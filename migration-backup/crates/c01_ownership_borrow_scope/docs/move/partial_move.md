# Partial Destructuring in Rust

在 Rust 中，部分解构语义（partial destructuring）指的
是在解构一个结构体、元组、枚举或组合类型时，只提取其中的一部分成员。
使用 `move` 关键字时，某些成员会被移动到新的变量中，而原始结构体的这些成员将不再有效。

## 部分无效的定义

“部分无效”通常指的是在解构后，原始数据结构中某些成员的所有权已经转移（被移动），
因此这些成员在原始结构体中不再可用。

具体来说：

- **移动（Move）**：当你将某个成员移动到一个新的变量时，原始结构体中的该成员将失去所有权，不能再被访问。
- **部分无效**：如果你只解构了结构体的一部分，未解构的部分仍然有效，但已解构的部分将无效。

## 是否支持后续操作

对于未被移动的成员，后续操作是支持的。例如：

```rust
struct MyStruct {
    a: i32,
    b: String,
}

fn main() {
    let my_struct = MyStruct {
        a: 10,
        b: String::from("Hello"),
    };

    // 部分解构，移动 b
    let MyStruct { a, b } = my_struct;

    // 这里 a 是有效的，但 my_struct.b 已经无效
    println!("a: {}", a); // 输出: a: 10
    // println!("{}", my_struct.b); // 这将导致编译错误，因为 b 已经被移动

    // 尝试解构 my_struct.a 将不会导致编译错误
    // 但 my_struct 已经无效，不能再访问
    // println!("my_struct.a: {}", my_struct.a); // 这将导致编译错误
}
```

在这个例子中，`a` 仍然有效，而 `b` 已经被移动，因此 `my_struct.b` 将无法访问。
在解构后，未移动的成员（如 a）仍然有效，可以继续使用。
但是，原始结构体（如 my_struct）在解构后将无法访问已移动的成员（如 b），
并且尝试访问 my_struct.a 也会导致编译错误，因为 my_struct 的所有权已经转移。

## 总结

- 部分解构语义允许你只提取结构体的一部分。
- 移动的成员在原始结构体中将变为无效。
- 被移动的成员变量在原始结构体中无效，无法继续解构或访问。
- 而原始结构体此时部分无效了,不能再访问.
- 当部分成员的所有权转移时，整个类型的所有权并不会被转移，但已移动的成员在原始实例中将变为无效。未移动的成员仍然可以继续使用。
- Rust 的所有权系统是基于整体类型的，而不是部分成员。
