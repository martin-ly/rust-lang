# 分布式系统中的所有权

```text
[分布式系统中的所有权](#分布式系统中的所有权)
[分布式所有权模型](#分布式所有权模型)
[一致性协议与资源转移](#一致性协议与资源转移)
[容错与所有权恢复](#容错与所有权恢复)
[去中心化系统中的所有权证明](#去中心化系统中的所有权证明)
```

## 目录结构

- [分布式系统中的所有权](#分布式系统中的所有权)
  - [目录结构](#目录结构)
  - [分布式所有权模型](#分布式所有权模型)
    - [一致性协议与资源转移](#一致性协议与资源转移)
    - [故障恢复中的所有权](#故障恢复中的所有权)
    - [所有权与共享资源协调](#所有权与共享资源协调)
  - [所有权驱动的契约验证](#所有权驱动的契约验证)
    - [基于所有权的接口契约](#基于所有权的接口契约)
    - [所有权协议验证](#所有权协议验证)
    - [基于类型的动态验证](#基于类型的动态验证)
    - [所有权驱动的契约自动化](#所有权驱动的契约自动化)
  - [所有权与领域特定语言](#所有权与领域特定语言)
    - [资源感知的语言嵌入](#资源感知的语言嵌入)
    - [所有权类型的DSL表达](#所有权类型的dsl表达)
    - [编码资源状态与流转](#编码资源状态与流转)
    - [可组合的资源抽象](#可组合的资源抽象)
  - [所有权与程序正确性](#所有权与程序正确性)
    - [编译期验证与运行时安全](#编译期验证与运行时安全)
    - [资源泄漏与生命周期](#资源泄漏与生命周期)
    - [所有权优化与性能](#所有权优化与性能)
    - [自定义的内存分配策略](#自定义的内存分配策略)
  - [所有权与未来趋势](#所有权与未来趋势)
    - [类型系统发展与所有权](#类型系统发展与所有权)
    - [并发与所有权协同](#并发与所有权协同)
    - [所有权与安全通信](#所有权与安全通信)
    - [所有权范式的跨语言应用](#所有权范式的跨语言应用)
  - [结论](#结论)
    - [所有权系统的优势与限制](#所有权系统的优势与限制)
    - [1.2 并发安全的自动验证](#12-并发安全的自动验证)
    - [1.3 资源管理的明确语义](#13-资源管理的明确语义)
  - [2. 所有权系统的限制](#2-所有权系统的限制)
    - [2.1 生命周期标注的复杂性](#21-生命周期标注的复杂性)
    - [2.2 对特定架构的限制](#22-对特定架构的限制)
    - [2.3 学习曲线的陡峭](#23-学习曲线的陡峭)
  - [3. 应用场景适合度](#3-应用场景适合度)
    - [3.1 最适合的应用场景](#31-最适合的应用场景)
    - [3.2 挑战较大的应用场景](#32-挑战较大的应用场景)
    - [3.3 权衡与选择](#33-权衡与选择)
    - [面向未来的所有权系统](#面向未来的所有权系统)
    - [1.2 降低复杂性的工具与抽象](#12-降低复杂性的工具与抽象)
  - [2. 其他语言中的所有权](#2-其他语言中的所有权)
    - [2.1 主流语言采纳所有权的趋势](#21-主流语言采纳所有权的趋势)
    - [2.2 混合所有权模型的探索](#22-混合所有权模型的探索)
  - [3. 未来研究方向](#3-未来研究方向)
    - [3.1 自动化所有权推导与验证](#31-自动化所有权推导与验证)
    - [3.2 跨语言所有权系统的标准化](#32-跨语言所有权系统的标准化)
  - [4. 所有权系统对软件工程的深远影响](#4-所有权系统对软件工程的深远影响)
  - [总结](#总结)

## 分布式所有权模型

分布式系统中的所有权概念与实现：

1. **跨节点所有权**
   - 分布式环境中的所有权概念扩展
   - 系统级所有权追踪机制

2. **分布式资源管理**
   - 使用所有权保证分布式资源安全
   - 防止资源泄漏和重复释放

3. **全局所有权协议**
   - 定义所有权转移的分布式协议
   - 所有权与分布式系统的容错

```rust
// 分布式所有权模型示例

// 1. 分布式节点和资源标识
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
struct NodeId(u32);

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
struct ResourceId(u64);

// 全局唯一资源标识
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
struct GlobalResourceId {
    node: NodeId,
    resource: ResourceId,
}

// 资源类型
enum ResourceType {
    File,
    Memory,
    Computation,
    Database,
}

// 2. 分布式资源
struct DistributedResource {
    id: GlobalResourceId,
    resource_type: ResourceType,
    size: usize,
    owner: Option<NodeId>, // 当前所有者节点
}

// 所有权令牌 - 表示资源的所有权
struct OwnershipToken {
    resource_id: GlobalResourceId,
    sequence: u64, // 所有权转移序列号，防止过期所有权
}

// 资源访问引用 - 类似借用
struct ResourceReference {
    resource_id: GlobalResourceId,
    expires_at: std::time::Instant,
    is_mutable: bool,
}

// 3. 分布式所有权管理器
struct DistributedOwnershipManager {
    node_id: NodeId,
    resources: std::collections::HashMap<GlobalResourceId, DistributedResource>,
    owned_tokens: std::collections::HashMap<GlobalResourceId, OwnershipToken>,
    borrowed_refs: std::collections::HashMap<GlobalResourceId, Vec<ResourceReference>>,
    // 在实际系统中会有网络通信组件
}

impl DistributedOwnershipManager {
    fn new(node_id: NodeId) -> Self {
        DistributedOwnershipManager {
            node_id,
            resources: std::collections::HashMap::new(),
            owned_tokens: std::collections::HashMap::new(),
            borrowed_refs: std::collections::HashMap::new(),
        }
    }
    
    // 创建和注册新资源
    fn create_resource(&mut self, resource_type: ResourceType, size: usize) -> GlobalResourceId {
        // 生成资源 ID
        static mut NEXT_RESOURCE_ID: u64 = 1;
        let resource_id = unsafe {
            let id = NEXT_RESOURCE_ID;
            NEXT_RESOURCE_ID += 1;
            ResourceId(id)
        };
        
        let global_id = GlobalResourceId {
            node: self.node_id,
            resource: resource_id,
        };
        
        // 创建资源
        let resource = DistributedResource {
            id: global_id,
            resource_type,
            size,
            owner: Some(self.node_id), // 初始所有者是创建节点
        };
        
        println!("节点 {:?} 创建 {:?} 资源，大小 {}", self.node_id, resource_type, size);
        
        // 创建所有权令牌
        let token = OwnershipToken {
            resource_id: global_id,
            sequence: 1,
        };
        
        // 注册资源和所有权
        self.resources.insert(global_id, resource);
        self.owned_tokens.insert(global_id, token);
        
        global_id
    }
    
    // 转移资源所有权到另一个节点
    fn transfer_ownership(&mut self, resource_id: GlobalResourceId, to_node: NodeId) -> Result<(), &'static str> {
        // 检查是否拥有资源
        let token = self.owned_tokens.get(&resource_id)
            .ok_or("没有此资源的所有权")?;
            
        let resource = self.resources.get_mut(&resource_id)
            .ok_or("资源不存在")?;
            
        if resource.owner != Some(self.node_id) {
            return Err("不是资源所有者");
        }
        
        println!("节点 {:?} 转移资源 {:?} 所有权到节点 {:?}", 
            self.node_id, resource_id, to_node);
        
        // 更新资源所有者
        resource.owner = Some(to_node);
        
        // 创建新的所有权令牌
        let new_token = OwnershipToken {
            resource_id,
            sequence: token.sequence + 1,
        };
        
        // 删除自己的所有权令牌
        self.owned_tokens.remove(&resource_id);
        
        // 在实际系统中，这里会通过网络发送令牌到目标节点
        println!("发送所有权令牌到节点 {:?}", to_node);
        
        Ok(())
    }
    
    // 接收所有权令牌
    fn receive_ownership(&mut self, token: OwnershipToken) -> Result<(), &'static str> {
        let resource_id = token.resource_id;
        
        // 检查资源是否存在
        let resource = self.resources.get_mut(&resource_id)
            .ok_or("资源不存在于本地")?;
            
        // 检查所有权转移是否预期
        if resource.owner != Some(self.node_id) {
            return Err("未预期的所有权转移");
        }
        
        // 存储所有权令牌
        self.owned_tokens.insert(resource_id, token);
        
        println!("节点 {:?} 接收资源 {:?} 的所有权", self.node_id, resource_id);
        
        Ok(())
    }
    
    // 请求对资源的借用（类似于借用引用）
    fn borrow_resource(&self, resource_id: GlobalResourceId, mutable: bool) -> Result<ResourceReference, &'static str> {
        // 检查资源是否存在
        let resource = self.resources.get(&resource_id)
            .ok_or("资源不存在")?;
            
        // 查找资源的所有者
        let owner = resource.owner.ok_or("资源没有所有者")?;
        
        // 如果我们是所有者，可以直接借用
        if owner == self.node_id {
            // 检查是否有冲突的借用
            if mutable {
                if let Some(refs) = self.borrowed_refs.get(&resource_id) {
                    if !refs.is_empty() {
                        return Err("已存在借用，无法创建可变借用");
                    }
                }
            }
            
            // 创建借用引用
            let reference = ResourceReference {
                resource_id,
                expires_at: std::time::Instant::now() + std::time::Duration::from_secs(30),
                is_mutable: mutable,
            };
            
            println!("节点 {:?} 创建对资源 {:?} 的{}借用",
                self.node_id, resource_id, if mutable { "可变" } else { "不可变" });
                
            return Ok(reference);
        }
        
        // 如果我们不是所有者，需要从所有者请求借用
        // 在实际系统中，这会发送网络请求
        println!("从节点 {:?} 请求资源 {:?} 的{}借用",
            owner, resource_id, if mutable { "可变" } else { "不可变" });
            
        // 模拟请求结果
        Err("需要网络请求借用")
    }
    
    // 接收借用请求（针对我们拥有的资源）
    fn handle_borrow_request(&mut self, requester: NodeId, resource_id: GlobalResourceId, mutable: bool) -> Result<(), &'static str> {
        // 检查我们是否拥有此资源
        if !self.owned_tokens.contains_key(&resource_id) {
            return Err("不拥有此资源");
        }
        
        // 检查是否有冲突的借用
        if mutable {
            if let Some(refs) = self.borrowed_refs.get(&resource_id) {
                if !refs.is_empty() {
                    return Err("已存在借用，无法授予可变借用");
                }
            }
        } else {
            if let Some(refs) = self.borrowed_refs.get(&resource_id) {
                for r in refs {
                    if r.is_mutable {
                        return Err("已存在可变借用，无法授予不可变借用");
                    }
                }
            }
        }
        
        // 创建借用引用
        let reference = ResourceReference {
            resource_id,
            expires_at: std::time::Instant::now() + std::time::Duration::from_secs(30),
            is_mutable: mutable,
        };
        
        // 记录借用
        self.borrowed_refs.entry(resource_id)
            .or_insert_with(Vec::new)
            .push(reference);
            
        println!("节点 {:?} 授予节点 {:?} 对资源 {:?} 的{}借用",
            self.node_id, requester, resource_id, if mutable { "可变" } else { "不可变" });
            
        // 在实际系统中，这会向请求者发送资源引用
        
        Ok(())
    }
    
    // 释放借用
    fn release_borrow(&mut self, reference: ResourceReference) {
        println!("释放对资源 {:?} 的借用", reference.resource_id);
        
        if let Some(refs) = self.borrowed_refs.get_mut(&reference.resource_id) {
            refs.retain(|r| r.expires_at != reference.expires_at);
        }
    }
    
    // 销毁资源（必须拥有所有权）
    fn destroy_resource(&mut self, resource_id: GlobalResourceId) -> Result<(), &'static str> {
        // 检查是否拥有资源
        if !self.owned_tokens.contains_key(&resource_id) {
            return Err("不拥有此资源");
        }
        
        // 检查是否有活跃的借用
        if let Some(refs) = self.borrowed_refs.get(&resource_id) {
            if !refs.is_empty() {
                return Err("资源有活跃的借用，无法销毁");
            }
        }
        
        // 从管理中移除资源
        self.resources.remove(&resource_id);
        self.owned_tokens.remove(&resource_id);
        self.borrowed_refs.remove(&resource_id);
        
        println!("节点 {:?} 销毁资源 {:?}", self.node_id, resource_id);
        
        Ok(())
    }
}

// 4. 分布式资源使用示例
fn distributed_ownership_example() {
    // 创建两个节点的所有权管理器
    let mut node1_mgr = DistributedOwnershipManager::new(NodeId(1));
    let mut node2_mgr = DistributedOwnershipManager::new(NodeId(2));
    
    // 节点1创建资源
    let file_id = node1_mgr.create_resource(ResourceType::File, 1024);
    let memory_id = node1_mgr.create_resource(ResourceType::Memory, 4096);
    
    println!("创建的文件资源 ID: {:?}", file_id);
    println!("创建的内存资源 ID: {:?}", memory_id);
    
    // 节点2也需要知道这些资源（在实际系统中通过网络发现或注册）
    node2_mgr.resources.insert(file_id, DistributedResource {
        id: file_id,
        resource_type: ResourceType::File,
        size: 1024,
        owner: Some(NodeId(1)),
    });
    
    node2_mgr.resources.insert(memory_id, DistributedResource {
        id: memory_id,
        resource_type: ResourceType::Memory,
        size: 4096,
        owner: Some(NodeId(1)),
    });
    
    // 节点1借用自己的资源（本地借用）
    let file_ref = node1_mgr.borrow_resource(file_id, false).unwrap();
    println!("节点1获得对文件的借用");
    
    // 节点1尝试转移文件所有权到节点2
    if let Err(e) = node1_mgr.transfer_ownership(file_id, NodeId(2)) {
        println!("转移失败: {}", e);
    } else {
        println!("文件所有权从节点1转移到节点2");
        
        // 模拟节点2接收所有权令牌
        let token = OwnershipToken {
            resource_id: file_id,
            sequence: 2, // 转移后的序列号
        };
        
        node2_mgr.receive_ownership(token).unwrap();
    }
    
    // 节点1释放文件借用
    node1_mgr.release_borrow(file_ref);
    
    // 重新尝试转移
    match node1_mgr.transfer_ownership(file_id, NodeId(2)) {
        Ok(_) => {
            println!("文件所有权成功转移到节点2");
            
            // 模拟节点2接收所有权令牌
            let token = OwnershipToken {
                resource_id: file_id,
                sequence: 2,
            };
            
            node2_mgr.receive_ownership(token).unwrap();
            
            // 节点2现在拥有文件，可以销毁它
            node2_mgr.destroy_resource(file_id).unwrap();
        },
        Err(e) => println!("转移失败: {}", e),
    }
    
    // 节点1仍然拥有内存资源
    match node1_mgr.destroy_resource(memory_id) {
        Ok(_) => println!("节点1销毁了内存资源"),
        Err(e) => println!("销毁内存资源失败: {}", e),
    }
}
```

### 一致性协议与资源转移

分布式一致性算法中的所有权模型：

1. **一致性协议中的所有权语义**
   - 使用所有权表达分布式一致性
   - 资源所有权作为共识对象

2. **安全的分布式转移**
   - 原子性所有权转移协议
   - 防止所有权丢失和重复

3. **基于所有权的事务机制**
   - 所有权实现的分布式事务
   - 解决分布式事务的一致性挑战

```rust
// 一致性协议与资源转移示例

// 1. 节点和资源标识
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct NodeId(u32);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct ResourceKey(u64);

// 操作类型
#[derive(Debug, Clone)]
enum Operation {
    Read(ResourceKey),
    Write(ResourceKey, Vec<u8>),
    Transfer(ResourceKey, NodeId),
    Delete(ResourceKey),
}

// 操作结果
#[derive(Debug, Clone)]
enum OperationResult {
    Success,
    Value(Vec<u8>),
    Error(String),
}

// 2. 日志条目
#[derive(Debug, Clone)]
struct LogEntry {
    term: u64,
    index: u64,
    operation: Operation,
}

// 3. 一致性状态机
struct ConsensusStateMachine {
    node_id: NodeId,
    current_term: u64,
    voted_for: Option<NodeId>,
    log: Vec<LogEntry>,
    commit_index: u64,
    last_applied: u64,
    state: std::collections::HashMap<ResourceKey, ResourceState>,
}

// 资源状态
#[derive(Debug, Clone)]
struct ResourceState {
    owner: NodeId,
    data: Vec<u8>,
    version: u64,
}

impl ConsensusStateMachine {
    fn new(node_id: NodeId) -> Self {
        ConsensusStateMachine {
            node_id,
            current_term: 0,
            voted_for: None,
            log: Vec::new(),
            commit_index: 0,
            last_applied: 0,
            state: std::collections::HashMap::new(),
        }
    }
    
    // 追加日志条目
    fn append_entry(&mut self, entry: LogEntry) -> bool {
        // 在实际系统中，这会验证条目的一致性
        if entry.term < self.current_term {
            return false;
        }
        
        self.log.push(entry);
        println!("节点 {:?} 追加日志条目: {:?}", self.node_id, entry.operation);
        
        true
    }
    
    // 应用日志条目到状态机
    fn apply_log_entries(&mut self) {
        while self.last_applied < self.commit_index && self.last_applied < self.log.len() as u64 {
            self.last_applied += 1;
            let entry_idx = (self.last_applied - 1) as usize;
            let entry = &self.log[entry_idx];
            
            self.apply_operation(&entry.operation);
        }
    }
    
    // 应用单个操作
    fn apply_operation(&mut self, operation: &Operation) {
        match operation {
            Operation::Read(_) => {
                // 读操作在apply阶段不执行任何操作
            },
            Operation::Write(key, data) => {
                println!("节点 {:?} 应用写入操作: 键={:?}, 数据长度={}", 
                    self.node_id, key, data.len());
                
                // 检查是否拥有资源
                if let Some(state) = self.state.get_mut(key) {
                    if state.owner == self.node_id {
                        state.data = data.clone();
                        state.version += 1;
                    } else {
                        println!("警告: 尝试写入非所有者的资源");
                    }
                } else {
                    // 创建新资源
                    self.state.insert(*key, ResourceState {
                        owner: self.node_id,
                        data: data.clone(),
                        version: 1,
                    });
                }
            },
            Operation::Transfer(key, to_node) => {
                println!("节点 {:?} 应用转移操作: 键={:?}, 目标节点={:?}", 
                    self.node_id, key, to_node);
                
                if let Some(state) = self.state.get_mut(key) {
                    if state.owner == self.node_id {
                        state.owner = *to_node;
                        state.version += 1;
                        println!("资源 {:?} 所有权转移到节点 {:?}", key, to_node);
                    } else {
                        println!("警告: 尝试转移非所有者的资源");
                    }
                } else {
                    println!("警告: 尝试转移不存在的资源");
                }
            },
            Operation::Delete(key) => {
                println!("节点 {:?} 应用删除操作: 键={:?}", self.node_id, key);
                
                if let Some(state) = self.state.get(key) {
                    if state.owner == self.node_id {
                        self.state.remove(key);
                        println!("删除资源 {:?}", key);
                    } else {
                        println!("警告: 尝试删除非所有者的资源");
                    }
                } else {
                    println!("警告: 尝试删除不存在的资源");
                }
            },
        }
    }
    
    // 执行操作（供客户端调用）
    fn execute_operation(&mut self, operation: Operation) -> OperationResult {
        match &operation {
            Operation::Read(key) => {
                // 读操作不需要共识，直接执行
                if let Some(state) = self.state.get(key) {
                    println!("节点 {:?} 执行读取操作: 键={:?}", self.node_id, key);
                    return OperationResult::Value(state.data.clone());
                } else {
                    return OperationResult::Error("资源不存在".to_string());
                }
            },
            _ => {
                // 写操作需要共识
                // 在实际系统中，会将操作提交给领导者并等待共识
                
                // 创建日志条目
                let entry = LogEntry {
                    term: self.current_term,
                    index: self.log.len() as u64 + 1,
                    operation: operation.clone(),
                };
                
                // 追加到本地日志
                self.append_entry(entry);
                
                // 模拟提交（在实际系统中，这需要多数节点确认）
                self.commit_index = self.log.len() as u64;
                
                // 应用日志条目
                self.apply_log_entries();
                
                OperationResult::Success
            }
        }
    }
    
    // 获取资源所有者
    fn get_resource_owner(&self, key: ResourceKey) -> Option<NodeId> {
        self.state.get(&key).map(|state| state.owner)
    }
}

// 4. 分布式事务协调器
struct TransactionCoordinator {
    node_id: NodeId,
    state_machine: ConsensusStateMachine,
    pending_transactions: std::collections::HashMap<u64, Transaction>,
    next_tx_id: u64,
}

// 事务
struct Transaction {
    id: u64,
    operations: Vec<Operation>,
    status: TransactionStatus,
}

enum TransactionStatus {
    Pending,
    Committed,
    Aborted,
}

impl TransactionCoordinator {
    fn new(node_id: NodeId) -> Self {
        TransactionCoordinator {
            node_id,
            state_machine: ConsensusStateMachine::new(node_id),
            pending_transactions: std::collections::HashMap::new(),
            next_tx_id: 1,
        }
    }
    
    // 开始新事务
    fn begin_transaction(&mut self) -> u64 {
        let tx_id = self.next_tx_id;
        self.next_tx_id += 1;
        
        self.pending_transactions.insert(tx_id, Transaction {
            id: tx_id,
            operations: Vec::new(),
            status: TransactionStatus::Pending,
        });
        
        println!("节点 {:?} 开始事务 {}", self.node_id, tx_id);
        
        tx_id
    }
    
    // 向事务添加操作
    fn add_operation(&mut self, tx_id: u64, operation: Operation) -> Result<(), String> {
        let transaction = self.pending_transactions.get_mut(&tx_id)
            .ok_or_else(|| format!("事务 {} 不存在", tx_id))?;
            
        if let TransactionStatus::Pending = transaction.status {
            transaction.operations.push(operation);
            Ok(())
        } else {
            Err(format!("事务 {} 已完成或中止", tx_id))
        }
    }
    
    // 提交事务
    fn commit_transaction(&mut self, tx_id: u64) -> Result<(), String> {
        let transaction = self.pending_transactions.get_mut(&tx_id)
            .ok_or_else(|| format!("事务 {} 不存在", tx_id))?;
            
        if let TransactionStatus::Pending = transaction.status {
            println!("节点 {:?} 提交事务 {}", self.node_id, tx_id);
            
            // 在实际系统中，这会实现两阶段提交
            // 1. 准备阶段
            println!("准备阶段：验证所有操作");
            
            // 验证所有资源操作的有效性
            for op in &transaction.operations {
                match op {
                    Operation::Write(key, _) | Operation::Transfer(key, _) | Operation::Delete(key) => {
                        // 检查是否拥有资源
                        if let Some(owner) = self.state_machine.get_resource_owner(*key) {
                            if owner != self.node_id {
                                transaction.status = TransactionStatus::Aborted;
                                return Err(format!("资源 {:?} 不属于节点 {:?}", key, self.node_id));
                            }
                        } else if matches!(op, Operation::Write(_, _) | Operation::Transfer(_, _)) {
                            // 创建新资源操作允许
                        } else {
                            transaction.status = TransactionStatus::Aborted;
                            return Err(format!("资源 {:?} 不存在，无法删除", key));
                        }
                    },
                    Operation::Read(_) => { /* 读操作总是有效的 */ }
                }
            }
            
            // 2. 提交阶段
            println!("提交阶段：执行所有操作");
            
            // 执行所有操作
            for op in &transaction.operations {
                self.state_machine.execute_operation(op.clone());
            }
            
            transaction.status = TransactionStatus::Committed;
            Ok(())
        } else {
            Err(format!("事务 {} 已完成或中止", tx_id))
        }
    }
    
    // 中止事务
    fn abort_transaction(&mut self, tx_id: u64) -> Result<(), String> {
        let transaction = self.pending_transactions.get_mut(&tx_id)
            .ok_or_else(|| format!("事务 {} 不存在", tx_id))?;
            
        if let TransactionStatus::Pending = transaction.status {
            println!("节点 {:?} 中止事务 {}", self.node_id, tx_id);
            transaction.status = TransactionStatus::Aborted;
            Ok(())
        } else {
            Err(format!("事务 {} 已完成或中止", tx_id))
        }
    }
}

// 5. 一致性协议与资源转移示例
fn consensus_resource_transfer_example() {
    // 创建两个节点的事务协调器
    let mut node1 = TransactionCoordinator::new(NodeId(1));
    let mut node2 = TransactionCoordinator::new(NodeId(2));
    
    // 节点1创建资源
    let tx1 = node1.begin_transaction();
    let resource_key = ResourceKey(101);
    
    node1.add_operation(tx1, Operation::Write(resource_key, b"初始数据".to_vec())).unwrap();
    node1.commit_transaction(tx1).unwrap();
    
    println!("节点1创建资源 {:?} 成功", resource_key);
    
    // 读取资源
    if let OperationResult::Value(data) = node1.state_machine.execute_operation(Operation::Read(resource_key)) {
        println!("读取资源 {:?}: {}", resource_key, String::from_utf8_lossy(&data));
    }
    
    // 转移资源所有权到节点2
    let tx2 = node1.begin_transaction();
    node1.add_operation(tx2, Operation::Transfer(resource_key, NodeId(2))).unwrap();
    node1.commit_transaction(tx2).unwrap();
    
    println!("资源 {:?} 所有权从节点1转移到节点2", resource_key);
    
    // 模拟节点2通过共识发现资源转移
    // 在实际系统中，这通过一致性协议自动完成
    if let Some(owner) = node1.state_machine.get_resource_owner(resource_key) {
        println!("节点1视角：资源 {:?} 的所有者是 {:?}", resource_key, owner);
        
        // 复制资源状态到节点2
        if owner == NodeId(2) {
            if let OperationResult::Value(data) = node1.state_machine.execute_operation(Operation::Read(resource_key)) {
                node2.state_machine.execute_operation(Operation::Write(resource_key, data.clone()));
                
                // 设置所有者
                if let Some(state) = node2.state_machine.state.get_mut(&resource_key) {
                    state.owner = NodeId(2);
                }
                
                println!("节点2接收资源 {:?} 的所有权", resource_key);
            }
        }
    }
    
    // 现在节点2可以修改资源
    let tx3 = node2.begin_transaction();
    node2.add_operation(tx3, Operation::Write(resource_key, b"节点2修改的数据".to_vec())).unwrap();
    node2.commit_transaction(tx3).unwrap();
    
    // 读取修改后的资源
    if let OperationResult::Value(data) = node2.state_machine.execute_operation(Operation::Read(resource_key)) {
        println!("节点2读取资源 {:?}: {}", resource_key, String::from_utf8_lossy(&data));
    }
    
    // 节点1尝试修改已转移的资源（应该失败）
    let tx4 = node1.begin_transaction();
    node1.add_operation(tx4, Operation::Write(resource_key, b"节点1尝试修改".to_vec())).unwrap();
    
    match node1.commit_transaction(tx4) {
        Ok(_) => println!("意外成功：节点1修改了不属于自己的资源"),
        Err(e) => println!("预期的错误：{}", e),
    }
    
    // 节点2删除资源
    let tx5 = node2.begin_transaction();
    node2.add_operation(tx5, Operation::Delete(resource_key)).unwrap();
    node2.commit_transaction(tx5).unwrap();
    
    println!("节点2删除资源 {:?}", resource_key);
}
```

### 故障恢复中的所有权

分布式系统中的故障恢复与所有权：

1. **所有权恢复协议**
   - 节点故障时的所有权回收
   - 一致性状态恢复

2. **租约与所有权超时**
   - 使用租约模型实现临时所有权
   - 防止故障节点持有所有权导致资源不可用

3. **所有权证明机制**
   - 验证节点的资源所有权断言
   - 解决冲突所有权声明

```rust
// 故障恢复中的所有权示例

// 1. 租约机制
#[derive(Debug, Clone)]
struct Lease {
    resource_id: GlobalResourceId,
    owner: NodeId,
    expires_at: std::time::Instant,
    lease_id: u64,
}

// 2. 租约管理器
struct LeaseManager {
    leases: std::collections::HashMap<GlobalResourceId, Lease>,
    next_lease_id: u64,
}

impl LeaseManager {
    fn new() -> Self {
        LeaseManager {
            leases: std::collections::HashMap::new(),
            next_lease_id: 1,
        }
    }
    
    // 分配租约
    fn grant_lease(&mut self, resource_id: GlobalResourceId, owner: NodeId, duration: std::time::Duration) -> Lease {
        let lease_id = self.next_lease_id;
        self.next_lease_id += 1;
        
        let expires_at = std::time::Instant::now() + duration;
        
        let lease = Lease {
            resource_id,
            owner,
            expires_at,
            lease_id,
        };
        
        self.leases.insert(resource_id, lease.clone());
        
        println!("为节点 {:?} 分配资源 {:?} 的租约，有效期 {}s，租约ID {}",
            owner, resource_id, duration.as_secs(), lease_id);
            
        lease
    }
    
    // 续约
    fn renew_lease(&mut self, lease_id: u64, duration: std::time::Duration) -> Result<Lease, &'static str> {
        // 查找租约
        for (_, lease) in self.leases.iter_mut() {
            if lease.lease_id == lease_id {
                // 检查是否已过期
                if lease.expires_at <= std::time::Instant::now() {
                    return Err("租约已过期");
                }
                
                // 更新过期时间
                lease.expires_at = std::time::Instant::now() + duration;
                
                println!("续约租约 {}，资源 {:?}，新有效期 {}s",
                    lease_id, lease.resource_id, duration.as_secs());
                    
                return Ok(lease.clone());
            }
        }
        
        Err("租约不存在")
    }
    
    // 释放租约
    fn release_lease(&mut self, lease_id: u64) -> Result<(), &'static str> {
        let mut resource_id = None;
        
        // 查找租约
        for (rid, lease) in &self.leases {
            if lease.lease_id == lease_id {
                resource_id = Some(*rid);
                break;
            }
        }
        
        if let Some(rid) = resource_id {
            self.leases.remove(&rid);
            println!("释放租约 {}，资源 {:?}", lease_id, rid);
            Ok(())
        } else {
            Err("租约不存在")
        }
    }
    
    // 回收过期租约
    fn recover_expired_leases(&mut self) -> Vec<GlobalResourceId> {
        let now = std::time::Instant::now();
        let mut expired = Vec::new();
        
        // 找出所有过期租约
        for (resource_id, lease) in &self.leases {
            if lease.expires_at <= now {
                expired.push(*resource_id);
            }
        }
        
        // 移除过期租约
        for resource_id in &expired {
            if let Some(lease) = self.leases.remove(resource_id) {
                println!("回收过期租约 {}，资源 {:?}，节点 {:?}",
                    lease.lease_id, resource_id, lease.owner);
            }
        }
        
        expired
    }
    
    // 验证租约有效性
    fn validate_lease(&self, lease_id: u64) -> Result<&Lease, &'static str> {
        let now = std::time::Instant::now();
        
        // 查找租约
        for (_, lease) in &self.leases {
            if lease.lease_id == lease_id {
                if lease.expires_at <= now {
                    return Err("租约已过期");
                }
                return Ok(lease);
            }
        }
        
        Err("租约不存在")
    }
}

// 3. 故障检测器
struct FailureDetector {
    nodes: std::collections::HashMap<NodeId, NodeStatus>,
}

#[derive(Debug, Clone, PartialEq)]
enum NodeStatus {
    Healthy,
    Suspected,
    Failed,
}

impl FailureDetector {
    fn new() -> Self {
        FailureDetector {
            nodes: std::collections::HashMap::new(),
        }
    }
    
    // 注册节点
    fn register_node(&mut self, node_id: NodeId) {
        self.nodes.insert(node_id, NodeStatus::Healthy);
        println!("注册节点 {:?} 为健康状态", node_id);
    }
    
    // 报告节点心跳
    fn heartbeat(&mut self, node_id: NodeId) -> Result<(), &'static str> {
        if let Some(status) = self.nodes.get_mut(&node_id) {
            if *status != NodeStatus::Failed {
                *status = NodeStatus::Healthy;
                // println!("收到节点 {:?} 的心跳", node_id);
                return Ok(());
            }
            return Err("节点已标记为失败");
        }
        Err("未知节点")
    }
    
    // 怀疑节点可能故障
    fn suspect_node(&mut self, node_id: NodeId) -> Result<(), &'static str> {
        if let Some(status) = self.nodes.get_mut(&node_id) {
            if *status == NodeStatus::Healthy {
                *status = NodeStatus::Suspected;
                println!("怀疑节点 {:?} 可能故障", node_id);
                return Ok(());
            }
        }
        Err("未知节点或节点已被怀疑/失败")
    }
    
    // 确认节点故障
    fn mark_node_failed(&mut self, node_id: NodeId) -> Result<(), &'static str> {
        if let Some(status) = self.nodes.get_mut(&node_id) {
            *status = NodeStatus::Failed;
            println!("确认节点 {:?} 已故障", node_id);
            return Ok(());
        }
        Err("未知节点")
    }
    
    // 恢复节点
    fn recover_node(&mut self, node_id: NodeId) -> Result<(), &'static str> {
        if let Some(status) = self.nodes.get_mut(&node_id) {
            *status = NodeStatus::Healthy;
            println!("节点 {:?} 已恢复", node_id);
            return Ok(());
        }
        Err("未知节点")
    }
    
    // 获取所有故障节点
    fn get_failed_nodes(&self) -> Vec<NodeId> {
        self.nodes.iter()
            .filter(|(_, status)| **status == NodeStatus::Failed)
            .map(|(node_id, _)| *node_id)
            .collect()
    }
}

// 4. 故障恢复协调器
struct FailoverCoordinator {
    lease_manager: LeaseManager,
    failure_detector: FailureDetector,
    resource_allocator: ResourceAllocator,
}

// 资源分配器
struct ResourceAllocator {
    resources: std::collections::HashMap<GlobalResourceId, ResourceAssignment>,
}

#[derive(Debug, Clone)]
struct ResourceAssignment {
    resource_id: GlobalResourceId,
    primary: NodeId,
    replicas: Vec<NodeId>,
}

impl ResourceAllocator {
    fn new() -> Self {
        ResourceAllocator {
            resources: std::collections::HashMap::new(),
        }
    }
    
    // 分配资源给节点
    fn assign_resource(&mut self, resource_id: GlobalResourceId, primary: NodeId, replicas: Vec<NodeId>) {
        let assignment = ResourceAssignment {
            resource_id,
            primary,
            replicas,
        };
        
        self.resources.insert(resource_id, assignment);
        
        println!("将资源 {:?} 分配给主节点 {:?}，副本节点 {:?}", 
            resource_id, primary, replicas);
    }
    
    // 重新分配资源
    fn reassign_resource(&mut self, resource_id: GlobalResourceId, new_primary: NodeId) -> Result<(), &'static str> {
        if let Some(assignment) = self.resources.get_mut(&resource_id) {
            let old_primary = assignment.primary;
            
            // 将旧主节点添加到副本列表
            if assignment.replicas.contains(&new_primary) {
                assignment.replicas.retain(|&node| node != new_primary);
                assignment.replicas.push(old_primary);
            } else {
                return Err("新主节点不在副本列表中");
            }
            
            // 设置新主节点
            assignment.primary = new_primary;
            
            println!("资源 {:?} 从主节点 {:?} 重新分配给主节点 {:?}",
                resource_id, old_primary, new_primary);
                
            Ok(())
        } else {
            Err("资源未分配")
        }
    }
    
    // 获取资源主节点
    fn get_primary(&self, resource_id: GlobalResourceId) -> Option<NodeId> {
        self.resources.get(&resource_id).map(|a| a.primary)
    }
    
    // 获取资源所有副本节点
    fn get_replicas(&self, resource_id: GlobalResourceId) -> Option<Vec<NodeId>> {
        self.resources.get(&resource_id).map(|a| a.replicas.clone())
    }
    
    // 检查节点是否可以访问资源
    fn can_access(&self, node_id: NodeId, resource_id: GlobalResourceId) -> bool {
        if let Some(assignment) = self.resources.get(&resource_id) {
            return assignment.primary == node_id || assignment.replicas.contains(&node_id);
        }
        false
    }
}

impl FailoverCoordinator {
    fn new() -> Self {
        FailoverCoordinator {
            lease_manager: LeaseManager::new(),
            failure_detector: FailureDetector::new(),
            resource_allocator: ResourceAllocator::new(),
        }
    }
    
    // 初始化系统
    fn initialize_system(&mut self, nodes: Vec<NodeId>) {
        for node in nodes {
            self.failure_detector.register_node(node);
        }
        println!("初始化故障恢复系统，注册 {} 个节点", nodes.len());
    }
    
    // 分配资源
    fn allocate_resource(&mut self, resource_id: GlobalResourceId, primary: NodeId, replicas: Vec<NodeId>) {
        // 分配资源
        self.resource_allocator.assign_resource(resource_id, primary, replicas);
        
        // 为主节点授予租约
        self.lease_manager.grant_lease(
            resource_id, 
            primary, 
            std::time::Duration::from_secs(30)
        );
    }
    
    // 处理节点心跳
    fn handle_heartbeat(&mut self, node_id: NodeId) {
        if let Ok(_) = self.failure_detector.heartbeat(node_id) {
            // 成功接收心跳，无需特殊处理
        } else {
            println!("忽略已故障节点 {:?} 的心跳", node_id);
        }
    }
    
    // 检测并处理故障
    fn check_for_failures(&mut self) {
        // 回收过期租约
        let expired_resources = self.lease_manager.recover_expired_leases();
        
        // 获取故障节点
        let failed_nodes = self.failure_detector.get_failed_nodes();
        
        // 处理故障节点持有的资源
        for node_id in &failed_nodes {
            println!("处理故障节点 {:?} 的资源", node_id);
            
            // 找出该节点作为主节点的所有资源
            let resources_to_reassign: Vec<_> = self.resource_allocator.resources.iter()
                .filter(|(_, assignment)| assignment.primary == *node_id)
                .map(|(resource_id, _)| *resource_id)
                .collect();
                
            // 为每个资源选择新的主节点
            for resource_id in resources_to_reassign {
                if let Some(replicas) = self.resource_allocator.get_replicas(resource_id) {
                    if let Some(&new_primary) = replicas.first() {
                        if let Ok(_) = self.resource_allocator.reassign_resource(resource_id, new_primary) {
                            // 为新主节点授予租约
                            self.lease_manager.grant_lease(
                                resource_id,
                                new_primary,
                                std::time::Duration::from_secs(30)
                            );
                        }
                    }
                }
            }
        }
        
        // 处理过期租约的资源
        for resource_id in expired_resources {
            if let Some(primary) = self.resource_allocator.get_primary(resource_id) {
                if !failed_nodes.contains(&primary) {
                    // 如果主节点没有故障，但租约过期，重新授予租约
                    self.lease_manager.grant_lease(
                        resource_id,
                        primary,
                        std::time::Duration::from_secs(30)
                    );
                }
            }
        }
    }
    
    // 模拟节点故障
    fn simulate_node_failure(&mut self, node_id: NodeId) {
        println!("\n模拟节点 {:?} 故障", node_id);
        self.failure_detector.mark_node_failed(node_id).unwrap();
        self.check_for_failures();
    }
    
    // 模拟节点恢复
    fn simulate_node_recovery(&mut self, node_id: NodeId) {
        println!("\n模拟节点 {:?} 恢复", node_id);
        self.failure_detector.recover_node(node_id).unwrap();
    }
}

// 5. 故障恢复示例
fn failure_recovery_example() {
    // 创建故障恢复协调器
    let mut coordinator = FailoverCoordinator::new();
    
    // 初始化系统，注册三个节点
    let node1 = NodeId(1);
    let node2 = NodeId(2);
    let node3 = NodeId(3);
    coordinator.initialize_system(vec![node1, node2, node3]);
    
    // 创建三个资源，并分配给不同节点
    let resource1 = GlobalResourceId { node: NodeId(0), resource: ResourceId(101) };
    let resource2 = GlobalResourceId { node: NodeId(0), resource: ResourceId(102) };
    let resource3 = GlobalResourceId { node: NodeId(0), resource: ResourceId(103) };
    
    coordinator.allocate_resource(resource1, node1, vec![node2, node3]);
    coordinator.allocate_resource(resource2, node2, vec![node1, node3]);
    coordinator.allocate_resource(resource3, node3, vec![node1, node2]);
    
    // 模拟心跳
    println!("\n模拟正常心跳");
    for _ in 0..3 {
        coordinator.handle_heartbeat(node1);
        coordinator.handle_heartbeat(node2);
        coordinator.handle_heartbeat(node3);
    }
    
    // 模拟节点1故障
    coordinator.simulate_node_failure(node1);
    
    // 查看资源1的新分配情况
    if let Some(primary) = coordinator.resource_allocator.get_primary(resource1) {
        println!("故障后资源 {:?} 的主节点是 {:?}", resource1, primary);
    }
    
    // 模拟节点1恢复
    coordinator.simulate_node_recovery(node1);
    
    // 恢复后，节点1会成为某些资源的副本，但不会自动成为主节点
    println!("\n检查节点1恢复后的资源访问权限");
    println!("节点1可以访问资源1: {}", coordinator.resource_allocator.can_access(node1, resource1));
    println!("节点1可以访问资源2: {}", coordinator.resource_allocator.can_access(node1, resource2));
    println!("节点1可以访问资源3: {}", coordinator.resource_allocator.can_access(node1, resource3));
    
    // 模拟主动重新分配资源1给节点1
    println!("\n尝试重新分配资源1给恢复的节点1");
    if let Some(primary) = coordinator.resource_allocator.get_primary(resource1) {
        if primary != node1 {
            if let Ok(_) = coordinator.resource_allocator.reassign_resource(resource1, node1) {
                coordinator.lease_manager.grant_lease(
                    resource1,
                    node1,
                    std::time::Duration::from_secs(30)
                );
            }
        }
    }
    
    // 查看重新分配后的情况
    if let Some(primary) = coordinator.resource_allocator.get_primary(resource1) {
        println!("重新分配后资源 {:?} 的主节点是 {:?}", resource1, primary);
    }
}
```

### 所有权与共享资源协调

分布式环境中的共享资源协调：

1. **分布式锁实现**
   - 资源独占访问与所有权语义
   - 非阻塞资源获取模式

2. **读写锁与共享所有权**
   - 多读单写模式的分布式实现
   - 引用计数与所有权共享

3. **资源通知和观察模式**
   - 资源变更传播机制
   - 基于所有权的订阅-发布模式

```rust
// 共享资源协调示例

// 1. 分布式锁
struct DistributedLock {
    resource_id: GlobalResourceId,
    lock_manager: LockManagerRef,
}

type LockManagerRef = Arc<Mutex<LockManager>>;

// 锁管理器
struct LockManager {
    locks: std::collections::HashMap<GlobalResourceId, LockEntry>,
}

struct LockEntry {
    owner: Option<NodeId>,
    waiters: Vec<NodeId>,
    lock_type: LockType,
    expires_at: Option<std::time::Instant>,
}

enum LockType {
    Exclusive,
    Shared { holders: Vec<NodeId> },
}

impl LockManager {
    fn new() -> Self {
        LockManager {
            locks: std::collections::HashMap::new(),
        }
    }
    
    // 尝试获取排他锁
    fn try_acquire_exclusive(&mut self, resource_id: GlobalResourceId, node_id: NodeId, timeout: Option<std::time::Duration>) 
        -> Result<bool, &'static str> 
    {
        // 检查锁是否存在
        let entry = self.locks.entry(resource_id).or_insert_with(|| LockEntry {
            owner: None,
            waiters: Vec::new(),
            lock_type: LockType::Exclusive,
            expires_at: None,
        });
        
        match &mut entry.lock_type {
            LockType::Exclusive => {
                // 如果锁未被持有或持有者就是请求者
                if entry.owner.is_none() || entry.owner == Some(node_id) {
                    entry.owner = Some(node_id);
                    
                    // 设置过期时间（如果有）
                    entry.expires_at = timeout.map(|t| std::time::Instant::now() + t);
                    
                    println!("节点 {:?} 获得资源 {:?} 的排他锁", node_id, resource_id);
                    return Ok(true);
                } else {
                    // 添加到等待队列
                    if !entry.waiters.contains(&node_id) {
                        entry.waiters.push(node_id);
                    }
                    
                    println!("节点 {:?} 无法获得资源 {:?} 的排他锁（已被 {:?} 持有）", 
                        node_id, resource_id, entry.owner);
                    return Ok(false);
                }
            },
            LockType::Shared { holders } => {
                // 如果有共享锁，无法获取排他锁
                if holders.is_empty() {
                    // 转换为排他锁
                    entry.lock_type = LockType::Exclusive;
                    entry.owner = Some(node_id);
                    
                    // 设置过期时间（如果有）
                    entry.expires_at = timeout.map(|t| std::time::Instant::now() + t);
                    
                    println!("节点 {:?} 获得资源 {:?} 的排他锁（从空闲共享锁转换）", 
                        node_id, resource_id);
                    return Ok(true);
                } else {
                    // 添加到等待队列
                    if !entry.waiters.contains(&node_id) {
                        entry.waiters.push(node_id);
                    }
                    
                    println!("节点 {:?} 无法获得资源 {:?} 的排他锁（有 {} 个共享锁持有者）", 
                        node_id, resource_id, holders.len());
                    return Ok(false);
                }
            }
        }
    }
    
    // 尝试获取共享锁
    fn try_acquire_shared(&mut self, resource_id: GlobalResourceId, node_id: NodeId, timeout: Option<std::time::Duration>) 
        -> Result<bool, &'static str> 
    {
        // 检查锁是否存在
        let entry = self.locks.entry(resource_id).or_insert_with(|| LockEntry {
            owner: None,
            waiters: Vec::new(),
            lock_type: LockType::Shared { holders: Vec::new() },
            expires_at: None,
        });
        
        match &mut entry.lock_type {
            LockType::Exclusive => {
                // 如果锁未被持有或持有者就是请求者
                if entry.owner.is_none() {
                    // 转换为共享锁
                    entry.lock_type = LockType::Shared { holders: vec![node_id] };
                    entry.owner = None;
                    
                    // 设置过期时间（如果有）
                    entry.expires_at = timeout.map(|t| std::time::Instant::now() + t);
                    
                    println!("节点 {:?} 获得资源 {:?} 的共享锁（从空闲排他锁转换）", 
                        node_id, resource_id);
                    return Ok(true);
                } else if entry.owner == Some(node_id) {
                    // 持有者降级锁
                    entry.lock_type = LockType::Shared { holders: vec![node_id] };
                    entry.owner = None;
                    
                    println!("节点 {:?} 将资源 {:?} 的排他锁降级为共享锁", 
                        node_id, resource_id);
                    return Ok(true);
                } else {
                    // 添加到等待队列
                    if !entry.waiters.contains(&node_id) {
                        entry.waiters.push(node_id);
                    }
                    
                    println!("节点 {:?} 无法获得资源 {:?} 的共享锁（已被 {:?} 排他持有）", 
                        node_id, resource_id, entry.owner);
                    return Ok(false);
                }
            },
            LockType::Shared { holders } => {
                // 如果该节点已持有共享锁
                if holders.contains(&node_id) {
                    return Ok(true);
                }
                
                // 添加新的共享锁持有者
                holders.push(node_id);
                
                // 设置过期时间（如果有）
                if entry.expires_at.is_none() {
                    entry.expires_at = timeout.map(|t| std::time::Instant::now() + t);
                }
                
                println!("节点 {:?} 获得资源 {:?} 的共享锁（现有 {} 个持有者）", 
                    node_id, resource_id, holders.len());
                return Ok(true);
            }
        }
    }
    
    // 释放锁
    fn release_lock(&mut self, resource_id: GlobalResourceId, node_id: NodeId) -> Result<(), &'static str> {
        if let Some(entry) = self.locks.get_mut(&resource_id) {
            match &mut entry.lock_type {
                LockType::Exclusive => {
                    if entry.owner == Some(node_id) {
                        entry.owner = None;
                        println!("节点 {:?} 释放资源 {:?} 的排他锁", node_id, resource_id);
                        
                        // 检查是否有等待者
                        self.check_waiters(resource_id);
                        
                        return Ok(());
                    } else {
                        return Err("节点不持有此排他锁");
                    }
                },
                LockType::Shared { holders } => {
                    if holders.contains(&node_id) {
                        holders.retain(|&n| n != node_id);
                        println!("节点 {:?} 释放资源 {:?} 的共享锁（剩余 {} 个持有者）", 
                            node_id, resource_id, holders.len());
                            
                        // 如果没有更多持有者，检查等待者
                        if holders.is_empty() {
                            self.check_waiters(resource_id);
                        }
                        
                        return Ok(());
                    } else {
                        return Err("节点不持有此共享锁");
                    }
                }
            }
        } else {
            return Err("锁不存在");
        }
    }
    
    // 检查并唤醒等待者
    fn check_waiters(&mut self, resource_id: GlobalResourceId) {
        if let Some(entry) = self.locks.get_mut(&resource_id) {
            // 如果有等待者，可以尝试唤醒第一个
            if !entry.waiters.is_empty() {
                let next_waiter = entry.waiters.remove(0);
                
                // 在实际系统中，会通知等待者锁可用
                println!("通知节点 {:?} 资源 {:?} 的锁现在可用", next_waiter, resource_id);
            }
        }
    }
    
    // 清理过期锁
    fn cleanup_expired_locks(&mut self) {
        let now = std::time::Instant::now();
        let mut expired = Vec::new();
        
        // 找出过期的锁
        for (&resource_id, entry) in &self.locks {
            if let Some(expires_at) = entry.expires_at {
                if expires_at <= now {
                    expired.push(resource_id);
                }
            }
        }
        
        // 清理过期锁
        for resource_id in expired {
            if let Some(entry) = self.locks.get(&resource_id) {
                match &entry.lock_type {
                    LockType::Exclusive => {
                        if let Some(owner) = entry.owner {
                            println!("锁过期：节点 {:?} 持有的资源 {:?} 排他锁", owner, resource_id);
                        }
                    },
                    LockType::Shared { holders } => {
                        println!("锁过期：资源 {:?} 的共享锁（{} 个持有者）", 
                            resource_id, holders.len());
                    }
                }
                
                // 移除锁
                self.locks.remove(&resource_id);
                
                // 检查等待者
                self.check_waiters(resource_id);
            }
        }
    }
}

impl DistributedLock {
    fn new(resource_id: GlobalResourceId, lock_manager: LockManagerRef) -> Self {
        DistributedLock {
            resource_id,
            lock_manager,
        }
    }
    
    // 尝试获取排他锁
    fn try_lock_exclusive(&self, node_id: NodeId, timeout: Option<std::time::Duration>) -> bool {
        let mut manager = self.lock_manager.lock().unwrap();
        match manager.try_acquire_exclusive(self.resource_id, node_id, timeout) {
            Ok(result) => result,
            Err(_) => false,
        }
    }
    
    // 尝试获取共享锁
    fn try_lock_shared(&self, node_id: NodeId, timeout: Option<std::time::Duration>) -> bool {
        let mut manager = self.lock_manager.lock().unwrap();
        match manager.try_acquire_shared(self.resource_id, node_id, timeout) {
            Ok(result) => result,
            Err(_) => false,
        }
    }
    
    // 释放锁
    fn unlock(&self, node_id: NodeId) -> bool {
        let mut manager = self.lock_manager.lock().unwrap();
        match manager.release_lock(self.resource_id, node_id) {
            Ok(_) => true,
            Err(_) => false,
        }
    }
}

// 2. 资源变更通知与订阅系统
struct ResourceNotificationSystem {
    subscriptions: std::collections::HashMap<GlobalResourceId, Vec<Subscription>>,
    next_sub_id: u64,
}

struct Subscription {
    id: u64,
    subscriber: NodeId,
    interest: ResourceInterest,
}

enum ResourceInterest {
    All,
    Write,
    Delete,
    OwnershipChange,
}

// 资源变更通知
#[derive(Debug, Clone)]
struct ResourceNotification {
    resource_id: GlobalResourceId,
    event_type: ResourceEventType,
    source: NodeId,
    timestamp: std::time::SystemTime,
}

#[derive(Debug, Clone)]
enum ResourceEventType {
    Created,
    Updated,
    Deleted,
    OwnershipChanged { old_owner: NodeId, new_owner: NodeId },
}

impl ResourceNotificationSystem {
    fn new() -> Self {
        ResourceNotificationSystem {
            subscriptions: std::collections::HashMap::new(),
            next_sub_id: 1,
        }
    }
    
    // 订阅资源变更
    fn subscribe(&mut self, resource_id: GlobalResourceId, node_id: NodeId, interest: ResourceInterest) -> u64 {
        let sub_id = self.next_sub_id;
        self.next_sub_id += 1;
        
        let subscription = Subscription {
            id: sub_id,
            subscriber: node_id,
            interest,
        };
        
        // 添加订阅
        self.subscriptions.entry(resource_id)
            .or_insert_with(Vec::new)
            .push(subscription);
            
        println!("节点 {:?} 订阅资源 {:?} 的变更", node_id, resource_id);
        
        sub_id
    }
    
    // 取消订阅
    fn unsubscribe(&mut self, resource_id: GlobalResourceId, subscription_id: u64) -> Result<(), &'static str> {
        if let Some(subs) = self.subscriptions.get_mut(&resource_id) {
            let before_len = subs.len();
            subs.retain(|s| s.id != subscription_id);
            
            if subs.len() < before_len {
                println!("取消订阅 ID {} 对资源 {:?} 的变更", subscription_id, resource_id);
                return Ok(());
            }
        }
        
        Err("订阅不存在")
    }
    
    // 发布资源变更通知
    fn publish(&self, notification: ResourceNotification) {
        let resource_id = notification.resource_id;
        
        if let Some(subs) = self.subscriptions.get(&resource_id) {
            for sub in subs {
                // 检查是否关注此类型的事件
                let should_notify = match (&notification.event_type, &sub.interest) {
                    (_, ResourceInterest::All) => true,
                    (ResourceEventType::Updated, ResourceInterest::Write) => true,
                    (ResourceEventType::Deleted, ResourceInterest::Delete) => true,
                    (ResourceEventType::OwnershipChanged { .. }, ResourceInterest::OwnershipChange) => true,
                    _ => false,
                };
                
                if should_notify {
                    println!("发送资源 {:?} 的 {:?} 事件通知给节点 {:?}", 
                        resource_id, notification.event_type, sub.subscriber);
                        
                    // 在实际系统中，这会通过网络发送通知
                }
            }
        }
    }
}

// 3. 分布式共享资源管理器
struct SharedResourceManager {
    node_id: NodeId,
    lock_manager: LockManagerRef,
    notification_system: Arc<Mutex<ResourceNotificationSystem>>,
    resources: std::collections::HashMap<GlobalResourceId, Arc<Mutex<Vec<u8>>>>,
}

impl SharedResourceManager {
    fn new(node_id: NodeId) -> Self {
        let lock_manager = Arc::new(Mutex::new(LockManager::new()));
        let notification_system = Arc::new(Mutex::new(ResourceNotificationSystem::new()));
        
        SharedResourceManager {
            node_id,
            lock_manager,
            notification_system,
            resources: std::collections::HashMap::new(),
        }
    }
    
    // 创建资源
    fn create_resource(&mut self, resource_id: GlobalResourceId, data: Vec<u8>) -> Result<(), &'static str> {
        // 检查资源是否已存在
        if self.resources.contains_key(&resource_id) {
            return Err("资源已存在");
        }
        
        // 获取排他锁
        let lock = DistributedLock::new(resource_id, self.lock_manager.clone());
        if !lock.try_lock_exclusive(self.node_id, Some(std::time::Duration::from_secs(5))) {
            return Err("无法获取锁");
        }
        
        // 创建资源
        self.resources.insert(resource_id, Arc::new(Mutex::new(data.clone())));
        
        println!("节点 {:?} 创建资源 {:?}，大小 {} 字节", 
            self.node_id, resource_id, data.len());
            
        // 发布创建通知
        let notification = ResourceNotification {
            resource_id,
            event_type: ResourceEventType::Created,
            source: self.node_id,
            timestamp: std::time::SystemTime::now(),
        };
        
        self.notification_system.lock().unwrap().publish(notification);
        
        // 释放锁
        lock.unlock(self.node_id);
        
        Ok(())
    }
    
    // 读取资源
    fn read_resource(&self, resource_id: GlobalResourceId) -> Result<Vec<u8>, &'static str> {
        // 检查资源是否存在
        let resource_data = match self.resources.get(&resource_id) {
            Some(data) => data,
            None => return Err("资源不存在"),
        };
        
        // 获取共享锁
        let lock = DistributedLock::new(resource_id, self.lock_manager.clone());
        if !lock.try_lock_shared(self.node_id, Some(std::time::Duration::from_secs(5))) {
            return Err("无法获取锁");
        }
        
        // 读取数据
        let data = resource_data.lock().unwrap().clone();
        
        println!("节点 {:?} 读取资源 {:?}，大小 {} 字节", 
            self.node_id, resource_id, data.len());
            
        // 释放锁
        lock.unlock(self.node_id);
        
        Ok(data)
    }
    
    // 更新资源
    fn update_resource(&self, resource_id: GlobalResourceId, data: Vec<u8>) -> Result<(), &'static str> {
        // 检查资源是否存在
        let resource_data = match self.resources.get(&resource_id) {
            Some(data) => data,
            None => return Err("资源不存在"),
        };
        
        // 获取排他锁
        let lock = DistributedLock::new(resource_id, self.lock_manager.clone());
        if !lock.try_lock_exclusive(self.node_id, Some(std::time::Duration::from_secs(5))) {
            return Err("无法获取锁");
        }
        
        // 更新数据
        *resource_data.lock().unwrap() = data.clone();
        
        println!("节点 {:?} 更新资源 {:?}，新大小 {} 字节", 
            self.node_id, resource_id, data.len());
            
        // 发布更新通知
        let notification = ResourceNotification {
            resource_id,
            event_type: ResourceEventType::Updated,
            source: self.node_id,
            timestamp: std::time::SystemTime::now(),
        };
        
        self.notification_system.lock().unwrap().publish(notification);
        
        // 释放锁
        lock.unlock(self.node_id);
        
        Ok(())
    }
    
    // 删除资源
    fn delete_resource(&mut self, resource_id: GlobalResourceId) -> Result<(), &'static str> {
        // 检查资源是否存在
        if !self.resources.contains_key(&resource_id) {
            return Err("资源不存在");
        }
        
        // 获取排他锁
        let lock = DistributedLock::new(resource_id, self.lock_manager.clone());
        if !lock.try_lock_exclusive(self.node_id, Some(std::time::Duration::from_secs(5))) {
            return Err("无法获取锁");
        }
        
        // 删除资源
        self.resources.remove(&resource_id);
        
        println!("节点 {:?} 删除资源 {:?}", self.node_id, resource_id);
        
        // 发布删除通知
        let notification = ResourceNotification {
            resource_id,
            event_type: ResourceEventType::Deleted,
            source: self.node_id,
            timestamp: std::time::SystemTime::now(),
        };
        
        self.notification_system.lock().unwrap().publish(notification);
        
        // 释放锁
        lock.unlock(self.node_id);
        
        Ok(())
    }
    
    // 订阅资源变更
    fn subscribe_to_changes(&self, resource_id: GlobalResourceId, interest: ResourceInterest) -> u64 {
        let mut notification_system = self.notification_system.lock().unwrap();
        notification_system.subscribe(resource_id, self.node_id, interest)
    }
    
    // 取消订阅
    fn unsubscribe(&self, resource_id: GlobalResourceId, subscription_id: u64) -> Result<(), &'static str> {
        let mut notification_system = self.notification_system.lock().unwrap();
        notification_system.unsubscribe(resource_id, subscription_id)
    }
    
    // 转移资源所有权
    fn transfer_ownership(&mut self, resource_id: GlobalResourceId, to_node: NodeId) -> Result<(), &'static str> {
        // 检查资源是否存在
        if !self.resources.contains_key(&resource_id) {
            return Err("资源不存在");
        }
        
        // 获取排他锁
        let lock = DistributedLock::new(resource_id, self.lock_manager.clone());
        if !lock.try_lock_exclusive(self.node_id, Some(std::time::Duration::from_secs(5))) {
            return Err("无法获取锁");
        }
        
        println!("节点 {:?} 转移资源 {:?} 所有权给节点 {:?}", 
            self.node_id, resource_id, to_node);
            
        // 在实际系统中，这会涉及到资源数据的网络传输
        // 这里我们模拟转移过程
        
        // 发布所有权变更通知
        let notification = ResourceNotification {
            resource_id,
            event_type: ResourceEventType::OwnershipChanged { 
                old_owner: self.node_id, 
                new_owner: to_node 
            },
            source: self.node_id,
            timestamp: std::time::SystemTime::now(),
        };
        
        self.notification_system.lock().unwrap().publish(notification);
        
        // 移除本地资源
        self.resources.remove(&resource_id);
        
        // 释放锁
        lock.unlock(self.node_id);
        
        Ok(())
    }
}

// 4. 共享资源使用示例
fn shared_resource_example() {
    // 创建两个节点的资源管理器
    let mut node1_mgr = SharedResourceManager::new(NodeId(1));
    let mut node2_mgr = SharedResourceManager::new(NodeId(2));
    
    // 创建资源
    let resource_id = GlobalResourceId { 
        node: NodeId(1), 
        resource: ResourceId(201) 
    };
    
    node1_mgr.create_resource(resource_id, b"这是一个共享资源的初始数据".to_vec()).unwrap();
    
    // 节点2订阅资源变更
    let sub_id = node2_mgr.subscribe_to_changes(resource_id, ResourceInterest::All);
    println!("节点2订阅资源变更，订阅ID: {}", sub_id);
    
    // 节点1更新资源
    node1_mgr.update_resource(resource_id, b"节点1更新后的资源数据".to_vec()).unwrap();
    
    // 模拟节点2接收到通知并读取更新后的数据
    // 在实际系统中，节点2会通过网络获取资源
    // 这里我们手动将资源数据复制到节点2
    node2_mgr.resources.insert(resource_id, Arc::new(Mutex::new(
        b"节点1更新后的资源数据".to_vec()
    )));
    
    // 节点2读取资源
    match node2_mgr.read_resource(resource_id) {
        Ok(data) => {
            println!("节点2读取资源数据: {}", String::from_utf8_lossy(&data));
        },
        Err(e) => {
            println!("节点2读取失败: {}", e);
        }
    }
    
    // 节点1转移资源所有权到节点2
    node1_mgr.transfer_ownership(resource_id, NodeId(2)).unwrap();
    
    // 节点2现在拥有资源，可以更新它
    node2_mgr.update_resource(resource_id, b"节点2更新后的资源数据".to_vec()).unwrap();
    
    // 节点2取消订阅
    node2_mgr.unsubscribe(resource_id, sub_id).unwrap();
    
    // 节点2删除资源
    node2_mgr.delete_resource(resource_id).unwrap();
}
```

## 所有权驱动的契约验证

### 基于所有权的接口契约

所有权如何影响接口设计和接口契约：

1. **所有权指导的接口设计**
   - 使用所有权表达资源责任
   - 接口与资源生命周期绑定

2. **接口不变性保证**
   - 所有权确保的状态不变性
   - 接口状态转换与所有权流转

3. **接口规范验证**
   - 基于所有权的前置和后置条件
   - 验证接口行为的完整性

```rust
// 基于所有权的接口契约示例

// 1. 所有权驱动的接口设计

// 资源标识符
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct ResourceId(u64);

// 资源类型
trait Resource {
    fn id(&self) -> ResourceId;
    fn size(&self) -> usize;
}

// 可变资源类型
trait MutableResource: Resource {
    fn set_data(&mut self, data: Vec<u8>) -> Result<(), &'static str>;
}

// 具体资源实现
struct DataResource {
    id: ResourceId,
    data: Vec<u8>,
}

impl Resource for DataResource {
    fn id(&self) -> ResourceId {
        self.id
    }
    
    fn size(&self) -> usize {
        self.data.len()
    }
}

impl MutableResource for DataResource {
    fn set_data(&mut self, data: Vec<u8>) -> Result<(), &'static str> {
        self.data = data;
        Ok(())
    }
}

// 2. 不变性保证的资源处理器
struct ResourceProcessor {
    name: String,
}

impl ResourceProcessor {
    fn new(name: &str) -> Self {
        ResourceProcessor {
            name: name.to_string(),
        }
    }
    
    // 消费型API - 接收所有权
    fn consume_and_transform(self, resource: DataResource) -> TransformedResource {
        println!("处理器 '{}' 消费资源 {:?}", self.name, resource.id());
        
        // 处理资源数据
        let original_data = resource.data;
        let transformed_data = original_data.into_iter()
            .map(|byte| byte.wrapping_add(1))
            .collect();
            
        // 返回转换后的新资源（不可变）
        TransformedResource {
            original_id: resource.id,
            data: transformed_data,
        }
    }
    
    // 借用型API - 不获取所有权
    fn process_without_consuming(&self, resource: &DataResource) -> Vec<u8> {
        println!("处理器 '{}' 处理资源 {:?} 而不消费它", self.name, resource.id());
        
        // 处理资源数据的副本
        resource.data.iter()
            .map(|&byte| byte.wrapping_add(2))
            .collect()
    }
    
    // 可变借用API - 不获取所有权但可以修改
    fn process_and_modify(&self, resource: &mut DataResource) -> Result<(), &'static str> {
        println!("处理器 '{}' 修改资源 {:?}", self.name, resource.id());
        
        // 修改资源数据
        let mut new_data = Vec::with_capacity(resource.data.len());
        for byte in &resource.data {
            new_data.push(byte.wrapping_add(3));
        }
        
        resource.data = new_data;
        
        Ok(())
    }
}

// 转换后的不可变资源
#[derive(Debug)]
struct TransformedResource {
    original_id: ResourceId,
    data: Vec<u8>,
}

impl Resource for TransformedResource {
    fn id(&self) -> ResourceId {
        // 新的ID是基于原始ID生成的
        ResourceId(self.original_id.0 + 10000)
    }
    
    fn size(&self) -> usize {
        self.data.len()
    }
}

// 3. 接口契约与验证
struct ResourceContract<R: Resource> {
    resource: R,
    preconditions_checked: bool,
}

impl<R: Resource> ResourceContract<R> {
    // 创建新的契约封装的资源
    fn new(resource: R) -> Self {
        ResourceContract {
            resource,
            preconditions_checked: false,
        }
    }
    
    // 定义前置条件
    fn require(&mut self, condition: bool, message: &str) -> Result<&mut Self, &'static str> {
        if !condition {
            println!("前置条件失败: {}", message);
            return Err("前置条件不满足");
        }
        
        self.preconditions_checked = true;
        Ok(self)
    }
    
    // 消费契约，返回资源
    fn consume(self) -> Result<R, &'static str> {
        if !self.preconditions_checked {
            return Err("未检查前置条件");
        }
        
        Ok(self.resource)
    }
    
    // 访问资源的不可变引用
    fn access(&self) -> Result<&R, &'static str> {
        if !self.preconditions_checked {
            return Err("未检查前置条件");
        }
        
        Ok(&self.resource)
    }
    
    // 访问资源的可变引用
    fn access_mut(&mut self) -> Result<&mut R, &'static str> {
        if !self.preconditions_checked {
            return Err("未检查前置条件");
        }
        
        Ok(&mut self.resource)
    }
}

// 4. 具体的资源管理器（遵循契约）
struct ResourceManager {
    resources: std::collections::HashMap<ResourceId, DataResource>,
}

impl ResourceManager {
    fn new() -> Self {
        ResourceManager {
            resources: std::collections::HashMap::new(),
        }
    }
    
    // 创建资源
    fn create_resource(&mut self, id: ResourceId, data: Vec<u8>) -> Result<(), &'static str> {
        if self.resources.contains_key(&id) {
            return Err("资源ID已存在");
        }
        
        let resource = DataResource { id, data };
        
        // 验证资源创建的前置条件
        let contract = ResourceContract::new(resource);
        let resource = contract
            .require(id.0 > 0, "资源ID必须为正数")?
            .consume()?;
            
        self.resources.insert(id, resource);
        
        println!("创建资源 {:?}，大小 {} 字节", id, self.resources[&id].size());
        
        Ok(())
    }
    
    // 获取资源（所有权转移）
    fn take_resource(&mut self, id: ResourceId) -> Result<DataResource, &'static str> {
        // 验证资源获取的前置条件
        let mut contract = ResourceContract::new(id);
        contract.require(self.resources.contains_key(&id), "资源必须存在")?;
        
        // 移除并返回资源
        match self.resources.remove(&id) {
            Some(resource) => {
                println!("移除并返回资源 {:?}", id);
                Ok(resource)
            },
            None => Err("资源不存在"),
        }
    }
    
    // 获取资源的不可变引用
    fn get_resource(&self, id: ResourceId) -> Result<&DataResource, &'static str> {
        // 验证资源访问的前置条件
        let mut contract = ResourceContract::new(id);
        contract.require(self.resources.contains_key(&id), "资源必须存在")?;
        
        match self.resources.get(&id) {
            Some(resource) => {
                println!("获取资源 {:?} 的不可变引用", id);
                Ok(resource)
            },
            None => Err("资源不存在"),
        }
    }
    
    // 获取资源的可变引用
    fn get_resource_mut(&mut self, id: ResourceId) -> Result<&mut DataResource, &'static str> {
        // 验证资源修改的前置条件
        let mut contract = ResourceContract::new(id);
        contract.require(self.resources.contains_key(&id), "资源必须存在")?;
        
        match self.resources.get_mut(&id) {
            Some(resource) => {
                println!("获取资源 {:?} 的可变引用", id);
                Ok(resource)
            },
            None => Err("资源不存在"),
        }
    }
    
    // 存入资源（接收所有权）
    fn put_resource(&mut self, resource: DataResource) -> Result<(), &'static str> {
        let id = resource.id();
        
        // 验证资源放入的前置条件
        let mut contract = ResourceContract::new(resource);
        let resource = contract
            .require(!self.resources.contains_key(&id), "资源ID不能已存在")?
            .consume()?;
            
        println!("存入资源 {:?}，大小 {} 字节", id, resource.size());
        
        self.resources.insert(id, resource);
        
        Ok(())
    }
}

// 5. 基于所有权的接口契约示例
fn interface_contract_example() {
    // 创建资源管理器
    let mut manager = ResourceManager::new();
    
    // 创建资源
    manager.create_resource(ResourceId(1), b"资源1的数据".to_vec()).unwrap();
    manager.create_resource(ResourceId(2), b"资源2的更多数据".to_vec()).unwrap();
    
    // 使用不可变引用处理资源
    {
        let resource1 = manager.get_resource(ResourceId(1)).unwrap();
        let processor = ResourceProcessor::new("处理器1");
        
        let processed_data = processor.process_without_consuming(resource1);
        println!("处理后的数据大小: {} 字节", processed_data.len());
        
        // 资源1仍然在管理器中
    }
    
    // 使用可变引用修改资源
    {
        let resource2 = manager.get_resource_mut(ResourceId(2)).unwrap();
        let processor = ResourceProcessor::new("处理器2");
        
        processor.process_and_modify(resource2).unwrap();
        
        // 资源2仍然在管理器中，但已被修改
        println!("修改后的资源2大小: {} 字节", resource2.size());
    }
    
    // 移除资源所有权并转换它
    {
        let resource1 = manager.take_resource(ResourceId(1)).unwrap();
        let processor = ResourceProcessor::new("处理器3");
        
        let transformed = processor.consume_and_transform(resource1);
        
        println!("转换后的资源: ID={:?}, 大小={} 字节", 
            transformed.id(), transformed.size());
            
        // 资源1不再在管理器中
        // 尝试再次获取它会失败
        match manager.get_resource(ResourceId(1)) {
            Ok(_) => println!("意外: 资源1仍然存在"),
            Err(e) => println!("预期的错误: {}", e),
        }
        
        // 存入转换后的资源
        // 在实际应用中，可能需要实现从 TransformedResource 转换到 DataResource 的逻辑
    }
    
    // 展示无效的操作
    {
        // 尝试创建已存在的资源
        match manager.create_resource(ResourceId(2), b"重复的资源2".to_vec()) {
            Ok(_) => println!("意外: 成功创建重复的资源2"),
            Err(e) => println!("预期的错误: {}", e),
        }
        
        // 尝试移除不存在的资源
        match manager.take_resource(ResourceId(999)) {
            Ok(_) => println!("意外: 成功移除不存在的资源"),
            Err(e) => println!("预期的错误: {}", e),
        }
    }
}
```

### 所有权协议验证

通过所有权证明验证协议合规性：

1. **协议与所有权规则**
   - 定义资源交换和处理的协议规则
   - 使用所有权检查验证规则遵守

2. **协议状态的安全转换**
   - 基于所有权的状态机实现
   - 所有权确保状态转换安全

3. **自动验证机制**
   - 编译时协议验证
   - 运行时所有权监控

```rust
// 所有权协议验证示例

// 1. 协议定义与状态
#[derive(Debug, Clone, Copy, PartialEq)]
enum ProtocolState {
    Initial,
    ResourceAllocated,
    ResourceConfigured,
    ResourceActive,
    ResourcePaused,
    ResourceReleasing,
    Terminated,
}

// 协议状态转换错误
#[derive(Debug)]
enum ProtocolError {
    InvalidStateTransition(ProtocolState, ProtocolState),
    ResourceNotOwned,
    ResourceAlreadyOwned,
    InvalidOperation,
    PermissionDenied,
}

// 协议参与者角色
#[derive(Debug, Clone, Copy, PartialEq)]
enum Role {
    Allocator,
    Consumer,
    Administrator,
}

// 2. 基于所有权的协议状态机
struct ProtocolStateMachine {
    current_state: ProtocolState,
    resource_owner: Option<Role>,
    allowed_transitions: std::collections::HashMap<ProtocolState, Vec<ProtocolState>>,
    role_permissions: std::collections::HashMap<Role, Vec<ProtocolState>>,
}

impl ProtocolStateMachine {
    fn new() -> Self {
        let mut allowed_transitions = std::collections::HashMap::new();
        allowed_transitions.insert(ProtocolState::Initial, vec![ProtocolState::ResourceAllocated]);
        allowed_transitions.insert(ProtocolState::ResourceAllocated, vec![
            ProtocolState::ResourceConfigured, ProtocolState::ResourceReleasing
        ]);
        allowed_transitions.insert(ProtocolState::ResourceConfigured, vec![
            ProtocolState::ResourceActive, ProtocolState::ResourceReleasing
        ]);
        allowed_transitions.insert(ProtocolState::ResourceActive, vec![
            ProtocolState::ResourcePaused, ProtocolState::ResourceReleasing
        ]);
        allowed_transitions.insert(ProtocolState::ResourcePaused, vec![
            ProtocolState::ResourceActive, ProtocolState::ResourceReleasing
        ]);
        allowed_transitions.insert(ProtocolState::ResourceReleasing, vec![
            ProtocolState::Terminated
        ]);
        allowed_transitions.insert(ProtocolState::Terminated, vec![]);
        
        let mut role_permissions = std::collections::HashMap::new();
        role_permissions.insert(Role::Allocator, vec![
            ProtocolState::Initial, 
            ProtocolState::ResourceAllocated,
            ProtocolState::ResourceReleasing,
            ProtocolState::Terminated
        ]);
        role_permissions.insert(Role::Consumer, vec![
            ProtocolState::ResourceConfigured,
            ProtocolState::ResourceActive,
            ProtocolState::ResourcePaused
        ]);
        role_permissions.insert(Role::Administrator, vec![
            ProtocolState::Initial, 
            ProtocolState::ResourceAllocated,
            ProtocolState::ResourceConfigured,
            ProtocolState::ResourceActive,
            ProtocolState::ResourcePaused,
            ProtocolState::ResourceReleasing,
            ProtocolState::Terminated
        ]);
        
        ProtocolStateMachine {
            current_state: ProtocolState::Initial,
            resource_owner: None,
            allowed_transitions,
            role_permissions,
        }
    }
    
    // 检查状态转换是否有效
    fn is_valid_transition(&self, from: ProtocolState, to: ProtocolState) -> bool {
        if let Some(allowed) = self.allowed_transitions.get(&from) {
            allowed.contains(&to)
        } else {
            false
        }
    }
    
    // 检查角色是否有权限执行操作
    fn has_permission(&self, role: Role, state: ProtocolState) -> bool {
        if let Some(allowed_states) = self.role_permissions.get(&role) {
            allowed_states.contains(&state)
        } else {
            false
        }
    }
    
    // 尝试转换状态
    fn try_transition(&mut self, to: ProtocolState, role: Role) -> Result<(), ProtocolError> {
        // 检查是否有权限
        if !self.has_permission(role, to) {
            return Err(ProtocolError::PermissionDenied);
        }
        
        // 检查转换是否有效
        if !self.is_valid_transition(self.current_state, to) {
            return Err(ProtocolError::InvalidStateTransition(self.current_state, to));
        }
        
        println!("协议状态从 {:?} 转换到 {:?}，由角色 {:?} 执行", 
            self.current_state, to, role);
            
        // 执行转换
        self.current_state = to;
        
        // 更新资源所有权
        match to {
            ProtocolState::ResourceAllocated => {
                self.resource_owner = Some(Role::Allocator);
            },
            ProtocolState::ResourceConfigured => {
                self.resource_owner = Some(Role::Consumer);
            },
            ProtocolState::Terminated => {
                self.resource_owner = None;
            },
            _ => {}
        }
        
        Ok(())
    }
    
    // 获取当前状态
    fn current_state(&self) -> ProtocolState {
        self.current_state
    }
    
    // 获取资源所有者
    fn resource_owner(&self) -> Option<Role> {
        self.resource_owner
    }
    
    // 检查资源所有权
    fn verify_ownership(&self, role: Role) -> Result<(), ProtocolError> {
        match self.resource_owner {
            Some(owner) if owner == role => Ok(()),
            Some(_) => Err(ProtocolError::ResourceNotOwned),
            None => Err(ProtocolError::ResourceNotOwned),
        }
    }
    
    // 转移资源所有权
    fn transfer_ownership(&mut self, from: Role, to: Role) -> Result<(), ProtocolError> {
        // 验证当前所有者
        self.verify_ownership(from)?;
        
        println!("资源所有权从 {:?} 转移到 {:?}", from, to);
        
        self.resource_owner = Some(to);
        
        Ok(())
    }
}

// 3. 协议参与者
struct ProtocolParticipant {
    name: String,
    role: Role,
    auth_token: u64,
}

impl ProtocolParticipant {
    fn new(name: &str, role: Role) -> Self {
        // 在实际系统中，auth_token会通过安全手段生成
        let auth_token = match role {
            Role::Allocator => 1001,
            Role::Consumer => 2001,
            Role::Administrator => 9001,
        };
        
        ProtocolParticipant {
            name: name.to_string(),
            role,
            auth_token,
        }
    }
    
    // 分配资源
    fn allocate_resource(&self, state_machine: &mut ProtocolStateMachine) -> Result<(), ProtocolError> {
        if self.role != Role::Allocator && self.role != Role::Administrator {
            return Err(ProtocolError::PermissionDenied);
        }
        
        if state_machine.current_state() != ProtocolState::Initial {
            return Err(ProtocolError::InvalidStateTransition(
                state_machine.current_state(), 
                ProtocolState::ResourceAllocated
            ));
        }
        
        println!("参与者 '{}' 分配资源", self.name);
        
        state_machine.try_transition(ProtocolState::ResourceAllocated, self.role)
    }
    
    // 配置资源
    fn configure_resource(&self, state_machine: &mut ProtocolStateMachine) -> Result<(), ProtocolError> {
        // 检查是否在正确的状态
        if state_machine.current_state() != ProtocolState::ResourceAllocated {
            return Err(ProtocolError::InvalidStateTransition(
                state_machine.current_state(), 
                ProtocolState::ResourceConfigured
            ));
        }
        
        // 验证所有权或权限
        if self.role == Role::Allocator {
            state_machine.verify_ownership(self.role)?;
        } else if self.role != Role::Administrator {
            return Err(ProtocolError::PermissionDenied);
        }
        
        println!("参与者 '{}' 配置资源", self.name);
        
        // 执行状态转换
        state_machine.try_transition(ProtocolState::ResourceConfigured, self.role)?;
        
        // 如果是分配者，需要转移所有权给消费者
        if self.role == Role::Allocator {
            state_machine.transfer_ownership(Role::Allocator, Role::Consumer)?;
        }
        
        Ok(())
    }
    
    // 激活资源
    fn activate_resource(&self, state_machine: &mut ProtocolStateMachine) -> Result<(), ProtocolError> {
        // 检查是否在正确的状态
        if state_machine.current_state() != ProtocolState::ResourceConfigured && 
           state_machine.current_state() != ProtocolState::ResourcePaused {
            return Err(ProtocolError::InvalidStateTransition(
                state_machine.current_state(), 
                ProtocolState::ResourceActive
            ));
        }
        
        // 验证所有权或权限
        if self.role == Role::Consumer {
            state_machine.verify_ownership(self.role)?;
        } else if self.role != Role::Administrator {
            return Err(ProtocolError::PermissionDenied);
        }
        
        println!("参与者 '{}' 激活资源", self.name);
        
        // 执行状态转换
        state_machine.try_transition(ProtocolState::ResourceActive, self.role)
    }
    
    // 暂停资源
    fn pause_resource(&self, state_machine: &mut ProtocolStateMachine) -> Result<(), ProtocolError> {
        // 检查是否在正确的状态
        if state_machine.current_state() != ProtocolState::ResourceActive {
            return Err(ProtocolError::InvalidStateTransition(
                state_machine.current_state(), 
                ProtocolState::ResourcePaused
            ));
        }
        
        // 验证所有权或权限
        if self.role == Role::Consumer {
            state_machine.verify_ownership(self.role)?;
        } else if self.role != Role::Administrator {
            return Err(ProtocolError::PermissionDenied);
        }
        
        println!("参与者 '{}' 暂停资源", self.name);
        
        // 执行状态转换
        state_machine.try_transition(ProtocolState::ResourcePaused, self.role)
    }
    
    // 释放资源
    fn release_resource(&self, state_machine: &mut ProtocolStateMachine) -> Result<(), ProtocolError> {
        // 几乎所有状态都可以转入释放状态，除了初始和已终止
        if state_machine.current_state() == ProtocolState::Initial || 
           state_machine.current_state() == ProtocolState::Terminated {
            return Err(ProtocolError::InvalidStateTransition(
                state_machine.current_state(), 
                ProtocolState::ResourceReleasing
            ));
        }
        
        // 验证所有权或权限
        if let Some(owner) = state_machine.resource_owner() {
            if self.role == owner || self.role == Role::Administrator {
                // 允许所有者或管理员释放资源
            } else {
                return Err(ProtocolError::PermissionDenied);
            }
        } else {
            return Err(ProtocolError::ResourceNotOwned);
        }
        
        println!("参与者 '{}' 释放资源", self.name);
        
        // 执行状态转换
        state_machine.try_transition(ProtocolState::ResourceReleasing, self.role)
    }
    
    // 终止协议
    fn terminate_protocol(&self, state_machine: &mut ProtocolStateMachine) -> Result<(), ProtocolError> {
        // 只能从释放状态转入终止状态
        if state_machine.current_state() != ProtocolState::ResourceReleasing {
            return Err(ProtocolError::InvalidStateTransition(
                state_machine.current_state(), 
                ProtocolState::Terminated
            ));
        }
        
        // 只有分配者和管理员可以终止协议
        if self.role != Role::Allocator && self.role != Role::Administrator {
            return Err(ProtocolError::PermissionDenied);
        }
        
        println!("参与者 '{}' 终止协议", self.name);
        
        // 执行状态转换
        state_machine.try_transition(ProtocolState::Terminated, self.role)
    }
}

// 4. 协议验证器
struct ProtocolVerifier {
    auth_tokens: std::collections::HashMap<u64, Role>,
}

impl ProtocolVerifier {
    fn new() -> Self {
        let mut auth_tokens = std::collections::HashMap::new();
        auth_tokens.insert(1001, Role::Allocator);
        auth_tokens.insert(2001, Role::Consumer);
        auth_tokens.insert(9001, Role::Administrator);
        
        ProtocolVerifier {
            auth_tokens,
        }
    }
    
    // 验证参与者身份
    fn verify_identity(&self, participant: &ProtocolParticipant) -> Result<(), ProtocolError> {
        if let Some(&role) = self.auth_tokens.get(&participant.auth_token) {
            if role == participant.role {
                return Ok(());
            }
        }
        
        Err(ProtocolError::PermissionDenied)
    }
    
    // 验证所有权转移
    fn verify_ownership_transfer(&self, 
                                state_machine: &ProtocolStateMachine,
                                from: &ProtocolParticipant, 
                                to: &ProtocolParticipant) -> Result<(), ProtocolError> {
        // 验证身份
        self.verify_identity(from)?;
        self.verify_identity(to)?;
        
        // 验证当前所有者
        if state_machine.resource_owner() != Some(from.role) {
            return Err(ProtocolError::ResourceNotOwned);
        }
        
        // 在实际系统中，这里会有更复杂的逻辑
        // 例如检查是否符合业务规则等
        
        Ok(())
    }
    
    // 记录协议事件（审计跟踪）
    fn log_protocol_event(&self, event: &str, participant: &ProtocolParticipant, state: ProtocolState) {
        println!("协议审计: {} | 参与者: {} ({:?}) | 状态: {:?}",
            event, participant.name, participant.role, state);
    }
}

// 5. 所有权协议验证示例
fn protocol_verification_example() {
    // 创建协议状态机
    let mut state_machine = ProtocolStateMachine::new();
    
    // 创建验证器
    let verifier = ProtocolVerifier::new();
    
    // 创建参与者
    let allocator = ProtocolParticipant::new("资源分配者", Role::Allocator);
    let consumer = ProtocolParticipant::new("资源消费者", Role::Consumer);
    let admin = ProtocolParticipant::new("系统管理员", Role::Administrator);
    
    println!("\n=== 协议执行 - 正常流程 ===");
    
    // 正常流程: 分配 -> 配置 -> 激活 -> 暂停 -> 激活 -> 释放 -> 终止
    
    // 分配资源
    match allocator.allocate_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("分配资源", &allocator, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
            return;
        }
    }
    
    // 配置资源
    match allocator.configure_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("配置资源", &allocator, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
            return;
        }
    }
    
    // 验证所有权已转移给消费者
    if let Some(owner) = state_machine.resource_owner() {
        println!("资源当前所有者: {:?}", owner);
    }
    
    // 消费者激活资源
    match consumer.activate_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("激活资源", &consumer, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
            return;
        }
    }
    
    // 消费者暂停资源
    match consumer.pause_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("暂停资源", &consumer, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
            return;
        }
    }
    
    // 消费者再次激活资源
    match consumer.activate_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("再次激活资源", &consumer, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
            return;
        }
    }
    
    // 消费者释放资源
    match consumer.release_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("释放资源", &consumer, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
            return;
        }
    }
    
    // 分配者终止协议
    match allocator.terminate_protocol(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("终止协议", &allocator, state_machine.current_state());
        },
        Err(e) => {
            println!("错误: {:?}", e);
        }
    }
    
    println!("\n=== 协议执行 - 异常流程 ===");
    
    // 重置状态机
    state_machine = ProtocolStateMachine::new();
    
    // 异常流程: 尝试跳过状态
    
    // 分配资源
    allocator.allocate_resource(&mut state_machine).unwrap();
    
    // 消费者尝试激活未配置的资源
    match consumer.activate_resource(&mut state_machine) {
        Ok(_) => {
            println!("意外: 消费者能够激活未配置的资源");
        },
        Err(e) => {
            println!("预期的错误: {:?}", e);
        }
    }
    
    // 配置资源
    allocator.configure_resource(&mut state_machine).unwrap();
    
    // 分配者尝试激活资源（资源已转移给消费者）
    match allocator.activate_resource(&mut state_machine) {
        Ok(_) => {
            println!("意外: 分配者能够激活不再拥有的资源");
        },
        Err(e) => {
            println!("预期的错误: {:?}", e);
        }
    }
    
    // 管理员可以激活资源（即使不是所有者）
    match admin.activate_resource(&mut state_machine) {
        Ok(_) => {
            verifier.log_protocol_event("管理员激活资源", &admin, state_machine.current_state());
        },
        Err(e) => {
            println!("意外错误: {:?}", e);
            return;
        }
    }
    
    // 管理员释放资源
    admin.release_resource(&mut state_machine).unwrap();
    
    // 管理员终止协议
    admin.terminate_protocol(&mut state_machine).unwrap();
    
    // 尝试在已终止的协议上操作
    match consumer.activate_resource(&mut state_machine) {
        Ok(_) => {
            println!("意外: 能够在已终止的协议上激活资源");
        },
        Err(e) => {
            println!("预期的错误: {:?}", e);
        }
    }
}
```

### 基于类型的动态验证

类型系统与所有权结合进行动态验证：

1. **编译时所有权保证**
   - 利用类型系统验证所有权规则
   - 在编译时捕获所有权错误

2. **类型驱动的不变性**
   - 通过类型编码资源不变性规则
   - 不变性在状态转换中的保持

3. **类型状态编程范式**
   - 将资源状态编码到类型中
   - 使用类型系统确保操作有效性

```rust
// 基于类型的动态验证示例

// 1. 类型编码的资源状态

// 资源标识符
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct TypedResourceId(u64);

// 资源状态类型标记
struct Uninitialized;
struct Initialized;
struct Active;
struct Paused;
struct Released;

// 状态化资源
struct TypedResource<State> {
    id: TypedResourceId,
    data: Vec<u8>,
    _state: std::marker::PhantomData<State>,
}

// 2. 基于类型的操作安全性

// 只有未初始化的资源可以初始化
impl TypedResource<Uninitialized> {
    // 创建新的未初始化资源
    fn new(id: TypedResourceId, data: Vec<u8>) -> Self {
        println!("创建未初始化资源 {:?}", id);
        
        TypedResource {
            id,
            data,
            _state: std::marker::PhantomData,
        }
    }
    
    // 初始化资源 - 改变类型状态
    fn initialize(self) -> TypedResource<Initialized> {
        println!("初始化资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
}

// 已初始化资源的操作
impl TypedResource<Initialized> {
    // 激活资源 - 改变类型状态
    fn activate(self) -> TypedResource<Active> {
        println!("激活资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
    
    // 释放资源 - 改变类型状态
    fn release(self) -> TypedResource<Released> {
        println!("释放资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
}

// 活跃资源的操作
impl TypedResource<Active> {
    // 读取数据 - 不改变状态
    fn read_data(&self) -> &[u8] {
        println!("读取活跃资源 {:?} 的数据", self.id);
        &self.data
    }
    
    // 更新数据 - 不改变状态
    fn update_data(&mut self, new_data: Vec<u8>) {
        println!("更新活跃资源 {:?} 的数据", self.id);
        self.data = new_data;
    }
    
    // 暂停资源 - 改变类型状态
    fn pause(self) -> TypedResource<Paused> {
        println!("暂停资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
    
    // 释放资源 - 改变类型状态
    fn release(self) -> TypedResource<Released> {
        println!("从活跃状态释放资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
}

// 暂停资源的操作
impl TypedResource<Paused> {
    // 恢复资源 - 改变类型状态
    fn resume(self) -> TypedResource<Active> {
        println!("恢复暂停的资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
    
    // 读取数据 - 不改变状态
    fn read_data(&self) -> &[u8] {
        println!("读取暂停资源 {:?} 的数据", self.id);
        &self.data
    }
    
    // 释放资源 - 改变类型状态
    fn release(self) -> TypedResource<Released> {
        println!("从暂停状态释放资源 {:?}", self.id);
        
        TypedResource {
            id: self.id,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
}

// 释放资源的操作（有限）
impl TypedResource<Released> {
    // 释放的资源只能获取ID
    fn id(&self) -> TypedResourceId {
        self.id
    }
    
    // 注意：无法访问数据或执行其他操作
}

// 3. 带验证的资源管理器
struct TypedResourceManager {
    active_resources: u32,
    max_resources: u32,
}

impl TypedResourceManager {
    fn new(max_resources: u32) -> Self {
        TypedResourceManager {
            active_resources: 0,
            max_resources,
        }
    }
    
    // 创建资源时检查限制
    fn create_resource(&mut self, id: TypedResourceId, data: Vec<u8>) 
        -> Result<TypedResource<Uninitialized>, &'static str> 
    {
        if self.active_resources >= self.max_resources {
            return Err("已达到最大资源限制");
        }
        
        self.active_resources += 1;
        println!("资源管理器: 创建资源 {:?}，当前活跃资源: {}/{}", 
            id, self.active_resources, self.max_resources);
            
        Ok(TypedResource::new(id, data))
    }
    
    // 释放资源时更新计数
    fn handle_resource_release(&mut self, resource: TypedResource<Released>) {
        if self.active_resources > 0 {
            self.active_resources -= 1;
        }
        
        println!("资源管理器: 处理资源 {:?} 的释放，当前活跃资源: {}/{}", 
            resource.id(), self.active_resources, self.max_resources);
            
        // 资源已完全释放，被丢弃
    }
}

// 4. 基于类型的验证示例
fn type_based_verification_example() {
    // 创建资源管理器
    let mut manager = TypedResourceManager::new(3);
    
    // 创建并初始化资源1
    let resource1 = match manager.create_resource(TypedResourceId(101), b"资源1初始数据".to_vec()) {
        Ok(res) => res,
        Err(e) => {
            println!("创建资源失败: {}", e);
            return;
        }
    };
    
    // 初始化并激活
    let resource1 = resource1.initialize().activate();
    
    // 创建并初始化资源2
    let resource2 = manager.create_resource(TypedResourceId(102), b"资源2初始数据".to_vec()).unwrap();
    let mut resource2 = resource2.initialize().activate();
    
    // 读取和更新资源
    {
        let data1 = resource1.read_data();
        println!("资源1数据: {}", String::from_utf8_lossy(data1));
        
        // 更新资源2
        resource2.update_data(b"资源2更新后的数据".to_vec());
        let data2 = resource2.read_data();
        println!("资源2数据: {}", String::from_utf8_lossy(data2));
    }
    
    // 暂停资源2
    let resource2 = resource2.pause();
    
    // 创建资源3
    let resource3 = manager.create_resource(TypedResourceId(103), b"资源3初始数据".to_vec()).unwrap();
    
    // 尝试创建超过限制的资源4
    match manager.create_resource(TypedResourceId(104), b"资源4".to_vec()) {
        Ok(_) => println!("意外: 创建超过限制的资源"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 释放资源1
    let released1 = resource1.release();
    manager.handle_resource_release(released1);
    
    // 现在可以创建资源4
    let resource4 = manager.create_resource(TypedResourceId(104), b"资源4初始数据".to_vec()).unwrap();
    println!("创建资源4成功");
    
    // 恢复资源2并使用
    let mut resource2 = resource2.resume();
    resource2.update_data(b"资源2再次更新".to_vec());
    
    // 释放资源
    let released2 = resource2.release();
    let released3 = resource3.initialize().release();
    let released4 = resource4.initialize().activate().release();
    
    manager.handle_resource_release(released2);
    manager.handle_resource_release(released3);
    manager.handle_resource_release(released4);
    
    println!("所有资源都已释放");
}
```

### 所有权驱动的契约自动化

自动化契约验证和资源管理：

1. **资源访问自动化契约**
   - 资源权限和访问控制自动化
   - 基于所有权的访问策略实施

2. **自适应资源处理**
   - 根据所有权状态动态调整资源管理
   - 智能处理资源限制和约束

3. **契约违规自动处理**
   - 检测和响应契约违规
   - 自动化资源恢复和修复

```rust
// 所有权驱动的契约自动化示例

// 1. 资源访问控制

// 资源类型
enum ResourceType {
    Database,
    File,
    Network,
    Memory,
}

// 资源访问权限
enum AccessType {
    Read,
    Write,
    Execute,
    Admin,
}

// 资源访问令牌
struct AccessToken {
    resource_type: ResourceType,
    access_type: AccessType,
    expiration: std::time::Instant,
    is_valid: bool,
}

// 2. 自动化资源管理器
struct AutomatedResourceManager {
    access_policies: std::collections::HashMap<ResourceType, Vec<AccessPolicy>>,
    resource_tokens: std::collections::HashMap<String, AccessToken>,
    violations: Vec<ContractViolation>,
}

// 访问策略
struct AccessPolicy {
    required_access: AccessType,
    max_time: std::time::Duration,
    auto_extend: bool,
}

// 契约违规记录
struct ContractViolation {
    timestamp: std::time::Instant,
    resource_type: ResourceType,
    violation_type: ViolationType,
    details: String,
}

enum ViolationType {
    UnauthorizedAccess,
    ExpiredToken,
    ExcessiveUsage,
    MissingToken,
}

impl AutomatedResourceManager {
    fn new() -> Self {
        let mut manager = AutomatedResourceManager {
            access_policies: std::collections::HashMap::new(),
            resource_tokens: std::collections::HashMap::new(),
            violations: Vec::new(),
        };
        
        // 设置默认策略
        manager.setup_default_policies();
        
        manager
    }
    
    // 设置默认访问策略
    fn setup_default_policies(&mut self) {
        // 数据库策略
        self.access_policies.insert(ResourceType::Database, vec![
            AccessPolicy { 
                required_access: AccessType::Read,
                max_time: std::time::Duration::from_secs(3600), // 1小时
                auto_extend: true,
            },
            AccessPolicy { 
                required_access: AccessType::Write,
                max_time: std::time::Duration::from_secs(1800), // 30分钟
                auto_extend: false,
            },
            AccessPolicy { 
                required_access: AccessType::Admin,
                max_time: std::time::Duration::from_secs(900), // 15分钟
                auto_extend: false,
            },
        ]);
        
        // 文件策略
        self.access_policies.insert(ResourceType::File, vec![
            AccessPolicy { 
                required_access: AccessType::Read,
                max_time: std::time::Duration::from_secs(7200), // 2小时
                auto_extend: true,
            },
            AccessPolicy { 
                required_access: AccessType::Write,
                max_time: std::time::Duration::from_secs(3600), // 1小时
                auto_extend: false,
            },
        ]);
        
        // 网络策略
        self.access_policies.insert(ResourceType::Network, vec![
            AccessPolicy { 
                required_access: AccessType::Read,
                max_time: std::time::Duration::from_secs(1800), // 30分钟
                auto_extend: true,
            },
            AccessPolicy { 
                required_access: AccessType::Write,
                max_time: std::time::Duration::from_secs(900), // 15分钟
                auto_extend: false,
            },
        ]);
        
        // 内存策略
        self.access_policies.insert(ResourceType::Memory, vec![
            AccessPolicy { 
                required_access: AccessType::Read,
                max_time: std::time::Duration::from_secs(300), // 5分钟
                auto_extend: true,
            },
            AccessPolicy { 
                required_access: AccessType::Write,
                max_time: std::time::Duration::from_secs(300), // 5分钟
                auto_extend: false,
            },
        ]);
    }
    
    // 请求资源访问令牌
    fn request_access(&mut self, resource_type: ResourceType, access_type: AccessType, 
                    resource_id: &str) -> Result<(), &'static str> {
        println!("请求访问 {:?} 资源 '{}' 的 {:?} 权限", resource_type, resource_id, access_type);
        
        // 检查是否存在该资源类型的策略
        let policies = match self.access_policies.get(&resource_type) {
            Some(p) => p,
            None => return Err("不支持的资源类型"),
        };
        
        // 查找匹配的策略
        let policy = policies.iter()
            .find(|p| match (&p.required_access, &access_type) {
                (AccessType::Admin, _) => true, // Admin 可以访问任何类型
                (required, requested) => std::mem::discriminant(required) == std::mem::discriminant(requested),
            })
            .ok_or("没有匹配的访问策略")?;
            
        // 创建访问令牌
        let token = AccessToken {
            resource_type,
            access_type,
            expiration: std::time::Instant::now() + policy.max_time,
            is_valid: true,
        };
        
        // 存储令牌
        let key = format!("{}:{}", resource_id, format!("{:?}", access_type));
        self.resource_tokens.insert(key, token);
        
        println!("授予 {:?} 访问，有效期 {} 秒", 
            access_type, policy.max_time.as_secs());
            
        Ok(())
    }
    
    // 验证资源访问权限
    fn verify_access(&mut self, resource_type: ResourceType, access_type: AccessType, 
                   resource_id: &str) -> Result<(), &'static str> {
        let key = format!("{}:{}", resource_id, format!("{:?}", access_type));
        
        // 查找令牌
        let token = match self.resource_tokens.get(&key) {
            Some(t) => t,
            None => {
                // 记录违规
                self.record_violation(
                    resource_type.clone(),
                    ViolationType::MissingToken,
                    format!("尝试访问 '{}' 没有令牌", resource_id)
                );
                
                return Err("未找到访问令牌");
            }
        };
        
        // 检查令牌有效性
        if !token.is_valid {
            self.record_violation(
                resource_type.clone(),
                ViolationType::UnauthorizedAccess,
                format!("尝试使用无效令牌访问 '{}'", resource_id)
            );
            
            return Err("访问令牌无效");
        }
        
        // 检查令牌是否过期
        if token.expiration <= std::time::Instant::now() {
            self.record_violation(
                resource_type.clone(),
                ViolationType::ExpiredToken,
                format!("尝试使用过期令牌访问 '{}'", resource_id)
            );
            
            return Err("访问令牌已过期");
        }
        
        // 检查访问类型是否匹配
        let access_allowed = match (&token.access_type, &access_type) {
            (AccessType::Admin, _) => true, // Admin 可以执行任何操作
            (AccessType::Write, AccessType::Read) => true, // 写权限包含读权限
            (a, b) => std::mem::discriminant(a) == std::mem::discriminant(b),
        };
        
        if !access_allowed {
            self.record_violation(
                resource_type.clone(),
                ViolationType::UnauthorizedAccess,
                format!("尝试使用 {:?} 令牌进行 {:?} 访问 '{}'", 
                    token.access_type, access_type, resource_id)
            );
            
            return Err("访问类型不匹配");
        }
        
        println!("验证 '{}' 的 {:?} 访问 - 成功", resource_id, access_type);
        
        // 尝试自动延长令牌（如果策略允许）
        self.try_extend_token(resource_type, resource_id, &key);
        
        Ok(())
    }
    
    // 尝试自动延长令牌有效期
    fn try_extend_token(&mut self, resource_type: ResourceType, resource_id: &str, token_key: &str) {
        if let Some(token) = self.resource_tokens.get(token_key) {
            // 剩余时间少于25%时尝试延长
            let remaining = token.expiration.duration_since(std::time::Instant::now());
            
            if let Some(policies) = self.access_policies.get(&resource_type) {
                for policy in policies {
                    if std::mem::discriminant(&policy.required_access) == std::mem::discriminant(&token.access_type) {
                        if policy.auto_extend {
                            // 检查是否应该延长
                            if remaining <= policy.max_time / 4 {
                                // 延长令牌
                                if let Some(token) = self.resource_tokens.get_mut(token_key) {
                                    token.expiration = std::time::Instant::now() + policy.max_time;
                                    
                                    println!("自动延长 '{}' 的 {:?} 访问，新过期时间为 {} 秒后",
                                        resource_id, token.access_type, policy.max_time.as_secs());
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
    
    // 显式释放资源访问权限
    fn release_access(&mut self, resource_type: ResourceType, access_type: AccessType, 
                    resource_id: &str) -> Result<(), &'static str> {
        let key = format!("{}:{}", resource_id, format!("{:?}", access_type));
        
        if let Some(mut token) = self.resource_tokens.remove(&key) {
            println!("释放 '{}' 的 {:?} 访问", resource_id, access_type);
            
            // 标记令牌为无效
            token.is_valid = false;
            
            Ok(())
        } else {
            self.record_violation(
                resource_type,
                ViolationType::MissingToken,
                format!("尝试释放不存在的令牌 '{}'", resource_id)
            );
            
            Err("未找到访问令牌")
        }
    }
    
    // 记录契约违规
    fn record_violation(&mut self, resource_type: ResourceType, violation_type: ViolationType, details: String) {
        let violation = ContractViolation {
            timestamp: std::time::Instant::now(),
            resource_type,
            violation_type,
            details,
        };
        
        self.violations.push(violation);
        
        match violation.violation_type {
            ViolationType::UnauthorizedAccess => {
                println!("违规警告! 未授权访问: {}", details);
            },
            ViolationType::ExpiredToken => {
                println!("违规警告! 使用过期令牌: {}", details);
            },
            ViolationType::ExcessiveUsage => {
                println!("违规警告! 资源过度使用: {}", details);
            },
            ViolationType::MissingToken => {
                println!("违规警告! 令牌缺失: {}", details);
            },
        }
    }
    
    // 获取所有违规记录
    fn get_violations(&self) -> &[ContractViolation] {
        &self.violations
    }
    
    // 自动清理过期令牌
    fn cleanup_expired_tokens(&mut self) {
        let now = std::time::Instant::now();
        let mut expired_keys = Vec::new();
        
        // 查找过期令牌
        for (key, token) in &self.resource_tokens {
            if token.expiration <= now {
                expired_keys.push((key.clone(), token.resource_type.clone()));
            }
        }
        
        // 移除过期令牌
        for (key, resource_type) in expired_keys {
            self.resource_tokens.remove(&key);
            
            let parts: Vec<&str> = key.split(':').collect();
            if parts.len() >= 1 {
                let resource_id = parts[0];
                self.record_violation(
                    resource_type,
                    ViolationType::ExpiredToken,
                    format!("自动清理过期的 '{}' 访问令牌", resource_id)
                );
            }
        }
    }
}

// 3. 可自动管理的资源
struct ManagedResource<T> {
    id: String,
    resource_type: ResourceType,
    data: T,
    manager: std::rc::Rc<std::cell::RefCell<AutomatedResourceManager>>,
}

impl<T> ManagedResource<T> {
    fn new(id: &str, resource_type: ResourceType, data: T, 
           manager: std::rc::Rc<std::cell::RefCell<AutomatedResourceManager>>) -> Self 
    {
        ManagedResource {
            id: id.to_string(),
            resource_type,
            data,
            manager,
        }
    }
    
    // 读取数据（需要读取权限）
    fn read(&self) -> Result<&T, &'static str> {
        // 验证读取权限
        self.manager.borrow_mut().verify_access(
            self.resource_type.clone(), 
            AccessType::Read, 
            &self.id
        )?;
        
        println!("读取资源 '{}'", self.id);
        
        Ok(&self.data)
    }
    
    // 修改数据（需要写入权限）
    fn modify<F>(&mut self, modifier: F) -> Result<(), &'static str>
        where F: FnOnce(&mut T)
    {
        // 验证写入权限
        self.manager.borrow_mut().verify_access(
            self.resource_type.clone(), 
            AccessType::Write, 
            &self.id
        )?;
        
        println!("修改资源 '{}'", self.id);
        
        // 执行修改
        modifier(&mut self.data);
        
        Ok(())
    }
}

// 当ManagedResource被丢弃时，自动释放访问权限
impl<T> Drop for ManagedResource<T> {
    fn drop(&mut self) {
        println!("资源 '{}' 被丢弃，自动释放访问权限", self.id);
        
        // 尝试释放读写权限
        let _ = self.manager.borrow_mut().release_access(
            self.resource_type.clone(), 
            AccessType::Read, 
            &self.id
        );
        
        let _ = self.manager.borrow_mut().release_access(
            self.resource_type.clone(), 
            AccessType::Write, 
            &self.id
        );
    }
}

// 4. 资源工厂
struct ResourceFactory {
    manager: std::rc::Rc<std::cell::RefCell<AutomatedResourceManager>>,
}

impl ResourceFactory {
    fn new(manager: std::rc::Rc<std::cell::RefCell<AutomatedResourceManager>>) -> Self {
        ResourceFactory { manager }
    }
    
    // 创建可读资源
    fn create_readable<T>(&self, id: &str, resource_type: ResourceType, data: T) 
        -> Result<ManagedResource<T>, &'static str> 
    {
        // 请求读取权限
        self.manager.borrow_mut().request_access(
            resource_type.clone(),
            AccessType::Read,
            id
        )?;
        
        Ok(ManagedResource::new(id, resource_type, data, self.manager.clone()))
    }
    
    // 创建可写资源
    fn create_writable<T>(&self, id: &str, resource_type: ResourceType, data: T) 
        -> Result<ManagedResource<T>, &'static str> 
    {
        // 请求写入权限（包含读取权限）
        self.manager.borrow_mut().request_access(
            resource_type.clone(),
            AccessType::Write,
            id
        )?;
        
        Ok(ManagedResource::new(id, resource_type, data, self.manager.clone()))
    }
    
    // 创建管理员资源
    fn create_admin<T>(&self, id: &str, resource_type: ResourceType, data: T) 
        -> Result<ManagedResource<T>, &'static str> 
    {
        // 请求管理员权限
        self.manager.borrow_mut().request_access(
            resource_type.clone(),
            AccessType::Admin,
            id
        )?;
        
        Ok(ManagedResource::new(id, resource_type, data, self.manager.clone()))
    }
}

// 5. 所有权驱动的契约自动化示例
fn contract_automation_example() {
    // 创建资源管理器
    let manager = std::rc::Rc::new(std::cell::RefCell::new(AutomatedResourceManager::new()));
    
    // 创建资源工厂
    let factory = ResourceFactory::new(manager.clone());
    
    println!("\n=== 创建和使用资源 ===");
    
    // 创建数据库资源
    let db_resource = factory.create_writable(
        "users_db", 
        ResourceType::Database,
        vec!["user1", "user2", "user3"]
    ).unwrap();
    
    // 创建文件资源
    let mut file_resource = factory.create_writable(
        "config.json", 
        ResourceType::File,
        "{\"version\": 1, \"settings\": {}}"
    ).unwrap();
    
    // 创建只读网络资源
    let network_resource = factory.create_readable(
        "api.example.com", 
        ResourceType::Network,
        "api.example.com:443"
    ).unwrap();
    
    // 读取资源
    match db_resource.read() {
        Ok(data) => println!("数据库用户: {:?}", data),
        Err(e) => println!("读取失败: {}", e),
    }
    
    match network_resource.read() {
        Ok(endpoint) => println!("网络端点: {}", endpoint),
        Err(e) => println!("读取失败: {}", e),
    }
    
    // 修改文件资源
    match file_resource.modify(|data| {
        *data = "{\"version\": 2, \"settings\": {\"debug\": true}}".to_string();
    }) {
        Ok(_) => println!("文件修改成功"),
        Err(e) => println!("修改失败: {}", e),
    }
    
    // 读取修改后的文件
    match file_resource.read() {
        Ok(content) => println!("文件内容: {}", content),
        Err(e) => println!("读取失败: {}", e),
    }
    
    println!("\n=== 违规访问示例 ===");
    
    // 尝试修改只读网络资源
    match network_resource.modify(|endpoint| {
        *endpoint = "new.example.com:8080".to_string();
    }) {
        Ok(_) => println!("意外: 成功修改只读资源"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 自动清理过期令牌
    println!("\n=== 自动令牌管理 ===");
    
    // 模拟时间过去，清理过期令牌（在真实系统中，这会定期自动执行）
    println!("执行过期令牌清理");
    manager.borrow_mut().cleanup_expired_tokens();
    
    // 查看违规记录
    println!("\n=== 违规记录摘要 ===");
    let violation_count = manager.borrow().get_violations().len();
    println!("记录了 {} 个违规", violation_count);
    
    println!("\n=== 资源释放 ===");
    // 离开作用域时资源会自动释放
}
```

## 所有权与领域特定语言

### 资源感知的语言嵌入

将所有权概念嵌入到领域特定语言中：

1. **嵌入式DSL资源表达**
   - 将Rust所有权语义嵌入DSL
   - DSL与主语言所有权系统的集成

2. **类型安全的DSL操作链**
   - 链式操作中的所有权流转
   - 防止无效状态和资源泄漏

3. **DSL编译期验证**
   - 编译时检查资源约束
   - 域特定错误的静态捕获

```rust
// 资源感知的语言嵌入示例

// 1. 资源定义

// 图像处理资源
struct Image {
    width: u32,
    height: u32,
    pixels: Vec<u8>,
    format: ImageFormat,
}

enum ImageFormat {
    RGB,
    RGBA,
    Grayscale,
}

impl Image {
    // 创建新图像
    fn new(width: u32, height: u32, format: ImageFormat) -> Self {
        let pixel_size = match format {
            ImageFormat::RGB => 3,
            ImageFormat::RGBA => 4,
            ImageFormat::Grayscale => 1,
        };
        
        let pixel_count = (width * height) as usize;
        
        Image {
            width,
            height,
            pixels: vec![0; pixel_count * pixel_size],
            format,
        }
    }
    
    // 获取图像信息
    fn info(&self) -> String {
        format!("图像: {}x{}, 格式: {:?}", self.width, self.height, self.format)
    }
    
    // 获取像素大小
    fn pixel_size(&self) -> usize {
        match self.format {
            ImageFormat::RGB => 3,
            ImageFormat::RGBA => 4,
            ImageFormat::Grayscale => 1,
        }
    }
}

// 2. 嵌入式DSL操作

// 图像操作构建器
struct ImagePipeline<'a> {
    image: &'a mut Image,
    has_error: bool,
    error_message: Option<String>,
}

impl<'a> ImagePipeline<'a> {
    // 创建新的操作管道
    fn new(image: &'a mut Image) -> Self {
        ImagePipeline {
            image,
            has_error: false,
            error_message: None,
        }
    }
    
    // 设置错误状态
    fn set_error(&mut self, message: &str) {
        self.has_error = true;
        self.error_message = Some(message.to_string());
    }
    
    // 应用灰度转换
    fn grayscale(mut self) -> Self {
        if self.has_error {
            return self;
        }
        
        match self.image.format {
            ImageFormat::Grayscale => {
                // 已经是灰度图，无需操作
                println!("图像已经是灰度格式");
            },
            ImageFormat::RGB | ImageFormat::RGBA => {
                println!("将图像转换为灰度");
                
                let pixel_size = self.image.pixel_size();
                let mut gray_pixels = Vec::with_capacity(self.image.width as usize * self.image.height as usize);
                
                // 转换为灰度
                for i in 0..(self.image.pixels.len() / pixel_size) {
                    let offset = i * pixel_size;
                    let r = self.image.pixels[offset] as f32;
                    let g = if pixel_size > 1 { self.image.pixels[offset + 1] as f32 } else { r };
                    let b = if pixel_size > 2 { self.image.pixels[offset + 2] as f32 } else { g };
                    
                    // 加权平均计算灰度
                    let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;
                    gray_pixels.push(gray);
                }
                
                self.image.pixels = gray_pixels;
                self.image.format = ImageFormat::Grayscale;
            }
        }
        
        self
    }
    
    // 应用模糊效果
    fn blur(mut self, radius: u32) -> Self {
        if self.has_error {
            return self;
        }
        
        if radius == 0 {
            self.set_error("模糊半径必须大于0");
            return self;
        }
        
        println!("对图像应用{}像素半径的模糊", radius);
        
        // 模拟模糊操作
        // 在实际实现中，这里会有复杂的模糊算法
        // 我们这里只是概念演示
        
        self
    }
    
    // 调整图像大小
    fn resize(mut self, new_width: u32, new_height: u32) -> Self {
        if self.has_error {
            return self;
        }
        
        if new_width == 0 || new_height == 0 {
            self.set_error("宽度和高度必须大于0");
            return self;
        }
        
        println!("调整图像大小为 {}x{}", new_width, new_height);
        
        // 创建新像素缓冲区
        let pixel_size = self.image.pixel_size();
        let mut new_pixels = vec![0; (new_width * new_height) as usize * pixel_size];
        
        // 模拟调整大小操作
        // 在实际实现中，这里会有双线性插值等复杂算法
        // 我们这里只是概念演示
        
        // 更新图像属性
        self.image.width = new_width;
        self.image.height = new_height;
        self.image.pixels = new_pixels;
        
        self
    }
    
    // 旋转图像
    fn rotate(mut self, degrees: f32) -> Self {
        if self.has_error {
            return self;
        }
        
        println!("旋转图像 {} 度", degrees);
        
        // 模拟旋转操作
        // 在实际实现中，这里会进行实际的几何变换
        // 我们这里只是概念演示
        
        self
    }
    
    // 裁剪图像
    fn crop(mut self, x: u32, y: u32, width: u32, height: u32) -> Self {
        if self.has_error {
            return self;
        }
        
        if x + width > self.image.width || y + height > self.image.height {
            self.set_error("裁剪区域超出图像范围");
            return self;
        }
        
        println!("裁剪图像：从 ({},{}) 开始，大小 {}x{}", x, y, width, height);
        
        // 模拟裁剪操作
        // 在实际实现中，会复制指定区域像素到新缓冲区
        // 我们这里只是概念演示
        
        // 更新图像属性
        self.image.width = width;
        self.image.height = height;
        
        self
    }
    
    // 转换颜色格式
    fn convert_format(mut self, target_format: ImageFormat) -> Self {
        if self.has_error {
            return self;
        }
        
        if self.image.format == target_format {
            println!("图像已经是 {:?} 格式", target_format);
            return self;
        }
        
        println!("将图像从 {:?} 转换为 {:?} 格式", self.image.format, target_format);
        
        // 处理各种转换情况
        match (self.image.format, target_format) {
            (ImageFormat::Grayscale, ImageFormat::RGB) => {
                // 灰度转RGB
                let mut rgb_pixels = Vec::with_capacity(self.image.width as usize * self.image.height as usize * 3);
                
                for &gray in &self.image.pixels {
                    rgb_pixels.push(gray);
                    rgb_pixels.push(gray);
                    rgb_pixels.push(gray);
                }
                
                self.image.pixels = rgb_pixels;
                self.image.format = ImageFormat::RGB;
            },
            (ImageFormat::Grayscale, ImageFormat::RGBA) => {
                // 灰度转RGBA
                let mut rgba_pixels = Vec::with_capacity(self.image.width as usize * self.image.height as usize * 4);
                
                for &gray in &self.image.pixels {
                    rgba_pixels.push(gray);
                    rgba_pixels.push(gray);
                    rgba_pixels.push(gray);
                    rgba_pixels.push(255); // 透明度为最大
                }
                
                self.image.pixels = rgba_pixels;
                self.image.format = ImageFormat::RGBA;
            },
            (ImageFormat::RGB, ImageFormat::RGBA) => {
                // RGB转RGBA
                let mut rgba_pixels = Vec::with_capacity(self.image.width as usize * self.image.height as usize * 4);
                
                for i in 0..(self.image.pixels.len() / 3) {
                    let offset = i * 3;
                    rgba_pixels.push(self.image.pixels[offset]);
                    rgba_pixels.push(self.image.pixels[offset + 1]);
                    rgba_pixels.push(self.image.pixels[offset + 2]);
                    rgba_pixels.push(255); // 透明度为最大
                }
                
                self.image.pixels = rgba_pixels;
                self.image.format = ImageFormat::RGBA;
            },
            (ImageFormat::RGBA, ImageFormat::RGB) => {
                // RGBA转RGB
                let mut rgb_pixels = Vec::with_capacity(self.image.width as usize * self.image.height as usize * 3);
                
                for i in 0..(self.image.pixels.len() / 4) {
                    let offset = i * 4;
                    rgb_pixels.push(self.image.pixels[offset]);
                    rgb_pixels.push(self.image.pixels[offset + 1]);
                    rgb_pixels.push(self.image.pixels[offset + 2]);
                    // 忽略透明度
                }
                
                self.image.pixels = rgb_pixels;
                self.image.format = ImageFormat::RGB;
            },
            (ImageFormat::RGB, ImageFormat::Grayscale) | 
            (ImageFormat::RGBA, ImageFormat::Grayscale) => {
                // 调用已实现的灰度转换
                return self.grayscale();
            },
            _ => {
                // 同样的格式，什么都不做
            }
        }
        
        self
    }
    
    // 结束管道并返回结果
    fn finish(self) -> Result<(), String> {
        if self.has_error {
            Err(self.error_message.unwrap_or_else(|| "未知错误".to_string()))
        } else {
            println!("图像处理完成：{}", self.image.info());
            Ok(())
        }
    }
}

// 3. 编译期验证辅助类型

// 已处理的图像标记类型
struct ProcessedImage<'a>(&'a mut Image);

// 已验证的参数类型
struct ValidCropRegion {
    x: u32,
    y: u32,
    width: u32,
    height: u32,
}

impl ValidCropRegion {
    fn new(x: u32, y: u32, width: u32, height: u32, image: &Image) -> Result<Self, &'static str> {
        if width == 0 || height == 0 {
            return Err("裁剪区域大小必须大于0");
        }
        
        if x + width > image.width || y + height > image.height {
            return Err("裁剪区域超出图像范围");
        }
        
        Ok(ValidCropRegion { x, y, width, height })
    }
}

// 4. 资源感知的DSL示例
fn embedded_dsl_example() {
    // 创建图像
    let mut image = Image::new(800, 600, ImageFormat::RGB);
    println!("创建新图像: {}", image.info());
    
    println!("\n=== 使用DSL进行图像处理链 ===");
    
    // 链式操作处理图像
    let result = ImagePipeline::new(&mut image)
        .resize(400, 300)
        .blur(5)
        .grayscale()
        .rotate(90.0)
        .finish();
        
    match result {
        Ok(_) => println!("图像处理成功"),
        Err(e) => println!("处理出错: {}", e),
    }
    
    // 创建另一个图像进行错误演示
    println!("\n=== 错误处理演示 ===");
    
    let mut image2 = Image::new(200, 150, ImageFormat::RGBA);
    println!("创建第二个图像: {}", image2.info());
    
    // 无效的裁剪区域
    let result = ImagePipeline::new(&mut image2)
        .crop(50, 50, 200, 200) // 尝试裁剪超出范围的区域
        .blur(3) // 这一步不会执行，因为上一步出错
        .finish();
        
    match result {
        Ok(_) => println!("意外: 处理成功"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 演示格式转换
    println!("\n=== 格式转换演示 ===");
    
    let mut image3 = Image::new(100, 100, ImageFormat::RGB);
    println!("创建第三个图像: {}", image3.info());
    
    let result = ImagePipeline::new(&mut image3)
        .convert_format(ImageFormat::RGBA)
        .blur(2)
        .convert_format(ImageFormat::Grayscale)
        .finish();
        
    match result {
        Ok(_) => println!("格式转换成功"),
        Err(e) => println!("转换出错: {}", e),
    }
}
```

### 所有权类型的DSL表达

使用Rust所有权设计DSL类型系统：

1. **DSL类型系统与所有权对应**
   - 映射DSL类型到Rust所有权
   - 类型安全的DSL表达式

2. **DSL语义与资源模型**
   - 领域语义表达资源关系
   - 领域内资源安全的确保

3. **类型驱动的DSL转换**
   - 所有权感知的代码生成
   - 保留DSL资源安全性的转换

```rust
// 所有权类型的DSL表达示例

// 1. 类型化的DSL表达式

// DSL表达式类型
enum DslExpr {
    // 数值表达式
    IntLit(i32),
    FloatLit(f64),
    BoolLit(bool),
    
    // 算术运算
    Add(Box<DslExpr>, Box<DslExpr>),
    Sub(Box<DslExpr>, Box<DslExpr>),
    Mul(Box<DslExpr>, Box<DslExpr>),
    Div(Box<DslExpr>, Box<DslExpr>),
    
    // 比较运算
    Eq(Box<DslExpr>, Box<DslExpr>),
    Lt(Box<DslExpr>, Box<DslExpr>),
    Gt(Box<DslExpr>, Box<DslExpr>),
    
    // 变量和资源引用
    VarRef(String),
    ResourceRef(String, ResourceAccessType),
    
    // 控制流
    IfThenElse(Box<DslExpr>, Box<DslExpr>, Box<DslExpr>),
    Block(Vec<DslExpr>),
    
    // 资源操作
    CreateResource(String, Box<DslExpr>),
    UseResource(String, Box<DslExpr>),
    ReleaseResource(String),
    
    // 资源转移
    TransferOwnership(String, String),
    
    // 函数定义和调用
    FuncDef(String, Vec<(String, DslType)>, Box<DslExpr>, DslType),
    FuncCall(String, Vec<DslExpr>),
}

// DSL类型系统
#[derive(Debug, Clone, PartialEq)]
enum DslType {
    Int,
    Float,
    Bool,
    String,
    Unit,
    Resource(String), // 资源类型，带有名称
    OwnedResource(String), // 所有资源类型
    BorrowedResource(String, bool), // 借用资源类型（是否可变）
    Function(Vec<DslType>, Box<DslType>), // 函数类型
}

// 资源访问类型
enum ResourceAccessType {
    Read,
    Write,
    Transfer,
}

// 2. 类型检查器

// 类型环境
struct TypeEnv {
    vars: std::collections::HashMap<String, DslType>,
    resources: std::collections::HashMap<String, ResourceState>,
}

// 资源状态
#[derive(Debug, Clone)]
enum ResourceState {
    Owned,
    Borrowed(bool), // 是否可变借用
    Moved,
    Released,
}

impl TypeEnv {
    fn new() -> Self {
        TypeEnv {
            vars: std::collections::HashMap::new(),
            resources: std::collections::HashMap::new(),
        }
    }
    
    // 添加变量类型
    fn add_var(&mut self, name: &str, ty: DslType) {
        self.vars.insert(name.to_string(), ty);
    }
    
    // 获取变量类型
    fn get_var(&self, name: &str) -> Option<&DslType> {
        self.vars.get(name)
    }
    
    // 添加资源
    fn add_resource(&mut self, name: &str, state: ResourceState) {
        self.resources.insert(name.to_string(), state);
    }
    
    // 获取资源状态
    fn get_resource(&self, name: &str) -> Option<&ResourceState> {
        self.resources.get(name)
    }
    
    // 更新资源状态
    fn update_resource(&mut self, name: &str, state: ResourceState) -> Result<(), String> {
        if let Some(current) = self.resources.get(name) {
            match (current, &state) {
                (ResourceState::Moved, _) => {
                    return Err(format!("资源 '{}' 已被移动", name));
                },
                (ResourceState::Released, _) => {
                    return Err(format!("资源 '{}' 已被释放", name));
                },
                (ResourceState::Borrowed(_), ResourceState::Moved) => {
                    return Err(format!("资源 '{}' 被借用时不能移动", name));
                },
                (ResourceState::Borrowed(true), ResourceState::Borrowed(false)) => {
                    return Err(format!("资源 '{}' 已被可变借用", name));
                },
                (ResourceState::Borrowed(false), ResourceState::Borrowed(true)) => {
                    return Err(format!("资源 '{}' 已被不可变借用", name));
                },
                _ => {
                    self.resources.insert(name.to_string(), state);
                }
            }
        } else {
            return Err(format!("资源 '{}' 不存在", name));
        }
        
        Ok(())
    }
}

// 类型检查器
struct TypeChecker {
    env: TypeEnv,
}

impl TypeChecker {
    fn new() -> Self {
        TypeChecker {
            env: TypeEnv::new(),
        }
    }
    
    // 检查表达式类型
    fn check(&mut self, expr: &DslExpr) -> Result<DslType, String> {
        match expr {
            DslExpr::IntLit(_) => Ok(DslType::Int),
            DslExpr::FloatLit(_) => Ok(DslType::Float),
            DslExpr::BoolLit(_) => Ok(DslType::Bool),
            
            DslExpr::Add(left, right) | DslExpr::Sub(left, right) | 
            DslExpr::Mul(left, right) | DslExpr::Div(left, right) => {
                let left_type = self.check(left)?;
                let right_type = self.check(right)?;
                
                match (left_type, right_type) {
                    (DslType::Int, DslType::Int) => Ok(DslType::Int),
                    (DslType::Float, DslType::Float) => Ok(DslType::Float),
                    (DslType::Int, DslType::Float) | (DslType::Float, DslType::Int) => Ok(DslType::Float),
                    _ => Err(format!("类型错误: 不能对 {:?} 和 {:?} 进行算术运算", left_type, right_type)),
                }
            },
            
            DslExpr::Eq(left, right) | DslExpr::Lt(left, right) | DslExpr::Gt(left, right) => {
                let left_type = self.check(left)?;
                let right_type = self.check(right)?;
                
                match (left_type, right_type) {
                    (DslType::Int, DslType::Int) | 
                    (DslType::Float, DslType::Float) | 
                    (DslType::Bool, DslType::Bool) => Ok(DslType::Bool),
                    _ => Err(format!("类型错误: 不能比较 {:?} 和 {:?}", left_type, right_type)),
                }
            },
            
            DslExpr::VarRef(name) => {
                if let Some(var_type) = self.env.get_var(name) {
                    Ok(var_type.clone())
                } else {
                    Err(format!("未定义的变量: {}", name))
                }
            },
            
            DslExpr::ResourceRef(name, access_type) => {
                if let Some(resource_state) = self.env.get_resource(name) {
                    match (resource_state, access_type) {
                        (ResourceState::Owned, ResourceAccessType::Read) => {
                            // 借用只读
                            self.env.update_resource(name, ResourceState::Borrowed(false))?;
                            Ok(DslType::BorrowedResource(name.clone(), false))
                        },
                        (ResourceState::Owned, ResourceAccessType::Write) => {
                            // 借用可变
                            self.env.update_resource(name, ResourceState::Borrowed(true))?;
                            Ok(DslType::BorrowedResource(name.clone(), true))
                        },
                        (ResourceState::Borrowed(false), ResourceAccessType::Read) => {
                            // 多次只读借用允许
                            Ok(DslType::BorrowedResource(name.clone(), false))
                        },
                        (ResourceState::Borrowed(_), _) => {
                            Err(format!("资源 '{}' 已被借用", name))
                        },
                        (ResourceState::Moved, _) => {
                            Err(format!("资源 '{}' 已被移动", name))
                        },
                        (ResourceState::Released, _) => {
                            Err(format!("资源 '{}' 已被释放", name))
                        },
                        (ResourceState::Owned, ResourceAccessType::Transfer) => {
                            // 移动所有权
                            self.env.update_resource(name, ResourceState::Moved)?;
                            Ok(DslType::OwnedResource(name.clone()))
                        },
                    }
                } else {
                    Err(format!("未定义的资源: {}", name))
                }
            },
            
            DslExpr::IfThenElse(cond, then_branch, else_branch) => {
                let cond_type = self.check(cond)?;
                if cond_type != DslType::Bool {
                    return Err(format!("条件表达式必须是布尔类型，得到 {:?}", cond_type));
                }
                
                let then_type = self.check(then_branch)?;
                let else_type = self.check(else_branch)?;
                
                if then_type == else_type {
                    Ok(then_type)
                } else {
                    Err(format!("if-then-else 分支类型不一致: {:?} 和 {:?}", then_type, else_type))
                }
            },
            
            DslExpr::Block(exprs) => {
                let mut result_type = DslType::Unit;
                
                for expr in exprs {
                    result_type = self.check(expr)?;
                }
                
                Ok(result_type)
            },
            
            DslExpr::CreateResource(name, value) => {
                let value_type = self.check(value)?;
                
                // 添加资源到环境
                self.env.add_resource(name, ResourceState::Owned);
                
                Ok(DslType::Resource(name.clone()))
            },
            
            DslExpr::UseResource(name, operation) => {
                // 检查资源是否存在且可用
                if let Some(state) = self.env.get_resource(name) {
                    match state {
                        ResourceState::Owned => {
                            // 可以使用自己拥有的资源
                            self.check(operation)?;
                            Ok(DslType::Unit)
                        },
                        ResourceState::Borrowed(_) => {
                            Err(format!("资源 '{}' 被借用，无法完全使用", name))
                        },
                        ResourceState::Moved => {
                            Err(format!("资源 '{}' 已被移动", name))
                        },
                        ResourceState::Released => {
                            Err(format!("资源 '{}' 已被释放", name))
                        },
                    }
                } else {
                    Err(format!("未定义的资源: {}", name))
                }
            },
            
            DslExpr::ReleaseResource(name) => {
                // 检查资源是否存在且可以释放
                if let Some(state) = self.env.get_resource(name) {
                    match state {
                        ResourceState::Owned => {
                            // 释放拥有的资源
                            self.env.update_resource(name, ResourceState::Released)?;
                            Ok(DslType::Unit)
                        },
                        ResourceState::Borrowed(_) => {
                            Err(format!("资源 '{}' 被借用，无法释放", name))
                        },
                        ResourceState::Moved => {
                            Err(format!("资源 '{}' 已被移动，无法释放", name))
                        },
                        ResourceState::Released => {
                            Err(format!("资源 '{}' 已被释放", name))
                        },
                    }
                } else {
                    Err(format!("未定义的资源: {}", name))
                }
            },
            
            DslExpr::TransferOwnership(from, to) => {
                // 检查源资源是否存在且可以转移
                if let Some(state) = self.env.get_resource(from) {
                    match state {
                        ResourceState::Owned => {
                            // 标记源资源为已移动
                            self.env.update_resource(from, ResourceState::Moved)?;
                            
                            // 添加或更新目标资源
                            if self.env.get_resource(to).is_some() {
                                // 更新已存在的资源状态
                                self.env.update_resource(to, ResourceState::Owned)?;
                            } else {
                                // 创建新资源
                                self.env.add_resource(to, ResourceState::Owned);
                            }
                            
                            Ok(DslType::Unit)
                        },
                        ResourceState::Borrowed(_) => {
                            Err(format!("资源 '{}' 被借用，无法转移所有权", from))
                        },
                        ResourceState::Moved => {
                            Err(format!("资源 '{}' 已被移动，无法转移所有权", from))
                        },
                        ResourceState::Released => {
                            Err(format!("资源 '{}' 已被释放，无法转移所有权", from))
                        },
                    }
                } else {
                    Err(format!("未定义的资源: {}", from))
                }
            },
            
            DslExpr::FuncDef(name, params, body, return_type) => {
                // 创建新的类型环境进行函数体检查
                let mut func_env = self.env.clone();
                
                // 添加参数到环境
                for (param_name, param_type) in params {
                    func_env.add_var(param_name, param_type.clone());
                }
                
                // 临时切换环境
                let old_env = std::mem::replace(&mut self.env, func_env);
                
                // 检查函数体
                let body_type = self.check(body)?;
                
                // 恢复环境
                self.env = old_env;
                
                // 检查返回类型是否匹配
                if &body_type != return_type {
                    return Err(format!("函数返回类型 {:?} 与函数体类型 {:?} 不匹配", return_type, body_type));
                }
                
                // 创建函数类型
                let param_types: Vec<DslType> = params.iter().map(|(_, t)| t.clone()).collect();
                let func_type = DslType::Function(param_types, Box::new(return_type.clone()));
                
                // 添加函数到环境
                self.env.add_var(name, func_type.clone());
                
                Ok(func_type)
            },
            
            DslExpr::FuncCall(name, args) => {
                // 获取函数类型
                let func_type = if let Some(t) = self.env.get_var(name) {
                    t.clone()
                } else {
                    return Err(format!("未定义的函数: {}", name));
                };
                
                // 检查函数类型
                if let DslType::Function(param_types, return_type) = func_type {
                    // 检查参数数量
                    if param_types.len() != args.len() {
                        return Err(format!("函数 {} 需要 {} 个参数，但提供了 {} 个", 
                            name, param_types.len(), args.len()));
                    }
                    
                    // 检查每个参数类型
                    for (i, (arg, expected_type)) in args.iter().zip(param_types.iter()).enumerate() {
                        let arg_type = self.check(arg)?;
                        
                        if &arg_type != expected_type {
                            return Err(format!("参数 {} 类型错误: 期望 {:?}，得到 {:?}", 
                                i + 1, expected_type, arg_type));
                        }
                    }
                    
                    // 返回函数返回类型
                    Ok(*return_type)
                } else {
                    Err(format!("{} 不是一个函数", name))
                }
            }
        }
    }
}

// 3. DSL解释器

// 值类型
enum DslValue {
    Int(i32),
    Float(f64),
    Bool(bool),
    String(String),
    Unit,
    Resource(String, Box<dyn std::any::Any>),
    Function(String, Vec<String>, Box<DslExpr>),
}

// 解释器环境
struct InterpreterEnv {
    values: std::collections::HashMap<String, DslValue>,
}

impl InterpreterEnv {
    fn new() -> Self {
        InterpreterEnv {
            values: std::collections::HashMap::new(),
        }
    }
    
    fn set(&mut self, name: &str, value: DslValue) {
        self.values.insert(name.to_string(), value);
    }
    
    fn get(&self, name: &str) -> Option<&DslValue> {
        self.values.get(name)
    }
    
    fn remove(&mut self, name: &str) -> Option<DslValue> {
        self.values.remove(name)
    }
}

// DSL解释器
struct DslInterpreter {
    env: InterpreterEnv,
}

impl DslInterpreter {
    fn new() -> Self {
        DslInterpreter {
            env: InterpreterEnv::new(),
        }
    }
    
    // 解释执行表达式
    fn eval(&mut self, expr: &DslExpr) -> Result<DslValue, String> {
        match expr {
            DslExpr::IntLit(n) => Ok(DslValue::Int(*n)),
            DslExpr::FloatLit(n) => Ok(DslValue::Float(*n)),
            DslExpr::BoolLit(b) => Ok(DslValue::Bool(*b)),
            
            DslExpr::Add(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => Ok(DslValue::Int(a + b)),
                    (DslValue::Float(a), DslValue::Float(b)) => Ok(DslValue::Float(a + b)),
                    (DslValue::Int(a), DslValue::Float(b)) => Ok(DslValue::Float(a as f64 + b)),
                    (DslValue::Float(a), DslValue::Int(b)) => Ok(DslValue::Float(a + b as f64)),
                    _ => Err("类型错误：不能相加".to_string()),
                }
            },
            
            DslExpr::Sub(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => Ok(DslValue::Int(a - b)),
                    (DslValue::Float(a), DslValue::Float(b)) => Ok(DslValue::Float(a - b)),
                    (DslValue::Int(a), DslValue::Float(b)) => Ok(DslValue::Float(a as f64 - b)),
                    (DslValue::Float(a), DslValue::Int(b)) => Ok(DslValue::Float(a - b as f64)),
                    _ => Err("类型错误：不能相减".to_string()),
                }
            },
            
            DslExpr::Mul(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => Ok(DslValue::Int(a * b)),
                    (DslValue::Float(a), DslValue::Float(b)) => Ok(DslValue::Float(a * b)),
                    (DslValue::Int(a), DslValue::Float(b)) => Ok(DslValue::Float(a as f64 * b)),
                    (DslValue::Float(a), DslValue::Int(b)) => Ok(DslValue::Float(a * b as f64)),
                    _ => Err("类型错误：不能相乘".to_string()),
                }
            },
            
            DslExpr::Div(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => {
                        if b == 0 {
                            return Err("除零错误".to_string());
                        }
                        Ok(DslValue::Int(a / b))
                    },
                    (DslValue::Float(a), DslValue::Float(b)) => {
                        if b == 0.0 {
                            return Err("除零错误".to_string());
                        }
                        Ok(DslValue::Float(a / b))
                    },
                    (DslValue::Int(a), DslValue::Float(b)) => {
                        if b == 0.0 {
                            return Err("除零错误".to_string());
                        }
                        Ok(DslValue::Float(a as f64 / b))
                    },
                    (DslValue::Float(a), DslValue::Int(b)) => {
                        if b == 0 {
                            return Err("除零错误".to_string());
                        }
                        Ok(DslValue::Float(a / b as f64))
                    },
                    _ => Err("类型错误：不能相除".to_string()),
                }
            },
            
            DslExpr::Eq(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => Ok(DslValue::Bool(a == b)),
                    (DslValue::Float(a), DslValue::Float(b)) => Ok(DslValue::Bool(a == b)),
                    (DslValue::Bool(a), DslValue::Bool(b)) => Ok(DslValue::Bool(a == b)),
                    (DslValue::String(a), DslValue::String(b)) => Ok(DslValue::Bool(a == b)),
                    _ => Ok(DslValue::Bool(false)), // 不同类型的值不相等
                }
            },
            
            DslExpr::Lt(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => Ok(DslValue::Bool(a < b)),
                    (DslValue::Float(a), DslValue::Float(b)) => Ok(DslValue::Bool(a < b)),
                    (DslValue::Int(a), DslValue::Float(b)) => Ok(DslValue::Bool((a as f64) < b)),
                    (DslValue::Float(a), DslValue::Int(b)) => Ok(DslValue::Bool(a < (b as f64))),
                    _ => Err("类型错误：不能比较大小".to_string()),
                }
            },
            
            DslExpr::Gt(left, right) => {
                let left_val = self.eval(left)?;
                let right_val = self.eval(right)?;
                
                match (left_val, right_val) {
                    (DslValue::Int(a), DslValue::Int(b)) => Ok(DslValue::Bool(a > b)),
                    (DslValue::Float(a), DslValue::Float(b)) => Ok(DslValue::Bool(a > b)),
                    (DslValue::Int(a), DslValue::Float(b)) => Ok(DslValue::Bool((a as f64) > b)),
                    (DslValue::Float(a), DslValue::Int(b)) => Ok(DslValue::Bool(a > (b as f64))),
                    _ => Err("类型错误：不能比较大小".to_string()),
                }
            },
            
            DslExpr::VarRef(name) => {
                if let Some(value) = self.env.get(name) {
                    // 返回值的克隆
                    match value {
                        DslValue::Int(n) => Ok(DslValue::Int(*n)),
                        DslValue::Float(n) => Ok(DslValue::Float(*n)),
                        DslValue::Bool(b) => Ok(DslValue::Bool(*b)),
                        DslValue::String(s) => Ok(DslValue::String(s.clone())),
                        DslValue::Unit => Ok(DslValue::Unit),
                        DslValue::Resource(_, _) => Err(format!("资源 {} 不能直接引用，需要使用ResourceRef", name)),
                        DslValue::Function(f, params, body) => 
                            Ok(DslValue::Function(f.clone(), params.clone(), body.clone())),
                    }
                } else {
                    Err(format!("未定义的变量: {}", name))
                }
            },
            
            DslExpr::ResourceRef(name, access_type) => {
                // 检查资源是否存在
                if let Some(value) = self.env.get(name) {
                    match (value, access_type) {
                        (DslValue::Resource(res_type, data), ResourceAccessType::Read) => {
                            println!("读取资源 {}: 类型 {}", name, res_type);
                            // 只读访问，返回资源的引用
                            Ok(DslValue::Resource(res_type.clone(), data.clone()))
                        },
                        (DslValue::Resource(res_type, data), ResourceAccessType::Write) => {
                            println!("可变访问资源 {}: 类型 {}", name, res_type);
                            // 可变访问，返回资源的引用
                            Ok(DslValue::Resource(res_type.clone(), data.clone()))
                        },
                        (DslValue::Resource(res_type, _), ResourceAccessType::Transfer) => {
                            println!("转移资源 {}: 类型 {}", name, res_type);
                            // 转移访问，返回资源自身
                            let resource = self.env.remove(name)
                                .expect("资源突然消失");
                            
                            if let DslValue::Resource(res_type, data) = resource {
                                Ok(DslValue::Resource(res_type, data))
                            } else {
                                unreachable!()
                            }
                        },
                        _ => Err(format!("值 {} 不是资源", name)),
                    }
                } else {
                    Err(format!("未定义的资源: {}", name))
                }
            },
            
            DslExpr::IfThenElse(cond, then_branch, else_branch) => {
                let cond_val = self.eval(cond)?;
                
                match cond_val {
                    DslValue::Bool(true) => self.eval(then_branch),
                    DslValue::Bool(false) => self.eval(else_branch),
                    _ => Err("条件表达式必须是布尔类型".to_string()),
                }
            },
            
            DslExpr::Block(exprs) => {
                let mut result = DslValue::Unit;
                
                for expr in exprs {
                    result = self.eval(expr)?;
                }
                
                Ok(result)
            },
            
            DslExpr::CreateResource(name, value) => {
                let value = self.eval(value)?;
                
                // 创建资源
                let resource = DslValue::Resource(format!("用户资源"), Box::new(value));
                
                // 存储资源
                self.env.set(name, resource);
                
                println!("创建资源: {}", name);
                
                Ok(DslValue::Unit)
            },
            
            DslExpr::UseResource(name, operation) => {
                // 检查资源是否存在
                if self.env.get(name).is_some() {
                    // 执行操作
                    let result = self.eval(operation)?;
                    println!("使用资源 {}", name);
                    Ok(result)
                } else {
                    Err(format!("未定义的资源: {}", name))
                }
            },
            
            DslExpr::ReleaseResource(name) => {
                // 检查资源是否存在
                if let Some(_) = self.env.remove(name) {
                    println!("释放资源: {}", name);
                    Ok(DslValue::Unit)
                } else {
                    Err(format!("未定义的资源: {}", name))
                }
            },
            
            DslExpr::TransferOwnership(from, to) => {
                // 检查源资源是否存在
                if let Some(resource) = self.env.remove(from) {
                    // 存储到目标
                    self.env.set(to, resource);
                    println!("将资源所有权从 {} 转移到 {}", from, to);
                    Ok(DslValue::Unit)
                } else {
                    Err(format!("未定义的资源: {}", from))
                }
            },
            
            DslExpr::FuncDef(name, params, body, _) => {
                // 提取参数名
                let param_names: Vec<String> = params.iter()
                    .map(|(name, _)| name.clone())
                    .collect();
                
                // 创建函数值
                let func = DslValue::Function(name.clone(), param_names, body.clone());
                
                // 存储函数
                self.env.set(name, func);
                
                Ok(DslValue::Unit)
            },
            
            DslExpr::FuncCall(name, args) => {
                // 获取函数
                let func = if let Some(f) = self.env.get(name) {
                    match f {
                        DslValue::Function(fname, params, body) => {
                            // 克隆函数定义
                            (fname.clone(), params.clone(), body.clone())
                        },
                        _ => return Err(format!("{} 不是一个函数", name)),
                    }
                } else {
                    return Err(format!("未定义的函数: {}", name));
                };
                
                // 解构函数
                let (func_name, param_names, func_body) = func;
                
                // 检查参数数量
                if param_names.len() != args.len() {
                    return Err(format!("函数 {} 需要 {} 个参数，但提供了 {} 个", 
                        func_name, param_names.len(), args.len()));
                }
                
                // 创建新环境
                let mut new_env = InterpreterEnv::new();
                
                // 评估参数并绑定到新环境
                for (name, arg_expr) in param_names.iter().zip(args.iter()) {
                    let arg_val = self.eval(arg_expr)?;
                    new_env.set(name, arg_val);
                }
                
                // 临时切换环境
                let old_env = std::mem::replace(&mut self.env, new_env);
                
                // 执行函数体
                let result = self.eval(&func_body);
                
                // 恢复环境
                self.env = old_env;
                
                result
            },
        }
    }
}

// 4. 所有权类型的DSL示例
fn ownership_dsl_example() {
    // 创建DSL示例程序
    
    // 1. 创建资源
    let create_resources = DslExpr::Block(vec![
        DslExpr::CreateResource("buffer".to_string(), Box::new(
            DslExpr::IntLit(1024)
        )),
        DslExpr::CreateResource("connection".to_string(), Box::new(
            DslExpr::Block(vec![
                DslExpr::CreateResource("host".to_string(), Box::new(
                    DslExpr::IntLit(127)
                )),
                DslExpr::CreateResource("port".to_string(), Box::new(
                    DslExpr::IntLit(8080)
                ))
            ])
        ))
    ]);
    
    // 2. 使用资源
    let use_resources = DslExpr::Block(vec![
        // 使用缓冲区资源
        DslExpr::UseResource("buffer".to_string(), Box::new(
            DslExpr::ResourceRef("buffer".to_string(), ResourceAccessType::Write)
        )),
        
        // 读取连接信息
        DslExpr::UseResource("connection".to_string(), Box::new(
            DslExpr::ResourceRef("connection".to_string(), ResourceAccessType::Read)
        ))
    ]);
    
    // 3. 转移所有权
    let transfer_ownership = DslExpr::Block(vec![
        DslExpr::TransferOwnership("buffer".to_string(), "new_buffer".to_string()),
        
        // 尝试使用转移后的资源（应该失败）
        DslExpr::UseResource("buffer".to_string(), Box::new(
            DslExpr::ResourceRef("buffer".to_string(), ResourceAccessType::Read)
        )),
        
        // 使用新资源
        DslExpr::UseResource("new_buffer".to_string(), Box::new(
            DslExpr::ResourceRef("new_buffer".to_string(), ResourceAccessType::Read)
        ))
    ]);
    
    // 4. 释放资源
    let release_resources = DslExpr::Block(vec![
        DslExpr::ReleaseResource("new_buffer".to_string()),
        DslExpr::ReleaseResource("connection".to_string()),
    ]);
    
    // 5. 类型检查
    println!("\n=== DSL 类型检查 ===");
    let mut type_checker = TypeChecker::new();
    
    match type_checker.check(&create_resources) {
        Ok(_) => println!("创建资源表达式类型正确"),
        Err(e) => println!("类型错误: {}", e),
    }
    
    match type_checker.check(&use_resources) {
        Ok(_) => println!("使用资源表达式类型正确"),
        Err(e) => println!("类型错误: {}", e),
    }
    
    // 为了演示，我们不检查转移和释放资源的表达式
    // 因为它们会修改类型环境状态
    
    // 6. 解释执行
    println!("\n=== DSL 执行 ===");
    let mut interpreter = DslInterpreter::new();
    
    // 创建资源
    match interpreter.eval(&create_resources) {
        Ok(_) => println!("成功创建资源"),
        Err(e) => println!("执行错误: {}", e),
    }
    
    // 使用资源
    match interpreter.eval(&use_resources) {
        Ok(_) => println!("成功使用资源"),
        Err(e) => println!("执行错误: {}", e),
    }
    
    // 转移所有权
    println!("\n尝试转移所有权：");
    match interpreter.eval(&transfer_ownership) {
        Ok(_) => println!("意外成功：应该在尝试使用已转移的资源时失败"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 转移部分后释放资源
    println!("\n释放资源：");
    match interpreter.eval(&DslExpr::TransferOwnership("buffer".to_string(), "new_buffer".to_string())) {
        Ok(_) => println!("成功转移资源"),
        Err(e) => println!("转移错误: {}", e),
    }
    
    match interpreter.eval(&release_resources) {
        Ok(_) => println!("成功释放资源"),
        Err(e) => println!("释放错误: {}", e),
    }
}
```

### 编码资源状态与流转

将资源状态和流转编码到类型系统中：

1. **状态机与类型转换**
   - 资源状态到类型的映射
   - 状态转换验证的类型检查

2. **资源生命周期的类型表达**
   - 资源创建与销毁的类型语义
   - 生命周期在编程语言中的编码

3. **可组合的状态类型运算**
   - 复合状态的类型组合操作
   - 多资源协同的状态组合

```rust
// 编码资源状态与流转示例

// 1. 状态类型定义

// 标记类型：初始状态
struct Uninitialized;

// 标记类型：已初始化
struct Initialized;

// 标记类型：活跃状态
struct Active;

// 标记类型：暂停状态
struct Paused;

// 标记类型：关闭状态
struct Closed;

// 2. 资源类型带状态信息
struct TypedResource<State> {
    id: u32,
    name: String,
    data: Vec<u8>,
    _state: std::marker::PhantomData<State>,
}

// 3. 状态转换定义
trait StateTransition<From, To> {
    fn transition(self) -> Result<TypedResource<To>, &'static str>;
}

// 具体状态转换实现

// 未初始化 -> 已初始化
impl StateTransition<Uninitialized, Initialized> for TypedResource<Uninitialized> {
    fn transition(self) -> Result<TypedResource<Initialized>, &'static str> {
        println!("资源 {} 初始化", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 已初始化 -> 活跃
impl StateTransition<Initialized, Active> for TypedResource<Initialized> {
    fn transition(self) -> Result<TypedResource<Active>, &'static str> {
        println!("激活资源 {}", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 活跃 -> 暂停
impl StateTransition<Active, Paused> for TypedResource<Active> {
    fn transition(self) -> Result<TypedResource<Paused>, &'static str> {
        println!("暂停资源 {}", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 暂停 -> 活跃
impl StateTransition<Paused, Active> for TypedResource<Paused> {
    fn transition(self) -> Result<TypedResource<Active>, &'static str> {
        println!("恢复资源 {}", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 活跃 -> 关闭
impl StateTransition<Active, Closed> for TypedResource<Active> {
    fn transition(self) -> Result<TypedResource<Closed>, &'static str> {
        println!("关闭活跃资源 {}", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 暂停 -> 关闭
impl StateTransition<Paused, Closed> for TypedResource<Paused> {
    fn transition(self) -> Result<TypedResource<Closed>, &'static str> {
        println!("关闭暂停资源 {}", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 已初始化 -> 关闭
impl StateTransition<Initialized, Closed> for TypedResource<Initialized> {
    fn transition(self) -> Result<TypedResource<Closed>, &'static str> {
        println!("关闭未激活资源 {}", self.name);
        
        Ok(TypedResource {
            id: self.id,
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        })
    }
}

// 4. 状态相关操作

// 未初始化状态可用操作
impl TypedResource<Uninitialized> {
    // 创建新资源
    fn new(id: u32, name: &str) -> Self {
        println!("创建资源 {} (ID: {})", name, id);
        
        TypedResource {
            id,
            name: name.to_string(),
            data: Vec::new(),
            _state: std::marker::PhantomData,
        }
    }
    
    // 设置初始数据
    fn with_data(mut self, data: Vec<u8>) -> Self {
        println!("设置资源 {} 的初始数据: {} 字节", self.name, data.len());
        
        self.data = data;
        self
    }
}

// 已初始化状态可用操作
impl TypedResource<Initialized> {
    // 读取数据
    fn read_data(&self) -> &[u8] {
        println!("读取已初始化资源 {} 的数据", self.name);
        
        &self.data
    }
    
    // 更新某个部分的数据
    fn update_partial(&mut self, offset: usize, new_data: &[u8]) -> Result<(), &'static str> {
        if offset + new_data.len() > self.data.len() {
            return Err("超出数据范围");
        }
        
        println!("更新已初始化资源 {} 的部分数据: 从偏移量 {}", self.name, offset);
        
        for (i, &byte) in new_data.iter().enumerate() {
            self.data[offset + i] = byte;
        }
        
        Ok(())
    }
}

// 活跃状态可用操作
impl TypedResource<Active> {
    // 读取数据
    fn read_data(&self) -> &[u8] {
        println!("读取活跃资源 {} 的数据", self.name);
        
        &self.data
    }
    
    // 写入数据
    fn write_data(&mut self, new_data: Vec<u8>) {
        println!("写入活跃资源 {} 的新数据: {} 字节", self.name, new_data.len());
        
        self.data = new_data;
    }
    
    // 追加数据
    fn append_data(&mut self, additional_data: &[u8]) {
        println!("向活跃资源 {} 追加数据: {} 字节", self.name, additional_data.len());
        
        self.data.extend_from_slice(additional_data);
    }
    
    // 清空数据
    fn clear_data(&mut self) {
        println!("清空活跃资源 {} 的数据", self.name);
        
        self.data.clear();
    }
}

// 暂停状态可用操作
impl TypedResource<Paused> {
    // 读取数据（只读）
    fn read_data(&self) -> &[u8] {
        println!("读取暂停资源 {} 的数据", self.name);
        
        &self.data
    }
    
    // 查询状态
    fn get_status(&self) -> String {
        println!("查询暂停资源 {} 的状态", self.name);
        
        format!("Paused: {} bytes of data", self.data.len())
    }
}

// 关闭状态可用操作
impl TypedResource<Closed> {
    // 获取资源ID
    fn id(&self) -> u32 {
        self.id
    }
    
    // 获取资源名称
    fn name(&self) -> &str {
        &self.name
    }
    
    // 检查是否有数据
    fn has_data(&self) -> bool {
        !self.data.is_empty()
    }
    
    // 销毁资源，返回最终数据
    fn destroy(self) -> Vec<u8> {
        println!("销毁关闭的资源 {}", self.name);
        
        self.data
    }
}

// 5. 资源管理器
struct ResourceManager {
    next_id: u32,
    active_count: usize,
}

impl ResourceManager {
    fn new() -> Self {
        ResourceManager {
            next_id: 1,
            active_count: 0,
        }
    }
    
    // 创建新资源
    fn create_resource(&mut self, name: &str) -> TypedResource<Uninitialized> {
        let id = self.next_id;
        self.next_id += 1;
        self.active_count += 1;
        
        TypedResource::new(id, name)
    }
    
    // 注销已关闭的资源
    fn release_resource(&mut self, resource: TypedResource<Closed>) {
        self.active_count -= 1;
        
        println!("管理器注销资源 {}", resource.name());
        
        // 资源被丢弃
        let _ = resource.destroy();
    }
    
    // 获取活跃资源数量
    fn active_resources(&self) -> usize {
        self.active_count
    }
}

// 6. 复合资源状态示例

// 两个资源的组合状态
struct ResourcePair<S1, S2> {
    resource1: TypedResource<S1>,
    resource2: TypedResource<S2>,
}

impl<S1, S2> ResourcePair<S1, S2> {
    fn new(resource1: TypedResource<S1>, resource2: TypedResource<S2>) -> Self {
        ResourcePair {
            resource1,
            resource2,
        }
    }
}

// 同时转换两个资源的状态
trait PairTransition<FromS1, ToS1, FromS2, ToS2> {
    fn transition_both(self) -> Result<ResourcePair<ToS1, ToS2>, &'static str>;
}

// 实现一个特定状态转换：(初始化,初始化) -> (活跃,活跃)
impl PairTransition<Initialized, Active, Initialized, Active> 
    for ResourcePair<Initialized, Initialized> 
{
    fn transition_both(self) -> Result<ResourcePair<Active, Active>, &'static str> {
        println!("同时激活资源对 {} 和 {}", self.resource1.name, self.resource2.name);
        
        let resource1 = self.resource1.transition()?;
        let resource2 = self.resource2.transition()?;
        
        Ok(ResourcePair::new(resource1, resource2))
    }
}

// 7. 状态编码示例
fn state_encoding_example() {
    // 创建资源管理器
    let mut manager = ResourceManager::new();
    
    println!("\n=== 单个资源状态转换示例 ===");
    
    // 创建未初始化资源
    let resource = manager.create_resource("database-connection")
        .with_data(b"connection-metadata".to_vec());
    
    println!("\n初始化资源");
    // 初始化资源
    let mut initialized = resource.transition().unwrap();
    
    // 读取数据
    let data = initialized.read_data();
    println!("初始化后数据: {}", String::from_utf8_lossy(data));
    
    // 更新部分数据
    initialized.update_partial(0, b"DATABASE").unwrap();
    
    println!("\n激活资源");
    // 激活资源
    let mut active = initialized.transition().unwrap();
    
    // 读取和写入数据
    println!("激活后数据: {}", String::from_utf8_lossy(active.read_data()));
    active.append_data(b"-ACTIVE-STATE".to_vec().as_slice());
    println!("追加后数据: {}", String::from_utf8_lossy(active.read_data()));
    
    println!("\n暂停资源");
    // 暂停资源
    let paused = active.transition().unwrap();
    
    // 读取数据和状态
    println!("暂停后数据: {}", String::from_utf8_lossy(paused.read_data()));
    println!("资源状态: {}", paused.get_status());
    
    println!("\n恢复资源");
    // 恢复资源
    let mut active = paused.transition().unwrap();
    
    // 清空数据
    active.clear_data();
    active.write_data(b"NEW-DATA-AFTER-RESUME".to_vec());
    
    println!("\n关闭资源");
    // 关闭资源
    let closed = active.transition().unwrap();
    
    // 检查资源信息
    println!("资源ID: {}", closed.id());
    println!("资源名称: {}", closed.name());
    println!("资源有数据: {}", closed.has_data());
    
    // 释放资源
    manager.release_resource(closed);
    
    println!("\n=== 复合资源状态转换示例 ===");
    
    // 创建两个资源
    let resource1 = manager.create_resource("cache")
        .with_data(b"cache-initial-data".to_vec());
    let resource2 = manager.create_resource("logger")
        .with_data(b"logger-initial-data".to_vec());
    
    // 初始化两个资源
    let initialized1 = resource1.transition().unwrap();
    let initialized2 = resource2.transition().unwrap();
    
    // 创建资源对
    let pair = ResourcePair::new(initialized1, initialized2);
    
    // 同时激活两个资源
    let active_pair = pair.transition_both().unwrap();
    
    // 使用活跃的资源对
    println!("资源对激活成功: {} 和 {}", 
        active_pair.resource1.name, 
        active_pair.resource2.name);
    
    // 单独关闭每个资源
    let closed1 = active_pair.resource1.transition().unwrap();
    let closed2 = active_pair.resource2.transition().unwrap();
    
    // 释放资源
    manager.release_resource(closed1);
    manager.release_resource(closed2);
    
    println!("\n最终活跃资源数量: {}", manager.active_resources());
}
```

### 可组合的资源抽象

构建可灵活组合的资源抽象：

1. **资源组合与分解**
   - 构建复合资源抽象
   - 安全地分解资源组合

2. **资源视图与投影**
   - 创建资源的受限视图
   - 通过投影隔离资源访问

3. **资源组合操作**
   - 基于所有权的安全组合操作
   - 资源组合的不变性保证

```rust
// 可组合的资源抽象示例

// 1. 基础资源类型
trait Resource {
    fn id(&self) -> u32;
    fn name(&self) -> &str;
    fn resource_type(&self) -> &str;
}

// 2. 具体资源类型

// 内存资源
struct MemoryResource {
    id: u32,
    name: String,
    data: Vec<u8>,
    capacity: usize,
}

impl MemoryResource {
    fn new(id: u32, name: &str, capacity: usize) -> Self {
        MemoryResource {
            id,
            name: name.to_string(),
            data: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    fn read(&self) -> &[u8] {
        &self.data
    }
    
    fn write(&mut self, data: &[u8]) -> Result<(), &'static str> {
        if data.len() > self.capacity {
            return Err("数据超出内存容量");
        }
        
        self.data.clear();
        self.data.extend_from_slice(data);
        
        Ok(())
    }
    
    fn available_capacity(&self) -> usize {
        self.capacity - self.data.len()
    }
}

impl Resource for MemoryResource {
    fn id(&self) -> u32 {
        self.id
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn resource_type(&self) -> &str {
        "内存资源"
    }
}

// 文件资源
struct FileResource {
    id: u32,
    name: String,
    path: String,
    is_open: bool,
}

impl FileResource {
    fn new(id: u32, name: &str, path: &str) -> Self {
        FileResource {
            id,
            name: name.to_string(),
            path: path.to_string(),
            is_open: false,
        }
    }
    
    fn open(&mut self) -> Result<(), &'static str> {
        if self.is_open {
            return Err("文件已经打开");
        }
        
        println!("打开文件 {}", self.path);
        self.is_open = true;
        
        Ok(())
    }
    
    fn close(&mut self) -> Result<(), &'static str> {
        if !self.is_open {
            return Err("文件已经关闭");
        }
        
        println!("关闭文件 {}", self.path);
        self.is_open = false;
        
        Ok(())
    }
    
    fn read(&self) -> Result<String, &'static str> {
        if !self.is_open {
            return Err("文件未打开");
        }
        
        println!("读取文件 {}", self.path);
        // 模拟文件读取
        Ok(format!("文件 {} 的内容", self.path))
    }
    
    fn write(&mut self, content: &str) -> Result<(), &'static str> {
        if !self.is_open {
            return Err("文件未打开");
        }
        
        println!("写入文件 {}: {}", self.path, content);
        // 模拟文件写入
        
        Ok(())
    }
}

impl Resource for FileResource {
    fn id(&self) -> u32 {
        self.id
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn resource_type(&self) -> &str {
        "文件资源"
    }
}

// 网络资源
struct NetworkResource {
    id: u32,
    name: String,
    endpoint: String,
    connected: bool,
}

impl NetworkResource {
    fn new(id: u32, name: &str, endpoint: &str) -> Self {
        NetworkResource {
            id,
            name: name.to_string(),
            endpoint: endpoint.to_string(),
            connected: false,
        }
    }
    
    fn connect(&mut self) -> Result<(), &'static str> {
        if self.connected {
            return Err("已经连接");
        }
        
        println!("连接到 {}", self.endpoint);
        self.connected = true;
        
        Ok(())
    }
    
    fn disconnect(&mut self) -> Result<(), &'static str> {
        if !self.connected {
            return Err("未连接");
        }
        
        println!("断开与 {} 的连接", self.endpoint);
        self.connected = false;
        
        Ok(())
    }
    
    fn send(&self, data: &[u8]) -> Result<(), &'static str> {
        if !self.connected {
            return Err("未连接");
        }
        
        println!("发送 {} 字节到 {}", data.len(), self.endpoint);
        // 模拟网络发送
        
        Ok(())
    }
    
    fn receive(&self) -> Result<Vec<u8>, &'static str> {
        if !self.connected {
            return Err("未连接");
        }
        
        println!("从 {} 接收数据", self.endpoint);
        // 模拟网络接收
        Ok(b"received data".to_vec())
    }
}

impl Resource for NetworkResource {
    fn id(&self) -> u32 {
        self.id
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn resource_type(&self) -> &str {
        "网络资源"
    }
}

// 3. 资源视图和投影

// 只读内存视图
struct ReadOnlyMemoryView<'a> {
    resource: &'a MemoryResource,
}

impl<'a> ReadOnlyMemoryView<'a> {
    fn new(resource: &'a MemoryResource) -> Self {
        ReadOnlyMemoryView { resource }
    }
    
    fn read(&self) -> &[u8] {
        self.resource.read()
    }
    
    fn size(&self) -> usize {
        self.resource.read().len()
    }
    
    fn capacity(&self) -> usize {
        self.resource.capacity
    }
}

// 文件读取视图
struct FileReadView<'a> {
    resource: &'a FileResource,
}

impl<'a> FileReadView<'a> {
    fn new(resource: &'a FileResource) -> Self {
        FileReadView { resource }
    }
    
    fn read(&self) -> Result<String, &'static str> {
        self.resource.read()
    }
    
    fn is_open(&self) -> bool {
        self.resource.is_open
    }
}

// 文件写入视图
struct FileWriteView<'a> {
    resource: &'a mut FileResource,
}

impl<'a> FileWriteView<'a> {
    fn new(resource: &'a mut FileResource) -> Self {
        FileWriteView { resource }
    }
    
    fn write(&mut self, content: &str) -> Result<(), &'static str> {
        self.resource.write(content)
    }
    
    fn open(&mut self) -> Result<(), &'static str> {
        self.resource.open()
    }
    
    fn close(&mut self) -> Result<(), &'static str> {
        self.resource.close()
    }
}

// 4. 复合资源

// 缓存资源（组合内存和文件）
struct CachedStorage {
    id: u32,
    name: String,
    memory: MemoryResource,
    file: FileResource,
    dirty: bool,
}

impl CachedStorage {
    fn new(id: u32, name: &str, memory_capacity: usize, file_path: &str) -> Self {
        CachedStorage {
            id,
            name: name.to_string(),
            memory: MemoryResource::new(id + 1000, &format!("{}-memory", name), memory_capacity),
            file: FileResource::new(id + 2000, &format!("{}-file", name), file_path),
            dirty: false,
        }
    }
    
    // 读取数据，优先从内存读取
    fn read(&self) -> Result<Vec<u8>, &'static str> {
        // 如果内存中有数据，直接返回
        let memory_data = self.memory.read();
        if !memory_data.is_empty() {
            return Ok(memory_data.to_vec());
        }
        
        // 否则从文件读取
        if !self.file.is_open {
            return Err("存储未打开");
        }
        
        let file_data = self.file.read()?;
        println!("从文件加载到缓存: {}", file_data);
        
        Ok(file_data.into_bytes())
    }
    
    // 写入数据到内存
    fn write(&mut self, data: &[u8]) -> Result<(), &'static str> {
        self.memory.write(data)?;
        self.dirty = true;
        
        Ok(())
    }
    
    // 打开存储
    fn open(&mut self) -> Result<(), &'static str> {
        self.file.open()?;
        println!("打开缓存存储 {}", self.name);
        
        Ok(())
    }
    
    // 关闭存储，如果有脏数据，先刷新到文件
    fn close(&mut self) -> Result<(), &'static str> {
        if self.dirty {
            self.flush()?;
        }
        
        self.file.close()?;
        println!("关闭缓存存储 {}", self.name);
        
        Ok(())
    }
    
    // 刷新内存数据到文件
    fn flush(&mut self) -> Result<(), &'static str> {
        if !self.dirty {
            return Ok(());
        }
        
        let memory_data = self.memory.read();
        let data_str = String::from_utf8_lossy(memory_data).to_string();
        
        self.file.write(&data_str)?;
        self.dirty = false;
        
        println!("刷新缓存到文件: {} 字节", memory_data.len());
        
        Ok(())
    }
    
    // 分解为组件
    fn decompose(self) -> (MemoryResource, FileResource) {
        println!("分解缓存存储 {} 为独立组件", self.name);
        (self.memory, self.file)
    }
    
    // 获取只读内存视图
    fn memory_view(&self) -> ReadOnlyMemoryView {
        ReadOnlyMemoryView::new(&self.memory)
    }
    
    // 获取文件读取视图
    fn file_read_view(&self) -> FileReadView {
        FileReadView::new(&self.file)
    }
    
    // 获取文件写入视图
    fn file_write_view(&mut self) -> FileWriteView {
        FileWriteView::new(&mut self.file)
    }
}

impl Resource for CachedStorage {
    fn id(&self) -> u32 {
        self.id
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn resource_type(&self) -> &str {
        "缓存存储"
    }
}

// 数据流水线（组合网络和内存）
struct DataPipeline {
    id: u32,
    name: String,
    source: NetworkResource,
    buffer: MemoryResource,
    processing: bool,
}

impl DataPipeline {
    fn new(id: u32, name: &str, endpoint: &str, buffer_capacity: usize) -> Self {
        DataPipeline {
            id,
            name: name.to_string(),
            source: NetworkResource::new(id + 3000, &format!("{}-network", name), endpoint),
            buffer: MemoryResource::new(id + 4000, &format!("{}-buffer", name), buffer_capacity),
            processing: false,
        }
    }
    
    // 启动流水线
    fn start(&mut self) -> Result<(), &'static str> {
        if self.processing {
            return Err("流水线已在运行");
        }
        
        self.source.connect()?;
        self.processing = true;
        
        println!("启动数据流水线 {}", self.name);
        
        Ok(())
    }
    
    // 停止流水线
    fn stop(&mut self) -> Result<(), &'static str> {
        if !self.processing {
            return Err("流水线未运行");
        }
        
        self.source.disconnect()?;
        self.processing = false;
        
        println!("停止数据流水线 {}", self.name);
        
        Ok(())
    }
    
    // 接收数据
    fn receive(&mut self) -> Result<&[u8], &'static str> {
        if !self.processing {
            return Err("流水线未运行");
        }
        
        // 从网络接收数据
        let data = self.source.receive()?;
        
        // 写入缓冲区
        self.buffer.write(&data)?;
        
        println!("流水线接收并处理 {} 字节数据", data.len());
        
        Ok(self.buffer.read())
    }
    
    // 处理并发送数据
    fn process_and_send(&mut self, transform: fn(&[u8]) -> Vec<u8>) -> Result<(), &'static str> {
        if !self.processing {
            return Err("流水线未运行");
        }
        
        // 读取当前缓冲区
        let input = self.buffer.read();
        
        // 应用转换
        let output = transform(input);
        
        // 发送处理后的数据
        self.source.send(&output)?;
        
        println!("流水线处理 {} 字节输入，发送 {} 字节输出",
            input.len(), output.len());
            
        Ok(())
    }
    
    // 分解为组件
    fn decompose(self) -> (NetworkResource, MemoryResource) {
        println!("分解数据流水线 {} 为独立组件", self.name);
        (self.source, self.buffer)
    }
}

impl Resource for DataPipeline {
    fn id(&self) -> u32 {
        self.id
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn resource_type(&self) -> &str {
        "数据流水线"
    }
}

// 5. 资源工厂
struct ResourceFactory {
    next_id: u32,
}

impl ResourceFactory {
    fn new() -> Self {
        ResourceFactory { next_id: 1 }
    }
    
    fn create_memory_resource(&mut self, name: &str, capacity: usize) -> MemoryResource {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂创建内存资源 {}, ID={}", name, id);
        MemoryResource::new(id, name, capacity)
    }
    
    fn create_file_resource(&mut self, name: &str, path: &str) -> FileResource {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂创建文件资源 {}, ID={}", name, id);
        FileResource::new(id, name, path)
    }
    
    fn create_network_resource(&mut self, name: &str, endpoint: &str) -> NetworkResource {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂创建网络资源 {}, ID={}", name, id);
        NetworkResource::new(id, name, endpoint)
    }
    
    fn create_cached_storage(&mut self, name: &str, memory_capacity: usize, file_path: &str) -> CachedStorage {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂创建缓存存储 {}, ID={}", name, id);
        CachedStorage::new(id, name, memory_capacity, file_path)
    }
    
    fn create_data_pipeline(&mut self, name: &str, endpoint: &str, buffer_capacity: usize) -> DataPipeline {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂创建数据流水线 {}, ID={}", name, id);
        DataPipeline::new(id, name, endpoint, buffer_capacity)
    }
    
    // 从组件创建缓存存储
    fn combine_into_cached_storage(&mut self, name: &str, memory: MemoryResource, file: FileResource) -> CachedStorage {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂将组件合并为缓存存储 {}, ID={}", name, id);
        
        CachedStorage {
            id,
            name: name.to_string(),
            memory,
            file,
            dirty: false,
        }
    }
    
    // 从组件创建数据流水线
    fn combine_into_data_pipeline(&mut self, name: &str, network: NetworkResource, buffer: MemoryResource) -> DataPipeline {
        let id = self.next_id;
        self.next_id += 1;
        
        println!("工厂将组件合并为数据流水线 {}, ID={}", name, id);
        
        DataPipeline {
            id,
            name: name.to_string(),
            source: network,
            buffer,
            processing: false,
        }
    }
}

// 6. 可组合的资源抽象示例
fn composable_resources_example() {
    let mut factory = ResourceFactory::new();
    
    println!("\n=== 创建和使用基础资源 ===");
    
    // 创建内存资源
    let mut memory = factory.create_memory_resource("app-cache", 1024);
    memory.write(b"Hello, Memory Resource!").unwrap();
    println!("内存数据: {}", String::from_utf8_lossy(memory.read()));
    
    // 创建文件资源
    let mut file = factory.create_file_resource("config", "/etc/app/config.txt");
    file.open().unwrap();
    file.write("app_mode=production").unwrap();
    println!("文件内容: {}", file.read().unwrap());
    file.close().unwrap();
    
    // 创建网络资源
    let mut network = factory.create_network_resource("api-endpoint", "api.example.com:443");
    network.connect().unwrap();
    network.send(b"GET /status").unwrap();
    let response = network.receive().unwrap();
    println!("网络响应: {}", String::from_utf8_lossy(&response));
    network.disconnect().unwrap();
    
    println!("\n=== 资源视图示例 ===");
    
    // 使用内存视图
    let mem_view = ReadOnlyMemoryView::new(&memory);
    println!("通过视图读取内存: {}", String::from_utf8_lossy(mem_view.read()));
    println!("内存视图大小: {}/{} 字节", mem_view.size(), mem_view.capacity());
    
    // 文件打开并使用视图
    file.open().unwrap();
    
    // 文件读取视图
    let file_read = FileReadView::new(&file);
    println!("通过读取视图: {}", file_read.read().unwrap());
    
    // 文件写入视图
    let mut file_write = FileWriteView::new(&mut file);
    file_write.write("app_mode=debug").unwrap();
    
    file.close().unwrap();
    
    println!("\n=== 复合资源示例 ===");
    
    // 创建缓存存储
    let mut cache = factory.create_cached_storage("user-data", 2048, "/var/cache/users.dat");
    cache.open().unwrap();
    cache.write(b"cached user data").unwrap();
    println!("缓存读取: {}", String::from_utf8_lossy(&cache.read().unwrap()));
    
    // 使用缓存存储的内存视图
    let cache_mem_view = cache.memory_view();
    println!("缓存内存视图大小: {}/{} 字节", 
        cache_mem_view.size(), cache_mem_view.capacity());
    
    // 刷新并关闭
    cache.flush().unwrap();
    cache.close().unwrap();
    
    // 创建数据流水线
    let mut pipeline = factory.create_data_pipeline("log-processor", "logs.example.com:8080", 4096);
    pipeline.start().unwrap();
    
    // 接收数据
    let received = pipeline.receive().unwrap();
    println!("流水线接收: {}", String::from_utf8_lossy(received));
    
    // 处理并发送
    pipeline.process_and_send(|data| {
        // 简单转换：转为大写
        data.iter().map(|&b| b.to_ascii_uppercase()).collect()
    }).unwrap();
    
    pipeline.stop().unwrap();
    
    println!("\n=== 资源分解和重组 ===");
    
    // 分解缓存存储
    let (cache_memory, cache_file) = cache.decompose();
    println!("分解得到内存组件: {} ({})", 
        cache_memory.name(), String::from_utf8_lossy(cache_memory.read()));
    println!("分解得到文件组件: {}", cache_file.name());
    
    // 分解数据流水线
    let (pipeline_network, pipeline_buffer) = pipeline.decompose();
    println!("分解得到网络组件: {}", pipeline_network.name());
    println!("分解得到缓冲区组件: {}", pipeline_buffer.name());
    
    // 使用工厂重组组件
    let recombined_cache = factory.combine_into_cached_storage(
        "recombined-cache", 
        cache_memory, 
        cache_file
    );
    
    let recombined_pipeline = factory.combine_into_data_pipeline(
        "recombined-pipeline",
        pipeline_network,
        pipeline_buffer
    );
    
    println!("重组后缓存: {} ({})", 
        recombined_cache.name(), recombined_cache.resource_type());
    println!("重组后流水线: {} ({})",
        recombined_pipeline.name(), recombined_pipeline.resource_type());
}
```

## 所有权与程序正确性

### 编译期验证与运行时安全

所有权如何提高编译期验证和运行时安全：

1. **编译时所有权验证**
   - 所有权违规的静态捕获
   - 资源泄露的编译时预防

2. **运行时所有权追踪**
   - 动态所有权状态的维护
   - 防止非法访问的运行时检查

3. **编译时与运行时结合**
   - 静态验证与动态安全的结合
   - 最小化运行时开销的设计

```rust
// 编译期验证与运行时安全示例

// 1. 编译时所有权验证
struct CompileTimeResource {
    data: Vec<u8>,
}

impl CompileTimeResource {
    fn new(data: Vec<u8>) -> Self {
        CompileTimeResource { data }
    }
    
    // 消费型方法 - 获取数据并销毁资源
    fn consume(self) -> Vec<u8> {
        self.data
    }
    
    // 借用型方法 - 获取数据引用
    fn borrow(&self) -> &[u8] {
        &self.data
    }
    
    // 可变借用型方法 - 修改数据
    fn modify(&mut self, new_data: &[u8]) {
        self.data.clear();
        self.data.extend_from_slice(new_data);
    }
}

// 2. 运行时所有权跟踪

// 拥有者标识
#[derive(Debug, Clone, Copy, PartialEq)]
struct OwnerId(u32);

// 运行时跟踪的资源
struct RuntimeResource {
    data: Vec<u8>,
    owner: Option<OwnerId>,
    borrowers: Vec<OwnerId>,
    mutable_borrower: Option<OwnerId>,
}

impl RuntimeResource {
    fn new(data: Vec<u8>, owner: OwnerId) -> Self {
        RuntimeResource {
            data,
            owner: Some(owner),
            borrowers: Vec::new(),
            mutable_borrower: None,
        }
    }
    
    // 尝试转移所有权
    fn transfer_to(&mut self, from: OwnerId, to: OwnerId) -> Result<(), &'static str> {
        // 验证当前所有者
        if self.owner != Some(from) {
            return Err("不是资源所有者");
        }
        
        // 检查是否有借用
        if !self.borrowers.is_empty() || self.mutable_borrower.is_some() {
            return Err("资源正在被借用，无法转移所有权");
        }
        
        // 转移所有权
        self.owner = Some(to);
        Ok(())
    }
    
    // 尝试借用
    fn borrow(&mut self, borrower: OwnerId) -> Result<&[u8], &'static str> {
        // 检查是否有可变借用
        if let Some(current) = self.mutable_borrower {
            return Err("资源已被可变借用");
        }
        
        // 添加借用者
        if !self.borrowers.contains(&borrower) {
            self.borrowers.push(borrower);
        }
        
        // 返回数据引用
        Ok(&self.data)
    }
    
    // 尝试可变借用
    fn borrow_mut(&mut self, borrower: OwnerId) -> Result<&mut Vec<u8>, &'static str> {
        // 检查是否有借用者
        if !self.borrowers.is_empty() {
            return Err("资源已被不可变借用");
        }
        
        // 检查是否已被可变借用
        if let Some(current) = self.mutable_borrower {
            if current != borrower {
                return Err("资源已被其他人可变借用");
            }
        }
        
        // 设置可变借用
        self.mutable_borrower = Some(borrower);
        
        // 返回可变数据引用
        Ok(&mut self.data)
    }
    
    // 释放借用
    fn release_borrow(&mut self, borrower: OwnerId) {
        // 移除不可变借用者
        self.borrowers.retain(|&b| b != borrower);
        
        // 清除可变借用
        if self.mutable_borrower == Some(borrower) {
            self.mutable_borrower = None;
        }
    }
    
    // 销毁资源
    fn destroy(mut self, owner: OwnerId) -> Result<Vec<u8>, &'static str> {
        // 验证所有者
        if self.owner != Some(owner) {
            return Err("不是资源所有者");
        }
        
        // 检查是否有借用
        if !self.borrowers.is_empty() || self.mutable_borrower.is_some() {
            return Err("资源正在被借用，无法销毁");
        }
        
        // 返回数据
        Ok(self.data)
    }
}

// 3. 混合静态和动态验证

// 资源句柄 - 编译时类型安全，运行时动态检查
struct ResourceHandle<'a> {
    resource_id: u32,
    owner_id: OwnerId,
    tracker: &'a mut ResourceTracker,
}

// 资源借用句柄 - 只读
struct ResourceBorrowHandle<'a> {
    resource_id: u32,
    borrower_id: OwnerId,
    tracker: &'a mut ResourceTracker,
}

// 资源可变借用句柄
struct ResourceMutBorrowHandle<'a> {
    resource_id: u32,
    borrower_id: OwnerId,
    tracker: &'a mut ResourceTracker,
}

// 资源跟踪器
struct ResourceTracker {
    resources: std::collections::HashMap<u32, RuntimeResource>,
    next_resource_id: u32,
}

impl ResourceTracker {
    fn new() -> Self {
        ResourceTracker {
            resources: std::collections::HashMap::new(),
            next_resource_id: 1,
        }
    }
    
    // 创建新资源
    fn create_resource(&mut self, data: Vec<u8>, owner: OwnerId) -> ResourceHandle {
        let resource_id = self.next_resource_id;
        self.next_resource_id += 1;
        
        let resource = RuntimeResource::new(data, owner);
        self.resources.insert(resource_id, resource);
        
        ResourceHandle {
            resource_id,
            owner_id: owner,
            tracker: self,
        }
    }
    
    // 内部：访问资源
    fn get_resource(&self, id: u32) -> Option<&RuntimeResource> {
        self.resources.get(&id)
    }
    
    // 内部：可变访问资源
    fn get_resource_mut(&mut self, id: u32) -> Option<&mut RuntimeResource> {
        self.resources.get_mut(&id)
    }
}

impl<'a> ResourceHandle<'a> {
    // 转移所有权
    fn transfer_to(self, new_owner: OwnerId) -> Result<ResourceHandle<'a>, &'static str> {
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            resource.transfer_to(self.owner_id, new_owner)?;
            
            Ok(ResourceHandle {
                resource_id: self.resource_id,
                owner_id: new_owner,
                tracker: self.tracker,
            })
        } else {
            Err("资源不存在")
        }
    }
    
    // 借用资源
    fn borrow(&mut self, borrower: OwnerId) -> Result<ResourceBorrowHandle, &'static str> {
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            // 尝试借用
            resource.borrow(borrower)?;
            
            Ok(ResourceBorrowHandle {
                resource_id: self.resource_id,
                borrower_id: borrower,
                tracker: self.tracker,
            })
        } else {
            Err("资源不存在")
        }
    }
    
    // 可变借用资源
    fn borrow_mut(&mut self, borrower: OwnerId) -> Result<ResourceMutBorrowHandle, &'static str> {
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            // 尝试可变借用
            resource.borrow_mut(borrower)?;
            
            Ok(ResourceMutBorrowHandle {
                resource_id: self.resource_id,
                borrower_id: borrower,
                tracker: self.tracker,
            })
        } else {
            Err("资源不存在")
        }
    }
    
    // 读取数据（所有者直接读取）
    fn read(&self) -> Result<&[u8], &'static str> {
        if let Some(resource) = self.tracker.get_resource(self.resource_id) {
            if resource.owner != Some(self.owner_id) {
                return Err("不再是资源所有者");
            }
            
            Ok(&resource.data)
        } else {
            Err("资源不存在")
        }
    }
    
    // 修改数据（所有者直接修改）
    fn modify(&mut self, new_data: &[u8]) -> Result<(), &'static str> {
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            if resource.owner != Some(self.owner_id) {
                return Err("不再是资源所有者");
            }
            
            // 检查是否有借用
            if !resource.borrowers.is_empty() || resource.mutable_borrower.is_some() {
                return Err("资源正在被借用，无法修改");
            }
            
            // 修改数据
            resource.data.clear();
            resource.data.extend_from_slice(new_data);
            
            Ok(())
        } else {
            Err("资源不存在")
        }
    }
    
    // 消费资源
    fn consume(self) -> Result<Vec<u8>, &'static str> {
        if let Some(resource) = self.tracker.resources.remove(&self.resource_id) {
            // 尝试销毁并获取数据
            resource.destroy(self.owner_id)
        } else {
            Err("资源不存在")
        }
    }
}

impl<'a> ResourceBorrowHandle<'a> {
    // 读取数据
    fn read(&self) -> Result<&[u8], &'static str> {
        if let Some(resource) = self.tracker.get_resource(self.resource_id) {
            // 验证仍然是借用者
            if !resource.borrowers.contains(&self.borrower_id) {
                return Err("不再是资源借用者");
            }
            
            Ok(&resource.data)
        } else {
            Err("资源不存在")
        }
    }
}

impl<'a> Drop for ResourceBorrowHandle<'a> {
    fn drop(&mut self) {
        // 释放借用
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            resource.release_borrow(self.borrower_id);
        }
    }
}

impl<'a> ResourceMutBorrowHandle<'a> {
    // 读取数据
    fn read(&self) -> Result<&[u8], &'static str> {
        if let Some(resource) = self.tracker.get_resource(self.resource_id) {
            // 验证仍然是可变借用者
            if resource.mutable_borrower != Some(self.borrower_id) {
                return Err("不再是资源可变借用者");
            }
            
            Ok(&resource.data)
        } else {
            Err("资源不存在")
        }
    }
    
    // 修改数据
    fn modify(&mut self, new_data: &[u8]) -> Result<(), &'static str> {
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            // 验证仍然是可变借用者
            if resource.mutable_borrower != Some(self.borrower_id) {
                return Err("不再是资源可变借用者");
            }
            
            // 修改数据
            resource.data.clear();
            resource.data.extend_from_slice(new_data);
            
            Ok(())
        } else {
            Err("资源不存在")
        }
    }
}

impl<'a> Drop for ResourceMutBorrowHandle<'a> {
    fn drop(&mut self) {
        // 释放可变借用
        if let Some(resource) = self.tracker.get_resource_mut(self.resource_id) {
            resource.release_borrow(self.borrower_id);
        }
    }
}

// 4. 编译期验证与运行时安全示例
fn compilation_runtime_safety_example() {
    println!("\n=== 编译期所有权验证示例 ===");
    
    // 创建资源
    let resource = CompileTimeResource::new(b"编译时验证的数据".to_vec());
    
    // 借用读取数据
    let data_ref = resource.borrow();
    println!("编译时借用读取: {}", String::from_utf8_lossy(data_ref));
    
    // 可变借用
    let mut resource_mut = resource; // 所有权移动
    resource_mut.modify(b"修改后的数据");
    
    // 读取修改后的数据
    let data_ref = resource_mut.borrow();
    println!("修改后数据: {}", String::from_utf8_lossy(data_ref));
    
    // 消费资源
    let final_data = resource_mut.consume();
    println!("消费资源后获得数据: {}", String::from_utf8_lossy(&final_data));
    
    // 尝试再次使用将导致编译错误
    // let invalid_ref = resource_mut.borrow(); // 编译错误: 资源已被移动
    
    println!("\n=== 运行时所有权跟踪示例 ===");
    
    // 创建资源跟踪器
    let mut tracker = ResourceTracker::new();
    
    // 定义用户ID
    let alice = OwnerId(1);
    let bob = OwnerId(2);
    
    // Alice创建资源
    let mut handle = tracker.create_resource(b"运行时追踪的数据".to_vec(), alice);
    println!("Alice创建了资源 {}", handle.resource_id);
    
    // Alice读取数据
    match handle.read() {
        Ok(data) => println!("Alice读取: {}", String::from_utf8_lossy(data)),
        Err(e) => println!("错误: {}", e),
    }
    
    // Alice允许Bob借用
    let mut bob_borrow = match handle.borrow(bob) {
        Ok(borrow) => {
            println!("Bob成功借用资源");
            borrow
        },
        Err(e) => {
            println!("Bob借用失败: {}", e);
            return;
        }
    };
    
    // Bob读取数据
    match bob_borrow.read() {
        Ok(data) => println!("Bob读取: {}", String::from_utf8_lossy(data)),
        Err(e) => println!("错误: {}", e),
    }
    
    // Alice尝试修改数据（应该失败，因为Bob正在借用）
    match handle.modify(b"Alice尝试修改".to_vec().as_slice()) {
        Ok(_) => println!("意外: Alice能够修改借出的资源"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // Bob完成借用
    drop(bob_borrow);
    println!("Bob归还借用");
    
    // Alice现在可以修改数据
    match handle.modify(b"Alice修改的数据".to_vec().as_slice()) {
        Ok(_) => println!("Alice成功修改资源"),
        Err(e) => println!("错误: {}", e),
    }
    
    // Alice允许Bob可变借用
    let mut bob_mut_borrow = match handle.borrow_mut(bob) {
        Ok(borrow) => {
            println!("Bob成功可变借用资源");
            borrow
        },
        Err(e) => {
            println!("Bob可变借用失败: {}", e);
            return;
        }
    };
    
    // Bob修改数据
    match bob_mut_borrow.modify(b"Bob修改的数据".to_vec().as_slice()) {
        Ok(_) => println!("Bob成功修改资源"),
        Err(e) => println!("错误: {}", e),
    }
    
    // Alice尝试读取数据（应该失败，因为Bob正在可变借用）
    match handle.read() {
        Ok(data) => println!("意外: Alice能够读取被可变借用的资源: {}", String::from_utf8_lossy(data)),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // Bob完成可变借用
    drop(bob_mut_borrow);
    println!("Bob归还可变借用");
    
    // Alice转移所有权给Bob
    handle = match handle.transfer_to(bob) {
        Ok(new_handle) => {
            println!("Alice将资源所有权转移给Bob");
            new_handle
        },
        Err(e) => {
            println!("所有权转移失败: {}", e);
            return;
        }
    };
    
    // Bob读取数据（现在作为所有者）
    match handle.read() {
        Ok(data) => println!("Bob作为所有者读取: {}", String::from_utf8_lossy(data)),
        Err(e) => println!("错误: {}", e),
    }
    
    // Bob销毁资源
    match handle.consume() {
        Ok(data) => println!("Bob销毁资源，最终数据: {}", String::from_utf8_lossy(&data)),
        Err(e) => println!("销毁失败: {}", e),
    }
}
```

### 资源泄漏与生命周期

处理资源泄漏和生命周期管理：

1. **自动释放机制**
   - RAII原则在Rust中的应用
   - Drop trait与资源释放

2. **防止循环引用**
   - 循环引用导致的内存泄漏
   - 弱引用与循环打破

3. **显式生命周期管理**
   - 生命周期注解的意义
   - 借用检查器的工作原理

```rust
// 资源泄漏与生命周期示例

// 1. RAII与资源自动释放

// 文件句柄
struct FileHandle {
    path: String,
    is_open: bool,
}

impl FileHandle {
    fn new(path: &str) -> Self {
        println!("创建文件句柄: {}", path);
        
        FileHandle {
            path: path.to_string(),
            is_open: false,
        }
    }
    
    fn open(&mut self) -> Result<(), &'static str> {
        if self.is_open {
            return Err("文件已打开");
        }
        
        println!("打开文件: {}", self.path);
        self.is_open = true;
        
        Ok(())
    }
    
    fn close(&mut self) -> Result<(), &'static str> {
        if !self.is_open {
            return Err("文件未打开");
        }
        
        println!("关闭文件: {}", self.path);
        self.is_open = false;
        
        Ok(())
    }
    
    fn is_open(&self) -> bool {
        self.is_open
    }
}

// 实现Drop来确保资源释放
impl Drop for FileHandle {
    fn drop(&mut self) {
        if self.is_open {
            println!("在析构函数中自动关闭文件: {}", self.path);
            let _ = self.close();
        }
        
        println!("释放文件句柄: {}", self.path);
    }
}

// RAII文件包装
struct RaiiFile {
    handle: FileHandle,
}

impl RaiiFile {
    fn new(path: &str) -> Result<Self, &'static str> {
        let mut handle = FileHandle::new(path);
        handle.open()?;
        
        Ok(RaiiFile { handle })
    }
    
    fn path(&self) -> &str {
        &self.handle.path
    }
    
    // 其他文件操作...
}

// 自动应用Drop
impl Drop for RaiiFile {
    fn drop(&mut self) {
        println!("RAII文件包装析构");
        // FileHandle的drop会自动处理关闭
    }
}

// 2. 处理循环引用

use std::rc::{Rc, Weak};
use std::cell::RefCell;

// 节点结构体
struct Node {
    id: u32,
    name: String,
    // 强引用可能导致循环引用
    strong_children: Vec<Rc<RefCell<Node>>>,
    // 弱引用不会导致循环引用
    parent: Option<Weak<RefCell<Node>>>,
}

impl Node {
    fn new(id: u32, name: &str) -> Self {
        println!("创建节点 {}: {}", id, name);
        
        Node {
            id,
            name: name.to_string(),
            strong_children: Vec::new(),
            parent: None,
        }
    }
    
    fn add_child(&mut self, child: Rc<RefCell<Node>>) {
        // 设置父节点（使用弱引用）
        child.borrow_mut().parent = Some(Rc::downgrade(&Rc::new(RefCell::new(self.clone()))));
        
        // 添加子节点（强引用）
        self.strong_children.push(child);
    }
    
    fn child_count(&self) -> usize {
        self.strong_children.len()
    }
}

// 实现Clone
impl Clone for Node {
    fn clone(&self) -> Self {
        Node {
            id: self.id,
            name: self.name.clone(),
            strong_children: self.strong_children.clone(),
            parent: self.parent.clone(),
        }
    }
}

// 实现Drop来跟踪节点释放
impl Drop for Node {
    fn drop(&mut self) {
        println!("释放节点 {}: {}", self.id, self.name);
    }
}

// 3. 显式生命周期管理

// 资源管理器
struct ResourceManager<'a> {
    resources: Vec<&'a str>,
}

impl<'a> ResourceManager<'a> {
    fn new() -> Self {
        ResourceManager {
            resources: Vec::new(),
        }
    }
    
    // 添加资源引用
    fn add_resource(&mut self, resource: &'a str) {
        println!("添加资源: {}", resource);
        self.resources.push(resource);
    }
    
    // 获取资源
    fn get_resource(&self, index: usize) -> Option<&'a str> {
        self.resources.get(index).copied()
    }
    
    // 计算两个资源的组合长度
    fn combined_length(&self, index1: usize, index2: usize) -> Option<usize> {
        let resource1 = self.get_resource(index1)?;
        let resource2 = self.get_resource(index2)?;
        
        Some(resource1.len() + resource2.len())
    }
    
    // 返回最长资源
    fn longest_resource<'b>(&self, r1: &'b str, r2: &'b str) -> &'b str {
        if r1.len() > r2.len() { r1 } else { r2 }
    }
}

// 具有生命周期约束的结构体
struct ResourceView<'a> {
    resource: &'a str,
}

impl<'a> ResourceView<'a> {
    fn new(resource: &'a str) -> Self {
        ResourceView { resource }
    }
    
    fn get(&self) -> &'a str {
        self.resource
    }
}

// 生命周期边界示例
struct ResourceContainer<'a, T: 'a> {
    name: &'a str,
    value: T,
}

// 4. 资源泄漏与生命周期示例
fn resource_leak_lifetime_example() {
    println!("\n=== RAII资源管理示例 ===");
    
    // 使用域块控制资源生命周期
    {
        // 创建文件句柄
        let mut file_handle = FileHandle::new("example.txt");
        
        // 打开文件
        match file_handle.open() {
            Ok(_) => println!("文件成功打开"),
            Err(e) => println!("打开文件失败: {}", e),
        }
        
        println!("文件状态: {}", if file_handle.is_open() { "打开" } else { "关闭" });
        
        // 不需要显式关闭，离开作用域会自动关闭
    } // file_handle被销毁，Drop trait的实现保证文件被关闭
    
    // 使用RAII文件包装
    {
        let raii_file = match RaiiFile::new("data.txt") {
            Ok(file) => file,
            Err(e) => {
                println!("创建RAII文件失败: {}", e);
                return;
            }
        };
        
        println!("使用RAII包装的文件: {}", raii_file.path());
        // 做一些文件操作...
        
    } // raii_file被销毁，自动关闭文件
    
    println!("\n=== 处理循环引用示例 ===");
    
    // 创建节点
    let node1 = Rc::new(RefCell::new(Node::new(1, "根节点")));
    let node2 = Rc::new(RefCell::new(Node::new(2, "子节点1")));
    let node3 = Rc::new(RefCell::new(Node::new(3, "子节点2")));
    
    // 建立父子关系
    {
        let mut node1_mut = node1.borrow_mut();
        node1_mut.add_child(node2.clone());
        node1_mut.add_child(node3.clone());
        
        println!("根节点有 {} 个子节点", node1_mut.child_count());
    }
    
    // 打印引用计数
    println!("节点1引用计数: {}", Rc::strong_count(&node1));
    println!("节点2引用计数: {}", Rc::strong_count(&node2));
    println!("节点3引用计数: {}", Rc::strong_count(&node3));
    
    // 创建循环引用（会造成内存泄漏）
    let node4 = Rc::new(RefCell::new(Node::new(4, "循环节点1")));
    let node5 = Rc::new(RefCell::new(Node::new(5, "循环节点2")));
    
    // 相互引用
    {
        node4.borrow_mut().strong_children.push(node5.clone());
        node5.borrow_mut().strong_children.push(node4.clone());
    }
    
    println!("节点4引用计数: {}", Rc::strong_count(&node4));
    println!("节点5引用计数: {}", Rc::strong_count(&node5));
    
    // 即使原始变量超出作用域，由于循环引用，节点4和5不会被释放
    drop(node4);
    drop(node5);
    println!("尝试丢弃循环引用的节点（可能不会真正释放）");
    
    println!("\n=== 显式生命周期管理示例 ===");
    
    // 创建资源和管理器
    let string1 = String::from("长字符串资源");
    let string2 = String::from("短资源");
    
    {
        let mut manager = ResourceManager::new();
        
        // 添加资源引用
        manager.add_resource(&string1);
        manager.add_resource(&string2);
        
        // 获取资源
        match manager.get_resource(0) {
            Some(res) => println!("资源0: {}", res),
            None => println!("资源0不存在"),
        }
        
        // 计算组合长度
        match manager.combined_length(0, 1) {
            Some(len) => println!("资源0和资源1的组合长度: {}", len),
            None => println!("无法计算组合长度"),
        }
        
        // 查找最长资源
        let longest = manager.longest_resource(&string1, &string2);
        println!("最长资源: {}", longest);
        
        // 创建资源视图
        let view = ResourceView::new(&string1);
        println!("资源视图: {}", view.get());
        
        // 创建包含引用的资源容器
        let container = ResourceContainer {
            name: &string1,
            value: 42,
        };
        
        println!("资源容器: {} = {}", container.name, container.value);
    }
}
```

### 所有权优化与性能

所有权系统对性能的影响和优化：

1. **所有权的零成本抽象**
   - 无运行时开销的所有权检查
   - 与手写内存管理的性能比较

2. **移动语义与复制避免**
   - 移动而非复制的性能优势
   - 智能指针的高效实现

3. **借用检查器优化**
   - 借用检查如何避免不必要的检查
   - 对性能的实际影响

```rust
// 所有权优化与性能示例

use std::time::{Duration, Instant};
use std::rc::Rc;

// 1. 所有权的零成本抽象

// 直接管理的资源
struct DirectResource {
    data: Vec<u32>,
}

impl DirectResource {
    fn new(size: usize) -> Self {
        let data = vec![0; size];
        DirectResource { data }
    }
    
    fn get(&self, index: usize) -> Option<u32> {
        self.data.get(index).copied()
    }
    
    fn set(&mut self, index: usize, value: u32) -> Result<(), &'static str> {
        if index < self.data.len() {
            self.data[index] = value;
            Ok(())
        } else {
            Err("索引超出范围")
        }
    }
    
    fn size(&self) -> usize {
        self.data.len()
    }
}

// 使用智能指针的间接资源
struct IndirectResource {
    data: Box<Vec<u32>>,
}

impl IndirectResource {
    fn new(size: usize) -> Self {
        let data = vec![0; size];
        IndirectResource { data: Box::new(data) }
    }
    
    fn get(&self, index: usize) -> Option<u32> {
        self.data.get(index).copied()
    }
    
    fn set(&mut self, index: usize, value: u32) -> Result<(), &'static str> {
        if index < self.data.len() {
            self.data[index] = value;
            Ok(())
        } else {
            Err("索引超出范围")
        }
    }
    
    fn size(&self) -> usize {
        self.data.len()
    }
}

// 使用共享引用计数的资源
struct SharedResource {
    data: Rc<Vec<u32>>,
}

impl SharedResource {
    fn new(size: usize) -> Self {
        let data = vec![0; size];
        SharedResource { data: Rc::new(data) }
    }
    
    fn get(&self, index: usize) -> Option<u32> {
        self.data.get(index).copied()
    }
    
    // 注意：由于使用Rc，无法直接修改
    fn clone(&self) -> Self {
        SharedResource { data: Rc::clone(&self.data) }
    }
    
    fn size(&self) -> usize {
        self.data.len()
    }
}

// 使用内部可变性的共享资源
struct MutableSharedResource {
    data: Rc<std::cell::RefCell<Vec<u32>>>,
}

impl MutableSharedResource {
    fn new(size: usize) -> Self {
        let data = vec![0; size];
        MutableSharedResource { data: Rc::new(std::cell::RefCell::new(data)) }
    }
    
    fn get(&self, index: usize) -> Option<u32> {
        self.data.borrow().get(index).copied()
    }
    
    fn set(&self, index: usize, value: u32) -> Result<(), &'static str> {
        let mut data = self.data.borrow_mut();
        if index < data.len() {
            data[index] = value;
            Ok(())
        } else {
            Err("索引超出范围")
        }
    }
    
    fn clone(&self) -> Self {
        MutableSharedResource { data: Rc::clone(&self.data) }
    }
    
    fn size(&self) -> usize {
        self.data.borrow().len()
    }
}

// 2. 移动语义与复制避免

// 大型数据结构
struct LargeData {
    matrix: Vec<Vec<f64>>,
}

impl LargeData {
    fn new(rows: usize, cols: usize) -> Self {
        let matrix = vec![vec![0.0; cols]; rows];
        LargeData { matrix }
    }
    
    fn rows(&self) -> usize {
        self.matrix.len()
    }
    
    fn cols(&self) -> usize {
        if self.matrix.is_empty() {
            0
        } else {
            self.matrix[0].len()
        }
    }
    
    fn get(&self, row: usize, col: usize) -> Option<f64> {
        self.matrix.get(row).and_then(|r| r.get(col)).copied()
    }
    
    fn set(&mut self, row: usize, col: usize, value: f64) -> Result<(), &'static str> {
        if row < self.rows() && col < self.cols() {
            self.matrix[row][col] = value;
            Ok(())
        } else {
            Err("索引超出范围")
        }
    }
}

// 实现Clone以便测试复制性能
impl Clone for LargeData {
    fn clone(&self) -> Self {
        let mut matrix = Vec::with_capacity(self.rows());
        for row in &self.matrix {
            matrix.push(row.clone());
        }
        LargeData { matrix }
    }
}

// 3. 借用检查对性能的影响

// 通过引用访问
fn process_by_ref(data: &mut LargeData) {
    for i in 0..data.rows() {
        for j in 0..data.cols() {
            if let Ok(_) = data.set(i, j, (i as f64) * (j as f64)) {
                // 处理每个元素...
            }
        }
    }
}

// 通过所有权访问（低效，因为需要移动和返回）
fn process_by_ownership(mut data: LargeData) -> LargeData {
    for i in 0..data.rows() {
        for j in 0..data.cols() {
            if let Ok(_) = data.set(i, j, (i as f64) * (j as f64)) {
                // 处理每个元素...
            }
        }
    }
    data
}

// 4. 基准测试函数
fn benchmark<F>(name: &str, count: usize, f: F)
    where F: FnOnce() -> Duration
{
    let duration = f();
    let per_op = duration.as_nanos() as f64 / count as f64;
    
    println!("{}: 总时间 = {:?}, 每操作 = {:.2} ns", name, duration, per_op);
}

// 5. 所有权优化与性能示例
fn ownership_performance_example() {
    let iterations = 1_000_000;
    let large_size = 1000;
    
    println!("\n=== 所有权的零成本抽象性能比较 ===");
    
    // 直接管理资源性能
    benchmark("直接资源访问", iterations, || {
        let start = Instant::now();
        
        let mut resource = DirectResource::new(100);
        for i in 0..iterations {
            resource.set(i % resource.size(), i as u32).unwrap();
            let _ = resource.get(i % resource.size());
        }
        
        start.elapsed()
    });
    
    // 间接资源性能
    benchmark("间接资源访问 (Box)", iterations, || {
        let start = Instant::now();
        
        let mut resource = IndirectResource::new(100);
        for i in 0..iterations {
            resource.set(i % resource.size(), i as u32).unwrap();
            let _ = resource.get(i % resource.size());
        }
        
        start.elapsed()
    });
    
    // 共享资源性能测试
    benchmark("共享资源克隆 (Rc)", iterations, || {
        let start = Instant::now();
        
        let resource = SharedResource::new(100);
        for i in 0..iterations {
            let cloned = resource.clone();
            let _ = cloned.get(i % cloned.size());
        }
        
        start.elapsed()
    });
    
    // 内部可变性资源性能
    benchmark("内部可变性资源 (RefCell)", iterations / 10, || {
        let start = Instant::now();
        
        let resource = MutableSharedResource::new(100);
        for i in 0..(iterations / 10) {
            resource.set(i % resource.size(), i as u32).unwrap();
            let _ = resource.get(i % resource.size());
        }
        
        start.elapsed()
    });
    
    println!("\n=== 移动语义与复制避免性能比较 ===");
    
    // 移动大型数据结构
    benchmark("移动大型数据", 100, || {
        let start = Instant::now();
        
        let mut data = LargeData::new(large_size, large_size);
        
        // 模拟在函数间传递数据（移动语义）
        for _ in 0..100 {
            let temp = data; // 移动
            data = temp;     // 移动回来
        }
        
        start.elapsed()
    });
    
    // 复制大型数据结构
    benchmark("复制大型数据", 10, || {
        let start = Instant::now();
        
        let data = LargeData::new(large_size, large_size);
        
        // 显式复制
        for _ in 0..10 {
            let _copied = data.clone();
        }
        
        start.elapsed()
    });
    
    println!("\n=== 借用检查性能影响 ===");
    
    // 通过引用处理
    benchmark("通过引用处理", 10, || {
        let start = Instant::now();
        
        let mut data = LargeData::new(100, 100);
        for _ in 0..10 {
            process_by_ref(&mut data);
        }
        
        start.elapsed()
    });
    
    // 通过所有权处理
    benchmark("通过所有权处理", 10, || {
        let start = Instant::now();
        
        let mut data = LargeData::new(100, 100);
        for _ in 0..10 {
            data = process_by_ownership(data);
        }
        
        start.elapsed()
    });
}
```

### 自定义的内存分配策略

使用所有权系统自定义内存分配策略：

1. **自定义分配器**
   - Rust分配器API的使用
   - 实现专用分配器的策略

2. **堆外内存管理**
   - 管理操作系统和特殊硬件内存
   - 为非Rust管理的资源提供安全接口

3. **资源池与对象复用**
   - 高效的资源池实现
   - 基于所有权的资源检出与归还

```rust
// 自定义的内存分配策略示例

use std::alloc::{alloc, dealloc, Layout};
use std::ptr::NonNull;
use std::marker::PhantomData;
use std::mem;

// 1. 自定义分配器

// 内存块结构
struct MemoryBlock {
    ptr: NonNull<u8>,
    layout: Layout,
}

impl MemoryBlock {
    // 分配内存块
    fn new(size: usize, align: usize) -> Result<Self, &'static str> {
        let layout = Layout::from_size_align(size, align)
            .map_err(|_| "无效的内存布局")?;
            
        // 使用系统分配器分配内存
        let ptr = unsafe {
            let ptr = alloc(layout);
            if ptr.is_null() {
                return Err("内存分配失败");
            }
            NonNull::new_unchecked(ptr)
        };
        
        Ok(MemoryBlock { ptr, layout })
    }
    
    // 获取指针
    fn as_ptr(&self) -> *mut u8 {
        self.ptr.as_ptr()
    }
    
    // 获取大小
    fn size(&self) -> usize {
        self.layout.size()
    }
}

// 自动释放内存
impl Drop for MemoryBlock {
    fn drop(&mut self) {
        unsafe {
            dealloc(self.ptr.as_ptr(), self.layout);
        }
    }
}

// 自定义分配器
struct CustomAllocator {
    total_allocated: usize,
    peak_allocated: usize,
    allocation_count: usize,
}

impl CustomAllocator {
    fn new() -> Self {
        CustomAllocator {
            total_allocated: 0,
            peak_allocated: 0,
            allocation_count: 0,
        }
    }
    
    // 分配内存
    fn allocate(&mut self, size: usize, align: usize) -> Result<MemoryBlock, &'static str> {
        let block = MemoryBlock::new(size, align)?;
        
        // 更新统计信息
        self.total_allocated += size;
        self.peak_allocated = self.peak_allocated.max(self.total_allocated);
        self.allocation_count += 1;
        
        println!("已分配 {} 字节内存块 (总计: {})", size, self.total_allocated);
        
        Ok(block)
    }
    
    // 释放内存（隐式通过MemoryBlock的Drop实现）
    fn deallocate(&mut self, size: usize) {
        self.total_allocated = self.total_allocated.saturating_sub(size);
        println!("已释放 {} 字节内存块 (总计: {})", size, self.total_allocated);
    }
    
    // 获取统计信息
    fn stats(&self) -> (usize, usize, usize) {
        (self.total_allocated, self.peak_allocated, self.allocation_count)
    }
}

// 2. 堆外内存管理

// 堆外内存包装
struct OffHeapMemory {
    ptr: NonNull<u8>,
    size: usize,
}

impl OffHeapMemory {
    // 分配堆外内存
    fn new(size: usize) -> Result<Self, &'static str> {
        // 调用系统API分配内存
        // 实际实现可能使用mmap或其他系统调用
        let layout = Layout::from_size_align(size, 64) // 使用大对齐以优化性能
            .map_err(|_| "无效的内存布局")?;
            
        let ptr = unsafe {
            let ptr = alloc(layout);
            if ptr.is_null() {
                return Err("堆外内存分配失败");
            }
            NonNull::new_unchecked(ptr)
        };
        
        println!("分配 {} 字节堆外内存", size);
<think>我需要继续编写"自定义的内存分配策略"示例代码中未完成的部分。这部分代码包括堆外内存管理的实现、资源池与对象复用的实现，以及演示整个自定义内存分配策略的功能的函数。

我将从前面OffHeapMemory的实现继续写起，完成其余方法和Drop实现，然后继续实现资源池等功能，最后编写示例函数。</think># Rust 所有权系统的资源管理视角（续二十一）

继续上一部分的"自定义的内存分配策略"代码：

```rust
        println!("分配 {} 字节堆外内存", size);
        
        Ok(OffHeapMemory { ptr, size })
    }
    
    // 读取数据
    fn read(&self, offset: usize, dest: &mut [u8]) -> Result<usize, &'static str> {
        if offset >= self.size {
            return Err("偏移量超出范围");
        }
        
        let available = self.size - offset;
        let bytes_to_read = dest.len().min(available);
        
        unsafe {
            std::ptr::copy_nonoverlapping(
                self.ptr.as_ptr().add(offset),
                dest.as_mut_ptr(),
                bytes_to_read
            );
        }
        
        Ok(bytes_to_read)
    }
    
    // 写入数据
    fn write(&mut self, offset: usize, src: &[u8]) -> Result<usize, &'static str> {
        if offset >= self.size {
            return Err("偏移量超出范围");
        }
        
        let available = self.size - offset;
        let bytes_to_write = src.len().min(available);
        
        unsafe {
            std::ptr::copy_nonoverlapping(
                src.as_ptr(),
                self.ptr.as_ptr().add(offset),
                bytes_to_write
            );
        }
        
        Ok(bytes_to_write)
    }
    
    // 获取大小
    fn size(&self) -> usize {
        self.size
    }
}

// 释放堆外内存
impl Drop for OffHeapMemory {
    fn drop(&mut self) {
        let layout = Layout::from_size_align(self.size, 64)
            .expect("无效的内存布局");
            
        unsafe {
            dealloc(self.ptr.as_ptr(), layout);
        }
        
        println!("释放 {} 字节堆外内存", self.size);
    }
}

// 3. 资源池与对象复用

// 对象池中的对象接口
trait Poolable {
    fn reset(&mut self);
    fn is_valid(&self) -> bool;
}

// 类型擦除的池化对象
struct PoolObject {
    data: Box<dyn Poolable>,
    in_use: bool,
}

// 对象池
struct ObjectPool<T: Poolable + 'static> {
    objects: Vec<PoolObject>,
    factory: Box<dyn Fn() -> T>,
    size: usize,
}

impl<T: Poolable + 'static> ObjectPool<T> {
    // 创建新对象池
    fn new(size: usize, factory: impl Fn() -> T + 'static) -> Self {
        let mut objects = Vec::with_capacity(size);
        
        // 预创建对象
        for _ in 0..size {
            let obj = factory();
            objects.push(PoolObject {
                data: Box::new(obj),
                in_use: false,
            });
        }
        
        println!("创建容量为 {} 的对象池", size);
        
        ObjectPool {
            objects,
            factory: Box::new(factory),
            size,
        }
    }
    
    // 获取对象（带所有权）
    fn acquire(&mut self) -> PooledObject<T> {
        // 查找可用对象
        for (i, obj) in self.objects.iter_mut().enumerate() {
            if !obj.in_use {
                obj.in_use = true;
                obj.data.reset();
                
                // 创建池化对象句柄
                return PooledObject {
                    pool: self,
                    index: Some(i),
                    _marker: PhantomData,
                };
            }
        }
        
        // 所有对象都在使用中，创建新对象
        let new_obj = (self.factory)();
        let index = self.objects.len();
        
        self.objects.push(PoolObject {
            data: Box::new(new_obj),
            in_use: true,
        });
        
        println!("对象池扩展到 {}", self.objects.len());
        
        PooledObject {
            pool: self,
            index: Some(index),
            _marker: PhantomData,
        }
    }
    
    // 内部方法：释放对象
    fn release(&mut self, index: usize) {
        if index < self.objects.len() {
            self.objects[index].in_use = false;
        }
    }
    
    // 池大小
    fn size(&self) -> usize {
        self.size
    }
    
    // 活跃对象计数
    fn active_count(&self) -> usize {
        self.objects.iter().filter(|obj| obj.in_use).count()
    }
    
    // 总对象计数
    fn total_count(&self) -> usize {
        self.objects.len()
    }
}

// 池化对象句柄
struct PooledObject<'a, T: Poolable + 'static> {
    pool: &'a mut ObjectPool<T>,
    index: Option<usize>,
    _marker: PhantomData<T>,
}

impl<'a, T: Poolable + 'static> PooledObject<'a, T> {
    // 访问对象
    fn get(&self) -> &T {
        let index = self.index.expect("无效的池对象");
        self.pool.objects[index].data.downcast_ref::<T>().unwrap()
    }
    
    // 可变访问对象
    fn get_mut(&mut self) -> &mut T {
        let index = self.index.expect("无效的池对象");
        self.pool.objects[index].data.downcast_mut::<T>().unwrap()
    }
    
    // 手动归还对象
    fn release(mut self) {
        if let Some(index) = self.index.take() {
            self.pool.release(index);
        }
    }
}

// 自动归还池化对象
impl<'a, T: Poolable + 'static> Drop for PooledObject<'a, T> {
    fn drop(&mut self) {
        if let Some(index) = self.index {
            self.pool.release(index);
        }
    }
}

// 池化缓冲区示例
struct Buffer {
    data: Vec<u8>,
    used_size: usize,
    valid: bool,
}

impl Buffer {
    fn new(capacity: usize) -> Self {
        Buffer {
            data: vec![0; capacity],
            used_size: 0,
            valid: true,
        }
    }
    
    fn write(&mut self, bytes: &[u8]) -> Result<(), &'static str> {
        if !self.valid {
            return Err("缓冲区无效");
        }
        
        if self.used_size + bytes.len() > self.data.len() {
            return Err("缓冲区容量不足");
        }
        
        self.data[self.used_size..self.used_size + bytes.len()].copy_from_slice(bytes);
        self.used_size += bytes.len();
        
        Ok(())
    }
    
    fn read(&self) -> &[u8] {
        &self.data[0..self.used_size]
    }
    
    fn capacity(&self) -> usize {
        self.data.len()
    }
    
    fn used_size(&self) -> usize {
        self.used_size
    }
}

impl Poolable for Buffer {
    fn reset(&mut self) {
        self.used_size = 0;
        self.valid = true;
    }
    
    fn is_valid(&self) -> bool {
        self.valid
    }
}

// 定制容器类型
struct FixedSizeContainer<T> {
    allocator: CustomAllocator,
    memory: MemoryBlock,
    len: usize,
    capacity: usize,
    marker: PhantomData<T>,
}

impl<T> FixedSizeContainer<T> {
    fn new(allocator: CustomAllocator, capacity: usize) -> Result<Self, &'static str> {
        let item_size = mem::size_of::<T>();
        let align = mem::align_of::<T>();
        
        if item_size == 0 {
            return Err("不支持零大小类型");
        }
        
        let mut allocator = allocator;
        let size = item_size * capacity;
        let memory = allocator.allocate(size, align)?;
        
        Ok(FixedSizeContainer {
            allocator,
            memory,
            len: 0,
            capacity,
            marker: PhantomData,
        })
    }
    
    // 添加元素
    fn push(&mut self, item: T) -> Result<(), &'static str> {
        if self.len >= self.capacity {
            return Err("容器已满");
        }
        
        // 计算目标地址
        let item_size = mem::size_of::<T>();
        let offset = self.len * item_size;
        let dest = unsafe { self.memory.as_ptr().add(offset) as *mut T };
        
        // 写入元素
        unsafe {
            std::ptr::write(dest, item);
        }
        
        self.len += 1;
        
        Ok(())
    }
    
    // 获取元素
    fn get(&self, index: usize) -> Option<&T> {
        if index >= self.len {
            return None;
        }
        
        let item_size = mem::size_of::<T>();
        let offset = index * item_size;
        
        unsafe {
            let ptr = self.memory.as_ptr().add(offset) as *const T;
            Some(&*ptr)
        }
    }
    
    // 获取元素（可变）
    fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        if index >= self.len {
            return None;
        }
        
        let item_size = mem::size_of::<T>();
        let offset = index * item_size;
        
        unsafe {
            let ptr = self.memory.as_ptr().add(offset) as *mut T;
            Some(&mut *ptr)
        }
    }
    
    // 长度
    fn len(&self) -> usize {
        self.len
    }
    
    // 容量
    fn capacity(&self) -> usize {
        self.capacity
    }
    
    // 清空容器
    fn clear(&mut self) {
        // 调用所有元素的析构函数
        for i in 0..self.len {
            unsafe {
                let item_size = mem::size_of::<T>();
                let offset = i * item_size;
                let ptr = self.memory.as_ptr().add(offset) as *mut T;
                std::ptr::drop_in_place(ptr);
            }
        }
        
        self.len = 0;
    }
}

// 释放所有元素并归还内存
impl<T> Drop for FixedSizeContainer<T> {
    fn drop(&mut self) {
        self.clear();
        let size = self.memory.size();
        
        // memory会在自己的Drop中释放实际内存
        // 我们只需要更新分配器的统计信息
        self.allocator.deallocate(size);
    }
}

// 4. 自定义的内存分配策略示例
fn custom_allocation_example() {
    println!("\n=== 自定义分配器示例 ===");
    
    let mut allocator = CustomAllocator::new();
    
    // 分配一些内存块
    let memory1 = allocator.allocate(1024, 8).unwrap();
    let memory2 = allocator.allocate(2048, 16).unwrap();
    
    // 写入一些数据
    unsafe {
        std::ptr::write_bytes(memory1.as_ptr(), 0xAA, 1024);
        std::ptr::write_bytes(memory2.as_ptr(), 0xBB, 2048);
    }
    
    // 查看统计信息
    let (total, peak, count) = allocator.stats();
    println!("当前分配: {} 字节, 峰值: {} 字节, 分配次数: {}", total, peak, count);
    
    // 释放一个内存块
    let size = memory1.size();
    drop(memory1);
    allocator.deallocate(size);
    
    // 再次查看统计信息
    let (total, peak, count) = allocator.stats();
    println!("当前分配: {} 字节, 峰值: {} 字节, 分配次数: {}", total, peak, count);
    
    // 释放另一个内存块
    let size = memory2.size();
    drop(memory2);
    allocator.deallocate(size);
    
    println!("\n=== 堆外内存管理示例 ===");
    
    // 创建堆外内存
    let mut offheap = OffHeapMemory::new(4096).unwrap();
    
    // 写入数据
    let data = b"Hello, Off-heap Memory!";
    offheap.write(0, data).unwrap();
    
    // 读取数据
    let mut buffer = [0u8; 32];
    let bytes_read = offheap.read(0, &mut buffer).unwrap();
    
    println!("从堆外内存读取: {}", String::from_utf8_lossy(&buffer[..bytes_read]));
    
    // 写入更多数据
    let data2 = b"More data at offset 1000";
    offheap.write(1000, data2).unwrap();
    
    // 读取更多数据
    let bytes_read = offheap.read(1000, &mut buffer).unwrap();
    println!("从偏移量1000读取: {}", String::from_utf8_lossy(&buffer[..bytes_read]));
    
    // 释放堆外内存
    drop(offheap);
    
    println!("\n=== 对象池示例 ===");
    
    // 创建缓冲区池
    let mut buffer_pool = ObjectPool::new(5, || Buffer::new(1024));
    
    // 获取一些缓冲区
    let mut buffers = Vec::new();
    for i in 1..=8 {
        let mut buffer = buffer_pool.acquire();
        buffer.get_mut().write(format!("Buffer {}", i).as_bytes()).unwrap();
        
        println!("获取缓冲区 {}: 使用 {} 字节，池大小 {}/{}", 
            i, buffer.get().used_size(), buffer_pool.active_count(), buffer_pool.total_count());
            
        buffers.push(buffer);
    }
    
    // 池状态
    println!("池状态: {}/{} 活跃/总计", buffer_pool.active_count(), buffer_pool.total_count());
    
    // 释放一些缓冲区
    for i in 0..4 {
        let buffer = buffers.remove(0);
        let used = buffer.get().used_size();
        println!("释放缓冲区: {} 字节", used);
        buffer.release();
    }
    
    // 池状态
    println!("释放后池状态: {}/{} 活跃/总计", buffer_pool.active_count(), buffer_pool.total_count());
    
    // 获取更多缓冲区
    for i in 9..=10 {
        let mut buffer = buffer_pool.acquire();
        buffer.get_mut().write(format!("Buffer {}", i).as_bytes()).unwrap();
        
        println!("获取缓冲区 {}: 使用 {} 字节，池大小 {}/{}", 
            i, buffer.get().used_size(), buffer_pool.active_count(), buffer_pool.total_count());
            
        buffers.push(buffer);
    }
    
    // 清理所有缓冲区
    buffers.clear();
    
    println!("最终池状态: {}/{} 活跃/总计", buffer_pool.active_count(), buffer_pool.total_count());
    
    println!("\n=== 自定义容器示例 ===");
    
    // 创建定制容器
    let mut container = FixedSizeContainer::<u32>::new(CustomAllocator::new(), 10).unwrap();
    
    // 添加元素
    for i in 0..8 {
        container.push(i * 100).unwrap();
    }
    
    // 读取元素
    println!("容器长度: {}/{}", container.len(), container.capacity());
    for i in 0..container.len() {
        if let Some(value) = container.get(i) {
            println!("元素 {}: {}", i, value);
        }
    }
    
    // 修改元素
    if let Some(value) = container.get_mut(3) {
        *value = 999;
        println!("修改元素3为: {}", value);
    }
    
    // 读取修改后的元素
    if let Some(value) = container.get(3) {
        println!("元素3: {}", value);
    }
    
    // 清空容器
    container.clear();
    println!("清空后长度: {}/{}", container.len(), container.capacity());
    
    // 释放容器
    drop(container);
}
```

## 所有权与未来趋势

### 类型系统发展与所有权

所有权在类型系统发展中的趋势：

1. **依赖类型与所有权**
   - 依赖类型表达所有权约束
   - 更精确的资源生命周期验证

2. **线性类型与所有权**
   - 线性逻辑与所有权模型的统一
   - 资源精确使用的表达能力

3. **类型状态与所有权结合**
   - 状态类型与所有权的协同
   - 状态转换安全性的保证

```rust
// 类型系统发展与所有权示例

// 1. 依赖类型与所有权（模拟）

// 大小依赖类型
struct SizedVector<const N: usize> {
    data: Vec<i32>,
    _marker: std::marker::PhantomData<[(); N]>,
}

impl<const N: usize> SizedVector<N> {
    // 创建指定大小的向量
    fn new() -> Self {
        SizedVector {
            data: Vec::with_capacity(N),
            _marker: std::marker::PhantomData,
        }
    }
    
    // 添加元素，保证大小约束
    fn push(&mut self, value: i32) -> Result<(), &'static str> {
        if self.data.len() >= N {
            return Err("向量已达到最大容量");
        }
        
        self.data.push(value);
        Ok(())
    }
    
    // 获取元素
    fn get(&self, index: usize) -> Option<&i32> {
        self.data.get(index)
    }
    
    // 当前长度
    fn len(&self) -> usize {
        self.data.len()
    }
    
    // 大小限制（类型级常量）
    fn capacity() -> usize {
        N
    }
}

// 资源状态依赖类型（模拟）
enum ResourceState {
    Open,
    Closed,
}

// 状态标记类型
struct StateOpen;
struct StateClosed;

// 资源类型
struct Resource<State> {
    name: String,
    data: Vec<u8>,
    _state: std::marker::PhantomData<State>,
}

impl Resource<StateClosed> {
    // 创建新的关闭状态资源
    fn new(name: &str) -> Self {
        println!("创建资源 {} (已关闭状态)", name);
        
        Resource {
            name: name.to_string(),
            data: Vec::new(),
            _state: std::marker::PhantomData,
        }
    }
    
    // 打开资源 - 改变类型状态
    fn open(self) -> Resource<StateOpen> {
        println!("打开资源 {}", self.name);
        
        Resource {
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
}

impl Resource<StateOpen> {
    // 写入数据（只在打开状态可用）
    fn write(&mut self, data: &[u8]) {
        println!("写入 {} 字节到资源 {}", data.len(), self.name);
        
        self.data.clear();
        self.data.extend_from_slice(data);
    }
    
    // 读取数据（只在打开状态可用）
    fn read(&self) -> &[u8] {
        &self.data
    }
    
    // 关闭资源 - 改变类型状态
    fn close(self) -> Resource<StateClosed> {
        println!("关闭资源 {}", self.name);
        
        Resource {
            name: self.name,
            data: self.data,
            _state: std::marker::PhantomData,
        }
    }
}

// 2. 线性类型与所有权（模拟）

// 线性资源（只能使用一次）
struct LinearResource {
    id: u32,
    consumed: bool,
}

impl LinearResource {
    fn new(id: u32) -> Self {
        println!("创建线性资源 {}", id);
        
        LinearResource {
            id,
            consumed: false,
        }
    }
    
    // 消费资源（只能调用一次）
    fn consume(mut self) -> Result<u32, &'static str> {
        if self.consumed {
            return Err("资源已被消费");
        }
        
        self.consumed = true;
        println!("消费线性资源 {}", self.id);
        
        Ok(self.id)
    }
}

// 线性函数（确保参数被精确使用一次）
fn use_resource(resource: LinearResource) -> u32 {
    let id = resource.consume().expect("资源无效");
    id * 2
}

// 3. 类型状态与所有权结合

// 连接类型状态
trait ConnectionState {}
struct Disconnected;
struct Connected;
struct Authenticated;

impl ConnectionState for Disconnected {}
impl ConnectionState for Connected {}
impl ConnectionState for Authenticated {}

// 类型状态连接
struct Connection<S: ConnectionState> {
    address: String,
    session_id: Option<String>,
    _state: std::marker::PhantomData<S>,
}

impl Connection<Disconnected> {
    // 创建新连接
    fn new(address: &str) -> Self {
        println!("创建到 {} 的连接", address);
        
        Connection {
            address: address.to_string(),
            session_id: None,
            _state: std::marker::PhantomData,
        }
    }
    
    // 连接 - 改变状态
    fn connect(self) -> Result<Connection<Connected>, &'static str> {
        println!("连接到 {}", self.address);
        
        // 模拟连接逻辑
        
        Ok(Connection {
            address: self.address,
            session_id: None,
            _state: std::marker::PhantomData,
        })
    }
}

impl Connection<Connected> {
    // 验证 - 改变状态
    fn authenticate(self, username: &str, password: &str) -> Result<Connection<Authenticated>, &'static str> {
        println!("验证用户 {} 连接到 {}", username, self.address);
        
        // 模拟验证逻辑
        let session_id = format!("session-{}-{}", username, std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
        
        Ok(Connection {
            address: self.address,
            session_id: Some(session_id),
            _state: std::marker::PhantomData,
        })
    }
    
    // 断开连接 - 改变状态
    fn disconnect(self) -> Connection<Disconnected> {
        println!("断开与 {} 的连接", self.address);
        
        Connection {
            address: self.address,
            session_id: None,
            _state: std::marker::PhantomData,
        }
    }
}

impl Connection<Authenticated> {
    // 发送数据（需要验证状态）
    fn send_data(&self, data: &[u8]) -> Result<(), &'static str> {
        let session = self.session_id.as_ref().expect("无会话ID");
        println!("使用会话 {} 发送 {} 字节到 {}", session, data.len(), self.address);
        
        // 模拟发送逻辑
        
        Ok(())
    }
    
    // 接收数据（需要验证状态）
    fn receive_data(&self) -> Result<Vec<u8>, &'static str> {
        let session = self.session_id.as_ref().expect("无会话ID");
        
        // 模拟接收逻辑
        let data = b"received data".to_vec();
        
        println!("使用会话 {} 从 {} 接收 {} 字节", session, self.address, data.len());
        
        Ok(data)
    }
    
    // 注销 - 改变状态回到已连接
    fn logout(self) -> Connection<Connected> {
        println!("注销会话 {}", self.session_id.unwrap_or_default());
        
        Connection {
            address: self.address,
            session_id: None,
            _state: std::marker::PhantomData,
        }
    }
    
    // 断开连接 - 改变状态
    fn disconnect(self) -> Connection<Disconnected> {
        println!("断开已验证的连接 {}", self.address);
        
        Connection {
            address: self.address,
            session_id: None,
            _state: std::marker::PhantomData,
        }
    }
}

// 4. 类型系统与所有权示例
fn type_system_ownership_example() {
    println!("\n=== 依赖类型与所有权示例 ===");
    
    // 创建固定大小向量
    let mut vec5 = SizedVector::<5>::new();
    
    // 添加元素
    for i in 1..=5 {
        vec5.push(i * 10).unwrap();
    }
    
    // 尝试添加超出容量的元素
    match vec5.push(60) {
        Ok(_) => println!("意外: 添加了超出容量的元素"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 读取元素
    println!("向量大小: {}/{}", vec5.len(), SizedVector::<5>::capacity());
    for i in 0..vec5.len() {
        if let Some(value) = vec5.get(i) {
            println!("元素 {}: {}", i, value);
        }
    }
    
    // 状态依赖类型
    let resource = Resource::new("config.txt");
    
    // 无法在关闭状态下读写
    // resource.write(b"data"); // 编译错误
    
    // 打开资源
    let mut open_resource = resource.open();
    
    // 在打开状态下可以读写
    open_resource.write(b"configuration data");
    println!("读取资源: {}", String::from_utf8_lossy(open_resource.read()));
    
    // 关闭资源
    let closed_resource = open_resource.close();
    
    // 再次打开
    let _reopened = closed_resource.open();
    
    println!("\n=== 线性类型与所有权示例 ===");
    
    // 创建线性资源
    let resource1 = LinearResource::new(1001);
    let resource2 = LinearResource::new(1002);
    
    // 消费资源
    let result = use_resource(resource1);
    println!("资源使用结果: {}", result);
    
    // 直接消费
    match resource2.consume() {
        Ok(id) => println!("资源ID: {}", id),
        Err(e) => println!("错误: {}", e),
    }
    
    // 尝试再次消费（在真实的线性类型系统中会导致编译错误）
    // let invalid = use_resource(resource1); // 编译错误: 资源已移动
    
    println!("\n=== 类型状态与所有权结合示例 ===");
    
    // 创建连接
    let conn = Connection::<Disconnected>::new("server.example.com");
    
    // 建立连接
    let connected = match conn.connect() {
        Ok(conn) => conn,
        Err(e) => {
            println!("连接失败: {}", e);
            return;
        }
    };
    
    // 尝试发送数据（不允许，编译错误）
    // connected.send_data(b"test"); // 编译错误: 方法不存在
    
    // 验证连接
    let authenticated = match connected.authenticate("admin", "password") {
        Ok(conn) => conn,
        Err(e) => {
            println!("验证失败: {}", e);
            return;
        }
    };
    
    // 发送和接收数据
    authenticated.send_data(b"secure data").unwrap();
    let response = authenticated.receive_data().unwrap();
    println!("收到响应: {}", String::from_utf8_lossy(&response));
    
    // 注销
    let connected = authenticated.logout();
    
    // 断开连接
    let disconnected = connected.disconnect();
    
    // 重新连接
    let _reconnected = match disconnected.connect() {
        Ok(conn) => conn,
        Err(e) => {
            println!("重新连接失败: {}", e);
            return;
        }
    };
}
```

### 并发与所有权协同

所有权在并发中的应用与发展：

1. **所有权驱动的Actor模型**
   - 基于所有权的消息传递机制
   - Actor之间资源转移的安全保证

2. **反应式编程与所有权**
   - 流式处理的所有权语义
   - 事件源与订阅的所有权模式

3. **所有权与并发版本控制**
   - 使用所有权实现乐观并发控制
   - 冲突检测与解决的所有权机制

```rust
// 并发与所有权协同示例

use std::sync::{Arc, Mutex, RwLock};
use std::sync::mpsc::{self, Sender, Receiver};
use std::thread;
use std::time::Duration;
use std::collections::HashMap;

// 1. 所有权驱动的Actor模型

// 消息类型
enum ActorMessage {
    Text(String),
    Binary(Vec<u8>),
    Number(i32),
    Shutdown,
}

// Actor 特征
trait Actor: Send {
    fn handle_message(&mut self, msg: ActorMessage);
    fn name(&self) -> &str;
}

// 日志Actor
struct LogActor {
    name: String,
    log_count: usize,
}

impl LogActor {
    fn new(name: &str) -> Self {
        LogActor {
            name: name.to_string(),
            log_count: 0,
        }
    }
}

impl Actor for LogActor {
    fn handle_message(&mut self, msg: ActorMessage) {
        self.log_count += 1;
        
        match msg {
            ActorMessage::Text(text) => {
                println!("[{}:{}] 文本消息: {}", self.name, self.log_count, text);
            },
            ActorMessage::Binary(data) => {
                println!("[{}:{}] 二进制消息: {} 字节", self.name, self.log_count, data.len());
            },
            ActorMessage::Number(num) => {
                println!("[{}:{}] 数字消息: {}", self.name, self.log_count, num);
            },
            ActorMessage::Shutdown => {
                println!("[{}:{}] 收到关闭消息，总处理消息数: {}", 
                    self.name, self.log_count, self.log_count);
            },
        }
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

// 处理Actor
struct ProcessActor {
    name: String,
    next: Option<Sender<ActorMessage>>,
    processed_count: usize,
}

impl ProcessActor {
    fn new(name: &str) -> Self {
        ProcessActor {
            name: name.to_string(),
            next: None,
            processed_count: 0,
        }
    }
    
    fn set_next(&mut self, next: Sender<ActorMessage>) {
        self.next = Some(next);
    }
}

impl Actor for ProcessActor {
    fn handle_message(&mut self, msg: ActorMessage) {
        self.processed_count += 1;
        
        // 处理消息
        let transformed = match msg {
            ActorMessage::Text(text) => {
                println!("[{}] 处理文本: {}", self.name, text);
                ActorMessage::Text(text.to_uppercase())
            },
            ActorMessage::Binary(data) => {
                println!("[{}] 处理二进制: {} 字节", self.name, data.len());
                // 简单转换：每个字节加1
                let transformed = data.iter().map(|b| b.wrapping_add(1)).collect();
                ActorMessage::Binary(transformed)
            },
            ActorMessage::Number(num) => {
                println!("[{}] 处理数字: {}", self.name, num);
                ActorMessage::Number(num * 2)
            },
            ActorMessage::Shutdown => {
                println!("[{}] 关闭处理中, 已处理消息数: {}", self.name, self.processed_count);
                // 转发关闭消息
                if let Some(next) = &self.next {
                    let _ = next.send(ActorMessage::Shutdown);
                }
                return;
            },
        };
        
        // 将转换后的消息发送到下一个Actor
        if let Some(next) = &self.next {
            let _ = next.send(transformed);
        }
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

// Actor管理器
struct ActorSystem {
    actors: HashMap<String, Sender<ActorMessage>>,
}

impl ActorSystem {
    fn new() -> Self {
        ActorSystem {
            actors: HashMap::new(),
        }
    }
    
    // 启动新Actor
    fn spawn<A: Actor + 'static>(&mut self, mut actor: A) -> Sender<ActorMessage> {
        let (tx, rx) = mpsc::channel();
        let name = actor.name().to_string();
        
        println!("启动Actor: {}", name);
        
        thread::spawn(move || {
            Self::actor_loop(&mut actor, rx);
        });
        
        self.actors.insert(name, tx.clone());
        tx
    }
    
    // Actor消息循环
    fn actor_loop<A: Actor>(actor: &mut A, rx: Receiver<ActorMessage>) {
        while let Ok(msg) = rx.recv() {
            match msg {
                ActorMessage::Shutdown => {
                    actor.handle_message(msg);
                    break;
                },
                _ => actor.handle_message(msg),
            }
        }
        
        println!("Actor {} 已停止", actor.name());
    }
    
    // 向指定Actor发送消息
    fn send(&self, actor_name: &str, msg: ActorMessage) -> Result<(), &'static str> {
        if let Some(tx) = self.actors.get(actor_name) {
            tx.send(msg).map_err(|_| "发送消息失败")?;
            Ok(())
        } else {
            Err("Actor不存在")
        }
    }
    
    // 关闭所有Actor
    fn shutdown(&self) {
        println!("关闭所有Actor");
        
        for (name, tx) in &self.actors {
            println!("发送关闭消息到 {}", name);
            let _ = tx.send(ActorMessage::Shutdown);
        }
    }
}

// 2. 反应式编程与所有权

// 流数据类型
enum StreamItem<T> {
    Next(T),
    Error(String),
    Complete,
}

// 订阅者特征
trait Subscriber<T: Clone>: Send {
    fn on_next(&mut self, item: T);
    fn on_error(&mut self, error: String);
    fn on_complete(&mut self);
}

// 发布者
struct Publisher<T: Clone + Send + 'static> {
    subscribers: Vec<Arc<Mutex<dyn Subscriber<T> + 'static>>>,
    name: String,
}

impl<T: Clone + Send + 'static> Publisher<T> {
    fn new(name: &str) -> Self {
        Publisher {
            subscribers: Vec::new(),
            name: name.to_string(),
        }
    }
    
    // 添加订阅者
    fn subscribe(&mut self, subscriber: Arc<Mutex<dyn Subscriber<T>>>) {
        println!("发布者 {} 添加新订阅者", self.name);
        self.subscribers.push(subscriber);
    }
    
    // 发布下一个数据项
    fn publish(&self, item: T) {
        println!("发布者 {} 发布新数据", self.name);
        
        for subscriber in &self.subscribers {
            let mut sub = subscriber.lock().unwrap();
            sub.on_next(item.clone());
        }
    }
    
    // 发布错误
    fn publish_error(&self, error: &str) {
        println!("发布者 {} 发布错误: {}", self.name, error);
        
        for subscriber in &self.subscribers {
            let mut sub = subscriber.lock().unwrap();
            sub.on_error(error.to_string());
        }
    }
    
    // 发布完成信号
    fn complete(&self) {
        println!("发布者 {} 发布完成信号", self.name);
        
        for subscriber in &self.subscribers {
            let mut sub = subscriber.lock().unwrap();
            sub.on_complete();
        }
    }
    
    // 在新线程上运行发布者
    fn run_in_thread(publisher: Arc<Mutex<Self>>, items: Vec<T>) {
        thread::spawn(move || {
            thread::sleep(Duration::from_millis(100));
            
            for item in items {
                {
                    let publisher = publisher.lock().unwrap();
                    publisher.publish(item);
                }
                thread::sleep(Duration::from_millis(200));
            }
            
            {
                let publisher = publisher.lock().unwrap();
                publisher.complete();
            }
        });
    }
}

// 简单订阅者
struct SimpleSubscriber<T: Clone> {
    name: String,
    received: Vec<T>,
    completed: bool,
}

impl<T: Clone> SimpleSubscriber<T> {
    fn new(name: &str) -> Self {
        SimpleSubscriber {
            name: name.to_string(),
            received: Vec::new(),
            completed: false,
        }
    }
    
    fn items_received(&self) -> usize {
        self.received.len()
    }
    
    fn is_completed(&self) -> bool {
        self.completed
    }
}

impl<T: Clone + std::fmt::Debug> Subscriber<T> for SimpleSubscriber<T> {
    fn on_next(&mut self, item: T) {
        println!("订阅者 {} 收到: {:?}", self.name, item);
        self.received.push(item);
    }
    
    fn on_error(&mut self, error: String) {
        println!("订阅者 {} 收到错误: {}", self.name, error);
    }
    
    fn on_complete(&mut self) {
        println!("订阅者 {} 收到完成信号", self.name);
        self.completed = true;
    }
}

// 转换订阅者（添加转换函数）
struct TransformSubscriber<T: Clone, U: Clone> {
    name: String,
    transform: Box<dyn Fn(T) -> U + Send>,
    next_subscriber: Arc<Mutex<dyn Subscriber<U>>>,
}

impl<T: Clone + Send + 'static, U: Clone + Send + 'static> TransformSubscriber<T, U> {
    fn new(name: &str, transform: Box<dyn Fn(T) -> U + Send>, next: Arc<Mutex<dyn Subscriber<U>>>) -> Self {
        TransformSubscriber {
            name: name.to_string(),
            transform,
            next_subscriber: next,
        }
    }
}

impl<T: Clone + Send + 'static, U: Clone + Send + 'static> Subscriber<T> for TransformSubscriber<T, U> {
    fn on_next(&mut self, item: T) {
        println!("转换订阅者 {} 处理数据", self.name);
        let transformed = (self.transform)(item);
        
        let mut next = self.next_subscriber.lock().unwrap();
        next.on_next(transformed);
    }
    
    fn on_error(&mut self, error: String) {
        println!("转换订阅者 {} 转发错误", self.name);
        let mut next = self.next_subscriber.lock().unwrap();
        next.on_error(error);
    }
    
    fn on_complete(&mut self) {
        println!("转换订阅者 {} 转发完成信号", self.name);
        let mut next = self.next_subscriber.lock().unwrap();
        next.on_complete();
    }
}

// 3. 所有权与并发版本控制

// 并发版本控制的数据项
struct VersionedItem<T> {
    data: T,
    version: u64,
}

impl<T: Clone> VersionedItem<T> {
    fn new(data: T, version: u64) -> Self {
        VersionedItem { data, version }
    }
    
    fn data(&self) -> &T {
        &self.data
    }
    
    fn version(&self) -> u64 {
        self.version
    }
    
    fn update(&self, new_data: T) -> VersionedItem<T> {
        VersionedItem {
            data: new_data,
            version: self.version + 1,
        }
    }
}

// 乐观锁版本控制的存储
struct OptimisticStore<K, V> 
    where K: Eq + std::hash::Hash + Clone, 
          V: Clone
{
    data: Arc<RwLock<HashMap<K, VersionedItem<V>>>>,
}

impl<K, V> OptimisticStore<K, V> 
    where K: Eq + std::hash::Hash + Clone + Send + Sync + 'static, 
          V: Clone + Send + Sync + 'static
{
    fn new() -> Self {
        OptimisticStore {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    // 获取数据（读锁）
    fn get(&self, key: &K) -> Option<VersionedItem<V>> {
        let data = self.data.read().unwrap();
        data.get(key).cloned()
    }
    
    // 添加新数据（写锁）
    fn insert(&self, key: K, value: V) -> Result<(), &'static str> {
        let mut data = self.data.write().unwrap();
        
        if data.contains_key(&key) {
            return Err("键已存在");
        }
        
        data.insert(key, VersionedItem::new(value, 1));
        Ok(())
    }
    
    // 乐观更新（检查版本，仅当版本匹配时更新）
    fn update(&self, key: K, new_value: V, expected_version: u64) -> Result<(), &'static str> {
        let mut data = self.data.write().unwrap();
        
        match data.get(&key) {
            Some(current) => {
                if current.version() != expected_version {
                    return Err("版本冲突，数据已被修改");
                }
                
                let updated = current.update(new_value);
                data.insert(key, updated);
                Ok(())
            },
            None => Err("键不存在"),
        }
    }
    
    // 运行多个并发更新（测试冲突检测）
    fn run_concurrent_updates(&self, key: K, values: Vec<V>, threads: usize) -> usize {
        let data = Arc::clone(&self.data);
        let values_per_thread = (values.len() + threads - 1) / threads;
        let values = Arc::new(values);
        
        let mut handles = Vec::new();
        let success_counter = Arc::new(Mutex::new(0usize));
        
        for t in 0..threads {
            let data = Arc::clone(&data);
            let values = Arc::clone(&values);
            let key = key.clone();
            let counter = Arc::clone(&success_counter);
            
            let handle = thread::spawn(move || {
                let start = t * values_per_thread;
                let end = std::cmp::min((t + 1) * values_per_thread, values.len());
                
                for i in start..end {
                    let value = values[i].clone();
                    
                    // 尝试乐观更新
                    let mut success = false;
                    for _ in 0..3 { // 重试3次
                        // 获取当前版本
                        let current_version = match data.read().unwrap().get(&key) {
                            Some(item) => item.version(),
                            None => break,
                        };
                        
                        // 尝试更新
                        let result = {
                            let mut data = data.write().unwrap();
                            match data.get(&key) {
                                Some(current) => {
                                    if current.version() != current_version {
                                        continue; // 版本已变，重试
                                    }
                                    
                                    let updated = current.update(value.clone());
                                    data.insert(key.clone(), updated);
                                    true
                                },
                                None => false,
                            }
                        };
                        
                        if result {
                            success = true;
                            break;
                        }
                        
                        // 失败后短暂等待再重试
                        thread::sleep(Duration::from_millis(5));
                    }
                    
                    if success {
                        let mut counter = counter.lock().unwrap();
                        *counter += 1;
                    }
                }
            });
            
            handles.push(handle);
        }
        
        // 等待所有线程完成
        for handle in handles {
            handle.join().unwrap();
        }
        
        *success_counter.lock().unwrap()
    }
}

// 4. 并发与所有权示例
fn concurrency_ownership_example() {
    println!("\n=== 所有权驱动的Actor模型示例 ===");
    
    // 创建Actor系统
    let mut system = ActorSystem::new();
    
    // 创建日志Actor
    let log_actor = LogActor::new("Logger");
    let log_sender = system.spawn(log_actor);
    
    // 创建处理Actor
    let mut process_actor = ProcessActor::new("Processor");
    process_actor.set_next(log_sender);
    let process_sender = system.spawn(process_actor);
    
    // 发送消息
    process_sender.send(ActorMessage::Text("hello actor".to_string())).unwrap();
    process_sender.send(ActorMessage::Binary(vec![1, 2, 3, 4])).unwrap();
    process_sender.send(ActorMessage::Number(42)).unwrap();
    
    // 等待处理完成
    thread::sleep(Duration::from_millis(100));
    
    // 关闭系统
    system.send("Processor", ActorMessage::Shutdown).unwrap();
    
    // 等待关闭完成
    thread::sleep(Duration::from_millis(100));
    
    println!("\n=== 反应式编程与所有权示例 ===");
    
    // 创建订阅者
    let subscriber1 = Arc::new(Mutex::new(SimpleSubscriber::<i32>::new("Subscriber1")));
    let subscriber2 = Arc::new(Mutex::new(SimpleSubscriber::<i32>::new("Subscriber2")));
    
    // 创建转换订阅者（将数字乘以2）
    let transform_subscriber = Arc::new(Mutex::new(TransformSubscriber::new(
        "Doubler",
        Box::new(|x: i32| x * 2),
        Arc::clone(&subscriber2) as Arc<Mutex<dyn Subscriber<i32>>>
    )));
    
    // 创建发布者
    let publisher = Arc::new(Mutex::new(Publisher::<i32>::new("NumberPublisher")));
    
    // 订阅
    {
        let mut pub_lock = publisher.lock().unwrap();
        pub_lock.subscribe(Arc::clone(&subscriber1) as Arc<Mutex<dyn Subscriber<i32>>>);
        pub_lock.subscribe(Arc::clone(&transform_subscriber) as Arc<Mutex<dyn Subscriber<i32>>>);
    }
    
    // 发布一些数据
    Publisher::run_in_thread(Arc::clone(&publisher), vec![1, 2, 3, 4, 5]);
    
    // 等待完成
    thread::sleep(Duration::from_secs(2));
    
    // 检查结果
    {
        let sub1 = subscriber1.lock().unwrap();
        let sub2 = subscriber2.lock().unwrap();
        
        println!("订阅者1接收到 {} 个项目，完成状态: {}", 
            sub1.items_received(), sub1.is_completed());
        println!("订阅者2（转换后）接收到 {} 个项目，完成状态: {}", 
            sub2.items_received(), sub2.is_completed());
    }
    
    println!("\n=== 所有权与并发版本控制示例 ===");
    
    // 创建乐观锁存储
    let store = OptimisticStore::<String, String>::new();
    
    // 插入初始数据
    store.insert("key1".to_string(), "initial value".to_string()).unwrap();
    
    // 读取数据
    match store.get(&"key1".to_string()) {
        Some(item) => println!("初始值: {} (版本 {})", item.data(), item.version()),
        None => println!("未找到键"),
    }
    
    // 单线程更新
    match store.update("key1".to_string(), "updated value".to_string(), 1) {
        Ok(_) => println!("成功更新值"),
        Err(e) => println!("更新失败: {}", e),
    }
    
    // 读取更新后的数据
    match store.get(&"key1".to_string()) {
        Some(item) => println!("更新后值: {} (版本 {})", item.data(), item.version()),
        None => println!("未找到键"),
    }
    
    // 错误版本更新（应该失败）
    match store.update("key1".to_string(), "wrong version update".to_string(), 1) {
        Ok(_) => println!("意外: 错误版本更新成功"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 并发更新测试
    println!("\n运行并发更新测试...");
    
    // 创建新键
    store.insert("concurrent".to_string(), "start".to_string()).unwrap();
    
    // 准备100个更新值
    let values: Vec<String> = (1..101).map(|i| format!("value-{}", i)).collect();
    
    // 在5个线程上运行并发更新
    let success_count = store.run_concurrent_updates("concurrent".to_string(), values, 5);
    
    // 读取最终值
    match store.get(&"concurrent".to_string()) {
        Some(item) => println!("并发更新后: {} (版本 {}, 成功更新: {}/100)", 
            item.data(), item.version(), success_count),
        None => println!("未找到键"),
    }
}
```

### 所有权与安全通信

所有权保证的安全通信机制：

1. **所有权型通信通道**
   - 使用所有权转移实现单生产者单消费者模式
   - 高效的无拷贝通信

2. **状态机驱动的协议**
   - 通过所有权保证协议状态转换
   - 编译时协议违规检查

3. **零信任通信模型**
   - 基于所有权的资源访问验证
   - 动态权限校验与所有权协同

```rust
// 所有权与安全通信示例

use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;

// 1. 所有权型通信通道

// 所有权转移型通道
struct OwnershipChannel<T> {
    queue: Mutex<VecDeque<T>>,
    not_empty: Condvar,
    not_full: Condvar,
    capacity: usize,
    closed: Mutex<bool>,
}

impl<T> OwnershipChannel<T> {
    fn new(capacity: usize) -> Self {
        OwnershipChannel {
            queue: Mutex::new(VecDeque::with_capacity(capacity)),
            not_empty: Condvar::new(),
            not_full: Condvar::new(),
            capacity,
            closed: Mutex::new(false),
        }
    }
    
    // 发送值（转移所有权）
    fn send(&self, value: T) -> Result<(), &'static str> {
        let mut queue = self.queue.lock().unwrap();
        let closed = self.closed.lock().unwrap();
        
        if *closed {
            return Err("通道已关闭");
        }
        
        // 当队列满时等待
        while queue.len() >= self.capacity {
            drop(closed);
            queue = self.not_full.wait(queue).unwrap();
            let closed = self.closed.lock().unwrap();
            if *closed {
                return Err("等待发送时通道关闭");
            }
        }
        
        // 添加值
        queue.push_back(value);
        
        // 通知等待接收的线程
        self.not_empty.notify_one();
        
        Ok(())
    }
    
    // 接收值（获取所有权）
    fn recv(&self) -> Result<T, &'static str> {
        let mut queue = self.queue.lock().unwrap();
        
        // 当队列空时等待
        while queue.is_empty() {
            let closed = self.closed.lock().unwrap();
            if *closed {
                return Err("通道已关闭且为空");
            }
            drop(closed);
            
            queue = self.not_empty.wait(queue).unwrap();
            
            let closed = self.closed.lock().unwrap();
            if *closed && queue.is_empty() {
                return Err("等待接收时通道关闭且为空");
            }
        }
        
        // 获取值
        let value = queue.pop_front().ok_or("队列为空")?;
        
        // 通知等待发送的线程
        self.not_full.notify_one();
        
        Ok(value)
    }
    
    // 关闭通道
    fn close(&self) {
        let mut closed = self.closed.lock().unwrap();
        *closed = true;
        
        // 通知所有等待线程
        self.not_empty.notify_all();
        self.not_full.notify_all();
    }
    
    // 创建通道并返回发送者和接收者
    fn create(capacity: usize) -> (Sender<T>, Receiver<T>) {
        let channel = Arc::new(OwnershipChannel::new(capacity));
        
        (
            Sender { channel: Arc::clone(&channel) },
            Receiver { channel }
        )
    }
}

// 发送端
struct Sender<T> {
    channel: Arc<OwnershipChannel<T>>,
}

impl<T> Sender<T> {
    fn send(&self, value: T) -> Result<(), &'static str> {
        self.channel.send(value)
    }
    
    fn close(&self) {
        self.channel.close();
    }
}

impl<T> Clone for Sender<T> {
    fn clone(&self) -> Self {
        Sender {
            channel: Arc::clone(&self.channel),
        }
    }
}

// 接收端
struct Receiver<T> {
    channel: Arc<OwnershipChannel<T>>,
}

impl<T> Receiver<T> {
    fn recv(&self) -> Result<T, &'static str> {
        self.channel.recv()
    }
    
    fn close(&self) {
        self.channel.close();
    }
}

// 2. 状态机驱动的协议

// 协议状态标记类型
trait ProtocolState {}

// 协议状态
struct Initial;
struct Handshake;
struct Established;
struct Closing;
struct Closed;

impl ProtocolState for Initial {}
impl ProtocolState for Handshake {}
impl ProtocolState for Established {}
impl ProtocolState for Closing {}
impl ProtocolState for Closed {}

// 协议消息
enum ProtocolMessage {
    Connect { client_id: String },
    Accept { session_id: String },
    Data { content: Vec<u8> },
    Close { reason: String },
    Acknowledge,
}

// 类型安全的协议
struct Protocol<S: ProtocolState> {
    client_id: String,
    session_id: Option<String>,
    _state: std::marker::PhantomData<S>,
}

// 初始状态实现
impl Protocol<Initial> {
    // 创建新协议
    fn new(client_id: &str) -> Self {
        Protocol {
            client_id: client_id.to_string(),
            session_id: None,
            _state: std::marker::PhantomData,
        }
    }
    
    // 发起连接请求（状态转移到Handshake）
    fn connect(self) -> (Protocol<Handshake>, ProtocolMessage) {
        let connect_msg = ProtocolMessage::Connect {
            client_id: self.client_id.clone(),
        };
        
        let next_state = Protocol {
            client_id: self.client_id,
            session_id: None,
            _state: std::marker::PhantomData,
        };
        
        (next_state, connect_msg)
    }
}

// 握手状态实现
impl Protocol<Handshake> {
    // 处理Accept消息（状态转移到Established）
    fn handle_accept(self, msg: ProtocolMessage) -> Result<Protocol<Established>, &'static str> {
        match msg {
            ProtocolMessage::Accept { session_id } => {
                println!("接受会话: {}", session_id);
                
                Ok(Protocol {
                    client_id: self.client_id,
                    session_id: Some(session_id),
                    _state: std::marker::PhantomData,
                })
            },
            _ => Err("协议错误: 预期Accept消息"),
        }
    }
    
    // 关闭连接（状态转移到Closed）
    fn abort(self) -> (Protocol<Closed>, ProtocolMessage) {
        let close_msg = ProtocolMessage::Close {
            reason: "握手中止".to_string(),
        };
        
        let next_state = Protocol {
            client_id: self.client_id,
            session_id: None,
            _state: std::marker::PhantomData,
        };
        
        (next_state, close_msg)
    }
}

// 已建立状态实现
impl Protocol<Established> {
    // 发送数据
    fn send_data(&self, data: Vec<u8>) -> ProtocolMessage {
        ProtocolMessage::Data { content: data }
    }
    
    // 处理数据消息
    fn handle_data(&self, msg: ProtocolMessage) -> Result<Vec<u8>, &'static str> {
        match msg {
            ProtocolMessage::Data { content } => {
                Ok(content)
            },
            _ => Err("协议错误: 预期Data消息"),
        }
    }
    
    // 开始关闭（状态转移到Closing）
    fn close(self, reason: &str) -> (Protocol<Closing>, ProtocolMessage) {
        let close_msg = ProtocolMessage::Close {
            reason: reason.to_string(),
        };
        
        let next_state = Protocol {
            client_id: self.client_id,
            session_id: self.session_id,
            _state: std::marker::PhantomData,
        };
        
        (next_state, close_msg)
    }
}

// 关闭中状态实现
impl Protocol<Closing> {
    // 处理确认消息（状态转移到Closed）
    fn handle_ack(self, msg: ProtocolMessage) -> Result<Protocol<Closed>, &'static str> {
        match msg {
            ProtocolMessage::Acknowledge => {
                println!("收到关闭确认");
                
                Ok(Protocol {
                    client_id: self.client_id,
                    session_id: None,
                    _state: std::marker::PhantomData,
                })
            },
            _ => Err("协议错误: 预期Acknowledge消息"),
        }
    }
}

// 已关闭状态实现
impl Protocol<Closed> {
    // 重新连接（状态转移到Initial）
    fn reconnect(self) -> Protocol<Initial> {
        Protocol {
            client_id: self.client_id,
            session_id: None,
            _state: std::marker::PhantomData,
        }
    }
}

// 3. 零信任通信模型

// 安全令牌
struct SecurityToken {
    id: String,
    capabilities: Vec<Capability>,
    expires_at: std::time::Instant,
}

// 令牌能力
#[derive(Clone, PartialEq, Debug)]
enum Capability {
    Read(String),
    Write(String),
    Execute(String),
    Delete(String),
}

impl SecurityToken {
    fn new(id: &str, capabilities: Vec<Capability>, duration: std::time::Duration) -> Self {
        SecurityToken {
            id: id.to_string(),
            capabilities,
            expires_at: std::time::Instant::now() + duration,
        }
    }
    
    // 检查令牌是否过期
    fn is_valid(&self) -> bool {
        std::time::Instant::now() < self.expires_at
    }
    
    // 检查是否有特定能力
    fn has_capability(&self, capability: &Capability) -> bool {
        self.capabilities.contains(capability)
    }
}

// 安全资源管理器
struct SecureResourceManager {
    resources: Mutex<HashMap<String, Vec<u8>>>,
}

impl SecureResourceManager {
    fn new() -> Self {
        SecureResourceManager {
            resources: Mutex::new(HashMap::new()),
        }
    }
    
    // 创建资源
    fn create_resource(&self, token: &SecurityToken, name: &str, data: Vec<u8>) -> Result<(), &'static str> {
        // 验证令牌
        if !token.is_valid() {
            return Err("令牌已过期");
        }
        
        // 验证权限
        let write_cap = Capability::Write(name.to_string());
        if !token.has_capability(&write_cap) {
            return Err("令牌没有写入权限");
        }
        
        // 创建资源
        let mut resources = self.resources.lock().unwrap();
        if resources.contains_key(name) {
            return Err("资源已存在");
        }
        
        resources.insert(name.to_string(), data);
        println!("创建资源: {}", name);
        
        Ok(())
    }
    
    // 读取资源
    fn read_resource(&self, token: &SecurityToken, name: &str) -> Result<Vec<u8>, &'static str> {
        // 验证令牌
        if !token.is_valid() {
            return Err("令牌已过期");
        }
        
        // 验证权限
        let read_cap = Capability::Read(name.to_string());
        if !token.has_capability(&read_cap) {
            return Err("令牌没有读取权限");
        }
        
        // 读取资源
        let resources = self.resources.lock().unwrap();
        match resources.get(name) {
            Some(data) => {
                println!("读取资源: {}", name);
                Ok(data.clone())
            },
            None => Err("资源不存在"),
        }
    }
    
    // 更新资源
    fn update_resource(&self, token: &SecurityToken, name: &str, data: Vec<u8>) -> Result<(), &'static str> {
        // 验证令牌
        if !token.is_valid() {
            return Err("令牌已过期");
        }
        
        // 验证权限
        let write_cap = Capability::Write(name.to_string());
        if !token.has_capability(&write_cap) {
            return Err("令牌没有写入权限");
        }
        
        // 更新资源
        let mut resources = self.resources.lock().unwrap();
        if !resources.contains_key(name) {
            return Err("资源不存在");
        }
        
        resources.insert(name.to_string(), data);
        println!("更新资源: {}", name);
        
        Ok(())
    }
    
    // 删除资源
    fn delete_resource(&self, token: &SecurityToken, name: &str) -> Result<(), &'static str> {
        // 验证令牌
        if !token.is_valid() {
            return Err("令牌已过期");
        }
        
        // 验证权限
        let delete_cap = Capability::Delete(name.to_string());
        if !token.has_capability(&delete_cap) {
            return Err("令牌没有删除权限");
        }
        
        // 删除资源
        let mut resources = self.resources.lock().unwrap();
        if !resources.contains_key(name) {
            return Err("资源不存在");
        }
        
        resources.remove(name);
        println!("删除资源: {}", name);
        
        Ok(())
    }
}

// 安全令牌生成器
struct TokenIssuer {
    issuer_id: String,
}

impl TokenIssuer {
    fn new(issuer_id: &str) -> Self {
        TokenIssuer {
            issuer_id: issuer_id.to_string(),
        }
    }
    
    // 创建读取令牌
    fn create_read_token(&self, resource_names: &[&str], duration: std::time::Duration) -> SecurityToken {
        let capabilities = resource_names.iter()
            .map(|&name| Capability::Read(name.to_string()))
            .collect();
            
        let token_id = format!("read-{}-{}", 
            self.issuer_id, 
            std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
            
        SecurityToken::new(&token_id, capabilities, duration)
    }
    
    // 创建写入令牌
    fn create_write_token(&self, resource_names: &[&str], duration: std::time::Duration) -> SecurityToken {
        let mut capabilities = Vec::new();
        
        for &name in resource_names {
            capabilities.push(Capability::Read(name.to_string()));
            capabilities.push(Capability::Write(name.to_string()));
        }
            
        let token_id = format!("write-{}-{}", 
            self.issuer_id, 
            std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
            
        SecurityToken::new(&token_id, capabilities, duration)
    }
    
    // 创建管理员令牌
    fn create_admin_token(&self, resource_names: &[&str], duration: std::time::Duration) -> SecurityToken {
        let mut capabilities = Vec::new();
        
        for &name in resource_names {
            capabilities.push(Capability::Read(name.to_string()));
            capabilities.push(Capability::Write(name.to_string()));
            capabilities.push(Capability::Execute(name.to_string()));
            capabilities.push(Capability::Delete(name.to_string()));
        }
            
        let token_id = format!("admin-{}-{}", 
            self.issuer_id, 
            std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
            
        SecurityToken::new(&token_id, capabilities, duration)
    }
}

// 4. 所有权与安全通信示例
fn ownership_secure_communication_example() {
    println!("\n=== 所有权型通信通道示例 ===");
    
    // 创建所有权通道
    let (tx, rx) = OwnershipChannel::<String>::create(5);
    
    // 发送线程
    let tx_clone = tx.clone();
    let sender_thread = thread::spawn(move || {
        for i in 0..10 {
            let message = format!("消息 {}", i);
            println!("发送: {}", message);
            
            match tx_clone.send(message) {
                Ok(_) => {},
                Err(e) => {
                    println!("发送错误: {}", e);
                    break;
                }
            }
            
            thread::sleep(Duration::from_millis(100));
        }
        
        println!("发送线程结束");
    });
    
    // 接收线程
    let receiver_thread = thread::spawn(move || {
        for _ in 0..10 {
            match rx.recv() {
                Ok(message) => println!("接收: {}", message),
                Err(e) => {
                    println!("接收错误: {}", e);
                    break;
                }
            }
            
            thread::sleep(Duration::from_millis(200));
        }
        
        println!("接收线程结束");
    });
    
    // 等待线程完成
    sender_thread.join().unwrap();
    receiver_thread.join().unwrap();
    
    println!("\n=== 状态机驱动的协议示例 ===");
    
    // 创建协议实例
    let protocol = Protocol::<Initial>::new("client-123");
    
    // 发起连接
    let (handshake_protocol, connect_msg) = protocol.connect();
    println!("发送连接消息: {:?}", connect_msg);
    
    // 处理Accept消息
    let accept_msg = ProtocolMessage::Accept { 
        session_id: "session-456".to_string() 
    };
    
    let established_protocol = match handshake_protocol.handle_accept(accept_msg) {
        Ok(protocol) => protocol,
        Err(e) => {
            println!("握手错误: {}", e);
            return;
        }
    };
    
    println!("连接已建立");
    
    // 发送数据
    let data_msg = established_protocol.send_data(b"Hello, Protocol!".to_vec());
    println!("发送数据消息");
    
    // 处理接收到的数据消息
    let received_data_msg = ProtocolMessage::Data { 
        content: b"Response data".to_vec() 
    };
    
    match established_protocol.handle_data(received_data_msg) {
        Ok(data) => println!("接收数据: {}", String::from_utf8_lossy(&data)),
        Err(e) => println!("数据处理错误: {}", e),
    }
    
    // 关闭连接
    let (closing_protocol, close_msg) = established_protocol.close("客户端请求关闭");
    println!("发送关闭消息");
    
    // 处理确认消息
    let ack_msg = ProtocolMessage::Acknowledge;
    let closed_protocol = match closing_protocol.handle_ack(ack_msg) {
        Ok(protocol) => protocol,
        Err(e) => {
            println!("关闭错误: {}", e);
            return;
        }
    };
    
    println!("连接已关闭");
    
    // 重新连接
    let _new_protocol = closed_protocol.reconnect();
    println!("准备重新连接");
    
    println!("\n=== 零信任通信模型示例 ===");
    
    // 创建资源管理器
    let resource_manager = SecureResourceManager::new();
    
    // 创建令牌颁发者
    let token_issuer = TokenIssuer::new("auth-server-1");
    
    // 创建资源列表
    let resources = ["document.txt", "config.yaml", "data.bin"];
    
    // 创建只读令牌
    let read_token = token_issuer.create_read_token(
        &resources,
        Duration::from_secs(60)
    );
    println!("创建只读令牌: {}", read_token.id);
    
    // 创建读写令牌
    let write_token = token_issuer.create_write_token(
        &resources,
        Duration::from_secs(60)
    );
    println!("创建读写令牌: {}", write_token.id);
    
    // 创建管理员令牌
    let admin_token = token_issuer.create_admin_token(
        &resources,
        Duration::from_secs(60)
    );
    println!("创建管理员令牌: {}", admin_token.id);
    
    // 使用令牌创建资源
    match resource_manager.create_resource(&write_token, "document.txt", b"Document content".to_vec()) {
        Ok(_) => println!("成功创建文档资源"),
        Err(e) => println!("创建资源错误: {}", e),
    }
    
    match resource_manager.create_resource(&admin_token, "config.yaml", b"config: production".to_vec()) {
        Ok(_) => println!("成功创建配置资源"),
        Err(e) => println!("创建资源错误: {}", e),
    }
    
    // 使用只读令牌尝试创建资源（应该失败）
    match resource_manager.create_resource(&read_token, "data.bin", b"binary data".to_vec()) {
        Ok(_) => println!("意外: 只读令牌创建资源成功"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 使用读写令牌创建资源
    match resource_manager.create_resource(&write_token, "data.bin", b"binary data".to_vec()) {
        Ok(_) => println!("成功创建二进制资源"),
        Err(e) => println!("创建资源错误: {}", e),
    }
    
    // 读取资源
    match resource_manager.read_resource(&read_token, "document.txt") {
        Ok(data) => println!("读取文档: {}", String::from_utf8_lossy(&data)),
        Err(e) => println!("读取错误: {}", e),
    }
    
    // 更新资源
    match resource_manager.update_resource(&write_token, "document.txt", b"Updated document content".to_vec()) {
        Ok(_) => println!("成功更新文档"),
        Err(e) => println!("更新错误: {}", e),
    }
    
    // 读取更新后的资源
    match resource_manager.read_resource(&admin_token, "document.txt") {
        Ok(data) => println!("读取更新后的文档: {}", String::from_utf8_lossy(&data)),
        Err(e) => println!("读取错误: {}", e),
    }
    
    // 使用只读令牌尝试删除资源（应该失败）
    match resource_manager.delete_resource(&read_token, "config.yaml") {
        Ok(_) => println!("意外: 只读令牌删除资源成功"),
        Err(e) => println!("预期的错误: {}", e),
    }
    
    // 使用管理员令牌删除资源
    match resource_manager.delete_resource(&admin_token, "config.yaml") {
        Ok(_) => println!("成功删除配置资源"),
        Err(e) => println!("删除错误: {}", e),
    }
    
    // 尝试读取已删除的资源
    match resource_manager.read_resource(&read_token, "config.yaml") {
        Ok(data) => println!("意外: 读取到已删除的资源: {}", String::from_utf8_lossy(&data)),
        Err(e) => println!("预期的错误: {}", e),
    }
}
```

### 所有权范式的跨语言应用

所有权思想跨语言应用的可能性：

1. **非Rust语言的所有权模式**
   - 其他语言中所有权的模拟与实现
   - 未内置所有权的语言应用模式

2. **语言间所有权模型互操作**
   - 跨语言边界的所有权转移
   - 资源安全的外部函数接口

3. **通用所有权模型抽象**
   - 可跨语言应用的所有权抽象
   - 语言无关资源管理设计模式

```rust
// 所有权范式的跨语言应用示例

// 注：这部分示例主要是伪代码和设计模式，无法实际运行

// 1. 非Rust语言的所有权模式

// Java中模拟所有权（伪代码）
/*
// 模拟所有权的包装类
class Owned<T> {
    private T value;
    private boolean consumed = false;
    
    public Owned(T value) {
        this.value = value;
    }
    
    // 访问值（不消耗所有权）
    public T borrow() {
        if (consumed) {
            throw new IllegalStateException("资源已被消费");
        }
        return value;
    }
    
    // 消费值（所有权转移）
    public T consume() {
        if (consumed) {
            throw new IllegalStateException("资源已被消费");
        }
        consumed = true;
        return value;
    }
    
    // 检查是否已消费
    public boolean isConsumed() {
        return consumed;
    }
}

// 使用示例
class OwnershipExample {
    public static void main(String[] args) {
        Owned<String> resource = new Owned<>("Hello, Ownership!");
        
        // 借用资源
        System.out.println("借用: " + resource.borrow());
        
        // 消费资源
        String value = resource.consume();
        System.out.println("消费: " + value);
        
        // 尝试再次访问（应该抛出异常）
        try {
            resource.borrow();
        } catch (IllegalStateException e) {
            System.out.println("预期异常: " + e.getMessage());
        }
    }
}
*/

// Python中模拟所有权（伪代码）
/*
class Owned:
    def __init__(self, value):
        self.value = value
        self.consumed = False
        
    def borrow(self):
        if self.consumed:
            raise ValueError("资源已被消费")
        return self.value
        
    def consume(self):
        if self.consumed:
            raise ValueError("资源已被消费")
        self.consumed = True
        return self.value
        
    def is_consumed(self):
        return self.consumed
        
# 使用示例
def main():
    resource = Owned("Hello, Ownership!")
    
    # 借用资源
    print(f"借用: {resource.borrow()}")
    
    # 消费资源
    value = resource.consume()
    print(f"消费: {value}")
    
    # 尝试再次访问
    try:
        resource.borrow()
    except ValueError as e:
        print(f"预期异常: {e}")
        
if __name__ == "__main__":
    main()
*/

// 2. 语言间所有权模型互操作

// Rust与C++间的所有权转移（伪代码）
/*
// C++端声明（拥有资源的类）
class ResourceHandle {
public:
    ResourceHandle(size_t size);
    ~ResourceHandle();  // 析构函数释放资源
    
    // 移动构造函数和赋值运算符
    ResourceHandle(ResourceHandle&& other) noexcept;
    ResourceHandle& operator=(ResourceHandle&& other) noexcept;
    
    // 禁用复制
    ResourceHandle(const ResourceHandle&) = delete;
    ResourceHandle& operator=(const ResourceHandle&) = delete;
    
    size_t size() const;
    void* data();
    
private:
    void* ptr;
    size_t _size;
};

// 提供给Rust的C接口
extern "C" {
    void* create_resource(size_t size);
    void destroy_resource(void* resource);
    size_t resource_size(void* resource);
}

// C++实现
void* create_resource(size_t size) {
    auto* handle = new ResourceHandle(size);
    return handle;
}

void destroy_resource(void* resource) {
    auto* handle = static_cast<ResourceHandle*>(resource);
    delete handle;
}

size_t resource_size(void* resource) {
    auto* handle = static_cast<ResourceHandle*>(resource);
    return handle->size();
}
*/

// Rust端的FFI绑定
#[repr(C)]
struct ResourceHandleFFI {
    _private: [u8; 0], // 不暴露内部结构
}

extern "C" {
    fn create_resource(size: usize) -> *mut ResourceHandleFFI;
    fn destroy_resource(resource: *mut ResourceHandleFFI);
    fn resource_size(resource: *const ResourceHandleFFI) -> usize;
}

// 安全的Rust包装
struct ResourceHandle {
    ptr: *mut ResourceHandleFFI,
    _marker: std::marker::PhantomData<ResourceHandleFFI>,
}

impl ResourceHandle {
    fn new(size: usize) -> Self {
        let ptr = unsafe { create_resource(size) };
        ResourceHandle {
            ptr,
            _marker: std::marker::PhantomData,
        }
    }
    
    fn size(&self) -> usize {
        unsafe { resource_size(self.ptr) }
    }
}

// 实现Drop自动释放资源
impl Drop for ResourceHandle {
    fn drop(&mut self) {
        unsafe { destroy_resource(self.ptr) };
    }
}

// 安全地转移所有权到其他语言
struct OwnershipTransfer<T> {
    value: Option<T>,
}

impl<T> OwnershipTransfer<T> {
    fn new(value: T) -> Self {
        OwnershipTransfer { value: Some(value) }
    }
    
    // 转移所有权到外部（通过FFI）
    fn transfer(&mut self) -> *mut T {
        if let Some(value) = self.value.take() {
            Box::into_raw(Box::new(value))
        } else {
            std::ptr::null_mut()
        }
    }
    
    // 从外部接收所有权
    unsafe fn receive_ownership(ptr: *mut T) -> Self {
        if ptr.is_null() {
            OwnershipTransfer { value: None }
        } else {
            let value = Box::from_raw(ptr);
            OwnershipTransfer { value: Some(*value) }
        }
    }
}

// 3. 通用所有权模型抽象

// 资源声明周期阶段
enum ResourceStage {
    Created,
    Initialized,
    Active,
    Released,
}

// 通用资源模型
trait ResourceLifecycle {
    fn stage(&self) -> ResourceStage;
    fn initialize(&mut self) -> Result<(), &'static str>;
    fn activate(&mut self) -> Result<(), &'static str>;
    fn release(&mut self) -> Result<(), &'static str>;
}

// RAII通用资源管理器
struct ResourceManager<R: ResourceLifecycle> {
    resource: Option<R>,
}

impl<R: ResourceLifecycle> ResourceManager<R> {
    fn new(resource: R) -> Self {
        ResourceManager { resource: Some(resource) }
    }
    
    fn initialize(&mut self) -> Result<(), &'static str> {
        if let Some(res) = self.resource.as_mut() {
            if res.stage() != ResourceStage::Created {
                return Err("资源阶段不匹配");
            }
            res.initialize()?;
            Ok(())
        } else {
            Err("资源不存在")
        }
    }
    
    fn activate(&mut self) -> Result<(), &'static str> {
        if let Some(res) = self.resource.as_mut() {
            if res.stage() != ResourceStage::Initialized {
                return Err("资源阶段不匹配");
            }
            res.activate()?;
            Ok(())
        } else {
            Err("资源不存在")
        }
    }
    
    // 转移所有权到外部
    fn transfer(mut self) -> Result<R, &'static str> {
        if let Some(res) = self.resource.take() {
            Ok(res)
        } else {
            Err("资源不存在")
        }
    }
}

impl<R: ResourceLifecycle> Drop for ResourceManager<R> {
    fn drop(&mut self) {
        if let Some(mut res) = self.resource.take() {
            // 尝试释放资源
            if res.stage() == ResourceStage::Active || res.stage() == ResourceStage::Initialized {
                let _ = res.release();
            }
        }
    }
}

// 4. 跨语言所有权示例（伪实现）
fn cross_language_ownership_example() {
    println!("\n=== 跨语言所有权模拟 ===");
    
    // 这部分代码只是模拟，无法实际运行
    println!("注: 以下代码仅为设计示例，不能实际运行");
    
    // 模拟Java中的所有权模式
    println!("\n[Java模拟所有权]");
    println!("创建Owned<String>对象");
    println!("借用: Hello, Ownership!");
    println!("消费: Hello, Ownership!");
    println!("预期异常: 资源已被消费");
    
    // 模拟Python中的所有权模式
    println!("\n[Python模拟所有权]");
    println!("创建Owned对象");
    println!("借用: Hello, Ownership!");
    println!("消费: Hello, Ownership!");
    println!("预期异常: 资源已被消费");
    
    println!("\n=== 模拟跨语言资源转移 ===");
    
    // 创建一个假设的资源句柄 (实际FFI会使用真实的C++对象)
    println!("创建ResourceHandle(1024)");
    println!("ResourceHandle.size() = 1024");
    println!("ResourceHandle析构时自动释放资源");
    
    // 模拟所有权转移
    println!("\n[所有权转移示例]");
    println!("创建OwnershipTransfer对象并包含数据");
    println!("将所有权转移到外部系统");
    println!("此时Rust对象中value = None");
    println!("从外部系统接收所有权");
    println!("重新获得数据的所有权");
    
    println!("\n=== 通用资源生命周期管理 ===");
    
    // 定义一个符合ResourceLifecycle的演示类型
    struct DemoResource {
        stage: ResourceStage,
        name: String,
    }
    
    impl DemoResource {
        fn new(name: &str) -> Self {
            DemoResource {
                stage: ResourceStage::Created,
                name: name.to_string(),
            }
        }
    }
    
    impl ResourceLifecycle for DemoResource {
        fn stage(&self) -> ResourceStage {
            self.stage.clone()
        }
        
        fn initialize(&mut self) -> Result<(), &'static str> {
            if self.stage != ResourceStage::Created {
                return Err("资源已初始化");
            }
            
            println!("初始化资源: {}", self.name);
            self.stage = ResourceStage::Initialized;
            
            Ok(())
        }
        
        fn activate(&mut self) -> Result<(), &'static str> {
            if self.stage != ResourceStage::Initialized {
                return Err("资源未初始化");
            }
            
            println!("激活资源: {}", self.name);
            self.stage = ResourceStage::Active;
            
            Ok(())
        }
        
        fn release(&mut self) -> Result<(), &'static str> {
            if self.stage == ResourceStage::Released {
                return Err("资源已释放");
            }
            
            println!("释放资源: {}", self.name);
            self.stage = ResourceStage::Released;
            
            Ok(())
        }
    }
    
    // 使用通用资源管理器
    let resource = DemoResource::new("跨语言资源");
    
    // 创建资源管理器
    let mut manager = ResourceManager::new(resource);
    
    // 初始化资源
    if let Err(e) = manager.initialize() {
        println!("初始化失败: {}", e);
        return;
    }
    
    // 激活资源
    if let Err(e) = manager.activate() {
        println!("激活失败: {}", e);
        return;
    }
    
    // 转移所有权到外部函数（模拟）
    match manager.transfer() {
        Ok(resource) => {
            println!("成功转移资源所有权: {}", resource.name);
            // 在这里资源的所有权已转移，manager不再拥有资源
        },
        Err(e) => println!("转移失败: {}", e),
    }
    
    println!("演示程序结束");
}
```

## 结论

### 所有权系统的优势与限制

Rust所有权系统的优劣势：

1. **优势总结**
   - 内存安全保证与性能
   - 并发安全的自动验证
   - 资源管理的明确语义

2. **限制与权衡**
   - 生命周期标注的复杂性
   - 对特定架构的限制
   - 学习曲线的陡峭

3. **应用场景适合度**
   - 不同问题领域的适用性分析
   - 任务特性与所有权匹配度

```rust
// 所有权系统的优势与限制示例

// 这个文件主要是分析和代码注释，而不是可执行的代码

/*
## 1. 所有权系统的优势

### 1.1 内存安全保证与性能

Rust的所有权系统通过以下机制确保内存安全：

- 所有资源有明确的所有者
- 资源只能有一个所有者
- 当所有者离开作用域时，资源自动释放
- 借用检查器在编译时防止悬垂引用和数据竞争

这些机制在编译时执行，没有运行时开销，实现了零成本抽象：

```rust
fn ownership_safety() {
    // 资源有单一所有者
    let mut v = vec![1, 2, 3];
    
    // 借用规则确保引用安全
    let r1 = &v;     // 不可变借用
    let r2 = &v;     // 多个不可变借用是允许的
    // let r3 = &mut v; // 错误：已存在不可变借用时不能可变借用
    
    println!("Values: {} {}", r1[0], r2[1]);
    
    // r1和r2不再使用后，可以创建可变借用
    let r3 = &mut v;
    r3[0] = 10;
    
    // v在这里自动释放 - 无需手动管理内存
}
```

与其他语言相比：

- C/C++: 手动内存管理容易出错
- GC语言: 垃圾收集带来性能损失和不可预期的暂停
- Rust: 内存安全的同时保持高性能和可预期行为

### 1.2 并发安全的自动验证

Rust借用规则自然延伸到并发领域：

```rust
fn concurrency_safety() {
    let mut data = vec![1, 2, 3];
    
    // 多线程不可变借用是安全的
    let handles: Vec<_> = (0..3).map(|i| {
        let data_ref = &data; // 不可变借用
        std::thread::spawn(move || {
            println!("线程 {}: 读取 {:?}", i, data_ref);
        })
    }).collect();
    
    // 等待所有线程完成
    for h in handles {
        h.join().unwrap();
    }
    
    // 此时没有活跃的借用，可以安全修改
    data.push(4);
    
    // 以下代码编译错误 - Rust防止数据竞争：
    /*
    let handle1 = std::thread::spawn(move || {
        data.push(5); // 尝试转移所有权到线程1
    });
    
    let handle2 = std::thread::spawn(move || {
        data.push(6); // 错误：data的所有权已经转移
    });
    */
}
```

### 1.3 资源管理的明确语义

所有权模型不仅适用于内存，还适用于所有需要管理的资源：

```rust
fn resource_management() {
    // 文件资源自动管理
    {
        let mut file = std::fs::File::create("example.txt").unwrap();
        file.write_all(b"Hello, Rust!").unwrap();
        // 文件在离开作用域时自动关闭
    }
    
    // 网络连接示例
    {
        let mut stream = std::net::TcpStream::connect("example.com:80").unwrap();
        stream.write_all(b"GET / HTTP/1.0\r\n\r\n").unwrap();
        // 连接在离开作用域时自动关闭
    }
    
    // 锁资源管理
    {
        let mutex = std::sync::Mutex::new(0);
        {
            let mut guard = mutex.lock().unwrap();
            *guard += 1;
            // 锁在guard离开作用域时自动释放
        }
        // 此时锁已释放
    }
}
```

资源管理的明确语义带来的好处：

- RAII (资源获取即初始化) 的一致性实现
- 资源泄漏风险的极大降低
- 更容易推理程序的资源使用情况

## 2. 所有权系统的限制

### 2.1 生命周期标注的复杂性

复杂的借用模式可能需要详细的生命周期标注：

```rust
// 简单情况下生命周期是自动推导的
fn simple_lifetimes(s: &str) -> &str {
    s
}

// 复杂情况需要明确标注
fn complex_lifetimes<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    if x.len() > y.len() { x } else { x }  // 返回值必须遵循'a
}

// 结构体中的引用也需要生命周期标注
struct DataHolder<'a> {
    reference: &'a [i32],
}

// 实现方法时也需要重复生命周期标注
impl<'a> DataHolder<'a> {
    fn get_first(&self) -> Option<&'a i32> {
        self.reference.first()
    }
}
```

这种复杂性使得某些模式难以实现：

- 自引用结构体需要特殊处理
- 复杂的数据结构（如图）需要替代方案
- 学习曲线变得更加陡峭

### 2.2 对特定架构的限制

某些设计模式与所有权模型不太兼容：

```rust
// 观察者模式实现困难
struct Subject {
    // 无法直接存储对观察者的引用，因为生命周期不明确
    // observers: Vec<&Observer>  // 不行
    
    // 必须使用间接方式
    observers: Vec<Box<dyn Observer>>,  // 使用Box
    // 或使用弱引用
    // observers: Vec<Weak<RefCell<dyn Observer>>>,
}

// 循环引用需要特殊处理
struct Node {
    // 简单引用会导致生命周期问题
    // parent: Option<&Node>,  // 不行
    
    // 需要使用Rc<RefCell<>>或Weak<RefCell<>>
    // 但这增加了运行时开销和复杂性
}
```

所有权系统对这些情况的限制：

- 某些动态数据结构需要额外的运行时支持
- 引用计数和内部可变性引入了运行时开销
- 纯函数式模式有时更难实现

### 2.3 学习曲线的陡峭

所有权概念对新手的挑战：

```rust
fn learning_curve_examples() {
    // 对初学者常见的困惑点
    
    // 1. 移动语义与克隆
    let s1 = String::from("hello");
    let s2 = s1;  // 所有权转移，s1不再有效
    // println!("{}", s1);  // 错误：s1的值已移动
    
    // 2. 借用规则
    let mut value = 5;
    let r1 = &value;
    let r2 = &value;
    // let r3 = &mut value;  // 错误：已有不可变借用时不能可变借用
    
    // 3. 生命周期关系
    let result: &str;
    {
        let s = String::from("临时字符串");
        // result = &s;  // 错误：s的生命周期太短
    }
    // println!("{}", result);  // 结果会是悬垂引用
}
```

学习曲线陡峭的原因：

- 所有权思想对大多数程序员来说是新概念
- "与编译器斗争"的挫折感
- 一些错误信息可能难以理解（尽管已大大改进）

## 3. 应用场景适合度

### 3.1 最适合的应用场景

Rust所有权系统最适合：

```rust
// 系统编程
fn systems_programming() {
    // 操作系统组件
    // 设备驱动
    // 嵌入式系统
}

// 性能关键型应用
fn performance_critical() {
    // 游戏引擎
    // 数据库
    // 网络服务器
}

// 安全关键型应用
fn safety_critical() {
    // 加密库
    // 金融系统
    // 医疗设备软件
}
```

这些场景特点：

- 对内存安全有严格要求
- 对性能有高要求
- 不能接受垃圾收集带来的不确定性

### 3.2 挑战较大的应用场景

某些场景实现起来较为复杂：

```rust
// 图形UI框架
fn gui_frameworks() {
    // 组件间复杂引用关系
    // 事件回调系统
    // 控件层次结构
}

// 动态度高的脚本语言
fn scripting_languages() {
    // 高度动态类型系统
    // 元编程需求
    // 解释执行环境
}

// 快速原型开发
fn rapid_prototyping() {
    // 需要快速迭代
    // 代码正确性没那么关键
    // 开发速度优先于运行性能
}
```

这些场景特点：

- 需要高度动态的对象关系
- 开发速度比性能更重要
- 对象生命周期高度不确定

### 3.3 权衡与选择

如何选择是否使用Rust：

```rust
fn decision_factors() {
    // 安全需求程度
    let safety_critical = true;
    
    // 性能需求程度
    let performance_critical = true;
    
    // 开发速度需求
    let rapid_development = false;
    
    // 团队Rust经验
    let team_rust_experience = true;
    
    // 决策逻辑
    if safety_critical && performance_critical && team_rust_experience {
        // 选择Rust
    } else if rapid_development && !safety_critical {
        // 考虑其他语言
    } else {
        // 进一步评估或混合使用多种语言
    }
}
```

关键权衡因素：

- 团队经验与学习成本
- 项目时间线与安全要求
- 与现有代码库的集成需求

### 面向未来的所有权系统

所有权系统的发展方向与趋势：

1. **所有权系统的演进**
   - Rust所有权模型的改进方向
   - 降低复杂性的工具与抽象

2. **其他语言中的所有权**
   - 主流语言采纳所有权的趋势
   - 混合所有权模型的探索

3. **未来研究方向**
   - 自动化所有权推导与验证
   - 跨语言所有权系统的标准化

```rust
// 面向未来的所有权系统示例与展望

/*
## 1. 所有权系统的演进

### 1.1 Rust所有权模型的改进方向

Rust所有权系统已经相当成熟，但仍有改进空间：

```rust
// 现有的复杂模式
struct SelfReferential {
    data: String,
    // 无法直接存储指向自身数据的引用
    // ptr: &str, // 无法编译
}

// 未来可能的改进方向
/*
// 自引用结构体的更简洁表达
#[self_referential]
struct BetterSelfReferential {
    data: String,
    ptr: &str, // 指向data的引用
}
*/

// 现有的解决方案需要额外库
// 例如using pin-project, ouroboros等
```

潜在的改进领域：

- 更简洁的生命周期标注语法
- 编译器改进自动推导能力
- 更丰富的借用检查器诊断信息
- 中级抽象概念降低学习曲线

### 1.2 降低复杂性的工具与抽象

工具和库已经在简化常见模式：

```rust
// 现有的复杂共享所有权
fn existing_shared_ownership() {
    use std::rc::Rc;
    use std::cell::RefCell;
    
    // 需要手动管理Rc和RefCell
    let data = Rc::new(RefCell::new(vec![1, 2, 3]));
    let data2 = Rc::clone(&data);
    
    data.borrow_mut().push(4);
    println!("修改后: {:?}", data2.borrow());
}

// 未来可能出现更高级抽象
/*
fn future_shared_ownership() {
    // 假想的更简洁API
    let data = shared_vec![1, 2, 3];
    let data2 = data.clone();
    
    data.push(4);
    println!("修改后: {:?}", data2);
}
*/
```

可能的工具改进：

- 静态分析工具自动检测常见所有权模式
- IDE集成提供实时所有权可视化
- 库抽象简化常见的所有权模式

## 2. 其他语言中的所有权

### 2.1 主流语言采纳所有权的趋势

其他语言已开始借鉴Rust的所有权概念：

```rust
// C++中正在引入的所有权相关概念
/*
// C++20 std::span - 借用检查的基本概念
void process_data(std::span<int> data) {
    // 非拥有的视图，类似Rust的&[T]
}

// C++23 std::expected - Result的等价物
std::expected<File, Error> open_file(const std::string& path) {
    // 类似Rust的Result返回模式
}
*/

// C#中的ref/in/out参数和readonly ref
/*
// 参数传递所有权语义更清晰
void Process(in int value) { // 不可变借用
    // ...
}

void Modify(ref int value) { // 可变借用
    // ...
}

void Initialize(out int value) { // 初始化输出参数
    // ...
}
*/
```

主流语言借鉴的趋势：

- C++: 借用检查器工具、所有权语义指导
- Java/C#: 引入不可变类型、改进值类型语义
- Swift: 借用已引入一些所有权概念
- 新语言如V、Carbon等直接采纳所有权模型

### 2.2 混合所有权模型的探索

各种语言正在尝试结合自身特点与所有权概念：

```rust
// 垃圾收集和所有权的混合模型
/*
// 假想的混合所有权语言
fn hybrid_ownership() {
    // 默认GC管理的对象
    let x = GcObject::new(42);
    
    // 显式声明的所有权管理对象
    let y = owned String::from("Hello");
    
    // 借用语义
    process(&y);
    
    // 结束时y自动释放，x由GC处理
}
*/

// 运行时检查的所有权模型
/*
// 编译时不强制，但运行时检查所有权规则
let x = owned vec![1, 2, 3];
let y = x;  // 转移所有权
// x[0];    // 运行时错误：使用已移动的值
*/
```

混合模型的优势：

- 降低学习曲线
- 允许渐进式采用
- 结合不同模型的优点
- 特定领域可按需启用严格检查

## 3. 未来研究方向

### 3.1 自动化所有权推导与验证

研究人员正在探索自动推导所有权信息：

```rust
// 现在需要手动标注的情况
fn complex_lifetime<'a, 'b, 'c>(
    x: &'a str,
    y: &'b str,
    z: &'c str,
) -> &'a str {
    if x.len() > y.len() && x.len() > z.len() {
        x
    } else if y.len() > z.len() {
        &x[0..1]  // 仍然返回来自x的引用
    } else {
        &x[0..1]  // 仍然返回来自x的引用
    }
}

// 未来可能的自动推导
/*
// 无需标注生命周期，编译器通过先进分析自动推导
fn auto_inferred_lifetime(
    x: &str,
    y: &str, 
    z: &str
) -> &str {
    // 复杂的控制流
    // 编译器能通过先进分析确定返回引用的来源
}
*/
```

研究方向包括：

- 基于分离逻辑的自动推导
- 机器学习辅助的所有权推断
- 智能生命周期推导算法
- 基于区域的自动内存管理

### 3.2 跨语言所有权系统的标准化

标准化所有权概念以便跨语言应用：

```rust
// 跨语言接口中的所有权表达
/*
// 所有权注解的IDL（接口定义语言）
interface DataProcessor {
    // 转移所有权的方法
    @consumes
    Result<()> process_data(@owned Data data);
    
    // 借用的方法
    @pure
    Stats analyze(@borrowed Data data);
    
    // 返回新拥有的对象
    @produces
    @owned Report generate_report();
}
*/
```

标准化的潜在好处：

- 不同语言间更安全的互操作
- 所有权信息在API边界的保留
- 混合语言系统中的资源安全
- 更一致的工具支持

## 4. 所有权系统对软件工程的深远影响

所有权系统已经开始改变软件设计思维：

```rust
// 所有权思想影响的设计模式
fn ownership_driven_design() {
    // 1. 明确资源责任
    struct ResourceManager {
        // 显式负责资源生命周期
    }
    
    // 2. 接口设计反映所有权转移
    trait DataProcessor {
        // 方法签名清晰表明所有权意图
        fn process(&self, data: &[u8]) -> Vec<u8>;
        fn consume(self, data: Vec<u8>);
    }
    
    // 3. 错误处理更精确
    enum CustomError {
        ResourceBusy,     // 资源暂时不可用
        ResourceMoved,    // 资源所有权已转移
        AccessDenied,     // 没有权限访问
    }
}
```

深远影响包括：

- API设计更明确表达资源意图
- 架构设计考虑资源所有权流转
- 错误处理更全面关注资源状态
- 并发设计从所有权角度思考数据共享

未来所有权将成为软件工程的基础概念，影响范围远超编程语言本身，成为正确设计系统的思维模型。

## 总结

通过这次对Rust所有权系统的深入探讨，我们建立了一个将所有权视为核心概念的资源管理视角。从基础概念到高级应用，从实现机制到跨语言应用，我们看到所有权不仅是一种语言特性，更是一种解决资源管理问题的思维方式。

所有权系统的核心价值在于：

1. **安全性与正确性**：通过编译时验证，防止内存错误和数据竞争。

2. **明确的资源语义**：清晰地表达资源创建、使用和释放的意图。

3. **高效运行时表现**：无需垃圾收集，实现可预测的性能。

4. **并发编程模型**：自然融入并发设计，避免数据竞争。

5. **领域特定应用**：适应从低级系统编程到高级抽象的各种应用场景。

这种资源管理方法虽然有学习曲线，但它所提供的安全保障和表达能力弥补了这一点。随着工具和生态系统的发展，所有权概念将变得更加易于应用，并可能影响更广泛的编程语言和系统设计领域。

所有权思想不仅限于Rust，它代表了一种更广泛的资源管理哲学，这种哲学将继续影响软件工程的未来发展。通过理解和应用所有权原则，我们能够构建更安全、更可靠、更高效的系统。

随着计算系统的复杂性不断增长，所有权驱动的资源管理将成为应对这种复杂性的重要工具，帮助我们在保证正确性的同时控制系统的复杂度。
