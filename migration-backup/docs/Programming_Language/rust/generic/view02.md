
# Rustæ³›å‹ä¸å¤šæ€ç³»ç»Ÿå…¨é¢è§£æï¼šåŸç†ã€åº”ç”¨ä¸æ‰¹åˆ¤æ€§è¯„ä»·

## ç›®å½•

- [Rustæ³›å‹ä¸å¤šæ€ç³»ç»Ÿå…¨é¢è§£æï¼šåŸç†ã€åº”ç”¨ä¸æ‰¹åˆ¤æ€§è¯„ä»·](#rustæ³›å‹ä¸å¤šæ€ç³»ç»Ÿå…¨é¢è§£æåŸç†åº”ç”¨ä¸æ‰¹åˆ¤æ€§è¯„ä»·)
  - [ç›®å½•](#ç›®å½•)
  - [å¼•è¨€](#å¼•è¨€)
    - [ç±»å‹ç³»ç»Ÿè®¾è®¡å“²å­¦](#ç±»å‹ç³»ç»Ÿè®¾è®¡å“²å­¦)
    - [é›¶æˆæœ¬æŠ½è±¡åŸåˆ™](#é›¶æˆæœ¬æŠ½è±¡åŸåˆ™)
    - [å®‰å…¨ä¸æ€§èƒ½çš„å¹³è¡¡](#å®‰å…¨ä¸æ€§èƒ½çš„å¹³è¡¡)
  - [Rustç±»å‹ç³»ç»Ÿçš„åŸºçŸ³](#rustç±»å‹ç³»ç»Ÿçš„åŸºçŸ³)
    - [æ³›å‹åŸºç¡€è®¾è®¡](#æ³›å‹åŸºç¡€è®¾è®¡)
    - [æ³›å‹çš„å•æ€åŒ–å®ç°æœºåˆ¶](#æ³›å‹çš„å•æ€åŒ–å®ç°æœºåˆ¶)
    - [Ad-hocå¤šæ€çš„å®ç°](#ad-hocå¤šæ€çš„å®ç°)
    - [å¤šæ€è¡¨è¾¾æ–¹å¼çš„æ¯”è¾ƒ](#å¤šæ€è¡¨è¾¾æ–¹å¼çš„æ¯”è¾ƒ)
  - [æ³›å‹çš„åº”ç”¨åœºæ™¯](#æ³›å‹çš„åº”ç”¨åœºæ™¯)
    - [æ³›å‹å‡½æ•°ä¸æ–¹æ³•](#æ³›å‹å‡½æ•°ä¸æ–¹æ³•)
    - [æ³›å‹ç»“æ„ä½“](#æ³›å‹ç»“æ„ä½“)
    - [æ³›å‹æšä¸¾](#æ³›å‹æšä¸¾)
    - [é›†åˆç±»å‹ä¸­çš„æ³›å‹åº”ç”¨](#é›†åˆç±»å‹ä¸­çš„æ³›å‹åº”ç”¨)
    - [é›¶å¤§å°ç±»å‹ä¸æ ‡è®°ç±»å‹](#é›¶å¤§å°ç±»å‹ä¸æ ‡è®°ç±»å‹)
  - [traitç³»ç»Ÿæ·±å…¥åˆ†æ](#traitç³»ç»Ÿæ·±å…¥åˆ†æ)
    - [traitä½œä¸ºæ¥å£æŠ½è±¡](#traitä½œä¸ºæ¥å£æŠ½è±¡)
    - [traitçº¦æŸä¸è¾¹ç•Œ](#traitçº¦æŸä¸è¾¹ç•Œ)
    - [traitå¯¹è±¡ä¸åŠ¨æ€åˆ†å‘](#traitå¯¹è±¡ä¸åŠ¨æ€åˆ†å‘)
    - [å…³è”ç±»å‹ä¸æ³›å‹å…³è”ç±»å‹](#å…³è”ç±»å‹ä¸æ³›å‹å…³è”ç±»å‹)
    - [traitç»§æ‰¿ä¸ç»„åˆ](#traitç»§æ‰¿ä¸ç»„åˆ)
    - [å­¤å„¿è§„åˆ™åŠå…¶å½±å“](#å­¤å„¿è§„åˆ™åŠå…¶å½±å“)
  - [é«˜çº§æ³›å‹æ¨¡å¼](#é«˜çº§æ³›å‹æ¨¡å¼)
    - [æ–°ç±»å‹æ¨¡å¼(Newtype Pattern)](#æ–°ç±»å‹æ¨¡å¼newtype-pattern)
    - [å¹»å½±ç±»å‹(Phantom Types)](#å¹»å½±ç±»å‹phantom-types)
    - [é€’å½’ç±»å‹çš„å®ç°](#é€’å½’ç±»å‹çš„å®ç°)
    - [é€’å½’traitæ¨¡å¼](#é€’å½’traitæ¨¡å¼)
    - [æ™ºèƒ½æŒ‡é’ˆä¸æ³›å‹](#æ™ºèƒ½æŒ‡é’ˆä¸æ³›å‹)
    - [æ„å»ºè€…æ¨¡å¼ä¸æµå¼æ¥å£](#æ„å»ºè€…æ¨¡å¼ä¸æµå¼æ¥å£)
  - [æ³›å‹åœ¨ç‰¹å®šé¢†åŸŸçš„åº”ç”¨](#æ³›å‹åœ¨ç‰¹å®šé¢†åŸŸçš„åº”ç”¨)
    - [é”™è¯¯å¤„ç†æ¨¡å¼](#é”™è¯¯å¤„ç†æ¨¡å¼)
    - [å¹¶å‘ä¸åŒæ­¥åŸè¯­](#å¹¶å‘ä¸åŒæ­¥åŸè¯­)
    - [å¼‚æ­¥ç¼–ç¨‹ä¸­çš„æ³›å‹](#å¼‚æ­¥ç¼–ç¨‹ä¸­çš„æ³›å‹)
  - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)

## å¼•è¨€

### ç±»å‹ç³»ç»Ÿè®¾è®¡å“²å­¦

Rustçš„ç±»å‹ç³»ç»Ÿä½“ç°äº†"å®‰å…¨æ€§ã€æ€§èƒ½ä¸è¡¨è¾¾åŠ›å¹¶é‡"çš„æ ¸å¿ƒè®¾è®¡ç†å¿µã€‚åœ¨ç³»ç»Ÿç¼–ç¨‹è¯­è¨€å†å²ä¸Šï¼Œç±»å‹ç³»ç»Ÿé€šå¸¸è¦ä¹ˆåå‘ç®€å•ç›´æ¥çš„è¡¨è¾¾ï¼ˆå¦‚Cï¼‰ï¼Œè¦ä¹ˆæ³¨é‡ä¸¥æ ¼çš„å®‰å…¨ä¿è¯ä½†ç‰ºç‰²è¿è¡Œæ•ˆç‡ï¼ˆå¦‚æ—©æœŸçš„Javaï¼‰ã€‚Rustè¯•å›¾é€šè¿‡åˆ›æ–°çš„ç±»å‹ç³»ç»Ÿè®¾è®¡å®ç°äºŒè€…çš„ç»Ÿä¸€ï¼Œä»¥ç¼–è¯‘æœŸæ£€æŸ¥å–ä»£è¿è¡Œæ—¶éªŒè¯ï¼Œåœ¨ä¸æŸå¤±è¡¨è¾¾åŠ›çš„åŒæ—¶ä¿è¯å†…å­˜å®‰å…¨å’Œå¹¶å‘å®‰å…¨ã€‚

è¿™ç§å“²å­¦ä½¿Rustæˆä¸ºé¦–ä¸ªå°†å€Ÿç”¨æ£€æŸ¥å™¨ã€ç”Ÿå‘½å‘¨æœŸåˆ†æä¸å…ˆè¿›ç±»å‹ç³»ç»Ÿç»“åˆçš„ä¸»æµç³»ç»Ÿè¯­è¨€ï¼Œä¸ºç¼–ç¨‹è¯­è¨€è®¾è®¡æä¾›äº†æ–°çš„æ€è·¯ã€‚æ³›å‹å’Œtraitæœºåˆ¶æ˜¯å®ç°è¿™ä¸€ç†å¿µçš„å…³é”®ç»„æˆéƒ¨åˆ†ï¼Œå®ƒä»¬å…è®¸å¼€å‘è€…ç¼–å†™æŠ½è±¡ä¸”é€šç”¨çš„ä»£ç ï¼ŒåŒæ—¶ä¸æŸå¤±è¿è¡Œæ—¶æ€§èƒ½ã€‚

### é›¶æˆæœ¬æŠ½è±¡åŸåˆ™

é›¶æˆæœ¬æŠ½è±¡ï¼ˆZero-cost Abstractionsï¼‰æ˜¯Rustæœ€é‡è¦çš„è®¾è®¡åŸåˆ™ä¹‹ä¸€ï¼Œæºè‡ªC++ä¹‹çˆ¶Bjarne Stroustrupçš„ç†å¿µï¼š"ä¸ä½¿ç”¨çš„ç‰¹æ€§ä¸ä»˜å‡ºæˆæœ¬ï¼›ä½¿ç”¨çš„ç‰¹æ€§ä¸åº”æœ‰é¢å¤–å¼€é”€"ã€‚Rustçš„æ³›å‹ã€traitå’Œæ‰€æœ‰æƒç³»ç»Ÿéƒ½éµå¾ªè¿™ä¸€åŸåˆ™ï¼Œé€šè¿‡ç¼–è¯‘æœŸè½¬æ¢å’Œä¼˜åŒ–ï¼Œç¡®ä¿æŠ½è±¡å±‚ä¸ä¼šå¼•å…¥è¿è¡Œæ—¶å¼€é”€ã€‚

æ³›å‹çš„å•æ€åŒ–å®ç°ã€traitçš„é™æ€åˆ†å‘ã€å†…è”ä¼˜åŒ–ç­‰æŠ€æœ¯ä½¿å¾—Rustä»£ç åœ¨æŠ½è±¡å±‚æ¬¡æé«˜çš„åŒæ—¶ï¼Œä¿æŒä¸æ‰‹å†™ç‰¹åŒ–ä»£ç ç›¸å½“çš„æ€§èƒ½ã€‚è¿™ä¸€åŸåˆ™ä½¿Rustæˆä¸ºå°‘æ•°èƒ½å¤ŸåŒæ—¶æä¾›é«˜çº§æŠ½è±¡å’Œåº•å±‚æ§åˆ¶çš„è¯­è¨€ï¼Œç‰¹åˆ«é€‚åˆç³»ç»Ÿç¼–ç¨‹ã€åµŒå…¥å¼å¼€å‘ç­‰å¯¹æ€§èƒ½æ•æ„Ÿçš„é¢†åŸŸã€‚

ç„¶è€Œï¼Œé›¶æˆæœ¬æŠ½è±¡å¹¶éæ²¡æœ‰ä»£ä»·â€”â€”å®ƒå°†æˆæœ¬ä»è¿è¡Œæ—¶è½¬ç§»åˆ°äº†ç¼–è¯‘æ—¶å’Œå¼€å‘è€…çš„è®¤çŸ¥è´Ÿæ‹…ä¸Šã€‚è¿™ç§æƒè¡¡åæ˜ äº†Rustå¯¹æ€§èƒ½å’Œå®‰å…¨çš„æ‰§ç€è¿½æ±‚ã€‚

### å®‰å…¨ä¸æ€§èƒ½çš„å¹³è¡¡

Rustçš„ç±»å‹ç³»ç»ŸåŠ›æ±‚åœ¨å®‰å…¨ä¿è¯å’Œæ€§èƒ½ä¼˜åŒ–ä¹‹é—´æ‰¾åˆ°ç†æƒ³å¹³è¡¡ç‚¹ã€‚ä¸€æ–¹é¢ï¼Œé€šè¿‡æ‰€æœ‰æƒã€å€Ÿç”¨æ£€æŸ¥ã€ç”Ÿå‘½å‘¨æœŸåˆ†æç­‰æœºåˆ¶ï¼ŒRuståœ¨ç¼–è¯‘æœŸé˜»æ­¢äº†å†…å­˜å®‰å…¨å’Œå¹¶å‘å®‰å…¨é—®é¢˜ï¼›å¦ä¸€æ–¹é¢ï¼Œé€šè¿‡ç²¾å¿ƒè®¾è®¡çš„æ³›å‹ã€traitç³»ç»Ÿå’Œä¼˜åŒ–ç¼–è¯‘å™¨ï¼ŒRustç¡®ä¿è¿™äº›å®‰å…¨ä¿è¯ä¸ä¼šæ˜¾è‘—å½±å“è¿è¡Œæ—¶æ€§èƒ½ã€‚

æ³›å‹ä¸å¤šæ€æœºåˆ¶åœ¨è¿™ç§å¹³è¡¡ä¸­æ‰®æ¼”å…³é”®è§’è‰²ï¼šå®ƒä»¬æä¾›äº†ç±»å‹å®‰å…¨çš„æŠ½è±¡èƒ½åŠ›ï¼ŒåŒæ—¶é€šè¿‡å•æ€åŒ–å’Œé™æ€åˆ†å‘ä¿æŒé«˜æ€§èƒ½ã€‚è¿™ç§å¹³è¡¡ä¸æ˜¯ç†æ‰€å½“ç„¶çš„â€”â€”å®ƒæ˜¯è¯­è¨€è®¾è®¡è€…ç»è¿‡å¤šå¹´è¿­ä»£å’Œæƒè¡¡çš„ç»“æœï¼Œä¹Ÿæ˜¯RuståŒºåˆ«äºå…¶ä»–ç³»ç»Ÿè¯­è¨€çš„æ ¸å¿ƒä¼˜åŠ¿ä¹‹ä¸€ã€‚

Rustè¯æ˜äº†å®‰å…¨æ€§å’Œé«˜æ€§èƒ½å¹¶éäº’æ–¥ç›®æ ‡ï¼Œé€šè¿‡åˆ›æ–°çš„ç±»å‹ç³»ç»Ÿè®¾è®¡ï¼Œå¯ä»¥åœ¨ä¸ç‰ºç‰²æ•ˆç‡çš„å‰æä¸‹æä¾›å¼ºå¤§çš„å®‰å…¨ä¿è¯ã€‚

## Rustç±»å‹ç³»ç»Ÿçš„åŸºçŸ³

### æ³›å‹åŸºç¡€è®¾è®¡

Rustçš„æ³›å‹ç³»ç»Ÿå…è®¸ç¼–å†™é€‚ç”¨äºå¤šç§æ•°æ®ç±»å‹çš„ä»£ç ï¼Œé¿å…äº†ä»£ç é‡å¤å¹¶æä¾›äº†ç±»å‹å®‰å…¨ä¿è¯ã€‚æ³›å‹é€šè¿‡ç±»å‹å‚æ•°åŒ–å®ç°ï¼Œç”¨å°–æ‹¬å·åŒ…å›´çš„å‚æ•°ï¼ˆå¦‚`<T>`ã€`<U>`ï¼‰ä»£è¡¨å¯æ›¿æ¢çš„ç±»å‹ã€‚

åŸºæœ¬æ³›å‹è¯­æ³•ç¤ºä¾‹ï¼š

```rust
// æ³›å‹å‡½æ•°
fn id<T>(x: T) -> T { x }

// æ³›å‹ç»“æ„ä½“
struct Pair<T, U> {
    first: T,
    second: U,
}

// æ³›å‹æšä¸¾
enum Either<L, R> {
    Left(L),
    Right(R),
}

// æ³›å‹å®ç°å—
impl<T, U> Pair<T, U> {
    fn new(first: T, second: U) -> Self {
        Pair { first, second }
    }
}
```

Rustæ³›å‹ç›¸æ¯”å…¶ä»–è¯­è¨€çš„ç‹¬ç‰¹ä¹‹å¤„åŒ…æ‹¬ï¼š

1. **ç¼–è¯‘æœŸæ£€æŸ¥**ï¼šæ‰€æœ‰æ³›å‹çº¦æŸåœ¨ç¼–è¯‘æœŸéªŒè¯ï¼Œç¡®ä¿ç±»å‹å®‰å…¨
2. **é›¶è¿è¡Œæ—¶å¼€é”€**ï¼šé€šè¿‡å•æ€åŒ–å®ç°ï¼Œæ²¡æœ‰è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯å¼€é”€
3. **æ˜¾å¼çº¦æŸ**ï¼šé€šè¿‡trait boundsæ˜ç¡®æŒ‡å®šç±»å‹å¿…é¡»æ»¡è¶³çš„è¡Œä¸º
4. **ç”Ÿå‘½å‘¨æœŸå‚æ•°**ï¼šå°†å¼•ç”¨ç”Ÿå‘½å‘¨æœŸä¹Ÿä½œä¸ºæ³›å‹å‚æ•°å¤„ç†

Rustæ³›å‹è®¾è®¡æ³¨é‡å®ç”¨æ€§å’Œå®‰å…¨æ€§ï¼Œè™½ç„¶æŸäº›ç†è®ºä¸Šçš„è¡¨è¾¾èƒ½åŠ›ï¼ˆå¦‚é«˜é˜¶ç±»å‹ï¼‰æœ‰æ‰€ç‰ºç‰²ï¼Œä½†è¿™ç§åŠ¡å®è®¾è®¡å¤§å¤§æé«˜äº†ç³»ç»Ÿä»£ç çš„å¯é æ€§ã€‚

### æ³›å‹çš„å•æ€åŒ–å®ç°æœºåˆ¶

Rustæ³›å‹é€šè¿‡"å•æ€åŒ–"ï¼ˆMonomorphizationï¼‰æœºåˆ¶å®ç°ï¼šç¼–è¯‘å™¨ä¸ºæ¯ä¸ªä½¿ç”¨çš„å…·ä½“ç±»å‹ç”Ÿæˆç‹¬ç«‹çš„ä»£ç å‰¯æœ¬ã€‚è¿™ä¸C++æ¨¡æ¿å±•å¼€ç±»ä¼¼ï¼Œä½†æ›´åŠ å¯æ§å’Œå®‰å…¨ã€‚

å•æ€åŒ–è¿‡ç¨‹ç¤ºä¾‹ï¼š

```rust
// æ³›å‹å‡½æ•°
fn min<T: PartialOrd>(a: T, b: T) -> T {
    if a < b { a } else { b }
}

// ä½¿ç”¨ä¸åŒç±»å‹è°ƒç”¨
let i = min(5, 10);         // ä½¿ç”¨i32
let f = min(5.5, 3.2);      // ä½¿ç”¨f64
```

ç¼–è¯‘åï¼Œä¸Šè¿°ä»£ç å¤§è‡´è½¬æ¢ä¸ºï¼š

```rust
// ä¸ºi32ç”Ÿæˆçš„ç‰¹åŒ–ç‰ˆæœ¬
fn min_i32(a: i32, b: i32) -> i32 {
    if a < b { a } else { b }
}

// ä¸ºf64ç”Ÿæˆçš„ç‰¹åŒ–ç‰ˆæœ¬
fn min_f64(a: f64, b: f64) -> f64 {
    if a < b { a } else { b }
}

let i = min_i32(5, 10);
let f = min_f64(5.5, 3.2);
```

å•æ€åŒ–æœºåˆ¶çš„å·¥ä½œåŸç†ï¼š

1. **ç±»å‹å‚æ•°æ›¿æ¢**ï¼šç¼–è¯‘å™¨è¯†åˆ«æ¯ä¸ªæ³›å‹å®ä¾‹åŒ–ä¸­ä½¿ç”¨çš„å…·ä½“ç±»å‹
2. **ä»£ç ç”Ÿæˆ**ï¼šä¸ºæ¯ç§ç±»å‹ç»„åˆåˆ›å»ºå‡½æ•°æˆ–ç»“æ„ä½“çš„ç‰¹åŒ–ç‰ˆæœ¬
3. **é™æ€åˆ†å‘**ï¼šè°ƒç”¨ç‚¹ç›´æ¥æ›¿æ¢ä¸ºç‰¹åŒ–ç‰ˆæœ¬çš„è°ƒç”¨
4. **ç±»å‹æ£€æŸ¥**ï¼šç¡®ä¿ç‰¹åŒ–ç‰ˆæœ¬æ»¡è¶³æ‰€æœ‰traitçº¦æŸ

å•æ€åŒ–å¸¦æ¥çš„ä¼˜åŠ¿å’ŒæŒ‘æˆ˜ï¼š

- **ä¼˜åŠ¿**ï¼šé™æ€åˆ†æ´¾ã€å†…è”ä¼˜åŒ–æœºä¼šã€æ¶ˆé™¤åŠ¨æ€æŸ¥æ‰¾å¼€é”€
- **æŒ‘æˆ˜**ï¼šäºŒè¿›åˆ¶æ–‡ä»¶è†¨èƒ€ã€ç¼–è¯‘æ—¶é—´å¢åŠ ã€é”™è¯¯ä¿¡æ¯å¤æ‚åŒ–

ç†è§£å•æ€åŒ–æœºåˆ¶å¯¹äºæŒæ¡Rustæ³›å‹ç³»ç»Ÿè‡³å…³é‡è¦ï¼Œå®ƒè§£é‡Šäº†ä¸ºä»€ä¹ˆRustæ³›å‹æ—¢å®‰å…¨åˆé«˜æ•ˆï¼Œä¹Ÿè¯´æ˜äº†æŸäº›åŠŸèƒ½è®¾è®¡å†³ç­–èƒŒåçš„åŸå› ã€‚

### Ad-hocå¤šæ€çš„å®ç°

Rusté€šè¿‡traitç³»ç»Ÿå®ç°"ad-hocå¤šæ€"ï¼Œè¿™ç§å¤šæ€å½¢å¼å…è®¸ä¸ºä¸åŒç±»å‹å®ç°ç›¸åŒçš„è¡Œä¸ºæ¥å£ï¼Œä»è€Œåœ¨ä¸å»ºç«‹ç»§æ‰¿å…³ç³»çš„æƒ…å†µä¸‹å…±äº«åŠŸèƒ½ã€‚è¿™ç§æ–¹æ³•ä¸ºé™æ€åˆ†å‘çš„åŸºç¡€ä¸Šæä¾›äº†è¡Œä¸ºå¤šæ€æ€§ã€‚

Ad-hocå¤šæ€çš„åŸºæœ¬å®ç°ï¼š

```rust
// å®šä¹‰è¡Œä¸ºæ¥å£
trait Drawable {
    fn draw(&self);
}

// ä¸ºä¸åŒç±»å‹å®ç°ç›¸åŒtrait
struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}

impl Drawable for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

// é€šè¿‡traitçº¦æŸå®ç°å¤šæ€å‡½æ•°
fn render<T: Drawable>(shape: T) {
    shape.draw();
}
```

Ad-hocå¤šæ€çš„å…³é”®ç‰¹æ€§ï¼š

1. **ç±»å‹ä¸è¡Œä¸ºåˆ†ç¦»**ï¼šç±»å‹å®šä¹‰å’Œè¡Œä¸ºå®ç°ç›¸äº’ç‹¬ç«‹
2. **æ¾è€¦åˆ**ï¼šå¯ä»¥ä¸ºä»»ä½•ç±»å‹ï¼ˆåŒ…æ‹¬å¤–éƒ¨åº“ç±»å‹ï¼‰å®ç°trait
3. **é™æ€åˆ†å‘**ï¼šé»˜è®¤é€šè¿‡å•æ€åŒ–å®ç°ï¼Œæ— è¿è¡Œæ—¶å¼€é”€
4. **ç»„åˆæ€§**ï¼šä¸€ä¸ªç±»å‹å¯å®ç°å¤šä¸ªtraitï¼Œä¸€ä¸ªtraitå¯è¢«å¤šä¸ªç±»å‹å®ç°

Rustçš„ad-hocå¤šæ€æ–¹å¼ä¸ä»…ä¿ç•™äº†é¢å‘å¯¹è±¡ç¼–ç¨‹å¤šæ€çš„çµæ´»æ€§ï¼Œè¿˜é€šè¿‡é™æ€åˆ†å‘æ¶ˆé™¤äº†è™šå‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼ŒåŒæ—¶é¿å…äº†ç»§æ‰¿å¸¦æ¥çš„é—®é¢˜ï¼ˆå¦‚è„†å¼±åŸºç±»ã€é’»çŸ³ç»§æ‰¿ç­‰ï¼‰ã€‚è¿™ç§è®¾è®¡ä½¿ä»£ç æ›´åŠ æ¨¡å—åŒ–å’Œå¯ç»´æŠ¤ã€‚

### å¤šæ€è¡¨è¾¾æ–¹å¼çš„æ¯”è¾ƒ

Rustæä¾›äº†å¤šç§å®ç°å¤šæ€çš„æ–¹å¼ï¼Œæ¯ç§æ–¹å¼éƒ½æœ‰ä¸åŒçš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å¤šæ€è¡¨è¾¾æ–¹å¼çš„æ¯”è¾ƒï¼š

-**1. åŸºäºæ³›å‹çš„é™æ€å¤šæ€**

- **å®ç°æ–¹å¼**ï¼šä½¿ç”¨æ³›å‹å‚æ•°å’Œtraitçº¦æŸ
- **åˆ†å‘æœºåˆ¶**ï¼šç¼–è¯‘æœŸå•æ€åŒ–ï¼Œé™æ€åˆ†å‘
- **æ€§èƒ½ç‰¹æ€§**ï¼šé›¶è¿è¡Œæ—¶å¼€é”€ï¼Œå¯èƒ½å¯¼è‡´ä»£ç è†¨èƒ€
- **ä½¿ç”¨åœºæ™¯**ï¼šæ€§èƒ½æ•æ„Ÿä»£ç ï¼Œç¼–è¯‘æ—¶ç±»å‹ç¡®å®šçš„æƒ…å†µ

```rust
fn process<T: Display>(item: T) {
    println!("{}", item);
}
```

-**2. åŸºäºtraitå¯¹è±¡çš„åŠ¨æ€å¤šæ€**

- **å®ç°æ–¹å¼**ï¼šä½¿ç”¨traitå¯¹è±¡ï¼ˆ`dyn Trait`ï¼‰
- **åˆ†å‘æœºåˆ¶**ï¼šé€šè¿‡è™šè¡¨ï¼ˆvtableï¼‰åŠ¨æ€åˆ†å‘
- **æ€§èƒ½ç‰¹æ€§**ï¼šæœ‰é—´æ¥è°ƒç”¨å¼€é”€ï¼Œä»£ç ä½“ç§¯è¾ƒå°
- **ä½¿ç”¨åœºæ™¯**ï¼šè¿è¡Œæ—¶ç±»å‹ä¸ç¡®å®šï¼Œéœ€è¦å¼‚æ„é›†åˆ

```rust
fn process(item: &dyn Display) {
    println!("{}", item);
}
```

-**3. åŸºäºæšä¸¾çš„æ ‡ç­¾è”åˆå¤šæ€**

- **å®ç°æ–¹å¼**ï¼šä½¿ç”¨å¸¦æœ‰ä¸åŒå˜ä½“çš„æšä¸¾
- **åˆ†å‘æœºåˆ¶**ï¼šé€šè¿‡æ¨¡å¼åŒ¹é…ï¼Œç¼–è¯‘æœŸç¡®å®š
- **æ€§èƒ½ç‰¹æ€§**ï¼šåŒ¹é…å¼€é”€ï¼Œæ•°æ®å¤§å°ä¸ºæœ€å¤§å˜ä½“
- **ä½¿ç”¨åœºæ™¯**ï¼šæœ‰é™ç§ç±»ã€ç›¸å…³ç±»å‹çš„å¤šæ€è¡¨è¾¾

```rust
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle(r) => std::f64::consts::PI * r * r,
            Shape::Rectangle(w, h) => w * h,
        }
    }
}
```

-**4. é™æ€ä¸åŠ¨æ€å¤šæ€çš„æ··åˆä½¿ç”¨**

- **å®ç°æ–¹å¼**ï¼šç»“åˆæ³›å‹å’Œtraitå¯¹è±¡
- **åˆ†å‘æœºåˆ¶**ï¼šæ··åˆé™æ€å’ŒåŠ¨æ€åˆ†å‘
- **æ€§èƒ½ç‰¹æ€§**ï¼šéƒ¨åˆ†ä»£ç é›¶å¼€é”€ï¼Œéƒ¨åˆ†æœ‰é—´æ¥è°ƒç”¨
- **ä½¿ç”¨åœºæ™¯**ï¼šéœ€è¦å¹³è¡¡çµæ´»æ€§å’Œæ€§èƒ½çš„å¤æ‚ç³»ç»Ÿ

```rust
struct Handler<T: Debug> {
    data: T,
    processor: Box<dyn Fn(&T)>,
}
```

å¤šæ€æ–¹å¼æ¯”è¾ƒè¡¨ï¼š

| ç‰¹æ€§ | æ³›å‹é™æ€å¤šæ€ | Traitå¯¹è±¡åŠ¨æ€å¤šæ€ | æšä¸¾æ ‡ç­¾è”åˆ |
|------|-------------|-----------------|------------|
| åˆ†å‘æ—¶æœº | ç¼–è¯‘æœŸ | è¿è¡Œæ—¶ | ç¼–è¯‘æœŸ |
| æ€§èƒ½å¼€é”€ | æä½ | æœ‰é—´æ¥å¼€é”€ | è¾ƒä½(åŒ¹é…å¼€é”€) |
| ä»£ç ä½“ç§¯ | å¯èƒ½è†¨èƒ€ | è¾ƒå° | ä¸­ç­‰ |
| ç±»å‹å®‰å…¨ | å®Œå…¨é™æ€æ£€æŸ¥ | åŠ¨æ€æ£€æŸ¥ | å®Œå…¨é™æ€æ£€æŸ¥ |
| å®ç°çµæ´»æ€§ | é«˜ï¼ˆä»»æ„ç±»å‹ï¼‰ | é«˜ï¼ˆå¯¹è±¡å®‰å…¨traitï¼‰ | ä¸­ï¼ˆæœ‰é™å˜ä½“ï¼‰ |
| å¼‚æ„é›†åˆ | ä¸æ”¯æŒ | æ”¯æŒ | æ”¯æŒ |

è¿™ç§å¤šæ ·åŒ–çš„å¤šæ€è¡¨è¾¾æ–¹å¼æ˜¯Rustç±»å‹ç³»ç»Ÿçš„å¼ºå¤§ä¹‹å¤„ï¼Œå…è®¸å¼€å‘è€…æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©æœ€é€‚åˆçš„æŠ½è±¡æ–¹å¼ï¼Œåœ¨è¡¨è¾¾åŠ›ã€å®‰å…¨æ€§å’Œæ€§èƒ½ä¹‹é—´æ‰¾åˆ°æ°å½“å¹³è¡¡ç‚¹ã€‚

## æ³›å‹çš„åº”ç”¨åœºæ™¯

### æ³›å‹å‡½æ•°ä¸æ–¹æ³•

æ³›å‹å‡½æ•°å’Œæ–¹æ³•æ˜¯Rustä¸­æœ€å¸¸è§çš„æ³›å‹åº”ç”¨åœºæ™¯ï¼Œå®ƒä»¬å…è®¸ç¼–å†™å¯å¤„ç†å¤šç§ç±»å‹çš„ä»£ç ï¼ŒåŒæ—¶ä¿æŒç±»å‹å®‰å…¨å’Œé«˜æ€§èƒ½ã€‚

**æ³›å‹å‡½æ•°çš„åŸºæœ¬ç»“æ„**ï¼š

```rust
fn function_name<T: Trait1 + Trait2, U: Trait3>(param1: T, param2: U) -> ReturnType 
where
    T: AdditionalTrait,
    U: OtherTrait,
{
    // å‡½æ•°ä½“
}
```

**æ³›å‹æ–¹æ³•çš„åŸºæœ¬ç»“æ„**ï¼š

```rust
impl<T, U> StructOrEnum<T, U> {
    fn method_name<V>(&self, param: V) -> ReturnType 
    where 
        V: SomeTrait,
    {
        // æ–¹æ³•ä½“
    }
}
```

**å®é™…åº”ç”¨ç¤ºä¾‹**ï¼š

1. **å¤šç±»å‹æ“ä½œå‡½æ•°**ï¼š

```rust
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a >= b { a } else { b }
}
```

1. **æ³›å‹è¿­ä»£å™¨é€‚é…å™¨**ï¼š

```rust
fn map_and_filter<T, U, F, P>(collection: Vec<T>, mapper: F, predicate: P) -> Vec<U>
where
    F: Fn(T) -> U,
    P: Fn(&U) -> bool,
{
    collection.into_iter()
             .map(mapper)
             .filter(predicate)
             .collect()
}
```

1. **è‡ªå¼•ç”¨æ³›å‹æ–¹æ³•**ï¼š

```rust
impl<T> Container<T> {
    fn get_or_insert_with<F>(&mut self, generator: F) -> &T
    where
        F: FnOnce() -> T,
    {
        if self.is_empty() {
            self.value = Some(generator());
        }
        self.value.as_ref().unwrap()
    }
}
```

**æ³›å‹å‡½æ•°è®¾è®¡è€ƒé‡**ï¼š

1. **çº¦æŸç²’åº¦**ï¼šæƒè¡¡çº¦æŸçš„å…·ä½“æ€§ä¸çµæ´»æ€§
   - è¿‡äºå®½æ¾çš„çº¦æŸå¯èƒ½å¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
   - è¿‡äºä¸¥æ ¼çš„çº¦æŸé™åˆ¶äº†å‡½æ•°çš„é€‚ç”¨èŒƒå›´

2. **æ˜¾å¼ä¸éšå¼ç±»å‹å‚æ•°**ï¼š
   - æœ‰æ—¶å¯ä»¥åˆ©ç”¨è¿”å›ç±»å‹æ¨å¯¼çœç•¥ç±»å‹å‚æ•°
   - å¤æ‚æƒ…å†µä¸‹æ˜¾å¼æŒ‡å®šå¯æé«˜æ¸…æ™°åº¦

3. **æ€§èƒ½è€ƒè™‘**ï¼š
   - æ¯ä¸ªç±»å‹å‚æ•°ç»„åˆç”Ÿæˆç‹¬ç«‹ä»£ç ï¼Œæ³¨æ„ç¼–è¯‘è†¨èƒ€
   - è€ƒè™‘ä½¿ç”¨traitå¯¹è±¡è¿›è¡Œç­–ç•¥æ€§åŠ¨æ€åˆ†å‘

4. **APIç¨³å®šæ€§**ï¼š
   - æ³›å‹å‚æ•°å’Œçº¦æŸæ˜¯APIå…¬å…±æ¥å£çš„ä¸€éƒ¨åˆ†
   - æ·»åŠ çº¦æŸæ˜¯ç ´åæ€§å˜æ›´ï¼Œç§»é™¤çº¦æŸé€šå¸¸å®‰å…¨

æ³›å‹å‡½æ•°å’Œæ–¹æ³•æ˜¯RustæŠ½è±¡æœºåˆ¶çš„åŸºç¡€ï¼ŒæŒæ¡å®ƒä»¬çš„è®¾è®¡åŸåˆ™å¯¹äºæ„å»ºçµæ´»ã€é«˜æ•ˆã€ç±»å‹å®‰å…¨çš„APIè‡³å…³é‡è¦ã€‚

### æ³›å‹ç»“æ„ä½“

æ³›å‹ç»“æ„ä½“å…è®¸å•ä¸€æ•°æ®ç»“æ„é€‚åº”å¤šç§ä¸åŒç±»å‹çš„æ•°æ®ï¼Œä¿æŒä»£ç çš„DRY(Don't Repeat Yourself)åŸåˆ™åŒæ—¶ä¸ç‰ºç‰²ç±»å‹å®‰å…¨ã€‚

**æ³›å‹ç»“æ„ä½“çš„åŸºæœ¬å½¢å¼**ï¼š

```rust
// å•å‚æ•°æ³›å‹ç»“æ„ä½“
struct Container<T> {
    data: T,
}

// å¤šå‚æ•°æ³›å‹ç»“æ„ä½“
struct KeyValue<K, V> {
    key: K,
    value: V,
}

// å¸¦æœ‰çº¦æŸçš„æ³›å‹ç»“æ„ä½“
struct Sortable<T: Ord> {
    elements: Vec<T>,
}

// å¸¦æœ‰ç”Ÿå‘½å‘¨æœŸçš„æ³›å‹ç»“æ„ä½“
struct Reference<'a, T> {
    reference: &'a T,
}
```

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

1. **æ•°æ®å®¹å™¨**ï¼š

```rust
struct Stack<T> {
    elements: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { elements: Vec::new() }
    }
    
    fn push(&mut self, item: T) {
        self.elements.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.elements.pop()
    }
}
```

1. **ç±»å‹çŠ¶æ€æ¨¡å¼**ï¼š

```rust
struct Uninitialized;
struct Initialized;

struct Connection<State> {
    address: String,
    port: u16,
    _state: PhantomData<State>,
}

impl Connection<Uninitialized> {
    fn new(address: String, port: u16) -> Self {
        Connection { 
            address, 
            port, 
            _state: PhantomData 
        }
    }
    
    fn connect(self) -> Result<Connection<Initialized>, Error> {
        // è¿æ¥é€»è¾‘...
        Ok(Connection { 
            address: self.address,
            port: self.port,
            _state: PhantomData 
        })
    }
}

impl Connection<Initialized> {
    fn send_data(&self, data: &[u8]) -> Result<(), Error> {
        // å‘é€æ•°æ®é€»è¾‘...
        Ok(())
    }
}
```

1. **å¤šç±»å‹èšåˆ**ï¼š

```rust
struct Either<L, R> {
    data: Result<L, R>,
}

impl<L, R> Either<L, R> {
    fn left(value: L) -> Self {
        Either { data: Ok(value) }
    }
    
    fn right(value: R) -> Self {
        Either { data: Err(value) }
    }
    
    fn is_left(&self) -> bool {
        self.data.is_ok()
    }
    
    fn is_right(&self) -> bool {
        self.data.is_err()
    }
}
```

**æ³›å‹ç»“æ„ä½“è®¾è®¡è€ƒé‡**ï¼š

1. **çº¦æŸä½ç½®é€‰æ‹©**ï¼š
   - ç»“æ„ä½“å®šä¹‰å¤„çš„çº¦æŸé€‚ç”¨äºæ‰€æœ‰å®ç°
   - æ–¹æ³•å®ç°å¤„çš„çº¦æŸåªé™åˆ¶ç‰¹å®šæ–¹æ³•

2. **éƒ¨åˆ†ç‰¹åŒ–å®ç°**ï¼š
   - å¯ä»¥ä¸ºç‰¹å®šç±»å‹å‚æ•°æä¾›ç‰¹æ®Šå®ç°

   ```rust
   impl<T> Container<T> { /* é€šç”¨å®ç° */ }
   impl Container<i32> { /* é’ˆå¯¹i32çš„ç‰¹åŒ–å®ç° */ }
   ```

3. **æ³›å‹å‚æ•°æ•°é‡**ï¼š
   - è¿‡å¤šå‚æ•°å¯èƒ½å¯¼è‡´ä½¿ç”¨å¤æ‚æ€§å’Œç†è§£å›°éš¾
   - è€ƒè™‘ä½¿ç”¨å…³è”ç±»å‹å‡å°‘å‚æ•°æ•°é‡

4. **é»˜è®¤ç±»å‹å‚æ•°**ï¼š
   - è‡ªRust 1.21èµ·æ”¯æŒç±»å‹å‚æ•°é»˜è®¤å€¼

   ```rust
   struct HashMap<K, V, S = RandomState> { /*...*/ }
   ```

æ³›å‹ç»“æ„ä½“æ˜¯æ„å»ºå¯å¤ç”¨ç»„ä»¶çš„é‡è¦å·¥å…·ï¼Œä¹Ÿæ˜¯è®¸å¤šæ ‡å‡†åº“å®¹å™¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„å®ç°åŸºç¡€ã€‚

### æ³›å‹æšä¸¾

æ³›å‹æšä¸¾æ˜¯Rustç±»å‹ç³»ç»Ÿä¸­æå…¶å¼ºå¤§çš„å·¥å…·ï¼Œå…è®¸è¡¨ç¤ºå¯èƒ½æ˜¯å¤šç§ç±»å‹ä¹‹ä¸€çš„å€¼ï¼ŒåŒæ—¶ä¿æŒå®Œå…¨ç±»å‹å®‰å…¨ã€‚å®ƒä»¬æ˜¯ä»£æ•°æ•°æ®ç±»å‹çš„æ ¸å¿ƒå®ç°ï¼Œä½¿Rustèƒ½å¤Ÿåœ¨ç±»å‹ç³»ç»Ÿå±‚é¢å¤„ç†å¤šç§å¯èƒ½æ€§ã€‚

**æ³›å‹æšä¸¾çš„åŸºæœ¬å½¢å¼**ï¼š

```rust
// å•å‚æ•°æ³›å‹æšä¸¾
enum Option<T> {
    Some(T),
    None,
}

// å¤šå‚æ•°æ³›å‹æšä¸¾
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// é€’å½’æ³›å‹æšä¸¾
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}
```

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

1. **å¯é€‰å€¼å¤„ç†**ï¼š

```rust
fn find_user(id: UserId) -> Option<User> {
    if database_has_user(id) {
        Some(get_user(id))
    } else {
        None
    }
}

// ä½¿ç”¨æ–¹
match find_user(id) {
    Some(user) => println!("Found user: {}", user.name),
    None => println!("User not found"),
}
```

1. **é”™è¯¯å¤„ç†**ï¼š

```rust
fn process_file(path: &str) -> Result<String, FileError> {
    let file = match File::open(path) {
        Ok(file) => file,
        Err(err) => return Err(FileError::OpenError(err)),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(err) => Err(FileError::ReadError(err)),
    }
}
```

1. **çŠ¶æ€æœºè¡¨ç¤º**ï¼š

```rust
enum ConnectionState<D> {
    Disconnected,
    Connecting,
    Connected(D),
    Failed(Error),
}

struct Connection<D> {
    state: ConnectionState<D>,
    address: String,
}
```

1. **å¼‚æ„é›†åˆ**ï¼š

```rust
enum Command {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

fn process_commands(commands: Vec<Command>) {
    for cmd in commands {
        match cmd {
            Command::Quit => return,
            Command::Move { x, y } => position.move_to(x, y),
            Command::Write(s) => println!("{}", s),
            Command::ChangeColor(r, g, b) => set_color(r, g, b),
        }
    }
}
```

**æ³›å‹æšä¸¾çš„ç‰¹æ€§ä¸ä¼˜åŠ¿**ï¼š

1. **ç±»å‹å±‚é¢çš„å¤šæ€**ï¼š
   - æä¾›ç¼–è¯‘æœŸç±»å‹å®‰å…¨çš„å¤šæ€è¡¨è¾¾
   - å¼ºåˆ¶å¤„ç†æ‰€æœ‰å¯èƒ½æƒ…å†µï¼Œé˜²æ­¢é—æ¼

2. **æ¨¡å¼åŒ¹é…èƒ½åŠ›**ï¼š
   - ä¸`match`è¡¨è¾¾å¼ç»“åˆä½¿ç”¨å¼ºå¤§
   - ç¼–è¯‘å™¨å¯éªŒè¯åŒ¹é…çš„å®Œæ•´æ€§

3. **ç©ºé—´æ•ˆç‡**ï¼š
   - å†…å­˜å¸ƒå±€ä¼˜åŒ–ï¼ˆæ ‡ç­¾+æœ€å¤§å˜ä½“å¤§å°ï¼‰
   - æ¯”ç±»å±‚æ¬¡ç»“æ„æ›´é«˜æ•ˆ

4. **ç±»å‹çŠ¶æ€ç¼–ç¨‹**ï¼š
   - å°†è¿è¡Œæ—¶çŠ¶æ€æå‡åˆ°ç±»å‹å±‚é¢
   - åœ¨ç¼–è¯‘æ—¶é˜²æ­¢éæ³•çŠ¶æ€è½¬æ¢

æ³›å‹æšä¸¾å±•ç¤ºäº†Rustç±»å‹ç³»ç»Ÿçš„è¡¨è¾¾èƒ½åŠ›ï¼Œå®ƒä»¬ç‰¹åˆ«é€‚åˆè¡¨ç¤ºå…·æœ‰å¤šç§å¯èƒ½æ€§çš„æ•°æ®ï¼Œæä¾›äº†æ¯”ä¼ ç»Ÿé¢å‘å¯¹è±¡å¤šæ€æ›´å®‰å…¨ã€æ›´é«˜æ•ˆçš„æŠ½è±¡æœºåˆ¶ã€‚

### é›†åˆç±»å‹ä¸­çš„æ³›å‹åº”ç”¨

Rustæ ‡å‡†åº“ä¸­çš„é›†åˆç±»å‹å¹¿æ³›åº”ç”¨äº†æ³›å‹ï¼Œè¿™ä½¿å®ƒä»¬èƒ½å¤Ÿå­˜å‚¨ä»»æ„ç±»å‹çš„æ•°æ®ï¼ŒåŒæ—¶ä¿æŒç±»å‹å®‰å…¨å’Œé«˜æ€§èƒ½ã€‚é›†åˆç±»å‹çš„è®¾è®¡å±•ç¤ºäº†æ³›å‹å’Œtraitç³»ç»Ÿå¦‚ä½•ååŒå·¥ä½œï¼Œæ„å»ºçµæ´»è€Œå¼ºå¤§çš„é€šç”¨ç»„ä»¶ã€‚

**ä¸»è¦é›†åˆç±»å‹çš„æ³›å‹ç»“æ„**ï¼š

1. **å‘é‡å’Œæ•°ç»„**ï¼š
   - `Vec<T>`: å¯å¢é•¿çš„è¿ç»­å­˜å‚¨åºåˆ—
   - `VecDeque<T>`: åŸºäºç¯å½¢ç¼“å†²åŒºçš„åŒç«¯é˜Ÿåˆ—
   - `[T; N]`: å›ºå®šå¤§å°æ•°ç»„ï¼ˆNæ˜¯constæ³›å‹å‚æ•°ï¼‰

2. **å…³è”å®¹å™¨**ï¼š
   - `HashMap<K, V, S = RandomState>`: å“ˆå¸Œæ˜ å°„
   - `BTreeMap<K, V>`: æœ‰åºæ˜ å°„ï¼ˆåŸºäºBæ ‘ï¼‰
   - `HashSet<T, S = RandomState>`: å“ˆå¸Œé›†åˆ
   - `BTreeSet<T>`: æœ‰åºé›†åˆ

3. **å…¶ä»–é›†åˆ**ï¼š
   - `LinkedList<T>`: åŒå‘é“¾è¡¨
   - `BinaryHeap<T>`: åŸºäºäºŒå‰å †çš„ä¼˜å…ˆé˜Ÿåˆ—

**é›†åˆç±»å‹é€šç”¨æ³›å‹æ¥å£æ¨¡å¼**ï¼š

Rusté›†åˆç±»å‹é€šå¸¸å®ç°äº†ä¸€å¥—å…±åŒçš„traitï¼Œå½¢æˆäº†ä¸€è‡´çš„æ¥å£æ¨¡å¼ï¼š

```rust
// åˆ›å»ºæ¥å£
impl<T> Collection<T> {
    fn new() -> Self;                // åˆ›å»ºç©ºé›†åˆ
    fn with_capacity(capacity: usize) -> Self;  // é¢„åˆ†é…å®¹é‡
}

// è½¬æ¢æ¥å£
impl<T> From<Vec<T>> for Collection<T>;  // ä»å…¶ä»–é›†åˆåˆ›å»º
impl<T> IntoIterator for Collection<T>;  // è½¬ä¸ºè¿­ä»£å™¨

// æŸ¥è¯¢æ¥å£
impl<T> Collection<T> {
    fn len(&self) -> usize;          // è·å–é•¿åº¦
    fn is_empty(&self) -> bool;      // æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    fn contains(&self, item: &T) -> bool where T: PartialEq;  // åŒ…å«æ£€æŸ¥
}

// ä¿®æ”¹æ¥å£
impl<T> Collection<T> {
    fn insert(&mut self, value: T);  // æ’å…¥å…ƒç´ 
    fn remove(&mut self, value: &T) -> bool where T: PartialEq;  // ç§»é™¤å…ƒç´ 
    fn clear(&mut self);             // æ¸…ç©ºé›†åˆ
}

// æ‰©å±•æ¥å£
impl<T> Extend<T> for Collection<T>;  // æ‰©å±•é›†åˆ
```

**æ³›å‹çº¦æŸåœ¨é›†åˆç±»å‹ä¸­çš„åº”ç”¨**ï¼š

é›†åˆç±»å‹ä¼šæ ¹æ®æ“ä½œéœ€æ±‚ä¸ºæ³›å‹å‚æ•°æ·»åŠ ä¸åŒçº¦æŸï¼š

```rust
// HashMapè¦æ±‚é”®å¯å“ˆå¸Œå’Œç›¸ç­‰æ¯”è¾ƒ
impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {
    fn new() -> Self { /*...*/ }
}

// BTreeMapè¦æ±‚é”®å¯æ’åº
impl<K: Ord, V> BTreeMap<K, V> {
    fn new() -> Self { /*...*/ }
}

// ä¸åŒæ“ä½œå¯èƒ½æ·»åŠ é¢å¤–çº¦æŸ
impl<T> Vec<T> {
    fn contains(&self, x: &T) -> bool 
    where T: PartialEq {
        // éœ€è¦å…ƒç´ å¯æ¯”è¾ƒ
    }
    
    fn binary_search(&self, x: &T) -> Result<usize, usize>
    where T: Ord {
        // éœ€è¦å…ƒç´ å¯æ’åº
    }
}
```

**æ³›å‹é›†åˆçš„é«˜çº§ç”¨ä¾‹**ï¼š

1. **å¤åˆé›†åˆç±»å‹**ï¼š

```rust
// æ„å»ºå›¾ç»“æ„
type Graph<N, E> = HashMap<N, Vec<(N, E)>>;

// ç¼“å­˜ç»“æ„
struct Cache<K, V> {
    storage: HashMap<K, (V, Instant)>,
    ttl: Duration,
}
```

1. **ç‰¹åŒ–é›†åˆè¡Œä¸º**ï¼š

```rust
// å­—ç¬¦ä¸²ç‰¹åŒ–å‘é‡
struct StringVec(Vec<String>);

impl StringVec {
    fn join(&self, separator: &str) -> String {
        self.0.join(separator)
    }
}
```

1. **å¤šç±»å‹å®¹å™¨**ï¼š

```rust
enum Value {
    Int(i64),
    Float(f64),
    Text(String),
    Boolean(bool),
}

type Record = HashMap<String, Value>;
```

é›†åˆç±»å‹å±•ç¤ºäº†Rustæ³›å‹ç³»ç»Ÿçš„å®é™…åº”ç”¨ï¼Œé€šè¿‡ç»Ÿä¸€çš„æ³›å‹æ¥å£å’Œtraitè¾¹ç•Œï¼ŒRustæä¾›äº†ç±»å‹å®‰å…¨ä¸”é«˜æ€§èƒ½çš„æ•°æ®ç»“æ„ï¼Œæ˜¯æ ‡å‡†åº“ä¸­æœ€å¹¿æ³›ä½¿ç”¨æ³›å‹çš„éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯å­¦ä¹ æ³›å‹å®é™…åº”ç”¨çš„é‡è¦èµ„æºã€‚

### é›¶å¤§å°ç±»å‹ä¸æ ‡è®°ç±»å‹

é›¶å¤§å°ç±»å‹(Zero-Sized Types, ZST)å’Œæ ‡è®°ç±»å‹æ˜¯Rustç±»å‹ç³»ç»Ÿçš„ç‹¬ç‰¹ç‰¹æ€§ï¼Œå®ƒä»¬åœ¨æ³›å‹ç¼–ç¨‹ä¸­æœ‰ç€é‡è¦åº”ç”¨ã€‚è¿™äº›ç±»å‹å ç”¨é›¶å­—èŠ‚å†…å­˜ï¼Œä½†å¯ä»¥æºå¸¦ä¸°å¯Œçš„ç±»å‹ä¿¡æ¯ï¼Œç”¨äºåœ¨ç¼–è¯‘æœŸå¼ºåˆ¶çº¦æŸå’Œä¼˜åŒ–ã€‚

**é›¶å¤§å°ç±»å‹çš„åŸºæœ¬å½¢å¼**ï¼š

```rust
// å•å…ƒç»“æ„ä½“
struct Empty;

// æ— å­—æ®µæšä¸¾
enum Void {}

// é›¶å¤§å°æ³›å‹ç»“æ„ä½“
struct ZeroSized<T> {
    _marker: PhantomData<T>,
}
```

**æ ‡è®°ç±»å‹çš„åº”ç”¨åœºæ™¯**ï¼š

1. **ç±»å‹çŠ¶æ€æ¨¡å¼**ï¼š

```rust
// çŠ¶æ€æ ‡è®°ç±»å‹
struct Uninitialized;
struct Initialized;

// å°†è¿è¡Œæ—¶çŠ¶æ€æå‡åˆ°ç±»å‹å±‚é¢
struct Connection<State> {
    socket: TcpStream,
    _state: PhantomData<State>,
}

impl Connection<Uninitialized> {
    fn new(address: &str) -> io::Result<Self> {
        let socket = TcpStream::connect(address)?;
        Ok(Connection {
            socket,
            _state: PhantomData,
        })
    }
    
    fn authenticate(self, credentials: Credentials) -> Result<Connection<Initialized>, AuthError> {
        // èº«ä»½éªŒè¯é€»è¾‘...
        Ok(Connection {
            socket: self.socket,
            _state: PhantomData,
        })
    }
}

impl Connection<Initialized> {
    // åªæœ‰ç»è¿‡è®¤è¯çš„è¿æ¥æ‰èƒ½å‘é€æ•°æ®
    fn send_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.socket.write_all(data)
    }
}
```

1. **æ‰€æœ‰æƒæ ‡è®°**ï¼š

```rust
struct Owned;
struct Borrowed;

struct Container<T, State> {
    data: Vec

```rust
struct Container<T, State> {
    data: Vec<T>,
    _marker: PhantomData<State>,
}

impl<T> Container<T, Owned> {
    fn new(data: Vec<T>) -> Self {
        Container { data, _marker: PhantomData }
    }
    
    fn modify(&mut self, index: usize, value: T) -> bool {
        if index < self.data.len() {
            self.data[index] = value;
            true
        } else {
            false
        }
    }
}

impl<T> Container<T, Borrowed> {
    fn from_slice(slice: &[T]) -> Self 
    where T: Clone {
        Container { 
            data: slice.to_vec(), 
            _marker: PhantomData 
        }
    }
    
    // ä¸å…è®¸ä¿®æ”¹æ“ä½œ
    fn get(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}
```

1. **ç±»å‹çº§åˆ«çº¦æŸ**ï¼š

```rust
// æ ‡è®° Send/Sync ç‰¹æ€§
struct ThreadSafe;
struct NotThreadSafe;

struct GenericWrapper<T, ThreadSafety> {
    value: T,
    _marker: PhantomData<ThreadSafety>,
}

// åªæœ‰æ ‡è®°ä¸º ThreadSafe çš„åŒ…è£…å™¨æ‰å®ç° Send
impl<T: Send> Send for GenericWrapper<T, ThreadSafe> {}

// å·¥å‚å‡½æ•°ç¡®ä¿æ­£ç¡®çš„æ ‡è®°
fn create_thread_safe<T: Send>(value: T) -> GenericWrapper<T, ThreadSafe> {
    GenericWrapper { 
        value, 
        _marker: PhantomData 
    }
}

fn create_not_thread_safe<T>(value: T) -> GenericWrapper<T, NotThreadSafe> {
    GenericWrapper { 
        value, 
        _marker: PhantomData 
    }
}
```

**PhantomDataçš„é«˜çº§ç”¨æ³•**ï¼š

`PhantomData<T>` æ˜¯Rustä¸­ç”¨äºæ ‡è®°ç±»å‹å‚æ•°çš„é‡è¦é›¶å¤§å°ç±»å‹ï¼Œæœ‰å¤šç§ç”¨é€”ï¼š

```rust
// 1. æ ‡è®°ç±»å‹å‚æ•°çš„ä½¿ç”¨
struct Deserializer<T> {
    _marker: PhantomData<fn() -> T>,  // è¡¨æ˜Tåªç”¨äºè¾“å‡º
}

// 2. æ ‡è®°ç”Ÿå‘½å‘¨æœŸå…³ç³»
struct LifetimeHolder<'a, T: 'a> {
    _marker: PhantomData<&'a T>,  // è¡¨æ˜æŒæœ‰Tçš„å¼•ç”¨
}

// 3. è¡¨ç¤ºæ‰€æœ‰æƒå…³ç³»
struct OwnedPointer<T> {
    ptr: *const T,
    _marker: PhantomData<T>,  // è¡¨æ˜æ‹¥æœ‰Tç±»å‹çš„æ•°æ®
}

// 4. å¤åˆæ ‡è®°
struct ComplexMarker<'a, T: 'a, U> {
    _marker: PhantomData<(&'a T, *const U)>,  // æŒæœ‰Tå¼•ç”¨ï¼Œæ‹¥æœ‰UæŒ‡é’ˆ
}
```

**é›¶å¤§å°ç±»å‹çš„ä¼˜åŒ–**ï¼š

é›¶å¤§å°ç±»å‹åœ¨ç¼–è¯‘åä¸å ç”¨å®é™…å†…å­˜ï¼Œç¼–è¯‘å™¨ä¼šä¼˜åŒ–æ‰å®ƒä»¬çš„å­˜å‚¨ç©ºé—´ï¼ŒåŒæ—¶ä¿ç•™ç±»å‹ä¿¡æ¯ï¼š

```rust
struct Empty;
fn main() {
    // åˆ›å»ºæ•°ç™¾ä¸‡ä¸ªå®ä¾‹ä½†ä¸å ç”¨é¢å¤–å†…å­˜
    let million_empties: Vec<Empty> = (0..1_000_000).map(|_| Empty).collect();
    println!("Vector length: {}", million_empties.len());
    // ç¼–è¯‘å™¨ä¼˜åŒ–ï¼šVec<Empty>åªå­˜å‚¨é•¿åº¦å’Œå®¹é‡ï¼Œä¸åˆ†é…å®é™…å­˜å‚¨ç©ºé—´
}
```

é›¶å¤§å°ç±»å‹å’Œæ ‡è®°ç±»å‹å±•ç¤ºäº†Rustç±»å‹ç³»ç»Ÿçš„å¼ºå¤§è¡¨è¾¾èƒ½åŠ›ï¼Œå®ƒä»¬å¯ä»¥åœ¨ä¸å¢åŠ è¿è¡Œæ—¶å¼€é”€çš„æƒ…å†µä¸‹ï¼Œåœ¨ç¼–è¯‘æœŸæä¾›å¼ºå¤§çš„ç±»å‹çº¦æŸå’Œå®‰å…¨ä¿è¯ï¼Œæ˜¯é«˜çº§æ³›å‹ç¼–ç¨‹çš„é‡è¦å·¥å…·ã€‚

## traitç³»ç»Ÿæ·±å…¥åˆ†æ

### traitä½œä¸ºæ¥å£æŠ½è±¡

traitæ˜¯Rustç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒæŠ½è±¡æœºåˆ¶ï¼Œå®ƒå®šä¹‰äº†ç±»å‹å¯ä»¥å®ç°çš„è¡Œä¸ºé›†åˆï¼Œç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„æ¥å£æˆ–æŠ½è±¡ç±»ï¼Œä½†æœ‰æ›´å¤šå¼ºå¤§ç‰¹æ€§ã€‚traitç³»ç»Ÿæ˜¯Rustå®ç°å¤šæ€å’Œä»£ç æŠ½è±¡çš„ä¸»è¦é€”å¾„ã€‚

**traitçš„åŸºæœ¬å®šä¹‰ä¸å®ç°**ï¼š

```rust
// å®šä¹‰trait
trait Display {
    // å¿…é¡»å®ç°çš„æ–¹æ³•
    fn display(&self) -> String;
    
    // å¸¦æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•
    fn show(&self) {
        println!("{}", self.display());
    }
    
    // å…³è”å¸¸é‡
    const NAME: &'static str = "Displayable";
    
    // å…³è”ç±»å‹
    type Output;
    
    // å…³è”å‡½æ•°ï¼ˆé™æ€æ–¹æ³•ï¼‰
    fn create(data: &str) -> Self::Output;
}

// ä¸ºç±»å‹å®ç°trait
struct Person {
    name: String,
    age: u32,
}

impl Display for Person {
    fn display(&self) -> String {
        format!("Person(name={}, age={})", self.name, self.age)
    }
    
    // è¦†ç›–é»˜è®¤å®ç°
    fn show(&self) {
        println!("ğŸ‘¤ {}", self.display());
    }
    
    // æŒ‡å®šå…³è”ç±»å‹
    type Output = Self;
    
    // å®ç°å…³è”å‡½æ•°
    fn create(data: &str) -> Self {
        let parts: Vec<&str> = data.split(',').collect();
        Person {
            name: parts[0].to_string(),
            age: parts[1].parse().unwrap_or(0),
        }
    }
}
```

**traitçš„å…³é”®ç‰¹æ€§**ï¼š

1. **æ¥å£å®šä¹‰**ï¼š
   - å®šä¹‰ç±»å‹å¿…é¡»å®ç°çš„æ–¹æ³•ç­¾å
   - å¯ä»¥åŒ…å«é»˜è®¤å®ç°ã€å…³è”ç±»å‹å’Œå…³è”å¸¸é‡

2. **å¼€æ”¾æ€§**ï¼š
   - å¯ä»¥ä¸ºä»»ä½•ç±»å‹å®ç°ä»»ä½•traitï¼ˆå—å­¤å„¿è§„åˆ™çº¦æŸï¼‰
   - å…è®¸ä¸ºç¬¬ä¸‰æ–¹ç±»å‹å®ç°è‡ªå®šä¹‰trait

3. **ç»„åˆä¸ç»§æ‰¿**ï¼š
   - æ”¯æŒtraitç»§æ‰¿ï¼ˆsupertraitï¼‰
   - é¼“åŠ±ç»„åˆè€Œéç»§æ‰¿å±‚æ¬¡ç»“æ„

4. **å¤šæ€æ€§**ï¼š
   - æ”¯æŒé™æ€å¤šæ€ï¼ˆé€šè¿‡æ³›å‹ï¼‰
   - æ”¯æŒåŠ¨æ€å¤šæ€ï¼ˆé€šè¿‡traitå¯¹è±¡ï¼‰

**traitçš„é«˜çº§åº”ç”¨**ï¼š

1. **è¿ç®—ç¬¦é‡è½½**ï¼š

```rust
use std::ops::Add;

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self;
    
    fn add(self, other: Self) -> Self::Output {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// ä½¿ç”¨ï¼šlet sum = point1 + point2;
```

1. **æ ‡å‡†åº“traitåˆ©ç”¨**ï¼š

```rust
// å®ç°è¿­ä»£å™¨
struct Counter {
    count: usize,
    max: usize,
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

// ä½¿ç”¨ï¼šfor i in Counter { ... }
```

1. **ç±»å‹è½¬æ¢trait**ï¼š

```rust
impl From<&str> for Person {
    fn from(s: &str) -> Self {
        let parts: Vec<&str> = s.split(',').collect();
        Person {
            name: parts[0].to_string(),
            age: parts[1].parse().unwrap_or(0),
        }
    }
}

// ä½¿ç”¨ï¼šlet person: Person = "John,30".into();
```

**traitä¸å…¶ä»–è¯­è¨€æ¥å£æœºåˆ¶å¯¹æ¯”**ï¼š

| ç‰¹æ€§ | Rust Trait | Java Interface | C++ Abstract Class | TypeScript Interface |
|------|------------|----------------|-------------------|---------------------|
| é»˜è®¤å®ç° | æ”¯æŒ | Java 8+ æ”¯æŒ | æ”¯æŒ | ä¸æ”¯æŒ |
| å…³è”ç±»å‹/å‡½æ•° | æ”¯æŒ | ä¸æ”¯æŒ | æ”¯æŒ | ä¸æ”¯æŒ |
| ç¬¬ä¸‰æ–¹ç±»å‹å®ç° | æ”¯æŒ(æœ‰é™åˆ¶) | ä¸æ”¯æŒ | ä¸æ”¯æŒ | æ”¯æŒ(æœ‰é™åˆ¶) |
| å¤šé‡å®ç° | æ”¯æŒ | æ”¯æŒ | æ”¯æŒ(å¤šé‡ç»§æ‰¿) | æ”¯æŒ |
| è¿è¡Œæ—¶è¡¨ç¤º | å¯é€‰ | å¿…éœ€ | å¿…éœ€ | ç¼–è¯‘æ—¶æ“¦é™¤ |
| é™æ€åˆ†å‘èƒ½åŠ› | ä¼˜ç§€ | æœ‰é™ | æœ‰é™ | æœ‰é™ |

traitç³»ç»Ÿæ˜¯Rustä»£ç æŠ½è±¡å’Œå¤šæ€æ€§çš„æ”¯æŸ±ï¼Œå®ƒå¹³è¡¡äº†çµæ´»æ€§ã€å®‰å…¨æ€§å’Œæ€§èƒ½ï¼Œä½¿å¼€å‘è€…èƒ½å¤Ÿç¼–å†™é«˜åº¦æŠ½è±¡ä½†ä»ç„¶é«˜æ•ˆçš„ä»£ç ã€‚

### traitçº¦æŸä¸è¾¹ç•Œ

traitçº¦æŸï¼ˆä¹Ÿç§°ä¸ºtraitè¾¹ç•Œï¼‰æ˜¯Rustæ³›å‹ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹æ€§ï¼Œå®ƒå…è®¸å¼€å‘è€…æŒ‡å®šæ³›å‹ç±»å‹å¿…é¡»æ»¡è¶³çš„è¡Œä¸ºè¦æ±‚ã€‚traitçº¦æŸä¿è¯äº†æ³›å‹ä»£ç çš„ç±»å‹å®‰å…¨ï¼ŒåŒæ—¶æä¾›äº†ç¼–è¯‘æ—¶éªŒè¯ã€‚

**traitçº¦æŸçš„åŸºæœ¬è¯­æ³•**ï¼š

```rust
// åŸºæœ¬çº¦æŸ
fn print<T: Display>(value: T) {
    println!("{}", value);
}

// å¤šé‡çº¦æŸ
fn process<T: Clone + Debug>(value: T) {
    let copy = value.clone();
    println!("{:?}", copy);
}

// whereå­å¥çº¦æŸ
fn complex_function<T, U>(t: T, u: U) -> Vec<String>
where
    T: Display + Clone,
    U: Debug + PartialEq + From<T>,
{
    // å‡½æ•°å®ç°...
}

// å…³è”ç±»å‹çº¦æŸ
fn collect<I, E>(iter: I) -> Result<Vec<I::Item>, E>
where
    I: Iterator,
    E: From<std::io::Error>,
{
    // å‡½æ•°å®ç°...
}
```

**é«˜çº§çº¦æŸæ¨¡å¼**ï¼š

1. **æ¡ä»¶å®ç°ï¼ˆimpl Trait for Type where...ï¼‰**ï¼š

```rust
// åªä¸ºå®ç°äº†Debugçš„ç±»å‹å®ç°Display
impl<T> Display for Wrapper<T>
where
    T: Debug,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "Wrapper({:?})", self.0)
    }
}
```

1. **å¦å®šçº¦æŸ**ï¼ˆå®éªŒæ€§ï¼‰ï¼š

```rust
// æ³›å‹å‚æ•°Tä¸èƒ½æ˜¯i32ç±»å‹
fn not_for_i32<T>() 
where 
    T: Not<i32>, 
{
    // å‡½æ•°å®ç°...
}
```

1. **ç”Ÿå‘½å‘¨æœŸçº¦æŸ**ï¼š

```rust
// Tå¿…é¡»æ¯”ç”Ÿå‘½å‘¨æœŸ'aå­˜æ´»å¾—æ›´ä¹…
fn process<'a, T: 'a>(value: &'a T) {
    // å‡½æ•°å®ç°...
}
```

1. **å…³è”ç±»å‹çº¦æŸ**ï¼š

```rust
fn sum<I>(iter: I) -> I::Item
where
    I: Iterator,
    I::Item: Add<Output = I::Item> + Default,
{
    iter.fold(I::Item::default(), |a, b| a + b)
}
```

**traitçº¦æŸä¸é™æ€åˆ†å‘**ï¼š

traitçº¦æŸåœ¨æ³›å‹ä»£ç ä¸­å¯ç”¨é™æ€åˆ†å‘ï¼Œç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆç‰¹å®šç‰ˆæœ¬çš„å‡½æ•°ï¼š

```rust
// å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°
fn double<T: Add<Output = T> + Copy>(x: T) -> T {
    x + x
}

// ä½¿ç”¨ä¸åŒç±»å‹è°ƒç”¨
let a = double(5);      // T = i32
let b = double(3.14);   // T = f64

// ç¼–è¯‘å™¨ç”Ÿæˆç±»ä¼¼äºï¼š
fn double_i32(x: i32) -> i32 { x + x }
fn double_f64(x: f64) -> f64 { x + x }
```

è¿™ç§é™æ€åˆ†å‘æ¶ˆé™¤äº†è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥çš„å¼€é”€ï¼ŒåŒæ—¶ä¿æŒæ³›å‹ä»£ç çš„çµæ´»æ€§ã€‚

**çº¦æŸçš„é€‰æ‹©ç­–ç•¥**ï¼š

1. **æœ€å°çº¦æŸåŸåˆ™**ï¼š
   - åªè¦æ±‚ç¡®å®éœ€è¦çš„åŠŸèƒ½
   - å¢åŠ ä»£ç é‡ç”¨å¯èƒ½æ€§ï¼Œå‡å°‘ä½¿ç”¨é™åˆ¶

2. **ç»„åˆç°æœ‰trait**ï¼š
   - ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“å·²æœ‰trait
   - ä¸ºç‰¹æ®Šéœ€æ±‚åˆ›å»ºè‡ªå®šä¹‰trait

3. **æƒè¡¡æ˜ç¡®æ€§ä¸çµæ´»æ€§**ï¼š
   - è¿‡äºå®½æ¾çš„çº¦æŸå¯èƒ½å¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
   - è¿‡äºä¸¥æ ¼çš„çº¦æŸé™åˆ¶ä»£ç é€‚ç”¨èŒƒå›´

4. **æ–‡æ¡£æ¸…æ™°è®°å½•çº¦æŸç†ç”±**ï¼š
   - å¸®åŠ©ç”¨æˆ·ç†è§£ä¸ºä½•éœ€è¦ç‰¹å®šçº¦æŸ
   - ä¾¿äºæœªæ¥ä»£ç ç»´æŠ¤å’Œä¼˜åŒ–

traitçº¦æŸæ˜¯Rustç±»å‹ç³»ç»Ÿè¡¨è¾¾åŠ›å’Œå®‰å…¨æ€§çš„æ ¸å¿ƒï¼Œå®ƒä»¬ä½¿ç¼–è¯‘å™¨èƒ½å¤Ÿåœ¨ç¼–è¯‘æ—¶éªŒè¯ç±»å‹è¡Œä¸ºï¼Œæ¶ˆé™¤æ•´ç±»è¿è¡Œæ—¶é”™è¯¯ï¼ŒåŒæ—¶ä¿æŒä»£ç çš„é€šç”¨æ€§å’Œå¯é‡ç”¨æ€§ã€‚åœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œé€‰æ‹©é€‚å½“çš„traitçº¦æŸæ˜¯ç¼–å†™é«˜è´¨é‡æ³›å‹ä»£ç çš„å…³é”®éƒ¨åˆ†ã€‚

### traitå¯¹è±¡ä¸åŠ¨æ€åˆ†å‘

è™½ç„¶Rustä¸»è¦ä¾èµ–é™æ€åˆ†å‘æ¥å®ç°å¤šæ€ï¼Œä½†ä¹Ÿæä¾›äº†traitå¯¹è±¡æ¥æ”¯æŒåŠ¨æ€åˆ†å‘ã€‚traitå¯¹è±¡å…è®¸åœ¨è¿è¡Œæ—¶ç¡®å®šå…·ä½“ç±»å‹ï¼Œä»¥æ”¯æŒå¼‚æ„é›†åˆå’Œæ’ä»¶ç³»ç»Ÿç­‰åœºæ™¯ã€‚

**traitå¯¹è±¡çš„åŸºæœ¬è¯­æ³•**ï¼š

```rust
// ä½¿ç”¨ dyn å…³é”®å­—åˆ›å»º trait å¯¹è±¡
fn process(item: &dyn Display) {
    println!("{}", item);
}

// åœ¨ Box ä¸­ä½¿ç”¨ trait å¯¹è±¡ï¼ˆå †åˆ†é…ï¼‰
fn store() -> Box<dyn Display> {
    Box::new("Hello, trait objects!")
}

// å…¶ä»–æ™ºèƒ½æŒ‡é’ˆä¸­çš„ trait å¯¹è±¡
fn shared() -> Rc<dyn Display> {
    Rc::new("Shared trait object")
}

// trait å¯¹è±¡æ•°ç»„
fn process_many(items: &[Box<dyn Display>]) {
    for item in items {
        println!("{}", item);
    }
}
```

**traitå¯¹è±¡çš„å†…éƒ¨è¡¨ç¤º**ï¼š

traitå¯¹è±¡åœ¨å†…å­˜ä¸­ç”±ä¸¤ä¸ªæŒ‡é’ˆç»„æˆï¼š

1. **æ•°æ®æŒ‡é’ˆ**ï¼šæŒ‡å‘å®é™…æ•°æ®çš„æŒ‡é’ˆ
2. **è™šè¡¨æŒ‡é’ˆ**ï¼šæŒ‡å‘åŒ…å«å®ç°æ–¹æ³•æŒ‡é’ˆçš„è™šè¡¨ï¼ˆvtableï¼‰

```text
+----------------+     +----------------+
| æ•°æ®æŒ‡é’ˆ       | --> | å…·ä½“ç±»å‹çš„æ•°æ® |
+----------------+     +----------------+
| è™šè¡¨æŒ‡é’ˆ       | --> +----------------+
+----------------+     | ç±»å‹å°ºå¯¸/å¯¹é½  |
                       +----------------+
                       | drop å‡½æ•°æŒ‡é’ˆ  |
                       +----------------+
                       | æ–¹æ³•1å‡½æ•°æŒ‡é’ˆ  |
                       +----------------+
                       | æ–¹æ³•2å‡½æ•°æŒ‡é’ˆ  |
                       +----------------+
                       | ...            |
                       +----------------+
```

**å¯¹è±¡å®‰å…¨æ€§**ï¼š

ä¸æ˜¯æ‰€æœ‰traitéƒ½å¯ä»¥ç”¨ä½œtraitå¯¹è±¡ã€‚ä¸€ä¸ªtraitè¦æˆä¸º"å¯¹è±¡å®‰å…¨"çš„ï¼Œå¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

1. traitä¸èƒ½è¦æ±‚`Self: Sized`
2. traitçš„æ‰€æœ‰æ–¹æ³•å¿…é¡»ï¼š
   - ä¸èƒ½æœ‰æ³›å‹å‚æ•°
   - ä¸èƒ½ä½¿ç”¨`Self`ä½œä¸ºå‚æ•°æˆ–è¿”å›ç±»å‹ï¼ˆé™¤éåœ¨æŒ‡é’ˆ/å¼•ç”¨åï¼‰
   - å¿…é¡»æ˜¯å¯¹è±¡å®‰å…¨çš„

```rust
// å¯¹è±¡å®‰å…¨çš„ trait
trait Safe {
    fn process(&self, data: &str);
    fn get_ref(&self) -> &dyn Safe;
}

// éå¯¹è±¡å®‰å…¨çš„ trait
trait Unsafe {
    fn clone(&self) -> Self;         // è¿”å› Selfï¼Œä¸å®‰å…¨
    fn process<T>(&self, data: T);   // æ³›å‹å‚æ•°ï¼Œä¸å®‰å…¨
    fn as_sized(self) where Self: Sized;  // è¦æ±‚ Self: Sizedï¼Œä¸å®‰å…¨
}
```

**åŠ¨æ€åˆ†å‘çš„å®é™…åº”ç”¨**ï¼š

1. **æ’ä»¶ç³»ç»Ÿ**ï¼š

```rust
trait Plugin {
    fn name(&self) -> &str;
    fn execute(&self, data: &[u8]) -> Result<(), Error>;
}

struct PluginManager {
    plugins: HashMap<String, Box<dyn Plugin>>,
}

impl PluginManager {
    fn register(&mut self, plugin: Box<dyn Plugin>) {
        self.plugins.insert(plugin.name().to_string(), plugin);
    }
    
    fn execute(&self, name: &str, data: &[u8]) -> Result<(), Error> {
        match self.plugins.get(name) {
            Some(plugin) => plugin.execute(data),
            None => Err(Error::PluginNotFound),
        }
    }
}
```

1. **å¼‚æ„é›†åˆ**ï¼š

```rust
struct UiElement {
    components: Vec<Box<dyn Drawable>>,
}

impl UiElement {
    fn add_component(&mut self, component: Box<dyn Drawable>) {
        self.components.push(component);
    }
    
    fn draw(&self) {
        for component in &self.components {
            component.draw();
        }
    }
}
```

1. **ç­–ç•¥æ¨¡å¼**ï¼š

```rust
trait SortStrategy {
    fn sort(&self, data: &mut [i32]);
}

struct QuickSort;
struct MergeSort;

impl SortStrategy for QuickSort {
    fn sort(&self, data: &mut [i32]) {
        // å¿«é€Ÿæ’åºå®ç°...
    }
}

impl SortStrategy for MergeSort {
    fn sort(&self, data: &mut [i32]) {
        // å½’å¹¶æ’åºå®ç°...
    }
}

struct Sorter {
    strategy: Box<dyn SortStrategy>,
}

impl Sorter {
    fn new(strategy: Box<dyn SortStrategy>) -> Self {
        Sorter { strategy }
    }
    
    fn sort(&self, data: &mut [i32]) {
        self.strategy.sort(data);
    }
}
```

**é™æ€vsåŠ¨æ€åˆ†å‘çš„æƒè¡¡**ï¼š

| ç‰¹æ€§ | é™æ€åˆ†å‘ (æ³›å‹) | åŠ¨æ€åˆ†å‘ (traitå¯¹è±¡) |
|------|---------------|---------------------|
| æ€§èƒ½ | é›¶è¿è¡Œæ—¶å¼€é”€ | æœ‰è™šè¡¨æŸ¥æ‰¾å¼€é”€ |
| ä»£ç å¤§å° | å¯èƒ½å¯¼è‡´ä»£ç è†¨èƒ€ | å•ä¸€ä»£ç è·¯å¾„ï¼Œæ›´ç´§å‡‘ |
| ç¼–è¯‘æ—¶é—´ | è¾ƒé•¿ | è¾ƒçŸ­ |
| å¼‚æ„é›†åˆ | ä¸æ”¯æŒ | æ”¯æŒ |
| åŠŸèƒ½é™åˆ¶ | æ— é™åˆ¶ | å¯¹è±¡å®‰å…¨æ€§é™åˆ¶ |
| é™æ€ç±»å‹æ£€æŸ¥ | å®Œå…¨ | éƒ¨åˆ†ï¼ˆæ¥å£çº§åˆ«ï¼‰ |

traitå¯¹è±¡å’ŒåŠ¨æ€åˆ†å‘è¡¥å……äº†Rustçš„é™æ€åˆ†å‘æœºåˆ¶ï¼Œæä¾›äº†å¤„ç†è¿è¡Œæ—¶ç±»å‹å˜åŒ–çš„çµæ´»æ€§ã€‚è™½ç„¶æœ‰ä¸€å®šæ€§èƒ½å¼€é”€ï¼Œä½†åœ¨éœ€è¦å¼‚æ„é›†åˆã€æ’ä»¶ç³»ç»Ÿæˆ–è¿è¡Œæ—¶ç±»å‹ç¡®å®šçš„åœºæ™¯ä¸­ï¼Œtraitå¯¹è±¡æ˜¯ä¸å¯æˆ–ç¼ºçš„å·¥å…·ã€‚

### å…³è”ç±»å‹ä¸æ³›å‹å…³è”ç±»å‹

å…³è”ç±»å‹(Associated Types)æ˜¯Rust traitç³»ç»Ÿçš„é‡è¦ç‰¹æ€§ï¼Œå®ƒå…è®¸åœ¨traitå®šä¹‰ä¸­æŒ‡å®šå ä½ç¬¦ç±»å‹ï¼Œå®ç°æ—¶æ‰ç¡®å®šå…·ä½“ç±»å‹ã€‚è¿™ç§æœºåˆ¶ç®€åŒ–äº†æ¶‰åŠå¤šä¸ªç›¸å…³ç±»å‹çš„APIè®¾è®¡ï¼Œæé«˜äº†ä»£ç å¯è¯»æ€§ã€‚

**å…³è”ç±»å‹åŸºç¡€**ï¼š

```rust
// å¸¦æœ‰å…³è”ç±»å‹çš„ trait
trait Container {
    // å…³è”ç±»å‹å£°æ˜
    type Item;
    
    // ä½¿ç”¨å…³è”ç±»å‹çš„æ–¹æ³•
    fn get(&self, index: usize) -> Option<&Self::Item>;
    fn insert(&mut self, item: Self::Item);
    fn len(&self) -> usize;
}

// ä¸º Vec<T> å®ç° Containerï¼ŒæŒ‡å®šå…³è”ç±»å‹
impl<T> Container for Vec<T> {
    type Item = T;
    
    fn get(&self, index: usize) -> Option<&Self::Item> {
        self.get(index)
    }
    
    fn insert(&mut self, item: Self::Item) {
        self.push(item);
    }
    
    fn len(&self) -> usize {
        self.len()
    }
}
```

**å…³è”ç±»å‹vsæ³›å‹å‚æ•°**ï¼š

è¿™ä¸¤ç§æœºåˆ¶æœ‰ä¸åŒçš„ç”¨é€”å’Œä¼˜ç¼ºç‚¹ï¼š

```rust
// ä½¿ç”¨æ³›å‹å‚æ•°çš„ trait
trait GenericContainer<T> {
    fn get(&self, index: usize) -> Option<&T>;
    fn insert(&mut self, item: T);
}

// ä½¿ç”¨å…³è”ç±»å‹çš„ trait
trait AssocContainer {
    type Item;
    fn get(&self, index: usize) -> Option<&Self::Item>;
    fn insert(&mut self, item: Self::Item);
}
```

| ç‰¹æ€§ | æ³›å‹å‚æ•° | å…³è”ç±»å‹ |
|------|---------|---------|
| ä¸€ä¸ªç±»å‹å¯å®ç°å¤šæ¬¡ | æ˜¯ | å¦ |
| ä½¿ç”¨æ—¶å¿…é¡»æŒ‡å®šç±»å‹ | æ˜¯ | å¦ |
| é€‚ç”¨åœºæ™¯ | å®¹å™¨å¯èƒ½åŒ…å«å¤šç§ç±»å‹ | å®¹å™¨ç±»å‹ä¸å…ƒç´ ç±»å‹ä¸€ä¸€å¯¹åº” |
| è¯­æ³•å†—é•¿åº¦ | è¾ƒé«˜ | è¾ƒä½ |

**æ ‡å‡†åº“å…³è”ç±»å‹ç¤ºä¾‹**ï¼š

```rust
// Iterator trait ä½¿ç”¨å…³è”ç±»å‹è¡¨ç¤ºè¿­ä»£é¡¹ç±»å‹
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// å®ç°ç¤ºä¾‹
impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        // å®ç°...
    }
}

// ä½¿ç”¨å…³è”ç±»å‹
fn sum<I: Iterator<Item = i32>>(iterator: I) -> i32 {
    // ä½¿ç”¨å…³è”ç±»å‹çº¦æŸ
}
```

**æ³›å‹å…³è”ç±»å‹(GAT)**ï¼š

æ³›å‹å…³è”ç±»å‹æ‰©å±•äº†å…³è”ç±»å‹ï¼Œå…è®¸å…³è”ç±»å‹æœ¬èº«å¸¦æœ‰æ³›å‹å‚æ•°ï¼Œæ˜¯Rust 1.65ä¸­æ–°ç¨³å®šçš„ç‰¹æ€§ï¼š

```rust
// æ³›å‹å…³è”ç±»å‹ç¤ºä¾‹
trait Collection {
    // å…³è”ç±»å‹å¸¦æœ‰ç”Ÿå‘½å‘¨æœŸå‚æ•°
    type Iter<'a> where Self: 'a;
    
    // ä½¿ç”¨æ³›å‹å…³è”ç±»å‹çš„æ–¹æ³•
    fn iter<'a>(&'a self) -> Self::Iter<'a>;
}

// å®ç°æ³›å‹å…³è”ç±»å‹
impl<T> Collection for Vec<T> {
    type Iter<'a> where T: 'a = std::slice::Iter<'a, T>;
    
    fn iter<'a>(&'a self) -> Self::Iter<'a> {
        self.iter()
    }
}
```

**GATçš„é«˜çº§åº”ç”¨**ï¼š

1. **å¸¦ç”Ÿå‘½å‘¨æœŸçš„è¿­ä»£å™¨**ï¼š

```rust
trait IteratorExt {
    type Item;
    
    // è¿”å›å¼•ç”¨çš„è¿­ä»£å™¨
    type References<'a>: Iterator<Item = &'a Self::Item>
    where
        Self: 'a;
        
    // è¿”å›å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨
    type ValuesMut<'a>: Iterator<Item = &'a mut Self::Item>
    where
        Self: 'a;
    
    fn references<'a>(&'a self) -> Self::References<'a>;
    fn values_mut<'a>(&'a mut self) -> Self::ValuesMut<'a>;
}
```

1. **åˆ›å»ºè‡ªå®šä¹‰Futures**ï¼š

```rust
trait AsyncGenerator {
    type Yield;
    type Return;
    
    type Future<'a>: Future<Output = Option<(Self::Yield, Self::Return)>>
    where
        Self: 'a;
    
    fn generate<'a>(&'a mut self) -> Self::Future<'a>;
}
```

å…³è”ç±»å‹å’Œæ³›å‹å…³è”ç±»å‹æ˜¯Rust traitç³»ç»Ÿçš„é«˜çº§ç‰¹æ€§ï¼Œå®ƒä»¬ç®€åŒ–äº†å¤æ‚APIè®¾è®¡ï¼Œæé«˜äº†ä»£ç å¯è¯»æ€§ï¼Œæ˜¯å¤§å‹Ruståº“å’Œæ¡†æ¶è®¾è®¡çš„é‡è¦å·¥å…·ã€‚GATçš„ç¨³å®šåŒ–æ›´æ˜¯ä¸ºå¼‚æ­¥ç¼–ç¨‹å’Œå¤æ‚é›†åˆç±»å‹è®¾è®¡æä¾›äº†å¼ºå¤§æ”¯æŒã€‚

### traitç»§æ‰¿ä¸ç»„åˆ

Rustä¸æ”¯æŒä¼ ç»Ÿæ„ä¹‰ä¸Šçš„ç±»å‹ç»§æ‰¿ï¼Œä½†æä¾›äº†traitç»§æ‰¿ï¼ˆsupertraitï¼‰å’Œtraitç»„åˆæœºåˆ¶ï¼Œä½¿å¼€å‘è€…èƒ½å¤Ÿæ„å»ºå¤æ‚çš„è¡Œä¸ºå±‚æ¬¡ç»“æ„ï¼Œå®ç°ä»£ç é‡ç”¨å’Œå¤šæ€ã€‚

**traitç»§æ‰¿åŸºç¡€**ï¼š

```rust
// å®šä¹‰åŸºç¡€trait
trait Printable {
    fn print(&self);
}

// ç»§æ‰¿åŸºç¡€traitï¼ˆsupertraitï¼‰
trait PrettyPrintable: Printable {
    fn pretty_print(&self);
    
    // é»˜è®¤å®ç°å¯ä»¥è°ƒç”¨supertraitçš„æ–¹æ³•
    fn print_with_border(&self) {
        println!("*************");
        self.print();  // è°ƒç”¨ Printable::print
        println!("*************");
    }
}

// å®ç°ç»§æ‰¿é“¾
struct Data {
    value: i32,
}

impl Printable for Data {
    fn print(&self) {
        println!("Value: {}", self.value);
    }
}

impl PrettyPrintable for Data {
    fn pretty_print(&self) {
        println!("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        println!("â”‚ Value: {} â”‚", self.value);
        println!("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
    }
}
```

ç»§æ‰¿traitï¼ˆsupertraitï¼‰è¦æ±‚ç±»å‹å¿…é¡»åŒæ—¶å®ç°çˆ¶traitï¼Œè¿™ç¡®ä¿äº†ç»§æ‰¿traitå¯ä»¥è°ƒç”¨çˆ¶traitä¸­çš„æ–¹æ³•ã€‚

**å¤šé‡traitç»§æ‰¿**ï¼š

```rust
trait A {
    fn method_a(&self);
}

trait B {
    fn method_b(&self);
}

// ç»§æ‰¿å¤šä¸ªtrait
trait C: A + B {
    fn method_c(&self) {
        self.method_a();  // æ¥è‡ª A
        self.method_b();  // æ¥è‡ª B
        println!("Method C");
    }
}

// å®ç°éœ€è¦æ»¡è¶³æ‰€æœ‰ç»§æ‰¿çš„trait
struct MyStruct;

impl A for MyStruct {
    fn method_a(&self) { println!("Method A"); }
}

impl B for MyStruct {
    fn method_b(&self) { println!("Method B"); }
}

impl C for MyStruct {
    // å¯ä»¥ä½¿ç”¨é»˜è®¤å®ç°æˆ–è¦†ç›–
}
```

**traitç»„åˆæ¨¡å¼**ï¼š

è™½ç„¶Rustä¸æ”¯æŒç›´æ¥çš„traitç»„åˆï¼Œä½†å¯ä»¥é€šè¿‡å¤šç§æ¨¡å¼å®ç°ç±»ä¼¼æ•ˆæœï¼š

1. **ä»£ç†æ¨¡å¼**ï¼š

```rust
trait Service {
    fn serve(&self) -> Result<(), Error>;
}

struct Logger<S> {
    inner: S,
}

// åŒ…è£…å†…éƒ¨æœåŠ¡å¹¶æ·»åŠ æ—¥å¿—åŠŸèƒ½
impl<S: Service> Service for Logger<S> {
    fn serve(&self) -> Result<(), Error> {
        println!("Before service call");
        let result = self.inner.serve();
        println!("After service call: {:?}", result);
        result
    }
}

// ä½¿ç”¨ï¼šlet service = Logger { inner: MyService };
```

1. **æ··å…¥æ¨¡å¼(Mixin)**ï¼š

```rust
// è¡Œä¸ºtrait
trait Drawable {
    fn draw(&self);
}

trait Resizable {
    fn resize(&mut self, width: u32, height: u32);
}

// ç»„åˆå¤šä¸ªè¡Œä¸ºçš„å®¹å™¨
struct UIWidget<T> {
    inner: T,
    x: u32,
    y: u32,
}

// å®ç°åŸºç¡€è¡Œä¸º
impl<T> UIWidget<T> {
    fn new(inner: T) -> Self {
        UIWidget { inner, x: 0, y: 0 }
    }
    
    fn position(&self) -> (u32, u32) {
        (self.x, self.y)
    }
    
    fn move_to(&mut self, x: u32, y: u32) {
        self.x = x;
        self.y = y;
    }
}

// æ¡ä»¶å®ç°é™„åŠ è¡Œä¸º
impl<T: Drawable> Drawable for UIWidget<T> {
    fn draw(&self) {
        println!("Drawing at position {:?}", self.position());
        self.inner.draw();
    }
}

impl<T: Resizable> Resizable for UIWidget<T> {
    fn resize(&mut self, width: u32, height: u32) {
        self.inner.resize(width, height);
    }
}
```

1. **é™æ€å¤šæ€ç»„åˆ**ï¼š

```rust
// ç»„åˆå¤šä¸ªè¡Œä¸ºçš„æ³›å‹å‡½æ•°
fn process<T>(value: &mut T)
where
    T: Drawable + Resizable + Clone,
{
    let backup = value.clone();
    value.resize(100, 100);
    value.draw();
    
    if some_condition() {
        *value = backup;  // æ¢å¤åŸçŠ¶
    }
}
```

**traitç»§æ‰¿çš„å±€é™æ€§**ï¼š

è™½ç„¶traitç»§æ‰¿æä¾›äº†ä¸€å®šçš„ä»£ç é‡ç”¨ï¼Œä½†å®ƒæœ‰ä¸€äº›å±€é™ï¼š

1. **æ²¡æœ‰é»˜è®¤å®ç°ç»§æ‰¿**ï¼šå­traitä¸èƒ½ç»§æ‰¿çˆ¶traitçš„é»˜è®¤å®ç°
2. **æ²¡æœ‰æ–¹æ³•è¦†ç›–æœºåˆ¶**ï¼šä¸èƒ½ç›´æ¥è¦†ç›–çˆ¶traitçš„æ–¹æ³•ï¼ˆå¿…é¡»é€šè¿‡å…¶ä»–æœºåˆ¶ï¼‰
3. **æ¥å£å™ªéŸ³**ï¼šæ¥å£å¯èƒ½å˜å¾—å¤æ‚ï¼Œç‰¹åˆ«æ˜¯å¤šé‡ç»§æ‰¿æ—¶

Rustçš„è®¾è®¡é€‰æ‹©äº†é¿å…ä¼ ç»ŸOOPç»§æ‰¿çš„é—®é¢˜ï¼Œè€Œæ˜¯é€šè¿‡traitç»§æ‰¿å’Œç»„åˆæä¾›æ›´å®‰å…¨ã€æ›´çµæ´»çš„ä»£ç é‡ç”¨æ–¹å¼ã€‚è¿™ç§è®¾è®¡é¼“åŠ±å¼€å‘è€…ä½¿ç”¨ç»„åˆè€Œéç»§æ‰¿ï¼Œç¬¦åˆç°ä»£è½¯ä»¶è®¾è®¡æœ€ä½³å®è·µã€‚

### å­¤å„¿è§„åˆ™åŠå…¶å½±å“

å­¤å„¿è§„åˆ™(Orphan Rule)æ˜¯Rustç±»å‹ç³»ç»Ÿçš„ä¸€ä¸ªé‡è¦çº¦æŸï¼Œå®ƒè§„å®šï¼šåªæœ‰å½“traitæˆ–ç±»å‹è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åœ¨å½“å‰crateä¸­å®šä¹‰çš„ï¼Œæ‰èƒ½ä¸ºè¯¥ç±»å‹å®ç°è¯¥traitã€‚è¿™ä¸ªè§„åˆ™å¯¹Rustçš„ç±»å‹ä¸€è‡´æ€§ã€åº“å…¼å®¹æ€§å’Œæ¼”è¿›æœ‰æ·±è¿œå½±å“ã€‚

**å­¤å„¿è§„åˆ™çš„åŸºæœ¬å½¢å¼**ï¼š

```rust
// å…è®¸ï¼šä¸ºæœ¬åœ°ç±»å‹å®ç°å¤–éƒ¨trait
struct MyType;  // æœ¬åœ°ç±»å‹
impl Display for MyType {}  // å¤–éƒ¨trait (std::fmt::Display)

// å…è®¸ï¼šä¸ºå¤–éƒ¨ç±»å‹å®ç°æœ¬åœ°trait
trait MyTrait {}  // æœ¬åœ°trait
impl MyTrait for String {}  // å¤–éƒ¨ç±»å‹ (std::string::String)

// ç¦æ­¢ï¼šä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨trait
// impl Serialize for String {}  // ç¼–è¯‘é”™è¯¯ï¼
```

**å­¤å„¿è§„åˆ™çš„åŸç†**ï¼š

å­¤å„¿è§„åˆ™è§£å†³äº†"ä¸€è‡´æ€§é—®é¢˜"ï¼Œå³ä¸¤ä¸ªç‹¬ç«‹çš„crateå¯èƒ½ä¸ºåŒä¸€ä¸ªç±»å‹å®ç°åŒä¸€ä¸ªtraitï¼Œå¯¼è‡´å†²çªã€‚é€šè¿‡å­¤å„¿è§„åˆ™ï¼ŒRustç¡®ä¿äº†ï¼š

1. æ¯ä¸ªtraitå®ç°éƒ½æœ‰ä¸€ä¸ªç¡®å®šçš„"æ‰€æœ‰è€…"
2. ä¸ä¼šå‘ç”Ÿä¸¤ä¸ªcrateä¸ºåŒä¸€ç±»å‹å®ç°åŒä¸€traitçš„å†²çª
3. ä»£ç æ›´æ”¹çš„å½±å“èŒƒå›´å¯æ§

**ç»•è¿‡å­¤å„¿è§„åˆ™çš„æ¨¡å¼**ï¼š

è™½ç„¶å­¤å„¿è§„åˆ™æœ‰å…¶å¿…è¦æ€§ï¼Œä½†æœ‰æ—¶ç¡®å®éœ€è¦ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨traitã€‚Rustæä¾›äº†å‡ ç§æ¨¡å¼æ¥å¤„ç†è¿™ç§éœ€æ±‚ï¼š

1. **Newtypeæ¨¡å¼**ï¼š

```rust
// ä¸ºå¤–éƒ¨ç±»å‹Stringå®ç°å¤–éƒ¨trait Serialize
struct MyString(String);  // æ–°ç±»å‹åŒ…è£…

impl Serialize for MyString {
    // å®ç°...
}

// ä½¿ç”¨æ—¶éœ€è¦åŒ…è£…å’Œè§£åŒ…
let my_string = MyString("hello".to_string());
serialize(&my_string);
```

1. **æœ¬åœ°traitç»§æ‰¿å¤–éƒ¨trait**ï¼š

```rust
// æœ¬åœ°traitç»§æ‰¿å¤–éƒ¨trait
trait MySerialize: Serialize {
    // å¯ä»¥æ·»åŠ é¢å¤–æ–¹æ³•
}

// ä¸ºå¤–éƒ¨ç±»å‹å®ç°æœ¬åœ°traitï¼ˆå…è®¸ï¼‰
impl MySerialize for String {
    // å®ç°...
}

// ç°åœ¨Stringç±»å‹å¯ä»¥åœ¨éœ€è¦Serializeçš„åœ°æ–¹ä½¿ç”¨
fn process<T: MySerialize>(value: T) {
    // å¯ä»¥ä½¿ç”¨Serializeçš„æ–¹æ³•
}
```

1. **å°è£…é€‚é…å™¨**ï¼š

```rust
// æ³›å‹é€‚é…å™¨ç±»å‹
struct Adapter<T>(T);

// ä¸ºæ‰€æœ‰Tå®ç°å¤–éƒ¨trait
impl<T: AnotherTrait> ExternalTrait for Adapter<T> {
    // å§”æ‰˜ç»™å†…éƒ¨ç±»å‹
}

// ä½¿ç”¨ï¼šlet adapted = Adapter(my_value);
```

**å­¤å„¿è§„åˆ™çš„å½±å“ä¸æŒ‘æˆ˜**ï¼š

1. **åº“è®¾è®¡å½±å“**ï¼š
   - é¼“åŠ±æ›´æ¨¡å—åŒ–çš„è®¾è®¡ï¼Œå°†ç›¸å…³ç±»å‹å’Œtraitæ”¾åœ¨åŒä¸€crate
   - æ¨åŠ¨"ç‰¹è®¾trait"æ¨¡å¼ï¼Œä¸ºç‰¹å®šåŠŸèƒ½åˆ›å»ºä¸“ç”¨trait

2. **æ‰©å±•æ€§æŒ‘æˆ˜**ï¼š
   - ä¸ºæ ‡å‡†åº“ç±»å‹æ·»åŠ åŠŸèƒ½å˜å¾—æ›´å¤æ‚
   - éœ€è¦åŒ…è£…/é€‚é…å™¨æ¨¡å¼ï¼Œå¢åŠ æ ·æ¿ä»£ç 

3. **ç”Ÿæ€ç³»ç»Ÿå½±å“**ï¼š
   - ä¿ƒè¿›äº†ä¸“æ³¨äºç‰¹å®šé¢†åŸŸçš„trait crateçš„å‘å±•
   - å¢åŠ äº†åŸºäºç±»å‹çŠ¶æ€å’Œnewtypeçš„è®¾è®¡æ¨¡å¼ä½¿ç”¨

4. **æ¼”è¿›ä¸€è‡´æ€§**ï¼š
   - ç¡®ä¿åº“å‡çº§æ—¶çš„ä¸€è‡´æ€§ï¼Œé¿å…breaking changes
   - é˜²æ­¢ä¾èµ–å†²çªå’Œ"è±å½¢ä¾èµ–"é—®é¢˜

**å­¤å„¿è§„åˆ™çš„æ¼”è¿›ä¸ç¼“è§£æªæ–½**ï¼š

Rustå›¢é˜Ÿè®¤è¯†åˆ°å­¤å„¿è§„åˆ™çš„é™åˆ¶æ€§ï¼Œå¹¶æ¢ç´¢äº†ä¸€äº›ç¼“è§£æªæ–½ï¼š

1. **è¦†ç›–è§„åˆ™ä¼˜åŒ–**ï¼šéšç€Rustå‘å±•ï¼Œå­¤å„¿è§„åˆ™çš„ç»†èŠ‚å·²ç»ä¼˜åŒ–ï¼Œå…è®¸åœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹çš„å®ç°

2. **impl Trait**ï¼šè¿”å›ä½ç½®çš„`impl Trait`æä¾›äº†ä¸å‘½åå…·ä½“ç±»å‹çš„æ–¹å¼ï¼Œéƒ¨åˆ†ç¼“è§£äº†ç±»å‹ç»„åˆé—®é¢˜

3. **æœªæ¥æ–¹å‘**ï¼šå›¢é˜Ÿæ¢ç´¢"å¯è¦†ç›–å®ç°"ç­‰åŠŸèƒ½ï¼Œå¯èƒ½åœ¨æœªæ¥ç‰ˆæœ¬ä¸­æä¾›æ›´å¤šçµæ´»æ€§

å­¤å„¿è§„åˆ™è™½ç„¶æœ‰é™åˆ¶æ€§ï¼Œä½†å®ƒæ˜¯Rustç±»å‹ç³»ç»Ÿä¸€è‡´æ€§å’Œå®‰å…¨æ€§çš„é‡è¦åŸºçŸ³ã€‚ç†è§£è¿™ä¸€è§„åˆ™åŠå…¶å·¥ä½œæ–¹å¼ï¼Œå¯¹äºè®¾è®¡è‰¯å¥½çš„Ruståº“å’Œåº”ç”¨ç¨‹åºæ¶æ„è‡³å…³é‡è¦ã€‚

## é«˜çº§æ³›å‹æ¨¡å¼

### æ–°ç±»å‹æ¨¡å¼(Newtype Pattern)

æ–°ç±»å‹æ¨¡å¼æ˜¯Rustä¸­å¸¸ç”¨çš„ä¸€ç§è®¾è®¡æ¨¡å¼ï¼Œé€šè¿‡åˆ›å»ºå•å­—æ®µçš„å…ƒç»„ç»“æ„ä½“åŒ…è£…ç°æœ‰ç±»å‹ï¼Œä»è€Œä¸ºç±»å‹æ·»åŠ æ–°çš„è¯­ä¹‰ã€è¡Œä¸ºæˆ–çº¦æŸã€‚è¿™ç§æ¨¡å¼æºè‡ªHaskellï¼Œåœ¨Rustä¸­ç”¨äºè§£å†³å¤šç§ç±»å‹ç³»ç»Ÿé—®é¢˜ã€‚

**æ–°ç±»å‹æ¨¡å¼çš„åŸºæœ¬å½¢å¼**ï¼š

```rust
// åŸºæœ¬æ–°ç±»å‹
struct Meters(f64);
struct Kilometers(f64);

// é˜²æ­¢æ··ç”¨ä¸åŒå•ä½
fn drive(distance: Kilometers) {
    println!("Driving {} km", distance.0);
}

// ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
// drive(Meters(100.0));

// æ­£ç¡®ï¼šæ˜ç¡®ç±»å‹è½¬æ¢
drive(Kilometers(50.0));
```

**æ–°ç±»å‹æ¨¡å¼çš„ä¸»è¦ç”¨é€”**ï¼š

1. **ç±»å‹å®‰å…¨ä¸å•ä½åŒºåˆ†**ï¼š

```rust
// é˜²æ­¢å•ä½æ··æ·†
struct Dollars(f64);
struct Euros(f64);

fn pay_in_dollars(amount: Dollars) {
    // å¤„ç†ç¾å…ƒæ”¯ä»˜...
}

// ä½¿ç”¨æ—¶å¿…é¡»æ˜ç¡®æŒ‡å®šå•ä½
pay_in_dollars(Dollars(100.0));
// pay_in_dollars(Euros(100.0));  // ç¼–è¯‘é”™è¯¯
```

1. **ç»†åŒ–ç±»å‹çš„è¯­ä¹‰**ï¼š

```rust
// ä¸ºæ™®é€šç±»å‹æ·»åŠ è¯­ä¹‰
struct Email(String);
struct Username(String);

impl Email {
    fn new(email: &str) -> Result<Self, ValidationError> {
        if !email.contains('@') {
            return Err(ValidationError::InvalidEmail);
        }
        Ok(Email(email.to_string()))
    }
}

// å‡½æ•°å¯ä»¥ç²¾ç¡®æŒ‡å®šéœ€è¦çš„ç±»å‹
fn send_notification(email: Email, message: &str) {
    // ç¡®ä¿ä½¿ç”¨æœ‰æ•ˆçš„ç”µå­é‚®

```rust
fn send_notification(email: Email, message: &str) {
    // ç¡®ä¿ä½¿ç”¨æœ‰æ•ˆçš„ç”µå­é‚®ä»¶åœ°å€
    println!("Sending message to {}: {}", email.0, message);
}

// å‡½æ•°è°ƒç”¨ä¿è¯ç±»å‹å®‰å…¨
let valid_email = Email::new("user@example.com").unwrap();
send_notification(valid_email, "Hello!");

// ä¸èƒ½ç›´æ¥ä¼ é€’å­—ç¬¦ä¸²
// send_notification("invalid".to_string(), "Hello!");  // ç¼–è¯‘é”™è¯¯
```

1. **ç»•è¿‡å­¤å„¿è§„åˆ™**ï¼š

```rust
// ä¸ºæ ‡å‡†åº“ç±»å‹å®ç°å¤–éƒ¨trait
struct MyVec<T>(Vec<T>);

impl<T: Display> Serialize for MyVec<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // åºåˆ—åŒ–å®ç°...
    }
}
```

1. **éšè—å†…éƒ¨å®ç°**ï¼š

```rust
// éšè—å†…éƒ¨å®ç°ç»†èŠ‚
pub struct PasswordHash(String);

impl PasswordHash {
    pub fn new(password: &str) -> Self {
        let hashed = hash_password(password);
        PasswordHash(hashed)
    }
    
    pub fn verify(&self, password: &str) -> bool {
        let hashed = hash_password(password);
        self.0 == hashed
    }
    
    // æ²¡æœ‰å…¬å¼€getteræ–¹æ³•ï¼Œé˜²æ­¢ç›´æ¥è®¿é—®å“ˆå¸Œå€¼
}
```

1. **æä¾›ä¸åŒçš„traitå®ç°**ï¼š

```rust
// ä¸ºåŒä¸€ç±»å‹æä¾›ä¸åŒçš„æ’åºå®ç°
struct SortByName(Person);
struct SortByAge(Person);

impl PartialEq for SortByName {
    fn eq(&self, other: &Self) -> bool {
        self.0.name == other.0.name
    }
}

impl PartialOrd for SortByName {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.name.partial_cmp(&other.0.name)
    }
}

impl PartialEq for SortByAge {
    fn eq(&self, other: &Self) -> bool {
        self.0.age == other.0.age
    }
}

impl PartialOrd for SortByAge {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.age.partial_cmp(&other.0.age)
    }
}
```

**æ–°ç±»å‹æ¨¡å¼å®ç°æŠ€å·§**ï¼š

1. **é€æ˜åŒ…è£…**ï¼š

```rust
// è‡ªåŠ¨è§£å¼•ç”¨
use std::ops::Deref;

struct Inches(f64);

impl Deref for Inches {
    type Target = f64;
    
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// å¯ä»¥ç›´æ¥ä½¿ç”¨f64çš„æ–¹æ³•
let length = Inches(5.0);
let double = *length * 2.0;
```

1. **è‡ªå®šä¹‰è¿ç®—ç¬¦**ï¼š

```rust
// å®ç°åŠ æ³•è¿ç®—
use std::ops::Add;

impl Add for Meters {
    type Output = Self;
    
    fn add(self, other: Self) -> Self::Output {
        Meters(self.0 + other.0)
    }
}

let sum = Meters(5.0) + Meters(10.0);
assert_eq!(sum.0, 15.0);
```

1. **é€‰æ‹©æ€§è½¬å‘trait**ï¼š

```rust
// é€‰æ‹©æ€§å®ç°åŒ…è£…ç±»å‹çš„trait
struct Wrapper<T>(T);

// è‡ªåŠ¨å®ç°æŸäº›trait
impl<T: Display> Display for Wrapper<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

// ä½†ä¸è‡ªåŠ¨å®ç°å…¶ä»–trait
// impl<T: PartialEq> PartialEq for Wrapper<T> { ... }
```

**æ–°ç±»å‹æ¨¡å¼çš„æƒè¡¡**ï¼š

1. **ä¼˜åŠ¿**ï¼š
   - å¢å¼ºç±»å‹å®‰å…¨æ€§
   - æ˜ç¡®è¡¨è¾¾æ„å›¾å’Œè¯­ä¹‰
   - æ§åˆ¶å¯è§æ€§å’Œæ¥å£
   - é¿å…å­¤å„¿è§„åˆ™é™åˆ¶

2. **åŠ£åŠ¿**ï¼š
   - å¢åŠ æ ·æ¿ä»£ç 
   - éœ€è¦æ‰‹åŠ¨å®ç°æˆ–è½¬å‘æ–¹æ³•
   - å¿…é¡»æ˜¾å¼è¿›è¡Œç±»å‹è½¬æ¢
   - å¯èƒ½å¢åŠ å¯¹IDEæ”¯æŒçš„è¦æ±‚

æ–°ç±»å‹æ¨¡å¼æ˜¯Rustä¸­åº”ç”¨æœ€å¹¿æ³›çš„è®¾è®¡æ¨¡å¼ä¹‹ä¸€ï¼Œå®ƒå……åˆ†åˆ©ç”¨äº†ç±»å‹ç³»ç»Ÿçš„èƒ½åŠ›ï¼Œåœ¨å®é™…ä»£ç ä¸­å¹¿æ³›ç”¨äºå¢å¼ºç±»å‹å®‰å…¨ã€è¯­ä¹‰æ˜ç¡®æ€§å’ŒAPIè®¾è®¡ã€‚é€šè¿‡è¿™ç§æ¨¡å¼ï¼Œå¯ä»¥åœ¨ä¸ç‰ºç‰²å®‰å…¨æ€§çš„å‰æä¸‹ï¼Œå®ç°æ›´ç²¾ç¡®å’Œç›´è§‚çš„ç±»å‹è¡¨è¾¾ã€‚

### å¹»å½±ç±»å‹(Phantom Types)

å¹»å½±ç±»å‹æ˜¯ä¸€ç§ä¸åœ¨è¿è¡Œæ—¶å­˜åœ¨ï¼Œä»…åœ¨ç±»å‹ç³»ç»Ÿå±‚é¢ä½¿ç”¨çš„ç±»å‹å‚æ•°ã€‚å®ƒä»¬é€šè¿‡`PhantomData<T>`æ ‡è®°ä½¿ç”¨ï¼Œå…è®¸åœ¨ä¸å®é™…å­˜å‚¨æ•°æ®çš„æƒ…å†µä¸‹ï¼Œä¸ºç±»å‹æ·»åŠ ç±»å‹å‚æ•°ï¼Œç”¨äºåœ¨ç¼–è¯‘æœŸå¼ºåˆ¶çº¦æŸå’ŒéªŒè¯ã€‚

**å¹»å½±ç±»å‹çš„åŸºæœ¬å½¢å¼**ï¼š

```rust
use std::marker::PhantomData;

// åŸºæœ¬å¹»å½±ç±»å‹ç¤ºä¾‹
struct Identifier<T> {
    id: u64,
    _marker: PhantomData<T>,  // Tä¸åœ¨è¿è¡Œæ—¶ä½¿ç”¨
}

// ä¸åŒçš„å¹»å½±å‚æ•°åˆ›å»ºä¸åŒç±»å‹
struct UserId;
struct ProductId;

type UserIdentifier = Identifier<UserId>;
type ProductIdentifier = Identifier<ProductId>;
```

**å¹»å½±ç±»å‹çš„ä¸»è¦åº”ç”¨**ï¼š

1. **ç±»å‹çŠ¶æ€æ¨¡å¼**ï¼š

```rust
// è¡¨ç¤ºçŠ¶æ€çš„æ ‡è®°ç±»å‹
struct Uninitialized;
struct Initialized;
struct Closed;

// ä½¿ç”¨å¹»å½±ç±»å‹è¡¨ç¤ºå½“å‰çŠ¶æ€
struct Connection<State> {
    socket: TcpStream,
    _state: PhantomData<State>,
}

impl Connection<Uninitialized> {
    fn new(addr: &str) -> io::Result<Self> {
        let socket = TcpStream::connect(addr)?;
        Ok(Connection {
            socket,
            _state: PhantomData,
        })
    }
    
    fn initialize(self) -> Connection<Initialized> {
        // æ‰§è¡Œåˆå§‹åŒ–...
        Connection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl Connection<Initialized> {
    // åªæœ‰åˆå§‹åŒ–çš„è¿æ¥æ‰èƒ½å‘é€æ•°æ®
    fn send_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.socket.write_all(data)
    }
    
    fn close(self) -> Connection<Closed> {
        // æ‰§è¡Œå…³é—­æ“ä½œ...
        Connection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl Connection<Closed> {
    // å…³é—­çš„è¿æ¥åªèƒ½ææ„
    fn destroy(self) {
        // æ¸…ç†èµ„æº...
    }
}
```

1. **å•ä½ç±»å‹å®‰å…¨**ï¼š

```rust
// è¡¨ç¤ºä¸åŒå•ä½çš„æ ‡è®°ç±»å‹
struct Meters;
struct Feet;

// ä½¿ç”¨å¹»å½±ç±»å‹è¡¨ç¤ºå•ä½
struct Length<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

// å•ä½è½¬æ¢å‡½æ•°
impl Length<Feet> {
    fn to_meters(self) -> Length<Meters> {
        Length {
            value: self.value * 0.3048,
            _unit: PhantomData,
        }
    }
}

impl Length<Meters> {
    fn to_feet(self) -> Length<Feet> {
        Length {
            value: self.value / 0.3048,
            _unit: PhantomData,
        }
    }
}

// ç‰¹å®šå•ä½çš„æ„é€ å‡½æ•°
fn meters(value: f64) -> Length<Meters> {
    Length { value, _unit: PhantomData }
}

fn feet(value: f64) -> Length<Feet> {
    Length { value, _unit: PhantomData }
}

// ä½¿ç”¨ï¼šä¸åŒå•ä½ä¸èƒ½ç›´æ¥æ··åˆ
let height = feet(6.0);
let height_m = height.to_meters();
// let wrong = height + height_m;  // ç¼–è¯‘é”™è¯¯
```

1. **æ³›å‹å‚æ•°æ ‡è®°**ï¼š

```rust
// è¡¨ç¤ºæ‰€æœ‰æƒå…³ç³»çš„å¹»å½±ç±»å‹
struct OwnedPointer<T> {
    ptr: *mut u8,
    size: usize,
    _marker: PhantomData<T>,  // è¡¨ç¤ºå¯¹Tçš„æ‰€æœ‰æƒ
}

impl<T> OwnedPointer<T> {
    fn new(value: T) -> Self {
        let size = std::mem::size_of::<T>();
        let ptr = unsafe { std::alloc::alloc(std::alloc::Layout::new::<T>()) };
        unsafe { std::ptr::write(ptr as *mut T, value); }
        
        OwnedPointer {
            ptr: ptr as *mut u8,
            size,
            _marker: PhantomData,
        }
    }
}

impl<T> Drop for OwnedPointer<T> {
    fn drop(&mut self) {
        unsafe {
            std::ptr::drop_in_place(self.ptr as *mut T);
            std::alloc::dealloc(
                self.ptr,
                std::alloc::Layout::from_size_align(self.size, std::mem::align_of::<T>()).unwrap()
            );
        }
    }
}
```

1. **ç±»å‹çº§åˆ«è®¿é—®æ§åˆ¶**ï¼š

```rust
// è¡¨ç¤ºè®¿é—®æƒé™çš„æ ‡è®°ç±»å‹
struct Readable;
struct Writable;

// ä½¿ç”¨å¹»å½±ç±»å‹æ§åˆ¶è®¿é—®æƒé™
struct DataStore<T, Access> {
    data: Vec<T>,
    _access: PhantomData<Access>,
}

impl<T> DataStore<T, Readable> {
    fn read(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

impl<T> DataStore<T, Writable> {
    fn write(&mut self, index: usize, value: T) -> bool {
        if index < self.data.len() {
            self.data[index] = value;
            true
        } else {
            false
        }
    }
}

impl<T> DataStore<T, Readable> {
    // ä¸€ä¸ªå‡½æ•°å¯ä»¥æå‡æƒé™
    fn make_writable(self) -> DataStore<T, Writable> {
        DataStore {
            data: self.data,
            _access: PhantomData,
        }
    }
}
```

**PhantomDataçš„ä¸åŒç”¨æ³•**ï¼š

```rust
// 1. æ ‡è®°ç”Ÿå‘½å‘¨æœŸå…³ç³»
struct Slice<'a, T> {
    ptr: *const T,
    len: usize,
    _marker: PhantomData<&'a T>,  // è¡¨ç¤ºæŒæœ‰Tçš„å¼•ç”¨
}

// 2. æ ‡è®°å˜æ€§ (variance)
struct Invariant<T> {
    _marker: PhantomData<fn(T) -> T>,  // ä½¿Tåœ¨ç±»å‹ä¸­æ˜¯ä¸å˜çš„
}

struct Covariant<T> {
    _marker: PhantomData<T>,  // ä½¿Tåœ¨ç±»å‹ä¸­æ˜¯åå˜çš„
}

struct Contravariant<T> {
    _marker: PhantomData<fn(T)>,  // ä½¿Tåœ¨ç±»å‹ä¸­æ˜¯é€†å˜çš„
}

// 3. æ ‡è®°æ‰€æœ‰æƒå’Œåˆ é™¤
struct OwnedBox<T> {
    ptr: *mut T,
    _marker: PhantomData<T>,  // è¡¨ç¤ºå¯¹Tæ‹¥æœ‰æ‰€æœ‰æƒ
}

// OwnedBox<T>ä¼šåœ¨åˆ é™¤æ—¶åˆ é™¤T
```

**å¹»å½±ç±»å‹çš„ä¼˜ç¼ºç‚¹**ï¼š

1. **ä¼˜ç‚¹**ï¼š
   - é›¶è¿è¡Œæ—¶æˆæœ¬çš„ç±»å‹å®‰å…¨
   - ç¼–è¯‘æœŸéªŒè¯çŠ¶æ€è½¬æ¢
   - é˜²æ­¢APIè¯¯ç”¨ï¼Œæä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯
   - è¡¨è¾¾å¤æ‚çš„ç±»å‹çº§åˆ«çº¦æŸ

2. **ç¼ºç‚¹**ï¼š
   - å¢åŠ ä»£ç å¤æ‚æ€§
   - å¯èƒ½é™ä½ä»£ç å¯è¯»æ€§
   - éœ€è¦ç†è§£å˜æ€§å’Œç±»å‹ç³»ç»Ÿæ·±å±‚æ¦‚å¿µ
   - é”™è¯¯ä¿¡æ¯å¯èƒ½éš¾ä»¥ç†è§£

å¹»å½±ç±»å‹æ˜¯Rustç±»å‹ç³»ç»Ÿä¸­çš„å¼ºå¤§å·¥å…·ï¼Œå®ƒå…è®¸å¼€å‘è€…åœ¨ä¸å¢åŠ è¿è¡Œæ—¶å¼€é”€çš„æƒ…å†µä¸‹ï¼Œä¸ºä»£ç æ·»åŠ é¢å¤–çš„ç±»å‹å®‰å…¨ä¿è¯ã€‚å½“æ­£ç¡®ä½¿ç”¨æ—¶ï¼Œå®ƒå¯ä»¥å°†è®¸å¤šæ½œåœ¨çš„è¿è¡Œæ—¶é”™è¯¯è½¬å˜ä¸ºç¼–è¯‘æ—¶é”™è¯¯ï¼Œå¤§å¤§æé«˜ä»£ç çš„å¥å£®æ€§å’Œå®‰å…¨æ€§ã€‚

### é€’å½’ç±»å‹çš„å®ç°

é€’å½’ç±»å‹æ˜¯ä¸€ç§åŒ…å«è‡ªèº«ç±»å‹çš„æ•°æ®ç»“æ„ï¼Œå¦‚é“¾è¡¨ã€æ ‘å’Œå›¾ç­‰ã€‚åœ¨Rustä¸­ï¼Œç”±äºæ‰€æœ‰ç±»å‹åœ¨ç¼–è¯‘æ—¶å¿…é¡»æœ‰å·²çŸ¥çš„å¤§å°ï¼Œå®ç°é€’å½’ç±»å‹éœ€è¦ç‰¹æ®ŠæŠ€å·§ï¼Œé€šå¸¸æ¶‰åŠä½¿ç”¨æŒ‡é’ˆç±»å‹æ¥åˆ›å»ºé—´æ¥å±‚ã€‚

**é€’å½’ç±»å‹çš„åŸºæœ¬æŒ‘æˆ˜**ï¼š

ä»¥ç®€å•é“¾è¡¨ä¸ºä¾‹ï¼Œç›´æ¥å®šä¹‰ä¼šå¯¼è‡´é—®é¢˜ï¼š

```rust
// é”™è¯¯ï¼šé€’å½’ç±»å‹çš„å¤§å°æ— æ³•ç¡®å®š
struct ListNode {
    value: i32,
    next: Option<ListNode>,  // ç¼–è¯‘é”™è¯¯ï¼šé€’å½’ç±»å‹ListNodeçš„å¤§å°æ— æ³•åœ¨ç¼–è¯‘æ—¶ç¡®å®š
}
```

**ä½¿ç”¨`Box<T>`å®ç°é€’å½’ç±»å‹**ï¼š

`Box<T>`å°†å€¼åˆ†é…åœ¨å †ä¸Šï¼Œå…¶å¤§å°æ˜¯å·²çŸ¥çš„æŒ‡é’ˆå¤§å°ï¼Œå¯ç”¨äºåˆ›å»ºé€’å½’æ•°æ®ç»“æ„ï¼š

```rust
// æ­£ç¡®ï¼šä½¿ç”¨Boxåˆ›å»ºé€’å½’ç±»å‹
#[derive(Debug)]
struct ListNode {
    value: i32,
    next: Option<Box<ListNode>>,
}

fn main() {
    // åˆ›å»ºé“¾è¡¨: 1 -> 2 -> 3
    let list = ListNode {
        value: 1,
        next: Some(Box::new(ListNode {
            value: 2,
            next: Some(Box::new(ListNode {
                value: 3,
                next: None,
            })),
        })),
    };
    
    // è®¿é—®é“¾è¡¨å…ƒç´ 
    let node1 = &list;
    let node2 = node1.next.as_ref().unwrap();
    let node3 = node2.next.as_ref().unwrap();
    
    println!("Values: {}, {}, {}", node1.value, node2.value, node3.value);
}
```

**é€’å½’æšä¸¾å®šä¹‰**ï¼š

æšä¸¾ä¹Ÿå¯ä»¥ç”¨äºå®šä¹‰é€’å½’ç±»å‹ï¼Œè¿™æ˜¯æ ‡å‡†åº“ä¸­`Option`å’Œ`Result`çš„å¸¸è§ç”¨æ³•ï¼š

```rust
// é€’å½’æšä¸¾ï¼šè¡¨ç¤ºç®—æœ¯è¡¨è¾¾å¼
#[derive(Debug, Clone)]
enum Expression {
    Value(i32),
    Add(Box<Expression>, Box<Expression>),
    Subtract(Box<Expression>, Box<Expression>),
    Multiply(Box<Expression>, Box<Expression>),
    Divide(Box<Expression>, Box<Expression>),
}

// è®¡ç®—è¡¨è¾¾å¼å€¼çš„é€’å½’å‡½æ•°
fn evaluate(expr: &Expression) -> i32 {
    match expr {
        Expression::Value(val) => *val,
        Expression::Add(left, right) => evaluate(left) + evaluate(right),
        Expression::Subtract(left, right) => evaluate(left) - evaluate(right),
        Expression::Multiply(left, right) => evaluate(left) * evaluate(right),
        Expression::Divide(left, right) => evaluate(left) / evaluate(right),
    }
}

// ä½¿ç”¨ï¼š(2 * 3) + (10 / 5)
let expr = Expression::Add(
    Box::new(Expression::Multiply(
        Box::new(Expression::Value(2)),
        Box::new(Expression::Value(3))
    )),
    Box::new(Expression::Divide(
        Box::new(Expression::Value(10)),
        Box::new(Expression::Value(5))
    ))
);

println!("Result: {}", evaluate(&expr));  // è¾“å‡º: 8
```

**é€’å½’ç±»å‹çš„ä¸åŒå®ç°æ–¹å¼**ï¼š

Rustæä¾›äº†å¤šç§æ–¹å¼å®ç°é€’å½’ç±»å‹ï¼Œé€‚åº”ä¸åŒåœºæ™¯ï¼š

1. **`Box<T>`ï¼šæ‰€æœ‰æƒç‹¬å **

```rust
// ä½¿ç”¨Boxçš„äºŒå‰æ ‘
struct BinaryTree<T> {
    value: T,
    left: Option<Box<BinaryTree<T>>>,
    right: Option<Box<BinaryTree<T>>>,
}
```

1. **`Rc<T>`ï¼šå…±äº«æ‰€æœ‰æƒ**

```rust
use std::rc::Rc;

// å¸¦å…±äº«å¼•ç”¨çš„å›¾èŠ‚ç‚¹
struct GraphNode<T> {
    value: T,
    neighbors: Vec<Rc<GraphNode<T>>>,
}

// åˆ›å»ºæœ‰ç¯å›¾ç»“æ„
fn create_graph() -> Rc<GraphNode<i32>> {
    let node1 = Rc::new(GraphNode {
        value: 1,
        neighbors: vec![],
    });
    
    let node2 = Rc::new(GraphNode {
        value: 2,
        neighbors: vec![Rc::clone(&node1)],
    });
    
    // ä¿®æ”¹node1ä½¿å…¶æŒ‡å‘node2ï¼Œå½¢æˆç¯
    {
        let mut neighbors = unsafe { 
            &mut *(Rc::as_ptr(&node1) as *mut GraphNode<i32>).neighbors
        };
        neighbors.push(Rc::clone(&node2));
    }
    
    node1
}
```

1. **`Rc<RefCell<T>>`ï¼šå…±äº«å¯å˜å¼•ç”¨**

```rust
use std::rc::Rc;
use std::cell::RefCell;

// å¯åŠ¨æ€ä¿®æ”¹çš„æ ‘ç»“æ„
struct TreeNode<T> {
    value: T,
    parent: Option<Weak<RefCell<TreeNode<T>>>>,
    children: Vec<Rc<RefCell<TreeNode<T>>>>,
}

impl<T> TreeNode<T> {
    fn new(value: T) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(TreeNode {
            value,
            parent: None,
            children: vec![],
        }))
    }
    
    fn add_child(parent: &Rc<RefCell<Self>>, value: T) -> Rc<RefCell<Self>> {
        let child = Rc::new(RefCell::new(TreeNode {
            value,
            parent: Some(Rc::downgrade(parent)),
            children: vec![],
        }));
        
        parent.borrow_mut().children.push(Rc::clone(&child));
        child
    }
}
```

1. **`Arc<T>`å’Œ`Arc<Mutex<T>>`ï¼šçº¿ç¨‹å®‰å…¨é€’å½’ç±»å‹**

```rust
use std::sync::{Arc, Mutex};

// çº¿ç¨‹å®‰å…¨çš„é“¾è¡¨
struct ThreadSafeList<T> {
    value: T,
    next: Option<Arc<ThreadSafeList<T>>>,
}

// å¯å¹¶å‘ä¿®æ”¹çš„æ ‘
struct ConcurrentTree<T> {
    value: T,
    children: Mutex<Vec<Arc<ConcurrentTree<T>>>>,
}

impl<T> ConcurrentTree<T> {
    fn add_child(&self, value: T) -> Arc<Self> {
        let child = Arc::new(ConcurrentTree {
            value,
            children: Mutex::new(vec![]),
        });
        
        self.children.lock().unwrap().push(Arc::clone(&child));
        child
    }
}
```

**é€’å½’ç±»å‹çš„å†…å­˜ç®¡ç†è€ƒé‡**ï¼š

1. **é¿å…å†…å­˜æ³„æ¼**ï¼š
   - å¾ªç¯å¼•ç”¨å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ï¼ˆç‰¹åˆ«æ˜¯ä½¿ç”¨`Rc`/`Arc`æ—¶ï¼‰
   - ä½¿ç”¨å¼±å¼•ç”¨(`Weak<T>`)æ‰“ç ´å¾ªç¯

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - è€ƒè™‘é€’å½’æ·±åº¦ï¼Œé¿å…æ ˆæº¢å‡º
   - å¯¹é¢‘ç¹è®¿é—®çš„é€’å½’ç»“æ„ä½¿ç”¨è¿­ä»£è€Œéé€’å½’ç®—æ³•

3. **èµ„æºæ•ˆç‡**ï¼š
   - `Box<T>`å†…å­˜å¼€é”€æœ€å°
   - `Rc<T>`/`Arc<T>`æœ‰å¼•ç”¨è®¡æ•°å¼€é”€
   - `RefCell<T>`/`Mutex<T>`æœ‰è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥å¼€é”€

é€’å½’ç±»å‹å±•ç¤ºäº†Rustç±»å‹ç³»ç»Ÿçš„å¼ºå¤§å’Œçµæ´»æ€§ï¼Œé€šè¿‡æ™ºèƒ½æŒ‡é’ˆå’Œé—´æ¥å±‚ï¼ŒRustèƒ½å¤Ÿå®‰å…¨é«˜æ•ˆåœ°å®ç°å¤æ‚æ•°æ®ç»“æ„ï¼ŒåŒæ—¶ä¿æŒå†…å­˜å®‰å…¨å’Œæ‰€æœ‰æƒè§„åˆ™ã€‚

### é€’å½’traitæ¨¡å¼

é€’å½’traitæ˜¯æŒ‡åŒ…å«å¯¹è‡ªèº«ç±»å‹çš„å¼•ç”¨æˆ–ä½¿ç”¨çš„traitï¼Œè¿™ç§æ¨¡å¼åœ¨å¤„ç†é€’å½’æ•°æ®ç»“æ„æˆ–ç®—æ³•æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚Rustæ”¯æŒå¤šç§é€’å½’traitå®ç°æ–¹å¼ï¼Œå¯ä»¥ç”¨äºéå†ã€æ¯”è¾ƒæˆ–è½¬æ¢å¤æ‚çš„åµŒå¥—ç»“æ„ã€‚

**åŸºæœ¬é€’å½’traitå®šä¹‰**ï¼š

```rust
// å®šä¹‰é€’å½’trait
trait Recursive {
    // é€’å½’æ–¹æ³•ï¼šæ¥å—å¹¶è¿”å›è‡ªèº«ç±»å‹
    fn process(&self) -> Self;
    
    // é€’å½’è®¡ç®—ï¼šè°ƒç”¨è‡ªèº«æ–¹æ³•
    fn recursive_computation(&self) -> i32;
}

// ä¸ºé€’å½’æ•°æ®ç»“æ„å®ç°é€’å½’trait
impl Recursive for BinaryTree<i32> {
    fn process(&self) -> Self {
        // é€’å½’å¤„ç†æ ‘èŠ‚ç‚¹...
        match (self.left.as_ref(), self.right.as_ref()) {
            (None, None) => BinaryTree {
                value: self.value * 2,
                left: None,
                right: None,
            },
            (Some(left), None) => BinaryTree {
                value: self.value * 2,
                left: Some(Box::new(left.process())),
                right: None,
            },
            // å…¶ä»–æƒ…å†µ...
        }
    }
    
    fn recursive_computation(&self) -> i32 {
        let left_value = self.left.as_ref().map_or(0, |left| left.recursive_computation());
        let right_value = self.right.as_ref().map_or(0, |right| right.recursive_computation());
        
        self.value + left_value + right_value
    }
}
```

**é€’å½’visitoræ¨¡å¼**ï¼š

visitoræ¨¡å¼æ˜¯å¤„ç†é€’å½’æ•°æ®ç»“æ„çš„å¸¸ç”¨æ–¹å¼ï¼Œå…è®¸å°†è¡Œä¸ºä¸ç»“æ„åˆ†ç¦»ï¼š

```rust
// è®¿é—®è€…trait
trait Visitor<T> {
    fn visit_value(&mut self, value: &T);
    fn visit_tree(&mut self, tree: &BinaryTree<T>);
}

// ä¸ºæ ‘æ·»åŠ æ¥å—è®¿é—®è€…çš„æ–¹æ³•
impl<T> BinaryTree<T> {
    fn accept<V: Visitor<T>>(&self, visitor: &mut V) {
        visitor.visit_tree(self);
        
        if let Some(left) = &self.left {
            left.accept(visitor);
        }
        
        if let Some(right) = &self.right {
            right.accept(visitor);
        }
    }
}

// å…·ä½“è®¿é—®è€…å®ç°
struct SumVisitor {
    sum: i32,
}

impl Visitor<i32> for SumVisitor {
    fn visit_value(&mut self, value: &i32) {
        self.sum += *value;
    }
    
    fn visit_tree(&mut self, tree: &BinaryTree<i32>) {
        self.visit_value(&tree.value);
    }
}

// ä½¿ç”¨
let tree = create_tree();
let mut visitor = SumVisitor { sum: 0 };
tree.accept(&mut visitor);
println!("Sum: {}", visitor.sum);
```

**é€’å½’traitè¾¹ç•Œ**ï¼š

æœ‰æ—¶éœ€è¦åœ¨æ³›å‹ä»£ç ä¸­å¤„ç†é€’å½’ç»“æ„ï¼Œå¯ä»¥ä½¿ç”¨é€’å½’traitè¾¹ç•Œï¼š

```rust
// é€’å½’å¯åºåˆ—åŒ–trait
trait RecursiveSerialize {
    fn serialize(&self) -> String;
}

// ä¸ºä»»ä½•é€’å½’ç»“æ„å®ç°åºåˆ—åŒ–æ–¹æ³•
fn serialize_structure<T: RecursiveSerialize>(value: &T) -> String {
    value.serialize()
}

// ä¸ºé€’å½’æšä¸¾å®ç°
impl RecursiveSerialize for Expression {
    fn serialize(&self) -> String {
        match self {
            Expression::Value(val) => val.to_string(),
            Expression::Add(left, right) => {
                format!("({} + {})", left.serialize(), right.serialize())
            }
            Expression::Subtract(left, right) => {
                format!("({} - {})", left.serialize(), right.serialize())
            }
            // å…¶ä»–æƒ…å†µ...
        }
    }
}
```

**é€’å½’traitå¯¹è±¡**ï¼š

é€’å½’traitå¯¹è±¡å…è®¸åŠ¨æ€åˆ†å‘ï¼Œä½†éœ€è¦ç‰¹åˆ«æ³¨æ„å¤„ç†ï¼š

```rust
// é€’å½’ç»„åˆæ¨¡å¼
trait Component {
    fn render(&self);
    fn add_child(&mut self, child: Box<dyn Component>);
}

struct Container {
    children: Vec<Box<dyn Component>>,
}

impl Component for Container {
    fn render(&self) {
        println!("Container:");
        for child in &self.children {
            child.render();
        }
    }
    
    fn add_child(&mut self, child: Box<dyn Component>) {
        self.children.push(child);
    }
}

struct TextElement {
    text: String,
}

impl Component for TextElement {
    fn render(&self) {
        println!("Text: {}", self.text);
    }
    
    fn add_child(&mut self, _child: Box<dyn Component>) {
        // å¶èŠ‚ç‚¹ä¸æ”¯æŒæ·»åŠ å­å…ƒç´ 
        println!("Cannot add child to text element");
    }
}
```

**é€’å½’traitçš„æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ**ï¼š

1. **æ ˆæº¢å‡ºé£é™©**ï¼š
   - é€’å½’è°ƒç”¨å¯èƒ½å¯¼è‡´æ ˆæº¢å‡º
   - è§£å†³ï¼šä½¿ç”¨è¿­ä»£æ›¿ä»£é€’å½’ï¼Œæˆ–æ§åˆ¶é€’å½’æ·±åº¦

```rust
// è½¬æ¢é€’å½’ä¸ºè¿­ä»£
fn sum_tree_iterative(root: &BinaryTree<i32>) -> i32 {
    let mut sum = 0;
    let mut stack = vec![root];
    
    while let Some(node) = stack.pop() {
        sum += node.value;
        
        if let Some(right) = &node.right {
            stack.push(right);
        }
        
        if let Some(left) = &node.left {
            stack.push(left);
        }
    }
    
    sum
}
```

1. **é€’å½’traitå¯¹è±¡çš„æ‰€æœ‰æƒé—®é¢˜**ï¼š
   - é€’å½’traitå¯¹è±¡å¯èƒ½å¯¼è‡´æ‰€æœ‰æƒé—®é¢˜
   - è§£å†³ï¼šä½¿ç”¨å¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆ

1. **traitæ–¹æ³•é€’å½’è°ƒç”¨çš„é™åˆ¶**ï¼š
   - é€’å½’å±‚çº§è¿‡æ·±å¯èƒ½å¯¼è‡´ç¼–è¯‘å™¨é™åˆ¶
   - è§£å†³ï¼šåˆ†è§£ä¸ºå¤šä¸ªæ–¹æ³•æˆ–ä½¿ç”¨ä¸­é—´å‡½æ•°

é€’å½’traitæ¨¡å¼æ˜¯Rustä¸­å¤„ç†å¤æ‚åµŒå¥—æ•°æ®ç»“æ„çš„å¼ºå¤§å·¥å…·ï¼Œç»“åˆæ‰€æœ‰æƒç³»ç»Ÿå’Œæ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥å®‰å…¨é«˜æ•ˆåœ°å®ç°éå†ã€è½¬æ¢å’Œæ“ä½œé€’å½’æ•°æ®ã€‚åˆç†ä½¿ç”¨è¿™ç§æ¨¡å¼ï¼Œå¯ä»¥ç¼–å†™æ—¢å®‰å…¨åˆè¡¨è¾¾åŠ›å¼ºçš„é€’å½’ç®—æ³•ã€‚

### æ™ºèƒ½æŒ‡é’ˆä¸æ³›å‹

æ™ºèƒ½æŒ‡é’ˆæ˜¯Rustä¸­ç»“åˆæ‰€æœ‰æƒç³»ç»Ÿä¸æ³›å‹çš„é‡è¦åº”ç”¨ï¼Œå®ƒä»¬æä¾›äº†ç®¡ç†èµ„æºåˆ†é…ã€å…±äº«å’ŒåŒæ­¥çš„æŠ½è±¡ï¼ŒåŒæ—¶ä¿æŒç±»å‹å®‰å…¨å’Œé›¶å¼€é”€æŠ½è±¡åŸåˆ™ã€‚

**ä¸»è¦æ™ºèƒ½æŒ‡é’ˆç±»å‹åŠå…¶æ³›å‹ç‰¹æ€§**ï¼š

1. **`Box<T>`ï¼šå”¯ä¸€æ‰€æœ‰æƒå †åˆ†é…**

```rust
// Box<T>å°†å€¼ç§»åŠ¨åˆ°å †ä¸Šï¼Œä¿æŒå”¯ä¸€æ‰€æœ‰æƒ
fn box_example<T: Display>(value: T) -> Box<T> {
    // å€¼è¢«ç§»åŠ¨åˆ°å †ä¸Š
    let boxed = Box::new(value);
    println!("Boxed value: {}", boxed);
    boxed
}

// ç”¨äºæ³›å‹é€’å½’ç±»å‹
#[derive(Debug)]
enum BinaryTree<T> {
    Leaf,
    Node(T, Box<BinaryTree<T>>, Box<BinaryTree<T>>),
}
```

1. **`Rc<T>`ï¼šå…±äº«æ‰€æœ‰æƒ**

```rust
use std::rc::Rc;

// Rc<T>å…è®¸å¤šä¸ªæ‰€æœ‰è€…ï¼Œé€šè¿‡å¼•ç”¨è®¡æ•°
fn rc_example<T: Display + Clone>(value: T) {
    let shared = Rc::new(value);
    
    // åˆ›å»ºå¤šä¸ªæ‰€æœ‰è€…
    let owner1 = Rc::clone(&shared);
    let owner2 = Rc::clone(&shared);
    
    println!("References: {}", Rc::strong_count(&shared));
    println!("Values: {}, {}", owner1, owner2);
}

// ç”¨äºå…±äº«æ•°æ®ç»“æ„
type SharedList<T> = Option<Rc<ListNode<T>>>;

struct ListNode<T> {
    value: T,
    next: SharedList<T>,
}
```

1. **`Arc<T>`ï¼šåŸå­å¼•ç”¨è®¡æ•°**

```rust
use std::sync::Arc;
use std::thread;

// Arc<T>æ˜¯çº¿ç¨‹å®‰å…¨çš„å…±äº«æ‰€æœ‰æƒ
fn arc_example<T: Display + Clone + Send + Sync + 'static>(value: T) {
    let shared = Arc::new(value);
    
    let threads: Vec<_> = (0..5)
        .map(|id| {
            let value_ref = Arc::clone(&shared);
            thread::spawn(move || {
                println!("Thread {}: {}", id, value_ref);
            })
        })
        .collect();
    
    for thread in threads {
        thread.join().unwrap();
    }
}
```

1. **`RefCell<T>`ï¼šè¿è¡Œæ—¶å¯å˜æ€§**

```rust
use std::cell::RefCell;

// RefCell<T>æä¾›å†…éƒ¨å¯å˜æ€§
fn refcell_example<T: Display + Clone>(value: T) {
    let cell = RefCell::new(value);
    
    // ä¸å¯å˜å€Ÿç”¨
    {
        let borrowed = cell.borrow();
        println!("Original: {}", borrowed);
    }
    
    // å¯å˜å€Ÿç”¨
    {
        let mut mut_borrowed = cell.borrow_mut();
        *mut_borrowed = mut_borrowed.clone();
        println!("After mutation: {}", mut_borrowed);
    }
}
```

1. **`Mutex<T>`å’Œ`RwLock<T>`ï¼šåŒæ­¥åŸè¯­**

```rust
use std::sync::{Mutex, RwLock};
use std::thread;

// Mutex<T>æä¾›äº’æ–¥è®¿é—®
fn mutex_example<T: Display + Clone + Send + 'static>(value: T) {
    let mutex = Arc::new(Mutex::new(value));
    
    let threads: Vec<_> = (0..3)
        .map(|id| {
            let lock_ref = Arc::clone(&mutex);
            thread::spawn(move || {
                let mut guard = lock_ref.lock().unwrap();
                println!("Thread {} has lock: {}", id, guard);
                // ä¿®æ”¹å€¼
                *guard = guard.clone();
            })
        })
        .collect();
    
    for thread in threads {
        thread.join().unwrap();
    }
}

// RwLock<T>æä¾›è¯»å†™é”
fn rwlock_example<T: Display + Send + Sync + 'static>(value: T) {
    let rwlock = Arc::new(RwLock::new(value));
    
    // å¤šä¸ªè¯»å–çº¿ç¨‹
    let read_threads: Vec<_> = (0..3)
        .map(|id| {
            let lock_ref = Arc::clone(&rwlock);
            thread::spawn(move || {
                let guard = lock_ref.read().unwrap();
                println!("Reader {}: {}", id, guard);
            })
        })
        .collect();
    
    // å•ä¸ªå†™å…¥çº¿ç¨‹
    let write_lock = Arc::clone(&rwlock);
    let write_thread = thread::spawn(move || {
        let mut guard = write_lock.write().unwrap();
        println!("Writer has exclusive access: {}", guard);
        // å†™å…¥æ“ä½œ...
    });
    
    for thread in read_threads {
        thread.join().unwrap();
    }
    
    write_thread.join().unwrap();
}
```

**æ™ºèƒ½æŒ‡é’ˆç»„åˆæ¨¡å¼**ï¼š

æ™ºèƒ½æŒ‡é’ˆå¯ä»¥ç»„åˆä½¿ç”¨ï¼Œåˆ›å»ºæ›´å¤æ‚çš„å†…å­˜ç®¡ç†æ–¹æ¡ˆï¼š

```rust
// çº¿ç¨‹å®‰å…¨ã€å…±äº«ã€å¯å˜æ•°æ®ï¼šArc<Mutex<T>>
type ThreadSafeCache<K, V> = Arc<Mutex<HashMap<K, V>>>;

// å…±äº«å¯å˜å¼•ç”¨ï¼šRc<RefCell<T>>
type SharedMutableList<T> = Rc<RefCell<Vec<T>>>;

// å¤šæ‰€æœ‰è€…é€’å½’ç»“æ„ï¼šRc<RefCell<Node<T>>>
struct Node<T> {
    value: T,
    children: Vec<Rc<RefCell<Node<T>>>>,
    parent: Option<Weak<RefCell<Node<T>>>>,
}
```

**è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ**ï¼š

Rustå…è®¸åˆ›å»ºè‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆï¼Œå®ç°ç‰¹å®šçš„å†…å­˜ç®¡ç†ç­–ç•¥ï¼š

```rust
// è‡ªå®šä¹‰å¼•ç”¨è®¡æ•°æŒ‡é’ˆ
struct RcVec<T> {
    inner: Rc<Vec<T>>,
}

impl<T> RcVec<T> {
    fn new(vec: Vec<T>) -> Self {
        RcVec { inner: Rc::new(vec) }
    }
    
    fn clone(&self) -> Self {
        RcVec { inner: Rc::clone(&self.inner) }
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        self.inner.get(index)
    }
}

impl<T> Drop for RcVec<T> {
    fn drop(&mut self) {
        println!("Dropping RcVec, remaining references: {}", 
                 Rc::strong_count(&self.inner) - 1);
    }
}
```

**æ™ºèƒ½æŒ‡é’ˆä¸traitå¯¹è±¡**ï¼š

æ™ºèƒ½æŒ‡é’ˆå¸¸ä¸traitå¯¹è±¡ç»“åˆä½¿ç”¨ï¼Œæ”¯æŒåŠ¨æ€åˆ†å‘ï¼š

```rust
trait Animal {
    fn make_sound(&self) -> String;
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn make_sound(&self) -> String {
        "Woof!".to_string()
    }
}

impl Animal for Cat {
    fn make_sound(&self) -> String {
        "Meow!".to_string()
    }
}

// åˆ›å»ºåŠ¨ç‰©é›†åˆ
fn create_animals() -> Vec<Box<dyn Animal>> {
    vec![
        Box::new(Dog),
        Box::new(Cat),
        Box::new(Dog),
    ]
}

// ä½¿ç”¨åŠ¨æ€åˆ†å‘
fn animal_sounds(animals: &[Box<dyn Animal>]) {
    for animal in animals {
        println!("Animal says: {}", animal.make_sound());
    }
}
```

**æ™ºèƒ½æŒ‡é’ˆæ€§èƒ½è€ƒé‡**ï¼š

1. **ç©ºé—´å¼€é”€**ï¼š
   - `Box<T>`ï¼šå‡ ä¹æ²¡æœ‰å¼€é”€
   - `Rc<T>`/`Arc<T>`ï¼šå¼•ç”¨è®¡æ•°å¼€é”€
   - `RefCell<T>`/`Mutex<T>`ï¼šå€Ÿç”¨æ ‡å¿—/é”çŠ¶æ€å¼€é”€

2. **æ—¶é—´å¼€é”€**ï¼š
   - `Box<T>`ï¼šåˆ†é…/é‡Šæ”¾å¼€é”€
   - `Rc<T>`ï¼šå¼•ç”¨è®¡æ•°æ›´æ–°å¼€é”€
   - `Arc<T>`ï¼šåŸå­æ“ä½œå¼€é”€
   - `RefCell<T>`ï¼šè¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥
   - `Mutex<T>`/`RwLock<T>`ï¼šé”è·å–/é‡Šæ”¾å¼€é”€

3. **é€‰æ‹©ç­–ç•¥**ï¼š
   - æœ€å°å¼€é”€ï¼šä¼˜å…ˆè€ƒè™‘`Box<T>`
   - éœ€è¦å…±äº«ï¼šä½¿ç”¨`Rc<T>`æˆ–`Arc<T>`
   - éœ€è¦å¯å˜æ€§ï¼šç»“åˆ`RefCell<T>`æˆ–`Mutex<T>`

æ™ºèƒ½æŒ‡é’ˆæ˜¯Rustå†…å­˜ç®¡ç†å’Œæ³›å‹ç³»ç»Ÿçš„å®Œç¾ç»“åˆï¼Œæä¾›äº†æ—¢å®‰å…¨åˆé«˜æ•ˆçš„èµ„æºç®¡ç†æŠ½è±¡ã€‚
é€šè¿‡æ™ºèƒ½æŒ‡é’ˆï¼ŒRustå®ç°äº†æ— åƒåœ¾æ”¶é›†çš„å†…å­˜å®‰å…¨ï¼ŒåŒæ—¶ä¿æŒäº†è¡¨è¾¾åŠ›å’Œæ€§èƒ½ã€‚

### æ„å»ºè€…æ¨¡å¼ä¸æµå¼æ¥å£

æ„å»ºè€…æ¨¡å¼(Builder Pattern)æ˜¯ä¸€ç§åˆ›å»ºå¤æ‚å¯¹è±¡çš„è®¾è®¡æ¨¡å¼ï¼Œç‰¹åˆ«é€‚åˆé…ç½®æœ‰å¤šä¸ªå¯é€‰å‚æ•°çš„å¯¹è±¡ã€‚
åœ¨Rustä¸­ï¼Œè¿™ç§æ¨¡å¼å¸¸ä¸æ³›å‹å’Œæ–¹æ³•é“¾(Method Chaining)ç»“åˆï¼Œåˆ›å»ºæµç•…çš„APIæ¥å£ã€‚

**åŸºæœ¬æ„å»ºè€…æ¨¡å¼**ï¼š

```rust
// ç›®æ ‡å¤æ‚å¯¹è±¡
#[derive(Debug)]
struct HttpRequest {
    url: String,
    method: String,
    headers: HashMap<String, String>,
    body: Option

```rust
// ç›®æ ‡å¤æ‚å¯¹è±¡
#[derive(Debug)]
struct HttpRequest {
    url: String,
    method: String,
    headers: HashMap<String, String>,
    body: Option<Vec<u8>>,
    timeout: Duration,
    follow_redirects: bool,
}

// æ„å»ºè€…
#[derive(Default)]
struct HttpRequestBuilder {
    url: Option<String>,
    method: Option<String>,
    headers: HashMap<String, String>,
    body: Option<Vec<u8>>,
    timeout: Option<Duration>,
    follow_redirects: Option<bool>,
}

impl HttpRequestBuilder {
    fn new() -> Self {
        HttpRequestBuilder::default()
    }
    
    // æµå¼è®¾ç½®æ–¹æ³•
    fn url(mut self, url: impl Into<String>) -> Self {
        self.url = Some(url.into());
        self
    }
    
    fn method(mut self, method: impl Into<String>) -> Self {
        self.method = Some(method.into());
        self
    }
    
    fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.insert(key.into(), value.into());
        self
    }
    
    fn body(mut self, body: impl Into<Vec<u8>>) -> Self {
        self.body = Some(body.into());
        self
    }
    
    fn timeout(mut self, timeout: Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn follow_redirects(mut self, follow: bool) -> Self {
        self.follow_redirects = Some(follow);
        self
    }
    
    // æ„å»ºæ–¹æ³•
    fn build(self) -> Result<HttpRequest, &'static str> {
        let url = self.url.ok_or("URL is required")?;
        let method = self.method.unwrap_or_else(|| "GET".to_string());
        
        Ok(HttpRequest {
            url,
            method,
            headers: self.headers,
            body: self.body,
            timeout: self.timeout.unwrap_or_else(|| Duration::from_secs(30)),
            follow_redirects: self.follow_redirects.unwrap_or(true),
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn builder_example() -> Result<(), &'static str> {
    let request = HttpRequestBuilder::new()
        .url("https://example.com/api")
        .method("POST")
        .header("Content-Type", "application/json")
        .header("Authorization", "Bearer token123")
        .body(r#"{"key": "value"}"#.as_bytes().to_vec())
        .timeout(Duration::from_secs(60))
        .build()?;
    
    println!("Request: {:?}", request);
    Ok(())
}
```

**æ³›å‹æ„å»ºè€…æ¨¡å¼**ï¼š

æ³›å‹å¯ä»¥å¢å¼ºæ„å»ºè€…æ¨¡å¼çš„çµæ´»æ€§ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†ç±»å‹å®‰å…¨çŠ¶æ€è½¬æ¢æ—¶ï¼š

```rust
// ç±»å‹çŠ¶æ€æ„å»ºè€…æ¨¡å¼
struct NoUrl;  // æ ‡è®°ç±»å‹ï¼šæ— URL
struct HasUrl;  // æ ‡è®°ç±»å‹ï¼šæœ‰URL

// æ³›å‹æ„å»ºè€…
struct RequestBuilder<State> {
    url: Option<String>,
    method: String,
    headers: HashMap<String, String>,
    _state: PhantomData<State>,
}

// åˆå§‹çŠ¶æ€å®ç°
impl RequestBuilder<NoUrl> {
    fn new() -> Self {
        RequestBuilder {
            url: None,
            method: "GET".to_string(),
            headers: HashMap::new(),
            _state: PhantomData,
        }
    }
    
    // è®¾ç½®URLè½¬æ¢çŠ¶æ€
    fn url(self, url: impl Into<String>) -> RequestBuilder<HasUrl> {
        RequestBuilder {
            url: Some(url.into()),
            method: self.method,
            headers: self.headers,
            _state: PhantomData,
        }
    }
}

// å…±æœ‰æ–¹æ³•
impl<State> RequestBuilder<State> {
    fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.insert(key.into(), value.into());
        self
    }
    
    fn method(mut self, method: impl Into<String>) -> Self {
        self.method = method.into();
        self
    }
}

// æœ‰URLçŠ¶æ€æ‰èƒ½æ„å»º
impl RequestBuilder<HasUrl> {
    fn build(self) -> HttpRequest {
        HttpRequest {
            url: self.url.unwrap(),
            method: self.method,
            headers: self.headers,
            body: None,
            timeout: Duration::from_secs(30),
            follow_redirects: true,
        }
    }
}

// ä½¿ç”¨ï¼šç¼–è¯‘å™¨ç¡®ä¿URLå¿…é¡»è®¾ç½®
let request = RequestBuilder::new()
    .method("POST")
    .header("Content-Type", "application/json")
    .url("https://example.com")  // å¿…é¡»è®¾ç½®URL
    .build();
```

**æ´¾ç”Ÿå®æ„å»ºè€…æ¨¡å¼**ï¼š

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ´¾ç”Ÿå®ç®€åŒ–æ„å»ºè€…æ¨¡å¼çš„å®ç°ï¼Œå¦‚`derive_builder`åº“ï¼š

```rust
use derive_builder::Builder;

#[derive(Builder, Debug)]
#[builder(setter(into))]
struct Server {
    #[builder(default = "localhost")]
    host: String,
    
    #[builder(default = "8080")]
    port: u16,
    
    #[builder(default)]
    secure: bool,
    
    #[builder(default = "4")]
    workers: u32,
}

// ä½¿ç”¨ç”Ÿæˆçš„æ„å»ºè€…
let server = ServerBuilder::default()
    .host("example.com")
    .port(9000)
    .secure(true)
    .build()
    .unwrap();
```

**é«˜çº§æ„å»ºè€…æ¨¡å¼å˜ä½“**ï¼š

1. **é€’å½’æ„å»ºè€…**ï¼š

```rust
// é€’å½’æ„å»ºåµŒå¥—ç»“æ„
struct Form {
    fields: Vec<Field>,
    buttons: Vec<Button>,
}

struct Field {
    name: String,
    value: String,
}

struct Button {
    text: String,
    action: String,
}

struct FormBuilder {
    fields: Vec<Field>,
    buttons: Vec<Button>,
}

impl FormBuilder {
    fn new() -> Self {
        FormBuilder {
            fields: Vec::new(),
            buttons: Vec::new(),
        }
    }
    
    // è¿”å›å­—æ®µæ„å»ºè€…
    fn add_field(&mut self) -> FieldBuilder {
        FieldBuilder {
            form_builder: self,
            name: String::new(),
            value: String::new(),
        }
    }
    
    // è¿”å›æŒ‰é’®æ„å»ºè€…
    fn add_button(&mut self) -> ButtonBuilder {
        ButtonBuilder {
            form_builder: self,
            text: String::new(),
            action: String::new(),
        }
    }
    
    fn build(self) -> Form {
        Form {
            fields: self.fields,
            buttons: self.buttons,
        }
    }
}

struct FieldBuilder<'a> {
    form_builder: &'a mut FormBuilder,
    name: String,
    value: String,
}

impl<'a> FieldBuilder<'a> {
    fn name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }
    
    fn value(mut self, value: impl Into<String>) -> Self {
        self.value = value.into();
        self
    }
    
    // å®Œæˆå¹¶è¿”å›çˆ¶æ„å»ºè€…
    fn done(self) -> &'a mut FormBuilder {
        self.form_builder.fields.push(Field {
            name: self.name,
            value: self.value,
        });
        self.form_builder
    }
}

// ç±»ä¼¼çš„ButtonBuilderå®ç°...

// ä½¿ç”¨åµŒå¥—æ„å»ºè€…
let form = FormBuilder::new()
    .add_field()
        .name("username")
        .value("johndoe")
        .done()
    .add_field()
        .name("password")
        .value("secret")
        .done()
    .add_button()
        .text("Submit")
        .action("/submit")
        .done()
    .build();
```

1. **æ„å»ºè€…ç‰¹å¾**ï¼š

```rust
// é€šç”¨æ„å»ºè€…ç‰¹å¾
trait Builder {
    type Product;
    
    fn build(self) -> Self::Product;
}

// å„ç§æ„å»ºè€…å®ç°æ­¤ç‰¹å¾
struct ConfigBuilder {
    // é…ç½®é€‰é¡¹...
}

impl Builder for ConfigBuilder {
    type Product = Config;
    
    fn build(self) -> Config {
        // æ„å»ºé…ç½®...
        Config { /* ... */ }
    }
}

// æ›´çµæ´»çš„å·¥å‚å‡½æ•°
fn create_product<B: Builder>(builder: B) -> B::Product {
    builder.build()
}
```

**æ„å»ºè€…æ¨¡å¼çš„æœ€ä½³å®è·µ**ï¼š

1. **è®¾è®¡è€ƒé‡**ï¼š
   - ä¸ºå¿…é€‰å‚æ•°ä½¿ç”¨ç±»å‹çŠ¶æ€
   - ä¸ºå¯é€‰å‚æ•°æä¾›é»˜è®¤å€¼
   - ä¿æŒæ–¹æ³•å‘½åä¸€è‡´æ€§
   - è€ƒè™‘ä½¿ç”¨`into`ç‰¹å¾ç®€åŒ–API

2. **é”™è¯¯å¤„ç†**ï¼š
   - ä½¿ç”¨`Result`è¿”å›æ„å»ºé”™è¯¯
   - è€ƒè™‘åœ¨æ„å»ºæ—¶éªŒè¯å‚æ•°

3. **æ€§èƒ½è€ƒè™‘**ï¼š
   - é¿å…ä¸å¿…è¦çš„å…‹éš†
   - ä½¿ç”¨`&mut self`è€Œé`mut self`å‡å°‘æ‰€æœ‰æƒè½¬ç§»
   - è€ƒè™‘å†…å­˜åˆ†é…ä¼˜åŒ–

æ„å»ºè€…æ¨¡å¼ç»“åˆæµå¼æ¥å£æ˜¯Rust APIè®¾è®¡ä¸­çš„é‡è¦å·¥å…·ï¼Œç‰¹åˆ«é€‚åˆåˆ›å»ºé…ç½®å¤æ‚çš„å¯¹è±¡ï¼Œ
æä¾›ç±»å‹å®‰å…¨ä¿è¯çš„åŒæ—¶ä¿æŒAPIçš„æ˜“ç”¨æ€§å’Œçµæ´»æ€§ã€‚

## æ³›å‹åœ¨ç‰¹å®šé¢†åŸŸçš„åº”ç”¨

### é”™è¯¯å¤„ç†æ¨¡å¼

Rustçš„é”™è¯¯å¤„ç†ç³»ç»Ÿå¹¿æ³›åº”ç”¨äº†æ³›å‹å’Œtraitç³»ç»Ÿï¼Œæä¾›äº†ç±»å‹å®‰å…¨ã€è¡¨è¾¾åŠ›å¼ºä¸”çµæ´»çš„é”™è¯¯å¤„ç†æœºåˆ¶ã€‚
æ³›å‹å…è®¸ä¸åŒç»„ä»¶å®šä¹‰å’Œä¼ æ’­å„è‡ªçš„é”™è¯¯ç±»å‹ï¼ŒåŒæ—¶ä¿æŒä»£ç çš„ç»„åˆæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

**åŸºç¡€æ³›å‹é”™è¯¯å¤„ç†**ï¼š

```rust
// Resultæ˜¯æœ€åŸºæœ¬çš„æ³›å‹é”™è¯¯å¤„ç†ç±»å‹
pub enum Result<T, E> {
    Ok(T),   // æˆåŠŸå€¼
    Err(E),  // é”™è¯¯å€¼
}

// åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹
fn divide(a: i32, b: i32) -> Result<i32, &'static str> {
    if b == 0 {
        Err("Cannot divide by zero")
    } else {
        Ok(a / b)
    }
}

// ä½¿ç”¨?è¿ç®—ç¬¦ä¼ æ’­é”™è¯¯
fn calculate(a: i32, b: i32) -> Result<i32, &'static str> {
    let division = divide(a, b)?;  // é”™è¯¯ä¼šæå‰è¿”å›
    Ok(division * 2)
}
```

**è‡ªå®šä¹‰é”™è¯¯ç±»å‹ä¸è½¬æ¢**ï¼š

```rust
// å®šä¹‰åº”ç”¨ç‰¹å®šé”™è¯¯ç±»å‹
#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    ValidationError(String),
}

// å®ç°é”™è¯¯è½¬æ¢
impl From<std::io::Error> for AppError {
    fn from(error: std::io::Error) -> Self {
        AppError::IoError(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::ParseError(error)
    }
}

// ä½¿ç”¨From traitå®ç°é”™è¯¯è½¬æ¢
fn read_config() -> Result<Config, AppError> {
    let data = std::fs::read_to_string("config.txt")?;  // IoErrorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    let value = data.parse::<i32>()?;  // ParseIntErrorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    
    if value < 0 {
        return Err(AppError::ValidationError("Value cannot be negative".into()));
    }
    
    Ok(Config { value })
}
```

**é”™è¯¯å¤„ç†æ³›å‹åº“**ï¼š

å®é™…é¡¹ç›®ä¸­å¸¸ç”¨çš„é”™è¯¯å¤„ç†åº“å¦‚`thiserror`å’Œ`anyhow`åˆ©ç”¨äº†æ³›å‹å’Œå®æ¥ç®€åŒ–é”™è¯¯å¤„ç†ï¼š

```rust
use thiserror::Error;

// ä½¿ç”¨æ´¾ç”Ÿå®å®šä¹‰ä¸°å¯Œçš„é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
enum ServiceError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Failed to parse data: {0}")]
    Parse(#[from] std::num::ParseIntError),
    
    #[error("Validation failed: {message}")]
    Validation { message: String },
    
    #[error("Database error: {0}")]
    Database(#[from] DatabaseError),
}

// ä½¿ç”¨anyhowå¤„ç†é€šç”¨é”™è¯¯
use anyhow::{Result, Context, bail, ensure};

fn process_data() -> Result<()> {
    let file = std::fs::File::open("data.txt")
        .context("Failed to open data file")?;
    
    let data = read_data(file)
        .context("Failed to read data")?;
    
    ensure!(data.is_valid(), "Data validation failed");
    
    if !process_is_allowed() {
        bail!("Processing is not allowed");
    }
    
    Ok(())
}
```

**æ³›å‹é”™è¯¯å¤„ç†æœåŠ¡**ï¼š

åœ¨å¤§å‹åº”ç”¨ç¨‹åºä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ³›å‹åˆ›å»ºé€šç”¨é”™è¯¯å¤„ç†æœåŠ¡ï¼š

```rust
// æ³›å‹é”™è¯¯å¤„ç†æœåŠ¡
trait ErrorHandler<E> {
    fn handle_error(&self, error: &E);
}

struct LoggingHandler;
struct MetricsHandler;

impl<E: std::fmt::Display> ErrorHandler<E> for LoggingHandler {
    fn handle_error(&self, error: &E) {
        log::error!("Error occurred: {}", error);
    }
}

impl<E> ErrorHandler<E> for MetricsHandler 
where 
    E: std::any::Any + 'static
{
    fn handle_error(&self, error: &E) {
        let type_name = std::any::type_name::<E>();
        metrics::increment_counter!("errors", "type" => type_name);
    }
}

// ä½¿ç”¨å¤šä¸ªå¤„ç†å™¨çš„æœåŠ¡
struct ErrorService<E> {
    handlers: Vec<Box<dyn ErrorHandler<E>>>,
}

impl<E> ErrorService<E> {
    fn new() -> Self {
        ErrorService { handlers: Vec::new() }
    }
    
    fn add_handler<H: ErrorHandler<E> + 'static>(&mut self, handler: H) {
        self.handlers.push(Box::new(handler));
    }
    
    fn handle(&self, error: &E) {
        for handler in &self.handlers {
            handler.handle_error(error);
        }
    }
}

// åœ¨åº”ç”¨ä¸­ä½¿ç”¨
let mut service = ErrorService::<ServiceError>::new();
service.add_handler(LoggingHandler);
service.add_handler(MetricsHandler);

// å¤„ç†é”™è¯¯
if let Err(e) = operation() {
    service.handle(&e);
}
```

**é«˜çº§é”™è¯¯ç±»å‹çŠ¶æ€æ¨¡å¼**ï¼š

æ³›å‹å’Œç±»å‹çŠ¶æ€å¯ä»¥åˆ›å»ºæ›´ç²¾ç»†çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼š

```rust
// æ³›å‹é”™è¯¯å¤„ç†Resultï¼Œå¸¦æœ‰é™„åŠ ä¸Šä¸‹æ–‡
struct ContextualResult<T, E, C> {
    result: Result<T, E>,
    context: C,
}

impl<T, E, C> ContextualResult<T, E, C> {
    fn new(result: Result<T, E>, context: C) -> Self {
        ContextualResult { result, context }
    }
    
    fn map<U, F>(self, f: F) -> ContextualResult<U, E, C>
    where
        F: FnOnce(T) -> U,
    {
        ContextualResult {
            result: self.result.map(f),
            context: self.context,
        }
    }
    
    fn map_err<G, F>(self, f: F) -> ContextualResult<T, G, C>
    where
        F: FnOnce(E) -> G,
    {
        ContextualResult {
            result: self.result.map_err(f),
            context: self.context,
        }
    }
    
    // é’ˆå¯¹ç‰¹å®šé”™è¯¯ç±»å‹çš„å¤„ç†æ–¹æ³•
    fn recover<F>(self, f: F) -> ContextualResult<T, E, C>
    where
        F: FnOnce(&E, &C) -> Option<T>,
    {
        match &self.result {
            Ok(_) => self,
            Err(e) => {
                if let Some(v) = f(e, &self.context) {
                    ContextualResult {
                        result: Ok(v),
                        context: self.context,
                    }
                } else {
                    self
                }
            }
        }
    }
}
```

**é”™è¯¯å¤„ç†æœ€ä½³å®è·µ**ï¼š

1. **ç±»å‹è®¾è®¡**ï¼š
   - ä½¿ç”¨æšä¸¾è¡¨ç¤ºç›¸å…³é”™è¯¯é›†åˆ
   - ä¸ºå…¬å…±APIå®šä¹‰ç‰¹å®šé”™è¯¯ç±»å‹
   - ä½¿ç”¨`From`è‡ªåŠ¨è½¬æ¢å¸¸è§é”™è¯¯

2. **ä¸Šä¸‹æ–‡ä¸°å¯Œæ€§**ï¼š
   - ä½¿ç”¨`context`æˆ–`.with_context()`æ·»åŠ ä¸Šä¸‹æ–‡
   - è€ƒè™‘åŒ…å«é”™è¯¯ä½ç½®ï¼ˆæ–‡ä»¶/è¡Œå·ï¼‰
   - ç»“æ„åŒ–é”™è¯¯è€Œéä»…å­—ç¬¦ä¸²

3. **æ€§èƒ½è€ƒè™‘**ï¼š
   - é¿å…é¢‘ç¹è·¯å¾„ä¸Šçš„è¿‡å¤šåˆ†é…
   - è€ƒè™‘ä¸å¤åˆ¶ï¼ˆnon-copyingï¼‰é”™è¯¯ç±»å‹
   - æ˜æ™ºåœ°ä½¿ç”¨é”™è¯¯å †æ ˆæ„å»º

Rustçš„æ³›å‹é”™è¯¯å¤„ç†ç³»ç»Ÿç»“åˆäº†é™æ€ç±»å‹å®‰å…¨å’Œè¡¨è¾¾åŠ›ï¼Œå…è®¸å¼€å‘è€…åˆ›å»ºç²¾ç¡®ã€å¯ç»„åˆå’Œå¯æ¢å¤çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œ
åŒæ—¶é¿å…äº†ä¼ ç»Ÿæ¨¡å¼ï¼ˆå¦‚å¼‚å¸¸ï¼‰çš„é—®é¢˜ã€‚è¿™ä¸€è®¾è®¡åœ¨ä¿æŒæ€§èƒ½çš„åŒæ—¶ï¼Œæé«˜äº†ä»£ç çš„å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### å¹¶å‘ä¸åŒæ­¥åŸè¯­

Rustçš„å¹¶å‘ç³»ç»Ÿå……åˆ†åˆ©ç”¨äº†æ³›å‹å’Œtraitç³»ç»Ÿï¼Œåˆ›å»ºäº†å®‰å…¨ã€è¡¨è¾¾åŠ›å¼ºä¸”é«˜æ€§èƒ½çš„å¹¶å‘åŸè¯­ã€‚
æ³›å‹åœ¨å¹¶å‘ç¼–ç¨‹ä¸­å°¤ä¸ºé‡è¦ï¼Œå®ƒå…è®¸åˆ›å»ºå¯é‡ç”¨çš„çº¿ç¨‹å®‰å…¨æŠ½è±¡ï¼ŒåŒæ—¶ä¿æŒç±»å‹å®‰å…¨å’Œé›¶æˆæœ¬æŠ½è±¡åŸåˆ™ã€‚

**åŸºç¡€çº¿ç¨‹å’Œæ•°æ®å…±äº«**ï¼š

```rust
use std::thread;
use std::sync::{Arc, Mutex};

// ä½¿ç”¨æ³›å‹åˆ›å»ºçº¿ç¨‹å®‰å…¨çš„å…±äº«æ•°æ®
fn process_data<T: Send + Sync + Clone + 'static>(data: T) {
    // Arc<T>æä¾›çº¿ç¨‹é—´å…±äº«æ‰€æœ‰æƒ
    let shared_data = Arc::new(data);
    
    let mut handles = vec![];
    
    for i in 0..5 {
        // å…‹éš†Arcä»¥ä¾¿åœ¨çº¿ç¨‹é—´å…±äº«
        let thread_data = Arc::clone(&shared_data);
        
        // å¯åŠ¨çº¿ç¨‹
        let handle = thread::spawn(move || {
            println!("Thread {}: processing {:?}", i, thread_data);
            // å¤„ç†æ•°æ®...
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for handle in handles {
        handle.join().unwrap();
    }
}

// çº¿ç¨‹å®‰å…¨çš„å¯å˜æ•°æ®
fn increment_counter<T: Send + 'static>(counter: &Arc<Mutex<T>>, increment: T)
where 
    T: std::ops::AddAssign + Copy
{
    let counter_clone = Arc::clone(counter);
    
    thread::spawn(move || {
        // äº’æ–¥é”ç¡®ä¿çº¿ç¨‹å®‰å…¨çš„ä¿®æ”¹
        let mut value = counter_clone.lock().unwrap();
        *value += increment;
    });
}
```

**æ³›å‹é€šé“å®ç°**ï¼š

é€šé“æ˜¯Rustä¸­å¸¸ç”¨çš„å¹¶å‘é€šä¿¡æœºåˆ¶ï¼Œä½¿ç”¨æ³›å‹æ”¯æŒä»»æ„ç±»å‹çš„æ¶ˆæ¯ä¼ é€’ï¼š

```rust
use std::sync::mpsc;

// åˆ›å»ºå·¥ä½œè€…çº¿ç¨‹å¤„ç†ä»»åŠ¡
fn start_worker<T, F>(processor: F) -> mpsc::Sender<T>
where
    T: Send + 'static,
    F: Fn(T) + Send + 'static,
{
    let (sender, receiver) = mpsc::channel::<T>();
    
    thread::spawn(move || {
        // æ¥æ”¶å¹¶å¤„ç†æ¶ˆæ¯
        for item in receiver {
            processor(item);
        }
    });
    
    sender
}

// æ³›å‹ä»»åŠ¡å¤„ç†ç³»ç»Ÿ
struct Worker<T> {
    sender: mpsc::Sender<T>,
}

impl<T: Send + 'static> Worker<T> {
    fn new<F>(processor: F) -> Self
    where
        F: Fn(T) + Send + 'static,
    {
        Worker {
            sender: start_worker(processor),
        }
    }
    
    fn submit(&self, task: T) -> Result<(), mpsc::SendError<T>> {
        self.sender.send(task)
    }
}

// ä½¿ç”¨
let string_worker = Worker::new(|s: String| {
    println!("Processing string: {}", s);
});

let number_worker = Worker::new(|n: i32| {
    println!("Processing number: {}", n);
});

string_worker.submit("hello".to_string()).unwrap();
number_worker.submit(42).unwrap();
```

**æ³›å‹åŒæ­¥åŸè¯­**ï¼š

Rustæä¾›äº†å¤šç§æ³›å‹åŒæ­¥åŸè¯­ï¼Œé€‚ç”¨äºä¸åŒçš„å¹¶å‘åœºæ™¯ï¼š

```rust
use std::sync::{Mutex, RwLock, Barrier, Condvar};

// äº’æ–¥é”ï¼šç‹¬å è®¿é—®
fn mutex_example<T: Send>(value: T) {
    let mutex = Mutex::new(value);
    
    // åœ¨é”ä¿æŠ¤ä¸‹ä¿®æ”¹å€¼
    {
        let mut guard = mutex.lock().unwrap();
        // ä¿®æ”¹ *guard...
    }
}

// è¯»å†™é”ï¼šå…±äº«è¯»/ç‹¬å å†™
fn rwlock_example<T: Send>(value: T) {
    let rwlock = RwLock::new(value);
    
    // å¤šä¸ªè¯»å–å™¨
    {
        let read_guard = rwlock.read().unwrap();
        // è¯»å– *read_guard...
    }
    
    // å•ä¸ªå†™å…¥å™¨
    {
        let mut write_guard = rwlock.write().unwrap();
        // ä¿®æ”¹ *write_guard...
    }
}

// å±éšœï¼šçº¿ç¨‹åŒæ­¥ç‚¹
fn barrier_example<F>(thread_count: usize, thread_fn: F)
where
    F: Fn(usize) + Send + Sync + 'static,
{
    let barrier = Arc::new(Barrier::new(thread_count));
    
    for id in 0..thread_count {
        let barrier_clone = Arc::clone(&barrier);
        let thread_fn = thread_fn.clone();
        
        thread::spawn(move || {
            // ç¬¬ä¸€é˜¶æ®µå·¥ä½œ
            println!("Thread {} performing phase 1", id);
            
            // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆç¬¬ä¸€é˜¶æ®µ
            barrier_clone.wait();
            
            // ç¬¬äºŒé˜¶æ®µå·¥ä½œ
            println!("Thread {} performing phase 2", id);
            thread_fn(id);
        });
    }
}

// æ¡ä»¶å˜é‡ï¼šç­‰å¾…æ¡ä»¶
fn condvar_example() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);
    
    // æ¶ˆè´¹è€…çº¿ç¨‹
    thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        let mut ready = lock.lock().unwrap();
        
        // ç­‰å¾…æ¡ä»¶ä¸ºtrue
        while !*ready {
            ready = cvar.wait(ready).unwrap();
        }
        
        println!("Consumer: Condition met!");
    });
    
    // ç”Ÿäº§è€…çº¿ç¨‹
    thread::sleep(Duration::from_secs(1));
    let (lock, cvar) = &*pair;
    let mut ready = lock.lock().unwrap();
    *ready = true;
    cvar.notify_one();
    println!("Producer: Notified consumer");
}
```

**é«˜çº§å¹¶å‘æŠ½è±¡**ï¼š

æ³›å‹å…è®¸åˆ›å»ºæ›´é«˜çº§çš„å¹¶å‘æŠ½è±¡ï¼Œå¦‚çº¿ç¨‹æ± å’Œå·¥ä½œé˜Ÿåˆ—ï¼š

```rust
// æ³›å‹çº¿ç¨‹æ± 
struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Box<dyn FnOnce() + Send + 'static>>,
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        assert!(size > 0);
        
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        
        let mut workers = Vec::with_capacity(size);
        
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }
        
        ThreadPool { workers, sender }
    }
    
    // æ³›å‹æ‰§è¡Œæ–¹æ³•
    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Box<dyn FnOnce() + Send>>>>) -> Self {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();
                println!("Worker {} got a job; executing.", id);
                job();
            }
        });
        
        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

**å¹¶å‘é›†åˆä¸æ•°æ®ç»“æ„**ï¼š

æ³›å‹å¹¶å‘æ•°æ®ç»“æ„æä¾›äº†ç±»å‹å®‰å…¨çš„å…±äº«çŠ¶æ€ï¼š

```rust
use std::collections::HashMap;
use std::sync::RwLock;

// çº¿ç¨‹å®‰å…¨çš„æ³›å‹ç¼“å­˜
struct ConcurrentCache<K, V> {
    data: RwLock<HashMap<K, V>>,
}

impl<K, V> ConcurrentCache<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    fn new() -> Self {
        ConcurrentCache {
            data: RwLock::new(HashMap::new()),
        }
    }
    
    fn get(&self, key: &K) -> Option<V> {
        let guard = self.data.read().unwrap();
        guard.get(key).cloned()
    }
    
    fn insert(&self, key: K, value: V) -> Option<V> {
        let mut guard = self.data.write().unwrap();
        guard.insert(key, value)
    }
    
    fn remove(&self, key: &K) -> Option<V> {
        let mut guard = self.data.write().unwrap();
        guard.remove(key)
    }
}
```

**ç±»å‹çŠ¶æ€çš„å¹¶å‘æ§åˆ¶**ï¼š

æ³›å‹å¯ä»¥ä¸ç±»å‹çŠ¶æ€æ¨¡å¼ç»“åˆï¼Œæä¾›æ›´ç²¾ç»†çš„å¹¶å‘æ§åˆ¶ï¼š

```rust
// æ ‡è®°ç±»å‹
struct Uninitialized;
struct Initialized;
struct Running;
struct Stopped;

// ç±»å‹çŠ¶æ€å·¥ä½œå™¨
struct Worker<S> {
    // å·¥ä½œå™¨çŠ¶æ€å’Œæ•°æ®
    data: Option<Vec<String>>,
    _state: PhantomData<S>,
}

impl Worker<Uninitialized> {
    fn new() -> Self {
        Worker {
            data: None,
            _state: PhantomData,
        }
    }
    
    fn initialize(self, data: Vec<String>) -> Worker<Initialized> {
        Worker {
            data: Some(data),
            _state: PhantomData,
        }
    }
}

impl Worker<Initialized> {
    fn start(self) -> (WorkerHandle, JoinHandle<Worker<Stopped>>) {
        let data = self.data.unwrap();
        let (tx, rx) = mpsc::channel();
        
        let handle = WorkerHandle { sender: tx };
        
        let join_handle = thread::spawn(move || {
            let mut worker = Worker::<Running> {
                data: Some(data),
                _state: PhantomData,
            };
            
            // å·¥ä½œå¾ªç¯
            for command in rx {
                // å¤„ç†å‘½ä»¤...
            }
            
            // è½¬æ¢ä¸ºStoppedçŠ¶æ€
            Worker {
                data: worker.data,
                _state: PhantomData,
            }
        });
        
        (handle, join_handle)
    }
}

struct WorkerHandle {
    sender: mpsc::Sender<Command>,
}

impl WorkerHandle {
    fn send_command(&self, command: Command) -> Result<(), mpsc::SendError<Command>> {
        self.sender.send(command)
    }
}

enum Command {
    Process,
    Pause,
    Stop,
}
```

å¹¶å‘å’ŒåŒæ­¥åŸè¯­æ˜¯Rustæ³›å‹ç³»ç»Ÿçš„é‡è¦åº”ç”¨é¢†åŸŸï¼Œé€šè¿‡ç»“åˆæ³›å‹ã€traitå’Œæ‰€æœ‰æƒç³»ç»Ÿï¼Œ
Rustèƒ½å¤Ÿåœ¨ç¼–è¯‘æ—¶æ•è·è®¸å¤šå¸¸è§çš„å¹¶å‘é”™è¯¯ï¼ŒåŒæ—¶æä¾›é«˜æ€§èƒ½å’Œè¡¨è¾¾åŠ›å¼ºçš„å¹¶å‘ç¼–ç¨‹æœºåˆ¶ã€‚

### å¼‚æ­¥ç¼–ç¨‹ä¸­çš„æ³›å‹

Rustçš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹æ·±åº¦æ•´åˆäº†æ³›å‹ç³»ç»Ÿï¼Œä½¿å¼€å‘è€…èƒ½å¤Ÿç¼–å†™é€šç”¨ã€ç±»å‹å®‰å…¨ä¸”é«˜æ€§èƒ½çš„å¼‚æ­¥ä»£ç ã€‚
æ³›å‹åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­çš„åº”ç”¨ä¸ºæ„å»ºå¤æ‚ä¸”å¯é çš„å¼‚æ­¥ç³»ç»Ÿæä¾›äº†åšå®åŸºç¡€ã€‚

**åŸºç¡€å¼‚æ­¥æ³›å‹**ï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// æ³›å‹Futureç‰¹è´¨
trait MyFuture {
    type Output;  // å…³è”ç±»å‹è¡¨ç¤ºFutureå®Œæˆæ—¶çš„ç»“æœç±»å‹
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

// å®ç°ç®€å•çš„æ³›å‹Future
struct Ready<T>(Option<T>);

impl<T> Future for Ready<T> {
    type Output = T;
    
    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<T> {
        Poll::Ready(self.0.take().expect("Future already polled"))
    }
}

// æ³›å‹å¼‚æ­¥å‡½æ•°
async fn process<T: AsRef<str>>(input: T) -> String {
    let s = input.as_ref();
    format!("Processed: {}", s)
}
```

**å¼‚æ­¥æµæ°´çº¿å’Œç»„åˆå™¨**ï¼š

æ³›å‹å…è®¸æ„å»ºçµæ´»çš„å¼‚æ­¥å¤„ç†æµæ°´çº¿ï¼š

```rust
use futures::stream::{self, StreamExt};
use futures::future::{self, FutureExt};

// æ³›å‹å¼‚æ­¥æ˜ å°„å‡½æ•°
async fn map_async<T, F, Fut, R>(items: Vec<T>, f: F) -> Vec<R>
where
    F: Fn(T) -> Fut + Clone,
    Fut: Future<Output = R>,
{
    let futures = items.into_iter().map(|item| f(item));
    future::join_all(futures).await
}

// æ³›å‹å¼‚æ­¥æµå¤„ç†
async fn process_stream<T, S, F, Fut, R>(stream: S, f: F) -> Vec<R>
where
    S: stream::Stream<Item = T> + Unpin,
    F: Fn(T) -> Fut + Clone,
    Fut: Future<Output = R>,
{
    stream.map(|item| f(item)).collect::<Vec<Fut>>().await
}

// ç»„åˆå¼‚æ­¥æ“ä½œ
async fn process_and_validate<T, F, V, FutP, FutV>(
    items: Vec<T>,
    processor: F,
    validator: V,
) -> Result<Vec<String>, Error>
where
    F: Fn(T) -> FutP + Clone,
    V: Fn(FutP::Output) -> FutV + Clone,
    FutP: Future,
    FutV: Future<Output = Result<String, Error>>,
{
    let processed = map_async(items, processor).await;
    let results = map_async(processed, validator).await;
    
    // æ”¶é›†æ‰€æœ‰ç»“æœ
    let mut output = Vec::new();
    for result in results {
        output.push(result?);
    }
    
    Ok(output)
}
```

**å¼‚æ­¥ç‰¹è´¨å¯¹è±¡**ï¼š

åŠ¨æ€åˆ†å‘åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­ä¹Ÿå¾ˆå¸¸ç”¨ï¼š

```rust
// å¼‚æ­¥å¤„ç†å™¨ç‰¹è´¨
trait AsyncProcessor {
    async fn process(&self, input: String) -> Result<String, Error>;
}

// å…·ä½“å®ç°
struct HttpProcessor;
struct FileProcessor;

impl AsyncProcessor for HttpProcessor {
    async fn process(&self, input: String) -> Result<String, Error> {
        // é€šè¿‡HTTPå¤„ç†...
        Ok(format!("HTTP processed: {}", input))
    }
}

impl AsyncProcessor for FileProcessor {
    async fn process(&self, input: String) -> Result<String, Error> {
        // é€šè¿‡æ–‡ä»¶ç³»ç»Ÿå¤„ç†...
        Ok(format!("File processed: {}", input))
    }
}

// ä½¿ç”¨åŠ¨æ€åˆ†å‘å¤„ç†è¾“å…¥
async fn handle_input(
    processor: &dyn AsyncProcessor,
    input: String,
) -> Result<String, Error> {
    processor.process(input).await
}

// åˆ›å»ºå¤„ç†å™¨æ³¨å†Œè¡¨
async fn process_all(
    processors: &HashMap<String, Box<dyn AsyncProcessor>>,
    inputs: HashMap<String, String>,
) -> Result<HashMap<String, String>, Error> {
    let mut results = HashMap::new();
    
    for (name, input) in inputs {
        if let Some(processor) = processors.get(&name) {
            let result = processor.process(input).await?;
            results.insert(name, result);
        }
    }
    
    Ok(results)
}
```

**æ³›å‹å¼‚æ­¥é€‚é…å™¨**ï¼š

æ³›å‹å¯ç”¨äºåˆ›å»ºå¼ºå¤§çš„å¼‚æ­¥é€‚é…å™¨ï¼š

```rust
// è‡ªåŠ¨é‡è¯•
async fn with_retry<F, Fut, T, E>(
    f: F,
    retries: usize,
    delay: Duration,
) -> Result<T, E>
where
    F: Fn() -> Fut + Clone,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Debug,
{
    let mut attempts = 0;
    loop {
        match f().await {
            Ok(value) => return Ok(value),
            Err(e) => {
                attempts += 1;
                if attempts > retries {
                    return Err(e);
                }
                println!("Attempt {} failed with {:?}, retrying after {:?}...", 
                         attempts, e, delay);
                tokio::time::sleep(delay).await;
            }
        }
    }
}

// è¶…æ—¶åŒ…è£…å™¨
async fn with_timeout<F, T>(
    future: F,
    timeout: Duration,
) -> Result<T, TimeoutError>
where
    F: Future<Output = T>,
{
    tokio::time::timeout(timeout, future).await
}

// å¸¦æ–­è·¯å™¨çš„æ‰§è¡Œ
struct CircuitBreaker {
    failures: AtomicUsize,
    threshold: usize,
    half_open: AtomicBool,
}

impl CircuitBreaker {
    async fn execute<F, Fut, T, E>(&self, f: F) -> Result<T, E>
    where
        F: Fn() -> Fut,
        Fut: Future<Output = Result<T, E>>,
        E: std::fmt::Debug,
    {
        if self.half_open.load(Ordering::SeqCst) {
            // åŠå¼€çŠ¶æ€
            match f().await {
                Ok(v) => {
                    self.failures.store(0, Ordering::SeqCst);
                    self.half_open.store(false, Ordering::SeqCst);
                    Ok(v)
                }
                Err(e) => {
                    self.half_open.store(false, Ordering::SeqCst);
                    Err(e)
                }
            }
        } else if self.failures.load(Ordering::SeqCst) >= self.threshold {
            // æ–­å¼€çŠ¶æ€
            Err(CircuitOpenError.into())
        } else {
            // é—­åˆçŠ¶æ€
            match f().await {
                Ok(v) => {
                    self.failures.store(0, Ordering::SeqCst);
                    Ok(v)
                }
                Err(e) => {
                    self.failures.fetch_add(1, Ordering::SeqCst);
                    Err(e)
                }
            }
        }
    }
}
```

**æ³›å‹å…³è”ç±»å‹åœ¨å¼‚æ­¥ä¸­çš„åº”ç”¨**ï¼š

```rust
// æ³›å‹å…³è”ç±»å‹åœ¨å¼‚æ­¥ç‰¹å¾ä¸­çš„åº”ç”¨
trait AsyncService {
    type Request;
    type Response;
    type Future<'a>: Future<Output = Result<Self::Response, Error>> + 'a
    where
        Self: 'a;
    
    fn process<'a>(&'a self, request: Self::Request) -> Self::Future<'a>;
}

// ç‰¹å®šæœåŠ¡å®ç°
struct UserService {
    db: Database,
}

struct User {
    id: i64,
    name: String,
}

struct GetUserRequest {
    id: i64,
}

impl AsyncService for UserService {
    type Request = GetUserRequest;
    type Response = User;
    type Future<'a> = Pin<Box<dyn Future<Output = Result<Self::Response, Error>> + 'a>>;
    
    fn process<'a>(&'a self, request: Self::Request) -> Self::Future<'a> {
        let db = &self.db;
        Box::pin(async move {
            let user = db.find_user(request.id).await?;
            Ok(user)
        })
    }
}

// æ³›å‹æœåŠ¡è°ƒç”¨è€…
struct ServiceClient<S: AsyncService> {
    service: S,
}

impl<S: AsyncService> ServiceClient<S> {
    async fn call(&self, request: S::Request) -> Result<S::Response, Error> {
        self.service.process(request).await
    }
}
```

**å¼‚æ­¥èµ„æºç®¡ç†**ï¼š

```rust
// æ³›å‹å¼‚æ­¥èµ„æºæ± 
struct ResourcePool<R> {
    resources: Mutex<Vec<R>>,
    max_size: usize,
    factory: Box<dyn Fn() -> Pin<Box<dyn Future<Output = R>>>>,
}

impl<R: 'static> ResourcePool<R> {
    fn new<F, Fut>(max_size: usize, factory: F) -> Self
    where
        F: Fn() -> Fut + 'static,
        Fut: Future<Output = R> + 'static,
    {
        let factory_boxed = Box::new(move || {
            let fut = factory();
            Box::pin(fut) as Pin<Box<dyn Future<Output = R>>>
        });
        
        ResourcePool {
            resources: Mutex::new(Vec::new()),
            max_size,
            factory: factory_boxed,
        }
    }
    
    async fn acquire(&self) -> ResourceGuard<R> {
        let resource = {
            let mut resources = self.resources.lock().unwrap();
            if let Some(resource) = resources.pop() {
                resource
            } else if resources.len() < self.max_size {
                (self.factory)().await
            } else {
                // ç­‰å¾…èµ„æºé‡Šæ”¾
                drop(resources);
                tokio::time::sleep(Duration::from_millis(10)).await;
                self.acquire().await;
                return;
            }
        };
        
        ResourceGuard {
            resource: Some(resource),
            pool: self,
        }
    }
    
    fn release(&self, resource: R) {
        let mut resources = self.resources.lock().unwrap();
        resources.push(resource);
    }
}

struct ResourceGuard<'a, R> {
    resource: Option<R>,
    pool: &'a ResourcePool<R>,
}

impl<'a, R> Drop for ResourceGuard<'a, R> {
    fn drop(&mut self) {
        if let Some(resource) = self.resource.take() {
            self.pool.release(resource);
        }
    }
}

impl<'a, R> Deref for ResourceGuard<'a, R> {
    type Target = R;
    
    fn deref(&self) -> &Self::Target {
        self.resource.as_ref().unwrap()
    }
}

impl<'a, R> DerefMut for ResourceGuard<'a, R> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.resource.as_mut().unwrap()
    }
}
```

**å¼‚æ­¥æ³›å‹ç­–ç•¥æ¨¡å¼**ï¼š

```rust
// å¼‚æ­¥ç­–ç•¥æ¥å£
trait AsyncStrategy<Input, Output, Error> {
    async fn execute(&self, input: Input) -> Result<Output, Error>;
}

// å…·ä½“ç­–ç•¥å®ç°
struct FastStrategy;
struct ReliableStrategy;

impl AsyncStrategy<String, String, Error> for FastStrategy {
    async fn execute(&self, input: String) -> Result<String, Error> {
        // å¿«é€Ÿä½†å¯èƒ½ä¸å¯é çš„å®ç°
        tokio::time::sleep(Duration::from_millis(10)).await;
        Ok(format!("Fast result for: {}", input))
    }
}

impl AsyncStrategy<String, String, Error> for ReliableStrategy {
    async fn execute(&self, input: String) -> Result<String, Error> {
        // å¯é ä½†è¾ƒæ…¢çš„å®ç°
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // å¤šæ¬¡é‡è¯•é€»è¾‘
        for attempt in 1..=3 {
            if attempt < 3 || rand::random::<f32>() < 0.9 {
                return Ok(format!("Reliable result for: {}", input));
            }
            
            tokio::time::sleep(Duration::from_millis(50)).await;
        }
        
        Err(Error::new("Operation failed after retries"))
    }
}

// æ³›å‹ä¸Šä¸‹æ–‡ä½¿ç”¨ç­–ç•¥
struct Context<I, O, E, S: AsyncStrategy<I, O, E>> {
    strategy: S,
}

impl<I, O, E, S: AsyncStrategy<I, O, E>> Context<I, O, E, S> {
    fn new(strategy: S) -> Self {
        Context { strategy }
    }
    
    async fn execute(&self, input: I) -> Result<O, E> {
        self.strategy.execute(input).await
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn process_with_strategy() {
    // é€‰æ‹©ç­–ç•¥
    let fast_context = Context::new(FastStrategy);
    let reliable_context = Context::new(ReliableStrategy);
    
    // æ ¹æ®éœ€è¦ä½¿ç”¨ä¸åŒç­–ç•¥
    let input = "test data".to_string();
    
    if is_critical_operation() {
        match reliable_context.execute(input).await {
            Ok(result) => println!("Got reliable result: {}", result),
            Err(e) => eprintln!("Error: {:?}", e),
        }
    } else {
        match fast_context.execute(input).await {
            Ok(result) => println!("Got fast result: {}", result),
            Err(e) => eprintln!("Error: {:?}", e),
        }
    }
}
```

**å¼‚æ­¥äº‹ä»¶ç³»ç»Ÿ**ï¼š

```rust
// æ³›å‹äº‹ä»¶ç³»ç»Ÿ
#[async_trait]
trait EventHandler<E> {
    async fn handle(&self, event: E) -> Result<(), Error>;
}

struct EventBus<E: Clone> {
    handlers: RwLock<Vec<Box<dyn EventHandler<E> + Send + Sync>>>,
}

impl<E: Clone + Send + Sync + 'static> EventBus<E> {
    fn new() -> Self {
        EventBus {
            handlers: RwLock::new(Vec::new()),
        }
    }
    
    fn register<H>(&self, handler: H)
    where
        H: EventHandler<E> + Send + Sync + 'static,
    {
        let mut handlers = self.handlers.write().unwrap();
        handlers.push(Box::new(handler));
    }
    
    async fn publish(&self, event: E) -> Result<(), Vec<Error>> {
        let handlers = self.handlers.read().unwrap();
        let mut futures = Vec::with_capacity(handlers.len());
        
        for handler in handlers.iter() {
            let event_clone = event.clone();
            futures.push(handler.handle(event_clone));
        }
        
        let results = future::join_all(futures).await;
        let errors = results.into_iter()
                           .filter_map(|r| r.err())
                           .collect::<Vec<_>>();
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[derive(Clone)]
struct UserCreatedEvent {
    user_id: String,
    email: String,
}

struct EmailNotifier;
struct AuditLogger;

#[async_trait]
impl EventHandler<UserCreatedEvent> for EmailNotifier {
    async fn handle(&self, event: UserCreatedEvent) -> Result<(), Error> {
        println!("Sending welcome email to: {}", event.email);
        // å‘é€ç”µå­é‚®ä»¶é€»è¾‘...
        Ok(())
    }
}

#[async_trait]
impl EventHandler<UserCreatedEvent> for AuditLogger {
    async fn handle(&self, event: UserCreatedEvent) -> Result<(), Error> {
        println!("Logging user creation: {}", event.user_id);
        // å®¡è®¡æ—¥å¿—è®°å½•é€»è¾‘...
        Ok(())
    }
}

async fn user_registration_flow() {
    let event_bus = EventBus::<UserCreatedEvent>::new();
    
    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    event_bus.register(EmailNotifier);
    event_bus.register(AuditLogger);
    
    // åˆ›å»ºå¹¶å‘å¸ƒäº‹ä»¶
    let event = UserCreatedEvent {
        user_id: "user123".to_string(),
        email: "user@example.com".to_string(),
    };
    
    if let Err(errors) = event_bus.publish(event).await {
        eprintln!("Errors while processing event: {:?}", errors);
    }
}
```

**å¼‚æ­¥ç¼–ç¨‹æœ€ä½³å®è·µ**ï¼š

1. **è®¾è®¡è€ƒé‡**ï¼š
   - è€ƒè™‘å¼‚æ­¥APIçš„å¯ç»„åˆæ€§å’Œå¯å–æ¶ˆæ€§
   - ä¼˜å…ˆä½¿ç”¨`Stream`è€Œéæ‰‹åŠ¨å®ç°è¿­ä»£å™¨
   - æ˜ç¡®åŒºåˆ†åŒæ­¥ä¸å¼‚æ­¥æ¥å£

2. **æ³›å‹ä½¿ç”¨**ï¼š
   - ä½¿ç”¨å…³è”ç±»å‹å‡å°‘ç±»å‹å‚æ•°æ•°é‡
   - ä¸ºå¤æ‚Futureå®ç°æä¾›æ„å»ºå™¨åŠŸèƒ½
   - å¯¹å…±äº«çŠ¶æ€ä½¿ç”¨é€‚å½“çš„åŒæ­¥åŸè¯­

3. **æ€§èƒ½è€ƒè™‘**ï¼š
   - æœ€å°åŒ–å †åˆ†é…å’ŒåŠ¨æ€åˆ†å‘
   - ä½¿ç”¨ä¸“æœ‰æ± è€Œéé¢‘ç¹åˆ›å»ºèµ„æº
   - å°å¿ƒé¿å…ä¸å¿…è¦çš„å…‹éš†å’Œå¤åˆ¶

Rustå¼‚æ­¥ç¼–ç¨‹ä¸­çš„æ³›å‹åº”ç”¨å±•ç¤ºäº†ç±»å‹ç³»ç»Ÿå¦‚ä½•æä¾›æŠ½è±¡èƒ½åŠ›ï¼ŒåŒæ—¶ä¿æŒæ€§èƒ½å’Œç±»å‹å®‰å…¨ã€‚
æ³›å‹å’Œç‰¹è´¨ç³»ç»Ÿå…±åŒå½¢æˆäº†é«˜å±‚æŠ½è±¡çš„å¼ºå¤§åŸºç¡€ï¼Œä½¿å¼€å‘è€…èƒ½å¤Ÿç¼–å†™é«˜æ•ˆã€å®‰å…¨å’Œå¯ç»„åˆçš„å¼‚æ­¥ä»£ç ã€‚

## æ€ç»´å¯¼å›¾

```text
Rustæ³›å‹ä¸å¤šæ€æœºåˆ¶
â”œâ”€â”€ åŸºç¡€è®¾è®¡å“²å­¦
â”‚   â”œâ”€â”€ é™æ€åˆ†å‘ä¸é›¶æˆæœ¬æŠ½è±¡
â”‚   â”œâ”€â”€ ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥
â”‚   â”œâ”€â”€ æ‰€æœ‰æƒç³»ç»Ÿä¸æ³›å‹é›†æˆ
â”‚   â””â”€â”€ è¡¨è¾¾åŠ›ä¸çº¦æŸå¹³è¡¡
â”œâ”€â”€ æ³›å‹åŸºç¡€
â”‚   â”œâ”€â”€ è¯­æ³•ä¸å£°æ˜
â”‚   â”œâ”€â”€ é»˜è®¤ç±»å‹å‚æ•°
â”‚   â”œâ”€â”€ æ³›å‹çº¦æŸ
â”‚   â”œâ”€â”€ whereå­å¥
â”‚   â””â”€â”€ å…³è”ç±»å‹
â”œâ”€â”€ ç‰¹è´¨ç³»ç»Ÿæ·±åº¦å‰–æ
â”‚   â”œâ”€â”€ ç‰¹è´¨å®šä¹‰ä¸å®ç°
â”‚   â”œâ”€â”€ ç‰¹è´¨çº¦æŸ
â”‚   â”œâ”€â”€ ç‰¹è´¨å¯¹è±¡ä¸åŠ¨æ€åˆ†å‘
â”‚   â”œâ”€â”€ å…³è”ç±»å‹ä¸GAT
â”‚   â””â”€â”€ ç‰¹è´¨ç»§æ‰¿ä¸ç»„åˆ
â”œâ”€â”€ é«˜çº§æ³›å‹æ¨¡å¼
â”‚   â”œâ”€â”€ ç±»å‹çŠ¶æ€æ¨¡å¼
â”‚   â”œâ”€â”€ CRTPæ¨¡å¼
â”‚   â”œâ”€â”€ æ ‡è®°ç±»å‹ä¸PhantomData
â”‚   â”œâ”€â”€ ç±»å‹å±‚çº§ä¸ç±»å‹æ ‘
â”‚   â””â”€â”€ é›¶å¤§å°ç±»å‹ä¼˜åŒ–
â”œâ”€â”€ é¢†åŸŸç‰¹å®šåº”ç”¨
â”‚   â”œâ”€â”€ æ„å»ºè€…æ¨¡å¼
â”‚   â”œâ”€â”€ é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ å¹¶å‘ä¸åŒæ­¥åŸè¯­
â”‚   â”œâ”€â”€ å¼‚æ­¥ç¼–ç¨‹
â”‚   â””â”€â”€ é›†åˆä¸å®¹å™¨è®¾è®¡
â”œâ”€â”€ é™åˆ¶ä¸æŒ‘æˆ˜
â”‚   â”œâ”€â”€ ç¼–è¯‘å¤æ‚æ€§
â”‚   â”œâ”€â”€ ç±»å‹æ¨å¯¼é™åˆ¶
â”‚   â”œâ”€â”€ é”™è¯¯ä¿¡æ¯å¯è¯»æ€§
â”‚   â””â”€â”€ å†…å­˜å¸ƒå±€è€ƒé‡
â””â”€â”€ ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”
    â”œâ”€â”€ C++æ¨¡æ¿ä¸Rustæ³›å‹å¯¹æ¯”
    â”œâ”€â”€ Java/C#æ³›å‹ä¸Rustæ³›å‹å¯¹æ¯”
    â”œâ”€â”€ Haskellç±»å‹ç±»ä¸Rustç‰¹è´¨å¯¹æ¯”
    â””â”€â”€ Goæ¥å£ä¸Rustç‰¹è´¨å¯¹æ¯”
```

Rustæ³›å‹ç³»ç»Ÿèåˆäº†å¤šç§ç¼–ç¨‹èŒƒå¼çš„ä¼˜ç‚¹ï¼Œåˆ›å»ºäº†ä¸€ä¸ªæ—¢æœ‰è¡¨è¾¾åŠ›åˆä¿æŒé«˜æ€§èƒ½çš„ç±»å‹ç³»ç»Ÿã€‚
é€šè¿‡é™æ€åˆ†å‘å’Œé›¶æˆæœ¬æŠ½è±¡åŸåˆ™ï¼ŒRustæä¾›äº†C++æ¨¡æ¿çš„æ€§èƒ½ä¼˜åŠ¿ï¼Œ
åŒæ—¶é€šè¿‡ç‰¹è´¨ç³»ç»Ÿæä¾›äº†ç±»ä¼¼Haskellç±»å‹ç±»çš„æŠ½è±¡èƒ½åŠ›ï¼Œå¹¶ç»“åˆäº†æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ã€‚
è¿™ç§è®¾è®¡ä½¿å¾—Rustèƒ½å¤Ÿåœ¨ä¿æŒç±»å‹å®‰å…¨å’Œé«˜æ€§èƒ½çš„åŒæ—¶ï¼Œæ”¯æŒå¤æ‚çš„æ³›å‹ç¼–ç¨‹èŒƒå¼ï¼Œ
ä¸ºå¼€å‘è€…æä¾›äº†å¼ºå¤§è€Œçµæ´»çš„å·¥å…·æ„å»ºå¯é çš„ç³»ç»Ÿã€‚
