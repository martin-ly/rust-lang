# é”™è¯¯å¤„ç†

## å…ƒæ•°æ®

- **æ¦‚å¿µID**: 09.01
- **æ¦‚å¿µåç§°**: é”™è¯¯å¤„ç† (Error Handling)
- **ç†è®ºå±‚æ¬¡**: ç¬¬äºŒå±‚ï¼šè¯­è¨€ç‰¹æ€§å½¢å¼åŒ–å±‚
- **ç›¸å…³æ¦‚å¿µ**: 09.02 (Resultç±»å‹), 09.03 (Optionç±»å‹), 09.04 (panicå¤„ç†)
- **éš¾åº¦çº§åˆ«**: ä¸­çº§

## å½¢å¼åŒ–å®šä¹‰

ä½¿ç”¨ç»Ÿä¸€ç¬¦å·ç³»ç»Ÿ(RFUSS)çš„å½¢å¼åŒ–å®šä¹‰ï¼š

```math
\text{Error}(E, R) \equiv \forall e \in E. \exists r \in R. \text{Handle}(e) \implies \text{Recover}(e, r)
```

å…¶ä¸­ï¼š

- $\text{Error}(E, R)$ è¡¨ç¤ºé”™è¯¯é›†åˆ $E$ å’Œæ¢å¤ç­–ç•¥é›†åˆ $R$
- $\forall e \in E$ è¡¨ç¤ºå¯¹æ‰€æœ‰é”™è¯¯ $e$ åœ¨é”™è¯¯é›†åˆ $E$ ä¸­
- $\exists r \in R$ è¡¨ç¤ºå­˜åœ¨æ¢å¤ç­–ç•¥ $r$ åœ¨æ¢å¤ç­–ç•¥é›†åˆ $R$ ä¸­
- $\text{Handle}(e)$ è¡¨ç¤ºå¤„ç†é”™è¯¯ $e$
- $\text{Recover}(e, r)$ è¡¨ç¤ºä½¿ç”¨ç­–ç•¥ $r$ ä»é”™è¯¯ $e$ ä¸­æ¢å¤

## ä»£ç æ˜ å°„

å½¢å¼åŒ–è¡¨ç¤ºä¸ä»£ç çš„å¯¹åº”å…³ç³»ï¼š

| å½¢å¼åŒ–è¡¨ç¤º | Rustä»£ç  | è¯´æ˜ |
|----------|---------|------|
| `Error(E, R)` | `Result<T, E>` | é”™è¯¯å¤„ç†ç±»å‹ |
| `âˆ€e âˆˆ E` | `match error` | å¤„ç†æ‰€æœ‰é”™è¯¯ |
| `âˆƒr âˆˆ R` | `map_err` | é”™è¯¯è½¬æ¢ç­–ç•¥ |
| `Handle(e)` | `?` æ“ä½œç¬¦ | é”™è¯¯ä¼ æ’­ |
| `Recover(e, r)` | `unwrap_or` | é”™è¯¯æ¢å¤ |

## åŸºç¡€ç¤ºä¾‹

æœ€å°åŒ–ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºé”™è¯¯å¤„ç†çš„æ ¸å¿ƒæ¦‚å¿µï¼š

```rust
use std::fs::File;
use std::io::{self, Read};

// åŸºæœ¬é”™è¯¯å¤„ç†
fn divide(a: i32, b: i32) -> Result<i32, &'static str> {
    if b == 0 {
        Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
    } else {
        Ok(a / b)
    }
}

// ä½¿ç”¨Resultç±»å‹
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// Optionç±»å‹å¤„ç†
fn find_element<T: PartialEq>(list: &[T], target: &T) -> Option<usize> {
    for (index, item) in list.iter().enumerate() {
        if item == target {
            return Some(index);
        }
    }
    None
}

fn main() {
    // åŸºæœ¬é”™è¯¯å¤„ç†
    match divide(10, 2) {
        Ok(result) => println!("é™¤æ³•ç»“æœ: {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
    
    match divide(10, 0) {
        Ok(result) => println!("é™¤æ³•ç»“æœ: {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
    
    // ä½¿ç”¨?æ“ä½œç¬¦
    let result = read_file("example.txt");
    match result {
        Ok(contents) => println!("æ–‡ä»¶å†…å®¹: {}", contents),
        Err(e) => println!("è¯»å–æ–‡ä»¶é”™è¯¯: {}", e),
    }
    
    // Optionç±»å‹ä½¿ç”¨
    let numbers = vec![1, 2, 3, 4, 5];
    match find_element(&numbers, &3) {
        Some(index) => println!("æ‰¾åˆ°å…ƒç´ åœ¨ç´¢å¼•: {}", index),
        None => println!("æœªæ‰¾åˆ°å…ƒç´ "),
    }
    
    match find_element(&numbers, &10) {
        Some(index) => println!("æ‰¾åˆ°å…ƒç´ åœ¨ç´¢å¼•: {}", index),
        None => println!("æœªæ‰¾åˆ°å…ƒç´ "),
    }
}
```

**è§£é‡Š**ï¼š

- `Result<T, E>` è¡¨ç¤ºå¯èƒ½æˆåŠŸè¿”å›ç±»å‹Tæˆ–å¤±è´¥è¿”å›é”™è¯¯E
- `?` æ“ä½œç¬¦è‡ªåŠ¨ä¼ æ’­é”™è¯¯
- `Option<T>` è¡¨ç¤ºå¯èƒ½åŒ…å«å€¼Tæˆ–ä¸ºç©º
- `match` è¯­å¥å¤„ç†æ‰€æœ‰å¯èƒ½çš„æƒ…å†µ

## è¿›é˜¶ç¤ºä¾‹

åœ¨å®é™…åœºæ™¯ä¸­åº”ç”¨é”™è¯¯å¤„ç†æ¦‚å¿µï¼š

```rust
use std::collections::HashMap;
use std::fmt;

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
enum ValidationError {
    TooShort(String),
    TooLong(String),
    InvalidCharacter(char),
    Empty,
}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ValidationError::TooShort(msg) => write!(f, "å¤ªçŸ­: {}", msg),
            ValidationError::TooLong(msg) => write!(f, "å¤ªé•¿: {}", msg),
            ValidationError::InvalidCharacter(c) => write!(f, "æ— æ•ˆå­—ç¬¦: {}", c),
            ValidationError::Empty => write!(f, "ä¸èƒ½ä¸ºç©º"),
        }
    }
}

// éªŒè¯å‡½æ•°
fn validate_username(username: &str) -> Result<String, ValidationError> {
    if username.is_empty() {
        return Err(ValidationError::Empty);
    }
    
    if username.len() < 3 {
        return Err(ValidationError::TooShort("ç”¨æˆ·åè‡³å°‘éœ€è¦3ä¸ªå­—ç¬¦".to_string()));
    }
    
    if username.len() > 20 {
        return Err(ValidationError::TooLong("ç”¨æˆ·åä¸èƒ½è¶…è¿‡20ä¸ªå­—ç¬¦".to_string()));
    }
    
    for c in username.chars() {
        if !c.is_alphanumeric() && c != '_' {
            return Err(ValidationError::InvalidCharacter(c));
        }
    }
    
    Ok(username.to_string())
}

// é”™è¯¯è½¬æ¢
fn process_user_input(input: &str) -> Result<String, String> {
    validate_username(input)
        .map_err(|e| format!("éªŒè¯å¤±è´¥: {}", e))
}

// ç»„åˆé”™è¯¯å¤„ç†
struct UserManager {
    users: HashMap<String, String>,
}

impl UserManager {
    fn new() -> Self {
        UserManager {
            users: HashMap::new(),
        }
    }
    
    fn add_user(&mut self, username: &str, email: &str) -> Result<(), String> {
        // éªŒè¯ç”¨æˆ·å
        let valid_username = validate_username(username)?;
        
        // éªŒè¯é‚®ç®±
        if !email.contains('@') {
            return Err("æ— æ•ˆçš„é‚®ç®±æ ¼å¼".to_string());
        }
        
        // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
        if self.users.contains_key(&valid_username) {
            return Err("ç”¨æˆ·åå·²å­˜åœ¨".to_string());
        }
        
        self.users.insert(valid_username, email.to_string());
        Ok(())
    }
    
    fn get_user(&self, username: &str) -> Option<&String> {
        self.users.get(username)
    }
    
    fn remove_user(&mut self, username: &str) -> Result<String, String> {
        self.users.remove(username)
            .ok_or_else(|| "ç”¨æˆ·ä¸å­˜åœ¨".to_string())
    }
}

// é”™è¯¯æ¢å¤ç­–ç•¥
fn safe_divide(a: f64, b: f64) -> Result<f64, &'static str> {
    if b == 0.0 {
        Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
    } else {
        Ok(a / b)
    }
}

fn calculate_average(numbers: &[f64]) -> f64 {
    if numbers.is_empty() {
        return 0.0; // é»˜è®¤å€¼
    }
    
    let sum: f64 = numbers.iter().sum();
    sum / numbers.len() as f64
}

fn main() {
    let mut user_manager = UserManager::new();
    
    // æµ‹è¯•ç”¨æˆ·æ·»åŠ 
    let test_cases = vec![
        ("john_doe", "john@example.com"),
        ("", "invalid@example.com"), // ç©ºç”¨æˆ·å
        ("ab", "short@example.com"), // å¤ªçŸ­
        ("very_long_username_that_exceeds_limit", "long@example.com"), // å¤ªé•¿
        ("user@name", "special@example.com"), // ç‰¹æ®Šå­—ç¬¦
        ("john_doe", "duplicate@example.com"), // é‡å¤ç”¨æˆ·å
    ];
    
    for (username, email) in test_cases {
        match user_manager.add_user(username, email) {
            Ok(_) => println!("âœ… æˆåŠŸæ·»åŠ ç”¨æˆ·: {}", username),
            Err(e) => println!("âŒ æ·»åŠ ç”¨æˆ·å¤±è´¥: {} - {}", username, e),
        }
    }
    
    // æµ‹è¯•ç”¨æˆ·æŸ¥è¯¢
    let usernames = vec!["john_doe", "nonexistent"];
    for username in usernames {
        match user_manager.get_user(username) {
            Some(email) => println!("ğŸ“§ ç”¨æˆ· {} çš„é‚®ç®±: {}", username, email),
            None => println!("â“ ç”¨æˆ· {} ä¸å­˜åœ¨", username),
        }
    }
    
    // æµ‹è¯•ç”¨æˆ·åˆ é™¤
    match user_manager.remove_user("john_doe") {
        Ok(email) => println!("ğŸ—‘ï¸  åˆ é™¤ç”¨æˆ·æˆåŠŸï¼Œé‚®ç®±: {}", email),
        Err(e) => println!("âŒ åˆ é™¤ç”¨æˆ·å¤±è´¥: {}", e),
    }
    
    // é”™è¯¯æ¢å¤ç¤ºä¾‹
    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let average = calculate_average(&numbers);
    println!("ğŸ“Š å¹³å‡å€¼: {}", average);
    
    let empty_numbers: Vec<f64> = vec![];
    let empty_average = calculate_average(&empty_numbers);
    println!("ğŸ“Š ç©ºåˆ—è¡¨å¹³å‡å€¼: {}", empty_average);
    
    // ä½¿ç”¨unwrap_oræä¾›é»˜è®¤å€¼
    let result = safe_divide(10.0, 0.0);
    let value = result.unwrap_or(0.0);
    println!("ğŸ”¢ å®‰å…¨é™¤æ³•ç»“æœ: {}", value);
}
```

**è§£é‡Š**ï¼š

- è‡ªå®šä¹‰é”™è¯¯ç±»å‹æä¾›æ›´ç²¾ç¡®çš„é”™è¯¯ä¿¡æ¯
- é”™è¯¯è½¬æ¢ä½¿ç”¨ `map_err` å’Œ `?` æ“ä½œç¬¦
- ç»„åˆé”™è¯¯å¤„ç†å¤„ç†å¤šä¸ªå¯èƒ½çš„é”™è¯¯æ¥æº
- é”™è¯¯æ¢å¤ç­–ç•¥æä¾›é»˜è®¤å€¼å’Œæ›¿ä»£æ–¹æ¡ˆ

## è¾¹ç•Œæƒ…å†µ

å±•ç¤ºé”™è¯¯å¤„ç†çš„è¾¹ç•Œæ¡ä»¶å’Œå¤æ‚æƒ…å†µï¼š

```rust
use std::panic::{catch_unwind, AssertUnwindSafe};
use std::sync::{Arc, Mutex};
use std::thread;

// panicå¤„ç†
fn safe_operation<F, T>(operation: F) -> Result<T, String>
where
    F: FnOnce() -> T + AssertUnwindSafe,
{
    catch_unwind(operation)
        .map_err(|e| format!("æ“ä½œå¤±è´¥: {:?}", e))
}

// é€’å½’é”™è¯¯å¤„ç†
fn recursive_operation(n: u32) -> Result<u32, String> {
    if n == 0 {
        return Ok(0);
    }
    
    if n > 1000 {
        return Err("é€’å½’æ·±åº¦è¿‡å¤§".to_string());
    }
    
    let prev = recursive_operation(n - 1)?;
    Ok(prev + n)
}

// å¼‚æ­¥é”™è¯¯å¤„ç†
async fn async_operation() -> Result<String, String> {
    // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    
    // æ¨¡æ‹Ÿéšæœºé”™è¯¯
    if rand::random::<bool>() {
        Ok("å¼‚æ­¥æ“ä½œæˆåŠŸ".to_string())
    } else {
        Err("å¼‚æ­¥æ“ä½œå¤±è´¥".to_string())
    }
}

// é”™è¯¯ä¼ æ’­é“¾
fn operation_chain() -> Result<String, String> {
    let step1 = perform_step1()?;
    let step2 = perform_step2(&step1)?;
    let step3 = perform_step3(&step2)?;
    Ok(step3)
}

fn perform_step1() -> Result<String, String> {
    Ok("æ­¥éª¤1å®Œæˆ".to_string())
}

fn perform_step2(input: &str) -> Result<String, String> {
    if input.contains("é”™è¯¯") {
        Err("æ­¥éª¤2å¤±è´¥".to_string())
    } else {
        Ok(format!("æ­¥éª¤2å¤„ç†: {}", input))
    }
}

fn perform_step3(input: &str) -> Result<String, String> {
    Ok(format!("æœ€ç»ˆç»“æœ: {}", input))
}

// é”™è¯¯èšåˆ
#[derive(Debug)]
struct ValidationResult {
    errors: Vec<String>,
    warnings: Vec<String>,
}

impl ValidationResult {
    fn new() -> Self {
        ValidationResult {
            errors: Vec::new(),
            warnings: Vec::new(),
        }
    }
    
    fn add_error(&mut self, error: String) {
        self.errors.push(error);
    }
    
    fn add_warning(&mut self, warning: String) {
        self.warnings.push(warning);
    }
    
    fn is_valid(&self) -> bool {
        self.errors.is_empty()
    }
    
    fn has_warnings(&self) -> bool {
        !self.warnings.is_empty()
    }
}

fn validate_complex_data(data: &str) -> ValidationResult {
    let mut result = ValidationResult::new();
    
    // æ£€æŸ¥é•¿åº¦
    if data.len() < 5 {
        result.add_error("æ•°æ®å¤ªçŸ­".to_string());
    } else if data.len() > 100 {
        result.add_warning("æ•°æ®è¾ƒé•¿".to_string());
    }
    
    // æ£€æŸ¥å­—ç¬¦
    if !data.chars().all(|c| c.is_alphanumeric()) {
        result.add_error("åŒ…å«éå­—æ¯æ•°å­—å­—ç¬¦".to_string());
    }
    
    // æ£€æŸ¥ç‰¹å®šæ¨¡å¼
    if data.contains("test") {
        result.add_warning("åŒ…å«æµ‹è¯•æ•°æ®".to_string());
    }
    
    result
}

// çº¿ç¨‹å®‰å…¨é”™è¯¯å¤„ç†
struct ThreadSafeCounter {
    count: Arc<Mutex<u32>>,
}

impl ThreadSafeCounter {
    fn new() -> Self {
        ThreadSafeCounter {
            count: Arc::new(Mutex::new(0)),
        }
    }
    
    fn increment(&self) -> Result<u32, String> {
        let mut count = self.count.lock()
            .map_err(|_| "æ— æ³•è·å–é”".to_string())?;
        
        *count += 1;
        Ok(*count)
    }
    
    fn get_count(&self) -> Result<u32, String> {
        let count = self.count.lock()
            .map_err(|_| "æ— æ³•è·å–é”".to_string())?;
        
        Ok(*count)
    }
}

fn main() {
    // panicå¤„ç†æµ‹è¯•
    let result = safe_operation(|| {
        // æ¨¡æ‹Ÿå¯èƒ½panicçš„æ“ä½œ
        let x = 10;
        let y = 0;
        x / y // è¿™ä¼španic
    });
    
    match result {
        Ok(value) => println!("æ“ä½œæˆåŠŸ: {}", value),
        Err(e) => println!("æ“ä½œå¤±è´¥: {}", e),
    }
    
    // é€’å½’é”™è¯¯å¤„ç†
    match recursive_operation(5) {
        Ok(result) => println!("é€’å½’ç»“æœ: {}", result),
        Err(e) => println!("é€’å½’é”™è¯¯: {}", e),
    }
    
    // é”™è¯¯ä¼ æ’­é“¾
    match operation_chain() {
        Ok(result) => println!("æ“ä½œé“¾ç»“æœ: {}", result),
        Err(e) => println!("æ“ä½œé“¾é”™è¯¯: {}", e),
    }
    
    // å¤æ‚éªŒè¯
    let test_data = vec![
        "short",
        "very_long_data_that_exceeds_normal_length_and_contains_test_pattern",
        "normal123",
        "invalid@data",
    ];
    
    for data in test_data {
        let validation = validate_complex_data(data);
        println!("éªŒè¯ '{}':", data);
        
        if validation.is_valid() {
            println!("  âœ… éªŒè¯é€šè¿‡");
        } else {
            println!("  âŒ éªŒè¯å¤±è´¥");
            for error in &validation.errors {
                println!("    é”™è¯¯: {}", error);
            }
        }
        
        if validation.has_warnings() {
            for warning in &validation.warnings {
                println!("    âš ï¸  è­¦å‘Š: {}", warning);
            }
        }
        println!();
    }
    
    // çº¿ç¨‹å®‰å…¨é”™è¯¯å¤„ç†
    let counter = ThreadSafeCounter::new();
    let counter_clone = counter.clone();
    
    let handle = thread::spawn(move || {
        for _ in 0..5 {
            match counter_clone.increment() {
                Ok(count) => println!("çº¿ç¨‹ä¸­è®¡æ•°: {}", count),
                Err(e) => println!("çº¿ç¨‹ä¸­é”™è¯¯: {}", e),
            }
        }
    });
    
    handle.join().unwrap();
    
    match counter.get_count() {
        Ok(count) => println!("æœ€ç»ˆè®¡æ•°: {}", count),
        Err(e) => println!("è·å–è®¡æ•°é”™è¯¯: {}", e),
    }
}

// ä¸ºThreadSafeCounterå®ç°Clone
impl Clone for ThreadSafeCounter {
    fn clone(&self) -> Self {
        ThreadSafeCounter {
            count: Arc::clone(&self.count),
        }
    }
}
```

**è§£é‡Š**ï¼š

- panicå¤„ç†ä½¿ç”¨ `catch_unwind` æ•è·panic
- é€’å½’é”™è¯¯å¤„ç†éœ€è¦æ·±åº¦é™åˆ¶
- å¼‚æ­¥é”™è¯¯å¤„ç†ä½¿ç”¨ `?` æ“ä½œç¬¦
- é”™è¯¯ä¼ æ’­é“¾å±•ç¤ºé”™è¯¯åœ¨å‡½æ•°é—´çš„ä¼ é€’
- é”™è¯¯èšåˆæ”¶é›†å¤šä¸ªé”™è¯¯å’Œè­¦å‘Š
- çº¿ç¨‹å®‰å…¨é”™è¯¯å¤„ç†å¤„ç†å¹¶å‘åœºæ™¯

## å¸¸è§é”™è¯¯

å±•ç¤ºä¸é”™è¯¯å¤„ç†ç›¸å…³çš„å¸¸è§é”™è¯¯åŠä¿®æ­£ï¼š

```rust
fn main() {
    // é”™è¯¯1: å¿½ç•¥é”™è¯¯
    // let file = File::open("nonexistent.txt").unwrap(); // é”™è¯¯ï¼šå¯èƒ½panic
    
    // é”™è¯¯2: ä¸å®Œæ•´çš„é”™è¯¯å¤„ç†
    // fn bad_function() -> Result<String, String> {
    //     let file = File::open("file.txt")?; // é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    //     Ok("success".to_string())
    // }
    
    // é”™è¯¯3: é”™è¯¯çš„é”™è¯¯ä¼ æ’­
    // fn wrong_propagation() -> Result<String, String> {
    //     let result: Result<String, io::Error> = read_file("file.txt");
    //     result // é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // }
    
    // é”™è¯¯4: å¿½ç•¥Option
    // let value = Some(42);
    // let result = value.unwrap(); // é”™è¯¯ï¼šå¦‚æœä¸ºNoneä¼španic
}
```

**é”™è¯¯åŸå› **ï¼š

- å¿½ç•¥é”™è¯¯ï¼šä½¿ç”¨ `unwrap()` å¯èƒ½å¯¼è‡´panic
- ä¸å®Œæ•´çš„é”™è¯¯å¤„ç†ï¼šé”™è¯¯ç±»å‹ä¸åŒ¹é…
- é”™è¯¯çš„é”™è¯¯ä¼ æ’­ï¼šè¿”å›ç±»å‹ä¸åŒ¹é…
- å¿½ç•¥Optionï¼šæ²¡æœ‰æ£€æŸ¥Noneæƒ…å†µ

**æ­£ç¡®ç‰ˆæœ¬**ï¼š

```rust
use std::fs::File;
use std::io;

fn main() {
    // ä¿®æ­£1: æ­£ç¡®å¤„ç†é”™è¯¯
    match File::open("nonexistent.txt") {
        Ok(file) => println!("æ–‡ä»¶æ‰“å¼€æˆåŠŸ"),
        Err(e) => println!("æ–‡ä»¶æ‰“å¼€å¤±è´¥: {}", e),
    }
    
    // ä¿®æ­£2: æ­£ç¡®çš„é”™è¯¯ç±»å‹
    fn good_function() -> Result<String, String> {
        let file = File::open("file.txt")
            .map_err(|e| format!("æ–‡ä»¶é”™è¯¯: {}", e))?;
        Ok("success".to_string())
    }
    
    // ä¿®æ­£3: æ­£ç¡®çš„é”™è¯¯ä¼ æ’­
    fn correct_propagation() -> Result<String, String> {
        let result: Result<String, io::Error> = read_file("file.txt");
        result.map_err(|e| format!("IOé”™è¯¯: {}", e))
    }
    
    // ä¿®æ­£4: æ­£ç¡®å¤„ç†Option
    let value = Some(42);
    match value {
        Some(v) => println!("å€¼: {}", v),
        None => println!("æ²¡æœ‰å€¼"),
    }
    
    // æˆ–è€…ä½¿ç”¨å®‰å…¨çš„æ–¹æ³•
    let result = value.unwrap_or(0);
    println!("å®‰å…¨å€¼: {}", result);
}

fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

## æ€§èƒ½è€ƒé‡

è®¨è®ºé”™è¯¯å¤„ç†çš„æ€§èƒ½ç‰¹æ€§ï¼š

- **é›¶æˆæœ¬æŠ½è±¡**ï¼šResultå’ŒOptionåœ¨è¿è¡Œæ—¶æ²¡æœ‰é¢å¤–å¼€é”€
- **é”™è¯¯ä¼ æ’­å¼€é”€**ï¼š`?` æ“ä½œç¬¦æœ‰å°‘é‡å¼€é”€
- **é”™è¯¯ç±»å‹å¤§å°**ï¼šé”™è¯¯ç±»å‹å½±å“Resultçš„å¤§å°
- **é”™è¯¯å¤„ç†åˆ†æ”¯**ï¼šé”™è¯¯å¤„ç†è·¯å¾„å¯èƒ½å½±å“æ€§èƒ½
- **é”™è¯¯èšåˆå¼€é”€**ï¼šæ”¶é›†å¤šä¸ªé”™è¯¯æœ‰å†…å­˜å¼€é”€

## æœ€ä½³å®è·µ

æä¾›ä½¿ç”¨é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µå»ºè®®ï¼š

1. **ä½¿ç”¨Resultè€Œä¸æ˜¯panic**ï¼šåœ¨åº“ä»£ç ä¸­é¿å…panic
2. **æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯**ï¼šé”™è¯¯ä¿¡æ¯åº”è¯¥å¸®åŠ©è°ƒè¯•
3. **ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹**ï¼šä¸ºç‰¹å®šé¢†åŸŸå®šä¹‰é”™è¯¯ç±»å‹
4. **æ­£ç¡®å¤„ç†Option**ï¼šä½¿ç”¨matchæˆ–å®‰å…¨çš„æ–¹æ³•
5. **é¿å…unwrap**ï¼šåœ¨ç”Ÿäº§ä»£ç ä¸­é¿å…ä½¿ç”¨unwrap
6. **ä½¿ç”¨é”™è¯¯è½¬æ¢**ï¼šä½¿ç”¨map_errè½¬æ¢é”™è¯¯ç±»å‹
7. **èšåˆé”™è¯¯**ï¼šæ”¶é›†å¤šä¸ªé”™è¯¯è€Œä¸æ˜¯åªæŠ¥å‘Šç¬¬ä¸€ä¸ª
8. **æµ‹è¯•é”™è¯¯è·¯å¾„**ï¼šç¼–å†™æµ‹è¯•éªŒè¯é”™è¯¯å¤„ç†

## ç›¸å…³èµ„æº

- [Rusté”™è¯¯å¤„ç†](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [Resultç±»å‹](https://doc.rust-lang.org/std/result/)
- [Optionç±»å‹](https://doc.rust-lang.org/std/option/)
- [thiserroråº“](https://docs.rs/thiserror/)
- [anyhowåº“](https://docs.rs/anyhow/)
