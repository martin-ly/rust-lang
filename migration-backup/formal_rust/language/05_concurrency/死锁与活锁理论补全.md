# 死锁与活锁理论补全

## 1. 形式化定义

- 死锁（Deadlock）：多个线程/进程因资源相互等待形成的循环依赖，导致系统无法推进。
  - 形式化：Wait-For Graph 存在有向环。
- 活锁（Livelock）：多个线程/进程持续变更状态但无实际进展。
- 饥饿（Starvation）：线程长期无法获得所需资源。

## 2. 检测算法与理论

- 资源分配图、Wait-For Graph建模。
- 死锁检测算法：环检测、Banker算法。
- 活锁/饥饿判定：状态转移分析、进展性判据。

## 3. 核心定理与证明

- 定理1（死锁必要条件）：互斥、占有且等待、不剥夺、循环等待四条件同时满足，系统可能死锁。
- 定理2（Wait-For Graph无环性）：Wait-For Graph无环，则系统无死锁。
- 定理3（活锁判定）：存在无限状态转移但无进展路径即为活锁。
- 定理4（饥饿判定）：存在线程长期无法获得资源即为饥饿。

## 4. 证明方法

- 状态机建模、图论分析、归纳证明、模型检验（TLA+）、自动化定理证明（Coq/Lean）。
- 自动化工具：Loom、TLA+、模型检测器。

## 5. 工程案例

- 多线程资源分配死锁检测与规避。
- 活锁场景：自旋重试导致无进展。
- 饥饿案例：优先级反转、资源长期占用。

## 6. 反例与边界

- 典型反例：双重加锁死锁、自旋活锁、优先级饥饿。
- 工程经验：加锁顺序、超时机制、优先级继承、自动化检测。

## 7. 未来趋势

- 分布式死锁检测、异步/分布式活锁规避、自动化验证工具链、工程集成。

---

> 本文档将持续递归补充，欢迎结合最新理论、工程案例、自动化工具、反例与前沿趋势递交补充，推动Rust并发死锁与活锁理论的形式化论证与证明体系不断进化。
