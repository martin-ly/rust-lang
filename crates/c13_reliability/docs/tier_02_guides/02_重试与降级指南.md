# C13 Reliability - Tier 2: é‡è¯•ä¸é™çº§æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 35 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C13 Reliability - Tier 2: é‡è¯•ä¸é™çº§æŒ‡å—](#c13-reliability---tier-2-é‡è¯•ä¸é™çº§æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. é‡è¯•ç­–ç•¥æ¦‚è¿°](#1-é‡è¯•ç­–ç•¥æ¦‚è¿°)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦é‡è¯•ï¼Ÿ](#11-ä¸ºä»€ä¹ˆéœ€è¦é‡è¯•)
    - [1.2 é‡è¯•ç­–ç•¥åˆ†ç±»](#12-é‡è¯•ç­–ç•¥åˆ†ç±»)
  - [2. åŸºç¡€é‡è¯•æ¨¡å¼](#2-åŸºç¡€é‡è¯•æ¨¡å¼)
    - [2.1 ç®€å•é‡è¯•](#21-ç®€å•é‡è¯•)
    - [2.2 çº¿æ€§é€€é¿](#22-çº¿æ€§é€€é¿)
    - [2.3 æŒ‡æ•°é€€é¿](#23-æŒ‡æ•°é€€é¿)
  - [3. é«˜çº§é‡è¯•ç­–ç•¥](#3-é«˜çº§é‡è¯•ç­–ç•¥)
    - [3.1 å¸¦æŠ–åŠ¨çš„æŒ‡æ•°é€€é¿](#31-å¸¦æŠ–åŠ¨çš„æŒ‡æ•°é€€é¿)
    - [3.2 æ¡ä»¶é‡è¯•](#32-æ¡ä»¶é‡è¯•)
    - [3.3 å¹‚ç­‰æ€§ä¿è¯](#33-å¹‚ç­‰æ€§ä¿è¯)
  - [4. é™çº§ç­–ç•¥](#4-é™çº§ç­–ç•¥)
    - [4.1 é™çº§åŸåˆ™](#41-é™çº§åŸåˆ™)
    - [4.2 å¤šçº§é™çº§](#42-å¤šçº§é™çº§)
    - [4.3 é»˜è®¤å€¼é™çº§](#43-é»˜è®¤å€¼é™çº§)
  - [5. æ–­è·¯å™¨æ¨¡å¼](#5-æ–­è·¯å™¨æ¨¡å¼)
    - [5.1 ä¸‰æ€æ–­è·¯å™¨](#51-ä¸‰æ€æ–­è·¯å™¨)
    - [5.2 äº”æ€æ–­è·¯å™¨](#52-äº”æ€æ–­è·¯å™¨)
    - [5.3 æ–­è·¯å™¨é…ç½®](#53-æ–­è·¯å™¨é…ç½®)
  - [6. è¶…æ—¶æ§åˆ¶](#6-è¶…æ—¶æ§åˆ¶)
    - [6.1 è¯·æ±‚è¶…æ—¶](#61-è¯·æ±‚è¶…æ—¶)
    - [6.2 æ€»è¶…æ—¶æ§åˆ¶](#62-æ€»è¶…æ—¶æ§åˆ¶)
    - [6.3 çº§è”è¶…æ—¶](#63-çº§è”è¶…æ—¶)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 API è°ƒç”¨é‡è¯•](#71-api-è°ƒç”¨é‡è¯•)
    - [7.2 æ•°æ®åº“è¿æ¥é‡è¯•](#72-æ•°æ®åº“è¿æ¥é‡è¯•)
    - [7.3 å®Œæ•´å¼¹æ€§ç³»ç»Ÿ](#73-å®Œæ•´å¼¹æ€§ç³»ç»Ÿ)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. é‡è¯•ç­–ç•¥æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦é‡è¯•ï¼Ÿ

**å¸¸è§æ•…éšœåœºæ™¯**:

| æ•…éšœç±»å‹ | æ˜¯å¦åº”é‡è¯• | é‡è¯•ç­–ç•¥ |
|---------|----------|---------|
| **ç½‘ç»œè¶…æ—¶** | âœ… æ˜¯ | æŒ‡æ•°é€€é¿ |
| **æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ (503)** | âœ… æ˜¯ | æŒ‡æ•°é€€é¿ + æŠ–åŠ¨ |
| **é™æµ (429)** | âœ… æ˜¯ | æ ¹æ® Retry-After |
| **å®¢æˆ·ç«¯é”™è¯¯ (400)** | âŒ å¦ | ç«‹å³å¤±è´¥ |
| **è®¤è¯å¤±è´¥ (401)** | âŒ å¦ | ç«‹å³å¤±è´¥ |
| **èµ„æºæœªæ‰¾åˆ° (404)** | âŒ å¦ | ç«‹å³å¤±è´¥ |

### 1.2 é‡è¯•ç­–ç•¥åˆ†ç±»

```rust
#[derive(Debug, Clone)]
pub enum RetryStrategy {
    /// å›ºå®šé—´éš”é‡è¯•
    Fixed { interval: Duration },
    
    /// çº¿æ€§é€€é¿
    Linear { base_interval: Duration, increment: Duration },
    
    /// æŒ‡æ•°é€€é¿
    Exponential { base_interval: Duration, max_interval: Duration },
    
    /// æŒ‡æ•°é€€é¿ + éšæœºæŠ–åŠ¨
    ExponentialWithJitter {
        base_interval: Duration,
        max_interval: Duration,
        jitter_factor: f64,  // 0.0 - 1.0
    },
    
    /// è‡ªå®šä¹‰é€€é¿å‡½æ•°
    Custom(Box<dyn Fn(u32) -> Duration + Send + Sync>),
}
```

---

## 2. åŸºç¡€é‡è¯•æ¨¡å¼

### 2.1 ç®€å•é‡è¯•

```rust
use std::time::Duration;
use tokio::time::sleep;

/// ç®€å•é‡è¯•ï¼šå›ºå®šæ¬¡æ•°ï¼Œå›ºå®šé—´éš”
async fn simple_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn example() -> Result<String, reqwest::Error> {
    simple_retry(
        || Box::pin(async {
            reqwest::get("https://api.example.com/data")
                .await?
                .text()
                .await
        }),
        3,  // æœ€å¤šé‡è¯•3æ¬¡
        Duration::from_secs(1),  // æ¯æ¬¡é—´éš”1ç§’
    ).await
}
```

### 2.2 çº¿æ€§é€€é¿

```rust
use std::time::Duration;
use tokio::time::sleep;

/// çº¿æ€§é€€é¿ï¼šå»¶è¿Ÿçº¿æ€§å¢é•¿
async fn linear_backoff_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    base_delay: Duration,
    increment: Duration,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                let delay = base_delay + increment * attempts;
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// å»¶è¿Ÿåºåˆ—: 1s, 2s, 3s, 4s, ...
```

### 2.3 æŒ‡æ•°é€€é¿

```rust
use std::time::Duration;
use tokio::time::sleep;

/// æŒ‡æ•°é€€é¿ï¼šå»¶è¿ŸæŒ‡æ•°å¢é•¿
async fn exponential_backoff_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    base_delay: Duration,
    max_delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                let delay = std::cmp::min(
                    base_delay * 2_u32.pow(attempts - 1),
                    max_delay,
                );
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// å»¶è¿Ÿåºåˆ—: 100ms, 200ms, 400ms, 800ms, 1600ms, ...
// æœ€å¤§å»¶è¿Ÿ: max_delay
```

---

## 3. é«˜çº§é‡è¯•ç­–ç•¥

### 3.1 å¸¦æŠ–åŠ¨çš„æŒ‡æ•°é€€é¿

```rust
use std::time::Duration;
use tokio::time::sleep;
use rand::Rng;

/// å¸¦æŠ–åŠ¨çš„æŒ‡æ•°é€€é¿ï¼šé¿å…æƒŠç¾¤æ•ˆåº”
async fn exponential_backoff_with_jitter<F, T, E>(
    mut operation: F,
    max_retries: u32,
    base_delay: Duration,
    max_delay: Duration,
    jitter_factor: f64,  // 0.0 - 1.0
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    let mut rng = rand::thread_rng();
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                
                // è®¡ç®—åŸºç¡€å»¶è¿Ÿ
                let base = std::cmp::min(
                    base_delay * 2_u32.pow(attempts - 1),
                    max_delay,
                );
                
                // æ·»åŠ éšæœºæŠ–åŠ¨
                let jitter_range = base.as_millis() as f64 * jitter_factor;
                let jitter = rng.gen_range(-jitter_range..jitter_range) as i64;
                let delay = Duration::from_millis(
                    (base.as_millis() as i64 + jitter).max(0) as u64
                );
                
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// å»¶è¿Ÿåºåˆ—ï¼ˆæŠ–åŠ¨ 20%ï¼‰: 
// 100ms Â± 20ms, 200ms Â± 40ms, 400ms Â± 80ms, ...
```

### 3.2 æ¡ä»¶é‡è¯•

```rust
use std::error::Error;

/// æ¡ä»¶é‡è¯•ï¼šæ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¯•
async fn conditional_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    should_retry: impl Fn(&E) -> bool,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries && should_retry(&e) => {
                attempts += 1;
                println!("Retryable error, attempt {}", attempts);
                tokio::time::sleep(Duration::from_millis(100 * 2_u64.pow(attempts - 1))).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
use reqwest::StatusCode;

async fn fetch_with_conditional_retry(url: &str) -> Result<String, reqwest::Error> {
    conditional_retry(
        || Box::pin(reqwest::get(url).and_then(|r| r.text())),
        3,
        |e: &reqwest::Error| {
            // åªå¯¹ä¸´æ—¶æ€§é”™è¯¯é‡è¯•
            e.is_timeout() || e.is_connect() || 
            e.status().map_or(false, |s| s == StatusCode::TOO_MANY_REQUESTS || s.is_server_error())
        }
    ).await
}
```

### 3.3 å¹‚ç­‰æ€§ä¿è¯

```rust
use uuid::Uuid;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

/// å¹‚ç­‰æ€§ä»¤ç‰Œç®¡ç†å™¨
struct IdempotencyManager {
    processed_tokens: Arc<Mutex<HashMap<String, String>>>,
}

impl IdempotencyManager {
    fn new() -> Self {
        Self {
            processed_tokens: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    /// ç”Ÿæˆå¹‚ç­‰æ€§ä»¤ç‰Œ
    fn generate_token(&self) -> String {
        Uuid::new_v4().to_string()
    }
    
    /// æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦å·²å¤„ç†
    async fn check_token(&self, token: &str) -> Option<String> {
        self.processed_tokens.lock().await.get(token).cloned()
    }
    
    /// è®°å½•å¤„ç†ç»“æœ
    async fn record_result(&self, token: String, result: String) {
        self.processed_tokens.lock().await.insert(token, result);
    }
}

/// å¹‚ç­‰æ€§é‡è¯•åŒ…è£…å™¨
async fn retry_with_idempotency<F, T>(
    manager: &IdempotencyManager,
    mut operation: F,
    max_retries: u32,
) -> Result<T, String>
where
    F: FnMut(String) -> futures::future::BoxFuture<'static, Result<T, String>>,
    T: std::fmt::Display + Clone,
{
    let token = manager.generate_token();
    
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    if let Some(cached_result) = manager.check_token(&token).await {
        println!("Returning cached result for token {}", token);
        // è¿™é‡Œç®€åŒ–äº†ï¼Œå®é™…éœ€è¦ååºåˆ—åŒ–
        return Err("Cached result".to_string());
    }
    
    let mut attempts = 0;
    
    loop {
        match operation(token.clone()).await {
            Ok(result) => {
                // è®°å½•æˆåŠŸç»“æœ
                manager.record_result(token.clone(), format!("{}", result)).await;
                return Ok(result);
            }
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("Attempt {} failed: {}, retrying...", attempts, e);
                tokio::time::sleep(Duration::from_secs(1)).await;
            }
            Err(e) => return Err(e),
        }
    }
}
```

---

## 4. é™çº§ç­–ç•¥

### 4.1 é™çº§åŸåˆ™

**é™çº§è§¦å‘æ¡ä»¶**:

1. **å“åº”è¶…æ—¶**: æœåŠ¡å“åº”æ—¶é—´è¶…è¿‡é˜ˆå€¼
2. **é”™è¯¯ç‡è¿‡é«˜**: é”™è¯¯ç‡è¶…è¿‡ 50%
3. **æ–­è·¯å™¨æ‰“å¼€**: æœåŠ¡å®Œå…¨ä¸å¯ç”¨
4. **èµ„æºè€—å°½**: å†…å­˜ã€CPUã€è¿æ¥æ± ç­‰èµ„æºä¸è¶³

### 4.2 å¤šçº§é™çº§

```rust
use std::time::Duration;
use tokio::time::timeout;

/// å¤šçº§é™çº§ç­–ç•¥
async fn fetch_user_data_with_fallback(user_id: u64) -> Result<UserData, String> {
    // çº§åˆ«1: ä¸»æœåŠ¡
    match timeout(
        Duration::from_secs(2),
        fetch_from_primary_service(user_id)
    ).await {
        Ok(Ok(data)) => {
            println!("âœ… Level 1: Primary service");
            return Ok(data);
        }
        Ok(Err(e)) => println!("âŒ Level 1 failed: {}", e),
        Err(_) => println!("â±ï¸ Level 1 timeout"),
    }
    
    // çº§åˆ«2: å¤‡ç”¨æœåŠ¡
    match timeout(
        Duration::from_secs(1),
        fetch_from_secondary_service(user_id)
    ).await {
        Ok(Ok(data)) => {
            println!("âœ… Level 2: Secondary service");
            return Ok(data);
        }
        Ok(Err(e)) => println!("âŒ Level 2 failed: {}", e),
        Err(_) => println!("â±ï¸ Level 2 timeout"),
    }
    
    // çº§åˆ«3: ç¼“å­˜
    match fetch_from_cache(user_id).await {
        Ok(data) => {
            println!("âœ… Level 3: Cache (may be stale)");
            return Ok(data);
        }
        Err(e) => println!("âŒ Level 3 failed: {}", e),
    }
    
    // çº§åˆ«4: é»˜è®¤å€¼
    println!("âš ï¸ Level 4: Default fallback");
    Ok(UserData::default_for(user_id))
}

async fn fetch_from_primary_service(user_id: u64) -> Result<UserData, String> {
    // æ¨¡æ‹Ÿä¸»æœåŠ¡è°ƒç”¨
    Err("Primary service unavailable".to_string())
}

async fn fetch_from_secondary_service(user_id: u64) -> Result<UserData, String> {
    // æ¨¡æ‹Ÿå¤‡ç”¨æœåŠ¡è°ƒç”¨
    Err("Secondary service unavailable".to_string())
}

async fn fetch_from_cache(user_id: u64) -> Result<UserData, String> {
    // æ¨¡æ‹Ÿç¼“å­˜è¯»å–
    Ok(UserData {
        id: user_id,
        name: format!("Cached User {}", user_id),
        email: format!("user{}@cached.com", user_id),
    })
}

#[derive(Debug, Clone)]
struct UserData {
    id: u64,
    name: String,
    email: String,
}

impl UserData {
    fn default_for(id: u64) -> Self {
        Self {
            id,
            name: format!("Guest {}", id),
            email: "guest@example.com".to_string(),
        }
    }
}
```

### 4.3 é»˜è®¤å€¼é™çº§

```rust
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;

/// é™æ€é»˜è®¤å€¼
const DEFAULT_CONFIG: &str = r#"{
    "max_connections": 100,
    "timeout_secs": 30,
    "retry_attempts": 3
}"#;

/// é…ç½®æœåŠ¡ï¼ˆå¸¦é™çº§ï¼‰
struct ConfigService {
    cache: Arc<RwLock<HashMap<String, String>>>,
}

impl ConfigService {
    fn new() -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// è·å–é…ç½®ï¼ˆå¸¦é™çº§ï¼‰
    async fn get_config(&self, key: &str) -> String {
        // 1. å°è¯•ä»è¿œç¨‹è·å–
        match self.fetch_from_remote(key).await {
            Ok(value) => {
                // æ›´æ–°ç¼“å­˜
                self.cache.write().await.insert(key.to_string(), value.clone());
                return value;
            }
            Err(e) => println!("Remote fetch failed: {}, trying cache...", e),
        }
        
        // 2. å°è¯•ä»ç¼“å­˜è·å–
        if let Some(cached) = self.cache.read().await.get(key) {
            println!("âš ï¸ Using cached value for '{}'", key);
            return cached.clone();
        }
        
        // 3. è¿”å›é»˜è®¤å€¼
        println!("âš ï¸ Using default value for '{}'", key);
        DEFAULT_CONFIG.to_string()
    }
    
    async fn fetch_from_remote(&self, key: &str) -> Result<String, String> {
        // æ¨¡æ‹Ÿè¿œç¨‹è°ƒç”¨
        Err("Remote service unavailable".to_string())
    }
}
```

---

## 5. æ–­è·¯å™¨æ¨¡å¼

### 5.1 ä¸‰æ€æ–­è·¯å™¨

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, Ordering};
use tokio::sync::Mutex;
use tokio::time::{Instant, Duration};

#[derive(Debug, Clone, Copy, PartialEq)]
enum CircuitState {
    Closed,   // æ­£å¸¸ï¼šè¯·æ±‚é€šè¿‡
    Open,     // æ–­å¼€ï¼šæ‹’ç»è¯·æ±‚
    HalfOpen, // åŠå¼€ï¼šå°è¯•æ¢å¤
}

struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: AtomicU32,
    success_count: AtomicU32,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
    failure_threshold: u32,
    success_threshold: u32,
    timeout: Duration,
}

impl CircuitBreaker {
    fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: AtomicU32::new(0),
            success_count: AtomicU32::new(0),
            last_failure_time: Arc::new(Mutex::new(None)),
            failure_threshold,
            success_threshold: 3,
            timeout,
        }
    }
    
    async fn call<F, T>(&self, operation: F) -> Result<T, String>
    where
        F: std::future::Future<Output = Result<T, String>>,
    {
        // æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
        let mut state = self.state.lock().await;
        
        match *state {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦è¶…æ—¶ï¼Œå¯ä»¥è½¬ä¸ºåŠå¼€çŠ¶æ€
                let last_failure = self.last_failure_time.lock().await;
                if let Some(time) = *last_failure {
                    if time.elapsed() >= self.timeout {
                        *state = CircuitState::HalfOpen;
                        self.success_count.store(0, Ordering::SeqCst);
                        println!("ğŸŸ¡ Circuit breaker: OPEN â†’ HALF_OPEN");
                    } else {
                        return Err("Circuit breaker is OPEN".to_string());
                    }
                }
            }
            CircuitState::HalfOpen => {
                // åŠå¼€çŠ¶æ€ï¼Œå…è®¸å°‘é‡è¯·æ±‚å°è¯•
            }
            CircuitState::Closed => {
                // æ­£å¸¸çŠ¶æ€
            }
        }
        
        drop(state);
        
        // æ‰§è¡Œæ“ä½œ
        match operation.await {
            Ok(result) => {
                // æˆåŠŸ
                self.success_count.fetch_add(1, Ordering::SeqCst);
                let mut state = self.state.lock().await;
                
                if *state == CircuitState::HalfOpen {
                    let successes = self.success_count.load(Ordering::SeqCst);
                    if successes >= self.success_threshold {
                        *state = CircuitState::Closed;
                        self.failure_count.store(0, Ordering::SeqCst);
                        println!("ğŸŸ¢ Circuit breaker: HALF_OPEN â†’ CLOSED");
                    }
                }
                
                Ok(result)
            }
            Err(e) => {
                // å¤±è´¥
                let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;
                *self.last_failure_time.lock().await = Some(Instant::now());
                
                let mut state = self.state.lock().await;
                
                if *state == CircuitState::HalfOpen {
                    // åŠå¼€çŠ¶æ€å¤±è´¥ï¼Œç«‹å³è½¬ä¸ºæ‰“å¼€
                    *state = CircuitState::Open;
                    println!("ğŸ”´ Circuit breaker: HALF_OPEN â†’ OPEN");
                } else if failures >= self.failure_threshold {
                    // å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œæ‰“å¼€æ–­è·¯å™¨
                    *state = CircuitState::Open;
                    println!("ğŸ”´ Circuit breaker: CLOSED â†’ OPEN (failures: {})", failures);
                }
                
                Err(e)
            }
        }
    }
}
```

### 5.2 äº”æ€æ–­è·¯å™¨

C13 Reliability æ¨¡å—å®ç°äº†æ›´é«˜çº§çš„**äº”æ€æ–­è·¯å™¨**ï¼š

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
enum AdvancedCircuitState {
    Closed,        // æ­£å¸¸
    HalfOpen,      // å°è¯•æ¢å¤
    Open,          // å®Œå…¨æ–­å¼€
    ForcedOpen,    // å¼ºåˆ¶æ–­å¼€ï¼ˆç®¡ç†å‘˜æ“ä½œï¼‰
    Disabled,      // ç¦ç”¨ï¼ˆæ—è·¯ï¼‰
}
```

**äº”æ€ä¼˜åŠ¿**:

- **ForcedOpen**: ç”¨äºç´§æ€¥ç»´æŠ¤æˆ–ç‰ˆæœ¬åˆ‡æ¢
- **Disabled**: ç”¨äºè°ƒè¯•æˆ–ä¸´æ—¶ç¦ç”¨ä¿æŠ¤æœºåˆ¶

### 5.3 æ–­è·¯å™¨é…ç½®

```rust
struct CircuitBreakerConfig {
    /// å¤±è´¥é˜ˆå€¼
    failure_threshold: u32,
    
    /// æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€ â†’ å…³é—­ï¼‰
    success_threshold: u32,
    
    /// è¶…æ—¶æ—¶é—´ï¼ˆæ‰“å¼€ â†’ åŠå¼€ï¼‰
    timeout: Duration,
    
    /// æ»‘åŠ¨çª—å£å¤§å°
    window_size: usize,
    
    /// æœ€å°è¯·æ±‚æ•°
    min_requests: u32,
    
    /// é”™è¯¯ç‡é˜ˆå€¼ (0.0 - 1.0)
    error_rate_threshold: f64,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            success_threshold: 2,
            timeout: Duration::from_secs(60),
            window_size: 100,
            min_requests: 20,
            error_rate_threshold: 0.5,  // 50%
        }
    }
}
```

---

## 6. è¶…æ—¶æ§åˆ¶

### 6.1 è¯·æ±‚è¶…æ—¶

```rust
use tokio::time::{timeout, Duration};

/// å•ä¸ªè¯·æ±‚è¶…æ—¶
async fn fetch_with_timeout(url: &str, timeout_duration: Duration) -> Result<String, String> {
    match timeout(timeout_duration, reqwest::get(url)).await {
        Ok(Ok(response)) => {
            response.text().await.map_err(|e| format!("Failed to read body: {}", e))
        }
        Ok(Err(e)) => Err(format!("Request failed: {}", e)),
        Err(_) => Err("Request timed out".to_string()),
    }
}
```

### 6.2 æ€»è¶…æ—¶æ§åˆ¶

```rust
use tokio::time::{timeout, Duration, Instant};

/// æ€»è¶…æ—¶æ§åˆ¶ï¼ˆåŒ…æ‹¬é‡è¯•ï¼‰
async fn retry_with_total_timeout<F, T>(
    mut operation: F,
    max_retries: u32,
    per_request_timeout: Duration,
    total_timeout: Duration,
) -> Result<T, String>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, String>>,
{
    let start_time = Instant::now();
    let mut attempts = 0;
    
    loop {
        // æ£€æŸ¥æ€»è¶…æ—¶
        if start_time.elapsed() >= total_timeout {
            return Err(format!(
                "Total timeout exceeded after {} attempts in {:?}",
                attempts,
                start_time.elapsed()
            ));
        }
        
        // è®¡ç®—å‰©ä½™æ—¶é—´
        let remaining_time = total_timeout.saturating_sub(start_time.elapsed());
        let request_timeout = std::cmp::min(per_request_timeout, remaining_time);
        
        // æ‰§è¡Œæ“ä½œï¼ˆå¸¦å•æ¬¡è¶…æ—¶ï¼‰
        match timeout(request_timeout, operation()).await {
            Ok(Ok(result)) => return Ok(result),
            Ok(Err(e)) if attempts < max_retries => {
                attempts += 1;
                println!("Attempt {} failed: {}", attempts, e);
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
            Ok(Err(e)) => return Err(format!("All retries exhausted: {}", e)),
            Err(_) => {
                attempts += 1;
                if attempts >= max_retries {
                    return Err("Request timed out after all retries".to_string());
                }
                println!("Attempt {} timed out", attempts);
            }
        }
    }
}
```

### 6.3 çº§è”è¶…æ—¶

```rust
use tokio::time::{timeout, Duration};

/// çº§è”è¶…æ—¶ï¼šæ¯å±‚æœåŠ¡è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
async fn api_gateway_handler() -> Result<String, String> {
    // APIç½‘å…³è¶…æ—¶: 5ç§’
    timeout(Duration::from_secs(5), async {
        // è°ƒç”¨ä¸šåŠ¡æœåŠ¡ï¼ˆè¶…æ—¶: 4ç§’ï¼‰
        timeout(Duration::from_secs(4), async {
            // è°ƒç”¨æ•°æ®åº“ï¼ˆè¶…æ—¶: 3ç§’ï¼‰
            timeout(Duration::from_secs(3), async {
                // å®é™…æ•°æ®åº“æŸ¥è¯¢
                Ok("Data".to_string())
            })
            .await
            .map_err(|_| "Database timeout".to_string())?
        })
        .await
        .map_err(|_| "Service timeout".to_string())?
    })
    .await
    .map_err(|_| "Gateway timeout".to_string())?
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 API è°ƒç”¨é‡è¯•

```rust
use reqwest::{Client, StatusCode};
use tokio::time::{sleep, Duration};
use rand::Rng;

struct ApiClient {
    client: Client,
    base_url: String,
}

impl ApiClient {
    fn new(base_url: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
        }
    }
    
    /// æ™ºèƒ½é‡è¯•çš„ API è°ƒç”¨
    async fn get_with_retry(&self, path: &str) -> Result<String, String> {
        let url = format!("{}{}", self.base_url, path);
        let max_retries = 3;
        let mut attempts = 0;
        let mut rng = rand::thread_rng();
        
        loop {
            match self.client.get(&url)
                .timeout(Duration::from_secs(10))
                .send()
                .await
            {
                Ok(response) => {
                    let status = response.status();
                    
                    if status.is_success() {
                        return response.text().await.map_err(|e| e.to_string());
                    } else if status == StatusCode::TOO_MANY_REQUESTS {
                        // 429: æ£€æŸ¥ Retry-After å¤´
                        let retry_after = response
                            .headers()
                            .get("Retry-After")
                            .and_then(|v| v.to_str().ok())
                            .and_then(|s| s.parse::<u64>().ok())
                            .unwrap_or(5);
                        
                        println!("Rate limited, waiting {} seconds...", retry_after);
                        sleep(Duration::from_secs(retry_after)).await;
                        attempts += 1;
                        
                        if attempts >= max_retries {
                            return Err("Max retries exceeded".to_string());
                        }
                    } else if status.is_server_error() {
                        // 5xx: æŒ‡æ•°é€€é¿
                        attempts += 1;
                        if attempts >= max_retries {
                            return Err(format!("Server error: {}", status));
                        }
                        
                        let base_delay = Duration::from_millis(100);
                        let delay = base_delay * 2_u32.pow(attempts - 1);
                        let jitter = rng.gen_range(0..delay.as_millis() as u64 / 4);
                        let total_delay = delay + Duration::from_millis(jitter);
                        
                        println!("Server error {}, retrying after {:?}...", status, total_delay);
                        sleep(total_delay).await;
                    } else {
                        // 4xx: å®¢æˆ·ç«¯é”™è¯¯ï¼Œä¸é‡è¯•
                        return Err(format!("Client error: {}", status));
                    }
                }
                Err(e) if attempts < max_retries && (e.is_timeout() || e.is_connect()) => {
                    // ç½‘ç»œé”™è¯¯æˆ–è¶…æ—¶ï¼Œé‡è¯•
                    attempts += 1;
                    let delay = Duration::from_millis(100 * 2_u64.pow(attempts - 1));
                    println!("Network error: {}, retrying after {:?}...", e, delay);
                    sleep(delay).await;
                }
                Err(e) => return Err(e.to_string()),
            }
        }
    }
}
```

### 7.2 æ•°æ®åº“è¿æ¥é‡è¯•

```rust
use tokio::time::{sleep, Duration};

struct Database;

impl Database {
    /// å¸¦é‡è¯•çš„æ•°æ®åº“è¿æ¥
    async fn connect_with_retry(
        connection_string: &str,
        max_retries: u32,
    ) -> Result<Self, String> {
        let mut attempts = 0;
        
        loop {
            match Self::try_connect(connection_string).await {
                Ok(db) => {
                    println!("âœ… Database connected on attempt {}", attempts + 1);
                    return Ok(db);
                }
                Err(e) if attempts < max_retries => {
                    attempts += 1;
                    let delay = Duration::from_secs(2_u64.pow(attempts.min(5)));
                    println!(
                        "âš ï¸ Connection attempt {} failed: {}, retrying in {:?}...",
                        attempts, e, delay
                    );
                    sleep(delay).await;
                }
                Err(e) => {
                    return Err(format!(
                        "Failed to connect after {} attempts: {}",
                        attempts + 1,
                        e
                    ));
                }
            }
        }
    }
    
    async fn try_connect(connection_string: &str) -> Result<Self, String> {
        // æ¨¡æ‹Ÿè¿æ¥å°è¯•
        Err("Connection refused".to_string())
    }
}
```

### 7.3 å®Œæ•´å¼¹æ€§ç³»ç»Ÿ

```rust
use std::sync::Arc;
use tokio::time::{sleep, timeout, Duration};

/// å®Œæ•´çš„å¼¹æ€§ç³»ç»Ÿç¤ºä¾‹
struct ResilientService {
    circuit_breaker: Arc<CircuitBreaker>,
    client: reqwest::Client,
}

impl ResilientService {
    fn new() -> Self {
        Self {
            circuit_breaker: Arc::new(CircuitBreaker::new(5, Duration::from_secs(60))),
            client: reqwest::Client::new(),
        }
    }
    
    /// å¸¦å®Œæ•´å¼¹æ€§ä¿æŠ¤çš„æœåŠ¡è°ƒç”¨
    async fn call_service(&self, url: &str) -> Result<String, String> {
        // 1. æ–­è·¯å™¨ä¿æŠ¤
        self.circuit_breaker.call(async {
            // 2. è¶…æ—¶æ§åˆ¶
            timeout(Duration::from_secs(5), async {
                // 3. é‡è¯•æœºåˆ¶
                exponential_backoff_retry(
                    || Box::pin(async {
                        // 4. å®é™… HTTP è°ƒç”¨
                        self.client.get(url)
                            .send()
                            .await
                            .map_err(|e| e.to_string())?
                            .text()
                            .await
                            .map_err(|e| e.to_string())
                    }),
                    3,
                    Duration::from_millis(100),
                    Duration::from_secs(2),
                ).await
            })
            .await
            .map_err(|_| "Total timeout".to_string())?
        }).await
    }
    
    /// å¸¦é™çº§çš„æœåŠ¡è°ƒç”¨
    async fn call_service_with_fallback(&self, url: &str) -> String {
        match self.call_service(url).await {
            Ok(result) => result,
            Err(e) => {
                println!("âš ï¸ Service call failed: {}, using fallback", e);
                "Fallback response".to_string()
            }
        }
    }
}
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **é‡è¯•ç­–ç•¥**: ä½¿ç”¨æŒ‡æ•°é€€é¿ + æŠ–åŠ¨ï¼Œé¿å…æƒŠç¾¤æ•ˆåº”
2. **æ¡ä»¶é‡è¯•**: åªå¯¹ä¸´æ—¶æ€§é”™è¯¯é‡è¯•ï¼Œå®¢æˆ·ç«¯é”™è¯¯ç«‹å³å¤±è´¥
3. **æ–­è·¯å™¨**: é˜²æ­¢çº§è”æ•…éšœï¼Œå¿«é€Ÿå¤±è´¥
4. **é™çº§ç­–ç•¥**: å¤šçº§é™çº§ï¼Œä¿è¯æ ¸å¿ƒåŠŸèƒ½å¯ç”¨
5. **è¶…æ—¶æ§åˆ¶**: è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´ï¼Œé¿å…èµ„æºè€—å°½

### æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èç­–ç•¥ | é…ç½® |
|------|---------|------|
| **HTTP API** | æŒ‡æ•°é€€é¿ + æŠ–åŠ¨ | æœ€å¤š3æ¬¡ï¼ŒåŸºç¡€å»¶è¿Ÿ100ms |
| **æ•°æ®åº“** | æŒ‡æ•°é€€é¿ | æœ€å¤š5æ¬¡ï¼ŒåŸºç¡€å»¶è¿Ÿ1s |
| **æ¶ˆæ¯é˜Ÿåˆ—** | ç®€å•é‡è¯• | æœ€å¤š10æ¬¡ï¼Œå›ºå®šå»¶è¿Ÿ5s |
| **å¾®æœåŠ¡è°ƒç”¨** | æ–­è·¯å™¨ + é™çº§ | å¤±è´¥é˜ˆå€¼5æ¬¡ï¼Œè¶…æ—¶60s |
| **æ‰¹å¤„ç†ä»»åŠ¡** | æ— é™é‡è¯• + æŒ‡æ•°é€€é¿ | æœ€å¤§å»¶è¿Ÿ1å°æ—¶ |

**å¸¸è§é™·é˜±**:

- âŒ å¯¹ä¸å¯é‡è¯•é”™è¯¯ï¼ˆå¦‚400ï¼‰è¿›è¡Œé‡è¯•
- âŒ ç¼ºå°‘æœ€å¤§é‡è¯•æ¬¡æ•°é™åˆ¶
- âŒ ç¼ºå°‘æ€»è¶…æ—¶æ§åˆ¶
- âŒ æ‰€æœ‰æœåŠ¡åŒæ—¶é‡è¯•ï¼ˆæƒŠç¾¤æ•ˆåº”ï¼‰
- âŒ é™çº§ç­–ç•¥ä¸å®Œæ•´
- âœ… æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¯•
- âœ… ä½¿ç”¨æŠ–åŠ¨é¿å…åŒæ­¥é‡è¯•
- âœ… å®ç°å¤šçº§é™çº§ç­–ç•¥
- âœ… è®°å½•é‡è¯•å’Œé™çº§äº‹ä»¶

---

## ğŸ“š å‚è€ƒèµ„æº

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: é”™è¯¯å¤„ç†æŒ‡å—](./01_é”™è¯¯å¤„ç†æŒ‡å—.md)
- [Tier 2: æµ‹è¯•ç­–ç•¥æŒ‡å—](./03_æµ‹è¯•ç­–ç•¥æŒ‡å—.md)
- [Tier 3: API å‚è€ƒ](../tier_03_references/)

**æ‰©å±•é˜…è¯»**:

- [AWS Exponential Backoff](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)
- [Netflix Hystrix](https://github.com/Netflix/Hystrix/wiki)
- [Google SRE Book - Handling Overload](https://sre.google/sre-book/handling-overload/)

---

**æ–‡æ¡£ç»´æŠ¤**: C13 Reliability Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
