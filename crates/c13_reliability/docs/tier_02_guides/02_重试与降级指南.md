# C13 Reliability - Tier 2: 重试与降级指南

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 35 分钟

---

## 📊 目录

- [C13 Reliability - Tier 2: 重试与降级指南](#c13-reliability---tier-2-重试与降级指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 重试策略概述](#1-重试策略概述)
    - [1.1 为什么需要重试？](#11-为什么需要重试)
    - [1.2 重试策略分类](#12-重试策略分类)
  - [2. 基础重试模式](#2-基础重试模式)
    - [2.1 简单重试](#21-简单重试)
    - [2.2 线性退避](#22-线性退避)
    - [2.3 指数退避](#23-指数退避)
  - [3. 高级重试策略](#3-高级重试策略)
    - [3.1 带抖动的指数退避](#31-带抖动的指数退避)
    - [3.2 条件重试](#32-条件重试)
    - [3.3 幂等性保证](#33-幂等性保证)
  - [4. 降级策略](#4-降级策略)
    - [4.1 降级原则](#41-降级原则)
    - [4.2 多级降级](#42-多级降级)
    - [4.3 默认值降级](#43-默认值降级)
  - [5. 断路器模式](#5-断路器模式)
    - [5.1 三态断路器](#51-三态断路器)
    - [5.2 五态断路器](#52-五态断路器)
    - [5.3 断路器配置](#53-断路器配置)
  - [6. 超时控制](#6-超时控制)
    - [6.1 请求超时](#61-请求超时)
    - [6.2 总超时控制](#62-总超时控制)
    - [6.3 级联超时](#63-级联超时)
  - [7. 实战案例](#7-实战案例)
    - [7.1 API 调用重试](#71-api-调用重试)
    - [7.2 数据库连接重试](#72-数据库连接重试)
    - [7.3 完整弹性系统](#73-完整弹性系统)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

## 📋 目录

- [C13 Reliability - Tier 2: 重试与降级指南](#c13-reliability---tier-2-重试与降级指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 重试策略概述](#1-重试策略概述)
    - [1.1 为什么需要重试？](#11-为什么需要重试)
    - [1.2 重试策略分类](#12-重试策略分类)
  - [2. 基础重试模式](#2-基础重试模式)
    - [2.1 简单重试](#21-简单重试)
    - [2.2 线性退避](#22-线性退避)
    - [2.3 指数退避](#23-指数退避)
  - [3. 高级重试策略](#3-高级重试策略)
    - [3.1 带抖动的指数退避](#31-带抖动的指数退避)
    - [3.2 条件重试](#32-条件重试)
    - [3.3 幂等性保证](#33-幂等性保证)
  - [4. 降级策略](#4-降级策略)
    - [4.1 降级原则](#41-降级原则)
    - [4.2 多级降级](#42-多级降级)
    - [4.3 默认值降级](#43-默认值降级)
  - [5. 断路器模式](#5-断路器模式)
    - [5.1 三态断路器](#51-三态断路器)
    - [5.2 五态断路器](#52-五态断路器)
    - [5.3 断路器配置](#53-断路器配置)
  - [6. 超时控制](#6-超时控制)
    - [6.1 请求超时](#61-请求超时)
    - [6.2 总超时控制](#62-总超时控制)
    - [6.3 级联超时](#63-级联超时)
  - [7. 实战案例](#7-实战案例)
    - [7.1 API 调用重试](#71-api-调用重试)
    - [7.2 数据库连接重试](#72-数据库连接重试)
    - [7.3 完整弹性系统](#73-完整弹性系统)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 重试策略概述

### 1.1 为什么需要重试？

**常见故障场景**:

| 故障类型 | 是否应重试 | 重试策略 |
|---------|----------|---------|
| **网络超时** | ✅ 是 | 指数退避 |
| **服务暂时不可用 (503)** | ✅ 是 | 指数退避 + 抖动 |
| **限流 (429)** | ✅ 是 | 根据 Retry-After |
| **客户端错误 (400)** | ❌ 否 | 立即失败 |
| **认证失败 (401)** | ❌ 否 | 立即失败 |
| **资源未找到 (404)** | ❌ 否 | 立即失败 |

### 1.2 重试策略分类

```rust
#[derive(Debug, Clone)]
pub enum RetryStrategy {
    /// 固定间隔重试
    Fixed { interval: Duration },
    
    /// 线性退避
    Linear { base_interval: Duration, increment: Duration },
    
    /// 指数退避
    Exponential { base_interval: Duration, max_interval: Duration },
    
    /// 指数退避 + 随机抖动
    ExponentialWithJitter {
        base_interval: Duration,
        max_interval: Duration,
        jitter_factor: f64,  // 0.0 - 1.0
    },
    
    /// 自定义退避函数
    Custom(Box<dyn Fn(u32) -> Duration + Send + Sync>),
}
```

---

## 2. 基础重试模式

### 2.1 简单重试

```rust
use std::time::Duration;
use tokio::time::sleep;

/// 简单重试：固定次数，固定间隔
async fn simple_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 使用示例
async fn example() -> Result<String, reqwest::Error> {
    simple_retry(
        || Box::pin(async {
            reqwest::get("https://api.example.com/data")
                .await?
                .text()
                .await
        }),
        3,  // 最多重试3次
        Duration::from_secs(1),  // 每次间隔1秒
    ).await
}
```

### 2.2 线性退避

```rust
use std::time::Duration;
use tokio::time::sleep;

/// 线性退避：延迟线性增长
async fn linear_backoff_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    base_delay: Duration,
    increment: Duration,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                let delay = base_delay + increment * attempts;
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 延迟序列: 1s, 2s, 3s, 4s, ...
```

### 2.3 指数退避

```rust
use std::time::Duration;
use tokio::time::sleep;

/// 指数退避：延迟指数增长
async fn exponential_backoff_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    base_delay: Duration,
    max_delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                let delay = std::cmp::min(
                    base_delay * 2_u32.pow(attempts - 1),
                    max_delay,
                );
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 延迟序列: 100ms, 200ms, 400ms, 800ms, 1600ms, ...
// 最大延迟: max_delay
```

---

## 3. 高级重试策略

### 3.1 带抖动的指数退避

```rust
use std::time::Duration;
use tokio::time::sleep;
use rand::Rng;

/// 带抖动的指数退避：避免惊群效应
async fn exponential_backoff_with_jitter<F, T, E>(
    mut operation: F,
    max_retries: u32,
    base_delay: Duration,
    max_delay: Duration,
    jitter_factor: f64,  // 0.0 - 1.0
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    let mut rng = rand::thread_rng();
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                
                // 计算基础延迟
                let base = std::cmp::min(
                    base_delay * 2_u32.pow(attempts - 1),
                    max_delay,
                );
                
                // 添加随机抖动
                let jitter_range = base.as_millis() as f64 * jitter_factor;
                let jitter = rng.gen_range(-jitter_range..jitter_range) as i64;
                let delay = Duration::from_millis(
                    (base.as_millis() as i64 + jitter).max(0) as u64
                );
                
                println!("Attempt {} failed, retrying after {:?}...", attempts, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 延迟序列（抖动 20%）: 
// 100ms ± 20ms, 200ms ± 40ms, 400ms ± 80ms, ...
```

### 3.2 条件重试

```rust
use std::error::Error;

/// 条件重试：根据错误类型决定是否重试
async fn conditional_retry<F, T, E>(
    mut operation: F,
    max_retries: u32,
    should_retry: impl Fn(&E) -> bool,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
{
    let mut attempts = 0;
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries && should_retry(&e) => {
                attempts += 1;
                println!("Retryable error, attempt {}", attempts);
                tokio::time::sleep(Duration::from_millis(100 * 2_u64.pow(attempts - 1))).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 使用示例
use reqwest::StatusCode;

async fn fetch_with_conditional_retry(url: &str) -> Result<String, reqwest::Error> {
    conditional_retry(
        || Box::pin(reqwest::get(url).and_then(|r| r.text())),
        3,
        |e: &reqwest::Error| {
            // 只对临时性错误重试
            e.is_timeout() || e.is_connect() || 
            e.status().map_or(false, |s| s == StatusCode::TOO_MANY_REQUESTS || s.is_server_error())
        }
    ).await
}
```

### 3.3 幂等性保证

```rust
use uuid::Uuid;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

/// 幂等性令牌管理器
struct IdempotencyManager {
    processed_tokens: Arc<Mutex<HashMap<String, String>>>,
}

impl IdempotencyManager {
    fn new() -> Self {
        Self {
            processed_tokens: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    /// 生成幂等性令牌
    fn generate_token(&self) -> String {
        Uuid::new_v4().to_string()
    }
    
    /// 检查令牌是否已处理
    async fn check_token(&self, token: &str) -> Option<String> {
        self.processed_tokens.lock().await.get(token).cloned()
    }
    
    /// 记录处理结果
    async fn record_result(&self, token: String, result: String) {
        self.processed_tokens.lock().await.insert(token, result);
    }
}

/// 幂等性重试包装器
async fn retry_with_idempotency<F, T>(
    manager: &IdempotencyManager,
    mut operation: F,
    max_retries: u32,
) -> Result<T, String>
where
    F: FnMut(String) -> futures::future::BoxFuture<'static, Result<T, String>>,
    T: std::fmt::Display + Clone,
{
    let token = manager.generate_token();
    
    // 检查是否已处理
    if let Some(cached_result) = manager.check_token(&token).await {
        println!("Returning cached result for token {}", token);
        // 这里简化了，实际需要反序列化
        return Err("Cached result".to_string());
    }
    
    let mut attempts = 0;
    
    loop {
        match operation(token.clone()).await {
            Ok(result) => {
                // 记录成功结果
                manager.record_result(token.clone(), format!("{}", result)).await;
                return Ok(result);
            }
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("Attempt {} failed: {}, retrying...", attempts, e);
                tokio::time::sleep(Duration::from_secs(1)).await;
            }
            Err(e) => return Err(e),
        }
    }
}
```

---

## 4. 降级策略

### 4.1 降级原则

**降级触发条件**:

1. **响应超时**: 服务响应时间超过阈值
2. **错误率过高**: 错误率超过 50%
3. **断路器打开**: 服务完全不可用
4. **资源耗尽**: 内存、CPU、连接池等资源不足

### 4.2 多级降级

```rust
use std::time::Duration;
use tokio::time::timeout;

/// 多级降级策略
async fn fetch_user_data_with_fallback(user_id: u64) -> Result<UserData, String> {
    // 级别1: 主服务
    match timeout(
        Duration::from_secs(2),
        fetch_from_primary_service(user_id)
    ).await {
        Ok(Ok(data)) => {
            println!("✅ Level 1: Primary service");
            return Ok(data);
        }
        Ok(Err(e)) => println!("❌ Level 1 failed: {}", e),
        Err(_) => println!("⏱️ Level 1 timeout"),
    }
    
    // 级别2: 备用服务
    match timeout(
        Duration::from_secs(1),
        fetch_from_secondary_service(user_id)
    ).await {
        Ok(Ok(data)) => {
            println!("✅ Level 2: Secondary service");
            return Ok(data);
        }
        Ok(Err(e)) => println!("❌ Level 2 failed: {}", e),
        Err(_) => println!("⏱️ Level 2 timeout"),
    }
    
    // 级别3: 缓存
    match fetch_from_cache(user_id).await {
        Ok(data) => {
            println!("✅ Level 3: Cache (may be stale)");
            return Ok(data);
        }
        Err(e) => println!("❌ Level 3 failed: {}", e),
    }
    
    // 级别4: 默认值
    println!("⚠️ Level 4: Default fallback");
    Ok(UserData::default_for(user_id))
}

async fn fetch_from_primary_service(user_id: u64) -> Result<UserData, String> {
    // 模拟主服务调用
    Err("Primary service unavailable".to_string())
}

async fn fetch_from_secondary_service(user_id: u64) -> Result<UserData, String> {
    // 模拟备用服务调用
    Err("Secondary service unavailable".to_string())
}

async fn fetch_from_cache(user_id: u64) -> Result<UserData, String> {
    // 模拟缓存读取
    Ok(UserData {
        id: user_id,
        name: format!("Cached User {}", user_id),
        email: format!("user{}@cached.com", user_id),
    })
}

#[derive(Debug, Clone)]
struct UserData {
    id: u64,
    name: String,
    email: String,
}

impl UserData {
    fn default_for(id: u64) -> Self {
        Self {
            id,
            name: format!("Guest {}", id),
            email: "guest@example.com".to_string(),
        }
    }
}
```

### 4.3 默认值降级

```rust
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;

/// 静态默认值
const DEFAULT_CONFIG: &str = r#"{
    "max_connections": 100,
    "timeout_secs": 30,
    "retry_attempts": 3
}"#;

/// 配置服务（带降级）
struct ConfigService {
    cache: Arc<RwLock<HashMap<String, String>>>,
}

impl ConfigService {
    fn new() -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// 获取配置（带降级）
    async fn get_config(&self, key: &str) -> String {
        // 1. 尝试从远程获取
        match self.fetch_from_remote(key).await {
            Ok(value) => {
                // 更新缓存
                self.cache.write().await.insert(key.to_string(), value.clone());
                return value;
            }
            Err(e) => println!("Remote fetch failed: {}, trying cache...", e),
        }
        
        // 2. 尝试从缓存获取
        if let Some(cached) = self.cache.read().await.get(key) {
            println!("⚠️ Using cached value for '{}'", key);
            return cached.clone();
        }
        
        // 3. 返回默认值
        println!("⚠️ Using default value for '{}'", key);
        DEFAULT_CONFIG.to_string()
    }
    
    async fn fetch_from_remote(&self, key: &str) -> Result<String, String> {
        // 模拟远程调用
        Err("Remote service unavailable".to_string())
    }
}
```

---

## 5. 断路器模式

### 5.1 三态断路器

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, Ordering};
use tokio::sync::Mutex;
use tokio::time::{Instant, Duration};

#[derive(Debug, Clone, Copy, PartialEq)]
enum CircuitState {
    Closed,   // 正常：请求通过
    Open,     // 断开：拒绝请求
    HalfOpen, // 半开：尝试恢复
}

struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: AtomicU32,
    success_count: AtomicU32,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
    failure_threshold: u32,
    success_threshold: u32,
    timeout: Duration,
}

impl CircuitBreaker {
    fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: AtomicU32::new(0),
            success_count: AtomicU32::new(0),
            last_failure_time: Arc::new(Mutex::new(None)),
            failure_threshold,
            success_threshold: 3,
            timeout,
        }
    }
    
    async fn call<F, T>(&self, operation: F) -> Result<T, String>
    where
        F: std::future::Future<Output = Result<T, String>>,
    {
        // 检查断路器状态
        let mut state = self.state.lock().await;
        
        match *state {
            CircuitState::Open => {
                // 检查是否超时，可以转为半开状态
                let last_failure = self.last_failure_time.lock().await;
                if let Some(time) = *last_failure {
                    if time.elapsed() >= self.timeout {
                        *state = CircuitState::HalfOpen;
                        self.success_count.store(0, Ordering::SeqCst);
                        println!("🟡 Circuit breaker: OPEN → HALF_OPEN");
                    } else {
                        return Err("Circuit breaker is OPEN".to_string());
                    }
                }
            }
            CircuitState::HalfOpen => {
                // 半开状态，允许少量请求尝试
            }
            CircuitState::Closed => {
                // 正常状态
            }
        }
        
        drop(state);
        
        // 执行操作
        match operation.await {
            Ok(result) => {
                // 成功
                self.success_count.fetch_add(1, Ordering::SeqCst);
                let mut state = self.state.lock().await;
                
                if *state == CircuitState::HalfOpen {
                    let successes = self.success_count.load(Ordering::SeqCst);
                    if successes >= self.success_threshold {
                        *state = CircuitState::Closed;
                        self.failure_count.store(0, Ordering::SeqCst);
                        println!("🟢 Circuit breaker: HALF_OPEN → CLOSED");
                    }
                }
                
                Ok(result)
            }
            Err(e) => {
                // 失败
                let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;
                *self.last_failure_time.lock().await = Some(Instant::now());
                
                let mut state = self.state.lock().await;
                
                if *state == CircuitState::HalfOpen {
                    // 半开状态失败，立即转为打开
                    *state = CircuitState::Open;
                    println!("🔴 Circuit breaker: HALF_OPEN → OPEN");
                } else if failures >= self.failure_threshold {
                    // 失败次数超过阈值，打开断路器
                    *state = CircuitState::Open;
                    println!("🔴 Circuit breaker: CLOSED → OPEN (failures: {})", failures);
                }
                
                Err(e)
            }
        }
    }
}
```

### 5.2 五态断路器

C13 Reliability 模块实现了更高级的**五态断路器**：

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
enum AdvancedCircuitState {
    Closed,        // 正常
    HalfOpen,      // 尝试恢复
    Open,          // 完全断开
    ForcedOpen,    // 强制断开（管理员操作）
    Disabled,      // 禁用（旁路）
}
```

**五态优势**:

- **ForcedOpen**: 用于紧急维护或版本切换
- **Disabled**: 用于调试或临时禁用保护机制

### 5.3 断路器配置

```rust
struct CircuitBreakerConfig {
    /// 失败阈值
    failure_threshold: u32,
    
    /// 成功阈值（半开 → 关闭）
    success_threshold: u32,
    
    /// 超时时间（打开 → 半开）
    timeout: Duration,
    
    /// 滑动窗口大小
    window_size: usize,
    
    /// 最小请求数
    min_requests: u32,
    
    /// 错误率阈值 (0.0 - 1.0)
    error_rate_threshold: f64,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            success_threshold: 2,
            timeout: Duration::from_secs(60),
            window_size: 100,
            min_requests: 20,
            error_rate_threshold: 0.5,  // 50%
        }
    }
}
```

---

## 6. 超时控制

### 6.1 请求超时

```rust
use tokio::time::{timeout, Duration};

/// 单个请求超时
async fn fetch_with_timeout(url: &str, timeout_duration: Duration) -> Result<String, String> {
    match timeout(timeout_duration, reqwest::get(url)).await {
        Ok(Ok(response)) => {
            response.text().await.map_err(|e| format!("Failed to read body: {}", e))
        }
        Ok(Err(e)) => Err(format!("Request failed: {}", e)),
        Err(_) => Err("Request timed out".to_string()),
    }
}
```

### 6.2 总超时控制

```rust
use tokio::time::{timeout, Duration, Instant};

/// 总超时控制（包括重试）
async fn retry_with_total_timeout<F, T>(
    mut operation: F,
    max_retries: u32,
    per_request_timeout: Duration,
    total_timeout: Duration,
) -> Result<T, String>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, String>>,
{
    let start_time = Instant::now();
    let mut attempts = 0;
    
    loop {
        // 检查总超时
        if start_time.elapsed() >= total_timeout {
            return Err(format!(
                "Total timeout exceeded after {} attempts in {:?}",
                attempts,
                start_time.elapsed()
            ));
        }
        
        // 计算剩余时间
        let remaining_time = total_timeout.saturating_sub(start_time.elapsed());
        let request_timeout = std::cmp::min(per_request_timeout, remaining_time);
        
        // 执行操作（带单次超时）
        match timeout(request_timeout, operation()).await {
            Ok(Ok(result)) => return Ok(result),
            Ok(Err(e)) if attempts < max_retries => {
                attempts += 1;
                println!("Attempt {} failed: {}", attempts, e);
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
            Ok(Err(e)) => return Err(format!("All retries exhausted: {}", e)),
            Err(_) => {
                attempts += 1;
                if attempts >= max_retries {
                    return Err("Request timed out after all retries".to_string());
                }
                println!("Attempt {} timed out", attempts);
            }
        }
    }
}
```

### 6.3 级联超时

```rust
use tokio::time::{timeout, Duration};

/// 级联超时：每层服务设置合理的超时时间
async fn api_gateway_handler() -> Result<String, String> {
    // API网关超时: 5秒
    timeout(Duration::from_secs(5), async {
        // 调用业务服务（超时: 4秒）
        timeout(Duration::from_secs(4), async {
            // 调用数据库（超时: 3秒）
            timeout(Duration::from_secs(3), async {
                // 实际数据库查询
                Ok("Data".to_string())
            })
            .await
            .map_err(|_| "Database timeout".to_string())?
        })
        .await
        .map_err(|_| "Service timeout".to_string())?
    })
    .await
    .map_err(|_| "Gateway timeout".to_string())?
}
```

---

## 7. 实战案例

### 7.1 API 调用重试

```rust
use reqwest::{Client, StatusCode};
use tokio::time::{sleep, Duration};
use rand::Rng;

struct ApiClient {
    client: Client,
    base_url: String,
}

impl ApiClient {
    fn new(base_url: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
        }
    }
    
    /// 智能重试的 API 调用
    async fn get_with_retry(&self, path: &str) -> Result<String, String> {
        let url = format!("{}{}", self.base_url, path);
        let max_retries = 3;
        let mut attempts = 0;
        let mut rng = rand::thread_rng();
        
        loop {
            match self.client.get(&url)
                .timeout(Duration::from_secs(10))
                .send()
                .await
            {
                Ok(response) => {
                    let status = response.status();
                    
                    if status.is_success() {
                        return response.text().await.map_err(|e| e.to_string());
                    } else if status == StatusCode::TOO_MANY_REQUESTS {
                        // 429: 检查 Retry-After 头
                        let retry_after = response
                            .headers()
                            .get("Retry-After")
                            .and_then(|v| v.to_str().ok())
                            .and_then(|s| s.parse::<u64>().ok())
                            .unwrap_or(5);
                        
                        println!("Rate limited, waiting {} seconds...", retry_after);
                        sleep(Duration::from_secs(retry_after)).await;
                        attempts += 1;
                        
                        if attempts >= max_retries {
                            return Err("Max retries exceeded".to_string());
                        }
                    } else if status.is_server_error() {
                        // 5xx: 指数退避
                        attempts += 1;
                        if attempts >= max_retries {
                            return Err(format!("Server error: {}", status));
                        }
                        
                        let base_delay = Duration::from_millis(100);
                        let delay = base_delay * 2_u32.pow(attempts - 1);
                        let jitter = rng.gen_range(0..delay.as_millis() as u64 / 4);
                        let total_delay = delay + Duration::from_millis(jitter);
                        
                        println!("Server error {}, retrying after {:?}...", status, total_delay);
                        sleep(total_delay).await;
                    } else {
                        // 4xx: 客户端错误，不重试
                        return Err(format!("Client error: {}", status));
                    }
                }
                Err(e) if attempts < max_retries && (e.is_timeout() || e.is_connect()) => {
                    // 网络错误或超时，重试
                    attempts += 1;
                    let delay = Duration::from_millis(100 * 2_u64.pow(attempts - 1));
                    println!("Network error: {}, retrying after {:?}...", e, delay);
                    sleep(delay).await;
                }
                Err(e) => return Err(e.to_string()),
            }
        }
    }
}
```

### 7.2 数据库连接重试

```rust
use tokio::time::{sleep, Duration};

struct Database;

impl Database {
    /// 带重试的数据库连接
    async fn connect_with_retry(
        connection_string: &str,
        max_retries: u32,
    ) -> Result<Self, String> {
        let mut attempts = 0;
        
        loop {
            match Self::try_connect(connection_string).await {
                Ok(db) => {
                    println!("✅ Database connected on attempt {}", attempts + 1);
                    return Ok(db);
                }
                Err(e) if attempts < max_retries => {
                    attempts += 1;
                    let delay = Duration::from_secs(2_u64.pow(attempts.min(5)));
                    println!(
                        "⚠️ Connection attempt {} failed: {}, retrying in {:?}...",
                        attempts, e, delay
                    );
                    sleep(delay).await;
                }
                Err(e) => {
                    return Err(format!(
                        "Failed to connect after {} attempts: {}",
                        attempts + 1,
                        e
                    ));
                }
            }
        }
    }
    
    async fn try_connect(connection_string: &str) -> Result<Self, String> {
        // 模拟连接尝试
        Err("Connection refused".to_string())
    }
}
```

### 7.3 完整弹性系统

```rust
use std::sync::Arc;
use tokio::time::{sleep, timeout, Duration};

/// 完整的弹性系统示例
struct ResilientService {
    circuit_breaker: Arc<CircuitBreaker>,
    client: reqwest::Client,
}

impl ResilientService {
    fn new() -> Self {
        Self {
            circuit_breaker: Arc::new(CircuitBreaker::new(5, Duration::from_secs(60))),
            client: reqwest::Client::new(),
        }
    }
    
    /// 带完整弹性保护的服务调用
    async fn call_service(&self, url: &str) -> Result<String, String> {
        // 1. 断路器保护
        self.circuit_breaker.call(async {
            // 2. 超时控制
            timeout(Duration::from_secs(5), async {
                // 3. 重试机制
                exponential_backoff_retry(
                    || Box::pin(async {
                        // 4. 实际 HTTP 调用
                        self.client.get(url)
                            .send()
                            .await
                            .map_err(|e| e.to_string())?
                            .text()
                            .await
                            .map_err(|e| e.to_string())
                    }),
                    3,
                    Duration::from_millis(100),
                    Duration::from_secs(2),
                ).await
            })
            .await
            .map_err(|_| "Total timeout".to_string())?
        }).await
    }
    
    /// 带降级的服务调用
    async fn call_service_with_fallback(&self, url: &str) -> String {
        match self.call_service(url).await {
            Ok(result) => result,
            Err(e) => {
                println!("⚠️ Service call failed: {}, using fallback", e);
                "Fallback response".to_string()
            }
        }
    }
}
```

---

## 8. 总结

### 核心要点

1. **重试策略**: 使用指数退避 + 抖动，避免惊群效应
2. **条件重试**: 只对临时性错误重试，客户端错误立即失败
3. **断路器**: 防止级联故障，快速失败
4. **降级策略**: 多级降级，保证核心功能可用
5. **超时控制**: 设置合理的超时时间，避免资源耗尽

### 最佳实践

| 场景 | 推荐策略 | 配置 |
|------|---------|------|
| **HTTP API** | 指数退避 + 抖动 | 最多3次，基础延迟100ms |
| **数据库** | 指数退避 | 最多5次，基础延迟1s |
| **消息队列** | 简单重试 | 最多10次，固定延迟5s |
| **微服务调用** | 断路器 + 降级 | 失败阈值5次，超时60s |
| **批处理任务** | 无限重试 + 指数退避 | 最大延迟1小时 |

**常见陷阱**:

- ❌ 对不可重试错误（如400）进行重试
- ❌ 缺少最大重试次数限制
- ❌ 缺少总超时控制
- ❌ 所有服务同时重试（惊群效应）
- ❌ 降级策略不完整
- ✅ 根据错误类型决定是否重试
- ✅ 使用抖动避免同步重试
- ✅ 实现多级降级策略
- ✅ 记录重试和降级事件

---

## 📚 参考资源

**相关文档**:

- [Tier 2: 错误处理指南](./01_错误处理指南.md)
- [Tier 2: 测试策略指南](./03_测试策略指南.md)
- [Tier 3: API 参考](../tier_03_references/)

**扩展阅读**:

- [AWS Exponential Backoff](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)
- [Netflix Hystrix](https://github.com/Netflix/Hystrix/wiki)
- [Google SRE Book - Handling Overload](https://sre.google/sre-book/handling-overload/)

---

**文档维护**: C13 Reliability Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
