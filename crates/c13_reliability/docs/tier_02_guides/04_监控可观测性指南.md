# C13 Reliability - Tier 2: ç›‘æ§å¯è§‚æµ‹æ€§æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 40 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C13 Reliability - Tier 2: ç›‘æ§å¯è§‚æµ‹æ€§æŒ‡å—](#c13-reliability---tier-2-ç›‘æ§å¯è§‚æµ‹æ€§æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±](#1-å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±)
    - [1.1 æŒ‡æ ‡ (Metrics)](#11-æŒ‡æ ‡-metrics)
    - [1.2 æ—¥å¿— (Logs)](#12-æ—¥å¿—-logs)
    - [1.3 è¿½è¸ª (Traces)](#13-è¿½è¸ª-traces)
  - [2. æŒ‡æ ‡æ”¶é›†](#2-æŒ‡æ ‡æ”¶é›†)
    - [2.1 ä½¿ç”¨ metrics crate](#21-ä½¿ç”¨-metrics-crate)
    - [2.2 Prometheus é›†æˆ](#22-prometheus-é›†æˆ)
    - [2.3 é»„é‡‘æŒ‡æ ‡](#23-é»„é‡‘æŒ‡æ ‡)
  - [3. ç»“æ„åŒ–æ—¥å¿—](#3-ç»“æ„åŒ–æ—¥å¿—)
    - [3.1 ä½¿ç”¨ tracing](#31-ä½¿ç”¨-tracing)
    - [3.2 æ—¥å¿—çº§åˆ«](#32-æ—¥å¿—çº§åˆ«)
    - [3.3 æ—¥å¿—ä¸Šä¸‹æ–‡](#33-æ—¥å¿—ä¸Šä¸‹æ–‡)
  - [4. åˆ†å¸ƒå¼è¿½è¸ª](#4-åˆ†å¸ƒå¼è¿½è¸ª)
    - [4.1 OpenTelemetry](#41-opentelemetry)
    - [4.2 è·¨æœåŠ¡è¿½è¸ª](#42-è·¨æœåŠ¡è¿½è¸ª)
    - [4.3 æ€§èƒ½åˆ†æ](#43-æ€§èƒ½åˆ†æ)
  - [5. å¥åº·æ£€æŸ¥](#5-å¥åº·æ£€æŸ¥)
    - [5.1 liveness æ¢é’ˆ](#51-liveness-æ¢é’ˆ)
    - [5.2 readiness æ¢é’ˆ](#52-readiness-æ¢é’ˆ)
    - [5.3 ä¾èµ–å¥åº·](#53-ä¾èµ–å¥åº·)
  - [6. å‘Šè­¦è§„åˆ™](#6-å‘Šè­¦è§„åˆ™)
    - [6.1 SLO/SLI/SLA](#61-sloslisla)
    - [6.2 å‘Šè­¦æœ€ä½³å®è·µ](#62-å‘Šè­¦æœ€ä½³å®è·µ)
    - [6.3 å‘Šè­¦é™å™ª](#63-å‘Šè­¦é™å™ª)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 å®Œæ•´å¯è§‚æµ‹æ€§ç³»ç»Ÿ](#71-å®Œæ•´å¯è§‚æµ‹æ€§ç³»ç»Ÿ)
    - [7.2 æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿](#72-æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±

### 1.1 æŒ‡æ ‡ (Metrics)

**å®šä¹‰**: æ•°å€¼åŒ–çš„æ—¶é—´åºåˆ—æ•°æ®

**ç±»å‹**:

- **Counter**: å•è°ƒé€’å¢çš„è®¡æ•°å™¨ (è¯·æ±‚æ€»æ•°ã€é”™è¯¯æ€»æ•°)
- **Gauge**: å¯å¢å¯å‡çš„æŒ‡æ ‡ (CPU ä½¿ç”¨ç‡ã€å†…å­˜ä½¿ç”¨)
- **Histogram**: åˆ†å¸ƒç»Ÿè®¡ (å“åº”æ—¶é—´åˆ†å¸ƒ)
- **Summary**: ç™¾åˆ†ä½æ•° (P50, P95, P99)

```rust
use metrics::{counter, gauge, histogram};

fn handle_request() {
    // è®¡æ•°å™¨ï¼šè¯·æ±‚æ€»æ•°
    counter!("http_requests_total", "method" => "GET", "path" => "/api/users").increment(1);
    
    // ç›´æ–¹å›¾ï¼šå“åº”æ—¶é—´
    let start = std::time::Instant::now();
    // ... å¤„ç†è¯·æ±‚ ...
    histogram!("http_request_duration_seconds").record(start.elapsed().as_secs_f64());
    
    // ä»ªè¡¨ç›˜ï¼šå½“å‰è¿æ¥æ•°
    gauge!("active_connections").set(42.0);
}
```

### 1.2 æ—¥å¿— (Logs)

**å®šä¹‰**: ç¦»æ•£çš„äº‹ä»¶è®°å½•

**çº§åˆ«**: ERROR > WARN > INFO > DEBUG > TRACE

```rust
use tracing::{info, warn, error, debug};

fn process_order(order_id: u64) {
    info!(order_id = order_id, "Processing order");
    
    match fetch_order_details(order_id) {
        Ok(details) => {
            debug!(order_id = order_id, details = ?details, "Order details fetched");
        }
        Err(e) => {
            error!(order_id = order_id, error = %e, "Failed to fetch order");
        }
    }
}

fn fetch_order_details(order_id: u64) -> Result<OrderDetails, String> {
    Ok(OrderDetails { id: order_id, amount: 100.0 })
}

#[derive(Debug)]
struct OrderDetails {
    id: u64,
    amount: f64,
}
```

### 1.3 è¿½è¸ª (Traces)

**å®šä¹‰**: è·¨æœåŠ¡çš„è¯·æ±‚è°ƒç”¨é“¾

```text
Root Span: HTTP GET /api/orders/123
â”œâ”€ Span: Database Query (50ms)
â”œâ”€ Span: Cache Lookup (10ms)
â””â”€ Span: External API Call (200ms)
   â””â”€ Span: HTTP Request (150ms)
```

```rust
use tracing::{info_span, instrument};

#[instrument]
async fn get_order(order_id: u64) -> Result<Order, String> {
    let span = info_span!("get_order", order_id = order_id);
    let _enter = span.enter();
    
    // æ•°æ®åº“æŸ¥è¯¢
    let order = fetch_from_db(order_id).await?;
    
    // å¤–éƒ¨ API è°ƒç”¨
    let enriched = enrich_order_data(order).await?;
    
    Ok(enriched)
}

async fn fetch_from_db(order_id: u64) -> Result<Order, String> {
    Ok(Order { id: order_id, status: "pending".to_string() })
}

async fn enrich_order_data(order: Order) -> Result<Order, String> {
    Ok(order)
}

#[derive(Debug)]
struct Order {
    id: u64,
    status: String,
}
```

---

## 2. æŒ‡æ ‡æ”¶é›†

### 2.1 ä½¿ç”¨ metrics crate

```rust
use metrics::{counter, histogram, gauge};
use std::time::Instant;

struct RequestHandler;

impl RequestHandler {
    fn handle_request(&self, method: &str, path: &str) -> Result<String, String> {
        let start = Instant::now();
        
        // è®¡æ•°å™¨ï¼šæ€»è¯·æ±‚æ•°
        counter!("http_requests_total", 
            "method" => method.to_string(), 
            "path" => path.to_string()
        ).increment(1);
        
        // å¤„ç†è¯·æ±‚
        let result = self.process(method, path);
        
        // è®°å½•å“åº”æ—¶é—´
        histogram!("http_request_duration_seconds",
            "method" => method.to_string(),
            "path" => path.to_string()
        ).record(start.elapsed().as_secs_f64());
        
        // è®°å½•ç»“æœ
        match &result {
            Ok(_) => counter!("http_requests_success_total").increment(1),
            Err(_) => counter!("http_requests_error_total").increment(1),
        }
        
        result
    }
    
    fn process(&self, method: &str, path: &str) -> Result<String, String> {
        Ok(format!("Processed {} {}", method, path))
    }
}
```

### 2.2 Prometheus é›†æˆ

```rust
use metrics_exporter_prometheus::PrometheusBuilder;
use std::net::SocketAddr;

async fn setup_metrics() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»º Prometheus exporter
    let builder = PrometheusBuilder::new();
    builder.install()?;
    
    // å¯åŠ¨ HTTP æœåŠ¡å™¨æš´éœ²æŒ‡æ ‡
    let addr: SocketAddr = "0.0.0.0:9090".parse()?;
    println!("Metrics server listening on http://{}/metrics", addr);
    
    Ok(())
}

// Prometheus é…ç½® (prometheus.yml)
// scrape_configs:
//   - job_name: 'rust_app'
//     static_configs:
//       - targets: ['localhost:9090']
```

### 2.3 é»„é‡‘æŒ‡æ ‡

**RED æ–¹æ³•** (è¯·æ±‚é©±åŠ¨æœåŠ¡):

- **Rate**: è¯·æ±‚é€Ÿç‡ (QPS)
- **Errors**: é”™è¯¯ç‡
- **Duration**: è¯·æ±‚å»¶è¿Ÿ

```rust
use metrics::{counter, histogram};

struct ServiceMetrics;

impl ServiceMetrics {
    fn record_request(&self, duration_ms: f64, is_error: bool) {
        // Rate: è¯·æ±‚é€Ÿç‡
        counter!("requests_total").increment(1);
        
        // Errors: é”™è¯¯ç‡
        if is_error {
            counter!("requests_errors_total").increment(1);
        }
        
        // Duration: å»¶è¿Ÿåˆ†å¸ƒ
        histogram!("request_duration_milliseconds").record(duration_ms);
    }
}
```

**USE æ–¹æ³•** (èµ„æºé©±åŠ¨æœåŠ¡):

- **Utilization**: èµ„æºä½¿ç”¨ç‡
- **Saturation**: èµ„æºé¥±å’Œåº¦
- **Errors**: é”™è¯¯æ•°

```rust
use metrics::gauge;

struct ResourceMetrics;

impl ResourceMetrics {
    fn record_cpu_usage(&self, cpu_percent: f64) {
        // Utilization: CPU ä½¿ç”¨ç‡
        gauge!("cpu_usage_percent").set(cpu_percent);
    }
    
    fn record_queue_length(&self, queue_len: f64) {
        // Saturation: é˜Ÿåˆ—é•¿åº¦
        gauge!("queue_length").set(queue_len);
    }
}
```

---

## 3. ç»“æ„åŒ–æ—¥å¿—

### 3.1 ä½¿ç”¨ tracing

```rust
use tracing::{info, warn, error, debug, trace};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

fn main() {
    init_logging();
    
    info!("Application started");
    debug!(config = ?load_config(), "Configuration loaded");
    
    match process_data() {
        Ok(result) => info!(result = ?result, "Data processed successfully"),
        Err(e) => error!(error = %e, "Failed to process data"),
    }
}

fn load_config() -> Config {
    Config { timeout_secs: 30 }
}

fn process_data() -> Result<String, String> {
    Ok("processed".to_string())
}

#[derive(Debug)]
struct Config {
    timeout_secs: u64,
}
```

### 3.2 æ—¥å¿—çº§åˆ«

```rust
use tracing::{Level, info, debug, trace};

fn process_request(request_id: u64, payload: &str) {
    // INFO: æ­£å¸¸ä¸šåŠ¡æµç¨‹
    info!(request_id = request_id, "Processing request");
    
    // DEBUG: è¯¦ç»†è°ƒè¯•ä¿¡æ¯
    debug!(request_id = request_id, payload = payload, "Request payload");
    
    // TRACE: æœ€è¯¦ç»†çš„è¿½è¸ªä¿¡æ¯
    trace!(request_id = request_id, "Entering validation phase");
    
    if payload.is_empty() {
        // WARN: è­¦å‘Šï¼Œä½†ä¸å½±å“ä¸»æµç¨‹
        tracing::warn!(request_id = request_id, "Empty payload received");
    }
    
    // ERROR: é”™è¯¯ï¼Œéœ€è¦äººå·¥ä»‹å…¥
    if let Err(e) = validate_payload(payload) {
        tracing::error!(request_id = request_id, error = %e, "Validation failed");
    }
}

fn validate_payload(payload: &str) -> Result<(), String> {
    if payload.is_empty() {
        Err("Empty payload".to_string())
    } else {
        Ok(())
    }
}
```

### 3.3 æ—¥å¿—ä¸Šä¸‹æ–‡

```rust
use tracing::{info, instrument};

#[instrument]
async fn handle_user_request(user_id: u64, action: String) -> Result<String, String> {
    info!("Handling user request");
    
    // è‡ªåŠ¨æ·»åŠ  user_id å’Œ action åˆ°æ‰€æœ‰æ—¥å¿—
    let result = process_action(&action).await?;
    
    info!(result = %result, "Request completed");
    Ok(result)
}

async fn process_action(action: &str) -> Result<String, String> {
    Ok(format!("Processed: {}", action))
}

// æ—¥å¿—è¾“å‡ºç¤ºä¾‹ï¼š
// INFO handle_user_request{user_id=123 action="create_order"}: Handling user request
// INFO handle_user_request{user_id=123 action="create_order"}: result="Processed: create_order" Request completed
```

---

## 4. åˆ†å¸ƒå¼è¿½è¸ª

### 4.1 OpenTelemetry

```rust
use opentelemetry::{global, KeyValue};
use opentelemetry_sdk::{trace as sdktrace, Resource};
use tracing_subscriber::{layer::SubscriberExt, Registry};

fn init_tracing() {
    // åˆ›å»º OTLP exporter
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(opentelemetry_otlp::new_exporter().tonic())
        .with_trace_config(
            sdktrace::config().with_resource(Resource::new(vec![
                KeyValue::new("service.name", "my-rust-service"),
            ])),
        )
        .install_batch(opentelemetry_sdk::runtime::Tokio)
        .expect("Failed to initialize tracer");
    
    // è®¾ç½® tracing subscriber
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    Registry::default()
        .with(telemetry)
        .with(tracing_subscriber::fmt::layer())
        .init();
}
```

### 4.2 è·¨æœåŠ¡è¿½è¸ª

```rust
use tracing::{info_span, instrument};
use opentelemetry::Context;

#[instrument]
async fn api_gateway_handler(request_id: String) -> Result<String, String> {
    info_span!("api_gateway").in_scope(|| {
        // è°ƒç”¨æœåŠ¡ A
        let service_a_result = call_service_a(&request_id);
        
        // è°ƒç”¨æœåŠ¡ B
        let service_b_result = call_service_b(&request_id);
        
        Ok(format!("{:?}, {:?}", service_a_result, service_b_result))
    })
}

fn call_service_a(request_id: &str) -> Result<String, String> {
    let _span = info_span!("call_service_a", service = "A", request_id = request_id).entered();
    
    // å®é™… HTTP è°ƒç”¨
    Ok("Service A response".to_string())
}

fn call_service_b(request_id: &str) -> Result<String, String> {
    let _span = info_span!("call_service_b", service = "B", request_id = request_id).entered();
    
    // å®é™… HTTP è°ƒç”¨
    Ok("Service B response".to_string())
}
```

### 4.3 æ€§èƒ½åˆ†æ

```rust
use tracing::{info_span, instrument};
use std::time::Instant;

#[instrument]
async fn slow_operation(data_size: usize) -> Result<String, String> {
    let start = Instant::now();
    
    // æ“ä½œ 1
    let _span1 = info_span!("database_query").entered();
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    drop(_span1);
    
    // æ“ä½œ 2
    let _span2 = info_span!("data_processing").entered();
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    drop(_span2);
    
    // æ“ä½œ 3
    let _span3 = info_span!("external_api_call").entered();
    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
    drop(_span3);
    
    let duration = start.elapsed();
    tracing::info!(duration_ms = duration.as_millis(), "Operation completed");
    
    Ok("processed".to_string())
}

// Trace è¾“å‡ºï¼š
// slow_operation (350ms)
// â”œâ”€ database_query (50ms)
// â”œâ”€ data_processing (100ms)
// â””â”€ external_api_call (200ms)
```

---

## 5. å¥åº·æ£€æŸ¥

### 5.1 liveness æ¢é’ˆ

```rust
use axum::{Router, routing::get, http::StatusCode};

async fn liveness() -> StatusCode {
    // ç®€å•æ£€æŸ¥ï¼šè¿›ç¨‹æ˜¯å¦å­˜æ´»
    StatusCode::OK
}

async fn readiness() -> StatusCode {
    // è¯¦ç»†æ£€æŸ¥ï¼šæ˜¯å¦å‡†å¤‡å¥½æ¥æ”¶æµé‡
    if check_database().await && check_cache().await {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    }
}

async fn check_database() -> bool {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    true
}

async fn check_cache() -> bool {
    // æ£€æŸ¥ç¼“å­˜è¿æ¥
    true
}

fn health_routes() -> Router {
    Router::new()
        .route("/health/liveness", get(liveness))
        .route("/health/readiness", get(readiness))
}
```

### 5.2 readiness æ¢é’ˆ

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use axum::{extract::State, http::StatusCode, Json};
use serde::Serialize;

#[derive(Clone)]
struct AppState {
    db_healthy: Arc<AtomicBool>,
    cache_healthy: Arc<AtomicBool>,
}

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    checks: Vec<HealthCheck>,
}

#[derive(Serialize)]
struct HealthCheck {
    name: String,
    status: String,
}

async fn readiness_detailed(State(state): State<AppState>) -> (StatusCode, Json<HealthResponse>) {
    let db_ok = state.db_healthy.load(Ordering::SeqCst);
    let cache_ok = state.cache_healthy.load(Ordering::SeqCst);
    
    let all_ok = db_ok && cache_ok;
    
    let response = HealthResponse {
        status: if all_ok { "UP".to_string() } else { "DOWN".to_string() },
        checks: vec![
            HealthCheck {
                name: "database".to_string(),
                status: if db_ok { "UP".to_string() } else { "DOWN".to_string() },
            },
            HealthCheck {
                name: "cache".to_string(),
                status: if cache_ok { "UP".to_string() } else { "DOWN".to_string() },
            },
        ],
    };
    
    let status = if all_ok {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    
    (status, Json(response))
}
```

### 5.3 ä¾èµ–å¥åº·

```rust
use tokio::time::{timeout, Duration};

struct DependencyChecker;

impl DependencyChecker {
    async fn check_database(&self) -> Result<(), String> {
        match timeout(Duration::from_secs(2), self.ping_database()).await {
            Ok(Ok(())) => Ok(()),
            Ok(Err(e)) => Err(format!("Database unhealthy: {}", e)),
            Err(_) => Err("Database check timeout".to_string()),
        }
    }
    
    async fn ping_database(&self) -> Result<(), String> {
        // å®é™…æ•°æ®åº“ ping é€»è¾‘
        Ok(())
    }
    
    async fn check_all_dependencies(&self) -> Vec<(String, Result<(), String>)> {
        let db_result = self.check_database().await;
        let cache_result = self.check_cache().await;
        let api_result = self.check_external_api().await;
        
        vec![
            ("database".to_string(), db_result),
            ("cache".to_string(), cache_result),
            ("external_api".to_string(), api_result),
        ]
    }
    
    async fn check_cache(&self) -> Result<(), String> {
        Ok(())
    }
    
    async fn check_external_api(&self) -> Result<(), String> {
        Ok(())
    }
}
```

---

## 6. å‘Šè­¦è§„åˆ™

### 6.1 SLO/SLI/SLA

**SLI (Service Level Indicator)**: æœåŠ¡è´¨é‡æŒ‡æ ‡

```rust
// å¯ç”¨æ€§ SLI = æˆåŠŸè¯·æ±‚ / æ€»è¯·æ±‚
// å»¶è¿Ÿ SLI = P99 å»¶è¿Ÿ
```

**SLO (Service Level Objective)**: æœåŠ¡è´¨é‡ç›®æ ‡

```yaml
# SLO å®šä¹‰
availability_slo: 99.9%  # 3ä¸ª9
latency_slo_p99: 500ms
error_rate_slo: 0.1%
```

**SLA (Service Level Agreement)**: æœåŠ¡è´¨é‡åè®®

```text
å¦‚æœå¯ç”¨æ€§ < 99.9%ï¼Œåˆ™ï¼š
- 99.0% - 99.9%: é€€æ¬¾ 10%
- 95.0% - 99.0%: é€€æ¬¾ 25%
- < 95.0%: é€€æ¬¾ 50%
```

### 6.2 å‘Šè­¦æœ€ä½³å®è·µ

```yaml
# Prometheus å‘Šè­¦è§„åˆ™
groups:
  - name: service_alerts
    rules:
      # é«˜é”™è¯¯ç‡å‘Šè­¦
      - alert: HighErrorRate
        expr: |
          rate(http_requests_errors_total[5m])
          /
          rate(http_requests_total[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }}"

      # P99 å»¶è¿Ÿå‘Šè­¦
      - alert: HighLatency
        expr: |
          histogram_quantile(0.99,
            rate(http_request_duration_seconds_bucket[5m])
          ) > 1.0
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "P99 latency is {{ $value }}s"

      # æœåŠ¡ä¸å¯ç”¨å‘Šè­¦
      - alert: ServiceDown
        expr: up{job="rust_app"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
```

### 6.3 å‘Šè­¦é™å™ª

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;

/// å‘Šè­¦å»é‡å™¨
struct AlertDeduplicator {
    last_alerts: HashMap<String, Instant>,
    cooldown: Duration,
}

impl AlertDeduplicator {
    fn new(cooldown: Duration) -> Self {
        Self {
            last_alerts: HashMap::new(),
            cooldown,
        }
    }
    
    fn should_send_alert(&mut self, alert_name: &str) -> bool {
        let now = Instant::now();
        
        if let Some(last_time) = self.last_alerts.get(alert_name) {
            if now.duration_since(*last_time) < self.cooldown {
                // å†·å´æœŸå†…ï¼Œä¸å‘é€
                return false;
            }
        }
        
        // å‘é€å‘Šè­¦ï¼Œå¹¶è®°å½•æ—¶é—´
        self.last_alerts.insert(alert_name.to_string(), now);
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_alert_deduplication() {
        let mut dedup = AlertDeduplicator::new(Duration::from_secs(60));
        
        // ç¬¬ä¸€æ¬¡åº”è¯¥å‘é€
        assert!(dedup.should_send_alert("HighErrorRate"));
        
        // 60ç§’å†…ä¸åº”è¯¥é‡å¤å‘é€
        assert!(!dedup.should_send_alert("HighErrorRate"));
        
        // ä¸åŒå‘Šè­¦ä¸å—å½±å“
        assert!(dedup.should_send_alert("HighLatency"));
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 å®Œæ•´å¯è§‚æµ‹æ€§ç³»ç»Ÿ

```rust
use metrics::{counter, histogram, gauge};
use tracing::{info, error, instrument};
use std::time::Instant;

struct ObservableService {
    name: String,
}

impl ObservableService {
    fn new(name: String) -> Self {
        Self { name }
    }
    
    #[instrument(skip(self))]
    async fn handle_request(&self, request_id: String, method: String, path: String) -> Result<String, String> {
        let start = Instant::now();
        
        // æŒ‡æ ‡ï¼šè¯·æ±‚è®¡æ•°
        counter!("requests_total",
            "service" => self.name.clone(),
            "method" => method.clone(),
            "path" => path.clone()
        ).increment(1);
        
        // æ—¥å¿—ï¼šè¯·æ±‚å¼€å§‹
        info!(
            service = %self.name,
            request_id = %request_id,
            method = %method,
            path = %path,
            "Request started"
        );
        
        // å¤„ç†è¯·æ±‚
        let result = self.process_request(&request_id, &method, &path).await;
        
        // æŒ‡æ ‡ï¼šå“åº”æ—¶é—´
        histogram!("request_duration_seconds",
            "service" => self.name.clone(),
            "method" => method.clone()
        ).record(start.elapsed().as_secs_f64());
        
        // æŒ‡æ ‡ï¼šæˆåŠŸ/å¤±è´¥è®¡æ•°
        match &result {
            Ok(_) => {
                counter!("requests_success_total",
                    "service" => self.name.clone()
                ).increment(1);
                
                info!(
                    request_id = %request_id,
                    duration_ms = start.elapsed().as_millis(),
                    "Request completed successfully"
                );
            }
            Err(e) => {
                counter!("requests_error_total",
                    "service" => self.name.clone()
                ).increment(1);
                
                error!(
                    request_id = %request_id,
                    error = %e,
                    duration_ms = start.elapsed().as_millis(),
                    "Request failed"
                );
            }
        }
        
        result
    }
    
    async fn process_request(&self, request_id: &str, method: &str, path: &str) -> Result<String, String> {
        // æ¨¡æ‹Ÿå¤„ç†
        Ok(format!("Processed {} {}", method, path))
    }
}
```

### 7.2 æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿

```rust
use metrics::gauge;
use sysinfo::{System, SystemExt, ProcessExt};

struct PerformanceMonitor {
    system: System,
}

impl PerformanceMonitor {
    fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }
    
    fn update_system_metrics(&mut self) {
        self.system.refresh_all();
        
        // CPU ä½¿ç”¨ç‡
        gauge!("system_cpu_usage_percent").set(self.system.global_cpu_info().cpu_usage() as f64);
        
        // å†…å­˜ä½¿ç”¨
        let used_memory = self.system.used_memory() as f64;
        let total_memory = self.system.total_memory() as f64;
        gauge!("system_memory_used_bytes").set(used_memory);
        gauge!("system_memory_total_bytes").set(total_memory);
        gauge!("system_memory_usage_percent").set((used_memory / total_memory) * 100.0);
        
        // ç£ç›˜ä½¿ç”¨ï¼ˆç®€åŒ–ï¼‰
        // gauge!("system_disk_usage_percent").set(disk_usage);
    }
    
    fn update_process_metrics(&mut self) {
        if let Some(process) = self.system.process(sysinfo::get_current_pid().unwrap()) {
            // è¿›ç¨‹å†…å­˜
            gauge!("process_memory_bytes").set(process.memory() as f64 * 1024.0);
            
            // è¿›ç¨‹ CPU
            gauge!("process_cpu_usage_percent").set(process.cpu_usage() as f64);
        }
    }
}
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ä¸‰æ”¯æŸ±**: æŒ‡æ ‡ã€æ—¥å¿—ã€è¿½è¸ªç¼ºä¸€ä¸å¯
2. **é»„é‡‘æŒ‡æ ‡**: RED (è¯·æ±‚æœåŠ¡) æˆ– USE (èµ„æºæœåŠ¡)
3. **ç»“æ„åŒ–æ—¥å¿—**: ä½¿ç”¨ `tracing`ï¼Œé¿å…å­—ç¬¦ä¸²æ‹¼æ¥
4. **åˆ†å¸ƒå¼è¿½è¸ª**: ä½¿ç”¨ OpenTelemetry å®ç°è·¨æœåŠ¡è¿½è¸ª
5. **å¥åº·æ£€æŸ¥**: åŒºåˆ† liveness å’Œ readiness

### æœ€ä½³å®è·µ

| ç»„ä»¶ | å·¥å…· | æ¨èé…ç½® |
|------|------|---------|
| **æŒ‡æ ‡** | Prometheus + metrics | 15s æŠ“å–é—´éš” |
| **æ—¥å¿—** | tracing + Loki | INFO çº§åˆ«ï¼Œç»“æ„åŒ– |
| **è¿½è¸ª** | OpenTelemetry + Jaeger | 10% é‡‡æ ·ç‡ |
| **å‘Šè­¦** | Alertmanager | 5åˆ†é’Ÿè¯„ä¼°å‘¨æœŸ |
| **ä»ªè¡¨æ¿** | Grafana | RED/USE æŒ‡æ ‡ |

**å¸¸è§é™·é˜±**:

- âŒ æ—¥å¿—è¿‡å¤šï¼Œå½±å“æ€§èƒ½
- âŒ ç¼ºå°‘ä¸Šä¸‹æ–‡ï¼Œéš¾ä»¥å®šä½é—®é¢˜
- âŒ å‘Šè­¦å¤ªå¤šï¼Œå½¢æˆå™ªéŸ³
- âŒ ç¼ºå°‘ç«¯åˆ°ç«¯è¿½è¸ª
- âŒ ç›‘æ§æŒ‡æ ‡ä¸å…¨é¢
- âœ… ä½¿ç”¨é‡‡æ ·å’Œæ—¥å¿—çº§åˆ«æ§åˆ¶é‡
- âœ… ä½¿ç”¨ `tracing` è‡ªåŠ¨æ·»åŠ ä¸Šä¸‹æ–‡
- âœ… å‘Šè­¦å»é‡å’Œèšåˆ
- âœ… ä½¿ç”¨ OpenTelemetry æ ‡å‡†
- âœ… å®ç° RED/USE é»„é‡‘æŒ‡æ ‡

---

## ğŸ“š å‚è€ƒèµ„æº

**Rust åº“**:

- [metrics](https://docs.rs/metrics/) - æŒ‡æ ‡æ”¶é›†
- [tracing](https://docs.rs/tracing/) - ç»“æ„åŒ–æ—¥å¿—å’Œè¿½è¸ª
- [opentelemetry](https://docs.rs/opentelemetry/) - åˆ†å¸ƒå¼è¿½è¸ª
- [sysinfo](https://docs.rs/sysinfo/) - ç³»ç»Ÿä¿¡æ¯

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: é”™è¯¯å¤„ç†æŒ‡å—](./01_é”™è¯¯å¤„ç†æŒ‡å—.md)
- [Tier 2: éƒ¨ç½²å®è·µæŒ‡å—](./05_éƒ¨ç½²å®è·µæŒ‡å—.md)
- [Tier 3: API å‚è€ƒ](../tier_03_references/)

---

**æ–‡æ¡£ç»´æŠ¤**: C13 Reliability Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
