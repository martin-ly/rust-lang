# C13 Reliability - Tier 2: 监控可观测性指南

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 40 分钟

---

## 📋 目录

- [C13 Reliability - Tier 2: 监控可观测性指南](#c13-reliability---tier-2-监控可观测性指南)
  - [📋 目录](#-目录)
  - [1. 可观测性三支柱](#1-可观测性三支柱)
    - [1.1 指标 (Metrics)](#11-指标-metrics)
    - [1.2 日志 (Logs)](#12-日志-logs)
    - [1.3 追踪 (Traces)](#13-追踪-traces)
  - [2. 指标收集](#2-指标收集)
    - [2.1 使用 metrics crate](#21-使用-metrics-crate)
    - [2.2 Prometheus 集成](#22-prometheus-集成)
    - [2.3 黄金指标](#23-黄金指标)
  - [3. 结构化日志](#3-结构化日志)
    - [3.1 使用 tracing](#31-使用-tracing)
    - [3.2 日志级别](#32-日志级别)
    - [3.3 日志上下文](#33-日志上下文)
  - [4. 分布式追踪](#4-分布式追踪)
    - [4.1 OpenTelemetry](#41-opentelemetry)
    - [4.2 跨服务追踪](#42-跨服务追踪)
    - [4.3 性能分析](#43-性能分析)
  - [5. 健康检查](#5-健康检查)
    - [5.1 liveness 探针](#51-liveness-探针)
    - [5.2 readiness 探针](#52-readiness-探针)
    - [5.3 依赖健康](#53-依赖健康)
  - [6. 告警规则](#6-告警规则)
    - [6.1 SLO/SLI/SLA](#61-sloslisla)
    - [6.2 告警最佳实践](#62-告警最佳实践)
    - [6.3 告警降噪](#63-告警降噪)
  - [7. 实战案例](#7-实战案例)
    - [7.1 完整可观测性系统](#71-完整可观测性系统)
    - [7.2 性能监控仪表板](#72-性能监控仪表板)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 可观测性三支柱

### 1.1 指标 (Metrics)

**定义**: 数值化的时间序列数据

**类型**:

- **Counter**: 单调递增的计数器 (请求总数、错误总数)
- **Gauge**: 可增可减的指标 (CPU 使用率、内存使用)
- **Histogram**: 分布统计 (响应时间分布)
- **Summary**: 百分位数 (P50, P95, P99)

```rust
use metrics::{counter, gauge, histogram};

fn handle_request() {
    // 计数器：请求总数
    counter!("http_requests_total", "method" => "GET", "path" => "/api/users").increment(1);
    
    // 直方图：响应时间
    let start = std::time::Instant::now();
    // ... 处理请求 ...
    histogram!("http_request_duration_seconds").record(start.elapsed().as_secs_f64());
    
    // 仪表盘：当前连接数
    gauge!("active_connections").set(42.0);
}
```

### 1.2 日志 (Logs)

**定义**: 离散的事件记录

**级别**: ERROR > WARN > INFO > DEBUG > TRACE

```rust
use tracing::{info, warn, error, debug};

fn process_order(order_id: u64) {
    info!(order_id = order_id, "Processing order");
    
    match fetch_order_details(order_id) {
        Ok(details) => {
            debug!(order_id = order_id, details = ?details, "Order details fetched");
        }
        Err(e) => {
            error!(order_id = order_id, error = %e, "Failed to fetch order");
        }
    }
}

fn fetch_order_details(order_id: u64) -> Result<OrderDetails, String> {
    Ok(OrderDetails { id: order_id, amount: 100.0 })
}

#[derive(Debug)]
struct OrderDetails {
    id: u64,
    amount: f64,
}
```

### 1.3 追踪 (Traces)

**定义**: 跨服务的请求调用链

```text
Root Span: HTTP GET /api/orders/123
├─ Span: Database Query (50ms)
├─ Span: Cache Lookup (10ms)
└─ Span: External API Call (200ms)
   └─ Span: HTTP Request (150ms)
```

```rust
use tracing::{info_span, instrument};

#[instrument]
async fn get_order(order_id: u64) -> Result<Order, String> {
    let span = info_span!("get_order", order_id = order_id);
    let _enter = span.enter();
    
    // 数据库查询
    let order = fetch_from_db(order_id).await?;
    
    // 外部 API 调用
    let enriched = enrich_order_data(order).await?;
    
    Ok(enriched)
}

async fn fetch_from_db(order_id: u64) -> Result<Order, String> {
    Ok(Order { id: order_id, status: "pending".to_string() })
}

async fn enrich_order_data(order: Order) -> Result<Order, String> {
    Ok(order)
}

#[derive(Debug)]
struct Order {
    id: u64,
    status: String,
}
```

---

## 2. 指标收集

### 2.1 使用 metrics crate

```rust
use metrics::{counter, histogram, gauge};
use std::time::Instant;

struct RequestHandler;

impl RequestHandler {
    fn handle_request(&self, method: &str, path: &str) -> Result<String, String> {
        let start = Instant::now();
        
        // 计数器：总请求数
        counter!("http_requests_total", 
            "method" => method.to_string(), 
            "path" => path.to_string()
        ).increment(1);
        
        // 处理请求
        let result = self.process(method, path);
        
        // 记录响应时间
        histogram!("http_request_duration_seconds",
            "method" => method.to_string(),
            "path" => path.to_string()
        ).record(start.elapsed().as_secs_f64());
        
        // 记录结果
        match &result {
            Ok(_) => counter!("http_requests_success_total").increment(1),
            Err(_) => counter!("http_requests_error_total").increment(1),
        }
        
        result
    }
    
    fn process(&self, method: &str, path: &str) -> Result<String, String> {
        Ok(format!("Processed {} {}", method, path))
    }
}
```

### 2.2 Prometheus 集成

```rust
use metrics_exporter_prometheus::PrometheusBuilder;
use std::net::SocketAddr;

async fn setup_metrics() -> Result<(), Box<dyn std::error::Error>> {
    // 创建 Prometheus exporter
    let builder = PrometheusBuilder::new();
    builder.install()?;
    
    // 启动 HTTP 服务器暴露指标
    let addr: SocketAddr = "0.0.0.0:9090".parse()?;
    println!("Metrics server listening on http://{}/metrics", addr);
    
    Ok(())
}

// Prometheus 配置 (prometheus.yml)
// scrape_configs:
//   - job_name: 'rust_app'
//     static_configs:
//       - targets: ['localhost:9090']
```

### 2.3 黄金指标

**RED 方法** (请求驱动服务):

- **Rate**: 请求速率 (QPS)
- **Errors**: 错误率
- **Duration**: 请求延迟

```rust
use metrics::{counter, histogram};

struct ServiceMetrics;

impl ServiceMetrics {
    fn record_request(&self, duration_ms: f64, is_error: bool) {
        // Rate: 请求速率
        counter!("requests_total").increment(1);
        
        // Errors: 错误率
        if is_error {
            counter!("requests_errors_total").increment(1);
        }
        
        // Duration: 延迟分布
        histogram!("request_duration_milliseconds").record(duration_ms);
    }
}
```

**USE 方法** (资源驱动服务):

- **Utilization**: 资源使用率
- **Saturation**: 资源饱和度
- **Errors**: 错误数

```rust
use metrics::gauge;

struct ResourceMetrics;

impl ResourceMetrics {
    fn record_cpu_usage(&self, cpu_percent: f64) {
        // Utilization: CPU 使用率
        gauge!("cpu_usage_percent").set(cpu_percent);
    }
    
    fn record_queue_length(&self, queue_len: f64) {
        // Saturation: 队列长度
        gauge!("queue_length").set(queue_len);
    }
}
```

---

## 3. 结构化日志

### 3.1 使用 tracing

```rust
use tracing::{info, warn, error, debug, trace};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

fn main() {
    init_logging();
    
    info!("Application started");
    debug!(config = ?load_config(), "Configuration loaded");
    
    match process_data() {
        Ok(result) => info!(result = ?result, "Data processed successfully"),
        Err(e) => error!(error = %e, "Failed to process data"),
    }
}

fn load_config() -> Config {
    Config { timeout_secs: 30 }
}

fn process_data() -> Result<String, String> {
    Ok("processed".to_string())
}

#[derive(Debug)]
struct Config {
    timeout_secs: u64,
}
```

### 3.2 日志级别

```rust
use tracing::{Level, info, debug, trace};

fn process_request(request_id: u64, payload: &str) {
    // INFO: 正常业务流程
    info!(request_id = request_id, "Processing request");
    
    // DEBUG: 详细调试信息
    debug!(request_id = request_id, payload = payload, "Request payload");
    
    // TRACE: 最详细的追踪信息
    trace!(request_id = request_id, "Entering validation phase");
    
    if payload.is_empty() {
        // WARN: 警告，但不影响主流程
        tracing::warn!(request_id = request_id, "Empty payload received");
    }
    
    // ERROR: 错误，需要人工介入
    if let Err(e) = validate_payload(payload) {
        tracing::error!(request_id = request_id, error = %e, "Validation failed");
    }
}

fn validate_payload(payload: &str) -> Result<(), String> {
    if payload.is_empty() {
        Err("Empty payload".to_string())
    } else {
        Ok(())
    }
}
```

### 3.3 日志上下文

```rust
use tracing::{info, instrument};

#[instrument]
async fn handle_user_request(user_id: u64, action: String) -> Result<String, String> {
    info!("Handling user request");
    
    // 自动添加 user_id 和 action 到所有日志
    let result = process_action(&action).await?;
    
    info!(result = %result, "Request completed");
    Ok(result)
}

async fn process_action(action: &str) -> Result<String, String> {
    Ok(format!("Processed: {}", action))
}

// 日志输出示例：
// INFO handle_user_request{user_id=123 action="create_order"}: Handling user request
// INFO handle_user_request{user_id=123 action="create_order"}: result="Processed: create_order" Request completed
```

---

## 4. 分布式追踪

### 4.1 OpenTelemetry

```rust
use opentelemetry::{global, KeyValue};
use opentelemetry_sdk::{trace as sdktrace, Resource};
use tracing_subscriber::{layer::SubscriberExt, Registry};

fn init_tracing() {
    // 创建 OTLP exporter
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(opentelemetry_otlp::new_exporter().tonic())
        .with_trace_config(
            sdktrace::config().with_resource(Resource::new(vec![
                KeyValue::new("service.name", "my-rust-service"),
            ])),
        )
        .install_batch(opentelemetry_sdk::runtime::Tokio)
        .expect("Failed to initialize tracer");
    
    // 设置 tracing subscriber
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    Registry::default()
        .with(telemetry)
        .with(tracing_subscriber::fmt::layer())
        .init();
}
```

### 4.2 跨服务追踪

```rust
use tracing::{info_span, instrument};
use opentelemetry::Context;

#[instrument]
async fn api_gateway_handler(request_id: String) -> Result<String, String> {
    info_span!("api_gateway").in_scope(|| {
        // 调用服务 A
        let service_a_result = call_service_a(&request_id);
        
        // 调用服务 B
        let service_b_result = call_service_b(&request_id);
        
        Ok(format!("{:?}, {:?}", service_a_result, service_b_result))
    })
}

fn call_service_a(request_id: &str) -> Result<String, String> {
    let _span = info_span!("call_service_a", service = "A", request_id = request_id).entered();
    
    // 实际 HTTP 调用
    Ok("Service A response".to_string())
}

fn call_service_b(request_id: &str) -> Result<String, String> {
    let _span = info_span!("call_service_b", service = "B", request_id = request_id).entered();
    
    // 实际 HTTP 调用
    Ok("Service B response".to_string())
}
```

### 4.3 性能分析

```rust
use tracing::{info_span, instrument};
use std::time::Instant;

#[instrument]
async fn slow_operation(data_size: usize) -> Result<String, String> {
    let start = Instant::now();
    
    // 操作 1
    let _span1 = info_span!("database_query").entered();
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    drop(_span1);
    
    // 操作 2
    let _span2 = info_span!("data_processing").entered();
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    drop(_span2);
    
    // 操作 3
    let _span3 = info_span!("external_api_call").entered();
    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
    drop(_span3);
    
    let duration = start.elapsed();
    tracing::info!(duration_ms = duration.as_millis(), "Operation completed");
    
    Ok("processed".to_string())
}

// Trace 输出：
// slow_operation (350ms)
// ├─ database_query (50ms)
// ├─ data_processing (100ms)
// └─ external_api_call (200ms)
```

---

## 5. 健康检查

### 5.1 liveness 探针

```rust
use axum::{Router, routing::get, http::StatusCode};

async fn liveness() -> StatusCode {
    // 简单检查：进程是否存活
    StatusCode::OK
}

async fn readiness() -> StatusCode {
    // 详细检查：是否准备好接收流量
    if check_database().await && check_cache().await {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    }
}

async fn check_database() -> bool {
    // 检查数据库连接
    true
}

async fn check_cache() -> bool {
    // 检查缓存连接
    true
}

fn health_routes() -> Router {
    Router::new()
        .route("/health/liveness", get(liveness))
        .route("/health/readiness", get(readiness))
}
```

### 5.2 readiness 探针

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use axum::{extract::State, http::StatusCode, Json};
use serde::Serialize;

#[derive(Clone)]
struct AppState {
    db_healthy: Arc<AtomicBool>,
    cache_healthy: Arc<AtomicBool>,
}

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    checks: Vec<HealthCheck>,
}

#[derive(Serialize)]
struct HealthCheck {
    name: String,
    status: String,
}

async fn readiness_detailed(State(state): State<AppState>) -> (StatusCode, Json<HealthResponse>) {
    let db_ok = state.db_healthy.load(Ordering::SeqCst);
    let cache_ok = state.cache_healthy.load(Ordering::SeqCst);
    
    let all_ok = db_ok && cache_ok;
    
    let response = HealthResponse {
        status: if all_ok { "UP".to_string() } else { "DOWN".to_string() },
        checks: vec![
            HealthCheck {
                name: "database".to_string(),
                status: if db_ok { "UP".to_string() } else { "DOWN".to_string() },
            },
            HealthCheck {
                name: "cache".to_string(),
                status: if cache_ok { "UP".to_string() } else { "DOWN".to_string() },
            },
        ],
    };
    
    let status = if all_ok {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    
    (status, Json(response))
}
```

### 5.3 依赖健康

```rust
use tokio::time::{timeout, Duration};

struct DependencyChecker;

impl DependencyChecker {
    async fn check_database(&self) -> Result<(), String> {
        match timeout(Duration::from_secs(2), self.ping_database()).await {
            Ok(Ok(())) => Ok(()),
            Ok(Err(e)) => Err(format!("Database unhealthy: {}", e)),
            Err(_) => Err("Database check timeout".to_string()),
        }
    }
    
    async fn ping_database(&self) -> Result<(), String> {
        // 实际数据库 ping 逻辑
        Ok(())
    }
    
    async fn check_all_dependencies(&self) -> Vec<(String, Result<(), String>)> {
        let db_result = self.check_database().await;
        let cache_result = self.check_cache().await;
        let api_result = self.check_external_api().await;
        
        vec![
            ("database".to_string(), db_result),
            ("cache".to_string(), cache_result),
            ("external_api".to_string(), api_result),
        ]
    }
    
    async fn check_cache(&self) -> Result<(), String> {
        Ok(())
    }
    
    async fn check_external_api(&self) -> Result<(), String> {
        Ok(())
    }
}
```

---

## 6. 告警规则

### 6.1 SLO/SLI/SLA

**SLI (Service Level Indicator)**: 服务质量指标

```rust
// 可用性 SLI = 成功请求 / 总请求
// 延迟 SLI = P99 延迟
```

**SLO (Service Level Objective)**: 服务质量目标

```yaml
# SLO 定义
availability_slo: 99.9%  # 3个9
latency_slo_p99: 500ms
error_rate_slo: 0.1%
```

**SLA (Service Level Agreement)**: 服务质量协议

```text
如果可用性 < 99.9%，则：
- 99.0% - 99.9%: 退款 10%
- 95.0% - 99.0%: 退款 25%
- < 95.0%: 退款 50%
```

### 6.2 告警最佳实践

```yaml
# Prometheus 告警规则
groups:
  - name: service_alerts
    rules:
      # 高错误率告警
      - alert: HighErrorRate
        expr: |
          rate(http_requests_errors_total[5m])
          /
          rate(http_requests_total[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }}"

      # P99 延迟告警
      - alert: HighLatency
        expr: |
          histogram_quantile(0.99,
            rate(http_request_duration_seconds_bucket[5m])
          ) > 1.0
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "P99 latency is {{ $value }}s"

      # 服务不可用告警
      - alert: ServiceDown
        expr: up{job="rust_app"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
```

### 6.3 告警降噪

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;

/// 告警去重器
struct AlertDeduplicator {
    last_alerts: HashMap<String, Instant>,
    cooldown: Duration,
}

impl AlertDeduplicator {
    fn new(cooldown: Duration) -> Self {
        Self {
            last_alerts: HashMap::new(),
            cooldown,
        }
    }
    
    fn should_send_alert(&mut self, alert_name: &str) -> bool {
        let now = Instant::now();
        
        if let Some(last_time) = self.last_alerts.get(alert_name) {
            if now.duration_since(*last_time) < self.cooldown {
                // 冷却期内，不发送
                return false;
            }
        }
        
        // 发送告警，并记录时间
        self.last_alerts.insert(alert_name.to_string(), now);
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_alert_deduplication() {
        let mut dedup = AlertDeduplicator::new(Duration::from_secs(60));
        
        // 第一次应该发送
        assert!(dedup.should_send_alert("HighErrorRate"));
        
        // 60秒内不应该重复发送
        assert!(!dedup.should_send_alert("HighErrorRate"));
        
        // 不同告警不受影响
        assert!(dedup.should_send_alert("HighLatency"));
    }
}
```

---

## 7. 实战案例

### 7.1 完整可观测性系统

```rust
use metrics::{counter, histogram, gauge};
use tracing::{info, error, instrument};
use std::time::Instant;

struct ObservableService {
    name: String,
}

impl ObservableService {
    fn new(name: String) -> Self {
        Self { name }
    }
    
    #[instrument(skip(self))]
    async fn handle_request(&self, request_id: String, method: String, path: String) -> Result<String, String> {
        let start = Instant::now();
        
        // 指标：请求计数
        counter!("requests_total",
            "service" => self.name.clone(),
            "method" => method.clone(),
            "path" => path.clone()
        ).increment(1);
        
        // 日志：请求开始
        info!(
            service = %self.name,
            request_id = %request_id,
            method = %method,
            path = %path,
            "Request started"
        );
        
        // 处理请求
        let result = self.process_request(&request_id, &method, &path).await;
        
        // 指标：响应时间
        histogram!("request_duration_seconds",
            "service" => self.name.clone(),
            "method" => method.clone()
        ).record(start.elapsed().as_secs_f64());
        
        // 指标：成功/失败计数
        match &result {
            Ok(_) => {
                counter!("requests_success_total",
                    "service" => self.name.clone()
                ).increment(1);
                
                info!(
                    request_id = %request_id,
                    duration_ms = start.elapsed().as_millis(),
                    "Request completed successfully"
                );
            }
            Err(e) => {
                counter!("requests_error_total",
                    "service" => self.name.clone()
                ).increment(1);
                
                error!(
                    request_id = %request_id,
                    error = %e,
                    duration_ms = start.elapsed().as_millis(),
                    "Request failed"
                );
            }
        }
        
        result
    }
    
    async fn process_request(&self, request_id: &str, method: &str, path: &str) -> Result<String, String> {
        // 模拟处理
        Ok(format!("Processed {} {}", method, path))
    }
}
```

### 7.2 性能监控仪表板

```rust
use metrics::gauge;
use sysinfo::{System, SystemExt, ProcessExt};

struct PerformanceMonitor {
    system: System,
}

impl PerformanceMonitor {
    fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }
    
    fn update_system_metrics(&mut self) {
        self.system.refresh_all();
        
        // CPU 使用率
        gauge!("system_cpu_usage_percent").set(self.system.global_cpu_info().cpu_usage() as f64);
        
        // 内存使用
        let used_memory = self.system.used_memory() as f64;
        let total_memory = self.system.total_memory() as f64;
        gauge!("system_memory_used_bytes").set(used_memory);
        gauge!("system_memory_total_bytes").set(total_memory);
        gauge!("system_memory_usage_percent").set((used_memory / total_memory) * 100.0);
        
        // 磁盘使用（简化）
        // gauge!("system_disk_usage_percent").set(disk_usage);
    }
    
    fn update_process_metrics(&mut self) {
        if let Some(process) = self.system.process(sysinfo::get_current_pid().unwrap()) {
            // 进程内存
            gauge!("process_memory_bytes").set(process.memory() as f64 * 1024.0);
            
            // 进程 CPU
            gauge!("process_cpu_usage_percent").set(process.cpu_usage() as f64);
        }
    }
}
```

---

## 8. 总结

### 核心要点

1. **三支柱**: 指标、日志、追踪缺一不可
2. **黄金指标**: RED (请求服务) 或 USE (资源服务)
3. **结构化日志**: 使用 `tracing`，避免字符串拼接
4. **分布式追踪**: 使用 OpenTelemetry 实现跨服务追踪
5. **健康检查**: 区分 liveness 和 readiness

### 最佳实践

| 组件 | 工具 | 推荐配置 |
|------|------|---------|
| **指标** | Prometheus + metrics | 15s 抓取间隔 |
| **日志** | tracing + Loki | INFO 级别，结构化 |
| **追踪** | OpenTelemetry + Jaeger | 10% 采样率 |
| **告警** | Alertmanager | 5分钟评估周期 |
| **仪表板** | Grafana | RED/USE 指标 |

**常见陷阱**:

- ❌ 日志过多，影响性能
- ❌ 缺少上下文，难以定位问题
- ❌ 告警太多，形成噪音
- ❌ 缺少端到端追踪
- ❌ 监控指标不全面
- ✅ 使用采样和日志级别控制量
- ✅ 使用 `tracing` 自动添加上下文
- ✅ 告警去重和聚合
- ✅ 使用 OpenTelemetry 标准
- ✅ 实现 RED/USE 黄金指标

---

## 📚 参考资源

**Rust 库**:

- [metrics](https://docs.rs/metrics/) - 指标收集
- [tracing](https://docs.rs/tracing/) - 结构化日志和追踪
- [opentelemetry](https://docs.rs/opentelemetry/) - 分布式追踪
- [sysinfo](https://docs.rs/sysinfo/) - 系统信息

**相关文档**:

- [Tier 2: 错误处理指南](./01_错误处理指南.md)
- [Tier 2: 部署实践指南](./05_部署实践指南.md)
- [Tier 3: API 参考](../tier_03_references/)

---

**文档维护**: C13 Reliability Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
