# C13 Reliability - Tier 2: 部署实践指南

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 35 分钟

---

## 📊 目录

- [C13 Reliability - Tier 2: 部署实践指南](#c13-reliability---tier-2-部署实践指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 构建优化](#1-构建优化)
    - [1.1 Release 构建](#11-release-构建)
    - [1.2 二进制大小优化](#12-二进制大小优化)
    - [1.3 编译时间优化](#13-编译时间优化)
  - [2. Docker 容器化](#2-docker-容器化)
    - [2.1 多阶段构建](#21-多阶段构建)
    - [2.2 最小化镜像](#22-最小化镜像)
    - [2.3 安全加固](#23-安全加固)
  - [3. Kubernetes 部署](#3-kubernetes-部署)
    - [3.1 Deployment 配置](#31-deployment-配置)
    - [3.2 Service 与 Ingress](#32-service-与-ingress)
    - [3.3 滚动更新](#33-滚动更新)
  - [4. 配置管理](#4-配置管理)
    - [4.1 环境变量](#41-环境变量)
    - [4.2 配置文件](#42-配置文件)
    - [4.3 Secret 管理](#43-secret-管理)
  - [5. 日志与监控](#5-日志与监控)
    - [5.1 日志收集](#51-日志收集)
    - [5.2 指标暴露](#52-指标暴露)
    - [5.3 健康检查](#53-健康检查)
  - [6. 弹性伸缩](#6-弹性伸缩)
    - [6.1 HPA 水平扩展](#61-hpa-水平扩展)
    - [6.2 VPA 垂直扩展](#62-vpa-垂直扩展)
    - [6.3 资源限制](#63-资源限制)
  - [7. 实战案例](#7-实战案例)
    - [7.1 完整部署流程](#71-完整部署流程)
    - [7.2 蓝绿部署](#72-蓝绿部署)
    - [7.3 金丝雀发布](#73-金丝雀发布)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

## 📋 目录

- [C13 Reliability - Tier 2: 部署实践指南](#c13-reliability---tier-2-部署实践指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 构建优化](#1-构建优化)
    - [1.1 Release 构建](#11-release-构建)
    - [1.2 二进制大小优化](#12-二进制大小优化)
    - [1.3 编译时间优化](#13-编译时间优化)
  - [2. Docker 容器化](#2-docker-容器化)
    - [2.1 多阶段构建](#21-多阶段构建)
    - [2.2 最小化镜像](#22-最小化镜像)
    - [2.3 安全加固](#23-安全加固)
  - [3. Kubernetes 部署](#3-kubernetes-部署)
    - [3.1 Deployment 配置](#31-deployment-配置)
    - [3.2 Service 与 Ingress](#32-service-与-ingress)
    - [3.3 滚动更新](#33-滚动更新)
  - [4. 配置管理](#4-配置管理)
    - [4.1 环境变量](#41-环境变量)
    - [4.2 配置文件](#42-配置文件)
    - [4.3 Secret 管理](#43-secret-管理)
  - [5. 日志与监控](#5-日志与监控)
    - [5.1 日志收集](#51-日志收集)
    - [5.2 指标暴露](#52-指标暴露)
    - [5.3 健康检查](#53-健康检查)
  - [6. 弹性伸缩](#6-弹性伸缩)
    - [6.1 HPA 水平扩展](#61-hpa-水平扩展)
    - [6.2 VPA 垂直扩展](#62-vpa-垂直扩展)
    - [6.3 资源限制](#63-资源限制)
  - [7. 实战案例](#7-实战案例)
    - [7.1 完整部署流程](#71-完整部署流程)
    - [7.2 蓝绿部署](#72-蓝绿部署)
    - [7.3 金丝雀发布](#73-金丝雀发布)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 构建优化

### 1.1 Release 构建

```toml
# Cargo.toml
[profile.release]
# 优化级别
opt-level = 3           # 最大优化 (0-3, s, z)

# 链接时优化
lto = "fat"             # LTO: off | thin | fat
codegen-units = 1       # 单个编译单元，最大优化

# 调试符号
debug = false           # 禁用调试符号
strip = true            # 剥离符号表

# Panic 行为
panic = "abort"         # abort 而非 unwind，减小二进制大小
```

**构建命令**:

```bash
# 标准 release 构建
cargo build --release

# 针对特定 CPU 优化
RUSTFLAGS="-C target-cpu=native" cargo build --release

# 启用链接时优化
cargo build --release --config profile.release.lto=true
```

### 1.2 二进制大小优化

```toml
# Cargo.toml
[profile.release]
opt-level = "z"     # 优化二进制大小
lto = true
codegen-units = 1
panic = "abort"
strip = true
```

**额外优化**:

```bash
# 使用 upx 压缩（可选）
upx --best --lzma target/release/my_app

# 检查二进制大小
ls -lh target/release/my_app

# 分析二进制组成
cargo bloat --release
cargo bloat --release --crates
```

### 1.3 编译时间优化

```toml
# .cargo/config.toml
[build]
incremental = true      # 增量编译
pipelining = true       # 流水线编译

[profile.dev]
opt-level = 1           # 开发时轻量优化
```

**并行构建**:

```bash
# 使用 mold 链接器（Linux）
cargo install -f mold
RUSTFLAGS="-C link-arg=-fuse-ld=mold" cargo build --release

# 使用 sccache 缓存
cargo install sccache
export RUSTC_WRAPPER=sccache
cargo build --release
```

---

## 2. Docker 容器化

### 2.1 多阶段构建

```dockerfile
# Dockerfile
# 阶段1: 构建
FROM rust:1.90-slim as builder

WORKDIR /app

# 复制依赖文件
COPY Cargo.toml Cargo.lock ./

# 构建依赖（利用缓存）
RUN mkdir src && \
    echo "fn main() {}" > src/main.rs && \
    cargo build --release && \
    rm -rf src

# 复制源代码
COPY src ./src

# 构建应用
RUN cargo build --release

# 阶段2: 运行时
FROM debian:bookworm-slim

# 安装运行时依赖
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        ca-certificates && \
    rm -rf /var/lib/apt/lists/*

# 创建非 root 用户
RUN useradd -m -u 1000 appuser

WORKDIR /app

# 从构建阶段复制二进制
COPY --from=builder /app/target/release/my_app /app/my_app

# 切换到非 root 用户
USER appuser

# 暴露端口
EXPOSE 8080

# 启动应用
CMD ["/app/my_app"]
```

### 2.2 最小化镜像

**使用 distroless**:

```dockerfile
# Dockerfile.distroless
FROM rust:1.90-slim as builder
WORKDIR /app
COPY . .
RUN cargo build --release

# 使用 Google 的 distroless 镜像
FROM gcr.io/distroless/cc-debian12

COPY --from=builder /app/target/release/my_app /app/my_app

USER nonroot:nonroot

ENTRYPOINT ["/app/my_app"]
```

**使用 Alpine** (如果兼容):

```dockerfile
# Dockerfile.alpine
FROM rust:1.90-alpine as builder

# 安装 musl 工具链
RUN apk add --no-cache musl-dev

WORKDIR /app
COPY . .

# 构建静态链接二进制
RUN cargo build --release --target x86_64-unknown-linux-musl

FROM alpine:latest

RUN apk add --no-cache ca-certificates

COPY --from=builder /app/target/x86_64-unknown-linux-musl/release/my_app /app/my_app

USER 1000:1000

ENTRYPOINT ["/app/my_app"]
```

### 2.3 安全加固

```dockerfile
# Dockerfile.secure
FROM rust:1.90-slim as builder
WORKDIR /app
COPY . .
RUN cargo build --release && \
    cargo audit

FROM gcr.io/distroless/cc-debian12

# 添加健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD ["/app/my_app", "--health-check"]

# 只读根文件系统
# VOLUME ["/tmp"]

COPY --from=builder /app/target/release/my_app /app/my_app

USER 65534:65534

ENTRYPOINT ["/app/my_app"]
```

---

## 3. Kubernetes 部署

### 3.1 Deployment 配置

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app
  labels:
    app: rust-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rust-app
  template:
    metadata:
      labels:
        app: rust-app
    spec:
      containers:
      - name: rust-app
        image: myregistry/rust-app:v1.0.0
        ports:
        - containerPort: 8080
          name: http
        
        # 资源限制
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        
        # 健康检查
        livenessProbe:
          httpGet:
            path: /health/liveness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /health/readiness
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        
        # 环境变量
        env:
        - name: RUST_LOG
          value: "info"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        
        # 挂载配置
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
      
      volumes:
      - name: config
        configMap:
          name: rust-app-config
```

### 3.2 Service 与 Ingress

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: rust-app
spec:
  selector:
    app: rust-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP

---
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rust-app
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  tls:
  - hosts:
    - api.example.com
    secretName: rust-app-tls
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rust-app
            port:
              number: 80
```

### 3.3 滚动更新

```yaml
# deployment.yaml (滚动更新策略)
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # 最多额外启动 1 个 Pod
      maxUnavailable: 1  # 最多 1 个 Pod 不可用
```

**更新命令**:

```bash
# 更新镜像
kubectl set image deployment/rust-app rust-app=myregistry/rust-app:v1.1.0

# 查看更新状态
kubectl rollout status deployment/rust-app

# 回滚更新
kubectl rollout undo deployment/rust-app

# 查看历史
kubectl rollout history deployment/rust-app
```

---

## 4. 配置管理

### 4.1 环境变量

```rust
use std::env;

fn load_config_from_env() -> Config {
    Config {
        database_url: env::var("DATABASE_URL")
            .expect("DATABASE_URL must be set"),
        
        redis_url: env::var("REDIS_URL")
            .expect("REDIS_URL must be set"),
        
        log_level: env::var("RUST_LOG")
            .unwrap_or_else(|_| "info".to_string()),
        
        port: env::var("PORT")
            .unwrap_or_else(|_| "8080".to_string())
            .parse()
            .expect("PORT must be a number"),
    }
}

struct Config {
    database_url: String,
    redis_url: String,
    log_level: String,
    port: u16,
}
```

### 4.2 配置文件

```rust
use serde::Deserialize;
use config::{Config, File, Environment};

#[derive(Debug, Deserialize)]
struct AppConfig {
    server: ServerConfig,
    database: DatabaseConfig,
    redis: RedisConfig,
}

#[derive(Debug, Deserialize)]
struct ServerConfig {
    host: String,
    port: u16,
}

#[derive(Debug, Deserialize)]
struct DatabaseConfig {
    url: String,
    max_connections: u32,
}

#[derive(Debug, Deserialize)]
struct RedisConfig {
    url: String,
    pool_size: u32,
}

fn load_config() -> Result<AppConfig, config::ConfigError> {
    let config = Config::builder()
        // 默认配置
        .add_source(File::with_name("config/default"))
        
        // 环境特定配置
        .add_source(
            File::with_name(&format!("config/{}", env::var("RUN_ENV").unwrap_or_else(|_| "dev".into())))
                .required(false)
        )
        
        // 环境变量覆盖 (前缀 APP_)
        .add_source(Environment::with_prefix("APP").separator("__"))
        
        .build()?;
    
    config.try_deserialize()
}
```

**配置文件示例** (`config/default.toml`):

```toml
[server]
host = "0.0.0.0"
port = 8080

[database]
url = "postgres://localhost/mydb"
max_connections = 20

[redis]
url = "redis://localhost:6379"
pool_size = 10
```

### 4.3 Secret 管理

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  database-url: "postgres://user:pass@db:5432/mydb"
  redis-url: "redis://:password@redis:6379"
  api-key: "secret-api-key-12345"
```

**从 Secret 读取** (Rust):

```rust
use std::fs;

fn load_secret(path: &str) -> Result<String, std::io::Error> {
    fs::read_to_string(path)
        .map(|s| s.trim().to_string())
}

fn init_with_secrets() -> Result<Config, Box<dyn std::error::Error>> {
    let database_url = load_secret("/var/secrets/database-url")?;
    let redis_url = load_secret("/var/secrets/redis-url")?;
    
    Ok(Config {
        database_url,
        redis_url,
    })
}

struct Config {
    database_url: String,
    redis_url: String,
}
```

---

## 5. 日志与监控

### 5.1 日志收集

```yaml
# deployment.yaml (日志配置)
spec:
  template:
    spec:
      containers:
      - name: rust-app
        # 日志输出到 stdout/stderr
        env:
        - name: RUST_LOG
          value: "info"
        - name: LOG_FORMAT
          value: "json"  # JSON 格式方便解析
```

**Fluentd/Fluent Bit 收集**:

```yaml
# fluent-bit-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush        1
        Log_Level    info
    
    [INPUT]
        Name              tail
        Path              /var/log/containers/*rust-app*.log
        Parser            docker
        Tag               kube.*
    
    [OUTPUT]
        Name  es
        Match *
        Host  elasticsearch
        Port  9200
        Index kubernetes
```

### 5.2 指标暴露

```yaml
# deployment.yaml (Prometheus 注解)
metadata:
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9090"
    prometheus.io/path: "/metrics"
```

**ServiceMonitor** (Prometheus Operator):

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: rust-app
spec:
  selector:
    matchLabels:
      app: rust-app
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
```

### 5.3 健康检查

```rust
use axum::{Router, routing::get, http::StatusCode};

async fn liveness() -> StatusCode {
    StatusCode::OK
}

async fn readiness() -> Result<StatusCode, StatusCode> {
    if check_dependencies().await {
        Ok(StatusCode::OK)
    } else {
        Err(StatusCode::SERVICE_UNAVAILABLE)
    }
}

async fn check_dependencies() -> bool {
    // 检查数据库、缓存等依赖
    true
}

fn health_routes() -> Router {
    Router::new()
        .route("/health/liveness", get(liveness))
        .route("/health/readiness", get(readiness))
}
```

---

## 6. 弹性伸缩

### 6.1 HPA 水平扩展

```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rust-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rust-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
  # CPU 使用率
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  
  # 内存使用率
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  
  # 自定义指标（每秒请求数）
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"
  
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # 5分钟稳定期
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 30
```

### 6.2 VPA 垂直扩展

```yaml
# vpa.yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: rust-app
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: Deployment
    name: rust-app
  updatePolicy:
    updateMode: "Auto"  # Auto | Initial | Off
  resourcePolicy:
    containerPolicies:
    - containerName: rust-app
      minAllowed:
        memory: "128Mi"
        cpu: "100m"
      maxAllowed:
        memory: "2Gi"
        cpu: "2000m"
```

### 6.3 资源限制

```yaml
# deployment.yaml
spec:
  template:
    spec:
      containers:
      - name: rust-app
        resources:
          requests:
            memory: "256Mi"  # 最小保证
            cpu: "250m"
          limits:
            memory: "512Mi"  # 最大限制
            cpu: "500m"
```

**QoS 类别**:

| 类别 | 条件 | 优先级 |
|------|------|--------|
| **Guaranteed** | requests == limits | 最高 |
| **Burstable** | requests < limits | 中等 |
| **BestEffort** | 无 requests/limits | 最低 |

---

## 7. 实战案例

### 7.1 完整部署流程

```bash
#!/bin/bash
# deploy.sh

set -e

# 1. 构建镜像
docker build -t myregistry/rust-app:$VERSION .

# 2. 推送镜像
docker push myregistry/rust-app:$VERSION

# 3. 更新 K8s 配置
kubectl apply -f k8s/configmap.yaml
kubectl apply -f k8s/secret.yaml
kubectl apply -f k8s/deployment.yaml
kubectl apply -f k8s/service.yaml
kubectl apply -f k8s/ingress.yaml
kubectl apply -f k8s/hpa.yaml

# 4. 等待更新完成
kubectl rollout status deployment/rust-app --timeout=300s

# 5. 验证健康检查
kubectl run test --rm -it --image=curlimages/curl -- \
  curl -f http://rust-app/health/readiness || exit 1

echo "Deployment successful!"
```

### 7.2 蓝绿部署

```yaml
# blue-green-deployment.yaml
# Blue (当前生产版本)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rust-app
      version: blue
  template:
    metadata:
      labels:
        app: rust-app
        version: blue
    spec:
      containers:
      - name: rust-app
        image: myregistry/rust-app:v1.0.0

---
# Green (新版本)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rust-app
      version: green
  template:
    metadata:
      labels:
        app: rust-app
        version: green
    spec:
      containers:
      - name: rust-app
        image: myregistry/rust-app:v1.1.0

---
# Service (切换版本)
apiVersion: v1
kind: Service
metadata:
  name: rust-app
spec:
  selector:
    app: rust-app
    version: blue  # 切换到 green 实现蓝绿切换
  ports:
  - port: 80
    targetPort: 8080
```

### 7.3 金丝雀发布

```yaml
# canary-deployment.yaml
# Stable (稳定版本 - 90% 流量)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app-stable
spec:
  replicas: 9
  selector:
    matchLabels:
      app: rust-app
      track: stable
  template:
    metadata:
      labels:
        app: rust-app
        track: stable
    spec:
      containers:
      - name: rust-app
        image: myregistry/rust-app:v1.0.0

---
# Canary (金丝雀版本 - 10% 流量)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-app-canary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rust-app
      track: canary
  template:
    metadata:
      labels:
        app: rust-app
        track: canary
    spec:
      containers:
      - name: rust-app
        image: myregistry/rust-app:v1.1.0

---
# Service (统一流量入口)
apiVersion: v1
kind: Service
metadata:
  name: rust-app
spec:
  selector:
    app: rust-app  # 匹配 stable 和 canary
  ports:
  - port: 80
    targetPort: 8080
```

---

## 8. 总结

### 核心要点

1. **构建优化**: 使用 LTO、剥离符号、优化编译选项
2. **容器化**: 多阶段构建、最小化镜像、安全加固
3. **K8s 部署**: Deployment + Service + Ingress + HPA
4. **配置管理**: 环境变量 + ConfigMap + Secret
5. **可观测性**: 日志 + 指标 + 追踪 + 健康检查

### 最佳实践

| 阶段 | 最佳实践 | 工具 |
|------|---------|------|
| **构建** | LTO + strip + panic=abort | Cargo profile |
| **镜像** | 多阶段构建 + distroless | Docker |
| **部署** | 滚动更新 + 健康检查 | Kubernetes |
| **配置** | ConfigMap + Secret | K8s |
| **监控** | Prometheus + Grafana | metrics |
| **日志** | JSON 格式 + Fluentd | tracing |
| **扩展** | HPA + VPA | K8s autoscaling |

**常见陷阱**:

- ❌ 使用 debug 构建部署
- ❌ 镜像过大 (>500MB)
- ❌ 没有资源限制
- ❌ 缺少健康检查
- ❌ 配置硬编码
- ✅ 使用 release 构建
- ✅ 多阶段构建优化镜像
- ✅ 设置合理的 requests/limits
- ✅ 实现 liveness/readiness 探针
- ✅ 使用 ConfigMap/Secret

---

## 📚 参考资源

**工具**:

- [Docker](https://docs.docker.com/) - 容器化
- [Kubernetes](https://kubernetes.io/docs/) - 容器编排
- [Helm](https://helm.sh/) - K8s 包管理器
- [cargo-audit](https://crates.io/crates/cargo-audit) - 安全审计

**相关文档**:

- [Tier 2: 错误处理指南](./01_错误处理指南.md)
- [Tier 2: 监控可观测性指南](./04_监控可观测性指南.md)
- [Tier 3: API 参考](../tier_03_references/)

---

**文档维护**: C13 Reliability Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
