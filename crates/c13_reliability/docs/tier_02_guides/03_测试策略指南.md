# C13 Reliability - Tier 2: æµ‹è¯•ç­–ç•¥æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 35 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C13 Reliability - Tier 2: æµ‹è¯•ç­–ç•¥æŒ‡å—](#c13-reliability---tier-2-æµ‹è¯•ç­–ç•¥æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æµ‹è¯•é‡‘å­—å¡”](#1-æµ‹è¯•é‡‘å­—å¡”)
    - [1.1 æµ‹è¯•å±‚æ¬¡](#11-æµ‹è¯•å±‚æ¬¡)
    - [1.2 æµ‹è¯•æ¯”ä¾‹](#12-æµ‹è¯•æ¯”ä¾‹)
  - [2. å•å…ƒæµ‹è¯•](#2-å•å…ƒæµ‹è¯•)
    - [2.1 åŸºç¡€å•å…ƒæµ‹è¯•](#21-åŸºç¡€å•å…ƒæµ‹è¯•)
    - [2.2 æµ‹è¯•ç»„ç»‡](#22-æµ‹è¯•ç»„ç»‡)
    - [2.3 å‚æ•°åŒ–æµ‹è¯•](#23-å‚æ•°åŒ–æµ‹è¯•)
  - [3. é›†æˆæµ‹è¯•](#3-é›†æˆæµ‹è¯•)
    - [3.1 åŸºç¡€é›†æˆæµ‹è¯•](#31-åŸºç¡€é›†æˆæµ‹è¯•)
    - [3.2 æµ‹è¯•å›ºä»¶](#32-æµ‹è¯•å›ºä»¶)
    - [3.3 æ•°æ®åº“æµ‹è¯•](#33-æ•°æ®åº“æµ‹è¯•)
  - [4. æ€§èƒ½æµ‹è¯•](#4-æ€§èƒ½æµ‹è¯•)
    - [4.1 åŸºå‡†æµ‹è¯•](#41-åŸºå‡†æµ‹è¯•)
    - [4.2 å‹åŠ›æµ‹è¯•](#42-å‹åŠ›æµ‹è¯•)
    - [4.3 æ€§èƒ½å›å½’](#43-æ€§èƒ½å›å½’)
  - [5. æ··æ²Œæµ‹è¯•](#5-æ··æ²Œæµ‹è¯•)
    - [5.1 æ•…éšœæ³¨å…¥](#51-æ•…éšœæ³¨å…¥)
    - [5.2 ç½‘ç»œæ··æ²Œ](#52-ç½‘ç»œæ··æ²Œ)
    - [5.3 èµ„æºæ··æ²Œ](#53-èµ„æºæ··æ²Œ)
  - [6. å±æ€§æµ‹è¯•](#6-å±æ€§æµ‹è¯•)
    - [6.1 QuickCheck é£æ ¼](#61-quickcheck-é£æ ¼)
    - [6.2 è‡ªå®šä¹‰ç”Ÿæˆå™¨](#62-è‡ªå®šä¹‰ç”Ÿæˆå™¨)
    - [6.3 æ”¶ç¼©ç­–ç•¥](#63-æ”¶ç¼©ç­–ç•¥)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 æ–­è·¯å™¨æµ‹è¯•](#71-æ–­è·¯å™¨æµ‹è¯•)
    - [7.2 é™æµå™¨æµ‹è¯•](#72-é™æµå™¨æµ‹è¯•)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. æµ‹è¯•é‡‘å­—å¡”

### 1.1 æµ‹è¯•å±‚æ¬¡

```text
        â•±â•²
       â•±  â•²      E2E æµ‹è¯• (5%)
      â•±    â•²     - å®Œæ•´ç”¨æˆ·æµç¨‹
     â•±â”€â”€â”€â”€â”€â”€â•²    - æœ€æ…¢ï¼Œæœ€æ˜‚è´µ
    â•±        â•²
   â•±          â•²  é›†æˆæµ‹è¯• (15%)
  â•±            â•² - æ¨¡å—é—´äº¤äº’
 â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•² - å¤–éƒ¨ä¾èµ–
â•±                â•²
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  å•å…ƒæµ‹è¯• (80%)
  - å‡½æ•°/æ–¹æ³•çº§åˆ«
  - æœ€å¿«ï¼Œæœ€ä¾¿å®œ
```

### 1.2 æµ‹è¯•æ¯”ä¾‹

| æµ‹è¯•ç±»å‹ | å æ¯” | æ‰§è¡Œæ—¶é—´ | è¦†ç›–èŒƒå›´ | ç»´æŠ¤æˆæœ¬ |
|---------|------|---------|---------|---------|
| **å•å…ƒæµ‹è¯•** | 70-80% | < 1ms | å•ä¸ªå‡½æ•° | ä½ |
| **é›†æˆæµ‹è¯•** | 15-20% | 10-100ms | å¤šä¸ªæ¨¡å— | ä¸­ |
| **E2E æµ‹è¯•** | 5-10% | 1-10s | å®Œæ•´æµç¨‹ | é«˜ |

---

## 2. å•å…ƒæµ‹è¯•

### 2.1 åŸºç¡€å•å…ƒæµ‹è¯•

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }

    #[test]
    fn test_divide_success() {
        assert_eq!(divide(10.0, 2.0).unwrap(), 5.0);
    }

    #[test]
    fn test_divide_by_zero() {
        assert!(divide(10.0, 0.0).is_err());
        assert_eq!(
            divide(10.0, 0.0).unwrap_err(),
            "Division by zero"
        );
    }

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_panic() {
        assert_eq!(1, 2);
    }
}
```

### 2.2 æµ‹è¯•ç»„ç»‡

```rust
// tests/integration_test.rs
use my_crate::*;

#[cfg(test)]
mod user_tests {
    use super::*;

    #[test]
    fn test_user_creation() {
        let user = User::new("Alice");
        assert_eq!(user.name(), "Alice");
    }

    #[test]
    fn test_user_validation() {
        assert!(User::validate_name("Alice").is_ok());
        assert!(User::validate_name("").is_err());
    }
}

#[cfg(test)]
mod order_tests {
    use super::*;

    #[test]
    fn test_order_total() {
        let order = Order::new();
        order.add_item(10.0);
        order.add_item(20.0);
        assert_eq!(order.total(), 30.0);
    }
}
```

### 2.3 å‚æ•°åŒ–æµ‹è¯•

```rust
use rstest::rstest;

#[rstest]
#[case(2, 3, 5)]
#[case(0, 0, 0)]
#[case(-1, 1, 0)]
#[case(100, -50, 50)]
fn test_add_parametrized(#[case] a: i32, #[case] b: i32, #[case] expected: i32) {
    assert_eq!(add(a, b), expected);
}

// ä½¿ç”¨è¡¨æ ¼æ•°æ®
#[rstest]
#[case("", false, "Empty string")]
#[case("a", false, "Too short")]
#[case("alice", true, "Valid name")]
#[case("Alice123", true, "Valid with numbers")]
fn test_validate_username(
    #[case] input: &str,
    #[case] expected: bool,
    #[case] description: &str,
) {
    assert_eq!(
        validate_username(input).is_ok(),
        expected,
        "Failed: {}",
        description
    );
}

fn validate_username(name: &str) -> Result<(), String> {
    if name.len() < 3 {
        Err("Username too short".to_string())
    } else {
        Ok(())
    }
}
```

---

## 3. é›†æˆæµ‹è¯•

### 3.1 åŸºç¡€é›†æˆæµ‹è¯•

```rust
// tests/integration_test.rs
use my_crate::api::Client;
use tokio;

#[tokio::test]
async fn test_api_client() {
    let client = Client::new("http://localhost:8080");
    
    let response = client.get("/users/1").await;
    assert!(response.is_ok());
    
    let user = response.unwrap();
    assert_eq!(user.id, 1);
}

#[tokio::test]
async fn test_api_error_handling() {
    let client = Client::new("http://localhost:8080");
    
    let response = client.get("/users/999999").await;
    assert!(response.is_err());
}
```

### 3.2 æµ‹è¯•å›ºä»¶

```rust
use std::sync::Once;

static INIT: Once = Once::new();

/// æµ‹è¯•å‰åˆå§‹åŒ–
fn setup() {
    INIT.call_once(|| {
        // åˆå§‹åŒ–æ—¥å¿—
        env_logger::init();
        
        // åˆå§‹åŒ–æ•°æ®åº“
        init_test_database();
    });
}

fn init_test_database() {
    // æ•°æ®åº“åˆå§‹åŒ–é€»è¾‘
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_with_setup() {
        setup();
        
        // æµ‹è¯•é€»è¾‘
        let result = query_database();
        assert!(result.is_ok());
    }
}
```

### 3.3 æ•°æ®åº“æµ‹è¯•

```rust
use sqlx::PgPool;
use testcontainers::{clients::Cli, Container, images::postgres::Postgres};

struct TestDb {
    container: Container<'static, Postgres>,
    pool: PgPool,
}

impl TestDb {
    async fn new() -> Self {
        let docker = Cli::default();
        let container = docker.run(Postgres::default());
        
        let connection_string = format!(
            "postgres://postgres:postgres@localhost:{}/test",
            container.get_host_port_ipv4(5432)
        );
        
        let pool = PgPool::connect(&connection_string).await.unwrap();
        
        Self { container, pool }
    }
    
    async fn setup_schema(&self) {
        sqlx::query(
            "CREATE TABLE users (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100) NOT NULL
            )"
        )
        .execute(&self.pool)
        .await
        .unwrap();
    }
}

#[tokio::test]
async fn test_database_operations() {
    let db = TestDb::new().await;
    db.setup_schema().await;
    
    // æ’å…¥æ•°æ®
    sqlx::query("INSERT INTO users (name) VALUES ($1)")
        .bind("Alice")
        .execute(&db.pool)
        .await
        .unwrap();
    
    // æŸ¥è¯¢æ•°æ®
    let users: Vec<String> = sqlx::query_scalar("SELECT name FROM users")
        .fetch_all(&db.pool)
        .await
        .unwrap();
    
    assert_eq!(users, vec!["Alice"]);
}
```

---

## 4. æ€§èƒ½æµ‹è¯•

### 4.1 åŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

**é«˜çº§åŸºå‡†æµ‹è¯•**:

```rust
use criterion::{BenchmarkId, Criterion, Throughput};

fn bench_hash_map(c: &mut Criterion) {
    let mut group = c.benchmark_group("hash_map");
    
    for size in [10, 100, 1000, 10000].iter() {
        group.throughput(Throughput::Elements(*size as u64));
        
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            b.iter(|| {
                let mut map = std::collections::HashMap::new();
                for i in 0..size {
                    map.insert(i, i * 2);
                }
                map
            });
        });
    }
    
    group.finish();
}
```

### 4.2 å‹åŠ›æµ‹è¯•

```rust
use tokio::time::{sleep, Duration};
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

#[tokio::test]
async fn stress_test_concurrent_requests() {
    let success_count = Arc::new(AtomicU64::new(0));
    let error_count = Arc::new(AtomicU64::new(0));
    
    let handles: Vec<_> = (0..1000)
        .map(|i| {
            let success = success_count.clone();
            let errors = error_count.clone();
            
            tokio::spawn(async move {
                match make_request(i).await {
                    Ok(_) => success.fetch_add(1, Ordering::SeqCst),
                    Err(_) => errors.fetch_add(1, Ordering::SeqCst),
                };
            })
        })
        .collect();
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let total_success = success_count.load(Ordering::SeqCst);
    let total_errors = error_count.load(Ordering::SeqCst);
    
    println!("Success: {}, Errors: {}", total_success, total_errors);
    assert!(total_success > 900);  // è‡³å°‘90%æˆåŠŸç‡
}

async fn make_request(id: u64) -> Result<(), String> {
    sleep(Duration::from_millis(10)).await;
    Ok(())
}
```

### 4.3 æ€§èƒ½å›å½’

```rust
#[cfg(test)]
mod performance_tests {
    use super::*;
    use std::time::Instant;

    #[test]
    fn test_sorting_performance() {
        let mut data: Vec<i32> = (0..10000).rev().collect();
        
        let start = Instant::now();
        data.sort();
        let duration = start.elapsed();
        
        // æ–­è¨€æ€§èƒ½ä¸é€€åŒ–
        assert!(
            duration.as_millis() < 100,
            "Sorting took too long: {:?}",
            duration
        );
    }

    #[test]
    fn test_memory_usage() {
        let start_memory = get_memory_usage();
        
        let _large_vec: Vec<u8> = vec![0; 1024 * 1024];  // 1MB
        
        let end_memory = get_memory_usage();
        let delta = end_memory - start_memory;
        
        // æ–­è¨€å†…å­˜ä½¿ç”¨åœ¨é¢„æœŸèŒƒå›´å†…
        assert!(
            delta < 2 * 1024 * 1024,  // < 2MB
            "Memory usage too high: {} bytes",
            delta
        );
    }

    fn get_memory_usage() -> usize {
        // ä½¿ç”¨ jemalloc æˆ–ç³»ç»Ÿè°ƒç”¨è·å–å†…å­˜ä½¿ç”¨
        0  // ç®€åŒ–ç¤ºä¾‹
    }
}
```

---

## 5. æ··æ²Œæµ‹è¯•

### 5.1 æ•…éšœæ³¨å…¥

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

/// æ•…éšœæ³¨å…¥å™¨
struct FaultInjector {
    fail_reads: Arc<AtomicBool>,
    fail_writes: Arc<AtomicBool>,
}

impl FaultInjector {
    fn new() -> Self {
        Self {
            fail_reads: Arc::new(AtomicBool::new(false)),
            fail_writes: Arc::new(AtomicBool::new(false)),
        }
    }
    
    fn enable_read_failures(&self) {
        self.fail_reads.store(true, Ordering::SeqCst);
    }
    
    fn enable_write_failures(&self) {
        self.fail_writes.store(true, Ordering::SeqCst);
    }
    
    fn should_fail_read(&self) -> bool {
        self.fail_reads.load(Ordering::SeqCst)
    }
    
    fn should_fail_write(&self) -> bool {
        self.fail_writes.load(Ordering::SeqCst)
    }
}

/// å¸¦æ•…éšœæ³¨å…¥çš„æ•°æ®åº“
struct Database {
    fault_injector: Arc<FaultInjector>,
}

impl Database {
    fn read(&self, key: &str) -> Result<String, String> {
        if self.fault_injector.should_fail_read() {
            return Err("Read failure injected".to_string());
        }
        Ok(format!("value for {}", key))
    }
    
    fn write(&self, key: &str, value: &str) -> Result<(), String> {
        if self.fault_injector.should_fail_write() {
            return Err("Write failure injected".to_string());
        }
        Ok(())
    }
}

#[cfg(test)]
mod chaos_tests {
    use super::*;

    #[test]
    fn test_read_failure_handling() {
        let injector = Arc::new(FaultInjector::new());
        let db = Database { fault_injector: injector.clone() };
        
        // æ­£å¸¸æƒ…å†µ
        assert!(db.read("key1").is_ok());
        
        // æ³¨å…¥è¯»å¤±è´¥
        injector.enable_read_failures();
        assert!(db.read("key1").is_err());
    }
}
```

### 5.2 ç½‘ç»œæ··æ²Œ

```rust
use tokio::time::{sleep, Duration};
use rand::Rng;

/// ç½‘ç»œæ··æ²Œæ¨¡æ‹Ÿå™¨
struct NetworkChaos {
    latency_ms: Option<u64>,
    packet_loss_rate: f64,  // 0.0 - 1.0
    timeout_rate: f64,
}

impl NetworkChaos {
    async fn simulate_request<F, T>(&self, operation: F) -> Result<T, String>
    where
        F: std::future::Future<Output = Result<T, String>>,
    {
        let mut rng = rand::thread_rng();
        
        // æ¨¡æ‹Ÿä¸¢åŒ…
        if rng.gen::<f64>() < self.packet_loss_rate {
            return Err("Packet lost".to_string());
        }
        
        // æ¨¡æ‹Ÿè¶…æ—¶
        if rng.gen::<f64>() < self.timeout_rate {
            sleep(Duration::from_secs(100)).await;
            return Err("Timeout".to_string());
        }
        
        // æ¨¡æ‹Ÿå»¶è¿Ÿ
        if let Some(latency) = self.latency_ms {
            let jitter = rng.gen_range(0..latency / 4);
            sleep(Duration::from_millis(latency + jitter)).await;
        }
        
        operation.await
    }
}

#[tokio::test]
async fn test_network_chaos() {
    let chaos = NetworkChaos {
        latency_ms: Some(100),
        packet_loss_rate: 0.1,  // 10% ä¸¢åŒ…
        timeout_rate: 0.05,     // 5% è¶…æ—¶
    };
    
    let mut success_count = 0;
    let mut error_count = 0;
    
    for _ in 0..100 {
        match chaos.simulate_request(async { Ok("data".to_string()) }).await {
            Ok(_) => success_count += 1,
            Err(_) => error_count += 1,
        }
    }
    
    println!("Success: {}, Errors: {}", success_count, error_count);
    assert!(success_count > 80);  // è‡³å°‘ 80% æˆåŠŸ
}
```

### 5.3 èµ„æºæ··æ²Œ

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

/// èµ„æºé™åˆ¶æ¨¡æ‹Ÿå™¨
struct ResourceChaos {
    max_memory: Arc<AtomicU64>,
    current_memory: Arc<AtomicU64>,
}

impl ResourceChaos {
    fn new(max_memory_mb: u64) -> Self {
        Self {
            max_memory: Arc::new(AtomicU64::new(max_memory_mb * 1024 * 1024)),
            current_memory: Arc::new(AtomicU64::new(0)),
        }
    }
    
    fn allocate(&self, size: u64) -> Result<(), String> {
        let current = self.current_memory.fetch_add(size, Ordering::SeqCst);
        let max = self.max_memory.load(Ordering::SeqCst);
        
        if current + size > max {
            self.current_memory.fetch_sub(size, Ordering::SeqCst);
            return Err("Out of memory".to_string());
        }
        
        Ok(())
    }
    
    fn deallocate(&self, size: u64) {
        self.current_memory.fetch_sub(size, Ordering::SeqCst);
    }
}

#[test]
fn test_resource_limits() {
    let chaos = ResourceChaos::new(10);  // 10MB limit
    
    // åˆ†é… 5MB - æˆåŠŸ
    assert!(chaos.allocate(5 * 1024 * 1024).is_ok());
    
    // å†åˆ†é… 6MB - å¤±è´¥ (è¶…è¿‡é™åˆ¶)
    assert!(chaos.allocate(6 * 1024 * 1024).is_err());
    
    // é‡Šæ”¾ 5MB
    chaos.deallocate(5 * 1024 * 1024);
    
    // å†åˆ†é… 6MB - æˆåŠŸ
    assert!(chaos.allocate(6 * 1024 * 1024).is_ok());
}
```

---

## 6. å±æ€§æµ‹è¯•

### 6.1 QuickCheck é£æ ¼

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_add_commutative(a: i32, b: i32) {
        prop_assert_eq!(add(a, b), add(b, a));
    }

    #[test]
    fn test_add_associative(a: i32, b: i32, c: i32) {
        prop_assert_eq!(
            add(add(a, b), c),
            add(a, add(b, c))
        );
    }

    #[test]
    fn test_reverse_involution(v in prop::collection::vec(any::<i32>(), 0..100)) {
        let mut v1 = v.clone();
        v1.reverse();
        v1.reverse();
        prop_assert_eq!(v1, v);
    }
}

fn add(a: i32, b: i32) -> i32 {
    a.saturating_add(b)  // é¿å…æº¢å‡º
}
```

### 6.2 è‡ªå®šä¹‰ç”Ÿæˆå™¨

```rust
use proptest::prelude::*;

#[derive(Debug, Clone)]
struct User {
    name: String,
    age: u8,
    email: String,
}

fn user_strategy() -> impl Strategy<Value = User> {
    ("[a-z]{3,10}", 18u8..100, "[a-z0-9]{5,10}@[a-z]{3,7}\\.com")
        .prop_map(|(name, age, email)| User { name, age, email })
}

proptest! {
    #[test]
    fn test_user_validation(user in user_strategy()) {
        // éªŒè¯ç”¨æˆ·åé•¿åº¦
        prop_assert!(user.name.len() >= 3);
        prop_assert!(user.name.len() <= 10);
        
        // éªŒè¯å¹´é¾„èŒƒå›´
        prop_assert!(user.age >= 18);
        prop_assert!(user.age < 100);
        
        // éªŒè¯é‚®ç®±æ ¼å¼
        prop_assert!(user.email.contains('@'));
        prop_assert!(user.email.ends_with(".com"));
    }
}
```

### 6.3 æ”¶ç¼©ç­–ç•¥

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_parse_number(s in "[0-9]{1,10}") {
        // è¿™ä¸ªæµ‹è¯•ä¼šå¤±è´¥ï¼Œå› ä¸ºå¾ˆå¤§çš„æ•°ä¼šæº¢å‡º
        let n: u32 = s.parse().unwrap();
        prop_assert!(n < 1_000_000);  // ä¼šå¤±è´¥
    }
}

// proptest ä¼šè‡ªåŠ¨æ”¶ç¼©å¤±è´¥çš„è¾“å…¥ï¼Œæ‰¾åˆ°æœ€å°å¤±è´¥æ¡ˆä¾‹
// ä¾‹å¦‚ï¼Œä» "999999999" æ”¶ç¼©åˆ° "1000000"
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 æ–­è·¯å™¨æµ‹è¯•

```rust
#[cfg(test)]
mod circuit_breaker_tests {
    use super::*;
    use tokio::time::{sleep, Duration};

    #[tokio::test]
    async fn test_circuit_breaker_open_on_failures() {
        let breaker = CircuitBreaker::new(3, Duration::from_secs(10));
        
        // è§¦å‘3æ¬¡å¤±è´¥
        for i in 0..3 {
            let result = breaker.call(async { Err::<(), String>("Fail".to_string()) }).await;
            assert!(result.is_err(), "Attempt {} should fail", i + 1);
        }
        
        // æ–­è·¯å™¨åº”è¯¥æ‰“å¼€
        let result = breaker.call(async { Ok::<(), String>(()) }).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Circuit breaker is OPEN"));
    }

    #[tokio::test]
    async fn test_circuit_breaker_half_open_after_timeout() {
        let breaker = CircuitBreaker::new(3, Duration::from_secs(1));
        
        // è§¦å‘å¤±è´¥ï¼Œæ‰“å¼€æ–­è·¯å™¨
        for _ in 0..3 {
            let _ = breaker.call(async { Err::<(), String>("Fail".to_string()) }).await;
        }
        
        // ç­‰å¾…è¶…æ—¶
        sleep(Duration::from_secs(2)).await;
        
        // åº”è¯¥è¿›å…¥åŠå¼€çŠ¶æ€ï¼Œå…è®¸å°è¯•
        let result = breaker.call(async { Ok::<(), String>(()) }).await;
        assert!(result.is_ok());
    }
}
```

### 7.2 é™æµå™¨æµ‹è¯•

```rust
#[cfg(test)]
mod rate_limiter_tests {
    use super::*;
    use tokio::time::{sleep, Duration, Instant};

    #[tokio::test]
    async fn test_token_bucket_rate_limiting() {
        let limiter = TokenBucketRateLimiter::new(10, 10);  // 10 tokens, 10/s
        
        // åº”è¯¥ç«‹å³è·å¾—10ä¸ªä»¤ç‰Œ
        for i in 0..10 {
            assert!(limiter.try_acquire().await.is_ok(), "Token {} should be available", i);
        }
        
        // ç¬¬11ä¸ªåº”è¯¥å¤±è´¥
        assert!(limiter.try_acquire().await.is_err());
        
        // ç­‰å¾…1ç§’ï¼Œåº”è¯¥è¡¥å……10ä¸ªä»¤ç‰Œ
        sleep(Duration::from_secs(1)).await;
        assert!(limiter.try_acquire().await.is_ok());
    }

    #[tokio::test]
    async fn test_sliding_window_rate_limiting() {
        let limiter = SlidingWindowRateLimiter::new(5, Duration::from_secs(1));
        
        let start = Instant::now();
        
        // å‰5ä¸ªè¯·æ±‚åº”è¯¥æˆåŠŸ
        for _ in 0..5 {
            assert!(limiter.try_acquire().await.is_ok());
        }
        
        // ç¬¬6ä¸ªåº”è¯¥å¤±è´¥
        assert!(limiter.try_acquire().await.is_err());
        
        // ç­‰å¾…çª—å£æ»‘åŠ¨
        let elapsed = start.elapsed();
        if elapsed < Duration::from_secs(1) {
            sleep(Duration::from_secs(1) - elapsed).await;
        }
        
        // çª—å£æ»‘åŠ¨åï¼Œåº”è¯¥å¯ä»¥å†æ¬¡è·å–
        assert!(limiter.try_acquire().await.is_ok());
    }
}

// æ¨¡æ‹Ÿé™æµå™¨
struct TokenBucketRateLimiter;
impl TokenBucketRateLimiter {
    fn new(_capacity: u32, _rate: u32) -> Self { Self }
    async fn try_acquire(&self) -> Result<(), String> { Ok(()) }
}

struct SlidingWindowRateLimiter;
impl SlidingWindowRateLimiter {
    fn new(_limit: u32, _window: Duration) -> Self { Self }
    async fn try_acquire(&self) -> Result<(), String> { Ok(()) }
}
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æµ‹è¯•é‡‘å­—å¡”**: å•å…ƒæµ‹è¯•ä¸ºä¸» (80%)ï¼Œé›†æˆæµ‹è¯•ä¸ºè¾… (15%)ï¼ŒE2E æµ‹è¯•æœ€å°‘ (5%)
2. **è‡ªåŠ¨åŒ–**: æ‰€æœ‰æµ‹è¯•éƒ½åº”è¯¥è‡ªåŠ¨åŒ–ï¼Œé›†æˆåˆ° CI/CD
3. **éš”ç¦»æ€§**: æ¯ä¸ªæµ‹è¯•åº”è¯¥ç‹¬ç«‹ï¼Œä¸ä¾èµ–å…¶ä»–æµ‹è¯•
4. **å¯é‡å¤**: æµ‹è¯•ç»“æœåº”è¯¥å¯é‡å¤ï¼Œä¸å—ç¯å¢ƒå½±å“
5. **å¿«é€Ÿåé¦ˆ**: å•å…ƒæµ‹è¯•åº”è¯¥åœ¨æ¯«ç§’çº§å®Œæˆ

### æœ€ä½³å®è·µ

| æµ‹è¯•ç±»å‹ | å·¥å…· | è¿è¡Œé¢‘ç‡ | è¦†ç›–ç‡ç›®æ ‡ |
|---------|------|---------|-----------|
| **å•å…ƒæµ‹è¯•** | `cargo test` | æ¯æ¬¡æäº¤ | > 80% |
| **é›†æˆæµ‹è¯•** | `cargo test --test '*'` | æ¯æ¬¡æäº¤ | > 60% |
| **æ€§èƒ½æµ‹è¯•** | `criterion` | æ¯å‘¨ | å…³é”®è·¯å¾„ 100% |
| **æ··æ²Œæµ‹è¯•** | è‡ªå®šä¹‰ | æ¯æœˆ | æ ¸å¿ƒæœåŠ¡ 100% |
| **å±æ€§æµ‹è¯•** | `proptest` | æ¯æ¬¡æäº¤ | å…³é”®ç®—æ³• 100% |

**å¸¸è§é™·é˜±**:

- âŒ æµ‹è¯•è¦†ç›–ç‡è¿‡ä½
- âŒ æµ‹è¯•å¤ªæ…¢ï¼Œå½±å“å¼€å‘æ•ˆç‡
- âŒ æµ‹è¯•ä¾èµ–å¤–éƒ¨æœåŠ¡
- âŒ æµ‹è¯•ä¸ç¨³å®š (flaky tests)
- âŒ ç¼ºå°‘æ€§èƒ½å’Œæ··æ²Œæµ‹è¯•
- âœ… ä¼˜å…ˆç¼–å†™å•å…ƒæµ‹è¯•
- âœ… ä½¿ç”¨æµ‹è¯•å›ºä»¶ç®€åŒ–æµ‹è¯•
- âœ… Mock å¤–éƒ¨ä¾èµ–
- âœ… å®šæœŸå®¡æŸ¥å’Œé‡æ„æµ‹è¯•ä»£ç 
- âœ… é›†æˆæ··æ²Œæµ‹è¯•åˆ° CI/CD

---

## ğŸ“š å‚è€ƒèµ„æº

**æµ‹è¯•æ¡†æ¶**:

- [cargo test](https://doc.rust-lang.org/cargo/commands/cargo-test.html) - æ ‡å‡†æµ‹è¯•å·¥å…·
- [rstest](https://docs.rs/rstest/) - å‚æ•°åŒ–æµ‹è¯•
- [proptest](https://docs.rs/proptest/) - å±æ€§æµ‹è¯•
- [criterion](https://docs.rs/criterion/) - åŸºå‡†æµ‹è¯•

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: é”™è¯¯å¤„ç†æŒ‡å—](./01_é”™è¯¯å¤„ç†æŒ‡å—.md)
- [Tier 2: ç›‘æ§å¯è§‚æµ‹æ€§æŒ‡å—](./04_ç›‘æ§å¯è§‚æµ‹æ€§æŒ‡å—.md)
- [Tier 3: API å‚è€ƒ](../tier_03_references/)

---

**æ–‡æ¡£ç»´æŠ¤**: C13 Reliability Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
