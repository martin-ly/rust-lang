# C13 Reliability - Tier 2: 错误处理指南

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 40 分钟

---


## 📊 目录

- [📋 目录](#目录)
- [1. 错误处理基础](#1-错误处理基础)
  - [1.1 Rust 错误模型](#11-rust-错误模型)
  - [1.2 错误类型设计](#12-错误类型设计)
- [2. Result 与 Option 最佳实践](#2-result-与-option-最佳实践)
  - [2.1 Result 模式](#21-result-模式)
  - [2.2 Option 模式](#22-option-模式)
  - [2.3 组合子链式调用](#23-组合子链式调用)
- [3. 自定义错误类型](#3-自定义错误类型)
  - [3.1 使用 thiserror](#31-使用-thiserror)
  - [3.2 使用 anyhow](#32-使用-anyhow)
  - [3.3 错误上下文](#33-错误上下文)
- [4. 错误传播与转换](#4-错误传播与转换)
  - [4.1 `?` 操作符](#41-操作符)
  - [4.2 From trait 自动转换](#42-from-trait-自动转换)
  - [4.3 错误装箱](#43-错误装箱)
- [5. 异步错误处理](#5-异步错误处理)
  - [5.1 async fn 错误](#51-async-fn-错误)
  - [5.2 超时处理](#52-超时处理)
  - [5.3 tokio::select! 错误](#53-tokioselect-错误)
- [6. 错误恢复策略](#6-错误恢复策略)
  - [6.1 重试机制](#61-重试机制)
  - [6.2 断路器模式](#62-断路器模式)
  - [6.3 降级处理](#63-降级处理)
- [7. 实战案例](#7-实战案例)
  - [7.1 HTTP 客户端错误处理](#71-http-客户端错误处理)
  - [7.2 数据库操作错误](#72-数据库操作错误)
- [8. 总结](#8-总结)
  - [核心要点](#核心要点)
  - [最佳实践](#最佳实践)
- [📚 参考资源](#参考资源)


## 📋 目录

- [C13 Reliability - Tier 2: 错误处理指南](#c13-reliability---tier-2-错误处理指南)
  - [📋 目录](#-目录)
  - [1. 错误处理基础](#1-错误处理基础)
    - [1.1 Rust 错误模型](#11-rust-错误模型)
    - [1.2 错误类型设计](#12-错误类型设计)
  - [2. Result 与 Option 最佳实践](#2-result-与-option-最佳实践)
    - [2.1 Result 模式](#21-result-模式)
    - [2.2 Option 模式](#22-option-模式)
    - [2.3 组合子链式调用](#23-组合子链式调用)
  - [3. 自定义错误类型](#3-自定义错误类型)
    - [3.1 使用 thiserror](#31-使用-thiserror)
    - [3.2 使用 anyhow](#32-使用-anyhow)
    - [3.3 错误上下文](#33-错误上下文)
  - [4. 错误传播与转换](#4-错误传播与转换)
    - [4.1 `?` 操作符](#41--操作符)
    - [4.2 From trait 自动转换](#42-from-trait-自动转换)
    - [4.3 错误装箱](#43-错误装箱)
  - [5. 异步错误处理](#5-异步错误处理)
    - [5.1 async fn 错误](#51-async-fn-错误)
    - [5.2 超时处理](#52-超时处理)
    - [5.3 tokio::select! 错误](#53-tokioselect-错误)
  - [6. 错误恢复策略](#6-错误恢复策略)
    - [6.1 重试机制](#61-重试机制)
    - [6.2 断路器模式](#62-断路器模式)
    - [6.3 降级处理](#63-降级处理)
  - [7. 实战案例](#7-实战案例)
    - [7.1 HTTP 客户端错误处理](#71-http-客户端错误处理)
    - [7.2 数据库操作错误](#72-数据库操作错误)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 错误处理基础

### 1.1 Rust 错误模型

Rust 使用 `Result<T, E>` 类型来处理可恢复错误：

```rust
// Result 定义
enum Result<T, E> {
    Ok(T),   // 成功情况
    Err(E),  // 错误情况
}

// 基本使用
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
```

**panic! vs Result**:

| 特性 | panic! | Result |
|------|--------|--------|
| **用途** | 不可恢复错误 | 可恢复错误 |
| **控制流** | 终止程序/线程 | 返回错误值 |
| **使用场景** | 断言失败、逻辑错误 | I/O 错误、网络错误 |
| **性能** | 展开栈 (慢) | 正常返回 (快) |

### 1.2 错误类型设计

```rust
// 简单枚举错误
#[derive(Debug)]
enum MyError {
    IoError,
    ParseError,
    NotFound,
}

// 带详细信息的错误
#[derive(Debug)]
enum DetailedError {
    Io(std::io::Error),
    Parse(String),
    NotFound { resource: String, id: u64 },
}

// 错误特质实现
impl std::fmt::Display for DetailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            DetailedError::Io(e) => write!(f, "I/O error: {}", e),
            DetailedError::Parse(msg) => write!(f, "Parse error: {}", msg),
            DetailedError::NotFound { resource, id } => {
                write!(f, "Resource '{}' with ID {} not found", resource, id)
            }
        }
    }
}

impl std::error::Error for DetailedError {}
```

---

## 2. Result 与 Option 最佳实践

### 2.1 Result 模式

```rust
use std::fs::File;
use std::io::Read;

// 基础 Result 处理
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(path)?;  // ? 自动传播错误
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// 多错误类型处理
fn process_data(path: &str) -> Result<u32, Box<dyn std::error::Error>> {
    let contents = read_file(path)?;
    let number: u32 = contents.trim().parse()?;  // 可能 ParseIntError
    Ok(number * 2)
}
```

### 2.2 Option 模式

```rust
// Option 基础
fn find_user(id: u64) -> Option<User> {
    DATABASE.get(&id).cloned()
}

// 链式调用
fn get_user_email(id: u64) -> Option<String> {
    find_user(id).and_then(|user| user.email)
}

// or_else 提供默认值
fn get_name_or_default(id: u64) -> String {
    find_user(id)
        .map(|user| user.name)
        .unwrap_or_else(|| "Anonymous".to_string())
}
```

### 2.3 组合子链式调用

```rust
use std::fs::File;
use std::io::Read;

fn process_file(path: &str) -> Result<u32, Box<dyn std::error::Error>> {
    File::open(path)?                    // Result<File, Error>
        .bytes()                          // Iterator<Result<u8, Error>>
        .collect::<Result<Vec<u8>, _>>()?  // Result<Vec<u8>, Error>
        .iter()
        .filter(|&&b| b.is_ascii_digit()) // Filter digits
        .map(|&b| (b - b'0') as u32)      // Convert to numbers
        .sum::<u32>()                     // Sum
        .pipe(|sum| Ok(sum))              // Wrap in Result
}

// 使用 map 和 and_then
fn double_first(vec: Vec<i32>) -> Option<i32> {
    vec.first()             // Option<&i32>
        .map(|&x| x * 2)    // Option<i32>
}

fn double_first_and_add(vec: Vec<i32>, n: i32) -> Option<i32> {
    vec.first()                      // Option<&i32>
        .map(|&x| x * 2)             // Option<i32>
        .and_then(|x| Some(x + n))   // Option<i32>
}
```

---

## 3. 自定义错误类型

### 3.1 使用 thiserror

`thiserror` 简化错误类型定义：

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    Parse(#[from] std::num::ParseIntError),

    #[error("Resource '{resource}' not found (ID: {id})")]
    NotFound { resource: String, id: u64 },

    #[error("Permission denied: {action}")]
    PermissionDenied { action: String },

    #[error("Invalid input: {0}")]
    InvalidInput(String),
}

// 使用示例
fn read_and_parse(path: &str) -> Result<u32, AppError> {
    let contents = std::fs::read_to_string(path)?;  // 自动转换 io::Error
    let number = contents.trim().parse::<u32>()?;   // 自动转换 ParseIntError
    
    if number == 0 {
        return Err(AppError::InvalidInput("Number cannot be zero".to_string()));
    }
    
    Ok(number)
}
```

### 3.2 使用 anyhow

`anyhow` 提供简化的错误处理：

```rust
use anyhow::{Context, Result, anyhow, bail};

fn process_file(path: &str) -> Result<String> {
    let contents = std::fs::read_to_string(path)
        .context("Failed to read config file")?;  // 添加上下文
    
    if contents.is_empty() {
        bail!("Config file is empty");  // 快速返回错误
    }
    
    Ok(contents)
}

fn load_config() -> Result<Config> {
    let path = std::env::var("CONFIG_PATH")
        .context("CONFIG_PATH environment variable not set")?;
    
    let contents = process_file(&path)
        .context("Failed to load configuration")?;
    
    serde_json::from_str(&contents)
        .context("Failed to parse JSON config")
}
```

### 3.3 错误上下文

```rust
use anyhow::{Context, Result};

fn download_file(url: &str) -> Result<Vec<u8>> {
    let response = reqwest::blocking::get(url)
        .with_context(|| format!("Failed to download from {}", url))?;
    
    let status = response.status();
    if !status.is_success() {
        anyhow::bail!("HTTP error {}: {}", status.as_u16(), status.canonical_reason().unwrap_or("Unknown"));
    }
    
    response.bytes()
        .map(|b| b.to_vec())
        .context("Failed to read response body")
}
```

---

## 4. 错误传播与转换

### 4.1 `?` 操作符

```rust
use std::io;

// 手动传播 (繁琐)
fn read_file_manual(path: &str) -> Result<String, io::Error> {
    let file = match File::open(path) {
        Ok(f) => f,
        Err(e) => return Err(e),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

// 使用 ? 操作符 (简洁)
fn read_file_elegant(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

### 4.2 From trait 自动转换

```rust
use std::fmt;
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
}

// 实现 From trait 实现自动转换
impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<ParseIntError> for AppError {
    fn from(error: ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "I/O error: {}", e),
            AppError::Parse(e) => write!(f, "Parse error: {}", e),
        }
    }
}

impl std::error::Error for AppError {}

// 现在可以直接使用 ? 操作符
fn read_and_parse(path: &str) -> Result<u32, AppError> {
    let contents = std::fs::read_to_string(path)?;  // io::Error -> AppError
    let number = contents.trim().parse::<u32>()?;   // ParseIntError -> AppError
    Ok(number)
}
```

### 4.3 错误装箱

```rust
use std::error::Error;

// 使用 Box<dyn Error> 支持多种错误类型
fn flexible_operation() -> Result<String, Box<dyn Error>> {
    let file = std::fs::read_to_string("config.txt")?;  // io::Error
    let number: u32 = file.trim().parse()?;              // ParseIntError
    let url = format!("https://api.example.com/item/{}", number);
    let response = reqwest::blocking::get(&url)?.text()?; // reqwest::Error
    Ok(response)
}

// 使用类型别名简化
type BoxError = Box<dyn Error + Send + Sync>;

fn async_operation() -> Result<String, BoxError> {
    // ...
    Ok("result".to_string())
}
```

---

## 5. 异步错误处理

### 5.1 async fn 错误

```rust
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};

// 异步函数错误处理
async fn read_file_async(path: &str) -> io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}

// 使用 tokio::try_join! 并行处理多个异步操作
use tokio::try_join;

async fn fetch_all_data() -> Result<(String, String, String), Box<dyn std::error::Error>> {
    let (user, posts, comments) = try_join!(
        fetch_user(),
        fetch_posts(),
        fetch_comments()
    )?;  // 任何一个失败都会立即返回错误
    
    Ok((user, posts, comments))
}

async fn fetch_user() -> Result<String, reqwest::Error> {
    reqwest::get("https://api.example.com/user").await?.text().await
}

async fn fetch_posts() -> Result<String, reqwest::Error> {
    reqwest::get("https://api.example.com/posts").await?.text().await
}

async fn fetch_comments() -> Result<String, reqwest::Error> {
    reqwest::get("https://api.example.com/comments").await?.text().await
}
```

### 5.2 超时处理

```rust
use tokio::time::{timeout, Duration};
use std::error::Error;

async fn fetch_with_timeout(url: &str) -> Result<String, Box<dyn Error>> {
    let result = timeout(
        Duration::from_secs(5),
        reqwest::get(url)
    ).await;
    
    match result {
        Ok(Ok(response)) => Ok(response.text().await?),
        Ok(Err(e)) => Err(Box::new(e)),
        Err(_) => Err("Request timed out".into()),
    }
}
```

### 5.3 tokio::select! 错误

```rust
use tokio::select;
use tokio::time::{sleep, Duration};

async fn operation_with_cancellation() -> Result<String, Box<dyn Error>> {
    let mut cancel_rx = get_cancellation_receiver();
    
    select! {
        result = async_operation() => {
            result  // 正常完成
        }
        _ = cancel_rx.recv() => {
            Err("Operation cancelled".into())
        }
        _ = sleep(Duration::from_secs(30)) => {
            Err("Operation timed out".into())
        }
    }
}

async fn async_operation() -> Result<String, Box<dyn Error>> {
    Ok("completed".to_string())
}

fn get_cancellation_receiver() -> tokio::sync::mpsc::Receiver<()> {
    let (_, rx) = tokio::sync::mpsc::channel(1);
    rx
}
```

---

## 6. 错误恢复策略

### 6.1 重试机制

```rust
use tokio::time::{sleep, Duration};
use std::error::Error;

/// 指数退避重试
async fn retry_with_exponential_backoff<F, T, E>(
    mut operation: F,
    max_retries: u32,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
    E: std::fmt::Debug,
{
    let mut retries = 0;
    let base_delay = Duration::from_millis(100);
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if retries < max_retries => {
                retries += 1;
                let delay = base_delay * 2_u32.pow(retries - 1);
                println!("Retry {}/{} after {:?}", retries, max_retries, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 使用示例
async fn fetch_data() -> Result<String, Box<dyn Error>> {
    retry_with_exponential_backoff(
        || Box::pin(async {
            reqwest::get("https://api.example.com/data")
                .await?
                .text()
                .await
                .map_err(|e| Box::new(e) as Box<dyn Error>)
        }),
        3  // 最多重试3次
    ).await
}
```

### 6.2 断路器模式

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
use tokio::time::{Instant, Duration};

#[derive(Debug)]
enum CircuitState {
    Closed,   // 正常
    Open,     // 断开（拒绝请求）
    HalfOpen, // 半开（尝试恢复）
}

struct CircuitBreaker {
    state: Arc<std::sync::Mutex<CircuitState>>,
    failure_count: AtomicU32,
    last_failure_time: Arc<std::sync::Mutex<Option<Instant>>>,
    failure_threshold: u32,
    timeout: Duration,
}

impl CircuitBreaker {
    fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(std::sync::Mutex::new(CircuitState::Closed)),
            failure_count: AtomicU32::new(0),
            last_failure_time: Arc::new(std::sync::Mutex::new(None)),
            failure_threshold,
            timeout,
        }
    }
    
    async fn call<F, T, E>(&self, operation: F) -> Result<T, String>
    where
        F: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Debug,
    {
        // 检查断路器状态
        {
            let state = self.state.lock().unwrap();
            if matches!(*state, CircuitState::Open) {
                let last_failure = self.last_failure_time.lock().unwrap();
                if let Some(time) = *last_failure {
                    if time.elapsed() < self.timeout {
                        return Err("Circuit breaker is OPEN".to_string());
                    }
                }
                // 超时后转为半开状态
                drop(state);
                *self.state.lock().unwrap() = CircuitState::HalfOpen;
            }
        }
        
        // 执行操作
        match operation.await {
            Ok(result) => {
                // 成功，重置计数器
                self.failure_count.store(0, Ordering::SeqCst);
                *self.state.lock().unwrap() = CircuitState::Closed;
                Ok(result)
            }
            Err(e) => {
                // 失败，增加计数器
                let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;
                *self.last_failure_time.lock().unwrap() = Some(Instant::now());
                
                if failures >= self.failure_threshold {
                    *self.state.lock().unwrap() = CircuitState::Open;
                }
                
                Err(format!("Operation failed: {:?}", e))
            }
        }
    }
}

// 使用示例
async fn protected_call() -> Result<String, String> {
    let breaker = Arc::new(CircuitBreaker::new(3, Duration::from_secs(10)));
    
    breaker.call(async {
        reqwest::get("https://api.example.com/data")
            .await
            .and_then(|r| r.error_for_status())
            .map_err(|e| e.to_string())?
            .text()
            .await
            .map_err(|e| e.to_string())
    }).await
}
```

### 6.3 降级处理

```rust
use std::error::Error;

/// 降级策略
async fn get_user_profile(user_id: u64) -> Result<UserProfile, Box<dyn Error>> {
    // 尝试从主数据库获取
    match fetch_from_primary_db(user_id).await {
        Ok(profile) => Ok(profile),
        Err(e) => {
            eprintln!("Primary DB failed: {}", e);
            
            // 降级：尝试从缓存获取
            match fetch_from_cache(user_id).await {
                Ok(profile) => {
                    println!("Fallback to cache");
                    Ok(profile)
                }
                Err(e) => {
                    eprintln!("Cache failed: {}", e);
                    
                    // 最终降级：返回默认值
                    println!("Fallback to default profile");
                    Ok(UserProfile::default_for(user_id))
                }
            }
        }
    }
}

async fn fetch_from_primary_db(user_id: u64) -> Result<UserProfile, Box<dyn Error>> {
    // 模拟数据库调用
    Err("DB connection failed".into())
}

async fn fetch_from_cache(user_id: u64) -> Result<UserProfile, Box<dyn Error>> {
    // 模拟缓存调用
    Ok(UserProfile { id: user_id, name: "Cached User".to_string() })
}

#[derive(Debug)]
struct UserProfile {
    id: u64,
    name: String,
}

impl UserProfile {
    fn default_for(id: u64) -> Self {
        Self {
            id,
            name: format!("User {}", id),
        }
    }
}
```

---

## 7. 实战案例

### 7.1 HTTP 客户端错误处理

```rust
use reqwest::{Client, StatusCode};
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ApiError {
    #[error("HTTP request failed: {0}")]
    Request(#[from] reqwest::Error),
    
    #[error("HTTP {status}: {message}")]
    HttpStatus { status: StatusCode, message: String },
    
    #[error("JSON deserialization failed: {0}")]
    Json(#[from] serde_json::Error),
    
    #[error("API returned error: {0}")]
    Api(String),
}

#[derive(Deserialize)]
struct ApiResponse {
    data: Option<String>,
    error: Option<String>,
}

async fn fetch_api_data(url: &str) -> Result<String, ApiError> {
    let client = Client::new();
    
    let response = client.get(url)
        .timeout(std::time::Duration::from_secs(10))
        .send()
        .await?;
    
    let status = response.status();
    
    if !status.is_success() {
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err(ApiError::HttpStatus {
            status,
            message: error_text,
        });
    }
    
    let api_response: ApiResponse = response.json().await?;
    
    match (api_response.data, api_response.error) {
        (Some(data), None) => Ok(data),
        (None, Some(error)) => Err(ApiError::Api(error)),
        _ => Err(ApiError::Api("Invalid API response".to_string())),
    }
}
```

### 7.2 数据库操作错误

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DbError {
    #[error("Connection failed: {0}")]
    Connection(String),
    
    #[error("Query failed: {0}")]
    Query(String),
    
    #[error("Transaction failed: {0}")]
    Transaction(String),
    
    #[error("Record not found: {table}#{id}")]
    NotFound { table: String, id: i64 },
    
    #[error("Unique constraint violated: {field}")]
    UniqueViolation { field: String },
}

struct Database;

impl Database {
    async fn get_user(&self, id: i64) -> Result<User, DbError> {
        // 模拟数据库查询
        if id == 0 {
            return Err(DbError::NotFound {
                table: "users".to_string(),
                id,
            });
        }
        
        Ok(User {
            id,
            name: format!("User {}", id),
            email: format!("user{}@example.com", id),
        })
    }
    
    async fn create_user(&self, email: &str) -> Result<User, DbError> {
        // 模拟唯一性检查
        if email == "duplicate@example.com" {
            return Err(DbError::UniqueViolation {
                field: "email".to_string(),
            });
        }
        
        Ok(User {
            id: 123,
            name: "New User".to_string(),
            email: email.to_string(),
        })
    }
    
    async fn transaction<F, T>(&self, f: F) -> Result<T, DbError>
    where
        F: FnOnce() -> Result<T, DbError>,
    {
        // 开始事务
        match f() {
            Ok(result) => {
                // 提交事务
                Ok(result)
            }
            Err(e) => {
                // 回滚事务
                Err(DbError::Transaction(format!("Rolled back: {}", e)))
            }
        }
    }
}

#[derive(Debug)]
struct User {
    id: i64,
    name: String,
    email: String,
}
```

---

## 8. 总结

### 核心要点

1. **优先使用 Result**: 对于可恢复错误，始终使用 `Result<T, E>`
2. **自定义错误类型**: 使用 `thiserror` 或 `anyhow` 简化错误定义
3. **错误上下文**: 使用 `context()` 为错误添加有意义的上下文信息
4. **? 操作符**: 简化错误传播，保持代码简洁
5. **错误恢复**: 实现重试、断路器、降级等弹性策略

### 最佳实践

| 场景 | 推荐做法 |
|------|---------|
| **应用层** | 使用 `anyhow::Result` 简化错误处理 |
| **库层** | 定义具体的错误类型（使用 `thiserror`） |
| **不可恢复错误** | 使用 `panic!` 或 `expect()` |
| **异步错误** | 使用 `tokio::try_join!` 和 `select!` |
| **错误日志** | 记录错误上下文和调用栈 |
| **错误恢复** | 实现重试、断路器、降级策略 |

**常见陷阱**:

- ❌ 滥用 `unwrap()` 和 `expect()`
- ❌ 丢弃错误信息
- ❌ 过度使用 `Box<dyn Error>`
- ❌ 忘记处理 `Option::None` 情况
- ✅ 使用 `?` 操作符传播错误
- ✅ 为错误添加上下文信息
- ✅ 定义清晰的错误类型

---

## 📚 参考资源

**标准库文档**:

- [std::result](https://doc.rust-lang.org/std/result/)
- [std::error::Error](https://doc.rust-lang.org/std/error/trait.Error.html)

**第三方库**:

- [thiserror](https://docs.rs/thiserror/) - 定义错误类型
- [anyhow](https://docs.rs/anyhow/) - 应用层错误处理
- [eyre](https://docs.rs/eyre/) - anyhow 的增强版

**相关文档**:

- [Tier 1: 项目概览](../tier_01_foundations/)
- [Tier 2: 重试与降级指南](./02_重试与降级指南.md)
- [Tier 3: API 参考](../tier_03_references/)

---

**文档维护**: C13 Reliability Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
