# C13 Reliability - Tier 2: é”™è¯¯å¤„ç†æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 40 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C13 Reliability - Tier 2: é”™è¯¯å¤„ç†æŒ‡å—](#c13-reliability---tier-2-é”™è¯¯å¤„ç†æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. é”™è¯¯å¤„ç†åŸºç¡€](#1-é”™è¯¯å¤„ç†åŸºç¡€)
    - [1.1 Rust é”™è¯¯æ¨¡å‹](#11-rust-é”™è¯¯æ¨¡å‹)
    - [1.2 é”™è¯¯ç±»å‹è®¾è®¡](#12-é”™è¯¯ç±»å‹è®¾è®¡)
  - [2. Result ä¸ Option æœ€ä½³å®è·µ](#2-result-ä¸-option-æœ€ä½³å®è·µ)
    - [2.1 Result æ¨¡å¼](#21-result-æ¨¡å¼)
    - [2.2 Option æ¨¡å¼](#22-option-æ¨¡å¼)
    - [2.3 ç»„åˆå­é“¾å¼è°ƒç”¨](#23-ç»„åˆå­é“¾å¼è°ƒç”¨)
  - [3. è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#3-è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [3.1 ä½¿ç”¨ thiserror](#31-ä½¿ç”¨-thiserror)
    - [3.2 ä½¿ç”¨ anyhow](#32-ä½¿ç”¨-anyhow)
    - [3.3 é”™è¯¯ä¸Šä¸‹æ–‡](#33-é”™è¯¯ä¸Šä¸‹æ–‡)
  - [4. é”™è¯¯ä¼ æ’­ä¸è½¬æ¢](#4-é”™è¯¯ä¼ æ’­ä¸è½¬æ¢)
    - [4.1 `?` æ“ä½œç¬¦](#41--æ“ä½œç¬¦)
    - [4.2 From trait è‡ªåŠ¨è½¬æ¢](#42-from-trait-è‡ªåŠ¨è½¬æ¢)
    - [4.3 é”™è¯¯è£…ç®±](#43-é”™è¯¯è£…ç®±)
  - [5. å¼‚æ­¥é”™è¯¯å¤„ç†](#5-å¼‚æ­¥é”™è¯¯å¤„ç†)
    - [5.1 async fn é”™è¯¯](#51-async-fn-é”™è¯¯)
    - [5.2 è¶…æ—¶å¤„ç†](#52-è¶…æ—¶å¤„ç†)
    - [5.3 tokio::select! é”™è¯¯](#53-tokioselect-é”™è¯¯)
  - [6. é”™è¯¯æ¢å¤ç­–ç•¥](#6-é”™è¯¯æ¢å¤ç­–ç•¥)
    - [6.1 é‡è¯•æœºåˆ¶](#61-é‡è¯•æœºåˆ¶)
    - [6.2 æ–­è·¯å™¨æ¨¡å¼](#62-æ–­è·¯å™¨æ¨¡å¼)
    - [6.3 é™çº§å¤„ç†](#63-é™çº§å¤„ç†)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 HTTP å®¢æˆ·ç«¯é”™è¯¯å¤„ç†](#71-http-å®¢æˆ·ç«¯é”™è¯¯å¤„ç†)
    - [7.2 æ•°æ®åº“æ“ä½œé”™è¯¯](#72-æ•°æ®åº“æ“ä½œé”™è¯¯)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. é”™è¯¯å¤„ç†åŸºç¡€

### 1.1 Rust é”™è¯¯æ¨¡å‹

Rust ä½¿ç”¨ `Result<T, E>` ç±»å‹æ¥å¤„ç†å¯æ¢å¤é”™è¯¯ï¼š

```rust
// Result å®šä¹‰
enum Result<T, E> {
    Ok(T),   // æˆåŠŸæƒ…å†µ
    Err(E),  // é”™è¯¯æƒ…å†µ
}

// åŸºæœ¬ä½¿ç”¨
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
```

**panic! vs Result**:

| ç‰¹æ€§ | panic! | Result |
|------|--------|--------|
| **ç”¨é€”** | ä¸å¯æ¢å¤é”™è¯¯ | å¯æ¢å¤é”™è¯¯ |
| **æ§åˆ¶æµ** | ç»ˆæ­¢ç¨‹åº/çº¿ç¨‹ | è¿”å›é”™è¯¯å€¼ |
| **ä½¿ç”¨åœºæ™¯** | æ–­è¨€å¤±è´¥ã€é€»è¾‘é”™è¯¯ | I/O é”™è¯¯ã€ç½‘ç»œé”™è¯¯ |
| **æ€§èƒ½** | å±•å¼€æ ˆ (æ…¢) | æ­£å¸¸è¿”å› (å¿«) |

### 1.2 é”™è¯¯ç±»å‹è®¾è®¡

```rust
// ç®€å•æšä¸¾é”™è¯¯
#[derive(Debug)]
enum MyError {
    IoError,
    ParseError,
    NotFound,
}

// å¸¦è¯¦ç»†ä¿¡æ¯çš„é”™è¯¯
#[derive(Debug)]
enum DetailedError {
    Io(std::io::Error),
    Parse(String),
    NotFound { resource: String, id: u64 },
}

// é”™è¯¯ç‰¹è´¨å®ç°
impl std::fmt::Display for DetailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            DetailedError::Io(e) => write!(f, "I/O error: {}", e),
            DetailedError::Parse(msg) => write!(f, "Parse error: {}", msg),
            DetailedError::NotFound { resource, id } => {
                write!(f, "Resource '{}' with ID {} not found", resource, id)
            }
        }
    }
}

impl std::error::Error for DetailedError {}
```

---

## 2. Result ä¸ Option æœ€ä½³å®è·µ

### 2.1 Result æ¨¡å¼

```rust
use std::fs::File;
use std::io::Read;

// åŸºç¡€ Result å¤„ç†
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(path)?;  // ? è‡ªåŠ¨ä¼ æ’­é”™è¯¯
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// å¤šé”™è¯¯ç±»å‹å¤„ç†
fn process_data(path: &str) -> Result<u32, Box<dyn std::error::Error>> {
    let contents = read_file(path)?;
    let number: u32 = contents.trim().parse()?;  // å¯èƒ½ ParseIntError
    Ok(number * 2)
}
```

### 2.2 Option æ¨¡å¼

```rust
// Option åŸºç¡€
fn find_user(id: u64) -> Option<User> {
    DATABASE.get(&id).cloned()
}

// é“¾å¼è°ƒç”¨
fn get_user_email(id: u64) -> Option<String> {
    find_user(id).and_then(|user| user.email)
}

// or_else æä¾›é»˜è®¤å€¼
fn get_name_or_default(id: u64) -> String {
    find_user(id)
        .map(|user| user.name)
        .unwrap_or_else(|| "Anonymous".to_string())
}
```

### 2.3 ç»„åˆå­é“¾å¼è°ƒç”¨

```rust
use std::fs::File;
use std::io::Read;

fn process_file(path: &str) -> Result<u32, Box<dyn std::error::Error>> {
    File::open(path)?                    // Result<File, Error>
        .bytes()                          // Iterator<Result<u8, Error>>
        .collect::<Result<Vec<u8>, _>>()?  // Result<Vec<u8>, Error>
        .iter()
        .filter(|&&b| b.is_ascii_digit()) // Filter digits
        .map(|&b| (b - b'0') as u32)      // Convert to numbers
        .sum::<u32>()                     // Sum
        .pipe(|sum| Ok(sum))              // Wrap in Result
}

// ä½¿ç”¨ map å’Œ and_then
fn double_first(vec: Vec<i32>) -> Option<i32> {
    vec.first()             // Option<&i32>
        .map(|&x| x * 2)    // Option<i32>
}

fn double_first_and_add(vec: Vec<i32>, n: i32) -> Option<i32> {
    vec.first()                      // Option<&i32>
        .map(|&x| x * 2)             // Option<i32>
        .and_then(|x| Some(x + n))   // Option<i32>
}
```

---

## 3. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### 3.1 ä½¿ç”¨ thiserror

`thiserror` ç®€åŒ–é”™è¯¯ç±»å‹å®šä¹‰ï¼š

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    Parse(#[from] std::num::ParseIntError),

    #[error("Resource '{resource}' not found (ID: {id})")]
    NotFound { resource: String, id: u64 },

    #[error("Permission denied: {action}")]
    PermissionDenied { action: String },

    #[error("Invalid input: {0}")]
    InvalidInput(String),
}

// ä½¿ç”¨ç¤ºä¾‹
fn read_and_parse(path: &str) -> Result<u32, AppError> {
    let contents = std::fs::read_to_string(path)?;  // è‡ªåŠ¨è½¬æ¢ io::Error
    let number = contents.trim().parse::<u32>()?;   // è‡ªåŠ¨è½¬æ¢ ParseIntError
    
    if number == 0 {
        return Err(AppError::InvalidInput("Number cannot be zero".to_string()));
    }
    
    Ok(number)
}
```

### 3.2 ä½¿ç”¨ anyhow

`anyhow` æä¾›ç®€åŒ–çš„é”™è¯¯å¤„ç†ï¼š

```rust
use anyhow::{Context, Result, anyhow, bail};

fn process_file(path: &str) -> Result<String> {
    let contents = std::fs::read_to_string(path)
        .context("Failed to read config file")?;  // æ·»åŠ ä¸Šä¸‹æ–‡
    
    if contents.is_empty() {
        bail!("Config file is empty");  // å¿«é€Ÿè¿”å›é”™è¯¯
    }
    
    Ok(contents)
}

fn load_config() -> Result<Config> {
    let path = std::env::var("CONFIG_PATH")
        .context("CONFIG_PATH environment variable not set")?;
    
    let contents = process_file(&path)
        .context("Failed to load configuration")?;
    
    serde_json::from_str(&contents)
        .context("Failed to parse JSON config")
}
```

### 3.3 é”™è¯¯ä¸Šä¸‹æ–‡

```rust
use anyhow::{Context, Result};

fn download_file(url: &str) -> Result<Vec<u8>> {
    let response = reqwest::blocking::get(url)
        .with_context(|| format!("Failed to download from {}", url))?;
    
    let status = response.status();
    if !status.is_success() {
        anyhow::bail!("HTTP error {}: {}", status.as_u16(), status.canonical_reason().unwrap_or("Unknown"));
    }
    
    response.bytes()
        .map(|b| b.to_vec())
        .context("Failed to read response body")
}
```

---

## 4. é”™è¯¯ä¼ æ’­ä¸è½¬æ¢

### 4.1 `?` æ“ä½œç¬¦

```rust
use std::io;

// æ‰‹åŠ¨ä¼ æ’­ (ç¹ç)
fn read_file_manual(path: &str) -> Result<String, io::Error> {
    let file = match File::open(path) {
        Ok(f) => f,
        Err(e) => return Err(e),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

// ä½¿ç”¨ ? æ“ä½œç¬¦ (ç®€æ´)
fn read_file_elegant(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

### 4.2 From trait è‡ªåŠ¨è½¬æ¢

```rust
use std::fmt;
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
}

// å®ç° From trait å®ç°è‡ªåŠ¨è½¬æ¢
impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<ParseIntError> for AppError {
    fn from(error: ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "I/O error: {}", e),
            AppError::Parse(e) => write!(f, "Parse error: {}", e),
        }
    }
}

impl std::error::Error for AppError {}

// ç°åœ¨å¯ä»¥ç›´æ¥ä½¿ç”¨ ? æ“ä½œç¬¦
fn read_and_parse(path: &str) -> Result<u32, AppError> {
    let contents = std::fs::read_to_string(path)?;  // io::Error -> AppError
    let number = contents.trim().parse::<u32>()?;   // ParseIntError -> AppError
    Ok(number)
}
```

### 4.3 é”™è¯¯è£…ç®±

```rust
use std::error::Error;

// ä½¿ç”¨ Box<dyn Error> æ”¯æŒå¤šç§é”™è¯¯ç±»å‹
fn flexible_operation() -> Result<String, Box<dyn Error>> {
    let file = std::fs::read_to_string("config.txt")?;  // io::Error
    let number: u32 = file.trim().parse()?;              // ParseIntError
    let url = format!("https://api.example.com/item/{}", number);
    let response = reqwest::blocking::get(&url)?.text()?; // reqwest::Error
    Ok(response)
}

// ä½¿ç”¨ç±»å‹åˆ«åç®€åŒ–
type BoxError = Box<dyn Error + Send + Sync>;

fn async_operation() -> Result<String, BoxError> {
    // ...
    Ok("result".to_string())
}
```

---

## 5. å¼‚æ­¥é”™è¯¯å¤„ç†

### 5.1 async fn é”™è¯¯

```rust
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};

// å¼‚æ­¥å‡½æ•°é”™è¯¯å¤„ç†
async fn read_file_async(path: &str) -> io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}

// ä½¿ç”¨ tokio::try_join! å¹¶è¡Œå¤„ç†å¤šä¸ªå¼‚æ­¥æ“ä½œ
use tokio::try_join;

async fn fetch_all_data() -> Result<(String, String, String), Box<dyn std::error::Error>> {
    let (user, posts, comments) = try_join!(
        fetch_user(),
        fetch_posts(),
        fetch_comments()
    )?;  // ä»»ä½•ä¸€ä¸ªå¤±è´¥éƒ½ä¼šç«‹å³è¿”å›é”™è¯¯
    
    Ok((user, posts, comments))
}

async fn fetch_user() -> Result<String, reqwest::Error> {
    reqwest::get("https://api.example.com/user").await?.text().await
}

async fn fetch_posts() -> Result<String, reqwest::Error> {
    reqwest::get("https://api.example.com/posts").await?.text().await
}

async fn fetch_comments() -> Result<String, reqwest::Error> {
    reqwest::get("https://api.example.com/comments").await?.text().await
}
```

### 5.2 è¶…æ—¶å¤„ç†

```rust
use tokio::time::{timeout, Duration};
use std::error::Error;

async fn fetch_with_timeout(url: &str) -> Result<String, Box<dyn Error>> {
    let result = timeout(
        Duration::from_secs(5),
        reqwest::get(url)
    ).await;
    
    match result {
        Ok(Ok(response)) => Ok(response.text().await?),
        Ok(Err(e)) => Err(Box::new(e)),
        Err(_) => Err("Request timed out".into()),
    }
}
```

### 5.3 tokio::select! é”™è¯¯

```rust
use tokio::select;
use tokio::time::{sleep, Duration};

async fn operation_with_cancellation() -> Result<String, Box<dyn Error>> {
    let mut cancel_rx = get_cancellation_receiver();
    
    select! {
        result = async_operation() => {
            result  // æ­£å¸¸å®Œæˆ
        }
        _ = cancel_rx.recv() => {
            Err("Operation cancelled".into())
        }
        _ = sleep(Duration::from_secs(30)) => {
            Err("Operation timed out".into())
        }
    }
}

async fn async_operation() -> Result<String, Box<dyn Error>> {
    Ok("completed".to_string())
}

fn get_cancellation_receiver() -> tokio::sync::mpsc::Receiver<()> {
    let (_, rx) = tokio::sync::mpsc::channel(1);
    rx
}
```

---

## 6. é”™è¯¯æ¢å¤ç­–ç•¥

### 6.1 é‡è¯•æœºåˆ¶

```rust
use tokio::time::{sleep, Duration};
use std::error::Error;

/// æŒ‡æ•°é€€é¿é‡è¯•
async fn retry_with_exponential_backoff<F, T, E>(
    mut operation: F,
    max_retries: u32,
) -> Result<T, E>
where
    F: FnMut() -> futures::future::BoxFuture<'static, Result<T, E>>,
    E: std::fmt::Debug,
{
    let mut retries = 0;
    let base_delay = Duration::from_millis(100);
    
    loop {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if retries < max_retries => {
                retries += 1;
                let delay = base_delay * 2_u32.pow(retries - 1);
                println!("Retry {}/{} after {:?}", retries, max_retries, delay);
                sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn fetch_data() -> Result<String, Box<dyn Error>> {
    retry_with_exponential_backoff(
        || Box::pin(async {
            reqwest::get("https://api.example.com/data")
                .await?
                .text()
                .await
                .map_err(|e| Box::new(e) as Box<dyn Error>)
        }),
        3  // æœ€å¤šé‡è¯•3æ¬¡
    ).await
}
```

### 6.2 æ–­è·¯å™¨æ¨¡å¼

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
use tokio::time::{Instant, Duration};

#[derive(Debug)]
enum CircuitState {
    Closed,   // æ­£å¸¸
    Open,     // æ–­å¼€ï¼ˆæ‹’ç»è¯·æ±‚ï¼‰
    HalfOpen, // åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰
}

struct CircuitBreaker {
    state: Arc<std::sync::Mutex<CircuitState>>,
    failure_count: AtomicU32,
    last_failure_time: Arc<std::sync::Mutex<Option<Instant>>>,
    failure_threshold: u32,
    timeout: Duration,
}

impl CircuitBreaker {
    fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(std::sync::Mutex::new(CircuitState::Closed)),
            failure_count: AtomicU32::new(0),
            last_failure_time: Arc::new(std::sync::Mutex::new(None)),
            failure_threshold,
            timeout,
        }
    }
    
    async fn call<F, T, E>(&self, operation: F) -> Result<T, String>
    where
        F: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Debug,
    {
        // æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
        {
            let state = self.state.lock().unwrap();
            if matches!(*state, CircuitState::Open) {
                let last_failure = self.last_failure_time.lock().unwrap();
                if let Some(time) = *last_failure {
                    if time.elapsed() < self.timeout {
                        return Err("Circuit breaker is OPEN".to_string());
                    }
                }
                // è¶…æ—¶åè½¬ä¸ºåŠå¼€çŠ¶æ€
                drop(state);
                *self.state.lock().unwrap() = CircuitState::HalfOpen;
            }
        }
        
        // æ‰§è¡Œæ“ä½œ
        match operation.await {
            Ok(result) => {
                // æˆåŠŸï¼Œé‡ç½®è®¡æ•°å™¨
                self.failure_count.store(0, Ordering::SeqCst);
                *self.state.lock().unwrap() = CircuitState::Closed;
                Ok(result)
            }
            Err(e) => {
                // å¤±è´¥ï¼Œå¢åŠ è®¡æ•°å™¨
                let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;
                *self.last_failure_time.lock().unwrap() = Some(Instant::now());
                
                if failures >= self.failure_threshold {
                    *self.state.lock().unwrap() = CircuitState::Open;
                }
                
                Err(format!("Operation failed: {:?}", e))
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn protected_call() -> Result<String, String> {
    let breaker = Arc::new(CircuitBreaker::new(3, Duration::from_secs(10)));
    
    breaker.call(async {
        reqwest::get("https://api.example.com/data")
            .await
            .and_then(|r| r.error_for_status())
            .map_err(|e| e.to_string())?
            .text()
            .await
            .map_err(|e| e.to_string())
    }).await
}
```

### 6.3 é™çº§å¤„ç†

```rust
use std::error::Error;

/// é™çº§ç­–ç•¥
async fn get_user_profile(user_id: u64) -> Result<UserProfile, Box<dyn Error>> {
    // å°è¯•ä»ä¸»æ•°æ®åº“è·å–
    match fetch_from_primary_db(user_id).await {
        Ok(profile) => Ok(profile),
        Err(e) => {
            eprintln!("Primary DB failed: {}", e);
            
            // é™çº§ï¼šå°è¯•ä»ç¼“å­˜è·å–
            match fetch_from_cache(user_id).await {
                Ok(profile) => {
                    println!("Fallback to cache");
                    Ok(profile)
                }
                Err(e) => {
                    eprintln!("Cache failed: {}", e);
                    
                    // æœ€ç»ˆé™çº§ï¼šè¿”å›é»˜è®¤å€¼
                    println!("Fallback to default profile");
                    Ok(UserProfile::default_for(user_id))
                }
            }
        }
    }
}

async fn fetch_from_primary_db(user_id: u64) -> Result<UserProfile, Box<dyn Error>> {
    // æ¨¡æ‹Ÿæ•°æ®åº“è°ƒç”¨
    Err("DB connection failed".into())
}

async fn fetch_from_cache(user_id: u64) -> Result<UserProfile, Box<dyn Error>> {
    // æ¨¡æ‹Ÿç¼“å­˜è°ƒç”¨
    Ok(UserProfile { id: user_id, name: "Cached User".to_string() })
}

#[derive(Debug)]
struct UserProfile {
    id: u64,
    name: String,
}

impl UserProfile {
    fn default_for(id: u64) -> Self {
        Self {
            id,
            name: format!("User {}", id),
        }
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 HTTP å®¢æˆ·ç«¯é”™è¯¯å¤„ç†

```rust
use reqwest::{Client, StatusCode};
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ApiError {
    #[error("HTTP request failed: {0}")]
    Request(#[from] reqwest::Error),
    
    #[error("HTTP {status}: {message}")]
    HttpStatus { status: StatusCode, message: String },
    
    #[error("JSON deserialization failed: {0}")]
    Json(#[from] serde_json::Error),
    
    #[error("API returned error: {0}")]
    Api(String),
}

#[derive(Deserialize)]
struct ApiResponse {
    data: Option<String>,
    error: Option<String>,
}

async fn fetch_api_data(url: &str) -> Result<String, ApiError> {
    let client = Client::new();
    
    let response = client.get(url)
        .timeout(std::time::Duration::from_secs(10))
        .send()
        .await?;
    
    let status = response.status();
    
    if !status.is_success() {
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err(ApiError::HttpStatus {
            status,
            message: error_text,
        });
    }
    
    let api_response: ApiResponse = response.json().await?;
    
    match (api_response.data, api_response.error) {
        (Some(data), None) => Ok(data),
        (None, Some(error)) => Err(ApiError::Api(error)),
        _ => Err(ApiError::Api("Invalid API response".to_string())),
    }
}
```

### 7.2 æ•°æ®åº“æ“ä½œé”™è¯¯

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DbError {
    #[error("Connection failed: {0}")]
    Connection(String),
    
    #[error("Query failed: {0}")]
    Query(String),
    
    #[error("Transaction failed: {0}")]
    Transaction(String),
    
    #[error("Record not found: {table}#{id}")]
    NotFound { table: String, id: i64 },
    
    #[error("Unique constraint violated: {field}")]
    UniqueViolation { field: String },
}

struct Database;

impl Database {
    async fn get_user(&self, id: i64) -> Result<User, DbError> {
        // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        if id == 0 {
            return Err(DbError::NotFound {
                table: "users".to_string(),
                id,
            });
        }
        
        Ok(User {
            id,
            name: format!("User {}", id),
            email: format!("user{}@example.com", id),
        })
    }
    
    async fn create_user(&self, email: &str) -> Result<User, DbError> {
        // æ¨¡æ‹Ÿå”¯ä¸€æ€§æ£€æŸ¥
        if email == "duplicate@example.com" {
            return Err(DbError::UniqueViolation {
                field: "email".to_string(),
            });
        }
        
        Ok(User {
            id: 123,
            name: "New User".to_string(),
            email: email.to_string(),
        })
    }
    
    async fn transaction<F, T>(&self, f: F) -> Result<T, DbError>
    where
        F: FnOnce() -> Result<T, DbError>,
    {
        // å¼€å§‹äº‹åŠ¡
        match f() {
            Ok(result) => {
                // æäº¤äº‹åŠ¡
                Ok(result)
            }
            Err(e) => {
                // å›æ»šäº‹åŠ¡
                Err(DbError::Transaction(format!("Rolled back: {}", e)))
            }
        }
    }
}

#[derive(Debug)]
struct User {
    id: i64,
    name: String,
    email: String,
}
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ä¼˜å…ˆä½¿ç”¨ Result**: å¯¹äºå¯æ¢å¤é”™è¯¯ï¼Œå§‹ç»ˆä½¿ç”¨ `Result<T, E>`
2. **è‡ªå®šä¹‰é”™è¯¯ç±»å‹**: ä½¿ç”¨ `thiserror` æˆ– `anyhow` ç®€åŒ–é”™è¯¯å®šä¹‰
3. **é”™è¯¯ä¸Šä¸‹æ–‡**: ä½¿ç”¨ `context()` ä¸ºé”™è¯¯æ·»åŠ æœ‰æ„ä¹‰çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
4. **? æ“ä½œç¬¦**: ç®€åŒ–é”™è¯¯ä¼ æ’­ï¼Œä¿æŒä»£ç ç®€æ´
5. **é”™è¯¯æ¢å¤**: å®ç°é‡è¯•ã€æ–­è·¯å™¨ã€é™çº§ç­‰å¼¹æ€§ç­–ç•¥

### æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èåšæ³• |
|------|---------|
| **åº”ç”¨å±‚** | ä½¿ç”¨ `anyhow::Result` ç®€åŒ–é”™è¯¯å¤„ç† |
| **åº“å±‚** | å®šä¹‰å…·ä½“çš„é”™è¯¯ç±»å‹ï¼ˆä½¿ç”¨ `thiserror`ï¼‰ |
| **ä¸å¯æ¢å¤é”™è¯¯** | ä½¿ç”¨ `panic!` æˆ– `expect()` |
| **å¼‚æ­¥é”™è¯¯** | ä½¿ç”¨ `tokio::try_join!` å’Œ `select!` |
| **é”™è¯¯æ—¥å¿—** | è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡å’Œè°ƒç”¨æ ˆ |
| **é”™è¯¯æ¢å¤** | å®ç°é‡è¯•ã€æ–­è·¯å™¨ã€é™çº§ç­–ç•¥ |

**å¸¸è§é™·é˜±**:

- âŒ æ»¥ç”¨ `unwrap()` å’Œ `expect()`
- âŒ ä¸¢å¼ƒé”™è¯¯ä¿¡æ¯
- âŒ è¿‡åº¦ä½¿ç”¨ `Box<dyn Error>`
- âŒ å¿˜è®°å¤„ç† `Option::None` æƒ…å†µ
- âœ… ä½¿ç”¨ `?` æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
- âœ… ä¸ºé”™è¯¯æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
- âœ… å®šä¹‰æ¸…æ™°çš„é”™è¯¯ç±»å‹

---

## ğŸ“š å‚è€ƒèµ„æº

**æ ‡å‡†åº“æ–‡æ¡£**:

- [std::result](https://doc.rust-lang.org/std/result/)
- [std::error::Error](https://doc.rust-lang.org/std/error/trait.Error.html)

**ç¬¬ä¸‰æ–¹åº“**:

- [thiserror](https://docs.rs/thiserror/) - å®šä¹‰é”™è¯¯ç±»å‹
- [anyhow](https://docs.rs/anyhow/) - åº”ç”¨å±‚é”™è¯¯å¤„ç†
- [eyre](https://docs.rs/eyre/) - anyhow çš„å¢å¼ºç‰ˆ

**ç›¸å…³æ–‡æ¡£**:

- [Tier 1: é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/)
- [Tier 2: é‡è¯•ä¸é™çº§æŒ‡å—](./02_é‡è¯•ä¸é™çº§æŒ‡å—.md)
- [Tier 3: API å‚è€ƒ](../tier_03_references/)

---

**æ–‡æ¡£ç»´æŠ¤**: C13 Reliability Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
