# å¸¸è§é—®é¢˜ (FAQ) - C13 Reliability

**æœ€åæ›´æ–°**: 2025-10-24

æœ¬æ–‡æ¡£æ±‡æ€»äº† Rust å¯é æ€§å·¥ç¨‹ä¸­çš„å¸¸è§é—®é¢˜å’Œè§£ç­”ã€‚

---

## ğŸ“‹ ç›®å½•

- [å¸¸è§é—®é¢˜ (FAQ) - C13 Reliability](#å¸¸è§é—®é¢˜-faq---c13-reliability)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ§ª æµ‹è¯•ç›¸å…³é—®é¢˜](#-æµ‹è¯•ç›¸å…³é—®é¢˜)
    - [Q1: ä½•æ—¶åº”è¯¥å†™å•å…ƒæµ‹è¯• vs. é›†æˆæµ‹è¯•ï¼Ÿ](#q1-ä½•æ—¶åº”è¯¥å†™å•å…ƒæµ‹è¯•-vs-é›†æˆæµ‹è¯•)
    - [Q2: å¦‚ä½•æµ‹è¯•ç§æœ‰å‡½æ•°ï¼Ÿ](#q2-å¦‚ä½•æµ‹è¯•ç§æœ‰å‡½æ•°)
    - [Q3: å¦‚ä½•ç»„ç»‡æµ‹è¯•ä»£ç ï¼Ÿ](#q3-å¦‚ä½•ç»„ç»‡æµ‹è¯•ä»£ç )
    - [Q4: å¦‚ä½•æµ‹è¯•å¼‚æ­¥ä»£ç ï¼Ÿ](#q4-å¦‚ä½•æµ‹è¯•å¼‚æ­¥ä»£ç )
    - [Q5: æµ‹è¯•è¦†ç›–ç‡å¤šå°‘æ‰ç®—å¤Ÿï¼Ÿ](#q5-æµ‹è¯•è¦†ç›–ç‡å¤šå°‘æ‰ç®—å¤Ÿ)
  - [âŒ é”™è¯¯å¤„ç†é—®é¢˜](#-é”™è¯¯å¤„ç†é—®é¢˜)
    - [Q6: Result vs. Panicï¼Œä½•æ—¶ä½¿ç”¨å“ªä¸ªï¼Ÿ](#q6-result-vs-panicä½•æ—¶ä½¿ç”¨å“ªä¸ª)
    - [Q7: å¦‚ä½•é€‰æ‹©é”™è¯¯å¤„ç†åº“ (thiserror vs. anyhow)ï¼Ÿ](#q7-å¦‚ä½•é€‰æ‹©é”™è¯¯å¤„ç†åº“-thiserror-vs-anyhow)
    - [Q8: å¦‚ä½•å¤„ç†å¤šç§é”™è¯¯ç±»å‹ï¼Ÿ](#q8-å¦‚ä½•å¤„ç†å¤šç§é”™è¯¯ç±»å‹)
    - [Q9: ä½•æ—¶åº”è¯¥ä½¿ç”¨ `unwrap()`ï¼Ÿ](#q9-ä½•æ—¶åº”è¯¥ä½¿ç”¨-unwrap)
  - [ğŸ“Š ç›‘æ§ä¸æ—¥å¿—é—®é¢˜](#-ç›‘æ§ä¸æ—¥å¿—é—®é¢˜)
    - [Q10: log vs. tracingï¼Œåº”è¯¥ç”¨å“ªä¸ªï¼Ÿ](#q10-log-vs-tracingåº”è¯¥ç”¨å“ªä¸ª)
    - [Q11: å¦‚ä½•æ§åˆ¶æ—¥å¿—çº§åˆ«ï¼Ÿ](#q11-å¦‚ä½•æ§åˆ¶æ—¥å¿—çº§åˆ«)
    - [Q12: å¦‚ä½•é¿å…æ—¥å¿—å½±å“æ€§èƒ½ï¼Ÿ](#q12-å¦‚ä½•é¿å…æ—¥å¿—å½±å“æ€§èƒ½)
    - [Q13: å¦‚ä½•åœ¨ç”Ÿäº§ç¯å¢ƒæ”¶é›†æŒ‡æ ‡ï¼Ÿ](#q13-å¦‚ä½•åœ¨ç”Ÿäº§ç¯å¢ƒæ”¶é›†æŒ‡æ ‡)
  - [ğŸ”„ æ•…éšœæ¢å¤é—®é¢˜](#-æ•…éšœæ¢å¤é—®é¢˜)
    - [Q14: é‡è¯•æœºåˆ¶çš„æœ€ä½³å®è·µæ˜¯ä»€ä¹ˆï¼Ÿ](#q14-é‡è¯•æœºåˆ¶çš„æœ€ä½³å®è·µæ˜¯ä»€ä¹ˆ)
    - [Q15: å¦‚ä½•å®ç°è¶…æ—¶æ§åˆ¶ï¼Ÿ](#q15-å¦‚ä½•å®ç°è¶…æ—¶æ§åˆ¶)
    - [Q16: å¦‚ä½•å®ç°ä¼˜é›…å…³æœºï¼Ÿ](#q16-å¦‚ä½•å®ç°ä¼˜é›…å…³æœº)
  - [ğŸ“ˆ æ€§èƒ½ç›¸å…³é—®é¢˜](#-æ€§èƒ½ç›¸å…³é—®é¢˜)
    - [Q17: å¦‚ä½•è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Ÿ](#q17-å¦‚ä½•è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [Q18: å¦‚ä½•åˆ†ææ€§èƒ½ç“¶é¢ˆï¼Ÿ](#q18-å¦‚ä½•åˆ†ææ€§èƒ½ç“¶é¢ˆ)
    - [Q19: å¦‚ä½•é¿å…æ€§èƒ½å›å½’ï¼Ÿ](#q19-å¦‚ä½•é¿å…æ€§èƒ½å›å½’)
  - [ğŸ—ï¸ æ¶æ„è®¾è®¡é—®é¢˜](#ï¸-æ¶æ„è®¾è®¡é—®é¢˜)
    - [Q20: å¦‚ä½•è®¾è®¡é«˜å¯ç”¨ç³»ç»Ÿï¼Ÿ](#q20-å¦‚ä½•è®¾è®¡é«˜å¯ç”¨ç³»ç»Ÿ)

---

## ğŸ§ª æµ‹è¯•ç›¸å…³é—®é¢˜

### Q1: ä½•æ—¶åº”è¯¥å†™å•å…ƒæµ‹è¯• vs. é›†æˆæµ‹è¯•ï¼Ÿ

**å•å…ƒæµ‹è¯•**é€‚ç”¨äºï¼š

- çº¯å‡½æ•°å’Œç®—æ³•
- ä¸šåŠ¡é€»è¾‘
- è¾¹ç•Œæ¡ä»¶æµ‹è¯•

```rust
#[test]
fn test_calculate_price() {
    assert_eq!(calculate_price(100, 0.1), 110.0);
}
```

**é›†æˆæµ‹è¯•**é€‚ç”¨äºï¼š

- å¤šæ¨¡å—åä½œ
- å¤–éƒ¨ä¾èµ–ï¼ˆæ•°æ®åº“ã€APIï¼‰
- ç«¯åˆ°ç«¯åœºæ™¯

```rust
// tests/integration_test.rs
#[tokio::test]
async fn test_user_registration() {
    let app = setup_test_app().await;
    let response = app.register_user("test@example.com").await;
    assert!(response.is_ok());
}
```

**å»ºè®®**ï¼šä¸¤è€…ç»“åˆï¼Œå•å…ƒæµ‹è¯•è¦†ç›–æ ¸å¿ƒé€»è¾‘ï¼Œé›†æˆæµ‹è¯•éªŒè¯æ•´ä½“æµç¨‹ã€‚

---

### Q2: å¦‚ä½•æµ‹è¯•ç§æœ‰å‡½æ•°ï¼Ÿ

**æ–¹æ¡ˆ 1**: é€šè¿‡å…¬å…± API é—´æ¥æµ‹è¯•ï¼ˆæ¨èï¼‰

```rust
pub fn public_api(input: i32) -> i32 {
    private_helper(input) * 2
}

fn private_helper(x: i32) -> i32 {
    x + 1
}

#[test]
fn test_via_public_api() {
    assert_eq!(public_api(5), 12); // é—´æ¥æµ‹è¯• private_helper
}
```

**æ–¹æ¡ˆ 2**: åœ¨åŒä¸€æ¨¡å—å†…æµ‹è¯•

```rust
mod my_module {
    pub fn public_fn() -> i32 { private_fn() }
    fn private_fn() -> i32 { 42 }
    
    #[cfg(test)]
    mod tests {
        use super::*;
        
        #[test]
        fn test_private() {
            assert_eq!(private_fn(), 42); // å¯è®¿é—®ç§æœ‰å‡½æ•°
        }
    }
}
```

**æ–¹æ¡ˆ 3**: ä½¿ç”¨ `#[cfg(test)] pub`

```rust
#[cfg_attr(test, visibility::make(pub))]
fn private_fn() -> i32 { 42 }
```

---

### Q3: å¦‚ä½•ç»„ç»‡æµ‹è¯•ä»£ç ï¼Ÿ

**å†…è”æµ‹è¯•**ï¼ˆå°å‹é¡¹ç›®ï¼‰ï¼š

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
}
```

**ç‹¬ç«‹æ–‡ä»¶**ï¼ˆå¤§å‹é¡¹ç›®ï¼‰ï¼š

```text
src/
â”œâ”€â”€ lib.rs
â”œâ”€â”€ module.rs
â””â”€â”€ module/
    â”œâ”€â”€ mod.rs
    â””â”€â”€ tests.rs  # æ¨¡å—æµ‹è¯•

tests/
â”œâ”€â”€ integration_test.rs
â””â”€â”€ common/
    â””â”€â”€ mod.rs    # æµ‹è¯•è¾…åŠ©å‡½æ•°
```

---

### Q4: å¦‚ä½•æµ‹è¯•å¼‚æ­¥ä»£ç ï¼Ÿ

ä½¿ç”¨å¼‚æ­¥æµ‹è¯•è¿è¡Œæ—¶ï¼š

```rust
#[tokio::test]
async fn test_async_function() {
    let result = async_fetch_data().await;
    assert!(result.is_ok());
}

#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_concurrent() {
    // å¹¶å‘æµ‹è¯•
}
```

**æ³¨æ„äº‹é¡¹**ï¼š

- ä½¿ç”¨ `#[tokio::test]` æˆ– `#[async_std::test]`
- æ³¨æ„è¶…æ—¶è®¾ç½®
- æµ‹è¯•å¹¶å‘ç«æ€æ¡ä»¶

---

### Q5: æµ‹è¯•è¦†ç›–ç‡å¤šå°‘æ‰ç®—å¤Ÿï¼Ÿ

**æ²¡æœ‰ç»å¯¹æ ‡å‡†**ï¼Œä½†å¯å‚è€ƒï¼š

| é¡¹ç›®ç±»å‹ | å»ºè®®è¦†ç›–ç‡ | è¯´æ˜ |
|---------|----------|------|
| å…³é”®ç³»ç»Ÿ | 80-90% | é‡‘èã€åŒ»ç–—ç­‰ |
| ä¸€èˆ¬åº”ç”¨ | 70-80% | ä¸šåŠ¡åº”ç”¨ |
| å·¥å…·åº“ | 85%+ | å…¬å…±åº“è¦æ±‚æ›´é«˜ |
| åŸå‹/å®éªŒ | 50-60% | å¿«é€Ÿè¿­ä»£ |

**æ›´é‡è¦çš„æ˜¯**ï¼š

- è¦†ç›–æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
- è¦†ç›–è¾¹ç•Œæ¡ä»¶
- è¦†ç›–é”™è¯¯è·¯å¾„

```bash
# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
cargo tarpaulin --out Html
cargo llvm-cov --html
```

---

## âŒ é”™è¯¯å¤„ç†é—®é¢˜

### Q6: Result vs. Panicï¼Œä½•æ—¶ä½¿ç”¨å“ªä¸ªï¼Ÿ

**ä½¿ç”¨ Result**ï¼š

- å¯æ¢å¤çš„é”™è¯¯
- é¢„æœŸä¸­çš„é”™è¯¯
- åº“ä»£ç 

```rust
fn parse_config(path: &str) -> Result<Config, ConfigError> {
    let content = std::fs::read_to_string(path)?;
    parse_toml(&content)
}
```

**ä½¿ç”¨ Panic**ï¼š

- é€»è¾‘é”™è¯¯ï¼ˆç¼–ç¨‹é”™è¯¯ï¼‰
- ä¸å¯æ¢å¤çš„é”™è¯¯
- è¿åä¸å˜é‡

```rust
fn get_item(index: usize) -> &Item {
    if index >= self.len() {
        panic!("Index out of bounds");
    }
    &self.items[index]
}
```

**åŸåˆ™**ï¼šä¼˜å…ˆä½¿ç”¨ `Result`ï¼Œåªåœ¨ç¡®å®ä¸å¯æ¢å¤æ—¶ä½¿ç”¨ `panic!`ã€‚

---

### Q7: å¦‚ä½•é€‰æ‹©é”™è¯¯å¤„ç†åº“ (thiserror vs. anyhow)ï¼Ÿ

**thiserror**ï¼šé€‚ç”¨äº**åº“**

- å®šä¹‰æ¸…æ™°çš„é”™è¯¯ç±»å‹
- æä¾›ç±»å‹å®‰å…¨
- ç”¨æˆ·å¯ä»¥ç²¾ç¡®å¤„ç†é”™è¯¯

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyLibError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Invalid config: {0}")]
    Config(String),
}
```

**anyhow**ï¼šé€‚ç”¨äº**åº”ç”¨**

- å¿«é€ŸåŸå‹å¼€å‘
- ä¸éœ€è¦ç²¾ç¡®é”™è¯¯ç±»å‹
- ä¸°å¯Œçš„é”™è¯¯ä¸Šä¸‹æ–‡

```rust
use anyhow::{Context, Result};

fn main() -> Result<()> {
    let config = load_config()
        .context("Failed to load config")?;
    Ok(())
}
```

**å»ºè®®**ï¼šåº“ç”¨ `thiserror`ï¼Œåº”ç”¨ç”¨ `anyhow`ã€‚

---

### Q8: å¦‚ä½•å¤„ç†å¤šç§é”™è¯¯ç±»å‹ï¼Ÿ

**æ–¹æ¡ˆ 1**: ä½¿ç”¨ `Box<dyn Error>`

```rust
fn process() -> Result<(), Box<dyn std::error::Error>> {
    let file = std::fs::read_to_string("config.toml")?;
    let config: Config = toml::from_str(&file)?;
    Ok(())
}
```

**æ–¹æ¡ˆ 2**: è‡ªå®šä¹‰é”™è¯¯ç±»å‹ + `From` trait

```rust
#[derive(Debug)]
enum MyError {
    Io(std::io::Error),
    Parse(toml::de::Error),
}

impl From<std::io::Error> for MyError {
    fn from(err: std::io::Error) -> Self {
        MyError::Io(err)
    }
}

impl From<toml::de::Error> for MyError {
    fn from(err: toml::de::Error) -> Self {
        MyError::Parse(err)
    }
}
```

**æ–¹æ¡ˆ 3**: ä½¿ç”¨ `thiserror` (æ¨è)

```rust
#[derive(Error, Debug)]
enum MyError {
    #[error("IO error")]
    Io(#[from] std::io::Error),
    
    #[error("Parse error")]
    Parse(#[from] toml::de::Error),
}
```

---

### Q9: ä½•æ—¶åº”è¯¥ä½¿ç”¨ `unwrap()`ï¼Ÿ

**å®‰å…¨ä½¿ç”¨åœºæ™¯**ï¼š

1. **æµ‹è¯•ä»£ç **

    ```rust
    #[test]
    fn test_something() {
        let result = do_something().unwrap();
        assert_eq!(result, expected);
    }
    ```

2. **åˆå§‹åŒ–é˜¶æ®µï¼ˆmain å‡½æ•°ï¼‰**

    ```rust
    fn main() {
        let config = load_config().unwrap();
        // ...
    }
    ```

3. **ç¡®å®šä¸ä¼šå¤±è´¥çš„æƒ…å†µ**

```rust
let num = "42".parse::<i32>().unwrap(); // ç¡¬ç¼–ç å­—ç¬¦ä¸²ï¼Œç¡®å®šæˆåŠŸ
```

**é¿å…åœ¨ç”Ÿäº§ä»£ç ä¸­ä½¿ç”¨**ï¼Œæ”¹ç”¨ï¼š

- `expect()` æä¾›é”™è¯¯æ¶ˆæ¯
- `?` ä¼ æ’­é”™è¯¯
- `match` æ˜¾å¼å¤„ç†

---

## ğŸ“Š ç›‘æ§ä¸æ—¥å¿—é—®é¢˜

### Q10: log vs. tracingï¼Œåº”è¯¥ç”¨å“ªä¸ªï¼Ÿ

**log**ï¼šç®€å•æ—¥å¿—è®°å½•

- ä¼ ç»Ÿæ—¥å¿—åº“
- é€‚åˆç®€å•åº”ç”¨
- æ€§èƒ½å¼€é”€å°

```rust
use log::{info, warn, error};

info!("Server started on port {}", port);
error!("Failed to connect: {}", err);
```

**tracing**ï¼šç»“æ„åŒ–è¿½è¸ªï¼ˆæ¨èï¼‰

- æ”¯æŒåˆ†å¸ƒå¼è¿½è¸ª
- ç»“æ„åŒ–æ—¥å¿—
- å¼‚æ­¥å‹å¥½

```rust
use tracing::{info, instrument};

#[instrument]
async fn handle_request(id: u64) {
    info!(request_id = %id, "Processing request");
    // ...
}
```

**å»ºè®®**ï¼šæ–°é¡¹ç›®ä½¿ç”¨ `tracing`ï¼Œå®ƒæ˜¯ `log` çš„è¶…é›†ã€‚

---

### Q11: å¦‚ä½•æ§åˆ¶æ—¥å¿—çº§åˆ«ï¼Ÿ

**ç¯å¢ƒå˜é‡**ï¼ˆæ¨èï¼‰ï¼š

```bash
# è®¾ç½®å…¨å±€çº§åˆ«
export RUST_LOG=info

# æŒ‰æ¨¡å—è®¾ç½®
export RUST_LOG=my_app=debug,hyper=warn

# å¤æ‚è¿‡æ»¤
export RUST_LOG="info,my_app::db=debug,tokio=error"
```

**ä»£ç é…ç½®**ï¼š

```rust
use tracing_subscriber::{EnvFilter, fmt};

tracing_subscriber::fmt()
    .with_env_filter(EnvFilter::from_default_env())
    .init();
```

---

### Q12: å¦‚ä½•é¿å…æ—¥å¿—å½±å“æ€§èƒ½ï¼Ÿ

**æŠ€å·§ 1**: ä½¿ç”¨å¼‚æ­¥æ—¥å¿—

```rust
use tracing_subscriber::fmt;

fmt()
    .with_writer(std::io::stderr)
    .with_ansi(false)
    .init();
```

**æŠ€å·§ 2**: æ¡ä»¶ç¼–è¯‘

```rust
#[cfg(debug_assertions)]
debug!("Detailed debug info: {:?}", data);
```

**æŠ€å·§ 3**: é‡‡æ ·

```rust
if rand::random::<f64>() < 0.01 { // 1% é‡‡æ ·
    info!("Sampled log");
}
```

**æŠ€å·§ 4**: é¿å…æ˜‚è´µçš„æ ¼å¼åŒ–

```rust
// âŒ ä¸å¥½ï¼šæ€»æ˜¯æ ¼å¼åŒ–
debug!("Data: {}", expensive_format(&data));

// âœ… å¥½ï¼šåªåœ¨éœ€è¦æ—¶æ ¼å¼åŒ–
debug!("Data: {:?}", data);
```

---

### Q13: å¦‚ä½•åœ¨ç”Ÿäº§ç¯å¢ƒæ”¶é›†æŒ‡æ ‡ï¼Ÿ

**ä½¿ç”¨ Prometheus**ï¼š

```rust
use prometheus::{Counter, Histogram, Registry};

lazy_static! {
    static ref REQUESTS_TOTAL: Counter = Counter::new(
        "requests_total", "Total requests"
    ).unwrap();
    
    static ref RESPONSE_TIME: Histogram = Histogram::new(
        "response_time_seconds", "Response time"
    ).unwrap();
}

// ä½¿ç”¨æŒ‡æ ‡
REQUESTS_TOTAL.inc();
let timer = RESPONSE_TIME.start_timer();
// ... å¤„ç†è¯·æ±‚ ...
timer.observe_duration();
```

**æš´éœ² metrics ç«¯ç‚¹**ï¼š

```rust
use warp::Filter;

let metrics_route = warp::path("metrics")
    .map(|| {
        let encoder = TextEncoder::new();
        let metric_families = prometheus::gather();
        let mut buffer = vec![];
        encoder.encode(&metric_families, &mut buffer).unwrap();
        String::from_utf8(buffer).unwrap()
    });
```

---

## ğŸ”„ æ•…éšœæ¢å¤é—®é¢˜

### Q14: é‡è¯•æœºåˆ¶çš„æœ€ä½³å®è·µæ˜¯ä»€ä¹ˆï¼Ÿ

**æŒ‡æ•°é€€é¿ + æŠ–åŠ¨**ï¼š

```rust
use tokio::time::{sleep, Duration};
use rand::Rng;

async fn retry_with_backoff<F, Fut, T>(mut f: F, max_attempts: u32) -> Result<T>
where
    F: FnMut() -> Fut,
    Fut: Future<Output = Result<T>>,
{
    for attempt in 1..=max_attempts {
        match f().await {
            Ok(result) => return Ok(result),
            Err(e) if attempt < max_attempts => {
                let base_delay = 2_u64.pow(attempt);
                let jitter = rand::thread_rng().gen_range(0..1000);
                sleep(Duration::from_millis(base_delay * 1000 + jitter)).await;
            }
            Err(e) => return Err(e),
        }
    }
    unreachable!()
}
```

**å…³é”®ç‚¹**ï¼š

- è®¾ç½®æœ€å¤§é‡è¯•æ¬¡æ•°
- ä½¿ç”¨æŒ‡æ•°é€€é¿
- æ·»åŠ éšæœºæŠ–åŠ¨
- åŒºåˆ†å¯é‡è¯•å’Œä¸å¯é‡è¯•é”™è¯¯

---

### Q15: å¦‚ä½•å®ç°è¶…æ—¶æ§åˆ¶ï¼Ÿ

**tokio timeout**ï¼š

```rust
use tokio::time::{timeout, Duration};

async fn fetch_with_timeout() -> Result<Data> {
    match timeout(Duration::from_secs(5), fetch_data()).await {
        Ok(Ok(data)) => Ok(data),
        Ok(Err(e)) => Err(e),
        Err(_) => Err(Error::Timeout),
    }
}
```

**å¤šä¸ªè¶…æ—¶å±‚æ¬¡**ï¼š

```rust
// å•ä¸ªè¯·æ±‚è¶…æ—¶
let request_timeout = Duration::from_secs(5);

// æ€»ä½“æ“ä½œè¶…æ—¶
let total_timeout = Duration::from_secs(30);

timeout(total_timeout, async {
    for _ in 0..3 {
        if let Ok(result) = timeout(request_timeout, request()).await {
            return result;
        }
    }
    Err(Error::AllAttemptsFailed)
}).await?
```

---

### Q16: å¦‚ä½•å®ç°ä¼˜é›…å…³æœºï¼Ÿ

**å®Œæ•´ç¤ºä¾‹**ï¼š

```rust
use tokio::signal;
use tokio::sync::broadcast;

async fn graceful_shutdown(
    server: Server,
    shutdown_tx: broadcast::Sender<()>,
) {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("Failed to listen for Ctrl+C");
    };
    
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to listen for SIGTERM")
            .recv()
            .await;
    };
    
    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    
    println!("Shutting down gracefully...");
    
    // é€šçŸ¥æ‰€æœ‰ä»»åŠ¡åœæ­¢æ¥å—æ–°è¯·æ±‚
    let _ = shutdown_tx.send(());
    
    // ç­‰å¾…æ­£åœ¨å¤„ç†çš„è¯·æ±‚å®Œæˆï¼ˆæœ€å¤š30ç§’ï¼‰
    tokio::time::timeout(
        Duration::from_secs(30),
        server.wait_for_active_requests()
    ).await.ok();
    
    println!("Shutdown complete");
}
```

---

## ğŸ“ˆ æ€§èƒ½ç›¸å…³é—®é¢˜

### Q17: å¦‚ä½•è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Ÿ

**ä½¿ç”¨ Criterion**ï¼š

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });
}

criterion_group!(benches, fibonacci_benchmark);
criterion_main!(benches);
```

**è¿è¡ŒåŸºå‡†æµ‹è¯•**ï¼š

```bash
cargo bench
```

---

### Q18: å¦‚ä½•åˆ†ææ€§èƒ½ç“¶é¢ˆï¼Ÿ

**å·¥å…·é“¾**ï¼š

1. **Flamegraph**ï¼š

    ```bash
    cargo install flamegraph
    cargo flamegraph --bin my_app
    ```

2. **perf** (Linux)ï¼š

    ```bash
    perf record -F 99 -g ./target/release/my_app
    perf report
    ```

3. **Criterion æ¯”è¾ƒ**ï¼š

    ```bash
    cargo bench -- --save-baseline before
    # ä¿®æ”¹ä»£ç ...
    cargo bench -- --baseline before
    ```

---

### Q19: å¦‚ä½•é¿å…æ€§èƒ½å›å½’ï¼Ÿ

**CI/CD é›†æˆ**ï¼š

```yaml
# .github/workflows/bench.yml
- name: Run benchmarks
  run: cargo bench -- --save-baseline main

- name: Compare with PR
  run: cargo bench -- --baseline main
```

**è®¾ç½®é˜ˆå€¼**ï¼š

```rust
c.bench_function("critical_path", |b| {
    b.iter(|| operation());
}).with_threshold(10.0); // æœ€å¤šé™ä½10%
```

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡é—®é¢˜

### Q20: å¦‚ä½•è®¾è®¡é«˜å¯ç”¨ç³»ç»Ÿï¼Ÿ

**æ ¸å¿ƒåŸåˆ™**ï¼š

1. **æ¶ˆé™¤å•ç‚¹æ•…éšœ**ï¼šå†—ä½™éƒ¨ç½²
2. **å¿«é€Ÿæ•…éšœæ£€æµ‹**ï¼šå¥åº·æ£€æŸ¥
3. **è‡ªåŠ¨æ•…éšœè½¬ç§»**ï¼šä¸»å¤‡åˆ‡æ¢
4. **æ•°æ®å†—ä½™**ï¼šå¤åˆ¶ä¸å¤‡ä»½
5. **ç›‘æ§å‘Šè­¦**ï¼šåŠæ—¶å‘ç°é—®é¢˜

**ç¤ºä¾‹æ¶æ„**ï¼š

```rust
struct HighAvailabilityService {
    primary: ServiceInstance,
    secondaries: Vec<ServiceInstance>,
    health_checker: HealthChecker,
    load_balancer: LoadBalancer,
}

impl HighAvailabilityService {
    async fn handle_request(&self, req: Request) -> Response {
        // 1. å¥åº·æ£€æŸ¥
        if !self.health_checker.is_healthy(&self.primary).await {
            // 2. æ•…éšœè½¬ç§»
            return self.failover_to_secondary(req).await;
        }
        
        // 3. è´Ÿè½½å‡è¡¡
        self.load_balancer.route(req).await
    }
}
```

---

**ä¸Šä¸€æ­¥**: [æœ¯è¯­è¡¨](./03_æœ¯è¯­è¡¨.md)  
**ä¸‹ä¸€æ­¥**: [è¿›å…¥ Tier 2 å®è·µå±‚](../tier_02_guides/)
