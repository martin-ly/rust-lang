# 常见问题 (FAQ) - C13 Reliability

**最后更新**: 2025-10-24

本文档汇总了 Rust 可靠性工程中的常见问题和解答。

---

## 📋 目录

- [常见问题 (FAQ) - C13 Reliability](#常见问题-faq---c13-reliability)
  - [📋 目录](#-目录)
  - [🧪 测试相关问题](#-测试相关问题)
    - [Q1: 何时应该写单元测试 vs. 集成测试？](#q1-何时应该写单元测试-vs-集成测试)
    - [Q2: 如何测试私有函数？](#q2-如何测试私有函数)
    - [Q3: 如何组织测试代码？](#q3-如何组织测试代码)
    - [Q4: 如何测试异步代码？](#q4-如何测试异步代码)
    - [Q5: 测试覆盖率多少才算够？](#q5-测试覆盖率多少才算够)
  - [❌ 错误处理问题](#-错误处理问题)
    - [Q6: Result vs. Panic，何时使用哪个？](#q6-result-vs-panic何时使用哪个)
    - [Q7: 如何选择错误处理库 (thiserror vs. anyhow)？](#q7-如何选择错误处理库-thiserror-vs-anyhow)
    - [Q8: 如何处理多种错误类型？](#q8-如何处理多种错误类型)
    - [Q9: 何时应该使用 `unwrap()`？](#q9-何时应该使用-unwrap)
  - [📊 监控与日志问题](#-监控与日志问题)
    - [Q10: log vs. tracing，应该用哪个？](#q10-log-vs-tracing应该用哪个)
    - [Q11: 如何控制日志级别？](#q11-如何控制日志级别)
    - [Q12: 如何避免日志影响性能？](#q12-如何避免日志影响性能)
    - [Q13: 如何在生产环境收集指标？](#q13-如何在生产环境收集指标)
  - [🔄 故障恢复问题](#-故障恢复问题)
    - [Q14: 重试机制的最佳实践是什么？](#q14-重试机制的最佳实践是什么)
    - [Q15: 如何实现超时控制？](#q15-如何实现超时控制)
    - [Q16: 如何实现优雅关机？](#q16-如何实现优雅关机)
  - [📈 性能相关问题](#-性能相关问题)
    - [Q17: 如何进行性能基准测试？](#q17-如何进行性能基准测试)
    - [Q18: 如何分析性能瓶颈？](#q18-如何分析性能瓶颈)
    - [Q19: 如何避免性能回归？](#q19-如何避免性能回归)
  - [🏗️ 架构设计问题](#️-架构设计问题)
    - [Q20: 如何设计高可用系统？](#q20-如何设计高可用系统)

---

## 🧪 测试相关问题

### Q1: 何时应该写单元测试 vs. 集成测试？

**单元测试**适用于：

- 纯函数和算法
- 业务逻辑
- 边界条件测试

```rust
#[test]
fn test_calculate_price() {
    assert_eq!(calculate_price(100, 0.1), 110.0);
}
```

**集成测试**适用于：

- 多模块协作
- 外部依赖（数据库、API）
- 端到端场景

```rust
// tests/integration_test.rs
#[tokio::test]
async fn test_user_registration() {
    let app = setup_test_app().await;
    let response = app.register_user("test@example.com").await;
    assert!(response.is_ok());
}
```

**建议**：两者结合，单元测试覆盖核心逻辑，集成测试验证整体流程。

---

### Q2: 如何测试私有函数？

**方案 1**: 通过公共 API 间接测试（推荐）

```rust
pub fn public_api(input: i32) -> i32 {
    private_helper(input) * 2
}

fn private_helper(x: i32) -> i32 {
    x + 1
}

#[test]
fn test_via_public_api() {
    assert_eq!(public_api(5), 12); // 间接测试 private_helper
}
```

**方案 2**: 在同一模块内测试

```rust
mod my_module {
    pub fn public_fn() -> i32 { private_fn() }
    fn private_fn() -> i32 { 42 }
    
    #[cfg(test)]
    mod tests {
        use super::*;
        
        #[test]
        fn test_private() {
            assert_eq!(private_fn(), 42); // 可访问私有函数
        }
    }
}
```

**方案 3**: 使用 `#[cfg(test)] pub`

```rust
#[cfg_attr(test, visibility::make(pub))]
fn private_fn() -> i32 { 42 }
```

---

### Q3: 如何组织测试代码？

**内联测试**（小型项目）：

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
}
```

**独立文件**（大型项目）：

```text
src/
├── lib.rs
├── module.rs
└── module/
    ├── mod.rs
    └── tests.rs  # 模块测试

tests/
├── integration_test.rs
└── common/
    └── mod.rs    # 测试辅助函数
```

---

### Q4: 如何测试异步代码？

使用异步测试运行时：

```rust
#[tokio::test]
async fn test_async_function() {
    let result = async_fetch_data().await;
    assert!(result.is_ok());
}

#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_concurrent() {
    // 并发测试
}
```

**注意事项**：

- 使用 `#[tokio::test]` 或 `#[async_std::test]`
- 注意超时设置
- 测试并发竞态条件

---

### Q5: 测试覆盖率多少才算够？

**没有绝对标准**，但可参考：

| 项目类型 | 建议覆盖率 | 说明 |
|---------|----------|------|
| 关键系统 | 80-90% | 金融、医疗等 |
| 一般应用 | 70-80% | 业务应用 |
| 工具库 | 85%+ | 公共库要求更高 |
| 原型/实验 | 50-60% | 快速迭代 |

**更重要的是**：

- 覆盖核心业务逻辑
- 覆盖边界条件
- 覆盖错误路径

```bash
# 生成覆盖率报告
cargo tarpaulin --out Html
cargo llvm-cov --html
```

---

## ❌ 错误处理问题

### Q6: Result vs. Panic，何时使用哪个？

**使用 Result**：

- 可恢复的错误
- 预期中的错误
- 库代码

```rust
fn parse_config(path: &str) -> Result<Config, ConfigError> {
    let content = std::fs::read_to_string(path)?;
    parse_toml(&content)
}
```

**使用 Panic**：

- 逻辑错误（编程错误）
- 不可恢复的错误
- 违反不变量

```rust
fn get_item(index: usize) -> &Item {
    if index >= self.len() {
        panic!("Index out of bounds");
    }
    &self.items[index]
}
```

**原则**：优先使用 `Result`，只在确实不可恢复时使用 `panic!`。

---

### Q7: 如何选择错误处理库 (thiserror vs. anyhow)？

**thiserror**：适用于**库**

- 定义清晰的错误类型
- 提供类型安全
- 用户可以精确处理错误

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyLibError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Invalid config: {0}")]
    Config(String),
}
```

**anyhow**：适用于**应用**

- 快速原型开发
- 不需要精确错误类型
- 丰富的错误上下文

```rust
use anyhow::{Context, Result};

fn main() -> Result<()> {
    let config = load_config()
        .context("Failed to load config")?;
    Ok(())
}
```

**建议**：库用 `thiserror`，应用用 `anyhow`。

---

### Q8: 如何处理多种错误类型？

**方案 1**: 使用 `Box<dyn Error>`

```rust
fn process() -> Result<(), Box<dyn std::error::Error>> {
    let file = std::fs::read_to_string("config.toml")?;
    let config: Config = toml::from_str(&file)?;
    Ok(())
}
```

**方案 2**: 自定义错误类型 + `From` trait

```rust
#[derive(Debug)]
enum MyError {
    Io(std::io::Error),
    Parse(toml::de::Error),
}

impl From<std::io::Error> for MyError {
    fn from(err: std::io::Error) -> Self {
        MyError::Io(err)
    }
}

impl From<toml::de::Error> for MyError {
    fn from(err: toml::de::Error) -> Self {
        MyError::Parse(err)
    }
}
```

**方案 3**: 使用 `thiserror` (推荐)

```rust
#[derive(Error, Debug)]
enum MyError {
    #[error("IO error")]
    Io(#[from] std::io::Error),
    
    #[error("Parse error")]
    Parse(#[from] toml::de::Error),
}
```

---

### Q9: 何时应该使用 `unwrap()`？

**安全使用场景**：

1. **测试代码**

    ```rust
    #[test]
    fn test_something() {
        let result = do_something().unwrap();
        assert_eq!(result, expected);
    }
    ```

2. **初始化阶段（main 函数）**

    ```rust
    fn main() {
        let config = load_config().unwrap();
        // ...
    }
    ```

3. **确定不会失败的情况**

```rust
let num = "42".parse::<i32>().unwrap(); // 硬编码字符串，确定成功
```

**避免在生产代码中使用**，改用：

- `expect()` 提供错误消息
- `?` 传播错误
- `match` 显式处理

---

## 📊 监控与日志问题

### Q10: log vs. tracing，应该用哪个？

**log**：简单日志记录

- 传统日志库
- 适合简单应用
- 性能开销小

```rust
use log::{info, warn, error};

info!("Server started on port {}", port);
error!("Failed to connect: {}", err);
```

**tracing**：结构化追踪（推荐）

- 支持分布式追踪
- 结构化日志
- 异步友好

```rust
use tracing::{info, instrument};

#[instrument]
async fn handle_request(id: u64) {
    info!(request_id = %id, "Processing request");
    // ...
}
```

**建议**：新项目使用 `tracing`，它是 `log` 的超集。

---

### Q11: 如何控制日志级别？

**环境变量**（推荐）：

```bash
# 设置全局级别
export RUST_LOG=info

# 按模块设置
export RUST_LOG=my_app=debug,hyper=warn

# 复杂过滤
export RUST_LOG="info,my_app::db=debug,tokio=error"
```

**代码配置**：

```rust
use tracing_subscriber::{EnvFilter, fmt};

tracing_subscriber::fmt()
    .with_env_filter(EnvFilter::from_default_env())
    .init();
```

---

### Q12: 如何避免日志影响性能？

**技巧 1**: 使用异步日志

```rust
use tracing_subscriber::fmt;

fmt()
    .with_writer(std::io::stderr)
    .with_ansi(false)
    .init();
```

**技巧 2**: 条件编译

```rust
#[cfg(debug_assertions)]
debug!("Detailed debug info: {:?}", data);
```

**技巧 3**: 采样

```rust
if rand::random::<f64>() < 0.01 { // 1% 采样
    info!("Sampled log");
}
```

**技巧 4**: 避免昂贵的格式化

```rust
// ❌ 不好：总是格式化
debug!("Data: {}", expensive_format(&data));

// ✅ 好：只在需要时格式化
debug!("Data: {:?}", data);
```

---

### Q13: 如何在生产环境收集指标？

**使用 Prometheus**：

```rust
use prometheus::{Counter, Histogram, Registry};

lazy_static! {
    static ref REQUESTS_TOTAL: Counter = Counter::new(
        "requests_total", "Total requests"
    ).unwrap();
    
    static ref RESPONSE_TIME: Histogram = Histogram::new(
        "response_time_seconds", "Response time"
    ).unwrap();
}

// 使用指标
REQUESTS_TOTAL.inc();
let timer = RESPONSE_TIME.start_timer();
// ... 处理请求 ...
timer.observe_duration();
```

**暴露 metrics 端点**：

```rust
use warp::Filter;

let metrics_route = warp::path("metrics")
    .map(|| {
        let encoder = TextEncoder::new();
        let metric_families = prometheus::gather();
        let mut buffer = vec![];
        encoder.encode(&metric_families, &mut buffer).unwrap();
        String::from_utf8(buffer).unwrap()
    });
```

---

## 🔄 故障恢复问题

### Q14: 重试机制的最佳实践是什么？

**指数退避 + 抖动**：

```rust
use tokio::time::{sleep, Duration};
use rand::Rng;

async fn retry_with_backoff<F, Fut, T>(mut f: F, max_attempts: u32) -> Result<T>
where
    F: FnMut() -> Fut,
    Fut: Future<Output = Result<T>>,
{
    for attempt in 1..=max_attempts {
        match f().await {
            Ok(result) => return Ok(result),
            Err(e) if attempt < max_attempts => {
                let base_delay = 2_u64.pow(attempt);
                let jitter = rand::thread_rng().gen_range(0..1000);
                sleep(Duration::from_millis(base_delay * 1000 + jitter)).await;
            }
            Err(e) => return Err(e),
        }
    }
    unreachable!()
}
```

**关键点**：

- 设置最大重试次数
- 使用指数退避
- 添加随机抖动
- 区分可重试和不可重试错误

---

### Q15: 如何实现超时控制？

**tokio timeout**：

```rust
use tokio::time::{timeout, Duration};

async fn fetch_with_timeout() -> Result<Data> {
    match timeout(Duration::from_secs(5), fetch_data()).await {
        Ok(Ok(data)) => Ok(data),
        Ok(Err(e)) => Err(e),
        Err(_) => Err(Error::Timeout),
    }
}
```

**多个超时层次**：

```rust
// 单个请求超时
let request_timeout = Duration::from_secs(5);

// 总体操作超时
let total_timeout = Duration::from_secs(30);

timeout(total_timeout, async {
    for _ in 0..3 {
        if let Ok(result) = timeout(request_timeout, request()).await {
            return result;
        }
    }
    Err(Error::AllAttemptsFailed)
}).await?
```

---

### Q16: 如何实现优雅关机？

**完整示例**：

```rust
use tokio::signal;
use tokio::sync::broadcast;

async fn graceful_shutdown(
    server: Server,
    shutdown_tx: broadcast::Sender<()>,
) {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("Failed to listen for Ctrl+C");
    };
    
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to listen for SIGTERM")
            .recv()
            .await;
    };
    
    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    
    println!("Shutting down gracefully...");
    
    // 通知所有任务停止接受新请求
    let _ = shutdown_tx.send(());
    
    // 等待正在处理的请求完成（最多30秒）
    tokio::time::timeout(
        Duration::from_secs(30),
        server.wait_for_active_requests()
    ).await.ok();
    
    println!("Shutdown complete");
}
```

---

## 📈 性能相关问题

### Q17: 如何进行性能基准测试？

**使用 Criterion**：

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });
}

criterion_group!(benches, fibonacci_benchmark);
criterion_main!(benches);
```

**运行基准测试**：

```bash
cargo bench
```

---

### Q18: 如何分析性能瓶颈？

**工具链**：

1. **Flamegraph**：

    ```bash
    cargo install flamegraph
    cargo flamegraph --bin my_app
    ```

2. **perf** (Linux)：

    ```bash
    perf record -F 99 -g ./target/release/my_app
    perf report
    ```

3. **Criterion 比较**：

    ```bash
    cargo bench -- --save-baseline before
    # 修改代码...
    cargo bench -- --baseline before
    ```

---

### Q19: 如何避免性能回归？

**CI/CD 集成**：

```yaml
# .github/workflows/bench.yml
- name: Run benchmarks
  run: cargo bench -- --save-baseline main

- name: Compare with PR
  run: cargo bench -- --baseline main
```

**设置阈值**：

```rust
c.bench_function("critical_path", |b| {
    b.iter(|| operation());
}).with_threshold(10.0); // 最多降低10%
```

---

## 🏗️ 架构设计问题

### Q20: 如何设计高可用系统？

**核心原则**：

1. **消除单点故障**：冗余部署
2. **快速故障检测**：健康检查
3. **自动故障转移**：主备切换
4. **数据冗余**：复制与备份
5. **监控告警**：及时发现问题

**示例架构**：

```rust
struct HighAvailabilityService {
    primary: ServiceInstance,
    secondaries: Vec<ServiceInstance>,
    health_checker: HealthChecker,
    load_balancer: LoadBalancer,
}

impl HighAvailabilityService {
    async fn handle_request(&self, req: Request) -> Response {
        // 1. 健康检查
        if !self.health_checker.is_healthy(&self.primary).await {
            // 2. 故障转移
            return self.failover_to_secondary(req).await;
        }
        
        // 3. 负载均衡
        self.load_balancer.route(req).await
    }
}
```

---

**上一步**: [术语表](./03_术语表.md)  
**下一步**: [进入 Tier 2 实践层](../tier_02_guides/)
