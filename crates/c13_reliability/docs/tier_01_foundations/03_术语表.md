# 术语表 - C13 Reliability

**最后更新**: 2025-10-24

本文档汇总了 Rust 可靠性工程中的核心术语和概念。

---

## 📋 目录

- [术语表 - C13 Reliability](#术语表---c13-reliability)
  - [📋 目录](#-目录)
  - [🧪 测试相关术语](#-测试相关术语)
    - [Unit Test (单元测试)](#unit-test-单元测试)
    - [Integration Test (集成测试)](#integration-test-集成测试)
    - [Benchmark (基准测试)](#benchmark-基准测试)
    - [Fuzz Testing (模糊测试)](#fuzz-testing-模糊测试)
    - [Property-Based Testing (属性测试)](#property-based-testing-属性测试)
    - [Test Coverage (测试覆盖率)](#test-coverage-测试覆盖率)
  - [❌ 错误处理术语](#-错误处理术语)
    - [Result Type (Result 类型)](#result-type-result-类型)
    - [Panic (恐慌)](#panic-恐慌)
    - [Error Propagation (错误传播)](#error-propagation-错误传播)
    - [Error Chain (错误链)](#error-chain-错误链)
    - [Custom Error Type (自定义错误类型)](#custom-error-type-自定义错误类型)
  - [📊 监控与可观测性术语](#-监控与可观测性术语)
    - [Logging (日志记录)](#logging-日志记录)
    - [Metrics (指标)](#metrics-指标)
    - [Tracing (追踪)](#tracing-追踪)
    - [Observability (可观测性)](#observability-可观测性)
    - [SLI/SLO/SLA](#slislosla)
  - [🔄 故障恢复术语](#-故障恢复术语)
    - [Timeout (超时)](#timeout-超时)
    - [Retry (重试)](#retry-重试)
    - [Circuit Breaker (断路器)](#circuit-breaker-断路器)
    - [Bulkhead (舱壁)](#bulkhead-舱壁)
    - [Graceful Degradation (优雅降级)](#graceful-degradation-优雅降级)
    - [Graceful Shutdown (优雅关机)](#graceful-shutdown-优雅关机)
  - [📈 性能相关术语](#-性能相关术语)
    - [Latency (延迟)](#latency-延迟)
    - [Throughput (吞吐量)](#throughput-吞吐量)
    - [Profiling (性能剖析)](#profiling-性能剖析)
  - [🏗️ 架构模式术语](#️-架构模式术语)
    - [High Availability (高可用)](#high-availability-高可用)
    - [Fault Tolerance (容错)](#fault-tolerance-容错)
    - [Load Balancing (负载均衡)](#load-balancing-负载均衡)
    - [Chaos Engineering (混沌工程)](#chaos-engineering-混沌工程)

---

## 🧪 测试相关术语

### Unit Test (单元测试)

针对单个函数或模块的测试，通过 `#[test]` 属性标记。

```rust
#[test]
fn test_add() {
    assert_eq!(2 + 2, 4);
}
```

**特点**:

- 快速执行
- 隔离性强
- 测试最小单元

---

### Integration Test (集成测试)

测试多个模块协作的测试，位于 `tests/` 目录。

```rust
// tests/integration_test.rs
#[test]
fn test_end_to_end() {
    // 测试多个模块的交互
}
```

**特点**:

- 测试模块间交互
- 更接近真实使用场景
- 执行时间较长

---

### Benchmark (基准测试)

衡量代码性能的测试，通常使用 Criterion 框架。

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}
```

**关键指标**:

- 吞吐量 (Throughput)
- 延迟 (Latency)
- 内存使用

---

### Fuzz Testing (模糊测试)

通过生成随机输入来发现程序漏洞的测试方法。

```rust
#[cfg(test)]
mod fuzz_tests {
    use libfuzzer_sys::fuzz_target;
    
    fuzz_target!(|data: &[u8]| {
        let _ = parse_input(data);
    });
}
```

**特点**:

- 发现边界情况
- 自动生成测试用例
- 发现未预期的错误

---

### Property-Based Testing (属性测试)

通过验证属性而非具体值的测试方法，使用 `proptest` 或 `quickcheck`。

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_reverse_twice(v: Vec<i32>) {
        let reversed_twice: Vec<i32> = v.iter().copied().rev().rev().collect();
        prop_assert_eq!(v, reversed_twice);
    }
}
```

**特点**:

- 验证数学性质
- 自动生成测试数据
- 发现通用规律

---

### Test Coverage (测试覆盖率)

代码被测试覆盖的百分比，使用 `tarpaulin` 或 `llvm-cov` 测量。

```bash
cargo tarpaulin --out Html
cargo llvm-cov --html
```

**指标**:

- 行覆盖率 (Line Coverage)
- 分支覆盖率 (Branch Coverage)
- 函数覆盖率 (Function Coverage)

---

## ❌ 错误处理术语

### Result Type (Result 类型)

Rust 的可恢复错误类型，包含 `Ok(T)` 和 `Err(E)` 两种变体。

```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}
```

**特点**:

- 强制错误处理
- 类型安全
- 可组合

---

### Panic (恐慌)

不可恢复的错误，导致程序终止或线程退出。

```rust
panic!("Something went terribly wrong!");
```

**使用场景**:

- 逻辑错误
- 不可恢复的错误
- 测试断言失败

---

### Error Propagation (错误传播)

通过 `?` 运算符向上层传递错误。

```rust
fn read_file() -> Result<String, std::io::Error> {
    let content = std::fs::read_to_string("file.txt")?;
    Ok(content)
}
```

**优势**:

- 简洁语法
- 自动类型转换
- 保持错误上下文

---

### Error Chain (错误链)

保留错误的原始上下文和调用链。

```rust
use anyhow::{Context, Result};

fn process() -> Result<()> {
    read_config()
        .context("Failed to read config")?;
    Ok(())
}
```

**特点**:

- 保留错误历史
- 便于调试
- 用户友好的错误消息

---

### Custom Error Type (自定义错误类型)

使用 `thiserror` 或手动实现 `std::error::Error`。

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Parse error: {0}")]
    Parse(String),
}
```

**优势**:

- 类型安全
- 丰富的错误信息
- 便于错误分类

---

## 📊 监控与可观测性术语

### Logging (日志记录)

记录程序运行时的事件和状态。

```rust
use tracing::{info, warn, error};

info!("Server started");
warn!("High memory usage: {}MB", mem);
error!("Database connection failed");
```

**日志级别**:

- TRACE: 最详细
- DEBUG: 调试信息
- INFO: 一般信息
- WARN: 警告
- ERROR: 错误

---

### Metrics (指标)

量化的性能和状态数据，通常用于 Prometheus。

```rust
use prometheus::{Counter, Histogram, Gauge};

let requests_total = Counter::new("requests_total", "Total requests")?;
let response_time = Histogram::new("response_time", "Response time")?;
let active_connections = Gauge::new("active_connections", "Active connections")?;
```

**常见指标类型**:

- Counter: 只增不减的计数器
- Gauge: 可增可减的仪表
- Histogram: 分布统计

---

### Tracing (追踪)

分布式系统中请求的完整路径跟踪。

```rust
use tracing::{span, instrument};

#[instrument]
async fn process_request(id: u64) {
    let span = span!(tracing::Level::INFO, "database_query");
    let _enter = span.enter();
    // 数据库查询...
}
```

**特点**:

- 跨服务追踪
- 可视化调用链
- 性能瓶颈识别

---

### Observability (可观测性)

系统通过日志、指标、追踪来暴露内部状态的能力。

**三大支柱**:

1. **Logs**: 离散事件
2. **Metrics**: 聚合数据
3. **Traces**: 请求路径

---

### SLI/SLO/SLA

- **SLI (Service Level Indicator)**: 服务水平指标
- **SLO (Service Level Objective)**: 服务水平目标
- **SLA (Service Level Agreement)**: 服务水平协议

```rust
// 示例：99.9% 可用性 SLO
const AVAILABILITY_SLO: f64 = 0.999;
```

---

## 🔄 故障恢复术语

### Timeout (超时)

限制操作的最长执行时间。

```rust
use tokio::time::{timeout, Duration};

let result = timeout(Duration::from_secs(5), long_operation()).await;
```

**目的**:

- 防止无限等待
- 快速失败
- 资源释放

---

### Retry (重试)

失败后重新尝试操作。

```rust
for attempt in 1..=3 {
    match try_operation().await {
        Ok(result) => return Ok(result),
        Err(e) if attempt < 3 => continue,
        Err(e) => return Err(e),
    }
}
```

**策略**:

- 固定延迟
- 指数退避
- 抖动 (Jitter)

---

### Circuit Breaker (断路器)

防止级联故障的保护机制。

**状态**:

- **Closed**: 正常运行
- **Open**: 故障打开，快速失败
- **Half-Open**: 尝试恢复

---

### Bulkhead (舱壁)

隔离资源，防止故障扩散。

```rust
let pool = ThreadPool::new(4); // 限制线程数
```

**目的**:

- 资源隔离
- 故障隔离
- 防止资源耗尽

---

### Graceful Degradation (优雅降级)

功能部分失效时提供降级服务。

```rust
async fn get_data() -> Result<Data> {
    match fetch_from_cache().await {
        Ok(data) => Ok(data),
        Err(_) => fetch_from_database().await, // 降级到数据库
    }
}
```

---

### Graceful Shutdown (优雅关机)

在停止服务前完成正在进行的请求。

```rust
tokio::select! {
    _ = server.run() => {},
    _ = shutdown_signal() => {
        // 清理资源
        server.graceful_shutdown().await;
    }
}
```

---

## 📈 性能相关术语

### Latency (延迟)

请求从发出到收到响应的时间。

**指标**:

- P50: 中位数
- P95: 95% 请求的延迟
- P99: 99% 请求的延迟

---

### Throughput (吞吐量)

单位时间内处理的请求数量。

```rust
// requests per second (RPS)
let rps = total_requests / duration_seconds;
```

---

### Profiling (性能剖析)

分析程序性能瓶颈的过程。

**工具**:

- `perf`: Linux 性能分析
- `flamegraph`: 火焰图可视化
- `criterion`: 基准测试

---

## 🏗️ 架构模式术语

### High Availability (高可用)

系统持续可用的能力，通常用"几个9"表示。

- 99% = 年停机 3.65 天
- 99.9% = 年停机 8.76 小时
- 99.99% = 年停机 52.56 分钟

---

### Fault Tolerance (容错)

系统在部分组件故障时继续运行的能力。

**技术**:

- 冗余
- 主备切换
- 数据复制

---

### Load Balancing (负载均衡)

将请求分配到多个服务实例。

**算法**:

- Round Robin
- Least Connections
- IP Hash

---

### Chaos Engineering (混沌工程)

主动注入故障以测试系统韧性。

```rust
// 模拟网络延迟
async fn inject_latency() {
    if rand::random::<f64>() < 0.1 { // 10% 概率
        sleep(Duration::from_millis(500)).await;
    }
}
```

---

**上一步**: [主索引导航](./02_主索引导航.md)  
**下一步**: [常见问题](./04_常见问题.md)
