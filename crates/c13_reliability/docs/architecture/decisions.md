# 架构决策记录 (ADR)


## 📊 目录

- [ADR-001: 采用 tokio 作为异步运行时](#adr-001-采用-tokio-作为异步运行时)
  - [背景](#背景)
  - [决策](#决策)
  - [理由](#理由)
  - [后果](#后果)
- [ADR-002: 使用 anyhow::Error 作为统一错误类型](#adr-002-使用-anyhowerror-作为统一错误类型)
  - [背景1](#背景1)
  - [决策1](#决策1)
  - [理由1](#理由1)
  - [后果1](#后果1)
- [ADR-003: 熔断器采用五状态模型](#adr-003-熔断器采用五状态模型)
  - [背景2](#背景2)
  - [决策2](#决策2)
  - [理由2](#理由2)
  - [后果2](#后果2)
- [ADR-004: 支持五种限流算法](#adr-004-支持五种限流算法)
  - [背景3](#背景3)
  - [决策3](#决策3)
  - [理由3](#理由3)
  - [后果3](#后果3)
- [ADR-005: 使用 parking_lot 替代标准库锁](#adr-005-使用-parking_lot-替代标准库锁)
  - [背景4](#背景4)
  - [决策4](#决策4)
  - [理由4](#理由4)
  - [后果4](#后果4)
- [ADR-006: 分离同步和异步锁](#adr-006-分离同步和异步锁)
  - [背景5](#背景5)
  - [决策5](#决策5)
  - [理由5](#理由5)
  - [后果5](#后果5)
- [ADR-007: 实现完整的分布式事务模式](#adr-007-实现完整的分布式事务模式)
  - [背景6](#背景6)
  - [决策6](#决策6)
  - [理由6](#理由6)
  - [后果6](#后果6)
- [ADR-008: Actor 模型使用消息传递](#adr-008-actor-模型使用消息传递)
  - [背景7](#背景7)
  - [决策7](#决策7)
  - [理由7](#理由7)
  - [后果7](#后果7)
- [ADR-009: 指标聚合使用时间窗口](#adr-009-指标聚合使用时间窗口)
  - [背景8](#背景8)
  - [决策8](#决策8)
  - [理由8](#理由8)
  - [后果8](#后果8)
- [ADR-010: 设计模式库强调实用性](#adr-010-设计模式库强调实用性)
  - [背景9](#背景9)
  - [决策9](#决策9)
  - [理由9](#理由9)
  - [后果9](#后果9)
- [ADR-011: 性能基准测试框架独立设计](#adr-011-性能基准测试框架独立设计)
  - [背景10](#背景10)
  - [决策10](#决策10)
  - [理由10](#理由10)
  - [后果10](#后果10)
- [ADR-012: 文档优先原则](#adr-012-文档优先原则)
  - [背景11](#背景11)
  - [决策11](#决策11)
  - [理由11](#理由11)
  - [后果11](#后果11)
- [决策原则](#决策原则)
- [未来考虑](#未来考虑)
  - [正在评估](#正在评估)
  - [已拒绝](#已拒绝)


本文档记录了 c13_reliability 项目的重要架构决策。

## ADR-001: 采用 tokio 作为异步运行时

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景

项目需要一个成熟的异步运行时来支持高并发场景。

### 决策

选择 tokio 作为唯一的异步运行时。

### 理由

1. **生态系统成熟** - tokio 拥有最完善的 Rust 异步生态
2. **性能优秀** - 经过充分优化，适合生产环境
3. **社区支持** - 大量的库和工具支持
4. **稳定性** - 已在大量生产环境验证

### 后果

- ✅ 统一的异步编程模型
- ✅ 良好的性能保证
- ⚠️ 与其他运行时（如 async-std）不兼容

---

## ADR-002: 使用 anyhow::Error 作为统一错误类型

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景1

需要一个简单灵活的错误处理方案，同时保持类型安全。

### 决策1

在公共 API 中使用 `anyhow::Result<T>` 作为返回类型。

### 理由1

1. **简化错误传播** - 自动转换不同类型的错误
2. **上下文丰富** - 支持 `.context()` 添加错误上下文
3. **零成本抽象** - 编译时优化
4. **生态兼容** - 与大多数 Rust 库兼容

### 后果1

- ✅ 简化了错误处理代码
- ✅ 更好的错误消息
- ⚠️ 丢失了具体的错误类型信息

---

## ADR-003: 熔断器采用五状态模型

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景2

传统的三状态熔断器（Closed/Open/Half-Open）在某些场景下不够灵活。

### 决策2

实现五状态熔断器：Closed → Open → Half-Open → Recovering → Closed

### 理由2

1. **渐进式恢复** - Recovering 状态允许更平滑的恢复过程
2. **更好的控制** - 可以精确控制恢复期间的请求数
3. **避免震荡** - 减少在 Half-Open 和 Open 之间的频繁切换

### 后果2

- ✅ 更稳定的系统恢复
- ✅ 更好的用户体验
- ⚠️ 实现更复杂

---

## ADR-004: 支持五种限流算法

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景3

不同场景需要不同的限流策略。

### 决策3

实现五种限流算法：Token Bucket、Leaky Bucket、Fixed Window、Sliding Window、Sliding Window Log

### 理由3

1. **场景覆盖** - 满足不同的业务需求
2. **灵活选择** - 用户可根据场景选择最合适的算法
3. **学习价值** - 提供完整的限流算法参考实现

### 后果3

- ✅ 高度灵活
- ✅ 教育价值
- ⚠️ 增加了维护成本

---

## ADR-005: 使用 parking_lot 替代标准库锁

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景4

标准库的 `Mutex` 和 `RwLock` 在高并发场景下性能不佳。

### 决策4

在非异步代码中使用 `parking_lot` 的锁实现。

### 理由4

1. **性能更好** - parking_lot 的锁实现更高效
2. **更小的内存占用** - 锁对象更小
3. **无毒性** - 不会因为 panic 导致锁中毒
4. **API 兼容** - 与标准库 API 基本一致

### 后果4

- ✅ 显著的性能提升
- ✅ 更好的并发性能
- ⚠️ 需要注意 Send trait 问题

---

## ADR-006: 分离同步和异步锁

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景5

在 async 上下文中使用 parking_lot 会导致 Send trait 问题。

### 决策5

- 异步代码使用 `tokio::sync::RwLock`
- 同步代码使用 `parking_lot::RwLock`

### 理由5

1. **类型安全** - 避免 Send trait 错误
2. **性能优化** - 各取所长
3. **明确分离** - 代码意图更清晰

### 后果5

- ✅ 避免了编译错误
- ✅ 更好的性能
- ⚠️ 需要选择正确的锁类型

---

## ADR-007: 实现完整的分布式事务模式

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景6

分布式系统需要多种事务保证机制。

### 决策6

实现四种分布式事务模式：Saga、2PC、3PC、TCC

### 理由6

1. **场景覆盖** - 不同场景有不同需求
2. **CAP 权衡** - 允许用户根据 CAP 定理选择
3. **完整性** - 提供分布式事务的完整解决方案

### 后果6

- ✅ 灵活的事务选择
- ✅ 学习价值高
- ⚠️ 实现复杂度高

---

## ADR-008: Actor 模型使用消息传递

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景7

需要实现一个线程安全的 Actor 模型。

### 决策7

使用 channel 实现 Actor 之间的消息传递，每个 Actor 在独立的 tokio 任务中运行。

### 理由7

1. **隔离性** - 每个 Actor 独立运行
2. **无共享状态** - 通过消息传递避免共享
3. **容错性** - 易于实现监督树
4. **性能** - tokio 的 channel 性能优秀

### 后果7

- ✅ 良好的隔离性
- ✅ 易于实现容错
- ⚠️ 消息传递有一定开销

---

## ADR-009: 指标聚合使用时间窗口

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景8

需要一个高效的指标聚合系统。

### 决策8

使用滑动时间窗口进行指标聚合，支持多种窗口大小（1分钟到24小时）。

### 理由8

1. **内存可控** - 自动清理过期数据
2. **实时性** - 提供最新的统计信息
3. **灵活性** - 支持多种时间粒度

### 后果8

- ✅ 内存使用可预测
- ✅ 实时统计
- ⚠️ 需要定期清理

---

## ADR-010: 设计模式库强调实用性

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景9

需要实现常见的设计模式，但要适应 Rust 的特性。

### 决策9

实现五种核心设计模式，并针对可靠性场景进行优化。

### 理由9

1. **实用导向** - 选择最常用的模式
2. **Rust 化** - 利用 Rust 的类型系统和所有权
3. **可靠性优先** - 每个模式都考虑错误处理

### 后果9

- ✅ 实用价值高
- ✅ 代码质量好
- ⚠️ 与传统 OOP 模式有差异

---

## ADR-011: 性能基准测试框架独立设计

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景10

需要一个内置的性能测试工具。

### 决策10

实现独立的 benchmarking 模块，包含负载生成、延迟分析和吞吐量测量。

### 理由10

1. **自包含** - 不依赖外部工具
2. **灵活** - 支持多种负载模式
3. **精确** - 提供详细的性能指标

### 后果10

- ✅ 易于使用
- ✅ 功能完整
- ⚠️ 增加了代码量

---

## ADR-012: 文档优先原则

**日期**: 2025-10-03  
**状态**: ✅ 已接受

### 背景11

复杂的系统需要完善的文档。

### 决策11

为每个模块提供详细的文档，包括示例代码和最佳实践。

### 理由11

1. **可用性** - 降低学习曲线
2. **可维护性** - 帮助未来的维护者
3. **专业性** - 体现项目质量

### 后果11

- ✅ 用户体验好
- ✅ 项目质量高
- ⚠️ 维护工作量大

---

## 决策原则

在做架构决策时，我们遵循以下原则：

1. **性能优先** - 在不牺牲可维护性的前提下追求高性能
2. **类型安全** - 充分利用 Rust 的类型系统
3. **零成本抽象** - 避免不必要的运行时开销
4. **实用主义** - 选择最适合 Rust 的方案，而不是盲目模仿其他语言
5. **可测试性** - 所有组件都应该易于测试
6. **文档完整** - 提供清晰的文档和示例

---

## 未来考虑

以下是正在考虑但尚未最终决定的架构选项：

### 正在评估

1. **是否集成 Prometheus SDK** - 考虑直接支持 Prometheus 指标导出
2. **是否支持 WebAssembly** - 考虑在 WASM 环境中运行
3. **是否提供 C FFI** - 考虑为其他语言提供绑定
4. **是否支持多运行时** - 考虑支持 async-std

### 已拒绝

1. ❌ **使用宏来简化 API** - 增加学习成本，降低可读性
2. ❌ **支持同步 API** - 增加维护负担，与项目目标不符

---

**版本**: 1.0  
**最后更新**: 2025-10-03  
**维护者**: c13_reliability 团队
