# ç”Ÿäº§ç¯å¢ƒè°ƒè¯•

> **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡åœ¨ç”Ÿäº§ç¯å¢ƒä¸­è¯Šæ–­å’Œä¿®å¤é—®é¢˜çš„ç­–ç•¥ã€å·¥å…·å’Œæœ€ä½³å®è·µã€‚

---

## ğŸ“– ç›®å½•

- [ç”Ÿäº§ç¯å¢ƒè°ƒè¯•](#ç”Ÿäº§ç¯å¢ƒè°ƒè¯•)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [ç”Ÿäº§è°ƒè¯•æŒ‘æˆ˜](#ç”Ÿäº§è°ƒè¯•æŒ‘æˆ˜)
    - [ç‰¹æ®Šçº¦æŸ](#ç‰¹æ®Šçº¦æŸ)
    - [è°ƒè¯•åŸåˆ™](#è°ƒè¯•åŸåˆ™)
  - [å¯è§‚æµ‹æ€§æ¶æ„](#å¯è§‚æµ‹æ€§æ¶æ„)
    - [ä¸‰å¤§æ”¯æŸ±](#ä¸‰å¤§æ”¯æŸ±)
    - [é›†æˆç­–ç•¥](#é›†æˆç­–ç•¥)
  - [æ—¥å¿—ç³»ç»Ÿ](#æ—¥å¿—ç³»ç»Ÿ)
    - [ç»“æ„åŒ–æ—¥å¿—](#ç»“æ„åŒ–æ—¥å¿—)
    - [æ—¥å¿—çº§åˆ«](#æ—¥å¿—çº§åˆ«)
    - [æ—¥å¿—èšåˆ](#æ—¥å¿—èšåˆ)
    - [æ—¥å¿—æŸ¥è¯¢](#æ—¥å¿—æŸ¥è¯¢)
  - [æŒ‡æ ‡ç›‘æ§](#æŒ‡æ ‡ç›‘æ§)
    - [Prometheus é›†æˆ](#prometheus-é›†æˆ)
    - [RED æ–¹æ³•](#red-æ–¹æ³•)
    - [è‡ªå®šä¹‰æŒ‡æ ‡](#è‡ªå®šä¹‰æŒ‡æ ‡)
    - [å‘Šè­¦è§„åˆ™](#å‘Šè­¦è§„åˆ™)
  - [åˆ†å¸ƒå¼è¿½è¸ª](#åˆ†å¸ƒå¼è¿½è¸ª)
    - [OpenTelemetry](#opentelemetry)
    - [Jaeger é›†æˆ](#jaeger-é›†æˆ)
    - [Span è®¾è®¡](#span-è®¾è®¡)
    - [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)
  - [é”™è¯¯è¿½è¸ª](#é”™è¯¯è¿½è¸ª)
    - [Sentry é›†æˆ](#sentry-é›†æˆ)
    - [è‡ªå®šä¹‰é”™è¯¯ä¸Šä¸‹æ–‡](#è‡ªå®šä¹‰é”™è¯¯ä¸Šä¸‹æ–‡)
    - [é”™è¯¯åˆ†ç»„](#é”™è¯¯åˆ†ç»„)
  - [æ€§èƒ½åˆ†æ1](#æ€§èƒ½åˆ†æ1)
    - [CPU Profiling](#cpu-profiling)
    - [å†…å­˜åˆ†æ](#å†…å­˜åˆ†æ)
    - [å®æ—¶åˆ†æ](#å®æ—¶åˆ†æ)
  - [å¥åº·æ£€æŸ¥](#å¥åº·æ£€æŸ¥)
    - [ç«¯ç‚¹è®¾è®¡](#ç«¯ç‚¹è®¾è®¡)
    - [ä¾èµ–æ£€æŸ¥](#ä¾èµ–æ£€æŸ¥)
    - [ä¼˜é›…é™çº§](#ä¼˜é›…é™çº§)
  - [é‡‘ä¸é›€éƒ¨ç½²](#é‡‘ä¸é›€éƒ¨ç½²)
    - [æµé‡åˆ†é…](#æµé‡åˆ†é…)
    - [ç›‘æ§æŒ‡æ ‡](#ç›‘æ§æŒ‡æ ‡)
    - [å›æ»šç­–ç•¥](#å›æ»šç­–ç•¥)
  - [æ•…éšœæ’æŸ¥æµç¨‹](#æ•…éšœæ’æŸ¥æµç¨‹)
    - [é—®é¢˜å®šä½](#é—®é¢˜å®šä½)
    - [æ ¹å› åˆ†æ](#æ ¹å› åˆ†æ)
    - [ä¿®å¤éªŒè¯](#ä¿®å¤éªŒè¯)
  - [å¸¸è§ç”Ÿäº§é—®é¢˜](#å¸¸è§ç”Ÿäº§é—®é¢˜)
    - [å†…å­˜æ³„æ¼](#å†…å­˜æ³„æ¼)
    - [CPU é«˜è´Ÿè½½](#cpu-é«˜è´Ÿè½½)
    - [è¿æ¥æ± è€—å°½](#è¿æ¥æ± è€—å°½)
    - [æ­»é”ä¸æ´»é”](#æ­»é”ä¸æ´»é”)
  - [åº”æ€¥å“åº”](#åº”æ€¥å“åº”)
    - [äº‹æ•…åˆ†çº§](#äº‹æ•…åˆ†çº§)
    - [å“åº”æµç¨‹](#å“åº”æµç¨‹)
    - [äº‹åå¤ç›˜](#äº‹åå¤ç›˜)
  - [å®‰å…¨è°ƒè¯•](#å®‰å…¨è°ƒè¯•)
    - [æ•æ„Ÿä¿¡æ¯è„±æ•](#æ•æ„Ÿä¿¡æ¯è„±æ•)
    - [è®¿é—®æ§åˆ¶](#è®¿é—®æ§åˆ¶)
    - [å®¡è®¡æ—¥å¿—](#å®¡è®¡æ—¥å¿—)
  - [å·¥å…·é›†æˆ](#å·¥å…·é›†æˆ)
    - [Kubernetes](#kubernetes)
    - [Docker](#docker)
    - [Cloud Provider](#cloud-provider)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [è®¾è®¡é˜¶æ®µ](#è®¾è®¡é˜¶æ®µ)
    - [å¼€å‘é˜¶æ®µ](#å¼€å‘é˜¶æ®µ)
    - [éƒ¨ç½²é˜¶æ®µ](#éƒ¨ç½²é˜¶æ®µ)
    - [è¿ç»´é˜¶æ®µ](#è¿ç»´é˜¶æ®µ)
  - [æ€»ç»“](#æ€»ç»“)
    - [1. å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±](#1-å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±)
    - [2. å…³é”®å®è·µ](#2-å…³é”®å®è·µ)
    - [3. åº”æ€¥å“åº”](#3-åº”æ€¥å“åº”)
    - [4. æŒç»­æ”¹è¿›](#4-æŒç»­æ”¹è¿›)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)

---

## ç”Ÿäº§è°ƒè¯•æŒ‘æˆ˜

### ç‰¹æ®Šçº¦æŸ

ç”Ÿäº§ç¯å¢ƒè°ƒè¯•ä¸å¼€å‘ç¯å¢ƒæˆªç„¶ä¸åŒï¼š

| æ–¹é¢ | å¼€å‘ç¯å¢ƒ | ç”Ÿäº§ç¯å¢ƒ |
|------|---------|---------|
| **è®¿é—®æƒé™** | å®Œå…¨è®¿é—® | å—é™è®¿é—® |
| **è°ƒè¯•å·¥å…·** | å…¨éƒ¨å¯ç”¨ | éƒ¨åˆ†å¯ç”¨ |
| **æ€§èƒ½å½±å“** | å¯ä»¥å®¹å¿ | å¿…é¡»æœ€å°åŒ– |
| **æ•°æ®å®‰å…¨** | æµ‹è¯•æ•°æ® | çœŸå®æ•°æ® |
| **å¯é‡ç°æ€§** | å®¹æ˜“ | å›°éš¾ |
| **å›æ»šæˆæœ¬** | ä½ | é«˜ |

### è°ƒè¯•åŸåˆ™

```text
ç”Ÿäº§è°ƒè¯•é»„é‡‘æ³•åˆ™
â”œâ”€ 1. éä¾µå…¥æ€§
â”‚  â””â”€ æœ€å°åŒ–å¯¹ç³»ç»Ÿçš„å½±å“
â”œâ”€ 2. å¯è§‚æµ‹æ€§
â”‚  â””â”€ æå‰åŸ‹ç‚¹ï¼Œè€Œéäº‹åè¡¥æ•‘
â”œâ”€ 3. å®‰å…¨ç¬¬ä¸€
â”‚  â””â”€ ä¿æŠ¤ç”¨æˆ·æ•°æ®å’Œéšç§
â”œâ”€ 4. å¿«é€Ÿæ¢å¤
â”‚  â””â”€ ä¼˜å…ˆæ¢å¤æœåŠ¡ï¼Œå†æ·±å…¥åˆ†æ
â””â”€ 5. æŒç»­æ”¹è¿›
   â””â”€ æ¯æ¬¡æ•…éšœéƒ½æ˜¯å­¦ä¹ æœºä¼š
```

---

## å¯è§‚æµ‹æ€§æ¶æ„

### ä¸‰å¤§æ”¯æŸ±

```rust
// å®Œæ•´çš„å¯è§‚æµ‹æ€§æ ˆ
use tracing::{info, error, instrument};
use prometheus::{IntCounter, Histogram};
use opentelemetry::trace::Tracer;

pub struct ObservabilityStack {
    // æ—¥å¿—
    logger: Logger,
    
    // æŒ‡æ ‡
    request_counter: IntCounter,
    response_time: Histogram,
    
    // è¿½è¸ª
    tracer: Box<dyn Tracer + Send + Sync>,
}

impl ObservabilityStack {
    #[instrument(skip(self))]
    pub async fn handle_request(&self, req: Request) -> Response {
        // 1. æ—¥å¿—è®°å½•
        info!(
            request_id = %req.id,
            method = %req.method,
            path = %req.path,
            "Handling request"
        );
        
        // 2. æŒ‡æ ‡æ›´æ–°
        self.request_counter.inc();
        let timer = self.response_time.start_timer();
        
        // 3. è¿½è¸ªä¸Šä¸‹æ–‡
        let span = self.tracer.start("handle_request");
        
        let result = self.process(req).await;
        
        timer.observe_duration();
        span.end();
        
        result
    }
}
```

### é›†æˆç­–ç•¥

```rust
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

pub fn init_observability() -> Result<()> {
    // æ—¥å¿—å±‚
    let fmt_layer = tracing_subscriber::fmt::layer()
        .json()
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true);
    
    // OpenTelemetry å±‚
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_simple()?;
    let telemetry_layer = tracing_opentelemetry::layer().with_tracer(tracer);
    
    // è¿‡æ»¤å±‚
    let filter_layer = tracing_subscriber::EnvFilter::try_from_default_env()
        .or_else(|_| tracing_subscriber::EnvFilter::try_new("info"))?;
    
    // ç»„åˆæ‰€æœ‰å±‚
    tracing_subscriber::registry()
        .with(filter_layer)
        .with(fmt_layer)
        .with(telemetry_layer)
        .init();
    
    Ok(())
}
```

---

## æ—¥å¿—ç³»ç»Ÿ

### ç»“æ„åŒ–æ—¥å¿—

```rust
use tracing::{info, error, warn};
use serde_json::json;

#[instrument(fields(user_id, request_id))]
async fn process_payment(
    user_id: u64,
    request_id: Uuid,
    amount: Decimal,
) -> Result<PaymentResult> {
    info!(
        user_id = %user_id,
        request_id = %request_id,
        amount = %amount,
        currency = "USD",
        "Starting payment processing"
    );
    
    match charge_card(user_id, amount).await {
        Ok(charge_id) => {
            info!(
                charge_id = %charge_id,
                "Payment successful"
            );
            Ok(PaymentResult::Success(charge_id))
        }
        Err(e) => {
            error!(
                error = %e,
                error_type = e.type_name(),
                "Payment failed",
            );
            Err(e)
        }
    }
}
```

### æ—¥å¿—çº§åˆ«

```rust
// ç”Ÿäº§ç¯å¢ƒæ—¥å¿—ç­–ç•¥
pub enum LogLevel {
    // ERROR: éœ€è¦ç«‹å³å…³æ³¨
    Error,   // ä¾‹: æ”¯ä»˜å¤±è´¥ã€æ•°æ®åº“è¿æ¥æ–­å¼€
    
    // WARN: æ½œåœ¨é—®é¢˜
    Warn,    // ä¾‹: é‡è¯•æˆåŠŸã€é™çº§æœåŠ¡
    
    // INFO: å…³é”®ä¸šåŠ¡äº‹ä»¶
    Info,    // ä¾‹: ç”¨æˆ·æ³¨å†Œã€è®¢å•åˆ›å»º
    
    // DEBUG: è¯¦ç»†è¯Šæ–­ä¿¡æ¯ (ç”Ÿäº§é€šå¸¸å…³é—­)
    Debug,   // ä¾‹: SQL æŸ¥è¯¢ã€API è¯·æ±‚è¯¦æƒ…
    
    // TRACE: è¶…è¯¦ç»†ä¿¡æ¯ (ä»…å¼€å‘)
    Trace,   // ä¾‹: å‡½æ•°è¿›å…¥/é€€å‡º
}

impl LogLevel {
    pub fn production_filter() -> &'static str {
        // é»˜è®¤ INFOï¼Œç‰¹å®šæ¨¡å— DEBUG
        "info,my_app::auth=debug,sqlx=warn"
    }
}
```

### æ—¥å¿—èšåˆ

```rust
// å‘é€æ—¥å¿—åˆ°ä¸­å¿ƒåŒ–ç³»ç»Ÿ
use tracing_appender::rolling::{RollingFileAppender, Rotation};

pub fn setup_log_shipping() {
    // æœ¬åœ°æ–‡ä»¶ (å¤‡ä»½)
    let file_appender = RollingFileAppender::new(
        Rotation::DAILY,
        "/var/log/my-app",
        "app.log"
    );
    
    // Stdout (å®¹å™¨ç¯å¢ƒï¼Œç”± Fluentd/Logstash æ”¶é›†)
    let stdout_layer = tracing_subscriber::fmt::layer()
        .json()
        .with_writer(std::io::stdout);
    
    // Loki (å¯é€‰)
    let loki_layer = tracing_loki::layer(
        tracing_loki::url::Url::parse("http://loki:3100").unwrap(),
        vec![
            ("service".to_string(), "my-service".to_string()),
            ("env".to_string(), "production".to_string()),
        ].into_iter().collect(),
        vec![].into_iter().collect(),
    ).unwrap();
    
    tracing_subscriber::registry()
        .with(stdout_layer)
        .with(loki_layer)
        .init();
}
```

### æ—¥å¿—æŸ¥è¯¢

```bash
# Loki æŸ¥è¯¢è¯­è¨€ (LogQL)

# æŸ¥æ‰¾é”™è¯¯
{service="my-app"} |= "ERROR"

# ç‰¹å®šç”¨æˆ·çš„è¯·æ±‚
{service="my-app"} | json | user_id="12345"

# æ…¢æŸ¥è¯¢
{service="my-app"} | json | duration > 1s

# èšåˆç»Ÿè®¡
sum(rate({service="my-app"} |= "ERROR"[5m])) by (error_type)
```

---

## æŒ‡æ ‡ç›‘æ§

### Prometheus é›†æˆ

```rust
use prometheus::{
    Encoder, TextEncoder,
    IntCounter, IntGauge, Histogram, HistogramOpts,
    register_int_counter, register_int_gauge, register_histogram,
};
use lazy_static::lazy_static;

lazy_static! {
    // è®¡æ•°å™¨: å•è°ƒé€’å¢
    pub static ref HTTP_REQUESTS_TOTAL: IntCounter = register_int_counter!(
        "http_requests_total",
        "Total number of HTTP requests"
    ).unwrap();
    
    // ä»ªè¡¨: å¯å¢å¯å‡
    pub static ref ACTIVE_CONNECTIONS: IntGauge = register_int_gauge!(
        "active_connections",
        "Number of active connections"
    ).unwrap();
    
    // ç›´æ–¹å›¾: åˆ†å¸ƒç»Ÿè®¡
    pub static ref HTTP_RESPONSE_TIME: Histogram = register_histogram!(
        "http_response_time_seconds",
        "HTTP response time in seconds",
        vec![0.001, 0.01, 0.1, 0.5, 1.0, 5.0]
    ).unwrap();
}

async fn handle_request(req: Request) -> Response {
    HTTP_REQUESTS_TOTAL.inc();
    ACTIVE_CONNECTIONS.inc();
    let timer = HTTP_RESPONSE_TIME.start_timer();
    
    let response = process(req).await;
    
    timer.observe_duration();
    ACTIVE_CONNECTIONS.dec();
    
    response
}

// Metrics ç«¯ç‚¹
async fn metrics_handler() -> impl Responder {
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = Vec::new();
    encoder.encode(&metric_families, &mut buffer).unwrap();
    
    HttpResponse::Ok()
        .content_type("text/plain; version=0.0.4")
        .body(buffer)
}
```

### RED æ–¹æ³•

**Rate, Errors, Duration**ï¼š

```rust
use prometheus::{HistogramVec, IntCounterVec};

lazy_static! {
    // Rate: è¯·æ±‚é€Ÿç‡
    static ref HTTP_REQUESTS: IntCounterVec = register_int_counter_vec!(
        "http_requests_total",
        "Total HTTP requests",
        &["method", "endpoint", "status"]
    ).unwrap();
    
    // Errors: é”™è¯¯ç‡
    static ref HTTP_ERRORS: IntCounterVec = register_int_counter_vec!(
        "http_errors_total",
        "Total HTTP errors",
        &["method", "endpoint", "error_type"]
    ).unwrap();
    
    // Duration: å“åº”æ—¶é—´
    static ref HTTP_DURATION: HistogramVec = register_histogram_vec!(
        "http_request_duration_seconds",
        "HTTP request duration",
        &["method", "endpoint"],
        vec![0.001, 0.01, 0.1, 0.5, 1.0, 5.0, 10.0]
    ).unwrap();
}

async fn observe_request<F, Fut>(
    method: &str,
    endpoint: &str,
    handler: F,
) -> Result<Response>
where
    F: FnOnce() -> Fut,
    Fut: Future<Output = Result<Response>>,
{
    let timer = HTTP_DURATION
        .with_label_values(&[method, endpoint])
        .start_timer();
    
    match handler().await {
        Ok(response) => {
            HTTP_REQUESTS
                .with_label_values(&[method, endpoint, &response.status().as_str()])
                .inc();
            timer.observe_duration();
            Ok(response)
        }
        Err(e) => {
            HTTP_ERRORS
                .with_label_values(&[method, endpoint, e.type_name()])
                .inc();
            timer.observe_duration();
            Err(e)
        }
    }
}
```

### è‡ªå®šä¹‰æŒ‡æ ‡

```rust
// ä¸šåŠ¡æŒ‡æ ‡
lazy_static! {
    // æ”¯ä»˜æˆåŠŸç‡
    static ref PAYMENT_SUCCESS: IntCounter = register_int_counter!(
        "payments_success_total",
        "Successful payments"
    ).unwrap();
    
    static ref PAYMENT_FAILED: IntCounter = register_int_counter!(
        "payments_failed_total",
        "Failed payments"
    ).unwrap();
    
    // è´­ç‰©è½¦å¤§å°åˆ†å¸ƒ
    static ref CART_SIZE: Histogram = register_histogram!(
        "cart_size_items",
        "Number of items in cart",
        vec![1.0, 5.0, 10.0, 20.0, 50.0]
    ).unwrap();
    
    // æ´»è·ƒç”¨æˆ·
    static ref ACTIVE_USERS: IntGauge = register_int_gauge!(
        "active_users",
        "Number of active users"
    ).unwrap();
}
```

### å‘Šè­¦è§„åˆ™

```yaml
# prometheus_rules.yml
groups:
  - name: my_app_alerts
    interval: 10s
    rules:
      # é«˜é”™è¯¯ç‡
      - alert: HighErrorRate
        expr: |
          sum(rate(http_errors_total[5m])) 
          / sum(rate(http_requests_total[5m])) > 0.05
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }}"
      
      # æ…¢å“åº”
      - alert: SlowResponseTime
        expr: |
          histogram_quantile(0.95, 
            rate(http_request_duration_seconds_bucket[5m])
          ) > 1.0
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "95th percentile response time > 1s"
      
      # æœåŠ¡å®•æœº
      - alert: ServiceDown
        expr: up{job="my-app"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service {{ $labels.instance }} is down"
```

---

## åˆ†å¸ƒå¼è¿½è¸ª

### OpenTelemetry

```rust
use opentelemetry::{global, sdk::trace as sdktrace, trace::Tracer};
use opentelemetry_otlp::WithExportConfig;

pub fn init_tracing() -> Result<()> {
    // OTLP å¯¼å‡ºå™¨
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(
            opentelemetry_otlp::new_exporter()
                .tonic()
                .with_endpoint("http://jaeger:4317")
        )
        .with_trace_config(
            sdktrace::config()
                .with_resource(opentelemetry::sdk::Resource::new(vec![
                    opentelemetry::KeyValue::new("service.name", "my-service"),
                    opentelemetry::KeyValue::new("service.version", "1.0.0"),
                ]))
        )
        .install_batch(opentelemetry::runtime::Tokio)?;
    
    global::set_tracer_provider(tracer);
    
    Ok(())
}
```

### Jaeger é›†æˆ

```rust
use tracing_opentelemetry::OpenTelemetrySpanExt;

#[instrument]
async fn fetch_user_data(user_id: u64) -> Result<User> {
    let span = tracing::Span::current();
    span.set_attribute("user_id", user_id.to_string());
    
    // æ•°æ®åº“æŸ¥è¯¢
    let user = {
        let _db_span = info_span!("database_query", db.table = "users");
        db.query_user(user_id).await?
    };
    
    // å¤–éƒ¨ API è°ƒç”¨
    let profile = {
        let _api_span = info_span!("external_api", api.endpoint = "profile");
        api_client.fetch_profile(user_id).await?
    };
    
    Ok(User { user, profile })
}
```

### Span è®¾è®¡

```rust
use tracing::{info_span, Instrument};

async fn process_order(order_id: Uuid) -> Result<()> {
    // æ ¹ Span
    async {
        info!(order_id = %order_id, "Processing order");
        
        // å­ Span 1: éªŒè¯
        validate_order(order_id)
            .instrument(info_span!("validate", step = "validation"))
            .await?;
        
        // å­ Span 2: æ”¯ä»˜
        process_payment(order_id)
            .instrument(info_span!("payment", 
                payment.gateway = "stripe",
                payment.method = "card"
            ))
            .await?;
        
        // å­ Span 3: å‘è´§
        schedule_shipment(order_id)
            .instrument(info_span!("shipment",
                shipment.carrier = "fedex"
            ))
            .await?;
        
        Ok(())
    }
    .instrument(info_span!("process_order", order_id = %order_id))
    .await
}
```

### æ€§èƒ½åˆ†æ

```rust
// ä½¿ç”¨ Span è¿›è¡Œæ€§èƒ½åˆ†æ
use tracing::{info_span, instrument};
use std::time::Instant;

#[instrument]
async fn analyze_performance() {
    let start = Instant::now();
    
    // æ“ä½œ1
    let span1 = info_span!("database_queries");
    let _enter1 = span1.enter();
    let db_result = fetch_from_db().await;
    drop(_enter1);
    tracing::info!(elapsed_ms = start.elapsed().as_millis(), "DB queries completed");
    
    // æ“ä½œ2
    let span2 = info_span!("cache_operations");
    let _enter2 = span2.enter();
    let cache_result = fetch_from_cache().await;
    drop(_enter2);
    tracing::info!(elapsed_ms = start.elapsed().as_millis(), "Cache ops completed");
    
    tracing::info!(total_ms = start.elapsed().as_millis(), "Analysis complete");
}
```

---

## é”™è¯¯è¿½è¸ª

### Sentry é›†æˆ

```rust
use sentry;

pub fn init_error_tracking() {
    let _guard = sentry::init((
        "https://key@sentry.io/project",
        sentry::ClientOptions {
            release: Some(env!("CARGO_PKG_VERSION").into()),
            environment: Some("production".into()),
            traces_sample_rate: 0.1,
            ..Default::default()
        },
    ));
    
    // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
    std::panic::set_hook(Box::new(|panic_info| {
        sentry::integrations::panic::panic_to_sentry(panic_info);
    }));
}

async fn risky_operation() -> Result<()> {
    sentry::with_scope(
        |scope| {
            scope.set_tag("operation", "risky");
            scope.set_user(Some(sentry::User {
                id: Some("12345".into()),
                email: Some("user@example.com".into()),
                ..Default::default()
            }));
        },
        || async {
            // æ“ä½œä»£ç 
        },
    ).await
}
```

### è‡ªå®šä¹‰é”™è¯¯ä¸Šä¸‹æ–‡

```rust
use sentry::{capture_message, Level};

async fn handle_payment(payment_id: Uuid, amount: Decimal) -> Result<()> {
    match charge_card(payment_id, amount).await {
        Ok(_) => Ok(()),
        Err(e) => {
            // æ•è·è¯¦ç»†ä¸Šä¸‹æ–‡
            sentry::configure_scope(|scope| {
                scope.set_context("payment", sentry::protocol::Context::from(json!({
                    "payment_id": payment_id.to_string(),
                    "amount": amount.to_string(),
                    "timestamp": chrono::Utc::now().to_rfc3339(),
                })));
                
                scope.set_extra("card_last4", "1234".into());
                scope.set_fingerprint(vec!["payment-error", &e.to_string()]);
            });
            
            sentry::capture_error(&e);
            Err(e)
        }
    }
}
```

### é”™è¯¯åˆ†ç»„

```rust
// ä½¿ç”¨ fingerprint æ§åˆ¶é”™è¯¯åˆ†ç»„
pub fn set_error_fingerprint(error: &Error) {
    let fingerprint = match error {
        Error::Database(ref e) => {
            vec!["database-error", e.code()]
        }
        Error::Network(ref e) => {
            vec!["network-error", e.kind().as_str()]
        }
        Error::Business(ref e) => {
            vec!["business-error", e.category()]
        }
        _ => vec!["unknown-error"],
    };
    
    sentry::configure_scope(|scope| {
        scope.set_fingerprint(Some(&fingerprint));
    });
}
```

---

## æ€§èƒ½åˆ†æ1

### CPU Profiling

```rust
// ä½¿ç”¨ pprof è¿›è¡Œåœ¨çº¿ profiling
use pprof::ProfilerGuard;

// åœ¨åº”ç”¨å¯åŠ¨æ—¶
let guard = ProfilerGuard::new(100).unwrap();

// æä¾› HTTP ç«¯ç‚¹
async fn profiling_endpoint() -> Result<Vec<u8>> {
    let report = guard.report().build().unwrap();
    let mut body = Vec::new();
    report.flamegraph(&mut body)?;
    Ok(body)
}
```

### å†…å­˜åˆ†æ

```rust
// ä½¿ç”¨ jemalloc + profiling
#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;

#[cfg(feature = "profiling")]
use jemalloc_ctl::{stats, epoch};

async fn memory_stats() -> Result<MemoryStats> {
    epoch::mib()?.advance()?;
    
    let allocated = stats::allocated::mib()?.read()?;
    let resident = stats::resident::mib()?.read()?;
    
    Ok(MemoryStats {
        allocated_bytes: allocated,
        resident_bytes: resident,
    })
}
```

### å®æ—¶åˆ†æ

```rust
// å®šæœŸæ”¶é›†è¿è¡Œæ—¶ç»Ÿè®¡
use tokio::time::{interval, Duration};

pub async fn runtime_monitor() {
    let mut interval = interval(Duration::from_secs(60));
    
    loop {
        interval.tick().await;
        
        // æ”¶é›† Tokio è¿è¡Œæ—¶ç»Ÿè®¡
        let metrics = tokio::runtime::Handle::current().metrics();
        
        info!(
            workers = metrics.num_workers(),
            blocking_threads = metrics.num_blocking_threads(),
            "Runtime metrics"
        );
    }
}
```

---

## å¥åº·æ£€æŸ¥

### ç«¯ç‚¹è®¾è®¡

```rust
use axum::{Router, Json};
use serde::Serialize;

#[derive(Serialize)]
struct HealthStatus {
    status: String,
    version: String,
    uptime: u64,
    checks: Vec<Check>,
}

#[derive(Serialize)]
struct Check {
    name: String,
    status: String,
    message: Option<String>,
}

async fn health_check() -> Json<HealthStatus> {
    let mut checks = vec![];
    
    // æ£€æŸ¥æ•°æ®åº“
    checks.push(check_database().await);
    
    // æ£€æŸ¥ Redis
    checks.push(check_redis().await);
    
    // æ£€æŸ¥å¤–éƒ¨ API
    checks.push(check_external_api().await);
    
    let all_healthy = checks.iter().all(|c| c.status == "healthy");
    
    Json(HealthStatus {
        status: if all_healthy { "healthy" } else { "degraded" }.to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
        uptime: get_uptime(),
        checks,
    })
}

async fn check_database() -> Check {
    match db_pool.acquire().await {
        Ok(_) => Check {
            name: "database".to_string(),
            status: "healthy".to_string(),
            message: None,
        },
        Err(e) => Check {
            name: "database".to_string(),
            status: "unhealthy".to_string(),
            message: Some(e.to_string()),
        },
    }
}
```

### ä¾èµ–æ£€æŸ¥

```rust
// å¯åŠ¨æ—¶æ£€æŸ¥æ‰€æœ‰ä¾èµ–
pub async fn startup_checks() -> Result<()> {
    info!("Running startup checks...");
    
    // 1. æ•°æ®åº“è¿æ¥
    db_pool.acquire().await
        .context("Database connection failed")?;
    info!("âœ“ Database connection OK");
    
    // 2. Redis è¿æ¥
    redis_client.ping().await
        .context("Redis connection failed")?;
    info!("âœ“ Redis connection OK");
    
    // 3. S3 è®¿é—®
    s3_client.head_bucket("my-bucket").await
        .context("S3 access failed")?;
    info!("âœ“ S3 access OK");
    
    // 4. å¿…è¦é…ç½®
    ensure!(!CONFIG.secret_key.is_empty(), "SECRET_KEY not set");
    info!("âœ“ Configuration OK");
    
    info!("All startup checks passed");
    Ok(())
}
```

### ä¼˜é›…é™çº§

```rust
use std::sync::atomic::{AtomicBool, Ordering};

static CACHE_AVAILABLE: AtomicBool = AtomicBool::new(true);

async fn get_user(id: u64) -> Result<User> {
    // å°è¯•ä»ç¼“å­˜è·å–
    if CACHE_AVAILABLE.load(Ordering::Relaxed) {
        match cache.get(id).await {
            Ok(user) => return Ok(user),
            Err(e) => {
                warn!("Cache unavailable, falling back to DB: {}", e);
                CACHE_AVAILABLE.store(false, Ordering::Relaxed);
                
                // å¯åŠ¨æ¢å¤ä»»åŠ¡
                tokio::spawn(async {
                    tokio::time::sleep(Duration::from_secs(30)).await;
                    if cache.ping().await.is_ok() {
                        CACHE_AVAILABLE.store(true, Ordering::Relaxed);
                        info!("Cache recovered");
                    }
                });
            }
        }
    }
    
    // é™çº§åˆ°æ•°æ®åº“
    db.get_user(id).await
}
```

---

## é‡‘ä¸é›€éƒ¨ç½²

### æµé‡åˆ†é…

```rust
// ä½¿ç”¨ feature flag è¿›è¡Œæµé‡åˆ†é…
use launchdarkly_server_sdk::{Client, Context};

pub async fn route_request(req: Request) -> Response {
    let user_id = req.user_id();
    
    // æ„å»º LaunchDarkly context
    let context = Context::builder(user_id.to_string())
        .set_value("email", req.user_email().into())
        .build()
        .unwrap();
    
    // æ£€æŸ¥æ˜¯å¦è·¯ç”±åˆ°æ–°ç‰ˆæœ¬
    let use_new_version = ld_client
        .bool_variation(&context, "new-payment-flow", false)
        .await;
    
    if use_new_version {
        new_payment_handler(req).await
    } else {
        old_payment_handler(req).await
    }
}
```

### ç›‘æ§æŒ‡æ ‡

```rust
// ä¸ºé‡‘ä¸é›€éƒ¨ç½²æ·»åŠ ä¸“é—¨æŒ‡æ ‡
lazy_static! {
    static ref CANARY_REQUESTS: IntCounterVec = register_int_counter_vec!(
        "canary_requests_total",
        "Requests to canary version",
        &["version", "status"]
    ).unwrap();
    
    static ref CANARY_ERRORS: IntCounterVec = register_int_counter_vec!(
        "canary_errors_total",
        "Errors in canary version",
        &["version", "error_type"]
    ).unwrap();
}

async fn canary_handler(version: &str, req: Request) -> Result<Response> {
    let result = process(req).await;
    
    CANARY_REQUESTS
        .with_label_values(&[version, if result.is_ok() { "success" } else { "error" }])
        .inc();
    
    if let Err(ref e) = result {
        CANARY_ERRORS
            .with_label_values(&[version, e.type_name()])
            .inc();
    }
    
    result
}
```

### å›æ»šç­–ç•¥

```rust
// è‡ªåŠ¨å›æ»šé€»è¾‘
pub async fn monitor_canary_deployment() {
    let mut interval = interval(Duration::from_secs(10));
    
    loop {
        interval.tick().await;
        
        let error_rate = calculate_error_rate("canary").await;
        let baseline_error_rate = calculate_error_rate("stable").await;
        
        // å¦‚æœé‡‘ä¸é›€é”™è¯¯ç‡æ˜¾è‘—é«˜äºåŸºçº¿
        if error_rate > baseline_error_rate * 2.0 && error_rate > 0.05 {
            error!("Canary error rate too high: {}%, rolling back", error_rate * 100.0);
            
            // è§¦å‘å›æ»š
            rollback_deployment().await;
            
            // å‘é€å‘Šè­¦
            send_alert("Canary deployment rolled back due to high error rate").await;
            
            break;
        }
    }
}
```

---

## æ•…éšœæ’æŸ¥æµç¨‹

### é—®é¢˜å®šä½

```text
æ•…éšœæ’æŸ¥æ£€æŸ¥æ¸…å•
â”œâ”€ 1. æ”¶é›†ç—‡çŠ¶
â”‚  â”œâ”€ é”™è¯¯æ¶ˆæ¯
â”‚  â”œâ”€ å½±å“èŒƒå›´
â”‚  â”œâ”€ å¼€å§‹æ—¶é—´
â”‚  â””â”€ ç›¸å…³äº‹ä»¶ï¼ˆéƒ¨ç½²ã€é…ç½®å˜æ›´ï¼‰
â”œâ”€ 2. æ£€æŸ¥ç›‘æ§
â”‚  â”œâ”€ Metrics (Grafana)
â”‚  â”œâ”€ Logs (Loki/ELK)
â”‚  â”œâ”€ Traces (Jaeger)
â”‚  â””â”€ Errors (Sentry)
â”œâ”€ 3. å®šä½å±‚çº§
â”‚  â”œâ”€ è´Ÿè½½å‡è¡¡å™¨
â”‚  â”œâ”€ åº”ç”¨æœåŠ¡å™¨
â”‚  â”œâ”€ æ•°æ®åº“
â”‚  â”œâ”€ ç¼“å­˜
â”‚  â””â”€ å¤–éƒ¨ä¾èµ–
â”œâ”€ 4. å½¢æˆå‡è®¾
â”‚  â””â”€ åŸºäºæ•°æ®ï¼Œè€ŒéçŒœæµ‹
â””â”€ 5. éªŒè¯å‡è®¾
   â””â”€ é€æ­¥æ’é™¤
```

### æ ¹å› åˆ†æ

```rust
// 5 Whys åˆ†ææ³•

// é—®é¢˜: ç”¨æˆ·æ— æ³•ç™»å½•
// 
// Why 1: ä¸ºä»€ä¹ˆç”¨æˆ·æ— æ³•ç™»å½•ï¼Ÿ
// â†’ å› ä¸ºè®¤è¯æœåŠ¡è¿”å› 500 é”™è¯¯
//
// Why 2: ä¸ºä»€ä¹ˆè®¤è¯æœåŠ¡è¿”å› 500ï¼Ÿ
// â†’ å› ä¸ºæ•°æ®åº“æŸ¥è¯¢è¶…æ—¶
//
// Why 3: ä¸ºä»€ä¹ˆæ•°æ®åº“æŸ¥è¯¢è¶…æ—¶ï¼Ÿ
// â†’ å› ä¸ºè¿æ¥æ± è€—å°½
//
// Why 4: ä¸ºä»€ä¹ˆè¿æ¥æ± è€—å°½ï¼Ÿ
// â†’ å› ä¸ºæŸäº›æŸ¥è¯¢æ²¡æœ‰æ­£ç¡®é‡Šæ”¾è¿æ¥
//
// Why 5: ä¸ºä»€ä¹ˆæŸ¥è¯¢æ²¡æœ‰é‡Šæ”¾è¿æ¥ï¼Ÿ
// â†’ å› ä¸ºé”™è¯¯å¤„ç†è·¯å¾„ä¸­å¿˜è®°è°ƒç”¨ drop()
//
// æ ¹å› : é”™è¯¯å¤„ç†ä¸å½“å¯¼è‡´è¿æ¥æ³„æ¼

// ä¿®å¤
async fn query_with_proper_cleanup() -> Result<User> {
    let conn = pool.acquire().await?;
    
    let result = sqlx::query_as("SELECT * FROM users WHERE id = ?")
        .bind(user_id)
        .fetch_one(&mut *conn)  // &mut *conn ç¡®ä¿ Drop è¢«è°ƒç”¨
        .await;
    
    // å³ä½¿å‡ºé”™ï¼Œconn ä¹Ÿä¼šè¢« drop
    result
}
```

### ä¿®å¤éªŒè¯

```rust
// ä¿®å¤åéªŒè¯æµç¨‹
pub async fn verify_fix() -> Result<()> {
    info!("Verifying fix...");
    
    // 1. åŠŸèƒ½æµ‹è¯•
    let test_result = run_smoke_tests().await?;
    ensure!(test_result.all_passed(), "Smoke tests failed");
    
    // 2. ç›‘æ§æ£€æŸ¥
    tokio::time::sleep(Duration::from_secs(60)).await;
    let error_rate = calculate_error_rate("production").await;
    ensure!(error_rate < 0.01, "Error rate still high");
    
    // 3. æ€§èƒ½æ£€æŸ¥
    let p95_latency = get_p95_latency().await;
    ensure!(p95_latency < Duration::from_millis(500), "Latency still high");
    
    info!("Fix verified successfully");
    Ok(())
}
```

---

## å¸¸è§ç”Ÿäº§é—®é¢˜

### å†…å­˜æ³„æ¼

**ç—‡çŠ¶**:

- å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿
- OOM Killer ç»ˆæ­¢è¿›ç¨‹
- æ€§èƒ½é€æ¸ä¸‹é™

**æ’æŸ¥**:

```bash
# 1. æŸ¥çœ‹å†…å­˜è¶‹åŠ¿
kubectl top pods

# 2. è·å–å †å¿«ç…§
curl http://pod-ip:9090/debug/pprof/heap > heap.prof

# 3. åˆ†æ
go tool pprof heap.prof
```

**å¸¸è§åŸå› **:

```rust
// âŒ å¿˜è®°æ¸…ç†è®¢é˜…
lazy_static! {
    static ref SUBSCRIBERS: Mutex<Vec<Sender>> = Mutex::new(vec![]);
}

// âœ… ä½¿ç”¨å¼±å¼•ç”¨
use std::sync::Weak;

lazy_static! {
    static ref SUBSCRIBERS: Mutex<Vec<Weak<Sender>>> = Mutex::new(vec![]);
}

// å®šæœŸæ¸…ç†
fn cleanup_subscribers() {
    SUBSCRIBERS.lock().unwrap().retain(|s| s.upgrade().is_some());
}
```

### CPU é«˜è´Ÿè½½

**ç—‡çŠ¶**:

- CPU ä½¿ç”¨ç‡ > 80%
- å“åº”æ—¶é—´å¢åŠ 
- è¯·æ±‚æ’é˜Ÿ

**æ’æŸ¥**:

```bash
# 1. ç«ç„°å›¾
cargo flamegraph --pid $(pgrep my-app)

# 2. Top å‘½ä»¤
top -H -p $(pgrep my-app)

# 3. Perf
perf top -p $(pgrep my-app)
```

**å¸¸è§åŸå› **:

```rust
// âŒ å¿™ç­‰å¾…
loop {
    if condition {
        break;
    }
}

// âœ… ä½¿ç”¨å¼‚æ­¥ç­‰å¾…
while !condition {
    tokio::time::sleep(Duration::from_millis(100)).await;
}

// âŒ ä¸å¿…è¦çš„å…‹éš†
for item in large_vec.clone() {
    process(item);
}

// âœ… ä½¿ç”¨å¼•ç”¨
for item in &large_vec {
    process(item);
}
```

### è¿æ¥æ± è€—å°½

**ç—‡çŠ¶**:

- è·å–è¿æ¥è¶…æ—¶
- å¤§é‡ "connection pool timeout" é”™è¯¯

**æ’æŸ¥**:

```rust
// ç›‘æ§è¿æ¥æ± çŠ¶æ€
async fn monitor_pool() {
    loop {
        tokio::time::sleep(Duration::from_secs(10)).await;
        
        let stats = pool.status();
        warn!(
            "Pool: size={}, idle={}, waiting={}",
            stats.size, stats.idle, stats.waiting
        );
        
        if stats.waiting > 10 {
            error!("Connection pool exhausted!");
        }
    }
}
```

**è§£å†³æ–¹æ¡ˆ**:

```rust
// 1. å¢åŠ æ± å¤§å°
let pool = PgPoolOptions::new()
    .max_connections(50)  // å¢åŠ 
    .acquire_timeout(Duration::from_secs(5))
    .connect(&database_url)
    .await?;

// 2. ä½¿ç”¨è¶…æ—¶
let conn = tokio::time::timeout(
    Duration::from_secs(5),
    pool.acquire()
).await??;

// 3. ç¡®ä¿è¿æ¥é‡Šæ”¾
async fn query() -> Result<()> {
    let mut conn = pool.acquire().await?;
    let result = sqlx::query("SELECT 1")
        .fetch_one(&mut *conn)
        .await?;
    // conn è‡ªåŠ¨ drop
    Ok(())
}
```

### æ­»é”ä¸æ´»é”

**ç—‡çŠ¶**:

- è¯·æ±‚hangä½
- æ— é”™è¯¯æ—¥å¿—
- CPU å¯èƒ½å¾ˆä½

**æ’æŸ¥**:

```rust
// ä½¿ç”¨ parking_lot çš„æ­»é”æ£€æµ‹
use parking_lot::deadlock;

fn start_deadlock_detector() {
    std::thread::spawn(move || {
        loop {
            std::thread::sleep(Duration::from_secs(1));
            let deadlocks = deadlock::check_deadlock();
            if !deadlocks.is_empty() {
                error!("{} deadlocks detected", deadlocks.len());
                for (i, threads) in deadlocks.iter().enumerate() {
                    error!("Deadlock #{}", i);
                    for t in threads {
                        error!("Thread {:?}\n{:?}", t.thread_id(), t.backtrace());
                    }
                }
            }
        }
    });
}
```

**è§£å†³æ–¹æ¡ˆ**:

```rust
// âŒ é”é¡ºåºä¸ä¸€è‡´
let lock1 = mutex1.lock();
let lock2 = mutex2.lock();  // å¯èƒ½æ­»é”

// âœ… å§‹ç»ˆæŒ‰ç›¸åŒé¡ºåºè·å–é”
fn acquire_locks<T, U>(
    mutex1: &Mutex<T>,
    mutex2: &Mutex<U>
) -> (MutexGuard<T>, MutexGuard<U>) {
    let (first, second) = if mutex1.data_ptr() < mutex2.data_ptr() {
        (mutex1, mutex2)
    } else {
        (mutex2, mutex1)
    };
    // ...
}
```

---

## åº”æ€¥å“åº”

### äº‹æ•…åˆ†çº§

| çº§åˆ« | æè¿° | å“åº”æ—¶é—´ | ç¤ºä¾‹ |
|------|------|---------|------|
| **P0** | æ ¸å¿ƒæœåŠ¡å®Œå…¨ä¸å¯ç”¨ | ç«‹å³ (5åˆ†é’Ÿ) | ç½‘ç«™å®•æœºã€æ”¯ä»˜å¤±è´¥ |
| **P1** | æ ¸å¿ƒåŠŸèƒ½ä¸¥é‡å—æŸ | ç´§æ€¥ (30åˆ†é’Ÿ) | æ€§èƒ½ä¸¥é‡ä¸‹é™ã€éƒ¨åˆ†ç”¨æˆ·æ— æ³•è®¿é—® |
| **P2** | éæ ¸å¿ƒåŠŸèƒ½æ•…éšœ | é«˜ä¼˜å…ˆçº§ (2å°æ—¶) | é‚®ä»¶å‘é€å¤±è´¥ã€æŠ¥è¡¨é”™è¯¯ |
| **P3** | å°é—®é¢˜æˆ–è¯·æ±‚ | æ­£å¸¸ (1å¤©) | UI bugã€æ—¥å¿—é”™è¯¯ |

### å“åº”æµç¨‹

```text
äº‹æ•…å“åº” Runbook
â”œâ”€ 1. ç¡®è®¤ (5åˆ†é’Ÿå†…)
â”‚  â”œâ”€ ç¡®è®¤é—®é¢˜å­˜åœ¨
â”‚  â”œâ”€ è¯„ä¼°å½±å“èŒƒå›´
â”‚  â””â”€ ç¡®å®šäº‹æ•…çº§åˆ«
â”œâ”€ 2. é€šçŸ¥ (ç«‹å³)
â”‚  â”œâ”€ é€šçŸ¥ç›¸å…³å›¢é˜Ÿ
â”‚  â”œâ”€ å»ºç«‹æ²Ÿé€šæ¸ é“ (Slack/Teams)
â”‚  â””â”€ åˆ†é…äº‹æ•…æŒ‡æŒ¥å®˜
â”œâ”€ 3. ç¼“è§£ (ç›®æ ‡: 15-30åˆ†é’Ÿ)
â”‚  â”œâ”€ å›æ»šéƒ¨ç½² (é¦–é€‰)
â”‚  â”œâ”€ åˆ‡æ¢æµé‡
â”‚  â”œâ”€ æ‰©å®¹èµ„æº
â”‚  â””â”€ å¯ç”¨é™çº§æ–¹æ¡ˆ
â”œâ”€ 4. ç›‘æ§
â”‚  â”œâ”€ éªŒè¯ç¼“è§£æªæ–½
â”‚  â”œâ”€ æŒç»­ç›‘æ§æŒ‡æ ‡
â”‚  â””â”€ æ›´æ–°çŠ¶æ€é¡µ
â”œâ”€ 5. ä¿®å¤
â”‚  â”œâ”€ æ ¹å› åˆ†æ
â”‚  â”œâ”€ å®æ–½æ°¸ä¹…ä¿®å¤
â”‚  â””â”€ ä»£ç å®¡æŸ¥
â””â”€ 6. å¤ç›˜
   â”œâ”€ äº‹æ•…æŠ¥å‘Š
   â”œâ”€ æ”¹è¿›æªæ–½
   â””â”€ æµç¨‹æ›´æ–°
```

### äº‹åå¤ç›˜

```markdown
# äº‹æ•…æŠ¥å‘Šæ¨¡æ¿

## åŸºæœ¬ä¿¡æ¯
- **äº‹æ•…ID**: INC-2025-001
- **å‘ç”Ÿæ—¶é—´**: 2025-10-20 14:30 UTC
- **æ¢å¤æ—¶é—´**: 2025-10-20 15:15 UTC
- **æŒç»­æ—¶é—´**: 45åˆ†é’Ÿ
- **äº‹æ•…çº§åˆ«**: P1

## å½±å“
- **å—å½±å“ç”¨æˆ·**: çº¦ 10,000 ç”¨æˆ· (20%)
- **ä¸šåŠ¡å½±å“**: æ”¯ä»˜å¤±è´¥ç‡ 100%
- **è´¢åŠ¡å½±å“**: ä¼°è®¡æŸå¤± $5,000

## æ—¶é—´çº¿
- 14:30 - éƒ¨ç½²æ–°ç‰ˆæœ¬ v1.2.0
- 14:35 - æ”¯ä»˜é”™è¯¯å‘Šè­¦è§¦å‘
- 14:40 - äº‹æ•…ç¡®è®¤ï¼Œå¼€å§‹è°ƒæŸ¥
- 14:50 - è¯†åˆ«ä¸ºæ•°æ®åº“è¿æ¥æ± é…ç½®é”™è¯¯
- 15:00 - å›æ»šåˆ° v1.1.9
- 15:15 - æœåŠ¡å®Œå…¨æ¢å¤

## æ ¹æœ¬åŸå› 
v1.2.0 ä¸­æ•°æ®åº“è¿æ¥æ± æœ€å¤§è¿æ¥æ•°ä» 50 é™ä½åˆ° 10ï¼Œ
å¯¼è‡´é«˜å³°æœŸè¿æ¥æ± è€—å°½ã€‚

## ç¼“è§£æªæ–½
1. ç«‹å³å›æ»šåˆ° v1.1.9
2. é‡å¯æ‰€æœ‰å®ä¾‹æ¸…ç†è¿æ¥

## æ°¸ä¹…ä¿®å¤
1. âœ… æ¢å¤è¿æ¥æ± é…ç½®åˆ° 50
2. âœ… æ·»åŠ è¿æ¥æ± æŒ‡æ ‡ç›‘æ§
3. âœ… åœ¨ staging ç¯å¢ƒè¿›è¡Œè´Ÿè½½æµ‹è¯•
4. âœ… æ›´æ–°éƒ¨ç½²æ£€æŸ¥æ¸…å•

## æ”¹è¿›è¡ŒåŠ¨é¡¹
1. [ ] å®æ–½è‡ªåŠ¨åŒ–é…ç½®éªŒè¯ (Owner: @team-sre, Due: 2025-10-27)
2. [ ] æ·»åŠ è¿æ¥æ± å‘Šè­¦ (Owner: @team-platform, Due: 2025-10-25)
3. [ ] æ›´æ–°å˜æ›´å®¡æŸ¥æµç¨‹ (Owner: @team-lead, Due: 2025-10-22)

## ç»éªŒæ•™è®­
**What went well**:
- å¿«é€Ÿæ£€æµ‹åˆ°é—®é¢˜
- å›æ»šæµç¨‹é¡ºåˆ©

**What went wrong**:
- é…ç½®å˜æ›´æœªå……åˆ†æµ‹è¯•
- ç¼ºå°‘è¿æ¥æ± ç›‘æ§

**What got lucky**:
- å‘ç”Ÿåœ¨éé«˜å³°æ—¶æ®µ
```

---

## å®‰å…¨è°ƒè¯•

### æ•æ„Ÿä¿¡æ¯è„±æ•

```rust
use tracing::field::Visit;

// è‡ªåŠ¨è„±æ•æ•æ„Ÿå­—æ®µ
#[derive(Debug)]
struct SensitiveData {
    user_id: u64,
    email: String,
    
    #[sensitive]  // è‡ªå®šä¹‰å±æ€§
    password: String,
    
    #[sensitive]
    credit_card: String,
}

impl std::fmt::Display for SensitiveData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SensitiveData {{ user_id: {}, email: {}, password: [REDACTED], credit_card: [REDACTED] }}",
            self.user_id, self.email)
    }
}

// æ—¥å¿—è„±æ•è¿‡æ»¤å™¨
pub fn redact_sensitive_info(message: &str) -> String {
    let patterns = vec![
        (r"password[:=]\s*\S+", "password: [REDACTED]"),
        (r"\b\d{16}\b", "[CARD_REDACTED]"),  // ä¿¡ç”¨å¡å·
        (r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b", "[EMAIL_REDACTED]"),
    ];
    
    let mut result = message.to_string();
    for (pattern, replacement) in patterns {
        result = regex::Regex::new(pattern).unwrap()
            .replace_all(&result, replacement)
            .to_string();
    }
    result
}
```

### è®¿é—®æ§åˆ¶

```rust
// å®¡è®¡æ—¥å¿—è®¿é—®
#[derive(Debug)]
struct AuditLog {
    user: String,
    action: String,
    resource: String,
    timestamp: DateTime<Utc>,
    result: Result<(), String>,
}

async fn access_sensitive_data(
    user: &User,
    resource_id: Uuid,
) -> Result<Data> {
    // æ£€æŸ¥æƒé™
    ensure!(user.has_permission("read:sensitive"), "Access denied");
    
    // è®°å½•å®¡è®¡æ—¥å¿—
    audit_log.record(AuditLog {
        user: user.email.clone(),
        action: "read_sensitive_data".to_string(),
        resource: resource_id.to_string(),
        timestamp: Utc::now(),
        result: Ok(()),
    }).await;
    
    // æ‰§è¡Œæ“ä½œ
    fetch_sensitive_data(resource_id).await
}
```

### å®¡è®¡æ—¥å¿—

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct SecurityEvent {
    event_type: String,
    user_id: Option<u64>,
    ip_address: String,
    user_agent: String,
    action: String,
    resource: String,
    success: bool,
    timestamp: DateTime<Utc>,
}

impl SecurityEvent {
    pub async fn log(&self) {
        // å†™å…¥ä¸“é—¨çš„å®‰å…¨æ—¥å¿—
        let json = serde_json::to_string(self).unwrap();
        
        // 1. æœ¬åœ°æ—¥å¿—
        info!(target: "security_audit", "{}", json);
        
        // 2. SIEM ç³»ç»Ÿ
        siem_client.send_event(self).await.ok();
        
        // 3. åˆè§„å­˜å‚¨ (ä¸å¯å˜)
        compliance_storage.append(self).await.ok();
    }
}
```

---

## å·¥å…·é›†æˆ

### Kubernetes

```bash
# æŸ¥çœ‹ Pod æ—¥å¿—
kubectl logs -f pod-name -c container-name

# æŸ¥çœ‹å‰ä¸€ä¸ªå®ä¾‹çš„æ—¥å¿— (å¦‚æœ crashed)
kubectl logs pod-name --previous

# è¿›å…¥å®¹å™¨
kubectl exec -it pod-name -- bash

# Port forward
kubectl port-forward pod-name 8080:8080

# æŸ¥çœ‹äº‹ä»¶
kubectl get events --sort-by='.lastTimestamp'

# è°ƒè¯• Pod
kubectl debug pod-name -it --image=busybox --target=container-name
```

### Docker

```bash
# æŸ¥çœ‹å®¹å™¨æ—¥å¿—
docker logs -f container-id

# è¿›å…¥å®¹å™¨
docker exec -it container-id bash

# æŸ¥çœ‹å®¹å™¨ç»Ÿè®¡
docker stats container-id

# æŸ¥çœ‹å®¹å™¨è¯¦æƒ…
docker inspect container-id
```

### Cloud Provider

**AWS CloudWatch**:

```bash
# æŸ¥è¯¢æ—¥å¿—
aws logs filter-log-events \
  --log-group-name /aws/lambda/my-function \
  --start-time $(date -d '1 hour ago' +%s)000 \
  --filter-pattern "ERROR"
```

**GCP Logging**:

```bash
# æŸ¥è¯¢æ—¥å¿—
gcloud logging read "resource.type=k8s_container" \
  --limit 100 \
  --format json
```

---

## æœ€ä½³å®è·µ

### è®¾è®¡é˜¶æ®µ

- âœ… å¯è§‚æµ‹æ€§ä¼˜å…ˆï¼šä»è®¾è®¡ä¹‹åˆå°±è€ƒè™‘å¦‚ä½•è°ƒè¯•
- âœ… å¹‚ç­‰æ€§ï¼šæ‰€æœ‰æ“ä½œåº”è¯¥æ˜¯å¹‚ç­‰çš„
- âœ… è¶…æ—¶å¤„ç†ï¼šæ‰€æœ‰å¤–éƒ¨è°ƒç”¨å¿…é¡»æœ‰è¶…æ—¶
- âœ… é‡è¯•ç­–ç•¥ï¼šå®ç°æŒ‡æ•°é€€é¿é‡è¯•

### å¼€å‘é˜¶æ®µ

- âœ… ç»“æ„åŒ–æ—¥å¿—ï¼šä½¿ç”¨ `tracing`ï¼Œä¸æ˜¯ `println!`
- âœ… æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯ï¼šåŒ…å«ä¸Šä¸‹æ–‡
- âœ… è¯·æ±‚IDï¼šè·¨æœåŠ¡è¿½è¸ª
- âœ… æŒ‡æ ‡åŸ‹ç‚¹ï¼šå…³é”®è·¯å¾„éƒ½è¦æœ‰æŒ‡æ ‡

### éƒ¨ç½²é˜¶æ®µ

- âœ… é‡‘ä¸é›€éƒ¨ç½²ï¼šé€æ­¥æ¨å‡ºæ–°ç‰ˆæœ¬
- âœ… è“ç»¿éƒ¨ç½²ï¼šå¿«é€Ÿå›æ»šèƒ½åŠ›
- âœ… Feature Flagï¼šè¿è¡Œæ—¶æ§åˆ¶åŠŸèƒ½
- âœ… å¥åº·æ£€æŸ¥ï¼šè®©è´Ÿè½½å‡è¡¡å™¨çŸ¥é“æœåŠ¡çŠ¶æ€

### è¿ç»´é˜¶æ®µ

- âœ… ç›‘æ§å‘Šè­¦ï¼šä¸»åŠ¨å‘ç°é—®é¢˜
- âœ… Runbookï¼šå¸¸è§é—®é¢˜å¤„ç†æ‰‹å†Œ
- âœ… å®šæœŸæ¼”ç»ƒï¼šChaos Engineering
- âœ… äº‹åå¤ç›˜ï¼šæŒç»­æ”¹è¿›

---

## æ€»ç»“

ç”Ÿäº§ç¯å¢ƒè°ƒè¯•çš„æ ¸å¿ƒåŸåˆ™ï¼š

### 1. å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±

- **æ—¥å¿—**: è®°å½•å‘ç”Ÿäº†ä»€ä¹ˆ
- **æŒ‡æ ‡**: å‘Šè¯‰ä½ ç³»ç»Ÿå¥åº·çŠ¶å†µ
- **è¿½è¸ª**: æ˜¾ç¤ºè¯·æ±‚å®Œæ•´è·¯å¾„

### 2. å…³é”®å®è·µ

- ç»“æ„åŒ–æ—¥å¿— (tracing)
- RED æŒ‡æ ‡ (Prometheus)
- åˆ†å¸ƒå¼è¿½è¸ª (OpenTelemetry)
- é”™è¯¯è¿½è¸ª (Sentry)

### 3. åº”æ€¥å“åº”

- å¿«é€Ÿæ¢å¤ > æ·±å…¥åˆ†æ
- å›æ»šä¼˜å…ˆ
- æ²Ÿé€šé€æ˜
- äº‹åå¤ç›˜

### 4. æŒç»­æ”¹è¿›

- ç›‘æ§ä½ å…³å¿ƒçš„
- å‘Šè­¦å¯æ“ä½œçš„
- æ–‡æ¡£åŒ–ç»éªŒ
- è‡ªåŠ¨åŒ–æµç¨‹

---

## ç›¸å…³èµ„æº

- [rust-debugging.md](./rust-debugging.md) - Rust è°ƒè¯•å®Œæ•´æŒ‡å—
- [debugging-tools.md](./debugging-tools.md) - è°ƒè¯•å·¥å…·ç”Ÿæ€
- [Google SRE Book](https://sre.google/books/)
- [Observability Engineering](https://www.oreilly.com/library/view/observability-engineering/9781492076438/)
- [OpenTelemetry Docs](https://opentelemetry.io/docs/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025-10-20  
**ç»´æŠ¤è€…**: C13 Reliability Team
