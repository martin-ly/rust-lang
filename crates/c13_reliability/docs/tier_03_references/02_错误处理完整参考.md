# é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ

**æœ€åæ›´æ–°**: 2025-10-24  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦**: â­â­â­

---

## ğŸ“‹ ç›®å½•

- [é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ](#é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Result ç±»å‹è¯¦è§£](#1-result-ç±»å‹è¯¦è§£)
    - [1.1 åŸºæœ¬å®šä¹‰](#11-åŸºæœ¬å®šä¹‰)
    - [1.2 Result æ–¹æ³•](#12-result-æ–¹æ³•)
    - [1.3 ç»„åˆå™¨æ¨¡å¼](#13-ç»„åˆå™¨æ¨¡å¼)
  - [2. Error Trait å®Œæ•´ API](#2-error-trait-å®Œæ•´-api)
    - [2.1 Error Trait å®šä¹‰](#21-error-trait-å®šä¹‰)
    - [2.2 æ ‡å‡†é”™è¯¯ç±»å‹](#22-æ ‡å‡†é”™è¯¯ç±»å‹)
    - [2.3 å®ç° Error Trait](#23-å®ç°-error-trait)
  - [3. é”™è¯¯ä¼ æ’­æœºåˆ¶](#3-é”™è¯¯ä¼ æ’­æœºåˆ¶)
    - [3.1 ? æ“ä½œç¬¦](#31--æ“ä½œç¬¦)
    - [3.2 From/Into è½¬æ¢](#32-frominto-è½¬æ¢)
    - [3.3 è‡ªåŠ¨ç±»å‹è½¬æ¢](#33-è‡ªåŠ¨ç±»å‹è½¬æ¢)
  - [4. è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#4-è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [4.1 ç®€å•é”™è¯¯æšä¸¾](#41-ç®€å•é”™è¯¯æšä¸¾)
    - [4.2 ä½¿ç”¨ thiserror](#42-ä½¿ç”¨-thiserror)
    - [4.3 é”™è¯¯ä¸Šä¸‹æ–‡](#43-é”™è¯¯ä¸Šä¸‹æ–‡)
  - [5. anyhow é”™è¯¯å¤„ç†](#5-anyhow-é”™è¯¯å¤„ç†)
    - [5.1 åŸºæœ¬ä½¿ç”¨](#51-åŸºæœ¬ä½¿ç”¨)
    - [5.2 æ·»åŠ ä¸Šä¸‹æ–‡](#52-æ·»åŠ ä¸Šä¸‹æ–‡)
    - [5.3 é”™è¯¯é“¾](#53-é”™è¯¯é“¾)
  - [6. Panic å¤„ç†ç­–ç•¥](#6-panic-å¤„ç†ç­–ç•¥)
    - [6.1 Panic æœºåˆ¶](#61-panic-æœºåˆ¶)
    - [6.2 æ•è· Panic](#62-æ•è·-panic)
    - [6.3 Panic Hook](#63-panic-hook)
  - [7. é”™è¯¯å¤„ç†æ¨¡å¼](#7-é”™è¯¯å¤„ç†æ¨¡å¼)
    - [7.1 å¤šå±‚é”™è¯¯ä¼ æ’­](#71-å¤šå±‚é”™è¯¯ä¼ æ’­)
    - [7.2 é”™è¯¯è½¬æ¢](#72-é”™è¯¯è½¬æ¢)
    - [7.3 é”™è¯¯æ¢å¤](#73-é”™è¯¯æ¢å¤)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 åº“ vs åº”ç”¨](#81-åº“-vs-åº”ç”¨)
    - [8.2 é”™è¯¯ä¿¡æ¯è®¾è®¡](#82-é”™è¯¯ä¿¡æ¯è®¾è®¡)
    - [8.3 æ€§èƒ½è€ƒé‡](#83-æ€§èƒ½è€ƒé‡)
  - [9. å¸¸è§é”™è¯¯æ¨¡å¼](#9-å¸¸è§é”™è¯¯æ¨¡å¼)
    - [9.1 I/O é”™è¯¯](#91-io-é”™è¯¯)
    - [9.2 è§£æé”™è¯¯](#92-è§£æé”™è¯¯)
    - [9.3 éªŒè¯é”™è¯¯](#93-éªŒè¯é”™è¯¯)
  - [10. è°ƒè¯•ä¸æ•…éšœæ’æŸ¥](#10-è°ƒè¯•ä¸æ•…éšœæ’æŸ¥)
    - [10.1 é”™è¯¯ä¿¡æ¯è¿½è¸ª](#101-é”™è¯¯ä¿¡æ¯è¿½è¸ª)
    - [10.2 Backtrace](#102-backtrace)
  - [11. API é€ŸæŸ¥è¡¨](#11-api-é€ŸæŸ¥è¡¨)
    - [11.1 Result æ–¹æ³•](#111-result-æ–¹æ³•)
    - [11.2 Error Trait æ–¹æ³•](#112-error-trait-æ–¹æ³•)

---

## 1. Result ç±»å‹è¯¦è§£

### 1.1 åŸºæœ¬å®šä¹‰

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**åŸºæœ¬ä½¿ç”¨**:

```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

// ä½¿ç”¨
match divide(10, 2) {
    Ok(result) => println!("Result: {}", result),
    Err(e) => eprintln!("Error: {}", e),
}
```

---

### 1.2 Result æ–¹æ³•

**æ£€æŸ¥æ–¹æ³•**:

```rust
let result: Result<i32, &str> = Ok(42);

// æ£€æŸ¥æ˜¯å¦æˆåŠŸ
assert!(result.is_ok());
assert!(!result.is_err());

// æ£€æŸ¥å¹¶è·å–å¼•ç”¨
assert_eq!(result.as_ref(), Ok(&42));

// è½¬æ¢ä¸º Option
assert_eq!(result.ok(), Some(42));
assert_eq!(result.err(), None);
```

**è½¬æ¢æ–¹æ³•**:

```rust
let result: Result<i32, &str> = Ok(42);

// map: è½¬æ¢æˆåŠŸå€¼
let doubled = result.map(|x| x * 2);
assert_eq!(doubled, Ok(84));

// map_err: è½¬æ¢é”™è¯¯å€¼
let result: Result<i32, &str> = Err("error");
let mapped = result.map_err(|e| format!("Error: {}", e));
assert_eq!(mapped, Err("Error: error".to_string()));

// and_then: é“¾å¼æ“ä½œ
let result = Ok(42)
    .and_then(|x| Ok(x * 2))
    .and_then(|x| Ok(x + 1));
assert_eq!(result, Ok(85));

// or_else: é”™è¯¯æ¢å¤
let result: Result<i32, &str> = Err("error");
let recovered = result.or_else(|_| Ok(0));
assert_eq!(recovered, Ok(0));
```

**å±•å¼€æ–¹æ³•**:

```rust
// unwrap: æˆåŠŸè¿”å›å€¼ï¼Œé”™è¯¯ panic
let value = Ok(42).unwrap();
// Err("error").unwrap(); // panic!

// unwrap_or: æä¾›é»˜è®¤å€¼
let value = Err("error").unwrap_or(0);
assert_eq!(value, 0);

// unwrap_or_else: è®¡ç®—é»˜è®¤å€¼
let value = Err("error").unwrap_or_else(|_| 42);
assert_eq!(value, 42);

// unwrap_or_default: ä½¿ç”¨ç±»å‹é»˜è®¤å€¼
let value: i32 = Err("error").unwrap_or_default();
assert_eq!(value, 0);

// expect: å¸¦è‡ªå®šä¹‰æ¶ˆæ¯çš„ unwrap
let value = Ok(42).expect("Should have a value");
```

---

### 1.3 ç»„åˆå™¨æ¨¡å¼

```rust
// å¤šä¸ª Result ç»„åˆ
fn process() -> Result<i32, String> {
    let a = read_number()?;
    let b = read_number()?;
    let result = divide(a, b)?;
    Ok(result * 2)
}

// ä½¿ç”¨ and ç»„åˆ
let result = Ok(42).and(Ok(100));
assert_eq!(result, Ok(100));

// ä½¿ç”¨ or ç»„åˆ
let result: Result<i32, &str> = Err("error1").or(Err("error2"));
assert_eq!(result, Err("error2"));

// flatten: å±•å¹³åµŒå¥— Result
let nested: Result<Result<i32, &str>, &str> = Ok(Ok(42));
let flattened = nested.flatten();
assert_eq!(flattened, Ok(42));
```

---

## 2. Error Trait å®Œæ•´ API

### 2.1 Error Trait å®šä¹‰

```rust
pub trait Error: Debug + Display {
    // è·å–é”™è¯¯æºï¼ˆå¯é€‰ï¼‰
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
    
    // è·å–ç±»å‹ IDï¼ˆä¸ç¨³å®šï¼‰
    fn type_id(&self, _: private::Internal) -> TypeId where Self: 'static {
        TypeId::of::<Self>()
    }
    
    // è·å– backtraceï¼ˆä¸ç¨³å®šï¼‰
    fn provide<'a>(&'a self, request: &mut Request<'a>) {}
}
```

---

### 2.2 æ ‡å‡†é”™è¯¯ç±»å‹

**å¸¸è§æ ‡å‡†åº“é”™è¯¯**:

```rust
use std::io;
use std::num;
use std::str;
use std::fmt;

// I/O é”™è¯¯
let err: io::Error = io::Error::new(io::ErrorKind::NotFound, "File not found");

// è§£æé”™è¯¯
let err: num::ParseIntError = "abc".parse::<i32>().unwrap_err();

// UTF-8 é”™è¯¯
let err: str::Utf8Error = str::from_utf8(&[0xFF]).unwrap_err();

// æ ¼å¼åŒ–é”™è¯¯
let err: fmt::Error = fmt::Error;
```

---

### 2.3 å®ç° Error Trait

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError {
    message: String,
    source: Option<Box<dyn Error>>,
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MyError: {}", self.message)
    }
}

impl Error for MyError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        self.source.as_ref().map(|e| e.as_ref())
    }
}

// ä½¿ç”¨
fn example() -> Result<(), MyError> {
    Err(MyError {
        message: "Something went wrong".to_string(),
        source: None,
    })
}
```

---

## 3. é”™è¯¯ä¼ æ’­æœºåˆ¶

### 3.1 ? æ“ä½œç¬¦

```rust
// ? æ“ä½œç¬¦å±•å¼€
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = std::fs::File::open(path)?;  // é”™è¯¯ç›´æ¥è¿”å›
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// ç­‰ä»·äº
fn read_file_manual(path: &str) -> Result<String, std::io::Error> {
    let mut file = match std::fs::File::open(path) {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}
```

---

### 3.2 From/Into è½¬æ¢

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

// å®ç° From trait å¯ç”¨ ? è‡ªåŠ¨è½¬æ¢
impl From<io::Error> for MyError {
    fn from(err: io::Error) -> Self {
        MyError::Io(err)
    }
}

impl From<ParseIntError> for MyError {
    fn from(err: ParseIntError) -> Self {
        MyError::Parse(err)
    }
}

// ä½¿ç”¨
fn process() -> Result<i32, MyError> {
    let content = std::fs::read_to_string("file.txt")?;  // io::Error è‡ªåŠ¨è½¬æ¢
    let number = content.trim().parse()?;  // ParseIntError è‡ªåŠ¨è½¬æ¢
    Ok(number)
}
```

---

### 3.3 è‡ªåŠ¨ç±»å‹è½¬æ¢

```rust
// Box<dyn Error> å¯æ¥å—ä»»ä½•é”™è¯¯
fn flexible_error() -> Result<(), Box<dyn std::error::Error>> {
    std::fs::read_to_string("file.txt")?;  // io::Error
    "123abc".parse::<i32>()?;  // ParseIntError
    Ok(())
}

// ä½¿ç”¨ anyhow::Error æ›´çµæ´»
use anyhow::Result;

fn anyhow_example() -> Result<()> {
    std::fs::read_to_string("file.txt")?;
    "123abc".parse::<i32>()?;
    Ok(())
}
```

---

## 4. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### 4.1 ç®€å•é”™è¯¯æšä¸¾

```rust
use std::fmt;

#[derive(Debug)]
enum AppError {
    NotFound,
    InvalidInput(String),
    DatabaseError(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::NotFound => write!(f, "Resource not found"),
            AppError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "Database error: {}", msg),
        }
    }
}

impl std::error::Error for AppError {}
```

---

### 4.2 ä½¿ç”¨ thiserror

**Cargo.toml**:

```toml
[dependencies]
thiserror = "1.0"
```

**å®šä¹‰é”™è¯¯**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DataStoreError {
    #[error("data store disconnected")]
    Disconnect(#[from] io::Error),
    
    #[error("the data for key `{0}` is not available")]
    Redaction(String),
    
    #[error("invalid header (expected {expected:?}, found {found:?})")]
    InvalidHeader {
        expected: String,
        found: String,
    },
    
    #[error("unknown data store error")]
    Unknown,
}

// ä½¿ç”¨
fn example() -> Result<(), DataStoreError> {
    Err(DataStoreError::Redaction("secret_key".to_string()))
}
```

**é€æ˜é”™è¯¯ä¼ æ’­**:

```rust
#[derive(Error, Debug)]
enum MyError {
    #[error(transparent)]
    IoError(#[from] std::io::Error),
    
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}
```

---

### 4.3 é”™è¯¯ä¸Šä¸‹æ–‡

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum ConfigError {
    #[error("failed to read config file: {path}")]
    ReadError {
        path: String,
        #[source]
        source: std::io::Error,
    },
    
    #[error("failed to parse config at line {line}")]
    ParseError {
        line: usize,
        #[source]
        source: toml::de::Error,
    },
}

// ä½¿ç”¨
fn load_config(path: &str) -> Result<Config, ConfigError> {
    let content = std::fs::read_to_string(path)
        .map_err(|source| ConfigError::ReadError {
            path: path.to_string(),
            source,
        })?;
    
    let config = toml::from_str(&content)
        .map_err(|source| ConfigError::ParseError {
            line: 0,  // å®é™…åº”è§£ææº
            source,
        })?;
    
    Ok(config)
}
```

---

## 5. anyhow é”™è¯¯å¤„ç†

### 5.1 åŸºæœ¬ä½¿ç”¨

**Cargo.toml**:

```toml
[dependencies]
anyhow = "1.0"
```

**ç®€åŒ–é”™è¯¯å¤„ç†**:

```rust
use anyhow::{Result, Context, bail, ensure, anyhow};

// æ›¿ä»£ Result<T, Box<dyn Error>>
fn process() -> Result<String> {
    let path = "config.toml";
    let content = std::fs::read_to_string(path)?;
    Ok(content)
}

// æŠ›å‡ºè‡ªå®šä¹‰é”™è¯¯
fn check_value(x: i32) -> Result<()> {
    if x < 0 {
        bail!("Value cannot be negative: {}", x);
    }
    Ok(())
}

// æ–­è¨€é£æ ¼
fn validate(x: i32) -> Result<()> {
    ensure!(x > 0, "Value must be positive");
    ensure!(x < 100, "Value must be less than 100");
    Ok(())
}

// åˆ›å»ºé”™è¯¯
fn create_error() -> Result<()> {
    Err(anyhow!("Something went wrong"))
}
```

---

### 5.2 æ·»åŠ ä¸Šä¸‹æ–‡

```rust
use anyhow::{Context, Result};

fn load_config() -> Result<Config> {
    let path = "config.toml";
    
    let content = std::fs::read_to_string(path)
        .context("Failed to read config file")?;
    
    let config: Config = toml::from_str(&content)
        .with_context(|| format!("Failed to parse config from {}", path))?;
    
    Ok(config)
}

// é”™è¯¯è¾“å‡º:
// Error: Failed to parse config from config.toml
// 
// Caused by:
//     TOML parse error at line 3, column 5
//     |
//   3 | value = "invalid
//     |         ^^^^^^^^
//     unexpected end of file
```

---

### 5.3 é”™è¯¯é“¾

```rust
use anyhow::Result;

fn inner() -> Result<()> {
    Err(anyhow::anyhow!("Inner error"))
}

fn middle() -> Result<()> {
    inner().context("Middle layer")?;
    Ok(())
}

fn outer() -> Result<()> {
    middle().context("Outer layer")?;
    Ok(())
}

fn main() {
    if let Err(e) = outer() {
        eprintln!("Error: {:?}", e);
        
        // éå†é”™è¯¯é“¾
        for cause in e.chain() {
            eprintln!("  Caused by: {}", cause);
        }
    }
}

// è¾“å‡º:
// Error: Outer layer
//   Caused by: Middle layer
//   Caused by: Inner error
```

---

## 6. Panic å¤„ç†ç­–ç•¥

### 6.1 Panic æœºåˆ¶

```rust
// è§¦å‘ panic
fn will_panic() {
    panic!("Something went wrong!");
}

// æ¡ä»¶ panic
fn check_value(x: i32) {
    assert!(x > 0, "x must be positive, got {}", x);
    assert_eq!(x, 42, "x must be 42");
    assert_ne!(x, 0, "x cannot be 0");
}

// unreachable! å®
fn process_status(status: Status) {
    match status {
        Status::Ok => println!("OK"),
        Status::Error => println!("Error"),
        // å¦‚æœç¡®ä¿¡ä¸ä¼šåˆ°è¾¾
        _ => unreachable!("Unexpected status"),
    }
}

// unimplemented! å®
fn future_feature() {
    unimplemented!("This will be implemented later");
}
```

---

### 6.2 æ•è· Panic

```rust
use std::panic;

fn may_panic() {
    panic!("Oops!");
}

// æ•è· panic
fn safe_call() -> Result<(), String> {
    let result = panic::catch_unwind(|| {
        may_panic();
    });
    
    match result {
        Ok(_) => Ok(()),
        Err(e) => {
            if let Some(s) = e.downcast_ref::<&str>() {
                Err(format!("Panic: {}", s))
            } else {
                Err("Unknown panic".to_string())
            }
        }
    }
}

// è®¾ç½® panic è¡Œä¸º
panic::set_hook(Box::new(|panic_info| {
    eprintln!("Custom panic handler: {:?}", panic_info);
}));
```

---

### 6.3 Panic Hook

```rust
use std::panic;

fn setup_panic_handler() {
    let default_hook = panic::take_hook();
    
    panic::set_hook(Box::new(move |panic_info| {
        // è®°å½•åˆ°æ—¥å¿—
        log::error!("Panic occurred: {:?}", panic_info);
        
        // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
        send_to_monitoring(panic_info);
        
        // è°ƒç”¨é»˜è®¤ hook
        default_hook(panic_info);
    }));
}

// ç”Ÿäº§ç¯å¢ƒ panic å¤„ç†
fn production_panic_handler(info: &panic::PanicInfo) {
    let location = info.location().map(|l| {
        format!("{}:{}:{}", l.file(), l.line(), l.column())
    }).unwrap_or_else(|| "unknown".to_string());
    
    let message = if let Some(s) = info.payload().downcast_ref::<&str>() {
        s.to_string()
    } else if let Some(s) = info.payload().downcast_ref::<String>() {
        s.clone()
    } else {
        "Unknown panic message".to_string()
    };
    
    eprintln!("PANIC at {}: {}", location, message);
}
```

---

## 7. é”™è¯¯å¤„ç†æ¨¡å¼

### 7.1 å¤šå±‚é”™è¯¯ä¼ æ’­

```rust
// Repository å±‚
mod repository {
    use thiserror::Error;
    
    #[derive(Error, Debug)]
    pub enum RepositoryError {
        #[error("database error")]
        Database(#[from] sqlx::Error),
        
        #[error("not found")]
        NotFound,
    }
    
    pub fn find_user(id: i32) -> Result<User, RepositoryError> {
        // ...
    }
}

// Service å±‚
mod service {
    use thiserror::Error;
    use super::repository::RepositoryError;
    
    #[derive(Error, Debug)]
    pub enum ServiceError {
        #[error("repository error")]
        Repository(#[from] RepositoryError),
        
        #[error("validation error: {0}")]
        Validation(String),
    }
    
    pub fn get_user(id: i32) -> Result<User, ServiceError> {
        let user = repository::find_user(id)?;
        
        if !user.is_active {
            return Err(ServiceError::Validation("User is inactive".to_string()));
        }
        
        Ok(user)
    }
}

// Controller å±‚
mod controller {
    use super::service::ServiceError;
    
    pub enum HttpError {
        NotFound,
        BadRequest(String),
        Internal(String),
    }
    
    impl From<ServiceError> for HttpError {
        fn from(err: ServiceError) -> Self {
            match err {
                ServiceError::Repository(RepositoryError::NotFound) => 
                    HttpError::NotFound,
                ServiceError::Validation(msg) => 
                    HttpError::BadRequest(msg),
                _ => HttpError::Internal(err.to_string()),
            }
        }
    }
}
```

---

### 7.2 é”™è¯¯è½¬æ¢

```rust
// ä½¿ç”¨ ? å’Œ From trait
fn convert_example() -> Result<String, MyError> {
    let bytes = std::fs::read("file.txt")?;  // io::Error -> MyError
    let text = String::from_utf8(bytes)?;    // FromUtf8Error -> MyError
    Ok(text)
}

// æ‰‹åŠ¨è½¬æ¢
fn manual_convert() -> Result<String, MyError> {
    let bytes = std::fs::read("file.txt")
        .map_err(|e| MyError::Io(e))?;
    
    let text = String::from_utf8(bytes)
        .map_err(|e| MyError::Utf8(e.utf8_error()))?;
    
    Ok(text)
}
```

---

### 7.3 é”™è¯¯æ¢å¤

```rust
// æä¾›é»˜è®¤å€¼
fn with_default() -> String {
    std::fs::read_to_string("config.toml")
        .unwrap_or_else(|_| "default config".to_string())
}

// é‡è¯•æœºåˆ¶
fn with_retry<F, T, E>(mut f: F, max_retries: usize) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        match f() {
            Ok(val) => return Ok(val),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                std::thread::sleep(std::time::Duration::from_millis(100 * attempts as u64));
            }
            Err(e) => return Err(e),
        }
    }
}

// é™çº§å¤„ç†
fn with_fallback() -> Result<Data, MyError> {
    // å°è¯•ä¸»æ•°æ®æº
    if let Ok(data) = fetch_from_primary() {
        return Ok(data);
    }
    
    // å°è¯•å¤‡ä»½æ•°æ®æº
    if let Ok(data) = fetch_from_backup() {
        return Ok(data);
    }
    
    // ä½¿ç”¨ç¼“å­˜
    if let Ok(data) = fetch_from_cache() {
        return Ok(data);
    }
    
    Err(MyError::AllSourcesFailed)
}
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 åº“ vs åº”ç”¨

**åº“å¼€å‘**:

```rust
// âœ… æä¾›å…·ä½“çš„é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub enum LibraryError {
    #[error("invalid input: {0}")]
    InvalidInput(String),
    
    #[error("operation failed")]
    OperationFailed,
}

// âœ… ä¸ä½¿ç”¨ panicï¼ˆé™¤äº†ä¸å¯æ¢å¤é”™è¯¯ï¼‰
pub fn process(input: &str) -> Result<Output, LibraryError> {
    // ...
}

// âŒ ä¸è¦åœ¨åº“ä¸­ä½¿ç”¨ unwrap/expect
// let x = some_operation().unwrap(); // åå®è·µ
```

**åº”ç”¨å¼€å‘**:

```rust
// âœ… å¯ä»¥ä½¿ç”¨ anyhow ç®€åŒ–
use anyhow::Result;

fn main() -> Result<()> {
    let config = load_config()?;
    let data = fetch_data()?;
    process(config, data)?;
    Ok(())
}

// âœ… main å‡½æ•°å¯ä»¥è¿”å› Result
// å¤±è´¥æ—¶ä¼šæ‰“å°é”™è¯¯å¹¶è¿”å›éé›¶é€€å‡ºç 

// âœ… å¯ä»¥é€‚åº¦ä½¿ç”¨ expect
let value = env::var("REQUIRED_VAR")
    .expect("REQUIRED_VAR must be set");
```

---

### 8.2 é”™è¯¯ä¿¡æ¯è®¾è®¡

```rust
// âŒ ä¸å¥½ï¼šä¿¡æ¯ä¸è¶³
Err("Failed")

// âœ… å¥½ï¼šæä¾›ä¸Šä¸‹æ–‡
Err(format!("Failed to parse config at line {}: {}", line, details))

// âŒ ä¸å¥½ï¼šè¿‡äºæŠ€æœ¯åŒ–
Err("ENOENT: no such file or directory")

// âœ… å¥½ï¼šç”¨æˆ·å‹å¥½
Err(format!("Configuration file not found at: {}", path))

// âœ… æœ€ä½³ï¼šç»“æ„åŒ–é”™è¯¯
#[derive(Error, Debug)]
#[error("Failed to load configuration from {path}")]
struct ConfigLoadError {
    path: String,
    #[source]
    source: std::io::Error,
}
```

---

### 8.3 æ€§èƒ½è€ƒé‡

```rust
// Result æ˜¯é›¶æˆæœ¬æŠ½è±¡
// âœ… ä¸æ¯”æ‰‹åŠ¨é”™è¯¯å¤„ç†æ…¢
fn with_result() -> Result<i32, String> {
    if condition {
        Ok(42)
    } else {
        Err("error".to_string())
    }
}

// âš ï¸ é¿å…åœ¨çƒ­è·¯å¾„åˆ›å»ºé”™è¯¯å¯¹è±¡
fn hot_path() -> Result<i32, String> {
    // âŒ æ¯æ¬¡éƒ½åˆ›å»º String
    if x < 0 {
        return Err(format!("Negative value: {}", x));
    }
    
    // âœ… ä½¿ç”¨é™æ€å­—ç¬¦ä¸²
    if x < 0 {
        return Err("Negative value");
    }
    
    Ok(x)
}

// âœ… ä½¿ç”¨ error æšä¸¾ï¼ˆæ— å †åˆ†é…ï¼‰
#[derive(Error, Debug)]
enum FastError {
    #[error("negative value")]
    Negative,
    
    #[error("too large")]
    TooLarge,
}
```

---

## 9. å¸¸è§é”™è¯¯æ¨¡å¼

### 9.1 I/O é”™è¯¯

```rust
use std::io::{self, Read, Write};
use std::fs::File;

fn read_file_safe(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// å¸¦ä¸Šä¸‹æ–‡çš„ I/O é”™è¯¯
fn read_with_context(path: &str) -> anyhow::Result<String> {
    let contents = std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read file: {}", path))?;
    Ok(contents)
}
```

---

### 9.2 è§£æé”™è¯¯

```rust
use std::num::ParseIntError;

fn parse_config(text: &str) -> Result<Config, ConfigError> {
    let lines: Vec<&str> = text.lines().collect();
    
    let port = lines.get(0)
        .ok_or(ConfigError::MissingField("port"))?
        .parse::<u16>()
        .map_err(|e| ConfigError::InvalidPort(e))?;
    
    let timeout = lines.get(1)
        .ok_or(ConfigError::MissingField("timeout"))?
        .parse::<u64>()
        .map_err(|e| ConfigError::InvalidTimeout(e))?;
    
    Ok(Config { port, timeout })
}
```

---

### 9.3 éªŒè¯é”™è¯¯

```rust
#[derive(Error, Debug)]
enum ValidationError {
    #[error("field {field} is required")]
    Required { field: String },
    
    #[error("field {field} must be between {min} and {max}")]
    OutOfRange { field: String, min: i32, max: i32 },
    
    #[error("field {field} has invalid format")]
    InvalidFormat { field: String },
}

fn validate_user(user: &User) -> Result<(), ValidationError> {
    if user.name.is_empty() {
        return Err(ValidationError::Required {
            field: "name".to_string(),
        });
    }
    
    if user.age < 0 || user.age > 150 {
        return Err(ValidationError::OutOfRange {
            field: "age".to_string(),
            min: 0,
            max: 150,
        });
    }
    
    Ok(())
}
```

---

## 10. è°ƒè¯•ä¸æ•…éšœæ’æŸ¥

### 10.1 é”™è¯¯ä¿¡æ¯è¿½è¸ª

```rust
use anyhow::Context;

fn trace_error_chain() {
    match dangerous_operation() {
        Ok(_) => println!("Success"),
        Err(e) => {
            eprintln!("Error: {}", e);
            
            // æ‰“å°å®Œæ•´é”™è¯¯é“¾
            for (i, cause) in e.chain().enumerate() {
                eprintln!("  {}: {}", i, cause);
            }
            
            // Debug æ ¼å¼ï¼ˆåŒ…å« backtraceï¼‰
            eprintln!("\nDebug: {:?}", e);
        }
    }
}
```

---

### 10.2 Backtrace

```rust
use std::backtrace::Backtrace;

#[derive(Debug)]
struct DetailedError {
    message: String,
    backtrace: Backtrace,
}

impl DetailedError {
    fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            backtrace: Backtrace::capture(),
        }
    }
}

// å¯ç”¨ backtrace
// RUST_BACKTRACE=1 cargo run

// anyhow è‡ªåŠ¨æ”¯æŒ backtrace
use anyhow::Result;

fn with_backtrace() -> Result<()> {
    Err(anyhow::anyhow!("Error with backtrace"))
}
```

---

## 11. API é€ŸæŸ¥è¡¨

### 11.1 Result æ–¹æ³•

| æ–¹æ³• | ç­¾å | è¯´æ˜ |
|------|------|------|
| `is_ok()` | `&self -> bool` | æ£€æŸ¥æ˜¯å¦æˆåŠŸ |
| `is_err()` | `&self -> bool` | æ£€æŸ¥æ˜¯å¦å¤±è´¥ |
| `ok()` | `self -> Option<T>` | è½¬æ¢ä¸º Option |
| `err()` | `self -> Option<E>` | è·å–é”™è¯¯ä¸º Option |
| `map()` | `self, F -> Result<U, E>` | è½¬æ¢æˆåŠŸå€¼ |
| `map_err()` | `self, F -> Result<T, F>` | è½¬æ¢é”™è¯¯å€¼ |
| `and_then()` | `self, F -> Result<U, E>` | é“¾å¼æ“ä½œ |
| `or_else()` | `self, F -> Result<T, F>` | é”™è¯¯æ¢å¤ |
| `unwrap()` | `self -> T` | å±•å¼€æˆ– panic |
| `unwrap_or()` | `self, T -> T` | å±•å¼€æˆ–é»˜è®¤å€¼ |
| `expect()` | `self, &str -> T` | å±•å¼€æˆ–å¸¦æ¶ˆæ¯ panic |

---

### 11.2 Error Trait æ–¹æ³•

| æ–¹æ³• | ç­¾å | è¯´æ˜ |
|------|------|------|
| `source()` | `&self -> Option<&dyn Error>` | è·å–åº•å±‚é”™è¯¯ |
| `to_string()` | `&self -> String` | Display å®ç° |
| `type_id()` | `&self -> TypeId` | ç±»å‹ IDï¼ˆä¸ç¨³å®šï¼‰ |

---

**ç›¸å…³æ–‡æ¡£**:

- [æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ](./01_æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ.md)
- [ç›‘æ§å¯è§‚æµ‹æ€§å‚è€ƒ](./03_ç›‘æ§å¯è§‚æµ‹æ€§å‚è€ƒ.md)
- [Tier 2 é”™è¯¯å¤„ç†å®è·µ](../tier_02_guides/)
- [Tier 4 é«˜çº§é”™è¯¯å¤„ç†](../tier_04_advanced/)

---

**æœ€åæ›´æ–°**: 2025-10-24  
**è´¡çŒ®è€…**: Rust Documentation Team
