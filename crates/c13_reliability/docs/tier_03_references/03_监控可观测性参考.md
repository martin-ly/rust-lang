# ç›‘æ§ä¸å¯è§‚æµ‹æ€§å®Œæ•´å‚è€ƒ

**æœ€åæ›´æ–°**: 2025-10-24  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦**: â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [ç›‘æ§ä¸å¯è§‚æµ‹æ€§å®Œæ•´å‚è€ƒ](#ç›‘æ§ä¸å¯è§‚æµ‹æ€§å®Œæ•´å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ä¸‰å¤§æ”¯æŸ±æ¦‚è¿°](#1-ä¸‰å¤§æ”¯æŸ±æ¦‚è¿°)
    - [1.1 æ—¥å¿— (Logging)](#11-æ—¥å¿—-logging)
    - [1.2 æŒ‡æ ‡ (Metrics)](#12-æŒ‡æ ‡-metrics)
    - [1.3 è¿½è¸ª (Tracing)](#13-è¿½è¸ª-tracing)
  - [2. æ—¥å¿—æ¡†æ¶ (log/tracing)](#2-æ—¥å¿—æ¡†æ¶-logtracing)
    - [2.1 log crate åŸºç¡€](#21-log-crate-åŸºç¡€)
    - [2.2 env\_logger é…ç½®](#22-env_logger-é…ç½®)
    - [2.3 tracing æ¡†æ¶](#23-tracing-æ¡†æ¶)
    - [2.4 ç»“æ„åŒ–æ—¥å¿—](#24-ç»“æ„åŒ–æ—¥å¿—)
  - [3. æŒ‡æ ‡æ”¶é›† (metrics)](#3-æŒ‡æ ‡æ”¶é›†-metrics)
    - [3.1 metrics crate](#31-metrics-crate)
    - [3.2 Prometheus é›†æˆ](#32-prometheus-é›†æˆ)
    - [3.3 æŒ‡æ ‡ç±»å‹](#33-æŒ‡æ ‡ç±»å‹)
  - [4. åˆ†å¸ƒå¼è¿½è¸ª (OpenTelemetry)](#4-åˆ†å¸ƒå¼è¿½è¸ª-opentelemetry)
    - [4.1 åŸºæœ¬é…ç½®](#41-åŸºæœ¬é…ç½®)
    - [4.2 Span ç®¡ç†](#42-span-ç®¡ç†)
    - [4.3 ä¸Šä¸‹æ–‡ä¼ æ’­](#43-ä¸Šä¸‹æ–‡ä¼ æ’­)
  - [5. æ—¥å¿—æœ€ä½³å®è·µ](#5-æ—¥å¿—æœ€ä½³å®è·µ)
    - [5.1 æ—¥å¿—çº§åˆ«ä½¿ç”¨](#51-æ—¥å¿—çº§åˆ«ä½¿ç”¨)
    - [5.2 ç»“æ„åŒ–æ—¥å¿—](#52-ç»“æ„åŒ–æ—¥å¿—)
    - [5.3 æ•æ„Ÿä¿¡æ¯å¤„ç†](#53-æ•æ„Ÿä¿¡æ¯å¤„ç†)
  - [6. æŒ‡æ ‡æœ€ä½³å®è·µ](#6-æŒ‡æ ‡æœ€ä½³å®è·µ)
    - [6.1 å‘½åçº¦å®š](#61-å‘½åçº¦å®š)
    - [6.2 æ ‡ç­¾ä½¿ç”¨](#62-æ ‡ç­¾ä½¿ç”¨)
    - [6.3 æ€§èƒ½è€ƒé‡](#63-æ€§èƒ½è€ƒé‡)
  - [7. è¿½è¸ªæœ€ä½³å®è·µ](#7-è¿½è¸ªæœ€ä½³å®è·µ)
    - [7.1 Span è®¾è®¡](#71-span-è®¾è®¡)
    - [7.2 é‡‡æ ·ç­–ç•¥](#72-é‡‡æ ·ç­–ç•¥)
    - [7.3 å¼‚æ­¥è¿½è¸ª](#73-å¼‚æ­¥è¿½è¸ª)
  - [8. ç”Ÿäº§ç¯å¢ƒé›†æˆ](#8-ç”Ÿäº§ç¯å¢ƒé›†æˆ)
    - [8.1 å®Œæ•´ç¤ºä¾‹](#81-å®Œæ•´ç¤ºä¾‹)
    - [8.2 å¥åº·æ£€æŸ¥](#82-å¥åº·æ£€æŸ¥)
  - [9. æ•…éšœæ’æŸ¥](#9-æ•…éšœæ’æŸ¥)
    - [9.1 å¸¸è§é—®é¢˜](#91-å¸¸è§é—®é¢˜)
  - [10. API é€ŸæŸ¥è¡¨](#10-api-é€ŸæŸ¥è¡¨)
    - [10.1 æ—¥å¿—å®](#101-æ—¥å¿—å®)
    - [10.2 æŒ‡æ ‡API](#102-æŒ‡æ ‡api)
    - [10.3 è¿½è¸ªAPI](#103-è¿½è¸ªapi)

---

## 1. ä¸‰å¤§æ”¯æŸ±æ¦‚è¿°

### 1.1 æ—¥å¿— (Logging)

**å®šä¹‰**: è®°å½•ç¦»æ•£äº‹ä»¶ï¼ŒåŒ…å«æ—¶é—´æˆ³å’Œä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚

**ç”¨é€”**:

- é”™è¯¯è°ƒè¯•
- å®¡è®¡è¿½è¸ª
- ä¸šåŠ¡åˆ†æ

**ç¤ºä¾‹**:

```text
2025-10-24T10:30:45Z INFO User logged in: user_id=123
2025-10-24T10:30:46Z ERROR Database connection failed: timeout
```

---

### 1.2 æŒ‡æ ‡ (Metrics)

**å®šä¹‰**: å¯èšåˆçš„æ•°å€¼æ•°æ®ï¼Œç”¨äºç›‘æ§ç³»ç»ŸçŠ¶æ€ã€‚

**ç”¨é€”**:

- æ€§èƒ½ç›‘æ§
- å®¹é‡è§„åˆ’
- å‘Šè­¦è§¦å‘

**ç¤ºä¾‹**:

```text
http_requests_total{method="GET", status="200"} 1524
http_request_duration_seconds_bucket{le="0.1"} 234
```

---

### 1.3 è¿½è¸ª (Tracing)

**å®šä¹‰**: è·Ÿè¸ªè¯·æ±‚åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„æ‰§è¡Œè·¯å¾„ã€‚

**ç”¨é€”**:

- æ€§èƒ½åˆ†æ
- ä¾èµ–å…³ç³»
- ç“¶é¢ˆå®šä½

**ç¤ºä¾‹**:

```text
Trace ID: abc123
â”œâ”€ Span: HTTP Request (100ms)
â”‚  â”œâ”€ Span: Auth Check (10ms)
â”‚  â”œâ”€ Span: Database Query (60ms)
â”‚  â””â”€ Span: Response Marshal (30ms)
```

---

## 2. æ—¥å¿—æ¡†æ¶ (log/tracing)

### 2.1 log crate åŸºç¡€

**Cargo.toml**:

```toml
[dependencies]
log = "0.4"
env_logger = "0.11"
```

**åŸºæœ¬ä½¿ç”¨**:

```rust
use log::{trace, debug, info, warn, error};

fn main() {
    env_logger::init();
    
    trace!("Trace message");
    debug!("Debug message");
    info!("Info message");
    warn!("Warning message");
    error!("Error message");
}

// è¿è¡Œ: RUST_LOG=info cargo run
```

**å¸¦å‚æ•°çš„æ—¥å¿—**:

```rust
let user_id = 42;
let duration = 1.23;

info!("User {} logged in", user_id);
debug!("Request completed in {:.2}ms", duration);
error!("Failed to connect to {}:{}", host, port);

// ç»“æ„åŒ–å‚æ•°
info!(target: "auth", "Login attempt: user_id={}", user_id);
```

---

### 2.2 env_logger é…ç½®

**ç¯å¢ƒå˜é‡é…ç½®**:

```bash
# å…¨å±€çº§åˆ«
RUST_LOG=info cargo run

# æ¨¡å—çº§åˆ«
RUST_LOG=myapp=debug,hyper=info cargo run

# å¤šä¸ªæ¨¡å—
RUST_LOG=myapp::auth=debug,myapp::db=info cargo run

# å¤æ‚è¿‡æ»¤
RUST_LOG=warn,myapp=debug cargo run
```

**ç¨‹åºåŒ–é…ç½®**:

```rust
use env_logger::Builder;
use log::LevelFilter;

fn init_logger() {
    Builder::new()
        .filter_level(LevelFilter::Info)
        .filter_module("myapp::auth", LevelFilter::Debug)
        .filter_module("hyper", LevelFilter::Warn)
        .format_timestamp_millis()
        .init();
}
```

---

### 2.3 tracing æ¡†æ¶

**Cargo.toml**:

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

**åŸºæœ¬ä½¿ç”¨**:

```rust
use tracing::{trace, debug, info, warn, error, instrument};

fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!("Starting application");
    process_request(42);
}

#[instrument]
fn process_request(user_id: i32) {
    info!("Processing request");
    let result = perform_task();
    info!(result = ?result, "Task completed");
}

// è¾“å‡º:
// INFO starting application
// INFO process_request{user_id=42}: processing request
// INFO process_request{user_id=42}: task completed result=Ok(())
```

**Span å’Œ Event**:

```rust
use tracing::{span, Level};

fn handle_request() {
    let span = span!(Level::INFO, "request", method = "GET", path = "/api/users");
    let _enter = span.enter();
    
    // äº‹ä»¶è‡ªåŠ¨å…³è”åˆ°å½“å‰ span
    info!("Handling request");
    
    let user = fetch_user(42);
    info!(user_id = user.id, "User fetched");
}

// ç®€åŒ–å†™æ³•
#[instrument(fields(request_id = %uuid::Uuid::new_v4()))]
async fn handle_request_async() {
    info!("Request started");
    // ...
}
```

---

### 2.4 ç»“æ„åŒ–æ—¥å¿—

**ä½¿ç”¨ serde_json**:

```rust
use serde_json::json;
use tracing::info;

let event = json!({
    "event": "user_login",
    "user_id": 42,
    "ip": "192.168.1.1",
    "timestamp": chrono::Utc::now(),
});

info!(event = %event, "User event");

// JSON æ ¼å¼è®¢é˜…å™¨
use tracing_subscriber::fmt::format::FmtSpan;

tracing_subscriber::fmt()
    .json()
    .with_span_events(FmtSpan::CLOSE)
    .init();
```

---

## 3. æŒ‡æ ‡æ”¶é›† (metrics)

### 3.1 metrics crate

**Cargo.toml**:

```toml
[dependencies]
metrics = "0.21"
metrics-exporter-prometheus = "0.13"
```

**åŸºæœ¬ä½¿ç”¨**:

```rust
use metrics::{counter, gauge, histogram};

fn handle_request() {
    // è®¡æ•°å™¨ï¼šç´¯åŠ 
    counter!("http_requests_total", "method" => "GET", "status" => "200").increment(1);
    
    // ä»ªè¡¨ç›˜ï¼šè®¾ç½®å€¼
    gauge!("active_connections").set(42.0);
    
    // ç›´æ–¹å›¾ï¼šè®°å½•åˆ†å¸ƒ
    histogram!("http_request_duration_seconds").record(0.123);
}
```

**åˆå§‹åŒ–**:

```rust
use metrics_exporter_prometheus::PrometheusBuilder;

fn main() {
    // è®¾ç½® Prometheus exporter
    PrometheusBuilder::new()
        .install()
        .expect("failed to install Prometheus recorder");
    
    // ç°åœ¨å¯ä»¥ä½¿ç”¨ metrics å®
    counter!("app_started").increment(1);
}
```

---

### 3.2 Prometheus é›†æˆ

**å®Œæ•´ HTTP æœåŠ¡å™¨**:

```rust
use axum::{routing::get, Router};
use metrics_exporter_prometheus::PrometheusHandle;

#[tokio::main]
async fn main() {
    // åˆ›å»º Prometheus exporter
    let recorder_handle = PrometheusBuilder::new()
        .install_recorder()
        .unwrap();
    
    // åˆ›å»º metrics ç«¯ç‚¹
    let app = Router::new()
        .route("/metrics", get(move || async move {
            recorder_handle.render()
        }))
        .route("/api/users", get(handle_users));
    
    // å¯åŠ¨æœåŠ¡å™¨
    axum::Server::bind(&"0.0.0.0:9090".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn handle_users() -> &'static str {
    counter!("api_requests_total", "endpoint" => "/api/users").increment(1);
    let start = std::time::Instant::now();
    
    // å¤„ç†è¯·æ±‚
    
    histogram!("api_request_duration_seconds", "endpoint" => "/api/users")
        .record(start.elapsed().as_secs_f64());
    
    "Users"
}
```

---

### 3.3 æŒ‡æ ‡ç±»å‹

**è®¡æ•°å™¨ (Counter)**:

```rust
// åªå¢ä¸å‡
counter!("requests_total").increment(1);
counter!("bytes_sent").increment(1024);

// å¸¦æ ‡ç­¾
counter!("http_requests", 
    "method" => "GET",
    "status" => "200"
).increment(1);
```

**ä»ªè¡¨ç›˜ (Gauge)**:

```rust
// å¯å¢å¯å‡
gauge!("active_connections").increment(1.0);
gauge!("active_connections").decrement(1.0);
gauge!("active_connections").set(42.0);

// æ¸©åº¦ã€CPUä½¿ç”¨ç‡ç­‰
gauge!("cpu_usage_percent").set(75.5);
gauge!("memory_used_bytes").set(1_073_741_824.0);
```

**ç›´æ–¹å›¾ (Histogram)**:

```rust
// è®°å½•å€¼çš„åˆ†å¸ƒ
histogram!("http_request_duration_seconds").record(0.123);
histogram!("db_query_duration_seconds").record(0.045);

// è‡ªåŠ¨ç”Ÿæˆ bucketã€sumã€count
// http_request_duration_seconds_bucket{le="0.1"} 234
// http_request_duration_seconds_sum 125.4
// http_request_duration_seconds_count 1000
```

---

## 4. åˆ†å¸ƒå¼è¿½è¸ª (OpenTelemetry)

### 4.1 åŸºæœ¬é…ç½®

**Cargo.toml**:

```toml
[dependencies]
opentelemetry = "0.20"
opentelemetry-jaeger = "0.19"
tracing-opentelemetry = "0.21"
tracing-subscriber = "0.3"
```

**åˆå§‹åŒ–**:

```rust
use opentelemetry::global;
use opentelemetry_jaeger::new_agent_pipeline;
use tracing_subscriber::{layer::SubscriberExt, Registry};

fn init_tracer() {
    // é…ç½® Jaeger exporter
    let tracer = new_agent_pipeline()
        .with_service_name("my-service")
        .with_endpoint("localhost:6831")
        .install_batch(opentelemetry::runtime::Tokio)
        .expect("Failed to install OpenTelemetry tracer");
    
    // åˆ›å»º tracing layer
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    // ç»„åˆè®¢é˜…å™¨
    let subscriber = Registry::default()
        .with(telemetry)
        .with(tracing_subscriber::fmt::layer());
    
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set subscriber");
}
```

---

### 4.2 Span ç®¡ç†

**æ‰‹åŠ¨ Span**:

```rust
use tracing::{span, Level};

fn process() {
    let span = span!(Level::INFO, "process", user_id = 42);
    let _enter = span.enter();
    
    // æ‰€æœ‰æ—¥å¿—å’Œ span è‡ªåŠ¨å…³è”
    info!("Processing started");
    
    // åµŒå¥— span
    {
        let child_span = span!(Level::DEBUG, "database_query");
        let _enter = child_span.enter();
        
        info!("Querying database");
    }
    
    info!("Processing completed");
}
```

**è‡ªåŠ¨ Span (instrument)**:

```rust
use tracing::instrument;

#[instrument(skip(password), fields(user_id = user.id))]
async fn authenticate(user: &User, password: &str) -> Result<Token, AuthError> {
    info!("Authenticating user");
    
    let hash = hash_password(password).await?;
    verify_hash(&user.password_hash, &hash)?;
    
    info!("Authentication successful");
    Ok(generate_token(user))
}
```

---

### 4.3 ä¸Šä¸‹æ–‡ä¼ æ’­

**HTTP å¤´éƒ¨ä¼ æ’­**:

```rust
use opentelemetry::global;
use opentelemetry::propagation::TextMapPropagator;

async fn handle_request(req: Request) -> Response {
    // æå–ä¸Šä¸‹æ–‡
    let propagator = global::get_text_map_propagator(|propagator| {
        propagator.extract(&req.headers())
    });
    
    // åœ¨å½“å‰ä¸Šä¸‹æ–‡ä¸­å¤„ç†è¯·æ±‚
    let span = span!(Level::INFO, "handle_request");
    let _enter = span.enter();
    
    // è°ƒç”¨ä¸‹æ¸¸æœåŠ¡
    let mut downstream_req = Request::new();
    
    // æ³¨å…¥ä¸Šä¸‹æ–‡
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(&tracing::Span::current().context(), &mut downstream_req.headers_mut())
    });
    
    client.send(downstream_req).await
}
```

---

## 5. æ—¥å¿—æœ€ä½³å®è·µ

### 5.1 æ—¥å¿—çº§åˆ«ä½¿ç”¨

```rust
// TRACE: éå¸¸è¯¦ç»†ï¼Œä»…ç”¨äºè¯Šæ–­ç‰¹å®šé—®é¢˜
trace!("Entering function with args: {:?}", args);

// DEBUG: å¼€å‘è°ƒè¯•ä¿¡æ¯
debug!("Cache hit for key: {}", key);

// INFO: é‡è¦çš„ä¸šåŠ¡äº‹ä»¶
info!("User {} logged in successfully", user_id);

// WARN: è­¦å‘Šï¼Œä¸å½±å“åŠŸèƒ½ä½†éœ€æ³¨æ„
warn!("Retry attempt {}/3 failed", retry_count);

// ERROR: é”™è¯¯ï¼Œéœ€è¦å…³æ³¨å’Œä¿®å¤
error!("Database connection failed: {}", err);
```

---

### 5.2 ç»“æ„åŒ–æ—¥å¿—

```rust
// âŒ ä¸å¥½ï¼šéš¾ä»¥è§£æ
info!("User 42 logged in from 192.168.1.1");

// âœ… å¥½ï¼šç»“æ„åŒ–
info!(
    user_id = 42,
    ip = "192.168.1.1",
    "User logged in"
);

// ä½¿ç”¨ tracing fields
#[instrument(fields(
    user_id = user.id,
    username = %user.name,
    request_id = %uuid::Uuid::new_v4()
))]
async fn process_user(user: &User) {
    info!("Processing user");
}
```

---

### 5.3 æ•æ„Ÿä¿¡æ¯å¤„ç†

```rust
use tracing::info;

// âŒ ä¸è¦è®°å½•æ•æ„Ÿä¿¡æ¯
// error!("Login failed: password={}", password);

// âœ… ä½¿ç”¨å ä½ç¬¦
info!("Login failed: user={}, password=***", username);

// âœ… ä½¿ç”¨ skip è·³è¿‡æ•æ„Ÿå­—æ®µ
#[instrument(skip(password, api_key))]
fn authenticate(username: &str, password: &str, api_key: &str) {
    // ...
}

// âœ… è‡ªå®šä¹‰ Debug å®ç°
#[derive(Debug)]
struct User {
    id: u32,
    username: String,
    #[debug(skip)]  // æˆ–ä½¿ç”¨è‡ªå®šä¹‰æ ¼å¼åŒ–
    password_hash: String,
}
```

---

## 6. æŒ‡æ ‡æœ€ä½³å®è·µ

### 6.1 å‘½åçº¦å®š

```rust
// âœ… å¥½çš„å‘½å
counter!("http_requests_total");          // ä½¿ç”¨ _total åç¼€
gauge!("active_connections");             // æè¿°æ€§åç§°
histogram!("http_request_duration_seconds"); // ä½¿ç”¨æ ‡å‡†å•ä½åç¼€

// âŒ ä¸å¥½çš„å‘½å
counter!("requests");                     // ä¸å¤Ÿå…·ä½“
gauge!("conn");                          // ç¼©å†™ä¸æ¸…æ™°
histogram!("latency");                   // ç¼ºå°‘å•ä½
```

---

### 6.2 æ ‡ç­¾ä½¿ç”¨

```rust
// âœ… å¥½çš„æ ‡ç­¾ï¼šåŸºæ•°å¯æ§
counter!("http_requests_total",
    "method" => "GET",           // æœ‰é™å€¼: GET, POSTç­‰
    "status" => "200",           // æœ‰é™å€¼: 200, 404ç­‰
    "endpoint" => "/api/users"   // æ§åˆ¶æ•°é‡çš„ç«¯ç‚¹
).increment(1);

// âŒ ä¸å¥½çš„æ ‡ç­¾ï¼šåŸºæ•°è¿‡é«˜
counter!("http_requests_total",
    "user_id" => user_id,        // å¯èƒ½æœ‰æ•°ç™¾ä¸‡ç”¨æˆ·
    "request_id" => request_id   // æ¯ä¸ªè¯·æ±‚éƒ½ä¸åŒ
).increment(1);
```

---

### 6.3 æ€§èƒ½è€ƒé‡

```rust
// âœ… ç¼“å­˜æŒ‡æ ‡å¥æŸ„
use metrics::{Counter, register_counter};

struct Metrics {
    requests_total: Counter,
}

impl Metrics {
    fn new() -> Self {
        Self {
            requests_total: register_counter!("requests_total"),
        }
    }
}

// ä½¿ç”¨ç¼“å­˜çš„å¥æŸ„
fn handle_request(metrics: &Metrics) {
    metrics.requests_total.increment(1);  // å¿«é€Ÿ
}

// âŒ æ¯æ¬¡éƒ½æŸ¥æ‰¾
fn handle_request_slow() {
    counter!("requests_total").increment(1);  // ç¨æ…¢
}
```

---

## 7. è¿½è¸ªæœ€ä½³å®è·µ

### 7.1 Span è®¾è®¡

```rust
// âœ… å¥½çš„ span è®¾è®¡
#[instrument(name = "authenticate_user", skip(password))]
async fn authenticate(username: &str, password: &str) -> Result<User> {
    // å­æ“ä½œä¹Ÿåˆ›å»º span
    let user = fetch_user(username).await?;
    verify_password(&user, password).await?;
    Ok(user)
}

#[instrument(name = "db.query", fields(db.statement = query))]
async fn fetch_user(username: &str) -> Result<User> {
    // ...
}

// Span å±‚æ¬¡:
// authenticate_user
// â””â”€ db.query
```

---

### 7.2 é‡‡æ ·ç­–ç•¥

```rust
use opentelemetry::sdk::trace::{Sampler, SamplerResult};

// å›ºå®šé‡‡æ ·ç‡
let sampler = Sampler::TraceIdRatioBased(0.1); // 10%

// è‡ªå®šä¹‰é‡‡æ ·
struct CustomSampler;

impl Sampler for CustomSampler {
    fn should_sample(&self, context: &SamplingContext) -> SamplerResult {
        // æ€»æ˜¯é‡‡æ ·é”™è¯¯è¯·æ±‚
        if context.attributes().contains_key("error") {
            return SamplerResult::RecordAndSample;
        }
        
        // å…¶ä»–è¯·æ±‚æŒ‰æ¯”ä¾‹é‡‡æ ·
        if rand::random::<f64>() < 0.1 {
            SamplerResult::RecordAndSample
        } else {
            SamplerResult::Drop
        }
    }
}
```

---

### 7.3 å¼‚æ­¥è¿½è¸ª

```rust
use tracing::Instrument;

async fn process_async() {
    // âœ… ä½¿ç”¨ instrument ç¡®ä¿ä¸Šä¸‹æ–‡ä¼ æ’­
    let span = span!(Level::INFO, "process");
    
    async move {
        info!("Step 1");
        tokio::time::sleep(Duration::from_millis(100)).await;
        info!("Step 2");
    }
    .instrument(span)
    .await;
}

// æˆ–ä½¿ç”¨ #[instrument]
#[instrument]
async fn process_auto() {
    info!("Step 1");
    tokio::time::sleep(Duration::from_millis(100)).await;
    info!("Step 2");
}
```

---

## 8. ç”Ÿäº§ç¯å¢ƒé›†æˆ

### 8.1 å®Œæ•´ç¤ºä¾‹

```rust
use tracing::info;
use metrics::{counter, histogram};
use opentelemetry::global;

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–è§‚æµ‹æ€§ç»„ä»¶
    init_observability();
    
    info!("Application started");
    counter!("app_starts_total").increment(1);
    
    // å¯åŠ¨æœåŠ¡
    let app = create_app();
    
    // ä¼˜é›…å…³é—­
    tokio::select! {
        _ = axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
            .serve(app.into_make_service()) => {}
        _ = tokio::signal::ctrl_c() => {
            info!("Shutting down");
            global::shutdown_tracer_provider();
        }
    }
}

fn init_observability() {
    // æ—¥å¿—
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .json()
        .init();
    
    // æŒ‡æ ‡
    let _ = metrics_exporter_prometheus::PrometheusBuilder::new()
        .install();
    
    // è¿½è¸ª
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_batch(opentelemetry::runtime::Tokio)
        .unwrap();
    
    tracing::subscriber::set_global_default(
        tracing_subscriber::Registry::default()
            .with(tracing_opentelemetry::layer().with_tracer(tracer))
    ).unwrap();
}
```

---

### 8.2 å¥åº·æ£€æŸ¥

```rust
use axum::{Json, response::IntoResponse};
use serde_json::json;

async fn health_check() -> impl IntoResponse {
    let health = json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "checks": {
            "database": check_database().await,
            "cache": check_cache().await,
        }
    });
    
    Json(health)
}

async fn readiness_check() -> impl IntoResponse {
    // æ£€æŸ¥æ‰€æœ‰ä¾èµ–æ˜¯å¦å°±ç»ª
    if is_ready().await {
        (axum::http::StatusCode::OK, "Ready")
    } else {
        (axum::http::StatusCode::SERVICE_UNAVAILABLE, "Not ready")
    }
}
```

---

## 9. æ•…éšœæ’æŸ¥

### 9.1 å¸¸è§é—®é¢˜

**é—®é¢˜ 1**: æ—¥å¿—çº§åˆ«ä¸ç”Ÿæ•ˆ

```bash
# ç¡®ä¿è®¾ç½®äº†ç¯å¢ƒå˜é‡
RUST_LOG=debug cargo run

# æˆ–åœ¨ä»£ç ä¸­è®¾ç½®
env_logger::Builder::new()
    .filter_level(log::LevelFilter::Debug)
    .init();
```

**é—®é¢˜ 2**: æŒ‡æ ‡æœªå¯¼å‡º

```rust
// ç¡®ä¿å®‰è£…äº† exporter
let _handle = PrometheusBuilder::new()
    .install_recorder()
    .expect("Failed to install Prometheus recorder");

// ç¡®ä¿æœ‰ /metrics ç«¯ç‚¹
app.route("/metrics", get(|| async { recorder_handle.render() }))
```

**é—®é¢˜ 3**: Span ä¸Šä¸‹æ–‡ä¸¢å¤±

```rust
// âœ… ç¡®ä¿åœ¨å¼‚æ­¥ä»£ç ä¸­ä¼ æ’­ä¸Šä¸‹æ–‡
async fn work() {
    async_operation()
        .instrument(span!(Level::INFO, "operation"))
        .await;
}
```

---

## 10. API é€ŸæŸ¥è¡¨

### 10.1 æ—¥å¿—å®

| å® | çº§åˆ« | ç”¨é€” |
|----|------|------|
| `trace!()` | TRACE | è¯¦ç»†è¯Šæ–­ |
| `debug!()` | DEBUG | è°ƒè¯•ä¿¡æ¯ |
| `info!()` | INFO | ä¸šåŠ¡äº‹ä»¶ |
| `warn!()` | WARN | è­¦å‘Š |
| `error!()` | ERROR | é”™è¯¯ |

---

### 10.2 æŒ‡æ ‡API

| å‡½æ•° | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `counter!()` | Counter | åªå¢è®¡æ•°å™¨ |
| `gauge!()` | Gauge | å¯å¢å¯å‡ä»ªè¡¨ç›˜ |
| `histogram!()` | Histogram | å€¼åˆ†å¸ƒç›´æ–¹å›¾ |

---

### 10.3 è¿½è¸ªAPI

| å®/å‡½æ•° | è¯´æ˜ |
|---------|------|
| `span!()` | åˆ›å»º span |
| `#[instrument]` | è‡ªåŠ¨ span |
| `.instrument()` | å¼‚æ­¥ span ä¼ æ’­ |

---

**ç›¸å…³æ–‡æ¡£**:

- [æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ](./01_æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ.md)
- [é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ](./02_é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ.md)
- [æ•…éšœæ¢å¤æœºåˆ¶å‚è€ƒ](./04_æ•…éšœæ¢å¤æœºåˆ¶å‚è€ƒ.md)
- [Tier 2 ç›‘æ§å®è·µ](../tier_02_guides/)

---

**æœ€åæ›´æ–°**: 2025-10-24  
**è´¡çŒ®è€…**: Rust Documentation Team
