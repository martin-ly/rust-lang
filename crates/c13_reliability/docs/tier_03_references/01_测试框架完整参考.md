# æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ

**æœ€åæ›´æ–°**: 2025-10-24  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦**: â­â­â­

---

## ğŸ“‹ ç›®å½•

- [æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ](#æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Cargo Test å®Œæ•´å‚è€ƒ](#1-cargo-test-å®Œæ•´å‚è€ƒ)
    - [1.1 åŸºæœ¬å‘½ä»¤](#11-åŸºæœ¬å‘½ä»¤)
    - [1.2 è¿‡æ»¤ä¸é€‰æ‹©](#12-è¿‡æ»¤ä¸é€‰æ‹©)
    - [1.3 ç¯å¢ƒå˜é‡](#13-ç¯å¢ƒå˜é‡)
    - [1.4 å¹¶è¡Œæ§åˆ¶](#14-å¹¶è¡Œæ§åˆ¶)
  - [2. å•å…ƒæµ‹è¯• API](#2-å•å…ƒæµ‹è¯•-api)
    - [2.1 æµ‹è¯•å±æ€§](#21-æµ‹è¯•å±æ€§)
    - [2.2 æ–­è¨€å®](#22-æ–­è¨€å®)
    - [2.3 æµ‹è¯•æ¨¡å—ç»„ç»‡](#23-æµ‹è¯•æ¨¡å—ç»„ç»‡)
    - [2.4 æ¡ä»¶ç¼–è¯‘](#24-æ¡ä»¶ç¼–è¯‘)
  - [3. é›†æˆæµ‹è¯•](#3-é›†æˆæµ‹è¯•)
    - [3.1 é›†æˆæµ‹è¯•ç»“æ„](#31-é›†æˆæµ‹è¯•ç»“æ„)
    - [3.2 å…±äº«ä»£ç ](#32-å…±äº«ä»£ç )
    - [3.3 æµ‹è¯•å¤–éƒ¨ API](#33-æµ‹è¯•å¤–éƒ¨-api)
  - [4. æ€§èƒ½æµ‹è¯• (Criterion)](#4-æ€§èƒ½æµ‹è¯•-criterion)
    - [4.1 åŸºæœ¬é…ç½®](#41-åŸºæœ¬é…ç½®)
    - [4.2 åŸºå‡†æµ‹è¯•ç¼–å†™](#42-åŸºå‡†æµ‹è¯•ç¼–å†™)
    - [4.3 é«˜çº§é…ç½®](#43-é«˜çº§é…ç½®)
    - [4.4 æ€§èƒ½å›å½’æ£€æµ‹](#44-æ€§èƒ½å›å½’æ£€æµ‹)
  - [5. æ¨¡ç³Šæµ‹è¯• (cargo-fuzz)](#5-æ¨¡ç³Šæµ‹è¯•-cargo-fuzz)
    - [5.1 å®‰è£…ä¸åˆå§‹åŒ–](#51-å®‰è£…ä¸åˆå§‹åŒ–)
    - [5.2 Fuzz Target ç¼–å†™](#52-fuzz-target-ç¼–å†™)
    - [5.3 è¿è¡Œä¸åˆ†æ](#53-è¿è¡Œä¸åˆ†æ)
  - [6. å±æ€§æµ‹è¯• (proptest)](#6-å±æ€§æµ‹è¯•-proptest)
    - [6.1 åŸºæœ¬ä½¿ç”¨](#61-åŸºæœ¬ä½¿ç”¨)
    - [6.2 è‡ªå®šä¹‰ç­–ç•¥](#62-è‡ªå®šä¹‰ç­–ç•¥)
  - [7. Mock ä¸ Stub](#7-mock-ä¸-stub)
    - [7.1 Mockall æ¡†æ¶](#71-mockall-æ¡†æ¶)
    - [7.2 ä¾èµ–æ³¨å…¥æ¨¡å¼](#72-ä¾èµ–æ³¨å…¥æ¨¡å¼)
  - [8. æµ‹è¯•è¦†ç›–ç‡](#8-æµ‹è¯•è¦†ç›–ç‡)
    - [8.1 Tarpaulin é…ç½®](#81-tarpaulin-é…ç½®)
    - [8.2 LLVM-cov ä½¿ç”¨](#82-llvm-cov-ä½¿ç”¨)
  - [9. æµ‹è¯•ç»„ç»‡æœ€ä½³å®è·µ](#9-æµ‹è¯•ç»„ç»‡æœ€ä½³å®è·µ)
    - [9.1 æ–‡ä»¶ç»“æ„](#91-æ–‡ä»¶ç»“æ„)
    - [9.2 å‘½åçº¦å®š](#92-å‘½åçº¦å®š)
    - [9.3 æµ‹è¯•é‡‘å­—å¡”](#93-æµ‹è¯•é‡‘å­—å¡”)
  - [10. CI/CD é›†æˆ](#10-cicd-é›†æˆ)
    - [10.1 GitHub Actions](#101-github-actions)
    - [10.2 ç¼“å­˜ç­–ç•¥](#102-ç¼“å­˜ç­–ç•¥)
  - [11. æ•…éšœæ’æŸ¥](#11-æ•…éšœæ’æŸ¥)
    - [11.1 å¸¸è§é”™è¯¯](#111-å¸¸è§é”™è¯¯)
    - [11.2 è°ƒè¯•æŠ€å·§](#112-è°ƒè¯•æŠ€å·§)
  - [12. API é€ŸæŸ¥è¡¨](#12-api-é€ŸæŸ¥è¡¨)
    - [12.1 cargo test å‘½ä»¤](#121-cargo-test-å‘½ä»¤)
    - [12.2 æ–­è¨€å®](#122-æ–­è¨€å®)
    - [12.3 æµ‹è¯•å±æ€§](#123-æµ‹è¯•å±æ€§)

---

## 1. Cargo Test å®Œæ•´å‚è€ƒ

### 1.1 åŸºæœ¬å‘½ä»¤

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_name

# è¿è¡Œæ¨¡å—æµ‹è¯•
cargo test module_name::

# æ˜¾ç¤ºæ‰“å°è¾“å‡º
cargo test -- --show-output

# æ˜¾ç¤ºå¿½ç•¥çš„æµ‹è¯•
cargo test -- --ignored

# è¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼ˆåŒ…æ‹¬å¿½ç•¥çš„ï¼‰
cargo test -- --include-ignored
```

---

### 1.2 è¿‡æ»¤ä¸é€‰æ‹©

```bash
# è¿è¡Œæ–‡æ¡£æµ‹è¯•
cargo test --doc

# è¿è¡Œé›†æˆæµ‹è¯•
cargo test --test integration_test

# è¿è¡Œç‰¹å®šåŒ…çš„æµ‹è¯•
cargo test -p package_name

# è¿è¡Œåº“æµ‹è¯•ï¼ˆä¸è¿è¡ŒäºŒè¿›åˆ¶æµ‹è¯•ï¼‰
cargo test --lib

# è¿è¡ŒäºŒè¿›åˆ¶æµ‹è¯•
cargo test --bin binary_name
```

---

### 1.3 ç¯å¢ƒå˜é‡

| ç¯å¢ƒå˜é‡ | è¯´æ˜ | ç¤ºä¾‹ |
|---------|------|------|
| `RUST_TEST_THREADS` | å¹¶è¡Œæµ‹è¯•çº¿ç¨‹æ•° | `RUST_TEST_THREADS=1 cargo test` |
| `RUST_TEST_NOCAPTURE` | ä¸æ•è·è¾“å‡º | `RUST_TEST_NOCAPTURE=1 cargo test` |
| `RUST_BACKTRACE` | æ˜¾ç¤ºå †æ ˆè·Ÿè¸ª | `RUST_BACKTRACE=1 cargo test` |
| `RUST_LOG` | æ—¥å¿—çº§åˆ« | `RUST_LOG=debug cargo test` |

---

### 1.4 å¹¶è¡Œæ§åˆ¶

```bash
# å•çº¿ç¨‹è¿è¡Œï¼ˆé¿å…ç«æ€ï¼‰
cargo test -- --test-threads=1

# è‡ªå®šä¹‰çº¿ç¨‹æ•°
cargo test -- --test-threads=4

# é¡ºåºè¿è¡Œç‰¹å®šæµ‹è¯•
cargo test sequential_ -- --test-threads=1
```

---

## 2. å•å…ƒæµ‹è¯• API

### 2.1 æµ‹è¯•å±æ€§

```rust
// æ ‡è®°æµ‹è¯•å‡½æ•°
#[test]
fn test_addition() {
    assert_eq!(2 + 2, 4);
}

// å¿½ç•¥æµ‹è¯•
#[test]
#[ignore]
fn expensive_test() {
    // åªåœ¨ cargo test -- --ignored æ—¶è¿è¡Œ
}

// é¢„æœŸ panic
#[test]
#[should_panic]
fn test_panic() {
    panic!("Expected panic");
}

// é¢„æœŸç‰¹å®š panic æ¶ˆæ¯
#[test]
#[should_panic(expected = "divide by zero")]
fn test_division() {
    let _ = 1 / 0;
}

// è¶…æ—¶æµ‹è¯•ï¼ˆéœ€è¦ nightlyï¼‰
#[test]
#[cfg(feature = "test-timeout")]
#[timeout(std::time::Duration::from_secs(5))]
fn test_with_timeout() {
    // å¿…é¡»åœ¨ 5 ç§’å†…å®Œæˆ
}
```

---

### 2.2 æ–­è¨€å®

**åŸºæœ¬æ–­è¨€**:

```rust
#[test]
fn test_assertions() {
    // ç›¸ç­‰æ–­è¨€
    assert_eq!(2 + 2, 4);
    assert_ne!(2 + 2, 5);
    
    // å¸ƒå°”æ–­è¨€
    assert!(true);
    assert!(!false);
    
    // è‡ªå®šä¹‰æ¶ˆæ¯
    assert_eq!(2 + 2, 4, "Math is broken!");
    assert!(x > 0, "x must be positive, got {}", x);
}
```

**æµ®ç‚¹æ•°æ–­è¨€**:

```rust
#[test]
fn test_floats() {
    let a = 0.1 + 0.2;
    let b = 0.3;
    
    // âŒ ä¸æ¨èï¼šç›´æ¥ç›¸ç­‰æ¯”è¾ƒ
    // assert_eq!(a, b);
    
    // âœ… æ¨èï¼šä½¿ç”¨ epsilon
    assert!((a - b).abs() < 1e-10);
    
    // æˆ–ä½¿ç”¨ approx crate
    use approx::assert_relative_eq;
    assert_relative_eq!(a, b, epsilon = 1e-10);
}
```

**é›†åˆæ–­è¨€**:

```rust
#[test]
fn test_collections() {
    let v = vec![1, 2, 3];
    
    // å…ƒç´ å­˜åœ¨
    assert!(v.contains(&2));
    
    // é•¿åº¦æ–­è¨€
    assert_eq!(v.len(), 3);
    
    // ä½¿ç”¨ assert_matches (Rust 1.82+)
    assert!(matches!(v.first(), Some(&1)));
}
```

---

### 2.3 æµ‹è¯•æ¨¡å—ç»„ç»‡

**æ¨èç»“æ„**:

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
    
    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }
    
    // åµŒå¥—æµ‹è¯•æ¨¡å—
    mod edge_cases {
        use super::*;
        
        #[test]
        fn test_zero() {
            assert_eq!(add(0, 0), 0);
        }
    }
}
```

---

### 2.4 æ¡ä»¶ç¼–è¯‘

```rust
// ä»…åœ¨æµ‹è¯•æ—¶ç¼–è¯‘
#[cfg(test)]
mod tests {
    // æµ‹è¯•ä»£ç 
}

// ä»…åœ¨ç‰¹å®šå¹³å°æµ‹è¯•
#[cfg(all(test, target_os = "linux"))]
mod linux_tests {
    // Linux ä¸“ç”¨æµ‹è¯•
}

// åŸºäº feature çš„æµ‹è¯•
#[cfg(all(test, feature = "advanced"))]
mod advanced_tests {
    // é«˜çº§åŠŸèƒ½æµ‹è¯•
}
```

---

## 3. é›†æˆæµ‹è¯•

### 3.1 é›†æˆæµ‹è¯•ç»“æ„

**ç›®å½•ç»“æ„**:

```text
project/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ lib.rs
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration_test.rs
â”‚   â”œâ”€â”€ api_test.rs
â”‚   â””â”€â”€ common/
â”‚       â””â”€â”€ mod.rs  # å…±äº«ä»£ç 
â””â”€â”€ Cargo.toml
```

**åŸºæœ¬é›†æˆæµ‹è¯•**:

```rust
// tests/integration_test.rs
use my_crate::{add, multiply};

#[test]
fn test_integration() {
    let result = add(2, 2);
    assert_eq!(result, 4);
    
    let result = multiply(result, 3);
    assert_eq!(result, 12);
}
```

---

### 3.2 å…±äº«ä»£ç 

```rust
// tests/common/mod.rs
pub fn setup() -> TestContext {
    TestContext {
        // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
    }
}

pub struct TestContext {
    // å…±äº«æµ‹è¯•çŠ¶æ€
}

// tests/integration_test.rs
mod common;

#[test]
fn test_with_setup() {
    let ctx = common::setup();
    // ä½¿ç”¨ ctx è¿›è¡Œæµ‹è¯•
}
```

---

### 3.3 æµ‹è¯•å¤–éƒ¨ API

```rust
// tests/api_test.rs
use my_crate::api::Client;

#[tokio::test]
async fn test_api_endpoint() {
    let client = Client::new("http://localhost:8080");
    
    let response = client.get("/users/1").await.unwrap();
    assert_eq!(response.status(), 200);
    
    let user: User = response.json().await.unwrap();
    assert_eq!(user.id, 1);
}
```

---

## 4. æ€§èƒ½æµ‹è¯• (Criterion)

### 4.1 åŸºæœ¬é…ç½®

**Cargo.toml**:

```toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "my_benchmark"
harness = false
```

---

### 4.2 åŸºå‡†æµ‹è¯•ç¼–å†™

**benches/my_benchmark.rs**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use my_crate::*;

// ç®€å•åŸºå‡†æµ‹è¯•
fn fibonacci_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });
}

// å‚æ•°åŒ–åŸºå‡†æµ‹è¯•
fn sort_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("sorting");
    
    for size in [100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(size),
            size,
            |b, &size| {
                b.iter(|| {
                    let mut vec: Vec<i32> = (0..size).collect();
                    vec.sort();
                });
            },
        );
    }
    
    group.finish();
}

// æ¯”è¾ƒä¸åŒå®ç°
fn algorithm_comparison(c: &mut Criterion) {
    let mut group = c.benchmark_group("algorithms");
    
    group.bench_function("quicksort", |b| {
        b.iter(|| quicksort(black_box(&mut test_data())))
    });
    
    group.bench_function("mergesort", |b| {
        b.iter(|| mergesort(black_box(&mut test_data())))
    });
    
    group.finish();
}

criterion_group!(benches, fibonacci_benchmark, sort_benchmark, algorithm_comparison);
criterion_main!(benches);
```

---

### 4.3 é«˜çº§é…ç½®

```rust
use criterion::{Criterion, SamplingMode, BenchmarkGroup};
use std::time::Duration;

fn custom_criterion() -> Criterion {
    Criterion::default()
        .sample_size(1000)                    // æ ·æœ¬æ•°é‡
        .measurement_time(Duration::from_secs(10))  // æµ‹é‡æ—¶é—´
        .warm_up_time(Duration::from_secs(3))       // é¢„çƒ­æ—¶é—´
        .noise_threshold(0.05)                      // å™ªå£°é˜ˆå€¼
        .confidence_level(0.95)                     // ç½®ä¿¡æ°´å¹³
        .significance_level(0.05)                   // æ˜¾è‘—æ€§æ°´å¹³
}

fn configured_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("custom");
    group.sampling_mode(SamplingMode::Flat);  // é‡‡æ ·æ¨¡å¼
    
    // æµ‹è¯•ä»£ç 
    
    group.finish();
}
```

---

### 4.4 æ€§èƒ½å›å½’æ£€æµ‹

```bash
# ä¿å­˜åŸºçº¿
cargo bench -- --save-baseline before

# ä¿®æ”¹ä»£ç å
cargo bench -- --baseline before

# æ¯”è¾ƒç»“æœ
# Criterion ä¼šè‡ªåŠ¨æ˜¾ç¤ºæ€§èƒ½å˜åŒ–ç™¾åˆ†æ¯”
```

---

## 5. æ¨¡ç³Šæµ‹è¯• (cargo-fuzz)

### 5.1 å®‰è£…ä¸åˆå§‹åŒ–

```bash
# å®‰è£… cargo-fuzz
cargo install cargo-fuzz

# åˆå§‹åŒ– fuzz ç›®æ ‡
cargo fuzz init

# æ·»åŠ æ–°çš„ fuzz ç›®æ ‡
cargo fuzz add fuzz_target_name
```

---

### 5.2 Fuzz Target ç¼–å†™

**fuzz/fuzz_targets/fuzz_parser.rs**:

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use my_crate::parse;

fuzz_target!(|data: &[u8]| {
    // å°è¯•è§£æä»»æ„è¾“å…¥
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = parse(s);
    }
});

// ç»“æ„åŒ–æ¨¡ç³Šæµ‹è¯•
use libfuzzer_sys::arbitrary::{Arbitrary, Unstructured};

#[derive(Arbitrary, Debug)]
struct Input {
    x: i32,
    y: i32,
    operation: Operation,
}

#[derive(Arbitrary, Debug)]
enum Operation {
    Add,
    Subtract,
    Multiply,
    Divide,
}

fuzz_target!(|input: Input| {
    let _ = calculate(input.x, input.y, input.operation);
});
```

---

### 5.3 è¿è¡Œä¸åˆ†æ

```bash
# è¿è¡Œæ¨¡ç³Šæµ‹è¯•
cargo fuzz run fuzz_target_name

# é™åˆ¶æ—¶é—´
cargo fuzz run fuzz_target_name -- -max_total_time=60

# ä½¿ç”¨è¯­æ–™åº“
cargo fuzz run fuzz_target_name corpus/

# æœ€å°åŒ–å¤±è´¥ç”¨ä¾‹
cargo fuzz cmin fuzz_target_name

# å›æ”¾å¤±è´¥ç”¨ä¾‹
cargo fuzz run fuzz_target_name crash-file
```

---

## 6. å±æ€§æµ‹è¯• (proptest)

### 6.1 åŸºæœ¬ä½¿ç”¨

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_addition_commutative(a: i32, b: i32) {
        prop_assert_eq!(a + b, b + a);
    }
    
    #[test]
    fn test_string_length(s in ".*") {
        prop_assert!(s.len() <= 1000);
    }
    
    #[test]
    fn test_vec_operations(v in prop::collection::vec(0..100, 0..10)) {
        prop_assert!(v.iter().all(|&x| x < 100));
    }
}
```

---

### 6.2 è‡ªå®šä¹‰ç­–ç•¥

```rust
use proptest::prelude::*;

// è‡ªå®šä¹‰ç”Ÿæˆå™¨
fn my_strategy() -> impl Strategy<Value = MyType> {
    (0..100, ".*")
        .prop_map(|(id, name)| MyType { id, name })
}

proptest! {
    #[test]
    fn test_custom_type(value in my_strategy()) {
        prop_assert!(value.id < 100);
    }
}

// æ¡ä»¶ç”Ÿæˆ
fn valid_email() -> impl Strategy<Value = String> {
    "[a-z0-9]+@[a-z0-9]+\\.[a-z]{2,}"
        .prop_filter("must be valid", |s| s.contains('@'))
}
```

---

## 7. Mock ä¸ Stub

### 7.1 Mockall æ¡†æ¶

**Cargo.toml**:

```toml
[dev-dependencies]
mockall = "0.12"
```

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use mockall::{automock, predicate::*};

#[automock]
trait Database {
    fn get_user(&self, id: u32) -> Result<User, Error>;
    fn save_user(&mut self, user: &User) -> Result<(), Error>;
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_with_mock() {
        let mut mock = MockDatabase::new();
        
        // è®¾ç½®æœŸæœ›
        mock.expect_get_user()
            .with(eq(1))
            .times(1)
            .returning(|_| Ok(User::default()));
        
        // ä½¿ç”¨ mock
        let result = mock.get_user(1);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_sequence() {
        let mut mock = MockDatabase::new();
        
        let mut seq = Sequence::new();
        
        mock.expect_get_user()
            .times(1)
            .in_sequence(&mut seq)
            .returning(|_| Ok(User::default()));
        
        mock.expect_save_user()
            .times(1)
            .in_sequence(&mut seq)
            .returning(|_| Ok(()));
    }
}
```

---

### 7.2 ä¾èµ–æ³¨å…¥æ¨¡å¼

```rust
// ä½¿ç”¨ trait å®ç°ä¾èµ–æ³¨å…¥
pub trait Logger {
    fn log(&self, message: &str);
}

pub struct Service<L: Logger> {
    logger: L,
}

impl<L: Logger> Service<L> {
    pub fn new(logger: L) -> Self {
        Self { logger }
    }
    
    pub fn do_something(&self) {
        self.logger.log("doing something");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    struct TestLogger {
        messages: std::sync::Mutex<Vec<String>>,
    }
    
    impl Logger for TestLogger {
        fn log(&self, message: &str) {
            self.messages.lock().unwrap().push(message.to_string());
        }
    }
    
    #[test]
    fn test_service() {
        let logger = TestLogger {
            messages: std::sync::Mutex::new(vec![]),
        };
        
        let service = Service::new(&logger);
        service.do_something();
        
        assert_eq!(logger.messages.lock().unwrap().len(), 1);
    }
}
```

---

## 8. æµ‹è¯•è¦†ç›–ç‡

### 8.1 Tarpaulin é…ç½®

**tarpaulin.toml**:

```toml
[report]
coveralls = true
out = ["Html", "Lcov"]

[run]
exclude-files = ["tests/*", "benches/*"]
timeout = "5m"
follow-exec = false
```

**è¿è¡Œ**:

```bash
# å®‰è£…
cargo install cargo-tarpaulin

# è¿è¡Œè¦†ç›–ç‡
cargo tarpaulin --out Html --output-dir coverage

# æ’é™¤ç‰¹å®šä»£ç 
cargo tarpaulin --ignore-tests --exclude-files 'src/generated/*'
```

---

### 8.2 LLVM-cov ä½¿ç”¨

```bash
# å®‰è£… (Rust 1.60+)
rustup component add llvm-tools-preview
cargo install cargo-llvm-cov

# ç”ŸæˆæŠ¥å‘Š
cargo llvm-cov --html

# æŸ¥çœ‹æŠ¥å‘Š
cargo llvm-cov --open

# CI å‹å¥½æ ¼å¼
cargo llvm-cov --lcov --output-path lcov.info
```

---

## 9. æµ‹è¯•ç»„ç»‡æœ€ä½³å®è·µ

### 9.1 æ–‡ä»¶ç»“æ„

**æ¨èç»“æ„**:

```text
src/
â”œâ”€â”€ lib.rs
â”œâ”€â”€ module1.rs    #[cfg(test)] mod tests {}
â”œâ”€â”€ module2.rs    #[cfg(test)] mod tests {}
tests/
â”œâ”€â”€ integration_test1.rs
â”œâ”€â”€ integration_test2.rs
â””â”€â”€ common/
    â””â”€â”€ mod.rs
benches/
â”œâ”€â”€ benchmark1.rs
â””â”€â”€ benchmark2.rs
fuzz/
â””â”€â”€ fuzz_targets/
    â””â”€â”€ fuzz_target_1.rs
```

---

### 9.2 å‘½åçº¦å®š

```rust
// âœ… å¥½çš„å‘½å
#[test]
fn test_add_positive_numbers() {}

#[test]
fn test_add_negative_numbers() {}

#[test]
fn test_add_zero() {}

// âŒ ä¸å¥½çš„å‘½å
#[test]
fn test1() {}

#[test]
fn test_stuff() {}
```

**å‘½åæ¨¡å¼**:

- `test_<function>_<scenario>`
- `test_<function>_returns_<expected>`
- `test_<function>_fails_when_<condition>`

---

### 9.3 æµ‹è¯•é‡‘å­—å¡”

```text
              â•± â•²
             â•±   â•²
            â•± E2E â•²         å°‘é‡ï¼ˆæ…¢ã€è„†å¼±ï¼‰
           â•±â”€â”€â”€â”€â”€â”€â”€â•²
          â•± é›†æˆæµ‹è¯• â•²       ä¸­é‡ï¼ˆä¸­é€Ÿï¼‰
         â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
        â•±   å•å…ƒæµ‹è¯•   â•²     å¤§é‡ï¼ˆå¿«ã€ç¨³å®šï¼‰
       â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
```

**æ¨èæ¯”ä¾‹**: å•å…ƒæµ‹è¯• 70% | é›†æˆæµ‹è¯• 20% | E2Eæµ‹è¯• 10%

---

## 10. CI/CD é›†æˆ

### 10.1 GitHub Actions

**.github/workflows/test.yml**:

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Run tests
        run: cargo test --all-features
      
      - name: Run doctests
        run: cargo test --doc
      
      - name: Run benchmarks (check only)
        run: cargo bench --no-run

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Install tarpaulin
        run: cargo install cargo-tarpaulin
      
      - name: Generate coverage
        run: cargo tarpaulin --out Lcov
      
      - name: Upload to codecov
        uses: codecov/codecov-action@v3
```

---

### 10.2 ç¼“å­˜ç­–ç•¥

```yaml
- name: Cache cargo registry
  uses: actions/cache@v3
  with:
    path: ~/.cargo/registry
    key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

- name: Cache cargo index
  uses: actions/cache@v3
  with:
    path: ~/.cargo/git
    key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

- name: Cache target directory
  uses: actions/cache@v3
  with:
    path: target
    key: ${{ runner.os }}-target-${{ hashFiles('**/Cargo.lock') }}
```

---

## 11. æ•…éšœæ’æŸ¥

### 11.1 å¸¸è§é”™è¯¯

**é”™è¯¯ 1**: æµ‹è¯•é—´çŠ¶æ€æ±¡æŸ“

```rust
// âŒ é”™è¯¯ï¼šå…±äº«å¯å˜çŠ¶æ€
static mut COUNTER: i32 = 0;

#[test]
fn test1() {
    unsafe { COUNTER += 1; }
    assert_eq!(unsafe { COUNTER }, 1); // å¯èƒ½å¤±è´¥
}

// âœ… æ­£ç¡®ï¼šéš”ç¦»çŠ¶æ€
#[test]
fn test2() {
    let mut counter = 0;
    counter += 1;
    assert_eq!(counter, 1);
}
```

**é”™è¯¯ 2**: å¼‚æ­¥æµ‹è¯•æœªç­‰å¾…

```rust
// âŒ é”™è¯¯
#[test]
fn test_async_wrong() {
    async_function(); // ä¸ä¼šæ‰§è¡Œ
}

// âœ… æ­£ç¡®
#[tokio::test]
async fn test_async_correct() {
    async_function().await;
}
```

---

### 11.2 è°ƒè¯•æŠ€å·§

```rust
// æ‰“å°è°ƒè¯•ä¿¡æ¯
#[test]
fn test_with_debug() {
    let x = compute();
    dbg!(x); // ä¼šåœ¨æµ‹è¯•è¾“å‡ºä¸­æ˜¾ç¤º
    assert_eq!(x, 42);
}

// ä½¿ç”¨ --show-output æŸ¥çœ‹ println!
cargo test -- --show-output

// è¿è¡Œå•ä¸ªæµ‹è¯•å¹¶æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—
RUST_LOG=debug cargo test test_name -- --nocapture

// ä½¿ç”¨ #[ignore] æš‚æ—¶è·³è¿‡æµ‹è¯•
#[test]
#[ignore = "éœ€è¦å¤–éƒ¨æœåŠ¡"]
fn test_external_api() {
    // ...
}
```

---

## 12. API é€ŸæŸ¥è¡¨

### 12.1 cargo test å‘½ä»¤

| å‘½ä»¤ | è¯´æ˜ |
|------|------|
| `cargo test` | è¿è¡Œæ‰€æœ‰æµ‹è¯• |
| `cargo test name` | è¿è¡ŒåŒ¹é…çš„æµ‹è¯• |
| `cargo test -- --show-output` | æ˜¾ç¤ºè¾“å‡º |
| `cargo test -- --ignored` | è¿è¡Œå¿½ç•¥çš„æµ‹è¯• |
| `cargo test -- --test-threads=1` | å•çº¿ç¨‹è¿è¡Œ |
| `cargo test --doc` | è¿è¡Œæ–‡æ¡£æµ‹è¯• |
| `cargo test --lib` | ä»…è¿è¡Œåº“æµ‹è¯• |

---

### 12.2 æ–­è¨€å®

| å® | ç”¨é€” |
|----|------|
| `assert!(expr)` | æ–­è¨€è¡¨è¾¾å¼ä¸ºçœŸ |
| `assert_eq!(a, b)` | æ–­è¨€ç›¸ç­‰ |
| `assert_ne!(a, b)` | æ–­è¨€ä¸ç›¸ç­‰ |
| `debug_assert!(expr)` | Debug æ–­è¨€ |

---

### 12.3 æµ‹è¯•å±æ€§

| å±æ€§ | è¯´æ˜ |
|------|------|
| `#[test]` | æ ‡è®°æµ‹è¯•å‡½æ•° |
| `#[ignore]` | å¿½ç•¥æµ‹è¯• |
| `#[should_panic]` | æœŸæœ› panic |
| `#[cfg(test)]` | æ¡ä»¶ç¼–è¯‘ |

---

**ç›¸å…³æ–‡æ¡£**:

- [é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ](./02_é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ.md)
- [ç›‘æ§å¯è§‚æµ‹æ€§å‚è€ƒ](./03_ç›‘æ§å¯è§‚æµ‹æ€§å‚è€ƒ.md)
- [Tier 2 æµ‹è¯•å®è·µ](../tier_02_guides/)
- [Tier 4 é«˜çº§æµ‹è¯•](../tier_04_advanced/)

---

**æœ€åæ›´æ–°**: 2025-10-24  
**è´¡çŒ®è€…**: Rust Documentation Team
