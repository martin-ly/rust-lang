# 测试框架完整参考

**最后更新**: 2025-10-24  
**适用版本**: Rust 1.90+  
**难度**: ⭐⭐⭐

---

## 📋 目录

- [测试框架完整参考](#测试框架完整参考)
  - [📋 目录](#-目录)
  - [1. Cargo Test 完整参考](#1-cargo-test-完整参考)
    - [1.1 基本命令](#11-基本命令)
    - [1.2 过滤与选择](#12-过滤与选择)
    - [1.3 环境变量](#13-环境变量)
    - [1.4 并行控制](#14-并行控制)
  - [2. 单元测试 API](#2-单元测试-api)
    - [2.1 测试属性](#21-测试属性)
    - [2.2 断言宏](#22-断言宏)
    - [2.3 测试模块组织](#23-测试模块组织)
    - [2.4 条件编译](#24-条件编译)
  - [3. 集成测试](#3-集成测试)
    - [3.1 集成测试结构](#31-集成测试结构)
    - [3.2 共享代码](#32-共享代码)
    - [3.3 测试外部 API](#33-测试外部-api)
  - [4. 性能测试 (Criterion)](#4-性能测试-criterion)
    - [4.1 基本配置](#41-基本配置)
    - [4.2 基准测试编写](#42-基准测试编写)
    - [4.3 高级配置](#43-高级配置)
    - [4.4 性能回归检测](#44-性能回归检测)
  - [5. 模糊测试 (cargo-fuzz)](#5-模糊测试-cargo-fuzz)
    - [5.1 安装与初始化](#51-安装与初始化)
    - [5.2 Fuzz Target 编写](#52-fuzz-target-编写)
    - [5.3 运行与分析](#53-运行与分析)
  - [6. 属性测试 (proptest)](#6-属性测试-proptest)
    - [6.1 基本使用](#61-基本使用)
    - [6.2 自定义策略](#62-自定义策略)
  - [7. Mock 与 Stub](#7-mock-与-stub)
    - [7.1 Mockall 框架](#71-mockall-框架)
    - [7.2 依赖注入模式](#72-依赖注入模式)
  - [8. 测试覆盖率](#8-测试覆盖率)
    - [8.1 Tarpaulin 配置](#81-tarpaulin-配置)
    - [8.2 LLVM-cov 使用](#82-llvm-cov-使用)
  - [9. 测试组织最佳实践](#9-测试组织最佳实践)
    - [9.1 文件结构](#91-文件结构)
    - [9.2 命名约定](#92-命名约定)
    - [9.3 测试金字塔](#93-测试金字塔)
  - [10. CI/CD 集成](#10-cicd-集成)
    - [10.1 GitHub Actions](#101-github-actions)
    - [10.2 缓存策略](#102-缓存策略)
  - [11. 故障排查](#11-故障排查)
    - [11.1 常见错误](#111-常见错误)
    - [11.2 调试技巧](#112-调试技巧)
  - [12. API 速查表](#12-api-速查表)
    - [12.1 cargo test 命令](#121-cargo-test-命令)
    - [12.2 断言宏](#122-断言宏)
    - [12.3 测试属性](#123-测试属性)

---

## 1. Cargo Test 完整参考

### 1.1 基本命令

```bash
# 运行所有测试
cargo test

# 运行特定测试
cargo test test_name

# 运行模块测试
cargo test module_name::

# 显示打印输出
cargo test -- --show-output

# 显示忽略的测试
cargo test -- --ignored

# 运行所有测试（包括忽略的）
cargo test -- --include-ignored
```

---

### 1.2 过滤与选择

```bash
# 运行文档测试
cargo test --doc

# 运行集成测试
cargo test --test integration_test

# 运行特定包的测试
cargo test -p package_name

# 运行库测试（不运行二进制测试）
cargo test --lib

# 运行二进制测试
cargo test --bin binary_name
```

---

### 1.3 环境变量

| 环境变量 | 说明 | 示例 |
|---------|------|------|
| `RUST_TEST_THREADS` | 并行测试线程数 | `RUST_TEST_THREADS=1 cargo test` |
| `RUST_TEST_NOCAPTURE` | 不捕获输出 | `RUST_TEST_NOCAPTURE=1 cargo test` |
| `RUST_BACKTRACE` | 显示堆栈跟踪 | `RUST_BACKTRACE=1 cargo test` |
| `RUST_LOG` | 日志级别 | `RUST_LOG=debug cargo test` |

---

### 1.4 并行控制

```bash
# 单线程运行（避免竞态）
cargo test -- --test-threads=1

# 自定义线程数
cargo test -- --test-threads=4

# 顺序运行特定测试
cargo test sequential_ -- --test-threads=1
```

---

## 2. 单元测试 API

### 2.1 测试属性

```rust
// 标记测试函数
#[test]
fn test_addition() {
    assert_eq!(2 + 2, 4);
}

// 忽略测试
#[test]
#[ignore]
fn expensive_test() {
    // 只在 cargo test -- --ignored 时运行
}

// 预期 panic
#[test]
#[should_panic]
fn test_panic() {
    panic!("Expected panic");
}

// 预期特定 panic 消息
#[test]
#[should_panic(expected = "divide by zero")]
fn test_division() {
    let _ = 1 / 0;
}

// 超时测试（需要 nightly）
#[test]
#[cfg(feature = "test-timeout")]
#[timeout(std::time::Duration::from_secs(5))]
fn test_with_timeout() {
    // 必须在 5 秒内完成
}
```

---

### 2.2 断言宏

**基本断言**:

```rust
#[test]
fn test_assertions() {
    // 相等断言
    assert_eq!(2 + 2, 4);
    assert_ne!(2 + 2, 5);
    
    // 布尔断言
    assert!(true);
    assert!(!false);
    
    // 自定义消息
    assert_eq!(2 + 2, 4, "Math is broken!");
    assert!(x > 0, "x must be positive, got {}", x);
}
```

**浮点数断言**:

```rust
#[test]
fn test_floats() {
    let a = 0.1 + 0.2;
    let b = 0.3;
    
    // ❌ 不推荐：直接相等比较
    // assert_eq!(a, b);
    
    // ✅ 推荐：使用 epsilon
    assert!((a - b).abs() < 1e-10);
    
    // 或使用 approx crate
    use approx::assert_relative_eq;
    assert_relative_eq!(a, b, epsilon = 1e-10);
}
```

**集合断言**:

```rust
#[test]
fn test_collections() {
    let v = vec![1, 2, 3];
    
    // 元素存在
    assert!(v.contains(&2));
    
    // 长度断言
    assert_eq!(v.len(), 3);
    
    // 使用 assert_matches (Rust 1.82+)
    assert!(matches!(v.first(), Some(&1)));
}
```

---

### 2.3 测试模块组织

**推荐结构**:

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
    
    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }
    
    // 嵌套测试模块
    mod edge_cases {
        use super::*;
        
        #[test]
        fn test_zero() {
            assert_eq!(add(0, 0), 0);
        }
    }
}
```

---

### 2.4 条件编译

```rust
// 仅在测试时编译
#[cfg(test)]
mod tests {
    // 测试代码
}

// 仅在特定平台测试
#[cfg(all(test, target_os = "linux"))]
mod linux_tests {
    // Linux 专用测试
}

// 基于 feature 的测试
#[cfg(all(test, feature = "advanced"))]
mod advanced_tests {
    // 高级功能测试
}
```

---

## 3. 集成测试

### 3.1 集成测试结构

**目录结构**:

```text
project/
├── src/
│   └── lib.rs
├── tests/
│   ├── integration_test.rs
│   ├── api_test.rs
│   └── common/
│       └── mod.rs  # 共享代码
└── Cargo.toml
```

**基本集成测试**:

```rust
// tests/integration_test.rs
use my_crate::{add, multiply};

#[test]
fn test_integration() {
    let result = add(2, 2);
    assert_eq!(result, 4);
    
    let result = multiply(result, 3);
    assert_eq!(result, 12);
}
```

---

### 3.2 共享代码

```rust
// tests/common/mod.rs
pub fn setup() -> TestContext {
    TestContext {
        // 初始化测试环境
    }
}

pub struct TestContext {
    // 共享测试状态
}

// tests/integration_test.rs
mod common;

#[test]
fn test_with_setup() {
    let ctx = common::setup();
    // 使用 ctx 进行测试
}
```

---

### 3.3 测试外部 API

```rust
// tests/api_test.rs
use my_crate::api::Client;

#[tokio::test]
async fn test_api_endpoint() {
    let client = Client::new("http://localhost:8080");
    
    let response = client.get("/users/1").await.unwrap();
    assert_eq!(response.status(), 200);
    
    let user: User = response.json().await.unwrap();
    assert_eq!(user.id, 1);
}
```

---

## 4. 性能测试 (Criterion)

### 4.1 基本配置

**Cargo.toml**:

```toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "my_benchmark"
harness = false
```

---

### 4.2 基准测试编写

**benches/my_benchmark.rs**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use my_crate::*;

// 简单基准测试
fn fibonacci_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });
}

// 参数化基准测试
fn sort_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("sorting");
    
    for size in [100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(size),
            size,
            |b, &size| {
                b.iter(|| {
                    let mut vec: Vec<i32> = (0..size).collect();
                    vec.sort();
                });
            },
        );
    }
    
    group.finish();
}

// 比较不同实现
fn algorithm_comparison(c: &mut Criterion) {
    let mut group = c.benchmark_group("algorithms");
    
    group.bench_function("quicksort", |b| {
        b.iter(|| quicksort(black_box(&mut test_data())))
    });
    
    group.bench_function("mergesort", |b| {
        b.iter(|| mergesort(black_box(&mut test_data())))
    });
    
    group.finish();
}

criterion_group!(benches, fibonacci_benchmark, sort_benchmark, algorithm_comparison);
criterion_main!(benches);
```

---

### 4.3 高级配置

```rust
use criterion::{Criterion, SamplingMode, BenchmarkGroup};
use std::time::Duration;

fn custom_criterion() -> Criterion {
    Criterion::default()
        .sample_size(1000)                    // 样本数量
        .measurement_time(Duration::from_secs(10))  // 测量时间
        .warm_up_time(Duration::from_secs(3))       // 预热时间
        .noise_threshold(0.05)                      // 噪声阈值
        .confidence_level(0.95)                     // 置信水平
        .significance_level(0.05)                   // 显著性水平
}

fn configured_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("custom");
    group.sampling_mode(SamplingMode::Flat);  // 采样模式
    
    // 测试代码
    
    group.finish();
}
```

---

### 4.4 性能回归检测

```bash
# 保存基线
cargo bench -- --save-baseline before

# 修改代码后
cargo bench -- --baseline before

# 比较结果
# Criterion 会自动显示性能变化百分比
```

---

## 5. 模糊测试 (cargo-fuzz)

### 5.1 安装与初始化

```bash
# 安装 cargo-fuzz
cargo install cargo-fuzz

# 初始化 fuzz 目标
cargo fuzz init

# 添加新的 fuzz 目标
cargo fuzz add fuzz_target_name
```

---

### 5.2 Fuzz Target 编写

**fuzz/fuzz_targets/fuzz_parser.rs**:

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use my_crate::parse;

fuzz_target!(|data: &[u8]| {
    // 尝试解析任意输入
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = parse(s);
    }
});

// 结构化模糊测试
use libfuzzer_sys::arbitrary::{Arbitrary, Unstructured};

#[derive(Arbitrary, Debug)]
struct Input {
    x: i32,
    y: i32,
    operation: Operation,
}

#[derive(Arbitrary, Debug)]
enum Operation {
    Add,
    Subtract,
    Multiply,
    Divide,
}

fuzz_target!(|input: Input| {
    let _ = calculate(input.x, input.y, input.operation);
});
```

---

### 5.3 运行与分析

```bash
# 运行模糊测试
cargo fuzz run fuzz_target_name

# 限制时间
cargo fuzz run fuzz_target_name -- -max_total_time=60

# 使用语料库
cargo fuzz run fuzz_target_name corpus/

# 最小化失败用例
cargo fuzz cmin fuzz_target_name

# 回放失败用例
cargo fuzz run fuzz_target_name crash-file
```

---

## 6. 属性测试 (proptest)

### 6.1 基本使用

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_addition_commutative(a: i32, b: i32) {
        prop_assert_eq!(a + b, b + a);
    }
    
    #[test]
    fn test_string_length(s in ".*") {
        prop_assert!(s.len() <= 1000);
    }
    
    #[test]
    fn test_vec_operations(v in prop::collection::vec(0..100, 0..10)) {
        prop_assert!(v.iter().all(|&x| x < 100));
    }
}
```

---

### 6.2 自定义策略

```rust
use proptest::prelude::*;

// 自定义生成器
fn my_strategy() -> impl Strategy<Value = MyType> {
    (0..100, ".*")
        .prop_map(|(id, name)| MyType { id, name })
}

proptest! {
    #[test]
    fn test_custom_type(value in my_strategy()) {
        prop_assert!(value.id < 100);
    }
}

// 条件生成
fn valid_email() -> impl Strategy<Value = String> {
    "[a-z0-9]+@[a-z0-9]+\\.[a-z]{2,}"
        .prop_filter("must be valid", |s| s.contains('@'))
}
```

---

## 7. Mock 与 Stub

### 7.1 Mockall 框架

**Cargo.toml**:

```toml
[dev-dependencies]
mockall = "0.12"
```

**使用示例**:

```rust
use mockall::{automock, predicate::*};

#[automock]
trait Database {
    fn get_user(&self, id: u32) -> Result<User, Error>;
    fn save_user(&mut self, user: &User) -> Result<(), Error>;
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_with_mock() {
        let mut mock = MockDatabase::new();
        
        // 设置期望
        mock.expect_get_user()
            .with(eq(1))
            .times(1)
            .returning(|_| Ok(User::default()));
        
        // 使用 mock
        let result = mock.get_user(1);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_sequence() {
        let mut mock = MockDatabase::new();
        
        let mut seq = Sequence::new();
        
        mock.expect_get_user()
            .times(1)
            .in_sequence(&mut seq)
            .returning(|_| Ok(User::default()));
        
        mock.expect_save_user()
            .times(1)
            .in_sequence(&mut seq)
            .returning(|_| Ok(()));
    }
}
```

---

### 7.2 依赖注入模式

```rust
// 使用 trait 实现依赖注入
pub trait Logger {
    fn log(&self, message: &str);
}

pub struct Service<L: Logger> {
    logger: L,
}

impl<L: Logger> Service<L> {
    pub fn new(logger: L) -> Self {
        Self { logger }
    }
    
    pub fn do_something(&self) {
        self.logger.log("doing something");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    struct TestLogger {
        messages: std::sync::Mutex<Vec<String>>,
    }
    
    impl Logger for TestLogger {
        fn log(&self, message: &str) {
            self.messages.lock().unwrap().push(message.to_string());
        }
    }
    
    #[test]
    fn test_service() {
        let logger = TestLogger {
            messages: std::sync::Mutex::new(vec![]),
        };
        
        let service = Service::new(&logger);
        service.do_something();
        
        assert_eq!(logger.messages.lock().unwrap().len(), 1);
    }
}
```

---

## 8. 测试覆盖率

### 8.1 Tarpaulin 配置

**tarpaulin.toml**:

```toml
[report]
coveralls = true
out = ["Html", "Lcov"]

[run]
exclude-files = ["tests/*", "benches/*"]
timeout = "5m"
follow-exec = false
```

**运行**:

```bash
# 安装
cargo install cargo-tarpaulin

# 运行覆盖率
cargo tarpaulin --out Html --output-dir coverage

# 排除特定代码
cargo tarpaulin --ignore-tests --exclude-files 'src/generated/*'
```

---

### 8.2 LLVM-cov 使用

```bash
# 安装 (Rust 1.60+)
rustup component add llvm-tools-preview
cargo install cargo-llvm-cov

# 生成报告
cargo llvm-cov --html

# 查看报告
cargo llvm-cov --open

# CI 友好格式
cargo llvm-cov --lcov --output-path lcov.info
```

---

## 9. 测试组织最佳实践

### 9.1 文件结构

**推荐结构**:

```text
src/
├── lib.rs
├── module1.rs    #[cfg(test)] mod tests {}
├── module2.rs    #[cfg(test)] mod tests {}
tests/
├── integration_test1.rs
├── integration_test2.rs
└── common/
    └── mod.rs
benches/
├── benchmark1.rs
└── benchmark2.rs
fuzz/
└── fuzz_targets/
    └── fuzz_target_1.rs
```

---

### 9.2 命名约定

```rust
// ✅ 好的命名
#[test]
fn test_add_positive_numbers() {}

#[test]
fn test_add_negative_numbers() {}

#[test]
fn test_add_zero() {}

// ❌ 不好的命名
#[test]
fn test1() {}

#[test]
fn test_stuff() {}
```

**命名模式**:

- `test_<function>_<scenario>`
- `test_<function>_returns_<expected>`
- `test_<function>_fails_when_<condition>`

---

### 9.3 测试金字塔

```text
              ╱ ╲
             ╱   ╲
            ╱ E2E ╲         少量（慢、脆弱）
           ╱───────╲
          ╱ 集成测试 ╲       中量（中速）
         ╱───────────╲
        ╱   单元测试   ╲     大量（快、稳定）
       ╱───────────────╲
```

**推荐比例**: 单元测试 70% | 集成测试 20% | E2E测试 10%

---

## 10. CI/CD 集成

### 10.1 GitHub Actions

**.github/workflows/test.yml**:

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Run tests
        run: cargo test --all-features
      
      - name: Run doctests
        run: cargo test --doc
      
      - name: Run benchmarks (check only)
        run: cargo bench --no-run

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Install tarpaulin
        run: cargo install cargo-tarpaulin
      
      - name: Generate coverage
        run: cargo tarpaulin --out Lcov
      
      - name: Upload to codecov
        uses: codecov/codecov-action@v3
```

---

### 10.2 缓存策略

```yaml
- name: Cache cargo registry
  uses: actions/cache@v3
  with:
    path: ~/.cargo/registry
    key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

- name: Cache cargo index
  uses: actions/cache@v3
  with:
    path: ~/.cargo/git
    key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

- name: Cache target directory
  uses: actions/cache@v3
  with:
    path: target
    key: ${{ runner.os }}-target-${{ hashFiles('**/Cargo.lock') }}
```

---

## 11. 故障排查

### 11.1 常见错误

**错误 1**: 测试间状态污染

```rust
// ❌ 错误：共享可变状态
static mut COUNTER: i32 = 0;

#[test]
fn test1() {
    unsafe { COUNTER += 1; }
    assert_eq!(unsafe { COUNTER }, 1); // 可能失败
}

// ✅ 正确：隔离状态
#[test]
fn test2() {
    let mut counter = 0;
    counter += 1;
    assert_eq!(counter, 1);
}
```

**错误 2**: 异步测试未等待

```rust
// ❌ 错误
#[test]
fn test_async_wrong() {
    async_function(); // 不会执行
}

// ✅ 正确
#[tokio::test]
async fn test_async_correct() {
    async_function().await;
}
```

---

### 11.2 调试技巧

```rust
// 打印调试信息
#[test]
fn test_with_debug() {
    let x = compute();
    dbg!(x); // 会在测试输出中显示
    assert_eq!(x, 42);
}

// 使用 --show-output 查看 println!
cargo test -- --show-output

// 运行单个测试并显示详细日志
RUST_LOG=debug cargo test test_name -- --nocapture

// 使用 #[ignore] 暂时跳过测试
#[test]
#[ignore = "需要外部服务"]
fn test_external_api() {
    // ...
}
```

---

## 12. API 速查表

### 12.1 cargo test 命令

| 命令 | 说明 |
|------|------|
| `cargo test` | 运行所有测试 |
| `cargo test name` | 运行匹配的测试 |
| `cargo test -- --show-output` | 显示输出 |
| `cargo test -- --ignored` | 运行忽略的测试 |
| `cargo test -- --test-threads=1` | 单线程运行 |
| `cargo test --doc` | 运行文档测试 |
| `cargo test --lib` | 仅运行库测试 |

---

### 12.2 断言宏

| 宏 | 用途 |
|----|------|
| `assert!(expr)` | 断言表达式为真 |
| `assert_eq!(a, b)` | 断言相等 |
| `assert_ne!(a, b)` | 断言不相等 |
| `debug_assert!(expr)` | Debug 断言 |

---

### 12.3 测试属性

| 属性 | 说明 |
|------|------|
| `#[test]` | 标记测试函数 |
| `#[ignore]` | 忽略测试 |
| `#[should_panic]` | 期望 panic |
| `#[cfg(test)]` | 条件编译 |

---

**相关文档**:

- [错误处理完整参考](./02_错误处理完整参考.md)
- [监控可观测性参考](./03_监控可观测性参考.md)
- [Tier 2 测试实践](../tier_02_guides/)
- [Tier 4 高级测试](../tier_04_advanced/)

---

**最后更新**: 2025-10-24  
**贡献者**: Rust Documentation Team
