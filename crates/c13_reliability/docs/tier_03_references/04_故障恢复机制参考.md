# æ•…éšœæ¢å¤æœºåˆ¶å®Œæ•´å‚è€ƒ

**æœ€åæ›´æ–°**: 2025-10-24  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦**: â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [æ•…éšœæ¢å¤æœºåˆ¶å®Œæ•´å‚è€ƒ](#æ•…éšœæ¢å¤æœºåˆ¶å®Œæ•´å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. é‡è¯•ç­–ç•¥](#1-é‡è¯•ç­–ç•¥)
    - [1.1 å›ºå®šå»¶è¿Ÿé‡è¯•](#11-å›ºå®šå»¶è¿Ÿé‡è¯•)
    - [1.2 æŒ‡æ•°é€€é¿](#12-æŒ‡æ•°é€€é¿)
    - [1.3 æŠ–åŠ¨ (Jitter)](#13-æŠ–åŠ¨-jitter)
  - [2. æ–­è·¯å™¨æ¨¡å¼ (Circuit Breaker)](#2-æ–­è·¯å™¨æ¨¡å¼-circuit-breaker)
    - [2.1 çŠ¶æ€æœº](#21-çŠ¶æ€æœº)
    - [2.2 åŸºæœ¬å®ç°](#22-åŸºæœ¬å®ç°)
    - [2.3 é«˜çº§é…ç½®](#23-é«˜çº§é…ç½®)
  - [3. è¶…æ—¶æ§åˆ¶](#3-è¶…æ—¶æ§åˆ¶)
    - [3.1 tokio è¶…æ—¶](#31-tokio-è¶…æ—¶)
    - [3.2 åˆ†å±‚è¶…æ—¶](#32-åˆ†å±‚è¶…æ—¶)
    - [3.3 è¶…æ—¶ä¼ æ’­](#33-è¶…æ—¶ä¼ æ’­)
  - [4. é™æµç®—æ³•](#4-é™æµç®—æ³•)
    - [4.1 ä»¤ç‰Œæ¡¶ (Token Bucket)](#41-ä»¤ç‰Œæ¡¶-token-bucket)
    - [4.2 æ¼æ¡¶ (Leaky Bucket)](#42-æ¼æ¡¶-leaky-bucket)
    - [4.3 å›ºå®šçª—å£è®¡æ•°](#43-å›ºå®šçª—å£è®¡æ•°)
    - [4.4 æ»‘åŠ¨çª—å£æ—¥å¿—](#44-æ»‘åŠ¨çª—å£æ—¥å¿—)
  - [5. é™çº§ç­–ç•¥](#5-é™çº§ç­–ç•¥)
    - [5.1 ç‰¹æ€§é™çº§](#51-ç‰¹æ€§é™çº§)
    - [5.2 ç¼“å­˜é™çº§](#52-ç¼“å­˜é™çº§)
    - [5.3 é»˜è®¤å€¼é™çº§](#53-é»˜è®¤å€¼é™çº§)
  - [6. èˆ±å£éš”ç¦» (Bulkhead)](#6-èˆ±å£éš”ç¦»-bulkhead)
    - [6.1 èµ„æºæ± éš”ç¦»](#61-èµ„æºæ± éš”ç¦»)
    - [6.2 çº¿ç¨‹æ± éš”ç¦»](#62-çº¿ç¨‹æ± éš”ç¦»)
  - [7. ä¼˜é›…å…³æœº](#7-ä¼˜é›…å…³æœº)
    - [7.1 ä¿¡å·å¤„ç†](#71-ä¿¡å·å¤„ç†)
    - [7.2 èµ„æºæ¸…ç†](#72-èµ„æºæ¸…ç†)
    - [7.3 è¯·æ±‚æ’ç©º](#73-è¯·æ±‚æ’ç©º)
  - [8. å¥åº·æ£€æŸ¥](#8-å¥åº·æ£€æŸ¥)
    - [8.1 æ´»æ€§æ£€æŸ¥ (Liveness)](#81-æ´»æ€§æ£€æŸ¥-liveness)
    - [8.2 å°±ç»ªæ£€æŸ¥ (Readiness)](#82-å°±ç»ªæ£€æŸ¥-readiness)
  - [9. ç»„åˆæ¨¡å¼](#9-ç»„åˆæ¨¡å¼)
    - [9.1 é‡è¯• + æ–­è·¯å™¨](#91-é‡è¯•--æ–­è·¯å™¨)
    - [9.2 è¶…æ—¶ + é‡è¯• + æ–­è·¯å™¨](#92-è¶…æ—¶--é‡è¯•--æ–­è·¯å™¨)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 ç­–ç•¥é€‰æ‹©](#101-ç­–ç•¥é€‰æ‹©)
    - [10.2 å‚æ•°è°ƒä¼˜](#102-å‚æ•°è°ƒä¼˜)
    - [10.3 ç›‘æ§æŒ‡æ ‡](#103-ç›‘æ§æŒ‡æ ‡)
  - [11. API é€ŸæŸ¥è¡¨](#11-api-é€ŸæŸ¥è¡¨)
    - [11.1 é‡è¯•åº“å¯¹æ¯”](#111-é‡è¯•åº“å¯¹æ¯”)
    - [11.2 é…ç½®å‚æ•°](#112-é…ç½®å‚æ•°)

---

## 1. é‡è¯•ç­–ç•¥

### 1.1 å›ºå®šå»¶è¿Ÿé‡è¯•

**åŸºæœ¬å®ç°**:

```rust
use std::time::Duration;

async fn retry_fixed<F, T, E>(
    mut operation: F,
    max_retries: usize,
    delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// ä½¿ç”¨
let result = retry_fixed(
    || fetch_data(),
    3,
    Duration::from_secs(1)
).await?;
```

---

### 1.2 æŒ‡æ•°é€€é¿

**ç®—æ³•**: `delay = base_delay * 2^attempt`

```rust
async fn retry_exponential<F, T, E>(
    mut operation: F,
    max_retries: usize,
    base_delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                let delay = base_delay * 2_u32.pow(attempts as u32);
                tokio::time::sleep(delay).await;
                attempts += 1;
            }
            Err(e) => return Err(e),
        }
    }
}

// ä½¿ç”¨
let result = retry_exponential(
    || fetch_data(),
    5,
    Duration::from_millis(100)
).await?;

// å»¶è¿Ÿåºåˆ—: 100ms, 200ms, 400ms, 800ms, 1600ms
```

---

### 1.3 æŠ–åŠ¨ (Jitter)

**ç›®çš„**: é¿å…"æƒŠç¾¤æ•ˆåº”"ï¼Œåˆ†æ•£é‡è¯•æ—¶é—´ã€‚

```rust
use rand::Rng;

fn exponential_backoff_with_jitter(
    attempt: u32,
    base_delay: Duration,
    max_delay: Duration,
) -> Duration {
    let exponential = base_delay * 2_u32.pow(attempt);
    let capped = exponential.min(max_delay);
    
    // Full jitter: 0 åˆ° capped ä¹‹é—´éšæœº
    let jitter = rand::thread_rng().gen_range(0..=capped.as_millis()) as u64;
    Duration::from_millis(jitter)
}

async fn retry_with_jitter<F, T, E>(
    mut operation: F,
    max_retries: usize,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    for attempt in 0..max_retries {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempt < max_retries - 1 => {
                let delay = exponential_backoff_with_jitter(
                    attempt as u32,
                    Duration::from_millis(100),
                    Duration::from_secs(10),
                );
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
    
    unreachable!()
}
```

---

## 2. æ–­è·¯å™¨æ¨¡å¼ (Circuit Breaker)

### 2.1 çŠ¶æ€æœº

```text
    [Closed] â”€â”€failure thresholdâ”€â”€> [Open]
        â†‘                              â”‚
        â”‚                              â”‚ timeout
        â”‚                              â†“
    [Half-Open] <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [Open]
        â”‚
        success threshold
        â”‚
        â†“
    [Closed]
```

**çŠ¶æ€è¯´æ˜**:

- **Closed**: æ­£å¸¸è¿è¡Œï¼Œè¯·æ±‚é€šè¿‡
- **Open**: å¿«é€Ÿå¤±è´¥ï¼Œç›´æ¥æ‹’ç»è¯·æ±‚
- **Half-Open**: å°è¯•æ¢å¤ï¼Œå…è®¸éƒ¨åˆ†è¯·æ±‚

---

### 2.2 åŸºæœ¬å®ç°

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone, PartialEq)]
enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

struct CircuitBreaker {
    state: Arc<Mutex<State>>,
    failure_threshold: usize,
    success_threshold: usize,
    timeout: Duration,
}

struct State {
    state: CircuitState,
    failure_count: usize,
    success_count: usize,
    last_failure_time: Option<Instant>,
}

impl CircuitBreaker {
    pub fn new(
        failure_threshold: usize,
        success_threshold: usize,
        timeout: Duration,
    ) -> Self {
        Self {
            state: Arc::new(Mutex::new(State {
                state: CircuitState::Closed,
                failure_count: 0,
                success_count: 0,
                last_failure_time: None,
            })),
            failure_threshold,
            success_threshold,
            timeout,
        }
    }
    
    pub async fn call<F, T, E>(&self, operation: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: FnOnce() -> Result<T, E>,
    {
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œ
        {
            let mut state = self.state.lock().unwrap();
            
            match state.state {
                CircuitState::Open => {
                    // æ£€æŸ¥æ˜¯å¦è¶…æ—¶ï¼Œå¯ä»¥å°è¯•æ¢å¤
                    if let Some(last_failure) = state.last_failure_time {
                        if last_failure.elapsed() > self.timeout {
                            state.state = CircuitState::HalfOpen;
                            state.success_count = 0;
                        } else {
                            return Err(CircuitBreakerError::Open);
                        }
                    }
                }
                _ => {}
            }
        }
        
        // æ‰§è¡Œæ“ä½œ
        match operation() {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(e) => {
                self.on_failure();
                Err(CircuitBreakerError::Operation(e))
            }
        }
    }
    
    fn on_success(&self) {
        let mut state = self.state.lock().unwrap();
        
        match state.state {
            CircuitState::HalfOpen => {
                state.success_count += 1;
                if state.success_count >= self.success_threshold {
                    state.state = CircuitState::Closed;
                    state.failure_count = 0;
                    state.success_count = 0;
                }
            }
            CircuitState::Closed => {
                state.failure_count = 0;
            }
            _ => {}
        }
    }
    
    fn on_failure(&self) {
        let mut state = self.state.lock().unwrap();
        
        match state.state {
            CircuitState::Closed => {
                state.failure_count += 1;
                if state.failure_count >= self.failure_threshold {
                    state.state = CircuitState::Open;
                    state.last_failure_time = Some(Instant::now());
                }
            }
            CircuitState::HalfOpen => {
                state.state = CircuitState::Open;
                state.last_failure_time = Some(Instant::now());
            }
            _ => {}
        }
    }
}

#[derive(Debug)]
enum CircuitBreakerError<E> {
    Open,
    Operation(E),
}

// ä½¿ç”¨
let breaker = CircuitBreaker::new(5, 2, Duration::from_secs(60));

match breaker.call(|| fetch_data()).await {
    Ok(data) => println!("Success: {:?}", data),
    Err(CircuitBreakerError::Open) => println!("Circuit breaker is open"),
    Err(CircuitBreakerError::Operation(e)) => println!("Operation failed: {:?}", e),
}
```

---

### 2.3 é«˜çº§é…ç½®

```rust
struct CircuitBreakerConfig {
    failure_threshold: usize,      // å¤±è´¥é˜ˆå€¼
    success_threshold: usize,      // æˆåŠŸé˜ˆå€¼
    timeout: Duration,             // Open çŠ¶æ€è¶…æ—¶
    half_open_max_calls: usize,    // Half-Open æœ€å¤§è°ƒç”¨æ•°
    error_rate_threshold: f64,     // é”™è¯¯ç‡é˜ˆå€¼ (0.0-1.0)
    min_requests: usize,           // æœ€å°è¯·æ±‚æ•°ï¼ˆè®¡ç®—é”™è¯¯ç‡ï¼‰
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            success_threshold: 2,
            timeout: Duration::from_secs(60),
            half_open_max_calls: 3,
            error_rate_threshold: 0.5,
            min_requests: 10,
        }
    }
}
```

---

## 3. è¶…æ—¶æ§åˆ¶

### 3.1 tokio è¶…æ—¶

```rust
use tokio::time::{timeout, Duration};

// åŸºæœ¬è¶…æ—¶
async fn with_timeout() -> Result<String, TimeoutError> {
    timeout(Duration::from_secs(5), fetch_data())
        .await
        .map_err(|_| TimeoutError)?
}

// å¤šä¸ªæ“ä½œçš„è¶…æ—¶
async fn multiple_timeouts() -> Result<(), Box<dyn std::error::Error>> {
    // å•ä¸ªæ“ä½œè¶…æ—¶
    let data1 = timeout(Duration::from_secs(2), fetch_data1()).await??;
    
    // å¦ä¸€ä¸ªæ“ä½œè¶…æ—¶
    let data2 = timeout(Duration::from_secs(3), fetch_data2()).await??;
    
    // æ€»è¶…æ—¶
    timeout(
        Duration::from_secs(10),
        process(data1, data2)
    ).await??;
    
    Ok(())
}
```

---

### 3.2 åˆ†å±‚è¶…æ—¶

```rust
struct TimeoutConfig {
    database: Duration,    // æ•°æ®åº“æŸ¥è¯¢è¶…æ—¶
    cache: Duration,       // ç¼“å­˜æ“ä½œè¶…æ—¶
    api: Duration,         // API è°ƒç”¨è¶…æ—¶
    total: Duration,       // æ€»è¶…æ—¶
}

async fn process_with_layered_timeout(
    config: &TimeoutConfig
) -> Result<Response, Error> {
    // æ€»è¶…æ—¶
    timeout(config.total, async {
        // ç¼“å­˜æŸ¥è¯¢è¶…æ—¶
        let cached = timeout(config.cache, check_cache()).await.ok().flatten();
        
        if let Some(data) = cached {
            return Ok(data);
        }
        
        // æ•°æ®åº“æŸ¥è¯¢è¶…æ—¶
        let db_data = timeout(config.database, query_database())
            .await
            .map_err(|_| Error::DatabaseTimeout)??;
        
        // API è°ƒç”¨è¶…æ—¶
        let api_data = timeout(config.api, call_api())
            .await
            .map_err(|_| Error::ApiTimeout)??;
        
        Ok(combine(db_data, api_data))
    }).await
    .map_err(|_| Error::TotalTimeout)?
}
```

---

### 3.3 è¶…æ—¶ä¼ æ’­

```rust
use tokio::time::{Instant, timeout_at};

async fn parent_operation(deadline: Instant) -> Result<(), Error> {
    // ä¼ æ’­æˆªæ­¢æ—¶é—´ç»™å­æ“ä½œ
    let result1 = timeout_at(deadline, child_operation1()).await?;
    
    // è®¡ç®—å‰©ä½™æ—¶é—´
    let remaining = deadline.saturating_duration_since(Instant::now());
    
    if remaining.is_zero() {
        return Err(Error::Timeout);
    }
    
    let result2 = timeout_at(deadline, child_operation2()).await?;
    
    Ok(())
}

// ä½¿ç”¨
let deadline = Instant::now() + Duration::from_secs(10);
parent_operation(deadline).await?;
```

---

## 4. é™æµç®—æ³•

### 4.1 ä»¤ç‰Œæ¡¶ (Token Bucket)

**ç®—æ³•**: å›ºå®šé€Ÿç‡ç”Ÿæˆä»¤ç‰Œï¼Œè¯·æ±‚æ¶ˆè€—ä»¤ç‰Œã€‚

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct TokenBucket {
    capacity: usize,           // æ¡¶å®¹é‡
    tokens: Arc<Mutex<f64>>,   // å½“å‰ä»¤ç‰Œæ•°
    rate: f64,                 // ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆä¸ª/ç§’ï¼‰
    last_update: Arc<Mutex<Instant>>,
}

impl TokenBucket {
    pub fn new(capacity: usize, rate: f64) -> Self {
        Self {
            capacity,
            tokens: Arc::new(Mutex::new(capacity as f64)),
            rate,
            last_update: Arc::new(Mutex::new(Instant::now())),
        }
    }
    
    pub fn acquire(&self, tokens: usize) -> bool {
        self.refill();
        
        let mut current_tokens = self.tokens.lock().unwrap();
        
        if *current_tokens >= tokens as f64 {
            *current_tokens -= tokens as f64;
            true
        } else {
            false
        }
    }
    
    fn refill(&self) {
        let now = Instant::now();
        let mut last_update = self.last_update.lock().unwrap();
        let elapsed = now.duration_since(*last_update).as_secs_f64();
        
        if elapsed > 0.0 {
            let mut tokens = self.tokens.lock().unwrap();
            *tokens = (*tokens + elapsed * self.rate).min(self.capacity as f64);
            *last_update = now;
        }
    }
    
    pub async fn wait_for(&self, tokens: usize) {
        loop {
            if self.acquire(tokens) {
                return;
            }
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    }
}

// ä½¿ç”¨
let limiter = TokenBucket::new(100, 10.0);  // å®¹é‡100ï¼Œé€Ÿç‡10/ç§’

if limiter.acquire(1) {
    // å¤„ç†è¯·æ±‚
} else {
    // æ‹’ç»è¯·æ±‚
}

// æˆ–ç­‰å¾…ä»¤ç‰Œ
limiter.wait_for(1).await;
// ç»§ç»­å¤„ç†
```

---

### 4.2 æ¼æ¡¶ (Leaky Bucket)

**ç®—æ³•**: å›ºå®šé€Ÿç‡æµå‡ºè¯·æ±‚ã€‚

```rust
use std::collections::VecDeque;

struct LeakyBucket {
    capacity: usize,
    rate: Duration,  // æµå‡ºé—´éš”
    queue: Arc<Mutex<VecDeque<Instant>>>,
}

impl LeakyBucket {
    pub fn new(capacity: usize, rate: Duration) -> Self {
        Self {
            capacity,
            rate,
            queue: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    pub fn try_acquire(&self) -> bool {
        self.leak();
        
        let mut queue = self.queue.lock().unwrap();
        
        if queue.len() < self.capacity {
            queue.push_back(Instant::now());
            true
        } else {
            false
        }
    }
    
    fn leak(&self) {
        let now = Instant::now();
        let mut queue = self.queue.lock().unwrap();
        
        while let Some(first) = queue.front() {
            if now.duration_since(*first) >= self.rate {
                queue.pop_front();
            } else {
                break;
            }
        }
    }
}
```

---

### 4.3 å›ºå®šçª—å£è®¡æ•°

```rust
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

struct FixedWindowCounter {
    limit: usize,
    window_size: Duration,
    windows: Arc<Mutex<HashMap<u64, usize>>>,
}

impl FixedWindowCounter {
    pub fn new(limit: usize, window_size: Duration) -> Self {
        Self {
            limit,
            window_size,
            windows: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub fn try_acquire(&self) -> bool {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        let window = now / self.window_size.as_secs();
        
        let mut windows = self.windows.lock().unwrap();
        
        // æ¸…ç†æ—§çª—å£
        windows.retain(|&k, _| k >= window);
        
        let count = windows.entry(window).or_insert(0);
        
        if *count < self.limit {
            *count += 1;
            true
        } else {
            false
        }
    }
}
```

---

### 4.4 æ»‘åŠ¨çª—å£æ—¥å¿—

```rust
use std::collections::VecDeque;

struct SlidingWindowLog {
    limit: usize,
    window_size: Duration,
    log: Arc<Mutex<VecDeque<Instant>>>,
}

impl SlidingWindowLog {
    pub fn new(limit: usize, window_size: Duration) -> Self {
        Self {
            limit,
            window_size,
            log: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    pub fn try_acquire(&self) -> bool {
        let now = Instant::now();
        let mut log = self.log.lock().unwrap();
        
        // æ¸…ç†çª—å£å¤–çš„è®°å½•
        while let Some(first) = log.front() {
            if now.duration_since(*first) > self.window_size {
                log.pop_front();
            } else {
                break;
            }
        }
        
        if log.len() < self.limit {
            log.push_back(now);
            true
        } else {
            false
        }
    }
}
```

---

## 5. é™çº§ç­–ç•¥

### 5.1 ç‰¹æ€§é™çº§

```rust
async fn get_user_profile(user_id: i32) -> Result<UserProfile, Error> {
    // å°è¯•å®Œæ•´åŠŸèƒ½
    match get_full_profile(user_id).await {
        Ok(profile) => Ok(profile),
        Err(_) => {
            // é™çº§ï¼šè¿”å›åŸºæœ¬ä¿¡æ¯
            get_basic_profile(user_id).await
        }
    }
}

async fn search_products(query: &str) -> Result<Vec<Product>, Error> {
    // å°è¯•é«˜çº§æœç´¢ï¼ˆåŒ…å«æ¨èï¼‰
    match advanced_search(query).await {
        Ok(results) => Ok(results),
        Err(_) => {
            // é™çº§ï¼šåŸºæœ¬æœç´¢ï¼ˆæ— æ¨èï¼‰
            basic_search(query).await
        }
    }
}
```

---

### 5.2 ç¼“å­˜é™çº§

```rust
async fn get_data(id: i32) -> Result<Data, Error> {
    // 1. å°è¯•ä¸»æ•°æ®æº
    match fetch_from_primary(id).await {
        Ok(data) => {
            // æ›´æ–°ç¼“å­˜
            let _ = update_cache(id, &data).await;
            return Ok(data);
        }
        Err(_) => {}
    }
    
    // 2. å°è¯•ä»ç¼“å­˜è¯»å–
    if let Ok(cached) = get_from_cache(id).await {
        return Ok(cached);
    }
    
    // 3. å°è¯•å¤‡ä»½æ•°æ®æº
    if let Ok(data) = fetch_from_backup(id).await {
        return Ok(data);
    }
    
    // 4. è¿”å›é»˜è®¤å€¼
    Ok(Data::default())
}
```

---

### 5.3 é»˜è®¤å€¼é™çº§

```rust
async fn get_recommendations(user_id: i32) -> Vec<Product> {
    // å°è¯•ä¸ªæ€§åŒ–æ¨è
    if let Ok(personalized) = get_personalized_recommendations(user_id).await {
        return personalized;
    }
    
    // é™çº§ï¼šçƒ­é—¨æ¨è
    if let Ok(popular) = get_popular_products().await {
        return popular;
    }
    
    // æœ€ç»ˆé™çº§ï¼šé™æ€é»˜è®¤åˆ—è¡¨
    get_default_products()
}
```

---

## 6. èˆ±å£éš”ç¦» (Bulkhead)

### 6.1 èµ„æºæ± éš”ç¦»

```rust
use tokio::sync::Semaphore;

struct ResourcePool {
    semaphore: Arc<Semaphore>,
}

impl ResourcePool {
    pub fn new(capacity: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(capacity)),
        }
    }
    
    pub async fn acquire<F, T>(&self, operation: F) -> Result<T, Error>
    where
        F: FnOnce() -> T,
    {
        let _permit = self.semaphore.acquire().await.map_err(|_| Error::PoolExhausted)?;
        Ok(operation())
    }
}

// ä¸ºä¸åŒæœåŠ¡åˆ›å»ºç‹¬ç«‹èµ„æºæ± 
struct ServicePools {
    database_pool: ResourcePool,
    cache_pool: ResourcePool,
    external_api_pool: ResourcePool,
}

impl ServicePools {
    pub fn new() -> Self {
        Self {
            database_pool: ResourcePool::new(50),
            cache_pool: ResourcePool::new(100),
            external_api_pool: ResourcePool::new(20),
        }
    }
}

// ä½¿ç”¨
async fn handle_request(pools: &ServicePools) -> Result<Response, Error> {
    // æ•°æ®åº“æŸ¥è¯¢ä½¿ç”¨ç‹¬ç«‹æ± 
    let db_result = pools.database_pool
        .acquire(|| query_database())
        .await?;
    
    // å¤–éƒ¨ API è°ƒç”¨ä½¿ç”¨ç‹¬ç«‹æ± 
    let api_result = pools.external_api_pool
        .acquire(|| call_external_api())
        .await?;
    
    Ok(combine(db_result, api_result))
}
```

---

### 6.2 çº¿ç¨‹æ± éš”ç¦»

```rust
use tokio::runtime::{Builder, Runtime};

struct IsolatedExecutors {
    cpu_intensive: Runtime,
    io_intensive: Runtime,
    default: Runtime,
}

impl IsolatedExecutors {
    pub fn new() -> Self {
        Self {
            // CPU å¯†é›†å‹ï¼šçº¿ç¨‹æ•° = CPU æ ¸å¿ƒæ•°
            cpu_intensive: Builder::new_multi_thread()
                .worker_threads(num_cpus::get())
                .thread_name("cpu-pool")
                .build()
                .unwrap(),
            
            // I/O å¯†é›†å‹ï¼šæ›´å¤šçº¿ç¨‹
            io_intensive: Builder::new_multi_thread()
                .worker_threads(num_cpus::get() * 2)
                .thread_name("io-pool")
                .build()
                .unwrap(),
            
            // é»˜è®¤
            default: Runtime::new().unwrap(),
        }
    }
    
    pub fn spawn_cpu_task<F>(&self, task: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        self.cpu_intensive.spawn(task);
    }
    
    pub fn spawn_io_task<F>(&self, task: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        self.io_intensive.spawn(task);
    }
}
```

---

## 7. ä¼˜é›…å…³æœº

### 7.1 ä¿¡å·å¤„ç†

```rust
use tokio::signal;

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };
    
    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };
    
    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();
    
    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    
    println!("Shutting down gracefully");
}
```

---

### 7.2 èµ„æºæ¸…ç†

```rust
struct Application {
    database: DatabasePool,
    cache: Cache,
    background_tasks: JoinSet<()>,
}

impl Application {
    pub async fn run(mut self) {
        tokio::select! {
            _ = self.serve() => {},
            _ = shutdown_signal() => {
                println!("Shutdown signal received");
            }
        }
        
        // ä¼˜é›…å…³æœº
        self.shutdown().await;
    }
    
    async fn shutdown(mut self) {
        println!("Stopping background tasks...");
        self.background_tasks.shutdown().await;
        
        println!("Closing database connections...");
        self.database.close().await;
        
        println!("Flushing cache...");
        self.cache.flush().await;
        
        println!("Shutdown complete");
    }
}
```

---

### 7.3 è¯·æ±‚æ’ç©º

```rust
use tokio::sync::watch;

struct Server {
    shutdown_tx: watch::Sender<bool>,
}

impl Server {
    pub async fn run(self) {
        let (shutdown_tx, mut shutdown_rx) = watch::channel(false);
        
        // å¯åŠ¨æœåŠ¡å™¨
        let server = axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
            .serve(app.into_make_service())
            .with_graceful_shutdown(async move {
                shutdown_rx.changed().await.ok();
            });
        
        tokio::select! {
            _ = server => {},
            _ = shutdown_signal() => {
                println!("Initiating graceful shutdown");
                // é€šçŸ¥æ‰€æœ‰å¤„ç†å™¨åœæ­¢æ¥å—æ–°è¯·æ±‚
                shutdown_tx.send(true).ok();
                
                // ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆï¼ˆæœ€å¤š30ç§’ï¼‰
                tokio::time::sleep(Duration::from_secs(30)).await;
            }
        }
    }
}
```

---

## 8. å¥åº·æ£€æŸ¥

### 8.1 æ´»æ€§æ£€æŸ¥ (Liveness)

```rust
async fn liveness_check() -> impl IntoResponse {
    // æ£€æŸ¥åº”ç”¨æ˜¯å¦æ´»ç€
    // ç®€å•æ£€æŸ¥ï¼Œä¸ä¾èµ–å¤–éƒ¨æœåŠ¡
    (StatusCode::OK, "OK")
}
```

---

### 8.2 å°±ç»ªæ£€æŸ¥ (Readiness)

```rust
async fn readiness_check(state: Arc<AppState>) -> impl IntoResponse {
    // æ£€æŸ¥æ‰€æœ‰ä¾èµ–æ˜¯å¦å°±ç»ª
    let mut checks = HashMap::new();
    
    // æ•°æ®åº“æ£€æŸ¥
    checks.insert("database", check_database(&state.db).await);
    
    // ç¼“å­˜æ£€æŸ¥
    checks.insert("cache", check_cache(&state.cache).await);
    
    // å¤–éƒ¨æœåŠ¡æ£€æŸ¥
    checks.insert("external_api", check_external_api().await);
    
    let all_healthy = checks.values().all(|&v| v);
    
    let status = if all_healthy {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    
    (status, Json(json!({
        "status": if all_healthy { "ready" } else { "not ready" },
        "checks": checks,
    })))
}

async fn check_database(pool: &DatabasePool) -> bool {
    pool.acquire().await.is_ok()
}

async fn check_cache(cache: &Cache) -> bool {
    cache.ping().await.is_ok()
}
```

---

## 9. ç»„åˆæ¨¡å¼

### 9.1 é‡è¯• + æ–­è·¯å™¨

```rust
async fn resilient_call<F, T, E>(
    breaker: &CircuitBreaker,
    operation: F,
) -> Result<T, Error>
where
    F: Fn() -> Result<T, E>,
{
    retry_exponential(
        || {
            breaker.call(&operation)
        },
        3,
        Duration::from_millis(100)
    ).await
}
```

---

### 9.2 è¶…æ—¶ + é‡è¯• + æ–­è·¯å™¨

```rust
async fn fully_resilient_call<F, Fut, T>(
    breaker: &CircuitBreaker,
    mut operation: F,
) -> Result<T, Error>
where
    F: FnMut() -> Fut,
    Fut: Future<Output = Result<T, Error>>,
{
    retry_with_jitter(
        || async {
            breaker.call(|| async {
                timeout(Duration::from_secs(5), operation())
                    .await
                    .map_err(|_| Error::Timeout)?
            }).await
        },
        3
    ).await
}
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 ç­–ç•¥é€‰æ‹©

| åœºæ™¯ | æ¨èç­–ç•¥ |
|------|---------|
| ç¬æ—¶ç½‘ç»œæ•…éšœ | é‡è¯• (æŒ‡æ•°é€€é¿ + æŠ–åŠ¨) |
| ä¸‹æ¸¸æœåŠ¡ä¸ç¨³å®š | æ–­è·¯å™¨ |
| é˜²æ­¢é›ªå´© | æ–­è·¯å™¨ + èˆ±å£ |
| API é™æµ | ä»¤ç‰Œæ¡¶ / æ¼æ¡¶ |
| æœåŠ¡é™çº§ | ç¼“å­˜ + é»˜è®¤å€¼ |

---

### 10.2 å‚æ•°è°ƒä¼˜

**é‡è¯•å‚æ•°**:

- æœ€å¤§é‡è¯•æ¬¡æ•°: 3-5 æ¬¡
- åŸºç¡€å»¶è¿Ÿ: 100-500ms
- æœ€å¤§å»¶è¿Ÿ: 10-30s

**æ–­è·¯å™¨å‚æ•°**:

- å¤±è´¥é˜ˆå€¼: 5-10 æ¬¡
- è¶…æ—¶æ—¶é—´: 60s
- åŠå¼€æœ€å¤§è°ƒç”¨: 3-5 æ¬¡

**è¶…æ—¶å‚æ•°**:

- æ•°æ®åº“æŸ¥è¯¢: 2-5s
- HTTP è¯·æ±‚: 10-30s
- æ€»è¶…æ—¶: æ“ä½œæ€»å’Œ + ç¼“å†²

---

### 10.3 ç›‘æ§æŒ‡æ ‡

```rust
use metrics::{counter, histogram, gauge};

// é‡è¯•æŒ‡æ ‡
counter!("retry_attempts_total", "operation" => "fetch_data").increment(1);
histogram!("retry_delay_seconds").record(delay.as_secs_f64());

// æ–­è·¯å™¨æŒ‡æ ‡
gauge!("circuit_breaker_state", "service" => "api").set(state_value);
counter!("circuit_breaker_state_changes", "service" => "api").increment(1);

// è¶…æ—¶æŒ‡æ ‡
counter!("timeout_total", "operation" => "query").increment(1);
histogram!("operation_duration_seconds", "operation" => "query")
    .record(duration.as_secs_f64());

// é™æµæŒ‡æ ‡
counter!("rate_limit_hits_total").increment(1);
gauge!("rate_limit_available_tokens").set(tokens);
```

---

## 11. API é€ŸæŸ¥è¡¨

### 11.1 é‡è¯•åº“å¯¹æ¯”

| åº“ | ç‰¹ç‚¹ | ç”¨é€” |
|----|------|------|
| `again` | ç®€å•é‡è¯• | åŸºæœ¬åœºæ™¯ |
| `retry` | å¯é…ç½®ç­–ç•¥ | é€šç”¨åœºæ™¯ |
| `tower::retry` | æœåŠ¡ä¸­é—´ä»¶ | å¾®æœåŠ¡ |

---

### 11.2 é…ç½®å‚æ•°

| å‚æ•° | å…¸å‹å€¼ | è¯´æ˜ |
|------|--------|------|
| `max_retries` | 3-5 | æœ€å¤§é‡è¯•æ¬¡æ•° |
| `base_delay` | 100ms | åˆå§‹å»¶è¿Ÿ |
| `max_delay` | 10s | æœ€å¤§å»¶è¿Ÿ |
| `timeout` | 5s | å•æ¬¡è¶…æ—¶ |
| `circuit_breaker_threshold` | 5 | æ–­è·¯å™¨é˜ˆå€¼ |

---

**ç›¸å…³æ–‡æ¡£**:

- [æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ](./01_æµ‹è¯•æ¡†æ¶å®Œæ•´å‚è€ƒ.md)
- [é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ](./02_é”™è¯¯å¤„ç†å®Œæ•´å‚è€ƒ.md)
- [ç›‘æ§å¯è§‚æµ‹æ€§å‚è€ƒ](./03_ç›‘æ§å¯è§‚æµ‹æ€§å‚è€ƒ.md)
- [Tier 2 æ•…éšœæ¢å¤å®è·µ](../tier_02_guides/)

---

**æœ€åæ›´æ–°**: 2025-10-24  
**è´¡çŒ®è€…**: Rust Documentation Team
