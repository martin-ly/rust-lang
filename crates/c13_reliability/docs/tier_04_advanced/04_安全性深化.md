# 04 安全性深化

## 目录

- [1. 概述](#1-概述)
- [2. 内存安全](#2-内存安全)
  - [2.1 Use-After-Free (UAF)](#21-use-after-free-uaf)
  - [2.2 缓冲区溢出](#22-缓冲区溢出)
  - [2.3 Unsafe Rust 最佳实践](#23-unsafe-rust-最佳实践)
  - [2.4 内存安全验证](#24-内存安全验证)
- [3. 并发安全](#3-并发安全)
  - [3.1 数据竞争](#31-数据竞争)
  - [3.2 死锁](#32-死锁)
  - [3.3 Send/Sync 正确性](#33-sendsync-正确性)
  - [3.4 并发安全验证](#34-并发安全验证)
- [4. 密码学最佳实践](#4-密码学最佳实践)
  - [4.1 安全随机数](#41-安全随机数)
  - [4.2 密钥管理](#42-密钥管理)
  - [4.3 常见加密场景](#43-常见加密场景)
  - [4.4 密码学陷阱](#44-密码学陷阱)
- [5. 安全审计](#5-安全审计)
  - [5.1 cargo-audit](#51-cargo-audit)
  - [5.2 cargo-deny](#52-cargo-deny)
  - [5.3 漏洞缓解](#53-漏洞缓解)
  - [5.4 供应链安全](#54-供应链安全)
- [6. 实战案例分析](#6-实战案例分析)
  - [6.1 Actix-web UAF 漏洞](#61-actix-web-uaf-漏洞)
  - [6.2 Tokio 并发安全问题](#62-tokio-并发安全问题)
  - [6.3 RustCrypto 密码学缺陷](#63-rustcrypto-密码学缺陷)
- [7. 安全加固清单](#7-安全加固清单)
- [8. 相关资源](#8-相关资源)

---

## 1. 概述

**安全性深化**是 Rust 可靠性工程的核心主题。尽管 Rust 的所有权系统在编译期阻止了大部分内存安全问题，但在使用 `unsafe` 代码、并发编程、密码学操作等场景下，仍需要深入理解安全原理并应用最佳实践。

**本文档涵盖**：

- **内存安全**：UAF、缓冲区溢出、unsafe 代码审查
- **并发安全**：数据竞争、死锁、Send/Sync 正确性
- **密码学**：安全随机数、密钥管理、常见陷阱
- **安全审计**：cargo-audit、cargo-deny、漏洞缓解
- **实战案例**：真实 CVE 分析与修复

**适用场景**：

- ✅ 开发安全关键系统（金融、医疗、国防）
- ✅ 编写 unsafe 代码或 FFI 绑定
- ✅ 进行安全审计或代码审查
- ✅ 设计密码学协议或实现

**学习路径**：

1. 深入理解内存安全漏洞模式
2. 掌握并发安全验证方法
3. 学习密码学最佳实践
4. 应用自动化安全审计工具
5. 分析真实漏洞案例

---

## 2. 内存安全

### 2.1 Use-After-Free (UAF)

**UAF 定义**：访问已释放的内存，是 C/C++ 中最常见的漏洞之一。Rust 的所有权系统在 **safe** 代码中完全防止 UAF，但 **unsafe** 代码中仍可能出现。

#### 2.1.1 Rust Safe 代码中的 UAF 防护

```rust
fn safe_no_uaf() {
    let v = vec![1, 2, 3];
    let first = &v[0]; // 借用 v
    // drop(v); // ❌ 编译错误: cannot move out of `v` because it is borrowed
    println!("First: {}", first);
}
```

**编译器保证**：

- 借用检查器阻止在引用存活时移动或释放所有者
- 生命周期系统确保引用不超过数据的生命周期

#### 2.1.2 Unsafe 代码中的 UAF 风险

```rust
use std::ptr;

// ❌ 错误示例：UAF 漏洞
unsafe fn uaf_example() {
    let mut v = vec![1, 2, 3];
    let ptr = v.as_ptr(); // 获取裸指针
    drop(v); // 释放 v
    // ⚠️ 此时 ptr 指向已释放的内存
    println!("Dangling pointer: {:?}", *ptr); // 未定义行为！
}
```

**正确做法**：

```rust
unsafe fn safe_pointer_usage() {
    let v = vec![1, 2, 3];
    let ptr = v.as_ptr();
    
    // ✅ 确保 v 的生命周期覆盖 ptr 的使用
    println!("Value: {}", *ptr);
    
    // v 在此处被 drop
}

// ✅ 使用 Pin 防止自引用结构的 UAF
use std::pin::Pin;
use std::marker::PhantomPinned;

struct SelfRef {
    data: String,
    ptr: *const String,
    _pin: PhantomPinned,
}

impl SelfRef {
    fn new(data: String) -> Pin<Box<Self>> {
        let mut boxed = Box::pin(SelfRef {
            data,
            ptr: std::ptr::null(),
            _pin: PhantomPinned,
        });
        
        // 安全地设置自引用指针
        unsafe {
            let ptr: *const String = &(*boxed).data;
            let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).ptr = ptr;
        }
        
        boxed
    }
    
    fn get_data(&self) -> &str {
        unsafe { &*self.ptr }
    }
}
```

#### 2.1.3 UAF 检测工具

```toml
# Cargo.toml
[dependencies]
# Miri: Rust 的解释器，可检测 UB
# 运行: cargo +nightly miri test

[profile.dev]
# AddressSanitizer (需要 nightly)
# RUSTFLAGS="-Z sanitizer=address" cargo run
```

**运行 Miri 检测 UAF**：

```bash
# 安装 Miri
rustup +nightly component add miri

# 运行测试
cargo +nightly miri test
```

**Miri 会捕获的问题**：

- Use-after-free
- 双重释放
- 无效指针解引用
- 数据竞争（需要 `-Zmiri-track-raw-pointers`）

---

### 2.2 缓冲区溢出

#### 2.2.1 Rust 自动防护

```rust
fn safe_bounds_check() {
    let arr = [1, 2, 3];
    // arr[10] // ❌ 编译期错误（常量索引）或运行时 panic（变量索引）
    
    // ✅ Safe 访问
    if let Some(val) = arr.get(10) {
        println!("Value: {}", val);
    } else {
        println!("Out of bounds!");
    }
}
```

#### 2.2.2 Unsafe 索引的风险

```rust
unsafe fn unchecked_access() {
    let arr = [1, 2, 3];
    // ⚠️ 跳过边界检查，性能提升但有风险
    let val = *arr.get_unchecked(1); // ✅ OK
    // let bad = *arr.get_unchecked(10); // ❌ 未定义行为！
}
```

**最佳实践**：

```rust
fn safe_unchecked_pattern(arr: &[i32], idx: usize) -> i32 {
    // ✅ 先验证，再使用 unchecked
    if idx < arr.len() {
        unsafe { *arr.get_unchecked(idx) }
    } else {
        panic!("Index out of bounds");
    }
}

// ✅ 使用迭代器避免手动索引
fn sum_safe(arr: &[i32]) -> i32 {
    arr.iter().sum()
}
```

#### 2.2.3 FFI 缓冲区溢出

```rust
use std::ffi::CString;
use std::os::raw::c_char;

extern "C" {
    fn unsafe_c_function(buf: *mut c_char, len: usize);
}

// ❌ 错误示例：缓冲区溢出
fn bad_ffi() {
    let mut buf = vec![0u8; 10];
    unsafe {
        // C 函数可能写入超过 10 字节！
        unsafe_c_function(buf.as_mut_ptr() as *mut c_char, 100);
    }
}

// ✅ 正确做法：传递正确的缓冲区大小
fn safe_ffi() {
    let mut buf = vec![0u8; 100];
    unsafe {
        unsafe_c_function(buf.as_mut_ptr() as *mut c_char, buf.len());
    }
    
    // ✅ 验证 C 函数返回的数据
    let result = CString::new(buf).expect("Invalid C string");
}
```

---

### 2.3 Unsafe Rust 最佳实践

#### 2.3.1 最小化 Unsafe 范围

```rust
// ❌ 不好：整个函数标记为 unsafe
unsafe fn bad_design(v: Vec<i32>) -> i32 {
    let ptr = v.as_ptr();
    let first = *ptr;
    let second = *ptr.add(1);
    first + second
}

// ✅ 好：仅 unsafe 必要的操作
fn good_design(v: &[i32]) -> Option<i32> {
    if v.len() < 2 {
        return None;
    }
    
    // Safe 代码验证前提条件
    let first = v[0];
    
    // ✅ Unsafe 块最小化
    let second = unsafe {
        // SAFETY: 已验证 v.len() >= 2
        *v.as_ptr().add(1)
    };
    
    Some(first + second)
}
```

#### 2.3.2 编写 SAFETY 注释

```rust
unsafe fn write_unchecked<T>(slice: &mut [T], idx: usize, value: T) {
    // SAFETY: 调用者必须保证：
    // 1. idx < slice.len()
    // 2. slice[idx] 当前未被其他线程访问
    // 3. T 实现了 Copy 或者这是最后一次访问旧值
    *slice.get_unchecked_mut(idx) = value;
}

// ✅ 包装为 safe 接口
fn write_checked<T>(slice: &mut [T], idx: usize, value: T) -> Result<(), &'static str> {
    if idx >= slice.len() {
        return Err("Index out of bounds");
    }
    
    unsafe {
        // SAFETY: 已验证 idx < slice.len()
        write_unchecked(slice, idx, value);
    }
    
    Ok(())
}
```

#### 2.3.3 Unsafe 代码审查清单

**内存安全检查项**：

```rust
// ✅ 检查清单
// 1. 所有裸指针解引用前是否验证了有效性？
// 2. 生命周期是否正确（指针不超过数据生命周期）？
// 3. 是否有潜在的数据竞争（多线程访问）？
// 4. Unsafe 代码是否被 safe 接口正确封装？
// 5. 是否有完整的 SAFETY 注释？

struct UnsafeWrapper {
    ptr: *mut u8,
    len: usize,
}

impl UnsafeWrapper {
    // ✅ Safe 构造函数
    fn new(size: usize) -> Self {
        let layout = std::alloc::Layout::array::<u8>(size).unwrap();
        let ptr = unsafe { std::alloc::alloc(layout) };
        
        if ptr.is_null() {
            std::alloc::handle_alloc_error(layout);
        }
        
        Self { ptr, len: size }
    }
    
    // ✅ Safe 访问方法
    fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len {
            return None;
        }
        
        unsafe {
            // SAFETY: 已验证 idx < len，且 ptr 在构造时分配
            Some(*self.ptr.add(idx))
        }
    }
}

impl Drop for UnsafeWrapper {
    fn drop(&mut self) {
        unsafe {
            // SAFETY: ptr 来自 alloc，len 是原始分配大小
            let layout = std::alloc::Layout::array::<u8>(self.len).unwrap();
            std::alloc::dealloc(self.ptr, layout);
        }
    }
}

// ✅ 实现 Send/Sync（如果合适）
unsafe impl Send for UnsafeWrapper {}
unsafe impl Sync for UnsafeWrapper {}
// SAFETY: 
// - Send: 所有权转移是安全的，因为 Drop 正确释放资源
// - Sync: 不提供内部可变性，多线程共享引用是安全的
```

---

### 2.4 内存安全验证

#### 2.4.1 自动化测试

```rust
#[cfg(test)]
mod memory_safety_tests {
    use super::*;
    
    #[test]
    fn test_no_uaf() {
        let wrapper = UnsafeWrapper::new(10);
        assert_eq!(wrapper.get(5), Some(0));
        drop(wrapper);
        // ✅ 编译器防止访问已 drop 的 wrapper
    }
    
    #[test]
    fn test_bounds_check() {
        let wrapper = UnsafeWrapper::new(5);
        assert_eq!(wrapper.get(10), None); // ✅ 正确返回 None
    }
    
    // ✅ 使用 Miri 检测 UB
    #[test]
    #[cfg_attr(miri, ignore)] // Miri 下某些测试可能不支持
    fn test_with_miri() {
        // cargo +nightly miri test
        let mut v = vec![1, 2, 3];
        let ptr = v.as_ptr();
        unsafe {
            assert_eq!(*ptr, 1);
        }
    }
}
```

#### 2.4.2 Sanitizers

```bash
# AddressSanitizer (检测内存错误)
RUSTFLAGS="-Z sanitizer=address" cargo +nightly run

# ThreadSanitizer (检测数据竞争)
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly run

# LeakSanitizer (检测内存泄漏)
RUSTFLAGS="-Z sanitizer=leak" cargo +nightly run
```

**示例输出**（AddressSanitizer）：

```text
==12345==ERROR: AddressSanitizer: heap-use-after-free on address 0x60300000eff0
READ of size 4 at 0x60300000eff0 thread T0
    #0 main src/main.rs:10
```

---

## 3. 并发安全

### 3.1 数据竞争

**数据竞争定义**：两个或多个线程同时访问同一内存位置，且至少一个是写操作，且没有同步机制。

#### 3.1.1 Rust 的编译期防护

```rust
use std::sync::Arc;
use std::thread;

fn no_data_race() {
    let counter = Arc::new(std::sync::Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap()); // ✅ 总是 10
}
```

#### 3.1.2 Atomic 操作

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn atomic_counter() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                // ✅ 原子操作，无数据竞争
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", counter.load(Ordering::Relaxed)); // ✅ 总是 10000
}
```

**内存序选择指南**：

| Ordering | 用途 | 性能 | 保证 |
|----------|------|------|------|
| `Relaxed` | 计数器、统计 | 最快 | 无同步，仅原子性 |
| `Acquire` | 读锁、消费数据 | 中等 | 防止重排（读之后） |
| `Release` | 写锁、发布数据 | 中等 | 防止重排（写之前） |
| `AcqRel` | 读-修改-写 | 中等 | Acquire + Release |
| `SeqCst` | 需要全局顺序 | 最慢 | 顺序一致性 |

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

fn ordering_example() {
    let flag = Arc::new(AtomicBool::new(false));
    let data = Arc::new(AtomicUsize::new(0));
    
    let flag_clone = Arc::clone(&flag);
    let data_clone = Arc::clone(&data);
    
    // 写线程
    let writer = thread::spawn(move || {
        data_clone.store(42, Ordering::Relaxed);
        // ✅ Release: 确保上面的 store 对读线程可见
        flag_clone.store(true, Ordering::Release);
    });
    
    // 读线程
    let reader = thread::spawn(move || {
        // ✅ Acquire: 确保能看到 Release 之前的所有写入
        while !flag.load(Ordering::Acquire) {
            std::hint::spin_loop();
        }
        assert_eq!(data.load(Ordering::Relaxed), 42);
    });
    
    writer.join().unwrap();
    reader.join().unwrap();
}
```

#### 3.1.3 检测数据竞争

```bash
# ThreadSanitizer (TSan)
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly run

# Loom (轻量级并发测试框架)
# Cargo.toml
[dev-dependencies]
loom = "0.7"
```

**Loom 示例**：

```rust
#[cfg(test)]
mod tests {
    use loom::sync::Arc;
    use loom::sync::atomic::{AtomicUsize, Ordering};
    use loom::thread;
    
    #[test]
    fn test_concurrent_increment() {
        loom::model(|| {
            let counter = Arc::new(AtomicUsize::new(0));
            
            let handles: Vec<_> = (0..2).map(|_| {
                let counter = Arc::clone(&counter);
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::Relaxed);
                })
            }).collect();
            
            for handle in handles {
                handle.join().unwrap();
            }
            
            let final_count = counter.load(Ordering::Relaxed);
            assert_eq!(final_count, 2); // ✅ Loom 验证所有可能的交错
        });
    }
}
```

---

### 3.2 死锁

#### 3.2.1 死锁示例

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// ❌ 经典死锁
fn deadlock_example() {
    let lock_a = Arc::new(Mutex::new(0));
    let lock_b = Arc::new(Mutex::new(0));
    
    let lock_a1 = Arc::clone(&lock_a);
    let lock_b1 = Arc::clone(&lock_b);
    
    let t1 = thread::spawn(move || {
        let _a = lock_a1.lock().unwrap(); // 线程 1 持有 A
        thread::sleep(std::time::Duration::from_millis(10));
        let _b = lock_b1.lock().unwrap(); // 等待 B (死锁!)
    });
    
    let t2 = thread::spawn(move || {
        let _b = lock_b.lock().unwrap(); // 线程 2 持有 B
        thread::sleep(std::time::Duration::from_millis(10));
        let _a = lock_a.lock().unwrap(); // 等待 A (死锁!)
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
}
```

#### 3.2.2 死锁防护策略

**策略 1：锁排序**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn lock_ordering() {
    let lock_a = Arc::new(Mutex::new(0));
    let lock_b = Arc::new(Mutex::new(0));
    
    // ✅ 所有线程按相同顺序获取锁
    let acquire_locks = |a: &Mutex<i32>, b: &Mutex<i32>| {
        let _guard_a = a.lock().unwrap(); // 总是先锁 A
        let _guard_b = b.lock().unwrap(); // 再锁 B
    };
    
    let lock_a1 = Arc::clone(&lock_a);
    let lock_b1 = Arc::clone(&lock_b);
    
    let t1 = thread::spawn(move || {
        acquire_locks(&lock_a1, &lock_b1);
    });
    
    let t2 = thread::spawn(move || {
        acquire_locks(&lock_a, &lock_b); // 相同顺序
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
}
```

**策略 2：`try_lock`**

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn try_lock_pattern() {
    let lock_a = Arc::new(Mutex::new(0));
    let lock_b = Arc::new(Mutex::new(0));
    
    let lock_a1 = Arc::clone(&lock_a);
    let lock_b1 = Arc::clone(&lock_b);
    
    let t1 = thread::spawn(move || {
        loop {
            if let Ok(_guard_a) = lock_a1.try_lock() {
                // ✅ 尝试获取第二个锁
                if let Ok(_guard_b) = lock_b1.try_lock() {
                    println!("Thread 1 acquired both locks");
                    break;
                }
                // ❌ 获取失败，释放第一个锁并重试
            }
            thread::sleep(Duration::from_millis(1));
        }
    });
    
    let t2 = thread::spawn(move || {
        loop {
            if let Ok(_guard_b) = lock_b.try_lock() {
                if let Ok(_guard_a) = lock_a.try_lock() {
                    println!("Thread 2 acquired both locks");
                    break;
                }
            }
            thread::sleep(Duration::from_millis(1));
        }
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
}
```

**策略 3：使用 `parking_lot`**

```toml
[dependencies]
parking_lot = "0.12"
```

```rust
use parking_lot::{Mutex, deadlock};
use std::thread;
use std::time::Duration;

fn deadlock_detection() {
    // ✅ 启动死锁检测线程
    thread::spawn(move || {
        loop {
            thread::sleep(Duration::from_secs(1));
            let deadlocks = deadlock::check_deadlock();
            if !deadlocks.is_empty() {
                println!("Deadlocks detected: {}", deadlocks.len());
                for (i, threads) in deadlocks.iter().enumerate() {
                    println!("Deadlock #{}", i);
                    for t in threads {
                        println!("Thread: {:?}", t.thread_id());
                    }
                }
            }
        }
    });
    
    // 业务代码...
}
```

---

### 3.3 Send/Sync 正确性

#### 3.3.1 Send 和 Sync 的含义

| Trait | 含义 | 示例 |
|-------|------|------|
| `Send` | 可安全跨线程**转移所有权** | `Vec<T>`, `String`, `Arc<T>` |
| `Sync` | 可安全跨线程**共享引用** | `&T`, `Arc<T>`, `Mutex<T>` |

**编译器自动实现规则**：

- 如果所有字段都是 `Send`，则类型自动实现 `Send`
- 如果所有字段都是 `Sync`，则类型自动实现 `Sync`

#### 3.3.2 不安全的 Send/Sync 实现

```rust
use std::cell::Cell;

// ❌ Cell 不是 Sync（内部可变性不安全）
struct BadWrapper {
    cell: Cell<i32>,
}

// ❌ 错误：手动实现 Sync 是不安全的
// unsafe impl Sync for BadWrapper {}

// ✅ 正确做法：使用 Mutex 包装
struct GoodWrapper {
    cell: std::sync::Mutex<i32>,
}

unsafe impl Sync for GoodWrapper {}
// SAFETY: Mutex 提供了同步，多线程访问是安全的
```

#### 3.3.3 裸指针的 Send/Sync

```rust
use std::ptr::NonNull;

// ❌ 裸指针默认不是 Send/Sync
struct RawPointerWrapper {
    ptr: *mut i32,
}

// ✅ 如果确定安全，手动实现
unsafe impl Send for RawPointerWrapper {}
unsafe impl Sync for RawPointerWrapper {}
// SAFETY:
// 1. ptr 指向的数据没有被其他线程访问
// 2. 或者 ptr 指向的数据是线程安全的 (如 AtomicI32)

// ✅ 更好的做法：使用 NonNull + PhantomData
use std::marker::PhantomData;

struct SafeWrapper<T> {
    ptr: NonNull<T>,
    _marker: PhantomData<T>, // 继承 T 的 Send/Sync
}

unsafe impl<T: Send> Send for SafeWrapper<T> {}
unsafe impl<T: Sync> Sync for SafeWrapper<T> {}
```

---

### 3.4 并发安全验证

#### 3.4.1 Loom 深度测试

```rust
#[cfg(test)]
#[cfg(loom)]
mod loom_tests {
    use loom::sync::Arc;
    use loom::sync::Mutex;
    use loom::thread;
    
    #[test]
    fn test_mutex_correctness() {
        loom::model(|| {
            let lock = Arc::new(Mutex::new(0));
            
            let handles: Vec<_> = (0..2).map(|_| {
                let lock = Arc::clone(&lock);
                thread::spawn(move || {
                    let mut guard = lock.lock().unwrap();
                    *guard += 1;
                })
            }).collect();
            
            for h in handles {
                h.join().unwrap();
            }
            
            let final_value = *lock.lock().unwrap();
            assert_eq!(final_value, 2);
        });
    }
}
```

**运行 Loom 测试**：

```bash
# 需要在 Cargo.toml 中配置 loom feature
cargo test --features loom --release
```

---

## 4. 密码学最佳实践

### 4.1 安全随机数

#### 4.1.1 正确使用 `rand`

```toml
[dependencies]
rand = "0.8"
getrandom = "0.2"
```

```rust
use rand::{Rng, thread_rng};
use rand::distributions::Alphanumeric;

fn generate_secure_token() -> String {
    // ✅ 使用 thread_rng (基于 getrandom)
    let token: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(32)
        .map(char::from)
        .collect();
    
    token
}

// ❌ 错误示例：使用不安全的 RNG
use rand::rngs::SmallRng;
use rand::SeedableRng;

fn insecure_random() {
    let mut rng = SmallRng::seed_from_u64(12345); // ❌ 可预测的种子
    let value: u64 = rng.gen();
    // ⚠️ 不要用于安全关键场景！
}
```

#### 4.1.2 密码学安全的随机数

```toml
[dependencies]
rand = "0.8"
```

```rust
use rand::RngCore;
use rand::rngs::OsRng;

fn generate_key() -> [u8; 32] {
    let mut key = [0u8; 32];
    // ✅ OsRng 使用操作系统的 CSPRNG
    OsRng.fill_bytes(&mut key);
    key
}

// ✅ 生成安全的随机密码
fn generate_password(length: usize) -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                            abcdefghijklmnopqrstuvwxyz\
                            0123456789!@#$%^&*";
    
    let mut rng = OsRng;
    (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}
```

---

### 4.2 密钥管理

#### 4.2.1 密钥派生

```toml
[dependencies]
argon2 = "0.5"
```

```rust
use argon2::{Argon2, PasswordHasher, PasswordVerifier};
use argon2::password_hash::{SaltString, PasswordHash};
use rand::rngs::OsRng;

// ✅ 使用 Argon2 派生密钥
fn hash_password(password: &str) -> String {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    
    argon2
        .hash_password(password.as_bytes(), &salt)
        .expect("Failed to hash password")
        .to_string()
}

fn verify_password(password: &str, hash: &str) -> bool {
    let parsed_hash = PasswordHash::new(hash).expect("Invalid hash");
    Argon2::default()
        .verify_password(password.as_bytes(), &parsed_hash)
        .is_ok()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_password_hashing() {
        let password = "MySecurePassword123!";
        let hash = hash_password(password);
        
        assert!(verify_password(password, &hash));
        assert!(!verify_password("WrongPassword", &hash));
    }
}
```

#### 4.2.2 密钥存储

```rust
use std::fs;
use std::path::Path;

// ❌ 不要硬编码密钥
const API_KEY: &str = "sk_live_abc123..."; // ⚠️ 危险！

// ✅ 从环境变量读取
fn load_api_key() -> Result<String, std::env::VarError> {
    std::env::var("API_KEY")
}

// ✅ 从安全配置文件读取
fn load_key_from_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
    // 确保文件权限为 0600 (仅所有者可读写)
    let key = fs::read(path)?;
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = fs::metadata(path)?;
        let perms = metadata.permissions();
        if perms.mode() & 0o777 != 0o600 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                "Key file must have 0600 permissions",
            ));
        }
    }
    
    Ok(key)
}
```

#### 4.2.3 密钥擦除

```rust
use zeroize::Zeroize;

#[derive(Zeroize)]
#[zeroize(drop)]
struct SecretKey {
    key: [u8; 32],
}

impl SecretKey {
    fn new(key: [u8; 32]) -> Self {
        Self { key }
    }
    
    fn as_bytes(&self) -> &[u8] {
        &self.key
    }
}

// ✅ Drop 时自动擦除
fn secure_key_handling() {
    let key = SecretKey::new([42u8; 32]);
    // 使用 key...
    
    // key 在此处 drop，内存被清零
}
```

---

### 4.3 常见加密场景

#### 4.3.1 对称加密 (AES-GCM)

```toml
[dependencies]
aes-gcm = "0.10"
```

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, KeyInit, OsRng};

fn encrypt_data(plaintext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, aes_gcm::Error> {
    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(key));
    
    // ✅ 每次加密使用不同的 nonce
    let nonce = Nonce::from_slice(b"unique_nonce"); // ⚠️ 实际应用中应随机生成
    
    cipher.encrypt(nonce, plaintext)
}

fn decrypt_data(ciphertext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, aes_gcm::Error> {
    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(key));
    let nonce = Nonce::from_slice(b"unique_nonce");
    
    cipher.decrypt(nonce, ciphertext)
}
```

#### 4.3.2 非对称加密 (RSA)

```toml
[dependencies]
rsa = "0.9"
```

```rust
use rsa::{RsaPrivateKey, RsaPublicKey, Pkcs1v15Encrypt};
use rsa::pkcs8::{EncodePrivateKey, EncodePublicKey};
use rand::rngs::OsRng;

fn generate_keypair() -> (RsaPrivateKey, RsaPublicKey) {
    let mut rng = OsRng;
    let bits = 2048;
    
    let private_key = RsaPrivateKey::new(&mut rng, bits)
        .expect("Failed to generate key");
    let public_key = RsaPublicKey::from(&private_key);
    
    (private_key, public_key)
}

fn rsa_encrypt(public_key: &RsaPublicKey, data: &[u8]) -> Vec<u8> {
    let mut rng = OsRng;
    public_key
        .encrypt(&mut rng, Pkcs1v15Encrypt, data)
        .expect("Encryption failed")
}

fn rsa_decrypt(private_key: &RsaPrivateKey, ciphertext: &[u8]) -> Vec<u8> {
    private_key
        .decrypt(Pkcs1v15Encrypt, ciphertext)
        .expect("Decryption failed")
}
```

#### 4.3.3 数字签名 (Ed25519)

```toml
[dependencies]
ed25519-dalek = "2.0"
```

```rust
use ed25519_dalek::{Keypair, Signature, Signer, Verifier};
use rand::rngs::OsRng;

fn sign_message(message: &[u8]) -> (Signature, Keypair) {
    let mut csprng = OsRng;
    let keypair = Keypair::generate(&mut csprng);
    
    let signature = keypair.sign(message);
    (signature, keypair)
}

fn verify_signature(message: &[u8], signature: &Signature, public_key: &ed25519_dalek::PublicKey) -> bool {
    public_key.verify(message, signature).is_ok()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_signature() {
        let message = b"Hello, world!";
        let (signature, keypair) = sign_message(message);
        
        assert!(verify_signature(message, &signature, &keypair.public));
        assert!(!verify_signature(b"Tampered", &signature, &keypair.public));
    }
}
```

---

### 4.4 密码学陷阱

#### 4.4.1 时序攻击

```rust
// ❌ 错误示例：时序攻击漏洞
fn insecure_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    
    // ⚠️ 一旦发现不同立即返回，泄露信息
    for (x, y) in a.iter().zip(b.iter()) {
        if x != y {
            return false;
        }
    }
    
    true
}

// ✅ 正确做法：常数时间比较
use subtle::ConstantTimeEq;

fn secure_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    
    a.ct_eq(b).into()
}
```

#### 4.4.2 Nonce 重用

```rust
// ❌ 错误示例：重用 nonce
fn bad_encryption(key: &[u8; 32]) {
    let nonce = [0u8; 12]; // ⚠️ 固定 nonce
    
    // 多次加密使用相同 nonce，破坏安全性！
    for _ in 0..10 {
        encrypt_data(b"secret", key);
    }
}

// ✅ 正确做法：每次生成新 nonce
use rand::RngCore;

fn good_encryption(key: &[u8; 32]) {
    for _ in 0..10 {
        let mut nonce = [0u8; 12];
        OsRng.fill_bytes(&mut nonce);
        // 加密...
    }
}
```

---

## 5. 安全审计

### 5.1 cargo-audit

#### 5.1.1 安装和使用

```bash
# 安装
cargo install cargo-audit

# 扫描依赖漏洞
cargo audit

# 自动修复（升级到安全版本）
cargo audit fix
```

**示例输出**：

```text
    Fetching advisory database from `https://github.com/RustSec/advisory-db.git`
      Loaded 523 security advisories (from /home/user/.cargo/advisory-db)
    Scanning Cargo.lock for vulnerabilities (123 crate dependencies)

Crate:    time
Version:  0.1.44
Warning:  Potential segfault in `time` crate
ID:       RUSTSEC-2020-0071
Solution: Upgrade to >= 0.2.23
```

#### 5.1.2 CI 集成

```yaml
# .github/workflows/security.yml
name: Security Audit

on:
  push:
    branches: [main]
  pull_request:
  schedule:
    - cron: '0 0 * * *' # 每天运行

jobs:
  security_audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
```

---

### 5.2 cargo-deny

#### 5.2.1 配置文件

```toml
# deny.toml
[advisories]
vulnerability = "deny"
unmaintained = "warn"
notice = "warn"

[licenses]
unlicensed = "deny"
allow = ["MIT", "Apache-2.0", "BSD-3-Clause"]
deny = ["GPL-3.0"]

[bans]
multiple-versions = "warn"
deny = [
    { name = "openssl", version = "<1.1" }
]

[sources]
unknown-registry = "deny"
unknown-git = "deny"
```

#### 5.2.2 运行检查

```bash
# 安装
cargo install cargo-deny

# 运行所有检查
cargo deny check

# 仅检查漏洞
cargo deny check advisories

# 仅检查许可证
cargo deny check licenses
```

---

### 5.3 漏洞缓解

#### 5.3.1 依赖固定

```toml
# Cargo.toml
[dependencies]
# ❌ 不要使用 * 或宽泛的版本范围
serde = "*" # 危险！

# ✅ 固定次版本号
serde = "1.0.193" # 明确版本
# 或者
serde = "~1.0.193" # 仅允许补丁更新
```

#### 5.3.2 供应链验证

```bash
# 使用 cargo-crev 进行代码审查
cargo install cargo-crev
cargo crev repo fetch all
cargo crev crate verify serde
```

---

### 5.4 供应链安全

#### 5.4.1 Vendor 本地化

```bash
# 将所有依赖复制到 vendor/
cargo vendor

# 配置 Cargo 使用本地依赖
mkdir -p .cargo
cat > .cargo/config.toml <<EOF
[source.crates-io]
replace-with = "vendored-sources"

[source.vendored-sources]
directory = "vendor"
EOF
```

#### 5.4.2 审计第三方依赖

```rust
// 使用 cargo-tree 分析依赖树
// cargo tree

// 使用 cargo-geiger 检测 unsafe 代码
// cargo install cargo-geiger
// cargo geiger
```

**cargo-geiger 输出示例**：

```text
Metric output format: x/y
    x = unsafe code used by the build
    y = total unsafe code found in the crate

Crates:
    geiger 0.11.2 (0/0)
    └── cargo 0.66.0 (15/42)
        ├── anyhow 1.0.68 (0/0)
        ├── curl 0.4.44 (12/35) ⚠️
```

---

## 6. 实战案例分析

### 6.1 Actix-web UAF 漏洞

**CVE-2018-20996** (已修复)

#### 6.1.1 漏洞描述

Actix-web 1.x 在处理 HTTP 请求时，使用了 `unsafe` 代码来管理请求生命周期，导致在某些情况下出现 Use-After-Free。

**简化复现**：

```rust
// 漏洞代码（简化）
struct Request {
    inner: *mut HttpRequest,
}

impl Request {
    unsafe fn new(req: *mut HttpRequest) -> Self {
        Self { inner: req }
    }
    
    fn get_body(&self) -> &[u8] {
        unsafe {
            // ⚠️ 没有验证 inner 是否仍然有效
            (*self.inner).body()
        }
    }
}

// drop(request); // 释放
// request.get_body(); // UAF!
```

#### 6.1.2 修复方案

```rust
// 使用 Arc + Mutex 替代裸指针
use std::sync::{Arc, Mutex};

struct Request {
    inner: Arc<Mutex<HttpRequest>>,
}

impl Request {
    fn new(req: HttpRequest) -> Self {
        Self {
            inner: Arc::new(Mutex::new(req)),
        }
    }
    
    fn get_body(&self) -> Vec<u8> {
        let guard = self.inner.lock().unwrap();
        guard.body().to_vec()
    }
}
```

---

### 6.2 Tokio 并发安全问题

**RUSTSEC-2021-0072** (Tokio < 1.8.4)

#### 6.2.1 漏洞描述

Tokio 的 `io::Take` 在某些情况下可能导致数据竞争。

**简化示例**：

```rust
// 漏洞代码模式
use tokio::io::{self, AsyncReadExt};

async fn vulnerable_read() {
    let reader = io::repeat(42).take(10);
    // ⚠️ 多个任务并发读取可能导致数据竞争
}
```

#### 6.2.2 修复方案

升级到 Tokio >= 1.8.4，或使用显式同步：

```rust
use tokio::io::{self, AsyncReadExt};
use tokio::sync::Mutex;
use std::sync::Arc;

async fn safe_read() {
    let reader = Arc::new(Mutex::new(io::repeat(42).take(10)));
    
    // ✅ 使用 Mutex 保护并发访问
    let mut guard = reader.lock().await;
    let mut buf = vec![0u8; 10];
    guard.read_exact(&mut buf).await.unwrap();
}
```

---

### 6.3 RustCrypto 密码学缺陷

**RUSTSEC-2021-0053** (aes-soft < 0.6.4)

#### 6.3.1 漏洞描述

`aes-soft` 实现存在时序侧信道攻击，可能泄露密钥信息。

#### 6.3.2 缓解措施

```rust
// ❌ 使用有漏洞的版本
// aes-soft = "0.6.3"

// ✅ 升级到修复版本
// aes-soft = "0.6.4"

// ✅ 或使用硬件加速的 AES-NI
use aes::Aes256;
use aes::cipher::{BlockEncrypt, KeyInit};

fn use_hardware_aes() {
    let key = [0u8; 32];
    let cipher = Aes256::new_from_slice(&key).unwrap();
    // 使用 AES-NI 指令（如果 CPU 支持）
}
```

---

## 7. 安全加固清单

### 7.1 代码层面

- [ ] 最小化 `unsafe` 代码，所有 `unsafe` 块都有 `SAFETY` 注释
- [ ] 使用 `cargo clippy` 并启用 `pedantic` lint
- [ ] 运行 `cargo audit` 检查依赖漏洞
- [ ] 使用 `cargo geiger` 识别依赖中的 `unsafe` 代码
- [ ] 启用 `#![forbid(unsafe_code)]`（如果可能）
- [ ] 所有输入验证都在边界处进行
- [ ] 密码学操作使用经过审计的库（RustCrypto, ring）

### 7.2 并发层面

- [ ] 使用 Loom 或 TSan 测试并发代码
- [ ] 避免手动实现 `Send`/`Sync`，除非有明确的 `SAFETY` 注释
- [ ] 使用 `parking_lot` 的死锁检测
- [ ] 所有共享状态都使用同步原语保护
- [ ] 避免在持有锁时调用外部函数

### 7.3 密码学层面

- [ ] 使用 `OsRng` 生成密码学安全的随机数
- [ ] 密钥派生使用 Argon2 或 PBKDF2
- [ ] 敏感数据使用 `zeroize` 擦除
- [ ] Nonce 每次加密都唯一
- [ ] 密钥不硬编码在代码中
- [ ] 使用常数时间比较验证 MAC/签名

### 7.4 供应链层面

- [ ] 配置 `deny.toml` 限制许可证和依赖
- [ ] 定期运行 `cargo update` 和 `cargo audit`
- [ ] 固定关键依赖的版本
- [ ] 使用 `cargo vendor` 本地化依赖
- [ ] 审查新依赖的代码质量和维护状态

### 7.5 部署层面

- [ ] 启用编译优化（`-C opt-level=3`）
- [ ] 启用 LTO (`lto = true`)
- [ ] 剥离调试符号（`strip = true`）
- [ ] 使用容器隔离（Docker + Seccomp/AppArmor）
- [ ] 最小化攻击面（删除未使用的依赖和 feature）

---

## 8. 相关资源

### 8.1 安全工具

- **Miri**: Rust 解释器，检测未定义行为
- **cargo-audit**: 依赖漏洞扫描
- **cargo-deny**: 许可证/依赖策略检查
- **cargo-geiger**: 识别 unsafe 代码
- **Loom**: 并发正确性测试
- **ThreadSanitizer**: 数据竞争检测

### 8.2 密码学库

- **RustCrypto**: 纯 Rust 密码学实现
- **ring**: 高性能密码学库（BoringSSL 绑定）
- **argon2**: 密码散列
- **zeroize**: 安全内存擦除

### 8.3 学习资源

- [RustSec Advisory Database](https://rustsec.org/)
- [Rust Security Response WG](https://www.rust-lang.org/governance/wgs/wg-security-response)
- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)
- [The Rustonomicon (Unsafe Rust)](https://doc.rust-lang.org/nomicon/)

---

**下一步**：

- → 阅读 [05_监控与可观测性.md](./05_监控与可观测性.md) 了解生产监控
- → 参考 [C13 主索引](../../02_主索引导航.md) 探索其他主题
- → 实践 [Tier 2 实践指南](../../tier_02_guides/README.md) 巩固知识

---

*最后更新: 2025-10-23*
*版本: 1.0.0*
*作者: Rust 学习系统团队*
