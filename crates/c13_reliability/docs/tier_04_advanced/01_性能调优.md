# C13 Reliability - Tier 4: æ€§èƒ½è°ƒä¼˜

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 60 åˆ†é’Ÿ  
> **éš¾åº¦**: â­â­â­â­â­ (ä¸“å®¶çº§)

---

## ğŸ“‹ ç›®å½•

- [C13 Reliability - Tier 4: æ€§èƒ½è°ƒä¼˜](#c13-reliability---tier-4-æ€§èƒ½è°ƒä¼˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ€§èƒ½è°ƒä¼˜æ¦‚è¿°](#1-æ€§èƒ½è°ƒä¼˜æ¦‚è¿°)
    - [1.1 æ€§èƒ½ä¼˜åŒ–é‡‘å­—å¡”](#11-æ€§èƒ½ä¼˜åŒ–é‡‘å­—å¡”)
    - [1.2 æµ‹é‡é©±åŠ¨ä¼˜åŒ–](#12-æµ‹é‡é©±åŠ¨ä¼˜åŒ–)
  - [2. å†…å­˜ä¼˜åŒ–](#2-å†…å­˜ä¼˜åŒ–)
    - [2.1 å †ä¸æ ˆä¼˜åŒ–](#21-å †ä¸æ ˆä¼˜åŒ–)
    - [2.2 å†…å­˜æ± æŠ€æœ¯](#22-å†…å­˜æ± æŠ€æœ¯)
    - [2.3 é›¶æ‹·è´æŠ€æœ¯](#23-é›¶æ‹·è´æŠ€æœ¯)
    - [2.4 å†…å­˜å¯¹é½ä¸ç¼“å­˜è¡Œ](#24-å†…å­˜å¯¹é½ä¸ç¼“å­˜è¡Œ)
  - [3. å¹¶å‘æ€§èƒ½ä¼˜åŒ–](#3-å¹¶å‘æ€§èƒ½ä¼˜åŒ–)
    - [3.1 çº¿ç¨‹æ± ä¼˜åŒ–](#31-çº¿ç¨‹æ± ä¼˜åŒ–)
    - [3.2 å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–](#32-å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–)
    - [3.3 é”ä¼˜åŒ–ç­–ç•¥](#33-é”ä¼˜åŒ–ç­–ç•¥)
    - [3.4 æ— é”æ•°æ®ç»“æ„](#34-æ— é”æ•°æ®ç»“æ„)
  - [4. I/O æ€§èƒ½ä¼˜åŒ–](#4-io-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 ç¼“å†²ç­–ç•¥](#41-ç¼“å†²ç­–ç•¥)
    - [4.2 æ‰¹å¤„ç†æŠ€æœ¯](#42-æ‰¹å¤„ç†æŠ€æœ¯)
    - [4.3 å¼‚æ­¥ I/O](#43-å¼‚æ­¥-io)
    - [4.4 é›¶æ‹·è´ I/O](#44-é›¶æ‹·è´-io)
  - [5. CPU ä¼˜åŒ–](#5-cpu-ä¼˜åŒ–)
    - [5.1 SIMD ä¼˜åŒ–](#51-simd-ä¼˜åŒ–)
    - [5.2 åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–](#52-åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–)
    - [5.3 ç¼“å­˜å‹å¥½è®¾è®¡](#53-ç¼“å­˜å‹å¥½è®¾è®¡)
    - [5.4 CPU äº²å’Œæ€§](#54-cpu-äº²å’Œæ€§)
  - [6. æ€§èƒ½åˆ†æå·¥å…·](#6-æ€§èƒ½åˆ†æå·¥å…·)
    - [6.1 perf + FlameGraph](#61-perf--flamegraph)
    - [6.2 valgrind (Cachegrind/Callgrind)](#62-valgrind-cachegrindcallgrind)
    - [6.3 Criterion åŸºå‡†æµ‹è¯•](#63-criterion-åŸºå‡†æµ‹è¯•)
    - [6.4 è‡ªå®šä¹‰æ€§èƒ½åˆ†æ](#64-è‡ªå®šä¹‰æ€§èƒ½åˆ†æ)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 é«˜æ€§èƒ½ JSON è§£æå™¨](#71-é«˜æ€§èƒ½-json-è§£æå™¨)
    - [7.2 å†…å­˜é«˜æ•ˆçš„ç¼“å­˜ç³»ç»Ÿ](#72-å†…å­˜é«˜æ•ˆçš„ç¼“å­˜ç³»ç»Ÿ)
    - [7.3 é«˜ååé‡æ¶ˆæ¯é˜Ÿåˆ—](#73-é«˜ååé‡æ¶ˆæ¯é˜Ÿåˆ—)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. æ€§èƒ½è°ƒä¼˜æ¦‚è¿°

### 1.1 æ€§èƒ½ä¼˜åŒ–é‡‘å­—å¡”

```text
          ç®—æ³•ä¼˜åŒ–
         /          \
     æ•°æ®ç»“æ„è®¾è®¡
       /          \
   ç¼–è¯‘å™¨ä¼˜åŒ–
     /          \
  æ¶æ„è®¾è®¡
    /          \
 å¾®ä¼˜åŒ–
```

**ä¼˜åŒ–ä¼˜å…ˆçº§**:

1. **ç®—æ³•å¤æ‚åº¦** (10x-1000x æå‡)
2. **æ•°æ®ç»“æ„** (5x-50x æå‡)
3. **ç³»ç»Ÿæ¶æ„** (2x-10x æå‡)
4. **ç¼–è¯‘å™¨ä¼˜åŒ–** (1.2x-3x æå‡)
5. **å¾®ä¼˜åŒ–** (1.05x-1.5x æå‡)

### 1.2 æµ‹é‡é©±åŠ¨ä¼˜åŒ–

**æ€§èƒ½ä¼˜åŒ–çš„é»„é‡‘æ³•åˆ™**: **å…ˆæµ‹é‡ï¼Œå†ä¼˜åŒ–**

```rust
use std::time::Instant;

pub struct PerformanceMonitor {
    start: Instant,
    name: &'static str,
}

impl PerformanceMonitor {
    pub fn new(name: &'static str) -> Self {
        Self {
            start: Instant::now(),
            name,
        }
    }
}

impl Drop for PerformanceMonitor {
    fn drop(&mut self) {
        let elapsed = self.start.elapsed();
        eprintln!("[PERF] {} took {:?}", self.name, elapsed);
    }
}

// ä½¿ç”¨
fn expensive_operation() {
    let _monitor = PerformanceMonitor::new("expensive_operation");
    // ä½ çš„ä»£ç 
}
```

---

## 2. å†…å­˜ä¼˜åŒ–

### 2.1 å †ä¸æ ˆä¼˜åŒ–

**æ ˆåˆ†é… vs å †åˆ†é…**:

```rust
// âŒ æ…¢ï¼šå †åˆ†é…
fn process_slow(data: Vec<u8>) -> Vec<u8> {
    let mut result = Vec::new();
    for &byte in &data {
        result.push(byte * 2);
    }
    result
}

// âœ… å¿«ï¼šæ ˆåˆ†é… (å°æ•°æ®)
fn process_fast<const N: usize>(data: &[u8; N]) -> [u8; N] {
    let mut result = [0u8; N];
    for i in 0..N {
        result[i] = data[i] * 2;
    }
    result
}

// âœ… æ›´å¥½ï¼šé¢„åˆ†é…å®¹é‡
fn process_preallocated(data: &[u8]) -> Vec<u8> {
    let mut result = Vec::with_capacity(data.len());
    for &byte in data {
        result.push(byte * 2);
    }
    result
}
```

**SmallVec ä¼˜åŒ–**:

```rust
use smallvec::{SmallVec, smallvec};

// å°äºç­‰äº 8 ä¸ªå…ƒç´ æ—¶ä½¿ç”¨æ ˆï¼Œå¦åˆ™ä½¿ç”¨å †
type FastVec<T> = SmallVec<[T; 8]>;

fn process_with_smallvec(items: &[i32]) -> FastVec<i32> {
    let mut result: FastVec<i32> = smallvec![];
    for &item in items {
        result.push(item * 2);
    }
    result
}
```

### 2.2 å†…å­˜æ± æŠ€æœ¯

**å¯¹è±¡æ± æ¨¡å¼**:

```rust
use std::sync::Mutex;

pub struct ObjectPool<T> {
    objects: Mutex<Vec<T>>,
    factory: fn() -> T,
}

impl<T> ObjectPool<T> {
    pub fn new(factory: fn() -> T, initial_size: usize) -> Self {
        let mut objects = Vec::with_capacity(initial_size);
        for _ in 0..initial_size {
            objects.push(factory());
        }
        Self {
            objects: Mutex::new(objects),
            factory,
        }
    }

    pub fn acquire(&self) -> PooledObject<T> {
        let obj = self.objects.lock().unwrap().pop()
            .unwrap_or_else(|| (self.factory)());
        PooledObject {
            obj: Some(obj),
            pool: self,
        }
    }

    fn release(&self, obj: T) {
        self.objects.lock().unwrap().push(obj);
    }
}

pub struct PooledObject<'a, T> {
    obj: Option<T>,
    pool: &'a ObjectPool<T>,
}

impl<T> std::ops::Deref for PooledObject<'_, T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        self.obj.as_ref().unwrap()
    }
}

impl<T> std::ops::DerefMut for PooledObject<'_, T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.obj.as_mut().unwrap()
    }
}

impl<T> Drop for PooledObject<'_, T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.release(obj);
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn buffer_factory() -> Vec<u8> {
    Vec::with_capacity(4096)
}

fn use_pool() {
    let pool = ObjectPool::new(buffer_factory, 10);
    
    let mut buffer = pool.acquire();
    buffer.extend_from_slice(b"Hello, world!");
    // buffer è‡ªåŠ¨å½’è¿˜åˆ°æ± ä¸­
}
```

### 2.3 é›¶æ‹·è´æŠ€æœ¯

**ä½¿ç”¨ `Cow` é¿å…ä¸å¿…è¦çš„å…‹éš†**:

```rust
use std::borrow::Cow;

// âŒ æ€»æ˜¯å…‹éš†
fn process_always_clone(input: &str) -> String {
    if input.contains("special") {
        input.replace("special", "modified")
    } else {
        input.to_string()  // ä¸å¿…è¦çš„å…‹éš†
    }
}

// âœ… æŒ‰éœ€å…‹éš†
fn process_cow(input: &str) -> Cow<str> {
    if input.contains("special") {
        Cow::Owned(input.replace("special", "modified"))
    } else {
        Cow::Borrowed(input)
    }
}
```

**ä½¿ç”¨ `bytes` crate é›¶æ‹·è´**:

```rust
use bytes::{Bytes, BytesMut};

fn zero_copy_slice(data: Bytes) -> Bytes {
    // é›¶æ‹·è´åˆ‡ç‰‡
    data.slice(0..100)
}

fn efficient_buffer() -> Bytes {
    let mut buf = BytesMut::with_capacity(1024);
    buf.extend_from_slice(b"Hello, world!");
    buf.freeze()  // è½¬æ¢ä¸ºä¸å¯å˜ Bytesï¼Œæ— æ‹·è´
}
```

### 2.4 å†…å­˜å¯¹é½ä¸ç¼“å­˜è¡Œ

**é¿å…ä¼ªå…±äº« (False Sharing)**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};

// âŒ ä¼ªå…±äº«ï¼šä¸¤ä¸ªåŸå­å˜é‡åœ¨åŒä¸€ç¼“å­˜è¡Œ
struct BadCounter {
    counter1: AtomicU64,
    counter2: AtomicU64,
}

// âœ… ç¼“å­˜è¡Œå¯¹é½ï¼šé¿å…ä¼ªå…±äº«
#[repr(align(64))]
struct AlignedCounter {
    counter: AtomicU64,
}

struct GoodCounter {
    counter1: AlignedCounter,
    counter2: AlignedCounter,
}

// ä½¿ç”¨
fn use_aligned_counter() {
    let counter = GoodCounter {
        counter1: AlignedCounter { counter: AtomicU64::new(0) },
        counter2: AlignedCounter { counter: AtomicU64::new(0) },
    };
    
    // ä¸¤ä¸ªçº¿ç¨‹å¯ä»¥å¹¶å‘ä¿®æ”¹ counter1 å’Œ counter2 è€Œæ— ä¼ªå…±äº«
    std::thread::scope(|s| {
        s.spawn(|| {
            for _ in 0..1_000_000 {
                counter.counter1.counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        s.spawn(|| {
            for _ in 0..1_000_000 {
                counter.counter2.counter.fetch_add(1, Ordering::Relaxed);
            }
        });
    });
}
```

---

## 3. å¹¶å‘æ€§èƒ½ä¼˜åŒ–

### 3.1 çº¿ç¨‹æ± ä¼˜åŒ–

**åŠ¨æ€çº¿ç¨‹æ± **:

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Sender<Job>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    pub fn new(size: usize) -> Self {
        let (sender, receiver) = channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();

            match job {
                Ok(job) => {
                    job();
                }
                Err(_) => {
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
```

### 3.2 å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–

**é¿å…ä¸å¿…è¦çš„ `await`**:

```rust
use tokio::time::{sleep, Duration};

// âŒ æ…¢ï¼šé¡ºåºæ‰§è¡Œ
async fn slow_sequential() {
    sleep(Duration::from_secs(1)).await;
    sleep(Duration::from_secs(1)).await;
    sleep(Duration::from_secs(1)).await;
    // æ€»è€—æ—¶ï¼š3 ç§’
}

// âœ… å¿«ï¼šå¹¶å‘æ‰§è¡Œ
async fn fast_concurrent() {
    let (_, _, _) = tokio::join!(
        sleep(Duration::from_secs(1)),
        sleep(Duration::from_secs(1)),
        sleep(Duration::from_secs(1)),
    );
    // æ€»è€—æ—¶ï¼š1 ç§’
}
```

**æµå¼å¤„ç†**:

```rust
use futures::stream::{self, StreamExt};

async fn process_stream() {
    let items = vec![1, 2, 3, 4, 5];
    
    // âœ… æµå¼å¤„ç†ï¼šå¹¶å‘å¤„ç†å¤šä¸ªé¡¹
    let results: Vec<_> = stream::iter(items)
        .map(|item| async move {
            // å¼‚æ­¥å¤„ç†æ¯ä¸ªé¡¹
            item * 2
        })
        .buffer_unordered(4)  // æœ€å¤šåŒæ—¶å¤„ç† 4 ä¸ª
        .collect()
        .await;
}
```

### 3.3 é”ä¼˜åŒ–ç­–ç•¥

**è¯»å†™é”ä¼˜åŒ–**:

```rust
use std::sync::RwLock;

struct Cache {
    data: RwLock<std::collections::HashMap<String, String>>,
}

impl Cache {
    fn get(&self, key: &str) -> Option<String> {
        // è¯»é”ï¼šå…è®¸å¤šä¸ªå¹¶å‘è¯»
        self.data.read().unwrap().get(key).cloned()
    }

    fn set(&self, key: String, value: String) {
        // å†™é”ï¼šç‹¬å è®¿é—®
        self.data.write().unwrap().insert(key, value);
    }
}
```

**é”ç²’åº¦ä¼˜åŒ–**:

```rust
use std::sync::Mutex;

// âŒ ç²—ç²’åº¦é”ï¼šæ•´ä¸ªç»“æ„è¢«é”
struct CoarseGrained {
    data: Mutex<Vec<Vec<i32>>>,
}

// âœ… ç»†ç²’åº¦é”ï¼šæ¯ä¸ªå­ç»“æ„ç‹¬ç«‹é”
struct FineGrained {
    data: Vec<Mutex<Vec<i32>>>,
}

impl FineGrained {
    fn update(&self, index: usize, value: i32) {
        // åªé”å®šä¸€ä¸ªå­å‘é‡
        self.data[index].lock().unwrap().push(value);
    }
}
```

### 3.4 æ— é”æ•°æ®ç»“æ„

**ä½¿ç”¨ crossbeam çš„æ— é”é˜Ÿåˆ—**:

```rust
use crossbeam::queue::ArrayQueue;
use std::sync::Arc;

fn lockfree_queue() {
    let queue = Arc::new(ArrayQueue::new(100));
    
    let producer = {
        let queue = Arc::clone(&queue);
        std::thread::spawn(move || {
            for i in 0..1000 {
                while queue.push(i).is_err() {
                    // é˜Ÿåˆ—æ»¡ï¼Œé‡è¯•
                    std::hint::spin_loop();
                }
            }
        })
    };
    
    let consumer = {
        let queue = Arc::clone(&queue);
        std::thread::spawn(move || {
            let mut sum = 0;
            for _ in 0..1000 {
                while let Err(_) = queue.pop() {
                    // é˜Ÿåˆ—ç©ºï¼Œé‡è¯•
                    std::hint::spin_loop();
                }
                sum += queue.pop().unwrap();
            }
            sum
        })
    };
    
    producer.join().unwrap();
    let result = consumer.join().unwrap();
    println!("Sum: {}", result);
}
```

---

## 4. I/O æ€§èƒ½ä¼˜åŒ–

### 4.1 ç¼“å†²ç­–ç•¥

**ä½¿ç”¨ BufReader/BufWriter**:

```rust
use std::io::{BufReader, BufWriter, Read, Write};
use std::fs::File;

// âŒ æ…¢ï¼šæ— ç¼“å†²
fn slow_read(path: &str) -> std::io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// âœ… å¿«ï¼šæœ‰ç¼“å†²
fn fast_read(path: &str) -> std::io::Result<String> {
    let file = File::open(path)?;
    let mut reader = BufReader::new(file);
    let mut contents = String::new();
    reader.read_to_string(&mut contents)?;
    Ok(contents)
}

// âœ… å¿«ï¼šæœ‰ç¼“å†²å†™å…¥
fn fast_write(path: &str, data: &[u8]) -> std::io::Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);
    writer.write_all(data)?;
    writer.flush()?;
    Ok(())
}
```

### 4.2 æ‰¹å¤„ç†æŠ€æœ¯

**æ‰¹é‡æ•°æ®åº“æ“ä½œ**:

```rust
use tokio_postgres::{Client, Error};

// âŒ æ…¢ï¼šé€æ¡æ’å…¥
async fn slow_insert(client: &Client, items: &[i32]) -> Result<(), Error> {
    for &item in items {
        client.execute(
            "INSERT INTO items (value) VALUES ($1)",
            &[&item],
        ).await?;
    }
    Ok(())
}

// âœ… å¿«ï¼šæ‰¹é‡æ’å…¥
async fn fast_insert(client: &Client, items: &[i32]) -> Result<(), Error> {
    let mut query = String::from("INSERT INTO items (value) VALUES ");
    for (i, _) in items.iter().enumerate() {
        if i > 0 {
            query.push_str(", ");
        }
        query.push_str(&format!("(${})", i + 1));
    }
    
    client.execute(&query, items).await?;
    Ok(())
}
```

### 4.3 å¼‚æ­¥ I/O

**tokio å¼‚æ­¥æ–‡ä»¶ I/O**:

```rust
use tokio::fs::File;
use tokio::io::AsyncReadExt;

async fn async_read(path: &str) -> std::io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}
```

### 4.4 é›¶æ‹·è´ I/O

**ä½¿ç”¨ `sendfile` (Linux)**:

```rust
#[cfg(target_os = "linux")]
use std::os::unix::io::AsRawFd;

#[cfg(target_os = "linux")]
fn zero_copy_transfer(input: &std::fs::File, output: &std::fs::File, size: usize) -> std::io::Result<()> {
    unsafe {
        let ret = libc::sendfile(
            output.as_raw_fd(),
            input.as_raw_fd(),
            std::ptr::null_mut(),
            size,
        );
        if ret < 0 {
            return Err(std::io::Error::last_os_error());
        }
    }
    Ok(())
}
```

---

## 5. CPU ä¼˜åŒ–

### 5.1 SIMD ä¼˜åŒ–

**ä½¿ç”¨ `std::simd` (Rust 1.90+)**:

```rust
#![feature(portable_simd)]
use std::simd::{f32x8, SimdFloat};

// âŒ æ ‡é‡ç‰ˆæœ¬
fn scalar_sum(data: &[f32]) -> f32 {
    data.iter().sum()
}

// âœ… SIMD ç‰ˆæœ¬
fn simd_sum(data: &[f32]) -> f32 {
    let chunks = data.chunks_exact(8);
    let remainder = chunks.remainder();
    
    let sum_vec: f32x8 = chunks
        .map(|chunk| f32x8::from_slice(chunk))
        .fold(f32x8::splat(0.0), |acc, x| acc + x);
    
    let sum_simd: f32 = sum_vec.reduce_sum();
    let sum_remainder: f32 = remainder.iter().sum();
    
    sum_simd + sum_remainder
}
```

### 5.2 åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–

**ä½¿ç”¨ `likely`/`unlikely` (nightly)**:

```rust
#![feature(core_intrinsics)]
use std::intrinsics::{likely, unlikely};

fn process(data: &[i32]) -> Vec<i32> {
    let mut result = Vec::with_capacity(data.len());
    
    for &value in data {
        // æç¤ºç¼–è¯‘å™¨è¿™ä¸ªåˆ†æ”¯å¾ˆå¯èƒ½ä¸ºçœŸ
        if unsafe { likely(value > 0) } {
            result.push(value * 2);
        } else if unsafe { unlikely(value < -1000) } {
            // è¿™ä¸ªåˆ†æ”¯å¾ˆå°‘æ‰§è¡Œ
            result.push(0);
        } else {
            result.push(value);
        }
    }
    
    result
}
```

### 5.3 ç¼“å­˜å‹å¥½è®¾è®¡

**Structure of Arrays (SoA) vs Array of Structures (AoS)**:

```rust
// âŒ Array of Structuresï¼šç¼“å­˜ä¸å‹å¥½
struct ParticleAoS {
    x: f32,
    y: f32,
    z: f32,
    vx: f32,
    vy: f32,
    vz: f32,
}

fn update_aos(particles: &mut [ParticleAoS]) {
    for particle in particles {
        particle.x += particle.vx;
        // è·³è¿‡ y, z, vy, vz å­—æ®µè®¿é—®å…¶ä»–ç²’å­çš„ x
    }
}

// âœ… Structure of Arraysï¼šç¼“å­˜å‹å¥½
struct ParticlesSoA {
    x: Vec<f32>,
    y: Vec<f32>,
    z: Vec<f32>,
    vx: Vec<f32>,
    vy: Vec<f32>,
    vz: Vec<f32>,
}

fn update_soa(particles: &mut ParticlesSoA) {
    for i in 0..particles.x.len() {
        particles.x[i] += particles.vx[i];
        // è¿ç»­è®¿é—® x å’Œ vx æ•°ç»„ï¼Œç¼“å­˜å‹å¥½
    }
}
```

### 5.4 CPU äº²å’Œæ€§

**ç»‘å®šçº¿ç¨‹åˆ° CPU æ ¸å¿ƒ**:

```rust
#[cfg(target_os = "linux")]
fn set_cpu_affinity(cpu_id: usize) -> std::io::Result<()> {
    use libc::{cpu_set_t, CPU_SET, CPU_ZERO, sched_setaffinity};
    use std::mem;
    
    unsafe {
        let mut cpu_set: cpu_set_t = mem::zeroed();
        CPU_ZERO(&mut cpu_set);
        CPU_SET(cpu_id, &mut cpu_set);
        
        let result = sched_setaffinity(
            0,  // å½“å‰çº¿ç¨‹
            mem::size_of::<cpu_set_t>(),
            &cpu_set,
        );
        
        if result != 0 {
            return Err(std::io::Error::last_os_error());
        }
    }
    
    Ok(())
}
```

---

## 6. æ€§èƒ½åˆ†æå·¥å…·

### 6.1 perf + FlameGraph

```bash
# å½•åˆ¶æ€§èƒ½æ•°æ®
perf record -F 99 -g ./target/release/my_app

# ç”ŸæˆæŠ¥å‘Š
perf report

# ç”Ÿæˆç«ç„°å›¾
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg
```

**åœ¨ Rust ä¸­é›†æˆ**:

```rust
use pprof::ProfilerGuard;

fn profile_code() {
    let guard = ProfilerGuard::new(100).unwrap();
    
    // ä½ çš„ä»£ç 
    expensive_function();
    
    if let Ok(report) = guard.report().build() {
        let file = std::fs::File::create("flamegraph.svg").unwrap();
        report.flamegraph(file).unwrap();
    }
}
```

### 6.2 valgrind (Cachegrind/Callgrind)

```bash
# ç¼“å­˜åˆ†æ
valgrind --tool=cachegrind ./target/release/my_app

# è°ƒç”¨å›¾åˆ†æ
valgrind --tool=callgrind ./target/release/my_app

# å¯è§†åŒ–
kcachegrind callgrind.out.<pid>
```

### 6.3 Criterion åŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

### 6.4 è‡ªå®šä¹‰æ€§èƒ½åˆ†æ

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::Instant;

pub struct Profiler {
    timings: Arc<Mutex<HashMap<String, Vec<u128>>>>,
}

impl Profiler {
    pub fn new() -> Self {
        Self {
            timings: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub fn profile<F, R>(&self, name: &str, f: F) -> R
    where
        F: FnOnce() -> R,
    {
        let start = Instant::now();
        let result = f();
        let elapsed = start.elapsed().as_micros();

        self.timings
            .lock()
            .unwrap()
            .entry(name.to_string())
            .or_insert_with(Vec::new)
            .push(elapsed);

        result
    }

    pub fn report(&self) {
        let timings = self.timings.lock().unwrap();
        for (name, times) in timings.iter() {
            let avg = times.iter().sum::<u128>() / times.len() as u128;
            let min = *times.iter().min().unwrap();
            let max = *times.iter().max().unwrap();
            println!(
                "{}: avg={}Î¼s, min={}Î¼s, max={}Î¼s, count={}",
                name, avg, min, max, times.len()
            );
        }
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 é«˜æ€§èƒ½ JSON è§£æå™¨

```rust
use serde_json::Value;

// ä¼˜åŒ–ç­–ç•¥ï¼š
// 1. ä½¿ç”¨ simd-json (SIMD åŠ é€Ÿ)
// 2. é›¶æ‹·è´è§£æ
// 3. é¢„åˆ†é…å®¹é‡

use simd_json;

fn fast_json_parse(json_bytes: &mut [u8]) -> Result<Value, simd_json::Error> {
    simd_json::to_borrowed_value(json_bytes)
        .map(|v| v.into())
}

// åŸºå‡†æµ‹è¯•å¯¹æ¯”
#[cfg(test)]
mod benches {
    use super::*;
    use criterion::{black_box, Criterion};

    pub fn benchmark_json(c: &mut Criterion) {
        let mut json = br#"{"name":"Alice","age":30,"city":"NYC"}"#.to_vec();

        c.bench_function("std json", |b| {
            b.iter(|| serde_json::from_slice::<Value>(black_box(&json)))
        });

        c.bench_function("simd json", |b| {
            b.iter(|| fast_json_parse(black_box(&mut json)))
        });
    }
}
```

### 7.2 å†…å­˜é«˜æ•ˆçš„ç¼“å­˜ç³»ç»Ÿ

```rust
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::RwLock;

pub struct LRUCache<K, V> {
    capacity: usize,
    cache: Arc<RwLock<HashMap<K, (V, usize)>>>,
    access_count: Arc<RwLock<usize>>,
}

impl<K: Eq + std::hash::Hash + Clone, V: Clone> LRUCache<K, V> {
    pub fn new(capacity: usize) -> Self {
        Self {
            capacity,
            cache: Arc::new(RwLock::new(HashMap::with_capacity(capacity))),
            access_count: Arc::new(RwLock::new(0)),
        }
    }

    pub fn get(&self, key: &K) -> Option<V> {
        let mut cache = self.cache.write();
        let mut count = self.access_count.write();
        
        if let Some((value, access)) = cache.get_mut(key) {
            *count += 1;
            *access = *count;
            Some(value.clone())
        } else {
            None
        }
    }

    pub fn put(&self, key: K, value: V) {
        let mut cache = self.cache.write();
        let mut count = self.access_count.write();
        
        *count += 1;
        
        if cache.len() >= self.capacity {
            // ç§»é™¤æœ€å°‘ä½¿ç”¨çš„é¡¹
            if let Some(lru_key) = cache
                .iter()
                .min_by_key(|(_, (_, access))| access)
                .map(|(k, _)| k.clone())
            {
                cache.remove(&lru_key);
            }
        }
        
        cache.insert(key, (value, *count));
    }
}
```

### 7.3 é«˜ååé‡æ¶ˆæ¯é˜Ÿåˆ—

```rust
use crossbeam::channel::{bounded, Sender, Receiver};
use std::sync::Arc;

pub struct MessageQueue<T> {
    sender: Sender<T>,
    receiver: Arc<Receiver<T>>,
}

impl<T: Send + 'static> MessageQueue<T> {
    pub fn new(capacity: usize) -> Self {
        let (sender, receiver) = bounded(capacity);
        Self {
            sender,
            receiver: Arc::new(receiver),
        }
    }

    pub fn send(&self, msg: T) -> Result<(), crossbeam::channel::SendError<T>> {
        self.sender.send(msg)
    }

    pub fn spawn_consumer<F>(&self, f: F) -> std::thread::JoinHandle<()>
    where
        F: Fn(T) + Send + 'static,
    {
        let receiver = Arc::clone(&self.receiver);
        std::thread::spawn(move || {
            while let Ok(msg) = receiver.recv() {
                f(msg);
            }
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn use_message_queue() {
    let queue = MessageQueue::new(1000);
    
    // å¯åŠ¨ 4 ä¸ªæ¶ˆè´¹è€…
    let mut handles = vec![];
    for i in 0..4 {
        let handle = queue.spawn_consumer(move |msg: String| {
            println!("Consumer {} received: {}", i, msg);
        });
        handles.push(handle);
    }
    
    // ç”Ÿäº§è€…
    for i in 0..10000 {
        queue.send(format!("Message {}", i)).unwrap();
    }
    
    drop(queue);
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æµ‹é‡é©±åŠ¨**: å…ˆæµ‹é‡ï¼Œå†ä¼˜åŒ–ï¼Œé¿å…è¿‡æ—©ä¼˜åŒ–
2. **ç®—æ³•ä¼˜å…ˆ**: ç®—æ³•ä¼˜åŒ–å¸¦æ¥çš„æå‡è¿œè¶…å¾®ä¼˜åŒ–
3. **å†…å­˜ä¼˜åŒ–**: æ ˆåˆ†é…ã€å†…å­˜æ± ã€é›¶æ‹·è´ã€ç¼“å­˜è¡Œå¯¹é½
4. **å¹¶å‘ä¼˜åŒ–**: çº¿ç¨‹æ± ã€å¼‚æ­¥ã€é”ç²’åº¦ã€æ— é”ç»“æ„
5. **I/O ä¼˜åŒ–**: ç¼“å†²ã€æ‰¹å¤„ç†ã€å¼‚æ­¥ I/Oã€é›¶æ‹·è´
6. **CPU ä¼˜åŒ–**: SIMDã€åˆ†æ”¯é¢„æµ‹ã€ç¼“å­˜å‹å¥½ã€CPU äº²å’Œæ€§

### æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èåšæ³• | æ€§èƒ½æå‡ |
|------|---------|---------|
| **å°æ•°æ®** | SmallVec / æ ˆåˆ†é… | 2-5x |
| **é¢‘ç¹åˆ†é…** | å¯¹è±¡æ±  | 3-10x |
| **å­—ç¬¦ä¸²å¤„ç†** | `Cow<str>` | 1.5-3x |
| **å¹¶å‘è¯»** | RwLock | 5-20x |
| **æ— é”å¹¶å‘** | crossbeam queue | 2-10x |
| **æ–‡ä»¶ I/O** | BufReader/Writer | 10-100x |
| **æ‰¹é‡æ“ä½œ** | æ‰¹é‡æ’å…¥ | 5-50x |
| **æ•°å€¼è®¡ç®—** | SIMD | 4-8x |
| **ç¼“å­˜å‹å¥½** | SoA vs AoS | 2-4x |

**å¸¸è§é™·é˜±**:

- âŒ è¿‡æ—©ä¼˜åŒ–
- âŒ å¿½ç•¥ç®—æ³•å¤æ‚åº¦
- âŒ ä¸æµ‹é‡å°±ä¼˜åŒ–
- âŒ ä¼˜åŒ–éçƒ­ç‚¹è·¯å¾„
- âŒ ç‰ºç‰²å¯è¯»æ€§æ¢å–å¾®å°æå‡
- âœ… ä½¿ç”¨ profiler æ‰¾çƒ­ç‚¹
- âœ… ä¼˜åŒ–ç®—æ³•å’Œæ•°æ®ç»“æ„
- âœ… ä¿æŒä»£ç å¯ç»´æŠ¤æ€§
- âœ… ç¼–å†™åŸºå‡†æµ‹è¯•

---

## ğŸ“š å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Rust Compiler Performance](https://rustc-dev-guide.rust-lang.org/backend/codegen.html)

**å·¥å…·**:

- `perf` + FlameGraph - CPU æ€§èƒ½åˆ†æ
- `valgrind` - å†…å­˜å’Œç¼“å­˜åˆ†æ
- `criterion` - åŸºå‡†æµ‹è¯•
- `cargo-flamegraph` - ç«ç„°å›¾ç”Ÿæˆ

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: éƒ¨ç½²å®è·µæŒ‡å—](../tier_02_guides/05_éƒ¨ç½²å®è·µæŒ‡å—.md)
- [Tier 4: æ•…éšœåˆ†æä¸è¯Šæ–­](./02_æ•…éšœåˆ†æä¸è¯Šæ–­.md)
- [Tier 3: å¹¶å‘æ¨¡å‹](../features/concurrency-models.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C13 Reliability Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
