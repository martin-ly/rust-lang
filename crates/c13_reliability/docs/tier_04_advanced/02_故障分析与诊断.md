# C13 Reliability - Tier 4: 故障分析与诊断

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 65 分钟  
> **难度**: ⭐⭐⭐⭐⭐ (专家级)

---


## 📊 目录

- [📋 目录](#目录)
- [1. 故障分析概述](#1-故障分析概述)
  - [1.1 故障分类体系](#11-故障分类体系)
  - [1.2 诊断流程](#12-诊断流程)
- [2. 日志分析技术](#2-日志分析技术)
  - [2.1 结构化日志](#21-结构化日志)
  - [2.2 日志聚合与搜索](#22-日志聚合与搜索)
  - [2.3 日志模式识别](#23-日志模式识别)
- [3. 核心转储分析](#3-核心转储分析)
  - [3.1 配置核心转储](#31-配置核心转储)
  - [3.2 使用 gdb 分析](#32-使用-gdb-分析)
  - [3.3 常见崩溃模式](#33-常见崩溃模式)
- [4. 分布式追踪](#4-分布式追踪)
  - [4.1 OpenTelemetry 集成](#41-opentelemetry-集成)
  - [4.2 追踪上下文传播](#42-追踪上下文传播)
  - [4.3 追踪数据分析](#43-追踪数据分析)
- [5. 根因分析方法](#5-根因分析方法)
  - [5.1 5-Why 分析法](#51-5-why-分析法)
  - [5.2 鱼骨图分析](#52-鱼骨图分析)
  - [5.3 故障树分析 (FTA)](#53-故障树分析-fta)
- [6. 实战案例](#6-实战案例)
  - [6.1 内存泄漏诊断](#61-内存泄漏诊断)
  - [6.2 死锁诊断](#62-死锁诊断)
  - [6.3 性能退化诊断](#63-性能退化诊断)
- [7. 自动化诊断](#7-自动化诊断)
  - [7.1 健康检查系统](#71-健康检查系统)
  - [7.2 异常检测](#72-异常检测)
  - [7.3 自动修复](#73-自动修复)
- [8. 总结](#8-总结)
  - [核心要点](#核心要点)
  - [最佳实践](#最佳实践)
- [📚 参考资源](#参考资源)


## 📋 目录

- [C13 Reliability - Tier 4: 故障分析与诊断](#c13-reliability---tier-4-故障分析与诊断)
  - [📋 目录](#-目录)
  - [1. 故障分析概述](#1-故障分析概述)
    - [1.1 故障分类体系](#11-故障分类体系)
    - [1.2 诊断流程](#12-诊断流程)
  - [2. 日志分析技术](#2-日志分析技术)
    - [2.1 结构化日志](#21-结构化日志)
    - [2.2 日志聚合与搜索](#22-日志聚合与搜索)
    - [2.3 日志模式识别](#23-日志模式识别)
  - [3. 核心转储分析](#3-核心转储分析)
    - [3.1 配置核心转储](#31-配置核心转储)
    - [3.2 使用 gdb 分析](#32-使用-gdb-分析)
    - [3.3 常见崩溃模式](#33-常见崩溃模式)
  - [4. 分布式追踪](#4-分布式追踪)
    - [4.1 OpenTelemetry 集成](#41-opentelemetry-集成)
    - [4.2 追踪上下文传播](#42-追踪上下文传播)
    - [4.3 追踪数据分析](#43-追踪数据分析)
  - [5. 根因分析方法](#5-根因分析方法)
    - [5.1 5-Why 分析法](#51-5-why-分析法)
    - [5.2 鱼骨图分析](#52-鱼骨图分析)
    - [5.3 故障树分析 (FTA)](#53-故障树分析-fta)
  - [6. 实战案例](#6-实战案例)
    - [6.1 内存泄漏诊断](#61-内存泄漏诊断)
    - [6.2 死锁诊断](#62-死锁诊断)
    - [6.3 性能退化诊断](#63-性能退化诊断)
  - [7. 自动化诊断](#7-自动化诊断)
    - [7.1 健康检查系统](#71-健康检查系统)
    - [7.2 异常检测](#72-异常检测)
    - [7.3 自动修复](#73-自动修复)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 故障分析概述

### 1.1 故障分类体系

**故障类型金字塔**:

```text
       灾难性故障
      /          \
   严重故障
    /          \
  一般故障
   /          \
 警告
  /          \
信息
```

**分类标准**:

| 级别 | 影响范围 | 响应时间 | 示例 |
|------|---------|---------|------|
| **P0 - 灾难** | 全站宕机 | < 5 分钟 | 数据库崩溃、核心服务不可用 |
| **P1 - 严重** | 核心功能失效 | < 30 分钟 | 支付失败、登录异常 |
| **P2 - 一般** | 次要功能故障 | < 2 小时 | 搜索慢、图片加载失败 |
| **P3 - 轻微** | 个别用户影响 | < 1 天 | UI 错乱、非关键功能异常 |
| **P4 - 信息** | 无用户影响 | 按计划 | 日志警告、性能轻微下降 |

**故障模式库**:

```rust
#[derive(Debug, Clone)]
pub enum FailurePattern {
    // 资源耗尽
    MemoryLeak,
    FileDescriptorLeak,
    ThreadPoolExhaustion,
    
    // 并发问题
    Deadlock,
    RaceCondition,
    LiveLock,
    
    // 性能问题
    SlowQuery,
    HighCPU,
    HighMemory,
    NetworkLatency,
    
    // 逻辑错误
    NullPointerDereference,
    IndexOutOfBounds,
    DivisionByZero,
    
    // 外部依赖
    DatabaseDown,
    CacheUnavailable,
    ThirdPartyAPIFailure,
}

impl FailurePattern {
    pub fn severity(&self) -> u8 {
        match self {
            Self::Deadlock | Self::MemoryLeak => 0, // P0
            Self::DatabaseDown | Self::NullPointerDereference => 1, // P1
            Self::SlowQuery | Self::HighCPU => 2, // P2
            _ => 3, // P3+
        }
    }
    
    pub fn diagnostic_steps(&self) -> Vec<&'static str> {
        match self {
            Self::MemoryLeak => vec![
                "检查 heaptrack/valgrind 报告",
                "分析对象分配热点",
                "检查是否有忘记 drop 的资源",
                "查看长期运行的缓存",
            ],
            Self::Deadlock => vec![
                "获取线程堆栈",
                "分析锁的获取顺序",
                "检查是否有循环依赖",
                "使用 TSAN 重现问题",
            ],
            _ => vec!["查看日志", "检查监控指标"],
        }
    }
}
```

### 1.2 诊断流程

**系统化诊断流程**:

```rust
pub struct DiagnosticSession {
    failure_id: String,
    pattern: FailurePattern,
    evidence: Vec<Evidence>,
    hypotheses: Vec<Hypothesis>,
    root_cause: Option<RootCause>,
}

#[derive(Debug)]
pub struct Evidence {
    source: String,      // logs, metrics, traces
    timestamp: u64,
    data: String,
    confidence: f32,     // 0.0-1.0
}

#[derive(Debug)]
pub struct Hypothesis {
    description: String,
    likelihood: f32,     // 0.0-1.0
    tests: Vec<String>,  // 验证方法
}

#[derive(Debug)]
pub struct RootCause {
    description: String,
    evidence_ids: Vec<usize>,
    remediation: Vec<String>,
}

impl DiagnosticSession {
    pub fn new(failure_id: String, pattern: FailurePattern) -> Self {
        Self {
            failure_id,
            pattern,
            evidence: Vec::new(),
            hypotheses: Vec::new(),
            root_cause: None,
        }
    }

    pub fn collect_evidence(&mut self, evidence: Evidence) {
        self.evidence.push(evidence);
    }

    pub fn propose_hypothesis(&mut self, hypothesis: Hypothesis) {
        self.hypotheses.push(hypothesis);
    }

    pub fn rank_hypotheses(&mut self) {
        self.hypotheses.sort_by(|a, b| {
            b.likelihood.partial_cmp(&a.likelihood).unwrap()
        });
    }

    pub fn identify_root_cause(&mut self, cause: RootCause) {
        self.root_cause = Some(cause);
    }

    pub fn generate_report(&self) -> String {
        format!(
            "Failure ID: {}\nPattern: {:?}\nEvidence: {} items\nHypotheses: {}\nRoot Cause: {}",
            self.failure_id,
            self.pattern,
            self.evidence.len(),
            self.hypotheses.len(),
            self.root_cause.is_some()
        )
    }
}
```

---

## 2. 日志分析技术

### 2.1 结构化日志

**使用 tracing 进行结构化日志**:

```rust
use tracing::{info, warn, error, span, Level};
use tracing_subscriber::{fmt, EnvFilter};

pub fn setup_logging() {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .json()  // JSON 格式，便于分析
        .init();
}

pub async fn process_request(request_id: &str, user_id: u64) {
    let span = span!(Level::INFO, "request", request_id, user_id);
    let _enter = span.enter();

    info!(
        event = "request_start",
        method = "POST",
        path = "/api/users"
    );

    // 业务逻辑
    match process_user_data(user_id).await {
        Ok(result) => {
            info!(
                event = "request_success",
                duration_ms = 120,
                result_size = result.len()
            );
        }
        Err(e) => {
            error!(
                event = "request_error",
                error = ?e,
                error_type = std::any::type_name_of_val(&e)
            );
        }
    }
}

async fn process_user_data(user_id: u64) -> Result<String, Box<dyn std::error::Error>> {
    // 模拟处理
    Ok(format!("Data for user {}", user_id))
}
```

### 2.2 日志聚合与搜索

**使用 Elasticsearch 进行日志搜索**:

```rust
use elasticsearch::{Elasticsearch, SearchParts};
use serde_json::json;

pub struct LogSearcher {
    client: Elasticsearch,
}

impl LogSearcher {
    pub fn new(url: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let transport = elasticsearch::http::transport::Transport::single_node(url)?;
        Ok(Self {
            client: Elasticsearch::new(transport),
        })
    }

    pub async fn search_errors(
        &self,
        start_time: &str,
        end_time: &str,
    ) -> Result<Vec<serde_json::Value>, Box<dyn std::error::Error>> {
        let response = self
            .client
            .search(SearchParts::Index(&["logs-*"]))
            .body(json!({
                "query": {
                    "bool": {
                        "must": [
                            {
                                "range": {
                                    "@timestamp": {
                                        "gte": start_time,
                                        "lte": end_time
                                    }
                                }
                            },
                            {
                                "term": {
                                    "level": "ERROR"
                                }
                            }
                        ]
                    }
                },
                "sort": [
                    { "@timestamp": "desc" }
                ],
                "size": 100
            }))
            .send()
            .await?;

        let response_body = response.json::<serde_json::Value>().await?;
        let hits = response_body["hits"]["hits"]
            .as_array()
            .unwrap()
            .iter()
            .map(|hit| hit["_source"].clone())
            .collect();

        Ok(hits)
    }

    pub async fn aggregate_error_types(
        &self,
        start_time: &str,
        end_time: &str,
    ) -> Result<Vec<(String, u64)>, Box<dyn std::error::Error>> {
        let response = self
            .client
            .search(SearchParts::Index(&["logs-*"]))
            .body(json!({
                "query": {
                    "bool": {
                        "must": [
                            {
                                "range": {
                                    "@timestamp": {
                                        "gte": start_time,
                                        "lte": end_time
                                    }
                                }
                            },
                            {
                                "term": {
                                    "level": "ERROR"
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "error_types": {
                        "terms": {
                            "field": "error_type.keyword",
                            "size": 20
                        }
                    }
                },
                "size": 0
            }))
            .send()
            .await?;

        let response_body = response.json::<serde_json::Value>().await?;
        let buckets = response_body["aggregations"]["error_types"]["buckets"]
            .as_array()
            .unwrap();

        let mut results = Vec::new();
        for bucket in buckets {
            let key = bucket["key"].as_str().unwrap().to_string();
            let count = bucket["doc_count"].as_u64().unwrap();
            results.push((key, count));
        }

        Ok(results)
    }
}
```

### 2.3 日志模式识别

**基于正则表达式的模式识别**:

```rust
use regex::Regex;
use std::collections::HashMap;

pub struct LogPatternAnalyzer {
    patterns: HashMap<String, Regex>,
    matches: HashMap<String, usize>,
}

impl LogPatternAnalyzer {
    pub fn new() -> Self {
        let mut patterns = HashMap::new();
        
        // 定义常见故障模式
        patterns.insert(
            "out_of_memory".to_string(),
            Regex::new(r"(?i)(out of memory|oom|memory allocation failed)").unwrap(),
        );
        patterns.insert(
            "connection_timeout".to_string(),
            Regex::new(r"(?i)(connection timeout|timed out|timeout exceeded)").unwrap(),
        );
        patterns.insert(
            "null_pointer".to_string(),
            Regex::new(r"(?i)(null pointer|segmentation fault|sigsegv)").unwrap(),
        );
        patterns.insert(
            "deadlock".to_string(),
            Regex::new(r"(?i)(deadlock detected|circular dependency)").unwrap(),
        );

        Self {
            patterns,
            matches: HashMap::new(),
        }
    }

    pub fn analyze_log(&mut self, log_line: &str) {
        for (pattern_name, regex) in &self.patterns {
            if regex.is_match(log_line) {
                *self.matches.entry(pattern_name.clone()).or_insert(0) += 1;
            }
        }
    }

    pub fn get_top_patterns(&self, n: usize) -> Vec<(String, usize)> {
        let mut sorted: Vec<_> = self.matches.iter().collect();
        sorted.sort_by(|a, b| b.1.cmp(a.1));
        sorted
            .into_iter()
            .take(n)
            .map(|(k, v)| (k.clone(), *v))
            .collect()
    }

    pub fn report(&self) -> String {
        let mut report = String::from("=== Log Pattern Analysis ===\n");
        for (pattern, count) in self.get_top_patterns(10) {
            report.push_str(&format!("{}: {} matches\n", pattern, count));
        }
        report
    }
}
```

---

## 3. 核心转储分析

### 3.1 配置核心转储

**启用核心转储**:

```bash
# 设置核心转储大小限制（无限制）
ulimit -c unlimited

# 配置核心转储文件名格式
echo "core.%e.%p.%t" > /proc/sys/kernel/core_pattern

# 在 Cargo.toml 中启用调试符号
[profile.release]
debug = true
```

**Rust 代码中捕获崩溃信息**:

```rust
use std::panic;
use std::fs::OpenOptions;
use std::io::Write;
use backtrace::Backtrace;

pub fn setup_panic_handler() {
    panic::set_hook(Box::new(|panic_info| {
        let backtrace = Backtrace::new();
        
        let mut crash_log = OpenOptions::new()
            .create(true)
            .append(true)
            .open("/var/log/myapp/crash.log")
            .expect("Failed to open crash log");

        let crash_report = format!(
            "===== PANIC =====\nTime: {}\nThread: {:?}\nMessage: {}\nBacktrace:\n{:?}\n\n",
            chrono::Utc::now(),
            std::thread::current().id(),
            panic_info,
            backtrace
        );

        crash_log.write_all(crash_report.as_bytes()).ok();
        eprintln!("{}", crash_report);
    }));
}
```

### 3.2 使用 gdb 分析

**基本 gdb 命令**:

```bash
# 加载核心转储
gdb ./target/release/myapp core.myapp.12345.1698123456

# 常用命令
(gdb) bt         # 查看调用栈
(gdb) bt full    # 查看详细调用栈
(gdb) info threads  # 查看所有线程
(gdb) thread 3   # 切换到线程 3
(gdb) frame 2    # 切换到栈帧 2
(gdb) print var  # 打印变量值
(gdb) info locals  # 查看局部变量
```

### 3.3 常见崩溃模式

**Panic 分析**:

```rust
// 使用 anyhow 提供更好的错误上下文
use anyhow::{Context, Result};

pub fn load_config(path: &str) -> Result<Config> {
    let contents = std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read config file: {}", path))?;
    
    let config: Config = toml::from_str(&contents)
        .with_context(|| format!("Failed to parse config file: {}", path))?;
    
    Ok(config)
}

// 配置结构
#[derive(serde::Deserialize)]
pub struct Config {
    pub server: ServerConfig,
}

#[derive(serde::Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}
```

---

## 4. 分布式追踪

### 4.1 OpenTelemetry 集成

```rust
use opentelemetry::{global, sdk::propagation::TraceContextPropagator};
use opentelemetry::sdk::trace as sdktrace;
use opentelemetry::trace::{TraceContextExt, Tracer};
use tracing_subscriber::layer::SubscriberExt;

pub fn init_tracing() {
    global::set_text_map_propagator(TraceContextPropagator::new());
    
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_simple()
        .expect("Failed to install tracer");
    
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    let subscriber = tracing_subscriber::registry().with(telemetry);
    
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set subscriber");
}

// 使用示例
#[tracing::instrument]
async fn handle_request(request_id: &str) -> Result<String, Box<dyn std::error::Error>> {
    tracing::info!("Processing request");
    
    let data = fetch_data().await?;
    let result = process_data(&data).await?;
    
    Ok(result)
}

#[tracing::instrument]
async fn fetch_data() -> Result<String, Box<dyn std::error::Error>> {
    // 模拟数据获取
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    Ok("data".to_string())
}

#[tracing::instrument]
async fn process_data(data: &str) -> Result<String, Box<dyn std::error::Error>> {
    // 模拟数据处理
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    Ok(format!("processed: {}", data))
}
```

### 4.2 追踪上下文传播

```rust
use opentelemetry::{global, Context};
use opentelemetry::propagation::{Injector, Extractor};
use std::collections::HashMap;

// HTTP 请求中注入追踪上下文
pub struct HttpHeadersInjector<'a> {
    headers: &'a mut HashMap<String, String>,
}

impl<'a> Injector for HttpHeadersInjector<'a> {
    fn set(&mut self, key: &str, value: String) {
        self.headers.insert(key.to_string(), value);
    }
}

// HTTP 请求中提取追踪上下文
pub struct HttpHeadersExtractor<'a> {
    headers: &'a HashMap<String, String>,
}

impl<'a> Extractor for HttpHeadersExtractor<'a> {
    fn get(&self, key: &str) -> Option<&str> {
        self.headers.get(key).map(|v| v.as_str())
    }

    fn keys(&self) -> Vec<&str> {
        self.headers.keys().map(|k| k.as_str()).collect()
    }
}

// 客户端：注入追踪上下文
pub fn make_http_request(url: &str) -> reqwest::RequestBuilder {
    let mut headers = HashMap::new();
    let propagator = global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &Context::current(),
            &mut HttpHeadersInjector { headers: &mut headers },
        );
    });
    
    let mut request = reqwest::Client::new().get(url);
    for (key, value) in headers {
        request = request.header(key, value);
    }
    request
}

// 服务端：提取追踪上下文
pub fn extract_context(headers: &HashMap<String, String>) -> Context {
    global::get_text_map_propagator(|propagator| {
        propagator.extract(&HttpHeadersExtractor { headers })
    })
}
```

### 4.3 追踪数据分析

**慢请求检测**:

```rust
use std::time::{Duration, Instant};

pub struct SpanAnalyzer {
    slow_threshold: Duration,
}

impl SpanAnalyzer {
    pub fn new(slow_threshold: Duration) -> Self {
        Self { slow_threshold }
    }

    pub fn analyze_span(&self, name: &str, duration: Duration) -> Option<SlowSpanAlert> {
        if duration > self.slow_threshold {
            Some(SlowSpanAlert {
                name: name.to_string(),
                duration,
                threshold: self.slow_threshold,
                severity: self.calculate_severity(duration),
            })
        } else {
            None
        }
    }

    fn calculate_severity(&self, duration: Duration) -> Severity {
        let ratio = duration.as_secs_f64() / self.slow_threshold.as_secs_f64();
        if ratio > 10.0 {
            Severity::Critical
        } else if ratio > 5.0 {
            Severity::High
        } else if ratio > 2.0 {
            Severity::Medium
        } else {
            Severity::Low
        }
    }
}

#[derive(Debug)]
pub struct SlowSpanAlert {
    pub name: String,
    pub duration: Duration,
    pub threshold: Duration,
    pub severity: Severity,
}

#[derive(Debug)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}
```

---

## 5. 根因分析方法

### 5.1 5-Why 分析法

```rust
pub struct FiveWhyAnalysis {
    problem: String,
    whys: Vec<String>,
    root_cause: Option<String>,
}

impl FiveWhyAnalysis {
    pub fn new(problem: String) -> Self {
        Self {
            problem,
            whys: Vec::new(),
            root_cause: None,
        }
    }

    pub fn ask_why(&mut self, answer: String) {
        self.whys.push(answer);
    }

    pub fn identify_root_cause(&mut self, cause: String) {
        self.root_cause = Some(cause);
    }

    pub fn report(&self) -> String {
        let mut report = format!("Problem: {}\n\n", self.problem);
        for (i, why) in self.whys.iter().enumerate() {
            report.push_str(&format!("Why {}: {}\n", i + 1, why));
        }
        if let Some(cause) = &self.root_cause {
            report.push_str(&format!("\nRoot Cause: {}\n", cause));
        }
        report
    }
}

// 使用示例
fn analyze_database_slowdown() {
    let mut analysis = FiveWhyAnalysis::new(
        "Database queries are slow".to_string()
    );
    
    analysis.ask_why("CPU usage is at 100%".to_string());
    analysis.ask_why("Too many concurrent queries".to_string());
    analysis.ask_why("No connection pooling".to_string());
    analysis.ask_why("Default configuration was used".to_string());
    analysis.ask_why("Documentation was not consulted".to_string());
    
    analysis.identify_root_cause(
        "Lack of proper database configuration review during setup".to_string()
    );
    
    println!("{}", analysis.report());
}
```

### 5.2 鱼骨图分析

```rust
pub struct FishboneAnalysis {
    effect: String,
    categories: Vec<Category>,
}

pub struct Category {
    name: String,
    causes: Vec<String>,
}

impl FishboneAnalysis {
    pub fn new(effect: String) -> Self {
        Self {
            effect,
            categories: vec![
                Category { name: "People".to_string(), causes: Vec::new() },
                Category { name: "Process".to_string(), causes: Vec::new() },
                Category { name: "Technology".to_string(), causes: Vec::new() },
                Category { name: "Environment".to_string(), causes: Vec::new() },
            ],
        }
    }

    pub fn add_cause(&mut self, category: &str, cause: String) {
        if let Some(cat) = self.categories.iter_mut().find(|c| c.name == category) {
            cat.causes.push(cause);
        }
    }

    pub fn report(&self) -> String {
        let mut report = format!("Effect: {}\n\n", self.effect);
        for category in &self.categories {
            if !category.causes.is_empty() {
                report.push_str(&format!("{}:\n", category.name));
                for cause in &category.causes {
                    report.push_str(&format!("  - {}\n", cause));
                }
                report.push('\n');
            }
        }
        report
    }
}
```

### 5.3 故障树分析 (FTA)

```rust
pub enum FaultTreeNode {
    Event {
        description: String,
        probability: f64,
    },
    AndGate {
        inputs: Vec<Box<FaultTreeNode>>,
    },
    OrGate {
        inputs: Vec<Box<FaultTreeNode>>,
    },
}

impl FaultTreeNode {
    pub fn probability(&self) -> f64 {
        match self {
            Self::Event { probability, .. } => *probability,
            Self::AndGate { inputs } => {
                inputs.iter().map(|node| node.probability()).product()
            }
            Self::OrGate { inputs } => {
                1.0 - inputs.iter().map(|node| 1.0 - node.probability()).product::<f64>()
            }
        }
    }
}

// 使用示例
fn build_system_failure_tree() -> FaultTreeNode {
    FaultTreeNode::OrGate {
        inputs: vec![
            Box::new(FaultTreeNode::Event {
                description: "Database failure".to_string(),
                probability: 0.001,
            }),
            Box::new(FaultTreeNode::Event {
                description: "Network outage".to_string(),
                probability: 0.002,
            }),
            Box::new(FaultTreeNode::AndGate {
                inputs: vec![
                    Box::new(FaultTreeNode::Event {
                        description: "Primary server down".to_string(),
                        probability: 0.01,
                    }),
                    Box::new(FaultTreeNode::Event {
                        description: "Failover failed".to_string(),
                        probability: 0.1,
                    }),
                ],
            }),
        ],
    }
}
```

---

## 6. 实战案例

### 6.1 内存泄漏诊断

```rust
// 使用 heaptrack 或 valgrind 进行诊断

// 常见内存泄漏模式
pub struct LeakyCache {
    data: std::collections::HashMap<String, Vec<u8>>,
}

impl LeakyCache {
    // ❌ 内存泄漏：从不清理旧数据
    pub fn insert(&mut self, key: String, value: Vec<u8>) {
        self.data.insert(key, value);
    }

    // ✅ 修复：使用 LRU 缓存
    pub fn insert_fixed(&mut self, key: String, value: Vec<u8>, max_size: usize) {
        if self.data.len() >= max_size {
            // 移除最旧的项
            if let Some(oldest_key) = self.data.keys().next().cloned() {
                self.data.remove(&oldest_key);
            }
        }
        self.data.insert(key, value);
    }
}

// 诊断工具：内存使用追踪
pub struct MemoryTracker {
    baseline: usize,
    samples: Vec<(std::time::Instant, usize)>,
}

impl MemoryTracker {
    pub fn new() -> Self {
        let baseline = Self::get_memory_usage();
        Self {
            baseline,
            samples: Vec::new(),
        }
    }

    pub fn sample(&mut self) {
        let usage = Self::get_memory_usage();
        self.samples.push((std::time::Instant::now(), usage));
    }

    pub fn detect_leak(&self, threshold_mb: usize) -> bool {
        if let Some((_, latest)) = self.samples.last() {
            (*latest - self.baseline) / 1024 / 1024 > threshold_mb
        } else {
            false
        }
    }

    fn get_memory_usage() -> usize {
        // 简化实现：读取 /proc/self/status
        #[cfg(target_os = "linux")]
        {
            if let Ok(status) = std::fs::read_to_string("/proc/self/status") {
                for line in status.lines() {
                    if line.starts_with("VmRSS:") {
                        if let Some(kb) = line.split_whitespace().nth(1) {
                            return kb.parse::<usize>().unwrap_or(0) * 1024;
                        }
                    }
                }
            }
        }
        0
    }
}
```

### 6.2 死锁诊断

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// ❌ 死锁示例
fn deadlock_example() {
    let resource1 = Arc::new(Mutex::new(0));
    let resource2 = Arc::new(Mutex::new(0));

    let r1 = Arc::clone(&resource1);
    let r2 = Arc::clone(&resource2);
    let thread1 = thread::spawn(move || {
        let _lock1 = r1.lock().unwrap();
        thread::sleep(Duration::from_millis(10));
        let _lock2 = r2.lock().unwrap();  // 死锁！
    });

    let r1 = Arc::clone(&resource1);
    let r2 = Arc::clone(&resource2);
    let thread2 = thread::spawn(move || {
        let _lock2 = r2.lock().unwrap();
        thread::sleep(Duration::from_millis(10));
        let _lock1 = r1.lock().unwrap();  // 死锁！
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
}

// ✅ 修复：始终按相同顺序获取锁
fn no_deadlock_example() {
    let resource1 = Arc::new(Mutex::new(0));
    let resource2 = Arc::new(Mutex::new(0));

    let r1 = Arc::clone(&resource1);
    let r2 = Arc::clone(&resource2);
    let thread1 = thread::spawn(move || {
        let _lock1 = r1.lock().unwrap();
        let _lock2 = r2.lock().unwrap();
    });

    let r1 = Arc::clone(&resource1);
    let r2 = Arc::clone(&resource2);
    let thread2 = thread::spawn(move || {
        let _lock1 = r1.lock().unwrap();  // 相同顺序
        let _lock2 = r2.lock().unwrap();
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
}

// 死锁检测工具
pub struct DeadlockDetector {
    lock_graph: std::collections::HashMap<usize, Vec<usize>>,
}

impl DeadlockDetector {
    pub fn new() -> Self {
        Self {
            lock_graph: std::collections::HashMap::new(),
        }
    }

    pub fn add_lock_acquisition(&mut self, thread_id: usize, lock_id: usize) {
        self.lock_graph
            .entry(thread_id)
            .or_insert_with(Vec::new)
            .push(lock_id);
    }

    pub fn detect_cycle(&self) -> bool {
        // 简化的环检测（实际应使用拓扑排序）
        for locks in self.lock_graph.values() {
            if locks.len() > 1 {
                // 检查是否有反向依赖
                for other_locks in self.lock_graph.values() {
                    if other_locks.len() > 1 && locks[0] == other_locks[1] && locks[1] == other_locks[0] {
                        return true;  // 检测到循环
                    }
                }
            }
        }
        false
    }
}
```

### 6.3 性能退化诊断

```rust
use std::collections::VecDeque;
use std::time::{Duration, Instant};

pub struct PerformanceBaseline {
    metric_name: String,
    baseline: f64,
    threshold_percent: f64,
    recent_values: VecDeque<(Instant, f64)>,
    max_history: usize,
}

impl PerformanceBaseline {
    pub fn new(metric_name: String, baseline: f64, threshold_percent: f64) -> Self {
        Self {
            metric_name,
            baseline,
            threshold_percent,
            recent_values: VecDeque::new(),
            max_history: 100,
        }
    }

    pub fn record(&mut self, value: f64) {
        self.recent_values.push_back((Instant::now(), value));
        if self.recent_values.len() > self.max_history {
            self.recent_values.pop_front();
        }
    }

    pub fn detect_degradation(&self) -> Option<DegradationAlert> {
        if self.recent_values.is_empty() {
            return None;
        }

        let recent_avg = self.recent_values.iter().map(|(_, v)| v).sum::<f64>()
            / self.recent_values.len() as f64;

        let degradation_percent = ((recent_avg - self.baseline) / self.baseline) * 100.0;

        if degradation_percent > self.threshold_percent {
            Some(DegradationAlert {
                metric_name: self.metric_name.clone(),
                baseline: self.baseline,
                current: recent_avg,
                degradation_percent,
            })
        } else {
            None
        }
    }
}

#[derive(Debug)]
pub struct DegradationAlert {
    pub metric_name: String,
    pub baseline: f64,
    pub current: f64,
    pub degradation_percent: f64,
}
```

---

## 7. 自动化诊断

### 7.1 健康检查系统

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub enum HealthStatus {
    Healthy,
    Degraded(String),
    Unhealthy(String),
}

pub trait HealthCheck: Send + Sync {
    async fn check(&self) -> HealthStatus;
    fn name(&self) -> &str;
}

pub struct HealthChecker {
    checks: Vec<Arc<dyn HealthCheck>>,
}

impl HealthChecker {
    pub fn new() -> Self {
        Self { checks: Vec::new() }
    }

    pub fn add_check(&mut self, check: Arc<dyn HealthCheck>) {
        self.checks.push(check);
    }

    pub async fn run_all_checks(&self) -> Vec<(String, HealthStatus)> {
        let mut results = Vec::new();
        for check in &self.checks {
            let status = check.check().await;
            results.push((check.name().to_string(), status));
        }
        results
    }

    pub async fn is_healthy(&self) -> bool {
        self.run_all_checks()
            .await
            .iter()
            .all(|(_, status)| matches!(status, HealthStatus::Healthy))
    }
}

// 示例：数据库健康检查
pub struct DatabaseHealthCheck {
    // 数据库连接
}

impl HealthCheck for DatabaseHealthCheck {
    async fn check(&self) -> HealthStatus {
        // 简化实现
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        HealthStatus::Healthy
    }

    fn name(&self) -> &str {
        "database"
    }
}
```

### 7.2 异常检测

```rust
pub struct AnomalyDetector {
    window_size: usize,
    threshold_stddev: f64,
    values: VecDeque<f64>,
}

impl AnomalyDetector {
    pub fn new(window_size: usize, threshold_stddev: f64) -> Self {
        Self {
            window_size,
            threshold_stddev,
            values: VecDeque::new(),
        }
    }

    pub fn add_value(&mut self, value: f64) -> bool {
        self.values.push_back(value);
        if self.values.len() > self.window_size {
            self.values.pop_front();
        }

        if self.values.len() < 10 {
            return false;  // 数据不足
        }

        let mean = self.values.iter().sum::<f64>() / self.values.len() as f64;
        let variance = self.values.iter()
            .map(|v| (v - mean).powi(2))
            .sum::<f64>() / self.values.len() as f64;
        let stddev = variance.sqrt();

        (value - mean).abs() > self.threshold_stddev * stddev
    }
}
```

### 7.3 自动修复

```rust
pub trait AutoRemediation: Send + Sync {
    async fn diagnose(&self) -> Option<String>;
    async fn remediate(&self, issue: &str) -> Result<(), String>;
    fn name(&self) -> &str;
}

pub struct AutoRemediationSystem {
    remediations: Vec<Arc<dyn AutoRemediation>>,
}

impl AutoRemediationSystem {
    pub fn new() -> Self {
        Self {
            remediations: Vec::new(),
        }
    }

    pub fn register(&mut self, remediation: Arc<dyn AutoRemediation>) {
        self.remediations.push(remediation);
    }

    pub async fn run(&self) {
        for remediation in &self.remediations {
            if let Some(issue) = remediation.diagnose().await {
                println!("[{}] Detected issue: {}", remediation.name(), issue);
                match remediation.remediate(&issue).await {
                    Ok(_) => println!("[{}] Successfully remediated", remediation.name()),
                    Err(e) => eprintln!("[{}] Remediation failed: {}", remediation.name(), e),
                }
            }
        }
    }
}

// 示例：自动重启服务
pub struct ServiceRestarter;

impl AutoRemediation for ServiceRestarter {
    async fn diagnose(&self) -> Option<String> {
        // 检查服务是否响应
        None  // 简化实现
    }

    async fn remediate(&self, issue: &str) -> Result<(), String> {
        // 重启服务
        Ok(())
    }

    fn name(&self) -> &str {
        "service_restarter"
    }
}
```

---

## 8. 总结

### 核心要点

1. **故障分类**: P0-P4 级别，明确响应时间
2. **系统化诊断**: 收集证据 → 提出假设 → 验证 → 根因分析
3. **日志分析**: 结构化日志、聚合搜索、模式识别
4. **核心转储**: 配置、分析、常见崩溃模式
5. **分布式追踪**: OpenTelemetry、上下文传播、慢请求检测
6. **根因分析**: 5-Why、鱼骨图、故障树分析
7. **自动化**: 健康检查、异常检测、自动修复

### 最佳实践

| 场景 | 推荐做法 | 工具 |
|------|---------|------|
| **日志分析** | 结构化日志 + JSON 格式 | tracing, Elasticsearch |
| **崩溃诊断** | 核心转储 + 调试符号 | gdb, rust-gdb |
| **性能问题** | 分布式追踪 | OpenTelemetry, Jaeger |
| **根因分析** | 5-Why + 鱼骨图 | 自定义工具 |
| **自动化** | 健康检查 + 自动修复 | 自定义系统 |

**常见陷阱**:

- ❌ 缺乏结构化日志
- ❌ 未启用核心转储
- ❌ 忽略分布式追踪
- ❌ 缺乏自动化诊断
- ❌ 不进行根因分析
- ✅ 使用统一的可观测性平台
- ✅ 保留调试符号
- ✅ 实施端到端追踪
- ✅ 建立自动化故障响应
- ✅ 文档化常见故障模式

---

## 📚 参考资源

**官方文档**:

- [Rust Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [tracing Documentation](https://docs.rs/tracing/)
- [OpenTelemetry Rust](https://opentelemetry.io/docs/instrumentation/rust/)

**工具**:

- `gdb` / `rust-gdb` - 调试器
- `valgrind` - 内存分析
- `heaptrack` - 内存追踪
- `Jaeger` - 分布式追踪
- `Elasticsearch` - 日志聚合

**相关文档**:

- [Tier 2: 监控可观测性指南](../tier_02_guides/04_监控可观测性指南.md)
- [Tier 4: 性能调优](./01_性能调优.md)
- [Tier 4: 测试策略进阶](./03_测试策略进阶.md)

---

**文档维护**: C13 Reliability Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
