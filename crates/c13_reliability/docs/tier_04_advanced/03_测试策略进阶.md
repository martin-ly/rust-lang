# C13 Reliability - Tier 4: 测试策略进阶

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 50 分钟  
> **难度**: ⭐⭐⭐⭐⭐ (专家级)

---


## 📊 目录

- [📋 目录](#目录)
- [1. 高级测试策略概述](#1-高级测试策略概述)
- [2. 属性测试 (Property-Based Testing)](#2-属性测试-property-based-testing)
  - [2.1 使用 proptest](#21-使用-proptest)
  - [2.2 高级属性](#22-高级属性)
- [3. 模糊测试 (Fuzzing)](#3-模糊测试-fuzzing)
  - [3.1 使用 cargo-fuzz](#31-使用-cargo-fuzz)
  - [3.2 结构化 Fuzzing](#32-结构化-fuzzing)
- [4. 混沌工程 (Chaos Engineering)](#4-混沌工程-chaos-engineering)
  - [4.1 故障注入框架](#41-故障注入框架)
  - [4.2 网络混沌测试](#42-网络混沌测试)
- [5. 突变测试 (Mutation Testing)](#5-突变测试-mutation-testing)
  - [5.1 使用 cargo-mutants](#51-使用-cargo-mutants)
  - [5.2 突变算子](#52-突变算子)
- [6. 合约测试 (Contract Testing)](#6-合约测试-contract-testing)
  - [6.1 Pact 模式](#61-pact-模式)
- [7. 测试策略矩阵](#7-测试策略矩阵)
- [8. 总结](#8-总结)
  - [核心要点](#核心要点)
  - [最佳实践](#最佳实践)
- [📚 参考资源](#参考资源)


## 📋 目录

- [C13 Reliability - Tier 4: 测试策略进阶](#c13-reliability---tier-4-测试策略进阶)
  - [📋 目录](#-目录)
  - [1. 高级测试策略概述](#1-高级测试策略概述)
  - [2. 属性测试 (Property-Based Testing)](#2-属性测试-property-based-testing)
    - [2.1 使用 proptest](#21-使用-proptest)
    - [2.2 高级属性](#22-高级属性)
  - [3. 模糊测试 (Fuzzing)](#3-模糊测试-fuzzing)
    - [3.1 使用 cargo-fuzz](#31-使用-cargo-fuzz)
    - [3.2 结构化 Fuzzing](#32-结构化-fuzzing)
  - [4. 混沌工程 (Chaos Engineering)](#4-混沌工程-chaos-engineering)
    - [4.1 故障注入框架](#41-故障注入框架)
    - [4.2 网络混沌测试](#42-网络混沌测试)
  - [5. 突变测试 (Mutation Testing)](#5-突变测试-mutation-testing)
    - [5.1 使用 cargo-mutants](#51-使用-cargo-mutants)
    - [5.2 突变算子](#52-突变算子)
  - [6. 合约测试 (Contract Testing)](#6-合约测试-contract-testing)
    - [6.1 Pact 模式](#61-pact-模式)
  - [7. 测试策略矩阵](#7-测试策略矩阵)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 高级测试策略概述

**测试金字塔 (进阶版)**:

```text
         E2E Tests (5%)
        /            \
    Contract Tests (10%)
      /            \
  Integration Tests (15%)
    /            \
 Unit Tests (70%)
   /          \
Property Tests + Fuzz Tests + Mutation Tests
```

**测试类型对比**:

| 测试类型 | 目标 | 工具 | 运行时间 | 覆盖率 |
|---------|------|------|---------|--------|
| 单元测试 | 函数正确性 | `#[test]` | 秒级 | 代码覆盖 |
| 属性测试 | 不变式验证 | proptest/quickcheck | 分钟级 | 边界条件 |
| 模糊测试 | 异常输入 | cargo-fuzz | 小时-天级 | 输入空间 |
| 混沌测试 | 系统韧性 | 自定义 | 分钟-小时级 | 故障注入 |
| 突变测试 | 测试质量 | cargo-mutants | 小时级 | 测试有效性 |

---

## 2. 属性测试 (Property-Based Testing)

### 2.1 使用 proptest

**基础示例**:

```rust
use proptest::prelude::*;

// 属性：任何数加上 0 等于自身
proptest! {
    #[test]
    fn test_add_zero(x in any::<i32>()) {
        prop_assert_eq!(x + 0, x);
    }
}

// 属性：Vec 反转两次等于原始Vec
proptest! {
    #[test]
    fn test_vec_reverse(vec in prop::collection::vec(any::<i32>(), 0..100)) {
        let mut reversed = vec.clone();
        reversed.reverse();
        reversed.reverse();
        prop_assert_eq!(vec, reversed);
    }
}
```

**自定义策略**:

```rust
use proptest::strategy::{Strategy, BoxedStrategy};

// 生成有效的电子邮件
fn email_strategy() -> BoxedStrategy<String> {
    "[a-z]{5,10}@[a-z]{5,10}\\.(com|org|net)"
        .prop_map(|s| s.to_string())
        .boxed()
}

// 生成有效的 JSON 对象
fn json_strategy() -> BoxedStrategy<serde_json::Value> {
    prop::collection::hash_map(
        "[a-z]{1,10}",
        any::<i64>().prop_map(serde_json::Value::from),
        0..10,
    )
    .prop_map(serde_json::Value::Object)
    .prop_map(|v| serde_json::Value::Object(v.as_object().unwrap().clone()))
    .boxed()
}

proptest! {
    #[test]
    fn test_email_validation(email in email_strategy()) {
        assert!(validate_email(&email));
    }
}

fn validate_email(email: &str) -> bool {
    email.contains('@') && email.contains('.')
}
```

### 2.2 高级属性

**不变式测试**:

```rust
#[derive(Debug, Clone)]
struct BinaryTree {
    value: i32,
    left: Option<Box<BinaryTree>>,
    right: Option<Box<BinaryTree>>,
}

impl BinaryTree {
    fn insert(&mut self, value: i32) {
        if value < self.value {
            match &mut self.left {
                Some(left) => left.insert(value),
                None => self.left = Some(Box::new(BinaryTree { value, left: None, right: None })),
            }
        } else {
            match &mut self.right {
                Some(right) => right.insert(value),
                None => self.right = Some(Box::new(BinaryTree { value, left: None, right: None })),
            }
        }
    }

    fn is_valid_bst(&self) -> bool {
        self.is_valid_bst_helper(i32::MIN, i32::MAX)
    }

    fn is_valid_bst_helper(&self, min: i32, max: i32) -> bool {
        if self.value <= min || self.value >= max {
            return false;
        }
        let left_valid = self.left.as_ref().map_or(true, |l| l.is_valid_bst_helper(min, self.value));
        let right_valid = self.right.as_ref().map_or(true, |r| r.is_valid_bst_helper(self.value, max));
        left_valid && right_valid
    }
}

proptest! {
    #[test]
    fn test_bst_invariant(values in prop::collection::vec(any::<i32>(), 1..100)) {
        let mut tree = BinaryTree { value: values[0], left: None, right: None };
        for &value in &values[1..] {
            tree.insert(value);
        }
        prop_assert!(tree.is_valid_bst());
    }
}
```

---

## 3. 模糊测试 (Fuzzing)

### 3.1 使用 cargo-fuzz

**安装和设置**:

```bash
cargo install cargo-fuzz
cargo fuzz init
cargo fuzz add parse_json
```

**Fuzz Target**:

```rust
// fuzz/fuzz_targets/parse_json.rs
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = serde_json::from_str::<serde_json::Value>(s);
    }
});
```

**运行**:

```bash
cargo fuzz run parse_json
```

### 3.2 结构化 Fuzzing

**使用 arbitrary**:

```rust
use arbitrary::Arbitrary;

#[derive(Debug, Arbitrary)]
struct ParseRequest {
    method: HttpMethod,
    path: String,
    headers: Vec<(String, String)>,
    body: Vec<u8>,
}

#[derive(Debug, Arbitrary)]
enum HttpMethod {
    GET,
    POST,
    PUT,
    DELETE,
}

#[cfg(fuzzing)]
fuzz_target!(|req: ParseRequest| {
    let _ = process_request(&req);
});

fn process_request(req: &ParseRequest) -> Result<(), Box<dyn std::error::Error>> {
    // 你的请求处理逻辑
    Ok(())
}
```

---

## 4. 混沌工程 (Chaos Engineering)

### 4.1 故障注入框架

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

pub struct ChaosMonkey {
    enabled: Arc<AtomicBool>,
    failure_rate: f64,  // 0.0-1.0
}

impl ChaosMonkey {
    pub fn new(failure_rate: f64) -> Self {
        Self {
            enabled: Arc::new(AtomicBool::new(true)),
            failure_rate,
        }
    }

    pub fn should_fail(&self) -> bool {
        if !self.enabled.load(Ordering::Relaxed) {
            return false;
        }
        rand::random::<f64>() < self.failure_rate
    }

    pub fn inject_delay(&self, base_ms: u64) {
        if self.should_fail() {
            let delay = rand::random::<u64>() % (base_ms * 10);
            std::thread::sleep(std::time::Duration::from_millis(delay));
        }
    }

    pub fn inject_error<T, E>(&self, error: E) -> Result<T, E> {
        if self.should_fail() {
            Err(error)
        } else {
            // 正常执行不返回错误
            unreachable!("This should not be called directly")
        }
    }
}

// 使用示例
async fn fetch_data_with_chaos(chaos: &ChaosMonkey) -> Result<String, Box<dyn std::error::Error>> {
    // 注入延迟
    chaos.inject_delay(100);

    // 注入故障
    if chaos.should_fail() {
        return Err("Chaos: Network timeout".into());
    }

    // 正常逻辑
    Ok("data".to_string())
}
```

### 4.2 网络混沌测试

```rust
use tokio::net::TcpStream;

pub struct NetworkChaos {
    drop_rate: f64,
    corrupt_rate: f64,
    delay_ms: u64,
}

impl NetworkChaos {
    pub async fn send_with_chaos(
        &self,
        stream: &mut TcpStream,
        data: &[u8],
    ) -> std::io::Result<()> {
        use tokio::io::AsyncWriteExt;

        // 丢包
        if rand::random::<f64>() < self.drop_rate {
            return Ok(());  // 假装发送成功，实际丢弃
        }

        // 延迟
        if self.delay_ms > 0 {
            tokio::time::sleep(tokio::time::Duration::from_millis(self.delay_ms)).await;
        }

        // 数据损坏
        let data_to_send = if rand::random::<f64>() < self.corrupt_rate {
            let mut corrupted = data.to_vec();
            if !corrupted.is_empty() {
                let idx = rand::random::<usize>() % corrupted.len();
                corrupted[idx] = rand::random();
            }
            corrupted
        } else {
            data.to_vec()
        };

        stream.write_all(&data_to_send).await
    }
}
```

---

## 5. 突变测试 (Mutation Testing)

### 5.1 使用 cargo-mutants

```bash
cargo install cargo-mutants
cargo mutants
```

### 5.2 突变算子

**常见突变**:

| 原始代码 | 突变后 | 类型 |
|---------|--------|------|
| `x + y` | `x - y` | 算术运算符 |
| `x == y` | `x != y` | 关系运算符 |
| `if cond` | `if !cond` | 条件取反 |
| `return x` | `return 0` | 返回值 |

**手动突变测试**:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn add(a: i32, b: i32) -> i32 {
        #[cfg(not(mutation_test))]
        { a + b }
        
        #[cfg(mutation_test)]
        { a - b }  // 突变：+ 改为 -
    }

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }

    // 这个测试应该捕获突变
    #[test]
    #[cfg(mutation_test)]
    fn test_add_mutation() {
        assert_ne!(add(2, 3), 5);  // 突变后会失败
    }
}
```

---

## 6. 合约测试 (Contract Testing)

### 6.1 Pact 模式

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct UserRequest {
    pub id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserResponse {
    pub id: u64,
    pub name: String,
    pub email: String,
}

// 提供者测试
#[cfg(test)]
mod provider_tests {
    use super::*;

    #[test]
    fn test_get_user_contract() {
        let request = UserRequest { id: 1 };
        let response = get_user(&request).unwrap();

        // 验证合约
        assert_eq!(response.id, request.id);
        assert!(!response.name.is_empty());
        assert!(response.email.contains('@'));
    }

    fn get_user(req: &UserRequest) -> Result<UserResponse, Box<dyn std::error::Error>> {
        Ok(UserResponse {
            id: req.id,
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        })
    }
}

// 消费者测试
#[cfg(test)]
mod consumer_tests {
    use super::*;

    #[test]
    fn test_consume_user_contract() {
        let response = UserResponse {
            id: 1,
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        };

        // 消费者验证
        assert_eq!(response.id, 1);
        assert_eq!(response.name, "Alice");
    }
}
```

---

## 7. 测试策略矩阵

**选择指南**:

| 场景 | 推荐策略 | 工具 | 优先级 |
|------|---------|------|--------|
| **基础功能** | 单元测试 | `#[test]` | ⭐⭐⭐⭐⭐ |
| **边界条件** | 属性测试 | proptest | ⭐⭐⭐⭐ |
| **安全输入** | 模糊测试 | cargo-fuzz | ⭐⭐⭐⭐ |
| **系统韧性** | 混沌工程 | 自定义 | ⭐⭐⭐ |
| **测试质量** | 突变测试 | cargo-mutants | ⭐⭐⭐ |
| **API 兼容** | 合约测试 | 自定义 | ⭐⭐⭐⭐ |

**覆盖率目标**:

```text
单元测试: 80%+ 代码覆盖
属性测试: 100% 关键不变式
模糊测试: 24 小时+ 持续运行
混沌测试: 定期执行 (每周)
突变测试: 70%+ 突变存活率
```

---

## 8. 总结

### 核心要点

1. **属性测试**: 验证不变式，发现边界条件
2. **模糊测试**: 异常输入，安全漏洞
3. **混沌工程**: 系统韧性，故障注入
4. **突变测试**: 测试质量，有效性验证
5. **合约测试**: API 兼容性，服务契约
6. **综合策略**: 多层次测试金字塔

### 最佳实践

| 阶段 | 策略 | 频率 |
|------|------|------|
| **开发** | 单元测试 + 属性测试 | 每次提交 |
| **CI** | 集成测试 + 突变测试 | 每次 PR |
| **Pre-Prod** | 混沌测试 + 负载测试 | 每次发布 |
| **Production** | 监控 + 金丝雀部署 | 持续 |

**常见陷阱**:

- ❌ 只依赖单元测试
- ❌ 忽略边界条件
- ❌ 缺少混沌测试
- ❌ 测试覆盖率虚高
- ✅ 多层次测试策略
- ✅ 属性测试关键逻辑
- ✅ 定期模糊测试
- ✅ 使用突变测试验证测试质量

---

## 📚 参考资源

**工具**:

- `proptest` - 属性测试
- `cargo-fuzz` - 模糊测试
- `cargo-mutants` - 突变测试

**相关文档**:

- [Tier 2: 测试策略指南](../tier_02_guides/03_测试策略指南.md)
- [Tier 4: 故障分析与诊断](./02_故障分析与诊断.md)

---

**文档维护**: C13 Reliability Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
