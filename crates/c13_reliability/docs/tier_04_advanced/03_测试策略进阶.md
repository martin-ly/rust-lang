# C13 Reliability - Tier 4: æµ‹è¯•ç­–ç•¥è¿›é˜¶

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 50 åˆ†é’Ÿ  
> **éš¾åº¦**: â­â­â­â­â­ (ä¸“å®¶çº§)

---

## ğŸ“‹ ç›®å½•

- [C13 Reliability - Tier 4: æµ‹è¯•ç­–ç•¥è¿›é˜¶](#c13-reliability---tier-4-æµ‹è¯•ç­–ç•¥è¿›é˜¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. é«˜çº§æµ‹è¯•ç­–ç•¥æ¦‚è¿°](#1-é«˜çº§æµ‹è¯•ç­–ç•¥æ¦‚è¿°)
  - [2. å±æ€§æµ‹è¯• (Property-Based Testing)](#2-å±æ€§æµ‹è¯•-property-based-testing)
    - [2.1 ä½¿ç”¨ proptest](#21-ä½¿ç”¨-proptest)
    - [2.2 é«˜çº§å±æ€§](#22-é«˜çº§å±æ€§)
  - [3. æ¨¡ç³Šæµ‹è¯• (Fuzzing)](#3-æ¨¡ç³Šæµ‹è¯•-fuzzing)
    - [3.1 ä½¿ç”¨ cargo-fuzz](#31-ä½¿ç”¨-cargo-fuzz)
    - [3.2 ç»“æ„åŒ– Fuzzing](#32-ç»“æ„åŒ–-fuzzing)
  - [4. æ··æ²Œå·¥ç¨‹ (Chaos Engineering)](#4-æ··æ²Œå·¥ç¨‹-chaos-engineering)
    - [4.1 æ•…éšœæ³¨å…¥æ¡†æ¶](#41-æ•…éšœæ³¨å…¥æ¡†æ¶)
    - [4.2 ç½‘ç»œæ··æ²Œæµ‹è¯•](#42-ç½‘ç»œæ··æ²Œæµ‹è¯•)
  - [5. çªå˜æµ‹è¯• (Mutation Testing)](#5-çªå˜æµ‹è¯•-mutation-testing)
    - [5.1 ä½¿ç”¨ cargo-mutants](#51-ä½¿ç”¨-cargo-mutants)
    - [5.2 çªå˜ç®—å­](#52-çªå˜ç®—å­)
  - [6. åˆçº¦æµ‹è¯• (Contract Testing)](#6-åˆçº¦æµ‹è¯•-contract-testing)
    - [6.1 Pact æ¨¡å¼](#61-pact-æ¨¡å¼)
  - [7. æµ‹è¯•ç­–ç•¥çŸ©é˜µ](#7-æµ‹è¯•ç­–ç•¥çŸ©é˜µ)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. é«˜çº§æµ‹è¯•ç­–ç•¥æ¦‚è¿°

**æµ‹è¯•é‡‘å­—å¡” (è¿›é˜¶ç‰ˆ)**:

```text
         E2E Tests (5%)
        /            \
    Contract Tests (10%)
      /            \
  Integration Tests (15%)
    /            \
 Unit Tests (70%)
   /          \
Property Tests + Fuzz Tests + Mutation Tests
```

**æµ‹è¯•ç±»å‹å¯¹æ¯”**:

| æµ‹è¯•ç±»å‹ | ç›®æ ‡ | å·¥å…· | è¿è¡Œæ—¶é—´ | è¦†ç›–ç‡ |
|---------|------|------|---------|--------|
| å•å…ƒæµ‹è¯• | å‡½æ•°æ­£ç¡®æ€§ | `#[test]` | ç§’çº§ | ä»£ç è¦†ç›– |
| å±æ€§æµ‹è¯• | ä¸å˜å¼éªŒè¯ | proptest/quickcheck | åˆ†é’Ÿçº§ | è¾¹ç•Œæ¡ä»¶ |
| æ¨¡ç³Šæµ‹è¯• | å¼‚å¸¸è¾“å…¥ | cargo-fuzz | å°æ—¶-å¤©çº§ | è¾“å…¥ç©ºé—´ |
| æ··æ²Œæµ‹è¯• | ç³»ç»ŸéŸ§æ€§ | è‡ªå®šä¹‰ | åˆ†é’Ÿ-å°æ—¶çº§ | æ•…éšœæ³¨å…¥ |
| çªå˜æµ‹è¯• | æµ‹è¯•è´¨é‡ | cargo-mutants | å°æ—¶çº§ | æµ‹è¯•æœ‰æ•ˆæ€§ |

---

## 2. å±æ€§æµ‹è¯• (Property-Based Testing)

### 2.1 ä½¿ç”¨ proptest

**åŸºç¡€ç¤ºä¾‹**:

```rust
use proptest::prelude::*;

// å±æ€§ï¼šä»»ä½•æ•°åŠ ä¸Š 0 ç­‰äºè‡ªèº«
proptest! {
    #[test]
    fn test_add_zero(x in any::<i32>()) {
        prop_assert_eq!(x + 0, x);
    }
}

// å±æ€§ï¼šVec åè½¬ä¸¤æ¬¡ç­‰äºåŸå§‹Vec
proptest! {
    #[test]
    fn test_vec_reverse(vec in prop::collection::vec(any::<i32>(), 0..100)) {
        let mut reversed = vec.clone();
        reversed.reverse();
        reversed.reverse();
        prop_assert_eq!(vec, reversed);
    }
}
```

**è‡ªå®šä¹‰ç­–ç•¥**:

```rust
use proptest::strategy::{Strategy, BoxedStrategy};

// ç”Ÿæˆæœ‰æ•ˆçš„ç”µå­é‚®ä»¶
fn email_strategy() -> BoxedStrategy<String> {
    "[a-z]{5,10}@[a-z]{5,10}\\.(com|org|net)"
        .prop_map(|s| s.to_string())
        .boxed()
}

// ç”Ÿæˆæœ‰æ•ˆçš„ JSON å¯¹è±¡
fn json_strategy() -> BoxedStrategy<serde_json::Value> {
    prop::collection::hash_map(
        "[a-z]{1,10}",
        any::<i64>().prop_map(serde_json::Value::from),
        0..10,
    )
    .prop_map(serde_json::Value::Object)
    .prop_map(|v| serde_json::Value::Object(v.as_object().unwrap().clone()))
    .boxed()
}

proptest! {
    #[test]
    fn test_email_validation(email in email_strategy()) {
        assert!(validate_email(&email));
    }
}

fn validate_email(email: &str) -> bool {
    email.contains('@') && email.contains('.')
}
```

### 2.2 é«˜çº§å±æ€§

**ä¸å˜å¼æµ‹è¯•**:

```rust
#[derive(Debug, Clone)]
struct BinaryTree {
    value: i32,
    left: Option<Box<BinaryTree>>,
    right: Option<Box<BinaryTree>>,
}

impl BinaryTree {
    fn insert(&mut self, value: i32) {
        if value < self.value {
            match &mut self.left {
                Some(left) => left.insert(value),
                None => self.left = Some(Box::new(BinaryTree { value, left: None, right: None })),
            }
        } else {
            match &mut self.right {
                Some(right) => right.insert(value),
                None => self.right = Some(Box::new(BinaryTree { value, left: None, right: None })),
            }
        }
    }

    fn is_valid_bst(&self) -> bool {
        self.is_valid_bst_helper(i32::MIN, i32::MAX)
    }

    fn is_valid_bst_helper(&self, min: i32, max: i32) -> bool {
        if self.value <= min || self.value >= max {
            return false;
        }
        let left_valid = self.left.as_ref().map_or(true, |l| l.is_valid_bst_helper(min, self.value));
        let right_valid = self.right.as_ref().map_or(true, |r| r.is_valid_bst_helper(self.value, max));
        left_valid && right_valid
    }
}

proptest! {
    #[test]
    fn test_bst_invariant(values in prop::collection::vec(any::<i32>(), 1..100)) {
        let mut tree = BinaryTree { value: values[0], left: None, right: None };
        for &value in &values[1..] {
            tree.insert(value);
        }
        prop_assert!(tree.is_valid_bst());
    }
}
```

---

## 3. æ¨¡ç³Šæµ‹è¯• (Fuzzing)

### 3.1 ä½¿ç”¨ cargo-fuzz

**å®‰è£…å’Œè®¾ç½®**:

```bash
cargo install cargo-fuzz
cargo fuzz init
cargo fuzz add parse_json
```

**Fuzz Target**:

```rust
// fuzz/fuzz_targets/parse_json.rs
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = serde_json::from_str::<serde_json::Value>(s);
    }
});
```

**è¿è¡Œ**:

```bash
cargo fuzz run parse_json
```

### 3.2 ç»“æ„åŒ– Fuzzing

**ä½¿ç”¨ arbitrary**:

```rust
use arbitrary::Arbitrary;

#[derive(Debug, Arbitrary)]
struct ParseRequest {
    method: HttpMethod,
    path: String,
    headers: Vec<(String, String)>,
    body: Vec<u8>,
}

#[derive(Debug, Arbitrary)]
enum HttpMethod {
    GET,
    POST,
    PUT,
    DELETE,
}

#[cfg(fuzzing)]
fuzz_target!(|req: ParseRequest| {
    let _ = process_request(&req);
});

fn process_request(req: &ParseRequest) -> Result<(), Box<dyn std::error::Error>> {
    // ä½ çš„è¯·æ±‚å¤„ç†é€»è¾‘
    Ok(())
}
```

---

## 4. æ··æ²Œå·¥ç¨‹ (Chaos Engineering)

### 4.1 æ•…éšœæ³¨å…¥æ¡†æ¶

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

pub struct ChaosMonkey {
    enabled: Arc<AtomicBool>,
    failure_rate: f64,  // 0.0-1.0
}

impl ChaosMonkey {
    pub fn new(failure_rate: f64) -> Self {
        Self {
            enabled: Arc::new(AtomicBool::new(true)),
            failure_rate,
        }
    }

    pub fn should_fail(&self) -> bool {
        if !self.enabled.load(Ordering::Relaxed) {
            return false;
        }
        rand::random::<f64>() < self.failure_rate
    }

    pub fn inject_delay(&self, base_ms: u64) {
        if self.should_fail() {
            let delay = rand::random::<u64>() % (base_ms * 10);
            std::thread::sleep(std::time::Duration::from_millis(delay));
        }
    }

    pub fn inject_error<T, E>(&self, error: E) -> Result<T, E> {
        if self.should_fail() {
            Err(error)
        } else {
            // æ­£å¸¸æ‰§è¡Œä¸è¿”å›é”™è¯¯
            unreachable!("This should not be called directly")
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn fetch_data_with_chaos(chaos: &ChaosMonkey) -> Result<String, Box<dyn std::error::Error>> {
    // æ³¨å…¥å»¶è¿Ÿ
    chaos.inject_delay(100);

    // æ³¨å…¥æ•…éšœ
    if chaos.should_fail() {
        return Err("Chaos: Network timeout".into());
    }

    // æ­£å¸¸é€»è¾‘
    Ok("data".to_string())
}
```

### 4.2 ç½‘ç»œæ··æ²Œæµ‹è¯•

```rust
use tokio::net::TcpStream;

pub struct NetworkChaos {
    drop_rate: f64,
    corrupt_rate: f64,
    delay_ms: u64,
}

impl NetworkChaos {
    pub async fn send_with_chaos(
        &self,
        stream: &mut TcpStream,
        data: &[u8],
    ) -> std::io::Result<()> {
        use tokio::io::AsyncWriteExt;

        // ä¸¢åŒ…
        if rand::random::<f64>() < self.drop_rate {
            return Ok(());  // å‡è£…å‘é€æˆåŠŸï¼Œå®é™…ä¸¢å¼ƒ
        }

        // å»¶è¿Ÿ
        if self.delay_ms > 0 {
            tokio::time::sleep(tokio::time::Duration::from_millis(self.delay_ms)).await;
        }

        // æ•°æ®æŸå
        let data_to_send = if rand::random::<f64>() < self.corrupt_rate {
            let mut corrupted = data.to_vec();
            if !corrupted.is_empty() {
                let idx = rand::random::<usize>() % corrupted.len();
                corrupted[idx] = rand::random();
            }
            corrupted
        } else {
            data.to_vec()
        };

        stream.write_all(&data_to_send).await
    }
}
```

---

## 5. çªå˜æµ‹è¯• (Mutation Testing)

### 5.1 ä½¿ç”¨ cargo-mutants

```bash
cargo install cargo-mutants
cargo mutants
```

### 5.2 çªå˜ç®—å­

**å¸¸è§çªå˜**:

| åŸå§‹ä»£ç  | çªå˜å | ç±»å‹ |
|---------|--------|------|
| `x + y` | `x - y` | ç®—æœ¯è¿ç®—ç¬¦ |
| `x == y` | `x != y` | å…³ç³»è¿ç®—ç¬¦ |
| `if cond` | `if !cond` | æ¡ä»¶å–å |
| `return x` | `return 0` | è¿”å›å€¼ |

**æ‰‹åŠ¨çªå˜æµ‹è¯•**:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn add(a: i32, b: i32) -> i32 {
        #[cfg(not(mutation_test))]
        { a + b }
        
        #[cfg(mutation_test)]
        { a - b }  // çªå˜ï¼š+ æ”¹ä¸º -
    }

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }

    // è¿™ä¸ªæµ‹è¯•åº”è¯¥æ•è·çªå˜
    #[test]
    #[cfg(mutation_test)]
    fn test_add_mutation() {
        assert_ne!(add(2, 3), 5);  // çªå˜åä¼šå¤±è´¥
    }
}
```

---

## 6. åˆçº¦æµ‹è¯• (Contract Testing)

### 6.1 Pact æ¨¡å¼

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct UserRequest {
    pub id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserResponse {
    pub id: u64,
    pub name: String,
    pub email: String,
}

// æä¾›è€…æµ‹è¯•
#[cfg(test)]
mod provider_tests {
    use super::*;

    #[test]
    fn test_get_user_contract() {
        let request = UserRequest { id: 1 };
        let response = get_user(&request).unwrap();

        // éªŒè¯åˆçº¦
        assert_eq!(response.id, request.id);
        assert!(!response.name.is_empty());
        assert!(response.email.contains('@'));
    }

    fn get_user(req: &UserRequest) -> Result<UserResponse, Box<dyn std::error::Error>> {
        Ok(UserResponse {
            id: req.id,
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        })
    }
}

// æ¶ˆè´¹è€…æµ‹è¯•
#[cfg(test)]
mod consumer_tests {
    use super::*;

    #[test]
    fn test_consume_user_contract() {
        let response = UserResponse {
            id: 1,
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        };

        // æ¶ˆè´¹è€…éªŒè¯
        assert_eq!(response.id, 1);
        assert_eq!(response.name, "Alice");
    }
}
```

---

## 7. æµ‹è¯•ç­–ç•¥çŸ©é˜µ

**é€‰æ‹©æŒ‡å—**:

| åœºæ™¯ | æ¨èç­–ç•¥ | å·¥å…· | ä¼˜å…ˆçº§ |
|------|---------|------|--------|
| **åŸºç¡€åŠŸèƒ½** | å•å…ƒæµ‹è¯• | `#[test]` | â­â­â­â­â­ |
| **è¾¹ç•Œæ¡ä»¶** | å±æ€§æµ‹è¯• | proptest | â­â­â­â­ |
| **å®‰å…¨è¾“å…¥** | æ¨¡ç³Šæµ‹è¯• | cargo-fuzz | â­â­â­â­ |
| **ç³»ç»ŸéŸ§æ€§** | æ··æ²Œå·¥ç¨‹ | è‡ªå®šä¹‰ | â­â­â­ |
| **æµ‹è¯•è´¨é‡** | çªå˜æµ‹è¯• | cargo-mutants | â­â­â­ |
| **API å…¼å®¹** | åˆçº¦æµ‹è¯• | è‡ªå®šä¹‰ | â­â­â­â­ |

**è¦†ç›–ç‡ç›®æ ‡**:

```text
å•å…ƒæµ‹è¯•: 80%+ ä»£ç è¦†ç›–
å±æ€§æµ‹è¯•: 100% å…³é”®ä¸å˜å¼
æ¨¡ç³Šæµ‹è¯•: 24 å°æ—¶+ æŒç»­è¿è¡Œ
æ··æ²Œæµ‹è¯•: å®šæœŸæ‰§è¡Œ (æ¯å‘¨)
çªå˜æµ‹è¯•: 70%+ çªå˜å­˜æ´»ç‡
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å±æ€§æµ‹è¯•**: éªŒè¯ä¸å˜å¼ï¼Œå‘ç°è¾¹ç•Œæ¡ä»¶
2. **æ¨¡ç³Šæµ‹è¯•**: å¼‚å¸¸è¾“å…¥ï¼Œå®‰å…¨æ¼æ´
3. **æ··æ²Œå·¥ç¨‹**: ç³»ç»ŸéŸ§æ€§ï¼Œæ•…éšœæ³¨å…¥
4. **çªå˜æµ‹è¯•**: æµ‹è¯•è´¨é‡ï¼Œæœ‰æ•ˆæ€§éªŒè¯
5. **åˆçº¦æµ‹è¯•**: API å…¼å®¹æ€§ï¼ŒæœåŠ¡å¥‘çº¦
6. **ç»¼åˆç­–ç•¥**: å¤šå±‚æ¬¡æµ‹è¯•é‡‘å­—å¡”

### æœ€ä½³å®è·µ

| é˜¶æ®µ | ç­–ç•¥ | é¢‘ç‡ |
|------|------|------|
| **å¼€å‘** | å•å…ƒæµ‹è¯• + å±æ€§æµ‹è¯• | æ¯æ¬¡æäº¤ |
| **CI** | é›†æˆæµ‹è¯• + çªå˜æµ‹è¯• | æ¯æ¬¡ PR |
| **Pre-Prod** | æ··æ²Œæµ‹è¯• + è´Ÿè½½æµ‹è¯• | æ¯æ¬¡å‘å¸ƒ |
| **Production** | ç›‘æ§ + é‡‘ä¸é›€éƒ¨ç½² | æŒç»­ |

**å¸¸è§é™·é˜±**:

- âŒ åªä¾èµ–å•å…ƒæµ‹è¯•
- âŒ å¿½ç•¥è¾¹ç•Œæ¡ä»¶
- âŒ ç¼ºå°‘æ··æ²Œæµ‹è¯•
- âŒ æµ‹è¯•è¦†ç›–ç‡è™šé«˜
- âœ… å¤šå±‚æ¬¡æµ‹è¯•ç­–ç•¥
- âœ… å±æ€§æµ‹è¯•å…³é”®é€»è¾‘
- âœ… å®šæœŸæ¨¡ç³Šæµ‹è¯•
- âœ… ä½¿ç”¨çªå˜æµ‹è¯•éªŒè¯æµ‹è¯•è´¨é‡

---

## ğŸ“š å‚è€ƒèµ„æº

**å·¥å…·**:

- `proptest` - å±æ€§æµ‹è¯•
- `cargo-fuzz` - æ¨¡ç³Šæµ‹è¯•
- `cargo-mutants` - çªå˜æµ‹è¯•

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: æµ‹è¯•ç­–ç•¥æŒ‡å—](../tier_02_guides/03_æµ‹è¯•ç­–ç•¥æŒ‡å—.md)
- [Tier 4: æ•…éšœåˆ†æä¸è¯Šæ–­](./02_æ•…éšœåˆ†æä¸è¯Šæ–­.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C13 Reliability Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
