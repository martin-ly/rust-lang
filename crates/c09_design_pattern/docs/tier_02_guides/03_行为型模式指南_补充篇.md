# 3.2 è¡Œä¸ºå‹æ¨¡å¼è¡¥å……ç¯‡

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—ï¼ˆè¡¥å……ï¼‰
> **è¡¥å……å†…å®¹**: Chain of Responsibility / Template Method / Memento / Mediator / Interpreter
> **éš¾åº¦**: â­â­â­ ä¸­çº§
> **æœ€åæ›´æ–°**: 2026-02-28

---

## ğŸ“‹ ç›®å½•

- [3.2 è¡Œä¸ºå‹æ¨¡å¼è¡¥å……ç¯‡](#32-è¡Œä¸ºå‹æ¨¡å¼è¡¥å……ç¯‡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility)](#1-è´£ä»»é“¾æ¨¡å¼-chain-of-responsibility)
    - [1.1 æ¨¡å¼å®šä¹‰](#11-æ¨¡å¼å®šä¹‰)
    - [1.2 Rust å®ç°](#12-rust-å®ç°)
    - [1.3 ä½¿ç”¨åœºæ™¯](#13-ä½¿ç”¨åœºæ™¯)
  - [2. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method)](#2-æ¨¡æ¿æ–¹æ³•æ¨¡å¼-template-method)
    - [2.1 æ¨¡å¼å®šä¹‰](#21-æ¨¡å¼å®šä¹‰)
    - [2.2 Rust å®ç°](#22-rust-å®ç°)
    - [2.3 æ¨¡æ¿æ–¹æ³•ä¸ç­–ç•¥æ¨¡å¼çš„åŒºåˆ«](#23-æ¨¡æ¿æ–¹æ³•ä¸ç­–ç•¥æ¨¡å¼çš„åŒºåˆ«)
  - [3. å¤‡å¿˜å½•æ¨¡å¼ (Memento)](#3-å¤‡å¿˜å½•æ¨¡å¼-memento)
    - [3.1 æ¨¡å¼å®šä¹‰](#31-æ¨¡å¼å®šä¹‰)
    - [3.2 Rust å®ç°](#32-rust-å®ç°)
    - [3.3 é€‚ç”¨åœºæ™¯](#33-é€‚ç”¨åœºæ™¯)
  - [4. ä¸­ä»‹è€…æ¨¡å¼ (Mediator)](#4-ä¸­ä»‹è€…æ¨¡å¼-mediator)
    - [4.1 æ¨¡å¼å®šä¹‰](#41-æ¨¡å¼å®šä¹‰)
    - [4.2 Rust å®ç°](#42-rust-å®ç°)
    - [4.3 é€‚ç”¨åœºæ™¯](#43-é€‚ç”¨åœºæ™¯)
  - [5. è§£é‡Šå™¨æ¨¡å¼ (Interpreter)](#5-è§£é‡Šå™¨æ¨¡å¼-interpreter)
    - [5.1 æ¨¡å¼å®šä¹‰](#51-æ¨¡å¼å®šä¹‰)
    - [5.2 Rust å®ç°ï¼ˆç®€å•è¡¨è¾¾å¼æ±‚å€¼å™¨ï¼‰](#52-rust-å®ç°ç®€å•è¡¨è¾¾å¼æ±‚å€¼å™¨)
    - [5.3 é€‚ç”¨åœºæ™¯](#53-é€‚ç”¨åœºæ™¯)
  - [6. äº«å…ƒæ¨¡å¼ (Flyweight)](#6-äº«å…ƒæ¨¡å¼-flyweight)
    - [6.1 æ¨¡å¼å®šä¹‰](#61-æ¨¡å¼å®šä¹‰)
    - [6.2 Rust å®ç°](#62-rust-å®ç°)
    - [6.3 å†…éƒ¨çŠ¶æ€ vs å¤–éƒ¨çŠ¶æ€](#63-å†…éƒ¨çŠ¶æ€-vs-å¤–éƒ¨çŠ¶æ€)
  - [âœ… å®Œæˆæ£€æŸ¥](#-å®Œæˆæ£€æŸ¥)

## 1. è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility)

### 1.1 æ¨¡å¼å®šä¹‰

è´£ä»»é“¾æ¨¡å¼å…è®¸ä½ å°†è¯·æ±‚æ²¿ç€å¤„ç†è€…é“¾è¿›è¡Œå‘é€ã€‚
æ”¶åˆ°è¯·æ±‚åï¼Œæ¯ä¸ªå¤„ç†è€…å‡å¯å¯¹è¯·æ±‚è¿›è¡Œå¤„ç†ï¼Œæˆ–å°†å…¶ä¼ é€’ç»™é“¾ä¸Šçš„ä¸‹ä¸ªå¤„ç†è€…ã€‚

### 1.2 Rust å®ç°

```rust
// å¤„ç†è€… trait
trait Handler {
    fn set_next(&mut self, next: Box<dyn Handler>) -> &mut dyn Handler;
    fn handle(&self, request: &str) -> Option<String>;
}

// åŸºç¡€å¤„ç†è€…ï¼ˆæä¾›é»˜è®¤å®ç°ï¼‰
struct BaseHandler {
    next: Option<Box<dyn Handler>>,
}

impl BaseHandler {
    fn new() -> Self {
        Self { next: None }
    }
}

impl Handler for BaseHandler {
    fn set_next(&mut self, next: Box<dyn Handler>) -> &mut dyn Handler {
        self.next = Some(next);
        self
    }

    fn handle(&self, request: &str) -> Option<String> {
        self.next.as_ref()?.handle(request)
    }
}

// å…·ä½“å¤„ç†è€…ï¼šè®¤è¯æ£€æŸ¥
struct AuthHandler {
    base: BaseHandler,
}

impl AuthHandler {
    fn new() -> Self {
        Self { base: BaseHandler::new() }
    }
}

impl Handler for AuthHandler {
    fn set_next(&mut self, next: Box<dyn Handler>) -> &mut dyn Handler {
        self.base.set_next(next);
        self
    }

    fn handle(&self, request: &str) -> Option<String> {
        if request.starts_with("AUTH:") {
            println!("AuthHandler: éªŒè¯é€šè¿‡");
            self.base.handle(request)
        } else {
            println!("AuthHandler: æ— éœ€è®¤è¯ï¼Œç»§ç»­");
            self.base.handle(request)
        }
    }
}

// å…·ä½“å¤„ç†è€…ï¼šæ—¥å¿—è®°å½•
struct LoggingHandler {
    base: BaseHandler,
}

impl LoggingHandler {
    fn new() -> Self {
        Self { base: BaseHandler::new() }
    }
}

impl Handler for LoggingHandler {
    fn set_next(&mut self, next: Box<dyn Handler>) -> &mut dyn Handler {
        self.base.set_next(next);
        self
    }

    fn handle(&self, request: &str) -> Option<String> {
        println!("LoggingHandler: è®°å½•è¯·æ±‚ {}", request);
        self.base.handle(request)
    }
}

// å…·ä½“å¤„ç†è€…ï¼šæœ€ç»ˆå¤„ç†
struct FinalHandler;

impl Handler for FinalHandler {
    fn set_next(&mut self, _next: Box<dyn Handler>) -> &mut dyn Handler {
        self
    }

    fn handle(&self, request: &str) -> Option<String> {
        Some(format!("å¤„ç†å®Œæˆ: {}", request))
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut auth = AuthHandler::new();
    let mut logging = LoggingHandler::new();
    let final_handler = FinalHandler;

    logging.set_next(Box::new(final_handler));
    auth.set_next(Box::new(logging));

    let result = auth.handle("AUTH:admin");
    println!("{:?}", result);
}
```

### 1.3 ä½¿ç”¨åœºæ™¯

- å½“ç¨‹åºéœ€è¦ä½¿ç”¨ä¸åŒæ–¹å¼å¤„ç†ä¸åŒç§ç±»çš„è¯·æ±‚æ—¶
- å½“å¿…é¡»æŒ‰ç…§é¡ºåºæ‰§è¡Œå¤šä¸ªå¤„ç†è€…æ—¶
- å½“å¤„ç†è€…çš„é›†åˆå’Œé¡ºåºéœ€è¦åŠ¨æ€æ”¹å˜æ—¶

---

## 2. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method)

### 2.1 æ¨¡å¼å®šä¹‰

æ¨¡æ¿æ–¹æ³•æ¨¡å¼åœ¨è¶…ç±»ä¸­å®šä¹‰ä¸€ä¸ªç®—æ³•çš„éª¨æ¶ï¼Œå°†æŸäº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­å®ç°ã€‚

### 2.2 Rust å®ç°

```rust
// ä½¿ç”¨ trait å®šä¹‰ç®—æ³•éª¨æ¶
trait DataMiner {
    // æ¨¡æ¿æ–¹æ³• - å®šä¹‰ç®—æ³•éª¨æ¶
    fn mine(&self, path: &str) -> String {
        let file = self.open_file(path);
        let raw_data = self.extract_data(&file);
        let data = self.parse_data(&raw_data);
        let analysis = self.analyze(&data);
        self.send_report(&analysis);
        self.close_file(&file);
        analysis
    }

    // å¿…é¡»ç”±å®ç°è€…æä¾›çš„æ­¥éª¤
    fn open_file(&self, path: &str) -> String;
    fn extract_data(&self, file: &str) -> String;
    fn parse_data(&self, raw: &str) -> Vec<String>;

    // é»˜è®¤å®ç°ï¼Œå¯è¢«å­ç±»è¦†ç›–
    fn analyze(&self, data: &[String]) -> String {
        format!("åˆ†æäº† {} æ¡æ•°æ®", data.len())
    }

    fn send_report(&self, analysis: &str) {
        println!("å‘é€æŠ¥å‘Š: {}", analysis);
    }

    fn close_file(&self, file: &str) {
        println!("å…³é—­æ–‡ä»¶: {}", file);
    }
}

// å…·ä½“å®ç°ï¼šPDFæ•°æ®æŒ–æ˜
struct PdfDataMiner;

impl DataMiner for PdfDataMiner {
    fn open_file(&self, path: &str) -> String {
        format!("PDFæ–‡ä»¶({})", path)
    }

    fn extract_data(&self, file: &str) -> String {
        println!("ä» {} æå–PDFæ•°æ®", file);
        "PDFåŸå§‹æ•°æ®".to_string()
    }

    fn parse_data(&self, raw: &str) -> Vec<String> {
        vec![raw.to_string(), "PDFè§£æç»“æœ".to_string()]
    }
}

// å…·ä½“å®ç°ï¼šCSVæ•°æ®æŒ–æ˜
struct CsvDataMiner {
    delimiter: char,
}

impl CsvDataMiner {
    fn new(delimiter: char) -> Self {
        Self { delimiter }
    }
}

impl DataMiner for CsvDataMiner {
    fn open_file(&self, path: &str) -> String {
        format!("CSVæ–‡ä»¶({})", path)
    }

    fn extract_data(&self, file: &str) -> String {
        println!("ä» {} æå–CSVæ•°æ®", file);
        "CSVåŸå§‹æ•°æ®".to_string()
    }

    fn parse_data(&self, raw: &str) -> Vec<String> {
        raw.split(self.delimiter)
            .map(|s| s.to_string())
            .collect()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let pdf_miner = PdfDataMiner;
    let csv_miner = CsvDataMiner::new(',');

    println!("=== PDFæŒ–æ˜ ===");
    pdf_miner.mine("data.pdf");

    println!("\n=== CSVæŒ–æ˜ ===");
    csv_miner.mine("data.csv");
}
```

### 2.3 æ¨¡æ¿æ–¹æ³•ä¸ç­–ç•¥æ¨¡å¼çš„åŒºåˆ«

| æ¨¡æ¿æ–¹æ³• | ç­–ç•¥æ¨¡å¼ |
|---------|---------|
| ç»§æ‰¿ï¼ˆä»£ç å¤ç”¨ï¼‰ | ç»„åˆï¼ˆå§”æ‰˜ï¼‰ |
| ç®—æ³•éª¨æ¶å›ºå®š | ç®—æ³•å¯å®Œå…¨æ›¿æ¢ |
| éƒ¨åˆ†æ­¥éª¤å¯è¦†ç›– | æ•´ä¸ªç®—æ³•å¯æ›¿æ¢ |

---

## 3. å¤‡å¿˜å½•æ¨¡å¼ (Memento)

### 3.1 æ¨¡å¼å®šä¹‰

å¤‡å¿˜å½•æ¨¡å¼å…è®¸åœ¨ä¸æš´éœ²å¯¹è±¡å®ç°ç»†èŠ‚çš„æƒ…å†µä¸‹æ•è·å’Œæ¢å¤å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ã€‚

### 3.2 Rust å®ç°

```rust
// å¤‡å¿˜å½• - ä¿å­˜ç¼–è¾‘å™¨çŠ¶æ€
#[derive(Clone)]
struct EditorMemento {
    content: String,
    cursor_position: usize,
    timestamp: std::time::SystemTime,
}

impl EditorMemento {
    fn new(content: String, cursor_position: usize) -> Self {
        Self {
            content,
            cursor_position,
            timestamp: std::time::SystemTime::now(),
        }
    }

    fn get_content(&self) -> &str {
        &self.content
    }

    fn get_cursor_position(&self) -> usize {
        self.cursor_position
    }
}

// åŸå‘å™¨ - ç¼–è¾‘å™¨
struct Editor {
    content: String,
    cursor_position: usize,
}

impl Editor {
    fn new() -> Self {
        Self {
            content: String::new(),
            cursor_position: 0,
        }
    }

    fn type_text(&mut self, text: &str) {
        self.content.insert_str(self.cursor_position, text);
        self.cursor_position += text.len();
    }

    fn delete(&mut self) {
        if self.cursor_position < self.content.len() {
            self.content.remove(self.cursor_position);
        }
    }

    // åˆ›å»ºå¤‡å¿˜å½•
    fn save(&self) -> EditorMemento {
        EditorMemento::new(self.content.clone(), self.cursor_position)
    }

    // ä»å¤‡å¿˜å½•æ¢å¤
    fn restore(&mut self, memento: &EditorMemento) {
        self.content = memento.get_content().to_string();
        self.cursor_position = memento.get_cursor_position();
    }

    fn get_content(&self) -> &str {
        &self.content
    }
}

// ç®¡ç†è€… - å†å²è®°å½•
struct History {
    mementos: Vec<EditorMemento>,
    current: usize,
}

impl History {
    fn new() -> Self {
        Self {
            mementos: Vec::new(),
            current: 0,
        }
    }

    fn backup(&mut self, memento: EditorMemento) {
        // åˆ é™¤å½“å‰ä½ç½®ä¹‹åçš„æ‰€æœ‰å†å²
        self.mementos.truncate(self.current);
        self.mementos.push(memento);
        self.current += 1;
    }

    fn undo(&mut self) -> Option<&EditorMemento> {
        if self.current > 0 {
            self.current -= 1;
            self.mementos.get(self.current)
        } else {
            None
        }
    }

    fn redo(&mut self) -> Option<&EditorMemento> {
        if self.current < self.mementos.len() {
            self.current += 1;
            self.mementos.get(self.current - 1)
        } else {
            None
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut editor = Editor::new();
    let mut history = History::new();

    // ç¼–è¾‘å¹¶ä¿å­˜
    editor.type_text("Hello ");
    history.backup(editor.save());

    editor.type_text("World!");
    history.backup(editor.save());

    editor.delete();
    println!("å½“å‰å†…å®¹: {}", editor.get_content());

    // Undo
    if let Some(memento) = history.undo() {
        editor.restore(memento);
        println!("Undoå: {}", editor.get_content());
    }

    // Undo again
    if let Some(memento) = history.undo() {
        editor.restore(memento);
        println!("å†æ¬¡Undoå: {}", editor.get_content());
    }
}
```

### 3.3 é€‚ç”¨åœºæ™¯

- éœ€è¦åˆ›å»ºå¯¹è±¡çŠ¶æ€å¿«ç…§ä»¥ä¾¿æ¢å¤
- ç›´æ¥è®¿é—®å¯¹è±¡çŠ¶æ€ä¼šç ´åå°è£…
- éœ€è¦å®ç°æ’¤é”€/é‡åšåŠŸèƒ½

---

## 4. ä¸­ä»‹è€…æ¨¡å¼ (Mediator)

### 4.1 æ¨¡å¼å®šä¹‰

ä¸­ä»‹è€…æ¨¡å¼è®©ä½ èƒ½å‡å°‘å¯¹è±¡ä¹‹é—´æ··ä¹±æ— åºçš„ä¾èµ–å…³ç³»ã€‚
è¯¥æ¨¡å¼é™åˆ¶å¯¹è±¡ä¹‹é—´çš„ç›´æ¥äº¤äº’ï¼Œè¿«ä½¿å®ƒä»¬é€šè¿‡ä¸€ä¸ªä¸­ä»‹è€…å¯¹è±¡è¿›è¡Œåˆä½œã€‚

### 4.2 Rust å®ç°

```rust
use std::collections::HashMap;

// ä¸­ä»‹è€… trait
trait ChatMediator {
    fn send_message(&self, message: &str, user_id: &str);
    fn add_user(&mut self, user: Box<dyn User>);
}

// ç”¨æˆ· trait
trait User {
    fn get_id(&self) -> &str;
    fn get_name(&self) -> &str;
    fn receive_message(&self, message: &str, from: &str);
    fn send_message(&self, mediator: &dyn ChatMediator, message: &str);
}

// å…·ä½“ä¸­ä»‹è€…
struct ChatRoom {
    users: HashMap<String, Box<dyn User>>,
}

impl ChatRoom {
    fn new() -> Self {
        Self {
            users: HashMap::new(),
        }
    }
}

impl ChatMediator for ChatRoom {
    fn send_message(&self, message: &str, user_id: &str) {
        if let Some(user) = self.users.get(user_id) {
            user.receive_message(message, "System");
        }
    }

    fn add_user(&mut self, user: Box<dyn User>) {
        let id = user.get_id().to_string();
        let name = user.get_name().to_string();
        self.users.insert(id.clone(), user);

        // é€šçŸ¥å…¶ä»–ç”¨æˆ·æœ‰æ–°æˆå‘˜åŠ å…¥
        for (uid, u) in &self.users {
            if uid != &id {
                u.receive_message(&format!("{} åŠ å…¥äº†èŠå¤©å®¤", name), "System");
            }
        }
    }
}

// å…·ä½“ç”¨æˆ·
struct ChatUser {
    id: String,
    name: String,
}

impl ChatUser {
    fn new(id: &str, name: &str) -> Self {
        Self {
            id: id.to_string(),
            name: name.to_string(),
        }
    }
}

impl User for ChatUser {
    fn get_id(&self) -> &str {
        &self.id
    }

    fn get_name(&self) -> &str {
        &self.name
    }

    fn receive_message(&self, message: &str, from: &str) {
        println!("[{} -> {}]: {}", from, self.name, message);
    }

    fn send_message(&self, mediator: &dyn ChatMediator, message: &str) {
        println!("{} å‘é€æ¶ˆæ¯: {}", self.name, message);
        // é€šè¿‡ä¸­ä»‹è€…å¹¿æ’­ç»™æ‰€æœ‰ç”¨æˆ·
        for i in 0..3 {
            mediator.send_message(message, &format!("user{}", i));
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut chat_room = ChatRoom::new();

    let user1 = Box::new(ChatUser::new("user0", "Alice"));
    let user2 = Box::new(ChatUser::new("user1", "Bob"));
    let user3 = Box::new(ChatUser::new("user2", "Charlie"));

    chat_room.add_user(user1);
    chat_room.add_user(user2);
    chat_room.add_user(user3);

    // æ³¨æ„ï¼šå®é™…ä½¿ç”¨éœ€è¦ä¿å­˜ç”¨æˆ·å¼•ç”¨æ¥å‘é€æ¶ˆæ¯
    // è¿™é‡Œç®€åŒ–ä¸ºé€šè¿‡ä¸­ä»‹è€…ç›´æ¥å‘é€
}
```

### 4.3 é€‚ç”¨åœºæ™¯

- å½“å¤šä¸ªå¯¹è±¡ä»¥å¤æ‚æ–¹å¼äº¤äº’ï¼Œå¯¼è‡´éš¾ä»¥ç»´æŠ¤
- å½“éœ€è¦å¤ç”¨ç»„ä»¶ï¼Œä½†ä¾èµ–éš¾ä»¥å¤ç”¨æ—¶
- å½“åˆ›å»ºå¤§é‡å­ç±»æ¥å®šåˆ¶è¡Œä¸ºå˜å¾—å›°éš¾æ—¶

---

## 5. è§£é‡Šå™¨æ¨¡å¼ (Interpreter)

### 5.1 æ¨¡å¼å®šä¹‰

è§£é‡Šå™¨æ¨¡å¼å®ç°ä¸€ä¸ªä¸“ç”¨è¯­è¨€ï¼Œä¸ºå…¶è¯­æ³•åˆ›å»ºè§£é‡Šå™¨ã€‚

### 5.2 Rust å®ç°ï¼ˆç®€å•è¡¨è¾¾å¼æ±‚å€¼å™¨ï¼‰

```rust
// è¡¨è¾¾å¼ trait
trait Expression {
    fn interpret(&self, context: &Context) -> i32;
    fn to_string(&self) -> String;
}

// ä¸Šä¸‹æ–‡
struct Context {
    variables: std::collections::HashMap<String, i32>,
}

impl Context {
    fn new() -> Self {
        Self {
            variables: std::collections::HashMap::new(),
        }
    }

    fn set_variable(&mut self, name: &str, value: i32) {
        self.variables.insert(name.to_string(), value);
    }

    fn get_variable(&self, name: &str) -> i32 {
        *self.variables.get(name).unwrap_or(&0)
    }
}

// æ•°å­—è¡¨è¾¾å¼
struct NumberExpression {
    value: i32,
}

impl NumberExpression {
    fn new(value: i32) -> Self {
        Self { value }
    }
}

impl Expression for NumberExpression {
    fn interpret(&self, _context: &Context) -> i32 {
        self.value
    }

    fn to_string(&self) -> String {
        self.value.to_string()
    }
}

// å˜é‡è¡¨è¾¾å¼
struct VariableExpression {
    name: String,
}

impl VariableExpression {
    fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
        }
    }
}

impl Expression for VariableExpression {
    fn interpret(&self, context: &Context) -> i32 {
        context.get_variable(&self.name)
    }

    fn to_string(&self) -> String {
        self.name.clone()
    }
}

// åŠ æ³•è¡¨è¾¾å¼
struct AddExpression {
    left: Box<dyn Expression>,
    right: Box<dyn Expression>,
}

impl AddExpression {
    fn new(left: Box<dyn Expression>, right: Box<dyn Expression>) -> Self {
        Self { left, right }
    }
}

impl Expression for AddExpression {
    fn interpret(&self, context: &Context) -> i32 {
        self.left.interpret(context) + self.right.interpret(context)
    }

    fn to_string(&self) -> String {
        format!("({} + {})", self.left.to_string(), self.right.to_string())
    }
}

// å‡æ³•è¡¨è¾¾å¼
struct SubtractExpression {
    left: Box<dyn Expression>,
    right: Box<dyn Expression>,
}

impl SubtractExpression {
    fn new(left: Box<dyn Expression>, right: Box<dyn Expression>) -> Self {
        Self { left, right }
    }
}

impl Expression for SubtractExpression {
    fn interpret(&self, context: &Context) -> i32 {
        self.left.interpret(context) - self.right.interpret(context)
    }

    fn to_string(&self) -> String {
        format!("({} - {})", self.left.to_string(), self.right.to_string())
    }
}

// è§£æå™¨
struct Parser;

impl Parser {
    fn parse(expression: &str) -> Box<dyn Expression> {
        // ç®€åŒ–çš„è§£æå™¨ - å®é™…åº”ç”¨éœ€è¦å®Œæ•´çš„è¯­æ³•åˆ†æ
        // è¿™é‡Œæ¼”ç¤ºè§£æ "x + 5 - 3" è¿™æ ·çš„ç®€å•è¡¨è¾¾å¼
        Box::new(NumberExpression::new(42))  // ç®€åŒ–å®ç°
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut context = Context::new();
    context.set_variable("x", 10);
    context.set_variable("y", 5);

    // æ„å»ºè¡¨è¾¾å¼æ ‘: (x + y) - 3
    let expression = SubtractExpression::new(
        Box::new(AddExpression::new(
            Box::new(VariableExpression::new("x")),
            Box::new(VariableExpression::new("y")),
        )),
        Box::new(NumberExpression::new(3)),
    );

    println!("è¡¨è¾¾å¼: {}", expression.to_string());
    println!("ç»“æœ: {}", expression.interpret(&context));
}
```

### 5.3 é€‚ç”¨åœºæ™¯

- å½“éœ€è¦è§£é‡Šç®€å•çš„è¯­æ³•è§„åˆ™
- å½“æ•ˆç‡ä¸æ˜¯å…³é”®è€ƒè™‘å› ç´ æ—¶
- å½“è¯­æ³•è§„åˆ™é¢‘ç¹å˜åŒ–æ—¶

---

## 6. äº«å…ƒæ¨¡å¼ (Flyweight)

### 6.1 æ¨¡å¼å®šä¹‰

äº«å…ƒæ¨¡å¼é€šè¿‡å…±äº«å¤šä¸ªå¯¹è±¡ä¹‹é—´é€šç”¨çš„çŠ¶æ€ï¼Œè®©ä½ èƒ½åœ¨æœ‰é™çš„å†…å­˜å®¹é‡ä¸­è½½å…¥æ›´å¤šå¯¹è±¡ã€‚

### 6.2 Rust å®ç°

```rust
use std::collections::HashMap;
use std::rc::Rc;

// äº«å…ƒ - å…±äº«çš„çŠ¶æ€
#[derive(Clone, Debug)]
struct TreeType {
    name: String,
    color: String,
    texture: String,
}

impl TreeType {
    fn new(name: &str, color: &str, texture: &str) -> Self {
        Self {
            name: name.to_string(),
            color: color.to_string(),
            texture: texture.to_string(),
        }
    }

    fn draw(&self, x: i32, y: i32) {
        println!(
            "åœ¨({}, {})ç»˜åˆ¶{}æ ‘ [é¢œè‰²={}, çº¹ç†={}]",
            x, y, self.name, self.color, self.texture
        );
    }
}

// äº«å…ƒå·¥å‚
struct TreeFactory {
    tree_types: HashMap<String, Rc<TreeType>>,
}

impl TreeFactory {
    fn new() -> Self {
        Self {
            tree_types: HashMap::new(),
        }
    }

    fn get_tree_type(&mut self, name: &str, color: &str, texture: &str) -> Rc<TreeType> {
        let key = format!("{}_{}_{}", name, color, texture);

        self.tree_types
            .entry(key.clone())
            .or_insert_with(|| Rc::new(TreeType::new(name, color, texture)))
            .clone()
    }

    fn get_tree_type_count(&self) -> usize {
        self.tree_types.len()
    }
}

// ä¸Šä¸‹æ–‡ - å¤–éƒ¨çŠ¶æ€
struct Tree {
    x: i32,
    y: i32,
    tree_type: Rc<TreeType>,
}

impl Tree {
    fn new(x: i32, y: i32, tree_type: Rc<TreeType>) -> Self {
        Self { x, y, tree_type }
    }

    fn draw(&self) {
        self.tree_type.draw(self.x, self.y);
    }
}

// æ£®æ—
struct Forest {
    trees: Vec<Tree>,
    factory: TreeFactory,
}

impl Forest {
    fn new() -> Self {
        Self {
            trees: Vec::new(),
            factory: TreeFactory::new(),
        }
    }

    fn plant_tree(&mut self, x: i32, y: i32, name: &str, color: &str, texture: &str) {
        let tree_type = self.factory.get_tree_type(name, color, texture);
        let tree = Tree::new(x, y, tree_type);
        self.trees.push(tree);
    }

    fn draw(&self) {
        for tree in &self.trees {
            tree.draw();
        }
    }

    fn get_tree_type_count(&self) -> usize {
        self.factory.get_tree_type_count()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut forest = Forest::new();

    // ç§æ¤1000æ£µæ ‘ï¼Œä½†åªæœ‰2ç§ç±»å‹
    for i in 0..500 {
        forest.plant_tree(i % 100, i / 100, "æ¾æ ‘", "æ·±ç»¿", "ç²—ç³™");
    }

    for i in 0..500 {
        forest.plant_tree((i % 100) + 200, i / 100, "æ¡¦æ ‘", "ç™½è‰²", "å…‰æ»‘");
    }

    println!("æ€»æ ‘æ•°é‡: {}", 1000);
    println!("å®é™…æ ‘ç±»å‹å¯¹è±¡æ•°é‡: {}", forest.get_tree_type_count());
    println!("å†…å­˜èŠ‚çœ: {}%", (1.0 - 2.0/1000.0) * 100.0);

    // forest.draw();  // ç»˜åˆ¶æ‰€æœ‰æ ‘
}
```

### 6.3 å†…éƒ¨çŠ¶æ€ vs å¤–éƒ¨çŠ¶æ€

| å†…éƒ¨çŠ¶æ€ï¼ˆå…±äº«ï¼‰ | å¤–éƒ¨çŠ¶æ€ï¼ˆæ¯ä¸ªå¯¹è±¡ç‹¬ç«‹ï¼‰ |
|----------------|------------------------|
| æ ‘çš„ç±»å‹ã€é¢œè‰²ã€çº¹ç† | æ ‘çš„ä½ç½®åæ ‡ (x, y) |
| å­—ä½“åç§°ã€å¤§å° | å­—ç¬¦ä½ç½®ã€é¢œè‰² |

---

## âœ… å®Œæˆæ£€æŸ¥

ç°åœ¨ 23 ç§ GoF è®¾è®¡æ¨¡å¼ + Rust ç‰¹æœ‰æ¨¡å¼å…¨éƒ¨å®Œæ•´ï¼š

**åˆ›å»ºå‹æ¨¡å¼ (6)**:

- âœ… Singleton / Factory Method / Abstract Factory / Builder / Prototype / Object Pool

**ç»“æ„å‹æ¨¡å¼ (8)**:

- âœ… Adapter / Bridge / Composite / Decorator / Facade / Proxy / **Flyweight**

**è¡Œä¸ºå‹æ¨¡å¼ (12)**:

- âœ… Strategy / Observer / Command / Iterator / State / Visitor
- âœ… **Chain of Responsibility** / **Template Method** / **Memento** / **Mediator** / **Interpreter**

**Rust ç‰¹æœ‰æ¨¡å¼ (3)**:

- âœ… RAII / Newtype / Typestate

---

**ç»´æŠ¤è€…**: Rust å­¦ä¹ é¡¹ç›®å›¢é˜Ÿ
**æœ€åæ›´æ–°**: 2026-02-28
**ç‰ˆæœ¬**: v1.0 (è¡¥å……å®Œæ•´)
