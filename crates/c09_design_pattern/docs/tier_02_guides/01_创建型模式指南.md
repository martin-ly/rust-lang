# 01 åˆ›å»ºå‹æ¨¡å¼æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—  
> **ç›®æ ‡è¯»è€…**: éœ€è¦æŒæ¡å¯¹è±¡åˆ›å»ºæ¨¡å¼çš„å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: Rust åŸºç¡€è¯­æ³•ã€æ‰€æœ‰æƒç³»ç»Ÿ

**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+

---

## ğŸ“‹ ç›®å½•

- [01 åˆ›å»ºå‹æ¨¡å¼æŒ‡å—](#01-åˆ›å»ºå‹æ¨¡å¼æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. Builder (å»ºé€ è€…æ¨¡å¼)](#1-builder-å»ºé€ è€…æ¨¡å¼)
    - [1.1 åŸºæœ¬ Builder](#11-åŸºæœ¬-builder)
    - [1.2 Derive Builder (ä½¿ç”¨å®)](#12-derive-builder-ä½¿ç”¨å®)
    - [1.3 ç±»å‹çŠ¶æ€ Builder](#13-ç±»å‹çŠ¶æ€-builder)
  - [2. Factory (å·¥å‚æ¨¡å¼)](#2-factory-å·¥å‚æ¨¡å¼)
    - [2.1 ç®€å•å·¥å‚](#21-ç®€å•å·¥å‚)
    - [2.2 å·¥å‚æ–¹æ³•](#22-å·¥å‚æ–¹æ³•)
  - [3. Abstract Factory (æŠ½è±¡å·¥å‚)](#3-abstract-factory-æŠ½è±¡å·¥å‚)
  - [4. Singleton (å•ä¾‹æ¨¡å¼)](#4-singleton-å•ä¾‹æ¨¡å¼)
    - [4.1 ä½¿ç”¨ lazy\_static](#41-ä½¿ç”¨-lazy_static)
    - [4.2 ä½¿ç”¨ once\_cell](#42-ä½¿ç”¨-once_cell)
  - [5. Prototype (åŸå‹æ¨¡å¼)](#5-prototype-åŸå‹æ¨¡å¼)
    - [5.1 ä½¿ç”¨ Clone](#51-ä½¿ç”¨-clone)
    - [5.2 æ·±æ‹·è´ vs æµ…æ‹·è´](#52-æ·±æ‹·è´-vs-æµ…æ‹·è´)
  - [6. Object Pool (å¯¹è±¡æ± )](#6-object-pool-å¯¹è±¡æ± )
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 é€‰æ‹©åˆé€‚çš„æ¨¡å¼](#71-é€‰æ‹©åˆé€‚çš„æ¨¡å¼)
    - [7.2 é¿å…è¿‡åº¦è®¾è®¡](#72-é¿å…è¿‡åº¦è®¾è®¡)
    - [7.3 åˆ©ç”¨ Rust ç‰¹æ€§](#73-åˆ©ç”¨-rust-ç‰¹æ€§)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- âœ… æŒæ¡ Builder æ¨¡å¼çš„ Rust æƒ¯ç”¨å®ç°
- âœ… ç†è§£å·¥å‚æ¨¡å¼çš„å¤šç§å˜ä½“
- âœ… å®ç°çº¿ç¨‹å®‰å…¨çš„ Singleton
- âœ… ä½¿ç”¨ Clone trait å®ç°åŸå‹æ¨¡å¼
- âœ… é€‰æ‹©åˆé€‚çš„åˆ›å»ºå‹æ¨¡å¼

---

## 1. Builder (å»ºé€ è€…æ¨¡å¼)

### 1.1 åŸºæœ¬ Builder

```rust
#[derive(Debug)]
struct Server {
    host: String,
    port: u16,
    timeout: u64,
    max_connections: usize,
    tls_enabled: bool,
}

// Builder ç»“æ„ä½“
struct ServerBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    max_connections: Option<usize>,
    tls_enabled: bool,
}

impl ServerBuilder {
    fn new() -> Self {
        ServerBuilder {
            host: None,
            port: None,
            timeout: None,
            max_connections: None,
            tls_enabled: false,
        }
    }
    
    fn host(mut self, host: impl Into<String>) -> Self {
        self.host = Some(host.into());
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn max_connections(mut self, max_connections: usize) -> Self {
        self.max_connections = Some(max_connections);
        self
    }
    
    fn enable_tls(mut self) -> Self {
        self.tls_enabled = true;
        self
    }
    
    fn build(self) -> Result<Server, String> {
        Ok(Server {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
            max_connections: self.max_connections.unwrap_or(100),
            tls_enabled: self.tls_enabled,
        })
    }
}

fn main() {
    let server = ServerBuilder::new()
        .host("localhost")
        .port(9000)
        .enable_tls()
        .build()
        .unwrap();
    
    println!("{:?}", server);
}
```

### 1.2 Derive Builder (ä½¿ç”¨å®)

```rust
// ä½¿ç”¨ derive_builder crate
use derive_builder::Builder;

#[derive(Debug, Builder)]
#[builder(setter(into))]
struct Database {
    host: String,
    port: u16,
    #[builder(default = "String::from(\"admin\")")]
    username: String,
    #[builder(default = "5")]
    pool_size: usize,
    #[builder(default = "false")]
    ssl: bool,
}

fn example_derive_builder() -> Result<(), Box<dyn std::error::Error>> {
    let db = DatabaseBuilder::default()
        .host("localhost")
        .port(5432)
        .pool_size(10)
        .build()?;
    
    println!("{:?}", db);
    Ok(())
}
```

### 1.3 ç±»å‹çŠ¶æ€ Builder

```rust
// ä½¿ç”¨ç±»å‹ç³»ç»Ÿç¡®ä¿æ­£ç¡®æ€§
struct ServerBuilder<Host, Port> {
    host: Host,
    port: Port,
    timeout: u64,
}

struct NoHost;
struct HasHost(String);
struct NoPort;
struct HasPort(u16);

impl ServerBuilder<NoHost, NoPort> {
    fn new() -> Self {
        ServerBuilder {
            host: NoHost,
            port: NoPort,
            timeout: 30,
        }
    }
}

impl<Port> ServerBuilder<NoHost, Port> {
    fn host(self, host: impl Into<String>) -> ServerBuilder<HasHost, Port> {
        ServerBuilder {
            host: HasHost(host.into()),
            port: self.port,
            timeout: self.timeout,
        }
    }
}

impl<Host> ServerBuilder<Host, NoPort> {
    fn port(self, port: u16) -> ServerBuilder<Host, HasPort> {
        ServerBuilder {
            host: self.host,
            port: HasPort(port),
            timeout: self.timeout,
        }
    }
}

impl<Host, Port> ServerBuilder<Host, Port> {
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
}

// åªæœ‰ Host å’Œ Port éƒ½è®¾ç½®åæ‰èƒ½ build
impl ServerBuilder<HasHost, HasPort> {
    fn build(self) -> Server {
        Server {
            host: self.host.0,
            port: self.port.0,
            timeout: self.timeout,
            max_connections: 100,
            tls_enabled: false,
        }
    }
}

fn example_typestate() {
    let server = ServerBuilder::new()
        .host("localhost")  // å¿…é¡»è°ƒç”¨
        .port(8080)  // å¿…é¡»è°ƒç”¨
        .build();
    
    // let server = ServerBuilder::new().build(); // âŒ ç¼–è¯‘é”™è¯¯
}
```

---

## 2. Factory (å·¥å‚æ¨¡å¼)

### 2.1 ç®€å•å·¥å‚

```rust
enum LogLevel {
    Debug,
    Info,
    Warning,
    Error,
}

trait Logger {
    fn log(&self, message: &str);
}

struct ConsoleLogger;
impl Logger for ConsoleLogger {
    fn log(&self, message: &str) {
        println!("[Console] {}", message);
    }
}

struct FileLogger {
    path: String,
}
impl Logger for FileLogger {
    fn log(&self, message: &str) {
        println!("[File: {}] {}", self.path, message);
    }
}

struct SyslogLogger;
impl Logger for SyslogLogger {
    fn log(&self, message: &str) {
        println!("[Syslog] {}", message);
    }
}

// ç®€å•å·¥å‚
struct LoggerFactory;

impl LoggerFactory {
    fn create_logger(logger_type: &str) -> Box<dyn Logger> {
        match logger_type {
            "console" => Box::new(ConsoleLogger),
            "file" => Box::new(FileLogger {
                path: String::from("/var/log/app.log"),
            }),
            "syslog" => Box::new(SyslogLogger),
            _ => Box::new(ConsoleLogger),
        }
    }
}

fn main() {
    let logger = LoggerFactory::create_logger("file");
    logger.log("Application started");
}
```

### 2.2 å·¥å‚æ–¹æ³•

```rust
// ä½¿ç”¨ trait å®šä¹‰å·¥å‚æ¥å£
trait LoggerFactory {
    fn create(&self) -> Box<dyn Logger>;
}

struct ConsoleLoggerFactory;
impl LoggerFactory for ConsoleLoggerFactory {
    fn create(&self) -> Box<dyn Logger> {
        Box::new(ConsoleLogger)
    }
}

struct FileLoggerFactory {
    path: String,
}
impl LoggerFactory for FileLoggerFactory {
    fn create(&self) -> Box<dyn Logger> {
        Box::new(FileLogger {
            path: self.path.clone(),
        })
    }
}

fn process_with_logger(factory: &dyn LoggerFactory) {
    let logger = factory.create();
    logger.log("Processing started");
    // ... ä¸šåŠ¡é€»è¾‘
    logger.log("Processing completed");
}
```

---

## 3. Abstract Factory (æŠ½è±¡å·¥å‚)

```rust
// UI ç»„ä»¶æŠ½è±¡
trait Button {
    fn render(&self) -> String;
}

trait Checkbox {
    fn render(&self) -> String;
}

// Windows é£æ ¼
struct WindowsButton;
impl Button for WindowsButton {
    fn render(&self) -> String {
        String::from("[Windows Button]")
    }
}

struct WindowsCheckbox;
impl Checkbox for WindowsCheckbox {
    fn render(&self) -> String {
        String::from("[Windows Checkbox]")
    }
}

// macOS é£æ ¼
struct MacButton;
impl Button for MacButton {
    fn render(&self) -> String {
        String::from("[Mac Button]")
    }
}

struct MacCheckbox;
impl Checkbox for MacCheckbox {
    fn render(&self) -> String {
        String::from("[Mac Checkbox]")
    }
}

// æŠ½è±¡å·¥å‚
trait UIFactory {
    fn create_button(&self) -> Box<dyn Button>;
    fn create_checkbox(&self) -> Box<dyn Checkbox>;
}

struct WindowsUIFactory;
impl UIFactory for WindowsUIFactory {
    fn create_button(&self) -> Box<dyn Button> {
        Box::new(WindowsButton)
    }
    
    fn create_checkbox(&self) -> Box<dyn Checkbox> {
        Box::new(WindowsCheckbox)
    }
}

struct MacUIFactory;
impl UIFactory for MacUIFactory {
    fn create_button(&self) -> Box<dyn Button> {
        Box::new(MacButton)
    }
    
    fn create_checkbox(&self) -> Box<dyn Checkbox> {
        Box::new(MacCheckbox)
    }
}

fn render_ui(factory: &dyn UIFactory) {
    let button = factory.create_button();
    let checkbox = factory.create_checkbox();
    
    println!("{}", button.render());
    println!("{}", checkbox.render());
}

fn main() {
    let factory: Box<dyn UIFactory> = if cfg!(target_os = "windows") {
        Box::new(WindowsUIFactory)
    } else {
        Box::new(MacUIFactory)
    };
    
    render_ui(factory.as_ref());
}
```

---

## 4. Singleton (å•ä¾‹æ¨¡å¼)

### 4.1 ä½¿ç”¨ lazy_static

```rust
use lazy_static::lazy_static;
use std::sync::Mutex;

struct Config {
    api_key: String,
    max_retries: usize,
}

lazy_static! {
    static ref CONFIG: Mutex<Config> = Mutex::new(Config {
        api_key: String::from("default-key"),
        max_retries: 3,
    });
}

fn get_config() -> &'static Mutex<Config> {
    &CONFIG
}

fn main() {
    // è¯»å–é…ç½®
    {
        let config = CONFIG.lock().unwrap();
        println!("API Key: {}", config.api_key);
    }
    
    // ä¿®æ”¹é…ç½®
    {
        let mut config = CONFIG.lock().unwrap();
        config.api_key = String::from("new-key");
    }
}
```

### 4.2 ä½¿ç”¨ once_cell

```rust
use once_cell::sync::OnceCell;
use std::sync::Mutex;

struct DatabaseConnection {
    url: String,
}

impl DatabaseConnection {
    fn new(url: String) -> Self {
        DatabaseConnection { url }
    }
    
    fn query(&self, sql: &str) {
        println!("Querying '{}' on {}", sql, self.url);
    }
}

static DB: OnceCell<Mutex<DatabaseConnection>> = OnceCell::new();

fn get_db() -> &'static Mutex<DatabaseConnection> {
    DB.get_or_init(|| {
        Mutex::new(DatabaseConnection::new(
            String::from("postgres://localhost:5432"),
        ))
    })
}

fn main() {
    let db = get_db();
    let conn = db.lock().unwrap();
    conn.query("SELECT * FROM users");
}
```

---

## 5. Prototype (åŸå‹æ¨¡å¼)

### 5.1 ä½¿ç”¨ Clone

```rust
#[derive(Clone)]
struct Document {
    title: String,
    content: String,
    metadata: Vec<(String, String)>,
}

impl Document {
    fn new(title: String, content: String) -> Self {
        Document {
            title,
            content,
            metadata: Vec::new(),
        }
    }
    
    fn add_metadata(&mut self, key: String, value: String) {
        self.metadata.push((key, value));
    }
}

fn main() {
    // åˆ›å»ºåŸå‹
    let mut template = Document::new(
        String::from("Template"),
        String::from("Default content"),
    );
    template.add_metadata(String::from("author"), String::from("System"));
    
    // å…‹éš†åŸå‹
    let mut doc1 = template.clone();
    doc1.title = String::from("Document 1");
    
    let mut doc2 = template.clone();
    doc2.title = String::from("Document 2");
}
```

### 5.2 æ·±æ‹·è´ vs æµ…æ‹·è´

```rust
use std::rc::Rc;

#[derive(Clone)]
struct Config {
    name: String,
    shared_data: Rc<Vec<u8>>,  // æµ…æ‹·è´
}

impl Config {
    fn deep_clone(&self) -> Self {
        Config {
            name: self.name.clone(),
            shared_data: Rc::new((*self.shared_data).clone()),  // æ·±æ‹·è´
        }
    }
}

fn main() {
    let config1 = Config {
        name: String::from("Config1"),
        shared_data: Rc::new(vec![1, 2, 3]),
    };
    
    // æµ…æ‹·è´ï¼šå…±äº« shared_data
    let config2 = config1.clone();
    println!("Rc count: {}", Rc::strong_count(&config1.shared_data)); // 2
    
    // æ·±æ‹·è´ï¼šç‹¬ç«‹çš„ shared_data
    let config3 = config1.deep_clone();
    println!("Rc count: {}", Rc::strong_count(&config3.shared_data)); // 1
}
```

---

## 6. Object Pool (å¯¹è±¡æ± )

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};

struct Connection {
    id: usize,
}

impl Connection {
    fn execute(&self, query: &str) {
        println!("Connection {}: {}", self.id, query);
    }
}

struct ConnectionPool {
    available: Arc<Mutex<VecDeque<Connection>>>,
    size: usize,
}

impl ConnectionPool {
    fn new(size: usize) -> Self {
        let mut pool = VecDeque::new();
        for id in 0..size {
            pool.push_back(Connection { id });
        }
        
        ConnectionPool {
            available: Arc::new(Mutex::new(pool)),
            size,
        }
    }
    
    fn acquire(&self) -> Option<PooledConnection> {
        let mut pool = self.available.lock().unwrap();
        pool.pop_front().map(|conn| PooledConnection {
            conn: Some(conn),
            pool: self.available.clone(),
        })
    }
}

struct PooledConnection {
    conn: Option<Connection>,
    pool: Arc<Mutex<VecDeque<Connection>>>,
}

impl PooledConnection {
    fn execute(&self, query: &str) {
        if let Some(ref conn) = self.conn {
            conn.execute(query);
        }
    }
}

impl Drop for PooledConnection {
    fn drop(&mut self) {
        if let Some(conn) = self.conn.take() {
            self.pool.lock().unwrap().push_back(conn);
        }
    }
}

fn main() {
    let pool = ConnectionPool::new(3);
    
    {
        let conn1 = pool.acquire().unwrap();
        conn1.execute("SELECT 1");
        
        let conn2 = pool.acquire().unwrap();
        conn2.execute("SELECT 2");
    } // conn1 å’Œ conn2 å½’è¿˜åˆ°æ± ä¸­
    
    let conn3 = pool.acquire().unwrap();
    conn3.execute("SELECT 3");
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 é€‰æ‹©åˆé€‚çš„æ¨¡å¼

```rust
// âœ… Builder: å¤šä¸ªå¯é€‰å‚æ•°
let server = ServerBuilder::new()
    .host("localhost")
    .port(8080)
    .timeout(60)
    .build()?;

// âœ… Factory: è¿è¡Œæ—¶å†³å®šç±»å‹
let logger = LoggerFactory::create_logger(&config.logger_type);

// âœ… Singleton: å…¨å±€å”¯ä¸€å®ä¾‹
let db = get_db();

// âœ… Prototype: éœ€è¦å…‹éš†å¯¹è±¡
let new_doc = template.clone();

// âœ… Object Pool: æ˜‚è´µå¯¹è±¡å¤ç”¨
let conn = pool.acquire();
```

### 7.2 é¿å…è¿‡åº¦è®¾è®¡

```rust
// âŒ ä¸å¿…è¦çš„å·¥å‚
struct SimpleConfig {
    value: i32,
}

trait ConfigFactory {
    fn create() -> SimpleConfig;
}
// è¿‡äºå¤æ‚ï¼

// âœ… ç›´æ¥æ„é€ 
let config = SimpleConfig { value: 42 };
```

### 7.3 åˆ©ç”¨ Rust ç‰¹æ€§

```rust
// âœ… ä½¿ç”¨ trait å®ç°å¤šæ€
trait Shape {
    fn draw(&self);
}

// âœ… ä½¿ç”¨ enum æ›¿ä»£å¤šä¸ªå­ç±»
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius } => std::f64::consts::PI * radius * radius,
            Shape::Rectangle { width, height } => width * height,
        }
    }
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

**å†…éƒ¨æ–‡æ¡£**:

- [ç»“æ„å‹æ¨¡å¼æŒ‡å—](./02_ç»“æ„å‹æ¨¡å¼æŒ‡å—.md) - ä¸‹ä¸€æ­¥
- [è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—](./03_è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—.md) - è¿›é˜¶
- [è¯¦ç»†æ¨¡å¼](../patterns/) - å®Œæ•´å‚è€ƒ

**å¤–éƒ¨èµ„æº**:

- ğŸ¦€ [Rust Design Patterns Book](https://rust-unofficial.github.io/patterns/)
- ğŸ“˜ [Design Patterns (GoF)](https://en.wikipedia.org/wiki/Design_Patterns)
- ğŸŒ [Refactoring.Guru](https://refactoring.guru/design-patterns)

**ç›¸å…³ Crate**:

- `derive_builder` - Builder æ¨¡å¼å®
- `lazy_static` / `once_cell` - å»¶è¿Ÿåˆå§‹åŒ–
- `r2d2` - é€šç”¨å¯¹è±¡æ± 

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [ç»“æ„å‹æ¨¡å¼æŒ‡å—](./02_ç»“æ„å‹æ¨¡å¼æŒ‡å—.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
