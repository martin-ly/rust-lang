# 03 行为型模式指南

> **文档类型**: Tier 2 - 实践指南  
> **目标读者**: 需要掌握对象交互模式的开发者  
> **预计学习时间**: 3-4小时  
> **前置知识**: [结构型模式指南](./02_结构型模式指南.md)

**最后更新**: 2025-10-23  
**适用版本**: Rust 1.90+

---

## 📋 目录

- [03 行为型模式指南](#03-行为型模式指南)
  - [📊 目录](#-目录)
  - [1. Strategy (策略模式)](#1-strategy-策略模式)
  - [2. Observer (观察者模式)](#2-observer-观察者模式)
  - [3. Command (命令模式)](#3-command-命令模式)
  - [4. Iterator (迭代器模式)](#4-iterator-迭代器模式)
  - [5. State (状态模式)](#5-state-状态模式)
  - [6. Visitor (访问者模式)](#6-visitor-访问者模式)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 使用 Enum 替代状态对象](#71-使用-enum-替代状态对象)
    - [7.2 使用闭包简化策略模式](#72-使用闭包简化策略模式)

---

## 1. Strategy (策略模式)

定义算法族，可互换使用：

```rust
trait SortStrategy {
    fn sort(&self, data: &mut [i32]);
}

struct BubbleSort;
impl SortStrategy for BubbleSort {
    fn sort(&self, data: &mut [i32]) {
        let len = data.len();
        for i in 0..len {
            for j in 0..len - 1 - i {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
}

struct QuickSort;
impl SortStrategy for QuickSort {
    fn sort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        let pivot = partition(data);
        let (left, right) = data.split_at_mut(pivot);
        self.sort(left);
        self.sort(&mut right[1..]);
    }
}

fn partition(data: &mut [i32]) -> usize {
    let len = data.len();
    let pivot = len - 1;
    let mut i = 0;
    
    for j in 0..len - 1 {
        if data[j] <= data[pivot] {
            data.swap(i, j);
            i += 1;
        }
    }
    
    data.swap(i, pivot);
    i
}

struct Sorter {
    strategy: Box<dyn SortStrategy>,
}

impl Sorter {
    fn new(strategy: Box<dyn SortStrategy>) -> Self {
        Sorter { strategy }
    }
    
    fn sort(&self, data: &mut [i32]) {
        self.strategy.sort(data);
    }
}

fn main() {
    let mut data = vec![5, 2, 8, 1, 9];
    
    let sorter = Sorter::new(Box::new(QuickSort));
    sorter.sort(&mut data);
    
    println!("{:?}", data);
}
```

**Rust 惯用：闭包作为策略**:

```rust
fn process_data<F>(data: &[i32], strategy: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    data.iter().fold(0, |acc, &x| strategy(acc, x))
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    let sum = process_data(&data, |acc, x| acc + x);
    let product = process_data(&data, |acc, x| acc * x);
    
    println!("Sum: {}, Product: {}", sum, product);
}
```

---

## 2. Observer (观察者模式)

发布-订阅机制：

```rust
trait Observer {
    fn update(&self, message: &str);
}

struct ConcreteObserver {
    name: String,
}

impl Observer for ConcreteObserver {
    fn update(&self, message: &str) {
        println!("{} received: {}", self.name, message);
    }
}

struct Subject {
    observers: Vec<Box<dyn Observer>>,
}

impl Subject {
    fn new() -> Self {
        Subject {
            observers: Vec::new(),
        }
    }
    
    fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn notify(&self, message: &str) {
        for observer in &self.observers {
            observer.update(message);
        }
    }
}

fn main() {
    let mut subject = Subject::new();
    
    subject.attach(Box::new(ConcreteObserver {
        name: String::from("Observer1"),
    }));
    subject.attach(Box::new(ConcreteObserver {
        name: String::from("Observer2"),
    }));
    
    subject.notify("Event occurred!");
}
```

---

## 3. Command (命令模式)

将请求封装为对象：

```rust
trait Command {
    fn execute(&mut self);
    fn undo(&mut self);
}

struct Light {
    on: bool,
}

impl Light {
    fn turn_on(&mut self) {
        self.on = true;
        println!("Light is ON");
    }
    
    fn turn_off(&mut self) {
        self.on = false;
        println!("Light is OFF");
    }
}

struct LightOnCommand {
    light: Light,
}

impl Command for LightOnCommand {
    fn execute(&mut self) {
        self.light.turn_on();
    }
    
    fn undo(&mut self) {
        self.light.turn_off();
    }
}

struct RemoteControl {
    history: Vec<Box<dyn Command>>,
}

impl RemoteControl {
    fn new() -> Self {
        RemoteControl {
            history: Vec::new(),
        }
    }
    
    fn execute(&mut self, mut command: Box<dyn Command>) {
        command.execute();
        self.history.push(command);
    }
    
    fn undo(&mut self) {
        if let Some(mut command) = self.history.pop() {
            command.undo();
        }
    }
}

fn main() {
    let mut remote = RemoteControl::new();
    
    let light_on = Box::new(LightOnCommand {
        light: Light { on: false },
    });
    
    remote.execute(light_on);
    remote.undo();
}
```

---

## 4. Iterator (迭代器模式)

顺序访问集合元素：

```rust
struct Range {
    current: i32,
    end: i32,
}

impl Range {
    fn new(start: i32, end: i32) -> Self {
        Range {
            current: start,
            end,
        }
    }
}

impl Iterator for Range {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.end {
            let current = self.current;
            self.current += 1;
            Some(current)
        } else {
            None
        }
    }
}

// 自定义集合迭代器
struct MyCollection {
    data: Vec<i32>,
}

impl MyCollection {
    fn iter(&self) -> impl Iterator<Item = &i32> {
        self.data.iter()
    }
    
    fn iter_mut(&mut self) -> impl Iterator<Item = &mut i32> {
        self.data.iter_mut()
    }
}

fn main() {
    let range = Range::new(1, 5);
    
    for num in range {
        println!("{}", num);
    }
    
    let collection = MyCollection {
        data: vec![1, 2, 3, 4, 5],
    };
    
    for &item in collection.iter() {
        println!("{}", item);
    }
}
```

---

## 5. State (状态模式)

状态改变对象行为：

```rust
trait State {
    fn handle(self: Box<Self>) -> Box<dyn State>;
    fn status(&self) -> &str;
}

struct OffState;
impl State for OffState {
    fn handle(self: Box<Self>) -> Box<dyn State> {
        println!("Turning ON");
        Box::new(OnState)
    }
    
    fn status(&self) -> &str {
        "OFF"
    }
}

struct OnState;
impl State for OnState {
    fn handle(self: Box<Self>) -> Box<dyn State> {
        println!("Turning OFF");
        Box::new(OffState)
    }
    
    fn status(&self) -> &str {
        "ON"
    }
}

struct Context {
    state: Box<dyn State>,
}

impl Context {
    fn new() -> Self {
        Context {
            state: Box::new(OffState),
        }
    }
    
    fn request(&mut self) {
        let state = std::mem::replace(&mut self.state, Box::new(OffState));
        self.state = state.handle();
    }
    
    fn status(&self) -> &str {
        self.state.status()
    }
}

fn main() {
    let mut context = Context::new();
    
    println!("Status: {}", context.status());
    context.request();
    println!("Status: {}", context.status());
    context.request();
    println!("Status: {}", context.status());
}
```

**类型状态模式（Rust惯用）**:

```rust
struct Locked;
struct Unlocked;

struct Door<State> {
    state: State,
}

impl Door<Locked> {
    fn new() -> Self {
        Door { state: Locked }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Unlocking door");
        Door { state: Unlocked }
    }
}

impl Door<Unlocked> {
    fn lock(self) -> Door<Locked> {
        println!("Locking door");
        Door { state: Locked }
    }
    
    fn open(&self) {
        println!("Opening door");
    }
}

fn main() {
    let door = Door::new();
    // door.open(); // ❌ 编译错误：锁定状态不能打开
    
    let door = door.unlock();
    door.open(); // ✅ 可以打开
}
```

---

## 6. Visitor (访问者模式)

在不修改类的前提下增加新操作：

```rust
trait Shape {
    fn accept(&self, visitor: &dyn Visitor);
}

trait Visitor {
    fn visit_circle(&self, circle: &Circle);
    fn visit_rectangle(&self, rectangle: &Rectangle);
}

struct Circle {
    radius: f64,
}

impl Shape for Circle {
    fn accept(&self, visitor: &dyn Visitor) {
        visitor.visit_circle(self);
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Rectangle {
    fn accept(&self, visitor: &dyn Visitor) {
        visitor.visit_rectangle(self);
    }
}

struct AreaCalculator;

impl Visitor for AreaCalculator {
    fn visit_circle(&self, circle: &Circle) {
        let area = std::f64::consts::PI * circle.radius * circle.radius;
        println!("Circle area: {:.2}", area);
    }
    
    fn visit_rectangle(&self, rectangle: &Rectangle) {
        let area = rectangle.width * rectangle.height;
        println!("Rectangle area: {:.2}", area);
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    let calculator = AreaCalculator;
    
    for shape in &shapes {
        shape.accept(&calculator);
    }
}
```

---

## 7. 最佳实践

### 7.1 使用 Enum 替代状态对象

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

impl TrafficLight {
    fn next(self) -> Self {
        match self {
            TrafficLight::Red => TrafficLight::Green,
            TrafficLight::Yellow => TrafficLight::Red,
            TrafficLight::Green => TrafficLight::Yellow,
        }
    }
    
    fn duration(&self) -> u32 {
        match self {
            TrafficLight::Red => 30,
            TrafficLight::Yellow => 5,
            TrafficLight::Green => 25,
        }
    }
}
```

### 7.2 使用闭包简化策略模式

```rust
fn apply_discount<F>(price: f64, strategy: F) -> f64
where
    F: Fn(f64) -> f64,
{
    strategy(price)
}

fn main() {
    let price = 100.0;
    
    let discounted = apply_discount(price, |p| p * 0.9);
    println!("Price: {}", discounted);
}
```

---

**返回**: [Tier 2 索引](./README.md) | **下一步**: [并发模式指南](./04_并发模式指南.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-23  
**文档状态**: ✅ 完成
