# 03 è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—  
> **ç›®æ ‡è¯»è€…**: éœ€è¦æŒæ¡å¯¹è±¡äº¤äº’æ¨¡å¼çš„å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: [ç»“æ„å‹æ¨¡å¼æŒ‡å—](./02_ç»“æ„å‹æ¨¡å¼æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+

---

## ğŸ“‹ ç›®å½•

- [03 è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—](#03-è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Strategy (ç­–ç•¥æ¨¡å¼)](#1-strategy-ç­–ç•¥æ¨¡å¼)
  - [2. Observer (è§‚å¯Ÿè€…æ¨¡å¼)](#2-observer-è§‚å¯Ÿè€…æ¨¡å¼)
  - [3. Command (å‘½ä»¤æ¨¡å¼)](#3-command-å‘½ä»¤æ¨¡å¼)
  - [4. Iterator (è¿­ä»£å™¨æ¨¡å¼)](#4-iterator-è¿­ä»£å™¨æ¨¡å¼)
  - [5. State (çŠ¶æ€æ¨¡å¼)](#5-state-çŠ¶æ€æ¨¡å¼)
  - [6. Visitor (è®¿é—®è€…æ¨¡å¼)](#6-visitor-è®¿é—®è€…æ¨¡å¼)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 ä½¿ç”¨ Enum æ›¿ä»£çŠ¶æ€å¯¹è±¡](#71-ä½¿ç”¨-enum-æ›¿ä»£çŠ¶æ€å¯¹è±¡)
    - [7.2 ä½¿ç”¨é—­åŒ…ç®€åŒ–ç­–ç•¥æ¨¡å¼](#72-ä½¿ç”¨é—­åŒ…ç®€åŒ–ç­–ç•¥æ¨¡å¼)

---

## 1. Strategy (ç­–ç•¥æ¨¡å¼)

å®šä¹‰ç®—æ³•æ—ï¼Œå¯äº’æ¢ä½¿ç”¨ï¼š

```rust
trait SortStrategy {
    fn sort(&self, data: &mut [i32]);
}

struct BubbleSort;
impl SortStrategy for BubbleSort {
    fn sort(&self, data: &mut [i32]) {
        let len = data.len();
        for i in 0..len {
            for j in 0..len - 1 - i {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
}

struct QuickSort;
impl SortStrategy for QuickSort {
    fn sort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        let pivot = partition(data);
        let (left, right) = data.split_at_mut(pivot);
        self.sort(left);
        self.sort(&mut right[1..]);
    }
}

fn partition(data: &mut [i32]) -> usize {
    let len = data.len();
    let pivot = len - 1;
    let mut i = 0;
    
    for j in 0..len - 1 {
        if data[j] <= data[pivot] {
            data.swap(i, j);
            i += 1;
        }
    }
    
    data.swap(i, pivot);
    i
}

struct Sorter {
    strategy: Box<dyn SortStrategy>,
}

impl Sorter {
    fn new(strategy: Box<dyn SortStrategy>) -> Self {
        Sorter { strategy }
    }
    
    fn sort(&self, data: &mut [i32]) {
        self.strategy.sort(data);
    }
}

fn main() {
    let mut data = vec![5, 2, 8, 1, 9];
    
    let sorter = Sorter::new(Box::new(QuickSort));
    sorter.sort(&mut data);
    
    println!("{:?}", data);
}
```

**Rust æƒ¯ç”¨ï¼šé—­åŒ…ä½œä¸ºç­–ç•¥**:

```rust
fn process_data<F>(data: &[i32], strategy: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    data.iter().fold(0, |acc, &x| strategy(acc, x))
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    let sum = process_data(&data, |acc, x| acc + x);
    let product = process_data(&data, |acc, x| acc * x);
    
    println!("Sum: {}, Product: {}", sum, product);
}
```

---

## 2. Observer (è§‚å¯Ÿè€…æ¨¡å¼)

å‘å¸ƒ-è®¢é˜…æœºåˆ¶ï¼š

```rust
trait Observer {
    fn update(&self, message: &str);
}

struct ConcreteObserver {
    name: String,
}

impl Observer for ConcreteObserver {
    fn update(&self, message: &str) {
        println!("{} received: {}", self.name, message);
    }
}

struct Subject {
    observers: Vec<Box<dyn Observer>>,
}

impl Subject {
    fn new() -> Self {
        Subject {
            observers: Vec::new(),
        }
    }
    
    fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn notify(&self, message: &str) {
        for observer in &self.observers {
            observer.update(message);
        }
    }
}

fn main() {
    let mut subject = Subject::new();
    
    subject.attach(Box::new(ConcreteObserver {
        name: String::from("Observer1"),
    }));
    subject.attach(Box::new(ConcreteObserver {
        name: String::from("Observer2"),
    }));
    
    subject.notify("Event occurred!");
}
```

---

## 3. Command (å‘½ä»¤æ¨¡å¼)

å°†è¯·æ±‚å°è£…ä¸ºå¯¹è±¡ï¼š

```rust
trait Command {
    fn execute(&mut self);
    fn undo(&mut self);
}

struct Light {
    on: bool,
}

impl Light {
    fn turn_on(&mut self) {
        self.on = true;
        println!("Light is ON");
    }
    
    fn turn_off(&mut self) {
        self.on = false;
        println!("Light is OFF");
    }
}

struct LightOnCommand {
    light: Light,
}

impl Command for LightOnCommand {
    fn execute(&mut self) {
        self.light.turn_on();
    }
    
    fn undo(&mut self) {
        self.light.turn_off();
    }
}

struct RemoteControl {
    history: Vec<Box<dyn Command>>,
}

impl RemoteControl {
    fn new() -> Self {
        RemoteControl {
            history: Vec::new(),
        }
    }
    
    fn execute(&mut self, mut command: Box<dyn Command>) {
        command.execute();
        self.history.push(command);
    }
    
    fn undo(&mut self) {
        if let Some(mut command) = self.history.pop() {
            command.undo();
        }
    }
}

fn main() {
    let mut remote = RemoteControl::new();
    
    let light_on = Box::new(LightOnCommand {
        light: Light { on: false },
    });
    
    remote.execute(light_on);
    remote.undo();
}
```

---

## 4. Iterator (è¿­ä»£å™¨æ¨¡å¼)

é¡ºåºè®¿é—®é›†åˆå…ƒç´ ï¼š

```rust
struct Range {
    current: i32,
    end: i32,
}

impl Range {
    fn new(start: i32, end: i32) -> Self {
        Range {
            current: start,
            end,
        }
    }
}

impl Iterator for Range {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.end {
            let current = self.current;
            self.current += 1;
            Some(current)
        } else {
            None
        }
    }
}

// è‡ªå®šä¹‰é›†åˆè¿­ä»£å™¨
struct MyCollection {
    data: Vec<i32>,
}

impl MyCollection {
    fn iter(&self) -> impl Iterator<Item = &i32> {
        self.data.iter()
    }
    
    fn iter_mut(&mut self) -> impl Iterator<Item = &mut i32> {
        self.data.iter_mut()
    }
}

fn main() {
    let range = Range::new(1, 5);
    
    for num in range {
        println!("{}", num);
    }
    
    let collection = MyCollection {
        data: vec![1, 2, 3, 4, 5],
    };
    
    for &item in collection.iter() {
        println!("{}", item);
    }
}
```

---

## 5. State (çŠ¶æ€æ¨¡å¼)

çŠ¶æ€æ”¹å˜å¯¹è±¡è¡Œä¸ºï¼š

```rust
trait State {
    fn handle(self: Box<Self>) -> Box<dyn State>;
    fn status(&self) -> &str;
}

struct OffState;
impl State for OffState {
    fn handle(self: Box<Self>) -> Box<dyn State> {
        println!("Turning ON");
        Box::new(OnState)
    }
    
    fn status(&self) -> &str {
        "OFF"
    }
}

struct OnState;
impl State for OnState {
    fn handle(self: Box<Self>) -> Box<dyn State> {
        println!("Turning OFF");
        Box::new(OffState)
    }
    
    fn status(&self) -> &str {
        "ON"
    }
}

struct Context {
    state: Box<dyn State>,
}

impl Context {
    fn new() -> Self {
        Context {
            state: Box::new(OffState),
        }
    }
    
    fn request(&mut self) {
        let state = std::mem::replace(&mut self.state, Box::new(OffState));
        self.state = state.handle();
    }
    
    fn status(&self) -> &str {
        self.state.status()
    }
}

fn main() {
    let mut context = Context::new();
    
    println!("Status: {}", context.status());
    context.request();
    println!("Status: {}", context.status());
    context.request();
    println!("Status: {}", context.status());
}
```

**ç±»å‹çŠ¶æ€æ¨¡å¼ï¼ˆRustæƒ¯ç”¨ï¼‰**:

```rust
struct Locked;
struct Unlocked;

struct Door<State> {
    state: State,
}

impl Door<Locked> {
    fn new() -> Self {
        Door { state: Locked }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Unlocking door");
        Door { state: Unlocked }
    }
}

impl Door<Unlocked> {
    fn lock(self) -> Door<Locked> {
        println!("Locking door");
        Door { state: Locked }
    }
    
    fn open(&self) {
        println!("Opening door");
    }
}

fn main() {
    let door = Door::new();
    // door.open(); // âŒ ç¼–è¯‘é”™è¯¯ï¼šé”å®šçŠ¶æ€ä¸èƒ½æ‰“å¼€
    
    let door = door.unlock();
    door.open(); // âœ… å¯ä»¥æ‰“å¼€
}
```

---

## 6. Visitor (è®¿é—®è€…æ¨¡å¼)

åœ¨ä¸ä¿®æ”¹ç±»çš„å‰æä¸‹å¢åŠ æ–°æ“ä½œï¼š

```rust
trait Shape {
    fn accept(&self, visitor: &dyn Visitor);
}

trait Visitor {
    fn visit_circle(&self, circle: &Circle);
    fn visit_rectangle(&self, rectangle: &Rectangle);
}

struct Circle {
    radius: f64,
}

impl Shape for Circle {
    fn accept(&self, visitor: &dyn Visitor) {
        visitor.visit_circle(self);
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Rectangle {
    fn accept(&self, visitor: &dyn Visitor) {
        visitor.visit_rectangle(self);
    }
}

struct AreaCalculator;

impl Visitor for AreaCalculator {
    fn visit_circle(&self, circle: &Circle) {
        let area = std::f64::consts::PI * circle.radius * circle.radius;
        println!("Circle area: {:.2}", area);
    }
    
    fn visit_rectangle(&self, rectangle: &Rectangle) {
        let area = rectangle.width * rectangle.height;
        println!("Rectangle area: {:.2}", area);
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    let calculator = AreaCalculator;
    
    for shape in &shapes {
        shape.accept(&calculator);
    }
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 ä½¿ç”¨ Enum æ›¿ä»£çŠ¶æ€å¯¹è±¡

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

impl TrafficLight {
    fn next(self) -> Self {
        match self {
            TrafficLight::Red => TrafficLight::Green,
            TrafficLight::Yellow => TrafficLight::Red,
            TrafficLight::Green => TrafficLight::Yellow,
        }
    }
    
    fn duration(&self) -> u32 {
        match self {
            TrafficLight::Red => 30,
            TrafficLight::Yellow => 5,
            TrafficLight::Green => 25,
        }
    }
}
```

### 7.2 ä½¿ç”¨é—­åŒ…ç®€åŒ–ç­–ç•¥æ¨¡å¼

```rust
fn apply_discount<F>(price: f64, strategy: F) -> f64
where
    F: Fn(f64) -> f64,
{
    strategy(price)
}

fn main() {
    let price = 100.0;
    
    let discounted = apply_discount(price, |p| p * 0.9);
    println!("Price: {}", discounted);
}
```

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [å¹¶å‘æ¨¡å¼æŒ‡å—](./04_å¹¶å‘æ¨¡å¼æŒ‡å—.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
