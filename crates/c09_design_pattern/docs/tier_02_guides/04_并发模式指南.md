# C09 Design Pattern - Tier 2: å¹¶å‘æ¨¡å¼æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 45 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C09 Design Pattern - Tier 2: å¹¶å‘æ¨¡å¼æŒ‡å—](#c09-design-pattern---tier-2-å¹¶å‘æ¨¡å¼æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¹¶å‘æ¨¡å¼æ¦‚è¿°](#1-å¹¶å‘æ¨¡å¼æ¦‚è¿°)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘æ¨¡å¼ï¼Ÿ](#11-ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘æ¨¡å¼)
    - [1.2 å¹¶å‘æ¨¡å¼åˆ†ç±»](#12-å¹¶å‘æ¨¡å¼åˆ†ç±»)
  - [2. Actor æ¨¡å¼](#2-actor-æ¨¡å¼)
    - [2.1 æ ¸å¿ƒæ¦‚å¿µ](#21-æ ¸å¿ƒæ¦‚å¿µ)
    - [2.2 åŸºç¡€å®ç°](#22-åŸºç¡€å®ç°)
    - [2.3 é«˜çº§ç‰¹æ€§](#23-é«˜çº§ç‰¹æ€§)
  - [3. Pipeline æ¨¡å¼](#3-pipeline-æ¨¡å¼)
    - [3.1 æ ¸å¿ƒæ¦‚å¿µ](#31-æ ¸å¿ƒæ¦‚å¿µ)
    - [3.2 åŸºç¡€å®ç°](#32-åŸºç¡€å®ç°)
    - [3.3 é€šç”¨ Pipeline æ¡†æ¶](#33-é€šç”¨-pipeline-æ¡†æ¶)
  - [4. Fork-Join æ¨¡å¼](#4-fork-join-æ¨¡å¼)
    - [4.1 æ ¸å¿ƒæ¦‚å¿µ](#41-æ ¸å¿ƒæ¦‚å¿µ)
    - [4.2 ä½¿ç”¨ Rayon å®ç°](#42-ä½¿ç”¨-rayon-å®ç°)
    - [4.3 è‡ªå®šä¹‰ Fork-Join](#43-è‡ªå®šä¹‰-fork-join)
  - [5. ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#5-ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
    - [5.1 æ ¸å¿ƒæ¦‚å¿µ](#51-æ ¸å¿ƒæ¦‚å¿µ)
    - [5.2 åŸºç¡€å®ç°](#52-åŸºç¡€å®ç°)
    - [5.3 å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…](#53-å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…)
  - [6. å…±äº«çŠ¶æ€æ¨¡å¼](#6-å…±äº«çŠ¶æ€æ¨¡å¼)
    - [6.1 ä½¿ç”¨ Arc + Mutex](#61-ä½¿ç”¨-arc--mutex)
    - [6.2 ä½¿ç”¨ RwLock](#62-ä½¿ç”¨-rwlock)
    - [6.3 ä½¿ç”¨åŸå­æ“ä½œ](#63-ä½¿ç”¨åŸå­æ“ä½œ)
  - [7. å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶å‘ä»»åŠ¡è°ƒåº¦å™¨](#7-å®æˆ˜æ¡ˆä¾‹å¹¶å‘ä»»åŠ¡è°ƒåº¦å™¨)
    - [7.1 è®¾è®¡ç›®æ ‡](#71-è®¾è®¡ç›®æ ‡)
    - [7.2 å®Œæ•´å®ç°](#72-å®Œæ•´å®ç°)
  - [8. æ€§èƒ½ä¸æœ€ä½³å®è·µ](#8-æ€§èƒ½ä¸æœ€ä½³å®è·µ)
    - [8.1 æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#81-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
    - [8.2 æœ€ä½³å®è·µ](#82-æœ€ä½³å®è·µ)
    - [8.3 å¸¸è§é™·é˜±](#83-å¸¸è§é™·é˜±)
  - [9. æ€»ç»“](#9-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [é€‰æ‹©æŒ‡å—](#é€‰æ‹©æŒ‡å—)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. å¹¶å‘æ¨¡å¼æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘æ¨¡å¼ï¼Ÿ

åœ¨ç°ä»£è½¯ä»¶å¼€å‘ä¸­ï¼Œå¹¶å‘æ˜¯æå‡æ€§èƒ½å’Œå“åº”èƒ½åŠ›çš„å…³é”®æŠ€æœ¯ã€‚
Rust çš„æ‰€æœ‰æƒç³»ç»Ÿä¸ºå®‰å…¨å¹¶å‘æä¾›äº†ç‹¬ç‰¹ä¿éšœã€‚

**æ ¸å¿ƒæŒ‘æˆ˜**ï¼š

- **æ•°æ®ç«äº‰**ï¼šå¤šçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«æ•°æ®
- **æ­»é”**ï¼šçº¿ç¨‹ç›¸äº’ç­‰å¾…å¯¹æ–¹é‡Šæ”¾èµ„æº
- **ä»»åŠ¡åè°ƒ**ï¼šå¦‚ä½•æœ‰æ•ˆåœ°åˆ†é…å’ŒåŒæ­¥ä»»åŠ¡
- **çŠ¶æ€ç®¡ç†**ï¼šå¹¶å‘ç¯å¢ƒä¸‹çš„çŠ¶æ€ä¸€è‡´æ€§

**Rust çš„è§£å†³æ–¹æ¡ˆ**ï¼š

```rust
// âœ… Rust çš„æ‰€æœ‰æƒç³»ç»Ÿåœ¨ç¼–è¯‘æœŸé˜²æ­¢æ•°æ®ç«äº‰
use std::sync::{Arc, Mutex};
use std::thread;

fn safe_concurrency() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut d = data.lock().unwrap();
            d.push(i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆæ•°æ®: {:?}", data.lock().unwrap());
}
```

### 1.2 å¹¶å‘æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ç±»å‹ | ä»£è¡¨æ¨¡å¼ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|
| **æ¶ˆæ¯ä¼ é€’** | Actorã€Pipeline | ä»»åŠ¡è§£è€¦ã€æ•°æ®æµå¤„ç† |
| **ä»»åŠ¡åˆ†è§£** | Fork-Joinã€MapReduce | CPU å¯†é›†å‹è®¡ç®— |
| **èµ„æºå…±äº«** | è¯»å†™é”ã€åŸå­æ“ä½œ | å…±äº«çŠ¶æ€ç®¡ç† |
| **åè°ƒåŒæ­¥** | Barrierã€Semaphore | çº¿ç¨‹åŒæ­¥ã€èµ„æºé™åˆ¶ |

---

## 2. Actor æ¨¡å¼

### 2.1 æ ¸å¿ƒæ¦‚å¿µ

Actor æ¨¡å¼é€šè¿‡æ¶ˆæ¯ä¼ é€’å®ç°å¹¶å‘ï¼Œæ¯ä¸ª Actor ç‹¬ç«‹å¤„ç†æ¶ˆæ¯ï¼Œé¿å…å…±äº«çŠ¶æ€ã€‚

**ç‰¹ç‚¹**ï¼š

- **å°è£…æ€§**ï¼šæ¯ä¸ª Actor æ‹¥æœ‰ç‹¬ç«‹çŠ¶æ€
- **æ¶ˆæ¯ä¼ é€’**ï¼šé€šè¿‡å¼‚æ­¥æ¶ˆæ¯é€šä¿¡
- **å®¹é”™æ€§**ï¼šActor å¤±è´¥ä¸å½±å“å…¶ä»– Actor

### 2.2 åŸºç¡€å®ç°

```rust
use tokio::sync::mpsc;
use tokio::task;

// å®šä¹‰ Actor æ¶ˆæ¯
enum ActorMessage {
    Increment(i32),
    GetValue(mpsc::Sender<i32>),
    Shutdown,
}

// å®šä¹‰ Actor ç»“æ„
struct CounterActor {
    receiver: mpsc::Receiver<ActorMessage>,
    value: i32,
}

impl CounterActor {
    fn new(receiver: mpsc::Receiver<ActorMessage>) -> Self {
        Self { receiver, value: 0 }
    }

    // Actor æ¶ˆæ¯å¾ªç¯
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                ActorMessage::Increment(amount) => {
                    self.value += amount;
                    println!("è®¡æ•°å™¨å¢åŠ  {}, å½“å‰å€¼: {}", amount, self.value);
                }
                ActorMessage::GetValue(sender) => {
                    let _ = sender.send(self.value).await;
                }
                ActorMessage::Shutdown => {
                    println!("Actor å…³é—­");
                    break;
                }
            }
        }
    }
}

// Actor å¥æŸ„
#[derive(Clone)]
struct CounterHandle {
    sender: mpsc::Sender<ActorMessage>,
}

impl CounterHandle {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel(32);
        let actor = CounterActor::new(receiver);
        task::spawn(actor.run());
        Self { sender }
    }

    async fn increment(&self, amount: i32) {
        let _ = self.sender.send(ActorMessage::Increment(amount)).await;
    }

    async fn get_value(&self) -> i32 {
        let (tx, mut rx) = mpsc::channel(1);
        let _ = self.sender.send(ActorMessage::GetValue(tx)).await;
        rx.recv().await.unwrap_or(0)
    }

    async fn shutdown(&self) {
        let _ = self.sender.send(ActorMessage::Shutdown).await;
    }
}

#[tokio::main]
async fn main() {
    let counter = CounterHandle::new();

    // å¹¶å‘å‘é€æ¶ˆæ¯
    let c1 = counter.clone();
    let h1 = task::spawn(async move {
        c1.increment(10).await;
    });

    let c2 = counter.clone();
    let h2 = task::spawn(async move {
        c2.increment(20).await;
    });

    h1.await.unwrap();
    h2.await.unwrap();

    let value = counter.get_value().await;
    println!("æœ€ç»ˆå€¼: {}", value);

    counter.shutdown().await;
}
```

### 2.3 é«˜çº§ç‰¹æ€§

**é”™è¯¯å¤„ç†**ï¼š

```rust
enum ActorMessage {
    ProcessData(String, mpsc::Sender<Result<String, String>>),
}

async fn process_with_error_handling(mut self) {
    while let Some(msg) = self.receiver.recv().await {
        match msg {
            ActorMessage::ProcessData(data, reply) => {
                let result = if data.is_empty() {
                    Err("æ•°æ®ä¸ºç©º".to_string())
                } else {
                    Ok(format!("å¤„ç†æˆåŠŸ: {}", data))
                };
                let _ = reply.send(result).await;
            }
        }
    }
}
```

**Actor ç›‘ç£**ï¼š

```rust
struct Supervisor {
    children: Vec<CounterHandle>,
}

impl Supervisor {
    async fn restart_failed_actor(&mut self, index: usize) {
        println!("é‡å¯ Actor {}", index);
        self.children[index] = CounterHandle::new();
    }
}
```

---

## 3. Pipeline æ¨¡å¼

### 3.1 æ ¸å¿ƒæ¦‚å¿µ

Pipeline æ¨¡å¼å°†æ•°æ®å¤„ç†åˆ†ä¸ºå¤šä¸ªé˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µå¹¶å‘æ‰§è¡Œã€‚

**ä¼˜åŠ¿**ï¼š

- **å¹¶è¡Œå¤„ç†**ï¼šå¤šé˜¶æ®µåŒæ—¶è¿è¡Œ
- **è§£è€¦**ï¼šå„é˜¶æ®µç‹¬ç«‹å®ç°
- **æµå¼å¤„ç†**ï¼šé€‚åˆå¤§æ•°æ®é‡

### 3.2 åŸºç¡€å®ç°

```rust
use tokio::sync::mpsc;
use tokio::task;

async fn pipeline_example() {
    // é˜¶æ®µ 1: æ•°æ®ç”Ÿæˆ
    let (tx1, mut rx1) = mpsc::channel::<i32>(10);
    task::spawn(async move {
        for i in 1..=5 {
            tx1.send(i).await.unwrap();
            println!("ç”Ÿæˆ: {}", i);
        }
    });

    // é˜¶æ®µ 2: æ•°æ®å¤„ç†
    let (tx2, mut rx2) = mpsc::channel::<i32>(10);
    task::spawn(async move {
        while let Some(val) = rx1.recv().await {
            let processed = val * 2;
            println!("å¤„ç†: {} -> {}", val, processed);
            tx2.send(processed).await.unwrap();
        }
    });

    // é˜¶æ®µ 3: æ•°æ®æ¶ˆè´¹
    task::spawn(async move {
        while let Some(val) = rx2.recv().await {
            println!("æ¶ˆè´¹: {}", val);
        }
    });

    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}

#[tokio::main]
async fn main() {
    pipeline_example().await;
}
```

### 3.3 é€šç”¨ Pipeline æ¡†æ¶

```rust
use std::marker::PhantomData;

struct Pipeline<T> {
    sender: mpsc::Sender<T>,
    _phantom: PhantomData<T>,
}

impl<T: Send + 'static> Pipeline<T> {
    fn new<F>(capacity: usize, processor: F) -> (Self, mpsc::Receiver<T>)
    where
        F: Fn(T) -> T + Send + 'static,
    {
        let (tx, rx) = mpsc::channel(capacity);
        (
            Self {
                sender: tx,
                _phantom: PhantomData,
            },
            rx,
        )
    }

    async fn send(&self, item: T) -> Result<(), mpsc::error::SendError<T>> {
        self.sender.send(item).await
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn advanced_pipeline() {
    let (stage1, mut rx1) = Pipeline::new(10, |x: i32| x * 2);
    let (stage2, mut rx2) = Pipeline::new(10, |x: i32| x + 10);

    // å¯åŠ¨å¤„ç†ä»»åŠ¡
    task::spawn(async move {
        while let Some(val) = rx1.recv().await {
            let processed = val * 2; // å¤„ç†é€»è¾‘
            stage2.send(processed).await.unwrap();
        }
    });

    task::spawn(async move {
        while let Some(val) = rx2.recv().await {
            println!("æœ€ç»ˆç»“æœ: {}", val);
        }
    });

    // å‘é€æ•°æ®
    for i in 1..=5 {
        stage1.send(i).await.unwrap();
    }

    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

---

## 4. Fork-Join æ¨¡å¼

### 4.1 æ ¸å¿ƒæ¦‚å¿µ

Fork-Join å°†å¤§ä»»åŠ¡åˆ†è§£ä¸ºå°ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œï¼Œæœ€ååˆå¹¶ç»“æœã€‚

**é€‚ç”¨åœºæ™¯**ï¼š

- æ•°æ®å¹¶è¡Œå¤„ç†
- åˆ†æ²»ç®—æ³•
- MapReduce æ“ä½œ

### 4.2 ä½¿ç”¨ Rayon å®ç°

```rust
use rayon::prelude::*;

// å¹¶è¡Œæ±‚å’Œ
fn parallel_sum(data: &[i32]) -> i32 {
    data.par_iter().sum()
}

// å¹¶è¡Œæ˜ å°„
fn parallel_map(data: &[i32]) -> Vec<i32> {
    data.par_iter().map(|&x| x * 2).collect()
}

// å¹¶è¡Œè¿‡æ»¤
fn parallel_filter(data: &[i32]) -> Vec<i32> {
    data.par_iter()
        .filter(|&&x| x % 2 == 0)
        .copied()
        .collect()
}

fn main() {
    let data: Vec<i32> = (1..=1000).collect();

    let sum = parallel_sum(&data);
    println!("å¹¶è¡Œæ±‚å’Œ: {}", sum);

    let doubled = parallel_map(&data);
    println!("å¹¶è¡Œæ˜ å°„å‰ 5 é¡¹: {:?}", &doubled[..5]);

    let evens = parallel_filter(&data);
    println!("å¹¶è¡Œè¿‡æ»¤ç»“æœæ•°é‡: {}", evens.len());
}
```

### 4.3 è‡ªå®šä¹‰ Fork-Join

```rust
use std::thread;

fn fork_join<T, F>(data: Vec<T>, threshold: usize, f: F) -> Vec<T>
where
    T: Send + 'static,
    F: Fn(Vec<T>) -> Vec<T> + Send + Sync + 'static + Clone,
{
    if data.len() <= threshold {
        return f(data);
    }

    let mid = data.len() / 2;
    let (left, right) = data.split_at(mid);
    let left = left.to_vec();
    let right = right.to_vec();

    let f_clone = f.clone();
    let handle = thread::spawn(move || fork_join(left, threshold, f_clone));

    let right_result = fork_join(right, threshold, f);
    let left_result = handle.join().unwrap();

    [left_result, right_result].concat()
}

fn main() {
    let data: Vec<i32> = (1..=100).collect();
    let result = fork_join(data, 25, |mut vec| {
        vec.iter_mut().for_each(|x| *x *= 2);
        vec
    });
    println!("å‰ 10 é¡¹: {:?}", &result[..10]);
}
```

---

## 5. ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

### 5.1 æ ¸å¿ƒæ¦‚å¿µ

ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼é€šè¿‡é˜Ÿåˆ—è§£è€¦ç”Ÿäº§å’Œæ¶ˆè´¹è¿‡ç¨‹ã€‚

**ä¼˜åŠ¿**ï¼š

- **ç¼“å†²**ï¼šå¹³è¡¡ç”Ÿäº§å’Œæ¶ˆè´¹é€Ÿåº¦
- **è§£è€¦**ï¼šç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ç‹¬ç«‹
- **æ‰©å±•æ€§**ï¼šæ˜“äºæ·»åŠ å¤šä¸ªç”Ÿäº§è€…/æ¶ˆè´¹è€…

### 5.2 åŸºç¡€å®ç°

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn producer_consumer_example() {
    let (tx, rx) = mpsc::channel();

    // ç”Ÿäº§è€…
    let producer = thread::spawn(move || {
        for i in 1..=5 {
            println!("ç”Ÿäº§: {}", i);
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    // æ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        while let Ok(item) = rx.recv() {
            println!("æ¶ˆè´¹: {}", item);
            thread::sleep(Duration::from_millis(200));
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}

fn main() {
    producer_consumer_example();
}
```

### 5.3 å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…

```rust
use crossbeam::channel;
use std::thread;

fn multi_producer_consumer() {
    let (tx, rx) = channel::unbounded();

    // 3 ä¸ªç”Ÿäº§è€…
    let mut producers = vec![];
    for id in 0..3 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            for i in 0..5 {
                let item = format!("P{}-Item{}", id, i);
                tx.send(item).unwrap();
            }
        });
        producers.push(handle);
    }
    drop(tx); // å…³é—­å‘é€ç«¯

    // 2 ä¸ªæ¶ˆè´¹è€…
    let mut consumers = vec![];
    for id in 0..2 {
        let rx = rx.clone();
        let handle = thread::spawn(move || {
            while let Ok(item) = rx.recv() {
                println!("C{} æ¶ˆè´¹: {}", id, item);
            }
        });
        consumers.push(handle);
    }

    for h in producers {
        h.join().unwrap();
    }
    for h in consumers {
        h.join().unwrap();
    }
}

fn main() {
    multi_producer_consumer();
}
```

---

## 6. å…±äº«çŠ¶æ€æ¨¡å¼

### 6.1 ä½¿ç”¨ Arc + Mutex

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn shared_state_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().unwrap());
}
```

### 6.2 ä½¿ç”¨ RwLock

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // å¤šä¸ªè¯»è€…
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let d = data.read().unwrap();
            println!("è¯»è€… {} è¯»å–: {:?}", i, *d);
        });
        handles.push(handle);
    }

    // ä¸€ä¸ªå†™è€…
    let data_clone = Arc::clone(&data);
    let writer = thread::spawn(move || {
        let mut d = data_clone.write().unwrap();
        d.push(4);
        println!("å†™è€…æ·»åŠ å…ƒç´ ");
    });

    for handle in handles {
        handle.join().unwrap();
    }
    writer.join().unwrap();

    println!("æœ€ç»ˆæ•°æ®: {:?}", *data.read().unwrap());
}
```

### 6.3 ä½¿ç”¨åŸå­æ“ä½œ

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn atomic_example() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("åŸå­è®¡æ•°: {}", counter.load(Ordering::SeqCst));
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶å‘ä»»åŠ¡è°ƒåº¦å™¨

### 7.1 è®¾è®¡ç›®æ ‡

å®ç°ä¸€ä¸ªé€šç”¨çš„å¹¶å‘ä»»åŠ¡è°ƒåº¦å™¨ï¼Œæ”¯æŒï¼š

- ä»»åŠ¡æäº¤ä¸æ‰§è¡Œ
- ä¼˜å…ˆçº§è°ƒåº¦
- ä»»åŠ¡å–æ¶ˆ
- ç»“æœè·å–

### 7.2 å®Œæ•´å®ç°

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;
use std::sync::{Arc, Mutex};
use std::thread;
use crossbeam::channel;

// ä»»åŠ¡å®šä¹‰
struct Task {
    id: usize,
    priority: usize,
    work: Box<dyn FnOnce() -> String + Send>,
}

impl PartialEq for Task {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl Eq for Task {}

impl PartialOrd for Task {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Task {
    fn cmp(&self, other: &Self) -> Ordering {
        self.priority.cmp(&other.priority)
    }
}

// ä»»åŠ¡è°ƒåº¦å™¨
struct TaskScheduler {
    task_queue: Arc<Mutex<BinaryHeap<Task>>>,
    result_tx: channel::Sender<(usize, String)>,
    result_rx: channel::Receiver<(usize, String)>,
}

impl TaskScheduler {
    fn new() -> Self {
        let (tx, rx) = channel::unbounded();
        Self {
            task_queue: Arc::new(Mutex::new(BinaryHeap::new())),
            result_tx: tx,
            result_rx: rx,
        }
    }

    fn submit<F>(&self, id: usize, priority: usize, work: F)
    where
        F: FnOnce() -> String + Send + 'static,
    {
        let task = Task {
            id,
            priority,
            work: Box::new(work),
        };
        self.task_queue.lock().unwrap().push(task);
    }

    fn start(&self, num_workers: usize) {
        for _ in 0..num_workers {
            let queue = Arc::clone(&self.task_queue);
            let tx = self.result_tx.clone();
            thread::spawn(move || loop {
                let task = {
                    let mut q = queue.lock().unwrap();
                    q.pop()
                };

                if let Some(task) = task {
                    let result = (task.work)();
                    tx.send((task.id, result)).unwrap();
                } else {
                    thread::sleep(std::time::Duration::from_millis(100));
                }
            });
        }
    }

    fn get_result(&self) -> Option<(usize, String)> {
        self.result_rx.try_recv().ok()
    }
}

fn main() {
    let scheduler = TaskScheduler::new();

    // æäº¤ä»»åŠ¡
    scheduler.submit(1, 1, || "ä½ä¼˜å…ˆçº§ä»»åŠ¡".to_string());
    scheduler.submit(2, 10, || "é«˜ä¼˜å…ˆçº§ä»»åŠ¡".to_string());
    scheduler.submit(3, 5, || "ä¸­ä¼˜å…ˆçº§ä»»åŠ¡".to_string());

    // å¯åŠ¨å·¥ä½œçº¿ç¨‹
    scheduler.start(2);

    // è·å–ç»“æœ
    thread::sleep(std::time::Duration::from_secs(1));
    while let Some((id, result)) = scheduler.get_result() {
        println!("ä»»åŠ¡ {} å®Œæˆ: {}", id, result);
    }
}
```

---

## 8. æ€§èƒ½ä¸æœ€ä½³å®è·µ

### 8.1 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**å‡å°‘é”ç«äº‰**ï¼š

```rust
// âŒ é¢‘ç¹åŠ é”
for i in 0..1000 {
    let mut data = mutex.lock().unwrap();
    data.push(i);
}

// âœ… æ‰¹é‡æ“ä½œ
let mut batch = Vec::new();
for i in 0..1000 {
    batch.push(i);
}
let mut data = mutex.lock().unwrap();
data.extend(batch);
```

**é€‰æ‹©åˆé€‚çš„åŒæ­¥åŸè¯­**ï¼š

- **åŸå­æ“ä½œ**ï¼šç®€å•è®¡æ•°å™¨
- **Mutex**ï¼šå¤æ‚æ•°æ®ç»“æ„
- **RwLock**ï¼šè¯»å¤šå†™å°‘
- **Channel**ï¼šæ¶ˆæ¯ä¼ é€’

### 8.2 æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨æ¶ˆæ¯ä¼ é€’**ï¼šé¿å…å…±äº«çŠ¶æ€
2. **æœ€å°åŒ–é”ä½œç”¨åŸŸ**ï¼šå°½æ—©é‡Šæ”¾é”
3. **é¿å…åµŒå¥—é”**ï¼šé˜²æ­¢æ­»é”
4. **ä½¿ç”¨ Rayon è¿›è¡Œæ•°æ®å¹¶è¡Œ**ï¼šç®€åŒ–ä»£ç 
5. **å¼‚æ­¥ I/O ä½¿ç”¨ Tokio**ï¼šæé«˜ååé‡

### 8.3 å¸¸è§é™·é˜±

**æ­»é”ç¤ºä¾‹**ï¼š

```rust
// âŒ æ­»é”é£é™©
let lock1 = Arc::new(Mutex::new(0));
let lock2 = Arc::new(Mutex::new(0));

// çº¿ç¨‹ 1: lock1 -> lock2
// çº¿ç¨‹ 2: lock2 -> lock1

// âœ… é¿å…ï¼šç»Ÿä¸€åŠ é”é¡ºåº
```

**æ€§èƒ½é™·é˜±**ï¼š

```rust
// âŒ è¿‡åº¦åŠ é”
let data = Arc::new(Mutex::new(vec![]));
for i in 0..1000 {
    let mut d = data.lock().unwrap();
    d.push(i); // æ¯æ¬¡å¾ªç¯éƒ½åŠ é”
}

// âœ… å‡å°‘åŠ é”æ¬¡æ•°
let mut local = vec![];
for i in 0..1000 {
    local.push(i);
}
data.lock().unwrap().extend(local);
```

---

## 9. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

| æ¨¡å¼ | æ ¸å¿ƒæ€æƒ³ | é€‚ç”¨åœºæ™¯ | Rust å·¥å…· |
|-----|---------|---------|----------|
| **Actor** | æ¶ˆæ¯ä¼ é€’ | çŠ¶æ€éš”ç¦»ã€å¼‚æ­¥é€šä¿¡ | Tokio, Actix |
| **Pipeline** | æµå¼å¤„ç† | æ•°æ®å¤„ç†ç®¡é“ | Channel |
| **Fork-Join** | ä»»åŠ¡åˆ†è§£ | æ•°æ®å¹¶è¡Œ | Rayon |
| **ç”Ÿäº§è€…-æ¶ˆè´¹è€…** | é˜Ÿåˆ—ç¼“å†² | é€Ÿåº¦ä¸åŒ¹é… | mpsc, crossbeam |
| **å…±äº«çŠ¶æ€** | åŒæ­¥è®¿é—® | å¿…é¡»å…±äº«æ—¶ | Mutex, RwLock, Atomic |

### é€‰æ‹©æŒ‡å—

- **CPU å¯†é›†å‹**ï¼šFork-Join (Rayon)
- **I/O å¯†é›†å‹**ï¼šActor (Tokio)
- **æ•°æ®æµ**ï¼šPipeline
- **ç®€å•å…±äº«**ï¼šAtomic > Mutex > RwLock

---

## ğŸ“š å‚è€ƒèµ„æº

- [Rust å¹¶å‘ç¼–ç¨‹](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [Tokio å¼‚æ­¥è¿è¡Œæ—¶](https://tokio.rs/)
- [Rayon æ•°æ®å¹¶è¡Œ](https://github.com/rayon-rs/rayon)
- [Crossbeam å·¥å…·é›†](https://github.com/crossbeam-rs/crossbeam)

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [æœ€ä½³å®è·µä¸åæ¨¡å¼](05_æœ€ä½³å®è·µä¸åæ¨¡å¼.md)ï¼ŒæŒæ¡è®¾è®¡æ¨¡å¼çš„è¿›é˜¶æŠ€å·§ã€‚
