# 02 结构型模式指南

> **文档类型**: Tier 2 - 实践指南
> **目标读者**: 需要掌握对象组合模式的开发者
> **预计学习时间**: 3-4小时
> **前置知识**: [创建型模式指南](./01_创建型模式指南.md)

**最后更新**: 2025-12-11
**适用版本**: Rust 1.92.0+

---

## 📋 目录

- [02 结构型模式指南](#02-结构型模式指南)
  - [📋 目录](#-目录)
  - [📐 知识结构](#-知识结构)
    - [概念定义](#概念定义)
    - [属性特征](#属性特征)
    - [关系连接](#关系连接)
    - [思维导图](#思维导图)
    - [概念矩阵](#概念矩阵)
  - [1. Adapter (适配器模式)](#1-adapter-适配器模式)
  - [2. Bridge (桥接模式)](#2-bridge-桥接模式)
  - [3. Composite (组合模式)](#3-composite-组合模式)
  - [4. Decorator (装饰器模式)](#4-decorator-装饰器模式)
  - [5. Facade (外观模式)](#5-facade-外观模式)
  - [6. Proxy (代理模式)](#6-proxy-代理模式)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 使用 Trait Objects](#71-使用-trait-objects)
    - [7.2 使用 Newtype 模式](#72-使用-newtype-模式)
    - [7.3 避免过度抽象](#73-避免过度抽象)

---

## 📐 知识结构

### 概念定义

**结构型模式 (Structural Patterns)**:

- **定义**: 处理对象组合的设计模式，关注如何组合类和对象以形成更大的结构
- **类型**: 设计模式类别
- **范畴**: 软件设计
- **相关概念**: 创建型模式、行为型模式、设计模式

**Adapter 模式**:

- **定义**: 将一个类的接口转换成客户希望的另一个接口，使原本不兼容的类可以一起工作
- **类型**: 结构型模式
- **属性**: 接口转换、兼容性、解耦
- **关系**: 与 Bridge、Proxy 模式相关

### 属性特征

**核心属性**:

- **接口适配**: 转换不兼容的接口
- **解耦**: 分离接口和实现
- **复用**: 复用现有类而不修改
- **灵活性**: 支持多种适配方式

**性能特征**:

- **适配开销**: 通常有少量性能开销
- **内存占用**: 需要额外的适配器对象
- **适用场景**: 接口不兼容、系统集成、遗留代码适配

### 关系连接

**继承关系**:

- Adapter --[is-a]--> 结构型模式
- Decorator --[is-a]--> 结构型模式

**组合关系**:

- 适配器 --[uses]--> 被适配对象
- 装饰器 --[wraps]--> 被装饰对象

**依赖关系**:

- 结构型模式 --[depends-on]--> 对象组合需求
- Adapter --[depends-on]--> 目标接口和源接口

### 思维导图

```text
结构型模式
│
├── Adapter 适配器
│   └── 接口转换
├── Bridge 桥接
│   └── 抽象与实现分离
├── Composite 组合
│   └── 树形结构
├── Decorator 装饰器
│   └── 动态扩展
├── Facade 外观
│   └── 简化接口
└── Proxy 代理
    └── 访问控制
```

### 概念矩阵

| 模式      | 目的     | 复杂度 | 适用场景       | 性能 |
| --------- | -------- | ------ | -------------- | ---- |
| Adapter   | 接口转换 | 低     | 接口不兼容     | 中   |
| Bridge    | 抽象分离 | 中     | 多维度变化     | 中   |
| Composite | 树形结构 | 中     | 部分-整体      | 中   |
| Decorator | 动态扩展 | 中     | 运行时扩展     | 中   |
| Facade    | 简化接口 | 低     | 复杂子系统     | 高   |
| Proxy     | 访问控制 | 中     | 延迟加载、缓存 | 中   |

---

## 1. Adapter (适配器模式)

将不兼容的接口转换为期望的接口：

```rust
// 旧接口
struct LegacyPrinter;
impl LegacyPrinter {
    fn print_text(&self, text: &str) {
        println!("[Legacy] {}", text);
    }
}

// 新接口
trait ModernPrinter {
    fn print(&self, content: &str);
}

// 适配器
struct PrinterAdapter {
    legacy: LegacyPrinter,
}

impl ModernPrinter for PrinterAdapter {
    fn print(&self, content: &str) {
        self.legacy.print_text(content);
    }
}

// 使用
fn print_document(printer: &dyn ModernPrinter) {
    printer.print("Hello, World!");
}

fn main() {
    let adapter = PrinterAdapter {
        legacy: LegacyPrinter,
    };
    print_document(&adapter);
}
```

**Rust 特有：From/Into trait**:

```rust
struct Celsius(f32);
struct Fahrenheit(f32);

impl From<Celsius> for Fahrenheit {
    fn from(c: Celsius) -> Self {
        Fahrenheit(c.0 * 9.0 / 5.0 + 32.0)
    }
}

fn main() {
    let celsius = Celsius(25.0);
    let fahrenheit: Fahrenheit = celsius.into();
    println!("{:.1}°F", fahrenheit.0);
}
```

---

## 2. Bridge (桥接模式)

分离抽象和实现：

```rust
// 实现接口
trait Renderer {
    fn render_circle(&self, radius: f32);
    fn render_square(&self, side: f32);
}

struct VectorRenderer;
impl Renderer for VectorRenderer {
    fn render_circle(&self, radius: f32) {
        println!("Vector: Circle with radius {}", radius);
    }

    fn render_square(&self, side: f32) {
        println!("Vector: Square with side {}", side);
    }
}

struct RasterRenderer;
impl Renderer for RasterRenderer {
    fn render_circle(&self, radius: f32) {
        println!("Raster: Circle with radius {}", radius);
    }

    fn render_square(&self, side: f32) {
        println!("Raster: Square with side {}", side);
    }
}

// 抽象层
trait Shape {
    fn draw(&self);
}

struct Circle {
    radius: f32,
    renderer: Box<dyn Renderer>,
}

impl Shape for Circle {
    fn draw(&self) {
        self.renderer.render_circle(self.radius);
    }
}

struct Square {
    side: f32,
    renderer: Box<dyn Renderer>,
}

impl Shape for Square {
    fn draw(&self) {
        self.renderer.render_square(self.side);
    }
}

fn main() {
    let circle = Circle {
        radius: 5.0,
        renderer: Box::new(VectorRenderer),
    };
    circle.draw();

    let square = Square {
        side: 10.0,
        renderer: Box::new(RasterRenderer),
    };
    square.draw();
}
```

---

## 3. Composite (组合模式)

树形结构的统一处理：

```rust
trait FileSystemNode {
    fn name(&self) -> &str;
    fn size(&self) -> usize;
    fn print(&self, indent: usize);
}

struct File {
    name: String,
    size: usize,
}

impl FileSystemNode for File {
    fn name(&self) -> &str {
        &self.name
    }

    fn size(&self) -> usize {
        self.size
    }

    fn print(&self, indent: usize) {
        println!("{:indent$}File: {} ({} bytes)", "", self.name, self.size, indent = indent);
    }
}

struct Directory {
    name: String,
    children: Vec<Box<dyn FileSystemNode>>,
}

impl Directory {
    fn new(name: String) -> Self {
        Directory {
            name,
            children: Vec::new(),
        }
    }

    fn add(&mut self, child: Box<dyn FileSystemNode>) {
        self.children.push(child);
    }
}

impl FileSystemNode for Directory {
    fn name(&self) -> &str {
        &self.name
    }

    fn size(&self) -> usize {
        self.children.iter().map(|c| c.size()).sum()
    }

    fn print(&self, indent: usize) {
        println!("{:indent$}Directory: {} ({} bytes)", "", self.name, self.size(), indent = indent);
        for child in &self.children {
            child.print(indent + 2);
        }
    }
}

fn main() {
    let mut root = Directory::new(String::from("root"));

    root.add(Box::new(File {
        name: String::from("file1.txt"),
        size: 100,
    }));

    let mut subdir = Directory::new(String::from("subdir"));
    subdir.add(Box::new(File {
        name: String::from("file2.txt"),
        size: 200,
    }));

    root.add(Box::new(subdir));

    root.print(0);
}
```

---

## 4. Decorator (装饰器模式)

动态添加职责：

```rust
trait DataSource {
    fn read(&self) -> String;
    fn write(&mut self, data: &str);
}

struct FileDataSource {
    filename: String,
    data: String,
}

impl DataSource for FileDataSource {
    fn read(&self) -> String {
        self.data.clone()
    }

    fn write(&mut self, data: &str) {
        self.data = data.to_string();
    }
}

// 加密装饰器
struct EncryptionDecorator {
    wrapped: Box<dyn DataSource>,
}

impl EncryptionDecorator {
    fn encrypt(&self, data: &str) -> String {
        data.chars().rev().collect()  // 简单反转
    }

    fn decrypt(&self, data: &str) -> String {
        data.chars().rev().collect()
    }
}

impl DataSource for EncryptionDecorator {
    fn read(&self) -> String {
        let data = self.wrapped.read();
        self.decrypt(&data)
    }

    fn write(&mut self, data: &str) {
        let encrypted = self.encrypt(data);
        self.wrapped.write(&encrypted);
    }
}

// 压缩装饰器
struct CompressionDecorator {
    wrapped: Box<dyn DataSource>,
}

impl DataSource for CompressionDecorator {
    fn read(&self) -> String {
        let data = self.wrapped.read();
        format!("[decompressed: {}]", data)
    }

    fn write(&mut self, data: &str) {
        let compressed = format!("[compressed: {}]", data);
        self.wrapped.write(&compressed);
    }
}

fn main() {
    let source = FileDataSource {
        filename: String::from("data.txt"),
        data: String::new(),
    };

    // 叠加装饰器
    let mut encrypted = EncryptionDecorator {
        wrapped: Box::new(source),
    };

    encrypted.write("Hello, World!");
    println!("{}", encrypted.read());
}
```

---

## 5. Facade (外观模式)

简化复杂子系统：

```rust
// 复杂的子系统
struct CPU;
impl CPU {
    fn freeze(&self) {
        println!("CPU: Freezing");
    }

    fn jump(&self, position: usize) {
        println!("CPU: Jumping to {}", position);
    }

    fn execute(&self) {
        println!("CPU: Executing");
    }
}

struct Memory;
impl Memory {
    fn load(&self, position: usize, data: &[u8]) {
        println!("Memory: Loading {} bytes at {}", data.len(), position);
    }
}

struct HardDrive;
impl HardDrive {
    fn read(&self, sector: usize, size: usize) -> Vec<u8> {
        println!("HardDrive: Reading {} bytes from sector {}", size, sector);
        vec![0; size]
    }
}

// 外观
struct ComputerFacade {
    cpu: CPU,
    memory: Memory,
    hard_drive: HardDrive,
}

impl ComputerFacade {
    fn new() -> Self {
        ComputerFacade {
            cpu: CPU,
            memory: Memory,
            hard_drive: HardDrive,
        }
    }

    fn start(&self) {
        println!("Starting computer...");
        self.cpu.freeze();

        let boot_data = self.hard_drive.read(0, 512);
        self.memory.load(0, &boot_data);

        self.cpu.jump(0);
        self.cpu.execute();

        println!("Computer started!");
    }
}

fn main() {
    let computer = ComputerFacade::new();
    computer.start();
}
```

---

## 6. Proxy (代理模式)

控制对对象的访问：

```rust
trait Image {
    fn display(&self);
}

struct RealImage {
    filename: String,
}

impl RealImage {
    fn new(filename: String) -> Self {
        println!("Loading image: {}", filename);
        RealImage { filename }
    }
}

impl Image for RealImage {
    fn display(&self) {
        println!("Displaying image: {}", self.filename);
    }
}

// 虚拟代理 - 延迟加载
struct ImageProxy {
    filename: String,
    real_image: Option<RealImage>,
}

impl ImageProxy {
    fn new(filename: String) -> Self {
        ImageProxy {
            filename,
            real_image: None,
        }
    }
}

impl Image for ImageProxy {
    fn display(&self) {
        // 延迟加载
        if self.real_image.is_none() {
            let mut self_mut = unsafe { &mut *(self as *const Self as *mut Self) };
            self_mut.real_image = Some(RealImage::new(self.filename.clone()));
        }

        if let Some(ref img) = self.real_image {
            img.display();
        }
    }
}

// 保护代理 - 访问控制
struct ProtectedImage {
    image: RealImage,
    access_level: u8,
}

impl ProtectedImage {
    fn display_with_permission(&self, user_level: u8) {
        if user_level >= self.access_level {
            self.image.display();
        } else {
            println!("Access denied!");
        }
    }
}
```

---

## 7. 最佳实践

### 7.1 使用 Trait Objects

```rust
trait Plugin {
    fn execute(&self);
}

struct Plugins {
    plugins: Vec<Box<dyn Plugin>>,
}

impl Plugins {
    fn add(&mut self, plugin: Box<dyn Plugin>) {
        self.plugins.push(plugin);
    }

    fn execute_all(&self) {
        for plugin in &self.plugins {
            plugin.execute();
        }
    }
}
```

### 7.2 使用 Newtype 模式

```rust
struct Meters(f64);
struct Feet(f64);

impl From<Meters> for Feet {
    fn from(m: Meters) -> Self {
        Feet(m.0 * 3.28084)
    }
}
```

### 7.3 避免过度抽象

```rust
// ❌ 过度设计
trait AbstractFileReader {
    fn read(&self) -> Result<Vec<u8>, std::io::Error>;
}

// ✅ 简单实用
fn read_file(path: &str) -> Result<Vec<u8>, std::io::Error> {
    std::fs::read(path)
}
```

---

**返回**: [Tier 2 索引](./README.md) | **下一步**: [行为型模式指南](./03_行为型模式指南.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-23
**文档状态**: ✅ 完成
