# 02 ç»“æ„å‹æ¨¡å¼æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—  
> **ç›®æ ‡è¯»è€…**: éœ€è¦æŒæ¡å¯¹è±¡ç»„åˆæ¨¡å¼çš„å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: [åˆ›å»ºå‹æ¨¡å¼æŒ‡å—](./01_åˆ›å»ºå‹æ¨¡å¼æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+

---

## ğŸ“‹ ç›®å½•

- [02 ç»“æ„å‹æ¨¡å¼æŒ‡å—](#02-ç»“æ„å‹æ¨¡å¼æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Adapter (é€‚é…å™¨æ¨¡å¼)](#1-adapter-é€‚é…å™¨æ¨¡å¼)
  - [2. Bridge (æ¡¥æ¥æ¨¡å¼)](#2-bridge-æ¡¥æ¥æ¨¡å¼)
  - [3. Composite (ç»„åˆæ¨¡å¼)](#3-composite-ç»„åˆæ¨¡å¼)
  - [4. Decorator (è£…é¥°å™¨æ¨¡å¼)](#4-decorator-è£…é¥°å™¨æ¨¡å¼)
  - [5. Facade (å¤–è§‚æ¨¡å¼)](#5-facade-å¤–è§‚æ¨¡å¼)
  - [6. Proxy (ä»£ç†æ¨¡å¼)](#6-proxy-ä»£ç†æ¨¡å¼)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 ä½¿ç”¨ Trait Objects](#71-ä½¿ç”¨-trait-objects)
    - [7.2 ä½¿ç”¨ Newtype æ¨¡å¼](#72-ä½¿ç”¨-newtype-æ¨¡å¼)
    - [7.3 é¿å…è¿‡åº¦æŠ½è±¡](#73-é¿å…è¿‡åº¦æŠ½è±¡)

---

## 1. Adapter (é€‚é…å™¨æ¨¡å¼)

å°†ä¸å…¼å®¹çš„æ¥å£è½¬æ¢ä¸ºæœŸæœ›çš„æ¥å£ï¼š

```rust
// æ—§æ¥å£
struct LegacyPrinter;
impl LegacyPrinter {
    fn print_text(&self, text: &str) {
        println!("[Legacy] {}", text);
    }
}

// æ–°æ¥å£
trait ModernPrinter {
    fn print(&self, content: &str);
}

// é€‚é…å™¨
struct PrinterAdapter {
    legacy: LegacyPrinter,
}

impl ModernPrinter for PrinterAdapter {
    fn print(&self, content: &str) {
        self.legacy.print_text(content);
    }
}

// ä½¿ç”¨
fn print_document(printer: &dyn ModernPrinter) {
    printer.print("Hello, World!");
}

fn main() {
    let adapter = PrinterAdapter {
        legacy: LegacyPrinter,
    };
    print_document(&adapter);
}
```

**Rust ç‰¹æœ‰ï¼šFrom/Into trait**:

```rust
struct Celsius(f32);
struct Fahrenheit(f32);

impl From<Celsius> for Fahrenheit {
    fn from(c: Celsius) -> Self {
        Fahrenheit(c.0 * 9.0 / 5.0 + 32.0)
    }
}

fn main() {
    let celsius = Celsius(25.0);
    let fahrenheit: Fahrenheit = celsius.into();
    println!("{:.1}Â°F", fahrenheit.0);
}
```

---

## 2. Bridge (æ¡¥æ¥æ¨¡å¼)

åˆ†ç¦»æŠ½è±¡å’Œå®ç°ï¼š

```rust
// å®ç°æ¥å£
trait Renderer {
    fn render_circle(&self, radius: f32);
    fn render_square(&self, side: f32);
}

struct VectorRenderer;
impl Renderer for VectorRenderer {
    fn render_circle(&self, radius: f32) {
        println!("Vector: Circle with radius {}", radius);
    }
    
    fn render_square(&self, side: f32) {
        println!("Vector: Square with side {}", side);
    }
}

struct RasterRenderer;
impl Renderer for RasterRenderer {
    fn render_circle(&self, radius: f32) {
        println!("Raster: Circle with radius {}", radius);
    }
    
    fn render_square(&self, side: f32) {
        println!("Raster: Square with side {}", side);
    }
}

// æŠ½è±¡å±‚
trait Shape {
    fn draw(&self);
}

struct Circle {
    radius: f32,
    renderer: Box<dyn Renderer>,
}

impl Shape for Circle {
    fn draw(&self) {
        self.renderer.render_circle(self.radius);
    }
}

struct Square {
    side: f32,
    renderer: Box<dyn Renderer>,
}

impl Shape for Square {
    fn draw(&self) {
        self.renderer.render_square(self.side);
    }
}

fn main() {
    let circle = Circle {
        radius: 5.0,
        renderer: Box::new(VectorRenderer),
    };
    circle.draw();
    
    let square = Square {
        side: 10.0,
        renderer: Box::new(RasterRenderer),
    };
    square.draw();
}
```

---

## 3. Composite (ç»„åˆæ¨¡å¼)

æ ‘å½¢ç»“æ„çš„ç»Ÿä¸€å¤„ç†ï¼š

```rust
trait FileSystemNode {
    fn name(&self) -> &str;
    fn size(&self) -> usize;
    fn print(&self, indent: usize);
}

struct File {
    name: String,
    size: usize,
}

impl FileSystemNode for File {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn size(&self) -> usize {
        self.size
    }
    
    fn print(&self, indent: usize) {
        println!("{:indent$}File: {} ({} bytes)", "", self.name, self.size, indent = indent);
    }
}

struct Directory {
    name: String,
    children: Vec<Box<dyn FileSystemNode>>,
}

impl Directory {
    fn new(name: String) -> Self {
        Directory {
            name,
            children: Vec::new(),
        }
    }
    
    fn add(&mut self, child: Box<dyn FileSystemNode>) {
        self.children.push(child);
    }
}

impl FileSystemNode for Directory {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn size(&self) -> usize {
        self.children.iter().map(|c| c.size()).sum()
    }
    
    fn print(&self, indent: usize) {
        println!("{:indent$}Directory: {} ({} bytes)", "", self.name, self.size(), indent = indent);
        for child in &self.children {
            child.print(indent + 2);
        }
    }
}

fn main() {
    let mut root = Directory::new(String::from("root"));
    
    root.add(Box::new(File {
        name: String::from("file1.txt"),
        size: 100,
    }));
    
    let mut subdir = Directory::new(String::from("subdir"));
    subdir.add(Box::new(File {
        name: String::from("file2.txt"),
        size: 200,
    }));
    
    root.add(Box::new(subdir));
    
    root.print(0);
}
```

---

## 4. Decorator (è£…é¥°å™¨æ¨¡å¼)

åŠ¨æ€æ·»åŠ èŒè´£ï¼š

```rust
trait DataSource {
    fn read(&self) -> String;
    fn write(&mut self, data: &str);
}

struct FileDataSource {
    filename: String,
    data: String,
}

impl DataSource for FileDataSource {
    fn read(&self) -> String {
        self.data.clone()
    }
    
    fn write(&mut self, data: &str) {
        self.data = data.to_string();
    }
}

// åŠ å¯†è£…é¥°å™¨
struct EncryptionDecorator {
    wrapped: Box<dyn DataSource>,
}

impl EncryptionDecorator {
    fn encrypt(&self, data: &str) -> String {
        data.chars().rev().collect()  // ç®€å•åè½¬
    }
    
    fn decrypt(&self, data: &str) -> String {
        data.chars().rev().collect()
    }
}

impl DataSource for EncryptionDecorator {
    fn read(&self) -> String {
        let data = self.wrapped.read();
        self.decrypt(&data)
    }
    
    fn write(&mut self, data: &str) {
        let encrypted = self.encrypt(data);
        self.wrapped.write(&encrypted);
    }
}

// å‹ç¼©è£…é¥°å™¨
struct CompressionDecorator {
    wrapped: Box<dyn DataSource>,
}

impl DataSource for CompressionDecorator {
    fn read(&self) -> String {
        let data = self.wrapped.read();
        format!("[decompressed: {}]", data)
    }
    
    fn write(&mut self, data: &str) {
        let compressed = format!("[compressed: {}]", data);
        self.wrapped.write(&compressed);
    }
}

fn main() {
    let source = FileDataSource {
        filename: String::from("data.txt"),
        data: String::new(),
    };
    
    // å åŠ è£…é¥°å™¨
    let mut encrypted = EncryptionDecorator {
        wrapped: Box::new(source),
    };
    
    encrypted.write("Hello, World!");
    println!("{}", encrypted.read());
}
```

---

## 5. Facade (å¤–è§‚æ¨¡å¼)

ç®€åŒ–å¤æ‚å­ç³»ç»Ÿï¼š

```rust
// å¤æ‚çš„å­ç³»ç»Ÿ
struct CPU;
impl CPU {
    fn freeze(&self) {
        println!("CPU: Freezing");
    }
    
    fn jump(&self, position: usize) {
        println!("CPU: Jumping to {}", position);
    }
    
    fn execute(&self) {
        println!("CPU: Executing");
    }
}

struct Memory;
impl Memory {
    fn load(&self, position: usize, data: &[u8]) {
        println!("Memory: Loading {} bytes at {}", data.len(), position);
    }
}

struct HardDrive;
impl HardDrive {
    fn read(&self, sector: usize, size: usize) -> Vec<u8> {
        println!("HardDrive: Reading {} bytes from sector {}", size, sector);
        vec![0; size]
    }
}

// å¤–è§‚
struct ComputerFacade {
    cpu: CPU,
    memory: Memory,
    hard_drive: HardDrive,
}

impl ComputerFacade {
    fn new() -> Self {
        ComputerFacade {
            cpu: CPU,
            memory: Memory,
            hard_drive: HardDrive,
        }
    }
    
    fn start(&self) {
        println!("Starting computer...");
        self.cpu.freeze();
        
        let boot_data = self.hard_drive.read(0, 512);
        self.memory.load(0, &boot_data);
        
        self.cpu.jump(0);
        self.cpu.execute();
        
        println!("Computer started!");
    }
}

fn main() {
    let computer = ComputerFacade::new();
    computer.start();
}
```

---

## 6. Proxy (ä»£ç†æ¨¡å¼)

æ§åˆ¶å¯¹å¯¹è±¡çš„è®¿é—®ï¼š

```rust
trait Image {
    fn display(&self);
}

struct RealImage {
    filename: String,
}

impl RealImage {
    fn new(filename: String) -> Self {
        println!("Loading image: {}", filename);
        RealImage { filename }
    }
}

impl Image for RealImage {
    fn display(&self) {
        println!("Displaying image: {}", self.filename);
    }
}

// è™šæ‹Ÿä»£ç† - å»¶è¿ŸåŠ è½½
struct ImageProxy {
    filename: String,
    real_image: Option<RealImage>,
}

impl ImageProxy {
    fn new(filename: String) -> Self {
        ImageProxy {
            filename,
            real_image: None,
        }
    }
}

impl Image for ImageProxy {
    fn display(&self) {
        // å»¶è¿ŸåŠ è½½
        if self.real_image.is_none() {
            let mut self_mut = unsafe { &mut *(self as *const Self as *mut Self) };
            self_mut.real_image = Some(RealImage::new(self.filename.clone()));
        }
        
        if let Some(ref img) = self.real_image {
            img.display();
        }
    }
}

// ä¿æŠ¤ä»£ç† - è®¿é—®æ§åˆ¶
struct ProtectedImage {
    image: RealImage,
    access_level: u8,
}

impl ProtectedImage {
    fn display_with_permission(&self, user_level: u8) {
        if user_level >= self.access_level {
            self.image.display();
        } else {
            println!("Access denied!");
        }
    }
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 ä½¿ç”¨ Trait Objects

```rust
trait Plugin {
    fn execute(&self);
}

struct Plugins {
    plugins: Vec<Box<dyn Plugin>>,
}

impl Plugins {
    fn add(&mut self, plugin: Box<dyn Plugin>) {
        self.plugins.push(plugin);
    }
    
    fn execute_all(&self) {
        for plugin in &self.plugins {
            plugin.execute();
        }
    }
}
```

### 7.2 ä½¿ç”¨ Newtype æ¨¡å¼

```rust
struct Meters(f64);
struct Feet(f64);

impl From<Meters> for Feet {
    fn from(m: Meters) -> Self {
        Feet(m.0 * 3.28084)
    }
}
```

### 7.3 é¿å…è¿‡åº¦æŠ½è±¡

```rust
// âŒ è¿‡åº¦è®¾è®¡
trait AbstractFileReader {
    fn read(&self) -> Result<Vec<u8>, std::io::Error>;
}

// âœ… ç®€å•å®ç”¨
fn read_file(path: &str) -> Result<Vec<u8>, std::io::Error> {
    std::fs::read(path)
}
```

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—](./03_è¡Œä¸ºå‹æ¨¡å¼æŒ‡å—.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
