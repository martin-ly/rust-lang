# 02 结构型模式指南

> **文档类型**: Tier 2 - 实践指南  
> **目标读者**: 需要掌握对象组合模式的开发者  
> **预计学习时间**: 3-4小时  
> **前置知识**: [创建型模式指南](./01_创建型模式指南.md)

**最后更新**: 2025-10-23  
**适用版本**: Rust 1.90+

---

## 📋 目录

- [02 结构型模式指南](#02-结构型模式指南)
  - [📊 目录](#-目录)
  - [1. Adapter (适配器模式)](#1-adapter-适配器模式)
  - [2. Bridge (桥接模式)](#2-bridge-桥接模式)
  - [3. Composite (组合模式)](#3-composite-组合模式)
  - [4. Decorator (装饰器模式)](#4-decorator-装饰器模式)
  - [5. Facade (外观模式)](#5-facade-外观模式)
  - [6. Proxy (代理模式)](#6-proxy-代理模式)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 使用 Trait Objects](#71-使用-trait-objects)
    - [7.2 使用 Newtype 模式](#72-使用-newtype-模式)
    - [7.3 避免过度抽象](#73-避免过度抽象)

---

## 1. Adapter (适配器模式)

将不兼容的接口转换为期望的接口：

```rust
// 旧接口
struct LegacyPrinter;
impl LegacyPrinter {
    fn print_text(&self, text: &str) {
        println!("[Legacy] {}", text);
    }
}

// 新接口
trait ModernPrinter {
    fn print(&self, content: &str);
}

// 适配器
struct PrinterAdapter {
    legacy: LegacyPrinter,
}

impl ModernPrinter for PrinterAdapter {
    fn print(&self, content: &str) {
        self.legacy.print_text(content);
    }
}

// 使用
fn print_document(printer: &dyn ModernPrinter) {
    printer.print("Hello, World!");
}

fn main() {
    let adapter = PrinterAdapter {
        legacy: LegacyPrinter,
    };
    print_document(&adapter);
}
```

**Rust 特有：From/Into trait**:

```rust
struct Celsius(f32);
struct Fahrenheit(f32);

impl From<Celsius> for Fahrenheit {
    fn from(c: Celsius) -> Self {
        Fahrenheit(c.0 * 9.0 / 5.0 + 32.0)
    }
}

fn main() {
    let celsius = Celsius(25.0);
    let fahrenheit: Fahrenheit = celsius.into();
    println!("{:.1}°F", fahrenheit.0);
}
```

---

## 2. Bridge (桥接模式)

分离抽象和实现：

```rust
// 实现接口
trait Renderer {
    fn render_circle(&self, radius: f32);
    fn render_square(&self, side: f32);
}

struct VectorRenderer;
impl Renderer for VectorRenderer {
    fn render_circle(&self, radius: f32) {
        println!("Vector: Circle with radius {}", radius);
    }
    
    fn render_square(&self, side: f32) {
        println!("Vector: Square with side {}", side);
    }
}

struct RasterRenderer;
impl Renderer for RasterRenderer {
    fn render_circle(&self, radius: f32) {
        println!("Raster: Circle with radius {}", radius);
    }
    
    fn render_square(&self, side: f32) {
        println!("Raster: Square with side {}", side);
    }
}

// 抽象层
trait Shape {
    fn draw(&self);
}

struct Circle {
    radius: f32,
    renderer: Box<dyn Renderer>,
}

impl Shape for Circle {
    fn draw(&self) {
        self.renderer.render_circle(self.radius);
    }
}

struct Square {
    side: f32,
    renderer: Box<dyn Renderer>,
}

impl Shape for Square {
    fn draw(&self) {
        self.renderer.render_square(self.side);
    }
}

fn main() {
    let circle = Circle {
        radius: 5.0,
        renderer: Box::new(VectorRenderer),
    };
    circle.draw();
    
    let square = Square {
        side: 10.0,
        renderer: Box::new(RasterRenderer),
    };
    square.draw();
}
```

---

## 3. Composite (组合模式)

树形结构的统一处理：

```rust
trait FileSystemNode {
    fn name(&self) -> &str;
    fn size(&self) -> usize;
    fn print(&self, indent: usize);
}

struct File {
    name: String,
    size: usize,
}

impl FileSystemNode for File {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn size(&self) -> usize {
        self.size
    }
    
    fn print(&self, indent: usize) {
        println!("{:indent$}File: {} ({} bytes)", "", self.name, self.size, indent = indent);
    }
}

struct Directory {
    name: String,
    children: Vec<Box<dyn FileSystemNode>>,
}

impl Directory {
    fn new(name: String) -> Self {
        Directory {
            name,
            children: Vec::new(),
        }
    }
    
    fn add(&mut self, child: Box<dyn FileSystemNode>) {
        self.children.push(child);
    }
}

impl FileSystemNode for Directory {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn size(&self) -> usize {
        self.children.iter().map(|c| c.size()).sum()
    }
    
    fn print(&self, indent: usize) {
        println!("{:indent$}Directory: {} ({} bytes)", "", self.name, self.size(), indent = indent);
        for child in &self.children {
            child.print(indent + 2);
        }
    }
}

fn main() {
    let mut root = Directory::new(String::from("root"));
    
    root.add(Box::new(File {
        name: String::from("file1.txt"),
        size: 100,
    }));
    
    let mut subdir = Directory::new(String::from("subdir"));
    subdir.add(Box::new(File {
        name: String::from("file2.txt"),
        size: 200,
    }));
    
    root.add(Box::new(subdir));
    
    root.print(0);
}
```

---

## 4. Decorator (装饰器模式)

动态添加职责：

```rust
trait DataSource {
    fn read(&self) -> String;
    fn write(&mut self, data: &str);
}

struct FileDataSource {
    filename: String,
    data: String,
}

impl DataSource for FileDataSource {
    fn read(&self) -> String {
        self.data.clone()
    }
    
    fn write(&mut self, data: &str) {
        self.data = data.to_string();
    }
}

// 加密装饰器
struct EncryptionDecorator {
    wrapped: Box<dyn DataSource>,
}

impl EncryptionDecorator {
    fn encrypt(&self, data: &str) -> String {
        data.chars().rev().collect()  // 简单反转
    }
    
    fn decrypt(&self, data: &str) -> String {
        data.chars().rev().collect()
    }
}

impl DataSource for EncryptionDecorator {
    fn read(&self) -> String {
        let data = self.wrapped.read();
        self.decrypt(&data)
    }
    
    fn write(&mut self, data: &str) {
        let encrypted = self.encrypt(data);
        self.wrapped.write(&encrypted);
    }
}

// 压缩装饰器
struct CompressionDecorator {
    wrapped: Box<dyn DataSource>,
}

impl DataSource for CompressionDecorator {
    fn read(&self) -> String {
        let data = self.wrapped.read();
        format!("[decompressed: {}]", data)
    }
    
    fn write(&mut self, data: &str) {
        let compressed = format!("[compressed: {}]", data);
        self.wrapped.write(&compressed);
    }
}

fn main() {
    let source = FileDataSource {
        filename: String::from("data.txt"),
        data: String::new(),
    };
    
    // 叠加装饰器
    let mut encrypted = EncryptionDecorator {
        wrapped: Box::new(source),
    };
    
    encrypted.write("Hello, World!");
    println!("{}", encrypted.read());
}
```

---

## 5. Facade (外观模式)

简化复杂子系统：

```rust
// 复杂的子系统
struct CPU;
impl CPU {
    fn freeze(&self) {
        println!("CPU: Freezing");
    }
    
    fn jump(&self, position: usize) {
        println!("CPU: Jumping to {}", position);
    }
    
    fn execute(&self) {
        println!("CPU: Executing");
    }
}

struct Memory;
impl Memory {
    fn load(&self, position: usize, data: &[u8]) {
        println!("Memory: Loading {} bytes at {}", data.len(), position);
    }
}

struct HardDrive;
impl HardDrive {
    fn read(&self, sector: usize, size: usize) -> Vec<u8> {
        println!("HardDrive: Reading {} bytes from sector {}", size, sector);
        vec![0; size]
    }
}

// 外观
struct ComputerFacade {
    cpu: CPU,
    memory: Memory,
    hard_drive: HardDrive,
}

impl ComputerFacade {
    fn new() -> Self {
        ComputerFacade {
            cpu: CPU,
            memory: Memory,
            hard_drive: HardDrive,
        }
    }
    
    fn start(&self) {
        println!("Starting computer...");
        self.cpu.freeze();
        
        let boot_data = self.hard_drive.read(0, 512);
        self.memory.load(0, &boot_data);
        
        self.cpu.jump(0);
        self.cpu.execute();
        
        println!("Computer started!");
    }
}

fn main() {
    let computer = ComputerFacade::new();
    computer.start();
}
```

---

## 6. Proxy (代理模式)

控制对对象的访问：

```rust
trait Image {
    fn display(&self);
}

struct RealImage {
    filename: String,
}

impl RealImage {
    fn new(filename: String) -> Self {
        println!("Loading image: {}", filename);
        RealImage { filename }
    }
}

impl Image for RealImage {
    fn display(&self) {
        println!("Displaying image: {}", self.filename);
    }
}

// 虚拟代理 - 延迟加载
struct ImageProxy {
    filename: String,
    real_image: Option<RealImage>,
}

impl ImageProxy {
    fn new(filename: String) -> Self {
        ImageProxy {
            filename,
            real_image: None,
        }
    }
}

impl Image for ImageProxy {
    fn display(&self) {
        // 延迟加载
        if self.real_image.is_none() {
            let mut self_mut = unsafe { &mut *(self as *const Self as *mut Self) };
            self_mut.real_image = Some(RealImage::new(self.filename.clone()));
        }
        
        if let Some(ref img) = self.real_image {
            img.display();
        }
    }
}

// 保护代理 - 访问控制
struct ProtectedImage {
    image: RealImage,
    access_level: u8,
}

impl ProtectedImage {
    fn display_with_permission(&self, user_level: u8) {
        if user_level >= self.access_level {
            self.image.display();
        } else {
            println!("Access denied!");
        }
    }
}
```

---

## 7. 最佳实践

### 7.1 使用 Trait Objects

```rust
trait Plugin {
    fn execute(&self);
}

struct Plugins {
    plugins: Vec<Box<dyn Plugin>>,
}

impl Plugins {
    fn add(&mut self, plugin: Box<dyn Plugin>) {
        self.plugins.push(plugin);
    }
    
    fn execute_all(&self) {
        for plugin in &self.plugins {
            plugin.execute();
        }
    }
}
```

### 7.2 使用 Newtype 模式

```rust
struct Meters(f64);
struct Feet(f64);

impl From<Meters> for Feet {
    fn from(m: Meters) -> Self {
        Feet(m.0 * 3.28084)
    }
}
```

### 7.3 避免过度抽象

```rust
// ❌ 过度设计
trait AbstractFileReader {
    fn read(&self) -> Result<Vec<u8>, std::io::Error>;
}

// ✅ 简单实用
fn read_file(path: &str) -> Result<Vec<u8>, std::io::Error> {
    std::fs::read(path)
}
```

---

**返回**: [Tier 2 索引](./README.md) | **下一步**: [行为型模式指南](./03_行为型模式指南.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-23  
**文档状态**: ✅ 完成
