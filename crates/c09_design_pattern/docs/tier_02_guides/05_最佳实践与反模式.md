# C09 Design Pattern - Tier 2: æœ€ä½³å®è·µä¸åæ¨¡å¼

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 40 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

1. [C09 Design Pattern - Tier 2: æœ€ä½³å®è·µä¸åæ¨¡å¼](#1-è®¾è®¡æ¨¡å¼æœ€ä½³å®è·µ)
2. [Rust ç‰¹æœ‰çš„è®¾è®¡æ¨¡å¼](#2-rust-ç‰¹æœ‰çš„è®¾è®¡æ¨¡å¼)
3. [å¸¸è§åæ¨¡å¼](#3-å¸¸è§åæ¨¡å¼)
4. [æ€§èƒ½åæ¨¡å¼](#4-æ€§èƒ½åæ¨¡å¼)
5. [ä»£ç å®¡æŸ¥æ¸…å•](#5-ä»£ç å®¡æŸ¥æ¸…å•)
6. [é‡æ„æŠ€å·§](#6-é‡æ„æŠ€å·§)
7. [å®æˆ˜æ¡ˆä¾‹åˆ†æ](#7-å®æˆ˜æ¡ˆä¾‹åˆ†æ)

---

## 1. è®¾è®¡æ¨¡å¼æœ€ä½³å®è·µ

### 1.1 ä¼˜å…ˆç®€å•è®¾è®¡

**åŸåˆ™**: å…ˆå†™ç®€å•ä»£ç ï¼Œå¿…è¦æ—¶å†å¼•å…¥æ¨¡å¼ã€‚

```rust
// âŒ è¿‡åº¦è®¾è®¡ï¼šä¸ºå•ä¸€åŠŸèƒ½å¼•å…¥å·¥å‚æ¨¡å¼
trait ShapeFactory {
    fn create_shape(&self) -> Box<dyn Shape>;
}

struct CircleFactory;
impl ShapeFactory for CircleFactory {
    fn create_shape(&self) -> Box<dyn Shape> {
        Box::new(Circle { radius: 1.0 })
    }
}

// âœ… ç®€å•è®¾è®¡ï¼šç›´æ¥åˆ›å»º
struct Circle {
    radius: f64,
}

impl Circle {
    fn new(radius: f64) -> Self {
        Self { radius }
    }
}

fn main() {
    let circle = Circle::new(1.0); // æ¸…æ™°ç›´æ¥
}
```

### 1.2 åˆ©ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿ

**ç±»å‹çŠ¶æ€æ¨¡å¼**ï¼šåœ¨ç¼–è¯‘æœŸä¿è¯çŠ¶æ€æ­£ç¡®æ€§ã€‚

```rust
// ä½¿ç”¨ç±»å‹çŠ¶æ€æ¨¡å¼å®ç°å®‰å…¨çš„è¿æ¥ç®¡ç†
struct Disconnected;
struct Connected;

struct Connection<State> {
    url: String,
    _state: std::marker::PhantomData<State>,
}

impl Connection<Disconnected> {
    fn new(url: String) -> Self {
        Self {
            url,
            _state: std::marker::PhantomData,
        }
    }

    // åªæœ‰æ–­å¼€çŠ¶æ€æ‰èƒ½è¿æ¥
    fn connect(self) -> Connection<Connected> {
        println!("è¿æ¥åˆ°: {}", self.url);
        Connection {
            url: self.url,
            _state: std::marker::PhantomData,
        }
    }
}

impl Connection<Connected> {
    // åªæœ‰è¿æ¥çŠ¶æ€æ‰èƒ½å‘é€æ•°æ®
    fn send(&self, data: &str) {
        println!("å‘é€æ•°æ®: {}", data);
    }

    // åªæœ‰è¿æ¥çŠ¶æ€æ‰èƒ½æ–­å¼€
    fn disconnect(self) -> Connection<Disconnected> {
        println!("æ–­å¼€è¿æ¥");
        Connection {
            url: self.url,
            _state: std::marker::PhantomData,
        }
    }
}

fn main() {
    let conn = Connection::new("localhost".to_string());
    // conn.send("data"); // âŒ ç¼–è¯‘é”™è¯¯ï¼šæœªè¿æ¥æ— æ³•å‘é€

    let conn = conn.connect();
    conn.send("Hello"); // âœ… å®‰å…¨å‘é€

    let conn = conn.disconnect();
    // conn.send("data"); // âŒ ç¼–è¯‘é”™è¯¯ï¼šå·²æ–­å¼€æ— æ³•å‘é€
}
```

### 1.3 åˆç†ä½¿ç”¨ trait object

**æƒè¡¡**ï¼š

- **é™æ€åˆ†æ´¾**ï¼šç¼–è¯‘æœŸç¡®å®šç±»å‹ï¼Œæ€§èƒ½æ›´å¥½
- **åŠ¨æ€åˆ†æ´¾**ï¼šè¿è¡Œæ—¶å¤šæ€ï¼Œæ›´çµæ´»

```rust
// âœ… é™æ€åˆ†æ´¾ï¼šé€‚åˆå·²çŸ¥ç±»å‹
fn process_static<T: Display>(item: T) {
    println!("{}", item);
}

// âœ… åŠ¨æ€åˆ†æ´¾ï¼šé€‚åˆå¼‚æ„é›†åˆ
fn process_dynamic(items: Vec<Box<dyn Display>>) {
    for item in items {
        println!("{}", item);
    }
}

use std::fmt::Display;

fn main() {
    // é™æ€åˆ†æ´¾ç¤ºä¾‹
    process_static(42);
    process_static("Hello");

    // åŠ¨æ€åˆ†æ´¾ç¤ºä¾‹
    let items: Vec<Box<dyn Display>> = vec![
        Box::new(42),
        Box::new("Hello"),
    ];
    process_dynamic(items);
}
```

---

## 2. Rust ç‰¹æœ‰çš„è®¾è®¡æ¨¡å¼

### 2.1 Newtype æ¨¡å¼

**ç›®çš„**ï¼šä¸ºç°æœ‰ç±»å‹æ·»åŠ è¯­ä¹‰æˆ–å®ç°å¤–éƒ¨ traitã€‚

```rust
// ä¸ºåŸºç¡€ç±»å‹æ·»åŠ è¯­ä¹‰
struct UserId(u64);
struct OrderId(u64);

impl UserId {
    fn new(id: u64) -> Self {
        UserId(id)
    }

    fn value(&self) -> u64 {
        self.0
    }
}

fn process_user(user_id: UserId) {
    println!("å¤„ç†ç”¨æˆ·: {}", user_id.value());
}

fn main() {
    let user_id = UserId::new(123);
    // let order_id = OrderId(456);
    
    process_user(user_id);
    // process_user(order_id); // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
}
```

**å­¤å„¿è§„åˆ™ç»•è¿‡**ï¼š

```rust
use std::fmt;

// ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨ trait
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0.join(", "))
    }
}

fn main() {
    let words = Wrapper(vec!["Rust".to_string(), "è®¾è®¡".to_string()]);
    println!("{}", words);
}
```

### 2.2 RAII æ¨¡å¼

**èµ„æºè·å–å³åˆå§‹åŒ–**ï¼šåˆ©ç”¨ Drop trait è‡ªåŠ¨æ¸…ç†èµ„æºã€‚

```rust
use std::fs::File;
use std::io::Write;

struct FileGuard {
    file: File,
}

impl FileGuard {
    fn new(path: &str) -> std::io::Result<Self> {
        Ok(Self {
            file: File::create(path)?,
        })
    }

    fn write(&mut self, data: &str) -> std::io::Result<()> {
        self.file.write_all(data.as_bytes())
    }
}

impl Drop for FileGuard {
    fn drop(&mut self) {
        println!("æ–‡ä»¶è‡ªåŠ¨å…³é—­");
        // æ–‡ä»¶åœ¨æ­¤è‡ªåŠ¨å…³é—­
    }
}

fn main() -> std::io::Result<()> {
    {
        let mut guard = FileGuard::new("example.txt")?;
        guard.write("Hello RAII")?;
    } // guard åœ¨æ­¤ç¦»å¼€ä½œç”¨åŸŸï¼Œè‡ªåŠ¨å…³é—­æ–‡ä»¶
    
    println!("æ–‡ä»¶å·²å®‰å…¨å…³é—­");
    Ok(())
}
```

### 2.3 Extension Trait æ¨¡å¼

**æ‰©å±•ç°æœ‰ç±»å‹çš„åŠŸèƒ½**ï¼š

```rust
trait StringExt {
    fn truncate_with_ellipsis(&self, max_len: usize) -> String;
}

impl StringExt for String {
    fn truncate_with_ellipsis(&self, max_len: usize) -> String {
        if self.len() <= max_len {
            self.clone()
        } else {
            format!("{}...", &self[..max_len - 3])
        }
    }
}

fn main() {
    let long_text = String::from("è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„å­—ç¬¦ä¸²");
    let truncated = long_text.truncate_with_ellipsis(10);
    println!("{}", truncated);
}
```

---

## 3. å¸¸è§åæ¨¡å¼

### 3.1 God Object (ä¸Šå¸å¯¹è±¡)

**é—®é¢˜**ï¼šå•ä¸ªç»“æ„ä½“æ‰¿æ‹…è¿‡å¤šèŒè´£ã€‚

```rust
// âŒ åæ¨¡å¼ï¼šä¸Šå¸å¯¹è±¡
struct Application {
    database: Database,
    network: Network,
    ui: UI,
    auth: Auth,
    logging: Logger,
}

impl Application {
    fn connect_database(&mut self) { /* ... */ }
    fn send_request(&self) { /* ... */ }
    fn render_ui(&self) { /* ... */ }
    fn authenticate(&self) { /* ... */ }
    fn log(&self) { /* ... */ }
}

// âœ… é‡æ„ï¼šèŒè´£åˆ†ç¦»
struct DatabaseService {
    connection: Database,
}

struct NetworkService {
    client: Network,
}

struct Application {
    database: DatabaseService,
    network: NetworkService,
}

impl DatabaseService {
    fn connect(&mut self) { /* ... */ }
}

impl NetworkService {
    fn send_request(&self) { /* ... */ }
}
```

### 3.2 Deref æ»¥ç”¨

**é—®é¢˜**ï¼šè¿‡åº¦ä½¿ç”¨ Deref trait å¯¼è‡´éšå¼è¡Œä¸ºã€‚

```rust
use std::ops::Deref;

// âŒ åæ¨¡å¼ï¼šæ»¥ç”¨ Deref
struct MyString(String);

impl Deref for MyString {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// âœ… æœ€ä½³å®è·µï¼šæ˜¾å¼æ–¹æ³•
struct MyString2(String);

impl MyString2 {
    fn as_str(&self) -> &str {
        &self.0
    }
    
    fn into_inner(self) -> String {
        self.0
    }
}
```

**è§„åˆ™**ï¼šä»…åœ¨æ™ºèƒ½æŒ‡é’ˆç±»å‹ä½¿ç”¨ Derefã€‚

### 3.3 clone() æ»¥ç”¨

**é—®é¢˜**ï¼šè¿‡åº¦ clone å¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚

```rust
// âŒ åæ¨¡å¼ï¼šä¸å¿…è¦çš„ clone
fn process_data(data: Vec<i32>) -> Vec<i32> {
    let cloned = data.clone();
    cloned.iter().map(|&x| x * 2).collect()
}

// âœ… é‡æ„ï¼šä½¿ç”¨å¼•ç”¨
fn process_data_efficient(data: &[i32]) -> Vec<i32> {
    data.iter().map(|&x| x * 2).collect()
}

// âœ… æˆ–è€…ï¼šæ¶ˆè´¹æ‰€æœ‰æƒ
fn process_data_consume(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x * 2).collect()
}
```

### 3.4 unwrap() æ»¥ç”¨

**é—®é¢˜**ï¼šåœ¨ç”Ÿäº§ä»£ç ä¸­è¿‡åº¦ä½¿ç”¨ unwrapã€‚

```rust
// âŒ åæ¨¡å¼ï¼šå¯èƒ½ panic
fn read_config() -> Config {
    let file = std::fs::read_to_string("config.toml").unwrap();
    toml::from_str(&file).unwrap()
}

// âœ… æœ€ä½³å®è·µï¼šé”™è¯¯ä¼ æ’­
fn read_config_safe() -> Result<Config, Box<dyn std::error::Error>> {
    let file = std::fs::read_to_string("config.toml")?;
    let config = toml::from_str(&file)?;
    Ok(config)
}

use serde::Deserialize;

#[derive(Deserialize)]
struct Config {
    port: u16,
}
```

---

## 4. æ€§èƒ½åæ¨¡å¼

### 4.1 é¢‘ç¹å­—ç¬¦ä¸²æ‹¼æ¥

**é—®é¢˜**ï¼šä½¿ç”¨ `+` è¿ç®—ç¬¦é¢‘ç¹æ‹¼æ¥å­—ç¬¦ä¸²ã€‚

```rust
// âŒ åæ¨¡å¼ï¼šå¤šæ¬¡åˆ†é…
fn concat_inefficient(items: &[&str]) -> String {
    let mut result = String::new();
    for item in items {
        result = result + item; // æ¯æ¬¡åˆ›å»ºæ–°å­—ç¬¦ä¸²
    }
    result
}

// âœ… ä¼˜åŒ–ï¼šä½¿ç”¨ push_str
fn concat_efficient(items: &[&str]) -> String {
    let mut result = String::new();
    for item in items {
        result.push_str(item); // åŸåœ°ä¿®æ”¹
    }
    result
}

// âœ… æ›´ä¼˜ï¼šé¢„åˆ†é…å®¹é‡
fn concat_best(items: &[&str]) -> String {
    let total_len: usize = items.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(total_len);
    for item in items {
        result.push_str(item);
    }
    result
}

fn main() {
    let items = vec!["Hello", " ", "Rust", " ", "World"];
    println!("{}", concat_best(&items));
}
```

### 4.2 ä¸å¿…è¦çš„å†…å­˜åˆ†é…

```rust
// âŒ åæ¨¡å¼ï¼šæ¯æ¬¡è°ƒç”¨éƒ½åˆ†é…
fn sum_inefficient(data: &[i32]) -> i32 {
    let vec: Vec<i32> = data.iter().map(|&x| x * 2).collect();
    vec.iter().sum()
}

// âœ… ä¼˜åŒ–ï¼šç›´æ¥è®¡ç®—
fn sum_efficient(data: &[i32]) -> i32 {
    data.iter().map(|&x| x * 2).sum()
}
```

### 4.3 è¿‡åº¦ä½¿ç”¨ Box

```rust
// âŒ åæ¨¡å¼ï¼šä¸å¿…è¦çš„å †åˆ†é…
struct Point {
    x: Box<i32>,
    y: Box<i32>,
}

// âœ… æœ€ä½³å®è·µï¼šæ ˆåˆ†é…è¶³å¤Ÿ
struct Point2 {
    x: i32,
    y: i32,
}
```

**ä½•æ—¶ä½¿ç”¨ Box**ï¼š

- å¤§å‹æ•°æ®ç»“æ„
- é€’å½’ç±»å‹
- Trait object
- è¿è¡Œæ—¶å¤§å°æœªçŸ¥çš„ç±»å‹

---

## 5. ä»£ç å®¡æŸ¥æ¸…å•

### 5.1 è®¾è®¡åŸåˆ™æ£€æŸ¥

- [ ] **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªæ¨¡å—/å‡½æ•°åªåšä¸€ä»¶äº‹
- [ ] **å¼€é—­åŸåˆ™**ï¼šæ˜“äºæ‰©å±•ï¼Œæ— éœ€ä¿®æ”¹
- [ ] **é‡Œæ°æ›¿æ¢**ï¼šå­ç±»å‹å¯æ›¿æ¢çˆ¶ç±»å‹
- [ ] **æ¥å£éš”ç¦»**ï¼šé¿å…åºå¤§ trait
- [ ] **ä¾èµ–å€’ç½®**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“

### 5.2 Rust ç‰¹å®šæ£€æŸ¥

```rust
// âœ… æ£€æŸ¥é¡¹
// 1. é¿å…ä¸å¿…è¦çš„ clone()
// 2. ä½¿ç”¨å¼•ç”¨ä»£æ›¿æ‰€æœ‰æƒè½¬ç§»
// 3. é”™è¯¯å¤„ç†ç”¨ Result è€Œé panic
// 4. ä¼˜å…ˆä½¿ç”¨è¿­ä»£å™¨è€Œéå¾ªç¯
// 5. åˆç†ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
// 6. é¿å…è¿‡åº¦ä½¿ç”¨ unsafe

// ç¤ºä¾‹ï¼šä¼˜å…ˆä½¿ç”¨è¿­ä»£å™¨
fn process_items_good(items: &[i32]) -> Vec<i32> {
    items.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .collect()
}

// è€Œéæ‰‹åŠ¨å¾ªç¯
fn process_items_verbose(items: &[i32]) -> Vec<i32> {
    let mut result = Vec::new();
    for &item in items {
        if item > 0 {
            result.push(item * 2);
        }
    }
    result
}
```

### 5.3 æ€§èƒ½æ£€æŸ¥

- [ ] **é¢„åˆ†é…å®¹é‡**ï¼š`Vec::with_capacity`
- [ ] **é¿å…é¢‘ç¹å…‹éš†**ï¼šä½¿ç”¨å¼•ç”¨
- [ ] **é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„**ï¼š`HashMap` vs `BTreeMap`
- [ ] **è€ƒè™‘ç¼“å­˜å±€éƒ¨æ€§**ï¼š`Vec<Struct>` vs `Vec<Box<Struct>>`
- [ ] **ä½¿ç”¨å¹¶è¡Œè¿­ä»£å™¨**ï¼šCPU å¯†é›†å‹ä»»åŠ¡ç”¨ Rayon

---

## 6. é‡æ„æŠ€å·§

### 6.1 æå–å‡½æ•°

```rust
// âŒ é‡æ„å‰ï¼šå†—é•¿å‡½æ•°
fn process_user_data(data: &str) {
    // è§£æ JSON
    let parsed = serde_json::from_str::<serde_json::Value>(data).unwrap();
    
    // éªŒè¯æ•°æ®
    if !parsed["name"].is_string() {
        panic!("æ— æ•ˆåç§°");
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    println!("ä¿å­˜: {}", parsed["name"]);
}

// âœ… é‡æ„åï¼šèŒè´£æ¸…æ™°
fn parse_json(data: &str) -> Result<serde_json::Value, serde_json::Error> {
    serde_json::from_str(data)
}

fn validate_user(data: &serde_json::Value) -> Result<(), String> {
    if !data["name"].is_string() {
        return Err("æ— æ•ˆåç§°".to_string());
    }
    Ok(())
}

fn save_user(data: &serde_json::Value) {
    println!("ä¿å­˜: {}", data["name"]);
}

fn process_user_data_refactored(data: &str) -> Result<(), Box<dyn std::error::Error>> {
    let parsed = parse_json(data)?;
    validate_user(&parsed)?;
    save_user(&parsed);
    Ok(())
}
```

### 6.2 å¼•å…¥ç±»å‹åˆ«å

```rust
// âŒ é‡æ„å‰ï¼šç±»å‹é‡å¤
fn process(data: Vec<HashMap<String, Vec<i32>>>) -> Vec<HashMap<String, Vec<i32>>> {
    data
}

// âœ… é‡æ„åï¼šç±»å‹åˆ«å
use std::collections::HashMap;

type DataMap = HashMap<String, Vec<i32>>;
type DataCollection = Vec<DataMap>;

fn process_clean(data: DataCollection) -> DataCollection {
    data
}
```

### 6.3 ä½¿ç”¨ Builder ç®€åŒ–æ„é€ 

```rust
// âŒ é‡æ„å‰ï¼šå‚æ•°è¿‡å¤š
struct Config {
    host: String,
    port: u16,
    timeout: u64,
    retries: usize,
}

impl Config {
    fn new(host: String, port: u16, timeout: u64, retries: usize) -> Self {
        Self { host, port, timeout, retries }
    }
}

// âœ… é‡æ„åï¼šBuilder æ¨¡å¼
struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: u64,
    retries: usize,
}

impl ConfigBuilder {
    fn new() -> Self {
        Self {
            host: None,
            port: None,
            timeout: 30,
            retries: 3,
        }
    }

    fn host(mut self, host: impl Into<String>) -> Self {
        self.host = Some(host.into());
        self
    }

    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }

    fn build(self) -> Result<Config, String> {
        Ok(Config {
            host: self.host.ok_or("ç¼ºå°‘ host")?,
            port: self.port.ok_or("ç¼ºå°‘ port")?,
            timeout: self.timeout,
            retries: self.retries,
        })
    }
}

fn main() {
    let config = ConfigBuilder::new()
        .host("localhost")
        .port(8080)
        .timeout(60)
        .build()
        .unwrap();
    println!("é…ç½®: {}:{}", config.host, config.port);
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 7.1 æ¡ˆä¾‹ï¼šAPI å®¢æˆ·ç«¯è®¾è®¡

**éœ€æ±‚**ï¼šè®¾è®¡ä¸€ä¸ª HTTP API å®¢æˆ·ç«¯åº“ã€‚

```rust
use std::collections::HashMap;

// âœ… è‰¯å¥½è®¾è®¡
pub struct ApiClient {
    base_url: String,
    headers: HashMap<String, String>,
}

impl ApiClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self {
            base_url: base_url.into(),
            headers: HashMap::new(),
        }
    }

    pub fn with_header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.insert(key.into(), value.into());
        self
    }

    pub async fn get(&self, path: &str) -> Result<String, Box<dyn std::error::Error>> {
        let url = format!("{}{}", self.base_url, path);
        println!("GET {}", url);
        // å®é™…å®ç°ä½¿ç”¨ reqwest ç­‰åº“
        Ok("å“åº”æ•°æ®".to_string())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = ApiClient::new("https://api.example.com")
        .with_header("Authorization", "Bearer token")
        .with_header("User-Agent", "MyApp/1.0");

    let response = client.get("/users").await?;
    println!("å“åº”: {}", response);
    Ok(())
}
```

### 7.2 æ¡ˆä¾‹ï¼šæ’ä»¶ç³»ç»Ÿè®¾è®¡

```rust
use std::collections::HashMap;

// å®šä¹‰æ’ä»¶ trait
trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn execute(&self, input: &str) -> String;
}

// æ’ä»¶ç®¡ç†å™¨
struct PluginManager {
    plugins: HashMap<String, Box<dyn Plugin>>,
}

impl PluginManager {
    fn new() -> Self {
        Self {
            plugins: HashMap::new(),
        }
    }

    fn register(&mut self, plugin: Box<dyn Plugin>) {
        let name = plugin.name().to_string();
        self.plugins.insert(name, plugin);
    }

    fn execute(&self, plugin_name: &str, input: &str) -> Option<String> {
        self.plugins.get(plugin_name).map(|p| p.execute(input))
    }
}

// ç¤ºä¾‹æ’ä»¶
struct UpperCasePlugin;

impl Plugin for UpperCasePlugin {
    fn name(&self) -> &str {
        "uppercase"
    }

    fn execute(&self, input: &str) -> String {
        input.to_uppercase()
    }
}

fn main() {
    let mut manager = PluginManager::new();
    manager.register(Box::new(UpperCasePlugin));

    let result = manager.execute("uppercase", "hello").unwrap();
    println!("ç»“æœ: {}", result);
}
```

---

## 8. æ€»ç»“

### 8.1 æ ¸å¿ƒåŸåˆ™

1. **ç®€å•ä¼˜å…ˆ**ï¼šä¸è¿‡åº¦è®¾è®¡
2. **ç±»å‹å®‰å…¨**ï¼šåˆ©ç”¨ Rust ç±»å‹ç³»ç»Ÿ
3. **é›¶æˆæœ¬æŠ½è±¡**ï¼šæ€§èƒ½ä¸æŠ½è±¡å…¼å¾—
4. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨ Resultï¼Œé¿å… panic
5. **æ‰€æœ‰æƒä¼˜å…ˆ**ï¼šå‡å°‘ä¸å¿…è¦çš„å…‹éš†

### 8.2 åæ¨¡å¼é€ŸæŸ¥è¡¨

| åæ¨¡å¼ | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|-------|------|---------|
| **ä¸Šå¸å¯¹è±¡** | èŒè´£è¿‡å¤š | èŒè´£åˆ†ç¦» |
| **Deref æ»¥ç”¨** | éšå¼è¡Œä¸º | æ˜¾å¼æ–¹æ³• |
| **clone æ»¥ç”¨** | æ€§èƒ½ä¸‹é™ | ä½¿ç”¨å¼•ç”¨ |
| **unwrap æ»¥ç”¨** | æ˜“ panic | é”™è¯¯ä¼ æ’­ |
| **é¢‘ç¹åˆ†é…** | å†…å­˜å¼€é”€ | é¢„åˆ†é…/å¤ç”¨ |

### 8.3 è®¾è®¡æ£€æŸ¥æ¸…å•

- [ ] æ˜¯å¦éµå¾ª SOLID åŸåˆ™ï¼Ÿ
- [ ] æ˜¯å¦åˆç†ä½¿ç”¨ Rust ç±»å‹ç³»ç»Ÿï¼Ÿ
- [ ] é”™è¯¯å¤„ç†æ˜¯å¦å®Œå–„ï¼Ÿ
- [ ] æ˜¯å¦æœ‰ä¸å¿…è¦çš„ cloneï¼Ÿ
- [ ] æ˜¯å¦è€ƒè™‘äº†æ€§èƒ½ä¼˜åŒ–ï¼Ÿ
- [ ] ä»£ç æ˜¯å¦æ˜“äºæµ‹è¯•ï¼Ÿ

---

## ğŸ“š å‚è€ƒèµ„æº

- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [Effective Rust](https://www.lurklurk.org/effective-rust/)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)

---

**ğŸ‰ æ­å–œï¼** ä½ å·²å®Œæˆ C09 Design Pattern Tier 2 å…¨éƒ¨å®è·µæŒ‡å—çš„å­¦ä¹ ã€‚

**ä¸‹ä¸€æ­¥å»ºè®®**ï¼š

- æ·±å…¥å­¦ä¹  [Tier 3: æŠ€æœ¯å‚è€ƒ](../tier_03_references/README.md)
- æ¢ç´¢ [Tier 4: é«˜çº§ä¸»é¢˜](../tier_04_advanced/README.md)
- å®è·µåº”ç”¨åˆ°å®é™…é¡¹ç›®ä¸­
