# C09 设计模式 - 常见问题

> **文档类型**: Tier 1 - 基础层
> **文档定位**: 设计模式学习和实践中的常见问题快速解答，新手入门必备
> **项目状态**: ✅ 完整完成
> **相关文档**: [项目概览](./01_项目概览.md) | [主索引导航](./02_主索引导航.md) | [术语表](./03_术语表.md) | [完整FAQ](../FAQ.md)

**最后更新**: 2025-12-25
**适用版本**: Rust 1.92.0+ (Edition 2024)
**文档类型**: 📚 问题解答

---

## 📋 目录

- [C09 设计模式 - 常见问题](#c09-设计模式---常见问题)
  - [📋 目录](#-目录)
  - [📊 问题索引](#-问题索引)
  - [🎯 核心问题](#-核心问题)
    - [基础概念](#基础概念)
      - [Q1: 什么时候应该使用设计模式？](#q1-什么时候应该使用设计模式)
      - [Q2: Rust 中的设计模式与其他语言有什么不同？](#q2-rust-中的设计模式与其他语言有什么不同)
      - [Q3: 如何选择合适的设计模式？](#q3-如何选择合适的设计模式)
    - [模式选择](#模式选择)
      - [Q4: Rust 中如何实现线程安全的单例模式？](#q4-rust-中如何实现线程安全的单例模式)
      - [Q5: 建造者模式如何保证必填字段？](#q5-建造者模式如何保证必填字段)
    - [Rust 特性](#rust-特性)
      - [Q6: 观察者模式如何避免借用检查问题？](#q6-观察者模式如何避免借用检查问题)
      - [Q7: async/await vs 线程，如何选择？](#q7-asyncawait-vs-线程如何选择)
    - [实践问题](#实践问题)
      - [Q8: 如何在实际项目中应用设计模式？](#q8-如何在实际项目中应用设计模式)
  - [📚 完整FAQ](#-完整faq)
  - [🔗 相关资源](#-相关资源)
    - [内部文档](#内部文档)

---

## 📊 问题索引

**快速跳转**:

- [C09 设计模式 - 常见问题](#c09-设计模式---常见问题)
  - [📋 目录](#-目录)
  - [📊 问题索引](#-问题索引)
  - [🎯 核心问题](#-核心问题)
    - [基础概念](#基础概念)
      - [Q1: 什么时候应该使用设计模式？](#q1-什么时候应该使用设计模式)
      - [Q2: Rust 中的设计模式与其他语言有什么不同？](#q2-rust-中的设计模式与其他语言有什么不同)
      - [Q3: 如何选择合适的设计模式？](#q3-如何选择合适的设计模式)
    - [模式选择](#模式选择)
      - [Q4: Rust 中如何实现线程安全的单例模式？](#q4-rust-中如何实现线程安全的单例模式)
      - [Q5: 建造者模式如何保证必填字段？](#q5-建造者模式如何保证必填字段)
    - [Rust 特性](#rust-特性)
      - [Q6: 观察者模式如何避免借用检查问题？](#q6-观察者模式如何避免借用检查问题)
      - [Q7: async/await vs 线程，如何选择？](#q7-asyncawait-vs-线程如何选择)
    - [实践问题](#实践问题)
      - [Q8: 如何在实际项目中应用设计模式？](#q8-如何在实际项目中应用设计模式)
  - [📚 完整FAQ](#-完整faq)
  - [🔗 相关资源](#-相关资源)
    - [内部文档](#内部文档)

---

## 🎯 核心问题

### 基础概念

#### Q1: 什么时候应该使用设计模式？

**A**: 设计模式应该在遇到特定问题时有针对性地使用：

✅ **适合使用设计模式的场景**:

- 遇到重复出现的设计问题
- 需要提高代码的可维护性和可扩展性
- 团队协作需要统一的架构语言
- 需要解耦复杂的依赖关系

❌ **不适合使用设计模式的场景**:

- 过度设计简单功能
- 为了使用模式而使用模式
- 增加不必要的抽象层次
- 性能敏感且模式引入开销的场景

**决策树**:

```text
需要解决设计问题？
├─ 是 → 问题是否重复出现？
│   ├─ 是 → 是否有现成的模式？
│   │   ├─ 是 → 使用设计模式 ✅
│   │   └─ 否 → 考虑创建新模式
│   └─ 否 → 简单解决方案即可
└─ 否 → 不需要设计模式
```

**相关**: [完整FAQ](../FAQ.md#q1-什么时候应该使用设计模式) | [项目概览](./01_项目概览.md)

---

#### Q2: Rust 中的设计模式与其他语言有什么不同？

**A**: Rust 的设计模式实现有以下独特之处：

**1. 所有权系统**:

- 无需担心内存泄漏
- 借用检查器防止数据竞争
- 生命周期系统保证安全

**2. 零成本抽象**:

- 泛型单态化，无运行时开销
- Trait 对象可选，按需使用
- 编译时优化

**3. 类型级编程**:

- Typestate 模式编译时保证状态
- 类型系统防止错误
- 零运行时开销

**对比矩阵**:

| 特性     | Java/C++   | Rust                  |
| -------- | ---------- | --------------------- |
| 内存安全 | 手动管理   | 编译时保证 ✅         |
| 并发安全 | 需要锁     | Send/Sync 自动推导 ✅ |
| 性能开销 | 虚函数表   | 零成本抽象 ✅         |
| 状态保证 | 运行时检查 | 编译时检查 ✅         |

**相关**: [完整FAQ](../FAQ.md#q2-rust-中的设计模式与其他语言有什么不同) | [术语表](./03_术语表.md)

---

#### Q3: 如何选择合适的设计模式？

**A**: 根据问题类型和需求选择：

**决策树**:

```text
需要解决的问题类型？
├─ 对象创建问题
│   ├─ 需要全局唯一实例 → Singleton
│   ├─ 需要封装创建逻辑 → Factory
│   ├─ 需要复杂对象构建 → Builder (Typestate)
│   └─ 需要对象克隆 → Prototype
├─ 对象结构问题
│   ├─ 接口不兼容 → Adapter
│   ├─ 需要动态添加功能 → Decorator
│   ├─ 需要控制访问 → Proxy
│   └─ 需要简化接口 → Facade
└─ 对象行为问题
    ├─ 需要事件通知 → Observer
    ├─ 需要算法切换 → Strategy
    ├─ 需要状态管理 → State (Typestate)
    └─ 需要请求封装 → Command
```

**选择矩阵**:

| 问题         | 推荐模式  | 原因                 |
| ------------ | --------- | -------------------- |
| 全局配置     | Singleton | 唯一实例             |
| 复杂对象构建 | Builder   | 类型安全构建         |
| 接口不兼容   | Adapter   | 接口转换             |
| 动态功能扩展 | Decorator | 零成本包装           |
| 算法切换     | Strategy  | 编译时/运行时多态    |
| 事件通知     | Observer  | 一对多依赖           |
| 状态管理     | State     | Typestate 编译时保证 |

**相关**: [完整FAQ](../FAQ.md#q3-如何选择合适的设计模式) | [主索引导航](./02_主索引导航.md)

---

### 模式选择

#### Q4: Rust 中如何实现线程安全的单例模式？

**A**: 使用 `OnceLock` (Rust 1.92.0+):

**推荐实现**:

```rust
use std::sync::OnceLock;

struct Config {
    value: String,
}

static CONFIG: OnceLock<Config> = OnceLock::new();

fn get_config() -> &'static Config {
    CONFIG.get_or_init(|| {
        Config {
            value: "default".to_string(),
        }
    })
}
```

**特点**:

- ✅ 线程安全
- ✅ 延迟初始化
- ✅ 标准库支持，无需外部依赖
- ✅ 零运行时开销（初始化后）

**vs lazy_static**: `OnceLock` 是标准库类型，更推荐使用

**相关**: [完整FAQ](../FAQ.md#q4-rust-中如何实现线程安全的单例模式) | [术语表](./03_术语表.md#oncelock)

---

#### Q5: 建造者模式如何保证必填字段？

**A**: 使用 Typestate 模式在编译时保证：

**Typestate 实现**:

```rust
struct RequestBuilder<State = NoUrl> {
    url: Option<String>,
    _state: std::marker::PhantomData<State>,
}

struct NoUrl;
struct HasUrl;

impl RequestBuilder<NoUrl> {
    fn new() -> Self {
        Self {
            url: None,
            _state: std::marker::PhantomData,
        }
    }

    fn url(self, url: String) -> RequestBuilder<HasUrl> {
        RequestBuilder {
            url: Some(url),
            _state: std::marker::PhantomData,
        }
    }
}

impl RequestBuilder<HasUrl> {
    fn build(self) -> Request {
        Request {
            url: self.url.unwrap(),
        }
    }
}

// 使用：编译时保证必须设置 URL
let request = RequestBuilder::new()
    .url("https://example.com".to_string())
    .build(); // ✅ 类型安全
```

**优势**:

- ✅ 编译时验证
- ✅ 零运行时开销
- ✅ 防止非法状态

**相关**: [完整FAQ](../FAQ.md#q5-建造者模式如何保证必填字段) | [术语表](./03_术语表.md#typestate-模式)

---

### Rust 特性

#### Q6: 观察者模式如何避免借用检查问题？

**A**: 使用 Channel 或 GATs 借用视图：

**方法1: Channel (推荐)**:

```rust
use std::sync::mpsc;

struct Subject {
    observers: Vec<mpsc::Sender<Event>>,
}

impl Subject {
    fn notify(&self, event: Event) {
        for observer in &self.observers {
            let _ = observer.send(event.clone());
        }
    }
}
```

**方法2: GATs 借用视图**:

```rust
trait Observer {
    type View<'a>: 'a where Self: 'a;
    fn update(&self, data: Self::View<'_>);
}
```

**对比**:

| 方法    | 优点             | 缺点         |
| ------- | ---------------- | ------------ |
| Channel | 简单、解耦       | 需要克隆数据 |
| GATs    | 零拷贝、类型安全 | 复杂度较高   |

**相关**: [完整FAQ](../FAQ.md#q8-观察者模式如何避免借用检查问题) | [术语表](./03_术语表.md#gats-generic-associated-types)

---

#### Q7: async/await vs 线程，如何选择？

**A**: 根据场景选择：

**决策树**:

```text
需要并发处理？
├─ CPU 密集型任务 → 线程 ✅
│   └─ 使用 rayon 或 threadpool
├─ I/O 密集型任务 → async/await ✅
│   └─ 使用 tokio 或 async-std
└─ 混合场景
    ├─ 主要 I/O → async/await
    └─ 主要 CPU → 线程
```

**对比矩阵**:

| 特性       | 线程             | async/await  |
| ---------- | ---------------- | ------------ |
| CPU 密集型 | ✅ 适合          | ❌ 不适合    |
| I/O 密集型 | ⚠️ 资源浪费      | ✅ 高效      |
| 内存开销   | 较高（每线程栈） | 较低（协程） |
| 上下文切换 | 操作系统调度     | 用户态调度   |
| 适用场景   | 并行计算         | 异步 I/O     |

**相关**: [完整FAQ](../FAQ.md#q10-asyncawait-vs-线程如何选择) | [术语表](./03_术语表.md#asyncawait)

---

### 实践问题

#### Q8: 如何在实际项目中应用设计模式？

**A**: 遵循渐进式原则：

**步骤1: 识别问题**:

- 重复代码模式
- 紧耦合的组件
- 难以扩展的结构

**步骤2: 选择模式**:

- 参考决策树（Q3）
- 考虑性能约束
- 评估团队熟悉度

**步骤3: 小步重构**:

- 从局部开始
- 编写测试保护
- 渐进式改进

**步骤4: 验证效果**:

- 代码可读性
- 可维护性
- 性能基准

**反模式警告**:

- ❌ 过度工程化
- ❌ 为了模式而模式
- ❌ 忽略简单解决方案

**相关**: [完整FAQ](../FAQ.md#q16-如何在实际项目中应用设计模式) | [项目概览](./01_项目概览.md)

---

## 📚 完整FAQ

本文档提供了核心问题的快速参考。如需查看完整的FAQ（包含更多问题、详细解答、代码示例等），请参阅：

- **[完整FAQ](../FAQ.md)** - 包含 17+ 个常见问题的详细解答

**完整FAQ包含**:

- ✅ 基础概念（本文档已覆盖）
- ✅ 创建型模式（Q4-Q5）
- ✅ 结构型模式（适配器 vs 桥接、装饰器 vs 代理）
- ✅ 行为型模式（观察者、状态 vs 策略）
- ✅ 并发与异步（async/await、Actor vs Reactor、异步递归）
- ✅ 性能优化（性能影响、性能测量）
- ✅ Rust特性（Rust 1.92.0 新特性）
- ✅ 实践问题（项目应用、团队统一）

---

## 🔗 相关资源

### 内部文档

**Tier 1 基础**:

- [项目概览](./01_项目概览.md) - 模块介绍、学习路径
- [主索引导航](./02_主索引导航.md) - 完整导航系统
- [术语表](./03_术语表.md) - 核心术语参考

**核心资源**:

- [完整FAQ](../FAQ.md) - 所有问题详细解答
- [综合指南](../COMPREHENSIVE_DESIGN_PATTERNS_GUIDE.md) - 完整模式指南
- [实战示例集](../RUST_190_EXAMPLES_COLLECTION.md) - 800+行代码示例

**深度理论**:

- [形式化理论体系](../tier_04_advanced/) - 高级主题
- [Actor/Reactor模式](../ACTOR_REACTOR_PATTERNS.md) - 并发模式深入
- [CSP vs Async](../CSP_VS_ASYNC_ANALYSIS.md) - 并发模型对比

---

**下一步**: 阅读 [主索引导航](./02_主索引导航.md) 规划学习路径，或查看 [完整FAQ](../FAQ.md) 获取更多解答！

---

**文档维护**: Documentation Team
**创建日期**: 2025-12-25
**最后更新**: 2025-12-25
**适用版本**: Rust 1.92.0+
**文档状态**: ✅ 活跃维护
