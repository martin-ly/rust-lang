# å…ƒç¼–ç¨‹ä¸ç”Ÿæˆå¼æ¨¡å¼

> **æ–‡æ¡£å®šä½**: Tier 4 é«˜çº§ä¸»é¢˜  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [å…ƒç¼–ç¨‹ä¸ç”Ÿæˆå¼æ¨¡å¼](#å…ƒç¼–ç¨‹ä¸ç”Ÿæˆå¼æ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å£°æ˜å® (Declarative Macros)](#2-å£°æ˜å®-declarative-macros)
    - [2.1 Factory æ¨¡å¼ç”Ÿæˆ](#21-factory-æ¨¡å¼ç”Ÿæˆ)
    - [2.2 Builder æ¨¡å¼ç”Ÿæˆ](#22-builder-æ¨¡å¼ç”Ÿæˆ)
  - [3. è¿‡ç¨‹å® (Procedural Macros)](#3-è¿‡ç¨‹å®-procedural-macros)
    - [3.1 Derive å®: Builder æ¨¡å¼](#31-derive-å®-builder-æ¨¡å¼)
    - [3.2 å±æ€§å®: Singleton æ¨¡å¼](#32-å±æ€§å®-singleton-æ¨¡å¼)
  - [4. ä»£ç ç”Ÿæˆæ¨¡å¼](#4-ä»£ç ç”Ÿæˆæ¨¡å¼)
    - [4.1 ä½¿ç”¨ build.rs ç”Ÿæˆä»£ç ](#41-ä½¿ç”¨-buildrs-ç”Ÿæˆä»£ç )
  - [5. å…ƒç¼–ç¨‹æœ€ä½³å®è·µ](#5-å…ƒç¼–ç¨‹æœ€ä½³å®è·µ)
    - [5.1 ä½•æ—¶ä½¿ç”¨å…ƒç¼–ç¨‹](#51-ä½•æ—¶ä½¿ç”¨å…ƒç¼–ç¨‹)
    - [5.2 é¿å…è¿‡åº¦å…ƒç¼–ç¨‹](#52-é¿å…è¿‡åº¦å…ƒç¼–ç¨‹)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

å…ƒç¼–ç¨‹å…è®¸ç¨‹åºç”Ÿæˆæˆ–ä¿®æ”¹ä»£ç ã€‚Rust æä¾›äº†å¼ºå¤§çš„å®ç³»ç»Ÿï¼Œå¯ç”¨äºå®ç°é«˜çº§è®¾è®¡æ¨¡å¼ã€‚

---

## 2. å£°æ˜å® (Declarative Macros)

### 2.1 Factory æ¨¡å¼ç”Ÿæˆ

```rust
/// å®: è‡ªåŠ¨ç”Ÿæˆå·¥å‚æ–¹æ³•
macro_rules! define_factory {
    ($factory:ident, $product:ident { $($variant:ident),+ }) => {
        pub enum $product {
            $($variant($variant)),+
        }
        
        pub struct $factory;
        
        impl $factory {
            $(
                pub fn $variant() -> $product {
                    $product::$variant($variant)
                }
            )+
        }
        
        $(
            pub struct $variant;
        )+
    };
}

// ä½¿ç”¨å®ç”Ÿæˆå·¥å‚
define_factory!(VehicleFactory, Vehicle { Car, Motorcycle, Truck });

// ç”Ÿæˆçš„ä»£ç ç­‰ä»·äº:
// pub enum Vehicle {
//     Car(Car),
//     Motorcycle(Motorcycle),
//     Truck(Truck),
// }
// 
// pub struct VehicleFactory;
// impl VehicleFactory {
//     pub fn Car() -> Vehicle { Vehicle::Car(Car) }
//     pub fn Motorcycle() -> Vehicle { Vehicle::Motorcycle(Motorcycle) }
//     pub fn Truck() -> Vehicle { Vehicle::Truck(Truck) }
// }
```

### 2.2 Builder æ¨¡å¼ç”Ÿæˆ

```rust
/// å®: è‡ªåŠ¨ç”Ÿæˆ Builder
macro_rules! builder {
    (
        $name:ident {
            $($field:ident: $ty:ty),+
        }
    ) => {
        paste::paste! {
            pub struct [<$name Builder>] {
                $($field: Option<$ty>),+
            }
            
            impl [<$name Builder>] {
                pub fn new() -> Self {
                    Self {
                        $($field: None),+
                    }
                }
                
                $(
                    pub fn $field(mut self, value: $ty) -> Self {
                        self.$field = Some(value);
                        self
                    }
                )+
                
                pub fn build(self) -> Result<$name, String> {
                    Ok($name {
                        $($field: self.$field.ok_or(concat!("Missing field: ", stringify!($field)))?),+
                    })
                }
            }
        }
    };
}

// å®šä¹‰ç»“æ„ä½“
pub struct HttpRequest {
    pub url: String,
    pub method: String,
}

// ç”Ÿæˆ Builder
builder!(HttpRequest {
    url: String,
    method: String
});

// ä½¿ç”¨
pub fn builder_example() {
    let request = HttpRequestBuilder::new()
        .url("https://api.example.com".to_string())
        .method("POST".to_string())
        .build()
        .unwrap();
}
```

---

## 3. è¿‡ç¨‹å® (Procedural Macros)

### 3.1 Derive å®: Builder æ¨¡å¼

```rust
// ============ è¿‡ç¨‹å®å®ç° (lib.rs) ============
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let builder_name = format_ident!("{}Builder", name);
    
    let fields = if let syn::Data::Struct(data) = &input.data {
        if let syn::Fields::Named(fields) = &data.fields {
            &fields.named
        } else {
            panic!("Builderåªæ”¯æŒå‘½åå­—æ®µ");
        }
    } else {
        panic!("Builderåªæ”¯æŒç»“æ„ä½“");
    };
    
    let field_names: Vec<_> = fields.iter().map(|f| &f.ident).collect();
    let field_types: Vec<_> = fields.iter().map(|f| &f.ty).collect();
    
    let expanded = quote! {
        pub struct #builder_name {
            #(#field_names: Option<#field_types>),*
        }
        
        impl #builder_name {
            pub fn new() -> Self {
                Self {
                    #(#field_names: None),*
                }
            }
            
            #(
                pub fn #field_names(mut self, value: #field_types) -> Self {
                    self.#field_names = Some(value);
                    self
                }
            )*
            
            pub fn build(self) -> Result<#name, String> {
                Ok(#name {
                    #(#field_names: self.#field_names.ok_or(stringify!(#field_names))?),*
                })
            }
        }
        
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name::new()
            }
        }
    };
    
    TokenStream::from(expanded)
}

// ============ ä½¿ç”¨ (main.rs) ============
#[derive(Builder)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

pub fn derive_builder_example() {
    let user = User::builder()
        .id(1)
        .name("Alice".to_string())
        .email("alice@example.com".to_string())
        .build()
        .unwrap();
}
```

### 3.2 å±æ€§å®: Singleton æ¨¡å¼

```rust
// ============ è¿‡ç¨‹å®å®ç° ============
#[proc_macro_attribute]
pub fn singleton(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    let name = &input.ident;
    let vis = &input.vis;
    
    let expanded = quote! {
        #input
        
        impl #name {
            #vis fn instance() -> &'static Self {
                use std::sync::OnceLock;
                static INSTANCE: OnceLock<#name> = OnceLock::new();
                INSTANCE.get_or_init(|| #name::new())
            }
        }
    };
    
    TokenStream::from(expanded)
}

// ============ ä½¿ç”¨ ============
#[singleton]
pub struct Config {
    pub max_connections: usize,
}

impl Config {
    fn new() -> Self {
        Self { max_connections: 100 }
    }
}

pub fn singleton_example() {
    let config = Config::instance();
    println!("Max connections: {}", config.max_connections);
}
```

---

## 4. ä»£ç ç”Ÿæˆæ¨¡å¼

### 4.1 ä½¿ç”¨ build.rs ç”Ÿæˆä»£ç 

```rust
// ============ build.rs ============
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated.rs");
    let mut f = File::create(&dest_path).unwrap();
    
    // ç”Ÿæˆ Factory ä»£ç 
    writeln!(f, "pub enum Vehicle {{").unwrap();
    for vehicle in &["Car", "Motorcycle", "Truck"] {
        writeln!(f, "    {},", vehicle).unwrap();
    }
    writeln!(f, "}}").unwrap();
    
    writeln!(f, "pub struct VehicleFactory;").unwrap();
    writeln!(f, "impl VehicleFactory {{").unwrap();
    for vehicle in &["Car", "Motorcycle", "Truck"] {
        writeln!(f, "    pub fn create_{}() -> Vehicle {{", vehicle.to_lowercase()).unwrap();
        writeln!(f, "        Vehicle::{}", vehicle).unwrap();
        writeln!(f, "    }}").unwrap();
    }
    writeln!(f, "}}").unwrap();
}

// ============ ä½¿ç”¨ (lib.rs) ============
include!(concat!(env!("OUT_DIR"), "/generated.rs"));

pub fn codegen_example() {
    let car = VehicleFactory::create_car();
}
```

---

## 5. å…ƒç¼–ç¨‹æœ€ä½³å®è·µ

### 5.1 ä½•æ—¶ä½¿ç”¨å…ƒç¼–ç¨‹

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|---------|------|
| **å‡å°‘é‡å¤ä»£ç ** | å£°æ˜å® | ç®€å•ç›´æ¥ |
| **è‡ªåŠ¨deriveå®ç°** | è¿‡ç¨‹å® (derive) | ç±»å‹å®‰å…¨ |
| **ä»£ç æ³¨è§£** | è¿‡ç¨‹å® (attribute) | è¯­æ³•è‡ªç„¶ |
| **å¤–éƒ¨é…ç½®ç”Ÿæˆä»£ç ** | build.rs | ç¼–è¯‘æ—¶ç”Ÿæˆ |

### 5.2 é¿å…è¿‡åº¦å…ƒç¼–ç¨‹

```rust
// âŒ è¿‡åº¦å¤æ‚çš„å®
macro_rules! complex_macro {
    // 100+ è¡Œå®å®šä¹‰
}

// âœ… ç®€å•æ¸…æ™°çš„å‡½æ•°
pub fn simple_function() {
    // æ™®é€šä»£ç æ›´æ˜“ç»´æŠ¤
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- **Rustå®ä¹¦**: [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- **è¿‡ç¨‹å®æ•™ç¨‹**: [proc-macro-workshop](https://github.com/dtolnay/proc-macro-workshop)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-23
