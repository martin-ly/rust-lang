# æ¶æ„æ¨¡å¼æ¼”è¿›

> **æ–‡æ¡£å®šä½**: Tier 4 é«˜çº§ä¸»é¢˜  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [æ¶æ„æ¨¡å¼æ¼”è¿›](#æ¶æ„æ¨¡å¼æ¼”è¿›)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. åˆ†å±‚æ¶æ„](#2-åˆ†å±‚æ¶æ„)
    - [2.1 å››å±‚æ¶æ„](#21-å››å±‚æ¶æ„)
  - [3. å¾®æœåŠ¡æ¶æ„](#3-å¾®æœåŠ¡æ¶æ„)
    - [3.1 æœåŠ¡æ‹†åˆ†ç­–ç•¥](#31-æœåŠ¡æ‹†åˆ†ç­–ç•¥)
  - [4. äº‹ä»¶é©±åŠ¨æ¶æ„](#4-äº‹ä»¶é©±åŠ¨æ¶æ„)
    - [4.1 äº‹ä»¶æ€»çº¿](#41-äº‹ä»¶æ€»çº¿)
  - [5. CQRS \& Event Sourcing](#5-cqrs--event-sourcing)
    - [5.1 CQRS (Command Query Responsibility Segregation)](#51-cqrs-command-query-responsibility-segregation)
    - [5.2 Event Sourcing](#52-event-sourcing)
  - [6. Hexagonal Architecture](#6-hexagonal-architecture)
    - [6.1 ç«¯å£ä¸é€‚é…å™¨](#61-ç«¯å£ä¸é€‚é…å™¨)
  - [7. æ¶æ„æ¨¡å¼å¯¹æ¯”](#7-æ¶æ„æ¨¡å¼å¯¹æ¯”)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

æ¶æ„æ¨¡å¼å®šä¹‰äº†ç³»ç»Ÿçº§çš„ç»„ç»‡ç»“æ„ã€‚æœ¬æ–‡æ¡£æ¢è®¨ä»å•ä½“åˆ°åˆ†å¸ƒå¼çš„æ¶æ„æ¼”è¿›ï¼ŒåŠå…¶åœ¨Rustä¸­çš„å®ç°ã€‚

---

## 2. åˆ†å±‚æ¶æ„

### 2.1 å››å±‚æ¶æ„

**æ¶æ„å›¾**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation Layer (API)      â”‚  â† HTTP/gRPC endpoints
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Application Layer (Service)   â”‚  â† Business logic
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Domain Layer (Model)          â”‚  â† Core entities
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Infrastructure Layer (Repo)   â”‚  â† Database/External
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Rustå®ç°**:

```rust
// ============ Domain Layer ============
pub mod domain {
    #[derive(Debug, Clone)]
    pub struct User {
        pub id: u64,
        pub name: String,
        pub email: String,
    }
    
    pub trait UserRepository: Send + Sync {
        async fn find_by_id(&self, id: u64) -> Option<User>;
        async fn save(&self, user: User) -> Result<(), String>;
    }
}

// ============ Infrastructure Layer ============
pub mod infrastructure {
    use super::domain::{User, UserRepository};
    use std::collections::HashMap;
    use tokio::sync::RwLock;
    
    pub struct PostgresUserRepository {
        users: RwLock<HashMap<u64, User>>,
    }
    
    impl PostgresUserRepository {
        pub fn new() -> Self {
            Self {
                users: RwLock::new(HashMap::new()),
            }
        }
    }
    
    #[async_trait::async_trait]
    impl UserRepository for PostgresUserRepository {
        async fn find_by_id(&self, id: u64) -> Option<User> {
            self.users.read().await.get(&id).cloned()
        }
        
        async fn save(&self, user: User) -> Result<(), String> {
            self.users.write().await.insert(user.id, user);
            Ok(())
        }
    }
}

// ============ Application Layer ============
pub mod application {
    use super::domain::{User, UserRepository};
    use std::sync::Arc;
    
    pub struct UserService {
        repository: Arc<dyn UserRepository>,
    }
    
    impl UserService {
        pub fn new(repository: Arc<dyn UserRepository>) -> Self {
            Self { repository }
        }
        
        pub async fn register_user(&self, name: String, email: String) -> Result<User, String> {
            let user = User {
                id: rand::random(),
                name,
                email,
            };
            
            self.repository.save(user.clone()).await?;
            Ok(user)
        }
        
        pub async fn get_user(&self, id: u64) -> Option<User> {
            self.repository.find_by_id(id).await
        }
    }
}

// ============ Presentation Layer ============
pub mod presentation {
    use super::application::UserService;
    use axum::{Router, routing::post, Json, Extension};
    use std::sync::Arc;
    
    pub async fn register_handler(
        Extension(service): Extension<Arc<UserService>>,
        Json(req): Json<RegisterRequest>,
    ) -> Json<User> {
        let user = service.register_user(req.name, req.email).await.unwrap();
        Json(user)
    }
    
    pub fn create_router(service: Arc<UserService>) -> Router {
        Router::new()
            .route("/users", post(register_handler))
            .layer(Extension(service))
    }
    
    #[derive(serde::Deserialize)]
    pub struct RegisterRequest {
        pub name: String,
        pub email: String,
    }
}
```

---

## 3. å¾®æœåŠ¡æ¶æ„

### 3.1 æœåŠ¡æ‹†åˆ†ç­–ç•¥

```rust
/// æœåŠ¡å‘ç°æ¥å£
pub trait ServiceDiscovery: Send + Sync {
    async fn register(&self, service: ServiceInfo) -> Result<(), String>;
    async fn discover(&self, service_name: &str) -> Option<ServiceInfo>;
}

#[derive(Debug, Clone)]
pub struct ServiceInfo {
    pub name: String,
    pub host: String,
    pub port: u16,
}

/// ç”¨æˆ·æœåŠ¡
pub struct UserMicroservice {
    discovery: Arc<dyn ServiceDiscovery>,
}

impl UserMicroservice {
    pub async fn start(self) -> Result<(), Box<dyn std::error::Error>> {
        // æ³¨å†ŒæœåŠ¡
        self.discovery.register(ServiceInfo {
            name: "user-service".to_string(),
            host: "localhost".to_string(),
            port: 8001,
        }).await?;
        
        // å¯åŠ¨ HTTP æœåŠ¡å™¨
        // ...
        
        Ok(())
    }
}

/// è®¢å•æœåŠ¡ï¼ˆè°ƒç”¨ç”¨æˆ·æœåŠ¡ï¼‰
pub struct OrderMicroservice {
    discovery: Arc<dyn ServiceDiscovery>,
}

impl OrderMicroservice {
    pub async fn create_order(&self, user_id: u64) -> Result<Order, String> {
        // æœåŠ¡å‘ç°
        let user_service = self.discovery
            .discover("user-service")
            .await
            .ok_or("User service not found")?;
        
        // è°ƒç”¨ç”¨æˆ·æœåŠ¡
        let user = self.call_user_service(&user_service, user_id).await?;
        
        Ok(Order {
            id: rand::random(),
            user_id: user.id,
        })
    }
    
    async fn call_user_service(&self, service: &ServiceInfo, user_id: u64) -> Result<User, String> {
        // HTTP è°ƒç”¨
        Ok(User { id: user_id, name: "Test".to_string(), email: "test@example.com".to_string() })
    }
}

#[derive(Debug)]
pub struct Order {
    id: u64,
    user_id: u64,
}
```

---

## 4. äº‹ä»¶é©±åŠ¨æ¶æ„

### 4.1 äº‹ä»¶æ€»çº¿

```rust
use tokio::sync::broadcast;
use serde::{Serialize, Deserialize};

/// é¢†åŸŸäº‹ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DomainEvent {
    UserRegistered { user_id: u64, email: String },
    OrderCreated { order_id: u64, user_id: u64 },
    PaymentProcessed { order_id: u64, amount: f64 },
}

/// äº‹ä»¶æ€»çº¿
pub struct EventBus {
    sender: broadcast::Sender<DomainEvent>,
}

impl EventBus {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(1000);
        Self { sender }
    }
    
    pub fn publish(&self, event: DomainEvent) {
        let _ = self.sender.send(event);
    }
    
    pub fn subscribe(&self) -> broadcast::Receiver<DomainEvent> {
        self.sender.subscribe()
    }
}

/// äº‹ä»¶å¤„ç†å™¨
pub struct EmailNotificationHandler {
    event_bus: Arc<EventBus>,
}

impl EmailNotificationHandler {
    pub async fn start(self) {
        let mut receiver = self.event_bus.subscribe();
        
        tokio::spawn(async move {
            while let Ok(event) = receiver.recv().await {
                match event {
                    DomainEvent::UserRegistered { email, .. } => {
                        println!("[Email] Welcome email sent to {}", email);
                    }
                    DomainEvent::OrderCreated { order_id, .. } => {
                        println!("[Email] Order confirmation sent for order {}", order_id);
                    }
                    _ => {}
                }
            }
        });
    }
}
```

---

## 5. CQRS & Event Sourcing

### 5.1 CQRS (Command Query Responsibility Segregation)

```rust
/// å‘½ä»¤æ¥å£ï¼ˆå†™æ“ä½œï¼‰
pub trait Command {
    type Result;
    async fn execute(&self) -> Self::Result;
}

/// æŸ¥è¯¢æ¥å£ï¼ˆè¯»æ“ä½œï¼‰
pub trait Query {
    type Result;
    async fn execute(&self) -> Self::Result;
}

/// å‘½ä»¤: åˆ›å»ºç”¨æˆ·
pub struct CreateUserCommand {
    pub name: String,
    pub email: String,
}

#[async_trait::async_trait]
impl Command for CreateUserCommand {
    type Result = Result<User, String>;
    
    async fn execute(&self) -> Self::Result {
        // å†™å…¥æ•°æ®åº“
        let user = User {
            id: rand::random(),
            name: self.name.clone(),
            email: self.email.clone(),
        };
        
        // å‘å¸ƒäº‹ä»¶
        // event_bus.publish(DomainEvent::UserRegistered { ... });
        
        Ok(user)
    }
}

/// æŸ¥è¯¢: è·å–ç”¨æˆ·åˆ—è¡¨
pub struct GetUsersQuery {
    pub limit: usize,
}

#[async_trait::async_trait]
impl Query for GetUsersQuery {
    type Result = Vec<User>;
    
    async fn execute(&self) -> Self::Result {
        // ä»åªè¯»æ•°æ®åº“æŸ¥è¯¢
        vec![]
    }
}
```

### 5.2 Event Sourcing

```rust
/// äº‹ä»¶å­˜å‚¨
pub trait EventStore: Send + Sync {
    async fn append(&self, stream_id: &str, event: DomainEvent) -> Result<(), String>;
    async fn read(&self, stream_id: &str) -> Vec<DomainEvent>;
}

/// èšåˆæ ¹
pub struct UserAggregate {
    pub id: u64,
    pub name: String,
    pub email: String,
    pub version: usize,
}

impl UserAggregate {
    /// ä»äº‹ä»¶æµé‡å»ºçŠ¶æ€
    pub fn from_events(events: Vec<DomainEvent>) -> Self {
        let mut aggregate = Self {
            id: 0,
            name: String::new(),
            email: String::new(),
            version: 0,
        };
        
        for event in events {
            aggregate.apply(event);
        }
        
        aggregate
    }
    
    /// åº”ç”¨äº‹ä»¶
    fn apply(&mut self, event: DomainEvent) {
        match event {
            DomainEvent::UserRegistered { user_id, email } => {
                self.id = user_id;
                self.email = email;
                self.version += 1;
            }
            _ => {}
        }
    }
}
```

---

## 6. Hexagonal Architecture

### 6.1 ç«¯å£ä¸é€‚é…å™¨

```rust
// ============ Domain Core (å†…æ ¸) ============
pub mod domain {
    /// ç«¯å£: ç”¨æˆ·å­˜å‚¨æ¥å£
    pub trait UserPort: Send + Sync {
        async fn save(&self, user: User) -> Result<(), String>;
    }
    
    pub struct User {
        pub id: u64,
        pub name: String,
    }
    
    /// ç”¨ä¾‹: æ³¨å†Œç”¨æˆ·
    pub struct RegisterUserUseCase<P: UserPort> {
        port: P,
    }
    
    impl<P: UserPort> RegisterUserUseCase<P> {
        pub fn new(port: P) -> Self {
            Self { port }
        }
        
        pub async fn execute(&self, name: String) -> Result<User, String> {
            let user = User {
                id: rand::random(),
                name,
            };
            
            self.port.save(user.clone()).await?;
            Ok(user)
        }
    }
}

// ============ Adapters (é€‚é…å™¨) ============
pub mod adapters {
    use super::domain::*;
    
    /// é€‚é…å™¨: PostgreSQL
    pub struct PostgresAdapter;
    
    #[async_trait::async_trait]
    impl UserPort for PostgresAdapter {
        async fn save(&self, user: User) -> Result<(), String> {
            println!("[Postgres] Saving user: {}", user.name);
            Ok(())
        }
    }
    
    /// é€‚é…å™¨: In-Memory
    pub struct InMemoryAdapter {
        users: tokio::sync::RwLock<Vec<User>>,
    }
    
    #[async_trait::async_trait]
    impl UserPort for InMemoryAdapter {
        async fn save(&self, user: User) -> Result<(), String> {
            self.users.write().await.push(user);
            Ok(())
        }
    }
}
```

---

## 7. æ¶æ„æ¨¡å¼å¯¹æ¯”

| æ¶æ„æ¨¡å¼ | å¤æ‚åº¦ | å¯æ‰©å±•æ€§ | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|---------|--------|---------|------|---------|
| **åˆ†å±‚æ¶æ„** | â­â­ | â­â­â­ | â­â­â­â­ | ä¸­å°å‹å•ä½“åº”ç”¨ |
| **å¾®æœåŠ¡** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­ | å¤§å‹åˆ†å¸ƒå¼ç³»ç»Ÿ |
| **äº‹ä»¶é©±åŠ¨** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | é«˜å¹¶å‘ã€å¼‚æ­¥åœºæ™¯ |
| **CQRS** | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | è¯»å†™åˆ†ç¦»åœºæ™¯ |
| **Hexagonal** | â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | é«˜å¯æµ‹è¯•æ€§éœ€æ±‚ |

---

## ğŸ“š ç›¸å…³èµ„æº

- **Tier 3**: [æŠ€æœ¯å‚è€ƒ](../tier_03_references/)
- **Tier 4-01**: [å½¢å¼åŒ–ç†è®º](./01_å½¢å¼åŒ–è®¾è®¡æ¨¡å¼ç†è®º.md)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-23
