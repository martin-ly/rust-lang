# å·¥ç¨‹å®è·µä¸ç”Ÿäº§çº§æ¨¡å¼

> **æ–‡æ¡£å®šä½**: Tier 4 é«˜çº§ä¸»é¢˜  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [å·¥ç¨‹å®è·µä¸ç”Ÿäº§çº§æ¨¡å¼](#å·¥ç¨‹å®è·µä¸ç”Ÿäº§çº§æ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å¯è§‚æµ‹æ€§æ¨¡å¼](#2-å¯è§‚æµ‹æ€§æ¨¡å¼)
    - [2.1 ç»“æ„åŒ–æ—¥å¿—](#21-ç»“æ„åŒ–æ—¥å¿—)
    - [2.2 Metricsæ”¶é›†](#22-metricsæ”¶é›†)
    - [2.3 åˆ†å¸ƒå¼è¿½è¸ª](#23-åˆ†å¸ƒå¼è¿½è¸ª)
  - [3. å¼¹æ€§æ¨¡å¼](#3-å¼¹æ€§æ¨¡å¼)
    - [3.1 Circuit Breaker (æ–­è·¯å™¨)](#31-circuit-breaker-æ–­è·¯å™¨)
    - [3.2 Retry Pattern (é‡è¯•)](#32-retry-pattern-é‡è¯•)
  - [4. æ€§èƒ½ä¼˜åŒ–æ¨¡å¼](#4-æ€§èƒ½ä¼˜åŒ–æ¨¡å¼)
    - [4.1 å¯¹è±¡æ± ](#41-å¯¹è±¡æ± )
    - [4.2 ç¼“å­˜æ¨¡å¼](#42-ç¼“å­˜æ¨¡å¼)
  - [5. å®‰å…¨æ¨¡å¼](#5-å®‰å…¨æ¨¡å¼)
    - [5.1 è¾“å…¥éªŒè¯](#51-è¾“å…¥éªŒè¯)
  - [6. ç”Ÿäº§éƒ¨ç½²æ£€æŸ¥æ¸…å•](#6-ç”Ÿäº§éƒ¨ç½²æ£€æŸ¥æ¸…å•)
    - [6.1 å¯è§‚æµ‹æ€§](#61-å¯è§‚æµ‹æ€§)
    - [6.2 å¼¹æ€§](#62-å¼¹æ€§)
    - [6.3 æ€§èƒ½](#63-æ€§èƒ½)
    - [6.4 å®‰å…¨](#64-å®‰å…¨)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

ç”Ÿäº§ç¯å¢ƒéœ€è¦è€ƒè™‘å¯è§‚æµ‹æ€§ã€å¼¹æ€§ã€æ€§èƒ½å’Œå®‰å…¨ã€‚æœ¬æ–‡æ¡£ä»‹ç»Rustä¸­çš„å·¥ç¨‹å®è·µæ¨¡å¼ã€‚

---

## 2. å¯è§‚æµ‹æ€§æ¨¡å¼

### 2.1 ç»“æ„åŒ–æ—¥å¿—

```rust
use tracing::{info, warn, error, instrument};
use tracing_subscriber;

/// åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
pub fn init_logging() {
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_line_number(true)
        .json() // ç»“æ„åŒ–JSONè¾“å‡º
        .init();
}

/// ä½¿ç”¨ tracing è¿›è¡Œç»“æ„åŒ–æ—¥å¿—
#[instrument]
pub async fn process_order(order_id: u64, user_id: u64) -> Result<(), String> {
    info!(order_id, user_id, "Processing order");
    
    // ä¸šåŠ¡é€»è¾‘
    let result = perform_payment(order_id).await;
    
    match result {
        Ok(_) => {
            info!(order_id, "Order processed successfully");
            Ok(())
        }
        Err(e) => {
            error!(order_id, error = %e, "Order processing failed");
            Err(e)
        }
    }
}

async fn perform_payment(order_id: u64) -> Result<(), String> {
    // æ”¯ä»˜é€»è¾‘
    Ok(())
}
```

### 2.2 Metricsæ”¶é›†

```rust
use prometheus::{Counter, Histogram, Registry};
use once_cell::sync::Lazy;

/// å…¨å±€ Metrics æ³¨å†Œè¡¨
pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

/// Metrics å®šä¹‰
pub struct Metrics {
    pub requests_total: Counter,
    pub request_duration: Histogram,
}

impl Metrics {
    pub fn new() -> Self {
        let requests_total = Counter::new("requests_total", "Total requests").unwrap();
        let request_duration = Histogram::new("request_duration_seconds", "Request duration").unwrap();
        
        REGISTRY.register(Box::new(requests_total.clone())).unwrap();
        REGISTRY.register(Box::new(request_duration.clone())).unwrap();
        
        Self {
            requests_total,
            request_duration,
        }
    }
}

/// ä½¿ç”¨ Metrics
pub async fn handle_request() {
    let metrics = Metrics::new();
    
    let timer = metrics.request_duration.start_timer();
    
    // å¤„ç†è¯·æ±‚
    process_request().await;
    
    timer.observe_duration();
    metrics.requests_total.inc();
}

async fn process_request() {
    // ä¸šåŠ¡é€»è¾‘
}
```

### 2.3 åˆ†å¸ƒå¼è¿½è¸ª

```rust
use opentelemetry::{global, trace::{Tracer, Span}};
use opentelemetry::sdk::trace::TracerProvider;

/// åˆå§‹åŒ–åˆ†å¸ƒå¼è¿½è¸ª
pub fn init_tracing() {
    let provider = TracerProvider::default();
    global::set_tracer_provider(provider);
}

/// ä½¿ç”¨ Span è¿›è¡Œè¿½è¸ª
pub async fn traced_operation() {
    let tracer = global::tracer("my-service");
    let mut span = tracer.start("operation");
    
    span.set_attribute(opentelemetry::KeyValue::new("user_id", 123));
    
    // ä¸šåŠ¡é€»è¾‘
    perform_database_query().await;
    
    span.end();
}

async fn perform_database_query() {
    // æ•°æ®åº“æŸ¥è¯¢
}
```

---

## 3. å¼¹æ€§æ¨¡å¼

### 3.1 Circuit Breaker (æ–­è·¯å™¨)

```rust
use std::sync::atomic::{AtomicU64, AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};

/// æ–­è·¯å™¨çŠ¶æ€
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CircuitState {
    Closed,   // æ­£å¸¸
    Open,     // æ–­å¼€ï¼ˆå¿«é€Ÿå¤±è´¥ï¼‰
    HalfOpen, // åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰
}

/// æ–­è·¯å™¨
pub struct CircuitBreaker {
    failure_threshold: u64,
    success_threshold: u64,
    timeout: Duration,
    
    failures: AtomicU64,
    successes: AtomicU64,
    last_failure_time: Arc<tokio::sync::RwLock<Option<Instant>>>,
    state: Arc<tokio::sync::RwLock<CircuitState>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u64, success_threshold: u64, timeout: Duration) -> Self {
        Self {
            failure_threshold,
            success_threshold,
            timeout,
            failures: AtomicU64::new(0),
            successes: AtomicU64::new(0),
            last_failure_time: Arc::new(tokio::sync::RwLock::new(None)),
            state: Arc::new(tokio::sync::RwLock::new(CircuitState::Closed)),
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: FnOnce() -> Result<T, E>,
    {
        let state = *self.state.read().await;
        
        match state {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å°è¯•æ¢å¤
                let last_failure = self.last_failure_time.read().await;
                if let Some(time) = *last_failure {
                    if time.elapsed() > self.timeout {
                        *self.state.write().await = CircuitState::HalfOpen;
                    } else {
                        return Err(CircuitBreakerError::CircuitOpen);
                    }
                }
            }
            _ => {}
        }
        
        // æ‰§è¡Œè°ƒç”¨
        match f() {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(CircuitBreakerError::InnerError(e))
            }
        }
    }
    
    async fn on_success(&self) {
        self.successes.fetch_add(1, Ordering::Relaxed);
        
        let state = *self.state.read().await;
        if state == CircuitState::HalfOpen {
            if self.successes.load(Ordering::Relaxed) >= self.success_threshold {
                *self.state.write().await = CircuitState::Closed;
                self.successes.store(0, Ordering::Relaxed);
                self.failures.store(0, Ordering::Relaxed);
            }
        }
    }
    
    async fn on_failure(&self) {
        self.failures.fetch_add(1, Ordering::Relaxed);
        *self.last_failure_time.write().await = Some(Instant::now());
        
        if self.failures.load(Ordering::Relaxed) >= self.failure_threshold {
            *self.state.write().await = CircuitState::Open;
        }
    }
}

#[derive(Debug)]
pub enum CircuitBreakerError<E> {
    CircuitOpen,
    InnerError(E),
}
```

### 3.2 Retry Pattern (é‡è¯•)

```rust
use tokio::time::{sleep, Duration};

/// é‡è¯•ç­–ç•¥
pub trait RetryStrategy {
    fn next_delay(&mut self) -> Option<Duration>;
}

/// æŒ‡æ•°é€€é¿é‡è¯•
pub struct ExponentialBackoff {
    current: Duration,
    max: Duration,
    multiplier: u32,
    attempts: u32,
    max_attempts: u32,
}

impl ExponentialBackoff {
    pub fn new(initial: Duration, max: Duration, max_attempts: u32) -> Self {
        Self {
            current: initial,
            max,
            multiplier: 2,
            attempts: 0,
            max_attempts,
        }
    }
}

impl RetryStrategy for ExponentialBackoff {
    fn next_delay(&mut self) -> Option<Duration> {
        if self.attempts >= self.max_attempts {
            return None;
        }
        
        let delay = self.current;
        self.current = std::cmp::min(self.current * self.multiplier, self.max);
        self.attempts += 1;
        
        Some(delay)
    }
}

/// é‡è¯•æ‰§è¡Œå™¨
pub async fn retry_with_strategy<F, T, E>(
    mut f: F,
    mut strategy: impl RetryStrategy,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    loop {
        match f() {
            Ok(result) => return Ok(result),
            Err(e) => {
                if let Some(delay) = strategy.next_delay() {
                    sleep(delay).await;
                } else {
                    return Err(e);
                }
            }
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn retry_example() {
    let result = retry_with_strategy(
        || {
            // å¯èƒ½å¤±è´¥çš„æ“ä½œ
            call_external_api()
        },
        ExponentialBackoff::new(
            Duration::from_millis(100),
            Duration::from_secs(10),
            5
        )
    ).await;
}

fn call_external_api() -> Result<String, String> {
    Ok("success".to_string())
}
```

---

## 4. æ€§èƒ½ä¼˜åŒ–æ¨¡å¼

### 4.1 å¯¹è±¡æ± 

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

/// å¯¹è±¡æ± 
pub struct Pool<T> {
    objects: Arc<Mutex<Vec<T>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
    max_size: usize,
}

impl<T: Send + 'static> Pool<T> {
    pub fn new<F>(factory: F, max_size: usize) -> Self
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        Self {
            objects: Arc::new(Mutex::new(Vec::new())),
            factory: Arc::new(factory),
            max_size,
        }
    }
    
    pub async fn acquire(&self) -> PoolGuard<T> {
        let mut objects = self.objects.lock().await;
        
        let object = objects.pop().unwrap_or_else(|| (self.factory)());
        
        PoolGuard {
            object: Some(object),
            pool: self.objects.clone(),
        }
    }
}

/// æ± å¯¹è±¡å®ˆå«
pub struct PoolGuard<T> {
    object: Option<T>,
    pool: Arc<Mutex<Vec<T>>>,
}

impl<T> std::ops::Deref for PoolGuard<T> {
    type Target = T;
    
    fn deref(&self) -> &Self::Target {
        self.object.as_ref().unwrap()
    }
}

impl<T> Drop for PoolGuard<T> {
    fn drop(&mut self) {
        if let Some(object) = self.object.take() {
            let pool = self.pool.clone();
            tokio::spawn(async move {
                let mut objects = pool.lock().await;
                objects.push(object);
            });
        }
    }
}
```

### 4.2 ç¼“å­˜æ¨¡å¼

```rust
use std::collections::HashMap;
use std::hash::Hash;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

/// å¸¦è¿‡æœŸæ—¶é—´çš„ç¼“å­˜
pub struct Cache<K, V> {
    store: RwLock<HashMap<K, CacheEntry<V>>>,
    ttl: Duration,
}

struct CacheEntry<V> {
    value: V,
    expires_at: Instant,
}

impl<K: Eq + Hash, V: Clone> Cache<K, V> {
    pub fn new(ttl: Duration) -> Self {
        Self {
            store: RwLock::new(HashMap::new()),
            ttl,
        }
    }
    
    pub async fn get(&self, key: &K) -> Option<V> {
        let store = self.store.read().await;
        
        if let Some(entry) = store.get(key) {
            if entry.expires_at > Instant::now() {
                return Some(entry.value.clone());
            }
        }
        
        None
    }
    
    pub async fn set(&self, key: K, value: V) {
        let mut store = self.store.write().await;
        
        store.insert(key, CacheEntry {
            value,
            expires_at: Instant::now() + self.ttl,
        });
    }
    
    pub async fn invalidate(&self, key: &K) {
        let mut store = self.store.write().await;
        store.remove(key);
    }
}
```

---

## 5. å®‰å…¨æ¨¡å¼

### 5.1 è¾“å…¥éªŒè¯

```rust
/// è¾“å…¥éªŒè¯ trait
pub trait Validator {
    type Error;
    fn validate(&self) -> Result<(), Self::Error>;
}

/// ç”¨æˆ·è¾“å…¥éªŒè¯
pub struct UserInput {
    pub username: String,
    pub email: String,
}

impl Validator for UserInput {
    type Error = String;
    
    fn validate(&self) -> Result<(), Self::Error> {
        // ç”¨æˆ·åéªŒè¯
        if self.username.len() < 3 {
            return Err("Username too short".to_string());
        }
        
        if self.username.len() > 32 {
            return Err("Username too long".to_string());
        }
        
        // é‚®ç®±éªŒè¯
        if !self.email.contains('@') {
            return Err("Invalid email".to_string());
        }
        
        Ok(())
    }
}
```

---

## 6. ç”Ÿäº§éƒ¨ç½²æ£€æŸ¥æ¸…å•

### 6.1 å¯è§‚æµ‹æ€§

- [ ] ç»“æ„åŒ–æ—¥å¿— (tracing)
- [ ] Metrics æ”¶é›† (Prometheus)
- [ ] åˆ†å¸ƒå¼è¿½è¸ª (OpenTelemetry)
- [ ] å¥åº·æ£€æŸ¥ç«¯ç‚¹
- [ ] Readiness/Liveness probes

### 6.2 å¼¹æ€§

- [ ] æ–­è·¯å™¨ (Circuit Breaker)
- [ ] é‡è¯•ç­–ç•¥ (Retry)
- [ ] è¶…æ—¶æ§åˆ¶ (Timeout)
- [ ] é™æµ (Rate Limiting)
- [ ] é™çº§ç­–ç•¥ (Fallback)

### 6.3 æ€§èƒ½

- [ ] è¿æ¥æ±  (Connection Pool)
- [ ] ç¼“å­˜ (Cache)
- [ ] å¼‚æ­¥I/O (Tokio)
- [ ] æ‰¹å¤„ç† (Batching)
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

### 6.4 å®‰å…¨

- [ ] è¾“å…¥éªŒè¯
- [ ] è¾“å‡ºè½¬ä¹‰
- [ ] è®¤è¯/æˆæƒ
- [ ] TLS/SSL
- [ ] å®‰å…¨å®¡è®¡æ—¥å¿—

---

## ğŸ“š ç›¸å…³èµ„æº

- **Tier 3**: [æ€§èƒ½è¯„ä¼°](../tier_03_references/04_æ¨¡å¼æ€§èƒ½è¯„ä¼°å‚è€ƒ.md)
- **ç”Ÿäº§éƒ¨ç½²**: [deployment/](../../../../deployment/)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-23
