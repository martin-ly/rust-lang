# è®¾è®¡æ¨¡å¼åˆ†ç±»å‚è€ƒ

> **æ–‡æ¡£å®šä½**: Tier 3 æŠ€æœ¯å‚è€ƒ  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¨¡å¼åˆ†ç±»å‚è€ƒ](#è®¾è®¡æ¨¡å¼åˆ†ç±»å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 åˆ†ç±»ç»´åº¦](#11-åˆ†ç±»ç»´åº¦)
    - [1.2 Rust ä¸­çš„è®¾è®¡æ¨¡å¼ç‰¹ç‚¹](#12-rust-ä¸­çš„è®¾è®¡æ¨¡å¼ç‰¹ç‚¹)
  - [2. GoF ç»å…¸è®¾è®¡æ¨¡å¼](#2-gof-ç»å…¸è®¾è®¡æ¨¡å¼)
    - [2.1 åˆ›å»ºå‹æ¨¡å¼ (Creational Patterns)](#21-åˆ›å»ºå‹æ¨¡å¼-creational-patterns)
      - [2.1.1 Singleton (å•ä¾‹æ¨¡å¼)](#211-singleton-å•ä¾‹æ¨¡å¼)
      - [2.1.2 Factory Method (å·¥å‚æ–¹æ³•æ¨¡å¼)](#212-factory-method-å·¥å‚æ–¹æ³•æ¨¡å¼)
      - [2.1.3 Builder (å»ºé€ è€…æ¨¡å¼)](#213-builder-å»ºé€ è€…æ¨¡å¼)
      - [2.1.4 Prototype (åŸå‹æ¨¡å¼)](#214-prototype-åŸå‹æ¨¡å¼)
      - [2.1.5 Abstract Factory (æŠ½è±¡å·¥å‚æ¨¡å¼)](#215-abstract-factory-æŠ½è±¡å·¥å‚æ¨¡å¼)
    - [2.2 ç»“æ„å‹æ¨¡å¼ (Structural Patterns)](#22-ç»“æ„å‹æ¨¡å¼-structural-patterns)
      - [2.2.1 Adapter (é€‚é…å™¨æ¨¡å¼)](#221-adapter-é€‚é…å™¨æ¨¡å¼)
      - [2.2.2 Decorator (è£…é¥°å™¨æ¨¡å¼)](#222-decorator-è£…é¥°å™¨æ¨¡å¼)
      - [2.2.3 Proxy (ä»£ç†æ¨¡å¼)](#223-proxy-ä»£ç†æ¨¡å¼)
    - [2.3 è¡Œä¸ºå‹æ¨¡å¼ (Behavioral Patterns)](#23-è¡Œä¸ºå‹æ¨¡å¼-behavioral-patterns)
      - [2.3.1 Observer (è§‚å¯Ÿè€…æ¨¡å¼)](#231-observer-è§‚å¯Ÿè€…æ¨¡å¼)
      - [2.3.2 Strategy (ç­–ç•¥æ¨¡å¼)](#232-strategy-ç­–ç•¥æ¨¡å¼)
  - [3. å¹¶å‘æ¨¡å¼ (Concurrency Patterns)](#3-å¹¶å‘æ¨¡å¼-concurrency-patterns)
    - [3.1 å…±äº«çŠ¶æ€æ¨¡å¼](#31-å…±äº«çŠ¶æ€æ¨¡å¼)
      - [3.1.1 Mutex (äº’æ–¥é”æ¨¡å¼)](#311-mutex-äº’æ–¥é”æ¨¡å¼)
    - [3.2 æ¶ˆæ¯ä¼ é€’æ¨¡å¼](#32-æ¶ˆæ¯ä¼ é€’æ¨¡å¼)
      - [3.2.1 Actor Model (Actoræ¨¡å¼)](#321-actor-model-actoræ¨¡å¼)
    - [3.3 å¼‚æ­¥æ¨¡å¼](#33-å¼‚æ­¥æ¨¡å¼)
      - [3.3.1 Reactor Pattern (ååº”å™¨æ¨¡å¼)](#331-reactor-pattern-ååº”å™¨æ¨¡å¼)
  - [4. Rust ç‰¹æœ‰æ¨¡å¼](#4-rust-ç‰¹æœ‰æ¨¡å¼)
    - [4.1 æ‰€æœ‰æƒæ¨¡å¼](#41-æ‰€æœ‰æƒæ¨¡å¼)
      - [4.1.1 RAII (Resource Acquisition Is Initialization)](#411-raii-resource-acquisition-is-initialization)
    - [4.2 ç±»å‹ç³»ç»Ÿæ¨¡å¼](#42-ç±»å‹ç³»ç»Ÿæ¨¡å¼)
      - [4.2.1 Newtype Pattern (æ–°ç±»å‹æ¨¡å¼)](#421-newtype-pattern-æ–°ç±»å‹æ¨¡å¼)
      - [4.2.2 Typestate Pattern (ç±»å‹çŠ¶æ€æ¨¡å¼)](#422-typestate-pattern-ç±»å‹çŠ¶æ€æ¨¡å¼)
  - [5. æ¶æ„æ¨¡å¼ (Architectural Patterns)](#5-æ¶æ„æ¨¡å¼-architectural-patterns)
    - [5.1 åˆ†å±‚æ¶æ„ (Layered Architecture)](#51-åˆ†å±‚æ¶æ„-layered-architecture)
  - [6. æ¨¡å¼åˆ†ç±»çŸ©é˜µ](#6-æ¨¡å¼åˆ†ç±»çŸ©é˜µ)
  - [7. æ¨¡å¼å…³ç³»å›¾è°±](#7-æ¨¡å¼å…³ç³»å›¾è°±)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å¼€å‘ä¸­åå¤å‡ºç°çš„é—®é¢˜çš„é€šç”¨è§£å†³æ–¹æ¡ˆã€‚åœ¨ Rust ä¸­ï¼Œè®¾è®¡æ¨¡å¼éœ€è¦é€‚åº”å…¶ç‹¬ç‰¹çš„æ‰€æœ‰æƒç³»ç»Ÿã€ç±»å‹ç³»ç»Ÿå’Œå†…å­˜æ¨¡å‹ã€‚

### 1.1 åˆ†ç±»ç»´åº¦

| ç»´åº¦ | åˆ†ç±»æ ‡å‡† | ç¤ºä¾‹ |
|-----|---------|------|
| **æ„å›¾** | åˆ›å»ºã€ç»“æ„ã€è¡Œä¸º | Singleton, Adapter, Observer |
| **ä½œç”¨åŸŸ** | ç±»çº§ã€å¯¹è±¡çº§ | Factory Method, Abstract Factory |
| **å¹¶å‘æ€§** | åŒæ­¥ã€å¼‚æ­¥ã€å¹¶è¡Œ | Mutex, Actor, Reactor |
| **æŠ½è±¡å±‚æ¬¡** | ä»£ç çº§ã€æ¶æ„çº§ | Strategy, Microservices |
| **Rustç‰¹æ€§** | æ‰€æœ‰æƒã€ç±»å‹ã€ç”Ÿå‘½å‘¨æœŸ | RAII, Newtype, Typestate |

### 1.2 Rust ä¸­çš„è®¾è®¡æ¨¡å¼ç‰¹ç‚¹

```rust
/// Rustè®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒç‰¹æ€§
pub trait RustPatternCharacteristics {
    /// é›¶æˆæœ¬æŠ½è±¡ - ç¼–è¯‘æ—¶ä¼˜åŒ–
    fn zero_cost_abstraction() -> bool { true }
    
    /// å†…å­˜å®‰å…¨ - ç¼–è¯‘æ—¶ä¿è¯
    fn memory_safety() -> bool { true }
    
    /// å¹¶å‘å®‰å…¨ - Send + Sync
    fn concurrency_safety() -> bool { true }
    
    /// é”™è¯¯å¤„ç† - Result<T, E>
    type Error;
    fn error_handling() -> Result<(), Self::Error>;
}

/// ç¤ºä¾‹ï¼šç±»å‹å®‰å…¨çš„Builderæ¨¡å¼
pub struct HttpRequestBuilder {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
}

impl HttpRequestBuilder {
    pub fn new() -> Self {
        Self {
            url: None,
            method: None,
            headers: Vec::new(),
        }
    }
    
    pub fn url(mut self, url: impl Into<String>) -> Self {
        self.url = Some(url.into());
        self
    }
    
    pub fn method(mut self, method: impl Into<String>) -> Self {
        self.method = Some(method.into());
        self
    }
    
    pub fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((key.into(), value.into()));
        self
    }
    
    pub fn build(self) -> Result<HttpRequest, BuildError> {
        let url = self.url.ok_or(BuildError::MissingUrl)?;
        let method = self.method.unwrap_or_else(|| "GET".to_string());
        
        Ok(HttpRequest {
            url,
            method,
            headers: self.headers,
        })
    }
}

#[derive(Debug)]
pub struct HttpRequest {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
}

#[derive(Debug)]
pub enum BuildError {
    MissingUrl,
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn builder_example() -> Result<(), BuildError> {
    let request = HttpRequestBuilder::new()
        .url("https://api.example.com")
        .method("POST")
        .header("Content-Type", "application/json")
        .header("Authorization", "Bearer token")
        .build()?;
    
    println!("Request: {:?}", request);
    Ok(())
}
```

---

## 2. GoF ç»å…¸è®¾è®¡æ¨¡å¼

### 2.1 åˆ›å»ºå‹æ¨¡å¼ (Creational Patterns)

åˆ›å»ºå‹æ¨¡å¼å¤„ç†å¯¹è±¡åˆ›å»ºæœºåˆ¶ï¼Œå¢åŠ ä»£ç çµæ´»æ€§å’Œå¯é‡ç”¨æ€§ã€‚

#### 2.1.1 Singleton (å•ä¾‹æ¨¡å¼)

**æ„å›¾**: ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
use std::sync::OnceLock;

/// å…¨å±€é…ç½®å•ä¾‹
pub struct Config {
    pub api_url: String,
    pub timeout: u64,
}

static CONFIG: OnceLock<Config> = OnceLock::new();

impl Config {
    /// åˆå§‹åŒ–å…¨å±€é…ç½®ï¼ˆåªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼‰
    pub fn init(api_url: String, timeout: u64) -> Result<(), &'static str> {
        CONFIG.set(Config { api_url, timeout })
            .map_err(|_| "Config already initialized")
    }
    
    /// è·å–å…¨å±€é…ç½®
    pub fn get() -> &'static Config {
        CONFIG.get().expect("Config not initialized")
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn singleton_example() {
    // åˆå§‹åŒ–
    Config::init("https://api.example.com".to_string(), 30).unwrap();
    
    // å…¨å±€è®¿é—®
    let config = Config::get();
    println!("API URL: {}", config.api_url);
    println!("Timeout: {}s", config.timeout);
}
```

**ç‰¹ç‚¹**:

- âœ… çº¿ç¨‹å®‰å…¨ (OnceLock)
- âœ… å»¶è¿Ÿåˆå§‹åŒ–
- âœ… é›¶æˆæœ¬æŠ½è±¡
- âš ï¸ å…¨å±€çŠ¶æ€ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰

**é€‚ç”¨åœºæ™¯**:

- å…¨å±€é…ç½®
- æ—¥å¿—ç³»ç»Ÿ
- èµ„æºæ± 

#### 2.1.2 Factory Method (å·¥å‚æ–¹æ³•æ¨¡å¼)

**æ„å›¾**: å®šä¹‰åˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œç”±å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
/// äº§å“æ¥å£
pub trait Vehicle {
    fn drive(&self);
}

/// å…·ä½“äº§å“ï¼šæ±½è½¦
pub struct Car;

impl Vehicle for Car {
    fn drive(&self) {
        println!("Driving a car ğŸš—");
    }
}

/// å…·ä½“äº§å“ï¼šæ‘©æ‰˜è½¦
pub struct Motorcycle;

impl Vehicle for Motorcycle {
    fn drive(&self) {
        println!("Riding a motorcycle ğŸï¸");
    }
}

/// å·¥å‚æ¥å£
pub trait VehicleFactory {
    fn create_vehicle(&self) -> Box<dyn Vehicle>;
}

/// å…·ä½“å·¥å‚ï¼šæ±½è½¦å·¥å‚
pub struct CarFactory;

impl VehicleFactory for CarFactory {
    fn create_vehicle(&self) -> Box<dyn Vehicle> {
        Box::new(Car)
    }
}

/// å…·ä½“å·¥å‚ï¼šæ‘©æ‰˜è½¦å·¥å‚
pub struct MotorcycleFactory;

impl VehicleFactory for MotorcycleFactory {
    fn create_vehicle(&self) -> Box<dyn Vehicle> {
        Box::new(Motorcycle)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn factory_method_example() {
    let factories: Vec<Box<dyn VehicleFactory>> = vec![
        Box::new(CarFactory),
        Box::new(MotorcycleFactory),
    ];
    
    for factory in factories {
        let vehicle = factory.create_vehicle();
        vehicle.drive();
    }
}
```

**ç‰¹ç‚¹**:

- âœ… è¿è¡Œæ—¶å¤šæ€ (trait object)
- âœ… æ˜“äºæ‰©å±•
- âš ï¸ æ€§èƒ½å¼€é”€ (åŠ¨æ€åˆ†æ´¾)

**é€‚ç”¨åœºæ™¯**:

- æ¡†æ¶å¼€å‘
- æ’ä»¶ç³»ç»Ÿ
- å¤šç±»å‹å¯¹è±¡åˆ›å»º

#### 2.1.3 Builder (å»ºé€ è€…æ¨¡å¼)

**æ„å›¾**: å°†å¤æ‚å¯¹è±¡çš„æ„å»ºä¸è¡¨ç¤ºåˆ†ç¦»ã€‚

**Rustå®ç°æ–¹å¼** (Typestate):

```rust
use std::marker::PhantomData;

/// ç±»å‹çŠ¶æ€æ ‡è®°
pub mod state {
    pub struct NoUrl;
    pub struct HasUrl;
    pub struct NoMethod;
    pub struct HasMethod;
}

/// ç±»å‹çŠ¶æ€çš„HTTPè¯·æ±‚æ„å»ºå™¨
pub struct TypedHttpRequestBuilder<U, M> {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
    _url_state: PhantomData<U>,
    _method_state: PhantomData<M>,
}

impl TypedHttpRequestBuilder<state::NoUrl, state::NoMethod> {
    pub fn new() -> Self {
        Self {
            url: None,
            method: None,
            headers: Vec::new(),
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<M> TypedHttpRequestBuilder<state::NoUrl, M> {
    pub fn url(self, url: impl Into<String>) -> TypedHttpRequestBuilder<state::HasUrl, M> {
        TypedHttpRequestBuilder {
            url: Some(url.into()),
            method: self.method,
            headers: self.headers,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U> TypedHttpRequestBuilder<U, state::NoMethod> {
    pub fn method(self, method: impl Into<String>) -> TypedHttpRequestBuilder<U, state::HasMethod> {
        TypedHttpRequestBuilder {
            url: self.url,
            method: Some(method.into()),
            headers: self.headers,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U, M> TypedHttpRequestBuilder<U, M> {
    pub fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((key.into(), value.into()));
        self
    }
}

impl TypedHttpRequestBuilder<state::HasUrl, state::HasMethod> {
    pub fn build(self) -> HttpRequest {
        HttpRequest {
            url: self.url.unwrap(),
            method: self.method.unwrap(),
            headers: self.headers,
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn typed_builder_example() {
    let request = TypedHttpRequestBuilder::new()
        .url("https://api.example.com")
        .method("POST")
        .header("Content-Type", "application/json")
        .build();
    
    println!("Request: {:?}", request);
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘ URL
    // let invalid = TypedHttpRequestBuilder::new()
    //     .method("GET")
    //     .build(); // ç¼–è¯‘å¤±è´¥
}
```

**ç‰¹ç‚¹**:

- âœ… ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
- âœ… é“¾å¼è°ƒç”¨
- âœ… é›¶æˆæœ¬æŠ½è±¡
- âš ï¸ ä»£ç é‡è¾ƒå¤§

#### 2.1.4 Prototype (åŸå‹æ¨¡å¼)

**æ„å›¾**: é€šè¿‡å…‹éš†ç°æœ‰å¯¹è±¡æ¥åˆ›å»ºæ–°å¯¹è±¡ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
/// å¯å…‹éš†çš„å›¾å½¢å¯¹è±¡
#[derive(Clone, Debug)]
pub struct Shape {
    pub shape_type: String,
    pub color: String,
    pub x: i32,
    pub y: i32,
}

impl Shape {
    pub fn new(shape_type: impl Into<String>, color: impl Into<String>) -> Self {
        Self {
            shape_type: shape_type.into(),
            color: color.into(),
            x: 0,
            y: 0,
        }
    }
    
    pub fn set_position(mut self, x: i32, y: i32) -> Self {
        self.x = x;
        self.y = y;
        self
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn prototype_example() {
    let circle_prototype = Shape::new("Circle", "Red");
    
    // å…‹éš†å¹¶ä¿®æ”¹
    let circle1 = circle_prototype.clone().set_position(10, 20);
    let circle2 = circle_prototype.clone().set_position(30, 40);
    
    println!("Circle 1: {:?}", circle1);
    println!("Circle 2: {:?}", circle2);
}
```

**ç‰¹ç‚¹**:

- âœ… å®ç°ç®€å• (derive Clone)
- âœ… æ”¯æŒæ·±æ‹·è´/æµ…æ‹·è´
- âš ï¸ æ³¨æ„Cloneæˆæœ¬

#### 2.1.5 Abstract Factory (æŠ½è±¡å·¥å‚æ¨¡å¼)

**æ„å›¾**: æä¾›åˆ›å»ºä¸€ç³»åˆ—ç›¸å…³å¯¹è±¡çš„æ¥å£ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
/// UIç»„ä»¶æŠ½è±¡
pub trait Button {
    fn render(&self);
}

pub trait Checkbox {
    fn render(&self);
}

/// Windowsé£æ ¼ç»„ä»¶
pub struct WindowsButton;

impl Button for WindowsButton {
    fn render(&self) {
        println!("Rendering Windows button");
    }
}

pub struct WindowsCheckbox;

impl Checkbox for WindowsCheckbox {
    fn render(&self) {
        println!("Rendering Windows checkbox");
    }
}

/// MacOSé£æ ¼ç»„ä»¶
pub struct MacButton;

impl Button for MacButton {
    fn render(&self) {
        println!("Rendering Mac button");
    }
}

pub struct MacCheckbox;

impl Checkbox for MacCheckbox {
    fn render(&self) {
        println!("Rendering Mac checkbox");
    }
}

/// UIå·¥å‚æŠ½è±¡
pub trait UIFactory {
    fn create_button(&self) -> Box<dyn Button>;
    fn create_checkbox(&self) -> Box<dyn Checkbox>;
}

/// Windowså·¥å‚
pub struct WindowsFactory;

impl UIFactory for WindowsFactory {
    fn create_button(&self) -> Box<dyn Button> {
        Box::new(WindowsButton)
    }
    
    fn create_checkbox(&self) -> Box<dyn Checkbox> {
        Box::new(WindowsCheckbox)
    }
}

/// Macå·¥å‚
pub struct MacFactory;

impl UIFactory for MacFactory {
    fn create_button(&self) -> Box<dyn Button> {
        Box::new(MacButton)
    }
    
    fn create_checkbox(&self) -> Box<dyn Checkbox> {
        Box::new(MacCheckbox)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn abstract_factory_example() {
    let factory: Box<dyn UIFactory> = if cfg!(target_os = "windows") {
        Box::new(WindowsFactory)
    } else {
        Box::new(MacFactory)
    };
    
    let button = factory.create_button();
    let checkbox = factory.create_checkbox();
    
    button.render();
    checkbox.render();
}
```

### 2.2 ç»“æ„å‹æ¨¡å¼ (Structural Patterns)

#### 2.2.1 Adapter (é€‚é…å™¨æ¨¡å¼)

**æ„å›¾**: å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·æœŸæœ›çš„å¦ä¸€ä¸ªæ¥å£ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
/// æ—§æ¥å£
pub trait OldPaymentProcessor {
    fn process_payment(&self, amount: f64);
}

pub struct LegacyPaymentSystem;

impl OldPaymentProcessor for LegacyPaymentSystem {
    fn process_payment(&self, amount: f64) {
        println!("[Legacy] Processing payment: ${}", amount);
    }
}

/// æ–°æ¥å£
pub trait NewPaymentProcessor {
    fn pay(&self, amount: f64, currency: &str);
}

/// é€‚é…å™¨
pub struct PaymentAdapter<T: OldPaymentProcessor> {
    legacy: T,
}

impl<T: OldPaymentProcessor> PaymentAdapter<T> {
    pub fn new(legacy: T) -> Self {
        Self { legacy }
    }
}

impl<T: OldPaymentProcessor> NewPaymentProcessor for PaymentAdapter<T> {
    fn pay(&self, amount: f64, currency: &str) {
        println!("[Adapter] Converting {} to USD", currency);
        self.legacy.process_payment(amount);
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn adapter_example() {
    let legacy = LegacyPaymentSystem;
    let adapter = PaymentAdapter::new(legacy);
    
    adapter.pay(100.0, "EUR");
}
```

#### 2.2.2 Decorator (è£…é¥°å™¨æ¨¡å¼)

**æ„å›¾**: åŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ é¢å¤–çš„èŒè´£ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
/// æ ¸å¿ƒæ¥å£
pub trait DataSource {
    fn read_data(&self) -> String;
    fn write_data(&self, data: &str);
}

/// åŸºç¡€ç»„ä»¶
pub struct FileDataSource {
    filename: String,
}

impl FileDataSource {
    pub fn new(filename: String) -> Self {
        Self { filename }
    }
}

impl DataSource for FileDataSource {
    fn read_data(&self) -> String {
        format!("[File] Reading from {}", self.filename)
    }
    
    fn write_data(&self, data: &str) {
        println!("[File] Writing to {}: {}", self.filename, data);
    }
}

/// è£…é¥°å™¨ï¼šåŠ å¯†
pub struct EncryptionDecorator<T: DataSource> {
    wrapped: T,
}

impl<T: DataSource> EncryptionDecorator<T> {
    pub fn new(wrapped: T) -> Self {
        Self { wrapped }
    }
}

impl<T: DataSource> DataSource for EncryptionDecorator<T> {
    fn read_data(&self) -> String {
        let data = self.wrapped.read_data();
        format!("[Encryption] Decrypting: {}", data)
    }
    
    fn write_data(&self, data: &str) {
        println!("[Encryption] Encrypting: {}", data);
        self.wrapped.write_data(&format!("encrypted({})", data));
    }
}

/// è£…é¥°å™¨ï¼šå‹ç¼©
pub struct CompressionDecorator<T: DataSource> {
    wrapped: T,
}

impl<T: DataSource> CompressionDecorator<T> {
    pub fn new(wrapped: T) -> Self {
        Self { wrapped }
    }
}

impl<T: DataSource> DataSource for CompressionDecorator<T> {
    fn read_data(&self) -> String {
        let data = self.wrapped.read_data();
        format!("[Compression] Decompressing: {}", data)
    }
    
    fn write_data(&self, data: &str) {
        println!("[Compression] Compressing: {}", data);
        self.wrapped.write_data(&format!("compressed({})", data));
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn decorator_example() {
    let file = FileDataSource::new("data.txt".to_string());
    let encrypted = EncryptionDecorator::new(file);
    let compressed = CompressionDecorator::new(encrypted);
    
    compressed.write_data("Hello, World!");
    println!("{}", compressed.read_data());
}
```

#### 2.2.3 Proxy (ä»£ç†æ¨¡å¼)

**æ„å›¾**: ä¸ºå…¶ä»–å¯¹è±¡æä¾›ä¸€ç§ä»£ç†ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

/// çœŸå®ä¸»é¢˜
pub trait Database {
    fn query(&self, sql: &str) -> String;
}

pub struct RealDatabase;

impl Database for RealDatabase {
    fn query(&self, sql: &str) -> String {
        println!("[DB] Executing query: {}", sql);
        format!("Result of '{}'", sql)
    }
}

/// ä»£ç†ï¼šç¼“å­˜ä»£ç†
pub struct CachedDatabaseProxy {
    real_db: RealDatabase,
    cache: Arc<Mutex<HashMap<String, String>>>,
}

impl CachedDatabaseProxy {
    pub fn new() -> Self {
        Self {
            real_db: RealDatabase,
            cache: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

impl Database for CachedDatabaseProxy {
    fn query(&self, sql: &str) -> String {
        let mut cache = self.cache.lock().unwrap();
        
        if let Some(cached_result) = cache.get(sql) {
            println!("[Proxy] Cache hit for: {}", sql);
            return cached_result.clone();
        }
        
        println!("[Proxy] Cache miss for: {}", sql);
        let result = self.real_db.query(sql);
        cache.insert(sql.to_string(), result.clone());
        result
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn proxy_example() {
    let db = CachedDatabaseProxy::new();
    
    // ç¬¬ä¸€æ¬¡æŸ¥è¯¢ - ç¼“å­˜æœªå‘½ä¸­
    println!("{}", db.query("SELECT * FROM users"));
    
    // ç¬¬äºŒæ¬¡æŸ¥è¯¢ - ç¼“å­˜å‘½ä¸­
    println!("{}", db.query("SELECT * FROM users"));
}
```

### 2.3 è¡Œä¸ºå‹æ¨¡å¼ (Behavioral Patterns)

#### 2.3.1 Observer (è§‚å¯Ÿè€…æ¨¡å¼)

**æ„å›¾**: å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»ã€‚

**Rustå®ç°æ–¹å¼** (with GATs):

```rust
use std::sync::{Arc, Mutex};

/// è§‚å¯Ÿè€…æ¥å£
pub trait Observer {
    fn update(&self, data: &str);
}

/// ä¸»é¢˜æ¥å£
pub trait Subject {
    fn attach(&mut self, observer: Arc<dyn Observer>);
    fn detach(&mut self, observer_id: usize);
    fn notify(&self, data: &str);
}

/// å…·ä½“ä¸»é¢˜
pub struct EventPublisher {
    observers: Vec<Arc<dyn Observer>>,
}

impl EventPublisher {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
        }
    }
}

impl Subject for EventPublisher {
    fn attach(&mut self, observer: Arc<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn detach(&mut self, observer_id: usize) {
        if observer_id < self.observers.len() {
            self.observers.remove(observer_id);
        }
    }
    
    fn notify(&self, data: &str) {
        for observer in &self.observers {
            observer.update(data);
        }
    }
}

/// å…·ä½“è§‚å¯Ÿè€…
pub struct EmailNotifier {
    email: String,
}

impl EmailNotifier {
    pub fn new(email: String) -> Self {
        Self { email }
    }
}

impl Observer for EmailNotifier {
    fn update(&self, data: &str) {
        println!("[Email] Sending to {}: {}", self.email, data);
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn observer_example() {
    let mut publisher = EventPublisher::new();
    
    let email_observer = Arc::new(EmailNotifier::new("user@example.com".to_string()));
    
    publisher.attach(email_observer.clone());
    
    publisher.notify("New article published!");
}
```

#### 2.3.2 Strategy (ç­–ç•¥æ¨¡å¼)

**æ„å›¾**: å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼ŒæŠŠå®ƒä»¬ä¸€ä¸ªä¸ªå°è£…èµ·æ¥ï¼Œå¹¶ä¸”ä½¿å®ƒä»¬å¯ç›¸äº’æ›¿æ¢ã€‚

**Rustå®ç°æ–¹å¼**:

```rust
/// ç­–ç•¥æ¥å£
pub trait CompressionStrategy {
    fn compress(&self, data: &[u8]) -> Vec<u8>;
    fn decompress(&self, data: &[u8]) -> Vec<u8>;
}

/// å…·ä½“ç­–ç•¥ï¼šZIP
pub struct ZipCompression;

impl CompressionStrategy for ZipCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        println!("[ZIP] Compressing {} bytes", data.len());
        data.to_vec() // ç®€åŒ–å®ç°
    }
    
    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        println!("[ZIP] Decompressing {} bytes", data.len());
        data.to_vec()
    }
}

/// å…·ä½“ç­–ç•¥ï¼šGZIP
pub struct GzipCompression;

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        println!("[GZIP] Compressing {} bytes", data.len());
        data.to_vec()
    }
    
    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        println!("[GZIP] Decompressing {} bytes", data.len());
        data.to_vec()
    }
}

/// ä¸Šä¸‹æ–‡
pub struct Compressor {
    strategy: Box<dyn CompressionStrategy>,
}

impl Compressor {
    pub fn new(strategy: Box<dyn CompressionStrategy>) -> Self {
        Self { strategy }
    }
    
    pub fn set_strategy(&mut self, strategy: Box<dyn CompressionStrategy>) {
        self.strategy = strategy;
    }
    
    pub fn compress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.compress(data)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn strategy_example() {
    let data = b"Hello, World!";
    
    let mut compressor = Compressor::new(Box::new(ZipCompression));
    compressor.compress(data);
    
    compressor.set_strategy(Box::new(GzipCompression));
    compressor.compress(data);
}
```

---

## 3. å¹¶å‘æ¨¡å¼ (Concurrency Patterns)

### 3.1 å…±äº«çŠ¶æ€æ¨¡å¼

#### 3.1.1 Mutex (äº’æ–¥é”æ¨¡å¼)

```rust
use std::sync::{Arc, Mutex};
use std::thread;

/// å…±äº«è®¡æ•°å™¨
pub struct Counter {
    value: Arc<Mutex<i32>>,
}

impl Counter {
    pub fn new() -> Self {
        Self {
            value: Arc::new(Mutex::new(0)),
        }
    }
    
    pub fn increment(&self) {
        let mut value = self.value.lock().unwrap();
        *value += 1;
    }
    
    pub fn get(&self) -> i32 {
        *self.value.lock().unwrap()
    }
}

impl Clone for Counter {
    fn clone(&self) -> Self {
        Self {
            value: Arc::clone(&self.value),
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn mutex_example() {
    let counter = Counter::new();
    
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = counter.clone();
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                counter_clone.increment();
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final count: {}", counter.get());
}
```

### 3.2 æ¶ˆæ¯ä¼ é€’æ¨¡å¼

#### 3.2.1 Actor Model (Actoræ¨¡å¼)

```rust
use tokio::sync::mpsc;

/// Actoræ¶ˆæ¯
pub enum ActorMessage {
    Increment,
    Decrement,
    Get(tokio::sync::oneshot::Sender<i32>),
    Stop,
}

/// Actor
pub struct CounterActor {
    receiver: mpsc::Receiver<ActorMessage>,
    count: i32,
}

impl CounterActor {
    pub fn new(receiver: mpsc::Receiver<ActorMessage>) -> Self {
        Self {
            receiver,
            count: 0,
        }
    }
    
    pub async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                ActorMessage::Increment => {
                    self.count += 1;
                    println!("[Actor] Incremented to {}", self.count);
                }
                ActorMessage::Decrement => {
                    self.count -= 1;
                    println!("[Actor] Decremented to {}", self.count);
                }
                ActorMessage::Get(sender) => {
                    let _ = sender.send(self.count);
                }
                ActorMessage::Stop => {
                    println!("[Actor] Stopping");
                    break;
                }
            }
        }
    }
}

/// Actorå¥æŸ„
#[derive(Clone)]
pub struct CounterActorHandle {
    sender: mpsc::Sender<ActorMessage>,
}

impl CounterActorHandle {
    pub fn new() -> (Self, CounterActor) {
        let (sender, receiver) = mpsc::channel(100);
        let actor = CounterActor::new(receiver);
        let handle = Self { sender };
        (handle, actor)
    }
    
    pub async fn increment(&self) {
        let _ = self.sender.send(ActorMessage::Increment).await;
    }
    
    pub async fn decrement(&self) {
        let _ = self.sender.send(ActorMessage::Decrement).await;
    }
    
    pub async fn get(&self) -> i32 {
        let (tx, rx) = tokio::sync::oneshot::channel();
        let _ = self.sender.send(ActorMessage::Get(tx)).await;
        rx.await.unwrap_or(0)
    }
    
    pub async fn stop(&self) {
        let _ = self.sender.send(ActorMessage::Stop).await;
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn actor_example() {
    let (handle, actor) = CounterActorHandle::new();
    
    // å¯åŠ¨Actor
    tokio::spawn(actor.run());
    
    // å‘é€æ¶ˆæ¯
    handle.increment().await;
    handle.increment().await;
    handle.decrement().await;
    
    let count = handle.get().await;
    println!("Final count: {}", count);
    
    handle.stop().await;
}
```

### 3.3 å¼‚æ­¥æ¨¡å¼

#### 3.3.1 Reactor Pattern (ååº”å™¨æ¨¡å¼)

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};

/// Reactoräº‹ä»¶å¤„ç†å™¨
pub struct EchoHandler;

impl EchoHandler {
    pub async fn handle(mut stream: TcpStream) -> std::io::Result<()> {
        let mut buffer = vec![0u8; 1024];
        
        loop {
            let n = stream.read(&mut buffer).await?;
            if n == 0 {
                break; // è¿æ¥å…³é—­
            }
            
            stream.write_all(&buffer[..n]).await?;
        }
        
        Ok(())
    }
}

/// ReactoræœåŠ¡å™¨
pub struct ReactorServer {
    listener: TcpListener,
}

impl ReactorServer {
    pub async fn bind(addr: &str) -> std::io::Result<Self> {
        let listener = TcpListener::bind(addr).await?;
        Ok(Self { listener })
    }
    
    pub async fn run(self) -> std::io::Result<()> {
        println!("[Reactor] Server listening");
        
        loop {
            let (stream, addr) = self.listener.accept().await?;
            println!("[Reactor] New connection from {}", addr);
            
            tokio::spawn(async move {
                if let Err(e) = EchoHandler::handle(stream).await {
                    eprintln!("[Reactor] Handler error: {}", e);
                }
            });
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn reactor_example() -> std::io::Result<()> {
    let server = ReactorServer::bind("127.0.0.1:8080").await?;
    server.run().await
}
```

---

## 4. Rust ç‰¹æœ‰æ¨¡å¼

### 4.1 æ‰€æœ‰æƒæ¨¡å¼

#### 4.1.1 RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

/// RAIIæ–‡ä»¶å¤„ç†å™¨
pub struct FileHandler {
    file: File,
}

impl FileHandler {
    pub fn new(path: &str) -> io::Result<Self> {
        let file = File::create(path)?;
        println!("[RAII] File opened: {}", path);
        Ok(Self { file })
    }
    
    pub fn write_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.file.write_all(data)
    }
}

impl Drop for FileHandler {
    fn drop(&mut self) {
        println!("[RAII] File closed automatically");
        let _ = self.file.flush();
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn raii_example() -> io::Result<()> {
    {
        let mut handler = FileHandler::new("test.txt")?;
        handler.write_data(b"Hello, RAII!")?;
    } // handleråœ¨æ­¤å¤„è‡ªåŠ¨dropï¼Œæ–‡ä»¶å…³é—­
    
    Ok(())
}
```

### 4.2 ç±»å‹ç³»ç»Ÿæ¨¡å¼

#### 4.2.1 Newtype Pattern (æ–°ç±»å‹æ¨¡å¼)

```rust
/// æ–°ç±»å‹ï¼šç”¨æˆ·ID
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct UserId(pub u64);

/// æ–°ç±»å‹ï¼šè®¢å•ID
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct OrderId(pub u64);

/// ç”¨æˆ·æœåŠ¡
pub struct UserService;

impl UserService {
    pub fn get_user(&self, id: UserId) -> Option<String> {
        println!("[UserService] Getting user {:?}", id);
        Some(format!("User-{}", id.0))
    }
}

/// è®¢å•æœåŠ¡
pub struct OrderService;

impl OrderService {
    pub fn get_order(&self, id: OrderId) -> Option<String> {
        println!("[OrderService] Getting order {:?}", id);
        Some(format!("Order-{}", id.0))
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn newtype_example() {
    let user_service = UserService;
    let order_service = OrderService;
    
    let user_id = UserId(123);
    let order_id = OrderId(456);
    
    user_service.get_user(user_id);
    order_service.get_order(order_id);
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // user_service.get_user(order_id); // ç¼–è¯‘å¤±è´¥
}
```

#### 4.2.2 Typestate Pattern (ç±»å‹çŠ¶æ€æ¨¡å¼)

```rust
use std::marker::PhantomData;

/// çŠ¶æ€æ ‡è®°
pub mod db_state {
    pub struct Disconnected;
    pub struct Connected;
    pub struct InTransaction;
}

/// ç±»å‹çŠ¶æ€çš„æ•°æ®åº“è¿æ¥
pub struct DatabaseConnection<S> {
    connection_string: String,
    _state: PhantomData<S>,
}

impl DatabaseConnection<db_state::Disconnected> {
    pub fn new(connection_string: String) -> Self {
        Self {
            connection_string,
            _state: PhantomData,
        }
    }
    
    pub fn connect(self) -> Result<DatabaseConnection<db_state::Connected>, String> {
        println!("[DB] Connecting to {}", self.connection_string);
        Ok(DatabaseConnection {
            connection_string: self.connection_string,
            _state: PhantomData,
        })
    }
}

impl DatabaseConnection<db_state::Connected> {
    pub fn begin_transaction(self) -> DatabaseConnection<db_state::InTransaction> {
        println!("[DB] Beginning transaction");
        DatabaseConnection {
            connection_string: self.connection_string,
            _state: PhantomData,
        }
    }
    
    pub fn disconnect(self) -> DatabaseConnection<db_state::Disconnected> {
        println!("[DB] Disconnecting");
        DatabaseConnection {
            connection_string: self.connection_string,
            _state: PhantomData,
        }
    }
}

impl DatabaseConnection<db_state::InTransaction> {
    pub fn commit(self) -> DatabaseConnection<db_state::Connected> {
        println!("[DB] Committing transaction");
        DatabaseConnection {
            connection_string: self.connection_string,
            _state: PhantomData,
        }
    }
    
    pub fn rollback(self) -> DatabaseConnection<db_state::Connected> {
        println!("[DB] Rolling back transaction");
        DatabaseConnection {
            connection_string: self.connection_string,
            _state: PhantomData,
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn typestate_example() -> Result<(), String> {
    let db = DatabaseConnection::new("postgres://localhost".to_string());
    let db = db.connect()?;
    let db = db.begin_transaction();
    let db = db.commit();
    let _db = db.disconnect();
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šçŠ¶æ€ä¸å¯¹
    // let db = DatabaseConnection::new("...".to_string());
    // db.begin_transaction(); // ç¼–è¯‘å¤±è´¥ï¼šæœªè¿æ¥
    
    Ok(())
}
```

---

## 5. æ¶æ„æ¨¡å¼ (Architectural Patterns)

### 5.1 åˆ†å±‚æ¶æ„ (Layered Architecture)

```rust
// ============ Domain Layer ============
pub mod domain {
    #[derive(Debug, Clone)]
    pub struct User {
        pub id: u64,
        pub name: String,
        pub email: String,
    }
    
    pub trait UserRepository {
        fn find_by_id(&self, id: u64) -> Option<User>;
        fn save(&mut self, user: User) -> Result<(), String>;
    }
}

// ============ Infrastructure Layer ============
pub mod infrastructure {
    use super::domain::{User, UserRepository};
    use std::collections::HashMap;
    
    pub struct InMemoryUserRepository {
        users: HashMap<u64, User>,
    }
    
    impl InMemoryUserRepository {
        pub fn new() -> Self {
            Self {
                users: HashMap::new(),
            }
        }
    }
    
    impl UserRepository for InMemoryUserRepository {
        fn find_by_id(&self, id: u64) -> Option<User> {
            self.users.get(&id).cloned()
        }
        
        fn save(&mut self, user: User) -> Result<(), String> {
            self.users.insert(user.id, user);
            Ok(())
        }
    }
}

// ============ Application Layer ============
pub mod application {
    use super::domain::{User, UserRepository};
    
    pub struct UserService<R: UserRepository> {
        repository: R,
    }
    
    impl<R: UserRepository> UserService<R> {
        pub fn new(repository: R) -> Self {
            Self { repository }
        }
        
        pub fn get_user(&self, id: u64) -> Option<User> {
            self.repository.find_by_id(id)
        }
        
        pub fn create_user(&mut self, id: u64, name: String, email: String) -> Result<User, String> {
            let user = User { id, name, email };
            self.repository.save(user.clone())?;
            Ok(user)
        }
    }
}

// ============ Presentation Layer ============
pub mod presentation {
    use super::application::UserService;
    use super::domain::UserRepository;
    
    pub struct UserController<R: UserRepository> {
        service: UserService<R>,
    }
    
    impl<R: UserRepository> UserController<R> {
        pub fn new(service: UserService<R>) -> Self {
            Self { service }
        }
        
        pub fn handle_get_user(&self, id: u64) -> String {
            match self.service.get_user(id) {
                Some(user) => format!("User: {:?}", user),
                None => "User not found".to_string(),
            }
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn layered_architecture_example() {
    use infrastructure::InMemoryUserRepository;
    use application::UserService;
    use presentation::UserController;
    
    let repository = InMemoryUserRepository::new();
    let mut service = UserService::new(repository);
    
    // åˆ›å»ºç”¨æˆ·
    service.create_user(1, "Alice".to_string(), "alice@example.com".to_string()).unwrap();
    
    let controller = UserController::new(service);
    
    // å¤„ç†è¯·æ±‚
    let response = controller.handle_get_user(1);
    println!("{}", response);
}
```

---

## 6. æ¨¡å¼åˆ†ç±»çŸ©é˜µ

| åˆ†ç±» | GoFæ¨¡å¼ | å¹¶å‘æ¨¡å¼ | Rustç‰¹æœ‰ | æ¶æ„æ¨¡å¼ |
|------|---------|----------|----------|----------|
| **åˆ›å»ºå‹** | Singleton, Factory, Builder, Prototype, Abstract Factory | - | - | - |
| **ç»“æ„å‹** | Adapter, Decorator, Proxy, Facade, Composite, Flyweight, Bridge | - | Newtype | Layered |
| **è¡Œä¸ºå‹** | Observer, Strategy, Command, State, Iterator, Template Method, Visitor, Chain of Responsibility, Mediator, Memento, Interpreter | - | - | Event-Driven |
| **å¹¶å‘** | - | Mutex, RwLock, Semaphore, Barrier | - | - |
| **æ¶ˆæ¯ä¼ é€’** | - | Actor, Channel, Pipeline | - | Message Bus |
| **å¼‚æ­¥** | - | Future, Reactor, Proactor | async/await | Event Loop |
| **æ‰€æœ‰æƒ** | - | - | RAII, Move Semantics, Borrow Checker | - |
| **ç±»å‹** | - | - | Typestate, Phantom Type, GATs | - |

---

## 7. æ¨¡å¼å…³ç³»å›¾è°±

```text
è®¾è®¡æ¨¡å¼ç”Ÿæ€ç³»ç»Ÿ
â”‚
â”œâ”€ GoF ç»å…¸æ¨¡å¼ (23ç§)
â”‚  â”œâ”€ åˆ›å»ºå‹ (5) â†’ å¯¹è±¡åˆ›å»º
â”‚  â”œâ”€ ç»“æ„å‹ (7) â†’ å¯¹è±¡ç»„åˆ
â”‚  â””â”€ è¡Œä¸ºå‹ (11) â†’ å¯¹è±¡äº¤äº’
â”‚
â”œâ”€ å¹¶å‘æ¨¡å¼
â”‚  â”œâ”€ å…±äº«çŠ¶æ€ â†’ Mutex, RwLock, Atomic
â”‚  â”œâ”€ æ¶ˆæ¯ä¼ é€’ â†’ Actor, Channel, Pipeline
â”‚  â””â”€ å¼‚æ­¥ç¼–ç¨‹ â†’ Future, async/await, Reactor
â”‚
â”œâ”€ Rust ç‰¹æœ‰æ¨¡å¼
â”‚  â”œâ”€ æ‰€æœ‰æƒ â†’ RAII, Move, Borrow
â”‚  â”œâ”€ ç±»å‹ç³»ç»Ÿ â†’ Newtype, Typestate, Phantom
â”‚  â””â”€ ç”Ÿå‘½å‘¨æœŸ â†’ 'static, 'a, Lifetime Elision
â”‚
â””â”€ æ¶æ„æ¨¡å¼
   â”œâ”€ åˆ†å±‚æ¶æ„ â†’ Domain, Application, Infrastructure
   â”œâ”€ å¾®æœåŠ¡ â†’ Service Mesh, API Gateway
   â””â”€ äº‹ä»¶é©±åŠ¨ â†’ Event Sourcing, CQRS
```

---

## ğŸ“š ç›¸å…³èµ„æº

- **Tier 2**: [å®è·µæŒ‡å—](../tier_02_guides/)
- **Tier 4**: [å½¢å¼åŒ–ç†è®º](../tier_04_advanced/)
- **ä»£ç ç¤ºä¾‹**: [examples/](../../examples/)
- **åŸºå‡†æµ‹è¯•**: [benches/](../../benches/)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-23
