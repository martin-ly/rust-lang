# 模式使用快速参考

> **文档定位**: Tier 3 技术参考
> **最后更新**: 2025-12-25
> **Rust版本**: 1.92.0+ (Edition 2024)

## 📋 目录

- [模式使用快速参考](#模式使用快速参考)
  - [📋 目录](#-目录)
  - [使用说明](#使用说明)
  - [创建型模式](#创建型模式)
    - [Singleton（单例模式）](#singleton单例模式)
    - [Factory Method（工厂方法）](#factory-method工厂方法)
    - [Abstract Factory（抽象工厂）](#abstract-factory抽象工厂)
    - [Builder（建造者）](#builder建造者)
    - [Prototype（原型）](#prototype原型)
  - [结构型模式](#结构型模式)
    - [Adapter（适配器）](#adapter适配器)
    - [Decorator（装饰器）](#decorator装饰器)
    - [Proxy（代理）](#proxy代理)
    - [Facade（外观）](#facade外观)
    - [Flyweight（享元）](#flyweight享元)
    - [Bridge（桥接）](#bridge桥接)
    - [Composite（组合）](#composite组合)
  - [行为型模式](#行为型模式)
    - [Observer（观察者）](#observer观察者)
    - [Strategy（策略）](#strategy策略)
    - [Command（命令）](#command命令)
    - [State（状态）](#state状态)
    - [Chain of Responsibility（责任链）](#chain-of-responsibility责任链)
    - [Iterator（迭代器）](#iterator迭代器)
    - [Mediator（中介者）](#mediator中介者)
    - [Memento（备忘录）](#memento备忘录)
    - [Template Method（模板方法）](#template-method模板方法)
    - [Visitor（访问者）](#visitor访问者)
    - [Interpreter（解释器）](#interpreter解释器)
  - [并发模式](#并发模式)
    - [Actor（Actor模式）](#actoractor模式)
    - [Reactor（Reactor模式）](#reactorreactor模式)
    - [Producer-Consumer（生产者-消费者）](#producer-consumer生产者-消费者)
    - [Circuit Breaker（断路器）](#circuit-breaker断路器)
  - [📚 相关资源](#-相关资源)

---

## 使用说明

本文档为每个设计模式提供快速参考，包括：

- ✅ **何时使用**: 适合使用该模式的场景
- ❌ **何时避免**: 不适合使用该模式的场景
- 📊 **复杂度**: 时间/空间复杂度（O表示法）
- 🔒 **线程安全**: 线程安全性说明
- 💡 **Rust特性**: Rust中的特殊实现要点

**复杂度说明**:

- **时间复杂度**: 操作的时间复杂度
- **空间复杂度**: 内存使用复杂度
- **实现复杂度**: 代码实现的难度（低/中/高）

**线程安全说明**:

- ✅ **线程安全**: 可在多线程环境中安全使用
- ⚠️ **需要同步**: 需要额外的同步机制
- ❌ **非线程安全**: 单线程使用或需要外部同步

---

## 创建型模式

### Singleton（单例模式）

**何时使用** ✅:

- 需要全局唯一的实例（配置、日志、连接池）
- 需要控制资源访问（文件、网络连接）
- 需要延迟初始化

**何时避免** ❌:

- 过度使用导致全局状态难以测试
- 需要依赖注入的场景
- 多实例更合适的场景

**复杂度**:

- **时间复杂度**: O(1) - 获取实例
- **空间复杂度**: O(1) - 单实例
- **实现复杂度**: 中（需要考虑线程安全）

**线程安全**:

- ✅ **线程安全**: 使用 `OnceLock` 或 `LazyLock`（Rust 1.70+）
- ⚠️ **需要同步**: 使用 `Mutex` 或 `RwLock` 包装
- **Rust实现**: `std::sync::OnceLock`（推荐）

**Rust特性**:

- 使用 `OnceLock` 实现线程安全的单例
- 避免全局可变状态，优先使用不可变单例

---

### Factory Method（工厂方法）

**何时使用** ✅:

- 需要根据条件创建不同类型的对象
- 创建逻辑复杂，需要封装
- 需要解耦创建者和具体产品

**何时避免** ❌:

- 简单对象创建（直接 `new` 即可）
- 只有一种产品类型
- 过度抽象增加复杂度

**复杂度**:

- **时间复杂度**: O(1) - 创建对象
- **空间复杂度**: O(1) - 产品对象
- **实现复杂度**: 低

**线程安全**:

- ✅ **线程安全**: Trait 方法默认线程安全（如果产品类型是 `Send + Sync`）
- **Rust实现**: 使用 Trait 定义工厂接口

**Rust特性**:

- 使用 Trait 定义工厂接口
- 泛型工厂支持零成本抽象

---

### Abstract Factory（抽象工厂）

**何时使用** ✅:

- 需要创建一系列相关对象
- 需要保证产品之间的兼容性
- 需要支持多种产品族

**何时避免** ❌:

- 只有一种产品类型（使用 Factory Method）
- 产品族变化频繁（增加复杂度）
- 简单场景（过度设计）

**复杂度**:

- **时间复杂度**: O(1) - 创建产品族
- **空间复杂度**: O(n) - n 个产品
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果工厂和产品都是 `Send + Sync`
- **Rust实现**: 使用 Trait 定义抽象工厂

**Rust特性**:

- 使用关联类型定义产品族
- 枚举实现支持多种产品族

---

### Builder（建造者）

**何时使用** ✅:

- 对象构造参数多且可选
- 需要分步构建复杂对象
- 需要保证构造的完整性（Typestate）

**何时避免** ❌:

- 构造参数少且固定（直接构造）
- 简单对象（过度设计）
- 性能敏感场景（Builder 有额外开销）

**复杂度**:

- **时间复杂度**: O(n) - n 个构建步骤
- **空间复杂度**: O(1) - Builder 状态
- **实现复杂度**: 中

**线程安全**:

- ⚠️ **需要同步**: Builder 通常不是线程安全的
- **Rust实现**: 使用移动语义，避免共享可变状态

**Rust特性**:

- Typestate Builder：编译时保证必填字段
- 链式调用：返回 `Self` 实现流畅接口

---

### Prototype（原型）

**何时使用** ✅:

- 对象创建成本高（数据库查询、网络请求）
- 需要创建相似对象
- 运行时确定对象类型

**何时避免** ❌:

- 对象创建成本低（直接创建即可）
- 对象差异大（不适合克隆）
- 需要深拷贝但性能敏感

**复杂度**:

- **时间复杂度**: O(n) - 克隆对象（取决于大小）
- **空间复杂度**: O(n) - 克隆对象
- **实现复杂度**: 低（使用 `Clone` trait）

**线程安全**:

- ✅ **线程安全**: `Clone` trait 默认线程安全
- **Rust实现**: 使用 `Clone` trait

**Rust特性**:

- 使用 `Clone` trait 实现原型
- 考虑深拷贝 vs 浅拷贝的性能

---

## 结构型模式

### Adapter（适配器）

**何时使用** ✅:

- 需要适配不兼容的接口
- 集成第三方库
- 版本兼容（新旧 API）

**何时避免** ❌:

- 可以直接修改接口（优先修改）
- 适配器过多（考虑重构）
- 性能敏感（适配器有开销）

**复杂度**:

- **时间复杂度**: O(1) - 适配调用
- **空间复杂度**: O(1) - 适配器对象
- **实现复杂度**: 低

**线程安全**:

- ✅ **线程安全**: 如果适配对象是 `Send + Sync`
- **Rust实现**: 使用 Trait 实现适配

**Rust特性**:

- 使用 Trait 实现接口适配
- 支持 `dyn` 上行转型（Rust 1.90+）

---

### Decorator（装饰器）

**何时使用** ✅:

- 需要动态添加功能
- 需要组合多个功能
- 避免子类爆炸

**何时避免** ❌:

- 功能固定（直接实现）
- 装饰器链过长（难以理解）
- 性能敏感（装饰器有开销）

**复杂度**:

- **时间复杂度**: O(n) - n 层装饰
- **空间复杂度**: O(n) - 装饰器链
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果装饰对象是 `Send + Sync`
- **Rust实现**: 使用组合和 Trait

**Rust特性**:

- 使用组合而非继承
- Trait 对象支持动态装饰

---

### Proxy（代理）

**何时使用** ✅:

- 需要控制对象访问（延迟加载、权限检查）
- 需要添加额外功能（缓存、日志）
- 需要远程访问（RPC）

**何时避免** ❌:

- 直接访问即可（不需要代理）
- 代理开销过大
- 过度抽象

**复杂度**:

- **时间复杂度**: O(1) - 代理调用（可能增加缓存查找）
- **空间复杂度**: O(1) - 代理对象
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果代理对象是 `Send + Sync`
- ⚠️ **需要同步**: 缓存代理需要同步机制
- **Rust实现**: 使用 `Arc`、`Mutex` 实现智能指针代理

**Rust特性**:

- 使用智能指针（`Box`、`Arc`、`Rc`）实现代理
- 支持零成本抽象（编译时多态）

---

### Facade（外观）

**何时使用** ✅:

- 需要简化复杂子系统接口
- 需要隐藏实现细节
- 需要统一入口

**何时避免** ❌:

- 子系统简单（不需要外观）
- 需要直接访问子系统
- 外观过于复杂（考虑重构）

**复杂度**:

- **时间复杂度**: O(1) - 外观调用（内部可能 O(n)）
- **空间复杂度**: O(1) - 外观对象
- **实现复杂度**: 低

**线程安全**:

- ✅ **线程安全**: 如果子系统是 `Send + Sync`
- **Rust实现**: 组合子系统，提供统一接口

**Rust特性**:

- 使用模块系统实现外观
- 组合多个 Trait 提供统一接口

---

### Flyweight（享元）

**何时使用** ✅:

- 大量相似对象（共享内部状态）
- 内存受限场景
- 对象状态可分（内部/外部）

**何时避免** ❌:

- 对象差异大（不适合共享）
- 内存充足（不需要优化）
- 共享状态管理复杂

**复杂度**:

- **时间复杂度**: O(1) - 获取享元（可能 O(log n) 查找）
- **空间复杂度**: O(n) - n 个唯一享元
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 使用 `Arc` 共享享元
- ⚠️ **需要同步**: 享元工厂需要同步
- **Rust实现**: 使用 `Arc`、`HashMap` 实现享元池

**Rust特性**:

- 使用 `Arc` 共享不可变状态
- `HashMap` 实现享元工厂

---

### Bridge（桥接）

**何时使用** ✅:

- 需要分离抽象和实现
- 需要在运行时切换实现
- 需要避免类爆炸

**何时避免** ❌:

- 抽象和实现耦合（不需要分离）
- 实现固定（不需要桥接）
- 过度抽象

**复杂度**:

- **时间复杂度**: O(1) - 桥接调用
- **空间复杂度**: O(1) - 桥接对象
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果实现是 `Send + Sync`
- **Rust实现**: 使用 Trait 定义实现接口

**Rust特性**:

- 使用 Trait 分离抽象和实现
- 支持运行时多态（Trait 对象）

---

### Composite（组合）

**何时使用** ✅:

- 需要表示树形结构
- 需要统一处理单个对象和组合对象
- 需要递归结构

**何时避免** ❌:

- 结构简单（不需要组合）
- 性能敏感（递归有开销）
- 过度抽象

**复杂度**:

- **时间复杂度**: O(n) - 遍历树（n 个节点）
- **空间复杂度**: O(n) - 树结构
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果节点是 `Send + Sync`
- ⚠️ **需要同步**: 修改树结构需要同步
- **Rust实现**: 使用 `Vec`、`Rc` 实现树结构

**Rust特性**:

- 使用 `Rc` 或 `Arc` 实现共享所有权
- 使用枚举表示叶子节点和组合节点

---

## 行为型模式

### Observer（观察者）

**何时使用** ✅:

- 需要一对多依赖关系
- 需要解耦发布者和订阅者
- 需要事件驱动架构

**何时避免** ❌:

- 依赖关系简单（直接调用）
- 观察者过多（性能问题）
- 循环依赖风险

**复杂度**:

- **时间复杂度**: O(n) - n 个观察者
- **空间复杂度**: O(n) - 观察者列表
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 使用 `Arc<Mutex<Vec<Observer>>>`
- ⚠️ **需要同步**: 观察者列表需要同步
- **Rust实现**: 使用 Channel（`mpsc`）实现异步观察者

**Rust特性**:

- 使用 GATs（Rust 1.65+）实现借用观察者
- 使用 Channel 实现异步事件总线

---

### Strategy（策略）

**何时使用** ✅:

- 需要运行时选择算法
- 需要避免 if-else 链
- 需要扩展算法

**何时避免** ❌:

- 算法固定（直接实现）
- 策略过多（难以管理）
- 性能敏感（Trait 对象有开销）

**复杂度**:

- **时间复杂度**: O(1) - 策略调用（算法复杂度取决于策略）
- **空间复杂度**: O(1) - 策略对象
- **实现复杂度**: 低

**线程安全**:

- ✅ **线程安全**: 如果策略是 `Send + Sync`
- **Rust实现**: 使用 Trait 定义策略，泛型实现零成本抽象

**Rust特性**:

- 泛型策略：编译时多态，零成本
- Trait 对象策略：运行时多态，灵活但有一定开销

---

### Command（命令）

**何时使用** ✅:

- 需要撤销/重做功能
- 需要队列化请求
- 需要解耦调用者和接收者

**何时避免** ❌:

- 操作简单（直接调用）
- 不需要撤销功能
- 性能敏感（命令对象有开销）

**复杂度**:

- **时间复杂度**: O(1) - 执行命令（操作复杂度取决于命令）
- **空间复杂度**: O(n) - n 个命令对象
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果命令是 `Send + Sync`
- ⚠️ **需要同步**: 命令队列需要同步
- **Rust实现**: 使用 `Arc<dyn Command>` 实现命令对象

**Rust特性**:

- 使用闭包实现简单命令
- Trait 对象实现复杂命令

---

### State（状态）

**何时使用** ✅:

- 对象行为依赖于状态
- 需要状态转换
- 需要避免大量 if-else

**何时避免** ❌:

- 状态简单（直接判断）
- 状态转换复杂（难以管理）
- 性能敏感（状态对象有开销）

**复杂度**:

- **时间复杂度**: O(1) - 状态转换
- **空间复杂度**: O(n) - n 个状态对象
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果状态是 `Send + Sync`
- **Rust实现**: 使用 Trait 定义状态，枚举实现类型级状态机

**Rust特性**:

- Typestate 模式：编译时状态验证
- Trait 对象：运行时状态机

---

### Chain of Responsibility（责任链）

**何时使用** ✅:

- 需要多个对象处理请求
- 需要动态决定处理器
- 需要解耦发送者和接收者

**何时避免** ❌:

- 处理器固定（直接调用）
- 链过长（性能问题）
- 难以调试（请求传递路径不明确）

**复杂度**:

- **时间复杂度**: O(n) - n 个处理器
- **空间复杂度**: O(n) - 处理器链
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果处理器是 `Send + Sync`
- **Rust实现**: 使用 `Option<Box<Handler>>` 实现链

**Rust特性**:

- 使用 `Option` 和 `Box` 实现链式结构
- 支持提前终止（`let-else`，Rust 1.65+）

---

### Iterator（迭代器）

**何时使用** ✅:

- 需要遍历集合
- 需要统一遍历接口
- 需要延迟计算

**何时避免** ❌:

- 简单遍历（直接 for 循环）
- 性能敏感（迭代器有开销）
- 需要随机访问（迭代器是顺序的）

**复杂度**:

- **时间复杂度**: O(n) - 遍历 n 个元素
- **空间复杂度**: O(1) - 迭代器状态
- **实现复杂度**: 低（Rust 内置支持）

**线程安全**:

- ✅ **线程安全**: Rust 迭代器默认线程安全（如果元素是 `Send`）
- **Rust实现**: 实现 `Iterator` trait

**Rust特性**:

- Rust 内置 `Iterator` trait
- 支持零成本抽象（编译时优化）
- 支持链式操作（`map`、`filter`、`fold`）

---

### Mediator（中介者）

**何时使用** ✅:

- 对象间通信复杂
- 需要解耦对象
- 需要集中控制交互

**何时避免** ❌:

- 对象间通信简单（直接通信）
- 中介者过于复杂（成为上帝对象）
- 性能敏感（中介者有开销）

**复杂度**:

- **时间复杂度**: O(1) - 中介调用（可能 O(n) 通知）
- **空间复杂度**: O(n) - n 个对象引用
- **实现复杂度**: 高

**线程安全**:

- ✅ **线程安全**: 如果对象是 `Send + Sync`
- ⚠️ **需要同步**: 中介者需要同步
- **Rust实现**: 使用 `Arc`、`Mutex` 实现中介者

**Rust特性**:

- 使用 `Arc` 实现对象共享
- 使用 Channel 实现异步中介

---

### Memento（备忘录）

**何时使用** ✅:

- 需要保存对象状态
- 需要撤销功能
- 需要快照功能

**何时避免** ❌:

- 状态简单（不需要快照）
- 状态过大（内存问题）
- 性能敏感（序列化有开销）

**复杂度**:

- **时间复杂度**: O(n) - 保存/恢复状态（n 是状态大小）
- **空间复杂度**: O(n) - 状态快照
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 如果状态是 `Send + Sync`
- **Rust实现**: 使用 `Clone` 实现快照

**Rust特性**:

- 使用 `Clone` trait 实现快照
- 考虑深拷贝 vs 浅拷贝

---

### Template Method（模板方法）

**何时使用** ✅:

- 算法骨架固定，步骤可变
- 需要代码复用
- 需要控制算法流程

**何时避免** ❌:

- 算法步骤不固定（不适合模板）
- 过度抽象
- 性能敏感（虚函数调用有开销）

**复杂度**:

- **时间复杂度**: O(1) - 模板调用（算法复杂度取决于步骤）
- **空间复杂度**: O(1) - 模板对象
- **实现复杂度**: 低

**线程安全**:

- ✅ **线程安全**: 如果模板是 `Send + Sync`
- **Rust实现**: 使用 Trait 定义模板方法

**Rust特性**:

- 使用 Trait 定义模板方法
- 默认实现提供算法骨架

---

### Visitor（访问者）

**何时使用** ✅:

- 需要对对象结构进行操作
- 需要分离算法和结构
- 需要扩展操作而不修改结构

**何时避免** ❌:

- 结构稳定（直接实现操作）
- 访问者过多（难以管理）
- 性能敏感（双重分发有开销）

**复杂度**:

- **时间复杂度**: O(n) - 遍历结构（n 个节点）
- **空间复杂度**: O(1) - 访问者对象
- **实现复杂度**: 高

**线程安全**:

- ✅ **线程安全**: 如果访问者和结构是 `Send + Sync`
- **Rust实现**: 使用 Trait 定义访问者接口

**Rust特性**:

- 使用 Trait 实现访问者模式
- 支持泛型访问者（零成本抽象）

---

### Interpreter（解释器）

**何时使用** ✅:

- 需要解释简单语言
- 需要定义语法规则
- 需要灵活扩展语法

**何时避免** ❌:

- 语法复杂（使用解析器生成器）
- 性能敏感（解释执行慢）
- 已有解析库（不需要自己实现）

**复杂度**:

- **时间复杂度**: O(n) - 解释表达式（n 是表达式大小）
- **空间复杂度**: O(n) - 表达式树
- **实现复杂度**: 高

**线程安全**:

- ✅ **线程安全**: 如果解释器是 `Send + Sync`
- **Rust实现**: 使用枚举实现表达式树

**Rust特性**:

- 使用枚举实现表达式树
- 模式匹配实现解释逻辑

---

## 并发模式

### Actor（Actor模式）

**何时使用** ✅:

- 需要消息传递并发
- 需要隔离状态
- 需要高并发处理

**何时避免** ❌:

- 需要共享状态（不适合 Actor）
- 性能敏感（消息传递有开销）
- 简单场景（过度设计）

**复杂度**:

- **时间复杂度**: O(1) - 发送消息（处理复杂度取决于 Actor）
- **空间复杂度**: O(n) - n 个 Actor
- **实现复杂度**: 高

**线程安全**:

- ✅ **线程安全**: Actor 模型天然线程安全（消息传递）
- **Rust实现**: 使用 Channel（`mpsc`）实现 Actor

**Rust特性**:

- 使用 `tokio::sync::mpsc` 实现异步 Actor
- 使用 `async/await` 实现 Actor 行为

---

### Reactor（Reactor模式）

**何时使用** ✅:

- 需要事件驱动 I/O
- 需要高并发 I/O
- 需要单线程事件循环

**何时避免** ❌:

- CPU 密集型（不适合 Reactor）
- 需要阻塞操作（不适合 Reactor）
- 简单场景（过度设计）

**复杂度**:

- **时间复杂度**: O(n) - n 个事件
- **空间复杂度**: O(n) - 事件队列
- **实现复杂度**: 高

**线程安全**:

- ✅ **线程安全**: Reactor 通常单线程，但支持多线程事件源
- **Rust实现**: 使用 `tokio` 实现 Reactor

**Rust特性**:

- Rust 的 `tokio` 实现了 Reactor 模式
- 使用 `async/await` 实现事件处理

---

### Producer-Consumer（生产者-消费者）

**何时使用** ✅:

- 需要解耦生产者和消费者
- 需要缓冲数据
- 需要控制流量（背压）

**何时避免** ❌:

- 生产消费同步（直接调用）
- 性能敏感（Channel 有开销）
- 简单场景（过度设计）

**复杂度**:

- **时间复杂度**: O(1) - 发送/接收（可能阻塞）
- **空间复杂度**: O(n) - Channel 缓冲区
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: Channel 天然线程安全
- **Rust实现**: 使用 `std::sync::mpsc` 或 `tokio::sync::mpsc`

**Rust特性**:

- Rust 的 Channel 实现了生产者-消费者模式
- 支持有界/无界 Channel
- 支持背压控制

---

### Circuit Breaker（断路器）

**何时使用** ✅:

- 需要保护下游服务
- 需要快速失败
- 需要自动恢复

**何时避免** ❌:

- 服务稳定（不需要断路器）
- 性能敏感（断路器有开销）
- 简单场景（过度设计）

**复杂度**:

- **时间复杂度**: O(1) - 断路器检查
- **空间复杂度**: O(1) - 断路器状态
- **实现复杂度**: 中

**线程安全**:

- ✅ **线程安全**: 使用原子操作和锁实现线程安全
- **Rust实现**: 使用 `AtomicU64`、`Mutex` 实现断路器

**Rust特性**:

- 使用原子操作实现计数器
- 使用 `Mutex` 保护状态转换

---

## 📚 相关资源

- **Tier 2**: [实践指南](../tier_02_guides/)
- **Tier 3-05**: [模式选择最佳实践](./05_模式选择最佳实践.md)
- **Tier 4**: [形式化理论](../tier_04_advanced/)

---

_本文档提供了每个设计模式的快速参考。如需详细了解，请参阅相应的实践指南和理论文档。_
