# æ¨¡å¼å®ç°å¯¹æ¯”å‚è€ƒ

> **æ–‡æ¡£å®šä½**: Tier 3 æŠ€æœ¯å‚è€ƒ  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [æ¨¡å¼å®ç°å¯¹æ¯”å‚è€ƒ](#æ¨¡å¼å®ç°å¯¹æ¯”å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 å¯¹æ¯”ç»´åº¦](#11-å¯¹æ¯”ç»´åº¦)
  - [2. Trait vs æ³›å‹å®ç°å¯¹æ¯”](#2-trait-vs-æ³›å‹å®ç°å¯¹æ¯”)
    - [2.1 Strategyæ¨¡å¼å¯¹æ¯”](#21-strategyæ¨¡å¼å¯¹æ¯”)
      - [æ–¹å¼ 1ï¼šTrait Object (åŠ¨æ€åˆ†æ´¾)](#æ–¹å¼-1trait-object-åŠ¨æ€åˆ†æ´¾)
      - [æ–¹å¼ 2ï¼šæ³›å‹ (é™æ€åˆ†æ´¾)](#æ–¹å¼-2æ³›å‹-é™æ€åˆ†æ´¾)
    - [2.2 æ€§èƒ½å¯¹æ¯”](#22-æ€§èƒ½å¯¹æ¯”)
  - [3. åŒæ­¥ vs å¼‚æ­¥å®ç°å¯¹æ¯”](#3-åŒæ­¥-vs-å¼‚æ­¥å®ç°å¯¹æ¯”)
    - [3.1 Observeræ¨¡å¼å¯¹æ¯”](#31-observeræ¨¡å¼å¯¹æ¯”)
      - [æ–¹å¼ 1ï¼šåŒæ­¥Observer](#æ–¹å¼-1åŒæ­¥observer)
      - [æ–¹å¼ 2ï¼šå¼‚æ­¥Observer](#æ–¹å¼-2å¼‚æ­¥observer)
    - [3.2 æ€§èƒ½å¯¹æ¯”](#32-æ€§èƒ½å¯¹æ¯”)
  - [4. é™æ€ vs åŠ¨æ€åˆ†æ´¾å¯¹æ¯”](#4-é™æ€-vs-åŠ¨æ€åˆ†æ´¾å¯¹æ¯”)
    - [4.1 å·¥å‚æ¨¡å¼å¯¹æ¯”](#41-å·¥å‚æ¨¡å¼å¯¹æ¯”)
      - [é™æ€åˆ†æ´¾ (æšä¸¾)](#é™æ€åˆ†æ´¾-æšä¸¾)
      - [åŠ¨æ€åˆ†æ´¾ (Trait Object)](#åŠ¨æ€åˆ†æ´¾-trait-object)
  - [5. å•çº¿ç¨‹ vs å¤šçº¿ç¨‹å®ç°å¯¹æ¯”](#5-å•çº¿ç¨‹-vs-å¤šçº¿ç¨‹å®ç°å¯¹æ¯”)
    - [5.1 å•ä¾‹æ¨¡å¼å¯¹æ¯”](#51-å•ä¾‹æ¨¡å¼å¯¹æ¯”)
      - [å•çº¿ç¨‹å•ä¾‹](#å•çº¿ç¨‹å•ä¾‹)
      - [å¤šçº¿ç¨‹å•ä¾‹](#å¤šçº¿ç¨‹å•ä¾‹)
    - [5.2 æ€§èƒ½å¯¹æ¯”](#52-æ€§èƒ½å¯¹æ¯”)
  - [6. é›¶æˆæœ¬ vs è¿è¡Œæ—¶æŠ½è±¡å¯¹æ¯”](#6-é›¶æˆæœ¬-vs-è¿è¡Œæ—¶æŠ½è±¡å¯¹æ¯”)
    - [6.1 è¿­ä»£å™¨æ¨¡å¼å¯¹æ¯”](#61-è¿­ä»£å™¨æ¨¡å¼å¯¹æ¯”)
      - [é›¶æˆæœ¬æŠ½è±¡ (æ³›å‹è¿­ä»£å™¨)](#é›¶æˆæœ¬æŠ½è±¡-æ³›å‹è¿­ä»£å™¨)
      - [è¿è¡Œæ—¶æŠ½è±¡ (Boxedè¿­ä»£å™¨)](#è¿è¡Œæ—¶æŠ½è±¡-boxedè¿­ä»£å™¨)
    - [6.2 æ€§èƒ½å¯¹æ¯”](#62-æ€§èƒ½å¯¹æ¯”)
  - [7. å†…å­˜æ¨¡å‹å¯¹æ¯”](#7-å†…å­˜æ¨¡å‹å¯¹æ¯”)
    - [7.1 æ‰€æœ‰æƒæ¨¡å¼å¯¹æ¯”](#71-æ‰€æœ‰æƒæ¨¡å¼å¯¹æ¯”)
      - [æ–¹å¼ 1ï¼šæ‰€æœ‰æƒè½¬ç§» (Move)](#æ–¹å¼-1æ‰€æœ‰æƒè½¬ç§»-move)
      - [æ–¹å¼ 2ï¼šä¸å¯å˜å€Ÿç”¨ (Borrow)](#æ–¹å¼-2ä¸å¯å˜å€Ÿç”¨-borrow)
      - [æ–¹å¼ 3ï¼šå¯å˜å€Ÿç”¨ (Mutable Borrow)](#æ–¹å¼-3å¯å˜å€Ÿç”¨-mutable-borrow)
      - [æ–¹å¼ 4ï¼šå…‹éš† (Clone)](#æ–¹å¼-4å…‹éš†-clone)
    - [7.2 å†…å­˜å¼€é”€å¯¹æ¯”](#72-å†…å­˜å¼€é”€å¯¹æ¯”)
  - [8. æ€§èƒ½å¼€é”€å¯¹æ¯”](#8-æ€§èƒ½å¼€é”€å¯¹æ¯”)
    - [8.1 ç»¼åˆæ€§èƒ½å¯¹æ¯”è¡¨](#81-ç»¼åˆæ€§èƒ½å¯¹æ¯”è¡¨)
    - [8.2 é€‰æ‹©å†³ç­–æ ‘](#82-é€‰æ‹©å†³ç­–æ ‘)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

Rust æä¾›äº†å¤šç§æ–¹å¼æ¥å®ç°è®¾è®¡æ¨¡å¼ï¼Œæ¯ç§æ–¹å¼éƒ½æœ‰å…¶æƒè¡¡ã€‚
æœ¬æ–‡æ¡£å¯¹æ¯”ä¸åŒå®ç°æ–¹å¼çš„ç‰¹ç‚¹ã€æ€§èƒ½å’Œé€‚ç”¨åœºæ™¯ã€‚

### 1.1 å¯¹æ¯”ç»´åº¦

| ç»´åº¦ | å…³æ³¨ç‚¹ | è¯„ä¼°æŒ‡æ ‡ |
|-----|--------|---------|
| **æ€§èƒ½** | æ‰§è¡Œé€Ÿåº¦ã€å†…å­˜å ç”¨ | ååé‡ã€å»¶è¿Ÿã€å†…å­˜å¼€é”€ |
| **çµæ´»æ€§** | æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§ | ä»£ç å¤æ‚åº¦ã€ä¿®æ”¹æˆæœ¬ |
| **ç±»å‹å®‰å…¨** | ç¼–è¯‘æ—¶æ£€æŸ¥ | ç±»å‹é”™è¯¯æ•è·ç‡ |
| **å¹¶å‘æ€§** | å¤šçº¿ç¨‹å®‰å…¨ | Send/Syncå®ç° |
| **å¯æµ‹è¯•æ€§** | å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯• | Mockæ”¯æŒã€æµ‹è¯•è¦†ç›–ç‡ |

---

## 2. Trait vs æ³›å‹å®ç°å¯¹æ¯”

### 2.1 Strategyæ¨¡å¼å¯¹æ¯”

#### æ–¹å¼ 1ï¼šTrait Object (åŠ¨æ€åˆ†æ´¾)

```rust
/// Strategyæ¥å£
pub trait CompressionStrategy {
    fn compress(&self, data: &[u8]) -> Vec<u8>;
}

/// å…·ä½“ç­–ç•¥
pub struct ZipCompression;
pub struct GzipCompression;

impl CompressionStrategy for ZipCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        // ZIPå‹ç¼©
        data.to_vec()
    }
}

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        // GZIPå‹ç¼©
        data.to_vec()
    }
}

/// ä¸Šä¸‹æ–‡ (åŠ¨æ€åˆ†æ´¾)
pub struct Compressor {
    strategy: Box<dyn CompressionStrategy>,
}

impl Compressor {
    pub fn new(strategy: Box<dyn CompressionStrategy>) -> Self {
        Self { strategy }
    }
    
    pub fn compress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.compress(data) // è™šå‡½æ•°è°ƒç”¨
    }
    
    pub fn set_strategy(&mut self, strategy: Box<dyn CompressionStrategy>) {
        self.strategy = strategy;
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn trait_object_example() {
    let mut compressor = Compressor::new(Box::new(ZipCompression));
    compressor.compress(b"data");
    
    // è¿è¡Œæ—¶åˆ‡æ¢ç­–ç•¥
    compressor.set_strategy(Box::new(GzipCompression));
    compressor.compress(b"data");
}
```

**ç‰¹ç‚¹**:

- âœ… è¿è¡Œæ—¶çµæ´»æ€§
- âœ… æ˜“äºæ‰©å±•
- âš ï¸ å †åˆ†é… (Box)
- âš ï¸ è™šå‡½æ•°è°ƒç”¨å¼€é”€ (~1-3ns)
- âš ï¸ æ— æ³•å†…è”

#### æ–¹å¼ 2ï¼šæ³›å‹ (é™æ€åˆ†æ´¾)

```rust
/// ä¸Šä¸‹æ–‡ (é™æ€åˆ†æ´¾)
pub struct GenericCompressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> GenericCompressor<S> {
    pub fn new(strategy: S) -> Self {
        Self { strategy }
    }
    
    pub fn compress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.compress(data) // ç›´æ¥è°ƒç”¨ï¼Œå¯å†…è”
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn generic_example() {
    let compressor1 = GenericCompressor::new(ZipCompression);
    compressor1.compress(b"data");
    
    let compressor2 = GenericCompressor::new(GzipCompression);
    compressor2.compress(b"data");
}
```

**ç‰¹ç‚¹**:

- âœ… é›¶æˆæœ¬æŠ½è±¡
- âœ… å¯å†…è”
- âœ… ç¼–è¯‘æ—¶å¤šæ€
- âš ï¸ ä»£ç è†¨èƒ€ (å•æ€åŒ–)
- âš ï¸ ä¸èƒ½è¿è¡Œæ—¶åˆ‡æ¢

### 2.2 æ€§èƒ½å¯¹æ¯”

| å®ç°æ–¹å¼ | è°ƒç”¨å¼€é”€ | å†…å­˜åˆ†é… | äºŒè¿›åˆ¶å¤§å° | çµæ´»æ€§ |
|---------|---------|---------|-----------|--------|
| **Trait Object** | 1-3ns (è™šå‡½æ•°) | å †åˆ†é… | å° | è¿è¡Œæ—¶ |
| **æ³›å‹** | 0ns (å†…è”) | æ ˆåˆ†é… | å¤§ (å•æ€åŒ–) | ç¼–è¯‘æ—¶ |

**åŸºå‡†æµ‹è¯•** (Criterion):

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn trait_object_benchmark(c: &mut Criterion) {
    let compressor = Compressor::new(Box::new(ZipCompression));
    let data = vec![0u8; 1024];
    
    c.bench_function("trait_object_compress", |b| {
        b.iter(|| compressor.compress(black_box(&data)))
    });
}

fn generic_benchmark(c: &mut Criterion) {
    let compressor = GenericCompressor::new(ZipCompression);
    let data = vec![0u8; 1024];
    
    c.bench_function("generic_compress", |b| {
        b.iter(|| compressor.compress(black_box(&data)))
    });
}

criterion_group!(benches, trait_object_benchmark, generic_benchmark);
criterion_main!(benches);
```

**å…¸å‹ç»“æœ**:

```text
trait_object_compress  time: [125.3 ns ... 128.7 ns]
generic_compress       time: [98.2 ns ... 101.5 ns]  (å¿« ~22%)
```

---

## 3. åŒæ­¥ vs å¼‚æ­¥å®ç°å¯¹æ¯”

### 3.1 Observeræ¨¡å¼å¯¹æ¯”

#### æ–¹å¼ 1ï¼šåŒæ­¥Observer

```rust
use std::sync::{Arc, Mutex};

pub trait Observer: Send + Sync {
    fn update(&self, data: &str);
}

pub struct Subject {
    observers: Arc<Mutex<Vec<Arc<dyn Observer>>>>,
}

impl Subject {
    pub fn new() -> Self {
        Self {
            observers: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    pub fn attach(&self, observer: Arc<dyn Observer>) {
        self.observers.lock().unwrap().push(observer);
    }
    
    pub fn notify(&self, data: &str) {
        let observers = self.observers.lock().unwrap();
        for observer in observers.iter() {
            observer.update(data); // åŒæ­¥è°ƒç”¨ï¼Œé˜»å¡
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn sync_observer_example() {
    let subject = Subject::new();
    
    // å‡è®¾è§‚å¯Ÿè€…å¤„ç†è€—æ—¶ 10ms
    subject.notify("event"); // é˜»å¡ 10ms * Nä¸ªè§‚å¯Ÿè€…
}
```

**ç‰¹ç‚¹**:

- âœ… å®ç°ç®€å•
- âœ… é¡ºåºä¿è¯
- âš ï¸ é˜»å¡æ‰§è¡Œ
- âš ï¸ æ…¢è§‚å¯Ÿè€…æ‹–ç´¯æ•´ä½“æ€§èƒ½

#### æ–¹å¼ 2ï¼šå¼‚æ­¥Observer

```rust
use tokio::sync::{mpsc, RwLock};
use std::sync::Arc;

pub trait AsyncObserver: Send + Sync {
    async fn update(&self, data: String);
}

pub struct AsyncSubject {
    observers: Arc<RwLock<Vec<Arc<dyn AsyncObserver>>>>,
}

impl AsyncSubject {
    pub fn new() -> Self {
        Self {
            observers: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    pub async fn attach(&self, observer: Arc<dyn AsyncObserver>) {
        self.observers.write().await.push(observer);
    }
    
    pub async fn notify(&self, data: String) {
        let observers = self.observers.read().await;
        
        // å¹¶å‘é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
        let mut handles = Vec::new();
        for observer in observers.iter() {
            let observer = Arc::clone(observer);
            let data = data.clone();
            
            let handle = tokio::spawn(async move {
                observer.update(data).await;
            });
            
            handles.push(handle);
        }
        
        // ç­‰å¾…æ‰€æœ‰è§‚å¯Ÿè€…å®Œæˆ
        for handle in handles {
            let _ = handle.await;
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn async_observer_example() {
    let subject = AsyncSubject::new();
    
    // å‡è®¾è§‚å¯Ÿè€…å¤„ç†è€—æ—¶ 10ms
    subject.notify("event".to_string()).await; // å¹¶å‘æ‰§è¡Œï¼Œæ€»è€—æ—¶ ~10ms
}
```

**ç‰¹ç‚¹**:

- âœ… éé˜»å¡
- âœ… å¹¶å‘æ‰§è¡Œ
- âœ… æ…¢è§‚å¯Ÿè€…ä¸å½±å“å…¶ä»–è§‚å¯Ÿè€…
- âš ï¸ é¡ºåºä¸ä¿è¯
- âš ï¸ å¤æ‚åº¦æ›´é«˜

### 3.2 æ€§èƒ½å¯¹æ¯”

| å®ç°æ–¹å¼ | é€šçŸ¥å»¶è¿Ÿ (10è§‚å¯Ÿè€…, å„10ms) | CPUä½¿ç”¨ç‡ | å†…å­˜å¼€é”€ |
|---------|----------------------------|----------|---------|
| **åŒæ­¥** | 100ms (é¡ºåºæ‰§è¡Œ) | ä½ | ä½ |
| **å¼‚æ­¥** | 10-12ms (å¹¶å‘æ‰§è¡Œ) | é«˜ | ä¸­ç­‰ (taskå¼€é”€) |

---

## 4. é™æ€ vs åŠ¨æ€åˆ†æ´¾å¯¹æ¯”

### 4.1 å·¥å‚æ¨¡å¼å¯¹æ¯”

#### é™æ€åˆ†æ´¾ (æšä¸¾)

```rust
/// äº§å“ç±»å‹
#[derive(Debug, Clone, Copy)]
pub enum VehicleType {
    Car,
    Motorcycle,
    Truck,
}

/// äº§å“
#[derive(Debug)]
pub enum Vehicle {
    Car { model: String },
    Motorcycle { cc: u32 },
    Truck { capacity: u32 },
}

impl Vehicle {
    pub fn create(vehicle_type: VehicleType) -> Self {
        match vehicle_type {
            VehicleType::Car => Vehicle::Car { model: "Sedan".to_string() },
            VehicleType::Motorcycle => Vehicle::Motorcycle { cc: 600 },
            VehicleType::Truck => Vehicle::Truck { capacity: 5000 },
        }
    }
    
    pub fn drive(&self) {
        match self {
            Vehicle::Car { model } => println!("Driving car: {}", model),
            Vehicle::Motorcycle { cc } => println!("Riding motorcycle: {}cc", cc),
            Vehicle::Truck { capacity } => println!("Driving truck: {}kg", capacity),
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn static_dispatch_example() {
    let car = Vehicle::create(VehicleType::Car);
    car.drive(); // é™æ€åˆ†æ´¾ï¼Œç¼–è¯‘æ—¶ç¡®å®š
}
```

**ç‰¹ç‚¹**:

- âœ… é›¶æˆæœ¬
- âœ… å®Œå…¨å†…è”
- âœ… ç¼–è¯‘æ—¶ä¼˜åŒ–
- âš ï¸ æ‰©å±•éœ€ä¿®æ”¹ä»£ç 

#### åŠ¨æ€åˆ†æ´¾ (Trait Object)

```rust
pub trait Vehicle {
    fn drive(&self);
}

pub struct Car { model: String }
pub struct Motorcycle { cc: u32 }
pub struct Truck { capacity: u32 }

impl Vehicle for Car {
    fn drive(&self) {
        println!("Driving car: {}", self.model);
    }
}

impl Vehicle for Motorcycle {
    fn drive(&self) {
        println!("Riding motorcycle: {}cc", self.cc);
    }
}

impl Vehicle for Truck {
    fn drive(&self) {
        println!("Driving truck: {}kg", self.capacity);
    }
}

pub fn create_vehicle(vehicle_type: &str) -> Box<dyn Vehicle> {
    match vehicle_type {
        "car" => Box::new(Car { model: "Sedan".to_string() }),
        "motorcycle" => Box::new(Motorcycle { cc: 600 }),
        "truck" => Box::new(Truck { capacity: 5000 }),
        _ => panic!("Unknown vehicle type"),
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn dynamic_dispatch_example() {
    let car = create_vehicle("car");
    car.drive(); // åŠ¨æ€åˆ†æ´¾ï¼Œè¿è¡Œæ—¶ç¡®å®š
}
```

**ç‰¹ç‚¹**:

- âœ… æ˜“äºæ‰©å±•
- âœ… æ’ä»¶å‹å¥½
- âš ï¸ è™šå‡½æ•°å¼€é”€
- âš ï¸ å †åˆ†é…

---

## 5. å•çº¿ç¨‹ vs å¤šçº¿ç¨‹å®ç°å¯¹æ¯”

### 5.1 å•ä¾‹æ¨¡å¼å¯¹æ¯”

#### å•çº¿ç¨‹å•ä¾‹

```rust
use std::cell::RefCell;

/// å•çº¿ç¨‹å•ä¾‹
pub struct SingleThreadSingleton {
    value: i32,
}

thread_local! {
    static INSTANCE: RefCell<Option<SingleThreadSingleton>> = RefCell::new(None);
}

impl SingleThreadSingleton {
    pub fn get_or_init() -> i32 {
        INSTANCE.with(|instance| {
            let mut instance = instance.borrow_mut();
            if instance.is_none() {
                *instance = Some(SingleThreadSingleton { value: 42 });
            }
            instance.as_ref().unwrap().value
        })
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn single_thread_example() {
    let value = SingleThreadSingleton::get_or_init();
    println!("Value: {}", value);
}
```

**ç‰¹ç‚¹**:

- âœ… æ— åŒæ­¥å¼€é”€
- âœ… å¿«é€Ÿè®¿é—®
- âš ï¸ ä»…é™å•çº¿ç¨‹
- âš ï¸ ä¸å®ç° Send/Sync

#### å¤šçº¿ç¨‹å•ä¾‹

```rust
use std::sync::OnceLock;

/// å¤šçº¿ç¨‹å•ä¾‹
pub struct MultiThreadSingleton {
    value: i32,
}

static INSTANCE: OnceLock<MultiThreadSingleton> = OnceLock::new();

impl MultiThreadSingleton {
    pub fn get_or_init() -> &'static MultiThreadSingleton {
        INSTANCE.get_or_init(|| MultiThreadSingleton { value: 42 })
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn multi_thread_example() {
    use std::thread;
    
    let handles: Vec<_> = (0..10)
        .map(|_| {
            thread::spawn(|| {
                let singleton = MultiThreadSingleton::get_or_init();
                println!("Value: {}", singleton.value);
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**ç‰¹ç‚¹**:

- âœ… çº¿ç¨‹å®‰å…¨
- âœ… å®ç° Send + Sync
- âš ï¸ é¦–æ¬¡è®¿é—®æœ‰åŒæ­¥å¼€é”€
- âš ï¸ åç»­è®¿é—®å‡ ä¹é›¶æˆæœ¬

### 5.2 æ€§èƒ½å¯¹æ¯”

| å®ç°æ–¹å¼ | é¦–æ¬¡è®¿é—® | åç»­è®¿é—® | çº¿ç¨‹å®‰å…¨ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|
| **å•çº¿ç¨‹** | ~1ns | ~1ns | âŒ | å•çº¿ç¨‹åº”ç”¨ |
| **å¤šçº¿ç¨‹** | ~50-100ns (åŒæ­¥) | ~2-5ns (åŸå­è¯») | âœ… | å¤šçº¿ç¨‹åº”ç”¨ |

---

## 6. é›¶æˆæœ¬ vs è¿è¡Œæ—¶æŠ½è±¡å¯¹æ¯”

### 6.1 è¿­ä»£å™¨æ¨¡å¼å¯¹æ¯”

#### é›¶æˆæœ¬æŠ½è±¡ (æ³›å‹è¿­ä»£å™¨)

```rust
/// é›¶æˆæœ¬è¿­ä»£å™¨é“¾
pub fn zero_cost_iterator(data: &[i32]) -> i32 {
    data.iter()
        .filter(|&&x| x > 0)     // ç¼–è¯‘æ—¶å†…è”
        .map(|&x| x * 2)         // ç¼–è¯‘æ—¶å†…è”
        .sum()                   // ç¼–è¯‘æ—¶ä¼˜åŒ–
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn zero_cost_example() {
    let data = vec![1, -2, 3, -4, 5];
    let result = zero_cost_iterator(&data);
    println!("Result: {}", result); // Result: 18
}
```

**æ±‡ç¼–è¾“å‡º** (ä¼˜åŒ–å):

```asm
; ç¼–è¯‘å™¨ç›´æ¥ç”Ÿæˆä¼˜åŒ–åçš„å¾ªç¯
; æ— å‡½æ•°è°ƒç”¨ï¼Œå®Œå…¨å†…è”
mov     eax, 0
.loop:
    cmp     [data + rcx], 0
    jle     .skip
    mov     edx, [data + rcx]
    add     edx, edx
    add     eax, edx
.skip:
    add     rcx, 4
    cmp     rcx, len
    jl      .loop
```

#### è¿è¡Œæ—¶æŠ½è±¡ (Boxedè¿­ä»£å™¨)

```rust
/// è¿è¡Œæ—¶æŠ½è±¡è¿­ä»£å™¨
pub fn runtime_iterator(data: &[i32]) -> Box<dyn Iterator<Item = i32> + '_> {
    Box::new(
        data.iter()
            .filter(|&&x| x > 0)
            .map(|&x| x * 2)
    )
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn runtime_example() {
    let data = vec![1, -2, 3, -4, 5];
    let iter = runtime_iterator(&data);
    let result: i32 = iter.sum();
    println!("Result: {}", result);
}
```

**ç‰¹ç‚¹**:

- âš ï¸ å †åˆ†é…
- âš ï¸ è™šå‡½æ•°è°ƒç”¨
- âš ï¸ æ— æ³•å†…è”

### 6.2 æ€§èƒ½å¯¹æ¯”

| å®ç°æ–¹å¼ | æ‰§è¡Œæ—¶é—´ (100ä¸‡å…ƒç´ ) | å†…å­˜åˆ†é… | ç¼–è¯‘å™¨ä¼˜åŒ– |
|---------|---------------------|---------|-----------|
| **é›¶æˆæœ¬** | 0.5ms | 0 | âœ… å®Œå…¨å†…è” |
| **è¿è¡Œæ—¶** | 2.1ms (æ…¢ ~4.2x) | å †åˆ†é… | âŒ æ— æ³•å†…è” |

**CriterionåŸºå‡†æµ‹è¯•**:

```rust
fn benchmark_iterators(c: &mut Criterion) {
    let data: Vec<i32> = (0..1_000_000).collect();
    
    c.bench_function("zero_cost_iterator", |b| {
        b.iter(|| zero_cost_iterator(black_box(&data)))
    });
    
    c.bench_function("runtime_iterator", |b| {
        b.iter(|| {
            let iter = runtime_iterator(black_box(&data));
            iter.sum::<i32>()
        })
    });
}
```

**ç»“æœ**:

```text
zero_cost_iterator     time: [485.2 Î¼s ... 491.3 Î¼s]
runtime_iterator       time: [2.08 ms ... 2.13 ms]
                       change: +328.9% (æ…¢ 4.2x)
```

---

## 7. å†…å­˜æ¨¡å‹å¯¹æ¯”

### 7.1 æ‰€æœ‰æƒæ¨¡å¼å¯¹æ¯”

#### æ–¹å¼ 1ï¼šæ‰€æœ‰æƒè½¬ç§» (Move)

```rust
/// æ‰€æœ‰æƒè½¬ç§»
pub fn take_ownership(data: Vec<u8>) -> Vec<u8> {
    // data è¢«ç§»åŠ¨è¿›æ¥
    println!("Processing {} bytes", data.len());
    data // è¿”å›æ‰€æœ‰æƒ
}

pub fn move_example() {
    let data = vec![1, 2, 3];
    let data = take_ownership(data); // æ‰€æœ‰æƒè½¬ç§»ï¼Œé›¶æˆæœ¬
    // data ç°åœ¨å¯ç”¨
}
```

**ç‰¹ç‚¹**:

- âœ… é›¶æˆæœ¬
- âœ… æ— å†…å­˜æ‹·è´
- âš ï¸ åŸå˜é‡å¤±æ•ˆ

#### æ–¹å¼ 2ï¼šä¸å¯å˜å€Ÿç”¨ (Borrow)

```rust
/// ä¸å¯å˜å€Ÿç”¨
pub fn borrow_immutable(data: &Vec<u8>) -> usize {
    println!("Processing {} bytes", data.len());
    data.len()
}

pub fn borrow_example() {
    let data = vec![1, 2, 3];
    let len = borrow_immutable(&data); // å€Ÿç”¨ï¼Œé›¶æˆæœ¬
    // data ä»ç„¶å¯ç”¨
    println!("Original data: {:?}", data);
}
```

**ç‰¹ç‚¹**:

- âœ… é›¶æˆæœ¬
- âœ… åŸå˜é‡ä»å¯ç”¨
- âš ï¸ æ— æ³•ä¿®æ”¹

#### æ–¹å¼ 3ï¼šå¯å˜å€Ÿç”¨ (Mutable Borrow)

```rust
/// å¯å˜å€Ÿç”¨
pub fn borrow_mutable(data: &mut Vec<u8>) {
    data.push(4);
    println!("Added element");
}

pub fn mut_borrow_example() {
    let mut data = vec![1, 2, 3];
    borrow_mutable(&mut data); // å¯å˜å€Ÿç”¨ï¼Œé›¶æˆæœ¬
    // data å·²è¢«ä¿®æ”¹
    println!("Modified data: {:?}", data);
}
```

**ç‰¹ç‚¹**:

- âœ… é›¶æˆæœ¬
- âœ… å¯ä¿®æ”¹
- âš ï¸ å€Ÿç”¨æœŸé—´æ— æ³•åŒæ—¶è®¿é—®

#### æ–¹å¼ 4ï¼šå…‹éš† (Clone)

```rust
/// å…‹éš†
pub fn clone_data(data: &Vec<u8>) -> Vec<u8> {
    data.clone() // æ·±æ‹·è´
}

pub fn clone_example() {
    let data = vec![1, 2, 3];
    let cloned = clone_data(&data); // å…‹éš†ï¼Œæœ‰æˆæœ¬
    // ä¸¤ä»½ç‹¬ç«‹æ•°æ®
    println!("Original: {:?}, Cloned: {:?}", data, cloned);
}
```

**ç‰¹ç‚¹**:

- âš ï¸ æœ‰æˆæœ¬ (å†…å­˜æ‹·è´)
- âœ… ç‹¬ç«‹æ•°æ®
- âœ… å¹¶å‘å®‰å…¨

### 7.2 å†…å­˜å¼€é”€å¯¹æ¯”

| æ¨¡å¼ | å†…å­˜æ‹·è´ | CPUå¼€é”€ | é€‚ç”¨åœºæ™¯ |
|------|---------|---------|---------|
| **Move** | 0 | 0 | è½¬ç§»æ‰€æœ‰æƒ |
| **Borrow** | 0 | 0 | åªè¯»è®¿é—® |
| **Mut Borrow** | 0 | 0 | è¯»å†™è®¿é—® |
| **Clone** | O(n) | O(n) | éœ€è¦ç‹¬ç«‹å‰¯æœ¬ |

---

## 8. æ€§èƒ½å¼€é”€å¯¹æ¯”

### 8.1 ç»¼åˆæ€§èƒ½å¯¹æ¯”è¡¨

| æ¨¡å¼ | å®ç°æ–¹å¼ | è°ƒç”¨å¼€é”€ | å†…å­˜å¼€é”€ | çµæ´»æ€§ | ç±»å‹å®‰å…¨ | æ¨èæŒ‡æ•° |
|------|---------|---------|---------|--------|---------|---------|
| **Singleton** | OnceLock | ~2-5ns | é™æ€ | ä½ | âœ… | â­â­â­â­â­ |
| **Factory** | æ³›å‹ | 0ns | æ ˆ | ä¸­ | âœ… | â­â­â­â­â­ |
| **Factory** | Trait Object | ~2ns | å † | é«˜ | âœ… | â­â­â­â­ |
| **Builder** | é“¾å¼è°ƒç”¨ | 0ns | æ ˆ | é«˜ | âœ… | â­â­â­â­â­ |
| **Observer** | åŒæ­¥ | ~1ns | ä½ | ä¸­ | âœ… | â­â­â­ |
| **Observer** | å¼‚æ­¥ | ~1000ns | ä¸­ | é«˜ | âœ… | â­â­â­â­â­ |
| **Strategy** | æ³›å‹ | 0ns | æ ˆ | ä½ | âœ… | â­â­â­â­â­ |
| **Strategy** | Trait Object | ~2ns | å † | é«˜ | âœ… | â­â­â­â­ |
| **Iterator** | é›¶æˆæœ¬ | 0ns | æ ˆ | é«˜ | âœ… | â­â­â­â­â­ |
| **Decorator** | æ³›å‹ | 0ns | æ ˆ | ä½ | âœ… | â­â­â­â­ |

### 8.2 é€‰æ‹©å†³ç­–æ ‘

```text
éœ€è¦è®¾è®¡æ¨¡å¼ï¼Ÿ
â”œâ”€ æ€§èƒ½å…³é”®è·¯å¾„ï¼Ÿ
â”‚  â”œâ”€ æ˜¯ â†’ æ³›å‹/é›¶æˆæœ¬æŠ½è±¡
â”‚  â””â”€ å¦ â†’ Trait Object
â”‚
â”œâ”€ éœ€è¦è¿è¡Œæ—¶åˆ‡æ¢ï¼Ÿ
â”‚  â”œâ”€ æ˜¯ â†’ Trait Object/æšä¸¾
â”‚  â””â”€ å¦ â†’ æ³›å‹
â”‚
â”œâ”€ éœ€è¦å¹¶å‘ï¼Ÿ
â”‚  â”œâ”€ æ˜¯ â†’ async/await + Arc
â”‚  â””â”€ å¦ â†’ åŒæ­¥å®ç°
â”‚
â””â”€ éœ€è¦æ‰©å±•æ€§ï¼Ÿ
   â”œâ”€ æ˜¯ â†’ Trait + æ’ä»¶
   â””â”€ å¦ â†’ æšä¸¾/æ³›å‹
```

---

## ğŸ“š ç›¸å…³èµ„æº

- **Tier 2**: [å®è·µæŒ‡å—](../tier_02_guides/)
- **Tier 3-01**: [æ¨¡å¼åˆ†ç±»å‚è€ƒ](./01_è®¾è®¡æ¨¡å¼åˆ†ç±»å‚è€ƒ.md)
- **Tier 4**: [å½¢å¼åŒ–ç†è®º](../tier_04_advanced/)
- **åŸºå‡†æµ‹è¯•**: [benches/pattern_benchmarks.rs](../../benches/pattern_benchmarks.rs)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-23
