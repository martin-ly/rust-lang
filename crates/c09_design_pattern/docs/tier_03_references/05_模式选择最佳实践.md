# æ¨¡å¼é€‰æ‹©æœ€ä½³å®è·µ

> **æ–‡æ¡£å®šä½**: Tier 3 æŠ€æœ¯å‚è€ƒ  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘](#2-æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘)
- [3. åœºæ™¯é©±åŠ¨çš„æ¨¡å¼é€‰æ‹©](#3-åœºæ™¯é©±åŠ¨çš„æ¨¡å¼é€‰æ‹©)
- [4. åæ¨¡å¼ä¸é™·é˜±](#4-åæ¨¡å¼ä¸é™·é˜±)
- [5. æ¨¡å¼ç»„åˆæœ€ä½³å®è·µ](#5-æ¨¡å¼ç»„åˆæœ€ä½³å®è·µ)
- [6. Rust ç‰¹æœ‰è€ƒé‡](#6-rust-ç‰¹æœ‰è€ƒé‡)
- [7. ç”Ÿäº§ç¯å¢ƒæŒ‡å—](#7-ç”Ÿäº§ç¯å¢ƒæŒ‡å—)

---

## 1. æ¦‚è¿°

è®¾è®¡æ¨¡å¼çš„é€‰æ‹©åº”åŸºäºå…·ä½“åœºæ™¯ã€æ€§èƒ½éœ€æ±‚å’Œå›¢é˜Ÿèƒ½åŠ›ã€‚æœ¬æ–‡æ¡£æä¾›ç³»ç»ŸåŒ–çš„é€‰æ‹©æ–¹æ³•å’Œæœ€ä½³å®è·µã€‚

### 1.1 é€‰æ‹©ç»´åº¦

| ç»´åº¦ | è€ƒé‡å› ç´  | æƒé‡ |
|------|---------|------|
| **æ€§èƒ½è¦æ±‚** | å»¶è¿Ÿã€ååé‡ | â­â­â­â­â­ |
| **çµæ´»æ€§** | æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§ | â­â­â­â­ |
| **å¤æ‚åº¦** | å®ç°æˆæœ¬ã€å­¦ä¹ æ›²çº¿ | â­â­â­ |
| **ç±»å‹å®‰å…¨** | ç¼–è¯‘æ—¶æ£€æŸ¥ | â­â­â­â­â­ |
| **å¹¶å‘éœ€æ±‚** | å¤šçº¿ç¨‹ã€å¼‚æ­¥ | â­â­â­â­ |

---

## 2. æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘

### 2.1 åˆ›å»ºå‹æ¨¡å¼å†³ç­–æ ‘

```text
éœ€è¦åˆ›å»ºå¯¹è±¡ï¼Ÿ
â”‚
â”œâ”€ åªéœ€ä¸€ä¸ªå®ä¾‹ï¼Ÿ
â”‚  â””â”€ Singleton (OnceLock)
â”‚
â”œâ”€ æ„é€ è¿‡ç¨‹å¤æ‚ï¼Ÿ
â”‚  â”œâ”€ éœ€è¦ç¼–è¯‘æ—¶éªŒè¯ï¼Ÿ
â”‚  â”‚  â””â”€ Typestate Builder â­æ¨è
â”‚  â””â”€ è¿è¡Œæ—¶çµæ´»æ€§ï¼Ÿ
â”‚     â””â”€ Builder
â”‚
â”œâ”€ åˆ›å»ºé€»è¾‘å¯å˜ï¼Ÿ
â”‚  â”œâ”€ ç±»å‹å›ºå®šï¼Ÿ
â”‚  â”‚  â””â”€ æ³›å‹Factory â­æ¨è
â”‚  â””â”€ è¿è¡Œæ—¶å†³å®šï¼Ÿ
â”‚     â””â”€ Trait Object Factory
â”‚
â””â”€ éœ€è¦å…‹éš†å¯¹è±¡ï¼Ÿ
   â””â”€ Prototype (Clone)
```

### 2.2 ç»“æ„å‹æ¨¡å¼å†³ç­–æ ‘

```text
éœ€è¦ç»„åˆå¯¹è±¡ï¼Ÿ
â”‚
â”œâ”€ æ¥å£ä¸å…¼å®¹ï¼Ÿ
â”‚  â””â”€ Adapter
â”‚
â”œâ”€ éœ€è¦æ·»åŠ åŠŸèƒ½ï¼Ÿ
â”‚  â”œâ”€ ç¼–è¯‘æ—¶ï¼Ÿ
â”‚  â”‚  â””â”€ æ³›å‹Decorator â­æ¨è
â”‚  â””â”€ è¿è¡Œæ—¶ï¼Ÿ
â”‚     â””â”€ Trait Object Decorator
â”‚
â”œâ”€ éœ€è¦æ§åˆ¶è®¿é—®ï¼Ÿ
â”‚  â”œâ”€ ç¼“å­˜ï¼Ÿ
â”‚  â”‚  â””â”€ Cache Proxy
â”‚  â”œâ”€ å»¶è¿ŸåŠ è½½ï¼Ÿ
â”‚  â”‚  â””â”€ Lazy Proxy
â”‚  â””â”€ æƒé™æ£€æŸ¥ï¼Ÿ
â”‚     â””â”€ Protection Proxy
â”‚
â””â”€ ç®€åŒ–å¤æ‚æ¥å£ï¼Ÿ
   â””â”€ Facade
```

### 2.3 è¡Œä¸ºå‹æ¨¡å¼å†³ç­–æ ‘

```text
éœ€è¦å¯¹è±¡äº¤äº’ï¼Ÿ
â”‚
â”œâ”€ ä¸€å¯¹å¤šé€šçŸ¥ï¼Ÿ
â”‚  â”œâ”€ åŒæ­¥ï¼Ÿ
â”‚  â”‚  â””â”€ Sync Observer
â”‚  â””â”€ å¼‚æ­¥ï¼Ÿ
â”‚     â””â”€ Async Observer â­æ¨è
â”‚
â”œâ”€ ç®—æ³•å¯åˆ‡æ¢ï¼Ÿ
â”‚  â”œâ”€ ç¼–è¯‘æ—¶ï¼Ÿ
â”‚  â”‚  â””â”€ æ³›å‹Strategy â­æ¨è
â”‚  â””â”€ è¿è¡Œæ—¶ï¼Ÿ
â”‚     â””â”€ Trait Object Strategy
â”‚
â”œâ”€ è¯·æ±‚éœ€è¦æ’é˜Ÿ/æ’¤é”€ï¼Ÿ
â”‚  â””â”€ Command
â”‚
â”œâ”€ çŠ¶æ€è½¬æ¢ï¼Ÿ
â”‚  â”œâ”€ ç¼–è¯‘æ—¶éªŒè¯ï¼Ÿ
â”‚  â”‚  â””â”€ Typestate â­æ¨è
â”‚  â””â”€ è¿è¡Œæ—¶çµæ´»æ€§ï¼Ÿ
â”‚     â””â”€ State
â”‚
â””â”€ éå†é›†åˆï¼Ÿ
   â””â”€ Iterator (é›¶æˆæœ¬)
```

---

## 3. åœºæ™¯é©±åŠ¨çš„æ¨¡å¼é€‰æ‹©

### 3.1 WebæœåŠ¡å™¨åœºæ™¯

```rust
/// åœºæ™¯ï¼šæ„å»ºé«˜æ€§èƒ½WebæœåŠ¡å™¨
/// 
/// éœ€æ±‚ï¼š
/// - æ”¯æŒå¤šç§è·¯ç”±ç­–ç•¥
/// - ä¸­é—´ä»¶æ”¯æŒ
/// - è¿æ¥æ± ç®¡ç†
/// - è¯·æ±‚æ—¥å¿—

// 1. Singleton: å…¨å±€é…ç½®
use std::sync::OnceLock;

pub struct ServerConfig {
    pub port: u16,
    pub max_connections: usize,
}

static CONFIG: OnceLock<ServerConfig> = OnceLock::new();

impl ServerConfig {
    pub fn get() -> &'static ServerConfig {
        CONFIG.get().expect("Config not initialized")
    }
}

// 2. Builder: è¯·æ±‚æ„å»º
pub struct RequestBuilder {
    path: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
}

impl RequestBuilder {
    pub fn new() -> Self {
        Self {
            path: None,
            method: None,
            headers: Vec::new(),
        }
    }
    
    pub fn path(mut self, path: impl Into<String>) -> Self {
        self.path = Some(path.into());
        self
    }
    
    pub fn method(mut self, method: impl Into<String>) -> Self {
        self.method = Some(method.into());
        self
    }
    
    pub fn build(self) -> Result<Request, BuildError> {
        Ok(Request {
            path: self.path.ok_or(BuildError::MissingPath)?,
            method: self.method.unwrap_or_else(|| "GET".to_string()),
            headers: self.headers,
        })
    }
}

// 3. Strategy: è·¯ç”±ç­–ç•¥
pub trait Router: Send + Sync {
    fn route(&self, path: &str) -> Option<Box<dyn Handler>>;
}

pub struct PrefixRouter {
    routes: std::collections::HashMap<String, Box<dyn Handler>>,
}

impl Router for PrefixRouter {
    fn route(&self, path: &str) -> Option<Box<dyn Handler>> {
        self.routes.get(path).map(|h| h.clone_box())
    }
}

// 4. Decorator: ä¸­é—´ä»¶
pub trait Middleware {
    fn handle(&self, request: Request, next: &dyn Handler) -> Response;
}

pub struct LoggingMiddleware;

impl Middleware for LoggingMiddleware {
    fn handle(&self, request: Request, next: &dyn Handler) -> Response {
        println!("[Middleware] {} {}", request.method, request.path);
        let response = next.handle(request);
        println!("[Middleware] Response: {}", response.status);
        response
    }
}

// 5. Object Pool: è¿æ¥æ± 
pub struct ConnectionPool {
    connections: tokio::sync::Mutex<Vec<Connection>>,
    max_size: usize,
}

impl ConnectionPool {
    pub fn new(max_size: usize) -> Self {
        Self {
            connections: tokio::sync::Mutex::new(Vec::new()),
            max_size,
        }
    }
    
    pub async fn acquire(&self) -> Connection {
        let mut conns = self.connections.lock().await;
        conns.pop().unwrap_or_else(|| Connection::new())
    }
    
    pub async fn release(&self, conn: Connection) {
        let mut conns = self.connections.lock().await;
        if conns.len() < self.max_size {
            conns.push(conn);
        }
    }
}
```

**æ¨¡å¼é€‰æ‹©æ€»ç»“**:

- âœ… Singleton: å…¨å±€é…ç½®ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
- âœ… Builder: å¤æ‚è¯·æ±‚æ„å»º
- âœ… Strategy: å¯æ’æ‹”è·¯ç”±
- âœ… Decorator: ä¸­é—´ä»¶é“¾
- âœ… Object Pool: èµ„æºå¤ç”¨

### 3.2 æ’ä»¶ç³»ç»Ÿåœºæ™¯

```rust
/// åœºæ™¯ï¼šæ„å»ºæ’ä»¶ç³»ç»Ÿ
/// 
/// éœ€æ±‚ï¼š
/// - åŠ¨æ€åŠ è½½æ’ä»¶
/// - æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
/// - æ’ä»¶é—´é€šä¿¡

// 1. Abstract Factory: æ’ä»¶å·¥å‚
pub trait PluginFactory: Send + Sync {
    fn create_plugin(&self) -> Box<dyn Plugin>;
    fn plugin_name(&self) -> &str;
}

// 2. Facade: æ’ä»¶ç®¡ç†å™¨
pub struct PluginManager {
    factories: std::collections::HashMap<String, Box<dyn PluginFactory>>,
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginManager {
    pub fn new() -> Self {
        Self {
            factories: std::collections::HashMap::new(),
            plugins: Vec::new(),
        }
    }
    
    pub fn register_factory(&mut self, factory: Box<dyn PluginFactory>) {
        self.factories.insert(factory.plugin_name().to_string(), factory);
    }
    
    pub fn load_plugin(&mut self, name: &str) -> Result<(), String> {
        let factory = self.factories.get(name)
            .ok_or_else(|| format!("Plugin not found: {}", name))?;
        
        let plugin = factory.create_plugin();
        plugin.init()?;
        self.plugins.push(plugin);
        Ok(())
    }
    
    pub fn broadcast(&self, event: &str) {
        for plugin in &self.plugins {
            plugin.on_event(event);
        }
    }
}

// 3. Observer: æ’ä»¶é—´é€šä¿¡
pub trait Plugin: Send + Sync {
    fn init(&self) -> Result<(), String>;
    fn on_event(&self, event: &str);
    fn shutdown(&self);
}

pub struct EventBusPlugin;

impl Plugin for EventBusPlugin {
    fn init(&self) -> Result<(), String> {
        println!("[EventBus] Plugin initialized");
        Ok(())
    }
    
    fn on_event(&self, event: &str) {
        println!("[EventBus] Received event: {}", event);
    }
    
    fn shutdown(&self) {
        println!("[EventBus] Plugin shutdown");
    }
}
```

**æ¨¡å¼é€‰æ‹©æ€»ç»“**:

- âœ… Abstract Factory: åˆ›å»ºä¸åŒç±»å‹æ’ä»¶
- âœ… Facade: ç®€åŒ–æ’ä»¶ç®¡ç†
- âœ… Observer: äº‹ä»¶é€šçŸ¥æœºåˆ¶
- âœ… Command: æ’ä»¶å‘½ä»¤æ‰§è¡Œ

### 3.3 æ¸¸æˆå¼•æ“åœºæ™¯

```rust
/// åœºæ™¯ï¼šæ¸¸æˆå¼•æ“æ¶æ„
/// 
/// éœ€æ±‚ï¼š
/// - å®ä½“ç»„ä»¶ç³»ç»Ÿ (ECS)
/// - çŠ¶æ€æœº (AI, Animation)
/// - èµ„æºç®¡ç†

// 1. Flyweight: å…±äº«èµ„æº
pub struct TextureCache {
    cache: std::collections::HashMap<String, std::sync::Arc<Texture>>,
}

impl TextureCache {
    pub fn get_or_load(&mut self, path: &str) -> std::sync::Arc<Texture> {
        self.cache.entry(path.to_string())
            .or_insert_with(|| std::sync::Arc::new(Texture::load(path)))
            .clone()
    }
}

// 2. State: AIçŠ¶æ€æœº
pub trait AIState {
    fn update(&self, entity: &mut Entity) -> Option<Box<dyn AIState>>;
}

pub struct IdleState;
pub struct ChaseState { target: EntityId }
pub struct AttackState { target: EntityId }

impl AIState for IdleState {
    fn update(&self, entity: &mut Entity) -> Option<Box<dyn AIState>> {
        if let Some(target) = entity.find_nearby_enemy() {
            return Some(Box::new(ChaseState { target }));
        }
        None
    }
}

impl AIState for ChaseState {
    fn update(&self, entity: &mut Entity) -> Option<Box<dyn AIState>> {
        if entity.distance_to(self.target) < 1.0 {
            return Some(Box::new(AttackState { target: self.target }));
        }
        entity.move_towards(self.target);
        None
    }
}

// 3. Command: è¾“å…¥ç³»ç»Ÿ
pub trait GameCommand {
    fn execute(&self, game: &mut Game);
    fn undo(&self, game: &mut Game);
}

pub struct MoveCommand {
    entity_id: EntityId,
    old_pos: Vec2,
    new_pos: Vec2,
}

impl GameCommand for MoveCommand {
    fn execute(&self, game: &mut Game) {
        game.move_entity(self.entity_id, self.new_pos);
    }
    
    fn undo(&self, game: &mut Game) {
        game.move_entity(self.entity_id, self.old_pos);
    }
}

// 4. Object Pool: å¯¹è±¡æ± ï¼ˆå¼¹è¯ã€ç‰¹æ•ˆç­‰ï¼‰
pub struct BulletPool {
    active: Vec<Bullet>,
    inactive: Vec<Bullet>,
    max_size: usize,
}

impl BulletPool {
    pub fn spawn(&mut self, pos: Vec2, velocity: Vec2) -> Option<&mut Bullet> {
        if let Some(mut bullet) = self.inactive.pop() {
            bullet.reset(pos, velocity);
            self.active.push(bullet);
            self.active.last_mut()
        } else if self.active.len() < self.max_size {
            let bullet = Bullet::new(pos, velocity);
            self.active.push(bullet);
            self.active.last_mut()
        } else {
            None
        }
    }
    
    pub fn recycle(&mut self, index: usize) {
        let bullet = self.active.remove(index);
        self.inactive.push(bullet);
    }
}
```

**æ¨¡å¼é€‰æ‹©æ€»ç»“**:

- âœ… Flyweight: çº¹ç†/æ¨¡å‹å…±äº«
- âœ… State: AIå’ŒåŠ¨ç”»çŠ¶æ€æœº
- âœ… Command: è¾“å…¥å’Œå›æ”¾ç³»ç»Ÿ
- âœ… Object Pool: é«˜é¢‘å¯¹è±¡å¤ç”¨

---

## 4. åæ¨¡å¼ä¸é™·é˜±

### 4.1 è¿‡åº¦å·¥ç¨‹

```rust
// âŒ åæ¨¡å¼ï¼šè¿‡åº¦ä½¿ç”¨è®¾è®¡æ¨¡å¼
pub trait DataProcessor {
    fn process(&self, data: Vec<u8>) -> Vec<u8>;
}

pub struct DataProcessorFactory;
impl DataProcessorFactory {
    pub fn create() -> Box<dyn DataProcessor> {
        Box::new(ConcreteDataProcessor)
    }
}

pub struct DataProcessorBuilder {
    processor: Option<Box<dyn DataProcessor>>,
}

// å®é™…ä¸Šåªéœ€è¦ï¼š
pub fn process_data(data: Vec<u8>) -> Vec<u8> {
    // ç®€å•å¤„ç†
    data
}
```

**æ•™è®­**: ç®€å•é—®é¢˜ä¸éœ€è¦å¤æ‚æ¨¡å¼ã€‚éµå¾ª YAGNI (You Aren't Gonna Need It) åŸåˆ™ã€‚

### 4.2 Trait Object æ»¥ç”¨

```rust
// âŒ åæ¨¡å¼ï¼šä¸å¿…è¦çš„åŠ¨æ€åˆ†æ´¾
pub fn bad_sum(numbers: Vec<Box<dyn Number>>) -> i32 {
    numbers.iter().map(|n| n.value()).sum()
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨æ³›å‹
pub fn good_sum<T: Number>(numbers: &[T]) -> i32 {
    numbers.iter().map(|n| n.value()).sum()
}
```

**æ•™è®­**: ä¼˜å…ˆä½¿ç”¨æ³›å‹ï¼Œä»…åœ¨éœ€è¦è¿è¡Œæ—¶å¤šæ€æ—¶ä½¿ç”¨ Trait Objectã€‚

### 4.3 å¿½ç•¥æ‰€æœ‰æƒ

```rust
// âŒ åæ¨¡å¼ï¼šä¸å¿…è¦çš„å…‹éš†
pub fn bad_observer_notify(observers: &Vec<Observer>, data: String) {
    for observer in observers {
        observer.update(data.clone()); // Næ¬¡å…‹éš†
    }
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨å€Ÿç”¨
pub fn good_observer_notify(observers: &Vec<Observer>, data: &str) {
    for observer in observers {
        observer.update(data); // é›¶æ‹·è´
    }
}
```

**æ•™è®­**: å……åˆ†åˆ©ç”¨ Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ï¼Œé¿å…ä¸å¿…è¦çš„å…‹éš†ã€‚

### 4.4 é”ç²’åº¦è¿‡å¤§

```rust
// âŒ åæ¨¡å¼ï¼šæŒæœ‰é”è¿‡ä¹…
pub fn bad_cache_access(cache: &Mutex<HashMap<String, String>>, key: &str) -> Option<String> {
    let cache = cache.lock().unwrap();
    if let Some(value) = cache.get(key) {
        // è€—æ—¶æ“ä½œï¼Œé”ä¸€ç›´è¢«æŒæœ‰
        expensive_processing(value);
        return Some(value.clone());
    }
    None
}

// âœ… æ­£ç¡®ï¼šç¼©å°ä¸´ç•ŒåŒº
pub fn good_cache_access(cache: &Mutex<HashMap<String, String>>, key: &str) -> Option<String> {
    let value = {
        let cache = cache.lock().unwrap();
        cache.get(key).cloned()
    }; // é”ç«‹å³é‡Šæ”¾
    
    if let Some(value) = value {
        expensive_processing(&value);
        return Some(value);
    }
    None
}
```

**æ•™è®­**: æœ€å°åŒ–é”æŒæœ‰æ—¶é—´ï¼Œè€ƒè™‘ä½¿ç”¨ RwLock æˆ–æ— é”æ•°æ®ç»“æ„ã€‚

---

## 5. æ¨¡å¼ç»„åˆæœ€ä½³å®è·µ

### 5.1 å¸¸è§æ¨¡å¼ç»„åˆ

| ç»„åˆ | åœºæ™¯ | ç¤ºä¾‹ |
|------|------|------|
| **Factory + Singleton** | å…¨å±€å·¥å‚ | æ—¥å¿—ç³»ç»Ÿ |
| **Builder + Strategy** | å¯é…ç½®æ„å»º | HTTPå®¢æˆ·ç«¯ |
| **Decorator + Proxy** | å¤šå±‚åŒ…è£… | ç¼“å­˜+æ—¥å¿— |
| **Observer + Command** | äº‹ä»¶é©±åŠ¨ | GUIç³»ç»Ÿ |
| **State + Strategy** | å¤æ‚çŠ¶æ€ | æ¸¸æˆAI |

### 5.2 ç»„åˆç¤ºä¾‹ï¼šHTTPå®¢æˆ·ç«¯

```rust
/// ç»„åˆ Builder + Strategy + Decorator + Proxy

// 1. Builder: æ„å»ºHTTPå®¢æˆ·ç«¯
pub struct HttpClientBuilder {
    base_url: Option<String>,
    timeout: Option<Duration>,
    retry_strategy: Option<Box<dyn RetryStrategy>>,
    middlewares: Vec<Box<dyn Middleware>>,
}

impl HttpClientBuilder {
    pub fn new() -> Self {
        Self {
            base_url: None,
            timeout: None,
            retry_strategy: None,
            middlewares: Vec::new(),
        }
    }
    
    pub fn base_url(mut self, url: String) -> Self {
        self.base_url = Some(url);
        self
    }
    
    pub fn timeout(mut self, timeout: Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    // 2. Strategy: é‡è¯•ç­–ç•¥
    pub fn retry_strategy(mut self, strategy: Box<dyn RetryStrategy>) -> Self {
        self.retry_strategy = Some(strategy);
        self
    }
    
    // 3. Decorator: ä¸­é—´ä»¶
    pub fn add_middleware(mut self, middleware: Box<dyn Middleware>) -> Self {
        self.middlewares.push(middleware);
        self
    }
    
    pub fn build(self) -> HttpClient {
        HttpClient {
            base_url: self.base_url.unwrap_or_default(),
            timeout: self.timeout.unwrap_or(Duration::from_secs(30)),
            retry_strategy: self.retry_strategy,
            middlewares: self.middlewares,
            // 4. Proxy: ç¼“å­˜ä»£ç†
            cache: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn http_client_example() {
    let client = HttpClientBuilder::new()
        .base_url("https://api.example.com".to_string())
        .timeout(Duration::from_secs(10))
        .retry_strategy(Box::new(ExponentialBackoff::new()))
        .add_middleware(Box::new(LoggingMiddleware))
        .add_middleware(Box::new(AuthMiddleware::new("token")))
        .build();
    
    // client ç°åœ¨ç»„åˆäº†å¤šç§æ¨¡å¼çš„ä¼˜åŠ¿
}
```

---

## 6. Rust ç‰¹æœ‰è€ƒé‡

### 6.1 æ‰€æœ‰æƒä¸ç”Ÿå‘½å‘¨æœŸ

```rust
// è€ƒè™‘ï¼šæ•°æ®æ˜¯ç§»åŠ¨è¿˜æ˜¯å€Ÿç”¨ï¼Ÿ
pub trait DataProcessor {
    // é€‰é¡¹1ï¼šç§»åŠ¨æ‰€æœ‰æƒï¼ˆæ¶ˆè´¹æ•°æ®ï¼‰
    fn process_owned(self, data: Vec<u8>) -> Vec<u8>;
    
    // é€‰é¡¹2ï¼šå€Ÿç”¨ï¼ˆåªè¯»ï¼‰
    fn process_borrowed(&self, data: &[u8]) -> Vec<u8>;
    
    // é€‰é¡¹3ï¼šå¯å˜å€Ÿç”¨ï¼ˆä¿®æ”¹æ•°æ®ï¼‰
    fn process_mut(&mut self, data: &mut Vec<u8>);
}

// æ¨èï¼šæ ¹æ®è¯­ä¹‰é€‰æ‹©
// - éœ€è¦æ¶ˆè´¹æ•°æ® â†’ ç§»åŠ¨
// - åªè¯»è®¿é—® â†’ ä¸å¯å˜å€Ÿç”¨
// - éœ€è¦ä¿®æ”¹ â†’ å¯å˜å€Ÿç”¨
```

### 6.2 Send + Sync

```rust
// è€ƒè™‘ï¼šæ˜¯å¦éœ€è¦è·¨çº¿ç¨‹ä¼ é€’ï¼Ÿ
pub trait ThreadSafeObserver: Send + Sync {
    fn update(&self, data: &str);
}

// ä¸éœ€è¦è·¨çº¿ç¨‹æ—¶å¯çœç•¥
pub trait SingleThreadObserver {
    fn update(&self, data: &str);
}
```

### 6.3 é”™è¯¯å¤„ç†

```rust
// æ¨èï¼šä½¿ç”¨ Result<T, E> è€Œéå¼‚å¸¸
pub trait Fallible {
    type Error;
    
    fn try_operation(&self) -> Result<(), Self::Error>;
}

// è€ƒè™‘ä½¿ç”¨ thiserror æˆ– anyhow
#[derive(Debug, thiserror::Error)]
pub enum PatternError {
    #[error("Invalid state transition")]
    InvalidTransition,
    
    #[error("Resource not available")]
    ResourceUnavailable,
}
```

---

## 7. ç”Ÿäº§ç¯å¢ƒæŒ‡å—

### 7.1 æ€§èƒ½æ£€æŸ¥æ¸…å•

- [ ] é¿å…ä¸å¿…è¦çš„å †åˆ†é…
- [ ] ä½¿ç”¨æ³›å‹è€Œé Trait Objectï¼ˆæ€§èƒ½å…³é”®è·¯å¾„ï¼‰
- [ ] ç¼©å°é”ç²’åº¦
- [ ] è€ƒè™‘ä½¿ç”¨ `#[inline]`
- [ ] åŸºå‡†æµ‹è¯•éªŒè¯æ€§èƒ½å‡è®¾

### 7.2 å¯ç»´æŠ¤æ€§æ£€æŸ¥æ¸…å•

- [ ] æ–‡æ¡£æ¸…æ™°ï¼ˆrustdocï¼‰
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] é¿å…è¿‡åº¦å·¥ç¨‹
- [ ] ä»£ç å®¡æŸ¥

### 7.3 å®‰å…¨æ€§æ£€æŸ¥æ¸…å•

- [ ] é¿å… `unsafe` æˆ–å……åˆ†æ³¨é‡Š
- [ ] è¾“å…¥éªŒè¯
- [ ] è¾¹ç•Œæ£€æŸ¥
- [ ] é¿å… panicï¼ˆä½¿ç”¨ Resultï¼‰
- [ ] Clippy å’Œ Miri æ£€æŸ¥

### 7.4 æ¨¡å¼é€‰æ‹©ä¼˜å…ˆçº§

1. **ä¼˜å…ˆ**ï¼šé›¶æˆæœ¬æŠ½è±¡ï¼ˆæ³›å‹ã€æšä¸¾ï¼‰
2. **å…¶æ¬¡**ï¼šè¿è¡Œæ—¶çµæ´»æ€§ï¼ˆTrait Objectï¼‰
3. **è°¨æ…**ï¼šå¤æ‚æ¨¡å¼ç»„åˆ
4. **é¿å…**ï¼šè¿‡åº¦å·¥ç¨‹

---

## ğŸ“š ç›¸å…³èµ„æº

- **Tier 2**: [å®è·µæŒ‡å—](../tier_02_guides/)
- **Tier 3-04**: [æ€§èƒ½è¯„ä¼°](./04_æ¨¡å¼æ€§èƒ½è¯„ä¼°å‚è€ƒ.md)
- **Tier 4**: [å½¢å¼åŒ–ç†è®º](../tier_04_advanced/)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-23
