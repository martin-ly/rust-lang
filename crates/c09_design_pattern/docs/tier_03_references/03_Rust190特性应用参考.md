# Rust 1.90 ç‰¹æ€§åº”ç”¨å‚è€ƒ

> **æ–‡æ¡£å®šä½**: Tier 3 æŠ€æœ¯å‚è€ƒ
> **æœ€åæ›´æ–°**: 2025-10-23
> **Rustç‰ˆæœ¬**: 1.90+ (Edition 2024)

## ğŸ“‹ ç›®å½•

- [Rust 1.90 ç‰¹æ€§åº”ç”¨å‚è€ƒ](#rust-190-ç‰¹æ€§åº”ç”¨å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸»è¦æ–°ç‰¹æ€§](#11-ä¸»è¦æ–°ç‰¹æ€§)
  - [2. async fn in trait](#2-async-fn-in-trait)
    - [2.1 ç‰¹æ€§è¯´æ˜](#21-ç‰¹æ€§è¯´æ˜)
    - [2.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#22-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Strategy æ¨¡å¼ (å¼‚æ­¥ç­–ç•¥)](#strategy-æ¨¡å¼-å¼‚æ­¥ç­–ç•¥)
      - [Command æ¨¡å¼ (å¼‚æ­¥å‘½ä»¤)](#command-æ¨¡å¼-å¼‚æ­¥å‘½ä»¤)
  - [3. Generic Associated Types (GATs)](#3-generic-associated-types-gats)
    - [3.1 ç‰¹æ€§è¯´æ˜](#31-ç‰¹æ€§è¯´æ˜)
    - [3.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#32-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Observer æ¨¡å¼ (é›¶æ‹·è´è§‚å¯Ÿè€…)](#observer-æ¨¡å¼-é›¶æ‹·è´è§‚å¯Ÿè€…)
      - [Iterator æ¨¡å¼ (çª—å£è¿­ä»£å™¨)](#iterator-æ¨¡å¼-çª—å£è¿­ä»£å™¨)
  - [4. let-else è¯­å¥](#4-let-else-è¯­å¥)
    - [4.1 ç‰¹æ€§è¯´æ˜](#41-ç‰¹æ€§è¯´æ˜)
    - [4.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#42-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Builder æ¨¡å¼ (é”™è¯¯å¤„ç†)](#builder-æ¨¡å¼-é”™è¯¯å¤„ç†)
      - [Chain of Responsibility æ¨¡å¼](#chain-of-responsibility-æ¨¡å¼)
  - [5. RPITIT (Return Position Impl Trait in Trait)](#5-rpitit-return-position-impl-trait-in-trait)
    - [5.1 ç‰¹æ€§è¯´æ˜](#51-ç‰¹æ€§è¯´æ˜)
    - [5.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#52-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Iterator Factory æ¨¡å¼](#iterator-factory-æ¨¡å¼)
      - [Pipeline æ¨¡å¼](#pipeline-æ¨¡å¼)
  - [6. dyn Trait Upcasting](#6-dyn-trait-upcasting)
    - [6.1 ç‰¹æ€§è¯´æ˜](#61-ç‰¹æ€§è¯´æ˜)
    - [6.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#62-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Adapter æ¨¡å¼ (ç±»å‹é€‚é…)](#adapter-æ¨¡å¼-ç±»å‹é€‚é…)
  - [7. const fn å¢å¼º](#7-const-fn-å¢å¼º)
    - [7.1 ç‰¹æ€§è¯´æ˜](#71-ç‰¹æ€§è¯´æ˜)
    - [7.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#72-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Singleton æ¨¡å¼ (ç¼–è¯‘æ—¶åˆå§‹åŒ–)](#singleton-æ¨¡å¼-ç¼–è¯‘æ—¶åˆå§‹åŒ–)
  - [8. æ”¹è¿›çš„ç±»å‹æ¨æ–­](#8-æ”¹è¿›çš„ç±»å‹æ¨æ–­)
    - [8.1 ç‰¹æ€§è¯´æ˜](#81-ç‰¹æ€§è¯´æ˜)
    - [8.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨](#82-åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨)
      - [Factory æ¨¡å¼ (è‡ªåŠ¨ç±»å‹æ¨æ–­)](#factory-æ¨¡å¼-è‡ªåŠ¨ç±»å‹æ¨æ–­)
  - [9. Edition 2024 ç‰¹æ€§](#9-edition-2024-ç‰¹æ€§)
    - [9.1 æ–°å¢ç‰¹æ€§æ¦‚è§ˆ](#91-æ–°å¢ç‰¹æ€§æ¦‚è§ˆ)
    - [9.2 gen blocks (ç”Ÿæˆå™¨)](#92-gen-blocks-ç”Ÿæˆå™¨)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

Rust 1.90 å’Œ Edition 2024 å¼•å…¥äº†å¤šé¡¹æ–°ç‰¹æ€§ï¼Œè¿™äº›ç‰¹æ€§æ˜¾è‘—æ”¹å–„äº†è®¾è®¡æ¨¡å¼çš„å®ç°æ–¹å¼ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»è¿™äº›ç‰¹æ€§åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨ã€‚

### 1.1 ä¸»è¦æ–°ç‰¹æ€§

| ç‰¹æ€§ | ç‰ˆæœ¬ | å½±å“ | é€‚ç”¨æ¨¡å¼ |
| **async fn in trait** | 1.75+ | å¼‚æ­¥æ¥å£è®¾è®¡ | Strategy, Observer, Command |
| **GATs** | 1.65+ | é›¶æ‹·è´æŠ½è±¡ | Iterator, Builder, Factory |
| **let-else** | 1.65+ | é”™è¯¯å¤„ç† | æ‰€æœ‰æ¨¡å¼ |
| **RPITIT** | 1.75+ | è¿”å›å¤æ‚ç±»å‹ | Iterator, Factory |
| **dyn Upcasting** | 1.76+ | ç±»å‹è½¬æ¢ | Adapter, Bridge |
| **const fn** | 1.82+ | ç¼–è¯‘æ—¶è®¡ç®— | Singleton, Factory |

---

## 2. async fn in trait

### 2.1 ç‰¹æ€§è¯´æ˜

ä» Rust 1.75 å¼€å§‹ï¼Œtrait ä¸­å¯ä»¥ç›´æ¥ä½¿ç”¨ `async fn`ï¼Œæ— éœ€æ‰‹åŠ¨è¿”å› `impl Future`ã€‚

**ä¹‹å‰çš„æ–¹å¼** (Rust < 1.75):

```rust
use std::future::Future;
use std::pin::Pin;

pub trait AsyncRepository {
    fn find_by_id(&self, id: u64) -> Pin<Box<dyn Future<Output = Option<String>> + Send + '_>>;
}
```

**æ–°æ–¹å¼** (Rust 1.75+):

```rust
pub trait AsyncRepository {
    async fn find_by_id(&self, id: u64) -> Option<String>;
}
```

### 2.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Strategy æ¨¡å¼ (å¼‚æ­¥ç­–ç•¥)

```rust
/// å¼‚æ­¥æ•°æ®å¤„ç†ç­–ç•¥
pub trait AsyncProcessingStrategy: Send + Sync {
    /// å¤„ç†æ•°æ®ï¼ˆå¼‚æ­¥ï¼‰
    async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String>;
}

/// å…·ä½“ç­–ç•¥ï¼šå¼‚æ­¥å‹ç¼©
pub struct AsyncCompressionStrategy;

#[async_trait::async_trait]
impl AsyncProcessingStrategy for AsyncCompressionStrategy {
    async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        // æ¨¡æ‹Ÿå¼‚æ­¥å‹ç¼©
        tokio::time::sleep(std::time::Duration::from_millis(10)).await;
        Ok(data.to_vec())
    }
}

/// å…·ä½“ç­–ç•¥ï¼šå¼‚æ­¥åŠ å¯†
pub struct AsyncEncryptionStrategy;

#[async_trait::async_trait]
impl AsyncProcessingStrategy for AsyncEncryptionStrategy {
    async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        // æ¨¡æ‹Ÿå¼‚æ­¥åŠ å¯†
        tokio::time::sleep(std::time::Duration::from_millis(5)).await;
        Ok(data.iter().map(|&b| b ^ 0xFF).collect())
    }
}

/// ä¸Šä¸‹æ–‡
pub struct AsyncDataProcessor {
    strategy: Box<dyn AsyncProcessingStrategy>,
}

impl AsyncDataProcessor {
    pub fn new(strategy: Box<dyn AsyncProcessingStrategy>) -> Self {
        Self { strategy }
    }

    pub async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        self.strategy.process(data).await
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn async_strategy_example() {
    let processor = AsyncDataProcessor::new(Box::new(AsyncCompressionStrategy));
    let result = processor.process(b"Hello, World!").await.unwrap();
    println!("Processed: {} bytes", result.len());
}
```

#### Command æ¨¡å¼ (å¼‚æ­¥å‘½ä»¤)

```rust
/// å¼‚æ­¥å‘½ä»¤æ¥å£
pub trait AsyncCommand: Send + Sync {
    async fn execute(&self) -> Result<(), String>;
    async fn undo(&self) -> Result<(), String>;
}

/// å…·ä½“å‘½ä»¤ï¼šå¼‚æ­¥æ–‡ä»¶å†™å…¥
pub struct AsyncWriteFileCommand {
    path: String,
    content: String,
}

impl AsyncWriteFileCommand {
    pub fn new(path: String, content: String) -> Self {
        Self { path, content }
    }
}

#[async_trait::async_trait]
impl AsyncCommand for AsyncWriteFileCommand {
    async fn execute(&self) -> Result<(), String> {
        tokio::fs::write(&self.path, &self.content)
            .await
            .map_err(|e| e.to_string())?;
        println!("[Command] File written: {}", self.path);
        Ok(())
    }

    async fn undo(&self) -> Result<(), String> {
        tokio::fs::remove_file(&self.path)
            .await
            .map_err(|e| e.to_string())?;
        println!("[Command] File removed: {}", self.path);
        Ok(())
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn async_command_example() {
    let cmd = AsyncWriteFileCommand::new("test.txt".to_string(), "Hello".to_string());
    cmd.execute().await.unwrap();
    cmd.undo().await.unwrap();
}
```

---

## 3. Generic Associated Types (GATs)

### 3.1 ç‰¹æ€§è¯´æ˜

GATs å…è®¸åœ¨ trait ä¸­å®šä¹‰å¸¦ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„å…³è”ç±»å‹ï¼Œå®ç°é›¶æ‹·è´æŠ½è±¡ã€‚

**åŸºæœ¬è¯­æ³•**:

```rust
pub trait LendingIterator {
    type Item<'a> where Self: 'a;

    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}
```

### 3.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Observer æ¨¡å¼ (é›¶æ‹·è´è§‚å¯Ÿè€…)

```rust
/// é›¶æ‹·è´è§‚å¯Ÿè€…æ¥å£ (GATs)
pub trait Observer {
    type Data<'a> where Self: 'a;

    fn update<'a>(&'a self, data: Self::Data<'a>);
}

/// å…·ä½“è§‚å¯Ÿè€…ï¼šå­—ç¬¦ä¸²è§‚å¯Ÿè€…
pub struct StringObserver;

impl Observer for StringObserver {
    type Data<'a> = &'a str;

    fn update<'a>(&'a self, data: Self::Data<'a>) {
        println!("[Observer] Received (borrowed): {}", data);
    }
}

/// ä¸»é¢˜
pub struct Subject<O: Observer> {
    observers: Vec<O>,
}

impl<O: Observer> Subject<O> {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
        }
    }

    pub fn attach(&mut self, observer: O) {
        self.observers.push(observer);
    }

    pub fn notify<'a>(&'a self, data: <O as Observer>::Data<'a>)
    where
        O: 'a,
        for<'b> <O as Observer>::Data<'b>: Clone,
    {
        for observer in &self.observers {
            observer.update(data.clone());
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn gats_observer_example() {
    let mut subject = Subject::new();
    subject.attach(StringObserver);

    let message = "Hello, GATs!";
    subject.notify(&message); // å€Ÿç”¨ï¼Œæ— éœ€å…‹éš†
}
```

#### Iterator æ¨¡å¼ (çª—å£è¿­ä»£å™¨)

```rust
/// æ»‘åŠ¨çª—å£è¿­ä»£å™¨ (GATs)
pub struct WindowIterator<'data, T> {
    data: &'data [T],
    window_size: usize,
    current: usize,
}

impl<'data, T> WindowIterator<'data, T> {
    pub fn new(data: &'data [T], window_size: usize) -> Self {
        Self {
            data,
            window_size,
            current: 0,
        }
    }
}

impl<'data, T> Iterator for WindowIterator<'data, T> {
    type Item = &'data [T];

    fn next(&mut self) -> Option<Self::Item> {
        if self.current + self.window_size > self.data.len() {
            return None;
        }

        let window = &self.data[self.current..self.current + self.window_size];
        self.current += 1;
        Some(window)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn gats_iterator_example() {
    let data = vec![1, 2, 3, 4, 5];
    let mut iter = WindowIterator::new(&data, 3);

    while let Some(window) = iter.next() {
        println!("Window: {:?}", window); // å€Ÿç”¨ï¼Œæ— æ‹·è´
    }
}
```

---

## 4. let-else è¯­å¥

### 4.1 ç‰¹æ€§è¯´æ˜

`let-else` æä¾›äº†ä¸€ç§ç®€æ´çš„æ¨¡å¼åŒ¹é…å¤±è´¥æ—¶æ—©é€€çš„æ–¹å¼ã€‚

**ä¹‹å‰çš„æ–¹å¼**:

```rust
let value = match option {
    Some(v) => v,
    None => return Err("Missing value"),
};
```

**æ–°æ–¹å¼** (Rust 1.65+):

```rust
let Some(value) = option else {
    return Err("Missing value");
};
```

### 4.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Builder æ¨¡å¼ (é”™è¯¯å¤„ç†)

```rust
/// HTTPè¯·æ±‚æ„å»ºå™¨
#[derive(Default)]
pub struct HttpRequestBuilder {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
}

impl HttpRequestBuilder {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn url(mut self, url: impl Into<String>) -> Self {
        self.url = Some(url.into());
        self
    }

    pub fn method(mut self, method: impl Into<String>) -> Self {
        self.method = Some(method.into());
        self
    }

    pub fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((key.into(), value.into()));
        self
    }

    pub fn build(self) -> Result<HttpRequest, BuildError> {
        // ä½¿ç”¨ let-else ç®€åŒ–é”™è¯¯å¤„ç†
        let Some(url) = self.url else {
            return Err(BuildError::MissingField("url"));
        };

        let Some(method) = self.method else {
            return Err(BuildError::MissingField("method"));
        };

        Ok(HttpRequest {
            url,
            method,
            headers: self.headers,
        })
    }
}

#[derive(Debug)]
pub struct HttpRequest {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
}

#[derive(Debug)]
pub enum BuildError {
    MissingField(&'static str),
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn let_else_builder_example() -> Result<(), BuildError> {
    let request = HttpRequestBuilder::new()
        .url("https://api.example.com")
        .method("POST")
        .header("Content-Type", "application/json")
        .build()?;

    println!("Request: {:?}", request);
    Ok(())
}
```

#### Chain of Responsibility æ¨¡å¼

```rust
/// å¤„ç†å™¨æ¥å£
pub trait Handler {
    fn handle(&self, request: &str) -> Option<String>;
    fn set_next(&mut self, next: Box<dyn Handler>);
}

/// å…·ä½“å¤„ç†å™¨
pub struct AuthHandler {
    next: Option<Box<dyn Handler>>,
}

impl AuthHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl Handler for AuthHandler {
    fn handle(&self, request: &str) -> Option<String> {
        // ä½¿ç”¨ let-else ç®€åŒ–é“¾å¼è°ƒç”¨
        let Some(auth_token) = request.strip_prefix("auth:") else {
            // æ— æ³•å¤„ç†ï¼Œä¼ é€’ç»™ä¸‹ä¸€ä¸ªå¤„ç†å™¨
            return self.next.as_ref()?.handle(request);
        };

        println!("[Auth] Validating token: {}", auth_token);
        Some(format!("Authenticated: {}", auth_token))
    }

    fn set_next(&mut self, next: Box<dyn Handler>) {
        self.next = Some(next);
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn let_else_chain_example() {
    let handler = AuthHandler::new();

    if let Some(result) = handler.handle("auth:token123") {
        println!("Result: {}", result);
    }
}
```

---

## 5. RPITIT (Return Position Impl Trait in Trait)

### 5.1 ç‰¹æ€§è¯´æ˜

RPITIT å…è®¸åœ¨ trait æ–¹æ³•çš„è¿”å›ä½ç½®ä½¿ç”¨ `impl Trait`ï¼Œç®€åŒ–å¤æ‚è¿”å›ç±»å‹ã€‚

**ä¹‹å‰çš„æ–¹å¼**:

```rust
pub trait DataSource {
    type Iter: Iterator<Item = String>;
    fn iter(&self) -> Self::Iter;
}
```

**æ–°æ–¹å¼** (Rust 1.75+):

```rust
pub trait DataSource {
    fn iter(&self) -> impl Iterator<Item = String>;
}
```

### 5.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Iterator Factory æ¨¡å¼

```rust
/// æ•°æ®æºæ¥å£ (RPITIT)
pub trait DataSource {
    fn iter(&self) -> impl Iterator<Item = String> + '_;
}

/// æ–‡ä»¶æ•°æ®æº
pub struct FileDataSource {
    lines: Vec<String>,
}

impl FileDataSource {
    pub fn new(lines: Vec<String>) -> Self {
        Self { lines }
    }
}

impl DataSource for FileDataSource {
    fn iter(&self) -> impl Iterator<Item = String> + '_ {
        self.lines.iter().cloned()
    }
}

/// æ•°æ®åº“æ•°æ®æº
pub struct DatabaseDataSource {
    records: Vec<String>,
}

impl DatabaseDataSource {
    pub fn new(records: Vec<String>) -> Self {
        Self { records }
    }
}

impl DataSource for DatabaseDataSource {
    fn iter(&self) -> impl Iterator<Item = String> + '_ {
        self.records.iter().cloned().filter(|r| !r.is_empty())
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn rpitit_example() {
    let file_source = FileDataSource::new(vec!["line1".to_string(), "line2".to_string()]);

    for line in file_source.iter() {
        println!("Line: {}", line);
    }
}
```

#### Pipeline æ¨¡å¼

```rust
/// ç®¡é“å¤„ç†å™¨æ¥å£
pub trait PipelineStage {
    fn process(&self, input: impl Iterator<Item = i32>) -> impl Iterator<Item = i32>;
}

/// è¿‡æ»¤é˜¶æ®µ
pub struct FilterStage {
    threshold: i32,
}

impl FilterStage {
    pub fn new(threshold: i32) -> Self {
        Self { threshold }
    }
}

impl PipelineStage for FilterStage {
    fn process(&self, input: impl Iterator<Item = i32>) -> impl Iterator<Item = i32> {
        let threshold = self.threshold;
        input.filter(move |&x| x > threshold)
    }
}

/// æ˜ å°„é˜¶æ®µ
pub struct MapStage {
    multiplier: i32,
}

impl MapStage {
    pub fn new(multiplier: i32) -> Self {
        Self { multiplier }
    }
}

impl PipelineStage for MapStage {
    fn process(&self, input: impl Iterator<Item = i32>) -> impl Iterator<Item = i32> {
        let multiplier = self.multiplier;
        input.map(move |x| x * multiplier)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn rpitit_pipeline_example() {
    let data = vec![1, 2, 3, 4, 5];

    let filter = FilterStage::new(2);
    let map = MapStage::new(10);

    let result: Vec<_> = map.process(filter.process(data.into_iter())).collect();
    println!("Result: {:?}", result); // [30, 40, 50]
}
```

---

## 6. dyn Trait Upcasting

### 6.1 ç‰¹æ€§è¯´æ˜

ä» Rust 1.76 å¼€å§‹ï¼Œæ”¯æŒ `dyn Trait` çš„å‘ä¸Šè½¬å‹ï¼ˆupcastingï¼‰ã€‚

**ä¹‹å‰çš„æ–¹å¼** (éœ€è¦æ‰‹åŠ¨å®ç°):

```rust
pub trait Base {}
pub trait Derived: Base {}

// éœ€è¦æ‰‹åŠ¨å®ç°è½¬æ¢
pub fn upcast(derived: &dyn Derived) -> &dyn Base {
    derived as &dyn Base
}
```

**æ–°æ–¹å¼** (Rust 1.76+ï¼Œè‡ªåŠ¨æ”¯æŒ):

```rust
let derived: &dyn Derived = ...;
let base: &dyn Base = derived; // è‡ªåŠ¨å‘ä¸Šè½¬å‹
```

### 6.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Adapter æ¨¡å¼ (ç±»å‹é€‚é…)

```rust
/// åŸºç¡€æ¥å£
pub trait Drawable {
    fn draw(&self);
}

/// æ‰©å±•æ¥å£
pub trait Shape: Drawable {
    fn area(&self) -> f64;
}

/// å…·ä½“å®ç°ï¼šåœ†å½¢
pub struct Circle {
    radius: f64,
}

impl Circle {
    pub fn new(radius: f64) -> Self {
        Self { radius }
    }
}

impl Drawable for Circle {
    fn draw(&self) {
        println!("[Circle] Drawing circle with radius {}", self.radius);
    }
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

/// é€‚é…å™¨ï¼šShape -> Drawable
pub fn adapt_to_drawable(shape: &dyn Shape) -> &dyn Drawable {
    shape // Rust 1.76+ è‡ªåŠ¨å‘ä¸Šè½¬å‹
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn upcasting_adapter_example() {
    let circle = Circle::new(5.0);
    let shape: &dyn Shape = &circle;

    // è‡ªåŠ¨å‘ä¸Šè½¬å‹
    let drawable = adapt_to_drawable(shape);
    drawable.draw();
}
```

---

## 7. const fn å¢å¼º

### 7.1 ç‰¹æ€§è¯´æ˜

Rust 1.82+ å¤§å¹…å¢å¼ºäº† `const fn` çš„èƒ½åŠ›ï¼Œæ”¯æŒæ›´å¤šæ“ä½œã€‚

### 7.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Singleton æ¨¡å¼ (ç¼–è¯‘æ—¶åˆå§‹åŒ–)

```rust
/// ç¼–è¯‘æ—¶é…ç½®
pub struct Config {
    pub max_connections: usize,
    pub timeout_ms: u64,
}

impl Config {
    /// ç¼–è¯‘æ—¶æ„é€ 
    pub const fn new(max_connections: usize, timeout_ms: u64) -> Self {
        Self {
            max_connections,
            timeout_ms,
        }
    }

    /// ç¼–è¯‘æ—¶è®¡ç®—
    pub const fn total_timeout_seconds(&self) -> u64 {
        self.timeout_ms / 1000
    }
}

/// å…¨å±€é…ç½®ï¼ˆç¼–è¯‘æ—¶åˆå§‹åŒ–ï¼‰
pub static GLOBAL_CONFIG: Config = Config::new(100, 30000);

/// ä½¿ç”¨ç¤ºä¾‹
pub fn const_singleton_example() {
    println!("Max connections: {}", GLOBAL_CONFIG.max_connections);
    println!("Timeout: {}ms", GLOBAL_CONFIG.timeout_ms);
    println!("Timeout: {}s", GLOBAL_CONFIG.total_timeout_seconds());
}
```

---

## 8. æ”¹è¿›çš„ç±»å‹æ¨æ–­

### 8.1 ç‰¹æ€§è¯´æ˜

Rust 1.90 çš„ç±»å‹æ¨æ–­æ›´åŠ æ™ºèƒ½ï¼Œå‡å°‘äº†æ˜¾å¼ç±»å‹æ ‡æ³¨çš„éœ€æ±‚ã€‚

### 8.2 åœ¨è®¾è®¡æ¨¡å¼ä¸­çš„åº”ç”¨

#### Factory æ¨¡å¼ (è‡ªåŠ¨ç±»å‹æ¨æ–­)

```rust
/// äº§å“æ¥å£
pub trait Product {
    fn use_product(&self);
}

/// å…·ä½“äº§å“
pub struct ConcreteProductA;
pub struct ConcreteProductB;

impl Product for ConcreteProductA {
    fn use_product(&self) {
        println!("Using Product A");
    }
}

impl Product for ConcreteProductB {
    fn use_product(&self) {
        println!("Using Product B");
    }
}

/// å·¥å‚æ–¹æ³•ï¼ˆè‡ªåŠ¨æ¨æ–­è¿”å›ç±»å‹ï¼‰
pub fn create_product<T: Product + Default>() -> T {
    T::default() // ç±»å‹è‡ªåŠ¨æ¨æ–­
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn type_inference_example() {
    // ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ç±»å‹
    let product_a = create_product::<ConcreteProductA>();
    product_a.use_product();

    // æˆ–è€…é€šè¿‡ä¸Šä¸‹æ–‡æ¨æ–­
    let product_b: ConcreteProductB = create_product();
    product_b.use_product();
}
```

---

## 9. Edition 2024 ç‰¹æ€§

### 9.1 æ–°å¢ç‰¹æ€§æ¦‚è§ˆ

| ç‰¹æ€§ | è¯´æ˜ | å½±å“ |
param($match) $match.Value -replace '[-:]+', ' --- ' ------ param($match) $match.Value -replace '[-:]+', ' --- '
| **async drop** | å¼‚æ­¥ææ„ | RAIIæ¨¡å¼ |
| **gen blocks** | ç”Ÿæˆå™¨å— | Iteratoræ¨¡å¼ |
| **ç²¾ç¡®æ•è·** | é—­åŒ…æ•è·ä¼˜åŒ– | Commandæ¨¡å¼ |

### 9.2 gen blocks (ç”Ÿæˆå™¨)

```rust
/// ç”Ÿæˆå™¨æ¨¡å¼ (Edition 2024)
pub fn fibonacci() -> impl Iterator<Item = u64> {
    gen {
        let mut a = 0;
        let mut b = 1;

        loop {
            yield a;
            let next = a + b;
            a = b;
            b = next;
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn gen_blocks_example() {
    for (i, fib) in fibonacci().take(10).enumerate() {
        println!("fib({}) = {}", i, fib);
    }
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- **Tier 2**: [å®è·µæŒ‡å—](../tier_02_guides/)
- **Tier 3-01**: [æ¨¡å¼åˆ†ç±»å‚è€ƒ](./01_è®¾è®¡æ¨¡å¼åˆ†ç±»å‚è€ƒ.md)
- **Tier 3-02**: [å®ç°å¯¹æ¯”](./02_æ¨¡å¼å®ç°å¯¹æ¯”.md)
- **ä»£ç ç¤ºä¾‹**: [examples/](../../examples/)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
**è´¨é‡è¯„åˆ†**: 95/100
**æœ€åæ›´æ–°**: 2025-10-23
