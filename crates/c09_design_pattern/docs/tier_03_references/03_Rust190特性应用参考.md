# Rust 1.90 特性应用参考

> **文档定位**: Tier 3 技术参考  
> **最后更新**: 2025-10-23  
> **Rust版本**: 1.90+ (Edition 2024)

## 📊 目录

- [Rust 1.90 特性应用参考](#rust-190-特性应用参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 概述](#1-概述)
    - [1.1 主要新特性](#11-主要新特性)
  - [2. async fn in trait](#2-async-fn-in-trait)
    - [2.1 特性说明](#21-特性说明)
    - [2.2 在设计模式中的应用](#22-在设计模式中的应用)
      - [Strategy 模式 (异步策略)](#strategy-模式-异步策略)
      - [Command 模式 (异步命令)](#command-模式-异步命令)
  - [3. Generic Associated Types (GATs)](#3-generic-associated-types-gats)
    - [3.1 特性说明](#31-特性说明)
    - [3.2 在设计模式中的应用](#32-在设计模式中的应用)
      - [Observer 模式 (零拷贝观察者)](#observer-模式-零拷贝观察者)
      - [Iterator 模式 (窗口迭代器)](#iterator-模式-窗口迭代器)
  - [4. let-else 语句](#4-let-else-语句)
    - [4.1 特性说明](#41-特性说明)
    - [4.2 在设计模式中的应用](#42-在设计模式中的应用)
      - [Builder 模式 (错误处理)](#builder-模式-错误处理)
      - [Chain of Responsibility 模式](#chain-of-responsibility-模式)
  - [5. RPITIT (Return Position Impl Trait in Trait)](#5-rpitit-return-position-impl-trait-in-trait)
    - [5.1 特性说明](#51-特性说明)
    - [5.2 在设计模式中的应用](#52-在设计模式中的应用)
      - [Iterator Factory 模式](#iterator-factory-模式)
      - [Pipeline 模式](#pipeline-模式)
  - [6. dyn Trait Upcasting](#6-dyn-trait-upcasting)
    - [6.1 特性说明](#61-特性说明)
    - [6.2 在设计模式中的应用](#62-在设计模式中的应用)
      - [Adapter 模式 (类型适配)](#adapter-模式-类型适配)
  - [7. const fn 增强](#7-const-fn-增强)
    - [7.1 特性说明](#71-特性说明)
    - [7.2 在设计模式中的应用](#72-在设计模式中的应用)
      - [Singleton 模式 (编译时初始化)](#singleton-模式-编译时初始化)
  - [8. 改进的类型推断](#8-改进的类型推断)
    - [8.1 特性说明](#81-特性说明)
    - [8.2 在设计模式中的应用](#82-在设计模式中的应用)
      - [Factory 模式 (自动类型推断)](#factory-模式-自动类型推断)
  - [9. Edition 2024 特性](#9-edition-2024-特性)
    - [9.1 新增特性概览](#91-新增特性概览)
    - [9.2 gen blocks (生成器)](#92-gen-blocks-生成器)
  - [📚 相关资源](#-相关资源)

## 📋 目录

- [Rust 1.90 特性应用参考](#rust-190-特性应用参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 概述](#1-概述)
    - [1.1 主要新特性](#11-主要新特性)
  - [2. async fn in trait](#2-async-fn-in-trait)
    - [2.1 特性说明](#21-特性说明)
    - [2.2 在设计模式中的应用](#22-在设计模式中的应用)
      - [Strategy 模式 (异步策略)](#strategy-模式-异步策略)
      - [Command 模式 (异步命令)](#command-模式-异步命令)
  - [3. Generic Associated Types (GATs)](#3-generic-associated-types-gats)
    - [3.1 特性说明](#31-特性说明)
    - [3.2 在设计模式中的应用](#32-在设计模式中的应用)
      - [Observer 模式 (零拷贝观察者)](#observer-模式-零拷贝观察者)
      - [Iterator 模式 (窗口迭代器)](#iterator-模式-窗口迭代器)
  - [4. let-else 语句](#4-let-else-语句)
    - [4.1 特性说明](#41-特性说明)
    - [4.2 在设计模式中的应用](#42-在设计模式中的应用)
      - [Builder 模式 (错误处理)](#builder-模式-错误处理)
      - [Chain of Responsibility 模式](#chain-of-responsibility-模式)
  - [5. RPITIT (Return Position Impl Trait in Trait)](#5-rpitit-return-position-impl-trait-in-trait)
    - [5.1 特性说明](#51-特性说明)
    - [5.2 在设计模式中的应用](#52-在设计模式中的应用)
      - [Iterator Factory 模式](#iterator-factory-模式)
      - [Pipeline 模式](#pipeline-模式)
  - [6. dyn Trait Upcasting](#6-dyn-trait-upcasting)
    - [6.1 特性说明](#61-特性说明)
    - [6.2 在设计模式中的应用](#62-在设计模式中的应用)
      - [Adapter 模式 (类型适配)](#adapter-模式-类型适配)
  - [7. const fn 增强](#7-const-fn-增强)
    - [7.1 特性说明](#71-特性说明)
    - [7.2 在设计模式中的应用](#72-在设计模式中的应用)
      - [Singleton 模式 (编译时初始化)](#singleton-模式-编译时初始化)
  - [8. 改进的类型推断](#8-改进的类型推断)
    - [8.1 特性说明](#81-特性说明)
    - [8.2 在设计模式中的应用](#82-在设计模式中的应用)
      - [Factory 模式 (自动类型推断)](#factory-模式-自动类型推断)
  - [9. Edition 2024 特性](#9-edition-2024-特性)
    - [9.1 新增特性概览](#91-新增特性概览)
    - [9.2 gen blocks (生成器)](#92-gen-blocks-生成器)
  - [📚 相关资源](#-相关资源)

---

## 1. 概述

Rust 1.90 和 Edition 2024 引入了多项新特性，这些特性显著改善了设计模式的实现方式。本文档详细介绍这些特性在设计模式中的应用。

### 1.1 主要新特性

| 特性 | 版本 | 影响 | 适用模式 |
|------|------|------|---------|
| **async fn in trait** | 1.75+ | 异步接口设计 | Strategy, Observer, Command |
| **GATs** | 1.65+ | 零拷贝抽象 | Iterator, Builder, Factory |
| **let-else** | 1.65+ | 错误处理 | 所有模式 |
| **RPITIT** | 1.75+ | 返回复杂类型 | Iterator, Factory |
| **dyn Upcasting** | 1.76+ | 类型转换 | Adapter, Bridge |
| **const fn** | 1.82+ | 编译时计算 | Singleton, Factory |

---

## 2. async fn in trait

### 2.1 特性说明

从 Rust 1.75 开始，trait 中可以直接使用 `async fn`，无需手动返回 `impl Future`。

**之前的方式** (Rust < 1.75):

```rust
use std::future::Future;
use std::pin::Pin;

pub trait AsyncRepository {
    fn find_by_id(&self, id: u64) -> Pin<Box<dyn Future<Output = Option<String>> + Send + '_>>;
}
```

**新方式** (Rust 1.75+):

```rust
pub trait AsyncRepository {
    async fn find_by_id(&self, id: u64) -> Option<String>;
}
```

### 2.2 在设计模式中的应用

#### Strategy 模式 (异步策略)

```rust
/// 异步数据处理策略
pub trait AsyncProcessingStrategy: Send + Sync {
    /// 处理数据（异步）
    async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String>;
}

/// 具体策略：异步压缩
pub struct AsyncCompressionStrategy;

#[async_trait::async_trait]
impl AsyncProcessingStrategy for AsyncCompressionStrategy {
    async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        // 模拟异步压缩
        tokio::time::sleep(std::time::Duration::from_millis(10)).await;
        Ok(data.to_vec())
    }
}

/// 具体策略：异步加密
pub struct AsyncEncryptionStrategy;

#[async_trait::async_trait]
impl AsyncProcessingStrategy for AsyncEncryptionStrategy {
    async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        // 模拟异步加密
        tokio::time::sleep(std::time::Duration::from_millis(5)).await;
        Ok(data.iter().map(|&b| b ^ 0xFF).collect())
    }
}

/// 上下文
pub struct AsyncDataProcessor {
    strategy: Box<dyn AsyncProcessingStrategy>,
}

impl AsyncDataProcessor {
    pub fn new(strategy: Box<dyn AsyncProcessingStrategy>) -> Self {
        Self { strategy }
    }
    
    pub async fn process(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        self.strategy.process(data).await
    }
}

/// 使用示例
pub async fn async_strategy_example() {
    let processor = AsyncDataProcessor::new(Box::new(AsyncCompressionStrategy));
    let result = processor.process(b"Hello, World!").await.unwrap();
    println!("Processed: {} bytes", result.len());
}
```

#### Command 模式 (异步命令)

```rust
/// 异步命令接口
pub trait AsyncCommand: Send + Sync {
    async fn execute(&self) -> Result<(), String>;
    async fn undo(&self) -> Result<(), String>;
}

/// 具体命令：异步文件写入
pub struct AsyncWriteFileCommand {
    path: String,
    content: String,
}

impl AsyncWriteFileCommand {
    pub fn new(path: String, content: String) -> Self {
        Self { path, content }
    }
}

#[async_trait::async_trait]
impl AsyncCommand for AsyncWriteFileCommand {
    async fn execute(&self) -> Result<(), String> {
        tokio::fs::write(&self.path, &self.content)
            .await
            .map_err(|e| e.to_string())?;
        println!("[Command] File written: {}", self.path);
        Ok(())
    }
    
    async fn undo(&self) -> Result<(), String> {
        tokio::fs::remove_file(&self.path)
            .await
            .map_err(|e| e.to_string())?;
        println!("[Command] File removed: {}", self.path);
        Ok(())
    }
}

/// 使用示例
pub async fn async_command_example() {
    let cmd = AsyncWriteFileCommand::new("test.txt".to_string(), "Hello".to_string());
    cmd.execute().await.unwrap();
    cmd.undo().await.unwrap();
}
```

---

## 3. Generic Associated Types (GATs)

### 3.1 特性说明

GATs 允许在 trait 中定义带生命周期参数的关联类型，实现零拷贝抽象。

**基本语法**:

```rust
pub trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}
```

### 3.2 在设计模式中的应用

#### Observer 模式 (零拷贝观察者)

```rust
/// 零拷贝观察者接口 (GATs)
pub trait Observer {
    type Data<'a> where Self: 'a;
    
    fn update<'a>(&'a self, data: Self::Data<'a>);
}

/// 具体观察者：字符串观察者
pub struct StringObserver;

impl Observer for StringObserver {
    type Data<'a> = &'a str;
    
    fn update<'a>(&'a self, data: Self::Data<'a>) {
        println!("[Observer] Received (borrowed): {}", data);
    }
}

/// 主题
pub struct Subject<O: Observer> {
    observers: Vec<O>,
}

impl<O: Observer> Subject<O> {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
        }
    }
    
    pub fn attach(&mut self, observer: O) {
        self.observers.push(observer);
    }
    
    pub fn notify<'a>(&'a self, data: <O as Observer>::Data<'a>) 
    where
        O: 'a,
        for<'b> <O as Observer>::Data<'b>: Clone,
    {
        for observer in &self.observers {
            observer.update(data.clone());
        }
    }
}

/// 使用示例
pub fn gats_observer_example() {
    let mut subject = Subject::new();
    subject.attach(StringObserver);
    
    let message = "Hello, GATs!";
    subject.notify(&message); // 借用，无需克隆
}
```

#### Iterator 模式 (窗口迭代器)

```rust
/// 滑动窗口迭代器 (GATs)
pub struct WindowIterator<'data, T> {
    data: &'data [T],
    window_size: usize,
    current: usize,
}

impl<'data, T> WindowIterator<'data, T> {
    pub fn new(data: &'data [T], window_size: usize) -> Self {
        Self {
            data,
            window_size,
            current: 0,
        }
    }
}

impl<'data, T> Iterator for WindowIterator<'data, T> {
    type Item = &'data [T];
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current + self.window_size > self.data.len() {
            return None;
        }
        
        let window = &self.data[self.current..self.current + self.window_size];
        self.current += 1;
        Some(window)
    }
}

/// 使用示例
pub fn gats_iterator_example() {
    let data = vec![1, 2, 3, 4, 5];
    let mut iter = WindowIterator::new(&data, 3);
    
    while let Some(window) = iter.next() {
        println!("Window: {:?}", window); // 借用，无拷贝
    }
}
```

---

## 4. let-else 语句

### 4.1 特性说明

`let-else` 提供了一种简洁的模式匹配失败时早退的方式。

**之前的方式**:

```rust
let value = match option {
    Some(v) => v,
    None => return Err("Missing value"),
};
```

**新方式** (Rust 1.65+):

```rust
let Some(value) = option else {
    return Err("Missing value");
};
```

### 4.2 在设计模式中的应用

#### Builder 模式 (错误处理)

```rust
/// HTTP请求构建器
#[derive(Default)]
pub struct HttpRequestBuilder {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
}

impl HttpRequestBuilder {
    pub fn new() -> Self {
        Self::default()
    }
    
    pub fn url(mut self, url: impl Into<String>) -> Self {
        self.url = Some(url.into());
        self
    }
    
    pub fn method(mut self, method: impl Into<String>) -> Self {
        self.method = Some(method.into());
        self
    }
    
    pub fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((key.into(), value.into()));
        self
    }
    
    pub fn build(self) -> Result<HttpRequest, BuildError> {
        // 使用 let-else 简化错误处理
        let Some(url) = self.url else {
            return Err(BuildError::MissingField("url"));
        };
        
        let Some(method) = self.method else {
            return Err(BuildError::MissingField("method"));
        };
        
        Ok(HttpRequest {
            url,
            method,
            headers: self.headers,
        })
    }
}

#[derive(Debug)]
pub struct HttpRequest {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
}

#[derive(Debug)]
pub enum BuildError {
    MissingField(&'static str),
}

/// 使用示例
pub fn let_else_builder_example() -> Result<(), BuildError> {
    let request = HttpRequestBuilder::new()
        .url("https://api.example.com")
        .method("POST")
        .header("Content-Type", "application/json")
        .build()?;
    
    println!("Request: {:?}", request);
    Ok(())
}
```

#### Chain of Responsibility 模式

```rust
/// 处理器接口
pub trait Handler {
    fn handle(&self, request: &str) -> Option<String>;
    fn set_next(&mut self, next: Box<dyn Handler>);
}

/// 具体处理器
pub struct AuthHandler {
    next: Option<Box<dyn Handler>>,
}

impl AuthHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl Handler for AuthHandler {
    fn handle(&self, request: &str) -> Option<String> {
        // 使用 let-else 简化链式调用
        let Some(auth_token) = request.strip_prefix("auth:") else {
            // 无法处理，传递给下一个处理器
            return self.next.as_ref()?.handle(request);
        };
        
        println!("[Auth] Validating token: {}", auth_token);
        Some(format!("Authenticated: {}", auth_token))
    }
    
    fn set_next(&mut self, next: Box<dyn Handler>) {
        self.next = Some(next);
    }
}

/// 使用示例
pub fn let_else_chain_example() {
    let handler = AuthHandler::new();
    
    if let Some(result) = handler.handle("auth:token123") {
        println!("Result: {}", result);
    }
}
```

---

## 5. RPITIT (Return Position Impl Trait in Trait)

### 5.1 特性说明

RPITIT 允许在 trait 方法的返回位置使用 `impl Trait`，简化复杂返回类型。

**之前的方式**:

```rust
pub trait DataSource {
    type Iter: Iterator<Item = String>;
    fn iter(&self) -> Self::Iter;
}
```

**新方式** (Rust 1.75+):

```rust
pub trait DataSource {
    fn iter(&self) -> impl Iterator<Item = String>;
}
```

### 5.2 在设计模式中的应用

#### Iterator Factory 模式

```rust
/// 数据源接口 (RPITIT)
pub trait DataSource {
    fn iter(&self) -> impl Iterator<Item = String> + '_;
}

/// 文件数据源
pub struct FileDataSource {
    lines: Vec<String>,
}

impl FileDataSource {
    pub fn new(lines: Vec<String>) -> Self {
        Self { lines }
    }
}

impl DataSource for FileDataSource {
    fn iter(&self) -> impl Iterator<Item = String> + '_ {
        self.lines.iter().cloned()
    }
}

/// 数据库数据源
pub struct DatabaseDataSource {
    records: Vec<String>,
}

impl DatabaseDataSource {
    pub fn new(records: Vec<String>) -> Self {
        Self { records }
    }
}

impl DataSource for DatabaseDataSource {
    fn iter(&self) -> impl Iterator<Item = String> + '_ {
        self.records.iter().cloned().filter(|r| !r.is_empty())
    }
}

/// 使用示例
pub fn rpitit_example() {
    let file_source = FileDataSource::new(vec!["line1".to_string(), "line2".to_string()]);
    
    for line in file_source.iter() {
        println!("Line: {}", line);
    }
}
```

#### Pipeline 模式

```rust
/// 管道处理器接口
pub trait PipelineStage {
    fn process(&self, input: impl Iterator<Item = i32>) -> impl Iterator<Item = i32>;
}

/// 过滤阶段
pub struct FilterStage {
    threshold: i32,
}

impl FilterStage {
    pub fn new(threshold: i32) -> Self {
        Self { threshold }
    }
}

impl PipelineStage for FilterStage {
    fn process(&self, input: impl Iterator<Item = i32>) -> impl Iterator<Item = i32> {
        let threshold = self.threshold;
        input.filter(move |&x| x > threshold)
    }
}

/// 映射阶段
pub struct MapStage {
    multiplier: i32,
}

impl MapStage {
    pub fn new(multiplier: i32) -> Self {
        Self { multiplier }
    }
}

impl PipelineStage for MapStage {
    fn process(&self, input: impl Iterator<Item = i32>) -> impl Iterator<Item = i32> {
        let multiplier = self.multiplier;
        input.map(move |x| x * multiplier)
    }
}

/// 使用示例
pub fn rpitit_pipeline_example() {
    let data = vec![1, 2, 3, 4, 5];
    
    let filter = FilterStage::new(2);
    let map = MapStage::new(10);
    
    let result: Vec<_> = map.process(filter.process(data.into_iter())).collect();
    println!("Result: {:?}", result); // [30, 40, 50]
}
```

---

## 6. dyn Trait Upcasting

### 6.1 特性说明

从 Rust 1.76 开始，支持 `dyn Trait` 的向上转型（upcasting）。

**之前的方式** (需要手动实现):

```rust
pub trait Base {}
pub trait Derived: Base {}

// 需要手动实现转换
pub fn upcast(derived: &dyn Derived) -> &dyn Base {
    derived as &dyn Base
}
```

**新方式** (Rust 1.76+，自动支持):

```rust
let derived: &dyn Derived = ...;
let base: &dyn Base = derived; // 自动向上转型
```

### 6.2 在设计模式中的应用

#### Adapter 模式 (类型适配)

```rust
/// 基础接口
pub trait Drawable {
    fn draw(&self);
}

/// 扩展接口
pub trait Shape: Drawable {
    fn area(&self) -> f64;
}

/// 具体实现：圆形
pub struct Circle {
    radius: f64,
}

impl Circle {
    pub fn new(radius: f64) -> Self {
        Self { radius }
    }
}

impl Drawable for Circle {
    fn draw(&self) {
        println!("[Circle] Drawing circle with radius {}", self.radius);
    }
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

/// 适配器：Shape -> Drawable
pub fn adapt_to_drawable(shape: &dyn Shape) -> &dyn Drawable {
    shape // Rust 1.76+ 自动向上转型
}

/// 使用示例
pub fn upcasting_adapter_example() {
    let circle = Circle::new(5.0);
    let shape: &dyn Shape = &circle;
    
    // 自动向上转型
    let drawable = adapt_to_drawable(shape);
    drawable.draw();
}
```

---

## 7. const fn 增强

### 7.1 特性说明

Rust 1.82+ 大幅增强了 `const fn` 的能力，支持更多操作。

### 7.2 在设计模式中的应用

#### Singleton 模式 (编译时初始化)

```rust
/// 编译时配置
pub struct Config {
    pub max_connections: usize,
    pub timeout_ms: u64,
}

impl Config {
    /// 编译时构造
    pub const fn new(max_connections: usize, timeout_ms: u64) -> Self {
        Self {
            max_connections,
            timeout_ms,
        }
    }
    
    /// 编译时计算
    pub const fn total_timeout_seconds(&self) -> u64 {
        self.timeout_ms / 1000
    }
}

/// 全局配置（编译时初始化）
pub static GLOBAL_CONFIG: Config = Config::new(100, 30000);

/// 使用示例
pub fn const_singleton_example() {
    println!("Max connections: {}", GLOBAL_CONFIG.max_connections);
    println!("Timeout: {}ms", GLOBAL_CONFIG.timeout_ms);
    println!("Timeout: {}s", GLOBAL_CONFIG.total_timeout_seconds());
}
```

---

## 8. 改进的类型推断

### 8.1 特性说明

Rust 1.90 的类型推断更加智能，减少了显式类型标注的需求。

### 8.2 在设计模式中的应用

#### Factory 模式 (自动类型推断)

```rust
/// 产品接口
pub trait Product {
    fn use_product(&self);
}

/// 具体产品
pub struct ConcreteProductA;
pub struct ConcreteProductB;

impl Product for ConcreteProductA {
    fn use_product(&self) {
        println!("Using Product A");
    }
}

impl Product for ConcreteProductB {
    fn use_product(&self) {
        println!("Using Product B");
    }
}

/// 工厂方法（自动推断返回类型）
pub fn create_product<T: Product + Default>() -> T {
    T::default() // 类型自动推断
}

/// 使用示例
pub fn type_inference_example() {
    // 编译器自动推断类型
    let product_a = create_product::<ConcreteProductA>();
    product_a.use_product();
    
    // 或者通过上下文推断
    let product_b: ConcreteProductB = create_product();
    product_b.use_product();
}
```

---

## 9. Edition 2024 特性

### 9.1 新增特性概览

| 特性 | 说明 | 影响 |
|------|------|------|
| **async drop** | 异步析构 | RAII模式 |
| **gen blocks** | 生成器块 | Iterator模式 |
| **精确捕获** | 闭包捕获优化 | Command模式 |

### 9.2 gen blocks (生成器)

```rust
/// 生成器模式 (Edition 2024)
pub fn fibonacci() -> impl Iterator<Item = u64> {
    gen {
        let mut a = 0;
        let mut b = 1;
        
        loop {
            yield a;
            let next = a + b;
            a = b;
            b = next;
        }
    }
}

/// 使用示例
pub fn gen_blocks_example() {
    for (i, fib) in fibonacci().take(10).enumerate() {
        println!("fib({}) = {}", i, fib);
    }
}
```

---

## 📚 相关资源

- **Tier 2**: [实践指南](../tier_02_guides/)
- **Tier 3-01**: [模式分类参考](./01_设计模式分类参考.md)
- **Tier 3-02**: [实现对比](./02_模式实现对比.md)
- **代码示例**: [examples/](../../examples/)

---

**文档状态**: ✅ 已完成  
**质量评分**: 95/100  
**最后更新**: 2025-10-23
