# Tier 2: 进程监控与诊断

> **文档类型**: 实践指南  
> **难度**: ⭐⭐ 初级  
> **预计时间**: 1小时  
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 进程监控与诊断](#tier-2-进程监控与诊断)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 进程状态监控](#1-进程状态监控)
  - [2. 资源使用监控](#2-资源使用监控)
  - [3. 日志与调试](#3-日志与调试)
  - [4. 实战案例](#4-实战案例)

---

## 学习目标

- ✅ 监控进程状态
- ✅ 获取资源使用情况
- ✅ 实现日志记录
- ✅ 构建监控工具

---

## 1. 进程状态监控

**基础监控**:

```rust
use std::process::Command;

struct ProcessMonitor {
    pid: u32,
    start_time: std::time::Instant,
}

impl ProcessMonitor {
    fn new(pid: u32) -> Self {
        Self {
            pid,
            start_time: std::time::Instant::now(),
        }
    }
    
    fn uptime(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }
}

let mut child = Command::new("app").spawn()?;
let monitor = ProcessMonitor::new(child.id());

println!("PID: {}", monitor.pid);
println!("运行时长: {:?}", monitor.uptime());
```

---

## 2. 资源使用监控

**使用 sysinfo**:

```rust
use sysinfo::{System, SystemExt, ProcessExt, Pid};

let mut sys = System::new_all();
sys.refresh_all();

if let Some(process) = sys.process(Pid::from(child.id() as usize)) {
    println!("CPU: {}%", process.cpu_usage());
    println!("内存: {} KB", process.memory());
    println!("虚拟内存: {} KB", process.virtual_memory());
}
```

**持续监控**:

```rust
use std::time::Duration;
use std::thread;

loop {
    sys.refresh_process(Pid::from(pid as usize));
    
    if let Some(process) = sys.process(Pid::from(pid as usize)) {
        println!("[{}] CPU: {}%, MEM: {} KB", 
            chrono::Local::now().format("%H:%M:%S"),
            process.cpu_usage(),
            process.memory()
        );
    }
    
    thread::sleep(Duration::from_secs(1));
}
```

---

## 3. 日志与调试

**捕获stderr**:

```rust
let output = Command::new("app")
    .stderr(Stdio::piped())
    .output()?;

let stderr = String::from_utf8_lossy(&output.stderr);
if !stderr.is_empty() {
    eprintln!("错误日志:\n{}", stderr);
}
```

**实时日志**:

```rust
use std::io::BufRead;

let mut child = Command::new("app")
    .stdout(Stdio::piped())
    .stderr(Stdio::piped())
    .spawn()?;

if let Some(stdout) = child.stdout.take() {
    let reader = BufReader::new(stdout);
    for line in reader.lines() {
        println!("[STDOUT] {}", line?);
    }
}
```

---

## 4. 实战案例

**进程监控器**:

```rust
pub struct ProcessWatcher {
    child: Child,
    monitor: ProcessMonitor,
}

impl ProcessWatcher {
    pub fn spawn(program: &str) -> Result<Self, std::io::Error> {
        let child = Command::new(program).spawn()?;
        let monitor = ProcessMonitor::new(child.id());
        
        Ok(Self { child, monitor })
    }
    
    pub fn status(&self) -> ProcessStatus {
        ProcessStatus {
            pid: self.monitor.pid,
            uptime: self.monitor.uptime(),
            running: matches!(self.child.try_wait(), Ok(None)),
        }
    }
}

pub struct ProcessStatus {
    pub pid: u32,
    pub uptime: Duration,
    pub running: bool,
}
```

---

**参考**: [性能优化参考](../tier_03_references/05_性能优化参考.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
