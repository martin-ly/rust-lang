# Tier 2: 进程监控与诊断

> **文档类型**: 实践指南
> **难度**: ⭐⭐ 初级
> **预计时间**: 1小时
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 进程监控与诊断](#tier-2-进程监控与诊断)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 进程状态监控](#1-进程状态监控)
    - [1.1 基础状态检查](#11-基础状态检查)
    - [1.2 进程状态监控器](#12-进程状态监控器)
    - [1.3 批量进程监控](#13-批量进程监控)
    - [1.4 进程状态持久化](#14-进程状态持久化)
  - [2. 资源使用监控](#2-资源使用监控)
    - [2.1 基础资源监控](#21-基础资源监控)
    - [2.2 高级资源监控](#22-高级资源监控)
    - [2.3 资源限制与告警](#23-资源限制与告警)
    - [2.4 跨平台资源监控](#24-跨平台资源监控)
    - [2.5 性能分析与优化](#25-性能分析与优化)
  - [3. 日志与调试](#3-日志与调试)
    - [3.1 标准输出捕获](#31-标准输出捕获)
    - [3.2 实时日志流](#32-实时日志流)
    - [3.3 日志文件记录](#33-日志文件记录)
    - [3.4 结构化日志](#34-结构化日志)
    - [3.5 调试技巧](#35-调试技巧)
    - [3.6 错误诊断](#36-错误诊断)
  - [4. 实战案例](#4-实战案例)
    - [案例1: 完整的进程监控系统](#案例1-完整的进程监控系统)
    - [案例2: 自动重启守护进程](#案例2-自动重启守护进程)
    - [案例3: 性能基准测试工具](#案例3-性能基准测试工具)
  - [5. 总结](#5-总结)
    - [关键要点](#关键要点)
    - [最佳实践](#最佳实践)
    - [推荐工具](#推荐工具)

---

## 学习目标

- ✅ 监控进程状态
- ✅ 获取资源使用情况
- ✅ 实现日志记录
- ✅ 构建监控工具

---

## 1. 进程状态监控

### 1.1 基础状态检查

**进程存活检查**:

```rust
use std::process::Command;

fn is_process_alive(pid: u32) -> bool {
    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;

        match kill(Pid::from_raw(pid as i32), Signal::from_c_int(0).unwrap()) {
            Ok(_) => true,
            Err(_) => false,
        }
    }

    #[cfg(windows)]
    {
        Command::new("tasklist")
            .args(["/FI", &format!("PID eq {}", pid)])
            .output()
            .map(|output| {
                String::from_utf8_lossy(&output.stdout)
                    .contains(&pid.to_string())
            })
            .unwrap_or(false)
    }
}

// 使用示例
fn main() {
    let mut child = Command::new("sleep")
        .arg("10")
        .spawn()
        .unwrap();

    let pid = child.id();
    println!("进程 {} 存活: {}", pid, is_process_alive(pid));

    child.kill().ok();
    std::thread::sleep(std::time::Duration::from_millis(100));

    println!("进程 {} 存活: {}", pid, is_process_alive(pid));
}
```

---

### 1.2 进程状态监控器

**完整监控器实现**:

```rust
use std::process::Command;
use std::time::{Duration, Instant};

pub struct ProcessMonitor {
    pid: u32,
    start_time: Instant,
    command: String,
    status: ProcessStatus,
}

#[derive(Debug, Clone)]
pub enum ProcessStatus {
    Running,
    Stopped,
    Zombie,
    Unknown,
}

impl ProcessMonitor {
    pub fn new(pid: u32, command: String) -> Self {
        Self {
            pid,
            start_time: Instant::now(),
            command,
            status: ProcessStatus::Running,
        }
    }

    pub fn update_status(&mut self) {
        self.status = Self::check_status(self.pid);
    }

    fn check_status(pid: u32) -> ProcessStatus {
        #[cfg(unix)]
        {
            use std::fs;

            let stat_path = format!("/proc/{}/stat", pid);
            if let Ok(content) = fs::read_to_string(stat_path) {
                let fields: Vec<&str> = content.split_whitespace().collect();
                if fields.len() > 2 {
                    return match fields[2] {
                        "R" | "S" | "D" => ProcessStatus::Running,
                        "Z" => ProcessStatus::Zombie,
                        "T" => ProcessStatus::Stopped,
                        _ => ProcessStatus::Unknown,
                    };
                }
            }
        }

        if is_process_alive(pid) {
            ProcessStatus::Running
        } else {
            ProcessStatus::Unknown
        }
    }

    pub fn uptime(&self) -> Duration {
        self.start_time.elapsed()
    }

    pub fn pid(&self) -> u32 {
        self.pid
    }

    pub fn command(&self) -> &str {
        &self.command
    }

    pub fn status(&self) -> &ProcessStatus {
        &self.status
    }

    pub fn is_running(&self) -> bool {
        matches!(self.status, ProcessStatus::Running)
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("sleep")
        .arg("60")
        .spawn()?;

    let mut monitor = ProcessMonitor::new(child.id(), "sleep 60".to_string());

    for _ in 0..5 {
        monitor.update_status();

        println!("━━━━━━━━━━━━━━━━━━━━━━━━━");
        println!("PID: {}", monitor.pid());
        println!("Command: {}", monitor.command());
        println!("Status: {:?}", monitor.status());
        println!("Uptime: {:?}", monitor.uptime());
        println!("Running: {}", monitor.is_running());

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 1.3 批量进程监控

**进程管理器**:

```rust
use std::collections::HashMap;
use std::process::{Command, Child};

pub struct ProcessManager {
    processes: HashMap<u32, (Child, ProcessMonitor)>,
}

impl ProcessManager {
    pub fn new() -> Self {
        Self {
            processes: HashMap::new(),
        }
    }

    pub fn spawn(&mut self, command: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let child = Command::new(command).args(args).spawn()?;
        let pid = child.id();
        let monitor = ProcessMonitor::new(pid, format!("{} {}", command, args.join(" ")));

        self.processes.insert(pid, (child, monitor));
        Ok(pid)
    }

    pub fn kill(&mut self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        if let Some((child, _)) = self.processes.get_mut(&pid) {
            child.kill()?;
            self.processes.remove(&pid);
        }
        Ok(())
    }

    pub fn kill_all(&mut self) {
        for (_, (child, _)) in self.processes.iter_mut() {
            child.kill().ok();
        }
        self.processes.clear();
    }

    pub fn update_all(&mut self) {
        self.processes.retain(|_, (child, monitor)| {
            // 检查进程是否还在运行
            match child.try_wait() {
                Ok(None) => {
                    // 进程还在运行，更新状态
                    monitor.update_status();
                    true
                }
                _ => {
                    // 进程已退出
                    println!("⚠️  Process {} exited", monitor.pid());
                    false
                }
            }
        });
    }

    pub fn get_status(&self, pid: u32) -> Option<&ProcessMonitor> {
        self.processes.get(&pid).map(|(_, monitor)| monitor)
    }

    pub fn list_all(&self) -> Vec<&ProcessMonitor> {
        self.processes.values().map(|(_, monitor)| monitor).collect()
    }

    pub fn count(&self) -> usize {
        self.processes.len()
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut manager = ProcessManager::new();

    // 启动多个进程
    let pid1 = manager.spawn("sleep", &["10"])?;
    let pid2 = manager.spawn("sleep", &["20"])?;
    let pid3 = manager.spawn("sleep", &["30"])?;

    println!("启动了 {} 个进程", manager.count());

    // 监控循环
    for _ in 0..15 {
        manager.update_all();

        println!("\n━━━━━━━━━━━━━━━━━━━━━━━━━");
        println!("活动进程: {}", manager.count());

        for monitor in manager.list_all() {
            println!("  PID {}: {:?}, uptime {:?}",
                monitor.pid(),
                monitor.status(),
                monitor.uptime()
            );
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    // 清理
    manager.kill_all();
    Ok(())
}
```

---

### 1.4 进程状态持久化

**状态记录器**:

```rust
use serde::{Serialize, Deserialize};
use std::fs;
use std::path::PathBuf;

#[derive(Serialize, Deserialize)]
pub struct ProcessRecord {
    pub pid: u32,
    pub command: String,
    pub start_time: String,
    pub end_time: Option<String>,
    pub exit_code: Option<i32>,
    pub status: String,
}

pub struct ProcessRecorder {
    records: Vec<ProcessRecord>,
    log_file: PathBuf,
}

impl ProcessRecorder {
    pub fn new(log_file: PathBuf) -> Self {
        let records = if log_file.exists() {
            let content = fs::read_to_string(&log_file).unwrap_or_default();
            serde_json::from_str(&content).unwrap_or_default()
        } else {
            Vec::new()
        };

        Self { records, log_file }
    }

    pub fn record_start(&mut self, pid: u32, command: String) {
        let record = ProcessRecord {
            pid,
            command,
            start_time: chrono::Local::now().to_rfc3339(),
            end_time: None,
            exit_code: None,
            status: "Running".to_string(),
        };

        self.records.push(record);
        self.save();
    }

    pub fn record_end(&mut self, pid: u32, exit_code: Option<i32>) {
        if let Some(record) = self.records.iter_mut().find(|r| r.pid == pid && r.end_time.is_none()) {
            record.end_time = Some(chrono::Local::now().to_rfc3339());
            record.exit_code = exit_code;
            record.status = "Exited".to_string();
            self.save();
        }
    }

    fn save(&self) {
        if let Ok(content) = serde_json::to_string_pretty(&self.records) {
            fs::write(&self.log_file, content).ok();
        }
    }

    pub fn get_history(&self, pid: u32) -> Vec<&ProcessRecord> {
        self.records.iter().filter(|r| r.pid == pid).collect()
    }
}
```

---

## 2. 资源使用监控

### 2.1 基础资源监控

**使用 sysinfo 库**:

```rust
use sysinfo::{System, SystemExt, ProcessExt, Pid};

pub struct ResourceMonitor {
    system: System,
}

impl ResourceMonitor {
    pub fn new() -> Self {
        let mut system = System::new_all();
        system.refresh_all();

        Self { system }
    }

    pub fn get_process_info(&mut self, pid: u32) -> Option<ProcessInfo> {
        self.system.refresh_process(Pid::from(pid as usize));

        self.system.process(Pid::from(pid as usize)).map(|process| {
            ProcessInfo {
                pid,
                name: process.name().to_string(),
                cpu_usage: process.cpu_usage(),
                memory: process.memory(),
                virtual_memory: process.virtual_memory(),
                disk_usage: process.disk_usage(),
                status: format!("{:?}", process.status()),
            }
        })
    }

    pub fn get_system_info(&mut self) -> SystemInfo {
        self.system.refresh_all();

        SystemInfo {
            total_memory: self.system.total_memory(),
            used_memory: self.system.used_memory(),
            total_swap: self.system.total_swap(),
            used_swap: self.system.used_swap(),
            cpu_count: self.system.cpus().len(),
            global_cpu_usage: self.system.global_cpu_info().cpu_usage(),
        }
    }
}

#[derive(Debug)]
pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub cpu_usage: f32,
    pub memory: u64,
    pub virtual_memory: u64,
    pub disk_usage: sysinfo::DiskUsage,
    pub status: String,
}

#[derive(Debug)]
pub struct SystemInfo {
    pub total_memory: u64,
    pub used_memory: u64,
    pub total_swap: u64,
    pub used_swap: u64,
    pub cpu_count: usize,
    pub global_cpu_usage: f32,
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("stress")
        .args(["--cpu", "1", "--timeout", "30s"])
        .spawn()?;

    let mut monitor = ResourceMonitor::new();

    for _ in 0..10 {
        if let Some(info) = monitor.get_process_info(child.id()) {
            println!("━━━━━━━━━━━━━━━━━━━━━━━━━");
            println!("PID: {}", info.pid);
            println!("Name: {}", info.name);
            println!("CPU: {:.2}%", info.cpu_usage);
            println!("Memory: {} KB", info.memory);
            println!("Virtual Memory: {} KB", info.virtual_memory);
            println!("Status: {}", info.status);
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 2.2 高级资源监控

**资源统计与历史记录**:

```rust
use std::collections::VecDeque;

pub struct ResourceTracker {
    history_size: usize,
    cpu_history: VecDeque<f32>,
    memory_history: VecDeque<u64>,
    monitor: ResourceMonitor,
}

impl ResourceTracker {
    pub fn new(history_size: usize) -> Self {
        Self {
            history_size,
            cpu_history: VecDeque::new(),
            memory_history: VecDeque::new(),
            monitor: ResourceMonitor::new(),
        }
    }

    pub fn update(&mut self, pid: u32) {
        if let Some(info) = self.monitor.get_process_info(pid) {
            // 添加新数据
            self.cpu_history.push_back(info.cpu_usage);
            self.memory_history.push_back(info.memory);

            // 保持历史大小
            while self.cpu_history.len() > self.history_size {
                self.cpu_history.pop_front();
            }
            while self.memory_history.len() > self.history_size {
                self.memory_history.pop_front();
            }
        }
    }

    pub fn get_statistics(&self) -> ResourceStatistics {
        ResourceStatistics {
            cpu_avg: self.average(&self.cpu_history),
            cpu_max: self.max(&self.cpu_history),
            cpu_min: self.min(&self.cpu_history),
            memory_avg: self.average_u64(&self.memory_history),
            memory_max: self.max_u64(&self.memory_history),
            memory_min: self.min_u64(&self.memory_history),
        }
    }

    fn average(&self, data: &VecDeque<f32>) -> f32 {
        if data.is_empty() {
            return 0.0;
        }
        data.iter().sum::<f32>() / data.len() as f32
    }

    fn max(&self, data: &VecDeque<f32>) -> f32 {
        data.iter().cloned().fold(f32::NEG_INFINITY, f32::max)
    }

    fn min(&self, data: &VecDeque<f32>) -> f32 {
        data.iter().cloned().fold(f32::INFINITY, f32::min)
    }

    fn average_u64(&self, data: &VecDeque<u64>) -> u64 {
        if data.is_empty() {
            return 0;
        }
        data.iter().sum::<u64>() / data.len() as u64
    }

    fn max_u64(&self, data: &VecDeque<u64>) -> u64 {
        *data.iter().max().unwrap_or(&0)
    }

    fn min_u64(&self, data: &VecDeque<u64>) -> u64 {
        *data.iter().min().unwrap_or(&0)
    }
}

#[derive(Debug)]
pub struct ResourceStatistics {
    pub cpu_avg: f32,
    pub cpu_max: f32,
    pub cpu_min: f32,
    pub memory_avg: u64,
    pub memory_max: u64,
    pub memory_min: u64,
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("stress")
        .args(["--cpu", "1", "--timeout", "60s"])
        .spawn()?;

    let mut tracker = ResourceTracker::new(60);  // 保留60秒历史

    for i in 0..60 {
        tracker.update(child.id());

        if i % 10 == 0 {
            let stats = tracker.get_statistics();
            println!("\n━━━━━━ 统计信息 ({}s) ━━━━━━", i);
            println!("CPU - Avg: {:.2}%, Max: {:.2}%, Min: {:.2}%",
                stats.cpu_avg, stats.cpu_max, stats.cpu_min);
            println!("Memory - Avg: {} KB, Max: {} KB, Min: {} KB",
                stats.memory_avg, stats.memory_max, stats.memory_min);
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 2.3 资源限制与告警

**资源阈值监控**:

```rust
pub struct ResourceAlarm {
    cpu_threshold: f32,
    memory_threshold: u64,
    callbacks: Vec<Box<dyn Fn(AlarmEvent) + Send>>,
}

#[derive(Debug, Clone)]
pub enum AlarmEvent {
    CpuHigh { pid: u32, usage: f32 },
    MemoryHigh { pid: u32, usage: u64 },
    CpuNormal { pid: u32 },
    MemoryNormal { pid: u32 },
}

impl ResourceAlarm {
    pub fn new(cpu_threshold: f32, memory_threshold: u64) -> Self {
        Self {
            cpu_threshold,
            memory_threshold,
            callbacks: Vec::new(),
        }
    }

    pub fn on_alarm<F>(&mut self, callback: F)
    where
        F: Fn(AlarmEvent) + Send + 'static,
    {
        self.callbacks.push(Box::new(callback));
    }

    pub fn check(&self, info: &ProcessInfo) {
        if info.cpu_usage > self.cpu_threshold {
            let event = AlarmEvent::CpuHigh {
                pid: info.pid,
                usage: info.cpu_usage,
            };
            self.trigger(event);
        }

        if info.memory > self.memory_threshold {
            let event = AlarmEvent::MemoryHigh {
                pid: info.pid,
                usage: info.memory,
            };
            self.trigger(event);
        }
    }

    fn trigger(&self, event: AlarmEvent) {
        for callback in &self.callbacks {
            callback(event.clone());
        }
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut alarm = ResourceAlarm::new(80.0, 100 * 1024 * 1024);  // 80% CPU, 100MB

    alarm.on_alarm(|event| {
        match event {
            AlarmEvent::CpuHigh { pid, usage } => {
                eprintln!("⚠️  HIGH CPU: Process {} using {:.2}%", pid, usage);
            }
            AlarmEvent::MemoryHigh { pid, usage } => {
                eprintln!("⚠️  HIGH MEMORY: Process {} using {} bytes", pid, usage);
            }
            _ => {}
        }
    });

    let mut child = Command::new("stress")
        .args(["--cpu", "4", "--timeout", "30s"])
        .spawn()?;

    let mut monitor = ResourceMonitor::new();

    for _ in 0..30 {
        if let Some(info) = monitor.get_process_info(child.id()) {
            alarm.check(&info);
        }
        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 2.4 跨平台资源监控

**平台特定实现**:

```rust
#[cfg(unix)]
mod unix {
    use std::fs;

    pub fn get_process_cpu_time(pid: u32) -> Result<u64, Box<dyn std::error::Error>> {
        let stat = fs::read_to_string(format!("/proc/{}/stat", pid))?;
        let fields: Vec<&str> = stat.split_whitespace().collect();

        if fields.len() > 14 {
            let utime: u64 = fields[13].parse()?;
            let stime: u64 = fields[14].parse()?;
            Ok(utime + stime)
        } else {
            Err("Invalid stat format".into())
        }
    }

    pub fn get_process_memory(pid: u32) -> Result<u64, Box<dyn std::error::Error>> {
        let status = fs::read_to_string(format!("/proc/{}/status", pid))?;

        for line in status.lines() {
            if line.starts_with("VmRSS:") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    return Ok(parts[1].parse::<u64>()? * 1024);  // Convert to bytes
                }
            }
        }

        Err("VmRSS not found".into())
    }
}

#[cfg(windows)]
mod windows {
    use winapi::um::processthreadsapi::*;
    use winapi::um::psapi::*;

    pub fn get_process_memory(pid: u32) -> Result<u64, Box<dyn std::error::Error>> {
        unsafe {
            use winapi::um::handleapi::CloseHandle;
            use winapi::shared::minwindef::FALSE;

            let handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
            if handle.is_null() {
                return Err("Failed to open process".into());
            }

            let mut pmc: PROCESS_MEMORY_COUNTERS = std::mem::zeroed();
            pmc.cb = std::mem::size_of::<PROCESS_MEMORY_COUNTERS>() as u32;

            if GetProcessMemoryInfo(handle, &mut pmc, pmc.cb) != 0 {
                CloseHandle(handle);
                Ok(pmc.WorkingSetSize as u64)
            } else {
                CloseHandle(handle);
                Err("GetProcessMemoryInfo failed".into())
            }
        }
    }
}
```

---

### 2.5 性能分析与优化

**性能瓶颈检测**:

```rust
pub struct PerformanceAnalyzer {
    tracker: ResourceTracker,
    baseline_cpu: f32,
    baseline_memory: u64,
}

impl PerformanceAnalyzer {
    pub fn new(baseline_samples: usize) -> Self {
        Self {
            tracker: ResourceTracker::new(baseline_samples),
            baseline_cpu: 0.0,
            baseline_memory: 0,
        }
    }

    pub fn establish_baseline(&mut self, pid: u32, duration: Duration) {
        let samples = duration.as_secs() as usize;

        for _ in 0..samples {
            self.tracker.update(pid);
            std::thread::sleep(Duration::from_secs(1));
        }

        let stats = self.tracker.get_statistics();
        self.baseline_cpu = stats.cpu_avg;
        self.baseline_memory = stats.memory_avg;

        println!("📊 Baseline established:");
        println!("   CPU: {:.2}%", self.baseline_cpu);
        println!("   Memory: {} KB", self.baseline_memory);
    }

    pub fn analyze(&mut self, pid: u32) -> PerformanceReport {
        self.tracker.update(pid);
        let stats = self.tracker.get_statistics();

        let cpu_deviation = ((stats.cpu_avg - self.baseline_cpu) / self.baseline_cpu) * 100.0;
        let memory_deviation = if self.baseline_memory > 0 {
            ((stats.memory_avg as f64 - self.baseline_memory as f64) / self.baseline_memory as f64) * 100.0
        } else {
            0.0
        };

        PerformanceReport {
            current_cpu: stats.cpu_avg,
            current_memory: stats.memory_avg,
            cpu_deviation,
            memory_deviation,
            is_anomaly: cpu_deviation.abs() > 50.0 || memory_deviation.abs() > 50.0,
        }
    }
}

#[derive(Debug)]
pub struct PerformanceReport {
    pub current_cpu: f32,
    pub current_memory: u64,
    pub cpu_deviation: f32,
    pub memory_deviation: f64,
    pub is_anomaly: bool,
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("my_app").spawn()?;

    let mut analyzer = PerformanceAnalyzer::new(60);

    // 建立基线（60秒）
    println!("⏱️  Establishing baseline...");
    analyzer.establish_baseline(child.id(), Duration::from_secs(60));

    // 持续监控
    println!("\n📈 Monitoring performance...");
    for i in 0..300 {
        let report = analyzer.analyze(child.id());

        if i % 10 == 0 {
            println!("\n━━━━━━ Report ({}s) ━━━━━━", i);
            println!("CPU: {:.2}% (deviation: {:+.2}%)",
                report.current_cpu, report.cpu_deviation);
            println!("Memory: {} KB (deviation: {:+.2}%)",
                report.current_memory, report.memory_deviation);

            if report.is_anomaly {
                eprintln!("🚨 ANOMALY DETECTED!");
            }
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

## 3. 日志与调试

### 3.1 标准输出捕获

**捕获stderr和stdout**:

```rust
use std::process::{Command, Stdio};

fn capture_output(cmd: &str, args: &[&str]) -> Result<(String, String), Box<dyn std::error::Error>> {
    let output = Command::new(cmd)
        .args(args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()?;

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    Ok((stdout, stderr))
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (stdout, stderr) = capture_output("ls", &["-la", "/nonexistent"])?;

    println!("STDOUT:\n{}", stdout);

    if !stderr.is_empty() {
        eprintln!("STDERR:\n{}", stderr);
    }

    Ok(())
}
```

---

### 3.2 实时日志流

**异步日志捕获**:

```rust
use std::io::{BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;

pub struct LogCapture {
    handles: Vec<thread::JoinHandle<()>>,
}

impl LogCapture {
    pub fn new() -> Self {
        Self {
            handles: Vec::new(),
        }
    }

    pub fn capture_stdout<F>(&mut self, child: &mut std::process::Child, mut callback: F)
    where
        F: FnMut(String) + Send + 'static,
    {
        if let Some(stdout) = child.stdout.take() {
            let handle = thread::spawn(move || {
                let reader = BufReader::new(stdout);
                for line in reader.lines() {
                    if let Ok(line) = line {
                        callback(line);
                    }
                }
            });
            self.handles.push(handle);
        }
    }

    pub fn capture_stderr<F>(&mut self, child: &mut std::process::Child, mut callback: F)
    where
        F: FnMut(String) + Send + 'static,
    {
        if let Some(stderr) = child.stderr.take() {
            let handle = thread::spawn(move || {
                let reader = BufReader::new(stderr);
                for line in reader.lines() {
                    if let Ok(line) = line {
                        callback(line);
                    }
                }
            });
            self.handles.push(handle);
        }
    }

    pub fn wait(self) {
        for handle in self.handles {
            handle.join().ok();
        }
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("my_app")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let mut capture = LogCapture::new();

    capture.capture_stdout(&mut child, |line| {
        println!("[STDOUT] {}", line);
    });

    capture.capture_stderr(&mut child, |line| {
        eprintln!("[STDERR] {}", line);
    });

    child.wait()?;
    capture.wait();

    Ok(())
}
```

---

### 3.3 日志文件记录

**日志写入文件**:

```rust
use std::fs::{File, OpenOptions};
use std::io::{Write, BufWriter};
use std::sync::{Arc, Mutex};

pub struct FileLogger {
    writer: Arc<Mutex<BufWriter<File>>>,
}

impl FileLogger {
    pub fn new(path: &str) -> Result<Self, std::io::Error> {
        let file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)?;

        let writer = BufWriter::new(file);

        Ok(Self {
            writer: Arc::new(Mutex::new(writer)),
        })
    }

    pub fn log(&self, message: &str) {
        if let Ok(mut writer) = self.writer.lock() {
            let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
            writeln!(writer, "[{}] {}", timestamp, message).ok();
            writer.flush().ok();
        }
    }

    pub fn log_process_output(&self, pid: u32, stream: &str, line: &str) {
        self.log(&format!("[PID:{}] [{}] {}", pid, stream, line));
    }
}

impl Clone for FileLogger {
    fn clone(&self) -> Self {
        Self {
            writer: Arc::clone(&self.writer),
        }
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let logger = FileLogger::new("process.log")?;

    let mut child = Command::new("my_app")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let pid = child.id();
    let mut capture = LogCapture::new();

    let logger_stdout = logger.clone();
    capture.capture_stdout(&mut child, move |line| {
        logger_stdout.log_process_output(pid, "STDOUT", &line);
        println!("[STDOUT] {}", line);
    });

    let logger_stderr = logger.clone();
    capture.capture_stderr(&mut child, move |line| {
        logger_stderr.log_process_output(pid, "STDERR", &line);
        eprintln!("[STDERR] {}", line);
    });

    child.wait()?;
    capture.wait();

    Ok(())
}
```

---

### 3.4 结构化日志

**使用tracing**:

```rust
use tracing::{info, warn, error, debug, instrument};
use tracing_subscriber;

#[instrument]
pub fn run_monitored_process(cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
    info!("Starting process: {}", cmd);

    let mut child = Command::new(cmd)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let pid = child.id();
    info!(pid = pid, "Process spawned");

    let status = child.wait()?;

    if status.success() {
        info!(pid = pid, exit_code = ?status.code(), "Process completed successfully");
    } else {
        warn!(pid = pid, exit_code = ?status.code(), "Process exited with error");
    }

    Ok(())
}

fn main() {
    // 初始化tracing
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();

    run_monitored_process("my_app").ok();
}
```

---

### 3.5 调试技巧

**详细进程信息**:

```rust
use std::process::Command;

pub fn debug_process_info(pid: u32) {
    println!("━━━━━━━━━━━━━━━━━━━━━━━━━");
    println!("🔍 Process Debug Info");
    println!("━━━━━━━━━━━━━━━━━━━━━━━━━");
    println!("PID: {}", pid);

    #[cfg(unix)]
    {
        // 命令行
        if let Ok(cmdline) = std::fs::read_to_string(format!("/proc/{}/cmdline", pid)) {
            let args: Vec<&str> = cmdline.split('\0').filter(|s| !s.is_empty()).collect();
            println!("Cmdline: {:?}", args);
        }

        // 环境变量
        if let Ok(environ) = std::fs::read_to_string(format!("/proc/{}/environ", pid)) {
            let envs: Vec<&str> = environ.split('\0').take(5).collect();
            println!("Environ (first 5): {:?}", envs);
        }

        // 当前工作目录
        if let Ok(cwd) = std::fs::read_link(format!("/proc/{}/cwd", pid)) {
            println!("CWD: {:?}", cwd);
        }

        // 打开的文件描述符
        if let Ok(entries) = std::fs::read_dir(format!("/proc/{}/fd", pid)) {
            let count = entries.count();
            println!("Open FDs: {}", count);
        }
    }

    #[cfg(windows)]
    {
        // Windows查询进程信息
        let output = Command::new("tasklist")
            .args(["/FI", &format!("PID eq {}", pid), "/V"])
            .output();

        if let Ok(output) = output {
            println!("{}", String::from_utf8_lossy(&output.stdout));
        }
    }
}
```

---

### 3.6 错误诊断

**进程失败分析**:

```rust
pub fn diagnose_failure(cmd: &str, args: &[&str]) -> Result<(), Box<dyn std::error::Error>> {
    println!("🔍 Diagnosing: {} {:?}", cmd, args);

    let result = Command::new(cmd)
        .args(args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output();

    match result {
        Ok(output) => {
            println!("\n✅ Process executed");
            println!("Exit code: {:?}", output.status.code());

            if !output.status.success() {
                println!("\n❌ Process failed!");

                let stderr = String::from_utf8_lossy(&output.stderr);
                if !stderr.is_empty() {
                    println!("\n📋 Error output:");
                    println!("{}", stderr);
                }

                let stdout = String::from_utf8_lossy(&output.stdout);
                if !stdout.is_empty() {
                    println!("\n📋 Standard output:");
                    println!("{}", stdout);
                }

                #[cfg(unix)]
                {
                    use std::os::unix::process::ExitStatusExt;
                    if let Some(signal) = output.status.signal() {
                        println!("\n⚠️  Killed by signal: {}", signal);
                    }
                }
            } else {
                println!("\n✅ Process succeeded");
            }
        }
        Err(e) => {
            println!("\n❌ Failed to spawn process!");
            println!("Error: {}", e);
            println!("\n💡 Possible causes:");
            println!("  - Command not found in PATH");
            println!("  - Insufficient permissions");
            println!("  - Invalid arguments");
            println!("  - System resource limits");
        }
    }

    Ok(())
}
```

---

## 4. 实战案例

### 案例1: 完整的进程监控系统

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct ComprehensiveMonitor {
    processes: HashMap<u32, MonitoredProcess>,
    resource_monitor: ResourceMonitor,
    logger: FileLogger,
    alarms: Vec<ResourceAlarm>,
}

struct MonitoredProcess {
    child: Option<Child>,
    monitor: ProcessMonitor,
    tracker: ResourceTracker,
    start_time: Instant,
}

impl ComprehensiveMonitor {
    pub fn new(log_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            processes: HashMap::new(),
            resource_monitor: ResourceMonitor::new(),
            logger: FileLogger::new(log_path)?,
            alarms: Vec::new(),
        })
    }

    pub fn spawn(&mut self, cmd: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let mut child = Command::new(cmd)
            .args(args)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        let pid = child.id();
        let command = format!("{} {}", cmd, args.join(" "));

        // 设置日志捕获
        let mut capture = LogCapture::new();
        let logger = self.logger.clone();

        capture.capture_stdout(&mut child, move |line| {
            logger.log_process_output(pid, "STDOUT", &line);
        });

        let logger = self.logger.clone();
        capture.capture_stderr(&mut child, move |line| {
            logger.log_process_output(pid, "STDERR", &line);
        });

        // 创建监控对象
        let process = MonitoredProcess {
            child: Some(child),
            monitor: ProcessMonitor::new(pid, command.clone()),
            tracker: ResourceTracker::new(300),  // 5分钟历史
            start_time: Instant::now(),
        };

        self.processes.insert(pid, process);
        self.logger.log(&format!("Process {} started: {}", pid, command));

        Ok(pid)
    }

    pub fn monitor_all(&mut self) {
        let pids: Vec<u32> = self.processes.keys().copied().collect();

        for pid in pids {
            if let Some(process) = self.processes.get_mut(&pid) {
                // 更新状态
                process.monitor.update_status();
                process.tracker.update(pid);

                // 检查是否还在运行
                if let Some(child) = &mut process.child {
                    match child.try_wait() {
                        Ok(Some(status)) => {
                            let uptime = process.start_time.elapsed();
                            self.logger.log(&format!(
                                "Process {} exited with status {:?} after {:?}",
                                pid, status.code(), uptime
                            ));
                            self.processes.remove(&pid);
                        }
                        Ok(None) => {
                            // 进程还在运行，检查告警
                            if let Some(info) = self.resource_monitor.get_process_info(pid) {
                                for alarm in &self.alarms {
                                    alarm.check(&info);
                                }
                            }
                        }
                        Err(_) => {
                            self.logger.log(&format!("Error checking process {}", pid));
                            self.processes.remove(&pid);
                        }
                    }
                }
            }
        }
    }

    pub fn get_report(&self) -> MonitorReport {
        let mut total_cpu = 0.0;
        let mut total_memory = 0;
        let mut process_count = 0;

        for (_, process) in &self.processes {
            let stats = process.tracker.get_statistics();
            total_cpu += stats.cpu_avg;
            total_memory += stats.memory_avg;
            process_count += 1;
        }

        MonitorReport {
            active_processes: process_count,
            total_cpu_usage: total_cpu,
            total_memory_usage: total_memory,
            uptime: Duration::from_secs(0),  // 实际应计算
        }
    }
}

#[derive(Debug)]
pub struct MonitorReport {
    pub active_processes: usize,
    pub total_cpu_usage: f32,
    pub total_memory_usage: u64,
    pub uptime: Duration,
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut monitor = ComprehensiveMonitor::new("monitor.log")?;

    // 启动多个进程
    monitor.spawn("stress", &["--cpu", "1", "--timeout", "30s"])?;
    monitor.spawn("stress", &["--vm", "1", "--timeout", "30s"])?;

    // 监控循环
    for _ in 0..60 {
        monitor.monitor_all();

        let report = monitor.get_report();
        println!("Active: {}, CPU: {:.2}%, Memory: {} KB",
            report.active_processes,
            report.total_cpu_usage,
            report.total_memory_usage
        );

        std::thread::sleep(Duration::from_secs(1));
    }

    Ok(())
}
```

---

### 案例2: 自动重启守护进程

```rust
pub struct ProcessSupervisor {
    command: String,
    args: Vec<String>,
    max_restarts: usize,
    restart_count: usize,
    monitor: Option<ProcessMonitor>,
    logger: FileLogger,
}

impl ProcessSupervisor {
    pub fn new(command: String, args: Vec<String>, log_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            command,
            args,
            max_restarts: 5,
            restart_count: 0,
            monitor: None,
            logger: FileLogger::new(log_path)?,
        })
    }

    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        loop {
            self.logger.log("Starting supervised process");

            let mut child = Command::new(&self.command)
                .args(&self.args)
                .spawn()?;

            let pid = child.id();
            self.monitor = Some(ProcessMonitor::new(pid, format!("{} {:?}", self.command, self.args)));

            self.logger.log(&format!("Process started with PID {}", pid));

            // 等待进程退出
            match child.wait() {
                Ok(status) => {
                    self.logger.log(&format!("Process {} exited with status {:?}", pid, status.code()));

                    if !status.success() {
                        self.restart_count += 1;

                        if self.restart_count >= self.max_restarts {
                            self.logger.log(&format!("Max restarts ({}) reached, giving up", self.max_restarts));
                            return Err("Max restarts reached".into());
                        }

                        self.logger.log(&format!("Restarting... (attempt {}/{})",
                            self.restart_count, self.max_restarts));

                        std::thread::sleep(Duration::from_secs(5));
                    } else {
                        // 正常退出，重置计数器
                        self.restart_count = 0;
                    }
                }
                Err(e) => {
                    self.logger.log(&format!("Error waiting for process: {}", e));
                    return Err(e.into());
                }
            }
        }
    }
}
```

---

### 案例3: 性能基准测试工具

```rust
pub struct BenchmarkRunner {
    command: String,
    args: Vec<String>,
    iterations: usize,
    results: Vec<BenchmarkResult>,
}

#[derive(Debug)]
pub struct BenchmarkResult {
    pub duration: Duration,
    pub exit_code: Option<i32>,
    pub avg_cpu: f32,
    pub peak_memory: u64,
}

impl BenchmarkRunner {
    pub fn new(command: String, args: Vec<String>, iterations: usize) -> Self {
        Self {
            command,
            args,
            iterations,
            results: Vec::new(),
        }
    }

    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("🏃 Running benchmark: {} iterations", self.iterations);

        for i in 0..self.iterations {
            println!("\n━━━━ Iteration {}/{} ━━━━", i + 1, self.iterations);

            let result = self.run_single()?;

            println!("Duration: {:?}", result.duration);
            println!("Avg CPU: {:.2}%", result.avg_cpu);
            println!("Peak Memory: {} KB", result.peak_memory);

            self.results.push(result);
        }

        self.print_summary();

        Ok(())
    }

    fn run_single(&self) -> Result<BenchmarkResult, Box<dyn std::error::Error>> {
        let start = Instant::now();

        let mut child = Command::new(&self.command)
            .args(&self.args)
            .spawn()?;

        let pid = child.id();
        let mut tracker = ResourceTracker::new(1000);

        // 监控进程
        loop {
            tracker.update(pid);

            match child.try_wait()? {
                Some(status) => {
                    let duration = start.elapsed();
                    let stats = tracker.get_statistics();

                    return Ok(BenchmarkResult {
                        duration,
                        exit_code: status.code(),
                        avg_cpu: stats.cpu_avg,
                        peak_memory: stats.memory_max,
                    });
                }
                None => {
                    std::thread::sleep(Duration::from_millis(100));
                }
            }
        }
    }

    fn print_summary(&self) {
        if self.results.is_empty() {
            return;
        }

        println!("\n━━━━━━━━━━━━━━━━━━━━━━━━━");
        println!("📊 Benchmark Summary");
        println!("━━━━━━━━━━━━━━━━━━━━━━━━━");

        let avg_duration = self.results.iter()
            .map(|r| r.duration.as_secs_f64())
            .sum::<f64>() / self.results.len() as f64;

        let avg_cpu = self.results.iter()
            .map(|r| r.avg_cpu)
            .sum::<f32>() / self.results.len() as f32;

        let avg_memory = self.results.iter()
            .map(|r| r.peak_memory)
            .sum::<u64>() / self.results.len() as u64;

        println!("Iterations: {}", self.results.len());
        println!("Avg Duration: {:.2}s", avg_duration);
        println!("Avg CPU: {:.2}%", avg_cpu);
        println!("Avg Peak Memory: {} KB", avg_memory);
    }
}
```

---

## 5. 总结

### 关键要点

1. ✅ **进程状态监控**: 使用`try_wait()`检查进程状态，读取`/proc`文件系统获取详细信息
2. ✅ **资源监控**: 使用`sysinfo`库跨平台监控CPU和内存
3. ✅ **日志记录**: 捕获stdout/stderr，使用结构化日志（tracing）
4. ✅ **告警机制**: 基于阈值的资源告警系统
5. ✅ **性能分析**: 建立基线，检测性能异常

### 最佳实践

**监控频率**: 根据需求调整

- 实时监控: 100-500ms
- 常规监控: 1-5s
- 长期监控: 10-60s

**资源历史**: 保留合适的历史数据

- 短期: 最近5-10分钟
- 中期: 最近1小时（采样）
- 长期: 按天聚合

**日志管理**:

- 使用日志轮转
- 控制日志级别
- 异步写入

**告警策略**:

- 合理设置阈值
- 避免告警风暴
- 支持告警静默

### 推荐工具

- **sysinfo**: 跨平台系统信息
- **tracing**: 结构化日志
- **prometheus**: 监控指标收集
- **grafana**: 可视化监控面板

---

**下一步**:

- [进程管理快速入门](./01_进程管理快速入门.md)
- [IPC通信实践](./02_IPC通信实践.md)
- [异步进程管理](./03_异步进程管理.md)
- [跨平台实践](./04_跨平台实践.md)

---

**参考**: [性能优化参考](../tier_03_references/05_性能优化参考.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-22
**适用版本**: Rust 1.90+
