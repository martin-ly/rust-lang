# Tier 2: è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­

> **æ–‡æ¡£ç±»å‹**: å®è·µæŒ‡å—
> **éš¾åº¦**: â­â­ åˆçº§
> **é¢„è®¡æ—¶é—´**: 1å°æ—¶
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+

---

## ç›®å½•

- [Tier 2: è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­](#tier-2-è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­)
  - [ç›®å½•](#ç›®å½•)
  - [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
  - [1. è¿›ç¨‹çŠ¶æ€ç›‘æ§](#1-è¿›ç¨‹çŠ¶æ€ç›‘æ§)
    - [1.1 åŸºç¡€çŠ¶æ€æ£€æŸ¥](#11-åŸºç¡€çŠ¶æ€æ£€æŸ¥)
    - [1.2 è¿›ç¨‹çŠ¶æ€ç›‘æ§å™¨](#12-è¿›ç¨‹çŠ¶æ€ç›‘æ§å™¨)
    - [1.3 æ‰¹é‡è¿›ç¨‹ç›‘æ§](#13-æ‰¹é‡è¿›ç¨‹ç›‘æ§)
    - [1.4 è¿›ç¨‹çŠ¶æ€æŒä¹…åŒ–](#14-è¿›ç¨‹çŠ¶æ€æŒä¹…åŒ–)
  - [2. èµ„æºä½¿ç”¨ç›‘æ§](#2-èµ„æºä½¿ç”¨ç›‘æ§)
    - [2.1 åŸºç¡€èµ„æºç›‘æ§](#21-åŸºç¡€èµ„æºç›‘æ§)
    - [2.2 é«˜çº§èµ„æºç›‘æ§](#22-é«˜çº§èµ„æºç›‘æ§)
    - [2.3 èµ„æºé™åˆ¶ä¸å‘Šè­¦](#23-èµ„æºé™åˆ¶ä¸å‘Šè­¦)
    - [2.4 è·¨å¹³å°èµ„æºç›‘æ§](#24-è·¨å¹³å°èµ„æºç›‘æ§)
    - [2.5 æ€§èƒ½åˆ†æä¸ä¼˜åŒ–](#25-æ€§èƒ½åˆ†æä¸ä¼˜åŒ–)
  - [3. æ—¥å¿—ä¸è°ƒè¯•](#3-æ—¥å¿—ä¸è°ƒè¯•)
    - [3.1 æ ‡å‡†è¾“å‡ºæ•è·](#31-æ ‡å‡†è¾“å‡ºæ•è·)
    - [3.2 å®æ—¶æ—¥å¿—æµ](#32-å®æ—¶æ—¥å¿—æµ)
    - [3.3 æ—¥å¿—æ–‡ä»¶è®°å½•](#33-æ—¥å¿—æ–‡ä»¶è®°å½•)
    - [3.4 ç»“æ„åŒ–æ—¥å¿—](#34-ç»“æ„åŒ–æ—¥å¿—)
    - [3.5 è°ƒè¯•æŠ€å·§](#35-è°ƒè¯•æŠ€å·§)
    - [3.6 é”™è¯¯è¯Šæ–­](#36-é”™è¯¯è¯Šæ–­)
  - [4. å®æˆ˜æ¡ˆä¾‹](#4-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: å®Œæ•´çš„è¿›ç¨‹ç›‘æ§ç³»ç»Ÿ](#æ¡ˆä¾‹1-å®Œæ•´çš„è¿›ç¨‹ç›‘æ§ç³»ç»Ÿ)
    - [æ¡ˆä¾‹2: è‡ªåŠ¨é‡å¯å®ˆæŠ¤è¿›ç¨‹](#æ¡ˆä¾‹2-è‡ªåŠ¨é‡å¯å®ˆæŠ¤è¿›ç¨‹)
    - [æ¡ˆä¾‹3: æ€§èƒ½åŸºå‡†æµ‹è¯•å·¥å…·](#æ¡ˆä¾‹3-æ€§èƒ½åŸºå‡†æµ‹è¯•å·¥å…·)
  - [5. æ€»ç»“](#5-æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [æ¨èå·¥å…·](#æ¨èå·¥å…·)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­ (Process Monitoring and Diagnostics)**:

- **å®šä¹‰**: ç›‘æ§è¿›ç¨‹çŠ¶æ€ã€èµ„æºä½¿ç”¨æƒ…å†µå’Œå®ç°æ—¥å¿—è®°å½•çš„æŠ€æœ¯å’Œå®è·µ
- **ç±»å‹**: ç›‘æ§å’Œè¯Šæ–­æŠ€æœ¯
- **èŒƒç•´**: ç³»ç»Ÿç¼–ç¨‹ã€è¿ç»´ç›‘æ§
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: è¿›ç¨‹çŠ¶æ€ã€èµ„æºç›‘æ§ã€æ—¥å¿—è®°å½•ã€æ€§èƒ½åˆ†æ

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **çŠ¶æ€ç›‘æ§**: å®æ—¶ç›‘æ§è¿›ç¨‹çŠ¶æ€
- **èµ„æºç›‘æ§**: ç›‘æ§ CPUã€å†…å­˜ã€I/O ä½¿ç”¨
- **æ—¥å¿—è®°å½•**: ç»“æ„åŒ–æ—¥å¿—å’Œè°ƒè¯•ä¿¡æ¯
- **è¯Šæ–­å·¥å…·**: æ„å»ºç›‘æ§å’Œè¯Šæ–­å·¥å…·

**æ€§èƒ½ç‰¹å¾**:

- **å®æ—¶æ€§**: å®æ—¶ç›‘æ§å’Œå‘Šè­¦
- **ä½å¼€é”€**: ç›‘æ§å¼€é”€å°
- **é€‚ç”¨åœºæ™¯**: ç”Ÿäº§ç¯å¢ƒã€å¼€å‘è°ƒè¯•ã€æ€§èƒ½åˆ†æ

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­ --[uses]--> å¤šç§ç›‘æ§æŠ€æœ¯
- ç”Ÿäº§ç¯å¢ƒ --[uses]--> ç›‘æ§ä½“ç³»

**ä¾èµ–å…³ç³»**:

- è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­ --[depends-on]--> æ“ä½œç³»ç»Ÿ API
- ç›‘æ§å·¥å…· --[depends-on]--> è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­

### æ€ç»´å¯¼å›¾

```text
è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­
â”‚
â”œâ”€â”€ è¿›ç¨‹çŠ¶æ€ç›‘æ§
â”‚   â”œâ”€â”€ åŸºç¡€çŠ¶æ€æ£€æŸ¥
â”‚   â””â”€â”€ æ‰¹é‡è¿›ç¨‹ç›‘æ§
â”œâ”€â”€ èµ„æºä½¿ç”¨ç›‘æ§
â”‚   â”œâ”€â”€ CPU ç›‘æ§
â”‚   â”œâ”€â”€ å†…å­˜ç›‘æ§
â”‚   â””â”€â”€ I/O ç›‘æ§
â”œâ”€â”€ æ—¥å¿—ä¸è°ƒè¯•
â”‚   â”œâ”€â”€ æ ‡å‡†è¾“å‡ºæ•è·
â”‚   â””â”€â”€ ç»“æ„åŒ–æ—¥å¿—
â””â”€â”€ å®æˆ˜æ¡ˆä¾‹
    â”œâ”€â”€ è¿›ç¨‹ç›‘æ§ç³»ç»Ÿ
    â””â”€â”€ è‡ªåŠ¨é‡å¯å®ˆæŠ¤è¿›ç¨‹
```

---

## å­¦ä¹ ç›®æ ‡

- âœ… ç›‘æ§è¿›ç¨‹çŠ¶æ€
- âœ… è·å–èµ„æºä½¿ç”¨æƒ…å†µ
- âœ… å®ç°æ—¥å¿—è®°å½•
- âœ… æ„å»ºç›‘æ§å·¥å…·

---

## 1. è¿›ç¨‹çŠ¶æ€ç›‘æ§

### 1.1 åŸºç¡€çŠ¶æ€æ£€æŸ¥

**è¿›ç¨‹å­˜æ´»æ£€æŸ¥**:

```rust
use std::process::Command;

fn is_process_alive(pid: u32) -> bool {
    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;

        match kill(Pid::from_raw(pid as i32), Signal::from_c_int(0).unwrap()) {
            Ok(_) => true,
            Err(_) => false,
        }
    }

    #[cfg(windows)]
    {
        Command::new("tasklist")
            .args(["/FI", &format!("PID eq {}", pid)])
            .output()
            .map(|output| {
                String::from_utf8_lossy(&output.stdout)
                    .contains(&pid.to_string())
            })
            .unwrap_or(false)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut child = Command::new("sleep")
        .arg("10")
        .spawn()
        .unwrap();

    let pid = child.id();
    println!("è¿›ç¨‹ {} å­˜æ´»: {}", pid, is_process_alive(pid));

    child.kill().ok();
    std::thread::sleep(std::time::Duration::from_millis(100));

    println!("è¿›ç¨‹ {} å­˜æ´»: {}", pid, is_process_alive(pid));
}
```

---

### 1.2 è¿›ç¨‹çŠ¶æ€ç›‘æ§å™¨

**å®Œæ•´ç›‘æ§å™¨å®ç°**:

```rust
use std::process::Command;
use std::time::{Duration, Instant};

pub struct ProcessMonitor {
    pid: u32,
    start_time: Instant,
    command: String,
    status: ProcessStatus,
}

#[derive(Debug, Clone)]
pub enum ProcessStatus {
    Running,
    Stopped,
    Zombie,
    Unknown,
}

impl ProcessMonitor {
    pub fn new(pid: u32, command: String) -> Self {
        Self {
            pid,
            start_time: Instant::now(),
            command,
            status: ProcessStatus::Running,
        }
    }

    pub fn update_status(&mut self) {
        self.status = Self::check_status(self.pid);
    }

    fn check_status(pid: u32) -> ProcessStatus {
        #[cfg(unix)]
        {
            use std::fs;

            let stat_path = format!("/proc/{}/stat", pid);
            if let Ok(content) = fs::read_to_string(stat_path) {
                let fields: Vec<&str> = content.split_whitespace().collect();
                if fields.len() > 2 {
                    return match fields[2] {
                        "R" | "S" | "D" => ProcessStatus::Running,
                        "Z" => ProcessStatus::Zombie,
                        "T" => ProcessStatus::Stopped,
                        _ => ProcessStatus::Unknown,
                    };
                }
            }
        }

        if is_process_alive(pid) {
            ProcessStatus::Running
        } else {
            ProcessStatus::Unknown
        }
    }

    pub fn uptime(&self) -> Duration {
        self.start_time.elapsed()
    }

    pub fn pid(&self) -> u32 {
        self.pid
    }

    pub fn command(&self) -> &str {
        &self.command
    }

    pub fn status(&self) -> &ProcessStatus {
        &self.status
    }

    pub fn is_running(&self) -> bool {
        matches!(self.status, ProcessStatus::Running)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("sleep")
        .arg("60")
        .spawn()?;

    let mut monitor = ProcessMonitor::new(child.id(), "sleep 60".to_string());

    for _ in 0..5 {
        monitor.update_status();

        println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        println!("PID: {}", monitor.pid());
        println!("Command: {}", monitor.command());
        println!("Status: {:?}", monitor.status());
        println!("Uptime: {:?}", monitor.uptime());
        println!("Running: {}", monitor.is_running());

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 1.3 æ‰¹é‡è¿›ç¨‹ç›‘æ§

**è¿›ç¨‹ç®¡ç†å™¨**:

```rust
use std::collections::HashMap;
use std::process::{Command, Child};

pub struct ProcessManager {
    processes: HashMap<u32, (Child, ProcessMonitor)>,
}

impl ProcessManager {
    pub fn new() -> Self {
        Self {
            processes: HashMap::new(),
        }
    }

    pub fn spawn(&mut self, command: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let child = Command::new(command).args(args).spawn()?;
        let pid = child.id();
        let monitor = ProcessMonitor::new(pid, format!("{} {}", command, args.join(" ")));

        self.processes.insert(pid, (child, monitor));
        Ok(pid)
    }

    pub fn kill(&mut self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        if let Some((child, _)) = self.processes.get_mut(&pid) {
            child.kill()?;
            self.processes.remove(&pid);
        }
        Ok(())
    }

    pub fn kill_all(&mut self) {
        for (_, (child, _)) in self.processes.iter_mut() {
            child.kill().ok();
        }
        self.processes.clear();
    }

    pub fn update_all(&mut self) {
        self.processes.retain(|_, (child, monitor)| {
            // æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
            match child.try_wait() {
                Ok(None) => {
                    // è¿›ç¨‹è¿˜åœ¨è¿è¡Œï¼Œæ›´æ–°çŠ¶æ€
                    monitor.update_status();
                    true
                }
                _ => {
                    // è¿›ç¨‹å·²é€€å‡º
                    println!("âš ï¸  Process {} exited", monitor.pid());
                    false
                }
            }
        });
    }

    pub fn get_status(&self, pid: u32) -> Option<&ProcessMonitor> {
        self.processes.get(&pid).map(|(_, monitor)| monitor)
    }

    pub fn list_all(&self) -> Vec<&ProcessMonitor> {
        self.processes.values().map(|(_, monitor)| monitor).collect()
    }

    pub fn count(&self) -> usize {
        self.processes.len()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut manager = ProcessManager::new();

    // å¯åŠ¨å¤šä¸ªè¿›ç¨‹
    let pid1 = manager.spawn("sleep", &["10"])?;
    let pid2 = manager.spawn("sleep", &["20"])?;
    let pid3 = manager.spawn("sleep", &["30"])?;

    println!("å¯åŠ¨äº† {} ä¸ªè¿›ç¨‹", manager.count());

    // ç›‘æ§å¾ªç¯
    for _ in 0..15 {
        manager.update_all();

        println!("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        println!("æ´»åŠ¨è¿›ç¨‹: {}", manager.count());

        for monitor in manager.list_all() {
            println!("  PID {}: {:?}, uptime {:?}",
                monitor.pid(),
                monitor.status(),
                monitor.uptime()
            );
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    // æ¸…ç†
    manager.kill_all();
    Ok(())
}
```

---

### 1.4 è¿›ç¨‹çŠ¶æ€æŒä¹…åŒ–

**çŠ¶æ€è®°å½•å™¨**:

```rust
use serde::{Serialize, Deserialize};
use std::fs;
use std::path::PathBuf;

#[derive(Serialize, Deserialize)]
pub struct ProcessRecord {
    pub pid: u32,
    pub command: String,
    pub start_time: String,
    pub end_time: Option<String>,
    pub exit_code: Option<i32>,
    pub status: String,
}

pub struct ProcessRecorder {
    records: Vec<ProcessRecord>,
    log_file: PathBuf,
}

impl ProcessRecorder {
    pub fn new(log_file: PathBuf) -> Self {
        let records = if log_file.exists() {
            let content = fs::read_to_string(&log_file).unwrap_or_default();
            serde_json::from_str(&content).unwrap_or_default()
        } else {
            Vec::new()
        };

        Self { records, log_file }
    }

    pub fn record_start(&mut self, pid: u32, command: String) {
        let record = ProcessRecord {
            pid,
            command,
            start_time: chrono::Local::now().to_rfc3339(),
            end_time: None,
            exit_code: None,
            status: "Running".to_string(),
        };

        self.records.push(record);
        self.save();
    }

    pub fn record_end(&mut self, pid: u32, exit_code: Option<i32>) {
        if let Some(record) = self.records.iter_mut().find(|r| r.pid == pid && r.end_time.is_none()) {
            record.end_time = Some(chrono::Local::now().to_rfc3339());
            record.exit_code = exit_code;
            record.status = "Exited".to_string();
            self.save();
        }
    }

    fn save(&self) {
        if let Ok(content) = serde_json::to_string_pretty(&self.records) {
            fs::write(&self.log_file, content).ok();
        }
    }

    pub fn get_history(&self, pid: u32) -> Vec<&ProcessRecord> {
        self.records.iter().filter(|r| r.pid == pid).collect()
    }
}
```

---

## 2. èµ„æºä½¿ç”¨ç›‘æ§

### 2.1 åŸºç¡€èµ„æºç›‘æ§

**ä½¿ç”¨ sysinfo åº“**:

```rust
use sysinfo::{System, SystemExt, ProcessExt, Pid};

pub struct ResourceMonitor {
    system: System,
}

impl ResourceMonitor {
    pub fn new() -> Self {
        let mut system = System::new_all();
        system.refresh_all();

        Self { system }
    }

    pub fn get_process_info(&mut self, pid: u32) -> Option<ProcessInfo> {
        self.system.refresh_process(Pid::from(pid as usize));

        self.system.process(Pid::from(pid as usize)).map(|process| {
            ProcessInfo {
                pid,
                name: process.name().to_string(),
                cpu_usage: process.cpu_usage(),
                memory: process.memory(),
                virtual_memory: process.virtual_memory(),
                disk_usage: process.disk_usage(),
                status: format!("{:?}", process.status()),
            }
        })
    }

    pub fn get_system_info(&mut self) -> SystemInfo {
        self.system.refresh_all();

        SystemInfo {
            total_memory: self.system.total_memory(),
            used_memory: self.system.used_memory(),
            total_swap: self.system.total_swap(),
            used_swap: self.system.used_swap(),
            cpu_count: self.system.cpus().len(),
            global_cpu_usage: self.system.global_cpu_info().cpu_usage(),
        }
    }
}

#[derive(Debug)]
pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub cpu_usage: f32,
    pub memory: u64,
    pub virtual_memory: u64,
    pub disk_usage: sysinfo::DiskUsage,
    pub status: String,
}

#[derive(Debug)]
pub struct SystemInfo {
    pub total_memory: u64,
    pub used_memory: u64,
    pub total_swap: u64,
    pub used_swap: u64,
    pub cpu_count: usize,
    pub global_cpu_usage: f32,
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("stress")
        .args(["--cpu", "1", "--timeout", "30s"])
        .spawn()?;

    let mut monitor = ResourceMonitor::new();

    for _ in 0..10 {
        if let Some(info) = monitor.get_process_info(child.id()) {
            println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
            println!("PID: {}", info.pid);
            println!("Name: {}", info.name);
            println!("CPU: {:.2}%", info.cpu_usage);
            println!("Memory: {} KB", info.memory);
            println!("Virtual Memory: {} KB", info.virtual_memory);
            println!("Status: {}", info.status);
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 2.2 é«˜çº§èµ„æºç›‘æ§

**èµ„æºç»Ÿè®¡ä¸å†å²è®°å½•**:

```rust
use std::collections::VecDeque;

pub struct ResourceTracker {
    history_size: usize,
    cpu_history: VecDeque<f32>,
    memory_history: VecDeque<u64>,
    monitor: ResourceMonitor,
}

impl ResourceTracker {
    pub fn new(history_size: usize) -> Self {
        Self {
            history_size,
            cpu_history: VecDeque::new(),
            memory_history: VecDeque::new(),
            monitor: ResourceMonitor::new(),
        }
    }

    pub fn update(&mut self, pid: u32) {
        if let Some(info) = self.monitor.get_process_info(pid) {
            // æ·»åŠ æ–°æ•°æ®
            self.cpu_history.push_back(info.cpu_usage);
            self.memory_history.push_back(info.memory);

            // ä¿æŒå†å²å¤§å°
            while self.cpu_history.len() > self.history_size {
                self.cpu_history.pop_front();
            }
            while self.memory_history.len() > self.history_size {
                self.memory_history.pop_front();
            }
        }
    }

    pub fn get_statistics(&self) -> ResourceStatistics {
        ResourceStatistics {
            cpu_avg: self.average(&self.cpu_history),
            cpu_max: self.max(&self.cpu_history),
            cpu_min: self.min(&self.cpu_history),
            memory_avg: self.average_u64(&self.memory_history),
            memory_max: self.max_u64(&self.memory_history),
            memory_min: self.min_u64(&self.memory_history),
        }
    }

    fn average(&self, data: &VecDeque<f32>) -> f32 {
        if data.is_empty() {
            return 0.0;
        }
        data.iter().sum::<f32>() / data.len() as f32
    }

    fn max(&self, data: &VecDeque<f32>) -> f32 {
        data.iter().cloned().fold(f32::NEG_INFINITY, f32::max)
    }

    fn min(&self, data: &VecDeque<f32>) -> f32 {
        data.iter().cloned().fold(f32::INFINITY, f32::min)
    }

    fn average_u64(&self, data: &VecDeque<u64>) -> u64 {
        if data.is_empty() {
            return 0;
        }
        data.iter().sum::<u64>() / data.len() as u64
    }

    fn max_u64(&self, data: &VecDeque<u64>) -> u64 {
        *data.iter().max().unwrap_or(&0)
    }

    fn min_u64(&self, data: &VecDeque<u64>) -> u64 {
        *data.iter().min().unwrap_or(&0)
    }
}

#[derive(Debug)]
pub struct ResourceStatistics {
    pub cpu_avg: f32,
    pub cpu_max: f32,
    pub cpu_min: f32,
    pub memory_avg: u64,
    pub memory_max: u64,
    pub memory_min: u64,
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("stress")
        .args(["--cpu", "1", "--timeout", "60s"])
        .spawn()?;

    let mut tracker = ResourceTracker::new(60);  // ä¿ç•™60ç§’å†å²

    for i in 0..60 {
        tracker.update(child.id());

        if i % 10 == 0 {
            let stats = tracker.get_statistics();
            println!("\nâ”â”â”â”â”â” ç»Ÿè®¡ä¿¡æ¯ ({}s) â”â”â”â”â”â”", i);
            println!("CPU - Avg: {:.2}%, Max: {:.2}%, Min: {:.2}%",
                stats.cpu_avg, stats.cpu_max, stats.cpu_min);
            println!("Memory - Avg: {} KB, Max: {} KB, Min: {} KB",
                stats.memory_avg, stats.memory_max, stats.memory_min);
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 2.3 èµ„æºé™åˆ¶ä¸å‘Šè­¦

**èµ„æºé˜ˆå€¼ç›‘æ§**:

```rust
pub struct ResourceAlarm {
    cpu_threshold: f32,
    memory_threshold: u64,
    callbacks: Vec<Box<dyn Fn(AlarmEvent) + Send>>,
}

#[derive(Debug, Clone)]
pub enum AlarmEvent {
    CpuHigh { pid: u32, usage: f32 },
    MemoryHigh { pid: u32, usage: u64 },
    CpuNormal { pid: u32 },
    MemoryNormal { pid: u32 },
}

impl ResourceAlarm {
    pub fn new(cpu_threshold: f32, memory_threshold: u64) -> Self {
        Self {
            cpu_threshold,
            memory_threshold,
            callbacks: Vec::new(),
        }
    }

    pub fn on_alarm<F>(&mut self, callback: F)
    where
        F: Fn(AlarmEvent) + Send + 'static,
    {
        self.callbacks.push(Box::new(callback));
    }

    pub fn check(&self, info: &ProcessInfo) {
        if info.cpu_usage > self.cpu_threshold {
            let event = AlarmEvent::CpuHigh {
                pid: info.pid,
                usage: info.cpu_usage,
            };
            self.trigger(event);
        }

        if info.memory > self.memory_threshold {
            let event = AlarmEvent::MemoryHigh {
                pid: info.pid,
                usage: info.memory,
            };
            self.trigger(event);
        }
    }

    fn trigger(&self, event: AlarmEvent) {
        for callback in &self.callbacks {
            callback(event.clone());
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut alarm = ResourceAlarm::new(80.0, 100 * 1024 * 1024);  // 80% CPU, 100MB

    alarm.on_alarm(|event| {
        match event {
            AlarmEvent::CpuHigh { pid, usage } => {
                eprintln!("âš ï¸  HIGH CPU: Process {} using {:.2}%", pid, usage);
            }
            AlarmEvent::MemoryHigh { pid, usage } => {
                eprintln!("âš ï¸  HIGH MEMORY: Process {} using {} bytes", pid, usage);
            }
            _ => {}
        }
    });

    let mut child = Command::new("stress")
        .args(["--cpu", "4", "--timeout", "30s"])
        .spawn()?;

    let mut monitor = ResourceMonitor::new();

    for _ in 0..30 {
        if let Some(info) = monitor.get_process_info(child.id()) {
            alarm.check(&info);
        }
        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

### 2.4 è·¨å¹³å°èµ„æºç›‘æ§

**å¹³å°ç‰¹å®šå®ç°**:

```rust
#[cfg(unix)]
mod unix {
    use std::fs;

    pub fn get_process_cpu_time(pid: u32) -> Result<u64, Box<dyn std::error::Error>> {
        let stat = fs::read_to_string(format!("/proc/{}/stat", pid))?;
        let fields: Vec<&str> = stat.split_whitespace().collect();

        if fields.len() > 14 {
            let utime: u64 = fields[13].parse()?;
            let stime: u64 = fields[14].parse()?;
            Ok(utime + stime)
        } else {
            Err("Invalid stat format".into())
        }
    }

    pub fn get_process_memory(pid: u32) -> Result<u64, Box<dyn std::error::Error>> {
        let status = fs::read_to_string(format!("/proc/{}/status", pid))?;

        for line in status.lines() {
            if line.starts_with("VmRSS:") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    return Ok(parts[1].parse::<u64>()? * 1024);  // Convert to bytes
                }
            }
        }

        Err("VmRSS not found".into())
    }
}

#[cfg(windows)]
mod windows {
    use winapi::um::processthreadsapi::*;
    use winapi::um::psapi::*;

    pub fn get_process_memory(pid: u32) -> Result<u64, Box<dyn std::error::Error>> {
        unsafe {
            use winapi::um::handleapi::CloseHandle;
            use winapi::shared::minwindef::FALSE;

            let handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
            if handle.is_null() {
                return Err("Failed to open process".into());
            }

            let mut pmc: PROCESS_MEMORY_COUNTERS = std::mem::zeroed();
            pmc.cb = std::mem::size_of::<PROCESS_MEMORY_COUNTERS>() as u32;

            if GetProcessMemoryInfo(handle, &mut pmc, pmc.cb) != 0 {
                CloseHandle(handle);
                Ok(pmc.WorkingSetSize as u64)
            } else {
                CloseHandle(handle);
                Err("GetProcessMemoryInfo failed".into())
            }
        }
    }
}
```

---

### 2.5 æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

**æ€§èƒ½ç“¶é¢ˆæ£€æµ‹**:

```rust
pub struct PerformanceAnalyzer {
    tracker: ResourceTracker,
    baseline_cpu: f32,
    baseline_memory: u64,
}

impl PerformanceAnalyzer {
    pub fn new(baseline_samples: usize) -> Self {
        Self {
            tracker: ResourceTracker::new(baseline_samples),
            baseline_cpu: 0.0,
            baseline_memory: 0,
        }
    }

    pub fn establish_baseline(&mut self, pid: u32, duration: Duration) {
        let samples = duration.as_secs() as usize;

        for _ in 0..samples {
            self.tracker.update(pid);
            std::thread::sleep(Duration::from_secs(1));
        }

        let stats = self.tracker.get_statistics();
        self.baseline_cpu = stats.cpu_avg;
        self.baseline_memory = stats.memory_avg;

        println!("ğŸ“Š Baseline established:");
        println!("   CPU: {:.2}%", self.baseline_cpu);
        println!("   Memory: {} KB", self.baseline_memory);
    }

    pub fn analyze(&mut self, pid: u32) -> PerformanceReport {
        self.tracker.update(pid);
        let stats = self.tracker.get_statistics();

        let cpu_deviation = ((stats.cpu_avg - self.baseline_cpu) / self.baseline_cpu) * 100.0;
        let memory_deviation = if self.baseline_memory > 0 {
            ((stats.memory_avg as f64 - self.baseline_memory as f64) / self.baseline_memory as f64) * 100.0
        } else {
            0.0
        };

        PerformanceReport {
            current_cpu: stats.cpu_avg,
            current_memory: stats.memory_avg,
            cpu_deviation,
            memory_deviation,
            is_anomaly: cpu_deviation.abs() > 50.0 || memory_deviation.abs() > 50.0,
        }
    }
}

#[derive(Debug)]
pub struct PerformanceReport {
    pub current_cpu: f32,
    pub current_memory: u64,
    pub cpu_deviation: f32,
    pub memory_deviation: f64,
    pub is_anomaly: bool,
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("my_app").spawn()?;

    let mut analyzer = PerformanceAnalyzer::new(60);

    // å»ºç«‹åŸºçº¿ï¼ˆ60ç§’ï¼‰
    println!("â±ï¸  Establishing baseline...");
    analyzer.establish_baseline(child.id(), Duration::from_secs(60));

    // æŒç»­ç›‘æ§
    println!("\nğŸ“ˆ Monitoring performance...");
    for i in 0..300 {
        let report = analyzer.analyze(child.id());

        if i % 10 == 0 {
            println!("\nâ”â”â”â”â”â” Report ({}s) â”â”â”â”â”â”", i);
            println!("CPU: {:.2}% (deviation: {:+.2}%)",
                report.current_cpu, report.cpu_deviation);
            println!("Memory: {} KB (deviation: {:+.2}%)",
                report.current_memory, report.memory_deviation);

            if report.is_anomaly {
                eprintln!("ğŸš¨ ANOMALY DETECTED!");
            }
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    Ok(())
}
```

---

## 3. æ—¥å¿—ä¸è°ƒè¯•

### 3.1 æ ‡å‡†è¾“å‡ºæ•è·

**æ•è·stderrå’Œstdout**:

```rust
use std::process::{Command, Stdio};

fn capture_output(cmd: &str, args: &[&str]) -> Result<(String, String), Box<dyn std::error::Error>> {
    let output = Command::new(cmd)
        .args(args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()?;

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    Ok((stdout, stderr))
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (stdout, stderr) = capture_output("ls", &["-la", "/nonexistent"])?;

    println!("STDOUT:\n{}", stdout);

    if !stderr.is_empty() {
        eprintln!("STDERR:\n{}", stderr);
    }

    Ok(())
}
```

---

### 3.2 å®æ—¶æ—¥å¿—æµ

**å¼‚æ­¥æ—¥å¿—æ•è·**:

```rust
use std::io::{BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;

pub struct LogCapture {
    handles: Vec<thread::JoinHandle<()>>,
}

impl LogCapture {
    pub fn new() -> Self {
        Self {
            handles: Vec::new(),
        }
    }

    pub fn capture_stdout<F>(&mut self, child: &mut std::process::Child, mut callback: F)
    where
        F: FnMut(String) + Send + 'static,
    {
        if let Some(stdout) = child.stdout.take() {
            let handle = thread::spawn(move || {
                let reader = BufReader::new(stdout);
                for line in reader.lines() {
                    if let Ok(line) = line {
                        callback(line);
                    }
                }
            });
            self.handles.push(handle);
        }
    }

    pub fn capture_stderr<F>(&mut self, child: &mut std::process::Child, mut callback: F)
    where
        F: FnMut(String) + Send + 'static,
    {
        if let Some(stderr) = child.stderr.take() {
            let handle = thread::spawn(move || {
                let reader = BufReader::new(stderr);
                for line in reader.lines() {
                    if let Ok(line) = line {
                        callback(line);
                    }
                }
            });
            self.handles.push(handle);
        }
    }

    pub fn wait(self) {
        for handle in self.handles {
            handle.join().ok();
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("my_app")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let mut capture = LogCapture::new();

    capture.capture_stdout(&mut child, |line| {
        println!("[STDOUT] {}", line);
    });

    capture.capture_stderr(&mut child, |line| {
        eprintln!("[STDERR] {}", line);
    });

    child.wait()?;
    capture.wait();

    Ok(())
}
```

---

### 3.3 æ—¥å¿—æ–‡ä»¶è®°å½•

**æ—¥å¿—å†™å…¥æ–‡ä»¶**:

```rust
use std::fs::{File, OpenOptions};
use std::io::{Write, BufWriter};
use std::sync::{Arc, Mutex};

pub struct FileLogger {
    writer: Arc<Mutex<BufWriter<File>>>,
}

impl FileLogger {
    pub fn new(path: &str) -> Result<Self, std::io::Error> {
        let file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)?;

        let writer = BufWriter::new(file);

        Ok(Self {
            writer: Arc::new(Mutex::new(writer)),
        })
    }

    pub fn log(&self, message: &str) {
        if let Ok(mut writer) = self.writer.lock() {
            let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
            writeln!(writer, "[{}] {}", timestamp, message).ok();
            writer.flush().ok();
        }
    }

    pub fn log_process_output(&self, pid: u32, stream: &str, line: &str) {
        self.log(&format!("[PID:{}] [{}] {}", pid, stream, line));
    }
}

impl Clone for FileLogger {
    fn clone(&self) -> Self {
        Self {
            writer: Arc::clone(&self.writer),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let logger = FileLogger::new("process.log")?;

    let mut child = Command::new("my_app")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let pid = child.id();
    let mut capture = LogCapture::new();

    let logger_stdout = logger.clone();
    capture.capture_stdout(&mut child, move |line| {
        logger_stdout.log_process_output(pid, "STDOUT", &line);
        println!("[STDOUT] {}", line);
    });

    let logger_stderr = logger.clone();
    capture.capture_stderr(&mut child, move |line| {
        logger_stderr.log_process_output(pid, "STDERR", &line);
        eprintln!("[STDERR] {}", line);
    });

    child.wait()?;
    capture.wait();

    Ok(())
}
```

---

### 3.4 ç»“æ„åŒ–æ—¥å¿—

**ä½¿ç”¨tracing**:

```rust
use tracing::{info, warn, error, debug, instrument};
use tracing_subscriber;

#[instrument]
pub fn run_monitored_process(cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
    info!("Starting process: {}", cmd);

    let mut child = Command::new(cmd)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let pid = child.id();
    info!(pid = pid, "Process spawned");

    let status = child.wait()?;

    if status.success() {
        info!(pid = pid, exit_code = ?status.code(), "Process completed successfully");
    } else {
        warn!(pid = pid, exit_code = ?status.code(), "Process exited with error");
    }

    Ok(())
}

fn main() {
    // åˆå§‹åŒ–tracing
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();

    run_monitored_process("my_app").ok();
}
```

---

### 3.5 è°ƒè¯•æŠ€å·§

**è¯¦ç»†è¿›ç¨‹ä¿¡æ¯**:

```rust
use std::process::Command;

pub fn debug_process_info(pid: u32) {
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸ” Process Debug Info");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("PID: {}", pid);

    #[cfg(unix)]
    {
        // å‘½ä»¤è¡Œ
        if let Ok(cmdline) = std::fs::read_to_string(format!("/proc/{}/cmdline", pid)) {
            let args: Vec<&str> = cmdline.split('\0').filter(|s| !s.is_empty()).collect();
            println!("Cmdline: {:?}", args);
        }

        // ç¯å¢ƒå˜é‡
        if let Ok(environ) = std::fs::read_to_string(format!("/proc/{}/environ", pid)) {
            let envs: Vec<&str> = environ.split('\0').take(5).collect();
            println!("Environ (first 5): {:?}", envs);
        }

        // å½“å‰å·¥ä½œç›®å½•
        if let Ok(cwd) = std::fs::read_link(format!("/proc/{}/cwd", pid)) {
            println!("CWD: {:?}", cwd);
        }

        // æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦
        if let Ok(entries) = std::fs::read_dir(format!("/proc/{}/fd", pid)) {
            let count = entries.count();
            println!("Open FDs: {}", count);
        }
    }

    #[cfg(windows)]
    {
        // WindowsæŸ¥è¯¢è¿›ç¨‹ä¿¡æ¯
        let output = Command::new("tasklist")
            .args(["/FI", &format!("PID eq {}", pid), "/V"])
            .output();

        if let Ok(output) = output {
            println!("{}", String::from_utf8_lossy(&output.stdout));
        }
    }
}
```

---

### 3.6 é”™è¯¯è¯Šæ–­

**è¿›ç¨‹å¤±è´¥åˆ†æ**:

```rust
pub fn diagnose_failure(cmd: &str, args: &[&str]) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ” Diagnosing: {} {:?}", cmd, args);

    let result = Command::new(cmd)
        .args(args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output();

    match result {
        Ok(output) => {
            println!("\nâœ… Process executed");
            println!("Exit code: {:?}", output.status.code());

            if !output.status.success() {
                println!("\nâŒ Process failed!");

                let stderr = String::from_utf8_lossy(&output.stderr);
                if !stderr.is_empty() {
                    println!("\nğŸ“‹ Error output:");
                    println!("{}", stderr);
                }

                let stdout = String::from_utf8_lossy(&output.stdout);
                if !stdout.is_empty() {
                    println!("\nğŸ“‹ Standard output:");
                    println!("{}", stdout);
                }

                #[cfg(unix)]
                {
                    use std::os::unix::process::ExitStatusExt;
                    if let Some(signal) = output.status.signal() {
                        println!("\nâš ï¸  Killed by signal: {}", signal);
                    }
                }
            } else {
                println!("\nâœ… Process succeeded");
            }
        }
        Err(e) => {
            println!("\nâŒ Failed to spawn process!");
            println!("Error: {}", e);
            println!("\nğŸ’¡ Possible causes:");
            println!("  - Command not found in PATH");
            println!("  - Insufficient permissions");
            println!("  - Invalid arguments");
            println!("  - System resource limits");
        }
    }

    Ok(())
}
```

---

## 4. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: å®Œæ•´çš„è¿›ç¨‹ç›‘æ§ç³»ç»Ÿ

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct ComprehensiveMonitor {
    processes: HashMap<u32, MonitoredProcess>,
    resource_monitor: ResourceMonitor,
    logger: FileLogger,
    alarms: Vec<ResourceAlarm>,
}

struct MonitoredProcess {
    child: Option<Child>,
    monitor: ProcessMonitor,
    tracker: ResourceTracker,
    start_time: Instant,
}

impl ComprehensiveMonitor {
    pub fn new(log_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            processes: HashMap::new(),
            resource_monitor: ResourceMonitor::new(),
            logger: FileLogger::new(log_path)?,
            alarms: Vec::new(),
        })
    }

    pub fn spawn(&mut self, cmd: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let mut child = Command::new(cmd)
            .args(args)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        let pid = child.id();
        let command = format!("{} {}", cmd, args.join(" "));

        // è®¾ç½®æ—¥å¿—æ•è·
        let mut capture = LogCapture::new();
        let logger = self.logger.clone();

        capture.capture_stdout(&mut child, move |line| {
            logger.log_process_output(pid, "STDOUT", &line);
        });

        let logger = self.logger.clone();
        capture.capture_stderr(&mut child, move |line| {
            logger.log_process_output(pid, "STDERR", &line);
        });

        // åˆ›å»ºç›‘æ§å¯¹è±¡
        let process = MonitoredProcess {
            child: Some(child),
            monitor: ProcessMonitor::new(pid, command.clone()),
            tracker: ResourceTracker::new(300),  // 5åˆ†é’Ÿå†å²
            start_time: Instant::now(),
        };

        self.processes.insert(pid, process);
        self.logger.log(&format!("Process {} started: {}", pid, command));

        Ok(pid)
    }

    pub fn monitor_all(&mut self) {
        let pids: Vec<u32> = self.processes.keys().copied().collect();

        for pid in pids {
            if let Some(process) = self.processes.get_mut(&pid) {
                // æ›´æ–°çŠ¶æ€
                process.monitor.update_status();
                process.tracker.update(pid);

                // æ£€æŸ¥æ˜¯å¦è¿˜åœ¨è¿è¡Œ
                if let Some(child) = &mut process.child {
                    match child.try_wait() {
                        Ok(Some(status)) => {
                            let uptime = process.start_time.elapsed();
                            self.logger.log(&format!(
                                "Process {} exited with status {:?} after {:?}",
                                pid, status.code(), uptime
                            ));
                            self.processes.remove(&pid);
                        }
                        Ok(None) => {
                            // è¿›ç¨‹è¿˜åœ¨è¿è¡Œï¼Œæ£€æŸ¥å‘Šè­¦
                            if let Some(info) = self.resource_monitor.get_process_info(pid) {
                                for alarm in &self.alarms {
                                    alarm.check(&info);
                                }
                            }
                        }
                        Err(_) => {
                            self.logger.log(&format!("Error checking process {}", pid));
                            self.processes.remove(&pid);
                        }
                    }
                }
            }
        }
    }

    pub fn get_report(&self) -> MonitorReport {
        let mut total_cpu = 0.0;
        let mut total_memory = 0;
        let mut process_count = 0;

        for (_, process) in &self.processes {
            let stats = process.tracker.get_statistics();
            total_cpu += stats.cpu_avg;
            total_memory += stats.memory_avg;
            process_count += 1;
        }

        MonitorReport {
            active_processes: process_count,
            total_cpu_usage: total_cpu,
            total_memory_usage: total_memory,
            uptime: Duration::from_secs(0),  // å®é™…åº”è®¡ç®—
        }
    }
}

#[derive(Debug)]
pub struct MonitorReport {
    pub active_processes: usize,
    pub total_cpu_usage: f32,
    pub total_memory_usage: u64,
    pub uptime: Duration,
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut monitor = ComprehensiveMonitor::new("monitor.log")?;

    // å¯åŠ¨å¤šä¸ªè¿›ç¨‹
    monitor.spawn("stress", &["--cpu", "1", "--timeout", "30s"])?;
    monitor.spawn("stress", &["--vm", "1", "--timeout", "30s"])?;

    // ç›‘æ§å¾ªç¯
    for _ in 0..60 {
        monitor.monitor_all();

        let report = monitor.get_report();
        println!("Active: {}, CPU: {:.2}%, Memory: {} KB",
            report.active_processes,
            report.total_cpu_usage,
            report.total_memory_usage
        );

        std::thread::sleep(Duration::from_secs(1));
    }

    Ok(())
}
```

---

### æ¡ˆä¾‹2: è‡ªåŠ¨é‡å¯å®ˆæŠ¤è¿›ç¨‹

```rust
pub struct ProcessSupervisor {
    command: String,
    args: Vec<String>,
    max_restarts: usize,
    restart_count: usize,
    monitor: Option<ProcessMonitor>,
    logger: FileLogger,
}

impl ProcessSupervisor {
    pub fn new(command: String, args: Vec<String>, log_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            command,
            args,
            max_restarts: 5,
            restart_count: 0,
            monitor: None,
            logger: FileLogger::new(log_path)?,
        })
    }

    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        loop {
            self.logger.log("Starting supervised process");

            let mut child = Command::new(&self.command)
                .args(&self.args)
                .spawn()?;

            let pid = child.id();
            self.monitor = Some(ProcessMonitor::new(pid, format!("{} {:?}", self.command, self.args)));

            self.logger.log(&format!("Process started with PID {}", pid));

            // ç­‰å¾…è¿›ç¨‹é€€å‡º
            match child.wait() {
                Ok(status) => {
                    self.logger.log(&format!("Process {} exited with status {:?}", pid, status.code()));

                    if !status.success() {
                        self.restart_count += 1;

                        if self.restart_count >= self.max_restarts {
                            self.logger.log(&format!("Max restarts ({}) reached, giving up", self.max_restarts));
                            return Err("Max restarts reached".into());
                        }

                        self.logger.log(&format!("Restarting... (attempt {}/{})",
                            self.restart_count, self.max_restarts));

                        std::thread::sleep(Duration::from_secs(5));
                    } else {
                        // æ­£å¸¸é€€å‡ºï¼Œé‡ç½®è®¡æ•°å™¨
                        self.restart_count = 0;
                    }
                }
                Err(e) => {
                    self.logger.log(&format!("Error waiting for process: {}", e));
                    return Err(e.into());
                }
            }
        }
    }
}
```

---

### æ¡ˆä¾‹3: æ€§èƒ½åŸºå‡†æµ‹è¯•å·¥å…·

```rust
pub struct BenchmarkRunner {
    command: String,
    args: Vec<String>,
    iterations: usize,
    results: Vec<BenchmarkResult>,
}

#[derive(Debug)]
pub struct BenchmarkResult {
    pub duration: Duration,
    pub exit_code: Option<i32>,
    pub avg_cpu: f32,
    pub peak_memory: u64,
}

impl BenchmarkRunner {
    pub fn new(command: String, args: Vec<String>, iterations: usize) -> Self {
        Self {
            command,
            args,
            iterations,
            results: Vec::new(),
        }
    }

    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸƒ Running benchmark: {} iterations", self.iterations);

        for i in 0..self.iterations {
            println!("\nâ”â”â”â” Iteration {}/{} â”â”â”â”", i + 1, self.iterations);

            let result = self.run_single()?;

            println!("Duration: {:?}", result.duration);
            println!("Avg CPU: {:.2}%", result.avg_cpu);
            println!("Peak Memory: {} KB", result.peak_memory);

            self.results.push(result);
        }

        self.print_summary();

        Ok(())
    }

    fn run_single(&self) -> Result<BenchmarkResult, Box<dyn std::error::Error>> {
        let start = Instant::now();

        let mut child = Command::new(&self.command)
            .args(&self.args)
            .spawn()?;

        let pid = child.id();
        let mut tracker = ResourceTracker::new(1000);

        // ç›‘æ§è¿›ç¨‹
        loop {
            tracker.update(pid);

            match child.try_wait()? {
                Some(status) => {
                    let duration = start.elapsed();
                    let stats = tracker.get_statistics();

                    return Ok(BenchmarkResult {
                        duration,
                        exit_code: status.code(),
                        avg_cpu: stats.cpu_avg,
                        peak_memory: stats.memory_max,
                    });
                }
                None => {
                    std::thread::sleep(Duration::from_millis(100));
                }
            }
        }
    }

    fn print_summary(&self) {
        if self.results.is_empty() {
            return;
        }

        println!("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        println!("ğŸ“Š Benchmark Summary");
        println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

        let avg_duration = self.results.iter()
            .map(|r| r.duration.as_secs_f64())
            .sum::<f64>() / self.results.len() as f64;

        let avg_cpu = self.results.iter()
            .map(|r| r.avg_cpu)
            .sum::<f32>() / self.results.len() as f32;

        let avg_memory = self.results.iter()
            .map(|r| r.peak_memory)
            .sum::<u64>() / self.results.len() as u64;

        println!("Iterations: {}", self.results.len());
        println!("Avg Duration: {:.2}s", avg_duration);
        println!("Avg CPU: {:.2}%", avg_cpu);
        println!("Avg Peak Memory: {} KB", avg_memory);
    }
}
```

---

## 5. æ€»ç»“

### å…³é”®è¦ç‚¹

1. âœ… **è¿›ç¨‹çŠ¶æ€ç›‘æ§**: ä½¿ç”¨`try_wait()`æ£€æŸ¥è¿›ç¨‹çŠ¶æ€ï¼Œè¯»å–`/proc`æ–‡ä»¶ç³»ç»Ÿè·å–è¯¦ç»†ä¿¡æ¯
2. âœ… **èµ„æºç›‘æ§**: ä½¿ç”¨`sysinfo`åº“è·¨å¹³å°ç›‘æ§CPUå’Œå†…å­˜
3. âœ… **æ—¥å¿—è®°å½•**: æ•è·stdout/stderrï¼Œä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—ï¼ˆtracingï¼‰
4. âœ… **å‘Šè­¦æœºåˆ¶**: åŸºäºé˜ˆå€¼çš„èµ„æºå‘Šè­¦ç³»ç»Ÿ
5. âœ… **æ€§èƒ½åˆ†æ**: å»ºç«‹åŸºçº¿ï¼Œæ£€æµ‹æ€§èƒ½å¼‚å¸¸

### æœ€ä½³å®è·µ

**ç›‘æ§é¢‘ç‡**: æ ¹æ®éœ€æ±‚è°ƒæ•´

- å®æ—¶ç›‘æ§: 100-500ms
- å¸¸è§„ç›‘æ§: 1-5s
- é•¿æœŸç›‘æ§: 10-60s

**èµ„æºå†å²**: ä¿ç•™åˆé€‚çš„å†å²æ•°æ®

- çŸ­æœŸ: æœ€è¿‘5-10åˆ†é’Ÿ
- ä¸­æœŸ: æœ€è¿‘1å°æ—¶ï¼ˆé‡‡æ ·ï¼‰
- é•¿æœŸ: æŒ‰å¤©èšåˆ

**æ—¥å¿—ç®¡ç†**:

- ä½¿ç”¨æ—¥å¿—è½®è½¬
- æ§åˆ¶æ—¥å¿—çº§åˆ«
- å¼‚æ­¥å†™å…¥

**å‘Šè­¦ç­–ç•¥**:

- åˆç†è®¾ç½®é˜ˆå€¼
- é¿å…å‘Šè­¦é£æš´
- æ”¯æŒå‘Šè­¦é™é»˜

### æ¨èå·¥å…·

- **sysinfo**: è·¨å¹³å°ç³»ç»Ÿä¿¡æ¯
- **tracing**: ç»“æ„åŒ–æ—¥å¿—
- **prometheus**: ç›‘æ§æŒ‡æ ‡æ”¶é›†
- **grafana**: å¯è§†åŒ–ç›‘æ§é¢æ¿

---

**ä¸‹ä¸€æ­¥**:

- [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](./01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)
- [IPCé€šä¿¡å®è·µ](./02_IPCé€šä¿¡å®è·µ.md)
- [å¼‚æ­¥è¿›ç¨‹ç®¡ç†](./03_å¼‚æ­¥è¿›ç¨‹ç®¡ç†.md)
- [è·¨å¹³å°å®è·µ](./04_è·¨å¹³å°å®è·µ.md)

---

**å‚è€ƒ**: [æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](../tier_03_references/05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
