# Tier 2: 进程监控与诊断

> **文档类型**: 实践指南  
> **难度**: ⭐⭐ 初级  
> **预计时间**: 1小时  
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 进程监控与诊断](#tier-2-进程监控与诊断)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 进程状态监控](#1-进程状态监控)
    - [1.1 基础状态检查](#11-基础状态检查)
    - [1.2 进程状态监控器](#12-进程状态监控器)
    - [1.3 批量进程监控](#13-批量进程监控)
    - [1.4 进程状态持久化](#14-进程状态持久化)
  - [2. 资源使用监控](#2-资源使用监控)
  - [3. 日志与调试](#3-日志与调试)
  - [4. 实战案例](#4-实战案例)

---

## 学习目标

- ✅ 监控进程状态
- ✅ 获取资源使用情况
- ✅ 实现日志记录
- ✅ 构建监控工具

---

## 1. 进程状态监控

### 1.1 基础状态检查

**进程存活检查**:

```rust
use std::process::Command;

fn is_process_alive(pid: u32) -> bool {
    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;
        
        match kill(Pid::from_raw(pid as i32), Signal::from_c_int(0).unwrap()) {
            Ok(_) => true,
            Err(_) => false,
        }
    }
    
    #[cfg(windows)]
    {
        Command::new("tasklist")
            .args(["/FI", &format!("PID eq {}", pid)])
            .output()
            .map(|output| {
                String::from_utf8_lossy(&output.stdout)
                    .contains(&pid.to_string())
            })
            .unwrap_or(false)
    }
}

// 使用示例
fn main() {
    let mut child = Command::new("sleep")
        .arg("10")
        .spawn()
        .unwrap();
    
    let pid = child.id();
    println!("进程 {} 存活: {}", pid, is_process_alive(pid));
    
    child.kill().ok();
    std::thread::sleep(std::time::Duration::from_millis(100));
    
    println!("进程 {} 存活: {}", pid, is_process_alive(pid));
}
```

---

### 1.2 进程状态监控器

**完整监控器实现**:

```rust
use std::process::Command;
use std::time::{Duration, Instant};

pub struct ProcessMonitor {
    pid: u32,
    start_time: Instant,
    command: String,
    status: ProcessStatus,
}

#[derive(Debug, Clone)]
pub enum ProcessStatus {
    Running,
    Stopped,
    Zombie,
    Unknown,
}

impl ProcessMonitor {
    pub fn new(pid: u32, command: String) -> Self {
        Self {
            pid,
            start_time: Instant::now(),
            command,
            status: ProcessStatus::Running,
        }
    }
    
    pub fn update_status(&mut self) {
        self.status = Self::check_status(self.pid);
    }
    
    fn check_status(pid: u32) -> ProcessStatus {
        #[cfg(unix)]
        {
            use std::fs;
            
            let stat_path = format!("/proc/{}/stat", pid);
            if let Ok(content) = fs::read_to_string(stat_path) {
                let fields: Vec<&str> = content.split_whitespace().collect();
                if fields.len() > 2 {
                    return match fields[2] {
                        "R" | "S" | "D" => ProcessStatus::Running,
                        "Z" => ProcessStatus::Zombie,
                        "T" => ProcessStatus::Stopped,
                        _ => ProcessStatus::Unknown,
                    };
                }
            }
        }
        
        if is_process_alive(pid) {
            ProcessStatus::Running
        } else {
            ProcessStatus::Unknown
        }
    }
    
    pub fn uptime(&self) -> Duration {
        self.start_time.elapsed()
    }
    
    pub fn pid(&self) -> u32 {
        self.pid
    }
    
    pub fn command(&self) -> &str {
        &self.command
    }
    
    pub fn status(&self) -> &ProcessStatus {
        &self.status
    }
    
    pub fn is_running(&self) -> bool {
        matches!(self.status, ProcessStatus::Running)
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("sleep")
        .arg("60")
        .spawn()?;
    
    let mut monitor = ProcessMonitor::new(child.id(), "sleep 60".to_string());
    
    for _ in 0..5 {
        monitor.update_status();
        
        println!("━━━━━━━━━━━━━━━━━━━━━━━━━");
        println!("PID: {}", monitor.pid());
        println!("Command: {}", monitor.command());
        println!("Status: {:?}", monitor.status());
        println!("Uptime: {:?}", monitor.uptime());
        println!("Running: {}", monitor.is_running());
        
        std::thread::sleep(Duration::from_secs(1));
    }
    
    child.kill()?;
    Ok(())
}
```

---

### 1.3 批量进程监控

**进程管理器**:

```rust
use std::collections::HashMap;
use std::process::{Command, Child};

pub struct ProcessManager {
    processes: HashMap<u32, (Child, ProcessMonitor)>,
}

impl ProcessManager {
    pub fn new() -> Self {
        Self {
            processes: HashMap::new(),
        }
    }
    
    pub fn spawn(&mut self, command: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let child = Command::new(command).args(args).spawn()?;
        let pid = child.id();
        let monitor = ProcessMonitor::new(pid, format!("{} {}", command, args.join(" ")));
        
        self.processes.insert(pid, (child, monitor));
        Ok(pid)
    }
    
    pub fn kill(&mut self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        if let Some((child, _)) = self.processes.get_mut(&pid) {
            child.kill()?;
            self.processes.remove(&pid);
        }
        Ok(())
    }
    
    pub fn kill_all(&mut self) {
        for (_, (child, _)) in self.processes.iter_mut() {
            child.kill().ok();
        }
        self.processes.clear();
    }
    
    pub fn update_all(&mut self) {
        self.processes.retain(|_, (child, monitor)| {
            // 检查进程是否还在运行
            match child.try_wait() {
                Ok(None) => {
                    // 进程还在运行，更新状态
                    monitor.update_status();
                    true
                }
                _ => {
                    // 进程已退出
                    println!("⚠️  Process {} exited", monitor.pid());
                    false
                }
            }
        });
    }
    
    pub fn get_status(&self, pid: u32) -> Option<&ProcessMonitor> {
        self.processes.get(&pid).map(|(_, monitor)| monitor)
    }
    
    pub fn list_all(&self) -> Vec<&ProcessMonitor> {
        self.processes.values().map(|(_, monitor)| monitor).collect()
    }
    
    pub fn count(&self) -> usize {
        self.processes.len()
    }
}

// 使用示例
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut manager = ProcessManager::new();
    
    // 启动多个进程
    let pid1 = manager.spawn("sleep", &["10"])?;
    let pid2 = manager.spawn("sleep", &["20"])?;
    let pid3 = manager.spawn("sleep", &["30"])?;
    
    println!("启动了 {} 个进程", manager.count());
    
    // 监控循环
    for _ in 0..15 {
        manager.update_all();
        
        println!("\n━━━━━━━━━━━━━━━━━━━━━━━━━");
        println!("活动进程: {}", manager.count());
        
        for monitor in manager.list_all() {
            println!("  PID {}: {:?}, uptime {:?}", 
                monitor.pid(), 
                monitor.status(),
                monitor.uptime()
            );
        }
        
        std::thread::sleep(Duration::from_secs(1));
    }
    
    // 清理
    manager.kill_all();
    Ok(())
}
```

---

### 1.4 进程状态持久化

**状态记录器**:

```rust
use serde::{Serialize, Deserialize};
use std::fs;
use std::path::PathBuf;

#[derive(Serialize, Deserialize)]
pub struct ProcessRecord {
    pub pid: u32,
    pub command: String,
    pub start_time: String,
    pub end_time: Option<String>,
    pub exit_code: Option<i32>,
    pub status: String,
}

pub struct ProcessRecorder {
    records: Vec<ProcessRecord>,
    log_file: PathBuf,
}

impl ProcessRecorder {
    pub fn new(log_file: PathBuf) -> Self {
        let records = if log_file.exists() {
            let content = fs::read_to_string(&log_file).unwrap_or_default();
            serde_json::from_str(&content).unwrap_or_default()
        } else {
            Vec::new()
        };
        
        Self { records, log_file }
    }
    
    pub fn record_start(&mut self, pid: u32, command: String) {
        let record = ProcessRecord {
            pid,
            command,
            start_time: chrono::Local::now().to_rfc3339(),
            end_time: None,
            exit_code: None,
            status: "Running".to_string(),
        };
        
        self.records.push(record);
        self.save();
    }
    
    pub fn record_end(&mut self, pid: u32, exit_code: Option<i32>) {
        if let Some(record) = self.records.iter_mut().find(|r| r.pid == pid && r.end_time.is_none()) {
            record.end_time = Some(chrono::Local::now().to_rfc3339());
            record.exit_code = exit_code;
            record.status = "Exited".to_string();
            self.save();
        }
    }
    
    fn save(&self) {
        if let Ok(content) = serde_json::to_string_pretty(&self.records) {
            fs::write(&self.log_file, content).ok();
        }
    }
    
    pub fn get_history(&self, pid: u32) -> Vec<&ProcessRecord> {
        self.records.iter().filter(|r| r.pid == pid).collect()
    }
}
```

---

## 2. 资源使用监控

**使用 sysinfo**:

```rust
use sysinfo::{System, SystemExt, ProcessExt, Pid};

let mut sys = System::new_all();
sys.refresh_all();

if let Some(process) = sys.process(Pid::from(child.id() as usize)) {
    println!("CPU: {}%", process.cpu_usage());
    println!("内存: {} KB", process.memory());
    println!("虚拟内存: {} KB", process.virtual_memory());
}
```

**持续监控**:

```rust
use std::time::Duration;
use std::thread;

loop {
    sys.refresh_process(Pid::from(pid as usize));
    
    if let Some(process) = sys.process(Pid::from(pid as usize)) {
        println!("[{}] CPU: {}%, MEM: {} KB", 
            chrono::Local::now().format("%H:%M:%S"),
            process.cpu_usage(),
            process.memory()
        );
    }
    
    thread::sleep(Duration::from_secs(1));
}
```

---

## 3. 日志与调试

**捕获stderr**:

```rust
let output = Command::new("app")
    .stderr(Stdio::piped())
    .output()?;

let stderr = String::from_utf8_lossy(&output.stderr);
if !stderr.is_empty() {
    eprintln!("错误日志:\n{}", stderr);
}
```

**实时日志**:

```rust
use std::io::BufRead;

let mut child = Command::new("app")
    .stdout(Stdio::piped())
    .stderr(Stdio::piped())
    .spawn()?;

if let Some(stdout) = child.stdout.take() {
    let reader = BufReader::new(stdout);
    for line in reader.lines() {
        println!("[STDOUT] {}", line?);
    }
}
```

---

## 4. 实战案例

**进程监控器**:

```rust
pub struct ProcessWatcher {
    child: Child,
    monitor: ProcessMonitor,
}

impl ProcessWatcher {
    pub fn spawn(program: &str) -> Result<Self, std::io::Error> {
        let child = Command::new(program).spawn()?;
        let monitor = ProcessMonitor::new(child.id());
        
        Ok(Self { child, monitor })
    }
    
    pub fn status(&self) -> ProcessStatus {
        ProcessStatus {
            pid: self.monitor.pid,
            uptime: self.monitor.uptime(),
            running: matches!(self.child.try_wait(), Ok(None)),
        }
    }
}

pub struct ProcessStatus {
    pub pid: u32,
    pub uptime: Duration,
    pub running: bool,
}
```

---

**参考**: [性能优化参考](../tier_03_references/05_性能优化参考.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
