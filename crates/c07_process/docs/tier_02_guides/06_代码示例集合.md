# ğŸ”§ C07: è¿›ç¨‹å’Œç³»ç»Ÿç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C07 è¿›ç¨‹å’Œç³»ç»Ÿç¼–ç¨‹
> **ç›®æ ‡**: é€šè¿‡ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å­¦ä¹ è€…æ·±å…¥ç†è§£ Rust ç³»ç»Ÿç¼–ç¨‹å’Œè¿›ç¨‹ç®¡ç†ã€‚

---

## ç›®å½•

- [ğŸ”§ C07: è¿›ç¨‹å’Œç³»ç»Ÿç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ](#-c07-è¿›ç¨‹å’Œç³»ç»Ÿç¼–ç¨‹---ä»£ç ç¤ºä¾‹é›†åˆ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [ğŸ“‹ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
  - [ğŸ¯ ç¤ºä¾‹å¯¼èˆª](#-ç¤ºä¾‹å¯¼èˆª)
  - [ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹](#-tier-1-åŸºç¡€å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹1.1: å‘½ä»¤æ‰§è¡ŒåŸºç¡€](#ç¤ºä¾‹11-å‘½ä»¤æ‰§è¡ŒåŸºç¡€)
    - [ç¤ºä¾‹1.2: è¿›ç¨‹è¾“å…¥è¾“å‡º](#ç¤ºä¾‹12-è¿›ç¨‹è¾“å…¥è¾“å‡º)
    - [ç¤ºä¾‹1.3: ç¯å¢ƒå˜é‡](#ç¤ºä¾‹13-ç¯å¢ƒå˜é‡)
    - [ç¤ºä¾‹1.4: å·¥ä½œç›®å½•](#ç¤ºä¾‹14-å·¥ä½œç›®å½•)
  - [ğŸš€ Tier 2: å®è·µå±‚ç¤ºä¾‹](#-tier-2-å®è·µå±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹2.1: è¿›ç¨‹ç®¡é“](#ç¤ºä¾‹21-è¿›ç¨‹ç®¡é“)
    - [ç¤ºä¾‹2.2: ä¿¡å·å¤„ç†](#ç¤ºä¾‹22-ä¿¡å·å¤„ç†)
    - [ç¤ºä¾‹2.3: è¿›ç¨‹ç›‘æ§](#ç¤ºä¾‹23-è¿›ç¨‹ç›‘æ§)
    - [ç¤ºä¾‹2.4: ç³»ç»Ÿä¿¡æ¯](#ç¤ºä¾‹24-ç³»ç»Ÿä¿¡æ¯)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å­¦ä¹ è·¯å¾„å»ºè®®](#å­¦ä¹ è·¯å¾„å»ºè®®)
    - [æ ¸å¿ƒæ¦‚å¿µæ€»ç»“](#æ ¸å¿ƒæ¦‚å¿µæ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ä»£ç ç¤ºä¾‹é›†åˆ (Code Examples Collection)**:

- **å®šä¹‰**: æ”¶é›†å’Œç»„ç»‡çš„ä»£ç ç¤ºä¾‹é›†åˆï¼Œç”¨äºæ¼”ç¤ºè¿›ç¨‹ç®¡ç†å’Œç³»ç»Ÿç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µ
- **ç±»å‹**: ç¤ºä¾‹æ–‡æ¡£
- **èŒƒç•´**: ç³»ç»Ÿç¼–ç¨‹ã€è¿›ç¨‹ç®¡ç†
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: è¿›ç¨‹ç®¡ç†ã€ç³»ç»Ÿç¼–ç¨‹ã€å‘½ä»¤æ‰§è¡Œã€ä¿¡å·å¤„ç†

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å±‚æ¬¡æ€§**: ä»åŸºç¡€åˆ°é«˜çº§çš„ç¤ºä¾‹
- **å®Œæ•´æ€§**: è¦†ç›–æ ¸å¿ƒæ¦‚å¿µ
- **å®ç”¨æ€§**: æ¯ä¸ªç¤ºä¾‹éƒ½æœ‰è¯¦ç»†è§£é‡Š
- **å¯è¿è¡Œæ€§**: æ‰€æœ‰ç¤ºä¾‹éƒ½å¯ä»¥è¿è¡Œ

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ä»£ç ç¤ºä¾‹é›†åˆ --[contains]--> å¤šä¸ªä»£ç ç¤ºä¾‹
- å­¦ä¹ è·¯å¾„ --[uses]--> ä»£ç ç¤ºä¾‹é›†åˆ

**ä¾èµ–å…³ç³»**:

- ä»£ç ç¤ºä¾‹é›†åˆ --[depends-on]--> è¿›ç¨‹ç®¡ç†çŸ¥è¯†
- å­¦ä¹ å®è·µ --[depends-on]--> ä»£ç ç¤ºä¾‹é›†åˆ

### æ€ç»´å¯¼å›¾

```text
ä»£ç ç¤ºä¾‹é›†åˆ
â”‚
â”œâ”€â”€ Tier 1 åŸºç¡€å±‚
â”‚   â”œâ”€â”€ å‘½ä»¤æ‰§è¡ŒåŸºç¡€
â”‚   â”œâ”€â”€ è¿›ç¨‹è¾“å…¥è¾“å‡º
â”‚   â”œâ”€â”€ ç¯å¢ƒå˜é‡
â”‚   â””â”€â”€ å·¥ä½œç›®å½•
â””â”€â”€ Tier 2 å®è·µå±‚
    â”œâ”€â”€ è¿›ç¨‹ç®¡é“
    â”œâ”€â”€ ä¿¡å·å¤„ç†
    â”œâ”€â”€ è¿›ç¨‹ç›‘æ§
    â””â”€â”€ ç³»ç»Ÿä¿¡æ¯
```

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº† **8ä¸ªç²¾å¿ƒè®¾è®¡çš„ä»£ç ç¤ºä¾‹**ï¼Œè¦†ç›–äº† C07 æ¨¡å—çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä»åŸºç¡€åˆ°é«˜çº§ï¼Œæ¯ä¸ªç¤ºä¾‹éƒ½é…æœ‰è¯¦ç»†çš„è§£é‡Šå’Œè¿è¡Œç»“æœã€‚

**ç¤ºä¾‹åˆ†å¸ƒ**:

- **Tier 1 (åŸºç¡€å±‚)**: 4ä¸ªç¤ºä¾‹ - å‘½ä»¤æ‰§è¡Œã€I/Oã€ç¯å¢ƒå˜é‡ã€å·¥ä½œç›®å½•
- **Tier 2 (å®è·µå±‚)**: 4ä¸ªç¤ºä¾‹ - è¿›ç¨‹ç®¡é“ã€ä¿¡å·å¤„ç†ã€è¿›ç¨‹ç›‘æ§ã€ç³»ç»Ÿä¿¡æ¯

---

## ğŸ¯ ç¤ºä¾‹å¯¼èˆª

| #                  | ç¤ºä¾‹åç§°                             | æ ¸å¿ƒæ¦‚å¿µ     | éš¾åº¦   | é¢„è®¡å­¦ä¹ æ—¶é—´ |
| :--- | :--- | :--- | :--- | :--- || **Tier 1: åŸºç¡€å±‚** |                                      |              |        |              |
| 1.1                | [å‘½ä»¤æ‰§è¡ŒåŸºç¡€](#ç¤ºä¾‹11-å‘½ä»¤æ‰§è¡ŒåŸºç¡€) | Command      | â­     | 15åˆ†é’Ÿ       |
| 1.2                | [è¿›ç¨‹è¾“å…¥è¾“å‡º](#ç¤ºä¾‹12-è¿›ç¨‹è¾“å…¥è¾“å‡º) | stdin/stdout | â­â­   | 25åˆ†é’Ÿ       |
| 1.3                | [ç¯å¢ƒå˜é‡](#ç¤ºä¾‹13-ç¯å¢ƒå˜é‡)         | env          | â­     | 20åˆ†é’Ÿ       |
| 1.4                | [å·¥ä½œç›®å½•](#ç¤ºä¾‹14-å·¥ä½œç›®å½•)         | current_dir  | â­     | 15åˆ†é’Ÿ       |
| **Tier 2: å®è·µå±‚** |                                      |              |        |              |
| 2.1                | [è¿›ç¨‹ç®¡é“](#ç¤ºä¾‹21-è¿›ç¨‹ç®¡é“)         | pipe         | â­â­   | 30åˆ†é’Ÿ       |
| 2.2                | [ä¿¡å·å¤„ç†](#ç¤ºä¾‹22-ä¿¡å·å¤„ç†)         | signal       | â­â­â­ | 35åˆ†é’Ÿ       |
| 2.3                | [è¿›ç¨‹ç›‘æ§](#ç¤ºä¾‹23-è¿›ç¨‹ç›‘æ§)         | status       | â­â­   | 30åˆ†é’Ÿ       |
| 2.4                | [ç³»ç»Ÿä¿¡æ¯](#ç¤ºä¾‹24-ç³»ç»Ÿä¿¡æ¯)         | sysinfo      | â­â­   | 25åˆ†é’Ÿ       |

---

## ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹

### ç¤ºä¾‹1.1: å‘½ä»¤æ‰§è¡ŒåŸºç¡€

**ç›®æ ‡**: ç†è§£å¦‚ä½•æ‰§è¡Œå¤–éƒ¨å‘½ä»¤

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use std::process::Command;

fn main() {
    println!("===== åŸºç¡€å‘½ä»¤æ‰§è¡Œ =====\n");

    // æ‰§è¡Œç®€å•å‘½ä»¤
    let output = Command::new("echo")
        .arg("Hello, Process!")
        .output()
        .expect("Failed to execute command");

    println!("çŠ¶æ€: {}", output.status);
    println!("è¾“å‡º: {}", String::from_utf8_lossy(&output.stdout));

    println!("===== å¤šä¸ªå‚æ•° =====\n");

    let output = Command::new("ls")
        .args(&["-l", "-h"])
        .output()
        .expect("Failed to execute");

    println!("è¾“å‡º:\n{}", String::from_utf8_lossy(&output.stdout));

    println!("===== é”™è¯¯å¤„ç† =====\n");

    match Command::new("nonexistent")
        .output() {
        Ok(output) => {
            if !output.status.success() {
                eprintln!("å‘½ä»¤å¤±è´¥: {}", output.status);
                eprintln!("é”™è¯¯: {}", String::from_utf8_lossy(&output.stderr));
            }
        },
        Err(e) => {
            eprintln!("æ‰§è¡Œå¤±è´¥: {}", e);
        }
    }

    println!("\n===== æ£€æŸ¥é€€å‡ºç  =====\n");

    let status = Command::new("true")
        .status()
        .expect("Failed to execute");

    println!("é€€å‡ºç : {:?}", status.code());
    println!("æˆåŠŸ: {}", status.success());

    println!("\n===== spawn vs output =====\n");

    // spawn: ç«‹å³è¿”å›ï¼Œä¸ç­‰å¾…
    let mut child = Command::new("sleep")
        .arg("1")
        .spawn()
        .expect("Failed to spawn");

    println!("è¿›ç¨‹ ID: {}", child.id());
    println!("ç­‰å¾…è¿›ç¨‹...");

    let status = child.wait().expect("Failed to wait");
    println!("è¿›ç¨‹å®Œæˆ: {}", status);
}
```

**è¯´æ˜**:

- **Command**: å‘½ä»¤æ„å»ºå™¨
- **output**: æ‰§è¡Œå¹¶ç­‰å¾…å®Œæˆ
- **spawn**: å¯åŠ¨è¿›ç¨‹ä½†ä¸ç­‰å¾…
- **status**: é€€å‡ºçŠ¶æ€

**è¾“å‡º**:

```text
===== åŸºç¡€å‘½ä»¤æ‰§è¡Œ =====

çŠ¶æ€: exit status: 0
è¾“å‡º: Hello, Process!

===== å¤šä¸ªå‚æ•° =====

è¾“å‡º:
total 64
drwxr-xr-x  5 user  staff   160B Oct 25 10:00 .
drwxr-xr-x  3 user  staff    96B Oct 25 09:00 ..
...

===== é”™è¯¯å¤„ç† =====

æ‰§è¡Œå¤±è´¥: No such file or directory (os error 2)

===== æ£€æŸ¥é€€å‡ºç  =====

é€€å‡ºç : Some(0)
æˆåŠŸ: true

===== spawn vs output =====

è¿›ç¨‹ ID: 12345
ç­‰å¾…è¿›ç¨‹...
è¿›ç¨‹å®Œæˆ: exit status: 0
```

---

### ç¤ºä¾‹1.2: è¿›ç¨‹è¾“å…¥è¾“å‡º

**ç›®æ ‡**: æŒæ¡è¿›ç¨‹çš„ I/O é‡å®šå‘

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::process::{Command, Stdio};
use std::io::Write;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== æ•è·è¾“å‡º =====\n");

    let output = Command::new("echo")
        .arg("Hello World")
        .stdout(Stdio::piped())
        .output()?;

    println!("stdout: {}", String::from_utf8_lossy(&output.stdout));

    println!("===== æ•è·é”™è¯¯è¾“å‡º =====\n");

    let output = Command::new("ls")
        .arg("nonexistent")
        .stderr(Stdio::piped())
        .output()?;

    if !output.stderr.is_empty() {
        eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
    }

    println!("\n===== é‡å®šå‘åˆ°æ–‡ä»¶ =====\n");

    use std::fs::File;

    let file = File::create("output.txt")?;

    let status = Command::new("echo")
        .arg("Redirected to file")
        .stdout(Stdio::from(file))
        .status()?;

    println!("å†™å…¥æ–‡ä»¶å®Œæˆ: {}", status);

    // è¯»å–éªŒè¯
    let content = std::fs::read_to_string("output.txt")?;
    println!("æ–‡ä»¶å†…å®¹: {}", content);

    println!("===== è¾“å…¥é‡å®šå‘ =====\n");

    let mut child = Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    // å†™å…¥æ•°æ®åˆ°è¿›ç¨‹çš„ stdin
    if let Some(mut stdin) = child.stdin.take() {
        stdin.write_all(b"Hello from stdin!\n")?;
    }

    let output = child.wait_with_output()?;
    println!("cat è¾“å‡º: {}", String::from_utf8_lossy(&output.stdout));

    println!("===== å¿½ç•¥è¾“å‡º =====\n");

    let status = Command::new("echo")
        .arg("This will be ignored")
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()?;

    println!("æ‰§è¡Œå®Œæˆ (è¾“å‡ºå·²å¿½ç•¥): {}", status);

    // æ¸…ç†
    std::fs::remove_file("output.txt")?;

    Ok(())
}
```

**è¯´æ˜**:

- **Stdio::piped()**: åˆ›å»ºç®¡é“æ•è·è¾“å‡º
- **Stdio::null()**: ä¸¢å¼ƒè¾“å‡º
- **stdin.write**: å‘è¿›ç¨‹è¾“å…¥æ•°æ®
- **é‡å®šå‘**: å¯ä»¥é‡å®šå‘åˆ°æ–‡ä»¶

**è¾“å‡º**:

```text
===== æ•è·è¾“å‡º =====

stdout: Hello World

===== æ•è·é”™è¯¯è¾“å‡º =====

stderr: ls: cannot access 'nonexistent': No such file or directory

===== é‡å®šå‘åˆ°æ–‡ä»¶ =====

å†™å…¥æ–‡ä»¶å®Œæˆ: exit status: 0
æ–‡ä»¶å†…å®¹: Redirected to file

===== è¾“å…¥é‡å®šå‘ =====

cat è¾“å‡º: Hello from stdin!

===== å¿½ç•¥è¾“å‡º =====

æ‰§è¡Œå®Œæˆ (è¾“å‡ºå·²å¿½ç•¥): exit status: 0
```

---

### ç¤ºä¾‹1.3: ç¯å¢ƒå˜é‡

**ç›®æ ‡**: ç†è§£ç¯å¢ƒå˜é‡çš„è®¾ç½®å’Œä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use std::process::Command;
use std::env;

fn main() {
    println!("===== è¯»å–ç¯å¢ƒå˜é‡ =====\n");

    // è¯»å–å½“å‰è¿›ç¨‹çš„ç¯å¢ƒå˜é‡
    if let Ok(path) = env::var("PATH") {
        println!("PATH: {}", path);
    }

    if let Ok(home) = env::var("HOME") {
        println!("HOME: {}", home);
    }

    println!("\n===== è®¾ç½®ç¯å¢ƒå˜é‡ =====\n");

    // ä¸ºå½“å‰è¿›ç¨‹è®¾ç½®
    env::set_var("MY_VAR", "my_value");
    println!("MY_VAR = {}", env::var("MY_VAR").unwrap());

    println!("\n===== å­è¿›ç¨‹ç¯å¢ƒå˜é‡ =====\n");

    let output = Command::new("sh")
        .arg("-c")
        .arg("echo $CUSTOM_VAR")
        .env("CUSTOM_VAR", "custom_value")
        .output()
        .expect("Failed to execute");

    println!("å­è¿›ç¨‹è¾“å‡º: {}", String::from_utf8_lossy(&output.stdout));

    println!("===== æ¸…é™¤ç¯å¢ƒå˜é‡ =====\n");

    let output = Command::new("sh")
        .arg("-c")
        .arg("echo PATH=$PATH")
        .env_clear()  // æ¸…é™¤æ‰€æœ‰ç¯å¢ƒå˜é‡
        .env("PATH", "/usr/bin")  // åªè®¾ç½®éœ€è¦çš„
        .output()
        .expect("Failed to execute");

    println!("{}", String::from_utf8_lossy(&output.stdout));

    println!("===== ç¯å¢ƒå˜é‡åˆ—è¡¨ =====\n");

    let count = env::vars().count();
    println!("å½“å‰è¿›ç¨‹æœ‰ {} ä¸ªç¯å¢ƒå˜é‡", count);

    // æ˜¾ç¤ºå‰ 5 ä¸ª
    for (key, value) in env::vars().take(5) {
        println!("{} = {}", key, value);
    }

    println!("\n===== ä¸´æ—¶ç¯å¢ƒå˜é‡ =====\n");

    env::set_var("TEMP_VAR", "temp");
    println!("è®¾ç½®: TEMP_VAR = temp");

    env::remove_var("TEMP_VAR");
    println!("åˆ é™¤: TEMP_VAR");

    match env::var("TEMP_VAR") {
        Ok(value) => println!("TEMP_VAR = {}", value),
        Err(_) => println!("TEMP_VAR ä¸å­˜åœ¨"),
    }
}
```

**è¯´æ˜**:

- **env::var**: è¯»å–ç¯å¢ƒå˜é‡
- **env::set_var**: è®¾ç½®ç¯å¢ƒå˜é‡
- **Command::env**: ä¸ºå­è¿›ç¨‹è®¾ç½®ç¯å¢ƒå˜é‡
- **env_clear**: æ¸…é™¤æ‰€æœ‰ç¯å¢ƒå˜é‡

**è¾“å‡º**:

```text
===== è¯»å–ç¯å¢ƒå˜é‡ =====

PATH: /usr/local/bin:/usr/bin:/bin
HOME: /home/user

===== è®¾ç½®ç¯å¢ƒå˜é‡ =====

MY_VAR = my_value

===== å­è¿›ç¨‹ç¯å¢ƒå˜é‡ =====

å­è¿›ç¨‹è¾“å‡º: custom_value

===== æ¸…é™¤ç¯å¢ƒå˜é‡ =====

PATH=/usr/bin

===== ç¯å¢ƒå˜é‡åˆ—è¡¨ =====

å½“å‰è¿›ç¨‹æœ‰ 42 ä¸ªç¯å¢ƒå˜é‡
SHELL = /bin/bash
USER = user
PATH = /usr/local/bin:/usr/bin
HOME = /home/user
LANG = en_US.UTF-8

===== ä¸´æ—¶ç¯å¢ƒå˜é‡ =====

è®¾ç½®: TEMP_VAR = temp
åˆ é™¤: TEMP_VAR
TEMP_VAR ä¸å­˜åœ¨
```

---

### ç¤ºä¾‹1.4: å·¥ä½œç›®å½•

**ç›®æ ‡**: ç†è§£å·¥ä½œç›®å½•çš„ç®¡ç†

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use std::process::Command;
use std::env;
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== å½“å‰å·¥ä½œç›®å½• =====\n");

    let current_dir = env::current_dir()?;
    println!("å½“å‰ç›®å½•: {:?}", current_dir);

    println!("\n===== æ”¹å˜å·¥ä½œç›®å½• =====\n");

    // åˆ›å»ºæµ‹è¯•ç›®å½•
    fs::create_dir_all("test_dir")?;

    env::set_current_dir("test_dir")?;
    println!("æ”¹å˜åˆ°: {:?}", env::current_dir()?);

    // è¿”å›åŸç›®å½•
    env::set_current_dir("..")?;
    println!("è¿”å›åˆ°: {:?}", env::current_dir()?);

    println!("\n===== å­è¿›ç¨‹å·¥ä½œç›®å½• =====\n");

    fs::create_dir_all("sub_dir")?;

    let output = Command::new("pwd")
        .current_dir("sub_dir")
        .output()?;

    println!("å­è¿›ç¨‹å·¥ä½œç›®å½•: {}", String::from_utf8_lossy(&output.stdout));

    println!("å½“å‰è¿›ç¨‹ç›®å½•ä¸å˜: {:?}", env::current_dir()?);

    println!("\n===== ç›¸å¯¹è·¯å¾„ vs ç»å¯¹è·¯å¾„ =====\n");

    // ç›¸å¯¹è·¯å¾„
    let output = Command::new("ls")
        .arg(".")
        .current_dir("sub_dir")
        .output()?;

    println!("ç›¸å¯¹è·¯å¾„ ls .: {}", String::from_utf8_lossy(&output.stdout));

    // ç»å¯¹è·¯å¾„
    let abs_path = env::current_dir()?.join("sub_dir");
    println!("ç»å¯¹è·¯å¾„: {:?}", abs_path);

    println!("\n===== è·¯å¾„è§„èŒƒåŒ– =====\n");

    let path = env::current_dir()?.join("./test_dir/../sub_dir");
    println!("åŸå§‹è·¯å¾„: {:?}", path);

    let canonical = fs::canonicalize(path)?;
    println!("è§„èŒƒåŒ–è·¯å¾„: {:?}", canonical);

    // æ¸…ç†
    fs::remove_dir_all("test_dir")?;
    fs::remove_dir_all("sub_dir")?;

    Ok(())
}
```

**è¯´æ˜**:

- **current_dir**: è·å–å½“å‰å·¥ä½œç›®å½•
- **set_current_dir**: æ”¹å˜å½“å‰ç›®å½•
- **Command::current_dir**: è®¾ç½®å­è¿›ç¨‹çš„å·¥ä½œç›®å½•
- **canonicalize**: è·å–è§„èŒƒåŒ–çš„ç»å¯¹è·¯å¾„

**è¾“å‡º**:

```text
===== å½“å‰å·¥ä½œç›®å½• =====

å½“å‰ç›®å½•: "/home/user/project"

===== æ”¹å˜å·¥ä½œç›®å½• =====

æ”¹å˜åˆ°: "/home/user/project/test_dir"
è¿”å›åˆ°: "/home/user/project"

===== å­è¿›ç¨‹å·¥ä½œç›®å½• =====

å­è¿›ç¨‹å·¥ä½œç›®å½•: /home/user/project/sub_dir

å½“å‰è¿›ç¨‹ç›®å½•ä¸å˜: "/home/user/project"

===== ç›¸å¯¹è·¯å¾„ vs ç»å¯¹è·¯å¾„ =====

ç›¸å¯¹è·¯å¾„ ls .: .
..
ç»å¯¹è·¯å¾„: "/home/user/project/sub_dir"

===== è·¯å¾„è§„èŒƒåŒ– =====

åŸå§‹è·¯å¾„: "/home/user/project/./test_dir/../sub_dir"
è§„èŒƒåŒ–è·¯å¾„: "/home/user/project/sub_dir"
```

---

## ğŸš€ Tier 2: å®è·µå±‚ç¤ºä¾‹

### ç¤ºä¾‹2.1: è¿›ç¨‹ç®¡é“

**ç›®æ ‡**: ç†è§£å¦‚ä½•é€šè¿‡ç®¡é“è¿æ¥å¤šä¸ªè¿›ç¨‹

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::process::{Command, Stdio};
use std::io::Write;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== åŸºç¡€ç®¡é“ =====\n");

    // æ¨¡æ‹Ÿ shell: echo "hello" | tr '[:lower:]' '[:upper:]'
    let echo_child = Command::new("echo")
        .arg("hello world")
        .stdout(Stdio::piped())
        .spawn()?;

    let echo_output = echo_child.stdout.expect("Failed to capture stdout");

    let tr_output = Command::new("tr")
        .arg("[:lower:]")
        .arg("[:upper:]")
        .stdin(Stdio::from(echo_output))
        .output()?;

    println!("ç®¡é“è¾“å‡º: {}", String::from_utf8_lossy(&tr_output.stdout));

    println!("===== å¤šçº§ç®¡é“ =====\n");

    // æ¨¡æ‹Ÿ: ps aux | grep rust | wc -l
    let ps = Command::new("ps")
        .arg("aux")
        .stdout(Stdio::piped())
        .spawn()?;

    let ps_stdout = ps.stdout.expect("Failed to capture ps stdout");

    let grep = Command::new("grep")
        .arg("rust")
        .stdin(Stdio::from(ps_stdout))
        .stdout(Stdio::piped())
        .spawn()?;

    let grep_stdout = grep.stdout.expect("Failed to capture grep stdout");

    let wc_output = Command::new("wc")
        .arg("-l")
        .stdin(Stdio::from(grep_stdout))
        .output()?;

    println!("åŒ…å« 'rust' çš„è¿›ç¨‹æ•°: {}",
             String::from_utf8_lossy(&wc_output.stdout).trim());

    println!("\n===== æ‰‹åŠ¨ç®¡é“ =====\n");

    use std::process::{ChildStdout, ChildStdin};
    use std::io::{BufRead, BufReader};

    let mut cat = Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    // å†™å…¥æ•°æ®
    if let Some(mut stdin) = cat.stdin.take() {
        writeln!(stdin, "Line 1")?;
        writeln!(stdin, "Line 2")?;
        writeln!(stdin, "Line 3")?;
    }

    let output = cat.wait_with_output()?;
    println!("cat è¾“å‡º:\n{}", String::from_utf8_lossy(&output.stdout));

    println!("===== åŒå‘é€šä¿¡ =====\n");

    let mut bc = Command::new("bc")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    // å‘é€è®¡ç®—è¡¨è¾¾å¼
    if let Some(mut stdin) = bc.stdin.take() {
        writeln!(stdin, "2 + 2")?;
        writeln!(stdin, "10 * 5")?;
        writeln!(stdin, "quit")?;
    }

    let output = bc.wait_with_output()?;
    println!("è®¡ç®—ç»“æœ:\n{}", String::from_utf8_lossy(&output.stdout));

    println!("===== å¹¶è¡Œç®¡é“ =====\n");

    use std::thread;

    let mut children = vec![];

    for i in 1..=3 {
        let child = Command::new("echo")
            .arg(format!("Task {}", i))
            .stdout(Stdio::piped())
            .spawn()?;
        children.push(child);
    }

    for mut child in children {
        let output = child.wait_with_output()?;
        println!("è¾“å‡º: {}", String::from_utf8_lossy(&output.stdout).trim());
    }

    Ok(())
}
```

**è¯´æ˜**:

- **ç®¡é“è¿æ¥**: å°†ä¸€ä¸ªè¿›ç¨‹çš„è¾“å‡ºä½œä¸ºå¦ä¸€ä¸ªè¿›ç¨‹çš„è¾“å…¥
- **å¤šçº§ç®¡é“**: è¿æ¥å¤šä¸ªè¿›ç¨‹å½¢æˆå¤„ç†é“¾
- **åŒå‘é€šä¿¡**: åŒæ—¶æ§åˆ¶è¿›ç¨‹çš„è¾“å…¥å’Œè¾“å‡º
- **å¹¶è¡Œå¤„ç†**: åŒæ—¶è¿è¡Œå¤šä¸ªå­è¿›ç¨‹

**è¾“å‡º**:

```text
===== åŸºç¡€ç®¡é“ =====

ç®¡é“è¾“å‡º: HELLO WORLD

===== å¤šçº§ç®¡é“ =====

åŒ…å« 'rust' çš„è¿›ç¨‹æ•°: 5

===== æ‰‹åŠ¨ç®¡é“ =====

cat è¾“å‡º:
Line 1
Line 2
Line 3

===== åŒå‘é€šä¿¡ =====

è®¡ç®—ç»“æœ:
4
50

===== å¹¶è¡Œç®¡é“ =====

è¾“å‡º: Task 1
è¾“å‡º: Task 2
è¾“å‡º: Task 3
```

---

### ç¤ºä¾‹2.2: ä¿¡å·å¤„ç†

**ç›®æ ‡**: ç†è§£å¦‚ä½•å¤„ç†ç³»ç»Ÿä¿¡å·

**éš¾åº¦**: â­â­â­

**ä¾èµ–**: éœ€è¦æ·»åŠ åˆ° `Cargo.toml`:

```toml
[dependencies]
signal-hook = "0.3"
```

**ä»£ç **:

```rust
use std::process::{Command, Child};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;
use std::thread;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== åŸºç¡€ä¿¡å·å¤„ç† =====\n");

    // æ•è· Ctrl+C (SIGINT)
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    ctrlc::set_handler(move || {
        println!("\næ”¶åˆ° SIGINT (Ctrl+C)");
        r.store(false, Ordering::SeqCst);
    })?;

    println!("ç¨‹åºè¿è¡Œä¸­... (æŒ‰ Ctrl+C é€€å‡º)");

    let mut count = 0;
    while running.load(Ordering::SeqCst) && count < 5 {
        println!("å·¥ä½œä¸­... {}", count);
        thread::sleep(Duration::from_secs(1));
        count += 1;
    }

    println!("\nç¨‹åºæ­£å¸¸é€€å‡º");

    println!("\n===== å­è¿›ç¨‹ç»ˆæ­¢ =====\n");

    // å¯åŠ¨ä¸€ä¸ªé•¿æ—¶é—´è¿è¡Œçš„è¿›ç¨‹
    let mut child = Command::new("sleep")
        .arg("30")
        .spawn()?;

    println!("å¯åŠ¨å­è¿›ç¨‹ (PID: {})", child.id());

    // ç­‰å¾…ä¸€ç§’åç»ˆæ­¢
    thread::sleep(Duration::from_secs(1));

    println!("å‘é€ SIGTERM...");
    child.kill()?;  // å‘é€ SIGKILL

    let status = child.wait()?;
    println!("å­è¿›ç¨‹é€€å‡º: {}", status);

    println!("\n===== è¶…æ—¶å¤„ç† =====\n");

    let mut child = Command::new("sleep")
        .arg("10")
        .spawn()?;

    println!("å¯åŠ¨å­è¿›ç¨‹ï¼Œè®¾ç½® 2 ç§’è¶…æ—¶");

    use std::time::Instant;
    let start = Instant::now();
    let timeout = Duration::from_secs(2);

    loop {
        match child.try_wait()? {
            Some(status) => {
                println!("è¿›ç¨‹å®Œæˆ: {}", status);
                break;
            }
            None => {
                if start.elapsed() >= timeout {
                    println!("è¶…æ—¶! ç»ˆæ­¢è¿›ç¨‹...");
                    child.kill()?;
                    child.wait()?;
                    break;
                }
                thread::sleep(Duration::from_millis(100));
            }
        }
    }

    println!("\n===== ä¿¡å·è½¬å‘ =====\n");

    let mut child = Command::new("bash")
        .arg("-c")
        .arg("trap 'echo Received SIGTERM' TERM; sleep 5")
        .spawn()?;

    println!("å¯åŠ¨ bash å­è¿›ç¨‹");
    thread::sleep(Duration::from_millis(500));

    // åœ¨ Unix ä¸Šå¯ä»¥å‘é€ç‰¹å®šä¿¡å·
    #[cfg(unix)]
    {
        use std::process;
        println!("å‘é€ SIGTERM åˆ°å­è¿›ç¨‹");

        unsafe {
            libc::kill(child.id() as i32, libc::SIGTERM);
        }

        thread::sleep(Duration::from_secs(1));
    }

    child.kill()?;
    child.wait()?;

    println!("\n===== ä¼˜é›…é€€å‡º =====\n");

    struct GracefulProcess {
        child: Option<Child>,
    }

    impl Drop for GracefulProcess {
        fn drop(&mut self) {
            if let Some(mut child) = self.child.take() {
                println!("æ¸…ç†: ç»ˆæ­¢å­è¿›ç¨‹ {}", child.id());
                let _ = child.kill();
                let _ = child.wait();
            }
        }
    }

    let _process = GracefulProcess {
        child: Some(Command::new("sleep").arg("100").spawn()?),
    };

    println!("åˆ›å»ºå®ˆæŠ¤è¿›ç¨‹");
    thread::sleep(Duration::from_secs(1));
    println!("é€€å‡ºä½œç”¨åŸŸï¼Œè‡ªåŠ¨æ¸…ç†");
    // _process åœ¨è¿™é‡Œè¢« dropï¼Œè‡ªåŠ¨ç»ˆæ­¢å­è¿›ç¨‹

    Ok(())
}
```

**è¯´æ˜**:

- **SIGINT**: Ctrl+C ä¸­æ–­ä¿¡å·
- **SIGTERM**: è¯·æ±‚ç»ˆæ­¢ä¿¡å·
- **SIGKILL**: å¼ºåˆ¶ç»ˆæ­¢ä¿¡å·
- **kill()**: ç»ˆæ­¢å­è¿›ç¨‹
- **ä¼˜é›…é€€å‡º**: ä½¿ç”¨ Drop trait è‡ªåŠ¨æ¸…ç†

**è¾“å‡º**:

```text
===== åŸºç¡€ä¿¡å·å¤„ç† =====

ç¨‹åºè¿è¡Œä¸­... (æŒ‰ Ctrl+C é€€å‡º)
å·¥ä½œä¸­... 0
å·¥ä½œä¸­... 1
^C
æ”¶åˆ° SIGINT (Ctrl+C)

ç¨‹åºæ­£å¸¸é€€å‡º

===== å­è¿›ç¨‹ç»ˆæ­¢ =====

å¯åŠ¨å­è¿›ç¨‹ (PID: 12345)
å‘é€ SIGTERM...
å­è¿›ç¨‹é€€å‡º: signal: 9 (SIGKILL)

===== è¶…æ—¶å¤„ç† =====

å¯åŠ¨å­è¿›ç¨‹ï¼Œè®¾ç½® 2 ç§’è¶…æ—¶
è¶…æ—¶! ç»ˆæ­¢è¿›ç¨‹...

===== ä¿¡å·è½¬å‘ =====

å¯åŠ¨ bash å­è¿›ç¨‹
å‘é€ SIGTERM åˆ°å­è¿›ç¨‹

===== ä¼˜é›…é€€å‡º =====

åˆ›å»ºå®ˆæŠ¤è¿›ç¨‹
é€€å‡ºä½œç”¨åŸŸï¼Œè‡ªåŠ¨æ¸…ç†
æ¸…ç†: ç»ˆæ­¢å­è¿›ç¨‹ 54321
```

---

### ç¤ºä¾‹2.3: è¿›ç¨‹ç›‘æ§

**ç›®æ ‡**: ç›‘æ§è¿›ç¨‹çŠ¶æ€å’Œèµ„æºä½¿ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use std::thread;
use std::io::Read;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== è¿›ç¨‹çŠ¶æ€ç›‘æ§ =====\n");

    let mut child = Command::new("sleep")
        .arg("3")
        .spawn()?;

    let pid = child.id();
    println!("å¯åŠ¨è¿›ç¨‹ (PID: {})", pid);

    let start = Instant::now();

    loop {
        match child.try_wait()? {
            Some(status) => {
                println!("\nè¿›ç¨‹å®Œæˆ:");
                println!("  é€€å‡ºçŠ¶æ€: {}", status);
                println!("  è¿è¡Œæ—¶é—´: {:?}", start.elapsed());
                println!("  æˆåŠŸ: {}", status.success());
                if let Some(code) = status.code() {
                    println!("  é€€å‡ºç : {}", code);
                }
                break;
            }
            None => {
                print!(".");
                std::io::Write::flush(&mut std::io::stdout())?;
                thread::sleep(Duration::from_millis(500));
            }
        }
    }

    println!("\n\n===== è¾“å‡ºæµç›‘æ§ =====\n");

    let mut child = Command::new("bash")
        .arg("-c")
        .arg("for i in {1..5}; do echo Line $i; sleep 1; done")
        .stdout(Stdio::piped())
        .spawn()?;

    println!("å®æ—¶è¯»å–è¾“å‡º:");

    if let Some(mut stdout) = child.stdout.take() {
        use std::io::BufReader;
        use std::io::BufRead;

        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            println!("  > {}", line?);
        }
    }

    let status = child.wait()?;
    println!("è¿›ç¨‹å®Œæˆ: {}", status);

    println!("\n===== å¤šè¿›ç¨‹ç›‘æ§ =====\n");

    let mut children = vec![];

    for i in 1..=3 {
        let child = Command::new("sleep")
            .arg(format!("{}", i))
            .spawn()?;
        println!("å¯åŠ¨è¿›ç¨‹ {} (PID: {})", i, child.id());
        children.push((i, child, Instant::now()));
    }

    println!("\nç›‘æ§è¿›ç¨‹:");

    while !children.is_empty() {
        children.retain_mut(|(id, child, start)| {
            match child.try_wait() {
                Ok(Some(status)) => {
                    println!("  è¿›ç¨‹ {} å®Œæˆ (ç”¨æ—¶: {:?})", id, start.elapsed());
                    false  // ç§»é™¤å·²å®Œæˆçš„è¿›ç¨‹
                }
                Ok(None) => true,  // ç»§ç»­ä¿ç•™è¿è¡Œä¸­çš„è¿›ç¨‹
                Err(e) => {
                    eprintln!("  è¿›ç¨‹ {} é”™è¯¯: {}", id, e);
                    false
                }
            }
        });

        if !children.is_empty() {
            thread::sleep(Duration::from_millis(100));
        }
    }

    println!("æ‰€æœ‰è¿›ç¨‹å®Œæˆ");

    println!("\n===== è¿›ç¨‹ç»Ÿè®¡ =====\n");

    let iterations = 5;
    let mut total_time = Duration::from_secs(0);
    let mut success_count = 0;

    for i in 1..=iterations {
        let start = Instant::now();

        let status = Command::new("echo")
            .arg(format!("Test {}", i))
            .status()?;

        let elapsed = start.elapsed();
        total_time += elapsed;

        if status.success() {
            success_count += 1;
        }

        println!("è¿­ä»£ {}: {:?} - {}", i, elapsed,
                 if status.success() { "âœ“" } else { "âœ—" });
    }

    println!("\nç»Ÿè®¡:");
    println!("  æ€»æ¬¡æ•°: {}", iterations);
    println!("  æˆåŠŸ: {}", success_count);
    println!("  å¤±è´¥: {}", iterations - success_count);
    println!("  æ€»æ—¶é—´: {:?}", total_time);
    println!("  å¹³å‡æ—¶é—´: {:?}", total_time / iterations);

    println!("\n===== èµ„æºé™åˆ¶ç›‘æ§ =====\n");

    // ç›‘æ§å†…å­˜å ç”¨è¾ƒå¤§çš„è¿›ç¨‹
    let start = Instant::now();

    let output = Command::new("bash")
        .arg("-c")
        .arg("dd if=/dev/zero of=/dev/null bs=1M count=100 2>&1")
        .output()?;

    let elapsed = start.elapsed();

    println!("å‘½ä»¤æ‰§è¡Œå®Œæˆ:");
    println!("  è€—æ—¶: {:?}", elapsed);
    println!("  è¾“å‡ºé•¿åº¦: {} bytes", output.stdout.len() + output.stderr.len());
    println!("  æˆåŠŸ: {}", output.status.success());

    if !output.stderr.is_empty() {
        println!("  ä¿¡æ¯: {}", String::from_utf8_lossy(&output.stderr));
    }

    Ok(())
}
```

**è¯´æ˜**:

- **try_wait**: éé˜»å¡æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
- **å®æ—¶ç›‘æ§**: è¯»å–è¿›ç¨‹è¾“å‡ºæµ
- **å¤šè¿›ç¨‹ç®¡ç†**: åŒæ—¶ç›‘æ§å¤šä¸ªå­è¿›ç¨‹
- **æ€§èƒ½ç»Ÿè®¡**: æ”¶é›†æ‰§è¡Œæ—¶é—´å’ŒæˆåŠŸç‡

**è¾“å‡º**:

```text
===== è¿›ç¨‹çŠ¶æ€ç›‘æ§ =====

å¯åŠ¨è¿›ç¨‹ (PID: 12345)
......

è¿›ç¨‹å®Œæˆ:
  é€€å‡ºçŠ¶æ€: exit status: 0
  è¿è¡Œæ—¶é—´: 3.002s
  æˆåŠŸ: true
  é€€å‡ºç : 0

===== è¾“å‡ºæµç›‘æ§ =====

å®æ—¶è¯»å–è¾“å‡º:
  > Line 1
  > Line 2
  > Line 3
  > Line 4
  > Line 5
è¿›ç¨‹å®Œæˆ: exit status: 0

===== å¤šè¿›ç¨‹ç›‘æ§ =====

å¯åŠ¨è¿›ç¨‹ 1 (PID: 12346)
å¯åŠ¨è¿›ç¨‹ 2 (PID: 12347)
å¯åŠ¨è¿›ç¨‹ 3 (PID: 12348)

ç›‘æ§è¿›ç¨‹:
  è¿›ç¨‹ 1 å®Œæˆ (ç”¨æ—¶: 1.001s)
  è¿›ç¨‹ 2 å®Œæˆ (ç”¨æ—¶: 2.002s)
  è¿›ç¨‹ 3 å®Œæˆ (ç”¨æ—¶: 3.003s)
æ‰€æœ‰è¿›ç¨‹å®Œæˆ

===== è¿›ç¨‹ç»Ÿè®¡ =====

è¿­ä»£ 1: 8.2ms - âœ“
è¿­ä»£ 2: 7.9ms - âœ“
è¿­ä»£ 3: 8.1ms - âœ“
è¿­ä»£ 4: 8.0ms - âœ“
è¿­ä»£ 5: 8.3ms - âœ“

ç»Ÿè®¡:
  æ€»æ¬¡æ•°: 5
  æˆåŠŸ: 5
  å¤±è´¥: 0
  æ€»æ—¶é—´: 40.5ms
  å¹³å‡æ—¶é—´: 8.1ms

===== èµ„æºé™åˆ¶ç›‘æ§ =====

å‘½ä»¤æ‰§è¡Œå®Œæˆ:
  è€—æ—¶: 156.3ms
  è¾“å‡ºé•¿åº¦: 95 bytes
  æˆåŠŸ: true
  ä¿¡æ¯: 100+0 records in
100+0 records out
104857600 bytes transferred in 0.156 secs (671281024 bytes/sec)
```

---

### ç¤ºä¾‹2.4: ç³»ç»Ÿä¿¡æ¯

**ç›®æ ‡**: è·å–ç³»ç»Ÿå’Œè¿›ç¨‹ä¿¡æ¯

**éš¾åº¦**: â­â­

**ä¾èµ–**: éœ€è¦æ·»åŠ åˆ° `Cargo.toml`:

```toml
[dependencies]
sysinfo = "0.30"
```

**ä»£ç **:

```rust
use sysinfo::{System, SystemExt, ProcessExt, Pid};
use std::process::Command;

fn main() {
    println!("===== ç³»ç»ŸåŸºç¡€ä¿¡æ¯ =====\n");

    let mut sys = System::new_all();
    sys.refresh_all();

    println!("ç³»ç»Ÿä¿¡æ¯:");
    println!("  æ“ä½œç³»ç»Ÿ: {} {}",
             System::name().unwrap_or_default(),
             System::os_version().unwrap_or_default());
    println!("  å†…æ ¸ç‰ˆæœ¬: {}", System::kernel_version().unwrap_or_default());
    println!("  ä¸»æœºå: {}", System::host_name().unwrap_or_default());

    println!("\nç¡¬ä»¶ä¿¡æ¯:");
    println!("  CPU æ ¸å¿ƒæ•°: {}", sys.cpus().len());
    println!("  æ€»å†…å­˜: {} MB", sys.total_memory() / 1024 / 1024);
    println!("  å·²ç”¨å†…å­˜: {} MB", sys.used_memory() / 1024 / 1024);
    println!("  å¯ç”¨å†…å­˜: {} MB", sys.available_memory() / 1024 / 1024);
    println!("  æ€»äº¤æ¢ç©ºé—´: {} MB", sys.total_swap() / 1024 / 1024);
    println!("  å·²ç”¨äº¤æ¢: {} MB", sys.used_swap() / 1024 / 1024);

    println!("\n===== CPU ä¿¡æ¯ =====\n");

    for (i, cpu) in sys.cpus().iter().enumerate() {
        println!("CPU {}:", i);
        println!("  åç§°: {}", cpu.name());
        println!("  ä½¿ç”¨ç‡: {:.2}%", cpu.cpu_usage());
        println!("  é¢‘ç‡: {} MHz", cpu.frequency());
    }

    println!("\n===== å½“å‰è¿›ç¨‹ä¿¡æ¯ =====\n");

    let pid = std::process::id();
    println!("å½“å‰è¿›ç¨‹ PID: {}", pid);

    sys.refresh_process(Pid::from(pid as usize));

    if let Some(process) = sys.process(Pid::from(pid as usize)) {
        println!("è¿›ç¨‹è¯¦æƒ…:");
        println!("  åç§°: {}", process.name());
        println!("  CPU ä½¿ç”¨: {:.2}%", process.cpu_usage());
        println!("  å†…å­˜ä½¿ç”¨: {} KB", process.memory());
        println!("  è™šæ‹Ÿå†…å­˜: {} KB", process.virtual_memory());
        println!("  çˆ¶è¿›ç¨‹ PID: {:?}", process.parent());
        println!("  å¯åŠ¨æ—¶é—´: {} ç§’", process.start_time());
        println!("  è¿è¡Œæ—¶é—´: {} ç§’", process.run_time());
    }

    println!("\n===== è¿›ç¨‹åˆ—è¡¨ =====\n");

    let mut rust_processes = vec![];

    for (pid, process) in sys.processes() {
        let name = process.name().to_lowercase();
        if name.contains("rust") || name.contains("cargo") {
            rust_processes.push((pid, process));
        }
    }

    println!("å‘ç° {} ä¸ª Rust ç›¸å…³è¿›ç¨‹:\n", rust_processes.len());

    for (pid, process) in rust_processes.iter().take(5) {
        println!("PID {}: {}", pid, process.name());
        println!("  CPU: {:.2}%", process.cpu_usage());
        println!("  å†…å­˜: {} MB", process.memory() / 1024);
        println!("  çŠ¶æ€: {:?}", process.status());
        println!();
    }

    println!("===== ç£ç›˜ä¿¡æ¯ =====\n");

    let disks = sysinfo::Disks::new_with_refreshed_list();

    for disk in disks.list() {
        println!("ç£ç›˜: {:?}", disk.name());
        println!("  æŒ‚è½½ç‚¹: {:?}", disk.mount_point());
        println!("  æ–‡ä»¶ç³»ç»Ÿ: {:?}", disk.file_system());
        println!("  æ€»ç©ºé—´: {} GB", disk.total_space() / 1024 / 1024 / 1024);
        println!("  å¯ç”¨ç©ºé—´: {} GB", disk.available_space() / 1024 / 1024 / 1024);
        println!();
    }

    println!("===== ç½‘ç»œæ¥å£ =====\n");

    let networks = sysinfo::Networks::new_with_refreshed_list();

    for (interface_name, network) in networks.list() {
        println!("æ¥å£: {}", interface_name);
        println!("  æ¥æ”¶: {} bytes", network.received());
        println!("  å‘é€: {} bytes", network.transmitted());
        println!("  æ€»æ¥æ”¶: {} MB", network.total_received() / 1024 / 1024);
        println!("  æ€»å‘é€: {} MB", network.total_transmitted() / 1024 / 1024);
        println!();
    }

    println!("===== ç³»ç»Ÿè´Ÿè½½ =====\n");

    use std::thread;
    use std::time::Duration;

    sys.refresh_cpu();
    thread::sleep(Duration::from_millis(1000));
    sys.refresh_cpu();

    let global_cpu = sys.global_cpu_info();
    println!("å…¨å±€ CPU ä½¿ç”¨ç‡: {:.2}%", global_cpu.cpu_usage());

    println!("\nå„æ ¸å¿ƒä½¿ç”¨ç‡:");
    for (i, cpu) in sys.cpus().iter().enumerate() {
        println!("  CPU {}: {:.2}%", i, cpu.cpu_usage());
    }

    println!("\n===== è¿›ç¨‹ç›‘æ§ç¤ºä¾‹ =====\n");

    // å¯åŠ¨ä¸€ä¸ªå­è¿›ç¨‹å¹¶ç›‘æ§å®ƒ
    let mut child = Command::new("sleep")
        .arg("2")
        .spawn()
        .expect("Failed to spawn");

    let child_pid = Pid::from(child.id() as usize);
    println!("å¯åŠ¨å­è¿›ç¨‹ PID: {}", child.id());

    for i in 1..=3 {
        thread::sleep(Duration::from_millis(500));
        sys.refresh_process(child_pid);

        if let Some(process) = sys.process(child_pid) {
            println!("æ£€æŸ¥ç‚¹ {}:", i);
            println!("  çŠ¶æ€: {:?}", process.status());
            println!("  å†…å­˜: {} KB", process.memory());
            println!("  CPU: {:.2}%", process.cpu_usage());
        }
    }

    child.wait().expect("Failed to wait");
    println!("\nå­è¿›ç¨‹å®Œæˆ");
}
```

**è¯´æ˜**:

- **System**: ç³»ç»Ÿä¿¡æ¯æŸ¥è¯¢
- **Process**: è¿›ç¨‹ä¿¡æ¯æŸ¥è¯¢
- **CPU ç›‘æ§**: CPU ä½¿ç”¨ç‡ç»Ÿè®¡
- **å†…å­˜ç›‘æ§**: å†…å­˜ä½¿ç”¨æƒ…å†µ
- **ç£ç›˜å’Œç½‘ç»œ**: ç³»ç»Ÿèµ„æºä¿¡æ¯

**è¾“å‡º**:

```text
===== ç³»ç»ŸåŸºç¡€ä¿¡æ¯ =====

ç³»ç»Ÿä¿¡æ¯:
  æ“ä½œç³»ç»Ÿ: Linux 6.5.0
  å†…æ ¸ç‰ˆæœ¬: 6.5.0-14-generic
  ä¸»æœºå: rust-dev

ç¡¬ä»¶ä¿¡æ¯:
  CPU æ ¸å¿ƒæ•°: 8
  æ€»å†…å­˜: 16384 MB
  å·²ç”¨å†…å­˜: 8192 MB
  å¯ç”¨å†…å­˜: 8192 MB
  æ€»äº¤æ¢ç©ºé—´: 4096 MB
  å·²ç”¨äº¤æ¢: 512 MB

===== CPU ä¿¡æ¯ =====

CPU 0:
  åç§°: Intel(R) Core(TM) i7-9750H
  ä½¿ç”¨ç‡: 12.50%
  é¢‘ç‡: 2600 MHz
CPU 1:
  åç§°: Intel(R) Core(TM) i7-9750H
  ä½¿ç”¨ç‡: 8.30%
  é¢‘ç‡: 2600 MHz
...

===== å½“å‰è¿›ç¨‹ä¿¡æ¯ =====

å½“å‰è¿›ç¨‹ PID: 12345
è¿›ç¨‹è¯¦æƒ…:
  åç§°: example
  CPU ä½¿ç”¨: 0.50%
  å†…å­˜ä½¿ç”¨: 2048 KB
  è™šæ‹Ÿå†…å­˜: 10240 KB
  çˆ¶è¿›ç¨‹ PID: Some(12000)
  å¯åŠ¨æ—¶é—´: 1698300000 ç§’
  è¿è¡Œæ—¶é—´: 2 ç§’

===== è¿›ç¨‹åˆ—è¡¨ =====

å‘ç° 3 ä¸ª Rust ç›¸å…³è¿›ç¨‹:

PID 12345: cargo
  CPU: 0.20%
  å†…å­˜: 50 MB
  çŠ¶æ€: Run

PID 12346: rustc
  CPU: 95.00%
  å†…å­˜: 1024 MB
  çŠ¶æ€: Run

...

===== ç£ç›˜ä¿¡æ¯ =====

ç£ç›˜: "/dev/sda1"
  æŒ‚è½½ç‚¹: "/"
  æ–‡ä»¶ç³»ç»Ÿ: "ext4"
  æ€»ç©ºé—´: 500 GB
  å¯ç”¨ç©ºé—´: 250 GB

===== ç½‘ç»œæ¥å£ =====

æ¥å£: eth0
  æ¥æ”¶: 1048576 bytes
  å‘é€: 524288 bytes
  æ€»æ¥æ”¶: 1024 MB
  æ€»å‘é€: 512 MB

===== ç³»ç»Ÿè´Ÿè½½ =====

å…¨å±€ CPU ä½¿ç”¨ç‡: 25.50%

å„æ ¸å¿ƒä½¿ç”¨ç‡:
  CPU 0: 30.20%
  CPU 1: 25.10%
  CPU 2: 22.80%
  ...

===== è¿›ç¨‹ç›‘æ§ç¤ºä¾‹ =====

å¯åŠ¨å­è¿›ç¨‹ PID: 54321
æ£€æŸ¥ç‚¹ 1:
  çŠ¶æ€: Run
  å†…å­˜: 128 KB
  CPU: 0.00%
æ£€æŸ¥ç‚¹ 2:
  çŠ¶æ€: Sleep
  å†…å­˜: 128 KB
  CPU: 0.00%
æ£€æŸ¥ç‚¹ 3:
  çŠ¶æ€: Sleep
  å†…å­˜: 128 KB
  CPU: 0.00%

å­è¿›ç¨‹å®Œæˆ
```

---

## ğŸ“ æ€»ç»“

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **ç¬¬ä¸€é˜¶æ®µ** (Tier 1): æŒæ¡åŸºç¡€ (ç¤ºä¾‹ 1.1-1.4)
   - å‘½ä»¤æ‰§è¡Œ
   - è¿›ç¨‹ I/O
   - ç¯å¢ƒå˜é‡
   - å·¥ä½œç›®å½•

2. **ç¬¬äºŒé˜¶æ®µ** (Tier 2): å®è·µåº”ç”¨ (ç¤ºä¾‹ 2.1-2.4)
   - è¿›ç¨‹ç®¡é“
   - ä¿¡å·å¤„ç†
   - è¿›ç¨‹ç›‘æ§
   - ç³»ç»Ÿä¿¡æ¯

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ      | ç›¸å…³ç¤ºä¾‹ | é‡è¦æ€§     | éš¾åº¦   |
| :--- | :--- | :--- | :--- || Command   | 1.1      | â­â­â­â­â­ | â­     |
| I/Oé‡å®šå‘ | 1.2      | â­â­â­â­   | â­â­   |
| ç¯å¢ƒå˜é‡  | 1.3      | â­â­â­â­   | â­     |
| å·¥ä½œç›®å½•  | 1.4      | â­â­â­     | â­     |
| è¿›ç¨‹ç®¡é“  | 2.1      | â­â­â­â­   | â­â­   |
| ä¿¡å·å¤„ç†  | 2.2      | â­â­â­â­â­ | â­â­â­ |
| è¿›ç¨‹ç›‘æ§  | 2.3      | â­â­â­â­   | â­â­   |
| ç³»ç»Ÿä¿¡æ¯  | 2.4      | â­â­â­     | â­â­   |

### æœ€ä½³å®è·µ

**Tier 1 åŸºç¡€å®è·µ**:

1. **å‘½ä»¤æ‰§è¡Œ**:
   - ä½¿ç”¨ output() ç®€å•åœºæ™¯
   - ä½¿ç”¨ spawn() éœ€è¦æ§åˆ¶
   - æ£€æŸ¥é€€å‡ºçŠ¶æ€

2. **I/O å¤„ç†**:
   - æ•è·è¾“å‡ºä½¿ç”¨ piped
   - ä¸¢å¼ƒè¾“å‡ºä½¿ç”¨ null
   - é‡å®šå‘åˆ°æ–‡ä»¶

3. **é”™è¯¯å¤„ç†**:
   - æ£€æŸ¥ Result
   - éªŒè¯é€€å‡ºç 
   - æ•è· stderr

4. **å®‰å…¨æ€§**:
   - éªŒè¯å‘½ä»¤è·¯å¾„
   - æ¸…ç†ç”¨æˆ·è¾“å…¥
   - é™åˆ¶æƒé™

**Tier 2 è¿›é˜¶å®è·µ**:

1. **è¿›ç¨‹ç®¡é“**:
   - åˆç†è®¾è®¡ç®¡é“é“¾
   - å¤„ç†ç®¡é“å¤±è´¥
   - é¿å…æ­»é”

2. **ä¿¡å·å¤„ç†**:
   - ä¼˜é›…é€€å‡ºæœºåˆ¶
   - è¶…æ—¶æ§åˆ¶
   - èµ„æºæ¸…ç†

3. **è¿›ç¨‹ç›‘æ§**:
   - éé˜»å¡æ£€æŸ¥
   - å®æ—¶è¾“å‡ºå¤„ç†
   - æ€§èƒ½ç»Ÿè®¡

4. **ç³»ç»Ÿä¿¡æ¯**:
   - å®šæœŸåˆ·æ–°æ•°æ®
   - åˆç†ä½¿ç”¨èµ„æº
   - è·¨å¹³å°å…¼å®¹

### ä¸‹ä¸€æ­¥

- ğŸ“– æ·±å…¥å­¦ä¹ : [è¿›ç¨‹é—´é€šä¿¡](./02_è¿›ç¨‹é—´é€šä¿¡æŒ‡å—.md)
- ğŸ“– æ·±å…¥å­¦ä¹ : [ç³»ç»Ÿç¼–ç¨‹å®è·µ](./03_ç³»ç»Ÿç¼–ç¨‹å®è·µ.md)
- ğŸš€ å®æˆ˜é¡¹ç›®: [C07 å®æˆ˜é¡¹ç›®é›†](./07_å®æˆ˜é¡¹ç›®é›†.md) (å³å°†åˆ›å»º)
- ğŸ“š å‚è€ƒæ–‡æ¡£: [tier_03_references](../tier_03_references/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ’¡ ç³»ç»Ÿç¼–ç¨‹æ˜¯ Rust çš„å¼ºé¡¹ï¼ŒæŒæ¡å®ƒèƒ½æ„å»ºå¯é çš„ç³»ç»Ÿå·¥å…·ï¼ğŸ¦€**-
