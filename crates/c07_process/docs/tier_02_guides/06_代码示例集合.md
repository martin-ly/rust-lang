# 🔧 C07: 进程和系统编程 - 代码示例集合

> **创建日期**: 2025-10-25  
> **文档版本**: v1.0  
> **适用模块**: C07 进程和系统编程  
> **目标**: 通过丰富的代码示例，帮助学习者深入理解 Rust 系统编程和进程管理。

---

## 📋 文档概述

本文档提供了 **8个精心设计的代码示例**，覆盖了 C07 模块的核心概念，从基础到高级，每个示例都配有详细的解释和运行结果。

**示例分布**:

- **Tier 1 (基础层)**: 4个示例 - 命令执行、I/O、环境变量、工作目录
- **Tier 2 (实践层)**: 4个示例 - 进程管道、信号处理、进程监控、系统信息

---

## 🎯 示例导航

| # | 示例名称 | 核心概念 | 难度 | 预计学习时间 |
|---|----------|----------|------|--------------|
| **Tier 1: 基础层** |||||
| 1.1 | [命令执行基础](#示例11-命令执行基础) | Command | ⭐ | 15分钟 |
| 1.2 | [进程输入输出](#示例12-进程输入输出) | stdin/stdout | ⭐⭐ | 25分钟 |
| 1.3 | [环境变量](#示例13-环境变量) | env | ⭐ | 20分钟 |
| 1.4 | [工作目录](#示例14-工作目录) | current_dir | ⭐ | 15分钟 |
| **Tier 2: 实践层** |||||
| 2.1 | [进程管道](#示例21-进程管道) | pipe | ⭐⭐ | 30分钟 |
| 2.2 | [信号处理](#示例22-信号处理) | signal | ⭐⭐⭐ | 35分钟 |
| 2.3 | [进程监控](#示例23-进程监控) | status | ⭐⭐ | 30分钟 |
| 2.4 | [系统信息](#示例24-系统信息) | sysinfo | ⭐⭐ | 25分钟 |

---

## 🎓 Tier 1: 基础层示例

### 示例1.1: 命令执行基础

**目标**: 理解如何执行外部命令

**难度**: ⭐

**代码**:

```rust
use std::process::Command;

fn main() {
    println!("===== 基础命令执行 =====\n");
    
    // 执行简单命令
    let output = Command::new("echo")
        .arg("Hello, Process!")
        .output()
        .expect("Failed to execute command");
    
    println!("状态: {}", output.status);
    println!("输出: {}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 多个参数 =====\n");
    
    let output = Command::new("ls")
        .args(&["-l", "-h"])
        .output()
        .expect("Failed to execute");
    
    println!("输出:\n{}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 错误处理 =====\n");
    
    match Command::new("nonexistent")
        .output() {
        Ok(output) => {
            if !output.status.success() {
                eprintln!("命令失败: {}", output.status);
                eprintln!("错误: {}", String::from_utf8_lossy(&output.stderr));
            }
        },
        Err(e) => {
            eprintln!("执行失败: {}", e);
        }
    }
    
    println!("\n===== 检查退出码 =====\n");
    
    let status = Command::new("true")
        .status()
        .expect("Failed to execute");
    
    println!("退出码: {:?}", status.code());
    println!("成功: {}", status.success());
    
    println!("\n===== spawn vs output =====\n");
    
    // spawn: 立即返回，不等待
    let mut child = Command::new("sleep")
        .arg("1")
        .spawn()
        .expect("Failed to spawn");
    
    println!("进程 ID: {}", child.id());
    println!("等待进程...");
    
    let status = child.wait().expect("Failed to wait");
    println!("进程完成: {}", status);
}
```

**说明**:

- **Command**: 命令构建器
- **output**: 执行并等待完成
- **spawn**: 启动进程但不等待
- **status**: 退出状态

**输出**:

```text
===== 基础命令执行 =====

状态: exit status: 0
输出: Hello, Process!

===== 多个参数 =====

输出:
total 64
drwxr-xr-x  5 user  staff   160B Oct 25 10:00 .
drwxr-xr-x  3 user  staff    96B Oct 25 09:00 ..
...

===== 错误处理 =====

执行失败: No such file or directory (os error 2)

===== 检查退出码 =====

退出码: Some(0)
成功: true

===== spawn vs output =====

进程 ID: 12345
等待进程...
进程完成: exit status: 0
```

---

### 示例1.2: 进程输入输出

**目标**: 掌握进程的 I/O 重定向

**难度**: ⭐⭐

**代码**:

```rust
use std::process::{Command, Stdio};
use std::io::Write;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 捕获输出 =====\n");
    
    let output = Command::new("echo")
        .arg("Hello World")
        .stdout(Stdio::piped())
        .output()?;
    
    println!("stdout: {}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 捕获错误输出 =====\n");
    
    let output = Command::new("ls")
        .arg("nonexistent")
        .stderr(Stdio::piped())
        .output()?;
    
    if !output.stderr.is_empty() {
        eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
    }
    
    println!("\n===== 重定向到文件 =====\n");
    
    use std::fs::File;
    
    let file = File::create("output.txt")?;
    
    let status = Command::new("echo")
        .arg("Redirected to file")
        .stdout(Stdio::from(file))
        .status()?;
    
    println!("写入文件完成: {}", status);
    
    // 读取验证
    let content = std::fs::read_to_string("output.txt")?;
    println!("文件内容: {}", content);
    
    println!("===== 输入重定向 =====\n");
    
    let mut child = Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;
    
    // 写入数据到进程的 stdin
    if let Some(mut stdin) = child.stdin.take() {
        stdin.write_all(b"Hello from stdin!\n")?;
    }
    
    let output = child.wait_with_output()?;
    println!("cat 输出: {}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 忽略输出 =====\n");
    
    let status = Command::new("echo")
        .arg("This will be ignored")
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()?;
    
    println!("执行完成 (输出已忽略): {}", status);
    
    // 清理
    std::fs::remove_file("output.txt")?;
    
    Ok(())
}
```

**说明**:

- **Stdio::piped()**: 创建管道捕获输出
- **Stdio::null()**: 丢弃输出
- **stdin.write**: 向进程输入数据
- **重定向**: 可以重定向到文件

**输出**:

```text
===== 捕获输出 =====

stdout: Hello World

===== 捕获错误输出 =====

stderr: ls: cannot access 'nonexistent': No such file or directory

===== 重定向到文件 =====

写入文件完成: exit status: 0
文件内容: Redirected to file

===== 输入重定向 =====

cat 输出: Hello from stdin!

===== 忽略输出 =====

执行完成 (输出已忽略): exit status: 0
```

---

### 示例1.3: 环境变量

**目标**: 理解环境变量的设置和使用

**难度**: ⭐

**代码**:

```rust
use std::process::Command;
use std::env;

fn main() {
    println!("===== 读取环境变量 =====\n");
    
    // 读取当前进程的环境变量
    if let Ok(path) = env::var("PATH") {
        println!("PATH: {}", path);
    }
    
    if let Ok(home) = env::var("HOME") {
        println!("HOME: {}", home);
    }
    
    println!("\n===== 设置环境变量 =====\n");
    
    // 为当前进程设置
    env::set_var("MY_VAR", "my_value");
    println!("MY_VAR = {}", env::var("MY_VAR").unwrap());
    
    println!("\n===== 子进程环境变量 =====\n");
    
    let output = Command::new("sh")
        .arg("-c")
        .arg("echo $CUSTOM_VAR")
        .env("CUSTOM_VAR", "custom_value")
        .output()
        .expect("Failed to execute");
    
    println!("子进程输出: {}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 清除环境变量 =====\n");
    
    let output = Command::new("sh")
        .arg("-c")
        .arg("echo PATH=$PATH")
        .env_clear()  // 清除所有环境变量
        .env("PATH", "/usr/bin")  // 只设置需要的
        .output()
        .expect("Failed to execute");
    
    println!("{}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 环境变量列表 =====\n");
    
    let count = env::vars().count();
    println!("当前进程有 {} 个环境变量", count);
    
    // 显示前 5 个
    for (key, value) in env::vars().take(5) {
        println!("{} = {}", key, value);
    }
    
    println!("\n===== 临时环境变量 =====\n");
    
    env::set_var("TEMP_VAR", "temp");
    println!("设置: TEMP_VAR = temp");
    
    env::remove_var("TEMP_VAR");
    println!("删除: TEMP_VAR");
    
    match env::var("TEMP_VAR") {
        Ok(value) => println!("TEMP_VAR = {}", value),
        Err(_) => println!("TEMP_VAR 不存在"),
    }
}
```

**说明**:

- **env::var**: 读取环境变量
- **env::set_var**: 设置环境变量
- **Command::env**: 为子进程设置环境变量
- **env_clear**: 清除所有环境变量

**输出**:

```text
===== 读取环境变量 =====

PATH: /usr/local/bin:/usr/bin:/bin
HOME: /home/user

===== 设置环境变量 =====

MY_VAR = my_value

===== 子进程环境变量 =====

子进程输出: custom_value

===== 清除环境变量 =====

PATH=/usr/bin

===== 环境变量列表 =====

当前进程有 42 个环境变量
SHELL = /bin/bash
USER = user
PATH = /usr/local/bin:/usr/bin
HOME = /home/user
LANG = en_US.UTF-8

===== 临时环境变量 =====

设置: TEMP_VAR = temp
删除: TEMP_VAR
TEMP_VAR 不存在
```

---

### 示例1.4: 工作目录

**目标**: 理解工作目录的管理

**难度**: ⭐

**代码**:

```rust
use std::process::Command;
use std::env;
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 当前工作目录 =====\n");
    
    let current_dir = env::current_dir()?;
    println!("当前目录: {:?}", current_dir);
    
    println!("\n===== 改变工作目录 =====\n");
    
    // 创建测试目录
    fs::create_dir_all("test_dir")?;
    
    env::set_current_dir("test_dir")?;
    println!("改变到: {:?}", env::current_dir()?);
    
    // 返回原目录
    env::set_current_dir("..")?;
    println!("返回到: {:?}", env::current_dir()?);
    
    println!("\n===== 子进程工作目录 =====\n");
    
    fs::create_dir_all("sub_dir")?;
    
    let output = Command::new("pwd")
        .current_dir("sub_dir")
        .output()?;
    
    println!("子进程工作目录: {}", String::from_utf8_lossy(&output.stdout));
    
    println!("当前进程目录不变: {:?}", env::current_dir()?);
    
    println!("\n===== 相对路径 vs 绝对路径 =====\n");
    
    // 相对路径
    let output = Command::new("ls")
        .arg(".")
        .current_dir("sub_dir")
        .output()?;
    
    println!("相对路径 ls .: {}", String::from_utf8_lossy(&output.stdout));
    
    // 绝对路径
    let abs_path = env::current_dir()?.join("sub_dir");
    println!("绝对路径: {:?}", abs_path);
    
    println!("\n===== 路径规范化 =====\n");
    
    let path = env::current_dir()?.join("./test_dir/../sub_dir");
    println!("原始路径: {:?}", path);
    
    let canonical = fs::canonicalize(path)?;
    println!("规范化路径: {:?}", canonical);
    
    // 清理
    fs::remove_dir_all("test_dir")?;
    fs::remove_dir_all("sub_dir")?;
    
    Ok(())
}
```

**说明**:

- **current_dir**: 获取当前工作目录
- **set_current_dir**: 改变当前目录
- **Command::current_dir**: 设置子进程的工作目录
- **canonicalize**: 获取规范化的绝对路径

**输出**:

```text
===== 当前工作目录 =====

当前目录: "/home/user/project"

===== 改变工作目录 =====

改变到: "/home/user/project/test_dir"
返回到: "/home/user/project"

===== 子进程工作目录 =====

子进程工作目录: /home/user/project/sub_dir

当前进程目录不变: "/home/user/project"

===== 相对路径 vs 绝对路径 =====

相对路径 ls .: .
..
绝对路径: "/home/user/project/sub_dir"

===== 路径规范化 =====

原始路径: "/home/user/project/./test_dir/../sub_dir"
规范化路径: "/home/user/project/sub_dir"
```

---

## 🚀 Tier 2: 实践层示例

### 示例2.1: 进程管道

**目标**: 理解如何通过管道连接多个进程

**难度**: ⭐⭐

**代码**:

```rust
use std::process::{Command, Stdio};
use std::io::Write;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 基础管道 =====\n");
    
    // 模拟 shell: echo "hello" | tr '[:lower:]' '[:upper:]'
    let echo_child = Command::new("echo")
        .arg("hello world")
        .stdout(Stdio::piped())
        .spawn()?;
    
    let echo_output = echo_child.stdout.expect("Failed to capture stdout");
    
    let tr_output = Command::new("tr")
        .arg("[:lower:]")
        .arg("[:upper:]")
        .stdin(Stdio::from(echo_output))
        .output()?;
    
    println!("管道输出: {}", String::from_utf8_lossy(&tr_output.stdout));
    
    println!("===== 多级管道 =====\n");
    
    // 模拟: ps aux | grep rust | wc -l
    let ps = Command::new("ps")
        .arg("aux")
        .stdout(Stdio::piped())
        .spawn()?;
    
    let ps_stdout = ps.stdout.expect("Failed to capture ps stdout");
    
    let grep = Command::new("grep")
        .arg("rust")
        .stdin(Stdio::from(ps_stdout))
        .stdout(Stdio::piped())
        .spawn()?;
    
    let grep_stdout = grep.stdout.expect("Failed to capture grep stdout");
    
    let wc_output = Command::new("wc")
        .arg("-l")
        .stdin(Stdio::from(grep_stdout))
        .output()?;
    
    println!("包含 'rust' 的进程数: {}", 
             String::from_utf8_lossy(&wc_output.stdout).trim());
    
    println!("\n===== 手动管道 =====\n");
    
    use std::process::{ChildStdout, ChildStdin};
    use std::io::{BufRead, BufReader};
    
    let mut cat = Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;
    
    // 写入数据
    if let Some(mut stdin) = cat.stdin.take() {
        writeln!(stdin, "Line 1")?;
        writeln!(stdin, "Line 2")?;
        writeln!(stdin, "Line 3")?;
    }
    
    let output = cat.wait_with_output()?;
    println!("cat 输出:\n{}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 双向通信 =====\n");
    
    let mut bc = Command::new("bc")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;
    
    // 发送计算表达式
    if let Some(mut stdin) = bc.stdin.take() {
        writeln!(stdin, "2 + 2")?;
        writeln!(stdin, "10 * 5")?;
        writeln!(stdin, "quit")?;
    }
    
    let output = bc.wait_with_output()?;
    println!("计算结果:\n{}", String::from_utf8_lossy(&output.stdout));
    
    println!("===== 并行管道 =====\n");
    
    use std::thread;
    
    let mut children = vec![];
    
    for i in 1..=3 {
        let child = Command::new("echo")
            .arg(format!("Task {}", i))
            .stdout(Stdio::piped())
            .spawn()?;
        children.push(child);
    }
    
    for mut child in children {
        let output = child.wait_with_output()?;
        println!("输出: {}", String::from_utf8_lossy(&output.stdout).trim());
    }
    
    Ok(())
}
```

**说明**:

- **管道连接**: 将一个进程的输出作为另一个进程的输入
- **多级管道**: 连接多个进程形成处理链
- **双向通信**: 同时控制进程的输入和输出
- **并行处理**: 同时运行多个子进程

**输出**:

```text
===== 基础管道 =====

管道输出: HELLO WORLD

===== 多级管道 =====

包含 'rust' 的进程数: 5

===== 手动管道 =====

cat 输出:
Line 1
Line 2
Line 3

===== 双向通信 =====

计算结果:
4
50

===== 并行管道 =====

输出: Task 1
输出: Task 2
输出: Task 3
```

---

### 示例2.2: 信号处理

**目标**: 理解如何处理系统信号

**难度**: ⭐⭐⭐

**依赖**: 需要添加到 `Cargo.toml`:

```toml
[dependencies]
signal-hook = "0.3"
```

**代码**:

```rust
use std::process::{Command, Child};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;
use std::thread;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 基础信号处理 =====\n");
    
    // 捕获 Ctrl+C (SIGINT)
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();
    
    ctrlc::set_handler(move || {
        println!("\n收到 SIGINT (Ctrl+C)");
        r.store(false, Ordering::SeqCst);
    })?;
    
    println!("程序运行中... (按 Ctrl+C 退出)");
    
    let mut count = 0;
    while running.load(Ordering::SeqCst) && count < 5 {
        println!("工作中... {}", count);
        thread::sleep(Duration::from_secs(1));
        count += 1;
    }
    
    println!("\n程序正常退出");
    
    println!("\n===== 子进程终止 =====\n");
    
    // 启动一个长时间运行的进程
    let mut child = Command::new("sleep")
        .arg("30")
        .spawn()?;
    
    println!("启动子进程 (PID: {})", child.id());
    
    // 等待一秒后终止
    thread::sleep(Duration::from_secs(1));
    
    println!("发送 SIGTERM...");
    child.kill()?;  // 发送 SIGKILL
    
    let status = child.wait()?;
    println!("子进程退出: {}", status);
    
    println!("\n===== 超时处理 =====\n");
    
    let mut child = Command::new("sleep")
        .arg("10")
        .spawn()?;
    
    println!("启动子进程，设置 2 秒超时");
    
    use std::time::Instant;
    let start = Instant::now();
    let timeout = Duration::from_secs(2);
    
    loop {
        match child.try_wait()? {
            Some(status) => {
                println!("进程完成: {}", status);
                break;
            }
            None => {
                if start.elapsed() >= timeout {
                    println!("超时! 终止进程...");
                    child.kill()?;
                    child.wait()?;
                    break;
                }
                thread::sleep(Duration::from_millis(100));
            }
        }
    }
    
    println!("\n===== 信号转发 =====\n");
    
    let mut child = Command::new("bash")
        .arg("-c")
        .arg("trap 'echo Received SIGTERM' TERM; sleep 5")
        .spawn()?;
    
    println!("启动 bash 子进程");
    thread::sleep(Duration::from_millis(500));
    
    // 在 Unix 上可以发送特定信号
    #[cfg(unix)]
    {
        use std::process;
        println!("发送 SIGTERM 到子进程");
        
        unsafe {
            libc::kill(child.id() as i32, libc::SIGTERM);
        }
        
        thread::sleep(Duration::from_secs(1));
    }
    
    child.kill()?;
    child.wait()?;
    
    println!("\n===== 优雅退出 =====\n");
    
    struct GracefulProcess {
        child: Option<Child>,
    }
    
    impl Drop for GracefulProcess {
        fn drop(&mut self) {
            if let Some(mut child) = self.child.take() {
                println!("清理: 终止子进程 {}", child.id());
                let _ = child.kill();
                let _ = child.wait();
            }
        }
    }
    
    let _process = GracefulProcess {
        child: Some(Command::new("sleep").arg("100").spawn()?),
    };
    
    println!("创建守护进程");
    thread::sleep(Duration::from_secs(1));
    println!("退出作用域，自动清理");
    // _process 在这里被 drop，自动终止子进程
    
    Ok(())
}
```

**说明**:

- **SIGINT**: Ctrl+C 中断信号
- **SIGTERM**: 请求终止信号
- **SIGKILL**: 强制终止信号
- **kill()**: 终止子进程
- **优雅退出**: 使用 Drop trait 自动清理

**输出**:

```text
===== 基础信号处理 =====

程序运行中... (按 Ctrl+C 退出)
工作中... 0
工作中... 1
^C
收到 SIGINT (Ctrl+C)

程序正常退出

===== 子进程终止 =====

启动子进程 (PID: 12345)
发送 SIGTERM...
子进程退出: signal: 9 (SIGKILL)

===== 超时处理 =====

启动子进程，设置 2 秒超时
超时! 终止进程...

===== 信号转发 =====

启动 bash 子进程
发送 SIGTERM 到子进程

===== 优雅退出 =====

创建守护进程
退出作用域，自动清理
清理: 终止子进程 54321
```

---

### 示例2.3: 进程监控

**目标**: 监控进程状态和资源使用

**难度**: ⭐⭐

**代码**:

```rust
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use std::thread;
use std::io::Read;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 进程状态监控 =====\n");
    
    let mut child = Command::new("sleep")
        .arg("3")
        .spawn()?;
    
    let pid = child.id();
    println!("启动进程 (PID: {})", pid);
    
    let start = Instant::now();
    
    loop {
        match child.try_wait()? {
            Some(status) => {
                println!("\n进程完成:");
                println!("  退出状态: {}", status);
                println!("  运行时间: {:?}", start.elapsed());
                println!("  成功: {}", status.success());
                if let Some(code) = status.code() {
                    println!("  退出码: {}", code);
                }
                break;
            }
            None => {
                print!(".");
                std::io::Write::flush(&mut std::io::stdout())?;
                thread::sleep(Duration::from_millis(500));
            }
        }
    }
    
    println!("\n\n===== 输出流监控 =====\n");
    
    let mut child = Command::new("bash")
        .arg("-c")
        .arg("for i in {1..5}; do echo Line $i; sleep 1; done")
        .stdout(Stdio::piped())
        .spawn()?;
    
    println!("实时读取输出:");
    
    if let Some(mut stdout) = child.stdout.take() {
        use std::io::BufReader;
        use std::io::BufRead;
        
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            println!("  > {}", line?);
        }
    }
    
    let status = child.wait()?;
    println!("进程完成: {}", status);
    
    println!("\n===== 多进程监控 =====\n");
    
    let mut children = vec![];
    
    for i in 1..=3 {
        let child = Command::new("sleep")
            .arg(format!("{}", i))
            .spawn()?;
        println!("启动进程 {} (PID: {})", i, child.id());
        children.push((i, child, Instant::now()));
    }
    
    println!("\n监控进程:");
    
    while !children.is_empty() {
        children.retain_mut(|(id, child, start)| {
            match child.try_wait() {
                Ok(Some(status)) => {
                    println!("  进程 {} 完成 (用时: {:?})", id, start.elapsed());
                    false  // 移除已完成的进程
                }
                Ok(None) => true,  // 继续保留运行中的进程
                Err(e) => {
                    eprintln!("  进程 {} 错误: {}", id, e);
                    false
                }
            }
        });
        
        if !children.is_empty() {
            thread::sleep(Duration::from_millis(100));
        }
    }
    
    println!("所有进程完成");
    
    println!("\n===== 进程统计 =====\n");
    
    let iterations = 5;
    let mut total_time = Duration::from_secs(0);
    let mut success_count = 0;
    
    for i in 1..=iterations {
        let start = Instant::now();
        
        let status = Command::new("echo")
            .arg(format!("Test {}", i))
            .status()?;
        
        let elapsed = start.elapsed();
        total_time += elapsed;
        
        if status.success() {
            success_count += 1;
        }
        
        println!("迭代 {}: {:?} - {}", i, elapsed, 
                 if status.success() { "✓" } else { "✗" });
    }
    
    println!("\n统计:");
    println!("  总次数: {}", iterations);
    println!("  成功: {}", success_count);
    println!("  失败: {}", iterations - success_count);
    println!("  总时间: {:?}", total_time);
    println!("  平均时间: {:?}", total_time / iterations);
    
    println!("\n===== 资源限制监控 =====\n");
    
    // 监控内存占用较大的进程
    let start = Instant::now();
    
    let output = Command::new("bash")
        .arg("-c")
        .arg("dd if=/dev/zero of=/dev/null bs=1M count=100 2>&1")
        .output()?;
    
    let elapsed = start.elapsed();
    
    println!("命令执行完成:");
    println!("  耗时: {:?}", elapsed);
    println!("  输出长度: {} bytes", output.stdout.len() + output.stderr.len());
    println!("  成功: {}", output.status.success());
    
    if !output.stderr.is_empty() {
        println!("  信息: {}", String::from_utf8_lossy(&output.stderr));
    }
    
    Ok(())
}
```

**说明**:

- **try_wait**: 非阻塞检查进程状态
- **实时监控**: 读取进程输出流
- **多进程管理**: 同时监控多个子进程
- **性能统计**: 收集执行时间和成功率

**输出**:

```text
===== 进程状态监控 =====

启动进程 (PID: 12345)
......

进程完成:
  退出状态: exit status: 0
  运行时间: 3.002s
  成功: true
  退出码: 0

===== 输出流监控 =====

实时读取输出:
  > Line 1
  > Line 2
  > Line 3
  > Line 4
  > Line 5
进程完成: exit status: 0

===== 多进程监控 =====

启动进程 1 (PID: 12346)
启动进程 2 (PID: 12347)
启动进程 3 (PID: 12348)

监控进程:
  进程 1 完成 (用时: 1.001s)
  进程 2 完成 (用时: 2.002s)
  进程 3 完成 (用时: 3.003s)
所有进程完成

===== 进程统计 =====

迭代 1: 8.2ms - ✓
迭代 2: 7.9ms - ✓
迭代 3: 8.1ms - ✓
迭代 4: 8.0ms - ✓
迭代 5: 8.3ms - ✓

统计:
  总次数: 5
  成功: 5
  失败: 0
  总时间: 40.5ms
  平均时间: 8.1ms

===== 资源限制监控 =====

命令执行完成:
  耗时: 156.3ms
  输出长度: 95 bytes
  成功: true
  信息: 100+0 records in
100+0 records out
104857600 bytes transferred in 0.156 secs (671281024 bytes/sec)
```

---

### 示例2.4: 系统信息

**目标**: 获取系统和进程信息

**难度**: ⭐⭐

**依赖**: 需要添加到 `Cargo.toml`:

```toml
[dependencies]
sysinfo = "0.30"
```

**代码**:

```rust
use sysinfo::{System, SystemExt, ProcessExt, Pid};
use std::process::Command;

fn main() {
    println!("===== 系统基础信息 =====\n");
    
    let mut sys = System::new_all();
    sys.refresh_all();
    
    println!("系统信息:");
    println!("  操作系统: {} {}", 
             System::name().unwrap_or_default(),
             System::os_version().unwrap_or_default());
    println!("  内核版本: {}", System::kernel_version().unwrap_or_default());
    println!("  主机名: {}", System::host_name().unwrap_or_default());
    
    println!("\n硬件信息:");
    println!("  CPU 核心数: {}", sys.cpus().len());
    println!("  总内存: {} MB", sys.total_memory() / 1024 / 1024);
    println!("  已用内存: {} MB", sys.used_memory() / 1024 / 1024);
    println!("  可用内存: {} MB", sys.available_memory() / 1024 / 1024);
    println!("  总交换空间: {} MB", sys.total_swap() / 1024 / 1024);
    println!("  已用交换: {} MB", sys.used_swap() / 1024 / 1024);
    
    println!("\n===== CPU 信息 =====\n");
    
    for (i, cpu) in sys.cpus().iter().enumerate() {
        println!("CPU {}:", i);
        println!("  名称: {}", cpu.name());
        println!("  使用率: {:.2}%", cpu.cpu_usage());
        println!("  频率: {} MHz", cpu.frequency());
    }
    
    println!("\n===== 当前进程信息 =====\n");
    
    let pid = std::process::id();
    println!("当前进程 PID: {}", pid);
    
    sys.refresh_process(Pid::from(pid as usize));
    
    if let Some(process) = sys.process(Pid::from(pid as usize)) {
        println!("进程详情:");
        println!("  名称: {}", process.name());
        println!("  CPU 使用: {:.2}%", process.cpu_usage());
        println!("  内存使用: {} KB", process.memory());
        println!("  虚拟内存: {} KB", process.virtual_memory());
        println!("  父进程 PID: {:?}", process.parent());
        println!("  启动时间: {} 秒", process.start_time());
        println!("  运行时间: {} 秒", process.run_time());
    }
    
    println!("\n===== 进程列表 =====\n");
    
    let mut rust_processes = vec![];
    
    for (pid, process) in sys.processes() {
        let name = process.name().to_lowercase();
        if name.contains("rust") || name.contains("cargo") {
            rust_processes.push((pid, process));
        }
    }
    
    println!("发现 {} 个 Rust 相关进程:\n", rust_processes.len());
    
    for (pid, process) in rust_processes.iter().take(5) {
        println!("PID {}: {}", pid, process.name());
        println!("  CPU: {:.2}%", process.cpu_usage());
        println!("  内存: {} MB", process.memory() / 1024);
        println!("  状态: {:?}", process.status());
        println!();
    }
    
    println!("===== 磁盘信息 =====\n");
    
    let disks = sysinfo::Disks::new_with_refreshed_list();
    
    for disk in disks.list() {
        println!("磁盘: {:?}", disk.name());
        println!("  挂载点: {:?}", disk.mount_point());
        println!("  文件系统: {:?}", disk.file_system());
        println!("  总空间: {} GB", disk.total_space() / 1024 / 1024 / 1024);
        println!("  可用空间: {} GB", disk.available_space() / 1024 / 1024 / 1024);
        println!();
    }
    
    println!("===== 网络接口 =====\n");
    
    let networks = sysinfo::Networks::new_with_refreshed_list();
    
    for (interface_name, network) in networks.list() {
        println!("接口: {}", interface_name);
        println!("  接收: {} bytes", network.received());
        println!("  发送: {} bytes", network.transmitted());
        println!("  总接收: {} MB", network.total_received() / 1024 / 1024);
        println!("  总发送: {} MB", network.total_transmitted() / 1024 / 1024);
        println!();
    }
    
    println!("===== 系统负载 =====\n");
    
    use std::thread;
    use std::time::Duration;
    
    sys.refresh_cpu();
    thread::sleep(Duration::from_millis(1000));
    sys.refresh_cpu();
    
    let global_cpu = sys.global_cpu_info();
    println!("全局 CPU 使用率: {:.2}%", global_cpu.cpu_usage());
    
    println!("\n各核心使用率:");
    for (i, cpu) in sys.cpus().iter().enumerate() {
        println!("  CPU {}: {:.2}%", i, cpu.cpu_usage());
    }
    
    println!("\n===== 进程监控示例 =====\n");
    
    // 启动一个子进程并监控它
    let mut child = Command::new("sleep")
        .arg("2")
        .spawn()
        .expect("Failed to spawn");
    
    let child_pid = Pid::from(child.id() as usize);
    println!("启动子进程 PID: {}", child.id());
    
    for i in 1..=3 {
        thread::sleep(Duration::from_millis(500));
        sys.refresh_process(child_pid);
        
        if let Some(process) = sys.process(child_pid) {
            println!("检查点 {}:", i);
            println!("  状态: {:?}", process.status());
            println!("  内存: {} KB", process.memory());
            println!("  CPU: {:.2}%", process.cpu_usage());
        }
    }
    
    child.wait().expect("Failed to wait");
    println!("\n子进程完成");
}
```

**说明**:

- **System**: 系统信息查询
- **Process**: 进程信息查询
- **CPU 监控**: CPU 使用率统计
- **内存监控**: 内存使用情况
- **磁盘和网络**: 系统资源信息

**输出**:

```text
===== 系统基础信息 =====

系统信息:
  操作系统: Linux 6.5.0
  内核版本: 6.5.0-14-generic
  主机名: rust-dev

硬件信息:
  CPU 核心数: 8
  总内存: 16384 MB
  已用内存: 8192 MB
  可用内存: 8192 MB
  总交换空间: 4096 MB
  已用交换: 512 MB

===== CPU 信息 =====

CPU 0:
  名称: Intel(R) Core(TM) i7-9750H
  使用率: 12.50%
  频率: 2600 MHz
CPU 1:
  名称: Intel(R) Core(TM) i7-9750H
  使用率: 8.30%
  频率: 2600 MHz
...

===== 当前进程信息 =====

当前进程 PID: 12345
进程详情:
  名称: example
  CPU 使用: 0.50%
  内存使用: 2048 KB
  虚拟内存: 10240 KB
  父进程 PID: Some(12000)
  启动时间: 1698300000 秒
  运行时间: 2 秒

===== 进程列表 =====

发现 3 个 Rust 相关进程:

PID 12345: cargo
  CPU: 0.20%
  内存: 50 MB
  状态: Run

PID 12346: rustc
  CPU: 95.00%
  内存: 1024 MB
  状态: Run

...

===== 磁盘信息 =====

磁盘: "/dev/sda1"
  挂载点: "/"
  文件系统: "ext4"
  总空间: 500 GB
  可用空间: 250 GB

===== 网络接口 =====

接口: eth0
  接收: 1048576 bytes
  发送: 524288 bytes
  总接收: 1024 MB
  总发送: 512 MB

===== 系统负载 =====

全局 CPU 使用率: 25.50%

各核心使用率:
  CPU 0: 30.20%
  CPU 1: 25.10%
  CPU 2: 22.80%
  ...

===== 进程监控示例 =====

启动子进程 PID: 54321
检查点 1:
  状态: Run
  内存: 128 KB
  CPU: 0.00%
检查点 2:
  状态: Sleep
  内存: 128 KB
  CPU: 0.00%
检查点 3:
  状态: Sleep
  内存: 128 KB
  CPU: 0.00%

子进程完成
```

---

## 📝 总结

### 学习路径建议

1. **第一阶段** (Tier 1): 掌握基础 (示例 1.1-1.4)
   - 命令执行
   - 进程 I/O
   - 环境变量
   - 工作目录

2. **第二阶段** (Tier 2): 实践应用 (示例 2.1-2.4)
   - 进程管道
   - 信号处理
   - 进程监控
   - 系统信息

### 核心概念总结

| 概念 | 相关示例 | 重要性 | 难度 |
|------|---------|--------|------|
| Command | 1.1 | ⭐⭐⭐⭐⭐ | ⭐ |
| I/O重定向 | 1.2 | ⭐⭐⭐⭐ | ⭐⭐ |
| 环境变量 | 1.3 | ⭐⭐⭐⭐ | ⭐ |
| 工作目录 | 1.4 | ⭐⭐⭐ | ⭐ |
| 进程管道 | 2.1 | ⭐⭐⭐⭐ | ⭐⭐ |
| 信号处理 | 2.2 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 进程监控 | 2.3 | ⭐⭐⭐⭐ | ⭐⭐ |
| 系统信息 | 2.4 | ⭐⭐⭐ | ⭐⭐ |

### 最佳实践

**Tier 1 基础实践**:

1. **命令执行**:
   - 使用 output() 简单场景
   - 使用 spawn() 需要控制
   - 检查退出状态

2. **I/O 处理**:
   - 捕获输出使用 piped
   - 丢弃输出使用 null
   - 重定向到文件

3. **错误处理**:
   - 检查 Result
   - 验证退出码
   - 捕获 stderr

4. **安全性**:
   - 验证命令路径
   - 清理用户输入
   - 限制权限

**Tier 2 进阶实践**:

1. **进程管道**:
   - 合理设计管道链
   - 处理管道失败
   - 避免死锁

2. **信号处理**:
   - 优雅退出机制
   - 超时控制
   - 资源清理

3. **进程监控**:
   - 非阻塞检查
   - 实时输出处理
   - 性能统计

4. **系统信息**:
   - 定期刷新数据
   - 合理使用资源
   - 跨平台兼容

### 下一步

- 📖 深入学习: [进程间通信](./02_进程间通信指南.md)
- 📖 深入学习: [系统编程实践](./03_系统编程实践.md)
- 🚀 实战项目: [C07 实战项目集](./07_实战项目集.md) (即将创建)
- 📚 参考文档: [tier_03_references](../tier_03_references/)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-25  
**维护状态**: 活跃维护

**💡 系统编程是 Rust 的强项，掌握它能构建可靠的系统工具！🦀**-
