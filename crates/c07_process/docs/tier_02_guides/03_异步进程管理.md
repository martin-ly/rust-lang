# Tier 2: 异步进程管理

> **文档类型**: 实践指南
> **难度**: ⭐⭐⭐ 中级
> **预计时间**: 2小时
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 异步进程管理](#tier-2-异步进程管理)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 为什么使用异步](#1-为什么使用异步)
  - [2. Tokio Process](#2-tokio-process)
    - [2.1 基础异步进程](#21-基础异步进程)
    - [2.2 异步捕获和流式处理](#22-异步捕获和流式处理)
    - [2.3 同时读取stdout和stderr](#23-同时读取stdout和stderr)
    - [2.4 异步写入stdin](#24-异步写入stdin)
    - [2.5 完整的双向通信](#25-完整的双向通信)
    - [2.6 性能对比](#26-性能对比)
  - [3. 并发进程管理](#3-并发进程管理)
    - [3.1 基础并发](#31-基础并发)
    - [3.2 使用join\_all批量等待](#32-使用join_all批量等待)
    - [3.3 限制并发数量（信号量）](#33-限制并发数量信号量)
    - [3.4 进程池实现](#34-进程池实现)
    - [3.5 动态任务调度](#35-动态任务调度)
    - [3.6 优先级调度](#36-优先级调度)
  - [4. 超时与取消](#4-超时与取消)
    - [4.1 基础超时控制](#41-基础超时控制)
    - [4.2 带清理的超时](#42-带清理的超时)
    - [4.3 优雅取消](#43-优雅取消)
    - [4.4 多进程协调取消](#44-多进程协调取消)
    - [4.5 重试机制](#45-重试机制)
    - [4.6 断路器模式](#46-断路器模式)
  - [5. 实战案例](#5-实战案例)
    - [案例1: 异步批处理系统](#案例1-异步批处理系统)
    - [案例2: 分布式任务执行器](#案例2-分布式任务执行器)
    - [案例3: 日志聚合器](#案例3-日志聚合器)
    - [案例4: 健康检查监控](#案例4-健康检查监控)
  - [6. 性能优化与最佳实践](#6-性能优化与最佳实践)
    - [6.1 选择合适的运行时配置](#61-选择合适的运行时配置)
    - [6.2 避免阻塞](#62-避免阻塞)
    - [6.3 资源管理](#63-资源管理)
    - [6.4 错误处理最佳实践](#64-错误处理最佳实践)
    - [6.5 监控和调试](#65-监控和调试)
  - [7. 常见陷阱与解决方案](#7-常见陷阱与解决方案)
    - [陷阱1: 忘记await](#陷阱1-忘记await)
    - [陷阱2: 死锁](#陷阱2-死锁)
    - [陷阱3: 资源泄漏](#陷阱3-资源泄漏)
  - [下一步](#下一步)

---

## 学习目标

- ✅ 理解异步进程管理的优势
- ✅ 使用Tokio管理进程
- ✅ 实现并发进程调度
- ✅ 处理超时和取消

---

## 1. 为什么使用异步

**适合异步的场景**:

- ✅ 同时管理多个子进程
- ✅ I/O密集型操作
- ✅ 需要超时控制
- ✅ 与异步生态集成

**不适合异步**:

- ❌ 单个进程简单执行
- ❌ CPU密集型任务

---

## 2. Tokio Process

### 2.1 基础异步进程

**最简单的异步进程执行**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new("echo")
        .arg("Hello Async!")
        .output()
        .await?;

    println!("stdout: {}", String::from_utf8_lossy(&output.stdout));
    println!("stderr: {}", String::from_utf8_lossy(&output.stderr));
    println!("status: {}", output.status);

    Ok(())
}
```

---

### 2.2 异步捕获和流式处理

**流式读取stdout**:

```rust
use tokio::process::{Command, ChildStdout};
use tokio::io::{AsyncReadExt, AsyncBufReadExt, BufReader};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("cat")
        .arg("large_file.txt")
        .stdout(Stdio::piped())
        .spawn()?;

    if let Some(stdout) = child.stdout.take() {
        let reader = BufReader::new(stdout);
        let mut lines = reader.lines();

        while let Some(line) = lines.next_line().await? {
            println!("📥 Line: {}", line);
        }
    }

    let status = child.wait().await?;
    println!("✅ Process exited: {}", status);

    Ok(())
}
```

---

### 2.3 同时读取stdout和stderr

```rust
use tokio::process::Command;
use tokio::io::AsyncBufReadExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("sh")
        .arg("-c")
        .arg("echo stdout; echo stderr >&2")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let stdout = child.stdout.take().unwrap();
    let stderr = child.stderr.take().unwrap();

    // 并发读取stdout和stderr
    let stdout_task = tokio::spawn(async move {
        let reader = BufReader::new(stdout);
        let mut lines = reader.lines();
        while let Some(line) = lines.next_line().await.unwrap() {
            println!("[stdout] {}", line);
        }
    });

    let stderr_task = tokio::spawn(async move {
        let reader = BufReader::new(stderr);
        let mut lines = reader.lines();
        while let Some(line) = lines.next_line().await.unwrap() {
            eprintln!("[stderr] {}", line);
        }
    });

    // 等待所有任务完成
    stdout_task.await?;
    stderr_task.await?;
    child.wait().await?;

    Ok(())
}
```

---

### 2.4 异步写入stdin

```rust
use tokio::process::Command;
use tokio::io::AsyncWriteExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("grep")
        .arg("pattern")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    // 异步写入stdin
    if let Some(mut stdin) = child.stdin.take() {
        tokio::spawn(async move {
            stdin.write_all(b"line with pattern\n").await.unwrap();
            stdin.write_all(b"line without\n").await.unwrap();
            stdin.write_all(b"another line with pattern\n").await.unwrap();
            // stdin自动关闭
        });
    }

    // 读取输出
    let output = child.wait_with_output().await?;
    println!("Output:\n{}", String::from_utf8_lossy(&output.stdout));

    Ok(())
}
```

---

### 2.5 完整的双向通信

```rust
use tokio::process::Command;
use tokio::io::{AsyncWriteExt, AsyncBufReadExt, BufReader};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("python3")
        .arg("-c")
        .arg("import sys; [print(line.strip().upper()) for line in sys.stdin]")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    let mut stdin = child.stdin.take().unwrap();
    let stdout = child.stdout.take().unwrap();

    // 在单独的任务中写入
    let write_task = tokio::spawn(async move {
        for i in 1..=5 {
            stdin.write_all(format!("message {}\n", i).as_bytes()).await.unwrap();
        }
        drop(stdin);  // 关闭stdin
    });

    // 主任务读取
    let reader = BufReader::new(stdout);
    let mut lines = reader.lines();
    while let Some(line) = lines.next_line().await? {
        println!("📥 Received: {}", line);
    }

    write_task.await?;
    child.wait().await?;

    Ok(())
}
```

---

### 2.6 性能对比

**同步 vs 异步处理10个进程**:

```rust
use std::time::Instant;

// 同步版本
fn sync_version() {
    use std::process::Command;

    let start = Instant::now();
    for i in 0..10 {
        Command::new("sleep")
            .arg("1")
            .output()
            .unwrap();
    }
    println!("⏱️ Sync: {:?}", start.elapsed());  // ~10秒
}

// 异步版本
#[tokio::main]
async fn async_version() {
    use tokio::process::Command;

    let start = Instant::now();
    let tasks: Vec<_> = (0..10)
        .map(|_| tokio::spawn(async {
            Command::new("sleep")
                .arg("1")
                .output()
                .await
                .unwrap()
        }))
        .collect();

    for task in tasks {
        task.await.unwrap();
    }
    println!("⏱️ Async: {:?}", start.elapsed());  // ~1秒
}
```

**性能对比表**:

| 场景 | 同步 | 异步 | 提升 |
|------|------|------|------|
| 10个1秒进程 | 10秒 | 1秒 | 10x |
| 100个进程 | 100秒 | ~2秒 | 50x |
| 高I/O延迟 | 线性增长 | 常数时间 | 显著 |

---

## 3. 并发进程管理

### 3.1 基础并发

**并发启动多个进程**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let tasks = vec![
        tokio::spawn(run_task("task1")),
        tokio::spawn(run_task("task2")),
        tokio::spawn(run_task("task3")),
    ];

    for task in tasks {
        task.await??;
    }

    Ok(())
}

async fn run_task(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new(name).output().await?;
    println!("{} 完成: {:?}", name, output.status);
    Ok(())
}
```

---

### 3.2 使用join_all批量等待

```rust
use tokio::process::Command;
use futures::future::join_all;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let commands = vec!["echo", "date", "pwd"];

    let futures: Vec<_> = commands
        .into_iter()
        .map(|cmd| async move {
            Command::new(cmd)
                .output()
                .await
        })
        .collect();

    let results = join_all(futures).await;

    for (i, result) in results.into_iter().enumerate() {
        match result {
            Ok(output) => println!("✅ Task {}: {}", i, output.status),
            Err(e) => eprintln!("❌ Task {} failed: {}", i, e),
        }
    }

    Ok(())
}
```

---

### 3.3 限制并发数量（信号量）

```rust
use tokio::process::Command;
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let max_concurrent = 3;
    let semaphore = Arc::new(Semaphore::new(max_concurrent));

    let tasks: Vec<_> = (0..10)
        .map(|i| {
            let sem = semaphore.clone();
            tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                println!("🚀 Starting task {}", i);

                let output = Command::new("sleep")
                    .arg("1")
                    .output()
                    .await
                    .unwrap();

                println!("✅ Task {} completed", i);
                output
            })
        })
        .collect();

    for task in tasks {
        task.await?;
    }

    Ok(())
}
```

---

### 3.4 进程池实现

```rust
use tokio::process::Command;
use tokio::sync::mpsc;
use std::sync::Arc;

struct AsyncProcessPool {
    tx: mpsc::Sender<Task>,
}

struct Task {
    command: String,
    args: Vec<String>,
    result_tx: mpsc::Sender<Result<std::process::Output, std::io::Error>>,
}

impl AsyncProcessPool {
    fn new(worker_count: usize) -> Self {
        let (tx, mut rx) = mpsc::channel::<Task>(100);

        // 启动worker
        for i in 0..worker_count {
            let mut task_rx = rx.clone();
            tokio::spawn(async move {
                while let Some(task) = task_rx.recv().await {
                    println!("Worker {} executing: {}", i, task.command);

                    let result = Command::new(&task.command)
                        .args(&task.args)
                        .output()
                        .await;

                    let _ = task.result_tx.send(result).await;
                }
            });
        }

        Self { tx }
    }

    async fn execute(
        &self,
        command: String,
        args: Vec<String>,
    ) -> Result<std::process::Output, std::io::Error> {
        let (result_tx, mut result_rx) = mpsc::channel(1);

        self.tx.send(Task {
            command,
            args,
            result_tx,
        }).await.unwrap();

        result_rx.recv().await.unwrap()
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let pool = AsyncProcessPool::new(4);

    let mut tasks = Vec::new();
    for i in 0..10 {
        let pool = &pool;
        tasks.push(async move {
            pool.execute("echo".to_string(), vec![format!("Task {}", i)]).await
        });
    }

    futures::future::join_all(tasks).await;
    Ok(())
}
```

---

### 3.5 动态任务调度

```rust
use tokio::process::Command;
use tokio::sync::mpsc;
use std::collections::VecDeque;

struct DynamicScheduler {
    queue: Arc<Mutex<VecDeque<String>>>,
    max_workers: usize,
}

impl DynamicScheduler {
    fn new(max_workers: usize) -> Self {
        Self {
            queue: Arc::new(Mutex::new(VecDeque::new())),
            max_workers,
        }
    }

    async fn submit(&self, command: String) {
        self.queue.lock().await.push_back(command);
    }

    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut workers = Vec::new();

        for _ in 0..self.max_workers {
            let queue = self.queue.clone();

            workers.push(tokio::spawn(async move {
                loop {
                    let cmd = {
                        let mut q = queue.lock().await;
                        q.pop_front()
                    };

                    match cmd {
                        Some(cmd) => {
                            let _ = Command::new(&cmd).output().await;
                        }
                        None => {
                            tokio::time::sleep(Duration::from_millis(100)).await;
                        }
                    }
                }
            }));
        }

        // 可以动态添加任务
        // ...

        Ok(())
    }
}
```

---

### 3.6 优先级调度

```rust
use std::cmp::Ordering;
use std::collections::BinaryHeap;
use tokio::sync::Mutex;

#[derive(Eq, PartialEq)]
struct PrioritizedTask {
    priority: u32,
    command: String,
    id: u64,
}

impl Ord for PrioritizedTask {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority)  // 高优先级在前
            .then_with(|| self.id.cmp(&other.id))
    }
}

impl PartialOrd for PrioritizedTask {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

struct PriorityScheduler {
    queue: Arc<Mutex<BinaryHeap<PrioritizedTask>>>,
    next_id: Arc<Mutex<u64>>,
}

impl PriorityScheduler {
    fn new() -> Self {
        Self {
            queue: Arc::new(Mutex::new(BinaryHeap::new())),
            next_id: Arc::new(Mutex::new(0)),
        }
    }

    async fn submit(&self, command: String, priority: u32) {
        let id = {
            let mut next = self.next_id.lock().await;
            let id = *next;
            *next += 1;
            id
        };

        self.queue.lock().await.push(PrioritizedTask {
            priority,
            command,
            id,
        });
    }

    async fn execute_next(&self) -> Option<()> {
        let task = self.queue.lock().await.pop()?;

        println!("🚀 Executing priority {} task: {}",
            task.priority, task.command);

        let _ = Command::new(&task.command).output().await;
        Some(())
    }
}
```

---

## 4. 超时与取消

### 4.1 基础超时控制

```rust
use tokio::time::{timeout, Duration};
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let result = timeout(
        Duration::from_secs(5),
        Command::new("sleep")
            .arg("10")
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            println!("✅ 完成: {}", output.status);
        }
        Ok(Err(e)) => {
            eprintln!("❌ 进程错误: {}", e);
        }
        Err(_) => {
            eprintln!("⏰ 超时！进程运行超过5秒");
        }
    }

    Ok(())
}
```

---

### 4.2 带清理的超时

```rust
use tokio::time::{timeout, Duration};
use tokio::process::Command;

async fn execute_with_timeout(
    cmd: &str,
    timeout_secs: u64
) -> Result<std::process::Output, String> {
    let mut child = Command::new(cmd)
        .spawn()
        .map_err(|e| format!("Failed to spawn: {}", e))?;

    let result = timeout(
        Duration::from_secs(timeout_secs),
        child.wait()
    ).await;

    match result {
        Ok(Ok(status)) => {
            // 进程正常完成
            let output = child.wait_with_output().await
                .map_err(|e| format!("Failed to get output: {}", e))?;
            Ok(output)
        }
        Ok(Err(e)) => {
            Err(format!("Process error: {}", e))
        }
        Err(_) => {
            // 超时，强制终止
            println!("⏰ Timeout! Killing process...");
            child.kill().await.ok();
            Err("Timeout".to_string())
        }
    }
}

#[tokio::main]
async fn main() {
    match execute_with_timeout("sleep 100", 3).await {
        Ok(output) => println!("✅ Success: {:?}", output.status),
        Err(e) => eprintln!("❌ Error: {}", e),
    }
}
```

---

### 4.3 优雅取消

```rust
use tokio::process::Command;
use tokio::sync::oneshot;
use tokio::time::{sleep, Duration};

async fn cancellable_process(
    mut cancel_rx: oneshot::Receiver<()>
) -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("long_running_task")
        .spawn()?;

    tokio::select! {
        result = child.wait() => {
            match result {
                Ok(status) => println!("✅ Process finished: {}", status),
                Err(e) => eprintln!("❌ Process error: {}", e),
            }
        }
        _ = &mut cancel_rx => {
            println!("🛑 Received cancel signal");

            // 尝试优雅终止
            #[cfg(unix)]
            {
                use nix::sys::signal::{kill, Signal};
                use nix::unistd::Pid;

                let pid = Pid::from_raw(child.id().unwrap() as i32);
                let _ = kill(pid, Signal::SIGTERM);

                // 等待一段时间
                sleep(Duration::from_secs(5)).await;

                // 如果还未退出，强制终止
                if child.try_wait()?.is_none() {
                    child.kill().await?;
                }
            }

            #[cfg(not(unix))]
            {
                child.kill().await?;
            }
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (cancel_tx, cancel_rx) = oneshot::channel();

    let task = tokio::spawn(cancellable_process(cancel_rx));

    // 3秒后取消
    sleep(Duration::from_secs(3)).await;
    cancel_tx.send(()).ok();

    task.await??;
    Ok(())
}
```

---

### 4.4 多进程协调取消

```rust
use tokio::process::Command;
use tokio::sync::broadcast;
use std::sync::Arc;

struct ProcessGroup {
    cancel_tx: broadcast::Sender<()>,
}

impl ProcessGroup {
    fn new() -> Self {
        let (cancel_tx, _) = broadcast::channel(10);
        Self { cancel_tx }
    }

    async fn spawn_process(&self, cmd: &str) -> tokio::task::JoinHandle<()> {
        let mut cancel_rx = self.cancel_tx.subscribe();
        let cmd = cmd.to_string();

        tokio::spawn(async move {
            let mut child = Command::new(&cmd).spawn().unwrap();

            tokio::select! {
                _ = child.wait() => {
                    println!("✅ {} finished normally", cmd);
                }
                _ = cancel_rx.recv() => {
                    println!("🛑 {} cancelled", cmd);
                    child.kill().await.ok();
                }
            }
        })
    }

    fn cancel_all(&self) {
        let _ = self.cancel_tx.send(());
    }
}

#[tokio::main]
async fn main() {
    let group = Arc::new(ProcessGroup::new());

    let tasks = vec![
        group.spawn_process("sleep 10").await,
        group.spawn_process("sleep 10").await,
        group.spawn_process("sleep 10").await,
    ];

    // 3秒后取消所有进程
    tokio::time::sleep(Duration::from_secs(3)).await;
    group.cancel_all();

    for task in tasks {
        task.await.ok();
    }
}
```

---

### 4.5 重试机制

```rust
use tokio::process::Command;
use tokio::time::{sleep, Duration};

async fn retry_command(
    cmd: &str,
    args: &[&str],
    max_retries: usize,
    delay: Duration,
) -> Result<std::process::Output, String> {
    for attempt in 0..max_retries {
        println!("🔄 Attempt {}/{}", attempt + 1, max_retries);

        match Command::new(cmd).args(args).output().await {
            Ok(output) if output.status.success() => {
                println!("✅ Success on attempt {}", attempt + 1);
                return Ok(output);
            }
            Ok(output) => {
                eprintln!("❌ Failed with status: {}", output.status);
                if attempt < max_retries - 1 {
                    sleep(delay).await;
                }
            }
            Err(e) => {
                eprintln!("❌ Error: {}", e);
                if attempt < max_retries - 1 {
                    sleep(delay).await;
                } else {
                    return Err(format!("All {} attempts failed", max_retries));
                }
            }
        }
    }

    Err("Max retries exceeded".to_string())
}

#[tokio::main]
async fn main() {
    match retry_command("unstable_command", &[], 3, Duration::from_secs(2)).await {
        Ok(output) => println!("Output: {}", String::from_utf8_lossy(&output.stdout)),
        Err(e) => eprintln!("Failed: {}", e),
    }
}
```

---

### 4.6 断路器模式

```rust
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use tokio::time::{sleep, Duration, Instant};

struct CircuitBreaker {
    failure_count: Arc<AtomicU32>,
    threshold: u32,
    timeout: Duration,
    last_failure: Arc<Mutex<Option<Instant>>>,
}

impl CircuitBreaker {
    fn new(threshold: u32, timeout: Duration) -> Self {
        Self {
            failure_count: Arc::new(AtomicU32::new(0)),
            threshold,
            timeout,
            last_failure: Arc::new(Mutex::new(None)),
        }
    }

    async fn is_open(&self) -> bool {
        let count = self.failure_count.load(Ordering::Relaxed);
        if count >= self.threshold {
            let last = self.last_failure.lock().await;
            if let Some(time) = *last {
                return time.elapsed() < self.timeout;
            }
        }
        false
    }

    async fn record_success(&self) {
        self.failure_count.store(0, Ordering::Relaxed);
    }

    async fn record_failure(&self) {
        self.failure_count.fetch_add(1, Ordering::Relaxed);
        *self.last_failure.lock().await = Some(Instant::now());
    }

    async fn execute<F, T>(&self, f: F) -> Result<T, String>
    where
        F: Future<Output = Result<T, String>>,
    {
        if self.is_open().await {
            return Err("Circuit breaker is open".to_string());
        }

        match f.await {
            Ok(result) => {
                self.record_success().await;
                Ok(result)
            }
            Err(e) => {
                self.record_failure().await;
                Err(e)
            }
        }
    }
}
```

---

## 5. 实战案例

### 案例1: 异步批处理系统

```rust
use tokio::process::Command;
use tokio::sync::mpsc;
use std::path::PathBuf;

struct BatchProcessor {
    input_queue: mpsc::Receiver<PathBuf>,
    max_workers: usize,
}

impl BatchProcessor {
    fn new(max_workers: usize) -> (Self, mpsc::Sender<PathBuf>) {
        let (tx, rx) = mpsc::channel(1000);

        (Self {
            input_queue: rx,
            max_workers,
        }, tx)
    }

    async fn run(mut self) -> Result<(), Box<dyn std::error::Error>> {
        let semaphore = Arc::new(Semaphore::new(self.max_workers));
        let mut handles = Vec::new();

        while let Some(file) = self.input_queue.recv().await {
            let sem = semaphore.clone();

            let handle = tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();

                println!("🔄 Processing: {:?}", file);

                let output = Command::new("ffmpeg")
                    .arg("-i")
                    .arg(&file)
                    .arg("-codec:v")
                    .arg("libx264")
                    .arg(file.with_extension("mp4"))
                    .output()
                    .await
                    .unwrap();

                if output.status.success() {
                    println!("✅ Completed: {:?}", file);
                } else {
                    eprintln!("❌ Failed: {:?}", file);
                }
            });

            handles.push(handle);
        }

        // 等待所有任务完成
        for handle in handles {
            handle.await?;
        }

        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (processor, tx) = BatchProcessor::new(4);

    // 启动处理器
    let processor_handle = tokio::spawn(processor.run());

    // 提交任务
    for i in 1..=20 {
        tx.send(PathBuf::from(format!("video_{}.avi", i))).await?;
    }
    drop(tx);  // 关闭队列

    processor_handle.await??;
    Ok(())
}
```

---

### 案例2: 分布式任务执行器

```rust
use tokio::process::Command;
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Task {
    id: u64,
    command: String,
    args: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct TaskResult {
    id: u64,
    success: bool,
    output: String,
}

struct RemoteExecutor {
    listener: TcpListener,
}

impl RemoteExecutor {
    async fn new(addr: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            listener: TcpListener::bind(addr).await?,
        })
    }

    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        loop {
            let (mut socket, addr) = self.listener.accept().await?;
            println!("✅ New connection from: {}", addr);

            tokio::spawn(async move {
                let mut buffer = vec![0; 4096];

                match socket.read(&mut buffer).await {
                    Ok(n) => {
                        let task: Task = bincode::deserialize(&buffer[..n]).unwrap();
                        println!("📥 Received task {}: {}", task.id, task.command);

                        // 执行任务
                        let output = Command::new(&task.command)
                            .args(&task.args)
                            .output()
                            .await
                            .unwrap();

                        let result = TaskResult {
                            id: task.id,
                            success: output.status.success(),
                            output: String::from_utf8_lossy(&output.stdout).to_string(),
                        };

                        // 发送结果
                        let result_data = bincode::serialize(&result).unwrap();
                        socket.write_all(&result_data).await.ok();
                    }
                    Err(e) => {
                        eprintln!("❌ Error: {}", e);
                    }
                }
            });
        }
    }
}
```

---

### 案例3: 日志聚合器

```rust
use tokio::process::Command;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::sync::mpsc;

struct LogAggregator {
    log_tx: mpsc::Sender<(String, String)>,  // (source, line)
}

impl LogAggregator {
    fn new() -> (Self, mpsc::Receiver<(String, String)>) {
        let (tx, rx) = mpsc::channel(1000);
        (Self { log_tx: tx }, rx)
    }

    async fn monitor_process(&self, name: String, cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut child = Command::new(cmd)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        let stdout = child.stdout.take().unwrap();
        let stderr = child.stderr.take().unwrap();

        let tx = self.log_tx.clone();
        let name_clone = name.clone();
        tokio::spawn(async move {
            let reader = BufReader::new(stdout);
            let mut lines = reader.lines();
            while let Some(line) = lines.next_line().await.unwrap() {
                tx.send((name_clone.clone(), line)).await.ok();
            }
        });

        let tx = self.log_tx.clone();
        tokio::spawn(async move {
            let reader = BufReader::new(stderr);
            let mut lines = reader.lines();
            while let Some(line) = lines.next_line().await.unwrap() {
                tx.send((name.clone(), format!("[ERROR] {}", line))).await.ok();
            }
        });

        child.wait().await?;
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (aggregator, mut log_rx) = LogAggregator::new();

    // 监控多个进程
    tokio::spawn({
        let agg = aggregator.clone();
        async move {
            agg.monitor_process("service1".to_string(), "your_service1").await.ok();
        }
    });

    tokio::spawn({
        let agg = aggregator.clone();
        async move {
            agg.monitor_process("service2".to_string(), "your_service2").await.ok();
        }
    });

    // 聚合日志
    while let Some((source, line)) = log_rx.recv().await {
        println!("[{}] {}", source, line);
    }

    Ok(())
}
```

---

### 案例4: 健康检查监控

```rust
use tokio::process::Command;
use tokio::time::{interval, Duration};
use std::collections::HashMap;

struct HealthMonitor {
    services: HashMap<String, ServiceConfig>,
}

struct ServiceConfig {
    check_command: String,
    check_interval: Duration,
    failure_threshold: u32,
}

impl HealthMonitor {
    fn new() -> Self {
        Self {
            services: HashMap::new(),
        }
    }

    fn add_service(&mut self, name: String, config: ServiceConfig) {
        self.services.insert(name, config);
    }

    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut handles = Vec::new();

        for (name, config) in &self.services {
            let name = name.clone();
            let cmd = config.check_command.clone();
            let check_interval = config.check_interval;
            let threshold = config.failure_threshold;

            handles.push(tokio::spawn(async move {
                let mut failures = 0;
                let mut ticker = interval(check_interval);

                loop {
                    ticker.tick().await;

                    match Command::new("sh").arg("-c").arg(&cmd).output().await {
                        Ok(output) if output.status.success() => {
                            if failures > 0 {
                                println!("✅ {} recovered", name);
                            }
                            failures = 0;
                        }
                        _ => {
                            failures += 1;
                            eprintln!("⚠️  {} health check failed ({}/{})",
                                name, failures, threshold);

                            if failures >= threshold {
                                eprintln!("🚨 {} is DOWN!", name);
                                // 触发告警
                            }
                        }
                    }
                }
            }));
        }

        futures::future::join_all(handles).await;
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut monitor = HealthMonitor::new();

    monitor.add_service("web_server".to_string(), ServiceConfig {
        check_command: "curl -f http://localhost:8080/health".to_string(),
        check_interval: Duration::from_secs(10),
        failure_threshold: 3,
    });

    monitor.add_service("database".to_string(), ServiceConfig {
        check_command: "pg_isready -h localhost".to_string(),
        check_interval: Duration::from_secs(30),
        failure_threshold: 2,
    });

    monitor.run().await?;
    Ok(())
}
```

---

## 6. 性能优化与最佳实践

### 6.1 选择合适的运行时配置

```rust
// 单线程运行时（适合I/O密集型）
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // ...
}

// 多线程运行时（适合混合负载）
#[tokio::main(flavor = "multi_thread", worker_threads = 4)]
async fn main() {
    // ...
}

// 自定义运行时
use tokio::runtime::Builder;

fn custom_runtime() {
    let rt = Builder::new_multi_thread()
        .worker_threads(8)
        .thread_name("my-worker")
        .thread_stack_size(3 * 1024 * 1024)
        .build()
        .unwrap();

    rt.block_on(async {
        // ...
    });
}
```

---

### 6.2 避免阻塞

```rust
// ❌ 错误：在异步代码中阻塞
#[tokio::main]
async fn bad_example() {
    let output = std::process::Command::new("ls")  // 同步！
        .output()
        .unwrap();
}

// ✅ 正确：使用异步版本
#[tokio::main]
async fn good_example() {
    let output = tokio::process::Command::new("ls")
        .output()
        .await
        .unwrap();
}

// ✅ 如果必须调用阻塞代码，使用spawn_blocking
#[tokio::main]
async fn blocking_example() {
    let result = tokio::task::spawn_blocking(|| {
        // 阻塞操作
        std::process::Command::new("heavy_sync_task")
            .output()
            .unwrap()
    }).await.unwrap();
}
```

---

### 6.3 资源管理

```rust
use tokio::process::Command;
use std::sync::Arc;
use tokio::sync::Semaphore;

struct ResourcePool {
    semaphore: Arc<Semaphore>,
}

impl ResourcePool {
    fn new(max_concurrent: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }

    async fn execute(&self, cmd: &str) -> Result<std::process::Output, std::io::Error> {
        let _permit = self.semaphore.acquire().await.unwrap();

        Command::new(cmd).output().await
    }
}

#[tokio::main]
async fn main() {
    let pool = Arc::new(ResourcePool::new(10));

    let mut handles = Vec::new();
    for _ in 0..100 {
        let pool = pool.clone();
        handles.push(tokio::spawn(async move {
            pool.execute("task").await
        }));
    }

    futures::future::join_all(handles).await;
}
```

---

### 6.4 错误处理最佳实践

```rust
use tokio::process::Command;

#[derive(Debug)]
enum ProcessError {
    SpawnFailed(std::io::Error),
    ExecutionFailed {
        code: Option<i32>,
        stderr: String
    },
    Timeout,
}

async fn execute_robust(
    cmd: &str,
    timeout_secs: u64
) -> Result<String, ProcessError> {
    let mut child = Command::new(cmd)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(ProcessError::SpawnFailed)?;

    let result = tokio::time::timeout(
        Duration::from_secs(timeout_secs),
        child.wait_with_output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            if output.status.success() {
                Ok(String::from_utf8_lossy(&output.stdout).to_string())
            } else {
                Err(ProcessError::ExecutionFailed {
                    code: output.status.code(),
                    stderr: String::from_utf8_lossy(&output.stderr).to_string(),
                })
            }
        }
        Ok(Err(e)) => Err(ProcessError::SpawnFailed(e)),
        Err(_) => {
            child.kill().await.ok();
            Err(ProcessError::Timeout)
        }
    }
}
```

---

### 6.5 监控和调试

```rust
use tokio::process::Command;
use std::time::Instant;

async fn execute_with_metrics(cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
    let start = Instant::now();

    println!("🚀 Starting: {}", cmd);

    let output = Command::new(cmd).output().await?;

    let duration = start.elapsed();

    println!("⏱️  Duration: {:?}", duration);
    println!("📊 Status: {}", output.status);
    println!("📏 Stdout: {} bytes", output.stdout.len());
    println!("📏 Stderr: {} bytes", output.stderr.len());

    Ok(())
}

// 使用tracing进行结构化日志
use tracing::{info, warn, error, instrument};

#[instrument]
async fn execute_instrumented(cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
    info!("Executing command: {}", cmd);

    let output = Command::new(cmd).output().await?;

    if output.status.success() {
        info!("Command completed successfully");
    } else {
        warn!("Command failed with status: {}", output.status);
    }

    Ok(())
}
```

---

## 7. 常见陷阱与解决方案

### 陷阱1: 忘记await

```rust
// ❌ 错误：忘记await
let _output = Command::new("ls").output();  // 返回Future，不执行

// ✅ 正确
let output = Command::new("ls").output().await?;
```

---

### 陷阱2: 死锁

```rust
// ❌ 可能死锁
let mut child = Command::new("cat").stdin(Stdio::piped()).spawn()?;
child.stdin.as_mut().unwrap().write_all(&huge_data).await?;
child.wait().await?;  // 可能永远等待

// ✅ 正确：在单独任务中写入
let mut stdin = child.stdin.take().unwrap();
tokio::spawn(async move {
    stdin.write_all(&huge_data).await.ok();
});
child.wait().await?;
```

---

### 陷阱3: 资源泄漏

```rust
// ❌ 可能泄漏：忘记等待
for i in 0..1000 {
    tokio::spawn(async move {
        Command::new("task").output().await.ok();
    });
}  // 任务可能还在运行

// ✅ 正确：收集handles并等待
let handles: Vec<_> = (0..1000)
    .map(|_| tokio::spawn(async {
        Command::new("task").output().await
    }))
    .collect();

for handle in handles {
    handle.await.ok();
}
```

---

## 下一步

- [进程管理快速入门](./01_进程管理快速入门.md)
- [IPC通信实践](./02_IPC通信实践.md)
- [进程模型参考](../tier_03_references/01_进程模型参考.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-22
**适用版本**: Rust 1.90+
