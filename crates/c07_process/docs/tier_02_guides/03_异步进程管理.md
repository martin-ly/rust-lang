# Tier 2: å¼‚æ­¥è¿›ç¨‹ç®¡ç†

> **æ–‡æ¡£ç±»å‹**: å®è·µæŒ‡å—
> **éš¾åº¦**: â­â­â­ ä¸­çº§
> **é¢„è®¡æ—¶é—´**: 2å°æ—¶
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+

---

## ç›®å½•

- [Tier 2: å¼‚æ­¥è¿›ç¨‹ç®¡ç†](#tier-2-å¼‚æ­¥è¿›ç¨‹ç®¡ç†)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
  - [1. ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥](#1-ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥)
  - [2. Tokio Process](#2-tokio-process)
    - [2.1 åŸºç¡€å¼‚æ­¥è¿›ç¨‹](#21-åŸºç¡€å¼‚æ­¥è¿›ç¨‹)
    - [2.2 å¼‚æ­¥æ•è·å’Œæµå¼å¤„ç†](#22-å¼‚æ­¥æ•è·å’Œæµå¼å¤„ç†)
    - [2.3 åŒæ—¶è¯»å–stdoutå’Œstderr](#23-åŒæ—¶è¯»å–stdoutå’Œstderr)
    - [2.4 å¼‚æ­¥å†™å…¥stdin](#24-å¼‚æ­¥å†™å…¥stdin)
    - [2.5 å®Œæ•´çš„åŒå‘é€šä¿¡](#25-å®Œæ•´çš„åŒå‘é€šä¿¡)
    - [2.6 æ€§èƒ½å¯¹æ¯”](#26-æ€§èƒ½å¯¹æ¯”)
  - [3. å¹¶å‘è¿›ç¨‹ç®¡ç†](#3-å¹¶å‘è¿›ç¨‹ç®¡ç†)
    - [3.1 åŸºç¡€å¹¶å‘](#31-åŸºç¡€å¹¶å‘)
    - [3.2 ä½¿ç”¨join\_allæ‰¹é‡ç­‰å¾…](#32-ä½¿ç”¨join_allæ‰¹é‡ç­‰å¾…)
    - [3.3 é™åˆ¶å¹¶å‘æ•°é‡ï¼ˆä¿¡å·é‡ï¼‰](#33-é™åˆ¶å¹¶å‘æ•°é‡ä¿¡å·é‡)
    - [3.4 è¿›ç¨‹æ± å®ç°](#34-è¿›ç¨‹æ± å®ç°)
    - [3.5 åŠ¨æ€ä»»åŠ¡è°ƒåº¦](#35-åŠ¨æ€ä»»åŠ¡è°ƒåº¦)
    - [3.6 ä¼˜å…ˆçº§è°ƒåº¦](#36-ä¼˜å…ˆçº§è°ƒåº¦)
  - [4. è¶…æ—¶ä¸å–æ¶ˆ](#4-è¶…æ—¶ä¸å–æ¶ˆ)
    - [4.1 åŸºç¡€è¶…æ—¶æ§åˆ¶](#41-åŸºç¡€è¶…æ—¶æ§åˆ¶)
    - [4.2 å¸¦æ¸…ç†çš„è¶…æ—¶](#42-å¸¦æ¸…ç†çš„è¶…æ—¶)
    - [4.3 ä¼˜é›…å–æ¶ˆ](#43-ä¼˜é›…å–æ¶ˆ)
    - [4.4 å¤šè¿›ç¨‹åè°ƒå–æ¶ˆ](#44-å¤šè¿›ç¨‹åè°ƒå–æ¶ˆ)
    - [4.5 é‡è¯•æœºåˆ¶](#45-é‡è¯•æœºåˆ¶)
    - [4.6 æ–­è·¯å™¨æ¨¡å¼](#46-æ–­è·¯å™¨æ¨¡å¼)
  - [5. å®æˆ˜æ¡ˆä¾‹](#5-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: å¼‚æ­¥æ‰¹å¤„ç†ç³»ç»Ÿ](#æ¡ˆä¾‹1-å¼‚æ­¥æ‰¹å¤„ç†ç³»ç»Ÿ)
    - [æ¡ˆä¾‹2: åˆ†å¸ƒå¼ä»»åŠ¡æ‰§è¡Œå™¨](#æ¡ˆä¾‹2-åˆ†å¸ƒå¼ä»»åŠ¡æ‰§è¡Œå™¨)
    - [æ¡ˆä¾‹3: æ—¥å¿—èšåˆå™¨](#æ¡ˆä¾‹3-æ—¥å¿—èšåˆå™¨)
    - [æ¡ˆä¾‹4: å¥åº·æ£€æŸ¥ç›‘æ§](#æ¡ˆä¾‹4-å¥åº·æ£€æŸ¥ç›‘æ§)
  - [6. æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ](#6-æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ)
    - [6.1 é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶é…ç½®](#61-é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶é…ç½®)
    - [6.2 é¿å…é˜»å¡](#62-é¿å…é˜»å¡)
    - [6.3 èµ„æºç®¡ç†](#63-èµ„æºç®¡ç†)
    - [6.4 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ](#64-é”™è¯¯å¤„ç†æœ€ä½³å®è·µ)
    - [6.5 ç›‘æ§å’Œè°ƒè¯•](#65-ç›‘æ§å’Œè°ƒè¯•)
  - [7. å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ](#7-å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ)
    - [é™·é˜±1: å¿˜è®°await](#é™·é˜±1-å¿˜è®°await)
    - [é™·é˜±2: æ­»é”](#é™·é˜±2-æ­»é”)
    - [é™·é˜±3: èµ„æºæ³„æ¼](#é™·é˜±3-èµ„æºæ³„æ¼)
  - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å¼‚æ­¥è¿›ç¨‹ç®¡ç† (Async Process Management)**:

- **å®šä¹‰**: ä½¿ç”¨å¼‚æ­¥è¿è¡Œæ—¶ç®¡ç†è¿›ç¨‹çš„æŠ€æœ¯ï¼Œæ”¯æŒå¹¶å‘è¿›ç¨‹è°ƒåº¦ã€è¶…æ—¶æ§åˆ¶å’Œä¼˜é›…å–æ¶ˆ
- **ç±»å‹**: è¿›ç¨‹ç®¡ç†æŠ€æœ¯
- **èŒƒç•´**: ç³»ç»Ÿç¼–ç¨‹ã€å¼‚æ­¥ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.39+ (Tokio)
- **ç›¸å…³æ¦‚å¿µ**: è¿›ç¨‹ã€å¼‚æ­¥è¿è¡Œæ—¶ã€å¹¶å‘è°ƒåº¦ã€è¶…æ—¶æ§åˆ¶

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å¹¶å‘è°ƒåº¦**: åŒæ—¶ç®¡ç†å¤šä¸ªå­è¿›ç¨‹
- **éé˜»å¡**: ä¸é˜»å¡å¼‚æ­¥è¿è¡Œæ—¶
- **è¶…æ—¶æ§åˆ¶**: æ”¯æŒè¿›ç¨‹è¶…æ—¶å’Œå–æ¶ˆ
- **èµ„æºç®¡ç†**: è‡ªåŠ¨æ¸…ç†è¿›ç¨‹èµ„æº

**æ€§èƒ½ç‰¹å¾**:

- **é«˜å¹¶å‘**: å¯åŒæ—¶ç®¡ç†å¤§é‡è¿›ç¨‹
- **ä½å¼€é”€**: æ¯”çº¿ç¨‹æ›´èŠ‚çœèµ„æº
- **é€‚ç”¨åœºæ™¯**: I/O å¯†é›†å‹ã€å¤šè¿›ç¨‹ç®¡ç†ã€è¶…æ—¶æ§åˆ¶

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- å¼‚æ­¥è¿›ç¨‹ç®¡ç† --[is-a]--> è¿›ç¨‹ç®¡ç†
- Tokio è¿›ç¨‹ç®¡ç† --[is-a]--> å¼‚æ­¥è¿›ç¨‹ç®¡ç†

**ç»„åˆå…³ç³»**:

- å¼‚æ­¥è¿›ç¨‹ç®¡ç† --[uses]--> å¼‚æ­¥è¿è¡Œæ—¶
- è¿›ç¨‹æ±  --[uses]--> å¼‚æ­¥è¿›ç¨‹ç®¡ç†

**ä¾èµ–å…³ç³»**:

- å¼‚æ­¥è¿›ç¨‹ç®¡ç† --[depends-on]--> Tokio
- å¼‚æ­¥è¿›ç¨‹ç®¡ç† --[depends-on]--> æ“ä½œç³»ç»Ÿè¿›ç¨‹æ”¯æŒ

### æ€ç»´å¯¼å›¾

```text
å¼‚æ­¥è¿›ç¨‹ç®¡ç†
â”‚
â”œâ”€â”€ Tokio Process
â”‚   â”œâ”€â”€ åŸºç¡€å¼‚æ­¥è¿›ç¨‹
â”‚   â”œâ”€â”€ æµå¼å¤„ç†
â”‚   â””â”€â”€ åŒå‘é€šä¿¡
â”œâ”€â”€ å¹¶å‘è¿›ç¨‹ç®¡ç†
â”‚   â”œâ”€â”€ å¹¶å‘æ‰§è¡Œ
â”‚   â”œâ”€â”€ è¿›ç¨‹æ± 
â”‚   â””â”€â”€ ä¼˜å…ˆçº§è°ƒåº¦
â”œâ”€â”€ è¶…æ—¶ä¸å–æ¶ˆ
â”‚   â”œâ”€â”€ è¶…æ—¶æ§åˆ¶
â”‚   â”œâ”€â”€ ä¼˜é›…å–æ¶ˆ
â”‚   â””â”€â”€ é‡è¯•æœºåˆ¶
â””â”€â”€ å®æˆ˜æ¡ˆä¾‹
    â”œâ”€â”€ æ‰¹å¤„ç†ç³»ç»Ÿ
    â””â”€â”€ ä»»åŠ¡æ‰§è¡Œå™¨
```

---

## å­¦ä¹ ç›®æ ‡

- âœ… ç†è§£å¼‚æ­¥è¿›ç¨‹ç®¡ç†çš„ä¼˜åŠ¿
- âœ… ä½¿ç”¨Tokioç®¡ç†è¿›ç¨‹
- âœ… å®ç°å¹¶å‘è¿›ç¨‹è°ƒåº¦
- âœ… å¤„ç†è¶…æ—¶å’Œå–æ¶ˆ

---

## 1. ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥

**é€‚åˆå¼‚æ­¥çš„åœºæ™¯**:

- âœ… åŒæ—¶ç®¡ç†å¤šä¸ªå­è¿›ç¨‹
- âœ… I/Oå¯†é›†å‹æ“ä½œ
- âœ… éœ€è¦è¶…æ—¶æ§åˆ¶
- âœ… ä¸å¼‚æ­¥ç”Ÿæ€é›†æˆ

**ä¸é€‚åˆå¼‚æ­¥**:

- âŒ å•ä¸ªè¿›ç¨‹ç®€å•æ‰§è¡Œ
- âŒ CPUå¯†é›†å‹ä»»åŠ¡

---

## 2. Tokio Process

### 2.1 åŸºç¡€å¼‚æ­¥è¿›ç¨‹

**æœ€ç®€å•çš„å¼‚æ­¥è¿›ç¨‹æ‰§è¡Œ**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new("echo")
        .arg("Hello Async!")
        .output()
        .await?;

    println!("stdout: {}", String::from_utf8_lossy(&output.stdout));
    println!("stderr: {}", String::from_utf8_lossy(&output.stderr));
    println!("status: {}", output.status);

    Ok(())
}
```

---

### 2.2 å¼‚æ­¥æ•è·å’Œæµå¼å¤„ç†

**æµå¼è¯»å–stdout**:

```rust
use tokio::process::{Command, ChildStdout};
use tokio::io::{AsyncReadExt, AsyncBufReadExt, BufReader};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("cat")
        .arg("large_file.txt")
        .stdout(Stdio::piped())
        .spawn()?;

    if let Some(stdout) = child.stdout.take() {
        let reader = BufReader::new(stdout);
        let mut lines = reader.lines();

        while let Some(line) = lines.next_line().await? {
            println!("ğŸ“¥ Line: {}", line);
        }
    }

    let status = child.wait().await?;
    println!("âœ… Process exited: {}", status);

    Ok(())
}
```

---

### 2.3 åŒæ—¶è¯»å–stdoutå’Œstderr

```rust
use tokio::process::Command;
use tokio::io::AsyncBufReadExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("sh")
        .arg("-c")
        .arg("echo stdout; echo stderr >&2")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let stdout = child.stdout.take().unwrap();
    let stderr = child.stderr.take().unwrap();

    // å¹¶å‘è¯»å–stdoutå’Œstderr
    let stdout_task = tokio::spawn(async move {
        let reader = BufReader::new(stdout);
        let mut lines = reader.lines();
        while let Some(line) = lines.next_line().await.unwrap() {
            println!("[stdout] {}", line);
        }
    });

    let stderr_task = tokio::spawn(async move {
        let reader = BufReader::new(stderr);
        let mut lines = reader.lines();
        while let Some(line) = lines.next_line().await.unwrap() {
            eprintln!("[stderr] {}", line);
        }
    });

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    stdout_task.await?;
    stderr_task.await?;
    child.wait().await?;

    Ok(())
}
```

---

### 2.4 å¼‚æ­¥å†™å…¥stdin

```rust
use tokio::process::Command;
use tokio::io::AsyncWriteExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("grep")
        .arg("pattern")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    // å¼‚æ­¥å†™å…¥stdin
    if let Some(mut stdin) = child.stdin.take() {
        tokio::spawn(async move {
            stdin.write_all(b"line with pattern\n").await.unwrap();
            stdin.write_all(b"line without\n").await.unwrap();
            stdin.write_all(b"another line with pattern\n").await.unwrap();
            // stdinè‡ªåŠ¨å…³é—­
        });
    }

    // è¯»å–è¾“å‡º
    let output = child.wait_with_output().await?;
    println!("Output:\n{}", String::from_utf8_lossy(&output.stdout));

    Ok(())
}
```

---

### 2.5 å®Œæ•´çš„åŒå‘é€šä¿¡

```rust
use tokio::process::Command;
use tokio::io::{AsyncWriteExt, AsyncBufReadExt, BufReader};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("python3")
        .arg("-c")
        .arg("import sys; [print(line.strip().upper()) for line in sys.stdin]")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    let mut stdin = child.stdin.take().unwrap();
    let stdout = child.stdout.take().unwrap();

    // åœ¨å•ç‹¬çš„ä»»åŠ¡ä¸­å†™å…¥
    let write_task = tokio::spawn(async move {
        for i in 1..=5 {
            stdin.write_all(format!("message {}\n", i).as_bytes()).await.unwrap();
        }
        drop(stdin);  // å…³é—­stdin
    });

    // ä¸»ä»»åŠ¡è¯»å–
    let reader = BufReader::new(stdout);
    let mut lines = reader.lines();
    while let Some(line) = lines.next_line().await? {
        println!("ğŸ“¥ Received: {}", line);
    }

    write_task.await?;
    child.wait().await?;

    Ok(())
}
```

---

### 2.6 æ€§èƒ½å¯¹æ¯”

**åŒæ­¥ vs å¼‚æ­¥å¤„ç†10ä¸ªè¿›ç¨‹**:

```rust
use std::time::Instant;

// åŒæ­¥ç‰ˆæœ¬
fn sync_version() {
    use std::process::Command;

    let start = Instant::now();
    for i in 0..10 {
        Command::new("sleep")
            .arg("1")
            .output()
            .unwrap();
    }
    println!("â±ï¸ Sync: {:?}", start.elapsed());  // ~10ç§’
}

// å¼‚æ­¥ç‰ˆæœ¬
#[tokio::main]
async fn async_version() {
    use tokio::process::Command;

    let start = Instant::now();
    let tasks: Vec<_> = (0..10)
        .map(|_| tokio::spawn(async {
            Command::new("sleep")
                .arg("1")
                .output()
                .await
                .unwrap()
        }))
        .collect();

    for task in tasks {
        task.await.unwrap();
    }
    println!("â±ï¸ Async: {:?}", start.elapsed());  // ~1ç§’
}
```

**æ€§èƒ½å¯¹æ¯”è¡¨**:

| åœºæ™¯ | åŒæ­¥ | å¼‚æ­¥ | æå‡ |
| --- | --- | --- | --- |
| 10ä¸ª1ç§’è¿›ç¨‹ | 10ç§’ | 1ç§’ | 10x |
| 100ä¸ªè¿›ç¨‹ | 100ç§’ | ~2ç§’ | 50x |
| é«˜I/Oå»¶è¿Ÿ | çº¿æ€§å¢é•¿ | å¸¸æ•°æ—¶é—´ | æ˜¾è‘— |

---

## 3. å¹¶å‘è¿›ç¨‹ç®¡ç†

### 3.1 åŸºç¡€å¹¶å‘

**å¹¶å‘å¯åŠ¨å¤šä¸ªè¿›ç¨‹**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let tasks = vec![
        tokio::spawn(run_task("task1")),
        tokio::spawn(run_task("task2")),
        tokio::spawn(run_task("task3")),
    ];

    for task in tasks {
        task.await??;
    }

    Ok(())
}

async fn run_task(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new(name).output().await?;
    println!("{} å®Œæˆ: {:?}", name, output.status);
    Ok(())
}
```

---

### 3.2 ä½¿ç”¨join_allæ‰¹é‡ç­‰å¾…

```rust
use tokio::process::Command;
use futures::future::join_all;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let commands = vec!["echo", "date", "pwd"];

    let futures: Vec<_> = commands
        .into_iter()
        .map(|cmd| async move {
            Command::new(cmd)
                .output()
                .await
        })
        .collect();

    let results = join_all(futures).await;

    for (i, result) in results.into_iter().enumerate() {
        match result {
            Ok(output) => println!("âœ… Task {}: {}", i, output.status),
            Err(e) => eprintln!("âŒ Task {} failed: {}", i, e),
        }
    }

    Ok(())
}
```

---

### 3.3 é™åˆ¶å¹¶å‘æ•°é‡ï¼ˆä¿¡å·é‡ï¼‰

```rust
use tokio::process::Command;
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let max_concurrent = 3;
    let semaphore = Arc::new(Semaphore::new(max_concurrent));

    let tasks: Vec<_> = (0..10)
        .map(|i| {
            let sem = semaphore.clone();
            tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                println!("ğŸš€ Starting task {}", i);

                let output = Command::new("sleep")
                    .arg("1")
                    .output()
                    .await
                    .unwrap();

                println!("âœ… Task {} completed", i);
                output
            })
        })
        .collect();

    for task in tasks {
        task.await?;
    }

    Ok(())
}
```

---

### 3.4 è¿›ç¨‹æ± å®ç°

```rust
use tokio::process::Command;
use tokio::sync::mpsc;
use std::sync::Arc;

struct AsyncProcessPool {
    tx: mpsc::Sender<Task>,
}

struct Task {
    command: String,
    args: Vec<String>,
    result_tx: mpsc::Sender<Result<std::process::Output, std::io::Error>>,
}

impl AsyncProcessPool {
    fn new(worker_count: usize) -> Self {
        let (tx, mut rx) = mpsc::channel::<Task>(100);

        // å¯åŠ¨worker
        for i in 0..worker_count {
            let mut task_rx = rx.clone();
            tokio::spawn(async move {
                while let Some(task) = task_rx.recv().await {
                    println!("Worker {} executing: {}", i, task.command);

                    let result = Command::new(&task.command)
                        .args(&task.args)
                        .output()
                        .await;

                    let _ = task.result_tx.send(result).await;
                }
            });
        }

        Self { tx }
    }

    async fn execute(
        &self,
        command: String,
        args: Vec<String>,
    ) -> Result<std::process::Output, std::io::Error> {
        let (result_tx, mut result_rx) = mpsc::channel(1);

        self.tx.send(Task {
            command,
            args,
            result_tx,
        }).await.unwrap();

        result_rx.recv().await.unwrap()
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let pool = AsyncProcessPool::new(4);

    let mut tasks = Vec::new();
    for i in 0..10 {
        let pool = &pool;
        tasks.push(async move {
            pool.execute("echo".to_string(), vec![format!("Task {}", i)]).await
        });
    }

    futures::future::join_all(tasks).await;
    Ok(())
}
```

---

### 3.5 åŠ¨æ€ä»»åŠ¡è°ƒåº¦

```rust
use tokio::process::Command;
use tokio::sync::mpsc;
use std::collections::VecDeque;

struct DynamicScheduler {
    queue: Arc<Mutex<VecDeque<String>>>,
    max_workers: usize,
}

impl DynamicScheduler {
    fn new(max_workers: usize) -> Self {
        Self {
            queue: Arc::new(Mutex::new(VecDeque::new())),
            max_workers,
        }
    }

    async fn submit(&self, command: String) {
        self.queue.lock().await.push_back(command);
    }

    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut workers = Vec::new();

        for _ in 0..self.max_workers {
            let queue = self.queue.clone();

            workers.push(tokio::spawn(async move {
                loop {
                    let cmd = {
                        let mut q = queue.lock().await;
                        q.pop_front()
                    };

                    match cmd {
                        Some(cmd) => {
                            let _ = Command::new(&cmd).output().await;
                        }
                        None => {
                            tokio::time::sleep(Duration::from_millis(100)).await;
                        }
                    }
                }
            }));
        }

        // å¯ä»¥åŠ¨æ€æ·»åŠ ä»»åŠ¡
        // ...

        Ok(())
    }
}
```

---

### 3.6 ä¼˜å…ˆçº§è°ƒåº¦

```rust
use std::cmp::Ordering;
use std::collections::BinaryHeap;
use tokio::sync::Mutex;

#[derive(Eq, PartialEq)]
struct PrioritizedTask {
    priority: u32,
    command: String,
    id: u64,
}

impl Ord for PrioritizedTask {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority)  // é«˜ä¼˜å…ˆçº§åœ¨å‰
            .then_with(|| self.id.cmp(&other.id))
    }
}

impl PartialOrd for PrioritizedTask {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

struct PriorityScheduler {
    queue: Arc<Mutex<BinaryHeap<PrioritizedTask>>>,
    next_id: Arc<Mutex<u64>>,
}

impl PriorityScheduler {
    fn new() -> Self {
        Self {
            queue: Arc::new(Mutex::new(BinaryHeap::new())),
            next_id: Arc::new(Mutex::new(0)),
        }
    }

    async fn submit(&self, command: String, priority: u32) {
        let id = {
            let mut next = self.next_id.lock().await;
            let id = *next;
            *next += 1;
            id
        };

        self.queue.lock().await.push(PrioritizedTask {
            priority,
            command,
            id,
        });
    }

    async fn execute_next(&self) -> Option<()> {
        let task = self.queue.lock().await.pop()?;

        println!("ğŸš€ Executing priority {} task: {}",
            task.priority, task.command);

        let _ = Command::new(&task.command).output().await;
        Some(())
    }
}
```

---

## 4. è¶…æ—¶ä¸å–æ¶ˆ

### 4.1 åŸºç¡€è¶…æ—¶æ§åˆ¶

```rust
use tokio::time::{timeout, Duration};
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let result = timeout(
        Duration::from_secs(5),
        Command::new("sleep")
            .arg("10")
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            println!("âœ… å®Œæˆ: {}", output.status);
        }
        Ok(Err(e)) => {
            eprintln!("âŒ è¿›ç¨‹é”™è¯¯: {}", e);
        }
        Err(_) => {
            eprintln!("â° è¶…æ—¶ï¼è¿›ç¨‹è¿è¡Œè¶…è¿‡5ç§’");
        }
    }

    Ok(())
}
```

---

### 4.2 å¸¦æ¸…ç†çš„è¶…æ—¶

```rust
use tokio::time::{timeout, Duration};
use tokio::process::Command;

async fn execute_with_timeout(
    cmd: &str,
    timeout_secs: u64
) -> Result<std::process::Output, String> {
    let mut child = Command::new(cmd)
        .spawn()
        .map_err(|e| format!("Failed to spawn: {}", e))?;

    let result = timeout(
        Duration::from_secs(timeout_secs),
        child.wait()
    ).await;

    match result {
        Ok(Ok(status)) => {
            // è¿›ç¨‹æ­£å¸¸å®Œæˆ
            let output = child.wait_with_output().await
                .map_err(|e| format!("Failed to get output: {}", e))?;
            Ok(output)
        }
        Ok(Err(e)) => {
            Err(format!("Process error: {}", e))
        }
        Err(_) => {
            // è¶…æ—¶ï¼Œå¼ºåˆ¶ç»ˆæ­¢
            println!("â° Timeout! Killing process...");
            child.kill().await.ok();
            Err("Timeout".to_string())
        }
    }
}

#[tokio::main]
async fn main() {
    match execute_with_timeout("sleep 100", 3).await {
        Ok(output) => println!("âœ… Success: {:?}", output.status),
        Err(e) => eprintln!("âŒ Error: {}", e),
    }
}
```

---

### 4.3 ä¼˜é›…å–æ¶ˆ

```rust
use tokio::process::Command;
use tokio::sync::oneshot;
use tokio::time::{sleep, Duration};

async fn cancellable_process(
    mut cancel_rx: oneshot::Receiver<()>
) -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("long_running_task")
        .spawn()?;

    tokio::select! {
        result = child.wait() => {
            match result {
                Ok(status) => println!("âœ… Process finished: {}", status),
                Err(e) => eprintln!("âŒ Process error: {}", e),
            }
        }
        _ = &mut cancel_rx => {
            println!("ğŸ›‘ Received cancel signal");

            // å°è¯•ä¼˜é›…ç»ˆæ­¢
            #[cfg(unix)]
            {
                use nix::sys::signal::{kill, Signal};
                use nix::unistd::Pid;

                let pid = Pid::from_raw(child.id().unwrap() as i32);
                let _ = kill(pid, Signal::SIGTERM);

                // ç­‰å¾…ä¸€æ®µæ—¶é—´
                sleep(Duration::from_secs(5)).await;

                // å¦‚æœè¿˜æœªé€€å‡ºï¼Œå¼ºåˆ¶ç»ˆæ­¢
                if child.try_wait()?.is_none() {
                    child.kill().await?;
                }
            }

            #[cfg(not(unix))]
            {
                child.kill().await?;
            }
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (cancel_tx, cancel_rx) = oneshot::channel();

    let task = tokio::spawn(cancellable_process(cancel_rx));

    // 3ç§’åå–æ¶ˆ
    sleep(Duration::from_secs(3)).await;
    cancel_tx.send(()).ok();

    task.await??;
    Ok(())
}
```

---

### 4.4 å¤šè¿›ç¨‹åè°ƒå–æ¶ˆ

```rust
use tokio::process::Command;
use tokio::sync::broadcast;
use std::sync::Arc;

struct ProcessGroup {
    cancel_tx: broadcast::Sender<()>,
}

impl ProcessGroup {
    fn new() -> Self {
        let (cancel_tx, _) = broadcast::channel(10);
        Self { cancel_tx }
    }

    async fn spawn_process(&self, cmd: &str) -> tokio::task::JoinHandle<()> {
        let mut cancel_rx = self.cancel_tx.subscribe();
        let cmd = cmd.to_string();

        tokio::spawn(async move {
            let mut child = Command::new(&cmd).spawn().unwrap();

            tokio::select! {
                _ = child.wait() => {
                    println!("âœ… {} finished normally", cmd);
                }
                _ = cancel_rx.recv() => {
                    println!("ğŸ›‘ {} cancelled", cmd);
                    child.kill().await.ok();
                }
            }
        })
    }

    fn cancel_all(&self) {
        let _ = self.cancel_tx.send(());
    }
}

#[tokio::main]
async fn main() {
    let group = Arc::new(ProcessGroup::new());

    let tasks = vec![
        group.spawn_process("sleep 10").await,
        group.spawn_process("sleep 10").await,
        group.spawn_process("sleep 10").await,
    ];

    // 3ç§’åå–æ¶ˆæ‰€æœ‰è¿›ç¨‹
    tokio::time::sleep(Duration::from_secs(3)).await;
    group.cancel_all();

    for task in tasks {
        task.await.ok();
    }
}
```

---

### 4.5 é‡è¯•æœºåˆ¶

```rust
use tokio::process::Command;
use tokio::time::{sleep, Duration};

async fn retry_command(
    cmd: &str,
    args: &[&str],
    max_retries: usize,
    delay: Duration,
) -> Result<std::process::Output, String> {
    for attempt in 0..max_retries {
        println!("ğŸ”„ Attempt {}/{}", attempt + 1, max_retries);

        match Command::new(cmd).args(args).output().await {
            Ok(output) if output.status.success() => {
                println!("âœ… Success on attempt {}", attempt + 1);
                return Ok(output);
            }
            Ok(output) => {
                eprintln!("âŒ Failed with status: {}", output.status);
                if attempt < max_retries - 1 {
                    sleep(delay).await;
                }
            }
            Err(e) => {
                eprintln!("âŒ Error: {}", e);
                if attempt < max_retries - 1 {
                    sleep(delay).await;
                } else {
                    return Err(format!("All {} attempts failed", max_retries));
                }
            }
        }
    }

    Err("Max retries exceeded".to_string())
}

#[tokio::main]
async fn main() {
    match retry_command("unstable_command", &[], 3, Duration::from_secs(2)).await {
        Ok(output) => println!("Output: {}", String::from_utf8_lossy(&output.stdout)),
        Err(e) => eprintln!("Failed: {}", e),
    }
}
```

---

### 4.6 æ–­è·¯å™¨æ¨¡å¼

```rust
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use tokio::time::{sleep, Duration, Instant};

struct CircuitBreaker {
    failure_count: Arc<AtomicU32>,
    threshold: u32,
    timeout: Duration,
    last_failure: Arc<Mutex<Option<Instant>>>,
}

impl CircuitBreaker {
    fn new(threshold: u32, timeout: Duration) -> Self {
        Self {
            failure_count: Arc::new(AtomicU32::new(0)),
            threshold,
            timeout,
            last_failure: Arc::new(Mutex::new(None)),
        }
    }

    async fn is_open(&self) -> bool {
        let count = self.failure_count.load(Ordering::Relaxed);
        if count >= self.threshold {
            let last = self.last_failure.lock().await;
            if let Some(time) = *last {
                return time.elapsed() < self.timeout;
            }
        }
        false
    }

    async fn record_success(&self) {
        self.failure_count.store(0, Ordering::Relaxed);
    }

    async fn record_failure(&self) {
        self.failure_count.fetch_add(1, Ordering::Relaxed);
        *self.last_failure.lock().await = Some(Instant::now());
    }

    async fn execute<F, T>(&self, f: F) -> Result<T, String>
    where
        F: Future<Output = Result<T, String>>,
    {
        if self.is_open().await {
            return Err("Circuit breaker is open".to_string());
        }

        match f.await {
            Ok(result) => {
                self.record_success().await;
                Ok(result)
            }
            Err(e) => {
                self.record_failure().await;
                Err(e)
            }
        }
    }
}
```

---

## 5. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: å¼‚æ­¥æ‰¹å¤„ç†ç³»ç»Ÿ

```rust
use tokio::process::Command;
use tokio::sync::mpsc;
use std::path::PathBuf;

struct BatchProcessor {
    input_queue: mpsc::Receiver<PathBuf>,
    max_workers: usize,
}

impl BatchProcessor {
    fn new(max_workers: usize) -> (Self, mpsc::Sender<PathBuf>) {
        let (tx, rx) = mpsc::channel(1000);

        (Self {
            input_queue: rx,
            max_workers,
        }, tx)
    }

    async fn run(mut self) -> Result<(), Box<dyn std::error::Error>> {
        let semaphore = Arc::new(Semaphore::new(self.max_workers));
        let mut handles = Vec::new();

        while let Some(file) = self.input_queue.recv().await {
            let sem = semaphore.clone();

            let handle = tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();

                println!("ğŸ”„ Processing: {:?}", file);

                let output = Command::new("ffmpeg")
                    .arg("-i")
                    .arg(&file)
                    .arg("-codec:v")
                    .arg("libx264")
                    .arg(file.with_extension("mp4"))
                    .output()
                    .await
                    .unwrap();

                if output.status.success() {
                    println!("âœ… Completed: {:?}", file);
                } else {
                    eprintln!("âŒ Failed: {:?}", file);
                }
            });

            handles.push(handle);
        }

        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for handle in handles {
            handle.await?;
        }

        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (processor, tx) = BatchProcessor::new(4);

    // å¯åŠ¨å¤„ç†å™¨
    let processor_handle = tokio::spawn(processor.run());

    // æäº¤ä»»åŠ¡
    for i in 1..=20 {
        tx.send(PathBuf::from(format!("video_{}.avi", i))).await?;
    }
    drop(tx);  // å…³é—­é˜Ÿåˆ—

    processor_handle.await??;
    Ok(())
}
```

---

### æ¡ˆä¾‹2: åˆ†å¸ƒå¼ä»»åŠ¡æ‰§è¡Œå™¨

```rust
use tokio::process::Command;
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Task {
    id: u64,
    command: String,
    args: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct TaskResult {
    id: u64,
    success: bool,
    output: String,
}

struct RemoteExecutor {
    listener: TcpListener,
}

impl RemoteExecutor {
    async fn new(addr: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            listener: TcpListener::bind(addr).await?,
        })
    }

    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        loop {
            let (mut socket, addr) = self.listener.accept().await?;
            println!("âœ… New connection from: {}", addr);

            tokio::spawn(async move {
                let mut buffer = vec![0; 4096];

                match socket.read(&mut buffer).await {
                    Ok(n) => {
                        let task: Task = bincode::deserialize(&buffer[..n]).unwrap();
                        println!("ğŸ“¥ Received task {}: {}", task.id, task.command);

                        // æ‰§è¡Œä»»åŠ¡
                        let output = Command::new(&task.command)
                            .args(&task.args)
                            .output()
                            .await
                            .unwrap();

                        let result = TaskResult {
                            id: task.id,
                            success: output.status.success(),
                            output: String::from_utf8_lossy(&output.stdout).to_string(),
                        };

                        // å‘é€ç»“æœ
                        let result_data = bincode::serialize(&result).unwrap();
                        socket.write_all(&result_data).await.ok();
                    }
                    Err(e) => {
                        eprintln!("âŒ Error: {}", e);
                    }
                }
            });
        }
    }
}
```

---

### æ¡ˆä¾‹3: æ—¥å¿—èšåˆå™¨

```rust
use tokio::process::Command;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::sync::mpsc;

struct LogAggregator {
    log_tx: mpsc::Sender<(String, String)>,  // (source, line)
}

impl LogAggregator {
    fn new() -> (Self, mpsc::Receiver<(String, String)>) {
        let (tx, rx) = mpsc::channel(1000);
        (Self { log_tx: tx }, rx)
    }

    async fn monitor_process(&self, name: String, cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut child = Command::new(cmd)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        let stdout = child.stdout.take().unwrap();
        let stderr = child.stderr.take().unwrap();

        let tx = self.log_tx.clone();
        let name_clone = name.clone();
        tokio::spawn(async move {
            let reader = BufReader::new(stdout);
            let mut lines = reader.lines();
            while let Some(line) = lines.next_line().await.unwrap() {
                tx.send((name_clone.clone(), line)).await.ok();
            }
        });

        let tx = self.log_tx.clone();
        tokio::spawn(async move {
            let reader = BufReader::new(stderr);
            let mut lines = reader.lines();
            while let Some(line) = lines.next_line().await.unwrap() {
                tx.send((name.clone(), format!("[ERROR] {}", line))).await.ok();
            }
        });

        child.wait().await?;
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (aggregator, mut log_rx) = LogAggregator::new();

    // ç›‘æ§å¤šä¸ªè¿›ç¨‹
    tokio::spawn({
        let agg = aggregator.clone();
        async move {
            agg.monitor_process("service1".to_string(), "your_service1").await.ok();
        }
    });

    tokio::spawn({
        let agg = aggregator.clone();
        async move {
            agg.monitor_process("service2".to_string(), "your_service2").await.ok();
        }
    });

    // èšåˆæ—¥å¿—
    while let Some((source, line)) = log_rx.recv().await {
        println!("[{}] {}", source, line);
    }

    Ok(())
}
```

---

### æ¡ˆä¾‹4: å¥åº·æ£€æŸ¥ç›‘æ§

```rust
use tokio::process::Command;
use tokio::time::{interval, Duration};
use std::collections::HashMap;

struct HealthMonitor {
    services: HashMap<String, ServiceConfig>,
}

struct ServiceConfig {
    check_command: String,
    check_interval: Duration,
    failure_threshold: u32,
}

impl HealthMonitor {
    fn new() -> Self {
        Self {
            services: HashMap::new(),
        }
    }

    fn add_service(&mut self, name: String, config: ServiceConfig) {
        self.services.insert(name, config);
    }

    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut handles = Vec::new();

        for (name, config) in &self.services {
            let name = name.clone();
            let cmd = config.check_command.clone();
            let check_interval = config.check_interval;
            let threshold = config.failure_threshold;

            handles.push(tokio::spawn(async move {
                let mut failures = 0;
                let mut ticker = interval(check_interval);

                loop {
                    ticker.tick().await;

                    match Command::new("sh").arg("-c").arg(&cmd).output().await {
                        Ok(output) if output.status.success() => {
                            if failures > 0 {
                                println!("âœ… {} recovered", name);
                            }
                            failures = 0;
                        }
                        _ => {
                            failures += 1;
                            eprintln!("âš ï¸  {} health check failed ({}/{})",
                                name, failures, threshold);

                            if failures >= threshold {
                                eprintln!("ğŸš¨ {} is DOWN!", name);
                                // è§¦å‘å‘Šè­¦
                            }
                        }
                    }
                }
            }));
        }

        futures::future::join_all(handles).await;
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut monitor = HealthMonitor::new();

    monitor.add_service("web_server".to_string(), ServiceConfig {
        check_command: "curl -f http://localhost:8080/health".to_string(),
        check_interval: Duration::from_secs(10),
        failure_threshold: 3,
    });

    monitor.add_service("database".to_string(), ServiceConfig {
        check_command: "pg_isready -h localhost".to_string(),
        check_interval: Duration::from_secs(30),
        failure_threshold: 2,
    });

    monitor.run().await?;
    Ok(())
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

### 6.1 é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶é…ç½®

```rust
// å•çº¿ç¨‹è¿è¡Œæ—¶ï¼ˆé€‚åˆI/Oå¯†é›†å‹ï¼‰
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // ...
}

// å¤šçº¿ç¨‹è¿è¡Œæ—¶ï¼ˆé€‚åˆæ··åˆè´Ÿè½½ï¼‰
#[tokio::main(flavor = "multi_thread", worker_threads = 4)]
async fn main() {
    // ...
}

// è‡ªå®šä¹‰è¿è¡Œæ—¶
use tokio::runtime::Builder;

fn custom_runtime() {
    let rt = Builder::new_multi_thread()
        .worker_threads(8)
        .thread_name("my-worker")
        .thread_stack_size(3 * 1024 * 1024)
        .build()
        .unwrap();

    rt.block_on(async {
        // ...
    });
}
```

---

### 6.2 é¿å…é˜»å¡

```rust
// âŒ é”™è¯¯ï¼šåœ¨å¼‚æ­¥ä»£ç ä¸­é˜»å¡
#[tokio::main]
async fn bad_example() {
    let output = std::process::Command::new("ls")  // åŒæ­¥ï¼
        .output()
        .unwrap();
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬
#[tokio::main]
async fn good_example() {
    let output = tokio::process::Command::new("ls")
        .output()
        .await
        .unwrap();
}

// âœ… å¦‚æœå¿…é¡»è°ƒç”¨é˜»å¡ä»£ç ï¼Œä½¿ç”¨spawn_blocking
#[tokio::main]
async fn blocking_example() {
    let result = tokio::task::spawn_blocking(|| {
        // é˜»å¡æ“ä½œ
        std::process::Command::new("heavy_sync_task")
            .output()
            .unwrap()
    }).await.unwrap();
}
```

---

### 6.3 èµ„æºç®¡ç†

```rust
use tokio::process::Command;
use std::sync::Arc;
use tokio::sync::Semaphore;

struct ResourcePool {
    semaphore: Arc<Semaphore>,
}

impl ResourcePool {
    fn new(max_concurrent: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }

    async fn execute(&self, cmd: &str) -> Result<std::process::Output, std::io::Error> {
        let _permit = self.semaphore.acquire().await.unwrap();

        Command::new(cmd).output().await
    }
}

#[tokio::main]
async fn main() {
    let pool = Arc::new(ResourcePool::new(10));

    let mut handles = Vec::new();
    for _ in 0..100 {
        let pool = pool.clone();
        handles.push(tokio::spawn(async move {
            pool.execute("task").await
        }));
    }

    futures::future::join_all(handles).await;
}
```

---

### 6.4 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```rust
use tokio::process::Command;

#[derive(Debug)]
enum ProcessError {
    SpawnFailed(std::io::Error),
    ExecutionFailed {
        code: Option<i32>,
        stderr: String
    },
    Timeout,
}

async fn execute_robust(
    cmd: &str,
    timeout_secs: u64
) -> Result<String, ProcessError> {
    let mut child = Command::new(cmd)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(ProcessError::SpawnFailed)?;

    let result = tokio::time::timeout(
        Duration::from_secs(timeout_secs),
        child.wait_with_output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            if output.status.success() {
                Ok(String::from_utf8_lossy(&output.stdout).to_string())
            } else {
                Err(ProcessError::ExecutionFailed {
                    code: output.status.code(),
                    stderr: String::from_utf8_lossy(&output.stderr).to_string(),
                })
            }
        }
        Ok(Err(e)) => Err(ProcessError::SpawnFailed(e)),
        Err(_) => {
            child.kill().await.ok();
            Err(ProcessError::Timeout)
        }
    }
}
```

---

### 6.5 ç›‘æ§å’Œè°ƒè¯•

```rust
use tokio::process::Command;
use std::time::Instant;

async fn execute_with_metrics(cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
    let start = Instant::now();

    println!("ğŸš€ Starting: {}", cmd);

    let output = Command::new(cmd).output().await?;

    let duration = start.elapsed();

    println!("â±ï¸  Duration: {:?}", duration);
    println!("ğŸ“Š Status: {}", output.status);
    println!("ğŸ“ Stdout: {} bytes", output.stdout.len());
    println!("ğŸ“ Stderr: {} bytes", output.stderr.len());

    Ok(())
}

// ä½¿ç”¨tracingè¿›è¡Œç»“æ„åŒ–æ—¥å¿—
use tracing::{info, warn, error, instrument};

#[instrument]
async fn execute_instrumented(cmd: &str) -> Result<(), Box<dyn std::error::Error>> {
    info!("Executing command: {}", cmd);

    let output = Command::new(cmd).output().await?;

    if output.status.success() {
        info!("Command completed successfully");
    } else {
        warn!("Command failed with status: {}", output.status);
    }

    Ok(())
}
```

---

## 7. å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

### é™·é˜±1: å¿˜è®°await

```rust
// âŒ é”™è¯¯ï¼šå¿˜è®°await
let _output = Command::new("ls").output();  // è¿”å›Futureï¼Œä¸æ‰§è¡Œ

// âœ… æ­£ç¡®
let output = Command::new("ls").output().await?;
```

---

### é™·é˜±2: æ­»é”

```rust
// âŒ å¯èƒ½æ­»é”
let mut child = Command::new("cat").stdin(Stdio::piped()).spawn()?;
child.stdin.as_mut().unwrap().write_all(&huge_data).await?;
child.wait().await?;  // å¯èƒ½æ°¸è¿œç­‰å¾…

// âœ… æ­£ç¡®ï¼šåœ¨å•ç‹¬ä»»åŠ¡ä¸­å†™å…¥
let mut stdin = child.stdin.take().unwrap();
tokio::spawn(async move {
    stdin.write_all(&huge_data).await.ok();
});
child.wait().await?;
```

---

### é™·é˜±3: èµ„æºæ³„æ¼

```rust
// âŒ å¯èƒ½æ³„æ¼ï¼šå¿˜è®°ç­‰å¾…
for i in 0..1000 {
    tokio::spawn(async move {
        Command::new("task").output().await.ok();
    });
}  // ä»»åŠ¡å¯èƒ½è¿˜åœ¨è¿è¡Œ

// âœ… æ­£ç¡®ï¼šæ”¶é›†handleså¹¶ç­‰å¾…
let handles: Vec<_> = (0..1000)
    .map(|_| tokio::spawn(async {
        Command::new("task").output().await
    }))
    .collect();

for handle in handles {
    handle.await.ok();
}
```

---

## ä¸‹ä¸€æ­¥

- [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](./01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)
- [IPCé€šä¿¡å®è·µ](./02_IPCé€šä¿¡å®è·µ.md)
- [è¿›ç¨‹æ¨¡å‹å‚è€ƒ](../tier_03_references/01_è¿›ç¨‹æ¨¡å‹å‚è€ƒ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
