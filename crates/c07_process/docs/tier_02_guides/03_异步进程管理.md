# Tier 2: 异步进程管理

> **文档类型**: 实践指南  
> **难度**: ⭐⭐⭐ 中级  
> **预计时间**: 2小时  
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 异步进程管理](#tier-2-异步进程管理)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 为什么使用异步](#1-为什么使用异步)
  - [2. Tokio Process](#2-tokio-process)
  - [3. 并发进程管理](#3-并发进程管理)
  - [4. 超时与取消](#4-超时与取消)
  - [5. 实战案例](#5-实战案例)

---

## 学习目标

- ✅ 理解异步进程管理的优势
- ✅ 使用Tokio管理进程
- ✅ 实现并发进程调度
- ✅ 处理超时和取消

---

## 1. 为什么使用异步

**适合异步的场景**:

- ✅ 同时管理多个子进程
- ✅ I/O密集型操作
- ✅ 需要超时控制
- ✅ 与异步生态集成

**不适合异步**:

- ❌ 单个进程简单执行
- ❌ CPU密集型任务

---

## 2. Tokio Process

**基础用法**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new("echo")
        .arg("Hello Async!")
        .output()
        .await?;
    
    println!("{}", String::from_utf8_lossy(&output.stdout));
    Ok(())
}
```

**捕获输出**:

```rust
use tokio::io::AsyncReadExt;

let mut child = Command::new("cat")
    .arg("file.txt")
    .stdout(Stdio::piped())
    .spawn()?;

if let Some(mut stdout) = child.stdout.take() {
    let mut buffer = String::new();
    stdout.read_to_string(&mut buffer).await?;
    println!("{}", buffer);
}

child.wait().await?;
```

---

## 3. 并发进程管理

**并发启动多个进程**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let tasks = vec![
        tokio::spawn(run_task("task1")),
        tokio::spawn(run_task("task2")),
        tokio::spawn(run_task("task3")),
    ];
    
    for task in tasks {
        task.await??;
    }
    
    Ok(())
}

async fn run_task(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new(name).output().await?;
    println!("{} 完成: {:?}", name, output.status);
    Ok(())
}
```

---

## 4. 超时与取消

**超时控制**:

```rust
use tokio::time::{timeout, Duration};

let result = timeout(
    Duration::from_secs(30),
    Command::new("slow_task").output()
).await;

match result {
    Ok(Ok(output)) => println!("完成"),
    Ok(Err(e)) => eprintln!("进程错误: {}", e),
    Err(_) => eprintln!("超时"),
}
```

**取消进程**:

```rust
let mut child = Command::new("app").spawn()?;
let handle = tokio::spawn(async move {
    child.wait().await
});

// 取消
handle.abort();
```

---

## 5. 实战案例

**案例: 异步进程池**:

```rust
use tokio::process::Command;
use tokio::sync::Semaphore;
use std::sync::Arc;

async fn process_pool(
    tasks: Vec<String>, 
    max_concurrent: usize
) -> Result<(), Box<dyn std::error::Error>> {
    let semaphore = Arc::new(Semaphore::new(max_concurrent));
    let mut handles = Vec::new();
    
    for task in tasks {
        let permit = semaphore.clone().acquire_owned().await?;
        let handle = tokio::spawn(async move {
            let _permit = permit;  // 持有permit直到任务完成
            Command::new(&task).output().await
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await??;
    }
    
    Ok(())
}
```

---

**参考**: [异步进程管理](../../docs/05_async_process_management.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
