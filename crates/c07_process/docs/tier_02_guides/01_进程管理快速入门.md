# Tier 2: è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨

> **æ–‡æ¡£ç±»å‹**: å®è·µæŒ‡å—
> **éš¾åº¦**: â­â­ åˆçº§
> **é¢„è®¡æ—¶é—´**: 2å°æ—¶
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+

---

## ç›®å½•

- [Tier 2: è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](#tier-2-è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
  - [1. åˆ›å»ºè¿›ç¨‹](#1-åˆ›å»ºè¿›ç¨‹)
    - [1.1 åŸºç¡€ç”¨æ³•](#11-åŸºç¡€ç”¨æ³•)
    - [1.2 é…ç½®é€‰é¡¹](#12-é…ç½®é€‰é¡¹)
    - [1.3 ä¸‰ç§å¯åŠ¨æ–¹å¼](#13-ä¸‰ç§å¯åŠ¨æ–¹å¼)
  - [2. ç®¡ç†è¿›ç¨‹](#2-ç®¡ç†è¿›ç¨‹)
    - [2.1 ç­‰å¾…è¿›ç¨‹å®Œæˆ](#21-ç­‰å¾…è¿›ç¨‹å®Œæˆ)
    - [2.2 è·å–è¿›ç¨‹çŠ¶æ€](#22-è·å–è¿›ç¨‹çŠ¶æ€)
    - [2.3 ç»ˆæ­¢è¿›ç¨‹](#23-ç»ˆæ­¢è¿›ç¨‹)
  - [3. è¿›ç¨‹I/O](#3-è¿›ç¨‹io)
    - [3.1 æ•è·è¾“å‡º](#31-æ•è·è¾“å‡º)
    - [3.2 ä¼ é€’è¾“å…¥](#32-ä¼ é€’è¾“å…¥)
    - [3.3 å®æ—¶é€šä¿¡](#33-å®æ—¶é€šä¿¡)
  - [4. é”™è¯¯å¤„ç†](#4-é”™è¯¯å¤„ç†)
    - [4.1 å¯åŠ¨é”™è¯¯](#41-å¯åŠ¨é”™è¯¯)
    - [4.2 æ‰§è¡Œé”™è¯¯](#42-æ‰§è¡Œé”™è¯¯)
    - [4.3 è¶…æ—¶å¤„ç†](#43-è¶…æ—¶å¤„ç†)
  - [5. å®æˆ˜æ¡ˆä¾‹](#5-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: å‘½ä»¤è¡ŒåŒ…è£…å™¨](#æ¡ˆä¾‹1-å‘½ä»¤è¡ŒåŒ…è£…å™¨)
    - [æ¡ˆä¾‹2: è¿›ç¨‹ç›‘æ§å™¨](#æ¡ˆä¾‹2-è¿›ç¨‹ç›‘æ§å™¨)
    - [æ¡ˆä¾‹3: æ‰¹é‡è¿›ç¨‹æ‰§è¡Œå™¨](#æ¡ˆä¾‹3-æ‰¹é‡è¿›ç¨‹æ‰§è¡Œå™¨)
    - [æ¡ˆä¾‹4: è¿›ç¨‹ç®¡é“é“¾](#æ¡ˆä¾‹4-è¿›ç¨‹ç®¡é“é“¾)
    - [æ¡ˆä¾‹5: è¿›ç¨‹æ± ç®¡ç†å™¨](#æ¡ˆä¾‹5-è¿›ç¨‹æ± ç®¡ç†å™¨)
    - [æ¡ˆä¾‹6: è¿›ç¨‹çœ‹é—¨ç‹—](#æ¡ˆä¾‹6-è¿›ç¨‹çœ‹é—¨ç‹—)
    - [æ¡ˆä¾‹7: èµ„æºé™åˆ¶æ‰§è¡Œ](#æ¡ˆä¾‹7-èµ„æºé™åˆ¶æ‰§è¡Œ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
  - [7. ç»ƒä¹ é¢˜](#7-ç»ƒä¹ é¢˜)
  - [8. å¸¸è§é—®é¢˜è§£ç­”](#8-å¸¸è§é—®é¢˜è§£ç­”)
    - [Q1: å¦‚ä½•åˆ¤æ–­è¿›ç¨‹æ˜¯å¦åœ¨è¿è¡Œï¼Ÿ](#q1-å¦‚ä½•åˆ¤æ–­è¿›ç¨‹æ˜¯å¦åœ¨è¿è¡Œ)
    - [Q2: ä¸ºä»€ä¹ˆä¼šå‡ºç°åƒµå°¸è¿›ç¨‹ï¼Ÿ](#q2-ä¸ºä»€ä¹ˆä¼šå‡ºç°åƒµå°¸è¿›ç¨‹)
    - [Q3: å¦‚ä½•å¤„ç†å¤§é‡è¾“å‡ºé¿å…ç®¡é“é˜»å¡ï¼Ÿ](#q3-å¦‚ä½•å¤„ç†å¤§é‡è¾“å‡ºé¿å…ç®¡é“é˜»å¡)
    - [Q4: Windowså’ŒUnixçš„è¿›ç¨‹ç®¡ç†æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q4-windowså’Œunixçš„è¿›ç¨‹ç®¡ç†æœ‰ä»€ä¹ˆåŒºåˆ«)
    - [Q5: å¦‚ä½•å®ç°è¿›ç¨‹è¶…æ—¶ï¼Ÿ](#q5-å¦‚ä½•å®ç°è¿›ç¨‹è¶…æ—¶)
    - [Q6: å¦‚ä½•åœ¨è¿›ç¨‹é—´å…±äº«æ•°æ®ï¼Ÿ](#q6-å¦‚ä½•åœ¨è¿›ç¨‹é—´å…±äº«æ•°æ®)
    - [Q7: å¦‚ä½•é™åˆ¶è¿›ç¨‹èµ„æºä½¿ç”¨ï¼Ÿ](#q7-å¦‚ä½•é™åˆ¶è¿›ç¨‹èµ„æºä½¿ç”¨)
    - [Q8: å¦‚ä½•æ•è·Ctrl+Cä¿¡å·å¹¶æ¸…ç†å­è¿›ç¨‹ï¼Ÿ](#q8-å¦‚ä½•æ•è·ctrlcä¿¡å·å¹¶æ¸…ç†å­è¿›ç¨‹)
    - [Q9: å¦‚ä½•å®ç°è¿›ç¨‹æ—¥å¿—è½®è½¬ï¼Ÿ](#q9-å¦‚ä½•å®ç°è¿›ç¨‹æ—¥å¿—è½®è½¬)
    - [Q10: å¦‚ä½•è°ƒè¯•è¿›ç¨‹é—®é¢˜ï¼Ÿ](#q10-å¦‚ä½•è°ƒè¯•è¿›ç¨‹é—®é¢˜)
  - [9. æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#9-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
    - [9.1 å‡å°‘è¿›ç¨‹åˆ›å»ºå¼€é”€](#91-å‡å°‘è¿›ç¨‹åˆ›å»ºå¼€é”€)
    - [9.2 ä¼˜åŒ–è¾“å‡ºå¤„ç†](#92-ä¼˜åŒ–è¾“å‡ºå¤„ç†)
    - [9.3 å¹¶è¡Œæ‰§è¡Œç­–ç•¥](#93-å¹¶è¡Œæ‰§è¡Œç­–ç•¥)
    - [9.4 å†…å­˜ä¼˜åŒ–](#94-å†…å­˜ä¼˜åŒ–)
  - [10. å®‰å…¨æ³¨æ„äº‹é¡¹](#10-å®‰å…¨æ³¨æ„äº‹é¡¹)
    - [10.1 å‘½ä»¤æ³¨å…¥é˜²æŠ¤](#101-å‘½ä»¤æ³¨å…¥é˜²æŠ¤)
    - [10.2 æƒé™æœ€å°åŒ–](#102-æƒé™æœ€å°åŒ–)
    - [10.3 è¾“å…¥éªŒè¯](#103-è¾“å…¥éªŒè¯)
    - [10.4 å®¡è®¡å’Œæ—¥å¿—](#104-å®¡è®¡å’Œæ—¥å¿—)
  - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**è¿›ç¨‹ (Process)**:

- **å®šä¹‰**: ç¨‹åºçš„æ‰§è¡Œå®ä¾‹ï¼Œæ‹¥æœ‰ç‹¬ç«‹çš„åœ°å€ç©ºé—´å’Œèµ„æº
- **ç±»å‹**: ç³»ç»Ÿæ¦‚å¿µ
- **èŒƒç•´**: ç³»ç»Ÿç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: çº¿ç¨‹ã€IPCã€ä¿¡å·ã€è¿›ç¨‹ç»„

**è¿›ç¨‹ç®¡ç† (Process Management)**:

- **å®šä¹‰**: åˆ›å»ºã€ç›‘æ§ã€æ§åˆ¶å’Œç»ˆæ­¢è¿›ç¨‹çš„æ“ä½œ
- **ç±»å‹**: å¤åˆæ¦‚å¿µ
- **å±æ€§**: ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€èµ„æºæ§åˆ¶ã€é”™è¯¯å¤„ç†
- **å…³ç³»**: ä¸è¿›ç¨‹ã€IPCã€åŒæ­¥ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **ç‹¬ç«‹åœ°å€ç©ºé—´**: æ¯ä¸ªè¿›ç¨‹æœ‰ç‹¬ç«‹çš„å†…å­˜ç©ºé—´
- **èµ„æºéš”ç¦»**: è¿›ç¨‹é—´èµ„æºç›¸äº’éš”ç¦»
- **è¿›ç¨‹ ID (PID)**: å”¯ä¸€æ ‡è¯†è¿›ç¨‹
- **çˆ¶å­å…³ç³»**: è¿›ç¨‹å¯ä»¥åˆ›å»ºå­è¿›ç¨‹

**æ€§èƒ½ç‰¹å¾**:

- **åˆ›å»ºå¼€é”€**: è¿›ç¨‹åˆ›å»ºå¼€é”€è¾ƒå¤§
- **å†…å­˜å ç”¨**: æ¯ä¸ªè¿›ç¨‹æœ‰ç‹¬ç«‹çš„åœ°å€ç©ºé—´
- **é€‚ç”¨åœºæ™¯**: ç³»ç»Ÿç®¡ç†ã€æœåŠ¡å®ˆæŠ¤ã€ä»»åŠ¡éš”ç¦»

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- å­è¿›ç¨‹ --[is-a]--> è¿›ç¨‹

**ç»„åˆå…³ç³»**:

- è¿›ç¨‹ç»„ --[has-a]--> å¤šä¸ªè¿›ç¨‹
- è¿›ç¨‹æ±  --[has-a]--> å¤šä¸ªè¿›ç¨‹

**ä¾èµ–å…³ç³»**:

- è¿›ç¨‹ç®¡ç† --[depends-on]--> æ“ä½œç³»ç»Ÿè¿›ç¨‹æ”¯æŒ
- IPC --[depends-on]--> è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶

### æ€ç»´å¯¼å›¾

```text
è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨
â”‚
â”œâ”€â”€ åˆ›å»ºè¿›ç¨‹
â”‚   â”œâ”€â”€ åŸºç¡€ç”¨æ³•
â”‚   â”œâ”€â”€ é…ç½®é€‰é¡¹
â”‚   â””â”€â”€ å¯åŠ¨æ–¹å¼
â”œâ”€â”€ ç®¡ç†è¿›ç¨‹
â”‚   â”œâ”€â”€ ç­‰å¾…å®Œæˆ
â”‚   â”œâ”€â”€ è·å–çŠ¶æ€
â”‚   â””â”€â”€ ç»ˆæ­¢è¿›ç¨‹
â”œâ”€â”€ è¿›ç¨‹ I/O
â”‚   â”œâ”€â”€ æ•è·è¾“å‡º
â”‚   â”œâ”€â”€ ä¼ é€’è¾“å…¥
â”‚   â””â”€â”€ å®æ—¶é€šä¿¡
â””â”€â”€ é”™è¯¯å¤„ç†
    â”œâ”€â”€ å¯åŠ¨é”™è¯¯
    â”œâ”€â”€ æ‰§è¡Œé”™è¯¯
    â””â”€â”€ è¶…æ—¶å¤„ç†
```

---

## å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… åˆ›å»ºå’Œé…ç½®å­è¿›ç¨‹
- âœ… ç®¡ç†è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸ
- âœ… å¤„ç†è¿›ç¨‹è¾“å…¥è¾“å‡º
- âœ… å®ç°å¥å£®çš„é”™è¯¯å¤„ç†
- âœ… æ„å»ºå®ç”¨çš„è¿›ç¨‹ç®¡ç†å·¥å…·

---

## 1. åˆ›å»ºè¿›ç¨‹

### 1.1 åŸºç¡€ç”¨æ³•

ä½¿ç”¨ `Command` åˆ›å»ºè¿›ç¨‹ï¼š

```rust
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºå¹¶è¿è¡Œè¿›ç¨‹
    let output = Command::new("echo")
        .arg("Hello, World!")
        .output()?;

    println!("status: {}", output.status);
    println!("stdout: {}", String::from_utf8_lossy(&output.stdout));

    Ok(())
}
```

**å…³é”®ç‚¹**:

- `Command::new()`: æŒ‡å®šç¨‹åºè·¯å¾„
- `.arg()`: æ·»åŠ å‘½ä»¤è¡Œå‚æ•°
- `.output()`: ç­‰å¾…å®Œæˆå¹¶è·å–è¾“å‡º

---

### 1.2 é…ç½®é€‰é¡¹

**è®¾ç½®å·¥ä½œç›®å½•**:

```rust
let output = Command::new("ls")
    .current_dir("/tmp")
    .output()?;
```

**è®¾ç½®ç¯å¢ƒå˜é‡**:

```rust
let output = Command::new("env")
    .env("MY_VAR", "my_value")
    .env_clear()  // æ¸…é™¤ç»§æ‰¿çš„ç¯å¢ƒå˜é‡
    .env("PATH", "/usr/bin")
    .output()?;
```

**å®Œæ•´é…ç½®ç¤ºä¾‹**:

```rust
let mut child = Command::new("my_program")
    .arg("--config")
    .arg("config.toml")
    .current_dir("/app")
    .env("LOG_LEVEL", "debug")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .stderr(Stdio::piped())
    .spawn()?;
```

---

### 1.3 ä¸‰ç§å¯åŠ¨æ–¹å¼

**æ–¹å¼1: `output()` - ç­‰å¾…å¹¶è·å–è¾“å‡º**:

```rust
let output = Command::new("ls").output()?;
// é˜»å¡ç›´åˆ°è¿›ç¨‹å®Œæˆ
// è¿”å› Output { status, stdout, stderr }
```

**æ–¹å¼2: `status()` - åªè·å–é€€å‡ºçŠ¶æ€**:

```rust
let status = Command::new("ls").status()?;
// é˜»å¡ç›´åˆ°è¿›ç¨‹å®Œæˆ
// åªè¿”å› ExitStatus
```

**æ–¹å¼3: `spawn()` - ç«‹å³è¿”å›**:

```rust
let mut child = Command::new("sleep")
    .arg("10")
    .spawn()?;
// ç«‹å³è¿”å›ï¼Œè¿›ç¨‹åœ¨åå°è¿è¡Œ
// è¿”å› Child å¯¹è±¡
```

**å¯¹æ¯”**:

| æ–¹æ³•       | é˜»å¡ | è¿”å›å€¼       | ç”¨é€”           |
| ---------- | ---- | ------------ | -------------- |
| `output()` | æ˜¯   | `Output`     | éœ€è¦æ•è·è¾“å‡º   |
| `status()` | æ˜¯   | `ExitStatus` | åªå…³å¿ƒé€€å‡ºçŠ¶æ€ |
| `spawn()`  | å¦   | `Child`      | éœ€è¦åç»­æ“ä½œ   |

---

## 2. ç®¡ç†è¿›ç¨‹

### 2.1 ç­‰å¾…è¿›ç¨‹å®Œæˆ

**é˜»å¡ç­‰å¾…**:

```rust
let mut child = Command::new("sleep")
    .arg("5")
    .spawn()?;

// é˜»å¡ç›´åˆ°å­è¿›ç¨‹å®Œæˆ
let status = child.wait()?;
println!("è¿›ç¨‹é€€å‡º: {}", status);
```

**éé˜»å¡æ£€æŸ¥**:

```rust
let mut child = Command::new("long_task").spawn()?;

loop {
    match child.try_wait()? {
        Some(status) => {
            println!("è¿›ç¨‹å®Œæˆ: {}", status);
            break;
        }
        None => {
            println!("ä»åœ¨è¿è¡Œ...");
            std::thread::sleep(std::time::Duration::from_secs(1));
        }
    }
}
```

---

### 2.2 è·å–è¿›ç¨‹çŠ¶æ€

**è·å–PID**:

```rust
let child = Command::new("app").spawn()?;
println!("è¿›ç¨‹ID: {}", child.id());
```

**æ£€æŸ¥é€€å‡ºçŠ¶æ€**:

```rust
let status = child.wait()?;

if status.success() {
    println!("æˆåŠŸ");
} else {
    if let Some(code) = status.code() {
        eprintln!("å¤±è´¥ï¼Œé€€å‡ºç : {}", code);
    } else {
        eprintln!("è¢«ä¿¡å·ç»ˆæ­¢");
    }
}
```

**Unixä¿¡å·æ£€æŸ¥**:

```rust
#[cfg(unix)]
{
    use std::os::unix::process::ExitStatusExt;

    if let Some(signal) = status.signal() {
        eprintln!("è¢«ä¿¡å· {} ç»ˆæ­¢", signal);
    }
}
```

---

### 2.3 ç»ˆæ­¢è¿›ç¨‹

**å¼ºåˆ¶ç»ˆæ­¢**:

```rust
let mut child = Command::new("app").spawn()?;

// ç»ˆæ­¢è¿›ç¨‹
child.kill()?;

// å›æ”¶èµ„æº
child.wait()?;
```

**Unixä¼˜é›…ç»ˆæ­¢**:

```rust
#[cfg(unix)]
{
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;

    let pid = Pid::from_raw(child.id() as i32);

    // å‘é€SIGTERMï¼ˆä¼˜é›…ç»ˆæ­¢ï¼‰
    kill(pid, Signal::SIGTERM)?;

    // ç­‰å¾…5ç§’
    std::thread::sleep(std::time::Duration::from_secs(5));

    // æ£€æŸ¥æ˜¯å¦è¿˜åœ¨è¿è¡Œ
    if child.try_wait()?.is_none() {
        // å¼ºåˆ¶SIGKILL
        kill(pid, Signal::SIGKILL)?;
    }

    child.wait()?;
}
```

---

## 3. è¿›ç¨‹I/O

### 3.1 æ•è·è¾“å‡º

**åŸºç¡€æ•è·**:

```rust
let output = Command::new("echo")
    .arg("Hello")
    .output()?;

let stdout = String::from_utf8_lossy(&output.stdout);
let stderr = String::from_utf8_lossy(&output.stderr);

println!("æ ‡å‡†è¾“å‡º: {}", stdout);
println!("æ ‡å‡†é”™è¯¯: {}", stderr);
```

**åˆ†ç¦»è¯»å–**:

```rust
use std::io::Read;

let mut child = Command::new("cat")
    .arg("file.txt")
    .stdout(Stdio::piped())
    .spawn()?;

if let Some(mut stdout) = child.stdout.take() {
    let mut buffer = String::new();
    stdout.read_to_string(&mut buffer)?;
    println!("{}", buffer);
}

child.wait()?;
```

---

### 3.2 ä¼ é€’è¾“å…¥

**å†™å…¥stdin**:

```rust
use std::io::Write;

let mut child = Command::new("cat")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// å†™å…¥æ•°æ®
if let Some(mut stdin) = child.stdin.take() {
    stdin.write_all(b"Hello from stdin!\n")?;
    // drop(stdin) è‡ªåŠ¨å…³é—­
}

// è¯»å–è¾“å‡º
let output = child.wait_with_output()?;
println!("{}", String::from_utf8_lossy(&output.stdout));
```

---

### 3.3 å®æ—¶é€šä¿¡

**åŒå‘é€šä¿¡**:

```rust
use std::io::{BufRead, BufReader, Write};

let mut child = Command::new("python")
    .arg("-u")  // unbuffered
    .arg("interactive.py")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

let mut stdin = child.stdin.take().unwrap();
let stdout = child.stdout.take().unwrap();
let reader = BufReader::new(stdout);

// å†™å…¥
stdin.write_all(b"input1\n")?;
stdin.flush()?;

// è¯»å–å“åº”
for line in reader.lines().take(1) {
    println!("Response: {}", line?);
}

child.kill()?;
child.wait()?;
```

---

## 4. é”™è¯¯å¤„ç†

### 4.1 å¯åŠ¨é”™è¯¯

```rust
use std::io::ErrorKind;

match Command::new("nonexistent_program").spawn() {
    Ok(child) => println!("æˆåŠŸå¯åŠ¨: PID {}", child.id()),
    Err(e) => match e.kind() {
        ErrorKind::NotFound => {
            eprintln!("âŒ ç¨‹åºä¸å­˜åœ¨");
        }
        ErrorKind::PermissionDenied => {
            eprintln!("âŒ æƒé™ä¸è¶³");
        }
        _ => {
            eprintln!("âŒ å…¶ä»–é”™è¯¯: {}", e);
        }
    }
}
```

---

### 4.2 æ‰§è¡Œé”™è¯¯

```rust
let output = Command::new("app")
    .arg("--config")
    .arg("missing.toml")
    .output()?;

if !output.status.success() {
    let stderr = String::from_utf8_lossy(&output.stderr);
    eprintln!("æ‰§è¡Œå¤±è´¥:\n{}", stderr);

    if let Some(code) = output.status.code() {
        eprintln!("é€€å‡ºç : {}", code);
    }
}
```

---

### 4.3 è¶…æ—¶å¤„ç†

```rust
use std::time::{Duration, Instant};

let mut child = Command::new("slow_task").spawn()?;
let timeout = Duration::from_secs(30);
let start = Instant::now();

loop {
    match child.try_wait()? {
        Some(status) => {
            println!("âœ… å®Œæˆ: {}", status);
            break;
        }
        None if start.elapsed() >= timeout => {
            eprintln!("â° è¶…æ—¶ï¼Œç»ˆæ­¢è¿›ç¨‹");
            child.kill()?;
            child.wait()?;
            return Err("Timeout".into());
        }
        None => {
            std::thread::sleep(Duration::from_millis(100));
        }
    }
}
```

---

## 5. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: å‘½ä»¤è¡ŒåŒ…è£…å™¨

å°è£…ç³»ç»Ÿå‘½ä»¤ï¼Œæä¾›å‹å¥½æ¥å£ï¼š

```rust
use std::process::Command;

struct ShellCommand {
    command: String,
}

impl ShellCommand {
    fn new(cmd: &str) -> Self {
        Self {
            command: cmd.to_string(),
        }
    }

    fn execute(&self) -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("cmd")
                .args(["/C", &self.command])
                .output()?
        } else {
            Command::new("sh")
                .args(["-c", &self.command])
                .output()?
        };

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Command failed: {}", stderr).into())
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cmd = ShellCommand::new("echo Hello && ls");
    let result = cmd.execute()?;
    println!("{}", result);
    Ok(())
}
```

---

### æ¡ˆä¾‹2: è¿›ç¨‹ç›‘æ§å™¨

ç›‘æ§è¿›ç¨‹èµ„æºä½¿ç”¨ï¼š

```rust
use std::process::Command;
use std::time::Duration;

struct ProcessMonitor {
    child: std::process::Child,
}

impl ProcessMonitor {
    fn spawn(program: &str) -> Result<Self, std::io::Error> {
        let child = Command::new(program).spawn()?;
        Ok(Self { child })
    }

    fn is_running(&mut self) -> Result<bool, std::io::Error> {
        match self.child.try_wait()? {
            Some(_) => Ok(false),
            None => Ok(true),
        }
    }

    fn wait_with_timeout(&mut self, timeout: Duration)
        -> Result<bool, Box<dyn std::error::Error>>
    {
        let start = std::time::Instant::now();

        while start.elapsed() < timeout {
            if !self.is_running()? {
                return Ok(true);  // å®Œæˆ
            }
            std::thread::sleep(Duration::from_millis(100));
        }

        Ok(false)  // è¶…æ—¶
    }
}

impl Drop for ProcessMonitor {
    fn drop(&mut self) {
        let _ = self.child.kill();
        let _ = self.child.wait();
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut monitor = ProcessMonitor::spawn("sleep")?;

    println!("è¿›ç¨‹å¯åŠ¨: PID {}", monitor.child.id());

    if monitor.wait_with_timeout(Duration::from_secs(5))? {
        println!("âœ… è¿›ç¨‹å®Œæˆ");
    } else {
        println!("â° è¿›ç¨‹è¶…æ—¶");
    }

    Ok(())
}
```

---

### æ¡ˆä¾‹3: æ‰¹é‡è¿›ç¨‹æ‰§è¡Œå™¨

æ‰§è¡Œå¤šä¸ªå‘½ä»¤å¹¶æ”¶é›†ç»“æœï¼š

```rust
use std::process::Command;

struct BatchExecutor {
    results: Vec<(String, bool)>,
}

impl BatchExecutor {
    fn new() -> Self {
        Self { results: Vec::new() }
    }

    fn execute(&mut self, commands: &[(&str, Vec<&str>)]) {
        for (program, args) in commands {
            let result = Command::new(program)
                .args(args)
                .output();

            match result {
                Ok(output) => {
                    let success = output.status.success();
                    let cmd_str = format!("{} {}", program, args.join(" "));
                    self.results.push((cmd_str, success));

                    if success {
                        println!("âœ… {}", program);
                    } else {
                        println!("âŒ {}", program);
                    }
                }
                Err(e) => {
                    println!("âŒ {} failed to start: {}", program, e);
                    self.results.push((program.to_string(), false));
                }
            }
        }
    }

    fn summary(&self) {
        let total = self.results.len();
        let success = self.results.iter().filter(|(_, ok)| *ok).count();
        println!("\nğŸ“Š Summary: {}/{} succeeded", success, total);
    }
}

fn main() {
    let mut executor = BatchExecutor::new();

    let commands = vec![
        ("echo", vec!["test"]),
        ("ls", vec!["-la"]),
        ("pwd", vec![]),
    ];

    executor.execute(&commands);
    executor.summary();
}
```

---

### æ¡ˆä¾‹4: è¿›ç¨‹ç®¡é“é“¾

è¿æ¥å¤šä¸ªè¿›ç¨‹å½¢æˆå¤„ç†ç®¡é“ï¼š

```rust
use std::process::{Command, Stdio};
use std::io::Write;

fn execute_pipeline() -> Result<String, Box<dyn std::error::Error>> {
    // ç¬¬ä¸€ä¸ªè¿›ç¨‹: cat file
    let mut cat = Command::new("cat")
        .arg("data.txt")
        .stdout(Stdio::piped())
        .spawn()?;

    // ç¬¬äºŒä¸ªè¿›ç¨‹: grep pattern
    let mut grep = Command::new("grep")
        .arg("pattern")
        .stdin(cat.stdout.take().unwrap())
        .stdout(Stdio::piped())
        .spawn()?;

    // ç¬¬ä¸‰ä¸ªè¿›ç¨‹: sort
    let sort_output = Command::new("sort")
        .stdin(grep.stdout.take().unwrap())
        .output()?;

    // ç­‰å¾…å‰é¢çš„è¿›ç¨‹
    cat.wait()?;
    grep.wait()?;

    Ok(String::from_utf8_lossy(&sort_output.stdout).to_string())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let result = execute_pipeline()?;
    println!("Pipeline result:\n{}", result);
    Ok(())
}
```

---

### æ¡ˆä¾‹5: è¿›ç¨‹æ± ç®¡ç†å™¨

ç®¡ç†å›ºå®šæ•°é‡çš„workerè¿›ç¨‹ï¼š

```rust
use std::process::{Command, Child};
use std::collections::VecDeque;

struct ProcessPool {
    max_workers: usize,
    active: Vec<Child>,
    pending: VecDeque<(String, Vec<String>)>,
}

impl ProcessPool {
    fn new(max_workers: usize) -> Self {
        Self {
            max_workers,
            active: Vec::new(),
            pending: VecDeque::new(),
        }
    }

    fn submit(&mut self, program: String, args: Vec<String>) {
        self.pending.push_back((program, args));
        self.try_start_pending();
    }

    fn try_start_pending(&mut self) {
        while self.active.len() < self.max_workers {
            if let Some((program, args)) = self.pending.pop_front() {
                match Command::new(&program).args(&args).spawn() {
                    Ok(child) => {
                        println!("ğŸš€ Started: {} (PID {})", program, child.id());
                        self.active.push(child);
                    }
                    Err(e) => {
                        eprintln!("âŒ Failed to start {}: {}", program, e);
                    }
                }
            } else {
                break;
            }
        }
    }

    fn wait_any(&mut self) -> Result<(), std::io::Error> {
        let mut i = 0;
        while i < self.active.len() {
            match self.active[i].try_wait()? {
                Some(status) => {
                    let child = self.active.remove(i);
                    println!("âœ… Completed: PID {} - {}", child.id(), status);
                    self.try_start_pending();
                }
                None => {
                    i += 1;
                }
            }
        }
        Ok(())
    }

    fn wait_all(&mut self) -> Result<(), std::io::Error> {
        while !self.active.is_empty() || !self.pending.is_empty() {
            self.wait_any()?;
            std::thread::sleep(std::time::Duration::from_millis(100));
        }
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut pool = ProcessPool::new(3);

    // Submit 10 tasks
    for i in 0..10 {
        pool.submit("sleep".to_string(), vec![format!("{}", i % 3 + 1)]);
    }

    println!("â³ Waiting for all tasks...");
    pool.wait_all()?;
    println!("âœ… All tasks completed!");

    Ok(())
}
```

---

### æ¡ˆä¾‹6: è¿›ç¨‹çœ‹é—¨ç‹—

è‡ªåŠ¨é‡å¯å´©æºƒçš„è¿›ç¨‹ï¼š

```rust
use std::process::{Command, Child};
use std::time::{Duration, Instant};

struct ProcessWatchdog {
    program: String,
    args: Vec<String>,
    child: Option<Child>,
    restart_count: u32,
    max_restarts: u32,
}

impl ProcessWatchdog {
    fn new(program: String, args: Vec<String>, max_restarts: u32) -> Self {
        Self {
            program,
            args,
            child: None,
            restart_count: 0,
            max_restarts,
        }
    }

    fn start(&mut self) -> Result<(), std::io::Error> {
        let child = Command::new(&self.program)
            .args(&self.args)
            .spawn()?;

        println!("ğŸš€ Process started: PID {}", child.id());
        self.child = Some(child);
        Ok(())
    }

    fn monitor(&mut self, check_interval: Duration) -> Result<(), std::io::Error> {
        self.start()?;

        loop {
            std::thread::sleep(check_interval);

            if let Some(ref mut child) = self.child {
                match child.try_wait()? {
                    Some(status) => {
                        println!("âš ï¸  Process exited: {}", status);

                        if self.restart_count < self.max_restarts {
                            self.restart_count += 1;
                            println!("ğŸ”„ Restarting... ({}/{})",
                                self.restart_count, self.max_restarts);
                            self.child = None;
                            self.start()?;
                        } else {
                            println!("âŒ Max restarts reached");
                            break;
                        }
                    }
                    None => {
                        // Process still running
                    }
                }
            }
        }

        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut watchdog = ProcessWatchdog::new(
        "your_program".to_string(),
        vec![],
        3,
    );

    watchdog.monitor(Duration::from_secs(2))?;
    Ok(())
}
```

---

### æ¡ˆä¾‹7: èµ„æºé™åˆ¶æ‰§è¡Œ

é™åˆ¶è¿›ç¨‹çš„èµ„æºä½¿ç”¨ï¼ˆUnixï¼‰ï¼š

```rust
#[cfg(unix)]
use std::process::{Command, Stdio};

#[cfg(unix)]
fn spawn_limited(program: &str, memory_mb: usize) -> std::io::Result<std::process::Child> {
    Command::new("sh")
        .arg("-c")
        .arg(format!(
            "ulimit -v {} && exec {}",
            memory_mb * 1024,
            program
        ))
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
}

#[cfg(unix)]
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ Starting process with 512MB memory limit");

    let mut child = spawn_limited("python3", 512)?;
    let output = child.wait_with_output()?;

    if output.status.success() {
        println!("âœ… Process completed successfully");
    } else {
        println!("âŒ Process failed: {}",
            String::from_utf8_lossy(&output.stderr));
    }

    Ok(())
}

#[cfg(not(unix))]
fn main() {
    println!("This example is Unix-only");
}
```

---

## 6. æœ€ä½³å®è·µ

**âœ… DO**:

- å§‹ç»ˆå¤„ç†é”™è¯¯ï¼ˆä½¿ç”¨ `?` æˆ– `match`ï¼‰
- åŠæ—¶å›æ”¶å­è¿›ç¨‹ï¼ˆè°ƒç”¨ `wait()` æˆ– `try_wait()`ï¼‰
- ä½¿ç”¨ `Stdio::null()` å¿½ç•¥ä¸éœ€è¦çš„è¾“å‡º
- å®ç°è¶…æ—¶æœºåˆ¶é˜²æ­¢æŒ‚èµ·
- ä½¿ç”¨ RAII æ¨¡å¼ç®¡ç†è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸ

**âŒ DON'T**:

- ä¸è¦å¿½ç•¥ `spawn()` çš„é”™è¯¯
- ä¸è¦å¿˜è®°ç­‰å¾…å­è¿›ç¨‹ï¼ˆä¼šäº§ç”Ÿåƒµå°¸è¿›ç¨‹ï¼‰
- ä¸è¦å‡è®¾è¿›ç¨‹ä¸€å®šä¼šæˆåŠŸ
- ä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨ `unwrap()`
- ä¸è¦å¿½ç•¥ä¿¡å·å¤„ç†ï¼ˆUnixï¼‰

**é«˜çº§æŠ€å·§**:

1. **ä½¿ç”¨ `try_wait()` å®ç°éé˜»å¡ç›‘æ§**:

   ```rust
   loop {
       match child.try_wait()? {
           Some(status) => {
               println!("Process finished: {}", status);
               break;
           }
           None => {
               // Process still running, do other work
               std::thread::sleep(Duration::from_millis(100));
           }
       }
   }
   ```

2. **å®ç°ä¼˜é›…çš„å…³é—­**:

   ```rust
   impl Drop for ManagedProcess {
       fn drop(&mut self) {
           // Try graceful shutdown first
           if let Some(ref mut child) = self.child {
               #[cfg(unix)]
               {
                   // Send SIGTERM
                   unsafe {
                       libc::kill(child.id() as i32, libc::SIGTERM);
                   }

                   // Wait briefly
                   std::thread::sleep(Duration::from_millis(1000));

                   // Force kill if still alive
                   let _ = child.kill();
               }

               #[cfg(not(unix))]
               {
                   let _ = child.kill();
               }

               let _ = child.wait();
           }
       }
   }
   ```

3. **é¿å…ç®¡é“æ­»é”**:

   ```rust
   // âŒ Wrong: can deadlock if buffer fills
   let mut child = Command::new("program")
       .stdout(Stdio::piped())
       .spawn()?;
   let output = child.wait_with_output()?;

   // âœ… Better: use separate threads or async
   use std::io::Read;
   use std::thread;

   let mut child = Command::new("program")
       .stdout(Stdio::piped())
       .spawn()?;

   let mut stdout = child.stdout.take().unwrap();
   let handle = thread::spawn(move || {
       let mut buffer = String::new();
       stdout.read_to_string(&mut buffer).unwrap();
       buffer
   });

   child.wait()?;
   let output = handle.join().unwrap();
   ```

4. **è·¨å¹³å°è¿›ç¨‹åˆ›å»º**:

   ```rust
   fn create_shell_command(cmd: &str) -> Command {
       if cfg!(windows) {
           let mut command = Command::new("cmd");
           command.args(&["/C", cmd]);
           command
       } else {
           let mut command = Command::new("sh");
           command.args(&["-c", cmd]);
           command
       }
   }
   ```

---

## 7. ç»ƒä¹ é¢˜

**ç»ƒä¹ 1**: åˆ›å»ºä¸€ä¸ªç¨‹åºï¼Œè¿è¡Œ `ls -la`ï¼ˆUnixï¼‰æˆ– `dir`ï¼ˆWindowsï¼‰ï¼Œå¹¶æ‰“å°è¾“å‡ºã€‚

**ç»ƒä¹ 2**: å®ç°ä¸€ä¸ªè¶…æ—¶è¿è¡Œå™¨ï¼Œå¦‚æœè¿›ç¨‹è¿è¡Œè¶…è¿‡æŒ‡å®šæ—¶é—´å°±ç»ˆæ­¢å®ƒã€‚

**ç»ƒä¹ 3**: åˆ›å»ºä¸€ä¸ªè¿›ç¨‹æ± ï¼ŒåŒæ—¶è¿è¡Œå¤šä¸ªè¿›ç¨‹å¹¶ç­‰å¾…æ‰€æœ‰å®Œæˆã€‚

**ç»ƒä¹ 4**: å®ç°ä¸€ä¸ªäº¤äº’å¼shellåŒ…è£…å™¨ï¼Œæ”¯æŒå¤šæ¬¡å‘½ä»¤è¾“å…¥è¾“å‡ºã€‚

---

## 8. å¸¸è§é—®é¢˜è§£ç­”

### Q1: å¦‚ä½•åˆ¤æ–­è¿›ç¨‹æ˜¯å¦åœ¨è¿è¡Œï¼Ÿ

**A**: ä½¿ç”¨ `try_wait()` æ–¹æ³•è¿›è¡Œéé˜»å¡æ£€æŸ¥ï¼š

```rust
match child.try_wait()? {
    Some(_) => println!("Process finished"),
    None => println!("Process still running"),
}
```

---

### Q2: ä¸ºä»€ä¹ˆä¼šå‡ºç°åƒµå°¸è¿›ç¨‹ï¼Ÿ

**A**: å½“çˆ¶è¿›ç¨‹æ²¡æœ‰è°ƒç”¨ `wait()` å›æ”¶å­è¿›ç¨‹æ—¶ï¼Œå­è¿›ç¨‹ä¼šæˆä¸ºåƒµå°¸è¿›ç¨‹ã€‚è§£å†³æ–¹æ³•ï¼š

```rust
// âœ… æ€»æ˜¯è°ƒç”¨ wait() æˆ– try_wait()
let status = child.wait()?;

// âœ… æˆ–è€…ä½¿ç”¨ Drop traitè‡ªåŠ¨å›æ”¶
impl Drop for ProcessGuard {
    fn drop(&mut self) {
        let _ = self.child.wait();
    }
}
```

---

### Q3: å¦‚ä½•å¤„ç†å¤§é‡è¾“å‡ºé¿å…ç®¡é“é˜»å¡ï¼Ÿ

**A**: ä½¿ç”¨å•ç‹¬çš„çº¿ç¨‹æˆ–å¼‚æ­¥IOè¯»å–è¾“å‡ºï¼š

```rust
use std::io::Read;
use std::thread;

let mut child = Command::new("program")
    .stdout(Stdio::piped())
    .spawn()?;

let mut stdout = child.stdout.take().unwrap();
thread::spawn(move || {
    let mut buffer = Vec::new();
    stdout.read_to_end(&mut buffer).unwrap();
    buffer
});

child.wait()?;
```

---

### Q4: Windowså’ŒUnixçš„è¿›ç¨‹ç®¡ç†æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**: ä¸»è¦åŒºåˆ«ï¼š

| ç‰¹æ€§   | Unix               | Windows         |
| ------ | ------------------ | --------------- |
| è¿›ç¨‹æ ‘ | fork()å½¢æˆå±‚çº§     | ç‹¬ç«‹åˆ›å»º        |
| ä¿¡å·   | SIGTERM, SIGKILLç­‰ | æœ‰é™æ”¯æŒ        |
| é€€å‡ºç  | 0-255              | 0-4294967295    |
| Shell  | sh, bash           | cmd, powershell |
| è¿›ç¨‹ç»„ | æ”¯æŒ               | æœ‰é™æ”¯æŒ        |

è·¨å¹³å°ç¤ºä¾‹ï¼š

```rust
#[cfg(unix)]
fn kill_process_group(child: &Child) {
    use std::os::unix::process::CommandExt;
    unsafe {
        libc::killpg(child.id() as i32, libc::SIGTERM);
    }
}

#[cfg(windows)]
fn kill_process_group(child: &Child) {
    // Windows doesn't have direct process group concept
    child.kill().ok();
}
```

---

### Q5: å¦‚ä½•å®ç°è¿›ç¨‹è¶…æ—¶ï¼Ÿ

**A**: ä½¿ç”¨ `try_wait()` å¾ªç¯é…åˆè®¡æ—¶å™¨ï¼š

```rust
use std::time::{Duration, Instant};

fn wait_with_timeout(child: &mut Child, timeout: Duration) -> Result<ExitStatus, String> {
    let start = Instant::now();

    loop {
        match child.try_wait() {
            Ok(Some(status)) => return Ok(status),
            Ok(None) => {
                if start.elapsed() > timeout {
                    child.kill().ok();
                    return Err("Timeout".to_string());
                }
                std::thread::sleep(Duration::from_millis(100));
            }
            Err(e) => return Err(e.to_string()),
        }
    }
}
```

---

### Q6: å¦‚ä½•åœ¨è¿›ç¨‹é—´å…±äº«æ•°æ®ï¼Ÿ

**A**: ä½¿ç”¨IPCæœºåˆ¶ï¼š

1. **ç®¡é“**: é€šè¿‡stdin/stdouté€šä¿¡
2. **å…±äº«å†…å­˜**: ä½¿ç”¨`shared_memory` crate
3. **æ¶ˆæ¯é˜Ÿåˆ—**: ä½¿ç”¨`ipc-channel` crate
4. **ç½‘ç»œsocket**: TCP/UDPæœ¬åœ°é€šä¿¡

ç¤ºä¾‹ï¼ˆç®¡é“ï¼‰ï¼š

```rust
let mut child = Command::new("grep")
    .arg("pattern")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// å†™å…¥æ•°æ®
if let Some(ref mut stdin) = child.stdin {
    stdin.write_all(b"data to process\n")?;
}

// è¯»å–ç»“æœ
let output = child.wait_with_output()?;
```

---

### Q7: å¦‚ä½•é™åˆ¶è¿›ç¨‹èµ„æºä½¿ç”¨ï¼Ÿ

**A**:

**Unix** - ä½¿ç”¨ `ulimit` æˆ– `setrlimit`:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

Command::new("program")
    .pre_exec(|| {
        // é™åˆ¶è™šæ‹Ÿå†…å­˜ä¸º512MB
        unsafe {
            let limit = libc::rlimit {
                rlim_cur: 512 * 1024 * 1024,
                rlim_max: 512 * 1024 * 1024,
            };
            libc::setrlimit(libc::RLIMIT_AS, &limit);
        }
        Ok(())
    })
    .spawn()?;
```

**Windows** - ä½¿ç”¨Job Objects:

```rust
// éœ€è¦ä½¿ç”¨ winapi crate
#[cfg(windows)]
use winapi::um::jobapi2::*;
```

---

### Q8: å¦‚ä½•æ•è·Ctrl+Cä¿¡å·å¹¶æ¸…ç†å­è¿›ç¨‹ï¼Ÿ

**A**: ä½¿ç”¨ `ctrlc` crate:

```rust
use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicBool, Ordering};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    ctrlc::set_handler(move || {
        r.store(false, Ordering::SeqCst);
    })?;

    let mut child = Command::new("long_running_task").spawn()?;

    while running.load(Ordering::SeqCst) {
        match child.try_wait()? {
            Some(status) => {
                println!("Process finished: {}", status);
                break;
            }
            None => std::thread::sleep(Duration::from_millis(100)),
        }
    }

    if running.load(Ordering::SeqCst) == false {
        println!("Received Ctrl+C, killing child...");
        child.kill()?;
        child.wait()?;
    }

    Ok(())
}
```

---

### Q9: å¦‚ä½•å®ç°è¿›ç¨‹æ—¥å¿—è½®è½¬ï¼Ÿ

**A**: ç›‘æ§è¾“å‡ºå¹¶è‡ªåŠ¨åˆ‡æ¢æ—¥å¿—æ–‡ä»¶ï¼š

```rust
use std::fs::OpenOptions;
use std::io::{BufRead, BufReader, Write};

struct LogRotator {
    base_path: String,
    max_size: u64,
    current_file: usize,
    current_size: u64,
}

impl LogRotator {
    fn new(base_path: String, max_size: u64) -> Self {
        Self {
            base_path,
            max_size,
            current_file: 0,
            current_size: 0,
        }
    }

    fn write_line(&mut self, line: &str) -> std::io::Result<()> {
        if self.current_size > self.max_size {
            self.current_file += 1;
            self.current_size = 0;
        }

        let path = format!("{}.{}", self.base_path, self.current_file);
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)?;

        writeln!(file, "{}", line)?;
        self.current_size += line.len() as u64 + 1;
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("program")
        .stdout(Stdio::piped())
        .spawn()?;

    let stdout = child.stdout.take().unwrap();
    let reader = BufReader::new(stdout);

    let mut rotator = LogRotator::new("output.log".to_string(), 1024 * 1024);

    for line in reader.lines() {
        let line = line?;
        rotator.write_line(&line)?;
    }

    child.wait()?;
    Ok(())
}
```

---

### Q10: å¦‚ä½•è°ƒè¯•è¿›ç¨‹é—®é¢˜ï¼Ÿ

**A**: å¸¸ç”¨è°ƒè¯•æŠ€å·§ï¼š

1. **å¯ç”¨è¯¦ç»†è¾“å‡º**:

   ```rust
   let output = Command::new("program")
       .env("RUST_LOG", "debug")
       .env("RUST_BACKTRACE", "1")
       .output()?;

   println!("stdout: {}", String::from_utf8_lossy(&output.stdout));
   println!("stderr: {}", String::from_utf8_lossy(&output.stderr));
   println!("status: {}", output.status);
   ```

2. **æ£€æŸ¥ç¯å¢ƒå˜é‡**:

   ```rust
   println!("PATH: {:?}", std::env::var("PATH"));
   println!("Current dir: {:?}", std::env::current_dir());
   ```

3. **ä½¿ç”¨strace/truss(Unix)æˆ–Process Monitor(Windows)**:

   ```bash
   # Unix
   strace -f your_program

   # Windows
   procmon.exe
   ```

4. **è®°å½•æ‰€æœ‰spawnè°ƒç”¨**:

   ```rust
   fn spawn_logged(cmd: &mut Command) -> std::io::Result<Child> {
       eprintln!("ğŸš€ Spawning: {:?}", cmd);
       let child = cmd.spawn()?;
       eprintln!("âœ… PID: {}", child.id());
       Ok(child)
   }
   ```

---

## 9. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 9.1 å‡å°‘è¿›ç¨‹åˆ›å»ºå¼€é”€

è¿›ç¨‹åˆ›å»ºæ˜¯æ˜‚è´µçš„æ“ä½œï¼Œè€ƒè™‘ï¼š

1. **è¿›ç¨‹æ± å¤ç”¨**:

   ```rust
   struct ProcessPool {
       workers: Vec<Child>,
   }

   impl ProcessPool {
       fn reuse_worker(&mut self) -> &mut Child {
           // å¤ç”¨å·²å®Œæˆçš„worker
           for worker in &mut self.workers {
               if let Ok(Some(_)) = worker.try_wait() {
                   return worker;
               }
           }
           // æˆ–åˆ›å»ºæ–°worker
           self.workers.push(self.spawn_new_worker());
           self.workers.last_mut().unwrap()
       }
   }
   ```

2. **æ‰¹å¤„ç†ä»»åŠ¡**:

```rust
// âŒ æ¯æ¬¡åˆ›å»ºè¿›ç¨‹
for item in items {
    Command::new("process").arg(item).output()?;
}

// âœ… æ‰¹é‡å¤„ç†
let items_str = items.join("\n");
Command::new("process")
    .stdin(Stdio::piped())
    .spawn()?
    .stdin.as_mut().unwrap()
    .write_all(items_str.as_bytes())?;
```

---

### 9.2 ä¼˜åŒ–è¾“å‡ºå¤„ç†

é¿å…ä¸å¿…è¦çš„ç¼“å†²å’Œå¤åˆ¶ï¼š

```rust
// âŒ ä½æ•ˆï¼šå¤šæ¬¡å¤åˆ¶
let output = child.wait_with_output()?;
let text = String::from_utf8(output.stdout)?;

// âœ… æµå¼å¤„ç†
let stdout = child.stdout.take().unwrap();
let reader = BufReader::new(stdout);
for line in reader.lines() {
    process_line(&line?);
}
```

---

### 9.3 å¹¶è¡Œæ‰§è¡Œç­–ç•¥

æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©ç­–ç•¥ï¼š

```rust
// CPUå¯†é›†å‹ï¼šé™åˆ¶å¹¶å‘æ•°
let semaphore = Arc::new(Semaphore::new(num_cpus::get()));

// IOå¯†é›†å‹ï¼šæ›´é«˜å¹¶å‘
let semaphore = Arc::new(Semaphore::new(num_cpus::get() * 4));

// æ··åˆå‹ï¼šåŠ¨æ€è°ƒæ•´
struct AdaptivePool {
    cpu_tasks: usize,
    io_tasks: usize,
    max_workers: usize,
}
```

---

### 9.4 å†…å­˜ä¼˜åŒ–

1. **é¿å…è¾“å‡ºç´¯ç§¯**:

   ```rust
   // âŒ å†…å­˜å¯èƒ½çˆ†ç‚¸
   let output = Command::new("generate_huge_output").output()?;

   // âœ… æµå¼å¤„ç†æˆ–ä¸¢å¼ƒ
   Command::new("generate_huge_output")
       .stdout(Stdio::null())
       .spawn()?;
   ```

2. **åŠæ—¶å›æ”¶èµ„æº**:

   ```rust
   impl Drop for ManagedChild {
       fn drop(&mut self) {
           let _ = self.child.kill();
           let _ = self.child.wait();
       }
   }
   ```

---

## 10. å®‰å…¨æ³¨æ„äº‹é¡¹

### 10.1 å‘½ä»¤æ³¨å…¥é˜²æŠ¤

**æ°¸è¿œä¸è¦**ç›´æ¥æ‹¼æ¥ç”¨æˆ·è¾“å…¥ï¼š

```rust
// âŒ å±é™©ï¼å‘½ä»¤æ³¨å…¥é£é™©
let user_input = get_user_input();
Command::new("sh")
    .arg("-c")
    .arg(format!("ls {}", user_input))
    .spawn()?;

// âœ… å®‰å…¨ï¼šä½¿ç”¨å‚æ•°åŒ–
Command::new("ls")
    .arg(user_input)
    .spawn()?;
```

---

### 10.2 æƒé™æœ€å°åŒ–

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

#[cfg(unix)]
Command::new("program")
    .uid(1000)  // ä½¿ç”¨érootç”¨æˆ·
    .gid(1000)
    .spawn()?;
```

---

### 10.3 è¾“å…¥éªŒè¯

```rust
fn is_safe_command(cmd: &str) -> bool {
    // ç™½åå•éªŒè¯
    const ALLOWED: &[&str] = &["ls", "cat", "grep"];
    ALLOWED.contains(&cmd)
}

fn execute_safely(cmd: &str, args: &[&str]) -> Result<Output, String> {
    if !is_safe_command(cmd) {
        return Err(format!("Command '{}' not allowed", cmd));
    }

    Command::new(cmd)
        .args(args)
        .output()
        .map_err(|e| e.to_string())
}
```

---

### 10.4 å®¡è®¡å’Œæ—¥å¿—

```rust
struct AuditedCommand {
    command: Command,
    audit_log: String,
}

impl AuditedCommand {
    fn spawn(mut self) -> std::io::Result<Child> {
        let log_entry = format!(
            "[{}] {:?} in {:?}",
            chrono::Utc::now(),
            self.command,
            std::env::current_dir()?
        );

        // è®°å½•åˆ°å®¡è®¡æ—¥å¿—
        std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.audit_log)?
            .write_all(log_entry.as_bytes())?;

        self.command.spawn()
    }
}
```

---

## ä¸‹ä¸€æ­¥

- [IPCé€šä¿¡å®è·µ](./02_IPCé€šä¿¡å®è·µ.md) - å­¦ä¹ è¿›ç¨‹é—´é€šä¿¡
- [å¼‚æ­¥è¿›ç¨‹ç®¡ç†](./03_å¼‚æ­¥è¿›ç¨‹ç®¡ç†.md) - ä½¿ç”¨Tokioå¼‚æ­¥ç®¡ç†
- [è¿›ç¨‹æ¨¡å‹å‚è€ƒ](../tier_03_references/01_è¿›ç¨‹æ¨¡å‹å‚è€ƒ.md) - æ·±å…¥ç†è®º

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
