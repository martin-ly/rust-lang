# Tier 2: 进程管理快速入门

> **文档类型**: 实践指南  
> **难度**: ⭐⭐ 初级  
> **预计时间**: 2小时  
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 进程管理快速入门](#tier-2-进程管理快速入门)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 创建进程](#1-创建进程)
    - [1.1 基础用法](#11-基础用法)
    - [1.2 配置选项](#12-配置选项)
    - [1.3 三种启动方式](#13-三种启动方式)
  - [2. 管理进程](#2-管理进程)
    - [2.1 等待进程完成](#21-等待进程完成)
    - [2.2 获取进程状态](#22-获取进程状态)
    - [2.3 终止进程](#23-终止进程)
  - [3. 进程I/O](#3-进程io)
    - [3.1 捕获输出](#31-捕获输出)
    - [3.2 传递输入](#32-传递输入)
    - [3.3 实时通信](#33-实时通信)
  - [4. 错误处理](#4-错误处理)
    - [4.1 启动错误](#41-启动错误)
    - [4.2 执行错误](#42-执行错误)
    - [4.3 超时处理](#43-超时处理)
  - [5. 实战案例](#5-实战案例)
    - [案例1: 命令行包装器](#案例1-命令行包装器)
    - [案例2: 进程监控器](#案例2-进程监控器)
  - [6. 最佳实践](#6-最佳实践)
  - [7. 练习题](#7-练习题)
  - [下一步](#下一步)

---

## 学习目标

完成本指南后，你将能够：

- ✅ 创建和配置子进程
- ✅ 管理进程生命周期
- ✅ 处理进程输入输出
- ✅ 实现健壮的错误处理
- ✅ 构建实用的进程管理工具

---

## 1. 创建进程

### 1.1 基础用法

使用 `Command` 创建进程：

```rust
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建并运行进程
    let output = Command::new("echo")
        .arg("Hello, World!")
        .output()?;
    
    println!("status: {}", output.status);
    println!("stdout: {}", String::from_utf8_lossy(&output.stdout));
    
    Ok(())
}
```

**关键点**:

- `Command::new()`: 指定程序路径
- `.arg()`: 添加命令行参数
- `.output()`: 等待完成并获取输出

---

### 1.2 配置选项

**设置工作目录**:

```rust
let output = Command::new("ls")
    .current_dir("/tmp")
    .output()?;
```

**设置环境变量**:

```rust
let output = Command::new("env")
    .env("MY_VAR", "my_value")
    .env_clear()  // 清除继承的环境变量
    .env("PATH", "/usr/bin")
    .output()?;
```

**完整配置示例**:

```rust
let mut child = Command::new("my_program")
    .arg("--config")
    .arg("config.toml")
    .current_dir("/app")
    .env("LOG_LEVEL", "debug")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .stderr(Stdio::piped())
    .spawn()?;
```

---

### 1.3 三种启动方式

**方式1: `output()` - 等待并获取输出**:

```rust
let output = Command::new("ls").output()?;
// 阻塞直到进程完成
// 返回 Output { status, stdout, stderr }
```

**方式2: `status()` - 只获取退出状态**:

```rust
let status = Command::new("ls").status()?;
// 阻塞直到进程完成
// 只返回 ExitStatus
```

**方式3: `spawn()` - 立即返回**:

```rust
let mut child = Command::new("sleep")
    .arg("10")
    .spawn()?;
// 立即返回，进程在后台运行
// 返回 Child 对象
```

**对比**:

| 方法 | 阻塞 | 返回值 | 用途 |
|------|------|--------|------|
| `output()` | 是 | `Output` | 需要捕获输出 |
| `status()` | 是 | `ExitStatus` | 只关心退出状态 |
| `spawn()` | 否 | `Child` | 需要后续操作 |

---

## 2. 管理进程

### 2.1 等待进程完成

**阻塞等待**:

```rust
let mut child = Command::new("sleep")
    .arg("5")
    .spawn()?;

// 阻塞直到子进程完成
let status = child.wait()?;
println!("进程退出: {}", status);
```

**非阻塞检查**:

```rust
let mut child = Command::new("long_task").spawn()?;

loop {
    match child.try_wait()? {
        Some(status) => {
            println!("进程完成: {}", status);
            break;
        }
        None => {
            println!("仍在运行...");
            std::thread::sleep(std::time::Duration::from_secs(1));
        }
    }
}
```

---

### 2.2 获取进程状态

**获取PID**:

```rust
let child = Command::new("app").spawn()?;
println!("进程ID: {}", child.id());
```

**检查退出状态**:

```rust
let status = child.wait()?;

if status.success() {
    println!("成功");
} else {
    if let Some(code) = status.code() {
        eprintln!("失败，退出码: {}", code);
    } else {
        eprintln!("被信号终止");
    }
}
```

**Unix信号检查**:

```rust
#[cfg(unix)]
{
    use std::os::unix::process::ExitStatusExt;
    
    if let Some(signal) = status.signal() {
        eprintln!("被信号 {} 终止", signal);
    }
}
```

---

### 2.3 终止进程

**强制终止**:

```rust
let mut child = Command::new("app").spawn()?;

// 终止进程
child.kill()?;

// 回收资源
child.wait()?;
```

**Unix优雅终止**:

```rust
#[cfg(unix)]
{
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;
    
    let pid = Pid::from_raw(child.id() as i32);
    
    // 发送SIGTERM（优雅终止）
    kill(pid, Signal::SIGTERM)?;
    
    // 等待5秒
    std::thread::sleep(std::time::Duration::from_secs(5));
    
    // 检查是否还在运行
    if child.try_wait()?.is_none() {
        // 强制SIGKILL
        kill(pid, Signal::SIGKILL)?;
    }
    
    child.wait()?;
}
```

---

## 3. 进程I/O

### 3.1 捕获输出

**基础捕获**:

```rust
let output = Command::new("echo")
    .arg("Hello")
    .output()?;

let stdout = String::from_utf8_lossy(&output.stdout);
let stderr = String::from_utf8_lossy(&output.stderr);

println!("标准输出: {}", stdout);
println!("标准错误: {}", stderr);
```

**分离读取**:

```rust
use std::io::Read;

let mut child = Command::new("cat")
    .arg("file.txt")
    .stdout(Stdio::piped())
    .spawn()?;

if let Some(mut stdout) = child.stdout.take() {
    let mut buffer = String::new();
    stdout.read_to_string(&mut buffer)?;
    println!("{}", buffer);
}

child.wait()?;
```

---

### 3.2 传递输入

**写入stdin**:

```rust
use std::io::Write;

let mut child = Command::new("cat")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// 写入数据
if let Some(mut stdin) = child.stdin.take() {
    stdin.write_all(b"Hello from stdin!\n")?;
    // drop(stdin) 自动关闭
}

// 读取输出
let output = child.wait_with_output()?;
println!("{}", String::from_utf8_lossy(&output.stdout));
```

---

### 3.3 实时通信

**双向通信**:

```rust
use std::io::{BufRead, BufReader, Write};

let mut child = Command::new("python")
    .arg("-u")  // unbuffered
    .arg("interactive.py")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

let mut stdin = child.stdin.take().unwrap();
let stdout = child.stdout.take().unwrap();
let reader = BufReader::new(stdout);

// 写入
stdin.write_all(b"input1\n")?;
stdin.flush()?;

// 读取响应
for line in reader.lines().take(1) {
    println!("Response: {}", line?);
}

child.kill()?;
child.wait()?;
```

---

## 4. 错误处理

### 4.1 启动错误

```rust
use std::io::ErrorKind;

match Command::new("nonexistent_program").spawn() {
    Ok(child) => println!("成功启动: PID {}", child.id()),
    Err(e) => match e.kind() {
        ErrorKind::NotFound => {
            eprintln!("❌ 程序不存在");
        }
        ErrorKind::PermissionDenied => {
            eprintln!("❌ 权限不足");
        }
        _ => {
            eprintln!("❌ 其他错误: {}", e);
        }
    }
}
```

---

### 4.2 执行错误

```rust
let output = Command::new("app")
    .arg("--config")
    .arg("missing.toml")
    .output()?;

if !output.status.success() {
    let stderr = String::from_utf8_lossy(&output.stderr);
    eprintln!("执行失败:\n{}", stderr);
    
    if let Some(code) = output.status.code() {
        eprintln!("退出码: {}", code);
    }
}
```

---

### 4.3 超时处理

```rust
use std::time::{Duration, Instant};

let mut child = Command::new("slow_task").spawn()?;
let timeout = Duration::from_secs(30);
let start = Instant::now();

loop {
    match child.try_wait()? {
        Some(status) => {
            println!("✅ 完成: {}", status);
            break;
        }
        None if start.elapsed() >= timeout => {
            eprintln!("⏰ 超时，终止进程");
            child.kill()?;
            child.wait()?;
            return Err("Timeout".into());
        }
        None => {
            std::thread::sleep(Duration::from_millis(100));
        }
    }
}
```

---

## 5. 实战案例

### 案例1: 命令行包装器

封装系统命令，提供友好接口：

```rust
use std::process::Command;

struct ShellCommand {
    command: String,
}

impl ShellCommand {
    fn new(cmd: &str) -> Self {
        Self {
            command: cmd.to_string(),
        }
    }
    
    fn execute(&self) -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("cmd")
                .args(["/C", &self.command])
                .output()?
        } else {
            Command::new("sh")
                .args(["-c", &self.command])
                .output()?
        };
        
        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Command failed: {}", stderr).into())
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cmd = ShellCommand::new("echo Hello && ls");
    let result = cmd.execute()?;
    println!("{}", result);
    Ok(())
}
```

---

### 案例2: 进程监控器

监控进程资源使用：

```rust
use std::process::Command;
use std::time::Duration;

struct ProcessMonitor {
    child: std::process::Child,
}

impl ProcessMonitor {
    fn spawn(program: &str) -> Result<Self, std::io::Error> {
        let child = Command::new(program).spawn()?;
        Ok(Self { child })
    }
    
    fn is_running(&mut self) -> Result<bool, std::io::Error> {
        match self.child.try_wait()? {
            Some(_) => Ok(false),
            None => Ok(true),
        }
    }
    
    fn wait_with_timeout(&mut self, timeout: Duration) 
        -> Result<bool, Box<dyn std::error::Error>> 
    {
        let start = std::time::Instant::now();
        
        while start.elapsed() < timeout {
            if !self.is_running()? {
                return Ok(true);  // 完成
            }
            std::thread::sleep(Duration::from_millis(100));
        }
        
        Ok(false)  // 超时
    }
}

impl Drop for ProcessMonitor {
    fn drop(&mut self) {
        let _ = self.child.kill();
        let _ = self.child.wait();
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut monitor = ProcessMonitor::spawn("sleep")?;
    
    println!("进程启动: PID {}", monitor.child.id());
    
    if monitor.wait_with_timeout(Duration::from_secs(5))? {
        println!("✅ 进程完成");
    } else {
        println!("⏰ 进程超时");
    }
    
    Ok(())
}
```

---

## 6. 最佳实践

**✅ DO**:

- 始终处理错误（使用 `?` 或 `match`）
- 及时回收子进程（调用 `wait()` 或 `try_wait()`）
- 使用 `Stdio::null()` 忽略不需要的输出
- 实现超时机制防止挂起
- 使用 RAII 模式管理进程生命周期

**❌ DON'T**:

- 不要忽略 `spawn()` 的错误
- 不要忘记等待子进程（会产生僵尸进程）
- 不要假设进程一定会成功
- 不要在生产环境中使用 `unwrap()`
- 不要忽略信号处理（Unix）

---

## 7. 练习题

**练习1**: 创建一个程序，运行 `ls -la`（Unix）或 `dir`（Windows），并打印输出。

**练习2**: 实现一个超时运行器，如果进程运行超过指定时间就终止它。

**练习3**: 创建一个进程池，同时运行多个进程并等待所有完成。

**练习4**: 实现一个交互式shell包装器，支持多次命令输入输出。

---

## 下一步

- [IPC通信实践](./02_IPC通信实践.md) - 学习进程间通信
- [异步进程管理](./03_异步进程管理.md) - 使用Tokio异步管理
- [进程模型参考](../tier_03_references/01_进程模型参考.md) - 深入理论

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
