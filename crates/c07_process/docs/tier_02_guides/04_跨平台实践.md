# Tier 2: 跨平台实践

> **文档类型**: 实践指南  
> **难度**: ⭐⭐⭐ 中级  
> **预计时间**: 2小时  
> **适用版本**: Rust 1.90+

---

## 目录

- [Tier 2: 跨平台实践](#tier-2-跨平台实践)
  - [目录](#目录)
  - [学习目标](#学习目标)
  - [1. 平台差异](#1-平台差异)
  - [2. 跨平台命令](#2-跨平台命令)
  - [3. 平台特定功能](#3-平台特定功能)
  - [4. 最佳实践](#4-最佳实践)

---

## 学习目标

- ✅ 理解Windows和Unix的差异
- ✅ 编写跨平台代码
- ✅ 使用条件编译
- ✅ 处理平台特定功能

---

## 1. 平台差异

**核心差异**:

| 特性 | Unix/Linux | Windows |
|------|-----------|---------|
| 进程创建 | fork+exec | CreateProcess |
| 信号 | SIGTERM, SIGKILL | 不支持 |
| 进程组 | 进程组ID | 作业对象 |
| 路径分隔符 | `/` | `\` |
| Shell | sh, bash | cmd, powershell |

---

## 2. 跨平台命令

**Shell命令抽象**:

```rust
fn run_shell_command(cmd: &str) -> Result<String, std::io::Error> {
    let output = if cfg!(windows) {
        Command::new("cmd")
            .args(["/C", cmd])
            .output()?
    } else {
        Command::new("sh")
            .args(["-c", cmd])
            .output()?
    };
    
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
```

**路径处理**:

```rust
use std::path::PathBuf;

fn get_config_path() -> PathBuf {
    if cfg!(windows) {
        PathBuf::from("C:\\config\\app.toml")
    } else {
        PathBuf::from("/etc/app/config.toml")
    }
}
```

---

## 3. 平台特定功能

**Unix特定**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

#[cfg(unix)]
fn set_process_group(cmd: &mut Command) {
    cmd.process_group(0);
}
```

**Windows特定**:

```rust
#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(windows)]
fn hide_window(cmd: &mut Command) {
    const CREATE_NO_WINDOW: u32 = 0x08000000;
    cmd.creation_flags(CREATE_NO_WINDOW);
}
```

---

## 4. 最佳实践

**✅ DO**:

- 使用标准库的跨平台API
- 条件编译处理平台差异
- 测试所有目标平台
- 使用抽象层隔离平台代码

**实用工具**:

```rust
pub struct CrossPlatformCommand {
    program: String,
    args: Vec<String>,
}

impl CrossPlatformCommand {
    pub fn new(program: &str) -> Self {
        Self {
            program: program.to_string(),
            args: Vec::new(),
        }
    }
    
    pub fn arg(mut self, arg: &str) -> Self {
        self.args.push(arg.to_string());
        self
    }
    
    pub fn execute(&self) -> Result<String, Box<dyn std::error::Error>> {
        let output = Command::new(&self.program)
            .args(&self.args)
            .output()?;
        
        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(format!("Command failed").into())
        }
    }
}
```

---

**参考**: [跨平台进程管理](../../docs/06_cross_platform_process_management.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
