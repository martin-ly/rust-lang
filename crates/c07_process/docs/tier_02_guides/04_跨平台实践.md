# Tier 2: è·¨å¹³å°å®è·µ

> **æ–‡æ¡£ç±»å‹**: å®è·µæŒ‡å—
> **éš¾åº¦**: â­â­â­ ä¸­çº§
> **é¢„è®¡æ—¶é—´**: 2å°æ—¶
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+

---

## ç›®å½•

- [Tier 2: è·¨å¹³å°å®è·µ](#tier-2-è·¨å¹³å°å®è·µ)
  - [ç›®å½•](#ç›®å½•)
  - [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
  - [1. å¹³å°å·®å¼‚](#1-å¹³å°å·®å¼‚)
    - [1.1 æ ¸å¿ƒç³»ç»Ÿå·®å¼‚](#11-æ ¸å¿ƒç³»ç»Ÿå·®å¼‚)
    - [1.2 è¿›ç¨‹åˆ›å»ºå·®å¼‚](#12-è¿›ç¨‹åˆ›å»ºå·®å¼‚)
    - [1.3 ä¿¡å·ä¸è¿›ç¨‹ç»ˆæ­¢](#13-ä¿¡å·ä¸è¿›ç¨‹ç»ˆæ­¢)
    - [1.4 è¿›ç¨‹ç»„ç®¡ç†](#14-è¿›ç¨‹ç»„ç®¡ç†)
    - [1.5 æ–‡ä»¶ç³»ç»Ÿè·¯å¾„](#15-æ–‡ä»¶ç³»ç»Ÿè·¯å¾„)
    - [1.6 ç¯å¢ƒå˜é‡](#16-ç¯å¢ƒå˜é‡)
    - [1.7 æ€§èƒ½å·®å¼‚](#17-æ€§èƒ½å·®å¼‚)
  - [2. è·¨å¹³å°å‘½ä»¤](#2-è·¨å¹³å°å‘½ä»¤)
    - [2.1 Shellå‘½ä»¤æŠ½è±¡](#21-shellå‘½ä»¤æŠ½è±¡)
    - [2.2 è·¨å¹³å°Shellå°è£…](#22-è·¨å¹³å°shellå°è£…)
    - [2.3 é€šç”¨å‘½ä»¤æ˜ å°„](#23-é€šç”¨å‘½ä»¤æ˜ å°„)
    - [2.4 æ–‡ä»¶æ“ä½œæŠ½è±¡](#24-æ–‡ä»¶æ“ä½œæŠ½è±¡)
    - [2.5 ç½‘ç»œå‘½ä»¤æŠ½è±¡](#25-ç½‘ç»œå‘½ä»¤æŠ½è±¡)
    - [2.6 ç³»ç»Ÿä¿¡æ¯å‘½ä»¤](#26-ç³»ç»Ÿä¿¡æ¯å‘½ä»¤)
  - [3. å¹³å°ç‰¹å®šåŠŸèƒ½](#3-å¹³å°ç‰¹å®šåŠŸèƒ½)
    - [3.1 Unixç‰¹å®šåŠŸèƒ½](#31-unixç‰¹å®šåŠŸèƒ½)
    - [3.2 Windowsç‰¹å®šåŠŸèƒ½](#32-windowsç‰¹å®šåŠŸèƒ½)
    - [3.3 macOSç‰¹å®šåŠŸèƒ½](#33-macosç‰¹å®šåŠŸèƒ½)
    - [3.4 ç»Ÿä¸€æŠ½è±¡å±‚](#34-ç»Ÿä¸€æŠ½è±¡å±‚)
  - [4. æœ€ä½³å®è·µ](#4-æœ€ä½³å®è·µ)
    - [4.1 è®¾è®¡åŸåˆ™](#41-è®¾è®¡åŸåˆ™)
    - [4.2 æŠ½è±¡å‘½ä»¤æ‰§è¡Œå™¨](#42-æŠ½è±¡å‘½ä»¤æ‰§è¡Œå™¨)
    - [4.3 è·¨å¹³å°é…ç½®ç®¡ç†](#43-è·¨å¹³å°é…ç½®ç®¡ç†)
    - [4.4 æµ‹è¯•ç­–ç•¥](#44-æµ‹è¯•ç­–ç•¥)
    - [4.5 å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ](#45-å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ)
    - [4.6 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#46-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [4.7 è°ƒè¯•æŠ€å·§](#47-è°ƒè¯•æŠ€å·§)
  - [5. å®æˆ˜æ¡ˆä¾‹](#5-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: è·¨å¹³å°è¿›ç¨‹ç›‘æ§](#æ¡ˆä¾‹1-è·¨å¹³å°è¿›ç¨‹ç›‘æ§)
    - [æ¡ˆä¾‹2: è·¨å¹³å°è‡ªåŠ¨æ›´æ–°](#æ¡ˆä¾‹2-è·¨å¹³å°è‡ªåŠ¨æ›´æ–°)
  - [6. æ€»ç»“](#6-æ€»ç»“)

---

## å­¦ä¹ ç›®æ ‡

- âœ… ç†è§£Windowså’ŒUnixçš„å·®å¼‚
- âœ… ç¼–å†™è·¨å¹³å°ä»£ç 
- âœ… ä½¿ç”¨æ¡ä»¶ç¼–è¯‘
- âœ… å¤„ç†å¹³å°ç‰¹å®šåŠŸèƒ½

---

## 1. å¹³å°å·®å¼‚

### 1.1 æ ¸å¿ƒç³»ç»Ÿå·®å¼‚

**æ ¸å¿ƒå·®å¼‚å¯¹ç…§è¡¨**:

| ç‰¹æ€§ | Unix/Linux | Windows | å…¼å®¹æ€§ |
| --- | --- | --- | --- |
| è¿›ç¨‹åˆ›å»º | fork+exec | CreateProcess | ä¸åŒ API |
| ä¿¡å·ç³»ç»Ÿ | SIGTERM, SIGKILL, etc. | GenerateConsoleCtrlEvent | éƒ¨åˆ†å…¼å®¹ |
| è¿›ç¨‹ç»„ | è¿›ç¨‹ç»„ID (PGID) | ä½œä¸šå¯¹è±¡ (Job Objects) | ä¸åŒæœºåˆ¶ |
| è·¯å¾„åˆ†éš”ç¬¦ | `/` | `\` | PathBuf è‡ªåŠ¨å¤„ç† |
| Shell | sh, bash, zsh | cmd, powershell | éœ€è¦æŠ½è±¡å±‚ |
| æ–‡ä»¶æƒé™ | chmod, umask | ACL | å®Œå…¨ä¸åŒ |
| ç¯å¢ƒå˜é‡ | $VAR | %VAR% | å¯ç”¨ä½†è¯­æ³•ä¸åŒ |
| è¡Œç»“æŸç¬¦ | LF (`\n`) | CRLF (`\r\n`) | éœ€è¦æ³¨æ„ |
| è¿›ç¨‹æ ‘ç»ˆæ­¢ | kill -TERM -PGID | TerminateJobObject | éœ€è¦å¹³å°ç‰¹å®šä»£ç  |
| å®ˆæŠ¤è¿›ç¨‹ | daemon() | Windows Service | å®Œå…¨ä¸åŒ |

---

### 1.2 è¿›ç¨‹åˆ›å»ºå·®å¼‚

**Unix: fork+execæ¨¡å‹**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

#[cfg(unix)]
fn unix_process_creation() {
    Command::new("ls")
        .arg("-la")
        // Unixç‰¹å®šé€‰é¡¹
        .uid(1000)  // è®¾ç½®ç”¨æˆ·ID
        .gid(1000)  // è®¾ç½®ç»„ID
        .process_group(0)  // æ–°è¿›ç¨‹ç»„
        .spawn()
        .expect("Failed to spawn");
}
```

**Windows: CreateProcess**:

```rust
#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(windows)]
fn windows_process_creation() {
    const CREATE_NO_WINDOW: u32 = 0x08000000;
    const CREATE_NEW_PROCESS_GROUP: u32 = 0x00000200;

    Command::new("cmd")
        .args(["/C", "dir"])
        // Windowsç‰¹å®šé€‰é¡¹
        .creation_flags(CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP)
        .spawn()
        .expect("Failed to spawn");
}
```

---

### 1.3 ä¿¡å·ä¸è¿›ç¨‹ç»ˆæ­¢

**Unixä¿¡å·**:

```rust
#[cfg(unix)]
use nix::sys::signal::{Signal, kill};
#[cfg(unix)]
use nix::unistd::Pid;

#[cfg(unix)]
fn send_signal_unix(pid: u32, signal: Signal) -> Result<(), Box<dyn std::error::Error>> {
    let pid = Pid::from_raw(pid as i32);
    kill(pid, signal)?;
    Ok(())
}

#[cfg(unix)]
fn graceful_shutdown_unix(pid: u32) -> Result<(), Box<dyn std::error::Error>> {
    let pid = Pid::from_raw(pid as i32);

    // å…ˆå‘é€ SIGTERM
    kill(pid, Signal::SIGTERM)?;

    // ç­‰å¾…ä¸€æ®µæ—¶é—´
    std::thread::sleep(Duration::from_secs(5));

    // æ£€æŸ¥æ˜¯å¦è¿˜æ´»ç€
    match kill(pid, Signal::Signal(0)) {  // signal 0 åªæ£€æŸ¥ï¼Œä¸å‘é€
        Ok(_) => {
            // è¿›ç¨‹è¿˜æ´»ç€ï¼Œå‘é€ SIGKILL
            println!("âš ï¸  Process didn't respond to SIGTERM, sending SIGKILL");
            kill(pid, Signal::SIGKILL)?;
        }
        Err(_) => {
            println!("âœ… Process terminated gracefully");
        }
    }

    Ok(())
}
```

**Windowsè¿›ç¨‹ç»ˆæ­¢**:

```rust
#[cfg(windows)]
use winapi::um::wincon::GenerateConsoleCtrlEvent;
#[cfg(windows)]
use winapi::um::processthreadsapi::TerminateProcess;

#[cfg(windows)]
fn terminate_windows(child: &mut std::process::Child) -> std::io::Result<()> {
    // Windowsä¸Šåªèƒ½å¼ºåˆ¶ç»ˆæ­¢
    child.kill()
}

#[cfg(windows)]
fn send_ctrl_c_windows(pid: u32) -> Result<(), Box<dyn std::error::Error>> {
    unsafe {
        // å°è¯•å‘é€Ctrl+C
        if GenerateConsoleCtrlEvent(0, pid) == 0 {
            return Err("Failed to send Ctrl+C".into());
        }
    }
    Ok(())
}
```

---

### 1.4 è¿›ç¨‹ç»„ç®¡ç†

**Unixè¿›ç¨‹ç»„**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

#[cfg(unix)]
fn create_process_group() -> Result<std::process::Child, std::io::Error> {
    Command::new("sh")
        .arg("-c")
        .arg("sleep 100 & sleep 100 &")
        .process_group(0)  // åˆ›å»ºæ–°è¿›ç¨‹ç»„
        .spawn()
}

#[cfg(unix)]
fn kill_process_group(pgid: i32) -> Result<(), Box<dyn std::error::Error>> {
    use nix::sys::signal::{killpg, Signal};
    use nix::unistd::Pid;

    // ç»ˆæ­¢æ•´ä¸ªè¿›ç¨‹ç»„
    killpg(Pid::from_raw(pgid), Signal::SIGTERM)?;
    Ok(())
}
```

**Windowsä½œä¸šå¯¹è±¡**:

```rust
#[cfg(windows)]
use winapi::um::jobapi2::*;
#[cfg(windows)]
use winapi::um::handleapi::CloseHandle;
#[cfg(windows)]
use std::ptr;

#[cfg(windows)]
struct JobObject {
    handle: *mut winapi::ctypes::c_void,
}

#[cfg(windows)]
impl JobObject {
    fn create() -> Result<Self, Box<dyn std::error::Error>> {
        unsafe {
            let handle = CreateJobObjectW(ptr::null_mut(), ptr::null());
            if handle.is_null() {
                return Err("Failed to create job object".into());
            }
            Ok(Self { handle })
        }
    }

    fn assign_process(&self, child: &std::process::Child) -> Result<(), Box<dyn std::error::Error>> {
        unsafe {
            use std::os::windows::io::AsRawHandle;
            use winapi::um::jobapi2::AssignProcessToJobObject;

            let process_handle = child.as_raw_handle();
            if AssignProcessToJobObject(self.handle, process_handle) == 0 {
                return Err("Failed to assign process to job".into());
            }
        }
        Ok(())
    }

    fn terminate_all(&self) -> Result<(), Box<dyn std::error::Error>> {
        unsafe {
            if TerminateJobObject(self.handle, 1) == 0 {
                return Err("Failed to terminate job".into());
            }
        }
        Ok(())
    }
}

#[cfg(windows)]
impl Drop for JobObject {
    fn drop(&mut self) {
        unsafe {
            CloseHandle(self.handle);
        }
    }
}
```

---

### 1.5 æ–‡ä»¶ç³»ç»Ÿè·¯å¾„

**è·¨å¹³å°è·¯å¾„å¤„ç†**:

```rust
use std::path::{Path, PathBuf};

fn get_home_dir() -> PathBuf {
    if cfg!(windows) {
        PathBuf::from(std::env::var("USERPROFILE").unwrap_or_else(|_| "C:\\Users\\Default".to_string()))
    } else {
        PathBuf::from(std::env::var("HOME").unwrap_or_else(|_| "/home/user".to_string()))
    }
}

fn get_temp_dir() -> PathBuf {
    std::env::temp_dir()  // è·¨å¹³å°ï¼
}

fn normalize_path(path: &str) -> PathBuf {
    // è‡ªåŠ¨å¤„ç† / å’Œ \
    PathBuf::from(path)
}

// æ„å»ºè·¯å¾„
fn build_config_path() -> PathBuf {
    let mut path = get_home_dir();
    path.push(".myapp");
    path.push("config.toml");
    path  // è‡ªåŠ¨ä½¿ç”¨æ­£ç¡®çš„åˆ†éš”ç¬¦
}
```

---

### 1.6 ç¯å¢ƒå˜é‡

**è·¨å¹³å°ç¯å¢ƒå˜é‡å¤„ç†**:

```rust
use std::env;

fn get_path_separator() -> char {
    if cfg!(windows) {
        ';'
    } else {
        ':'
    }
}

fn add_to_path(dir: &str) -> String {
    let current_path = env::var("PATH").unwrap_or_default();
    let separator = get_path_separator();

    format!("{}{}{}", dir, separator, current_path)
}

fn set_environment_for_command(cmd: &mut Command) {
    if cfg!(windows) {
        cmd.env("SYSTEMROOT", r"C:\Windows");
        cmd.env("PATHEXT", ".COM;.EXE;.BAT;.CMD");
    } else {
        cmd.env("HOME", env::var("HOME").unwrap_or_else(|_| "/home/user".to_string()));
        cmd.env("SHELL", "/bin/sh");
    }
}
```

---

### 1.7 æ€§èƒ½å·®å¼‚

**è¿›ç¨‹åˆ›å»ºæ€§èƒ½å¯¹æ¯”**:

| æ“ä½œ | Linux | Windows | å·®å¼‚ |
| --- | --- | --- | --- |
| åˆ›å»º1ä¸ªè¿›ç¨‹ | ~1-3 ms | ~10-20 ms | 3-10x |
| åˆ›å»º100ä¸ªè¿›ç¨‹ | ~100-300 ms | ~1-2 s | 3-7x |
| fork() | ~50 Î¼s | N/A | - |
| exec() | ~1-2 ms | ~10-20 ms | 5-10x |

**ä¼˜åŒ–å»ºè®®**:

- Windows: å‡å°‘è¿›ç¨‹åˆ›å»ºï¼Œä½¿ç”¨çº¿ç¨‹æˆ–è¿›ç¨‹æ± 
- Unix: å¯ä»¥æ›´è‡ªç”±åœ°åˆ›å»ºè¿›ç¨‹
- è·¨å¹³å°: ä½¿ç”¨å¼‚æ­¥+è¿›ç¨‹æ± 

---

## 2. è·¨å¹³å°å‘½ä»¤

### 2.1 Shellå‘½ä»¤æŠ½è±¡

**åŸºç¡€ShellæŠ½è±¡**:

```rust
use std::process::Command;

fn run_shell_command(cmd: &str) -> Result<String, std::io::Error> {
    let output = if cfg!(windows) {
        Command::new("cmd")
            .args(["/C", cmd])
            .output()?
    } else {
        Command::new("sh")
            .args(["-c", cmd])
            .output()?
    };

    if output.status.success() {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    } else {
        Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            String::from_utf8_lossy(&output.stderr).to_string()
        ))
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), std::io::Error> {
    let result = run_shell_command("echo Hello World")?;
    println!("{}", result);
    Ok(())
}
```

---

### 2.2 è·¨å¹³å°Shellå°è£…

```rust
pub enum Shell {
    Sh,
    Bash,
    Cmd,
    PowerShell,
}

impl Shell {
    pub fn default() -> Self {
        if cfg!(windows) {
            Shell::PowerShell
        } else {
            Shell::Bash
        }
    }

    pub fn execute(&self, script: &str) -> Result<String, Box<dyn std::error::Error>> {
        let output = match self {
            Shell::Sh => Command::new("sh").args(["-c", script]).output()?,
            Shell::Bash => Command::new("bash").args(["-c", script]).output()?,
            Shell::Cmd => Command::new("cmd").args(["/C", script]).output()?,
            Shell::PowerShell => Command::new("powershell")
                .args(["-Command", script])
                .output()?,
        };

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(format!("Command failed: {}",
                String::from_utf8_lossy(&output.stderr)).into())
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let shell = Shell::default();

    #[cfg(windows)]
    let result = shell.execute("Get-Process | Select-Object -First 5")?;

    #[cfg(unix)]
    let result = shell.execute("ps aux | head -5")?;

    println!("{}", result);
    Ok(())
}
```

---

### 2.3 é€šç”¨å‘½ä»¤æ˜ å°„

```rust
use std::collections::HashMap;

struct CommandMapper {
    mappings: HashMap<String, PlatformCommands>,
}

struct PlatformCommands {
    unix: String,
    windows: String,
}

impl CommandMapper {
    fn new() -> Self {
        let mut mappings = HashMap::new();

        // åˆ—å‡ºæ–‡ä»¶
        mappings.insert("list_files".to_string(), PlatformCommands {
            unix: "ls -la".to_string(),
            windows: "dir".to_string(),
        });

        // å¤åˆ¶æ–‡ä»¶
        mappings.insert("copy_file".to_string(), PlatformCommands {
            unix: "cp".to_string(),
            windows: "copy".to_string(),
        });

        // åˆ é™¤æ–‡ä»¶
        mappings.insert("delete_file".to_string(), PlatformCommands {
            unix: "rm".to_string(),
            windows: "del".to_string(),
        });

        // æ˜¾ç¤ºå½“å‰ç›®å½•
        mappings.insert("current_dir".to_string(), PlatformCommands {
            unix: "pwd".to_string(),
            windows: "cd".to_string(),
        });

        // æŸ¥çœ‹è¿›ç¨‹
        mappings.insert("list_processes".to_string(), PlatformCommands {
            unix: "ps aux".to_string(),
            windows: "tasklist".to_string(),
        });

        // ç»ˆæ­¢è¿›ç¨‹
        mappings.insert("kill_process".to_string(), PlatformCommands {
            unix: "kill".to_string(),
            windows: "taskkill /F /PID".to_string(),
        });

        Self { mappings }
    }

    fn get_command(&self, key: &str) -> Option<String> {
        self.mappings.get(key).map(|cmds| {
            if cfg!(windows) {
                cmds.windows.clone()
            } else {
                cmds.unix.clone()
            }
        })
    }

    fn execute(&self, key: &str, args: &[&str]) -> Result<String, Box<dyn std::error::Error>> {
        let cmd = self.get_command(key)
            .ok_or("Command not found")?;

        let output = if cfg!(windows) {
            Command::new("cmd")
                .args(["/C", &cmd])
                .args(args)
                .output()?
        } else {
            Command::new("sh")
                .arg("-c")
                .arg(format!("{} {}", cmd, args.join(" ")))
                .output()?
        };

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mapper = CommandMapper::new();

    // è·¨å¹³å°åˆ—å‡ºæ–‡ä»¶
    let files = mapper.execute("list_files", &[])?;
    println!("{}", files);

    // è·¨å¹³å°æŸ¥çœ‹è¿›ç¨‹
    let processes = mapper.execute("list_processes", &[])?;
    println!("{}", processes);

    Ok(())
}
```

---

### 2.4 æ–‡ä»¶æ“ä½œæŠ½è±¡

```rust
use std::fs;
use std::path::Path;

pub struct CrossPlatformFile;

impl CrossPlatformFile {
    pub fn copy(src: &str, dst: &str) -> Result<(), Box<dyn std::error::Error>> {
        if cfg!(windows) {
            Command::new("cmd")
                .args(["/C", "copy", src, dst])
                .output()?;
        } else {
            Command::new("cp")
                .args([src, dst])
                .output()?;
        }
        Ok(())
    }

    pub fn move_file(src: &str, dst: &str) -> Result<(), Box<dyn std::error::Error>> {
        if cfg!(windows) {
            Command::new("cmd")
                .args(["/C", "move", src, dst])
                .output()?;
        } else {
            Command::new("mv")
                .args([src, dst])
                .output()?;
        }
        Ok(())
    }

    pub fn delete(path: &str) -> Result<(), Box<dyn std::error::Error>> {
        if cfg!(windows) {
            if Path::new(path).is_dir() {
                Command::new("cmd")
                    .args(["/C", "rmdir", "/S", "/Q", path])
                    .output()?;
            } else {
                Command::new("cmd")
                    .args(["/C", "del", "/F", "/Q", path])
                    .output()?;
            }
        } else {
            Command::new("rm")
                .args(["-rf", path])
                .output()?;
        }
        Ok(())
    }

    // æ›´å¥½çš„æ–¹å¼ï¼šä½¿ç”¨Rustæ ‡å‡†åº“
    pub fn copy_native(src: &str, dst: &str) -> std::io::Result<u64> {
        fs::copy(src, dst)
    }

    pub fn delete_native(path: &str) -> std::io::Result<()> {
        if Path::new(path).is_dir() {
            fs::remove_dir_all(path)
        } else {
            fs::remove_file(path)
        }
    }
}
```

---

### 2.5 ç½‘ç»œå‘½ä»¤æŠ½è±¡

```rust
pub struct NetworkCommands;

impl NetworkCommands {
    pub fn ping(host: &str) -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("ping")
                .args(["-n", "4", host])
                .output()?
        } else {
            Command::new("ping")
                .args(["-c", "4", host])
                .output()?
        };

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    pub fn get_ip() -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("ipconfig").output()?
        } else {
            Command::new("ip").args(["addr"]).output()?
        };

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    pub fn check_port(port: u16) -> Result<bool, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("netstat")
                .args(["-ano"])
                .output()?
        } else {
            Command::new("ss")
                .args(["-tuln"])
                .output()?
        };

        let stdout = String::from_utf8_lossy(&output.stdout);
        Ok(stdout.contains(&format!(":{}", port)))
    }
}
```

---

### 2.6 ç³»ç»Ÿä¿¡æ¯å‘½ä»¤

```rust
pub struct SystemInfo;

impl SystemInfo {
    pub fn get_os_info() -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("systeminfo").output()?
        } else {
            Command::new("uname").args(["-a"]).output()?
        };

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    pub fn get_cpu_info() -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("wmic")
                .args(["cpu", "get", "name"])
                .output()?
        } else if cfg!(target_os = "macos") {
            Command::new("sysctl")
                .args(["-n", "machdep.cpu.brand_string"])
                .output()?
        } else {
            Command::new("cat")
                .arg("/proc/cpuinfo")
                .output()?
        };

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    pub fn get_memory_info() -> Result<String, Box<dyn std::error::Error>> {
        let output = if cfg!(windows) {
            Command::new("wmic")
                .args(["OS", "get", "FreePhysicalMemory,TotalVisibleMemorySize"])
                .output()?
        } else if cfg!(target_os = "macos") {
            Command::new("vm_stat").output()?
        } else {
            Command::new("free").args(["-h"]).output()?
        };

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }
}
```

---

## 3. å¹³å°ç‰¹å®šåŠŸèƒ½

### 3.1 Unixç‰¹å®šåŠŸèƒ½

**è¿›ç¨‹ç»„ä¸ä¼šè¯**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

#[cfg(unix)]
fn unix_process_options() {
    use std::process::Command;

    Command::new("my_daemon")
        // è®¾ç½®è¿›ç¨‹ç»„
        .process_group(0)
        // è®¾ç½®ç”¨æˆ·ID
        .uid(1000)
        // è®¾ç½®ç»„ID
        .gid(1000)
        .spawn()
        .expect("Failed to spawn");
}

// åˆ›å»ºå®ˆæŠ¤è¿›ç¨‹
#[cfg(unix)]
fn daemonize() -> Result<(), Box<dyn std::error::Error>> {
    use nix::unistd::{fork, setsid, ForkResult};

    // ç¬¬ä¸€æ¬¡fork
    match unsafe { fork()? } {
        ForkResult::Parent { .. } => {
            // çˆ¶è¿›ç¨‹é€€å‡º
            std::process::exit(0);
        }
        ForkResult::Child => {}
    }

    // åˆ›å»ºæ–°ä¼šè¯
    setsid()?;

    // ç¬¬äºŒæ¬¡fork
    match unsafe { fork()? } {
        ForkResult::Parent { .. } => {
            std::process::exit(0);
        }
        ForkResult::Child => {}
    }

    // ç°åœ¨æ˜¯å®ˆæŠ¤è¿›ç¨‹
    Ok(())
}
```

---

**Unixä¿¡å·å¤„ç†**:

```rust
#[cfg(unix)]
use signal_hook::{consts::SIGTERM, iterator::Signals};

#[cfg(unix)]
fn setup_signal_handler() -> Result<(), Box<dyn std::error::Error>> {
    let mut signals = Signals::new(&[SIGTERM])?;

    std::thread::spawn(move || {
        for sig in signals.forever() {
            println!("Received signal {:?}", sig);
            match sig {
                SIGTERM => {
                    println!("Shutting down gracefully...");
                    std::process::exit(0);
                }
                _ => {}
            }
        }
    });

    Ok(())
}

#[cfg(unix)]
fn ignore_sigpipe() {
    unsafe {
        libc::signal(libc::SIGPIPE, libc::SIG_IGN);
    }
}
```

---

**æ–‡ä»¶æè¿°ç¬¦æ“ä½œ**:

```rust
#[cfg(unix)]
use std::os::unix::io::{AsRawFd, FromRawFd};

#[cfg(unix)]
fn dup_fd(cmd: &mut Command) {
    use std::process::Stdio;
    use std::fs::File;

    let file = File::create("/tmp/output.log").unwrap();
    let fd = file.as_raw_fd();

    // é‡å®šå‘ stdout åˆ°æ–‡ä»¶
    unsafe {
        cmd.stdout(Stdio::from_raw_fd(fd));
    }
}

#[cfg(unix)]
fn set_close_on_exec(fd: i32) {
    use libc::{fcntl, F_SETFD, FD_CLOEXEC};

    unsafe {
        fcntl(fd, F_SETFD, FD_CLOEXEC);
    }
}
```

---

**èµ„æºé™åˆ¶**:

```rust
#[cfg(unix)]
use libc::{setrlimit, getrlimit, rlimit, RLIMIT_NOFILE};

#[cfg(unix)]
fn set_file_limit(limit: u64) -> Result<(), Box<dyn std::error::Error>> {
    let rlim = rlimit {
        rlim_cur: limit,
        rlim_max: limit,
    };

    unsafe {
        if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {
            return Err("Failed to set file limit".into());
        }
    }

    Ok(())
}

#[cfg(unix)]
fn get_file_limit() -> Result<u64, Box<dyn std::error::Error>> {
    let mut rlim = rlimit {
        rlim_cur: 0,
        rlim_max: 0,
    };

    unsafe {
        if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {
            return Err("Failed to get file limit".into());
        }
    }

    Ok(rlim.rlim_cur)
}
```

---

### 3.2 Windowsç‰¹å®šåŠŸèƒ½

**åˆ›å»ºæ ‡å¿—**:

```rust
#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(windows)]
fn windows_process_flags() {
    use std::process::Command;

    const CREATE_NO_WINDOW: u32 = 0x08000000;
    const CREATE_NEW_CONSOLE: u32 = 0x00000010;
    const CREATE_NEW_PROCESS_GROUP: u32 = 0x00000200;
    const DETACHED_PROCESS: u32 = 0x00000008;

    Command::new("my_app.exe")
        // ä¸åˆ›å»ºæ§åˆ¶å°çª—å£
        .creation_flags(CREATE_NO_WINDOW)
        .spawn()
        .expect("Failed to spawn");

    Command::new("app_with_console.exe")
        // åˆ›å»ºæ–°æ§åˆ¶å°
        .creation_flags(CREATE_NEW_CONSOLE)
        .spawn()
        .expect("Failed to spawn");

    Command::new("background_task.exe")
        // åå°è¿›ç¨‹
        .creation_flags(DETACHED_PROCESS)
        .spawn()
        .expect("Failed to spawn");
}
```

---

**WindowsæœåŠ¡**:

```rust
#[cfg(windows)]
use windows_service::{
    define_windows_service,
    service::{
        ServiceControl, ServiceControlAccept, ServiceExitCode,
        ServiceState, ServiceStatus, ServiceType,
    },
    service_control_handler::{self, ServiceControlHandlerResult},
    service_dispatcher,
};

#[cfg(windows)]
define_windows_service!(ffi_service_main, my_service_main);

#[cfg(windows)]
fn my_service_main(arguments: Vec<std::ffi::OsString>) {
    if let Err(e) = run_service(arguments) {
        // è®°å½•é”™è¯¯
        eprintln!("Service error: {}", e);
    }
}

#[cfg(windows)]
fn run_service(_arguments: Vec<std::ffi::OsString>) -> Result<(), Box<dyn std::error::Error>> {
    let event_handler = move |control_event| -> ServiceControlHandlerResult {
        match control_event {
            ServiceControl::Stop => {
                // å¤„ç†åœæ­¢
                ServiceControlHandlerResult::NoError
            }
            ServiceControl::Interrogate => ServiceControlHandlerResult::NoError,
            _ => ServiceControlHandlerResult::NotImplemented,
        }
    };

    let status_handle = service_control_handler::register("my_service", event_handler)?;

    // æŠ¥å‘Šè¿è¡ŒçŠ¶æ€
    status_handle.set_service_status(ServiceStatus {
        service_type: ServiceType::OWN_PROCESS,
        current_state: ServiceState::Running,
        controls_accepted: ServiceControlAccept::STOP,
        exit_code: ServiceExitCode::Win32(0),
        checkpoint: 0,
        wait_hint: std::time::Duration::default(),
        process_id: None,
    })?;

    // æœåŠ¡é€»è¾‘...

    Ok(())
}
```

---

**ä½œä¸šå¯¹è±¡é«˜çº§ç”¨æ³•**:

```rust
#[cfg(windows)]
use winapi::um::jobapi2::*;
#[cfg(windows)]
use winapi::um::winnt::*;

#[cfg(windows)]
struct AdvancedJobObject {
    handle: *mut winapi::ctypes::c_void,
}

#[cfg(windows)]
impl AdvancedJobObject {
    fn create_with_limits() -> Result<Self, Box<dyn std::error::Error>> {
        unsafe {
            let handle = CreateJobObjectW(std::ptr::null_mut(), std::ptr::null());
            if handle.is_null() {
                return Err("Failed to create job object".into());
            }

            // è®¾ç½®å†…å­˜é™åˆ¶
            let mut limits = JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
                BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION {
                    PerProcessUserTimeLimit: 0,
                    PerJobUserTimeLimit: 0,
                    LimitFlags: JOB_OBJECT_LIMIT_PROCESS_MEMORY,
                    MinimumWorkingSetSize: 0,
                    MaximumWorkingSetSize: 0,
                    ActiveProcessLimit: 0,
                    Affinity: 0,
                    PriorityClass: 0,
                    SchedulingClass: 0,
                },
                ProcessMemoryLimit: 100 * 1024 * 1024,  // 100 MB
                JobMemoryLimit: 0,
                PeakProcessMemoryUsed: 0,
                PeakJobMemoryUsed: 0,
                ..std::mem::zeroed()
            };

            SetInformationJobObject(
                handle,
                JobObjectExtendedLimitInformation,
                &mut limits as *mut _ as *mut _,
                std::mem::size_of::<JOBOBJECT_EXTENDED_LIMIT_INFORMATION>() as u32,
            );

            Ok(Self { handle })
        }
    }

    fn set_cpu_limit(&self, percent: u32) -> Result<(), Box<dyn std::error::Error>> {
        unsafe {
            let mut cpu_limit = JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
                ControlFlags: JOB_OBJECT_CPU_RATE_CONTROL_ENABLE | JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP,
                Value: percent * 100,  // ä»¥1/100%ä¸ºå•ä½
            };

            SetInformationJobObject(
                self.handle,
                JobObjectCpuRateControlInformation,
                &mut cpu_limit as *mut _ as *mut _,
                std::mem::size_of::<JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>() as u32,
            );
        }
        Ok(())
    }
}
```

---

**æ³¨å†Œè¡¨æ“ä½œ**:

```rust
#[cfg(windows)]
use winreg::RegKey;
#[cfg(windows)]
use winreg::enums::*;

#[cfg(windows)]
fn read_registry() -> Result<String, Box<dyn std::error::Error>> {
    let hklm = RegKey::predef(HKEY_LOCAL_MACHINE);
    let key = hklm.open_subkey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")?;
    let version: String = key.get_value("ProductName")?;
    Ok(version)
}

#[cfg(windows)]
fn write_registry() -> Result<(), Box<dyn std::error::Error>> {
    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let (key, _disp) = hkcu.create_subkey("Software\\MyApp")?;
    key.set_value("Version", &"1.0.0")?;
    Ok(())
}
```

---

### 3.3 macOSç‰¹å®šåŠŸèƒ½

**Launch Agent/Daemon**:

```rust
#[cfg(target_os = "macos")]
fn create_launchd_plist() -> String {
    r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.example.myapp</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/myapp</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>/tmp/myapp.out</string>
    <key>StandardErrorPath</key>
    <string>/tmp/myapp.err</string>
</dict>
</plist>"#.to_string()
}

#[cfg(target_os = "macos")]
fn install_launchd_service() -> Result<(), Box<dyn std::error::Error>> {
    use std::fs;
    use std::path::PathBuf;

    let home = std::env::var("HOME")?;
    let mut plist_path = PathBuf::from(home);
    plist_path.push("Library/LaunchAgents/com.example.myapp.plist");

    let plist = create_launchd_plist();
    fs::write(plist_path, plist)?;

    // åŠ è½½æœåŠ¡
    Command::new("launchctl")
        .args(["load", "-w", "~/Library/LaunchAgents/com.example.myapp.plist"])
        .output()?;

    Ok(())
}
```

---

### 3.4 ç»Ÿä¸€æŠ½è±¡å±‚

**è·¨å¹³å°è¿›ç¨‹ç®¡ç†å™¨**:

```rust
pub trait ProcessManager {
    fn spawn(&self, cmd: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>>;
    fn kill(&self, pid: u32) -> Result<(), Box<dyn std::error::Error>>;
    fn list(&self) -> Result<Vec<ProcessInfo>, Box<dyn std::error::Error>>;
}

pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub cpu_usage: f32,
    pub memory: u64,
}

#[cfg(unix)]
pub struct UnixProcessManager;

#[cfg(unix)]
impl ProcessManager for UnixProcessManager {
    fn spawn(&self, cmd: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let child = Command::new(cmd).args(args).spawn()?;
        Ok(child.id())
    }

    fn kill(&self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;

        kill(Pid::from_raw(pid as i32), Signal::SIGTERM)?;
        Ok(())
    }

    fn list(&self) -> Result<Vec<ProcessInfo>, Box<dyn std::error::Error>> {
        // è§£æ ps è¾“å‡º
        let output = Command::new("ps")
            .args(["aux"])
            .output()?;

        // ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦è§£æè¾“å‡º
        Ok(vec![])
    }
}

#[cfg(windows)]
pub struct WindowsProcessManager;

#[cfg(windows)]
impl ProcessManager for WindowsProcessManager {
    fn spawn(&self, cmd: &str, args: &[&str]) -> Result<u32, Box<dyn std::error::Error>> {
        let child = Command::new(cmd).args(args).spawn()?;
        Ok(child.id())
    }

    fn kill(&self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        Command::new("taskkill")
            .args(["/F", "/PID", &pid.to_string()])
            .output()?;
        Ok(())
    }

    fn list(&self) -> Result<Vec<ProcessInfo>, Box<dyn std::error::Error>> {
        // è§£æ tasklist è¾“å‡º
        let output = Command::new("tasklist").output()?;

        // ç®€åŒ–ç¤ºä¾‹
        Ok(vec![])
    }
}

pub fn get_process_manager() -> Box<dyn ProcessManager> {
    #[cfg(unix)]
    return Box::new(UnixProcessManager);

    #[cfg(windows)]
    return Box::new(WindowsProcessManager);
}
```

---

## 4. æœ€ä½³å®è·µ

### 4.1 è®¾è®¡åŸåˆ™

**âœ… DO**:

1. **ä¼˜å…ˆä½¿ç”¨Rustæ ‡å‡†åº“**:
   - `std::path::PathBuf` è‡ªåŠ¨å¤„ç†è·¯å¾„
   - `std::env` å¤„ç†ç¯å¢ƒå˜é‡
   - `std::fs` å¤„ç†æ–‡ä»¶æ“ä½œ

2. **ä½¿ç”¨æ¡ä»¶ç¼–è¯‘**:

   ```rust
   #[cfg(windows)]
   fn platform_specific() {
       // Windowså®ç°
   }

   #[cfg(unix)]
   fn platform_specific() {
       // Unixå®ç°
   }
   ```

3. **åˆ›å»ºæŠ½è±¡å±‚**:

   ```rust
   pub trait CrossPlatform {
       fn execute(&self) -> Result<(), Error>;
   }
   ```

4. **å…¨å¹³å°æµ‹è¯•**:
   - ä½¿ç”¨CI/CDåœ¨å¤šå¹³å°æµ‹è¯•
   - GitHub Actions, GitLab CI

---

**âŒ DON'T**:

1. **ç¡¬ç¼–ç è·¯å¾„**:

   ```rust
   // âŒ é”™è¯¯
   let path = "/usr/bin/app";

   // âœ… æ­£ç¡®
   let path = std::env::var("PATH").unwrap_or_default();
   ```

2. **å‡è®¾Shellå­˜åœ¨**:

   ```rust
   // âŒ é”™è¯¯
   Command::new("sh").arg("-c").arg("ls");

   // âœ… æ­£ç¡®
   if cfg!(windows) {
       Command::new("cmd").args(["/C", "dir"]);
   } else {
       Command::new("sh").args(["-c", "ls"]);
   }
   ```

---

### 4.2 æŠ½è±¡å‘½ä»¤æ‰§è¡Œå™¨

```rust
use std::process::Command;

pub struct CrossPlatformCommand {
    program: String,
    args: Vec<String>,
    env: Vec<(String, String)>,
    cwd: Option<String>,
}

impl CrossPlatformCommand {
    pub fn new(program: &str) -> Self {
        Self {
            program: program.to_string(),
            args: Vec::new(),
            env: Vec::new(),
            cwd: None,
        }
    }

    pub fn arg(mut self, arg: &str) -> Self {
        self.args.push(arg.to_string());
        self
    }

    pub fn args(mut self, args: &[&str]) -> Self {
        for arg in args {
            self.args.push(arg.to_string());
        }
        self
    }

    pub fn env(mut self, key: &str, value: &str) -> Self {
        self.env.push((key.to_string(), value.to_string()));
        self
    }

    pub fn current_dir(mut self, dir: &str) -> Self {
        self.cwd = Some(dir.to_string());
        self
    }

    pub fn execute(&self) -> Result<String, Box<dyn std::error::Error>> {
        let mut cmd = Command::new(&self.program);
        cmd.args(&self.args);

        for (key, value) in &self.env {
            cmd.env(key, value);
        }

        if let Some(cwd) = &self.cwd {
            cmd.current_dir(cwd);
        }

        let output = cmd.output()?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(format!("Command failed: {}",
                String::from_utf8_lossy(&output.stderr)).into())
        }
    }

    pub fn spawn(&self) -> Result<std::process::Child, Box<dyn std::error::Error>> {
        let mut cmd = Command::new(&self.program);
        cmd.args(&self.args);

        for (key, value) in &self.env {
            cmd.env(key, value);
        }

        if let Some(cwd) = &self.cwd {
            cmd.current_dir(cwd);
        }

        Ok(cmd.spawn()?)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let result = CrossPlatformCommand::new("echo")
        .arg("Hello")
        .arg("World")
        .env("MY_VAR", "value")
        .execute()?;

    println!("{}", result);
    Ok(())
}
```

---

### 4.3 è·¨å¹³å°é…ç½®ç®¡ç†

```rust
use std::path::PathBuf;
use std::fs;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct AppConfig {
    pub data_dir: PathBuf,
    pub log_dir: PathBuf,
    pub temp_dir: PathBuf,
}

impl AppConfig {
    pub fn default() -> Self {
        Self {
            data_dir: Self::get_data_dir(),
            log_dir: Self::get_log_dir(),
            temp_dir: std::env::temp_dir(),
        }
    }

    fn get_data_dir() -> PathBuf {
        if cfg!(windows) {
            let appdata = std::env::var("APPDATA")
                .unwrap_or_else(|_| "C:\\ProgramData".to_string());
            PathBuf::from(appdata).join("MyApp")
        } else if cfg!(target_os = "macos") {
            let home = std::env::var("HOME")
                .unwrap_or_else(|_| "/Users/Shared".to_string());
            PathBuf::from(home).join("Library/Application Support/MyApp")
        } else {
            let home = std::env::var("HOME")
                .unwrap_or_else(|_| "/tmp".to_string());
            PathBuf::from(home).join(".local/share/MyApp")
        }
    }

    fn get_log_dir() -> PathBuf {
        if cfg!(windows) {
            let appdata = std::env::var("LOCALAPPDATA")
                .unwrap_or_else(|_| "C:\\ProgramData".to_string());
            PathBuf::from(appdata).join("MyApp\\logs")
        } else if cfg!(target_os = "macos") {
            let home = std::env::var("HOME")
                .unwrap_or_else(|_| "/tmp".to_string());
            PathBuf::from(home).join("Library/Logs/MyApp")
        } else {
            PathBuf::from("/var/log/myapp")
        }
    }

    pub fn load() -> Result<Self, Box<dyn std::error::Error>> {
        let config_path = Self::config_file_path();

        if config_path.exists() {
            let contents = fs::read_to_string(config_path)?;
            Ok(toml::from_str(&contents)?)
        } else {
            Ok(Self::default())
        }
    }

    pub fn save(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config_path = Self::config_file_path();

        // ç¡®ä¿ç›®å½•å­˜åœ¨
        if let Some(parent) = config_path.parent() {
            fs::create_dir_all(parent)?;
        }

        let contents = toml::to_string_pretty(self)?;
        fs::write(config_path, contents)?;

        Ok(())
    }

    fn config_file_path() -> PathBuf {
        if cfg!(windows) {
            let appdata = std::env::var("APPDATA")
                .unwrap_or_else(|_| "C:\\ProgramData".to_string());
            PathBuf::from(appdata).join("MyApp\\config.toml")
        } else {
            let home = std::env::var("HOME")
                .unwrap_or_else(|_| "/tmp".to_string());
            PathBuf::from(home).join(".config/myapp/config.toml")
        }
    }
}
```

---

### 4.4 æµ‹è¯•ç­–ç•¥

**å•å…ƒæµ‹è¯•è·¨å¹³å°ä»£ç **:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shell_command() {
        let result = run_shell_command("echo test");
        assert!(result.is_ok());

        #[cfg(windows)]
        assert!(result.unwrap().contains("test"));

        #[cfg(unix)]
        assert_eq!(result.unwrap().trim(), "test");
    }

    #[test]
    #[cfg(unix)]
    fn test_unix_specific() {
        // Unixç‰¹å®šæµ‹è¯•
    }

    #[test]
    #[cfg(windows)]
    fn test_windows_specific() {
        // Windowsç‰¹å®šæµ‹è¯•
    }
}
```

**CI/CDé…ç½®ç¤ºä¾‹ (GitHub Actions)**:

```yaml
name: Cross-Platform Tests

on: [push, pull_request]

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, beta]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v2

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ matrix.rust }}
          override: true

      - name: Run Tests
        run: cargo test --all-features

      - name: Run Examples
        run: cargo run --example cross_platform
```

---

### 4.5 å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

**é™·é˜±1: è¡Œç»“æŸç¬¦å·®å¼‚**:

```rust
// âŒ é—®é¢˜ï¼šWindowså’ŒUnixè¡Œç»“æŸç¬¦ä¸åŒ
let lines: Vec<&str> = output.split('\n').collect();

// âœ… è§£å†³ï¼šä½¿ç”¨lines()æ–¹æ³•
let lines: Vec<&str> = output.lines().collect();
```

---

**é™·é˜±2: è·¯å¾„åˆ†éš”ç¬¦**:

```rust
// âŒ é—®é¢˜ï¼šç¡¬ç¼–ç è·¯å¾„åˆ†éš”ç¬¦
let path = format!("{}{}config.toml", home, "/");

// âœ… è§£å†³ï¼šä½¿ç”¨PathBuf
let mut path = PathBuf::from(home);
path.push("config.toml");
```

---

**é™·é˜±3: æƒé™æ¨¡å‹å·®å¼‚**:

```rust
#[cfg(unix)]
fn set_permissions(path: &str) -> Result<(), Box<dyn std::error::Error>> {
    use std::os::unix::fs::PermissionsExt;
    use std::fs;

    let metadata = fs::metadata(path)?;
    let mut permissions = metadata.permissions();
    permissions.set_mode(0o755);
    fs::set_permissions(path, permissions)?;

    Ok(())
}

#[cfg(windows)]
fn set_permissions(path: &str) -> Result<(), Box<dyn std::error::Error>> {
    // Windowsä½¿ç”¨ACLï¼Œéœ€è¦winapiæˆ–ä¸“é—¨çš„crate
    println!("âš ï¸  Permission management on Windows requires ACL");
    Ok(())
}
```

---

**é™·é˜±4: è¿›ç¨‹é€€å‡ºç **:

```rust
fn check_exit_code(status: std::process::ExitStatus) {
    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        if let Some(signal) = status.signal() {
            println!("Process killed by signal {}", signal);
        }
    }

    if let Some(code) = status.code() {
        println!("Exit code: {}", code);
    }
}
```

---

### 4.6 æ€§èƒ½ä¼˜åŒ–å»ºè®®

**Windowsä¼˜åŒ–**:

```rust
#[cfg(windows)]
fn optimize_windows_process_creation() {
    // 1. å‡å°‘è¿›ç¨‹åˆ›å»ºæ¬¡æ•°
    // 2. ä½¿ç”¨çº¿ç¨‹æ± ä»£æ›¿è¿›ç¨‹
    // 3. æ‰¹é‡å¤„ç†å‘½ä»¤
    // 4. ç¼“å­˜è¿›ç¨‹å¥æŸ„
}
```

**Unixä¼˜åŒ–**:

```rust
#[cfg(unix)]
fn optimize_unix_process_creation() {
    // 1. ä½¿ç”¨vforkä»£æ›¿forkï¼ˆè°¨æ…ï¼‰
    // 2. åˆ©ç”¨è¿›ç¨‹æ± 
    // 3. ä½¿ç”¨execæ—å‡½æ•°çš„æœ€å¿«å˜ä½“
}
```

---

### 4.7 è°ƒè¯•æŠ€å·§

**è·¨å¹³å°è°ƒè¯•**:

```rust
fn debug_platform_info() {
    println!("Platform: {}", std::env::consts::OS);
    println!("Architecture: {}", std::env::consts::ARCH);
    println!("Family: {}", std::env::consts::FAMILY);

    #[cfg(windows)]
    println!("Windows version: {:?}", std::env::var("OS"));

    #[cfg(unix)]
    {
        let output = Command::new("uname").arg("-a").output().unwrap();
        println!("Unix info: {}", String::from_utf8_lossy(&output.stdout));
    }
}

fn debug_command(cmd: &Command) {
    println!("ğŸ” Command: {:?}", cmd);
    println!("   Program: {:?}", cmd.get_program());
    println!("   Args: {:?}", cmd.get_args().collect::<Vec<_>>());
    println!("   Env: {:?}", cmd.get_envs().collect::<Vec<_>>());
}
```

---

## 5. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: è·¨å¹³å°è¿›ç¨‹ç›‘æ§

```rust
pub struct ProcessMonitor {
    #[cfg(unix)]
    unix_impl: UnixProcessMonitor,

    #[cfg(windows)]
    windows_impl: WindowsProcessMonitor,
}

impl ProcessMonitor {
    pub fn new() -> Self {
        Self {
            #[cfg(unix)]
            unix_impl: UnixProcessMonitor::new(),

            #[cfg(windows)]
            windows_impl: WindowsProcessMonitor::new(),
        }
    }

    pub fn get_process_list(&self) -> Result<Vec<ProcessInfo>, Box<dyn std::error::Error>> {
        #[cfg(unix)]
        return self.unix_impl.get_process_list();

        #[cfg(windows)]
        return self.windows_impl.get_process_list();
    }
}
```

---

### æ¡ˆä¾‹2: è·¨å¹³å°è‡ªåŠ¨æ›´æ–°

```rust
pub struct Updater;

impl Updater {
    pub fn download_and_install(url: &str) -> Result<(), Box<dyn std::error::Error>> {
        // ä¸‹è½½
        let temp_file = Self::download(url)?;

        // å®‰è£…
        #[cfg(windows)]
        {
            Command::new("msiexec")
                .args(["/i", &temp_file, "/quiet"])
                .output()?;
        }

        #[cfg(unix)]
        {
            Command::new("dpkg")
                .args(["-i", &temp_file])
                .output()?;
        }

        Ok(())
    }

    fn download(url: &str) -> Result<String, Box<dyn std::error::Error>> {
        // ä¸‹è½½é€»è¾‘
        Ok("/tmp/installer".to_string())
    }
}
```

---

## 6. æ€»ç»“

**å…³é”®è¦ç‚¹**:

1. âœ… ä¼˜å…ˆä½¿ç”¨Rustæ ‡å‡†åº“çš„è·¨å¹³å°API
2. âœ… ä½¿ç”¨æ¡ä»¶ç¼–è¯‘ (#[cfg]) å¤„ç†å¹³å°ç‰¹å®šä»£ç 
3. âœ… åˆ›å»ºæŠ½è±¡å±‚ç»Ÿä¸€æ¥å£
4. âœ… åœ¨æ‰€æœ‰ç›®æ ‡å¹³å°ä¸Šæµ‹è¯•
5. âœ… æ³¨æ„è·¯å¾„ã€æƒé™ã€ä¿¡å·ç­‰å·®å¼‚

**æ¨èå·¥å…·**:

- `sysinfo`: è·¨å¹³å°ç³»ç»Ÿä¿¡æ¯
- `nix`: Unixç³»ç»Ÿè°ƒç”¨
- `winapi`: Windows API
- `crossbeam`: è·¨å¹³å°å¹¶å‘åŸè¯­

---

**ä¸‹ä¸€æ­¥**:

- [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](./01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)
- [IPCé€šä¿¡å®è·µ](./02_IPCé€šä¿¡å®è·µ.md)
- [è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­](./05_è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­.md)

---

**å‚è€ƒ**: [è·¨å¹³å°è¿›ç¨‹ç®¡ç†](../../docs/06_cross_platform_process_management.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
