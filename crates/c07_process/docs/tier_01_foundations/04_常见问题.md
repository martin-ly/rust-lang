# Tier 1: C07 è¿›ç¨‹ç®¡ç† - å¸¸è§é—®é¢˜

> **æ–‡æ¡£ç±»å‹**: FAQ
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **æœ€åæ›´æ–°**: 2025-12-11

---

## ç›®å½•

- [Tier 1: C07 è¿›ç¨‹ç®¡ç† - å¸¸è§é—®é¢˜](#tier-1-c07-è¿›ç¨‹ç®¡ç†---å¸¸è§é—®é¢˜)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ é—®é¢˜ç´¢å¼•](#-é—®é¢˜ç´¢å¼•)
  - [åŸºç¡€é—®é¢˜](#åŸºç¡€é—®é¢˜)
    - [Q1: å¦‚ä½•åˆ›å»ºå’Œç®¡ç†å­è¿›ç¨‹ï¼Ÿ](#q1-å¦‚ä½•åˆ›å»ºå’Œç®¡ç†å­è¿›ç¨‹)
    - [Q2: å¦‚ä½•è·å–å­è¿›ç¨‹çš„è¾“å‡ºï¼Ÿ](#q2-å¦‚ä½•è·å–å­è¿›ç¨‹çš„è¾“å‡º)
    - [Q3: å¦‚ä½•å‘å­è¿›ç¨‹ä¼ é€’è¾“å…¥ï¼Ÿ](#q3-å¦‚ä½•å‘å­è¿›ç¨‹ä¼ é€’è¾“å…¥)
  - [IPC é€šä¿¡é—®é¢˜](#ipc-é€šä¿¡é—®é¢˜)
    - [Q4: è¿›ç¨‹é—´å¦‚ä½•é€šä¿¡ï¼Ÿæœ€å¥½çš„æ–¹å¼æ˜¯ä»€ä¹ˆï¼Ÿ](#q4-è¿›ç¨‹é—´å¦‚ä½•é€šä¿¡æœ€å¥½çš„æ–¹å¼æ˜¯ä»€ä¹ˆ)
    - [Q5: ç®¡é“å’Œå‘½åç®¡é“æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q5-ç®¡é“å’Œå‘½åç®¡é“æœ‰ä»€ä¹ˆåŒºåˆ«)
    - [Q6: å¦‚ä½•å®ç°åŒå‘é€šä¿¡ï¼Ÿ](#q6-å¦‚ä½•å®ç°åŒå‘é€šä¿¡)
  - [è·¨å¹³å°é—®é¢˜](#è·¨å¹³å°é—®é¢˜)
    - [Q7: å¦‚ä½•å®ç°è·¨å¹³å°çš„è¿›ç¨‹ç®¡ç†ï¼Ÿ](#q7-å¦‚ä½•å®ç°è·¨å¹³å°çš„è¿›ç¨‹ç®¡ç†)
    - [Q8: Windowså’ŒUnixçš„è¿›ç¨‹æ¨¡å‹æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q8-windowså’Œunixçš„è¿›ç¨‹æ¨¡å‹æœ‰ä»€ä¹ˆåŒºåˆ«)
  - [ç”Ÿå‘½å‘¨æœŸé—®é¢˜](#ç”Ÿå‘½å‘¨æœŸé—®é¢˜)
    - [Q9: å¦‚ä½•é¿å…å’Œå¤„ç†åƒµå°¸è¿›ç¨‹ï¼Ÿ](#q9-å¦‚ä½•é¿å…å’Œå¤„ç†åƒµå°¸è¿›ç¨‹)
    - [Q10: å¦‚ä½•ä¼˜é›…åœ°ç»ˆæ­¢å­è¿›ç¨‹ï¼Ÿ](#q10-å¦‚ä½•ä¼˜é›…åœ°ç»ˆæ­¢å­è¿›ç¨‹)
    - [Q11: å¦‚ä½•å¤„ç†å­è¿›ç¨‹è¶…æ—¶ï¼Ÿ](#q11-å¦‚ä½•å¤„ç†å­è¿›ç¨‹è¶…æ—¶)
  - [å¼‚æ­¥ä¸æ€§èƒ½é—®é¢˜](#å¼‚æ­¥ä¸æ€§èƒ½é—®é¢˜)
    - [Q12: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨å¼‚æ­¥è¿›ç¨‹ç®¡ç†ï¼Ÿ](#q12-ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨å¼‚æ­¥è¿›ç¨‹ç®¡ç†)
    - [Q13: å¦‚ä½•æé«˜è¿›ç¨‹é€šä¿¡æ€§èƒ½ï¼Ÿ](#q13-å¦‚ä½•æé«˜è¿›ç¨‹é€šä¿¡æ€§èƒ½)
    - [Q14: å¦‚ä½•ç›‘æ§è¿›ç¨‹èµ„æºä½¿ç”¨ï¼Ÿ](#q14-å¦‚ä½•ç›‘æ§è¿›ç¨‹èµ„æºä½¿ç”¨)
  - [é”™è¯¯å¤„ç†é—®é¢˜](#é”™è¯¯å¤„ç†é—®é¢˜)
    - [Q15: å¦‚ä½•å¤„ç†è¿›ç¨‹åˆ›å»ºå¤±è´¥ï¼Ÿ](#q15-å¦‚ä½•å¤„ç†è¿›ç¨‹åˆ›å»ºå¤±è´¥)
    - [Q16: å¦‚ä½•åŒºåˆ†è¿›ç¨‹é”™è¯¯ç±»å‹ï¼Ÿ](#q16-å¦‚ä½•åŒºåˆ†è¿›ç¨‹é”™è¯¯ç±»å‹)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## ğŸ“‹ é—®é¢˜ç´¢å¼•

**æŒ‰ç±»åˆ«**: [åŸºç¡€](#åŸºç¡€é—®é¢˜) | [IPC](#ipc-é€šä¿¡é—®é¢˜) | [è·¨å¹³å°](#è·¨å¹³å°é—®é¢˜) | [ç”Ÿå‘½å‘¨æœŸ](#ç”Ÿå‘½å‘¨æœŸé—®é¢˜) | [å¼‚æ­¥æ€§èƒ½](#å¼‚æ­¥ä¸æ€§èƒ½é—®é¢˜) | [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†é—®é¢˜)

---

## åŸºç¡€é—®é¢˜

### Q1: å¦‚ä½•åˆ›å»ºå’Œç®¡ç†å­è¿›ç¨‹ï¼Ÿ

**A**: Rust çš„ `std::process::Command` æä¾›äº†åˆ›å»ºå’Œç®¡ç†å­è¿›ç¨‹çš„æ ‡å‡†æ–¹å¼ã€‚

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::process::Command;

// æ–¹æ³•1: ç­‰å¾…å®Œæˆå¹¶è·å–è¾“å‡º
let output = Command::new("ls")
    .arg("-la")
    .output()
    .expect("failed to execute process");

println!("status: {}", output.status);
println!("stdout: {}", String::from_utf8_lossy(&output.stdout));
println!("stderr: {}", String::from_utf8_lossy(&output.stderr));

// æ–¹æ³•2: åªè·å–é€€å‡ºçŠ¶æ€
let status = Command::new("ls")
    .status()
    .expect("failed to execute");

// æ–¹æ³•3: å¯åŠ¨åç«‹å³è¿”å›
let mut child = Command::new("long_running_task")
    .spawn()
    .expect("failed to spawn");

// ç¨åç­‰å¾…
let status = child.wait()?;
```

**æ ¸å¿ƒæ–¹æ³•å¯¹æ¯”**:

| æ–¹æ³•       | é˜»å¡ | è¿”å›å€¼       | ç”¨é€”           |
| :--- | :--- | :--- | :--- || `output()` | æ˜¯   | `Output`     | éœ€è¦æ•è·è¾“å‡º   |
| `status()` | æ˜¯   | `ExitStatus` | åªå…³å¿ƒé€€å‡ºçŠ¶æ€ |
| `spawn()`  | å¦   | `Child`      | éœ€è¦åç»­æ“ä½œ   |

**å‚è€ƒ**: [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](../tier_02_guides/01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)

---

### Q2: å¦‚ä½•è·å–å­è¿›ç¨‹çš„è¾“å‡ºï¼Ÿ

**A**: é…ç½® `stdout` å’Œ `stderr`ï¼Œç„¶åè¯»å–è¾“å‡ºã€‚

**æ–¹æ³•1: ä½¿ç”¨ `output()`**:

```rust
let output = Command::new("echo")
    .arg("Hello")
    .output()?;

let stdout = String::from_utf8_lossy(&output.stdout);
println!("Output: {}", stdout);
```

**æ–¹æ³•2: ä½¿ç”¨ `Stdio::piped()`**:

```rust
use std::process::{Command, Stdio};
use std::io::Read;

let mut child = Command::new("cat")
    .arg("file.txt")
    .stdout(Stdio::piped())
    .spawn()?;

// è¯»å–stdout
if let Some(mut stdout) = child.stdout.take() {
    let mut output = String::new();
    stdout.read_to_string(&mut output)?;
    println!("{}", output);
}

child.wait()?;
```

**æ–¹æ³•3: å®æ—¶è¯»å–**:

```rust
use std::io::BufRead;

let mut child = Command::new("tail")
    .arg("-f")
    .arg("log.txt")
    .stdout(Stdio::piped())
    .spawn()?;

if let Some(stdout) = child.stdout.take() {
    let reader = BufReader::new(stdout);
    for line in reader.lines() {
        println!("LOG: {}", line?);
    }
}
```

---

### Q3: å¦‚ä½•å‘å­è¿›ç¨‹ä¼ é€’è¾“å…¥ï¼Ÿ

**A**: é…ç½® `stdin` ä¸º `Stdio::piped()`ï¼Œç„¶åå†™å…¥æ•°æ®ã€‚

```rust
use std::process::{Command, Stdio};
use std::io::Write;

let mut child = Command::new("cat")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// å†™å…¥æ•°æ®åˆ°å­è¿›ç¨‹çš„stdin
if let Some(mut stdin) = child.stdin.take() {
    stdin.write_all(b"Hello from parent!\n")?;
    // drop(stdin); // å…³é—­stdinï¼Œè®©catçŸ¥é“è¾“å…¥ç»“æŸ
}

// è¯»å–è¾“å‡º
let output = child.wait_with_output()?;
println!("{}", String::from_utf8_lossy(&output.stdout));
```

---

## IPC é€šä¿¡é—®é¢˜

### Q4: è¿›ç¨‹é—´å¦‚ä½•é€šä¿¡ï¼Ÿæœ€å¥½çš„æ–¹å¼æ˜¯ä»€ä¹ˆï¼Ÿ

**A**: Rust æ”¯æŒå¤šç§ IPC æœºåˆ¶ï¼Œé€‰æ‹©å–å†³äºå…·ä½“éœ€æ±‚ã€‚

**IPC æ–¹å¼å¯¹æ¯”**:

| IPC ç±»å‹        | æ€§èƒ½ | å¤æ‚åº¦ | è·¨ç½‘ç»œ | é€‚ç”¨åœºæ™¯         |
| :--- | :--- | :--- | :--- | :--- || **ç®¡é“**        | ä¸­   | ä½     | å¦     | çˆ¶å­è¿›ç¨‹ç®€å•é€šä¿¡ |
| **å‘½åç®¡é“**    | ä¸­   | ä½     | å¦     | æœ¬åœ°æ— äº²ç¼˜è¿›ç¨‹   |
| **Unix Socket** | é«˜   | ä¸­     | å¦     | æœ¬åœ°å¤æ‚é€šä¿¡     |
| **TCP Socket**  | ä¸­   | ä¸­     | æ˜¯     | è·¨ç½‘ç»œé€šä¿¡       |
| **å…±äº«å†…å­˜**    | æœ€é«˜ | é«˜     | å¦     | å¤§æ•°æ®é‡ã€é«˜æ€§èƒ½ |
| **æ¶ˆæ¯é˜Ÿåˆ—**    | ä¸­   | ä¸­     | å¦     | å¼‚æ­¥æ¶ˆæ¯ä¼ é€’     |

**é€‰æ‹©å»ºè®®**:

- **ç®€å•åœºæ™¯**: ç®¡é“
- **æœ¬åœ°é«˜æ€§èƒ½**: Unix Socket æˆ–å…±äº«å†…å­˜
- **è·¨ç½‘ç»œ**: TCP Socket
- **å¼‚æ­¥æ¶ˆæ¯**: æ¶ˆæ¯é˜Ÿåˆ—

**ç¤ºä¾‹ - ç®¡é“**:

```rust
let mut child = Command::new("cat")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// å†™å…¥
if let Some(mut stdin) = child.stdin.take() {
    stdin.write_all(b"data")?;
}

// è¯»å–
let output = child.wait_with_output()?;
```

**å‚è€ƒ**: [IPCé€šä¿¡å®è·µ](../tier_02_guides/02_IPCé€šä¿¡å®è·µ.md)

---

### Q5: ç®¡é“å’Œå‘½åç®¡é“æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**: ä¸»è¦åŒºåˆ«åœ¨äºä½¿ç”¨èŒƒå›´å’ŒæŒä¹…æ€§ã€‚

**åŒ¿åç®¡é“ (Pipe)**:

- åªèƒ½ç”¨äºæœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹ï¼ˆçˆ¶å­ã€å…„å¼Ÿï¼‰
- ç”Ÿå‘½å‘¨æœŸéšè¿›ç¨‹ç»“æŸ
- é€šè¿‡æ–‡ä»¶æè¿°ç¬¦ä¼ é€’

**å‘½åç®¡é“ (Named Pipe / FIFO)**:

- åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æœ‰è·¯å¾„å
- ä»»ä½•è¿›ç¨‹éƒ½å¯ä»¥è®¿é—®ï¼ˆæœ‰æƒé™ï¼‰
- æŒä¹…åŒ–ï¼Œå¯é‡å¤ä½¿ç”¨
- Unix: ä½¿ç”¨ `mkfifo()`ï¼›Windows: ä½¿ç”¨ `CreateNamedPipe()`

**Unix å‘½åç®¡é“ç¤ºä¾‹**:

```rust
#[cfg(unix)]
use nix::unistd::mkfifo;
use nix::sys::stat::Mode;
use std::fs::File;
use std::io::{Read, Write};

// åˆ›å»ºå‘½åç®¡é“
mkfifo(Path::new("/tmp/my_pipe"), Mode::S_IRWXU)?;

// è¿›ç¨‹Aå†™å…¥
let mut file = File::create("/tmp/my_pipe")?;
file.write_all(b"Hello")?;

// è¿›ç¨‹Bè¯»å–
let mut file = File::open("/tmp/my_pipe")?;
let mut buf = String::new();
file.read_to_string(&mut buf)?;
```

---

### Q6: å¦‚ä½•å®ç°åŒå‘é€šä¿¡ï¼Ÿ

**A**: éœ€è¦åˆ›å»ºä¸¤ä¸ªç®¡é“æˆ–ä½¿ç”¨æ”¯æŒåŒå‘çš„IPCæœºåˆ¶ã€‚

**æ–¹æ³•1: ä¸¤ä¸ªç®¡é“**:

```rust
use std::process::{Command, Stdio};
use std::io::{Read, Write};

let mut child = Command::new("python")
    .arg("-u") // unbuffered
    .arg("script.py")
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()?;

// å‘å­è¿›ç¨‹å†™å…¥
if let Some(mut stdin) = child.stdin.as_mut() {
    stdin.write_all(b"input\n")?;
}

// ä»å­è¿›ç¨‹è¯»å–
if let Some(mut stdout) = child.stdout.as_mut() {
    let mut buf = String::new();
    stdout.read_to_string(&mut buf)?;
    println!("Output: {}", buf);
}
```

**æ–¹æ³•2: Unix Socket**:

```rust
#[cfg(unix)]
use std::os::unix::net::{UnixStream, UnixListener};

// æœåŠ¡ç«¯
let listener = UnixListener::bind("/tmp/my.sock")?;
let (mut stream, _) = listener.accept()?;

// åŒå‘é€šä¿¡
stream.write_all(b"request")?;
let mut buf = [0; 1024];
let n = stream.read(&mut buf)?;

// å®¢æˆ·ç«¯
let mut stream = UnixStream::connect("/tmp/my.sock")?;
stream.write_all(b"response")?;
let mut buf = [0; 1024];
let n = stream.read(&mut buf)?;
```

---

## è·¨å¹³å°é—®é¢˜

### Q7: å¦‚ä½•å®ç°è·¨å¹³å°çš„è¿›ç¨‹ç®¡ç†ï¼Ÿ

**A**: ä½¿ç”¨æ¡ä»¶ç¼–è¯‘å’ŒæŠ½è±¡å±‚æ¥å¤„ç†å¹³å°å·®å¼‚ã€‚

**æ ¸å¿ƒå·®å¼‚**:

| ç‰¹æ€§       | Unix/Linux        | Windows             |
| :--- | :--- | :--- || è¿›ç¨‹åˆ›å»º   | `fork()`+`exec()` | `CreateProcess()`   |
| ä¿¡å·       | SIGTERM, SIGKILL  | ä¸æ”¯æŒ              |
| è¿›ç¨‹ç»„     | è¿›ç¨‹ç»„ID          | ä½œä¸šå¯¹è±¡            |
| è·¯å¾„åˆ†éš”ç¬¦ | `/`               | `\`                 |
| Shell      | `sh`, `bash`      | `cmd`, `powershell` |

**è·¨å¹³å°å‘½ä»¤ç¤ºä¾‹**:

```rust
let cmd = if cfg!(target_os = "windows") {
    Command::new("cmd")
        .args(["/C", "dir"])
        .spawn()?
} else {
    Command::new("sh")
        .args(["-c", "ls -la"])
        .spawn()?
};
```

**æŠ½è±¡åŒ–ç¤ºä¾‹**:

```rust
fn run_shell_command(cmd: &str) -> Result<Output, std::io::Error> {
    if cfg!(windows) {
        Command::new("cmd")
            .args(["/C", cmd])
            .output()
    } else {
        Command::new("sh")
            .args(["-c", cmd])
            .output()
    }
}

let output = run_shell_command("echo Hello")?;
```

**æ¨èåº“**:

- `tokio` - ç»Ÿä¸€çš„å¼‚æ­¥è¿›ç¨‹API
- `nix` - Unix ç³»ç»Ÿè°ƒç”¨å°è£…
- `winapi` - Windows API å°è£…

**å‚è€ƒ**: [è·¨å¹³å°å®è·µ](../tier_02_guides/04_è·¨å¹³å°å®è·µ.md)

---

### Q8: Windowså’ŒUnixçš„è¿›ç¨‹æ¨¡å‹æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**: ä¸¤è€…åœ¨è¿›ç¨‹åˆ›å»ºå’Œç®¡ç†ä¸Šæœ‰æ ¹æœ¬æ€§å·®å¼‚ã€‚

**Unix/Linux**:

- `fork()`: å¤åˆ¶è¿›ç¨‹
- `exec()`: æ›¿æ¢ç¨‹åº
- ä¿¡å·: SIGTERM, SIGKILL
- è¿›ç¨‹ç»„å’Œä¼šè¯
- `/proc` æ–‡ä»¶ç³»ç»Ÿ

**Windows**:

- `CreateProcess()`: ç›´æ¥åˆ›å»ºè¿›ç¨‹
- æ—  forkï¼ˆæ— å†™æ—¶å¤åˆ¶ï¼‰
- æ—  Unix ä¿¡å·ï¼ˆæœ‰äº‹ä»¶å¯¹è±¡ï¼‰
- ä½œä¸šå¯¹è±¡ï¼ˆJob Objectï¼‰
- æ³¨å†Œè¡¨å’ŒæœåŠ¡ç®¡ç†

**Rust å¤„ç†**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;

#[cfg(windows)]
use std::os::windows::process::CommandExt;

let mut cmd = Command::new("app");

#[cfg(unix)]
{
    cmd.process_group(0); // åˆ›å»ºæ–°è¿›ç¨‹ç»„
}

#[cfg(windows)]
{
    cmd.creation_flags(0x00000200); // CREATE_NEW_PROCESS_GROUP
}

cmd.spawn()?;
```

---

## ç”Ÿå‘½å‘¨æœŸé—®é¢˜

### Q9: å¦‚ä½•é¿å…å’Œå¤„ç†åƒµå°¸è¿›ç¨‹ï¼Ÿ

**A**: åƒµå°¸è¿›ç¨‹æ˜¯å·²ç»ˆæ­¢ä½†çˆ¶è¿›ç¨‹æœªå›æ”¶å…¶é€€å‡ºçŠ¶æ€çš„è¿›ç¨‹ã€‚

**äº§ç”ŸåŸå› **:

- çˆ¶è¿›ç¨‹åˆ›å»ºå­è¿›ç¨‹åæœªè°ƒç”¨ `wait()`
- çˆ¶è¿›ç¨‹æ„å¤–é€€å‡º
- é”™è¯¯å¤„ç†ä¸å½“

**é¿å…æ–¹æ³•**:

**æ–¹æ³•1: ä½¿ç”¨ `output()` æˆ– `status()` (è‡ªåŠ¨ç­‰å¾…)**:

```rust
// è‡ªåŠ¨ç­‰å¾…å¹¶å›æ”¶
let output = Command::new("child").output()?;
let status = Command::new("child").status()?;
```

**æ–¹æ³•2: æ‰‹åŠ¨ `wait()`**:

```rust
let mut child = Command::new("child").spawn()?;
// ... åšå…¶ä»–äº‹æƒ… ...
let status = child.wait()?; // å›æ”¶å­è¿›ç¨‹
```

**æ–¹æ³•3: éé˜»å¡ `try_wait()`**:

```rust
let mut child = Command::new("child").spawn()?;

loop {
    match child.try_wait() {
        Ok(Some(status)) => {
            println!("å­è¿›ç¨‹é€€å‡º: {}", status);
            break; // å·²å›æ”¶
        }
        Ok(None) => {
            // ä»åœ¨è¿è¡Œï¼Œåšå…¶ä»–äº‹æƒ…
            thread::sleep(Duration::from_millis(100));
        }
        Err(e) => return Err(e),
    }
}
```

**æ–¹æ³•4: RAII æ¨¡å¼**:

```rust
struct ManagedChild(Child);

impl Drop for ManagedChild {
    fn drop(&mut self) {
        let _ = self.0.kill();
        let _ = self.0.wait();
    }
}
```

**Unix ä¿¡å·å¤„ç†**:

```rust
#[cfg(unix)]
{
    use nix::sys::signal::{signal, SigHandler, Signal};
    unsafe {
        // å¿½ç•¥SIGCHLDï¼Œè®©å†…æ ¸è‡ªåŠ¨å›æ”¶
        signal(Signal::SIGCHLD, SigHandler::SigIgn)?;
    }
}
```

**å‚è€ƒ**: [æœ¯è¯­è¡¨ - åƒµå°¸è¿›ç¨‹](./03_æœ¯è¯­è¡¨.md#åƒµå°¸è¿›ç¨‹-zombie-process)

---

### Q10: å¦‚ä½•ä¼˜é›…åœ°ç»ˆæ­¢å­è¿›ç¨‹ï¼Ÿ

**A**: ä¼˜å…ˆä½¿ç”¨ä¿¡å·ï¼ˆUnixï¼‰æˆ–è¯·æ±‚ç»ˆæ­¢ï¼ˆWindowsï¼‰ï¼Œæœ€åæ‰å¼ºåˆ¶killã€‚

**Unixä¼˜é›…ç»ˆæ­¢**:

```rust
#[cfg(unix)]
{
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;

    let pid = Pid::from_raw(child.id() as i32);

    // 1. å‘é€SIGTERMï¼ˆä¼˜é›…ç»ˆæ­¢ï¼‰
    kill(pid, Signal::SIGTERM)?;

    // 2. ç­‰å¾…ä¸€æ®µæ—¶é—´
    thread::sleep(Duration::from_secs(5));

    // 3. æ£€æŸ¥æ˜¯å¦è¿˜åœ¨è¿è¡Œ
    match child.try_wait()? {
        Some(status) => println!("å·²ç»ˆæ­¢: {}", status),
        None => {
            // 4. å¼ºåˆ¶SIGKILL
            println!("å‘é€SIGKILL");
            kill(pid, Signal::SIGKILL)?;
            child.wait()?;
        }
    }
}
```

**è·¨å¹³å°é€šç”¨**:

```rust
// 1. å°è¯•kill()
child.kill()?;

// 2. ç­‰å¾…å¹¶å›æ”¶
let status = child.wait()?;
println!("è¿›ç¨‹å·²ç»ˆæ­¢: {}", status);
```

---

### Q11: å¦‚ä½•å¤„ç†å­è¿›ç¨‹è¶…æ—¶ï¼Ÿ

**A**: ä½¿ç”¨å®šæ—¶å™¨æˆ–å¼‚æ­¥è¶…æ—¶æœºåˆ¶ã€‚

**æ–¹æ³•1: å®šæ—¶å™¨+try_wait()**:

```rust
use std::time::{Duration, Instant};

let mut child = Command::new("slow_task").spawn()?;
let timeout = Duration::from_secs(30);
let start = Instant::now();

loop {
    match child.try_wait()? {
        Some(status) => {
            println!("å®Œæˆ: {}", status);
            break;
        }
        None if start.elapsed() >= timeout => {
            println!("è¶…æ—¶ï¼Œç»ˆæ­¢è¿›ç¨‹");
            child.kill()?;
            child.wait()?;
            return Err("timeout".into());
        }
        None => {
            thread::sleep(Duration::from_millis(100));
        }
    }
}
```

**æ–¹æ³•2: Tokioå¼‚æ­¥è¶…æ—¶**:

```rust
use tokio::process::Command;
use tokio::time::{timeout, Duration};

let result = timeout(
    Duration::from_secs(30),
    Command::new("slow_task").output()
).await;

match result {
    Ok(Ok(output)) => println!("å®Œæˆ: {:?}", output.status),
    Ok(Err(e)) => eprintln!("è¿›ç¨‹é”™è¯¯: {}", e),
    Err(_) => eprintln!("è¶…æ—¶"),
}
```

---

## å¼‚æ­¥ä¸æ€§èƒ½é—®é¢˜

### Q12: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨å¼‚æ­¥è¿›ç¨‹ç®¡ç†ï¼Ÿ

**A**: å¼‚æ­¥é€‚åˆéœ€è¦åŒæ—¶ç®¡ç†å¤šä¸ªè¿›ç¨‹æˆ–I/Oå¯†é›†å‹åœºæ™¯ã€‚

**é€‚åˆå¼‚æ­¥**:

- âœ… åŒæ—¶ç®¡ç†å¤šä¸ªå­è¿›ç¨‹
- âœ… è¿›ç¨‹I/Oå¯†é›†å‹æ“ä½œ
- âœ… éœ€è¦è¶…æ—¶æ§åˆ¶
- âœ… ä¸å…¶ä»–å¼‚æ­¥æ“ä½œååŒ
- âœ… WebæœåŠ¡å™¨ã€çˆ¬è™«ç­‰é«˜å¹¶å‘åœºæ™¯

**ä¸é€‚åˆå¼‚æ­¥**:

- âŒ å•ä¸ªè¿›ç¨‹ç®€å•æ‰§è¡Œ
- âŒ CPUå¯†é›†å‹ä»»åŠ¡
- âŒ éœ€è¦å®æ—¶ä¿è¯çš„åœºæ™¯

**Tokioç¤ºä¾‹**:

```rust
use tokio::process::Command;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // å¹¶å‘å¯åŠ¨å¤šä¸ªè¿›ç¨‹
    let tasks = vec![
        tokio::spawn(run_task("task1")),
        tokio::spawn(run_task("task2")),
        tokio::spawn(run_task("task3")),
    ];

    // ç­‰å¾…æ‰€æœ‰å®Œæˆ
    for task in tasks {
        task.await??;
    }

    Ok(())
}

async fn run_task(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let output = Command::new(name).output().await?;
    println!("{} å®Œæˆ: {:?}", name, output.status);
    Ok(())
}
```

**å‚è€ƒ**: [å¼‚æ­¥è¿›ç¨‹ç®¡ç†](../tier_02_guides/03_å¼‚æ­¥è¿›ç¨‹ç®¡ç†.md)

---

### Q13: å¦‚ä½•æé«˜è¿›ç¨‹é€šä¿¡æ€§èƒ½ï¼Ÿ

**A**: é€‰æ‹©åˆé€‚çš„IPCæœºåˆ¶ï¼Œå‡å°‘æ•°æ®æ‹·è´ï¼Œä½¿ç”¨ç¼“å†²ã€‚

**æ€§èƒ½ä¼˜åŒ–å»ºè®®**:

1. **é€‰æ‹©é«˜æ€§èƒ½IPC**:
   - å…±äº«å†…å­˜ > Unix Socket > ç®¡é“ > TCP

2. **å‡å°‘æ‹·è´**:

   ```rust
   // ä½¿ç”¨ BufReader/BufWriter
   use std::io::{BufReader, BufWriter};

   let stdout = BufReader::new(child.stdout.take().unwrap());
   let stdin = BufWriter::new(child.stdin.take().unwrap());
   ```

3. **æ‰¹é‡ä¼ è¾“**:

   ```rust
   // æ‰¹é‡è€Œéé€ä¸ª
   let data: Vec<u8> = (0..10000).map(|_| 42u8).collect();
   stdin.write_all(&data)?;
   ```

4. **é›¶æ‹·è´æŠ€æœ¯** (é«˜çº§):

   ```rust
   // ä½¿ç”¨ splice() (Linux)
   #[cfg(target_os = "linux")]
   use nix::fcntl::splice;
   ```

**å‚è€ƒ**: [æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](../tier_03_references/05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

### Q14: å¦‚ä½•ç›‘æ§è¿›ç¨‹èµ„æºä½¿ç”¨ï¼Ÿ

**A**: ä½¿ç”¨ç³»ç»Ÿå·¥å…·æˆ–ç¬¬ä¸‰æ–¹åº“è·å–è¿›ç¨‹èµ„æºä¿¡æ¯ã€‚

**æ–¹æ³•1: ä½¿ç”¨ sysinfo åº“**:

```rust
use sysinfo::{System, SystemExt, ProcessExt};

let mut sys = System::new_all();
sys.refresh_all();

if let Some(process) = sys.process(pid.into()) {
    println!("CPUä½¿ç”¨: {}%", process.cpu_usage());
    println!("å†…å­˜: {} KB", process.memory());
}
```

**æ–¹æ³•2: è¯»å– /proc (Linux)**:

```rust
#[cfg(target_os = "linux")]
fn get_process_stats(pid: u32) -> std::io::Result<String> {
    std::fs::read_to_string(format!("/proc/{}/stat", pid))
}
```

**å‚è€ƒ**: [è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­](../tier_02_guides/05_è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­.md)

---

## é”™è¯¯å¤„ç†é—®é¢˜

### Q15: å¦‚ä½•å¤„ç†è¿›ç¨‹åˆ›å»ºå¤±è´¥ï¼Ÿ

**A**: ä½¿ç”¨ `Result` å’Œæ¨¡å¼åŒ¹é…å¤„ç†å„ç§é”™è¯¯ã€‚

```rust
use std::io::ErrorKind;

match Command::new("nonexistent").spawn() {
    Ok(child) => println!("æˆåŠŸ: PID {}", child.id()),
    Err(e) => match e.kind() {
        ErrorKind::NotFound => {
            eprintln!("ç¨‹åºä¸å­˜åœ¨");
        }
        ErrorKind::PermissionDenied => {
            eprintln!("æƒé™ä¸è¶³");
        }
        _ => {
            eprintln!("å…¶ä»–é”™è¯¯: {}", e);
        }
    }
}
```

---

### Q16: å¦‚ä½•åŒºåˆ†è¿›ç¨‹é”™è¯¯ç±»å‹ï¼Ÿ

**A**: æ£€æŸ¥ `ExitStatus` å’Œé”™è¯¯ç ã€‚

```rust
let output = Command::new("app").output()?;

if output.status.success() {
    println!("æˆåŠŸ");
} else if let Some(code) = output.status.code() {
    println!("å¤±è´¥ï¼Œé€€å‡ºç : {}", code);
} else {
    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        if let Some(signal) = output.status.signal() {
            println!("è¢«ä¿¡å·ç»ˆæ­¢: {}", signal);
        }
    }
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [é¡¹ç›®æ¦‚è§ˆ](./01_é¡¹ç›®æ¦‚è§ˆ.md)
- [ä¸»ç´¢å¼•å¯¼èˆª](./02_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [æœ¯è¯­è¡¨](./03_æœ¯è¯­è¡¨.md)
- [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](../tier_02_guides/01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)
- [IPCé€šä¿¡å®è·µ](../tier_02_guides/02_IPCé€šä¿¡å®è·µ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
