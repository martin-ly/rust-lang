# Tier 1: C07 è¿›ç¨‹ç®¡ç† - é¡¹ç›®æ¦‚è§ˆ

> **æ–‡æ¡£ç±»å‹**: é¡¹ç›®æ¦‚è¿°
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **æœ€åæ›´æ–°**: 2025-12-11

---

## ç›®å½•

- [Tier 1: C07 è¿›ç¨‹ç®¡ç† - é¡¹ç›®æ¦‚è§ˆ](#tier-1-c07-è¿›ç¨‹ç®¡ç†---é¡¹ç›®æ¦‚è§ˆ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ¯ æ¨¡å—ç®€ä»‹](#-æ¨¡å—ç®€ä»‹)
    - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
    - [æ¶æ„è®¾è®¡åŸåˆ™](#æ¶æ„è®¾è®¡åŸåˆ™)
  - [ğŸ’¡ ä¸ºä»€ä¹ˆå­¦ä¹ è¿›ç¨‹ç®¡ç†ï¼Ÿ](#-ä¸ºä»€ä¹ˆå­¦ä¹ è¿›ç¨‹ç®¡ç†)
    - [ç³»ç»Ÿç¼–ç¨‹åŸºç¡€](#ç³»ç»Ÿç¼–ç¨‹åŸºç¡€)
    - [å®é™…åº”ç”¨åœºæ™¯](#å®é™…åº”ç”¨åœºæ™¯)
    - [Rust çš„ä¼˜åŠ¿](#rust-çš„ä¼˜åŠ¿)
    - [ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”](#ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”)
  - [ğŸ“š æ ¸å¿ƒå†…å®¹](#-æ ¸å¿ƒå†…å®¹)
    - [1. è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†](#1-è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†)
    - [2. è¿›ç¨‹é—´é€šä¿¡ (IPC)](#2-è¿›ç¨‹é—´é€šä¿¡-ipc)
    - [3. åŒæ­¥åŸè¯­](#3-åŒæ­¥åŸè¯­)
    - [4. è·¨å¹³å°æ”¯æŒ](#4-è·¨å¹³å°æ”¯æŒ)
  - [ğŸš€ å¿«é€Ÿå¼€å§‹](#-å¿«é€Ÿå¼€å§‹)
    - [1. å®‰è£…](#1-å®‰è£…)
    - [2. ç¬¬ä¸€ä¸ªç¨‹åº](#2-ç¬¬ä¸€ä¸ªç¨‹åº)
    - [3. è¿è¡Œç¤ºä¾‹](#3-è¿è¡Œç¤ºä¾‹)
  - [ğŸ“ å­¦ä¹ è·¯å¾„](#-å­¦ä¹ è·¯å¾„)
    - [æ–°æ‰‹è·¯å¾„ (1-2 å‘¨)](#æ–°æ‰‹è·¯å¾„-1-2-å‘¨)
    - [è¿›é˜¶è·¯å¾„ (2-4 å‘¨)](#è¿›é˜¶è·¯å¾„-2-4-å‘¨)
    - [ä¸“å®¶è·¯å¾„ (æŒç»­å­¦ä¹ )](#ä¸“å®¶è·¯å¾„-æŒç»­å­¦ä¹ )
    - [æ¨èå®è·µé¡¹ç›®](#æ¨èå®è·µé¡¹ç›®)
  - [ğŸ¯ å¸¸è§åº”ç”¨åœºæ™¯](#-å¸¸è§åº”ç”¨åœºæ™¯)
    - [1. ç³»ç»Ÿç›‘æ§å’Œå‘Šè­¦](#1-ç³»ç»Ÿç›‘æ§å’Œå‘Šè­¦)
    - [2. æ„å»ºç³»ç»Ÿå’Œ CI/CD](#2-æ„å»ºç³»ç»Ÿå’Œ-cicd)
    - [3. æ•°æ®é‡‡é›†å’Œ ETL](#3-æ•°æ®é‡‡é›†å’Œ-etl)
    - [4. æœåŠ¡ç¼–æ’](#4-æœåŠ¡ç¼–æ’)
  - [ğŸ’¡ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. èµ„æºç®¡ç†](#1-èµ„æºç®¡ç†)
    - [2. é”™è¯¯å¤„ç†](#2-é”™è¯¯å¤„ç†)
    - [3. è·¨å¹³å°å…¼å®¹](#3-è·¨å¹³å°å…¼å®¹)
    - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
  - [ğŸ“Š æ¨¡å—ç»Ÿè®¡](#-æ¨¡å—ç»Ÿè®¡)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
    - [æœ¬æ¨¡å—](#æœ¬æ¨¡å—)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ğŸ¯ æ¨¡å—ç®€ä»‹

**C07 Process Management** æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ Rust è¿›ç¨‹ç®¡ç†å’Œ IPC é€šä¿¡åº“ï¼Œæä¾›ï¼š

- **è¿›ç¨‹ç®¡ç†**: è¿›ç¨‹åˆ›å»ºã€ç›‘æ§ã€æ§åˆ¶å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- **IPC é€šä¿¡**: å‘½åç®¡é“ã€Unix å¥—æ¥å­—ã€TCP å¥—æ¥å­—ã€å…±äº«å†…å­˜ã€æ¶ˆæ¯é˜Ÿåˆ—
- **åŒæ­¥åŸè¯­**: äº’æ–¥é”ã€è¯»å†™é”ã€æ¡ä»¶å˜é‡ã€ä¿¡å·é‡ã€å±éšœ
- **è·¨å¹³å°**: æ”¯æŒ Windowsã€Linux å’Œ macOS
- **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ Rust ç±»å‹ç³»ç»Ÿå’Œé”™è¯¯å¤„ç†
- **Rust 1.92.0**: å……åˆ†åˆ©ç”¨æœ€æ–°è¯­è¨€ç‰¹æ€§ï¼ˆå…¼å®¹ Rust 1.90+ ç‰¹æ€§ï¼‰

### æ ¸å¿ƒç‰¹æ€§

**1. è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸå…¨é¢ç®¡ç†**:

- è¿›ç¨‹åˆ›å»ºå’Œæ´¾ç”Ÿ (spawn, fork)
- è¿›ç¨‹çŠ¶æ€ç›‘æ§ (è¿è¡Œä¸­ã€åœæ­¢ã€åƒµå°¸)
- è¿›ç¨‹ä¿¡å·å¤„ç† (SIGTERM, SIGKILL)
- è¿›ç¨‹èµ„æºé™åˆ¶ (CPU, å†…å­˜)
- è¿›ç¨‹ç»„å’Œä¼šè¯ç®¡ç†

**2. å¤šç§ IPC é€šä¿¡æ–¹å¼**:

| IPC ç±»å‹    | æ€§èƒ½ | è·¨å¹³å°    | ä½¿ç”¨åœºæ™¯       |
| :--- | :--- | :--- | :--- || å‘½åç®¡é“    | ä¸­   | âœ…        | æœ¬åœ°è¿›ç¨‹é€šä¿¡   |
| Unix Socket | é«˜   | Unix only | æœ¬åœ°é«˜æ€§èƒ½é€šä¿¡ |
| TCP Socket  | ä¸­   | âœ…        | ç½‘ç»œé€šä¿¡       |
| å…±äº«å†…å­˜    | æé«˜ | âš ï¸        | å¤§æ•°æ®ä¼ è¾“     |
| æ¶ˆæ¯é˜Ÿåˆ—    | ä¸­   | âš ï¸        | å¼‚æ­¥æ¶ˆæ¯ä¼ é€’   |

**3. Rust 1.92.0 æ–°ç‰¹æ€§æ”¯æŒ**ï¼ˆå…¼å®¹ Rust 1.90+ ç‰¹æ€§ï¼‰:

- `std::process::Command` å¢å¼º API
- `std::os::unix::process` æ‰©å±•
- `std::os::windows::process` æ‰©å±•
- åŒ¿åç®¡é“ (anonymous pipes) æ ‡å‡†åŒ–
- æ–‡ä»¶æè¿°ç¬¦ç®¡ç†æ”¹è¿›

### æ¶æ„è®¾è®¡åŸåˆ™

**å†…å­˜å®‰å…¨ä¼˜å…ˆ**: åˆ©ç”¨ Rust çš„æ‰€æœ‰æƒç³»ç»Ÿï¼Œç¡®ä¿è¿›ç¨‹é—´é€šä¿¡æ— æ•°æ®ç«äº‰

**è·¨å¹³å°æŠ½è±¡**: ç»Ÿä¸€çš„ API æ¥å£ï¼Œåº•å±‚è‡ªåŠ¨é€‚é…ä¸åŒæ“ä½œç³»ç»Ÿ

**æ€§èƒ½ä¼˜åŒ–**: é›¶æ‹·è´ä¼ è¾“ã€å¼‚æ­¥ I/Oã€æ‰¹é‡æ“ä½œ

**é”™è¯¯å¤„ç†**: å¼ºç±»å‹é”™è¯¯ï¼Œè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼Œä¾¿äºè°ƒè¯•

---

## ğŸ’¡ ä¸ºä»€ä¹ˆå­¦ä¹ è¿›ç¨‹ç®¡ç†ï¼Ÿ

### ç³»ç»Ÿç¼–ç¨‹åŸºç¡€

è¿›ç¨‹ç®¡ç†æ˜¯ç³»ç»Ÿç¼–ç¨‹çš„æ ¸å¿ƒæŠ€èƒ½ï¼Œå¯¹äºï¼š

1. **æ„å»ºç³»ç»Ÿå·¥å…·**: å¼€å‘ç›‘æ§ã€è‡ªåŠ¨åŒ–ã€éƒ¨ç½²å·¥å…·
2. **å¾®æœåŠ¡æ¶æ„**: ç®¡ç†å¤šä¸ªæœåŠ¡è¿›ç¨‹
3. **å¹¶è¡Œè®¡ç®—**: åˆ©ç”¨å¤šè¿›ç¨‹è¿›è¡Œè®¡ç®—
4. **å®¹å™¨åŒ–**: ç†è§£å®¹å™¨åº•å±‚æœºåˆ¶
5. **æ€§èƒ½ä¼˜åŒ–**: ä¼˜åŒ–è¿›ç¨‹é—´åä½œ

### å®é™…åº”ç”¨åœºæ™¯

**1. DevOps è‡ªåŠ¨åŒ–**:

```rust
// æ‰¹é‡éƒ¨ç½²å·¥å…·
use std::process::Command;

fn deploy_service(service: &str) -> std::io::Result<()> {
    let output = Command::new("systemctl")
        .arg("restart")
        .arg(service)
        .output()?;

    if output.status.success() {
        println!("âœ… {} deployed", service);
    }
    Ok(())
}
```

**2. æ•°æ®å¤„ç†ç®¡é“**:

```rust
// ä½¿ç”¨ç®¡é“è¿æ¥å¤šä¸ªè¿›ç¨‹
use std::process::{Command, Stdio};

fn process_pipeline() -> std::io::Result<()> {
    let ps = Command::new("ps")
        .arg("aux")
        .stdout(Stdio::piped())
        .spawn()?;

    let grep = Command::new("grep")
        .arg("rust")
        .stdin(Stdio::from(ps.stdout.unwrap()))
        .output()?;

    println!("Rust processes: {}", String::from_utf8_lossy(&grep.stdout));
    Ok(())
}
```

**3. ç›‘æ§å’Œå¥åº·æ£€æŸ¥**:

```rust
// å®šæœŸæ£€æŸ¥å­è¿›ç¨‹å¥åº·çŠ¶æ€
use std::process::{Child, Command};
use std::time::Duration;

struct MonitoredProcess {
    child: Child,
    name: String,
}

impl MonitoredProcess {
    fn check_health(&mut self) -> bool {
        match self.child.try_wait() {
            Ok(Some(status)) => {
                println!("âš ï¸  {} exited: {}", self.name, status);
                false
            }
            Ok(None) => true, // Still running
            Err(e) => {
                eprintln!("âŒ Error checking {}: {}", self.name, e);
                false
            }
        }
    }

    fn restart(&mut self) -> std::io::Result<()> {
        println!("ğŸ”„ Restarting {}", self.name);
        // Restart logic here
        Ok(())
    }
}
```

**4. åˆ†å¸ƒå¼è®¡ç®—**:

```rust
// å¹¶è¡Œæ•°æ®å¤„ç†
use std::process::Command;

fn parallel_compute(data_chunks: &[Vec<u8>]) -> Vec<Vec<u8>> {
    data_chunks.iter().map(|chunk| {
        // ä¸ºæ¯ä¸ªæ•°æ®å—å¯åŠ¨ä¸€ä¸ªå·¥ä½œè¿›ç¨‹
        let output = Command::new("./worker")
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .expect("Failed to spawn worker");

        // å¤„ç†æ•°æ®...
        vec![]
    }).collect()
}
```

### Rust çš„ä¼˜åŠ¿

Rust åœ¨è¿›ç¨‹ç®¡ç†æ–¹é¢æä¾›ï¼š

- âœ… **å†…å­˜å®‰å…¨**: æ— æ•°æ®ç«äº‰ï¼Œç¼–è¯‘æ—¶é˜²æ­¢å¸¸è§é”™è¯¯
- âœ… **é›¶æˆæœ¬æŠ½è±¡**: æ€§èƒ½æ¥è¿‘ Cï¼Œæ— è¿è¡Œæ—¶å¼€é”€
- âœ… **è·¨å¹³å°**: ç»Ÿä¸€çš„ APIï¼Œè‡ªåŠ¨é€‚é…æ“ä½œç³»ç»Ÿ
- âœ… **é”™è¯¯å¤„ç†**: å¼ºç±»å‹é”™è¯¯ï¼Œ`Result<T, E>` å¼ºåˆ¶å¤„ç†é”™è¯¯
- âœ… **å¼‚æ­¥æ”¯æŒ**: é«˜æ€§èƒ½ I/Oï¼Œ`tokio::process` é›†æˆ

### ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”

| ç‰¹æ€§         | Rust           | Python     | C/C++       | Go           |
| :--- | :--- | :--- | :--- | :--- || **å†…å­˜å®‰å…¨** | âœ… ç¼–è¯‘æ—¶      | âš ï¸ è¿è¡Œæ—¶  | âŒ æ‰‹åŠ¨ç®¡ç† | âœ… GC        |
| **æ€§èƒ½**     | â­â­â­â­â­     | â­â­       | â­â­â­â­â­  | â­â­â­â­     |
| **è·¨å¹³å°**   | âœ… ç»Ÿä¸€API     | âœ… ç»Ÿä¸€API | âš ï¸ æ¡ä»¶ç¼–è¯‘ | âœ… ç»Ÿä¸€API   |
| **é”™è¯¯å¤„ç†** | å¼ºç±»å‹         | å¼‚å¸¸       | è¿”å›å€¼/å¼‚å¸¸ | è¿”å›å€¼       |
| **å¼‚æ­¥æ”¯æŒ** | âœ… async/await | âœ… asyncio | âŒ åº“æ”¯æŒ   | âœ… goroutine |

**Rust çš„ç‹¬ç‰¹ä¼˜åŠ¿**:

- ç¼–è¯‘æ—¶å†…å­˜å®‰å…¨ä¿è¯ï¼Œæ— éœ€åƒåœ¾å›æ”¶
- é›¶æˆæœ¬æŠ½è±¡ï¼Œæ€§èƒ½æ¥è¿‘ C
- å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿï¼Œç¼–è¯‘æ—¶æ•è·é”™è¯¯
- ç°ä»£åŒ–çš„é”™è¯¯å¤„ç†æœºåˆ¶

---

## ğŸ“š æ ¸å¿ƒå†…å®¹

### 1. è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

**åˆ›å»ºè¿›ç¨‹**:

```rust
use c07_process::prelude::*;

let mut pm = ProcessManager::new();
let pid = pm.spawn(ProcessConfig {
    program: "echo".to_string(),
    args: vec!["Hello".to_string()],
    ..Default::default()
})?;
```

**ç›‘æ§è¿›ç¨‹**:

```rust
let info = pm.get_process_info(pid)?;
println!("çŠ¶æ€: {:?}", info.status);
```

---

### 2. è¿›ç¨‹é—´é€šä¿¡ (IPC)

**ç®¡é“é€šä¿¡**:

```rust
let mut ipc = IpcManager::new(IpcConfig::default());
ipc.create_named_pipe("my_pipe")?;

let message = Message::new(1, "demo", b"Hello IPC!".to_vec(), 1234);
ipc.send_message("my_pipe", &message)?;
```

**æ”¯æŒçš„ IPC æœºåˆ¶**:

- å‘½åç®¡é“ (Named Pipes)
- Unix åŸŸå¥—æ¥å­— (Unix Sockets)
- TCP å¥—æ¥å­— (TCP Sockets)
- å…±äº«å†…å­˜ (Shared Memory)
- æ¶ˆæ¯é˜Ÿåˆ— (Message Queues)

---

### 3. åŒæ­¥åŸè¯­

**äº’æ–¥é”**:

```rust
let mut sync = SyncManager::new(SyncConfig::default());
let mutex = sync.create_mutex("demo_mutex")?;

if let Ok(guard) = mutex.lock() {
    // ä¸´ç•ŒåŒº
    drop(guard);
}
```

**å…¶ä»–åŸè¯­**:

- è¯»å†™é” (RwLock)
- æ¡ä»¶å˜é‡ (Condvar)
- ä¿¡å·é‡ (Semaphore)
- å±éšœ (Barrier)

---

### 4. è·¨å¹³å°æ”¯æŒ

**Windows å…¼å®¹**:

```rust
let mut cmd = if cfg!(windows) {
    let mut c = Command::new("cmd");
    c.args(["/C", "echo hello"]);
    c
} else {
    let mut c = Command::new("sh");
    c.args(["-c", "echo hello"]);
    c
};
```

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. å®‰è£…

```toml
[dependencies]
c07_process = { path = "crates/c07_process" }
```

### 2. ç¬¬ä¸€ä¸ªç¨‹åº

```rust
use c07_process::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut pm = ProcessManager::new();

    let config = ProcessConfig {
        program: "echo".to_string(),
        args: vec!["Hello, World!".to_string()],
        ..Default::default()
    };

    let pid = pm.spawn(config)?;
    println!("è¿›ç¨‹å¯åŠ¨æˆåŠŸ: {}", pid);

    Ok(())
}
```

### 3. è¿è¡Œç¤ºä¾‹

```bash
cargo run --bin process_demo
cargo run --bin ipc_demo
cargo run --bin sync_demo
```

---

## ğŸ“ å­¦ä¹ è·¯å¾„

### æ–°æ‰‹è·¯å¾„ (1-2 å‘¨)

**ç›®æ ‡**: æŒæ¡è¿›ç¨‹ç®¡ç†åŸºç¡€ï¼Œèƒ½å¤Ÿåˆ›å»ºå’Œç®¡ç†ç®€å•è¿›ç¨‹

1. **Tier 1 åŸºç¡€** (2-3 å¤©):
   - é˜…è¯»æœ¬æ–‡æ¡£å’Œæœ¯è¯­è¡¨
   - ç†è§£è¿›ç¨‹çš„åŸºæœ¬æ¦‚å¿µ
   - ç†Ÿæ‚‰ `std::process` æ¨¡å—

2. **Tier 2 å®è·µ** (3-5 å¤©):
   - [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](../tier_02_guides/01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)
   - [IPCé€šä¿¡å®è·µ](../tier_02_guides/02_IPCé€šä¿¡å®è·µ.md)
   - å®Œæˆ 5+ ä¸ªåŸºç¡€ç»ƒä¹ 

3. **åŠ¨æ‰‹å®è·µ** (2-3 å¤©):
   - è¿è¡Œç¤ºä¾‹ç¨‹åº
   - ç¼–å†™ç®€å•çš„å‘½ä»¤è¡Œå·¥å…·
   - å®ç°ä¸€ä¸ªç®€å•çš„è¿›ç¨‹ç›‘æ§å™¨

**å­¦ä¹ æˆæœ**:

- âœ… èƒ½å¤Ÿä½¿ç”¨ `Command` åˆ›å»ºè¿›ç¨‹
- âœ… ç†è§£è¿›ç¨‹çš„è¾“å…¥è¾“å‡ºé‡å®šå‘
- âœ… æŒæ¡åŸºæœ¬çš„è¿›ç¨‹ç­‰å¾…å’ŒçŠ¶æ€æŸ¥è¯¢
- âœ… äº†è§£ç®¡é“é€šä¿¡çš„åŸºæœ¬åŸç†

### è¿›é˜¶è·¯å¾„ (2-4 å‘¨)

**ç›®æ ‡**: ç²¾é€šè·¨å¹³å°è¿›ç¨‹ç®¡ç†ï¼ŒæŒæ¡é«˜çº§ IPC æŠ€æœ¯

1. **Tier 2 æ·±å…¥** (1 å‘¨):
   - [å¼‚æ­¥è¿›ç¨‹ç®¡ç†](../tier_02_guides/03_å¼‚æ­¥è¿›ç¨‹ç®¡ç†.md)
   - [è·¨å¹³å°å®è·µ](../tier_02_guides/04_è·¨å¹³å°å®è·µ.md)
   - [è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­](../tier_02_guides/05_è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­.md)

2. **Tier 3 å‚è€ƒ** (1 å‘¨):
   - æŸ¥é˜…æŠ€æœ¯å‚è€ƒæ‰‹å†Œ
   - æ·±å…¥ç†è§£ Unix/Windows è¿›ç¨‹æ¨¡å‹
   - å­¦ä¹ å„ç§ IPC æœºåˆ¶çš„å®ç°ç»†èŠ‚

3. **é¡¹ç›®å®æˆ˜** (1-2 å‘¨):
   - æ„å»ºä¸€ä¸ªå®Œæ•´çš„ç›‘æ§å·¥å…·
   - å®ç°ä¸€ä¸ªè¿›ç¨‹ç®¡ç†å™¨ï¼ˆç±»ä¼¼ supervisordï¼‰
   - å¼€å‘ä¸€ä¸ªè·¨å¹³å°çš„è‡ªåŠ¨åŒ–è„šæœ¬å·¥å…·

**å­¦ä¹ æˆæœ**:

- âœ… èƒ½å¤Ÿå¤„ç†å¤æ‚çš„è¿›ç¨‹ç®¡ç†åœºæ™¯
- âœ… æŒæ¡å¤šç§ IPC æœºåˆ¶çš„ä½¿ç”¨
- âœ… ç†è§£è·¨å¹³å°å·®å¼‚å’Œè§£å†³æ–¹æ¡ˆ
- âœ… èƒ½å¤Ÿè®¾è®¡å’Œå®ç°ç”Ÿäº§çº§å·¥å…·

### ä¸“å®¶è·¯å¾„ (æŒç»­å­¦ä¹ )

**ç›®æ ‡**: æ·±å…¥è¿›ç¨‹ç®¡ç†åŸç†ï¼Œå…·å¤‡ç³»ç»Ÿçº§ç¼–ç¨‹èƒ½åŠ›

1. **Tier 4 é«˜çº§** (2-3 å‘¨):
   - æ·±å…¥å®‰å…¨å’Œæ²™ç®±æŠ€æœ¯
   - æ€§èƒ½ä¼˜åŒ–å’Œå·¥ç¨‹å®è·µ
   - æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•æ–¹æ³•

2. **æºç ç ”ç©¶** (æŒç»­):
   - é˜…è¯» Rust æ ‡å‡†åº“ `std::process` æºç 
   - ç ”ç©¶ `tokio::process` å®ç°
   - åˆ†æç¬¬ä¸‰æ–¹åº“ï¼ˆnix, windows-rsï¼‰

3. **è´¡çŒ®å¼€æº** (æŒç»­):
   - å‚ä¸ Rust æ ‡å‡†åº“è®¨è®º
   - ä¸ºè¿›ç¨‹ç®¡ç†ç›¸å…³åº“è´¡çŒ®ä»£ç 
   - åˆ†äº«å®è·µç»éªŒå’Œæœ€ä½³å®è·µ

**å­¦ä¹ æˆæœ**:

- âœ… æ·±åˆ»ç†è§£æ“ä½œç³»ç»Ÿè¿›ç¨‹æ¨¡å‹
- âœ… èƒ½å¤Ÿä¼˜åŒ–è¿›ç¨‹ç®¡ç†æ€§èƒ½
- âœ… æŒæ¡å®‰å…¨è¿›ç¨‹ç®¡ç†å®è·µ
- âœ… å…·å¤‡è®¾è®¡åˆ†å¸ƒå¼è¿›ç¨‹ç³»ç»Ÿçš„èƒ½åŠ›

### æ¨èå®è·µé¡¹ç›®

**åˆçº§é¡¹ç›®**:

1. **å‘½ä»¤è¡Œå·¥å…·åŒ…è£…å™¨**: åŒ…è£…å¸¸ç”¨å‘½ä»¤ï¼Œæä¾›å‹å¥½çš„ Rust API
2. **ç®€å•ä»»åŠ¡è°ƒåº¦å™¨**: å®šæ—¶æ‰§è¡Œä»»åŠ¡çš„è°ƒåº¦å™¨
3. **æ—¥å¿—èšåˆå·¥å…·**: ä»å¤šä¸ªè¿›ç¨‹æ”¶é›†æ—¥å¿—

**ä¸­çº§é¡¹ç›®**:

1. **è¿›ç¨‹ç›‘æ§é¢æ¿**: Web ç•Œé¢çš„è¿›ç¨‹ç›‘æ§å·¥å…·
2. **åˆ†å¸ƒå¼ä»»åŠ¡é˜Ÿåˆ—**: è·¨æœºå™¨çš„ä»»åŠ¡åˆ†å‘å’Œæ‰§è¡Œ
3. **æœåŠ¡ç¼–æ’å™¨**: ç®¡ç†å¤šä¸ªæœåŠ¡è¿›ç¨‹çš„ç”Ÿå‘½å‘¨æœŸ

**é«˜çº§é¡¹ç›®**:

1. **å®¹å™¨è¿è¡Œæ—¶**: ç®€åŒ–ç‰ˆçš„å®¹å™¨ç®¡ç†å·¥å…·
2. **è¿›ç¨‹æ²™ç®±**: éš”ç¦»è¿›ç¨‹çš„å®‰å…¨æ‰§è¡Œç¯å¢ƒ
3. **åˆ†å¸ƒå¼è¿›ç¨‹ç¼–æ’ç³»ç»Ÿ**: ç±»ä¼¼ Kubernetes çš„è¿›ç¨‹ç®¡ç†

---

## ğŸ¯ å¸¸è§åº”ç”¨åœºæ™¯

### 1. ç³»ç»Ÿç›‘æ§å’Œå‘Šè­¦

```rust
// ç›‘æ§ç³»ç»Ÿèµ„æºï¼Œè¶…è¿‡é˜ˆå€¼å‘é€å‘Šè­¦
use std::process::Command;
use std::thread;
use std::time::Duration;

fn monitor_system() {
    loop {
        let output = Command::new("ps")
            .args(["aux", "--sort=-%mem"])
            .output()
            .expect("Failed to execute ps");

        // åˆ†æè¾“å‡ºï¼Œæ£€æµ‹å¼‚å¸¸
        let stdout = String::from_utf8_lossy(&output.stdout);
        if analyze_memory_usage(&stdout) > 90.0 {
            send_alert("Memory usage critical!");
        }

        thread::sleep(Duration::from_secs(60));
    }
}
```

### 2. æ„å»ºç³»ç»Ÿå’Œ CI/CD

```rust
// ç¼–è¯‘å¤šä¸ªå­é¡¹ç›®
fn build_projects(projects: &[&str]) -> Result<(), Box<dyn std::error::Error>> {
    for project in projects {
        println!("Building {}...", project);

        let status = Command::new("cargo")
            .args(["build", "--release"])
            .current_dir(project)
            .status()?;

        if !status.success() {
            return Err(format!("Build failed for {}", project).into());
        }
    }
    Ok(())
}
```

### 3. æ•°æ®é‡‡é›†å’Œ ETL

```rust
// å¹¶è¡Œå¤„ç†æ•°æ®æ–‡ä»¶
use std::process::{Command, Stdio};

fn etl_pipeline(files: &[&str]) {
    let handles: Vec<_> = files.iter().map(|file| {
        Command::new("./process_data")
            .arg(file)
            .stdout(Stdio::piped())
            .spawn()
            .expect("Failed to spawn process")
    }).collect();

    // ç­‰å¾…æ‰€æœ‰å¤„ç†å®Œæˆ
    for mut handle in handles {
        let output = handle.wait_with_output().expect("Failed to wait");
        // å¤„ç†è¾“å‡º...
    }
}
```

### 4. æœåŠ¡ç¼–æ’

```rust
// å¯åŠ¨å’Œç®¡ç†å¤šä¸ªå¾®æœåŠ¡
struct ServiceOrchestrator {
    services: Vec<(String, Child)>,
}

impl ServiceOrchestrator {
    fn start_all(&mut self) -> std::io::Result<()> {
        let services = vec!["api", "worker", "scheduler"];

        for service in services {
            let child = Command::new(format!("./{}", service))
                .spawn()?;
            self.services.push((service.to_string(), child));
        }
        Ok(())
    }

    fn health_check(&mut self) {
        for (name, child) in &mut self.services {
            if let Ok(Some(status)) = child.try_wait() {
                println!("âš ï¸  Service {} exited: {}", name, status);
                // é‡å¯é€»è¾‘
            }
        }
    }
}
```

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. èµ„æºç®¡ç†

**âœ… æ¨èåšæ³•**:

```rust
// ä½¿ç”¨ RAII ç¡®ä¿è¿›ç¨‹æ¸…ç†
struct ManagedProcess(Child);

impl Drop for ManagedProcess {
    fn drop(&mut self) {
        // ç¡®ä¿è¿›ç¨‹è¢«æ­£ç¡®ç»ˆæ­¢
        let _ = self.0.kill();
        let _ = self.0.wait();
    }
}
```

**âŒ é¿å…åšæ³•**:

```rust
// å¿˜è®°ç­‰å¾…å­è¿›ç¨‹ï¼Œå¯¼è‡´åƒµå°¸è¿›ç¨‹
let child = Command::new("./worker").spawn()?;
// æ²¡æœ‰ wait() æˆ– try_wait()
```

### 2. é”™è¯¯å¤„ç†

**âœ… æ¨èåšæ³•**:

```rust
// è¯¦ç»†çš„é”™è¯¯å¤„ç†
fn spawn_with_retry(cmd: &str, max_retries: u32) -> std::io::Result<Child> {
    for attempt in 0..max_retries {
        match Command::new(cmd).spawn() {
            Ok(child) => return Ok(child),
            Err(e) if attempt < max_retries - 1 => {
                eprintln!("Attempt {} failed: {}, retrying...", attempt + 1, e);
                std::thread::sleep(std::time::Duration::from_secs(1));
            }
            Err(e) => return Err(e),
        }
    }
    unreachable!()
}
```

### 3. è·¨å¹³å°å…¼å®¹

**âœ… æ¨èåšæ³•**:

```rust
// ä½¿ç”¨æ¡ä»¶ç¼–è¯‘
#[cfg(unix)]
fn get_shell() -> (&'static str, Vec<&'static str>) {
    ("sh", vec!["-c"])
}

#[cfg(windows)]
fn get_shell() -> (&'static str, Vec<&'static str>) {
    ("cmd", vec!["/C"])
}

fn run_command(cmd: &str) -> std::io::Result<()> {
    let (shell, args) = get_shell();
    Command::new(shell)
        .args(&args)
        .arg(cmd)
        .status()?;
    Ok(())
}
```

### 4. æ€§èƒ½ä¼˜åŒ–

**âœ… æ¨èåšæ³•**:

```rust
// å¤ç”¨è¿›ç¨‹ï¼Œé¿å…é¢‘ç¹åˆ›å»º
struct ProcessPool {
    workers: Vec<Child>,
}

impl ProcessPool {
    fn new(size: usize) -> Self {
        let workers = (0..size)
            .map(|_| Command::new("./worker").spawn().unwrap())
            .collect();
        ProcessPool { workers }
    }
}
```

## ğŸ“Š æ¨¡å—ç»Ÿè®¡

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“Š C07 Process - æ¨¡å—ç»Ÿè®¡          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æºä»£ç æ–‡ä»¶:    55 ä¸ª                â”‚
â”‚  æ–‡æ¡£æ–‡ä»¶:      26 ä¸ª (æ ‡å‡†åŒ–å)      â”‚
â”‚  ç¤ºä¾‹ç¨‹åº:      15+ ä¸ª               â”‚
â”‚  æµ‹è¯•ç”¨ä¾‹:      å®Œæ•´è¦†ç›–             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ”¯æŒå¹³å°:      Windows/Linux/macOS  â”‚
â”‚  Rust ç‰ˆæœ¬:     1.92.0+               â”‚
â”‚  è´¨é‡è¯„åˆ†:      95/100               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”— ç›¸å…³èµ„æº

### æœ¬æ¨¡å—

- [ä¸»ç´¢å¼•å¯¼èˆª](./02_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [æœ¯è¯­è¡¨](./03_æœ¯è¯­è¡¨.md)
- [å¸¸è§é—®é¢˜](./04_å¸¸è§é—®é¢˜.md)

### å¤–éƒ¨èµ„æº

- [Rust æ ‡å‡†åº“ std::process](https://doc.rust-lang.org/std/process/)
- [Unix è¿›ç¨‹ç¼–ç¨‹](<https://en.wikipedia.org/wiki/Process_(computing)>)
- [Windows è¿›ç¨‹ç®¡ç†](https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads)

---

**ä¸‹ä¸€æ­¥**: é˜…è¯» [ä¸»ç´¢å¼•å¯¼èˆª](./02_ä¸»ç´¢å¼•å¯¼èˆª.md) è§„åˆ’æ‚¨çš„å­¦ä¹ è·¯å¾„ï¼

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
