# Tier 4: æ€§èƒ½å·¥ç¨‹å®è·µ

> **æ–‡æ¡£ç±»å‹**: é«˜çº§ä¸»é¢˜
> **éš¾åº¦**: â­â­â­â­â­
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **å‰ç½®çŸ¥è¯†**: [æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](../tier_03_references/05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

## ç›®å½•

- [Tier 4: æ€§èƒ½å·¥ç¨‹å®è·µ](#tier-4-æ€§èƒ½å·¥ç¨‹å®è·µ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
  - [1. æ€§èƒ½åˆ†ææ–¹æ³•è®º](#1-æ€§èƒ½åˆ†ææ–¹æ³•è®º)
    - [1.1 æ€§èƒ½æŒ‡æ ‡ä½“ç³»](#11-æ€§èƒ½æŒ‡æ ‡ä½“ç³»)
    - [1.2 åˆ†ææµç¨‹](#12-åˆ†ææµç¨‹)
  - [2. æ€§èƒ½å‰–æå·¥å…·](#2-æ€§èƒ½å‰–æå·¥å…·)
    - [2.1 perfå·¥å…·](#21-perfå·¥å…·)
    - [2.2 Flamegraphå¯è§†åŒ–](#22-flamegraphå¯è§†åŒ–)
    - [2.3 Valgrind/Massif](#23-valgrindmassif)
    - [2.4 strace/ltrace](#24-straceltrace)
    - [2.5 Rustå·¥å…·é“¾](#25-rustå·¥å…·é“¾)
  - [3. çƒ­ç‚¹åˆ†æ](#3-çƒ­ç‚¹åˆ†æ)
    - [3.1 CPUçƒ­ç‚¹è¯†åˆ«](#31-cpuçƒ­ç‚¹è¯†åˆ«)
    - [3.2 å†…å­˜çƒ­ç‚¹](#32-å†…å­˜çƒ­ç‚¹)
    - [3.3 I/Oç“¶é¢ˆè¯Šæ–­](#33-ioç“¶é¢ˆè¯Šæ–­)
  - [4. æ€§èƒ½è°ƒä¼˜ç­–ç•¥](#4-æ€§èƒ½è°ƒä¼˜ç­–ç•¥)
    - [4.1 ç³»ç»Ÿçº§ä¼˜åŒ–](#41-ç³»ç»Ÿçº§ä¼˜åŒ–)
    - [4.2 åº”ç”¨çº§ä¼˜åŒ–](#42-åº”ç”¨çº§ä¼˜åŒ–)
    - [4.3 ç¼–è¯‘å™¨ä¼˜åŒ–](#43-ç¼–è¯‘å™¨ä¼˜åŒ–)
  - [5. é›¶æ‹·è´æŠ€æœ¯](#5-é›¶æ‹·è´æŠ€æœ¯)
    - [5.1 spliceç³»ç»Ÿè°ƒç”¨](#51-spliceç³»ç»Ÿè°ƒç”¨)
    - [5.2 sendfile](#52-sendfile)
    - [5.3 å†…å­˜æ˜ å°„](#53-å†…å­˜æ˜ å°„)
  - [6. ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–](#6-ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–)
    - [6.1 ç›‘æ§ä½“ç³»](#61-ç›‘æ§ä½“ç³»)
    - [6.2 æŒç»­ä¼˜åŒ–æµç¨‹](#62-æŒç»­ä¼˜åŒ–æµç¨‹)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½è¿›ç¨‹æ± ä¼˜åŒ–](#æ¡ˆä¾‹é«˜æ€§èƒ½è¿›ç¨‹æ± ä¼˜åŒ–)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
  - [æ€»ç»“](#æ€»ç»“)
  - [9. é«˜çº§æ€§èƒ½æ¨¡å¼](#9-é«˜çº§æ€§èƒ½æ¨¡å¼)
    - [9.1 è¿›ç¨‹æ± é«˜çº§è®¾è®¡](#91-è¿›ç¨‹æ± é«˜çº§è®¾è®¡)
    - [9.2 Pipelineæ¶æ„ä¼˜åŒ–](#92-pipelineæ¶æ„ä¼˜åŒ–)
    - [9.3 ç¼“å­˜ç­–ç•¥](#93-ç¼“å­˜ç­–ç•¥)
  - [10. å®æ—¶æ€§èƒ½ç›‘æ§](#10-å®æ—¶æ€§èƒ½ç›‘æ§)
    - [10.1 æŒ‡æ ‡æ”¶é›†](#101-æŒ‡æ ‡æ”¶é›†)
    - [10.2 å‘Šè­¦ç³»ç»Ÿ](#102-å‘Šè­¦ç³»ç»Ÿ)
  - [11. æ€§èƒ½è°ƒè¯•æŠ€å·§](#11-æ€§èƒ½è°ƒè¯•æŠ€å·§)
    - [11.1 ç³»ç»Ÿè°ƒç”¨è¿½è¸ª](#111-ç³»ç»Ÿè°ƒç”¨è¿½è¸ª)
    - [11.2 æ€§èƒ½å›å½’æµ‹è¯•](#112-æ€§èƒ½å›å½’æµ‹è¯•)
  - [12. ä¼˜åŒ–æ¸…å•](#12-ä¼˜åŒ–æ¸…å•)
    - [12.1 æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥è¡¨](#121-æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥è¡¨)
    - [12.2 æ€§èƒ½å®¡æŸ¥æµç¨‹](#122-æ€§èƒ½å®¡æŸ¥æµç¨‹)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ€§èƒ½å·¥ç¨‹å®è·µ (Performance Engineering Practice)**:

- **å®šä¹‰**: Rust 1.92.0 æ€§èƒ½å·¥ç¨‹å®è·µï¼ŒåŒ…æ‹¬æ€§èƒ½åˆ†ææ–¹æ³•è®ºã€æ€§èƒ½å‰–æå·¥å…·ã€çƒ­ç‚¹åˆ†æã€æ€§èƒ½è°ƒä¼˜ç­–ç•¥ã€é›¶æ‹·è´æŠ€æœ¯ã€ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–ã€å®æˆ˜æ¡ˆä¾‹ã€æœ€ä½³å®è·µã€é«˜çº§æ€§èƒ½æ¨¡å¼ã€å®æ—¶æ€§èƒ½ç›‘æ§ã€æ€§èƒ½è°ƒè¯•æŠ€å·§ç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: è¿›ç¨‹ç®¡ç†ã€æ€§èƒ½ä¼˜åŒ–
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: æ€§èƒ½åˆ†æã€æ€§èƒ½å‰–æã€çƒ­ç‚¹åˆ†æã€æ€§èƒ½è°ƒä¼˜ã€é›¶æ‹·è´ã€æ€§èƒ½ç›‘æ§

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æ€§èƒ½åˆ†ææ–¹æ³•è®º**: æ€§èƒ½æŒ‡æ ‡ä½“ç³»ã€åˆ†ææµç¨‹
- **æ€§èƒ½å‰–æå·¥å…·**: perf å·¥å…·ã€Flamegraph å¯è§†åŒ–ã€Valgrind/Massifã€strace/ltraceã€Rust å·¥å…·é“¾
- **çƒ­ç‚¹åˆ†æ**: CPU çƒ­ç‚¹è¯†åˆ«ã€å†…å­˜çƒ­ç‚¹ã€I/O ç“¶é¢ˆè¯Šæ–­
- **æ€§èƒ½è°ƒä¼˜ç­–ç•¥**: ç³»ç»Ÿçº§ä¼˜åŒ–ã€åº”ç”¨çº§ä¼˜åŒ–ã€ç¼–è¯‘å™¨ä¼˜åŒ–
- **é›¶æ‹·è´æŠ€æœ¯**: splice ç³»ç»Ÿè°ƒç”¨ã€sendfileã€å†…å­˜æ˜ å°„
- **ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–**: ç›‘æ§ä½“ç³»ã€æŒç»­ä¼˜åŒ–æµç¨‹
- **é«˜çº§æ€§èƒ½æ¨¡å¼**: è¿›ç¨‹æ± é«˜çº§è®¾è®¡ã€Pipeline æ¶æ„ä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥
- **å®æ—¶æ€§èƒ½ç›‘æ§**: æŒ‡æ ‡æ”¶é›†ã€å‘Šè­¦ç³»ç»Ÿ
- **æ€§èƒ½è°ƒè¯•æŠ€å·§**: ç³»ç»Ÿè°ƒç”¨è¿½è¸ªã€æ€§èƒ½å›å½’æµ‹è¯•

**Rust 1.92.0 æ–°ç‰¹æ€§**:

- **æ”¹è¿›çš„æ€§èƒ½åˆ†æ**: æ›´ç²¾ç¡®çš„æ€§èƒ½åˆ†æå·¥å…·
- **å¢å¼ºçš„ SIMD**: æ›´å¥½çš„ SIMD æ”¯æŒ
- **ä¼˜åŒ–çš„æ€§èƒ½**: æ›´é«˜æ•ˆçš„æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½ç‰¹å¾**:

- **é«˜æ€§èƒ½**: æ˜¾è‘—çš„æ€§èƒ½æå‡
- **ä½å»¶è¿Ÿ**: ä¼˜åŒ–çš„å»¶è¿Ÿ
- **é€‚ç”¨åœºæ™¯**: é«˜æ€§èƒ½åº”ç”¨ã€å®æ—¶ç³»ç»Ÿã€æ€§èƒ½å…³é”®åº”ç”¨

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- æ€§èƒ½å·¥ç¨‹å®è·µ --[covers]--> æ€§èƒ½ä¼˜åŒ–å®Œæ•´å†…å®¹
- é«˜æ€§èƒ½åº”ç”¨ --[uses]--> æ€§èƒ½å·¥ç¨‹å®è·µ

**ä¾èµ–å…³ç³»**:

- æ€§èƒ½å·¥ç¨‹å®è·µ --[depends-on]--> è¿›ç¨‹ç®¡ç†
- æ€§èƒ½ä¼˜åŒ– --[depends-on]--> æ€§èƒ½å·¥ç¨‹å®è·µ

### æ€ç»´å¯¼å›¾

```text
æ€§èƒ½å·¥ç¨‹å®è·µ
â”‚
â”œâ”€â”€ æ€§èƒ½åˆ†ææ–¹æ³•è®º
â”‚   â”œâ”€â”€ æ€§èƒ½æŒ‡æ ‡ä½“ç³»
â”‚   â””â”€â”€ åˆ†ææµç¨‹
â”œâ”€â”€ æ€§èƒ½å‰–æå·¥å…·
â”‚   â”œâ”€â”€ perf å·¥å…·
â”‚   â””â”€â”€ Flamegraph
â”œâ”€â”€ çƒ­ç‚¹åˆ†æ
â”‚   â”œâ”€â”€ CPU çƒ­ç‚¹è¯†åˆ«
â”‚   â””â”€â”€ å†…å­˜çƒ­ç‚¹
â”œâ”€â”€ æ€§èƒ½è°ƒä¼˜ç­–ç•¥
â”‚   â”œâ”€â”€ ç³»ç»Ÿçº§ä¼˜åŒ–
â”‚   â””â”€â”€ åº”ç”¨çº§ä¼˜åŒ–
â”œâ”€â”€ é›¶æ‹·è´æŠ€æœ¯
â”‚   â”œâ”€â”€ splice
â”‚   â””â”€â”€ sendfile
â”œâ”€â”€ ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–
â”‚   â””â”€â”€ ç›‘æ§ä½“ç³»
â””â”€â”€ é«˜çº§æ€§èƒ½æ¨¡å¼
    â””â”€â”€ è¿›ç¨‹æ± é«˜çº§è®¾è®¡
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯   | æ€§èƒ½æå‡ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯     | Rust 1.92.0 |
| -------------- | -------- | ------ | ------------ | ----------- |
| **æ€§èƒ½åˆ†æ**   | -        | ä¸­     | æ€§èƒ½è¯Šæ–­     | âœ…          |
| **çƒ­ç‚¹åˆ†æ**   | -        | ä¸­     | æ€§èƒ½ç“¶é¢ˆè¯†åˆ« | âœ…          |
| **ç³»ç»Ÿçº§ä¼˜åŒ–** | ä¸­       | ä¸­     | ç³»ç»Ÿä¼˜åŒ–     | âœ…          |
| **åº”ç”¨çº§ä¼˜åŒ–** | é«˜       | ä¸­     | åº”ç”¨ä¼˜åŒ–     | âœ…          |
| **é›¶æ‹·è´**     | æœ€é«˜     | é«˜     | I/O ä¼˜åŒ–     | âœ…          |
| **SIMD**       | æœ€é«˜     | é«˜     | æ•°å€¼è®¡ç®—     | âœ… å¢å¼º     |
| **ç¼“å­˜ç­–ç•¥**   | é«˜       | ä¸­     | ç¼“å­˜ä¼˜åŒ–     | âœ…          |

### å†³ç­–æ ‘å›¾

```text
æ€§èƒ½ä¼˜åŒ–æµç¨‹
â”‚
â”œâ”€â”€ æ€§èƒ½åˆ†æé˜¶æ®µ
â”‚   â””â”€â”€ æ€§èƒ½å‰–æå·¥å…· â†’ perf / Flamegraph
â”œâ”€â”€ çƒ­ç‚¹è¯†åˆ«é˜¶æ®µ
â”‚   â””â”€â”€ çƒ­ç‚¹åˆ†æ â†’ CPU / å†…å­˜ / I/O çƒ­ç‚¹
â”œâ”€â”€ ä¼˜åŒ–å®æ–½é˜¶æ®µ
â”‚   â”œâ”€â”€ ç³»ç»Ÿçº§ä¼˜åŒ– â†’ ç³»ç»Ÿè°ƒä¼˜
â”‚   â”œâ”€â”€ åº”ç”¨çº§ä¼˜åŒ– â†’ åº”ç”¨è°ƒä¼˜
â”‚   â””â”€â”€ é›¶æ‹·è´ â†’ splice / sendfile
â””â”€â”€ éªŒè¯é˜¶æ®µ
    â””â”€â”€ æ€§èƒ½ç›‘æ§ â†’ æŒ‡æ ‡æ”¶é›† / å‘Šè­¦ç³»ç»Ÿ
```

---

## 1. æ€§èƒ½åˆ†ææ–¹æ³•è®º

### 1.1 æ€§èƒ½æŒ‡æ ‡ä½“ç³»

**æ ¸å¿ƒæŒ‡æ ‡**:

```rust
pub struct PerformanceMetrics {
    // å»¶è¿ŸæŒ‡æ ‡
    pub p50_latency: Duration,
    pub p99_latency: Duration,
    pub p999_latency: Duration,

    // ååé‡æŒ‡æ ‡
    pub throughput: f64,  // requests/second
    pub qps: u64,         // queries per second

    // èµ„æºåˆ©ç”¨ç‡
    pub cpu_usage: f32,      // 0-100%
    pub memory_usage: u64,   // bytes
    pub io_wait: f32,        // 0-100%
}

impl PerformanceMetrics {
    pub fn is_acceptable(&self, baseline: &PerformanceBaseline) -> bool {
        self.p99_latency <= baseline.max_p99_latency &&
        self.throughput >= baseline.min_throughput &&
        self.cpu_usage <= baseline.max_cpu_usage
    }
}
```

### 1.2 åˆ†ææµç¨‹

**ç³»ç»ŸåŒ–æ€§èƒ½åˆ†æ**:

```rust
pub struct PerformanceAnalyzer {
    baseline: PerformanceBaseline,
    profiler: Box<dyn Profiler>,
}

impl PerformanceAnalyzer {
    pub fn analyze(&mut self) -> AnalysisReport {
        // 1. æµ‹é‡
        let metrics = self.measure();

        // 2. å¯¹æ¯”åŸºçº¿
        let regression = self.detect_regression(&metrics);

        // 3. è¯†åˆ«ç“¶é¢ˆ
        let bottlenecks = self.identify_bottlenecks(&metrics);

        // 4. ç”ŸæˆæŠ¥å‘Š
        AnalysisReport {
            metrics,
            regression,
            bottlenecks,
            recommendations: self.generate_recommendations(&bottlenecks),
        }
    }

    fn measure(&self) -> PerformanceMetrics {
        // è¿è¡ŒåŸºå‡†æµ‹è¯•
        let start = Instant::now();
        let samples: Vec<Duration> = (0..1000)
            .map(|_| {
                let start = Instant::now();
                // æ‰§è¡Œæµ‹è¯•
                self.run_test();
                start.elapsed()
            })
            .collect();

        self.calculate_percentiles(samples)
    }

    fn calculate_percentiles(&self, mut samples: Vec<Duration>) -> PerformanceMetrics {
        samples.sort();
        let len = samples.len();

        PerformanceMetrics {
            p50_latency: samples[len / 2],
            p99_latency: samples[len * 99 / 100],
            p999_latency: samples[len * 999 / 1000],
            throughput: 1000.0 / samples.iter().sum::<Duration>().as_secs_f64(),
            ..Default::default()
        }
    }
}
```

---

## 2. æ€§èƒ½å‰–æå·¥å…·

### 2.1 perfå·¥å…·

**Linux perf profiling**:

```bash
# è®°å½•è¿›ç¨‹æ€§èƒ½æ•°æ®
perf record -F 99 -p <PID> -g -- sleep 30

# ç”ŸæˆæŠ¥å‘Š
perf report --stdio

# CPUé‡‡æ ·
perf stat -p <PID> -- sleep 30
```

**Rusté›†æˆ**:

```rust
use std::process::Command;

pub fn profile_with_perf(pid: u32, duration: u64) -> std::io::Result<String> {
    // å¯åŠ¨perfè®°å½•
    let output = Command::new("perf")
        .args(&["record", "-F", "99", "-p", &pid.to_string(), "-g"])
        .args(&["--", "sleep", &duration.to_string()])
        .output()?;

    // ç”ŸæˆæŠ¥å‘Š
    let report = Command::new("perf")
        .args(&["report", "--stdio"])
        .output()?;

    Ok(String::from_utf8_lossy(&report.stdout).to_string())
}
```

### 2.2 Flamegraphå¯è§†åŒ–

**ç”Ÿæˆç«ç„°å›¾**:

```rust
// Cargo.toml
// [dependencies]
// inferno = "0.11"

use inferno::flamegraph::{from_reader, Options};
use std::fs::File;
use std::io::BufReader;

pub fn generate_flamegraph(
    perf_data: &str,
    output: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let file = File::open(perf_data)?;
    let reader = BufReader::new(file);

    let mut output_file = File::create(output)?;

    let mut options = Options::default();
    from_reader(&mut options, reader, &mut output_file)?;

    Ok(())
}
```

**ä½¿ç”¨cargo-flamegraph**:

```bash
# å®‰è£…
cargo install flamegraph

# ç”Ÿæˆç«ç„°å›¾
cargo flamegraph --bin my_process_manager

# è¾“å‡º: flamegraph.svg
```

### 2.3 Valgrind/Massif

**å†…å­˜åˆ†æ**:

```bash
# Massifå†…å­˜profiling
valgrind --tool=massif --massif-out-file=massif.out ./my_binary

# å¯è§†åŒ–
ms_print massif.out > massif.txt
```

**Rusté›†æˆ**:

```rust
pub fn run_with_valgrind(binary: &str) -> std::io::Result<String> {
    let output = Command::new("valgrind")
        .args(&["--tool=massif", "--massif-out-file=massif.out"])
        .arg(binary)
        .output()?;

    // è§£æmassifè¾“å‡º
    let report = Command::new("ms_print")
        .arg("massif.out")
        .output()?;

    Ok(String::from_utf8_lossy(&report.stdout).to_string())
}
```

### 2.4 strace/ltrace

**ç³»ç»Ÿè°ƒç”¨è¿½è¸ª**:

```bash
# straceè¿½è¸ªç³»ç»Ÿè°ƒç”¨
strace -c -p <PID>  # ç»Ÿè®¡
strace -tt -T -p <PID>  # è¯¦ç»†æ—¶é—´

# ltraceè¿½è¸ªåº“è°ƒç”¨
ltrace -c -p <PID>
```

### 2.5 Rustå·¥å…·é“¾

**pprofé›†æˆ**:

```rust
// Cargo.toml
// [dependencies]
// pprof = { version = "0.13", features = ["flamegraph"] }

use pprof::ProfilerGuard;

pub fn profile_section<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    let guard = pprof::ProfilerGuard::new(100).unwrap();

    let result = f();

    if let Ok(report) = guard.report().build() {
        let file = std::fs::File::create("flamegraph.svg").unwrap();
        report.flamegraph(file).unwrap();
    }

    result
}
```

---

## 3. çƒ­ç‚¹åˆ†æ

### 3.1 CPUçƒ­ç‚¹è¯†åˆ«

**é‡‡æ ·åˆ†æ**:

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;

pub struct CpuProfiler {
    samples: HashMap<String, Vec<Duration>>,
}

impl CpuProfiler {
    pub fn profile<F>(&mut self, name: &str, f: F)
    where
        F: FnOnce(),
    {
        let start = Instant::now();
        f();
        let elapsed = start.elapsed();

        self.samples.entry(name.to_string())
            .or_insert_with(Vec::new)
            .push(elapsed);
    }

    pub fn report(&self) -> Vec<(String, Duration, f64)> {
        let total: Duration = self.samples.values()
            .flatten()
            .sum();

        let mut results: Vec<_> = self.samples.iter()
            .map(|(name, samples)| {
                let sum: Duration = samples.iter().sum();
                let percent = sum.as_secs_f64() / total.as_secs_f64() * 100.0;
                (name.clone(), sum, percent)
            })
            .collect();

        results.sort_by(|a, b| b.1.cmp(&a.1));
        results
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut profiler = CpuProfiler::new();

    profiler.profile("spawn_process", || {
        std::process::Command::new("echo").spawn().unwrap();
    });

    profiler.profile("wait_process", || {
        std::thread::sleep(Duration::from_millis(10));
    });

    for (name, duration, percent) in profiler.report() {
        println!("{}: {:?} ({:.2}%)", name, duration, percent);
    }
}
```

### 3.2 å†…å­˜çƒ­ç‚¹

**å†…å­˜è·Ÿè¸ª**:

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct TrackingAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for TrackingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ret = System.alloc(layout);
        if !ret.is_null() {
            ALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
        }
        ret
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        ALLOCATED.fetch_sub(layout.size(), Ordering::SeqCst);
    }
}

#[global_allocator]
static GLOBAL: TrackingAllocator = TrackingAllocator;

pub fn current_memory_usage() -> usize {
    ALLOCATED.load(Ordering::SeqCst)
}
```

### 3.3 I/Oç“¶é¢ˆè¯Šæ–­

**I/Oç›‘æ§**:

```rust
use std::fs::File;
use std::io::{Read, Write};
use std::time::Instant;

pub struct IoMonitor {
    read_bytes: u64,
    write_bytes: u64,
    read_time: Duration,
    write_time: Duration,
}

impl IoMonitor {
    pub fn monitored_read<R: Read>(&mut self, reader: &mut R, buf: &mut [u8])
        -> std::io::Result<usize>
    {
        let start = Instant::now();
        let n = reader.read(buf)?;
        self.read_time += start.elapsed();
        self.read_bytes += n as u64;
        Ok(n)
    }

    pub fn monitored_write<W: Write>(&mut self, writer: &mut W, buf: &[u8])
        -> std::io::Result<usize>
    {
        let start = Instant::now();
        let n = writer.write(buf)?;
        self.write_time += start.elapsed();
        self.write_bytes += n as u64;
        Ok(n)
    }

    pub fn report(&self) {
        println!("I/O Statistics:");
        println!("  Read: {} bytes in {:?} ({:.2} MB/s)",
            self.read_bytes,
            self.read_time,
            self.read_bytes as f64 / self.read_time.as_secs_f64() / 1_000_000.0
        );
        println!("  Write: {} bytes in {:?} ({:.2} MB/s)",
            self.write_bytes,
            self.write_time,
            self.write_bytes as f64 / self.write_time.as_secs_f64() / 1_000_000.0
        );
    }
}
```

---

## 4. æ€§èƒ½è°ƒä¼˜ç­–ç•¥

### 4.1 ç³»ç»Ÿçº§ä¼˜åŒ–

**å†…æ ¸å‚æ•°è°ƒæ•´**:

```rust
use std::fs;

pub fn optimize_kernel_params() -> std::io::Result<()> {
    // å¢åŠ æ–‡ä»¶æè¿°ç¬¦é™åˆ¶
    fs::write("/proc/sys/fs/file-max", "1000000")?;

    // TCPä¼˜åŒ–
    fs::write("/proc/sys/net/ipv4/tcp_fin_timeout", "30")?;
    fs::write("/proc/sys/net/ipv4/tcp_tw_reuse", "1")?;

    // è¿›ç¨‹ä¼˜åŒ–
    fs::write("/proc/sys/kernel/pid_max", "4194304")?;

    Ok(())
}
```

### 4.2 åº”ç”¨çº§ä¼˜åŒ–

**å¯¹è±¡æ± **:

```rust
use std::collections::VecDeque;
use std::sync::Mutex;

pub struct ObjectPool<T> {
    objects: Mutex<VecDeque<T>>,
    factory: Box<dyn Fn() -> T + Send + Sync>,
}

impl<T> ObjectPool<T> {
    pub fn new<F>(size: usize, factory: F) -> Self
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let objects = (0..size).map(|_| factory()).collect();

        Self {
            objects: Mutex::new(objects),
            factory: Box::new(factory),
        }
    }

    pub fn acquire(&self) -> PooledObject<T> {
        let mut pool = self.objects.lock().unwrap();
        let obj = pool.pop_front()
            .unwrap_or_else(|| (self.factory)());

        PooledObject {
            obj: Some(obj),
            pool: &self.objects,
        }
    }
}

pub struct PooledObject<'a, T> {
    obj: Option<T>,
    pool: &'a Mutex<VecDeque<T>>,
}

impl<'a, T> Drop for PooledObject<'a, T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.lock().unwrap().push_back(obj);
        }
    }
}

impl<'a, T> std::ops::Deref for PooledObject<'a, T> {
    type Target = T;

    fn deref(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
}
```

### 4.3 ç¼–è¯‘å™¨ä¼˜åŒ–

**LTOï¼ˆLink-Time Optimizationï¼‰**:

```toml
# Cargo.toml
[profile.release]
lto = true
codegen-units = 1
opt-level = 3
```

**PGOï¼ˆProfile-Guided Optimizationï¼‰**:

```bash
# 1. æ„å»ºinstrumentedç‰ˆæœ¬
RUSTFLAGS="-Cprofile-generate=/tmp/pgo-data" cargo build --release

# 2. è¿è¡Œç”Ÿæˆprofile
./target/release/my_binary

# 3. ä½¿ç”¨profileé‡æ–°ç¼–è¯‘
RUSTFLAGS="-Cprofile-use=/tmp/pgo-data" cargo build --release
```

---

## 5. é›¶æ‹·è´æŠ€æœ¯

### 5.1 spliceç³»ç»Ÿè°ƒç”¨

**Linux splice**:

```rust
#[cfg(target_os = "linux")]
use nix::fcntl::{splice, SpliceFFlags};
use std::os::unix::io::RawFd;

#[cfg(target_os = "linux")]
pub fn zero_copy_transfer(
    input_fd: RawFd,
    output_fd: RawFd,
    len: usize,
) -> nix::Result<usize> {
    splice(
        input_fd,
        None,
        output_fd,
        None,
        len,
        SpliceFFlags::empty()
    )
}

#[cfg(target_os = "linux")]
pub fn pipe_to_pipe(
    in_pipe: RawFd,
    out_pipe: RawFd,
    len: usize,
) -> nix::Result<usize> {
    splice(
        in_pipe,
        None,
        out_pipe,
        None,
        len,
        SpliceFFlags::SPLICE_F_MOVE
    )
}
```

### 5.2 sendfile

**sendfileç³»ç»Ÿè°ƒç”¨**:

```rust
#[cfg(unix)]
use nix::sys::sendfile::sendfile;

#[cfg(unix)]
pub fn send_file(
    out_fd: RawFd,
    in_fd: RawFd,
    offset: Option<&mut libc::off_t>,
    count: usize,
) -> nix::Result<usize> {
    sendfile(out_fd, in_fd, offset, count)
}
```

### 5.3 å†…å­˜æ˜ å°„

**mmapä¼˜åŒ–**:

```rust
use memmap2::{Mmap, MmapMut, MmapOptions};
use std::fs::File;

pub struct MmapBuffer {
    mmap: Mmap,
}

impl MmapBuffer {
    pub fn from_file(path: &str) -> std::io::Result<Self> {
        let file = File::open(path)?;
        let mmap = unsafe { Mmap::map(&file)? };
        Ok(Self { mmap })
    }

    pub fn as_slice(&self) -> &[u8] {
        &self.mmap
    }
}

pub struct MmapWriter {
    mmap: MmapMut,
}

impl MmapWriter {
    pub fn create(path: &str, len: usize) -> std::io::Result<Self> {
        let file = File::create(path)?;
        file.set_len(len as u64)?;

        let mmap = unsafe { MmapMut::map_mut(&file)? };
        Ok(Self { mmap })
    }

    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.mmap
    }

    pub fn flush(&self) -> std::io::Result<()> {
        self.mmap.flush()
    }
}
```

---

## 6. ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–

### 6.1 ç›‘æ§ä½“ç³»

**Prometheusé›†æˆ**:

```rust
use prometheus::{IntCounter, IntGauge, Histogram, Registry};

pub struct ProcessMetrics {
    spawned_total: IntCounter,
    active_processes: IntGauge,
    spawn_duration: Histogram,
    registry: Registry,
}

impl ProcessMetrics {
    pub fn new() -> Self {
        let registry = Registry::new();

        let spawned_total = IntCounter::new(
            "process_spawned_total",
            "Total processes spawned"
        ).unwrap();

        let active_processes = IntGauge::new(
            "process_active",
            "Currently active processes"
        ).unwrap();

        let spawn_duration = Histogram::with_opts(
            prometheus::HistogramOpts::new(
                "process_spawn_duration_seconds",
                "Process spawn duration"
            ).buckets(vec![0.001, 0.01, 0.1, 1.0, 10.0])
        ).unwrap();

        registry.register(Box::new(spawned_total.clone())).unwrap();
        registry.register(Box::new(active_processes.clone())).unwrap();
        registry.register(Box::new(spawn_duration.clone())).unwrap();

        Self {
            spawned_total,
            active_processes,
            spawn_duration,
            registry,
        }
    }

    pub fn record_spawn(&self, duration: Duration) {
        self.spawned_total.inc();
        self.active_processes.inc();
        self.spawn_duration.observe(duration.as_secs_f64());
    }

    pub fn record_exit(&self) {
        self.active_processes.dec();
    }
}
```

### 6.2 æŒç»­ä¼˜åŒ–æµç¨‹

**è‡ªåŠ¨åŒ–æ€§èƒ½å›å½’æ£€æµ‹**:

```rust
pub struct PerformanceRegression {
    baseline: PerformanceMetrics,
    threshold: f64,  // å…è®¸çš„æ€§èƒ½ä¸‹é™ç™¾åˆ†æ¯”
}

impl PerformanceRegression {
    pub fn check(&self, current: &PerformanceMetrics) -> RegressionReport {
        let mut issues = Vec::new();

        // æ£€æŸ¥å»¶è¿Ÿå›å½’
        if current.p99_latency > self.baseline.p99_latency * (1.0 + self.threshold) {
            issues.push(format!(
                "P99å»¶è¿Ÿå›å½’: {:?} -> {:?}",
                self.baseline.p99_latency,
                current.p99_latency
            ));
        }

        // æ£€æŸ¥ååé‡å›å½’
        if current.throughput < self.baseline.throughput * (1.0 - self.threshold) {
            issues.push(format!(
                "ååé‡ä¸‹é™: {:.2} -> {:.2}",
                self.baseline.throughput,
                current.throughput
            ));
        }

        RegressionReport {
            has_regression: !issues.is_empty(),
            issues,
        }
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½è¿›ç¨‹æ± ä¼˜åŒ–

**ä¼˜åŒ–å‰**ï¼ˆç®€å•ç‰ˆæœ¬ï¼‰:

```rust
// åŸºç¡€ç‰ˆæœ¬ï¼šæ¯æ¬¡åˆ›å»ºæ–°è¿›ç¨‹
pub fn process_tasks_naive(tasks: Vec<Task>) {
    for task in tasks {
        let child = Command::new("worker")
            .arg(&task.data)
            .spawn()
            .unwrap();
        child.wait().unwrap();
    }
}
// æ€§èƒ½ï¼š~100 tasks/s
```

**ä¼˜åŒ–å**ï¼ˆè¿›ç¨‹æ±  + æ‰¹å¤„ç†ï¼‰:

```rust
pub struct OptimizedProcessPool {
    workers: Vec<Worker>,
    task_queue: crossbeam::channel::Sender<Task>,
}

impl OptimizedProcessPool {
    pub fn new(size: usize) -> Self {
        let (tx, rx) = crossbeam::channel::unbounded();

        let workers: Vec<_> = (0..size)
            .map(|_| Worker::new(rx.clone()))
            .collect();

        Self {
            workers,
            task_queue: tx,
        }
    }

    pub fn submit(&self, task: Task) {
        self.task_queue.send(task).unwrap();
    }
}

struct Worker {
    child: Child,
}

impl Worker {
    fn new(rx: crossbeam::channel::Receiver<Task>) -> Self {
        let mut child = Command::new("worker").spawn().unwrap();

        std::thread::spawn(move || {
            while let Ok(task) = rx.recv() {
                // é€šè¿‡stdinå‘é€ä»»åŠ¡
                // é€šè¿‡stdoutæ¥æ”¶ç»“æœ
            }
        });

        Self { child }
    }
}

// æ€§èƒ½æå‡ï¼š~100 tasks/s -> ~5,000 tasks/s (50x)
```

**å…³é”®ä¼˜åŒ–ç‚¹**:

1. âœ… è¿›ç¨‹å¤ç”¨ï¼ˆé¿å…é¢‘ç¹spawnï¼‰
2. âœ… æ‰¹å¤„ç†ï¼ˆå‡å°‘ç³»ç»Ÿè°ƒç”¨ï¼‰
3. âœ… ç®¡é“é€šä¿¡ï¼ˆé¿å…æ–‡ä»¶I/Oï¼‰
4. âœ… å¼‚æ­¥å¤„ç†ï¼ˆæé«˜å¹¶å‘ï¼‰

---

## 8. æœ€ä½³å®è·µ

**1. æµ‹é‡ä¼˜å…ˆ**:

```rust
// âœ… å…ˆæµ‹é‡ï¼Œå†ä¼˜åŒ–
let start = Instant::now();
expensive_operation();
println!("è€—æ—¶: {:?}", start.elapsed());
```

**2. é¿å…è¿‡æ—©ä¼˜åŒ–**:

- âœ… å…ˆç¡®ä¿æ­£ç¡®æ€§
- âœ… å†å…³æ³¨æ€§èƒ½
- âœ… åªä¼˜åŒ–çƒ­ç‚¹ä»£ç 

**3. ä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„**:

```rust
// âŒ é¿å…ï¼šé¢‘ç¹çš„Vecæ’å…¥åˆ é™¤
let mut vec = Vec::new();
for i in 0..1000 {
    vec.insert(0, i);  // O(n) æ¯æ¬¡
}

// âœ… æ¨èï¼šä½¿ç”¨VecDeque
let mut deque = VecDeque::new();
for i in 0..1000 {
    deque.push_front(i);  // O(1) æ¯æ¬¡
}
```

**4. æ‰¹é‡å¤„ç†**:

```rust
// âŒ é¿å…ï¼šé€ä¸ªå¤„ç†
for item in items {
    process(item);  // æ¯æ¬¡éƒ½æœ‰å¼€é”€
}

// âœ… æ¨èï¼šæ‰¹é‡å¤„ç†
for chunk in items.chunks(100) {
    process_batch(chunk);  // å‡å°‘å¼€é”€
}
```

**5. ç›‘æ§ç”Ÿäº§ç¯å¢ƒ**:

- âœ… æŒç»­ç›‘æ§å…³é”®æŒ‡æ ‡
- âœ… è®¾ç½®æ€§èƒ½å‘Šè­¦
- âœ… å®šæœŸæ€§èƒ½å®¡æŸ¥

---

## æ€»ç»“

**æ€§èƒ½å·¥ç¨‹æ ¸å¿ƒè¦ç´ **:

1. âœ… **æ–¹æ³•è®º**: æµ‹é‡â†’åˆ†æâ†’ä¼˜åŒ–â†’éªŒè¯
2. âœ… **å·¥å…·é“¾**: perf/flamegraph/valgrind/strace
3. âœ… **çƒ­ç‚¹åˆ†æ**: CPU/å†…å­˜/I/Oç“¶é¢ˆè¯†åˆ«
4. âœ… **ä¼˜åŒ–ç­–ç•¥**: ç³»ç»Ÿçº§/åº”ç”¨çº§/ç¼–è¯‘å™¨ä¼˜åŒ–
5. âœ… **é›¶æ‹·è´**: splice/sendfile/mmap
6. âœ… **ç”Ÿäº§ç¯å¢ƒ**: ç›‘æ§/æŒç»­ä¼˜åŒ–

**æ€§èƒ½æå‡è·¯å¾„**:

- **Level 1**: åŸºç¡€ä¼˜åŒ–ï¼ˆç®—æ³•/æ•°æ®ç»“æ„ï¼‰â†’ 2-5x
- **Level 2**: ç³»ç»Ÿä¼˜åŒ–ï¼ˆè¿›ç¨‹æ± /ç¼“å­˜ï¼‰â†’ 5-20x
- **Level 3**: åº•å±‚ä¼˜åŒ–ï¼ˆé›¶æ‹·è´/å¼‚æ­¥ï¼‰â†’ 20-100x

---

## 9. é«˜çº§æ€§èƒ½æ¨¡å¼

### 9.1 è¿›ç¨‹æ± é«˜çº§è®¾è®¡

**è‡ªé€‚åº”è¿›ç¨‹æ± **:

```rust
use std::sync::Arc;
use tokio::sync::{Semaphore, RwLock};
use sysinfo::{System, SystemExt};

pub struct AdaptiveProcessPool {
    min_workers: usize,
    max_workers: usize,
    current_workers: Arc<RwLock<Vec<Worker>>>,
    semaphore: Arc<Semaphore>,
    system: Arc<RwLock<System>>,
}

impl AdaptiveProcessPool {
    pub fn new(min_workers: usize, max_workers: usize) -> Self {
        let workers = (0..min_workers)
            .map(|_| Worker::spawn())
            .collect();

        Self {
            min_workers,
            max_workers,
            current_workers: Arc::new(RwLock::new(workers)),
            semaphore: Arc::new(Semaphore::new(max_workers)),
            system: Arc::new(RwLock::new(System::new_all())),
        }
    }

    pub async fn execute<F, T>(&self, f: F) -> Result<T, Error>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        // 1. è·å–è®¸å¯
        let _permit = self.semaphore.acquire().await?;

        // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        self.scale_if_needed().await;

        // 3. é€‰æ‹©æœ€ä¼˜worker
        let worker = self.select_best_worker().await?;

        // 4. æ‰§è¡Œä»»åŠ¡
        worker.execute(f).await
    }

    async fn scale_if_needed(&self) {
        let mut system = self.system.write().await;
        system.refresh_cpu();

        let cpu_usage = system.global_cpu_info().cpu_usage();
        let mut workers = self.current_workers.write().await;

        // CPUä½¿ç”¨ç‡é«˜ä¸”æœªè¾¾ä¸Šé™ï¼šæ‰©å®¹
        if cpu_usage > 80.0 && workers.len() < self.max_workers {
            println!("æ‰©å®¹: CPU {}%, æ–°å¢worker", cpu_usage);
            workers.push(Worker::spawn());
        }
        // CPUä½¿ç”¨ç‡ä½ä¸”è¶…è¿‡æœ€å°å€¼ï¼šç¼©å®¹
        else if cpu_usage < 20.0 && workers.len() > self.min_workers {
            println!("ç¼©å®¹: CPU {}%, ç§»é™¤worker", cpu_usage);
            if let Some(worker) = workers.pop() {
                worker.shutdown().await;
            }
        }
    }

    async fn select_best_worker(&self) -> Result<Worker, Error> {
        let workers = self.current_workers.read().await;

        // é€‰æ‹©è´Ÿè½½æœ€ä½çš„worker
        workers.iter()
            .min_by_key(|w| w.queue_size())
            .cloned()
            .ok_or(Error::NoWorkerAvailable)
    }
}

#[derive(Clone)]
struct Worker {
    id: usize,
    queue_size: Arc<AtomicUsize>,
    // ... å…¶ä»–å­—æ®µ
}

impl Worker {
    fn spawn() -> Self {
        // å®ç°worker spawné€»è¾‘
        Self {
            id: rand::random(),
            queue_size: Arc::new(AtomicUsize::new(0)),
        }
    }

    fn queue_size(&self) -> usize {
        self.queue_size.load(Ordering::Relaxed)
    }

    async fn execute<F, T>(&self, f: F) -> Result<T, Error>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        self.queue_size.fetch_add(1, Ordering::Relaxed);

        // æ‰§è¡Œä»»åŠ¡
        let result = tokio::task::spawn_blocking(f).await?;

        self.queue_size.fetch_sub(1, Ordering::Relaxed);

        Ok(result)
    }

    async fn shutdown(self) {
        // ä¼˜é›…å…³é—­worker
    }
}
```

### 9.2 Pipelineæ¶æ„ä¼˜åŒ–

**æµå¼Pipelineå¤„ç†**:

```rust
use tokio::sync::mpsc;
use futures::StreamExt;

pub struct ProcessPipeline {
    stages: Vec<Stage>,
    buffer_size: usize,
}

impl ProcessPipeline {
    pub fn builder() -> PipelineBuilder {
        PipelineBuilder::new()
    }

    pub async fn process<I>(&self, input: I) -> Result<Vec<Output>, Error>
    where
        I: IntoIterator<Item = Input>,
    {
        let (input_tx, mut input_rx) = mpsc::channel(self.buffer_size);

        // å¯åŠ¨æ‰€æœ‰stage
        let mut stage_channels = Vec::new();
        for stage in &self.stages {
            let (tx, rx) = mpsc::channel(self.buffer_size);
            stage_channels.push((tx, rx));
        }

        // Stage 1: è¾“å…¥å¤„ç†
        let stage1_tx = stage_channels[0].0.clone();
        tokio::spawn(async move {
            while let Some(item) = input_rx.recv().await {
                let processed = process_stage1(item).await;
                stage1_tx.send(processed).await.ok();
            }
        });

        // Stage 2-N: ä¸­é—´å¤„ç†
        for i in 1..self.stages.len() {
            let mut prev_rx = stage_channels[i-1].1.clone();
            let next_tx = stage_channels[i].0.clone();

            tokio::spawn(async move {
                while let Some(item) = prev_rx.recv().await {
                    let processed = process_stage(item, i).await;
                    next_tx.send(processed).await.ok();
                }
            });
        }

        // æ”¶é›†è¾“å‡º
        let mut final_rx = stage_channels.last().unwrap().1.clone();
        let mut results = Vec::new();

        // å‘é€æ‰€æœ‰è¾“å…¥
        for item in input {
            input_tx.send(item).await?;
        }
        drop(input_tx);

        // æ”¶é›†æ‰€æœ‰è¾“å‡º
        while let Some(output) = final_rx.recv().await {
            results.push(output);
        }

        Ok(results)
    }
}

async fn process_stage1(input: Input) -> StageOutput {
    // Stage 1å¤„ç†é€»è¾‘
    StageOutput::default()
}

async fn process_stage(input: StageOutput, stage: usize) -> StageOutput {
    // Stage Nå¤„ç†é€»è¾‘
    StageOutput::default()
}

// æ€§èƒ½ä¼˜åŠ¿ï¼š
// - å¹¶è¡Œå¤„ç†å¤šä¸ªstage
// - æµå¼å¤„ç†ï¼Œæ— éœ€ç­‰å¾…å…¨éƒ¨è¾“å…¥
// - èƒŒå‹æ§åˆ¶ï¼Œé¿å…å†…å­˜æº¢å‡º
```

### 9.3 ç¼“å­˜ç­–ç•¥

**å¤šçº§ç¼“å­˜ç³»ç»Ÿ**:

```rust
use lru::LruCache;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct TieredCache<K, V> {
    l1_cache: Arc<Mutex<LruCache<K, V>>>,      // å†…å­˜ç¼“å­˜ (å¿«)
    l2_cache: Arc<Mutex<LruCache<K, V>>>,      // å…±äº«å†…å­˜ (ä¸­)
    l3_cache: Box<dyn ExternalCache<K, V>>,    // å¤–éƒ¨ç¼“å­˜ (æ…¢)
}

impl<K, V> TieredCache<K, V>
where
    K: Clone + Eq + Hash,
    V: Clone,
{
    pub async fn get(&self, key: &K) -> Option<V> {
        // L1: å†…å­˜ç¼“å­˜
        if let Some(value) = self.l1_cache.lock().await.get(key) {
            return Some(value.clone());
        }

        // L2: å…±äº«å†…å­˜
        if let Some(value) = self.l2_cache.lock().await.get(key) {
            // æå‡åˆ°L1
            self.l1_cache.lock().await.put(key.clone(), value.clone());
            return Some(value);
        }

        // L3: å¤–éƒ¨ç¼“å­˜ï¼ˆRedis/Memcachedï¼‰
        if let Some(value) = self.l3_cache.get(key).await {
            // æå‡åˆ°L1å’ŒL2
            self.l1_cache.lock().await.put(key.clone(), value.clone());
            self.l2_cache.lock().await.put(key.clone(), value.clone());
            return Some(value);
        }

        None
    }

    pub async fn put(&self, key: K, value: V) {
        // åŒæ—¶å†™å…¥æ‰€æœ‰å±‚çº§
        self.l1_cache.lock().await.put(key.clone(), value.clone());
        self.l2_cache.lock().await.put(key.clone(), value.clone());
        self.l3_cache.put(key, value).await;
    }
}

// æ€§èƒ½æå‡ï¼š
// - L1å‘½ä¸­: ~10ns
// - L2å‘½ä¸­: ~100ns
// - L3å‘½ä¸­: ~1ms
// - ç¼“å­˜æœªå‘½ä¸­: ~10-100ms
```

---

## 10. å®æ—¶æ€§èƒ½ç›‘æ§

### 10.1 æŒ‡æ ‡æ”¶é›†

**å®Œæ•´ç›‘æ§ç³»ç»Ÿ**:

```rust
use prometheus::{
    Counter, Histogram, Gauge, Registry,
    HistogramOpts, Opts,
};
use std::time::Instant;

pub struct ProcessMonitor {
    // è®¡æ•°å™¨
    spawns_total: Counter,
    failures_total: Counter,

    // ç›´æ–¹å›¾
    spawn_duration: Histogram,
    execution_duration: Histogram,

    // ä»ªè¡¨
    active_processes: Gauge,
    memory_usage: Gauge,
    cpu_usage: Gauge,
}

impl ProcessMonitor {
    pub fn new(registry: &Registry) -> Self {
        let spawns_total = Counter::with_opts(
            Opts::new("process_spawns_total", "Total process spawns")
        ).unwrap();

        let spawn_duration = Histogram::with_opts(
            HistogramOpts::new(
                "process_spawn_duration_seconds",
                "Process spawn duration"
            ).buckets(vec![0.001, 0.01, 0.1, 1.0, 10.0])
        ).unwrap();

        let active_processes = Gauge::with_opts(
            Opts::new("process_active", "Active processes")
        ).unwrap();

        registry.register(Box::new(spawns_total.clone())).unwrap();
        registry.register(Box::new(spawn_duration.clone())).unwrap();
        registry.register(Box::new(active_processes.clone())).unwrap();

        Self {
            spawns_total,
            failures_total: Counter::new("failures", "").unwrap(),
            spawn_duration,
            execution_duration: Histogram::new().unwrap(),
            active_processes,
            memory_usage: Gauge::new("memory", "").unwrap(),
            cpu_usage: Gauge::new("cpu", "").unwrap(),
        }
    }

    pub async fn spawn_monitored<F, T>(
        &self,
        f: F
    ) -> Result<T, Error>
    where
        F: FnOnce() -> T,
    {
        self.spawns_total.inc();
        self.active_processes.inc();

        let start = Instant::now();

        let result = match std::panic::catch_unwind(std::panic::AssertUnwindSafe(f)) {
            Ok(value) => Ok(value),
            Err(_) => {
                self.failures_total.inc();
                Err(Error::Panicked)
            }
        };

        self.spawn_duration.observe(start.elapsed().as_secs_f64());
        self.active_processes.dec();

        result
    }

    pub async fn collect_system_metrics(&self) {
        let mut system = sysinfo::System::new_all();
        system.refresh_all();

        // CPUä½¿ç”¨ç‡
        self.cpu_usage.set(system.global_cpu_info().cpu_usage() as f64);

        // å†…å­˜ä½¿ç”¨
        let used_memory = system.used_memory();
        self.memory_usage.set(used_memory as f64);
    }
}
```

### 10.2 å‘Šè­¦ç³»ç»Ÿ

**è‡ªåŠ¨åŒ–å‘Šè­¦**:

```rust
use tokio::time::{interval, Duration};

pub struct AlertManager {
    thresholds: AlertThresholds,
    notifier: Box<dyn Notifier>,
}

pub struct AlertThresholds {
    pub max_cpu: f32,
    pub max_memory: u64,
    pub max_latency: Duration,
    pub min_throughput: f64,
}

impl AlertManager {
    pub async fn monitor_loop(&mut self, metrics: Arc<ProcessMonitor>) {
        let mut interval = interval(Duration::from_secs(10));

        loop {
            interval.tick().await;

            // æ”¶é›†æŒ‡æ ‡
            metrics.collect_system_metrics().await;

            // æ£€æŸ¥é˜ˆå€¼
            if let Some(alert) = self.check_thresholds(&metrics).await {
                self.send_alert(alert).await;
            }
        }
    }

    async fn check_thresholds(&self, metrics: &ProcessMonitor) -> Option<Alert> {
        // CPUæ£€æŸ¥
        let cpu = metrics.cpu_usage.get();
        if cpu > self.thresholds.max_cpu as f64 {
            return Some(Alert {
                severity: Severity::Warning,
                message: format!("CPU usage high: {:.2}%", cpu),
                metric: "cpu_usage",
            });
        }

        // å†…å­˜æ£€æŸ¥
        let memory = metrics.memory_usage.get() as u64;
        if memory > self.thresholds.max_memory {
            return Some(Alert {
                severity: Severity::Critical,
                message: format!("Memory usage high: {} MB", memory / 1024 / 1024),
                metric: "memory_usage",
            });
        }

        None
    }

    async fn send_alert(&self, alert: Alert) {
        self.notifier.notify(alert).await;
    }
}

pub trait Notifier: Send + Sync {
    async fn notify(&self, alert: Alert);
}

pub struct SlackNotifier {
    webhook_url: String,
}

impl Notifier for SlackNotifier {
    async fn notify(&self, alert: Alert) {
        // å‘é€Slacké€šçŸ¥
        let client = reqwest::Client::new();
        let payload = serde_json::json!({
            "text": format!("[{}] {}", alert.severity, alert.message),
            "username": "Process Monitor",
        });

        client.post(&self.webhook_url)
            .json(&payload)
            .send()
            .await
            .ok();
    }
}
```

---

## 11. æ€§èƒ½è°ƒè¯•æŠ€å·§

### 11.1 ç³»ç»Ÿè°ƒç”¨è¿½è¸ª

**è¯¦ç»†çš„straceåˆ†æ**:

```bash
# ç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨
strace -c -f ./process-manager

# è¾“å‡ºç¤ºä¾‹:
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 45.23    0.000452          23        20           clone
 23.45    0.000234          12        20           wait4
 12.34    0.000123           6        20           execve
  8.90    0.000089           4        22           read
  5.67    0.000057           3        18           write
  4.41    0.000044           2        20           pipe2
------ ----------- ----------- --------- --------- ----------------
100.00    0.000999                   120           total
```

**åˆ†æå…³é”®æŒ‡æ ‡**:

```rust
pub struct SyscallAnalysis {
    pub clone_count: usize,      // è¿›ç¨‹åˆ›å»ºæ¬¡æ•°
    pub wait_count: usize,       // ç­‰å¾…æ¬¡æ•°
    pub pipe_count: usize,       // ç®¡é“åˆ›å»ºæ¬¡æ•°
    pub total_time: Duration,    // æ€»è€—æ—¶
}

impl SyscallAnalysis {
    pub fn from_strace_output(output: &str) -> Self {
        // è§£æstrace -cè¾“å‡º
        // ...
        Self {
            clone_count: 20,
            wait_count: 20,
            pipe_count: 20,
            total_time: Duration::from_micros(999),
        }
    }

    pub fn recommendations(&self) -> Vec<String> {
        let mut recs = Vec::new();

        // è¿‡å¤šçš„cloneè°ƒç”¨
        if self.clone_count > 100 {
            recs.push("è€ƒè™‘ä½¿ç”¨è¿›ç¨‹æ± å‡å°‘cloneè°ƒç”¨".to_string());
        }

        // è¿‡å¤šçš„pipeè°ƒç”¨
        if self.pipe_count > 50 {
            recs.push("è€ƒè™‘å¤ç”¨ç®¡é“æˆ–ä½¿ç”¨å…±äº«å†…å­˜".to_string());
        }

        recs
    }
}
```

### 11.2 æ€§èƒ½å›å½’æµ‹è¯•

**è‡ªåŠ¨åŒ–æ€§èƒ½å›å½’æ£€æµ‹**:

```rust
use criterion::{criterion_group, criterion_main, Criterion};
use std::fs;

pub struct PerformanceRegression {
    baseline_file: String,
    threshold: f64,  // å…è®¸çš„æ€§èƒ½ä¸‹é™ç™¾åˆ†æ¯”
}

impl PerformanceRegression {
    pub fn check(&self, current_metrics: &Metrics) -> Result<(), RegressionError> {
        let baseline = self.load_baseline()?;

        // æ£€æŸ¥å„é¡¹æŒ‡æ ‡
        for (name, current_value) in &current_metrics.values {
            if let Some(baseline_value) = baseline.get(name) {
                let regression = (current_value - baseline_value) / baseline_value * 100.0;

                if regression > self.threshold {
                    return Err(RegressionError {
                        metric: name.clone(),
                        baseline: *baseline_value,
                        current: *current_value,
                        regression_pct: regression,
                    });
                }
            }
        }

        Ok(())
    }

    fn load_baseline(&self) -> Result<HashMap<String, f64>, Error> {
        let content = fs::read_to_string(&self.baseline_file)?;
        serde_json::from_str(&content).map_err(Into::into)
    }
}

// CIé›†æˆ
fn bench_with_regression(c: &mut Criterion) {
    let mut group = c.benchmark_group("regression");

    group.bench_function("spawn", |b| {
        b.iter(|| {
            Command::new("true").output().unwrap()
        });
    });

    group.finish();

    // æ£€æŸ¥å›å½’
    let regression = PerformanceRegression {
        baseline_file: "baseline.json".to_string(),
        threshold: 5.0,  // å…è®¸5%ä¸‹é™
    };

    let current_metrics = collect_current_metrics();

    if let Err(e) = regression.check(&current_metrics) {
        panic!("æ€§èƒ½å›å½’æ£€æµ‹å¤±è´¥: {:?}", e);
    }
}
```

---

## 12. ä¼˜åŒ–æ¸…å•

### 12.1 æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥è¡¨

**Level 1: åŸºç¡€ä¼˜åŒ–** (2-5xæå‡)

- [ ] ä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„ (Vec vs VecDeque vs HashMap)
- [ ] é¿å…ä¸å¿…è¦çš„å…‹éš† (Clone vs å¼•ç”¨)
- [ ] å‡å°‘å†…å­˜åˆ†é… (é¢„åˆ†é…å®¹é‡)
- [ ] ä½¿ç”¨è¿­ä»£å™¨é“¾å¼è°ƒç”¨
- [ ] é¿å…å­—ç¬¦ä¸²æ‹¼æ¥ (ä½¿ç”¨format!)

**Level 2: ç³»ç»Ÿä¼˜åŒ–** (5-20xæå‡)

- [ ] å®ç°è¿›ç¨‹æ±  (é¿å…é¢‘ç¹spawn)
- [ ] ä½¿ç”¨å¯¹è±¡æ±  (å¤ç”¨æ˜‚è´µèµ„æº)
- [ ] æ‰¹å¤„ç†æ“ä½œ (å‡å°‘ç³»ç»Ÿè°ƒç”¨)
- [ ] å®ç°ç¼“å­˜å±‚ (å‡å°‘é‡å¤è®¡ç®—)
- [ ] å¼‚æ­¥I/O (æé«˜å¹¶å‘)

**Level 3: åº•å±‚ä¼˜åŒ–** (20-100xæå‡)

- [ ] é›¶æ‹·è´æŠ€æœ¯ (splice/sendfile/mmap)
- [ ] SIMDæŒ‡ä»¤ (å‘é‡åŒ–è®¡ç®—)
- [ ] å†…å­˜å¯¹é½ (Cache-lineä¼˜åŒ–)
- [ ] Lock-freeæ•°æ®ç»“æ„
- [ ] å†…æ ¸bypass (io_uring/DPDK)

### 12.2 æ€§èƒ½å®¡æŸ¥æµç¨‹

```rust
pub struct PerformanceReview {
    checklist: Vec<CheckItem>,
}

impl PerformanceReview {
    pub fn conduct_review(&self) -> ReviewReport {
        let mut report = ReviewReport::new();

        for item in &self.checklist {
            let result = item.check();
            report.add_result(result);
        }

        report
    }
}

pub struct CheckItem {
    pub name: String,
    pub category: OptimizationLevel,
    pub check_fn: Box<dyn Fn() -> CheckResult>,
}

pub enum OptimizationLevel {
    Basic,      // 2-5x
    System,     // 5-20x
    Advanced,   // 20-100x
}

pub struct ReviewReport {
    pub passed: Vec<String>,
    pub failed: Vec<String>,
    pub recommendations: Vec<String>,
}
```

---

**ä¸‹ä¸€æ­¥**: [04\_æµ‹è¯•ä¸åŸºå‡†.md](./04_æµ‹è¯•ä¸åŸºå‡†.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
