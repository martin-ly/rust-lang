# Tier 4: 测试与基准

> **文档类型**: 高级主题  
> **难度**: ⭐⭐⭐⭐  
> **适用版本**: Rust 1.90+  
> **前置知识**: [性能工程实践](./03_性能工程实践.md)

---

## 目录

- [Tier 4: 测试与基准](#tier-4-测试与基准)
  - [目录](#目录)
  - [1. 测试策略](#1-测试策略)
    - [1.1 单元测试](#11-单元测试)
    - [1.2 集成测试](#12-集成测试)
    - [1.3 端到端测试](#13-端到端测试)
  - [2. 进程测试技巧](#2-进程测试技巧)
    - [2.1 超时处理](#21-超时处理)
    - [2.2 错误注入](#22-错误注入)
    - [2.3 僵尸进程处理](#23-僵尸进程处理)
    - [2.4 信号处理测试](#24-信号处理测试)
  - [3. 基准测试](#3-基准测试)
    - [3.1 Criterion框架](#31-criterion框架)
    - [3.2 IPC基准](#32-ipc基准)
    - [3.3 进程池基准](#33-进程池基准)
  - [4. 压力测试](#4-压力测试)
    - [4.1 负载生成](#41-负载生成)
    - [4.2 稳定性测试](#42-稳定性测试)
    - [4.3 内存泄漏检测](#43-内存泄漏检测)
    - [4.4 资源耗尽测试](#44-资源耗尽测试)
  - [5. CI/CD集成](#5-cicd集成)
    - [5.1 GitHub Actions](#51-github-actions)
    - [5.2 性能回归检测](#52-性能回归检测)
  - [6. 实战案例](#6-实战案例)
    - [案例：完整测试套件](#案例完整测试套件)
  - [7. 最佳实践](#7-最佳实践)
  - [总结](#总结)
  - [8. 高级测试模式](#8-高级测试模式)
    - [8.1 属性测试（Property-based Testing）](#81-属性测试property-based-testing)
    - [8.2 模糊测试（Fuzzing）](#82-模糊测试fuzzing)
    - [8.3 测试覆盖率](#83-测试覆盖率)
  - [9. 性能剖析与调优](#9-性能剖析与调优)
    - [9.1 CPU剖析](#91-cpu剖析)
    - [9.2 内存剖析](#92-内存剖析)
    - [9.3 系统调用跟踪](#93-系统调用跟踪)
  - [10. 调试技巧](#10-调试技巧)
    - [10.1 条件断点](#101-条件断点)
    - [10.2 日志驱动测试](#102-日志驱动测试)
    - [10.3 时间旅行调试](#103-时间旅行调试)
  - [11. 测试数据管理](#11-测试数据管理)
    - [11.1 Fixture管理](#111-fixture管理)
    - [11.2 快照测试](#112-快照测试)
  - [12. 持续性能监控](#12-持续性能监控)
    - [12.1 性能回归检测](#121-性能回归检测)
    - [12.2 持续集成报告](#122-持续集成报告)

---

## 1. 测试策略

### 1.1 单元测试

**基础进程测试**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::process::Command;
    
    #[test]
    fn test_spawn_echo() {
        let output = Command::new("echo")
            .arg("test")
            .output()
            .expect("Failed to spawn");
        
        assert!(output.status.success());
        assert_eq!(output.stdout, b"test\n");
    }
    
    #[test]
    fn test_spawn_failure() {
        let result = Command::new("nonexistent_command_12345").spawn();
        assert!(result.is_err());
    }
    
    #[test]
    fn test_exit_code() {
        let status = Command::new("sh")
            .arg("-c")
            .arg("exit 42")
            .status()
            .unwrap();
        
        assert_eq!(status.code(), Some(42));
    }
}
```

**Mock进程**:

```rust
pub struct MockProcess {
    exit_code: i32,
    stdout: Vec<u8>,
    stderr: Vec<u8>,
    delay: Duration,
}

impl MockProcess {
    pub fn builder() -> MockProcessBuilder {
        MockProcessBuilder::default()
    }
    
    pub async fn run(&self) -> std::io::Result<MockOutput> {
        tokio::time::sleep(self.delay).await;
        
        Ok(MockOutput {
            status: MockStatus { code: self.exit_code },
            stdout: self.stdout.clone(),
            stderr: self.stderr.clone(),
        })
    }
}

// 使用示例
#[tokio::test]
async fn test_with_mock() {
    let mock = MockProcess::builder()
        .exit_code(0)
        .stdout(b"success")
        .delay(Duration::from_millis(10))
        .build();
    
    let output = mock.run().await.unwrap();
    assert_eq!(output.stdout, b"success");
}
```

### 1.2 集成测试

**进程通信测试**:

```rust
#[tokio::test]
async fn test_process_communication() {
    let mut child = tokio::process::Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();
    
    let mut stdin = child.stdin.take().unwrap();
    stdin.write_all(b"hello world").await.unwrap();
    drop(stdin);  // 关闭stdin以触发EOF
    
    let output = child.wait_with_output().await.unwrap();
    assert_eq!(output.stdout, b"hello world");
}

#[tokio::test]
async fn test_pipeline() {
    // 测试进程管道：echo "test" | wc -c
    let echo = tokio::process::Command::new("echo")
        .arg("test")
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();
    
    let mut wc = tokio::process::Command::new("wc")
        .arg("-c")
        .stdin(echo.stdout.unwrap())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();
    
    let output = wc.wait_with_output().await.unwrap();
    let count = String::from_utf8_lossy(&output.stdout).trim().parse::<i32>().unwrap();
    assert_eq!(count, 5);  // "test\n" = 5 bytes
}
```

### 1.3 端到端测试

**完整工作流测试**:

```rust
#[tokio::test]
async fn test_process_pool_workflow() {
    let pool = ProcessPool::new(4);
    
    // 1. 提交任务
    let tasks: Vec<_> = (0..100).map(|i| Task { id: i }).collect();
    for task in tasks {
        pool.submit(task).await.unwrap();
    }
    
    // 2. 等待完成
    pool.wait_all().await;
    
    // 3. 验证结果
    let results = pool.get_results();
    assert_eq!(results.len(), 100);
    assert!(results.iter().all(|r| r.success));
}
```

---

## 2. 进程测试技巧

### 2.1 超时处理

**测试超时保护**:

```rust
use tokio::time::{timeout, Duration};

#[tokio::test]
async fn test_with_timeout() {
    let result = timeout(
        Duration::from_secs(5),
        async {
            let output = tokio::process::Command::new("sleep")
                .arg("10")
                .output()
                .await?;
            Ok::<_, std::io::Error>(output)
        }
    ).await;
    
    assert!(result.is_err(), "应该超时");
}

// 通用超时包装器
pub async fn with_timeout<F, T>(
    duration: Duration,
    future: F,
) -> Result<T, TimeoutError>
where
    F: Future<Output = T>,
{
    timeout(duration, future)
        .await
        .map_err(|_| TimeoutError::new(duration))
}
```

### 2.2 错误注入

**故障模拟**:

```rust
pub struct FaultInjector {
    fail_rate: f64,  // 0.0 - 1.0
}

impl FaultInjector {
    pub fn should_fail(&self) -> bool {
        use rand::Rng;
        rand::thread_rng().gen::<f64>() < self.fail_rate
    }
    
    pub fn maybe_fail<T, E>(&self, result: Result<T, E>) -> Result<T, E> {
        if self.should_fail() {
            // 随机失败
            Err(result.err().unwrap_or_else(|| panic!("No error to inject")))
        } else {
            result
        }
    }
}

#[tokio::test]
async fn test_with_fault_injection() {
    let injector = FaultInjector { fail_rate: 0.5 };
    
    let mut failures = 0;
    for _ in 0..100 {
        let result = injector.maybe_fail::<(), &str>(Ok(()));
        if result.is_err() {
            failures += 1;
        }
    }
    
    // 应该有大约50次失败
    assert!(failures > 30 && failures < 70);
}
```

### 2.3 僵尸进程处理

**自动清理**:

```rust
pub struct ProcessGuard {
    child: Option<Child>,
}

impl ProcessGuard {
    pub fn new(child: Child) -> Self {
        Self { child: Some(child) }
    }
    
    pub fn pid(&self) -> u32 {
        self.child.as_ref().unwrap().id()
    }
}

impl Drop for ProcessGuard {
    fn drop(&mut self) {
        if let Some(mut child) = self.child.take() {
            // 确保进程被清理
            let _ = child.kill();
            let _ = child.wait();
        }
    }
}

#[test]
fn test_no_zombie() {
    let guard = ProcessGuard::new(
        Command::new("sleep").arg("100").spawn().unwrap()
    );
    
    let pid = guard.pid();
    // guard会在作用域结束时自动清理进程
    drop(guard);
    
    std::thread::sleep(Duration::from_millis(100));
    
    // 验证进程已被清理
    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;
        let result = kill(Pid::from_raw(pid as i32), Signal::SIGKILL);
        assert!(result.is_err());  // 进程应该已不存在
    }
}
```

### 2.4 信号处理测试

**信号测试**:

```rust
#[cfg(unix)]
#[test]
fn test_signal_handling() {
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;
    
    let mut child = Command::new("sleep")
        .arg("100")
        .spawn()
        .unwrap();
    
    let pid = child.id();
    
    // 发送SIGTERM
    kill(Pid::from_raw(pid as i32), Signal::SIGTERM).unwrap();
    
    // 等待进程退出
    let status = child.wait().unwrap();
    
    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        assert_eq!(status.signal(), Some(15));  // SIGTERM
    }
}
```

---

## 3. 基准测试

### 3.1 Criterion框架

**完整基准测试**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::process::Command;

fn bench_process_spawn(c: &mut Criterion) {
    c.bench_function("spawn_echo", |b| {
        b.iter(|| {
            Command::new("echo")
                .arg(black_box("test"))
                .output()
                .unwrap()
        });
    });
}

fn bench_process_spawn_different_sizes(c: &mut Criterion) {
    let mut group = c.benchmark_group("spawn_with_args");
    
    for size in [1, 10, 100, 1000].iter() {
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            let args: Vec<_> = (0..size).map(|i| format!("arg{}", i)).collect();
            b.iter(|| {
                Command::new("echo")
                    .args(&args)
                    .output()
                    .unwrap()
            });
        });
    }
    group.finish();
}

criterion_group!(benches, bench_process_spawn, bench_process_spawn_different_sizes);
criterion_main!(benches);
```

### 3.2 IPC基准

**通信性能测试**:

```rust
use criterion::{criterion_group, criterion_main, Criterion, Throughput};

fn bench_pipe_throughput(c: &mut Criterion) {
    let mut group = c.benchmark_group("pipe_throughput");
    
    for size in [1024, 4096, 16384, 65536].iter() {
        group.throughput(Throughput::Bytes(*size as u64));
        
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            let data = vec![0u8; size];
            
            b.iter(|| {
                let mut child = Command::new("cat")
                    .stdin(Stdio::piped())
                    .stdout(Stdio::piped())
                    .spawn()
                    .unwrap();
                
                child.stdin.as_mut().unwrap().write_all(&data).unwrap();
                drop(child.stdin.take());
                
                let output = child.wait_with_output().unwrap();
                black_box(output);
            });
        });
    }
    
    group.finish();
}

criterion_group!(benches, bench_pipe_throughput);
criterion_main!(benches);
```

### 3.3 进程池基准

**池性能对比**:

```rust
fn bench_process_pool(c: &mut Criterion) {
    let mut group = c.benchmark_group("process_pool");
    
    // 基准：无池
    group.bench_function("no_pool", |b| {
        b.iter(|| {
            for _ in 0..10 {
                Command::new("true").status().unwrap();
            }
        });
    });
    
    // 基准：固定池
    group.bench_function("fixed_pool", |b| {
        let pool = ProcessPool::new(4);
        b.iter(|| {
            for _ in 0..10 {
                pool.execute(|| Command::new("true").status()).unwrap();
            }
        });
    });
    
    // 基准：动态池
    group.bench_function("dynamic_pool", |b| {
        let pool = DynamicProcessPool::new(2, 8);
        b.iter(|| {
            for _ in 0..10 {
                pool.execute(|| Command::new("true").status()).unwrap();
            }
        });
    });
    
    group.finish();
}
```

---

## 4. 压力测试

### 4.1 负载生成

**高并发测试**:

```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn test_concurrent_spawns() {
    let handles: Vec<_> = (0..1000)
        .map(|i| {
            tokio::spawn(async move {
                let output = tokio::process::Command::new("echo")
                    .arg(format!("task-{}", i))
                    .output()
                    .await
                    .unwrap();
                
                assert!(output.status.success());
            })
        })
        .collect();
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 4.2 稳定性测试

**长时间运行测试**:

```rust
#[tokio::test]
#[ignore]  // 使用 cargo test -- --ignored 运行
async fn test_stability_24h() {
    let start = Instant::now();
    let target_duration = Duration::from_secs(24 * 3600);
    
    let mut iterations = 0;
    let mut failures = 0;
    
    while start.elapsed() < target_duration {
        match spawn_and_run_task().await {
            Ok(_) => iterations += 1,
            Err(e) => {
                failures += 1;
                eprintln!("Failure: {:?}", e);
            }
        }
        
        if iterations % 1000 == 0 {
            println!("Iterations: {}, Failures: {}, Uptime: {:?}",
                iterations, failures, start.elapsed());
        }
    }
    
    let failure_rate = failures as f64 / iterations as f64;
    assert!(failure_rate < 0.001, "故障率过高: {:.4}%", failure_rate * 100.0);
}
```

### 4.3 内存泄漏检测

**内存增长测试**:

```rust
#[test]
fn test_no_memory_leak() {
    use sysinfo::{System, SystemExt, ProcessExt};
    
    let mut system = System::new_all();
    let pid = sysinfo::Pid::from(std::process::id() as usize);
    
    system.refresh_all();
    let initial_memory = system.process(pid).unwrap().memory();
    
    // 运行1000次操作
    for _ in 0..1000 {
        let child = Command::new("echo")
            .arg("test")
            .spawn()
            .unwrap();
        child.wait_with_output().unwrap();
    }
    
    system.refresh_all();
    let final_memory = system.process(pid).unwrap().memory();
    
    let growth = (final_memory as f64 - initial_memory as f64) / initial_memory as f64;
    
    // 允许10%的内存增长
    assert!(growth < 0.10, "内存增长过大: {:.2}%", growth * 100.0);
}
```

### 4.4 资源耗尽测试

**文件描述符测试**:

```rust
#[test]
fn test_fd_exhaustion() {
    let max_fds = 100;
    let mut children = Vec::new();
    
    for i in 0..max_fds {
        match Command::new("sleep").arg("1").spawn() {
            Ok(child) => children.push(child),
            Err(e) => {
                eprintln!("Failed at {}: {:?}", i, e);
                break;
            }
        }
    }
    
    // 清理
    for mut child in children {
        child.kill().ok();
        child.wait().ok();
    }
}
```

---

## 5. CI/CD集成

### 5.1 GitHub Actions

**完整CI配置**:

```yaml
# .github/workflows/test.yml
name: Process Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable, beta, nightly]
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: ${{ matrix.rust }}
        override: true
    
    - name: Run tests
      run: cargo test --all-features
    
    - name: Run benchmarks
      run: cargo bench --no-run
    
    - name: Run stress tests
      run: cargo test --release -- --ignored --test-threads=1
      
  coverage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin
    
    - name: Generate coverage
      run: cargo tarpaulin --out Xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v2
```

### 5.2 性能回归检测

**自动化性能测试**:

```yaml
name: Performance Regression

on:
  pull_request:
    branches: [ main ]

jobs:
  bench:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
    
    - name: Run benchmarks (baseline)
      run: |
        git checkout main
        cargo bench --bench process_bench -- --save-baseline main
    
    - name: Run benchmarks (PR)
      run: |
        git checkout ${{ github.sha }}
        cargo bench --bench process_bench -- --baseline main
    
    - name: Check for regression
      run: |
        if grep -q "regressed" target/criterion/*/report/index.html; then
          echo "Performance regression detected!"
          exit 1
        fi
```

---

## 6. 实战案例

### 案例：完整测试套件

**测试组织结构**:

```text
tests/
├── unit/
│   ├── process_spawn_test.rs
│   ├── process_pool_test.rs
│   └── ipc_test.rs
├── integration/
│   ├── workflow_test.rs
│   └── error_handling_test.rs
├── stress/
│   ├── concurrent_test.rs
│   └── stability_test.rs
└── benches/
    ├── spawn_bench.rs
    └── pool_bench.rs
```

**测试辅助工具**:

```rust
// tests/common/mod.rs
pub struct TestContext {
    temp_dir: TempDir,
    process_guard: Vec<ProcessGuard>,
}

impl TestContext {
    pub fn new() -> Self {
        Self {
            temp_dir: TempDir::new().unwrap(),
            process_guard: Vec::new(),
        }
    }
    
    pub fn spawn_guarded(&mut self, cmd: Command) -> std::io::Result<&mut Child> {
        let child = cmd.spawn()?;
        self.process_guard.push(ProcessGuard::new(child));
        Ok(self.process_guard.last_mut().unwrap().child())
    }
    
    pub fn temp_file(&self, name: &str) -> PathBuf {
        self.temp_dir.path().join(name)
    }
}

impl Drop for TestContext {
    fn drop(&mut self) {
        // 自动清理所有进程和临时文件
        self.process_guard.clear();
    }
}

// 使用示例
#[test]
fn test_with_context() {
    let mut ctx = TestContext::new();
    
    let child = ctx.spawn_guarded(
        Command::new("echo").arg("test")
    ).unwrap();
    
    let output = child.wait_with_output().unwrap();
    assert!(output.status.success());
    
    // ctx被drop时自动清理
}
```

---

## 7. 最佳实践

**1. 测试隔离**:

```rust
// ✅ 推荐：每个测试独立
#[test]
fn test_isolated() {
    let temp_dir = tempfile::tempdir().unwrap();
    // 测试逻辑
} // temp_dir自动清理

// ❌ 避免：共享状态
static SHARED: Mutex<State> = Mutex::new(State::new());
```

**2. 确定性测试**:

```rust
// ✅ 推荐：确定性
#[test]
fn test_deterministic() {
    let output = Command::new("echo").arg("test").output().unwrap();
    assert_eq!(output.stdout, b"test\n");
}

// ❌ 避免：依赖时间
#[test]
fn test_timing_dependent() {
    let start = Instant::now();
    // 可能在不同机器上失败
    assert!(start.elapsed() < Duration::from_millis(10));
}
```

**3. 快速反馈**:

- ✅ 单元测试 < 100ms
- ✅ 集成测试 < 5s
- ✅ 压力测试标记为`#[ignore]`

**4. 清理资源**:

```rust
// ✅ 使用RAII
pub struct TestProcess(Child);

impl Drop for TestProcess {
    fn drop(&mut self) {
        self.0.kill().ok();
        self.0.wait().ok();
    }
}
```

**5. 有意义的断言**:

```rust
// ✅ 推荐：清晰的错误消息
assert_eq!(actual, expected, "进程输出不匹配: {:?}", actual);

// ❌ 避免：无信息的断言
assert!(condition);
```

---

## 总结

**测试与基准核心要素**:

1. ✅ **测试策略**: 单元/集成/端到端
2. ✅ **测试技巧**: 超时/错误注入/僵尸清理/信号测试
3. ✅ **基准测试**: Criterion框架/IPC性能/池对比
4. ✅ **压力测试**: 高并发/稳定性/内存泄漏/资源耗尽
5. ✅ **CI/CD**: GitHub Actions/性能回归检测
6. ✅ **最佳实践**: 隔离/确定性/快速反馈/清理/断言

**测试金字塔**:

```text
    /\        E2E测试 (少量, 慢)
   /  \
  /    \      集成测试 (中等)
 /      \
/________\    单元测试 (大量, 快)
```

---

## 8. 高级测试模式

### 8.1 属性测试（Property-based Testing）

**使用proptest框架**:

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_echo_preserves_input(input in "\\PC*") {
        let output = std::process::Command::new("echo")
            .arg(&input)
            .output()
            .unwrap();
        
        let result = String::from_utf8_lossy(&output.stdout);
        // echo会添加换行符
        prop_assert!(result.starts_with(&input));
    }
    
    #[test]
    fn test_wc_counts_correctly(lines in prop::collection::vec(".*", 0..100)) {
        use std::io::Write;
        
        let input = lines.join("\n");
        let expected_count = lines.len();
        
        let mut child = std::process::Command::new("wc")
            .arg("-l")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .spawn()
            .unwrap();
        
        child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();
        let output = child.wait_with_output().unwrap();
        
        let count: usize = String::from_utf8_lossy(&output.stdout)
            .trim()
            .parse()
            .unwrap();
        
        prop_assert_eq!(count, expected_count);
    }
}
```

**进程参数模糊测试**:

```rust
use proptest::prelude::*;

fn valid_arg_strategy() -> impl Strategy<Value = String> {
    prop::string::string_regex("[a-zA-Z0-9_-]{1,100}").unwrap()
}

proptest! {
    #[test]
    fn test_process_handles_any_valid_arg(arg in valid_arg_strategy()) {
        let result = std::process::Command::new("echo")
            .arg(&arg)
            .output();
        
        // 应该总能成功处理有效参数
        prop_assert!(result.is_ok());
    }
    
    #[test]
    fn test_concurrent_spawn_property(
        count in 1usize..50,
        args in prop::collection::vec(valid_arg_strategy(), 0..10)
    ) {
        let rt = tokio::runtime::Runtime::new().unwrap();
        
        rt.block_on(async {
            let mut tasks = Vec::new();
            
            for _ in 0..count {
                let args_clone = args.clone();
                tasks.push(tokio::spawn(async move {
                    tokio::process::Command::new("echo")
                        .args(&args_clone)
                        .output()
                        .await
                }));
            }
            
            let results: Vec<_> = futures::future::join_all(tasks)
                .await
                .into_iter()
                .collect();
            
            // 所有任务都应该成功完成
            for result in results {
                prop_assert!(result.is_ok());
                prop_assert!(result.unwrap().is_ok());
            }
            
            Ok(())
        })?;
    }
}
```

### 8.2 模糊测试（Fuzzing）

**cargo-fuzz集成**:

```bash
# 安装cargo-fuzz
cargo install cargo-fuzz

# 初始化fuzz target
cargo fuzz init

# 创建fuzz target
cargo fuzz add process_args
```

**Fuzz target实现**:

```rust
// fuzz/fuzz_targets/process_args.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use std::process::Command;

fuzz_target!(|data: &[u8]| {
    // 将随机字节转换为字符串
    if let Ok(arg) = std::str::from_utf8(data) {
        // 测试进程是否能处理任意输入
        let _ = Command::new("echo")
            .arg(arg)
            .output();
    }
});
```

**高级模糊测试策略**:

```rust
// fuzz/fuzz_targets/ipc_fuzzing.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
struct IpcInput {
    pipe_data: Vec<u8>,
    timeout_ms: u16,
    env_vars: Vec<(String, String)>,
}

fuzz_target!(|input: IpcInput| {
    use std::io::Write;
    use std::time::Duration;
    
    let mut child = std::process::Command::new("cat")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .envs(input.env_vars.iter().map(|(k, v)| (k, v)))
        .spawn();
    
    if let Ok(mut child) = child {
        // 写入数据
        if let Some(mut stdin) = child.stdin.take() {
            let _ = stdin.write_all(&input.pipe_data);
            drop(stdin);
        }
        
        // 带超时等待
        let timeout = Duration::from_millis(input.timeout_ms as u64);
        let _ = std::thread::spawn(move || {
            std::thread::sleep(timeout);
            let _ = child.kill();
        });
    }
});
```

### 8.3 测试覆盖率

**使用tarpaulin**:

```bash
# 安装
cargo install cargo-tarpaulin

# 运行覆盖率测试
cargo tarpaulin --out Html --out Xml

# 生成报告
cargo tarpaulin --out Html --output-dir coverage/
```

**配置tarpaulin.toml**:

```toml
[tarpaulin]
# 排除文件
exclude = [
    "*/tests/*",
    "*/benches/*",
]

# 超时设置
timeout = 600

# 最小覆盖率
fail-under = 80.0

# 输出格式
output-format = ["Html", "Lcov"]
```

**覆盖率目标实现**:

```rust
// 确保关键路径被测试覆盖
pub fn critical_process_function() -> Result<(), Error> {
    let output = Command::new("critical_command")
        .output()?;
    
    // 分支1: 成功
    if output.status.success() {
        return Ok(());
    }
    
    // 分支2: 失败
    if let Some(code) = output.status.code() {
        return Err(Error::ExitCode(code));
    }
    
    // 分支3: 被信号终止
    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        if let Some(signal) = output.status.signal() {
            return Err(Error::Signal(signal));
        }
    }
    
    Err(Error::Unknown)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_success_path() {
        // 覆盖成功分支
    }
    
    #[test]
    fn test_failure_path() {
        // 覆盖失败分支
    }
    
    #[test]
    #[cfg(unix)]
    fn test_signal_path() {
        // 覆盖信号分支
    }
}
```

---

## 9. 性能剖析与调优

### 9.1 CPU剖析

**使用flamegraph**:

```bash
# 安装
cargo install flamegraph

# 生成CPU火焰图
cargo flamegraph --bin process-manager

# 带基准测试
cargo flamegraph --bench process_bench
```

**集成到测试中**:

```rust
#[cfg(test)]
mod profiling {
    use std::fs::File;
    
    #[test]
    #[ignore]  // 只在需要时运行
    fn profile_spawn_performance() {
        let guard = pprof::ProfilerGuardBuilder::default()
            .frequency(1000)
            .build()
            .unwrap();
        
        // 执行需要剖析的代码
        for _ in 0..1000 {
            let _ = std::process::Command::new("true")
                .spawn()
                .unwrap()
                .wait();
        }
        
        // 生成报告
        if let Ok(report) = guard.report().build() {
            let file = File::create("flamegraph.svg").unwrap();
            report.flamegraph(file).unwrap();
        }
    }
}
```

### 9.2 内存剖析

**使用valgrind/massif**:

```bash
# 运行内存剖析
valgrind --tool=massif \
         --massif-out-file=massif.out \
         ./target/release/process-manager

# 可视化
massif-visualizer massif.out
```

**内存泄漏检测**:

```rust
#[cfg(test)]
mod memory_tests {
    use std::process::Command;
    
    #[test]
    fn test_no_memory_leak() {
        let initial = get_memory_usage();
        
        // 执行大量操作
        for _ in 0..1000 {
            let output = Command::new("echo")
                .arg("test")
                .output()
                .unwrap();
            
            drop(output);  // 确保释放
        }
        
        // 强制GC
        std::mem::drop(vec![0u8; 1024 * 1024]);
        
        let final_usage = get_memory_usage();
        let growth = final_usage - initial;
        
        // 增长应该小于1MB
        assert!(growth < 1024 * 1024, "内存泄漏: {} bytes", growth);
    }
    
    fn get_memory_usage() -> usize {
        #[cfg(target_os = "linux")]
        {
            use std::fs;
            let status = fs::read_to_string("/proc/self/status").unwrap();
            
            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        return parts[1].parse::<usize>().unwrap() * 1024;
                    }
                }
            }
        }
        
        0
    }
}
```

### 9.3 系统调用跟踪

**使用strace**:

```bash
# 跟踪系统调用
strace -c ./target/release/process-manager

# 详细跟踪
strace -tt -T -o strace.log ./target/release/process-manager

# 只跟踪进程相关系统调用
strace -e trace=process ./target/release/process-manager
```

**程序化系统调用分析**:

```rust
#[cfg(test)]
mod syscall_tests {
    use std::process::Command;
    
    #[test]
    #[cfg(target_os = "linux")]
    fn test_syscall_count() {
        // 使用strace统计系统调用
        let output = Command::new("strace")
            .arg("-c")
            .arg("-e")
            .arg("trace=process")
            .arg("./target/release/test-binary")
            .output()
            .unwrap();
        
        let stderr = String::from_utf8_lossy(&output.stderr);
        
        // 解析输出，验证系统调用次数合理
        assert!(stderr.contains("execve"));
        assert!(stderr.contains("clone") || stderr.contains("fork"));
    }
}
```

---

## 10. 调试技巧

### 10.1 条件断点

**使用gdb调试**:

```bash
# 编译debug版本
cargo build

# 启动gdb
gdb ./target/debug/process-manager

# 设置条件断点
(gdb) break spawn_process if pid > 1000
(gdb) run
```

### 10.2 日志驱动测试

**结构化日志**:

```rust
use tracing::{info, warn, error, instrument};
use tracing_subscriber;

#[instrument]
pub async fn spawn_monitored(cmd: &str) -> Result<Child, Error> {
    info!("尝试spawn进程: {}", cmd);
    
    let child = tokio::process::Command::new(cmd)
        .spawn()
        .map_err(|e| {
            error!("spawn失败: {}", e);
            Error::SpawnFailed(e)
        })?;
    
    info!("spawn成功, PID: {:?}", child.id());
    Ok(child)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_subscriber::fmt::format::FmtSpan;
    
    #[tokio::test]
    async fn test_with_tracing() {
        // 初始化tracing
        tracing_subscriber::fmt()
            .with_span_events(FmtSpan::FULL)
            .with_test_writer()
            .init();
        
        let result = spawn_monitored("echo").await;
        assert!(result.is_ok());
        
        // 日志会在测试失败时显示
    }
}
```

### 10.3 时间旅行调试

**使用rr (Record and Replay)**:

```bash
# 录制执行
rr record ./target/debug/process-manager

# 重放调试
rr replay

# 在gdb中可以前进/后退
(gdb) reverse-continue
(gdb) reverse-step
```

---

## 11. 测试数据管理

### 11.1 Fixture管理

**使用rstest**:

```rust
use rstest::*;

#[fixture]
fn test_env() -> TestEnvironment {
    TestEnvironment::new()
}

#[rstest]
fn test_with_fixture(test_env: TestEnvironment) {
    let output = Command::new("echo")
        .env("TEST_VAR", test_env.var())
        .output()
        .unwrap();
    
    assert!(output.status.success());
}

#[rstest]
#[case("echo", vec!["hello"])]
#[case("ls", vec!["-la"])]
#[case("pwd", vec![])]
fn test_multiple_commands(#[case] cmd: &str, #[case] args: Vec<&str>) {
    let result = Command::new(cmd)
        .args(&args)
        .output();
    
    assert!(result.is_ok());
}
```

### 11.2 快照测试

**使用insta**:

```rust
use insta::assert_snapshot;

#[test]
fn test_process_output_snapshot() {
    let output = Command::new("ls")
        .arg("-1")
        .output()
        .unwrap();
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    
    // 首次运行创建快照，后续运行对比
    assert_snapshot!(stdout);
}

#[test]
fn test_error_message_snapshot() {
    let result = Command::new("nonexistent")
        .spawn();
    
    assert!(result.is_err());
    let error_msg = format!("{:?}", result.unwrap_err());
    
    assert_snapshot!(error_msg);
}
```

---

## 12. 持续性能监控

### 12.1 性能回归检测

**自动化性能测试**:

```rust
use criterion::{criterion_group, criterion_main, Criterion};
use std::fs;

fn load_baseline() -> Option<f64> {
    fs::read_to_string("baseline.txt")
        .ok()?
        .trim()
        .parse()
        .ok()
}

fn save_baseline(value: f64) {
    fs::write("baseline.txt", value.to_string()).ok();
}

fn bench_with_regression_check(c: &mut Criterion) {
    let mut group = c.benchmark_group("regression_check");
    
    group.bench_function("spawn", |b| {
        b.iter(|| {
            Command::new("true").output().unwrap()
        });
    });
    
    group.finish();
    
    // 检查性能回归
    let current = get_median_time();
    
    if let Some(baseline) = load_baseline() {
        let regression = (current - baseline) / baseline * 100.0;
        
        if regression > 10.0 {
            panic!("性能回归 {:.2}%！", regression);
        }
    } else {
        save_baseline(current);
    }
}

fn get_median_time() -> f64 {
    // 从criterion报告中提取中位数时间
    1.0  // 简化示例
}

criterion_group!(benches, bench_with_regression_check);
criterion_main!(benches);
```

### 12.2 持续集成报告

**GitHub Actions集成**:

```yaml
name: Performance Tests

on:
  pull_request:
    branches: [ main ]

jobs:
  performance:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: 运行基准测试
      run: cargo bench -- --save-baseline PR
      
    - name: 对比性能
      run: |
        cargo bench -- --baseline main --load-baseline PR
        
    - name: 上传报告
      uses: actions/upload-artifact@v3
      with:
        name: criterion-report
        path: target/criterion/
        
    - name: 评论PR
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('perf-report.md', 'utf8');
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.name,
            body: report
          });
```

---

**下一步**: [05_现代进程库.md](./05_现代进程库.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-24  
**适用版本**: Rust 1.90+
