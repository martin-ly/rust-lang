# Tier 4: æµ‹è¯•ä¸åŸºå‡†

> **æ–‡æ¡£ç±»å‹**: é«˜çº§ä¸»é¢˜
> **éš¾åº¦**: â­â­â­â­
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **å‰ç½®çŸ¥è¯†**: [æ€§èƒ½å·¥ç¨‹å®è·µ](./03_æ€§èƒ½å·¥ç¨‹å®è·µ.md)

---

## ç›®å½•

- [Tier 4: æµ‹è¯•ä¸åŸºå‡†](#tier-4-æµ‹è¯•ä¸åŸºå‡†)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
  - [1. æµ‹è¯•ç­–ç•¥](#1-æµ‹è¯•ç­–ç•¥)
    - [1.1 å•å…ƒæµ‹è¯•](#11-å•å…ƒæµ‹è¯•)
    - [1.2 é›†æˆæµ‹è¯•](#12-é›†æˆæµ‹è¯•)
    - [1.3 ç«¯åˆ°ç«¯æµ‹è¯•](#13-ç«¯åˆ°ç«¯æµ‹è¯•)
  - [2. è¿›ç¨‹æµ‹è¯•æŠ€å·§](#2-è¿›ç¨‹æµ‹è¯•æŠ€å·§)
    - [2.1 è¶…æ—¶å¤„ç†](#21-è¶…æ—¶å¤„ç†)
    - [2.2 é”™è¯¯æ³¨å…¥](#22-é”™è¯¯æ³¨å…¥)
    - [2.3 åƒµå°¸è¿›ç¨‹å¤„ç†](#23-åƒµå°¸è¿›ç¨‹å¤„ç†)
    - [2.4 ä¿¡å·å¤„ç†æµ‹è¯•](#24-ä¿¡å·å¤„ç†æµ‹è¯•)
  - [3. åŸºå‡†æµ‹è¯•](#3-åŸºå‡†æµ‹è¯•)
    - [3.1 Criterionæ¡†æ¶](#31-criterionæ¡†æ¶)
    - [3.2 IPCåŸºå‡†](#32-ipcåŸºå‡†)
    - [3.3 è¿›ç¨‹æ± åŸºå‡†](#33-è¿›ç¨‹æ± åŸºå‡†)
  - [4. å‹åŠ›æµ‹è¯•](#4-å‹åŠ›æµ‹è¯•)
    - [4.1 è´Ÿè½½ç”Ÿæˆ](#41-è´Ÿè½½ç”Ÿæˆ)
    - [4.2 ç¨³å®šæ€§æµ‹è¯•](#42-ç¨³å®šæ€§æµ‹è¯•)
    - [4.3 å†…å­˜æ³„æ¼æ£€æµ‹](#43-å†…å­˜æ³„æ¼æ£€æµ‹)
    - [4.4 èµ„æºè€—å°½æµ‹è¯•](#44-èµ„æºè€—å°½æµ‹è¯•)
  - [5. CI/CDé›†æˆ](#5-cicdé›†æˆ)
    - [5.1 GitHub Actions](#51-github-actions)
    - [5.2 æ€§èƒ½å›å½’æ£€æµ‹](#52-æ€§èƒ½å›å½’æ£€æµ‹)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ï¼šå®Œæ•´æµ‹è¯•å¥—ä»¶](#æ¡ˆä¾‹å®Œæ•´æµ‹è¯•å¥—ä»¶)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
  - [æ€»ç»“](#æ€»ç»“)
  - [8. é«˜çº§æµ‹è¯•æ¨¡å¼](#8-é«˜çº§æµ‹è¯•æ¨¡å¼)
    - [8.1 å±æ€§æµ‹è¯•ï¼ˆProperty-based Testingï¼‰](#81-å±æ€§æµ‹è¯•property-based-testing)
    - [8.2 æ¨¡ç³Šæµ‹è¯•ï¼ˆFuzzingï¼‰](#82-æ¨¡ç³Šæµ‹è¯•fuzzing)
    - [8.3 æµ‹è¯•è¦†ç›–ç‡](#83-æµ‹è¯•è¦†ç›–ç‡)
  - [9. æ€§èƒ½å‰–æä¸è°ƒä¼˜](#9-æ€§èƒ½å‰–æä¸è°ƒä¼˜)
    - [9.1 CPUå‰–æ](#91-cpuå‰–æ)
    - [9.2 å†…å­˜å‰–æ](#92-å†…å­˜å‰–æ)
    - [9.3 ç³»ç»Ÿè°ƒç”¨è·Ÿè¸ª](#93-ç³»ç»Ÿè°ƒç”¨è·Ÿè¸ª)
  - [10. è°ƒè¯•æŠ€å·§](#10-è°ƒè¯•æŠ€å·§)
    - [10.1 æ¡ä»¶æ–­ç‚¹](#101-æ¡ä»¶æ–­ç‚¹)
    - [10.2 æ—¥å¿—é©±åŠ¨æµ‹è¯•](#102-æ—¥å¿—é©±åŠ¨æµ‹è¯•)
    - [10.3 æ—¶é—´æ—…è¡Œè°ƒè¯•](#103-æ—¶é—´æ—…è¡Œè°ƒè¯•)
  - [11. æµ‹è¯•æ•°æ®ç®¡ç†](#11-æµ‹è¯•æ•°æ®ç®¡ç†)
    - [11.1 Fixtureç®¡ç†](#111-fixtureç®¡ç†)
    - [11.2 å¿«ç…§æµ‹è¯•](#112-å¿«ç…§æµ‹è¯•)
  - [12. æŒç»­æ€§èƒ½ç›‘æ§](#12-æŒç»­æ€§èƒ½ç›‘æ§)
    - [12.1 æ€§èƒ½å›å½’æ£€æµ‹](#121-æ€§èƒ½å›å½’æ£€æµ‹)
    - [12.2 æŒç»­é›†æˆæŠ¥å‘Š](#122-æŒç»­é›†æˆæŠ¥å‘Š)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æµ‹è¯•ä¸åŸºå‡† (Testing and Benchmarking)**:

- **å®šä¹‰**: Rust 1.92.0 æµ‹è¯•ä¸åŸºå‡†æŠ€æœ¯ï¼ŒåŒ…æ‹¬æµ‹è¯•ç­–ç•¥ã€è¿›ç¨‹æµ‹è¯•æŠ€å·§ã€åŸºå‡†æµ‹è¯•ã€å‹åŠ›æµ‹è¯•ã€CI/CD é›†æˆã€å®æˆ˜æ¡ˆä¾‹ã€æœ€ä½³å®è·µã€é«˜çº§æµ‹è¯•æ¨¡å¼ã€æ€§èƒ½å‰–æä¸è°ƒä¼˜ã€è°ƒè¯•æŠ€å·§ç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: è¿›ç¨‹ç®¡ç†ã€æµ‹è¯•ã€æ€§èƒ½
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€åŸºå‡†æµ‹è¯•ã€å‹åŠ›æµ‹è¯•ã€CI/CDã€å±æ€§æµ‹è¯•ã€æ¨¡ç³Šæµ‹è¯•

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æµ‹è¯•ç­–ç•¥**: å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•
- **è¿›ç¨‹æµ‹è¯•æŠ€å·§**: è¶…æ—¶å¤„ç†ã€é”™è¯¯æ³¨å…¥ã€åƒµå°¸è¿›ç¨‹å¤„ç†ã€ä¿¡å·å¤„ç†æµ‹è¯•
- **åŸºå‡†æµ‹è¯•**: Criterion æ¡†æ¶ã€IPC åŸºå‡†ã€è¿›ç¨‹æ± åŸºå‡†
- **å‹åŠ›æµ‹è¯•**: è´Ÿè½½ç”Ÿæˆã€ç¨³å®šæ€§æµ‹è¯•ã€å†…å­˜æ³„æ¼æ£€æµ‹ã€èµ„æºè€—å°½æµ‹è¯•
- **CI/CD é›†æˆ**: GitHub Actionsã€æ€§èƒ½å›å½’æ£€æµ‹
- **é«˜çº§æµ‹è¯•æ¨¡å¼**: å±æ€§æµ‹è¯•ï¼ˆProperty-based Testingï¼‰ã€æ¨¡ç³Šæµ‹è¯•ï¼ˆFuzzingï¼‰ã€æµ‹è¯•è¦†ç›–ç‡
- **æ€§èƒ½å‰–æä¸è°ƒä¼˜**: CPU å‰–æã€å†…å­˜å‰–æã€ç³»ç»Ÿè°ƒç”¨è·Ÿè¸ª
- **è°ƒè¯•æŠ€å·§**: æ¡ä»¶æ–­ç‚¹ã€æ—¥å¿—é©±åŠ¨æµ‹è¯•ã€æ—¶é—´æ—…è¡Œè°ƒè¯•

**Rust 1.92.0 æ–°ç‰¹æ€§**:

- **æ”¹è¿›çš„æµ‹è¯•æ¡†æ¶**: æ›´å¥½çš„æµ‹è¯•æ¡†æ¶æ”¯æŒ
- **å¢å¼ºçš„åŸºå‡†æµ‹è¯•**: æ›´ç²¾ç¡®çš„åŸºå‡†æµ‹è¯•å·¥å…·
- **ä¼˜åŒ–çš„æ€§èƒ½åˆ†æ**: æ›´ç²¾ç¡®çš„æ€§èƒ½åˆ†æå·¥å…·

**æ€§èƒ½ç‰¹å¾**:

- **æµ‹è¯•è¦†ç›–**: å…¨é¢çš„æµ‹è¯•è¦†ç›–
- **æ€§èƒ½åŸºå‡†**: å‡†ç¡®çš„æ€§èƒ½åŸºå‡†
- **é€‚ç”¨åœºæ™¯**: æµ‹è¯•é©±åŠ¨å¼€å‘ã€æ€§èƒ½ä¼˜åŒ–ã€è´¨é‡ä¿è¯

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- æµ‹è¯•ä¸åŸºå‡† --[covers]--> æµ‹è¯•å®Œæ•´å†…å®¹
- è´¨é‡ä¿è¯ --[uses]--> æµ‹è¯•ä¸åŸºå‡†

**ä¾èµ–å…³ç³»**:

- æµ‹è¯•ä¸åŸºå‡† --[depends-on]--> è¿›ç¨‹ç®¡ç†
- è´¨é‡ä¿è¯ --[depends-on]--> æµ‹è¯•ä¸åŸºå‡†

### æ€ç»´å¯¼å›¾

```text
æµ‹è¯•ä¸åŸºå‡†
â”‚
â”œâ”€â”€ æµ‹è¯•ç­–ç•¥
â”‚   â”œâ”€â”€ å•å…ƒæµ‹è¯•
â”‚   â””â”€â”€ é›†æˆæµ‹è¯•
â”œâ”€â”€ è¿›ç¨‹æµ‹è¯•æŠ€å·§
â”‚   â”œâ”€â”€ è¶…æ—¶å¤„ç†
â”‚   â””â”€â”€ é”™è¯¯æ³¨å…¥
â”œâ”€â”€ åŸºå‡†æµ‹è¯•
â”‚   â”œâ”€â”€ Criterion æ¡†æ¶
â”‚   â””â”€â”€ IPC åŸºå‡†
â”œâ”€â”€ å‹åŠ›æµ‹è¯•
â”‚   â”œâ”€â”€ è´Ÿè½½ç”Ÿæˆ
â”‚   â””â”€â”€ ç¨³å®šæ€§æµ‹è¯•
â”œâ”€â”€ CI/CD é›†æˆ
â”‚   â””â”€â”€ GitHub Actions
â”œâ”€â”€ é«˜çº§æµ‹è¯•æ¨¡å¼
â”‚   â”œâ”€â”€ å±æ€§æµ‹è¯•
â”‚   â””â”€â”€ æ¨¡ç³Šæµ‹è¯•
â””â”€â”€ æ€§èƒ½å‰–æä¸è°ƒä¼˜
    â”œâ”€â”€ CPU å‰–æ
    â””â”€â”€ å†…å­˜å‰–æ
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| æµ‹è¯•æŠ€æœ¯ | è¦†ç›–åº¦ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | Rust 1.92.0 |
| --- | --- | --- | --- | --- |
| **å•å…ƒæµ‹è¯•** | ä¸­ | ä½ | å‡½æ•°çº§æµ‹è¯• | âœ… |
| **é›†æˆæµ‹è¯•** | é«˜ | ä¸­ | æ¨¡å—çº§æµ‹è¯• | âœ… |
| **ç«¯åˆ°ç«¯æµ‹è¯•** | æœ€é«˜ | é«˜ | ç³»ç»Ÿçº§æµ‹è¯• | âœ… |
| **åŸºå‡†æµ‹è¯•** | - | ä¸­ | æ€§èƒ½æµ‹è¯• | âœ… |
| **å‹åŠ›æµ‹è¯•** | é«˜ | é«˜ | ç¨³å®šæ€§æµ‹è¯• | âœ… |
| **å±æ€§æµ‹è¯•** | æœ€é«˜ | é«˜ | å±æ€§éªŒè¯ | âœ… |
| **æ¨¡ç³Šæµ‹è¯•** | æœ€é«˜ | é«˜ | å®‰å…¨æµ‹è¯• | âœ… |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©æµ‹è¯•æŠ€æœ¯
â”‚
â”œâ”€â”€ éœ€è¦æµ‹è¯•ä»€ä¹ˆï¼Ÿ
â”‚   â”œâ”€â”€ å‡½æ•°çº§ â†’ å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ æ¨¡å—çº§ â†’ é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ ç³»ç»Ÿçº§ â†’ ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ æ€§èƒ½ â†’ åŸºå‡†æµ‹è¯•
â”‚   â”œâ”€â”€ ç¨³å®šæ€§ â†’ å‹åŠ›æµ‹è¯•
â”‚   â”œâ”€â”€ å±æ€§éªŒè¯ â†’ å±æ€§æµ‹è¯•
â”‚   â””â”€â”€ å®‰å…¨ â†’ æ¨¡ç³Šæµ‹è¯•
```

---

## 1. æµ‹è¯•ç­–ç•¥

### 1.1 å•å…ƒæµ‹è¯•

**åŸºç¡€è¿›ç¨‹æµ‹è¯•**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::process::Command;

    #[test]
    fn test_spawn_echo() {
        let output = Command::new("echo")
            .arg("test")
            .output()
            .expect("Failed to spawn");

        assert!(output.status.success());
        assert_eq!(output.stdout, b"test\n");
    }

    #[test]
    fn test_spawn_failure() {
        let result = Command::new("nonexistent_command_12345").spawn();
        assert!(result.is_err());
    }

    #[test]
    fn test_exit_code() {
        let status = Command::new("sh")
            .arg("-c")
            .arg("exit 42")
            .status()
            .unwrap();

        assert_eq!(status.code(), Some(42));
    }
}
```

**Mockè¿›ç¨‹**:

```rust
pub struct MockProcess {
    exit_code: i32,
    stdout: Vec<u8>,
    stderr: Vec<u8>,
    delay: Duration,
}

impl MockProcess {
    pub fn builder() -> MockProcessBuilder {
        MockProcessBuilder::default()
    }

    pub async fn run(&self) -> std::io::Result<MockOutput> {
        tokio::time::sleep(self.delay).await;

        Ok(MockOutput {
            status: MockStatus { code: self.exit_code },
            stdout: self.stdout.clone(),
            stderr: self.stderr.clone(),
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::test]
async fn test_with_mock() {
    let mock = MockProcess::builder()
        .exit_code(0)
        .stdout(b"success")
        .delay(Duration::from_millis(10))
        .build();

    let output = mock.run().await.unwrap();
    assert_eq!(output.stdout, b"success");
}
```

### 1.2 é›†æˆæµ‹è¯•

**è¿›ç¨‹é€šä¿¡æµ‹è¯•**:

```rust
#[tokio::test]
async fn test_process_communication() {
    let mut child = tokio::process::Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();

    let mut stdin = child.stdin.take().unwrap();
    stdin.write_all(b"hello world").await.unwrap();
    drop(stdin);  // å…³é—­stdinä»¥è§¦å‘EOF

    let output = child.wait_with_output().await.unwrap();
    assert_eq!(output.stdout, b"hello world");
}

#[tokio::test]
async fn test_pipeline() {
    // æµ‹è¯•è¿›ç¨‹ç®¡é“ï¼šecho "test" | wc -c
    let echo = tokio::process::Command::new("echo")
        .arg("test")
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();

    let mut wc = tokio::process::Command::new("wc")
        .arg("-c")
        .stdin(echo.stdout.unwrap())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();

    let output = wc.wait_with_output().await.unwrap();
    let count = String::from_utf8_lossy(&output.stdout).trim().parse::<i32>().unwrap();
    assert_eq!(count, 5);  // "test\n" = 5 bytes
}
```

### 1.3 ç«¯åˆ°ç«¯æµ‹è¯•

**å®Œæ•´å·¥ä½œæµæµ‹è¯•**:

```rust
#[tokio::test]
async fn test_process_pool_workflow() {
    let pool = ProcessPool::new(4);

    // 1. æäº¤ä»»åŠ¡
    let tasks: Vec<_> = (0..100).map(|i| Task { id: i }).collect();
    for task in tasks {
        pool.submit(task).await.unwrap();
    }

    // 2. ç­‰å¾…å®Œæˆ
    pool.wait_all().await;

    // 3. éªŒè¯ç»“æœ
    let results = pool.get_results();
    assert_eq!(results.len(), 100);
    assert!(results.iter().all(|r| r.success));
}
```

---

## 2. è¿›ç¨‹æµ‹è¯•æŠ€å·§

### 2.1 è¶…æ—¶å¤„ç†

**æµ‹è¯•è¶…æ—¶ä¿æŠ¤**:

```rust
use tokio::time::{timeout, Duration};

#[tokio::test]
async fn test_with_timeout() {
    let result = timeout(
        Duration::from_secs(5),
        async {
            let output = tokio::process::Command::new("sleep")
                .arg("10")
                .output()
                .await?;
            Ok::<_, std::io::Error>(output)
        }
    ).await;

    assert!(result.is_err(), "åº”è¯¥è¶…æ—¶");
}

// é€šç”¨è¶…æ—¶åŒ…è£…å™¨
pub async fn with_timeout<F, T>(
    duration: Duration,
    future: F,
) -> Result<T, TimeoutError>
where
    F: Future<Output = T>,
{
    timeout(duration, future)
        .await
        .map_err(|_| TimeoutError::new(duration))
}
```

### 2.2 é”™è¯¯æ³¨å…¥

**æ•…éšœæ¨¡æ‹Ÿ**:

```rust
pub struct FaultInjector {
    fail_rate: f64,  // 0.0 - 1.0
}

impl FaultInjector {
    pub fn should_fail(&self) -> bool {
        use rand::Rng;
        rand::thread_rng().gen::<f64>() < self.fail_rate
    }

    pub fn maybe_fail<T, E>(&self, result: Result<T, E>) -> Result<T, E> {
        if self.should_fail() {
            // éšæœºå¤±è´¥
            Err(result.err().unwrap_or_else(|| panic!("No error to inject")))
        } else {
            result
        }
    }
}

#[tokio::test]
async fn test_with_fault_injection() {
    let injector = FaultInjector { fail_rate: 0.5 };

    let mut failures = 0;
    for _ in 0..100 {
        let result = injector.maybe_fail::<(), &str>(Ok(()));
        if result.is_err() {
            failures += 1;
        }
    }

    // åº”è¯¥æœ‰å¤§çº¦50æ¬¡å¤±è´¥
    assert!(failures > 30 && failures < 70);
}
```

### 2.3 åƒµå°¸è¿›ç¨‹å¤„ç†

**è‡ªåŠ¨æ¸…ç†**:

```rust
pub struct ProcessGuard {
    child: Option<Child>,
}

impl ProcessGuard {
    pub fn new(child: Child) -> Self {
        Self { child: Some(child) }
    }

    pub fn pid(&self) -> u32 {
        self.child.as_ref().unwrap().id()
    }
}

impl Drop for ProcessGuard {
    fn drop(&mut self) {
        if let Some(mut child) = self.child.take() {
            // ç¡®ä¿è¿›ç¨‹è¢«æ¸…ç†
            let _ = child.kill();
            let _ = child.wait();
        }
    }
}

#[test]
fn test_no_zombie() {
    let guard = ProcessGuard::new(
        Command::new("sleep").arg("100").spawn().unwrap()
    );

    let pid = guard.pid();
    // guardä¼šåœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨æ¸…ç†è¿›ç¨‹
    drop(guard);

    std::thread::sleep(Duration::from_millis(100));

    // éªŒè¯è¿›ç¨‹å·²è¢«æ¸…ç†
    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;
        let result = kill(Pid::from_raw(pid as i32), Signal::SIGKILL);
        assert!(result.is_err());  // è¿›ç¨‹åº”è¯¥å·²ä¸å­˜åœ¨
    }
}
```

### 2.4 ä¿¡å·å¤„ç†æµ‹è¯•

**ä¿¡å·æµ‹è¯•**:

```rust
#[cfg(unix)]
#[test]
fn test_signal_handling() {
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;

    let mut child = Command::new("sleep")
        .arg("100")
        .spawn()
        .unwrap();

    let pid = child.id();

    // å‘é€SIGTERM
    kill(Pid::from_raw(pid as i32), Signal::SIGTERM).unwrap();

    // ç­‰å¾…è¿›ç¨‹é€€å‡º
    let status = child.wait().unwrap();

    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        assert_eq!(status.signal(), Some(15));  // SIGTERM
    }
}
```

---

## 3. åŸºå‡†æµ‹è¯•

### 3.1 Criterionæ¡†æ¶

**å®Œæ•´åŸºå‡†æµ‹è¯•**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::process::Command;

fn bench_process_spawn(c: &mut Criterion) {
    c.bench_function("spawn_echo", |b| {
        b.iter(|| {
            Command::new("echo")
                .arg(black_box("test"))
                .output()
                .unwrap()
        });
    });
}

fn bench_process_spawn_different_sizes(c: &mut Criterion) {
    let mut group = c.benchmark_group("spawn_with_args");

    for size in [1, 10, 100, 1000].iter() {
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            let args: Vec<_> = (0..size).map(|i| format!("arg{}", i)).collect();
            b.iter(|| {
                Command::new("echo")
                    .args(&args)
                    .output()
                    .unwrap()
            });
        });
    }
    group.finish();
}

criterion_group!(benches, bench_process_spawn, bench_process_spawn_different_sizes);
criterion_main!(benches);
```

### 3.2 IPCåŸºå‡†

**é€šä¿¡æ€§èƒ½æµ‹è¯•**:

```rust
use criterion::{criterion_group, criterion_main, Criterion, Throughput};

fn bench_pipe_throughput(c: &mut Criterion) {
    let mut group = c.benchmark_group("pipe_throughput");

    for size in [1024, 4096, 16384, 65536].iter() {
        group.throughput(Throughput::Bytes(*size as u64));

        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            let data = vec![0u8; size];

            b.iter(|| {
                let mut child = Command::new("cat")
                    .stdin(Stdio::piped())
                    .stdout(Stdio::piped())
                    .spawn()
                    .unwrap();

                child.stdin.as_mut().unwrap().write_all(&data).unwrap();
                drop(child.stdin.take());

                let output = child.wait_with_output().unwrap();
                black_box(output);
            });
        });
    }

    group.finish();
}

criterion_group!(benches, bench_pipe_throughput);
criterion_main!(benches);
```

### 3.3 è¿›ç¨‹æ± åŸºå‡†

**æ± æ€§èƒ½å¯¹æ¯”**:

```rust
fn bench_process_pool(c: &mut Criterion) {
    let mut group = c.benchmark_group("process_pool");

    // åŸºå‡†ï¼šæ— æ± 
    group.bench_function("no_pool", |b| {
        b.iter(|| {
            for _ in 0..10 {
                Command::new("true").status().unwrap();
            }
        });
    });

    // åŸºå‡†ï¼šå›ºå®šæ± 
    group.bench_function("fixed_pool", |b| {
        let pool = ProcessPool::new(4);
        b.iter(|| {
            for _ in 0..10 {
                pool.execute(|| Command::new("true").status()).unwrap();
            }
        });
    });

    // åŸºå‡†ï¼šåŠ¨æ€æ± 
    group.bench_function("dynamic_pool", |b| {
        let pool = DynamicProcessPool::new(2, 8);
        b.iter(|| {
            for _ in 0..10 {
                pool.execute(|| Command::new("true").status()).unwrap();
            }
        });
    });

    group.finish();
}
```

---

## 4. å‹åŠ›æµ‹è¯•

### 4.1 è´Ÿè½½ç”Ÿæˆ

**é«˜å¹¶å‘æµ‹è¯•**:

```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 8)]
async fn test_concurrent_spawns() {
    let handles: Vec<_> = (0..1000)
        .map(|i| {
            tokio::spawn(async move {
                let output = tokio::process::Command::new("echo")
                    .arg(format!("task-{}", i))
                    .output()
                    .await
                    .unwrap();

                assert!(output.status.success());
            })
        })
        .collect();

    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 4.2 ç¨³å®šæ€§æµ‹è¯•

**é•¿æ—¶é—´è¿è¡Œæµ‹è¯•**:

```rust
#[tokio::test]
#[ignore]  // ä½¿ç”¨ cargo test -- --ignored è¿è¡Œ
async fn test_stability_24h() {
    let start = Instant::now();
    let target_duration = Duration::from_secs(24 * 3600);

    let mut iterations = 0;
    let mut failures = 0;

    while start.elapsed() < target_duration {
        match spawn_and_run_task().await {
            Ok(_) => iterations += 1,
            Err(e) => {
                failures += 1;
                eprintln!("Failure: {:?}", e);
            }
        }

        if iterations % 1000 == 0 {
            println!("Iterations: {}, Failures: {}, Uptime: {:?}",
                iterations, failures, start.elapsed());
        }
    }

    let failure_rate = failures as f64 / iterations as f64;
    assert!(failure_rate < 0.001, "æ•…éšœç‡è¿‡é«˜: {:.4}%", failure_rate * 100.0);
}
```

### 4.3 å†…å­˜æ³„æ¼æ£€æµ‹

**å†…å­˜å¢é•¿æµ‹è¯•**:

```rust
#[test]
fn test_no_memory_leak() {
    use sysinfo::{System, SystemExt, ProcessExt};

    let mut system = System::new_all();
    let pid = sysinfo::Pid::from(std::process::id() as usize);

    system.refresh_all();
    let initial_memory = system.process(pid).unwrap().memory();

    // è¿è¡Œ1000æ¬¡æ“ä½œ
    for _ in 0..1000 {
        let child = Command::new("echo")
            .arg("test")
            .spawn()
            .unwrap();
        child.wait_with_output().unwrap();
    }

    system.refresh_all();
    let final_memory = system.process(pid).unwrap().memory();

    let growth = (final_memory as f64 - initial_memory as f64) / initial_memory as f64;

    // å…è®¸10%çš„å†…å­˜å¢é•¿
    assert!(growth < 0.10, "å†…å­˜å¢é•¿è¿‡å¤§: {:.2}%", growth * 100.0);
}
```

### 4.4 èµ„æºè€—å°½æµ‹è¯•

**æ–‡ä»¶æè¿°ç¬¦æµ‹è¯•**:

```rust
#[test]
fn test_fd_exhaustion() {
    let max_fds = 100;
    let mut children = Vec::new();

    for i in 0..max_fds {
        match Command::new("sleep").arg("1").spawn() {
            Ok(child) => children.push(child),
            Err(e) => {
                eprintln!("Failed at {}: {:?}", i, e);
                break;
            }
        }
    }

    // æ¸…ç†
    for mut child in children {
        child.kill().ok();
        child.wait().ok();
    }
}
```

---

## 5. CI/CDé›†æˆ

### 5.1 GitHub Actions

**å®Œæ•´CIé…ç½®**:

```yaml
# .github/workflows/test.yml
name: Process Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable, beta, nightly]

    steps:
    - uses: actions/checkout@v2

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: ${{ matrix.rust }}
        override: true

    - name: Run tests
      run: cargo test --all-features

    - name: Run benchmarks
      run: cargo bench --no-run

    - name: Run stress tests
      run: cargo test --release -- --ignored --test-threads=1

  coverage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin

    - name: Generate coverage
      run: cargo tarpaulin --out Xml

    - name: Upload coverage
      uses: codecov/codecov-action@v2
```

### 5.2 æ€§èƒ½å›å½’æ£€æµ‹

**è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•**:

```yaml
name: Performance Regression

on:
  pull_request:
    branches: [ main ]

jobs:
  bench:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable

    - name: Run benchmarks (baseline)
      run: |
        git checkout main
        cargo bench --bench process_bench -- --save-baseline main

    - name: Run benchmarks (PR)
      run: |
        git checkout ${{ github.sha }}
        cargo bench --bench process_bench -- --baseline main

    - name: Check for regression
      run: |
        if grep -q "regressed" target/criterion/*/report/index.html; then
          echo "Performance regression detected!"
          exit 1
        fi
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ï¼šå®Œæ•´æµ‹è¯•å¥—ä»¶

**æµ‹è¯•ç»„ç»‡ç»“æ„**:

```text
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ process_spawn_test.rs
â”‚   â”œâ”€â”€ process_pool_test.rs
â”‚   â””â”€â”€ ipc_test.rs
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ workflow_test.rs
â”‚   â””â”€â”€ error_handling_test.rs
â”œâ”€â”€ stress/
â”‚   â”œâ”€â”€ concurrent_test.rs
â”‚   â””â”€â”€ stability_test.rs
â””â”€â”€ benches/
    â”œâ”€â”€ spawn_bench.rs
    â””â”€â”€ pool_bench.rs
```

**æµ‹è¯•è¾…åŠ©å·¥å…·**:

```rust
// tests/common/mod.rs
pub struct TestContext {
    temp_dir: TempDir,
    process_guard: Vec<ProcessGuard>,
}

impl TestContext {
    pub fn new() -> Self {
        Self {
            temp_dir: TempDir::new().unwrap(),
            process_guard: Vec::new(),
        }
    }

    pub fn spawn_guarded(&mut self, cmd: Command) -> std::io::Result<&mut Child> {
        let child = cmd.spawn()?;
        self.process_guard.push(ProcessGuard::new(child));
        Ok(self.process_guard.last_mut().unwrap().child())
    }

    pub fn temp_file(&self, name: &str) -> PathBuf {
        self.temp_dir.path().join(name)
    }
}

impl Drop for TestContext {
    fn drop(&mut self) {
        // è‡ªåŠ¨æ¸…ç†æ‰€æœ‰è¿›ç¨‹å’Œä¸´æ—¶æ–‡ä»¶
        self.process_guard.clear();
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[test]
fn test_with_context() {
    let mut ctx = TestContext::new();

    let child = ctx.spawn_guarded(
        Command::new("echo").arg("test")
    ).unwrap();

    let output = child.wait_with_output().unwrap();
    assert!(output.status.success());

    // ctxè¢«dropæ—¶è‡ªåŠ¨æ¸…ç†
}
```

---

## 7. æœ€ä½³å®è·µ

**1. æµ‹è¯•éš”ç¦»**:

```rust
// âœ… æ¨èï¼šæ¯ä¸ªæµ‹è¯•ç‹¬ç«‹
#[test]
fn test_isolated() {
    let temp_dir = tempfile::tempdir().unwrap();
    // æµ‹è¯•é€»è¾‘
} // temp_dirè‡ªåŠ¨æ¸…ç†

// âŒ é¿å…ï¼šå…±äº«çŠ¶æ€
static SHARED: Mutex<State> = Mutex::new(State::new());
```

**2. ç¡®å®šæ€§æµ‹è¯•**:

```rust
// âœ… æ¨èï¼šç¡®å®šæ€§
#[test]
fn test_deterministic() {
    let output = Command::new("echo").arg("test").output().unwrap();
    assert_eq!(output.stdout, b"test\n");
}

// âŒ é¿å…ï¼šä¾èµ–æ—¶é—´
#[test]
fn test_timing_dependent() {
    let start = Instant::now();
    // å¯èƒ½åœ¨ä¸åŒæœºå™¨ä¸Šå¤±è´¥
    assert!(start.elapsed() < Duration::from_millis(10));
}
```

**3. å¿«é€Ÿåé¦ˆ**:

- âœ… å•å…ƒæµ‹è¯• < 100ms
- âœ… é›†æˆæµ‹è¯• < 5s
- âœ… å‹åŠ›æµ‹è¯•æ ‡è®°ä¸º`#[ignore]`

**4. æ¸…ç†èµ„æº**:

```rust
// âœ… ä½¿ç”¨RAII
pub struct TestProcess(Child);

impl Drop for TestProcess {
    fn drop(&mut self) {
        self.0.kill().ok();
        self.0.wait().ok();
    }
}
```

**5. æœ‰æ„ä¹‰çš„æ–­è¨€**:

```rust
// âœ… æ¨èï¼šæ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯
assert_eq!(actual, expected, "è¿›ç¨‹è¾“å‡ºä¸åŒ¹é…: {:?}", actual);

// âŒ é¿å…ï¼šæ— ä¿¡æ¯çš„æ–­è¨€
assert!(condition);
```

---

## æ€»ç»“

**æµ‹è¯•ä¸åŸºå‡†æ ¸å¿ƒè¦ç´ **:

1. âœ… **æµ‹è¯•ç­–ç•¥**: å•å…ƒ/é›†æˆ/ç«¯åˆ°ç«¯
2. âœ… **æµ‹è¯•æŠ€å·§**: è¶…æ—¶/é”™è¯¯æ³¨å…¥/åƒµå°¸æ¸…ç†/ä¿¡å·æµ‹è¯•
3. âœ… **åŸºå‡†æµ‹è¯•**: Criterionæ¡†æ¶/IPCæ€§èƒ½/æ± å¯¹æ¯”
4. âœ… **å‹åŠ›æµ‹è¯•**: é«˜å¹¶å‘/ç¨³å®šæ€§/å†…å­˜æ³„æ¼/èµ„æºè€—å°½
5. âœ… **CI/CD**: GitHub Actions/æ€§èƒ½å›å½’æ£€æµ‹
6. âœ… **æœ€ä½³å®è·µ**: éš”ç¦»/ç¡®å®šæ€§/å¿«é€Ÿåé¦ˆ/æ¸…ç†/æ–­è¨€

**æµ‹è¯•é‡‘å­—å¡”**:

```text
    /\        E2Eæµ‹è¯• (å°‘é‡, æ…¢)
   /  \
  /    \      é›†æˆæµ‹è¯• (ä¸­ç­‰)
 /      \
/________\    å•å…ƒæµ‹è¯• (å¤§é‡, å¿«)
```

---

## 8. é«˜çº§æµ‹è¯•æ¨¡å¼

### 8.1 å±æ€§æµ‹è¯•ï¼ˆProperty-based Testingï¼‰

**ä½¿ç”¨proptestæ¡†æ¶**:

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_echo_preserves_input(input in "\\PC*") {
        let output = std::process::Command::new("echo")
            .arg(&input)
            .output()
            .unwrap();

        let result = String::from_utf8_lossy(&output.stdout);
        // echoä¼šæ·»åŠ æ¢è¡Œç¬¦
        prop_assert!(result.starts_with(&input));
    }

    #[test]
    fn test_wc_counts_correctly(lines in prop::collection::vec(".*", 0..100)) {
        use std::io::Write;

        let input = lines.join("\n");
        let expected_count = lines.len();

        let mut child = std::process::Command::new("wc")
            .arg("-l")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .spawn()
            .unwrap();

        child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();
        let output = child.wait_with_output().unwrap();

        let count: usize = String::from_utf8_lossy(&output.stdout)
            .trim()
            .parse()
            .unwrap();

        prop_assert_eq!(count, expected_count);
    }
}
```

**è¿›ç¨‹å‚æ•°æ¨¡ç³Šæµ‹è¯•**:

```rust
use proptest::prelude::*;

fn valid_arg_strategy() -> impl Strategy<Value = String> {
    prop::string::string_regex("[a-zA-Z0-9_-]{1,100}").unwrap()
}

proptest! {
    #[test]
    fn test_process_handles_any_valid_arg(arg in valid_arg_strategy()) {
        let result = std::process::Command::new("echo")
            .arg(&arg)
            .output();

        // åº”è¯¥æ€»èƒ½æˆåŠŸå¤„ç†æœ‰æ•ˆå‚æ•°
        prop_assert!(result.is_ok());
    }

    #[test]
    fn test_concurrent_spawn_property(
        count in 1usize..50,
        args in prop::collection::vec(valid_arg_strategy(), 0..10)
    ) {
        let rt = tokio::runtime::Runtime::new().unwrap();

        rt.block_on(async {
            let mut tasks = Vec::new();

            for _ in 0..count {
                let args_clone = args.clone();
                tasks.push(tokio::spawn(async move {
                    tokio::process::Command::new("echo")
                        .args(&args_clone)
                        .output()
                        .await
                }));
            }

            let results: Vec<_> = futures::future::join_all(tasks)
                .await
                .into_iter()
                .collect();

            // æ‰€æœ‰ä»»åŠ¡éƒ½åº”è¯¥æˆåŠŸå®Œæˆ
            for result in results {
                prop_assert!(result.is_ok());
                prop_assert!(result.unwrap().is_ok());
            }

            Ok(())
        })?;
    }
}
```

### 8.2 æ¨¡ç³Šæµ‹è¯•ï¼ˆFuzzingï¼‰

**cargo-fuzzé›†æˆ**:

```bash
# å®‰è£…cargo-fuzz
cargo install cargo-fuzz

# åˆå§‹åŒ–fuzz target
cargo fuzz init

# åˆ›å»ºfuzz target
cargo fuzz add process_args
```

**Fuzz targetå®ç°**:

```rust
// fuzz/fuzz_targets/process_args.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use std::process::Command;

fuzz_target!(|data: &[u8]| {
    // å°†éšæœºå­—èŠ‚è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    if let Ok(arg) = std::str::from_utf8(data) {
        // æµ‹è¯•è¿›ç¨‹æ˜¯å¦èƒ½å¤„ç†ä»»æ„è¾“å…¥
        let _ = Command::new("echo")
            .arg(arg)
            .output();
    }
});
```

**é«˜çº§æ¨¡ç³Šæµ‹è¯•ç­–ç•¥**:

```rust
// fuzz/fuzz_targets/ipc_fuzzing.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
struct IpcInput {
    pipe_data: Vec<u8>,
    timeout_ms: u16,
    env_vars: Vec<(String, String)>,
}

fuzz_target!(|input: IpcInput| {
    use std::io::Write;
    use std::time::Duration;

    let mut child = std::process::Command::new("cat")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .envs(input.env_vars.iter().map(|(k, v)| (k, v)))
        .spawn();

    if let Ok(mut child) = child {
        // å†™å…¥æ•°æ®
        if let Some(mut stdin) = child.stdin.take() {
            let _ = stdin.write_all(&input.pipe_data);
            drop(stdin);
        }

        // å¸¦è¶…æ—¶ç­‰å¾…
        let timeout = Duration::from_millis(input.timeout_ms as u64);
        let _ = std::thread::spawn(move || {
            std::thread::sleep(timeout);
            let _ = child.kill();
        });
    }
});
```

### 8.3 æµ‹è¯•è¦†ç›–ç‡

**ä½¿ç”¨tarpaulin**:

```bash
# å®‰è£…
cargo install cargo-tarpaulin

# è¿è¡Œè¦†ç›–ç‡æµ‹è¯•
cargo tarpaulin --out Html --out Xml

# ç”ŸæˆæŠ¥å‘Š
cargo tarpaulin --out Html --output-dir coverage/
```

**é…ç½®tarpaulin.toml**:

```toml
[tarpaulin]
# æ’é™¤æ–‡ä»¶
exclude = [
    "*/tests/*",
    "*/benches/*",
]

# è¶…æ—¶è®¾ç½®
timeout = 600

# æœ€å°è¦†ç›–ç‡
fail-under = 80.0

# è¾“å‡ºæ ¼å¼
output-format = ["Html", "Lcov"]
```

**è¦†ç›–ç‡ç›®æ ‡å®ç°**:

```rust
// ç¡®ä¿å…³é”®è·¯å¾„è¢«æµ‹è¯•è¦†ç›–
pub fn critical_process_function() -> Result<(), Error> {
    let output = Command::new("critical_command")
        .output()?;

    // åˆ†æ”¯1: æˆåŠŸ
    if output.status.success() {
        return Ok(());
    }

    // åˆ†æ”¯2: å¤±è´¥
    if let Some(code) = output.status.code() {
        return Err(Error::ExitCode(code));
    }

    // åˆ†æ”¯3: è¢«ä¿¡å·ç»ˆæ­¢
    #[cfg(unix)]
    {
        use std::os::unix::process::ExitStatusExt;
        if let Some(signal) = output.status.signal() {
            return Err(Error::Signal(signal));
        }
    }

    Err(Error::Unknown)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success_path() {
        // è¦†ç›–æˆåŠŸåˆ†æ”¯
    }

    #[test]
    fn test_failure_path() {
        // è¦†ç›–å¤±è´¥åˆ†æ”¯
    }

    #[test]
    #[cfg(unix)]
    fn test_signal_path() {
        // è¦†ç›–ä¿¡å·åˆ†æ”¯
    }
}
```

---

## 9. æ€§èƒ½å‰–æä¸è°ƒä¼˜

### 9.1 CPUå‰–æ

**ä½¿ç”¨flamegraph**:

```bash
# å®‰è£…
cargo install flamegraph

# ç”ŸæˆCPUç«ç„°å›¾
cargo flamegraph --bin process-manager

# å¸¦åŸºå‡†æµ‹è¯•
cargo flamegraph --bench process_bench
```

**é›†æˆåˆ°æµ‹è¯•ä¸­**:

```rust
#[cfg(test)]
mod profiling {
    use std::fs::File;

    #[test]
    #[ignore]  // åªåœ¨éœ€è¦æ—¶è¿è¡Œ
    fn profile_spawn_performance() {
        let guard = pprof::ProfilerGuardBuilder::default()
            .frequency(1000)
            .build()
            .unwrap();

        // æ‰§è¡Œéœ€è¦å‰–æçš„ä»£ç 
        for _ in 0..1000 {
            let _ = std::process::Command::new("true")
                .spawn()
                .unwrap()
                .wait();
        }

        // ç”ŸæˆæŠ¥å‘Š
        if let Ok(report) = guard.report().build() {
            let file = File::create("flamegraph.svg").unwrap();
            report.flamegraph(file).unwrap();
        }
    }
}
```

### 9.2 å†…å­˜å‰–æ

**ä½¿ç”¨valgrind/massif**:

```bash
# è¿è¡Œå†…å­˜å‰–æ
valgrind --tool=massif \
         --massif-out-file=massif.out \
         ./target/release/process-manager

# å¯è§†åŒ–
massif-visualizer massif.out
```

**å†…å­˜æ³„æ¼æ£€æµ‹**:

```rust
#[cfg(test)]
mod memory_tests {
    use std::process::Command;

    #[test]
    fn test_no_memory_leak() {
        let initial = get_memory_usage();

        // æ‰§è¡Œå¤§é‡æ“ä½œ
        for _ in 0..1000 {
            let output = Command::new("echo")
                .arg("test")
                .output()
                .unwrap();

            drop(output);  // ç¡®ä¿é‡Šæ”¾
        }

        // å¼ºåˆ¶GC
        std::mem::drop(vec![0u8; 1024 * 1024]);

        let final_usage = get_memory_usage();
        let growth = final_usage - initial;

        // å¢é•¿åº”è¯¥å°äº1MB
        assert!(growth < 1024 * 1024, "å†…å­˜æ³„æ¼: {} bytes", growth);
    }

    fn get_memory_usage() -> usize {
        #[cfg(target_os = "linux")]
        {
            use std::fs;
            let status = fs::read_to_string("/proc/self/status").unwrap();

            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        return parts[1].parse::<usize>().unwrap() * 1024;
                    }
                }
            }
        }

        0
    }
}
```

### 9.3 ç³»ç»Ÿè°ƒç”¨è·Ÿè¸ª

**ä½¿ç”¨strace**:

```bash
# è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨
strace -c ./target/release/process-manager

# è¯¦ç»†è·Ÿè¸ª
strace -tt -T -o strace.log ./target/release/process-manager

# åªè·Ÿè¸ªè¿›ç¨‹ç›¸å…³ç³»ç»Ÿè°ƒç”¨
strace -e trace=process ./target/release/process-manager
```

**ç¨‹åºåŒ–ç³»ç»Ÿè°ƒç”¨åˆ†æ**:

```rust
#[cfg(test)]
mod syscall_tests {
    use std::process::Command;

    #[test]
    #[cfg(target_os = "linux")]
    fn test_syscall_count() {
        // ä½¿ç”¨straceç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨
        let output = Command::new("strace")
            .arg("-c")
            .arg("-e")
            .arg("trace=process")
            .arg("./target/release/test-binary")
            .output()
            .unwrap();

        let stderr = String::from_utf8_lossy(&output.stderr);

        // è§£æè¾“å‡ºï¼ŒéªŒè¯ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°åˆç†
        assert!(stderr.contains("execve"));
        assert!(stderr.contains("clone") || stderr.contains("fork"));
    }
}
```

---

## 10. è°ƒè¯•æŠ€å·§

### 10.1 æ¡ä»¶æ–­ç‚¹

**ä½¿ç”¨gdbè°ƒè¯•**:

```bash
# ç¼–è¯‘debugç‰ˆæœ¬
cargo build

# å¯åŠ¨gdb
gdb ./target/debug/process-manager

# è®¾ç½®æ¡ä»¶æ–­ç‚¹
(gdb) break spawn_process if pid > 1000
(gdb) run
```

### 10.2 æ—¥å¿—é©±åŠ¨æµ‹è¯•

**ç»“æ„åŒ–æ—¥å¿—**:

```rust
use tracing::{info, warn, error, instrument};
use tracing_subscriber;

#[instrument]
pub async fn spawn_monitored(cmd: &str) -> Result<Child, Error> {
    info!("å°è¯•spawnè¿›ç¨‹: {}", cmd);

    let child = tokio::process::Command::new(cmd)
        .spawn()
        .map_err(|e| {
            error!("spawnå¤±è´¥: {}", e);
            Error::SpawnFailed(e)
        })?;

    info!("spawnæˆåŠŸ, PID: {:?}", child.id());
    Ok(child)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_subscriber::fmt::format::FmtSpan;

    #[tokio::test]
    async fn test_with_tracing() {
        // åˆå§‹åŒ–tracing
        tracing_subscriber::fmt()
            .with_span_events(FmtSpan::FULL)
            .with_test_writer()
            .init();

        let result = spawn_monitored("echo").await;
        assert!(result.is_ok());

        // æ—¥å¿—ä¼šåœ¨æµ‹è¯•å¤±è´¥æ—¶æ˜¾ç¤º
    }
}
```

### 10.3 æ—¶é—´æ—…è¡Œè°ƒè¯•

**ä½¿ç”¨rr (Record and Replay)**:

```bash
# å½•åˆ¶æ‰§è¡Œ
rr record ./target/debug/process-manager

# é‡æ”¾è°ƒè¯•
rr replay

# åœ¨gdbä¸­å¯ä»¥å‰è¿›/åé€€
(gdb) reverse-continue
(gdb) reverse-step
```

---

## 11. æµ‹è¯•æ•°æ®ç®¡ç†

### 11.1 Fixtureç®¡ç†

**ä½¿ç”¨rstest**:

```rust
use rstest::*;

#[fixture]
fn test_env() -> TestEnvironment {
    TestEnvironment::new()
}

#[rstest]
fn test_with_fixture(test_env: TestEnvironment) {
    let output = Command::new("echo")
        .env("TEST_VAR", test_env.var())
        .output()
        .unwrap();

    assert!(output.status.success());
}

#[rstest]
#[case("echo", vec!["hello"])]
#[case("ls", vec!["-la"])]
#[case("pwd", vec![])]
fn test_multiple_commands(#[case] cmd: &str, #[case] args: Vec<&str>) {
    let result = Command::new(cmd)
        .args(&args)
        .output();

    assert!(result.is_ok());
}
```

### 11.2 å¿«ç…§æµ‹è¯•

**ä½¿ç”¨insta**:

```rust
use insta::assert_snapshot;

#[test]
fn test_process_output_snapshot() {
    let output = Command::new("ls")
        .arg("-1")
        .output()
        .unwrap();

    let stdout = String::from_utf8_lossy(&output.stdout);

    // é¦–æ¬¡è¿è¡Œåˆ›å»ºå¿«ç…§ï¼Œåç»­è¿è¡Œå¯¹æ¯”
    assert_snapshot!(stdout);
}

#[test]
fn test_error_message_snapshot() {
    let result = Command::new("nonexistent")
        .spawn();

    assert!(result.is_err());
    let error_msg = format!("{:?}", result.unwrap_err());

    assert_snapshot!(error_msg);
}
```

---

## 12. æŒç»­æ€§èƒ½ç›‘æ§

### 12.1 æ€§èƒ½å›å½’æ£€æµ‹

**è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•**:

```rust
use criterion::{criterion_group, criterion_main, Criterion};
use std::fs;

fn load_baseline() -> Option<f64> {
    fs::read_to_string("baseline.txt")
        .ok()?
        .trim()
        .parse()
        .ok()
}

fn save_baseline(value: f64) {
    fs::write("baseline.txt", value.to_string()).ok();
}

fn bench_with_regression_check(c: &mut Criterion) {
    let mut group = c.benchmark_group("regression_check");

    group.bench_function("spawn", |b| {
        b.iter(|| {
            Command::new("true").output().unwrap()
        });
    });

    group.finish();

    // æ£€æŸ¥æ€§èƒ½å›å½’
    let current = get_median_time();

    if let Some(baseline) = load_baseline() {
        let regression = (current - baseline) / baseline * 100.0;

        if regression > 10.0 {
            panic!("æ€§èƒ½å›å½’ {:.2}%ï¼", regression);
        }
    } else {
        save_baseline(current);
    }
}

fn get_median_time() -> f64 {
    // ä»criterionæŠ¥å‘Šä¸­æå–ä¸­ä½æ•°æ—¶é—´
    1.0  // ç®€åŒ–ç¤ºä¾‹
}

criterion_group!(benches, bench_with_regression_check);
criterion_main!(benches);
```

### 12.2 æŒç»­é›†æˆæŠ¥å‘Š

**GitHub Actionsé›†æˆ**:

```yaml
name: Performance Tests

on:
  pull_request:
    branches: [ main ]

jobs:
  performance:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: è¿è¡ŒåŸºå‡†æµ‹è¯•
      run: cargo bench -- --save-baseline PR

    - name: å¯¹æ¯”æ€§èƒ½
      run: |
        cargo bench -- --baseline main --load-baseline PR

    - name: ä¸Šä¼ æŠ¥å‘Š
      uses: actions/upload-artifact@v3
      with:
        name: criterion-report
        path: target/criterion/

    - name: è¯„è®ºPR
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('perf-report.md', 'utf8');

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.name,
            body: report
          });
```

---

**ä¸‹ä¸€æ­¥**: [05_ç°ä»£è¿›ç¨‹åº“.md](./05_ç°ä»£è¿›ç¨‹åº“.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
