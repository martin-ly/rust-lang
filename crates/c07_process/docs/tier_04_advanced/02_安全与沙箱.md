# Tier 4: 安全与沙箱

> **文档类型**: 高级主题  
> **难度**: ⭐⭐⭐⭐⭐  
> **适用版本**: Rust 1.90+  
> **前置知识**: [跨平台实践](../tier_02_guides/04_跨平台实践.md)

---

## 目录

- [Tier 4: 安全与沙箱](#tier-4-安全与沙箱)
  - [目录](#目录)
  - [1. 进程隔离技术](#1-进程隔离技术)
    - [1.1 权限降级](#11-权限降级)
    - [1.2 用户与组管理](#12-用户与组管理)
    - [1.3 Capabilities](#13-capabilities)
  - [2. 资源限制](#2-资源限制)
    - [2.1 rlimit配置](#21-rlimit配置)
    - [2.2 cgroups控制](#22-cgroups控制)
    - [2.3 内存与CPU限制](#23-内存与cpu限制)
  - [3. 容器化技术](#3-容器化技术)
    - [3.1 Linux Namespaces](#31-linux-namespaces)
    - [3.2 网络隔离](#32-网络隔离)
    - [3.3 文件系统隔离](#33-文件系统隔离)
  - [4. 安全机制](#4-安全机制)
    - [4.1 Seccomp过滤](#41-seccomp过滤)
    - [4.2 AppArmor/SELinux](#42-apparmorselinux)
    - [4.3 审计日志](#43-审计日志)
  - [5. 沙箱实现](#5-沙箱实现)
    - [完整的沙箱系统](#完整的沙箱系统)
  - [6. 最佳实践](#6-最佳实践)
  - [总结](#总结)
  - [7. 容器安全](#7-容器安全)
    - [7.1 Docker容器安全](#71-docker容器安全)
    - [7.2 进程安全审计](#72-进程安全审计)
  - [8. 威胁模型](#8-威胁模型)
    - [8.1 常见攻击向量](#81-常见攻击向量)
  - [9. 安全配置模板](#9-安全配置模板)
    - [9.1 高安全级别配置](#91-高安全级别配置)
    - [9.2 开发环境配置](#92-开发环境配置)
  - [10. 安全测试](#10-安全测试)
    - [10.1 安全测试套件](#101-安全测试套件)
    - [10.2 渗透测试清单](#102-渗透测试清单)

---

## 1. 进程隔离技术

### 1.1 权限降级

**原理**: 以最小权限运行进程，降低安全风险。

**Unix权限降级**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;
use std::process::Command;

#[cfg(unix)]
pub fn spawn_with_dropped_privileges(
    program: &str,
    user: &str,
    group: &str,
) -> std::io::Result<std::process::Child> {
    use nix::unistd::{User, Group, Uid, Gid};
    
    // 查找用户和组
    let user_info = User::from_name(user)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("User {} not found", user),
        ))?;
    
    let group_info = Group::from_name(group)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("Group {} not found", group),
        ))?;
    
    // 创建子进程并降级权限
    Command::new(program)
        .uid(user_info.uid.as_raw())
        .gid(group_info.gid.as_raw())
        .spawn()
}

// 使用示例
fn main() -> std::io::Result<()> {
    // 以nobody用户运行worker
    let child = spawn_with_dropped_privileges("worker", "nobody", "nogroup")?;
    
    println!("Worker进程启动，PID: {}", child.id());
    
    Ok(())
}
```

**Windows权限控制**:

```rust
#[cfg(windows)]
use windows_sys::Win32::Security::*;

#[cfg(windows)]
pub fn create_restricted_token() -> std::io::Result<()> {
    // Windows需要使用CreateRestrictedToken API
    // 限制进程的访问令牌
    unimplemented!("Windows实现需要使用Win32 API")
}
```

---

### 1.2 用户与组管理

**多用户隔离**:

```rust
use std::collections::HashMap;

pub struct UserIsolation {
    user_map: HashMap<String, UserConfig>,
}

pub struct UserConfig {
    pub uid: u32,
    pub gid: u32,
    pub home_dir: String,
    pub allowed_commands: Vec<String>,
}

impl UserIsolation {
    pub fn new() -> Self {
        Self {
            user_map: HashMap::new(),
        }
    }
    
    pub fn add_user(&mut self, name: String, config: UserConfig) {
        self.user_map.insert(name, config);
    }
    
    pub fn spawn_for_user(&self, user: &str, command: &str) 
        -> std::io::Result<std::process::Child> 
    {
        let config = self.user_map.get(user)
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "User not found",
            ))?;
        
        // 检查命令是否允许
        if !config.allowed_commands.contains(&command.to_string()) {
            return Err(std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                "Command not allowed",
            ));
        }
        
        #[cfg(unix)]
        {
            use std::os::unix::process::CommandExt;
            std::process::Command::new(command)
                .uid(config.uid)
                .gid(config.gid)
                .env("HOME", &config.home_dir)
                .spawn()
        }
        
        #[cfg(not(unix))]
        {
            std::process::Command::new(command).spawn()
        }
    }
}
```

---

### 1.3 Capabilities

**Linux Capabilities细粒度权限控制**:

```rust
#[cfg(target_os = "linux")]
use caps::{Capability, CapSet, set};

#[cfg(target_os = "linux")]
pub fn drop_all_capabilities() -> Result<(), Box<dyn std::error::Error>> {
    // 移除所有capabilities
    caps::clear(None, CapSet::Effective)?;
    caps::clear(None, CapSet::Permitted)?;
    caps::clear(None, CapSet::Inheritable)?;
    
    Ok(())
}

#[cfg(target_os = "linux")]
pub fn set_minimal_capabilities() -> Result<(), Box<dyn std::error::Error>> {
    use caps::Capability::*;
    
    // 仅保留必要的capabilities
    let required_caps = vec![
        CAP_NET_BIND_SERVICE,  // 绑定<1024端口
        CAP_CHOWN,             // 修改文件所有权
    ];
    
    // 清除所有
    drop_all_capabilities()?;
    
    // 设置必要的
    for cap in required_caps {
        set(None, CapSet::Effective, cap)?;
        set(None, CapSet::Permitted, cap)?;
    }
    
    Ok(())
}
```

---

## 2. 资源限制

### 2.1 rlimit配置

**完整的资源限制**:

```rust
#[cfg(unix)]
use nix::sys::resource::{setrlimit, getrlimit, Resource};

#[cfg(unix)]
pub struct ResourceLimits {
    cpu_seconds: Option<u64>,
    memory_bytes: Option<u64>,
    open_files: Option<u64>,
    processes: Option<u64>,
}

#[cfg(unix)]
impl ResourceLimits {
    pub fn new() -> Self {
        Self {
            cpu_seconds: None,
            memory_bytes: None,
            open_files: None,
            processes: None,
        }
    }
    
    pub fn cpu(mut self, seconds: u64) -> Self {
        self.cpu_seconds = Some(seconds);
        self
    }
    
    pub fn memory(mut self, bytes: u64) -> Self {
        self.memory_bytes = Some(bytes);
        self
    }
    
    pub fn open_files(mut self, count: u64) -> Self {
        self.open_files = Some(count);
        self
    }
    
    pub fn processes(mut self, count: u64) -> Self {
        self.processes = Some(count);
        self
    }
    
    pub fn apply(&self) -> nix::Result<()> {
        if let Some(cpu) = self.cpu_seconds {
            setrlimit(Resource::RLIMIT_CPU, cpu, cpu)?;
        }
        
        if let Some(mem) = self.memory_bytes {
            setrlimit(Resource::RLIMIT_AS, mem, mem)?;
        }
        
        if let Some(files) = self.open_files {
            setrlimit(Resource::RLIMIT_NOFILE, files, files)?;
        }
        
        if let Some(procs) = self.processes {
            setrlimit(Resource::RLIMIT_NPROC, procs, procs)?;
        }
        
        Ok(())
    }
}

// 使用示例
fn spawn_limited_process() -> std::io::Result<()> {
    let limits = ResourceLimits::new()
        .cpu(10)                    // 10秒CPU时间
        .memory(100 * 1024 * 1024)  // 100MB内存
        .open_files(64)             // 64个文件描述符
        .processes(10);             // 10个子进程
    
    // 在fork前应用限制
    #[cfg(unix)]
    {
        use std::os::unix::process::CommandExt;
        
        std::process::Command::new("worker")
            .pre_exec(move || {
                limits.apply()
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))
            })
            .spawn()?;
    }
    
    Ok(())
}
```

---

### 2.2 cgroups控制

**cgroups v2集成**:

```rust
use std::fs;
use std::path::PathBuf;

pub struct CgroupController {
    cgroup_path: PathBuf,
}

impl CgroupController {
    pub fn new(name: &str) -> std::io::Result<Self> {
        let cgroup_path = PathBuf::from("/sys/fs/cgroup")
            .join("user.slice")
            .join(name);
        
        // 创建cgroup目录
        fs::create_dir_all(&cgroup_path)?;
        
        Ok(Self { cgroup_path })
    }
    
    pub fn set_memory_limit(&self, bytes: u64) -> std::io::Result<()> {
        let limit_path = self.cgroup_path.join("memory.max");
        fs::write(limit_path, bytes.to_string())?;
        Ok(())
    }
    
    pub fn set_cpu_weight(&self, weight: u64) -> std::io::Result<()> {
        // CPU权重：1-10000
        let weight_path = self.cgroup_path.join("cpu.weight");
        fs::write(weight_path, weight.to_string())?;
        Ok(())
    }
    
    pub fn add_process(&self, pid: u32) -> std::io::Result<()> {
        let procs_path = self.cgroup_path.join("cgroup.procs");
        fs::write(procs_path, pid.to_string())?;
        Ok(())
    }
    
    pub fn get_memory_usage(&self) -> std::io::Result<u64> {
        let current_path = self.cgroup_path.join("memory.current");
        let content = fs::read_to_string(current_path)?;
        content.trim().parse()
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }
}

// 使用示例
fn spawn_with_cgroups() -> std::io::Result<()> {
    let cgroup = CgroupController::new("my_worker")?;
    
    // 设置限制
    cgroup.set_memory_limit(100 * 1024 * 1024)?;  // 100MB
    cgroup.set_cpu_weight(100)?;                   // 默认权重
    
    // 启动进程
    let child = std::process::Command::new("worker").spawn()?;
    
    // 将进程加入cgroup
    cgroup.add_process(child.id())?;
    
    println!("进程 {} 已加入cgroup", child.id());
    
    Ok(())
}
```

---

### 2.3 内存与CPU限制

**运行时监控与限制**:

```rust
use sysinfo::{System, SystemExt, ProcessExt};

pub struct RuntimeLimiter {
    max_memory: u64,
    max_cpu_percent: f32,
    system: System,
}

impl RuntimeLimiter {
    pub fn new(max_memory: u64, max_cpu_percent: f32) -> Self {
        Self {
            max_memory,
            max_cpu_percent,
            system: System::new_all(),
        }
    }
    
    pub fn check_and_limit(&mut self, pid: u32) -> bool {
        self.system.refresh_all();
        
        if let Some(process) = self.system.process(sysinfo::Pid::from(pid as usize)) {
            // 检查内存
            if process.memory() > self.max_memory {
                eprintln!("进程 {} 超出内存限制", pid);
                return false;
            }
            
            // 检查CPU
            if process.cpu_usage() > self.max_cpu_percent {
                eprintln!("进程 {} 超出CPU限制", pid);
                return false;
            }
            
            return true;
        }
        
        false
    }
    
    pub fn enforce_limits(&mut self, mut child: std::process::Child) 
        -> std::io::Result<()> 
    {
        loop {
            std::thread::sleep(std::time::Duration::from_secs(1));
            
            if !self.check_and_limit(child.id()) {
                println!("终止违规进程 {}", child.id());
                child.kill()?;
                break;
            }
            
            // 检查进程是否已结束
            if let Ok(Some(_)) = child.try_wait() {
                break;
            }
        }
        
        Ok(())
    }
}
```

---

## 3. 容器化技术

### 3.1 Linux Namespaces

**完整的命名空间隔离**:

```rust
#[cfg(target_os = "linux")]
use nix::sched::{unshare, CloneFlags};
#[cfg(target_os = "linux")]
use nix::unistd::{sethostname, Pid};

#[cfg(target_os = "linux")]
pub struct NamespaceConfig {
    pub isolate_pid: bool,
    pub isolate_net: bool,
    pub isolate_mnt: bool,
    pub isolate_uts: bool,
    pub isolate_ipc: bool,
    pub isolate_user: bool,
}

#[cfg(target_os = "linux")]
impl NamespaceConfig {
    pub fn full_isolation() -> Self {
        Self {
            isolate_pid: true,
            isolate_net: true,
            isolate_mnt: true,
            isolate_uts: true,
            isolate_ipc: true,
            isolate_user: true,
        }
    }
    
    pub fn apply(&self) -> nix::Result<()> {
        let mut flags = CloneFlags::empty();
        
        if self.isolate_pid {
            flags |= CloneFlags::CLONE_NEWPID;
        }
        if self.isolate_net {
            flags |= CloneFlags::CLONE_NEWNET;
        }
        if self.isolate_mnt {
            flags |= CloneFlags::CLONE_NEWNS;
        }
        if self.isolate_uts {
            flags |= CloneFlags::CLONE_NEWUTS;
        }
        if self.isolate_ipc {
            flags |= CloneFlags::CLONE_NEWIPC;
        }
        if self.isolate_user {
            flags |= CloneFlags::CLONE_NEWUSER;
        }
        
        unshare(flags)?;
        
        Ok(())
    }
}

#[cfg(target_os = "linux")]
pub fn spawn_in_namespace(
    config: NamespaceConfig,
    command: &str,
) -> std::io::Result<std::process::Child> {
    use std::os::unix::process::CommandExt;
    
    std::process::Command::new(command)
        .pre_exec(move || {
            config.apply()
                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
            // 设置主机名
            sethostname("container")
                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
            Ok(())
        })
        .spawn()
}
```

---

### 3.2 网络隔离

**网络命名空间配置**:

```rust
#[cfg(target_os = "linux")]
pub fn setup_network_namespace() -> std::io::Result<()> {
    use std::process::Command;
    
    // 创建veth对
    Command::new("ip")
        .args(&["link", "add", "veth0", "type", "veth", "peer", "name", "veth1"])
        .status()?;
    
    // 将veth1移入命名空间
    Command::new("ip")
        .args(&["link", "set", "veth1", "netns", "container"])
        .status()?;
    
    // 配置IP地址
    Command::new("ip")
        .args(&["addr", "add", "10.0.0.1/24", "dev", "veth0"])
        .status()?;
    
    // 启用接口
    Command::new("ip")
        .args(&["link", "set", "veth0", "up"])
        .status()?;
    
    Ok(())
}
```

---

### 3.3 文件系统隔离

**chroot/pivot_root**:

```rust
#[cfg(unix)]
use std::path::Path;
#[cfg(unix)]
use nix::unistd::chroot;

#[cfg(unix)]
pub fn setup_chroot(root_path: &Path) -> nix::Result<()> {
    // 切换根目录
    chroot(root_path)?;
    
    // 切换工作目录
    std::env::set_current_dir("/")?;
    
    Ok(())
}

#[cfg(target_os = "linux")]
pub fn setup_pivot_root(
    new_root: &Path,
    put_old: &Path,
) -> nix::Result<()> {
    use nix::mount::{mount, umount2, MsFlags, MntFlags};
    use nix::unistd::pivot_root;
    
    // 挂载new_root
    mount(
        Some(new_root),
        new_root,
        None::<&str>,
        MsFlags::MS_BIND | MsFlags::MS_REC,
        None::<&str>,
    )?;
    
    // 切换根
    pivot_root(new_root, put_old)?;
    
    // 切换到新根
    std::env::set_current_dir("/")?;
    
    // 卸载旧根
    umount2(put_old, MntFlags::MNT_DETACH)?;
    
    Ok(())
}
```

---

## 4. 安全机制

### 4.1 Seccomp过滤

**系统调用过滤**:

```rust
#[cfg(target_os = "linux")]
use seccompiler::{SeccompAction, SeccompFilter, SeccompRule, BpfProgram};

#[cfg(target_os = "linux")]
pub fn create_seccomp_filter() -> Result<BpfProgram, Box<dyn std::error::Error>> {
    let mut filter = SeccompFilter::new(
        vec![
            // 允许的系统调用
            (libc::SYS_read, vec![]),
            (libc::SYS_write, vec![]),
            (libc::SYS_exit, vec![]),
            (libc::SYS_exit_group, vec![]),
            (libc::SYS_rt_sigreturn, vec![]),
            
            // 禁止危险调用
            // (libc::SYS_execve 被默认禁止)
            // (libc::SYS_ptrace 被默认禁止)
        ].into_iter().collect(),
        SeccompAction::Trap,  // 违规时触发trap
    )?;
    
    let program: BpfProgram = filter.try_into()?;
    Ok(program)
}

#[cfg(target_os = "linux")]
pub fn apply_seccomp() -> Result<(), Box<dyn std::error::Error>> {
    let program = create_seccomp_filter()?;
    
    // 应用过滤器
    seccompiler::apply_filter(&program)?;
    
    Ok(())
}
```

---

### 4.2 AppArmor/SELinux

**AppArmor配置文件生成**:

```rust
pub struct AppArmorProfile {
    name: String,
    rules: Vec<String>,
}

impl AppArmorProfile {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            rules: Vec::new(),
        }
    }
    
    pub fn allow_read(&mut self, path: &str) -> &mut Self {
        self.rules.push(format!("  {} r,", path));
        self
    }
    
    pub fn allow_write(&mut self, path: &str) -> &mut Self {
        self.rules.push(format!("  {} w,", path));
        self
    }
    
    pub fn allow_execute(&mut self, path: &str) -> &mut Self {
        self.rules.push(format!("  {} ix,", path));
        self
    }
    
    pub fn generate(&self) -> String {
        format!(
            r#"#include <tunables/global>

profile {} {{
  #include <abstractions/base>

  # 规则
{}

  # 拒绝其他
  /** ix,
}}
"#,
            self.name,
            self.rules.join("\n")
        )
    }
    
    pub fn save(&self, path: &std::path::Path) -> std::io::Result<()> {
        std::fs::write(path, self.generate())
    }
}

// 使用示例
fn create_worker_profile() -> std::io::Result<()> {
    let mut profile = AppArmorProfile::new("worker");
    
    profile
        .allow_read("/usr/bin/worker")
        .allow_execute("/usr/bin/worker")
        .allow_read("/etc/worker.conf")
        .allow_write("/var/log/worker/*.log");
    
    profile.save(std::path::Path::new("/etc/apparmor.d/worker"))?;
    
    println!("AppArmor profile created");
    
    Ok(())
}
```

---

### 4.3 审计日志

**安全事件审计**:

```rust
use std::fs::OpenOptions;
use std::io::Write;
use chrono::Utc;

pub struct SecurityAuditor {
    log_path: std::path::PathBuf,
}

pub enum SecurityEvent {
    PrivilegeEscalation { pid: u32, from_uid: u32, to_uid: u32 },
    ResourceLimitViolation { pid: u32, resource: String, limit: u64 },
    SyscallViolation { pid: u32, syscall: String },
    NetworkViolation { pid: u32, dest: String },
}

impl SecurityAuditor {
    pub fn new(log_path: std::path::PathBuf) -> Self {
        Self { log_path }
    }
    
    pub fn log_event(&self, event: SecurityEvent) -> std::io::Result<()> {
        let timestamp = Utc::now().to_rfc3339();
        
        let message = match event {
            SecurityEvent::PrivilegeEscalation { pid, from_uid, to_uid } => {
                format!("[{}] PRIVILEGE_ESCALATION pid={} from_uid={} to_uid={}",
                    timestamp, pid, from_uid, to_uid)
            }
            SecurityEvent::ResourceLimitViolation { pid, resource, limit } => {
                format!("[{}] RESOURCE_VIOLATION pid={} resource={} limit={}",
                    timestamp, pid, resource, limit)
            }
            SecurityEvent::SyscallViolation { pid, syscall } => {
                format!("[{}] SYSCALL_VIOLATION pid={} syscall={}",
                    timestamp, pid, syscall)
            }
            SecurityEvent::NetworkViolation { pid, dest } => {
                format!("[{}] NETWORK_VIOLATION pid={} dest={}",
                    timestamp, pid, dest)
            }
        };
        
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_path)?;
        
        writeln!(file, "{}", message)?;
        
        Ok(())
    }
}
```

---

## 5. 沙箱实现

### 完整的沙箱系统

```rust
use std::process::{Command, Child};
use std::path::PathBuf;

pub struct Sandbox {
    root_dir: PathBuf,
    user: String,
    resource_limits: ResourceLimits,
    #[cfg(target_os = "linux")]
    namespace_config: NamespaceConfig,
    auditor: SecurityAuditor,
}

impl Sandbox {
    pub fn builder() -> SandboxBuilder {
        SandboxBuilder::new()
    }
    
    pub fn execute(&self, command: &str) -> std::io::Result<Child> {
        // 1. 创建审计日志
        self.auditor.log_event(SecurityEvent::ProcessSpawn {
            command: command.to_string(),
        })?;
        
        // 2. 准备命令
        let mut cmd = Command::new(command);
        
        // 3. 应用资源限制
        #[cfg(unix)]
        {
            use std::os::unix::process::CommandExt;
            
            cmd.pre_exec(move || {
                // 应用rlimit
                self.resource_limits.apply()
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                
                // 应用命名空间
                #[cfg(target_os = "linux")]
                {
                    self.namespace_config.apply()
                        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                }
                
                // chroot
                setup_chroot(&self.root_dir)
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                
                Ok(())
            });
        }
        
        // 4. 启动进程
        cmd.spawn()
    }
}

pub struct SandboxBuilder {
    root_dir: Option<PathBuf>,
    user: Option<String>,
    cpu_limit: Option<u64>,
    memory_limit: Option<u64>,
    log_path: Option<PathBuf>,
}

impl SandboxBuilder {
    pub fn new() -> Self {
        Self {
            root_dir: None,
            user: None,
            cpu_limit: None,
            memory_limit: None,
            log_path: None,
        }
    }
    
    pub fn root_dir(mut self, path: PathBuf) -> Self {
        self.root_dir = Some(path);
        self
    }
    
    pub fn user(mut self, user: String) -> Self {
        self.user = Some(user);
        self
    }
    
    pub fn cpu_limit(mut self, seconds: u64) -> Self {
        self.cpu_limit = Some(seconds);
        self
    }
    
    pub fn memory_limit(mut self, bytes: u64) -> Self {
        self.memory_limit = Some(bytes);
        self
    }
    
    pub fn log_path(mut self, path: PathBuf) -> Self {
        self.log_path = Some(path);
        self
    }
    
    pub fn build(self) -> Sandbox {
        let mut limits = ResourceLimits::new();
        
        if let Some(cpu) = self.cpu_limit {
            limits = limits.cpu(cpu);
        }
        if let Some(mem) = self.memory_limit {
            limits = limits.memory(mem);
        }
        
        Sandbox {
            root_dir: self.root_dir.unwrap_or_else(|| PathBuf::from("/tmp/sandbox")),
            user: self.user.unwrap_or_else(|| "nobody".to_string()),
            resource_limits: limits,
            #[cfg(target_os = "linux")]
            namespace_config: NamespaceConfig::full_isolation(),
            auditor: SecurityAuditor::new(
                self.log_path.unwrap_or_else(|| PathBuf::from("/var/log/sandbox.log"))
            ),
        }
    }
}

// 使用示例
fn main() -> std::io::Result<()> {
    let sandbox = Sandbox::builder()
        .root_dir(PathBuf::from("/tmp/sandbox"))
        .user("nobody".to_string())
        .cpu_limit(10)
        .memory_limit(100 * 1024 * 1024)
        .log_path(PathBuf::from("/var/log/sandbox.log"))
        .build();
    
    let mut child = sandbox.execute("worker")?;
    
    println!("沙箱进程启动，PID: {}", child.id());
    
    let status = child.wait()?;
    println!("进程退出: {:?}", status);
    
    Ok(())
}
```

---

## 6. 最佳实践

**1. 最小权限原则**:

- ✅ 以非root用户运行
- ✅ 仅授予必要的capabilities
- ✅ 使用命名空间隔离

**2. 深度防御**:

```rust
// ✅ 多层安全措施
Sandbox::builder()
    .user("nobody")                    // 权限降级
    .root_dir("/jail")                 // chroot
    .cpu_limit(10)                     // 资源限制
    .memory_limit(100 * 1024 * 1024)   // 内存限制
    // + namespaces                    // 命名空间
    // + seccomp                       // 系统调用过滤
    // + AppArmor                      // MAC
    .build();
```

**3. 审计所有安全事件**:

- ✅ 记录权限变更
- ✅ 记录资源违规
- ✅ 记录网络访问

**4. 定期安全审查**:

- ✅ 检查配置文件
- ✅ 审查审计日志
- ✅ 更新安全策略

**5. 测试安全措施**:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_privilege_drop() {
        // 测试权限降级
    }
    
    #[test]
    fn test_resource_limits() {
        // 测试资源限制
    }
    
    #[test]
    fn test_namespace_isolation() {
        // 测试命名空间隔离
    }
}
```

---

## 总结

**进程安全与沙箱核心要素**:

1. ✅ **权限控制**: 用户/组/Capabilities
2. ✅ **资源限制**: rlimit/cgroups
3. ✅ **隔离技术**: Namespaces/chroot
4. ✅ **安全机制**: Seccomp/AppArmor/SELinux
5. ✅ **审计日志**: 完整的安全事件记录

**安全等级**:

- **Level 1**: 权限降级 + rlimit
- **Level 2**: + cgroups + chroot
- **Level 3**: + Namespaces + Seccomp
- **Level 4**: + AppArmor/SELinux + 审计

---

## 7. 容器安全

### 7.1 Docker容器安全

**安全容器配置**:

```dockerfile
# 多阶段构建 - 最小化攻击面
FROM rust:1.75 as builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bookworm-slim

# 创建非root用户
RUN useradd -m -u 1000 appuser && \
    apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates && \
    rm -rf /var/lib/apt/lists/*

# 复制二进制文件
COPY --from=builder /app/target/release/app /usr/local/bin/
RUN chown appuser:appuser /usr/local/bin/app

# 切换到非root用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD /usr/local/bin/app health || exit 1

CMD ["app"]
```

**Docker运行时安全选项**:

```bash
# 安全运行容器
docker run \
  --rm \
  --read-only \
  --tmpfs /tmp:rw,noexec,nosuid,size=100m \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt=no-new-privileges \
  --security-opt=seccomp=/path/to/seccomp-profile.json \
  --security-opt=apparmor=docker-default \
  --pids-limit=100 \
  --memory=512m \
  --cpus=1.0 \
  --user=1000:1000 \
  myapp:latest
```

### 7.2 进程安全审计

**完整审计系统**:

```rust
use serde::{Serialize, Deserialize};
use std::fs::OpenOptions;
use std::io::Write;

#[derive(Serialize, Deserialize, Debug)]
pub struct SecurityEvent {
    pub timestamp: String,
    pub event_type: EventType,
    pub pid: u32,
    pub user: String,
    pub action: String,
    pub result: EventResult,
    pub details: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum EventType {
    PrivilegeEscalation,
    ResourceViolation,
    UnauthorizedAccess,
    SuspiciousActivity,
    PolicyViolation,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum EventResult {
    Allowed,
    Denied,
    Failed,
}

pub struct AuditLogger {
    log_file: PathBuf,
    syslog: Option<syslog::Logger>,
}

impl AuditLogger {
    pub fn new(log_file: PathBuf) -> Self {
        let syslog = syslog::unix(syslog::Facility::LOG_AUTH).ok();
        
        Self {
            log_file,
            syslog,
        }
    }
    
    pub fn log_event(&self, event: SecurityEvent) {
        // 1. 写入本地文件
        self.log_to_file(&event);
        
        // 2. 写入syslog
        if let Some(ref syslog) = self.syslog {
            let msg = format!(
                "{:?}: {} by {} (PID: {}): {:?}",
                event.event_type,
                event.action,
                event.user,
                event.pid,
                event.result
            );
            syslog.err(msg).ok();
        }
        
        // 3. 关键事件告警
        if matches!(event.event_type, EventType::PrivilegeEscalation) {
            self.send_alert(&event);
        }
    }
    
    fn log_to_file(&self, event: &SecurityEvent) {
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
            .unwrap();
        
        let json = serde_json::to_string(event).unwrap();
        writeln!(file, "{}", json).ok();
    }
    
    fn send_alert(&self, event: &SecurityEvent) {
        // 发送告警到监控系统
        println!("⚠️  SECURITY ALERT: {:?}", event);
    }
}
```

---

## 8. 威胁模型

### 8.1 常见攻击向量

**1. 权限提升攻击**:

```rust
pub fn detect_privilege_escalation(child: &Child) -> bool {
    #[cfg(unix)]
    {
        use nix::unistd::{getuid, Uid};
        
        if let Some(pid) = child.id() {
            // 检查进程的有效UID
            let proc_status = std::fs::read_to_string(
                format!("/proc/{}/status", pid)
            ).ok()?;
            
            for line in proc_status.lines() {
                if line.starts_with("Uid:") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        let euid: u32 = parts[2].parse().ok()?;
                        
                        // 检查是否提升到root
                        if euid == 0 && getuid() != Uid::from_raw(0) {
                            return true;  // 检测到权限提升
                        }
                    }
                }
            }
        }
    }
    
    false
}
```

**2. 资源耗尽攻击**:

```rust
pub struct ResourceMonitor {
    limits: ResourceLimits,
    violations: Arc<Mutex<Vec<Violation>>>,
}

impl ResourceMonitor {
    pub async fn monitor_process(&self, pid: u32) {
        let mut system = sysinfo::System::new_all();
        
        loop {
            system.refresh_process(sysinfo::Pid::from_u32(pid));
            
            if let Some(process) = system.process(sysinfo::Pid::from_u32(pid)) {
                // CPU检查
                if process.cpu_usage() > self.limits.max_cpu {
                    self.record_violation(Violation {
                        pid,
                        violation_type: ViolationType::CpuExhaustion,
                        value: process.cpu_usage() as f64,
                    }).await;
                }
                
                // 内存检查
                if process.memory() > self.limits.max_memory {
                    self.record_violation(Violation {
                        pid,
                        violation_type: ViolationType::MemoryExhaustion,
                        value: process.memory() as f64,
                    }).await;
                }
            }
            
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    }
    
    async fn record_violation(&self, violation: Violation) {
        let mut violations = self.violations.lock().await;
        violations.push(violation);
        
        // 超过阈值：终止进程
        if violations.len() > 3 {
            println!("终止恶意进程: PID {}", violation.pid);
            unsafe {
                libc::kill(violation.pid as i32, libc::SIGKILL);
            }
        }
    }
}
```

**3. 逃逸攻击防御**:

```rust
pub fn verify_sandbox_integrity(sandbox: &Sandbox) -> Result<(), SecurityError> {
    #[cfg(target_os = "linux")]
    {
        use std::fs;
        
        // 1. 验证命名空间
        let ns_types = vec!["mnt", "pid", "net", "ipc", "uts"];
        
        for ns_type in ns_types {
            let ns_path = format!("/proc/self/ns/{}", ns_type);
            if !fs::metadata(&ns_path).is_ok() {
                return Err(SecurityError::NamespaceError(
                    format!("命名空间 {} 不存在", ns_type)
                ));
            }
        }
        
        // 2. 验证根目录
        let root = fs::read_link("/proc/self/root")?;
        if root == PathBuf::from("/") {
            return Err(SecurityError::EscapeAttempt(
                "根目录未被chroot".to_string()
            ));
        }
        
        // 3. 验证capabilities
        let cap_status = fs::read_to_string("/proc/self/status")?;
        for line in cap_status.lines() {
            if line.starts_with("CapEff:") {
                let cap_hex = line.split_whitespace().nth(1).unwrap();
                let cap_value = u64::from_str_radix(cap_hex, 16)?;
                
                // 检查是否有危险的capabilities
                if cap_value & (1 << CAP_SYS_ADMIN) != 0 {
                    return Err(SecurityError::DangerousCapability(
                        "拥有CAP_SYS_ADMIN".to_string()
                    ));
                }
            }
        }
    }
    
    Ok(())
}

const CAP_SYS_ADMIN: u64 = 21;
```

---

## 9. 安全配置模板

### 9.1 高安全级别配置

**生产环境安全模板**:

```rust
pub fn production_security_config() -> SandboxBuilder {
    Sandbox::builder()
        // 1. 权限最小化
        .user("nobody".to_string())
        .drop_all_capabilities()
        .add_capability(Capability::CAP_NET_BIND_SERVICE)  // 仅绑定端口
        
        // 2. 资源严格限制
        .cpu_limit(10)                           // 10秒CPU
        .memory_limit(256 * 1024 * 1024)        // 256MB
        .process_limit(50)                       // 最多50个进程
        .file_descriptors_limit(1024)           // 最多1024个文件描述符
        
        // 3. 文件系统隔离
        .root_dir(PathBuf::from("/var/sandbox"))
        .mount_readonly("/etc")
        .mount_readonly("/usr")
        .mount_tmpfs("/tmp", 100 * 1024 * 1024)  // 100MB临时空间
        
        // 4. 网络隔离
        .network_namespace(true)
        .allow_outbound_only()
        
        // 5. Seccomp严格过滤
        .seccomp_profile(SeccompProfile::Strict)
        
        // 6. 审计所有事件
        .log_path(PathBuf::from("/var/log/sandbox/security.log"))
        .audit_level(AuditLevel::Verbose)
}
```

### 9.2 开发环境配置

**开发调试友好配置**:

```rust
pub fn development_security_config() -> SandboxBuilder {
    Sandbox::builder()
        // 1. 宽松权限（方便调试）
        .user(std::env::var("USER").unwrap())
        
        // 2. 较高资源限制
        .cpu_limit(60)
        .memory_limit(2 * 1024 * 1024 * 1024)  // 2GB
        .process_limit(200)
        
        // 3. 文件系统访问
        .root_dir(PathBuf::from("/tmp/dev-sandbox"))
        .bind_mount(std::env::current_dir().unwrap(), "/workspace")
        
        // 4. 网络全开
        .network_namespace(false)
        
        // 5. 宽松Seccomp
        .seccomp_profile(SeccompProfile::Permissive)
        
        // 6. 详细日志
        .log_path(PathBuf::from("/tmp/sandbox-dev.log"))
        .audit_level(AuditLevel::Debug)
}
```

---

## 10. 安全测试

### 10.1 安全测试套件

**完整安全测试**:

```rust
#[cfg(test)]
mod security_tests {
    use super::*;
    
    #[test]
    #[cfg(target_os = "linux")]
    fn test_privilege_drop() {
        let sandbox = Sandbox::builder()
            .user("nobody".to_string())
            .build();
        
        let mut child = sandbox.execute("id").unwrap();
        let output = child.wait_with_output().unwrap();
        
        let stdout = String::from_utf8_lossy(&output.stdout);
        
        // 验证进程以nobody运行
        assert!(stdout.contains("uid=") && stdout.contains("nobody"));
        assert!(!stdout.contains("uid=0"));  // 不是root
    }
    
    #[test]
    #[cfg(target_os = "linux")]
    fn test_resource_limits() {
        let sandbox = Sandbox::builder()
            .memory_limit(10 * 1024 * 1024)  // 10MB
            .build();
        
        // 尝试分配超过限制的内存
        let result = sandbox.execute_with_args(
            "python3",
            &["-c", "x = 'a' * (100 * 1024 * 1024)"]
        );
        
        // 应该被资源限制kill
        assert!(result.is_err() || !result.unwrap().wait().unwrap().success());
    }
    
    #[test]
    #[cfg(target_os = "linux")]
    fn test_filesystem_isolation() {
        let sandbox = Sandbox::builder()
            .root_dir(PathBuf::from("/tmp/sandbox-test"))
            .build();
        
        let mut child = sandbox.execute_with_args(
            "ls",
            &["/etc/passwd"]
        ).unwrap();
        
        let output = child.wait_with_output().unwrap();
        
        // 应该无法访问主机文件系统
        assert!(!output.status.success());
    }
    
    #[test]
    fn test_capability_drop() {
        // 测试capabilities被正确移除
    }
    
    #[test]
    fn test_namespace_isolation() {
        // 测试命名空间隔离
    }
}
```

### 10.2 渗透测试清单

**安全检查清单**:

```markdown
## 权限测试
- [ ] 进程以非root用户运行
- [ ] Capabilities被正确限制
- [ ] Seccomp过滤生效
- [ ] 无法提升权限

## 隔离测试
- [ ] 文件系统隔离有效
- [ ] 网络命名空间隔离
- [ ] PID命名空间隔离
- [ ] 无法访问主机资源

## 资源限制测试
- [ ] CPU限制生效
- [ ] 内存限制生效
- [ ] 进程数限制生效
- [ ] 文件描述符限制生效

## 审计测试
- [ ] 安全事件被记录
- [ ] 违规行为被检测
- [ ] 告警机制正常工作
```

---

**下一步**: [03_性能工程实践.md](./03_性能工程实践.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-24  
**适用版本**: Rust 1.90+
