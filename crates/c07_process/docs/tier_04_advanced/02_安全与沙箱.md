# Tier 4: å®‰å…¨ä¸æ²™ç®±

> **æ–‡æ¡£ç±»å‹**: é«˜çº§ä¸»é¢˜
> **éš¾åº¦**: â­â­â­â­â­
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **å‰ç½®çŸ¥è¯†**: [è·¨å¹³å°å®è·µ](../tier_02_guides/04_è·¨å¹³å°å®è·µ.md)

---

## ç›®å½•

- [Tier 4: å®‰å…¨ä¸æ²™ç®±](#tier-4-å®‰å…¨ä¸æ²™ç®±)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
  - [1. è¿›ç¨‹éš”ç¦»æŠ€æœ¯](#1-è¿›ç¨‹éš”ç¦»æŠ€æœ¯)
    - [1.1 æƒé™é™çº§](#11-æƒé™é™çº§)
    - [1.2 ç”¨æˆ·ä¸ç»„ç®¡ç†](#12-ç”¨æˆ·ä¸ç»„ç®¡ç†)
    - [1.3 Capabilities](#13-capabilities)
  - [2. èµ„æºé™åˆ¶](#2-èµ„æºé™åˆ¶)
    - [2.1 rlimité…ç½®](#21-rlimité…ç½®)
    - [2.2 cgroupsæ§åˆ¶](#22-cgroupsæ§åˆ¶)
    - [2.3 å†…å­˜ä¸CPUé™åˆ¶](#23-å†…å­˜ä¸cpué™åˆ¶)
  - [3. å®¹å™¨åŒ–æŠ€æœ¯](#3-å®¹å™¨åŒ–æŠ€æœ¯)
    - [3.1 Linux Namespaces](#31-linux-namespaces)
    - [3.2 ç½‘ç»œéš”ç¦»](#32-ç½‘ç»œéš”ç¦»)
    - [3.3 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»](#33-æ–‡ä»¶ç³»ç»Ÿéš”ç¦»)
  - [4. å®‰å…¨æœºåˆ¶](#4-å®‰å…¨æœºåˆ¶)
    - [4.1 Seccompè¿‡æ»¤](#41-seccompè¿‡æ»¤)
    - [4.2 AppArmor/SELinux](#42-apparmorselinux)
    - [4.3 å®¡è®¡æ—¥å¿—](#43-å®¡è®¡æ—¥å¿—)
  - [5. æ²™ç®±å®ç°](#5-æ²™ç®±å®ç°)
    - [å®Œæ•´çš„æ²™ç®±ç³»ç»Ÿ](#å®Œæ•´çš„æ²™ç®±ç³»ç»Ÿ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
  - [æ€»ç»“](#æ€»ç»“)
  - [7. å®¹å™¨å®‰å…¨](#7-å®¹å™¨å®‰å…¨)
    - [7.1 Dockerå®¹å™¨å®‰å…¨](#71-dockerå®¹å™¨å®‰å…¨)
    - [7.2 è¿›ç¨‹å®‰å…¨å®¡è®¡](#72-è¿›ç¨‹å®‰å…¨å®¡è®¡)
  - [8. å¨èƒæ¨¡å‹](#8-å¨èƒæ¨¡å‹)
    - [8.1 å¸¸è§æ”»å‡»å‘é‡](#81-å¸¸è§æ”»å‡»å‘é‡)
  - [9. å®‰å…¨é…ç½®æ¨¡æ¿](#9-å®‰å…¨é…ç½®æ¨¡æ¿)
    - [9.1 é«˜å®‰å…¨çº§åˆ«é…ç½®](#91-é«˜å®‰å…¨çº§åˆ«é…ç½®)
    - [9.2 å¼€å‘ç¯å¢ƒé…ç½®](#92-å¼€å‘ç¯å¢ƒé…ç½®)
  - [10. å®‰å…¨æµ‹è¯•](#10-å®‰å…¨æµ‹è¯•)
    - [10.1 å®‰å…¨æµ‹è¯•å¥—ä»¶](#101-å®‰å…¨æµ‹è¯•å¥—ä»¶)
    - [10.2 æ¸—é€æµ‹è¯•æ¸…å•](#102-æ¸—é€æµ‹è¯•æ¸…å•)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å®‰å…¨ä¸æ²™ç®± (Security and Sandboxing)**:

- **å®šä¹‰**: Rust 1.92.0 å®‰å…¨ä¸æ²™ç®±æŠ€æœ¯ï¼ŒåŒ…æ‹¬è¿›ç¨‹éš”ç¦»æŠ€æœ¯ã€èµ„æºé™åˆ¶ã€å®¹å™¨åŒ–æŠ€æœ¯ã€å®‰å…¨æœºåˆ¶ã€æ²™ç®±å®ç°ã€æœ€ä½³å®è·µã€å®¹å™¨å®‰å…¨ã€å¨èƒæ¨¡å‹ã€å®‰å…¨é…ç½®æ¨¡æ¿ã€å®‰å…¨æµ‹è¯•ç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: è¿›ç¨‹ç®¡ç†ã€å®‰å…¨
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: è¿›ç¨‹éš”ç¦»ã€èµ„æºé™åˆ¶ã€å®¹å™¨åŒ–ã€å®‰å…¨æœºåˆ¶ã€æ²™ç®±ã€å¨èƒæ¨¡å‹

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **è¿›ç¨‹éš”ç¦»æŠ€æœ¯**: æƒé™é™çº§ã€ç”¨æˆ·ä¸ç»„ç®¡ç†ã€Capabilities
- **èµ„æºé™åˆ¶**: rlimit é…ç½®ã€cgroups æ§åˆ¶ã€å†…å­˜ä¸ CPU é™åˆ¶
- **å®¹å™¨åŒ–æŠ€æœ¯**: Linux Namespacesã€ç½‘ç»œéš”ç¦»ã€æ–‡ä»¶ç³»ç»Ÿéš”ç¦»
- **å®‰å…¨æœºåˆ¶**: Seccomp è¿‡æ»¤ã€AppArmor/SELinuxã€å®¡è®¡æ—¥å¿—
- **æ²™ç®±å®ç°**: å®Œæ•´çš„æ²™ç®±ç³»ç»Ÿ
- **å®¹å™¨å®‰å…¨**: Docker å®¹å™¨å®‰å…¨ã€è¿›ç¨‹å®‰å…¨å®¡è®¡
- **å¨èƒæ¨¡å‹**: å¸¸è§æ”»å‡»å‘é‡
- **å®‰å…¨é…ç½®æ¨¡æ¿**: é«˜å®‰å…¨çº§åˆ«é…ç½®ã€å¼€å‘ç¯å¢ƒé…ç½®
- **å®‰å…¨æµ‹è¯•**: å®‰å…¨æµ‹è¯•å¥—ä»¶ã€æ¸—é€æµ‹è¯•æ¸…å•

**Rust 1.92.0 æ–°ç‰¹æ€§**:

- **æ”¹è¿›çš„å®‰å…¨æœºåˆ¶**: æ›´å¥½çš„å®‰å…¨æœºåˆ¶æ”¯æŒ
- **å¢å¼ºçš„æ²™ç®±**: æ›´å®Œå–„çš„æ²™ç®±æ”¯æŒ
- **ä¼˜åŒ–çš„å®¹å™¨åŒ–**: æ›´é«˜æ•ˆçš„å®¹å™¨åŒ–æ”¯æŒ

**æ€§èƒ½ç‰¹å¾**:

- **å®‰å…¨æ€§**: å¼ºå¤§çš„å®‰å…¨ä¿è¯
- **éš”ç¦»æ€§**: è‰¯å¥½çš„è¿›ç¨‹éš”ç¦»
- **é€‚ç”¨åœºæ™¯**: å®‰å…¨å…³é”®ç³»ç»Ÿã€å®¹å™¨åŒ–åº”ç”¨ã€æ²™ç®±ç¯å¢ƒ

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- å®‰å…¨ä¸æ²™ç®± --[covers]--> å®‰å…¨å®Œæ•´å†…å®¹
- å®‰å…¨å…³é”®ç³»ç»Ÿ --[uses]--> å®‰å…¨ä¸æ²™ç®±

**ä¾èµ–å…³ç³»**:

- å®‰å…¨ä¸æ²™ç®± --[depends-on]--> è¿›ç¨‹ç®¡ç†
- å®‰å…¨ç³»ç»Ÿ --[depends-on]--> å®‰å…¨ä¸æ²™ç®±

### æ€ç»´å¯¼å›¾

```text
å®‰å…¨ä¸æ²™ç®±
â”‚
â”œâ”€â”€ è¿›ç¨‹éš”ç¦»æŠ€æœ¯
â”‚   â”œâ”€â”€ æƒé™é™çº§
â”‚   â””â”€â”€ Capabilities
â”œâ”€â”€ èµ„æºé™åˆ¶
â”‚   â”œâ”€â”€ rlimit é…ç½®
â”‚   â””â”€â”€ cgroups æ§åˆ¶
â”œâ”€â”€ å®¹å™¨åŒ–æŠ€æœ¯
â”‚   â”œâ”€â”€ Linux Namespaces
â”‚   â””â”€â”€ ç½‘ç»œéš”ç¦»
â”œâ”€â”€ å®‰å…¨æœºåˆ¶
â”‚   â”œâ”€â”€ Seccomp è¿‡æ»¤
â”‚   â””â”€â”€ AppArmor/SELinux
â”œâ”€â”€ æ²™ç®±å®ç°
â”‚   â””â”€â”€ å®Œæ•´çš„æ²™ç®±ç³»ç»Ÿ
â”œâ”€â”€ å®¹å™¨å®‰å…¨
â”‚   â””â”€â”€ Docker å®¹å™¨å®‰å…¨
â”œâ”€â”€ å¨èƒæ¨¡å‹
â”‚   â””â”€â”€ å¸¸è§æ”»å‡»å‘é‡
â””â”€â”€ å®‰å…¨æµ‹è¯•
    â””â”€â”€ å®‰å…¨æµ‹è¯•å¥—ä»¶
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| å®‰å…¨æŠ€æœ¯             | å®‰å…¨æ€§ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯     | Rust 1.92.0 |
| :--- | :--- | :--- | :--- | :--- || **è¿›ç¨‹éš”ç¦»**         | é«˜     | ä¸­     | è¿›ç¨‹éš”ç¦»     | âœ…          |
| **èµ„æºé™åˆ¶**         | ä¸­     | ä½     | èµ„æºæ§åˆ¶     | âœ…          |
| **å®¹å™¨åŒ–**           | é«˜     | é«˜     | å®¹å™¨ç¯å¢ƒ     | âœ…          |
| **Seccomp**          | æœ€é«˜   | ä¸­     | ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤ | âœ…          |
| **AppArmor/SELinux** | æœ€é«˜   | é«˜     | å¼ºåˆ¶è®¿é—®æ§åˆ¶ | âœ…          |
| **æ²™ç®±**             | æœ€é«˜   | æœ€é«˜   | æ²™ç®±ç¯å¢ƒ     | âœ…          |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©å®‰å…¨æŠ€æœ¯
â”‚
â”œâ”€â”€ éœ€è¦ä»€ä¹ˆå®‰å…¨çº§åˆ«ï¼Ÿ
â”‚   â”œâ”€â”€ åŸºç¡€éš”ç¦» â†’ è¿›ç¨‹éš”ç¦» / èµ„æºé™åˆ¶
â”‚   â”œâ”€â”€ å®¹å™¨éš”ç¦» â†’ å®¹å™¨åŒ–æŠ€æœ¯
â”‚   â”œâ”€â”€ ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤ â†’ Seccomp
â”‚   â”œâ”€â”€ å¼ºåˆ¶è®¿é—®æ§åˆ¶ â†’ AppArmor/SELinux
â”‚   â””â”€â”€ å®Œæ•´æ²™ç®± â†’ æ²™ç®±å®ç°
```

---

## 1. è¿›ç¨‹éš”ç¦»æŠ€æœ¯

### 1.1 æƒé™é™çº§

**åŸç†**: ä»¥æœ€å°æƒé™è¿è¡Œè¿›ç¨‹ï¼Œé™ä½å®‰å…¨é£é™©ã€‚

**Unixæƒé™é™çº§**:

```rust
#[cfg(unix)]
use std::os::unix::process::CommandExt;
use std::process::Command;

#[cfg(unix)]
pub fn spawn_with_dropped_privileges(
    program: &str,
    user: &str,
    group: &str,
) -> std::io::Result<std::process::Child> {
    use nix::unistd::{User, Group, Uid, Gid};

    // æŸ¥æ‰¾ç”¨æˆ·å’Œç»„
    let user_info = User::from_name(user)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("User {} not found", user),
        ))?;

    let group_info = Group::from_name(group)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("Group {} not found", group),
        ))?;

    // åˆ›å»ºå­è¿›ç¨‹å¹¶é™çº§æƒé™
    Command::new(program)
        .uid(user_info.uid.as_raw())
        .gid(group_info.gid.as_raw())
        .spawn()
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    // ä»¥nobodyç”¨æˆ·è¿è¡Œworker
    let child = spawn_with_dropped_privileges("worker", "nobody", "nogroup")?;

    println!("Workerè¿›ç¨‹å¯åŠ¨ï¼ŒPID: {}", child.id());

    Ok(())
}
```

**Windowsæƒé™æ§åˆ¶**:

```rust
#[cfg(windows)]
use windows_sys::Win32::Security::*;

#[cfg(windows)]
pub fn create_restricted_token() -> std::io::Result<()> {
    // Windowséœ€è¦ä½¿ç”¨CreateRestrictedToken API
    // é™åˆ¶è¿›ç¨‹çš„è®¿é—®ä»¤ç‰Œ
    unimplemented!("Windowså®ç°éœ€è¦ä½¿ç”¨Win32 API")
}
```

---

### 1.2 ç”¨æˆ·ä¸ç»„ç®¡ç†

**å¤šç”¨æˆ·éš”ç¦»**:

```rust
use std::collections::HashMap;

pub struct UserIsolation {
    user_map: HashMap<String, UserConfig>,
}

pub struct UserConfig {
    pub uid: u32,
    pub gid: u32,
    pub home_dir: String,
    pub allowed_commands: Vec<String>,
}

impl UserIsolation {
    pub fn new() -> Self {
        Self {
            user_map: HashMap::new(),
        }
    }

    pub fn add_user(&mut self, name: String, config: UserConfig) {
        self.user_map.insert(name, config);
    }

    pub fn spawn_for_user(&self, user: &str, command: &str)
        -> std::io::Result<std::process::Child>
    {
        let config = self.user_map.get(user)
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "User not found",
            ))?;

        // æ£€æŸ¥å‘½ä»¤æ˜¯å¦å…è®¸
        if !config.allowed_commands.contains(&command.to_string()) {
            return Err(std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                "Command not allowed",
            ));
        }

        #[cfg(unix)]
        {
            use std::os::unix::process::CommandExt;
            std::process::Command::new(command)
                .uid(config.uid)
                .gid(config.gid)
                .env("HOME", &config.home_dir)
                .spawn()
        }

        #[cfg(not(unix))]
        {
            std::process::Command::new(command).spawn()
        }
    }
}
```

---

### 1.3 Capabilities

**Linux Capabilitiesç»†ç²’åº¦æƒé™æ§åˆ¶**:

```rust
#[cfg(target_os = "linux")]
use caps::{Capability, CapSet, set};

#[cfg(target_os = "linux")]
pub fn drop_all_capabilities() -> Result<(), Box<dyn std::error::Error>> {
    // ç§»é™¤æ‰€æœ‰capabilities
    caps::clear(None, CapSet::Effective)?;
    caps::clear(None, CapSet::Permitted)?;
    caps::clear(None, CapSet::Inheritable)?;

    Ok(())
}

#[cfg(target_os = "linux")]
pub fn set_minimal_capabilities() -> Result<(), Box<dyn std::error::Error>> {
    use caps::Capability::*;

    // ä»…ä¿ç•™å¿…è¦çš„capabilities
    let required_caps = vec![
        CAP_NET_BIND_SERVICE,  // ç»‘å®š<1024ç«¯å£
        CAP_CHOWN,             // ä¿®æ”¹æ–‡ä»¶æ‰€æœ‰æƒ
    ];

    // æ¸…é™¤æ‰€æœ‰
    drop_all_capabilities()?;

    // è®¾ç½®å¿…è¦çš„
    for cap in required_caps {
        set(None, CapSet::Effective, cap)?;
        set(None, CapSet::Permitted, cap)?;
    }

    Ok(())
}
```

---

## 2. èµ„æºé™åˆ¶

### 2.1 rlimité…ç½®

**å®Œæ•´çš„èµ„æºé™åˆ¶**:

```rust
#[cfg(unix)]
use nix::sys::resource::{setrlimit, getrlimit, Resource};

#[cfg(unix)]
pub struct ResourceLimits {
    cpu_seconds: Option<u64>,
    memory_bytes: Option<u64>,
    open_files: Option<u64>,
    processes: Option<u64>,
}

#[cfg(unix)]
impl ResourceLimits {
    pub fn new() -> Self {
        Self {
            cpu_seconds: None,
            memory_bytes: None,
            open_files: None,
            processes: None,
        }
    }

    pub fn cpu(mut self, seconds: u64) -> Self {
        self.cpu_seconds = Some(seconds);
        self
    }

    pub fn memory(mut self, bytes: u64) -> Self {
        self.memory_bytes = Some(bytes);
        self
    }

    pub fn open_files(mut self, count: u64) -> Self {
        self.open_files = Some(count);
        self
    }

    pub fn processes(mut self, count: u64) -> Self {
        self.processes = Some(count);
        self
    }

    pub fn apply(&self) -> nix::Result<()> {
        if let Some(cpu) = self.cpu_seconds {
            setrlimit(Resource::RLIMIT_CPU, cpu, cpu)?;
        }

        if let Some(mem) = self.memory_bytes {
            setrlimit(Resource::RLIMIT_AS, mem, mem)?;
        }

        if let Some(files) = self.open_files {
            setrlimit(Resource::RLIMIT_NOFILE, files, files)?;
        }

        if let Some(procs) = self.processes {
            setrlimit(Resource::RLIMIT_NPROC, procs, procs)?;
        }

        Ok(())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn spawn_limited_process() -> std::io::Result<()> {
    let limits = ResourceLimits::new()
        .cpu(10)                    // 10ç§’CPUæ—¶é—´
        .memory(100 * 1024 * 1024)  // 100MBå†…å­˜
        .open_files(64)             // 64ä¸ªæ–‡ä»¶æè¿°ç¬¦
        .processes(10);             // 10ä¸ªå­è¿›ç¨‹

    // åœ¨forkå‰åº”ç”¨é™åˆ¶
    #[cfg(unix)]
    {
        use std::os::unix::process::CommandExt;

        std::process::Command::new("worker")
            .pre_exec(move || {
                limits.apply()
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))
            })
            .spawn()?;
    }

    Ok(())
}
```

---

### 2.2 cgroupsæ§åˆ¶

**cgroups v2é›†æˆ**:

```rust
use std::fs;
use std::path::PathBuf;

pub struct CgroupController {
    cgroup_path: PathBuf,
}

impl CgroupController {
    pub fn new(name: &str) -> std::io::Result<Self> {
        let cgroup_path = PathBuf::from("/sys/fs/cgroup")
            .join("user.slice")
            .join(name);

        // åˆ›å»ºcgroupç›®å½•
        fs::create_dir_all(&cgroup_path)?;

        Ok(Self { cgroup_path })
    }

    pub fn set_memory_limit(&self, bytes: u64) -> std::io::Result<()> {
        let limit_path = self.cgroup_path.join("memory.max");
        fs::write(limit_path, bytes.to_string())?;
        Ok(())
    }

    pub fn set_cpu_weight(&self, weight: u64) -> std::io::Result<()> {
        // CPUæƒé‡ï¼š1-10000
        let weight_path = self.cgroup_path.join("cpu.weight");
        fs::write(weight_path, weight.to_string())?;
        Ok(())
    }

    pub fn add_process(&self, pid: u32) -> std::io::Result<()> {
        let procs_path = self.cgroup_path.join("cgroup.procs");
        fs::write(procs_path, pid.to_string())?;
        Ok(())
    }

    pub fn get_memory_usage(&self) -> std::io::Result<u64> {
        let current_path = self.cgroup_path.join("memory.current");
        let content = fs::read_to_string(current_path)?;
        content.trim().parse()
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn spawn_with_cgroups() -> std::io::Result<()> {
    let cgroup = CgroupController::new("my_worker")?;

    // è®¾ç½®é™åˆ¶
    cgroup.set_memory_limit(100 * 1024 * 1024)?;  // 100MB
    cgroup.set_cpu_weight(100)?;                   // é»˜è®¤æƒé‡

    // å¯åŠ¨è¿›ç¨‹
    let child = std::process::Command::new("worker").spawn()?;

    // å°†è¿›ç¨‹åŠ å…¥cgroup
    cgroup.add_process(child.id())?;

    println!("è¿›ç¨‹ {} å·²åŠ å…¥cgroup", child.id());

    Ok(())
}
```

---

### 2.3 å†…å­˜ä¸CPUé™åˆ¶

**è¿è¡Œæ—¶ç›‘æ§ä¸é™åˆ¶**:

```rust
use sysinfo::{System, SystemExt, ProcessExt};

pub struct RuntimeLimiter {
    max_memory: u64,
    max_cpu_percent: f32,
    system: System,
}

impl RuntimeLimiter {
    pub fn new(max_memory: u64, max_cpu_percent: f32) -> Self {
        Self {
            max_memory,
            max_cpu_percent,
            system: System::new_all(),
        }
    }

    pub fn check_and_limit(&mut self, pid: u32) -> bool {
        self.system.refresh_all();

        if let Some(process) = self.system.process(sysinfo::Pid::from(pid as usize)) {
            // æ£€æŸ¥å†…å­˜
            if process.memory() > self.max_memory {
                eprintln!("è¿›ç¨‹ {} è¶…å‡ºå†…å­˜é™åˆ¶", pid);
                return false;
            }

            // æ£€æŸ¥CPU
            if process.cpu_usage() > self.max_cpu_percent {
                eprintln!("è¿›ç¨‹ {} è¶…å‡ºCPUé™åˆ¶", pid);
                return false;
            }

            return true;
        }

        false
    }

    pub fn enforce_limits(&mut self, mut child: std::process::Child)
        -> std::io::Result<()>
    {
        loop {
            std::thread::sleep(std::time::Duration::from_secs(1));

            if !self.check_and_limit(child.id()) {
                println!("ç»ˆæ­¢è¿è§„è¿›ç¨‹ {}", child.id());
                child.kill()?;
                break;
            }

            // æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å·²ç»“æŸ
            if let Ok(Some(_)) = child.try_wait() {
                break;
            }
        }

        Ok(())
    }
}
```

---

## 3. å®¹å™¨åŒ–æŠ€æœ¯

### 3.1 Linux Namespaces

**å®Œæ•´çš„å‘½åç©ºé—´éš”ç¦»**:

```rust
#[cfg(target_os = "linux")]
use nix::sched::{unshare, CloneFlags};
#[cfg(target_os = "linux")]
use nix::unistd::{sethostname, Pid};

#[cfg(target_os = "linux")]
pub struct NamespaceConfig {
    pub isolate_pid: bool,
    pub isolate_net: bool,
    pub isolate_mnt: bool,
    pub isolate_uts: bool,
    pub isolate_ipc: bool,
    pub isolate_user: bool,
}

#[cfg(target_os = "linux")]
impl NamespaceConfig {
    pub fn full_isolation() -> Self {
        Self {
            isolate_pid: true,
            isolate_net: true,
            isolate_mnt: true,
            isolate_uts: true,
            isolate_ipc: true,
            isolate_user: true,
        }
    }

    pub fn apply(&self) -> nix::Result<()> {
        let mut flags = CloneFlags::empty();

        if self.isolate_pid {
            flags |= CloneFlags::CLONE_NEWPID;
        }
        if self.isolate_net {
            flags |= CloneFlags::CLONE_NEWNET;
        }
        if self.isolate_mnt {
            flags |= CloneFlags::CLONE_NEWNS;
        }
        if self.isolate_uts {
            flags |= CloneFlags::CLONE_NEWUTS;
        }
        if self.isolate_ipc {
            flags |= CloneFlags::CLONE_NEWIPC;
        }
        if self.isolate_user {
            flags |= CloneFlags::CLONE_NEWUSER;
        }

        unshare(flags)?;

        Ok(())
    }
}

#[cfg(target_os = "linux")]
pub fn spawn_in_namespace(
    config: NamespaceConfig,
    command: &str,
) -> std::io::Result<std::process::Child> {
    use std::os::unix::process::CommandExt;

    std::process::Command::new(command)
        .pre_exec(move || {
            config.apply()
                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

            // è®¾ç½®ä¸»æœºå
            sethostname("container")
                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

            Ok(())
        })
        .spawn()
}
```

---

### 3.2 ç½‘ç»œéš”ç¦»

**ç½‘ç»œå‘½åç©ºé—´é…ç½®**:

```rust
#[cfg(target_os = "linux")]
pub fn setup_network_namespace() -> std::io::Result<()> {
    use std::process::Command;

    // åˆ›å»ºvethå¯¹
    Command::new("ip")
        .args(&["link", "add", "veth0", "type", "veth", "peer", "name", "veth1"])
        .status()?;

    // å°†veth1ç§»å…¥å‘½åç©ºé—´
    Command::new("ip")
        .args(&["link", "set", "veth1", "netns", "container"])
        .status()?;

    // é…ç½®IPåœ°å€
    Command::new("ip")
        .args(&["addr", "add", "10.0.0.1/24", "dev", "veth0"])
        .status()?;

    // å¯ç”¨æ¥å£
    Command::new("ip")
        .args(&["link", "set", "veth0", "up"])
        .status()?;

    Ok(())
}
```

---

### 3.3 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»

**chroot/pivot_root**:

```rust
#[cfg(unix)]
use std::path::Path;
#[cfg(unix)]
use nix::unistd::chroot;

#[cfg(unix)]
pub fn setup_chroot(root_path: &Path) -> nix::Result<()> {
    // åˆ‡æ¢æ ¹ç›®å½•
    chroot(root_path)?;

    // åˆ‡æ¢å·¥ä½œç›®å½•
    std::env::set_current_dir("/")?;

    Ok(())
}

#[cfg(target_os = "linux")]
pub fn setup_pivot_root(
    new_root: &Path,
    put_old: &Path,
) -> nix::Result<()> {
    use nix::mount::{mount, umount2, MsFlags, MntFlags};
    use nix::unistd::pivot_root;

    // æŒ‚è½½new_root
    mount(
        Some(new_root),
        new_root,
        None::<&str>,
        MsFlags::MS_BIND | MsFlags::MS_REC,
        None::<&str>,
    )?;

    // åˆ‡æ¢æ ¹
    pivot_root(new_root, put_old)?;

    // åˆ‡æ¢åˆ°æ–°æ ¹
    std::env::set_current_dir("/")?;

    // å¸è½½æ—§æ ¹
    umount2(put_old, MntFlags::MNT_DETACH)?;

    Ok(())
}
```

---

## 4. å®‰å…¨æœºåˆ¶

### 4.1 Seccompè¿‡æ»¤

**ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤**:

```rust
#[cfg(target_os = "linux")]
use seccompiler::{SeccompAction, SeccompFilter, SeccompRule, BpfProgram};

#[cfg(target_os = "linux")]
pub fn create_seccomp_filter() -> Result<BpfProgram, Box<dyn std::error::Error>> {
    let mut filter = SeccompFilter::new(
        vec![
            // å…è®¸çš„ç³»ç»Ÿè°ƒç”¨
            (libc::SYS_read, vec![]),
            (libc::SYS_write, vec![]),
            (libc::SYS_exit, vec![]),
            (libc::SYS_exit_group, vec![]),
            (libc::SYS_rt_sigreturn, vec![]),

            // ç¦æ­¢å±é™©è°ƒç”¨
            // (libc::SYS_execve è¢«é»˜è®¤ç¦æ­¢)
            // (libc::SYS_ptrace è¢«é»˜è®¤ç¦æ­¢)
        ].into_iter().collect(),
        SeccompAction::Trap,  // è¿è§„æ—¶è§¦å‘trap
    )?;

    let program: BpfProgram = filter.try_into()?;
    Ok(program)
}

#[cfg(target_os = "linux")]
pub fn apply_seccomp() -> Result<(), Box<dyn std::error::Error>> {
    let program = create_seccomp_filter()?;

    // åº”ç”¨è¿‡æ»¤å™¨
    seccompiler::apply_filter(&program)?;

    Ok(())
}
```

---

### 4.2 AppArmor/SELinux

**AppArmoré…ç½®æ–‡ä»¶ç”Ÿæˆ**:

```rust
pub struct AppArmorProfile {
    name: String,
    rules: Vec<String>,
}

impl AppArmorProfile {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            rules: Vec::new(),
        }
    }

    pub fn allow_read(&mut self, path: &str) -> &mut Self {
        self.rules.push(format!("  {} r,", path));
        self
    }

    pub fn allow_write(&mut self, path: &str) -> &mut Self {
        self.rules.push(format!("  {} w,", path));
        self
    }

    pub fn allow_execute(&mut self, path: &str) -> &mut Self {
        self.rules.push(format!("  {} ix,", path));
        self
    }

    pub fn generate(&self) -> String {
        format!(
            r#"#include <tunables/global>

profile {} {{
  #include <abstractions/base>

  # è§„åˆ™
{}

  # æ‹’ç»å…¶ä»–
  /** ix,
}}
"#,
            self.name,
            self.rules.join("\n")
        )
    }

    pub fn save(&self, path: &std::path::Path) -> std::io::Result<()> {
        std::fs::write(path, self.generate())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn create_worker_profile() -> std::io::Result<()> {
    let mut profile = AppArmorProfile::new("worker");

    profile
        .allow_read("/usr/bin/worker")
        .allow_execute("/usr/bin/worker")
        .allow_read("/etc/worker.conf")
        .allow_write("/var/log/worker/*.log");

    profile.save(std::path::Path::new("/etc/apparmor.d/worker"))?;

    println!("AppArmor profile created");

    Ok(())
}
```

---

### 4.3 å®¡è®¡æ—¥å¿—

**å®‰å…¨äº‹ä»¶å®¡è®¡**:

```rust
use std::fs::OpenOptions;
use std::io::Write;
use chrono::Utc;

pub struct SecurityAuditor {
    log_path: std::path::PathBuf,
}

pub enum SecurityEvent {
    PrivilegeEscalation { pid: u32, from_uid: u32, to_uid: u32 },
    ResourceLimitViolation { pid: u32, resource: String, limit: u64 },
    SyscallViolation { pid: u32, syscall: String },
    NetworkViolation { pid: u32, dest: String },
}

impl SecurityAuditor {
    pub fn new(log_path: std::path::PathBuf) -> Self {
        Self { log_path }
    }

    pub fn log_event(&self, event: SecurityEvent) -> std::io::Result<()> {
        let timestamp = Utc::now().to_rfc3339();

        let message = match event {
            SecurityEvent::PrivilegeEscalation { pid, from_uid, to_uid } => {
                format!("[{}] PRIVILEGE_ESCALATION pid={} from_uid={} to_uid={}",
                    timestamp, pid, from_uid, to_uid)
            }
            SecurityEvent::ResourceLimitViolation { pid, resource, limit } => {
                format!("[{}] RESOURCE_VIOLATION pid={} resource={} limit={}",
                    timestamp, pid, resource, limit)
            }
            SecurityEvent::SyscallViolation { pid, syscall } => {
                format!("[{}] SYSCALL_VIOLATION pid={} syscall={}",
                    timestamp, pid, syscall)
            }
            SecurityEvent::NetworkViolation { pid, dest } => {
                format!("[{}] NETWORK_VIOLATION pid={} dest={}",
                    timestamp, pid, dest)
            }
        };

        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_path)?;

        writeln!(file, "{}", message)?;

        Ok(())
    }
}
```

---

## 5. æ²™ç®±å®ç°

### å®Œæ•´çš„æ²™ç®±ç³»ç»Ÿ

```rust
use std::process::{Command, Child};
use std::path::PathBuf;

pub struct Sandbox {
    root_dir: PathBuf,
    user: String,
    resource_limits: ResourceLimits,
    #[cfg(target_os = "linux")]
    namespace_config: NamespaceConfig,
    auditor: SecurityAuditor,
}

impl Sandbox {
    pub fn builder() -> SandboxBuilder {
        SandboxBuilder::new()
    }

    pub fn execute(&self, command: &str) -> std::io::Result<Child> {
        // 1. åˆ›å»ºå®¡è®¡æ—¥å¿—
        self.auditor.log_event(SecurityEvent::ProcessSpawn {
            command: command.to_string(),
        })?;

        // 2. å‡†å¤‡å‘½ä»¤
        let mut cmd = Command::new(command);

        // 3. åº”ç”¨èµ„æºé™åˆ¶
        #[cfg(unix)]
        {
            use std::os::unix::process::CommandExt;

            cmd.pre_exec(move || {
                // åº”ç”¨rlimit
                self.resource_limits.apply()
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

                // åº”ç”¨å‘½åç©ºé—´
                #[cfg(target_os = "linux")]
                {
                    self.namespace_config.apply()
                        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
                }

                // chroot
                setup_chroot(&self.root_dir)
                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

                Ok(())
            });
        }

        // 4. å¯åŠ¨è¿›ç¨‹
        cmd.spawn()
    }
}

pub struct SandboxBuilder {
    root_dir: Option<PathBuf>,
    user: Option<String>,
    cpu_limit: Option<u64>,
    memory_limit: Option<u64>,
    log_path: Option<PathBuf>,
}

impl SandboxBuilder {
    pub fn new() -> Self {
        Self {
            root_dir: None,
            user: None,
            cpu_limit: None,
            memory_limit: None,
            log_path: None,
        }
    }

    pub fn root_dir(mut self, path: PathBuf) -> Self {
        self.root_dir = Some(path);
        self
    }

    pub fn user(mut self, user: String) -> Self {
        self.user = Some(user);
        self
    }

    pub fn cpu_limit(mut self, seconds: u64) -> Self {
        self.cpu_limit = Some(seconds);
        self
    }

    pub fn memory_limit(mut self, bytes: u64) -> Self {
        self.memory_limit = Some(bytes);
        self
    }

    pub fn log_path(mut self, path: PathBuf) -> Self {
        self.log_path = Some(path);
        self
    }

    pub fn build(self) -> Sandbox {
        let mut limits = ResourceLimits::new();

        if let Some(cpu) = self.cpu_limit {
            limits = limits.cpu(cpu);
        }
        if let Some(mem) = self.memory_limit {
            limits = limits.memory(mem);
        }

        Sandbox {
            root_dir: self.root_dir.unwrap_or_else(|| PathBuf::from("/tmp/sandbox")),
            user: self.user.unwrap_or_else(|| "nobody".to_string()),
            resource_limits: limits,
            #[cfg(target_os = "linux")]
            namespace_config: NamespaceConfig::full_isolation(),
            auditor: SecurityAuditor::new(
                self.log_path.unwrap_or_else(|| PathBuf::from("/var/log/sandbox.log"))
            ),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    let sandbox = Sandbox::builder()
        .root_dir(PathBuf::from("/tmp/sandbox"))
        .user("nobody".to_string())
        .cpu_limit(10)
        .memory_limit(100 * 1024 * 1024)
        .log_path(PathBuf::from("/var/log/sandbox.log"))
        .build();

    let mut child = sandbox.execute("worker")?;

    println!("æ²™ç®±è¿›ç¨‹å¯åŠ¨ï¼ŒPID: {}", child.id());

    let status = child.wait()?;
    println!("è¿›ç¨‹é€€å‡º: {:?}", status);

    Ok(())
}
```

---

## 6. æœ€ä½³å®è·µ

**1. æœ€å°æƒé™åŸåˆ™**:

- âœ… ä»¥érootç”¨æˆ·è¿è¡Œ
- âœ… ä»…æˆäºˆå¿…è¦çš„capabilities
- âœ… ä½¿ç”¨å‘½åç©ºé—´éš”ç¦»

**2. æ·±åº¦é˜²å¾¡**:

```rust
// âœ… å¤šå±‚å®‰å…¨æªæ–½
Sandbox::builder()
    .user("nobody")                    // æƒé™é™çº§
    .root_dir("/jail")                 // chroot
    .cpu_limit(10)                     // èµ„æºé™åˆ¶
    .memory_limit(100 * 1024 * 1024)   // å†…å­˜é™åˆ¶
    // + namespaces                    // å‘½åç©ºé—´
    // + seccomp                       // ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤
    // + AppArmor                      // MAC
    .build();
```

**3. å®¡è®¡æ‰€æœ‰å®‰å…¨äº‹ä»¶**:

- âœ… è®°å½•æƒé™å˜æ›´
- âœ… è®°å½•èµ„æºè¿è§„
- âœ… è®°å½•ç½‘ç»œè®¿é—®

**4. å®šæœŸå®‰å…¨å®¡æŸ¥**:

- âœ… æ£€æŸ¥é…ç½®æ–‡ä»¶
- âœ… å®¡æŸ¥å®¡è®¡æ—¥å¿—
- âœ… æ›´æ–°å®‰å…¨ç­–ç•¥

**5. æµ‹è¯•å®‰å…¨æªæ–½**:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_privilege_drop() {
        // æµ‹è¯•æƒé™é™çº§
    }

    #[test]
    fn test_resource_limits() {
        // æµ‹è¯•èµ„æºé™åˆ¶
    }

    #[test]
    fn test_namespace_isolation() {
        // æµ‹è¯•å‘½åç©ºé—´éš”ç¦»
    }
}
```

---

## æ€»ç»“

**è¿›ç¨‹å®‰å…¨ä¸æ²™ç®±æ ¸å¿ƒè¦ç´ **:

1. âœ… **æƒé™æ§åˆ¶**: ç”¨æˆ·/ç»„/Capabilities
2. âœ… **èµ„æºé™åˆ¶**: rlimit/cgroups
3. âœ… **éš”ç¦»æŠ€æœ¯**: Namespaces/chroot
4. âœ… **å®‰å…¨æœºåˆ¶**: Seccomp/AppArmor/SELinux
5. âœ… **å®¡è®¡æ—¥å¿—**: å®Œæ•´çš„å®‰å…¨äº‹ä»¶è®°å½•

**å®‰å…¨ç­‰çº§**:

- **Level 1**: æƒé™é™çº§ + rlimit
- **Level 2**: + cgroups + chroot
- **Level 3**: + Namespaces + Seccomp
- **Level 4**: + AppArmor/SELinux + å®¡è®¡

---

## 7. å®¹å™¨å®‰å…¨

### 7.1 Dockerå®¹å™¨å®‰å…¨

**å®‰å…¨å®¹å™¨é…ç½®**:

```dockerfile
# å¤šé˜¶æ®µæ„å»º - æœ€å°åŒ–æ”»å‡»é¢
FROM rust:1.75 as builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bookworm-slim

# åˆ›å»ºérootç”¨æˆ·
RUN useradd -m -u 1000 appuser && \
    apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates && \
    rm -rf /var/lib/apt/lists/*

# å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/target/release/app /usr/local/bin/
RUN chown appuser:appuser /usr/local/bin/app

# åˆ‡æ¢åˆ°érootç”¨æˆ·
USER appuser

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s \
  CMD /usr/local/bin/app health || exit 1

CMD ["app"]
```

**Dockerè¿è¡Œæ—¶å®‰å…¨é€‰é¡¹**:

```bash
# å®‰å…¨è¿è¡Œå®¹å™¨
docker run \
  --rm \
  --read-only \
  --tmpfs /tmp:rw,noexec,nosuid,size=100m \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt=no-new-privileges \
  --security-opt=seccomp=/path/to/seccomp-profile.json \
  --security-opt=apparmor=docker-default \
  --pids-limit=100 \
  --memory=512m \
  --cpus=1.0 \
  --user=1000:1000 \
  myapp:latest
```

### 7.2 è¿›ç¨‹å®‰å…¨å®¡è®¡

**å®Œæ•´å®¡è®¡ç³»ç»Ÿ**:

```rust
use serde::{Serialize, Deserialize};
use std::fs::OpenOptions;
use std::io::Write;

#[derive(Serialize, Deserialize, Debug)]
pub struct SecurityEvent {
    pub timestamp: String,
    pub event_type: EventType,
    pub pid: u32,
    pub user: String,
    pub action: String,
    pub result: EventResult,
    pub details: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum EventType {
    PrivilegeEscalation,
    ResourceViolation,
    UnauthorizedAccess,
    SuspiciousActivity,
    PolicyViolation,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum EventResult {
    Allowed,
    Denied,
    Failed,
}

pub struct AuditLogger {
    log_file: PathBuf,
    syslog: Option<syslog::Logger>,
}

impl AuditLogger {
    pub fn new(log_file: PathBuf) -> Self {
        let syslog = syslog::unix(syslog::Facility::LOG_AUTH).ok();

        Self {
            log_file,
            syslog,
        }
    }

    pub fn log_event(&self, event: SecurityEvent) {
        // 1. å†™å…¥æœ¬åœ°æ–‡ä»¶
        self.log_to_file(&event);

        // 2. å†™å…¥syslog
        if let Some(ref syslog) = self.syslog {
            let msg = format!(
                "{:?}: {} by {} (PID: {}): {:?}",
                event.event_type,
                event.action,
                event.user,
                event.pid,
                event.result
            );
            syslog.err(msg).ok();
        }

        // 3. å…³é”®äº‹ä»¶å‘Šè­¦
        if matches!(event.event_type, EventType::PrivilegeEscalation) {
            self.send_alert(&event);
        }
    }

    fn log_to_file(&self, event: &SecurityEvent) {
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
            .unwrap();

        let json = serde_json::to_string(event).unwrap();
        writeln!(file, "{}", json).ok();
    }

    fn send_alert(&self, event: &SecurityEvent) {
        // å‘é€å‘Šè­¦åˆ°ç›‘æ§ç³»ç»Ÿ
        println!("âš ï¸  SECURITY ALERT: {:?}", event);
    }
}
```

---

## 8. å¨èƒæ¨¡å‹

### 8.1 å¸¸è§æ”»å‡»å‘é‡

**1. æƒé™æå‡æ”»å‡»**:

```rust
pub fn detect_privilege_escalation(child: &Child) -> bool {
    #[cfg(unix)]
    {
        use nix::unistd::{getuid, Uid};

        if let Some(pid) = child.id() {
            // æ£€æŸ¥è¿›ç¨‹çš„æœ‰æ•ˆUID
            let proc_status = std::fs::read_to_string(
                format!("/proc/{}/status", pid)
            ).ok()?;

            for line in proc_status.lines() {
                if line.starts_with("Uid:") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        let euid: u32 = parts[2].parse().ok()?;

                        // æ£€æŸ¥æ˜¯å¦æå‡åˆ°root
                        if euid == 0 && getuid() != Uid::from_raw(0) {
                            return true;  // æ£€æµ‹åˆ°æƒé™æå‡
                        }
                    }
                }
            }
        }
    }

    false
}
```

**2. èµ„æºè€—å°½æ”»å‡»**:

```rust
pub struct ResourceMonitor {
    limits: ResourceLimits,
    violations: Arc<Mutex<Vec<Violation>>>,
}

impl ResourceMonitor {
    pub async fn monitor_process(&self, pid: u32) {
        let mut system = sysinfo::System::new_all();

        loop {
            system.refresh_process(sysinfo::Pid::from_u32(pid));

            if let Some(process) = system.process(sysinfo::Pid::from_u32(pid)) {
                // CPUæ£€æŸ¥
                if process.cpu_usage() > self.limits.max_cpu {
                    self.record_violation(Violation {
                        pid,
                        violation_type: ViolationType::CpuExhaustion,
                        value: process.cpu_usage() as f64,
                    }).await;
                }

                // å†…å­˜æ£€æŸ¥
                if process.memory() > self.limits.max_memory {
                    self.record_violation(Violation {
                        pid,
                        violation_type: ViolationType::MemoryExhaustion,
                        value: process.memory() as f64,
                    }).await;
                }
            }

            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    }

    async fn record_violation(&self, violation: Violation) {
        let mut violations = self.violations.lock().await;
        violations.push(violation);

        // è¶…è¿‡é˜ˆå€¼ï¼šç»ˆæ­¢è¿›ç¨‹
        if violations.len() > 3 {
            println!("ç»ˆæ­¢æ¶æ„è¿›ç¨‹: PID {}", violation.pid);
            unsafe {
                libc::kill(violation.pid as i32, libc::SIGKILL);
            }
        }
    }
}
```

**3. é€ƒé€¸æ”»å‡»é˜²å¾¡**:

```rust
pub fn verify_sandbox_integrity(sandbox: &Sandbox) -> Result<(), SecurityError> {
    #[cfg(target_os = "linux")]
    {
        use std::fs;

        // 1. éªŒè¯å‘½åç©ºé—´
        let ns_types = vec!["mnt", "pid", "net", "ipc", "uts"];

        for ns_type in ns_types {
            let ns_path = format!("/proc/self/ns/{}", ns_type);
            if !fs::metadata(&ns_path).is_ok() {
                return Err(SecurityError::NamespaceError(
                    format!("å‘½åç©ºé—´ {} ä¸å­˜åœ¨", ns_type)
                ));
            }
        }

        // 2. éªŒè¯æ ¹ç›®å½•
        let root = fs::read_link("/proc/self/root")?;
        if root == PathBuf::from("/") {
            return Err(SecurityError::EscapeAttempt(
                "æ ¹ç›®å½•æœªè¢«chroot".to_string()
            ));
        }

        // 3. éªŒè¯capabilities
        let cap_status = fs::read_to_string("/proc/self/status")?;
        for line in cap_status.lines() {
            if line.starts_with("CapEff:") {
                let cap_hex = line.split_whitespace().nth(1).unwrap();
                let cap_value = u64::from_str_radix(cap_hex, 16)?;

                // æ£€æŸ¥æ˜¯å¦æœ‰å±é™©çš„capabilities
                if cap_value & (1 << CAP_SYS_ADMIN) != 0 {
                    return Err(SecurityError::DangerousCapability(
                        "æ‹¥æœ‰CAP_SYS_ADMIN".to_string()
                    ));
                }
            }
        }
    }

    Ok(())
}

const CAP_SYS_ADMIN: u64 = 21;
```

---

## 9. å®‰å…¨é…ç½®æ¨¡æ¿

### 9.1 é«˜å®‰å…¨çº§åˆ«é…ç½®

**ç”Ÿäº§ç¯å¢ƒå®‰å…¨æ¨¡æ¿**:

```rust
pub fn production_security_config() -> SandboxBuilder {
    Sandbox::builder()
        // 1. æƒé™æœ€å°åŒ–
        .user("nobody".to_string())
        .drop_all_capabilities()
        .add_capability(Capability::CAP_NET_BIND_SERVICE)  // ä»…ç»‘å®šç«¯å£

        // 2. èµ„æºä¸¥æ ¼é™åˆ¶
        .cpu_limit(10)                           // 10ç§’CPU
        .memory_limit(256 * 1024 * 1024)        // 256MB
        .process_limit(50)                       // æœ€å¤š50ä¸ªè¿›ç¨‹
        .file_descriptors_limit(1024)           // æœ€å¤š1024ä¸ªæ–‡ä»¶æè¿°ç¬¦

        // 3. æ–‡ä»¶ç³»ç»Ÿéš”ç¦»
        .root_dir(PathBuf::from("/var/sandbox"))
        .mount_readonly("/etc")
        .mount_readonly("/usr")
        .mount_tmpfs("/tmp", 100 * 1024 * 1024)  // 100MBä¸´æ—¶ç©ºé—´

        // 4. ç½‘ç»œéš”ç¦»
        .network_namespace(true)
        .allow_outbound_only()

        // 5. Seccompä¸¥æ ¼è¿‡æ»¤
        .seccomp_profile(SeccompProfile::Strict)

        // 6. å®¡è®¡æ‰€æœ‰äº‹ä»¶
        .log_path(PathBuf::from("/var/log/sandbox/security.log"))
        .audit_level(AuditLevel::Verbose)
}
```

### 9.2 å¼€å‘ç¯å¢ƒé…ç½®

**å¼€å‘è°ƒè¯•å‹å¥½é…ç½®**:

```rust
pub fn development_security_config() -> SandboxBuilder {
    Sandbox::builder()
        // 1. å®½æ¾æƒé™ï¼ˆæ–¹ä¾¿è°ƒè¯•ï¼‰
        .user(std::env::var("USER").unwrap())

        // 2. è¾ƒé«˜èµ„æºé™åˆ¶
        .cpu_limit(60)
        .memory_limit(2 * 1024 * 1024 * 1024)  // 2GB
        .process_limit(200)

        // 3. æ–‡ä»¶ç³»ç»Ÿè®¿é—®
        .root_dir(PathBuf::from("/tmp/dev-sandbox"))
        .bind_mount(std::env::current_dir().unwrap(), "/workspace")

        // 4. ç½‘ç»œå…¨å¼€
        .network_namespace(false)

        // 5. å®½æ¾Seccomp
        .seccomp_profile(SeccompProfile::Permissive)

        // 6. è¯¦ç»†æ—¥å¿—
        .log_path(PathBuf::from("/tmp/sandbox-dev.log"))
        .audit_level(AuditLevel::Debug)
}
```

---

## 10. å®‰å…¨æµ‹è¯•

### 10.1 å®‰å…¨æµ‹è¯•å¥—ä»¶

**å®Œæ•´å®‰å…¨æµ‹è¯•**:

```rust
#[cfg(test)]
mod security_tests {
    use super::*;

    #[test]
    #[cfg(target_os = "linux")]
    fn test_privilege_drop() {
        let sandbox = Sandbox::builder()
            .user("nobody".to_string())
            .build();

        let mut child = sandbox.execute("id").unwrap();
        let output = child.wait_with_output().unwrap();

        let stdout = String::from_utf8_lossy(&output.stdout);

        // éªŒè¯è¿›ç¨‹ä»¥nobodyè¿è¡Œ
        assert!(stdout.contains("uid=") && stdout.contains("nobody"));
        assert!(!stdout.contains("uid=0"));  // ä¸æ˜¯root
    }

    #[test]
    #[cfg(target_os = "linux")]
    fn test_resource_limits() {
        let sandbox = Sandbox::builder()
            .memory_limit(10 * 1024 * 1024)  // 10MB
            .build();

        // å°è¯•åˆ†é…è¶…è¿‡é™åˆ¶çš„å†…å­˜
        let result = sandbox.execute_with_args(
            "python3",
            &["-c", "x = 'a' * (100 * 1024 * 1024)"]
        );

        // åº”è¯¥è¢«èµ„æºé™åˆ¶kill
        assert!(result.is_err() || !result.unwrap().wait().unwrap().success());
    }

    #[test]
    #[cfg(target_os = "linux")]
    fn test_filesystem_isolation() {
        let sandbox = Sandbox::builder()
            .root_dir(PathBuf::from("/tmp/sandbox-test"))
            .build();

        let mut child = sandbox.execute_with_args(
            "ls",
            &["/etc/passwd"]
        ).unwrap();

        let output = child.wait_with_output().unwrap();

        // åº”è¯¥æ— æ³•è®¿é—®ä¸»æœºæ–‡ä»¶ç³»ç»Ÿ
        assert!(!output.status.success());
    }

    #[test]
    fn test_capability_drop() {
        // æµ‹è¯•capabilitiesè¢«æ­£ç¡®ç§»é™¤
    }

    #[test]
    fn test_namespace_isolation() {
        // æµ‹è¯•å‘½åç©ºé—´éš”ç¦»
    }
}
```

### 10.2 æ¸—é€æµ‹è¯•æ¸…å•

**å®‰å…¨æ£€æŸ¥æ¸…å•**:

```markdown
## æƒé™æµ‹è¯•

- [ ] è¿›ç¨‹ä»¥érootç”¨æˆ·è¿è¡Œ
- [ ] Capabilitiesè¢«æ­£ç¡®é™åˆ¶
- [ ] Seccompè¿‡æ»¤ç”Ÿæ•ˆ
- [ ] æ— æ³•æå‡æƒé™

## éš”ç¦»æµ‹è¯•

- [ ] æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æœ‰æ•ˆ
- [ ] ç½‘ç»œå‘½åç©ºé—´éš”ç¦»
- [ ] PIDå‘½åç©ºé—´éš”ç¦»
- [ ] æ— æ³•è®¿é—®ä¸»æœºèµ„æº

## èµ„æºé™åˆ¶æµ‹è¯•

- [ ] CPUé™åˆ¶ç”Ÿæ•ˆ
- [ ] å†…å­˜é™åˆ¶ç”Ÿæ•ˆ
- [ ] è¿›ç¨‹æ•°é™åˆ¶ç”Ÿæ•ˆ
- [ ] æ–‡ä»¶æè¿°ç¬¦é™åˆ¶ç”Ÿæ•ˆ

## å®¡è®¡æµ‹è¯•

- [ ] å®‰å…¨äº‹ä»¶è¢«è®°å½•
- [ ] è¿è§„è¡Œä¸ºè¢«æ£€æµ‹
- [ ] å‘Šè­¦æœºåˆ¶æ­£å¸¸å·¥ä½œ
```

---

**ä¸‹ä¸€æ­¥**: [03\_æ€§èƒ½å·¥ç¨‹å®è·µ.md](./03_æ€§èƒ½å·¥ç¨‹å®è·µ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
