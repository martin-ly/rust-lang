# Tier 3: æ€§èƒ½ä¼˜åŒ–å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: æŠ€æœ¯å‚è€ƒ  
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
> **å‰ç½®çŸ¥è¯†**: [è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­](../tier_02_guides/05_è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­.md)

---

## ç›®å½•

- [Tier 3: æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](#tier-3-æ€§èƒ½ä¼˜åŒ–å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ€§èƒ½åˆ†ææ–¹æ³•](#1-æ€§èƒ½åˆ†ææ–¹æ³•)
    - [1.1 æ€§èƒ½åˆ†æå·¥å…·](#11-æ€§èƒ½åˆ†æå·¥å…·)
    - [1.2 æ€§èƒ½æŒ‡æ ‡](#12-æ€§èƒ½æŒ‡æ ‡)
  - [2. è¿›ç¨‹å¯åŠ¨ä¼˜åŒ–](#2-è¿›ç¨‹å¯åŠ¨ä¼˜åŒ–)
    - [2.1 å‡å°‘å¯åŠ¨æ—¶é—´](#21-å‡å°‘å¯åŠ¨æ—¶é—´)
    - [2.2 å‡å°‘èµ„æºå ç”¨](#22-å‡å°‘èµ„æºå ç”¨)
  - [3. IPCæ€§èƒ½ä¼˜åŒ–](#3-ipcæ€§èƒ½ä¼˜åŒ–)
    - [3.1 IPCæœºåˆ¶é€‰æ‹©](#31-ipcæœºåˆ¶é€‰æ‹©)
    - [3.2 ç¼“å†²ä¼˜åŒ–](#32-ç¼“å†²ä¼˜åŒ–)
    - [3.3 é›¶æ‹·è´æŠ€æœ¯](#33-é›¶æ‹·è´æŠ€æœ¯)
  - [4. å†…å­˜ä¼˜åŒ–](#4-å†…å­˜ä¼˜åŒ–)
    - [4.1 å‡å°‘å†…å­˜åˆ†é…](#41-å‡å°‘å†…å­˜åˆ†é…)
    - [4.2 å†…å­˜æ˜ å°„](#42-å†…å­˜æ˜ å°„)
  - [5. CPUä¼˜åŒ–](#5-cpuä¼˜åŒ–)
    - [5.1 å¹¶è¡ŒåŒ–](#51-å¹¶è¡ŒåŒ–)
    - [5.2 å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢](#52-å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢)
  - [6. I/Oä¼˜åŒ–](#6-ioä¼˜åŒ–)
    - [6.1 å¼‚æ­¥I/O](#61-å¼‚æ­¥io)
    - [6.2 æ‰¹é‡I/O](#62-æ‰¹é‡io)
  - [7. å¹¶å‘ä¼˜åŒ–](#7-å¹¶å‘ä¼˜åŒ–)
    - [7.1 è¿›ç¨‹æ± ](#71-è¿›ç¨‹æ± )
    - [7.2 åŠ¨æ€æ‰©ç¼©å®¹](#72-åŠ¨æ€æ‰©ç¼©å®¹)
  - [8. åŸºå‡†æµ‹è¯•](#8-åŸºå‡†æµ‹è¯•)
    - [8.1 CriterionåŸºå‡†æµ‹è¯•](#81-criterionåŸºå‡†æµ‹è¯•)
    - [8.2 å¯¹æ¯”åŸºå‡†](#82-å¯¹æ¯”åŸºå‡†)
  - [9. æ€§èƒ½ç›‘æ§](#9-æ€§èƒ½ç›‘æ§)
    - [9.1 è¿è¡Œæ—¶ç›‘æ§](#91-è¿è¡Œæ—¶ç›‘æ§)
    - [9.2 æ€§èƒ½æŒ‡æ ‡æ”¶é›†](#92-æ€§èƒ½æŒ‡æ ‡æ”¶é›†)
  - [10. å®æˆ˜æ¡ˆä¾‹](#10-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹: é«˜æ€§èƒ½æ‰¹å¤„ç†ç³»ç»Ÿ](#æ¡ˆä¾‹-é«˜æ€§èƒ½æ‰¹å¤„ç†ç³»ç»Ÿ)
  - [æ€»ç»“](#æ€»ç»“)

---

## 1. æ€§èƒ½åˆ†ææ–¹æ³•

### 1.1 æ€§èƒ½åˆ†æå·¥å…·

**Linuxå·¥å…·é“¾**:

```bash
# CPUåˆ†æ
perf record -g ./myapp
perf report

# ç«ç„°å›¾
perf script | flamegraph.pl > flame.svg

# å†…å­˜åˆ†æ
valgrind --tool=massif ./myapp

# ç³»ç»Ÿè°ƒç”¨è¿½è¸ª
strace -c ./myapp
```

**Rustä¸“ç”¨å·¥å…·**:

```bash
# CriterionåŸºå‡†æµ‹è¯•
cargo bench

# flamegraph
cargo install flamegraph
cargo flamegraph --bin myapp

# cargo-profdata
cargo install cargo-profdata
cargo profdata -- ./target/release/myapp
```

---

### 1.2 æ€§èƒ½æŒ‡æ ‡

**æ ¸å¿ƒæŒ‡æ ‡**:

| æŒ‡æ ‡ | è¯´æ˜ | ç›®æ ‡ |
|------|------|------|
| **ååé‡** | å•ä½æ—¶é—´å¤„ç†é‡ | è¶Šé«˜è¶Šå¥½ |
| **å»¶è¿Ÿ** | å“åº”æ—¶é—´ | è¶Šä½è¶Šå¥½ |
| **CPUä½¿ç”¨ç‡** | CPUå ç”¨ç™¾åˆ†æ¯” | é€‚ä¸­ |
| **å†…å­˜å ç”¨** | å¸¸é©»å†…å­˜å¤§å° | è¶Šå°è¶Šå¥½ |
| **è¿›ç¨‹æ•°** | å¹¶å‘è¿›ç¨‹æ•°é‡ | é€‚å½“ |

---

## 2. è¿›ç¨‹å¯åŠ¨ä¼˜åŒ–

### 2.1 å‡å°‘å¯åŠ¨æ—¶é—´

**ç­–ç•¥1: é¢„çƒ­è¿›ç¨‹æ± **:

```rust
use std::process::Command;

pub struct ProcessPool {
    workers: Vec<std::process::Child>,
}

impl ProcessPool {
    pub fn new(size: usize, program: &str) -> std::io::Result<Self> {
        let mut workers = Vec::with_capacity(size);
        
        for _ in 0..size {
            let child = Command::new(program).spawn()?;
            workers.push(child);
        }
        
        Ok(Self { workers })
    }
}

// å¯åŠ¨æ—¶é¢„çƒ­10ä¸ªè¿›ç¨‹
let pool = ProcessPool::new(10, "worker")?;
```

**ç­–ç•¥2: å»¶è¿Ÿå¯åŠ¨**:

```rust
use std::sync::LazyLock;

static PROCESS: LazyLock<Child> = LazyLock::new(|| {
    Command::new("worker").spawn().unwrap()
});

// é¦–æ¬¡ä½¿ç”¨æ—¶æ‰å¯åŠ¨
let pid = PROCESS.id();
```

**åŸºå‡†æµ‹è¯•** (å¯åŠ¨100ä¸ªè¿›ç¨‹):

| æ–¹æ³• | è€—æ—¶ |
|------|------|
| é€ä¸ªå¯åŠ¨ | 1,500ms |
| æ‰¹é‡å¯åŠ¨ | 800ms |
| è¿›ç¨‹æ±  (é¢„çƒ­) | 50ms âœ… |

---

### 2.2 å‡å°‘èµ„æºå ç”¨

**æœ€å°åŒ–ç¯å¢ƒå˜é‡**:

```rust
// âŒ ç»§æ‰¿æ‰€æœ‰ç¯å¢ƒå˜é‡
Command::new("app").spawn()?;

// âœ… ä»…ä¼ é€’å¿…è¦çš„
Command::new("app")
    .env_clear()
    .env("PATH", "/usr/bin")
    .spawn()?;
```

**ä¼˜åŒ–å·¥ä½œç›®å½•**:

```rust
// è®¾ç½®åˆé€‚çš„å·¥ä½œç›®å½•
Command::new("app")
    .current_dir("/tmp")  // å¿«é€Ÿçš„tmpfs
    .spawn()?;
```

---

## 3. IPCæ€§èƒ½ä¼˜åŒ–

### 3.1 IPCæœºåˆ¶é€‰æ‹©

**æ€§èƒ½æ’åº** (åŒä¸»æœº):

1. ğŸ¥‡ **å…±äº«å†…å­˜**: ~20 GB/s
2. ğŸ¥ˆ **Unix Socket**: ~10 GB/s
3. ğŸ¥‰ **ç®¡é“**: ~1 GB/s
4. **TCP Socket**: ~1 GB/s

**é€‰æ‹©å†³ç­–**:

```rust
pub fn select_ipc(data_size: usize, local: bool) -> &'static str {
    match (data_size, local) {
        (size, true) if size > 1024 * 1024 => "shared_memory",  // >1MB
        (_, true) => "unix_socket",
        (_, false) => "tcp_socket",
    }
}
```

---

### 3.2 ç¼“å†²ä¼˜åŒ–

**ä½¿ç”¨BufReader/BufWriter**:

```rust
use std::io::{BufReader, BufWriter, Write, Read};

// âŒ ä½æ•ˆï¼šæ— ç¼“å†²
for byte in data {
    stdout.write(&[byte])?;
}

// âœ… é«˜æ•ˆï¼šå¤§ç¼“å†²
let mut writer = BufWriter::with_capacity(64 * 1024, stdout);
writer.write_all(&data)?;
writer.flush()?;
```

**æ€§èƒ½å¯¹æ¯”** (ä¼ è¾“10MB):

| æ–¹æ³• | è€—æ—¶ |
|------|------|
| æ— ç¼“å†² | 2,500ms |
| é»˜è®¤ç¼“å†²(8KB) | 150ms |
| å¤§ç¼“å†²(64KB) | 80ms âœ… |

---

### 3.3 é›¶æ‹·è´æŠ€æœ¯

**sendfile (Linux)**:

```rust
#[cfg(target_os = "linux")]
fn zero_copy_transfer(from: &File, to: &File, len: usize) -> std::io::Result<()> {
    use std::os::unix::io::AsRawFd;
    
    unsafe {
        libc::sendfile(
            to.as_raw_fd(),
            from.as_raw_fd(),
            std::ptr::null_mut(),
            len,
        );
    }
    
    Ok(())
}
```

---

## 4. å†…å­˜ä¼˜åŒ–

### 4.1 å‡å°‘å†…å­˜åˆ†é…

**å¯¹è±¡æ± æ¨¡å¼**:

```rust
use std::collections::VecDeque;

pub struct ByteBufferPool {
    buffers: VecDeque<Vec<u8>>,
    capacity: usize,
}

impl ByteBufferPool {
    pub fn new(size: usize, capacity: usize) -> Self {
        let mut buffers = VecDeque::with_capacity(size);
        for _ in 0..size {
            buffers.push_back(Vec::with_capacity(capacity));
        }
        
        Self { buffers, capacity }
    }
    
    pub fn acquire(&mut self) -> Vec<u8> {
        self.buffers.pop_front()
            .unwrap_or_else(|| Vec::with_capacity(self.capacity))
    }
    
    pub fn release(&mut self, mut buf: Vec<u8>) {
        buf.clear();
        self.buffers.push_back(buf);
    }
}
```

---

### 4.2 å†…å­˜æ˜ å°„

**mmapä¼˜åŒ–**:

```rust
use memmap2::MmapMut;

fn use_mmap(size: usize) -> std::io::Result<()> {
    let file = std::fs::OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open("/tmp/data")?;
    
    file.set_len(size as u64)?;
    
    let mut mmap = unsafe { MmapMut::map_mut(&file)? };
    
    // ç›´æ¥è®¿é—®å†…å­˜
    mmap[0] = 42;
    
    mmap.flush()?;
    Ok(())
}
```

**ä¼˜ç‚¹**: å‡å°‘ç³»ç»Ÿè°ƒç”¨ã€æ‡’åŠ è½½ã€‚

---

## 5. CPUä¼˜åŒ–

### 5.1 å¹¶è¡ŒåŒ–

**Rayonå¹¶è¡Œå¤„ç†**:

```rust
use rayon::prelude::*;

// å¹¶è¡Œå¤„ç†è¿›ç¨‹è¾“å‡º
let results: Vec<_> = outputs.par_iter()
    .map(|output| process_output(output))
    .collect();
```

**æ€§èƒ½æå‡**: 4æ ¸CPUå¯æå‡3-3.5xã€‚

---

### 5.2 å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢

**æ§åˆ¶å¹¶å‘æ•°**:

```rust
use tokio::sync::Semaphore;

let sem = Arc::new(Semaphore::new(num_cpus::get()));

for task in tasks {
    let permit = sem.clone().acquire_owned().await.unwrap();
    tokio::spawn(async move {
        do_work(task).await;
        drop(permit);
    });
}
```

---

## 6. I/Oä¼˜åŒ–

### 6.1 å¼‚æ­¥I/O

**Tokioå¼‚æ­¥è¿›ç¨‹**:

```rust
use tokio::process::Command;

async fn async_execute(cmd: &str) -> std::io::Result<Vec<u8>> {
    let output = Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .output()
        .await?;
    
    Ok(output.stdout)
}

// å¹¶å‘æ‰§è¡Œ
let results = futures::future::join_all(
    commands.iter().map(|cmd| async_execute(cmd))
).await;
```

**ååé‡æå‡**: ç›¸æ¯”åŒæ­¥ç‰ˆæœ¬æå‡10-50xã€‚

---

### 6.2 æ‰¹é‡I/O

```rust
// âŒ é€ä¸ªè¯»å†™
for _ in 0..1000 {
    let byte = reader.read_u8()?;
    writer.write_u8(byte)?;
}

// âœ… æ‰¹é‡è¯»å†™
let mut buffer = vec![0; 1024];
while let Ok(n) = reader.read(&mut buffer) {
    if n == 0 { break; }
    writer.write_all(&buffer[..n])?;
}
```

---

## 7. å¹¶å‘ä¼˜åŒ–

### 7.1 è¿›ç¨‹æ± 

**é«˜çº§è¿›ç¨‹æ± **:

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

pub struct AdvancedProcessPool {
    workers: Arc<Mutex<VecDeque<Worker>>>,
    size: usize,
}

struct Worker {
    child: Child,
    busy: bool,
}

impl AdvancedProcessPool {
    pub fn new(size: usize, program: &str) -> std::io::Result<Self> {
        let mut workers = VecDeque::with_capacity(size);
        
        for _ in 0..size {
            let child = Command::new(program).spawn()?;
            workers.push_back(Worker {
                child,
                busy: false,
            });
        }
        
        Ok(Self {
            workers: Arc::new(Mutex::new(workers)),
            size,
        })
    }
    
    pub fn execute<F>(&self, task: F) -> std::io::Result<()>
    where
        F: FnOnce(&mut Child) -> std::io::Result<()>,
    {
        let mut workers = self.workers.lock().unwrap();
        
        if let Some(worker) = workers.iter_mut().find(|w| !w.busy) {
            worker.busy = true;
            task(&mut worker.child)?;
            worker.busy = false;
        }
        
        Ok(())
    }
}
```

---

### 7.2 åŠ¨æ€æ‰©ç¼©å®¹

```rust
impl AdvancedProcessPool {
    pub fn scale_up(&mut self, count: usize, program: &str) -> std::io::Result<()> {
        let mut workers = self.workers.lock().unwrap();
        
        for _ in 0..count {
            let child = Command::new(program).spawn()?;
            workers.push_back(Worker {
                child,
                busy: false,
            });
        }
        
        self.size += count;
        Ok(())
    }
    
    pub fn scale_down(&mut self, count: usize) -> std::io::Result<()> {
        let mut workers = self.workers.lock().unwrap();
        
        for _ in 0..count.min(workers.len()) {
            if let Some(mut worker) = workers.pop_front() {
                worker.child.kill()?;
            }
        }
        
        self.size = self.size.saturating_sub(count);
        Ok(())
    }
}
```

---

## 8. åŸºå‡†æµ‹è¯•

### 8.1 CriterionåŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_process_spawn(c: &mut Criterion) {
    c.bench_function("spawn_process", |b| {
        b.iter(|| {
            let child = Command::new("true").spawn().unwrap();
            child.wait_with_output().unwrap();
        });
    });
}

criterion_group!(benches, bench_process_spawn);
criterion_main!(benches);
```

---

### 8.2 å¯¹æ¯”åŸºå‡†

**IPCåŸºå‡†**:

```rust
fn bench_ipc_mechanisms(c: &mut Criterion) {
    let mut group = c.benchmark_group("ipc");
    
    // Unix Socket
    group.bench_function("unix_socket", |b| {
        b.iter(|| unix_socket_transfer(black_box(&data)));
    });
    
    // ç®¡é“
    group.bench_function("pipe", |b| {
        b.iter(|| pipe_transfer(black_box(&data)));
    });
    
    // å…±äº«å†…å­˜
    group.bench_function("shared_memory", |b| {
        b.iter(|| shm_transfer(black_box(&data)));
    });
    
    group.finish();
}
```

---

## 9. æ€§èƒ½ç›‘æ§

### 9.1 è¿è¡Œæ—¶ç›‘æ§

```rust
use sysinfo::{System, ProcessExt};

pub struct ProcessMonitor {
    system: System,
}

impl ProcessMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }
    
    pub fn monitor(&mut self, pid: u32) {
        self.system.refresh_all();
        
        if let Some(process) = self.system.process(sysinfo::Pid::from(pid as usize)) {
            println!("CPU: {:.2}%", process.cpu_usage());
            println!("Memory: {} KB", process.memory());
            println!("Disk read: {} bytes", process.disk_usage().read_bytes);
            println!("Disk write: {} bytes", process.disk_usage().written_bytes);
        }
    }
}
```

---

### 9.2 æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```rust
use std::time::Instant;

pub struct Metrics {
    pub total_processes: usize,
    pub avg_duration: std::time::Duration,
    pub max_memory: usize,
}

pub struct MetricsCollector {
    start: Instant,
    process_count: usize,
    durations: Vec<std::time::Duration>,
}

impl MetricsCollector {
    pub fn new() -> Self {
        Self {
            start: Instant::now(),
            process_count: 0,
            durations: Vec::new(),
        }
    }
    
    pub fn record_process(&mut self, duration: std::time::Duration) {
        self.process_count += 1;
        self.durations.push(duration);
    }
    
    pub fn report(&self) -> Metrics {
        let avg_duration = self.durations.iter().sum::<std::time::Duration>() 
            / self.durations.len() as u32;
        
        Metrics {
            total_processes: self.process_count,
            avg_duration,
            max_memory: 0,  // éœ€è¦ä»ç³»ç»Ÿè·å–
        }
    }
}
```

---

## 10. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹: é«˜æ€§èƒ½æ‰¹å¤„ç†ç³»ç»Ÿ

```rust
use tokio::process::Command;
use tokio::sync::Semaphore;
use std::sync::Arc;

pub struct BatchProcessor {
    concurrency: usize,
    semaphore: Arc<Semaphore>,
}

impl BatchProcessor {
    pub fn new(concurrency: usize) -> Self {
        Self {
            concurrency,
            semaphore: Arc::new(Semaphore::new(concurrency)),
        }
    }
    
    pub async fn process_batch(&self, tasks: Vec<String>) -> Vec<Result<String, std::io::Error>> {
        let mut handles = vec![];
        
        for task in tasks {
            let sem = self.semaphore.clone();
            let handle = tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                
                let output = Command::new("sh")
                    .arg("-c")
                    .arg(&task)
                    .output()
                    .await?;
                
                Ok(String::from_utf8_lossy(&output.stdout).to_string())
            });
            
            handles.push(handle);
        }
        
        let mut results = Vec::with_capacity(handles.len());
        for handle in handles {
            results.push(handle.await.unwrap());
        }
        
        results
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let processor = BatchProcessor::new(10);
    
    let tasks = (0..100).map(|i| format!("echo Task {}", i)).collect();
    
    let start = std::time::Instant::now();
    let results = processor.process_batch(tasks).await;
    let duration = start.elapsed();
    
    println!("å¤„ç† {} ä¸ªä»»åŠ¡", results.len());
    println!("æ€»è€—æ—¶: {:?}", duration);
    println!("å¹³å‡: {:?}/ä»»åŠ¡", duration / results.len() as u32);
}
```

**æ€§èƒ½æŒ‡æ ‡**:

- å¹¶å‘æ•°: 10
- ä»»åŠ¡æ•°: 100
- æ€»è€—æ—¶: ~1s
- ååé‡: 100 tasks/s

---

## æ€»ç»“

**æ€§èƒ½ä¼˜åŒ–æ¸…å•**:

| ä¼˜åŒ–é¡¹ | æ–¹æ³• | æå‡ |
|--------|------|------|
| **è¿›ç¨‹å¯åŠ¨** | è¿›ç¨‹æ±  | 30x |
| **IPC** | Unix Socketä»£æ›¿ç®¡é“ | 10x |
| **I/O** | BufReader/Writer | 10-30x |
| **å¹¶å‘** | å¼‚æ­¥ + ä¿¡å·é‡ | 10-50x |
| **å†…å­˜** | å¯¹è±¡æ±  | å‡å°‘50%åˆ†é… |
| **CPU** | Rayonå¹¶è¡Œ | 3-3.5x |

**å…³é”®åŸåˆ™**:

1. âœ… **æµ‹é‡ä¼˜å…ˆ**: å…ˆæµ‹é‡å†ä¼˜åŒ–
2. âœ… **é€‰æ‹©åˆé€‚çš„IPC**: æ ¹æ®åœºæ™¯é€‰æ‹©
3. âœ… **ä½¿ç”¨ç¼“å†²**: BufReader/BufWriter
4. âœ… **å¼‚æ­¥I/O**: Tokioæå‡å¹¶å‘
5. âœ… **è¿›ç¨‹æ± **: å¤ç”¨è¿›ç¨‹
6. âœ… **ç›‘æ§æŒ‡æ ‡**: æŒç»­ç›‘æ§

**æ¨èé…ç½®**:

```rust
// ç”Ÿäº§çº§é…ç½®
ProcessPool::new(num_cpus::get() * 2, "worker")?
    .with_buffer_size(128 * 1024)
    .with_timeout(Duration::from_secs(30))
    .with_retry(3)
    .build()
```

---

**ä¸‹ä¸€æ­¥**: è¿”å› [ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+
