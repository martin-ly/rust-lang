# Tier 3: æ€§èƒ½ä¼˜åŒ–å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: æŠ€æœ¯å‚è€ƒ
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+
> **å‰ç½®çŸ¥è¯†**: [è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­](../tier_02_guides/05_è¿›ç¨‹ç›‘æ§ä¸è¯Šæ–­.md)

---

## ç›®å½•

- [Tier 3: æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](#tier-3-æ€§èƒ½ä¼˜åŒ–å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ€§èƒ½åˆ†ææ–¹æ³•](#1-æ€§èƒ½åˆ†ææ–¹æ³•)
    - [1.1 æ€§èƒ½åˆ†æå·¥å…·](#11-æ€§èƒ½åˆ†æå·¥å…·)
    - [1.2 æ€§èƒ½æŒ‡æ ‡](#12-æ€§èƒ½æŒ‡æ ‡)
  - [2. è¿›ç¨‹å¯åŠ¨ä¼˜åŒ–](#2-è¿›ç¨‹å¯åŠ¨ä¼˜åŒ–)
    - [2.1 å‡å°‘å¯åŠ¨æ—¶é—´](#21-å‡å°‘å¯åŠ¨æ—¶é—´)
    - [2.2 å‡å°‘èµ„æºå ç”¨](#22-å‡å°‘èµ„æºå ç”¨)
  - [3. IPCæ€§èƒ½ä¼˜åŒ–](#3-ipcæ€§èƒ½ä¼˜åŒ–)
    - [3.1 IPCæœºåˆ¶é€‰æ‹©](#31-ipcæœºåˆ¶é€‰æ‹©)
    - [3.2 ç¼“å†²ä¼˜åŒ–](#32-ç¼“å†²ä¼˜åŒ–)
    - [3.3 é›¶æ‹·è´æŠ€æœ¯](#33-é›¶æ‹·è´æŠ€æœ¯)
  - [4. å†…å­˜ä¼˜åŒ–](#4-å†…å­˜ä¼˜åŒ–)
    - [4.1 å‡å°‘å†…å­˜åˆ†é…](#41-å‡å°‘å†…å­˜åˆ†é…)
    - [4.2 å†…å­˜æ˜ å°„](#42-å†…å­˜æ˜ å°„)
  - [5. CPUä¼˜åŒ–](#5-cpuä¼˜åŒ–)
    - [5.1 å¹¶è¡ŒåŒ–](#51-å¹¶è¡ŒåŒ–)
    - [5.2 å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢](#52-å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢)
  - [6. I/Oä¼˜åŒ–](#6-ioä¼˜åŒ–)
    - [6.1 å¼‚æ­¥I/O](#61-å¼‚æ­¥io)
    - [6.2 æ‰¹é‡I/O](#62-æ‰¹é‡io)
  - [7. å¹¶å‘ä¼˜åŒ–](#7-å¹¶å‘ä¼˜åŒ–)
    - [7.1 è¿›ç¨‹æ± ](#71-è¿›ç¨‹æ± )
    - [7.2 åŠ¨æ€æ‰©ç¼©å®¹](#72-åŠ¨æ€æ‰©ç¼©å®¹)
  - [8. åŸºå‡†æµ‹è¯•](#8-åŸºå‡†æµ‹è¯•)
    - [8.1 CriterionåŸºå‡†æµ‹è¯•](#81-criterionåŸºå‡†æµ‹è¯•)
    - [8.2 å¯¹æ¯”åŸºå‡†](#82-å¯¹æ¯”åŸºå‡†)
  - [9. æ€§èƒ½ç›‘æ§](#9-æ€§èƒ½ç›‘æ§)
    - [9.1 è¿è¡Œæ—¶ç›‘æ§](#91-è¿è¡Œæ—¶ç›‘æ§)
    - [9.2 æ€§èƒ½æŒ‡æ ‡æ”¶é›†](#92-æ€§èƒ½æŒ‡æ ‡æ”¶é›†)
  - [10. å®æˆ˜æ¡ˆä¾‹](#10-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹: é«˜æ€§èƒ½æ‰¹å¤„ç†ç³»ç»Ÿ](#æ¡ˆä¾‹-é«˜æ€§èƒ½æ‰¹å¤„ç†ç³»ç»Ÿ)
  - [æ€»ç»“](#æ€»ç»“)

---

## 1. æ€§èƒ½åˆ†ææ–¹æ³•

### 1.1 æ€§èƒ½åˆ†æå·¥å…·

**Linuxå·¥å…·é“¾**:

```bash
# CPUåˆ†æ
perf record -g ./myapp
perf report

# ç«ç„°å›¾
perf script | flamegraph.pl > flame.svg

# å†…å­˜åˆ†æ
valgrind --tool=massif ./myapp

# ç³»ç»Ÿè°ƒç”¨è¿½è¸ª
strace -c ./myapp

# å®æ—¶ç›‘æ§
top -p $(pidof myapp)
htop -p $(pidof myapp)
```

**Rustä¸“ç”¨å·¥å…·**:

```bash
# CriterionåŸºå‡†æµ‹è¯•
cargo bench

# flamegraph
cargo install flamegraph
cargo flamegraph --bin myapp

# cargo-profdata
cargo install cargo-profdata
cargo profdata -- ./target/release/myapp

# heaptrack (å†…å­˜åˆ†æ)
heaptrack ./target/release/myapp
heaptrack_gui heaptrack.myapp.*.gz
```

**é«˜çº§æ€§èƒ½åˆ†æå·¥å…·é“¾**:

1. **perf + flamegraph (CPUçƒ­ç‚¹åˆ†æ)**:

    ```bash
    # é‡‡é›†æ€§èƒ½æ•°æ® (60ç§’)
    perf record -F 99 -g -p $(pidof myapp) -- sleep 60

    # ç”Ÿæˆç«ç„°å›¾
    perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg

    # åˆ†æç»“æœ
    # - å®½åº¦ï¼šCPUå ç”¨æ—¶é—´
    # - é«˜åº¦ï¼šè°ƒç”¨æ ˆæ·±åº¦
    # - é¢œè‰²ï¼šä¸åŒå‡½æ•°
    ```

2. **valgrind + massif-visualizer (å†…å­˜åˆ†æ)**:

    ```bash
    # è¿è¡Œå†…å­˜åˆ†æ
    valgrind --tool=massif \
            --massif-out-file=massif.out \
            ./target/release/myapp

    # å¯è§†åŒ–
    massif-visualizer massif.out

    # å…³é”®æŒ‡æ ‡:
    # - å †å†…å­˜ä½¿ç”¨å³°å€¼
    # - å†…å­˜åˆ†é…çƒ­ç‚¹
    # - å†…å­˜æ³„æ¼æ£€æµ‹
    ```

3. **strace + ltrace (ç³»ç»Ÿè°ƒç”¨åˆ†æ)**:

    ```bash
    # ç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨
    strace -c -p $(pidof myapp)

    # è¯¦ç»†è·Ÿè¸ª
    strace -T -tt -o strace.log ./myapp

    # åº“å‡½æ•°è°ƒç”¨
    ltrace -c ./myapp

    # å…³æ³¨æŒ‡æ ‡:
    # - ç³»ç»Ÿè°ƒç”¨é¢‘ç‡
    # - I/O æ“ä½œæ¬¡æ•°
    # - é”ç«äº‰æƒ…å†µ
    ```

4. **cargo-flamegraph (Rustä¼˜åŒ–)**:

    ```bash
    # å®‰è£…
    cargo install flamegraph

    # CPU ç«ç„°å›¾
    cargo flamegraph --bin myapp

    # å®šåˆ¶é‡‡æ ·é¢‘ç‡
    cargo flamegraph --bin myapp --freq 997

    # è¿‡æ»¤ç‰¹å®šå‡½æ•°
    cargo flamegraph --bin myapp --filter "process::"
    ```

5. **cargo-bloat (äºŒè¿›åˆ¶å¤§å°åˆ†æ)**:

    ```bash
    # å®‰è£…
    cargo install cargo-bloat

    # åˆ†æäºŒè¿›åˆ¶å¤§å°
    cargo bloat --release

    # ç¤ºä¾‹è¾“å‡º:
    #  File  .text     Size Crate Name
    #  0.9%  31.8%  89.3KiB   std std::sys::unix::process::process_common::Command::spawn
    #  0.5%  17.5%  49.1KiB tokio tokio::process::unix::ChildStdio::try_into_stdio
    ```

**æ€§èƒ½åˆ†ææœ€ä½³å®è·µ**:

```rust
use std::time::Instant;

// 1. å†…ç½®æ€§èƒ½è®¡æ—¶å™¨
#[inline]
pub fn measure_time<F, T>(name: &str, f: F) -> T
where
    F: FnOnce() -> T,
{
    let start = Instant::now();
    let result = f();
    let duration = start.elapsed();
    println!("[{}] è€—æ—¶: {:?}", name, duration);
    result
}

// ä½¿ç”¨ç¤ºä¾‹
let output = measure_time("spawn_process", || {
    Command::new("echo").arg("hello").output().unwrap()
});

// 2. è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨
pub struct PerfMetrics {
    spawn_count: AtomicU64,
    spawn_time_ms: AtomicU64,
    wait_count: AtomicU64,
    wait_time_ms: AtomicU64,
}

impl PerfMetrics {
    pub fn record_spawn(&self, duration: Duration) {
        self.spawn_count.fetch_add(1, Ordering::Relaxed);
        self.spawn_time_ms.fetch_add(
            duration.as_millis() as u64,
            Ordering::Relaxed
        );
    }

    pub fn report(&self) {
        let spawns = self.spawn_count.load(Ordering::Relaxed);
        let spawn_time = self.spawn_time_ms.load(Ordering::Relaxed);

        println!("è¿›ç¨‹spawn: {} æ¬¡", spawns);
        println!("å¹³å‡spawnæ—¶é—´: {} ms", spawn_time / spawns);
    }
}
```

**æ€§èƒ½åˆ†æå†³ç­–æ ‘**:

```text
æ€§èƒ½é—®é¢˜
â”œâ”€ CPUé«˜ï¼Ÿ
â”‚  â”œâ”€ ä½¿ç”¨perf + flamegraph
â”‚  â”œâ”€ æ£€æŸ¥çƒ­ç‚¹å‡½æ•°
â”‚  â””â”€ è€ƒè™‘å¹¶è¡ŒåŒ–/ç®—æ³•ä¼˜åŒ–
â”‚
â”œâ”€ å†…å­˜é«˜ï¼Ÿ
â”‚  â”œâ”€ ä½¿ç”¨valgrind/heaptrack
â”‚  â”œâ”€ æŸ¥æ‰¾æ³„æ¼/è¿‡åº¦åˆ†é…
â”‚  â””â”€ è€ƒè™‘å¯¹è±¡æ± /å†…å­˜æ˜ å°„
â”‚
â”œâ”€ I/Oæ…¢ï¼Ÿ
â”‚  â”œâ”€ ä½¿ç”¨straceåˆ†æç³»ç»Ÿè°ƒç”¨
â”‚  â”œâ”€ æ£€æŸ¥ç¼“å†²åŒºå¤§å°
â”‚  â””â”€ è€ƒè™‘å¼‚æ­¥I/O/æ‰¹é‡æ“ä½œ
â”‚
â””â”€ å¯åŠ¨æ…¢ï¼Ÿ
   â”œâ”€ ä½¿ç”¨è¿›ç¨‹æ± 
   â”œâ”€ é¢„çƒ­ç¼“å­˜
   â””â”€ å‡å°‘ä¾èµ–åŠ è½½
```

---

### 1.2 æ€§èƒ½æŒ‡æ ‡

**æ ¸å¿ƒæŒ‡æ ‡**:

| æŒ‡æ ‡ | è¯´æ˜ | ç›®æ ‡ |
|------|------|------|
| **ååé‡** | å•ä½æ—¶é—´å¤„ç†é‡ | è¶Šé«˜è¶Šå¥½ |
| **å»¶è¿Ÿ** | å“åº”æ—¶é—´ | è¶Šä½è¶Šå¥½ |
| **CPUä½¿ç”¨ç‡** | CPUå ç”¨ç™¾åˆ†æ¯” | é€‚ä¸­ |
| **å†…å­˜å ç”¨** | å¸¸é©»å†…å­˜å¤§å° | è¶Šå°è¶Šå¥½ |
| **è¿›ç¨‹æ•°** | å¹¶å‘è¿›ç¨‹æ•°é‡ | é€‚å½“ |

---

## 2. è¿›ç¨‹å¯åŠ¨ä¼˜åŒ–

### 2.1 å‡å°‘å¯åŠ¨æ—¶é—´

**ç­–ç•¥1: é¢„çƒ­è¿›ç¨‹æ± **:

```rust
use std::process::Command;

pub struct ProcessPool {
    workers: Vec<std::process::Child>,
}

impl ProcessPool {
    pub fn new(size: usize, program: &str) -> std::io::Result<Self> {
        let mut workers = Vec::with_capacity(size);

        for _ in 0..size {
            let child = Command::new(program).spawn()?;
            workers.push(child);
        }

        Ok(Self { workers })
    }
}

// å¯åŠ¨æ—¶é¢„çƒ­10ä¸ªè¿›ç¨‹
let pool = ProcessPool::new(10, "worker")?;
```

**ç­–ç•¥2: å»¶è¿Ÿå¯åŠ¨**:

```rust
use std::sync::LazyLock;

static PROCESS: LazyLock<Child> = LazyLock::new(|| {
    Command::new("worker").spawn().unwrap()
});

// é¦–æ¬¡ä½¿ç”¨æ—¶æ‰å¯åŠ¨
let pid = PROCESS.id();
```

**åŸºå‡†æµ‹è¯•** (å¯åŠ¨100ä¸ªè¿›ç¨‹):

| æ–¹æ³• | è€—æ—¶ |
|------|------|
| é€ä¸ªå¯åŠ¨ | 1,500ms |
| æ‰¹é‡å¯åŠ¨ | 800ms |
| è¿›ç¨‹æ±  (é¢„çƒ­) | 50ms âœ… |

---

### 2.2 å‡å°‘èµ„æºå ç”¨

**æœ€å°åŒ–ç¯å¢ƒå˜é‡**:

```rust
// âŒ ç»§æ‰¿æ‰€æœ‰ç¯å¢ƒå˜é‡
Command::new("app").spawn()?;

// âœ… ä»…ä¼ é€’å¿…è¦çš„
Command::new("app")
    .env_clear()
    .env("PATH", "/usr/bin")
    .spawn()?;
```

**ä¼˜åŒ–å·¥ä½œç›®å½•**:

```rust
// è®¾ç½®åˆé€‚çš„å·¥ä½œç›®å½•
Command::new("app")
    .current_dir("/tmp")  // å¿«é€Ÿçš„tmpfs
    .spawn()?;
```

---

## 3. IPCæ€§èƒ½ä¼˜åŒ–

### 3.1 IPCæœºåˆ¶é€‰æ‹©

**æ€§èƒ½æ’åº** (åŒä¸»æœº):

1. ğŸ¥‡ **å…±äº«å†…å­˜**: ~20 GB/s
2. ğŸ¥ˆ **Unix Socket**: ~10 GB/s
3. ğŸ¥‰ **ç®¡é“**: ~1 GB/s
4. **TCP Socket**: ~1 GB/s

**é€‰æ‹©å†³ç­–**:

```rust
pub fn select_ipc(data_size: usize, local: bool) -> &'static str {
    match (data_size, local) {
        (size, true) if size > 1024 * 1024 => "shared_memory",  // >1MB
        (_, true) => "unix_socket",
        (_, false) => "tcp_socket",
    }
}
```

---

### 3.2 ç¼“å†²ä¼˜åŒ–

**ä½¿ç”¨BufReader/BufWriter**:

```rust
use std::io::{BufReader, BufWriter, Write, Read};

// âŒ ä½æ•ˆï¼šæ— ç¼“å†²
for byte in data {
    stdout.write(&[byte])?;
}

// âœ… é«˜æ•ˆï¼šå¤§ç¼“å†²
let mut writer = BufWriter::with_capacity(64 * 1024, stdout);
writer.write_all(&data)?;
writer.flush()?;
```

**æ€§èƒ½å¯¹æ¯”** (ä¼ è¾“10MB):

| æ–¹æ³• | è€—æ—¶ |
|------|------|
| æ— ç¼“å†² | 2,500ms |
| é»˜è®¤ç¼“å†²(8KB) | 150ms |
| å¤§ç¼“å†²(64KB) | 80ms âœ… |

---

### 3.3 é›¶æ‹·è´æŠ€æœ¯

**sendfile (Linux)**:

```rust
#[cfg(target_os = "linux")]
fn zero_copy_transfer(from: &File, to: &File, len: usize) -> std::io::Result<()> {
    use std::os::unix::io::AsRawFd;

    unsafe {
        libc::sendfile(
            to.as_raw_fd(),
            from.as_raw_fd(),
            std::ptr::null_mut(),
            len,
        );
    }

    Ok(())
}
```

---

## 4. å†…å­˜ä¼˜åŒ–

### 4.1 å‡å°‘å†…å­˜åˆ†é…

**å¯¹è±¡æ± æ¨¡å¼**:

```rust
use std::collections::VecDeque;

pub struct ByteBufferPool {
    buffers: VecDeque<Vec<u8>>,
    capacity: usize,
}

impl ByteBufferPool {
    pub fn new(size: usize, capacity: usize) -> Self {
        let mut buffers = VecDeque::with_capacity(size);
        for _ in 0..size {
            buffers.push_back(Vec::with_capacity(capacity));
        }

        Self { buffers, capacity }
    }

    pub fn acquire(&mut self) -> Vec<u8> {
        self.buffers.pop_front()
            .unwrap_or_else(|| Vec::with_capacity(self.capacity))
    }

    pub fn release(&mut self, mut buf: Vec<u8>) {
        buf.clear();
        self.buffers.push_back(buf);
    }
}
```

**é«˜çº§å¯¹è±¡æ± å®ç°ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰**:

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

pub struct ThreadSafePool<T> {
    pool: Arc<Mutex<VecDeque<T>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
    max_size: usize,
}

impl<T> ThreadSafePool<T>
where
    T: Send + 'static,
{
    pub fn new<F>(max_size: usize, factory: F) -> Self
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        Self {
            pool: Arc::new(Mutex::new(VecDeque::with_capacity(max_size))),
            factory: Arc::new(factory),
            max_size,
        }
    }

    pub fn acquire(&self) -> PoolGuard<T> {
        let mut pool = self.pool.lock().unwrap();
        let item = pool.pop_front().unwrap_or_else(|| (self.factory)());

        PoolGuard {
            item: Some(item),
            pool: Arc::clone(&self.pool),
        }
    }
}

pub struct PoolGuard<T> {
    item: Option<T>,
    pool: Arc<Mutex<VecDeque<T>>>,
}

impl<T> Drop for PoolGuard<T> {
    fn drop(&mut self) {
        if let Some(item) = self.item.take() {
            let mut pool = self.pool.lock().unwrap();
            pool.push_back(item);
        }
    }
}

impl<T> std::ops::Deref for PoolGuard<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.item.as_ref().unwrap()
    }
}

impl<T> std::ops::DerefMut for PoolGuard<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.item.as_mut().unwrap()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
use std::process::Command;

let pool = ThreadSafePool::new(10, || Vec::with_capacity(1024 * 1024));

// è‡ªåŠ¨å½’è¿˜åˆ°æ± ä¸­
{
    let mut buffer = pool.acquire();
    // ä½¿ç”¨ buffer...
} // Dropæ—¶è‡ªåŠ¨å½’è¿˜
```

**SmallVecä¼˜åŒ–ï¼ˆæ ˆä¸Šå°æ•°ç»„ï¼‰**:

```rust
use smallvec::{SmallVec, smallvec};

// å°äº8ä¸ªå…ƒç´ æ—¶ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
type ArgsVec = SmallVec<[String; 8]>;

fn build_args(base_args: &[&str], extra: &[&str]) -> ArgsVec {
    let mut args: ArgsVec = smallvec![];

    for arg in base_args {
        args.push(arg.to_string());
    }

    for arg in extra {
        args.push(arg.to_string());
    }

    args  // å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ— å †åˆ†é…
}

// æ€§èƒ½å¯¹æ¯”
// Vec<String>: æ¯æ¬¡éƒ½å †åˆ†é…
// SmallVec<[String; 8]>: â‰¤8ä¸ªå…ƒç´ æ—¶æ— å †åˆ†é…ï¼ˆå¿«2-3xï¼‰
```

**å†…å­˜é¢„åˆ†é…ç­–ç•¥**:

```rust
// âŒ ä½æ•ˆï¼šå¤šæ¬¡åˆ†é…
let mut vec = Vec::new();
for i in 0..10000 {
    vec.push(i);  // æ¯æ¬¡å¯èƒ½è§¦å‘é‡æ–°åˆ†é…
}

// âœ… é«˜æ•ˆï¼šé¢„åˆ†é…
let mut vec = Vec::with_capacity(10000);
for i in 0..10000 {
    vec.push(i);  // æ— é‡æ–°åˆ†é…
}

// âœ… æ›´é«˜æ•ˆï¼šç›´æ¥collect
let vec: Vec<_> = (0..10000).collect();
```

**å†…å­˜å¤ç”¨æŠ€å·§**:

```rust
use std::process::{Command, Stdio};
use std::io::Read;

pub struct ProcessRunner {
    buffer: Vec<u8>,  // å¤ç”¨ç¼“å†²åŒº
}

impl ProcessRunner {
    pub fn new(buffer_size: usize) -> Self {
        Self {
            buffer: Vec::with_capacity(buffer_size),
        }
    }

    pub fn run_and_capture(&mut self, cmd: &str) -> std::io::Result<String> {
        // å¤ç”¨bufferï¼Œé¿å…é‡å¤åˆ†é…
        self.buffer.clear();

        let mut child = Command::new("sh")
            .arg("-c")
            .arg(cmd)
            .stdout(Stdio::piped())
            .spawn()?;

        if let Some(mut stdout) = child.stdout.take() {
            stdout.read_to_end(&mut self.buffer)?;
        }

        child.wait()?;

        Ok(String::from_utf8_lossy(&self.buffer).to_string())
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šå•ä¸ªbufferè¿è¡Œ100ä¸ªè¿›ç¨‹
let mut runner = ProcessRunner::new(64 * 1024);

for i in 0..100 {
    let output = runner.run_and_capture(&format!("echo {}", i))?;
    println!("{}", output);
}
// ä»…åˆ†é…ä¸€æ¬¡64KBå†…å­˜ï¼Œå¤ç”¨100æ¬¡
```

---

### 4.2 å†…å­˜æ˜ å°„

**mmapä¼˜åŒ–**:

```rust
use memmap2::MmapMut;

fn use_mmap(size: usize) -> std::io::Result<()> {
    let file = std::fs::OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open("/tmp/data")?;

    file.set_len(size as u64)?;

    let mut mmap = unsafe { MmapMut::map_mut(&file)? };

    // ç›´æ¥è®¿é—®å†…å­˜
    mmap[0] = 42;

    mmap.flush()?;
    Ok(())
}
```

**ä¼˜ç‚¹**: å‡å°‘ç³»ç»Ÿè°ƒç”¨ã€æ‡’åŠ è½½ã€‚

---

## 5. CPUä¼˜åŒ–

### 5.1 å¹¶è¡ŒåŒ–

**Rayonå¹¶è¡Œå¤„ç†**:

```rust
use rayon::prelude::*;

// å¹¶è¡Œå¤„ç†è¿›ç¨‹è¾“å‡º
let results: Vec<_> = outputs.par_iter()
    .map(|output| process_output(output))
    .collect();
```

**æ€§èƒ½æå‡**: 4æ ¸CPUå¯æå‡3-3.5xã€‚

**é«˜çº§å¹¶è¡Œæ¨¡å¼**:

1. **Rayonå¹¶è¡Œæ‰¹å¤„ç†**:

    ```rust
    use rayon::prelude::*;
    use std::process::Command;

    pub struct ParallelProcessor {
        num_threads: usize,
    }

    impl ParallelProcessor {
        pub fn new(num_threads: usize) -> Self {
            rayon::ThreadPoolBuilder::new()
                .num_threads(num_threads)
                .build_global()
                .unwrap();

            Self { num_threads }
        }

        pub fn process_batch(&self, commands: Vec<String>) -> Vec<Result<String, std::io::Error>> {
            commands.par_iter()
                .map(|cmd| {
                    let output = Command::new("sh")
                        .arg("-c")
                        .arg(cmd)
                        .output()?;

                    Ok(String::from_utf8_lossy(&output.stdout).to_string())
                })
                .collect()
        }

        // å¹¶è¡ŒMap-Reduce
        pub fn parallel_map_reduce<T, R>(
            &self,
            data: Vec<T>,
            map_fn: impl Fn(T) -> R + Sync + Send,
            reduce_fn: impl Fn(R, R) -> R + Sync + Send,
        ) -> Option<R>
        where
            T: Send,
            R: Send,
        {
            data.into_par_iter()
                .map(map_fn)
                .reduce_with(reduce_fn)
        }
    }

    // ä½¿ç”¨ç¤ºä¾‹
    let processor = ParallelProcessor::new(8);

    // å¹¶è¡Œæ‰§è¡Œ100ä¸ªå‘½ä»¤
    let commands: Vec<_> = (0..100)
        .map(|i| format!("echo Processing {}", i))
        .collect();

    let results = processor.process_batch(commands);

    println!("æˆåŠŸ: {} / {}",
        results.iter().filter(|r| r.is_ok()).count(),
        results.len()
    );
    ```

2. **Work Stealingå¹¶è¡Œ**:

    ```rust
    use crossbeam::channel::{unbounded, Sender, Receiver};
    use std::thread;
    use std::process::Command;

    pub struct WorkStealingPool {
        workers: Vec<thread::JoinHandle<()>>,
        sender: Sender<WorkItem>,
    }

    type WorkItem = Box<dyn FnOnce() + Send + 'static>;

    impl WorkStealingPool {
        pub fn new(size: usize) -> Self {
            let (sender, receiver) = unbounded::<WorkItem>();

            let mut workers = Vec::with_capacity(size);

            for id in 0..size {
                let rx = receiver.clone();

                let handle = thread::spawn(move || {
                    while let Ok(work) = rx.recv() {
                        work();
                    }
                });

                workers.push(handle);
            }

            Self { workers, sender }
        }

        pub fn execute<F>(&self, f: F)
        where
            F: FnOnce() + Send + 'static,
        {
            self.sender.send(Box::new(f)).unwrap();
        }

        pub fn shutdown(self) {
            drop(self.sender);
            for worker in self.workers {
                worker.join().unwrap();
            }
        }
    }

    // ä½¿ç”¨ç¤ºä¾‹
    let pool = WorkStealingPool::new(4);

    for i in 0..100 {
        pool.execute(move || {
            let output = Command::new("echo")
                .arg(format!("Task {}", i))
                .output()
                .unwrap();

            println!("{}", String::from_utf8_lossy(&output.stdout));
        });
    }

    pool.shutdown();
    ```

3. **å¹¶è¡Œæµæ°´çº¿å¤„ç†**:

    ```rust
    use std::sync::mpsc::{channel, Sender, Receiver};
    use std::thread;

    pub struct Pipeline<I, O> {
        stages: Vec<Box<dyn FnMut(I) -> O + Send>>,
    }

    impl<I: Send + 'static, O: Send + 'static> Pipeline<I, O> {
        pub fn new() -> Self {
            Self { stages: Vec::new() }
        }

        pub fn add_stage<F>(mut self, f: F) -> Self
        where
            F: FnMut(I) -> O + Send + 'static,
        {
            self.stages.push(Box::new(f));
            self
        }

        pub fn run(&mut self, inputs: Vec<I>) -> Vec<O> {
            // ç®€åŒ–ç¤ºä¾‹ï¼šå®é™…åº”è¯¥ä½¿ç”¨å¤šçº¿ç¨‹æµæ°´çº¿
            inputs.into_iter()
                .map(|input| {
                    let mut result = input;
                    for stage in &mut self.stages {
                        // è¿™é‡Œéœ€è¦ç±»å‹è½¬æ¢é€»è¾‘
                        // å®é™…å®ç°æ›´å¤æ‚
                    }
                    // result
                    unimplemented!("éœ€è¦æ›´å¤æ‚çš„ç±»å‹ç³»ç»Ÿ")
                })
                .collect()
        }
    }
    ```

4. **CPUäº²å’Œæ€§ä¼˜åŒ–** (Linux):

    ```rust
    #[cfg(target_os = "linux")]
    pub fn set_cpu_affinity(cpu_id: usize) -> std::io::Result<()> {
        use libc::{cpu_set_t, CPU_SET, CPU_ZERO, sched_setaffinity};
        use std::mem;

        unsafe {
            let mut cpuset: cpu_set_t = mem::zeroed();
            CPU_ZERO(&mut cpuset);
            CPU_SET(cpu_id, &mut cpuset);

            let result = sched_setaffinity(
                0,  // å½“å‰çº¿ç¨‹
                mem::size_of::<cpu_set_t>(),
                &cpuset,
            );

            if result == 0 {
                Ok(())
            } else {
                Err(std::io::Error::last_os_error())
            }
        }
    }

    // ä½¿ç”¨ç¤ºä¾‹ï¼šå°†workerçº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šCPU
    thread::spawn(move || {
        set_cpu_affinity(core_id).unwrap();

        // æ‰§è¡Œè¿›ç¨‹ç®¡ç†ä»»åŠ¡
        loop {
            // ...
        }
    });
    ```

**å¹¶è¡ŒåŒ–æœ€ä½³å®è·µ**:

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | æ€§èƒ½æå‡ |
|------|---------|---------|
| CPUå¯†é›†å‹ | Rayon | 3-3.5x (4æ ¸) |
| I/Oå¯†é›†å‹ | Tokioå¼‚æ­¥ | 10-100x |
| æ··åˆä»»åŠ¡ | Work Stealing Pool | 2-5x |
| æµæ°´çº¿ | å¤šstage pipeline | 2-4x |

---

### 5.2 å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢

**æ§åˆ¶å¹¶å‘æ•°**:

```rust
use tokio::sync::Semaphore;

let sem = Arc::new(Semaphore::new(num_cpus::get()));

for task in tasks {
    let permit = sem.clone().acquire_owned().await.unwrap();
    tokio::spawn(async move {
        do_work(task).await;
        drop(permit);
    });
}
```

---

## 6. I/Oä¼˜åŒ–

### 6.1 å¼‚æ­¥I/O

**Tokioå¼‚æ­¥è¿›ç¨‹**:

```rust
use tokio::process::Command;

async fn async_execute(cmd: &str) -> std::io::Result<Vec<u8>> {
    let output = Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .output()
        .await?;

    Ok(output.stdout)
}

// å¹¶å‘æ‰§è¡Œ
let results = futures::future::join_all(
    commands.iter().map(|cmd| async_execute(cmd))
).await;
```

**ååé‡æå‡**: ç›¸æ¯”åŒæ­¥ç‰ˆæœ¬æå‡10-50xã€‚

**å¼‚æ­¥æµå¼I/O**:

```rust
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::process::Command;

pub async fn stream_output(cmd: &str) -> std::io::Result<Vec<String>> {
    let mut child = Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .stdout(std::process::Stdio::piped())
        .spawn()?;

    let stdout = child.stdout.take().unwrap();
    let reader = BufReader::new(stdout);
    let mut lines = reader.lines();

    let mut output = Vec::new();

    while let Some(line) = lines.next_line().await? {
        output.push(line);
    }

    child.wait().await?;
    Ok(output)
}
```

**å¼‚æ­¥å¹¶å‘I/Oæ§åˆ¶**:

```rust
use tokio::sync::Semaphore;
use tokio::process::Command;
use std::sync::Arc;

pub async fn concurrent_with_limit(
    commands: Vec<String>,
    limit: usize
) -> Vec<Result<String, std::io::Error>> {
    let sem = Arc::new(Semaphore::new(limit));
    let mut tasks = Vec::new();

    for cmd in commands {
        let sem_clone = Arc::clone(&sem);

        let task = tokio::spawn(async move {
            let _permit = sem_clone.acquire().await.unwrap();

            let output = Command::new("sh")
                .arg("-c")
                .arg(&cmd)
                .output()
                .await?;

            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        });

        tasks.push(task);
    }

    let mut results = Vec::new();
    for task in tasks {
        results.push(task.await.unwrap());
    }

    results
}

// é™åˆ¶å¹¶å‘ï¼šé˜²æ­¢èµ„æºè€—å°½
// limit = 10: åŒæ—¶æœ€å¤š10ä¸ªè¿›ç¨‹
```

---

### 6.2 æ‰¹é‡I/O

```rust
// âŒ é€ä¸ªè¯»å†™
for _ in 0..1000 {
    let byte = reader.read_u8()?;
    writer.write_u8(byte)?;
}

// âœ… æ‰¹é‡è¯»å†™
let mut buffer = vec![0; 1024];
while let Ok(n) = reader.read(&mut buffer) {
    if n == 0 { break; }
    writer.write_all(&buffer[..n])?;
}
```

**é«˜çº§æ‰¹é‡I/Oæ¨¡å¼**:

```rust
use std::io::{BufWriter, Write};
use std::fs::File;

// 1. æ‰¹é‡å†™å…¥å¸¦ç¼“å†²
pub fn batch_write(file_path: &str, data: &[Vec<u8>]) -> std::io::Result<()> {
    let file = File::create(file_path)?;
    let mut writer = BufWriter::with_capacity(256 * 1024, file);

    for chunk in data {
        writer.write_all(chunk)?;
    }

    writer.flush()?;
    Ok(())
}

// 2. æ‰¹é‡è¯»å–
pub fn batch_read(file_path: &str, chunk_size: usize) -> std::io::Result<Vec<Vec<u8>>> {
    use std::io::Read;

    let mut file = File::open(file_path)?;
    let mut chunks = Vec::new();
    let mut buffer = vec![0; chunk_size];

    loop {
        match file.read(&mut buffer) {
            Ok(0) => break,
            Ok(n) => {
                chunks.push(buffer[..n].to_vec());
            }
            Err(e) => return Err(e),
        }
    }

    Ok(chunks)
}

// æ€§èƒ½å¯¹æ¯” (10MBæ–‡ä»¶):
// é€å­—èŠ‚è¯»å†™: 8,000ms
// 4KBç¼“å†²:    120ms
// 256KBç¼“å†²:  15ms (533x æå‡)
```

---

## 7. å¹¶å‘ä¼˜åŒ–

### 7.1 è¿›ç¨‹æ± 

**é«˜çº§è¿›ç¨‹æ± **:

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

pub struct AdvancedProcessPool {
    workers: Arc<Mutex<VecDeque<Worker>>>,
    size: usize,
}

struct Worker {
    child: Child,
    busy: bool,
}

impl AdvancedProcessPool {
    pub fn new(size: usize, program: &str) -> std::io::Result<Self> {
        let mut workers = VecDeque::with_capacity(size);

        for _ in 0..size {
            let child = Command::new(program).spawn()?;
            workers.push_back(Worker {
                child,
                busy: false,
            });
        }

        Ok(Self {
            workers: Arc::new(Mutex::new(workers)),
            size,
        })
    }

    pub fn execute<F>(&self, task: F) -> std::io::Result<()>
    where
        F: FnOnce(&mut Child) -> std::io::Result<()>,
    {
        let mut workers = self.workers.lock().unwrap();

        if let Some(worker) = workers.iter_mut().find(|w| !w.busy) {
            worker.busy = true;
            task(&mut worker.child)?;
            worker.busy = false;
        }

        Ok(())
    }
}
```

---

### 7.2 åŠ¨æ€æ‰©ç¼©å®¹

```rust
impl AdvancedProcessPool {
    pub fn scale_up(&mut self, count: usize, program: &str) -> std::io::Result<()> {
        let mut workers = self.workers.lock().unwrap();

        for _ in 0..count {
            let child = Command::new(program).spawn()?;
            workers.push_back(Worker {
                child,
                busy: false,
            });
        }

        self.size += count;
        Ok(())
    }

    pub fn scale_down(&mut self, count: usize) -> std::io::Result<()> {
        let mut workers = self.workers.lock().unwrap();

        for _ in 0..count.min(workers.len()) {
            if let Some(mut worker) = workers.pop_front() {
                worker.child.kill()?;
            }
        }

        self.size = self.size.saturating_sub(count);
        Ok(())
    }
}
```

---

## 8. åŸºå‡†æµ‹è¯•

### 8.1 CriterionåŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_process_spawn(c: &mut Criterion) {
    c.bench_function("spawn_process", |b| {
        b.iter(|| {
            let child = Command::new("true").spawn().unwrap();
            child.wait_with_output().unwrap();
        });
    });
}

criterion_group!(benches, bench_process_spawn);
criterion_main!(benches);
```

---

### 8.2 å¯¹æ¯”åŸºå‡†

**IPCåŸºå‡†**:

```rust
fn bench_ipc_mechanisms(c: &mut Criterion) {
    let mut group = c.benchmark_group("ipc");

    // Unix Socket
    group.bench_function("unix_socket", |b| {
        b.iter(|| unix_socket_transfer(black_box(&data)));
    });

    // ç®¡é“
    group.bench_function("pipe", |b| {
        b.iter(|| pipe_transfer(black_box(&data)));
    });

    // å…±äº«å†…å­˜
    group.bench_function("shared_memory", |b| {
        b.iter(|| shm_transfer(black_box(&data)));
    });

    group.finish();
}
```

---

## 9. æ€§èƒ½ç›‘æ§

### 9.1 è¿è¡Œæ—¶ç›‘æ§

```rust
use sysinfo::{System, ProcessExt};

pub struct ProcessMonitor {
    system: System,
}

impl ProcessMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }

    pub fn monitor(&mut self, pid: u32) {
        self.system.refresh_all();

        if let Some(process) = self.system.process(sysinfo::Pid::from(pid as usize)) {
            println!("CPU: {:.2}%", process.cpu_usage());
            println!("Memory: {} KB", process.memory());
            println!("Disk read: {} bytes", process.disk_usage().read_bytes);
            println!("Disk write: {} bytes", process.disk_usage().written_bytes);
        }
    }
}
```

---

### 9.2 æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```rust
use std::time::Instant;

pub struct Metrics {
    pub total_processes: usize,
    pub avg_duration: std::time::Duration,
    pub max_memory: usize,
}

pub struct MetricsCollector {
    start: Instant,
    process_count: usize,
    durations: Vec<std::time::Duration>,
}

impl MetricsCollector {
    pub fn new() -> Self {
        Self {
            start: Instant::now(),
            process_count: 0,
            durations: Vec::new(),
        }
    }

    pub fn record_process(&mut self, duration: std::time::Duration) {
        self.process_count += 1;
        self.durations.push(duration);
    }

    pub fn report(&self) -> Metrics {
        let avg_duration = self.durations.iter().sum::<std::time::Duration>()
            / self.durations.len() as u32;

        Metrics {
            total_processes: self.process_count,
            avg_duration,
            max_memory: 0,  // éœ€è¦ä»ç³»ç»Ÿè·å–
        }
    }
}
```

---

## 10. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹: é«˜æ€§èƒ½æ‰¹å¤„ç†ç³»ç»Ÿ

```rust
use tokio::process::Command;
use tokio::sync::Semaphore;
use std::sync::Arc;

pub struct BatchProcessor {
    concurrency: usize,
    semaphore: Arc<Semaphore>,
}

impl BatchProcessor {
    pub fn new(concurrency: usize) -> Self {
        Self {
            concurrency,
            semaphore: Arc::new(Semaphore::new(concurrency)),
        }
    }

    pub async fn process_batch(&self, tasks: Vec<String>) -> Vec<Result<String, std::io::Error>> {
        let mut handles = vec![];

        for task in tasks {
            let sem = self.semaphore.clone();
            let handle = tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();

                let output = Command::new("sh")
                    .arg("-c")
                    .arg(&task)
                    .output()
                    .await?;

                Ok(String::from_utf8_lossy(&output.stdout).to_string())
            });

            handles.push(handle);
        }

        let mut results = Vec::with_capacity(handles.len());
        for handle in handles {
            results.push(handle.await.unwrap());
        }

        results
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let processor = BatchProcessor::new(10);

    let tasks = (0..100).map(|i| format!("echo Task {}", i)).collect();

    let start = std::time::Instant::now();
    let results = processor.process_batch(tasks).await;
    let duration = start.elapsed();

    println!("å¤„ç† {} ä¸ªä»»åŠ¡", results.len());
    println!("æ€»è€—æ—¶: {:?}", duration);
    println!("å¹³å‡: {:?}/ä»»åŠ¡", duration / results.len() as u32);
}
```

**æ€§èƒ½æŒ‡æ ‡**:

- å¹¶å‘æ•°: 10
- ä»»åŠ¡æ•°: 100
- æ€»è€—æ—¶: ~1s
- ååé‡: 100 tasks/s

---

## æ€»ç»“

**æ€§èƒ½ä¼˜åŒ–æ¸…å•**:

| ä¼˜åŒ–é¡¹ | æ–¹æ³• | æå‡ |
|--------|------|------|
| **è¿›ç¨‹å¯åŠ¨** | è¿›ç¨‹æ±  | 30x |
| **IPC** | Unix Socketä»£æ›¿ç®¡é“ | 10x |
| **I/O** | BufReader/Writer | 10-30x |
| **å¹¶å‘** | å¼‚æ­¥ + ä¿¡å·é‡ | 10-50x |
| **å†…å­˜** | å¯¹è±¡æ±  | å‡å°‘50%åˆ†é… |
| **CPU** | Rayonå¹¶è¡Œ | 3-3.5x |

**å…³é”®åŸåˆ™**:

1. âœ… **æµ‹é‡ä¼˜å…ˆ**: å…ˆæµ‹é‡å†ä¼˜åŒ–
2. âœ… **é€‰æ‹©åˆé€‚çš„IPC**: æ ¹æ®åœºæ™¯é€‰æ‹©
3. âœ… **ä½¿ç”¨ç¼“å†²**: BufReader/BufWriter
4. âœ… **å¼‚æ­¥I/O**: Tokioæå‡å¹¶å‘
5. âœ… **è¿›ç¨‹æ± **: å¤ç”¨è¿›ç¨‹
6. âœ… **ç›‘æ§æŒ‡æ ‡**: æŒç»­ç›‘æ§

**æ¨èé…ç½®**:

```rust
// ç”Ÿäº§çº§é…ç½®
ProcessPool::new(num_cpus::get() * 2, "worker")?
    .with_buffer_size(128 * 1024)
    .with_timeout(Duration::from_secs(30))
    .with_retry(3)
    .build()
```

---

**ä¸‹ä¸€æ­¥**: è¿”å› [ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-10-23
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+
