# Tier 3: è¿›ç¨‹æ¨¡å‹å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: æŠ€æœ¯å‚è€ƒ
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **å‰ç½®çŸ¥è¯†**: [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](../tier_02_guides/01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)

---

## ç›®å½•

- [Tier 3: è¿›ç¨‹æ¨¡å‹å‚è€ƒ](#tier-3-è¿›ç¨‹æ¨¡å‹å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. è¿›ç¨‹æ¨¡å‹ç†è®º](#1-è¿›ç¨‹æ¨¡å‹ç†è®º)
    - [1.1 è¿›ç¨‹çš„å®šä¹‰ä¸æœ¬è´¨](#11-è¿›ç¨‹çš„å®šä¹‰ä¸æœ¬è´¨)
    - [1.2 è¿›ç¨‹ä¸çº¿ç¨‹çš„å¯¹æ¯”](#12-è¿›ç¨‹ä¸çº¿ç¨‹çš„å¯¹æ¯”)
    - [1.3 è¿›ç¨‹çš„èµ„æºéš”ç¦»](#13-è¿›ç¨‹çš„èµ„æºéš”ç¦»)
    - [1.4 è¿›ç¨‹çš„ä¼˜ç¼ºç‚¹åˆ†æ](#14-è¿›ç¨‹çš„ä¼˜ç¼ºç‚¹åˆ†æ)
  - [2. è¿›ç¨‹çŠ¶æ€æœºæ¨¡å‹](#2-è¿›ç¨‹çŠ¶æ€æœºæ¨¡å‹)
    - [2.1 ç»å…¸äº”çŠ¶æ€æ¨¡å‹](#21-ç»å…¸äº”çŠ¶æ€æ¨¡å‹)
    - [2.2 ä¸ƒçŠ¶æ€æ¨¡å‹ï¼ˆåŒ…å«æŒ‚èµ·ï¼‰](#22-ä¸ƒçŠ¶æ€æ¨¡å‹åŒ…å«æŒ‚èµ·)
    - [2.3 Rustä¸­çš„è¿›ç¨‹çŠ¶æ€æ˜ å°„](#23-rustä¸­çš„è¿›ç¨‹çŠ¶æ€æ˜ å°„)
    - [2.4 çŠ¶æ€è½¬æ¢è§¦å‘æ¡ä»¶](#24-çŠ¶æ€è½¬æ¢è§¦å‘æ¡ä»¶)
    - [2.5 åƒµå°¸è¿›ç¨‹ä¸å­¤å„¿è¿›ç¨‹](#25-åƒµå°¸è¿›ç¨‹ä¸å­¤å„¿è¿›ç¨‹)
  - [3. è¿›ç¨‹å±æ€§ä¸èµ„æº](#3-è¿›ç¨‹å±æ€§ä¸èµ„æº)
    - [3.1 è¿›ç¨‹æ ‡è¯†ç¬¦](#31-è¿›ç¨‹æ ‡è¯†ç¬¦)
    - [3.2 è¿›ç¨‹èµ„æº](#32-è¿›ç¨‹èµ„æº)
  - [4. è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†](#4-è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†)
    - [4.1 åˆ›å»ºé˜¶æ®µ](#41-åˆ›å»ºé˜¶æ®µ)
    - [4.2 è¿è¡Œé˜¶æ®µ](#42-è¿è¡Œé˜¶æ®µ)
    - [4.3 ç»ˆæ­¢é˜¶æ®µ](#43-ç»ˆæ­¢é˜¶æ®µ)
    - [4.4 å›æ”¶é˜¶æ®µ](#44-å›æ”¶é˜¶æ®µ)
  - [5. è¿›ç¨‹æ§åˆ¶å—ï¼ˆPCBï¼‰](#5-è¿›ç¨‹æ§åˆ¶å—pcb)
  - [6. è¿›ç¨‹è°ƒåº¦æ¨¡å‹](#6-è¿›ç¨‹è°ƒåº¦æ¨¡å‹)
    - [6.1 è°ƒåº¦ç®—æ³•](#61-è°ƒåº¦ç®—æ³•)
  - [7. è¿›ç¨‹é—´å…³ç³»](#7-è¿›ç¨‹é—´å…³ç³»)
    - [7.1 çˆ¶å­å…³ç³»](#71-çˆ¶å­å…³ç³»)
    - [7.2 è¿›ç¨‹ç»„](#72-è¿›ç¨‹ç»„)
    - [7.3 ä¼šè¯ï¼ˆSessionï¼‰](#73-ä¼šè¯session)
  - [8. Unix vs Windows è¿›ç¨‹æ¨¡å‹å·®å¼‚](#8-unix-vs-windows-è¿›ç¨‹æ¨¡å‹å·®å¼‚)
  - [9. Rustè¿›ç¨‹æ¨¡å‹å®ç°](#9-rustè¿›ç¨‹æ¨¡å‹å®ç°)
    - [9.1 Command Builder](#91-command-builder)
    - [9.2 è¿›ç¨‹å¥æŸ„ (Child)](#92-è¿›ç¨‹å¥æŸ„-child)
  - [10. å®æˆ˜æ¡ˆä¾‹](#10-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹: è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨](#æ¡ˆä¾‹-è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨)
  - [11. æ€»ç»“ä¸æœ€ä½³å®è·µ](#11-æ€»ç»“ä¸æœ€ä½³å®è·µ)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**è¿›ç¨‹æ¨¡å‹ (Process Model)**:

- **å®šä¹‰**: æ“ä½œç³»ç»Ÿä¸­è¿›ç¨‹çš„å®šä¹‰ã€çŠ¶æ€ã€ç”Ÿå‘½å‘¨æœŸå’Œèµ„æºç®¡ç†çš„ç†è®ºæ¨¡å‹
- **ç±»å‹**: ç³»ç»Ÿç†è®ºæ¨¡å‹
- **èŒƒç•´**: æ“ä½œç³»ç»Ÿã€ç³»ç»Ÿç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: è¿›ç¨‹ã€çº¿ç¨‹ã€è¿›ç¨‹çŠ¶æ€ã€è¿›ç¨‹æ§åˆ¶å—ã€è¿›ç¨‹è°ƒåº¦

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **ç‹¬ç«‹æ€§**: æ¯ä¸ªè¿›ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„åœ°å€ç©ºé—´
- **åŠ¨æ€æ€§**: è¿›ç¨‹æ˜¯åŠ¨æ€åˆ›å»ºã€æ‰§è¡Œå’Œæ¶ˆäº¡çš„
- **å¹¶å‘æ€§**: å¤šä¸ªè¿›ç¨‹å¯ä»¥å¹¶å‘æ‰§è¡Œ
- **å¼‚æ­¥æ€§**: è¿›ç¨‹ä»¥ä¸å¯é¢„çŸ¥çš„é€Ÿåº¦æ¨è¿›

**æ€§èƒ½ç‰¹å¾**:

- **èµ„æºéš”ç¦»**: è¿›ç¨‹é—´èµ„æºéš”ç¦»
- **å¼€é”€**: è¿›ç¨‹åˆ›å»ºå’Œåˆ‡æ¢å¼€é”€è¾ƒå¤§
- **é€‚ç”¨åœºæ™¯**: ç³»ç»ŸæœåŠ¡ã€ç‹¬ç«‹åº”ç”¨ã€èµ„æºéš”ç¦»

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- è¿›ç¨‹ --[is-a]--> æ‰§è¡Œå®ä½“
- è¿›ç¨‹çŠ¶æ€ --[is-a]--> çŠ¶æ€æ¨¡å‹

**ç»„åˆå…³ç³»**:

- è¿›ç¨‹æ¨¡å‹ --[uses]--> è¿›ç¨‹æ§åˆ¶å—
- æ“ä½œç³»ç»Ÿ --[uses]--> è¿›ç¨‹æ¨¡å‹

**ä¾èµ–å…³ç³»**:

- è¿›ç¨‹æ¨¡å‹ --[depends-on]--> æ“ä½œç³»ç»Ÿæ”¯æŒ
- è¿›ç¨‹ç®¡ç† --[depends-on]--> è¿›ç¨‹æ¨¡å‹

### æ€ç»´å¯¼å›¾

```text
è¿›ç¨‹æ¨¡å‹å‚è€ƒ
â”‚
â”œâ”€â”€ è¿›ç¨‹æ¨¡å‹ç†è®º
â”‚   â”œâ”€â”€ è¿›ç¨‹å®šä¹‰
â”‚   â””â”€â”€ è¿›ç¨‹ä¸çº¿ç¨‹å¯¹æ¯”
â”œâ”€â”€ è¿›ç¨‹çŠ¶æ€æœºæ¨¡å‹
â”‚   â”œâ”€â”€ äº”çŠ¶æ€æ¨¡å‹
â”‚   â””â”€â”€ ä¸ƒçŠ¶æ€æ¨¡å‹
â”œâ”€â”€ è¿›ç¨‹å±æ€§ä¸èµ„æº
â”‚   â”œâ”€â”€ è¿›ç¨‹æ ‡è¯†ç¬¦
â”‚   â””â”€â”€ è¿›ç¨‹èµ„æº
â”œâ”€â”€ è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†
â”‚   â”œâ”€â”€ åˆ›å»ºé˜¶æ®µ
â”‚   â”œâ”€â”€ è¿è¡Œé˜¶æ®µ
â”‚   â””â”€â”€ ç»ˆæ­¢é˜¶æ®µ
â””â”€â”€ è¿›ç¨‹è°ƒåº¦æ¨¡å‹
    â””â”€â”€ è°ƒåº¦ç®—æ³•
```

---

## 1. è¿›ç¨‹æ¨¡å‹ç†è®º

### 1.1 è¿›ç¨‹çš„å®šä¹‰ä¸æœ¬è´¨

**å®šä¹‰**: è¿›ç¨‹ï¼ˆProcessï¼‰æ˜¯æ“ä½œç³»ç»Ÿä¸­èµ„æºåˆ†é…å’Œè°ƒåº¦çš„åŸºæœ¬å•ä½ï¼Œæ˜¯ç¨‹åºçš„ä¸€æ¬¡æ‰§è¡Œå®ä¾‹ã€‚

**æ ¸å¿ƒç‰¹å¾**:

1. **ç‹¬ç«‹æ€§**: æ¯ä¸ªè¿›ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„åœ°å€ç©ºé—´
2. **åŠ¨æ€æ€§**: è¿›ç¨‹æ˜¯åŠ¨æ€åˆ›å»ºã€æ‰§è¡Œå’Œæ¶ˆäº¡çš„
3. **å¹¶å‘æ€§**: å¤šä¸ªè¿›ç¨‹å¯ä»¥å¹¶å‘æ‰§è¡Œ
4. **å¼‚æ­¥æ€§**: è¿›ç¨‹ä»¥ä¸å¯é¢„çŸ¥çš„é€Ÿåº¦æ¨è¿›

**è¿›ç¨‹ vs ç¨‹åº**:

| å¯¹æ¯”ç»´åº¦ | ç¨‹åº           | è¿›ç¨‹                     |
| :--- | :--- | :--- || æœ¬è´¨     | é™æ€çš„æŒ‡ä»¤é›†åˆ | åŠ¨æ€çš„æ‰§è¡Œå®ä½“           |
| ç”Ÿå‘½å‘¨æœŸ | æ°¸ä¹…å­˜å‚¨       | ä¸´æ—¶å­˜åœ¨                 |
| èµ„æº     | ä¸å ç”¨ç³»ç»Ÿèµ„æº | å ç”¨CPUã€å†…å­˜ç­‰èµ„æº      |
| å…³ç³»     | ä¸€å¯¹å¤š         | ä¸€ä¸ªç¨‹åºå¯ä»¥å¯¹åº”å¤šä¸ªè¿›ç¨‹ |

**Rustä¸­çš„è¿›ç¨‹**:

```rust
use std::process::Command;

// ç¨‹åºï¼šç£ç›˜ä¸Šçš„å¯æ‰§è¡Œæ–‡ä»¶
let program = "/usr/bin/ls";

// è¿›ç¨‹ï¼šç¨‹åºçš„æ‰§è¡Œå®ä¾‹
let process1 = Command::new(program).spawn()?;  // ç¬¬1ä¸ªå®ä¾‹
let process2 = Command::new(program).spawn()?;  // ç¬¬2ä¸ªå®ä¾‹

// ä¸¤ä¸ªè¿›ç¨‹ç‹¬ç«‹è¿è¡Œï¼Œæ‹¥æœ‰ä¸åŒçš„PID
println!("Process 1 PID: {}", process1.id());
println!("Process 2 PID: {}", process2.id());
```

---

### 1.2 è¿›ç¨‹ä¸çº¿ç¨‹çš„å¯¹æ¯”

**æ ¹æœ¬åŒºåˆ«**: è¿›ç¨‹æ˜¯èµ„æºåˆ†é…å•ä½ï¼Œçº¿ç¨‹æ˜¯è°ƒåº¦å•ä½ã€‚

| å¯¹æ¯”ç»´åº¦     | è¿›ç¨‹                       | çº¿ç¨‹                             |
| :--- | :--- | :--- || **åœ°å€ç©ºé—´** | ç‹¬ç«‹                       | å…±äº«                             |
| **èµ„æºå¼€é”€** | å¤§ï¼ˆéœ€è¦ç‹¬ç«‹çš„å†…å­˜ç©ºé—´ï¼‰   | å°ï¼ˆå…±äº«è¿›ç¨‹èµ„æºï¼‰               |
| **åˆ›å»ºå¼€é”€** | å¤§ï¼ˆéœ€è¦fork+execï¼‰        | å°ï¼ˆåªéœ€åˆ†é…æ ˆï¼‰                 |
| **é€šä¿¡æ–¹å¼** | IPCï¼ˆç®¡é“ã€å…±äº«å†…å­˜ç­‰ï¼‰    | ç›´æ¥è®¿é—®å…±äº«å˜é‡                 |
| **å®‰å…¨æ€§**   | é«˜ï¼ˆéš”ç¦»æ€§å¥½ï¼‰             | ä½ï¼ˆéœ€è¦åŒæ­¥æœºåˆ¶ï¼‰               |
| **ç¨³å®šæ€§**   | ä¸€ä¸ªè¿›ç¨‹å´©æºƒä¸å½±å“å…¶ä»–è¿›ç¨‹ | ä¸€ä¸ªçº¿ç¨‹å´©æºƒå¯èƒ½å¯¼è‡´æ•´ä¸ªè¿›ç¨‹å´©æºƒ |
| **å¹¶å‘æ€§**   | å¤šè¿›ç¨‹å¹¶å‘                 | å¤šçº¿ç¨‹å¹¶å‘                       |

**ä½¿ç”¨åœºæ™¯**:

**é€‰æ‹©è¿›ç¨‹**:

- âœ… éœ€è¦å¼ºéš”ç¦»å’Œå®‰å…¨æ€§
- âœ… ä¸åŒæ¨¡å—ä¹‹é—´è€¦åˆåº¦ä½
- âœ… åˆ©ç”¨å¤šæ ¸CPUï¼ˆåˆ†å¸ƒå¼è®¡ç®—ï¼‰
- âœ… ä¸åŒç¼–ç¨‹è¯­è¨€æ··åˆä½¿ç”¨

**é€‰æ‹©çº¿ç¨‹**:

- âœ… éœ€è¦é¢‘ç¹é€šä¿¡å’Œæ•°æ®å…±äº«
- âœ… å¯¹æ€§èƒ½è¦æ±‚é«˜ï¼ˆåˆ›å»º/åˆ‡æ¢å¼€é”€å°ï¼‰
- âœ… åŒä¸€ç¨‹åºå†…çš„å¹¶å‘ä»»åŠ¡
- âœ… å†…å­˜èµ„æºå—é™

**Rustç¤ºä¾‹å¯¹æ¯”**:

```rust
use std::process::Command;
use std::thread;

// 1. å¤šè¿›ç¨‹æ–¹å¼
fn multi_process() {
    let mut handles = vec![];

    for i in 0..4 {
        let child = Command::new("worker")
            .arg(i.to_string())
            .spawn()
            .expect("Failed to spawn");
        handles.push(child);
    }

    for mut child in handles {
        child.wait().expect("Failed to wait");
    }
}

// 2. å¤šçº¿ç¨‹æ–¹å¼
fn multi_thread() {
    let mut handles = vec![];

    for i in 0..4 {
        let handle = thread::spawn(move || {
            // å·¥ä½œé€»è¾‘
            println!("Thread {} working", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().expect("Failed to join");
    }
}
```

---

### 1.3 è¿›ç¨‹çš„èµ„æºéš”ç¦»

**éš”ç¦»çš„èµ„æºç±»å‹**:

**1. å†…å­˜éš”ç¦»**:

```text
è¿›ç¨‹Aåœ°å€ç©ºé—´              è¿›ç¨‹Båœ°å€ç©ºé—´
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å†…æ ¸ç©ºé—´   â”‚          â”‚   å†…æ ¸ç©ºé—´   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     æ ˆ       â”‚          â”‚     æ ˆ       â”‚
â”‚      â†“       â”‚          â”‚      â†“       â”‚
â”‚              â”‚          â”‚              â”‚
â”‚      â†‘       â”‚          â”‚      â†‘       â”‚
â”‚     å †       â”‚          â”‚     å †       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ•°æ®æ®µ     â”‚          â”‚   æ•°æ®æ®µ     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ä»£ç æ®µ     â”‚          â”‚   ä»£ç æ®µ     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ç‹¬ç«‹ç©ºé—´                  ç‹¬ç«‹ç©ºé—´
```

**2. æ–‡ä»¶æè¿°ç¬¦éš”ç¦»**:

```rust
use std::fs::File;
use std::process::Command;
use std::os::unix::io::AsRawFd;

fn main() -> std::io::Result<()> {
    // çˆ¶è¿›ç¨‹æ‰“å¼€æ–‡ä»¶
    let file = File::open("/etc/hosts")?;
    let fd = file.as_raw_fd();

    println!("Parent FD: {}", fd);

    // å­è¿›ç¨‹æœ‰è‡ªå·±ç‹¬ç«‹çš„FDè¡¨
    let child = Command::new("ls")
        .arg("-la")
        .arg("/proc/self/fd")
        .spawn()?;

    child.wait_with_output()?;

    // æ–‡ä»¶æè¿°ç¬¦ä¸ä¼šäº’ç›¸å½±å“
    Ok(())
}
```

**3. ç¯å¢ƒå˜é‡éš”ç¦»**:

```rust
use std::process::Command;
use std::env;

fn main() {
    // çˆ¶è¿›ç¨‹ç¯å¢ƒå˜é‡
    env::set_var("PARENT_VAR", "parent_value");

    // å­è¿›ç¨‹ç»§æ‰¿ä½†ç‹¬ç«‹
    let output = Command::new("sh")
        .arg("-c")
        .arg("echo $PARENT_VAR")
        .env("CHILD_VAR", "child_value")
        .output()
        .expect("Failed");

    println!("Child sees: {}", String::from_utf8_lossy(&output.stdout));

    // çˆ¶è¿›ç¨‹ä¸å—å½±å“
    assert_eq!(env::var("CHILD_VAR").is_err(), true);
}
```

**4. å·¥ä½œç›®å½•éš”ç¦»**:

```rust
let child1 = Command::new("pwd")
    .current_dir("/tmp")
    .spawn()?;

let child2 = Command::new("pwd")
    .current_dir("/home")
    .spawn()?;

// ä¸¤ä¸ªè¿›ç¨‹æ‹¥æœ‰ä¸åŒçš„å·¥ä½œç›®å½•
```

**éš”ç¦»çš„å®ç°æœºåˆ¶**:

- **è™šæ‹Ÿå†…å­˜**: æ¯ä¸ªè¿›ç¨‹æœ‰ç‹¬ç«‹çš„é¡µè¡¨
- **å‘½åç©ºé—´ï¼ˆLinuxï¼‰**: PID, Mount, Network, IPC, UTS, Userå‘½åç©ºé—´
- **Cgroups**: èµ„æºé™åˆ¶å’Œéš”ç¦»
- **æƒé™æ§åˆ¶**: UID/GID, Capabilities

---

### 1.4 è¿›ç¨‹çš„ä¼˜ç¼ºç‚¹åˆ†æ

**ä¼˜ç‚¹** âœ…:

1. **å¼ºéš”ç¦»æ€§**:
   - ä¸€ä¸ªè¿›ç¨‹å´©æºƒä¸å½±å“å…¶ä»–è¿›ç¨‹
   - é€‚åˆè¿è¡Œä¸å¯ä¿¡ä»£ç 

2. **å®‰å…¨æ€§**:
   - ç‹¬ç«‹çš„åœ°å€ç©ºé—´é˜²æ­¢å†…å­˜è¶Šç•Œ
   - å¯ä»¥è®¾ç½®ä¸åŒçš„æƒé™ï¼ˆUID/GIDï¼‰

3. **ç¨³å®šæ€§**:
   - æ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºç»´æŠ¤
   - å¯ä»¥ç‹¬ç«‹é‡å¯æŸä¸ªæœåŠ¡

4. **è·¨è¯­è¨€**:
   - ä¸åŒè¯­è¨€ç¼–å†™çš„æ¨¡å—å¯ä»¥é€šè¿‡è¿›ç¨‹é€šä¿¡
   - æ— éœ€è€ƒè™‘ABIå…¼å®¹æ€§

**ç¼ºç‚¹** âŒ:

1. **èµ„æºå¼€é”€å¤§**:
   - æ¯ä¸ªè¿›ç¨‹éœ€è¦ç‹¬ç«‹çš„å†…å­˜ç©ºé—´
   - åˆ›å»ºå’Œé”€æ¯å¼€é”€è¾ƒå¤§

2. **é€šä¿¡å¤æ‚**:
   - éœ€è¦ä½¿ç”¨IPCæœºåˆ¶ï¼ˆç®¡é“ã€Socketç­‰ï¼‰
   - æ€§èƒ½ä¸å¦‚çº¿ç¨‹çš„ç›´æ¥å†…å­˜è®¿é—®

3. **è°ƒè¯•å›°éš¾**:
   - å¤šè¿›ç¨‹è°ƒè¯•æ¯”å•è¿›ç¨‹å¤æ‚
   - éœ€è¦ä¸“é—¨çš„å·¥å…·ï¼ˆå¦‚gdb attachï¼‰

4. **åŒæ­¥é—®é¢˜**:
   - è¿›ç¨‹é—´åŒæ­¥éœ€è¦é¢å¤–æœºåˆ¶
   - æ¯”çº¿ç¨‹çš„äº’æ–¥é”ç­‰æ›´å¤æ‚

**æ€§èƒ½å¯¹æ¯”**:

```rust
use std::time::Instant;

// æµ‹è¯•è¿›ç¨‹åˆ›å»ºå¼€é”€
fn benchmark_process_creation() {
    let start = Instant::now();

    for _ in 0..100 {
        let child = Command::new("true").spawn().unwrap();
        child.wait_with_output().unwrap();
    }

    let duration = start.elapsed();
    println!("100 processes: {:?}", duration);  // çº¦ 500-1000ms
}

// æµ‹è¯•çº¿ç¨‹åˆ›å»ºå¼€é”€
fn benchmark_thread_creation() {
    let start = Instant::now();

    for _ in 0..100 {
        let handle = thread::spawn(|| {});
        handle.join().unwrap();
    }

    let duration = start.elapsed();
    println!("100 threads: {:?}", duration);  // çº¦ 10-50ms
}
```

**å…¸å‹åº”ç”¨åœºæ™¯**:

**è¿›ç¨‹é€‚ç”¨**:

- ğŸ”¹ WebæœåŠ¡å™¨ï¼ˆNginx: master-workeræ¨¡å‹ï¼‰
- ğŸ”¹ æ•°æ®åº“ï¼ˆPostgreSQL: æ¯ä¸ªè¿æ¥ä¸€ä¸ªè¿›ç¨‹ï¼‰
- ğŸ”¹ Chromeæµè§ˆå™¨ï¼ˆæ¯ä¸ªæ ‡ç­¾é¡µä¸€ä¸ªè¿›ç¨‹ï¼‰
- ğŸ”¹ å®¹å™¨åŒ–åº”ç”¨ï¼ˆDocker: æ¯ä¸ªå®¹å™¨ä¸€ä¸ªä¸»è¿›ç¨‹ï¼‰

**çº¿ç¨‹é€‚ç”¨**:

- ğŸ”¹ GUIåº”ç”¨ï¼ˆä¸»çº¿ç¨‹+å·¥ä½œçº¿ç¨‹ï¼‰
- ğŸ”¹ æ¸¸æˆå¼•æ“ï¼ˆæ¸²æŸ“ã€ç‰©ç†ã€AIçº¿ç¨‹ï¼‰
- ğŸ”¹ é«˜æ€§èƒ½è®¡ç®—ï¼ˆæ•°æ®å¹¶è¡Œï¼‰
- ğŸ”¹ å¼‚æ­¥I/Oæ¡†æ¶ï¼ˆTokio: å¤šçº¿ç¨‹è¿è¡Œæ—¶ï¼‰

---

## 2. è¿›ç¨‹çŠ¶æ€æœºæ¨¡å‹

### 2.1 ç»å…¸äº”çŠ¶æ€æ¨¡å‹

**çŠ¶æ€å®šä¹‰**:

```text
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   æ–°å»º  â”‚ (NEW)
       â”‚  (åˆ›å»º) â”‚
       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
            â”‚ è¿›ç¨‹åˆ›å»ºå®Œæˆ
            â†“
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”Œâ”€â”€â†’â”‚  å°±ç»ª   â”‚â†â”€â”€â”
   â”‚   â”‚ (READY) â”‚   â”‚ æ—¶é—´ç‰‡ç”¨å®Œ/è¢«æŠ¢å 
   â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â”‚
   â”‚        â”‚ è°ƒåº¦   â”‚
   â”‚        â†“        â”‚
   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
   â”‚   â”‚  è¿è¡Œ   â”‚â”€â”€â”€â”˜
   â”‚   â”‚(RUNNING)â”‚
   â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
   â”‚        â”‚ I/Oè¯·æ±‚
   â”‚        â†“
   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â””â”€â”€â”€â”‚  é˜»å¡   â”‚
       â”‚(BLOCKED)â”‚
       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
            â”‚ è¿›ç¨‹ç»ˆæ­¢
            â†“
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  ç»ˆæ­¢   â”‚ (TERMINATED)
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**çŠ¶æ€è¯¦è§£**:

**1. NEW (æ–°å»º)**:

- è¿›ç¨‹æ­£åœ¨è¢«åˆ›å»º
- åˆ†é…è¿›ç¨‹æ§åˆ¶å—ï¼ˆPCBï¼‰
- å°šæœªè¿›å…¥å°±ç»ªé˜Ÿåˆ—

**2. READY (å°±ç»ª)**:

- è¿›ç¨‹å·²å‡†å¤‡å¥½è¿è¡Œ
- ç­‰å¾…CPUè°ƒåº¦
- åœ¨å°±ç»ªé˜Ÿåˆ—ä¸­æ’é˜Ÿ

**3. RUNNING (è¿è¡Œ)**:

- è¿›ç¨‹æ­£åœ¨CPUä¸Šæ‰§è¡Œ
- å•æ ¸CPUåŒæ—¶åªæœ‰ä¸€ä¸ªè¿›ç¨‹è¿è¡Œ

**4. BLOCKED (é˜»å¡)**:

- è¿›ç¨‹ç­‰å¾…æŸä¸ªäº‹ä»¶ï¼ˆI/Oå®Œæˆã€ä¿¡å·ç­‰ï¼‰
- ä¸èƒ½è¢«è°ƒåº¦æ‰§è¡Œ
- äº‹ä»¶å‘ç”Ÿåè½¬ä¸ºå°±ç»ªçŠ¶æ€

**5. TERMINATED (ç»ˆæ­¢)**:

- è¿›ç¨‹æ‰§è¡Œå®Œæˆæˆ–è¢«ç»ˆæ­¢
- ç­‰å¾…çˆ¶è¿›ç¨‹å›æ”¶èµ„æº

**Rustä»£ç ç¤ºä¾‹**:

```rust
use std::process::{Command, Stdio};
use std::time::Duration;
use std::thread;

fn demonstrate_process_states() -> std::io::Result<()> {
    // NEW â†’ READY â†’ RUNNING
    let mut child = Command::new("sleep")
        .arg("10")
        .spawn()?;  // è¿›ç¨‹ä» NEW â†’ READY â†’ RUNNING

    println!("è¿›ç¨‹å·²åˆ›å»ºï¼ŒPID: {}", child.id());

    // RUNNING çŠ¶æ€
    thread::sleep(Duration::from_secs(2));

    // æ£€æŸ¥çŠ¶æ€ï¼ˆRUNNING æˆ– READYï¼‰
    match child.try_wait()? {
        None => println!("è¿›ç¨‹ä»åœ¨è¿è¡Œ"),
        Some(status) => println!("è¿›ç¨‹å·²ç»ˆæ­¢: {:?}", status),
    }

    // ç»ˆæ­¢è¿›ç¨‹ (RUNNING â†’ TERMINATED)
    child.kill()?;

    // TERMINATED çŠ¶æ€
    let status = child.wait()?;
    println!("è¿›ç¨‹å·²ç»ˆæ­¢ï¼Œé€€å‡ºç : {:?}", status.code());

    Ok(())
}
```

### 2.2 ä¸ƒçŠ¶æ€æ¨¡å‹ï¼ˆåŒ…å«æŒ‚èµ·ï¼‰

**æ‰©å±•çŠ¶æ€**:

```text
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚   æ–°å»º  â”‚
               â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                    â”‚
                    â†“
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚        å°±ç»ªé˜Ÿåˆ—            â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
     â”‚  â”‚ å°±ç»ªæŒ‚èµ·â”‚  â”‚   å°±ç»ª  â”‚â”‚
     â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”˜
             â”‚            â”‚
             â”‚            â†“
             â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚       â”‚  è¿è¡Œ   â”‚
             â”‚       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚            â”‚
             â”‚            â†“
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚       â”‚      é˜»å¡é˜Ÿåˆ—        â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
     â”‚  â”‚ é˜»å¡æŒ‚èµ·â”‚  â”‚  é˜»å¡   â”‚  â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â†“
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  ç»ˆæ­¢   â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ–°å¢çŠ¶æ€è§£é‡Š**:

**READY_SUSPEND (å°±ç»ªæŒ‚èµ·)**:

- è¿›ç¨‹å·²å°±ç»ªä½†è¢«æŒ‚èµ·åˆ°ç£ç›˜
- å†…å­˜ä¸è¶³æ—¶ï¼Œå°†éƒ¨åˆ†å°±ç»ªè¿›ç¨‹æŒ‚èµ·
- æ¿€æ´»åè½¬ä¸ºå°±ç»ªçŠ¶æ€

**BLOCKED_SUSPEND (é˜»å¡æŒ‚èµ·)**:

- è¿›ç¨‹ç­‰å¾…äº‹ä»¶ä¸”è¢«æŒ‚èµ·åˆ°ç£ç›˜
- åŒé‡ç­‰å¾…ï¼šäº‹ä»¶å®Œæˆ + å†…å­˜èµ„æº
- é€‚ç”¨äºé•¿æ—¶é—´ç­‰å¾…çš„è¿›ç¨‹

**Rustæ¨¡æ‹ŸæŒ‚èµ·**:

```rust
use std::process::{Command, Stdio};

#[cfg(unix)]
fn suspend_resume_process() -> std::io::Result<()> {
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;

    let mut child = Command::new("sleep")
        .arg("60")
        .spawn()?;

    let pid = child.id() as i32;

    // æŒ‚èµ·è¿›ç¨‹ (SIGSTOP)
    kill(Pid::from_raw(pid), Signal::SIGSTOP).ok();
    println!("è¿›ç¨‹å·²æŒ‚èµ·");

    std::thread::sleep(Duration::from_secs(5));

    // æ¢å¤è¿›ç¨‹ (SIGCONT)
    kill(Pid::from_raw(pid), Signal::SIGCONT).ok();
    println!("è¿›ç¨‹å·²æ¢å¤");

    child.wait()?;
    Ok(())
}
```

---

### 2.3 Rustä¸­çš„è¿›ç¨‹çŠ¶æ€æ˜ å°„

**Rustç±»å‹ vs æ“ä½œç³»ç»ŸçŠ¶æ€**:

| Rustç±»å‹              | OSçŠ¶æ€                | è¯´æ˜                   |
| :--- | :--- | :--- || `Command::new()`      | -                     | ä»…æ„å»ºå‘½ä»¤ï¼Œæœªåˆ›å»ºè¿›ç¨‹ |
| `spawn()`             | NEW â†’ READY/RUNNING   | åˆ›å»ºè¿›ç¨‹å¹¶ç«‹å³è¿è¡Œ     |
| `Child`               | RUNNING/READY/BLOCKED | è¿è¡Œä¸­çš„è¿›ç¨‹           |
| `try_wait() â†’ None`   | RUNNING/READY/BLOCKED | è¿›ç¨‹ä»åœ¨è¿è¡Œ           |
| `try_wait() â†’ Some()` | TERMINATED            | è¿›ç¨‹å·²ç»“æŸ             |
| `ExitStatus`          | TERMINATED            | ç»ˆæ­¢çŠ¶æ€è¯¦æƒ…           |

**çŠ¶æ€æ£€æµ‹**:

```rust
use std::process::Command;
use std::time::Duration;

pub enum ProcessState {
    Running,
    Terminated(Option<i32>),
    Unknown,
}

pub fn check_process_state(child: &mut Child) -> ProcessState {
    match child.try_wait() {
        Ok(Some(status)) => ProcessState::Terminated(status.code()),
        Ok(None) => ProcessState::Running,
        Err(_) => ProcessState::Unknown,
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    let mut child = Command::new("sleep").arg("5").spawn()?;

    loop {
        match check_process_state(&mut child) {
            ProcessState::Running => {
                println!("[{}] è¿›ç¨‹è¿è¡Œä¸­...", child.id());
            }
            ProcessState::Terminated(code) => {
                println!("[{}] è¿›ç¨‹å·²ç»ˆæ­¢ï¼Œé€€å‡ºç : {:?}", child.id(), code);
                break;
            }
            ProcessState::Unknown => {
                eprintln!("æ— æ³•æ£€æµ‹è¿›ç¨‹çŠ¶æ€");
                break;
            }
        }

        std::thread::sleep(Duration::from_secs(1));
    }

    Ok(())
}
```

---

### 2.4 çŠ¶æ€è½¬æ¢è§¦å‘æ¡ä»¶

**çŠ¶æ€è½¬æ¢è¡¨**:

| å½“å‰çŠ¶æ€        | äº‹ä»¶         | ä¸‹ä¸€çŠ¶æ€        |
| :--- | :--- | :--- || NEW             | è¿›ç¨‹åˆ›å»ºå®Œæˆ | READY           |
| READY           | CPUè°ƒåº¦      | RUNNING         |
| RUNNING         | æ—¶é—´ç‰‡ç”¨å®Œ   | READY           |
| RUNNING         | I/Oè¯·æ±‚      | BLOCKED         |
| RUNNING         | è¿›ç¨‹ç»ˆæ­¢     | TERMINATED      |
| RUNNING         | æŒ‚èµ·         | READY_SUSPEND   |
| BLOCKED         | I/Oå®Œæˆ      | READY           |
| BLOCKED         | æŒ‚èµ·         | BLOCKED_SUSPEND |
| READY_SUSPEND   | æ¿€æ´»         | READY           |
| BLOCKED_SUSPEND | I/Oå®Œæˆ      | READY_SUSPEND   |
| BLOCKED_SUSPEND | æ¿€æ´»         | BLOCKED         |

**Rustè§¦å‘çŠ¶æ€è½¬æ¢**:

```rust
use std::process::{Command, Stdio};
use std::io::Write;

fn trigger_state_transitions() -> std::io::Result<()> {
    // NEW â†’ READY â†’ RUNNING
    let mut child = Command::new("cat")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    println!("1. è¿›ç¨‹åˆ›å»º: NEW â†’ RUNNING");

    // RUNNING â†’ BLOCKED (ç­‰å¾…è¾“å…¥)
    println!("2. è¿›ç¨‹é˜»å¡: RUNNING â†’ BLOCKED (ç­‰å¾…stdin)");
    std::thread::sleep(Duration::from_secs(2));

    // BLOCKED â†’ READY â†’ RUNNING (æä¾›è¾“å…¥)
    if let Some(mut stdin) = child.stdin.take() {
        writeln!(stdin, "Hello")?;
        println!("3. è§£é™¤é˜»å¡: BLOCKED â†’ READY â†’ RUNNING");
    }

    std::thread::sleep(Duration::from_secs(1));

    // RUNNING â†’ TERMINATED (ç»ˆæ­¢è¿›ç¨‹)
    child.kill()?;
    println!("4. è¿›ç¨‹ç»ˆæ­¢: RUNNING â†’ TERMINATED");

    child.wait()?;

    Ok(())
}
```

---

### 2.5 åƒµå°¸è¿›ç¨‹ä¸å­¤å„¿è¿›ç¨‹

**åƒµå°¸è¿›ç¨‹ (Zombie Process)**:

**å®šä¹‰**: è¿›ç¨‹å·²ç»ˆæ­¢ï¼Œä½†çˆ¶è¿›ç¨‹å°šæœªè°ƒç”¨`wait()`å›æ”¶å…¶èµ„æºã€‚

**ç‰¹å¾**:

- è¿›ç¨‹å·²ç»“æŸï¼Œä½†PCBä»ä¿ç•™
- å ç”¨PIDï¼Œä¸å ç”¨å…¶ä»–èµ„æº
- çŠ¶æ€æ˜¾ç¤ºä¸º`Z (zombie)`

**å±å®³**: å¤§é‡åƒµå°¸è¿›ç¨‹ä¼šè€—å°½PIDèµ„æº

**é¿å…åƒµå°¸è¿›ç¨‹**:

```rust
use std::process::Command;
use std::thread;

// âŒ é”™è¯¯ï¼šä¸å›æ”¶å­è¿›ç¨‹
fn create_zombie() {
    let _child = Command::new("true").spawn().unwrap();
    // æ²¡æœ‰è°ƒç”¨ wait()ï¼Œåˆ›å»ºåƒµå°¸è¿›ç¨‹ï¼
}

// âœ… æ­£ç¡®ï¼šåŠæ—¶å›æ”¶å­è¿›ç¨‹
fn proper_cleanup() -> std::io::Result<()> {
    let mut child = Command::new("true").spawn()?;
    child.wait()?;  // å›æ”¶å­è¿›ç¨‹
    Ok(())
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨RAIIæ¨¡å¼
struct ManagedChild(Child);

impl Drop for ManagedChild {
    fn drop(&mut self) {
        // è‡ªåŠ¨å›æ”¶
        self.0.wait().ok();
    }
}
```

**æ£€æµ‹åƒµå°¸è¿›ç¨‹**:

```rust
#[cfg(unix)]
fn find_zombie_processes() -> std::io::Result<()> {
    use std::fs;

    let entries = fs::read_dir("/proc")?;

    for entry in entries {
        if let Ok(entry) = entry {
            let path = entry.path();
            if let Some(pid_str) = path.file_name().and_then(|n| n.to_str()) {
                if pid_str.chars().all(|c| c.is_digit(10)) {
                    // è¯»å–è¿›ç¨‹çŠ¶æ€
                    let status_path = path.join("stat");
                    if let Ok(content) = fs::read_to_string(status_path) {
                        // ç¬¬ä¸‰ä¸ªå­—æ®µæ˜¯çŠ¶æ€
                        let fields: Vec<&str> = content.split_whitespace().collect();
                        if fields.len() > 2 && fields[2] == "Z" {
                            println!("åƒµå°¸è¿›ç¨‹: PID {}", pid_str);
                        }
                    }
                }
            }
        }
    }

    Ok(())
}
```

---

**å­¤å„¿è¿›ç¨‹ (Orphan Process)**:

**å®šä¹‰**: çˆ¶è¿›ç¨‹å…ˆäºå­è¿›ç¨‹é€€å‡ºï¼Œå­è¿›ç¨‹è¢«`init`(PID 1)æˆ–`systemd`æ”¶å…»ã€‚

**ç‰¹å¾**:

- PPIDå˜ä¸º1ï¼ˆinitè¿›ç¨‹ï¼‰
- æ­£å¸¸è¿è¡Œï¼Œä¸ä¼šæˆä¸ºåƒµå°¸è¿›ç¨‹
- initä¼šè‡ªåŠ¨å›æ”¶å…¶é€€å‡ºçŠ¶æ€

**åˆ›å»ºå­¤å„¿è¿›ç¨‹**:

```rust
use std::process::Command;
use std::thread;
use std::time::Duration;

fn create_orphan() -> std::io::Result<()> {
    // çˆ¶è¿›ç¨‹
    let parent_pid = std::process::id();
    println!("çˆ¶è¿›ç¨‹ PID: {}", parent_pid);

    // åˆ›å»ºå­è¿›ç¨‹
    let mut child = Command::new("sleep")
        .arg("30")
        .spawn()?;

    let child_pid = child.id();
    println!("å­è¿›ç¨‹ PID: {}", child_pid);

    // çˆ¶è¿›ç¨‹ç«‹å³é€€å‡ºï¼Œä¸ç­‰å¾…å­è¿›ç¨‹
    // å­è¿›ç¨‹å˜æˆå­¤å„¿è¿›ç¨‹
    std::process::exit(0);  // çˆ¶è¿›ç¨‹é€€å‡º

    // è¿™é‡Œçš„ä»£ç ä¸ä¼šæ‰§è¡Œ
}

// å®ˆæŠ¤è¿›ç¨‹åŒ–ï¼ˆåˆ»æ„åˆ›å»ºå­¤å„¿è¿›ç¨‹ï¼‰
#[cfg(unix)]
fn daemonize() -> std::io::Result<()> {
    use nix::unistd::{fork, ForkResult, setsid};

    // ç¬¬ä¸€æ¬¡fork
    match unsafe { fork() } {
        Ok(ForkResult::Parent { .. }) => {
            // çˆ¶è¿›ç¨‹é€€å‡ºï¼Œè®©å­è¿›ç¨‹æˆä¸ºå­¤å„¿
            std::process::exit(0);
        }
        Ok(ForkResult::Child) => {
            // å­è¿›ç¨‹æˆä¸ºä¼šè¯é¢†å¯¼è€…
            setsid().ok();

            // ç¬¬äºŒæ¬¡forkï¼Œç¡®ä¿ä¸æ˜¯ä¼šè¯é¢†å¯¼è€…
            match unsafe { fork() } {
                Ok(ForkResult::Parent { .. }) => std::process::exit(0),
                Ok(ForkResult::Child) => {
                    // çœŸæ­£çš„å®ˆæŠ¤è¿›ç¨‹
                    println!("å®ˆæŠ¤è¿›ç¨‹è¿è¡Œä¸­ï¼ŒPID: {}", std::process::id());
                    // ... å®ˆæŠ¤è¿›ç¨‹é€»è¾‘
                }
                Err(e) => return Err(e.into()),
            }
        }
        Err(e) => return Err(e.into()),
    }

    Ok(())
}
```

**å¯¹æ¯”**:

| ç‰¹æ€§         | åƒµå°¸è¿›ç¨‹                 | å­¤å„¿è¿›ç¨‹             |
| :--- | :--- | :--- || **æˆå› **     | çˆ¶è¿›ç¨‹æœªå›æ”¶å·²ç»ˆæ­¢å­è¿›ç¨‹ | çˆ¶è¿›ç¨‹å…ˆäºå­è¿›ç¨‹é€€å‡º |
| **çŠ¶æ€**     | TERMINATED (Z)           | RUNNING              |
| **PPID**     | åŸçˆ¶è¿›ç¨‹PID              | 1 (init)             |
| **èµ„æºå ç”¨** | ä»…å ç”¨PID                | æ­£å¸¸å ç”¨             |
| **å±å®³**     | è€—å°½PID                  | æ— ï¼ˆinitä¼šå›æ”¶ï¼‰     |
| **è§£å†³**     | çˆ¶è¿›ç¨‹è°ƒç”¨wait()         | æ— éœ€è§£å†³ï¼ˆæ­£å¸¸è¡Œä¸ºï¼‰ |

---

## 3. è¿›ç¨‹å±æ€§ä¸èµ„æº

### 3.1 è¿›ç¨‹æ ‡è¯†ç¬¦

**PID (Process ID)**:

- ç³»ç»Ÿå”¯ä¸€çš„è¿›ç¨‹æ ‡è¯†ç¬¦
- Unix: 1-32768 (å¯é…ç½®)
- Windows: ä»»æ„æ­£æ•´æ•°

```rust
use std::process::{Command, id as current_pid};

// å½“å‰è¿›ç¨‹PID
let my_pid = current_pid();
println!("å½“å‰è¿›ç¨‹: {}", my_pid);

// å­è¿›ç¨‹PID
let child = Command::new("sleep").arg("10").spawn()?;
println!("å­è¿›ç¨‹: {}", child.id());
```

**PPID (Parent PID)**:

```rust
#[cfg(unix)]
fn get_parent_pid() -> u32 {
    unsafe {
        libc::getppid() as u32
    }
}
```

---

### 3.2 è¿›ç¨‹èµ„æº

**èµ„æºç±»å‹**:

1. **CPUæ—¶é—´**: è¿›ç¨‹å ç”¨çš„CPUæ—¶é—´ç‰‡
2. **å†…å­˜**: è™šæ‹Ÿåœ°å€ç©ºé—´ã€ç‰©ç†å†…å­˜
3. **æ–‡ä»¶æè¿°ç¬¦**: æ‰“å¼€çš„æ–‡ä»¶ã€Socketã€ç®¡é“
4. **ä¿¡å·**: æ³¨å†Œçš„ä¿¡å·å¤„ç†å™¨
5. **ç¯å¢ƒ**: ç¯å¢ƒå˜é‡ã€å‘½ä»¤è¡Œå‚æ•°

**Rustèµ„æºç®¡ç†**:

```rust
use std::process::Command;
use std::env;

pub struct ProcessResources {
    pub pid: u32,
    pub env_vars: Vec<(String, String)>,
    pub args: Vec<String>,
    pub cwd: std::path::PathBuf,
}

impl ProcessResources {
    pub fn current() -> Self {
        Self {
            pid: std::process::id(),
            env_vars: env::vars().collect(),
            args: env::args().collect(),
            cwd: env::current_dir().unwrap_or_default(),
        }
    }

    pub fn print_summary(&self) {
        println!("PID: {}", self.pid);
        println!("CWD: {:?}", self.cwd);
        println!("Args: {:?}", self.args);
        println!("Env count: {}", self.env_vars.len());
    }
}
```

---

## 4. è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 4.1 åˆ›å»ºé˜¶æ®µ

**Unix: fork + execæ¨¡å‹**:

```text
çˆ¶è¿›ç¨‹           å­è¿›ç¨‹
  â”‚
  â”œâ”€ fork() â”€â”€â†’ åˆ›å»ºå‰¯æœ¬
  â”‚              â”‚
  â”‚              â”œâ”€ exec() â”€â”€â†’ åŠ è½½æ–°ç¨‹åº
  â”‚              â”‚
  â”‚              â””â”€ è¿è¡Œ
```

**Windows: CreateProcess**:

```text
çˆ¶è¿›ç¨‹
  â”‚
  â””â”€ CreateProcess() â”€â”€â†’ ç›´æ¥åˆ›å»ºæ–°è¿›ç¨‹
```

**Rustç»Ÿä¸€æ¥å£**:

```rust
// Rustéšè—äº†å¹³å°å·®å¼‚
let child = Command::new("program")
    .arg("arg1")
    .spawn()?;  // Unix: fork+exec / Windows: CreateProcess
```

---

### 4.2 è¿è¡Œé˜¶æ®µ

**è¿›ç¨‹è¡Œä¸º**:

- æ‰§è¡ŒæŒ‡ä»¤
- ç³»ç»Ÿè°ƒç”¨
- å“åº”ä¿¡å·ï¼ˆUnixï¼‰
- è®¿é—®èµ„æº

**ç›‘æ§è¿è¡Œä¸­çš„è¿›ç¨‹**:

```rust
use std::time::{Duration, Instant};

pub fn monitor_until_complete(mut child: Child) -> std::io::Result<()> {
    let start = Instant::now();

    loop {
        match child.try_wait()? {
            Some(status) => {
                let duration = start.elapsed();
                println!("è¿›ç¨‹è¿è¡Œäº† {:?}", duration);
                println!("é€€å‡ºçŠ¶æ€: {:?}", status.code());
                break;
            }
            None => {
                // è¿›ç¨‹ä»åœ¨è¿è¡Œ
                std::thread::sleep(Duration::from_millis(100));
            }
        }
    }

    Ok(())
}
```

---

### 4.3 ç»ˆæ­¢é˜¶æ®µ

**ç»ˆæ­¢æ–¹å¼**:

1. **æ­£å¸¸é€€å‡º**: `return` / `exit()`
2. **å¼‚å¸¸é€€å‡º**: æœªæ•è·çš„panicã€æ®µé”™è¯¯
3. **è¢«æ€æ­»**: `kill()` / ä¿¡å·

**Rustç»ˆæ­¢æ§åˆ¶**:

```rust
use std::process::Command;

// 1. ç­‰å¾…è‡ªç„¶ç»ˆæ­¢
let status = child.wait()?;

// 2. å¼ºåˆ¶ç»ˆæ­¢
child.kill()?;
let status = child.wait()?;

// 3. Unixä¿¡å·ç»ˆæ­¢
#[cfg(unix)]
{
    use nix::sys::signal::{kill, Signal};
    use nix::unistd::Pid;

    let pid = Pid::from_raw(child.id() as i32);
    kill(pid, Signal::SIGTERM)?;  // ä¼˜é›…ç»ˆæ­¢

    // ç­‰å¾…5ç§’
    std::thread::sleep(Duration::from_secs(5));

    // å¦‚æœè¿˜æœªç»ˆæ­¢ï¼Œå¼ºåˆ¶æ€æ­»
    if child.try_wait()?.is_none() {
        kill(pid, Signal::SIGKILL)?;
    }
}
```

---

### 4.4 å›æ”¶é˜¶æ®µ

**ä¸ºä»€ä¹ˆéœ€è¦å›æ”¶**:

- è·å–é€€å‡ºçŠ¶æ€
- é‡Šæ”¾PCBèµ„æº
- é˜²æ­¢åƒµå°¸è¿›ç¨‹

**æ­£ç¡®çš„å›æ”¶æ¨¡å¼**:

```rust
// âœ… RAIIæ¨¡å¼è‡ªåŠ¨å›æ”¶
pub struct ManagedProcess {
    child: Option<Child>,
}

impl ManagedProcess {
    pub fn spawn(cmd: &str) -> std::io::Result<Self> {
        let child = Command::new(cmd).spawn()?;
        Ok(Self {
            child: Some(child),
        })
    }
}

impl Drop for ManagedProcess {
    fn drop(&mut self) {
        if let Some(mut child) = self.child.take() {
            // å°è¯•ä¼˜é›…ç»ˆæ­¢
            child.kill().ok();
            child.wait().ok();
        }
    }
}
```

---

## 5. è¿›ç¨‹æ§åˆ¶å—ï¼ˆPCBï¼‰

**PCBåŒ…å«çš„ä¿¡æ¯**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Process Control Block (PCB)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. è¿›ç¨‹æ ‡è¯†                      â”‚
â”‚    - PID, PPID, UID, GID         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. è¿›ç¨‹çŠ¶æ€                      â”‚
â”‚    - NEW/READY/RUNNING/BLOCKED  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. CPUå¯„å­˜å™¨                     â”‚
â”‚    - PC, SP, é€šç”¨å¯„å­˜å™¨          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. è°ƒåº¦ä¿¡æ¯                      â”‚
â”‚    - ä¼˜å…ˆçº§, æ—¶é—´ç‰‡              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5. å†…å­˜ç®¡ç†                      â”‚
â”‚    - é¡µè¡¨æŒ‡é’ˆ, å†…å­˜é™åˆ¶          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6. æ–‡ä»¶æè¿°ç¬¦è¡¨                  â”‚
â”‚    - æ‰“å¼€çš„æ–‡ä»¶åˆ—è¡¨              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7. ä¿¡å·ä¿¡æ¯                      â”‚
â”‚    - ä¿¡å·æ©ç , å¤„ç†å™¨            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åœ¨Rustä¸­æ¨¡æ‹ŸPCB**:

```rust
#[derive(Debug)]
pub struct ProcessControlBlock {
    pub pid: u32,
    pub ppid: u32,
    pub state: ProcessState,
    pub priority: u8,
    pub cpu_time: Duration,
    pub memory_usage: usize,
    pub open_files: Vec<String>,
}

impl ProcessControlBlock {
    pub fn new(pid: u32, ppid: u32) -> Self {
        Self {
            pid,
            ppid,
            state: ProcessState::Running,
            priority: 0,
            cpu_time: Duration::from_secs(0),
            memory_usage: 0,
            open_files: Vec::new(),
        }
    }

    pub fn update_state(&mut self, new_state: ProcessState) {
        println!("PID {} çŠ¶æ€å˜æ›´: {:?} -> {:?}",
            self.pid, self.state, new_state);
        self.state = new_state;
    }
}
```

---

## 6. è¿›ç¨‹è°ƒåº¦æ¨¡å‹

### 6.1 è°ƒåº¦ç®—æ³•

**å¸¸è§ç®—æ³•**:

1. **FCFS (å…ˆæ¥å…ˆæœåŠ¡)**:
   - ç®€å•ï¼Œä½†å¯èƒ½å¯¼è‡´é•¿ä½œä¸šé˜»å¡

2. **SJF (æœ€çŸ­ä½œä¸šä¼˜å…ˆ)**:
   - æœ€ä¼˜å¹³å‡ç­‰å¾…æ—¶é—´
   - å¯èƒ½å¯¼è‡´é¥¥é¥¿

3. **ä¼˜å…ˆçº§è°ƒåº¦**:
   - æ”¯æŒä¸åŒé‡è¦æ€§çš„è¿›ç¨‹
   - å¯èƒ½å¯¼è‡´ä¼˜å…ˆçº§åè½¬

4. **æ—¶é—´ç‰‡è½®è½¬ (RR)**:
   - å…¬å¹³ï¼Œå“åº”æ—¶é—´å¥½
   - ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€

5. **å¤šçº§åé¦ˆé˜Ÿåˆ— (MLFQ)**:
   - å…¼é¡¾I/Oå¯†é›†å’ŒCPUå¯†é›†å‹è¿›ç¨‹
   - Linux CFSä½¿ç”¨ç±»ä¼¼æœºåˆ¶

**Rustæ¨¡æ‹Ÿè°ƒåº¦å™¨**:

```rust
use std::collections::VecDeque;

pub struct RoundRobinScheduler {
    ready_queue: VecDeque<u32>,  // PIDé˜Ÿåˆ—
    time_quantum: Duration,
}

impl RoundRobinScheduler {
    pub fn new(time_quantum: Duration) -> Self {
        Self {
            ready_queue: VecDeque::new(),
            time_quantum,
        }
    }

    pub fn add_process(&mut self, pid: u32) {
        self.ready_queue.push_back(pid);
    }

    pub fn schedule(&mut self) -> Option<u32> {
        self.ready_queue.pop_front()
    }

    pub fn time_slice_expired(&mut self, pid: u32) {
        // æ—¶é—´ç‰‡ç”¨å®Œï¼Œæ”¾å›é˜Ÿå°¾
        self.ready_queue.push_back(pid);
    }
}
```

---

## 7. è¿›ç¨‹é—´å…³ç³»

### 7.1 çˆ¶å­å…³ç³»

**ç»§æ‰¿å…³ç³»**:

- å­è¿›ç¨‹ç»§æ‰¿çˆ¶è¿›ç¨‹çš„éƒ¨åˆ†èµ„æº
- ç¯å¢ƒå˜é‡ï¼ˆå¯ä¿®æ”¹ï¼‰
- å·¥ä½œç›®å½•ï¼ˆå¯ä¿®æ”¹ï¼‰
- æ–‡ä»¶æè¿°ç¬¦ï¼ˆå¯é€‰ç»§æ‰¿ï¼‰

```rust
use std::fs::File;
use std::os::unix::io::AsRawFd;

// çˆ¶è¿›ç¨‹æ‰“å¼€æ–‡ä»¶
let file = File::open("data.txt")?;

// å­è¿›ç¨‹é»˜è®¤ä¼šç»§æ‰¿æ‰“å¼€çš„æ–‡ä»¶
let child = Command::new("cat")
    .stdin(Stdio::from(file))
    .spawn()?;
```

---

### 7.2 è¿›ç¨‹ç»„

**æ¦‚å¿µ**: ä¸€ç»„ç›¸å…³è¿›ç¨‹çš„é›†åˆï¼Œæ–¹ä¾¿ç»Ÿä¸€ç®¡ç†ã€‚

**Unixè¿›ç¨‹ç»„**:

```rust
#[cfg(unix)]
fn create_process_group() -> std::io::Result<()> {
    use nix::unistd::{setpgid, Pid};

    let mut child = Command::new("sleep").arg("100").spawn()?;
    let pid = child.id() as i32;

    // è®¾ç½®è¿›ç¨‹ç»„
    setpgid(Pid::from_raw(pid), Pid::from_raw(pid))?;

    println!("è¿›ç¨‹ {} æˆä¸ºè¿›ç¨‹ç»„ç»„é•¿", pid);

    Ok(())
}
```

---

### 7.3 ä¼šè¯ï¼ˆSessionï¼‰

**ä¼šè¯ > è¿›ç¨‹ç»„ > è¿›ç¨‹**:

```text
ä¼šè¯ (Session)
  â”œâ”€ å‰å°è¿›ç¨‹ç»„
  â”‚   â”œâ”€ è¿›ç¨‹1
  â”‚   â””â”€ è¿›ç¨‹2
  â””â”€ åå°è¿›ç¨‹ç»„
      â”œâ”€ è¿›ç¨‹3
      â””â”€ è¿›ç¨‹4
```

---

## 8. Unix vs Windows è¿›ç¨‹æ¨¡å‹å·®å¼‚

**æ ¸å¿ƒå·®å¼‚å¯¹æ¯”**:

| ç‰¹æ€§         | Unix                    | Windows          |
| :--- | :--- | :--- || **åˆ›å»ºæ–¹å¼** | fork + exec             | CreateProcess    |
| **èµ„æºç»§æ‰¿** | COW (å†™æ—¶å¤åˆ¶)          | æ˜¾å¼ç»§æ‰¿         |
| **è¿›ç¨‹æ ‘**   | æ ‘å½¢ç»“æ„                | æ‰å¹³ç»“æ„         |
| **ç»ˆæ­¢æ–¹å¼** | ä¿¡å· (SIGTERM, SIGKILL) | TerminateProcess |
| **é€€å‡ºç **   | 0-255                   | 0-4294967295     |
| **å®ˆæŠ¤è¿›ç¨‹** | daemon                  | Windows Service  |

**Rustè·¨å¹³å°å¤„ç†**:

```rust
pub fn terminate_process(child: &mut Child) -> std::io::Result<()> {
    #[cfg(unix)]
    {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;

        let pid = Pid::from_raw(child.id() as i32);
        kill(pid, Signal::SIGTERM)?;
    }

    #[cfg(windows)]
    {
        child.kill()?;
    }

    Ok(())
}
```

---

## 9. Rustè¿›ç¨‹æ¨¡å‹å®ç°

### 9.1 Command Builder

**æ„å»ºå™¨æ¨¡å¼**:

```rust
let child = Command::new("program")
    .arg("arg1")                    // å‚æ•°
    .env("VAR", "value")            // ç¯å¢ƒå˜é‡
    .current_dir("/tmp")            // å·¥ä½œç›®å½•
    .stdin(Stdio::piped())          // æ ‡å‡†è¾“å…¥
    .stdout(Stdio::piped())         // æ ‡å‡†è¾“å‡º
    .stderr(Stdio::null())          // å¿½ç•¥é”™è¯¯
    .spawn()?;                      // å¯åŠ¨
```

---

### 9.2 è¿›ç¨‹å¥æŸ„ (Child)

**å…³é”®æ–¹æ³•**:

```rust
pub struct Child {
    // è·å–PID
    pub fn id(&self) -> u32;

    // ç­‰å¾…è¿›ç¨‹ç»“æŸï¼ˆé˜»å¡ï¼‰
    pub fn wait(&mut self) -> io::Result<ExitStatus>;

    // éé˜»å¡æ£€æŸ¥çŠ¶æ€
    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>>;

    // ç»ˆæ­¢è¿›ç¨‹
    pub fn kill(&mut self) -> io::Result<()>;

    // æ ‡å‡†I/Oæµ
    pub stdin: Option<ChildStdin>;
    pub stdout: Option<ChildStdout>;
    pub stderr: Option<ChildStderr>;
}
```

---

## 10. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹: è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨

```rust
use std::collections::HashMap;
use std::time::Instant;

pub struct ProcessLifecycleManager {
    processes: HashMap<u32, ProcessInfo>,
}

struct ProcessInfo {
    child: Child,
    start_time: Instant,
    name: String,
}

impl ProcessLifecycleManager {
    pub fn new() -> Self {
        Self {
            processes: HashMap::new(),
        }
    }

    pub fn spawn(&mut self, name: String, cmd: &str) -> std::io::Result<u32> {
        let child = Command::new(cmd).spawn()?;
        let pid = child.id();

        self.processes.insert(pid, ProcessInfo {
            child,
            start_time: Instant::now(),
            name,
        });

        println!("âœ… è¿›ç¨‹ '{}' (PID {}) å·²å¯åŠ¨", name, pid);

        Ok(pid)
    }

    pub fn check_all(&mut self) {
        let pids: Vec<u32> = self.processes.keys().copied().collect();

        for pid in pids {
            if let Some(info) = self.processes.get_mut(&pid) {
                match info.child.try_wait() {
                    Ok(Some(status)) => {
                        let uptime = info.start_time.elapsed();
                        println!("âœ… è¿›ç¨‹ '{}' (PID {}) å·²ç»“æŸï¼Œè¿è¡Œæ—¶é—´: {:?}",
                            info.name, pid, uptime);
                        self.processes.remove(&pid);
                    }
                    Ok(None) => {
                        // ä»åœ¨è¿è¡Œ
                    }
                    Err(e) => {
                        eprintln!("âŒ æ£€æŸ¥è¿›ç¨‹ {} å¤±è´¥: {}", pid, e);
                        self.processes.remove(&pid);
                    }
                }
            }
        }
    }

    pub fn kill_all(&mut self) {
        for (pid, info) in &mut self.processes {
            println!("ğŸ›‘ ç»ˆæ­¢è¿›ç¨‹ '{}' (PID {})", info.name, pid);
            info.child.kill().ok();
        }
    }
}
```

---

## 11. æ€»ç»“ä¸æœ€ä½³å®è·µ

### æ ¸å¿ƒè¦ç‚¹

1. âœ… **è¿›ç¨‹æ˜¯èµ„æºåˆ†é…çš„åŸºæœ¬å•ä½**
2. âœ… **ç†è§£è¿›ç¨‹çŠ¶æ€è½¬æ¢æœºåˆ¶**
3. âœ… **é¿å…åƒµå°¸è¿›ç¨‹ï¼šå§‹ç»ˆå›æ”¶å­è¿›ç¨‹**
4. âœ… **ä½¿ç”¨RAIIæ¨¡å¼ç®¡ç†è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸ**
5. âœ… **è·¨å¹³å°å·®å¼‚ç”±RustæŠ½è±¡**

### æœ€ä½³å®è·µ

**1. è¿›ç¨‹åˆ›å»º**:

```rust
// âœ… ä½¿ç”¨Command builder
let child = Command::new("app")
    .args(["arg1", "arg2"])
    .spawn()?;
```

**2. è¿›ç¨‹å›æ”¶**:

```rust
// âœ… æ€»æ˜¯è°ƒç”¨wait()
child.wait()?;

// âœ… æˆ–ä½¿ç”¨RAII
let _managed = ManagedProcess::spawn("app")?;
```

**3. é”™è¯¯å¤„ç†**:

```rust
// âœ… æ£€æŸ¥é€€å‡ºçŠ¶æ€
let status = child.wait()?;
if !status.success() {
    eprintln!("è¿›ç¨‹å¤±è´¥: {:?}", status.code());
}
```

**4. èµ„æºæ¸…ç†**:

```rust
// âœ… å®ç°Drop trait
impl Drop for ProcessManager {
    fn drop(&mut self) {
        self.kill_all();
    }
}
```

---

**ä¸‹ä¸€æ­¥**: [02_IPCæœºåˆ¶å‚è€ƒ](./02_IPCæœºåˆ¶å‚è€ƒ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+

**é˜¶æ®µ**:

1. **åˆ›å»º**: `Command::new()`.`spawn()`
2. **è¿è¡Œ**: è¿›ç¨‹æ‰§è¡Œ
3. **ç­‰å¾…**: `wait()` / `try_wait()`
4. **ç»ˆæ­¢**: `kill()` / è‡ªç„¶é€€å‡º
5. **å›æ”¶**: è¯»å–é€€å‡ºçŠ¶æ€

**æœ€ä½³å®è·µ**: å§‹ç»ˆè°ƒç”¨ `wait()` å›æ”¶å­è¿›ç¨‹

---

**å‚è€ƒ**: [è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨](../tier_02_guides/01_è¿›ç¨‹ç®¡ç†å¿«é€Ÿå…¥é—¨.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
