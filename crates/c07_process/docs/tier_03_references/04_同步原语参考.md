# Tier 3: 同步原语参考

> **文档类型**: 技术参考  
> **适用版本**: Rust 1.90+  
> **前置知识**: [IPC通信实践](../tier_02_guides/02_IPC通信实践.md)

---

## 目录

- [Tier 3: 同步原语参考](#tier-3-同步原语参考)
  - [目录](#目录)
  - [1. 同步原语概述](#1-同步原语概述)
  - [2. 线程内同步](#2-线程内同步)
    - [2.1 Mutex互斥锁](#21-mutex互斥锁)
    - [2.2 RwLock读写锁](#22-rwlock读写锁)
    - [2.3 Condvar条件变量](#23-condvar条件变量)
    - [2.4 Barrier屏障](#24-barrier屏障)
    - [2.5 Once一次性初始化](#25-once一次性初始化)
  - [3. 原子操作](#3-原子操作)
  - [4. 进程间同步](#4-进程间同步)
    - [4.1 文件锁](#41-文件锁)
    - [4.2 信号量](#42-信号量)
    - [4.3 共享内存同步](#43-共享内存同步)
  - [5. 死锁预防](#5-死锁预防)
  - [6. 性能对比](#6-性能对比)
  - [7. 无锁编程](#7-无锁编程)
  - [8. 异步同步原语](#8-异步同步原语)
  - [9. 最佳实践](#9-最佳实践)
  - [10. 实战案例](#10-实战案例)
    - [案例: 线程安全的进程池](#案例-线程安全的进程池)
  - [总结](#总结)

---

## 1. 同步原语概述

**定义**: 用于协调多个并发执行单元（线程/进程）访问共享资源的机制。

**分类**:

```text
同步原语
├─ 线程内同步
│  ├─ Mutex (互斥锁)
│  ├─ RwLock (读写锁)
│  ├─ Condvar (条件变量)
│  ├─ Barrier (屏障)
│  ├─ Once (一次性初始化)
│  └─ Atomic (原子操作)
└─ 进程间同步
   ├─ 文件锁 (flock/fcntl)
   ├─ 信号量 (Semaphore)
   ├─ 共享内存同步
   └─ 消息传递
```

**为什么需要同步**:

```rust
// ❌ 数据竞争示例
use std::thread;

let mut counter = 0;

let handles: Vec<_> = (0..10)
    .map(|_| {
        thread::spawn(|| {
            counter += 1;  // 数据竞争！
        })
    })
    .collect();

// ✅ 正确的同步
use std::sync::{Arc, Mutex};

let counter = Arc::new(Mutex::new(0));

let handles: Vec<_> = (0..10)
    .map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        })
    })
    .collect();
```

---

## 2. 线程内同步

### 2.1 Mutex互斥锁

**原理**: 确保同一时刻只有一个线程访问共享资源。

**基本用法**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(0));
let mut handles = vec![];

for _ in 0..10 {
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut num = data.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *data.lock().unwrap());  // 10
```

**高级用法**:

```rust
use std::sync::Mutex;

// 带超时的锁获取（需parking_lot库）
use parking_lot::Mutex as ParkingMutex;
use std::time::Duration;

let mutex = ParkingMutex::new(42);

if let Some(guard) = mutex.try_lock_for(Duration::from_secs(1)) {
    println!("获取锁成功: {}", *guard);
} else {
    println!("获取锁超时");
}

// 死锁检测
let mutex = ParkingMutex::new(0);
let _guard1 = mutex.lock();
// let _guard2 = mutex.lock();  // 死锁！
```

**性能优化**:

```rust
// ❌ 低效：锁持有时间过长
let data = Arc::new(Mutex::new(vec![1, 2, 3]));
{
    let mut vec = data.lock().unwrap();
    for i in 0..1000 {
        vec.push(i);  // 锁持有整个循环
    }
}

// ✅ 高效：减少锁持有时间
let data = Arc::new(Mutex::new(vec![1, 2, 3]));
let new_items: Vec<_> = (0..1000).collect();
{
    let mut vec = data.lock().unwrap();
    vec.extend(new_items);  // 锁持有时间短
}
```

---

### 2.2 RwLock读写锁

**原理**: 允许多个读者或一个写者。

**基本用法**:

```rust
use std::sync::{Arc, RwLock};
use std::thread;

let data = Arc::new(RwLock::new(0));

// 多个读者线程
for _ in 0..5 {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let n = data.read().unwrap();
        println!("Reader: {}", *n);
    });
}

// 单个写者线程
let data_clone = Arc::clone(&data);
thread::spawn(move || {
    let mut n = data_clone.write().unwrap();
    *n += 1;
    println!("Writer: updated to {}", *n);
});
```

**性能对比**:

| 场景 | Mutex | RwLock |
|------|-------|--------|
| 纯读（10线程） | 1.0x | 5.2x ✅ |
| 纯写（10线程） | 1.0x | 0.8x |
| 读写混合（9读1写） | 1.0x | 3.5x ✅ |

**适用场景**: 读多写少

---

### 2.3 Condvar条件变量

**原理**: 线程等待特定条件成立。

**生产者-消费者模式**:

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::collections::VecDeque;

struct Queue {
    data: Mutex<VecDeque<i32>>,
    not_empty: Condvar,
}

impl Queue {
    fn new() -> Self {
        Self {
            data: Mutex::new(VecDeque::new()),
            not_empty: Condvar::new(),
        }
    }
    
    fn push(&self, value: i32) {
        let mut queue = self.data.lock().unwrap();
        queue.push_back(value);
        self.not_empty.notify_one();
    }
    
    fn pop(&self) -> i32 {
        let mut queue = self.data.lock().unwrap();
        while queue.is_empty() {
            queue = self.not_empty.wait(queue).unwrap();
        }
        queue.pop_front().unwrap()
    }
}

// 使用
let queue = Arc::new(Queue::new());

// 消费者
let q = Arc::clone(&queue);
thread::spawn(move || {
    let value = q.pop();
    println!("Got: {}", value);
});

// 生产者
queue.push(42);
```

---

### 2.4 Barrier屏障

**原理**: 等待所有线程到达同步点。

```rust
use std::sync::{Arc, Barrier};
use std::thread;

let barrier = Arc::new(Barrier::new(3));

for i in 0..3 {
    let barrier = Arc::clone(&barrier);
    thread::spawn(move || {
        println!("Thread {} 开始工作", i);
        
        // 模拟工作
        thread::sleep(std::time::Duration::from_millis(i * 100));
        
        println!("Thread {} 到达屏障", i);
        barrier.wait();
        
        println!("Thread {} 继续执行", i);
    });
}
```

**输出**:

```text
Thread 0 开始工作
Thread 1 开始工作
Thread 2 开始工作
Thread 0 到达屏障
Thread 1 到达屏障
Thread 2 到达屏障
Thread 0 继续执行
Thread 1 继续执行
Thread 2 继续执行
```

---

### 2.5 Once一次性初始化

**原理**: 确保初始化代码只执行一次。

```rust
use std::sync::Once;

static INIT: Once = Once::new();

fn expensive_initialization() {
    INIT.call_once(|| {
        println!("初始化（只执行一次）");
        // 耗时初始化
    });
}

// 多次调用，但只初始化一次
expensive_initialization();
expensive_initialization();
```

**LazyLock (Rust 1.80+)**:

```rust
use std::sync::LazyLock;

static CONFIG: LazyLock<Config> = LazyLock::new(|| {
    Config::load_from_file("config.toml")
});

// 首次访问时初始化
println!("{:?}", *CONFIG);
```

---

## 3. 原子操作

**无锁的并发**: 使用硬件支持的原子指令。

**基本原子类型**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

let counter = AtomicUsize::new(0);

// 原子递增
counter.fetch_add(1, Ordering::SeqCst);

// 原子比较并交换
let expected = 1;
let new_value = 2;
counter.compare_exchange(
    expected,
    new_value,
    Ordering::SeqCst,
    Ordering::SeqCst,
);
```

**内存顺序 (Ordering)**:

| 顺序 | 说明 | 性能 | 适用场景 |
|------|------|------|----------|
| `Relaxed` | 最弱保证 | 最快 | 计数器 |
| `Acquire` | 读操作 | 中 | 读锁 |
| `Release` | 写操作 | 中 | 写锁 |
| `AcqRel` | 读写操作 | 中 | 原子交换 |
| `SeqCst` | 最强保证 | 最慢 | 默认选择 |

**性能对比** (10M操作):

| 方法 | 耗时 |
|------|------|
| `AtomicUsize (Relaxed)` | 50ms |
| `AtomicUsize (SeqCst)` | 80ms |
| `Mutex` | 450ms |

**适用场景**: 简单计数器、标志位。

---

## 4. 进程间同步

### 4.1 文件锁

**flock/fcntl锁**:

```rust
use std::fs::OpenOptions;
use fs2::FileExt;

fn acquire_file_lock() -> std::io::Result<()> {
    let file = OpenOptions::new()
        .write(true)
        .create(true)
        .open("/tmp/myapp.lock")?;
    
    // 尝试获取排他锁
    match file.try_lock_exclusive() {
        Ok(_) => {
            println!("✅ 获取锁成功");
            
            // 临界区
            std::thread::sleep(std::time::Duration::from_secs(5));
            
            file.unlock()?;
            println!("✅ 释放锁");
        }
        Err(e) => {
            println!("❌ 锁已被占用: {}", e);
        }
    }
    
    Ok(())
}
```

**应用场景**: 防止程序多开、保护共享文件。

---

### 4.2 信号量

**POSIX信号量**:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));  // 最多3个并发
    
    let mut handles = vec![];
    
    for i in 0..10 {
        let sem = Arc::clone(&semaphore);
        let handle = tokio::spawn(async move {
            let _permit = sem.acquire().await.unwrap();
            println!("Task {} 执行中", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

---

### 4.3 共享内存同步

**原子操作 + 共享内存**:

```rust
use shared_memory::*;
use std::sync::atomic::{AtomicU32, Ordering};

// 进程A：写入
fn process_a() -> Result<(), Box<dyn std::error::Error>> {
    let shmem = ShmemConf::new().size(4096).create()?;
    
    unsafe {
        let counter = shmem.as_ptr() as *mut AtomicU32;
        (*counter).store(0, Ordering::SeqCst);
        
        for _ in 0..1000 {
            (*counter).fetch_add(1, Ordering::SeqCst);
        }
    }
    
    Ok(())
}

// 进程B：读取
fn process_b() -> Result<(), Box<dyn std::error::Error>> {
    let shmem = ShmemConf::new().size(4096).open()?;
    
    unsafe {
        let counter = shmem.as_ptr() as *const AtomicU32;
        let value = (*counter).load(Ordering::SeqCst);
        println!("Counter: {}", value);
    }
    
    Ok(())
}
```

---

## 5. 死锁预防

**死锁的4个必要条件**:

1. **互斥**: 资源不可共享
2. **持有并等待**: 持有资源的同时等待其他资源
3. **不可抢占**: 资源不能被强制释放
4. **循环等待**: 形成资源请求环路

**预防策略**:

**1. 锁顺序**:

```rust
// ❌ 死锁风险
thread::spawn(|| {
    let _a = lock_a.lock();
    let _b = lock_b.lock();
});

thread::spawn(|| {
    let _b = lock_b.lock();  // 反向！
    let _a = lock_a.lock();
});

// ✅ 正确：统一顺序
thread::spawn(|| {
    let _a = lock_a.lock();
    let _b = lock_b.lock();
});

thread::spawn(|| {
    let _a = lock_a.lock();  // 相同顺序
    let _b = lock_b.lock();
});
```

**2. try_lock**:

```rust
loop {
    let guard_a = lock_a.lock();
    
    if let Ok(guard_b) = lock_b.try_lock() {
        // 同时持有两个锁
        break;
    }
    
    // 释放lock_a，稍后重试
    drop(guard_a);
    std::thread::sleep(std::time::Duration::from_millis(10));
}
```

**3. 超时机制** (需parking_lot):

```rust
use parking_lot::Mutex;

let mutex = Mutex::new(0);

if let Some(guard) = mutex.try_lock_for(Duration::from_secs(5)) {
    println!("获取锁成功");
} else {
    println!("超时，可能存在死锁");
}
```

---

## 6. 性能对比

**延迟对比** (单次操作):

| 同步原语 | 延迟 |
|----------|------|
| `AtomicUsize (Relaxed)` | ~5 ns |
| `AtomicUsize (SeqCst)` | ~8 ns |
| `Mutex` | ~45 ns |
| `RwLock (read)` | ~40 ns |
| `RwLock (write)` | ~50 ns |

**吞吐量对比** (10线程，100万操作):

| 同步原语 | 操作/秒 |
|----------|---------|
| `AtomicUsize` | 22M ops/s |
| `Mutex` | 2.2M ops/s |
| `RwLock (90%读)` | 8.5M ops/s |
| 无同步(单线程) | 100M ops/s |

---

## 7. 无锁编程

**无锁队列**:

```rust
use crossbeam::queue::ArrayQueue;

let queue = ArrayQueue::new(10);

// 生产者
queue.push(42).ok();

// 消费者
if let Some(value) = queue.pop() {
    println!("Got: {}", value);
}
```

**优点**: 高性能、无死锁风险  
**缺点**: 实现复杂、难以调试

---

## 8. 异步同步原语

**Tokio同步原语**:

```rust
use tokio::sync::{Mutex, RwLock, Semaphore};

// 异步Mutex
let mutex = Mutex::new(0);
{
    let mut guard = mutex.lock().await;
    *guard += 1;
}

// 异步RwLock
let lock = RwLock::new(0);
{
    let read = lock.read().await;
    println!("{}", *read);
}

// 信号量
let sem = Semaphore::new(3);
let permit = sem.acquire().await.unwrap();
```

**关键区别**: 异步原语在等待时不阻塞线程。

---

## 9. 最佳实践

**1. 最小化锁范围**:

```rust
// ❌ 锁持有时间长
let mut data = shared_data.lock().unwrap();
heavy_computation(&data);

// ✅ 锁持有时间短
let snapshot = {
    let data = shared_data.lock().unwrap();
    data.clone()
};
heavy_computation(&snapshot);
```

**2. 选择合适的同步原语**:

- **简单计数器**: `AtomicUsize`
- **读多写少**: `RwLock`
- **一般场景**: `Mutex`
- **生产者-消费者**: `Condvar` 或 `channel`
- **一次性初始化**: `Once` / `LazyLock`

**3. 避免嵌套锁**:

```rust
// ❌ 嵌套锁（死锁风险）
let _a = lock_a.lock();
let _b = lock_b.lock();

// ✅ 单一锁
let _combined = combined_lock.lock();
```

**4. 使用RAII**:

```rust
// ✅ 自动释放锁
{
    let _guard = mutex.lock().unwrap();
    // 作用域结束时自动释放
}
```

---

## 10. 实战案例

### 案例: 线程安全的进程池

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;
use std::process::{Child, Command};

pub struct ProcessPool {
    available: Arc<(Mutex<VecDeque<Child>>, Condvar)>,
    max_size: usize,
}

impl ProcessPool {
    pub fn new(max_size: usize) -> Self {
        Self {
            available: Arc::new((Mutex::new(VecDeque::new()), Condvar::new())),
            max_size,
        }
    }
    
    pub fn acquire(&self) -> Child {
        let (lock, cvar) = &*self.available;
        let mut queue = lock.lock().unwrap();
        
        while queue.is_empty() && queue.len() < self.max_size {
            queue = cvar.wait(queue).unwrap();
        }
        
        queue.pop_front().unwrap_or_else(|| {
            Command::new("worker").spawn().unwrap()
        })
    }
    
    pub fn release(&self, child: Child) {
        let (lock, cvar) = &*self.available;
        let mut queue = lock.lock().unwrap();
        queue.push_back(child);
        cvar.notify_one();
    }
}
```

---

## 总结

**同步原语选择指南**:

| 需求 | 推荐原语 |
|------|----------|
| 简单计数器 | `AtomicUsize` |
| 共享可变状态 | `Mutex` |
| 读多写少 | `RwLock` |
| 等待条件 | `Condvar` |
| 同步点 | `Barrier` |
| 一次性初始化 | `Once` / `LazyLock` |
| 进程间同步 | 文件锁 / 信号量 |
| 异步场景 | `tokio::sync::*` |

**关键原则**:

1. ✅ 选择合适的同步原语
2. ✅ 最小化锁范围
3. ✅ 避免嵌套锁
4. ✅ 使用超时机制
5. ✅ 优先使用无锁数据结构

---

**下一步**: [05_性能优化参考](./05_性能优化参考.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-23  
**适用版本**: Rust 1.90+
