# Tier 3: åŒæ­¥åŸè¯­å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: æŠ€æœ¯å‚è€ƒ
> **é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
> **å‰ç½®çŸ¥è¯†**: [IPCé€šä¿¡å®è·µ](../tier_02_guides/02_IPCé€šä¿¡å®è·µ.md)

---

## ç›®å½•

- [Tier 3: åŒæ­¥åŸè¯­å‚è€ƒ](#tier-3-åŒæ­¥åŸè¯­å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. åŒæ­¥åŸè¯­æ¦‚è¿°](#1-åŒæ­¥åŸè¯­æ¦‚è¿°)
  - [2. çº¿ç¨‹å†…åŒæ­¥](#2-çº¿ç¨‹å†…åŒæ­¥)
    - [2.1 Mutexäº’æ–¥é”](#21-mutexäº’æ–¥é”)
    - [2.2 RwLockè¯»å†™é”](#22-rwlockè¯»å†™é”)
    - [2.3 Condvaræ¡ä»¶å˜é‡](#23-condvaræ¡ä»¶å˜é‡)
    - [2.4 Barrierå±éšœ](#24-barrierå±éšœ)
    - [2.5 Onceä¸€æ¬¡æ€§åˆå§‹åŒ–](#25-onceä¸€æ¬¡æ€§åˆå§‹åŒ–)
  - [3. åŸå­æ“ä½œ](#3-åŸå­æ“ä½œ)
  - [4. è¿›ç¨‹é—´åŒæ­¥](#4-è¿›ç¨‹é—´åŒæ­¥)
    - [4.1 æ–‡ä»¶é”](#41-æ–‡ä»¶é”)
    - [4.2 ä¿¡å·é‡](#42-ä¿¡å·é‡)
    - [4.3 å…±äº«å†…å­˜åŒæ­¥](#43-å…±äº«å†…å­˜åŒæ­¥)
  - [5. æ­»é”é¢„é˜²](#5-æ­»é”é¢„é˜²)
  - [6. æ€§èƒ½å¯¹æ¯”](#6-æ€§èƒ½å¯¹æ¯”)
  - [7. æ— é”ç¼–ç¨‹](#7-æ— é”ç¼–ç¨‹)
  - [8. å¼‚æ­¥åŒæ­¥åŸè¯­](#8-å¼‚æ­¥åŒæ­¥åŸè¯­)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [10. å®æˆ˜æ¡ˆä¾‹](#10-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹: çº¿ç¨‹å®‰å…¨çš„è¿›ç¨‹æ± ](#æ¡ˆä¾‹-çº¿ç¨‹å®‰å…¨çš„è¿›ç¨‹æ± )
  - [æ€»ç»“](#æ€»ç»“)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**åŒæ­¥åŸè¯­å‚è€ƒ (Synchronization Primitives Reference)**:

- **å®šä¹‰**: ç”¨äºåè°ƒå¤šä¸ªå¹¶å‘æ‰§è¡Œå•å…ƒï¼ˆçº¿ç¨‹/è¿›ç¨‹ï¼‰è®¿é—®å…±äº«èµ„æºçš„æœºåˆ¶çš„æŠ€æœ¯å‚è€ƒ
- **ç±»å‹**: æŠ€æœ¯å‚è€ƒæ–‡æ¡£
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹ã€ç³»ç»Ÿç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: åŒæ­¥åŸè¯­ã€äº’æ–¥é”ã€æ¡ä»¶å˜é‡ã€ä¿¡å·é‡

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **çº¿ç¨‹å†…åŒæ­¥**: Mutexã€RwLockã€Condvarã€Barrier
- **è¿›ç¨‹é—´åŒæ­¥**: æ–‡ä»¶é”ã€ä¿¡å·é‡ã€å…±äº«å†…å­˜åŒæ­¥
- **åŸå­æ“ä½œ**: åŸå­ç±»å‹å’Œæ“ä½œ
- **æ­»é”é¢„é˜²**: æ­»é”é¢„é˜²ç­–ç•¥

**æ€§èƒ½ç‰¹å¾**:

- **é”æ€§èƒ½**: ä¸åŒé”çš„æ€§èƒ½å¯¹æ¯”
- **é€‚ç”¨åœºæ™¯**: çº¿ç¨‹åŒæ­¥ã€è¿›ç¨‹åŒæ­¥ã€å…±äº«èµ„æºä¿æŠ¤

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- Mutex --[is-a]--> åŒæ­¥åŸè¯­
- RwLock --[is-a]--> åŒæ­¥åŸè¯­

**ç»„åˆå…³ç³»**:

- åŒæ­¥åŸè¯­å‚è€ƒ --[contains]--> å¤šä¸ªåŒæ­¥åŸè¯­
- å¹¶å‘ç¨‹åº --[uses]--> åŒæ­¥åŸè¯­

**ä¾èµ–å…³ç³»**:

- åŒæ­¥åŸè¯­å‚è€ƒ --[depends-on]--> æ“ä½œç³»ç»Ÿæ”¯æŒ
- å¹¶å‘å®‰å…¨ --[depends-on]--> åŒæ­¥åŸè¯­

### æ€ç»´å¯¼å›¾

```text
åŒæ­¥åŸè¯­å‚è€ƒ
â”‚
â”œâ”€â”€ çº¿ç¨‹å†…åŒæ­¥
â”‚   â”œâ”€â”€ Mutex
â”‚   â”œâ”€â”€ RwLock
â”‚   â”œâ”€â”€ Condvar
â”‚   â””â”€â”€ Barrier
â”œâ”€â”€ åŸå­æ“ä½œ
â”‚   â””â”€â”€ åŸå­ç±»å‹
â”œâ”€â”€ è¿›ç¨‹é—´åŒæ­¥
â”‚   â”œâ”€â”€ æ–‡ä»¶é”
â”‚   â””â”€â”€ ä¿¡å·é‡
â””â”€â”€ æ­»é”é¢„é˜²
    â””â”€â”€ é¢„é˜²ç­–ç•¥
```

---

## 1. åŒæ­¥åŸè¯­æ¦‚è¿°

**å®šä¹‰**: ç”¨äºåè°ƒå¤šä¸ªå¹¶å‘æ‰§è¡Œå•å…ƒï¼ˆçº¿ç¨‹/è¿›ç¨‹ï¼‰è®¿é—®å…±äº«èµ„æºçš„æœºåˆ¶ã€‚

**åˆ†ç±»**:

```text
åŒæ­¥åŸè¯­
â”œâ”€ çº¿ç¨‹å†…åŒæ­¥
â”‚  â”œâ”€ Mutex (äº’æ–¥é”)
â”‚  â”œâ”€ RwLock (è¯»å†™é”)
â”‚  â”œâ”€ Condvar (æ¡ä»¶å˜é‡)
â”‚  â”œâ”€ Barrier (å±éšœ)
â”‚  â”œâ”€ Once (ä¸€æ¬¡æ€§åˆå§‹åŒ–)
â”‚  â””â”€ Atomic (åŸå­æ“ä½œ)
â””â”€ è¿›ç¨‹é—´åŒæ­¥
   â”œâ”€ æ–‡ä»¶é” (flock/fcntl)
   â”œâ”€ ä¿¡å·é‡ (Semaphore)
   â”œâ”€ å…±äº«å†…å­˜åŒæ­¥
   â””â”€ æ¶ˆæ¯ä¼ é€’
```

**ä¸ºä»€ä¹ˆéœ€è¦åŒæ­¥**:

```rust
// âŒ æ•°æ®ç«äº‰ç¤ºä¾‹
use std::thread;

let mut counter = 0;

let handles: Vec<_> = (0..10)
    .map(|_| {
        thread::spawn(|| {
            counter += 1;  // æ•°æ®ç«äº‰ï¼
        })
    })
    .collect();

// âœ… æ­£ç¡®çš„åŒæ­¥
use std::sync::{Arc, Mutex};

let counter = Arc::new(Mutex::new(0));

let handles: Vec<_> = (0..10)
    .map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        })
    })
    .collect();
```

---

## 2. çº¿ç¨‹å†…åŒæ­¥

### 2.1 Mutexäº’æ–¥é”

**åŸç†**: ç¡®ä¿åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºã€‚

**å†…éƒ¨å®ç°**:

- **Unix**: `pthread_mutex_t` (futex)
- **Windows**: `CRITICAL_SECTION` / `SRWLOCK`
- **ä¼˜åŒ–**: è‡ªæ—‹ + ç³»ç»Ÿè°ƒç”¨æ··åˆæ¨¡å¼

**æ€§èƒ½ç‰¹æ€§**:

| ç‰¹æ€§      | è¯´æ˜                |
| :--- | :--- || é”è·å–    | ~10-50 ns (æ— ç«äº‰)  |
| é”ç«äº‰    | ~1-10 Î¼s (ç³»ç»Ÿè°ƒç”¨) |
| å…¬å¹³æ€§    | éå…¬å¹³ (FIFOä¸ä¿è¯) |
| Poisoning | è‡ªåŠ¨æ£€æµ‹panic       |

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(0));
let mut handles = vec![];

for _ in 0..10 {
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut num = data.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *data.lock().unwrap());  // 10
```

**é«˜çº§ç”¨æ³•**:

```rust
use std::sync::Mutex;

// å¸¦è¶…æ—¶çš„é”è·å–ï¼ˆéœ€parking_lotåº“ï¼‰
use parking_lot::Mutex as ParkingMutex;
use std::time::Duration;

let mutex = ParkingMutex::new(42);

if let Some(guard) = mutex.try_lock_for(Duration::from_secs(1)) {
    println!("è·å–é”æˆåŠŸ: {}", *guard);
} else {
    println!("è·å–é”è¶…æ—¶");
}

// æ­»é”æ£€æµ‹
let mutex = ParkingMutex::new(0);
let _guard1 = mutex.lock();
// let _guard2 = mutex.lock();  // æ­»é”ï¼
```

**æ€§èƒ½ä¼˜åŒ–**:

```rust
// âŒ ä½æ•ˆï¼šé”æŒæœ‰æ—¶é—´è¿‡é•¿
let data = Arc::new(Mutex::new(vec![1, 2, 3]));
{
    let mut vec = data.lock().unwrap();
    for i in 0..1000 {
        vec.push(i);  // é”æŒæœ‰æ•´ä¸ªå¾ªç¯
    }
}

// âœ… é«˜æ•ˆï¼šå‡å°‘é”æŒæœ‰æ—¶é—´
let data = Arc::new(Mutex::new(vec![1, 2, 3]));
let new_items: Vec<_> = (0..1000).collect();
{
    let mut vec = data.lock().unwrap();
    vec.extend(new_items);  // é”æŒæœ‰æ—¶é—´çŸ­
}
```

**Poisoning å¤„ç†è¯¦è§£**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(vec![1, 2, 3]));
let data_clone = Arc::clone(&data);

// çº¿ç¨‹ä¸­å‘ç”Ÿpanic
let handle = thread::spawn(move || {
    let mut vec = data_clone.lock().unwrap();
    vec.push(4);
    panic!("æ¨¡æ‹Ÿé”™è¯¯");  // é”è¿›å…¥poisonedçŠ¶æ€
});

let _ = handle.join();

// å¤„ç†poisonedé”
match data.lock() {
    Ok(guard) => {
        println!("æ­£å¸¸è·å–é”: {:?}", *guard);
    }
    Err(poisoned) => {
        // æ–¹æ³•1: æ¢å¤æ•°æ®
        let mut guard = poisoned.into_inner();
        println!("é”å·²poisonedï¼Œæ¢å¤æ•°æ®: {:?}", *guard);
        guard.clear();  // ä¿®å¤æ•°æ®

        // æ–¹æ³•2: å¿½ç•¥poisonçŠ¶æ€
        // let guard = data.lock().unwrap_or_else(|e| e.into_inner());
    }
}
```

**å…¬å¹³æ€§ä¸é¥¥é¥¿é—®é¢˜**:

```rust
use parking_lot::FairMutex;  // å…¬å¹³é”å®ç°
use std::thread;
use std::time::Duration;

let fair_mutex = Arc::new(FairMutex::new(0));

// é«˜ä¼˜å…ˆçº§çº¿ç¨‹
for i in 0..5 {
    let mutex = Arc::clone(&fair_mutex);
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(i * 10));
        let _guard = mutex.lock();
        println!("çº¿ç¨‹ {} è·å–é”", i);
    });
}

// parking_lot::FairMutex ä¿è¯ FIFO é¡ºåº
// std::sync::Mutex ä¸ä¿è¯é¡ºåºï¼ˆå¯èƒ½å¯¼è‡´é¥¥é¥¿ï¼‰
```

**Mutex vs Atomic æ€§èƒ½å¯¹æ¯”**:

```rust
use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

// Mutexç‰ˆæœ¬
let mutex_counter = Arc::new(Mutex::new(0_usize));
let start = std::time::Instant::now();
let handles: Vec<_> = (0..4).map(|_| {
    let counter = Arc::clone(&mutex_counter);
    thread::spawn(move || {
        for _ in 0..1_000_000 {
            *counter.lock().unwrap() += 1;
        }
    })
}).collect();
for h in handles { h.join().unwrap(); }
println!("Mutex: {:?}", start.elapsed());  // ~50ms

// Atomicç‰ˆæœ¬
let atomic_counter = Arc::new(AtomicUsize::new(0));
let start = std::time::Instant::now();
let handles: Vec<_> = (0..4).map(|_| {
    let counter = Arc::clone(&atomic_counter);
    thread::spawn(move || {
        for _ in 0..1_000_000 {
            counter.fetch_add(1, Ordering::Relaxed);
        }
    })
}).collect();
for h in handles { h.join().unwrap(); }
println!("Atomic: {:?}", start.elapsed());  // ~10ms (5x faster)
```

**ç»“è®º**: å¯¹äºç®€å•æ“ä½œï¼Œä¼˜å…ˆä½¿ç”¨ `Atomic`

---

### 2.2 RwLockè¯»å†™é”

**åŸç†**: å…è®¸å¤šä¸ªè¯»è€…æˆ–ä¸€ä¸ªå†™è€…ã€‚

**æ€§èƒ½ç‰¹æ€§**:

| åœºæ™¯                | RwLock | Mutex | æ€§èƒ½å¯¹æ¯”      |
| :--- | :--- | :--- | :--- || è¯»å¤šå†™å°‘ (90% read) | 10 ns  | 50 ns | **5x faster** |
| è¯»å†™å‡è¡¡ (50% read) | 60 ns  | 50 ns | 1.2x slower   |
| å†™å¤šè¯»å°‘ (10% read) | 100 ns | 50 ns | **2x slower** |

**é€‚ç”¨åœºæ™¯**:

- âœ… é…ç½®è¯»å– (è¯»å¤šå†™å°‘)
- âœ… ç¼“å­˜ç³»ç»Ÿ (è¯»>>å†™)
- âŒ é¢‘ç¹æ›´æ–°çš„è®¡æ•°å™¨ (ç”¨Atomic)
- âŒ è¯»å†™å‡è¡¡ (ç”¨Mutexæ›´ç®€å•)

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::sync::{Arc, RwLock};
use std::thread;

let data = Arc::new(RwLock::new(0));

// å¤šä¸ªè¯»è€…çº¿ç¨‹
for _ in 0..5 {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let n = data.read().unwrap();
        println!("Reader: {}", *n);
    });
}

// å•ä¸ªå†™è€…çº¿ç¨‹
let data_clone = Arc::clone(&data);
thread::spawn(move || {
    let mut n = data_clone.write().unwrap();
    *n += 1;
    println!("Writer: updated to {}", *n);
});
```

**æ€§èƒ½å¯¹æ¯”**:

| åœºæ™¯               | Mutex | RwLock  |
| :--- | :--- | :--- || çº¯è¯»ï¼ˆ10çº¿ç¨‹ï¼‰     | 1.0x  | 5.2x âœ… |
| çº¯å†™ï¼ˆ10çº¿ç¨‹ï¼‰     | 1.0x  | 0.8x    |
| è¯»å†™æ··åˆï¼ˆ9è¯»1å†™ï¼‰ | 1.0x  | 3.5x âœ… |

**é€‚ç”¨åœºæ™¯**: è¯»å¤šå†™å°‘

**å†™é¥¥é¥¿é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ**:

```rust
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

let data = Arc::new(RwLock::new(0));

// å¤§é‡è¯»è€…æŒç»­å ç”¨
for i in 0..100 {
    let data = Arc::clone(&data);
    thread::spawn(move || loop {
        let _guard = data.read().unwrap();
        thread::sleep(Duration::from_micros(10));
        // è¯»é”æŒç»­å ç”¨ï¼Œå†™è€…å¯èƒ½é¥¿æ­»
    });
}

// å†™è€…å¯èƒ½æ°¸è¿œæ— æ³•è·å¾—é”
let data_clone = Arc::clone(&data);
thread::spawn(move || {
    println!("å†™è€…ç­‰å¾…ä¸­...");
    let mut guard = data_clone.write().unwrap();
    *guard += 1;
    println!("ç»ˆäºè·å¾—å†™é”ï¼");
});

// è§£å†³æ–¹æ¡ˆ1: ä½¿ç”¨parking_lot::RwLock (å†™è€…ä¼˜å…ˆ)
use parking_lot::RwLock as ParkingRwLock;

let data = Arc::new(ParkingRwLock::new(0));
// parking_lot çš„ RwLock ä¼šç»™å†™è€…æ›´é«˜ä¼˜å…ˆçº§

// è§£å†³æ–¹æ¡ˆ2: è¯»é”è¶…æ—¶æœºåˆ¶
let data = Arc::new(ParkingRwLock::new(0));
if let Some(guard) = data.try_read_for(Duration::from_millis(100)) {
    // ä½¿ç”¨è¯»é”
} else {
    // è®©å‡ºï¼Œé¿å…é¥¥é¥¿
}
```

**é”å‡çº§ä¸é™çº§**:

```rust
use parking_lot::{RwLock, RwLockUpgradableReadGuard};

let lock = RwLock::new(vec![1, 2, 3]);

// å¯å‡çº§çš„è¯»é”
let upgradable = lock.upgradable_read();
println!("å½“å‰å€¼: {:?}", *upgradable);

// éœ€è¦ä¿®æ”¹æ—¶ï¼Œå‡çº§ä¸ºå†™é”
if upgradable.len() < 5 {
    let mut write_guard = RwLockUpgradableReadGuard::upgrade(upgradable);
    write_guard.push(4);
    write_guard.push(5);
}

// æ³¨æ„: std::sync::RwLock ä¸æ”¯æŒé”å‡çº§
// å°è¯•å‡çº§ä¼šå¯¼è‡´æ­»é”ï¼š
// let read = lock.read().unwrap();
// let write = lock.write().unwrap();  // æ­»é”ï¼
```

**RwLock vs Mutex å†³ç­–æ ‘**:

```text
è¯»å†™æ¯”ä¾‹ > 80%?
â”œâ”€ Yes â†’ RwLock (è¯»å¤šå†™å°‘)
â”‚   â”œâ”€ å†™è€…é¢‘ç¹ç­‰å¾…? â†’ parking_lot::RwLock (å†™è€…ä¼˜å…ˆ)
â”‚   â””â”€ éœ€è¦é”å‡çº§? â†’ parking_lot::RwLock (æ”¯æŒupgradable_read)
â””â”€ No â†’ Mutex (è¯»å†™å‡è¡¡æˆ–å†™å¤š)
    â”œâ”€ ç®€å•æ“ä½œ? â†’ Atomic (æ›´å¿«)
    â””â”€ å¤æ‚æ“ä½œ? â†’ Mutex
```

**å®æˆ˜æ¡ˆä¾‹: é…ç½®çƒ­æ›´æ–°**:

```rust
use std::sync::{Arc, RwLock};
use std::collections::HashMap;
use std::thread;
use std::time::Duration;

#[derive(Clone, Debug)]
struct Config {
    settings: HashMap<String, String>,
}

struct ConfigManager {
    config: Arc<RwLock<Config>>,
}

impl ConfigManager {
    fn new() -> Self {
        Self {
            config: Arc::new(RwLock::new(Config {
                settings: HashMap::new(),
            })),
        }
    }

    // é«˜é¢‘è¯»å–
    fn get(&self, key: &str) -> Option<String> {
        let config = self.config.read().unwrap();
        config.settings.get(key).cloned()
    }

    // ä½é¢‘æ›´æ–°
    fn update(&self, key: String, value: String) {
        let mut config = self.config.write().unwrap();
        config.settings.insert(key, value);
        println!("é…ç½®å·²æ›´æ–°");
    }

    // æ‰¹é‡æ›´æ–°ï¼ˆé¿å…å¤šæ¬¡è·å–å†™é”ï¼‰
    fn batch_update(&self, updates: HashMap<String, String>) {
        let mut config = self.config.write().unwrap();
        for (k, v) in updates {
            config.settings.insert(k, v);
        }
    }
}

// ä½¿ç”¨
let manager = Arc::new(ConfigManager::new());

// å¤šä¸ªè¯»è€…çº¿ç¨‹
for i in 0..10 {
    let mgr = Arc::clone(&manager);
    thread::spawn(move || {
        loop {
            if let Some(val) = mgr.get("max_connections") {
                println!("çº¿ç¨‹ {} è¯»å–é…ç½®: {}", i, val);
            }
            thread::sleep(Duration::from_millis(100));
        }
    });
}

// å•ä¸ªå†™è€…çº¿ç¨‹
let mgr = Arc::clone(&manager);
thread::spawn(move || {
    loop {
        mgr.update("max_connections".to_string(), "100".to_string());
        thread::sleep(Duration::from_secs(5));
    }
});
```

---

### 2.3 Condvaræ¡ä»¶å˜é‡

**åŸç†**: çº¿ç¨‹ç­‰å¾…ç‰¹å®šæ¡ä»¶æˆç«‹ã€‚

**ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼**:

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::collections::VecDeque;

struct Queue {
    data: Mutex<VecDeque<i32>>,
    not_empty: Condvar,
}

impl Queue {
    fn new() -> Self {
        Self {
            data: Mutex::new(VecDeque::new()),
            not_empty: Condvar::new(),
        }
    }

    fn push(&self, value: i32) {
        let mut queue = self.data.lock().unwrap();
        queue.push_back(value);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> i32 {
        let mut queue = self.data.lock().unwrap();
        while queue.is_empty() {
            queue = self.not_empty.wait(queue).unwrap();
        }
        queue.pop_front().unwrap()
    }
}

// ä½¿ç”¨
let queue = Arc::new(Queue::new());

// æ¶ˆè´¹è€…
let q = Arc::clone(&queue);
thread::spawn(move || {
    let value = q.pop();
    println!("Got: {}", value);
});

// ç”Ÿäº§è€…
queue.push(42);
```

**è™šå‡å”¤é†’å¤„ç†**:

```rust
use std::sync::{Arc, Mutex, Condvar};

let pair = Arc::new((Mutex::new(false), Condvar::new()));
let (lock, cvar) = &*pair;

// âŒ é”™è¯¯ï¼šä¸å¤„ç†è™šå‡å”¤é†’
let mut ready = lock.lock().unwrap();
cvar.wait(ready).unwrap();  // å¯èƒ½è™šå‡å”¤é†’
// è¿™é‡Œæ¡ä»¶å¯èƒ½ä»ä¸æ»¡è¶³ï¼

// âœ… æ­£ç¡®ï¼šä½¿ç”¨whileå¾ªç¯
let mut ready = lock.lock().unwrap();
while !*ready {  // é‡æ–°æ£€æŸ¥æ¡ä»¶
    ready = cvar.wait(ready).unwrap();
}
// æ¡ä»¶ç¡®ä¿æ»¡è¶³

// âœ… æ›´å¥½ï¼šä½¿ç”¨wait_while
let ready = lock.lock().unwrap();
let ready = cvar.wait_while(ready, |ready| !*ready).unwrap();
// è‡ªåŠ¨å¤„ç†è™šå‡å”¤é†’
```

**è¶…æ—¶æœºåˆ¶**:

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::time::Duration;

let pair = Arc::new((Mutex::new(false), Condvar::new()));
let (lock, cvar) = &*pair;

let mut ready = lock.lock().unwrap();
let result = cvar.wait_timeout(ready, Duration::from_secs(1)).unwrap();

if result.1.timed_out() {
    println!("ç­‰å¾…è¶…æ—¶");
} else {
    println!("æ¡ä»¶å·²æ»¡è¶³");
}

// å¸¦è¶…æ—¶çš„wait_while
let ready = lock.lock().unwrap();
let (ready, timeout_result) = cvar.wait_timeout_while(
    ready,
    Duration::from_secs(1),
    |ready| !*ready
).unwrap();

if timeout_result.timed_out() {
    println!("è¶…æ—¶ï¼Œæ¡ä»¶æœªæ»¡è¶³");
}
```

**å¤šæ¡ä»¶å˜é‡æ¨¡å¼**:

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;

struct BoundedQueue<T> {
    data: Mutex<VecDeque<T>>,
    not_empty: Condvar,
    not_full: Condvar,
    capacity: usize,
}

impl<T> BoundedQueue<T> {
    fn new(capacity: usize) -> Self {
        Self {
            data: Mutex::new(VecDeque::new()),
            not_empty: Condvar::new(),
            not_full: Condvar::new(),
            capacity,
        }
    }

    fn push(&self, value: T) {
        let mut queue = self.data.lock().unwrap();
        // é˜Ÿåˆ—æ»¡æ—¶ç­‰å¾…
        while queue.len() >= self.capacity {
            queue = self.not_full.wait(queue).unwrap();
        }
        queue.push_back(value);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut queue = self.data.lock().unwrap();
        // é˜Ÿåˆ—ç©ºæ—¶ç­‰å¾…
        while queue.is_empty() {
            queue = self.not_empty.wait(queue).unwrap();
        }
        let value = queue.pop_front().unwrap();
        self.not_full.notify_one();
        value
    }
}

// ä½¿ç”¨
let queue = Arc::new(BoundedQueue::new(10));

// ç”Ÿäº§è€…
let q = Arc::clone(&queue);
std::thread::spawn(move || {
    for i in 0..20 {
        q.push(i);  // é˜Ÿåˆ—æ»¡æ—¶è‡ªåŠ¨é˜»å¡
        println!("æ¨å…¥: {}", i);
    }
});

// æ¶ˆè´¹è€…
let q = Arc::clone(&queue);
std::thread::spawn(move || {
    for _ in 0..20 {
        let val = q.pop();  // é˜Ÿåˆ—ç©ºæ—¶è‡ªåŠ¨é˜»å¡
        println!("å¼¹å‡º: {}", val);
    }
});
```

**Condvar vs Channel æ€§èƒ½å¯¹æ¯”**:

| åœºæ™¯              | Condvar    | Channel    | æ¨è       |
| :--- | :--- | :--- | :--- || ç®€å•é€šçŸ¥          | 20 ns      | 50 ns      | Condvar âœ… |
| æ•°æ®ä¼ é€’          | éœ€æ‰‹åŠ¨å®ç° | å†…ç½®æ”¯æŒ   | Channel âœ… |
| å¤šç”Ÿäº§è€…/å¤šæ¶ˆè´¹è€… | å¤æ‚       | ç®€å•       | Channel âœ… |
| ç­‰å¾…å¤šä¸ªæ¡ä»¶      | çµæ´»       | éœ€ select! | Condvar âœ… |

---

### 2.4 Barrierå±éšœ

**åŸç†**: ç­‰å¾…æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾åŒæ­¥ç‚¹ã€‚

```rust
use std::sync::{Arc, Barrier};
use std::thread;

let barrier = Arc::new(Barrier::new(3));

for i in 0..3 {
    let barrier = Arc::clone(&barrier);
    thread::spawn(move || {
        println!("Thread {} å¼€å§‹å·¥ä½œ", i);

        // æ¨¡æ‹Ÿå·¥ä½œ
        thread::sleep(std::time::Duration::from_millis(i * 100));

        println!("Thread {} åˆ°è¾¾å±éšœ", i);
        barrier.wait();

        println!("Thread {} ç»§ç»­æ‰§è¡Œ", i);
    });
}
```

**è¾“å‡º**:

```text
Thread 0 å¼€å§‹å·¥ä½œ
Thread 1 å¼€å§‹å·¥ä½œ
Thread 2 å¼€å§‹å·¥ä½œ
Thread 0 åˆ°è¾¾å±éšœ
Thread 1 åˆ°è¾¾å±éšœ
Thread 2 åˆ°è¾¾å±éšœ
Thread 0 ç»§ç»­æ‰§è¡Œ
Thread 1 ç»§ç»­æ‰§è¡Œ
Thread 2 ç»§ç»­æ‰§è¡Œ
```

---

### 2.5 Onceä¸€æ¬¡æ€§åˆå§‹åŒ–

**åŸç†**: ç¡®ä¿åˆå§‹åŒ–ä»£ç åªæ‰§è¡Œä¸€æ¬¡ã€‚

```rust
use std::sync::Once;

static INIT: Once = Once::new();

fn expensive_initialization() {
    INIT.call_once(|| {
        println!("åˆå§‹åŒ–ï¼ˆåªæ‰§è¡Œä¸€æ¬¡ï¼‰");
        // è€—æ—¶åˆå§‹åŒ–
    });
}

// å¤šæ¬¡è°ƒç”¨ï¼Œä½†åªåˆå§‹åŒ–ä¸€æ¬¡
expensive_initialization();
expensive_initialization();
```

**LazyLock (Rust 1.80+)**:

```rust
use std::sync::LazyLock;

static CONFIG: LazyLock<Config> = LazyLock::new(|| {
    Config::load_from_file("config.toml")
});

// é¦–æ¬¡è®¿é—®æ—¶åˆå§‹åŒ–
println!("{:?}", *CONFIG);
```

---

## 3. åŸå­æ“ä½œ

**æ— é”çš„å¹¶å‘**: ä½¿ç”¨ç¡¬ä»¶æ”¯æŒçš„åŸå­æŒ‡ä»¤ã€‚

**åŸºæœ¬åŸå­ç±»å‹**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

let counter = AtomicUsize::new(0);

// åŸå­é€’å¢
counter.fetch_add(1, Ordering::SeqCst);

// åŸå­æ¯”è¾ƒå¹¶äº¤æ¢
let expected = 1;
let new_value = 2;
counter.compare_exchange(
    expected,
    new_value,
    Ordering::SeqCst,
    Ordering::SeqCst,
);
```

**å†…å­˜é¡ºåº (Ordering)**:

| é¡ºåº      | è¯´æ˜     | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
| :--- | :--- | :--- | :--- || `Relaxed` | æœ€å¼±ä¿è¯ | æœ€å¿« | è®¡æ•°å™¨   |
| `Acquire` | è¯»æ“ä½œ   | ä¸­   | è¯»é”     |
| `Release` | å†™æ“ä½œ   | ä¸­   | å†™é”     |
| `AcqRel`  | è¯»å†™æ“ä½œ | ä¸­   | åŸå­äº¤æ¢ |
| `SeqCst`  | æœ€å¼ºä¿è¯ | æœ€æ…¢ | é»˜è®¤é€‰æ‹© |

**æ€§èƒ½å¯¹æ¯”** (10Mæ“ä½œ):

| æ–¹æ³•                    | è€—æ—¶  |
| :--- | :--- || `AtomicUsize (Relaxed)` | 50ms  |
| `AtomicUsize (SeqCst)`  | 80ms  |
| `Mutex`                 | 450ms |

**é€‚ç”¨åœºæ™¯**: ç®€å•è®¡æ•°å™¨ã€æ ‡å¿—ä½ã€‚

---

## 4. è¿›ç¨‹é—´åŒæ­¥

### 4.1 æ–‡ä»¶é”

**flock/fcntlé”**:

```rust
use std::fs::OpenOptions;
use fs2::FileExt;

fn acquire_file_lock() -> std::io::Result<()> {
    let file = OpenOptions::new()
        .write(true)
        .create(true)
        .open("/tmp/myapp.lock")?;

    // å°è¯•è·å–æ’ä»–é”
    match file.try_lock_exclusive() {
        Ok(_) => {
            println!("âœ… è·å–é”æˆåŠŸ");

            // ä¸´ç•ŒåŒº
            std::thread::sleep(std::time::Duration::from_secs(5));

            file.unlock()?;
            println!("âœ… é‡Šæ”¾é”");
        }
        Err(e) => {
            println!("âŒ é”å·²è¢«å ç”¨: {}", e);
        }
    }

    Ok(())
}
```

**åº”ç”¨åœºæ™¯**: é˜²æ­¢ç¨‹åºå¤šå¼€ã€ä¿æŠ¤å…±äº«æ–‡ä»¶ã€‚

---

### 4.2 ä¿¡å·é‡

**åŸç†**: æ§åˆ¶å¯¹æœ‰é™èµ„æºçš„å¹¶å‘è®¿é—®ã€‚

**åˆ†ç±»**:

- **äºŒè¿›åˆ¶ä¿¡å·é‡** (å€¼0æˆ–1) - ç±»ä¼¼Mutex
- **è®¡æ•°ä¿¡å·é‡** (å€¼0-N) - èµ„æºæ± 

**å¼‚æ­¥ä¿¡å·é‡ (tokio::sync::Semaphore)**:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));  // æœ€å¤š3ä¸ªå¹¶å‘

    let mut handles = vec![];

    for i in 0..10 {
        let sem = Arc::clone(&semaphore);
        let handle = tokio::spawn(async move {
            let _permit = sem.acquire().await.unwrap();
            println!("Task {} æ‰§è¡Œä¸­ (å¹¶å‘: 3)", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            // permit dropæ—¶è‡ªåŠ¨é‡Šæ”¾
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }
}
```

**POSIXå‘½åä¿¡å·é‡ (è·¨è¿›ç¨‹)**:

```rust
use nix::sys::sem::*;
use nix::sys::stat::Mode;
use nix::fcntl::OFlag;

fn use_named_semaphore() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºå‘½åä¿¡å·é‡
    let name = std::ffi::CString::new("/my_semaphore")?;
    let sem = sem_open(
        &name,
        OFlag::O_CREAT,
        Mode::S_IRUSR | Mode::S_IWUSR,
        3  // åˆå§‹å€¼3
    )?;

    // ç­‰å¾…ä¿¡å·é‡ (Pæ“ä½œ)
    sem_wait(&sem)?;
    println!("è·å–ä¿¡å·é‡");

    // ä¸´ç•ŒåŒº
    std::thread::sleep(std::time::Duration::from_secs(1));

    // é‡Šæ”¾ä¿¡å·é‡ (Væ“ä½œ)
    sem_post(&sem)?;
    println!("é‡Šæ”¾ä¿¡å·é‡");

    // æ¸…ç†
    sem_close(sem)?;
    sem_unlink(&name)?;

    Ok(())
}
```

**é™æµå™¨å®ç°**:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;
use std::time::{Duration, Instant};

struct RateLimiter {
    semaphore: Arc<Semaphore>,
    rate: usize,  // æ¯ç§’å…è®¸çš„è¯·æ±‚æ•°
}

impl RateLimiter {
    fn new(rate: usize) -> Self {
        let limiter = Self {
            semaphore: Arc::new(Semaphore::new(rate)),
            rate,
        };

        // åå°ä»»åŠ¡ï¼šæ¯ç§’è¡¥å……è®¸å¯
        let sem = Arc::clone(&limiter.semaphore);
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(1)).await;
                // é‡Šæ”¾æ‰€æœ‰è®¸å¯ï¼ˆè¡¥å……åˆ°rateï¼‰
                sem.add_permits(rate);
            }
        });

        limiter
    }

    async fn acquire(&self) {
        let _permit = self.semaphore.acquire().await.unwrap();
        // permitè‡ªåŠ¨drop
    }
}

// ä½¿ç”¨é™æµå™¨
#[tokio::main]
async fn main() {
    let limiter = Arc::new(RateLimiter::new(10));  // æ¯ç§’10ä¸ªè¯·æ±‚

    for i in 0..100 {
        let limiter = Arc::clone(&limiter);
        tokio::spawn(async move {
            limiter.acquire().await;
            println!("è¯·æ±‚ {} å¤„ç†ä¸­", i);
            // å¤„ç†è¯·æ±‚
        });
    }

    tokio::time::sleep(Duration::from_secs(15)).await;
}
```

**è¿æ¥æ± å®ç° (ä¿¡å·é‡ + Arc)**:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

struct ConnectionPool<T> {
    connections: Vec<Arc<T>>,
    semaphore: Arc<Semaphore>,
}

impl<T> ConnectionPool<T> {
    fn new(connections: Vec<T>) -> Self {
        let count = connections.len();
        Self {
            connections: connections.into_iter().map(Arc::new).collect(),
            semaphore: Arc::new(Semaphore::new(count)),
        }
    }

    async fn acquire(&self) -> PoolGuard<T> {
        let permit = self.semaphore.acquire().await.unwrap();
        let conn = Arc::clone(&self.connections[0]);  // ç®€åŒ–ç‰ˆæœ¬
        PoolGuard {
            conn,
            _permit: permit,
        }
    }
}

struct PoolGuard<T> {
    conn: Arc<T>,
    _permit: tokio::sync::SemaphorePermit<'static>,
}

impl<T> std::ops::Deref for PoolGuard<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.conn
    }
}

// ä½¿ç”¨
struct DbConnection;

#[tokio::main]
async fn main() {
    let pool = Arc::new(ConnectionPool::new(vec![
        DbConnection, DbConnection, DbConnection
    ]));

    let mut handles = vec![];
    for i in 0..10 {
        let pool = Arc::clone(&pool);
        let handle = tokio::spawn(async move {
            let conn = pool.acquire().await;
            println!("è¿æ¥ {} è·å–", i);
            tokio::time::sleep(Duration::from_secs(1)).await;
            // conn dropæ—¶è‡ªåŠ¨å½’è¿˜
        });
        handles.push(handle);
    }

    for h in handles {
        h.await.unwrap();
    }
}
```

**ä¿¡å·é‡ vs Mutex**:

| ç‰¹æ€§     | Semaphore    | Mutex    |
| :--- | :--- | :--- || å¹¶å‘æ•°   | N (å¯é…ç½®)   | 1        |
| é€‚ç”¨åœºæ™¯ | èµ„æºæ± ã€é™æµ | äº’æ–¥è®¿é—® |
| æ€§èƒ½     | ä¸­ç­‰         | é«˜       |
| çµæ´»æ€§   | é«˜           | ä½       |

---

### 4.3 å…±äº«å†…å­˜åŒæ­¥

**åŸå­æ“ä½œ + å…±äº«å†…å­˜**:

```rust
use shared_memory::*;
use std::sync::atomic::{AtomicU32, Ordering};

// è¿›ç¨‹Aï¼šå†™å…¥
fn process_a() -> Result<(), Box<dyn std::error::Error>> {
    let shmem = ShmemConf::new().size(4096).create()?;

    unsafe {
        let counter = shmem.as_ptr() as *mut AtomicU32;
        (*counter).store(0, Ordering::SeqCst);

        for _ in 0..1000 {
            (*counter).fetch_add(1, Ordering::SeqCst);
        }
    }

    Ok(())
}

// è¿›ç¨‹Bï¼šè¯»å–
fn process_b() -> Result<(), Box<dyn std::error::Error>> {
    let shmem = ShmemConf::new().size(4096).open()?;

    unsafe {
        let counter = shmem.as_ptr() as *const AtomicU32;
        let value = (*counter).load(Ordering::SeqCst);
        println!("Counter: {}", value);
    }

    Ok(())
}
```

---

## 5. æ­»é”é¢„é˜²

**æ­»é”çš„4ä¸ªå¿…è¦æ¡ä»¶**:

1. **äº’æ–¥**: èµ„æºä¸å¯å…±äº«
2. **æŒæœ‰å¹¶ç­‰å¾…**: æŒæœ‰èµ„æºçš„åŒæ—¶ç­‰å¾…å…¶ä»–èµ„æº
3. **ä¸å¯æŠ¢å **: èµ„æºä¸èƒ½è¢«å¼ºåˆ¶é‡Šæ”¾
4. **å¾ªç¯ç­‰å¾…**: å½¢æˆèµ„æºè¯·æ±‚ç¯è·¯

**é¢„é˜²ç­–ç•¥**:

**1. é”é¡ºåº**:

```rust
// âŒ æ­»é”é£é™©
thread::spawn(|| {
    let _a = lock_a.lock();
    let _b = lock_b.lock();
});

thread::spawn(|| {
    let _b = lock_b.lock();  // åå‘ï¼
    let _a = lock_a.lock();
});

// âœ… æ­£ç¡®ï¼šç»Ÿä¸€é¡ºåº
thread::spawn(|| {
    let _a = lock_a.lock();
    let _b = lock_b.lock();
});

thread::spawn(|| {
    let _a = lock_a.lock();  // ç›¸åŒé¡ºåº
    let _b = lock_b.lock();
});
```

**2. try_lock**:

```rust
loop {
    let guard_a = lock_a.lock();

    if let Ok(guard_b) = lock_b.try_lock() {
        // åŒæ—¶æŒæœ‰ä¸¤ä¸ªé”
        break;
    }

    // é‡Šæ”¾lock_aï¼Œç¨åé‡è¯•
    drop(guard_a);
    std::thread::sleep(std::time::Duration::from_millis(10));
}
```

**3. è¶…æ—¶æœºåˆ¶** (éœ€parking_lot):

```rust
use parking_lot::Mutex;

let mutex = Mutex::new(0);

if let Some(guard) = mutex.try_lock_for(Duration::from_secs(5)) {
    println!("è·å–é”æˆåŠŸ");
} else {
    println!("è¶…æ—¶ï¼Œå¯èƒ½å­˜åœ¨æ­»é”");
}
```

---

## 6. æ€§èƒ½å¯¹æ¯”

**å»¶è¿Ÿå¯¹æ¯”** (å•æ¬¡æ“ä½œ):

| åŒæ­¥åŸè¯­                | å»¶è¿Ÿ   |
| :--- | :--- || `AtomicUsize (Relaxed)` | ~5 ns  |
| `AtomicUsize (SeqCst)`  | ~8 ns  |
| `Mutex`                 | ~45 ns |
| `RwLock (read)`         | ~40 ns |
| `RwLock (write)`        | ~50 ns |

**ååé‡å¯¹æ¯”** (10çº¿ç¨‹ï¼Œ100ä¸‡æ“ä½œ):

| åŒæ­¥åŸè¯­         | æ“ä½œ/ç§’    |
| :--- | :--- || `AtomicUsize`    | 22M ops/s  |
| `Mutex`          | 2.2M ops/s |
| `RwLock (90%è¯»)` | 8.5M ops/s |
| æ— åŒæ­¥(å•çº¿ç¨‹)   | 100M ops/s |

---

## 7. æ— é”ç¼–ç¨‹

**æ— é”é˜Ÿåˆ—**:

```rust
use crossbeam::queue::ArrayQueue;

let queue = ArrayQueue::new(10);

// ç”Ÿäº§è€…
queue.push(42).ok();

// æ¶ˆè´¹è€…
if let Some(value) = queue.pop() {
    println!("Got: {}", value);
}
```

**ä¼˜ç‚¹**: é«˜æ€§èƒ½ã€æ— æ­»é”é£é™©
**ç¼ºç‚¹**: å®ç°å¤æ‚ã€éš¾ä»¥è°ƒè¯•

---

## 8. å¼‚æ­¥åŒæ­¥åŸè¯­

**TokioåŒæ­¥åŸè¯­**:

```rust
use tokio::sync::{Mutex, RwLock, Semaphore};

// å¼‚æ­¥Mutex
let mutex = Mutex::new(0);
{
    let mut guard = mutex.lock().await;
    *guard += 1;
}

// å¼‚æ­¥RwLock
let lock = RwLock::new(0);
{
    let read = lock.read().await;
    println!("{}", *read);
}

// ä¿¡å·é‡
let sem = Semaphore::new(3);
let permit = sem.acquire().await.unwrap();
```

**å…³é”®åŒºåˆ«**: å¼‚æ­¥åŸè¯­åœ¨ç­‰å¾…æ—¶ä¸é˜»å¡çº¿ç¨‹ã€‚

---

## 9. æœ€ä½³å®è·µ

**1. æœ€å°åŒ–é”èŒƒå›´**:

```rust
// âŒ é”æŒæœ‰æ—¶é—´é•¿
let mut data = shared_data.lock().unwrap();
heavy_computation(&data);

// âœ… é”æŒæœ‰æ—¶é—´çŸ­
let snapshot = {
    let data = shared_data.lock().unwrap();
    data.clone()
};
heavy_computation(&snapshot);
```

**2. é€‰æ‹©åˆé€‚çš„åŒæ­¥åŸè¯­**:

- **ç®€å•è®¡æ•°å™¨**: `AtomicUsize`
- **è¯»å¤šå†™å°‘**: `RwLock`
- **ä¸€èˆ¬åœºæ™¯**: `Mutex`
- **ç”Ÿäº§è€…-æ¶ˆè´¹è€…**: `Condvar` æˆ– `channel`
- **ä¸€æ¬¡æ€§åˆå§‹åŒ–**: `Once` / `LazyLock`

**3. é¿å…åµŒå¥—é”**:

```rust
// âŒ åµŒå¥—é”ï¼ˆæ­»é”é£é™©ï¼‰
let _a = lock_a.lock();
let _b = lock_b.lock();

// âœ… å•ä¸€é”
let _combined = combined_lock.lock();
```

**4. ä½¿ç”¨RAII**:

```rust
// âœ… è‡ªåŠ¨é‡Šæ”¾é”
{
    let _guard = mutex.lock().unwrap();
    // ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
}
```

---

## 10. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹: çº¿ç¨‹å®‰å…¨çš„è¿›ç¨‹æ± 

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;
use std::process::{Child, Command};

pub struct ProcessPool {
    available: Arc<(Mutex<VecDeque<Child>>, Condvar)>,
    max_size: usize,
}

impl ProcessPool {
    pub fn new(max_size: usize) -> Self {
        Self {
            available: Arc::new((Mutex::new(VecDeque::new()), Condvar::new())),
            max_size,
        }
    }

    pub fn acquire(&self) -> Child {
        let (lock, cvar) = &*self.available;
        let mut queue = lock.lock().unwrap();

        while queue.is_empty() && queue.len() < self.max_size {
            queue = cvar.wait(queue).unwrap();
        }

        queue.pop_front().unwrap_or_else(|| {
            Command::new("worker").spawn().unwrap()
        })
    }

    pub fn release(&self, child: Child) {
        let (lock, cvar) = &*self.available;
        let mut queue = lock.lock().unwrap();
        queue.push_back(child);
        cvar.notify_one();
    }
}
```

---

## æ€»ç»“

**åŒæ­¥åŸè¯­é€‰æ‹©æŒ‡å—**:

| éœ€æ±‚         | æ¨èåŸè¯­            |
| :--- | :--- || ç®€å•è®¡æ•°å™¨   | `AtomicUsize`       |
| å…±äº«å¯å˜çŠ¶æ€ | `Mutex`             |
| è¯»å¤šå†™å°‘     | `RwLock`            |
| ç­‰å¾…æ¡ä»¶     | `Condvar`           |
| åŒæ­¥ç‚¹       | `Barrier`           |
| ä¸€æ¬¡æ€§åˆå§‹åŒ– | `Once` / `LazyLock` |
| è¿›ç¨‹é—´åŒæ­¥   | æ–‡ä»¶é” / ä¿¡å·é‡     |
| å¼‚æ­¥åœºæ™¯     | `tokio::sync::*`    |

**å…³é”®åŸåˆ™**:

1. âœ… é€‰æ‹©åˆé€‚çš„åŒæ­¥åŸè¯­
2. âœ… æœ€å°åŒ–é”èŒƒå›´
3. âœ… é¿å…åµŒå¥—é”
4. âœ… ä½¿ç”¨è¶…æ—¶æœºåˆ¶
5. âœ… ä¼˜å…ˆä½¿ç”¨æ— é”æ•°æ®ç»“æ„

---

**ä¸‹ä¸€æ­¥**: [05\_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](./05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
