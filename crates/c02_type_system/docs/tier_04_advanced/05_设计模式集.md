# 4.5 Rust ç±»å‹ç³»ç»Ÿ - è®¾è®¡æ¨¡å¼é›†

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: Rust è®¾è®¡æ¨¡å¼å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [4.5 Rust ç±»å‹ç³»ç»Ÿ - è®¾è®¡æ¨¡å¼é›†](#45-rust-ç±»å‹ç³»ç»Ÿ---è®¾è®¡æ¨¡å¼é›†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. åˆ›å»ºå‹æ¨¡å¼](#1-åˆ›å»ºå‹æ¨¡å¼)
    - [Builder æ¨¡å¼](#builder-æ¨¡å¼)
    - [Factory æ¨¡å¼](#factory-æ¨¡å¼)
  - [2. ç»“æ„å‹æ¨¡å¼](#2-ç»“æ„å‹æ¨¡å¼)
    - [Adapter æ¨¡å¼](#adapter-æ¨¡å¼)
    - [Decorator æ¨¡å¼](#decorator-æ¨¡å¼)
  - [3. è¡Œä¸ºå‹æ¨¡å¼](#3-è¡Œä¸ºå‹æ¨¡å¼)
    - [Strategy æ¨¡å¼](#strategy-æ¨¡å¼)
    - [Visitor æ¨¡å¼](#visitor-æ¨¡å¼)
    - [Iterator æ¨¡å¼](#iterator-æ¨¡å¼)
  - [4. Rust ç‰¹æœ‰æ¨¡å¼](#4-rust-ç‰¹æœ‰æ¨¡å¼)
    - [RAII (Resource Acquisition Is Initialization)](#raii-resource-acquisition-is-initialization)
    - [Typestate æ¨¡å¼](#typestate-æ¨¡å¼)
    - [Extension Trait æ¨¡å¼](#extension-trait-æ¨¡å¼)
  - [5. å¹¶å‘æ¨¡å¼](#5-å¹¶å‘æ¨¡å¼)
    - [Actor æ¨¡å¼](#actor-æ¨¡å¼)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [ç»„åˆä¼˜äºç»§æ‰¿](#ç»„åˆä¼˜äºç»§æ‰¿)
    - [ä½¿ç”¨ Trait å¯¹è±¡å®ç°å¤šæ€](#ä½¿ç”¨-trait-å¯¹è±¡å®ç°å¤šæ€)
  - [6. é”™è¯¯å¤„ç†æ¨¡å¼](#6-é”™è¯¯å¤„ç†æ¨¡å¼)
    - [Resultç»„åˆæ¨¡å¼](#resultç»„åˆæ¨¡å¼)
    - [è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [Try traitæ¨¡å¼](#try-traitæ¨¡å¼)
  - [7. å†…å­˜ç®¡ç†æ¨¡å¼](#7-å†…å­˜ç®¡ç†æ¨¡å¼)
    - [Arenaåˆ†é…æ¨¡å¼](#arenaåˆ†é…æ¨¡å¼)
    - [å¯¹è±¡æ± æ¨¡å¼](#å¯¹è±¡æ± æ¨¡å¼)
  - [8. Traitå¯¹è±¡æ¨¡å¼](#8-traitå¯¹è±¡æ¨¡å¼)
    - [åŠ¨æ€åˆ†å‘](#åŠ¨æ€åˆ†å‘)
    - [æšä¸¾åˆ†å‘ï¼ˆæ›´é«˜æ•ˆï¼‰](#æšä¸¾åˆ†å‘æ›´é«˜æ•ˆ)
  - [9. ç±»å‹å®‰å…¨APIè®¾è®¡](#9-ç±»å‹å®‰å…¨apiè®¾è®¡)
    - [å¹»å½±ç±»å‹å‚æ•°](#å¹»å½±ç±»å‹å‚æ•°)
    - [Session Types](#session-types)
  - [10. å‡½æ•°å¼æ¨¡å¼](#10-å‡½æ•°å¼æ¨¡å¼)
    - [Monad-likeæ¨¡å¼](#monad-likeæ¨¡å¼)
    - [Lensæ¨¡å¼ï¼ˆèšç„¦æ•°æ®ï¼‰](#lensæ¨¡å¼èšç„¦æ•°æ®)
  - [11. æ€»ç»“](#11-æ€»ç»“)
  - [8. å‚è€ƒèµ„æº](#8-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust è®¾è®¡æ¨¡å¼åˆ†ç±»ï¼š

| ç±»åˆ« | æ¨¡å¼ |
|------|------|
| **åˆ›å»ºå‹** | Builder, Factory, Singleton |
| **ç»“æ„å‹** | Adapter, Decorator, Newtype |
| **è¡Œä¸ºå‹** | Strategy, Visitor, Iterator |
| **Rustç‰¹æœ‰** | RAII, Typestate, Extension Traits |

---

## 1. åˆ›å»ºå‹æ¨¡å¼

### Builder æ¨¡å¼

```rust
struct Server {
    host: String,
    port: u16,
    timeout: u64,
    max_connections: usize,
}

struct ServerBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    max_connections: Option<usize>,
}

impl ServerBuilder {
    fn new() -> Self {
        ServerBuilder {
            host: None,
            port: None,
            timeout: None,
            max_connections: None,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn max_connections(mut self, max: usize) -> Self {
        self.max_connections = Some(max);
        self
    }
    
    fn build(self) -> Result<Server, String> {
        Ok(Server {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
            max_connections: self.max_connections.unwrap_or(100),
        })
    }
}

fn main() {
    let server = ServerBuilder::new()
        .host(String::from("localhost"))
        .port(3000)
        .timeout(60)
        .build()
        .unwrap();
    
    println!("Server: {}:{}", server.host, server.port);
}
```

### Factory æ¨¡å¼

```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn speak(&self) {
        println!("Meow!");
    }
}

enum AnimalType {
    Dog,
    Cat,
}

struct AnimalFactory;

impl AnimalFactory {
    fn create(animal_type: AnimalType) -> Box<dyn Animal> {
        match animal_type {
            AnimalType::Dog => Box::new(Dog),
            AnimalType::Cat => Box::new(Cat),
        }
    }
}

fn main() {
    let animals: Vec<Box<dyn Animal>> = vec![
        AnimalFactory::create(AnimalType::Dog),
        AnimalFactory::create(AnimalType::Cat),
    ];
    
    for animal in animals {
        animal.speak();
    }
}
```

---

## 2. ç»“æ„å‹æ¨¡å¼

### Adapter æ¨¡å¼

```rust
// æ—§æ¥å£
struct OldLogger;

impl OldLogger {
    fn log_message(&self, msg: &str) {
        println!("[OLD] {}", msg);
    }
}

// æ–°æ¥å£
trait Logger {
    fn log(&self, level: &str, msg: &str);
}

// Adapter
struct LoggerAdapter {
    old_logger: OldLogger,
}

impl Logger for LoggerAdapter {
    fn log(&self, level: &str, msg: &str) {
        let formatted = format!("[{}] {}", level, msg);
        self.old_logger.log_message(&formatted);
    }
}

fn main() {
    let adapter = LoggerAdapter {
        old_logger: OldLogger,
    };
    
    adapter.log("INFO", "Application started");
}
```

### Decorator æ¨¡å¼

```rust
trait Component {
    fn operation(&self) -> String;
}

struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        String::from("ConcreteComponent")
    }
}

struct DecoratorA<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorA<T> {
    fn operation(&self) -> String {
        format!("DecoratorA({})", self.component.operation())
    }
}

struct DecoratorB<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorB<T> {
    fn operation(&self) -> String {
        format!("DecoratorB({})", self.component.operation())
    }
}

fn main() {
    let component = ConcreteComponent;
    let decorated_a = DecoratorA { component };
    let decorated_b = DecoratorB { component: decorated_a };
    
    println!("{}", decorated_b.operation());
}
```

---

## 3. è¡Œä¸ºå‹æ¨¡å¼

### Strategy æ¨¡å¼

```rust
trait CompressionStrategy {
    fn compress(&self, data: &str) -> String;
}

struct ZipCompression;
struct GzipCompression;

impl CompressionStrategy for ZipCompression {
    fn compress(&self, data: &str) -> String {
        format!("ZIP: {}", data)
    }
}

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &str) -> String {
        format!("GZIP: {}", data)
    }
}

struct Compressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> Compressor<S> {
    fn new(strategy: S) -> Self {
        Compressor { strategy }
    }
    
    fn compress_data(&self, data: &str) -> String {
        self.strategy.compress(data)
    }
}

fn main() {
    let data = "Hello, World!";
    
    let zip_compressor = Compressor::new(ZipCompression);
    println!("{}", zip_compressor.compress_data(data));
    
    let gzip_compressor = Compressor::new(GzipCompression);
    println!("{}", gzip_compressor.compress_data(data));
}
```

### Visitor æ¨¡å¼

```rust
trait Visitor {
    fn visit_circle(&mut self, circle: &Circle);
    fn visit_rectangle(&mut self, rectangle: &Rectangle);
}

trait Shape {
    fn accept(&self, visitor: &mut dyn Visitor);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Circle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_circle(self);
    }
}

impl Shape for Rectangle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_rectangle(self);
    }
}

struct AreaCalculator {
    total_area: f64,
}

impl Visitor for AreaCalculator {
    fn visit_circle(&mut self, circle: &Circle) {
        self.total_area += std::f64::consts::PI * circle.radius * circle.radius;
    }
    
    fn visit_rectangle(&mut self, rectangle: &Rectangle) {
        self.total_area += rectangle.width * rectangle.height;
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    let mut calculator = AreaCalculator { total_area: 0.0 };
    
    for shape in &shapes {
        shape.accept(&mut calculator);
    }
    
    println!("Total area: {}", calculator.total_area);
}
```

### Iterator æ¨¡å¼

```rust
struct Counter {
    count: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            let current = self.count;
            self.count += 1;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);
    
    for i in counter {
        println!("{}", i);
    }
}
```

---

## 4. Rust ç‰¹æœ‰æ¨¡å¼

### RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

struct FileWriter {
    file: File,
}

impl FileWriter {
    fn new(path: &str) -> io::Result<Self> {
        Ok(FileWriter {
            file: File::create(path)?,
        })
    }
    
    fn write_line(&mut self, line: &str) -> io::Result<()> {
        writeln!(self.file, "{}", line)
    }
}

impl Drop for FileWriter {
    fn drop(&mut self) {
        println!("Closing file");
        // æ–‡ä»¶è‡ªåŠ¨å…³é—­
    }
}

fn main() -> io::Result<()> {
    let mut writer = FileWriter::new("output.txt")?;
    writer.write_line("Hello, RAII!")?;
    // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å…³é—­æ–‡ä»¶
    Ok(())
}
```

### Typestate æ¨¡å¼

```rust
use std::marker::PhantomData;

struct Locked;
struct Unlocked;

struct Safe<State> {
    content: String,
    _state: PhantomData<State>,
}

impl Safe<Locked> {
    fn new(content: String) -> Self {
        Safe {
            content,
            _state: PhantomData,
        }
    }
    
    fn unlock(self, password: &str) -> Result<Safe<Unlocked>, String> {
        if password == "secret" {
            Ok(Safe {
                content: self.content,
                _state: PhantomData,
            })
        } else {
            Err(String::from("Wrong password"))
        }
    }
}

impl Safe<Unlocked> {
    fn get_content(&self) -> &str {
        &self.content
    }
    
    fn lock(self) -> Safe<Locked> {
        Safe {
            content: self.content,
            _state: PhantomData,
        }
    }
}

fn main() {
    let safe = Safe::<Locked>::new(String::from("treasure"));
    
    match safe.unlock("secret") {
        Ok(unlocked) => {
            println!("Content: {}", unlocked.get_content());
            let _locked_again = unlocked.lock();
        }
        Err(e) => println!("Error: {}", e),
    }
}
```

### Extension Trait æ¨¡å¼

```rust
trait StringExt {
    fn is_palindrome(&self) -> bool;
    fn reverse(&self) -> String;
}

impl StringExt for str {
    fn is_palindrome(&self) -> bool {
        let chars: Vec<char> = self.chars().collect();
        chars == chars.iter().rev().copied().collect::<Vec<_>>()
    }
    
    fn reverse(&self) -> String {
        self.chars().rev().collect()
    }
}

fn main() {
    println!("'radar' is palindrome: {}", "radar".is_palindrome());
    println!("'hello' reversed: {}", "hello".reverse());
}
```

---

## 5. å¹¶å‘æ¨¡å¼

### Actor æ¨¡å¼

```rust
use std::sync::mpsc::{self, Sender, Receiver};
use std::thread;

enum Message {
    Increment,
    Decrement,
    Get(Sender<i32>),
    Stop,
}

struct Counter {
    value: i32,
    receiver: Receiver<Message>,
}

impl Counter {
    fn new(receiver: Receiver<Message>) -> Self {
        Counter {
            value: 0,
            receiver,
        }
    }
    
    fn run(&mut self) {
        while let Ok(msg) = self.receiver.recv() {
            match msg {
                Message::Increment => self.value += 1,
                Message::Decrement => self.value -= 1,
                Message::Get(sender) => {
                    sender.send(self.value).unwrap();
                }
                Message::Stop => break,
            }
        }
    }
}

fn main() {
    let (sender, receiver) = mpsc::channel();
    
    thread::spawn(move || {
        let mut counter = Counter::new(receiver);
        counter.run();
    });
    
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Decrement).unwrap();
    
    let (result_sender, result_receiver) = mpsc::channel();
    sender.send(Message::Get(result_sender)).unwrap();
    
    let value = result_receiver.recv().unwrap();
    println!("Counter value: {}", value);
    
    sender.send(Message::Stop).unwrap();
}
```

---

## 6. æœ€ä½³å®è·µ

### ç»„åˆä¼˜äºç»§æ‰¿

```rust
// âœ… ç»„åˆ
struct Engine {
    power: u32,
}

impl Engine {
    fn start(&self) {
        println!("Engine started with {} HP", self.power);
    }
}

struct Car {
    engine: Engine,
    model: String,
}

impl Car {
    fn start(&self) {
        self.engine.start();
        println!("Car {} is ready", self.model);
    }
}

fn main() {
    let car = Car {
        engine: Engine { power: 200 },
        model: String::from("Model S"),
    };
    
    car.start();
}
```

### ä½¿ç”¨ Trait å¯¹è±¡å®ç°å¤šæ€

```rust
trait Drawable {
    fn draw(&self);
}

struct Circle;
struct Square;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Drawable for Square {
    fn draw(&self) {
        println!("Drawing square");
    }
}

fn draw_all(shapes: &[Box<dyn Drawable>]) {
    for shape in shapes {
        shape.draw();
    }
}

fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle),
        Box::new(Square),
    ];
    
    draw_all(&shapes);
}
```

---

## 6. é”™è¯¯å¤„ç†æ¨¡å¼

### Resultç»„åˆæ¨¡å¼

**é“¾å¼é”™è¯¯å¤„ç†**:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username() -> Result<String, io::Error> {
    File::open("username.txt")?
        .bytes()
        .collect::<Result<Vec<_>, _>>()
        .map(|bytes| String::from_utf8_lossy(&bytes).to_string())
}

// ä½¿ç”¨
fn main() {
    match read_username() {
        Ok(name) => println!("Username: {}", name),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

### è‡ªå®šä¹‰é”™è¯¯ç±»å‹

**ä½¿ç”¨thiserror**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DataStoreError {
    #[error("Data not found: {key}")]
    NotFound { key: String },
    
    #[error("Failed to write data")]
    WriteError(#[from] std::io::Error),
    
    #[error("Invalid format: {0}")]
    InvalidFormat(String),
    
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

fn fetch_data(key: &str) -> Result<String, DataStoreError> {
    if key.is_empty() {
        return Err(DataStoreError::InvalidFormat(
            "Key cannot be empty".to_string(),
        ));
    }
    // ... å®é™…é€»è¾‘
    Err(DataStoreError::NotFound { 
        key: key.to_string() 
    })
}
```

### Try traitæ¨¡å¼

```rust
use std::ops::Try;

// è‡ªå®šä¹‰å¯Tryçš„ç±»å‹
enum MyResult<T, E> {
    Ok(T),
    Err(E),
}

impl<T, E> Try for MyResult<T, E> {
    type Output = T;
    type Residual = MyResult<std::convert::Infallible, E>;

    fn from_output(output: Self::Output) -> Self {
        MyResult::Ok(output)
    }

    fn branch(self) -> std::ops::ControlFlow<Self::Residual, Self::Output> {
        match self {
            MyResult::Ok(v) => std::ops::ControlFlow::Continue(v),
            MyResult::Err(e) => std::ops::ControlFlow::Break(MyResult::Err(e)),
        }
    }
}
```

---

## 7. å†…å­˜ç®¡ç†æ¨¡å¼

### Arenaåˆ†é…æ¨¡å¼

```rust
struct Arena {
    storage: Vec<u8>,
    offset: usize,
}

impl Arena {
    fn new(capacity: usize) -> Self {
        Arena {
            storage: Vec::with_capacity(capacity),
            offset: 0,
        }
    }
    
    fn alloc<T>(&mut self, value: T) -> &mut T {
        use std::mem;
        
        let size = mem::size_of::<T>();
        let align = mem::align_of::<T>();
        
        // å¯¹é½
        let offset = (self.offset + align - 1) & !(align - 1);
        
        unsafe {
            let ptr = self.storage.as_mut_ptr().add(offset) as *mut T;
            ptr.write(value);
            self.offset = offset + size;
            &mut *ptr
        }
    }
}

// ä½¿ç”¨
fn main() {
    let mut arena = Arena::new(1024);
    let num = arena.alloc(42);
    let string = arena.alloc(String::from("hello"));
    
    println!("{}, {}", num, string);
}
```

### å¯¹è±¡æ± æ¨¡å¼

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

struct Pool<T> {
    objects: Arc<Mutex<VecDeque<T>>>,
    factory: Box<dyn Fn() -> T + Send + Sync>,
}

impl<T> Pool<T> {
    fn new<F>(size: usize, factory: F) -> Self 
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let mut objects = VecDeque::with_capacity(size);
        for _ in 0..size {
            objects.push_back(factory());
        }
        
        Pool {
            objects: Arc::new(Mutex::new(objects)),
            factory: Box::new(factory),
        }
    }
    
    fn acquire(&self) -> PoolGuard<T> {
        let obj = self.objects
            .lock()
            .unwrap()
            .pop_front()
            .unwrap_or_else(|| (self.factory)());
            
        PoolGuard {
            obj: Some(obj),
            pool: self.objects.clone(),
        }
    }
}

struct PoolGuard<T> {
    obj: Option<T>,
    pool: Arc<Mutex<VecDeque<T>>>,
}

impl<T> Drop for PoolGuard<T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.lock().unwrap().push_back(obj);
        }
    }
}

impl<T> std::ops::Deref for PoolGuard<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
}
```

---

## 8. Traitå¯¹è±¡æ¨¡å¼

### åŠ¨æ€åˆ†å‘

```rust
trait Shape {
    fn area(&self) -> f64;
    fn perimeter(&self) -> f64;
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * std::f64::consts::PI * self.radius
    }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * (self.width + self.height)
    }
}

// å¼‚æ„é›†åˆ
fn total_area(shapes: &[Box<dyn Shape>]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 10.0 }),
        Box::new(Rectangle { width: 5.0, height: 10.0 }),
    ];
    
    println!("Total area: {}", total_area(&shapes));
}
```

### æšä¸¾åˆ†å‘ï¼ˆæ›´é«˜æ•ˆï¼‰

```rust
enum ShapeEnum {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl ShapeEnum {
    fn area(&self) -> f64 {
        match self {
            ShapeEnum::Circle { radius } => 
                std::f64::consts::PI * radius * radius,
            ShapeEnum::Rectangle { width, height } => 
                width * height,
        }
    }
}

// é™æ€åˆ†å‘ï¼Œæ›´å¿«
fn total_area_enum(shapes: &[ShapeEnum]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}
```

---

## 9. ç±»å‹å®‰å…¨APIè®¾è®¡

### å¹»å½±ç±»å‹å‚æ•°

```rust
use std::marker::PhantomData;

struct Meter;
struct Foot;

struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl Distance<Meter> {
    fn to_feet(self) -> Distance<Foot> {
        Distance {
            value: self.value * 3.28084,
            _unit: PhantomData,
        }
    }
}

impl Distance<Foot> {
    fn to_meters(self) -> Distance<Meter> {
        Distance {
            value: self.value / 3.28084,
            _unit: PhantomData,
        }
    }
}

// ç±»å‹å®‰å…¨ï¼šä¸èƒ½æ··ç”¨å•ä½
fn main() {
    let d1 = Distance::<Meter> { 
        value: 100.0, 
        _unit: PhantomData 
    };
    let d2 = d1.to_feet();
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // let sum = d1.value + d2.value;
}
```

### Session Types

```rust
use std::marker::PhantomData;

struct Authenticated;
struct Unauthenticated;

struct Session<State> {
    token: Option<String>,
    _state: PhantomData<State>,
}

impl Session<Unauthenticated> {
    fn new() -> Self {
        Session {
            token: None,
            _state: PhantomData,
        }
    }
    
    fn login(self, credentials: &str) -> Session<Authenticated> {
        // éªŒè¯é€»è¾‘
        Session {
            token: Some(credentials.to_string()),
            _state: PhantomData,
        }
    }
}

impl Session<Authenticated> {
    fn access_protected_resource(&self) -> String {
        format!("Accessing with token: {:?}", self.token)
    }
    
    fn logout(self) -> Session<Unauthenticated> {
        Session {
            token: None,
            _state: PhantomData,
        }
    }
}

fn main() {
    let session = Session::new();
    // session.access_protected_resource(); // âŒ ç¼–è¯‘é”™è¯¯
    
    let session = session.login("token123");
    println!("{}", session.access_protected_resource()); // âœ… OK
}
```

---

## 10. å‡½æ•°å¼æ¨¡å¼

### Monad-likeæ¨¡å¼

```rust
// Option monad
fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b != 0.0 {
        Some(a / b)
    } else {
        None
    }
}

fn computation() -> Option<f64> {
    safe_divide(10.0, 2.0)?
        .then(|x| safe_divide(x, 2.0))
        .flatten()
}

// è‡ªå®šä¹‰Functor
trait Functor<A> {
    type Output<B>;
    fn fmap<B, F>(self, f: F) -> Self::Output<B>
    where
        F: FnOnce(A) -> B;
}

impl<T> Functor<T> for Option<T> {
    type Output<U> = Option<U>;
    
    fn fmap<U, F>(self, f: F) -> Option<U>
    where
        F: FnOnce(T) -> U,
    {
        self.map(f)
    }
}
```

### Lensæ¨¡å¼ï¼ˆèšç„¦æ•°æ®ï¼‰

```rust
struct Lens<S, A> {
    get: Box<dyn Fn(&S) -> A>,
    set: Box<dyn Fn(&S, A) -> S>,
}

impl<S, A> Lens<S, A> {
    fn new<G, St>(get: G, set: St) -> Self
    where
        G: Fn(&S) -> A + 'static,
        St: Fn(&S, A) -> S + 'static,
    {
        Lens {
            get: Box::new(get),
            set: Box::new(set),
        }
    }
    
    fn view(&self, source: &S) -> A {
        (self.get)(source)
    }
    
    fn set_value(&self, source: &S, value: A) -> S {
        (self.set)(source, value)
    }
}

#[derive(Clone)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let name_lens = Lens::new(
        |p: &Person| p.name.clone(),
        |p, n| Person { name: n, age: p.age },
    );
    
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };
    
    let new_person = name_lens.set_value(&person, "Bob".to_string());
    println!("{}", new_person.name); // Bob
}
```

---

## 11. æ€»ç»“

**è®¾è®¡æ¨¡å¼åˆ†ç±»æ€»ç»“**:

| æ¨¡å¼ | ç”¨é€” | Rust ç‰¹è‰² |
|------|------|----------|
| **Builder** | å¤æ‚å¯¹è±¡æ„å»º | é“¾å¼è°ƒç”¨ + Result |
| **Factory** | å¯¹è±¡åˆ›å»º | Trait å¯¹è±¡ |
| **Adapter** | æ¥å£è½¬æ¢ | Newtype |
| **Decorator** | åŠŸèƒ½æ‰©å±• | æ³›å‹ç»„åˆ |
| **Strategy** | ç®—æ³•æ›¿æ¢ | Trait |
| **Visitor** | æ“ä½œåˆ†ç¦» | Trait + æšä¸¾ |
| **RAII** | èµ„æºç®¡ç† | æ‰€æœ‰æƒ + Drop |
| **Typestate** | çŠ¶æ€ç¼–ç  | PhantomData |
| **Actor** | å¹¶å‘é€šä¿¡ | Channel + Thread |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… é›¶æˆæœ¬æŠ½è±¡
2. âœ… ç¼–è¯‘æ—¶æ£€æŸ¥
3. âœ… æ˜ç¡®çš„æ‰€æœ‰æƒ
4. âœ… ç±»å‹å®‰å…¨

---

## 8. å‚è€ƒèµ„æº

**å®˜æ–¹èµ„æ–™**:

- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [The Rust Book](https://doc.rust-lang.org/book/)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)
- [4.2 é«˜çº§æ³›å‹æ¨¡å¼](./02_é«˜çº§æ³›å‹æ¨¡å¼.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚

---

**ğŸ‰ å®Œæˆè®¾è®¡æ¨¡å¼é›†å­¦ä¹ ï¼** ğŸ¦€
