# 4.5 Rust 类型系统 - 设计模式集

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: Rust 设计模式完整参考  
> **适用对象**: 中级 → 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.5 Rust 类型系统 - 设计模式集](#45-rust-类型系统---设计模式集)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 创建型模式](#1-创建型模式)
    - [Builder 模式](#builder-模式)
    - [Factory 模式](#factory-模式)
  - [2. 结构型模式](#2-结构型模式)
    - [Adapter 模式](#adapter-模式)
    - [Decorator 模式](#decorator-模式)
  - [3. 行为型模式](#3-行为型模式)
    - [Strategy 模式](#strategy-模式)
    - [Visitor 模式](#visitor-模式)
    - [Iterator 模式](#iterator-模式)
  - [4. Rust 特有模式](#4-rust-特有模式)
    - [RAII (Resource Acquisition Is Initialization)](#raii-resource-acquisition-is-initialization)
    - [Typestate 模式](#typestate-模式)
    - [Extension Trait 模式](#extension-trait-模式)
  - [5. 并发模式](#5-并发模式)
    - [Actor 模式](#actor-模式)
  - [6. 最佳实践](#6-最佳实践)
    - [组合优于继承](#组合优于继承)
    - [使用 Trait 对象实现多态](#使用-trait-对象实现多态)
  - [7. 总结](#7-总结)
  - [8. 参考资源](#8-参考资源)

---

## 🎯 概述

Rust 设计模式分类：

| 类别 | 模式 |
|------|------|
| **创建型** | Builder, Factory, Singleton |
| **结构型** | Adapter, Decorator, Newtype |
| **行为型** | Strategy, Visitor, Iterator |
| **Rust特有** | RAII, Typestate, Extension Traits |

---

## 1. 创建型模式

### Builder 模式

```rust
struct Server {
    host: String,
    port: u16,
    timeout: u64,
    max_connections: usize,
}

struct ServerBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    max_connections: Option<usize>,
}

impl ServerBuilder {
    fn new() -> Self {
        ServerBuilder {
            host: None,
            port: None,
            timeout: None,
            max_connections: None,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn max_connections(mut self, max: usize) -> Self {
        self.max_connections = Some(max);
        self
    }
    
    fn build(self) -> Result<Server, String> {
        Ok(Server {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
            max_connections: self.max_connections.unwrap_or(100),
        })
    }
}

fn main() {
    let server = ServerBuilder::new()
        .host(String::from("localhost"))
        .port(3000)
        .timeout(60)
        .build()
        .unwrap();
    
    println!("Server: {}:{}", server.host, server.port);
}
```

### Factory 模式

```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn speak(&self) {
        println!("Meow!");
    }
}

enum AnimalType {
    Dog,
    Cat,
}

struct AnimalFactory;

impl AnimalFactory {
    fn create(animal_type: AnimalType) -> Box<dyn Animal> {
        match animal_type {
            AnimalType::Dog => Box::new(Dog),
            AnimalType::Cat => Box::new(Cat),
        }
    }
}

fn main() {
    let animals: Vec<Box<dyn Animal>> = vec![
        AnimalFactory::create(AnimalType::Dog),
        AnimalFactory::create(AnimalType::Cat),
    ];
    
    for animal in animals {
        animal.speak();
    }
}
```

---

## 2. 结构型模式

### Adapter 模式

```rust
// 旧接口
struct OldLogger;

impl OldLogger {
    fn log_message(&self, msg: &str) {
        println!("[OLD] {}", msg);
    }
}

// 新接口
trait Logger {
    fn log(&self, level: &str, msg: &str);
}

// Adapter
struct LoggerAdapter {
    old_logger: OldLogger,
}

impl Logger for LoggerAdapter {
    fn log(&self, level: &str, msg: &str) {
        let formatted = format!("[{}] {}", level, msg);
        self.old_logger.log_message(&formatted);
    }
}

fn main() {
    let adapter = LoggerAdapter {
        old_logger: OldLogger,
    };
    
    adapter.log("INFO", "Application started");
}
```

### Decorator 模式

```rust
trait Component {
    fn operation(&self) -> String;
}

struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        String::from("ConcreteComponent")
    }
}

struct DecoratorA<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorA<T> {
    fn operation(&self) -> String {
        format!("DecoratorA({})", self.component.operation())
    }
}

struct DecoratorB<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorB<T> {
    fn operation(&self) -> String {
        format!("DecoratorB({})", self.component.operation())
    }
}

fn main() {
    let component = ConcreteComponent;
    let decorated_a = DecoratorA { component };
    let decorated_b = DecoratorB { component: decorated_a };
    
    println!("{}", decorated_b.operation());
}
```

---

## 3. 行为型模式

### Strategy 模式

```rust
trait CompressionStrategy {
    fn compress(&self, data: &str) -> String;
}

struct ZipCompression;
struct GzipCompression;

impl CompressionStrategy for ZipCompression {
    fn compress(&self, data: &str) -> String {
        format!("ZIP: {}", data)
    }
}

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &str) -> String {
        format!("GZIP: {}", data)
    }
}

struct Compressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> Compressor<S> {
    fn new(strategy: S) -> Self {
        Compressor { strategy }
    }
    
    fn compress_data(&self, data: &str) -> String {
        self.strategy.compress(data)
    }
}

fn main() {
    let data = "Hello, World!";
    
    let zip_compressor = Compressor::new(ZipCompression);
    println!("{}", zip_compressor.compress_data(data));
    
    let gzip_compressor = Compressor::new(GzipCompression);
    println!("{}", gzip_compressor.compress_data(data));
}
```

### Visitor 模式

```rust
trait Visitor {
    fn visit_circle(&mut self, circle: &Circle);
    fn visit_rectangle(&mut self, rectangle: &Rectangle);
}

trait Shape {
    fn accept(&self, visitor: &mut dyn Visitor);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Circle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_circle(self);
    }
}

impl Shape for Rectangle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_rectangle(self);
    }
}

struct AreaCalculator {
    total_area: f64,
}

impl Visitor for AreaCalculator {
    fn visit_circle(&mut self, circle: &Circle) {
        self.total_area += std::f64::consts::PI * circle.radius * circle.radius;
    }
    
    fn visit_rectangle(&mut self, rectangle: &Rectangle) {
        self.total_area += rectangle.width * rectangle.height;
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    let mut calculator = AreaCalculator { total_area: 0.0 };
    
    for shape in &shapes {
        shape.accept(&mut calculator);
    }
    
    println!("Total area: {}", calculator.total_area);
}
```

### Iterator 模式

```rust
struct Counter {
    count: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            let current = self.count;
            self.count += 1;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);
    
    for i in counter {
        println!("{}", i);
    }
}
```

---

## 4. Rust 特有模式

### RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

struct FileWriter {
    file: File,
}

impl FileWriter {
    fn new(path: &str) -> io::Result<Self> {
        Ok(FileWriter {
            file: File::create(path)?,
        })
    }
    
    fn write_line(&mut self, line: &str) -> io::Result<()> {
        writeln!(self.file, "{}", line)
    }
}

impl Drop for FileWriter {
    fn drop(&mut self) {
        println!("Closing file");
        // 文件自动关闭
    }
}

fn main() -> io::Result<()> {
    let mut writer = FileWriter::new("output.txt")?;
    writer.write_line("Hello, RAII!")?;
    // 离开作用域时自动关闭文件
    Ok(())
}
```

### Typestate 模式

```rust
use std::marker::PhantomData;

struct Locked;
struct Unlocked;

struct Safe<State> {
    content: String,
    _state: PhantomData<State>,
}

impl Safe<Locked> {
    fn new(content: String) -> Self {
        Safe {
            content,
            _state: PhantomData,
        }
    }
    
    fn unlock(self, password: &str) -> Result<Safe<Unlocked>, String> {
        if password == "secret" {
            Ok(Safe {
                content: self.content,
                _state: PhantomData,
            })
        } else {
            Err(String::from("Wrong password"))
        }
    }
}

impl Safe<Unlocked> {
    fn get_content(&self) -> &str {
        &self.content
    }
    
    fn lock(self) -> Safe<Locked> {
        Safe {
            content: self.content,
            _state: PhantomData,
        }
    }
}

fn main() {
    let safe = Safe::<Locked>::new(String::from("treasure"));
    
    match safe.unlock("secret") {
        Ok(unlocked) => {
            println!("Content: {}", unlocked.get_content());
            let _locked_again = unlocked.lock();
        }
        Err(e) => println!("Error: {}", e),
    }
}
```

### Extension Trait 模式

```rust
trait StringExt {
    fn is_palindrome(&self) -> bool;
    fn reverse(&self) -> String;
}

impl StringExt for str {
    fn is_palindrome(&self) -> bool {
        let chars: Vec<char> = self.chars().collect();
        chars == chars.iter().rev().copied().collect::<Vec<_>>()
    }
    
    fn reverse(&self) -> String {
        self.chars().rev().collect()
    }
}

fn main() {
    println!("'radar' is palindrome: {}", "radar".is_palindrome());
    println!("'hello' reversed: {}", "hello".reverse());
}
```

---

## 5. 并发模式

### Actor 模式

```rust
use std::sync::mpsc::{self, Sender, Receiver};
use std::thread;

enum Message {
    Increment,
    Decrement,
    Get(Sender<i32>),
    Stop,
}

struct Counter {
    value: i32,
    receiver: Receiver<Message>,
}

impl Counter {
    fn new(receiver: Receiver<Message>) -> Self {
        Counter {
            value: 0,
            receiver,
        }
    }
    
    fn run(&mut self) {
        while let Ok(msg) = self.receiver.recv() {
            match msg {
                Message::Increment => self.value += 1,
                Message::Decrement => self.value -= 1,
                Message::Get(sender) => {
                    sender.send(self.value).unwrap();
                }
                Message::Stop => break,
            }
        }
    }
}

fn main() {
    let (sender, receiver) = mpsc::channel();
    
    thread::spawn(move || {
        let mut counter = Counter::new(receiver);
        counter.run();
    });
    
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Decrement).unwrap();
    
    let (result_sender, result_receiver) = mpsc::channel();
    sender.send(Message::Get(result_sender)).unwrap();
    
    let value = result_receiver.recv().unwrap();
    println!("Counter value: {}", value);
    
    sender.send(Message::Stop).unwrap();
}
```

---

## 6. 最佳实践

### 组合优于继承

```rust
// ✅ 组合
struct Engine {
    power: u32,
}

impl Engine {
    fn start(&self) {
        println!("Engine started with {} HP", self.power);
    }
}

struct Car {
    engine: Engine,
    model: String,
}

impl Car {
    fn start(&self) {
        self.engine.start();
        println!("Car {} is ready", self.model);
    }
}

fn main() {
    let car = Car {
        engine: Engine { power: 200 },
        model: String::from("Model S"),
    };
    
    car.start();
}
```

### 使用 Trait 对象实现多态

```rust
trait Drawable {
    fn draw(&self);
}

struct Circle;
struct Square;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Drawable for Square {
    fn draw(&self) {
        println!("Drawing square");
    }
}

fn draw_all(shapes: &[Box<dyn Drawable>]) {
    for shape in shapes {
        shape.draw();
    }
}

fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle),
        Box::new(Square),
    ];
    
    draw_all(&shapes);
}
```

---

## 7. 总结

**设计模式分类总结**:

| 模式 | 用途 | Rust 特色 |
|------|------|----------|
| **Builder** | 复杂对象构建 | 链式调用 + Result |
| **Factory** | 对象创建 | Trait 对象 |
| **Adapter** | 接口转换 | Newtype |
| **Decorator** | 功能扩展 | 泛型组合 |
| **Strategy** | 算法替换 | Trait |
| **Visitor** | 操作分离 | Trait + 枚举 |
| **RAII** | 资源管理 | 所有权 + Drop |
| **Typestate** | 状态编码 | PhantomData |
| **Actor** | 并发通信 | Channel + Thread |

**核心原则**:

1. ✅ 零成本抽象
2. ✅ 编译时检查
3. ✅ 明确的所有权
4. ✅ 类型安全

---

## 8. 参考资源

**官方资料**:

- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [The Rust Book](https://doc.rust-lang.org/book/)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
- [4.2 高级泛型模式](./02_高级泛型模式.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🎉 完成设计模式集学习！** 🦀
