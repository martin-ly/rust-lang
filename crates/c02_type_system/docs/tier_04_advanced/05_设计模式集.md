# 4.5 Rust 类型系统 - 设计模式集

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: Rust 设计模式完整参考  
> **适用对象**: 中级 → 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.5 Rust 类型系统 - 设计模式集](#45-rust-类型系统---设计模式集)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 创建型模式](#1-创建型模式)
    - [Builder 模式](#builder-模式)
    - [Factory 模式](#factory-模式)
  - [2. 结构型模式](#2-结构型模式)
    - [Adapter 模式](#adapter-模式)
    - [Decorator 模式](#decorator-模式)
  - [3. 行为型模式](#3-行为型模式)
    - [Strategy 模式](#strategy-模式)
    - [Visitor 模式](#visitor-模式)
    - [Iterator 模式](#iterator-模式)
  - [4. Rust 特有模式](#4-rust-特有模式)
    - [RAII (Resource Acquisition Is Initialization)](#raii-resource-acquisition-is-initialization)
    - [Typestate 模式](#typestate-模式)
    - [Extension Trait 模式](#extension-trait-模式)
  - [5. 并发模式](#5-并发模式)
    - [Actor 模式](#actor-模式)
  - [6. 最佳实践](#6-最佳实践)
    - [组合优于继承](#组合优于继承)
    - [使用 Trait 对象实现多态](#使用-trait-对象实现多态)
  - [6. 错误处理模式](#6-错误处理模式)
    - [Result组合模式](#result组合模式)
    - [自定义错误类型](#自定义错误类型)
    - [Try trait模式](#try-trait模式)
  - [7. 内存管理模式](#7-内存管理模式)
    - [Arena分配模式](#arena分配模式)
    - [对象池模式](#对象池模式)
  - [8. Trait对象模式](#8-trait对象模式)
    - [动态分发](#动态分发)
    - [枚举分发（更高效）](#枚举分发更高效)
  - [9. 类型安全API设计](#9-类型安全api设计)
    - [幻影类型参数](#幻影类型参数)
    - [Session Types](#session-types)
  - [10. 函数式模式](#10-函数式模式)
    - [Monad-like模式](#monad-like模式)
    - [Lens模式（聚焦数据）](#lens模式聚焦数据)
  - [11. 总结](#11-总结)
  - [8. 参考资源](#8-参考资源)

---

## 🎯 概述

Rust 设计模式分类：

| 类别 | 模式 |
|------|------|
| **创建型** | Builder, Factory, Singleton |
| **结构型** | Adapter, Decorator, Newtype |
| **行为型** | Strategy, Visitor, Iterator |
| **Rust特有** | RAII, Typestate, Extension Traits |

---

## 1. 创建型模式

### Builder 模式

```rust
struct Server {
    host: String,
    port: u16,
    timeout: u64,
    max_connections: usize,
}

struct ServerBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    max_connections: Option<usize>,
}

impl ServerBuilder {
    fn new() -> Self {
        ServerBuilder {
            host: None,
            port: None,
            timeout: None,
            max_connections: None,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn max_connections(mut self, max: usize) -> Self {
        self.max_connections = Some(max);
        self
    }
    
    fn build(self) -> Result<Server, String> {
        Ok(Server {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
            max_connections: self.max_connections.unwrap_or(100),
        })
    }
}

fn main() {
    let server = ServerBuilder::new()
        .host(String::from("localhost"))
        .port(3000)
        .timeout(60)
        .build()
        .unwrap();
    
    println!("Server: {}:{}", server.host, server.port);
}
```

### Factory 模式

```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn speak(&self) {
        println!("Meow!");
    }
}

enum AnimalType {
    Dog,
    Cat,
}

struct AnimalFactory;

impl AnimalFactory {
    fn create(animal_type: AnimalType) -> Box<dyn Animal> {
        match animal_type {
            AnimalType::Dog => Box::new(Dog),
            AnimalType::Cat => Box::new(Cat),
        }
    }
}

fn main() {
    let animals: Vec<Box<dyn Animal>> = vec![
        AnimalFactory::create(AnimalType::Dog),
        AnimalFactory::create(AnimalType::Cat),
    ];
    
    for animal in animals {
        animal.speak();
    }
}
```

---

## 2. 结构型模式

### Adapter 模式

```rust
// 旧接口
struct OldLogger;

impl OldLogger {
    fn log_message(&self, msg: &str) {
        println!("[OLD] {}", msg);
    }
}

// 新接口
trait Logger {
    fn log(&self, level: &str, msg: &str);
}

// Adapter
struct LoggerAdapter {
    old_logger: OldLogger,
}

impl Logger for LoggerAdapter {
    fn log(&self, level: &str, msg: &str) {
        let formatted = format!("[{}] {}", level, msg);
        self.old_logger.log_message(&formatted);
    }
}

fn main() {
    let adapter = LoggerAdapter {
        old_logger: OldLogger,
    };
    
    adapter.log("INFO", "Application started");
}
```

### Decorator 模式

```rust
trait Component {
    fn operation(&self) -> String;
}

struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        String::from("ConcreteComponent")
    }
}

struct DecoratorA<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorA<T> {
    fn operation(&self) -> String {
        format!("DecoratorA({})", self.component.operation())
    }
}

struct DecoratorB<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorB<T> {
    fn operation(&self) -> String {
        format!("DecoratorB({})", self.component.operation())
    }
}

fn main() {
    let component = ConcreteComponent;
    let decorated_a = DecoratorA { component };
    let decorated_b = DecoratorB { component: decorated_a };
    
    println!("{}", decorated_b.operation());
}
```

---

## 3. 行为型模式

### Strategy 模式

```rust
trait CompressionStrategy {
    fn compress(&self, data: &str) -> String;
}

struct ZipCompression;
struct GzipCompression;

impl CompressionStrategy for ZipCompression {
    fn compress(&self, data: &str) -> String {
        format!("ZIP: {}", data)
    }
}

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &str) -> String {
        format!("GZIP: {}", data)
    }
}

struct Compressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> Compressor<S> {
    fn new(strategy: S) -> Self {
        Compressor { strategy }
    }
    
    fn compress_data(&self, data: &str) -> String {
        self.strategy.compress(data)
    }
}

fn main() {
    let data = "Hello, World!";
    
    let zip_compressor = Compressor::new(ZipCompression);
    println!("{}", zip_compressor.compress_data(data));
    
    let gzip_compressor = Compressor::new(GzipCompression);
    println!("{}", gzip_compressor.compress_data(data));
}
```

### Visitor 模式

```rust
trait Visitor {
    fn visit_circle(&mut self, circle: &Circle);
    fn visit_rectangle(&mut self, rectangle: &Rectangle);
}

trait Shape {
    fn accept(&self, visitor: &mut dyn Visitor);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Circle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_circle(self);
    }
}

impl Shape for Rectangle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_rectangle(self);
    }
}

struct AreaCalculator {
    total_area: f64,
}

impl Visitor for AreaCalculator {
    fn visit_circle(&mut self, circle: &Circle) {
        self.total_area += std::f64::consts::PI * circle.radius * circle.radius;
    }
    
    fn visit_rectangle(&mut self, rectangle: &Rectangle) {
        self.total_area += rectangle.width * rectangle.height;
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    let mut calculator = AreaCalculator { total_area: 0.0 };
    
    for shape in &shapes {
        shape.accept(&mut calculator);
    }
    
    println!("Total area: {}", calculator.total_area);
}
```

### Iterator 模式

```rust
struct Counter {
    count: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            let current = self.count;
            self.count += 1;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);
    
    for i in counter {
        println!("{}", i);
    }
}
```

---

## 4. Rust 特有模式

### RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

struct FileWriter {
    file: File,
}

impl FileWriter {
    fn new(path: &str) -> io::Result<Self> {
        Ok(FileWriter {
            file: File::create(path)?,
        })
    }
    
    fn write_line(&mut self, line: &str) -> io::Result<()> {
        writeln!(self.file, "{}", line)
    }
}

impl Drop for FileWriter {
    fn drop(&mut self) {
        println!("Closing file");
        // 文件自动关闭
    }
}

fn main() -> io::Result<()> {
    let mut writer = FileWriter::new("output.txt")?;
    writer.write_line("Hello, RAII!")?;
    // 离开作用域时自动关闭文件
    Ok(())
}
```

### Typestate 模式

```rust
use std::marker::PhantomData;

struct Locked;
struct Unlocked;

struct Safe<State> {
    content: String,
    _state: PhantomData<State>,
}

impl Safe<Locked> {
    fn new(content: String) -> Self {
        Safe {
            content,
            _state: PhantomData,
        }
    }
    
    fn unlock(self, password: &str) -> Result<Safe<Unlocked>, String> {
        if password == "secret" {
            Ok(Safe {
                content: self.content,
                _state: PhantomData,
            })
        } else {
            Err(String::from("Wrong password"))
        }
    }
}

impl Safe<Unlocked> {
    fn get_content(&self) -> &str {
        &self.content
    }
    
    fn lock(self) -> Safe<Locked> {
        Safe {
            content: self.content,
            _state: PhantomData,
        }
    }
}

fn main() {
    let safe = Safe::<Locked>::new(String::from("treasure"));
    
    match safe.unlock("secret") {
        Ok(unlocked) => {
            println!("Content: {}", unlocked.get_content());
            let _locked_again = unlocked.lock();
        }
        Err(e) => println!("Error: {}", e),
    }
}
```

### Extension Trait 模式

```rust
trait StringExt {
    fn is_palindrome(&self) -> bool;
    fn reverse(&self) -> String;
}

impl StringExt for str {
    fn is_palindrome(&self) -> bool {
        let chars: Vec<char> = self.chars().collect();
        chars == chars.iter().rev().copied().collect::<Vec<_>>()
    }
    
    fn reverse(&self) -> String {
        self.chars().rev().collect()
    }
}

fn main() {
    println!("'radar' is palindrome: {}", "radar".is_palindrome());
    println!("'hello' reversed: {}", "hello".reverse());
}
```

---

## 5. 并发模式

### Actor 模式

```rust
use std::sync::mpsc::{self, Sender, Receiver};
use std::thread;

enum Message {
    Increment,
    Decrement,
    Get(Sender<i32>),
    Stop,
}

struct Counter {
    value: i32,
    receiver: Receiver<Message>,
}

impl Counter {
    fn new(receiver: Receiver<Message>) -> Self {
        Counter {
            value: 0,
            receiver,
        }
    }
    
    fn run(&mut self) {
        while let Ok(msg) = self.receiver.recv() {
            match msg {
                Message::Increment => self.value += 1,
                Message::Decrement => self.value -= 1,
                Message::Get(sender) => {
                    sender.send(self.value).unwrap();
                }
                Message::Stop => break,
            }
        }
    }
}

fn main() {
    let (sender, receiver) = mpsc::channel();
    
    thread::spawn(move || {
        let mut counter = Counter::new(receiver);
        counter.run();
    });
    
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Decrement).unwrap();
    
    let (result_sender, result_receiver) = mpsc::channel();
    sender.send(Message::Get(result_sender)).unwrap();
    
    let value = result_receiver.recv().unwrap();
    println!("Counter value: {}", value);
    
    sender.send(Message::Stop).unwrap();
}
```

---

## 6. 最佳实践

### 组合优于继承

```rust
// ✅ 组合
struct Engine {
    power: u32,
}

impl Engine {
    fn start(&self) {
        println!("Engine started with {} HP", self.power);
    }
}

struct Car {
    engine: Engine,
    model: String,
}

impl Car {
    fn start(&self) {
        self.engine.start();
        println!("Car {} is ready", self.model);
    }
}

fn main() {
    let car = Car {
        engine: Engine { power: 200 },
        model: String::from("Model S"),
    };
    
    car.start();
}
```

### 使用 Trait 对象实现多态

```rust
trait Drawable {
    fn draw(&self);
}

struct Circle;
struct Square;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Drawable for Square {
    fn draw(&self) {
        println!("Drawing square");
    }
}

fn draw_all(shapes: &[Box<dyn Drawable>]) {
    for shape in shapes {
        shape.draw();
    }
}

fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle),
        Box::new(Square),
    ];
    
    draw_all(&shapes);
}
```

---

## 6. 错误处理模式

### Result组合模式

**链式错误处理**:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username() -> Result<String, io::Error> {
    File::open("username.txt")?
        .bytes()
        .collect::<Result<Vec<_>, _>>()
        .map(|bytes| String::from_utf8_lossy(&bytes).to_string())
}

// 使用
fn main() {
    match read_username() {
        Ok(name) => println!("Username: {}", name),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

### 自定义错误类型

**使用thiserror**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DataStoreError {
    #[error("Data not found: {key}")]
    NotFound { key: String },
    
    #[error("Failed to write data")]
    WriteError(#[from] std::io::Error),
    
    #[error("Invalid format: {0}")]
    InvalidFormat(String),
    
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

fn fetch_data(key: &str) -> Result<String, DataStoreError> {
    if key.is_empty() {
        return Err(DataStoreError::InvalidFormat(
            "Key cannot be empty".to_string(),
        ));
    }
    // ... 实际逻辑
    Err(DataStoreError::NotFound { 
        key: key.to_string() 
    })
}
```

### Try trait模式

```rust
use std::ops::Try;

// 自定义可Try的类型
enum MyResult<T, E> {
    Ok(T),
    Err(E),
}

impl<T, E> Try for MyResult<T, E> {
    type Output = T;
    type Residual = MyResult<std::convert::Infallible, E>;

    fn from_output(output: Self::Output) -> Self {
        MyResult::Ok(output)
    }

    fn branch(self) -> std::ops::ControlFlow<Self::Residual, Self::Output> {
        match self {
            MyResult::Ok(v) => std::ops::ControlFlow::Continue(v),
            MyResult::Err(e) => std::ops::ControlFlow::Break(MyResult::Err(e)),
        }
    }
}
```

---

## 7. 内存管理模式

### Arena分配模式

```rust
struct Arena {
    storage: Vec<u8>,
    offset: usize,
}

impl Arena {
    fn new(capacity: usize) -> Self {
        Arena {
            storage: Vec::with_capacity(capacity),
            offset: 0,
        }
    }
    
    fn alloc<T>(&mut self, value: T) -> &mut T {
        use std::mem;
        
        let size = mem::size_of::<T>();
        let align = mem::align_of::<T>();
        
        // 对齐
        let offset = (self.offset + align - 1) & !(align - 1);
        
        unsafe {
            let ptr = self.storage.as_mut_ptr().add(offset) as *mut T;
            ptr.write(value);
            self.offset = offset + size;
            &mut *ptr
        }
    }
}

// 使用
fn main() {
    let mut arena = Arena::new(1024);
    let num = arena.alloc(42);
    let string = arena.alloc(String::from("hello"));
    
    println!("{}, {}", num, string);
}
```

### 对象池模式

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

struct Pool<T> {
    objects: Arc<Mutex<VecDeque<T>>>,
    factory: Box<dyn Fn() -> T + Send + Sync>,
}

impl<T> Pool<T> {
    fn new<F>(size: usize, factory: F) -> Self 
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let mut objects = VecDeque::with_capacity(size);
        for _ in 0..size {
            objects.push_back(factory());
        }
        
        Pool {
            objects: Arc::new(Mutex::new(objects)),
            factory: Box::new(factory),
        }
    }
    
    fn acquire(&self) -> PoolGuard<T> {
        let obj = self.objects
            .lock()
            .unwrap()
            .pop_front()
            .unwrap_or_else(|| (self.factory)());
            
        PoolGuard {
            obj: Some(obj),
            pool: self.objects.clone(),
        }
    }
}

struct PoolGuard<T> {
    obj: Option<T>,
    pool: Arc<Mutex<VecDeque<T>>>,
}

impl<T> Drop for PoolGuard<T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.lock().unwrap().push_back(obj);
        }
    }
}

impl<T> std::ops::Deref for PoolGuard<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
}
```

---

## 8. Trait对象模式

### 动态分发

```rust
trait Shape {
    fn area(&self) -> f64;
    fn perimeter(&self) -> f64;
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * std::f64::consts::PI * self.radius
    }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * (self.width + self.height)
    }
}

// 异构集合
fn total_area(shapes: &[Box<dyn Shape>]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 10.0 }),
        Box::new(Rectangle { width: 5.0, height: 10.0 }),
    ];
    
    println!("Total area: {}", total_area(&shapes));
}
```

### 枚举分发（更高效）

```rust
enum ShapeEnum {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl ShapeEnum {
    fn area(&self) -> f64 {
        match self {
            ShapeEnum::Circle { radius } => 
                std::f64::consts::PI * radius * radius,
            ShapeEnum::Rectangle { width, height } => 
                width * height,
        }
    }
}

// 静态分发，更快
fn total_area_enum(shapes: &[ShapeEnum]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}
```

---

## 9. 类型安全API设计

### 幻影类型参数

```rust
use std::marker::PhantomData;

struct Meter;
struct Foot;

struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl Distance<Meter> {
    fn to_feet(self) -> Distance<Foot> {
        Distance {
            value: self.value * 3.28084,
            _unit: PhantomData,
        }
    }
}

impl Distance<Foot> {
    fn to_meters(self) -> Distance<Meter> {
        Distance {
            value: self.value / 3.28084,
            _unit: PhantomData,
        }
    }
}

// 类型安全：不能混用单位
fn main() {
    let d1 = Distance::<Meter> { 
        value: 100.0, 
        _unit: PhantomData 
    };
    let d2 = d1.to_feet();
    
    // ❌ 编译错误：类型不匹配
    // let sum = d1.value + d2.value;
}
```

### Session Types

```rust
use std::marker::PhantomData;

struct Authenticated;
struct Unauthenticated;

struct Session<State> {
    token: Option<String>,
    _state: PhantomData<State>,
}

impl Session<Unauthenticated> {
    fn new() -> Self {
        Session {
            token: None,
            _state: PhantomData,
        }
    }
    
    fn login(self, credentials: &str) -> Session<Authenticated> {
        // 验证逻辑
        Session {
            token: Some(credentials.to_string()),
            _state: PhantomData,
        }
    }
}

impl Session<Authenticated> {
    fn access_protected_resource(&self) -> String {
        format!("Accessing with token: {:?}", self.token)
    }
    
    fn logout(self) -> Session<Unauthenticated> {
        Session {
            token: None,
            _state: PhantomData,
        }
    }
}

fn main() {
    let session = Session::new();
    // session.access_protected_resource(); // ❌ 编译错误
    
    let session = session.login("token123");
    println!("{}", session.access_protected_resource()); // ✅ OK
}
```

---

## 10. 函数式模式

### Monad-like模式

```rust
// Option monad
fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b != 0.0 {
        Some(a / b)
    } else {
        None
    }
}

fn computation() -> Option<f64> {
    safe_divide(10.0, 2.0)?
        .then(|x| safe_divide(x, 2.0))
        .flatten()
}

// 自定义Functor
trait Functor<A> {
    type Output<B>;
    fn fmap<B, F>(self, f: F) -> Self::Output<B>
    where
        F: FnOnce(A) -> B;
}

impl<T> Functor<T> for Option<T> {
    type Output<U> = Option<U>;
    
    fn fmap<U, F>(self, f: F) -> Option<U>
    where
        F: FnOnce(T) -> U,
    {
        self.map(f)
    }
}
```

### Lens模式（聚焦数据）

```rust
struct Lens<S, A> {
    get: Box<dyn Fn(&S) -> A>,
    set: Box<dyn Fn(&S, A) -> S>,
}

impl<S, A> Lens<S, A> {
    fn new<G, St>(get: G, set: St) -> Self
    where
        G: Fn(&S) -> A + 'static,
        St: Fn(&S, A) -> S + 'static,
    {
        Lens {
            get: Box::new(get),
            set: Box::new(set),
        }
    }
    
    fn view(&self, source: &S) -> A {
        (self.get)(source)
    }
    
    fn set_value(&self, source: &S, value: A) -> S {
        (self.set)(source, value)
    }
}

#[derive(Clone)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let name_lens = Lens::new(
        |p: &Person| p.name.clone(),
        |p, n| Person { name: n, age: p.age },
    );
    
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };
    
    let new_person = name_lens.set_value(&person, "Bob".to_string());
    println!("{}", new_person.name); // Bob
}
```

---

## 11. 总结

**设计模式分类总结**:

| 模式 | 用途 | Rust 特色 |
|------|------|----------|
| **Builder** | 复杂对象构建 | 链式调用 + Result |
| **Factory** | 对象创建 | Trait 对象 |
| **Adapter** | 接口转换 | Newtype |
| **Decorator** | 功能扩展 | 泛型组合 |
| **Strategy** | 算法替换 | Trait |
| **Visitor** | 操作分离 | Trait + 枚举 |
| **RAII** | 资源管理 | 所有权 + Drop |
| **Typestate** | 状态编码 | PhantomData |
| **Actor** | 并发通信 | Channel + Thread |

**核心原则**:

1. ✅ 零成本抽象
2. ✅ 编译时检查
3. ✅ 明确的所有权
4. ✅ 类型安全

---

## 8. 参考资源

**官方资料**:

- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [The Rust Book](https://doc.rust-lang.org/book/)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
- [4.2 高级泛型模式](./02_高级泛型模式.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🎉 完成设计模式集学习！** 🦀
