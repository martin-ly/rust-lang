# 4.5 Rust ç±»å‹ç³»ç»Ÿ - è®¾è®¡æ¨¡å¼é›†

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: Rust è®¾è®¡æ¨¡å¼å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [4.5 Rust ç±»å‹ç³»ç»Ÿ - è®¾è®¡æ¨¡å¼é›†](#45-rust-ç±»å‹ç³»ç»Ÿ---è®¾è®¡æ¨¡å¼é›†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. åˆ›å»ºå‹æ¨¡å¼](#1-åˆ›å»ºå‹æ¨¡å¼)
    - [Builder æ¨¡å¼](#builder-æ¨¡å¼)
    - [Factory æ¨¡å¼](#factory-æ¨¡å¼)
  - [2. ç»“æ„å‹æ¨¡å¼](#2-ç»“æ„å‹æ¨¡å¼)
    - [Adapter æ¨¡å¼](#adapter-æ¨¡å¼)
    - [Decorator æ¨¡å¼](#decorator-æ¨¡å¼)
  - [3. è¡Œä¸ºå‹æ¨¡å¼](#3-è¡Œä¸ºå‹æ¨¡å¼)
    - [Strategy æ¨¡å¼](#strategy-æ¨¡å¼)
    - [Visitor æ¨¡å¼](#visitor-æ¨¡å¼)
    - [Iterator æ¨¡å¼](#iterator-æ¨¡å¼)
  - [4. Rust ç‰¹æœ‰æ¨¡å¼](#4-rust-ç‰¹æœ‰æ¨¡å¼)
    - [RAII (Resource Acquisition Is Initialization)](#raii-resource-acquisition-is-initialization)
    - [Typestate æ¨¡å¼](#typestate-æ¨¡å¼)
    - [Extension Trait æ¨¡å¼](#extension-trait-æ¨¡å¼)
  - [5. å¹¶å‘æ¨¡å¼](#5-å¹¶å‘æ¨¡å¼)
    - [Actor æ¨¡å¼](#actor-æ¨¡å¼)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [ç»„åˆä¼˜äºç»§æ‰¿](#ç»„åˆä¼˜äºç»§æ‰¿)
    - [ä½¿ç”¨ Trait å¯¹è±¡å®ç°å¤šæ€](#ä½¿ç”¨-trait-å¯¹è±¡å®ç°å¤šæ€)
  - [6. é”™è¯¯å¤„ç†æ¨¡å¼](#6-é”™è¯¯å¤„ç†æ¨¡å¼)
    - [Resultç»„åˆæ¨¡å¼](#resultç»„åˆæ¨¡å¼)
    - [è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [Try traitæ¨¡å¼](#try-traitæ¨¡å¼)
  - [7. å†…å­˜ç®¡ç†æ¨¡å¼](#7-å†…å­˜ç®¡ç†æ¨¡å¼)
    - [Arenaåˆ†é…æ¨¡å¼](#arenaåˆ†é…æ¨¡å¼)
    - [å¯¹è±¡æ± æ¨¡å¼](#å¯¹è±¡æ± æ¨¡å¼)
  - [8. Traitå¯¹è±¡æ¨¡å¼](#8-traitå¯¹è±¡æ¨¡å¼)
    - [åŠ¨æ€åˆ†å‘](#åŠ¨æ€åˆ†å‘)
    - [æšä¸¾åˆ†å‘ï¼ˆæ›´é«˜æ•ˆï¼‰](#æšä¸¾åˆ†å‘æ›´é«˜æ•ˆ)
  - [9. ç±»å‹å®‰å…¨APIè®¾è®¡](#9-ç±»å‹å®‰å…¨apiè®¾è®¡)
    - [å¹»å½±ç±»å‹å‚æ•°](#å¹»å½±ç±»å‹å‚æ•°)
    - [Session Types](#session-types)
  - [10. å‡½æ•°å¼æ¨¡å¼](#10-å‡½æ•°å¼æ¨¡å¼)
    - [Monad-likeæ¨¡å¼](#monad-likeæ¨¡å¼)
    - [Lensæ¨¡å¼ï¼ˆèšç„¦æ•°æ®ï¼‰](#lensæ¨¡å¼èšç„¦æ•°æ®)
    - [10.1 é«˜çº§å‡½æ•°å¼æ¨¡å¼ï¼šApplicativeä¸Monadæ·±åŒ–](#101-é«˜çº§å‡½æ•°å¼æ¨¡å¼applicativeä¸monadæ·±åŒ–)
    - [10.2 Free Monadæ¨¡å¼](#102-free-monadæ¨¡å¼)
    - [10.3 Zipperæ¨¡å¼ï¼ˆé«˜æ•ˆå¯¼èˆªï¼‰](#103-zipperæ¨¡å¼é«˜æ•ˆå¯¼èˆª)
    - [10.4 Opticsæ¨¡å¼ï¼ˆPrismä¸Isoï¼‰](#104-opticsæ¨¡å¼prismä¸iso)
    - [10.5 Reader Monadæ¨¡å¼ï¼ˆä¾èµ–æ³¨å…¥ï¼‰](#105-reader-monadæ¨¡å¼ä¾èµ–æ³¨å…¥)
    - [10.6 Writer Monadæ¨¡å¼ï¼ˆæ—¥å¿—ç´¯ç§¯ï¼‰](#106-writer-monadæ¨¡å¼æ—¥å¿—ç´¯ç§¯)
    - [10.7 State Monadæ¨¡å¼ï¼ˆçŠ¶æ€è½¬æ¢ï¼‰](#107-state-monadæ¨¡å¼çŠ¶æ€è½¬æ¢)
    - [10.8 å¹¶å‘æ¨¡å¼æ·±åŒ–](#108-å¹¶å‘æ¨¡å¼æ·±åŒ–)
    - [10.9 æ€§èƒ½ä¼˜åŒ–æ¨¡å¼é›†](#109-æ€§èƒ½ä¼˜åŒ–æ¨¡å¼é›†)
  - [11. æ€»ç»“](#11-æ€»ç»“)
  - [8. å‚è€ƒèµ„æº](#8-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust è®¾è®¡æ¨¡å¼åˆ†ç±»ï¼š

| ç±»åˆ« | æ¨¡å¼ |
|------|------|
| **åˆ›å»ºå‹** | Builder, Factory, Singleton |
| **ç»“æ„å‹** | Adapter, Decorator, Newtype |
| **è¡Œä¸ºå‹** | Strategy, Visitor, Iterator |
| **Rustç‰¹æœ‰** | RAII, Typestate, Extension Traits |

---

## 1. åˆ›å»ºå‹æ¨¡å¼

### Builder æ¨¡å¼

```rust
struct Server {
    host: String,
    port: u16,
    timeout: u64,
    max_connections: usize,
}

struct ServerBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    max_connections: Option<usize>,
}

impl ServerBuilder {
    fn new() -> Self {
        ServerBuilder {
            host: None,
            port: None,
            timeout: None,
            max_connections: None,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn max_connections(mut self, max: usize) -> Self {
        self.max_connections = Some(max);
        self
    }
    
    fn build(self) -> Result<Server, String> {
        Ok(Server {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
            max_connections: self.max_connections.unwrap_or(100),
        })
    }
}

fn main() {
    let server = ServerBuilder::new()
        .host(String::from("localhost"))
        .port(3000)
        .timeout(60)
        .build()
        .unwrap();
    
    println!("Server: {}:{}", server.host, server.port);
}
```

### Factory æ¨¡å¼

```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn speak(&self) {
        println!("Meow!");
    }
}

enum AnimalType {
    Dog,
    Cat,
}

struct AnimalFactory;

impl AnimalFactory {
    fn create(animal_type: AnimalType) -> Box<dyn Animal> {
        match animal_type {
            AnimalType::Dog => Box::new(Dog),
            AnimalType::Cat => Box::new(Cat),
        }
    }
}

fn main() {
    let animals: Vec<Box<dyn Animal>> = vec![
        AnimalFactory::create(AnimalType::Dog),
        AnimalFactory::create(AnimalType::Cat),
    ];
    
    for animal in animals {
        animal.speak();
    }
}
```

---

## 2. ç»“æ„å‹æ¨¡å¼

### Adapter æ¨¡å¼

```rust
// æ—§æ¥å£
struct OldLogger;

impl OldLogger {
    fn log_message(&self, msg: &str) {
        println!("[OLD] {}", msg);
    }
}

// æ–°æ¥å£
trait Logger {
    fn log(&self, level: &str, msg: &str);
}

// Adapter
struct LoggerAdapter {
    old_logger: OldLogger,
}

impl Logger for LoggerAdapter {
    fn log(&self, level: &str, msg: &str) {
        let formatted = format!("[{}] {}", level, msg);
        self.old_logger.log_message(&formatted);
    }
}

fn main() {
    let adapter = LoggerAdapter {
        old_logger: OldLogger,
    };
    
    adapter.log("INFO", "Application started");
}
```

### Decorator æ¨¡å¼

```rust
trait Component {
    fn operation(&self) -> String;
}

struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        String::from("ConcreteComponent")
    }
}

struct DecoratorA<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorA<T> {
    fn operation(&self) -> String {
        format!("DecoratorA({})", self.component.operation())
    }
}

struct DecoratorB<T: Component> {
    component: T,
}

impl<T: Component> Component for DecoratorB<T> {
    fn operation(&self) -> String {
        format!("DecoratorB({})", self.component.operation())
    }
}

fn main() {
    let component = ConcreteComponent;
    let decorated_a = DecoratorA { component };
    let decorated_b = DecoratorB { component: decorated_a };
    
    println!("{}", decorated_b.operation());
}
```

---

## 3. è¡Œä¸ºå‹æ¨¡å¼

### Strategy æ¨¡å¼

```rust
trait CompressionStrategy {
    fn compress(&self, data: &str) -> String;
}

struct ZipCompression;
struct GzipCompression;

impl CompressionStrategy for ZipCompression {
    fn compress(&self, data: &str) -> String {
        format!("ZIP: {}", data)
    }
}

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &str) -> String {
        format!("GZIP: {}", data)
    }
}

struct Compressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> Compressor<S> {
    fn new(strategy: S) -> Self {
        Compressor { strategy }
    }
    
    fn compress_data(&self, data: &str) -> String {
        self.strategy.compress(data)
    }
}

fn main() {
    let data = "Hello, World!";
    
    let zip_compressor = Compressor::new(ZipCompression);
    println!("{}", zip_compressor.compress_data(data));
    
    let gzip_compressor = Compressor::new(GzipCompression);
    println!("{}", gzip_compressor.compress_data(data));
}
```

### Visitor æ¨¡å¼

```rust
trait Visitor {
    fn visit_circle(&mut self, circle: &Circle);
    fn visit_rectangle(&mut self, rectangle: &Rectangle);
}

trait Shape {
    fn accept(&self, visitor: &mut dyn Visitor);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Circle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_circle(self);
    }
}

impl Shape for Rectangle {
    fn accept(&self, visitor: &mut dyn Visitor) {
        visitor.visit_rectangle(self);
    }
}

struct AreaCalculator {
    total_area: f64,
}

impl Visitor for AreaCalculator {
    fn visit_circle(&mut self, circle: &Circle) {
        self.total_area += std::f64::consts::PI * circle.radius * circle.radius;
    }
    
    fn visit_rectangle(&mut self, rectangle: &Rectangle) {
        self.total_area += rectangle.width * rectangle.height;
    }
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    let mut calculator = AreaCalculator { total_area: 0.0 };
    
    for shape in &shapes {
        shape.accept(&mut calculator);
    }
    
    println!("Total area: {}", calculator.total_area);
}
```

### Iterator æ¨¡å¼

```rust
struct Counter {
    count: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            let current = self.count;
            self.count += 1;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);
    
    for i in counter {
        println!("{}", i);
    }
}
```

---

## 4. Rust ç‰¹æœ‰æ¨¡å¼

### RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

struct FileWriter {
    file: File,
}

impl FileWriter {
    fn new(path: &str) -> io::Result<Self> {
        Ok(FileWriter {
            file: File::create(path)?,
        })
    }
    
    fn write_line(&mut self, line: &str) -> io::Result<()> {
        writeln!(self.file, "{}", line)
    }
}

impl Drop for FileWriter {
    fn drop(&mut self) {
        println!("Closing file");
        // æ–‡ä»¶è‡ªåŠ¨å…³é—­
    }
}

fn main() -> io::Result<()> {
    let mut writer = FileWriter::new("output.txt")?;
    writer.write_line("Hello, RAII!")?;
    // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å…³é—­æ–‡ä»¶
    Ok(())
}
```

### Typestate æ¨¡å¼

```rust
use std::marker::PhantomData;

struct Locked;
struct Unlocked;

struct Safe<State> {
    content: String,
    _state: PhantomData<State>,
}

impl Safe<Locked> {
    fn new(content: String) -> Self {
        Safe {
            content,
            _state: PhantomData,
        }
    }
    
    fn unlock(self, password: &str) -> Result<Safe<Unlocked>, String> {
        if password == "secret" {
            Ok(Safe {
                content: self.content,
                _state: PhantomData,
            })
        } else {
            Err(String::from("Wrong password"))
        }
    }
}

impl Safe<Unlocked> {
    fn get_content(&self) -> &str {
        &self.content
    }
    
    fn lock(self) -> Safe<Locked> {
        Safe {
            content: self.content,
            _state: PhantomData,
        }
    }
}

fn main() {
    let safe = Safe::<Locked>::new(String::from("treasure"));
    
    match safe.unlock("secret") {
        Ok(unlocked) => {
            println!("Content: {}", unlocked.get_content());
            let _locked_again = unlocked.lock();
        }
        Err(e) => println!("Error: {}", e),
    }
}
```

### Extension Trait æ¨¡å¼

```rust
trait StringExt {
    fn is_palindrome(&self) -> bool;
    fn reverse(&self) -> String;
}

impl StringExt for str {
    fn is_palindrome(&self) -> bool {
        let chars: Vec<char> = self.chars().collect();
        chars == chars.iter().rev().copied().collect::<Vec<_>>()
    }
    
    fn reverse(&self) -> String {
        self.chars().rev().collect()
    }
}

fn main() {
    println!("'radar' is palindrome: {}", "radar".is_palindrome());
    println!("'hello' reversed: {}", "hello".reverse());
}
```

---

## 5. å¹¶å‘æ¨¡å¼

### Actor æ¨¡å¼

```rust
use std::sync::mpsc::{self, Sender, Receiver};
use std::thread;

enum Message {
    Increment,
    Decrement,
    Get(Sender<i32>),
    Stop,
}

struct Counter {
    value: i32,
    receiver: Receiver<Message>,
}

impl Counter {
    fn new(receiver: Receiver<Message>) -> Self {
        Counter {
            value: 0,
            receiver,
        }
    }
    
    fn run(&mut self) {
        while let Ok(msg) = self.receiver.recv() {
            match msg {
                Message::Increment => self.value += 1,
                Message::Decrement => self.value -= 1,
                Message::Get(sender) => {
                    sender.send(self.value).unwrap();
                }
                Message::Stop => break,
            }
        }
    }
}

fn main() {
    let (sender, receiver) = mpsc::channel();
    
    thread::spawn(move || {
        let mut counter = Counter::new(receiver);
        counter.run();
    });
    
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Increment).unwrap();
    sender.send(Message::Decrement).unwrap();
    
    let (result_sender, result_receiver) = mpsc::channel();
    sender.send(Message::Get(result_sender)).unwrap();
    
    let value = result_receiver.recv().unwrap();
    println!("Counter value: {}", value);
    
    sender.send(Message::Stop).unwrap();
}
```

---

## 6. æœ€ä½³å®è·µ

### ç»„åˆä¼˜äºç»§æ‰¿

```rust
// âœ… ç»„åˆ
struct Engine {
    power: u32,
}

impl Engine {
    fn start(&self) {
        println!("Engine started with {} HP", self.power);
    }
}

struct Car {
    engine: Engine,
    model: String,
}

impl Car {
    fn start(&self) {
        self.engine.start();
        println!("Car {} is ready", self.model);
    }
}

fn main() {
    let car = Car {
        engine: Engine { power: 200 },
        model: String::from("Model S"),
    };
    
    car.start();
}
```

### ä½¿ç”¨ Trait å¯¹è±¡å®ç°å¤šæ€

```rust
trait Drawable {
    fn draw(&self);
}

struct Circle;
struct Square;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Drawable for Square {
    fn draw(&self) {
        println!("Drawing square");
    }
}

fn draw_all(shapes: &[Box<dyn Drawable>]) {
    for shape in shapes {
        shape.draw();
    }
}

fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle),
        Box::new(Square),
    ];
    
    draw_all(&shapes);
}
```

---

## 6. é”™è¯¯å¤„ç†æ¨¡å¼

### Resultç»„åˆæ¨¡å¼

**é“¾å¼é”™è¯¯å¤„ç†**:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username() -> Result<String, io::Error> {
    File::open("username.txt")?
        .bytes()
        .collect::<Result<Vec<_>, _>>()
        .map(|bytes| String::from_utf8_lossy(&bytes).to_string())
}

// ä½¿ç”¨
fn main() {
    match read_username() {
        Ok(name) => println!("Username: {}", name),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

### è‡ªå®šä¹‰é”™è¯¯ç±»å‹

**ä½¿ç”¨thiserror**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DataStoreError {
    #[error("Data not found: {key}")]
    NotFound { key: String },
    
    #[error("Failed to write data")]
    WriteError(#[from] std::io::Error),
    
    #[error("Invalid format: {0}")]
    InvalidFormat(String),
    
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

fn fetch_data(key: &str) -> Result<String, DataStoreError> {
    if key.is_empty() {
        return Err(DataStoreError::InvalidFormat(
            "Key cannot be empty".to_string(),
        ));
    }
    // ... å®é™…é€»è¾‘
    Err(DataStoreError::NotFound { 
        key: key.to_string() 
    })
}
```

### Try traitæ¨¡å¼

```rust
use std::ops::Try;

// è‡ªå®šä¹‰å¯Tryçš„ç±»å‹
enum MyResult<T, E> {
    Ok(T),
    Err(E),
}

impl<T, E> Try for MyResult<T, E> {
    type Output = T;
    type Residual = MyResult<std::convert::Infallible, E>;

    fn from_output(output: Self::Output) -> Self {
        MyResult::Ok(output)
    }

    fn branch(self) -> std::ops::ControlFlow<Self::Residual, Self::Output> {
        match self {
            MyResult::Ok(v) => std::ops::ControlFlow::Continue(v),
            MyResult::Err(e) => std::ops::ControlFlow::Break(MyResult::Err(e)),
        }
    }
}
```

---

## 7. å†…å­˜ç®¡ç†æ¨¡å¼

### Arenaåˆ†é…æ¨¡å¼

```rust
struct Arena {
    storage: Vec<u8>,
    offset: usize,
}

impl Arena {
    fn new(capacity: usize) -> Self {
        Arena {
            storage: Vec::with_capacity(capacity),
            offset: 0,
        }
    }
    
    fn alloc<T>(&mut self, value: T) -> &mut T {
        use std::mem;
        
        let size = mem::size_of::<T>();
        let align = mem::align_of::<T>();
        
        // å¯¹é½
        let offset = (self.offset + align - 1) & !(align - 1);
        
        unsafe {
            let ptr = self.storage.as_mut_ptr().add(offset) as *mut T;
            ptr.write(value);
            self.offset = offset + size;
            &mut *ptr
        }
    }
}

// ä½¿ç”¨
fn main() {
    let mut arena = Arena::new(1024);
    let num = arena.alloc(42);
    let string = arena.alloc(String::from("hello"));
    
    println!("{}, {}", num, string);
}
```

### å¯¹è±¡æ± æ¨¡å¼

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

struct Pool<T> {
    objects: Arc<Mutex<VecDeque<T>>>,
    factory: Box<dyn Fn() -> T + Send + Sync>,
}

impl<T> Pool<T> {
    fn new<F>(size: usize, factory: F) -> Self 
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let mut objects = VecDeque::with_capacity(size);
        for _ in 0..size {
            objects.push_back(factory());
        }
        
        Pool {
            objects: Arc::new(Mutex::new(objects)),
            factory: Box::new(factory),
        }
    }
    
    fn acquire(&self) -> PoolGuard<T> {
        let obj = self.objects
            .lock()
            .unwrap()
            .pop_front()
            .unwrap_or_else(|| (self.factory)());
            
        PoolGuard {
            obj: Some(obj),
            pool: self.objects.clone(),
        }
    }
}

struct PoolGuard<T> {
    obj: Option<T>,
    pool: Arc<Mutex<VecDeque<T>>>,
}

impl<T> Drop for PoolGuard<T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.lock().unwrap().push_back(obj);
        }
    }
}

impl<T> std::ops::Deref for PoolGuard<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
}
```

---

## 8. Traitå¯¹è±¡æ¨¡å¼

### åŠ¨æ€åˆ†å‘

```rust
trait Shape {
    fn area(&self) -> f64;
    fn perimeter(&self) -> f64;
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * std::f64::consts::PI * self.radius
    }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * (self.width + self.height)
    }
}

// å¼‚æ„é›†åˆ
fn total_area(shapes: &[Box<dyn Shape>]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}

fn main() {
    let shapes: Vec<Box<dyn Shape>> = vec![
        Box::new(Circle { radius: 10.0 }),
        Box::new(Rectangle { width: 5.0, height: 10.0 }),
    ];
    
    println!("Total area: {}", total_area(&shapes));
}
```

### æšä¸¾åˆ†å‘ï¼ˆæ›´é«˜æ•ˆï¼‰

```rust
enum ShapeEnum {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl ShapeEnum {
    fn area(&self) -> f64 {
        match self {
            ShapeEnum::Circle { radius } => 
                std::f64::consts::PI * radius * radius,
            ShapeEnum::Rectangle { width, height } => 
                width * height,
        }
    }
}

// é™æ€åˆ†å‘ï¼Œæ›´å¿«
fn total_area_enum(shapes: &[ShapeEnum]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}
```

---

## 9. ç±»å‹å®‰å…¨APIè®¾è®¡

### å¹»å½±ç±»å‹å‚æ•°

```rust
use std::marker::PhantomData;

struct Meter;
struct Foot;

struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl Distance<Meter> {
    fn to_feet(self) -> Distance<Foot> {
        Distance {
            value: self.value * 3.28084,
            _unit: PhantomData,
        }
    }
}

impl Distance<Foot> {
    fn to_meters(self) -> Distance<Meter> {
        Distance {
            value: self.value / 3.28084,
            _unit: PhantomData,
        }
    }
}

// ç±»å‹å®‰å…¨ï¼šä¸èƒ½æ··ç”¨å•ä½
fn main() {
    let d1 = Distance::<Meter> { 
        value: 100.0, 
        _unit: PhantomData 
    };
    let d2 = d1.to_feet();
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // let sum = d1.value + d2.value;
}
```

### Session Types

```rust
use std::marker::PhantomData;

struct Authenticated;
struct Unauthenticated;

struct Session<State> {
    token: Option<String>,
    _state: PhantomData<State>,
}

impl Session<Unauthenticated> {
    fn new() -> Self {
        Session {
            token: None,
            _state: PhantomData,
        }
    }
    
    fn login(self, credentials: &str) -> Session<Authenticated> {
        // éªŒè¯é€»è¾‘
        Session {
            token: Some(credentials.to_string()),
            _state: PhantomData,
        }
    }
}

impl Session<Authenticated> {
    fn access_protected_resource(&self) -> String {
        format!("Accessing with token: {:?}", self.token)
    }
    
    fn logout(self) -> Session<Unauthenticated> {
        Session {
            token: None,
            _state: PhantomData,
        }
    }
}

fn main() {
    let session = Session::new();
    // session.access_protected_resource(); // âŒ ç¼–è¯‘é”™è¯¯
    
    let session = session.login("token123");
    println!("{}", session.access_protected_resource()); // âœ… OK
}
```

---

## 10. å‡½æ•°å¼æ¨¡å¼

### Monad-likeæ¨¡å¼

```rust
// Option monad
fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b != 0.0 {
        Some(a / b)
    } else {
        None
    }
}

fn computation() -> Option<f64> {
    safe_divide(10.0, 2.0)?
        .then(|x| safe_divide(x, 2.0))
        .flatten()
}

// è‡ªå®šä¹‰Functor
trait Functor<A> {
    type Output<B>;
    fn fmap<B, F>(self, f: F) -> Self::Output<B>
    where
        F: FnOnce(A) -> B;
}

impl<T> Functor<T> for Option<T> {
    type Output<U> = Option<U>;
    
    fn fmap<U, F>(self, f: F) -> Option<U>
    where
        F: FnOnce(T) -> U,
    {
        self.map(f)
    }
}
```

### Lensæ¨¡å¼ï¼ˆèšç„¦æ•°æ®ï¼‰

```rust
struct Lens<S, A> {
    get: Box<dyn Fn(&S) -> A>,
    set: Box<dyn Fn(&S, A) -> S>,
}

impl<S, A> Lens<S, A> {
    fn new<G, St>(get: G, set: St) -> Self
    where
        G: Fn(&S) -> A + 'static,
        St: Fn(&S, A) -> S + 'static,
    {
        Lens {
            get: Box::new(get),
            set: Box::new(set),
        }
    }
    
    fn view(&self, source: &S) -> A {
        (self.get)(source)
    }
    
    fn set_value(&self, source: &S, value: A) -> S {
        (self.set)(source, value)
    }
}

#[derive(Clone)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let name_lens = Lens::new(
        |p: &Person| p.name.clone(),
        |p, n| Person { name: n, age: p.age },
    );
    
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };
    
    let new_person = name_lens.set_value(&person, "Bob".to_string());
    println!("{}", new_person.name); // Bob
}
```

### 10.1 é«˜çº§å‡½æ•°å¼æ¨¡å¼ï¼šApplicativeä¸Monadæ·±åŒ–

**Applicative Functoræ¨¡å¼**:

```rust
trait Applicative<T>: Functor<T> {
    fn pure(value: T) -> Self;
    fn ap<U, F>(self, f: Self::Output<F>) -> Self::Output<U>
    where
        F: FnOnce(T) -> U;
}

// Optionçš„Applicativeå®ç°
impl<T> Applicative<T> for Option<T> {
    fn pure(value: T) -> Self {
        Some(value)
    }
    
    fn ap<U, F>(self, f: Option<F>) -> Option<U>
    where
        F: FnOnce(T) -> U,
    {
        match (self, f) {
            (Some(x), Some(func)) => Some(func(x)),
            _ => None,
        }
    }
}

// å®æˆ˜æ¡ˆä¾‹ï¼šè¡¨å•éªŒè¯
struct ValidationResult<T> {
    value: Option<T>,
    errors: Vec<String>,
}

impl<T> ValidationResult<T> {
    fn valid(value: T) -> Self {
        ValidationResult {
            value: Some(value),
            errors: vec![],
        }
    }
    
    fn invalid(error: String) -> Self {
        ValidationResult {
            value: None,
            errors: vec![error],
        }
    }
    
    fn combine<U, F>(self, other: ValidationResult<U>, f: F) -> ValidationResult<(T, U)>
    where
        F: FnOnce(T, U) -> (T, U),
    {
        let mut errors = self.errors;
        errors.extend(other.errors);
        
        match (self.value, other.value) {
            (Some(a), Some(b)) => ValidationResult {
                value: Some(f(a, b)),
                errors,
            },
            _ => ValidationResult {
                value: None,
                errors,
            },
        }
    }
}
```

**Monad Transformersæ¨¡å¼**:

```rust
// OptionT Monad Transformer
struct OptionT<M, T> {
    inner: M,
    _phantom: std::marker::PhantomData<T>,
}

impl<M, T> OptionT<M, Option<T>> {
    fn new(inner: M) -> Self {
        OptionT {
            inner,
            _phantom: std::marker::PhantomData,
        }
    }
    
    fn run(self) -> M {
        self.inner
    }
}

// å®æˆ˜æ¡ˆä¾‹ï¼šå¼‚æ­¥ + Optionç»„åˆ
use std::future::Future;

async fn fetch_user_id(username: &str) -> Option<u64> {
    // æ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®åº“æŸ¥è¯¢
    if username == "admin" {
        Some(1)
    } else {
        None
    }
}

async fn fetch_user_profile(user_id: u64) -> Option<String> {
    // æ¨¡æ‹Ÿå¼‚æ­¥APIè°ƒç”¨
    Some(format!("Profile of user {}", user_id))
}

async fn get_user_profile_by_name(username: &str) -> Option<String> {
    let user_id = fetch_user_id(username).await?;
    fetch_user_profile(user_id).await
}
```

### 10.2 Free Monadæ¨¡å¼

**Free Monadå®ç°**:

```rust
use std::marker::PhantomData;

enum Free<F, A> {
    Pure(A),
    Free(F),
}

// DSLç¤ºä¾‹ï¼šæ–‡ä»¶æ“ä½œ
enum FileOp<Next> {
    Read { path: String, next: Box<dyn FnOnce(String) -> Next> },
    Write { path: String, content: String, next: Next },
}

type FileProgram<A> = Free<FileOp<FileProgram<A>>, A>;

impl<A> FileProgram<A> {
    fn read(path: String) -> FileProgram<String> {
        Free::Free(FileOp::Read {
            path,
            next: Box::new(|content| Free::Pure(content)),
        })
    }
    
    fn write(path: String, content: String) -> FileProgram<()> {
        Free::Free(FileOp::Write {
            path,
            content,
            next: Free::Pure(()),
        })
    }
}

// è§£é‡Šå™¨æ¨¡å¼
trait Interpreter<F, A> {
    fn interpret(&self, program: Free<F, A>) -> A;
}

// å®é™…çš„æ–‡ä»¶ç³»ç»Ÿè§£é‡Šå™¨
struct RealFileSystem;

impl Interpreter<FileOp<FileProgram<String>>, String> for RealFileSystem {
    fn interpret(&self, program: Free<FileOp<FileProgram<String>>, String>) -> String {
        match program {
            Free::Pure(a) => a,
            Free::Free(FileOp::Read { path, next }) => {
                let content = std::fs::read_to_string(&path).unwrap_or_default();
                self.interpret(next(content))
            },
            Free::Free(FileOp::Write { path, content, next }) => {
                std::fs::write(&path, &content).ok();
                self.interpret(next)
            },
        }
    }
}
```

### 10.3 Zipperæ¨¡å¼ï¼ˆé«˜æ•ˆå¯¼èˆªï¼‰

**Zipperæ•°æ®ç»“æ„**:

```rust
// æ ‘çš„Zipper
#[derive(Clone, Debug)]
enum Tree<T> {
    Leaf(T),
    Node(Box<Tree<T>>, Box<Tree<T>>),
}

#[derive(Clone, Debug)]
enum Crumb<T> {
    LeftCrumb(Box<Tree<T>>),
    RightCrumb(Box<Tree<T>>),
}

#[derive(Clone, Debug)]
struct Zipper<T> {
    focus: Box<Tree<T>>,
    breadcrumbs: Vec<Crumb<T>>,
}

impl<T: Clone> Zipper<T> {
    fn new(tree: Tree<T>) -> Self {
        Zipper {
            focus: Box::new(tree),
            breadcrumbs: vec![],
        }
    }
    
    fn go_left(mut self) -> Option<Self> {
        match *self.focus {
            Tree::Node(left, right) => {
                self.breadcrumbs.push(Crumb::LeftCrumb(right));
                self.focus = left;
                Some(self)
            },
            _ => None,
        }
    }
    
    fn go_right(mut self) -> Option<Self> {
        match *self.focus {
            Tree::Node(left, right) => {
                self.breadcrumbs.push(Crumb::RightCrumb(left));
                self.focus = right;
                Some(self)
            },
            _ => None,
        }
    }
    
    fn go_up(mut self) -> Option<Self> {
        match self.breadcrumbs.pop() {
            Some(Crumb::LeftCrumb(right)) => {
                let new_focus = Tree::Node(self.focus, right);
                self.focus = Box::new(new_focus);
                Some(self)
            },
            Some(Crumb::RightCrumb(left)) => {
                let new_focus = Tree::Node(left, self.focus);
                self.focus = Box::new(new_focus);
                Some(self)
            },
            None => None,
        }
    }
    
    fn modify<F>(mut self, f: F) -> Self
    where
        F: FnOnce(Tree<T>) -> Tree<T>,
    {
        self.focus = Box::new(f(*self.focus));
        self
    }
}
```

### 10.4 Opticsæ¨¡å¼ï¼ˆPrismä¸Isoï¼‰

**Prismæ¨¡å¼ï¼ˆå¤„ç†Sumç±»å‹ï¼‰**:

```rust
struct Prism<S, A> {
    preview: Box<dyn Fn(&S) -> Option<A>>,
    review: Box<dyn Fn(A) -> S>,
}

impl<S, A> Prism<S, A> {
    fn new<P, R>(preview: P, review: R) -> Self
    where
        P: Fn(&S) -> Option<A> + 'static,
        R: Fn(A) -> S + 'static,
    {
        Prism {
            preview: Box::new(preview),
            review: Box::new(review),
        }
    }
    
    fn preview(&self, source: &S) -> Option<A> {
        (self.preview)(source)
    }
    
    fn review(&self, value: A) -> S {
        (self.review)(value)
    }
}

// ç¤ºä¾‹ï¼šOption Prism
fn some_prism<T: Clone + 'static>() -> Prism<Option<T>, T> {
    Prism::new(
        |opt: &Option<T>| opt.clone(),
        |val: T| Some(val),
    )
}
```

**Isoæ¨¡å¼ï¼ˆåŒæ„ï¼‰**:

```rust
struct Iso<S, A> {
    from: Box<dyn Fn(S) -> A>,
    to: Box<dyn Fn(A) -> S>,
}

impl<S, A> Iso<S, A> {
    fn new<F, T>(from: F, to: T) -> Self
    where
        F: Fn(S) -> A + 'static,
        T: Fn(A) -> S + 'static,
    {
        Iso {
            from: Box::new(from),
            to: Box::new(to),
        }
    }
    
    fn from(&self, source: S) -> A {
        (self.from)(source)
    }
    
    fn to(&self, value: A) -> S {
        (self.to)(value)
    }
    
    fn reverse(self) -> Iso<A, S> {
        Iso {
            from: self.to,
            to: self.from,
        }
    }
}

// ç¤ºä¾‹ï¼šCelsius â†” Fahrenheit
fn celsius_fahrenheit_iso() -> Iso<f64, f64> {
    Iso::new(
        |c| c * 1.8 + 32.0,  // Celsius -> Fahrenheit
        |f| (f - 32.0) / 1.8, // Fahrenheit -> Celsius
    )
}
```

### 10.5 Reader Monadæ¨¡å¼ï¼ˆä¾èµ–æ³¨å…¥ï¼‰

**Reader Monadå®ç°**:

```rust
struct Reader<R, A> {
    run: Box<dyn Fn(R) -> A>,
}

impl<R: Clone + 'static, A: 'static> Reader<R, A> {
    fn new<F>(f: F) -> Self
    where
        F: Fn(R) -> A + 'static,
    {
        Reader {
            run: Box::new(f),
        }
    }
    
    fn run(&self, env: R) -> A {
        (self.run)(env)
    }
    
    fn map<B, F>(self, f: F) -> Reader<R, B>
    where
        F: Fn(A) -> B + 'static,
    {
        Reader::new(move |env: R| {
            let a = (self.run)(env);
            f(a)
        })
    }
    
    fn flat_map<B, F>(self, f: F) -> Reader<R, B>
    where
        F: Fn(A) -> Reader<R, B> + 'static,
    {
        Reader::new(move |env: R| {
            let a = (self.run)(env.clone());
            f(a).run(env)
        })
    }
}

// å®æˆ˜æ¡ˆä¾‹ï¼šé…ç½®ä¾èµ–æ³¨å…¥
#[derive(Clone)]
struct Config {
    database_url: String,
    api_key: String,
    timeout: u64,
}

fn get_database_url() -> Reader<Config, String> {
    Reader::new(|config: Config| config.database_url)
}

fn get_api_key() -> Reader<Config, String> {
    Reader::new(|config: Config| config.api_key)
}

fn connect_with_auth() -> Reader<Config, String> {
    get_database_url()
        .flat_map(|url| {
            get_api_key().map(move |key| {
                format!("Connecting to {} with key {}", url, key)
            })
        })
}
```

### 10.6 Writer Monadæ¨¡å¼ï¼ˆæ—¥å¿—ç´¯ç§¯ï¼‰

**Writer Monadå®ç°**:

```rust
use std::fmt::Display;

struct Writer<W, A> {
    value: A,
    log: W,
}

impl<W: Monoid, A> Writer<W, A> {
    fn new(value: A, log: W) -> Self {
        Writer { value, log }
    }
    
    fn run(self) -> (A, W) {
        (self.value, self.log)
    }
    
    fn map<B, F>(self, f: F) -> Writer<W, B>
    where
        F: FnOnce(A) -> B,
    {
        Writer {
            value: f(self.value),
            log: self.log,
        }
    }
    
    fn flat_map<B, F>(self, f: F) -> Writer<W, B>
    where
        F: FnOnce(A) -> Writer<W, B>,
    {
        let Writer { value: b, log: log2 } = f(self.value);
        Writer {
            value: b,
            log: self.log.mappend(log2),
        }
    }
    
    fn tell(log: W) -> Writer<W, ()> {
        Writer::new((), log)
    }
}

// Monoid traitï¼ˆå¯ç»“åˆçš„å¹ºåŠç¾¤ï¼‰
trait Monoid: Clone {
    fn mempty() -> Self;
    fn mappend(self, other: Self) -> Self;
}

impl Monoid for String {
    fn mempty() -> Self {
        String::new()
    }
    
    fn mappend(mut self, other: Self) -> Self {
        self.push_str(&other);
        self
    }
}

impl<T> Monoid for Vec<T> {
    fn mempty() -> Self {
        Vec::new()
    }
    
    fn mappend(mut self, mut other: Self) -> Self {
        self.append(&mut other);
        self
    }
}

// å®æˆ˜æ¡ˆä¾‹ï¼šå¸¦æ—¥å¿—çš„è®¡ç®—
fn factorial_with_log(n: u64) -> Writer<String, u64> {
    if n == 0 {
        Writer::new(1, format!("factorial(0) = 1\n"))
    } else {
        factorial_with_log(n - 1)
            .flat_map(move |prev| {
                let result = n * prev;
                Writer::new(
                    result,
                    format!("factorial({}) = {} * {} = {}\n", n, n, prev, result),
                )
            })
    }
}
```

### 10.7 State Monadæ¨¡å¼ï¼ˆçŠ¶æ€è½¬æ¢ï¼‰

**State Monadå®ç°**:

```rust
struct State<S, A> {
    run: Box<dyn FnOnce(S) -> (A, S)>,
}

impl<S: 'static, A: 'static> State<S, A> {
    fn new<F>(f: F) -> Self
    where
        F: FnOnce(S) -> (A, S) + 'static,
    {
        State {
            run: Box::new(f),
        }
    }
    
    fn run(self, initial_state: S) -> (A, S) {
        (self.run)(initial_state)
    }
    
    fn map<B, F>(self, f: F) -> State<S, B>
    where
        F: FnOnce(A) -> B + 'static,
    {
        State::new(|s| {
            let (a, s2) = (self.run)(s);
            (f(a), s2)
        })
    }
    
    fn flat_map<B, F>(self, f: F) -> State<S, B>
    where
        F: FnOnce(A) -> State<S, B> + 'static,
    {
        State::new(|s| {
            let (a, s2) = (self.run)(s);
            f(a).run(s2)
        })
    }
    
    fn get() -> State<S, S>
    where
        S: Clone,
    {
        State::new(|s: S| (s.clone(), s))
    }
    
    fn put(new_state: S) -> State<S, ()> {
        State::new(|_| ((), new_state))
    }
    
    fn modify<F>(f: F) -> State<S, ()>
    where
        F: FnOnce(S) -> S + 'static,
    {
        State::new(|s| ((), f(s)))
    }
}

// å®æˆ˜æ¡ˆä¾‹ï¼šéšæœºæ•°ç”Ÿæˆå™¨
struct RNG {
    seed: u64,
}

impl RNG {
    fn next(self) -> (u64, RNG) {
        let new_seed = (self.seed.wrapping_mul(1103515245).wrapping_add(12345)) & 0x7FFFFFFF;
        (new_seed, RNG { seed: new_seed })
    }
}

fn random_int() -> State<RNG, u64> {
    State::new(|rng| rng.next())
}

fn random_range(min: u64, max: u64) -> State<RNG, u64> {
    random_int().map(move |n| min + (n % (max - min)))
}

fn random_pair() -> State<RNG, (u64, u64)> {
    random_int().flat_map(|x| {
        random_int().map(move |y| (x, y))
    })
}
```

### 10.8 å¹¶å‘æ¨¡å¼æ·±åŒ–

**CSP (Communicating Sequential Processes) æ¨¡å¼**:

```rust
use std::sync::mpsc;
use std::thread;

// CSPé£æ ¼çš„å¹¶å‘
fn csp_pattern() {
    let (tx1, rx) = mpsc::channel();
    let tx2 = tx1.clone();
    
    // Worker 1
    thread::spawn(move || {
        for i in 0..5 {
            tx1.send(format!("Worker1: {}", i)).unwrap();
            thread::sleep(std::time::Duration::from_millis(100));
        }
    });
    
    // Worker 2
    thread::spawn(move || {
        for i in 0..5 {
            tx2.send(format!("Worker2: {}", i)).unwrap();
            thread::sleep(std::time::Duration::from_millis(150));
        }
    });
    
    // Coordinator
    for received in rx {
        println!("Received: {}", received);
    }
}
```

**STM (Software Transactional Memory) é£æ ¼**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// æ¨¡æ‹ŸSTMçš„åŸå­äº‹åŠ¡
struct Transaction<T> {
    value: Arc<Mutex<T>>,
}

impl<T: Clone> Transaction<T> {
    fn new(value: T) -> Self {
        Transaction {
            value: Arc::new(Mutex::new(value)),
        }
    }
    
    fn atomically<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&mut T) -> R,
    {
        let mut guard = self.value.lock().unwrap();
        f(&mut *guard)
    }
}

// é“¶è¡Œè½¬è´¦ç¤ºä¾‹
fn transfer(from: &Transaction<u64>, to: &Transaction<u64>, amount: u64) -> bool {
    from.atomically(|from_balance| {
        if *from_balance >= amount {
            *from_balance -= amount;
            to.atomically(|to_balance| {
                *to_balance += amount;
            });
            true
        } else {
            false
        }
    })
}
```

**Actoræ¨¡å¼æ·±åŒ–**:

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

enum Message {
    Increment,
    Decrement,
    Get(Sender<i32>),
    Stop,
}

struct CounterActor {
    receiver: Receiver<Message>,
    count: i32,
}

impl CounterActor {
    fn new() -> (Self, Sender<Message>) {
        let (sender, receiver) = channel();
        (
            CounterActor {
                receiver,
                count: 0,
            },
            sender,
        )
    }
    
    fn run(mut self) {
        thread::spawn(move || {
            loop {
                match self.receiver.recv() {
                    Ok(Message::Increment) => self.count += 1,
                    Ok(Message::Decrement) => self.count -= 1,
                    Ok(Message::Get(reply)) => {
                        reply.send(self.count).ok();
                    },
                    Ok(Message::Stop) | Err(_) => break,
                }
            }
        });
    }
}
```

### 10.9 æ€§èƒ½ä¼˜åŒ–æ¨¡å¼é›†

**é›¶æ‹·è´æ¨¡å¼**:

```rust
use std::borrow::Cow;

// Cow (Clone on Write)æ¨¡å¼
fn process_data<'a>(data: Cow<'a, str>) -> Cow<'a, str> {
    if data.contains("special") {
        // éœ€è¦ä¿®æ”¹ï¼Œä¼šå‘ç”Ÿå…‹éš†
        Cow::Owned(data.replace("special", "normal"))
    } else {
        // æ— éœ€ä¿®æ”¹ï¼Œé›¶æ‹·è´
        data
    }
}

fn main() {
    let original = "Hello world";
    let result = process_data(Cow::Borrowed(original));
    // æ²¡æœ‰å‘ç”Ÿå¤åˆ¶
}
```

**å»¶è¿Ÿè®¡ç®—æ¨¡å¼**:

```rust
struct Lazy<T, F>
where
    F: FnOnce() -> T,
{
    init: Option<F>,
    value: Option<T>,
}

impl<T, F> Lazy<T, F>
where
    F: FnOnce() -> T,
{
    fn new(init: F) -> Self {
        Lazy {
            init: Some(init),
            value: None,
        }
    }
    
    fn force(&mut self) -> &T {
        if self.value.is_none() {
            let init = self.init.take().unwrap();
            self.value = Some(init());
        }
        self.value.as_ref().unwrap()
    }
}

// å®æˆ˜æ¡ˆä¾‹ï¼šå»¶è¿ŸåŠ è½½é…ç½®
fn expensive_computation() -> String {
    println!("Computing...");
    std::thread::sleep(std::time::Duration::from_secs(1));
    "Result".to_string()
}

fn main() {
    let mut lazy = Lazy::new(expensive_computation);
    println!("Lazy created");  // ä¸ä¼šè§¦å‘è®¡ç®—
    println!("Value: {}", lazy.force());  // è§¦å‘è®¡ç®—
    println!("Value: {}", lazy.force());  // ä½¿ç”¨ç¼“å­˜ç»“æœ
}
```

**å†…å­˜æ± æ¨¡å¼å®æˆ˜**:

```rust
struct Pool<T> {
    items: Vec<Option<T>>,
    available: Vec<usize>,
}

impl<T> Pool<T> {
    fn new() -> Self {
        Pool {
            items: Vec::new(),
            available: Vec::new(),
        }
    }
    
    fn allocate(&mut self, item: T) -> usize {
        if let Some(index) = self.available.pop() {
            self.items[index] = Some(item);
            index
        } else {
            let index = self.items.len();
            self.items.push(Some(item));
            index
        }
    }
    
    fn deallocate(&mut self, index: usize) {
        if index < self.items.len() {
            self.items[index] = None;
            self.available.push(index);
        }
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        self.items.get(index).and_then(|item| item.as_ref())
    }
}
```

---

## 11. æ€»ç»“

**è®¾è®¡æ¨¡å¼åˆ†ç±»æ€»ç»“**:

| æ¨¡å¼ | ç”¨é€” | Rust ç‰¹è‰² |
|------|------|----------|
| **Builder** | å¤æ‚å¯¹è±¡æ„å»º | é“¾å¼è°ƒç”¨ + Result |
| **Factory** | å¯¹è±¡åˆ›å»º | Trait å¯¹è±¡ |
| **Adapter** | æ¥å£è½¬æ¢ | Newtype |
| **Decorator** | åŠŸèƒ½æ‰©å±• | æ³›å‹ç»„åˆ |
| **Strategy** | ç®—æ³•æ›¿æ¢ | Trait |
| **Visitor** | æ“ä½œåˆ†ç¦» | Trait + æšä¸¾ |
| **RAII** | èµ„æºç®¡ç† | æ‰€æœ‰æƒ + Drop |
| **Typestate** | çŠ¶æ€ç¼–ç  | PhantomData |
| **Actor** | å¹¶å‘é€šä¿¡ | Channel + Thread |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… é›¶æˆæœ¬æŠ½è±¡
2. âœ… ç¼–è¯‘æ—¶æ£€æŸ¥
3. âœ… æ˜ç¡®çš„æ‰€æœ‰æƒ
4. âœ… ç±»å‹å®‰å…¨

---

## 8. å‚è€ƒèµ„æº

**å®˜æ–¹èµ„æ–™**:

- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [The Rust Book](https://doc.rust-lang.org/book/)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)
- [4.2 é«˜çº§æ³›å‹æ¨¡å¼](./02_é«˜çº§æ³›å‹æ¨¡å¼.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚

---

**ğŸ‰ å®Œæˆè®¾è®¡æ¨¡å¼é›†å­¦ä¹ ï¼** ğŸ¦€
