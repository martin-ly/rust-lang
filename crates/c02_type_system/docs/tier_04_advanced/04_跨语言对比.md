# 4.4 Rust 类型系统 - 跨语言对比

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: Rust vs 其他语言的类型系统对比  
> **适用对象**: 高级开发者  
> **前置知识**: 多种编程语言经验  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.4 Rust 类型系统 - 跨语言对比](#44-rust-类型系统---跨语言对比)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. Rust vs C/C++](#1-rust-vs-cc)
    - [内存管理](#内存管理)
    - [空指针](#空指针)
  - [2. Rust vs Haskell](#2-rust-vs-haskell)
    - [纯度](#纯度)
    - [高阶类型](#高阶类型)
  - [3. Rust vs Go](#3-rust-vs-go)
    - [错误处理](#错误处理)
    - [泛型](#泛型)
  - [4. Rust vs Java/C#1](#4-rust-vs-javac1)
    - [Null 安全](#null-安全)
    - [所有权 vs GC](#所有权-vs-gc)
  - [5. Rust vs Swift](#5-rust-vs-swift)
    - [内存管理1](#内存管理1)
    - [Optional](#optional)
  - [6. Rust vs TypeScript](#6-rust-vs-typescript)
    - [类型系统](#类型系统)
    - [Null vs Option](#null-vs-option)
  - [7. 类型系统特性对比](#7-类型系统特性对比)
  - [8. 总结](#8-总结)
  - [9. 参考资源](#9-参考资源)

---

## 🎯 概述

**类型系统特性对比**:

| 语言 | 类型系统 | 内存管理 | 空安全 | 并发安全 |
|------|---------|---------|--------|----------|
| **Rust** | 强静态 + 仿射 | 所有权 | ✅ Option | ✅ Send/Sync |
| **C++** | 静态 | 手动/RAII | ❌ null | ❌ UB |
| **Haskell** | 强静态 + 纯 | GC | ✅ Maybe | ✅ STM |
| **Go** | 静态 | GC | ❌ nil | ⚠️ Channel |
| **Java** | 强静态 | GC | ❌ null | ⚠️ synchronized |
| **Swift** | 强静态 | ARC | ✅ Optional | ⚠️ actor |

---

## 1. Rust vs C/C++

### 内存管理

**C++**: 手动 + RAII

```cpp
// C++: 手动内存管理
std::string* create_string() {
    return new std::string("hello");
}

void use_string() {
    auto s = create_string();
    std::cout << *s << std::endl;
    delete s;  // 必须手动释放
}

// RAII
void use_string_raii() {
    auto s = std::make_unique<std::string>("hello");
    std::cout << *s << std::endl;
    // 自动释放
}
```

**Rust**: 所有权

```rust
// Rust: 自动内存管理
fn create_string() -> String {
    String::from("hello")
}

fn use_string() {
    let s = create_string();
    println!("{}", s);
    // 自动释放，无需手动管理
}

fn main() {
    use_string();
}
```

### 空指针

**C++**: null 可能导致崩溃

```cpp
// C++: 可能的 null
std::string* find_user(int id) {
    if (id == 1) {
        return new std::string("Alice");
    }
    return nullptr;
}

void process() {
    auto user = find_user(2);
    std::cout << *user << std::endl;  // ❌ 崩溃！
}
```

**Rust**: Option 强制处理

```rust
// Rust: 强制处理 None
fn find_user(id: i32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn process() {
    match find_user(2) {
        Some(user) => println!("{}", user),
        None => println!("User not found"),
    }
}

fn main() {
    process();
}
```

---

## 2. Rust vs Haskell

### 纯度

**Haskell**: 默认纯函数

```haskell
-- Haskell: 纯函数
add :: Int -> Int -> Int
add x y = x + y

-- IO 必须明确标记
printNumber :: Int -> IO ()
printNumber n = putStrLn (show n)
```

**Rust**: 非纯，但可控

```rust
// Rust: 可变性可控
fn add(x: i32, y: i32) -> i32 {
    x + y
}

fn print_number(n: i32) {
    println!("{}", n);  // 副作用
}

fn main() {
    println!("{}", add(1, 2));
    print_number(3);
}
```

### 高阶类型

**Haskell**: 原生支持 HKT

```haskell
-- Haskell: Functor
class Functor f where
    fmap :: (a -> b) -> f a -> f b

instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)
```

**Rust**: 通过 Associated Types 模拟

```rust
// Rust: 无原生 HKT，使用关联类型
trait Functor {
    type Inner;
    type Mapped<T>;
    
    fn fmap<F, B>(self, f: F) -> Self::Mapped<B>
    where
        F: FnOnce(Self::Inner) -> B;
}

impl<T> Functor for Option<T> {
    type Inner = T;
    type Mapped<U> = Option<U>;
    
    fn fmap<F, B>(self, f: F) -> Option<B>
    where
        F: FnOnce(T) -> B,
    {
        self.map(f)
    }
}

fn main() {
    let some = Some(42);
    let result = some.fmap(|x| x * 2);
    println!("{:?}", result);
}
```

---

## 3. Rust vs Go

### 错误处理

**Go**: 返回值 + error

```go
// Go: 返回值和 error
func readFile(path string) (string, error) {
    content, err := os.ReadFile(path)
    if err != nil {
        return "", err
    }
    return string(content), nil
}

func main() {
    content, err := readFile("file.txt")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(content)
}
```

**Rust**: Result 类型

```rust
// Rust: Result<T, E>
use std::fs;
use std::io;

fn read_file(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path)
}

fn main() {
    match read_file("file.txt") {
        Ok(content) => println!("{}", content),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

### 泛型

**Go**: 1.18+ 泛型

```go
// Go: 泛型 (1.18+)
func Max[T comparable](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Max(1, 2))
    fmt.Println(Max(1.5, 2.5))
}
```

**Rust**: 强大的泛型系统

```rust
// Rust: 泛型 + Trait Bounds
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

fn main() {
    println!("{}", max(1, 2));
    println!("{}", max(1.5, 2.5));
}
```

---

## 4. Rust vs Java/C#1

### Null 安全

**Java**: NullPointerException

```java
// Java: 可能的 NullPointerException
String findUser(int id) {
    if (id == 1) {
        return "Alice";
    }
    return null;
}

void process() {
    String user = findUser(2);
    System.out.println(user.length());  // ❌ NPE!
}
```

**Rust**: 编译时检查

```rust
// Rust: 编译时强制处理
fn find_user(id: i32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn process() {
    if let Some(user) = find_user(2) {
        println!("{}", user.len());
    }
}

fn main() {
    process();
}
```

### 所有权 vs GC

**Java**: 垃圾回收

```java
// Java: GC 管理内存
class Data {
    private String value;
    
    public Data(String value) {
        this.value = value;
    }
}

void process() {
    Data d1 = new Data("hello");
    Data d2 = d1;  // 共享引用
    System.out.println(d1.value);  // ✅ 可以使用
    // GC 自动回收
}
```

**Rust**: 所有权转移

```rust
// Rust: 所有权系统
struct Data {
    value: String,
}

fn process() {
    let d1 = Data {
        value: String::from("hello"),
    };
    let d2 = d1;  // 所有权转移
    // println!("{}", d1.value);  // ❌ d1 已失效
    println!("{}", d2.value);  // ✅
}

fn main() {
    process();
}
```

---

## 5. Rust vs Swift

### 内存管理1

**Swift**: ARC (Automatic Reference Counting)

```swift
// Swift: ARC
class Person {
    let name: String
    init(name: String) {
        self.name = name
    }
}

func process() {
    let person = Person(name: "Alice")
    let another = person  // 引用计数 +1
    print(person.name)    // ✅ 可以使用
    // ARC 自动管理
}
```

**Rust**: 所有权

```rust
// Rust: 所有权
struct Person {
    name: String,
}

fn process() {
    let person = Person {
        name: String::from("Alice"),
    };
    let another = person;  // 所有权转移
    // println!("{}", person.name);  // ❌ 已失效
    println!("{}", another.name);  // ✅
}

fn main() {
    process();
}
```

### Optional

**Swift**: Optional

```swift
// Swift: Optional
func findUser(id: Int) -> String? {
    if id == 1 {
        return "Alice"
    }
    return nil
}

func process() {
    if let user = findUser(2) {
        print(user)
    } else {
        print("Not found")
    }
}
```

**Rust**: Option

```rust
// Rust: Option<T>
fn find_user(id: i32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn process() {
    match find_user(2) {
        Some(user) => println!("{}", user),
        None => println!("Not found"),
    }
}

fn main() {
    process();
}
```

---

## 6. Rust vs TypeScript

### 类型系统

**TypeScript**: 结构化类型

```typescript
// TypeScript: 结构化类型
interface Point {
    x: number;
    y: number;
}

function distance(p: Point): number {
    return Math.sqrt(p.x * p.x + p.y * p.y);
}

// 任何有 x, y 的对象都可以
const p1 = { x: 3, y: 4, z: 5 };
console.log(distance(p1));  // ✅ OK
```

**Rust**: 名义类型

```rust
// Rust: 名义类型
struct Point {
    x: f64,
    y: f64,
}

fn distance(p: Point) -> f64 {
    (p.x * p.x + p.y * p.y).sqrt()
}

fn main() {
    let p1 = Point { x: 3.0, y: 4.0 };
    println!("{}", distance(p1));
}
```

### Null vs Option

**TypeScript**: null/undefined

```typescript
// TypeScript: null/undefined
function findUser(id: number): string | null {
    if (id === 1) {
        return "Alice";
    }
    return null;
}

function process() {
    const user = findUser(2);
    console.log(user?.length);  // Optional chaining
}
```

**Rust**: Option

```rust
// Rust: Option
fn find_user(id: i32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn process() {
    if let Some(user) = find_user(2) {
        println!("{}", user.len());
    }
}

fn main() {
    process();
}
```

---

## 7. 类型系统特性对比

**完整对比表**:

| 特性 | Rust | C++ | Haskell | Go | Java | Swift | TypeScript |
|------|------|-----|---------|----|----|-------|-----------|
| **强类型** | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ⚠️ |
| **静态类型** | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| **类型推断** | ✅ | ⚠️ | ✅ | ✅ | ⚠️ | ✅ | ✅ |
| **泛型** | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| **HKT** | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❌ |
| **Trait/Interface** | ✅ | ⚠️ | ✅ | ✅ | ✅ | ✅ | ✅ |
| **所有权** | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| **空安全** | ✅ | ❌ | ✅ | ❌ | ❌ | ✅ | ⚠️ |
| **并发安全** | ✅ | ❌ | ✅ | ⚠️ | ⚠️ | ⚠️ | ❌ |
| **零成本抽象** | ✅ | ✅ | ❌ | ⚠️ | ❌ | ❌ | ❌ |

---

## 8. 总结

**Rust 的独特优势**:

1. **所有权系统**: 编译时内存安全
2. **仿射类型**: 零成本资源管理
3. **强类型 + 空安全**: 消除常见错误
4. **并发安全**: Send/Sync 编译时检查
5. **零成本抽象**: 性能 + 安全

**各语言适用场景**:

| 语言 | 适用场景 |
|------|---------|
| **Rust** | 系统编程、性能关键、高可靠性 |
| **C++** | 遗留代码、极致性能 |
| **Haskell** | 函数式编程、类型驱动开发 |
| **Go** | 微服务、网络编程 |
| **Java/C#** | 企业应用、大型系统 |
| **Swift** | iOS/macOS 开发 |
| **TypeScript** | Web 前端 |

---

## 9. 参考资源

**对比文章**:

- [Rust vs C++](https://www.thecodedmessage.com/posts/rust-vs-cpp/)
- [Rust vs Haskell](https://www.fpcomplete.com/blog/2018/11/haskell-and-rust/)

**相关文档**:

- [4.1 类型理论深度](./01_类型理论深度.md)
- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🌍 完成跨语言对比学习！** 🦀
