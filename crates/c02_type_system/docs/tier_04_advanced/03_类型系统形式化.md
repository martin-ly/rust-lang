# 4.3 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–æè¿°  
> **é€‚ç”¨å¯¹è±¡**: é«˜çº§å¼€å‘è€… + ç ”ç©¶è€…  
> **å‰ç½®çŸ¥è¯†**: [4.1 ç±»å‹ç†è®ºæ·±åº¦](./01_ç±»å‹ç†è®ºæ·±åº¦.md), å½¢å¼åŒ–æ–¹æ³•åŸºç¡€  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [4.3 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–](#43-rust-ç±»å‹ç³»ç»Ÿ---ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. è¯­æ³•å®šä¹‰](#1-è¯­æ³•å®šä¹‰)
    - [1.1 æ ¸å¿ƒè¯­æ³•](#11-æ ¸å¿ƒè¯­æ³•)
    - [1.2 æ‰©å±•è¯­æ³•](#12-æ‰©å±•è¯­æ³•)
    - [1.3 è¯­æ³•ç³–](#13-è¯­æ³•ç³–)
  - [2. ç±»å‹è§„åˆ™](#2-ç±»å‹è§„åˆ™)
    - [2.1 åŸºç¡€ç±»å‹è§„åˆ™](#21-åŸºç¡€ç±»å‹è§„åˆ™)
    - [2.2 å¼•ç”¨ç±»å‹è§„åˆ™](#22-å¼•ç”¨ç±»å‹è§„åˆ™)
    - [2.3 é«˜çº§ç±»å‹è§„åˆ™](#23-é«˜çº§ç±»å‹è§„åˆ™)
  - [3. æ“ä½œè¯­ä¹‰](#3-æ“ä½œè¯­ä¹‰)
    - [3.1 å°æ­¥è¯­ä¹‰](#31-å°æ­¥è¯­ä¹‰)
    - [3.2 å¤§æ­¥è¯­ä¹‰](#32-å¤§æ­¥è¯­ä¹‰)
    - [3.3 å †æ¨¡å‹](#33-å †æ¨¡å‹)
  - [4. æ‰€æœ‰æƒè§„åˆ™](#4-æ‰€æœ‰æƒè§„åˆ™)
    - [4.1 æ‰€æœ‰æƒè½¬ç§»](#41-æ‰€æœ‰æƒè½¬ç§»)
    - [4.2 Copy vs Move è¯­ä¹‰](#42-copy-vs-move-è¯­ä¹‰)
    - [4.3 Drop è¯­ä¹‰](#43-drop-è¯­ä¹‰)
  - [5. å€Ÿç”¨æ£€æŸ¥](#5-å€Ÿç”¨æ£€æŸ¥)
    - [5.1 å€Ÿç”¨è§„åˆ™å½¢å¼åŒ–](#51-å€Ÿç”¨è§„åˆ™å½¢å¼åŒ–)
    - [5.2 Polonius å€Ÿç”¨æ£€æŸ¥å™¨](#52-polonius-å€Ÿç”¨æ£€æŸ¥å™¨)
    - [5.3 NLL (Non-Lexical Lifetimes)](#53-nll-non-lexical-lifetimes)
  - [6. ç”Ÿå‘½å‘¨æœŸæ¨æ–­](#6-ç”Ÿå‘½å‘¨æœŸæ¨æ–­)
    - [6.1 ç”Ÿå‘½å‘¨æœŸçº¦æŸç³»ç»Ÿ](#61-ç”Ÿå‘½å‘¨æœŸçº¦æŸç³»ç»Ÿ)
    - [6.2 åŒºåŸŸç±»å‹ç³»ç»Ÿ](#62-åŒºåŸŸç±»å‹ç³»ç»Ÿ)
    - [6.3 ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™](#63-ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™)
  - [7. ç±»å‹å¥å…¨æ€§](#7-ç±»å‹å¥å…¨æ€§)
    - [7.1 ç±»å‹ä¿å…¨æ€§è¯æ˜](#71-ç±»å‹ä¿å…¨æ€§è¯æ˜)
    - [7.2 è¿›å±•æ€§è¯æ˜](#72-è¿›å±•æ€§è¯æ˜)
    - [7.3 å†…å­˜å®‰å…¨è¯æ˜](#73-å†…å­˜å®‰å…¨è¯æ˜)
  - [8. åˆ†ç¦»é€»è¾‘ä¸ RustBelt](#8-åˆ†ç¦»é€»è¾‘ä¸-rustbelt)
    - [8.1 åˆ†ç¦»é€»è¾‘åŸºç¡€](#81-åˆ†ç¦»é€»è¾‘åŸºç¡€)
    - [8.2 Iris æ¡†æ¶](#82-iris-æ¡†æ¶)
    - [8.3 RustBelt æ¨¡å‹](#83-rustbelt-æ¨¡å‹)
  - [9. Oxide: Rust çš„æ ¸å¿ƒæ¼”ç®—](#9-oxide-rust-çš„æ ¸å¿ƒæ¼”ç®—)
    - [9.1 Oxide è¯­æ³•](#91-oxide-è¯­æ³•)
    - [9.2 Oxide ç±»å‹ç³»ç»Ÿ](#92-oxide-ç±»å‹ç³»ç»Ÿ)
    - [9.3 Oxide è¯æ˜](#93-oxide-è¯æ˜)
  - [10. é«˜çº§ä¸»é¢˜](#10-é«˜çº§ä¸»é¢˜)
    - [10.1 å‹å˜ä¸å­ç±»å‹](#101-å‹å˜ä¸å­ç±»å‹)
    - [10.2 Higher-Ranked Types](#102-higher-ranked-types)
    - [10.3 æ•ˆåº”ç³»ç»Ÿ](#103-æ•ˆåº”ç³»ç»Ÿ)
    - [10.4 ç±»å‹æ¼”ç®—çš„å…ƒç†è®ºæ€§è´¨](#104-ç±»å‹æ¼”ç®—çš„å…ƒç†è®ºæ€§è´¨)
    - [10.5 å¹¶å‘ä¸åŒæ­¥çš„å½¢å¼åŒ–](#105-å¹¶å‘ä¸åŒæ­¥çš„å½¢å¼åŒ–)
    - [10.6 å¼‚æ­¥çš„å½¢å¼åŒ–](#106-å¼‚æ­¥çš„å½¢å¼åŒ–)
    - [10.7 Unsafe ä»£ç çš„å½¢å¼åŒ–](#107-unsafe-ä»£ç çš„å½¢å¼åŒ–)
    - [10.8 å¸¸é‡æ³›å‹çš„å½¢å¼åŒ–](#108-å¸¸é‡æ³›å‹çš„å½¢å¼åŒ–)
  - [11. å®è·µï¼šå½¢å¼åŒ–éªŒè¯å·¥å…·](#11-å®è·µå½¢å¼åŒ–éªŒè¯å·¥å…·)
    - [11.1 Prusti](#111-prusti)
    - [11.2 Creusot](#112-creusot)
    - [11.3 Verus](#113-verus)
    - [11.4 Kani: æ¨¡å‹æ£€æŸ¥å™¨](#114-kani-æ¨¡å‹æ£€æŸ¥å™¨)
    - [11.5 å½¢å¼åŒ–éªŒè¯å®æˆ˜æ¡ˆä¾‹](#115-å½¢å¼åŒ–éªŒè¯å®æˆ˜æ¡ˆä¾‹)
    - [11.6 å½¢å¼åŒ–æ–¹æ³•çš„æ¯”è¾ƒ](#116-å½¢å¼åŒ–æ–¹æ³•çš„æ¯”è¾ƒ)
    - [11.7 å½¢å¼åŒ–éªŒè¯çš„æœªæ¥æ–¹å‘](#117-å½¢å¼åŒ–éªŒè¯çš„æœªæ¥æ–¹å‘)
  - [12. æ€»ç»“](#12-æ€»ç»“)
  - [13. å‚è€ƒèµ„æº](#13-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–åŸºäºï¼š

- Î»-æ¼”ç®—
- çº¿æ€§/ä»¿å°„ç±»å‹ç³»ç»Ÿ
- åŒºåŸŸç±»å‹ç³»ç»Ÿ
- Hindley-Milner ç±»å‹æ¨æ–­

---

## 1. è¯­æ³•å®šä¹‰

### 1.1 æ ¸å¿ƒè¯­æ³•

**æŠ½è±¡è¯­æ³•ï¼ˆBNFèŒƒå¼ï¼‰**:

```text
ç±»å‹ T ::=
    | bool                    å¸ƒå°”ç±»å‹
    | i32, i64, u32, u64      æ•´æ•°ç±»å‹æ—
    | f32, f64                æµ®ç‚¹ç±»å‹
    | ()                      å•å…ƒç±»å‹
    | &'a T                   ä¸å¯å˜å¼•ç”¨
    | &'a mut T               å¯å˜å¼•ç”¨
    | (T1, T2, ..., Tn)       å…ƒç»„ç±»å‹
    | fn(T1, ..., Tn) -> T    å‡½æ•°ç±»å‹
    | Box<T>                  æ‰€æœ‰æƒæŒ‡é’ˆ
    | [T; n]                  æ•°ç»„ç±»å‹
    | [T]                     åˆ‡ç‰‡ç±»å‹
    | struct { f1: T1, ... }  ç»“æ„ä½“ç±»å‹
    | enum { C1(T1), ... }    æšä¸¾ç±»å‹
    | impl Trait              Traitå¯¹è±¡
    | dyn Trait               åŠ¨æ€Trait
    | 'a                      ç”Ÿå‘½å‘¨æœŸå‚æ•°

è¡¨è¾¾å¼ e ::=
    | x                       å˜é‡
    | true | false            å¸ƒå°”å€¼
    | n                       æ•´æ•°å­—é¢é‡
    | f                       æµ®ç‚¹å­—é¢é‡
    | ()                      å•å…ƒå€¼
    | (e1, e2, ..., en)       å…ƒç»„æ„é€ 
    | e.i                     å…ƒç»„æŠ•å½± (i âˆˆ â„•)
    | e.f                     å­—æ®µè®¿é—®
    | &e | &mut e             å¼•ç”¨æ„é€ 
    | *e                      è§£å¼•ç”¨
    | let x = e1 in e2        letç»‘å®š
    | let mut x = e1 in e2    å¯å˜ç»‘å®š
    | fn(x: T) e              å‡½æ•°æŠ½è±¡
    | e1(e2, ..., en)         å‡½æ•°åº”ç”¨
    | if e1 { e2 } else { e3 } æ¡ä»¶è¡¨è¾¾å¼
    | match e { p1 => e1, ... } æ¨¡å¼åŒ¹é…
    | loop { e }              æ— é™å¾ªç¯
    | break e                 å¾ªç¯è·³å‡º
    | continue                å¾ªç¯ç»§ç»­
    | { e1; e2; ...; en }     å—è¡¨è¾¾å¼
    | e1 = e2                 èµ‹å€¼
    | drop(e)                 æ˜¾å¼é‡Šæ”¾
    | Box::new(e)             å †åˆ†é…
    | e as T                  ç±»å‹è½¬æ¢

æ¨¡å¼ p ::=
    | _                       é€šé…ç¬¦
    | x                       å˜é‡ç»‘å®š
    | true | false | n        å­—é¢é‡
    | (p1, ..., pn)           å…ƒç»„æ¨¡å¼
    | C(p1, ..., pn)          æ„é€ å™¨æ¨¡å¼
    | p @ p'                  ç»‘å®šæ¨¡å¼
    | ref p | ref mut p       å¼•ç”¨æ¨¡å¼

å€¼ v ::=
    | true | false            å¸ƒå°”å€¼
    | n                       æ•´æ•°å€¼
    | ()                      å•å…ƒå€¼
    | (v1, v2, ..., vn)       å…ƒç»„å€¼
    | fn(x: T) e              é—­åŒ…å€¼
    | &l | &mut l             å¼•ç”¨å€¼
    | Box(l)                  å †æŒ‡é’ˆå€¼

ä½ç½® l âˆˆ Loc                  å †åœ°å€ï¼ˆæŠ½è±¡ï¼‰
ç”Ÿå‘½å‘¨æœŸ 'a, 'b, ...          ç”Ÿå‘½å‘¨æœŸå˜é‡
```

**ç±»å‹ç¯å¢ƒ**:

```text
Î“ ::= âˆ…                       ç©ºç¯å¢ƒ
    | Î“, x : T                å˜é‡ç»‘å®š
    | Î“, 'a : Region          ç”Ÿå‘½å‘¨æœŸç»‘å®š
    | Î“, l : T                ä½ç½®ç±»å‹

Î£ ::= âˆ…                       ç©ºå †
    | Î£, l â†¦ v                å †æ˜ å°„
```

### 1.2 æ‰©å±•è¯­æ³•

**æ³›å‹å’ŒTrait**:

```text
ç±»å‹å‚æ•° Î±, Î², ...
Traitçº¦æŸ C ::= T : Trait | 'a : 'b

æ³›å‹ç±»å‹ âˆ€Î±. T
å¸¦çº¦æŸæ³›å‹ âˆ€Î± where C. T

å…³è”ç±»å‹:
trait Iterator {
    type Item;
    ...
}

impl Iterator for T {
    type Item = U;
    ...
}
```

**ç”Ÿå‘½å‘¨æœŸå‚æ•°åŒ–**:

```text
&'a T                         æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ
&'static T                    é™æ€ç”Ÿå‘½å‘¨æœŸ
&'_ T                         ç”Ÿå‘½å‘¨æœŸçœç•¥

for<'a> fn(&'a T) -> &'a U    é«˜é˜¶ç”Ÿå‘½å‘¨æœŸ
```

### 1.3 è¯­æ³•ç³–

**Rustè¯­æ³•ç³–åˆ°æ ¸å¿ƒè¯­æ³•çš„è„±ç³–**:

| Rust è¯­æ³• | æ ¸å¿ƒè¯­æ³• | è¯´æ˜ |
|-----------|---------|------|
| `let x = e;` | `let x = e in ()` | è¯­å¥è½¬è¡¨è¾¾å¼ |
| `x += 1` | `x = x + 1` | å¤åˆèµ‹å€¼ |
| `vec![1, 2, 3]` | `Vec::from([1, 2, 3])` | å®å±•å¼€ |
| `s.len()` | `String::len(&s)` | æ–¹æ³•è°ƒç”¨ |
| `for x in iter { e }` | `iter.into_iter().for_each(\|x\| e)` | forå¾ªç¯ |
| `?` æ“ä½œç¬¦ | `match e { Ok(v) => v, Err(e) => return Err(e) }` | é”™è¯¯ä¼ æ’­ |
| `async fn` | `fn() -> impl Future<Output = T>` | å¼‚æ­¥å‡½æ•° |

**ç¤ºä¾‹è„±ç³–**:

```rust
// åŸå§‹Rustä»£ç 
fn process(data: Vec<i32>) -> Result<i32, String> {
    let sum = data.iter().sum();
    if sum > 0 {
        Ok(sum)
    } else {
        Err("Sum is not positive".to_string())
    }
}

// å¯¹åº”çš„æ ¸å¿ƒè¯­æ³•ï¼ˆä¼ªä»£ç ï¼‰
fn process(data: Vec<i32>) -> Result<i32, String> = 
    let sum = 
        let iter = Vec::iter(&data) in
        let sum_fn = Iterator::sum in
        sum_fn(iter)
    in
    if sum > 0 {
        Result::Ok(sum)
    } else {
        Result::Err(String::from("Sum is not positive"))
    }
```

---

## 2. ç±»å‹è§„åˆ™

### 2.1 åŸºç¡€ç±»å‹è§„åˆ™

**ç±»å‹åˆ¤æ–­**: `Î“ âŠ¢ e : T`

**åŸºç¡€è§„åˆ™**:

```text
[T-Var]
x : T âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x : T


[T-Unit]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ () : ()


[T-Bool]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ true : bool
Î“ âŠ¢ false : bool


[T-Int]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ n : i32


[T-Float]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f : f64


[T-Tuple]
Î“ âŠ¢ e1 : T1    Î“ âŠ¢ e2 : T2    ...    Î“ âŠ¢ en : Tn
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (e1, e2, ..., en) : (T1, T2, ..., Tn)


[T-Proj]
Î“ âŠ¢ e : (T1, ..., Ti, ..., Tn)    i âˆˆ {0, ..., n-1}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e.i : Ti


[T-Struct]
Î“ âŠ¢ e1 : T1    ...    Î“ âŠ¢ en : Tn
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ S { f1: e1, ..., fn: en } : S

å…¶ä¸­ S = struct { f1: T1, ..., fn: Tn }


[T-Field]
Î“ âŠ¢ e : S    S.fi = Ti
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e.fi : Ti
```

### 2.2 å¼•ç”¨ç±»å‹è§„åˆ™

**ä¸å¯å˜å¼•ç”¨**:

```text
[T-Ref]
Î“ âŠ¢ e : T    'a fresh    e å¯å€Ÿç”¨
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &e : &'a T


[T-Deref-Imm]
Î“ âŠ¢ e : &'a T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ *e : T


[T-Copy-Ref]
Î“ âŠ¢ e : &'a T    T : Copy
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ *e : T    (å¯ä»¥å¤šæ¬¡ä½¿ç”¨)
```

**å¯å˜å¼•ç”¨**:

```text
[T-MutRef]
Î“ âŠ¢ e : T    'a fresh    e ç‹¬å å¯å€Ÿç”¨    e å¯å˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &mut e : &'a mut T


[T-Deref-Mut]
Î“ âŠ¢ e : &'a mut T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ *e : T


[T-Assign]
Î“ âŠ¢ e1 : &'a mut T    Î“ âŠ¢ e2 : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (*e1 = e2) : ()


[T-Reborrow-Imm]
Î“ âŠ¢ e : &'a mut T    'b âŠ† 'a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &*e : &'b T


[T-Reborrow-Mut]
Î“ âŠ¢ e : &'a mut T    'b âŠ† 'a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &mut *e : &'b mut T
```

### 2.3 é«˜çº§ç±»å‹è§„åˆ™

**Letç»‘å®šä¸æ‰€æœ‰æƒ**:

```text
[T-Let-Move]
Î“ âŠ¢ e1 : T1    Â¬(T1 : Copy)    Î“, x : T1 âŠ¢ e2 : T2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ \ moved(e1) âŠ¢ let x = e1 in e2 : T2


[T-Let-Copy]
Î“ âŠ¢ e1 : T1    T1 : Copy    Î“, x : T1 âŠ¢ e2 : T2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ let x = e1 in e2 : T2
```

**å‡½æ•°ä¸åº”ç”¨**:

```text
[T-Fun]
Î“, x : T1 âŠ¢ e : T2    captures(e) âŠ† Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ fn(x: T1) -> T2 { e } : fn(T1) -> T2


[T-Closure]
Î“, x : T1 âŠ¢ e : T2    captures(e) = {y1: U1, ..., yn: Un}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ |x| e : impl Fn(T1) -> T2


[T-App]
Î“ âŠ¢ e1 : fn(T1, ..., Tn) -> T    Î“ âŠ¢ e2 : T1    ...    Î“ âŠ¢ en+1 : Tn
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ \ moved(e2, ..., en+1) âŠ¢ e1(e2, ..., en+1) : T


[T-Method]
Î“ âŠ¢ e : T    T :: m : fn(&Self, T1, ..., Tn) -> U
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e.m(e1, ..., en) : U
```

**æ§åˆ¶æµ**:

```text
[T-If]
Î“ âŠ¢ e1 : bool    Î“ âŠ¢ e2 : T    Î“ âŠ¢ e3 : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ if e1 { e2 } else { e3 } : T


[T-Match]
Î“ âŠ¢ e : T    Î“, pi âŠ¢ ei : U    (âˆ€i)    patterns(p1, ..., pn) complete for T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ match e { p1 => e1, ..., pn => en } : U


[T-Loop]
Î“ âŠ¢ e : ()    Î“ âŠ¢ (break in e) : T    (å¦‚æœæœ‰)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ loop { e } : T


[T-Break]
Î“ âŠ¢ e : T    (åœ¨loopä¸Šä¸‹æ–‡ä¸­)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ break e : !
```

**æ¨¡å¼åŒ¹é…**:

```text
[P-Wildcard]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ _ : T â‡’ Î“


[P-Var]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x : T â‡’ Î“, x : T


[P-Literal]
v : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ v : T â‡’ Î“


[P-Tuple]
Î“ âŠ¢ p1 : T1 â‡’ Î“1    ...    Î“n-1 âŠ¢ pn : Tn â‡’ Î“n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (p1, ..., pn) : (T1, ..., Tn) â‡’ Î“n


[P-Constructor]
C : (T1, ..., Tn) -> E    Î“ âŠ¢ p1 : T1 â‡’ Î“1    ...    Î“n-1 âŠ¢ pn : Tn â‡’ Î“n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ C(p1, ..., pn) : E â‡’ Î“n


[P-Ref]
Î“ âŠ¢ p : T â‡’ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ref p : &'a T â‡’ Î“'


[P-MutRef]
Î“ âŠ¢ p : T â‡’ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ref mut p : &'a mut T â‡’ Î“'
```

**ç¤ºä¾‹æ¨å¯¼**:

```rust
// å®Œæ•´çš„ç±»å‹æ¨å¯¼æ ‘ç¤ºä¾‹
//
// let x = 42 in x + 1
//
// ç±»å‹æ¨å¯¼æ ‘:
//
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Int]
//              âŠ¢ 42 : i32
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Var]
//              x : i32 âŠ¢ x : i32
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Int]    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Int]
//              âŠ¢ 1 : i32                             x : i32 âŠ¢ 1 : i32
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Add]
//              x : i32 âŠ¢ x + 1 : i32
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Let-Copy]
// âŠ¢ let x = 42 in x + 1 : i32

fn main() {
    let x = 42;
    let result = x + 1;
    println!("{}", result);
}

// æ›´å¤æ‚çš„ç¤ºä¾‹ï¼šå¼•ç”¨æ¨å¯¼
//
// let mut v = vec![1, 2, 3];
// let r = &mut v;
// r.push(4);
//
// ç±»å‹æ¨å¯¼:
//
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//              âŠ¢ vec![1, 2, 3] : Vec<i32>
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Let-Move]
//              v : Vec<i32> âŠ¢ ...
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-MutRef]
//              v : Vec<i32> âŠ¢ &mut v : &'a mut Vec<i32>
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Let-Move]
//              r : &'a mut Vec<i32> âŠ¢ ...
//              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [T-Method]
//              r : &'a mut Vec<i32> âŠ¢ r.push(4) : ()

fn example_ref() {
    let mut v = vec![1, 2, 3];
    let r = &mut v;
    r.push(4);
    println!("{:?}", r);
}
```

---

## 3. æ“ä½œè¯­ä¹‰

### 3.1 å°æ­¥è¯­ä¹‰

**å°æ­¥è¯­ä¹‰è§„åˆ™**: `e, Î£ â†’ e', Î£'`

**åŸºç¡€è§„åˆ™**:

```text
[E-ProjTuple-1]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(v1, v2).0, Î£ â†’ v1, Î£


[E-ProjTuple-2]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(v1, v2).1, Î£ â†’ v2, Î£


[E-FieldAccess]
Î£(l) = struct { ..., fi: vi, ... }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
l.fi, Î£ â†’ vi, Î£


[E-LetV]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let x = v in e, Î£ â†’ e[x := v], Î£


[E-LetE]
e1, Î£ â†’ e1', Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let x = e1 in e2, Î£ â†’ let x = e1' in e2, Î£'


[E-App-Beta]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(fn(x: T) e)(v), Î£ â†’ e[x := v], Î£


[E-App-Fun]
e1, Î£ â†’ e1', Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
e1(e2), Î£ â†’ e1'(e2), Î£'


[E-App-Arg]
e2, Î£ â†’ e2', Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
v(e2), Î£ â†’ v(e2'), Î£'
```

**å¼•ç”¨è§„åˆ™**:

```text
[E-Ref]
l fresh
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
&v, Î£ â†’ &l, Î£ âˆª {l â†¦ v}


[E-MutRef]
l fresh
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
&mut v, Î£ â†’ &mut l, Î£ âˆª {l â†¦ v}


[E-Deref]
Î£(l) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*(&l), Î£ â†’ v, Î£


[E-DerefMut]
Î£(l) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*(&mut l), Î£ â†’ v, Î£


[E-Assign]
Î£(l) = _
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*(&mut l) = v, Î£ â†’ (), Î£[l â†¦ v]


[E-Drop]
Î£(l) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
drop(&mut l), Î£ â†’ (), Î£ \ {l}
```

**æ§åˆ¶æµè§„åˆ™**:

```text
[E-If-True]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if true { e1 } else { e2 }, Î£ â†’ e1, Î£


[E-If-False]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if false { e1 } else { e2 }, Î£ â†’ e2, Î£


[E-If-Cond]
e, Î£ â†’ e', Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if e { e1 } else { e2 }, Î£ â†’ if e' { e1 } else { e2 }, Î£'


[E-Match]
match_pattern(v, pi) = Some(Î¸)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
match v { ..., pi => ei, ... }, Î£ â†’ Î¸(ei), Î£


[E-Match-Scrutinee]
e, Î£ â†’ e', Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
match e { p1 => e1, ... }, Î£ â†’ match e' { p1 => e1, ... }, Î£'


[E-Loop]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
loop { e }, Î£ â†’ (e; loop { e }), Î£


[E-Break]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
break v, Î£ â†’ (exit v), Î£
```

**ä¸Šä¸‹æ–‡è§„åˆ™**:

```text
e, Î£ â†’ e', Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
E[e], Î£ â†’ E[e'], Î£'

å…¶ä¸­ E æ˜¯æ±‚å€¼ä¸Šä¸‹æ–‡:
E ::= [ ] | (E, e) | (v, E) | E.i | &E | &mut E | *E | let x = E in e 
    | E(e) | v(E) | if E { e1 } else { e2 } | match E { ... } | E = e | v = E
```

### 3.2 å¤§æ­¥è¯­ä¹‰

**å¤§æ­¥è¯­ä¹‰ï¼ˆè‡ªç„¶è¯­ä¹‰ï¼‰**: `e, Î£ â‡“ v, Î£'`

```text
[E-Val]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
v, Î£ â‡“ v, Î£


[E-Var]
Î“(x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
x, Î£ â‡“ v, Î£


[E-Tuple]
e1, Î£ â‡“ v1, Î£1    e2, Î£1 â‡“ v2, Î£2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(e1, e2), Î£ â‡“ (v1, v2), Î£2


[E-Proj]
e, Î£ â‡“ (v1, v2), Î£'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
e.0, Î£ â‡“ v1, Î£'


[E-Let]
e1, Î£ â‡“ v1, Î£1    e2[x := v1], Î£1 â‡“ v2, Î£2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let x = e1 in e2, Î£ â‡“ v2, Î£2


[E-App-Big]
e1, Î£ â‡“ fn(x: T) e, Î£1    e2, Î£1 â‡“ v2, Î£2    e[x := v2], Î£2 â‡“ v, Î£3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
e1(e2), Î£ â‡“ v, Î£3


[E-If-Big-True]
e1, Î£ â‡“ true, Î£1    e2, Î£1 â‡“ v, Î£2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if e1 { e2 } else { e3 }, Î£ â‡“ v, Î£2


[E-If-Big-False]
e1, Î£ â‡“ false, Î£1    e3, Î£1 â‡“ v, Î£2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if e1 { e2 } else { e3 }, Î£ â‡“ v, Î£2
```

### 3.3 å †æ¨¡å‹

**å †æŠ½è±¡**:

```text
å † Î£: Loc â†’ Value
ä½ç½® l âˆˆ Loc (æ— é™é›†)
å€¼ v âˆˆ Value

å †æ“ä½œ:
- Î£(l): è¯»å–ä½ç½® l çš„å€¼
- Î£[l â†¦ v]: æ›´æ–°ä½ç½® l ä¸ºå€¼ v
- Î£ \ {l}: é‡Šæ”¾ä½ç½® l
- l fresh: åˆ†é…æ–°ä½ç½®
```

**å †ä¸å˜å¼**:

1. **è‰¯æ„æ€§**: `âˆ€l âˆˆ dom(Î£), Î£(l)` æ˜¯è‰¯ç±»å‹çš„å€¼
2. **æ— æ‚¬å‚æŒ‡é’ˆ**: `âˆ€&l âˆˆ reachable(Î£), l âˆˆ dom(Î£)`
3. **å”¯ä¸€å¯å˜å¼•ç”¨**: `âˆ€&mut l âˆˆ reachable(Î£)`, ä¸å­˜åœ¨å…¶ä»–æŒ‡å‘ l çš„å¼•ç”¨

**å †è¯­ä¹‰ç¤ºä¾‹**:

```rust
// å®Œæ•´çš„å †è¯­ä¹‰æ¨å¯¼
//
// let mut x = Box::new(42);
// let y = &mut x;
// *y = 43;
//
// è¯­ä¹‰æ¨å¯¼:
//
// åˆå§‹: Î£â‚€ = âˆ…
//
// Box::new(42), Î£â‚€
// â†’ (lâ‚ fresh) Box(lâ‚), Î£â‚ where Î£â‚ = {lâ‚ â†¦ 42}
//
// let mut x = Box(lâ‚), Î£â‚
// â†’ Î“ = {x : Box(lâ‚)}, Î£â‚
//
// &mut x, Î£â‚
// â†’ (lâ‚‚ fresh) &mut lâ‚‚, Î£â‚‚ where Î£â‚‚ = {lâ‚ â†¦ 42, lâ‚‚ â†¦ Box(lâ‚)}
//
// let y = &mut lâ‚‚, Î£â‚‚
// â†’ Î“ = {x : Box(lâ‚), y : &mut Box(lâ‚)}, Î£â‚‚
//
// *y = 43, Î£â‚‚
// â†’ *(&mut lâ‚‚) = 43, Î£â‚‚
// â†’ *Box(lâ‚) = 43, Î£â‚‚
// â†’ (), Î£â‚ƒ where Î£â‚ƒ = {lâ‚ â†¦ 43, lâ‚‚ â†¦ Box(lâ‚)}

fn heap_example() {
    let mut x = Box::new(42);
    let y = &mut x;
    *y = Box::new(43);
    println!("{}", **y);
}

// æ›´å¤æ‚çš„å †æ“ä½œç¤ºä¾‹
//
// let v1 = vec![1, 2, 3];
// let v2 = v1;  // ç§»åŠ¨
// drop(v2);
//
// å †çŠ¶æ€å˜åŒ–:
//
// Î£â‚€ = âˆ…
// â†’ Î£â‚ = {lâ‚ â†¦ vec![1,2,3]}     (v1åˆ†é…)
// â†’ Î£â‚ = {lâ‚ â†¦ vec![1,2,3]}     (v1ç§»åŠ¨åˆ°v2, v1å¤±æ•ˆ)
// â†’ Î£â‚‚ = âˆ…                       (v2è¢«drop, lâ‚é‡Šæ”¾)

fn drop_example() {
    let v1 = vec![1, 2, 3];
    let v2 = v1;  // v1 ç§»åŠ¨
    drop(v2);  // v2 è¢«é‡Šæ”¾
    // println!("{:?}", v1);  // âŒ v1 å·²å¤±æ•ˆ
}
```

**å †å¯è¾¾æ€§åˆ†æ**:

```text
reachable(Î£) = fix Î»R. {
    l | l âˆˆ dom(Î£) âˆ§ (
        âˆƒx âˆˆ Î“. x ç›´æ¥å¼•ç”¨ l âˆ¨
        âˆƒl' âˆˆ R. Î£(l') åŒ…å«æŒ‡å‘ l çš„å¼•ç”¨
    )
}
```

---

## 4. æ‰€æœ‰æƒè§„åˆ™

### 4.1 æ‰€æœ‰æƒè½¬ç§»

**æ‰€æœ‰æƒç±»å‹è§„åˆ™**:

```text
[Own-Move]
Î“ âŠ¢ e : T    x âˆ‰ dom(Î“)    Â¬(T : Copy)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ \ used(e), x : T âŠ¢ let x = e


[Own-Use]
Î“, x : T âŠ¢ e : T'    x åœ¨ e ä¸­ä½¿ç”¨ä¸€æ¬¡    Â¬(T : Copy)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ \ {x} âŠ¢ e : T'


[Own-Drop]
Î“, x : T âŠ¢ e : T'    x ä¸åœ¨ e ä¸­ä½¿ç”¨
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ \ {x} âŠ¢ e : T'
```

**æ‰€æœ‰æƒè½¬ç§»è¯­ä¹‰**:

```text
moved(x) = x çš„æ‰€æœ‰æƒå·²è½¬ç§»
used(e) = e ä¸­ä½¿ç”¨çš„æ‰€æœ‰éCopyå˜é‡é›†åˆ

ç¯å¢ƒåˆ†ç¦»: Î“ \ S = {x : T âˆˆ Î“ | x âˆ‰ S}
```

### 4.2 Copy vs Move è¯­ä¹‰

**Copy traitè§„åˆ™**:

```text
[Copy-Trait]
T : Copy    Î“ âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : T    (å¯å¤šæ¬¡ä½¿ç”¨)


[Copy-Types]
i32, i64, f32, f64, bool, char, &T : Copy
ä½† String, Vec<T>, Box<T> : !Copy
```

**Moveè¯­ä¹‰ç¤ºä¾‹**:

```rust
// å½¢å¼åŒ–æ¨å¯¼:
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŠ¢ String::from("hello") : String
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [Own-Move]
// x : String âŠ¢ x : String
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [Own-Use]
// âˆ… âŠ¢ let y = x : String
//
// x åœ¨ç§»åŠ¨åä¸å¯ç”¨

fn move_semantics() {
    let x = String::from("hello");
    let y = x;  // x ç§»åŠ¨åˆ° y, Î“ä»{x:String}å˜ä¸º{y:String}
    println!("{}", y);
    // println!("{}", x);  // âŒ x å·²å¤±æ•ˆ
}

// Copyè¯­ä¹‰ç¤ºä¾‹:
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŠ¢ 42 : i32
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [Copy-Trait]
// x : i32 âŠ¢ x : i32    (å¯å¤šæ¬¡ä½¿ç”¨)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// x : i32, y : i32 âŠ¢ ...

fn copy_semantics() {
    let x = 42;
    let y = x;  // x å¤åˆ¶åˆ° y, Î“åŒ…å«{x:i32, y:i32}
    println!("{} {}", x, y);  // âœ… x ä»å¯ç”¨
}
```

### 4.3 Drop è¯­ä¹‰

**Drop traitè§„åˆ™**:

```text
[Drop-Implicit]
Î“ âŠ¢ e : T    T : Drop    e ç¦»å¼€ä½œç”¨åŸŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T::drop(e) è‡ªåŠ¨è°ƒç”¨


[Drop-Explicit]
Î“ âŠ¢ e : T    T : Drop
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ \ {e} âŠ¢ drop(e) : ()


[Drop-Order]
let x1 = e1; ... ; let xn = en;
dropé¡ºåº: xn, ..., x2, x1  (é€†åº)
```

**Dropè¯­ä¹‰ç¤ºä¾‹**:

```rust
struct Resource {
    id: i32,
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("Dropping resource {}", self.id);
    }
}

// å½¢å¼åŒ–:
// let r1 = Resource { id: 1 };
// let r2 = Resource { id: 2 };
// // ä½œç”¨åŸŸç»“æŸ
//
// Dropé¡ºåº:
// 1. r2.drop()  // è¾“å‡º: "Dropping resource 2"
// 2. r1.drop()  // è¾“å‡º: "Dropping resource 1"

fn drop_order() {
    let r1 = Resource { id: 1 };
    let r2 = Resource { id: 2 };
    println!("Before drop");
    // è¾“å‡ºé¡ºåº:
    // "Before drop"
    // "Dropping resource 2"
    // "Dropping resource 1"
}

// æ˜¾å¼drop
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// r : Resource âŠ¢ drop(r)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âˆ… âŠ¢ () : ()

fn explicit_drop() {
    let r = Resource { id: 3 };
    drop(r);  // æ˜¾å¼é‡Šæ”¾
    // println!("{}", r.id);  // âŒ r å·²è¢«drop
}
```

---

## 5. å€Ÿç”¨æ£€æŸ¥

### 5.1 å€Ÿç”¨è§„åˆ™å½¢å¼åŒ–

**å€Ÿç”¨è§„åˆ™ï¼ˆä¼ ç»Ÿè¯æ³•ä½œç”¨åŸŸï¼‰**:

```text
[Borrow-Shared]
Î“ âŠ¢ e : T    'a fresh    path(e) âˆˆ Loans(Î“)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &e : &'a T
Î“' = Î“ âˆª {Loan(path(e), Shared, 'a)}


[Borrow-Mut]
Î“ âŠ¢ e : T    'a fresh    no_active_loans(path(e), Î“)    e mutable
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &mut e : &'a mut T
Î“' = Î“ âˆª {Loan(path(e), Exclusive, 'a)}


[Borrow-Conflict]
Loan(p, Exclusive, 'a) âˆˆ Î“    Loan(p, _, 'b) âˆˆ Î“    'a âˆ© 'b â‰  âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
é”™è¯¯ï¼šå¯å˜å€Ÿç”¨ä¸å…¶ä»–å€Ÿç”¨å†²çª
```

**å€Ÿç”¨æ£€æŸ¥ç¤ºä¾‹**:

```rust
// å½¢å¼åŒ–æ¨å¯¼:
//
// let mut x = String::from("hello");
// Î“â‚€ = {x : String}
//
// let r1 = &x;
// Î“â‚ = {x : String, Loan(x, Shared, 'a)}
//
// let r2 = &x;
// Î“â‚‚ = {x : String, Loan(x, Shared, 'a), Loan(x, Shared, 'b)}
// âœ… å¤šä¸ªå…±äº«å€Ÿç”¨å…è®¸
//
// let r3 = &mut x;
// âŒ é”™è¯¯ï¼šx å·²æœ‰å…±äº«å€Ÿç”¨ï¼Œä¸èƒ½åˆ›å»ºå¯å˜å€Ÿç”¨

fn borrow_rules() {
    let mut x = String::from("hello");
    
    {
        let r1 = &x;
        let r2 = &x;
        println!("{} {}", r1, r2);
    } // Loansç»“æŸ
    
    let r3 = &mut x;
    r3.push_str(" world");
    println!("{}", r3);
}
```

### 5.2 Polonius å€Ÿç”¨æ£€æŸ¥å™¨

**Polonius: åŸºäºäº‹å®çš„å€Ÿç”¨æ£€æŸ¥**:

Poloniusä½¿ç”¨æ•°æ®æµåˆ†æä»£æ›¿è¯æ³•ä½œç”¨åŸŸï¼š

```text
æ ¸å¿ƒå…³ç³»:
- Origin(r, o): å¼•ç”¨rçš„æ¥æºæ˜¯o
- Loan(o, l): æ¥æºoåŒ…å«è´·æ¬¾l
- Outlives(o1, o2): o1çš„ç”Ÿå‘½å‘¨æœŸé•¿äºo2
- LiveAt(r, p): å¼•ç”¨råœ¨ç¨‹åºç‚¹på¤„æ´»è·ƒ

å€Ÿç”¨å†²çªæ£€æµ‹:
âˆ€l âˆˆ Loans, p âˆˆ Points:
    if Loan(o, l) âˆ§ LiveAt(r, p) âˆ§ Origin(r, o) âˆ§ conflicts(l, use_at(p))
    then ERROR
```

**Poloniusç¤ºä¾‹**:

```rust
// Poloniuså…è®¸æ›´ç²¾ç¡®çš„å€Ÿç”¨åˆ†æ
//
// ä¼ ç»Ÿå€Ÿç”¨æ£€æŸ¥å™¨æ‹’ç»ï¼Œä½†Poloniusæ¥å—ï¼š

fn polonius_example() {
    let mut data = vec![1, 2, 3];
    let r;
    
    {
        let x = &mut data;
        r = &x[0];  // r å€Ÿç”¨ x
    } // x ç»“æŸï¼Œä½† r ä»ç„¶å¼•ç”¨ data
    
    // ä¼ ç»Ÿå€Ÿç”¨æ£€æŸ¥ï¼šâŒ r çš„ç”Ÿå‘½å‘¨æœŸè¶…è¿‡ x
    // Poloniusï¼šâœ… r å®é™…ä¸Šå€Ÿç”¨ dataï¼Œè€Œä¸æ˜¯ x
    
    println!("{}", r);
}

// Poloniusçš„å…³é”®æ´å¯Ÿï¼š
// Origin(r, origin_data)  è€Œä¸æ˜¯  Origin(r, origin_x)
```

### 5.3 NLL (Non-Lexical Lifetimes)

**éè¯æ³•ç”Ÿå‘½å‘¨æœŸ**:

NLLå…è®¸ç”Ÿå‘½å‘¨æœŸåœ¨æœ€åä¸€æ¬¡ä½¿ç”¨åç»“æŸï¼Œè€Œä¸æ˜¯åœ¨ä½œç”¨åŸŸç»“æŸæ—¶ï¼š

```text
[NLL-LastUse]
Î“, x : &'a T âŠ¢ e : U    last_use(x, e) = p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
'a åœ¨ç¨‹åºç‚¹ p ä¹‹åç»“æŸ


[NLL-Conflict]
Loan(p, Exclusive, 'a) âˆˆ Î“    last_use('a) < first_use('b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
'a å’Œ 'b ä¸å†²çª
```

**NLLç¤ºä¾‹**:

```rust
// æ²¡æœ‰NLLï¼šâŒ
// let mut data = vec![1, 2, 3];
// let r = &data[0];
// data.push(4);  // âŒ dataè¢«å€Ÿç”¨
// println!("{}", r);

// æœ‰NLLï¼šâœ…
fn nll_example() {
    let mut data = vec![1, 2, 3];
    let r = &data[0];
    println!("{}", r);  // r çš„æœ€åä½¿ç”¨
    
    // NLL: r çš„ç”Ÿå‘½å‘¨æœŸåœ¨æ­¤ç»“æŸ
    data.push(4);  // âœ… dataä¸å†è¢«å€Ÿç”¨
    println!("{:?}", data);
}

// NLLçš„å½¢å¼åŒ–è¯­ä¹‰:
//
// Î“â‚€ = {data : Vec<i32>}
// 
// let r = &data[0];
// Î“â‚ = {data : Vec<i32>, r : &'a i32, Loan(data, Shared, 'a)}
//
// println!("{}", r);  // last_use(r) at point pâ‚
// 
// // NLL: 'a åœ¨ pâ‚ ä¹‹åç»“æŸ
// Î“â‚‚ = {data : Vec<i32>}  // Loan å·²ç»“æŸ
//
// data.push(4);  // âœ… æ²¡æœ‰æ´»è·ƒçš„ Loan
```

---

## 6. ç”Ÿå‘½å‘¨æœŸæ¨æ–­

### 6.1 ç”Ÿå‘½å‘¨æœŸçº¦æŸç³»ç»Ÿ

**ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼ˆLifetime Constraintsï¼‰**:

```text
[Life-Var]
Î“(x) = &'a T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x : &'a T


[Life-Sub]
Î“ âŠ¢ e : &'a T    'a : 'b    ('a outlives 'b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : &'b T


[Life-Ref]
Î“ âŠ¢ e : T    'a covers scope(e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &e : &'a T


[Life-Fun]
Î“, x : &'a T1 âŠ¢ e : &'b T2    'a : 'b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ fn(x: &'a T1) -> &'b T2


[Life-Trans]
'a : 'b    'b : 'c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
'a : 'c
```

**çº¦æŸæ±‚è§£**:

ç”Ÿå‘½å‘¨æœŸæ¨æ–­æ˜¯çº¦æŸæ±‚è§£é—®é¢˜ï¼š

```text
æ”¶é›†çº¦æŸ: Î“ âŠ¢ e : T  â‡’  C (çº¦æŸé›†)
æ±‚è§£: solve(C) = Ïƒ (ç”Ÿå‘½å‘¨æœŸæ›¿æ¢)
éªŒè¯: Ïƒ(C) å…¨éƒ¨æ»¡è¶³
```

### 6.2 åŒºåŸŸç±»å‹ç³»ç»Ÿ

**åŒºåŸŸï¼ˆRegionsï¼‰**:

Rustä½¿ç”¨åŒºåŸŸç±»å‹ç³»ç»Ÿæ¥è·Ÿè¸ªå¼•ç”¨çš„æœ‰æ•ˆæ€§ï¼š

```text
åŒºåŸŸ Ï ::= 'a | 'static | concrete_scope

åŒºåŸŸå…³ç³»:
- Ï1 âŠ† Ï2: Ï1 è¢« Ï2 åŒ…å«
- Ï1 âŠ“ Ï2: Ï1 å’Œ Ï2 çš„äº¤é›†
- Ï1 âŠ” Ï2: Ï1 å’Œ Ï2 çš„å¹¶é›†
```

**åŒºåŸŸæ¨æ–­ç¤ºä¾‹**:

```rust
// å½¢å¼åŒ–:
// x : &'a str, y : &'b str
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// longest : fn(&'a str, &'a str) -> &'a str
//
// çº¦æŸ: 'a = min('a_x, 'a_y) = 'a_x âŠ“ 'a_y

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// è°ƒç”¨ç‚¹æ¨æ–­:
// s1 : String, 'static : 's1  (æ ˆä¸Šç”Ÿå‘½å‘¨æœŸ)
// s2 : String, 'static : 's2
// result : &'r str, where 'r = 's1 âŠ“ 's2

fn main() {
    let s1 = String::from("long string");  // 's1 å¼€å§‹
    {
        let s2 = String::from("short");  // 's2 å¼€å§‹
        let result = longest(&s1, &s2);  // 'r = 's1 âŠ“ 's2 = 's2
        println!("{}", result);
    } // 's2 ç»“æŸ, 'r ç»“æŸ
} // 's1 ç»“æŸ
```

### 6.3 ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

**çœç•¥è§„åˆ™ï¼ˆLifetime Elisionï¼‰**:

```text
[Elision-Input]
fn f(x: &T) -> ...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ¨æ–­ä¸º: fn f<'a>(x: &'a T) -> ...


[Elision-Output-Single]
fn f<'a>(x: &'a T) -> &U
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ¨æ–­ä¸º: fn f<'a>(x: &'a T) -> &'a U


[Elision-Method-Self]
fn f(&self, x: &T) -> &U
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ¨æ–­ä¸º: fn f<'a, 'b>(&'a self, x: &'b T) -> &'a U
```

**çœç•¥ç¤ºä¾‹**:

```rust
// æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ
fn explicit<'a>(x: &'a str) -> &'a str {
    x
}

// çœç•¥ç”Ÿå‘½å‘¨æœŸï¼ˆç­‰ä»·ï¼‰
fn elided(x: &str) -> &str {
    x
}

// æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸçœç•¥
struct Parser<'a> {
    data: &'a str,
}

impl<'a> Parser<'a> {
    // fn parse(&self, input: &str) -> &str
    // æ¨æ–­ä¸º: fn parse<'b>(&'a self, input: &'b str) -> &'a str
    fn parse(&self, input: &str) -> &str {
        self.data
    }
}
```

---

## 7. ç±»å‹å¥å…¨æ€§

### 7.1 ç±»å‹ä¿å…¨æ€§è¯æ˜

**ä¿å…¨æ€§å®šç†ï¼ˆPreservation Theoremï¼‰**:

```text
å®šç† (Type Preservation):
å¦‚æœ Î“ âŠ¢ e : T ä¸” e, Î£ â†’ e', Î£'
åˆ™ Î“ âŠ¢ e' : T

è¯æ˜ï¼šå¯¹ e â†’ e' çš„æ¨å¯¼è¿›è¡Œç»“æ„å½’çº³
```

**è¯æ˜è‰å›¾**:

```text
æƒ…å†µ 1: [E-LetV]
let x = v in e, Î£ â†’ e[x := v], Î£

å·²çŸ¥:
1. Î“ âŠ¢ let x = v in e : T    (å‡è®¾)
2. ç”± [T-Let]: Î“ âŠ¢ v : T1, Î“,x:T1 âŠ¢ e : T

éœ€è¯: Î“ âŠ¢ e[x := v] : T

ç”±æ›¿æ¢å¼•ç† (Substitution Lemma):
å¦‚æœ Î“,x:T1 âŠ¢ e : T ä¸” Î“ âŠ¢ v : T1
åˆ™ Î“ âŠ¢ e[x := v] : T  âœ“


æƒ…å†µ 2: [E-App-Beta]
(fn(x: T1) e)(v), Î£ â†’ e[x := v], Î£

å·²çŸ¥:
1. Î“ âŠ¢ (fn(x: T1) e)(v) : T2
2. ç”± [T-App] å’Œ [T-Fun]:
   Î“,x:T1 âŠ¢ e : T2
   Î“ âŠ¢ v : T1

éœ€è¯: Î“ âŠ¢ e[x := v] : T2

ç”±æ›¿æ¢å¼•ç†: âœ“


æƒ…å†µ 3: [E-Deref]
*(&l), Î£ â†’ v, Î£ where Î£(l) = v

å·²çŸ¥:
1. Î“ âŠ¢ *(&l) : T
2. ç”± [T-Deref]: Î“ âŠ¢ &l : &'a T
3. ç”±å †è‰¯æ„æ€§: Î£(l) = v ä¸” Î“ âŠ¢ v : T

éœ€è¯: Î“ âŠ¢ v : T  âœ“ (ç”±å †è‰¯æ„æ€§)
```

### 7.2 è¿›å±•æ€§è¯æ˜

**è¿›å±•æ€§å®šç†ï¼ˆProgress Theoremï¼‰**:

```text
å®šç† (Progress):
å¦‚æœ âˆ… âŠ¢ e : T ä¸” e è‰¯æ„
åˆ™ e æ˜¯å€¼ æˆ– å­˜åœ¨ e', Î£' ä½¿å¾— e, Î£ â†’ e', Î£'

è¯æ˜ï¼šå¯¹ âˆ… âŠ¢ e : T çš„æ¨å¯¼è¿›è¡Œç»“æ„å½’çº³
```

**è¯æ˜è‰å›¾**:

```text
æƒ…å†µ 1: e = v
åˆ™ e æ˜¯å€¼ âœ“


æƒ…å†µ 2: e = let x = e1 in e2
ç”±å½’çº³å‡è®¾å¯¹ e1:
- å¦‚æœ e1 æ˜¯å€¼ v, åˆ™ [E-LetV] é€‚ç”¨
- å¦‚æœ e1 â†’ e1', åˆ™ [E-LetE] é€‚ç”¨
ä¸¤ç§æƒ…å†µéƒ½å¯ä»¥è¿›ä¸€æ­¥æ±‚å€¼ âœ“


æƒ…å†µ 3: e = e1(e2)
ç”±å½’çº³å‡è®¾:
- å¦‚æœ e1 ä¸æ˜¯å€¼, åˆ™ [E-App-Fun] é€‚ç”¨
- å¦‚æœ e1 = fn(x:T)e ä¸” e2 ä¸æ˜¯å€¼, åˆ™ [E-App-Arg] é€‚ç”¨
- å¦‚æœ e1 = fn(x:T)e ä¸” e2 = v, åˆ™ [E-App-Beta] é€‚ç”¨
æ‰€æœ‰æƒ…å†µéƒ½å¯ä»¥è¿›ä¸€æ­¥æ±‚å€¼ âœ“


æƒ…å†µ 4: e = if e1 { e2 } else { e3 }
ç”±å½’çº³å‡è®¾å¯¹ e1:
- å¦‚æœ e1 = true, åˆ™ [E-If-True] é€‚ç”¨
- å¦‚æœ e1 = false, åˆ™ [E-If-False] é€‚ç”¨
- å¦‚æœ e1 ä¸æ˜¯å€¼, åˆ™ [E-If-Cond] é€‚ç”¨
æ‰€æœ‰æƒ…å†µéƒ½å¯ä»¥è¿›ä¸€æ­¥æ±‚å€¼ âœ“
```

### 7.3 å†…å­˜å®‰å…¨è¯æ˜

**å†…å­˜å®‰å…¨å®šç†ï¼ˆMemory Safety Theoremï¼‰**:

```text
å®šç† (Memory Safety):
å¦‚æœ Î“ âŠ¢ e : T, å † Î£ è‰¯æ„, ä¸” e, Î£ â†’* v, Î£'
åˆ™:
1. æ— æ‚¬å‚æŒ‡é’ˆ: âˆ€&l âˆˆ reachable(Î£'), l âˆˆ dom(Î£')
2. æ— æ•°æ®ç«äº‰: æ‰€æœ‰å¯å˜å€Ÿç”¨æ˜¯ç‹¬å çš„
3. ç±»å‹å®‰å…¨: Î£'(l) çš„ç±»å‹ä¸ Î“ ä¸€è‡´

è¯æ˜ï¼šç”±å€Ÿç”¨æ£€æŸ¥ + æ‰€æœ‰æƒè§„åˆ™ + ç±»å‹å¥å…¨æ€§
```

**è¯æ˜è¦ç‚¹**:

```text
1. æ— æ‚¬å‚æŒ‡é’ˆï¼š
   - æ‰€æœ‰æƒç¡®ä¿å€¼åœ¨ä½¿ç”¨å®Œæ¯•åæ‰è¢«é‡Šæ”¾
   - å€Ÿç”¨æ£€æŸ¥ç¡®ä¿å¼•ç”¨ä¸è¶…è¿‡å€¼çš„ç”Ÿå‘½å‘¨æœŸ
   - ç”± [Own-Drop] å’Œ [Borrow-Use] ä¿è¯

2. æ— æ•°æ®ç«äº‰ï¼š
   - [Borrow-Mut] ç¡®ä¿å¯å˜å€Ÿç”¨æ˜¯ç‹¬å çš„
   - [Borrow-Conflict] æ£€æµ‹å¹¶æ‹’ç»å†²çªçš„å€Ÿç”¨
   - ç”±å€Ÿç”¨æ£€æŸ¥å™¨é™æ€éªŒè¯

3. ç±»å‹å®‰å…¨ï¼š
   - ç”±ç±»å‹ä¿å…¨æ€§å’Œè¿›å±•æ€§å®šç†ä¿è¯
   - å †è‰¯æ„æ€§ç»´æŠ¤ç±»å‹ä¸å˜å¼
```

---

## 8. åˆ†ç¦»é€»è¾‘ä¸ RustBelt

### 8.1 åˆ†ç¦»é€»è¾‘åŸºç¡€

**åˆ†ç¦»é€»è¾‘ï¼ˆSeparation Logicï¼‰**:

åˆ†ç¦»é€»è¾‘æ‰©å±•éœå°”é€»è¾‘ï¼Œç”¨äºæ¨ç†å †ï¼š

```text
æ–­è¨€ P, Q ::=
    | emp                ç©ºå †
    | e â†¦ v              å•ç‚¹å †ï¼ˆe æŒ‡å‘ vï¼‰
    | P * Q              åˆ†ç¦»åˆå–ï¼ˆP å’Œ Q å ç”¨ä¸åŒå †éƒ¨åˆ†ï¼‰
    | P â”€âˆ— Q              åˆ†ç¦»è•´å«ï¼ˆé­”æ£’ï¼‰
    | P âˆ§ Q              æ™®é€šåˆå–
    | âˆƒx. P              å­˜åœ¨é‡è¯

å…³é”®è§„åˆ™:
{P} c {Q}    {R} c' {S}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Frame Rule)
{P * R} c {Q * R}
```

### 8.2 Iris æ¡†æ¶

**Iris: é«˜é˜¶å¹¶å‘åˆ†ç¦»é€»è¾‘**:

```text
Iris æ–­è¨€:
- æŒä¹…æ–­è¨€ (Persistent): â–¡P
- ä¸å˜å¼ (Invariants): inv N P
- é¬¼çŠ¶æ€ (Ghost State): own Î³ a

Iris è§„åˆ™:
[Inv-Alloc]
P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|={E}=> inv N P

[Inv-Access]
inv N P    E1 âŠ† E2    N âˆ‰ E1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|={E2,E1}=> P * (P ={E1,E2}=âˆ— True)
```

### 8.3 RustBelt æ¨¡å‹

**RustBelt: Rustçš„å½¢å¼åŒ–éªŒè¯**:

RustBelt ä½¿ç”¨ Iris æ¡†æ¶å½¢å¼åŒ– Rust çš„ç±»å‹ç³»ç»Ÿå’Œå®‰å…¨æ€§ï¼š

```text
ç±»å‹è¯­ä¹‰ (Type Semantics):
âŸ¦TâŸ§ : Val â†’ iProp

å…³é”®ç±»å‹ï¼š
âŸ¦&'a TâŸ§(v) â‰œ âˆƒl. v = &l * l â†¦ âŸ¦TâŸ§ * lifetime('a, l)
âŸ¦&'a mut TâŸ§(v) â‰œ âˆƒl. v = &mut l * exclusive(l, âŸ¦TâŸ§) * lifetime('a, l)
âŸ¦Box<T>âŸ§(v) â‰œ âˆƒl. v = Box(l) * l â†¦ âŸ¦TâŸ§ * own(l)

å€Ÿç”¨è§„åˆ™éªŒè¯:
{âŸ¦&TâŸ§(v)} read(v) {Î»r. âŸ¦TâŸ§(r) * âŸ¦&TâŸ§(v)}
{âŸ¦&mut TâŸ§(v)} write(v, w) {Î»_. âŸ¦&mut TâŸ§(v)}
```

---

## 9. Oxide: Rust çš„æ ¸å¿ƒæ¼”ç®—

### 9.1 Oxide è¯­æ³•

**Oxide: Rust çš„æœ€å°æ ¸å¿ƒ**:

```text
ç±»å‹ Ï„ ::= i32 | bool | &Ï Ï„ | &Ï mut Ï„ | ...
è¡¨è¾¾å¼ e ::= x | n | &e | *e | let x = e in e | ...
åŒºåŸŸ Ï ::= Î± | Ï âŠ“ Ï | ...
```

### 9.2 Oxide ç±»å‹ç³»ç»Ÿ

**Oxide çš„ç±»å‹è§„åˆ™**:

```text
[Oxide-Borrow]
Î”; Î“ âŠ¢ e : Ï„ @ Ï    fresh Ï'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î”; Î“ âŠ¢ &e : &Ï' Ï„ @ Ï âŠ“ Ï'
```

### 9.3 Oxide è¯æ˜

Oxide æä¾›äº† Rust å®‰å…¨æ€§çš„å¯æœºå™¨æ£€æŸ¥è¯æ˜ã€‚

---

## 10. é«˜çº§ä¸»é¢˜

### 10.1 å‹å˜ä¸å­ç±»å‹

**å‹å˜ï¼ˆVarianceï¼‰**:

```text
åå˜ (Covariant): T <: U â‡’ F<T> <: F<U>
é€†å˜ (Contravariant): T <: U â‡’ F<U> <: F<T>
ä¸å˜ (Invariant): T â‰  U â‡’ F<T> å’Œ F<U> ä¸å¯æ¯”
```

### 10.2 Higher-Ranked Types

**é«˜é˜¶ç±»å‹ï¼ˆHRTï¼‰**:

```text
âˆ€'a. &'a T  vs  &'a T for some 'a

for<'a> fn(&'a T) -> &'a U  (HRT)
vs fn(&'a T) -> &'a U  (æ™®é€š)
```

### 10.3 æ•ˆåº”ç³»ç»Ÿ

**æ•ˆåº”ï¼ˆEffectsï¼‰**:

æœªæ¥çš„ Rust å¯èƒ½å¼•å…¥æ•ˆåº”ç³»ç»Ÿï¼š

```text
fn f() -> T throws E
fn g() async -> T
```

### 10.4 ç±»å‹æ¼”ç®—çš„å…ƒç†è®ºæ€§è´¨

**å¼ºè§„èŒƒåŒ–ï¼ˆStrong Normalizationï¼‰**:

ç±»å‹è‰¯å¥½çš„è¡¨è¾¾å¼æ€»ä¼šç»ˆæ­¢ï¼š

```text
å®šç† (Strong Normalization):
å¦‚æœ Î“ âŠ¢ e : Ï„ï¼Œåˆ™ä¸å­˜åœ¨æ— é™å½’çº¦åºåˆ— e â†’ eâ‚ â†’ eâ‚‚ â†’ ...

è¯æ˜sketch:
1. å®šä¹‰é€»è¾‘å…³ç³» âŸ¦Ï„âŸ§ âŠ† Terms
2. è¯æ˜åŸºç¡€æƒ…å†µï¼ˆå˜é‡ã€å¸¸é‡ï¼‰
3. å½’çº³æƒ…å†µï¼ˆå‡½æ•°åº”ç”¨ã€letç»‘å®šï¼‰
4. ä½¿ç”¨å€™é€‰å¼•ç† (Candidate Lemma)
```

**åˆæµæ€§ï¼ˆConfluenceï¼‰**:

å½’çº¦é¡ºåºä¸å½±å“æœ€ç»ˆç»“æœï¼š

```text
å®šç† (Church-Rosser):
å¦‚æœ e â†’* eâ‚ ä¸” e â†’* eâ‚‚ï¼Œ
åˆ™å­˜åœ¨ eâ‚ƒ ä½¿å¾— eâ‚ â†’* eâ‚ƒ ä¸” eâ‚‚ â†’* eâ‚ƒ

è¯æ˜æ–¹æ³•: å¹³è¡Œå½’çº¦æŠ€æœ¯ (Parallel Reduction)
```

**å¯åˆ¤å®šæ€§ï¼ˆDecidabilityï¼‰**:

```text
å®šç† (Type Checking Decidability):
ç»™å®š Î“, e, Ï„ï¼Œåˆ¤å®š Î“ âŠ¢ e : Ï„ æ˜¯å¯åˆ¤å®šçš„

å®šç† (Type Inference Decidability):
å¯¹äº Hindley-Milner å­é›†ï¼Œç±»å‹æ¨æ–­æ˜¯å¯åˆ¤å®šçš„
```

### 10.5 å¹¶å‘ä¸åŒæ­¥çš„å½¢å¼åŒ–

**æ•°æ®ç«äº‰è‡ªç”±ï¼ˆData-Race Freedomï¼‰**:

Rust ä¿è¯æ— æ•°æ®ç«äº‰ï¼š

```text
å®šç† (Data-Race Freedom):
å¦‚æœç¨‹åºç±»å‹æ£€æŸ¥é€šè¿‡ï¼Œåˆ™ä¸å­˜åœ¨æ•°æ®ç«äº‰

å½¢å¼åŒ–å®šä¹‰:
æ•°æ®ç«äº‰ ::= âˆƒ loc, threads tâ‚ â‰  tâ‚‚.
  - tâ‚, tâ‚‚ åŒæ—¶è®¿é—® loc
  - è‡³å°‘ä¸€ä¸ªæ˜¯å†™è®¿é—®
  - æ²¡æœ‰åŒæ­¥æœºåˆ¶

è¯æ˜ç­–ç•¥:
1. å€Ÿç”¨è§„åˆ™æ’é™¤å…±äº«å¯å˜å¼•ç”¨
2. Send/Sync trait æ§åˆ¶çº¿ç¨‹é—´ä¼ é€’
3. ç±»å‹ç³»ç»Ÿä¿è¯äº’æ–¥è®¿é—®
```

**æ— æ­»é”ä¿è¯ï¼ˆDeadlock Freedomï¼‰**:

è™½ç„¶ Rust ä¸ä¿è¯æ— æ­»é”ï¼Œä½†å¯ä»¥é€šè¿‡ç±»å‹ç¼–ç ï¼š

```text
ç±»å‹çº§é”é¡ºåº:
struct Lock<const N: usize, T> { ... }

impl<const N: usize, T> Lock<N, T> {
    fn acquire<const M: usize>(&self, other: &Lock<M, U>) 
    where 
        [(); N.cmp(M)]: ,  // ç¼–è¯‘æ—¶æ£€æŸ¥é”é¡ºåº
    { ... }
}
```

### 10.6 å¼‚æ­¥çš„å½¢å¼åŒ–

**Future çš„ç±»å‹è¯­ä¹‰**:

```text
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}

å½¢å¼åŒ–è¯­ä¹‰:
âŸ¦Future<T>âŸ§ â‰œ State Ã— (State â†’ Option<T> + State)

å…¶ä¸­:
- State: Future çš„å†…éƒ¨çŠ¶æ€
- None: å°šæœªå°±ç»ª
- Some(t): å·²å®Œæˆï¼Œç»“æœä¸º t
```

**async/await çš„è½¬æ¢è§„åˆ™**:

```text
[Async-Transform]
async fn f() -> T { body }
  â‡
fn f() -> impl Future<Output = T> {
    async move { body }
}

[Await-Transform]
let x = fut.await;
  â‡
let x = {
    let mut __fut = fut;
    loop {
        match Pin::new(&mut __fut).poll(&mut cx) {
            Poll::Ready(v) => break v,
            Poll::Pending => yield,
        }
    }
};
```

### 10.7 Unsafe ä»£ç çš„å½¢å¼åŒ–

**Unsafe è¾¹ç•Œ**:

```text
Unsafe å—çš„è¯­ä¹‰:
{P} unsafe { code } {Q}

å…¶ä¸­:
- P: å‰ç½®æ¡ä»¶ï¼ˆè°ƒç”¨è€…å¿…é¡»ä¿è¯ï¼‰
- Q: åç½®æ¡ä»¶ï¼ˆunsafeå—å¿…é¡»ä¿è¯ï¼‰

å…³é”®ä¸å˜å¼:
1. å¼•ç”¨æœ‰æ•ˆæ€§ (Reference Validity)
2. æ•°æ®ç«äº‰è‡ªç”± (Data-Race Freedom)  
3. æ— æ‚¬å‚æŒ‡é’ˆ (No Dangling Pointers)
```

**Stacked Borrows æ¨¡å‹**:

```text
Stacked Borrows: Unsafe ä»£ç çš„å½¢å¼åŒ–æ¨¡å‹

çŠ¶æ€: Memory = Loc â†’ Stack<Tag>

å…³é”®è§„åˆ™:
[SB-SharedRead]
  Stack = [..., (SharedRO, t), ...]
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  å¯ä»¥ä½¿ç”¨æ ‡ç­¾ t è¿›è¡Œè¯»å–

[SB-UniqueWrite]
  Stack = [..., (Unique, t)]
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  å¯ä»¥ä½¿ç”¨æ ‡ç­¾ t è¿›è¡Œå†™å…¥

[SB-Invalidate]
  è¿åè§„åˆ™ â‡’ æœªå®šä¹‰è¡Œä¸º (UB)
```

### 10.8 å¸¸é‡æ³›å‹çš„å½¢å¼åŒ–

**å¸¸é‡æ³›å‹ç±»å‹è§„åˆ™**:

```text
[Const-Generic]
Î”; Î“ âŠ¢ e : T<n>    n âˆˆ Nat
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î”; Î“ âŠ¢ e : T<n>

[Const-Unify]
T<n> = T<m>  â‡”  n = m

ä¾‹å­:
struct Array<T, const N: usize> { ... }

ç±»å‹è§„åˆ™:
Array<i32, 5> â‰  Array<i32, 6>
```

**å¸¸é‡æ±‚å€¼è¯­ä¹‰**:

```text
const fn çš„è¯­ä¹‰:
[Const-Eval]
  e â‡“ v    v æ˜¯ç¼–è¯‘æ—¶å¯è®¡ç®—çš„å€¼
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const C: T = e;  â‡  C = v

é™åˆ¶:
- æ—  I/O
- æ— å †åˆ†é…ï¼ˆRust 1.90 å‰ï¼‰
- ç¡®å®šæ€§è®¡ç®—
```

---

## 11. å®è·µï¼šå½¢å¼åŒ–éªŒè¯å·¥å…·

### 11.1 Prusti

**Prusti: Rust çš„æ¼”ç»éªŒè¯å™¨**:

```rust
#[requires(x > 0)]
#[ensures(result > x)]
fn increment(x: i32) -> i32 {
    x + 1
}
```

### 11.2 Creusot

**Creusot: Rust åˆ° Why3 çš„ç¿»è¯‘**:

```rust
#[ensures(result@ == x@)]
fn identity(x: i32) -> i32 {
    x
}
```

### 11.3 Verus

**Verus: Rust çš„éªŒè¯ç³»ç»Ÿ**:

```rust
proof fn lemma_double(x: int)
    ensures x + x == 2 * x
{}
```

### 11.4 Kani: æ¨¡å‹æ£€æŸ¥å™¨

**Kani: Rust çš„æœ‰ç•Œæ¨¡å‹æ£€æŸ¥**:

```rust
#[kani::proof]
fn verify_add_no_overflow() {
    let x: u8 = kani::any();
    let y: u8 = kani::any();
    
    kani::assume(x < 128);
    kani::assume(y < 128);
    
    let z = x + y;
    assert!(z < 256);  // Kani éªŒè¯æ­¤æ–­è¨€æ€»æ˜¯æˆç«‹
}
```

**Kani çš„éªŒè¯ç­–ç•¥**:

```text
æœ‰ç•Œæ¨¡å‹æ£€æŸ¥:
1. ç¬¦å·æ‰§è¡Œç”Ÿæˆè·¯å¾„æ¡ä»¶
2. è½¬æ¢ä¸ºSAT/SMTå…¬å¼
3. æ±‚è§£å™¨æ£€æŸ¥å¯æ»¡è¶³æ€§
4. ç”Ÿæˆåä¾‹æˆ–è¯æ˜æ­£ç¡®æ€§

ä¼˜åŠ¿:
- å…¨è‡ªåŠ¨ï¼ˆæ— éœ€æ‰‹åŠ¨è§„èŒƒï¼‰
- å¯ä»¥æ£€æµ‹è¿è¡Œæ—¶é”™è¯¯
- å¿«é€Ÿåé¦ˆ

å±€é™:
- æœ‰ç•Œæ€§ï¼ˆéœ€è¦è®¾ç½®æ·±åº¦é™åˆ¶ï¼‰
- çŠ¶æ€ç©ºé—´çˆ†ç‚¸
```

### 11.5 å½¢å¼åŒ–éªŒè¯å®æˆ˜æ¡ˆä¾‹

**æ¡ˆä¾‹1ï¼šå®‰å…¨çš„å‘é‡ç´¢å¼•**:

```rust
use prusti_contracts::*;

#[requires(index < vec.len())]
#[ensures(result == vec[index])]
fn safe_get<T: Copy>(vec: &Vec<T>, index: usize) -> T {
    vec[index]
}

// éªŒè¯çš„è°ƒç”¨
fn verified_caller() {
    let v = vec![1, 2, 3];
    let idx = 1;
    
    prusti_assert!(idx < v.len());  // å‰ç½®æ¡ä»¶æˆç«‹
    let val = safe_get(&v, idx);
    prusti_assert!(val == 2);       // åç½®æ¡ä»¶æˆç«‹
}
```

**æ¡ˆä¾‹2ï¼šäºŒåˆ†æŸ¥æ‰¾çš„å®Œå…¨éªŒè¯**:

```rust
use prusti_contracts::*;

#[pure]
#[requires(i < arr.len() && j < arr.len())]
fn is_sorted_range<T: Ord>(arr: &[T], i: usize, j: usize) -> bool {
    forall(|k: usize, l: usize| 
        (i <= k && k < l && l <= j) ==> arr[k] <= arr[l]
    )
}

#[requires(is_sorted_range(arr, 0, arr.len()))]
#[ensures(match result {
    Ok(idx) => idx < arr.len() && arr[idx] == target,
    Err(idx) => idx <= arr.len() && 
                forall(|i: usize| i < arr.len() ==> arr[i] != target),
})]
fn binary_search<T: Ord>(arr: &[T], target: &T) -> Result<usize, usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    #[invariant(left <= right && right <= arr.len())]
    #[invariant(forall(|i: usize| i < left ==> arr[i] < target))]
    #[invariant(forall(|i: usize| i >= right ==> arr[i] > target))]
    while left < right {
        body_invariant!(left < right);
        
        let mid = left + (right - left) / 2;
        assert!(mid < arr.len());
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Less => {
                left = mid + 1;
            },
            std::cmp::Ordering::Greater => {
                right = mid;
            },
            std::cmp::Ordering::Equal => {
                return Ok(mid);
            },
        }
    }
    
    Err(left)
}
```

**æ¡ˆä¾‹3ï¼šå¹¶å‘è®¡æ•°å™¨çš„éªŒè¯**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

/// å¹¶å‘è®¡æ•°å™¨
/// 
/// ä¸å˜å¼: count.load(Ordering::SeqCst) 
///        == æ‰€æœ‰ increment() è°ƒç”¨æ¬¡æ•° - æ‰€æœ‰ decrement() è°ƒç”¨æ¬¡æ•°
pub struct Counter {
    count: AtomicUsize,
}

impl Counter {
    /// åˆ›å»ºè®¡æ•°å™¨
    /// 
    /// åç½®æ¡ä»¶: counter.get() == 0
    pub fn new() -> Self {
        Counter {
            count: AtomicUsize::new(0),
        }
    }
    
    /// å¢åŠ è®¡æ•°
    /// 
    /// åç½®æ¡ä»¶: counter.get() == old(counter.get()) + 1
    /// çº¿ç¨‹å®‰å…¨: å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹å¹¶å‘è°ƒç”¨
    pub fn increment(&self) {
        self.count.fetch_add(1, Ordering::SeqCst);
    }
    
    /// å‡å°‘è®¡æ•°
    /// 
    /// åç½®æ¡ä»¶: counter.get() == old(counter.get()) - 1
    /// çº¿ç¨‹å®‰å…¨: å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹å¹¶å‘è°ƒç”¨
    pub fn decrement(&self) {
        self.count.fetch_sub(1, Ordering::SeqCst);
    }
    
    /// è·å–å½“å‰è®¡æ•°
    /// 
    /// è¿”å›å€¼: å½“å‰è®¡æ•°å€¼
    /// çº¿ç¨‹å®‰å…¨: å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹å¹¶å‘è°ƒç”¨
    pub fn get(&self) -> usize {
        self.count.load(Ordering::SeqCst)
    }
}

// ä½¿ç”¨ Kani éªŒè¯å¹¶å‘æ­£ç¡®æ€§
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(3)]
fn verify_counter_concurrent() {
    use std::sync::Arc;
    use std::thread;
    
    let counter = Arc::new(Counter::new());
    let c1 = Arc::clone(&counter);
    let c2 = Arc::clone(&counter);
    
    let t1 = thread::spawn(move || {
        c1.increment();
        c1.increment();
    });
    
    let t2 = thread::spawn(move || {
        c2.increment();
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
    
    // éªŒè¯æœ€ç»ˆè®¡æ•°æ­£ç¡®
    assert!(counter.get() == 3);
}
```

### 11.6 å½¢å¼åŒ–æ–¹æ³•çš„æ¯”è¾ƒ

**ä¸åŒéªŒè¯å·¥å…·çš„å¯¹æ¯”**:

| å·¥å…·    | æ–¹æ³•           | è‡ªåŠ¨åŒ–ç¨‹åº¦ | è§„èŒƒè¯­è¨€     | æ€§èƒ½    | é€‚ç”¨åœºæ™¯         |
|---------|----------------|------------|--------------|---------|------------------|
| Prusti  | æ¼”ç»éªŒè¯       | ä¸­         | Rust + æ³¨è§£  | æ…¢      | å…³é”®ç®—æ³•         |
| Creusot | æ¼”ç»éªŒè¯       | ä¸­         | Rust + Why3  | æ…¢      | å­¦æœ¯ç ”ç©¶         |
| Verus   | æ¼”ç»éªŒè¯       | ä¸­-é«˜      | Rust + æ‰©å±•  | ä¸­      | ç³»ç»Ÿè½¯ä»¶         |
| Kani    | æ¨¡å‹æ£€æŸ¥       | é«˜         | Rust         | ä¸­-å¿«   | è¿è¡Œæ—¶é”™è¯¯æ£€æµ‹   |
| MIRI    | è§£é‡Šæ‰§è¡Œ       | é«˜         | Rust         | å¿«      | Unsafe ä»£ç æµ‹è¯•  |

**é€‰æ‹©å»ºè®®**:

```text
1. åŸå‹é˜¶æ®µ: MIRIï¼ˆå¿«é€Ÿå‘ç°UBï¼‰
2. å¼€å‘é˜¶æ®µ: Kaniï¼ˆè‡ªåŠ¨æ£€æµ‹é”™è¯¯ï¼‰
3. å…³é”®ä»£ç : Prusti/Verusï¼ˆå®Œå…¨éªŒè¯ï¼‰
4. ç ”ç©¶é¡¹ç›®: Creusotï¼ˆæœ€å¼ºè¡¨è¾¾èƒ½åŠ›ï¼‰
```

### 11.7 å½¢å¼åŒ–éªŒè¯çš„æœªæ¥æ–¹å‘

**è¶‹åŠ¿1ï¼šè‡ªåŠ¨åŒ–å¢å¼º**:

```text
- AIè¾…åŠ©çš„è§„èŒƒæ¨æ–­
- è‡ªåŠ¨å¾ªç¯ä¸å˜å¼ç”Ÿæˆ
- æ™ºèƒ½åä¾‹æœ€å°åŒ–
- å¢é‡éªŒè¯ï¼ˆåªéªŒè¯å˜æ›´éƒ¨åˆ†ï¼‰
```

**è¶‹åŠ¿2ï¼šé›†æˆåˆ°å¼€å‘æµç¨‹**:

```text
- IDEå®æ—¶åé¦ˆ
- CI/CDç®¡é“é›†æˆ
- äº‘ç«¯éªŒè¯æœåŠ¡
- è½»é‡çº§è§„èŒƒDSL
```

**è¶‹åŠ¿3ï¼šæ€§èƒ½ä¼˜åŒ–**:

```text
- å¹¶è¡ŒéªŒè¯
- åˆ†å¸ƒå¼æ±‚è§£
- ç¼“å­˜éªŒè¯ç»“æœ
- è¿‘ä¼¼éªŒè¯ï¼ˆtrade-offå®Œå¤‡æ€§æ¢é€Ÿåº¦ï¼‰
```

**Rustç”Ÿæ€çš„ç‹¬ç‰¹ä¼˜åŠ¿**:

```text
1. ç±»å‹ç³»ç»Ÿå·²æä¾›åŸºç¡€ä¿è¯
   - å†…å­˜å®‰å…¨ï¼ˆæ— GCï¼‰
   - çº¿ç¨‹å®‰å…¨ï¼ˆSend/Syncï¼‰
   - æ— æ•°æ®ç«äº‰

2. å½¢å¼åŒ–éªŒè¯èšç„¦äºï¼š
   - å‡½æ•°æ­£ç¡®æ€§
   - å¤æ‚ç®—æ³•
   - Unsafeä»£ç 
   - æ€§èƒ½å…³é”®è·¯å¾„

3. æ¸è¿›å¼é‡‡ç”¨ï¼š
   - æ— éœ€ä¸€å¼€å§‹å°±å…¨é¢éªŒè¯
   - å…ˆéªŒè¯å…³é”®æ¨¡å—
   - é€æ­¥æ‰©å¤§éªŒè¯èŒƒå›´
```

---

## 12. æ€»ç»“

Rust ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–æ¶µç›–ï¼š

1. **è¯­æ³•**: æ ¸å¿ƒè¯­æ³•ã€æ‰©å±•ã€è„±ç³–
2. **ç±»å‹è§„åˆ™**: åŸºç¡€ã€å¼•ç”¨ã€é«˜çº§
3. **æ“ä½œè¯­ä¹‰**: å°æ­¥ã€å¤§æ­¥ã€å †æ¨¡å‹
4. **æ‰€æœ‰æƒ**: ç§»åŠ¨ã€å¤åˆ¶ã€Drop
5. **å€Ÿç”¨**: ä¼ ç»Ÿã€Poloniusã€NLL
6. **ç”Ÿå‘½å‘¨æœŸ**: çº¦æŸã€åŒºåŸŸã€çœç•¥
7. **å¥å…¨æ€§**: ä¿å…¨æ€§ã€è¿›å±•æ€§ã€å†…å­˜å®‰å…¨
8. **å½¢å¼åŒ–**: RustBeltã€Oxide
9. **å·¥å…·**: Prustiã€Creusotã€Verus

**æ ¸å¿ƒæ´å¯Ÿ**:

- Rust = ä»¿å°„ç±»å‹ç³»ç»Ÿ + åŒºåŸŸç±»å‹ç³»ç»Ÿ
- å®‰å…¨æ€§æ¥è‡ªé™æ€æ£€æŸ¥ï¼Œè€Œéè¿è¡Œæ—¶
- å½¢å¼åŒ–éªŒè¯ç¡®ä¿ç†è®ºæ­£ç¡®æ€§

---

## 13. å‚è€ƒèµ„æº

**å­¦æœ¯è®ºæ–‡**:

- "RustBelt: Securing the Foundations of the Rust Programming Language" (POPL 2018)
- "Oxide: The Essence of Rust" (ECOOP 2019)
- "Stacked Borrows: An Aliasing Model for Rust" (POPL 2020)
- "Polonius: The Next Generation Borrow Checker" (Rust RFC)
- "Non-Lexical Lifetimes" (RFC 2094)

**å½¢å¼åŒ–å·¥å…·**:

- [Prusti](https://www.pm.inf.ethz.ch/research/prusti.html)
- [Creusot](https://github.com/creusot-rs/creusot)
- [Verus](https://github.com/verus-lang/verus)
- [Kani](https://model-checking.github.io/kani/)

**ç†è®ºèµ„æº**:

- Types and Programming Languages (TAPL) - Pierce
- Separation Logic: A Logic for Shared Mutable Data Structures - Reynolds
- Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning

**ç›¸å…³æ–‡æ¡£**:

- [4.1 ç±»å‹ç†è®ºæ·±åº¦](./01_ç±»å‹ç†è®ºæ·±åº¦.md)
- [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)
- [3.2 ç±»å‹å‹å˜å‚è€ƒ](../tier_03_references/02_ç±»å‹å‹å˜å‚è€ƒ.md)

---

**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚

---

**ğŸ“ å®Œæˆç±»å‹ç³»ç»Ÿå½¢å¼åŒ–æ·±åº¦å­¦ä¹ ï¼** ğŸ¦€

---

*æœ¬æ–‡æ¡£æä¾›äº† Rust ç±»å‹ç³»ç»Ÿçš„å®Œæ•´å½¢å¼åŒ–æ¡†æ¶ï¼Œæ¶µç›–ä»åŸºç¡€è¯­æ³•åˆ°é«˜çº§éªŒè¯å·¥å…·çš„å…¨éƒ¨å†…å®¹ã€‚é€šè¿‡å½¢å¼åŒ–æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜ Rust çš„å†…å­˜å®‰å…¨æ€§å’Œç±»å‹å¥å…¨æ€§ã€‚*
