# 4.3 Rust 类型系统 - 类型系统形式化

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 类型系统的形式化描述  
> **适用对象**: 高级开发者 + 研究者  
> **前置知识**: [4.1 类型理论深度](./01_类型理论深度.md), 形式化方法基础  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.3 Rust 类型系统 - 类型系统形式化](#43-rust-类型系统---类型系统形式化)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 语法定义](#1-语法定义)
    - [1.1 核心语法](#11-核心语法)
    - [1.2 扩展语法](#12-扩展语法)
    - [1.3 语法糖](#13-语法糖)
  - [2. 类型规则](#2-类型规则)
    - [2.1 基础类型规则](#21-基础类型规则)
    - [2.2 引用类型规则](#22-引用类型规则)
    - [2.3 高级类型规则](#23-高级类型规则)
  - [3. 操作语义](#3-操作语义)
    - [3.1 小步语义](#31-小步语义)
    - [3.2 大步语义](#32-大步语义)
    - [3.3 堆模型](#33-堆模型)
  - [4. 所有权规则](#4-所有权规则)
    - [4.1 所有权转移](#41-所有权转移)
    - [4.2 Copy vs Move 语义](#42-copy-vs-move-语义)
    - [4.3 Drop 语义](#43-drop-语义)
  - [5. 借用检查](#5-借用检查)
    - [5.1 借用规则形式化](#51-借用规则形式化)
    - [5.2 Polonius 借用检查器](#52-polonius-借用检查器)
    - [5.3 NLL (Non-Lexical Lifetimes)](#53-nll-non-lexical-lifetimes)
  - [6. 生命周期推断](#6-生命周期推断)
    - [6.1 生命周期约束系统](#61-生命周期约束系统)
    - [6.2 区域类型系统](#62-区域类型系统)
    - [6.3 生命周期省略规则](#63-生命周期省略规则)
  - [7. 类型健全性](#7-类型健全性)
    - [7.1 类型保全性证明](#71-类型保全性证明)
    - [7.2 进展性证明](#72-进展性证明)
    - [7.3 内存安全证明](#73-内存安全证明)
  - [8. 分离逻辑与 RustBelt](#8-分离逻辑与-rustbelt)
    - [8.1 分离逻辑基础](#81-分离逻辑基础)
    - [8.2 Iris 框架](#82-iris-框架)
    - [8.3 RustBelt 模型](#83-rustbelt-模型)
  - [9. Oxide: Rust 的核心演算](#9-oxide-rust-的核心演算)
    - [9.1 Oxide 语法](#91-oxide-语法)
    - [9.2 Oxide 类型系统](#92-oxide-类型系统)
    - [9.3 Oxide 证明](#93-oxide-证明)
  - [10. 高级主题](#10-高级主题)
    - [10.1 型变与子类型](#101-型变与子类型)
    - [10.2 Higher-Ranked Types](#102-higher-ranked-types)
    - [10.3 效应系统](#103-效应系统)
  - [11. 实践：形式化验证工具](#11-实践形式化验证工具)
    - [11.1 Prusti](#111-prusti)
    - [11.2 Creusot](#112-creusot)
    - [11.3 Verus](#113-verus)
  - [12. 总结](#12-总结)
  - [13. 参考资源](#13-参考资源)

---

## 🎯 概述

Rust 类型系统的形式化基于：

- λ-演算
- 线性/仿射类型系统
- 区域类型系统
- Hindley-Milner 类型推断

---

## 1. 语法定义

### 1.1 核心语法

**抽象语法（BNF范式）**:

```text
类型 T ::=
    | bool                    布尔类型
    | i32, i64, u32, u64      整数类型族
    | f32, f64                浮点类型
    | ()                      单元类型
    | &'a T                   不可变引用
    | &'a mut T               可变引用
    | (T1, T2, ..., Tn)       元组类型
    | fn(T1, ..., Tn) -> T    函数类型
    | Box<T>                  所有权指针
    | [T; n]                  数组类型
    | [T]                     切片类型
    | struct { f1: T1, ... }  结构体类型
    | enum { C1(T1), ... }    枚举类型
    | impl Trait              Trait对象
    | dyn Trait               动态Trait
    | 'a                      生命周期参数

表达式 e ::=
    | x                       变量
    | true | false            布尔值
    | n                       整数字面量
    | f                       浮点字面量
    | ()                      单元值
    | (e1, e2, ..., en)       元组构造
    | e.i                     元组投影 (i ∈ ℕ)
    | e.f                     字段访问
    | &e | &mut e             引用构造
    | *e                      解引用
    | let x = e1 in e2        let绑定
    | let mut x = e1 in e2    可变绑定
    | fn(x: T) e              函数抽象
    | e1(e2, ..., en)         函数应用
    | if e1 { e2 } else { e3 } 条件表达式
    | match e { p1 => e1, ... } 模式匹配
    | loop { e }              无限循环
    | break e                 循环跳出
    | continue                循环继续
    | { e1; e2; ...; en }     块表达式
    | e1 = e2                 赋值
    | drop(e)                 显式释放
    | Box::new(e)             堆分配
    | e as T                  类型转换

模式 p ::=
    | _                       通配符
    | x                       变量绑定
    | true | false | n        字面量
    | (p1, ..., pn)           元组模式
    | C(p1, ..., pn)          构造器模式
    | p @ p'                  绑定模式
    | ref p | ref mut p       引用模式

值 v ::=
    | true | false            布尔值
    | n                       整数值
    | ()                      单元值
    | (v1, v2, ..., vn)       元组值
    | fn(x: T) e              闭包值
    | &l | &mut l             引用值
    | Box(l)                  堆指针值

位置 l ∈ Loc                  堆地址（抽象）
生命周期 'a, 'b, ...          生命周期变量
```

**类型环境**:

```text
Γ ::= ∅                       空环境
    | Γ, x : T                变量绑定
    | Γ, 'a : Region          生命周期绑定
    | Γ, l : T                位置类型

Σ ::= ∅                       空堆
    | Σ, l ↦ v                堆映射
```

### 1.2 扩展语法

**泛型和Trait**:

```text
类型参数 α, β, ...
Trait约束 C ::= T : Trait | 'a : 'b

泛型类型 ∀α. T
带约束泛型 ∀α where C. T

关联类型:
trait Iterator {
    type Item;
    ...
}

impl Iterator for T {
    type Item = U;
    ...
}
```

**生命周期参数化**:

```text
&'a T                         显式生命周期
&'static T                    静态生命周期
&'_ T                         生命周期省略

for<'a> fn(&'a T) -> &'a U    高阶生命周期
```

### 1.3 语法糖

**Rust语法糖到核心语法的脱糖**:

| Rust 语法 | 核心语法 | 说明 |
|-----------|---------|------|
| `let x = e;` | `let x = e in ()` | 语句转表达式 |
| `x += 1` | `x = x + 1` | 复合赋值 |
| `vec![1, 2, 3]` | `Vec::from([1, 2, 3])` | 宏展开 |
| `s.len()` | `String::len(&s)` | 方法调用 |
| `for x in iter { e }` | `iter.into_iter().for_each(\|x\| e)` | for循环 |
| `?` 操作符 | `match e { Ok(v) => v, Err(e) => return Err(e) }` | 错误传播 |
| `async fn` | `fn() -> impl Future<Output = T>` | 异步函数 |

**示例脱糖**:

```rust
// 原始Rust代码
fn process(data: Vec<i32>) -> Result<i32, String> {
    let sum = data.iter().sum();
    if sum > 0 {
        Ok(sum)
    } else {
        Err("Sum is not positive".to_string())
    }
}

// 对应的核心语法（伪代码）
fn process(data: Vec<i32>) -> Result<i32, String> = 
    let sum = 
        let iter = Vec::iter(&data) in
        let sum_fn = Iterator::sum in
        sum_fn(iter)
    in
    if sum > 0 {
        Result::Ok(sum)
    } else {
        Result::Err(String::from("Sum is not positive"))
    }
```

---

## 2. 类型规则

### 2.1 基础类型规则

**类型判断**: `Γ ⊢ e : T`

**基础规则**:

```text
[T-Var]
x : T ∈ Γ
────────────
Γ ⊢ x : T


[T-Unit]
────────────
Γ ⊢ () : ()


[T-Bool]
────────────────
Γ ⊢ true : bool
Γ ⊢ false : bool


[T-Int]
────────────
Γ ⊢ n : i32


[T-Float]
────────────
Γ ⊢ f : f64


[T-Tuple]
Γ ⊢ e1 : T1    Γ ⊢ e2 : T2    ...    Γ ⊢ en : Tn
──────────────────────────────────────────────────
Γ ⊢ (e1, e2, ..., en) : (T1, T2, ..., Tn)


[T-Proj]
Γ ⊢ e : (T1, ..., Ti, ..., Tn)    i ∈ {0, ..., n-1}
───────────────────────────────────────────────────
Γ ⊢ e.i : Ti


[T-Struct]
Γ ⊢ e1 : T1    ...    Γ ⊢ en : Tn
───────────────────────────────────────────
Γ ⊢ S { f1: e1, ..., fn: en } : S

其中 S = struct { f1: T1, ..., fn: Tn }


[T-Field]
Γ ⊢ e : S    S.fi = Ti
─────────────────────
Γ ⊢ e.fi : Ti
```

### 2.2 引用类型规则

**不可变引用**:

```text
[T-Ref]
Γ ⊢ e : T    'a fresh    e 可借用
──────────────────────────────────
Γ ⊢ &e : &'a T


[T-Deref-Imm]
Γ ⊢ e : &'a T
─────────────
Γ ⊢ *e : T


[T-Copy-Ref]
Γ ⊢ e : &'a T    T : Copy
─────────────────────────
Γ ⊢ *e : T    (可以多次使用)
```

**可变引用**:

```text
[T-MutRef]
Γ ⊢ e : T    'a fresh    e 独占可借用    e 可变
─────────────────────────────────────────────────
Γ ⊢ &mut e : &'a mut T


[T-Deref-Mut]
Γ ⊢ e : &'a mut T
─────────────────
Γ ⊢ *e : T


[T-Assign]
Γ ⊢ e1 : &'a mut T    Γ ⊢ e2 : T
──────────────────────────────────
Γ ⊢ (*e1 = e2) : ()


[T-Reborrow-Imm]
Γ ⊢ e : &'a mut T    'b ⊆ 'a
─────────────────────────────
Γ ⊢ &*e : &'b T


[T-Reborrow-Mut]
Γ ⊢ e : &'a mut T    'b ⊆ 'a
─────────────────────────────
Γ ⊢ &mut *e : &'b mut T
```

### 2.3 高级类型规则

**Let绑定与所有权**:

```text
[T-Let-Move]
Γ ⊢ e1 : T1    ¬(T1 : Copy)    Γ, x : T1 ⊢ e2 : T2
───────────────────────────────────────────────────
Γ \ moved(e1) ⊢ let x = e1 in e2 : T2


[T-Let-Copy]
Γ ⊢ e1 : T1    T1 : Copy    Γ, x : T1 ⊢ e2 : T2
──────────────────────────────────────────────────
Γ ⊢ let x = e1 in e2 : T2
```

**函数与应用**:

```text
[T-Fun]
Γ, x : T1 ⊢ e : T2    captures(e) ⊆ Γ
──────────────────────────────────────
Γ ⊢ fn(x: T1) -> T2 { e } : fn(T1) -> T2


[T-Closure]
Γ, x : T1 ⊢ e : T2    captures(e) = {y1: U1, ..., yn: Un}
─────────────────────────────────────────────────────────
Γ ⊢ |x| e : impl Fn(T1) -> T2


[T-App]
Γ ⊢ e1 : fn(T1, ..., Tn) -> T    Γ ⊢ e2 : T1    ...    Γ ⊢ en+1 : Tn
────────────────────────────────────────────────────────────────────
Γ \ moved(e2, ..., en+1) ⊢ e1(e2, ..., en+1) : T


[T-Method]
Γ ⊢ e : T    T :: m : fn(&Self, T1, ..., Tn) -> U
──────────────────────────────────────────────────
Γ ⊢ e.m(e1, ..., en) : U
```

**控制流**:

```text
[T-If]
Γ ⊢ e1 : bool    Γ ⊢ e2 : T    Γ ⊢ e3 : T
────────────────────────────────────────────
Γ ⊢ if e1 { e2 } else { e3 } : T


[T-Match]
Γ ⊢ e : T    Γ, pi ⊢ ei : U    (∀i)    patterns(p1, ..., pn) complete for T
──────────────────────────────────────────────────────────────────────────
Γ ⊢ match e { p1 => e1, ..., pn => en } : U


[T-Loop]
Γ ⊢ e : ()    Γ ⊢ (break in e) : T    (如果有)
──────────────────────────────────────────────
Γ ⊢ loop { e } : T


[T-Break]
Γ ⊢ e : T    (在loop上下文中)
────────────────────────────
Γ ⊢ break e : !
```

**模式匹配**:

```text
[P-Wildcard]
─────────────
Γ ⊢ _ : T ⇒ Γ


[P-Var]
───────────────
Γ ⊢ x : T ⇒ Γ, x : T


[P-Literal]
v : T
─────────────
Γ ⊢ v : T ⇒ Γ


[P-Tuple]
Γ ⊢ p1 : T1 ⇒ Γ1    ...    Γn-1 ⊢ pn : Tn ⇒ Γn
───────────────────────────────────────────────
Γ ⊢ (p1, ..., pn) : (T1, ..., Tn) ⇒ Γn


[P-Constructor]
C : (T1, ..., Tn) -> E    Γ ⊢ p1 : T1 ⇒ Γ1    ...    Γn-1 ⊢ pn : Tn ⇒ Γn
─────────────────────────────────────────────────────────────────────────
Γ ⊢ C(p1, ..., pn) : E ⇒ Γn


[P-Ref]
Γ ⊢ p : T ⇒ Γ'
───────────────────────
Γ ⊢ ref p : &'a T ⇒ Γ'


[P-MutRef]
Γ ⊢ p : T ⇒ Γ'
───────────────────────────
Γ ⊢ ref mut p : &'a mut T ⇒ Γ'
```

**示例推导**:

```rust
// 完整的类型推导树示例
//
// let x = 42 in x + 1
//
// 类型推导树:
//
//              ────────────── [T-Int]
//              ⊢ 42 : i32
//              ──────────────────────────────── [T-Var]
//              x : i32 ⊢ x : i32
//              ────────────────────────── [T-Int]    ────────────── [T-Int]
//              ⊢ 1 : i32                             x : i32 ⊢ 1 : i32
//              ───────────────────────────────────────────────────── [T-Add]
//              x : i32 ⊢ x + 1 : i32
// ──────────────────────────────────────────────────────────────────── [T-Let-Copy]
// ⊢ let x = 42 in x + 1 : i32

fn main() {
    let x = 42;
    let result = x + 1;
    println!("{}", result);
}

// 更复杂的示例：引用推导
//
// let mut v = vec![1, 2, 3];
// let r = &mut v;
// r.push(4);
//
// 类型推导:
//
//              ───────────────────────────
//              ⊢ vec![1, 2, 3] : Vec<i32>
//              ─────────────────────────────────────── [T-Let-Move]
//              v : Vec<i32> ⊢ ...
//              ─────────────────────────────────── [T-MutRef]
//              v : Vec<i32> ⊢ &mut v : &'a mut Vec<i32>
//              ──────────────────────────────────────────────── [T-Let-Move]
//              r : &'a mut Vec<i32> ⊢ ...
//              ────────────────────────────── [T-Method]
//              r : &'a mut Vec<i32> ⊢ r.push(4) : ()

fn example_ref() {
    let mut v = vec![1, 2, 3];
    let r = &mut v;
    r.push(4);
    println!("{:?}", r);
}
```

---

## 3. 操作语义

### 3.1 小步语义

**小步语义规则**: `e, Σ → e', Σ'`

**基础规则**:

```text
[E-ProjTuple-1]
─────────────────
(v1, v2).0, Σ → v1, Σ


[E-ProjTuple-2]
─────────────────
(v1, v2).1, Σ → v2, Σ


[E-FieldAccess]
Σ(l) = struct { ..., fi: vi, ... }
───────────────────────────────────
l.fi, Σ → vi, Σ


[E-LetV]
──────────────────────────────
let x = v in e, Σ → e[x := v], Σ


[E-LetE]
e1, Σ → e1', Σ'
───────────────────────────────────────
let x = e1 in e2, Σ → let x = e1' in e2, Σ'


[E-App-Beta]
────────────────────────────────
(fn(x: T) e)(v), Σ → e[x := v], Σ


[E-App-Fun]
e1, Σ → e1', Σ'
──────────────────────────
e1(e2), Σ → e1'(e2), Σ'


[E-App-Arg]
e2, Σ → e2', Σ'
────────────────────────
v(e2), Σ → v(e2'), Σ'
```

**引用规则**:

```text
[E-Ref]
l fresh
──────────────────────────────
&v, Σ → &l, Σ ∪ {l ↦ v}


[E-MutRef]
l fresh
──────────────────────────────
&mut v, Σ → &mut l, Σ ∪ {l ↦ v}


[E-Deref]
Σ(l) = v
──────────────
*(&l), Σ → v, Σ


[E-DerefMut]
Σ(l) = v
────────────────────
*(&mut l), Σ → v, Σ


[E-Assign]
Σ(l) = _
────────────────────────────────
*(&mut l) = v, Σ → (), Σ[l ↦ v]


[E-Drop]
Σ(l) = v
──────────────────────
drop(&mut l), Σ → (), Σ \ {l}
```

**控制流规则**:

```text
[E-If-True]
────────────────────────────────
if true { e1 } else { e2 }, Σ → e1, Σ


[E-If-False]
────────────────────────────────
if false { e1 } else { e2 }, Σ → e2, Σ


[E-If-Cond]
e, Σ → e', Σ'
───────────────────────────────────────────────────────
if e { e1 } else { e2 }, Σ → if e' { e1 } else { e2 }, Σ'


[E-Match]
match_pattern(v, pi) = Some(θ)
───────────────────────────────────────────
match v { ..., pi => ei, ... }, Σ → θ(ei), Σ


[E-Match-Scrutinee]
e, Σ → e', Σ'
──────────────────────────────────────────────────────────
match e { p1 => e1, ... }, Σ → match e' { p1 => e1, ... }, Σ'


[E-Loop]
───────────────────────────────────────
loop { e }, Σ → (e; loop { e }), Σ


[E-Break]
──────────────────────────
break v, Σ → (exit v), Σ
```

**上下文规则**:

```text
e, Σ → e', Σ'
─────────────────
E[e], Σ → E[e'], Σ'

其中 E 是求值上下文:
E ::= [ ] | (E, e) | (v, E) | E.i | &E | &mut E | *E | let x = E in e 
    | E(e) | v(E) | if E { e1 } else { e2 } | match E { ... } | E = e | v = E
```

### 3.2 大步语义

**大步语义（自然语义）**: `e, Σ ⇓ v, Σ'`

```text
[E-Val]
─────────────
v, Σ ⇓ v, Σ


[E-Var]
Γ(x) = v
─────────────
x, Σ ⇓ v, Σ


[E-Tuple]
e1, Σ ⇓ v1, Σ1    e2, Σ1 ⇓ v2, Σ2
───────────────────────────────────
(e1, e2), Σ ⇓ (v1, v2), Σ2


[E-Proj]
e, Σ ⇓ (v1, v2), Σ'
────────────────────
e.0, Σ ⇓ v1, Σ'


[E-Let]
e1, Σ ⇓ v1, Σ1    e2[x := v1], Σ1 ⇓ v2, Σ2
────────────────────────────────────────────
let x = e1 in e2, Σ ⇓ v2, Σ2


[E-App-Big]
e1, Σ ⇓ fn(x: T) e, Σ1    e2, Σ1 ⇓ v2, Σ2    e[x := v2], Σ2 ⇓ v, Σ3
─────────────────────────────────────────────────────────────────────
e1(e2), Σ ⇓ v, Σ3


[E-If-Big-True]
e1, Σ ⇓ true, Σ1    e2, Σ1 ⇓ v, Σ2
────────────────────────────────────
if e1 { e2 } else { e3 }, Σ ⇓ v, Σ2


[E-If-Big-False]
e1, Σ ⇓ false, Σ1    e3, Σ1 ⇓ v, Σ2
─────────────────────────────────────
if e1 { e2 } else { e3 }, Σ ⇓ v, Σ2
```

### 3.3 堆模型

**堆抽象**:

```text
堆 Σ: Loc → Value
位置 l ∈ Loc (无限集)
值 v ∈ Value

堆操作:
- Σ(l): 读取位置 l 的值
- Σ[l ↦ v]: 更新位置 l 为值 v
- Σ \ {l}: 释放位置 l
- l fresh: 分配新位置
```

**堆不变式**:

1. **良构性**: `∀l ∈ dom(Σ), Σ(l)` 是良类型的值
2. **无悬垂指针**: `∀&l ∈ reachable(Σ), l ∈ dom(Σ)`
3. **唯一可变引用**: `∀&mut l ∈ reachable(Σ)`, 不存在其他指向 l 的引用

**堆语义示例**:

```rust
// 完整的堆语义推导
//
// let mut x = Box::new(42);
// let y = &mut x;
// *y = 43;
//
// 语义推导:
//
// 初始: Σ₀ = ∅
//
// Box::new(42), Σ₀
// → (l₁ fresh) Box(l₁), Σ₁ where Σ₁ = {l₁ ↦ 42}
//
// let mut x = Box(l₁), Σ₁
// → Γ = {x : Box(l₁)}, Σ₁
//
// &mut x, Σ₁
// → (l₂ fresh) &mut l₂, Σ₂ where Σ₂ = {l₁ ↦ 42, l₂ ↦ Box(l₁)}
//
// let y = &mut l₂, Σ₂
// → Γ = {x : Box(l₁), y : &mut Box(l₁)}, Σ₂
//
// *y = 43, Σ₂
// → *(&mut l₂) = 43, Σ₂
// → *Box(l₁) = 43, Σ₂
// → (), Σ₃ where Σ₃ = {l₁ ↦ 43, l₂ ↦ Box(l₁)}

fn heap_example() {
    let mut x = Box::new(42);
    let y = &mut x;
    *y = Box::new(43);
    println!("{}", **y);
}

// 更复杂的堆操作示例
//
// let v1 = vec![1, 2, 3];
// let v2 = v1;  // 移动
// drop(v2);
//
// 堆状态变化:
//
// Σ₀ = ∅
// → Σ₁ = {l₁ ↦ vec![1,2,3]}     (v1分配)
// → Σ₁ = {l₁ ↦ vec![1,2,3]}     (v1移动到v2, v1失效)
// → Σ₂ = ∅                       (v2被drop, l₁释放)

fn drop_example() {
    let v1 = vec![1, 2, 3];
    let v2 = v1;  // v1 移动
    drop(v2);  // v2 被释放
    // println!("{:?}", v1);  // ❌ v1 已失效
}
```

**堆可达性分析**:

```text
reachable(Σ) = fix λR. {
    l | l ∈ dom(Σ) ∧ (
        ∃x ∈ Γ. x 直接引用 l ∨
        ∃l' ∈ R. Σ(l') 包含指向 l 的引用
    )
}
```

---

## 4. 所有权规则

### 4.1 所有权转移

**所有权类型规则**:

```text
[Own-Move]
Γ ⊢ e : T    x ∉ dom(Γ)    ¬(T : Copy)
────────────────────────────────────────
Γ \ used(e), x : T ⊢ let x = e


[Own-Use]
Γ, x : T ⊢ e : T'    x 在 e 中使用一次    ¬(T : Copy)
────────────────────────────────────────────────────────
Γ \ {x} ⊢ e : T'


[Own-Drop]
Γ, x : T ⊢ e : T'    x 不在 e 中使用
────────────────────────────────────
Γ \ {x} ⊢ e : T'
```

**所有权转移语义**:

```text
moved(x) = x 的所有权已转移
used(e) = e 中使用的所有非Copy变量集合

环境分离: Γ \ S = {x : T ∈ Γ | x ∉ S}
```

### 4.2 Copy vs Move 语义

**Copy trait规则**:

```text
[Copy-Trait]
T : Copy    Γ ⊢ e : T
───────────────────────
Γ ⊢ e : T    (可多次使用)


[Copy-Types]
i32, i64, f32, f64, bool, char, &T : Copy
但 String, Vec<T>, Box<T> : !Copy
```

**Move语义示例**:

```rust
// 形式化推导:
// ─────────────────────────────
// ⊢ String::from("hello") : String
// ───────────────────────────────────── [Own-Move]
// x : String ⊢ x : String
// ───────────────────────────────────── [Own-Use]
// ∅ ⊢ let y = x : String
//
// x 在移动后不可用

fn move_semantics() {
    let x = String::from("hello");
    let y = x;  // x 移动到 y, Γ从{x:String}变为{y:String}
    println!("{}", y);
    // println!("{}", x);  // ❌ x 已失效
}

// Copy语义示例:
// ─────────────
// ⊢ 42 : i32
// ───────────────────── [Copy-Trait]
// x : i32 ⊢ x : i32    (可多次使用)
// ─────────────────────
// x : i32, y : i32 ⊢ ...

fn copy_semantics() {
    let x = 42;
    let y = x;  // x 复制到 y, Γ包含{x:i32, y:i32}
    println!("{} {}", x, y);  // ✅ x 仍可用
}
```

### 4.3 Drop 语义

**Drop trait规则**:

```text
[Drop-Implicit]
Γ ⊢ e : T    T : Drop    e 离开作用域
──────────────────────────────────────
T::drop(e) 自动调用


[Drop-Explicit]
Γ ⊢ e : T    T : Drop
─────────────────────
Γ \ {e} ⊢ drop(e) : ()


[Drop-Order]
let x1 = e1; ... ; let xn = en;
drop顺序: xn, ..., x2, x1  (逆序)
```

**Drop语义示例**:

```rust
struct Resource {
    id: i32,
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("Dropping resource {}", self.id);
    }
}

// 形式化:
// let r1 = Resource { id: 1 };
// let r2 = Resource { id: 2 };
// // 作用域结束
//
// Drop顺序:
// 1. r2.drop()  // 输出: "Dropping resource 2"
// 2. r1.drop()  // 输出: "Dropping resource 1"

fn drop_order() {
    let r1 = Resource { id: 1 };
    let r2 = Resource { id: 2 };
    println!("Before drop");
    // 输出顺序:
    // "Before drop"
    // "Dropping resource 2"
    // "Dropping resource 1"
}

// 显式drop
// ──────────────────────
// r : Resource ⊢ drop(r)
// ──────────────────────
// ∅ ⊢ () : ()

fn explicit_drop() {
    let r = Resource { id: 3 };
    drop(r);  // 显式释放
    // println!("{}", r.id);  // ❌ r 已被drop
}
```

---

## 5. 借用检查

### 5.1 借用规则形式化

**借用规则（传统词法作用域）**:

```text
[Borrow-Shared]
Γ ⊢ e : T    'a fresh    path(e) ∈ Loans(Γ)
─────────────────────────────────────────────
Γ ⊢ &e : &'a T
Γ' = Γ ∪ {Loan(path(e), Shared, 'a)}


[Borrow-Mut]
Γ ⊢ e : T    'a fresh    no_active_loans(path(e), Γ)    e mutable
──────────────────────────────────────────────────────────────────
Γ ⊢ &mut e : &'a mut T
Γ' = Γ ∪ {Loan(path(e), Exclusive, 'a)}


[Borrow-Conflict]
Loan(p, Exclusive, 'a) ∈ Γ    Loan(p, _, 'b) ∈ Γ    'a ∩ 'b ≠ ∅
──────────────────────────────────────────────────────────────
错误：可变借用与其他借用冲突
```

**借用检查示例**:

```rust
// 形式化推导:
//
// let mut x = String::from("hello");
// Γ₀ = {x : String}
//
// let r1 = &x;
// Γ₁ = {x : String, Loan(x, Shared, 'a)}
//
// let r2 = &x;
// Γ₂ = {x : String, Loan(x, Shared, 'a), Loan(x, Shared, 'b)}
// ✅ 多个共享借用允许
//
// let r3 = &mut x;
// ❌ 错误：x 已有共享借用，不能创建可变借用

fn borrow_rules() {
    let mut x = String::from("hello");
    
    {
        let r1 = &x;
        let r2 = &x;
        println!("{} {}", r1, r2);
    } // Loans结束
    
    let r3 = &mut x;
    r3.push_str(" world");
    println!("{}", r3);
}
```

### 5.2 Polonius 借用检查器

**Polonius: 基于事实的借用检查**:

Polonius使用数据流分析代替词法作用域：

```text
核心关系:
- Origin(r, o): 引用r的来源是o
- Loan(o, l): 来源o包含贷款l
- Outlives(o1, o2): o1的生命周期长于o2
- LiveAt(r, p): 引用r在程序点p处活跃

借用冲突检测:
∀l ∈ Loans, p ∈ Points:
    if Loan(o, l) ∧ LiveAt(r, p) ∧ Origin(r, o) ∧ conflicts(l, use_at(p))
    then ERROR
```

**Polonius示例**:

```rust
// Polonius允许更精确的借用分析
//
// 传统借用检查器拒绝，但Polonius接受：

fn polonius_example() {
    let mut data = vec![1, 2, 3];
    let r;
    
    {
        let x = &mut data;
        r = &x[0];  // r 借用 x
    } // x 结束，但 r 仍然引用 data
    
    // 传统借用检查：❌ r 的生命周期超过 x
    // Polonius：✅ r 实际上借用 data，而不是 x
    
    println!("{}", r);
}

// Polonius的关键洞察：
// Origin(r, origin_data)  而不是  Origin(r, origin_x)
```

### 5.3 NLL (Non-Lexical Lifetimes)

**非词法生命周期**:

NLL允许生命周期在最后一次使用后结束，而不是在作用域结束时：

```text
[NLL-LastUse]
Γ, x : &'a T ⊢ e : U    last_use(x, e) = p
────────────────────────────────────────────
'a 在程序点 p 之后结束


[NLL-Conflict]
Loan(p, Exclusive, 'a) ∈ Γ    last_use('a) < first_use('b)
────────────────────────────────────────────────────────────
'a 和 'b 不冲突
```

**NLL示例**:

```rust
// 没有NLL：❌
// let mut data = vec![1, 2, 3];
// let r = &data[0];
// data.push(4);  // ❌ data被借用
// println!("{}", r);

// 有NLL：✅
fn nll_example() {
    let mut data = vec![1, 2, 3];
    let r = &data[0];
    println!("{}", r);  // r 的最后使用
    
    // NLL: r 的生命周期在此结束
    data.push(4);  // ✅ data不再被借用
    println!("{:?}", data);
}

// NLL的形式化语义:
//
// Γ₀ = {data : Vec<i32>}
// 
// let r = &data[0];
// Γ₁ = {data : Vec<i32>, r : &'a i32, Loan(data, Shared, 'a)}
//
// println!("{}", r);  // last_use(r) at point p₁
// 
// // NLL: 'a 在 p₁ 之后结束
// Γ₂ = {data : Vec<i32>}  // Loan 已结束
//
// data.push(4);  // ✅ 没有活跃的 Loan
```

---

## 6. 生命周期推断

### 6.1 生命周期约束系统

**生命周期约束（Lifetime Constraints）**:

```text
[Life-Var]
Γ(x) = &'a T
────────────────
Γ ⊢ x : &'a T


[Life-Sub]
Γ ⊢ e : &'a T    'a : 'b    ('a outlives 'b)
─────────────────────────────────────────────
Γ ⊢ e : &'b T


[Life-Ref]
Γ ⊢ e : T    'a covers scope(e)
────────────────────────────────
Γ ⊢ &e : &'a T


[Life-Fun]
Γ, x : &'a T1 ⊢ e : &'b T2    'a : 'b
───────────────────────────────────────
Γ ⊢ fn(x: &'a T1) -> &'b T2


[Life-Trans]
'a : 'b    'b : 'c
──────────────────
'a : 'c
```

**约束求解**:

生命周期推断是约束求解问题：

```text
收集约束: Γ ⊢ e : T  ⇒  C (约束集)
求解: solve(C) = σ (生命周期替换)
验证: σ(C) 全部满足
```

### 6.2 区域类型系统

**区域（Regions）**:

Rust使用区域类型系统来跟踪引用的有效性：

```text
区域 ρ ::= 'a | 'static | concrete_scope

区域关系:
- ρ1 ⊆ ρ2: ρ1 被 ρ2 包含
- ρ1 ⊓ ρ2: ρ1 和 ρ2 的交集
- ρ1 ⊔ ρ2: ρ1 和 ρ2 的并集
```

**区域推断示例**:

```rust
// 形式化:
// x : &'a str, y : &'b str
// ─────────────────────────
// longest : fn(&'a str, &'a str) -> &'a str
//
// 约束: 'a = min('a_x, 'a_y) = 'a_x ⊓ 'a_y

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// 调用点推断:
// s1 : String, 'static : 's1  (栈上生命周期)
// s2 : String, 'static : 's2
// result : &'r str, where 'r = 's1 ⊓ 's2

fn main() {
    let s1 = String::from("long string");  // 's1 开始
    {
        let s2 = String::from("short");  // 's2 开始
        let result = longest(&s1, &s2);  // 'r = 's1 ⊓ 's2 = 's2
        println!("{}", result);
    } // 's2 结束, 'r 结束
} // 's1 结束
```

### 6.3 生命周期省略规则

**省略规则（Lifetime Elision）**:

```text
[Elision-Input]
fn f(x: &T) -> ...
─────────────────────
推断为: fn f<'a>(x: &'a T) -> ...


[Elision-Output-Single]
fn f<'a>(x: &'a T) -> &U
────────────────────────────
推断为: fn f<'a>(x: &'a T) -> &'a U


[Elision-Method-Self]
fn f(&self, x: &T) -> &U
────────────────────────────────
推断为: fn f<'a, 'b>(&'a self, x: &'b T) -> &'a U
```

**省略示例**:

```rust
// 显式生命周期
fn explicit<'a>(x: &'a str) -> &'a str {
    x
}

// 省略生命周期（等价）
fn elided(x: &str) -> &str {
    x
}

// 方法的生命周期省略
struct Parser<'a> {
    data: &'a str,
}

impl<'a> Parser<'a> {
    // fn parse(&self, input: &str) -> &str
    // 推断为: fn parse<'b>(&'a self, input: &'b str) -> &'a str
    fn parse(&self, input: &str) -> &str {
        self.data
    }
}
```

---

## 7. 类型健全性

### 7.1 类型保全性证明

**保全性定理（Preservation Theorem）**:

```text
定理 (Type Preservation):
如果 Γ ⊢ e : T 且 e, Σ → e', Σ'
则 Γ ⊢ e' : T

证明：对 e → e' 的推导进行结构归纳
```

**证明草图**:

```text
情况 1: [E-LetV]
let x = v in e, Σ → e[x := v], Σ

已知:
1. Γ ⊢ let x = v in e : T    (假设)
2. 由 [T-Let]: Γ ⊢ v : T1, Γ,x:T1 ⊢ e : T

需证: Γ ⊢ e[x := v] : T

由替换引理 (Substitution Lemma):
如果 Γ,x:T1 ⊢ e : T 且 Γ ⊢ v : T1
则 Γ ⊢ e[x := v] : T  ✓


情况 2: [E-App-Beta]
(fn(x: T1) e)(v), Σ → e[x := v], Σ

已知:
1. Γ ⊢ (fn(x: T1) e)(v) : T2
2. 由 [T-App] 和 [T-Fun]:
   Γ,x:T1 ⊢ e : T2
   Γ ⊢ v : T1

需证: Γ ⊢ e[x := v] : T2

由替换引理: ✓


情况 3: [E-Deref]
*(&l), Σ → v, Σ where Σ(l) = v

已知:
1. Γ ⊢ *(&l) : T
2. 由 [T-Deref]: Γ ⊢ &l : &'a T
3. 由堆良构性: Σ(l) = v 且 Γ ⊢ v : T

需证: Γ ⊢ v : T  ✓ (由堆良构性)
```

### 7.2 进展性证明

**进展性定理（Progress Theorem）**:

```text
定理 (Progress):
如果 ∅ ⊢ e : T 且 e 良构
则 e 是值 或 存在 e', Σ' 使得 e, Σ → e', Σ'

证明：对 ∅ ⊢ e : T 的推导进行结构归纳
```

**证明草图**:

```text
情况 1: e = v
则 e 是值 ✓


情况 2: e = let x = e1 in e2
由归纳假设对 e1:
- 如果 e1 是值 v, 则 [E-LetV] 适用
- 如果 e1 → e1', 则 [E-LetE] 适用
两种情况都可以进一步求值 ✓


情况 3: e = e1(e2)
由归纳假设:
- 如果 e1 不是值, 则 [E-App-Fun] 适用
- 如果 e1 = fn(x:T)e 且 e2 不是值, 则 [E-App-Arg] 适用
- 如果 e1 = fn(x:T)e 且 e2 = v, 则 [E-App-Beta] 适用
所有情况都可以进一步求值 ✓


情况 4: e = if e1 { e2 } else { e3 }
由归纳假设对 e1:
- 如果 e1 = true, 则 [E-If-True] 适用
- 如果 e1 = false, 则 [E-If-False] 适用
- 如果 e1 不是值, 则 [E-If-Cond] 适用
所有情况都可以进一步求值 ✓
```

### 7.3 内存安全证明

**内存安全定理（Memory Safety Theorem）**:

```text
定理 (Memory Safety):
如果 Γ ⊢ e : T, 堆 Σ 良构, 且 e, Σ →* v, Σ'
则:
1. 无悬垂指针: ∀&l ∈ reachable(Σ'), l ∈ dom(Σ')
2. 无数据竞争: 所有可变借用是独占的
3. 类型安全: Σ'(l) 的类型与 Γ 一致

证明：由借用检查 + 所有权规则 + 类型健全性
```

**证明要点**:

```text
1. 无悬垂指针：
   - 所有权确保值在使用完毕后才被释放
   - 借用检查确保引用不超过值的生命周期
   - 由 [Own-Drop] 和 [Borrow-Use] 保证

2. 无数据竞争：
   - [Borrow-Mut] 确保可变借用是独占的
   - [Borrow-Conflict] 检测并拒绝冲突的借用
   - 由借用检查器静态验证

3. 类型安全：
   - 由类型保全性和进展性定理保证
   - 堆良构性维护类型不变式
```

---

## 8. 分离逻辑与 RustBelt

### 8.1 分离逻辑基础

**分离逻辑（Separation Logic）**:

分离逻辑扩展霍尔逻辑，用于推理堆：

```text
断言 P, Q ::=
    | emp                空堆
    | e ↦ v              单点堆（e 指向 v）
    | P * Q              分离合取（P 和 Q 占用不同堆部分）
    | P ─∗ Q              分离蕴含（魔棒）
    | P ∧ Q              普通合取
    | ∃x. P              存在量词

关键规则:
{P} c {Q}    {R} c' {S}
──────────────────────────── (Frame Rule)
{P * R} c {Q * R}
```

### 8.2 Iris 框架

**Iris: 高阶并发分离逻辑**:

```text
Iris 断言:
- 持久断言 (Persistent): □P
- 不变式 (Invariants): inv N P
- 鬼状态 (Ghost State): own γ a

Iris 规则:
[Inv-Alloc]
P
─────────────────
|={E}=> inv N P

[Inv-Access]
inv N P    E1 ⊆ E2    N ∉ E1
──────────────────────────────
|={E2,E1}=> P * (P ={E1,E2}=∗ True)
```

### 8.3 RustBelt 模型

**RustBelt: Rust的形式化验证**:

RustBelt 使用 Iris 框架形式化 Rust 的类型系统和安全性：

```text
类型语义 (Type Semantics):
⟦T⟧ : Val → iProp

关键类型：
⟦&'a T⟧(v) ≜ ∃l. v = &l * l ↦ ⟦T⟧ * lifetime('a, l)
⟦&'a mut T⟧(v) ≜ ∃l. v = &mut l * exclusive(l, ⟦T⟧) * lifetime('a, l)
⟦Box<T>⟧(v) ≜ ∃l. v = Box(l) * l ↦ ⟦T⟧ * own(l)

借用规则验证:
{⟦&T⟧(v)} read(v) {λr. ⟦T⟧(r) * ⟦&T⟧(v)}
{⟦&mut T⟧(v)} write(v, w) {λ_. ⟦&mut T⟧(v)}
```

---

## 9. Oxide: Rust 的核心演算

### 9.1 Oxide 语法

**Oxide: Rust 的最小核心**:

```text
类型 τ ::= i32 | bool | &ρ τ | &ρ mut τ | ...
表达式 e ::= x | n | &e | *e | let x = e in e | ...
区域 ρ ::= α | ρ ⊓ ρ | ...
```

### 9.2 Oxide 类型系统

**Oxide 的类型规则**:

```text
[Oxide-Borrow]
Δ; Γ ⊢ e : τ @ ρ    fresh ρ'
─────────────────────────────
Δ; Γ ⊢ &e : &ρ' τ @ ρ ⊓ ρ'
```

### 9.3 Oxide 证明

Oxide 提供了 Rust 安全性的可机器检查证明。

---

## 10. 高级主题

### 10.1 型变与子类型

**型变（Variance）**:

```text
协变 (Covariant): T <: U ⇒ F<T> <: F<U>
逆变 (Contravariant): T <: U ⇒ F<U> <: F<T>
不变 (Invariant): T ≠ U ⇒ F<T> 和 F<U> 不可比
```

### 10.2 Higher-Ranked Types

**高阶类型（HRT）**:

```text
∀'a. &'a T  vs  &'a T for some 'a

for<'a> fn(&'a T) -> &'a U  (HRT)
vs fn(&'a T) -> &'a U  (普通)
```

### 10.3 效应系统

**效应（Effects）**:

未来的 Rust 可能引入效应系统：

```text
fn f() -> T throws E
fn g() async -> T
```

---

## 11. 实践：形式化验证工具

### 11.1 Prusti

**Prusti: Rust 的演绎验证器**:

```rust
#[requires(x > 0)]
#[ensures(result > x)]
fn increment(x: i32) -> i32 {
    x + 1
}
```

### 11.2 Creusot

**Creusot: Rust 到 Why3 的翻译**:

```rust
#[ensures(result@ == x@)]
fn identity(x: i32) -> i32 {
    x
}
```

### 11.3 Verus

**Verus: Rust 的验证系统**:

```rust
proof fn lemma_double(x: int)
    ensures x + x == 2 * x
{}
```

---

## 12. 总结

Rust 类型系统的形式化涵盖：

1. **语法**: 核心语法、扩展、脱糖
2. **类型规则**: 基础、引用、高级
3. **操作语义**: 小步、大步、堆模型
4. **所有权**: 移动、复制、Drop
5. **借用**: 传统、Polonius、NLL
6. **生命周期**: 约束、区域、省略
7. **健全性**: 保全性、进展性、内存安全
8. **形式化**: RustBelt、Oxide
9. **工具**: Prusti、Creusot、Verus

**核心洞察**:

- Rust = 仿射类型系统 + 区域类型系统
- 安全性来自静态检查，而非运行时
- 形式化验证确保理论正确性

---

## 13. 参考资源

**学术论文**:

- "RustBelt: Securing the Foundations of the Rust Programming Language" (POPL 2018)
- "Oxide: The Essence of Rust" (ECOOP 2019)
- "Stacked Borrows: An Aliasing Model for Rust" (POPL 2020)
- "Polonius: The Next Generation Borrow Checker" (Rust RFC)
- "Non-Lexical Lifetimes" (RFC 2094)

**形式化工具**:

- [Prusti](https://www.pm.inf.ethz.ch/research/prusti.html)
- [Creusot](https://github.com/creusot-rs/creusot)
- [Verus](https://github.com/verus-lang/verus)
- [Kani](https://model-checking.github.io/kani/)

**理论资源**:

- Types and Programming Languages (TAPL) - Pierce
- Separation Logic: A Logic for Shared Mutable Data Structures - Reynolds
- Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning

**相关文档**:

- [4.1 类型理论深度](./01_类型理论深度.md)
- [2.5 生命周期指南](../tier_02_guides/05_生命周期指南.md)
- [3.2 类型型变参考](../tier_03_references/02_类型型变参考.md)

---

**最后更新**: 2025-10-23  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🎓 完成类型系统形式化深度学习！** 🦀

---

*本文档提供了 Rust 类型系统的完整形式化框架，涵盖从基础语法到高级验证工具的全部内容。通过形式化方法，我们可以证明 Rust 的内存安全性和类型健全性。*
