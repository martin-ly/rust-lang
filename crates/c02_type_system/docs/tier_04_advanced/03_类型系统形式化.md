# 4.3 Rust 类型系统 - 类型系统形式化

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 类型系统的形式化描述  
> **适用对象**: 高级开发者 + 研究者  
> **前置知识**: [4.1 类型理论深度](./01_类型理论深度.md), 形式化方法基础  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.3 Rust 类型系统 - 类型系统形式化](#43-rust-类型系统---类型系统形式化)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 语法定义](#1-语法定义)
  - [2. 类型规则](#2-类型规则)
  - [3. 操作语义](#3-操作语义)
  - [4. 所有权规则](#4-所有权规则)
  - [5. 借用检查](#5-借用检查)
  - [6. 生命周期推断](#6-生命周期推断)
  - [7. 类型健全性](#7-类型健全性)
  - [8. 总结](#8-总结)
  - [9. 参考资源](#9-参考资源)

---

## 🎯 概述

Rust 类型系统的形式化基于：

- λ-演算
- 线性/仿射类型系统
- 区域类型系统
- Hindley-Milner 类型推断

---

## 1. 语法定义

**抽象语法**:

```text
类型 T ::=
    | bool                    布尔类型
    | i32                     整数类型
    | &'a T                   不可变引用
    | &'a mut T               可变引用
    | (T1, T2)                元组类型
    | fn(T1) -> T2            函数类型
    | Box<T>                  所有权指针

表达式 e ::=
    | x                       变量
    | true | false            布尔值
    | n                       整数
    | (e1, e2)                元组
    | e.0 | e.1               投影
    | &e | &mut e             引用
    | *e                      解引用
    | let x = e1 in e2        绑定
    | fn(x: T) e              函数
    | e1(e2)                  应用

值 v ::=
    | true | false
    | n
    | (v1, v2)
    | fn(x: T) e
    | &l | &mut l             引用值

位置 l ::= ...                堆地址
```

---

## 2. 类型规则

**类型判断**: `Γ ⊢ e : T`

```text
[T-Var]
x : T ∈ Γ
────────────
Γ ⊢ x : T


[T-Bool]
────────────────
Γ ⊢ true : bool
Γ ⊢ false : bool


[T-Int]
────────────
Γ ⊢ n : i32


[T-Tuple]
Γ ⊢ e1 : T1    Γ ⊢ e2 : T2
───────────────────────────
Γ ⊢ (e1, e2) : (T1, T2)


[T-Proj-1]
Γ ⊢ e : (T1, T2)
────────────────
Γ ⊢ e.0 : T1


[T-Ref]
Γ ⊢ e : T
──────────────
Γ ⊢ &e : &'a T


[T-MutRef]
Γ ⊢ e : T
──────────────────
Γ ⊢ &mut e : &'a mut T


[T-Deref]
Γ ⊢ e : &'a T
─────────────
Γ ⊢ *e : T


[T-Let]
Γ ⊢ e1 : T1    Γ, x : T1 ⊢ e2 : T2
───────────────────────────────────
Γ ⊢ let x = e1 in e2 : T2


[T-Fun]
Γ, x : T1 ⊢ e : T2
──────────────────────────
Γ ⊢ fn(x: T1) e : fn(T1) -> T2


[T-App]
Γ ⊢ e1 : fn(T1) -> T2    Γ ⊢ e2 : T1
──────────────────────────────────────
Γ ⊢ e1(e2) : T2
```

**示例**:

```rust
// let x = 42 in x + 1
//
// 类型推导:
// ─────────────
// ⊢ 42 : i32
// ─────────────────────────
// x : i32 ⊢ x : i32
// ───────────────────────────────────
// x : i32 ⊢ x + 1 : i32
// ────────────────────────────────────────
// ⊢ let x = 42 in x + 1 : i32

fn main() {
    let x = 42;
    let result = x + 1;
    println!("{}", result);
}
```

---

## 3. 操作语义

**小步语义**: `e → e'`

```text
[E-ProjTuple]
─────────────────
(v1, v2).0 → v1


[E-LetV]
─────────────────────────
let x = v in e → e[x := v]


[E-App]
───────────────────────────
(fn(x: T) e)(v) → e[x := v]


[E-Deref]
Σ(l) = v
────────────
*(&l) → v


[E-Ctx]
e → e'
────────────
C[e] → C[e']
```

**示例**:

```rust
// (λx. x + 1) 42
// → [x := 42](x + 1)
// → 42 + 1
// → 43

fn main() {
    let add_one = |x: i32| x + 1;
    let result = add_one(42);  // → 43
    println!("{}", result);
}
```

---

## 4. 所有权规则

**所有权类型规则**:

```text
[Own-Move]
Γ ⊢ e : T    x ∉ dom(Γ)
────────────────────────
Γ, x : T ⊢ let x = e


[Own-Use]
Γ, x : T ⊢ e : T'    x 在 e 中使用一次
───────────────────────────────────────
Γ ⊢ let y = e : T'


[Own-Drop]
Γ, x : T ⊢ e : T'    x 不在 e 中使用
────────────────────────────────────
Γ ⊢ let y = e : T'
```

**示例**:

```rust
// 形式化推导:
// ─────────────────────────────
// ⊢ String::from("hello") : String
// ─────────────────────────────────────
// x : String ⊢ x : String  (移动)
// ─────────────────────────────────────
// y : String ⊢ println!(y)
//
// x 在第二次使用时不可用

fn main() {
    let x = String::from("hello");
    let y = x;  // x 移动到 y
    println!("{}", y);
    // println!("{}", x);  // ❌ x 已失效
}
```

---

## 5. 借用检查

**借用规则**:

```text
[Borrow-Shared]
Γ ⊢ e : T    'a fresh
─────────────────────
Γ ⊢ &e : &'a T
Γ' = Γ + {shared borrows}


[Borrow-Mut]
Γ ⊢ e : T    'a fresh    no active borrows
─────────────────────────────────────────
Γ ⊢ &mut e : &'a mut T
Γ' = Γ + {exclusive borrow}


[Borrow-Use]
Γ, x : &'a T ⊢ e : T'    'a outlives e
─────────────────────────────────────
Γ ⊢ e : T'
```

**示例**:

```rust
// 形式化:
// x : String
// ──────────────────
// r1 : &'a String    (shared)
// ──────────────────
// r2 : &'b String    (shared, 'a ∩ 'b valid)
// ──────────────────
// no active borrows
// ──────────────────
// r3 : &'c mut String  (exclusive)

fn main() {
    let mut x = String::from("hello");
    
    {
        let r1 = &x;
        let r2 = &x;
        println!("{} {}", r1, r2);
    } // r1, r2 结束
    
    let r3 = &mut x;
    r3.push_str(" world");
    println!("{}", r3);
}
```

---

## 6. 生命周期推断

**生命周期约束**:

```text
[Life-Var]
Γ(x) = &'a T
────────────────
Γ ⊢ x : &'a T


[Life-Sub]
Γ ⊢ e : &'a T    'a : 'b
─────────────────────────
Γ ⊢ e : &'b T


[Life-Ref]
Γ ⊢ e : T    'a covers e
─────────────────────────
Γ ⊢ &e : &'a T


[Life-Fun]
Γ, x : &'a T1 ⊢ e : &'b T2    'a : 'b
───────────────────────────────────────
Γ ⊢ fn(x: &'a T1) -> &'b T2
```

**示例**:

```rust
// 形式化:
// x : &'a str, y : &'b str
// ─────────────────────────
// longest : fn(&'a str, &'a str) -> &'a str
//
// 约束: 'a = min('a_x, 'a_y)

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let s1 = String::from("long string");
    let s2 = String::from("short");
    let result = longest(&s1, &s2);
    println!("{}", result);
}
```

---

## 7. 类型健全性

**类型保全性定理**:

```text
Theorem (Preservation):
如果 Γ ⊢ e : T 且 e, Σ → e', Σ'
则 Γ ⊢ e' : T

证明：对 e → e' 的推导进行归纳。
```

**进展性定理**:

```text
Theorem (Progress):
如果 ∅ ⊢ e : T
则 e 是值 或 存在 e', Σ' 使得 e, Σ → e', Σ'

证明：对 Γ ⊢ e : T 的推导进行归纳。
```

**内存安全定理**:

```text
Theorem (Memory Safety):
如果 Γ ⊢ e : T 且 e, Σ →* v, Σ'
则:
1. 所有解引用都是有效的
2. 没有悬垂指针
3. 没有数据竞争

证明：结合所有权、借用和生命周期规则。
```

---

## 8. 总结

**形式化系统的组成**:

| 组件 | 作用 |
|------|------|
| **语法** | 定义程序结构 |
| **类型规则** | 静态语义 |
| **操作语义** | 动态语义 |
| **所有权** | 资源管理 |
| **借用** | 别名控制 |
| **生命周期** | 时间约束 |

**关键性质**:

1. ✅ **类型健全性**: 类型正确的程序不会出错
2. ✅ **内存安全**: 无悬垂指针、无数据竞争
3. ✅ **进展性**: 良类型程序要么是值，要么可以继续执行

---

## 9. 参考资源

**学术论文**:

- "RustBelt: Securing the Foundations of the Rust Programming Language" (POPL 2018)
  - 使用 Iris 分离逻辑形式化 Rust
- "Oxide: The Essence of Rust" (ECOOP 2019)
  - Rust 核心的形式化模型
- "Stacked Borrows: An Aliasing Model for Rust" (POPL 2020)
  - 借用检查的操作语义

**工具**:

- [Coq](https://coq.inria.fr/) - 证明助手
- [Iris](https://iris-project.org/) - 分离逻辑框架

**相关文档**:

- [4.1 类型理论深度](./01_类型理论深度.md)
- [2.5 生命周期指南](../tier_02_guides/05_生命周期指南.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🎓 完成类型系统形式化学习！** 🦀
