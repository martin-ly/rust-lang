# 4.2 Rust 类型系统 - 高级泛型模式

> **文档类型**: Tier 4 - 高级层
> **文档定位**: 高级泛型编程模式
> **适用对象**: 高级开发者
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
> **最后更新**: 2025-12-11

---

## 📋 目录

- [4.2 Rust 类型系统 - 高级泛型模式](#42-rust-类型系统---高级泛型模式)
  - [📋 目录](#-目录)
  - [📐 知识结构](#-知识结构)
    - [概念定义](#概念定义)
    - [属性特征](#属性特征)
    - [关系连接](#关系连接)
    - [思维导图](#思维导图)
    - [多维概念对比矩阵](#多维概念对比矩阵)
    - [决策树图](#决策树图)
  - [🎯 概述](#-概述)
  - [1. 类型状态模式](#1-类型状态模式)
    - [1.1 基础类型状态](#11-基础类型状态)
  - [2. 类型见证模式](#2-类型见证模式)
    - [2.1 类型见证高级应用](#21-类型见证高级应用)
  - [3. Newtype 模式](#3-newtype-模式)
    - [3.1 Newtype高级应用：金融系统类型安全](#31-newtype高级应用金融系统类型安全)
  - [4. Visitor 模式](#4-visitor-模式)
  - [5. Extension Traits](#5-extension-traits)
  - [6. Sealed Traits](#6-sealed-traits)
  - [7. 类型擦除](#7-类型擦除)
  - [8. 高级组合模式](#8-高级组合模式)
    - [8.1 HKT模拟](#81-hkt模拟)
    - [8.2 类型级编程](#82-类型级编程)
    - [8.3 依赖类型模拟](#83-依赖类型模拟)
  - [9. 性能优化模式](#9-性能优化模式)
    - [9.1 单态化](#91-单态化)
    - [9.2 内联优化](#92-内联优化)
    - [9.3 编译时计算](#93-编译时计算)
    - [9.4 SIMD与泛型优化](#94-simd与泛型优化)
    - [9.5 泛型与异构编程](#95-泛型与异构编程)
  - [9.6 GAT高级应用案例](#96-gat高级应用案例)
    - [案例1：零拷贝异步Stream](#案例1零拷贝异步stream)
    - [案例2：类型安全的数据库查询构建器](#案例2类型安全的数据库查询构建器)
    - [案例3：类型安全的单位系统](#案例3类型安全的单位系统)
  - [9.7 类型级列表与异构集合](#97-类型级列表与异构集合)
  - [10. 总结](#10-总结)
  - [11. 参考资源](#11-参考资源)

---

## 📐 知识结构

### 概念定义

**高级泛型模式 (Advanced Generic Patterns)**:

- **定义**: Rust 1.92.0 高级泛型编程模式，包括类型状态模式、类型见证模式、Newtype 模式、Visitor 模式、Extension Traits、Sealed Traits、类型擦除、高级组合模式等
- **类型**: 高级层文档
- **范畴**: 类型系统、泛型编程
- **版本**: Rust 1.92.0+ (Edition 2024)
- **相关概念**: 泛型模式、类型状态、Newtype、Visitor、Extension Traits、类型擦除、HKT 模拟

### 属性特征

**核心属性**:

- **类型状态模式**: 基础类型状态、实现编译时状态机、构建器模式的类型安全版本、协议状态管理
- **类型见证模式**: 类型见证高级应用
- **Newtype 模式**: Newtype 高级应用（金融系统类型安全）
- **Visitor 模式**: 访问者模式实现
- **Extension Traits**: 扩展 Trait 模式
- **Sealed Traits**: 密封 Trait 模式

**Rust 1.92.0 新特性**:

- **改进的类型状态模式**: 更简洁的类型状态实现
- **增强的 GAT 支持**: 更好的 GAT 高级应用
- **优化的类型级编程**: 更强大的类型级列表与异构集合

**性能特征**:

- **零成本抽象**: 所有模式零运行时开销
- **编译时检查**: 编译期状态检查
- **适用场景**: 类型安全 API、状态机、代码复用

### 关系连接

**组合关系**:

- 高级泛型模式 --[covers]--> 多种泛型模式
- 类型安全程序 --[uses]--> 高级泛型模式

**依赖关系**:

- 高级泛型模式 --[depends-on]--> 泛型系统
- 类型安全设计 --[depends-on]--> 高级泛型模式

### 思维导图

```text
高级泛型模式
│
├── 类型状态模式
│   └── 编译时状态机
├── 类型见证模式
│   └── 类型见证
├── Newtype 模式
│   └── 类型安全
├── Visitor 模式
│   └── 访问者模式
├── Extension Traits
│   └── 扩展 Trait
└── Sealed Traits
    └── 密封 Trait
```

### 多维概念对比矩阵

| 泛型模式             | 复杂度 | 性能   | 类型安全 | 适用场景   | Rust 1.92.0 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **类型状态模式**     | 中     | 零开销 | 高       | 状态机     | ✅ 改进     |
| **Newtype 模式**     | 低     | 零开销 | 高       | 类型安全   | ✅          |
| **Visitor 模式**     | 中     | 零开销 | 高       | 遍历结构   | ✅          |
| **Extension Traits** | 低     | 零开销 | 高       | 扩展功能   | ✅          |
| **Sealed Traits**    | 中     | 零开销 | 高       | 受限 Trait | ✅          |
| **类型擦除**         | 高     | 零开销 | 中       | 动态分发   | ✅          |

### 决策树图

```text
选择泛型模式
│
├── 是否需要状态管理？
│   ├── 是 → 类型状态模式
│   └── 否 → 继续判断
│       ├── 是否需要类型安全？
│       │   ├── 是 → Newtype 模式
│       │   └── 否 → 继续判断
│       │       ├── 是否需要扩展功能？
│       │       │   ├── 是 → Extension Traits
│       │       │   └── 否 → Visitor 模式
```

---

## 🎯 概述

高级泛型模式用于：

- 🔒 编译时状态检查
- 🎯 类型安全的 API
- 🔄 灵活的代码复用
- ⚡ 零成本抽象

---

## 1. 类型状态模式

### 1.1 基础类型状态

**设计原则**:

类型状态模式(Typestate Pattern)将对象的状态编码到类型系统中，使得非法状态转换在编译时被拒绝。这是Rust零成本抽象的典型应用。

**核心优势**:

1. **编译时状态验证**：非法状态转换在编译时被捕获
2. **零运行时开销**：幻影类型在编译后被擦除
3. **API强制约束**：类型系统强制正确的使用顺序
4. **自文档化**：类型签名清晰表达状态转换

**使用类型编码状态**:

```rust
use std::marker::PhantomData;

// 状态标记
struct New;
struct Initialized;
struct Configured;
struct Running;

// 构建器，使用幻影类型跟踪状态
struct Builder<State> {
    config: Option<String>,
    _state: PhantomData<State>,
}

impl Builder<New> {
    fn new() -> Self {
        Builder {
            config: None,
            _state: PhantomData,
        }
    }

    fn initialize(self) -> Builder<Initialized> {
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Initialized> {
    fn configure(mut self, config: String) -> Builder<Configured> {
        self.config = Some(config);
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Configured> {
    fn build(self) -> Builder<Running> {
        println!("Building with config: {:?}", self.config);
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Running> {
    fn run(&self) {
        println!("Running...");
    }
}

fn main() {
    let builder = Builder::<New>::new()
        .initialize()
        .configure(String::from("config.toml"))
        .build();

    builder.run();

    // ❌ 编译错误：无法跳过状态
    // let bad = Builder::<New>::new().build();
}
```

**复杂状态机**:

```rust
use std::marker::PhantomData;

// TCP 连接状态
struct Closed;
struct Listen;
struct SynRcvd;
struct Established;

struct TcpConnection<State> {
    socket: String,
    _state: PhantomData<State>,
}

impl TcpConnection<Closed> {
    fn new(socket: String) -> Self {
        TcpConnection {
            socket,
            _state: PhantomData,
        }
    }

    fn listen(self) -> TcpConnection<Listen> {
        println!("Listening on {}", self.socket);
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Listen> {
    fn accept(self) -> TcpConnection<SynRcvd> {
        println!("SYN received");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<SynRcvd> {
    fn acknowledge(self) -> TcpConnection<Established> {
        println!("Connection established");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Established> {
    fn send(&self, data: &str) {
        println!("Sending: {}", data);
    }

    fn close(self) -> TcpConnection<Closed> {
        println!("Connection closed");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

fn main() {
    let conn = TcpConnection::<Closed>::new(String::from("127.0.0.1:8080"))
        .listen()
        .accept()
        .acknowledge();

    conn.send("Hello");
    let _closed = conn.close();
}
```

---

## 2. 类型见证模式

**使用类型证明属性**:

```rust
use std::marker::PhantomData;

// 空类型作为证明
struct NonEmpty;

struct Vec<T, Proof = ()> {
    inner: std::vec::Vec<T>,
    _proof: PhantomData<Proof>,
}

impl<T> Vec<T, ()> {
    fn new() -> Self {
        Vec {
            inner: std::vec::Vec::new(),
            _proof: PhantomData,
        }
    }

    fn push(mut self, item: T) -> Vec<T, NonEmpty> {
        self.inner.push(item);
        Vec {
            inner: self.inner,
            _proof: PhantomData,
        }
    }
}

impl<T> Vec<T, NonEmpty> {
    fn first(&self) -> &T {
        &self.inner[0]  // 保证非空，不会 panic
    }

    fn push(mut self, item: T) -> Self {
        self.inner.push(item);
        self
    }
}

fn main() {
    let empty = Vec::<i32>::new();
    // empty.first();  // ❌ 编译错误：没有 first 方法

    let non_empty = empty.push(1);
    println!("First: {}", non_empty.first());  // ✅ 安全
}
```

**排序见证**:

```rust
use std::marker::PhantomData;

struct Unsorted;
struct Sorted;

struct List<T, State = Unsorted> {
    items: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> List<T, Unsorted> {
    fn new(items: Vec<T>) -> Self {
        List {
            items,
            _state: PhantomData,
        }
    }

    fn sort(mut self) -> List<T, Sorted>
    where
        T: Ord,
    {
        self.items.sort();
        List {
            items: self.items,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> List<T, Sorted> {
    fn binary_search(&self, item: &T) -> Result<usize, usize> {
        self.items.binary_search(item)  // 保证已排序
    }
}

fn main() {
    let unsorted = List::new(vec![3, 1, 4, 1, 5]);
    // unsorted.binary_search(&3);  // ❌ 编译错误

    let sorted = unsorted.sort();
    println!("{:?}", sorted.binary_search(&3));  // ✅ 安全
}
```

### 2.1 类型见证高级应用

**案例1：编译时排序证明**:

```rust
use std::marker::PhantomData;

// 排序状态标记
struct Unsorted;
struct Sorted;

struct List<T, State = Unsorted> {
    data: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> List<T, Unsorted> {
    fn new(data: Vec<T>) -> Self {
        List {
            data,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> List<T, Unsorted> {
    fn sort(mut self) -> List<T, Sorted> {
        self.data.sort();
        List {
            data: self.data,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> List<T, Sorted> {
    // ✅ 只有排序后的列表可以进行二分查找
    fn binary_search(&self, target: &T) -> Result<usize, usize> {
        self.data.binary_search(target)
    }

    fn get(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

fn main() {
    let unsorted = List::new(vec![3, 1, 4, 1, 5]);

    // ❌ 编译错误：未排序的列表不能进行二分查找
    // unsorted.binary_search(&3);

    let sorted = unsorted.sort();
    let result = sorted.binary_search(&3);
    println!("{:?}", result);
}
```

**案例2：类型安全的验证链**:

```rust
use std::marker::PhantomData;

// 验证状态
struct Unvalidated;
struct EmailValidated;
struct PhoneValidated;

struct UserData<EmailState = Unvalidated, PhoneState = Unvalidated> {
    email: String,
    phone: String,
    _email_state: PhantomData<EmailState>,
    _phone_state: PhantomData<PhoneState>,
}

impl UserData<Unvalidated, Unvalidated> {
    fn new(email: String, phone: String) -> Self {
        UserData {
            email,
            phone,
            _email_state: PhantomData,
            _phone_state: PhantomData,
        }
    }
}

impl<P> UserData<Unvalidated, P> {
    fn validate_email(self) -> Result<UserData<EmailValidated, P>, String> {
        if self.email.contains('@') {
            Ok(UserData {
                email: self.email,
                phone: self.phone,
                _email_state: PhantomData,
                _phone_state: PhantomData,
            })
        } else {
            Err("Invalid email".to_string())
        }
    }
}

impl<E> UserData<E, Unvalidated> {
    fn validate_phone(self) -> Result<UserData<E, PhoneValidated>, String> {
        if self.phone.len() >= 10 {
            Ok(UserData {
                email: self.email,
                phone: self.phone,
                _email_state: PhantomData,
                _phone_state: PhantomData,
            })
        } else {
            Err("Invalid phone".to_string())
        }
    }
}

impl UserData<EmailValidated, PhoneValidated> {
    // ✅ 只有完全验证后才能保存
    fn save_to_database(&self) {
        println!("Saving validated user: {}, {}", self.email, self.phone);
    }
}

fn main() {
    let user = UserData::new(
        "user@example.com".to_string(),
        "1234567890".to_string(),
    );

    // ❌ 编译错误：未验证不能保存
    // user.save_to_database();

    let user = user
        .validate_email()
        .expect("Email validation failed")
        .validate_phone()
        .expect("Phone validation failed");

    // ✅ 现在可以保存了
    user.save_to_database();
}
```

**案例3：编译时权限检查**:

```rust
use std::marker::PhantomData;

// 权限级别
struct Guest;
struct User;
struct Admin;

struct Resource<Permission> {
    data: String,
    _permission: PhantomData<Permission>,
}

impl Resource<Guest> {
    fn new(data: String) -> Self {
        Resource {
            data,
            _permission: PhantomData,
        }
    }

    fn read(&self) -> &str {
        &self.data
    }
}

impl Resource<User> {
    fn write(&mut self, data: String) {
        self.data = data;
    }
}

impl Resource<Admin> {
    fn delete(self) {
        println!("Resource deleted");
    }
}

// 权限提升（需要认证）
impl Resource<Guest> {
    fn authenticate(self, password: &str) -> Option<Resource<User>> {
        if password == "secret" {
            Some(Resource {
                data: self.data,
                _permission: PhantomData,
            })
        } else {
            None
        }
    }
}

impl Resource<User> {
    fn elevate_to_admin(self, admin_key: &str) -> Option<Resource<Admin>> {
        if admin_key == "admin123" {
            Some(Resource {
                data: self.data,
                _permission: PhantomData,
            })
        } else {
            None
        }
    }
}

fn main() {
    let guest_resource = Resource::<Guest>::new("Sensitive Data".to_string());

    // ✅ Guest 可以读取
    println!("Guest reads: {}", guest_resource.read());

    // ❌ 编译错误：Guest 不能写入
    // guest_resource.write("Modified".to_string());

    // 认证后变成User
    let mut user_resource = guest_resource
        .authenticate("secret")
        .expect("Authentication failed");

    // ✅ User 可以写入
    user_resource.write("Modified Data".to_string());

    // ❌ 编译错误：User 不能删除
    // user_resource.delete();

    // 提升到Admin
    let admin_resource = user_resource
        .elevate_to_admin("admin123")
        .expect("Elevation failed");

    // ✅ Admin 可以删除
    admin_resource.delete();
}
```

---

## 3. Newtype 模式

**类型安全封装**:

```rust
// 强类型 ID
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) -> String {
    format!("User {}", id.0)
}

fn get_product(id: ProductId) -> String {
    format!("Product {}", id.0)
}

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);

    println!("{}", get_user(user_id));
    // println!("{}", get_user(product_id));  // ❌ 编译错误
}
```

**计量单位**:

```rust
use std::ops::{Add, Mul};

#[derive(Debug, Copy, Clone)]
struct Meters(f64);

#[derive(Debug, Copy, Clone)]
struct Seconds(f64);

#[derive(Debug, Copy, Clone)]
struct MetersPerSecond(f64);

impl Add for Meters {
    type Output = Meters;

    fn add(self, rhs: Self) -> Self::Output {
        Meters(self.0 + rhs.0)
    }
}

impl Mul<Seconds> for MetersPerSecond {
    type Output = Meters;

    fn mul(self, rhs: Seconds) -> Self::Output {
        Meters(self.0 * rhs.0)
    }
}

fn main() {
    let distance1 = Meters(100.0);
    let distance2 = Meters(50.0);
    let total = distance1 + distance2;
    println!("Total distance: {:?}", total);

    let velocity = MetersPerSecond(10.0);
    let time = Seconds(5.0);
    let distance = velocity * time;
    println!("Distance traveled: {:?}", distance);

    // let bad = distance1 + time;  // ❌ 编译错误：类型不匹配
}
```

### 3.1 Newtype高级应用：金融系统类型安全

**案例：防止货币错误的类型系统**:

```rust
use std::ops::{Add, Sub, Mul, Div};
use std::marker::PhantomData;

// 货币标记
struct USD;
struct EUR;
struct CNY;

// 强类型货币
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
struct Money<Currency> {
    amount: f64,
    _currency: PhantomData<Currency>,
}

impl<C> Money<C> {
    fn new(amount: f64) -> Self {
        Money {
            amount,
            _currency: PhantomData,
        }
    }

    fn amount(&self) -> f64 {
        self.amount
    }
}

// 相同货币可以相加
impl<C> Add for Money<C> {
    type Output = Money<C>;
    fn add(self, rhs: Self) -> Self::Output {
        Money::new(self.amount + rhs.amount)
    }
}

// 相同货币可以相减
impl<C> Sub for Money<C> {
    type Output = Money<C>;
    fn sub(self, rhs: Self) -> Self::Output {
        Money::new(self.amount - rhs.amount)
    }
}

// 货币可以乘以标量
impl<C> Mul<f64> for Money<C> {
    type Output = Money<C>;
    fn mul(self, rhs: f64) -> Self::Output {
        Money::new(self.amount * rhs)
    }
}

// 货币可以除以标量
impl<C> Div<f64> for Money<C> {
    type Output = Money<C>;
    fn div(self, rhs: f64) -> Self::Output {
        Money::new(self.amount / rhs)
    }
}

// 汇率类型（编译时检查方向）
struct ExchangeRate<From, To> {
    rate: f64,
    _from: PhantomData<From>,
    _to: PhantomData<To>,
}

impl<From, To> ExchangeRate<From, To> {
    fn new(rate: f64) -> Self {
        ExchangeRate {
            rate,
            _from: PhantomData,
            _to: PhantomData,
        }
    }

    fn convert(&self, amount: Money<From>) -> Money<To> {
        Money::new(amount.amount * self.rate)
    }
}

// 金融计算示例
fn calculate_total_in_usd() -> Money<USD> {
    // 定义汇率
    let eur_to_usd = ExchangeRate::<EUR, USD>::new(1.18);
    let cny_to_usd = ExchangeRate::<CNY, USD>::new(0.16);

    // 不同货币的金额
    let usd_amount = Money::<USD>::new(100.0);
    let eur_amount = Money::<EUR>::new(50.0);
    let cny_amount = Money::<CNY>::new(300.0);

    // ❌ 编译错误：不能直接相加不同货币
    // let total = usd_amount + eur_amount;  // 类型不匹配

    // ✅ 正确：先转换货币再相加
    let eur_in_usd = eur_to_usd.convert(eur_amount);
    let cny_in_usd = cny_to_usd.convert(cny_amount);

    let total = usd_amount + eur_in_usd + cny_in_usd;

    println!("Total in USD: ${:.2}", total.amount());
    total
}

fn main() {
    let total = calculate_total_in_usd();

    // 应用折扣
    let discounted = total * 0.9;
    println!("After 10% discount: ${:.2}", discounted.amount());
}
```

**案例：类型安全的百分比计算**:

```rust
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
struct Percentage(f64);

impl Percentage {
    // 智能构造函数，确保范围有效
    fn new(value: f64) -> Option<Self> {
        if (0.0..=100.0).contains(&value) {
            Some(Percentage(value))
        } else {
            None
        }
    }

    // 从小数创建（0.0-1.0）
    fn from_decimal(value: f64) -> Option<Self> {
        if (0.0..=1.0).contains(&value) {
            Some(Percentage(value * 100.0))
        } else {
            None
        }
    }

    fn as_decimal(&self) -> f64 {
        self.0 / 100.0
    }

    fn as_percentage(&self) -> f64 {
        self.0
    }
}

// 应用百分比到数值
fn apply_percentage<T>(value: T, percentage: Percentage) -> T
where
    T: std::ops::Mul<f64, Output = T>,
{
    value * percentage.as_decimal()
}

fn main() {
    let price = 100.0;

    // ✅ 类型安全的百分比
    if let Some(tax) = Percentage::new(18.0) {
        let tax_amount = apply_percentage(price, tax);
        println!("Tax: ${:.2}", tax_amount);
    }

    // ❌ 无效的百分比会被拒绝
    assert!(Percentage::new(150.0).is_none());
}
```

---

## 4. Visitor 模式

**类型安全的 Visitor**:

```rust
trait Visitor {
    type Output;

    fn visit_int(&mut self, value: i32) -> Self::Output;
    fn visit_string(&mut self, value: &str) -> Self::Output;
    fn visit_bool(&mut self, value: bool) -> Self::Output;
}

enum Value {
    Int(i32),
    String(String),
    Bool(bool),
}

impl Value {
    fn accept<V: Visitor>(&self, visitor: &mut V) -> V::Output {
        match self {
            Value::Int(i) => visitor.visit_int(*i),
            Value::String(s) => visitor.visit_string(s),
            Value::Bool(b) => visitor.visit_bool(*b),
        }
    }
}

// 具体 Visitor：打印
struct PrintVisitor;

impl Visitor for PrintVisitor {
    type Output = ();

    fn visit_int(&mut self, value: i32) {
        println!("Int: {}", value);
    }

    fn visit_string(&mut self, value: &str) {
        println!("String: {}", value);
    }

    fn visit_bool(&mut self, value: bool) {
        println!("Bool: {}", value);
    }
}

// 具体 Visitor：序列化
struct JsonVisitor;

impl Visitor for JsonVisitor {
    type Output = String;

    fn visit_int(&mut self, value: i32) -> String {
        value.to_string()
    }

    fn visit_string(&mut self, value: &str) -> String {
        format!("\"{}\"", value)
    }

    fn visit_bool(&mut self, value: bool) -> String {
        value.to_string()
    }
}

fn main() {
    let values = vec![
        Value::Int(42),
        Value::String(String::from("hello")),
        Value::Bool(true),
    ];

    let mut print_visitor = PrintVisitor;
    let mut json_visitor = JsonVisitor;

    for value in &values {
        value.accept(&mut print_visitor);
        let json = value.accept(&mut json_visitor);
        println!("JSON: {}", json);
    }
}
```

---

## 5. Extension Traits

**为外部类型添加方法**:

```rust
trait IntExt {
    fn is_even(self) -> bool;
    fn is_odd(self) -> bool;
}

impl IntExt for i32 {
    fn is_even(self) -> bool {
        self % 2 == 0
    }

    fn is_odd(self) -> bool {
        !self.is_even()
    }
}

fn main() {
    println!("4 is even: {}", 4.is_even());
    println!("5 is odd: {}", 5.is_odd());
}
```

**泛型扩展**:

```rust
trait IteratorExt: Iterator {
    fn collect_vec(self) -> Vec<Self::Item>
    where
        Self: Sized,
    {
        self.collect()
    }

    fn sum_default(self) -> Self::Item
    where
        Self: Sized,
        Self::Item: Default + std::ops::Add<Output = Self::Item>,
    {
        self.fold(Self::Item::default(), |a, b| a + b)
    }
}

impl<T: Iterator> IteratorExt for T {}

fn main() {
    let vec = (1..=5).collect_vec();
    println!("Vec: {:?}", vec);

    let sum = (1..=10).sum_default();
    println!("Sum: {}", sum);
}
```

---

## 6. Sealed Traits

**防止外部实现**:

```rust
mod sealed {
    pub trait Sealed {}

    impl Sealed for i32 {}
    impl Sealed for f64 {}
    impl Sealed for String {}
}

pub trait Number: sealed::Sealed {
    fn double(&self) -> Self;
}

impl Number for i32 {
    fn double(&self) -> Self {
        self * 2
    }
}

impl Number for f64 {
    fn double(&self) -> Self {
        self * 2.0
    }
}

// 外部无法实现 Number trait
// impl Number for MyType {}  // ❌ 编译错误：未实现 Sealed

fn main() {
    println!("Double 21: {}", 21.double());
    println!("Double 3.14: {}", 3.14.double());
}
```

---

## 7. 类型擦除

**动态分发的类型擦除**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

// 类型擦除容器
struct DrawBox {
    inner: Box<dyn Draw>,
}

impl DrawBox {
    fn new<T: Draw + 'static>(value: T) -> Self {
        DrawBox {
            inner: Box::new(value),
        }
    }

    fn draw(&self) {
        self.inner.draw();
    }
}

fn main() {
    let shapes: Vec<DrawBox> = vec![
        DrawBox::new(Circle { radius: 5.0 }),
        DrawBox::new(Rectangle { width: 10.0, height: 20.0 }),
    ];

    for shape in &shapes {
        shape.draw();
    }
}
```

---

## 8. 高级组合模式

### 8.1 HKT模拟

**Higher-Kinded Types（HKT）模拟**:

虽然Rust不直接支持HKT，但可以通过关联类型模拟：

```rust
// 模拟 Functor typeclass
trait Functor {
    type Wrapped<T>;

    fn map<A, B, F>(fa: Self::Wrapped<A>, f: F) -> Self::Wrapped<B>
    where
        F: FnOnce(A) -> B;
}

// Option 的 Functor 实现
struct OptionFunctor;

impl Functor for OptionFunctor {
    type Wrapped<T> = Option<T>;

    fn map<A, B, F>(fa: Option<A>, f: F) -> Option<B>
    where
        F: FnOnce(A) -> B,
    {
        fa.map(f)
    }
}

// Vec 的 Functor 实现
struct VecFunctor;

impl Functor for VecFunctor {
    type Wrapped<T> = Vec<T>;

    fn map<A, B, F>(fa: Vec<A>, f: F) -> Vec<B>
    where
        F: FnOnce(A) -> B + Clone,
    {
        fa.into_iter().map(f).collect()
    }
}

fn main() {
    let opt = Some(42);
    let result = OptionFunctor::map(opt, |x| x * 2);
    println!("{:?}", result);

    let vec = vec![1, 2, 3];
    let doubled = VecFunctor::map(vec, |x| x * 2);
    println!("{:?}", doubled);
}
```

**Monad 模拟**:

```rust
trait Monad: Functor {
    fn pure<T>(value: T) -> Self::Wrapped<T>;

    fn bind<A, B, F>(ma: Self::Wrapped<A>, f: F) -> Self::Wrapped<B>
    where
        F: FnOnce(A) -> Self::Wrapped<B>;
}

impl Monad for OptionFunctor {
    fn pure<T>(value: T) -> Option<T> {
        Some(value)
    }

    fn bind<A, B, F>(ma: Option<A>, f: F) -> Option<B>
    where
        F: FnOnce(A) -> Option<B>,
    {
        ma.and_then(f)
    }
}

fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

fn main() {
    let result = OptionFunctor::bind(Some(10), |x| safe_divide(x, 2));
    println!("{:?}", result);  // Some(5)

    let error = OptionFunctor::bind(Some(10), |x| safe_divide(x, 0));
    println!("{:?}", error);  // None
}
```

### 8.2 类型级编程

**类型级自然数**:

```rust
use std::marker::PhantomData;

// Peano 数
trait Nat {}

struct Zero;
impl Nat for Zero {}

struct Succ<N: Nat>(PhantomData<N>);
impl<N: Nat> Nat for Succ<N> {}

// 类型别名
type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;
type Four = Succ<Three>;
type Five = Succ<Four>;

// 类型级加法
trait Add<N: Nat> {
    type Output: Nat;
}

impl<N: Nat> Add<Zero> for N {
    type Output = N;
}

impl<N: Nat, M: Nat> Add<Succ<M>> for N
where
    N: Add<M>,
{
    type Output = Succ<<N as Add<M>>::Output>;
}

// 类型级比较
trait LessThan<N: Nat> {}

impl<N: Nat> LessThan<Succ<N>> for Zero {}

impl<N: Nat, M: Nat> LessThan<Succ<M>> for Succ<N>
where
    N: LessThan<M>,
{}

// 使用示例
fn assert_less_than<N: Nat, M: Nat>()
where
    N: LessThan<M>,
{}

fn main() {
    // 编译时证明 1 < 3
    assert_less_than::<One, Three>();

    // ❌ 编译错误：3 不小于 1
    // assert_less_than::<Three, One>();

    // 类型级加法
    type Sum = <Two as Add<Three>>::Output;  // Sum = Five
}
```

**类型级布尔运算**:

```rust
trait Bool {}

struct True;
impl Bool for True {}

struct False;
impl Bool for False {}

// NOT
trait Not {
    type Output: Bool;
}

impl Not for True {
    type Output = False;
}

impl Not for False {
    type Output = True;
}

// AND
trait And<B: Bool> {
    type Output: Bool;
}

impl And<True> for True {
    type Output = True;
}

impl And<False> for True {
    type Output = False;
}

impl<B: Bool> And<B> for False {
    type Output = False;
}

// OR
trait Or<B: Bool> {
    type Output: Bool;
}

impl<B: Bool> Or<B> for True {
    type Output = True;
}

impl Or<True> for False {
    type Output = True;
}

impl Or<False> for False {
    type Output = False;
}

fn main() {
    // 类型级布尔计算
    type Result1 = <True as And<False>>::Output;  // False
    type Result2 = <True as Or<False>>::Output;   // True
    type Result3 = <False as Not>::Output;         // True
}
```

### 8.3 依赖类型模拟

**类型级长度的Vector**:

```rust
use std::marker::PhantomData;

// 自然数类型
trait Nat {
    const VALUE: usize;
}

struct Zero;
impl Nat for Zero {
    const VALUE: usize = 0;
}

struct Succ<N: Nat>(PhantomData<N>);
impl<N: Nat> Nat for Succ<N> {
    const VALUE: usize = N::VALUE + 1;
}

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// 固定长度的Vector
struct Vec<T, N: Nat> {
    data: std::vec::Vec<T>,
    _len: PhantomData<N>,
}

impl<T, N: Nat> Vec<T, N> {
    fn len(&self) -> usize {
        N::VALUE
    }
}

impl<T> Vec<T, Zero> {
    fn new() -> Self {
        Vec {
            data: std::vec::Vec::new(),
            _len: PhantomData,
        }
    }
}

impl<T, N: Nat> Vec<T, N> {
    fn push(mut self, item: T) -> Vec<T, Succ<N>> {
        self.data.push(item);
        Vec {
            data: self.data,
            _len: PhantomData,
        }
    }

    fn get(&self, index: usize) -> Option<&T> {
        if index < N::VALUE {
            self.data.get(index)
        } else {
            None
        }
    }
}

// 类型安全的索引访问
impl<T, N: Nat> Vec<T, Succ<N>> {
    fn first(&self) -> &T {
        &self.data[0]  // 保证非空
    }
}

fn main() {
    let v = Vec::<i32, Zero>::new()
        .push(1)
        .push(2)
        .push(3);

    println!("Length: {}", v.len());  // 3
    println!("First: {}", v.first());  // 1

    // 空Vector没有first方法
    let empty = Vec::<i32, Zero>::new();
    // empty.first();  // ❌ 编译错误
}
```

**类型级矩阵尺寸**:

```rust
use std::ops::{Add, Mul};

struct Matrix<T, const M: usize, const N: usize> {
    data: [[T; N]; M],
}

impl<T: Default + Copy, const M: usize, const N: usize> Matrix<T, M, N> {
    fn new() -> Self {
        Matrix {
            data: [[T::default(); N]; M],
        }
    }
}

// 矩阵加法：相同尺寸
impl<T, const M: usize, const N: usize> Add for Matrix<T, M, N>
where
    T: Add<Output = T> + Copy + Default,
{
    type Output = Matrix<T, M, N>;

    fn add(self, other: Self) -> Self::Output {
        let mut result = Matrix::new();
        for i in 0..M {
            for j in 0..N {
                result.data[i][j] = self.data[i][j] + other.data[i][j];
            }
        }
        result
    }
}

// 矩阵乘法：类型级尺寸检查
impl<T, const M: usize, const N: usize, const P: usize> Matrix<T, M, N>
where
    T: Mul<Output = T> + Add<Output = T> + Copy + Default,
{
    fn mul(&self, other: &Matrix<T, N, P>) -> Matrix<T, M, P> {
        let mut result = Matrix::new();
        for i in 0..M {
            for j in 0..P {
                let mut sum = T::default();
                for k in 0..N {
                    sum = sum + self.data[i][k] * other.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        result
    }
}

fn main() {
    let m1 = Matrix::<i32, 2, 3>::new();
    let m2 = Matrix::<i32, 3, 4>::new();
    let m3 = m1.mul(&m2);  // Matrix<i32, 2, 4>

    // ❌ 编译错误：尺寸不匹配
    // let m4 = Matrix::<i32, 2, 5>::new();
    // let bad = m1.mul(&m4);
}
```

---

## 9. 性能优化模式

### 9.1 单态化

**泛型的单态化（Monomorphization）**:

Rust编译器为每个具体类型生成专门的代码：

```rust
// 泛型函数
fn generic_add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    // 编译器生成两个不同的函数
    let x = generic_add(1i32, 2i32);     // generic_add_i32
    let y = generic_add(1.0f64, 2.0f64); // generic_add_f64
}

// 编译后等价于：
// fn generic_add_i32(a: i32, b: i32) -> i32 { a + b }
// fn generic_add_f64(a: f64, b: f64) -> f64 { a + b }
```

**避免代码膨胀**:

```rust
// ❌ 不好：每个T都会生成新代码
fn process<T: std::fmt::Display>(items: Vec<T>) {
    for item in items {
        println!("{}", item);
    }
}

// ✅ 更好：使用trait对象减少代码膨胀
fn process_dyn(items: &[&dyn std::fmt::Display]) {
    for item in items {
        println!("{}", item);
    }
}
```

### 9.2 内联优化

**强制内联泛型函数**:

```rust
#[inline(always)]
fn fast_add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

#[inline]
fn map_and_sum<T, F>(data: &[T], f: F) -> T
where
    T: std::ops::Add<Output = T> + Copy + Default,
    F: Fn(T) -> T,
{
    data.iter()
        .copied()
        .map(f)
        .fold(T::default(), |acc, x| acc + x)
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let sum = map_and_sum(&data, |x| x * 2);
    println!("Sum: {}", sum);
}
```

### 9.3 编译时计算

**const泛型与编译时计算**:

```rust
// 编译时计算数组大小
const fn calculate_size<const N: usize>() -> usize {
    N * N
}

struct Grid<T, const N: usize> {
    data: [T; calculate_size::<N>()],
}

impl<T: Default + Copy, const N: usize> Grid<T, N> {
    fn new() -> Self {
        Grid {
            data: [T::default(); calculate_size::<N>()],
        }
    }

    fn get(&self, row: usize, col: usize) -> Option<&T> {
        if row < N && col < N {
            self.data.get(row * N + col)
        } else {
            None
        }
    }
}

fn main() {
    let grid = Grid::<i32, 3>::new();  // 3x3 grid, size = 9
    println!("Grid size: {}", grid.data.len());
}
```

**const trait bounds（实验性）**:

```rust
#![feature(const_trait_impl)]

#[const_trait]
trait ConstAdd {
    fn const_add(self, other: Self) -> Self;
}

impl const ConstAdd for i32 {
    fn const_add(self, other: Self) -> Self {
        self + other
    }
}

const fn compute<T: ~const ConstAdd>(a: T, b: T) -> T {
    a.const_add(b)
}

const RESULT: i32 = compute(10, 20);  // 编译时计算

fn main() {
    println!("Computed at compile time: {}", RESULT);
}
```

### 9.4 SIMD与泛型优化

**使用泛型实现SIMD抽象**:

```rust
use std::arch::x86_64::*;

// 泛型SIMD trait
trait SimdOps {
    type Output;
    fn add(self, rhs: Self) -> Self::Output;
    fn mul(self, rhs: Self) -> Self::Output;
}

// f32标量实现
impl SimdOps for f32 {
    type Output = f32;
    fn add(self, rhs: Self) -> Self {
        self + rhs
    }
    fn mul(self, rhs: Self) -> Self {
        self * rhs
    }
}

// f32 SIMD实现（AVX）
#[cfg(target_arch = "x86_64")]
impl SimdOps for __m256 {
    type Output = __m256;
    unsafe fn add(self, rhs: Self) -> Self {
        _mm256_add_ps(self, rhs)
    }
    unsafe fn mul(self, rhs: Self) -> Self {
        _mm256_mul_ps(self, rhs)
    }
}

// 通用算法可以用于标量和SIMD
fn dot_product<T: SimdOps + Copy>(a: &[T], b: &[T]) -> T::Output
where
    T::Output: Default + std::ops::AddAssign,
{
    let mut sum = T::Output::default();
    for (x, y) in a.iter().zip(b.iter()) {
        sum += (*x).mul(*y);
    }
    sum
}
```

### 9.5 泛型与异构编程

**编译时代码生成**:

```rust
// 使用泛型生成特化代码
trait ComputeKernel {
    fn compute(&self, input: &[f32], output: &mut [f32]);
}

struct CpuKernel;
impl ComputeKernel for CpuKernel {
    fn compute(&self, input: &[f32], output: &mut [f32]) {
        for (i, o) in input.iter().zip(output.iter_mut()) {
            *o = i * 2.0;  // CPU标量实现
        }
    }
}

#[cfg(target_arch = "x86_64")]
struct SimdKernel;
#[cfg(target_arch = "x86_64")]
impl ComputeKernel for SimdKernel {
    fn compute(&self, input: &[f32], output: &mut [f32]) {
        // SIMD向量化实现
        // ...
    }
}

// 编译时选择最优实现
fn select_kernel() -> Box<dyn ComputeKernel> {
    #[cfg(target_arch = "x86_64")]
    {
        if is_x86_feature_detected!("avx2") {
            Box::new(SimdKernel)
        } else {
            Box::new(CpuKernel)
        }
    }
    #[cfg(not(target_arch = "x86_64"))]
    {
        Box::new(CpuKernel)
    }
}
```

---

## 9.6 GAT高级应用案例

### 案例1：零拷贝异步Stream

```rust
// 使用GAT实现零拷贝的异步流
trait AsyncStream {
    type Item<'a> where Self: 'a;
    type Future<'a>: std::future::Future<Output = Option<Self::Item<'a>>>
    where
        Self: 'a;

    fn next<'a>(&'a mut self) -> Self::Future<'a>;
}

// 实现：从内存映射文件读取
struct MmapStream {
    data: &'static [u8],
    pos: usize,
    chunk_size: usize,
}

impl AsyncStream for MmapStream {
    type Item<'a> = &'a [u8];
    type Future<'a> = impl std::future::Future<Output = Option<&'a [u8]>> + 'a
    where
        Self: 'a;

    fn next<'a>(&'a mut self) -> Self::Future<'a> {
        async move {
            if self.pos >= self.data.len() {
                return None;
            }

            let end = (self.pos + self.chunk_size).min(self.data.len());
            let chunk = &self.data[self.pos..end];
            self.pos = end;
            Some(chunk)
        }
    }
}
```

### 案例2：类型安全的数据库查询构建器

```rust
use std::marker::PhantomData;

// 查询状态
struct NoTable;
struct HasTable;
struct NoWhere;
struct HasWhere;

// 查询构建器
struct QueryBuilder<TableState, WhereState> {
    table: Option<String>,
    where_clause: Option<String>,
    _table_state: PhantomData<TableState>,
    _where_state: PhantomData<WhereState>,
}

impl QueryBuilder<NoTable, NoWhere> {
    fn new() -> Self {
        QueryBuilder {
            table: None,
            where_clause: None,
            _table_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<W> QueryBuilder<NoTable, W> {
    fn table(self, name: &str) -> QueryBuilder<HasTable, W> {
        QueryBuilder {
            table: Some(name.to_string()),
            where_clause: self.where_clause,
            _table_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<T> QueryBuilder<T, NoWhere> {
    fn where_clause(self, condition: &str) -> QueryBuilder<T, HasWhere> {
        QueryBuilder {
            table: self.table,
            where_clause: Some(condition.to_string()),
            _table_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl QueryBuilder<HasTable, HasWhere> {
    fn build(self) -> String {
        format!(
            "SELECT * FROM {} WHERE {}",
            self.table.unwrap(),
            self.where_clause.unwrap()
        )
    }
}

fn main() {
    let query = QueryBuilder::new()
        .table("users")
        .where_clause("age > 18")
        .build();

    println!("{}", query);

    // ❌ 编译错误：缺少table
    // let invalid = QueryBuilder::new().where_clause("age > 18").build();
}
```

### 案例3：类型安全的单位系统

```rust
use std::marker::PhantomData;
use std::ops::{Add, Mul, Div};

// 单位维度
struct Meter;
struct Second;
struct Kilogram;

// 复合维度
struct Velocity;  // m/s
struct Acceleration;  // m/s²
struct Force;  // kg·m/s²

// 物理量
struct Quantity<T, U> {
    value: T,
    _unit: PhantomData<U>,
}

impl<T, U> Quantity<T, U> {
    fn new(value: T) -> Self {
        Quantity {
            value,
            _unit: PhantomData,
        }
    }

    fn value(&self) -> &T {
        &self.value
    }
}

// 相同单位可以相加
impl<T: Add<Output = T>, U> Add for Quantity<T, U> {
    type Output = Quantity<T, U>;
    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// 单位转换规则
impl<T: Div<Output = T>> Div<Quantity<T, Second>> for Quantity<T, Meter> {
    type Output = Quantity<T, Velocity>;
    fn div(self, rhs: Quantity<T, Second>) -> Self::Output {
        Quantity::new(self.value / rhs.value)
    }
}

impl<T: Mul<Output = T>> Mul<Quantity<T, Acceleration>> for Quantity<T, Kilogram> {
    type Output = Quantity<T, Force>;
    fn mul(self, rhs: Quantity<T, Acceleration>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

fn main() {
    let distance = Quantity::<f64, Meter>::new(100.0);
    let time = Quantity::<f64, Second>::new(10.0);
    let velocity = distance / time;  // Quantity<f64, Velocity>

    println!("Velocity: {} m/s", velocity.value());

    // ❌ 编译错误：单位不匹配
    // let invalid = distance + time;
}
```

---

## 9.7 类型级列表与异构集合

**类型级链表**:

```rust
trait HList {}

struct HNil;
impl HList for HNil {}

struct HCons<H, T: HList>(H, T);
impl<H, T: HList> HList for HCons<H, T> {}

// 类型安全的异构索引
trait Index<N> {
    type Output;
    fn get(&self) -> &Self::Output;
}

// 索引0：头元素
impl<H, T: HList> Index<Zero> for HCons<H, T> {
    type Output = H;
    fn get(&self) -> &H {
        &self.0
    }
}

// 索引N+1：递归到尾部
impl<H, T, N> Index<Succ<N>> for HCons<H, T>
where
    T: HList + Index<N>,
{
    type Output = T::Output;
    fn get(&self) -> &Self::Output {
        self.1.get()
    }
}

// 使用示例
fn main() {
    type MyList = HCons<i32, HCons<&'static str, HCons<f64, HNil>>>;
    let list: MyList = HCons(42, HCons("hello", HCons(3.14, HNil)));

    let x: &i32 = list.get::<Zero>();
    let y: &&'static str = list.get::<Succ<Zero>>();
    let z: &f64 = list.get::<Succ<Succ<Zero>>>();

    println!("{}, {}, {}", x, y, z);
}
```

---

## 10. 总结

**高级泛型模式对比**:

| 模式          | 用途      | 编译时 vs 运行时 |
| :--- | :--- | :--- || **类型状态**  | 状态机    | 编译时           |
| **类型见证**  | 属性证明  | 编译时           |
| **Newtype**   | 类型安全  | 编译时           |
| **Visitor**   | 多态操作  | 编译时           |
| **Extension** | 添加方法  | 编译时           |
| **Sealed**    | 封闭trait | 编译时           |
| **类型擦除**  | 异构集合  | 运行时           |

**核心原则**:

1. ✅ 编译时验证优于运行时
2. ✅ 类型安全优于便利
3. ✅ 零成本抽象
4. ✅ 明确的 API 契约

---

## 11. 参考资源

**学术论文**:

- "Type Classes as Objects and Implicits" - Odersky et al
- "Lightweight Higher-Kinded Polymorphism" - Yallop & White
- "Generic Programming with Adjunctions" - Hinze

**文章与教程**:

- [The Typestate Pattern in Rust](https://cliffle.com/blog/rust-typestate/)
- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [Advanced Rust Generics](https://blog.rust-lang.org/2022/10/28/gats-stabilization.html)

**开源项目**:

- [frunk](https://github.com/lloydmeta/frunk) - 函数式编程库
- [typenum](https://github.com/paholg/typenum) - 类型级数值
- [generic-array](https://github.com/fizyk20/generic-array) - 泛型数组

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
- [4.1 类型理论深度](./01_类型理论深度.md)
- [4.3 类型系统形式化](./03_类型系统形式化.md)

---

**最后更新**: 2025-12-11
**适用版本**: Rust 1.92.0+
**文档类型**: Tier 4 - 高级层

---

**🎉 完成高级泛型模式深度学习！** 🦀

_本文档涵盖了Rust高级泛型编程的所有核心模式，从类型状态到类型级编程，为构建类型安全和高性能的系统提供了完整的工具箱。_
