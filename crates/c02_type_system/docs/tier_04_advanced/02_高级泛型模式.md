# 4.2 Rust ç±»å‹ç³»ç»Ÿ - é«˜çº§æ³›å‹æ¨¡å¼

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: é«˜çº§æ³›å‹ç¼–ç¨‹æ¨¡å¼  
> **é€‚ç”¨å¯¹è±¡**: é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [4.2 Rust ç±»å‹ç³»ç»Ÿ - é«˜çº§æ³›å‹æ¨¡å¼](#42-rust-ç±»å‹ç³»ç»Ÿ---é«˜çº§æ³›å‹æ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. ç±»å‹çŠ¶æ€æ¨¡å¼](#1-ç±»å‹çŠ¶æ€æ¨¡å¼)
    - [1.1 åŸºç¡€ç±»å‹çŠ¶æ€](#11-åŸºç¡€ç±»å‹çŠ¶æ€)
  - [2. ç±»å‹è§è¯æ¨¡å¼](#2-ç±»å‹è§è¯æ¨¡å¼)
  - [3. Newtype æ¨¡å¼](#3-newtype-æ¨¡å¼)
  - [4. Visitor æ¨¡å¼](#4-visitor-æ¨¡å¼)
  - [5. Extension Traits](#5-extension-traits)
  - [6. Sealed Traits](#6-sealed-traits)
  - [7. ç±»å‹æ“¦é™¤](#7-ç±»å‹æ“¦é™¤)
  - [8. é«˜çº§ç»„åˆæ¨¡å¼](#8-é«˜çº§ç»„åˆæ¨¡å¼)
    - [8.1 HKTæ¨¡æ‹Ÿ](#81-hktæ¨¡æ‹Ÿ)
    - [8.2 ç±»å‹çº§ç¼–ç¨‹](#82-ç±»å‹çº§ç¼–ç¨‹)
    - [8.3 ä¾èµ–ç±»å‹æ¨¡æ‹Ÿ](#83-ä¾èµ–ç±»å‹æ¨¡æ‹Ÿ)
  - [9. æ€§èƒ½ä¼˜åŒ–æ¨¡å¼](#9-æ€§èƒ½ä¼˜åŒ–æ¨¡å¼)
    - [9.1 å•æ€åŒ–](#91-å•æ€åŒ–)
    - [9.2 å†…è”ä¼˜åŒ–](#92-å†…è”ä¼˜åŒ–)
    - [9.3 ç¼–è¯‘æ—¶è®¡ç®—](#93-ç¼–è¯‘æ—¶è®¡ç®—)
    - [9.4 SIMDä¸æ³›å‹ä¼˜åŒ–](#94-simdä¸æ³›å‹ä¼˜åŒ–)
    - [9.5 æ³›å‹ä¸å¼‚æ„ç¼–ç¨‹](#95-æ³›å‹ä¸å¼‚æ„ç¼–ç¨‹)
  - [9.6 GATé«˜çº§åº”ç”¨æ¡ˆä¾‹](#96-gaté«˜çº§åº”ç”¨æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šé›¶æ‹·è´å¼‚æ­¥Stream](#æ¡ˆä¾‹1é›¶æ‹·è´å¼‚æ­¥stream)
    - [æ¡ˆä¾‹2ï¼šç±»å‹å®‰å…¨çš„æ•°æ®åº“æŸ¥è¯¢æ„å»ºå™¨](#æ¡ˆä¾‹2ç±»å‹å®‰å…¨çš„æ•°æ®åº“æŸ¥è¯¢æ„å»ºå™¨)
    - [æ¡ˆä¾‹3ï¼šç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ](#æ¡ˆä¾‹3ç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ)
  - [9.7 ç±»å‹çº§åˆ—è¡¨ä¸å¼‚æ„é›†åˆ](#97-ç±»å‹çº§åˆ—è¡¨ä¸å¼‚æ„é›†åˆ)
  - [10. æ€»ç»“](#10-æ€»ç»“)
  - [11. å‚è€ƒèµ„æº](#11-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

é«˜çº§æ³›å‹æ¨¡å¼ç”¨äºï¼š

- ğŸ”’ ç¼–è¯‘æ—¶çŠ¶æ€æ£€æŸ¥
- ğŸ¯ ç±»å‹å®‰å…¨çš„ API
- ğŸ”„ çµæ´»çš„ä»£ç å¤ç”¨
- âš¡ é›¶æˆæœ¬æŠ½è±¡

---

## 1. ç±»å‹çŠ¶æ€æ¨¡å¼

### 1.1 åŸºç¡€ç±»å‹çŠ¶æ€

**è®¾è®¡åŸåˆ™**:

ç±»å‹çŠ¶æ€æ¨¡å¼(Typestate Pattern)å°†å¯¹è±¡çš„çŠ¶æ€ç¼–ç åˆ°ç±»å‹ç³»ç»Ÿä¸­ï¼Œä½¿å¾—éæ³•çŠ¶æ€è½¬æ¢åœ¨ç¼–è¯‘æ—¶è¢«æ‹’ç»ã€‚è¿™æ˜¯Rusté›¶æˆæœ¬æŠ½è±¡çš„å…¸å‹åº”ç”¨ã€‚

**æ ¸å¿ƒä¼˜åŠ¿**:

1. **ç¼–è¯‘æ—¶çŠ¶æ€éªŒè¯**ï¼šéæ³•çŠ¶æ€è½¬æ¢åœ¨ç¼–è¯‘æ—¶è¢«æ•è·
2. **é›¶è¿è¡Œæ—¶å¼€é”€**ï¼šå¹»å½±ç±»å‹åœ¨ç¼–è¯‘åè¢«æ“¦é™¤
3. **APIå¼ºåˆ¶çº¦æŸ**ï¼šç±»å‹ç³»ç»Ÿå¼ºåˆ¶æ­£ç¡®çš„ä½¿ç”¨é¡ºåº
4. **è‡ªæ–‡æ¡£åŒ–**ï¼šç±»å‹ç­¾åæ¸…æ™°è¡¨è¾¾çŠ¶æ€è½¬æ¢

**ä½¿ç”¨ç±»å‹ç¼–ç çŠ¶æ€**:

```rust
use std::marker::PhantomData;

// çŠ¶æ€æ ‡è®°
struct New;
struct Initialized;
struct Configured;
struct Running;

// æ„å»ºå™¨ï¼Œä½¿ç”¨å¹»å½±ç±»å‹è·Ÿè¸ªçŠ¶æ€
struct Builder<State> {
    config: Option<String>,
    _state: PhantomData<State>,
}

impl Builder<New> {
    fn new() -> Self {
        Builder {
            config: None,
            _state: PhantomData,
        }
    }
    
    fn initialize(self) -> Builder<Initialized> {
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Initialized> {
    fn configure(mut self, config: String) -> Builder<Configured> {
        self.config = Some(config);
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Configured> {
    fn build(self) -> Builder<Running> {
        println!("Building with config: {:?}", self.config);
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Running> {
    fn run(&self) {
        println!("Running...");
    }
}

fn main() {
    let builder = Builder::<New>::new()
        .initialize()
        .configure(String::from("config.toml"))
        .build();
    
    builder.run();
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šæ— æ³•è·³è¿‡çŠ¶æ€
    // let bad = Builder::<New>::new().build();
}
```

**å¤æ‚çŠ¶æ€æœº**:

```rust
use std::marker::PhantomData;

// TCP è¿æ¥çŠ¶æ€
struct Closed;
struct Listen;
struct SynRcvd;
struct Established;

struct TcpConnection<State> {
    socket: String,
    _state: PhantomData<State>,
}

impl TcpConnection<Closed> {
    fn new(socket: String) -> Self {
        TcpConnection {
            socket,
            _state: PhantomData,
        }
    }
    
    fn listen(self) -> TcpConnection<Listen> {
        println!("Listening on {}", self.socket);
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Listen> {
    fn accept(self) -> TcpConnection<SynRcvd> {
        println!("SYN received");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<SynRcvd> {
    fn acknowledge(self) -> TcpConnection<Established> {
        println!("Connection established");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Established> {
    fn send(&self, data: &str) {
        println!("Sending: {}", data);
    }
    
    fn close(self) -> TcpConnection<Closed> {
        println!("Connection closed");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

fn main() {
    let conn = TcpConnection::<Closed>::new(String::from("127.0.0.1:8080"))
        .listen()
        .accept()
        .acknowledge();
    
    conn.send("Hello");
    let _closed = conn.close();
}
```

---

## 2. ç±»å‹è§è¯æ¨¡å¼

**ä½¿ç”¨ç±»å‹è¯æ˜å±æ€§**:

```rust
use std::marker::PhantomData;

// ç©ºç±»å‹ä½œä¸ºè¯æ˜
struct NonEmpty;

struct Vec<T, Proof = ()> {
    inner: std::vec::Vec<T>,
    _proof: PhantomData<Proof>,
}

impl<T> Vec<T, ()> {
    fn new() -> Self {
        Vec {
            inner: std::vec::Vec::new(),
            _proof: PhantomData,
        }
    }
    
    fn push(mut self, item: T) -> Vec<T, NonEmpty> {
        self.inner.push(item);
        Vec {
            inner: self.inner,
            _proof: PhantomData,
        }
    }
}

impl<T> Vec<T, NonEmpty> {
    fn first(&self) -> &T {
        &self.inner[0]  // ä¿è¯éç©ºï¼Œä¸ä¼š panic
    }
    
    fn push(mut self, item: T) -> Self {
        self.inner.push(item);
        self
    }
}

fn main() {
    let empty = Vec::<i32>::new();
    // empty.first();  // âŒ ç¼–è¯‘é”™è¯¯ï¼šæ²¡æœ‰ first æ–¹æ³•
    
    let non_empty = empty.push(1);
    println!("First: {}", non_empty.first());  // âœ… å®‰å…¨
}
```

**æ’åºè§è¯**:

```rust
use std::marker::PhantomData;

struct Unsorted;
struct Sorted;

struct List<T, State = Unsorted> {
    items: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> List<T, Unsorted> {
    fn new(items: Vec<T>) -> Self {
        List {
            items,
            _state: PhantomData,
        }
    }
    
    fn sort(mut self) -> List<T, Sorted>
    where
        T: Ord,
    {
        self.items.sort();
        List {
            items: self.items,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> List<T, Sorted> {
    fn binary_search(&self, item: &T) -> Result<usize, usize> {
        self.items.binary_search(item)  // ä¿è¯å·²æ’åº
    }
}

fn main() {
    let unsorted = List::new(vec![3, 1, 4, 1, 5]);
    // unsorted.binary_search(&3);  // âŒ ç¼–è¯‘é”™è¯¯
    
    let sorted = unsorted.sort();
    println!("{:?}", sorted.binary_search(&3));  // âœ… å®‰å…¨
}
```

---

## 3. Newtype æ¨¡å¼

**ç±»å‹å®‰å…¨å°è£…**:

```rust
// å¼ºç±»å‹ ID
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) -> String {
    format!("User {}", id.0)
}

fn get_product(id: ProductId) -> String {
    format!("Product {}", id.0)
}

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);
    
    println!("{}", get_user(user_id));
    // println!("{}", get_user(product_id));  // âŒ ç¼–è¯‘é”™è¯¯
}
```

**è®¡é‡å•ä½**:

```rust
use std::ops::{Add, Mul};

#[derive(Debug, Copy, Clone)]
struct Meters(f64);

#[derive(Debug, Copy, Clone)]
struct Seconds(f64);

#[derive(Debug, Copy, Clone)]
struct MetersPerSecond(f64);

impl Add for Meters {
    type Output = Meters;
    
    fn add(self, rhs: Self) -> Self::Output {
        Meters(self.0 + rhs.0)
    }
}

impl Mul<Seconds> for MetersPerSecond {
    type Output = Meters;
    
    fn mul(self, rhs: Seconds) -> Self::Output {
        Meters(self.0 * rhs.0)
    }
}

fn main() {
    let distance1 = Meters(100.0);
    let distance2 = Meters(50.0);
    let total = distance1 + distance2;
    println!("Total distance: {:?}", total);
    
    let velocity = MetersPerSecond(10.0);
    let time = Seconds(5.0);
    let distance = velocity * time;
    println!("Distance traveled: {:?}", distance);
    
    // let bad = distance1 + time;  // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
}
```

---

## 4. Visitor æ¨¡å¼

**ç±»å‹å®‰å…¨çš„ Visitor**:

```rust
trait Visitor {
    type Output;
    
    fn visit_int(&mut self, value: i32) -> Self::Output;
    fn visit_string(&mut self, value: &str) -> Self::Output;
    fn visit_bool(&mut self, value: bool) -> Self::Output;
}

enum Value {
    Int(i32),
    String(String),
    Bool(bool),
}

impl Value {
    fn accept<V: Visitor>(&self, visitor: &mut V) -> V::Output {
        match self {
            Value::Int(i) => visitor.visit_int(*i),
            Value::String(s) => visitor.visit_string(s),
            Value::Bool(b) => visitor.visit_bool(*b),
        }
    }
}

// å…·ä½“ Visitorï¼šæ‰“å°
struct PrintVisitor;

impl Visitor for PrintVisitor {
    type Output = ();
    
    fn visit_int(&mut self, value: i32) {
        println!("Int: {}", value);
    }
    
    fn visit_string(&mut self, value: &str) {
        println!("String: {}", value);
    }
    
    fn visit_bool(&mut self, value: bool) {
        println!("Bool: {}", value);
    }
}

// å…·ä½“ Visitorï¼šåºåˆ—åŒ–
struct JsonVisitor;

impl Visitor for JsonVisitor {
    type Output = String;
    
    fn visit_int(&mut self, value: i32) -> String {
        value.to_string()
    }
    
    fn visit_string(&mut self, value: &str) -> String {
        format!("\"{}\"", value)
    }
    
    fn visit_bool(&mut self, value: bool) -> String {
        value.to_string()
    }
}

fn main() {
    let values = vec![
        Value::Int(42),
        Value::String(String::from("hello")),
        Value::Bool(true),
    ];
    
    let mut print_visitor = PrintVisitor;
    let mut json_visitor = JsonVisitor;
    
    for value in &values {
        value.accept(&mut print_visitor);
        let json = value.accept(&mut json_visitor);
        println!("JSON: {}", json);
    }
}
```

---

## 5. Extension Traits

**ä¸ºå¤–éƒ¨ç±»å‹æ·»åŠ æ–¹æ³•**:

```rust
trait IntExt {
    fn is_even(self) -> bool;
    fn is_odd(self) -> bool;
}

impl IntExt for i32 {
    fn is_even(self) -> bool {
        self % 2 == 0
    }
    
    fn is_odd(self) -> bool {
        !self.is_even()
    }
}

fn main() {
    println!("4 is even: {}", 4.is_even());
    println!("5 is odd: {}", 5.is_odd());
}
```

**æ³›å‹æ‰©å±•**:

```rust
trait IteratorExt: Iterator {
    fn collect_vec(self) -> Vec<Self::Item>
    where
        Self: Sized,
    {
        self.collect()
    }
    
    fn sum_default(self) -> Self::Item
    where
        Self: Sized,
        Self::Item: Default + std::ops::Add<Output = Self::Item>,
    {
        self.fold(Self::Item::default(), |a, b| a + b)
    }
}

impl<T: Iterator> IteratorExt for T {}

fn main() {
    let vec = (1..=5).collect_vec();
    println!("Vec: {:?}", vec);
    
    let sum = (1..=10).sum_default();
    println!("Sum: {}", sum);
}
```

---

## 6. Sealed Traits

**é˜²æ­¢å¤–éƒ¨å®ç°**:

```rust
mod sealed {
    pub trait Sealed {}
    
    impl Sealed for i32 {}
    impl Sealed for f64 {}
    impl Sealed for String {}
}

pub trait Number: sealed::Sealed {
    fn double(&self) -> Self;
}

impl Number for i32 {
    fn double(&self) -> Self {
        self * 2
    }
}

impl Number for f64 {
    fn double(&self) -> Self {
        self * 2.0
    }
}

// å¤–éƒ¨æ— æ³•å®ç° Number trait
// impl Number for MyType {}  // âŒ ç¼–è¯‘é”™è¯¯ï¼šæœªå®ç° Sealed

fn main() {
    println!("Double 21: {}", 21.double());
    println!("Double 3.14: {}", 3.14.double());
}
```

---

## 7. ç±»å‹æ“¦é™¤

**åŠ¨æ€åˆ†å‘çš„ç±»å‹æ“¦é™¤**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

// ç±»å‹æ“¦é™¤å®¹å™¨
struct DrawBox {
    inner: Box<dyn Draw>,
}

impl DrawBox {
    fn new<T: Draw + 'static>(value: T) -> Self {
        DrawBox {
            inner: Box::new(value),
        }
    }
    
    fn draw(&self) {
        self.inner.draw();
    }
}

fn main() {
    let shapes: Vec<DrawBox> = vec![
        DrawBox::new(Circle { radius: 5.0 }),
        DrawBox::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    for shape in &shapes {
        shape.draw();
    }
}
```

---

## 8. é«˜çº§ç»„åˆæ¨¡å¼

### 8.1 HKTæ¨¡æ‹Ÿ

**Higher-Kinded Typesï¼ˆHKTï¼‰æ¨¡æ‹Ÿ**:

è™½ç„¶Rustä¸ç›´æ¥æ”¯æŒHKTï¼Œä½†å¯ä»¥é€šè¿‡å…³è”ç±»å‹æ¨¡æ‹Ÿï¼š

```rust
// æ¨¡æ‹Ÿ Functor typeclass
trait Functor {
    type Wrapped<T>;
    
    fn map<A, B, F>(fa: Self::Wrapped<A>, f: F) -> Self::Wrapped<B>
    where
        F: FnOnce(A) -> B;
}

// Option çš„ Functor å®ç°
struct OptionFunctor;

impl Functor for OptionFunctor {
    type Wrapped<T> = Option<T>;
    
    fn map<A, B, F>(fa: Option<A>, f: F) -> Option<B>
    where
        F: FnOnce(A) -> B,
    {
        fa.map(f)
    }
}

// Vec çš„ Functor å®ç°
struct VecFunctor;

impl Functor for VecFunctor {
    type Wrapped<T> = Vec<T>;
    
    fn map<A, B, F>(fa: Vec<A>, f: F) -> Vec<B>
    where
        F: FnOnce(A) -> B + Clone,
    {
        fa.into_iter().map(f).collect()
    }
}

fn main() {
    let opt = Some(42);
    let result = OptionFunctor::map(opt, |x| x * 2);
    println!("{:?}", result);
    
    let vec = vec![1, 2, 3];
    let doubled = VecFunctor::map(vec, |x| x * 2);
    println!("{:?}", doubled);
}
```

**Monad æ¨¡æ‹Ÿ**:

```rust
trait Monad: Functor {
    fn pure<T>(value: T) -> Self::Wrapped<T>;
    
    fn bind<A, B, F>(ma: Self::Wrapped<A>, f: F) -> Self::Wrapped<B>
    where
        F: FnOnce(A) -> Self::Wrapped<B>;
}

impl Monad for OptionFunctor {
    fn pure<T>(value: T) -> Option<T> {
        Some(value)
    }
    
    fn bind<A, B, F>(ma: Option<A>, f: F) -> Option<B>
    where
        F: FnOnce(A) -> Option<B>,
    {
        ma.and_then(f)
    }
}

fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

fn main() {
    let result = OptionFunctor::bind(Some(10), |x| safe_divide(x, 2));
    println!("{:?}", result);  // Some(5)
    
    let error = OptionFunctor::bind(Some(10), |x| safe_divide(x, 0));
    println!("{:?}", error);  // None
}
```

### 8.2 ç±»å‹çº§ç¼–ç¨‹

**ç±»å‹çº§è‡ªç„¶æ•°**:

```rust
use std::marker::PhantomData;

// Peano æ•°
trait Nat {}

struct Zero;
impl Nat for Zero {}

struct Succ<N: Nat>(PhantomData<N>);
impl<N: Nat> Nat for Succ<N> {}

// ç±»å‹åˆ«å
type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;
type Four = Succ<Three>;
type Five = Succ<Four>;

// ç±»å‹çº§åŠ æ³•
trait Add<N: Nat> {
    type Output: Nat;
}

impl<N: Nat> Add<Zero> for N {
    type Output = N;
}

impl<N: Nat, M: Nat> Add<Succ<M>> for N
where
    N: Add<M>,
{
    type Output = Succ<<N as Add<M>>::Output>;
}

// ç±»å‹çº§æ¯”è¾ƒ
trait LessThan<N: Nat> {}

impl<N: Nat> LessThan<Succ<N>> for Zero {}

impl<N: Nat, M: Nat> LessThan<Succ<M>> for Succ<N>
where
    N: LessThan<M>,
{}

// ä½¿ç”¨ç¤ºä¾‹
fn assert_less_than<N: Nat, M: Nat>()
where
    N: LessThan<M>,
{}

fn main() {
    // ç¼–è¯‘æ—¶è¯æ˜ 1 < 3
    assert_less_than::<One, Three>();
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼š3 ä¸å°äº 1
    // assert_less_than::<Three, One>();
    
    // ç±»å‹çº§åŠ æ³•
    type Sum = <Two as Add<Three>>::Output;  // Sum = Five
}
```

**ç±»å‹çº§å¸ƒå°”è¿ç®—**:

```rust
trait Bool {}

struct True;
impl Bool for True {}

struct False;
impl Bool for False {}

// NOT
trait Not {
    type Output: Bool;
}

impl Not for True {
    type Output = False;
}

impl Not for False {
    type Output = True;
}

// AND
trait And<B: Bool> {
    type Output: Bool;
}

impl And<True> for True {
    type Output = True;
}

impl And<False> for True {
    type Output = False;
}

impl<B: Bool> And<B> for False {
    type Output = False;
}

// OR
trait Or<B: Bool> {
    type Output: Bool;
}

impl<B: Bool> Or<B> for True {
    type Output = True;
}

impl Or<True> for False {
    type Output = True;
}

impl Or<False> for False {
    type Output = False;
}

fn main() {
    // ç±»å‹çº§å¸ƒå°”è®¡ç®—
    type Result1 = <True as And<False>>::Output;  // False
    type Result2 = <True as Or<False>>::Output;   // True
    type Result3 = <False as Not>::Output;         // True
}
```

### 8.3 ä¾èµ–ç±»å‹æ¨¡æ‹Ÿ

**ç±»å‹çº§é•¿åº¦çš„Vector**:

```rust
use std::marker::PhantomData;

// è‡ªç„¶æ•°ç±»å‹
trait Nat {
    const VALUE: usize;
}

struct Zero;
impl Nat for Zero {
    const VALUE: usize = 0;
}

struct Succ<N: Nat>(PhantomData<N>);
impl<N: Nat> Nat for Succ<N> {
    const VALUE: usize = N::VALUE + 1;
}

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// å›ºå®šé•¿åº¦çš„Vector
struct Vec<T, N: Nat> {
    data: std::vec::Vec<T>,
    _len: PhantomData<N>,
}

impl<T, N: Nat> Vec<T, N> {
    fn len(&self) -> usize {
        N::VALUE
    }
}

impl<T> Vec<T, Zero> {
    fn new() -> Self {
        Vec {
            data: std::vec::Vec::new(),
            _len: PhantomData,
        }
    }
}

impl<T, N: Nat> Vec<T, N> {
    fn push(mut self, item: T) -> Vec<T, Succ<N>> {
        self.data.push(item);
        Vec {
            data: self.data,
            _len: PhantomData,
        }
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        if index < N::VALUE {
            self.data.get(index)
        } else {
            None
        }
    }
}

// ç±»å‹å®‰å…¨çš„ç´¢å¼•è®¿é—®
impl<T, N: Nat> Vec<T, Succ<N>> {
    fn first(&self) -> &T {
        &self.data[0]  // ä¿è¯éç©º
    }
}

fn main() {
    let v = Vec::<i32, Zero>::new()
        .push(1)
        .push(2)
        .push(3);
    
    println!("Length: {}", v.len());  // 3
    println!("First: {}", v.first());  // 1
    
    // ç©ºVectoræ²¡æœ‰firstæ–¹æ³•
    let empty = Vec::<i32, Zero>::new();
    // empty.first();  // âŒ ç¼–è¯‘é”™è¯¯
}
```

**ç±»å‹çº§çŸ©é˜µå°ºå¯¸**:

```rust
use std::ops::{Add, Mul};

struct Matrix<T, const M: usize, const N: usize> {
    data: [[T; N]; M],
}

impl<T: Default + Copy, const M: usize, const N: usize> Matrix<T, M, N> {
    fn new() -> Self {
        Matrix {
            data: [[T::default(); N]; M],
        }
    }
}

// çŸ©é˜µåŠ æ³•ï¼šç›¸åŒå°ºå¯¸
impl<T, const M: usize, const N: usize> Add for Matrix<T, M, N>
where
    T: Add<Output = T> + Copy + Default,
{
    type Output = Matrix<T, M, N>;
    
    fn add(self, other: Self) -> Self::Output {
        let mut result = Matrix::new();
        for i in 0..M {
            for j in 0..N {
                result.data[i][j] = self.data[i][j] + other.data[i][j];
            }
        }
        result
    }
}

// çŸ©é˜µä¹˜æ³•ï¼šç±»å‹çº§å°ºå¯¸æ£€æŸ¥
impl<T, const M: usize, const N: usize, const P: usize> Matrix<T, M, N>
where
    T: Mul<Output = T> + Add<Output = T> + Copy + Default,
{
    fn mul(&self, other: &Matrix<T, N, P>) -> Matrix<T, M, P> {
        let mut result = Matrix::new();
        for i in 0..M {
            for j in 0..P {
                let mut sum = T::default();
                for k in 0..N {
                    sum = sum + self.data[i][k] * other.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        result
    }
}

fn main() {
    let m1 = Matrix::<i32, 2, 3>::new();
    let m2 = Matrix::<i32, 3, 4>::new();
    let m3 = m1.mul(&m2);  // Matrix<i32, 2, 4>
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šå°ºå¯¸ä¸åŒ¹é…
    // let m4 = Matrix::<i32, 2, 5>::new();
    // let bad = m1.mul(&m4);
}
```

---

## 9. æ€§èƒ½ä¼˜åŒ–æ¨¡å¼

### 9.1 å•æ€åŒ–

**æ³›å‹çš„å•æ€åŒ–ï¼ˆMonomorphizationï¼‰**:

Rustç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨çš„ä»£ç ï¼š

```rust
// æ³›å‹å‡½æ•°
fn generic_add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    // ç¼–è¯‘å™¨ç”Ÿæˆä¸¤ä¸ªä¸åŒçš„å‡½æ•°
    let x = generic_add(1i32, 2i32);     // generic_add_i32
    let y = generic_add(1.0f64, 2.0f64); // generic_add_f64
}

// ç¼–è¯‘åç­‰ä»·äºï¼š
// fn generic_add_i32(a: i32, b: i32) -> i32 { a + b }
// fn generic_add_f64(a: f64, b: f64) -> f64 { a + b }
```

**é¿å…ä»£ç è†¨èƒ€**:

```rust
// âŒ ä¸å¥½ï¼šæ¯ä¸ªTéƒ½ä¼šç”Ÿæˆæ–°ä»£ç 
fn process<T: std::fmt::Display>(items: Vec<T>) {
    for item in items {
        println!("{}", item);
    }
}

// âœ… æ›´å¥½ï¼šä½¿ç”¨traitå¯¹è±¡å‡å°‘ä»£ç è†¨èƒ€
fn process_dyn(items: &[&dyn std::fmt::Display]) {
    for item in items {
        println!("{}", item);
    }
}
```

### 9.2 å†…è”ä¼˜åŒ–

**å¼ºåˆ¶å†…è”æ³›å‹å‡½æ•°**:

```rust
#[inline(always)]
fn fast_add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

#[inline]
fn map_and_sum<T, F>(data: &[T], f: F) -> T
where
    T: std::ops::Add<Output = T> + Copy + Default,
    F: Fn(T) -> T,
{
    data.iter()
        .copied()
        .map(f)
        .fold(T::default(), |acc, x| acc + x)
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let sum = map_and_sum(&data, |x| x * 2);
    println!("Sum: {}", sum);
}
```

### 9.3 ç¼–è¯‘æ—¶è®¡ç®—

**constæ³›å‹ä¸ç¼–è¯‘æ—¶è®¡ç®—**:

```rust
// ç¼–è¯‘æ—¶è®¡ç®—æ•°ç»„å¤§å°
const fn calculate_size<const N: usize>() -> usize {
    N * N
}

struct Grid<T, const N: usize> {
    data: [T; calculate_size::<N>()],
}

impl<T: Default + Copy, const N: usize> Grid<T, N> {
    fn new() -> Self {
        Grid {
            data: [T::default(); calculate_size::<N>()],
        }
    }
    
    fn get(&self, row: usize, col: usize) -> Option<&T> {
        if row < N && col < N {
            self.data.get(row * N + col)
        } else {
            None
        }
    }
}

fn main() {
    let grid = Grid::<i32, 3>::new();  // 3x3 grid, size = 9
    println!("Grid size: {}", grid.data.len());
}
```

**const trait boundsï¼ˆå®éªŒæ€§ï¼‰**:

```rust
#![feature(const_trait_impl)]

#[const_trait]
trait ConstAdd {
    fn const_add(self, other: Self) -> Self;
}

impl const ConstAdd for i32 {
    fn const_add(self, other: Self) -> Self {
        self + other
    }
}

const fn compute<T: ~const ConstAdd>(a: T, b: T) -> T {
    a.const_add(b)
}

const RESULT: i32 = compute(10, 20);  // ç¼–è¯‘æ—¶è®¡ç®—

fn main() {
    println!("Computed at compile time: {}", RESULT);
}
```

### 9.4 SIMDä¸æ³›å‹ä¼˜åŒ–

**ä½¿ç”¨æ³›å‹å®ç°SIMDæŠ½è±¡**:

```rust
use std::arch::x86_64::*;

// æ³›å‹SIMD trait
trait SimdOps {
    type Output;
    fn add(self, rhs: Self) -> Self::Output;
    fn mul(self, rhs: Self) -> Self::Output;
}

// f32æ ‡é‡å®ç°
impl SimdOps for f32 {
    type Output = f32;
    fn add(self, rhs: Self) -> Self {
        self + rhs
    }
    fn mul(self, rhs: Self) -> Self {
        self * rhs
    }
}

// f32 SIMDå®ç°ï¼ˆAVXï¼‰
#[cfg(target_arch = "x86_64")]
impl SimdOps for __m256 {
    type Output = __m256;
    unsafe fn add(self, rhs: Self) -> Self {
        _mm256_add_ps(self, rhs)
    }
    unsafe fn mul(self, rhs: Self) -> Self {
        _mm256_mul_ps(self, rhs)
    }
}

// é€šç”¨ç®—æ³•å¯ä»¥ç”¨äºæ ‡é‡å’ŒSIMD
fn dot_product<T: SimdOps + Copy>(a: &[T], b: &[T]) -> T::Output
where
    T::Output: Default + std::ops::AddAssign,
{
    let mut sum = T::Output::default();
    for (x, y) in a.iter().zip(b.iter()) {
        sum += (*x).mul(*y);
    }
    sum
}
```

### 9.5 æ³›å‹ä¸å¼‚æ„ç¼–ç¨‹

**ç¼–è¯‘æ—¶ä»£ç ç”Ÿæˆ**:

```rust
// ä½¿ç”¨æ³›å‹ç”Ÿæˆç‰¹åŒ–ä»£ç 
trait ComputeKernel {
    fn compute(&self, input: &[f32], output: &mut [f32]);
}

struct CpuKernel;
impl ComputeKernel for CpuKernel {
    fn compute(&self, input: &[f32], output: &mut [f32]) {
        for (i, o) in input.iter().zip(output.iter_mut()) {
            *o = i * 2.0;  // CPUæ ‡é‡å®ç°
        }
    }
}

#[cfg(target_arch = "x86_64")]
struct SimdKernel;
#[cfg(target_arch = "x86_64")]
impl ComputeKernel for SimdKernel {
    fn compute(&self, input: &[f32], output: &mut [f32]) {
        // SIMDå‘é‡åŒ–å®ç°
        // ...
    }
}

// ç¼–è¯‘æ—¶é€‰æ‹©æœ€ä¼˜å®ç°
fn select_kernel() -> Box<dyn ComputeKernel> {
    #[cfg(target_arch = "x86_64")]
    {
        if is_x86_feature_detected!("avx2") {
            Box::new(SimdKernel)
        } else {
            Box::new(CpuKernel)
        }
    }
    #[cfg(not(target_arch = "x86_64"))]
    {
        Box::new(CpuKernel)
    }
}
```

---

## 9.6 GATé«˜çº§åº”ç”¨æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šé›¶æ‹·è´å¼‚æ­¥Stream

```rust
// ä½¿ç”¨GATå®ç°é›¶æ‹·è´çš„å¼‚æ­¥æµ
trait AsyncStream {
    type Item<'a> where Self: 'a;
    type Future<'a>: std::future::Future<Output = Option<Self::Item<'a>>>
    where
        Self: 'a;
    
    fn next<'a>(&'a mut self) -> Self::Future<'a>;
}

// å®ç°ï¼šä»å†…å­˜æ˜ å°„æ–‡ä»¶è¯»å–
struct MmapStream {
    data: &'static [u8],
    pos: usize,
    chunk_size: usize,
}

impl AsyncStream for MmapStream {
    type Item<'a> = &'a [u8];
    type Future<'a> = impl std::future::Future<Output = Option<&'a [u8]>> + 'a
    where
        Self: 'a;
    
    fn next<'a>(&'a mut self) -> Self::Future<'a> {
        async move {
            if self.pos >= self.data.len() {
                return None;
            }
            
            let end = (self.pos + self.chunk_size).min(self.data.len());
            let chunk = &self.data[self.pos..end];
            self.pos = end;
            Some(chunk)
        }
    }
}
```

### æ¡ˆä¾‹2ï¼šç±»å‹å®‰å…¨çš„æ•°æ®åº“æŸ¥è¯¢æ„å»ºå™¨

```rust
use std::marker::PhantomData;

// æŸ¥è¯¢çŠ¶æ€
struct NoTable;
struct HasTable;
struct NoWhere;
struct HasWhere;

// æŸ¥è¯¢æ„å»ºå™¨
struct QueryBuilder<TableState, WhereState> {
    table: Option<String>,
    where_clause: Option<String>,
    _table_state: PhantomData<TableState>,
    _where_state: PhantomData<WhereState>,
}

impl QueryBuilder<NoTable, NoWhere> {
    fn new() -> Self {
        QueryBuilder {
            table: None,
            where_clause: None,
            _table_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<W> QueryBuilder<NoTable, W> {
    fn table(self, name: &str) -> QueryBuilder<HasTable, W> {
        QueryBuilder {
            table: Some(name.to_string()),
            where_clause: self.where_clause,
            _table_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<T> QueryBuilder<T, NoWhere> {
    fn where_clause(self, condition: &str) -> QueryBuilder<T, HasWhere> {
        QueryBuilder {
            table: self.table,
            where_clause: Some(condition.to_string()),
            _table_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl QueryBuilder<HasTable, HasWhere> {
    fn build(self) -> String {
        format!(
            "SELECT * FROM {} WHERE {}",
            self.table.unwrap(),
            self.where_clause.unwrap()
        )
    }
}

fn main() {
    let query = QueryBuilder::new()
        .table("users")
        .where_clause("age > 18")
        .build();
    
    println!("{}", query);
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘table
    // let invalid = QueryBuilder::new().where_clause("age > 18").build();
}
```

### æ¡ˆä¾‹3ï¼šç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ

```rust
use std::marker::PhantomData;
use std::ops::{Add, Mul, Div};

// å•ä½ç»´åº¦
struct Meter;
struct Second;
struct Kilogram;

// å¤åˆç»´åº¦
struct Velocity;  // m/s
struct Acceleration;  // m/sÂ²
struct Force;  // kgÂ·m/sÂ²

// ç‰©ç†é‡
struct Quantity<T, U> {
    value: T,
    _unit: PhantomData<U>,
}

impl<T, U> Quantity<T, U> {
    fn new(value: T) -> Self {
        Quantity {
            value,
            _unit: PhantomData,
        }
    }
    
    fn value(&self) -> &T {
        &self.value
    }
}

// ç›¸åŒå•ä½å¯ä»¥ç›¸åŠ 
impl<T: Add<Output = T>, U> Add for Quantity<T, U> {
    type Output = Quantity<T, U>;
    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// å•ä½è½¬æ¢è§„åˆ™
impl<T: Div<Output = T>> Div<Quantity<T, Second>> for Quantity<T, Meter> {
    type Output = Quantity<T, Velocity>;
    fn div(self, rhs: Quantity<T, Second>) -> Self::Output {
        Quantity::new(self.value / rhs.value)
    }
}

impl<T: Mul<Output = T>> Mul<Quantity<T, Acceleration>> for Quantity<T, Kilogram> {
    type Output = Quantity<T, Force>;
    fn mul(self, rhs: Quantity<T, Acceleration>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

fn main() {
    let distance = Quantity::<f64, Meter>::new(100.0);
    let time = Quantity::<f64, Second>::new(10.0);
    let velocity = distance / time;  // Quantity<f64, Velocity>
    
    println!("Velocity: {} m/s", velocity.value());
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šå•ä½ä¸åŒ¹é…
    // let invalid = distance + time;
}
```

---

## 9.7 ç±»å‹çº§åˆ—è¡¨ä¸å¼‚æ„é›†åˆ

**ç±»å‹çº§é“¾è¡¨**:

```rust
trait HList {}

struct HNil;
impl HList for HNil {}

struct HCons<H, T: HList>(H, T);
impl<H, T: HList> HList for HCons<H, T> {}

// ç±»å‹å®‰å…¨çš„å¼‚æ„ç´¢å¼•
trait Index<N> {
    type Output;
    fn get(&self) -> &Self::Output;
}

// ç´¢å¼•0ï¼šå¤´å…ƒç´ 
impl<H, T: HList> Index<Zero> for HCons<H, T> {
    type Output = H;
    fn get(&self) -> &H {
        &self.0
    }
}

// ç´¢å¼•N+1ï¼šé€’å½’åˆ°å°¾éƒ¨
impl<H, T, N> Index<Succ<N>> for HCons<H, T>
where
    T: HList + Index<N>,
{
    type Output = T::Output;
    fn get(&self) -> &Self::Output {
        self.1.get()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    type MyList = HCons<i32, HCons<&'static str, HCons<f64, HNil>>>;
    let list: MyList = HCons(42, HCons("hello", HCons(3.14, HNil)));
    
    let x: &i32 = list.get::<Zero>();
    let y: &&'static str = list.get::<Succ<Zero>>();
    let z: &f64 = list.get::<Succ<Succ<Zero>>>();
    
    println!("{}, {}, {}", x, y, z);
}
```

---

## 10. æ€»ç»“

**é«˜çº§æ³›å‹æ¨¡å¼å¯¹æ¯”**:

| æ¨¡å¼ | ç”¨é€” | ç¼–è¯‘æ—¶ vs è¿è¡Œæ—¶ |
|------|------|-----------------|
| **ç±»å‹çŠ¶æ€** | çŠ¶æ€æœº | ç¼–è¯‘æ—¶ |
| **ç±»å‹è§è¯** | å±æ€§è¯æ˜ | ç¼–è¯‘æ—¶ |
| **Newtype** | ç±»å‹å®‰å…¨ | ç¼–è¯‘æ—¶ |
| **Visitor** | å¤šæ€æ“ä½œ | ç¼–è¯‘æ—¶ |
| **Extension** | æ·»åŠ æ–¹æ³• | ç¼–è¯‘æ—¶ |
| **Sealed** | å°é—­trait | ç¼–è¯‘æ—¶ |
| **ç±»å‹æ“¦é™¤** | å¼‚æ„é›†åˆ | è¿è¡Œæ—¶ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… ç¼–è¯‘æ—¶éªŒè¯ä¼˜äºè¿è¡Œæ—¶
2. âœ… ç±»å‹å®‰å…¨ä¼˜äºä¾¿åˆ©
3. âœ… é›¶æˆæœ¬æŠ½è±¡
4. âœ… æ˜ç¡®çš„ API å¥‘çº¦

---

## 11. å‚è€ƒèµ„æº

**å­¦æœ¯è®ºæ–‡**:

- "Type Classes as Objects and Implicits" - Odersky et al
- "Lightweight Higher-Kinded Polymorphism" - Yallop & White
- "Generic Programming with Adjunctions" - Hinze

**æ–‡ç« ä¸æ•™ç¨‹**:

- [The Typestate Pattern in Rust](https://cliffle.com/blog/rust-typestate/)
- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [Advanced Rust Generics](https://blog.rust-lang.org/2022/10/28/gats-stabilization.html)

**å¼€æºé¡¹ç›®**:

- [frunk](https://github.com/lloydmeta/frunk) - å‡½æ•°å¼ç¼–ç¨‹åº“
- [typenum](https://github.com/paholg/typenum) - ç±»å‹çº§æ•°å€¼
- [generic-array](https://github.com/fizyk20/generic-array) - æ³›å‹æ•°ç»„

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)
- [4.1 ç±»å‹ç†è®ºæ·±åº¦](./01_ç±»å‹ç†è®ºæ·±åº¦.md)
- [4.3 ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–](./03_ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–.md)

---

**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚

---

**ğŸ‰ å®Œæˆé«˜çº§æ³›å‹æ¨¡å¼æ·±åº¦å­¦ä¹ ï¼** ğŸ¦€

*æœ¬æ–‡æ¡£æ¶µç›–äº†Rusté«˜çº§æ³›å‹ç¼–ç¨‹çš„æ‰€æœ‰æ ¸å¿ƒæ¨¡å¼ï¼Œä»ç±»å‹çŠ¶æ€åˆ°ç±»å‹çº§ç¼–ç¨‹ï¼Œä¸ºæ„å»ºç±»å‹å®‰å…¨å’Œé«˜æ€§èƒ½çš„ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„å·¥å…·ç®±ã€‚*
