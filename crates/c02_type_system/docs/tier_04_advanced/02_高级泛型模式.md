# 4.2 Rust 类型系统 - 高级泛型模式

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 高级泛型编程模式  
> **适用对象**: 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.2 Rust 类型系统 - 高级泛型模式](#42-rust-类型系统---高级泛型模式)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 类型状态模式](#1-类型状态模式)
  - [2. 类型见证模式](#2-类型见证模式)
  - [3. Newtype 模式](#3-newtype-模式)
  - [4. Visitor 模式](#4-visitor-模式)
  - [5. Extension Traits](#5-extension-traits)
  - [6. Sealed Traits](#6-sealed-traits)
  - [7. 类型擦除](#7-类型擦除)
  - [8. 总结](#8-总结)
  - [9. 参考资源](#9-参考资源)

---

## 🎯 概述

高级泛型模式用于：

- 🔒 编译时状态检查
- 🎯 类型安全的 API
- 🔄 灵活的代码复用
- ⚡ 零成本抽象

---

## 1. 类型状态模式

**使用类型编码状态**:

```rust
use std::marker::PhantomData;

// 状态标记
struct New;
struct Initialized;
struct Configured;
struct Running;

// 构建器，使用幻影类型跟踪状态
struct Builder<State> {
    config: Option<String>,
    _state: PhantomData<State>,
}

impl Builder<New> {
    fn new() -> Self {
        Builder {
            config: None,
            _state: PhantomData,
        }
    }
    
    fn initialize(self) -> Builder<Initialized> {
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Initialized> {
    fn configure(mut self, config: String) -> Builder<Configured> {
        self.config = Some(config);
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Configured> {
    fn build(self) -> Builder<Running> {
        println!("Building with config: {:?}", self.config);
        Builder {
            config: self.config,
            _state: PhantomData,
        }
    }
}

impl Builder<Running> {
    fn run(&self) {
        println!("Running...");
    }
}

fn main() {
    let builder = Builder::<New>::new()
        .initialize()
        .configure(String::from("config.toml"))
        .build();
    
    builder.run();
    
    // ❌ 编译错误：无法跳过状态
    // let bad = Builder::<New>::new().build();
}
```

**复杂状态机**:

```rust
use std::marker::PhantomData;

// TCP 连接状态
struct Closed;
struct Listen;
struct SynRcvd;
struct Established;

struct TcpConnection<State> {
    socket: String,
    _state: PhantomData<State>,
}

impl TcpConnection<Closed> {
    fn new(socket: String) -> Self {
        TcpConnection {
            socket,
            _state: PhantomData,
        }
    }
    
    fn listen(self) -> TcpConnection<Listen> {
        println!("Listening on {}", self.socket);
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Listen> {
    fn accept(self) -> TcpConnection<SynRcvd> {
        println!("SYN received");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<SynRcvd> {
    fn acknowledge(self) -> TcpConnection<Established> {
        println!("Connection established");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Established> {
    fn send(&self, data: &str) {
        println!("Sending: {}", data);
    }
    
    fn close(self) -> TcpConnection<Closed> {
        println!("Connection closed");
        TcpConnection {
            socket: self.socket,
            _state: PhantomData,
        }
    }
}

fn main() {
    let conn = TcpConnection::<Closed>::new(String::from("127.0.0.1:8080"))
        .listen()
        .accept()
        .acknowledge();
    
    conn.send("Hello");
    let _closed = conn.close();
}
```

---

## 2. 类型见证模式

**使用类型证明属性**:

```rust
use std::marker::PhantomData;

// 空类型作为证明
struct NonEmpty;

struct Vec<T, Proof = ()> {
    inner: std::vec::Vec<T>,
    _proof: PhantomData<Proof>,
}

impl<T> Vec<T, ()> {
    fn new() -> Self {
        Vec {
            inner: std::vec::Vec::new(),
            _proof: PhantomData,
        }
    }
    
    fn push(mut self, item: T) -> Vec<T, NonEmpty> {
        self.inner.push(item);
        Vec {
            inner: self.inner,
            _proof: PhantomData,
        }
    }
}

impl<T> Vec<T, NonEmpty> {
    fn first(&self) -> &T {
        &self.inner[0]  // 保证非空，不会 panic
    }
    
    fn push(mut self, item: T) -> Self {
        self.inner.push(item);
        self
    }
}

fn main() {
    let empty = Vec::<i32>::new();
    // empty.first();  // ❌ 编译错误：没有 first 方法
    
    let non_empty = empty.push(1);
    println!("First: {}", non_empty.first());  // ✅ 安全
}
```

**排序见证**:

```rust
use std::marker::PhantomData;

struct Unsorted;
struct Sorted;

struct List<T, State = Unsorted> {
    items: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> List<T, Unsorted> {
    fn new(items: Vec<T>) -> Self {
        List {
            items,
            _state: PhantomData,
        }
    }
    
    fn sort(mut self) -> List<T, Sorted>
    where
        T: Ord,
    {
        self.items.sort();
        List {
            items: self.items,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> List<T, Sorted> {
    fn binary_search(&self, item: &T) -> Result<usize, usize> {
        self.items.binary_search(item)  // 保证已排序
    }
}

fn main() {
    let unsorted = List::new(vec![3, 1, 4, 1, 5]);
    // unsorted.binary_search(&3);  // ❌ 编译错误
    
    let sorted = unsorted.sort();
    println!("{:?}", sorted.binary_search(&3));  // ✅ 安全
}
```

---

## 3. Newtype 模式

**类型安全封装**:

```rust
// 强类型 ID
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) -> String {
    format!("User {}", id.0)
}

fn get_product(id: ProductId) -> String {
    format!("Product {}", id.0)
}

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);
    
    println!("{}", get_user(user_id));
    // println!("{}", get_user(product_id));  // ❌ 编译错误
}
```

**计量单位**:

```rust
use std::ops::{Add, Mul};

#[derive(Debug, Copy, Clone)]
struct Meters(f64);

#[derive(Debug, Copy, Clone)]
struct Seconds(f64);

#[derive(Debug, Copy, Clone)]
struct MetersPerSecond(f64);

impl Add for Meters {
    type Output = Meters;
    
    fn add(self, rhs: Self) -> Self::Output {
        Meters(self.0 + rhs.0)
    }
}

impl Mul<Seconds> for MetersPerSecond {
    type Output = Meters;
    
    fn mul(self, rhs: Seconds) -> Self::Output {
        Meters(self.0 * rhs.0)
    }
}

fn main() {
    let distance1 = Meters(100.0);
    let distance2 = Meters(50.0);
    let total = distance1 + distance2;
    println!("Total distance: {:?}", total);
    
    let velocity = MetersPerSecond(10.0);
    let time = Seconds(5.0);
    let distance = velocity * time;
    println!("Distance traveled: {:?}", distance);
    
    // let bad = distance1 + time;  // ❌ 编译错误：类型不匹配
}
```

---

## 4. Visitor 模式

**类型安全的 Visitor**:

```rust
trait Visitor {
    type Output;
    
    fn visit_int(&mut self, value: i32) -> Self::Output;
    fn visit_string(&mut self, value: &str) -> Self::Output;
    fn visit_bool(&mut self, value: bool) -> Self::Output;
}

enum Value {
    Int(i32),
    String(String),
    Bool(bool),
}

impl Value {
    fn accept<V: Visitor>(&self, visitor: &mut V) -> V::Output {
        match self {
            Value::Int(i) => visitor.visit_int(*i),
            Value::String(s) => visitor.visit_string(s),
            Value::Bool(b) => visitor.visit_bool(*b),
        }
    }
}

// 具体 Visitor：打印
struct PrintVisitor;

impl Visitor for PrintVisitor {
    type Output = ();
    
    fn visit_int(&mut self, value: i32) {
        println!("Int: {}", value);
    }
    
    fn visit_string(&mut self, value: &str) {
        println!("String: {}", value);
    }
    
    fn visit_bool(&mut self, value: bool) {
        println!("Bool: {}", value);
    }
}

// 具体 Visitor：序列化
struct JsonVisitor;

impl Visitor for JsonVisitor {
    type Output = String;
    
    fn visit_int(&mut self, value: i32) -> String {
        value.to_string()
    }
    
    fn visit_string(&mut self, value: &str) -> String {
        format!("\"{}\"", value)
    }
    
    fn visit_bool(&mut self, value: bool) -> String {
        value.to_string()
    }
}

fn main() {
    let values = vec![
        Value::Int(42),
        Value::String(String::from("hello")),
        Value::Bool(true),
    ];
    
    let mut print_visitor = PrintVisitor;
    let mut json_visitor = JsonVisitor;
    
    for value in &values {
        value.accept(&mut print_visitor);
        let json = value.accept(&mut json_visitor);
        println!("JSON: {}", json);
    }
}
```

---

## 5. Extension Traits

**为外部类型添加方法**:

```rust
trait IntExt {
    fn is_even(self) -> bool;
    fn is_odd(self) -> bool;
}

impl IntExt for i32 {
    fn is_even(self) -> bool {
        self % 2 == 0
    }
    
    fn is_odd(self) -> bool {
        !self.is_even()
    }
}

fn main() {
    println!("4 is even: {}", 4.is_even());
    println!("5 is odd: {}", 5.is_odd());
}
```

**泛型扩展**:

```rust
trait IteratorExt: Iterator {
    fn collect_vec(self) -> Vec<Self::Item>
    where
        Self: Sized,
    {
        self.collect()
    }
    
    fn sum_default(self) -> Self::Item
    where
        Self: Sized,
        Self::Item: Default + std::ops::Add<Output = Self::Item>,
    {
        self.fold(Self::Item::default(), |a, b| a + b)
    }
}

impl<T: Iterator> IteratorExt for T {}

fn main() {
    let vec = (1..=5).collect_vec();
    println!("Vec: {:?}", vec);
    
    let sum = (1..=10).sum_default();
    println!("Sum: {}", sum);
}
```

---

## 6. Sealed Traits

**防止外部实现**:

```rust
mod sealed {
    pub trait Sealed {}
    
    impl Sealed for i32 {}
    impl Sealed for f64 {}
    impl Sealed for String {}
}

pub trait Number: sealed::Sealed {
    fn double(&self) -> Self;
}

impl Number for i32 {
    fn double(&self) -> Self {
        self * 2
    }
}

impl Number for f64 {
    fn double(&self) -> Self {
        self * 2.0
    }
}

// 外部无法实现 Number trait
// impl Number for MyType {}  // ❌ 编译错误：未实现 Sealed

fn main() {
    println!("Double 21: {}", 21.double());
    println!("Double 3.14: {}", 3.14.double());
}
```

---

## 7. 类型擦除

**动态分发的类型擦除**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

// 类型擦除容器
struct DrawBox {
    inner: Box<dyn Draw>,
}

impl DrawBox {
    fn new<T: Draw + 'static>(value: T) -> Self {
        DrawBox {
            inner: Box::new(value),
        }
    }
    
    fn draw(&self) {
        self.inner.draw();
    }
}

fn main() {
    let shapes: Vec<DrawBox> = vec![
        DrawBox::new(Circle { radius: 5.0 }),
        DrawBox::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    for shape in &shapes {
        shape.draw();
    }
}
```

---

## 8. 总结

**高级泛型模式对比**:

| 模式 | 用途 | 编译时 vs 运行时 |
|------|------|-----------------|
| **类型状态** | 状态机 | 编译时 |
| **类型见证** | 属性证明 | 编译时 |
| **Newtype** | 类型安全 | 编译时 |
| **Visitor** | 多态操作 | 编译时 |
| **Extension** | 添加方法 | 编译时 |
| **Sealed** | 封闭trait | 编译时 |
| **类型擦除** | 异构集合 | 运行时 |

**核心原则**:

1. ✅ 编译时验证优于运行时
2. ✅ 类型安全优于便利
3. ✅ 零成本抽象
4. ✅ 明确的 API 契约

---

## 9. 参考资源

**文章**:

- [The Typestate Pattern in Rust](https://cliffle.com/blog/rust-typestate/)
- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
- [4.1 类型理论深度](./01_类型理论深度.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🎉 完成高级泛型模式学习！** 🦀
