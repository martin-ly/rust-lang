# 4.1 Rust 类型系统 - 类型理论深度

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 类型理论深入探讨  
> **适用对象**: 高级开发者 + 研究者  
> **前置知识**: 完整的 Tier 1-3 文档，类型理论基础  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [4.1 Rust 类型系统 - 类型理论深度](#41-rust-类型系统---类型理论深度)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 类型理论基础](#1-类型理论基础)
    - [1.1 类型系统分类](#11-类型系统分类)
    - [1.2 Curry-Howard 同构](#12-curry-howard-同构)
    - [1.3 类型推导](#13-类型推导)
  - [2. Rust 的类型系统特性](#2-rust-的类型系统特性)
    - [2.1 仿射类型系统](#21-仿射类型系统)
    - [2.2 HM 类型推断](#22-hm-类型推断)
    - [2.3 类型安全保证](#23-类型安全保证)
  - [3. 高阶类型](#3-高阶类型)
    - [3.1 Higher-Kinded Types](#31-higher-kinded-types)
    - [3.2 GATs (泛型关联类型)](#32-gats-泛型关联类型)
    - [3.3 HRTB (高阶Trait边界)](#33-hrtb-高阶trait边界)
  - [4. 类型级编程](#4-类型级编程)
    - [4.1 类型级计算](#41-类型级计算)
    - [4.2 Phantom Types](#42-phantom-types)
    - [4.3 状态机类型编码](#43-状态机类型编码)
  - [5. 子类型和型变](#5-子类型和型变)
    - [5.1 子类型关系](#51-子类型关系)
    - [5.2 型变规则](#52-型变规则)
    - [5.3 生命周期的格理论](#53-生命周期的格理论)
  - [6. 线性类型和仿射类型](#6-线性类型和仿射类型)
    - [6.1 线性类型](#61-线性类型)
    - [6.2 仿射类型](#62-仿射类型)
    - [6.3 所有权和借用的类型理论](#63-所有权和借用的类型理论)
  - [7. 依赖类型模拟](#7-依赖类型模拟)
    - [7.1 Const Generics](#71-const-generics)
    - [7.2 类型级数值](#72-类型级数值)
    - [7.3 约束和验证](#73-约束和验证)
  - [8. 形式化验证](#8-形式化验证)
    - [8.1 类型正确性](#81-类型正确性)
    - [8.2 类型保全性](#82-类型保全性)
    - [8.3 进展性](#83-进展性)
  - [9. 总结](#9-总结)
  - [10. 参考资源](#10-参考资源)

---

## 🎯 概述

Rust 的类型系统基于**仿射类型系统** (Affine Type System) 和 **Hindley-Milner类型推断**，提供了：

| 特性 | 理论基础 | Rust 实现 |
|------|---------|----------|
| **线性性** | 线性逻辑 | 所有权 (默认 move) |
| **仿射性** | 仿射逻辑 | 借用 (允许不使用) |
| **多态性** | 参数多态 | 泛型 + Trait |
| **子类型** | 子类型关系 | 生命周期 + 型变 |

---

## 1. 类型理论基础

### 1.1 类型系统分类

**按强度分类**:

| 类型系统 | 特点 | 示例语言 |
|---------|------|---------|
| **强类型** | 严格类型检查 | Rust, Haskell, ML |
| **弱类型** | 宽松类型检查 | C, JavaScript |
| **静态类型** | 编译时检查 | Rust, Java, C++ |
| **动态类型** | 运行时检查 | Python, Ruby |

**Rust 的定位**：**强静态类型 + 仿射类型**

```rust
// 强类型：不允许隐式转换
fn main() {
    let x: i32 = 42;
    // let y: i64 = x;  // 编译错误
    let y: i64 = x as i64;  // 必须显式转换
    
    println!("{}", y);
}
```

### 1.2 Curry-Howard 同构

**命题即类型，证明即程序**:

| 逻辑 | 类型理论 | Rust |
|------|---------|------|
| 真 (⊤) | Unit 类型 | `()` |
| 假 (⊥) | Never 类型 | `!` |
| 合取 (A ∧ B) | 积类型 | `(A, B)`, `struct` |
| 析取 (A ∨ B) | 和类型 | `enum` |
| 蕴涵 (A → B) | 函数类型 | `fn(A) -> B` |

**示例**:

```rust
// 真：Unit 类型
fn truth() -> () {
    ()
}

// 假：Never 类型
fn falsehood() -> ! {
    panic!("No value!")
}

// 合取：积类型
fn conjunction<A, B>(a: A, b: B) -> (A, B) {
    (a, b)
}

// 析取：和类型
enum Either<A, B> {
    Left(A),
    Right(B),
}

// 蕴涵：函数类型
fn implication<A, B>(f: fn(A) -> B, a: A) -> B {
    f(a)
}

fn main() {
    let _unit = truth();
    let _pair = conjunction(1, "hello");
    let _either: Either<i32, String> = Either::Left(42);
}
```

### 1.3 类型推导

**Hindley-Milner 类型推断**:

```rust
// 编译器推断类型
fn main() {
    let x = 42;          // i32
    let y = vec![x];     // Vec<i32>
    let z = y.iter();    // std::slice::Iter<'_, i32>
    
    // 完整的类型推导
    let _: i32 = x;
    let _: Vec<i32> = y;
    let _: std::slice::Iter<'_, i32> = z;
}
```

---

## 2. Rust 的类型系统特性

### 2.1 仿射类型系统

**仿射性**：值最多使用一次（可以不使用）

```rust
fn main() {
    let x = String::from("hello");
    let y = x;  // x moved, 不能再使用
    
    // println!("{}", x);  // 编译错误：x 已被移动
    println!("{}", y);  // ✅
    
    // 允许不使用
    let _unused = String::from("not used");  // ✅
}
```

**对比线性类型**：值必须恰好使用一次

```rust
// Rust 不强制使用，所以是仿射而非线性
fn main() {
    let x = Box::new(42);
    // 不使用 x 也可以 ✅
} // x dropped
```

### 2.2 HM 类型推断

**Let-polymorphism**:

```rust
fn main() {
    // 泛型函数
    let id = |x| x;
    
    // 可以用于不同类型
    let _a: i32 = id(42);
    // let _b: String = id(String::from("hello"));  // ❌ 编译错误
    
    // Rust 不支持完全的 let-polymorphism
    // 需要明确泛型参数
}
```

**改进**:

```rust
fn id<T>(x: T) -> T {
    x
}

fn main() {
    let _a = id(42);
    let _b = id(String::from("hello"));  // ✅
}
```

### 2.3 类型安全保证

**类型健全性** (Type Soundness):

1. **保全性** (Preservation): 如果 `e: T` 且 `e → e'`，则 `e': T`
2. **进展性** (Progress): 如果 `e: T`，则 `e` 是值或可以进一步求值

```rust
// 类型保证：如果编译通过，运行时不会有类型错误
fn safe_division(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

fn main() {
    match safe_division(10, 2) {
        Some(result) => println!("Result: {}", result),
        None => println!("Division by zero"),
    }
}
```

---

## 3. 高阶类型

### 3.1 Higher-Kinded Types

**HKT**：类型的类型

```text
Kind 分类:
* : 普通类型 (i32, String)
* -> * : 类型构造器 (Vec, Option)
* -> * -> * : 二元类型构造器 (Result)
```

**Rust 的局限**:

```rust
// ❌ Rust 不直接支持 HKT
// trait Functor<F<_>> {
//     fn map<A, B>(self, f: fn(A) -> B) -> F<B>;
// }

// ✅ 使用 Associated Type 模拟
trait Functor {
    type Wrapped<T>;
    fn map<A, B>(self, f: fn(A) -> B) -> Self::Wrapped<B>;
}
```

### 3.2 GATs (泛型关联类型)

**Generic Associated Types**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct WindowsMut<'data, T> {
    data: &'data mut [T],
    size: usize,
    pos: usize,
}

impl<'data, T> LendingIterator for WindowsMut<'data, T> {
    type Item<'a> = &'a mut [T] where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        if self.pos + self.size <= self.data.len() {
            let window = &mut self.data[self.pos..self.pos + self.size];
            self.pos += 1;
            Some(window)
        } else {
            None
        }
    }
}

fn main() {
    let mut data = vec![1, 2, 3, 4, 5];
    let mut windows = WindowsMut {
        data: &mut data,
        size: 3,
        pos: 0,
    };
    
    while let Some(window) = windows.next() {
        println!("{:?}", window);
    }
}
```

### 3.3 HRTB (高阶Trait边界)

**Higher-Rank Trait Bounds**:

```rust
// for<'a> 表示对所有生命周期 'a
fn apply<F>(f: F)
where
    F: for<'a> Fn(&'a i32) -> &'a i32,
{
    let x = 42;
    let result = f(&x);
    println!("Result: {}", result);
}

fn main() {
    apply(|x| x);  // ✅ 适用于任意生命周期
}
```

---

## 4. 类型级编程

### 4.1 类型级计算

**Peano 数**:

```rust
use std::marker::PhantomData;

// 类型级自然数
struct Zero;
struct Succ<N>(PhantomData<N>);

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// 类型级加法
trait Add<N> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
    Succ<N::Output>: Sized,
{
    type Output = Succ<N::Output>;
}

// 使用
type Five = <Two as Add<Three>>::Output;

fn main() {
    // 类型系统证明 2 + 3 = 5
    let _: Five = Succ(PhantomData::<Succ<Succ<Succ<Succ<Zero>>>>>);
}
```

### 4.2 Phantom Types

**幻影类型用于编译时状态跟踪**:

```rust
use std::marker::PhantomData;

struct Open;
struct Closed;

struct File<State> {
    path: String,
    _state: PhantomData<State>,
}

impl File<Closed> {
    fn open(path: String) -> File<Open> {
        println!("Opening file: {}", path);
        File {
            path,
            _state: PhantomData,
        }
    }
}

impl File<Open> {
    fn write(&mut self, data: &str) {
        println!("Writing to {}: {}", self.path, data);
    }
    
    fn close(self) -> File<Closed> {
        println!("Closing file: {}", self.path);
        File {
            path: self.path,
            _state: PhantomData,
        }
    }
}

fn main() {
    let closed = File::<Closed> {
        path: String::from("test.txt"),
        _state: PhantomData,
    };
    
    let mut open = closed.open();
    open.write("Hello");
    let _closed_again = open.close();
    
    // open.write("World");  // ❌ 编译错误：已关闭
}
```

### 4.3 状态机类型编码

**类型安全的状态机**:

```rust
use std::marker::PhantomData;

// 状态
struct Idle;
struct Running;
struct Stopped;

// 状态机
struct Machine<State> {
    _state: PhantomData<State>,
}

impl Machine<Idle> {
    fn new() -> Self {
        Machine { _state: PhantomData }
    }
    
    fn start(self) -> Machine<Running> {
        println!("Starting...");
        Machine { _state: PhantomData }
    }
}

impl Machine<Running> {
    fn stop(self) -> Machine<Stopped> {
        println!("Stopping...");
        Machine { _state: PhantomData }
    }
    
    fn process(&self) {
        println!("Processing...");
    }
}

impl Machine<Stopped> {
    fn reset(self) -> Machine<Idle> {
        println!("Resetting...");
        Machine { _state: PhantomData }
    }
}

fn main() {
    let machine = Machine::<Idle>::new();
    let machine = machine.start();
    machine.process();
    let machine = machine.stop();
    let _machine = machine.reset();
    
    // machine.process();  // ❌ 编译错误：已停止
}
```

---

## 5. 子类型和型变

### 5.1 子类型关系

**生命周期子类型**:

```rust
// 'static <: 'a (对所有 'a)
fn main() {
    let static_str: &'static str = "hello";
    let _local: &str = static_str;  // ✅ 'static 是 'a 的子类型
}
```

### 5.2 型变规则

**型变的形式化定义**:

| Type Constructor | Variance in T |
|-----------------|---------------|
| `&'a T` | Covariant |
| `&'a mut T` | Invariant |
| `fn(T) -> U` | Contravariant in T, Covariant in U |
| `Cell<T>` | Invariant |

### 5.3 生命周期的格理论

**格 (Lattice)**:

```text
'static
   |
   |
  'a ⊓ 'b  (交)
  /   \
 'a    'b
  \   /
  'a ⊔ 'b  (并)
   |
'(empty)
```

---

## 6. 线性类型和仿射类型

### 6.1 线性类型

**线性逻辑**：资源必须恰好使用一次

```rust
// Rust 的线性性通过 ownership 实现
fn consume(x: String) {
    println!("{}", x);
    // x 被消耗
}

fn main() {
    let s = String::from("hello");
    consume(s);
    // consume(s);  // ❌ 编译错误：s 已被移动
}
```

### 6.2 仿射类型

**仿射逻辑**：资源最多使用一次（可以不使用）

```rust
fn main() {
    let x = Box::new(42);
    // 不使用 x 也可以 ✅
} // x dropped，体现仿射性
```

### 6.3 所有权和借用的类型理论

**所有权规则**:

1. 每个值有唯一所有者
2. 所有者离开作用域，值被释放

**借用规则**:

1. 多个不可变借用 **或** 一个可变借用
2. 借用必须有效

```rust
fn main() {
    let mut x = vec![1, 2, 3];
    
    // 不可变借用
    let r1 = &x;
    let r2 = &x;
    println!("{:?} {:?}", r1, r2);
    
    // 可变借用
    let r3 = &mut x;
    r3.push(4);
    println!("{:?}", r3);
}
```

---

## 7. 依赖类型模拟

### 7.1 Const Generics

**编译时常量**:

```rust
fn print_array<T: std::fmt::Display, const N: usize>(arr: &[T; N]) {
    for item in arr {
        print!("{} ", item);
    }
    println!();
}

fn main() {
    print_array(&[1, 2, 3]);
    print_array(&[1, 2, 3, 4, 5]);
}
```

### 7.2 类型级数值

**类型安全的矩阵**:

```rust
use std::ops::Add;

struct Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

impl<T: Add<Output = T> + Copy + Default, const ROWS: usize, const COLS: usize>
    Matrix<T, ROWS, COLS>
{
    fn new() -> Self {
        Matrix {
            data: [[T::default(); COLS]; ROWS],
        }
    }
}

// 类型安全的矩阵乘法
impl<T, const M: usize, const N: usize, const P: usize> Matrix<T, M, N>
where
    T: Add<Output = T> + std::ops::Mul<Output = T> + Copy + Default,
{
    fn mul(&self, rhs: &Matrix<T, N, P>) -> Matrix<T, M, P> {
        let mut result = Matrix::<T, M, P>::new();
        
        for i in 0..M {
            for j in 0..P {
                let mut sum = T::default();
                for k in 0..N {
                    sum = sum + self.data[i][k] * rhs.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        
        result
    }
}

fn main() {
    let m1 = Matrix::<i32, 2, 3>::new();
    let m2 = Matrix::<i32, 3, 4>::new();
    let _result = m1.mul(&m2);  // Matrix<i32, 2, 4>
    
    // let m3 = Matrix::<i32, 2, 5>::new();
    // let _bad = m1.mul(&m3);  // ❌ 编译错误：维度不匹配
}
```

### 7.3 约束和验证

**编译时验证**:

```rust
struct NonEmpty<T> {
    head: T,
    tail: Vec<T>,
}

impl<T> NonEmpty<T> {
    fn new(head: T) -> Self {
        NonEmpty {
            head,
            tail: Vec::new(),
        }
    }
    
    fn first(&self) -> &T {
        &self.head  // 保证非空
    }
}

fn main() {
    let ne = NonEmpty::new(1);
    println!("First: {}", ne.first());  // ✅ 不会 panic
}
```

---

## 8. 形式化验证

### 8.1 类型正确性

**类型判断**:

```text
Γ ⊢ e : T

Γ: 类型环境
e: 表达式
T: 类型
```

### 8.2 类型保全性

**Preservation Theorem**:

```text
如果 Γ ⊢ e : T 且 e → e'
则 Γ ⊢ e' : T
```

### 8.3 进展性

**Progress Theorem**:

```text
如果 ∅ ⊢ e : T
则 e 是值 或 存在 e' 使得 e → e'
```

**Rust 的类型安全**:

```rust
// 如果编译通过，运行时不会有类型错误
fn main() {
    let x: i32 = 42;
    let y: i32 = x + 10;
    println!("{}", y);  // 保证类型正确
}
```

---

## 9. 总结

**Rust 类型系统的理论基础**:

| 理论 | Rust 实现 |
|------|----------|
| **仿射类型** | 所有权系统 |
| **HM 推断** | 类型推导 |
| **子类型** | 生命周期 + 型变 |
| **GAT** | 关联类型泛型 |
| **HRTB** | 高阶 trait 边界 |

**核心原则**:

1. ✅ 类型安全 = 内存安全
2. ✅ 零成本抽象
3. ✅ 编译时保证
4. ✅ 可扩展性

---

## 10. 参考资源

**学术论文**:

- "RustBelt: Securing the Foundations of the Rust Programming Language" (POPL 2018)
- "Oxide: The Essence of Rust" (ECOOP 2019)
- "Stacked Borrows: An Aliasing Model for Rust" (POPL 2020)

**书籍**:

- Types and Programming Languages (TAPL) - Benjamin C. Pierce
- Advanced Topics in Types and Programming Languages - Pierce et al.

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [3.2 类型型变参考](../tier_03_references/02_类型型变参考.md)
- [Rust Reference - Type System](https://doc.rust-lang.org/reference/type-system.html)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 4 - 高级层

---

**🎓 完成类型理论深度学习！** 🦀
