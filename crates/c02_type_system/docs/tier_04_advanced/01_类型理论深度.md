# 4.1 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹ç†è®ºæ·±åº¦

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹ç†è®ºæ·±å…¥æ¢è®¨  
> **é€‚ç”¨å¯¹è±¡**: é«˜çº§å¼€å‘è€… + ç ”ç©¶è€…  
> **å‰ç½®çŸ¥è¯†**: å®Œæ•´çš„ Tier 1-3 æ–‡æ¡£ï¼Œç±»å‹ç†è®ºåŸºç¡€  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [4.1 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹ç†è®ºæ·±åº¦](#41-rust-ç±»å‹ç³»ç»Ÿ---ç±»å‹ç†è®ºæ·±åº¦)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. ç±»å‹ç†è®ºåŸºç¡€](#1-ç±»å‹ç†è®ºåŸºç¡€)
    - [1.1 ç±»å‹ç³»ç»Ÿåˆ†ç±»](#11-ç±»å‹ç³»ç»Ÿåˆ†ç±»)
    - [1.2 Curry-Howard åŒæ„](#12-curry-howard-åŒæ„)
    - [1.3 ç±»å‹æ¨å¯¼](#13-ç±»å‹æ¨å¯¼)
  - [2. Rust çš„ç±»å‹ç³»ç»Ÿç‰¹æ€§](#2-rust-çš„ç±»å‹ç³»ç»Ÿç‰¹æ€§)
    - [2.1 ä»¿å°„ç±»å‹ç³»ç»Ÿ](#21-ä»¿å°„ç±»å‹ç³»ç»Ÿ)
    - [2.2 HM ç±»å‹æ¨æ–­](#22-hm-ç±»å‹æ¨æ–­)
    - [2.3 ç±»å‹å®‰å…¨ä¿è¯](#23-ç±»å‹å®‰å…¨ä¿è¯)
  - [3. é«˜é˜¶ç±»å‹](#3-é«˜é˜¶ç±»å‹)
    - [3.1 Higher-Kinded Types](#31-higher-kinded-types)
    - [3.2 GATs (æ³›å‹å…³è”ç±»å‹)](#32-gats-æ³›å‹å…³è”ç±»å‹)
    - [3.3 HRTB (é«˜é˜¶Traitè¾¹ç•Œ)](#33-hrtb-é«˜é˜¶traitè¾¹ç•Œ)
  - [4. ç±»å‹çº§ç¼–ç¨‹](#4-ç±»å‹çº§ç¼–ç¨‹)
    - [4.1 ç±»å‹çº§è®¡ç®—](#41-ç±»å‹çº§è®¡ç®—)
    - [4.2 Phantom Types](#42-phantom-types)
    - [4.3 çŠ¶æ€æœºç±»å‹ç¼–ç ](#43-çŠ¶æ€æœºç±»å‹ç¼–ç )
  - [5. å­ç±»å‹å’Œå‹å˜](#5-å­ç±»å‹å’Œå‹å˜)
    - [5.1 å­ç±»å‹å…³ç³»](#51-å­ç±»å‹å…³ç³»)
    - [5.2 å‹å˜è§„åˆ™](#52-å‹å˜è§„åˆ™)
    - [5.3 ç”Ÿå‘½å‘¨æœŸçš„æ ¼ç†è®º](#53-ç”Ÿå‘½å‘¨æœŸçš„æ ¼ç†è®º)
  - [6. çº¿æ€§ç±»å‹å’Œä»¿å°„ç±»å‹](#6-çº¿æ€§ç±»å‹å’Œä»¿å°„ç±»å‹)
    - [6.1 çº¿æ€§ç±»å‹](#61-çº¿æ€§ç±»å‹)
    - [6.2 ä»¿å°„ç±»å‹](#62-ä»¿å°„ç±»å‹)
    - [6.3 æ‰€æœ‰æƒå’Œå€Ÿç”¨çš„ç±»å‹ç†è®º](#63-æ‰€æœ‰æƒå’Œå€Ÿç”¨çš„ç±»å‹ç†è®º)
  - [7. ä¾èµ–ç±»å‹æ¨¡æ‹Ÿ](#7-ä¾èµ–ç±»å‹æ¨¡æ‹Ÿ)
    - [7.1 Const Generics](#71-const-generics)
    - [7.2 ç±»å‹çº§æ•°å€¼](#72-ç±»å‹çº§æ•°å€¼)
    - [7.3 çº¦æŸå’ŒéªŒè¯](#73-çº¦æŸå’ŒéªŒè¯)
  - [8. å½¢å¼åŒ–éªŒè¯](#8-å½¢å¼åŒ–éªŒè¯)
    - [8.1 ç±»å‹æ­£ç¡®æ€§](#81-ç±»å‹æ­£ç¡®æ€§)
    - [8.2 ç±»å‹ä¿å…¨æ€§](#82-ç±»å‹ä¿å…¨æ€§)
    - [8.3 è¿›å±•æ€§](#83-è¿›å±•æ€§)
  - [9. æ€»ç»“](#9-æ€»ç»“)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust çš„ç±»å‹ç³»ç»ŸåŸºäº**ä»¿å°„ç±»å‹ç³»ç»Ÿ** (Affine Type System) å’Œ **Hindley-Milnerç±»å‹æ¨æ–­**ï¼Œæä¾›äº†ï¼š

| ç‰¹æ€§ | ç†è®ºåŸºç¡€ | Rust å®ç° |
|------|---------|----------|
| **çº¿æ€§æ€§** | çº¿æ€§é€»è¾‘ | æ‰€æœ‰æƒ (é»˜è®¤ move) |
| **ä»¿å°„æ€§** | ä»¿å°„é€»è¾‘ | å€Ÿç”¨ (å…è®¸ä¸ä½¿ç”¨) |
| **å¤šæ€æ€§** | å‚æ•°å¤šæ€ | æ³›å‹ + Trait |
| **å­ç±»å‹** | å­ç±»å‹å…³ç³» | ç”Ÿå‘½å‘¨æœŸ + å‹å˜ |

---

## 1. ç±»å‹ç†è®ºåŸºç¡€

### 1.1 ç±»å‹ç³»ç»Ÿåˆ†ç±»

**æŒ‰å¼ºåº¦åˆ†ç±»**:

| ç±»å‹ç³»ç»Ÿ | ç‰¹ç‚¹ | ç¤ºä¾‹è¯­è¨€ |
|---------|------|---------|
| **å¼ºç±»å‹** | ä¸¥æ ¼ç±»å‹æ£€æŸ¥ | Rust, Haskell, ML |
| **å¼±ç±»å‹** | å®½æ¾ç±»å‹æ£€æŸ¥ | C, JavaScript |
| **é™æ€ç±»å‹** | ç¼–è¯‘æ—¶æ£€æŸ¥ | Rust, Java, C++ |
| **åŠ¨æ€ç±»å‹** | è¿è¡Œæ—¶æ£€æŸ¥ | Python, Ruby |

**Rust çš„å®šä½**ï¼š**å¼ºé™æ€ç±»å‹ + ä»¿å°„ç±»å‹**

```rust
// å¼ºç±»å‹ï¼šä¸å…è®¸éšå¼è½¬æ¢
fn main() {
    let x: i32 = 42;
    // let y: i64 = x;  // ç¼–è¯‘é”™è¯¯
    let y: i64 = x as i64;  // å¿…é¡»æ˜¾å¼è½¬æ¢
    
    println!("{}", y);
}
```

### 1.2 Curry-Howard åŒæ„

**å‘½é¢˜å³ç±»å‹ï¼Œè¯æ˜å³ç¨‹åº**:

| é€»è¾‘ | ç±»å‹ç†è®º | Rust |
|------|---------|------|
| çœŸ (âŠ¤) | Unit ç±»å‹ | `()` |
| å‡ (âŠ¥) | Never ç±»å‹ | `!` |
| åˆå– (A âˆ§ B) | ç§¯ç±»å‹ | `(A, B)`, `struct` |
| æå– (A âˆ¨ B) | å’Œç±»å‹ | `enum` |
| è•´æ¶µ (A â†’ B) | å‡½æ•°ç±»å‹ | `fn(A) -> B` |

**ç¤ºä¾‹**:

```rust
// çœŸï¼šUnit ç±»å‹
fn truth() -> () {
    ()
}

// å‡ï¼šNever ç±»å‹
fn falsehood() -> ! {
    panic!("No value!")
}

// åˆå–ï¼šç§¯ç±»å‹
fn conjunction<A, B>(a: A, b: B) -> (A, B) {
    (a, b)
}

// æå–ï¼šå’Œç±»å‹
enum Either<A, B> {
    Left(A),
    Right(B),
}

// è•´æ¶µï¼šå‡½æ•°ç±»å‹
fn implication<A, B>(f: fn(A) -> B, a: A) -> B {
    f(a)
}

fn main() {
    let _unit = truth();
    let _pair = conjunction(1, "hello");
    let _either: Either<i32, String> = Either::Left(42);
}
```

### 1.3 ç±»å‹æ¨å¯¼

**Hindley-Milner ç±»å‹æ¨æ–­**:

```rust
// ç¼–è¯‘å™¨æ¨æ–­ç±»å‹
fn main() {
    let x = 42;          // i32
    let y = vec![x];     // Vec<i32>
    let z = y.iter();    // std::slice::Iter<'_, i32>
    
    // å®Œæ•´çš„ç±»å‹æ¨å¯¼
    let _: i32 = x;
    let _: Vec<i32> = y;
    let _: std::slice::Iter<'_, i32> = z;
}
```

---

## 2. Rust çš„ç±»å‹ç³»ç»Ÿç‰¹æ€§

### 2.1 ä»¿å°„ç±»å‹ç³»ç»Ÿ

**ä»¿å°„æ€§**ï¼šå€¼æœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼ˆå¯ä»¥ä¸ä½¿ç”¨ï¼‰

```rust
fn main() {
    let x = String::from("hello");
    let y = x;  // x moved, ä¸èƒ½å†ä½¿ç”¨
    
    // println!("{}", x);  // ç¼–è¯‘é”™è¯¯ï¼šx å·²è¢«ç§»åŠ¨
    println!("{}", y);  // âœ…
    
    // å…è®¸ä¸ä½¿ç”¨
    let _unused = String::from("not used");  // âœ…
}
```

**å¯¹æ¯”çº¿æ€§ç±»å‹**ï¼šå€¼å¿…é¡»æ°å¥½ä½¿ç”¨ä¸€æ¬¡

```rust
// Rust ä¸å¼ºåˆ¶ä½¿ç”¨ï¼Œæ‰€ä»¥æ˜¯ä»¿å°„è€Œéçº¿æ€§
fn main() {
    let x = Box::new(42);
    // ä¸ä½¿ç”¨ x ä¹Ÿå¯ä»¥ âœ…
} // x dropped
```

### 2.2 HM ç±»å‹æ¨æ–­

**Let-polymorphism**:

```rust
fn main() {
    // æ³›å‹å‡½æ•°
    let id = |x| x;
    
    // å¯ä»¥ç”¨äºä¸åŒç±»å‹
    let _a: i32 = id(42);
    // let _b: String = id(String::from("hello"));  // âŒ ç¼–è¯‘é”™è¯¯
    
    // Rust ä¸æ”¯æŒå®Œå…¨çš„ let-polymorphism
    // éœ€è¦æ˜ç¡®æ³›å‹å‚æ•°
}
```

**æ”¹è¿›**:

```rust
fn id<T>(x: T) -> T {
    x
}

fn main() {
    let _a = id(42);
    let _b = id(String::from("hello"));  // âœ…
}
```

### 2.3 ç±»å‹å®‰å…¨ä¿è¯

**ç±»å‹å¥å…¨æ€§** (Type Soundness):

1. **ä¿å…¨æ€§** (Preservation): å¦‚æœ `e: T` ä¸” `e â†’ e'`ï¼Œåˆ™ `e': T`
2. **è¿›å±•æ€§** (Progress): å¦‚æœ `e: T`ï¼Œåˆ™ `e` æ˜¯å€¼æˆ–å¯ä»¥è¿›ä¸€æ­¥æ±‚å€¼

```rust
// ç±»å‹ä¿è¯ï¼šå¦‚æœç¼–è¯‘é€šè¿‡ï¼Œè¿è¡Œæ—¶ä¸ä¼šæœ‰ç±»å‹é”™è¯¯
fn safe_division(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

fn main() {
    match safe_division(10, 2) {
        Some(result) => println!("Result: {}", result),
        None => println!("Division by zero"),
    }
}
```

---

## 3. é«˜é˜¶ç±»å‹

### 3.1 Higher-Kinded Types

**HKT**ï¼šç±»å‹çš„ç±»å‹

```text
Kind åˆ†ç±»:
* : æ™®é€šç±»å‹ (i32, String)
* -> * : ç±»å‹æ„é€ å™¨ (Vec, Option)
* -> * -> * : äºŒå…ƒç±»å‹æ„é€ å™¨ (Result)
```

**Rust çš„å±€é™**:

```rust
// âŒ Rust ä¸ç›´æ¥æ”¯æŒ HKT
// trait Functor<F<_>> {
//     fn map<A, B>(self, f: fn(A) -> B) -> F<B>;
// }

// âœ… ä½¿ç”¨ Associated Type æ¨¡æ‹Ÿ
trait Functor {
    type Wrapped<T>;
    fn map<A, B>(self, f: fn(A) -> B) -> Self::Wrapped<B>;
}
```

### 3.2 GATs (æ³›å‹å…³è”ç±»å‹)

**Generic Associated Types**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct WindowsMut<'data, T> {
    data: &'data mut [T],
    size: usize,
    pos: usize,
}

impl<'data, T> LendingIterator for WindowsMut<'data, T> {
    type Item<'a> = &'a mut [T] where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        if self.pos + self.size <= self.data.len() {
            let window = &mut self.data[self.pos..self.pos + self.size];
            self.pos += 1;
            Some(window)
        } else {
            None
        }
    }
}

fn main() {
    let mut data = vec![1, 2, 3, 4, 5];
    let mut windows = WindowsMut {
        data: &mut data,
        size: 3,
        pos: 0,
    };
    
    while let Some(window) = windows.next() {
        println!("{:?}", window);
    }
}
```

### 3.3 HRTB (é«˜é˜¶Traitè¾¹ç•Œ)

**Higher-Rank Trait Bounds**:

```rust
// for<'a> è¡¨ç¤ºå¯¹æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ 'a
fn apply<F>(f: F)
where
    F: for<'a> Fn(&'a i32) -> &'a i32,
{
    let x = 42;
    let result = f(&x);
    println!("Result: {}", result);
}

fn main() {
    apply(|x| x);  // âœ… é€‚ç”¨äºä»»æ„ç”Ÿå‘½å‘¨æœŸ
}
```

---

## 4. ç±»å‹çº§ç¼–ç¨‹

### 4.1 ç±»å‹çº§è®¡ç®—

**Peano æ•°**:

```rust
use std::marker::PhantomData;

// ç±»å‹çº§è‡ªç„¶æ•°
struct Zero;
struct Succ<N>(PhantomData<N>);

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// ç±»å‹çº§åŠ æ³•
trait Add<N> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
    Succ<N::Output>: Sized,
{
    type Output = Succ<N::Output>;
}

// ä½¿ç”¨
type Five = <Two as Add<Three>>::Output;

fn main() {
    // ç±»å‹ç³»ç»Ÿè¯æ˜ 2 + 3 = 5
    let _: Five = Succ(PhantomData::<Succ<Succ<Succ<Succ<Zero>>>>>);
}
```

### 4.2 Phantom Types

**å¹»å½±ç±»å‹ç”¨äºç¼–è¯‘æ—¶çŠ¶æ€è·Ÿè¸ª**:

```rust
use std::marker::PhantomData;

struct Open;
struct Closed;

struct File<State> {
    path: String,
    _state: PhantomData<State>,
}

impl File<Closed> {
    fn open(path: String) -> File<Open> {
        println!("Opening file: {}", path);
        File {
            path,
            _state: PhantomData,
        }
    }
}

impl File<Open> {
    fn write(&mut self, data: &str) {
        println!("Writing to {}: {}", self.path, data);
    }
    
    fn close(self) -> File<Closed> {
        println!("Closing file: {}", self.path);
        File {
            path: self.path,
            _state: PhantomData,
        }
    }
}

fn main() {
    let closed = File::<Closed> {
        path: String::from("test.txt"),
        _state: PhantomData,
    };
    
    let mut open = closed.open();
    open.write("Hello");
    let _closed_again = open.close();
    
    // open.write("World");  // âŒ ç¼–è¯‘é”™è¯¯ï¼šå·²å…³é—­
}
```

### 4.3 çŠ¶æ€æœºç±»å‹ç¼–ç 

**ç±»å‹å®‰å…¨çš„çŠ¶æ€æœº**:

```rust
use std::marker::PhantomData;

// çŠ¶æ€
struct Idle;
struct Running;
struct Stopped;

// çŠ¶æ€æœº
struct Machine<State> {
    _state: PhantomData<State>,
}

impl Machine<Idle> {
    fn new() -> Self {
        Machine { _state: PhantomData }
    }
    
    fn start(self) -> Machine<Running> {
        println!("Starting...");
        Machine { _state: PhantomData }
    }
}

impl Machine<Running> {
    fn stop(self) -> Machine<Stopped> {
        println!("Stopping...");
        Machine { _state: PhantomData }
    }
    
    fn process(&self) {
        println!("Processing...");
    }
}

impl Machine<Stopped> {
    fn reset(self) -> Machine<Idle> {
        println!("Resetting...");
        Machine { _state: PhantomData }
    }
}

fn main() {
    let machine = Machine::<Idle>::new();
    let machine = machine.start();
    machine.process();
    let machine = machine.stop();
    let _machine = machine.reset();
    
    // machine.process();  // âŒ ç¼–è¯‘é”™è¯¯ï¼šå·²åœæ­¢
}
```

---

## 5. å­ç±»å‹å’Œå‹å˜

### 5.1 å­ç±»å‹å…³ç³»

**ç”Ÿå‘½å‘¨æœŸå­ç±»å‹**:

```rust
// 'static <: 'a (å¯¹æ‰€æœ‰ 'a)
fn main() {
    let static_str: &'static str = "hello";
    let _local: &str = static_str;  // âœ… 'static æ˜¯ 'a çš„å­ç±»å‹
}
```

### 5.2 å‹å˜è§„åˆ™

**å‹å˜çš„å½¢å¼åŒ–å®šä¹‰**:

| Type Constructor | Variance in T |
|-----------------|---------------|
| `&'a T` | Covariant |
| `&'a mut T` | Invariant |
| `fn(T) -> U` | Contravariant in T, Covariant in U |
| `Cell<T>` | Invariant |

### 5.3 ç”Ÿå‘½å‘¨æœŸçš„æ ¼ç†è®º

**æ ¼ (Lattice)**:

```text
'static
   |
   |
  'a âŠ“ 'b  (äº¤)
  /   \
 'a    'b
  \   /
  'a âŠ” 'b  (å¹¶)
   |
'(empty)
```

---

## 6. çº¿æ€§ç±»å‹å’Œä»¿å°„ç±»å‹

### 6.1 çº¿æ€§ç±»å‹

**çº¿æ€§é€»è¾‘**ï¼šèµ„æºå¿…é¡»æ°å¥½ä½¿ç”¨ä¸€æ¬¡

```rust
// Rust çš„çº¿æ€§æ€§é€šè¿‡ ownership å®ç°
fn consume(x: String) {
    println!("{}", x);
    // x è¢«æ¶ˆè€—
}

fn main() {
    let s = String::from("hello");
    consume(s);
    // consume(s);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šs å·²è¢«ç§»åŠ¨
}
```

### 6.2 ä»¿å°„ç±»å‹

**ä»¿å°„é€»è¾‘**ï¼šèµ„æºæœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼ˆå¯ä»¥ä¸ä½¿ç”¨ï¼‰

```rust
fn main() {
    let x = Box::new(42);
    // ä¸ä½¿ç”¨ x ä¹Ÿå¯ä»¥ âœ…
} // x droppedï¼Œä½“ç°ä»¿å°„æ€§
```

### 6.3 æ‰€æœ‰æƒå’Œå€Ÿç”¨çš„ç±»å‹ç†è®º

**æ‰€æœ‰æƒè§„åˆ™**:

1. æ¯ä¸ªå€¼æœ‰å”¯ä¸€æ‰€æœ‰è€…
2. æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼Œå€¼è¢«é‡Šæ”¾

**å€Ÿç”¨è§„åˆ™**:

1. å¤šä¸ªä¸å¯å˜å€Ÿç”¨ **æˆ–** ä¸€ä¸ªå¯å˜å€Ÿç”¨
2. å€Ÿç”¨å¿…é¡»æœ‰æ•ˆ

```rust
fn main() {
    let mut x = vec![1, 2, 3];
    
    // ä¸å¯å˜å€Ÿç”¨
    let r1 = &x;
    let r2 = &x;
    println!("{:?} {:?}", r1, r2);
    
    // å¯å˜å€Ÿç”¨
    let r3 = &mut x;
    r3.push(4);
    println!("{:?}", r3);
}
```

---

## 7. ä¾èµ–ç±»å‹æ¨¡æ‹Ÿ

### 7.1 Const Generics

**ç¼–è¯‘æ—¶å¸¸é‡**:

```rust
fn print_array<T: std::fmt::Display, const N: usize>(arr: &[T; N]) {
    for item in arr {
        print!("{} ", item);
    }
    println!();
}

fn main() {
    print_array(&[1, 2, 3]);
    print_array(&[1, 2, 3, 4, 5]);
}
```

### 7.2 ç±»å‹çº§æ•°å€¼

**ç±»å‹å®‰å…¨çš„çŸ©é˜µ**:

```rust
use std::ops::Add;

struct Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

impl<T: Add<Output = T> + Copy + Default, const ROWS: usize, const COLS: usize>
    Matrix<T, ROWS, COLS>
{
    fn new() -> Self {
        Matrix {
            data: [[T::default(); COLS]; ROWS],
        }
    }
}

// ç±»å‹å®‰å…¨çš„çŸ©é˜µä¹˜æ³•
impl<T, const M: usize, const N: usize, const P: usize> Matrix<T, M, N>
where
    T: Add<Output = T> + std::ops::Mul<Output = T> + Copy + Default,
{
    fn mul(&self, rhs: &Matrix<T, N, P>) -> Matrix<T, M, P> {
        let mut result = Matrix::<T, M, P>::new();
        
        for i in 0..M {
            for j in 0..P {
                let mut sum = T::default();
                for k in 0..N {
                    sum = sum + self.data[i][k] * rhs.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        
        result
    }
}

fn main() {
    let m1 = Matrix::<i32, 2, 3>::new();
    let m2 = Matrix::<i32, 3, 4>::new();
    let _result = m1.mul(&m2);  // Matrix<i32, 2, 4>
    
    // let m3 = Matrix::<i32, 2, 5>::new();
    // let _bad = m1.mul(&m3);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šç»´åº¦ä¸åŒ¹é…
}
```

### 7.3 çº¦æŸå’ŒéªŒè¯

**ç¼–è¯‘æ—¶éªŒè¯**:

```rust
struct NonEmpty<T> {
    head: T,
    tail: Vec<T>,
}

impl<T> NonEmpty<T> {
    fn new(head: T) -> Self {
        NonEmpty {
            head,
            tail: Vec::new(),
        }
    }
    
    fn first(&self) -> &T {
        &self.head  // ä¿è¯éç©º
    }
}

fn main() {
    let ne = NonEmpty::new(1);
    println!("First: {}", ne.first());  // âœ… ä¸ä¼š panic
}
```

---

## 8. å½¢å¼åŒ–éªŒè¯

### 8.1 ç±»å‹æ­£ç¡®æ€§

**ç±»å‹åˆ¤æ–­**:

```text
Î“ âŠ¢ e : T

Î“: ç±»å‹ç¯å¢ƒ
e: è¡¨è¾¾å¼
T: ç±»å‹
```

### 8.2 ç±»å‹ä¿å…¨æ€§

**Preservation Theorem**:

```text
å¦‚æœ Î“ âŠ¢ e : T ä¸” e â†’ e'
åˆ™ Î“ âŠ¢ e' : T
```

### 8.3 è¿›å±•æ€§

**Progress Theorem**:

```text
å¦‚æœ âˆ… âŠ¢ e : T
åˆ™ e æ˜¯å€¼ æˆ– å­˜åœ¨ e' ä½¿å¾— e â†’ e'
```

**Rust çš„ç±»å‹å®‰å…¨**:

```rust
// å¦‚æœç¼–è¯‘é€šè¿‡ï¼Œè¿è¡Œæ—¶ä¸ä¼šæœ‰ç±»å‹é”™è¯¯
fn main() {
    let x: i32 = 42;
    let y: i32 = x + 10;
    println!("{}", y);  // ä¿è¯ç±»å‹æ­£ç¡®
}
```

---

## 9. æ€»ç»“

**Rust ç±»å‹ç³»ç»Ÿçš„ç†è®ºåŸºç¡€**:

| ç†è®º | Rust å®ç° |
|------|----------|
| **ä»¿å°„ç±»å‹** | æ‰€æœ‰æƒç³»ç»Ÿ |
| **HM æ¨æ–­** | ç±»å‹æ¨å¯¼ |
| **å­ç±»å‹** | ç”Ÿå‘½å‘¨æœŸ + å‹å˜ |
| **GAT** | å…³è”ç±»å‹æ³›å‹ |
| **HRTB** | é«˜é˜¶ trait è¾¹ç•Œ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… ç±»å‹å®‰å…¨ = å†…å­˜å®‰å…¨
2. âœ… é›¶æˆæœ¬æŠ½è±¡
3. âœ… ç¼–è¯‘æ—¶ä¿è¯
4. âœ… å¯æ‰©å±•æ€§

---

## 10. å‚è€ƒèµ„æº

**å­¦æœ¯è®ºæ–‡**:

- "RustBelt: Securing the Foundations of the Rust Programming Language" (POPL 2018)
- "Oxide: The Essence of Rust" (ECOOP 2019)
- "Stacked Borrows: An Aliasing Model for Rust" (POPL 2020)

**ä¹¦ç±**:

- Types and Programming Languages (TAPL) - Benjamin C. Pierce
- Advanced Topics in Types and Programming Languages - Pierce et al.

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [3.2 ç±»å‹å‹å˜å‚è€ƒ](../tier_03_references/02_ç±»å‹å‹å˜å‚è€ƒ.md)
- [Rust Reference - Type System](https://doc.rust-lang.org/reference/type-system.html)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚

---

**ğŸ“ å®Œæˆç±»å‹ç†è®ºæ·±åº¦å­¦ä¹ ï¼** ğŸ¦€
