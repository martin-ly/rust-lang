# ğŸ¯ C02: Type System - å®æˆ˜é¡¹ç›®é›†

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25  
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **é€‚ç”¨æ¨¡å—**: C02 ç±»å‹ç³»ç»Ÿ  
> **ç›®æ ‡**: é€šè¿‡å®æˆ˜é¡¹ç›®æ·±å…¥ç†è§£ Rust çš„ç±»å‹ç³»ç»Ÿå’Œ Trait

---

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

æœ¬æ–‡æ¡£æä¾›äº† **3ä¸ªç²¾å¿ƒè®¾è®¡çš„å®æˆ˜é¡¹ç›®**ï¼Œå¸®åŠ©ä½ æŒæ¡ Rust ç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€‚

| # | é¡¹ç›®åç§° | éš¾åº¦ | é¢„è®¡æ—¶é—´ | æ ¸å¿ƒæ¦‚å¿µ |
|---|----------|------|---------|---------|
| 1 | [ç®€å• Trait ç³»ç»Ÿ](#é¡¹ç›®1-ç®€å•-trait-ç³»ç»Ÿ) | â­ | 1-2å°æ—¶ | Trait å®šä¹‰ã€å®ç° |
| 2 | [å¤šæ€è®¾è®¡å®è·µ](#é¡¹ç›®2-å¤šæ€è®¾è®¡å®è·µ) | â­â­ | 2-3å°æ—¶ | Trait å¯¹è±¡ã€åŠ¨æ€åˆ†æ´¾ |
| 3 | [è‡ªå®šä¹‰ Iterator](#é¡¹ç›®3-è‡ªå®šä¹‰-iterator) | â­â­â­ | 3-4å°æ—¶ | å…³è”ç±»å‹ã€é«˜çº§ Trait |

---

## é¡¹ç›®1: ç®€å• Trait ç³»ç»Ÿ

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­  
**é¢„è®¡æ—¶é—´**: 1-2å°æ—¶  
**ç›®æ ‡**: ç†è§£ Trait å®šä¹‰å’Œå®ç°

### å­¦ä¹ ç›®æ ‡

1. å®šä¹‰è‡ªå·±çš„ Trait
2. ä¸ºä¸åŒç±»å‹å®ç° Trait
3. ä½¿ç”¨ Trait Bounds
4. ç†è§£æ´¾ç”Ÿ Trait

### åŠŸèƒ½éœ€æ±‚

#### åŸºç¡€åŠŸèƒ½

1. å®šä¹‰ `Drawable` trait
2. ä¸ºä¸åŒå›¾å½¢å®ç° trait
3. å®ç°æ³›å‹å‡½æ•°ä½¿ç”¨ trait
4. ä½¿ç”¨æ´¾ç”Ÿ trait

### é¡¹ç›®ç»“æ„

```text
shape_system/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â””â”€â”€ shapes.rs
```

### æ ¸å¿ƒä»£ç å®ç°

#### `shapes.rs`

```rust
use std::f64::consts::PI;

/// Drawable trait - æ‰€æœ‰å¯ç»˜åˆ¶å¯¹è±¡å¿…é¡»å®ç°
pub trait Drawable {
    /// ç»˜åˆ¶å¯¹è±¡
    fn draw(&self);
    
    /// è·å–æè¿°
    fn description(&self) -> String;
    
    /// é»˜è®¤å®ç°ï¼šæ˜¾ç¤ºå¯¹è±¡ä¿¡æ¯
    fn show_info(&self) {
        println!("=== {} ===", self.description());
        self.draw();
        println!();
    }
}

/// Shape trait - å‡ ä½•å½¢çŠ¶ç‰¹æ€§
pub trait Shape: Drawable {
    /// è®¡ç®—é¢ç§¯
    fn area(&self) -> f64;
    
    /// è®¡ç®—å‘¨é•¿
    fn perimeter(&self) -> f64;
}

/// åœ†å½¢
#[derive(Debug, Clone)]
pub struct Circle {
    pub radius: f64,
}

impl Circle {
    pub fn new(radius: f64) -> Self {
        Circle { radius }
    }
}

impl Drawable for Circle {
    fn draw(&self) {
        println!("  â­• åœ†å½¢");
        println!("     åŠå¾„: {:.2}", self.radius);
    }
    
    fn description(&self) -> String {
        format!("Circle(r={})", self.radius)
    }
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        PI * self.radius * self.radius
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * PI * self.radius
    }
}

/// çŸ©å½¢
#[derive(Debug, Clone)]
pub struct Rectangle {
    pub width: f64,
    pub height: f64,
}

impl Rectangle {
    pub fn new(width: f64, height: f64) -> Self {
        Rectangle { width, height }
    }
}

impl Drawable for Rectangle {
    fn draw(&self) {
        println!("  â–­ çŸ©å½¢");
        println!("     å®½åº¦: {:.2}, é«˜åº¦: {:.2}", self.width, self.height);
    }
    
    fn description(&self) -> String {
        format!("Rectangle({}x{})", self.width, self.height)
    }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * (self.width + self.height)
    }
}

/// ä¸‰è§’å½¢
#[derive(Debug, Clone)]
pub struct Triangle {
    pub base: f64,
    pub height: f64,
    pub side1: f64,
    pub side2: f64,
}

impl Triangle {
    pub fn new(base: f64, height: f64, side1: f64, side2: f64) -> Self {
        Triangle { base, height, side1, side2 }
    }
}

impl Drawable for Triangle {
    fn draw(&self) {
        println!("  ğŸ”º ä¸‰è§’å½¢");
        println!("     åº•è¾¹: {:.2}, é«˜: {:.2}", self.base, self.height);
    }
    
    fn description(&self) -> String {
        format!("Triangle(base={})", self.base)
    }
}

impl Shape for Triangle {
    fn area(&self) -> f64 {
        0.5 * self.base * self.height
    }
    
    fn perimeter(&self) -> f64 {
        self.base + self.side1 + self.side2
    }
}

/// ä½¿ç”¨ trait bound çš„æ³›å‹å‡½æ•°
pub fn print_shape_info<T: Shape>(shape: &T) {
    println!("ğŸ“ å½¢çŠ¶ä¿¡æ¯:");
    shape.draw();
    println!("   é¢ç§¯: {:.2}", shape.area());
    println!("   å‘¨é•¿: {:.2}", shape.perimeter());
}

/// æ¯”è¾ƒä¸¤ä¸ªå½¢çŠ¶çš„é¢ç§¯
pub fn compare_area<T: Shape, U: Shape>(shape1: &T, shape2: &U) {
    let area1 = shape1.area();
    let area2 = shape2.area();
    
    println!("ğŸ“Š é¢ç§¯æ¯”è¾ƒ:");
    println!("   {} é¢ç§¯: {:.2}", shape1.description(), area1);
    println!("   {} é¢ç§¯: {:.2}", shape2.description(), area2);
    
    if area1 > area2 {
        println!("   âœ… {} é¢ç§¯æ›´å¤§", shape1.description());
    } else if area1 < area2 {
        println!("   âœ… {} é¢ç§¯æ›´å¤§", shape2.description());
    } else {
        println!("   âœ… é¢ç§¯ç›¸ç­‰");
    }
}

/// æ‰¾å‡ºé¢ç§¯æœ€å¤§çš„å½¢çŠ¶
pub fn find_largest<T: Shape>(shapes: &[T]) -> Option<&T> {
    shapes.iter().max_by(|a, b| {
        a.area().partial_cmp(&b.area()).unwrap()
    })
}
```

#### `main.rs`

```rust
mod shapes;
use shapes::*;

fn main() {
    println!("===== ç®€å• Trait ç³»ç»Ÿæµ‹è¯• =====\n");
    
    // æµ‹è¯•1: åŸºç¡€ trait å®ç°
    {
        println!("æµ‹è¯•1: åŸºç¡€ Trait å®ç°\n");
        
        let circle = Circle::new(5.0);
        let rectangle = Rectangle::new(4.0, 6.0);
        let triangle = Triangle::new(3.0, 4.0, 3.0, 5.0);
        
        circle.show_info();
        rectangle.show_info();
        triangle.show_info();
    }
    
    // æµ‹è¯•2: Shape trait
    {
        println!("æµ‹è¯•2: Shape Trait\n");
        
        let circle = Circle::new(3.0);
        print_shape_info(&circle);
        
        println!();
        
        let rect = Rectangle::new(5.0, 10.0);
        print_shape_info(&rect);
        println!();
    }
    
    // æµ‹è¯•3: æ¯”è¾ƒå½¢çŠ¶
    {
        println!("æµ‹è¯•3: å½¢çŠ¶æ¯”è¾ƒ\n");
        
        let circle = Circle::new(5.0);
        let rectangle = Rectangle::new(7.0, 7.0);
        
        compare_area(&circle, &rectangle);
        println!();
    }
    
    // æµ‹è¯•4: æ‰¾å‡ºæœ€å¤§å½¢çŠ¶
    {
        println!("æµ‹è¯•4: æ‰¾å‡ºæœ€å¤§å½¢çŠ¶\n");
        
        let shapes = vec![
            Circle::new(3.0),
            Circle::new(5.0),
            Circle::new(2.0),
        ];
        
        if let Some(largest) = find_largest(&shapes) {
            println!("æœ€å¤§çš„åœ†å½¢:");
            largest.show_info();
            println!("é¢ç§¯: {:.2}", largest.area());
        }
    }
    
    // æµ‹è¯•5: æ³›å‹é›†åˆ
    {
        println!("\næµ‹è¯•5: æ³›å‹é›†åˆ\n");
        
        fn total_area<T: Shape>(shapes: &[T]) -> f64 {
            shapes.iter().map(|s| s.area()).sum()
        }
        
        let circles = vec![
            Circle::new(1.0),
            Circle::new(2.0),
            Circle::new(3.0),
        ];
        
        let rectangles = vec![
            Rectangle::new(2.0, 3.0),
            Rectangle::new(4.0, 5.0),
        ];
        
        println!("åœ†å½¢æ€»é¢ç§¯: {:.2}", total_area(&circles));
        println!("çŸ©å½¢æ€»é¢ç§¯: {:.2}", total_area(&rectangles));
    }
}
```

### æµ‹è¯•æ–¹å¼

```bash
cargo new shape_system
cd shape_system
# å¤åˆ¶ä¸Šè¿°ä»£ç 
cargo run
```

### é¢„æœŸè¾“å‡º

```text
===== ç®€å• Trait ç³»ç»Ÿæµ‹è¯• =====

æµ‹è¯•1: åŸºç¡€ Trait å®ç°

=== Circle(r=5) ===
  â­• åœ†å½¢
     åŠå¾„: 5.00

=== Rectangle(4x6) ===
  â–­ çŸ©å½¢
     å®½åº¦: 4.00, é«˜åº¦: 6.00

=== Triangle(base=3) ===
  ğŸ”º ä¸‰è§’å½¢
     åº•è¾¹: 3.00, é«˜: 4.00

æµ‹è¯•2: Shape Trait

ğŸ“ å½¢çŠ¶ä¿¡æ¯:
  â­• åœ†å½¢
     åŠå¾„: 3.00
   é¢ç§¯: 28.27
   å‘¨é•¿: 18.85

ğŸ“ å½¢çŠ¶ä¿¡æ¯:
  â–­ çŸ©å½¢
     å®½åº¦: 5.00, é«˜åº¦: 10.00
   é¢ç§¯: 50.00
   å‘¨é•¿: 30.00

æµ‹è¯•3: å½¢çŠ¶æ¯”è¾ƒ

ğŸ“Š é¢ç§¯æ¯”è¾ƒ:
   Circle(r=5) é¢ç§¯: 78.54
   Rectangle(7x7) é¢ç§¯: 49.00
   âœ… Circle(r=5) é¢ç§¯æ›´å¤§

æµ‹è¯•4: æ‰¾å‡ºæœ€å¤§å½¢çŠ¶

æœ€å¤§çš„åœ†å½¢:
=== Circle(r=5) ===
  â­• åœ†å½¢
     åŠå¾„: 5.00

é¢ç§¯: 78.54

æµ‹è¯•5: æ³›å‹é›†åˆ

åœ†å½¢æ€»é¢ç§¯: 43.98
çŸ©å½¢æ€»é¢ç§¯: 26.00
```

### å…³é”®çŸ¥è¯†ç‚¹

1. **Trait å®šä¹‰**: å®šä¹‰å…±äº«è¡Œä¸º
2. **Trait å®ç°**: ä¸ºç±»å‹å®ç° trait
3. **Supertrait**: `Shape: Drawable` ç»§æ‰¿å…³ç³»
4. **é»˜è®¤å®ç°**: `show_info` æœ‰é»˜è®¤è¡Œä¸º
5. **Trait Bounds**: æ³›å‹å‡½æ•°çº¦æŸ

### æ‰©å±•æ–¹å‘

1. æ·»åŠ æ›´å¤šå›¾å½¢ï¼ˆæ¤­åœ†ã€å¤šè¾¹å½¢ï¼‰
2. å®ç° `PartialEq` å’Œ `Ord` trait
3. æ·»åŠ é¢œè‰²å’Œæ ·å¼æ”¯æŒ
4. å®ç°å›¾å½¢å˜æ¢ï¼ˆæ—‹è½¬ã€ç¼©æ”¾ï¼‰

---

## é¡¹ç›®2: å¤šæ€è®¾è®¡å®è·µ

### ğŸ“– é¡¹ç›®è¯´æ˜2

**éš¾åº¦**: â­â­  
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶  
**ç›®æ ‡**: æŒæ¡ Trait å¯¹è±¡å’ŒåŠ¨æ€åˆ†æ´¾

### å­¦ä¹ ç›®æ ‡2

1. ä½¿ç”¨ `dyn Trait` å®ç°å¤šæ€
2. ç†è§£é™æ€åˆ†æ´¾ vs åŠ¨æ€åˆ†æ´¾
3. å®ç°æ’ä»¶ç³»ç»Ÿ
4. ä½¿ç”¨ `Box<dyn Trait>`

### åŠŸèƒ½éœ€æ±‚2

#### åŸºç¡€åŠŸèƒ½

1. å®šä¹‰æ’ä»¶ç³»ç»Ÿæ¥å£
2. å®ç°ä¸åŒç±»å‹çš„æ’ä»¶
3. åŠ¨æ€åŠ è½½å’Œæ‰§è¡Œæ’ä»¶
4. æ’ä»¶ç®¡ç†å™¨

### é¡¹ç›®ç»“æ„

```text
plugin_system/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â”œâ”€â”€ plugin.rs
    â””â”€â”€ plugins/
        â”œâ”€â”€ mod.rs
        â”œâ”€â”€ logger.rs
        â”œâ”€â”€ validator.rs
        â””â”€â”€ transformer.rs
```

### æ ¸å¿ƒä»£ç å®ç°

#### `plugin.rs`

```rust
use std::any::Any;

/// æ’ä»¶ trait - æ‰€æœ‰æ’ä»¶å¿…é¡»å®ç°
pub trait Plugin: Any {
    /// æ’ä»¶åç§°
    fn name(&self) -> &str;
    
    /// æ’ä»¶ç‰ˆæœ¬
    fn version(&self) -> &str {
        "1.0.0"
    }
    
    /// æ’ä»¶æè¿°
    fn description(&self) -> &str;
    
    /// åˆå§‹åŒ–æ’ä»¶
    fn initialize(&mut self) {
        println!("ğŸ”Œ æ’ä»¶ '{}' åˆå§‹åŒ–", self.name());
    }
    
    /// æ‰§è¡Œæ’ä»¶
    fn execute(&self, input: &str) -> Result<String, String>;
    
    /// å…³é—­æ’ä»¶
    fn shutdown(&mut self) {
        println!("ğŸ”Œ æ’ä»¶ '{}' å…³é—­", self.name());
    }
    
    /// è½¬æ¢ä¸º Anyï¼Œç”¨äºå‘ä¸‹è½¬å‹
    fn as_any(&self) -> &dyn Any;
}

/// æ’ä»¶ç®¡ç†å™¨
pub struct PluginManager {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginManager {
    pub fn new() -> Self {
        PluginManager {
            plugins: Vec::new(),
        }
    }
    
    /// æ³¨å†Œæ’ä»¶
    pub fn register(&mut self, mut plugin: Box<dyn Plugin>) {
        println!("ğŸ“¦ æ³¨å†Œæ’ä»¶: {} v{}", plugin.name(), plugin.version());
        plugin.initialize();
        self.plugins.push(plugin);
    }
    
    /// åˆ—å‡ºæ‰€æœ‰æ’ä»¶
    pub fn list_plugins(&self) {
        println!("\nğŸ“‹ å·²æ³¨å†Œçš„æ’ä»¶:");
        for (i, plugin) in self.plugins.iter().enumerate() {
            println!("  {}. {} v{} - {}", 
                     i + 1, 
                     plugin.name(), 
                     plugin.version(),
                     plugin.description());
        }
    }
    
    /// æ‰§è¡Œæ’ä»¶
    pub fn execute(&self, plugin_name: &str, input: &str) -> Result<String, String> {
        for plugin in &self.plugins {
            if plugin.name() == plugin_name {
                return plugin.execute(input);
            }
        }
        Err(format!("æ’ä»¶ '{}' æœªæ‰¾åˆ°", plugin_name))
    }
    
    /// æ‰§è¡Œæ‰€æœ‰æ’ä»¶ï¼ˆpipelineï¼‰
    pub fn execute_all(&self, input: &str) -> Result<String, String> {
        let mut result = input.to_string();
        
        for plugin in &self.plugins {
            println!("  ğŸ”„ æ‰§è¡Œ: {}", plugin.name());
            result = plugin.execute(&result)?;
        }
        
        Ok(result)
    }
    
    /// è·å–æ’ä»¶æ•°é‡
    pub fn count(&self) -> usize {
        self.plugins.len()
    }
}

impl Drop for PluginManager {
    fn drop(&mut self) {
        println!("\nğŸ”Œ å…³é—­æ‰€æœ‰æ’ä»¶...");
        for plugin in &mut self.plugins {
            plugin.shutdown();
        }
    }
}
```

#### `plugins/logger.rs`

```rust
use crate::plugin::Plugin;
use std::any::Any;

/// æ—¥å¿—æ’ä»¶ - è®°å½•æ‰€æœ‰è¾“å…¥
pub struct LoggerPlugin {
    name: String,
    log_count: usize,
}

impl LoggerPlugin {
    pub fn new() -> Self {
        LoggerPlugin {
            name: "Logger".to_string(),
            log_count: 0,
        }
    }
}

impl Plugin for LoggerPlugin {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn description(&self) -> &str {
        "è®°å½•æ‰€æœ‰è¾“å…¥å†…å®¹"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        println!("    ğŸ“ [Logger] è¾“å…¥: {}", input);
        Ok(input.to_string())
    }
    
    fn as_any(&self) -> &dyn Any {
        self
    }
}
```

#### `plugins/validator.rs`

```rust
use crate::plugin::Plugin;
use std::any::Any;

/// éªŒè¯æ’ä»¶ - éªŒè¯è¾“å…¥æœ‰æ•ˆæ€§
pub struct ValidatorPlugin {
    min_length: usize,
}

impl ValidatorPlugin {
    pub fn new(min_length: usize) -> Self {
        ValidatorPlugin { min_length }
    }
}

impl Plugin for ValidatorPlugin {
    fn name(&self) -> &str {
        "Validator"
    }
    
    fn description(&self) -> &str {
        "éªŒè¯è¾“å…¥é•¿åº¦"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        if input.len() < self.min_length {
            Err(format!("è¾“å…¥å¤ªçŸ­: {} < {}", input.len(), self.min_length))
        } else {
            println!("    âœ… [Validator] éªŒè¯é€šè¿‡ (é•¿åº¦: {})", input.len());
            Ok(input.to_string())
        }
    }
    
    fn as_any(&self) -> &dyn Any {
        self
    }
}
```

#### `plugins/transformer.rs`

```rust
use crate::plugin::Plugin;
use std::any::Any;

/// è½¬æ¢æ’ä»¶ - è½¬æ¢è¾“å…¥å†…å®¹
pub struct TransformerPlugin {
    mode: TransformMode,
}

pub enum TransformMode {
    Uppercase,
    Lowercase,
    Reverse,
}

impl TransformerPlugin {
    pub fn new(mode: TransformMode) -> Self {
        TransformerPlugin { mode }
    }
}

impl Plugin for TransformerPlugin {
    fn name(&self) -> &str {
        "Transformer"
    }
    
    fn description(&self) -> &str {
        "è½¬æ¢è¾“å…¥å†…å®¹"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        let result = match self.mode {
            TransformMode::Uppercase => input.to_uppercase(),
            TransformMode::Lowercase => input.to_lowercase(),
            TransformMode::Reverse => input.chars().rev().collect(),
        };
        
        println!("    ğŸ”„ [Transformer] è½¬æ¢å®Œæˆ");
        Ok(result)
    }
    
    fn as_any(&self) -> &dyn Any {
        self
    }
}
```

#### `plugins/mod.rs`

```rust
pub mod logger;
pub mod validator;
pub mod transformer;
```

#### `main.rs`

```rust
mod plugin;
mod plugins;

use plugin::*;
use plugins::logger::LoggerPlugin;
use plugins::validator::ValidatorPlugin;
use plugins::transformer::{TransformerPlugin, TransformMode};

fn main() {
    println!("===== å¤šæ€æ’ä»¶ç³»ç»Ÿæµ‹è¯• =====\n");
    
    // æµ‹è¯•1: åŸºç¡€æ’ä»¶æ³¨å†Œ
    {
        println!("æµ‹è¯•1: åŸºç¡€æ’ä»¶æ³¨å†Œ\n");
        
        let mut manager = PluginManager::new();
        
        manager.register(Box::new(LoggerPlugin::new()));
        manager.register(Box::new(ValidatorPlugin::new(3)));
        
        manager.list_plugins();
        println!();
    }
    
    // æµ‹è¯•2: æ‰§è¡Œå•ä¸ªæ’ä»¶
    {
        println!("\næµ‹è¯•2: æ‰§è¡Œå•ä¸ªæ’ä»¶\n");
        
        let mut manager = PluginManager::new();
        manager.register(Box::new(LoggerPlugin::new()));
        manager.register(Box::new(ValidatorPlugin::new(5)));
        
        let result = manager.execute("Logger", "Hello, Rust!");
        println!("ç»“æœ: {:?}\n", result);
        
        let result2 = manager.execute("Validator", "Hi");
        println!("ç»“æœ: {:?}", result2);
    }
    
    // æµ‹è¯•3: Pipeline æ‰§è¡Œ
    {
        println!("\n\næµ‹è¯•3: Pipeline æ‰§è¡Œ\n");
        
        let mut manager = PluginManager::new();
        manager.register(Box::new(LoggerPlugin::new()));
        manager.register(Box::new(ValidatorPlugin::new(3)));
        manager.register(Box::new(TransformerPlugin::new(TransformMode::Uppercase)));
        
        println!("æ‰§è¡Œ Pipeline:");
        match manager.execute_all("hello rust") {
            Ok(result) => println!("\nâœ… æœ€ç»ˆç»“æœ: {}", result),
            Err(e) => println!("\nâŒ é”™è¯¯: {}", e),
        }
    }
    
    // æµ‹è¯•4: ä¸åŒè½¬æ¢æ¨¡å¼
    {
        println!("\n\næµ‹è¯•4: ä¸åŒè½¬æ¢æ¨¡å¼\n");
        
        let transformers: Vec<Box<dyn Plugin>> = vec![
            Box::new(TransformerPlugin::new(TransformMode::Uppercase)),
            Box::new(TransformerPlugin::new(TransformMode::Lowercase)),
            Box::new(TransformerPlugin::new(TransformMode::Reverse)),
        ];
        
        let input = "Hello World";
        println!("åŸå§‹è¾“å…¥: {}\n", input);
        
        for transformer in transformers {
            match transformer.execute(input) {
                Ok(result) => println!("  ç»“æœ: {}", result),
                Err(e) => println!("  é”™è¯¯: {}", e),
            }
        }
    }
    
    // æµ‹è¯•5: é”™è¯¯å¤„ç†
    {
        println!("\n\næµ‹è¯•5: é”™è¯¯å¤„ç†\n");
        
        let mut manager = PluginManager::new();
        manager.register(Box::new(ValidatorPlugin::new(10)));
        
        let inputs = vec!["Hi", "Hello", "Hello, World!"];
        
        for input in inputs {
            println!("è¾“å…¥: '{}'", input);
            match manager.execute("Validator", input) {
                Ok(_) => println!("  âœ… é€šè¿‡\n"),
                Err(e) => println!("  âŒ {}\n", e),
            }
        }
    }
}
```

### æµ‹è¯•æ–¹å¼

```bash
cargo new plugin_system
cd plugin_system
# å¤åˆ¶ä¸Šè¿°ä»£ç 
cargo run
```

### é¢„æœŸè¾“å‡º

```text
===== å¤šæ€æ’ä»¶ç³»ç»Ÿæµ‹è¯• =====

æµ‹è¯•1: åŸºç¡€æ’ä»¶æ³¨å†Œ

ğŸ“¦ æ³¨å†Œæ’ä»¶: Logger v1.0.0
ğŸ”Œ æ’ä»¶ 'Logger' åˆå§‹åŒ–
ğŸ“¦ æ³¨å†Œæ’ä»¶: Validator v1.0.0
ğŸ”Œ æ’ä»¶ 'Validator' åˆå§‹åŒ–

ğŸ“‹ å·²æ³¨å†Œçš„æ’ä»¶:
  1. Logger v1.0.0 - è®°å½•æ‰€æœ‰è¾“å…¥å†…å®¹
  2. Validator v1.0.0 - éªŒè¯è¾“å…¥é•¿åº¦

ğŸ”Œ å…³é—­æ‰€æœ‰æ’ä»¶...
ğŸ”Œ æ’ä»¶ 'Logger' å…³é—­
ğŸ”Œ æ’ä»¶ 'Validator' å…³é—­


æµ‹è¯•2: æ‰§è¡Œå•ä¸ªæ’ä»¶

ğŸ“¦ æ³¨å†Œæ’ä»¶: Logger v1.0.0
ğŸ”Œ æ’ä»¶ 'Logger' åˆå§‹åŒ–
ğŸ“¦ æ³¨å†Œæ’ä»¶: Validator v1.0.0
ğŸ”Œ æ’ä»¶ 'Validator' åˆå§‹åŒ–
    ğŸ“ [Logger] è¾“å…¥: Hello, Rust!
ç»“æœ: Ok("Hello, Rust!")

ç»“æœ: Err("è¾“å…¥å¤ªçŸ­: 2 < 5")
...
```

### å…³é”®çŸ¥è¯†ç‚¹

1. **Trait å¯¹è±¡**: `Box<dyn Plugin>` å®ç°å¤šæ€
2. **åŠ¨æ€åˆ†æ´¾**: è¿è¡Œæ—¶ç¡®å®šè°ƒç”¨å“ªä¸ªæ–¹æ³•
3. **Any trait**: æ”¯æŒå‘ä¸‹è½¬å‹
4. **æ’ä»¶æ¶æ„**: å¯æ‰©å±•çš„ç³»ç»Ÿè®¾è®¡
5. **é”™è¯¯å¤„ç†**: ä½¿ç”¨ `Result` ä¼ æ’­é”™è¯¯

### æ‰©å±•æ–¹å‘

1. æ·»åŠ æ’ä»¶é…ç½®æ”¯æŒ
2. å®ç°æ’ä»¶ä¾èµ–ç®¡ç†
3. æ·»åŠ å¼‚æ­¥æ’ä»¶æ”¯æŒ
4. å®ç°æ’ä»¶çƒ­åŠ è½½

---

## é¡¹ç›®3: è‡ªå®šä¹‰ Iterator

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­â­â­  
**é¢„è®¡æ—¶é—´**: 3-4å°æ—¶  
**ç›®æ ‡**: æŒæ¡å…³è”ç±»å‹å’Œé«˜çº§ Trait

### å­¦ä¹ ç›®æ ‡

1. å®ç°è‡ªå®šä¹‰è¿­ä»£å™¨
2. ç†è§£å…³è”ç±»å‹
3. ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨
4. å®ç°é“¾å¼è°ƒç”¨

### åŠŸèƒ½éœ€æ±‚

#### åŸºç¡€åŠŸèƒ½

1. å®ç° `Iterator` trait
2. å®ç°èŒƒå›´è¿­ä»£å™¨
3. å®ç°æ­¥é•¿è¿­ä»£å™¨
4. å®ç°è¿‡æ»¤è¿­ä»£å™¨

#### è¿›é˜¶åŠŸèƒ½

1. å®ç°è¿­ä»£å™¨ç»„åˆ
2. å®ç°æ— é™è¿­ä»£å™¨
3. å®ç°è‡ªå®šä¹‰é€‚é…å™¨

### æ ¸å¿ƒä»£ç 

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œè¿™é‡Œæä¾›æ ¸å¿ƒç»“æ„å’Œç¤ºä¾‹ï¼š

```rust
/// è‡ªå®šä¹‰èŒƒå›´è¿­ä»£å™¨
struct RangeIterator {
    current: i32,
    end: i32,
    step: i32,
}

impl Iterator for RangeIterator {
    type Item = i32;  // å…³è”ç±»å‹
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.end {
            let value = self.current;
            self.current += self.step;
            Some(value)
        } else {
            None
        }
    }
}

/// æ–æ³¢é‚£å¥‘æ•°åˆ—è¿­ä»£å™¨
struct Fibonacci {
    current: u64,
    next: u64,
}

impl Iterator for Fibonacci {
    type Item = u64;
    
    fn next(&mut self) -> Option<Self::Item> {
        let new_next = self.current + self.next;
        self.current = self.next;
        self.next = new_next;
        Some(self.current)
    }
}
```

*å®Œæ•´ä»£ç è¯·å‚è€ƒé¡¹ç›®æ–‡ä»¶*

### å…³é”®çŸ¥è¯†ç‚¹

1. **å…³è”ç±»å‹**: `type Item = T`
2. **Iterator trait**: å®ç°è¿­ä»£è¡Œä¸º
3. **é“¾å¼è°ƒç”¨**: `.map().filter().collect()`
4. **æƒ°æ€§æ±‚å€¼**: è¿­ä»£å™¨åªåœ¨éœ€è¦æ—¶è®¡ç®—
5. **é€‚é…å™¨æ¨¡å¼**: ç»„åˆä¸åŒçš„è¿­ä»£å™¨

---

## ğŸ“ æ€»ç»“

### é¡¹ç›®è¿›é˜¶è·¯å¾„

1. **é¡¹ç›®1**: åŸºç¡€ Trait â†’ ç†è§£æ¥å£å®šä¹‰
2. **é¡¹ç›®2**: Trait å¯¹è±¡ â†’ ç†è§£å¤šæ€å’ŒåŠ¨æ€åˆ†æ´¾
3. **é¡¹ç›®3**: é«˜çº§ Trait â†’ ç†è§£å…³è”ç±»å‹å’Œæ³›å‹

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ | é¡¹ç›®1 | é¡¹ç›®2 | é¡¹ç›®3 |
|------|-------|-------|-------|
| Trait å®šä¹‰ | âœ…âœ…âœ… | âœ…âœ… | âœ…âœ… |
| Trait å®ç° | âœ…âœ…âœ… | âœ…âœ… | âœ…âœ…âœ… |
| Trait Bounds | âœ…âœ… | âœ… | âœ…âœ… |
| Trait å¯¹è±¡ | âŒ | âœ…âœ…âœ… | âœ… |
| å…³è”ç±»å‹ | âŒ | âŒ | âœ…âœ…âœ… |

### ç›¸å…³æ–‡æ¡£

- ğŸ“– [ä»£ç ç¤ºä¾‹é›†åˆ](./06_ä»£ç ç¤ºä¾‹é›†åˆ.md)
- ğŸ“– [Trait åŸºç¡€](../tier_01_foundations/05_TraitåŸºç¡€.md)
- ğŸ“– [æ³›å‹ä¸å¤šæ€](../tier_02_guides/02_æ³›å‹ä¸å¤šæ€.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25  
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ¯ é€šè¿‡å®æˆ˜é¡¹ç›®ï¼ŒæŒæ¡ Rust å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿï¼ğŸ¦€**
