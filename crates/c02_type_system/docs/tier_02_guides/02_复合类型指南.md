# 2.2 Rust ç±»å‹ç³»ç»Ÿ - å¤åˆç±»å‹æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚
> **æ–‡æ¡£å®šä½**: æ·±å…¥å­¦ä¹  Rust å¤åˆç±»å‹ç³»ç»Ÿ
> **é€‚ç”¨å¯¹è±¡**: åˆå­¦è€… â†’ ä¸­çº§å¼€å‘è€…
> **å‰ç½®çŸ¥è¯†**: [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md)
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 5-7 å°æ—¶
> **æœ€åæ›´æ–°**: 2025-12-11

---

## ğŸ“‹ ç›®å½•

- [2.2 Rust ç±»å‹ç³»ç»Ÿ - å¤åˆç±»å‹æŒ‡å—](#22-rust-ç±»å‹ç³»ç»Ÿ---å¤åˆç±»å‹æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [ğŸ“Š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. å¤åˆç±»å‹æ¦‚è¿°](#1-å¤åˆç±»å‹æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯å¤åˆç±»å‹](#11-ä»€ä¹ˆæ˜¯å¤åˆç±»å‹)
    - [1.2 Rust å¤åˆç±»å‹åˆ†ç±»](#12-rust-å¤åˆç±»å‹åˆ†ç±»)
  - [2. ç»“æ„ä½“ (Struct)](#2-ç»“æ„ä½“-struct)
    - [2.1 å‘½åå­—æ®µç»“æ„ä½“](#21-å‘½åå­—æ®µç»“æ„ä½“)
      - [å®šä¹‰å’Œåˆ›å»º](#å®šä¹‰å’Œåˆ›å»º)
      - [å¯å˜æ€§](#å¯å˜æ€§)
      - [å­—æ®µåˆå§‹åŒ–ç®€å†™](#å­—æ®µåˆå§‹åŒ–ç®€å†™)
      - [ç»“æ„ä½“æ›´æ–°è¯­æ³•](#ç»“æ„ä½“æ›´æ–°è¯­æ³•)
    - [2.2 å…ƒç»„ç»“æ„ä½“](#22-å…ƒç»„ç»“æ„ä½“)
      - [åŸºæœ¬ç”¨æ³•](#åŸºæœ¬ç”¨æ³•)
      - [å®é™…åº”ç”¨](#å®é™…åº”ç”¨)
    - [2.3 å•å…ƒç»“æ„ä½“](#23-å•å…ƒç»“æ„ä½“)
      - [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
      - [å®é™…åº”ç”¨2](#å®é™…åº”ç”¨2)
    - [2.4 ç»“æ„ä½“æ–¹æ³•](#24-ç»“æ„ä½“æ–¹æ³•)
      - [å®šä¹‰æ–¹æ³•](#å®šä¹‰æ–¹æ³•)
    - [2.5 å…³è”å‡½æ•°](#25-å…³è”å‡½æ•°)
      - [å®šä¹‰å…³è”å‡½æ•°](#å®šä¹‰å…³è”å‡½æ•°)
    - [2.6 ç»“æ„ä½“çš„å¯è§æ€§](#26-ç»“æ„ä½“çš„å¯è§æ€§)
  - [3. æšä¸¾ (Enum)](#3-æšä¸¾-enum)
    - [3.1 åŸºæœ¬æšä¸¾](#31-åŸºæœ¬æšä¸¾)
      - [å®šä¹‰å’Œä½¿ç”¨](#å®šä¹‰å’Œä½¿ç”¨)
    - [3.2 å¸¦æ•°æ®çš„æšä¸¾](#32-å¸¦æ•°æ®çš„æšä¸¾)
      - [åŸºæœ¬å½¢å¼](#åŸºæœ¬å½¢å¼)
      - [å¤æ‚æšä¸¾](#å¤æ‚æšä¸¾)
    - [3.3 Option æšä¸¾](#33-option-æšä¸¾)
      - [åŸºæœ¬æ¦‚å¿µ3](#åŸºæœ¬æ¦‚å¿µ3)
      - [Option å¸¸ç”¨æ–¹æ³•](#option-å¸¸ç”¨æ–¹æ³•)
    - [3.4 Result æšä¸¾](#34-result-æšä¸¾)
      - [åŸºæœ¬æ¦‚å¿µ34](#åŸºæœ¬æ¦‚å¿µ34)
      - [Result å¸¸ç”¨æ–¹æ³•](#result-å¸¸ç”¨æ–¹æ³•)
    - [3.5 æšä¸¾æ–¹æ³•](#35-æšä¸¾æ–¹æ³•)
    - [3.6 æšä¸¾çš„å†…å­˜è¡¨ç¤º](#36-æšä¸¾çš„å†…å­˜è¡¨ç¤º)
  - [4. æ¨¡å¼åŒ¹é…](#4-æ¨¡å¼åŒ¹é…)
    - [4.1 match è¡¨è¾¾å¼](#41-match-è¡¨è¾¾å¼)
      - [åŸºæœ¬ç”¨æ³•41](#åŸºæœ¬ç”¨æ³•41)
      - [ç»‘å®šå€¼](#ç»‘å®šå€¼)
      - [åŒ¹é… Option](#åŒ¹é…-option)
      - [é€šé…æ¨¡å¼](#é€šé…æ¨¡å¼)
    - [4.2 if let è¡¨è¾¾å¼](#42-if-let-è¡¨è¾¾å¼)
    - [4.3 while let å¾ªç¯](#43-while-let-å¾ªç¯)
    - [4.4 è§£æ„æ¨¡å¼](#44-è§£æ„æ¨¡å¼)
      - [è§£æ„ç»“æ„ä½“](#è§£æ„ç»“æ„ä½“)
      - [è§£æ„æšä¸¾](#è§£æ„æšä¸¾)
    - [4.5 åŒ¹é…å®ˆå«](#45-åŒ¹é…å®ˆå«)
    - [4.6 @ ç»‘å®š](#46--ç»‘å®š)
  - [5. ç»“æ„ä½“ä¸æšä¸¾çš„å¯¹æ¯”](#5-ç»“æ„ä½“ä¸æšä¸¾çš„å¯¹æ¯”)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: å›¾å½¢ç³»ç»Ÿ](#æ¡ˆä¾‹-1-å›¾å½¢ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 2: ç”¨æˆ·ç³»ç»Ÿ](#æ¡ˆä¾‹-2-ç”¨æˆ·ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 3: çŠ¶æ€æœº](#æ¡ˆä¾‹-3-çŠ¶æ€æœº)
    - [æ¡ˆä¾‹ 4: é”™è¯¯å¤„ç†](#æ¡ˆä¾‹-4-é”™è¯¯å¤„ç†)
  - [7. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#7-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [7.1 å¸¸è§é™·é˜±](#71-å¸¸è§é™·é˜±)
    - [7.2 æœ€ä½³å®è·µ](#72-æœ€ä½³å®è·µ)
  - [8. æ€§èƒ½è€ƒè™‘](#8-æ€§èƒ½è€ƒè™‘)
    - [8.1 å†…å­˜å¸ƒå±€](#81-å†…å­˜å¸ƒå±€)
    - [8.2 æ€§èƒ½ä¼˜åŒ–](#82-æ€§èƒ½ä¼˜åŒ–)
    - [8.4 ç»¼åˆå®æˆ˜æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½é…ç½®ç®¡ç†ç³»ç»Ÿ](#84-ç»¼åˆå®æˆ˜æ¡ˆä¾‹é«˜æ€§èƒ½é…ç½®ç®¡ç†ç³»ç»Ÿ)
  - [9. æ€»ç»“](#9-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
  - [å¤åˆç±»å‹é«˜çº§ä»£ç ç¤ºä¾‹è¡¥å……](#å¤åˆç±»å‹é«˜çº§ä»£ç ç¤ºä¾‹è¡¥å……)
  - [ğŸš€ é«˜çº§å®æˆ˜æ¡ˆä¾‹](#-é«˜çº§å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 5: JSONè§£æå™¨å®ç°](#æ¡ˆä¾‹-5-jsonè§£æå™¨å®ç°)
    - [æ¡ˆä¾‹ 6: çŠ¶æ€æœºï¼ˆæ¸¸æˆè§’è‰²ï¼‰](#æ¡ˆä¾‹-6-çŠ¶æ€æœºæ¸¸æˆè§’è‰²)
    - [æ¡ˆä¾‹ 7: ç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ](#æ¡ˆä¾‹-7-ç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 8: æ„å»ºå™¨æ¨¡å¼ï¼ˆé«˜çº§ï¼‰](#æ¡ˆä¾‹-8-æ„å»ºå™¨æ¨¡å¼é«˜çº§)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–è¿›é˜¶](#-æ€§èƒ½ä¼˜åŒ–è¿›é˜¶)
    - [å†…å­˜å¸ƒå±€ä¼˜åŒ–å®ä¾‹](#å†…å­˜å¸ƒå±€ä¼˜åŒ–å®ä¾‹)
    - [æšä¸¾åˆ¤åˆ«å¼ä¼˜åŒ–](#æšä¸¾åˆ¤åˆ«å¼ä¼˜åŒ–)
  - [ğŸ”¥ é«˜çº§æ¨¡å¼åŒ¹é…æŠ€å·§](#-é«˜çº§æ¨¡å¼åŒ¹é…æŠ€å·§)
    - [åŒ¹é…å¤šä¸ªæ¨¡å¼](#åŒ¹é…å¤šä¸ªæ¨¡å¼)
    - [èŒƒå›´æ¨¡å¼](#èŒƒå›´æ¨¡å¼)
    - [åµŒå¥—åŒ¹é…ä¸è§£æ„](#åµŒå¥—åŒ¹é…ä¸è§£æ„)
  - [ğŸ¯ å®æˆ˜ç»ƒä¹ é¢˜](#-å®æˆ˜ç»ƒä¹ é¢˜)
    - [ç»ƒä¹  1: å®ç°å‘½ä»¤è¡Œå‚æ•°è§£æå™¨](#ç»ƒä¹ -1-å®ç°å‘½ä»¤è¡Œå‚æ•°è§£æå™¨)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… **æŒæ¡** ç»“æ„ä½“çš„ä¸‰ç§å½¢å¼ï¼ˆå‘½åå­—æ®µã€å…ƒç»„ã€å•å…ƒï¼‰
- âœ… **ç†è§£** æšä¸¾å’Œæ¨¡å¼åŒ¹é…
- âœ… **æŒæ¡** ç»“æ„ä½“å’Œæšä¸¾çš„æ–¹æ³•å®šä¹‰
- âœ… **åº”ç”¨** Option å’Œ Result è¿›è¡Œé”™è¯¯å¤„ç†
- âœ… **ç†è§£** å¤åˆç±»å‹çš„å†…å­˜å¸ƒå±€
- âœ… **è®¾è®¡** åˆç†çš„æ•°æ®ç»“æ„
- âœ… **ç¼–å†™** å¥å£®çš„ Rust ç¨‹åº

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å¤åˆç±»å‹æŒ‡å— (Compound Types Guide)**:

- **å®šä¹‰**: æ·±å…¥å­¦ä¹  Rust å¤åˆç±»å‹ç³»ç»Ÿçš„å®è·µæŒ‡å—ï¼ŒåŒ…æ‹¬ç»“æ„ä½“ã€æšä¸¾ç­‰
- **ç±»å‹**: å®è·µæŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: ç±»å‹ç³»ç»Ÿã€æ•°æ®ç»“æ„
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: ç»“æ„ä½“ã€æšä¸¾ã€å¤åˆç±»å‹ã€æ¨¡å¼åŒ¹é…

**å¤åˆç±»å‹ (Compound Types)**:

- **å®šä¹‰**: ç”±å¤šä¸ªå€¼ç»„åˆè€Œæˆçš„ç±»å‹
- **ç±»å‹**: ç±»å‹ç³»ç»Ÿ
- **å±æ€§**: ç»“æ„ä½“ã€æšä¸¾ã€å…ƒç»„ã€æ•°ç»„
- **å…³ç³»**: ä¸åŸºç¡€ç±»å‹ã€æ³›å‹ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **ç»“æ„ä½“**: å‘½åå­—æ®µç»“æ„ä½“ã€å…ƒç»„ç»“æ„ä½“ã€å•å…ƒç»“æ„ä½“
- **æšä¸¾**: åŸºæœ¬æšä¸¾ã€å¸¦æ•°æ®çš„æšä¸¾ã€Option/Result
- **æ¨¡å¼åŒ¹é…**: match è¡¨è¾¾å¼ã€if letã€è§£æ„æ¨¡å¼
- **æ–¹æ³•**: ç»“æ„ä½“æ–¹æ³•ã€æšä¸¾æ–¹æ³•ã€å…³è”å‡½æ•°

**æ€§èƒ½ç‰¹å¾**:

- **å†…å­˜å¸ƒå±€**: ç»“æ„ä½“å’Œæšä¸¾çš„å†…å­˜è¡¨ç¤º
- **é›¶æˆæœ¬æŠ½è±¡**: å¤åˆç±»å‹é›¶å¼€é”€
- **é€‚ç”¨åœºæ™¯**: æ•°æ®ç»“æ„è®¾è®¡ã€çŠ¶æ€æœºã€é”™è¯¯å¤„ç†

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- ç»“æ„ä½“ --[is-a]--> å¤åˆç±»å‹
- æšä¸¾ --[is-a]--> å¤åˆç±»å‹

**ç»„åˆå…³ç³»**:

- å¤åˆç±»å‹æŒ‡å— --[covers]--> å¤šç§å¤åˆç±»å‹
- æ•°æ®ç»“æ„è®¾è®¡ --[uses]--> å¤åˆç±»å‹

**ä¾èµ–å…³ç³»**:

- å¤åˆç±»å‹ --[depends-on]--> åŸºç¡€ç±»å‹
- ç¨‹åºå»ºæ¨¡ --[depends-on]--> å¤åˆç±»å‹

### æ€ç»´å¯¼å›¾

```text
å¤åˆç±»å‹æŒ‡å—
â”‚
â”œâ”€â”€ ç»“æ„ä½“
â”‚   â”œâ”€â”€ å‘½åå­—æ®µç»“æ„ä½“
â”‚   â””â”€â”€ å…ƒç»„ç»“æ„ä½“
â”œâ”€â”€ æšä¸¾
â”‚   â”œâ”€â”€ åŸºæœ¬æšä¸¾
â”‚   â””â”€â”€ Option/Result
â”œâ”€â”€ æ¨¡å¼åŒ¹é…
â”‚   â””â”€â”€ match è¡¨è¾¾å¼
â””â”€â”€ æ–¹æ³•
    â””â”€â”€ ç»“æ„ä½“æ–¹æ³•
```

---

## ğŸ“Š ç« èŠ‚æ¦‚è§ˆ

| ç« èŠ‚            | å†…å®¹                | éš¾åº¦    | é¢„è®¡æ—¶é—´ |
| :--- | :--- | :--- | :--- || 1. å¤åˆç±»å‹æ¦‚è¿° | å¤åˆç±»å‹åŸºæœ¬æ¦‚å¿µ    | ğŸŸ¢ ç®€å• | 20åˆ†é’Ÿ   |
| 2. ç»“æ„ä½“       | ä¸‰ç§ç»“æ„ä½“å½¢å¼      | ğŸŸ¢ ç®€å• | 60åˆ†é’Ÿ   |
| 3. æšä¸¾         | æšä¸¾å®šä¹‰å’Œä½¿ç”¨      | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ   |
| 4. æ¨¡å¼åŒ¹é…     | matchã€if letã€è§£æ„ | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ   |
| 5. å¯¹æ¯”åˆ†æ     | ç»“æ„ä½“ vs æšä¸¾      | ğŸŸ¡ ä¸­ç­‰ | 20åˆ†é’Ÿ   |
| 6. å®æˆ˜æ¡ˆä¾‹     | ç»¼åˆåº”ç”¨            | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ   |
| 7. æœ€ä½³å®è·µ     | é™·é˜±ä¸å®è·µ          | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ   |
| 8. æ€§èƒ½è€ƒè™‘     | å†…å­˜å¸ƒå±€å’Œä¼˜åŒ–      | ğŸ”´ é«˜çº§ | 30åˆ†é’Ÿ   |

**æ€»è®¡**: çº¦ 5-6 å°æ—¶

---

## 1. å¤åˆç±»å‹æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯å¤åˆç±»å‹

**å¤åˆç±»å‹** (Compound Types) æ˜¯å°†å¤šä¸ªå€¼ç»„åˆæˆä¸€ä¸ªç±»å‹çš„æ•°æ®ç»“æ„ã€‚

**æ ¸å¿ƒç‰¹ç‚¹**:

- ğŸ“¦ ç»„åˆå¤šä¸ªå€¼
- ğŸ—ï¸ è‡ªå®šä¹‰æ•°æ®ç»“æ„
- ğŸ¯ æ›´å¥½çš„ä»£ç ç»„ç»‡
- ğŸ”’ ç±»å‹å®‰å…¨

**ä¸¤å¤§ç±»**:

1. **ç»“æ„ä½“ (Struct)** - ç»„åˆä¸åŒå‘½åçš„å­—æ®µ
2. **æšä¸¾ (Enum)** - è¡¨ç¤ºå¤šç§å¯èƒ½çš„å˜ä½“

### 1.2 Rust å¤åˆç±»å‹åˆ†ç±»

```text
Rust å¤åˆç±»å‹
â”œâ”€â”€ ç»“æ„ä½“ (Struct)
â”‚   â”œâ”€â”€ å‘½åå­—æ®µç»“æ„ä½“ (Named Fields)
â”‚   â”œâ”€â”€ å…ƒç»„ç»“æ„ä½“ (Tuple Struct)
â”‚   â””â”€â”€ å•å…ƒç»“æ„ä½“ (Unit Struct)
â”‚
â””â”€â”€ æšä¸¾ (Enum)
    â”œâ”€â”€ æ— æ•°æ®æšä¸¾
    â”œâ”€â”€ å¸¦æ•°æ®æšä¸¾
    â”œâ”€â”€ Option<T>
    â””â”€â”€ Result<T, E>
```

---

## 2. ç»“æ„ä½“ (Struct)

ç»“æ„ä½“æ˜¯ Rust ä¸­æœ€å¸¸ç”¨çš„å¤åˆç±»å‹ï¼Œç”¨äºåˆ›å»ºè‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ã€‚

### 2.1 å‘½åå­—æ®µç»“æ„ä½“

#### å®šä¹‰å’Œåˆ›å»º

```rust
// å®šä¹‰ç»“æ„ä½“
struct User {
    username: String,
    email: String,
    active: bool,
    sign_in_count: u64,
}

fn main() {
    // åˆ›å»ºå®ä¾‹
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // è®¿é—®å­—æ®µ
    println!("User email: {}", user1.email);
    println!("Username: {}", user1.username);
}
```

#### å¯å˜æ€§

```rust
fn main() {
    // æ•´ä¸ªå®ä¾‹å¿…é¡»æ˜¯å¯å˜çš„
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // ä¿®æ”¹å­—æ®µ
    user1.email = String::from("anotheremail@example.com");
    println!("Updated email: {}", user1.email);
}

struct User {
    username: String,
    email: String,
    active: bool,
    sign_in_count: u64,
}
```

#### å­—æ®µåˆå§‹åŒ–ç®€å†™

```rust
struct User {
    username: String,
    email: String,
    active: bool,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    // å­—æ®µåˆå§‹åŒ–ç®€å†™
    User {
        email,      // ç­‰åŒäº email: email
        username,   // ç­‰åŒäº username: username
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"),
    );

    println!("User: {}", user1.username);
}
```

#### ç»“æ„ä½“æ›´æ–°è¯­æ³•

```rust
struct User {
    username: String,
    email: String,
    active: bool,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1  // ä½¿ç”¨ user1 çš„å…¶ä½™å­—æ®µ
    };

    // æ³¨æ„ï¼šuser1 çš„ username å·²è¢«ç§»åŠ¨åˆ° user2
    // println!("{}", user1.username); // ç¼–è¯‘é”™è¯¯ï¼
    println!("User2: {}", user2.username);
}
```

### 2.2 å…ƒç»„ç»“æ„ä½“

#### åŸºæœ¬ç”¨æ³•

```rust
// å®šä¹‰å…ƒç»„ç»“æ„ä½“
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    // è®¿é—®å­—æ®µ
    println!("Black: ({}, {}, {})", black.0, black.1, black.2);
    println!("Origin: ({}, {}, {})", origin.0, origin.1, origin.2);

    // æ³¨æ„ï¼šColor å’Œ Point æ˜¯ä¸åŒçš„ç±»å‹
    // let color: Color = origin; // ç¼–è¯‘é”™è¯¯ï¼
}
```

#### å®é™…åº”ç”¨

```rust
// Newtype æ¨¡å¼
struct Meters(f64);
struct Seconds(f64);

fn main() {
    let distance = Meters(100.0);
    let time = Seconds(10.0);

    // ç±»å‹å®‰å…¨ï¼šä¸èƒ½æ··æ·†
    // let speed = distance.0 / time; // ç¼–è¯‘é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
    let speed = distance.0 / time.0; // âœ… æ˜ç¡®è½¬æ¢

    println!("Speed: {} m/s", speed);
}
```

### 2.3 å•å…ƒç»“æ„ä½“

#### åŸºæœ¬æ¦‚å¿µ

```rust
// å•å…ƒç»“æ„ä½“ï¼šæ²¡æœ‰ä»»ä½•å­—æ®µ
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;

    // é›¶å¤§å°ç±»å‹
    use std::mem;
    println!("Size of AlwaysEqual: {} bytes", mem::size_of::<AlwaysEqual>());
}
```

#### å®é™…åº”ç”¨2

```rust
// ç”¨äºå®ç° trait
struct FileLogger;

trait Logger {
    fn log(&self, message: &str);
}

impl Logger for FileLogger {
    fn log(&self, message: &str) {
        println!("[FILE] {}", message);
    }
}

fn main() {
    let logger = FileLogger;
    logger.log("Application started");
}
```

### 2.4 ç»“æ„ä½“æ–¹æ³•

#### å®šä¹‰æ–¹æ³•

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•ï¼šç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ self
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    // å¯å˜æ–¹æ³•
    fn scale(&mut self, factor: u32) {
        self.width *= factor;
        self.height *= factor;
    }

    // æ¶ˆè€—æ‰€æœ‰æƒçš„æ–¹æ³•
    fn into_square(self) -> Rectangle {
        let size = std::cmp::max(self.width, self.height);
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("Area: {}", rect1.area());

    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };

    println!("Can hold: {}", rect1.can_hold(&rect2));

    // å¯å˜æ–¹æ³•
    let mut rect3 = Rectangle {
        width: 10,
        height: 20,
    };
    rect3.scale(2);
    println!("Scaled: {:?}", rect3);
}
```

### 2.5 å…³è”å‡½æ•°

#### å®šä¹‰å…³è”å‡½æ•°

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // å…³è”å‡½æ•°ï¼šæ²¡æœ‰ self å‚æ•°
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    // ä½¿ç”¨ :: è°ƒç”¨å…³è”å‡½æ•°
    let rect1 = Rectangle::new(30, 50);
    let rect2 = Rectangle::square(20);

    println!("Rectangle: {:?}", rect1);
    println!("Square: {:?}", rect2);
}
```

### 2.6 ç»“æ„ä½“çš„å¯è§æ€§

```rust
mod shapes {
    // å…¬å¼€ç»“æ„ä½“
    pub struct Circle {
        pub radius: f64,  // å…¬å¼€å­—æ®µ
        center_x: f64,    // ç§æœ‰å­—æ®µ
        center_y: f64,    // ç§æœ‰å­—æ®µ
    }

    impl Circle {
        pub fn new(radius: f64, center_x: f64, center_y: f64) -> Circle {
            Circle {
                radius,
                center_x,
                center_y,
            }
        }

        pub fn area(&self) -> f64 {
            std::f64::consts::PI * self.radius * self.radius
        }
    }
}

fn main() {
    let circle = shapes::Circle::new(5.0, 0.0, 0.0);

    // å¯ä»¥è®¿é—®å…¬å¼€å­—æ®µ
    println!("Radius: {}", circle.radius);

    // ä¸èƒ½è®¿é—®ç§æœ‰å­—æ®µ
    // println!("Center: ({}, {})", circle.center_x, circle.center_y); // ç¼–è¯‘é”™è¯¯ï¼

    println!("Area: {}", circle.area());
}
```

---

## 3. æšä¸¾ (Enum)

æšä¸¾å…è®¸å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œå®ƒå¯ä»¥æ˜¯å‡ ä¸ªå¯èƒ½çš„å˜ä½“ä¹‹ä¸€ã€‚

### 3.1 åŸºæœ¬æšä¸¾

#### å®šä¹‰å’Œä½¿ç”¨

```rust
// å®šä¹‰æšä¸¾
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    // åˆ›å»ºæšä¸¾å€¼
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {
    // ä½¿ç”¨æšä¸¾å€¼
    match ip_kind {
        IpAddrKind::V4 => println!("IPv4"),
        IpAddrKind::V6 => println!("IPv6"),
    }
}
```

### 3.2 å¸¦æ•°æ®çš„æšä¸¾

#### åŸºæœ¬å½¢å¼

```rust
// æšä¸¾å˜ä½“å¯ä»¥æºå¸¦æ•°æ®
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));

    print_ip(home);
    print_ip(loopback);
}

fn print_ip(ip: IpAddr) {
    match ip {
        IpAddr::V4(a, b, c, d) => {
            println!("IPv4: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(addr) => {
            println!("IPv6: {}", addr);
        }
    }
}
```

#### å¤æ‚æšä¸¾

```rust
enum Message {
    Quit,                       // æ— æ•°æ®
    Move { x: i32, y: i32 },   // å‘½åå­—æ®µ
    Write(String),              // å•ä¸ª String
    ChangeColor(i32, i32, i32), // ä¸‰ä¸ª i32
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from("Hello"));
    let msg4 = Message::ChangeColor(255, 0, 0);

    process_message(msg1);
    process_message(msg2);
    process_message(msg3);
    process_message(msg4);
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit => {
            println!("Quit message");
        }
        Message::Move { x, y } => {
            println!("Move to ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("Text message: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change color to RGB({}, {}, {})", r, g, b);
        }
    }
}
```

### 3.3 Option æšä¸¾

#### åŸºæœ¬æ¦‚å¿µ3

```rust
// Option æ˜¯æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾
// enum Option<T> {
//     Some(T),
//     None,
// }

fn main() {
    // Some è¡¨ç¤ºæœ‰å€¼
    let some_number = Some(5);
    let some_string = Some("a string");

    // None è¡¨ç¤ºæ²¡æœ‰å€¼
    let absent_number: Option<i32> = None;

    // ä½¿ç”¨ Option
    match some_number {
        Some(value) => println!("Value: {}", value),
        None => println!("No value"),
    }

    // Option æ–¹æ³•
    let x: Option<i32> = Some(2);
    println!("Is some: {}", x.is_some());
    println!("Is none: {}", x.is_none());

    // unwrap (ä¸å®‰å…¨ï¼Œå¯èƒ½ panic)
    let value = x.unwrap();
    println!("Unwrapped: {}", value);

    // unwrap_or (æä¾›é»˜è®¤å€¼)
    let y: Option<i32> = None;
    let value = y.unwrap_or(0);
    println!("Value or default: {}", value);
}
```

#### Option å¸¸ç”¨æ–¹æ³•

```rust
fn main() {
    let x = Some(5);

    // map: è½¬æ¢å†…éƒ¨å€¼
    let y = x.map(|v| v * 2);
    println!("Mapped: {:?}", y); // Some(10)

    // and_then: é“¾å¼æ“ä½œ
    let z = x.and_then(|v| Some(v * 2));
    println!("And then: {:?}", z); // Some(10)

    // or: æä¾›å¤‡é€‰
    let a: Option<i32> = None;
    let b = a.or(Some(10));
    println!("Or: {:?}", b); // Some(10)

    // filter: è¿‡æ»¤
    let c = x.filter(|&v| v > 3);
    println!("Filtered: {:?}", c); // Some(5)
}
```

### 3.4 Result æšä¸¾

#### åŸºæœ¬æ¦‚å¿µ34

```rust
// Result æ˜¯æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾
// enum Result<T, E> {
//     Ok(T),
//     Err(E),
// }

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    // æˆåŠŸæƒ…å†µ
    match divide(10.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    // é”™è¯¯æƒ…å†µ
    match divide(10.0, 0.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    // ä½¿ç”¨ unwrap (ä¸å®‰å…¨)
    // let result = divide(10.0, 0.0).unwrap(); // panic!

    // ä½¿ç”¨ expect (å¸¦è‡ªå®šä¹‰æ¶ˆæ¯)
    // let result = divide(10.0, 0.0).expect("Division failed");

    // ä½¿ç”¨ unwrap_or
    let result = divide(10.0, 0.0).unwrap_or(0.0);
    println!("Result or default: {}", result);
}
```

#### Result å¸¸ç”¨æ–¹æ³•

```rust
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse::<i32>()
}

fn main() {
    // map: è½¬æ¢ Ok å€¼
    let result = parse_number("42").map(|v| v * 2);
    println!("Mapped: {:?}", result); // Ok(84)

    // map_err: è½¬æ¢ Err å€¼
    let result = parse_number("abc").map_err(|e| format!("Parse error: {}", e));
    println!("Mapped error: {:?}", result);

    // and_then: é“¾å¼æ“ä½œ
    let result = parse_number("42").and_then(|v| Ok(v * 2));
    println!("And then: {:?}", result); // Ok(84)

    // or: æä¾›å¤‡é€‰
    let result = parse_number("abc").or(Ok(0));
    println!("Or: {:?}", result); // Ok(0)

    // ? æ“ä½œç¬¦ (åœ¨å‡½æ•°ä¸­ä½¿ç”¨)
    fn double_number(s: &str) -> Result<i32, std::num::ParseIntError> {
        let num = s.parse::<i32>()?; // å¦‚æœæ˜¯ Errï¼Œæå‰è¿”å›
        Ok(num * 2)
    }

    println!("Double: {:?}", double_number("42"));
}
```

### 3.5 æšä¸¾æ–¹æ³•

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    // æšä¸¾å¯ä»¥æœ‰æ–¹æ³•
    fn call(&self) {
        match self {
            Message::Quit => println!("Quit"),
            Message::Move { x, y } => println!("Move to ({}, {})", x, y),
            Message::Write(text) => println!("Write: {}", text),
            Message::ChangeColor(r, g, b) => println!("Color: RGB({}, {}, {})", r, g, b),
        }
    }

    fn is_quit(&self) -> bool {
        matches!(self, Message::Quit)
    }
}

fn main() {
    let msg = Message::Write(String::from("Hello"));
    msg.call();

    println!("Is quit: {}", msg.is_quit());
}
```

### 3.6 æšä¸¾çš„å†…å­˜è¡¨ç¤º

```rust
use std::mem;

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    // æšä¸¾çš„å¤§å°æ˜¯æœ€å¤§å˜ä½“çš„å¤§å° + åˆ¤åˆ«å€¼
    println!("Size of Message: {} bytes", mem::size_of::<Message>());

    // åˆ¤åˆ«å€¼ä¼˜åŒ–
    println!("Size of Option<i32>: {} bytes", mem::size_of::<Option<i32>>());
    println!("Size of Option<Box<i32>>: {} bytes", mem::size_of::<Option<Box<i32>>>());

    // ç©ºæŒ‡é’ˆä¼˜åŒ–ï¼šOption<Box<T>> å’Œ Box<T> å¤§å°ç›¸åŒ
    println!("Size of Box<i32>: {} bytes", mem::size_of::<Box<i32>>());
}
```

---

## 4. æ¨¡å¼åŒ¹é…

æ¨¡å¼åŒ¹é…æ˜¯ Rust æœ€å¼ºå¤§çš„ç‰¹æ€§ä¹‹ä¸€ã€‚

### 4.1 match è¡¨è¾¾å¼

#### åŸºæœ¬ç”¨æ³•41

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {
    let coin = Coin::Dime;
    println!("Value: {} cents", value_in_cents(coin));
}
```

#### ç»‘å®šå€¼

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // ...
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    let coin = Coin::Quarter(UsState::Alaska);
    println!("Value: {} cents", value_in_cents(coin));
}
```

#### åŒ¹é… Option

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("Six: {:?}", six);
    println!("None: {:?}", none);
}
```

#### é€šé…æ¨¡å¼

```rust
fn main() {
    let dice_roll = 9;

    match dice_roll {
        3 => println!("You get a hat"),
        7 => println!("You lose a hat"),
        other => println!("Move {} spaces", other), // ç»‘å®šå…¶ä»–å€¼
    }

    // ä½¿ç”¨ _ å¿½ç•¥å€¼
    match dice_roll {
        3 => println!("You get a hat"),
        7 => println!("You lose a hat"),
        _ => println!("Reroll"), // å¿½ç•¥å…¶ä»–æƒ…å†µ
    }
}
```

### 4.2 if let è¡¨è¾¾å¼

```rust
fn main() {
    let config_max = Some(3u8);

    // ä½¿ç”¨ match
    match config_max {
        Some(max) => println!("The maximum is {}", max),
        _ => (),
    }

    // ä½¿ç”¨ if let (æ›´ç®€æ´)
    if let Some(max) = config_max {
        println!("The maximum is {}", max);
    }

    // if let å¯ä»¥æœ‰ else
    let value = Some(5);
    if let Some(v) = value {
        println!("Value: {}", v);
    } else {
        println!("No value");
    }
}
```

### 4.3 while let å¾ªç¯

```rust
fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    // while let å¾ªç¯
    while let Some(top) = stack.pop() {
        println!("Popped: {}", top);
    }
}
```

### 4.4 è§£æ„æ¨¡å¼

#### è§£æ„ç»“æ„ä½“

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    // è§£æ„
    let Point { x, y } = p;
    println!("x: {}, y: {}", x, y);

    // é‡å‘½å
    let Point { x: a, y: b } = p;
    println!("a: {}, b: {}", a, b);

    // éƒ¨åˆ†è§£æ„
    let Point { x, .. } = p;
    println!("x: {}", x);

    // match ä¸­è§£æ„
    match p {
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```

#### è§£æ„æšä¸¾

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("Quit");
        }
        Message::Move { x, y } => {
            println!("Move to x:{}, y:{}", x, y);
        }
        Message::Write(text) => {
            println!("Text: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change color to red:{}, green:{}, blue:{}", r, g, b);
        }
    }
}
```

### 4.5 åŒ¹é…å®ˆå«

```rust
fn main() {
    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }

    // å¤šä¸ªæ¨¡å¼ + å®ˆå«
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
}
```

### 4.6 @ ç»‘å®š

```rust
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
}
```

---

## 5. ç»“æ„ä½“ä¸æšä¸¾çš„å¯¹æ¯”

| ç‰¹æ€§         | ç»“æ„ä½“           | æšä¸¾                   |
| :--- | :--- | :--- || **ç”¨é€”**     | ç»„åˆå¤šä¸ªå­—æ®µ     | è¡¨ç¤ºå¤šç§å¯èƒ½çš„å˜ä½“     |
| **æ•°æ®**     | åŒæ—¶åŒ…å«æ‰€æœ‰å­—æ®µ | æŸä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªå˜ä½“   |
| **å†…å­˜**     | æ‰€æœ‰å­—æ®µçš„æ€»å’Œ   | æœ€å¤§å˜ä½“ + åˆ¤åˆ«å€¼      |
| **åŒ¹é…**     | è§£æ„å­—æ®µ         | match å¿…é¡»è¦†ç›–æ‰€æœ‰å˜ä½“ |
| **é€‚ç”¨åœºæ™¯** | å›ºå®šçš„æ•°æ®ç»“æ„   | å¤šç§å¯èƒ½çš„çŠ¶æ€         |

**é€‰æ‹©å»ºè®®**:

- âœ… æ•°æ®æ€»æ˜¯åŒæ—¶å­˜åœ¨ â†’ ä½¿ç”¨ç»“æ„ä½“
- âœ… æ•°æ®æ˜¯å¤šé€‰ä¸€ â†’ ä½¿ç”¨æšä¸¾
- âœ… éœ€è¦ Option è¯­ä¹‰ â†’ ä½¿ç”¨ Option
- âœ… éœ€è¦é”™è¯¯å¤„ç† â†’ ä½¿ç”¨ Result

---

## 6. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: å›¾å½¢ç³»ç»Ÿ

```rust
#[derive(Debug)]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius } => {
                std::f64::consts::PI * radius * radius
            }
            Shape::Rectangle { width, height } => {
                width * height
            }
            Shape::Triangle { base, height } => {
                0.5 * base * height
            }
        }
    }

    fn perimeter(&self) -> f64 {
        match self {
            Shape::Circle { radius } => {
                2.0 * std::f64::consts::PI * radius
            }
            Shape::Rectangle { width, height } => {
                2.0 * (width + height)
            }
            Shape::Triangle { base, height } => {
                // ç®€åŒ–ï¼šå‡è®¾æ˜¯ç›´è§’ä¸‰è§’å½¢
                let hypotenuse = (base * base + height * height).sqrt();
                base + height + hypotenuse
            }
        }
    }
}

fn main() {
    let shapes = vec![
        Shape::Circle { radius: 5.0 },
        Shape::Rectangle { width: 10.0, height: 20.0 },
        Shape::Triangle { base: 6.0, height: 8.0 },
    ];

    for shape in shapes.iter() {
        println!("{:?}", shape);
        println!("Area: {:.2}", shape.area());
        println!("Perimeter: {:.2}", shape.perimeter());
        println!();
    }
}
```

### æ¡ˆä¾‹ 2: ç”¨æˆ·ç³»ç»Ÿ

```rust
#[derive(Debug)]
struct User {
    id: u64,
    username: String,
    email: String,
    role: UserRole,
    status: UserStatus,
}

#[derive(Debug)]
enum UserRole {
    Admin,
    Moderator,
    User,
}

#[derive(Debug)]
enum UserStatus {
    Active,
    Suspended { reason: String, until: String },
    Banned,
}

impl User {
    fn new(id: u64, username: String, email: String) -> Self {
        User {
            id,
            username,
            email,
            role: UserRole::User,
            status: UserStatus::Active,
        }
    }

    fn can_post(&self) -> bool {
        matches!(self.status, UserStatus::Active)
    }

    fn suspend(&mut self, reason: String, until: String) {
        self.status = UserStatus::Suspended { reason, until };
    }

    fn is_admin(&self) -> bool {
        matches!(self.role, UserRole::Admin)
    }
}

fn main() {
    let mut user = User::new(
        1,
        String::from("alice"),
        String::from("alice@example.com"),
    );

    println!("User: {:?}", user);
    println!("Can post: {}", user.can_post());

    user.suspend(
        String::from("Spam"),
        String::from("2025-11-01"),
    );

    println!("After suspension: {:?}", user);
    println!("Can post: {}", user.can_post());
}
```

### æ¡ˆä¾‹ 3: çŠ¶æ€æœº

```rust
#[derive(Debug)]
enum ConnectionState {
    Disconnected,
    Connecting,
    Connected { session_id: String },
    Error { message: String },
}

struct Connection {
    state: ConnectionState,
}

impl Connection {
    fn new() -> Self {
        Connection {
            state: ConnectionState::Disconnected,
        }
    }

    fn connect(&mut self) -> Result<(), String> {
        match self.state {
            ConnectionState::Disconnected => {
                self.state = ConnectionState::Connecting;
                // æ¨¡æ‹Ÿè¿æ¥
                self.state = ConnectionState::Connected {
                    session_id: String::from("session123"),
                };
                Ok(())
            }
            _ => Err(String::from("Invalid state transition")),
        }
    }

    fn disconnect(&mut self) {
        self.state = ConnectionState::Disconnected;
    }

    fn get_status(&self) -> String {
        match &self.state {
            ConnectionState::Disconnected => String::from("Disconnected"),
            ConnectionState::Connecting => String::from("Connecting..."),
            ConnectionState::Connected { session_id } => {
                format!("Connected (session: {})", session_id)
            }
            ConnectionState::Error { message } => {
                format!("Error: {}", message)
            }
        }
    }
}

fn main() {
    let mut conn = Connection::new();

    println!("Status: {}", conn.get_status());

    conn.connect().unwrap();
    println!("Status: {}", conn.get_status());

    conn.disconnect();
    println!("Status: {}", conn.get_status());
}
```

### æ¡ˆä¾‹ 4: é”™è¯¯å¤„ç†

```rust
#[derive(Debug)]
enum AppError {
    IoError(String),
    ParseError(String),
    ValidationError(String),
    NotFound(String),
}

type Result<T> = std::result::Result<T, AppError>;

#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
}

impl Config {
    fn from_str(s: &str) -> Result<Self> {
        let parts: Vec<&str> = s.split(':').collect();

        if parts.len() != 2 {
            return Err(AppError::ValidationError(
                String::from("Invalid format, expected host:port")
            ));
        }

        let host = parts[0].to_string();
        let port = parts[1].parse::<u16>()
            .map_err(|e| AppError::ParseError(format!("Invalid port: {}", e)))?;

        if port == 0 {
            return Err(AppError::ValidationError(
                String::from("Port cannot be 0")
            ));
        }

        Ok(Config { host, port })
    }
}

fn main() {
    // æˆåŠŸæƒ…å†µ
    match Config::from_str("localhost:8080") {
        Ok(config) => println!("Config: {:?}", config),
        Err(e) => println!("Error: {:?}", e),
    }

    // é”™è¯¯æƒ…å†µ
    match Config::from_str("localhost:abc") {
        Ok(config) => println!("Config: {:?}", config),
        Err(e) => println!("Error: {:?}", e),
    }

    // éªŒè¯é”™è¯¯
    match Config::from_str("localhost:0") {
        Ok(config) => println!("Config: {:?}", config),
        Err(e) => println!("Error: {:?}", e),
    }
}
```

---

## 7. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 7.1 å¸¸è§é™·é˜±

```rust
// âŒ é™·é˜± 1: å¿˜è®°æ‰€æœ‰æƒè½¬ç§»
fn mistake1() {
    #[derive(Debug)]
    struct Data {
        value: String,
    }

    let data = Data {
        value: String::from("hello"),
    };

    let copied = Data {
        value: data.value, // value è¢«ç§»åŠ¨
        ..data
    };

    // println!("{:?}", data); // ç¼–è¯‘é”™è¯¯ï¼value å·²è¢«ç§»åŠ¨
}

// âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ Clone
#[derive(Debug, Clone)]
struct Data {
    value: String,
}

fn correct1() {
    let data = Data {
        value: String::from("hello"),
    };

    let copied = Data {
        value: data.value.clone(),
        ..data
    };

    println!("{:?}", data); // âœ… å¯ä»¥ä½¿ç”¨
}

// âŒ é™·é˜± 2: match ä¸å®Œæ•´
fn mistake2(opt: Option<i32>) {
    // match opt {
    //     Some(x) => println!("{}", x),
    //     // ç¼ºå°‘ None åˆ†æ”¯ - ç¼–è¯‘é”™è¯¯ï¼
    // }
}

// âœ… æ­£ç¡®åšæ³•
fn correct2(opt: Option<i32>) {
    match opt {
        Some(x) => println!("{}", x),
        None => println!("No value"),
    }
}

// âŒ é™·é˜± 3: æšä¸¾å¤§å°è†¨èƒ€
enum BigEnum {
    Small(u8),
    Large([u8; 1000]), // å¯¼è‡´æ•´ä¸ªæšä¸¾å˜å¤§
}

// âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ Box
enum BetterEnum {
    Small(u8),
    Large(Box<[u8; 1000]>), // åªå¢åŠ æŒ‡é’ˆå¤§å°
}

fn main() {
    use std::mem;
    println!("BigEnum size: {}", mem::size_of::<BigEnum>());
    println!("BetterEnum size: {}", mem::size_of::<BetterEnum>());
}
```

### 7.2 æœ€ä½³å®è·µ

```rust
// âœ… 1. ä¸ºç»“æ„ä½“æ´¾ç”Ÿå¸¸ç”¨ trait
#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// âœ… 2. ä½¿ç”¨ builder æ¨¡å¼
struct User {
    username: String,
    email: String,
    age: Option<u32>,
    active: bool,
}

impl User {
    fn new(username: String, email: String) -> Self {
        User {
            username,
            email,
            age: None,
            active: true,
        }
    }

    fn age(mut self, age: u32) -> Self {
        self.age = Some(age);
        self
    }

    fn inactive(mut self) -> Self {
        self.active = false;
        self
    }
}

// âœ… 3. ä½¿ç”¨ç±»å‹åˆ«åç®€åŒ–
type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

// âœ… 4. æšä¸¾ä½¿ç”¨æœ‰æ„ä¹‰çš„åç§°
enum PaymentStatus {
    Pending,
    Processing,
    Completed,
    Failed { reason: String },
}

// âœ… 5. ä¸ºæšä¸¾å®ç° Display
use std::fmt;

impl fmt::Display for PaymentStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            PaymentStatus::Pending => write!(f, "Pending"),
            PaymentStatus::Processing => write!(f, "Processing"),
            PaymentStatus::Completed => write!(f, "Completed"),
            PaymentStatus::Failed { reason } => write!(f, "Failed: {}", reason),
        }
    }
}

fn main() {
    let user = User::new(
        String::from("alice"),
        String::from("alice@example.com"),
    )
    .age(25);

    println!("User: {}", user.username);

    let status = PaymentStatus::Completed;
    println!("Status: {}", status);
}
```

---

## 8. æ€§èƒ½è€ƒè™‘

### 8.1 å†…å­˜å¸ƒå±€

```rust
use std::mem;

#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
}

#[derive(Debug)]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

fn main() {
    // ç»“æ„ä½“å¤§å°
    println!("Size of Point: {} bytes", mem::size_of::<Point>());

    // æšä¸¾å¤§å° = åˆ¤åˆ«å€¼ + æœ€å¤§å˜ä½“
    println!("Size of Shape: {} bytes", mem::size_of::<Shape>());

    // Option ä¼˜åŒ–
    println!("Size of Option<Point>: {} bytes", mem::size_of::<Option<Point>>());
    println!("Size of Option<Box<Point>>: {} bytes", mem::size_of::<Option<Box<Point>>>());
    println!("Size of Box<Point>: {} bytes", mem::size_of::<Box<Point>>());
}
```

### 8.2 æ€§èƒ½ä¼˜åŒ–

```rust
// âŒ æ€§èƒ½é—®é¢˜ï¼šå¤§æšä¸¾
enum LargeEnum {
    Small(u32),
    Large([u8; 10000]),
}

// âœ… ä¼˜åŒ–ï¼šä½¿ç”¨ Box
enum OptimizedEnum {
    Small(u32),
    Large(Box<[u8; 10000]>),
}

// âœ… ä½¿ç”¨å°çš„åˆ¤åˆ«å€¼
#[repr(u8)]
enum SmallEnum {
    A,
    B,
    C,
}

fn main() {
    use std::mem;

    println!("LargeEnum: {} bytes", mem::size_of::<LargeEnum>());
    println!("OptimizedEnum: {} bytes", mem::size_of::<OptimizedEnum>());
    println!("SmallEnum: {} bytes", mem::size_of::<SmallEnum>());
}
```

### 8.4 ç»¼åˆå®æˆ˜æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½é…ç½®ç®¡ç†ç³»ç»Ÿ

**æ¡ˆä¾‹ï¼šç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ**:

```rust
use std::collections::HashMap;

/// é…ç½®å€¼çš„æšä¸¾è¡¨ç¤º
#[derive(Debug, Clone)]
pub enum ConfigValue {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Array(Vec<ConfigValue>),
    Object(HashMap<String, ConfigValue>),
}

impl ConfigValue {
    /// ç±»å‹å®‰å…¨çš„å€¼è·å–
    pub fn as_string(&self) -> Option<&str> {
        match self {
            ConfigValue::String(s) => Some(s),
            _ => None,
        }
    }

    pub fn as_i64(&self) -> Option<i64> {
        match self {
            ConfigValue::Integer(i) => Some(*i),
            _ => None,
        }
    }

    pub fn as_array(&self) -> Option<&Vec<ConfigValue>> {
        match self {
            ConfigValue::Array(arr) => Some(arr),
            _ => None,
        }
    }
}

/// é…ç½®ç®¡ç†å™¨
pub struct Config {
    values: HashMap<String, ConfigValue>,
}

impl Config {
    pub fn new() -> Self {
        Self {
            values: HashMap::new(),
        }
    }

    pub fn set(&mut self, key: String, value: ConfigValue) {
        self.values.insert(key, value);
    }

    pub fn get(&self, key: &str) -> Option<&ConfigValue> {
        self.values.get(key)
    }

    pub fn get_string(&self, key: &str) -> Option<&str> {
        self.get(key).and_then(|v| v.as_string())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut config = Config::new();

    config.set("app_name".to_string(), ConfigValue::String("MyApp".to_string()));
    config.set("max_connections".to_string(), ConfigValue::Integer(100));
    config.set("debug".to_string(), ConfigValue::Boolean(true));

    // ç±»å‹å®‰å…¨çš„è®¿é—®
    if let Some(name) = config.get_string("app_name") {
        println!("App Name: {}", name);
    }

    if let Some(max_conn) = config.get("max_connections").and_then(|v| v.as_i64()) {
        println!("Max Connections: {}", max_conn);
    }
}
```

**æ€§èƒ½ä¼˜åŠ¿**:

- âœ… é›¶å¼€é”€æŠ½è±¡ï¼šæšä¸¾çš„å†…å­˜å¸ƒå±€é«˜æ•ˆ
- âœ… ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶æ•è·ç±»å‹é”™è¯¯
- âœ… æ¨¡å¼åŒ¹é…ä¼˜åŒ–ï¼šç¼–è¯‘å™¨ç”Ÿæˆé«˜æ•ˆåˆ†æ”¯ä»£ç 

---

## 9. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç»“æ„ä½“**
   - âœ… ä¸‰ç§å½¢å¼ï¼šå‘½åå­—æ®µã€å…ƒç»„ã€å•å…ƒ
   - âœ… ä½¿ç”¨ impl å®šä¹‰æ–¹æ³•å’Œå…³è”å‡½æ•°
   - âœ… ç»“æ„ä½“æ›´æ–°è¯­æ³•å’Œå­—æ®µåˆå§‹åŒ–ç®€å†™

2. **æšä¸¾**
   - âœ… è¡¨ç¤ºå¤šç§å¯èƒ½çš„å˜ä½“
   - âœ… å˜ä½“å¯ä»¥æºå¸¦ä¸åŒç±»å‹çš„æ•°æ®
   - âœ… Option å’Œ Result æ˜¯æœ€å¸¸ç”¨çš„æšä¸¾

3. **æ¨¡å¼åŒ¹é…**
   - âœ… match å¿…é¡»è¦†ç›–æ‰€æœ‰å¯èƒ½
   - âœ… if let å’Œ while let ç®€åŒ–åŒ¹é…
   - âœ… è§£æ„ã€å®ˆå«ã€@ ç»‘å®š

4. **æœ€ä½³å®è·µ**
   - âœ… æ´¾ç”Ÿå¸¸ç”¨ trait
   - âœ… ä½¿ç”¨ Box ä¼˜åŒ–å¤§æšä¸¾
   - âœ… ä½¿ç”¨ç±»å‹åˆ«åç®€åŒ–å¤æ‚ç±»å‹
   - âœ… ä¸ºå…¬å¼€APIå®ç° Display

### ä¸‹ä¸€æ­¥å­¦ä¹ 

å­¦å®Œæœ¬æŒ‡å—åï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **[2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](./03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)** - å­¦ä¹ æ³›å‹ç³»ç»Ÿ
2. **[2.4 Traitç³»ç»ŸæŒ‡å—](./04_Traitç³»ç»ŸæŒ‡å—.md)** - æŒæ¡ trait è®¾è®¡
3. **[2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](./05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)** - ç†è§£ç”Ÿå‘½å‘¨æœŸç®¡ç†
4. **[3.1 ç±»å‹è½¬æ¢å‚è€ƒ](../tier_03_references/01_ç±»å‹è½¬æ¢å‚è€ƒ.md)** - æ·±å…¥ç±»å‹è½¬æ¢

---

## 10. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Chapter 5 (Structs)](https://doc.rust-lang.org/book/ch05-00-structs.html)
- [Rust Book - Chapter 6 (Enums)](https://doc.rust-lang.org/book/ch06-00-enums.html)
- [Rust Reference - Types](https://doc.rust-lang.org/reference/types.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [1.0 é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [1.2 æœ¯è¯­è¡¨](../tier_01_foundations/03_æœ¯è¯­è¡¨.md)
- [1.3 å¸¸è§é—®é¢˜](../tier_01_foundations/04_å¸¸è§é—®é¢˜.md)

**æ·±åº¦åˆ†æ**:

- [ç±»å‹å®šä¹‰](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [ç±»å‹å˜ä½“](../tier_02_guides/02_å¤åˆç±»å‹æŒ‡å—.md)

---

**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
**æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚

---

**ğŸ‰ æ­å–œå®Œæˆå¤åˆç±»å‹æŒ‡å—å­¦ä¹ ï¼** ğŸ¦€

## å¤åˆç±»å‹é«˜çº§ä»£ç ç¤ºä¾‹è¡¥å……

## ğŸš€ é«˜çº§å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 5: JSONè§£æå™¨å®ç°

**å®Œæ•´çš„é€’å½’æšä¸¾åº”ç”¨**ï¼š

```rust
use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum JsonValue {
    Null,
    Boolean(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(HashMap<String, JsonValue>),
}

impl JsonValue {
    /// ç±»å‹åˆ¤æ–­è¾…åŠ©æ–¹æ³•
    pub fn is_null(&self) -> bool {
        matches!(self, JsonValue::Null)
    }

    pub fn is_object(&self) -> bool {
        matches!(self, JsonValue::Object(_))
    }

    pub fn is_array(&self) -> bool {
        matches!(self, JsonValue::Array(_))
    }

    /// è·¯å¾„è®¿é—®
    pub fn get(&self, path: &str) -> Option<&JsonValue> {
        let parts: Vec<&str> = path.split('.').collect();
        let mut current = self;

        for part in parts {
            match current {
                JsonValue::Object(map) => {
                    current = map.get(part)?;
                }
                JsonValue::Array(arr) => {
                    let index: usize = part.parse().ok()?;
                    current = arr.get(index)?;
                }
                _ => return None,
            }
        }

        Some(current)
    }

    /// é€’å½’è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    pub fn stringify(&self) -> String {
        match self {
            JsonValue::Null => "null".to_string(),
            JsonValue::Boolean(b) => b.to_string(),
            JsonValue::Number(n) => n.to_string(),
            JsonValue::String(s) => format!("\"{}\"", s),
            JsonValue::Array(arr) => {
                let items: Vec<String> = arr.iter().map(|v| v.stringify()).collect();
                format!("[{}]", items.join(", "))
            }
            JsonValue::Object(obj) => {
                let items: Vec<String> = obj
                    .iter()
                    .map(|(k, v)| format!("\"{}\": {}", k, v.stringify()))
                    .collect();
                format!("{{{}}}", items.join(", "))
            }
        }
    }
}

impl fmt::Display for JsonValue {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.stringify())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn json_example() {
    let mut user = HashMap::new();
    user.insert("name".to_string(), JsonValue::String("Alice".to_string()));
    user.insert("age".to_string(), JsonValue::Number(30.0));
    user.insert("active".to_string(), JsonValue::Boolean(true));

    let mut address = HashMap::new();
    address.insert("city".to_string(), JsonValue::String("Beijing".to_string()));
    address.insert("zip".to_string(), JsonValue::String("100000".to_string()));

    user.insert("address".to_string(), JsonValue::Object(address));

    let json = JsonValue::Object(user);

    // æ‰“å°
    println!("{}", json);

    // è·¯å¾„è®¿é—®
    if let Some(city) = json.get("address.city") {
        println!("City: {}", city);
    }
}
```

---

### æ¡ˆä¾‹ 6: çŠ¶æ€æœºï¼ˆæ¸¸æˆè§’è‰²ï¼‰

**ç±»å‹å®‰å…¨çš„çŠ¶æ€è½¬æ¢**ï¼š

```rust
// ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¡¨ç¤ºçŠ¶æ€
struct Idle;
struct Walking;
struct Running;
struct Jumping;

struct Character<State> {
    name: String,
    health: u32,
    position: (f32, f32),
    _state: std::marker::PhantomData<State>,
}

// é€šç”¨æ–¹æ³•ï¼ˆæ‰€æœ‰çŠ¶æ€å…±äº«ï¼‰
impl<State> Character<State> {
    fn name(&self) -> &str {
        &self.name
    }

    fn health(&self) -> u32 {
        self.health
    }

    fn take_damage(&mut self, damage: u32) {
        self.health = self.health.saturating_sub(damage);
    }
}

// Idle çŠ¶æ€ç‰¹å®šæ–¹æ³•
impl Character<Idle> {
    fn new(name: String) -> Self {
        Character {
            name,
            health: 100,
            position: (0.0, 0.0),
            _state: std::marker::PhantomData,
        }
    }

    fn start_walking(self) -> Character<Walking> {
        println!("{} starts walking", self.name);
        Character {
            name: self.name,
            health: self.health,
            position: self.position,
            _state: std::marker::PhantomData,
        }
    }

    fn jump(self) -> Character<Jumping> {
        println!("{} jumps from idle", self.name);
        Character {
            name: self.name,
            health: self.health,
            position: self.position,
            _state: std::marker::PhantomData,
        }
    }
}

// Walking çŠ¶æ€ç‰¹å®šæ–¹æ³•
impl Character<Walking> {
    fn walk(&mut self, dx: f32, dy: f32) {
        self.position.0 += dx;
        self.position.1 += dy;
        println!("{} walks to {:?}", self.name, self.position);
    }

    fn stop(self) -> Character<Idle> {
        println!("{} stops walking", self.name);
        Character {
            name: self.name,
            health: self.health,
            position: self.position,
            _state: std::marker::PhantomData,
        }
    }

    fn start_running(self) -> Character<Running> {
        println!("{} starts running", self.name);
        Character {
            name: self.name,
            health: self.health,
            position: self.position,
            _state: std::marker::PhantomData,
        }
    }
}

// Running çŠ¶æ€ç‰¹å®šæ–¹æ³•
impl Character<Running> {
    fn run(&mut self, dx: f32, dy: f32) {
        self.position.0 += dx * 2.0; // è·‘æ­¥é€Ÿåº¦æ˜¯èµ°è·¯çš„2å€
        self.position.1 += dy * 2.0;
        println!("{} runs to {:?}", self.name, self.position);
    }

    fn slow_down(self) -> Character<Walking> {
        println!("{} slows down", self.name);
        Character {
            name: self.name,
            health: self.health,
            position: self.position,
            _state: std::marker::PhantomData,
        }
    }
}

// Jumping çŠ¶æ€ç‰¹å®šæ–¹æ³•
impl Character<Jumping> {
    fn land(self) -> Character<Idle> {
        println!("{} lands", self.name);
        Character {
            name: self.name,
            health: self.health,
            position: self.position,
            _state: std::marker::PhantomData,
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šç¼–è¯‘æ—¶ä¿è¯çŠ¶æ€è½¬æ¢æ­£ç¡®
fn character_example() {
    let hero = Character::<Idle>::new("Hero".to_string());

    // ç¼–è¯‘é€šè¿‡ï¼šidle -> walking
    let mut hero = hero.start_walking();
    hero.walk(1.0, 0.0);

    // ç¼–è¯‘é€šè¿‡ï¼šwalking -> running
    let mut hero = hero.start_running();
    hero.run(2.0, 0.0);

    // ç¼–è¯‘é€šè¿‡ï¼šrunning -> walking -> idle
    let hero = hero.slow_down().stop();

    // ç¼–è¯‘é”™è¯¯ï¼šidle çŠ¶æ€ä¸èƒ½è°ƒç”¨ run()
    // hero.run(1.0, 0.0);

    println!("Final position: {:?}", hero.position);
}
```

---

### æ¡ˆä¾‹ 7: ç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ

**é›¶æˆæœ¬æŠ½è±¡çš„ç‰©ç†å•ä½**ï¼š

```rust
use std::ops::{Add, Sub, Mul, Div};
use std::marker::PhantomData;

// å•ä½ç±»å‹æ ‡è®°
struct Meters;
struct Seconds;
struct MetersPerSecond;

// å¸¦å•ä½çš„å€¼
#[derive(Debug, Clone, Copy)]
struct Quantity<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<Unit> Quantity<Unit> {
    fn new(value: f64) -> Self {
        Quantity {
            value,
            _unit: PhantomData,
        }
    }

    fn value(&self) -> f64 {
        self.value
    }
}

// ç›¸åŒå•ä½å¯ä»¥ç›¸åŠ 
impl<Unit> Add for Quantity<Unit> {
    type Output = Quantity<Unit>;

    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// ç›¸åŒå•ä½å¯ä»¥ç›¸å‡
impl<Unit> Sub for Quantity<Unit> {
    type Output = Quantity<Unit>;

    fn sub(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value - rhs.value)
    }
}

// è·ç¦» / æ—¶é—´ = é€Ÿåº¦
impl Div<Quantity<Seconds>> for Quantity<Meters> {
    type Output = Quantity<MetersPerSecond>;

    fn div(self, rhs: Quantity<Seconds>) -> Self::Output {
        Quantity::new(self.value / rhs.value)
    }
}

// é€Ÿåº¦ * æ—¶é—´ = è·ç¦»
impl Mul<Quantity<Seconds>> for Quantity<MetersPerSecond> {
    type Output = Quantity<Meters>;

    fn mul(self, rhs: Quantity<Seconds>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

// ä¾¿æ·æ„é€ å‡½æ•°
fn meters(value: f64) -> Quantity<Meters> {
    Quantity::new(value)
}

fn seconds(value: f64) -> Quantity<Seconds> {
    Quantity::new(value)
}

// ä½¿ç”¨ç¤ºä¾‹
fn physics_example() {
    let distance = meters(100.0);
    let time = seconds(10.0);

    // ç±»å‹å®‰å…¨ï¼šè®¡ç®—é€Ÿåº¦
    let speed = distance / time;
    println!("Speed: {} m/s", speed.value());

    // ç±»å‹å®‰å…¨ï¼šè®¡ç®—æ–°è·ç¦»
    let new_time = seconds(5.0);
    let new_distance = speed * new_time;
    println!("New distance: {} m", new_distance.value());

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½å°†è·ç¦»å’Œæ—¶é—´ç›¸åŠ 
    // let wrong = distance + time;

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½å°†é€Ÿåº¦å’Œè·ç¦»ç›¸ä¹˜
    // let wrong = speed * distance;
}
```

---

### æ¡ˆä¾‹ 8: æ„å»ºå™¨æ¨¡å¼ï¼ˆé«˜çº§ï¼‰

**æ”¯æŒå¤æ‚éªŒè¯å’Œé»˜è®¤å€¼**ï¼š

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
pub enum BuilderError {
    MissingField(&'static str),
    InvalidValue(String),
}

impl fmt::Display for BuilderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BuilderError::MissingField(field) => write!(f, "Missing required field: {}", field),
            BuilderError::InvalidValue(msg) => write!(f, "Invalid value: {}", msg),
        }
    }
}

impl Error for BuilderError {}

#[derive(Debug, Clone)]
pub struct DatabaseConfig {
    host: String,
    port: u16,
    database: String,
    username: String,
    password: String,
    pool_size: usize,
    timeout_seconds: u64,
    ssl_enabled: bool,
}

pub struct DatabaseConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    database: Option<String>,
    username: Option<String>,
    password: Option<String>,
    pool_size: Option<usize>,
    timeout_seconds: Option<u64>,
    ssl_enabled: Option<bool>,
}

impl DatabaseConfigBuilder {
    pub fn new() -> Self {
        Self {
            host: None,
            port: None,
            database: None,
            username: None,
            password: None,
            pool_size: None,
            timeout_seconds: None,
            ssl_enabled: None,
        }
    }

    pub fn host(mut self, host: impl Into<String>) -> Self {
        self.host = Some(host.into());
        self
    }

    pub fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    pub fn database(mut self, database: impl Into<String>) -> Self {
        self.database = Some(database.into());
        self
    }

    pub fn username(mut self, username: impl Into<String>) -> Self {
        self.username = Some(username.into());
        self
    }

    pub fn password(mut self, password: impl Into<String>) -> Self {
        self.password = Some(password.into());
        self
    }

    pub fn pool_size(mut self, size: usize) -> Self {
        self.pool_size = Some(size);
        self
    }

    pub fn timeout_seconds(mut self, seconds: u64) -> Self {
        self.timeout_seconds = Some(seconds);
        self
    }

    pub fn ssl_enabled(mut self, enabled: bool) -> Self {
        self.ssl_enabled = Some(enabled);
        self
    }

    pub fn build(self) -> Result<DatabaseConfig, BuilderError> {
        // éªŒè¯å¿…å¡«å­—æ®µ
        let host = self.host
            .ok_or(BuilderError::MissingField("host"))?;

        let database = self.database
            .ok_or(BuilderError::MissingField("database"))?;

        let username = self.username
            .ok_or(BuilderError::MissingField("username"))?;

        let password = self.password
            .ok_or(BuilderError::MissingField("password"))?;

        // æä¾›é»˜è®¤å€¼
        let port = self.port.unwrap_or(5432);
        let pool_size = self.pool_size.unwrap_or(10);
        let timeout_seconds = self.timeout_seconds.unwrap_or(30);
        let ssl_enabled = self.ssl_enabled.unwrap_or(false);

        // éªŒè¯å€¼çš„æœ‰æ•ˆæ€§
        if port == 0 {
            return Err(BuilderError::InvalidValue("Port cannot be 0".to_string()));
        }

        if pool_size == 0 || pool_size > 1000 {
            return Err(BuilderError::InvalidValue(
                "Pool size must be between 1 and 1000".to_string()
            ));
        }

        Ok(DatabaseConfig {
            host,
            port,
            database,
            username,
            password,
            pool_size,
            timeout_seconds,
            ssl_enabled,
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn builder_example() -> Result<(), BuilderError> {
    let config = DatabaseConfigBuilder::new()
        .host("localhost")
        .database("mydb")
        .username("admin")
        .password("secret")
        .pool_size(20)
        .ssl_enabled(true)
        .build()?;

    println!("Config: {:?}", config);

    // ç¼ºå°‘å¿…å¡«å­—æ®µä¼šç¼–è¯‘é€šè¿‡ä½†è¿è¡Œæ—¶æŠ¥é”™
    let result = DatabaseConfigBuilder::new()
        .host("localhost")
        .build();

    match result {
        Ok(_) => println!("Unexpected success"),
        Err(e) => println!("Expected error: {}", e),
    }

    Ok(())
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–è¿›é˜¶

### å†…å­˜å¸ƒå±€ä¼˜åŒ–å®ä¾‹

```rust
use std::mem;

// âŒ å†…å­˜å¸ƒå±€ä¸ä½³
#[derive(Debug)]
struct BadLayout {
    flag: bool,      // 1 byte
    // padding: 7 bytes (å¯¹é½åˆ°u64)
    number: u64,     // 8 bytes
    small: u8,       // 1 byte
    // padding: 7 bytes
}

// âœ… ä¼˜åŒ–çš„å†…å­˜å¸ƒå±€
#[derive(Debug)]
struct GoodLayout {
    number: u64,     // 8 bytes
    flag: bool,      // 1 byte
    small: u8,       // 1 byte
    // padding: 6 bytes
}

// ä½¿ç”¨ repr(C) æ§åˆ¶å¸ƒå±€
#[repr(C)]
struct CLayout {
    number: u64,
    flag: bool,
    small: u8,
}

// repr(packed) å»é™¤paddingï¼ˆæ…ç”¨ï¼‰
#[repr(packed)]
struct PackedLayout {
    flag: bool,
    number: u64,
    small: u8,
}

fn layout_example() {
    println!("BadLayout size: {} bytes", mem::size_of::<BadLayout>());
    println!("GoodLayout size: {} bytes", mem::size_of::<GoodLayout>());
    println!("CLayout size: {} bytes", mem::size_of::<CLayout>());
    println!("PackedLayout size: {} bytes", mem::size_of::<PackedLayout>());

    // å…¸å‹è¾“å‡ºï¼š
    // BadLayout size: 24 bytes  (æµªè´¹!)
    // GoodLayout size: 16 bytes
    // CLayout size: 16 bytes
    // PackedLayout size: 10 bytes (ä½†è®¿é—®é€Ÿåº¦å¯èƒ½å˜æ…¢)
}
```

---

### æšä¸¾åˆ¤åˆ«å¼ä¼˜åŒ–

```rust
// ä½¿ç”¨å°çš„åˆ¤åˆ«å¼ç±»å‹
#[repr(u8)]  // åªä½¿ç”¨1å­—èŠ‚ä½œä¸ºåˆ¤åˆ«å€¼
enum Status {
    Pending = 0,
    InProgress = 1,
    Completed = 2,
    Failed = 3,
}

// æ˜¾å¼æŒ‡å®šåˆ¤åˆ«å€¼
#[repr(u16)]
enum ErrorCode {
    NetworkError = 1000,
    DatabaseError = 2000,
    AuthError = 3000,
}

impl ErrorCode {
    fn as_u16(&self) -> u16 {
        *self as u16
    }

    fn from_u16(value: u16) -> Option<Self> {
        match value {
            1000 => Some(ErrorCode::NetworkError),
            2000 => Some(ErrorCode::DatabaseError),
            3000 => Some(ErrorCode::AuthError),
            _ => None,
        }
    }
}

fn discriminant_example() {
    use std::mem;

    let status = Status::Completed;
    println!("Status size: {} bytes", mem::size_of_val(&status));

    let code = ErrorCode::DatabaseError;
    println!("Error code: {}", code.as_u16());
}
```

---

## ğŸ”¥ é«˜çº§æ¨¡å¼åŒ¹é…æŠ€å·§

### åŒ¹é…å¤šä¸ªæ¨¡å¼

```rust
enum Message {
    Text(String),
    Image(String, Vec<u8>),
    Video(String, Vec<u8>, u32),
}

fn process_media(msg: Message) {
    match msg {
        // åŒ¹é…å¤šä¸ªæ¨¡å¼
        Message::Image(name, _) | Message::Video(name, _, _) => {
            println!("Processing media: {}", name);
        }
        Message::Text(content) => {
            println!("Processing text: {}", content);
        }
    }
}
```

---

### èŒƒå›´æ¨¡å¼

```rust
fn classify_age(age: u32) -> &'static str {
    match age {
        0..=12 => "Child",
        13..=19 => "Teenager",
        20..=64 => "Adult",
        65.. => "Senior",
    }
}

fn classify_char(c: char) -> &'static str {
    match c {
        'a'..='z' => "lowercase",
        'A'..='Z' => "uppercase",
        '0'..='9' => "digit",
        _ => "other",
    }
}
```

---

### åµŒå¥—åŒ¹é…ä¸è§£æ„

```rust
enum Response {
    Success(Result<String, String>),
    Redirect(String),
    Error(u16, String),
}

fn handle_response(response: Response) {
    match response {
        // åµŒå¥—åŒ¹é…
        Response::Success(Ok(data)) => {
            println!("Success with data: {}", data);
        }
        Response::Success(Err(reason)) => {
            println!("Success but error: {}", reason);
        }
        Response::Redirect(url) => {
            println!("Redirect to: {}", url);
        }
        // å®ˆå« + è§£æ„
        Response::Error(code, msg) if code >= 500 => {
            println!("Server error {}: {}", code, msg);
        }
        Response::Error(code, msg) => {
            println!("Client error {}: {}", code, msg);
        }
    }
}
```

---

## ğŸ¯ å®æˆ˜ç»ƒä¹ é¢˜

### ç»ƒä¹  1: å®ç°å‘½ä»¤è¡Œå‚æ•°è§£æå™¨

```rust
#[derive(Debug)]
enum Arg {
    Flag(String),
    Option(String, String),
    Positional(String),
}

struct ArgParser {
    args: Vec<Arg>,
}

impl ArgParser {
    fn parse(input: &[String]) -> Self {
        let mut args = Vec::new();
        let mut iter = input.iter();

        while let Some(arg) = iter.next() {
            if arg.starts_with("--") {
                let name = arg[2..].to_string();
                if let Some(value) = iter.next() {
                    args.push(Arg::Option(name, value.clone()));
                } else {
                    args.push(Arg::Flag(name));
                }
            } else if arg.starts_with("-") {
                args.push(Arg::Flag(arg[1..].to_string()));
            } else {
                args.push(Arg::Positional(arg.clone()));
            }
        }

        ArgParser { args }
    }

    fn get_flag(&self, name: &str) -> bool {
        self.args.iter().any(|arg| match arg {
            Arg::Flag(flag_name) => flag_name == name,
            _ => false,
        })
    }

    fn get_option(&self, name: &str) -> Option<&str> {
        self.args.iter().find_map(|arg| match arg {
            Arg::Option(opt_name, value) if opt_name == name => Some(value.as_str()),
            _ => None,
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn parser_example() {
    let args = vec![
        "--verbose".to_string(),
        "--output".to_string(),
        "file.txt".to_string(),
        "-h".to_string(),
        "input.txt".to_string(),
    ];

    let parser = ArgParser::parse(&args);

    println!("Has verbose: {}", parser.get_flag("verbose"));
    println!("Has help: {}", parser.get_flag("h"));
    println!("Output: {:?}", parser.get_option("output"));
}
```

---

**æ›´æ–°æ—¥æœŸ**: 2025-10-24
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0
**ä½œè€…**: C02 Type System Code Examples Team
