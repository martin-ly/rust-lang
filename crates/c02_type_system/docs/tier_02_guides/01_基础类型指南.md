# 2.1 Rust 类型系统 - 基础类型指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统学习 Rust 基础类型系统  
> **适用对象**: 初学者 → 中级开发者  
> **预计学习时间**: 4-6 小时  
> **最后更新**: 2025-10-22

---


## 📋 目录

- [2.1 Rust 类型系统 - 基础类型指南](#21-rust-类型系统---基础类型指南)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [📊 章节概览](#-章节概览)
  - [1. 类型系统概述](#1-类型系统概述)
    - [1.1 什么是类型系统](#11-什么是类型系统)
    - [1.2 Rust 类型系统特点](#12-rust-类型系统特点)
    - [1.3 类型分类](#13-类型分类)
  - [2. 标量类型 (Scalar Types)](#2-标量类型-scalar-types)
    - [2.1 整数类型](#21-整数类型)
      - [基本整数类型](#基本整数类型)
      - [整数字面量](#整数字面量)
      - [整数溢出](#整数溢出)
      - [最佳实践](#最佳实践)
    - [2.2 浮点数类型](#22-浮点数类型)
      - [基本浮点数类型](#基本浮点数类型)
      - [浮点数精度](#浮点数精度)
      - [特殊值](#特殊值)
      - [最佳实践2](#最佳实践2)
    - [2.3 布尔类型](#23-布尔类型)
      - [基本用法](#基本用法)
      - [布尔运算](#布尔运算)
      - [类型大小](#类型大小)
    - [2.4 字符类型](#24-字符类型)
      - [基本用法2](#基本用法2)
      - [Unicode 支持](#unicode-支持)
      - [常见陷阱](#常见陷阱)
  - [3. 复合类型 (Compound Types)](#3-复合类型-compound-types)
    - [3.1 元组类型](#31-元组类型)
      - [基本用法3](#基本用法3)
      - [解构](#解构)
      - [单元类型](#单元类型)
    - [3.2 数组类型](#32-数组类型)
      - [基本用法32](#基本用法32)
      - [数组操作](#数组操作)
      - [多维数组](#多维数组)
  - [4. 字符串类型](#4-字符串类型)
    - [4.1 字符串切片 (\&str)](#41-字符串切片-str)
      - [基本概念](#基本概念)
      - [字符串字面量](#字符串字面量)
      - [切片操作](#切片操作)
    - [4.2 String 类型](#42-string-类型)
      - [创建 String](#创建-string)
      - [修改 String](#修改-string)
      - [String vs \&str](#string-vs-str)
  - [5. 引用类型](#5-引用类型)
    - [5.1 不可变引用 (\&T)](#51-不可变引用-t)
      - [基本用法51](#基本用法51)
      - [借用规则](#借用规则)
    - [5.2 可变引用 (\&mut T)](#52-可变引用-mut-t)
      - [基本用法52](#基本用法52)
      - [可变性规则](#可变性规则)
    - [5.3 引用的生命周期](#53-引用的生命周期)
  - [6. 智能指针类型](#6-智能指针类型)
    - [6.1 `Box<T>`](#61-boxt)
      - [堆分配](#堆分配)
      - [递归类型](#递归类型)
    - [6.2 `Rc<T> 和 Arc<T>`](#62-rct-和-arct)
      - [引用计数](#引用计数)
      - [多线程共享](#多线程共享)
  - [7. 切片类型](#7-切片类型)
    - [7.1 数组切片](#71-数组切片)
    - [7.2 字符串切片](#72-字符串切片)
  - [8. 指针类型](#8-指针类型)
    - [8.1 原始指针](#81-原始指针)
    - [8.2 函数指针](#82-函数指针)
  - [9. Never 类型 (!)](#9-never-类型-)
    - [9.1 基本概念](#91-基本概念)
    - [9.2 实际应用](#92-实际应用)
  - [10. 类型推导与类型标注](#10-类型推导与类型标注)
    - [10.1 类型推导](#101-类型推导)
    - [10.2 显式类型标注](#102-显式类型标注)
    - [10.3 Turbofish 语法](#103-turbofish-语法)
  - [11. 类型别名](#11-类型别名)
    - [11.1 基本用法](#111-基本用法)
    - [11.2 泛型类型别名](#112-泛型类型别名)
  - [12. 类型大小与内存布局](#12-类型大小与内存布局)
    - [12.1 类型大小](#121-类型大小)
    - [12.2 零大小类型 (ZST)](#122-零大小类型-zst)
    - [12.3 内存对齐](#123-内存对齐)
  - [13. 实战案例](#13-实战案例)
    - [案例 1: 温度转换器](#案例-1-温度转换器)
    - [案例 2: 简单计算器](#案例-2-简单计算器)
    - [案例 3: 字符串处理](#案例-3-字符串处理)
  - [14. 常见陷阱与最佳实践](#14-常见陷阱与最佳实践)
    - [14.1 常见陷阱](#141-常见陷阱)
    - [14.2 最佳实践](#142-最佳实践)
    - [14.6 实战案例：高性能数据处理](#146-实战案例高性能数据处理)
  - [15. 总结](#15-总结)
    - [核心要点](#核心要点)
    - [下一步学习](#下一步学习)
  - [16. 参考资源](#16-参考资源)

---

## 🎯 学习目标

完成本指南后，您将能够：

- ✅ **理解** Rust 的基础类型系统
- ✅ **掌握** 标量类型（整数、浮点数、布尔、字符）
- ✅ **掌握** 复合类型（元组、数组）
- ✅ **理解** 字符串类型（&str 和 String）
- ✅ **理解** 引用类型和智能指针
- ✅ **应用** 类型推导和类型标注
- ✅ **了解** 类型大小和内存布局
- ✅ **编写** 类型安全的 Rust 程序

---

## 📊 章节概览

| 章节 | 内容 | 难度 | 预计时间 |
|------|------|------|---------|
| 1. 类型系统概述 | 类型系统基本概念 | 🟢 简单 | 20分钟 |
| 2. 标量类型 | 整数、浮点数、布尔、字符 | 🟢 简单 | 40分钟 |
| 3. 复合类型 | 元组、数组 | 🟢 简单 | 30分钟 |
| 4. 字符串类型 | &str 和 String | 🟡 中等 | 40分钟 |
| 5. 引用类型 | 不可变和可变引用 | 🟡 中等 | 40分钟 |
| 6. 智能指针 | Box, Rc, Arc | 🟡 中等 | 30分钟 |
| 7. 切片类型 | 数组切片、字符串切片 | 🟡 中等 | 20分钟 |
| 8. 指针类型 | 原始指针、函数指针 | 🔴 高级 | 20分钟 |
| 9. Never 类型 | ! 类型 | 🟡 中等 | 15分钟 |
| 10. 类型推导 | 类型推导与标注 | 🟢 简单 | 20分钟 |
| 11. 类型别名 | type 关键字 | 🟢 简单 | 15分钟 |
| 12. 内存布局 | 类型大小、对齐 | 🔴 高级 | 30分钟 |
| 13. 实战案例 | 综合应用 | 🟡 中等 | 40分钟 |
| 14. 最佳实践 | 陷阱与实践 | 🟡 中等 | 20分钟 |

**总计**: 约 5-6 小时

---

## 1. 类型系统概述

### 1.1 什么是类型系统

**类型系统** 是编程语言用来对值进行分类的系统，它定义了：

- 📝 值的种类（整数、字符串、布尔等）
- 🔒 对值可以执行的操作
- 🚫 不允许的操作（类型安全）

**类型系统的作用**:

1. **编译期检查** - 在编译时发现类型错误
2. **内存安全** - 防止无效的内存访问
3. **代码清晰** - 类型信息作为文档
4. **性能优化** - 编译器可以基于类型信息优化

### 1.2 Rust 类型系统特点

Rust 采用 **强静态类型系统**：

**强类型** (Strong Typing):

- ❌ 不允许隐式类型转换
- ✅ 必须显式转换类型
- ✅ 防止类型错误

**静态类型** (Static Typing):

- ✅ 编译时确定所有类型
- ✅ 运行时无类型检查开销
- ✅ 零成本抽象

**核心特点**:

```rust
// 1. 静态类型 - 编译时确定
let x: i32 = 5;
let y: f64 = 3.14;

// 2. 强类型 - 不允许隐式转换
// let z = x + y; // 编译错误！类型不匹配

// 3. 类型推导 - 编译器可以推导类型
let a = 5;      // 推导为 i32
let b = 3.14;   // 推导为 f64

// 4. 类型安全 - 防止类型错误
let s = String::from("hello");
// let len = s + 5; // 编译错误！不能将 String 和 i32 相加
```

### 1.3 类型分类

Rust 的类型可以分为以下几类：

```text
Rust 类型系统
├── 标量类型 (Scalar Types)
│   ├── 整数 (i8, i16, i32, i64, i128, isize)
│   ├── 无符号整数 (u8, u16, u32, u64, u128, usize)
│   ├── 浮点数 (f32, f64)
│   ├── 布尔 (bool)
│   └── 字符 (char)
│
├── 复合类型 (Compound Types)
│   ├── 元组 (tuple)
│   ├── 数组 (array)
│   ├── 结构体 (struct)
│   └── 枚举 (enum)
│
├── 字符串类型
│   ├── 字符串切片 (&str)
│   └── String
│
├── 引用类型
│   ├── 不可变引用 (&T)
│   └── 可变引用 (&mut T)
│
├── 智能指针
│   ├── Box<T>
│   ├── Rc<T>
│   ├── Arc<T>
│   └── RefCell<T>
│
├── 切片类型
│   ├── 数组切片 (&[T])
│   └── 字符串切片 (&str)
│
└── 其他类型
    ├── 指针 (*const T, *mut T)
    ├── 函数指针 (fn)
    ├── Never 类型 (!)
    └── 单元类型 (())
```

---

## 2. 标量类型 (Scalar Types)

标量类型表示单个值。Rust 有四种主要的标量类型：

### 2.1 整数类型

#### 基本整数类型

Rust 提供了多种大小的有符号和无符号整数：

| 长度 | 有符号 | 无符号 | 范围 (有符号) | 范围 (无符号) |
|------|-------|--------|--------------|--------------|
| 8-bit | `i8` | `u8` | -128 ~ 127 | 0 ~ 255 |
| 16-bit | `i16` | `u16` | -32,768 ~ 32,767 | 0 ~ 65,535 |
| 32-bit | `i32` | `u32` | -2³¹ ~ 2³¹-1 | 0 ~ 2³²-1 |
| 64-bit | `i64` | `u64` | -2⁶³ ~ 2⁶³-1 | 0 ~ 2⁶⁴-1 |
| 128-bit | `i128` | `u128` | -2¹²⁷ ~ 2¹²⁷-1 | 0 ~ 2¹²⁸-1 |
| arch | `isize` | `usize` | 依赖架构 | 依赖架构 |

**示例**:

```rust
fn main() {
    // 有符号整数
    let x: i8 = -128;
    let y: i32 = 42;        // i32 是默认整数类型
    let z: i64 = 1_000_000;  // 使用下划线提高可读性
    
    // 无符号整数
    let a: u8 = 255;
    let b: u32 = 100;
    let c: u64 = 18_446_744_073_709_551_615u64;
    
    // 架构相关
    let size: usize = 8;    // 64位系统上是 u64，32位系统上是 u32
    let index: isize = -5;
    
    println!("x = {}, y = {}, z = {}", x, y, z);
    println!("a = {}, b = {}, c = {}", a, b, c);
    println!("size = {}, index = {}", size, index);
}
```

#### 整数字面量

Rust 支持多种整数字面量格式：

```rust
fn main() {
    // 十进制
    let decimal = 98_222;
    
    // 十六进制
    let hex = 0xff;
    
    // 八进制
    let octal = 0o77;
    
    // 二进制
    let binary = 0b1111_0000;
    
    // 字节 (仅限 u8)
    let byte = b'A';
    
    // 带类型后缀
    let typed = 42u8;
    let large = 1000i64;
    
    println!("decimal: {}", decimal);
    println!("hex: {}, octal: {}, binary: {}", hex, octal, binary);
    println!("byte: {}, typed: {}, large: {}", byte, typed, large);
}
```

#### 整数溢出

整数溢出行为：

```rust
fn main() {
    // Debug 模式：溢出会 panic
    // Release 模式：溢出会回绕 (wrapping)
    
    // 显式处理溢出
    let mut x: u8 = 255;
    
    // 1. wrapping 方法 - 回绕
    x = x.wrapping_add(1); // 0
    println!("wrapping: {}", x);
    
    // 2. checked 方法 - 返回 Option
    let y: u8 = 255;
    match y.checked_add(1) {
        Some(v) => println!("checked: {}", v),
        None => println!("overflow!"),
    }
    
    // 3. overflowing 方法 - 返回值和溢出标志
    let (result, overflowed) = y.overflowing_add(1);
    println!("result: {}, overflowed: {}", result, overflowed);
    
    // 4. saturating 方法 - 饱和到最大/最小值
    let z = y.saturating_add(1);
    println!("saturating: {}", z); // 255
}
```

#### 最佳实践

```rust
fn main() {
    // ✅ 使用 i32 作为默认整数类型
    let count = 42;
    
    // ✅ 使用 usize 作为索引和长度
    let vec = vec![1, 2, 3];
    let len: usize = vec.len();
    
    // ✅ 选择合适的大小
    let age: u8 = 25;          // 0-255 足够
    let population: u64 = 7_800_000_000;  // 需要大范围
    
    // ✅ 使用下划线提高可读性
    let million = 1_000_000;
    
    // ✅ 显式处理溢出
    let result = 255u8.checked_add(1);
    
    println!("count: {}, len: {}, age: {}", count, len, age);
    println!("population: {}, million: {}", population, million);
}
```

### 2.2 浮点数类型

#### 基本浮点数类型

Rust 有两种浮点数类型：

| 类型 | 精度 | 范围 | 默认 |
|------|------|------|------|
| `f32` | 单精度 (32位) | ±1.18 × 10⁻³⁸ ~ ±3.4 × 10³⁸ | - |
| `f64` | 双精度 (64位) | ±2.23 × 10⁻³⁰⁸ ~ ±1.8 × 10³⁰⁸ | ✅ |

**示例**:

```rust
fn main() {
    // f64 是默认类型
    let x = 2.0;        // f64
    let y: f32 = 3.0;   // f32
    
    // 科学计数法
    let large = 1.23e10;   // 1.23 × 10¹⁰
    let small = 4.56e-8;   // 4.56 × 10⁻⁸
    
    // 基本运算
    let sum = x + y as f64;
    let difference = x - 1.0;
    let product = x * 2.0;
    let quotient = x / 0.5;
    
    println!("x: {}, y: {}", x, y);
    println!("large: {}, small: {}", large, small);
    println!("sum: {}, product: {}", sum, product);
}
```

#### 浮点数精度

```rust
fn main() {
    // 浮点数精度问题
    let x = 0.1 + 0.2;
    println!("0.1 + 0.2 = {}", x); // 0.30000000000000004
    
    // 比较浮点数
    let a = 0.1 + 0.2;
    let b = 0.3;
    
    // ❌ 不要直接比较
    // if a == b { ... }
    
    // ✅ 使用 epsilon 比较
    let epsilon = 1e-10;
    if (a - b).abs() < epsilon {
        println!("a and b are approximately equal");
    }
    
    // ✅ 使用第三方库 (如 approx)
    // assert_relative_eq!(a, b, epsilon = 1e-10);
}
```

#### 特殊值

```rust
fn main() {
    // 特殊浮点数值
    let inf = f64::INFINITY;
    let neg_inf = f64::NEG_INFINITY;
    let nan = f64::NAN;
    
    println!("inf: {}, neg_inf: {}, nan: {}", inf, neg_inf, nan);
    
    // 检查特殊值
    println!("inf is infinite: {}", inf.is_infinite());
    println!("nan is nan: {}", nan.is_nan());
    println!("1.0 is finite: {}", 1.0f64.is_finite());
    
    // NaN 的特殊性
    println!("nan == nan: {}", nan == nan); // false!
    println!("nan != nan: {}", nan != nan); // true!
}
```

#### 最佳实践2

```rust
fn main() {
    // ✅ 使用 f64 作为默认浮点数类型
    let pi = 3.14159265359;
    
    // ✅ 不要直接比较浮点数
    let epsilon = 1e-10;
    let a = 0.1 + 0.2;
    let b = 0.3;
    assert!((a - b).abs() < epsilon);
    
    // ✅ 检查特殊值
    let result = some_calculation();
    if result.is_finite() {
        println!("result: {}", result);
    } else {
        println!("result is not finite!");
    }
    
    // ✅ 使用精确的整数运算代替浮点数
    // ❌ let cents = 0.1 + 0.2;  // 浮点数误差
    // ✅ let cents = 10 + 20;     // 整数精确
}

fn some_calculation() -> f64 {
    42.0
}
```

### 2.3 布尔类型

#### 基本用法

布尔类型只有两个值：`true` 和 `false`

```rust
fn main() {
    // 布尔值
    let t = true;
    let f: bool = false;
    
    // 条件表达式
    if t {
        println!("t is true");
    }
    
    // 比较运算
    let is_greater = 5 > 3;
    let is_equal = 10 == 10;
    println!("is_greater: {}, is_equal: {}", is_greater, is_equal);
}
```

#### 布尔运算

```rust
fn main() {
    let a = true;
    let b = false;
    
    // 逻辑运算
    println!("a && b: {}", a && b); // false (与)
    println!("a || b: {}", a || b); // true (或)
    println!("!a: {}", !a);         // false (非)
    
    // 短路求值
    let result = a || expensive_operation();
    // expensive_operation() 不会被调用，因为 a 已经是 true
    
    // 布尔运算优先级
    let complex = true || false && false; // true || (false && false)
    println!("complex: {}", complex); // true
}

fn expensive_operation() -> bool {
    println!("expensive operation called");
    true
}
```

#### 类型大小

```rust
fn main() {
    use std::mem;
    
    // 布尔类型占用 1 字节
    println!("size of bool: {} byte", mem::size_of::<bool>());
    
    // 尽管只需要 1 bit，但为了内存对齐，占用 1 byte
    let b = true;
    println!("b: {}", b);
}
```

### 2.4 字符类型

#### 基本用法2

Rust 的 `char` 类型表示单个 Unicode 标量值：

```rust
fn main() {
    // 字符字面量使用单引号
    let c = 'z';
    let z: char = 'ℤ';
    let heart_eyed_cat = '😻';
    
    println!("c: {}, z: {}, cat: {}", c, z, heart_eyed_cat);
    
    // char 占用 4 字节 (32 位)
    use std::mem;
    println!("size of char: {} bytes", mem::size_of::<char>());
}
```

#### Unicode 支持

```rust
fn main() {
    // ASCII 字符
    let ascii = 'A';
    
    // Unicode 字符
    let chinese = '中';
    let emoji = '😀';
    
    // Unicode 转义
    let unicode_char = '\u{1F60A}'; // 😊
    
    // 字符转换
    let code = unicode_char as u32;
    println!("unicode code point: U+{:X}", code);
    
    // 从代码点创建字符
    if let Some(ch) = char::from_u32(0x1F60A) {
        println!("char from code point: {}", ch);
    }
    
    println!("ascii: {}, chinese: {}, emoji: {}", ascii, chinese, emoji);
}
```

#### 常见陷阱

```rust
fn main() {
    // ❌ 字符不是字符串
    // let s = 'hello'; // 编译错误！单引号用于字符
    let s = "hello";    // ✅ 双引号用于字符串
    
    // ❌ 字符不能为空
    // let empty = ''; // 编译错误！
    
    // ✅ 字符方法
    let c = 'A';
    println!("is alphabetic: {}", c.is_alphabetic());
    println!("is numeric: {}", c.is_numeric());
    println!("to lowercase: {}", c.to_lowercase());
    
    // ✅ 字符串是字符的集合
    let hello = "Hello";
    for c in hello.chars() {
        println!("{}", c);
    }
}
```

---

## 3. 复合类型 (Compound Types)

复合类型可以将多个值组合成一个类型。

### 3.1 元组类型

#### 基本用法3

元组可以将多个不同类型的值组合在一起：

```rust
fn main() {
    // 创建元组
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    
    // 访问元组元素
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;
    
    println!("tup: ({}, {}, {})", five_hundred, six_point_four, one);
    
    // 类型推导
    let tup2 = (1, 2.0, 'a');
    println!("tup2: ({}, {}, {})", tup2.0, tup2.1, tup2.2);
}
```

#### 解构

```rust
fn main() {
    let tup = (500, 6.4, 1);
    
    // 解构元组
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);
    
    // 部分解构
    let (a, _, c) = tup; // 忽略第二个元素
    println!("a: {}, c: {}", a, c);
    
    // 函数返回元组
    let (min, max) = find_min_max(&[1, 5, 3, 9, 2]);
    println!("min: {}, max: {}", min, max);
}

fn find_min_max(numbers: &[i32]) -> (i32, i32) {
    let min = *numbers.iter().min().unwrap();
    let max = *numbers.iter().max().unwrap();
    (min, max)
}
```

#### 单元类型

```rust
fn main() {
    // 单元类型 () 是空元组
    let unit: () = ();
    
    // 不返回值的函数返回单元类型
    let result = println!("Hello"); // result 是 ()
    
    // 显式返回单元类型
    fn do_nothing() -> () {
        // 或 fn do_nothing() { ... }
    }
    
    println!("unit: {:?}", unit);
}
```

### 3.2 数组类型

#### 基本用法32

数组是固定长度的相同类型元素的集合：

```rust
fn main() {
    // 创建数组
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5]; // 显式类型和长度
    
    // 初始化相同值
    let c = [3; 5]; // [3, 3, 3, 3, 3]
    
    // 访问数组元素
    let first = a[0];
    let second = a[1];
    
    println!("a: {:?}", a);
    println!("first: {}, second: {}", first, second);
    
    // 数组长度
    println!("length of a: {}", a.len());
}
```

#### 数组操作

```rust
fn main() {
    let mut arr = [1, 2, 3, 4, 5];
    
    // 修改元素
    arr[0] = 10;
    println!("arr: {:?}", arr);
    
    // 迭代
    for element in arr.iter() {
        println!("{}", element);
    }
    
    // 带索引迭代
    for (index, &value) in arr.iter().enumerate() {
        println!("arr[{}] = {}", index, value);
    }
    
    // 切片
    let slice = &arr[1..4]; // [2, 3, 4]
    println!("slice: {:?}", slice);
}
```

#### 多维数组

```rust
fn main() {
    // 二维数组
    let matrix: [[i32; 3]; 2] = [
        [1, 2, 3],
        [4, 5, 6],
    ];
    
    // 访问元素
    println!("matrix[0][1]: {}", matrix[0][1]); // 2
    
    // 遍历二维数组
    for row in matrix.iter() {
        for &col in row.iter() {
            print!("{} ", col);
        }
        println!();
    }
}
```

---

## 4. 字符串类型

Rust 有两种主要的字符串类型：`String` 和 `&str`

### 4.1 字符串切片 (&str)

#### 基本概念

`&str` 是字符串切片的引用，是不可变的：

```rust
fn main() {
    // 字符串字面量是 &str 类型
    let s: &str = "Hello, world!";
    
    // 字符串切片
    let hello = &s[0..5];   // "Hello"
    let world = &s[7..12];  // "world"
    
    println!("s: {}", s);
    println!("hello: {}, world: {}", hello, world);
}
```

#### 字符串字面量

```rust
fn main() {
    // 字符串字面量存储在二进制文件中
    let s1 = "Hello";
    let s2 = "Hello";
    
    // 字符串字面量的生命周期是 'static
    let s3: &'static str = "Hello, static!";
    
    // 原始字符串字面量 (不转义)
    let raw = r"C:\Users\Name\file.txt";
    let multi_line = r#"
        This is a
        multi-line
        string
    "#;
    
    println!("s1: {}, s2: {}", s1, s2);
    println!("raw: {}", raw);
    println!("multi_line: {}", multi_line);
}
```

#### 切片操作

```rust
fn main() {
    let s = String::from("hello world");
    
    // 切片语法
    let hello = &s[0..5];    // "hello"
    let world = &s[6..11];   // "world"
    
    // 省略起始索引
    let hello2 = &s[..5];    // "hello"
    
    // 省略结束索引
    let world2 = &s[6..];    // "world"
    
    // 完整切片
    let full = &s[..];       // "hello world"
    
    println!("hello: {}, world: {}", hello, world);
    println!("hello2: {}, world2: {}", hello2, world2);
    println!("full: {}", full);
    
    // ⚠️ 注意：切片索引必须位于字符边界
    let chinese = String::from("中国");
    // let invalid = &chinese[0..1]; // panic! 不是有效的字符边界
    let valid = &chinese[0..3];     // "中" (UTF-8 中一个汉字占 3 字节)
    println!("valid: {}", valid);
}
```

### 4.2 String 类型

#### 创建 String

```rust
fn main() {
    // 从字符串字面量创建
    let s1 = String::from("Hello");
    let s2 = "World".to_string();
    
    // 创建空字符串
    let mut s3 = String::new();
    
    // 预分配容量
    let mut s4 = String::with_capacity(10);
    
    println!("s1: {}, s2: {}", s1, s2);
    println!("s3: '{}', s4: '{}'", s3, s4);
}
```

#### 修改 String

```rust
fn main() {
    let mut s = String::from("Hello");
    
    // 追加字符串
    s.push_str(", world");
    println!("after push_str: {}", s);
    
    // 追加字符
    s.push('!');
    println!("after push: {}", s);
    
    // 插入字符串
    s.insert_str(5, " Rust");
    println!("after insert_str: {}", s);
    
    // 插入字符
    s.insert(0, '#');
    println!("after insert: {}", s);
    
    // 替换
    let new_s = s.replace("Rust", "World");
    println!("after replace: {}", new_s);
    
    // 清空
    s.clear();
    println!("after clear: '{}'", s);
}
```

#### String vs &str

```rust
fn main() {
    // String: 拥有所有权，可变，堆分配
    let mut s1 = String::from("Hello");
    s1.push_str(", world");
    
    // &str: 借用，不可变，可能在栈或堆
    let s2: &str = "Hello";
    // s2.push_str(", world"); // 编译错误！&str 不可变
    
    // String -> &str (Deref coercion)
    let s3 = String::from("Hello");
    let s4: &str = &s3; // 自动转换
    
    // &str -> String
    let s5: &str = "Hello";
    let s6 = s5.to_string();
    let s7 = String::from(s5);
    
    println!("s1: {}, s2: {}", s1, s2);
    println!("s3: {}, s4: {}", s3, s4);
    println!("s5: {}, s6: {}, s7: {}", s5, s6, s7);
    
    // 函数参数通常使用 &str (更通用)
    print_str("Hello");
    print_str(&String::from("World"));
}

fn print_str(s: &str) {
    println!("{}", s);
}
```

---

## 5. 引用类型

引用允许您引用某个值而不获取其所有权。

### 5.1 不可变引用 (&T)

#### 基本用法51

```rust
fn main() {
    let s1 = String::from("Hello");
    
    // 创建不可变引用
    let len = calculate_length(&s1);
    
    println!("The length of '{}' is {}.", s1, len);
    // s1 仍然有效，因为我们只是借用了它
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s 离开作用域，但因为它只是引用，所以不会释放内存
```

#### 借用规则

```rust
fn main() {
    let s = String::from("Hello");
    
    // 可以同时有多个不可变引用
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;
    
    println!("r1: {}, r2: {}, r3: {}", r1, r2, r3);
    // 所有引用都有效
}
```

### 5.2 可变引用 (&mut T)

#### 基本用法52

```rust
fn main() {
    let mut s = String::from("Hello");
    
    // 创建可变引用
    change(&mut s);
    
    println!("s: {}", s); // "Hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

#### 可变性规则

```rust
fn main() {
    let mut s = String::from("Hello");
    
    // ✅ 可以有一个可变引用
    let r1 = &mut s;
    r1.push_str(", world");
    println!("r1: {}", r1);
    
    // ❌ 不能同时有两个可变引用
    // let r1 = &mut s;
    // let r2 = &mut s; // 编译错误！
    // println!("{}, {}", r1, r2);
    
    // ❌ 不能同时有可变和不可变引用
    let r2 = &s;
    // let r3 = &mut s; // 编译错误！
    // println!("{}, {}", r2, r3);
    
    // ✅ 引用的作用域在最后一次使用后结束
    let r4 = &s;
    let r5 = &s;
    println!("{} {}", r4, r5);
    // r4 和 r5 的作用域在这里结束
    
    let r6 = &mut s; // ✅ 现在可以创建可变引用了
    r6.push_str("!");
}
```

### 5.3 引用的生命周期

```rust
fn main() {
    // 生命周期确保引用总是有效的
    let r;
    {
        let x = 5;
        // r = &x; // 编译错误！x 的生命周期不够长
    }
    // println!("r: {}", r);
    
    // ✅ 正确的用法
    let x = 5;
    let r = &x;
    println!("r: {}", r);
}
```

---

## 6. 智能指针类型

智能指针是具有额外功能的指针。

### 6.1 `Box<T>`

#### 堆分配

```rust
fn main() {
    // 在堆上分配值
    let b = Box::new(5);
    println!("b = {}", b);
    
    // 大型数据结构
    let large_data = Box::new([0; 1000]);
    println!("large data allocated on heap");
}
```

#### 递归类型

```rust
// 使用 Box 定义递归类型
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    print_list(&list);
}

fn print_list(list: &List) {
    match list {
        Cons(value, next) => {
            print!("{} -> ", value);
            print_list(next);
        }
        Nil => println!("Nil"),
    }
}
```

### 6.2 `Rc<T> 和 Arc<T>`

#### 引用计数

```rust
use std::rc::Rc;

fn main() {
    // Rc: 引用计数智能指针 (单线程)
    let a = Rc::new(5);
    println!("count after creating a: {}", Rc::strong_count(&a));
    
    let b = Rc::clone(&a);
    println!("count after creating b: {}", Rc::strong_count(&a));
    
    {
        let c = Rc::clone(&a);
        println!("count after creating c: {}", Rc::strong_count(&a));
    }
    
    println!("count after c goes out of scope: {}", Rc::strong_count(&a));
}
```

#### 多线程共享

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    // Arc: 原子引用计数 (多线程安全)
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("thread {}: {:?}", i, data);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 7. 切片类型

切片是对数组或字符串的引用。

### 7.1 数组切片

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    
    // 创建切片
    let slice = &a[1..4]; // [2, 3, 4]
    println!("slice: {:?}", slice);
    
    // 传递切片给函数
    let sum = sum_slice(slice);
    println!("sum: {}", sum);
}

fn sum_slice(slice: &[i32]) -> i32 {
    slice.iter().sum()
}
```

### 7.2 字符串切片

```rust
fn main() {
    let s = String::from("hello world");
    
    let hello = &s[0..5];
    let world = &s[6..11];
    
    println!("hello: {}, world: {}", hello, world);
    
    // 获取第一个单词
    let word = first_word(&s);
    println!("first word: {}", word);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}
```

---

## 8. 指针类型

### 8.1 原始指针

```rust
fn main() {
    let mut num = 5;
    
    // 创建原始指针
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    
    unsafe {
        println!("r1 points to: {}", *r1);
        println!("r2 points to: {}", *r2);
        
        // 修改值
        *r2 = 10;
        println!("num is now: {}", num);
    }
}
```

### 8.2 函数指针

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);
    println!("The answer is: {}", answer); // 12
}
```

---

## 9. Never 类型 (!)

### 9.1 基本概念

```rust
fn main() {
    // ! 类型表示永不返回
    // fn exit() -> ! {
    //     std::process::exit(0);
    // }
    
    // 可以用在 match 中
    let guess: u32 = match "42".parse() {
        Ok(num) => num,
        Err(_) => panic!("Not a number!"), // panic! 返回 !
    };
    
    println!("guess: {}", guess);
}
```

### 9.2 实际应用

```rust
fn main() {
    loop {
        // loop 表达式的类型是 !
        // continue 和 break 也是 !
        break;
    }
}
```

---

## 10. 类型推导与类型标注

### 10.1 类型推导

```rust
fn main() {
    // 编译器可以推导类型
    let x = 5;          // i32
    let y = 3.14;       // f64
    let z = true;       // bool
    let c = 'a';        // char
    
    // 从上下文推导
    let mut vec = Vec::new();
    vec.push(1); // 现在编译器知道 vec 是 Vec<i32>
    
    println!("x: {}, y: {}, z: {}, c: {}", x, y, z, c);
}
```

### 10.2 显式类型标注

```rust
fn main() {
    // 显式标注类型
    let x: i32 = 5;
    let y: f64 = 3.14;
    
    // 需要显式标注的情况
    let numbers: Vec<i32> = Vec::new();
    
    // 类型标注在变量名后
    let guess: u32 = "42".parse().expect("Not a number!");
    
    println!("x: {}, y: {}, guess: {}", x, y, guess);
}
```

### 10.3 Turbofish 语法

```rust
fn main() {
    // 使用 turbofish 语法指定类型参数
    let numbers = vec![1, 2, 3];
    
    // 指定 collect 的目标类型
    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();
    
    // 使用 turbofish
    let doubled2 = numbers.iter().map(|x| x * 2).collect::<Vec<i32>>();
    
    println!("doubled: {:?}", doubled);
    println!("doubled2: {:?}", doubled2);
    
    // 解析字符串
    let num = "42".parse::<i32>().unwrap();
    println!("num: {}", num);
}
```

---

## 11. 类型别名

### 11.1 基本用法

```rust
fn main() {
    // 创建类型别名
    type Kilometers = i32;
    
    let x: i32 = 5;
    let y: Kilometers = 5;
    
    // 类型别名不是新类型，只是别名
    println!("x + y = {}", x + y); // ✅ 可以相加
}
```

### 11.2 泛型类型别名

```rust
fn main() {
    // 简化复杂类型
    type Result<T> = std::result::Result<T, std::io::Error>;
    
    // 使用别名
    fn read_file() -> Result<String> {
        Ok(String::from("file contents"))
    }
    
    match read_file() {
        Ok(content) => println!("content: {}", content),
        Err(e) => println!("error: {}", e),
    }
}
```

---

## 12. 类型大小与内存布局

### 12.1 类型大小

```rust
fn main() {
    use std::mem;
    
    // 查询类型大小
    println!("size of i8: {} byte", mem::size_of::<i8>());
    println!("size of i32: {} bytes", mem::size_of::<i32>());
    println!("size of i64: {} bytes", mem::size_of::<i64>());
    println!("size of f64: {} bytes", mem::size_of::<f64>());
    println!("size of bool: {} byte", mem::size_of::<bool>());
    println!("size of char: {} bytes", mem::size_of::<char>());
    
    // 引用和指针
    println!("size of &i32: {} bytes", mem::size_of::<&i32>());
    println!("size of Box<i32>: {} bytes", mem::size_of::<Box<i32>>());
    
    // 复合类型
    println!("size of (i32, i32): {} bytes", mem::size_of::<(i32, i32)>());
    println!("size of [i32; 5]: {} bytes", mem::size_of::<[i32; 5]>());
}
```

### 12.2 零大小类型 (ZST)

```rust
fn main() {
    use std::mem;
    
    // 单元类型是 ZST
    println!("size of (): {} bytes", mem::size_of::<()>());
    
    // 空结构体是 ZST
    struct Empty;
    println!("size of Empty: {} bytes", mem::size_of::<Empty>());
    
    // PhantomData 是 ZST
    use std::marker::PhantomData;
    println!("size of PhantomData<i32>: {} bytes", mem::size_of::<PhantomData<i32>>());
}
```

### 12.3 内存对齐

```rust
fn main() {
    use std::mem;
    
    // 结构体的内存对齐
    #[repr(C)]
    struct A {
        a: u8,   // 1 byte
        b: u32,  // 4 bytes
        c: u16,  // 2 bytes
    }
    
    println!("size of A: {} bytes", mem::size_of::<A>());
    println!("align of A: {} bytes", mem::align_of::<A>());
    
    // 优化内存布局
    #[repr(C)]
    struct B {
        b: u32,  // 4 bytes
        c: u16,  // 2 bytes
        a: u8,   // 1 byte
    }
    
    println!("size of B: {} bytes", mem::size_of::<B>());
}
```

---

## 13. 实战案例

### 案例 1: 温度转换器

```rust
fn main() {
    // 摄氏度转华氏度
    let celsius = 25.0;
    let fahrenheit = celsius_to_fahrenheit(celsius);
    println!("{}°C = {}°F", celsius, fahrenheit);
    
    // 华氏度转摄氏度
    let fahr = 77.0;
    let cel = fahrenheit_to_celsius(fahr);
    println!("{}°F = {}°C", fahr, cel);
}

fn celsius_to_fahrenheit(celsius: f64) -> f64 {
    (celsius * 9.0 / 5.0) + 32.0
}

fn fahrenheit_to_celsius(fahrenheit: f64) -> f64 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}
```

### 案例 2: 简单计算器

```rust
fn main() {
    println!("10 + 5 = {}", calculate(10.0, 5.0, '+'));
    println!("10 - 5 = {}", calculate(10.0, 5.0, '-'));
    println!("10 * 5 = {}", calculate(10.0, 5.0, '*'));
    println!("10 / 5 = {}", calculate(10.0, 5.0, '/'));
}

fn calculate(a: f64, b: f64, operator: char) -> f64 {
    match operator {
        '+' => a + b,
        '-' => a - b,
        '*' => a * b,
        '/' => a / b,
        _ => {
            println!("Unknown operator: {}", operator);
            0.0
        }
    }
}
```

### 案例 3: 字符串处理

```rust
fn main() {
    let text = "Hello, Rust! Welcome to type system learning.";
    
    // 统计单词
    let word_count = count_words(text);
    println!("Word count: {}", word_count);
    
    // 统计字符
    let char_count = text.chars().count();
    println!("Character count: {}", char_count);
    
    // 转换为大写
    let uppercase = text.to_uppercase();
    println!("Uppercase: {}", uppercase);
}

fn count_words(text: &str) -> usize {
    text.split_whitespace().count()
}
```

---

## 14. 常见陷阱与最佳实践

### 14.1 常见陷阱

```rust
fn main() {
    // ❌ 陷阱 1: 整数溢出
    // let x: u8 = 256; // 编译错误！
    
    // ✅ 使用 checked 方法
    let y: u8 = 255;
    if let Some(result) = y.checked_add(1) {
        println!("result: {}", result);
    } else {
        println!("overflow!");
    }
    
    // ❌ 陷阱 2: 浮点数比较
    let a = 0.1 + 0.2;
    // if a == 0.3 { } // 可能失败！
    
    // ✅ 使用 epsilon 比较
    let epsilon = 1e-10;
    if (a - 0.3).abs() < epsilon {
        println!("approximately equal");
    }
    
    // ❌ 陷阱 3: 字符串切片边界
    let s = String::from("中国");
    // let invalid = &s[0..1]; // panic! 不是字符边界
    let valid = &s[0..3];     // ✅ 完整的 UTF-8 字符
    println!("valid: {}", valid);
}
```

### 14.2 最佳实践

```rust
fn main() {
    // ✅ 1. 使用类型推导
    let x = 42;                    // 而不是 let x: i32 = 42;
    
    // ✅ 2. 使用 &str 作为参数
    fn print_str(s: &str) {
        println!("{}", s);
    }
    
    // ✅ 3. 使用 usize 作为索引
    let vec = vec![1, 2, 3];
    let len: usize = vec.len();
    
    // ✅ 4. 预分配容量
    let mut vec = Vec::with_capacity(100);
    
    // ✅ 5. 使用迭代器而不是索引
    for item in vec.iter() {
        // ...
    }
}
```

### 14.6 实战案例：高性能数据处理

**案例：优化大规模数值计算**:

```rust
use std::time::Instant;

// ❌ 非优化版本
fn process_data_slow(data: &[f64]) -> f64 {
    let mut result = 0.0;
    for i in 0..data.len() {
        result += data[i] * 2.0;  // 索引访问有边界检查
    }
    result
}

// ✅ 优化版本
fn process_data_fast(data: &[f64]) -> f64 {
    data.iter()                    // 迭代器，无边界检查
        .map(|&x| x * 2.0)         // 编译器优化SIMD
        .sum()                     // 聚合操作
}

fn main() {
    let data: Vec<f64> = (0..1_000_000).map(|x| x as f64).collect();
    
    let start = Instant::now();
    let result1 = process_data_slow(&data);
    println!("Slow: {:?}, result: {}", start.elapsed(), result1);
    
    let start = Instant::now();
    let result2 = process_data_fast(&data);
    println!("Fast: {:?}, result: {}", start.elapsed(), result2);
}
// 输出示例：
// Slow: 3.2ms
// Fast: 1.1ms  (3x faster!)
```

---

## 15. 总结

### 核心要点

1. **类型系统**
   - ✅ Rust 采用强静态类型系统
   - ✅ 编译时确定所有类型
   - ✅ 类型推导减少冗余标注

2. **标量类型**
   - ✅ 整数 (i8-i128, u8-u128, isize, usize)
   - ✅ 浮点数 (f32, f64)
   - ✅ 布尔 (bool)
   - ✅ 字符 (char)

3. **复合类型**
   - ✅ 元组 - 组合不同类型
   - ✅ 数组 - 固定长度相同类型

4. **字符串类型**
   - ✅ &str - 字符串切片，不可变
   - ✅ String - 可变字符串，堆分配

5. **引用和智能指针**
   - ✅ &T - 不可变引用
   - ✅ &mut T - 可变引用
   - ✅ `Box<T>` - 堆分配
   - ✅ `Rc<T>/Arc<T>` - 引用计数

### 下一步学习

学完本指南后，建议继续学习：

1. **[2.2 复合类型指南](./02_复合类型指南.md)** - 深入学习结构体和枚举
2. **[2.3 泛型编程指南](./03_泛型编程指南.md)** - 学习泛型系统
3. **[2.4 Trait系统指南](./04_Trait系统指南.md)** - 掌握 trait 设计
4. **[2.5 生命周期指南](./05_生命周期指南.md)** - 理解生命周期管理

---

## 16. 参考资源

**官方文档**:

- [Rust Book - Chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html)
- [Rust Reference - Types](https://doc.rust-lang.org/reference/types.html)
- [Std Library - Primitive Types](https://doc.rust-lang.org/std/#primitives)

**相关文档**:

- [1.0 项目概览](../tier_01_foundations/01_项目概览.md)
- [1.1 主索引导航](../tier_01_foundations/02_主索引导航.md)
- [1.2 术语表](../tier_01_foundations/03_术语表.md)
- [1.3 常见问题](../tier_01_foundations/04_常见问题.md)

**深度分析**:

- [类型定义](../02_core/01_type_definition.md)
- [类型变体](../02_core/02_type_variants.md)
- [类型转换](../02_core/03_type_conversion.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 2 - 指南层

---

**🎉 恭喜完成基础类型指南学习！** 🦀
