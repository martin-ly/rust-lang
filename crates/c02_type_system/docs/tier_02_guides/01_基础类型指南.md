# 2.1 Rust ç±»å‹ç³»ç»Ÿ - åŸºç¡€ç±»å‹æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚
> **æ–‡æ¡£å®šä½**: ç³»ç»Ÿå­¦ä¹  Rust åŸºç¡€ç±»å‹ç³»ç»Ÿ
> **é€‚ç”¨å¯¹è±¡**: åˆå­¦è€… â†’ ä¸­çº§å¼€å‘è€…
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 4-6 å°æ—¶
> **æœ€åæ›´æ–°**: 2025-12-11

---

## ğŸ“‹ ç›®å½•

- [2.1 Rust ç±»å‹ç³»ç»Ÿ - åŸºç¡€ç±»å‹æŒ‡å—](#21-rust-ç±»å‹ç³»ç»Ÿ---åŸºç¡€ç±»å‹æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“Š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. ç±»å‹ç³»ç»Ÿæ¦‚è¿°](#1-ç±»å‹ç³»ç»Ÿæ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯ç±»å‹ç³»ç»Ÿ](#11-ä»€ä¹ˆæ˜¯ç±»å‹ç³»ç»Ÿ)
    - [1.2 Rust ç±»å‹ç³»ç»Ÿç‰¹ç‚¹](#12-rust-ç±»å‹ç³»ç»Ÿç‰¹ç‚¹)
    - [1.3 ç±»å‹åˆ†ç±»](#13-ç±»å‹åˆ†ç±»)
  - [2. æ ‡é‡ç±»å‹ (Scalar Types)](#2-æ ‡é‡ç±»å‹-scalar-types)
    - [2.1 æ•´æ•°ç±»å‹](#21-æ•´æ•°ç±»å‹)
      - [åŸºæœ¬æ•´æ•°ç±»å‹](#åŸºæœ¬æ•´æ•°ç±»å‹)
      - [æ•´æ•°å­—é¢é‡](#æ•´æ•°å­—é¢é‡)
      - [æ•´æ•°æº¢å‡º](#æ•´æ•°æº¢å‡º)
      - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [2.2 æµ®ç‚¹æ•°ç±»å‹](#22-æµ®ç‚¹æ•°ç±»å‹)
      - [åŸºæœ¬æµ®ç‚¹æ•°ç±»å‹](#åŸºæœ¬æµ®ç‚¹æ•°ç±»å‹)
      - [æµ®ç‚¹æ•°ç²¾åº¦](#æµ®ç‚¹æ•°ç²¾åº¦)
      - [ç‰¹æ®Šå€¼](#ç‰¹æ®Šå€¼)
      - [æœ€ä½³å®è·µ2](#æœ€ä½³å®è·µ2)
    - [2.3 å¸ƒå°”ç±»å‹](#23-å¸ƒå°”ç±»å‹)
      - [åŸºæœ¬ç”¨æ³•](#åŸºæœ¬ç”¨æ³•)
      - [å¸ƒå°”è¿ç®—](#å¸ƒå°”è¿ç®—)
      - [ç±»å‹å¤§å°](#ç±»å‹å¤§å°)
    - [2.4 å­—ç¬¦ç±»å‹](#24-å­—ç¬¦ç±»å‹)
      - [åŸºæœ¬ç”¨æ³•2](#åŸºæœ¬ç”¨æ³•2)
      - [Unicode æ”¯æŒ](#unicode-æ”¯æŒ)
      - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
  - [3. å¤åˆç±»å‹ (Compound Types)](#3-å¤åˆç±»å‹-compound-types)
    - [3.1 å…ƒç»„ç±»å‹](#31-å…ƒç»„ç±»å‹)
      - [åŸºæœ¬ç”¨æ³•3](#åŸºæœ¬ç”¨æ³•3)
      - [è§£æ„](#è§£æ„)
      - [å•å…ƒç±»å‹](#å•å…ƒç±»å‹)
    - [3.2 æ•°ç»„ç±»å‹](#32-æ•°ç»„ç±»å‹)
      - [åŸºæœ¬ç”¨æ³•32](#åŸºæœ¬ç”¨æ³•32)
      - [æ•°ç»„æ“ä½œ](#æ•°ç»„æ“ä½œ)
      - [å¤šç»´æ•°ç»„](#å¤šç»´æ•°ç»„)
  - [4. å­—ç¬¦ä¸²ç±»å‹](#4-å­—ç¬¦ä¸²ç±»å‹)
    - [4.1 å­—ç¬¦ä¸²åˆ‡ç‰‡ (\&str)](#41-å­—ç¬¦ä¸²åˆ‡ç‰‡-str)
      - [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
      - [å­—ç¬¦ä¸²å­—é¢é‡](#å­—ç¬¦ä¸²å­—é¢é‡)
      - [åˆ‡ç‰‡æ“ä½œ](#åˆ‡ç‰‡æ“ä½œ)
    - [4.2 String ç±»å‹](#42-string-ç±»å‹)
      - [åˆ›å»º String](#åˆ›å»º-string)
      - [ä¿®æ”¹ String](#ä¿®æ”¹-string)
      - [String vs \&str](#string-vs-str)
  - [5. å¼•ç”¨ç±»å‹](#5-å¼•ç”¨ç±»å‹)
    - [5.1 ä¸å¯å˜å¼•ç”¨ (\&T)](#51-ä¸å¯å˜å¼•ç”¨-t)
      - [åŸºæœ¬ç”¨æ³•51](#åŸºæœ¬ç”¨æ³•51)
      - [å€Ÿç”¨è§„åˆ™](#å€Ÿç”¨è§„åˆ™)
    - [5.2 å¯å˜å¼•ç”¨ (\&mut T)](#52-å¯å˜å¼•ç”¨-mut-t)
      - [åŸºæœ¬ç”¨æ³•52](#åŸºæœ¬ç”¨æ³•52)
      - [å¯å˜æ€§è§„åˆ™](#å¯å˜æ€§è§„åˆ™)
    - [5.3 å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ](#53-å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ)
  - [6. æ™ºèƒ½æŒ‡é’ˆç±»å‹](#6-æ™ºèƒ½æŒ‡é’ˆç±»å‹)
    - [6.1 `Box<T>`](#61-boxt)
      - [å †åˆ†é…](#å †åˆ†é…)
      - [é€’å½’ç±»å‹](#é€’å½’ç±»å‹)
    - [6.2 `Rc<T> å’Œ Arc<T>`](#62-rct-å’Œ-arct)
      - [å¼•ç”¨è®¡æ•°](#å¼•ç”¨è®¡æ•°)
      - [å¤šçº¿ç¨‹å…±äº«](#å¤šçº¿ç¨‹å…±äº«)
  - [7. åˆ‡ç‰‡ç±»å‹](#7-åˆ‡ç‰‡ç±»å‹)
    - [7.1 æ•°ç»„åˆ‡ç‰‡](#71-æ•°ç»„åˆ‡ç‰‡)
    - [7.2 å­—ç¬¦ä¸²åˆ‡ç‰‡](#72-å­—ç¬¦ä¸²åˆ‡ç‰‡)
  - [8. æŒ‡é’ˆç±»å‹](#8-æŒ‡é’ˆç±»å‹)
    - [8.1 åŸå§‹æŒ‡é’ˆ](#81-åŸå§‹æŒ‡é’ˆ)
    - [8.2 å‡½æ•°æŒ‡é’ˆ](#82-å‡½æ•°æŒ‡é’ˆ)
  - [9. Never ç±»å‹ (!)](#9-never-ç±»å‹-)
    - [9.1 åŸºæœ¬æ¦‚å¿µ](#91-åŸºæœ¬æ¦‚å¿µ)
    - [9.2 å®é™…åº”ç”¨](#92-å®é™…åº”ç”¨)
  - [10. ç±»å‹æ¨å¯¼ä¸ç±»å‹æ ‡æ³¨](#10-ç±»å‹æ¨å¯¼ä¸ç±»å‹æ ‡æ³¨)
    - [10.1 ç±»å‹æ¨å¯¼](#101-ç±»å‹æ¨å¯¼)
    - [10.2 æ˜¾å¼ç±»å‹æ ‡æ³¨](#102-æ˜¾å¼ç±»å‹æ ‡æ³¨)
    - [10.3 Turbofish è¯­æ³•](#103-turbofish-è¯­æ³•)
  - [11. ç±»å‹åˆ«å](#11-ç±»å‹åˆ«å)
    - [11.1 åŸºæœ¬ç”¨æ³•](#111-åŸºæœ¬ç”¨æ³•)
    - [11.2 æ³›å‹ç±»å‹åˆ«å](#112-æ³›å‹ç±»å‹åˆ«å)
  - [12. ç±»å‹å¤§å°ä¸å†…å­˜å¸ƒå±€](#12-ç±»å‹å¤§å°ä¸å†…å­˜å¸ƒå±€)
    - [12.1 ç±»å‹å¤§å°](#121-ç±»å‹å¤§å°)
    - [12.2 é›¶å¤§å°ç±»å‹ (ZST)](#122-é›¶å¤§å°ç±»å‹-zst)
    - [12.3 å†…å­˜å¯¹é½](#123-å†…å­˜å¯¹é½)
  - [13. å®æˆ˜æ¡ˆä¾‹](#13-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: æ¸©åº¦è½¬æ¢å™¨](#æ¡ˆä¾‹-1-æ¸©åº¦è½¬æ¢å™¨)
    - [æ¡ˆä¾‹ 2: ç®€å•è®¡ç®—å™¨](#æ¡ˆä¾‹-2-ç®€å•è®¡ç®—å™¨)
    - [æ¡ˆä¾‹ 3: å­—ç¬¦ä¸²å¤„ç†](#æ¡ˆä¾‹-3-å­—ç¬¦ä¸²å¤„ç†)
  - [14. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#14-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [14.1 å¸¸è§é™·é˜±](#141-å¸¸è§é™·é˜±)
    - [14.2 æœ€ä½³å®è·µ](#142-æœ€ä½³å®è·µ)
    - [14.6 å®æˆ˜æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½æ•°æ®å¤„ç†](#146-å®æˆ˜æ¡ˆä¾‹é«˜æ€§èƒ½æ•°æ®å¤„ç†)
  - [15. æ€»ç»“](#15-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )
  - [16. å‚è€ƒèµ„æº](#16-å‚è€ƒèµ„æº)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… **ç†è§£** Rust çš„åŸºç¡€ç±»å‹ç³»ç»Ÿ
- âœ… **æŒæ¡** æ ‡é‡ç±»å‹ï¼ˆæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”ã€å­—ç¬¦ï¼‰
- âœ… **æŒæ¡** å¤åˆç±»å‹ï¼ˆå…ƒç»„ã€æ•°ç»„ï¼‰
- âœ… **ç†è§£** å­—ç¬¦ä¸²ç±»å‹ï¼ˆ&str å’Œ Stringï¼‰
- âœ… **ç†è§£** å¼•ç”¨ç±»å‹å’Œæ™ºèƒ½æŒ‡é’ˆ
- âœ… **åº”ç”¨** ç±»å‹æ¨å¯¼å’Œç±»å‹æ ‡æ³¨
- âœ… **äº†è§£** ç±»å‹å¤§å°å’Œå†…å­˜å¸ƒå±€
- âœ… **ç¼–å†™** ç±»å‹å®‰å…¨çš„ Rust ç¨‹åº

---

## ğŸ“Š ç« èŠ‚æ¦‚è§ˆ

| ç« èŠ‚            | å†…å®¹                     | éš¾åº¦    | é¢„è®¡æ—¶é—´ |
| :--- | :--- | :--- | :--- || 1. ç±»å‹ç³»ç»Ÿæ¦‚è¿° | ç±»å‹ç³»ç»ŸåŸºæœ¬æ¦‚å¿µ         | ğŸŸ¢ ç®€å• | 20åˆ†é’Ÿ   |
| 2. æ ‡é‡ç±»å‹     | æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”ã€å­—ç¬¦ | ğŸŸ¢ ç®€å• | 40åˆ†é’Ÿ   |
| 3. å¤åˆç±»å‹     | å…ƒç»„ã€æ•°ç»„               | ğŸŸ¢ ç®€å• | 30åˆ†é’Ÿ   |
| 4. å­—ç¬¦ä¸²ç±»å‹   | &str å’Œ String           | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ   |
| 5. å¼•ç”¨ç±»å‹     | ä¸å¯å˜å’Œå¯å˜å¼•ç”¨         | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ   |
| 6. æ™ºèƒ½æŒ‡é’ˆ     | Box, Rc, Arc             | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ   |
| 7. åˆ‡ç‰‡ç±»å‹     | æ•°ç»„åˆ‡ç‰‡ã€å­—ç¬¦ä¸²åˆ‡ç‰‡     | ğŸŸ¡ ä¸­ç­‰ | 20åˆ†é’Ÿ   |
| 8. æŒ‡é’ˆç±»å‹     | åŸå§‹æŒ‡é’ˆã€å‡½æ•°æŒ‡é’ˆ       | ğŸ”´ é«˜çº§ | 20åˆ†é’Ÿ   |
| 9. Never ç±»å‹   | ! ç±»å‹                   | ğŸŸ¡ ä¸­ç­‰ | 15åˆ†é’Ÿ   |
| 10. ç±»å‹æ¨å¯¼    | ç±»å‹æ¨å¯¼ä¸æ ‡æ³¨           | ğŸŸ¢ ç®€å• | 20åˆ†é’Ÿ   |
| 11. ç±»å‹åˆ«å    | type å…³é”®å­—              | ğŸŸ¢ ç®€å• | 15åˆ†é’Ÿ   |
| 12. å†…å­˜å¸ƒå±€    | ç±»å‹å¤§å°ã€å¯¹é½           | ğŸ”´ é«˜çº§ | 30åˆ†é’Ÿ   |
| 13. å®æˆ˜æ¡ˆä¾‹    | ç»¼åˆåº”ç”¨                 | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ   |
| 14. æœ€ä½³å®è·µ    | é™·é˜±ä¸å®è·µ               | ğŸŸ¡ ä¸­ç­‰ | 20åˆ†é’Ÿ   |

**æ€»è®¡**: çº¦ 5-6 å°æ—¶

---

## 1. ç±»å‹ç³»ç»Ÿæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯ç±»å‹ç³»ç»Ÿ

**ç±»å‹ç³»ç»Ÿ** æ˜¯ç¼–ç¨‹è¯­è¨€ç”¨æ¥å¯¹å€¼è¿›è¡Œåˆ†ç±»çš„ç³»ç»Ÿï¼Œå®ƒå®šä¹‰äº†ï¼š

- ğŸ“ å€¼çš„ç§ç±»ï¼ˆæ•´æ•°ã€å­—ç¬¦ä¸²ã€å¸ƒå°”ç­‰ï¼‰
- ğŸ”’ å¯¹å€¼å¯ä»¥æ‰§è¡Œçš„æ“ä½œ
- ğŸš« ä¸å…è®¸çš„æ“ä½œï¼ˆç±»å‹å®‰å…¨ï¼‰

**ç±»å‹ç³»ç»Ÿçš„ä½œç”¨**ï¼ˆå¼•ç”¨ä¸€è‡´æ€§è§†è§’ï¼‰:

1. **ç¼–è¯‘æœŸæ£€æŸ¥** - åœ¨ç¼–è¯‘æ—¶å‘ç°ç±»å‹é”™è¯¯ï¼ˆç¼–è¯‘æœŸé€»è¾‘è¯æ˜ï¼‰
2. **èµ„æºå®‰å…¨** - é˜²æ­¢æ— æ•ˆçš„èµ„æºè®¿é—®ï¼ˆç¼–è¯‘æœŸé€»è¾‘è¯æ˜ï¼Œéå†…å­˜æ£€æŸ¥ï¼‰
3. **ä»£ç æ¸…æ™°** - ç±»å‹ä¿¡æ¯ä½œä¸ºæ–‡æ¡£ï¼ˆé€»è¾‘å…³ç³»çš„è¡¨è¾¾ï¼‰
4. **æ€§èƒ½ä¼˜åŒ–** - ç¼–è¯‘å™¨å¯ä»¥åŸºäºç±»å‹ä¿¡æ¯ä¼˜åŒ–ï¼ˆç¼–è¯‘æœŸè¯æ˜çš„æ•ˆç‡ï¼‰

### 1.2 Rust ç±»å‹ç³»ç»Ÿç‰¹ç‚¹

Rust é‡‡ç”¨ **å¼ºé™æ€ç±»å‹ç³»ç»Ÿ**ï¼š

**å¼ºç±»å‹** (Strong Typing):

- âŒ ä¸å…è®¸éšå¼ç±»å‹è½¬æ¢
- âœ… å¿…é¡»æ˜¾å¼è½¬æ¢ç±»å‹
- âœ… é˜²æ­¢ç±»å‹é”™è¯¯

**é™æ€ç±»å‹** (Static Typing):

- âœ… ç¼–è¯‘æ—¶ç¡®å®šæ‰€æœ‰ç±»å‹
- âœ… è¿è¡Œæ—¶æ— ç±»å‹æ£€æŸ¥å¼€é”€
- âœ… é›¶æˆæœ¬æŠ½è±¡

**æ ¸å¿ƒç‰¹ç‚¹**:

```rust
// 1. é™æ€ç±»å‹ - ç¼–è¯‘æ—¶ç¡®å®š
let x: i32 = 5;
let y: f64 = 3.14;

// 2. å¼ºç±»å‹ - ä¸å…è®¸éšå¼è½¬æ¢
// let z = x + y; // ç¼–è¯‘é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…

// 3. ç±»å‹æ¨å¯¼ - ç¼–è¯‘å™¨å¯ä»¥æ¨å¯¼ç±»å‹
let a = 5;      // æ¨å¯¼ä¸º i32
let b = 3.14;   // æ¨å¯¼ä¸º f64

// 4. ç±»å‹å®‰å…¨ - é˜²æ­¢ç±»å‹é”™è¯¯
let s = String::from("hello");
// let len = s + 5; // ç¼–è¯‘é”™è¯¯ï¼ä¸èƒ½å°† String å’Œ i32 ç›¸åŠ 
```

### 1.3 ç±»å‹åˆ†ç±»

Rust çš„ç±»å‹å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

```text
Rust ç±»å‹ç³»ç»Ÿ
â”œâ”€â”€ æ ‡é‡ç±»å‹ (Scalar Types)
â”‚   â”œâ”€â”€ æ•´æ•° (i8, i16, i32, i64, i128, isize)
â”‚   â”œâ”€â”€ æ— ç¬¦å·æ•´æ•° (u8, u16, u32, u64, u128, usize)
â”‚   â”œâ”€â”€ æµ®ç‚¹æ•° (f32, f64)
â”‚   â”œâ”€â”€ å¸ƒå°” (bool)
â”‚   â””â”€â”€ å­—ç¬¦ (char)
â”‚
â”œâ”€â”€ å¤åˆç±»å‹ (Compound Types)
â”‚   â”œâ”€â”€ å…ƒç»„ (tuple)
â”‚   â”œâ”€â”€ æ•°ç»„ (array)
â”‚   â”œâ”€â”€ ç»“æ„ä½“ (struct)
â”‚   â””â”€â”€ æšä¸¾ (enum)
â”‚
â”œâ”€â”€ å­—ç¬¦ä¸²ç±»å‹
â”‚   â”œâ”€â”€ å­—ç¬¦ä¸²åˆ‡ç‰‡ (&str)
â”‚   â””â”€â”€ String
â”‚
â”œâ”€â”€ å¼•ç”¨ç±»å‹
â”‚   â”œâ”€â”€ ä¸å¯å˜å¼•ç”¨ (&T)
â”‚   â””â”€â”€ å¯å˜å¼•ç”¨ (&mut T)
â”‚
â”œâ”€â”€ æ™ºèƒ½æŒ‡é’ˆ
â”‚   â”œâ”€â”€ Box<T>
â”‚   â”œâ”€â”€ Rc<T>
â”‚   â”œâ”€â”€ Arc<T>
â”‚   â””â”€â”€ RefCell<T>
â”‚
â”œâ”€â”€ åˆ‡ç‰‡ç±»å‹
â”‚   â”œâ”€â”€ æ•°ç»„åˆ‡ç‰‡ (&[T])
â”‚   â””â”€â”€ å­—ç¬¦ä¸²åˆ‡ç‰‡ (&str)
â”‚
â””â”€â”€ å…¶ä»–ç±»å‹
    â”œâ”€â”€ æŒ‡é’ˆ (*const T, *mut T)
    â”œâ”€â”€ å‡½æ•°æŒ‡é’ˆ (fn)
    â”œâ”€â”€ Never ç±»å‹ (!)
    â””â”€â”€ å•å…ƒç±»å‹ (())
```

---

## 2. æ ‡é‡ç±»å‹ (Scalar Types)

æ ‡é‡ç±»å‹è¡¨ç¤ºå•ä¸ªå€¼ã€‚Rust æœ‰å››ç§ä¸»è¦çš„æ ‡é‡ç±»å‹ï¼š

### 2.1 æ•´æ•°ç±»å‹

#### åŸºæœ¬æ•´æ•°ç±»å‹

Rust æä¾›äº†å¤šç§å¤§å°çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´æ•°ï¼š

| é•¿åº¦    | æœ‰ç¬¦å·  | æ— ç¬¦å·  | èŒƒå›´ (æœ‰ç¬¦å·)    | èŒƒå›´ (æ— ç¬¦å·) |
| :--- | :--- | :--- | :--- | :--- || 8-bit   | `i8`    | `u8`    | -128 ~ 127       | 0 ~ 255       |
| 16-bit  | `i16`   | `u16`   | -32,768 ~ 32,767 | 0 ~ 65,535    |
| 32-bit  | `i32`   | `u32`   | -2Â³Â¹ ~ 2Â³Â¹-1     | 0 ~ 2Â³Â²-1     |
| 64-bit  | `i64`   | `u64`   | -2â¶Â³ ~ 2â¶Â³-1     | 0 ~ 2â¶â´-1     |
| 128-bit | `i128`  | `u128`  | -2Â¹Â²â· ~ 2Â¹Â²â·-1   | 0 ~ 2Â¹Â²â¸-1    |
| arch    | `isize` | `usize` | ä¾èµ–æ¶æ„         | ä¾èµ–æ¶æ„      |

**ç¤ºä¾‹**:

```rust
fn main() {
    // æœ‰ç¬¦å·æ•´æ•°
    let x: i8 = -128;
    let y: i32 = 42;        // i32 æ˜¯é»˜è®¤æ•´æ•°ç±»å‹
    let z: i64 = 1_000_000;  // ä½¿ç”¨ä¸‹åˆ’çº¿æé«˜å¯è¯»æ€§

    // æ— ç¬¦å·æ•´æ•°
    let a: u8 = 255;
    let b: u32 = 100;
    let c: u64 = 18_446_744_073_709_551_615u64;

    // æ¶æ„ç›¸å…³
    let size: usize = 8;    // 64ä½ç³»ç»Ÿä¸Šæ˜¯ u64ï¼Œ32ä½ç³»ç»Ÿä¸Šæ˜¯ u32
    let index: isize = -5;

    println!("x = {}, y = {}, z = {}", x, y, z);
    println!("a = {}, b = {}, c = {}", a, b, c);
    println!("size = {}, index = {}", size, index);
}
```

#### æ•´æ•°å­—é¢é‡

Rust æ”¯æŒå¤šç§æ•´æ•°å­—é¢é‡æ ¼å¼ï¼š

```rust
fn main() {
    // åè¿›åˆ¶
    let decimal = 98_222;

    // åå…­è¿›åˆ¶
    let hex = 0xff;

    // å…«è¿›åˆ¶
    let octal = 0o77;

    // äºŒè¿›åˆ¶
    let binary = 0b1111_0000;

    // å­—èŠ‚ (ä»…é™ u8)
    let byte = b'A';

    // å¸¦ç±»å‹åç¼€
    let typed = 42u8;
    let large = 1000i64;

    println!("decimal: {}", decimal);
    println!("hex: {}, octal: {}, binary: {}", hex, octal, binary);
    println!("byte: {}, typed: {}, large: {}", byte, typed, large);
}
```

#### æ•´æ•°æº¢å‡º

æ•´æ•°æº¢å‡ºè¡Œä¸ºï¼š

```rust
fn main() {
    // Debug æ¨¡å¼ï¼šæº¢å‡ºä¼š panic
    // Release æ¨¡å¼ï¼šæº¢å‡ºä¼šå›ç»• (wrapping)

    // æ˜¾å¼å¤„ç†æº¢å‡º
    let mut x: u8 = 255;

    // 1. wrapping æ–¹æ³• - å›ç»•
    x = x.wrapping_add(1); // 0
    println!("wrapping: {}", x);

    // 2. checked æ–¹æ³• - è¿”å› Option
    let y: u8 = 255;
    match y.checked_add(1) {
        Some(v) => println!("checked: {}", v),
        None => println!("overflow!"),
    }

    // 3. overflowing æ–¹æ³• - è¿”å›å€¼å’Œæº¢å‡ºæ ‡å¿—
    let (result, overflowed) = y.overflowing_add(1);
    println!("result: {}, overflowed: {}", result, overflowed);

    // 4. saturating æ–¹æ³• - é¥±å’Œåˆ°æœ€å¤§/æœ€å°å€¼
    let z = y.saturating_add(1);
    println!("saturating: {}", z); // 255
}
```

#### æœ€ä½³å®è·µ

```rust
fn main() {
    // âœ… ä½¿ç”¨ i32 ä½œä¸ºé»˜è®¤æ•´æ•°ç±»å‹
    let count = 42;

    // âœ… ä½¿ç”¨ usize ä½œä¸ºç´¢å¼•å’Œé•¿åº¦
    let vec = vec![1, 2, 3];
    let len: usize = vec.len();

    // âœ… é€‰æ‹©åˆé€‚çš„å¤§å°
    let age: u8 = 25;          // 0-255 è¶³å¤Ÿ
    let population: u64 = 7_800_000_000;  // éœ€è¦å¤§èŒƒå›´

    // âœ… ä½¿ç”¨ä¸‹åˆ’çº¿æé«˜å¯è¯»æ€§
    let million = 1_000_000;

    // âœ… æ˜¾å¼å¤„ç†æº¢å‡º
    let result = 255u8.checked_add(1);

    println!("count: {}, len: {}, age: {}", count, len, age);
    println!("population: {}, million: {}", population, million);
}
```

### 2.2 æµ®ç‚¹æ•°ç±»å‹

#### åŸºæœ¬æµ®ç‚¹æ•°ç±»å‹

Rust æœ‰ä¸¤ç§æµ®ç‚¹æ•°ç±»å‹ï¼š

| ç±»å‹  | ç²¾åº¦          | èŒƒå›´                          | é»˜è®¤ |
| :--- | :--- | :--- | :--- || `f32` | å•ç²¾åº¦ (32ä½) | Â±1.18 Ã— 10â»Â³â¸ ~ Â±3.4 Ã— 10Â³â¸   | -    |
| `f64` | åŒç²¾åº¦ (64ä½) | Â±2.23 Ã— 10â»Â³â°â¸ ~ Â±1.8 Ã— 10Â³â°â¸ | âœ…   |

**ç¤ºä¾‹**:

```rust
fn main() {
    // f64 æ˜¯é»˜è®¤ç±»å‹
    let x = 2.0;        // f64
    let y: f32 = 3.0;   // f32

    // ç§‘å­¦è®¡æ•°æ³•
    let large = 1.23e10;   // 1.23 Ã— 10Â¹â°
    let small = 4.56e-8;   // 4.56 Ã— 10â»â¸

    // åŸºæœ¬è¿ç®—
    let sum = x + y as f64;
    let difference = x - 1.0;
    let product = x * 2.0;
    let quotient = x / 0.5;

    println!("x: {}, y: {}", x, y);
    println!("large: {}, small: {}", large, small);
    println!("sum: {}, product: {}", sum, product);
}
```

#### æµ®ç‚¹æ•°ç²¾åº¦

```rust
fn main() {
    // æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
    let x = 0.1 + 0.2;
    println!("0.1 + 0.2 = {}", x); // 0.30000000000000004

    // æ¯”è¾ƒæµ®ç‚¹æ•°
    let a = 0.1 + 0.2;
    let b = 0.3;

    // âŒ ä¸è¦ç›´æ¥æ¯”è¾ƒ
    // if a == b { ... }

    // âœ… ä½¿ç”¨ epsilon æ¯”è¾ƒ
    let epsilon = 1e-10;
    if (a - b).abs() < epsilon {
        println!("a and b are approximately equal");
    }

    // âœ… ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ (å¦‚ approx)
    // assert_relative_eq!(a, b, epsilon = 1e-10);
}
```

#### ç‰¹æ®Šå€¼

```rust
fn main() {
    // ç‰¹æ®Šæµ®ç‚¹æ•°å€¼
    let inf = f64::INFINITY;
    let neg_inf = f64::NEG_INFINITY;
    let nan = f64::NAN;

    println!("inf: {}, neg_inf: {}, nan: {}", inf, neg_inf, nan);

    // æ£€æŸ¥ç‰¹æ®Šå€¼
    println!("inf is infinite: {}", inf.is_infinite());
    println!("nan is nan: {}", nan.is_nan());
    println!("1.0 is finite: {}", 1.0f64.is_finite());

    // NaN çš„ç‰¹æ®Šæ€§
    println!("nan == nan: {}", nan == nan); // false!
    println!("nan != nan: {}", nan != nan); // true!
}
```

#### æœ€ä½³å®è·µ2

```rust
fn main() {
    // âœ… ä½¿ç”¨ f64 ä½œä¸ºé»˜è®¤æµ®ç‚¹æ•°ç±»å‹
    let pi = 3.14159265359;

    // âœ… ä¸è¦ç›´æ¥æ¯”è¾ƒæµ®ç‚¹æ•°
    let epsilon = 1e-10;
    let a = 0.1 + 0.2;
    let b = 0.3;
    assert!((a - b).abs() < epsilon);

    // âœ… æ£€æŸ¥ç‰¹æ®Šå€¼
    let result = some_calculation();
    if result.is_finite() {
        println!("result: {}", result);
    } else {
        println!("result is not finite!");
    }

    // âœ… ä½¿ç”¨ç²¾ç¡®çš„æ•´æ•°è¿ç®—ä»£æ›¿æµ®ç‚¹æ•°
    // âŒ let cents = 0.1 + 0.2;  // æµ®ç‚¹æ•°è¯¯å·®
    // âœ… let cents = 10 + 20;     // æ•´æ•°ç²¾ç¡®
}

fn some_calculation() -> f64 {
    42.0
}
```

### 2.3 å¸ƒå°”ç±»å‹

#### åŸºæœ¬ç”¨æ³•

å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`

```rust
fn main() {
    // å¸ƒå°”å€¼
    let t = true;
    let f: bool = false;

    // æ¡ä»¶è¡¨è¾¾å¼
    if t {
        println!("t is true");
    }

    // æ¯”è¾ƒè¿ç®—
    let is_greater = 5 > 3;
    let is_equal = 10 == 10;
    println!("is_greater: {}, is_equal: {}", is_greater, is_equal);
}
```

#### å¸ƒå°”è¿ç®—

```rust
fn main() {
    let a = true;
    let b = false;

    // é€»è¾‘è¿ç®—
    println!("a && b: {}", a && b); // false (ä¸)
    println!("a || b: {}", a || b); // true (æˆ–)
    println!("!a: {}", !a);         // false (é)

    // çŸ­è·¯æ±‚å€¼
    let result = a || expensive_operation();
    // expensive_operation() ä¸ä¼šè¢«è°ƒç”¨ï¼Œå› ä¸º a å·²ç»æ˜¯ true

    // å¸ƒå°”è¿ç®—ä¼˜å…ˆçº§
    let complex = true || false && false; // true || (false && false)
    println!("complex: {}", complex); // true
}

fn expensive_operation() -> bool {
    println!("expensive operation called");
    true
}
```

#### ç±»å‹å¤§å°

```rust
fn main() {
    use std::mem;

    // å¸ƒå°”ç±»å‹å ç”¨ 1 å­—èŠ‚
    println!("size of bool: {} byte", mem::size_of::<bool>());

    // å°½ç®¡åªéœ€è¦ 1 bitï¼Œä½†ä¸ºäº†å†…å­˜å¯¹é½ï¼Œå ç”¨ 1 byte
    let b = true;
    println!("b: {}", b);
}
```

### 2.4 å­—ç¬¦ç±»å‹

#### åŸºæœ¬ç”¨æ³•2

Rust çš„ `char` ç±»å‹è¡¨ç¤ºå•ä¸ª Unicode æ ‡é‡å€¼ï¼š

```rust
fn main() {
    // å­—ç¬¦å­—é¢é‡ä½¿ç”¨å•å¼•å·
    let c = 'z';
    let z: char = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';

    println!("c: {}, z: {}, cat: {}", c, z, heart_eyed_cat);

    // char å ç”¨ 4 å­—èŠ‚ (32 ä½)
    use std::mem;
    println!("size of char: {} bytes", mem::size_of::<char>());
}
```

#### Unicode æ”¯æŒ

```rust
fn main() {
    // ASCII å­—ç¬¦
    let ascii = 'A';

    // Unicode å­—ç¬¦
    let chinese = 'ä¸­';
    let emoji = 'ğŸ˜€';

    // Unicode è½¬ä¹‰
    let unicode_char = '\u{1F60A}'; // ğŸ˜Š

    // å­—ç¬¦è½¬æ¢
    let code = unicode_char as u32;
    println!("unicode code point: U+{:X}", code);

    // ä»ä»£ç ç‚¹åˆ›å»ºå­—ç¬¦
    if let Some(ch) = char::from_u32(0x1F60A) {
        println!("char from code point: {}", ch);
    }

    println!("ascii: {}, chinese: {}, emoji: {}", ascii, chinese, emoji);
}
```

#### å¸¸è§é™·é˜±

```rust
fn main() {
    // âŒ å­—ç¬¦ä¸æ˜¯å­—ç¬¦ä¸²
    // let s = 'hello'; // ç¼–è¯‘é”™è¯¯ï¼å•å¼•å·ç”¨äºå­—ç¬¦
    let s = "hello";    // âœ… åŒå¼•å·ç”¨äºå­—ç¬¦ä¸²

    // âŒ å­—ç¬¦ä¸èƒ½ä¸ºç©º
    // let empty = ''; // ç¼–è¯‘é”™è¯¯ï¼

    // âœ… å­—ç¬¦æ–¹æ³•
    let c = 'A';
    println!("is alphabetic: {}", c.is_alphabetic());
    println!("is numeric: {}", c.is_numeric());
    println!("to lowercase: {}", c.to_lowercase());

    // âœ… å­—ç¬¦ä¸²æ˜¯å­—ç¬¦çš„é›†åˆ
    let hello = "Hello";
    for c in hello.chars() {
        println!("{}", c);
    }
}
```

---

## 3. å¤åˆç±»å‹ (Compound Types)

å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼ç»„åˆæˆä¸€ä¸ªç±»å‹ã€‚

### 3.1 å…ƒç»„ç±»å‹

#### åŸºæœ¬ç”¨æ³•3

å…ƒç»„å¯ä»¥å°†å¤šä¸ªä¸åŒç±»å‹çš„å€¼ç»„åˆåœ¨ä¸€èµ·ï¼š

```rust
fn main() {
    // åˆ›å»ºå…ƒç»„
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // è®¿é—®å…ƒç»„å…ƒç´ 
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;

    println!("tup: ({}, {}, {})", five_hundred, six_point_four, one);

    // ç±»å‹æ¨å¯¼
    let tup2 = (1, 2.0, 'a');
    println!("tup2: ({}, {}, {})", tup2.0, tup2.1, tup2.2);
}
```

#### è§£æ„

```rust
fn main() {
    let tup = (500, 6.4, 1);

    // è§£æ„å…ƒç»„
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);

    // éƒ¨åˆ†è§£æ„
    let (a, _, c) = tup; // å¿½ç•¥ç¬¬äºŒä¸ªå…ƒç´ 
    println!("a: {}, c: {}", a, c);

    // å‡½æ•°è¿”å›å…ƒç»„
    let (min, max) = find_min_max(&[1, 5, 3, 9, 2]);
    println!("min: {}, max: {}", min, max);
}

fn find_min_max(numbers: &[i32]) -> (i32, i32) {
    let min = *numbers.iter().min().unwrap();
    let max = *numbers.iter().max().unwrap();
    (min, max)
}
```

#### å•å…ƒç±»å‹

```rust
fn main() {
    // å•å…ƒç±»å‹ () æ˜¯ç©ºå…ƒç»„
    let unit: () = ();

    // ä¸è¿”å›å€¼çš„å‡½æ•°è¿”å›å•å…ƒç±»å‹
    let result = println!("Hello"); // result æ˜¯ ()

    // æ˜¾å¼è¿”å›å•å…ƒç±»å‹
    fn do_nothing() -> () {
        // æˆ– fn do_nothing() { ... }
    }

    println!("unit: {:?}", unit);
}
```

### 3.2 æ•°ç»„ç±»å‹

#### åŸºæœ¬ç”¨æ³•32

æ•°ç»„æ˜¯å›ºå®šé•¿åº¦çš„ç›¸åŒç±»å‹å…ƒç´ çš„é›†åˆï¼š

```rust
fn main() {
    // åˆ›å»ºæ•°ç»„
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5]; // æ˜¾å¼ç±»å‹å’Œé•¿åº¦

    // åˆå§‹åŒ–ç›¸åŒå€¼
    let c = [3; 5]; // [3, 3, 3, 3, 3]

    // è®¿é—®æ•°ç»„å…ƒç´ 
    let first = a[0];
    let second = a[1];

    println!("a: {:?}", a);
    println!("first: {}, second: {}", first, second);

    // æ•°ç»„é•¿åº¦
    println!("length of a: {}", a.len());
}
```

#### æ•°ç»„æ“ä½œ

```rust
fn main() {
    let mut arr = [1, 2, 3, 4, 5];

    // ä¿®æ”¹å…ƒç´ 
    arr[0] = 10;
    println!("arr: {:?}", arr);

    // è¿­ä»£
    for element in arr.iter() {
        println!("{}", element);
    }

    // å¸¦ç´¢å¼•è¿­ä»£
    for (index, &value) in arr.iter().enumerate() {
        println!("arr[{}] = {}", index, value);
    }

    // åˆ‡ç‰‡
    let slice = &arr[1..4]; // [2, 3, 4]
    println!("slice: {:?}", slice);
}
```

#### å¤šç»´æ•°ç»„

```rust
fn main() {
    // äºŒç»´æ•°ç»„
    let matrix: [[i32; 3]; 2] = [
        [1, 2, 3],
        [4, 5, 6],
    ];

    // è®¿é—®å…ƒç´ 
    println!("matrix[0][1]: {}", matrix[0][1]); // 2

    // éå†äºŒç»´æ•°ç»„
    for row in matrix.iter() {
        for &col in row.iter() {
            print!("{} ", col);
        }
        println!();
    }
}
```

---

## 4. å­—ç¬¦ä¸²ç±»å‹

Rust æœ‰ä¸¤ç§ä¸»è¦çš„å­—ç¬¦ä¸²ç±»å‹ï¼š`String` å’Œ `&str`

### 4.1 å­—ç¬¦ä¸²åˆ‡ç‰‡ (&str)

#### åŸºæœ¬æ¦‚å¿µ

`&str` æ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼•ç”¨ï¼Œæ˜¯ä¸å¯å˜çš„ï¼š

```rust
fn main() {
    // å­—ç¬¦ä¸²å­—é¢é‡æ˜¯ &str ç±»å‹
    let s: &str = "Hello, world!";

    // å­—ç¬¦ä¸²åˆ‡ç‰‡
    let hello = &s[0..5];   // "Hello"
    let world = &s[7..12];  // "world"

    println!("s: {}", s);
    println!("hello: {}, world: {}", hello, world);
}
```

#### å­—ç¬¦ä¸²å­—é¢é‡

```rust
fn main() {
    // å­—ç¬¦ä¸²å­—é¢é‡å­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­
    let s1 = "Hello";
    let s2 = "Hello";

    // å­—ç¬¦ä¸²å­—é¢é‡çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ 'static
    let s3: &'static str = "Hello, static!";

    // åŸå§‹å­—ç¬¦ä¸²å­—é¢é‡ (ä¸è½¬ä¹‰)
    let raw = r"C:\Users\Name\file.txt";
    let multi_line = r#"
        This is a
        multi-line
        string
    "#;

    println!("s1: {}, s2: {}", s1, s2);
    println!("raw: {}", raw);
    println!("multi_line: {}", multi_line);
}
```

#### åˆ‡ç‰‡æ“ä½œ

```rust
fn main() {
    let s = String::from("hello world");

    // åˆ‡ç‰‡è¯­æ³•
    let hello = &s[0..5];    // "hello"
    let world = &s[6..11];   // "world"

    // çœç•¥èµ·å§‹ç´¢å¼•
    let hello2 = &s[..5];    // "hello"

    // çœç•¥ç»“æŸç´¢å¼•
    let world2 = &s[6..];    // "world"

    // å®Œæ•´åˆ‡ç‰‡
    let full = &s[..];       // "hello world"

    println!("hello: {}, world: {}", hello, world);
    println!("hello2: {}, world2: {}", hello2, world2);
    println!("full: {}", full);

    // âš ï¸ æ³¨æ„ï¼šåˆ‡ç‰‡ç´¢å¼•å¿…é¡»ä½äºå­—ç¬¦è¾¹ç•Œ
    let chinese = String::from("ä¸­å›½");
    // let invalid = &chinese[0..1]; // panic! ä¸æ˜¯æœ‰æ•ˆçš„å­—ç¬¦è¾¹ç•Œ
    let valid = &chinese[0..3];     // "ä¸­" (UTF-8 ä¸­ä¸€ä¸ªæ±‰å­—å  3 å­—èŠ‚)
    println!("valid: {}", valid);
}
```

### 4.2 String ç±»å‹

#### åˆ›å»º String

```rust
fn main() {
    // ä»å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»º
    let s1 = String::from("Hello");
    let s2 = "World".to_string();

    // åˆ›å»ºç©ºå­—ç¬¦ä¸²
    let mut s3 = String::new();

    // é¢„åˆ†é…å®¹é‡
    let mut s4 = String::with_capacity(10);

    println!("s1: {}, s2: {}", s1, s2);
    println!("s3: '{}', s4: '{}'", s3, s4);
}
```

#### ä¿®æ”¹ String

```rust
fn main() {
    let mut s = String::from("Hello");

    // è¿½åŠ å­—ç¬¦ä¸²
    s.push_str(", world");
    println!("after push_str: {}", s);

    // è¿½åŠ å­—ç¬¦
    s.push('!');
    println!("after push: {}", s);

    // æ’å…¥å­—ç¬¦ä¸²
    s.insert_str(5, " Rust");
    println!("after insert_str: {}", s);

    // æ’å…¥å­—ç¬¦
    s.insert(0, '#');
    println!("after insert: {}", s);

    // æ›¿æ¢
    let new_s = s.replace("Rust", "World");
    println!("after replace: {}", new_s);

    // æ¸…ç©º
    s.clear();
    println!("after clear: '{}'", s);
}
```

#### String vs &str

```rust
fn main() {
    // String: æ‹¥æœ‰æ‰€æœ‰æƒï¼Œå¯å˜ï¼Œå †åˆ†é…
    let mut s1 = String::from("Hello");
    s1.push_str(", world");

    // &str: å€Ÿç”¨ï¼Œä¸å¯å˜ï¼Œå¯èƒ½åœ¨æ ˆæˆ–å †
    let s2: &str = "Hello";
    // s2.push_str(", world"); // ç¼–è¯‘é”™è¯¯ï¼&str ä¸å¯å˜

    // String -> &str (Deref coercion)
    let s3 = String::from("Hello");
    let s4: &str = &s3; // è‡ªåŠ¨è½¬æ¢

    // &str -> String
    let s5: &str = "Hello";
    let s6 = s5.to_string();
    let s7 = String::from(s5);

    println!("s1: {}, s2: {}", s1, s2);
    println!("s3: {}, s4: {}", s3, s4);
    println!("s5: {}, s6: {}, s7: {}", s5, s6, s7);

    // å‡½æ•°å‚æ•°é€šå¸¸ä½¿ç”¨ &str (æ›´é€šç”¨)
    print_str("Hello");
    print_str(&String::from("World"));
}

fn print_str(s: &str) {
    println!("{}", s);
}
```

---

## 5. å¼•ç”¨ç±»å‹

å¼•ç”¨å…è®¸æ‚¨å¼•ç”¨æŸä¸ªå€¼è€Œä¸è·å–å…¶æ‰€æœ‰æƒã€‚

### 5.1 ä¸å¯å˜å¼•ç”¨ (&T)

#### åŸºæœ¬ç”¨æ³•51

```rust
fn main() {
    let s1 = String::from("Hello");

    // åˆ›å»ºä¸å¯å˜å¼•ç”¨
    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
    // s1 ä»ç„¶æœ‰æ•ˆï¼Œå› ä¸ºæˆ‘ä»¬åªæ˜¯å€Ÿç”¨äº†å®ƒ
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s ç¦»å¼€ä½œç”¨åŸŸï¼Œä½†å› ä¸ºå®ƒåªæ˜¯å¼•ç”¨ï¼Œæ‰€ä»¥ä¸ä¼šé‡Šæ”¾å†…å­˜
```

#### å€Ÿç”¨è§„åˆ™

```rust
fn main() {
    let s = String::from("Hello");

    // å¯ä»¥åŒæ—¶æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;

    println!("r1: {}, r2: {}, r3: {}", r1, r2, r3);
    // æ‰€æœ‰å¼•ç”¨éƒ½æœ‰æ•ˆ
}
```

### 5.2 å¯å˜å¼•ç”¨ (&mut T)

#### åŸºæœ¬ç”¨æ³•52

```rust
fn main() {
    let mut s = String::from("Hello");

    // åˆ›å»ºå¯å˜å¼•ç”¨
    change(&mut s);

    println!("s: {}", s); // "Hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

#### å¯å˜æ€§è§„åˆ™

```rust
fn main() {
    let mut s = String::from("Hello");

    // âœ… å¯ä»¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨
    let r1 = &mut s;
    r1.push_str(", world");
    println!("r1: {}", r1);

    // âŒ ä¸èƒ½åŒæ—¶æœ‰ä¸¤ä¸ªå¯å˜å¼•ç”¨
    // let r1 = &mut s;
    // let r2 = &mut s; // ç¼–è¯‘é”™è¯¯ï¼
    // println!("{}, {}", r1, r2);

    // âŒ ä¸èƒ½åŒæ—¶æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨
    let r2 = &s;
    // let r3 = &mut s; // ç¼–è¯‘é”™è¯¯ï¼
    // println!("{}, {}", r2, r3);

    // âœ… å¼•ç”¨çš„ä½œç”¨åŸŸåœ¨æœ€åä¸€æ¬¡ä½¿ç”¨åç»“æŸ
    let r4 = &s;
    let r5 = &s;
    println!("{} {}", r4, r5);
    // r4 å’Œ r5 çš„ä½œç”¨åŸŸåœ¨è¿™é‡Œç»“æŸ

    let r6 = &mut s; // âœ… ç°åœ¨å¯ä»¥åˆ›å»ºå¯å˜å¼•ç”¨äº†
    r6.push_str("!");
}
```

### 5.3 å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ

```rust
fn main() {
    // ç”Ÿå‘½å‘¨æœŸç¡®ä¿å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„
    let r;
    {
        let x = 5;
        // r = &x; // ç¼–è¯‘é”™è¯¯ï¼x çš„ç”Ÿå‘½å‘¨æœŸä¸å¤Ÿé•¿
    }
    // println!("r: {}", r);

    // âœ… æ­£ç¡®çš„ç”¨æ³•
    let x = 5;
    let r = &x;
    println!("r: {}", r);
}
```

---

## 6. æ™ºèƒ½æŒ‡é’ˆç±»å‹

æ™ºèƒ½æŒ‡é’ˆæ˜¯å…·æœ‰é¢å¤–åŠŸèƒ½çš„æŒ‡é’ˆã€‚

### 6.1 `Box<T>`

#### å †åˆ†é…

```rust
fn main() {
    // åœ¨å †ä¸Šåˆ†é…å€¼
    let b = Box::new(5);
    println!("b = {}", b);

    // å¤§å‹æ•°æ®ç»“æ„
    let large_data = Box::new([0; 1000]);
    println!("large data allocated on heap");
}
```

#### é€’å½’ç±»å‹

```rust
// ä½¿ç”¨ Box å®šä¹‰é€’å½’ç±»å‹
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    print_list(&list);
}

fn print_list(list: &List) {
    match list {
        Cons(value, next) => {
            print!("{} -> ", value);
            print_list(next);
        }
        Nil => println!("Nil"),
    }
}
```

### 6.2 `Rc<T> å’Œ Arc<T>`

#### å¼•ç”¨è®¡æ•°

```rust
use std::rc::Rc;

fn main() {
    // Rc: å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ (å•çº¿ç¨‹)
    let a = Rc::new(5);
    println!("count after creating a: {}", Rc::strong_count(&a));

    let b = Rc::clone(&a);
    println!("count after creating b: {}", Rc::strong_count(&a));

    {
        let c = Rc::clone(&a);
        println!("count after creating c: {}", Rc::strong_count(&a));
    }

    println!("count after c goes out of scope: {}", Rc::strong_count(&a));
}
```

#### å¤šçº¿ç¨‹å…±äº«

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    // Arc: åŸå­å¼•ç”¨è®¡æ•° (å¤šçº¿ç¨‹å®‰å…¨)
    let data = Arc::new(vec![1, 2, 3, 4, 5]);

    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("thread {}: {:?}", i, data);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 7. åˆ‡ç‰‡ç±»å‹

åˆ‡ç‰‡æ˜¯å¯¹æ•°ç»„æˆ–å­—ç¬¦ä¸²çš„å¼•ç”¨ã€‚

### 7.1 æ•°ç»„åˆ‡ç‰‡

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // åˆ›å»ºåˆ‡ç‰‡
    let slice = &a[1..4]; // [2, 3, 4]
    println!("slice: {:?}", slice);

    // ä¼ é€’åˆ‡ç‰‡ç»™å‡½æ•°
    let sum = sum_slice(slice);
    println!("sum: {}", sum);
}

fn sum_slice(slice: &[i32]) -> i32 {
    slice.iter().sum()
}
```

### 7.2 å­—ç¬¦ä¸²åˆ‡ç‰‡

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];

    println!("hello: {}, world: {}", hello, world);

    // è·å–ç¬¬ä¸€ä¸ªå•è¯
    let word = first_word(&s);
    println!("first word: {}", word);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

---

## 8. æŒ‡é’ˆç±»å‹

### 8.1 åŸå§‹æŒ‡é’ˆ

```rust
fn main() {
    let mut num = 5;

    // åˆ›å»ºåŸå§‹æŒ‡é’ˆ
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 points to: {}", *r1);
        println!("r2 points to: {}", *r2);

        // ä¿®æ”¹å€¼
        *r2 = 10;
        println!("num is now: {}", num);
    }
}
```

### 8.2 å‡½æ•°æŒ‡é’ˆ

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);
    println!("The answer is: {}", answer); // 12
}
```

---

## 9. Never ç±»å‹ (!)

### 9.1 åŸºæœ¬æ¦‚å¿µ

```rust
fn main() {
    // ! ç±»å‹è¡¨ç¤ºæ°¸ä¸è¿”å›
    // fn exit() -> ! {
    //     std::process::exit(0);
    // }

    // å¯ä»¥ç”¨åœ¨ match ä¸­
    let guess: u32 = match "42".parse() {
        Ok(num) => num,
        Err(_) => panic!("Not a number!"), // panic! è¿”å› !
    };

    println!("guess: {}", guess);
}
```

### 9.2 å®é™…åº”ç”¨

```rust
fn main() {
    loop {
        // loop è¡¨è¾¾å¼çš„ç±»å‹æ˜¯ !
        // continue å’Œ break ä¹Ÿæ˜¯ !
        break;
    }
}
```

---

## 10. ç±»å‹æ¨å¯¼ä¸ç±»å‹æ ‡æ³¨

### 10.1 ç±»å‹æ¨å¯¼

```rust
fn main() {
    // ç¼–è¯‘å™¨å¯ä»¥æ¨å¯¼ç±»å‹
    let x = 5;          // i32
    let y = 3.14;       // f64
    let z = true;       // bool
    let c = 'a';        // char

    // ä»ä¸Šä¸‹æ–‡æ¨å¯¼
    let mut vec = Vec::new();
    vec.push(1); // ç°åœ¨ç¼–è¯‘å™¨çŸ¥é“ vec æ˜¯ Vec<i32>

    println!("x: {}, y: {}, z: {}, c: {}", x, y, z, c);
}
```

### 10.2 æ˜¾å¼ç±»å‹æ ‡æ³¨

```rust
fn main() {
    // æ˜¾å¼æ ‡æ³¨ç±»å‹
    let x: i32 = 5;
    let y: f64 = 3.14;

    // éœ€è¦æ˜¾å¼æ ‡æ³¨çš„æƒ…å†µ
    let numbers: Vec<i32> = Vec::new();

    // ç±»å‹æ ‡æ³¨åœ¨å˜é‡åå
    let guess: u32 = "42".parse().expect("Not a number!");

    println!("x: {}, y: {}, guess: {}", x, y, guess);
}
```

### 10.3 Turbofish è¯­æ³•

```rust
fn main() {
    // ä½¿ç”¨ turbofish è¯­æ³•æŒ‡å®šç±»å‹å‚æ•°
    let numbers = vec![1, 2, 3];

    // æŒ‡å®š collect çš„ç›®æ ‡ç±»å‹
    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();

    // ä½¿ç”¨ turbofish
    let doubled2 = numbers.iter().map(|x| x * 2).collect::<Vec<i32>>();

    println!("doubled: {:?}", doubled);
    println!("doubled2: {:?}", doubled2);

    // è§£æå­—ç¬¦ä¸²
    let num = "42".parse::<i32>().unwrap();
    println!("num: {}", num);
}
```

---

## 11. ç±»å‹åˆ«å

### 11.1 åŸºæœ¬ç”¨æ³•

```rust
fn main() {
    // åˆ›å»ºç±»å‹åˆ«å
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    // ç±»å‹åˆ«åä¸æ˜¯æ–°ç±»å‹ï¼Œåªæ˜¯åˆ«å
    println!("x + y = {}", x + y); // âœ… å¯ä»¥ç›¸åŠ 
}
```

### 11.2 æ³›å‹ç±»å‹åˆ«å

```rust
fn main() {
    // ç®€åŒ–å¤æ‚ç±»å‹
    type Result<T> = std::result::Result<T, std::io::Error>;

    // ä½¿ç”¨åˆ«å
    fn read_file() -> Result<String> {
        Ok(String::from("file contents"))
    }

    match read_file() {
        Ok(content) => println!("content: {}", content),
        Err(e) => println!("error: {}", e),
    }
}
```

---

## 12. ç±»å‹å¤§å°ä¸å†…å­˜å¸ƒå±€

### 12.1 ç±»å‹å¤§å°

```rust
fn main() {
    use std::mem;

    // æŸ¥è¯¢ç±»å‹å¤§å°
    println!("size of i8: {} byte", mem::size_of::<i8>());
    println!("size of i32: {} bytes", mem::size_of::<i32>());
    println!("size of i64: {} bytes", mem::size_of::<i64>());
    println!("size of f64: {} bytes", mem::size_of::<f64>());
    println!("size of bool: {} byte", mem::size_of::<bool>());
    println!("size of char: {} bytes", mem::size_of::<char>());

    // å¼•ç”¨å’ŒæŒ‡é’ˆ
    println!("size of &i32: {} bytes", mem::size_of::<&i32>());
    println!("size of Box<i32>: {} bytes", mem::size_of::<Box<i32>>());

    // å¤åˆç±»å‹
    println!("size of (i32, i32): {} bytes", mem::size_of::<(i32, i32)>());
    println!("size of [i32; 5]: {} bytes", mem::size_of::<[i32; 5]>());
}
```

### 12.2 é›¶å¤§å°ç±»å‹ (ZST)

```rust
fn main() {
    use std::mem;

    // å•å…ƒç±»å‹æ˜¯ ZST
    println!("size of (): {} bytes", mem::size_of::<()>());

    // ç©ºç»“æ„ä½“æ˜¯ ZST
    struct Empty;
    println!("size of Empty: {} bytes", mem::size_of::<Empty>());

    // PhantomData æ˜¯ ZST
    use std::marker::PhantomData;
    println!("size of PhantomData<i32>: {} bytes", mem::size_of::<PhantomData<i32>>());
}
```

### 12.3 å†…å­˜å¯¹é½

```rust
fn main() {
    use std::mem;

    // ç»“æ„ä½“çš„å†…å­˜å¯¹é½
    #[repr(C)]
    struct A {
        a: u8,   // 1 byte
        b: u32,  // 4 bytes
        c: u16,  // 2 bytes
    }

    println!("size of A: {} bytes", mem::size_of::<A>());
    println!("align of A: {} bytes", mem::align_of::<A>());

    // ä¼˜åŒ–å†…å­˜å¸ƒå±€
    #[repr(C)]
    struct B {
        b: u32,  // 4 bytes
        c: u16,  // 2 bytes
        a: u8,   // 1 byte
    }

    println!("size of B: {} bytes", mem::size_of::<B>());
}
```

---

## 13. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: æ¸©åº¦è½¬æ¢å™¨

```rust
fn main() {
    // æ‘„æ°åº¦è½¬åæ°åº¦
    let celsius = 25.0;
    let fahrenheit = celsius_to_fahrenheit(celsius);
    println!("{}Â°C = {}Â°F", celsius, fahrenheit);

    // åæ°åº¦è½¬æ‘„æ°åº¦
    let fahr = 77.0;
    let cel = fahrenheit_to_celsius(fahr);
    println!("{}Â°F = {}Â°C", fahr, cel);
}

fn celsius_to_fahrenheit(celsius: f64) -> f64 {
    (celsius * 9.0 / 5.0) + 32.0
}

fn fahrenheit_to_celsius(fahrenheit: f64) -> f64 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}
```

### æ¡ˆä¾‹ 2: ç®€å•è®¡ç®—å™¨

```rust
fn main() {
    println!("10 + 5 = {}", calculate(10.0, 5.0, '+'));
    println!("10 - 5 = {}", calculate(10.0, 5.0, '-'));
    println!("10 * 5 = {}", calculate(10.0, 5.0, '*'));
    println!("10 / 5 = {}", calculate(10.0, 5.0, '/'));
}

fn calculate(a: f64, b: f64, operator: char) -> f64 {
    match operator {
        '+' => a + b,
        '-' => a - b,
        '*' => a * b,
        '/' => a / b,
        _ => {
            println!("Unknown operator: {}", operator);
            0.0
        }
    }
}
```

### æ¡ˆä¾‹ 3: å­—ç¬¦ä¸²å¤„ç†

```rust
fn main() {
    let text = "Hello, Rust! Welcome to type system learning.";

    // ç»Ÿè®¡å•è¯
    let word_count = count_words(text);
    println!("Word count: {}", word_count);

    // ç»Ÿè®¡å­—ç¬¦
    let char_count = text.chars().count();
    println!("Character count: {}", char_count);

    // è½¬æ¢ä¸ºå¤§å†™
    let uppercase = text.to_uppercase();
    println!("Uppercase: {}", uppercase);
}

fn count_words(text: &str) -> usize {
    text.split_whitespace().count()
}
```

---

## 14. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 14.1 å¸¸è§é™·é˜±

```rust
fn main() {
    // âŒ é™·é˜± 1: æ•´æ•°æº¢å‡º
    // let x: u8 = 256; // ç¼–è¯‘é”™è¯¯ï¼

    // âœ… ä½¿ç”¨ checked æ–¹æ³•
    let y: u8 = 255;
    if let Some(result) = y.checked_add(1) {
        println!("result: {}", result);
    } else {
        println!("overflow!");
    }

    // âŒ é™·é˜± 2: æµ®ç‚¹æ•°æ¯”è¾ƒ
    let a = 0.1 + 0.2;
    // if a == 0.3 { } // å¯èƒ½å¤±è´¥ï¼

    // âœ… ä½¿ç”¨ epsilon æ¯”è¾ƒ
    let epsilon = 1e-10;
    if (a - 0.3).abs() < epsilon {
        println!("approximately equal");
    }

    // âŒ é™·é˜± 3: å­—ç¬¦ä¸²åˆ‡ç‰‡è¾¹ç•Œ
    let s = String::from("ä¸­å›½");
    // let invalid = &s[0..1]; // panic! ä¸æ˜¯å­—ç¬¦è¾¹ç•Œ
    let valid = &s[0..3];     // âœ… å®Œæ•´çš„ UTF-8 å­—ç¬¦
    println!("valid: {}", valid);
}
```

### 14.2 æœ€ä½³å®è·µ

```rust
fn main() {
    // âœ… 1. ä½¿ç”¨ç±»å‹æ¨å¯¼
    let x = 42;                    // è€Œä¸æ˜¯ let x: i32 = 42;

    // âœ… 2. ä½¿ç”¨ &str ä½œä¸ºå‚æ•°
    fn print_str(s: &str) {
        println!("{}", s);
    }

    // âœ… 3. ä½¿ç”¨ usize ä½œä¸ºç´¢å¼•
    let vec = vec![1, 2, 3];
    let len: usize = vec.len();

    // âœ… 4. é¢„åˆ†é…å®¹é‡
    let mut vec = Vec::with_capacity(100);

    // âœ… 5. ä½¿ç”¨è¿­ä»£å™¨è€Œä¸æ˜¯ç´¢å¼•
    for item in vec.iter() {
        // ...
    }
}
```

### 14.6 å®æˆ˜æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½æ•°æ®å¤„ç†

**æ¡ˆä¾‹ï¼šä¼˜åŒ–å¤§è§„æ¨¡æ•°å€¼è®¡ç®—**:

```rust
use std::time::Instant;

// âŒ éä¼˜åŒ–ç‰ˆæœ¬
fn process_data_slow(data: &[f64]) -> f64 {
    let mut result = 0.0;
    for i in 0..data.len() {
        result += data[i] * 2.0;  // ç´¢å¼•è®¿é—®æœ‰è¾¹ç•Œæ£€æŸ¥
    }
    result
}

// âœ… ä¼˜åŒ–ç‰ˆæœ¬
fn process_data_fast(data: &[f64]) -> f64 {
    data.iter()                    // è¿­ä»£å™¨ï¼Œæ— è¾¹ç•Œæ£€æŸ¥
        .map(|&x| x * 2.0)         // ç¼–è¯‘å™¨ä¼˜åŒ–SIMD
        .sum()                     // èšåˆæ“ä½œ
}

fn main() {
    let data: Vec<f64> = (0..1_000_000).map(|x| x as f64).collect();

    let start = Instant::now();
    let result1 = process_data_slow(&data);
    println!("Slow: {:?}, result: {}", start.elapsed(), result1);

    let start = Instant::now();
    let result2 = process_data_fast(&data);
    println!("Fast: {:?}, result: {}", start.elapsed(), result2);
}
// è¾“å‡ºç¤ºä¾‹ï¼š
// Slow: 3.2ms
// Fast: 1.1ms  (3x faster!)
```

---

## 15. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç±»å‹ç³»ç»Ÿ**
   - âœ… Rust é‡‡ç”¨å¼ºé™æ€ç±»å‹ç³»ç»Ÿ
   - âœ… ç¼–è¯‘æ—¶ç¡®å®šæ‰€æœ‰ç±»å‹
   - âœ… ç±»å‹æ¨å¯¼å‡å°‘å†—ä½™æ ‡æ³¨

2. **æ ‡é‡ç±»å‹**
   - âœ… æ•´æ•° (i8-i128, u8-u128, isize, usize)
   - âœ… æµ®ç‚¹æ•° (f32, f64)
   - âœ… å¸ƒå°” (bool)
   - âœ… å­—ç¬¦ (char)

3. **å¤åˆç±»å‹**
   - âœ… å…ƒç»„ - ç»„åˆä¸åŒç±»å‹
   - âœ… æ•°ç»„ - å›ºå®šé•¿åº¦ç›¸åŒç±»å‹

4. **å­—ç¬¦ä¸²ç±»å‹**
   - âœ… &str - å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œä¸å¯å˜
   - âœ… String - å¯å˜å­—ç¬¦ä¸²ï¼Œå †åˆ†é…

5. **å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆ**
   - âœ… &T - ä¸å¯å˜å¼•ç”¨
   - âœ… &mut T - å¯å˜å¼•ç”¨
   - âœ… `Box<T>` - å †åˆ†é…
   - âœ… `Rc<T>/Arc<T>` - å¼•ç”¨è®¡æ•°

### ä¸‹ä¸€æ­¥å­¦ä¹ 

å­¦å®Œæœ¬æŒ‡å—åï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **[2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)** - æ·±å…¥å­¦ä¹ ç»“æ„ä½“å’Œæšä¸¾
2. **[2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](./03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)** - å­¦ä¹ æ³›å‹ç³»ç»Ÿ
3. **[2.4 Traitç³»ç»ŸæŒ‡å—](./04_Traitç³»ç»ŸæŒ‡å—.md)** - æŒæ¡ trait è®¾è®¡
4. **[2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](./05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)** - ç†è§£ç”Ÿå‘½å‘¨æœŸç®¡ç†

---

## 16. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Chapter 3](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html)
- [Rust Reference - Types](https://doc.rust-lang.org/reference/types.html)
- [Std Library - Primitive Types](https://doc.rust-lang.org/std/#primitives)

**ç›¸å…³æ–‡æ¡£**:

- [1.0 é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [1.2 æœ¯è¯­è¡¨](../tier_01_foundations/03_æœ¯è¯­è¡¨.md)
- [1.3 å¸¸è§é—®é¢˜](../tier_01_foundations/04_å¸¸è§é—®é¢˜.md)

**æ·±åº¦åˆ†æ**:

- [ç±»å‹å®šä¹‰](./01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [ç±»å‹å˜ä½“](./02_å¤åˆç±»å‹æŒ‡å—.md)
- [ç±»å‹è½¬æ¢](../tier_03_references/01_ç±»å‹è½¬æ¢å‚è€ƒ.md)

---

**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
**æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚

---

**ğŸ‰ æ­å–œå®ŒæˆåŸºç¡€ç±»å‹æŒ‡å—å­¦ä¹ ï¼** ğŸ¦€
