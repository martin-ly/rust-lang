# 2.5 Rust ç±»å‹ç³»ç»Ÿ - ç”Ÿå‘½å‘¨æœŸæŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚  
> **æ–‡æ¡£å®šä½**: ç³»ç»Ÿå­¦ä¹  Rust ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md), [2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 6-8 å°æ—¶  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [2.5 Rust ç±»å‹ç³»ç»Ÿ - ç”Ÿå‘½å‘¨æœŸæŒ‡å—](#25-rust-ç±»å‹ç³»ç»Ÿ---ç”Ÿå‘½å‘¨æœŸæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“Š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°](#1-ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ](#11-ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ)
    - [1.2 ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ](#12-ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ)
    - [1.3 å€Ÿç”¨æ£€æŸ¥å™¨](#13-å€Ÿç”¨æ£€æŸ¥å™¨)
  - [2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨](#2-ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨)
    - [2.1 åŸºæœ¬è¯­æ³•](#21-åŸºæœ¬è¯­æ³•)
    - [2.2 å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#22-å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
    - [2.3 å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°](#23-å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°)
  - [3. ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#3-ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
    - [3.1 å¼•ç”¨å­—æ®µ](#31-å¼•ç”¨å­—æ®µ)
    - [3.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ](#32-ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
    - [3.3 æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#33-æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
  - [4. ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™](#4-ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™)
    - [4.1 ä¸‰æ¡è§„åˆ™](#41-ä¸‰æ¡è§„åˆ™)
    - [4.2 å®é™…åº”ç”¨](#42-å®é™…åº”ç”¨)
  - [5. é™æ€ç”Ÿå‘½å‘¨æœŸ](#5-é™æ€ç”Ÿå‘½å‘¨æœŸ)
    - [5.1 'static ç”Ÿå‘½å‘¨æœŸ](#51-static-ç”Ÿå‘½å‘¨æœŸ)
    - [5.2 ä½¿ç”¨åœºæ™¯](#52-ä½¿ç”¨åœºæ™¯)
  - [6. ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹](#6-ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹)
    - [6.1 ç»“åˆä½¿ç”¨](#61-ç»“åˆä½¿ç”¨)
    - [6.2 ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ](#62-ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ)
  - [7. ç”Ÿå‘½å‘¨æœŸå­ç±»å‹](#7-ç”Ÿå‘½å‘¨æœŸå­ç±»å‹)
    - [7.1 åå˜å’Œé€†å˜](#71-åå˜å’Œé€†å˜)
    - [7.2 ç”Ÿå‘½å‘¨æœŸå…³ç³»](#72-ç”Ÿå‘½å‘¨æœŸå…³ç³»)
  - [8. é«˜çº§ç”Ÿå‘½å‘¨æœŸç‰¹æ€§](#8-é«˜çº§ç”Ÿå‘½å‘¨æœŸç‰¹æ€§)
    - [8.1 é«˜é˜¶ trait bounds (HRTB)](#81-é«˜é˜¶-trait-bounds-hrtb)
    - [8.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ](#82-ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
  - [9. å®æˆ˜æ¡ˆä¾‹](#9-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²åˆ†å‰²å™¨](#æ¡ˆä¾‹-1-å­—ç¬¦ä¸²åˆ†å‰²å™¨)
    - [æ¡ˆä¾‹ 2: ç¼“å­˜ç³»ç»Ÿ](#æ¡ˆä¾‹-2-ç¼“å­˜ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 3: è¿­ä»£å™¨](#æ¡ˆä¾‹-3-è¿­ä»£å™¨)
    - [æ¡ˆä¾‹ 4: è‡ªå¼•ç”¨ç»“æ„](#æ¡ˆä¾‹-4-è‡ªå¼•ç”¨ç»“æ„)
  - [10. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#10-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [10.1 å¸¸è§é™·é˜±](#101-å¸¸è§é™·é˜±)
    - [10.2 æœ€ä½³å®è·µ](#102-æœ€ä½³å®è·µ)
  - [11. æ€»ç»“](#11-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )
  - [12. å‚è€ƒèµ„æº](#12-å‚è€ƒèµ„æº)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… **ç†è§£** ç”Ÿå‘½å‘¨æœŸçš„æ ¸å¿ƒæ¦‚å¿µ
- âœ… **æŒæ¡** ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•
- âœ… **ç†è§£** å€Ÿç”¨æ£€æŸ¥å™¨çš„å·¥ä½œåŸç†
- âœ… **åº”ç”¨** ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
- âœ… **æŒæ¡** ç»“æ„ä½“å’Œæ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
- âœ… **ç†è§£** ç”Ÿå‘½å‘¨æœŸå­ç±»å‹å’Œ HRTB
- âœ… **è§£å†³** ç”Ÿå‘½å‘¨æœŸç›¸å…³çš„ç¼–è¯‘é”™è¯¯

---

## ğŸ“Š ç« èŠ‚æ¦‚è§ˆ

| ç« èŠ‚ | å†…å®¹ | éš¾åº¦ | é¢„è®¡æ—¶é—´ |
|------|------|------|---------|
| 1. ç”Ÿå‘½å‘¨æœŸæ¦‚è¿° | åŸºæœ¬æ¦‚å¿µ | ğŸŸ¢ ç®€å• | 30åˆ†é’Ÿ |
| 2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ | æ ‡æ³¨è¯­æ³• | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ |
| 3. ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ | ç»“æ„ä½“ä¸­çš„å¼•ç”¨ | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ |
| 4. çœç•¥è§„åˆ™ | ç”Ÿå‘½å‘¨æœŸçœç•¥ | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ |
| 5. é™æ€ç”Ÿå‘½å‘¨æœŸ | 'static è¯¦è§£ | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ |
| 6. ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ | ç»“åˆä½¿ç”¨ | ğŸ”´ é«˜çº§ | 40åˆ†é’Ÿ |
| 7. ç”Ÿå‘½å‘¨æœŸå­ç±»å‹ | åå˜å’Œé€†å˜ | ğŸ”´ é«˜çº§ | 50åˆ†é’Ÿ |
| 8. é«˜çº§ç‰¹æ€§ | HRTB ç­‰ | ğŸ”´ é«˜çº§ | 40åˆ†é’Ÿ |
| 9. å®æˆ˜æ¡ˆä¾‹ | ç»¼åˆåº”ç”¨ | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ |
| 10. æœ€ä½³å®è·µ | é™·é˜±ä¸å®è·µ | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ |

**æ€»è®¡**: çº¦ 6-8 å°æ—¶

---

## 1. ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ

**ç”Ÿå‘½å‘¨æœŸ** æ˜¯å¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸã€‚æ¯ä¸ªå¼•ç”¨éƒ½æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå¤§å¤šæ•°æ—¶å€™æ˜¯éšå¼çš„ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- ğŸ”’ ç¡®ä¿å¼•ç”¨å§‹ç»ˆæœ‰æ•ˆ
- â±ï¸ é˜²æ­¢æ‚¬å‚å¼•ç”¨
- ğŸ›¡ï¸ å†…å­˜å®‰å…¨ä¿è¯

**ç¤ºä¾‹**:

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    // println!("r: {}", r); // ç¼–è¯‘é”™è¯¯ï¼x å·²è¢«é”€æ¯
}                         // ---------+
```

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ

**1. é˜²æ­¢æ‚¬å‚å¼•ç”¨**:

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼šæ‚¬å‚å¼•ç”¨
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // s å°†åœ¨å‡½æ•°ç»“æŸæ—¶è¢«é”€æ¯
// }

// âœ… æ­£ç¡®ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // ç§»åŠ¨æ‰€æœ‰æƒ
}

fn main() {
    let s = no_dangle();
    println!("{}", s);
}
```

**2. ç¡®ä¿å¼•ç”¨æœ‰æ•ˆæ€§**:

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

### 1.3 å€Ÿç”¨æ£€æŸ¥å™¨

**å€Ÿç”¨æ£€æŸ¥å™¨** æ˜¯ Rust ç¼–è¯‘å™¨çš„ä¸€éƒ¨åˆ†ï¼Œè´Ÿè´£éªŒè¯æ‰€æœ‰å¼•ç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    // å€Ÿç”¨æ£€æŸ¥å™¨å‘ç° 'b < 'aï¼Œæ‹’ç»ç¼–è¯‘
}
```

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
    // 'a <= 'bï¼Œç¼–è¯‘é€šè¿‡
}
```

---

## 2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

### 2.1 åŸºæœ¬è¯­æ³•

**ç”Ÿå‘½å‘¨æœŸå‚æ•°**ä»¥æ’‡å· `'` å¼€å¤´ï¼Œé€šå¸¸ä½¿ç”¨å°å†™å­—æ¯å‘½åã€‚

```rust
&i32        // å¼•ç”¨
&'a i32     // å¸¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
&'a mut i32 // å¸¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨
```

**ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªæ˜¯æè¿°å¼•ç”¨ä¹‹é—´çš„å…³ç³»**ã€‚

### 2.2 å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

**åŸºæœ¬ç¤ºä¾‹**:

```rust
// éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    
    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

**ç”Ÿå‘½å‘¨æœŸå«ä¹‰**:

- è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ä¸¤ä¸ªå‚æ•°ä¸­ç”Ÿå‘½å‘¨æœŸè¾ƒçŸ­çš„é‚£ä¸ªç›¸åŒ
- å€Ÿç”¨æ£€æŸ¥å™¨ç¡®ä¿è¿™ä¸ªçº¦æŸå¾—åˆ°æ»¡è¶³

**è¿”å›å€¼åªä¸ä¸€ä¸ªå‚æ•°ç›¸å…³**:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

fn main() {
    let sentence = String::from("hello world");
    let word = first_word(&sentence);
    println!("First word: {}", word);
}
```

### 2.3 å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
// ä¸¤ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
fn longest_with_announcement<'a, 'b>(
    x: &'a str,
    y: &'b str,
    ann: &str,
) -> &'a str {
    println!("Announcement! {}", ann);
    x
}

fn main() {
    let string1 = String::from("long string");
    let string2 = String::from("short");
    
    let result = longest_with_announcement(
        string1.as_str(),
        string2.as_str(),
        "Comparing strings",
    );
    
    println!("Longest: {}", result);
}
```

---

## 3. ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

### 3.1 å¼•ç”¨å­—æ®µ

**åŒ…å«å¼•ç”¨çš„ç»“æ„ä½“**:

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    
    println!("Excerpt: {}", i.part);
}
```

**ç”Ÿå‘½å‘¨æœŸçº¦æŸ**:

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let i;
    {
        let novel = String::from("Call me Ishmael. Some years ago...");
        let first_sentence = novel.split('.').next().expect("Could not find a '.'");
        
        i = ImportantExcerpt {
            part: first_sentence,
        };
        
        // âœ… åœ¨è¿™é‡Œä½¿ç”¨ i æ˜¯å¯ä»¥çš„
        println!("Excerpt: {}", i.part);
    }
    
    // âŒ è¿™é‡Œä½¿ç”¨ i ä¼šç¼–è¯‘é”™è¯¯
    // println!("Excerpt: {}", i.part);
}
```

### 3.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rust
// å¤šä¸ªå¼•ç”¨å­—æ®µ
struct Context<'a, 'b> {
    input: &'a str,
    output: &'b str,
}

fn main() {
    let input = String::from("input data");
    let output = String::from("output data");
    
    let ctx = Context {
        input: &input,
        output: &output,
    };
    
    println!("Input: {}, Output: {}", ctx.input, ctx.output);
}
```

### 3.3 æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    // æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸçœç•¥
    fn level(&self) -> i32 {
        3
    }
    
    // æ–¹æ³•è¿”å›å¼•ç”¨
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
    
    // æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ
    fn with_context<'b>(&'a self, context: &'b str) -> &'a str {
        println!("Context: {}", context);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let excerpt = ImportantExcerpt {
        part: first_sentence,
    };
    
    println!("Level: {}", excerpt.level());
    let result = excerpt.announce_and_return_part("Important!");
    println!("Part: {}", result);
}
```

---

## 4. ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

### 4.1 ä¸‰æ¡è§„åˆ™

ç¼–è¯‘å™¨ä½¿ç”¨ä¸‰æ¡è§„åˆ™è‡ªåŠ¨æ¨æ–­ç”Ÿå‘½å‘¨æœŸï¼š

**è§„åˆ™ 1**: æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚

```rust
// fn foo(x: &i32)
// å˜æˆ
// fn foo<'a>(x: &'a i32)

// fn foo(x: &i32, y: &i32)
// å˜æˆ
// fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
```

**è§„åˆ™ 2**: å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚

```rust
// fn foo(x: &i32) -> &i32
// å˜æˆ
// fn foo<'a>(x: &'a i32) -> &'a i32
```

**è§„åˆ™ 3**: å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ `&self` æˆ– `&mut self`ï¼Œé‚£ä¹ˆ `self` çš„ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚

```rust
// impl Foo {
//     fn method(&self, x: &i32) -> &i32
// }
// å˜æˆ
// impl<'a> Foo {
//     fn method<'b>(&'a self, x: &'b i32) -> &'a i32
// }
```

### 4.2 å®é™…åº”ç”¨

```rust
// çœç•¥å‰
// fn first_word<'a>(s: &'a str) -> &'a str {

// çœç•¥åï¼ˆåº”ç”¨è§„åˆ™ 1 å’Œ 2ï¼‰
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

// éœ€è¦æ˜¾å¼æ ‡æ³¨çš„æƒ…å†µ
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let word = first_word("hello world");
    println!("First word: {}", word);
    
    let result = longest("abc", "defgh");
    println!("Longest: {}", result);
}
```

---

## 5. é™æ€ç”Ÿå‘½å‘¨æœŸ

### 5.1 'static ç”Ÿå‘½å‘¨æœŸ

`'static` ç”Ÿå‘½å‘¨æœŸè¡¨ç¤ºå¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆã€‚

```rust
fn main() {
    // å­—ç¬¦ä¸²å­—é¢é‡æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ
    let s: &'static str = "I have a static lifetime.";
    println!("{}", s);
    
    // ç­‰ä»·äº
    let s = "I have a static lifetime.";
    println!("{}", s);
}
```

### 5.2 ä½¿ç”¨åœºæ™¯

**1. å­—ç¬¦ä¸²å­—é¢é‡**:

```rust
fn get_greeting() -> &'static str {
    "Hello, world!"
}

fn main() {
    let greeting = get_greeting();
    println!("{}", greeting);
}
```

**2. å¸¸é‡**:

```rust
const MAX_POINTS: u32 = 100_000;
static LANGUAGE: &str = "Rust";

fn main() {
    println!("Max points: {}", MAX_POINTS);
    println!("Language: {}", LANGUAGE);
}
```

**3. çº¿ç¨‹å®‰å…¨çš„å…¨å±€æ•°æ®**:

```rust
use std::sync::Mutex;

static COUNTER: Mutex<i32> = Mutex::new(0);

fn increment() {
    let mut num = COUNTER.lock().unwrap();
    *num += 1;
}

fn main() {
    increment();
    increment();
    
    println!("Counter: {}", *COUNTER.lock().unwrap());
}
```

**âš ï¸ æ³¨æ„ï¼šä¸è¦æ»¥ç”¨ 'static**:

```rust
// âŒ ä¸å¥½ï¼šè¿‡åº¦ä½¿ç”¨ 'static
// fn process(data: &'static str) -> String {
//     data.to_uppercase()
// }

// âœ… å¥½ï¼šä½¿ç”¨é€‚å½“çš„ç”Ÿå‘½å‘¨æœŸ
fn process(data: &str) -> String {
    data.to_uppercase()
}

fn main() {
    let data = String::from("hello");
    let result = process(&data);
    println!("{}", result);
}
```

---

## 6. ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹

### 6.1 ç»“åˆä½¿ç”¨

```rust
use std::fmt::Display;

// ç”Ÿå‘½å‘¨æœŸ + æ³›å‹ + trait bound
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    
    println!("The longest string is {}", result);
}
```

### 6.2 ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ

```rust
struct Ref<'a, T: 'a> {
    value: &'a T,
}

// Rust 2018+ å¯ä»¥çœç•¥ T: 'a
struct RefModern<'a, T> {
    value: &'a T,
}

fn main() {
    let x = 5;
    let r = Ref { value: &x };
    println!("Value: {}", r.value);
}
```

---

## 7. ç”Ÿå‘½å‘¨æœŸå­ç±»å‹

### 7.1 åå˜å’Œé€†å˜

**ç”Ÿå‘½å‘¨æœŸçš„å­ç±»å‹å…³ç³»**:

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
    
    // result çš„ç”Ÿå‘½å‘¨æœŸå—é™äº string2
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 7.2 ç”Ÿå‘½å‘¨æœŸå…³ç³»

```rust
// 'a æ¯” 'b å­˜æ´»å¾—æ›´ä¹…
fn choose<'a, 'b>(first: &'a str, _second: &'b str) -> &'a str
where
    'b: 'a,  // 'b è‡³å°‘å’Œ 'a ä¸€æ ·é•¿
{
    first
}

fn main() {
    let string1 = String::from("long string");
    let string2 = String::from("short");
    
    let result = choose(string1.as_str(), string2.as_str());
    println!("Result: {}", result);
}
```

---

## 8. é«˜çº§ç”Ÿå‘½å‘¨æœŸç‰¹æ€§

### 8.1 é«˜é˜¶ trait bounds (HRTB)

```rust
// for<'a> è¯­æ³•
trait DoSomething {
    fn do_it(&self, x: &str);
}

fn higher_ranked<F>(f: F)
where
    F: for<'a> Fn(&'a str),
{
    f("hello");
}

fn main() {
    higher_ranked(|x| println!("{}", x));
}
```

**å®é™…åº”ç”¨**:

```rust
trait Parser<'a> {
    type Output;
    fn parse(&self, input: &'a str) -> Self::Output;
}

fn use_parser<P>(parser: P, input: &str)
where
    P: for<'a> Parser<'a>,
{
    let _ = parser.parse(input);
}

struct SimpleParser;

impl<'a> Parser<'a> for SimpleParser {
    type Output = &'a str;
    
    fn parse(&self, input: &'a str) -> Self::Output {
        input
    }
}

fn main() {
    use_parser(SimpleParser, "test");
}
```

### 8.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rust
struct Context<'s> {
    data: &'s str,
}

impl<'s> Context<'s> {
    fn get_data<'a>(&'a self) -> &'a str
    where
        's: 'a,  // 's è‡³å°‘å’Œ 'a ä¸€æ ·é•¿
    {
        self.data
    }
}

fn main() {
    let data = String::from("some data");
    let ctx = Context { data: &data };
    let result = ctx.get_data();
    println!("Data: {}", result);
}
```

---

## 9. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²åˆ†å‰²å™¨

```rust
struct StrSplit<'a, 'b> {
    remainder: Option<&'a str>,
    delimiter: &'b str,
}

impl<'a, 'b> StrSplit<'a, 'b> {
    fn new(haystack: &'a str, delimiter: &'b str) -> Self {
        StrSplit {
            remainder: Some(haystack),
            delimiter,
        }
    }
}

impl<'a, 'b> Iterator for StrSplit<'a, 'b> {
    type Item = &'a str;
    
    fn next(&mut self) -> Option<Self::Item> {
        let remainder = self.remainder.as_mut()?;
        
        if let Some(next_delim) = remainder.find(self.delimiter) {
            let until_delimiter = &remainder[..next_delim];
            *remainder = &remainder[next_delim + self.delimiter.len()..];
            Some(until_delimiter)
        } else {
            self.remainder.take()
        }
    }
}

fn main() {
    let haystack = "a b c d e";
    let letters: Vec<_> = StrSplit::new(haystack, " ").collect();
    
    println!("Letters: {:?}", letters);
}
```

### æ¡ˆä¾‹ 2: ç¼“å­˜ç³»ç»Ÿ

```rust
use std::collections::HashMap;

struct Cache<'a, T> {
    data: HashMap<&'a str, T>,
}

impl<'a, T> Cache<'a, T> {
    fn new() -> Self {
        Cache {
            data: HashMap::new(),
        }
    }
    
    fn get(&self, key: &str) -> Option<&T> {
        self.data.get(key)
    }
    
    fn insert(&mut self, key: &'a str, value: T) {
        self.data.insert(key, value);
    }
}

fn main() {
    let key1 = "user:1";
    let key2 = "user:2";
    
    let mut cache = Cache::new();
    cache.insert(key1, String::from("Alice"));
    cache.insert(key2, String::from("Bob"));
    
    if let Some(name) = cache.get("user:1") {
        println!("User 1: {}", name);
    }
}
```

### æ¡ˆä¾‹ 3: è¿­ä»£å™¨

```rust
struct Iter<'a, T> {
    slice: &'a [T],
    index: usize,
}

impl<'a, T> Iter<'a, T> {
    fn new(slice: &'a [T]) -> Self {
        Iter { slice, index: 0 }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.slice.len() {
            let item = &self.slice[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let iter = Iter::new(&numbers);
    
    for num in iter {
        println!("Number: {}", num);
    }
}
```

### æ¡ˆä¾‹ 4: è‡ªå¼•ç”¨ç»“æ„

```rust
use std::pin::Pin;

struct SelfReferential {
    data: String,
    pointer: *const String,
}

impl SelfReferential {
    fn new(data: String) -> Pin<Box<Self>> {
        let mut boxed = Box::pin(SelfReferential {
            data,
            pointer: std::ptr::null(),
        });
        
        let self_ptr: *const String = &boxed.data;
        
        unsafe {
            let mut_ref = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).pointer = self_ptr;
        }
        
        boxed
    }
    
    fn get_data(&self) -> &str {
        &self.data
    }
    
    fn get_pointer(&self) -> &str {
        unsafe { &*self.pointer }
    }
}

fn main() {
    let s = SelfReferential::new(String::from("hello"));
    println!("Data: {}", s.get_data());
    println!("Pointer: {}", s.get_pointer());
}
```

---

## 10. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 10.1 å¸¸è§é™·é˜±

```rust
// âŒ é™·é˜± 1: è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨
// fn dangle() -> &str {
//     let s = String::from("hello");
//     &s  // ç¼–è¯‘é”™è¯¯ï¼
// }

// âœ… æ­£ç¡®ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    String::from("hello")
}

// âŒ é™·é˜± 2: ç”Ÿå‘½å‘¨æœŸè¿‡é•¿
// fn process<'a>(input: &'a str) -> &'a str {
//     // è¿”å›çš„å¼•ç”¨ç”Ÿå‘½å‘¨æœŸè¢«ä¸å¿…è¦åœ°å»¶é•¿
// }

// âœ… æ­£ç¡®ï¼šä½¿ç”¨é€‚å½“çš„ç”Ÿå‘½å‘¨æœŸ
fn process(input: &str) -> String {
    input.to_uppercase()
}

// âŒ é™·é˜± 3: æ··æ·†ç”Ÿå‘½å‘¨æœŸ
// fn mix<'a>(x: &'a str, y: &str) -> &'a str {
//     y  // ç¼–è¯‘é”™è¯¯ï¼y çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½æ¯” 'a çŸ­
// }

// âœ… æ­£ç¡®ï¼šæ˜ç¡®ç”Ÿå‘½å‘¨æœŸå…³ç³»
fn mix<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'b: 'a,
{
    x
}

fn main() {
    let s = no_dangle();
    println!("{}", s);
    
    let result = process("hello");
    println!("{}", result);
}
```

### 10.2 æœ€ä½³å®è·µ

```rust
use std::fmt::Display;

// âœ… 1. ä¼˜å…ˆä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçœç•¥
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

// âœ… 2. è¿”å›å€¼å°½é‡é¿å…å¼•ç”¨
fn process_data(data: &str) -> String {
    data.to_uppercase()
}

// âœ… 3. ä½¿ç”¨ where å­å¥æé«˜å¯è¯»æ€§
fn complex<'a, T>(x: &'a T, y: &'a T) -> &'a T
where
    T: Display + PartialOrd,
{
    if x > y { x } else { y }
}

// âœ… 4. ç»“æ„ä½“ä¸­é¿å…ä¸å¿…è¦çš„ç”Ÿå‘½å‘¨æœŸ
struct Config {
    name: String,  // æ‹¥æœ‰æ‰€æœ‰æƒ
    port: u16,
}

// âœ… 5. åˆç†ä½¿ç”¨ 'static
const DEFAULT_NAME: &str = "app";

fn get_name() -> &'static str {
    DEFAULT_NAME
}

fn main() {
    let word = first_word("hello world");
    println!("First word: {}", word);
    
    let result = process_data("test");
    println!("Processed: {}", result);
    
    println!("Name: {}", get_name());
}
```

---

## 11. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç”Ÿå‘½å‘¨æœŸåŸºç¡€**
   - âœ… ç”Ÿå‘½å‘¨æœŸç¡®ä¿å¼•ç”¨æœ‰æ•ˆ
   - âœ… å€Ÿç”¨æ£€æŸ¥å™¨éªŒè¯ç”Ÿå‘½å‘¨æœŸ
   - âœ… é˜²æ­¢æ‚¬å‚å¼•ç”¨

2. **ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨**
   - âœ… ä½¿ç”¨ `'a` è¯­æ³•
   - âœ… æè¿°å¼•ç”¨é—´çš„å…³ç³»
   - âœ… ä¸æ”¹å˜å®é™…ç”Ÿå‘½å‘¨æœŸ

3. **çœç•¥è§„åˆ™**
   - âœ… ä¸‰æ¡è‡ªåŠ¨æ¨æ–­è§„åˆ™
   - âœ… å¤§å¤šæ•°æƒ…å†µå¯çœç•¥
   - âœ… ç¼–è¯‘å™¨è‡ªåŠ¨åº”ç”¨

4. **é«˜çº§ç‰¹æ€§**
   - âœ… 'static ç”Ÿå‘½å‘¨æœŸ
   - âœ… ç”Ÿå‘½å‘¨æœŸå­ç±»å‹
   - âœ… HRTB (é«˜é˜¶ trait bounds)

5. **æœ€ä½³å®è·µ**
   - âœ… ä¼˜å…ˆçœç•¥ç”Ÿå‘½å‘¨æœŸ
   - âœ… è¿”å›å€¼é¿å…å¼•ç”¨
   - âœ… åˆç†ä½¿ç”¨ 'static
   - âœ… ç»“æ„ä½“é¿å…è¿‡å¤šå¼•ç”¨

### ä¸‹ä¸€æ­¥å­¦ä¹ 

å­¦å®Œæœ¬æŒ‡å—åï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **[3.1 ç±»å‹è½¬æ¢å‚è€ƒ](../tier_03_references/01_ç±»å‹è½¬æ¢å‚è€ƒ.md)** - ç±»å‹è½¬æ¢æŠ€æœ¯
2. **[3.2 ç±»å‹å‹å˜å‚è€ƒ](../tier_03_references/02_ç±»å‹å‹å˜å‚è€ƒ.md)** - å‹å˜å’Œå­ç±»å‹
3. **[3.3 åˆ†æ´¾æœºåˆ¶å‚è€ƒ](../tier_03_references/03_åˆ†æ´¾æœºåˆ¶å‚è€ƒ.md)** - é™æ€å’ŒåŠ¨æ€åˆ†å‘
4. **[4.1 é«˜çº§ç±»å‹ç‰¹æ€§](../tier_04_advanced/01_é«˜çº§ç±»å‹ç‰¹æ€§.md)** - é«˜çº§ç±»å‹æŠ€å·§

---

## 12. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Chapter 10.3 (Lifetimes)](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)
- [Rust Reference - Lifetimes](https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds)
- [Rustonomicon - Lifetimes](https://doc.rust-lang.org/nomicon/lifetimes.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)
- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](./03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](./04_Traitç³»ç»ŸæŒ‡å—.md)
- [1.0 é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æ·±åº¦åˆ†æ**:

- [ç”Ÿå‘½å‘¨æœŸåŸç†](../analysis/rust_theory/lifetime_theory.md)
- [å€Ÿç”¨æ£€æŸ¥å™¨è¯¦è§£](../analysis/rust_theory/borrow_checker.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚

---

**ğŸ‰ æ­å–œå®Œæˆç”Ÿå‘½å‘¨æœŸæŒ‡å—å­¦ä¹ ï¼Tier 2 å…¨éƒ¨å®Œæˆï¼** ğŸ¦€
