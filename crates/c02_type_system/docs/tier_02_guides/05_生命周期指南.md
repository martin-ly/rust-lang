# 2.5 Rust ç±»å‹ç³»ç»Ÿ - ç”Ÿå‘½å‘¨æœŸæŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚  
> **æ–‡æ¡£å®šä½**: ç³»ç»Ÿå­¦ä¹  Rust ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md), [2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 6-8 å°æ—¶  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [2.5 Rust ç±»å‹ç³»ç»Ÿ - ç”Ÿå‘½å‘¨æœŸæŒ‡å—](#25-rust-ç±»å‹ç³»ç»Ÿ---ç”Ÿå‘½å‘¨æœŸæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“Š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°](#1-ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ](#11-ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ)
    - [1.2 ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ](#12-ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ)
    - [1.3 å€Ÿç”¨æ£€æŸ¥å™¨](#13-å€Ÿç”¨æ£€æŸ¥å™¨)
  - [2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨](#2-ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨)
    - [2.1 åŸºæœ¬è¯­æ³•](#21-åŸºæœ¬è¯­æ³•)
    - [2.2 å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#22-å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
    - [2.3 å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°](#23-å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°)
  - [3. ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#3-ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
    - [3.1 å¼•ç”¨å­—æ®µ](#31-å¼•ç”¨å­—æ®µ)
    - [3.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ](#32-ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
    - [3.3 æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#33-æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
  - [4. ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™](#4-ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™)
    - [4.1 ä¸‰æ¡è§„åˆ™](#41-ä¸‰æ¡è§„åˆ™)
    - [4.2 å®é™…åº”ç”¨](#42-å®é™…åº”ç”¨)
  - [5. é™æ€ç”Ÿå‘½å‘¨æœŸ](#5-é™æ€ç”Ÿå‘½å‘¨æœŸ)
    - [5.1 'static ç”Ÿå‘½å‘¨æœŸ](#51-static-ç”Ÿå‘½å‘¨æœŸ)
    - [5.2 ä½¿ç”¨åœºæ™¯](#52-ä½¿ç”¨åœºæ™¯)
    - [5.3 'static vs \&'static è¯¦è§£](#53-static-vs-static-è¯¦è§£)
    - [5.4 T: 'static çº¦æŸæ·±åº¦è§£æ](#54-t-static-çº¦æŸæ·±åº¦è§£æ)
    - [5.5 'static å¸¸è§è¯¯åŒº](#55-static-å¸¸è§è¯¯åŒº)
    - [5.6 'static çš„å®é™…åº”ç”¨](#56-static-çš„å®é™…åº”ç”¨)
  - [6. ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹](#6-ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹)
    - [6.1 ç»“åˆä½¿ç”¨](#61-ç»“åˆä½¿ç”¨)
    - [6.2 ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ](#62-ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ)
  - [7. ç”Ÿå‘½å‘¨æœŸå­ç±»å‹](#7-ç”Ÿå‘½å‘¨æœŸå­ç±»å‹)
    - [7.1 åå˜å’Œé€†å˜](#71-åå˜å’Œé€†å˜)
    - [7.2 ç”Ÿå‘½å‘¨æœŸå…³ç³»](#72-ç”Ÿå‘½å‘¨æœŸå…³ç³»)
  - [8. é«˜çº§ç”Ÿå‘½å‘¨æœŸç‰¹æ€§](#8-é«˜çº§ç”Ÿå‘½å‘¨æœŸç‰¹æ€§)
    - [8.1 é«˜é˜¶ trait bounds (HRTB)](#81-é«˜é˜¶-trait-bounds-hrtb)
    - [8.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ](#82-ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
    - [8.3 ç”Ÿå‘½å‘¨æœŸä¸å†…éƒ¨å¯å˜æ€§](#83-ç”Ÿå‘½å‘¨æœŸä¸å†…éƒ¨å¯å˜æ€§)
    - [8.4 ç”Ÿå‘½å‘¨æœŸä¸é—­åŒ…](#84-ç”Ÿå‘½å‘¨æœŸä¸é—­åŒ…)
    - [8.5 ç”Ÿå‘½å‘¨æœŸè§„é¿æŠ€å·§](#85-ç”Ÿå‘½å‘¨æœŸè§„é¿æŠ€å·§)
    - [8.6 ç”Ÿå‘½å‘¨æœŸä¸è¿­ä»£å™¨](#86-ç”Ÿå‘½å‘¨æœŸä¸è¿­ä»£å™¨)
    - [8.7 ç”Ÿå‘½å‘¨æœŸä¸å¼‚æ­¥](#87-ç”Ÿå‘½å‘¨æœŸä¸å¼‚æ­¥)
  - [9. å®æˆ˜æ¡ˆä¾‹](#9-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²åˆ†å‰²å™¨](#æ¡ˆä¾‹-1-å­—ç¬¦ä¸²åˆ†å‰²å™¨)
    - [æ¡ˆä¾‹ 2: ç¼“å­˜ç³»ç»Ÿ](#æ¡ˆä¾‹-2-ç¼“å­˜ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 3: è¿­ä»£å™¨](#æ¡ˆä¾‹-3-è¿­ä»£å™¨)
    - [æ¡ˆä¾‹ 4: è‡ªå¼•ç”¨ç»“æ„](#æ¡ˆä¾‹-4-è‡ªå¼•ç”¨ç»“æ„)
  - [10. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#10-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [10.1 å¸¸è§é™·é˜±](#101-å¸¸è§é™·é˜±)
    - [10.2 æœ€ä½³å®è·µ](#102-æœ€ä½³å®è·µ)
    - [10.3 ç”Ÿå‘½å‘¨æœŸè°ƒè¯•æŠ€å·§](#103-ç”Ÿå‘½å‘¨æœŸè°ƒè¯•æŠ€å·§)
  - [11. æ€»ç»“](#11-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )
  - [12. å‚è€ƒèµ„æº](#12-å‚è€ƒèµ„æº)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… **ç†è§£** ç”Ÿå‘½å‘¨æœŸçš„æ ¸å¿ƒæ¦‚å¿µ
- âœ… **æŒæ¡** ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•
- âœ… **ç†è§£** å€Ÿç”¨æ£€æŸ¥å™¨çš„å·¥ä½œåŸç†
- âœ… **åº”ç”¨** ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
- âœ… **æŒæ¡** ç»“æ„ä½“å’Œæ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
- âœ… **ç†è§£** ç”Ÿå‘½å‘¨æœŸå­ç±»å‹å’Œ HRTB
- âœ… **è§£å†³** ç”Ÿå‘½å‘¨æœŸç›¸å…³çš„ç¼–è¯‘é”™è¯¯

---

## ğŸ“Š ç« èŠ‚æ¦‚è§ˆ

| ç« èŠ‚ | å†…å®¹ | éš¾åº¦ | é¢„è®¡æ—¶é—´ |
|------|------|------|---------|
| 1. ç”Ÿå‘½å‘¨æœŸæ¦‚è¿° | åŸºæœ¬æ¦‚å¿µ | ğŸŸ¢ ç®€å• | 30åˆ†é’Ÿ |
| 2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ | æ ‡æ³¨è¯­æ³• | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ |
| 3. ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ | ç»“æ„ä½“ä¸­çš„å¼•ç”¨ | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ |
| 4. çœç•¥è§„åˆ™ | ç”Ÿå‘½å‘¨æœŸçœç•¥ | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ |
| 5. é™æ€ç”Ÿå‘½å‘¨æœŸ | 'static è¯¦è§£ | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ |
| 6. ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ | ç»“åˆä½¿ç”¨ | ğŸ”´ é«˜çº§ | 40åˆ†é’Ÿ |
| 7. ç”Ÿå‘½å‘¨æœŸå­ç±»å‹ | åå˜å’Œé€†å˜ | ğŸ”´ é«˜çº§ | 50åˆ†é’Ÿ |
| 8. é«˜çº§ç‰¹æ€§ | HRTB ç­‰ | ğŸ”´ é«˜çº§ | 40åˆ†é’Ÿ |
| 9. å®æˆ˜æ¡ˆä¾‹ | ç»¼åˆåº”ç”¨ | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ |
| 10. æœ€ä½³å®è·µ | é™·é˜±ä¸å®è·µ | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ |

**æ€»è®¡**: çº¦ 6-8 å°æ—¶

---

## 1. ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ

**ç”Ÿå‘½å‘¨æœŸ** æ˜¯å¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸã€‚æ¯ä¸ªå¼•ç”¨éƒ½æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå¤§å¤šæ•°æ—¶å€™æ˜¯éšå¼çš„ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- ğŸ”’ ç¡®ä¿å¼•ç”¨å§‹ç»ˆæœ‰æ•ˆ
- â±ï¸ é˜²æ­¢æ‚¬å‚å¼•ç”¨
- ğŸ›¡ï¸ å†…å­˜å®‰å…¨ä¿è¯

**ç¤ºä¾‹**:

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    // println!("r: {}", r); // ç¼–è¯‘é”™è¯¯ï¼x å·²è¢«é”€æ¯
}                         // ---------+
```

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸ

**1. é˜²æ­¢æ‚¬å‚å¼•ç”¨**:

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼šæ‚¬å‚å¼•ç”¨
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // s å°†åœ¨å‡½æ•°ç»“æŸæ—¶è¢«é”€æ¯
// }

// âœ… æ­£ç¡®ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // ç§»åŠ¨æ‰€æœ‰æƒ
}

fn main() {
    let s = no_dangle();
    println!("{}", s);
}
```

**2. ç¡®ä¿å¼•ç”¨æœ‰æ•ˆæ€§**:

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

### 1.3 å€Ÿç”¨æ£€æŸ¥å™¨

**å€Ÿç”¨æ£€æŸ¥å™¨** æ˜¯ Rust ç¼–è¯‘å™¨çš„ä¸€éƒ¨åˆ†ï¼Œè´Ÿè´£éªŒè¯æ‰€æœ‰å¼•ç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    // å€Ÿç”¨æ£€æŸ¥å™¨å‘ç° 'b < 'aï¼Œæ‹’ç»ç¼–è¯‘
}
```

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
    // 'a <= 'bï¼Œç¼–è¯‘é€šè¿‡
}
```

---

## 2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

### 2.1 åŸºæœ¬è¯­æ³•

**ç”Ÿå‘½å‘¨æœŸå‚æ•°**ä»¥æ’‡å· `'` å¼€å¤´ï¼Œé€šå¸¸ä½¿ç”¨å°å†™å­—æ¯å‘½åã€‚

```rust
&i32        // å¼•ç”¨
&'a i32     // å¸¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
&'a mut i32 // å¸¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨
```

**ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªæ˜¯æè¿°å¼•ç”¨ä¹‹é—´çš„å…³ç³»**ã€‚

### 2.2 å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

**åŸºæœ¬ç¤ºä¾‹**:

```rust
// éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    
    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

**ç”Ÿå‘½å‘¨æœŸå«ä¹‰**:

- è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ä¸¤ä¸ªå‚æ•°ä¸­ç”Ÿå‘½å‘¨æœŸè¾ƒçŸ­çš„é‚£ä¸ªç›¸åŒ
- å€Ÿç”¨æ£€æŸ¥å™¨ç¡®ä¿è¿™ä¸ªçº¦æŸå¾—åˆ°æ»¡è¶³

**è¿”å›å€¼åªä¸ä¸€ä¸ªå‚æ•°ç›¸å…³**:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

fn main() {
    let sentence = String::from("hello world");
    let word = first_word(&sentence);
    println!("First word: {}", word);
}
```

### 2.3 å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
// ä¸¤ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
fn longest_with_announcement<'a, 'b>(
    x: &'a str,
    y: &'b str,
    ann: &str,
) -> &'a str {
    println!("Announcement! {}", ann);
    x
}

fn main() {
    let string1 = String::from("long string");
    let string2 = String::from("short");
    
    let result = longest_with_announcement(
        string1.as_str(),
        string2.as_str(),
        "Comparing strings",
    );
    
    println!("Longest: {}", result);
}
```

---

## 3. ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

### 3.1 å¼•ç”¨å­—æ®µ

**åŒ…å«å¼•ç”¨çš„ç»“æ„ä½“**:

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    
    println!("Excerpt: {}", i.part);
}
```

**ç”Ÿå‘½å‘¨æœŸçº¦æŸ**:

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let i;
    {
        let novel = String::from("Call me Ishmael. Some years ago...");
        let first_sentence = novel.split('.').next().expect("Could not find a '.'");
        
        i = ImportantExcerpt {
            part: first_sentence,
        };
        
        // âœ… åœ¨è¿™é‡Œä½¿ç”¨ i æ˜¯å¯ä»¥çš„
        println!("Excerpt: {}", i.part);
    }
    
    // âŒ è¿™é‡Œä½¿ç”¨ i ä¼šç¼–è¯‘é”™è¯¯
    // println!("Excerpt: {}", i.part);
}
```

### 3.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rust
// å¤šä¸ªå¼•ç”¨å­—æ®µ
struct Context<'a, 'b> {
    input: &'a str,
    output: &'b str,
}

fn main() {
    let input = String::from("input data");
    let output = String::from("output data");
    
    let ctx = Context {
        input: &input,
        output: &output,
    };
    
    println!("Input: {}, Output: {}", ctx.input, ctx.output);
}
```

### 3.3 æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    // æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸçœç•¥
    fn level(&self) -> i32 {
        3
    }
    
    // æ–¹æ³•è¿”å›å¼•ç”¨
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
    
    // æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ
    fn with_context<'b>(&'a self, context: &'b str) -> &'a str {
        println!("Context: {}", context);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let excerpt = ImportantExcerpt {
        part: first_sentence,
    };
    
    println!("Level: {}", excerpt.level());
    let result = excerpt.announce_and_return_part("Important!");
    println!("Part: {}", result);
}
```

---

## 4. ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

### 4.1 ä¸‰æ¡è§„åˆ™

ç¼–è¯‘å™¨ä½¿ç”¨ä¸‰æ¡è§„åˆ™è‡ªåŠ¨æ¨æ–­ç”Ÿå‘½å‘¨æœŸï¼š

**è§„åˆ™ 1**: æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚

```rust
// fn foo(x: &i32)
// å˜æˆ
// fn foo<'a>(x: &'a i32)

// fn foo(x: &i32, y: &i32)
// å˜æˆ
// fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
```

**è§„åˆ™ 2**: å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚

```rust
// fn foo(x: &i32) -> &i32
// å˜æˆ
// fn foo<'a>(x: &'a i32) -> &'a i32
```

**è§„åˆ™ 3**: å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ `&self` æˆ– `&mut self`ï¼Œé‚£ä¹ˆ `self` çš„ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚

```rust
// impl Foo {
//     fn method(&self, x: &i32) -> &i32
// }
// å˜æˆ
// impl<'a> Foo {
//     fn method<'b>(&'a self, x: &'b i32) -> &'a i32
// }
```

### 4.2 å®é™…åº”ç”¨

```rust
// çœç•¥å‰
// fn first_word<'a>(s: &'a str) -> &'a str {

// çœç•¥åï¼ˆåº”ç”¨è§„åˆ™ 1 å’Œ 2ï¼‰
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

// éœ€è¦æ˜¾å¼æ ‡æ³¨çš„æƒ…å†µ
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let word = first_word("hello world");
    println!("First word: {}", word);
    
    let result = longest("abc", "defgh");
    println!("Longest: {}", result);
}
```

---

## 5. é™æ€ç”Ÿå‘½å‘¨æœŸ

### 5.1 'static ç”Ÿå‘½å‘¨æœŸ

`'static` ç”Ÿå‘½å‘¨æœŸè¡¨ç¤ºå¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆã€‚

```rust
fn main() {
    // å­—ç¬¦ä¸²å­—é¢é‡æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ
    let s: &'static str = "I have a static lifetime.";
    println!("{}", s);
    
    // ç­‰ä»·äº
    let s = "I have a static lifetime.";
    println!("{}", s);
}
```

### 5.2 ä½¿ç”¨åœºæ™¯

**1. å­—ç¬¦ä¸²å­—é¢é‡**:

```rust
fn get_greeting() -> &'static str {
    "Hello, world!"
}

fn main() {
    let greeting = get_greeting();
    println!("{}", greeting);
}
```

**2. å¸¸é‡**:

```rust
const MAX_POINTS: u32 = 100_000;
static LANGUAGE: &str = "Rust";

fn main() {
    println!("Max points: {}", MAX_POINTS);
    println!("Language: {}", LANGUAGE);
}
```

**3. çº¿ç¨‹å®‰å…¨çš„å…¨å±€æ•°æ®**:

```rust
use std::sync::Mutex;

static COUNTER: Mutex<i32> = Mutex::new(0);

fn increment() {
    let mut num = COUNTER.lock().unwrap();
    *num += 1;
}

fn main() {
    increment();
    increment();
    
    println!("Counter: {}", *COUNTER.lock().unwrap());
}
```

**âš ï¸ æ³¨æ„ï¼šä¸è¦æ»¥ç”¨ 'static**:

```rust
// âŒ ä¸å¥½ï¼šè¿‡åº¦ä½¿ç”¨ 'static
// fn process(data: &'static str) -> String {
//     data.to_uppercase()
// }

// âœ… å¥½ï¼šä½¿ç”¨é€‚å½“çš„ç”Ÿå‘½å‘¨æœŸ
fn process(data: &str) -> String {
    data.to_uppercase()
}

fn main() {
    let data = String::from("hello");
    let result = process(&data);
    println!("{}", result);
}
```

### 5.3 'static vs &'static è¯¦è§£

**æ ¸å¿ƒåŒºåˆ«**:

```rust
// 'static æ˜¯ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸ
// &'static æ˜¯ä¸€ä¸ªå…·æœ‰'staticç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨

// 1. å­—ç¬¦ä¸²å­—é¢é‡ï¼š&'static str
let s1: &'static str = "I am 'static";

// 2. static å˜é‡å¯ä»¥æ˜¯ä»»æ„ç±»å‹
static BYTES: [u8; 3] = [1, 2, 3];
static mut COUNTER: i32 = 0;

// 3. æ‹¥æœ‰æ‰€æœ‰æƒçš„æ•°æ®ä¸æ˜¯ 'static
fn not_static() {
    let owned = String::from("not static");  // owned ä¸æ˜¯ 'static
    // let ref: &'static str = &owned;  // âŒ ç¼–è¯‘é”™è¯¯
}

fn main() {
    println!("{}", s1);
    println!("{:?}", BYTES);
}
```

**Box::leak åˆ›å»º 'static å¼•ç”¨**:

```rust
fn create_static_str() -> &'static str {
    let s = String::from("Hello, world!");
    // Box::leak æ•…æ„æ³„æ¼å†…å­˜ï¼Œè¿”å›'staticå¼•ç”¨
    Box::leak(s.into_boxed_str())
}

fn create_static_vec() -> &'static mut Vec<i32> {
    let vec = vec![1, 2, 3];
    Box::leak(Box::new(vec))
}

fn main() {
    let s = create_static_str();
    println!("{}", s);
    
    let v = create_static_vec();
    v.push(4);
    println!("{:?}", v);
}
```

### 5.4 T: 'static çº¦æŸæ·±åº¦è§£æ

`T: 'static` **ä¸æ˜¯**"Tå¿…é¡»æ˜¯'static"ï¼Œè€Œæ˜¯"Tä¸èƒ½åŒ…å«é'staticå¼•ç”¨"ã€‚

```rust
use std::fmt::Display;

// T: 'static æ„å‘³ç€ T ä¸èƒ½åŒ…å«é'staticå¼•ç”¨
fn print_type<T: Display + 'static>(t: T) {
    println!("{}", t);
}

fn main() {
    // âœ… i32 ä¸åŒ…å«å¼•ç”¨
    print_type(42);
    
    // âœ… String æ‹¥æœ‰æ‰€æœ‰æƒï¼Œä¸åŒ…å«é'staticå¼•ç”¨
    print_type(String::from("owned"));
    
    // âœ… 'static å¼•ç”¨
    print_type("static str");
    
    // âŒ &String æ˜¯é'staticå¼•ç”¨
    let s = String::from("temporary");
    // print_type(&s);  // ç¼–è¯‘é”™è¯¯
}
```

**å®é™…åº”ç”¨ï¼šçº¿ç¨‹é—´ä¼ é€’æ•°æ®**:

```rust
use std::thread;

// T: 'static ä¿è¯å¯ä»¥è·¨çº¿ç¨‹
fn spawn_with_data<T: Send + 'static>(data: T) {
    thread::spawn(move || {
        // ä½¿ç”¨ data
    });
}

fn main() {
    // âœ… String æ»¡è¶³ 'static
    spawn_with_data(String::from("owned data"));
    
    // âŒ &str ä¸æ»¡è¶³ 'staticï¼ˆé™¤éæ˜¯å­—ç¬¦ä¸²å­—é¢é‡ï¼‰
    let s = String::from("temporary");
    // spawn_with_data(&s);  // ç¼–è¯‘é”™è¯¯
    
    // âœ… ä½†å¯ä»¥ clone
    spawn_with_data(s.clone());
}
```

### 5.5 'static å¸¸è§è¯¯åŒº

**è¯¯åŒº 1: 'static æ„å‘³ç€æ°¸è¿œå­˜æ´»**:

```rust
// âŒ é”™è¯¯ç†è§£
fn wrong() -> &'static str {
    let s = String::from("not static");
    // &s  // âŒ ç¼–è¯‘é”™è¯¯ï¼šs ä¸æ˜¯'static
    
    // å³ä½¿ä½¿ç”¨ Box::leakï¼Œä¹Ÿæ˜¯æœ‰æ„æ³„æ¼å†…å­˜
    Box::leak(s.into_boxed_str())
}

// âœ… æ­£ç¡®ç†è§£ï¼šåªæœ‰çœŸæ­£å­˜æ´»æ•´ä¸ªç¨‹åºçš„æ•°æ®æ‰æ˜¯ 'static
fn correct() -> &'static str {
    "This is truly static"
}
```

**è¯¯åŒº 2: æ‰€æœ‰ä¸œè¥¿éƒ½éœ€è¦ 'static**:

```rust
// âŒ è¿‡åº¦é™åˆ¶
fn bad_api(data: &'static str) -> usize {
    data.len()
}

// âœ… ä½¿ç”¨æ›´å®½æ¾çš„ç”Ÿå‘½å‘¨æœŸ
fn good_api(data: &str) -> usize {
    data.len()
}

fn main() {
    let owned = String::from("temporary");
    
    // bad_api(&owned);  // âŒ ä¸èƒ½è°ƒç”¨
    let len = good_api(&owned);  // âœ… å¯ä»¥è°ƒç”¨
    println!("Length: {}", len);
}
```

**è¯¯åŒº 3: static å˜é‡éƒ½æ˜¯ä¸å¯å˜çš„**:

```rust
// static å˜é‡é»˜è®¤ä¸å¯å˜
static IMMUTABLE: i32 = 42;

// ä½†å¯ä»¥å£°æ˜ä¸º mutï¼ˆéœ€è¦ unsafe è®¿é—®ï¼‰
static mut MUTABLE: i32 = 0;

unsafe fn increment() {
    MUTABLE += 1;
}

fn main() {
    println!("Immutable: {}", IMMUTABLE);
    
    unsafe {
        increment();
        println!("Mutable: {}", MUTABLE);
    }
}
```

### 5.6 'static çš„å®é™…åº”ç”¨

**åº”ç”¨ 1: å…¨å±€é…ç½®ï¼ˆæ¨èä½¿ç”¨ OnceLockï¼‰**:

```rust
use std::sync::OnceLock;

static CONFIG: OnceLock<AppConfig> = OnceLock::new();

struct AppConfig {
    app_name: String,
    version: String,
    max_connections: usize,
}

fn init_config() {
    CONFIG.set(AppConfig {
        app_name: String::from("MyApp"),
        version: String::from("1.0.0"),
        max_connections: 100,
    }).expect("Config already initialized");
}

fn get_config() -> &'static AppConfig {
    CONFIG.get().expect("Config not initialized")
}

fn main() {
    init_config();
    
    let config = get_config();
    println!("{} v{}", config.app_name, config.version);
    println!("Max connections: {}", config.max_connections);
}
```

**åº”ç”¨ 2: ç¼“å­˜å’Œæƒ°æ€§åˆå§‹åŒ–**:

```rust
use std::sync::OnceLock;

static EXPENSIVE_DATA: OnceLock<Vec<String>> = OnceLock::new();

fn get_data() -> &'static Vec<String> {
    EXPENSIVE_DATA.get_or_init(|| {
        println!("Computing expensive data...");
        vec![
            String::from("data1"),
            String::from("data2"),
            String::from("data3"),
        ]
    })
}

fn main() {
    println!("First call:");
    let data1 = get_data();
    println!("Data: {:?}", data1);
    
    println!("\nSecond call:");
    let data2 = get_data();  // ä¸ä¼šé‡æ–°è®¡ç®—
    println!("Data: {:?}", data2);
    
    println!("\nSame instance: {}", std::ptr::eq(data1, data2));
}
```

**åº”ç”¨ 3: é¿å…'staticçš„æ›¿ä»£æ–¹æ¡ˆ**:

```rust
use std::rc::Rc;
use std::sync::Arc;

// æ–¹æ¡ˆ 1: ä½¿ç”¨ Rc (å•çº¿ç¨‹)
fn use_rc() {
    let data = Rc::new(String::from("shared data"));
    let data1 = Rc::clone(&data);
    let data2 = Rc::clone(&data);
    
    println!("Count: {}", Rc::strong_count(&data));
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨ Arc (å¤šçº¿ç¨‹)
fn use_arc() {
    let data = Arc::new(String::from("shared data"));
    let data1 = Arc::clone(&data);
    
    std::thread::spawn(move || {
        println!("Thread: {}", data1);
    });
    
    println!("Main: {}", data);
}

// æ–¹æ¡ˆ 3: ä¼ é€’æ‰€æœ‰æƒ
fn take_ownership(data: String) {
    println!("{}", data);
}

fn main() {
    use_rc();
    use_arc();
    
    let owned = String::from("owned data");
    take_ownership(owned);
}
```

---

## 6. ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹

### 6.1 ç»“åˆä½¿ç”¨

```rust
use std::fmt::Display;

// ç”Ÿå‘½å‘¨æœŸ + æ³›å‹ + trait bound
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    
    println!("The longest string is {}", result);
}
```

### 6.2 ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ

```rust
struct Ref<'a, T: 'a> {
    value: &'a T,
}

// Rust 2018+ å¯ä»¥çœç•¥ T: 'a
struct RefModern<'a, T> {
    value: &'a T,
}

fn main() {
    let x = 5;
    let r = Ref { value: &x };
    println!("Value: {}", r.value);
}
```

---

## 7. ç”Ÿå‘½å‘¨æœŸå­ç±»å‹

### 7.1 åå˜å’Œé€†å˜

**ç”Ÿå‘½å‘¨æœŸçš„å­ç±»å‹å…³ç³»**:

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
    
    // result çš„ç”Ÿå‘½å‘¨æœŸå—é™äº string2
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 7.2 ç”Ÿå‘½å‘¨æœŸå…³ç³»

```rust
// 'a æ¯” 'b å­˜æ´»å¾—æ›´ä¹…
fn choose<'a, 'b>(first: &'a str, _second: &'b str) -> &'a str
where
    'b: 'a,  // 'b è‡³å°‘å’Œ 'a ä¸€æ ·é•¿
{
    first
}

fn main() {
    let string1 = String::from("long string");
    let string2 = String::from("short");
    
    let result = choose(string1.as_str(), string2.as_str());
    println!("Result: {}", result);
}
```

---

## 8. é«˜çº§ç”Ÿå‘½å‘¨æœŸç‰¹æ€§

### 8.1 é«˜é˜¶ trait bounds (HRTB)

```rust
// for<'a> è¯­æ³•
trait DoSomething {
    fn do_it(&self, x: &str);
}

fn higher_ranked<F>(f: F)
where
    F: for<'a> Fn(&'a str),
{
    f("hello");
}

fn main() {
    higher_ranked(|x| println!("{}", x));
}
```

**å®é™…åº”ç”¨**:

```rust
trait Parser<'a> {
    type Output;
    fn parse(&self, input: &'a str) -> Self::Output;
}

fn use_parser<P>(parser: P, input: &str)
where
    P: for<'a> Parser<'a>,
{
    let _ = parser.parse(input);
}

struct SimpleParser;

impl<'a> Parser<'a> for SimpleParser {
    type Output = &'a str;
    
    fn parse(&self, input: &'a str) -> Self::Output {
        input
    }
}

fn main() {
    use_parser(SimpleParser, "test");
}
```

### 8.2 ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rust
struct Context<'s> {
    data: &'s str,
}

impl<'s> Context<'s> {
    fn get_data<'a>(&'a self) -> &'a str
    where
        's: 'a,  // 's è‡³å°‘å’Œ 'a ä¸€æ ·é•¿
    {
        self.data
    }
}

fn main() {
    let data = String::from("some data");
    let ctx = Context { data: &data };
    let result = ctx.get_data();
    println!("Data: {}", result);
}
```

### 8.3 ç”Ÿå‘½å‘¨æœŸä¸å†…éƒ¨å¯å˜æ€§

å†…éƒ¨å¯å˜æ€§æ¨¡å¼ï¼ˆå¦‚`Cell`/`RefCell`ï¼‰ä¸ç”Ÿå‘½å‘¨æœŸçš„äº¤äº’ï¼š

```rust
use std::cell::RefCell;

struct Data<'a> {
    value: RefCell<&'a str>,
}

impl<'a> Data<'a> {
    fn new(s: &'a str) -> Self {
        Data {
            value: RefCell::new(s),
        }
    }
    
    fn update(&self, new_value: &'a str) {
        *self.value.borrow_mut() = new_value;
    }
    
    fn get(&self) -> &'a str {
        // âš ï¸ æ³¨æ„ï¼šä¸èƒ½ç›´æ¥è¿”å›å€Ÿç”¨
        // éœ€è¦unsafeæˆ–è€…è¿”å›æ‹·è´
        unsafe { *self.value.as_ptr() }
    }
}

fn main() {
    let s1 = String::from("hello");
    let s2 = String::from("world");
    
    let data = Data::new(&s1);
    println!("Initial: {}", data.get());
    
    data.update(&s2);
    println!("Updated: {}", data.get());
}
```

### 8.4 ç”Ÿå‘½å‘¨æœŸä¸é—­åŒ…

é—­åŒ…æ•è·å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸè§„åˆ™ï¼š

```rust
// é—­åŒ…æ•è·å¼•ç”¨
fn with_closure<'a>(data: &'a str) -> impl Fn() -> &'a str {
    move || data
}

// é—­åŒ…ä¸HRTB
fn apply_to_refs<F>(f: F, x: &str, y: &str)
where
    F: for<'a> Fn(&'a str) -> &'a str,
{
    println!("x: {}", f(x));
    println!("y: {}", f(y));
}

fn main() {
    let data = String::from("captured");
    let closure = with_closure(&data);
    println!("{}", closure());
    
    apply_to_refs(|s| s, "hello", "world");
}
```

### 8.5 ç”Ÿå‘½å‘¨æœŸè§„é¿æŠ€å·§

**æŠ€å·§ 1: ä½¿ç”¨ `Rc`/`Arc` é¿å…ç”Ÿå‘½å‘¨æœŸ**

```rust
use std::rc::Rc;

struct Node {
    value: i32,
    children: Vec<Rc<Node>>,
}

impl Node {
    fn new(value: i32) -> Rc<Self> {
        Rc::new(Node {
            value,
            children: Vec::new(),
        })
    }
    
    fn add_child(self: &mut Rc<Node>, child: Rc<Node>) {
        Rc::get_mut(self).unwrap().children.push(child);
    }
}

fn main() {
    let mut root = Node::new(1);
    let child1 = Node::new(2);
    let child2 = Node::new(3);
    
    root.add_child(child1);
    root.add_child(child2);
    
    println!("Root: {}", root.value);
    println!("Children: {}", root.children.len());
}
```

**æŠ€å·§ 2: é‡æ„ä¸ºç´¢å¼•è€Œéå¼•ç”¨**:

```rust
// âŒ ä½¿ç”¨å¼•ç”¨ï¼ˆç”Ÿå‘½å‘¨æœŸå¤æ‚ï¼‰
struct BadDesign<'a> {
    items: Vec<String>,
    current: Option<&'a String>,
}

// âœ… ä½¿ç”¨ç´¢å¼•ï¼ˆæ— ç”Ÿå‘½å‘¨æœŸï¼‰
struct GoodDesign {
    items: Vec<String>,
    current_index: Option<usize>,
}

impl GoodDesign {
    fn new() -> Self {
        GoodDesign {
            items: Vec::new(),
            current_index: None,
        }
    }
    
    fn add(&mut self, item: String) {
        self.items.push(item);
    }
    
    fn set_current(&mut self, index: usize) {
        if index < self.items.len() {
            self.current_index = Some(index);
        }
    }
    
    fn get_current(&self) -> Option<&String> {
        self.current_index.and_then(|i| self.items.get(i))
    }
}

fn main() {
    let mut design = GoodDesign::new();
    design.add(String::from("item1"));
    design.add(String::from("item2"));
    design.set_current(0);
    
    if let Some(current) = design.get_current() {
        println!("Current: {}", current);
    }
}
```

**æŠ€å·§ 3: ä½¿ç”¨ `Cow` çµæ´»å¤„ç†**

```rust
use std::borrow::Cow;

fn process_data(input: &str) -> Cow<str> {
    if input.contains("special") {
        // éœ€è¦ä¿®æ”¹ï¼Œè¿”å› Owned
        Cow::Owned(input.to_uppercase())
    } else {
        // ä¸éœ€è¦ä¿®æ”¹ï¼Œè¿”å› Borrowed
        Cow::Borrowed(input)
    }
}

fn main() {
    let data1 = "normal data";
    let data2 = "special data";
    
    let result1 = process_data(data1);
    let result2 = process_data(data2);
    
    println!("Result 1: {} (borrowed: {})", result1, matches!(result1, Cow::Borrowed(_)));
    println!("Result 2: {} (borrowed: {})", result2, matches!(result2, Cow::Borrowed(_)));
}
```

### 8.6 ç”Ÿå‘½å‘¨æœŸä¸è¿­ä»£å™¨

è¿­ä»£å™¨çš„ç”Ÿå‘½å‘¨æœŸæ¨¡å¼ï¼š

```rust
struct Lines<'a> {
    text: &'a str,
}

impl<'a> Lines<'a> {
    fn new(text: &'a str) -> Self {
        Lines { text }
    }
}

impl<'a> Iterator for Lines<'a> {
    type Item = &'a str;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.text.is_empty() {
            return None;
        }
        
        match self.text.find('\n') {
            Some(pos) => {
                let line = &self.text[..pos];
                self.text = &self.text[pos + 1..];
                Some(line)
            }
            None => {
                let line = self.text;
                self.text = "";
                Some(line)
            }
        }
    }
}

fn main() {
    let text = "line1\nline2\nline3";
    let lines = Lines::new(text);
    
    for line in lines {
        println!("Line: {}", line);
    }
}
```

### 8.7 ç”Ÿå‘½å‘¨æœŸä¸å¼‚æ­¥

å¼‚æ­¥å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸï¼š

```rust
use std::future::Future;

// å¼‚æ­¥å‡½æ•°è‡ªåŠ¨æ·»åŠ ç”Ÿå‘½å‘¨æœŸ
async fn async_process(data: &str) -> String {
    // å¼‚æ­¥æ“ä½œ
    data.to_uppercase()
}

// æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
fn manual_async<'a>(data: &'a str) -> impl Future<Output = String> + 'a {
    async move {
        data.to_uppercase()
    }
}

// ç»“æ„ä½“ä¸å¼‚æ­¥
struct AsyncData<'a> {
    data: &'a str,
}

impl<'a> AsyncData<'a> {
    async fn process(&self) -> String {
        self.data.to_uppercase()
    }
}

fn main() {
    // æ³¨ï¼šè¿™äº›ç¤ºä¾‹éœ€è¦ tokio è¿è¡Œæ—¶
    let data = "hello";
    
    // åœ¨å®é™…å¼‚æ­¥ç¯å¢ƒä¸­ä½¿ç”¨
    // tokio::runtime::Runtime::new().unwrap().block_on(async {
    //     let result = async_process(data).await;
    //     println!("{}", result);
    // });
    
    println!("Data: {}", data);
}
```

---

## 9. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²åˆ†å‰²å™¨

```rust
struct StrSplit<'a, 'b> {
    remainder: Option<&'a str>,
    delimiter: &'b str,
}

impl<'a, 'b> StrSplit<'a, 'b> {
    fn new(haystack: &'a str, delimiter: &'b str) -> Self {
        StrSplit {
            remainder: Some(haystack),
            delimiter,
        }
    }
}

impl<'a, 'b> Iterator for StrSplit<'a, 'b> {
    type Item = &'a str;
    
    fn next(&mut self) -> Option<Self::Item> {
        let remainder = self.remainder.as_mut()?;
        
        if let Some(next_delim) = remainder.find(self.delimiter) {
            let until_delimiter = &remainder[..next_delim];
            *remainder = &remainder[next_delim + self.delimiter.len()..];
            Some(until_delimiter)
        } else {
            self.remainder.take()
        }
    }
}

fn main() {
    let haystack = "a b c d e";
    let letters: Vec<_> = StrSplit::new(haystack, " ").collect();
    
    println!("Letters: {:?}", letters);
}
```

### æ¡ˆä¾‹ 2: ç¼“å­˜ç³»ç»Ÿ

```rust
use std::collections::HashMap;

struct Cache<'a, T> {
    data: HashMap<&'a str, T>,
}

impl<'a, T> Cache<'a, T> {
    fn new() -> Self {
        Cache {
            data: HashMap::new(),
        }
    }
    
    fn get(&self, key: &str) -> Option<&T> {
        self.data.get(key)
    }
    
    fn insert(&mut self, key: &'a str, value: T) {
        self.data.insert(key, value);
    }
}

fn main() {
    let key1 = "user:1";
    let key2 = "user:2";
    
    let mut cache = Cache::new();
    cache.insert(key1, String::from("Alice"));
    cache.insert(key2, String::from("Bob"));
    
    if let Some(name) = cache.get("user:1") {
        println!("User 1: {}", name);
    }
}
```

### æ¡ˆä¾‹ 3: è¿­ä»£å™¨

```rust
struct Iter<'a, T> {
    slice: &'a [T],
    index: usize,
}

impl<'a, T> Iter<'a, T> {
    fn new(slice: &'a [T]) -> Self {
        Iter { slice, index: 0 }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.slice.len() {
            let item = &self.slice[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let iter = Iter::new(&numbers);
    
    for num in iter {
        println!("Number: {}", num);
    }
}
```

### æ¡ˆä¾‹ 4: è‡ªå¼•ç”¨ç»“æ„

```rust
use std::pin::Pin;

struct SelfReferential {
    data: String,
    pointer: *const String,
}

impl SelfReferential {
    fn new(data: String) -> Pin<Box<Self>> {
        let mut boxed = Box::pin(SelfReferential {
            data,
            pointer: std::ptr::null(),
        });
        
        let self_ptr: *const String = &boxed.data;
        
        unsafe {
            let mut_ref = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).pointer = self_ptr;
        }
        
        boxed
    }
    
    fn get_data(&self) -> &str {
        &self.data
    }
    
    fn get_pointer(&self) -> &str {
        unsafe { &*self.pointer }
    }
}

fn main() {
    let s = SelfReferential::new(String::from("hello"));
    println!("Data: {}", s.get_data());
    println!("Pointer: {}", s.get_pointer());
}
```

---

## 10. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 10.1 å¸¸è§é™·é˜±

```rust
// âŒ é™·é˜± 1: è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨
// fn dangle() -> &str {
//     let s = String::from("hello");
//     &s  // ç¼–è¯‘é”™è¯¯ï¼
// }

// âœ… æ­£ç¡®ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    String::from("hello")
}

// âŒ é™·é˜± 2: ç”Ÿå‘½å‘¨æœŸè¿‡é•¿
// fn process<'a>(input: &'a str) -> &'a str {
//     // è¿”å›çš„å¼•ç”¨ç”Ÿå‘½å‘¨æœŸè¢«ä¸å¿…è¦åœ°å»¶é•¿
// }

// âœ… æ­£ç¡®ï¼šä½¿ç”¨é€‚å½“çš„ç”Ÿå‘½å‘¨æœŸ
fn process(input: &str) -> String {
    input.to_uppercase()
}

// âŒ é™·é˜± 3: æ··æ·†ç”Ÿå‘½å‘¨æœŸ
// fn mix<'a>(x: &'a str, y: &str) -> &'a str {
//     y  // ç¼–è¯‘é”™è¯¯ï¼y çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½æ¯” 'a çŸ­
// }

// âœ… æ­£ç¡®ï¼šæ˜ç¡®ç”Ÿå‘½å‘¨æœŸå…³ç³»
fn mix<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'b: 'a,
{
    x
}

fn main() {
    let s = no_dangle();
    println!("{}", s);
    
    let result = process("hello");
    println!("{}", result);
}
```

### 10.2 æœ€ä½³å®è·µ

```rust
use std::fmt::Display;

// âœ… 1. ä¼˜å…ˆä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçœç•¥
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

// âœ… 2. è¿”å›å€¼å°½é‡é¿å…å¼•ç”¨
fn process_data(data: &str) -> String {
    data.to_uppercase()
}

// âœ… 3. ä½¿ç”¨ where å­å¥æé«˜å¯è¯»æ€§
fn complex<'a, T>(x: &'a T, y: &'a T) -> &'a T
where
    T: Display + PartialOrd,
{
    if x > y { x } else { y }
}

// âœ… 4. ç»“æ„ä½“ä¸­é¿å…ä¸å¿…è¦çš„ç”Ÿå‘½å‘¨æœŸ
struct Config {
    name: String,  // æ‹¥æœ‰æ‰€æœ‰æƒ
    port: u16,
}

// âœ… 5. åˆç†ä½¿ç”¨ 'static
const DEFAULT_NAME: &str = "app";

fn get_name() -> &'static str {
    DEFAULT_NAME
}

fn main() {
    let word = first_word("hello world");
    println!("First word: {}", word);
    
    let result = process_data("test");
    println!("Processed: {}", result);
    
    println!("Name: {}", get_name());
}
```

### 10.3 ç”Ÿå‘½å‘¨æœŸè°ƒè¯•æŠ€å·§

**æŠ€å·§ 1: æ˜¾å¼æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸä»¥ç†è§£é”™è¯¯**:

```rust
// âŒ ç¼–è¯‘é”™è¯¯
// fn wrong<'a>(x: &'a str, y: &str) -> &'a str {
//     y  // é”™è¯¯ï¼šy çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½æ¯” 'a çŸ­
// }

// âœ… æ˜¾å¼æ ‡æ³¨æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ
fn correct<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'b: 'a,  // æ˜ç¡®è¦æ±‚ 'b è‡³å°‘å’Œ 'a ä¸€æ ·é•¿
{
    x  // åªèƒ½è¿”å› x
}
```

**æŠ€å·§ 2: ä½¿ç”¨å•å…ƒæµ‹è¯•éªŒè¯ç”Ÿå‘½å‘¨æœŸ**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_lifetime_scope() {
        let long_lived = String::from("long");
        let result;
        
        {
            let short_lived = String::from("short");
            // result = longest(&long_lived, &short_lived);  // âŒ ç¼–è¯‘é”™è¯¯
        }
        
        result = &long_lived;  // âœ… æ­£ç¡®
        println!("{}", result);
    }
}
```

**æŠ€å·§ 3: ä½¿ç”¨ç¼–è¯‘å™¨å»ºè®®**:

```rust
// ç¼–è¯‘å™¨é€šå¸¸ä¼šç»™å‡ºæœ‰ç”¨çš„å»ºè®®
// ä¾‹å¦‚ï¼Œå»ºè®®æ·»åŠ ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œæˆ–è°ƒæ•´è¿”å›ç±»å‹

fn example() {
    // æ ¹æ®ç¼–è¯‘å™¨æç¤ºé€æ­¥è°ƒæ•´ä»£ç 
}
```

---

## 11. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç”Ÿå‘½å‘¨æœŸåŸºç¡€**
   - âœ… ç”Ÿå‘½å‘¨æœŸç¡®ä¿å¼•ç”¨æœ‰æ•ˆ
   - âœ… å€Ÿç”¨æ£€æŸ¥å™¨éªŒè¯ç”Ÿå‘½å‘¨æœŸ
   - âœ… é˜²æ­¢æ‚¬å‚å¼•ç”¨

2. **ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨**
   - âœ… ä½¿ç”¨ `'a` è¯­æ³•
   - âœ… æè¿°å¼•ç”¨é—´çš„å…³ç³»
   - âœ… ä¸æ”¹å˜å®é™…ç”Ÿå‘½å‘¨æœŸ

3. **çœç•¥è§„åˆ™**
   - âœ… ä¸‰æ¡è‡ªåŠ¨æ¨æ–­è§„åˆ™
   - âœ… å¤§å¤šæ•°æƒ…å†µå¯çœç•¥
   - âœ… ç¼–è¯‘å™¨è‡ªåŠ¨åº”ç”¨

4. **é«˜çº§ç‰¹æ€§**
   - âœ… 'static ç”Ÿå‘½å‘¨æœŸ
   - âœ… ç”Ÿå‘½å‘¨æœŸå­ç±»å‹
   - âœ… HRTB (é«˜é˜¶ trait bounds)

5. **æœ€ä½³å®è·µ**
   - âœ… ä¼˜å…ˆçœç•¥ç”Ÿå‘½å‘¨æœŸ
   - âœ… è¿”å›å€¼é¿å…å¼•ç”¨
   - âœ… åˆç†ä½¿ç”¨ 'static
   - âœ… ç»“æ„ä½“é¿å…è¿‡å¤šå¼•ç”¨

### ä¸‹ä¸€æ­¥å­¦ä¹ 

å­¦å®Œæœ¬æŒ‡å—åï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **[3.1 ç±»å‹è½¬æ¢å‚è€ƒ](../tier_03_references/01_ç±»å‹è½¬æ¢å‚è€ƒ.md)** - ç±»å‹è½¬æ¢æŠ€æœ¯
2. **[3.2 ç±»å‹å‹å˜å‚è€ƒ](../tier_03_references/02_ç±»å‹å‹å˜å‚è€ƒ.md)** - å‹å˜å’Œå­ç±»å‹
3. **[3.3 åˆ†æ´¾æœºåˆ¶å‚è€ƒ](../tier_03_references/03_åˆ†æ´¾æœºåˆ¶å‚è€ƒ.md)** - é™æ€å’ŒåŠ¨æ€åˆ†å‘
4. **[4.1 é«˜çº§ç±»å‹ç‰¹æ€§](../tier_04_advanced/01_é«˜çº§ç±»å‹ç‰¹æ€§.md)** - é«˜çº§ç±»å‹æŠ€å·§

---

## 12. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Chapter 10.3 (Lifetimes)](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)
- [Rust Reference - Lifetimes](https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds)
- [Rustonomicon - Lifetimes](https://doc.rust-lang.org/nomicon/lifetimes.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)
- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](./03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](./04_Traitç³»ç»ŸæŒ‡å—.md)
- [1.0 é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æ·±åº¦åˆ†æ**:

- [ç”Ÿå‘½å‘¨æœŸåŸç†](../analysis/rust_theory/lifetime_theory.md)
- [å€Ÿç”¨æ£€æŸ¥å™¨è¯¦è§£](../analysis/rust_theory/borrow_checker.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚

---

**ğŸ‰ æ­å–œå®Œæˆç”Ÿå‘½å‘¨æœŸæŒ‡å—å­¦ä¹ ï¼Tier 2 å…¨éƒ¨å®Œæˆï¼** ğŸ¦€
