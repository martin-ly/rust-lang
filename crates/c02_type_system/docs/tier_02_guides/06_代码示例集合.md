# ğŸ’» C02: ç±»å‹ç³»ç»Ÿ - ä»£ç ç¤ºä¾‹é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **éš¾åº¦**: â­ åŸºç¡€ â†’ â­â­â­â­ é«˜çº§
> **ç›®æ ‡**: é€šè¿‡ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹æ·±å…¥ç†è§£ Rust ç±»å‹ç³»ç»Ÿ

---

## ğŸ“Š ç›®å½•

- [ğŸ’» C02: ç±»å‹ç³»ç»Ÿ - ä»£ç ç¤ºä¾‹é›†åˆ](#-c02-ç±»å‹ç³»ç»Ÿ---ä»£ç ç¤ºä¾‹é›†åˆ)
  - [ğŸ“Š ç›®å½•](#-ç›®å½•)
  - [ğŸ“‹ ç¤ºä¾‹å¯¼èˆª](#-ç¤ºä¾‹å¯¼èˆª)
  - [ğŸŒŸ Tier 1: åŸºç¡€ç±»å‹ç¤ºä¾‹](#-tier-1-åŸºç¡€ç±»å‹ç¤ºä¾‹)
    - [ç¤ºä¾‹1.1: åŸºç¡€ç»“æ„ä½“å®šä¹‰](#ç¤ºä¾‹11-åŸºç¡€ç»“æ„ä½“å®šä¹‰)
    - [ç¤ºä¾‹1.2: å…ƒç»„ç»“æ„ä½“å’Œå•å…ƒç»“æ„ä½“](#ç¤ºä¾‹12-å…ƒç»„ç»“æ„ä½“å’Œå•å…ƒç»“æ„ä½“)
    - [ç¤ºä¾‹1.3: æšä¸¾ç±»å‹åŸºç¡€](#ç¤ºä¾‹13-æšä¸¾ç±»å‹åŸºç¡€)
    - [ç¤ºä¾‹1.4: Option å’Œ Result å®è·µ](#ç¤ºä¾‹14-option-å’Œ-result-å®è·µ)
    - [ç¤ºä¾‹1.5: åŸºç¡€ Trait å®ç°](#ç¤ºä¾‹15-åŸºç¡€-trait-å®ç°)
    - [ç¤ºä¾‹1.6: Trait æ–¹æ³•å’Œå…³è”å‡½æ•°](#ç¤ºä¾‹16-trait-æ–¹æ³•å’Œå…³è”å‡½æ•°)
    - [ç¤ºä¾‹1.7: æ´¾ç”Ÿ Trait](#ç¤ºä¾‹17-æ´¾ç”Ÿ-trait)
    - [ç¤ºä¾‹1.8: åŸºç¡€æ¨¡å¼åŒ¹é…](#ç¤ºä¾‹18-åŸºç¡€æ¨¡å¼åŒ¹é…)
  - [ğŸš€ Tier 2: å®è·µåº”ç”¨ç¤ºä¾‹](#-tier-2-å®è·µåº”ç”¨ç¤ºä¾‹)
    - [ç¤ºä¾‹2.1: Trait Bounds çº¦æŸ](#ç¤ºä¾‹21-trait-bounds-çº¦æŸ)
    - [ç¤ºä¾‹2.2: æ³›å‹å‡½æ•°å’Œç»“æ„ä½“](#ç¤ºä¾‹22-æ³›å‹å‡½æ•°å’Œç»“æ„ä½“)
    - [ç¤ºä¾‹2.3: å¤šæ€å’ŒåŠ¨æ€åˆ†æ´¾](#ç¤ºä¾‹23-å¤šæ€å’ŒåŠ¨æ€åˆ†æ´¾)
    - [ç¤ºä¾‹2.4: å…³è”ç±»å‹](#ç¤ºä¾‹24-å…³è”ç±»å‹)
    - [ç¤ºä¾‹2.5: Trait å¯¹è±¡è¯¦è§£](#ç¤ºä¾‹25-trait-å¯¹è±¡è¯¦è§£)
    - [ç¤ºä¾‹2.6: é»˜è®¤å®ç°å’Œé‡å†™](#ç¤ºä¾‹26-é»˜è®¤å®ç°å’Œé‡å†™)
  - [ğŸ“ Tier 3: é«˜çº§ç±»å‹ç³»ç»Ÿç¤ºä¾‹](#-tier-3-é«˜çº§ç±»å‹ç³»ç»Ÿç¤ºä¾‹)
    - [ç¤ºä¾‹3.1: é«˜çº§ Trait æ¨¡å¼](#ç¤ºä¾‹31-é«˜çº§-trait-æ¨¡å¼)
    - [ç¤ºä¾‹3.2: é›¶å¤§å°ç±»å‹ (ZST)](#ç¤ºä¾‹32-é›¶å¤§å°ç±»å‹-zst)
    - [ç¤ºä¾‹3.3: PhantomData å’Œç±»å‹æ ‡è®°](#ç¤ºä¾‹33-phantomdata-å’Œç±»å‹æ ‡è®°)
    - [ç¤ºä¾‹3.4: é«˜çº§ç±»å‹ç³»ç»ŸæŠ€å·§](#ç¤ºä¾‹34-é«˜çº§ç±»å‹ç³»ç»ŸæŠ€å·§)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å­¦ä¹ è·¯å¾„å»ºè®®](#å­¦ä¹ è·¯å¾„å»ºè®®)
    - [æ ¸å¿ƒæ¦‚å¿µæ€»ç»“](#æ ¸å¿ƒæ¦‚å¿µæ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

## ğŸ“‹ ç¤ºä¾‹å¯¼èˆª

| ç¼–å·                                  | ä¸»é¢˜             | éš¾åº¦     | é‡ç‚¹æ¦‚å¿µ         |
| :--- | :--- | :--- | :--- || [1.1](#ç¤ºä¾‹11-åŸºç¡€ç»“æ„ä½“å®šä¹‰)         | åŸºç¡€ç»“æ„ä½“å®šä¹‰   | â­       | structã€å­—æ®µè®¿é—® |
| [1.2](#ç¤ºä¾‹12-å…ƒç»„ç»“æ„ä½“å’Œå•å…ƒç»“æ„ä½“) | å…ƒç»„å’Œå•å…ƒç»“æ„ä½“ | â­       | ç‰¹æ®Šç»“æ„ä½“       |
| [1.3](#ç¤ºä¾‹13-æšä¸¾ç±»å‹åŸºç¡€)           | æšä¸¾ç±»å‹åŸºç¡€     | â­       | enumã€æ¨¡å¼åŒ¹é…   |
| [1.4](#ç¤ºä¾‹14-option-å’Œ-result-å®è·µ)  | Option å’Œ Result | â­â­     | é”™è¯¯å¤„ç†         |
| [1.5](#ç¤ºä¾‹15-åŸºç¡€-trait-å®ç°)        | åŸºç¡€ Trait å®ç°  | â­â­     | trait å®šä¹‰å’Œå®ç° |
| [1.6](#ç¤ºä¾‹16-trait-æ–¹æ³•å’Œå…³è”å‡½æ•°)   | Trait æ–¹æ³•       | â­â­     | æ–¹æ³•ã€å…³è”å‡½æ•°   |
| [1.7](#ç¤ºä¾‹17-æ´¾ç”Ÿ-trait)             | æ´¾ç”Ÿ Trait       | â­       | #[derive]        |
| [1.8](#ç¤ºä¾‹18-åŸºç¡€æ¨¡å¼åŒ¹é…)           | åŸºç¡€æ¨¡å¼åŒ¹é…     | â­â­     | matchã€if let    |
| [2.1](#ç¤ºä¾‹21-trait-bounds-çº¦æŸ)      | Trait Bounds     | â­â­     | æ³›å‹çº¦æŸ         |
| [2.2](#ç¤ºä¾‹22-æ³›å‹å‡½æ•°å’Œç»“æ„ä½“)       | æ³›å‹ç¼–ç¨‹         | â­â­     | ç±»å‹å‚æ•°         |
| [2.3](#ç¤ºä¾‹23-å¤šæ€å’ŒåŠ¨æ€åˆ†æ´¾)         | å¤šæ€             | â­â­â­   | trait å¯¹è±¡       |
| [2.4](#ç¤ºä¾‹24-å…³è”ç±»å‹)               | å…³è”ç±»å‹         | â­â­â­   | type å…³è”        |
| [2.5](#ç¤ºä¾‹25-trait-å¯¹è±¡è¯¦è§£)         | Trait å¯¹è±¡       | â­â­â­   | dyn Trait        |
| [2.6](#ç¤ºä¾‹26-é»˜è®¤å®ç°å’Œé‡å†™)         | é»˜è®¤å®ç°         | â­â­     | é»˜è®¤æ–¹æ³•         |
| [3.1](#ç¤ºä¾‹31-é«˜çº§-trait-æ¨¡å¼)        | é«˜çº§ Trait æ¨¡å¼  | â­â­â­â­ | HRTB             |
| [3.2](#ç¤ºä¾‹32-é›¶å¤§å°ç±»å‹-zst)         | é›¶å¤§å°ç±»å‹       | â­â­â­â­ | ZST              |
| [3.3](#ç¤ºä¾‹33-phantomdata-å’Œç±»å‹æ ‡è®°) | PhantomData      | â­â­â­â­ | ç±»å‹æ ‡è®°         |
| [3.4](#ç¤ºä¾‹34-é«˜çº§ç±»å‹ç³»ç»ŸæŠ€å·§)       | é«˜çº§æŠ€å·§         | â­â­â­â­ | ç±»å‹çº§ç¼–ç¨‹       |

---

## ğŸŒŸ Tier 1: åŸºç¡€ç±»å‹ç¤ºä¾‹

### ç¤ºä¾‹1.1: åŸºç¡€ç»“æ„ä½“å®šä¹‰

**ç›®æ ‡**: æŒæ¡ç»“æ„ä½“çš„å®šä¹‰ã€åˆ›å»ºå’Œä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== åŸºç¡€ç»“æ„ä½“ =====\n");

    // å®šä¹‰ä¸€ä¸ªç”¨æˆ·ç»“æ„ä½“
    struct User {
        username: String,
        email: String,
        age: u32,
        active: bool,
    }

    // åˆ›å»ºç»“æ„ä½“å®ä¾‹
    let user1 = User {
        username: String::from("alice"),
        email: String::from("alice@example.com"),
        age: 30,
        active: true,
    };

    println!("ç”¨æˆ·å: {}", user1.username);
    println!("é‚®ç®±: {}", user1.email);
    println!("å¹´é¾„: {}", user1.age);
    println!("æ¿€æ´»: {}", user1.active);

    // å¯å˜ç»“æ„ä½“
    let mut user2 = User {
        username: String::from("bob"),
        email: String::from("bob@example.com"),
        age: 25,
        active: false,
    };

    // ä¿®æ”¹å­—æ®µ
    user2.active = true;
    user2.age = 26;

    println!("\nç”¨æˆ·2æ›´æ–°å:");
    println!("æ¿€æ´»: {}", user2.active);
    println!("å¹´é¾„: {}", user2.age);

    // å­—æ®µåˆå§‹åŒ–ç®€å†™
    let username = String::from("charlie");
    let email = String::from("charlie@example.com");

    let user3 = User {
        username,  // ç­‰åŒäº username: username
        email,     // ç­‰åŒäº email: email
        age: 28,
        active: true,
    };

    println!("\nç”¨æˆ·3 (ç®€å†™): {}", user3.username);

    // ç»“æ„ä½“æ›´æ–°è¯­æ³•
    let user4 = User {
        username: String::from("dave"),
        email: String::from("dave@example.com"),
        ..user3  // ä» user3 å¤åˆ¶å…¶ä»–å­—æ®µ
    };

    println!("ç”¨æˆ·4å¹´é¾„: {}", user4.age);  // ä» user3 å¤åˆ¶

    println!("\n===== ç»“æ„ä½“æ–¹æ³• =====\n");

    // å¸¦æ–¹æ³•çš„ç»“æ„ä½“
    struct Rectangle {
        width: u32,
        height: u32,
    }

    impl Rectangle {
        // å…³è”å‡½æ•° (æ„é€ å‡½æ•°)
        fn new(width: u32, height: u32) -> Rectangle {
            Rectangle { width, height }
        }

        // æ–¹æ³• (self)
        fn area(&self) -> u32 {
            self.width * self.height
        }

        // å¯å˜æ–¹æ³•
        fn resize(&mut self, width: u32, height: u32) {
            self.width = width;
            self.height = height;
        }

        // æ¯”è¾ƒæ–¹æ³•
        fn can_hold(&self, other: &Rectangle) -> bool {
            self.width > other.width && self.height > other.height
        }
    }

    let mut rect1 = Rectangle::new(30, 50);
    println!("çŸ©å½¢1é¢ç§¯: {}", rect1.area());

    let rect2 = Rectangle::new(10, 20);
    println!("çŸ©å½¢1èƒ½å®¹çº³çŸ©å½¢2: {}", rect1.can_hold(&rect2));

    rect1.resize(60, 80);
    println!("çŸ©å½¢1æ–°é¢ç§¯: {}", rect1.area());
}
```

**è¯´æ˜**:

- **ç»“æ„ä½“å®šä¹‰**: ä½¿ç”¨ `struct` å…³é”®å­—å®šä¹‰è‡ªå®šä¹‰ç±»å‹
- **å®ä¾‹åŒ–**: ä¸ºæ¯ä¸ªå­—æ®µæä¾›å€¼æ¥åˆ›å»ºå®ä¾‹
- **æ–¹æ³•**: åœ¨ `impl` å—ä¸­å®šä¹‰ä¸ç»“æ„ä½“å…³è”çš„æ–¹æ³•
- **æ‰€æœ‰æƒ**: ç»“æ„ä½“æ‹¥æœ‰å…¶å­—æ®µçš„æ•°æ®

**è¾“å‡º**:

```text
===== åŸºç¡€ç»“æ„ä½“ =====

ç”¨æˆ·å: alice
é‚®ç®±: alice@example.com
å¹´é¾„: 30
æ¿€æ´»: true

ç”¨æˆ·2æ›´æ–°å:
æ¿€æ´»: true
å¹´é¾„: 26

ç”¨æˆ·3 (ç®€å†™): charlie
ç”¨æˆ·4å¹´é¾„: 28

===== ç»“æ„ä½“æ–¹æ³• =====

çŸ©å½¢1é¢ç§¯: 1500
çŸ©å½¢1èƒ½å®¹çº³çŸ©å½¢2: true
çŸ©å½¢1æ–°é¢ç§¯: 4800
```

**å…³é”®ç‚¹**:

- ğŸ¯ ç»“æ„ä½“å­—æ®µé»˜è®¤ç§æœ‰
- ğŸ¯ æ•´ä¸ªç»“æ„ä½“å¿…é¡»å¯å˜æ‰èƒ½ä¿®æ”¹å­—æ®µ
- ğŸ¯ `impl` å—å¯ä»¥å®šä¹‰å¤šä¸ªæ–¹æ³•
- ğŸ¯ `&self` å€Ÿç”¨ï¼Œ`&mut self` å¯å˜å€Ÿç”¨ï¼Œ`self` è·å–æ‰€æœ‰æƒ

---

### ç¤ºä¾‹1.2: å…ƒç»„ç»“æ„ä½“å’Œå•å…ƒç»“æ„ä½“

**ç›®æ ‡**: ç†è§£ç‰¹æ®Šå½¢å¼çš„ç»“æ„ä½“

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== å…ƒç»„ç»“æ„ä½“ =====\n");

    // å…ƒç»„ç»“æ„ä½“ (å…·åå…ƒç»„)
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    // è®¿é—®å­—æ®µ (ä½¿ç”¨ç´¢å¼•)
    println!("é»‘è‰² RGB: ({}, {}, {})", black.0, black.1, black.2);
    println!("åŸç‚¹åæ ‡: ({}, {}, {})", origin.0, origin.1, origin.2);

    // æ³¨æ„: Color å’Œ Point æ˜¯ä¸åŒç±»å‹
    // let black_point: Point = black;  // âŒ ç¼–è¯‘é”™è¯¯!

    // è§£æ„å…ƒç»„ç»“æ„ä½“
    let Color(r, g, b) = black;
    println!("è§£æ„: R={}, G={}, B={}", r, g, b);

    println!("\n===== å•å…ƒç»“æ„ä½“ =====\n");

    // å•å…ƒç»“æ„ä½“ (æ— å­—æ®µ)
    struct Marker;
    struct AlwaysEqual;

    // åˆ›å»ºå®ä¾‹
    let _marker = Marker;
    let _equal1 = AlwaysEqual;
    let _equal2 = AlwaysEqual;

    println!("å•å…ƒç»“æ„ä½“å¸¸ç”¨äº:");
    println!("- å®ç° trait è€Œä¸éœ€è¦æ•°æ®");
    println!("- ä½œä¸ºç±»å‹æ ‡è®°");
    println!("- é›¶å¤§å°ç±»å‹ (ZST)");

    println!("\n===== å®é™…åº”ç”¨: New Type æ¨¡å¼ =====\n");

    // New Type æ¨¡å¼: ä¸ºåŸºç¡€ç±»å‹åˆ›å»ºå°è£…
    struct Meters(f64);
    struct Kilometers(f64);

    impl Meters {
        fn to_kilometers(&self) -> Kilometers {
            Kilometers(self.0 / 1000.0)
        }
    }

    impl Kilometers {
        fn to_meters(&self) -> Meters {
            Meters(self.0 * 1000.0)
        }
    }

    let distance_m = Meters(5000.0);
    let distance_km = distance_m.to_kilometers();

    println!("è·ç¦»: {} ç±³ = {} åƒç±³", distance_m.0, distance_km.0);

    // ç±»å‹å®‰å…¨: ä¸èƒ½æ··ç”¨ Meters å’Œ Kilometers
    // let wrong: Meters = Kilometers(1.0);  // âŒ ç¼–è¯‘é”™è¯¯!

    println!("\n===== é€æ˜å°è£… =====\n");

    // ä½¿ç”¨å…ƒç»„ç»“æ„ä½“åˆ›å»ºé€æ˜å°è£…
    struct Wrapper(Vec<String>);

    impl Wrapper {
        fn new() -> Self {
            Wrapper(Vec::new())
        }

        fn add(&mut self, s: String) {
            self.0.push(s);
        }

        fn len(&self) -> usize {
            self.0.len()
        }
    }

    let mut wrapper = Wrapper::new();
    wrapper.add(String::from("hello"));
    wrapper.add(String::from("world"));

    println!("Wrapper é•¿åº¦: {}", wrapper.len());

    // è®¿é—®å†…éƒ¨ Vec (éœ€è¦é€šè¿‡ .0)
    for item in &wrapper.0 {
        println!("  - {}", item);
    }
}
```

**è¯´æ˜**:

- **å…ƒç»„ç»“æ„ä½“**: æœ‰åå­—ä½†å­—æ®µæ— åï¼Œé€‚åˆç®€å•å°è£…
- **å•å…ƒç»“æ„ä½“**: æ— å­—æ®µï¼Œå¸¸ç”¨äºå®ç° trait
- **New Type æ¨¡å¼**: ä¸ºåŸºç¡€ç±»å‹æä¾›ç±»å‹å®‰å…¨çš„å°è£…
- **é›¶å¤§å°**: å•å…ƒç»“æ„ä½“åœ¨è¿è¡Œæ—¶ä¸å ç©ºé—´

**è¾“å‡º**:

```text
===== å…ƒç»„ç»“æ„ä½“ =====

é»‘è‰² RGB: (0, 0, 0)
åŸç‚¹åæ ‡: (0, 0, 0)
è§£æ„: R=0, G=0, B=0

===== å•å…ƒç»“æ„ä½“ =====

å•å…ƒç»“æ„ä½“å¸¸ç”¨äº:
- å®ç° trait è€Œä¸éœ€è¦æ•°æ®
- ä½œä¸ºç±»å‹æ ‡è®°
- é›¶å¤§å°ç±»å‹ (ZST)

===== å®é™…åº”ç”¨: New Type æ¨¡å¼ =====

è·ç¦»: 5000 ç±³ = 5 åƒç±³

===== é€æ˜å°è£… =====

Wrapper é•¿åº¦: 2
  - hello
  - world
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… å…ƒç»„ç»“æ„ä½“: ç®€å•çš„ç±»å‹åŒºåˆ†
- âœ… å•å…ƒç»“æ„ä½“: Trait æ ‡è®°ã€ç±»å‹çŠ¶æ€
- âœ… New Type: å•ä½ã€IDã€ç±»å‹å®‰å…¨

---

### ç¤ºä¾‹1.3: æšä¸¾ç±»å‹åŸºç¡€

**ç›®æ ‡**: æŒæ¡æšä¸¾çš„å®šä¹‰å’Œä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ç®€å•æšä¸¾ =====\n");

    // å®šä¹‰æšä¸¾
    #[derive(Debug)]
    enum Direction {
        North,
        South,
        East,
        West,
    }

    // ä½¿ç”¨æšä¸¾
    let dir = Direction::North;
    println!("æ–¹å‘: {:?}", dir);

    // åŒ¹é…æšä¸¾
    match dir {
        Direction::North => println!("å‘åŒ—"),
        Direction::South => println!("å‘å—"),
        Direction::East => println!("å‘ä¸œ"),
        Direction::West => println!("å‘è¥¿"),
    }

    println!("\n===== æºå¸¦æ•°æ®çš„æšä¸¾ =====\n");

    // æšä¸¾å˜ä½“å¯ä»¥æºå¸¦ä¸åŒç±»å‹çš„æ•°æ®
    #[derive(Debug)]
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));

    println!("IPv4: {:?}", home);
    println!("IPv6: {:?}", loopback);

    // åŒ¹é…å¹¶æå–æ•°æ®
    match home {
        IpAddr::V4(a, b, c, d) => {
            println!("IPv4 åœ°å€: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(addr) => {
            println!("IPv6 åœ°å€: {}", addr);
        }
    }

    println!("\n===== å¤æ‚æšä¸¾ =====\n");

    // æšä¸¾å˜ä½“å¯ä»¥æ˜¯ä¸åŒçš„ç»“æ„
    #[derive(Debug)]
    enum Message {
        Quit,                       // æ— æ•°æ®
        Move { x: i32, y: i32 },   // åŒ¿åç»“æ„ä½“
        Write(String),              // å•ä¸ªå€¼
        ChangeColor(i32, i32, i32), // å…ƒç»„
    }

    // ä¸ºæšä¸¾å®ç°æ–¹æ³•
    impl Message {
        fn call(&self) {
            match self {
                Message::Quit => {
                    println!("é€€å‡ºæ¶ˆæ¯");
                }
                Message::Move { x, y } => {
                    println!("ç§»åŠ¨åˆ°: ({}, {})", x, y);
                }
                Message::Write(text) => {
                    println!("å†™å…¥æ–‡æœ¬: {}", text);
                }
                Message::ChangeColor(r, g, b) => {
                    println!("æ”¹å˜é¢œè‰²: RGB({}, {}, {})", r, g, b);
                }
            }
        }
    }

    let messages = vec![
        Message::Quit,
        Message::Move { x: 10, y: 20 },
        Message::Write(String::from("Hello")),
        Message::ChangeColor(255, 0, 0),
    ];

    for msg in messages {
        msg.call();
    }

    println!("\n===== æšä¸¾ä¸ç»“æ„ä½“å¯¹æ¯” =====\n");

    // å¦‚æœç”¨ç»“æ„ä½“å®ç°ä¸Šé¢çš„ Message
    // ä¼šéœ€è¦å¤šä¸ªç»“æ„ä½“å’Œé¢å¤–çš„é€»è¾‘

    struct QuitMessage;
    struct MoveMessage {
        x: i32,
        y: i32,
    }
    struct WriteMessage(String);
    struct ChangeColorMessage(i32, i32, i32);

    // ä½¿ç”¨æšä¸¾æ›´ç®€æ´ç»Ÿä¸€
    println!("æšä¸¾ä¼˜åŠ¿:");
    println!("- ç»Ÿä¸€ç±»å‹: æ‰€æœ‰å˜ä½“éƒ½æ˜¯ Message ç±»å‹");
    println!("- ç±»å‹å®‰å…¨: ç¼–è¯‘æ—¶æ£€æŸ¥æ‰€æœ‰æƒ…å†µ");
    println!("- æ¨¡å¼åŒ¹é…: å¼ºåˆ¶å¤„ç†æ‰€æœ‰å˜ä½“");
}
```

**è¯´æ˜**:

- **æšä¸¾å®šä¹‰**: å®šä¹‰ä¸€ç»„ç›¸å…³çš„å˜ä½“
- **æºå¸¦æ•°æ®**: æ¯ä¸ªå˜ä½“å¯ä»¥æºå¸¦ä¸åŒç±»å‹å’Œæ•°é‡çš„æ•°æ®
- **æ–¹æ³•**: æšä¸¾ä¹Ÿå¯ä»¥æœ‰ impl å—
- **æ¨¡å¼åŒ¹é…**: match æ˜¯å¤„ç†æšä¸¾çš„ä¸»è¦æ–¹å¼

**è¾“å‡º**:

```text
===== ç®€å•æšä¸¾ =====

æ–¹å‘: North
å‘åŒ—

===== æºå¸¦æ•°æ®çš„æšä¸¾ =====

IPv4: V4(127, 0, 0, 1)
IPv6: V6("::1")
IPv4 åœ°å€: 127.0.0.1

===== å¤æ‚æšä¸¾ =====

é€€å‡ºæ¶ˆæ¯
ç§»åŠ¨åˆ°: (10, 20)
å†™å…¥æ–‡æœ¬: Hello
æ”¹å˜é¢œè‰²: RGB(255, 0, 0)

===== æšä¸¾ä¸ç»“æ„ä½“å¯¹æ¯” =====

æšä¸¾ä¼˜åŠ¿:
- ç»Ÿä¸€ç±»å‹: æ‰€æœ‰å˜ä½“éƒ½æ˜¯ Message ç±»å‹
- ç±»å‹å®‰å…¨: ç¼–è¯‘æ—¶æ£€æŸ¥æ‰€æœ‰æƒ…å†µ
- æ¨¡å¼åŒ¹é…: å¼ºåˆ¶å¤„ç†æ‰€æœ‰å˜ä½“
```

**å…³é”®ç‚¹**:

- ğŸ¯ æšä¸¾é€‚åˆ"å¤šé€‰ä¸€"çš„åœºæ™¯
- ğŸ¯ æ¯ä¸ªå˜ä½“å¯ä»¥æ˜¯ä¸åŒçš„æ•°æ®ç»“æ„
- ğŸ¯ match å¿…é¡»è¦†ç›–æ‰€æœ‰å˜ä½“
- ğŸ¯ ä½¿ç”¨æšä¸¾æ¯”å¤šä¸ªç»“æ„ä½“æ›´ç®€æ´

---

### ç¤ºä¾‹1.4: Option å’Œ Result å®è·µ

**ç›®æ ‡**: æŒæ¡ Rust çš„æ ¸å¿ƒæšä¸¾ç±»å‹

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Option<T> åŸºç¡€ =====\n");

    // Option è¡¨ç¤ºå¯èƒ½å­˜åœ¨æˆ–ä¸å­˜åœ¨çš„å€¼
    let some_number: Option<i32> = Some(5);
    let no_number: Option<i32> = None;

    println!("Some: {:?}", some_number);
    println!("None: {:?}", no_number);

    // ä½¿ç”¨ match å¤„ç† Option
    match some_number {
        Some(value) => println!("å€¼æ˜¯: {}", value),
        None => println!("æ²¡æœ‰å€¼"),
    }

    // if let ç®€åŒ–è¯­æ³•
    if let Some(value) = some_number {
        println!("ä½¿ç”¨ if let: {}", value);
    }

    println!("\n===== Option æ–¹æ³• =====\n");

    let x = Some(5);

    // unwrap: å–å‡ºå€¼æˆ– panic
    let value = x.unwrap();
    println!("unwrap: {}", value);

    // unwrap_or: æä¾›é»˜è®¤å€¼
    let y: Option<i32> = None;
    let value = y.unwrap_or(0);
    println!("unwrap_or: {}", value);

    // map: è½¬æ¢å†…éƒ¨å€¼
    let squared = x.map(|n| n * n);
    println!("map: {:?}", squared);

    // and_then: é“¾å¼æ“ä½œ
    let result = x.and_then(|n| Some(n * 2));
    println!("and_then: {:?}", result);

    // filter: è¿‡æ»¤
    let even = x.filter(|&n| n % 2 == 0);
    println!("filter (å¥‡æ•°): {:?}", even);

    println!("\n===== Result<T, E> åŸºç¡€ =====\n");

    // Result ç”¨äºå¯èƒ½å¤±è´¥çš„æ“ä½œ
    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err(String::from("é™¤æ•°ä¸èƒ½ä¸ºé›¶"))
        } else {
            Ok(a / b)
        }
    }

    let result1 = divide(10.0, 2.0);
    let result2 = divide(10.0, 0.0);

    // å¤„ç† Result
    match result1 {
        Ok(value) => println!("10 / 2 = {}", value),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    match result2 {
        Ok(value) => println!("10 / 0 = {}", value),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    println!("\n===== Result æ–¹æ³• =====\n");

    let good: Result<i32, &str> = Ok(42);
    let bad: Result<i32, &str> = Err("å‡ºé”™äº†");

    // is_ok / is_err
    println!("good.is_ok(): {}", good.is_ok());
    println!("bad.is_err(): {}", bad.is_err());

    // unwrap_or
    println!("bad.unwrap_or(0): {}", bad.unwrap_or(0));

    // map: è½¬æ¢æˆåŠŸå€¼
    let doubled = good.map(|n| n * 2);
    println!("doubled: {:?}", doubled);

    // map_err: è½¬æ¢é”™è¯¯å€¼
    let mapped_err = bad.map_err(|e| format!("é”™è¯¯: {}", e));
    println!("mapped_err: {:?}", mapped_err);

    println!("\n===== ? æ“ä½œç¬¦ =====\n");

    // ? æ“ä½œç¬¦ç”¨äºé”™è¯¯ä¼ æ’­
    fn read_number(s: &str) -> Result<i32, std::num::ParseIntError> {
        let n = s.parse::<i32>()?;  // å¦‚æœå¤±è´¥,ç›´æ¥è¿”å›é”™è¯¯
        Ok(n * 2)
    }

    match read_number("42") {
        Ok(n) => println!("è§£ææˆåŠŸ: {}", n),
        Err(e) => println!("è§£æå¤±è´¥: {}", e),
    }

    match read_number("abc") {
        Ok(n) => println!("è§£ææˆåŠŸ: {}", n),
        Err(e) => println!("è§£æå¤±è´¥: {}", e),
    }

    println!("\n===== å®é™…åº”ç”¨ =====\n");

    // ä»å‘é‡ä¸­æŸ¥æ‰¾å…ƒç´ 
    fn find_by_id(users: &[User], id: u32) -> Option<&User> {
        users.iter().find(|u| u.id == id)
    }

    struct User {
        id: u32,
        name: String,
    }

    let users = vec![
        User { id: 1, name: String::from("Alice") },
        User { id: 2, name: String::from("Bob") },
    ];

    if let Some(user) = find_by_id(&users, 1) {
        println!("æ‰¾åˆ°ç”¨æˆ·: {}", user.name);
    } else {
        println!("ç”¨æˆ·ä¸å­˜åœ¨");
    }

    // æ–‡ä»¶æ“ä½œ (Result çš„å…¸å‹åº”ç”¨)
    use std::fs;

    fn read_config() -> Result<String, std::io::Error> {
        // ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
        let content = fs::read_to_string("config.txt")?;
        Ok(content)
    }

    match read_config() {
        Ok(content) => println!("é…ç½®: {}", content),
        Err(e) => println!("è¯»å–é…ç½®å¤±è´¥: {}", e),
    }
}
```

**è¯´æ˜**:

- **Option**: è¡¨ç¤ºå¯é€‰å€¼ï¼Œé¿å…ç©ºæŒ‡é’ˆ
- **Result**: è¡¨ç¤ºå¯èƒ½å¤±è´¥çš„æ“ä½œï¼Œç”¨äºé”™è¯¯å¤„ç†
- **? æ“ä½œç¬¦**: ç®€åŒ–é”™è¯¯ä¼ æ’­
- **æ–¹æ³•é“¾**: æä¾›å‡½æ•°å¼ç¼–ç¨‹é£æ ¼

**è¾“å‡º**:

```text
===== Option<T> åŸºç¡€ =====

Some: Some(5)
None: None
å€¼æ˜¯: 5
ä½¿ç”¨ if let: 5

===== Option æ–¹æ³• =====

unwrap: 5
unwrap_or: 0
map: Some(25)
and_then: Some(10)
filter (å¥‡æ•°): None

===== Result<T, E> åŸºç¡€ =====

10 / 2 = 5
é”™è¯¯: é™¤æ•°ä¸èƒ½ä¸ºé›¶

===== Result æ–¹æ³• =====

good.is_ok(): true
bad.is_err(): true
bad.unwrap_or(0): 0
doubled: Ok(84)
mapped_err: Err("é”™è¯¯: å‡ºé”™äº†")

===== ? æ“ä½œç¬¦ =====

è§£ææˆåŠŸ: 84
è§£æå¤±è´¥: invalid digit found in string

===== å®é™…åº”ç”¨ =====

æ‰¾åˆ°ç”¨æˆ·: Alice
è¯»å–é…ç½®å¤±è´¥: No such file or directory (os error 2)
```

**æœ€ä½³å®è·µ**:

- âœ… ä¼˜å…ˆä½¿ç”¨ Option/Result è€Œé panic
- âœ… ä½¿ç”¨ ? æ“ä½œç¬¦ç®€åŒ–é”™è¯¯å¤„ç†
- âœ… ä¸ºè‡ªå®šä¹‰é”™è¯¯ç±»å‹å®ç° Error trait
- âŒ é¿å…è¿‡åº¦ä½¿ç”¨ unwrap()

---

### ç¤ºä¾‹1.5: åŸºç¡€ Trait å®ç°

**ç›®æ ‡**: ç†è§£ Trait çš„å®šä¹‰å’Œå®ç°

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Trait å®šä¹‰å’Œå®ç° =====\n");

    // å®šä¹‰ Trait
    trait Summary {
        fn summarize(&self) -> String;
    }

    // ä¸ºç»“æ„ä½“å®ç° Trait
    struct Article {
        title: String,
        author: String,
        content: String,
    }

    impl Summary for Article {
        fn summarize(&self) -> String {
            format!("{} by {}", self.title, self.author)
        }
    }

    struct Tweet {
        username: String,
        content: String,
        reply: bool,
    }

    impl Summary for Tweet {
        fn summarize(&self) -> String {
            format!("@{}: {}", self.username, self.content)
        }
    }

    // ä½¿ç”¨ Trait
    let article = Article {
        title: String::from("Rust ç¼–ç¨‹"),
        author: String::from("å¼ ä¸‰"),
        content: String::from("Rust æ˜¯ä¸€é—¨ç³»ç»Ÿç¼–ç¨‹è¯­è¨€..."),
    };

    let tweet = Tweet {
        username: String::from("æå››"),
        content: String::from("å­¦ä¹  Rust çœŸæœ‰è¶£!"),
        reply: false,
    };

    println!("æ–‡ç« æ‘˜è¦: {}", article.summarize());
    println!("æ¨æ–‡æ‘˜è¦: {}", tweet.summarize());

    println!("\n===== Trait ä½œä¸ºå‚æ•° =====\n");

    // å‡½æ•°æ¥å—å®ç°äº† Summary çš„ç±»å‹
    fn notify(item: &impl Summary) {
        println!("é€šçŸ¥: {}", item.summarize());
    }

    notify(&article);
    notify(&tweet);

    // Trait bound è¯­æ³•
    fn notify_bound<T: Summary>(item: &T) {
        println!("é€šçŸ¥ (bound): {}", item.summarize());
    }

    notify_bound(&article);

    println!("\n===== å¤šä¸ª Trait =====\n");

    use std::fmt::Display;

    // è¦æ±‚å®ç°å¤šä¸ª Trait
    fn notify_display<T: Summary + Display>(item: &T) {
        println!("é€šçŸ¥ (display): {}", item);
    }

    // å®ç° Display
    impl Display for Article {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "ã€Š{}ã€‹ - {}", self.title, self.author)
        }
    }

    notify_display(&article);

    println!("\n===== è¿”å› Trait =====\n");

    // è¿”å›å®ç°äº† Summary çš„ç±»å‹
    fn create_article() -> impl Summary {
        Article {
            title: String::from("æ–°æ–‡ç« "),
            author: String::from("ç‹äº”"),
            content: String::from("å†…å®¹..."),
        }
    }

    let new_article = create_article();
    println!("æ–°æ–‡ç« : {}", new_article.summarize());

    println!("\n===== where å­å¥ =====\n");

    // ä½¿ç”¨ where ç®€åŒ–å¤æ‚çº¦æŸ
    fn complex_function<T, U>(_t: &T, _u: &U)
    where
        T: Summary + Display,
        U: Clone + std::fmt::Debug,
    {
        println!("å¤æ‚å‡½æ•°æ‰§è¡Œ");
    }

    let vec = vec![1, 2, 3];
    complex_function(&article, &vec);
}
```

**è¯´æ˜**:

- **Trait**: å®šä¹‰å…±äº«è¡Œä¸ºçš„æ¥å£
- **impl Trait**: ä¸ºç±»å‹å®ç° Trait
- **Trait å‚æ•°**: å‡½æ•°å¯ä»¥æ¥å—å®ç°äº†ç‰¹å®š Trait çš„ç±»å‹
- **Trait Bound**: çº¦æŸæ³›å‹å‚æ•°

**è¾“å‡º**:

```text
===== Trait å®šä¹‰å’Œå®ç° =====

æ–‡ç« æ‘˜è¦: Rust ç¼–ç¨‹ by å¼ ä¸‰
æ¨æ–‡æ‘˜è¦: @æå››: å­¦ä¹  Rust çœŸæœ‰è¶£!

===== Trait ä½œä¸ºå‚æ•° =====

é€šçŸ¥: Rust ç¼–ç¨‹ by å¼ ä¸‰
é€šçŸ¥: @æå››: å­¦ä¹  Rust çœŸæœ‰è¶£!
é€šçŸ¥ (bound): Rust ç¼–ç¨‹ by å¼ ä¸‰

===== å¤šä¸ª Trait =====

é€šçŸ¥ (display): ã€ŠRust ç¼–ç¨‹ã€‹ - å¼ ä¸‰

===== è¿”å› Trait =====

æ–°æ–‡ç« : æ–°æ–‡ç«  by ç‹äº”

===== where å­å¥ =====

å¤æ‚å‡½æ•°æ‰§è¡Œ
```

**å…³é”®æ¦‚å¿µ**:

- ğŸ¯ Trait ç±»ä¼¼å…¶ä»–è¯­è¨€çš„æ¥å£
- ğŸ¯ ä¸€ä¸ªç±»å‹å¯ä»¥å®ç°å¤šä¸ª Trait
- ğŸ¯ Trait å¯ä»¥æœ‰é»˜è®¤å®ç°
- ğŸ¯ å­¤å„¿è§„åˆ™ï¼šè¦ä¹ˆç±»å‹è¦ä¹ˆ Trait å¿…é¡»åœ¨å½“å‰ crate

---

_ç”±äºç¯‡å¹…é™åˆ¶ï¼Œæˆ‘å°†ç»§ç»­åˆ›å»ºå…¶ä½™ç¤ºä¾‹ã€‚å®Œæ•´æ–‡æ¡£å°†åŒ…å«æ‰€æœ‰ 18 ä¸ªç¤ºä¾‹ï¼Œæ¶µç›– Tier 1-3 çš„æ‰€æœ‰å†…å®¹ã€‚_

### ç¤ºä¾‹1.6: Trait æ–¹æ³•å’Œå…³è”å‡½æ•°

**ç›®æ ‡**: æŒæ¡ Trait ä¸­çš„æ–¹æ³•å’Œå…³è”å‡½æ•°

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Trait æ–¹æ³• =====\n");

    trait Drawable {
        // å¿…é¡»å®ç°çš„æ–¹æ³•
        fn draw(&self);

        // æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•
        fn default_draw(&self) {
            println!("ä½¿ç”¨é»˜è®¤ç»˜åˆ¶");
        }

        // å…³è”å‡½æ•° (æ—  self)
        fn create() -> Self
        where
            Self: Sized;
    }

    struct Circle {
        radius: f64,
    }

    impl Drawable for Circle {
        fn draw(&self) {
            println!("ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: {}", self.radius);
        }

        // è¦†ç›–é»˜è®¤å®ç°
        fn default_draw(&self) {
            println!("è‡ªå®šä¹‰åœ†å½¢ç»˜åˆ¶");
        }

        fn create() -> Self {
            Circle { radius: 1.0 }
        }
    }

    struct Rectangle {
        width: f64,
        height: f64,
    }

    impl Drawable for Rectangle {
        fn draw(&self) {
            println!("ç»˜åˆ¶çŸ©å½¢ï¼Œ{}x{}", self.width, self.height);
        }

        // ä½¿ç”¨é»˜è®¤å®ç° (ä¸è¦†ç›–)

        fn create() -> Self {
            Rectangle {
                width: 1.0,
                height: 1.0,
            }
        }
    }

    let circle = Circle { radius: 5.0 };
    let rectangle = Rectangle {
        width: 10.0,
        height: 20.0,
    };

    circle.draw();
    circle.default_draw();

    rectangle.draw();
    rectangle.default_draw();  // ä½¿ç”¨é»˜è®¤å®ç°

    // è°ƒç”¨å…³è”å‡½æ•°
    let new_circle = Circle::create();
    new_circle.draw();

    println!("\n===== Self ç±»å‹ =====\n");

    trait Builder {
        fn new() -> Self;
        fn build(self) -> Self;
        fn with_name(self, name: &str) -> Self;
    }

    struct Config {
        name: String,
        value: i32,
    }

    impl Builder for Config {
        fn new() -> Self {
            Config {
                name: String::from("default"),
                value: 0,
            }
        }

        fn build(self) -> Self {
            println!("æ„å»ºé…ç½®: {}", self.name);
            self
        }

        fn with_name(mut self, name: &str) -> Self {
            self.name = String::from(name);
            self
        }
    }

    // é“¾å¼è°ƒç”¨
    let config = Config::new().with_name("my_config").build();

    println!("é…ç½®åç§°: {}", config.name);
}
```

**è¯´æ˜**:

- **å®ä¾‹æ–¹æ³•**: éœ€è¦ `&self`ã€`&mut self` æˆ– `self`
- **å…³è”å‡½æ•°**: æ—  self å‚æ•°ï¼Œç±»ä¼¼é™æ€æ–¹æ³•
- **é»˜è®¤å®ç°**: Trait å¯ä»¥æä¾›æ–¹æ³•çš„é»˜è®¤å®ç°
- **Self ç±»å‹**: ä»£è¡¨å®ç°è¯¥ Trait çš„ç±»å‹

**è¾“å‡º**:

```text
===== Trait æ–¹æ³• =====

ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 5
è‡ªå®šä¹‰åœ†å½¢ç»˜åˆ¶
ç»˜åˆ¶çŸ©å½¢ï¼Œ10x20
ä½¿ç”¨é»˜è®¤ç»˜åˆ¶
ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 1

===== Self ç±»å‹ =====

æ„å»ºé…ç½®: my_config
é…ç½®åç§°: my_config
```

---

### ç¤ºä¾‹1.7: æ´¾ç”Ÿ Trait

**ç›®æ ‡**: ä½¿ç”¨ `#[derive]` è‡ªåŠ¨å®ç°å¸¸ç”¨ Trait

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== æ´¾ç”Ÿ Debug =====\n");

    #[derive(Debug)]
    struct Point {
        x: i32,
        y: i32,
    }

    let p = Point { x: 10, y: 20 };
    println!("Debug: {:?}", p);
    println!("Pretty Debug: {:#?}", p);

    println!("\n===== æ´¾ç”Ÿ Clone å’Œ Copy =====\n");

    #[derive(Debug, Clone, Copy)]
    struct Color {
        r: u8,
        g: u8,
        b: u8,
    }

    let c1 = Color { r: 255, g: 0, b: 0 };
    let c2 = c1;  // Copy
    let c3 = c1.clone();  // Clone

    println!("c1: {:?}", c1);  // ä»ç„¶æœ‰æ•ˆ
    println!("c2: {:?}", c2);
    println!("c3: {:?}", c3);

    println!("\n===== æ´¾ç”Ÿ PartialEq å’Œ Eq =====\n");

    #[derive(Debug, PartialEq, Eq)]
    struct User {
        id: u32,
        name: String,
    }

    let user1 = User {
        id: 1,
        name: String::from("Alice"),
    };

    let user2 = User {
        id: 1,
        name: String::from("Alice"),
    };

    let user3 = User {
        id: 2,
        name: String::from("Bob"),
    };

    println!("user1 == user2: {}", user1 == user2);
    println!("user1 == user3: {}", user1 == user3);

    println!("\n===== æ´¾ç”Ÿ PartialOrd å’Œ Ord =====\n");

    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
    struct Priority {
        level: u8,
    }

    let p1 = Priority { level: 1 };
    let p2 = Priority { level: 2 };
    let p3 = Priority { level: 1 };

    println!("p1 < p2: {}", p1 < p2);
    println!("p1 == p3: {}", p1 == p3);

    // æ’åº
    let mut priorities = vec![
        Priority { level: 3 },
        Priority { level: 1 },
        Priority { level: 2 },
    ];

    priorities.sort();
    println!("æ’åºå: {:?}", priorities);

    println!("\n===== æ´¾ç”Ÿ Hash =====\n");

    use std::collections::HashMap;

    #[derive(Debug, PartialEq, Eq, Hash)]
    struct UserId(u32);

    let mut map = HashMap::new();
    map.insert(UserId(1), String::from("Alice"));
    map.insert(UserId(2), String::from("Bob"));

    println!("User 1: {:?}", map.get(&UserId(1)));

    println!("\n===== æ´¾ç”Ÿ Default =====\n");

    #[derive(Debug, Default)]
    struct Config {
        host: String,
        port: u16,
        timeout: u32,
    }

    // ä½¿ç”¨é»˜è®¤å€¼
    let config = Config::default();
    println!("é»˜è®¤é…ç½®: {:?}", config);

    // éƒ¨åˆ†è¦†ç›–é»˜è®¤å€¼
    let config2 = Config {
        host: String::from("localhost"),
        ..Default::default()
    };
    println!("è‡ªå®šä¹‰é…ç½®: {:?}", config2);
}
```

**è¯´æ˜**:

- **#[derive]**: è‡ªåŠ¨å®ç°å¸¸ç”¨ Trait
- **Debug**: æ ¼å¼åŒ–è¾“å‡º
- **Clone/Copy**: å¤åˆ¶è¯­ä¹‰
- **PartialEq/Eq**: ç›¸ç­‰æ¯”è¾ƒ
- **PartialOrd/Ord**: æ’åº
- **Hash**: ç”¨äº HashMap ç­‰
- **Default**: é»˜è®¤å€¼

**è¾“å‡º**:

```text
===== æ´¾ç”Ÿ Debug =====

Debug: Point { x: 10, y: 20 }
Pretty Debug: Point {
    x: 10,
    y: 20,
}

===== æ´¾ç”Ÿ Clone å’Œ Copy =====

c1: Color { r: 255, g: 0, b: 0 }
c2: Color { r: 255, g: 0, b: 0 }
c3: Color { r: 255, g: 0, b: 0 }

===== æ´¾ç”Ÿ PartialEq å’Œ Eq =====

user1 == user2: true
user1 == user3: false

===== æ´¾ç”Ÿ PartialOrd å’Œ Ord =====

p1 < p2: true
p1 == p3: true
æ’åºå: [Priority { level: 1 }, Priority { level: 2 }, Priority { level: 3 }]

===== æ´¾ç”Ÿ Hash =====

User 1: Some("Alice")

===== æ´¾ç”Ÿ Default =====

é»˜è®¤é…ç½®: Config { host: "", port: 0, timeout: 0 }
è‡ªå®šä¹‰é…ç½®: Config { host: "localhost", port: 0, timeout: 0 }
```

**å¯æ´¾ç”Ÿçš„ Trait**:

- âœ… Debug, Clone, Copy
- âœ… PartialEq, Eq, PartialOrd, Ord
- âœ… Hash, Default

---

### ç¤ºä¾‹1.8: åŸºç¡€æ¨¡å¼åŒ¹é…

**ç›®æ ‡**: æŒæ¡æ¨¡å¼åŒ¹é…çš„åŸºç¡€ç”¨æ³•

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== match åŸºç¡€ =====\n");

    let number = 7;

    match number {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 | 4 | 5 => println!("ä¸‰åˆ°äº”"),  // å¤šä¸ªæ¨¡å¼
        6..=10 => println!("å…­åˆ°å"),    // èŒƒå›´
        _ => println!("å…¶ä»–"),            // é»˜è®¤åˆ†æ”¯
    }

    println!("\n===== è§£æ„ç»“æ„ä½“ =====\n");

    struct Point {
        x: i32,
        y: i32,
    }

    let origin = Point { x: 0, y: 0 };

    match origin {
        Point { x: 0, y: 0 } => println!("åŸç‚¹"),
        Point { x, y: 0 } => println!("åœ¨ x è½´ä¸Šï¼Œx = {}", x),
        Point { x: 0, y } => println!("åœ¨ y è½´ä¸Šï¼Œy = {}", y),
        Point { x, y } => println!("ä»»æ„ç‚¹: ({}, {})", x, y),
    }

    // ç®€å†™
    let Point { x, y } = origin;
    println!("x = {}, y = {}", x, y);

    println!("\n===== è§£æ„æšä¸¾ =====\n");

    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    let msg = Message::ChangeColor(255, 0, 0);

    match msg {
        Message::Quit => println!("é€€å‡º"),
        Message::Move { x, y } => println!("ç§»åŠ¨: ({}, {})", x, y),
        Message::Write(text) => println!("å†™å…¥: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("æ”¹å˜é¢œè‰²: RGB({}, {}, {})", r, g, b);
        }
    }

    println!("\n===== è§£æ„å…ƒç»„ =====\n");

    let tuple = (1, "hello", 3.14);

    let (a, b, c) = tuple;
    println!("a = {}, b = {}, c = {}", a, b, c);

    // å¿½ç•¥éƒ¨åˆ†å€¼
    let (x, _, z) = tuple;
    println!("x = {}, z = {}", x, z);

    println!("\n===== if let å’Œ while let =====\n");

    let some_value = Some(3);

    // if let: åªå…³å¿ƒä¸€ç§æ¨¡å¼
    if let Some(value) = some_value {
        println!("å€¼æ˜¯: {}", value);
    } else {
        println!("æ²¡æœ‰å€¼");
    }

    // while let: å¾ªç¯åŒ¹é…
    let mut stack = vec![1, 2, 3];

    while let Some(top) = stack.pop() {
        println!("å¼¹å‡º: {}", top);
    }

    println!("\n===== åŒ¹é…å®ˆå« =====\n");

    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("å°äº5: {}", x),
        Some(x) => println!("å¤§äºç­‰äº5: {}", x),
        None => println!("æ²¡æœ‰å€¼"),
    }

    println!("\n===== @ ç»‘å®š =====\n");

    enum Status {
        Value(i32),
    }

    let status = Status::Value(15);

    match status {
        Status::Value(n @ 1..=10) => {
            println!("å€¼åœ¨1-10ä¹‹é—´: {}", n);
        }
        Status::Value(n @ 11..=20) => {
            println!("å€¼åœ¨11-20ä¹‹é—´: {}", n);
        }
        Status::Value(n) => {
            println!("å…¶ä»–å€¼: {}", n);
        }
    }
}
```

**è¯´æ˜**:

- **match**: å¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½
- **è§£æ„**: å¯ä»¥è§£æ„ç»“æ„ä½“ã€æšä¸¾ã€å…ƒç»„
- **if let/while let**: ç®€åŒ–å•ä¸€æ¨¡å¼åŒ¹é…
- **åŒ¹é…å®ˆå«**: æ·»åŠ é¢å¤–æ¡ä»¶
- **@ ç»‘å®š**: åŒæ—¶åŒ¹é…å’Œç»‘å®šå€¼

**è¾“å‡º**:

```text
===== match åŸºç¡€ =====

å…­åˆ°å

===== è§£æ„ç»“æ„ä½“ =====

åŸç‚¹
x = 0, y = 0

===== è§£æ„æšä¸¾ =====

æ”¹å˜é¢œè‰²: RGB(255, 0, 0)

===== è§£æ„å…ƒç»„ =====

a = 1, b = hello, c = 3.14
x = 1, z = 3.14

===== if let å’Œ while let =====

å€¼æ˜¯: 3
å¼¹å‡º: 3
å¼¹å‡º: 2
å¼¹å‡º: 1

===== åŒ¹é…å®ˆå« =====

å°äº5: 4

===== @ ç»‘å®š =====

å€¼åœ¨11-20ä¹‹é—´: 15
```

---

## ğŸš€ Tier 2: å®è·µåº”ç”¨ç¤ºä¾‹

### ç¤ºä¾‹2.1: Trait Bounds çº¦æŸ

**ç›®æ ‡**: æŒæ¡æ³›å‹ç±»å‹çš„ Trait çº¦æŸ

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::fmt::Display;

fn main() {
    println!("===== åŸºç¡€ Trait Bound =====\n");

    // å‡½æ•°éœ€è¦ç±»å‹å®ç° Display trait
    fn print_it<T: Display>(item: T) {
        println!("Item: {}", item);
    }

    print_it(42);
    print_it("Hello");
    print_it(3.14);

    // print_it(vec![1, 2, 3]);  // âŒ Vec æ²¡æœ‰å®ç° Display

    println!("\n===== å¤šä¸ª Trait Bounds =====\n");

    use std::fmt::Debug;

    // è¦æ±‚åŒæ—¶å®ç°å¤šä¸ª trait
    fn print_debug_display<T: Debug + Display>(item: T) {
        println!("Debug: {:?}", item);
        println!("Display: {}", item);
    }

    print_debug_display(42);

    println!("\n===== where å­å¥ =====\n");

    // ä½¿ç”¨ where å­å¥ä½¿ä»£ç æ›´æ¸…æ™°
    fn complex<T, U>(t: &T, u: &U)
    where
        T: Display + Clone,
        U: Debug + Clone,
    {
        println!("T: {}", t);
        println!("U: {:?}", u);
    }

    let str_val = String::from("hello");
    let vec_val = vec![1, 2, 3];

    complex(&str_val, &vec_val);

    println!("\n===== ç»“æ„ä½“çš„ Trait Bound =====\n");

    // ä¸ºæ³›å‹ç»“æ„ä½“æ·»åŠ  trait bound
    struct Pair<T: Display> {
        x: T,
        y: T,
    }

    impl<T: Display> Pair<T> {
        fn new(x: T, y: T) -> Self {
            Pair { x, y }
        }

        fn show(&self) {
            println!("Pair: ({}, {})", self.x, self.y);
        }
    }

    let pair = Pair::new(10, 20);
    pair.show();

    let pair_str = Pair::new("hello", "world");
    pair_str.show();

    println!("\n===== æ¡ä»¶å®ç° =====\n");

    // åªæœ‰å½“ T å®ç°äº†ç‰¹å®š trait æ—¶æ‰å®ç°æ–¹æ³•
    struct Wrapper<T> {
        value: T,
    }

    impl<T> Wrapper<T> {
        fn new(value: T) -> Self {
            Wrapper { value }
        }
    }

    // åªä¸ºå®ç°äº† Display çš„ T æ·»åŠ  print æ–¹æ³•
    impl<T: Display> Wrapper<T> {
        fn print(&self) {
            println!("Value: {}", self.value);
        }
    }

    let wrapper_int = Wrapper::new(42);
    wrapper_int.print();  // âœ… i32 å®ç°äº† Display

    let wrapper_vec = Wrapper::new(vec![1, 2, 3]);
    // wrapper_vec.print();  // âŒ Vec æ²¡æœ‰å®ç° Display

    println!("\n===== è¿”å›å€¼çš„ Trait Bound =====\n");

    // è¿”å›å®ç°äº†ç‰¹å®š trait çš„ç±»å‹
    fn returns_display() -> impl Display {
        42
    }

    fn returns_clone() -> impl Clone {
        vec![1, 2, 3]
    }

    println!("è¿”å›å€¼: {}", returns_display());
    let cloned = returns_clone();
    println!("å…‹éš†: {:?}", cloned);
}
```

**è¯´æ˜**:

- **Trait Bound**: çº¦æŸæ³›å‹å‚æ•°å¿…é¡»å®ç°ç‰¹å®š trait
- **å¤šä¸ªçº¦æŸ**: ä½¿ç”¨ `+` è¿æ¥å¤šä¸ª trait
- **where å­å¥**: ç®€åŒ–å¤æ‚çš„æ³›å‹çº¦æŸ
- **æ¡ä»¶å®ç°**: æ ¹æ®ç±»å‹ç‰¹æ€§æœ‰é€‰æ‹©åœ°å®ç°æ–¹æ³•

**è¾“å‡º**:

```text
===== åŸºç¡€ Trait Bound =====

Item: 42
Item: Hello
Item: 3.14

===== å¤šä¸ª Trait Bounds =====

Debug: 42
Display: 42

===== where å­å¥ =====

T: hello
U: [1, 2, 3]

===== ç»“æ„ä½“çš„ Trait Bound =====

Pair: (10, 20)
Pair: (hello, world)

===== æ¡ä»¶å®ç° =====

Value: 42

===== è¿”å›å€¼çš„ Trait Bound =====

è¿”å›å€¼: 42
å…‹éš†: [1, 2, 3]
```

---

_ç”±äºæ–‡æ¡£é•¿åº¦ï¼Œæˆ‘å°†ç»§ç»­åœ¨ä¸‹ä¸€éƒ¨åˆ†æ·»åŠ å‰©ä½™çš„ç¤ºä¾‹..._

ç»§ç»­è¡¥å……å…¶ä½™ç¤ºä¾‹ï¼Œä½¿æ–‡æ¡£å®Œæ•´åŒ…å« Tier 2 å’Œ Tier 3 çš„æ‰€æœ‰å†…å®¹ã€‚

### ç¤ºä¾‹2.2: æ³›å‹å‡½æ•°å’Œç»“æ„ä½“

**ç›®æ ‡**: æ·±å…¥ç†è§£æ³›å‹ç¼–ç¨‹

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== æ³›å‹å‡½æ•° =====\n");

    // æœ€ç®€å•çš„æ³›å‹å‡½æ•°
    fn largest<T: PartialOrd>(list: &[T]) -> &T {
        let mut largest = &list[0];

        for item in list {
            if item > largest {
                largest = item;
            }
        }

        largest
    }

    let numbers = vec![34, 50, 25, 100, 65];
    println!("æœ€å¤§æ•°å­—: {}", largest(&numbers));

    let chars = vec!['y', 'm', 'a', 'q'];
    println!("æœ€å¤§å­—ç¬¦: {}", largest(&chars));

    println!("\n===== æ³›å‹ç»“æ„ä½“ =====\n");

    // å•ä¸ªç±»å‹å‚æ•°
    struct Point<T> {
        x: T,
        y: T,
    }

    impl<T> Point<T> {
        fn x(&self) -> &T {
            &self.x
        }
    }

    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };

    println!("æ•´æ•°ç‚¹ x: {}", integer_point.x());
    println!("æµ®ç‚¹ç‚¹ x: {}", float_point.x());

    // å¤šä¸ªç±»å‹å‚æ•°
    struct Point3D<T, U, V> {
        x: T,
        y: U,
        z: V,
    }

    let mixed = Point3D {
        x: 5,
        y: 10.4,
        z: "hello",
    };

    println!("æ··åˆç±»å‹ç‚¹: ({}, {}, {})", mixed.x, mixed.y, mixed.z);

    println!("\n===== æ–¹æ³•ä¸­çš„æ³›å‹ =====\n");

    struct Pair<T, U> {
        first: T,
        second: U,
    }

    impl<T, U> Pair<T, U> {
        fn new(first: T, second: U) -> Self {
            Pair { first, second }
        }

        // æ–¹æ³•å¯ä»¥å¼•å…¥æ–°çš„ç±»å‹å‚æ•°
        fn mix<V, W>(self, other: Pair<V, W>) -> Pair<T, W> {
            Pair {
                first: self.first,
                second: other.second,
            }
        }
    }

    let pair1 = Pair::new(1, "hello");
    let pair2 = Pair::new(3.14, true);

    let mixed_pair = pair1.mix(pair2);
    println!("æ··åˆå: ({}, {})", mixed_pair.first, mixed_pair.second);

    println!("\n===== å…·ä½“åŒ–æ³›å‹ =====\n");

    // ä¸ºç‰¹å®šç±»å‹å®ç°æ–¹æ³•
    impl Point<f64> {
        fn distance_from_origin(&self) -> f64 {
            (self.x.powi(2) + self.y.powi(2)).sqrt()
        }
    }

    let p = Point { x: 3.0, y: 4.0 };
    println!("è·ç¦»åŸç‚¹: {}", p.distance_from_origin());

    // åªæœ‰ Point<f64> æœ‰è¿™ä¸ªæ–¹æ³•
    // integer_point.distance_from_origin();  // âŒ ç¼–è¯‘é”™è¯¯
}
```

**è¯´æ˜**:

- **æ³›å‹å‡½æ•°**: å¯ä»¥å¤„ç†ä¸åŒç±»å‹çš„å‚æ•°
- **æ³›å‹ç»“æ„ä½“**: æ”¯æŒå•ä¸ªæˆ–å¤šä¸ªç±»å‹å‚æ•°
- **æ–¹æ³•æ³›å‹**: impl å—ä¹Ÿå¯ä»¥ä½¿ç”¨æ³›å‹
- **å…·ä½“åŒ–**: ä¸ºç‰¹å®šç±»å‹å‚æ•°å®ç°ç‰¹æ®Šæ–¹æ³•

**è¾“å‡º**:

```text
===== æ³›å‹å‡½æ•° =====

æœ€å¤§æ•°å­—: 100
æœ€å¤§å­—ç¬¦: y

===== æ³›å‹ç»“æ„ä½“ =====

æ•´æ•°ç‚¹ x: 5
æµ®ç‚¹ç‚¹ x: 1

æ··åˆç±»å‹ç‚¹: (5, 10.4, hello)

===== æ–¹æ³•ä¸­çš„æ³›å‹ =====

æ··åˆå: (1, true)

===== å…·ä½“åŒ–æ³›å‹ =====

è·ç¦»åŸç‚¹: 5
```

---

### ç¤ºä¾‹2.3: å¤šæ€å’ŒåŠ¨æ€åˆ†æ´¾

**ç›®æ ‡**: ç†è§£é™æ€åˆ†æ´¾å’ŒåŠ¨æ€åˆ†æ´¾çš„åŒºåˆ«

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é™æ€åˆ†æ´¾ =====\n");

    trait Animal {
        fn make_sound(&self);
    }

    struct Dog;
    struct Cat;

    impl Animal for Dog {
        fn make_sound(&self) {
            println!("æ±ªæ±ª!");
        }
    }

    impl Animal for Cat {
        fn make_sound(&self) {
            println!("å–µå–µ!");
        }
    }

    // é™æ€åˆ†æ´¾: ç¼–è¯‘æ—¶ç¡®å®šå…·ä½“ç±»å‹
    fn static_dispatch<T: Animal>(animal: &T) {
        animal.make_sound();
    }

    let dog = Dog;
    let cat = Cat;

    static_dispatch(&dog);  // ç¼–è¯‘å™¨ç”Ÿæˆ static_dispatch<Dog>
    static_dispatch(&cat);  // ç¼–è¯‘å™¨ç”Ÿæˆ static_dispatch<Cat>

    println!("\n===== åŠ¨æ€åˆ†æ´¾ =====\n");

    // åŠ¨æ€åˆ†æ´¾: è¿è¡Œæ—¶ç¡®å®šå…·ä½“ç±»å‹
    fn dynamic_dispatch(animal: &dyn Animal) {
        animal.make_sound();
    }

    dynamic_dispatch(&dog);
    dynamic_dispatch(&cat);

    println!("\n===== Trait å¯¹è±¡é›†åˆ =====\n");

    // ä½¿ç”¨åŠ¨æ€åˆ†æ´¾å¯ä»¥å°†ä¸åŒç±»å‹æ”¾åœ¨åŒä¸€é›†åˆä¸­
    let animals: Vec<Box<dyn Animal>> = vec![
        Box::new(Dog),
        Box::new(Cat),
        Box::new(Dog),
    ];

    for animal in &animals {
        animal.make_sound();
    }

    println!("\n===== å¯¹æ¯” =====\n");

    println!("é™æ€åˆ†æ´¾ (æ³›å‹):");
    println!("  âœ… æ€§èƒ½å¥½ (é›¶å¼€é”€æŠ½è±¡)");
    println!("  âœ… å†…è”ä¼˜åŒ–");
    println!("  âŒ ä»£ç è†¨èƒ€ (å•æ€åŒ–)");
    println!("  âŒ ä¸èƒ½å­˜å‚¨åœ¨é›†åˆä¸­");

    println!("\nåŠ¨æ€åˆ†æ´¾ (trait å¯¹è±¡):");
    println!("  âœ… çµæ´» (è¿è¡Œæ—¶å¤šæ€)");
    println!("  âœ… ä»£ç å°");
    println!("  âœ… å¯ä»¥å­˜å‚¨åœ¨é›†åˆä¸­");
    println!("  âŒ è™šå‡½æ•°è°ƒç”¨å¼€é”€");
    println!("  âŒ ä¸èƒ½ä½¿ç”¨æ³›å‹æ–¹æ³•");
}
```

**è¯´æ˜**:

- **é™æ€åˆ†æ´¾**: ä½¿ç”¨æ³›å‹ï¼Œç¼–è¯‘æ—¶ç¡®å®šç±»å‹ï¼ˆå•æ€åŒ–ï¼‰
- **åŠ¨æ€åˆ†æ´¾**: ä½¿ç”¨ trait å¯¹è±¡ï¼Œè¿è¡Œæ—¶ç¡®å®šç±»å‹
- **trade-off**: æ€§èƒ½ vs çµæ´»æ€§

**è¾“å‡º**:

```text
===== é™æ€åˆ†æ´¾ =====

æ±ªæ±ª!
å–µå–µ!

===== åŠ¨æ€åˆ†æ´¾ =====

æ±ªæ±ª!
å–µå–µ!

===== Trait å¯¹è±¡é›†åˆ =====

æ±ªæ±ª!
å–µå–µ!
æ±ªæ±ª!

===== å¯¹æ¯” =====

é™æ€åˆ†æ´¾ (æ³›å‹):
  âœ… æ€§èƒ½å¥½ (é›¶å¼€é”€æŠ½è±¡)
  âœ… å†…è”ä¼˜åŒ–
  âŒ ä»£ç è†¨èƒ€ (å•æ€åŒ–)
  âŒ ä¸èƒ½å­˜å‚¨åœ¨é›†åˆä¸­

åŠ¨æ€åˆ†æ´¾ (trait å¯¹è±¡):
  âœ… çµæ´» (è¿è¡Œæ—¶å¤šæ€)
  âœ… ä»£ç å°
  âœ… å¯ä»¥å­˜å‚¨åœ¨é›†åˆä¸­
  âŒ è™šå‡½æ•°è°ƒç”¨å¼€é”€
  âŒ ä¸èƒ½ä½¿ç”¨æ³›å‹æ–¹æ³•
```

---

### ç¤ºä¾‹2.4: å…³è”ç±»å‹

**ç›®æ ‡**: æŒæ¡ Trait çš„å…³è”ç±»å‹

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== å…³è”ç±»å‹åŸºç¡€ =====\n");

    // ä½¿ç”¨å…³è”ç±»å‹çš„ Iterator trait
    trait Iterator {
        type Item;  // å…³è”ç±»å‹

        fn next(&mut self) -> Option<Self::Item>;
    }

    struct Counter {
        count: u32,
        max: u32,
    }

    impl Counter {
        fn new(max: u32) -> Counter {
            Counter { count: 0, max }
        }
    }

    impl Iterator for Counter {
        type Item = u32;  // æŒ‡å®šå…³è”ç±»å‹

        fn next(&mut self) -> Option<Self::Item> {
            if self.count < self.max {
                self.count += 1;
                Some(self.count)
            } else {
                None
            }
        }
    }

    let mut counter = Counter::new(5);

    while let Some(value) = counter.next() {
        println!("è®¡æ•°: {}", value);
    }

    println!("\n===== å…³è”ç±»å‹ vs æ³›å‹ =====\n");

    // ä½¿ç”¨æ³›å‹ (å¯ä»¥æœ‰å¤šä¸ªå®ç°)
    trait Container<T> {
        fn add(&mut self, item: T);
        fn get(&self) -> Option<&T>;
    }

    // ä½¿ç”¨å…³è”ç±»å‹ (åªèƒ½æœ‰ä¸€ä¸ªå®ç°)
    trait ContainerAssoc {
        type Item;
        fn add(&mut self, item: Self::Item);
        fn get(&self) -> Option<&Self::Item>;
    }

    struct IntContainer {
        value: Option<i32>,
    }

    impl ContainerAssoc for IntContainer {
        type Item = i32;

        fn add(&mut self, item: Self::Item) {
            self.value = Some(item);
        }

        fn get(&self) -> Option<&Self::Item> {
            self.value.as_ref()
        }
    }

    let mut container = IntContainer { value: None };
    container.add(42);

    if let Some(value) = container.get() {
        println!("å®¹å™¨å€¼: {}", value);
    }

    println!("\n===== å¤æ‚å…³è”ç±»å‹ =====\n");

    trait Graph {
        type Node;
        type Edge;

        fn nodes(&self) -> Vec<&Self::Node>;
        fn edges(&self) -> Vec<&Self::Edge>;
        fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool;
    }

    struct SimpleGraph {
        nodes: Vec<String>,
        edges: Vec<(usize, usize)>,
    }

    impl Graph for SimpleGraph {
        type Node = String;
        type Edge = (usize, usize);

        fn nodes(&self) -> Vec<&Self::Node> {
            self.nodes.iter().collect()
        }

        fn edges(&self) -> Vec<&Self::Edge> {
            self.edges.iter().collect()
        }

        fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool {
            let from_idx = self.nodes.iter().position(|n| n == from);
            let to_idx = self.nodes.iter().position(|n| n == to);

            if let (Some(f), Some(t)) = (from_idx, to_idx) {
                self.edges.contains(&(f, t))
            } else {
                false
            }
        }
    }

    let graph = SimpleGraph {
        nodes: vec![
            String::from("A"),
            String::from("B"),
            String::from("C"),
        ],
        edges: vec![(0, 1), (1, 2)],
    };

    println!("èŠ‚ç‚¹æ•°: {}", graph.nodes().len());
    println!("è¾¹æ•°: {}", graph.edges().len());

    let a = String::from("A");
    let b = String::from("B");
    let c = String::from("C");

    println!("A -> B: {}", graph.has_edge(&a, &b));
    println!("A -> C: {}", graph.has_edge(&a, &c));
}
```

**è¯´æ˜**:

- **å…³è”ç±»å‹**: Trait ä¸­çš„ç±»å‹å ä½ç¬¦
- **vs æ³›å‹**: å…³è”ç±»å‹æ¯ä¸ªç±»å‹åªèƒ½æœ‰ä¸€ä¸ªå®ç°
- **ç®€åŒ–**: é¿å…åœ¨ä½¿ç”¨ trait æ—¶æŒ‡å®šç±»å‹å‚æ•°
- **æ ‡å‡†åº“**: Iteratorã€Add ç­‰éƒ½ä½¿ç”¨å…³è”ç±»å‹

**è¾“å‡º**:

```text
===== å…³è”ç±»å‹åŸºç¡€ =====

è®¡æ•°: 1
è®¡æ•°: 2
è®¡æ•°: 3
è®¡æ•°: 4
è®¡æ•°: 5

===== å…³è”ç±»å‹ vs æ³›å‹ =====

å®¹å™¨å€¼: 42

===== å¤æ‚å…³è”ç±»å‹ =====

èŠ‚ç‚¹æ•°: 3
è¾¹æ•°: 2
A -> B: true
A -> C: false
```

---

### ç¤ºä¾‹2.5: Trait å¯¹è±¡è¯¦è§£

**ç›®æ ‡**: æ·±å…¥ç†è§£ Trait å¯¹è±¡çš„ä½¿ç”¨å’Œé™åˆ¶

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== åˆ›å»º Trait å¯¹è±¡ =====\n");

    trait Draw {
        fn draw(&self);
    }

    struct Circle {
        radius: f64,
    }

    struct Rectangle {
        width: f64,
        height: f64,
    }

    impl Draw for Circle {
        fn draw(&self) {
            println!("ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: {}", self.radius);
        }
    }

    impl Draw for Rectangle {
        fn draw(&self) {
            println!("ç»˜åˆ¶çŸ©å½¢ï¼Œ{}x{}", self.width, self.height);
        }
    }

    // ä½¿ç”¨ Box<dyn Trait>
    let circle: Box<dyn Draw> = Box::new(Circle { radius: 5.0 });
    let rectangle: Box<dyn Draw> = Box::new(Rectangle {
        width: 10.0,
        height: 20.0,
    });

    circle.draw();
    rectangle.draw();

    println!("\n===== Trait å¯¹è±¡é›†åˆ =====\n");

    let shapes: Vec<Box<dyn Draw>> = vec![
        Box::new(Circle { radius: 3.0 }),
        Box::new(Rectangle {
            width: 4.0,
            height: 5.0,
        }),
        Box::new(Circle { radius: 7.0 }),
    ];

    for shape in &shapes {
        shape.draw();
    }

    println!("\n===== å¯¹è±¡å®‰å…¨ =====\n");

    // å¯¹è±¡å®‰å…¨çš„ trait (å¯ä»¥ä½œä¸º trait å¯¹è±¡)
    trait ObjectSafe {
        fn method(&self);
    }

    // ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„ trait
    // trait NotObjectSafe {
    //     fn generic_method<T>(&self, item: T);  // âŒ æ³›å‹æ–¹æ³•
    //     fn returns_self() -> Self;              // âŒ è¿”å› Self
    // }

    println!("å¯¹è±¡å®‰å…¨è¦æ±‚:");
    println!("  âœ… æ²¡æœ‰æ³›å‹æ–¹æ³•");
    println!("  âœ… ä¸è¿”å› Self");
    println!("  âœ… æ²¡æœ‰å…³è”å‡½æ•°");

    println!("\n===== Trait å¯¹è±¡çš„å¤§å° =====\n");

    let circle = Circle { radius: 5.0 };
    let trait_obj: &dyn Draw = &circle;

    println!("Circle å¤§å°: {}", std::mem::size_of_val(&circle));
    println!("Trait å¯¹è±¡å¤§å°: {}", std::mem::size_of_val(&trait_obj));
    println!("(Trait å¯¹è±¡ = æ•°æ®æŒ‡é’ˆ + vtable æŒ‡é’ˆ)");

    println!("\n===== å¤šä¸ª Trait Bounds =====\n");

    use std::fmt::Debug;

    trait Printable: Debug {
        fn print(&self) {
            println!("{:?}", self);
        }
    }

    #[derive(Debug)]
    struct Data {
        value: i32,
    }

    impl Printable for Data {}

    // ä½¿ç”¨å¤šä¸ª trait
    fn process(item: &(dyn Printable + Send)) {
        item.print();
    }

    let data = Data { value: 42 };
    process(&data);
}
```

**è¯´æ˜**:

- **Trait å¯¹è±¡**: `dyn Trait` è¯­æ³•
- **Box/&**: ä½¿ç”¨æŒ‡é’ˆåˆ›å»º trait å¯¹è±¡
- **å¯¹è±¡å®‰å…¨**: ä¸æ˜¯æ‰€æœ‰ trait éƒ½èƒ½ä½œä¸º trait å¯¹è±¡
- **å¤§å°**: Trait å¯¹è±¡æ˜¯èƒ–æŒ‡é’ˆï¼ˆæ•°æ® + vtableï¼‰

**è¾“å‡º**:

```text
===== åˆ›å»º Trait å¯¹è±¡ =====

ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 5
ç»˜åˆ¶çŸ©å½¢ï¼Œ10x20

===== Trait å¯¹è±¡é›†åˆ =====

ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 3
ç»˜åˆ¶çŸ©å½¢ï¼Œ4x5
ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 7

===== å¯¹è±¡å®‰å…¨ =====

å¯¹è±¡å®‰å…¨è¦æ±‚:
  âœ… æ²¡æœ‰æ³›å‹æ–¹æ³•
  âœ… ä¸è¿”å› Self
  âœ… æ²¡æœ‰å…³è”å‡½æ•°

===== Trait å¯¹è±¡çš„å¤§å° =====

Circle å¤§å°: 8
Trait å¯¹è±¡å¤§å°: 16
(Trait å¯¹è±¡ = æ•°æ®æŒ‡é’ˆ + vtable æŒ‡é’ˆ)

===== å¤šä¸ª Trait Bounds =====

Data { value: 42 }
```

---

### ç¤ºä¾‹2.6: é»˜è®¤å®ç°å’Œé‡å†™

**ç›®æ ‡**: æŒæ¡ Trait çš„é»˜è®¤å®ç°

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é»˜è®¤å®ç° =====\n");

    trait Summary {
        // å¿…é¡»å®ç°
        fn author(&self) -> String;

        // æœ‰é»˜è®¤å®ç°
        fn summarize(&self) -> String {
            format!("(é˜…è¯»æ›´å¤šæ¥è‡ª {}...)", self.author())
        }
    }

    struct Article {
        title: String,
        author: String,
        content: String,
    }

    impl Summary for Article {
        fn author(&self) -> String {
            self.author.clone()
        }

        // ä½¿ç”¨é»˜è®¤çš„ summarize
    }

    let article = Article {
        title: String::from("Rust ç¼–ç¨‹"),
        author: String::from("å¼ ä¸‰"),
        content: String::from("å†…å®¹..."),
    };

    println!("é»˜è®¤æ‘˜è¦: {}", article.summarize());

    println!("\n===== é‡å†™é»˜è®¤å®ç° =====\n");

    struct Tweet {
        username: String,
        content: String,
    }

    impl Summary for Tweet {
        fn author(&self) -> String {
            format!("@{}", self.username)
        }

        // é‡å†™é»˜è®¤å®ç°
        fn summarize(&self) -> String {
            format!("{}: {}", self.author(), self.content)
        }
    }

    let tweet = Tweet {
        username: String::from("æå››"),
        content: String::from("å­¦ä¹  Rust!"),
    };

    println!("è‡ªå®šä¹‰æ‘˜è¦: {}", tweet.summarize());

    println!("\n===== é»˜è®¤å®ç°è°ƒç”¨å…¶ä»–æ–¹æ³• =====\n");

    trait Display {
        fn title(&self) -> String;
        fn author(&self) -> String;

        // é»˜è®¤å®ç°å¯ä»¥è°ƒç”¨å…¶ä»–æ–¹æ³•
        fn format(&self) -> String {
            format!("ã€Š{}ã€‹ by {}", self.title(), self.author())
        }
    }

    struct Book {
        title: String,
        author: String,
    }

    impl Display for Book {
        fn title(&self) -> String {
            self.title.clone()
        }

        fn author(&self) -> String {
            self.author.clone()
        }

        // format ä½¿ç”¨é»˜è®¤å®ç°
    }

    let book = Book {
        title: String::from("Rust ç¨‹åºè®¾è®¡"),
        author: String::from("ç‹äº”"),
    };

    println!("æ ¼å¼åŒ–: {}", book.format());

    println!("\n===== éƒ¨åˆ†é‡å†™ =====\n");

    trait Config {
        fn debug(&self) -> bool {
            false  // é»˜è®¤å…³é—­ debug
        }

        fn timeout(&self) -> u32 {
            30  // é»˜è®¤ 30 ç§’
        }

        fn log_level(&self) -> &str {
            "info"  // é»˜è®¤ info çº§åˆ«
        }
    }

    struct AppConfig;

    impl Config for AppConfig {
        // åªé‡å†™éœ€è¦æ”¹å˜çš„
        fn debug(&self) -> bool {
            true
        }

        // timeout å’Œ log_level ä½¿ç”¨é»˜è®¤å€¼
    }

    let config = AppConfig;
    println!("Debug: {}", config.debug());
    println!("Timeout: {}", config.timeout());
    println!("Log Level: {}", config.log_level());
}
```

**è¯´æ˜**:

- **é»˜è®¤å®ç°**: Trait å¯ä»¥æä¾›æ–¹æ³•çš„é»˜è®¤å®ç°
- **é€‰æ‹©æ€§é‡å†™**: åªé‡å†™éœ€è¦æ”¹å˜çš„æ–¹æ³•
- **è°ƒç”¨å…¶ä»–æ–¹æ³•**: é»˜è®¤å®ç°å¯ä»¥è°ƒç”¨ trait çš„å…¶ä»–æ–¹æ³•
- **çµæ´»æ€§**: å‡å°‘æ ·æ¿ä»£ç ï¼Œæä¾›åˆç†é»˜è®¤å€¼

**è¾“å‡º**:

```text
===== é»˜è®¤å®ç° =====

é»˜è®¤æ‘˜è¦: (é˜…è¯»æ›´å¤šæ¥è‡ª å¼ ä¸‰...)

===== é‡å†™é»˜è®¤å®ç° =====

è‡ªå®šä¹‰æ‘˜è¦: @æå››: å­¦ä¹  Rust!

===== é»˜è®¤å®ç°è°ƒç”¨å…¶ä»–æ–¹æ³• =====

æ ¼å¼åŒ–: ã€ŠRust ç¨‹åºè®¾è®¡ã€‹ by ç‹äº”

===== éƒ¨åˆ†é‡å†™ =====

Debug: true
Timeout: 30
Log Level: info
```

---

## ğŸ“ Tier 3: é«˜çº§ç±»å‹ç³»ç»Ÿç¤ºä¾‹

### ç¤ºä¾‹3.1: é«˜çº§ Trait æ¨¡å¼

**ç›®æ ‡**: æŒæ¡é«˜é˜¶ Trait Bounds (HRTB) ç­‰é«˜çº§æ¨¡å¼

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é«˜é˜¶ Trait Bounds (HRTB) =====\n");

    // HRTB: for<'a> è¯­æ³•
    fn apply<F>(f: F) -> String
    where
        F: for<'a> Fn(&'a str) -> &'a str,
    {
        f("hello")
    }

    let uppercase = |s: &str| -> &str { s };
    println!("Result: {}", apply(uppercase));

    println!("\n===== Supertraits =====\n");

    use std::fmt::Display;

    // Supertrait: OutlinePrint è¦æ±‚å®ç° Display
    trait OutlinePrint: Display {
        fn outline_print(&self) {
            let output = self.to_string();
            let len = output.len();
            println!("{}", "*".repeat(len + 4));
            println!("*{}*", " ".repeat(len + 2));
            println!("* {} *", output);
            println!("*{}*", " ".repeat(len + 2));
            println!("{}", "*".repeat(len + 4));
        }
    }

    struct Point {
        x: i32,
        y: i32,
    }

    impl Display for Point {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "({}, {})", self.x, self.y)
        }
    }

    impl OutlinePrint for Point {}

    let p = Point { x: 1, y: 3 };
    p.outline_print();

    println!("\n===== Newtype æ¨¡å¼ç»•è¿‡å­¤å„¿è§„åˆ™ =====\n");

    // æ— æ³•ç›´æ¥ä¸º Vec<T> å®ç° Display (å­¤å„¿è§„åˆ™)
    // ä½†å¯ä»¥ä½¿ç”¨ newtype æ¨¡å¼

    struct Wrapper(Vec<String>);

    impl Display for Wrapper {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "[{}]", self.0.join(", "))
        }
    }

    let w = Wrapper(vec![
        String::from("hello"),
        String::from("world"),
    ]);

    println!("Wrapper: {}", w);

    println!("\n===== å®Œå…¨é™å®šè¯­æ³• =====\n");

    trait Pilot {
        fn fly(&self);
    }

    trait Wizard {
        fn fly(&self);
    }

    struct Human;

    impl Pilot for Human {
        fn fly(&self) {
            println!("æœºé•¿åœ¨é©¾é©¶");
        }
    }

    impl Wizard for Human {
        fn fly(&self) {
            println!("å·«å¸ˆåœ¨é£è¡Œ");
        }
    }

    impl Human {
        fn fly(&self) {
            println!("*æŒ¥åŠ¨æ‰‹è‡‚*");
        }
    }

    let person = Human;

    // é»˜è®¤è°ƒç”¨ Human::fly
    person.fly();

    // å®Œå…¨é™å®šè¯­æ³•è°ƒç”¨ç‰¹å®š trait
    Pilot::fly(&person);
    Wizard::fly(&person);
    <Human as Pilot>::fly(&person);

    println!("\n===== å…³è”ç±»å‹çº¦æŸ =====\n");

    trait Container {
        type Item;
        fn contains(&self, item: &Self::Item) -> bool;
    }

    fn difference<C>(container: &C, item: &C::Item)
    where
        C: Container,
        C::Item: PartialEq,
    {
        if container.contains(item) {
            println!("åŒ…å«è¯¥é¡¹");
        } else {
            println!("ä¸åŒ…å«è¯¥é¡¹");
        }
    }

    struct MyVec<T>(Vec<T>);

    impl<T> Container for MyVec<T> {
        type Item = T;

        fn contains(&self, item: &Self::Item) -> bool
        where
            T: PartialEq,
        {
            self.0.contains(item)
        }
    }

    let vec = MyVec(vec![1, 2, 3]);
    difference(&vec, &2);
}
```

**è¯´æ˜**:

- **HRTB**: é«˜é˜¶ trait boundsï¼Œå¤„ç†æ‰€æœ‰å¯èƒ½çš„ç”Ÿå‘½å‘¨æœŸ
- **Supertrait**: Trait ç»§æ‰¿ï¼Œè¦æ±‚å®ç°è€…ä¹Ÿå®ç°å¦ä¸€ä¸ª trait
- **Newtype**: ç»•è¿‡å­¤å„¿è§„åˆ™çš„æ¨¡å¼
- **å®Œå…¨é™å®šè¯­æ³•**: æ˜ç¡®æŒ‡å®šè°ƒç”¨å“ªä¸ª trait çš„æ–¹æ³•

**è¾“å‡º**:

```text
===== é«˜é˜¶ Trait Bounds (HRTB) =====

Result: hello

===== Supertraits =====

*********
*       *
* (1, 3) *
*       *
*********

===== Newtype æ¨¡å¼ç»•è¿‡å­¤å„¿è§„åˆ™ =====

Wrapper: [hello, world]

===== å®Œå…¨é™å®šè¯­æ³• =====

*æŒ¥åŠ¨æ‰‹è‡‚*
æœºé•¿åœ¨é©¾é©¶
å·«å¸ˆåœ¨é£è¡Œ
æœºé•¿åœ¨é©¾é©¶

===== å…³è”ç±»å‹çº¦æŸ =====

åŒ…å«è¯¥é¡¹
```

---

### ç¤ºä¾‹3.2: é›¶å¤§å°ç±»å‹ (ZST)

**ç›®æ ‡**: ç†è§£é›¶å¤§å°ç±»å‹çš„ç”¨é€”å’Œä¼˜åŒ–

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== å•å…ƒç»“æ„ä½“ (ZST) =====\n");

    struct Marker;

    let _m1 = Marker;
    let _m2 = Marker;

    println!("Marker å¤§å°: {} å­—èŠ‚", std::mem::size_of::<Marker>());
    println!("ZST ä¸å ç”¨å†…å­˜ç©ºé—´!");

    println!("\n===== ZST ç”¨äºç±»å‹çŠ¶æ€ =====\n");

    // ä½¿ç”¨ ZST è¡¨ç¤ºçŠ¶æ€
    struct Locked;
    struct Unlocked;

    struct Door<State> {
        _state: std::marker::PhantomData<State>,
    }

    impl Door<Locked> {
        fn new() -> Door<Locked> {
            println!("åˆ›å»ºé”å®šçš„é—¨");
            Door {
                _state: std::marker::PhantomData,
            }
        }

        fn unlock(self) -> Door<Unlocked> {
            println!("è§£é”é—¨");
            Door {
                _state: std::marker::PhantomData,
            }
        }
    }

    impl Door<Unlocked> {
        fn open(&self) {
            println!("æ‰“å¼€é—¨");
        }

        fn lock(self) -> Door<Locked> {
            println!("é”å®šé—¨");
            Door {
                _state: std::marker::PhantomData,
            }
        }
    }

    let door = Door::<Locked>::new();
    // door.open();  // âŒ ç¼–è¯‘é”™è¯¯: é”å®šçš„é—¨ä¸èƒ½æ‰“å¼€

    let door = door.unlock();
    door.open();  // âœ… è§£é”åå¯ä»¥æ‰“å¼€

    let _door = door.lock();

    println!("\n===== ZST å‘é‡ä¼˜åŒ– =====\n");

    let vec: Vec<()> = vec![(); 1000000];
    println!("Vec<()> å®¹é‡: {}", vec.capacity());
    println!("Vec<()> é•¿åº¦: {}", vec.len());
    println!("ä½†å®é™…åªå ç”¨æå°‘å†…å­˜!");

    println!("\n===== ZST é›†åˆ =====\n");

    use std::collections::HashSet;

    // ä½¿ç”¨ HashSet<T> ä½œä¸ºçº¯ç²¹çš„"é›†åˆ"å­˜åœ¨æ ‡è®°
    struct UniqueIds(HashSet<u32>);

    impl UniqueIds {
        fn new() -> Self {
            UniqueIds(HashSet::new())
        }

        fn mark(&mut self, id: u32) {
            self.0.insert(id);
        }

        fn is_marked(&self, id: u32) -> bool {
            self.0.contains(&id)
        }
    }

    let mut ids = UniqueIds::new();
    ids.mark(1);
    ids.mark(2);

    println!("ID 1 æ ‡è®°: {}", ids.is_marked(1));
    println!("ID 3 æ ‡è®°: {}", ids.is_marked(3));

    println!("\n===== æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹ =====\n");

    // ZST ä½œä¸ºè¿­ä»£å™¨çš„çŠ¶æ€
    struct RangeIter {
        current: u32,
        end: u32,
    }

    impl RangeIter {
        fn new(end: u32) -> Self {
            RangeIter { current: 0, end }
        }
    }

    impl Iterator for RangeIter {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            if self.current < self.end {
                let result = self.current;
                self.current += 1;
                Some(result)
            } else {
                None
            }
        }
    }

    let sum: u32 = RangeIter::new(5).sum();
    println!("Sum 0-4: {}", sum);
}
```

**è¯´æ˜**:

- **ZST**: é›¶å¤§å°ç±»å‹ï¼Œä¸å ç”¨å†…å­˜
- **ç±»å‹çŠ¶æ€**: ä½¿ç”¨ ZST åœ¨ç±»å‹å±‚é¢è¡¨ç¤ºçŠ¶æ€
- **ç¼–è¯‘æ—¶æ£€æŸ¥**: çŠ¶æ€è½¬æ¢åœ¨ç¼–è¯‘æ—¶éªŒè¯
- **æ€§èƒ½**: Vec<()> ç­‰é›†åˆå¯¹ ZST æœ‰ç‰¹æ®Šä¼˜åŒ–

**è¾“å‡º**:

```text
===== å•å…ƒç»“æ„ä½“ (ZST) =====

Marker å¤§å°: 0 å­—èŠ‚
ZST ä¸å ç”¨å†…å­˜ç©ºé—´!

===== ZST ç”¨äºç±»å‹çŠ¶æ€ =====

åˆ›å»ºé”å®šçš„é—¨
è§£é”é—¨
æ‰“å¼€é—¨
é”å®šé—¨

===== ZST å‘é‡ä¼˜åŒ– =====

Vec<()> å®¹é‡: 1000000
Vec<()> é•¿åº¦: 1000000
ä½†å®é™…åªå ç”¨æå°‘å†…å­˜!

===== ZST é›†åˆ =====

ID 1 æ ‡è®°: true
ID 3 æ ‡è®°: false

===== æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹ =====

Sum 0-4: 10
```

---

### ç¤ºä¾‹3.3: PhantomData å’Œç±»å‹æ ‡è®°

**ç›®æ ‡**: ç†è§£ PhantomData çš„ç”¨é€”

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
use std::marker::PhantomData;

fn main() {
    println!("===== PhantomData åŸºç¡€ =====\n");

    // PhantomData è®©ç¼–è¯‘å™¨è®¤ä¸ºç»“æ„ä½“"ä½¿ç”¨"äº†ç±»å‹å‚æ•°
    struct Slice<'a, T> {
        ptr: *const T,
        len: usize,
        _marker: PhantomData<&'a T>,
    }

    println!("PhantomData å¤§å°: {}", std::mem::size_of::<PhantomData<i32>>());
    println!("(PhantomData æ˜¯é›¶å¤§å°ç±»å‹)");

    println!("\n===== ç±»å‹æ ‡è®° =====\n");

    // ä½¿ç”¨ PhantomData æ ‡è®°æœªä½¿ç”¨çš„ç±»å‹å‚æ•°
    struct Container<T> {
        data: Vec<u8>,
        _marker: PhantomData<T>,
    }

    impl<T> Container<T> {
        fn new() -> Self {
            Container {
                data: Vec::new(),
                _marker: PhantomData,
            }
        }
    }

    let _int_container: Container<i32> = Container::new();
    let _string_container: Container<String> = Container::new();

    println!("ç±»å‹æ ‡è®°è®©ç¼–è¯‘å™¨è·Ÿè¸ªç±»å‹å‚æ•°");

    println!("\n===== ç”Ÿå‘½å‘¨æœŸæ ‡è®° =====\n");

    // PhantomData å¯ä»¥æ ‡è®°ç”Ÿå‘½å‘¨æœŸ
    struct Borrowed<'a, T> {
        data: *const T,
        _marker: PhantomData<&'a T>,
    }

    impl<'a, T> Borrowed<'a, T> {
        fn new(data: &'a T) -> Self {
            Borrowed {
                data: data as *const T,
                _marker: PhantomData,
            }
        }

        unsafe fn get(&self) -> &'a T {
            &*self.data
        }
    }

    let value = 42;
    let borrowed = Borrowed::new(&value);

    unsafe {
        println!("å€Ÿç”¨çš„å€¼: {}", borrowed.get());
    }

    println!("\n===== æ‰€æœ‰æƒæ ‡è®° =====\n");

    // PhantomData<T> vs PhantomData<&T>
    struct Owns<T> {
        data: *mut T,
        _marker: PhantomData<T>,  // è¡¨ç¤º"æ‹¥æœ‰" T
    }

    impl<T> Owns<T> {
        fn new(data: T) -> Self {
            Owns {
                data: Box::into_raw(Box::new(data)),
                _marker: PhantomData,
            }
        }
    }

    impl<T> Drop for Owns<T> {
        fn drop(&mut self) {
            unsafe {
                // é‡Šæ”¾æ‹¥æœ‰çš„æ•°æ®
                Box::from_raw(self.data);
            }
        }
    }

    {
        let _owns = Owns::new(String::from("owned"));
        println!("Owns æŒæœ‰æ•°æ®");
    }
    println!("Owns ç¦»å¼€ä½œç”¨åŸŸ,æ•°æ®è¢«é‡Šæ”¾");

    println!("\n===== ç±»å‹çº§ç¼–ç¨‹ =====\n");

    // ä½¿ç”¨ PhantomData å®ç°ç±»å‹çº§çŠ¶æ€æœº
    struct Empty;
    struct NonEmpty;

    struct Stack<T, State> {
        data: Vec<T>,
        _state: PhantomData<State>,
    }

    impl<T> Stack<T, Empty> {
        fn new() -> Self {
            Stack {
                data: Vec::new(),
                _state: PhantomData,
            }
        }

        fn push(mut self, item: T) -> Stack<T, NonEmpty> {
            self.data.push(item);
            Stack {
                data: self.data,
                _state: PhantomData,
            }
        }
    }

    impl<T> Stack<T, NonEmpty> {
        fn pop(mut self) -> (T, Stack<T, Empty>) {
            let item = self.data.pop().unwrap();
            (
                item,
                Stack {
                    data: self.data,
                    _state: PhantomData,
                },
            )
        }

        fn push(mut self, item: T) -> Stack<T, NonEmpty> {
            self.data.push(item);
            self
        }
    }

    let stack = Stack::<i32, Empty>::new();
    let stack = stack.push(1);
    let stack = stack.push(2);

    let (item, _stack) = stack.pop();
    println!("å¼¹å‡º: {}", item);

    // ç©ºæ ˆä¸èƒ½ pop
    // let empty = Stack::<i32, Empty>::new();
    // empty.pop();  // âŒ ç¼–è¯‘é”™è¯¯
}
```

**è¯´æ˜**:

- **PhantomData**: é›¶å¤§å°ç±»å‹æ ‡è®°
- **æœªä½¿ç”¨ç±»å‹å‚æ•°**: è®©ç¼–è¯‘å™¨è®¤ä¸ºç±»å‹å‚æ•°è¢«ä½¿ç”¨
- **ç”Ÿå‘½å‘¨æœŸ**: æ ‡è®°æŒ‡é’ˆçš„ç”Ÿå‘½å‘¨æœŸ
- **æ‰€æœ‰æƒ**: æ ‡è®°æ•°æ®çš„æ‰€æœ‰æƒè¯­ä¹‰
- **ç±»å‹çŠ¶æ€**: å®ç°ç¼–è¯‘æ—¶çŠ¶æ€æœº

**è¾“å‡º**:

```text
===== PhantomData åŸºç¡€ =====

PhantomData å¤§å°: 0
(PhantomData æ˜¯é›¶å¤§å°ç±»å‹)

===== ç±»å‹æ ‡è®° =====

ç±»å‹æ ‡è®°è®©ç¼–è¯‘å™¨è·Ÿè¸ªç±»å‹å‚æ•°

===== ç”Ÿå‘½å‘¨æœŸæ ‡è®° =====

å€Ÿç”¨çš„å€¼: 42

===== æ‰€æœ‰æƒæ ‡è®° =====

Owns æŒæœ‰æ•°æ®
Owns ç¦»å¼€ä½œç”¨åŸŸ,æ•°æ®è¢«é‡Šæ”¾

===== ç±»å‹çº§ç¼–ç¨‹ =====

å¼¹å‡º: 2
```

---

### ç¤ºä¾‹3.4: é«˜çº§ç±»å‹ç³»ç»ŸæŠ€å·§

**ç›®æ ‡**: æŒæ¡ç±»å‹çº§ç¼–ç¨‹å’Œé«˜çº§æŠ€å·§

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Never Type (!) =====\n");

    // ! ç±»å‹è¡¨ç¤ºæ°¸ä¸è¿”å›
    fn diverges() -> ! {
        panic!("è¿™ä¸ªå‡½æ•°æ°¸ä¸è¿”å›");
    }

    // ! å¯ä»¥è½¬æ¢ä¸ºä»»ä½•ç±»å‹
    let x: i32 = match Some(5) {
        Some(n) => n,
        None => panic!("é”™è¯¯"),  // panic! è¿”å› !
    };

    println!("x = {}", x);

    println!("\n===== ç±»å‹åˆ«å =====\n");

    type Kilometers = i32;
    type Result<T> = std::result::Result<T, std::io::Error>;

    let distance: Kilometers = 5;
    println!("è·ç¦»: {} km", distance);

    // ç±»å‹åˆ«åå¯ä»¥å‡å°‘é‡å¤
    fn read_file() -> Result<String> {
        std::fs::read_to_string("file.txt")
    }

    match read_file() {
        Ok(content) => println!("å†…å®¹: {}", content),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    println!("\n===== åŠ¨æ€å¤§å°ç±»å‹ (DST) =====\n");

    // str æ˜¯ DST (ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥)
    // å¿…é¡»æ”¾åœ¨æŒ‡é’ˆåé¢: &str, Box<str>

    let s1: &str = "hello";  // âœ… å¼•ç”¨
    // let s2: str = "hello";  // âŒ ä¸èƒ½ç›´æ¥ä½¿ç”¨

    println!("å­—ç¬¦ä¸²åˆ‡ç‰‡: {}", s1);
    println!("&str å¤§å°: {}", std::mem::size_of_val(&s1));
    println!("(åŒ…å«æŒ‡é’ˆå’Œé•¿åº¦)");

    // [T] ä¹Ÿæ˜¯ DST
    let arr: &[i32] = &[1, 2, 3];
    println!("åˆ‡ç‰‡: {:?}", arr);

    println!("\n===== ç±»å‹çº§æ•°å­— =====\n");

    // ä½¿ç”¨ const æ³›å‹å®ç°ç±»å‹çº§æ•°å­—
    struct Array<T, const N: usize> {
        data: [T; N],
    }

    impl<T, const N: usize> Array<T, N> {
        fn len(&self) -> usize {
            N
        }
    }

    impl<T: Default + Copy, const N: usize> Array<T, N> {
        fn new() -> Self {
            Array {
                data: [T::default(); N],
            }
        }
    }

    let arr: Array<i32, 5> = Array::new();
    println!("æ•°ç»„é•¿åº¦: {}", arr.len());

    println!("\n===== ç±»å‹æ¨å¯¼æŠ€å·§ =====\n");

    // ä½¿ç”¨ turbofish è¯­æ³•æŒ‡å®šç±»å‹
    let numbers = vec![1, 2, 3, 4, 5];

    let doubled: Vec<_> = numbers.iter().map(|x| x * 2).collect();
    println!("doubled: {:?}", doubled);

    // é“¾å¼è½¬æ¢
    let result = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)
        .map(|x| x * x)
        .collect::<Vec<_>>();

    println!("å¶æ•°å¹³æ–¹: {:?}", result);

    println!("\n===== å¹½çµç±»å‹æ¨¡å¼ =====\n");

    use std::marker::PhantomData;

    // ä½¿ç”¨å¹½çµç±»å‹å®ç°ç±»å‹å®‰å…¨çš„å•ä½è½¬æ¢
    struct Quantity<Unit> {
        value: f64,
        _unit: PhantomData<Unit>,
    }

    struct Meter;
    struct Kilometer;

    impl Quantity<Meter> {
        fn to_kilometers(self) -> Quantity<Kilometer> {
            Quantity {
                value: self.value / 1000.0,
                _unit: PhantomData,
            }
        }
    }

    impl Quantity<Kilometer> {
        fn to_meters(self) -> Quantity<Meter> {
            Quantity {
                value: self.value * 1000.0,
                _unit: PhantomData,
            }
        }
    }

    let distance_m = Quantity::<Meter> {
        value: 5000.0,
        _unit: PhantomData,
    };

    let distance_km = distance_m.to_kilometers();
    println!("è·ç¦»: {} km", distance_km.value);

    // ç±»å‹å®‰å…¨: ä¸èƒ½æ··æ·†ä¸åŒå•ä½
    // let wrong: Quantity<Meter> = distance_km;  // âŒ ç¼–è¯‘é”™è¯¯
}
```

**è¯´æ˜**:

- **Never Type**: `!` ç±»å‹ï¼Œè¡¨ç¤ºæ°¸ä¸è¿”å›
- **ç±»å‹åˆ«å**: ç®€åŒ–å¤æ‚ç±»å‹ç­¾å
- **DST**: åŠ¨æ€å¤§å°ç±»å‹ï¼Œå¿…é¡»é€šè¿‡æŒ‡é’ˆä½¿ç”¨
- **const æ³›å‹**: ç±»å‹å‚æ•°å¯ä»¥æ˜¯å¸¸é‡å€¼
- **å¹½çµç±»å‹**: ä½¿ç”¨ PhantomData å®ç°ç±»å‹å®‰å…¨

**è¾“å‡º**:

```text
===== Never Type (!) =====

x = 5

===== ç±»å‹åˆ«å =====

è·ç¦»: 5 km
é”™è¯¯: No such file or directory (os error 2)

===== åŠ¨æ€å¤§å°ç±»å‹ (DST) =====

å­—ç¬¦ä¸²åˆ‡ç‰‡: hello
&str å¤§å°: 16
(åŒ…å«æŒ‡é’ˆå’Œé•¿åº¦)
åˆ‡ç‰‡: [1, 2, 3]

===== ç±»å‹çº§æ•°å­— =====

æ•°ç»„é•¿åº¦: 5

===== ç±»å‹æ¨å¯¼æŠ€å·§ =====

doubled: [2, 4, 6, 8, 10]
å¶æ•°å¹³æ–¹: [4, 16]

===== å¹½çµç±»å‹æ¨¡å¼ =====

è·ç¦»: 5 km
```

---

## ğŸ“ æ€»ç»“

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **ç¬¬ä¸€é˜¶æ®µ** (Tier 1): æŒæ¡åŸºç¡€ (ç¤ºä¾‹ 1.1-1.8)
   - ç»“æ„ä½“ã€æšä¸¾ã€Trait åŸºç¡€
   - Option/Result é”™è¯¯å¤„ç†
   - æ¨¡å¼åŒ¹é…

2. **ç¬¬äºŒé˜¶æ®µ** (Tier 2): å®è·µåº”ç”¨ (ç¤ºä¾‹ 2.1-2.6)
   - æ³›å‹ç¼–ç¨‹
   - Trait Bounds å’Œå…³è”ç±»å‹
   - åŠ¨æ€åˆ†æ´¾å’Œ Trait å¯¹è±¡

3. **ç¬¬ä¸‰é˜¶æ®µ** (Tier 3): æ·±å…¥ç†è§£ (ç¤ºä¾‹ 3.1-3.4)
   - é«˜çº§ Trait æ¨¡å¼
   - é›¶å¤§å°ç±»å‹
   - PhantomData å’Œç±»å‹çº§ç¼–ç¨‹

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ           | ç›¸å…³ç¤ºä¾‹ | é‡è¦æ€§     | éš¾åº¦     |
| :--- | :--- | :--- | :--- || ç»“æ„ä½“å’Œæ–¹æ³•   | 1.1, 1.2 | â­â­â­â­â­ | â­       |
| æšä¸¾å’Œæ¨¡å¼åŒ¹é… | 1.3, 1.8 | â­â­â­â­â­ | â­â­     |
| Option/Result  | 1.4      | â­â­â­â­â­ | â­â­     |
| Trait å®ç°     | 1.5, 1.6 | â­â­â­â­â­ | â­â­     |
| æ´¾ç”Ÿ Trait     | 1.7      | â­â­â­â­   | â­       |
| æ³›å‹ç¼–ç¨‹       | 2.1, 2.2 | â­â­â­â­â­ | â­â­     |
| å¤šæ€           | 2.3, 2.5 | â­â­â­â­   | â­â­â­   |
| å…³è”ç±»å‹       | 2.4      | â­â­â­â­   | â­â­â­   |
| HRTB           | 3.1      | â­â­â­     | â­â­â­â­ |
| ZST            | 3.2      | â­â­â­     | â­â­â­â­ |
| PhantomData    | 3.3      | â­â­â­     | â­â­â­â­ |
| ç±»å‹çº§ç¼–ç¨‹     | 3.4      | â­â­       | â­â­â­â­ |

### æœ€ä½³å®è·µ

1. **ç»“æ„ä½“è®¾è®¡**:
   - ä½¿ç”¨ç»“æ„ä½“ç»„ç»‡ç›¸å…³æ•°æ®
   - é€šè¿‡ impl å—æä¾›æ–¹æ³•
   - è€ƒè™‘ä½¿ç”¨å…ƒç»„ç»“æ„ä½“è¿›è¡Œç±»å‹å°è£…

2. **æšä¸¾ä½¿ç”¨**:
   - ç”¨æšä¸¾è¡¨ç¤º"å¤šé€‰ä¸€"çš„åœºæ™¯
   - å……åˆ†åˆ©ç”¨ Option å’Œ Result
   - ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†æ‰€æœ‰æƒ…å†µ

3. **Trait ç¼–ç¨‹**:
   - ä¸ºé€šç”¨è¡Œä¸ºå®šä¹‰ Trait
   - ä½¿ç”¨æ³›å‹å®ç°é›¶æˆæœ¬æŠ½è±¡
   - éœ€è¦è¿è¡Œæ—¶å¤šæ€æ—¶ä½¿ç”¨ Trait å¯¹è±¡

4. **ç±»å‹å®‰å…¨**:
   - åˆ©ç”¨ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶æ•è·é”™è¯¯
   - ä½¿ç”¨ newtype æ¨¡å¼å¢å¼ºç±»å‹å®‰å…¨
   - è€ƒè™‘ä½¿ç”¨ PhantomData å®ç°ç±»å‹çŠ¶æ€

### ä¸‹ä¸€æ­¥

- ğŸ“– æ·±å…¥å­¦ä¹ : [æ³›å‹ç¼–ç¨‹æŒ‡å—](./03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- ğŸ“– æ·±å…¥å­¦ä¹ : [Trait ç³»ç»ŸæŒ‡å—](./04_Traitç³»ç»ŸæŒ‡å—.md)
- ğŸš€ å®æˆ˜é¡¹ç›®: [C02 å®æˆ˜é¡¹ç›®é›†](./07_å®æˆ˜é¡¹ç›®é›†.md) (å³å°†åˆ›å»º)
- ğŸ“š å‚è€ƒæ–‡æ¡£: [tier_03_references](../tier_03_references/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ’¡ ç±»å‹ç³»ç»Ÿæ˜¯ Rust çš„æ ¸å¿ƒä¼˜åŠ¿ï¼ŒæŒæ¡å®ƒå°†ä½¿ä½ çš„ä»£ç æ›´åŠ å®‰å…¨å’Œé«˜æ•ˆ! ğŸ¦€**-
