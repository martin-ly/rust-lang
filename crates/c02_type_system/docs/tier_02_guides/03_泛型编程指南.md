# 2.3 Rust 类型系统 - 泛型编程指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统学习 Rust 泛型编程  
> **适用对象**: 中级开发者  
> **前置知识**: [2.1 基础类型指南](./01_基础类型指南.md), [2.2 复合类型指南](./02_复合类型指南.md)  
> **预计学习时间**: 6-8 小时  
> **最后更新**: 2025-10-22

---


## 📋 目录

- [2.3 Rust 类型系统 - 泛型编程指南](#23-rust-类型系统---泛型编程指南)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [📊 章节概览](#-章节概览)
  - [1. 泛型概述](#1-泛型概述)
    - [1.1 什么是泛型](#11-什么是泛型)
    - [1.2 泛型的优势](#12-泛型的优势)
    - [1.3 泛型 vs 动态分发](#13-泛型-vs-动态分发)
  - [2. 泛型函数](#2-泛型函数)
    - [2.1 基本泛型函数](#21-基本泛型函数)
    - [2.2 多个类型参数](#22-多个类型参数)
    - [2.3 类型推导](#23-类型推导)
  - [3. 泛型结构体](#3-泛型结构体)
    - [3.1 定义泛型结构体](#31-定义泛型结构体)
    - [3.2 泛型字段](#32-泛型字段)
    - [3.3 多类型参数结构体](#33-多类型参数结构体)
  - [4. 泛型枚举](#4-泛型枚举)
    - [4.1 标准库泛型枚举](#41-标准库泛型枚举)
    - [4.2 自定义泛型枚举](#42-自定义泛型枚举)
  - [5. 泛型方法](#5-泛型方法)
    - [5.1 结构体的泛型方法](#51-结构体的泛型方法)
    - [5.2 方法级别的类型参数](#52-方法级别的类型参数)
  - [6. 泛型约束 (Trait Bounds)](#6-泛型约束-trait-bounds)
    - [6.1 基本约束](#61-基本约束)
    - [6.2 多重约束](#62-多重约束)
    - [6.3 where 子句](#63-where-子句)
  - [7. 关联类型](#7-关联类型)
    - [7.1 关联类型 vs 泛型参数](#71-关联类型-vs-泛型参数)
    - [7.2 实际应用](#72-实际应用)
  - [8. 生命周期泛型](#8-生命周期泛型)
    - [8.1 生命周期参数](#81-生命周期参数)
    - [8.2 生命周期与泛型结合](#82-生命周期与泛型结合)
  - [9. 常量泛型](#9-常量泛型)
    - [9.1 基本用法](#91-基本用法)
    - [9.2 实际应用](#92-实际应用)
    - [9.3 常量泛型的高级用法](#93-常量泛型的高级用法)
    - [9.4 常量泛型的实际应用场景](#94-常量泛型的实际应用场景)
  - [10. 泛型的性能](#10-泛型的性能)
    - [10.1 单态化](#101-单态化)
    - [10.2 代码膨胀](#102-代码膨胀)
    - [10.3 性能优化](#103-性能优化)
    - [10.4 性能对比：泛型 vs trait对象](#104-性能对比泛型-vs-trait对象)
    - [10.5 编译时间优化](#105-编译时间优化)
    - [10.6 内存布局优化](#106-内存布局优化)
  - [11. 实战案例](#11-实战案例)
    - [案例 1: 通用容器](#案例-1-通用容器)
    - [案例 2: 构建器模式](#案例-2-构建器模式)
    - [案例 3: 状态机](#案例-3-状态机)
    - [案例 4: 类型安全的 API](#案例-4-类型安全的-api)
  - [12. 常见陷阱与最佳实践](#12-常见陷阱与最佳实践)
    - [12.1 常见陷阱](#121-常见陷阱)
    - [12.2 最佳实践](#122-最佳实践)
    - [12.3 泛型API设计原则](#123-泛型api设计原则)
  - [13. 总结](#13-总结)
    - [核心要点](#核心要点)
    - [下一步学习](#下一步学习)
  - [14. 参考资源](#14-参考资源)

---

## 🎯 学习目标

完成本指南后，您将能够：

- ✅ **理解** 泛型编程的核心概念
- ✅ **掌握** 泛型函数、结构体和枚举的定义
- ✅ **应用** 泛型约束和 where 子句
- ✅ **理解** 关联类型与泛型参数的区别
- ✅ **掌握** 生命周期泛型和常量泛型
- ✅ **理解** 泛型的性能特征
- ✅ **设计** 类型安全的泛型 API

---

## 📊 章节概览

| 章节 | 内容 | 难度 | 预计时间 |
|------|------|------|---------|
| 1. 泛型概述 | 泛型基本概念 | 🟢 简单 | 20分钟 |
| 2. 泛型函数 | 定义和使用泛型函数 | 🟢 简单 | 40分钟 |
| 3. 泛型结构体 | 泛型结构体定义 | 🟡 中等 | 40分钟 |
| 4. 泛型枚举 | 泛型枚举应用 | 🟡 中等 | 30分钟 |
| 5. 泛型方法 | 结构体和方法的泛型 | 🟡 中等 | 40分钟 |
| 6. 泛型约束 | Trait Bounds 和 where | 🟡 中等 | 60分钟 |
| 7. 关联类型 | 关联类型 vs 泛型 | 🔴 高级 | 40分钟 |
| 8. 生命周期泛型 | 生命周期参数 | 🔴 高级 | 40分钟 |
| 9. 常量泛型 | Const Generics | 🟡 中等 | 30分钟 |
| 10. 性能考虑 | 单态化和优化 | 🔴 高级 | 30分钟 |
| 11. 实战案例 | 综合应用 | 🟡 中等 | 60分钟 |
| 12. 最佳实践 | 陷阱与实践 | 🟡 中等 | 30分钟 |

**总计**: 约 6-8 小时

---

## 1. 泛型概述

### 1.1 什么是泛型

**泛型** (Generics) 是一种参数化类型的编程技术，允许在定义函数、结构体、枚举和方法时使用类型参数。

**核心思想**:

- 📝 编写一次，适用于多种类型
- 🔒 编译时类型安全
- ⚡ 零运行时开销

**示例对比**:

```rust
// ❌ 没有泛型：需要为每种类型编写函数
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// ✅ 使用泛型：一个函数适用于所有可比较类型
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("The largest number is {}", result);
    
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

### 1.2 泛型的优势

**1. 代码复用**:

```rust
// 同一个容器可以存储不同类型
let int_vec: Vec<i32> = vec![1, 2, 3];
let string_vec: Vec<String> = vec![String::from("a"), String::from("b")];
```

**2. 类型安全**:

```rust
let mut vec: Vec<i32> = Vec::new();
vec.push(1);
// vec.push("hello"); // 编译错误！类型不匹配
```

**3. 零成本抽象**:

```rust
// 泛型在编译时展开，没有运行时开销
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}
// 编译后等同于为每个具体类型生成专门的函数
```

### 1.3 泛型 vs 动态分发

| 特性 | 泛型 (静态分发) | trait 对象 (动态分发) |
|------|----------------|---------------------|
| **性能** | 无运行时开销 | 有虚函数表查找开销 |
| **代码大小** | 可能膨胀 | 不膨胀 |
| **编译时间** | 较长 | 较短 |
| **灵活性** | 编译时确定 | 运行时确定 |
| **内联** | 可以内联 | 难以内联 |

```rust
// 静态分发：泛型
fn process_static<T: std::fmt::Display>(item: T) {
    println!("{}", item);
}

// 动态分发：trait 对象
fn process_dynamic(item: &dyn std::fmt::Display) {
    println!("{}", item);
}

fn main() {
    process_static(42);      // 编译时确定类型
    process_dynamic(&42);    // 运行时通过 vtable 调用
}
```

---

## 2. 泛型函数

### 2.1 基本泛型函数

**定义泛型函数**:

```rust
// 基本语法
fn function_name<T>(parameter: T) -> T {
    parameter
}

// 实际示例
fn identity<T>(value: T) -> T {
    value
}

fn main() {
    let number = identity(42);
    let string = identity(String::from("hello"));
    
    println!("number: {}", number);
    println!("string: {}", string);
}
```

**带约束的泛型函数**:

```rust
// 需要 Display trait
fn print_value<T: std::fmt::Display>(value: T) {
    println!("Value: {}", value);
}

// 需要 PartialOrd 进行比较
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

fn main() {
    print_value(42);
    print_value("hello");
    
    println!("Max: {}", max(10, 20));
    println!("Max: {}", max(3.14, 2.71));
}
```

### 2.2 多个类型参数

```rust
// 两个类型参数
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// 三个类型参数
fn triple<T, U, V>(first: T, second: U, third: V) -> (T, U, V) {
    (first, second, third)
}

fn main() {
    let p1 = pair(42, "hello");
    println!("Pair: {:?}", p1);
    
    let p2 = pair(3.14, true);
    println!("Pair: {:?}", p2);
    
    let t = triple(1, "two", 3.0);
    println!("Triple: {:?}", t);
}
```

### 2.3 类型推导

```rust
fn print_type<T: std::fmt::Debug>(value: T) {
    println!("{:?}", value);
}

fn main() {
    // 类型推导
    print_type(42);           // T = i32
    print_type("hello");      // T = &str
    print_type(vec![1, 2, 3]); // T = Vec<i32>
    
    // 显式指定类型
    print_type::<i32>(42);
    print_type::<&str>("hello");
    
    // Turbofish 语法
    let v = vec![1, 2, 3];
    let sum = v.iter().sum::<i32>();
    println!("Sum: {}", sum);
}
```

---

## 3. 泛型结构体

### 3.1 定义泛型结构体

**基本定义**:

```rust
// 单个类型参数
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };
    
    println!("Integer point: ({}, {})", integer_point.x, integer_point.y);
    println!("Float point: ({}, {})", float_point.x, float_point.y);
}
```

### 3.2 泛型字段

```rust
#[derive(Debug)]
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }
    
    fn get(&self) -> &T {
        &self.value
    }
    
    fn set(&mut self, value: T) {
        self.value = value;
    }
}

fn main() {
    let mut int_container = Container::new(42);
    println!("Container: {:?}", int_container);
    
    int_container.set(100);
    println!("Updated: {:?}", int_container);
    println!("Value: {}", int_container.get());
}
```

### 3.3 多类型参数结构体

```rust
#[derive(Debug)]
struct Pair<T, U> {
    first: T,
    second: U,
}

impl<T, U> Pair<T, U> {
    fn new(first: T, second: U) -> Self {
        Pair { first, second }
    }
    
    fn first(&self) -> &T {
        &self.first
    }
    
    fn second(&self) -> &U {
        &self.second
    }
}

fn main() {
    let pair1 = Pair::new(42, "hello");
    println!("Pair: {:?}", pair1);
    println!("First: {}, Second: {}", pair1.first(), pair1.second());
    
    let pair2 = Pair::new(3.14, vec![1, 2, 3]);
    println!("Pair: {:?}", pair2);
}
```

---

## 4. 泛型枚举

### 4.1 标准库泛型枚举

**`Option<T>`**:

```rust
fn main() {
    // Option<T> 定义
    // enum Option<T> {
    //     Some(T),
    //     None,
    // }
    
    let some_number: Option<i32> = Some(5);
    let some_string: Option<String> = Some(String::from("hello"));
    let absent_number: Option<i32> = None;
    
    match some_number {
        Some(value) => println!("Value: {}", value),
        None => println!("No value"),
    }
}
```

**Result<T, E>**:

```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 4.2 自定义泛型枚举

```rust
#[derive(Debug)]
enum Either<L, R> {
    Left(L),
    Right(R),
}

impl<L, R> Either<L, R> {
    fn is_left(&self) -> bool {
        matches!(self, Either::Left(_))
    }
    
    fn is_right(&self) -> bool {
        matches!(self, Either::Right(_))
    }
}

fn main() {
    let left: Either<i32, String> = Either::Left(42);
    let right: Either<i32, String> = Either::Right(String::from("hello"));
    
    println!("Left: {:?}, is_left: {}", left, left.is_left());
    println!("Right: {:?}, is_right: {}", right, right.is_right());
}
```

**树结构**:

```rust
#[derive(Debug)]
enum Tree<T> {
    Leaf(T),
    Node {
        value: T,
        left: Box<Tree<T>>,
        right: Box<Tree<T>>,
    },
}

impl<T> Tree<T> {
    fn leaf(value: T) -> Self {
        Tree::Leaf(value)
    }
    
    fn node(value: T, left: Tree<T>, right: Tree<T>) -> Self {
        Tree::Node {
            value,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
}

fn main() {
    let tree = Tree::node(
        1,
        Tree::leaf(2),
        Tree::node(
            3,
            Tree::leaf(4),
            Tree::leaf(5),
        ),
    );
    
    println!("Tree: {:?}", tree);
}
```

---

## 5. 泛型方法

### 5.1 结构体的泛型方法

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
    
    fn x(&self) -> &T {
        &self.x
    }
    
    fn y(&self) -> &T {
        &self.y
    }
}

// 为特定类型实现方法
impl Point<f64> {
    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let int_point = Point::new(5, 10);
    println!("x: {}, y: {}", int_point.x(), int_point.y());
    
    let float_point = Point::new(3.0, 4.0);
    println!("Distance: {}", float_point.distance_from_origin());
}
```

### 5.2 方法级别的类型参数

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    // 方法自己的类型参数
    fn mixup<U>(self, other: Point<U>) -> Point<(T, U)> {
        Point {
            x: (self.x, other.x),
            y: (self.y, other.y),
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: "hello", y: "world" };
    
    let p3 = p1.mixup(p2);
    println!("Mixed: ({:?}, {:?})", p3.x, p3.y);
}
```

---

## 6. 泛型约束 (Trait Bounds)

### 6.1 基本约束

```rust
use std::fmt::Display;

// 单个约束
fn print_value<T: Display>(value: T) {
    println!("Value: {}", value);
}

// 多个约束（使用 +）
fn print_and_compare<T: Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} is greater", a);
    } else {
        println!("{} is greater or equal", b);
    }
}

fn main() {
    print_value(42);
    print_value("hello");
    
    print_and_compare(10, 20);
    print_and_compare("apple", "banana");
}
```

### 6.2 多重约束

```rust
use std::fmt::{Debug, Display};

// 方法 1: 使用 +
fn compare<T: Debug + Display + PartialOrd>(a: T, b: T) {
    println!("Comparing {:?} and {:?}", a, b);
    if a > b {
        println!("{} is greater", a);
    }
}

// 方法 2: 分别指定多个类型参数的约束
fn print_pair<T: Display, U: Debug>(first: T, second: U) {
    println!("First: {}, Second: {:?}", first, second);
}

fn main() {
    compare(10, 20);
    print_pair("hello", vec![1, 2, 3]);
}
```

### 6.3 where 子句

```rust
use std::fmt::Display;

// 复杂约束使用 where
fn complex_function<T, U>(t: T, u: U)
where
    T: Display + Clone,
    U: Clone + Debug,
{
    println!("t: {}", t);
    println!("u: {:?}", u);
}

// where 子句使代码更清晰
fn another_function<T, U, V>(t: T, u: U, v: V)
where
    T: Display,
    U: Debug,
    V: Clone,
{
    println!("t: {}, u: {:?}", t, u);
}

use std::fmt::Debug;

fn main() {
    complex_function("hello", vec![1, 2, 3]);
}
```

**返回类型约束**:

```rust
use std::fmt::Display;

fn return_displayable<T: Display>(value: T) -> impl Display {
    format!("Value: {}", value)
}

fn main() {
    let result = return_displayable(42);
    println!("{}", result);
}
```

---

## 7. 关联类型

### 7.1 关联类型 vs 泛型参数

**使用泛型参数**:

```rust
trait Container<T> {
    fn add(&mut self, item: T);
    fn get(&self) -> Option<&T>;
}

// 可以为同一类型实现多次
impl Container<i32> for Vec<i32> {
    fn add(&mut self, item: i32) {
        self.push(item);
    }
    
    fn get(&self) -> Option<&i32> {
        self.first()
    }
}

impl Container<String> for Vec<String> {
    fn add(&mut self, item: String) {
        self.push(item);
    }
    
    fn get(&self) -> Option<&String> {
        self.first()
    }
}
```

**使用关联类型**:

```rust
trait Container {
    type Item;  // 关联类型
    
    fn add(&mut self, item: Self::Item);
    fn get(&self) -> Option<&Self::Item>;
}

// 只能为每个类型实现一次
impl Container for Vec<i32> {
    type Item = i32;
    
    fn add(&mut self, item: i32) {
        self.push(item);
    }
    
    fn get(&self) -> Option<&i32> {
        self.first()
    }
}

fn main() {
    let mut vec = Vec::new();
    vec.add(42);
    println!("First: {:?}", vec.get());
}
```

### 7.2 实际应用

**迭代器示例**:

```rust
trait Iterator {
    type Item;  // 关联类型
    
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut counter = Counter::new();
    
    while let Some(value) = counter.next() {
        println!("Count: {}", value);
    }
}
```

---

## 8. 生命周期泛型

### 8.1 生命周期参数

```rust
// 生命周期参数
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

### 8.2 生命周期与泛型结合

```rust
use std::fmt::Display;

// 结构体的生命周期参数
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
    
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

// 生命周期 + 泛型 + trait bound
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let excerpt = ImportantExcerpt {
        part: first_sentence,
    };
    
    println!("Excerpt: {}", excerpt.part);
    
    let result = longest_with_an_announcement(
        "hello",
        "world",
        "Comparing strings",
    );
    println!("Longest: {}", result);
}
```

---

## 9. 常量泛型

### 9.1 基本用法

```rust
// 常量泛型参数
fn print_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}

// 结构体的常量泛型
struct ArrayPair<T, const N: usize> {
    left: [T; N],
    right: [T; N],
}

fn main() {
    let arr1 = [1, 2, 3];
    let arr2 = [1, 2, 3, 4, 5];
    
    print_array(arr1);
    print_array(arr2);
    
    let pair = ArrayPair {
        left: [1, 2, 3],
        right: [4, 5, 6],
    };
}
```

### 9.2 实际应用

```rust
// 固定大小的缓冲区
struct Buffer<T, const SIZE: usize> {
    data: [T; SIZE],
    len: usize,
}

impl<T: Default + Copy, const SIZE: usize> Buffer<T, SIZE> {
    fn new() -> Self {
        Buffer {
            data: [T::default(); SIZE],
            len: 0,
        }
    }
    
    fn push(&mut self, item: T) -> Result<(), &'static str> {
        if self.len < SIZE {
            self.data[self.len] = item;
            self.len += 1;
            Ok(())
        } else {
            Err("Buffer is full")
        }
    }
    
    fn len(&self) -> usize {
        self.len
    }
}

fn main() {
    let mut buffer: Buffer<i32, 5> = Buffer::new();
    
    buffer.push(1).unwrap();
    buffer.push(2).unwrap();
    buffer.push(3).unwrap();
    
    println!("Buffer length: {}", buffer.len());
}
```

### 9.3 常量泛型的高级用法

**矩阵运算**:

```rust
use std::ops::{Add, Mul};

// 固定大小矩阵
#[derive(Debug, Clone, Copy)]
struct Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

impl<T: Default + Copy, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS> {
    fn new() -> Self {
        Matrix {
            data: [[T::default(); COLS]; ROWS],
        }
    }
    
    fn from_fn<F>(mut f: F) -> Self
    where
        F: FnMut(usize, usize) -> T,
    {
        let mut data = [[T::default(); COLS]; ROWS];
        for i in 0..ROWS {
            for j in 0..COLS {
                data[i][j] = f(i, j);
            }
        }
        Matrix { data }
    }
}

// 矩阵加法（要求维度相同）
impl<T, const ROWS: usize, const COLS: usize> Add for Matrix<T, ROWS, COLS>
where
    T: Add<Output = T> + Copy,
{
    type Output = Self;
    
    fn add(self, rhs: Self) -> Self::Output {
        Matrix::from_fn(|i, j| self.data[i][j] + rhs.data[i][j])
    }
}

// 矩阵乘法（编译时检查维度匹配）
impl<T, const M: usize, const N: usize, const P: usize> Mul<Matrix<T, N, P>>
    for Matrix<T, M, N>
where
    T: Mul<Output = T> + Add<Output = T> + Default + Copy,
{
    type Output = Matrix<T, M, P>;
    
    fn mul(self, rhs: Matrix<T, N, P>) -> Self::Output {
        Matrix::from_fn(|i, j| {
            let mut sum = T::default();
            for k in 0..N {
                sum = sum + self.data[i][k] * rhs.data[k][j];
            }
            sum
        })
    }
}

fn main() {
    let m1: Matrix<i32, 2, 3> = Matrix::from_fn(|i, j| (i * 3 + j) as i32);
    let m2: Matrix<i32, 3, 2> = Matrix::from_fn(|i, j| (i * 2 + j) as i32);
    
    // 编译时检查：2x3 * 3x2 = 2x2
    let result = m1 * m2;
    println!("{:?}", result);
    
    // 编译错误：维度不匹配
    // let m3: Matrix<i32, 2, 2> = Matrix::new();
    // let invalid = m1 * m3;  // 编译错误！
}
```

### 9.4 常量泛型的实际应用场景

**类型安全的网络协议**:

```rust
use std::marker::PhantomData;

// 协议版本标记
struct V1;
struct V2;

// 固定大小的数据包
struct Packet<V, const SIZE: usize> {
    data: [u8; SIZE],
    _version: PhantomData<V>,
}

impl<const SIZE: usize> Packet<V1, SIZE> {
    fn new(data: [u8; SIZE]) -> Self {
        Packet {
            data,
            _version: PhantomData,
        }
    }
    
    // V1 特定的方法
    fn checksum_v1(&self) -> u8 {
        self.data.iter().fold(0u8, |acc, &x| acc.wrapping_add(x))
    }
}

impl<const SIZE: usize> Packet<V2, SIZE> {
    fn new(data: [u8; SIZE]) -> Self {
        Packet {
            data,
            _version: PhantomData,
        }
    }
    
    // V2 特定的方法（更强的校验）
    fn checksum_v2(&self) -> u16 {
        self.data.iter().fold(0u16, |acc, &x| acc.wrapping_add(x as u16))
    }
}

fn main() {
    let packet_v1: Packet<V1, 64> = Packet::new([0u8; 64]);
    println!("V1 Checksum: {}", packet_v1.checksum_v1());
    
    let packet_v2: Packet<V2, 128> = Packet::new([0u8; 128]);
    println!("V2 Checksum: {}", packet_v2.checksum_v2());
    
    // 类型安全：不能混用版本的方法
    // packet_v1.checksum_v2();  // 编译错误！
}
```

---

## 10. 泛型的性能

### 10.1 单态化

```rust
// 泛型函数
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    // 编译器为每个具体类型生成专门的函数
    let result1 = add(5, 10);      // 生成 add_i32
    let result2 = add(1.5, 2.5);   // 生成 add_f64
    
    println!("result1: {}, result2: {}", result1, result2);
}

// 编译后等价于:
// fn add_i32(a: i32, b: i32) -> i32 { a + b }
// fn add_f64(a: f64, b: f64) -> f64 { a + b }
```

### 10.2 代码膨胀

```rust
// 可能导致代码膨胀
fn process<T: Clone>(value: T) {
    let cloned = value.clone();
    // ... 大量代码 ...
}

fn main() {
    // 每种类型都会生成一份代码
    process(42);
    process(3.14);
    process(String::from("hello"));
    process(vec![1, 2, 3]);
}
```

### 10.3 性能优化

```rust
use std::mem;

// ✅ 方法 1: 使用 trait 对象减少代码膨胀
trait Processable {
    fn process(&self);
}

fn process_dynamic(value: &dyn Processable) {
    value.process();
}

// ✅ 方法 2: 提取非泛型部分
fn common_logic() {
    // 通用逻辑
}

fn generic_wrapper<T>(value: T) {
    common_logic();
    // T 特定逻辑
}

// ✅ 方法 3: 使用内联
#[inline(always)]
fn small_generic<T: Copy>(value: T) -> T {
    value
}

fn main() {
    println!("Size of function pointer: {}", mem::size_of::<fn()>());
}
```

### 10.4 性能对比：泛型 vs trait对象

**性能测试**:

```rust
use std::time::Instant;

trait Processor {
    fn process(&self, value: i32) -> i32;
}

struct Doubler;
impl Processor for Doubler {
    fn process(&self, value: i32) -> i32 {
        value * 2
    }
}

// 泛型版本（静态分发）
fn process_generic<P: Processor>(processor: &P, values: &[i32]) -> Vec<i32> {
    values.iter().map(|&v| processor.process(v)).collect()
}

// trait对象版本（动态分发）
fn process_dynamic(processor: &dyn Processor, values: &[i32]) -> Vec<i32> {
    values.iter().map(|&v| processor.process(v)).collect()
}

fn main() {
    let data: Vec<i32> = (0..1_000_000).collect();
    let processor = Doubler;
    
    // 泛型版本
    let start = Instant::now();
    let _ = process_generic(&processor, &data);
    println!("泛型版本: {:?}", start.elapsed());
    
    // trait对象版本
    let start = Instant::now();
    let _ = process_dynamic(&processor as &dyn Processor, &data);
    println!("trait对象版本: {:?}", start.elapsed());
    
    // 通常：泛型版本 ≈ trait对象版本的 80%-95%
}
```

### 10.5 编译时间优化

**减少单态化开销**:

```rust
// ❌ 不好：大量单态化
fn large_processing<T: Clone + PartialEq>(data: Vec<T>) {
    // 大量代码...
    let _cloned = data.clone();
    // 更多代码...
}

// ✅ 更好：使用类型擦除
fn large_processing_impl(data: Vec<Box<dyn std::any::Any>>) {
    // 通用逻辑
}

fn large_processing<T: Clone + PartialEq + 'static>(data: Vec<T>) {
    let erased: Vec<Box<dyn std::any::Any>> = 
        data.into_iter().map(|x| Box::new(x) as Box<dyn std::any::Any>).collect();
    large_processing_impl(erased);
}
```

### 10.6 内存布局优化

**零开销抽象验证**:

```rust
use std::mem;

// 泛型结构体
#[repr(C)]
struct Wrapper<T> {
    value: T,
    count: usize,
}

fn main() {
    // 验证零开销
    assert_eq!(
        mem::size_of::<Wrapper<i32>>(),
        mem::size_of::<i32>() + mem::size_of::<usize>()
    );
    
    assert_eq!(
        mem::size_of::<Wrapper<f64>>(),
        mem::size_of::<f64>() + mem::size_of::<usize>()
    );
    
    println!("泛型没有额外的运行时开销！");
}
```

---

## 11. 实战案例

### 案例 1: 通用容器

```rust
use std::fmt::Display;

#[derive(Debug)]
struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { items: Vec::new() }
    }
    
    fn push(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }
    
    fn peek(&self) -> Option<&T> {
        self.items.last()
    }
    
    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
    
    fn len(&self) -> usize {
        self.items.len()
    }
}

impl<T: Display> Stack<T> {
    fn display(&self) {
        print!("[");
        for (i, item) in self.items.iter().enumerate() {
            if i > 0 {
                print!(", ");
            }
            print!("{}", item);
        }
        println!("]");
    }
}

fn main() {
    let mut stack = Stack::new();
    
    stack.push(1);
    stack.push(2);
    stack.push(3);
    
    stack.display();
    
    while let Some(item) = stack.pop() {
        println!("Popped: {}", item);
    }
}
```

### 案例 2: 构建器模式

```rust
#[derive(Debug)]
struct Query<T> {
    data: Vec<T>,
}

struct QueryBuilder<T> {
    data: Vec<T>,
}

impl<T> QueryBuilder<T> {
    fn new() -> Self {
        QueryBuilder { data: Vec::new() }
    }
    
    fn add(mut self, item: T) -> Self {
        self.data.push(item);
        self
    }
    
    fn filter<F>(mut self, predicate: F) -> Self
    where
        F: Fn(&T) -> bool,
    {
        self.data.retain(|item| predicate(item));
        self
    }
    
    fn build(self) -> Query<T> {
        Query { data: self.data }
    }
}

fn main() {
    let query = QueryBuilder::new()
        .add(1)
        .add(2)
        .add(3)
        .add(4)
        .add(5)
        .filter(|&x| x > 2)
        .build();
    
    println!("Query: {:?}", query);
}
```

### 案例 3: 状态机

```rust
use std::marker::PhantomData;

// 状态标记
struct Locked;
struct Unlocked;

// 泛型状态机
struct Door<State> {
    _state: PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door is locked");
        Door {
            _state: PhantomData,
        }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Unlocking door");
        Door {
            _state: PhantomData,
        }
    }
}

impl Door<Unlocked> {
    fn open(self) {
        println!("Opening door");
    }
    
    fn lock(self) -> Door<Locked> {
        println!("Locking door");
        Door {
            _state: PhantomData,
        }
    }
}

fn main() {
    let door = Door::<Locked>::new();
    let door = door.unlock();
    door.open();
    
    // let door = Door::<Locked>::new();
    // door.open(); // 编译错误！锁着的门不能打开
}
```

### 案例 4: 类型安全的 API

```rust
use std::marker::PhantomData;

// 单位标记
struct Kilometers;
struct Miles;

// 泛型距离类型
struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<Unit> Distance<Unit> {
    fn new(value: f64) -> Self {
        Distance {
            value,
            _unit: PhantomData,
        }
    }
    
    fn value(&self) -> f64 {
        self.value
    }
}

impl Distance<Kilometers> {
    fn to_miles(self) -> Distance<Miles> {
        Distance::new(self.value * 0.621371)
    }
}

impl Distance<Miles> {
    fn to_kilometers(self) -> Distance<Kilometers> {
        Distance::new(self.value / 0.621371)
    }
}

fn main() {
    let km = Distance::<Kilometers>::new(100.0);
    println!("{}km", km.value());
    
    let miles = km.to_miles();
    println!("{}miles", miles.value());
    
    let km2 = miles.to_kilometers();
    println!("{}km", km2.value());
    
    // 类型安全：不能混用
    // let total = Distance::<Kilometers>::new(100.0) + Distance::<Miles>::new(50.0); // 编译错误！
}
```

---

## 12. 常见陷阱与最佳实践

### 12.1 常见陷阱

```rust
// ❌ 陷阱 1: 忘记 trait bound
// fn print<T>(value: T) {
//     println!("{}", value); // 编译错误！T 没有实现 Display
// }

// ✅ 正确做法
use std::fmt::Display;

fn print<T: Display>(value: T) {
    println!("{}", value);
}

// ❌ 陷阱 2: 过度泛型化
// struct Container<T, U, V, W> { // 太多类型参数
//     ...
// }

// ✅ 正确做法：简化设计
struct Container<T> {
    items: Vec<T>,
}

// ❌ 陷阱 3: 代码膨胀
// fn large_function<T: Clone>(value: T) {
//     // 大量代码...
//     // 每个类型都会生成一份
// }

// ✅ 正确做法：提取非泛型部分
fn common_logic() {
    // 通用逻辑
}

fn generic_wrapper<T: Clone>(value: T) {
    common_logic();
    // T 特定的少量代码
}

fn main() {
    print(42);
}
```

### 12.2 最佳实践

```rust
use std::fmt::{Debug, Display};

// ✅ 1. 使用有意义的类型参数名
struct Point<Coordinate> {
    x: Coordinate,
    y: Coordinate,
}

// ✅ 2. 使用 where 子句提高可读性
fn complex<T, U>(t: T, u: U)
where
    T: Debug + Display + Clone,
    U: Debug + Clone,
{
    println!("{:?}", t);
    println!("{:?}", u);
}

// ✅ 3. 为特定类型提供特化实现
impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
}

impl Point<f64> {
    fn distance(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// ✅ 4. 使用 impl Trait 简化返回类型
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}

// ✅ 5. 合理使用生命周期省略规则
fn first_word(s: &str) -> &str {
    // 编译器自动推导生命周期
    s.split_whitespace().next().unwrap_or("")
}

fn main() {
    let p = Point::new(3.0, 4.0);
    println!("Distance: {}", p.distance());
    
    let add_5 = make_adder(5);
    println!("5 + 10 = {}", add_5(10));
}
```

### 12.3 泛型API设计原则

**原则 1: 最小化类型参数**:

```rust
// ❌ 过度泛型化
struct Bad<K, V, S, H> {
    _k: std::marker::PhantomData<K>,
    _v: std::marker::PhantomData<V>,
    _s: std::marker::PhantomData<S>,
    _h: std::marker::PhantomData<H>,
}

// ✅ 合理设计
use std::collections::HashMap;

struct Good<K, V> {
    data: HashMap<K, V>,
}
```

**原则 2: 优先使用trait约束**:

```rust
// ✅ 灵活的API设计
fn process<I>(iter: I)
where
    I: IntoIterator<Item = i32>,
{
    for item in iter {
        println!("{}", item);
    }
}

fn main() {
    process(vec![1, 2, 3]);           // Vec
    process([1, 2, 3]);               // 数组
    process(std::iter::once(1));      // Iterator
}
```

**原则 3: 提供合理的默认实现**:

```rust
// ✅ 为常见情况提供默认
trait Container<T> {
    fn add(&mut self, item: T);
    fn remove(&mut self) -> Option<T>;
    
    // 提供默认实现
    fn is_empty(&self) -> bool {
        self.len() == 0
    }
    
    fn len(&self) -> usize;
}
```

---

## 13. 总结

### 核心要点

1. **泛型基础**
   - ✅ 泛型提供代码复用和类型安全
   - ✅ 零成本抽象，无运行时开销
   - ✅ 编译时通过单态化展开

2. **泛型应用**
   - ✅ 函数、结构体、枚举、方法都可以泛型
   - ✅ 支持多个类型参数
   - ✅ 类型推导减少显式标注

3. **泛型约束**
   - ✅ 使用 trait bounds 限制类型
   - ✅ where 子句提高可读性
   - ✅ 多重约束组合使用

4. **高级特性**
   - ✅ 关联类型 vs 泛型参数
   - ✅ 生命周期泛型
   - ✅ 常量泛型

5. **性能考虑**
   - ✅ 单态化带来零开销
   - ✅ 可能导致代码膨胀
   - ✅ 合理设计避免过度泛型化

### 下一步学习

学完本指南后，建议继续学习：

1. **[2.4 Trait系统指南](./04_Trait系统指南.md)** - 掌握 trait 设计
2. **[2.5 生命周期指南](./05_生命周期指南.md)** - 深入生命周期
3. **[3.1 类型转换参考](../tier_03_references/01_类型转换参考.md)** - 类型转换技术
4. **[4.1 高级类型特性](../tier_04_advanced/01_高级类型特性.md)** - 高级类型技巧

---

## 14. 参考资源

**官方文档**:

- [Rust Book - Chapter 10 (Generics)](https://doc.rust-lang.org/book/ch10-00-generics.html)
- [Rust Reference - Generics](https://doc.rust-lang.org/reference/items/generics.html)
- [Rust by Example - Generics](https://doc.rust-lang.org/rust-by-example/generics.html)

**相关文档**:

- [2.1 基础类型指南](./01_基础类型指南.md)
- [2.2 复合类型指南](./02_复合类型指南.md)
- [1.0 项目概览](../tier_01_foundations/01_项目概览.md)
- [1.1 主索引导航](../tier_01_foundations/02_主索引导航.md)

**深度分析**:

- [泛型原理](../analysis/rust_theory/generics_theory.md)
- [类型系统设计](../02_core/01_type_definition.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 2 - 指南层

---

**🎉 恭喜完成泛型编程指南学习！** 🦀
