# 2.3 Rust ç±»å‹ç³»ç»Ÿ - æ³›å‹ç¼–ç¨‹æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚
> **æ–‡æ¡£å®šä½**: ç³»ç»Ÿå­¦ä¹  Rust æ³›å‹ç¼–ç¨‹
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§å¼€å‘è€…
> **å‰ç½®çŸ¥è¯†**: [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md), [2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 6-8 å°æ—¶
> **æœ€åæ›´æ–°**: 2025-12-11

---

## ğŸ“‹ ç›®å½•

- [2.3 Rust ç±»å‹ç³»ç»Ÿ - æ³›å‹ç¼–ç¨‹æŒ‡å—](#23-rust-ç±»å‹ç³»ç»Ÿ---æ³›å‹ç¼–ç¨‹æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [ğŸ“Š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. æ³›å‹æ¦‚è¿°](#1-æ³›å‹æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯æ³›å‹](#11-ä»€ä¹ˆæ˜¯æ³›å‹)
    - [1.2 æ³›å‹çš„ä¼˜åŠ¿](#12-æ³›å‹çš„ä¼˜åŠ¿)
    - [1.3 æ³›å‹ vs åŠ¨æ€åˆ†å‘](#13-æ³›å‹-vs-åŠ¨æ€åˆ†å‘)
  - [2. æ³›å‹å‡½æ•°](#2-æ³›å‹å‡½æ•°)
    - [2.1 åŸºæœ¬æ³›å‹å‡½æ•°](#21-åŸºæœ¬æ³›å‹å‡½æ•°)
    - [2.2 å¤šä¸ªç±»å‹å‚æ•°](#22-å¤šä¸ªç±»å‹å‚æ•°)
    - [2.3 ç±»å‹æ¨å¯¼](#23-ç±»å‹æ¨å¯¼)
  - [3. æ³›å‹ç»“æ„ä½“](#3-æ³›å‹ç»“æ„ä½“)
    - [3.1 å®šä¹‰æ³›å‹ç»“æ„ä½“](#31-å®šä¹‰æ³›å‹ç»“æ„ä½“)
    - [3.2 æ³›å‹å­—æ®µ](#32-æ³›å‹å­—æ®µ)
    - [3.3 å¤šç±»å‹å‚æ•°ç»“æ„ä½“](#33-å¤šç±»å‹å‚æ•°ç»“æ„ä½“)
  - [4. æ³›å‹æšä¸¾](#4-æ³›å‹æšä¸¾)
    - [4.1 æ ‡å‡†åº“æ³›å‹æšä¸¾](#41-æ ‡å‡†åº“æ³›å‹æšä¸¾)
    - [4.2 è‡ªå®šä¹‰æ³›å‹æšä¸¾](#42-è‡ªå®šä¹‰æ³›å‹æšä¸¾)
  - [5. æ³›å‹æ–¹æ³•](#5-æ³›å‹æ–¹æ³•)
    - [5.1 ç»“æ„ä½“çš„æ³›å‹æ–¹æ³•](#51-ç»“æ„ä½“çš„æ³›å‹æ–¹æ³•)
    - [5.2 æ–¹æ³•çº§åˆ«çš„ç±»å‹å‚æ•°](#52-æ–¹æ³•çº§åˆ«çš„ç±»å‹å‚æ•°)
  - [6. æ³›å‹çº¦æŸ (Trait Bounds)](#6-æ³›å‹çº¦æŸ-trait-bounds)
    - [6.1 åŸºæœ¬çº¦æŸ](#61-åŸºæœ¬çº¦æŸ)
    - [6.2 å¤šé‡çº¦æŸ](#62-å¤šé‡çº¦æŸ)
    - [6.3 where å­å¥](#63-where-å­å¥)
  - [7. å…³è”ç±»å‹](#7-å…³è”ç±»å‹)
    - [7.1 å…³è”ç±»å‹ vs æ³›å‹å‚æ•°](#71-å…³è”ç±»å‹-vs-æ³›å‹å‚æ•°)
    - [7.2 å®é™…åº”ç”¨](#72-å®é™…åº”ç”¨)
  - [8. ç”Ÿå‘½å‘¨æœŸæ³›å‹](#8-ç”Ÿå‘½å‘¨æœŸæ³›å‹)
    - [8.1 ç”Ÿå‘½å‘¨æœŸå‚æ•°](#81-ç”Ÿå‘½å‘¨æœŸå‚æ•°)
    - [8.2 ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ç»“åˆ](#82-ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ç»“åˆ)
  - [9. å¸¸é‡æ³›å‹](#9-å¸¸é‡æ³›å‹)
    - [9.1 åŸºæœ¬ç”¨æ³•](#91-åŸºæœ¬ç”¨æ³•)
    - [9.2 å®é™…åº”ç”¨](#92-å®é™…åº”ç”¨)
    - [9.3 å¸¸é‡æ³›å‹çš„é«˜çº§ç”¨æ³•](#93-å¸¸é‡æ³›å‹çš„é«˜çº§ç”¨æ³•)
    - [9.4 å¸¸é‡æ³›å‹çš„å®é™…åº”ç”¨åœºæ™¯](#94-å¸¸é‡æ³›å‹çš„å®é™…åº”ç”¨åœºæ™¯)
  - [10. æ³›å‹çš„æ€§èƒ½](#10-æ³›å‹çš„æ€§èƒ½)
    - [10.1 å•æ€åŒ–](#101-å•æ€åŒ–)
    - [10.2 ä»£ç è†¨èƒ€](#102-ä»£ç è†¨èƒ€)
    - [10.3 æ€§èƒ½ä¼˜åŒ–](#103-æ€§èƒ½ä¼˜åŒ–)
    - [10.4 æ€§èƒ½å¯¹æ¯”ï¼šæ³›å‹ vs traitå¯¹è±¡](#104-æ€§èƒ½å¯¹æ¯”æ³›å‹-vs-traitå¯¹è±¡)
    - [10.5 ç¼–è¯‘æ—¶é—´ä¼˜åŒ–](#105-ç¼–è¯‘æ—¶é—´ä¼˜åŒ–)
    - [10.6 å†…å­˜å¸ƒå±€ä¼˜åŒ–](#106-å†…å­˜å¸ƒå±€ä¼˜åŒ–)
  - [11. å®æˆ˜æ¡ˆä¾‹](#11-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: é€šç”¨å®¹å™¨](#æ¡ˆä¾‹-1-é€šç”¨å®¹å™¨)
    - [æ¡ˆä¾‹ 2: æ„å»ºå™¨æ¨¡å¼](#æ¡ˆä¾‹-2-æ„å»ºå™¨æ¨¡å¼)
    - [æ¡ˆä¾‹ 3: çŠ¶æ€æœº](#æ¡ˆä¾‹-3-çŠ¶æ€æœº)
    - [æ¡ˆä¾‹ 4: ç±»å‹å®‰å…¨çš„ API](#æ¡ˆä¾‹-4-ç±»å‹å®‰å…¨çš„-api)
  - [12. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#12-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [12.1 å¸¸è§é™·é˜±](#121-å¸¸è§é™·é˜±)
    - [12.2 æœ€ä½³å®è·µ](#122-æœ€ä½³å®è·µ)
    - [12.3 æ³›å‹APIè®¾è®¡åŸåˆ™](#123-æ³›å‹apiè®¾è®¡åŸåˆ™)
  - [13. æ€»ç»“](#13-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )
  - [14. å‚è€ƒèµ„æº](#14-å‚è€ƒèµ„æº)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… **ç†è§£** æ³›å‹ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µ
- âœ… **æŒæ¡** æ³›å‹å‡½æ•°ã€ç»“æ„ä½“å’Œæšä¸¾çš„å®šä¹‰
- âœ… **åº”ç”¨** æ³›å‹çº¦æŸå’Œ where å­å¥
- âœ… **ç†è§£** å…³è”ç±»å‹ä¸æ³›å‹å‚æ•°çš„åŒºåˆ«
- âœ… **æŒæ¡** ç”Ÿå‘½å‘¨æœŸæ³›å‹å’Œå¸¸é‡æ³›å‹
- âœ… **ç†è§£** æ³›å‹çš„æ€§èƒ½ç‰¹å¾
- âœ… **è®¾è®¡** ç±»å‹å®‰å…¨çš„æ³›å‹ API

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ³›å‹ç¼–ç¨‹æŒ‡å— (Generic Programming Guide)**:

- **å®šä¹‰**: ç³»ç»Ÿå­¦ä¹  Rust æ³›å‹ç¼–ç¨‹çš„å®è·µæŒ‡å—ï¼ŒåŒ…æ‹¬æ³›å‹å‡½æ•°ã€ç»“æ„ä½“ã€çº¦æŸç­‰
- **ç±»å‹**: å®è·µæŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: æ³›å‹ç¼–ç¨‹ã€ç±»å‹ç³»ç»Ÿ
- **ç‰ˆæœ¬**: Rust 1.0+ (åŸºç¡€), Rust 1.51+ (å¸¸é‡æ³›å‹)
- **ç›¸å…³æ¦‚å¿µ**: æ³›å‹ã€ç±»å‹å‚æ•°ã€Trait çº¦æŸã€å•æ€åŒ–

**æ³›å‹ç¼–ç¨‹ (Generic Programming)**:

- **å®šä¹‰**: ç¼–å†™å¯é€‚ç”¨äºå¤šç§ç±»å‹çš„ä»£ç çš„ç¼–ç¨‹èŒƒå¼
- **ç±»å‹**: ç¼–ç¨‹èŒƒå¼
- **å±æ€§**: ç±»å‹å‚æ•°ã€Trait çº¦æŸã€å•æ€åŒ–
- **å…³ç³»**: ä¸ç±»å‹ç³»ç»Ÿã€Trait ç³»ç»Ÿç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æ³›å‹å‡½æ•°**: ç±»å‹å‚æ•°ã€ç±»å‹æ¨å¯¼
- **æ³›å‹ç»“æ„ä½“**: æ³›å‹å­—æ®µã€å¤šç±»å‹å‚æ•°
- **æ³›å‹çº¦æŸ**: Trait boundsã€where å­å¥
- **å…³è”ç±»å‹**: å…³è”ç±»å‹ vs æ³›å‹å‚æ•°

**æ€§èƒ½ç‰¹å¾**:

- **å•æ€åŒ–**: ç¼–è¯‘æ—¶ç”Ÿæˆå…·ä½“ç±»å‹ä»£ç 
- **é›¶æˆæœ¬æŠ½è±¡**: æ³›å‹é›¶è¿è¡Œæ—¶å¼€é”€
- **é€‚ç”¨åœºæ™¯**: ä»£ç å¤ç”¨ã€ç±»å‹å®‰å…¨ã€æ€§èƒ½ä¼˜åŒ–

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- æ³›å‹å‡½æ•° --[is-a]--> æ³›å‹ç¼–ç¨‹
- æ³›å‹ç»“æ„ä½“ --[is-a]--> æ³›å‹ç¼–ç¨‹

**ç»„åˆå…³ç³»**:

- æ³›å‹ç¼–ç¨‹æŒ‡å— --[covers]--> å¤šç§æ³›å‹æœºåˆ¶
- ç±»å‹å®‰å…¨ç¨‹åº --[uses]--> æ³›å‹ç¼–ç¨‹

**ä¾èµ–å…³ç³»**:

- æ³›å‹ç¼–ç¨‹ --[depends-on]--> ç±»å‹ç³»ç»Ÿ
- ä»£ç å¤ç”¨ --[depends-on]--> æ³›å‹ç¼–ç¨‹

### æ€ç»´å¯¼å›¾

```text
æ³›å‹ç¼–ç¨‹æŒ‡å—
â”‚
â”œâ”€â”€ æ³›å‹å‡½æ•°
â”‚   â””â”€â”€ ç±»å‹å‚æ•°
â”œâ”€â”€ æ³›å‹ç»“æ„ä½“
â”‚   â””â”€â”€ æ³›å‹å­—æ®µ
â”œâ”€â”€ æ³›å‹çº¦æŸ
â”‚   â”œâ”€â”€ Trait bounds
â”‚   â””â”€â”€ where å­å¥
â”œâ”€â”€ å…³è”ç±»å‹
â”‚   â””â”€â”€ vs æ³›å‹å‚æ•°
â””â”€â”€ æ€§èƒ½ç‰¹å¾
    â””â”€â”€ å•æ€åŒ–
```

---

## ğŸ“Š ç« èŠ‚æ¦‚è§ˆ

| ç« èŠ‚            | å†…å®¹                  | éš¾åº¦    | é¢„è®¡æ—¶é—´ |
| --------------- | --------------------- | ------- | -------- |
| 1. æ³›å‹æ¦‚è¿°     | æ³›å‹åŸºæœ¬æ¦‚å¿µ          | ğŸŸ¢ ç®€å• | 20åˆ†é’Ÿ   |
| 2. æ³›å‹å‡½æ•°     | å®šä¹‰å’Œä½¿ç”¨æ³›å‹å‡½æ•°    | ğŸŸ¢ ç®€å• | 40åˆ†é’Ÿ   |
| 3. æ³›å‹ç»“æ„ä½“   | æ³›å‹ç»“æ„ä½“å®šä¹‰        | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ   |
| 4. æ³›å‹æšä¸¾     | æ³›å‹æšä¸¾åº”ç”¨          | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ   |
| 5. æ³›å‹æ–¹æ³•     | ç»“æ„ä½“å’Œæ–¹æ³•çš„æ³›å‹    | ğŸŸ¡ ä¸­ç­‰ | 40åˆ†é’Ÿ   |
| 6. æ³›å‹çº¦æŸ     | Trait Bounds å’Œ where | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ   |
| 7. å…³è”ç±»å‹     | å…³è”ç±»å‹ vs æ³›å‹      | ğŸ”´ é«˜çº§ | 40åˆ†é’Ÿ   |
| 8. ç”Ÿå‘½å‘¨æœŸæ³›å‹ | ç”Ÿå‘½å‘¨æœŸå‚æ•°          | ğŸ”´ é«˜çº§ | 40åˆ†é’Ÿ   |
| 9. å¸¸é‡æ³›å‹     | Const Generics        | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ   |
| 10. æ€§èƒ½è€ƒè™‘    | å•æ€åŒ–å’Œä¼˜åŒ–          | ğŸ”´ é«˜çº§ | 30åˆ†é’Ÿ   |
| 11. å®æˆ˜æ¡ˆä¾‹    | ç»¼åˆåº”ç”¨              | ğŸŸ¡ ä¸­ç­‰ | 60åˆ†é’Ÿ   |
| 12. æœ€ä½³å®è·µ    | é™·é˜±ä¸å®è·µ            | ğŸŸ¡ ä¸­ç­‰ | 30åˆ†é’Ÿ   |

**æ€»è®¡**: çº¦ 6-8 å°æ—¶

---

## 1. æ³›å‹æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯æ³›å‹

**æ³›å‹** (Generics) æ˜¯ä¸€ç§å‚æ•°åŒ–ç±»å‹çš„ç¼–ç¨‹æŠ€æœ¯ï¼Œå…è®¸åœ¨å®šä¹‰å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾å’Œæ–¹æ³•æ—¶ä½¿ç”¨ç±»å‹å‚æ•°ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- ğŸ“ ç¼–å†™ä¸€æ¬¡ï¼Œé€‚ç”¨äºå¤šç§ç±»å‹
- ğŸ”’ ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
- âš¡ é›¶è¿è¡Œæ—¶å¼€é”€

**ç¤ºä¾‹å¯¹æ¯”**:

```rust
// âŒ æ²¡æœ‰æ³›å‹ï¼šéœ€è¦ä¸ºæ¯ç§ç±»å‹ç¼–å†™å‡½æ•°
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// âœ… ä½¿ç”¨æ³›å‹ï¼šä¸€ä¸ªå‡½æ•°é€‚ç”¨äºæ‰€æœ‰å¯æ¯”è¾ƒç±»å‹
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

### 1.2 æ³›å‹çš„ä¼˜åŠ¿

**1. ä»£ç å¤ç”¨**:

```rust
// åŒä¸€ä¸ªå®¹å™¨å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹
let int_vec: Vec<i32> = vec![1, 2, 3];
let string_vec: Vec<String> = vec![String::from("a"), String::from("b")];
```

**2. ç±»å‹å®‰å…¨**:

```rust
let mut vec: Vec<i32> = Vec::new();
vec.push(1);
// vec.push("hello"); // ç¼–è¯‘é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
```

**3. é›¶æˆæœ¬æŠ½è±¡**:

```rust
// æ³›å‹åœ¨ç¼–è¯‘æ—¶å±•å¼€ï¼Œæ²¡æœ‰è¿è¡Œæ—¶å¼€é”€
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}
// ç¼–è¯‘åç­‰åŒäºä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨çš„å‡½æ•°
```

### 1.3 æ³›å‹ vs åŠ¨æ€åˆ†å‘

| ç‰¹æ€§         | æ³›å‹ (é™æ€åˆ†å‘) | trait å¯¹è±¡ (åŠ¨æ€åˆ†å‘) |
| ------------ | --------------- | --------------------- |
| **æ€§èƒ½**     | æ— è¿è¡Œæ—¶å¼€é”€    | æœ‰è™šå‡½æ•°è¡¨æŸ¥æ‰¾å¼€é”€    |
| **ä»£ç å¤§å°** | å¯èƒ½è†¨èƒ€        | ä¸è†¨èƒ€                |
| **ç¼–è¯‘æ—¶é—´** | è¾ƒé•¿            | è¾ƒçŸ­                  |
| **çµæ´»æ€§**   | ç¼–è¯‘æ—¶ç¡®å®š      | è¿è¡Œæ—¶ç¡®å®š            |
| **å†…è”**     | å¯ä»¥å†…è”        | éš¾ä»¥å†…è”              |

```rust
// é™æ€åˆ†å‘ï¼šæ³›å‹
fn process_static<T: std::fmt::Display>(item: T) {
    println!("{}", item);
}

// åŠ¨æ€åˆ†å‘ï¼štrait å¯¹è±¡
fn process_dynamic(item: &dyn std::fmt::Display) {
    println!("{}", item);
}

fn main() {
    process_static(42);      // ç¼–è¯‘æ—¶ç¡®å®šç±»å‹
    process_dynamic(&42);    // è¿è¡Œæ—¶é€šè¿‡ vtable è°ƒç”¨
}
```

---

## 2. æ³›å‹å‡½æ•°

### 2.1 åŸºæœ¬æ³›å‹å‡½æ•°

**å®šä¹‰æ³›å‹å‡½æ•°**:

```rust
// åŸºæœ¬è¯­æ³•
fn function_name<T>(parameter: T) -> T {
    parameter
}

// å®é™…ç¤ºä¾‹
fn identity<T>(value: T) -> T {
    value
}

fn main() {
    let number = identity(42);
    let string = identity(String::from("hello"));

    println!("number: {}", number);
    println!("string: {}", string);
}
```

**å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°**:

```rust
// éœ€è¦ Display trait
fn print_value<T: std::fmt::Display>(value: T) {
    println!("Value: {}", value);
}

// éœ€è¦ PartialOrd è¿›è¡Œæ¯”è¾ƒ
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

fn main() {
    print_value(42);
    print_value("hello");

    println!("Max: {}", max(10, 20));
    println!("Max: {}", max(3.14, 2.71));
}
```

### 2.2 å¤šä¸ªç±»å‹å‚æ•°

```rust
// ä¸¤ä¸ªç±»å‹å‚æ•°
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// ä¸‰ä¸ªç±»å‹å‚æ•°
fn triple<T, U, V>(first: T, second: U, third: V) -> (T, U, V) {
    (first, second, third)
}

fn main() {
    let p1 = pair(42, "hello");
    println!("Pair: {:?}", p1);

    let p2 = pair(3.14, true);
    println!("Pair: {:?}", p2);

    let t = triple(1, "two", 3.0);
    println!("Triple: {:?}", t);
}
```

### 2.3 ç±»å‹æ¨å¯¼

```rust
fn print_type<T: std::fmt::Debug>(value: T) {
    println!("{:?}", value);
}

fn main() {
    // ç±»å‹æ¨å¯¼
    print_type(42);           // T = i32
    print_type("hello");      // T = &str
    print_type(vec![1, 2, 3]); // T = Vec<i32>

    // æ˜¾å¼æŒ‡å®šç±»å‹
    print_type::<i32>(42);
    print_type::<&str>("hello");

    // Turbofish è¯­æ³•
    let v = vec![1, 2, 3];
    let sum = v.iter().sum::<i32>();
    println!("Sum: {}", sum);
}
```

---

## 3. æ³›å‹ç»“æ„ä½“

### 3.1 å®šä¹‰æ³›å‹ç»“æ„ä½“

**åŸºæœ¬å®šä¹‰**:

```rust
// å•ä¸ªç±»å‹å‚æ•°
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };

    println!("Integer point: ({}, {})", integer_point.x, integer_point.y);
    println!("Float point: ({}, {})", float_point.x, float_point.y);
}
```

### 3.2 æ³›å‹å­—æ®µ

```rust
#[derive(Debug)]
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }

    fn get(&self) -> &T {
        &self.value
    }

    fn set(&mut self, value: T) {
        self.value = value;
    }
}

fn main() {
    let mut int_container = Container::new(42);
    println!("Container: {:?}", int_container);

    int_container.set(100);
    println!("Updated: {:?}", int_container);
    println!("Value: {}", int_container.get());
}
```

### 3.3 å¤šç±»å‹å‚æ•°ç»“æ„ä½“

```rust
#[derive(Debug)]
struct Pair<T, U> {
    first: T,
    second: U,
}

impl<T, U> Pair<T, U> {
    fn new(first: T, second: U) -> Self {
        Pair { first, second }
    }

    fn first(&self) -> &T {
        &self.first
    }

    fn second(&self) -> &U {
        &self.second
    }
}

fn main() {
    let pair1 = Pair::new(42, "hello");
    println!("Pair: {:?}", pair1);
    println!("First: {}, Second: {}", pair1.first(), pair1.second());

    let pair2 = Pair::new(3.14, vec![1, 2, 3]);
    println!("Pair: {:?}", pair2);
}
```

---

## 4. æ³›å‹æšä¸¾

### 4.1 æ ‡å‡†åº“æ³›å‹æšä¸¾

**`Option<T>`**:

```rust
fn main() {
    // Option<T> å®šä¹‰
    // enum Option<T> {
    //     Some(T),
    //     None,
    // }

    let some_number: Option<i32> = Some(5);
    let some_string: Option<String> = Some(String::from("hello"));
    let absent_number: Option<i32> = None;

    match some_number {
        Some(value) => println!("Value: {}", value),
        None => println!("No value"),
    }
}
```

**Result<T, E>**:

```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 4.2 è‡ªå®šä¹‰æ³›å‹æšä¸¾

```rust
#[derive(Debug)]
enum Either<L, R> {
    Left(L),
    Right(R),
}

impl<L, R> Either<L, R> {
    fn is_left(&self) -> bool {
        matches!(self, Either::Left(_))
    }

    fn is_right(&self) -> bool {
        matches!(self, Either::Right(_))
    }
}

fn main() {
    let left: Either<i32, String> = Either::Left(42);
    let right: Either<i32, String> = Either::Right(String::from("hello"));

    println!("Left: {:?}, is_left: {}", left, left.is_left());
    println!("Right: {:?}, is_right: {}", right, right.is_right());
}
```

**æ ‘ç»“æ„**:

```rust
#[derive(Debug)]
enum Tree<T> {
    Leaf(T),
    Node {
        value: T,
        left: Box<Tree<T>>,
        right: Box<Tree<T>>,
    },
}

impl<T> Tree<T> {
    fn leaf(value: T) -> Self {
        Tree::Leaf(value)
    }

    fn node(value: T, left: Tree<T>, right: Tree<T>) -> Self {
        Tree::Node {
            value,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
}

fn main() {
    let tree = Tree::node(
        1,
        Tree::leaf(2),
        Tree::node(
            3,
            Tree::leaf(4),
            Tree::leaf(5),
        ),
    );

    println!("Tree: {:?}", tree);
}
```

---

## 5. æ³›å‹æ–¹æ³•

### 5.1 ç»“æ„ä½“çš„æ³›å‹æ–¹æ³•

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }

    fn x(&self) -> &T {
        &self.x
    }

    fn y(&self) -> &T {
        &self.y
    }
}

// ä¸ºç‰¹å®šç±»å‹å®ç°æ–¹æ³•
impl Point<f64> {
    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let int_point = Point::new(5, 10);
    println!("x: {}, y: {}", int_point.x(), int_point.y());

    let float_point = Point::new(3.0, 4.0);
    println!("Distance: {}", float_point.distance_from_origin());
}
```

### 5.2 æ–¹æ³•çº§åˆ«çš„ç±»å‹å‚æ•°

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    // æ–¹æ³•è‡ªå·±çš„ç±»å‹å‚æ•°
    fn mixup<U>(self, other: Point<U>) -> Point<(T, U)> {
        Point {
            x: (self.x, other.x),
            y: (self.y, other.y),
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: "hello", y: "world" };

    let p3 = p1.mixup(p2);
    println!("Mixed: ({:?}, {:?})", p3.x, p3.y);
}
```

---

## 6. æ³›å‹çº¦æŸ (Trait Bounds)

### 6.1 åŸºæœ¬çº¦æŸ

```rust
use std::fmt::Display;

// å•ä¸ªçº¦æŸ
fn print_value<T: Display>(value: T) {
    println!("Value: {}", value);
}

// å¤šä¸ªçº¦æŸï¼ˆä½¿ç”¨ +ï¼‰
fn print_and_compare<T: Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} is greater", a);
    } else {
        println!("{} is greater or equal", b);
    }
}

fn main() {
    print_value(42);
    print_value("hello");

    print_and_compare(10, 20);
    print_and_compare("apple", "banana");
}
```

### 6.2 å¤šé‡çº¦æŸ

```rust
use std::fmt::{Debug, Display};

// æ–¹æ³• 1: ä½¿ç”¨ +
fn compare<T: Debug + Display + PartialOrd>(a: T, b: T) {
    println!("Comparing {:?} and {:?}", a, b);
    if a > b {
        println!("{} is greater", a);
    }
}

// æ–¹æ³• 2: åˆ†åˆ«æŒ‡å®šå¤šä¸ªç±»å‹å‚æ•°çš„çº¦æŸ
fn print_pair<T: Display, U: Debug>(first: T, second: U) {
    println!("First: {}, Second: {:?}", first, second);
}

fn main() {
    compare(10, 20);
    print_pair("hello", vec![1, 2, 3]);
}
```

### 6.3 where å­å¥

```rust
use std::fmt::Display;

// å¤æ‚çº¦æŸä½¿ç”¨ where
fn complex_function<T, U>(t: T, u: U)
where
    T: Display + Clone,
    U: Clone + Debug,
{
    println!("t: {}", t);
    println!("u: {:?}", u);
}

// where å­å¥ä½¿ä»£ç æ›´æ¸…æ™°
fn another_function<T, U, V>(t: T, u: U, v: V)
where
    T: Display,
    U: Debug,
    V: Clone,
{
    println!("t: {}, u: {:?}", t, u);
}

use std::fmt::Debug;

fn main() {
    complex_function("hello", vec![1, 2, 3]);
}
```

**è¿”å›ç±»å‹çº¦æŸ**:

```rust
use std::fmt::Display;

fn return_displayable<T: Display>(value: T) -> impl Display {
    format!("Value: {}", value)
}

fn main() {
    let result = return_displayable(42);
    println!("{}", result);
}
```

---

## 7. å…³è”ç±»å‹

### 7.1 å…³è”ç±»å‹ vs æ³›å‹å‚æ•°

**ä½¿ç”¨æ³›å‹å‚æ•°**:

```rust
trait Container<T> {
    fn add(&mut self, item: T);
    fn get(&self) -> Option<&T>;
}

// å¯ä»¥ä¸ºåŒä¸€ç±»å‹å®ç°å¤šæ¬¡
impl Container<i32> for Vec<i32> {
    fn add(&mut self, item: i32) {
        self.push(item);
    }

    fn get(&self) -> Option<&i32> {
        self.first()
    }
}

impl Container<String> for Vec<String> {
    fn add(&mut self, item: String) {
        self.push(item);
    }

    fn get(&self) -> Option<&String> {
        self.first()
    }
}
```

**ä½¿ç”¨å…³è”ç±»å‹**:

```rust
trait Container {
    type Item;  // å…³è”ç±»å‹

    fn add(&mut self, item: Self::Item);
    fn get(&self) -> Option<&Self::Item>;
}

// åªèƒ½ä¸ºæ¯ä¸ªç±»å‹å®ç°ä¸€æ¬¡
impl Container for Vec<i32> {
    type Item = i32;

    fn add(&mut self, item: i32) {
        self.push(item);
    }

    fn get(&self) -> Option<&i32> {
        self.first()
    }
}

fn main() {
    let mut vec = Vec::new();
    vec.add(42);
    println!("First: {:?}", vec.get());
}
```

### 7.2 å®é™…åº”ç”¨

**è¿­ä»£å™¨ç¤ºä¾‹**:

```rust
trait Iterator {
    type Item;  // å…³è”ç±»å‹

    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut counter = Counter::new();

    while let Some(value) = counter.next() {
        println!("Count: {}", value);
    }
}
```

---

## 8. ç”Ÿå‘½å‘¨æœŸæ³›å‹

ä»å¼•ç”¨ä¸€è‡´æ€§è§†è§’çœ‹ï¼Œç”Ÿå‘½å‘¨æœŸæ³›å‹æ˜¯**ç¼–è¯‘æœŸæ„é€ çš„è¯æ˜å˜é‡**ï¼Œç”¨äºè¯æ˜å¼•ç”¨åœ¨å…¶ä½¿ç”¨æœŸé—´å§‹ç»ˆæŒ‡å‘æœ‰æ•ˆçš„èµ„æºã€‚ç”Ÿå‘½å‘¨æœŸè¡¨ç¤ºçš„æ˜¯**é€»è¾‘å…³ç³»ï¼Œè€Œéç‰©ç†æ—¶é—´**ã€‚

### 8.1 ç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
// ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼ˆè¯æ˜å˜é‡ï¼‰
// ä»å¼•ç”¨ä¸€è‡´æ€§è§†è§’çœ‹ï¼Œ'a æ˜¯ç¼–è¯‘æœŸæ„é€ çš„è¯æ˜å˜é‡ï¼Œç”¨äºè¯æ˜å¼•ç”¨çš„æœ‰æ•ˆæ€§
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

### 8.2 ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ç»“åˆ

ä»å¼•ç”¨ä¸€è‡´æ€§è§†è§’çœ‹ï¼Œç”Ÿå‘½å‘¨æœŸä¸æ³›å‹çš„ç»“åˆæ˜¯**ç±»å‹å±‚é¢çš„é€»è¾‘å…³ç³»è¯æ˜**ï¼Œç”¨äºè¡¨è¾¾èµ„æºæ§åˆ¶æƒå’Œè®¿é—®èƒ½åŠ›çš„é€»è¾‘ä¾èµ–å…³ç³»ã€‚

```rust
use std::fmt::Display;

// ç»“æ„ä½“çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼ˆè¯æ˜å˜é‡ï¼‰
// ä»å¼•ç”¨ä¸€è‡´æ€§è§†è§’çœ‹ï¼Œ'a æ˜¯ç¼–è¯‘æœŸæ„é€ çš„è¯æ˜å˜é‡ï¼Œç”¨äºè¯æ˜å¼•ç”¨çš„æœ‰æ•ˆæ€§
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }

    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

// ç”Ÿå‘½å‘¨æœŸ + æ³›å‹ + trait bound
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let excerpt = ImportantExcerpt {
        part: first_sentence,
    };

    println!("Excerpt: {}", excerpt.part);

    let result = longest_with_an_announcement(
        "hello",
        "world",
        "Comparing strings",
    );
    println!("Longest: {}", result);
}
```

---

## 9. å¸¸é‡æ³›å‹

### 9.1 åŸºæœ¬ç”¨æ³•

```rust
// å¸¸é‡æ³›å‹å‚æ•°
fn print_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}

// ç»“æ„ä½“çš„å¸¸é‡æ³›å‹
struct ArrayPair<T, const N: usize> {
    left: [T; N],
    right: [T; N],
}

fn main() {
    let arr1 = [1, 2, 3];
    let arr2 = [1, 2, 3, 4, 5];

    print_array(arr1);
    print_array(arr2);

    let pair = ArrayPair {
        left: [1, 2, 3],
        right: [4, 5, 6],
    };
}
```

### 9.2 å®é™…åº”ç”¨

```rust
// å›ºå®šå¤§å°çš„ç¼“å†²åŒº
struct Buffer<T, const SIZE: usize> {
    data: [T; SIZE],
    len: usize,
}

impl<T: Default + Copy, const SIZE: usize> Buffer<T, SIZE> {
    fn new() -> Self {
        Buffer {
            data: [T::default(); SIZE],
            len: 0,
        }
    }

    fn push(&mut self, item: T) -> Result<(), &'static str> {
        if self.len < SIZE {
            self.data[self.len] = item;
            self.len += 1;
            Ok(())
        } else {
            Err("Buffer is full")
        }
    }

    fn len(&self) -> usize {
        self.len
    }
}

fn main() {
    let mut buffer: Buffer<i32, 5> = Buffer::new();

    buffer.push(1).unwrap();
    buffer.push(2).unwrap();
    buffer.push(3).unwrap();

    println!("Buffer length: {}", buffer.len());
}
```

### 9.3 å¸¸é‡æ³›å‹çš„é«˜çº§ç”¨æ³•

**çŸ©é˜µè¿ç®—**:

```rust
use std::ops::{Add, Mul};

// å›ºå®šå¤§å°çŸ©é˜µ
#[derive(Debug, Clone, Copy)]
struct Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

impl<T: Default + Copy, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS> {
    fn new() -> Self {
        Matrix {
            data: [[T::default(); COLS]; ROWS],
        }
    }

    fn from_fn<F>(mut f: F) -> Self
    where
        F: FnMut(usize, usize) -> T,
    {
        let mut data = [[T::default(); COLS]; ROWS];
        for i in 0..ROWS {
            for j in 0..COLS {
                data[i][j] = f(i, j);
            }
        }
        Matrix { data }
    }
}

// çŸ©é˜µåŠ æ³•ï¼ˆè¦æ±‚ç»´åº¦ç›¸åŒï¼‰
impl<T, const ROWS: usize, const COLS: usize> Add for Matrix<T, ROWS, COLS>
where
    T: Add<Output = T> + Copy,
{
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Matrix::from_fn(|i, j| self.data[i][j] + rhs.data[i][j])
    }
}

// çŸ©é˜µä¹˜æ³•ï¼ˆç¼–è¯‘æ—¶æ£€æŸ¥ç»´åº¦åŒ¹é…ï¼‰
impl<T, const M: usize, const N: usize, const P: usize> Mul<Matrix<T, N, P>>
    for Matrix<T, M, N>
where
    T: Mul<Output = T> + Add<Output = T> + Default + Copy,
{
    type Output = Matrix<T, M, P>;

    fn mul(self, rhs: Matrix<T, N, P>) -> Self::Output {
        Matrix::from_fn(|i, j| {
            let mut sum = T::default();
            for k in 0..N {
                sum = sum + self.data[i][k] * rhs.data[k][j];
            }
            sum
        })
    }
}

fn main() {
    let m1: Matrix<i32, 2, 3> = Matrix::from_fn(|i, j| (i * 3 + j) as i32);
    let m2: Matrix<i32, 3, 2> = Matrix::from_fn(|i, j| (i * 2 + j) as i32);

    // ç¼–è¯‘æ—¶æ£€æŸ¥ï¼š2x3 * 3x2 = 2x2
    let result = m1 * m2;
    println!("{:?}", result);

    // ç¼–è¯‘é”™è¯¯ï¼šç»´åº¦ä¸åŒ¹é…
    // let m3: Matrix<i32, 2, 2> = Matrix::new();
    // let invalid = m1 * m3;  // ç¼–è¯‘é”™è¯¯ï¼
}
```

### 9.4 å¸¸é‡æ³›å‹çš„å®é™…åº”ç”¨åœºæ™¯

**ç±»å‹å®‰å…¨çš„ç½‘ç»œåè®®**:

```rust
use std::marker::PhantomData;

// åè®®ç‰ˆæœ¬æ ‡è®°
struct V1;
struct V2;

// å›ºå®šå¤§å°çš„æ•°æ®åŒ…
struct Packet<V, const SIZE: usize> {
    data: [u8; SIZE],
    _version: PhantomData<V>,
}

impl<const SIZE: usize> Packet<V1, SIZE> {
    fn new(data: [u8; SIZE]) -> Self {
        Packet {
            data,
            _version: PhantomData,
        }
    }

    // V1 ç‰¹å®šçš„æ–¹æ³•
    fn checksum_v1(&self) -> u8 {
        self.data.iter().fold(0u8, |acc, &x| acc.wrapping_add(x))
    }
}

impl<const SIZE: usize> Packet<V2, SIZE> {
    fn new(data: [u8; SIZE]) -> Self {
        Packet {
            data,
            _version: PhantomData,
        }
    }

    // V2 ç‰¹å®šçš„æ–¹æ³•ï¼ˆæ›´å¼ºçš„æ ¡éªŒï¼‰
    fn checksum_v2(&self) -> u16 {
        self.data.iter().fold(0u16, |acc, &x| acc.wrapping_add(x as u16))
    }
}

fn main() {
    let packet_v1: Packet<V1, 64> = Packet::new([0u8; 64]);
    println!("V1 Checksum: {}", packet_v1.checksum_v1());

    let packet_v2: Packet<V2, 128> = Packet::new([0u8; 128]);
    println!("V2 Checksum: {}", packet_v2.checksum_v2());

    // ç±»å‹å®‰å…¨ï¼šä¸èƒ½æ··ç”¨ç‰ˆæœ¬çš„æ–¹æ³•
    // packet_v1.checksum_v2();  // ç¼–è¯‘é”™è¯¯ï¼
}
```

---

## 10. æ³›å‹çš„æ€§èƒ½

### 10.1 å•æ€åŒ–

```rust
// æ³›å‹å‡½æ•°
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    // ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨çš„å‡½æ•°
    let result1 = add(5, 10);      // ç”Ÿæˆ add_i32
    let result2 = add(1.5, 2.5);   // ç”Ÿæˆ add_f64

    println!("result1: {}, result2: {}", result1, result2);
}

// ç¼–è¯‘åç­‰ä»·äº:
// fn add_i32(a: i32, b: i32) -> i32 { a + b }
// fn add_f64(a: f64, b: f64) -> f64 { a + b }
```

### 10.2 ä»£ç è†¨èƒ€

```rust
// å¯èƒ½å¯¼è‡´ä»£ç è†¨èƒ€
fn process<T: Clone>(value: T) {
    let cloned = value.clone();
    // ... å¤§é‡ä»£ç  ...
}

fn main() {
    // æ¯ç§ç±»å‹éƒ½ä¼šç”Ÿæˆä¸€ä»½ä»£ç 
    process(42);
    process(3.14);
    process(String::from("hello"));
    process(vec![1, 2, 3]);
}
```

### 10.3 æ€§èƒ½ä¼˜åŒ–

```rust
use std::mem;

// âœ… æ–¹æ³• 1: ä½¿ç”¨ trait å¯¹è±¡å‡å°‘ä»£ç è†¨èƒ€
trait Processable {
    fn process(&self);
}

fn process_dynamic(value: &dyn Processable) {
    value.process();
}

// âœ… æ–¹æ³• 2: æå–éæ³›å‹éƒ¨åˆ†
fn common_logic() {
    // é€šç”¨é€»è¾‘
}

fn generic_wrapper<T>(value: T) {
    common_logic();
    // T ç‰¹å®šé€»è¾‘
}

// âœ… æ–¹æ³• 3: ä½¿ç”¨å†…è”
#[inline(always)]
fn small_generic<T: Copy>(value: T) -> T {
    value
}

fn main() {
    println!("Size of function pointer: {}", mem::size_of::<fn()>());
}
```

### 10.4 æ€§èƒ½å¯¹æ¯”ï¼šæ³›å‹ vs traitå¯¹è±¡

**æ€§èƒ½æµ‹è¯•**:

```rust
use std::time::Instant;

trait Processor {
    fn process(&self, value: i32) -> i32;
}

struct Doubler;
impl Processor for Doubler {
    fn process(&self, value: i32) -> i32 {
        value * 2
    }
}

// æ³›å‹ç‰ˆæœ¬ï¼ˆé™æ€åˆ†å‘ï¼‰
fn process_generic<P: Processor>(processor: &P, values: &[i32]) -> Vec<i32> {
    values.iter().map(|&v| processor.process(v)).collect()
}

// traitå¯¹è±¡ç‰ˆæœ¬ï¼ˆåŠ¨æ€åˆ†å‘ï¼‰
fn process_dynamic(processor: &dyn Processor, values: &[i32]) -> Vec<i32> {
    values.iter().map(|&v| processor.process(v)).collect()
}

fn main() {
    let data: Vec<i32> = (0..1_000_000).collect();
    let processor = Doubler;

    // æ³›å‹ç‰ˆæœ¬
    let start = Instant::now();
    let _ = process_generic(&processor, &data);
    println!("æ³›å‹ç‰ˆæœ¬: {:?}", start.elapsed());

    // traitå¯¹è±¡ç‰ˆæœ¬
    let start = Instant::now();
    let _ = process_dynamic(&processor as &dyn Processor, &data);
    println!("traitå¯¹è±¡ç‰ˆæœ¬: {:?}", start.elapsed());

    // é€šå¸¸ï¼šæ³›å‹ç‰ˆæœ¬ â‰ˆ traitå¯¹è±¡ç‰ˆæœ¬çš„ 80%-95%
}
```

### 10.5 ç¼–è¯‘æ—¶é—´ä¼˜åŒ–

**å‡å°‘å•æ€åŒ–å¼€é”€**:

```rust
// âŒ ä¸å¥½ï¼šå¤§é‡å•æ€åŒ–
fn large_processing<T: Clone + PartialEq>(data: Vec<T>) {
    // å¤§é‡ä»£ç ...
    let _cloned = data.clone();
    // æ›´å¤šä»£ç ...
}

// âœ… æ›´å¥½ï¼šä½¿ç”¨ç±»å‹æ“¦é™¤
fn large_processing_impl(data: Vec<Box<dyn std::any::Any>>) {
    // é€šç”¨é€»è¾‘
}

fn large_processing<T: Clone + PartialEq + 'static>(data: Vec<T>) {
    let erased: Vec<Box<dyn std::any::Any>> =
        data.into_iter().map(|x| Box::new(x) as Box<dyn std::any::Any>).collect();
    large_processing_impl(erased);
}
```

### 10.6 å†…å­˜å¸ƒå±€ä¼˜åŒ–

**é›¶å¼€é”€æŠ½è±¡éªŒè¯**:

```rust
use std::mem;

// æ³›å‹ç»“æ„ä½“
#[repr(C)]
struct Wrapper<T> {
    value: T,
    count: usize,
}

fn main() {
    // éªŒè¯é›¶å¼€é”€
    assert_eq!(
        mem::size_of::<Wrapper<i32>>(),
        mem::size_of::<i32>() + mem::size_of::<usize>()
    );

    assert_eq!(
        mem::size_of::<Wrapper<f64>>(),
        mem::size_of::<f64>() + mem::size_of::<usize>()
    );

    println!("æ³›å‹æ²¡æœ‰é¢å¤–çš„è¿è¡Œæ—¶å¼€é”€ï¼");
}
```

---

## 11. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: é€šç”¨å®¹å™¨

```rust
use std::fmt::Display;

#[derive(Debug)]
struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { items: Vec::new() }
    }

    fn push(&mut self, item: T) {
        self.items.push(item);
    }

    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }

    fn peek(&self) -> Option<&T> {
        self.items.last()
    }

    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }

    fn len(&self) -> usize {
        self.items.len()
    }
}

impl<T: Display> Stack<T> {
    fn display(&self) {
        print!("[");
        for (i, item) in self.items.iter().enumerate() {
            if i > 0 {
                print!(", ");
            }
            print!("{}", item);
        }
        println!("]");
    }
}

fn main() {
    let mut stack = Stack::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    stack.display();

    while let Some(item) = stack.pop() {
        println!("Popped: {}", item);
    }
}
```

### æ¡ˆä¾‹ 2: æ„å»ºå™¨æ¨¡å¼

```rust
#[derive(Debug)]
struct Query<T> {
    data: Vec<T>,
}

struct QueryBuilder<T> {
    data: Vec<T>,
}

impl<T> QueryBuilder<T> {
    fn new() -> Self {
        QueryBuilder { data: Vec::new() }
    }

    fn add(mut self, item: T) -> Self {
        self.data.push(item);
        self
    }

    fn filter<F>(mut self, predicate: F) -> Self
    where
        F: Fn(&T) -> bool,
    {
        self.data.retain(|item| predicate(item));
        self
    }

    fn build(self) -> Query<T> {
        Query { data: self.data }
    }
}

fn main() {
    let query = QueryBuilder::new()
        .add(1)
        .add(2)
        .add(3)
        .add(4)
        .add(5)
        .filter(|&x| x > 2)
        .build();

    println!("Query: {:?}", query);
}
```

### æ¡ˆä¾‹ 3: çŠ¶æ€æœº

```rust
use std::marker::PhantomData;

// çŠ¶æ€æ ‡è®°
struct Locked;
struct Unlocked;

// æ³›å‹çŠ¶æ€æœº
struct Door<State> {
    _state: PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door is locked");
        Door {
            _state: PhantomData,
        }
    }

    fn unlock(self) -> Door<Unlocked> {
        println!("Unlocking door");
        Door {
            _state: PhantomData,
        }
    }
}

impl Door<Unlocked> {
    fn open(self) {
        println!("Opening door");
    }

    fn lock(self) -> Door<Locked> {
        println!("Locking door");
        Door {
            _state: PhantomData,
        }
    }
}

fn main() {
    let door = Door::<Locked>::new();
    let door = door.unlock();
    door.open();

    // let door = Door::<Locked>::new();
    // door.open(); // ç¼–è¯‘é”™è¯¯ï¼é”ç€çš„é—¨ä¸èƒ½æ‰“å¼€
}
```

### æ¡ˆä¾‹ 4: ç±»å‹å®‰å…¨çš„ API

```rust
use std::marker::PhantomData;

// å•ä½æ ‡è®°
struct Kilometers;
struct Miles;

// æ³›å‹è·ç¦»ç±»å‹
struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<Unit> Distance<Unit> {
    fn new(value: f64) -> Self {
        Distance {
            value,
            _unit: PhantomData,
        }
    }

    fn value(&self) -> f64 {
        self.value
    }
}

impl Distance<Kilometers> {
    fn to_miles(self) -> Distance<Miles> {
        Distance::new(self.value * 0.621371)
    }
}

impl Distance<Miles> {
    fn to_kilometers(self) -> Distance<Kilometers> {
        Distance::new(self.value / 0.621371)
    }
}

fn main() {
    let km = Distance::<Kilometers>::new(100.0);
    println!("{}km", km.value());

    let miles = km.to_miles();
    println!("{}miles", miles.value());

    let km2 = miles.to_kilometers();
    println!("{}km", km2.value());

    // ç±»å‹å®‰å…¨ï¼šä¸èƒ½æ··ç”¨
    // let total = Distance::<Kilometers>::new(100.0) + Distance::<Miles>::new(50.0); // ç¼–è¯‘é”™è¯¯ï¼
}
```

---

## 12. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 12.1 å¸¸è§é™·é˜±

```rust
// âŒ é™·é˜± 1: å¿˜è®° trait bound
// fn print<T>(value: T) {
//     println!("{}", value); // ç¼–è¯‘é”™è¯¯ï¼T æ²¡æœ‰å®ç° Display
// }

// âœ… æ­£ç¡®åšæ³•
use std::fmt::Display;

fn print<T: Display>(value: T) {
    println!("{}", value);
}

// âŒ é™·é˜± 2: è¿‡åº¦æ³›å‹åŒ–
// struct Container<T, U, V, W> { // å¤ªå¤šç±»å‹å‚æ•°
//     ...
// }

// âœ… æ­£ç¡®åšæ³•ï¼šç®€åŒ–è®¾è®¡
struct Container<T> {
    items: Vec<T>,
}

// âŒ é™·é˜± 3: ä»£ç è†¨èƒ€
// fn large_function<T: Clone>(value: T) {
//     // å¤§é‡ä»£ç ...
//     // æ¯ä¸ªç±»å‹éƒ½ä¼šç”Ÿæˆä¸€ä»½
// }

// âœ… æ­£ç¡®åšæ³•ï¼šæå–éæ³›å‹éƒ¨åˆ†
fn common_logic() {
    // é€šç”¨é€»è¾‘
}

fn generic_wrapper<T: Clone>(value: T) {
    common_logic();
    // T ç‰¹å®šçš„å°‘é‡ä»£ç 
}

fn main() {
    print(42);
}
```

### 12.2 æœ€ä½³å®è·µ

```rust
use std::fmt::{Debug, Display};

// âœ… 1. ä½¿ç”¨æœ‰æ„ä¹‰çš„ç±»å‹å‚æ•°å
struct Point<Coordinate> {
    x: Coordinate,
    y: Coordinate,
}

// âœ… 2. ä½¿ç”¨ where å­å¥æé«˜å¯è¯»æ€§
fn complex<T, U>(t: T, u: U)
where
    T: Debug + Display + Clone,
    U: Debug + Clone,
{
    println!("{:?}", t);
    println!("{:?}", u);
}

// âœ… 3. ä¸ºç‰¹å®šç±»å‹æä¾›ç‰¹åŒ–å®ç°
impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
}

impl Point<f64> {
    fn distance(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// âœ… 4. ä½¿ç”¨ impl Trait ç®€åŒ–è¿”å›ç±»å‹
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}

// âœ… 5. åˆç†ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
fn first_word(s: &str) -> &str {
    // ç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼ç”Ÿå‘½å‘¨æœŸ
    s.split_whitespace().next().unwrap_or("")
}

fn main() {
    let p = Point::new(3.0, 4.0);
    println!("Distance: {}", p.distance());

    let add_5 = make_adder(5);
    println!("5 + 10 = {}", add_5(10));
}
```

### 12.3 æ³›å‹APIè®¾è®¡åŸåˆ™

**åŸåˆ™ 1: æœ€å°åŒ–ç±»å‹å‚æ•°**:

```rust
// âŒ è¿‡åº¦æ³›å‹åŒ–
struct Bad<K, V, S, H> {
    _k: std::marker::PhantomData<K>,
    _v: std::marker::PhantomData<V>,
    _s: std::marker::PhantomData<S>,
    _h: std::marker::PhantomData<H>,
}

// âœ… åˆç†è®¾è®¡
use std::collections::HashMap;

struct Good<K, V> {
    data: HashMap<K, V>,
}
```

**åŸåˆ™ 2: ä¼˜å…ˆä½¿ç”¨traitçº¦æŸ**:

```rust
// âœ… çµæ´»çš„APIè®¾è®¡
fn process<I>(iter: I)
where
    I: IntoIterator<Item = i32>,
{
    for item in iter {
        println!("{}", item);
    }
}

fn main() {
    process(vec![1, 2, 3]);           // Vec
    process([1, 2, 3]);               // æ•°ç»„
    process(std::iter::once(1));      // Iterator
}
```

**åŸåˆ™ 3: æä¾›åˆç†çš„é»˜è®¤å®ç°**:

```rust
// âœ… ä¸ºå¸¸è§æƒ…å†µæä¾›é»˜è®¤
trait Container<T> {
    fn add(&mut self, item: T);
    fn remove(&mut self) -> Option<T>;

    // æä¾›é»˜è®¤å®ç°
    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn len(&self) -> usize;
}
```

---

## 13. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æ³›å‹åŸºç¡€**
   - âœ… æ³›å‹æä¾›ä»£ç å¤ç”¨å’Œç±»å‹å®‰å…¨
   - âœ… é›¶æˆæœ¬æŠ½è±¡ï¼Œæ— è¿è¡Œæ—¶å¼€é”€
   - âœ… ç¼–è¯‘æ—¶é€šè¿‡å•æ€åŒ–å±•å¼€

2. **æ³›å‹åº”ç”¨**
   - âœ… å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾ã€æ–¹æ³•éƒ½å¯ä»¥æ³›å‹
   - âœ… æ”¯æŒå¤šä¸ªç±»å‹å‚æ•°
   - âœ… ç±»å‹æ¨å¯¼å‡å°‘æ˜¾å¼æ ‡æ³¨

3. **æ³›å‹çº¦æŸ**
   - âœ… ä½¿ç”¨ trait bounds é™åˆ¶ç±»å‹
   - âœ… where å­å¥æé«˜å¯è¯»æ€§
   - âœ… å¤šé‡çº¦æŸç»„åˆä½¿ç”¨

4. **é«˜çº§ç‰¹æ€§**
   - âœ… å…³è”ç±»å‹ vs æ³›å‹å‚æ•°
   - âœ… ç”Ÿå‘½å‘¨æœŸæ³›å‹
   - âœ… å¸¸é‡æ³›å‹

5. **æ€§èƒ½è€ƒè™‘**
   - âœ… å•æ€åŒ–å¸¦æ¥é›¶å¼€é”€
   - âœ… å¯èƒ½å¯¼è‡´ä»£ç è†¨èƒ€
   - âœ… åˆç†è®¾è®¡é¿å…è¿‡åº¦æ³›å‹åŒ–

### ä¸‹ä¸€æ­¥å­¦ä¹ 

å­¦å®Œæœ¬æŒ‡å—åï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **[2.4 Traitç³»ç»ŸæŒ‡å—](./04_Traitç³»ç»ŸæŒ‡å—.md)** - æŒæ¡ trait è®¾è®¡
2. **[2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](./05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)** - æ·±å…¥ç”Ÿå‘½å‘¨æœŸ
3. **[3.1 ç±»å‹è½¬æ¢å‚è€ƒ](../tier_03_references/01_ç±»å‹è½¬æ¢å‚è€ƒ.md)** - ç±»å‹è½¬æ¢æŠ€æœ¯
4. **[4.1 é«˜çº§ç±»å‹ç‰¹æ€§](../tier_04_advanced/01_é«˜çº§ç±»å‹ç‰¹æ€§.md)** - é«˜çº§ç±»å‹æŠ€å·§

---

## 14. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Chapter 10 (Generics)](https://doc.rust-lang.org/book/ch10-00-generics.html)
- [Rust Reference - Generics](https://doc.rust-lang.org/reference/items/generics.html)
- [Rust by Example - Generics](https://doc.rust-lang.org/rust-by-example/generics.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.1 åŸºç¡€ç±»å‹æŒ‡å—](./01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [2.2 å¤åˆç±»å‹æŒ‡å—](./02_å¤åˆç±»å‹æŒ‡å—.md)
- [1.0 é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æ·±åº¦åˆ†æ**:

- [æ³›å‹åŸç†](../tier_04_advanced/02_é«˜çº§æ³›å‹æ¨¡å¼.md)
- [ç±»å‹ç³»ç»Ÿè®¾è®¡](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md)

---

**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
**æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚

---

**ğŸ‰ æ­å–œå®Œæˆæ³›å‹ç¼–ç¨‹æŒ‡å—å­¦ä¹ ï¼** ğŸ¦€
