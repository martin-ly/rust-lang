# Rust ç±»å‹æ¨æ–­ç³»ç»Ÿå®Œæ•´æŒ‡å—

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-27  
**Rustç‰ˆæœ¬**: 1.90+  
**éš¾åº¦ç­‰çº§**: é«˜çº§  

## ğŸ“‹ ç›®å½•

- [Rust ç±»å‹æ¨æ–­ç³»ç»Ÿå®Œæ•´æŒ‡å—](#rust-ç±»å‹æ¨æ–­ç³»ç»Ÿå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç±»å‹æ¨æ–­åŸºç¡€](#1-ç±»å‹æ¨æ–­åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­](#11-ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­)
    - [1.2 ç±»å‹æ¨æ–­çš„ä¼˜åŠ¿](#12-ç±»å‹æ¨æ–­çš„ä¼˜åŠ¿)
    - [1.3 åŸºæœ¬å·¥ä½œåŸç†](#13-åŸºæœ¬å·¥ä½œåŸç†)
  - [2. Hindley-Milner ç³»ç»Ÿ](#2-hindley-milner-ç³»ç»Ÿ)
    - [2.1 ç†è®ºåŸºç¡€](#21-ç†è®ºåŸºç¡€)
    - [2.2 ç±»å‹å˜é‡](#22-ç±»å‹å˜é‡)
    - [2.3 çº¦æŸç”Ÿæˆ](#23-çº¦æŸç”Ÿæˆ)
    - [2.4 çº¦æŸæ±‚è§£](#24-çº¦æŸæ±‚è§£)
  - [3. Rust ç±»å‹æ¨æ–­ç®—æ³•](#3-rust-ç±»å‹æ¨æ–­ç®—æ³•)
    - [3.1 ç®—æ³•æ¦‚è¿°](#31-ç®—æ³•æ¦‚è¿°)
    - [3.2 ç±»å‹å˜é‡åˆ†é…](#32-ç±»å‹å˜é‡åˆ†é…)
    - [3.3 çº¦æŸæ”¶é›†](#33-çº¦æŸæ”¶é›†)
    - [3.4 ç»Ÿä¸€ç®—æ³•](#34-ç»Ÿä¸€ç®—æ³•)
  - [4. æ¨æ–­è§„åˆ™](#4-æ¨æ–­è§„åˆ™)
    - [4.1 åŸºæœ¬æ¨æ–­è§„åˆ™](#41-åŸºæœ¬æ¨æ–­è§„åˆ™)
    - [4.2 å‡½æ•°æ¨æ–­è§„åˆ™](#42-å‡½æ•°æ¨æ–­è§„åˆ™)
    - [4.3 æ³›å‹æ¨æ–­è§„åˆ™](#43-æ³›å‹æ¨æ–­è§„åˆ™)
    - [4.4 ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™](#44-ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™)
  - [5. é«˜çº§æ¨æ–­ç‰¹æ€§](#5-é«˜çº§æ¨æ–­ç‰¹æ€§)
    - [5.1 å¤šæ€æ¨æ–­](#51-å¤šæ€æ¨æ–­)
    - [5.2 å­ç±»å‹æ¨æ–­](#52-å­ç±»å‹æ¨æ–­)
    - [5.3 é«˜é˜¶ç±»å‹æ¨æ–­](#53-é«˜é˜¶ç±»å‹æ¨æ–­)
    - [5.4 ä¾èµ–ç±»å‹æ¨æ–­](#54-ä¾èµ–ç±»å‹æ¨æ–­)
  - [6. æ¨æ–­é™åˆ¶](#6-æ¨æ–­é™åˆ¶)
    - [6.1 æ¨æ–­å¤±è´¥åœºæ™¯](#61-æ¨æ–­å¤±è´¥åœºæ™¯)
    - [6.2 æ­§ä¹‰æ€§å¤„ç†](#62-æ­§ä¹‰æ€§å¤„ç†)
    - [6.3 ç±»å‹æ³¨è§£éœ€æ±‚](#63-ç±»å‹æ³¨è§£éœ€æ±‚)
  - [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
    - [7.1 æ¨æ–­ç®—æ³•ä¼˜åŒ–](#71-æ¨æ–­ç®—æ³•ä¼˜åŒ–)
    - [7.2 ç¼“å­˜æœºåˆ¶](#72-ç¼“å­˜æœºåˆ¶)
    - [7.3 å¢é‡æ¨æ–­](#73-å¢é‡æ¨æ–­)
  - [8. è°ƒè¯•å’Œè¯Šæ–­](#8-è°ƒè¯•å’Œè¯Šæ–­)
    - [8.1 æ¨æ–­è¿‡ç¨‹å¯è§†åŒ–](#81-æ¨æ–­è¿‡ç¨‹å¯è§†åŒ–)
    - [8.2 é”™è¯¯è¯Šæ–­](#82-é”™è¯¯è¯Šæ–­)
    - [8.3 è°ƒè¯•å·¥å…·](#83-è°ƒè¯•å·¥å…·)
  - [9. å®é™…åº”ç”¨](#9-å®é™…åº”ç”¨)
    - [9.1 ç¼–è¯‘å™¨å®ç°](#91-ç¼–è¯‘å™¨å®ç°)
    - [9.2 IDE æ”¯æŒ](#92-ide-æ”¯æŒ)
    - [9.3 é™æ€åˆ†æ](#93-é™æ€åˆ†æ)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 ç¼–å†™æ¨æ–­å‹å¥½çš„ä»£ç ](#101-ç¼–å†™æ¨æ–­å‹å¥½çš„ä»£ç )
    - [10.2 æ€§èƒ½è€ƒè™‘](#102-æ€§èƒ½è€ƒè™‘)
    - [10.3 è°ƒè¯•æŠ€å·§](#103-è°ƒè¯•æŠ€å·§)
  - [11. æ€»ç»“](#11-æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
    - [è¿›ä¸€æ­¥å­¦ä¹ ](#è¿›ä¸€æ­¥å­¦ä¹ )

## 1. ç±»å‹æ¨æ–­åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­

ç±»å‹æ¨æ–­ï¼ˆType Inferenceï¼‰æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨ç¡®å®šè¡¨è¾¾å¼ç±»å‹çš„è¿‡ç¨‹ï¼Œæ— éœ€ç¨‹åºå‘˜æ˜¾å¼æŒ‡å®šç±»å‹æ³¨è§£ã€‚Rust çš„ç±»å‹æ¨æ–­ç³»ç»ŸåŸºäº Hindley-Milner ç±»å‹ç³»ç»Ÿï¼Œèƒ½å¤Ÿæ¨æ–­å‡ºå¤§éƒ¨åˆ†è¡¨è¾¾å¼çš„ç±»å‹ã€‚

```rust
// æ˜¾å¼ç±»å‹æ³¨è§£
let x: i32 = 42;
let y: String = "hello".to_string();

// ç±»å‹æ¨æ–­
let x = 42;                    // æ¨æ–­ä¸º i32
let y = "hello".to_string();   // æ¨æ–­ä¸º String
let z = vec![1, 2, 3];         // æ¨æ–­ä¸º Vec<i32>
```

### 1.2 ç±»å‹æ¨æ–­çš„ä¼˜åŠ¿

1. **å‡å°‘æ ·æ¿ä»£ç **: é¿å…é‡å¤çš„ç±»å‹æ³¨è§£
2. **æé«˜å¯è¯»æ€§**: ä»£ç æ›´ç®€æ´ï¼Œé‡ç‚¹çªå‡º
3. **å¢å¼ºå¯ç»´æŠ¤æ€§**: ç±»å‹å˜æ›´æ—¶å‡å°‘ä¿®æ”¹ç‚¹
4. **ä¿æŒç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ä»ç„¶è¿›è¡Œå®Œæ•´çš„ç±»å‹æ£€æŸ¥

```rust
// æ²¡æœ‰ç±»å‹æ¨æ–­çš„ä»£ç 
fn process_data<T: Clone + std::fmt::Debug>(data: Vec<T>) -> Vec<T> {
    data.iter().map(|item: &T| item.clone()).collect::<Vec<T>>()
}

// æœ‰ç±»å‹æ¨æ–­çš„ä»£ç 
fn process_data<T: Clone + std::fmt::Debug>(data: Vec<T>) -> Vec<T> {
    data.iter().map(|item| item.clone()).collect()
}
```

### 1.3 åŸºæœ¬å·¥ä½œåŸç†

Rust çš„ç±»å‹æ¨æ–­è¿‡ç¨‹åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š

1. **ç±»å‹å˜é‡åˆ†é…**: ä¸ºæœªçŸ¥ç±»å‹åˆ†é…ç±»å‹å˜é‡
2. **çº¦æŸç”Ÿæˆ**: æ ¹æ®è¡¨è¾¾å¼ç”Ÿæˆç±»å‹çº¦æŸ
3. **çº¦æŸæ±‚è§£**: æ±‚è§£çº¦æŸç³»ç»Ÿå¾—åˆ°å…·ä½“ç±»å‹
4. **ç±»å‹æ£€æŸ¥**: éªŒè¯æ¨æ–­ç»“æœçš„æ­£ç¡®æ€§

```rust
// æ¨æ–­è¿‡ç¨‹ç¤ºä¾‹
fn example() {
    let x = 42;           // 1. åˆ†é…ç±»å‹å˜é‡ Î±
    let y = x + 1;        // 2. ç”Ÿæˆçº¦æŸ: Î± + i32 = Î²
    let z = y.to_string(); // 3. ç”Ÿæˆçº¦æŸ: Î² å®ç° ToString
    // 4. æ±‚è§£: Î± = i32, Î² = i32, z = String
}
```

## 2. Hindley-Milner ç³»ç»Ÿ

### 2.1 ç†è®ºåŸºç¡€

Hindley-Milner ç±»å‹ç³»ç»Ÿæ˜¯ Rust ç±»å‹æ¨æ–­çš„ç†è®ºåŸºç¡€ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **å¤šæ€æ€§**: æ”¯æŒå‚æ•°å¤šæ€
- **å¯åˆ¤å®šæ€§**: ç±»å‹æ¨æ–­æ˜¯å¯åˆ¤å®šçš„
- **æœ€ä¸€èˆ¬ç±»å‹**: èƒ½å¤Ÿæ¨æ–­å‡ºæœ€ä¸€èˆ¬çš„ç±»å‹
- **ç±»å‹å®‰å…¨**: ä¿è¯ç±»å‹å®‰å…¨

```rust
// Hindley-Milner ç±»å‹æ¨æ–­ç¤ºä¾‹
fn identity<T>(x: T) -> T {
    x  // ç±»å‹: âˆ€Î±. Î± â†’ Î±
}

fn apply<T, U>(f: T, x: U) -> U
where
    T: Fn(U) -> U,
{
    f(x)  // ç±»å‹: âˆ€Î±,Î². (Î± â†’ Î²) â†’ Î± â†’ Î²
}
```

### 2.2 ç±»å‹å˜é‡

ç±»å‹å˜é‡è¡¨ç¤ºæœªçŸ¥çš„ç±»å‹ï¼Œåœ¨æ¨æ–­è¿‡ç¨‹ä¸­ä¼šè¢«å…·ä½“ç±»å‹æ›¿æ¢ï¼š

```rust
// ç±»å‹å˜é‡ç¤ºä¾‹
fn example() {
    let x = vec![1, 2, 3];  // x: Vec<Î±>ï¼Œå…¶ä¸­ Î± å¾…æ¨æ–­
    let y = x[0];           // y: Î±ï¼Œçº¦æŸ: Î± å®ç° Index<usize>
    let z = y + 1;          // çº¦æŸ: Î± å®ç° Add<i32>
    // æ±‚è§£: Î± = i32
}
```

### 2.3 çº¦æŸç”Ÿæˆ

çº¦æŸç”Ÿæˆæ˜¯ç±»å‹æ¨æ–­çš„æ ¸å¿ƒæ­¥éª¤ï¼Œæ ¹æ®è¡¨è¾¾å¼çš„ç»“æ„ç”Ÿæˆç±»å‹çº¦æŸï¼š

```rust
// çº¦æŸç”Ÿæˆç¤ºä¾‹
fn constraint_generation() {
    let x = 42;                    // çº¦æŸ: x : i32
    let y = "hello";               // çº¦æŸ: y : &str
    let z = x.to_string();         // çº¦æŸ: x å®ç° ToString
    let w = format!("{} {}", y, z); // çº¦æŸ: y, z å®ç° Display
}
```

### 2.4 çº¦æŸæ±‚è§£

çº¦æŸæ±‚è§£å°†ç±»å‹å˜é‡æ›¿æ¢ä¸ºå…·ä½“ç±»å‹ï¼š

```rust
// çº¦æŸæ±‚è§£ç¤ºä¾‹
fn constraint_solving() {
    let mut vec = Vec::new();      // vec: Vec<Î±>
    vec.push(42);                  // çº¦æŸ: Î± = i32
    vec.push(43);                  // éªŒè¯: i32 = i32 âœ“
    // æ±‚è§£ç»“æœ: vec: Vec<i32>
}
```

## 3. Rust ç±»å‹æ¨æ–­ç®—æ³•

### 3.1 ç®—æ³•æ¦‚è¿°

Rust çš„ç±»å‹æ¨æ–­ç®—æ³•åŸºäº Hindley-Milner ç³»ç»Ÿï¼Œä½†å¢åŠ äº†ä»¥ä¸‹æ‰©å±•ï¼š

- **å­ç±»å‹**: æ”¯æŒå­ç±»å‹å…³ç³»
- **ç”Ÿå‘½å‘¨æœŸ**: ç”Ÿå‘½å‘¨æœŸæ¨æ–­
- **ç‰¹å¾çº¦æŸ**: ç‰¹å¾çº¦æŸæ±‚è§£
- **å¸¸é‡æ³›å‹**: å¸¸é‡æ³›å‹æ¨æ–­

```rust
// Rust æ‰©å±•çš„ç±»å‹æ¨æ–­
fn rust_extensions() {
    let x: &str = "hello";         // å­ç±»å‹: &'static str <: &str
    let y = x;                     // ç”Ÿå‘½å‘¨æœŸæ¨æ–­
    let z = y.to_owned();          // ç‰¹å¾çº¦æŸ: &str å®ç° ToOwned
}
```

### 3.2 ç±»å‹å˜é‡åˆ†é…

ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªéœ€è¦æ¨æ–­çš„ç±»å‹åˆ†é…å”¯ä¸€çš„ç±»å‹å˜é‡ï¼š

```rust
// ç±»å‹å˜é‡åˆ†é…
fn type_variable_allocation() {
    let x = Vec::new();            // åˆ†é…: Vec<Î±>
    let y = HashMap::new();        // åˆ†é…: HashMap<Î², Î³>
    let z = (x, y);                // åˆ†é…: (Vec<Î±>, HashMap<Î², Î³>)
}
```

### 3.3 çº¦æŸæ”¶é›†

çº¦æŸæ”¶é›†é˜¶æ®µæ ¹æ®è¡¨è¾¾å¼çš„ä½¿ç”¨æƒ…å†µç”Ÿæˆçº¦æŸï¼š

```rust
// çº¦æŸæ”¶é›†
fn constraint_collection() {
    let mut vec = Vec::new();      // çº¦æŸ: Vec<Î±>
    vec.push(42);                  // çº¦æŸ: Î± = i32
    vec.push("hello");             // çº¦æŸ: Î± = &str
    // é”™è¯¯: æ— æ³•ç»Ÿä¸€ i32 å’Œ &str
}
```

### 3.4 ç»Ÿä¸€ç®—æ³•

ç»Ÿä¸€ç®—æ³•è§£å†³ç±»å‹å˜é‡ä¹‹é—´çš„çº¦æŸå…³ç³»ï¼š

```rust
// ç»Ÿä¸€ç®—æ³•ç¤ºä¾‹
fn unification_example() {
    let x = 42;                    // x: i32
    let y = x;                     // y: i32 (ç»Ÿä¸€)
    let z = y + 1;                 // z: i32 (ç»Ÿä¸€)
}
```

## 4. æ¨æ–­è§„åˆ™

### 4.1 åŸºæœ¬æ¨æ–­è§„åˆ™

```rust
// å­—é¢é‡æ¨æ–­
fn literal_inference() {
    let x = 42;                    // i32
    let y = 42u64;                 // u64
    let z = 3.14;                  // f64
    let w = true;                  // bool
    let s = "hello";               // &str
}

// å˜é‡æ¨æ–­
fn variable_inference() {
    let x = 42;
    let y = x;                     // æ¨æ–­ä¸º i32
    let z = &x;                    // æ¨æ–­ä¸º &i32
}
```

### 4.2 å‡½æ•°æ¨æ–­è§„åˆ™

```rust
// å‡½æ•°å‚æ•°æ¨æ–­
fn function_parameter_inference() {
    let add = |x, y| x + y;        // æ¨æ–­: (i32, i32) -> i32
    let result = add(1, 2);        // æ¨æ–­: i32
}

// å‡½æ•°è¿”å›ç±»å‹æ¨æ–­
fn return_type_inference() -> i32 {
    let x = 42;
    x  // æ¨æ–­è¿”å›ç±»å‹ä¸º i32
}
```

### 4.3 æ³›å‹æ¨æ–­è§„åˆ™

```rust
// æ³›å‹å‚æ•°æ¨æ–­
fn generic_inference() {
    let vec = vec![1, 2, 3];       // æ¨æ–­: Vec<i32>
    let map = HashMap::new();      // æ¨æ–­: HashMap<(), ()>
    map.insert("key", "value");    // æ¨æ–­: HashMap<&str, &str>
}

// æ³›å‹å‡½æ•°æ¨æ–­
fn generic_function<T>(x: T) -> T {
    x
}

fn use_generic() {
    let x = generic_function(42);  // æ¨æ–­: T = i32
    let y = generic_function("hello"); // æ¨æ–­: T = &str
}
```

### 4.4 ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™

```rust
// ç”Ÿå‘½å‘¨æœŸæ¨æ–­
fn lifetime_inference() {
    let x = "hello";
    let y = x;                     // æ¨æ–­ç”Ÿå‘½å‘¨æœŸ
    let z = longest(x, y);         // æ¨æ–­ç”Ÿå‘½å‘¨æœŸå‚æ•°
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 5. é«˜çº§æ¨æ–­ç‰¹æ€§

### 5.1 å¤šæ€æ¨æ–­

```rust
// å¤šæ€ç±»å‹æ¨æ–­
fn polymorphic_inference() {
    let identity = |x| x;          // æ¨æ–­: âˆ€Î±. Î± â†’ Î±
    let int_result = identity(42); // å®ä¾‹åŒ–: i32 â†’ i32
    let str_result = identity("hello"); // å®ä¾‹åŒ–: &str â†’ &str
}

// é«˜é˜¶å¤šæ€
fn higher_order_polymorphic() {
    let apply = |f, x| f(x);       // æ¨æ–­: âˆ€Î±,Î². (Î± â†’ Î²) â†’ Î± â†’ Î²
    let result = apply(|x| x * 2, 21); // å®ä¾‹åŒ–: (i32 â†’ i32) â†’ i32 â†’ i32
}
```

### 5.2 å­ç±»å‹æ¨æ–­

```rust
// å­ç±»å‹æ¨æ–­
fn subtype_inference() {
    let x: &str = "hello";         // &'static str <: &str
    let y = x;                     // æ¨æ–­: &str
    let z: &dyn std::fmt::Display = &42; // i32 <: dyn Display
}
```

### 5.3 é«˜é˜¶ç±»å‹æ¨æ–­

```rust
// é«˜é˜¶ç±»å‹æ¨æ–­
fn higher_kinded_inference() {
    let vec = vec![vec![1, 2], vec![3, 4]]; // æ¨æ–­: Vec<Vec<i32>>
    let option = Some(Some(42));            // æ¨æ–­: Option<Option<i32>>
    let result = Some(Ok(42));              // æ¨æ–­: Option<Result<i32, ()>>
}
```

### 5.4 ä¾èµ–ç±»å‹æ¨æ–­

```rust
// å¸¸é‡æ³›å‹æ¨æ–­
fn const_generic_inference() {
    let arr = [1, 2, 3, 4, 5];     // æ¨æ–­: [i32; 5]
    let vec = Vec::<i32>::new();   // æ¨æ–­: Vec<i32>
}

// å…³è”ç±»å‹æ¨æ–­
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        Some(self.count)
    }
}

fn use_iterator() {
    let mut counter = Counter { count: 0 };
    let item = counter.next();     // æ¨æ–­: Option<u32>
}
```

## 6. æ¨æ–­é™åˆ¶

### 6.1 æ¨æ–­å¤±è´¥åœºæ™¯

```rust
// æ¨æ–­å¤±è´¥ç¤ºä¾‹
fn inference_failure() {
    // é”™è¯¯ï¼šæ— æ³•æ¨æ–­ç±»å‹
    // let x = Vec::new();
    // x.push(42);
    
    // è§£å†³æ–¹æ¡ˆï¼šæä¾›ç±»å‹æ³¨è§£
    let mut x: Vec<i32> = Vec::new();
    x.push(42);
    
    // æˆ–è€…æä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡
    let x = vec![42];  // ä»å…ƒç´ æ¨æ–­ç±»å‹
}
```

### 6.2 æ­§ä¹‰æ€§å¤„ç†

```rust
// æ­§ä¹‰æ€§å¤„ç†
fn ambiguity_handling() {
    // é”™è¯¯ï¼šæ­§ä¹‰çš„ç±»å‹
    // let x = 42;
    // let y = x.parse();
    
    // è§£å†³æ–¹æ¡ˆï¼šæ˜ç¡®æŒ‡å®šç±»å‹
    let x = "42";
    let y: i32 = x.parse().unwrap();
    
    // æˆ–è€…ä½¿ç”¨ç±»å‹æ³¨è§£
    let y = x.parse::<i32>().unwrap();
}
```

### 6.3 ç±»å‹æ³¨è§£éœ€æ±‚

```rust
// éœ€è¦ç±»å‹æ³¨è§£çš„åœºæ™¯
fn type_annotation_required() {
    // 1. ç©ºé›†åˆ
    let mut vec: Vec<i32> = Vec::new();
    
    // 2. å‡½æ•°æŒ‡é’ˆ
    let func: fn(i32) -> i32 = |x| x * 2;
    
    // 3. ç‰¹å¾å¯¹è±¡
    let display: Box<dyn std::fmt::Display> = Box::new(42);
    
    // 4. å¤æ‚æ³›å‹
    let map: std::collections::HashMap<String, Vec<i32>> = HashMap::new();
}
```

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 æ¨æ–­ç®—æ³•ä¼˜åŒ–

```rust
// ä¼˜åŒ–æ¨æ–­æ€§èƒ½çš„æŠ€å·§
fn optimization_tips() {
    // 1. æä¾›ç±»å‹æ³¨è§£å‡å°‘æ¨æ–­å·¥ä½œé‡
    let vec: Vec<i32> = (0..1000).collect();
    
    // 2. ä½¿ç”¨å…·ä½“çš„ç±»å‹è€Œä¸æ˜¯æ³›å‹
    let specific_vec = vec![1, 2, 3, 4, 5];
    
    // 3. é¿å…å¤æ‚çš„åµŒå¥—æ³›å‹
    let simple_map: HashMap<String, i32> = HashMap::new();
}
```

### 7.2 ç¼“å­˜æœºåˆ¶

```rust
// åˆ©ç”¨æ¨æ–­ç¼“å­˜
fn cache_utilization() {
    // ç¼–è¯‘å™¨ä¼šç¼“å­˜æ¨æ–­ç»“æœ
    let vec1 = vec![1, 2, 3];      // æ¨æ–­: Vec<i32>
    let vec2 = vec![4, 5, 6];      // å¤ç”¨æ¨æ–­ç»“æœ
    let vec3 = vec![7, 8, 9];      // å¤ç”¨æ¨æ–­ç»“æœ
}
```

### 7.3 å¢é‡æ¨æ–­

```rust
// å¢é‡æ¨æ–­ç¤ºä¾‹
fn incremental_inference() {
    let mut vec = Vec::new();      // æ¨æ–­: Vec<Î±>
    vec.push(1);                   // çº¦æŸ: Î± = i32
    vec.push(2);                   // éªŒè¯: i32 = i32
    vec.push(3);                   // éªŒè¯: i32 = i32
    // æœ€ç»ˆæ¨æ–­: Vec<i32>
}
```

## 8. è°ƒè¯•å’Œè¯Šæ–­

### 8.1 æ¨æ–­è¿‡ç¨‹å¯è§†åŒ–

```rust
// ä½¿ç”¨ç±»å‹æ³¨è§£å¸®åŠ©è°ƒè¯•
fn debug_inference() {
    let x = 42;
    let y = x + 1;
    let z = y.to_string();
    
    // æ·»åŠ ç±»å‹æ³¨è§£æŸ¥çœ‹æ¨æ–­ç»“æœ
    let x: i32 = 42;
    let y: i32 = x + 1;
    let z: String = y.to_string();
}
```

### 8.2 é”™è¯¯è¯Šæ–­

```rust
// å¸¸è§æ¨æ–­é”™è¯¯
fn common_errors() {
    // é”™è¯¯1ï¼šæ— æ³•æ¨æ–­ç©ºé›†åˆç±»å‹
    // let vec = Vec::new();
    // vec.push(42);
    
    // é”™è¯¯2ï¼šæ­§ä¹‰çš„ç±»å‹
    // let x = 42;
    // let y = x.parse();
    
    // é”™è¯¯3ï¼šç”Ÿå‘½å‘¨æœŸæ¨æ–­å¤±è´¥
    // let result;
    // {
    //     let s = String::from("hello");
    //     result = &s;
    // }
    // println!("{}", result);
}
```

### 8.3 è°ƒè¯•å·¥å…·

```rust
// ä½¿ç”¨ç¼–è¯‘å™¨è¾“å‡ºè°ƒè¯•
fn compiler_debugging() {
    // ä½¿ç”¨ rustc çš„ --explain é€‰é¡¹
    // rustc --explain E0282
    
    // ä½¿ç”¨ cargo expand æŸ¥çœ‹å®å±•å¼€
    // cargo expand
    
    // ä½¿ç”¨ç±»å‹æ£€æŸ¥å·¥å…·
    let x = 42;
    let _: () = x;  // ç±»å‹é”™è¯¯ï¼Œå¸®åŠ©ç†è§£æ¨æ–­è¿‡ç¨‹
}
```

## 9. å®é™…åº”ç”¨

### 9.1 ç¼–è¯‘å™¨å®ç°

```rust
// ç¼–è¯‘å™¨ä¸­çš„ç±»å‹æ¨æ–­
fn compiler_implementation() {
    // 1. è¯æ³•åˆ†æï¼šè¯†åˆ«ç±»å‹å˜é‡
    let x = 42;  // è¯†åˆ«ä¸ºå­—é¢é‡
    
    // 2. è¯­æ³•åˆ†æï¼šæ„å»ºæŠ½è±¡è¯­æ³•æ ‘
    let y = x + 1;  // æ„å»ºäºŒå…ƒè¡¨è¾¾å¼
    
    // 3. ç±»å‹æ¨æ–­ï¼šåˆ†é…ç±»å‹å˜é‡å¹¶æ±‚è§£çº¦æŸ
    // x: Î±, 1: i32, +: (Î±, i32) -> Î²
    // çº¦æŸ: Î± = i32, Î² = i32
    
    // 4. ç±»å‹æ£€æŸ¥ï¼šéªŒè¯æ¨æ–­ç»“æœ
    // éªŒè¯: i32 å®ç° Add<i32>
}
```

### 9.2 IDE æ”¯æŒ

```rust
// IDE ä¸­çš„ç±»å‹æ¨æ–­æ”¯æŒ
fn ide_support() {
    let x = 42;
    // IDE æ˜¾ç¤º: x: i32
    
    let y = x.to_string();
    // IDE æ˜¾ç¤º: y: String
    
    let z = y.len();
    // IDE æ˜¾ç¤º: z: usize
}
```

### 9.3 é™æ€åˆ†æ

```rust
// é™æ€åˆ†æä¸­çš„ç±»å‹æ¨æ–­
fn static_analysis() {
    let vec = vec![1, 2, 3];
    // é™æ€åˆ†æå™¨æ¨æ–­: vec: Vec<i32>
    
    for item in vec {
        // é™æ€åˆ†æå™¨æ¨æ–­: item: i32
        println!("{}", item);
    }
}
```

## 10. æœ€ä½³å®è·µ

### 10.1 ç¼–å†™æ¨æ–­å‹å¥½çš„ä»£ç 

```rust
// å¥½çš„å®è·µï¼šæä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡
fn good_practice() {
    let vec = vec![1, 2, 3];       // ä»å…ƒç´ æ¨æ–­ç±»å‹
    let map = HashMap::from([("key", "value")]); // ä»é”®å€¼å¯¹æ¨æ–­ç±»å‹
    let result = Some(Ok(42));     // ä»åµŒå¥—ç»“æ„æ¨æ–­ç±»å‹
}

// é¿å…çš„å®è·µï¼šç¼ºä¹ä¸Šä¸‹æ–‡
fn bad_practice() {
    // let vec = Vec::new();        // æ— æ³•æ¨æ–­ç±»å‹
    // let map = HashMap::new();    // æ— æ³•æ¨æ–­ç±»å‹
    
    // è§£å†³æ–¹æ¡ˆ
    let vec: Vec<i32> = Vec::new();
    let map: HashMap<String, i32> = HashMap::new();
}
```

### 10.2 æ€§èƒ½è€ƒè™‘

```rust
// æ€§èƒ½ä¼˜åŒ–å»ºè®®
fn performance_considerations() {
    // 1. é¿å…è¿‡åº¦æ³›å‹åŒ–
    fn specific_function(x: i32) -> i32 {
        x * 2
    }
    
    // 2. ä½¿ç”¨å…·ä½“çš„ç±»å‹
    let specific_vec = vec![1, 2, 3, 4, 5];
    
    // 3. æä¾›ç±»å‹æ³¨è§£å‡å°‘æ¨æ–­æ—¶é—´
    let typed_vec: Vec<i32> = (0..1000).collect();
}
```

### 10.3 è°ƒè¯•æŠ€å·§

```rust
// è°ƒè¯•ç±»å‹æ¨æ–­çš„æŠ€å·§
fn debugging_tips() {
    // 1. ä½¿ç”¨ç±»å‹æ³¨è§£éªŒè¯æ¨æ–­
    let x: i32 = 42;
    let y: i32 = x + 1;
    
    // 2. ä½¿ç”¨ç¼–è¯‘å™¨é”™è¯¯ä¿¡æ¯
    let _: () = 42;  // ç±»å‹é”™è¯¯ï¼Œæ˜¾ç¤ºæ¨æ–­è¿‡ç¨‹
    
    // 3. ä½¿ç”¨ IDE çš„ç±»å‹æç¤º
    let vec = vec![1, 2, 3];
    // æ‚¬åœæŸ¥çœ‹ç±»å‹ä¿¡æ¯
    
    // 4. ä½¿ç”¨ cargo expand æŸ¥çœ‹å®å±•å¼€
    // cargo expand
}
```

## 11. æ€»ç»“

Rust çš„ç±»å‹æ¨æ–­ç³»ç»Ÿæ˜¯ä¸€ä¸ªå¼ºå¤§è€Œå¤æ‚çš„æœºåˆ¶ï¼Œå®ƒï¼š

1. **å‡å°‘æ ·æ¿ä»£ç **: è‡ªåŠ¨æ¨æ–­å¤§éƒ¨åˆ†ç±»å‹
2. **ä¿æŒç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶è¿›è¡Œå®Œæ•´ç±»å‹æ£€æŸ¥
3. **æ”¯æŒå¤æ‚åœºæ™¯**: å¤„ç†æ³›å‹ã€ç”Ÿå‘½å‘¨æœŸã€ç‰¹å¾çº¦æŸ
4. **æä¾›è‰¯å¥½ä½“éªŒ**: å¹³è¡¡è‡ªåŠ¨æ¨æ–­å’Œæ˜¾å¼æ§åˆ¶

### å…³é”®è¦ç‚¹

- ç±»å‹æ¨æ–­åŸºäº Hindley-Milner ç³»ç»Ÿ
- ç¼–è¯‘å™¨é€šè¿‡çº¦æŸç”Ÿæˆå’Œæ±‚è§£æ¨æ–­ç±»å‹
- æŸäº›åœºæ™¯éœ€è¦æ˜¾å¼ç±»å‹æ³¨è§£
- æ¨æ–­å¤±è´¥æ—¶ç¼–è¯‘å™¨ä¼šæä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
- åˆç†ä½¿ç”¨ç±»å‹æ³¨è§£å¯ä»¥æé«˜æ€§èƒ½å’Œå¯è¯»æ€§

### è¿›ä¸€æ­¥å­¦ä¹ 

- å­¦ä¹  Hindley-Milner ç±»å‹ç³»ç»Ÿçš„ç†è®ºåŸºç¡€
- ç ”ç©¶ Rust ç¼–è¯‘å™¨çš„ç±»å‹æ¨æ–­å®ç°
- äº†è§£å…¶ä»–è¯­è¨€çš„ç±»å‹æ¨æ–­æœºåˆ¶
- å®è·µç¼–å†™æ¨æ–­å‹å¥½çš„ä»£ç 

---

**ç¤ºä¾‹ä¸æµ‹è¯•**: è§ `examples/type_inference_examples.rs` ä¸ `tests/type_inference_tests.rs`ã€‚
