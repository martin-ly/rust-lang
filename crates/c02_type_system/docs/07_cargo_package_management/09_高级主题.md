# Cargo é«˜çº§ä¸»é¢˜

**ç‰ˆæœ¬**: Rust 1.90  
**æœ€åæ›´æ–°**: 2025-10-19

---

## ğŸ“‹ ç›®å½•

- [Cargo é«˜çº§ä¸»é¢˜](#cargo-é«˜çº§ä¸»é¢˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ é«˜çº§ä¸»é¢˜æ¦‚è§ˆ](#-é«˜çº§ä¸»é¢˜æ¦‚è§ˆ)
  - [1. é«˜çº§æ„å»ºè„šæœ¬](#1-é«˜çº§æ„å»ºè„šæœ¬)
    - [1.1 ç¯å¢ƒå˜é‡](#11-ç¯å¢ƒå˜é‡)
    - [1.2 æ¡ä»¶ç¼–è¯‘](#12-æ¡ä»¶ç¼–è¯‘)
    - [1.3 ä»£ç ç”Ÿæˆ](#13-ä»£ç ç”Ÿæˆ)
  - [2. è¿‡ç¨‹å®](#2-è¿‡ç¨‹å®)
    - [2.1 derive å®](#21-derive-å®)
    - [2.2 å±æ€§å®](#22-å±æ€§å®)
    - [2.3 å‡½æ•°å®](#23-å‡½æ•°å®)
  - [3. FFI é›†æˆ](#3-ffi-é›†æˆ)
    - [3.1 è°ƒç”¨ C åº“](#31-è°ƒç”¨-c-åº“)
    - [3.2 å¯¼å‡ºåˆ° C](#32-å¯¼å‡ºåˆ°-c)
    - [3.3 bindgen](#33-bindgen)
  - [4. è‡ªå®šä¹‰å·¥å…·é“¾](#4-è‡ªå®šä¹‰å·¥å…·é“¾)
    - [4.1 å·¥å…·é“¾è¦†ç›–](#41-å·¥å…·é“¾è¦†ç›–)
    - [4.2 è‡ªå®šä¹‰ç›®æ ‡](#42-è‡ªå®šä¹‰ç›®æ ‡)
    - [4.3 å·¥å…·é“¾ç»„ä»¶](#43-å·¥å…·é“¾ç»„ä»¶)
  - [5. Cargo æ‰©å±•](#5-cargo-æ‰©å±•)
    - [5.1 è‡ªå®šä¹‰å‘½ä»¤](#51-è‡ªå®šä¹‰å‘½ä»¤)
    - [5.2 Cargo æ’ä»¶](#52-cargo-æ’ä»¶)
    - [5.3 é›†æˆå·¥å…·](#53-é›†æˆå·¥å…·)
  - [6. ç§æœ‰æ³¨å†Œè¡¨](#6-ç§æœ‰æ³¨å†Œè¡¨)
    - [6.1 æ­å»ºç§æœ‰æ³¨å†Œè¡¨](#61-æ­å»ºç§æœ‰æ³¨å†Œè¡¨)
    - [6.2 é…ç½®ä½¿ç”¨](#62-é…ç½®ä½¿ç”¨)
    - [6.3 é•œåƒåŠ é€Ÿ](#63-é•œåƒåŠ é€Ÿ)
  - [7. no\_std å¼€å‘](#7-no_std-å¼€å‘)
    - [7.1 åŸºç¡€é…ç½®](#71-åŸºç¡€é…ç½®)
    - [7.2 ä¾èµ–ç®¡ç†](#72-ä¾èµ–ç®¡ç†)
    - [7.3 å¸¸è§æ¨¡å¼](#73-å¸¸è§æ¨¡å¼)
  - [8. WebAssembly](#8-webassembly)
    - [8.1 wasm-pack](#81-wasm-pack)
    - [8.2 ä¼˜åŒ–é…ç½®](#82-ä¼˜åŒ–é…ç½®)
    - [8.3 JavaScript äº’æ“ä½œ](#83-javascript-äº’æ“ä½œ)
  - [9. æ€§èƒ½åˆ†æ](#9-æ€§èƒ½åˆ†æ)
    - [9.1 ç¼–è¯‘æ—¶é—´åˆ†æ](#91-ç¼–è¯‘æ—¶é—´åˆ†æ)
    - [9.2 è¿è¡Œæ—¶åˆ†æ](#92-è¿è¡Œæ—¶åˆ†æ)
    - [9.3 å†…å­˜åˆ†æ](#93-å†…å­˜åˆ†æ)
  - [10. å®‰å…¨åŠ å›º](#10-å®‰å…¨åŠ å›º)
    - [10.1 ä¾èµ–å®¡è®¡](#101-ä¾èµ–å®¡è®¡)
    - [10.2 fuzzing](#102-fuzzing)
    - [10.3 å†…å­˜å®‰å…¨](#103-å†…å­˜å®‰å…¨)
  - [ğŸ“Š é«˜çº§åŠŸèƒ½å¯¹æ¯”](#-é«˜çº§åŠŸèƒ½å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [ğŸ“– å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [å·¥å…·](#å·¥å…·)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## ğŸ¯ é«˜çº§ä¸»é¢˜æ¦‚è§ˆ

Cargo çš„é«˜çº§åŠŸèƒ½å’Œæ‰©å±•èƒ½åŠ›ï¼š

```mermaid
graph TD
    A[é«˜çº§ä¸»é¢˜] --> B[æ„å»ºè„šæœ¬]
    A --> C[è¿‡ç¨‹å®]
    A --> D[FFI]
    A --> E[æ‰©å±•å·¥å…·]
    
    B --> B1[ä»£ç ç”Ÿæˆ]
    C --> C1[è‡ªå®šä¹‰ derive]
    D --> D1[C äº’æ“ä½œ]
    E --> E1[cargo æ’ä»¶]
```

---

## 1. é«˜çº§æ„å»ºè„šæœ¬

### 1.1 ç¯å¢ƒå˜é‡

**å¯ç”¨å˜é‡**ï¼š

```rust
// build.rs
use std::env;

fn main() {
    // Cargo æä¾›çš„å˜é‡
    let out_dir = env::var("OUT_DIR").unwrap();
    let target = env::var("TARGET").unwrap();
    let host = env::var("HOST").unwrap();
    let opt_level = env::var("OPT_LEVEL").unwrap();
    let profile = env::var("PROFILE").unwrap();
    
    println!("OUT_DIR: {}", out_dir);
    println!("TARGET: {}", target);
    println!("PROFILE: {}", profile);
    
    // åŒ…ä¿¡æ¯
    let pkg_name = env::var("CARGO_PKG_NAME").unwrap();
    let pkg_version = env::var("CARGO_PKG_VERSION").unwrap();
    
    // ç‰¹æ€§æ£€æµ‹
    if env::var("CARGO_FEATURE_SERDE").is_ok() {
        println!("Serde feature enabled");
    }
}
```

### 1.2 æ¡ä»¶ç¼–è¯‘

**è®¾ç½® cfg æ ‡å¿—**ï¼š

```rust
// build.rs
fn main() {
    // åŸºäºæ“ä½œç³»ç»Ÿ
    if cfg!(target_os = "linux") {
        println!("cargo:rustc-cfg=use_epoll");
    }
    
    // åŸºäºç‰¹æ€§
    println!("cargo:rustc-cfg=has_custom_feature");
    
    // åŸºäºç¯å¢ƒ
    if env::var("ENABLE_LOGGING").is_ok() {
        println!("cargo:rustc-cfg=logging_enabled");
    }
}
```

```rust
// src/lib.rs
#[cfg(use_epoll)]
mod epoll_impl {
    // Linux epoll å®ç°
}

#[cfg(has_custom_feature)]
pub fn custom_function() {
    // è‡ªå®šä¹‰åŠŸèƒ½
}
```

### 1.3 ä»£ç ç”Ÿæˆ

**ç”Ÿæˆ Rust ä»£ç **ï¼š

```rust
// build.rs
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated.rs");
    
    let code = generate_code();
    fs::write(dest_path, code).unwrap();
    
    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_code() -> String {
    format!(
        r#"
        pub const BUILD_TIME: &str = "{}";
        pub const GIT_HASH: &str = "{}";
        
        pub mod generated {{
            pub fn version() -> &'static str {{
                "{}"
            }}
        }}
        "#,
        chrono::Utc::now().to_rfc3339(),
        git_hash(),
        env!("CARGO_PKG_VERSION")
    )
}

fn git_hash() -> String {
    std::process::Command::new("git")
        .args(&["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|output| String::from_utf8(output.stdout).ok())
        .unwrap_or_else(|| "unknown".to_string())
}
```

```rust
// src/lib.rs
include!(concat!(env!("OUT_DIR"), "/generated.rs"));

pub fn print_build_info() {
    println!("Built at: {}", BUILD_TIME);
    println!("Git hash: {}", GIT_HASH);
}
```

---

## 2. è¿‡ç¨‹å®

### 2.1 derive å®

**åˆ›å»º derive å®åŒ…**ï¼š

```toml
# my-derive/Cargo.toml
[package]
name = "my-derive"
version = "0.1.0"
edition = "2024"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
```

```rust
// my-derive/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyTrait)]
pub fn derive_my_trait(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;
    
    let expanded = quote! {
        impl MyTrait for #name {
            fn my_method(&self) -> String {
                format!("Hello from {}", stringify!(#name))
            }
        }
    };
    
    TokenStream::from(expanded)
}
```

**ä½¿ç”¨**ï¼š

```rust
// ç”¨æˆ·ä»£ç 
use my_derive::MyTrait;

#[derive(MyTrait)]
struct MyStruct;

fn main() {
    let s = MyStruct;
    println!("{}", s.my_method());
}
```

### 2.2 å±æ€§å®

```rust
// my-macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn trace(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_sig = &input.sig;
    
    let expanded = quote! {
        #fn_sig {
            println!("Entering {}", stringify!(#fn_name));
            let result = (|| #fn_block)();
            println!("Exiting {}", stringify!(#fn_name));
            result
        }
    };
    
    TokenStream::from(expanded)
}
```

**ä½¿ç”¨**ï¼š

```rust
use my_macro::trace;

#[trace]
fn my_function(x: i32) -> i32 {
    x * 2
}
```

### 2.3 å‡½æ•°å®

```rust
// my-macro/src/lib.rs
#[proc_macro]
pub fn make_struct(input: TokenStream) -> TokenStream {
    let name = parse_macro_input!(input as syn::Ident);
    
    let expanded = quote! {
        struct #name {
            value: i32,
        }
        
        impl #name {
            pub fn new(value: i32) -> Self {
                Self { value }
            }
        }
    };
    
    TokenStream::from(expanded)
}
```

**ä½¿ç”¨**ï¼š

```rust
use my_macro::make_struct;

make_struct!(MyStruct);

fn main() {
    let s = MyStruct::new(42);
}
```

---

## 3. FFI é›†æˆ

### 3.1 è°ƒç”¨ C åº“

**ä½¿ç”¨ cc crate**ï¼š

```toml
# Cargo.toml
[build-dependencies]
cc = "1.0"
```

```rust
// build.rs
fn main() {
    cc::Build::new()
        .file("src/native/wrapper.c")
        .include("src/native")
        .compile("wrapper");
}
```

```c
// src/native/wrapper.c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}
```

```rust
// src/lib.rs
extern "C" {
    fn add(a: i32, b: i32) -> i32;
}

pub fn safe_add(a: i32, b: i32) -> i32 {
    unsafe { add(a, b) }
}
```

### 3.2 å¯¼å‡ºåˆ° C

```rust
// src/lib.rs
#[no_mangle]
pub extern "C" fn rust_add(a: i32, b: i32) -> i32 {
    a + b
}

#[no_mangle]
pub extern "C" fn rust_hello() -> *const u8 {
    b"Hello from Rust!\0".as_ptr()
}
```

```c
// header.h
#ifdef __cplusplus
extern "C" {
#endif

int rust_add(int a, int b);
const char* rust_hello(void);

#ifdef __cplusplus
}
#endif
```

### 3.3 bindgen

**è‡ªåŠ¨ç”Ÿæˆç»‘å®š**ï¼š

```toml
[build-dependencies]
bindgen = "0.69"
```

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rerun-if-changed=wrapper.h");
    
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .expect("Unable to generate bindings");
    
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
```

```rust
// src/lib.rs
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
```

---

## 4. è‡ªå®šä¹‰å·¥å…·é“¾

### 4.1 å·¥å…·é“¾è¦†ç›–

**é¡¹ç›®çº§è¦†ç›–**ï¼š

```toml
# rust-toolchain.toml
[toolchain]
channel = "nightly-2025-10-19"
components = ["rustfmt", "clippy"]
targets = ["wasm32-unknown-unknown"]
profile = "minimal"
```

**ç›®å½•çº§è¦†ç›–**ï¼š

```bash
# è®¾ç½®è¦†ç›–
rustup override set nightly

# æŸ¥çœ‹è¦†ç›–
rustup override list

# å–æ¶ˆè¦†ç›–
rustup override unset
```

### 4.2 è‡ªå®šä¹‰ç›®æ ‡

**åˆ›å»ºç›®æ ‡è§„èŒƒ**ï¼š

```json
{
  "llvm-target": "x86_64-unknown-none",
  "data-layout": "e-m:e-i64:64-f80:128-n8:16:32:64-S128",
  "arch": "x86_64",
  "target-endian": "little",
  "target-pointer-width": "64",
  "target-c-int-width": "32",
  "os": "none",
  "executables": true,
  "linker-flavor": "ld.lld",
  "linker": "rust-lld",
  "panic-strategy": "abort",
  "disable-redzone": true,
  "features": "-mmx,-sse,+soft-float"
}
```

**ä½¿ç”¨**ï¼š

```bash
cargo build --target x86_64-unknown-none.json
```

### 4.3 å·¥å…·é“¾ç»„ä»¶

```bash
# æ·»åŠ ç»„ä»¶
rustup component add rustfmt
rustup component add clippy
rustup component add rust-src

# åˆ—å‡ºç»„ä»¶
rustup component list

# åˆ é™¤ç»„ä»¶
rustup component remove rustfmt
```

---

## 5. Cargo æ‰©å±•

### 5.1 è‡ªå®šä¹‰å‘½ä»¤

**åˆ›å»º cargo-my-cmd**ï¼š

```rust
// src/main.rs
fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    // Cargo ä¼šä¼ é€’ "my-cmd" ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°
    // cargo my-cmd --flag
    // args = ["cargo-my-cmd", "my-cmd", "--flag"]
    
    println!("Running custom command with args: {:?}", &args[1..]);
}
```

**å®‰è£…å’Œä½¿ç”¨**ï¼š

```bash
# å®‰è£…
cargo install --path .

# ä½¿ç”¨
cargo my-cmd --flag
```

### 5.2 Cargo æ’ä»¶

**å¸¸ç”¨æ’ä»¶**ï¼š

```bash
# cargo-edit - ä¾èµ–ç®¡ç†
cargo install cargo-edit
cargo add tokio
cargo rm old-dep
cargo upgrade

# cargo-watch - è‡ªåŠ¨é‡æ–°ç¼–è¯‘
cargo install cargo-watch
cargo watch -x build

# cargo-expand - å±•å¼€å®
cargo install cargo-expand
cargo expand

# cargo-tree - ä¾èµ–æ ‘
cargo tree

# cargo-outdated - æ£€æŸ¥è¿‡æ—¶ä¾èµ–
cargo install cargo-outdated
cargo outdated
```

### 5.3 é›†æˆå·¥å…·

**IDE é›†æˆ**ï¼š

```toml
# .cargo/config.toml
[target.x86_64-unknown-linux-gnu]
runner = "gdb -q -ex run"

[build]
rustflags = ["-C", "link-arg=-fuse-ld=mold"]

[alias]
b = "build"
t = "test"
r = "run"
```

---

## 6. ç§æœ‰æ³¨å†Œè¡¨

### 6.1 æ­å»ºç§æœ‰æ³¨å†Œè¡¨

**ä½¿ç”¨ Kellnr**ï¼š

```bash
# Docker éƒ¨ç½²
docker run -d \
  --name kellnr \
  -p 8000:8000 \
  -v kellnr_data:/opt/kdata \
  kellnr/kellnr:latest
```

### 6.2 é…ç½®ä½¿ç”¨

```toml
# .cargo/config.toml
[registries.my-registry]
index = "https://my-registry.com/git/index"
token = "<token>"

[source.my-registry]
registry = "https://my-registry.com/git/index"
```

**å‘å¸ƒåˆ°ç§æœ‰æ³¨å†Œè¡¨**ï¼š

```bash
cargo publish --registry my-registry
```

### 6.3 é•œåƒåŠ é€Ÿ

**é…ç½®é•œåƒ**ï¼š

```toml
# .cargo/config.toml
[source.crates-io]
replace-with = "ustc"

[source.ustc]
registry = "https://mirrors.ustc.edu.cn/crates.io-index"
```

---

## 7. no_std å¼€å‘

### 7.1 åŸºç¡€é…ç½®

```rust
// src/lib.rs
#![no_std]

#[cfg(feature = "alloc")]
extern crate alloc;

#[cfg(feature = "alloc")]
use alloc::vec::Vec;

pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

```toml
# Cargo.toml
[features]
default = []
std = []
alloc = []
```

### 7.2 ä¾èµ–ç®¡ç†

```toml
[dependencies]
serde = { version = "1.0", default-features = false, features = ["derive"] }
heapless = "0.8"  # no_std é›†åˆç±»å‹

[features]
std = ["serde/std"]
```

### 7.3 å¸¸è§æ¨¡å¼

**panic handler**ï¼š

```rust
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

**å…¨å±€åˆ†é…å™¨**ï¼š

```rust
#![no_std]
#![feature(alloc_error_handler)]

extern crate alloc;

use alloc::alloc::GlobalAlloc;

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: core::alloc::Layout) -> *mut u8 {
        // å®ç°
        core::ptr::null_mut()
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: core::alloc::Layout) {
        // å®ç°
    }
}

#[global_allocator]
static ALLOCATOR: MyAllocator = MyAllocator;

#[alloc_error_handler]
fn alloc_error(_layout: core::alloc::Layout) -> ! {
    loop {}
}
```

---

## 8. WebAssembly

### 8.1 wasm-pack

**é…ç½®**ï¼š

```toml
# Cargo.toml
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"

[profile.release]
opt-level = "z"
lto = true
```

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}
```

**æ„å»º**ï¼š

```bash
# å®‰è£… wasm-pack
cargo install wasm-pack

# æ„å»º
wasm-pack build --target web

# è¾“å‡ºç›®å½•: pkg/
```

### 8.2 ä¼˜åŒ–é…ç½®

```toml
[profile.release]
opt-level = "z"     # ä¼˜åŒ–å¤§å°
lto = true
codegen-units = 1
panic = "abort"

[profile.release.package."*"]
opt-level = "z"
```

**ä½¿ç”¨ wasm-opt**ï¼š

```bash
# è¿›ä¸€æ­¥ä¼˜åŒ–
wasm-opt -Oz -o output.wasm input.wasm
```

### 8.3 JavaScript äº’æ“ä½œ

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct Calculator {
    value: f64,
}

#[wasm_bindgen]
impl Calculator {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Calculator {
        Calculator { value: 0.0 }
    }
    
    pub fn add(&mut self, x: f64) -> f64 {
        self.value += x;
        self.value
    }
    
    pub fn get_value(&self) -> f64 {
        self.value
    }
}
```

```javascript
// JavaScript ä½¿ç”¨
import init, { Calculator } from './pkg/my_wasm.js';

async function run() {
    await init();
    
    const calc = new Calculator();
    console.log(calc.add(5));  // 5
    console.log(calc.add(3));  // 8
}

run();
```

---

## 9. æ€§èƒ½åˆ†æ

### 9.1 ç¼–è¯‘æ—¶é—´åˆ†æ

```bash
# ç”Ÿæˆç¼–è¯‘æ—¶é—´æŠ¥å‘Š
cargo build --timings

# æŸ¥çœ‹æŠ¥å‘Š
# target/cargo-timings/cargo-timing.html

# è¯¦ç»†åˆ†æ
cargo build -Z timings
```

### 9.2 è¿è¡Œæ—¶åˆ†æ

**ä½¿ç”¨ perf (Linux)**ï¼š

```bash
# æ„å»ºå¸¦è°ƒè¯•ä¿¡æ¯çš„ release
cargo build --release
RUSTFLAGS="-C force-frame-pointers=yes" cargo build --release

# æ€§èƒ½åˆ†æ
perf record target/release/my-app
perf report

# ç«ç„°å›¾
cargo flamegraph
```

**ä½¿ç”¨ Instruments (macOS)**ï¼š

```bash
cargo build --release
instruments -t "Time Profiler" target/release/my-app
```

### 9.3 å†…å­˜åˆ†æ

```bash
# Valgrind
valgrind --leak-check=full target/release/my-app

# heaptrack
heaptrack target/release/my-app
heaptrack_gui heaptrack.my-app.*.gz
```

---

## 10. å®‰å…¨åŠ å›º

### 10.1 ä¾èµ–å®¡è®¡

```bash
# cargo-audit
cargo install cargo-audit
cargo audit

# cargo-deny
cargo install cargo-deny
cargo deny check
```

```toml
# deny.toml
[advisories]
vulnerability = "deny"
unmaintained = "warn"

[licenses]
unlicensed = "deny"
allow = ["MIT", "Apache-2.0"]
deny = ["GPL-3.0"]
```

### 10.2 fuzzing

**ä½¿ç”¨ cargo-fuzz**ï¼š

```bash
# å®‰è£…
cargo install cargo-fuzz

# åˆå§‹åŒ–
cargo fuzz init

# æ·»åŠ  fuzz target
cargo fuzz add my_target
```

```rust
// fuzz/fuzz_targets/my_target.rs
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    // æµ‹è¯•ä½ çš„ä»£ç 
    if let Ok(s) = std::str::from_utf8(data) {
        my_crate::parse(s);
    }
});
```

```bash
# è¿è¡Œ fuzzing
cargo fuzz run my_target
```

### 10.3 å†…å­˜å®‰å…¨

**Miri (æœªå®šä¹‰è¡Œä¸ºæ£€æµ‹)**ï¼š

```bash
# å®‰è£…
rustup component add miri

# è¿è¡Œ
cargo miri test
cargo miri run
```

**AddressSanitizer**:

```bash
# ä½¿ç”¨ sanitizer
RUSTFLAGS="-Z sanitizer=address" cargo +nightly build --target x86_64-unknown-linux-gnu
./target/x86_64-unknown-linux-gnu/debug/my-app
```

---

## ğŸ“Š é«˜çº§åŠŸèƒ½å¯¹æ¯”

| åŠŸèƒ½ | å¤æ‚åº¦ | ä½¿ç”¨åœºæ™¯ | æ€§èƒ½å½±å“ |
|-----|-------|---------|---------|
| æ„å»ºè„šæœ¬ | ä¸­ | ä»£ç ç”Ÿæˆã€C é›†æˆ | ç¼–è¯‘æ—¶ |
| è¿‡ç¨‹å® | é«˜ | è‡ªå®šä¹‰ deriveã€DSL | ç¼–è¯‘æ—¶ |
| FFI | é«˜ | C/C++ äº’æ“ä½œ | å¯èƒ½æœ‰å¼€é”€ |
| no_std | ä¸­ | åµŒå…¥å¼ã€WebAssembly | æ›´å°çš„äºŒè¿›åˆ¶ |
| ç§æœ‰æ³¨å†Œè¡¨ | ä¸­ | ä¼ä¸šå†…éƒ¨ | æ—  |

---

## ğŸ” å¸¸è§é—®é¢˜

**Q1: ä½•æ—¶ä½¿ç”¨æ„å»ºè„šæœ¬ï¼Ÿ**

```text
âœ… ä½¿ç”¨åœºæ™¯ï¼š
- ç¼–è¯‘ C/C++ ä»£ç 
- ç”Ÿæˆä»£ç 
- è¿è¡Œ bindgen
- è®¾ç½®ç¼–è¯‘æ ‡å¿—

âŒ é¿å…åœºæ™¯ï¼š
- å¤æ‚çš„ä¸šåŠ¡é€»è¾‘
- é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
```

**Q2: è¿‡ç¨‹å®vså£°æ˜å®ï¼Ÿ**

```text
è¿‡ç¨‹å®ï¼š
- æ›´å¼ºå¤§
- å¯è®¿é—® AST
- ç¼–è¯‘æ—¶é—´æ›´é•¿

å£°æ˜å®ï¼š
- æ›´ç®€å•
- åŸºäºæ¨¡å¼åŒ¹é…
- ç¼–è¯‘æ›´å¿«
```

**Q3: no_std æœ‰ä»€ä¹ˆé™åˆ¶ï¼Ÿ**

```text
ä¸å¯ç”¨ï¼š
- æ–‡ä»¶ I/O
- ç½‘ç»œ
- çº¿ç¨‹
- åŠ¨æ€å†…å­˜ï¼ˆé™¤éå¯ç”¨ allocï¼‰

å¯ç”¨ï¼š
- æ ¸å¿ƒç±»å‹
- æ•°å­¦è¿ç®—
- å­—ç¬¦ä¸²å¤„ç†ï¼ˆæœ‰é™ï¼‰
```

---

## ğŸ“– å»¶ä¼¸é˜…è¯»

### å®˜æ–¹æ–‡æ¡£

- [Build Scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html)
- [Procedural Macros](https://doc.rust-lang.org/reference/procedural-macros.html)
- [FFI](https://doc.rust-lang.org/nomicon/ffi.html)

### å·¥å…·

- [bindgen](https://github.com/rust-lang/rust-bindgen)
- [wasm-pack](https://github.com/rustwasm/wasm-pack)
- [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz)
- [miri](https://github.com/rust-lang/miri)

### ç›¸å…³æ–‡æ¡£

- [06_æ„å»ºç³»ç»Ÿè¯¦è§£.md](./06_æ„å»ºç³»ç»Ÿè¯¦è§£.md)
- [08_æœ€ä½³å®è·µæŒ‡å—.md](./08_æœ€ä½³å®è·µæŒ‡å—.md)
- [10_å®æˆ˜æ¡ˆä¾‹é›†.md](./10_å®æˆ˜æ¡ˆä¾‹é›†.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025-10-19  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+

*æŒæ¡é«˜çº§ç‰¹æ€§ï¼Œæ¸¸åˆƒæœ‰ä½™ã€‚* ğŸ¦€ğŸš€
