---
title: Rust 1.90 类型系统与基础语法全景指南（c02_type_system）
lang: zh-CN
---

说明：本指南面向“从语义到代码”的系统化学习，聚焦 Rust 1.90 的类型系统与基础语法。配套示例：

- `examples/rust_190_features_demo.rs`：最小可运行片段，串联核心语法点。
- `examples/rust_190_comprehensive_demo.rs`：更全面的工程化写法。
- `tests/rust_190_features_tests.rs`：关键行为的断言回归。

目录：

- 原生类型与常量/静态/常量函数
- 所有权、借用、切片与字符串
- 结构体、枚举、模式与匹配
- Trait、泛型、关联类型、impl Trait
- 常量泛型（const generics）
- 错误处理与转换：Result/?/From/Into/TryFrom/AsRef
- 模块与可见性
- 条件编译与目标特性
- Send/Sync 直觉与并发前置

每节均给出：何时用、为何如此、边界与陷阱、示例链接。

1) 原生类型与常量/静态/常量函数

    - 常量 `const`：编译期内联；不可变；需赋常量表达式。
    - 静态 `static`：具有固定内存地址；可通过原子类型进行并发安全访问。
    - 常量函数 `const fn`：可在 const 上下文求值；限制逐步放宽。

2) 所有权、借用、切片与字符串

    - `String`/`&str`：拥有者 vs 视图；`&String` 可自动解引用到 `&str`。
    - 切片 `&[T]` 与 `Vec<T>`：只读视图 vs 可增长容器。
    - 借用规则：不可变多借、可变独占；生命周期遵循“借用不超过被借用者”。

3) 结构体、枚举、模式与匹配

    - 模式解构支持重命名与守卫；枚举匹配应覆盖完备性（exhaustive）。
    - 使用 `match` 明确状态机分支；必要时加守卫 `if` 保持精确性。

4) Trait、泛型、关联类型、impl Trait

    - Trait 提供行为抽象；关联类型简化复杂泛型签名。
    - `impl Trait` 返回位置隐藏具体类型；参数位置表达“实现某 Trait 的任意类型”。

5) 常量泛型（const generics）

    - 将“大小/容量”等编译期已知信息编码到类型中；避免运行期开销。
    - N 必须是编译期常量；部分复杂表达式不支持，需要拆分。

6) 错误处理与转换

    - `?` 传播错误，并按 `From` 自动转换错误类型。
    - 对外暴露 API 时建议用自定义错误枚举集中语义。

7) 模块与可见性

    - `pub`, `pub(crate)`, `pub(super)`, `pub(in path)` 精细控制边界；
    - 建议只导出稳定不变的抽象面，内部细节保持私有。

8) 条件编译与目标特性

    - `#[cfg(...)]` 按平台/特性切换实现；
    - 对于指令集细分用 `target_feature`；注意在 CI 上至少覆盖一个通用路径。

9) Send/Sync 直觉

- `i32`: Send+Sync；`Rc<T>`: !Send/!Sync；`Arc<T>`: Send+Sync（若 T 满足）。
- 不要将 `!Send` 类型跨线程移动；必要时替换为 `Arc` 或通道。

更多：请结合源码注释阅读上述示例文件，理解每行代码背后的类型约束与编译期保证。
