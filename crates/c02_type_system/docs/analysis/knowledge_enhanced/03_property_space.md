# ç±»å‹ç³»ç»Ÿ - å±æ€§ç©ºé—´

> **æ–‡æ¡£ç±»å‹**: ğŸ“ å±æ€§ç©ºé—´ | ğŸ“Š å¤šç»´åˆ†æ  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-19  
> **Rust ç‰ˆæœ¬**: 1.90+

---

## ç›®å½•

- [ç±»å‹ç³»ç»Ÿ - å±æ€§ç©ºé—´](#ç±»å‹ç³»ç»Ÿ---å±æ€§ç©ºé—´)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
    - [å±æ€§ç©ºé—´çš„ä½œç”¨](#å±æ€§ç©ºé—´çš„ä½œç”¨)
  - [ğŸ¯ å±æ€§ç»´åº¦åˆ†ç±»](#-å±æ€§ç»´åº¦åˆ†ç±»)
  - [1ï¸âƒ£ ç±»å‹ç»´åº¦ (Type Dimensions)](#1ï¸âƒ£-ç±»å‹ç»´åº¦-type-dimensions)
    - [1.1 å¤§å°å±æ€§ (Size Properties)](#11-å¤§å°å±æ€§-size-properties)
    - [1.2 å¸ƒå±€å±æ€§ (Layout Properties)](#12-å¸ƒå±€å±æ€§-layout-properties)
    - [1.3 å¯¹é½å±æ€§ (Alignment Properties)](#13-å¯¹é½å±æ€§-alignment-properties)
  - [2ï¸âƒ£ å®‰å…¨ç»´åº¦ (Safety Dimensions)](#2ï¸âƒ£-å®‰å…¨ç»´åº¦-safety-dimensions)
    - [2.1 ç±»å‹å®‰å…¨ (Type Safety)](#21-ç±»å‹å®‰å…¨-type-safety)
    - [2.2 å†…å­˜å®‰å…¨ (Memory Safety)](#22-å†…å­˜å®‰å…¨-memory-safety)
    - [2.3 çº¿ç¨‹å®‰å…¨ (Thread Safety)](#23-çº¿ç¨‹å®‰å…¨-thread-safety)
  - [3ï¸âƒ£ æ€§èƒ½ç»´åº¦ (Performance Dimensions)](#3ï¸âƒ£-æ€§èƒ½ç»´åº¦-performance-dimensions)
    - [3.1 ç¼–è¯‘æ—¶æ€§èƒ½ (Compile-time Performance)](#31-ç¼–è¯‘æ—¶æ€§èƒ½-compile-time-performance)
    - [3.2 è¿è¡Œæ—¶æ€§èƒ½ (Runtime Performance)](#32-è¿è¡Œæ—¶æ€§èƒ½-runtime-performance)
    - [3.3 å†…å­˜æ€§èƒ½ (Memory Performance)](#33-å†…å­˜æ€§èƒ½-memory-performance)
  - [4ï¸âƒ£ è¡¨è¾¾ç»´åº¦ (Expressiveness Dimensions)](#4ï¸âƒ£-è¡¨è¾¾ç»´åº¦-expressiveness-dimensions)
    - [4.1 æŠ½è±¡èƒ½åŠ› (Abstraction Capability)](#41-æŠ½è±¡èƒ½åŠ›-abstraction-capability)
    - [4.2 ç»„åˆèƒ½åŠ› (Composition Capability)](#42-ç»„åˆèƒ½åŠ›-composition-capability)
    - [4.3 å¤šæ€èƒ½åŠ› (Polymorphism Capability)](#43-å¤šæ€èƒ½åŠ›-polymorphism-capability)
  - [5ï¸âƒ£ å·¥ç¨‹ç»´åº¦ (Engineering Dimensions)](#5ï¸âƒ£-å·¥ç¨‹ç»´åº¦-engineering-dimensions)
    - [5.1 å¯ç»´æŠ¤æ€§ (Maintainability)](#51-å¯ç»´æŠ¤æ€§-maintainability)
    - [5.2 å¯æµ‹è¯•æ€§ (Testability)](#52-å¯æµ‹è¯•æ€§-testability)
    - [5.3 å¯æ‰©å±•æ€§ (Extensibility)](#53-å¯æ‰©å±•æ€§-extensibility)
  - [ğŸ“Š å¤šç»´å±æ€§é›·è¾¾å›¾](#-å¤šç»´å±æ€§é›·è¾¾å›¾)
    - [åŸºæœ¬ç±»å‹å±æ€§](#åŸºæœ¬ç±»å‹å±æ€§)
    - [æ³›å‹ç±»å‹å±æ€§](#æ³›å‹ç±»å‹å±æ€§)
    - [ç‰¹å¾å¯¹è±¡å±æ€§](#ç‰¹å¾å¯¹è±¡å±æ€§)
  - [ğŸ”¬ å±æ€§å¯¹æ¯”åˆ†æ](#-å±æ€§å¯¹æ¯”åˆ†æ)
    - [é™æ€åˆ†æ´¾ vs åŠ¨æ€åˆ†æ´¾](#é™æ€åˆ†æ´¾-vs-åŠ¨æ€åˆ†æ´¾)
    - [Copy vs Move vs Borrow](#copy-vs-move-vs-borrow)
    - [å…³è”ç±»å‹ vs GATs](#å…³è”ç±»å‹-vs-gats)
  - [ğŸ’¡ å±æ€§åº”ç”¨æŒ‡å—](#-å±æ€§åº”ç”¨æŒ‡å—)
    - [æ ¹æ®å±æ€§é€‰æ‹©ç±»å‹](#æ ¹æ®å±æ€§é€‰æ‹©ç±»å‹)
    - [æ ¹æ®å±æ€§ä¼˜åŒ–è®¾è®¡](#æ ¹æ®å±æ€§ä¼˜åŒ–è®¾è®¡)
  - [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)
    - [Rustæ€§èƒ½](#rustæ€§èƒ½)
    - [ç±»å‹ç³»ç»Ÿ](#ç±»å‹ç³»ç»Ÿ)
    - [å·¥ç¨‹å®è·µ](#å·¥ç¨‹å®è·µ)

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰ Rust ç±»å‹ç³»ç»Ÿä¸­å„ä¸ªæ¦‚å¿µçš„**å¤šç»´å±æ€§ç©ºé—´**ï¼Œæä¾›å®šé‡å’Œå®šæ€§çš„åˆ†ææ¡†æ¶ã€‚

### å±æ€§ç©ºé—´çš„ä½œç”¨

1. **é‡åŒ–è¯„ä¼°**: å¯¹ç±»å‹ç‰¹æ€§è¿›è¡Œé‡åŒ–åˆ†æ
2. **å¯¹æ¯”å†³ç­–**: å¤šç»´åº¦å¯¹æ¯”ä¸åŒè®¾è®¡é€‰æ‹©
3. **ä¼˜åŒ–æŒ‡å¯¼**: åŸºäºå±æ€§è¿›è¡Œæ€§èƒ½ä¼˜åŒ–
4. **æƒè¡¡åˆ†æ**: ç†è§£ä¸åŒé€‰æ‹©çš„æƒè¡¡(trade-offs)

---

## ğŸ¯ å±æ€§ç»´åº¦åˆ†ç±»

```text
å±æ€§ç©ºé—´ (Property Space)
â”œâ”€â”€ ç±»å‹ç»´åº¦
â”‚   â”œâ”€â”€ å¤§å° (Size)
â”‚   â”œâ”€â”€ å¸ƒå±€ (Layout)
â”‚   â””â”€â”€ å¯¹é½ (Alignment)
â”œâ”€â”€ å®‰å…¨ç»´åº¦
â”‚   â”œâ”€â”€ ç±»å‹å®‰å…¨ (Type Safety)
â”‚   â”œâ”€â”€ å†…å­˜å®‰å…¨ (Memory Safety)
â”‚   â””â”€â”€ çº¿ç¨‹å®‰å…¨ (Thread Safety)
â”œâ”€â”€ æ€§èƒ½ç»´åº¦
â”‚   â”œâ”€â”€ ç¼–è¯‘æ—¶æ€§èƒ½ (Compile-time)
â”‚   â”œâ”€â”€ è¿è¡Œæ—¶æ€§èƒ½ (Runtime)
â”‚   â””â”€â”€ å†…å­˜æ€§èƒ½ (Memory)
â”œâ”€â”€ è¡¨è¾¾ç»´åº¦
â”‚   â”œâ”€â”€ æŠ½è±¡èƒ½åŠ› (Abstraction)
â”‚   â”œâ”€â”€ ç»„åˆèƒ½åŠ› (Composition)
â”‚   â””â”€â”€ å¤šæ€èƒ½åŠ› (Polymorphism)
â””â”€â”€ å·¥ç¨‹ç»´åº¦
    â”œâ”€â”€ å¯ç»´æŠ¤æ€§ (Maintainability)
    â”œâ”€â”€ å¯æµ‹è¯•æ€§ (Testability)
    â””â”€â”€ å¯æ‰©å±•æ€§ (Extensibility)
```

---

## 1ï¸âƒ£ ç±»å‹ç»´åº¦ (Type Dimensions)

### 1.1 å¤§å°å±æ€§ (Size Properties)

**å±æ€§å®šä¹‰**:

| å±æ€§ | å®šä¹‰ | åº¦é‡å•ä½ |
|------|------|---------|
| **ç¼–è¯‘æ—¶å¤§å°** | `size_of::<T>()` æ˜¯å¦åœ¨ç¼–è¯‘æ—¶å·²çŸ¥ | Boolean (Sized/!Sized) |
| **å®é™…å¤§å°** | ç±»å‹å ç”¨çš„å­—èŠ‚æ•° | Bytes |
| **å¯¹é½è¦æ±‚** | `align_of::<T>()` | Bytes (power of 2) |

**ç±»å‹åˆ†ç±»**:

| ç±»å‹ | ç¼–è¯‘æ—¶å¤§å° | å®é™…å¤§å°ç¤ºä¾‹ | Sized Trait |
|------|-----------|------------|-------------|
| `i32` | å·²çŸ¥ | 4 bytes | âœ“ |
| `bool` | å·²çŸ¥ | 1 byte | âœ“ |
| `[i32; 5]` | å·²çŸ¥ | 20 bytes | âœ“ |
| `[i32]` | æœªçŸ¥ | è¿è¡Œæ—¶ç¡®å®š | âœ— (DST) |
| `str` | æœªçŸ¥ | è¿è¡Œæ—¶ç¡®å®š | âœ— (DST) |
| `dyn Trait` | æœªçŸ¥ | è¿è¡Œæ—¶ç¡®å®š | âœ— (DST) |
| `()` | å·²çŸ¥ | 0 bytes | âœ“ (ZST) |
| `PhantomData<T>` | å·²çŸ¥ | 0 bytes | âœ“ (ZST) |

**ç¤ºä¾‹åˆ†æ**:

```rust
// å¤§å°å±æ€§ç¤ºä¾‹
use std::mem::{size_of, align_of};

// Sizedç±»å‹
assert_eq!(size_of::<i32>(), 4);
assert_eq!(size_of::<[i32; 5]>(), 20);

// é›¶å¤§å°ç±»å‹ (ZST)
assert_eq!(size_of::<()>(), 0);
assert_eq!(size_of::<PhantomData<i32>>(), 0);

// DST (é€šè¿‡æŒ‡é’ˆè®¿é—®)
let slice: &[i32] = &[1, 2, 3];
assert_eq!(size_of_val(slice), 12);  // 3 * 4 bytes

// èƒ–æŒ‡é’ˆå¤§å°
assert_eq!(size_of::<&[i32]>(), 16);  // æŒ‡é’ˆ + é•¿åº¦
assert_eq!(size_of::<&dyn Display>(), 16);  // æŒ‡é’ˆ + vtable
```

### 1.2 å¸ƒå±€å±æ€§ (Layout Properties)

**å±æ€§å®šä¹‰**:

| å±æ€§ | å®šä¹‰ | å¯èƒ½å€¼ |
|------|------|--------|
| **å†…å­˜å¸ƒå±€** | å­—æ®µåœ¨å†…å­˜ä¸­çš„æ’åˆ—æ–¹å¼ | Rusté»˜è®¤ / `#[repr(C)]` / `#[repr(packed)]` |
| **å¡«å……å­—èŠ‚** | å¯¹é½å¯¼è‡´çš„é¢å¤–å­—èŠ‚ | 0-N bytes |
| **å­—æ®µé¡ºåº** | å­—æ®µåœ¨å†…å­˜ä¸­çš„é¡ºåº | ç¼–è¯‘å™¨ä¼˜åŒ– / å£°æ˜é¡ºåº |

**å¸ƒå±€ç±»å‹**:

```rust
// Rusté»˜è®¤å¸ƒå±€ï¼ˆç¼–è¯‘å™¨å¯ä¼˜åŒ–ï¼‰
struct DefaultLayout {
    a: u8,   // å¯èƒ½è¢«é‡æ’åº
    b: u32,
    c: u16,
}

// #[repr(C)] - Cå…¼å®¹å¸ƒå±€
#[repr(C)]
struct CLayout {
    a: u8,   // å£°æ˜é¡ºåº
    b: u32,  // æœ‰å¡«å……å­—èŠ‚
    c: u16,
}

// #[repr(packed)] - ç´§å‡‘å¸ƒå±€
#[repr(packed)]
struct PackedLayout {
    a: u8,   // æ— å¡«å……å­—èŠ‚
    b: u32,  // å¯èƒ½æœªå¯¹é½
    c: u16,
}

// å¸ƒå±€åˆ†æ
println!("Default: {} bytes", size_of::<DefaultLayout>());
println!("C:       {} bytes", size_of::<CLayout>());
println!("Packed:  {} bytes", size_of::<PackedLayout>());
```

### 1.3 å¯¹é½å±æ€§ (Alignment Properties)

**å±æ€§å®šä¹‰**:

| ç±»å‹ | å¯¹é½è¦æ±‚ | è¯´æ˜ |
|------|---------|------|
| `u8`, `i8`, `bool` | 1 byte | æœ€å°å¯¹é½ |
| `u16`, `i16` | 2 bytes | |
| `u32`, `i32`, `f32` | 4 bytes | |
| `u64`, `i64`, `f64` | 8 bytes | |
| `u128`, `i128` | 16 bytes (å¹³å°ç›¸å…³) | |
| ç»“æ„ä½“ | max(å­—æ®µå¯¹é½) | æœ€å¤§å­—æ®µå¯¹é½ |
| æ•°ç»„ `[T; N]` | `align_of::<T>()` | å…ƒç´ ç±»å‹å¯¹é½ |

**å¯¹é½å½±å“**:

```rust
// å¯¹é½å½±å“å¤§å°
struct Aligned {
    a: u8,    // 1 byte
    // 3 bytes padding
    b: u32,   // 4 bytes
    c: u8,    // 1 byte
    // 3 bytes padding
}
// æ€»å¤§å°: 12 bytes (ä¸æ˜¯ 6 bytes)

// å­—æ®µé‡æ’å¯ä»¥å‡å°‘å¡«å……
struct Optimized {
    b: u32,   // 4 bytes
    a: u8,    // 1 byte
    c: u8,    // 1 byte
    // 2 bytes padding
}
// æ€»å¤§å°: 8 bytes
```

---

## 2ï¸âƒ£ å®‰å…¨ç»´åº¦ (Safety Dimensions)

### 2.1 ç±»å‹å®‰å…¨ (Type Safety)

**å±æ€§é‡åŒ–**:

| ç»´åº¦ | åº¦é‡ | è¯„åˆ† (1-5) |
|------|------|-----------|
| **é™æ€ç±»å‹æ£€æŸ¥** | ç¼–è¯‘æ—¶ç±»å‹éªŒè¯ | 5 (å®Œå…¨) |
| **å¼ºç±»å‹** | æ— éšå¼ç±»å‹è½¬æ¢ | 5 (å®Œå…¨) |
| **ç±»å‹æ¨æ–­** | è‡ªåŠ¨æ¨æ–­ç¨‹åº¦ | 4 (é«˜) |
| **æ³›å‹ç±»å‹å®‰å…¨** | æ³›å‹å‚æ•°æ£€æŸ¥ | 5 (å®Œå…¨) |

**ç±»å‹å®‰å…¨ä¿è¯**:

```rust
// ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
let x: i32 = 5;
// let y: String = x;  // ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…

// æ— éšå¼è½¬æ¢
let a: i32 = 5;
let b: i64 = 10;
// let c = a + b;  // ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…

// æ³›å‹ç±»å‹å®‰å…¨
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}
// add(5, "hello");  // ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
```

### 2.2 å†…å­˜å®‰å…¨ (Memory Safety)

**å±æ€§é‡åŒ–**:

| ç»´åº¦ | æ£€æŸ¥æ—¶æœº | æˆæœ¬ | ä¿è¯ç¨‹åº¦ |
|------|---------|------|---------|
| **æ— æ‚¬å‚æŒ‡é’ˆ** | ç¼–è¯‘æ—¶ | é›¶æˆæœ¬ | 100% |
| **æ— æ•°æ®ç«äº‰** | ç¼–è¯‘æ—¶ | é›¶æˆæœ¬ | 100% |
| **æ— ç¼“å†²åŒºæº¢å‡º** | ç¼–è¯‘æ—¶+è¿è¡Œæ—¶ | è¾¹ç•Œæ£€æŸ¥ | 100% |
| **æ— use-after-free** | ç¼–è¯‘æ—¶ | é›¶æˆæœ¬ | 100% |
| **æ— double-free** | ç¼–è¯‘æ—¶ | é›¶æˆæœ¬ | 100% |

**å†…å­˜å®‰å…¨æœºåˆ¶**:

```rust
// é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ
fn no_dangling() -> &'static str {
    // let s = String::from("hello");
    // &s  // ç¼–è¯‘é”™è¯¯ï¼šè¿”å›å¯¹å±€éƒ¨å˜é‡çš„å¼•ç”¨
    "valid static"
}

// é˜²æ­¢use-after-free
let s = String::from("hello");
drop(s);
// println!("{}", s);  // ç¼–è¯‘é”™è¯¯ï¼šuse after move

// é˜²æ­¢æ•°æ®ç«äº‰
let mut data = vec![1, 2, 3];
// let r1 = &mut data;
// let r2 = &mut data;  // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½æœ‰å¤šä¸ªå¯å˜å¼•ç”¨

// è¾¹ç•Œæ£€æŸ¥
let arr = [1, 2, 3];
// let x = arr[10];  // panic!ï¼ˆè¿è¡Œæ—¶æ£€æŸ¥ï¼‰
```

### 2.3 çº¿ç¨‹å®‰å…¨ (Thread Safety)

**å±æ€§çŸ©é˜µ**:

| ç±»å‹ | Send | Sync | è¯´æ˜ |
|------|------|------|------|
| `i32` | âœ“ | âœ“ | åŸºæœ¬ç±»å‹ |
| `String` | âœ“ | âœ“ | å¯å‘é€å’Œå…±äº« |
| `Rc<T>` | âœ— | âœ— | éçº¿ç¨‹å®‰å…¨å¼•ç”¨è®¡æ•° |
| `Arc<T>` | âœ“ (if T: Send) | âœ“ (if T: Sync) | çº¿ç¨‹å®‰å…¨å¼•ç”¨è®¡æ•° |
| `Cell<T>` | âœ“ (if T: Send) | âœ— | å†…éƒ¨å¯å˜æ€§ï¼ŒéSync |
| `RefCell<T>` | âœ“ (if T: Send) | âœ— | è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥ï¼ŒéSync |
| `Mutex<T>` | âœ“ (if T: Send) | âœ“ (if T: Send) | äº’æ–¥é”ä¿æŠ¤ |
| `RwLock<T>` | âœ“ (if T: Send) | âœ“ (if T: Send + Sync) | è¯»å†™é”ä¿æŠ¤ |

**çº¿ç¨‹å®‰å…¨ç¤ºä¾‹**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// Send + Sync: å¯ä»¥è·¨çº¿ç¨‹ä¼ é€’å’Œå…±äº«
fn thread_safe<T: Send + Sync + 'static>(data: Arc<T>) {
    thread::spawn(move || {
        // å¯ä»¥åœ¨æ–°çº¿ç¨‹ä¸­ä½¿ç”¨
    });
}

// Mutexæä¾›å†…éƒ¨å¯å˜æ€§å’Œçº¿ç¨‹å®‰å…¨
let counter = Arc::new(Mutex::new(0));
let handles: Vec<_> = (0..10)
    .map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        })
    })
    .collect();
```

---

## 3ï¸âƒ£ æ€§èƒ½ç»´åº¦ (Performance Dimensions)

### 3.1 ç¼–è¯‘æ—¶æ€§èƒ½ (Compile-time Performance)

**å±æ€§é‡åŒ–**:

| ç‰¹æ€§ | ç¼–è¯‘æ—¶æˆæœ¬ | å½±å“å› ç´  |
|------|-----------|---------|
| **æ³›å‹å•æ€åŒ–** | é«˜ | æ³›å‹å®ä¾‹æ•°é‡ |
| **ç±»å‹æ¨æ–­** | ä¸­ | ç±»å‹çº¦æŸå¤æ‚åº¦ |
| **å®å±•å¼€** | é«˜ | å®å¤æ‚åº¦ |
| **å€Ÿç”¨æ£€æŸ¥** | ä¸­-é«˜ | å¼•ç”¨å¤æ‚åº¦ |
| **LLVMä¼˜åŒ–** | é«˜ | ä¼˜åŒ–çº§åˆ« |

**ç¼–è¯‘æ—¶æˆæœ¬å¯¹æ¯”**:

```rust
// ä½ç¼–è¯‘æˆæœ¬ï¼šå…·ä½“ç±»å‹
fn add_i32(a: i32, b: i32) -> i32 {
    a + b
}

// é«˜ç¼–è¯‘æˆæœ¬ï¼šæ³›å‹ï¼ˆæ¯ä¸ªå®ä¾‹åŒ–éƒ½ç¼–è¯‘ä¸€æ¬¡ï¼‰
fn add_generic<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}
// add_generic(1i32, 2i32);    // ç¼–è¯‘ i32 ç‰ˆæœ¬
// add_generic(1.0f64, 2.0f64); // ç¼–è¯‘ f64 ç‰ˆæœ¬
// ... æ¯ä¸ªç±»å‹ä¸€ä¸ªç‰ˆæœ¬

// æ›´é«˜ç¼–è¯‘æˆæœ¬ï¼šå¤æ‚æ³›å‹çº¦æŸ
fn complex<T, U, V>(t: T, u: U) -> V
where
    T: Clone + Debug + Send + Sync,
    U: Into<V> + Display,
    V: From<U> + Default,
{
    u.into()
}
```

### 3.2 è¿è¡Œæ—¶æ€§èƒ½ (Runtime Performance)

**æ€§èƒ½å¯¹æ¯”è¡¨**:

| ç‰¹æ€§ | è¿è¡Œæ—¶æˆæœ¬ | é›¶æˆæœ¬æŠ½è±¡ | è¯´æ˜ |
|------|-----------|-----------|------|
| **æ³›å‹ï¼ˆé™æ€åˆ†æ´¾ï¼‰** | æ—  | âœ“ | å•æ€åŒ–ï¼Œå†…è”ä¼˜åŒ– |
| **ç‰¹å¾å¯¹è±¡ï¼ˆåŠ¨æ€åˆ†æ´¾ï¼‰** | è™šè¡¨æŸ¥æ‰¾ | âœ— | è¿è¡Œæ—¶å¤šæ€ |
| **å€Ÿç”¨æ£€æŸ¥** | æ—  | âœ“ | ç¼–è¯‘æ—¶æ£€æŸ¥ |
| **Option/Result** | æ—  | âœ“ | ç¼–è¯‘å™¨ä¼˜åŒ– |
| **è¿­ä»£å™¨** | æ—  | âœ“ | è¿­ä»£å™¨èåˆ |
| **æ™ºèƒ½æŒ‡é’ˆ** | å¼•ç”¨è®¡æ•° | éƒ¨åˆ† | Boxæ— æˆæœ¬ï¼ŒRc/Arcæœ‰æˆæœ¬ |

**é›¶æˆæœ¬æŠ½è±¡ç¤ºä¾‹**:

```rust
// é™æ€åˆ†æ´¾ï¼šé›¶æˆæœ¬
fn process<T: Display>(value: T) {
    println!("{}", value);
}
// ç¼–è¯‘åä¸ç›´æ¥è°ƒç”¨ç›¸åŒ

// åŠ¨æ€åˆ†æ´¾ï¼šæœ‰è¿è¡Œæ—¶æˆæœ¬
fn process_dyn(value: &dyn Display) {
    println!("{}", value);  // è™šè¡¨æŸ¥æ‰¾
}

// è¿­ä»£å™¨ï¼šé›¶æˆæœ¬æŠ½è±¡
let sum: i32 = (1..100)
    .filter(|x| x % 2 == 0)
    .map(|x| x * 2)
    .sum();
// ç¼–è¯‘åä¸æ‰‹å†™å¾ªç¯æ€§èƒ½ç›¸åŒ

// æ‰‹å†™ç­‰ä»·ä»£ç 
let mut sum = 0;
for x in 1..100 {
    if x % 2 == 0 {
        sum += x * 2;
    }
}
```

### 3.3 å†…å­˜æ€§èƒ½ (Memory Performance)

**å†…å­˜å±æ€§**:

| ç±»å‹ | æ ˆåˆ†é… | å †åˆ†é… | å†…å­˜å¼€é”€ | ç¼“å­˜å‹å¥½æ€§ |
|------|-------|-------|---------|----------|
| `i32` | âœ“ | âœ— | 4 bytes | é«˜ |
| `[i32; 100]` | âœ“ | âœ— | 400 bytes | é«˜ |
| `Vec<i32>` | éƒ¨åˆ† | âœ“ | 24 + capacity * 4 bytes | ä¸­ |
| `Box<i32>` | æŒ‡é’ˆ | âœ“ | 8 + 4 bytes | ä½ |
| `Rc<i32>` | æŒ‡é’ˆ | âœ“ | 8 + 4 + 8 bytes (å¼•ç”¨è®¡æ•°) | ä½ |
| `Arc<i32>` | æŒ‡é’ˆ | âœ“ | 8 + 4 + 16 bytes (åŸå­è®¡æ•°) | ä½ |

**å†…å­˜å¸ƒå±€ä¼˜åŒ–**:

```rust
// æ ˆåˆ†é…ï¼šé«˜æ€§èƒ½
fn stack_allocation() {
    let x = [0; 1000];  // æ ˆåˆ†é…
    // å¿«é€Ÿï¼Œä½†æ ˆç©ºé—´æœ‰é™
}

// å †åˆ†é…ï¼šçµæ´»ä½†è¾ƒæ…¢
fn heap_allocation() {
    let x = vec![0; 1000000];  // å †åˆ†é…
    // æ…¢ä½†å¯ä»¥åˆ†é…å¤§ç©ºé—´
}

// å†…è”æ•°ç»„ vs Vec
struct InlineArray {
    data: [i32; 100],  // 400 bytes æ ˆ
}

struct HeapVector {
    data: Vec<i32>,  // 24 bytes æ ˆ + å †
}
```

---

## 4ï¸âƒ£ è¡¨è¾¾ç»´åº¦ (Expressiveness Dimensions)

### 4.1 æŠ½è±¡èƒ½åŠ› (Abstraction Capability)

**æŠ½è±¡å±‚æ¬¡**:

| æŠ½è±¡æœºåˆ¶ | æŠ½è±¡èƒ½åŠ› | æ€§èƒ½æˆæœ¬ | ç±»å‹å®‰å…¨ |
|---------|---------|---------|---------|
| **å‡½æ•°** | åŸºç¡€ | æ— ï¼ˆå†…è”ï¼‰ | å®Œå…¨ |
| **æ³›å‹** | é«˜ | æ— ï¼ˆå•æ€åŒ–ï¼‰ | å®Œå…¨ |
| **ç‰¹å¾** | é«˜ | æ— ï¼ˆé™æ€åˆ†æ´¾ï¼‰ | å®Œå…¨ |
| **ç‰¹å¾å¯¹è±¡** | é«˜ | è™šè¡¨æŸ¥æ‰¾ | å®Œå…¨ |
| **GATs** | å¾ˆé«˜ | æ— ï¼ˆå•æ€åŒ–ï¼‰ | å®Œå…¨ |
| **å®** | æœ€é«˜ | ç¼–è¯‘æ—¶ | æœ‰é™ |

**æŠ½è±¡èƒ½åŠ›ç¤ºä¾‹**:

```rust
// ä½æŠ½è±¡ï¼šå…·ä½“ç±»å‹
fn add_i32(a: i32, b: i32) -> i32 {
    a + b
}

// ä¸­æŠ½è±¡ï¼šæ³›å‹
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// é«˜æŠ½è±¡ï¼šç‰¹å¾
trait Addable {
    type Output;
    fn add(self, other: Self) -> Self::Output;
}

// å¾ˆé«˜æŠ½è±¡ï¼šGATs
trait Container {
    type Item<'a> where Self: 'a;
    fn get<'a>(&'a self) -> Option<Self::Item<'a>>;
}
```

### 4.2 ç»„åˆèƒ½åŠ› (Composition Capability)

**ç»„åˆæ¨¡å¼**:

| æ¨¡å¼ | ç»„åˆæ–¹å¼ | çµæ´»æ€§ | ç¤ºä¾‹ |
|------|---------|-------|------|
| **ç»“æ„ä½“ç»„åˆ** | å­—æ®µç»„åˆ | ä½ | `struct Point { x: f64, y: f64 }` |
| **æšä¸¾ç»„åˆ** | å˜ä½“ç»„åˆ | ä¸­ | `enum Option<T> { Some(T), None }` |
| **ç‰¹å¾ç»„åˆ** | ç‰¹å¾è¾¹ç•Œ | é«˜ | `T: Display + Clone` |
| **é«˜é˜¶ç±»å‹** | ç±»å‹æ„é€ å™¨ | å¾ˆé«˜ | `F: Fn(T) -> U` |

**ç»„åˆç¤ºä¾‹**:

```rust
// ç‰¹å¾ç»„åˆ
fn process<T: Display + Clone + Send>(value: T) {
    // T ç»„åˆäº†ä¸‰ä¸ªç‰¹å¾çš„èƒ½åŠ›
}

// ç±»å‹ç»„åˆ
struct Composite<T, U> {
    first: T,
    second: U,
}

// å®ç°ç»„åˆ
impl<T: Display, U: Display> Display for Composite<T, U> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "({}, {})", self.first, self.second)
    }
}
```

### 4.3 å¤šæ€èƒ½åŠ› (Polymorphism Capability)

**å¤šæ€ç±»å‹**:

| å¤šæ€ç±»å‹ | å®ç°æ–¹å¼ | æ€§èƒ½ | çµæ´»æ€§ |
|---------|---------|------|-------|
| **å‚æ•°å¤šæ€** | æ³›å‹ | é«˜ï¼ˆå•æ€åŒ–ï¼‰ | é«˜ |
| **Ad-hocå¤šæ€** | ç‰¹å¾é‡è½½ | é«˜ï¼ˆé™æ€åˆ†æ´¾ï¼‰ | é«˜ |
| **å­ç±»å‹å¤šæ€** | ç‰¹å¾å¯¹è±¡ | ä¸­ï¼ˆè™šè¡¨ï¼‰ | å¾ˆé«˜ |
| **è¡Œå¤šæ€** | ç»“æ„ä½“ | é«˜ | ä¸­ |

**å¤šæ€ç¤ºä¾‹**:

```rust
// å‚æ•°å¤šæ€
fn identity<T>(x: T) -> T { x }

// Ad-hocå¤šæ€ï¼ˆç‰¹å¾é‡è½½ï¼‰
trait Display {
    fn display(&self) -> String;
}
impl Display for i32 { /* ... */ }
impl Display for String { /* ... */ }

// å­ç±»å‹å¤šæ€ï¼ˆç‰¹å¾å¯¹è±¡ï¼‰
let shapes: Vec<Box<dyn Draw>> = vec![
    Box::new(Circle),
    Box::new(Square),
];
```

---

## 5ï¸âƒ£ å·¥ç¨‹ç»´åº¦ (Engineering Dimensions)

### 5.1 å¯ç»´æŠ¤æ€§ (Maintainability)

**å¯ç»´æŠ¤æ€§æŒ‡æ ‡**:

| ç»´åº¦ | åº¦é‡ | å½±å“å› ç´  |
|------|------|---------|
| **å¯è¯»æ€§** | ä»£ç æ¸…æ™°åº¦ | ç±»å‹æ ‡æ³¨ã€å‘½åã€æ–‡æ¡£ |
| **å¯ä¿®æ”¹æ€§** | ä¿®æ”¹éš¾åº¦ | è€¦åˆåº¦ã€æŠ½è±¡å±‚æ¬¡ |
| **å¯ç†è§£æ€§** | ç†è§£å¤æ‚åº¦ | ç±»å‹å¤æ‚åº¦ã€æ³›å‹åµŒå¥— |

**å¯ç»´æŠ¤æ€§å¯¹æ¯”**:

```rust
// é«˜å¯ç»´æŠ¤æ€§ï¼šæ¸…æ™°çš„ç±»å‹å’Œæ¥å£
struct User {
    name: String,
    email: String,
}

impl User {
    fn new(name: String, email: String) -> Self {
        User { name, email }
    }
    
    fn display(&self) -> String {
        format!("{} <{}>", self.name, self.email)
    }
}

// ä½å¯ç»´æŠ¤æ€§ï¼šå¤æ‚çš„æ³›å‹åµŒå¥—
type Complex<'a, T, U, F> = 
    Box<dyn Fn(&'a T) -> Result<U, Box<dyn Error>> + F>;
```

### 5.2 å¯æµ‹è¯•æ€§ (Testability)

**å¯æµ‹è¯•æ€§å±æ€§**:

| ç‰¹æ€§ | å¯æµ‹è¯•æ€§ | æµ‹è¯•ç­–ç•¥ |
|------|---------|---------|
| **æ³›å‹å‡½æ•°** | é«˜ | å¤šç§ç±»å‹æµ‹è¯• |
| **ç‰¹å¾** | å¾ˆé«˜ | Mockå®ç° |
| **çº¯å‡½æ•°** | æœ€é«˜ | å•å…ƒæµ‹è¯• |
| **å‰¯ä½œç”¨å‡½æ•°** | ä½ | é›†æˆæµ‹è¯• |

**å¯æµ‹è¯•è®¾è®¡**:

```rust
// é«˜å¯æµ‹è¯•æ€§ï¼šç‰¹å¾æŠ½è±¡
trait DataStore {
    fn get(&self, key: &str) -> Option<String>;
    fn set(&mut self, key: &str, value: String);
}

struct RealStore { /* ... */ }
impl DataStore for RealStore { /* ... */ }

// æµ‹è¯•ç”¨Mock
struct MockStore {
    data: HashMap<String, String>,
}
impl DataStore for MockStore { /* ... */ }

// å¯ä»¥ç”¨Mockè½»æ¾æµ‹è¯•
fn process_data<S: DataStore>(store: &mut S) {
    store.set("key", "value".to_string());
}

#[test]
fn test_process() {
    let mut mock = MockStore::new();
    process_data(&mut mock);
    assert_eq!(mock.get("key"), Some("value".to_string()));
}
```

### 5.3 å¯æ‰©å±•æ€§ (Extensibility)

**å¯æ‰©å±•æ€§æ¨¡å¼**:

| æ¨¡å¼ | æ‰©å±•æ–¹å¼ | çµæ´»æ€§ | ä¾µå…¥æ€§ |
|------|---------|-------|-------|
| **ç‰¹å¾æ‰©å±•** | ä¸ºç±»å‹å®ç°æ–°ç‰¹å¾ | é«˜ | æ—  |
| **æ³›å‹å‚æ•°** | æ·»åŠ ç±»å‹å‚æ•° | ä¸­ | ä¸­ |
| **å…³è”ç±»å‹** | æ‰©å±•ç‰¹å¾å®šä¹‰ | é«˜ | ä½ |
| **æšä¸¾å˜ä½“** | æ·»åŠ æ–°å˜ä½“ | ä½ | é«˜ï¼ˆç ´åæ€§ï¼‰ |

**å¯æ‰©å±•è®¾è®¡**:

```rust
// å¯æ‰©å±•ï¼šç‰¹å¾ç³»ç»Ÿ
trait Drawable {
    fn draw(&self);
}

// å¯ä»¥ä¸ºä»»ä½•ç±»å‹å®ç°Drawableï¼Œæ— éœ€ä¿®æ”¹åŸç±»å‹
struct Circle;
impl Drawable for Circle {
    fn draw(&self) { println!("Drawing circle"); }
}

struct Square;
impl Drawable for Square {
    fn draw(&self) { println!("Drawing square"); }
}

// å¯æ‰©å±•ï¼šæ³›å‹å®¹å™¨
struct Container<T> {
    items: Vec<T>,
}

impl<T> Container<T> {
    fn new() -> Self {
        Container { items: Vec::new() }
    }
    
    fn add(&mut self, item: T) {
        self.items.push(item);
    }
}

// å¯ä»¥é€šè¿‡ç‰¹å¾æ‰©å±•åŠŸèƒ½ï¼Œæ— éœ€ä¿®æ”¹Container
trait Filterable<T> {
    fn filter<F: Fn(&T) -> bool>(&self, predicate: F) -> Vec<&T>;
}

impl<T> Filterable<T> for Container<T> {
    fn filter<F: Fn(&T) -> bool>(&self, predicate: F) -> Vec<&T> {
        self.items.iter().filter(|item| predicate(item)).collect()
    }
}
```

---

## ğŸ“Š å¤šç»´å±æ€§é›·è¾¾å›¾

### åŸºæœ¬ç±»å‹å±æ€§

```text
åŸºæœ¬ç±»å‹ (i32, f64, bool, char)

         ç±»å‹å®‰å…¨ 5
              |
        4.5  / \  4
           /     \
      ç¼–è¯‘ /       \ è¿è¡Œ
      æ€§èƒ½ 5-------5 æ€§èƒ½
           \       /
            \     /
             \   /
         0.5  \ /  0
        å¤æ‚åº¦ 1 å†…å­˜å ç”¨ 0.5
```

**å±æ€§è¯„åˆ†**:

- ç±»å‹å®‰å…¨: 5/5 (å®Œå…¨é™æ€æ£€æŸ¥)
- å†…å­˜å®‰å…¨: 5/5 (æ— æŒ‡é’ˆï¼ŒCopyè¯­ä¹‰)
- ç¼–è¯‘æ€§èƒ½: 5/5 (ç®€å•ç±»å‹)
- è¿è¡Œæ€§èƒ½: 5/5 (ç›´æ¥æ“ä½œ)
- å†…å­˜å ç”¨: 5/5 (å›ºå®šå°å°ºå¯¸)
- è¡¨è¾¾èƒ½åŠ›: 2/5 (å…·ä½“ç±»å‹)
- å¯ç»´æŠ¤æ€§: 5/5 (ç®€å•ç›´è§‚)
- å¤æ‚åº¦: 1/5 (æç®€å•)

### æ³›å‹ç±»å‹å±æ€§

```text
æ³›å‹ç±»å‹ (Vec<T>, Option<T>)

         ç±»å‹å®‰å…¨ 5
              |
        3    / \  4.5
           /     \
      ç¼–è¯‘ /       \ è¿è¡Œ
      æ€§èƒ½ 3-------5 æ€§èƒ½
           \       /
            \     /
             \   /
         3   \ /  3
        å¤æ‚åº¦ 3 è¡¨è¾¾èƒ½åŠ› 5
```

**å±æ€§è¯„åˆ†**:

- ç±»å‹å®‰å…¨: 5/5 (æ³›å‹å‚æ•°æ£€æŸ¥)
- ç¼–è¯‘æ€§èƒ½: 3/5 (å•æ€åŒ–æˆæœ¬)
- è¿è¡Œæ€§èƒ½: 5/5 (é›¶æˆæœ¬æŠ½è±¡)
- è¡¨è¾¾èƒ½åŠ›: 5/5 (é«˜åº¦æŠ½è±¡)
- å¤æ‚åº¦: 3/5 (ä¸­ç­‰å¤æ‚)
- å¯ç»´æŠ¤æ€§: 4/5 (æ¸…æ™°çš„æŠ½è±¡)

### ç‰¹å¾å¯¹è±¡å±æ€§

```text
ç‰¹å¾å¯¹è±¡ (Box<dyn Trait>)

         ç±»å‹å®‰å…¨ 5
              |
        2    / \  3
           /     \
      ç¼–è¯‘ /       \ è¿è¡Œ
      æ€§èƒ½ 4-------3 æ€§èƒ½
           \       /
            \     /
             \   /
         4   \ /  5
        çµæ´»æ€§ 5 å¤æ‚åº¦ 4
```

**å±æ€§è¯„åˆ†**:

- ç±»å‹å®‰å…¨: 5/5 (ç±»å‹æ“¦é™¤ä½†å®‰å…¨)
- ç¼–è¯‘æ€§èƒ½: 4/5 (æ— å•æ€åŒ–)
- è¿è¡Œæ€§èƒ½: 3/5 (è™šè¡¨æŸ¥æ‰¾)
- çµæ´»æ€§: 5/5 (åŠ¨æ€åˆ†æ´¾)
- å¤æ‚åº¦: 4/5 (å¯¹è±¡å®‰å…¨è§„åˆ™)
- è¡¨è¾¾èƒ½åŠ›: 5/5 (è¿è¡Œæ—¶å¤šæ€)

---

## ğŸ”¬ å±æ€§å¯¹æ¯”åˆ†æ

### é™æ€åˆ†æ´¾ vs åŠ¨æ€åˆ†æ´¾

| å±æ€§ç»´åº¦ | é™æ€åˆ†æ´¾ (æ³›å‹) | åŠ¨æ€åˆ†æ´¾ (trait object) |
|---------|---------------|----------------------|
| **ç¼–è¯‘æ—¶é—´** | æ…¢ï¼ˆå•æ€åŒ–ï¼‰ | å¿«ï¼ˆæ— å•æ€åŒ–ï¼‰ |
| **äºŒè¿›åˆ¶å¤§å°** | å¤§ï¼ˆæ¯ä¸ªç±»å‹ä¸€ä»½ä»£ç ï¼‰ | å°ï¼ˆå…±äº«ä»£ç ï¼‰ |
| **è¿è¡Œæ—¶æ€§èƒ½** | å¿«ï¼ˆç›´æ¥è°ƒç”¨+å†…è”ï¼‰ | æ…¢ï¼ˆè™šè¡¨æŸ¥æ‰¾ï¼‰ |
| **å†…å­˜å ç”¨** | æ­£å¸¸æŒ‡é’ˆï¼ˆ8 bytesï¼‰ | èƒ–æŒ‡é’ˆï¼ˆ16 bytesï¼‰ |
| **çµæ´»æ€§** | ç¼–è¯‘æ—¶ç¡®å®š | è¿è¡Œæ—¶ç¡®å®š |
| **ç±»å‹æ“¦é™¤** | å¦ | æ˜¯ |

**é€‰æ‹©æŒ‡å—**:

```rust
// ä½¿ç”¨é™æ€åˆ†æ´¾ï¼ˆæ³›å‹ï¼‰å½“ï¼š
// - æ€§èƒ½å…³é”®
// - ç±»å‹åœ¨ç¼–è¯‘æ—¶å·²çŸ¥
// - éœ€è¦å†…è”ä¼˜åŒ–
fn process<T: Display>(value: T) {
    println!("{}", value);
}

// ä½¿ç”¨åŠ¨æ€åˆ†æ´¾ï¼ˆç‰¹å¾å¯¹è±¡ï¼‰å½“ï¼š
// - éœ€è¦è¿è¡Œæ—¶å¤šæ€
// - å‡å°äºŒè¿›åˆ¶å¤§å°
// - éœ€è¦å­˜å‚¨ä¸åŒç±»å‹
let shapes: Vec<Box<dyn Draw>> = vec![
    Box::new(Circle),
    Box::new(Square),
];
```

### Copy vs Move vs Borrow

| ç»´åº¦ | Copy | Move | Borrow |
|------|------|------|--------|
| **æ‰€æœ‰æƒ** | å¤åˆ¶æ‰€æœ‰æƒ | è½¬ç§»æ‰€æœ‰æƒ | ä¸´æ—¶å€Ÿç”¨ |
| **æ€§èƒ½** | å¿«ï¼ˆå°ç±»å‹ï¼‰ | é›¶æˆæœ¬ | é›¶æˆæœ¬ |
| **å†…å­˜** | å¤åˆ¶æ•°æ® | æ— å¤åˆ¶ | æ— å¤åˆ¶ |
| **ä½¿ç”¨ååŸå€¼** | ä»å¯ç”¨ | ä¸å¯ç”¨ | å¯ç”¨ï¼ˆå€Ÿç”¨ç»“æŸåï¼‰ |
| **é€‚ç”¨ç±»å‹** | åŸºæœ¬ç±»å‹ã€å°ç»“æ„ä½“ | æ‰€æœ‰éCopyç±»å‹ | æ‰€æœ‰ç±»å‹ |
| **ç”Ÿå‘½å‘¨æœŸ** | æ— å…³ | æ— å…³ | æœ‰çº¦æŸ |

**é€‰æ‹©æŒ‡å—**:

```rust
// Copy: å°å‹ã€ç®€å•ç±»å‹
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

// Move: æ‹¥æœ‰å †æ•°æ®çš„ç±»å‹
let s1 = String::from("hello");
let s2 = s1;  // s1 moved

// Borrow: ä¸´æ—¶è®¿é—®
fn print(s: &String) {  // å€Ÿç”¨
    println!("{}", s);
}
let s = String::from("hello");
print(&s);  // s ä»å¯ç”¨
```

### å…³è”ç±»å‹ vs GATs

| ç»´åº¦ | Associated Types | GATs (Generic Associated Types) |
|------|-----------------|--------------------------------|
| **å‚æ•°åŒ–** | æ— å‚æ•° | å¸¦ç±»å‹/ç”Ÿå‘½å‘¨æœŸå‚æ•° |
| **è¡¨è¾¾èƒ½åŠ›** | ä¸­ | é«˜ |
| **å¤æ‚åº¦** | ä½ | é«˜ |
| **ç¼–è¯‘æ”¯æŒ** | Rust 1.0+ | Rust 1.65+ |
| **ä½¿ç”¨åœºæ™¯** | ç®€å•å…³è” | é«˜é˜¶ç±»å‹ã€Lending Iterator |

**å¯¹æ¯”ç¤ºä¾‹**:

```rust
// å…³è”ç±»å‹ï¼šç®€å•ä½†æœ‰é™
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// GATsï¼šå¤æ‚ä½†å¼ºå¤§
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// GATså¯ä»¥è¡¨è¾¾å€Ÿç”¨è¿­ä»£å™¨
impl LendingIterator for VecDeque<String> {
    type Item<'a> = &'a String;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        self.front()
    }
}
```

---

## ğŸ’¡ å±æ€§åº”ç”¨æŒ‡å—

### æ ¹æ®å±æ€§é€‰æ‹©ç±»å‹

**æ€§èƒ½ä¼˜å…ˆ**:

```rust
// ä½¿ç”¨æ ˆåˆ†é…ã€Copyç±»å‹
struct FastPoint {
    x: i32,
    y: i32,
}

// ä½¿ç”¨æ•°ç»„è€ŒéVecï¼ˆå·²çŸ¥å¤§å°æ—¶ï¼‰
let data: [i32; 100] = [0; 100];

// ä½¿ç”¨é™æ€åˆ†æ´¾è€ŒéåŠ¨æ€åˆ†æ´¾
fn process<T: Display>(value: T) { /* ... */ }
```

**çµæ´»æ€§ä¼˜å…ˆ**:

```rust
// ä½¿ç”¨ç‰¹å¾å¯¹è±¡å®ç°è¿è¡Œæ—¶å¤šæ€
let plugins: Vec<Box<dyn Plugin>> = vec![
    Box::new(PluginA),
    Box::new(PluginB),
];

// ä½¿ç”¨æšä¸¾å®ç°å°é—­çš„å˜ä½“
enum Message {
    Text(String),
    Image(Vec<u8>),
    Video { url: String, duration: u32 },
}
```

**å®‰å…¨æ€§ä¼˜å…ˆ**:

```rust
// ä½¿ç”¨æ‰€æœ‰æƒé¿å…ç”Ÿå‘½å‘¨æœŸé—®é¢˜
struct Owner {
    data: String,  // æ‹¥æœ‰æ•°æ®
}

// ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†å…±äº«
use std::sync::Arc;
let shared = Arc::new(expensive_data);
```

### æ ¹æ®å±æ€§ä¼˜åŒ–è®¾è®¡

**ç¼–è¯‘æ—¶ä¼˜åŒ–**:

```rust
// ä½¿ç”¨constæ³›å‹é¿å…è¿è¡Œæ—¶æ£€æŸ¥
struct Buffer<const N: usize> {
    data: [u8; N],
}

// ä½¿ç”¨é›¶å¤§å°ç±»å‹ä½œä¸ºæ ‡è®°
struct Initialized;
struct Uninitialized;

struct State<S> {
    _marker: PhantomData<S>,
}
```

**è¿è¡Œæ—¶ä¼˜åŒ–**:

```rust
// ä½¿ç”¨å†…è”ä¼˜åŒ–å°å‡½æ•°
#[inline(always)]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// ä½¿ç”¨è¿­ä»£å™¨è€Œéæ‰‹å†™å¾ªç¯
let sum: i32 = data.iter().filter(|&&x| x > 0).sum();
```

**å†…å­˜ä¼˜åŒ–**:

```rust
// å­—æ®µé‡æ’å‡å°‘å¡«å……
struct Optimized {
    large: u64,   // 8 bytes
    medium: u32,  // 4 bytes
    small: u8,    // 1 byte
    tiny: bool,   // 1 byte
}  // 16 bytes (vs 24 if not ordered)

// ä½¿ç”¨Cowé¿å…ä¸å¿…è¦çš„å…‹éš†
use std::borrow::Cow;
fn process(s: Cow<str>) {
    // åªåœ¨éœ€è¦æ—¶å…‹éš†
}
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

### Rustæ€§èƒ½

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Rust Compiler Performance](https://doc.rust-lang.org/nightly/cargo/reference/profiles.html)

### ç±»å‹ç³»ç»Ÿ

- [Rust Reference - Type System](https://doc.rust-lang.org/reference/types.html)
- [Rust Nomicon - Exotic Sizes](https://doc.rust-lang.org/nomicon/exotic-sizes.html)

### å·¥ç¨‹å®è·µ

- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)

---

**æ–‡æ¡£ç»´æŠ¤**: Rust å­¦ä¹ ç¤¾åŒº  
**æ›´æ–°é¢‘ç‡**: è·ŸéšRustç‰ˆæœ¬æ›´æ–°  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**Rust ç‰ˆæœ¬**: 1.90+  
**æœ€åæ›´æ–°**: 2025-10-19
