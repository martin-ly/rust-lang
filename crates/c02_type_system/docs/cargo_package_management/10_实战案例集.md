# Cargo 实战案例集

## 📋 目录

- [Cargo 实战案例集](#cargo-实战案例集)
  - [📋 目录](#-目录)
  - [🎯 案例概览](#-案例概览)
  - [案例 1: 简单 CLI 工具](#案例-1-简单-cli-工具)
    - [项目需求](#项目需求)
    - [项目结构](#项目结构)
    - [实现步骤](#实现步骤)
    - [关键代码](#关键代码)
    - [运行和测试](#运行和测试)
  - [案例 2: 可复用的库](#案例-2-可复用的库)
    - [项目需求2](#项目需求2)
    - [项目结构2](#项目结构2)
    - [实现步骤2](#实现步骤2)
    - [关键代码2](#关键代码2)
    - [测试和发布](#测试和发布)
  - [案例 3: Web API 服务](#案例-3-web-api-服务)
    - [项目需求3](#项目需求3)
    - [项目结构3](#项目结构3)
    - [实现步骤3](#实现步骤3)
    - [关键代码3](#关键代码3)
    - [部署](#部署)
  - [案例 4: 多包工作空间](#案例-4-多包工作空间)
    - [项目需求4](#项目需求4)
    - [工作空间结构4](#工作空间结构4)
    - [实现步骤4](#实现步骤4)
    - [关键配置](#关键配置)
    - [开发工作流](#开发工作流)
  - [案例 5: 系统工具库（no\_std）](#案例-5-系统工具库no_std)
    - [项目需求5](#项目需求5)
    - [项目结构5](#项目结构5)
    - [实现步骤5](#实现步骤5)
    - [关键代码5](#关键代码5)
  - [案例 6: 插件系统](#案例-6-插件系统)
    - [项目需求6](#项目需求6)
    - [项目结构6](#项目结构6)
    - [实现步骤6](#实现步骤6)
    - [关键代码6](#关键代码6)
  - [📚 案例对比](#-案例对比)
  - [💡 经验总结](#-经验总结)
    - [通用建议](#通用建议)
    - [特定建议](#特定建议)
  - [🔗 参考资源](#-参考资源)
    - [示例项目](#示例项目)
    - [学习资源](#学习资源)

---

## 🎯 案例概览

本文档包含 6 个真实场景的完整实战案例：

| 案例 | 类型 | 难度 | 关键技术 |
|------|------|------|---------|
| 1. CLI 工具 | 二进制 | ⭐ | 命令行解析 |
| 2. 可复用库 | 库 | ⭐⭐ | 特性系统、文档 |
| 3. Web API | 二进制 | ⭐⭐⭐ | 异步、数据库 |
| 4. 工作空间 | 混合 | ⭐⭐⭐ | 多包管理 |
| 5. no_std 库 | 库 | ⭐⭐⭐⭐ | 嵌入式 |
| 6. 插件系统 | 混合 | ⭐⭐⭐⭐⭐ | 动态加载、FFI |

---

## 案例 1: 简单 CLI 工具

### 项目需求

创建一个简单的文件搜索工具 `filesearch`，支持：

- 在目录中搜索文件
- 支持正则表达式
- 输出格式化结果

### 项目结构

```text
filesearch/
├── Cargo.toml
├── README.md
├── src/
│   ├── main.rs              # 主入口
│   ├── lib.rs               # 库代码
│   ├── config.rs            # 配置
│   └── search.rs            # 搜索逻辑
├── tests/
│   └── integration_test.rs
└── examples/
    └── basic_search.rs
```

### 实现步骤

**步骤 1: 创建项目**:

```bash
cargo new filesearch
cd filesearch
```

**步骤 2: 配置 Cargo.toml**:

```toml
[package]
name = "filesearch"
version = "0.1.0"
edition = "2024"
authors = ["Your Name <you@example.com>"]
description = "A simple file search tool"
license = "MIT"
repository = "https://github.com/username/filesearch"

[[bin]]
name = "filesearch"
path = "src/main.rs"

[dependencies]
clap = { version = "4.5", features = ["derive"] }
regex = "1.10"
walkdir = "2.5"
colored = "2.1"

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.1"
tempfile = "3.10"
```

### 关键代码

**src/lib.rs**:

```rust
//! File search library

use regex::Regex;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Search configuration
pub struct SearchConfig {
    pub pattern: Regex,
    pub directory: PathBuf,
    pub max_depth: Option<usize>,
}

impl SearchConfig {
    pub fn new(pattern: &str, directory: impl AsRef<Path>) -> Result<Self, regex::Error> {
        Ok(Self {
            pattern: Regex::new(pattern)?,
            directory: directory.as_ref().to_path_buf(),
            max_depth: None,
        })
    }
}

/// Search results
#[derive(Debug, Clone)]
pub struct SearchResult {
    pub path: PathBuf,
    pub matches: Vec<String>,
}

/// Perform file search
pub fn search(config: &SearchConfig) -> Vec<SearchResult> {
    let walker = if let Some(depth) = config.max_depth {
        WalkDir::new(&config.directory).max_depth(depth)
    } else {
        WalkDir::new(&config.directory)
    };

    walker
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
        .filter_map(|entry| {
            let path = entry.path();
            if config.pattern.is_match(&path.to_string_lossy()) {
                Some(SearchResult {
                    path: path.to_path_buf(),
                    matches: vec![path.to_string_lossy().to_string()],
                })
            } else {
                None
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_search_config() {
        let config = SearchConfig::new(r"\.rs$", ".").unwrap();
        assert_eq!(config.directory, PathBuf::from("."));
    }
}
```

**src/main.rs**:

```rust
use clap::Parser;
use colored::*;
use filesearch::{search, SearchConfig};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "filesearch")]
#[command(about = "Search files by pattern", long_about = None)]
struct Cli {
    /// Search pattern (regex)
    pattern: String,

    /// Directory to search
    #[arg(short, long, default_value = ".")]
    directory: PathBuf,

    /// Maximum search depth
    #[arg(short, long)]
    max_depth: Option<usize>,

    /// Show verbose output
    #[arg(short, long)]
    verbose: bool,
}

fn main() {
    let cli = Cli::parse();

    let mut config = match SearchConfig::new(&cli.pattern, &cli.directory) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("{}: {}", "Error".red().bold(), e);
            std::process::exit(1);
        }
    };

    config.max_depth = cli.max_depth;

    if cli.verbose {
        println!(
            "{} {} in {}",
            "Searching for".green(),
            cli.pattern.yellow(),
            cli.directory.display()
        );
    }

    let results = search(&config);

    if results.is_empty() {
        println!("{}", "No files found".yellow());
    } else {
        println!("{} {} files:", "Found".green().bold(), results.len());
        for result in results {
            println!("  {}", result.path.display().to_string().cyan());
        }
    }
}
```

### 运行和测试

```bash
# 构建
cargo build --release

# 运行
cargo run -- "\.rs$"
cargo run -- "test" --directory ./tests

# 测试
cargo test

# 安装到系统
cargo install --path .
```

---

## 案例 2: 可复用的库

### 项目需求2

创建一个数据序列化库 `datacodec`，支持：

- 多种序列化格式（JSON、YAML）
- 可选特性
- 完整文档

### 项目结构2

```text
datacodec/
├── Cargo.toml
├── README.md
├── CHANGELOG.md
├── LICENSE
├── src/
│   ├── lib.rs
│   ├── json.rs              # JSON 支持
│   ├── yaml.rs              # YAML 支持
│   └── error.rs             # 错误类型
├── tests/
│   ├── json_tests.rs
│   └── yaml_tests.rs
├── benches/
│   └── codec_bench.rs
└── examples/
    ├── json_example.rs
    └── yaml_example.rs
```

### 实现步骤2

**步骤 1: 配置 Cargo.toml**:

```toml
[package]
name = "datacodec"
version = "0.1.0"
edition = "2024"
rust-version = "1.90"
authors = ["Your Name <you@example.com>"]
description = "A flexible data serialization library"
documentation = "https://docs.rs/datacodec"
repository = "https://github.com/username/datacodec"
license = "MIT OR Apache-2.0"
keywords = ["serialization", "json", "yaml", "codec"]
categories = ["encoding", "data-structures"]

[features]
default = ["std"]
std = []
json = ["dep:serde_json"]
yaml = ["dep:serde_yaml"]
full = ["json", "yaml"]

[dependencies]
serde = { version = "1.0", default-features = false, features = ["derive"] }
serde_json = { version = "1.0", optional = true }
serde_yaml = { version = "0.9", optional = true }

[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "codec_bench"
harness = false

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]
```

### 关键代码2

**src/lib.rs**:

```rust
#![doc = include_str!("../README.md")]
#![cfg_attr(docsrs, feature(doc_cfg))]
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "std")]
extern crate std;

use serde::{Deserialize, Serialize};

pub mod error;

#[cfg(feature = "json")]
#[cfg_attr(docsrs, doc(cfg(feature = "json")))]
pub mod json;

#[cfg(feature = "yaml")]
#[cfg_attr(docsrs, doc(cfg(feature = "yaml")))]
pub mod yaml;

/// Codec trait for serialization/deserialization
pub trait Codec {
    /// Encode data to bytes
    fn encode<T: Serialize>(&self, data: &T) -> Result<Vec<u8>, error::CodecError>;

    /// Decode data from bytes
    fn decode<'a, T: Deserialize<'a>>(&self, bytes: &'a [u8]) -> Result<T, error::CodecError>;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic() {
        // 基础测试
    }
}
```

**src/json.rs**:

```rust
//! JSON codec implementation

use crate::{Codec, error::CodecError};
use serde::{Deserialize, Serialize};

/// JSON codec
pub struct JsonCodec;

impl Codec for JsonCodec {
    fn encode<T: Serialize>(&self, data: &T) -> Result<Vec<u8>, CodecError> {
        serde_json::to_vec(data).map_err(CodecError::from)
    }

    fn decode<'a, T: Deserialize<'a>>(&self, bytes: &'a [u8]) -> Result<T, CodecError> {
        serde_json::from_slice(bytes).map_err(CodecError::from)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_json_encode_decode() {
        let codec = JsonCodec;
        let data = vec![1, 2, 3];
        let encoded = codec.encode(&data).unwrap();
        let decoded: Vec<i32> = codec.decode(&encoded).unwrap();
        assert_eq!(data, decoded);
    }
}
```

### 测试和发布

```bash
# 测试所有特性组合
cargo test --no-default-features
cargo test --features json
cargo test --features yaml
cargo test --all-features

# 生成文档
cargo doc --all-features --open

# 基准测试
cargo bench

# 发布前检查
cargo publish --dry-run

# 发布
cargo publish
```

---

## 案例 3: Web API 服务

### 项目需求3

创建一个 RESTful API 服务 `todoapi`，支持：

- CRUD 操作
- 数据库持久化
- 异步处理

### 项目结构3

```text
todoapi/
├── Cargo.toml
├── .env.example
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── config.rs
│   ├── models/
│   │   ├── mod.rs
│   │   └── todo.rs
│   ├── handlers/
│   │   ├── mod.rs
│   │   └── todo.rs
│   ├── db/
│   │   ├── mod.rs
│   │   └── pool.rs
│   └── routes.rs
├── migrations/
│   └── 001_create_todos.sql
└── tests/
    └── api_tests.rs
```

### 实现步骤3

**Cargo.toml**:

```toml
[package]
name = "todoapi"
version = "0.1.0"
edition = "2024"

[dependencies]
# Web framework
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["trace", "cors"] }

# Async runtime
tokio = { version = "1.48", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Database
sqlx = { version = "0.7", features = ["runtime-tokio", "sqlite", "migrate"] }

# Configuration
dotenvy = "0.15"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Error handling
anyhow = "1.0"
thiserror = "1.0"

[dev-dependencies]
reqwest = { version = "0.11", features = ["json"] }
```

### 关键代码3

**src/models/todo.rs**:

```rust
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Todo {
    pub id: i64,
    pub title: String,
    pub completed: bool,
}

#[derive(Debug, Deserialize)]
pub struct CreateTodo {
    pub title: String,
}

#[derive(Debug, Deserialize)]
pub struct UpdateTodo {
    pub title: Option<String>,
    pub completed: Option<bool>,
}
```

**src/handlers/todo.rs**:

```rust
use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use sqlx::SqlitePool;

use crate::models::todo::{CreateTodo, Todo, UpdateTodo};

pub async fn list_todos(
    State(pool): State<SqlitePool>,
) -> Result<Json<Vec<Todo>>, StatusCode> {
    let todos = sqlx::query_as::<_, Todo>("SELECT * FROM todos")
        .fetch_all(&pool)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(todos))
}

pub async fn create_todo(
    State(pool): State<SqlitePool>,
    Json(payload): Json<CreateTodo>,
) -> Result<(StatusCode, Json<Todo>), StatusCode> {
    let todo = sqlx::query_as::<_, Todo>(
        "INSERT INTO todos (title, completed) VALUES (?, false) RETURNING *"
    )
    .bind(&payload.title)
    .fetch_one(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok((StatusCode::CREATED, Json(todo)))
}

// ... 更多处理函数
```

**src/main.rs**:

```rust
use axum::{
    routing::{get, post},
    Router,
};
use sqlx::sqlite::SqlitePoolOptions;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod config;
mod handlers;
mod models;
mod routes;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 初始化日志
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "todoapi=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // 加载配置
    dotenvy::dotenv().ok();

    // 数据库连接
    let database_url = std::env::var("DATABASE_URL")?;
    let pool = SqlitePoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    // 运行迁移
    sqlx::migrate!("./migrations").run(&pool).await?;

    // 构建路由
    let app = Router::new()
        .route("/todos", get(handlers::todo::list_todos))
        .route("/todos", post(handlers::todo::create_todo))
        .layer(TraceLayer::new_for_http())
        .with_state(pool);

    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    tracing::info!("listening on {}", listener.local_addr()?);
    axum::serve(listener, app).await?;

    Ok(())
}
```

### 部署

```bash
# 开发环境
cargo run

# 生产构建
cargo build --release

# Docker 部署
docker build -t todoapi .
docker run -p 3000:3000 todoapi
```

---

## 案例 4: 多包工作空间

### 项目需求4

创建一个完整的应用系统，包含：

- 共享的数据模型库
- 后端 API 服务
- CLI 工具

### 工作空间结构4

```text
my-project/
├── Cargo.toml              # 工作空间清单
├── Cargo.lock
├── common/                 # 共享库
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
├── server/                 # 后端服务
│   ├── Cargo.toml
│   └── src/
│       └── main.rs
├── cli/                    # CLI 工具
│   ├── Cargo.toml
│   └── src/
│       └── main.rs
└── tests/                  # 集成测试
    └── integration_test.rs
```

### 实现步骤4

**根 Cargo.toml**:

```toml
[workspace]
members = [
    "common",
    "server",
    "cli",
]
resolver = "3"

[workspace.package]
version = "0.1.0"
edition = "2024"
rust-version = "1.90"
authors = ["Your Name"]
license = "MIT"

[workspace.dependencies]
# 共享依赖
tokio = { version = "1.48", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
tracing = "0.1"

# 内部依赖
common = { path = "./common" }
```

### 关键配置

**common/Cargo.toml**:

```toml
[package]
name = "common"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
serde.workspace = true
serde_json.workspace = true
```

**server/Cargo.toml**:

```toml
[package]
name = "server"
version.workspace = true
edition.workspace = true

[dependencies]
common.workspace = true
tokio.workspace = true
axum = "0.7"
```

**cli/Cargo.toml**:

```toml
[package]
name = "cli"
version.workspace = true
edition.workspace = true

[dependencies]
common.workspace = true
clap = { version = "4.5", features = ["derive"] }
```

### 开发工作流

```bash
# 构建整个工作空间
cargo build --workspace

# 测试整个工作空间
cargo test --workspace

# 运行特定包
cargo run -p server
cargo run -p cli -- --help

# 发布顺序
cargo publish -p common
cargo publish -p server
cargo publish -p cli
```

---

## 案例 5: 系统工具库（no_std）

### 项目需求5

创建一个嵌入式/系统级的工具库 `sysutil`，支持：

- no_std 环境
- 可选 std 支持
- 核心工具函数

### 项目结构5

```text
sysutil/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── math.rs             # 数学工具
│   └── buffer.rs           # 缓冲区管理
└── tests/
    └── std_tests.rs        # std 环境测试
```

### 实现步骤5

**Cargo.toml**:

```toml
[package]
name = "sysutil"
version = "0.1.0"
edition = "2024"

[features]
default = ["std"]
std = []
alloc = []

[dependencies]
# no_std 兼容的依赖

[dev-dependencies]
# 测试依赖（需要 std）
```

### 关键代码5

**src/lib.rs**:

```rust
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "alloc")]
extern crate alloc;

#[cfg(feature = "std")]
extern crate std;

pub mod math;
pub mod buffer;

#[cfg(all(test, feature = "std"))]
mod tests {
    #[test]
    fn test_basic() {
        assert_eq!(2 + 2, 4);
    }
}
```

**src/math.rs**:

```rust
//! Math utilities for no_std environments

/// Calculate power without std
pub const fn pow(base: u32, exp: u32) -> u32 {
    let mut result = 1;
    let mut i = 0;
    while i < exp {
        result *= base;
        i += 1;
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pow() {
        assert_eq!(pow(2, 3), 8);
        assert_eq!(pow(10, 2), 100);
    }
}
```

---

## 案例 6: 插件系统

### 项目需求6

创建一个支持动态插件加载的系统：

- 插件 API 定义
- 插件加载器
- 示例插件

### 项目结构6

```text
plugin-system/
├── Cargo.toml              # 工作空间
├── plugin-api/             # 插件 API
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
├── plugin-loader/          # 加载器
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
├── example-plugin/         # 示例插件
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
└── host/                   # 主程序
    ├── Cargo.toml
    └── src/
        └── main.rs
```

### 实现步骤6

**plugin-api/src/lib.rs**:

```rust
//! Plugin API definition

use std::any::Any;

/// Plugin trait that all plugins must implement
pub trait Plugin: Send + Sync {
    /// Plugin name
    fn name(&self) -> &str;

    /// Plugin version
    fn version(&self) -> &str;

    /// Initialize plugin
    fn init(&mut self) -> Result<(), Box<dyn std::error::Error>>;

    /// Execute plugin
    fn execute(&self, input: &dyn Any) -> Result<Box<dyn Any>, Box<dyn std::error::Error>>;
}

/// Plugin constructor type
pub type PluginConstructor = fn() -> Box<dyn Plugin>;

#[macro_export]
macro_rules! declare_plugin {
    ($plugin_type:ty, $constructor:path) => {
        #[no_mangle]
        pub extern "C" fn _plugin_create() -> *mut dyn $crate::Plugin {
            let constructor: fn() -> Box<dyn $crate::Plugin> = $constructor;
            let object = constructor();
            Box::into_raw(object)
        }
    };
}
```

### 关键代码6

**example-plugin/src/lib.rs**:

```rust
use plugin_api::{declare_plugin, Plugin};
use std::any::Any;

pub struct ExamplePlugin {
    name: String,
}

impl Plugin for ExamplePlugin {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        "0.1.0"
    }

    fn init(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("Initializing {}", self.name);
        Ok(())
    }

    fn execute(&self, _input: &dyn Any) -> Result<Box<dyn Any>, Box<dyn std::error::Error>> {
        println!("Executing {}", self.name);
        Ok(Box::new(()))
    }
}

fn constructor() -> Box<dyn Plugin> {
    Box::new(ExamplePlugin {
        name: "Example Plugin".to_string(),
    })
}

declare_plugin!(Plugin, constructor);
```

---

## 📚 案例对比

| 特性 | CLI 工具 | 库 | Web API | 工作空间 | no_std | 插件 |
|------|---------|-----|---------|----------|--------|------|
| 复杂度 | ⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 依赖数 | 少 | 中 | 多 | 多 | 极少 | 中 |
| 异步 | 否 | 可选 | 是 | 混合 | 否 | 可选 |
| 测试 | 简单 | 重要 | 复杂 | 分层 | 特殊 | 复杂 |
| 文档 | 基础 | 完整 | API | 分散 | 详细 | 完整 |

---

## 💡 经验总结

### 通用建议

1. **从简单开始**: 先实现核心功能，再添加特性
2. **测试优先**: 编写测试保证代码质量
3. **文档同步**: 代码和文档同步更新
4. **持续集成**: 使用 CI/CD 自动化流程

### 特定建议

**CLI 工具**:

- 使用 `clap` 简化参数解析
- 提供友好的错误消息
- 添加 `--help` 和 `--version`

**库开发**:

- 设计清晰的 API
- 提供完整的文档和示例
- 使用特性系统支持可选功能

**Web 服务**:

- 使用异步运行时
- 实现适当的错误处理
- 添加日志和监控

**工作空间**:

- 合理划分包的职责
- 使用工作空间继承
- 统一版本管理

---

## 🔗 参考资源

### 示例项目

- [ripgrep](https://github.com/BurntSushi/ripgrep) - CLI 工具
- [serde](https://github.com/serde-rs/serde) - 库
- [axum](https://github.com/tokio-rs/axum) - Web 框架
- [tokio](https://github.com/tokio-rs/tokio) - 工作空间

### 学习资源

- [Rust By Example](https://doc.rust-lang.org/rust-by-example/)
- [The Cargo Book](https://doc.rust-lang.org/cargo/)
- [Awesome Rust](https://github.com/rust-unofficial/awesome-rust)

---

**文档版本**: 1.0
**最后更新**: 2025-10-19
**适用版本**: Rust 1.90+

*实践是最好的老师。* 🦀💼
