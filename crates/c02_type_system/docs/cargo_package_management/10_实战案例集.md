# Cargo å®æˆ˜æ¡ˆä¾‹é›†

## ğŸ“‹ ç›®å½•

- [Cargo å®æˆ˜æ¡ˆä¾‹é›†](#cargo-å®æˆ˜æ¡ˆä¾‹é›†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¡ˆä¾‹æ¦‚è§ˆ](#-æ¡ˆä¾‹æ¦‚è§ˆ)
  - [æ¡ˆä¾‹ 1: ç®€å• CLI å·¥å…·](#æ¡ˆä¾‹-1-ç®€å•-cli-å·¥å…·)
    - [é¡¹ç›®éœ€æ±‚](#é¡¹ç›®éœ€æ±‚)
    - [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
    - [å®ç°æ­¥éª¤](#å®ç°æ­¥éª¤)
    - [å…³é”®ä»£ç ](#å…³é”®ä»£ç )
    - [è¿è¡Œå’Œæµ‹è¯•](#è¿è¡Œå’Œæµ‹è¯•)
  - [æ¡ˆä¾‹ 2: å¯å¤ç”¨çš„åº“](#æ¡ˆä¾‹-2-å¯å¤ç”¨çš„åº“)
    - [é¡¹ç›®éœ€æ±‚2](#é¡¹ç›®éœ€æ±‚2)
    - [é¡¹ç›®ç»“æ„2](#é¡¹ç›®ç»“æ„2)
    - [å®ç°æ­¥éª¤2](#å®ç°æ­¥éª¤2)
    - [å…³é”®ä»£ç 2](#å…³é”®ä»£ç 2)
    - [æµ‹è¯•å’Œå‘å¸ƒ](#æµ‹è¯•å’Œå‘å¸ƒ)
  - [æ¡ˆä¾‹ 3: Web API æœåŠ¡](#æ¡ˆä¾‹-3-web-api-æœåŠ¡)
    - [é¡¹ç›®éœ€æ±‚3](#é¡¹ç›®éœ€æ±‚3)
    - [é¡¹ç›®ç»“æ„3](#é¡¹ç›®ç»“æ„3)
    - [å®ç°æ­¥éª¤3](#å®ç°æ­¥éª¤3)
    - [å…³é”®ä»£ç 3](#å…³é”®ä»£ç 3)
    - [éƒ¨ç½²](#éƒ¨ç½²)
  - [æ¡ˆä¾‹ 4: å¤šåŒ…å·¥ä½œç©ºé—´](#æ¡ˆä¾‹-4-å¤šåŒ…å·¥ä½œç©ºé—´)
    - [é¡¹ç›®éœ€æ±‚4](#é¡¹ç›®éœ€æ±‚4)
    - [å·¥ä½œç©ºé—´ç»“æ„4](#å·¥ä½œç©ºé—´ç»“æ„4)
    - [å®ç°æ­¥éª¤4](#å®ç°æ­¥éª¤4)
    - [å…³é”®é…ç½®](#å…³é”®é…ç½®)
    - [å¼€å‘å·¥ä½œæµ](#å¼€å‘å·¥ä½œæµ)
  - [æ¡ˆä¾‹ 5: ç³»ç»Ÿå·¥å…·åº“ï¼ˆno\_stdï¼‰](#æ¡ˆä¾‹-5-ç³»ç»Ÿå·¥å…·åº“no_std)
    - [é¡¹ç›®éœ€æ±‚5](#é¡¹ç›®éœ€æ±‚5)
    - [é¡¹ç›®ç»“æ„5](#é¡¹ç›®ç»“æ„5)
    - [å®ç°æ­¥éª¤5](#å®ç°æ­¥éª¤5)
    - [å…³é”®ä»£ç 5](#å…³é”®ä»£ç 5)
  - [æ¡ˆä¾‹ 6: æ’ä»¶ç³»ç»Ÿ](#æ¡ˆä¾‹-6-æ’ä»¶ç³»ç»Ÿ)
    - [é¡¹ç›®éœ€æ±‚6](#é¡¹ç›®éœ€æ±‚6)
    - [é¡¹ç›®ç»“æ„6](#é¡¹ç›®ç»“æ„6)
    - [å®ç°æ­¥éª¤6](#å®ç°æ­¥éª¤6)
    - [å…³é”®ä»£ç 6](#å…³é”®ä»£ç 6)
  - [ğŸ“š æ¡ˆä¾‹å¯¹æ¯”](#-æ¡ˆä¾‹å¯¹æ¯”)
  - [ğŸ’¡ ç»éªŒæ€»ç»“](#-ç»éªŒæ€»ç»“)
    - [é€šç”¨å»ºè®®](#é€šç”¨å»ºè®®)
    - [ç‰¹å®šå»ºè®®](#ç‰¹å®šå»ºè®®)
  - [ğŸ”— å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [ç¤ºä¾‹é¡¹ç›®](#ç¤ºä¾‹é¡¹ç›®)
    - [å­¦ä¹ èµ„æº](#å­¦ä¹ èµ„æº)

---

## ğŸ¯ æ¡ˆä¾‹æ¦‚è§ˆ

æœ¬æ–‡æ¡£åŒ…å« 6 ä¸ªçœŸå®åœºæ™¯çš„å®Œæ•´å®æˆ˜æ¡ˆä¾‹ï¼š

| æ¡ˆä¾‹ | ç±»å‹ | éš¾åº¦ | å…³é”®æŠ€æœ¯ |
| --- | --- | --- | --- |
| 1. CLI å·¥å…· | äºŒè¿›åˆ¶ | â­ | å‘½ä»¤è¡Œè§£æ |
| 2. å¯å¤ç”¨åº“ | åº“ | â­â­ | ç‰¹æ€§ç³»ç»Ÿã€æ–‡æ¡£ |
| 3. Web API | äºŒè¿›åˆ¶ | â­â­â­ | å¼‚æ­¥ã€æ•°æ®åº“ |
| 4. å·¥ä½œç©ºé—´ | æ··åˆ | â­â­â­ | å¤šåŒ…ç®¡ç† |
| 5. no_std åº“ | åº“ | â­â­â­â­ | åµŒå…¥å¼ |
| 6. æ’ä»¶ç³»ç»Ÿ | æ··åˆ | â­â­â­â­â­ | åŠ¨æ€åŠ è½½ã€FFI |

---

## æ¡ˆä¾‹ 1: ç®€å• CLI å·¥å…·

### é¡¹ç›®éœ€æ±‚

åˆ›å»ºä¸€ä¸ªç®€å•çš„æ–‡ä»¶æœç´¢å·¥å…· `filesearch`ï¼Œæ”¯æŒï¼š

- åœ¨ç›®å½•ä¸­æœç´¢æ–‡ä»¶
- æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼
- è¾“å‡ºæ ¼å¼åŒ–ç»“æœ

### é¡¹ç›®ç»“æ„

```text
filesearch/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # ä¸»å…¥å£
â”‚   â”œâ”€â”€ lib.rs               # åº“ä»£ç 
â”‚   â”œâ”€â”€ config.rs            # é…ç½®
â”‚   â””â”€â”€ search.rs            # æœç´¢é€»è¾‘
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration_test.rs
â””â”€â”€ examples/
    â””â”€â”€ basic_search.rs
```

### å®ç°æ­¥éª¤

**æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®**:

```bash
cargo new filesearch
cd filesearch
```

**æ­¥éª¤ 2: é…ç½® Cargo.toml**:

```toml
[package]
name = "filesearch"
version = "0.1.0"
edition = "2024"
authors = ["Your Name <you@example.com>"]
description = "A simple file search tool"
license = "MIT"
repository = "https://github.com/username/filesearch"

[[bin]]
name = "filesearch"
path = "src/main.rs"

[dependencies]
clap = { version = "4.5", features = ["derive"] }
regex = "1.10"
walkdir = "2.5"
colored = "2.1"

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.1"
tempfile = "3.10"
```

### å…³é”®ä»£ç 

**src/lib.rs**:

```rust
//! File search library

use regex::Regex;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

/// Search configuration
pub struct SearchConfig {
    pub pattern: Regex,
    pub directory: PathBuf,
    pub max_depth: Option<usize>,
}

impl SearchConfig {
    pub fn new(pattern: &str, directory: impl AsRef<Path>) -> Result<Self, regex::Error> {
        Ok(Self {
            pattern: Regex::new(pattern)?,
            directory: directory.as_ref().to_path_buf(),
            max_depth: None,
        })
    }
}

/// Search results
#[derive(Debug, Clone)]
pub struct SearchResult {
    pub path: PathBuf,
    pub matches: Vec<String>,
}

/// Perform file search
pub fn search(config: &SearchConfig) -> Vec<SearchResult> {
    let walker = if let Some(depth) = config.max_depth {
        WalkDir::new(&config.directory).max_depth(depth)
    } else {
        WalkDir::new(&config.directory)
    };

    walker
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
        .filter_map(|entry| {
            let path = entry.path();
            if config.pattern.is_match(&path.to_string_lossy()) {
                Some(SearchResult {
                    path: path.to_path_buf(),
                    matches: vec![path.to_string_lossy().to_string()],
                })
            } else {
                None
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_search_config() {
        let config = SearchConfig::new(r"\.rs$", ".").unwrap();
        assert_eq!(config.directory, PathBuf::from("."));
    }
}
```

**src/main.rs**:

```rust
use clap::Parser;
use colored::*;
use filesearch::{search, SearchConfig};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "filesearch")]
#[command(about = "Search files by pattern", long_about = None)]
struct Cli {
    /// Search pattern (regex)
    pattern: String,

    /// Directory to search
    #[arg(short, long, default_value = ".")]
    directory: PathBuf,

    /// Maximum search depth
    #[arg(short, long)]
    max_depth: Option<usize>,

    /// Show verbose output
    #[arg(short, long)]
    verbose: bool,
}

fn main() {
    let cli = Cli::parse();

    let mut config = match SearchConfig::new(&cli.pattern, &cli.directory) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("{}: {}", "Error".red().bold(), e);
            std::process::exit(1);
        }
    };

    config.max_depth = cli.max_depth;

    if cli.verbose {
        println!(
            "{} {} in {}",
            "Searching for".green(),
            cli.pattern.yellow(),
            cli.directory.display()
        );
    }

    let results = search(&config);

    if results.is_empty() {
        println!("{}", "No files found".yellow());
    } else {
        println!("{} {} files:", "Found".green().bold(), results.len());
        for result in results {
            println!("  {}", result.path.display().to_string().cyan());
        }
    }
}
```

### è¿è¡Œå’Œæµ‹è¯•

```bash
# æ„å»º
cargo build --release

# è¿è¡Œ
cargo run -- "\.rs$"
cargo run -- "test" --directory ./tests

# æµ‹è¯•
cargo test

# å®‰è£…åˆ°ç³»ç»Ÿ
cargo install --path .
```

---

## æ¡ˆä¾‹ 2: å¯å¤ç”¨çš„åº“

### é¡¹ç›®éœ€æ±‚2

åˆ›å»ºä¸€ä¸ªæ•°æ®åºåˆ—åŒ–åº“ `datacodec`ï¼Œæ”¯æŒï¼š

- å¤šç§åºåˆ—åŒ–æ ¼å¼ï¼ˆJSONã€YAMLï¼‰
- å¯é€‰ç‰¹æ€§
- å®Œæ•´æ–‡æ¡£

### é¡¹ç›®ç»“æ„2

```text
datacodec/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ CHANGELOG.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ json.rs              # JSON æ”¯æŒ
â”‚   â”œâ”€â”€ yaml.rs              # YAML æ”¯æŒ
â”‚   â””â”€â”€ error.rs             # é”™è¯¯ç±»å‹
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ json_tests.rs
â”‚   â””â”€â”€ yaml_tests.rs
â”œâ”€â”€ benches/
â”‚   â””â”€â”€ codec_bench.rs
â””â”€â”€ examples/
    â”œâ”€â”€ json_example.rs
    â””â”€â”€ yaml_example.rs
```

### å®ç°æ­¥éª¤2

**æ­¥éª¤ 1: é…ç½® Cargo.toml**:

```toml
[package]
name = "datacodec"
version = "0.1.0"
edition = "2024"
rust-version = "1.93"
authors = ["Your Name <you@example.com>"]
description = "A flexible data serialization library"
documentation = "https://docs.rs/datacodec"
repository = "https://github.com/username/datacodec"
license = "MIT OR Apache-2.0"
keywords = ["serialization", "json", "yaml", "codec"]
categories = ["encoding", "data-structures"]

[features]
default = ["std"]
std = []
json = ["dep:serde_json"]
yaml = ["dep:serde_yaml"]
full = ["json", "yaml"]

[dependencies]
serde = { version = "1.0", default-features = false, features = ["derive"] }
serde_json = { version = "1.0", optional = true }
serde_yaml = { version = "0.9", optional = true }

[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "codec_bench"
harness = false

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]
```

### å…³é”®ä»£ç 2

**src/lib.rs**:

```rust
#![doc = include_str!("../README.md")]
#![cfg_attr(docsrs, feature(doc_cfg))]
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "std")]
extern crate std;

use serde::{Deserialize, Serialize};

pub mod error;

#[cfg(feature = "json")]
#[cfg_attr(docsrs, doc(cfg(feature = "json")))]
pub mod json;

#[cfg(feature = "yaml")]
#[cfg_attr(docsrs, doc(cfg(feature = "yaml")))]
pub mod yaml;

/// Codec trait for serialization/deserialization
pub trait Codec {
    /// Encode data to bytes
    fn encode<T: Serialize>(&self, data: &T) -> Result<Vec<u8>, error::CodecError>;

    /// Decode data from bytes
    fn decode<'a, T: Deserialize<'a>>(&self, bytes: &'a [u8]) -> Result<T, error::CodecError>;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic() {
        // åŸºç¡€æµ‹è¯•
    }
}
```

**src/json.rs**:

```rust
//! JSON codec implementation

use crate::{Codec, error::CodecError};
use serde::{Deserialize, Serialize};

/// JSON codec
pub struct JsonCodec;

impl Codec for JsonCodec {
    fn encode<T: Serialize>(&self, data: &T) -> Result<Vec<u8>, CodecError> {
        serde_json::to_vec(data).map_err(CodecError::from)
    }

    fn decode<'a, T: Deserialize<'a>>(&self, bytes: &'a [u8]) -> Result<T, CodecError> {
        serde_json::from_slice(bytes).map_err(CodecError::from)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_json_encode_decode() {
        let codec = JsonCodec;
        let data = vec![1, 2, 3];
        let encoded = codec.encode(&data).unwrap();
        let decoded: Vec<i32> = codec.decode(&encoded).unwrap();
        assert_eq!(data, decoded);
    }
}
```

### æµ‹è¯•å’Œå‘å¸ƒ

```bash
# æµ‹è¯•æ‰€æœ‰ç‰¹æ€§ç»„åˆ
cargo test --no-default-features
cargo test --features json
cargo test --features yaml
cargo test --all-features

# ç”Ÿæˆæ–‡æ¡£
cargo doc --all-features --open

# åŸºå‡†æµ‹è¯•
cargo bench

# å‘å¸ƒå‰æ£€æŸ¥
cargo publish --dry-run

# å‘å¸ƒ
cargo publish
```

---

## æ¡ˆä¾‹ 3: Web API æœåŠ¡

### é¡¹ç›®éœ€æ±‚3

åˆ›å»ºä¸€ä¸ª RESTful API æœåŠ¡ `todoapi`ï¼Œæ”¯æŒï¼š

- CRUD æ“ä½œ
- æ•°æ®åº“æŒä¹…åŒ–
- å¼‚æ­¥å¤„ç†

### é¡¹ç›®ç»“æ„3

```text
todoapi/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ .env.example
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ config.rs
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ todo.rs
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ todo.rs
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ pool.rs
â”‚   â””â”€â”€ routes.rs
â”œâ”€â”€ migrations/
â”‚   â””â”€â”€ 001_create_todos.sql
â””â”€â”€ tests/
    â””â”€â”€ api_tests.rs
```

### å®ç°æ­¥éª¤3

**Cargo.toml**:

```toml
[package]
name = "todoapi"
version = "0.1.0"
edition = "2024"

[dependencies]
# Web framework
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["trace", "cors"] }

# Async runtime
tokio = { version = "1.48", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Database
sqlx = { version = "0.7", features = ["runtime-tokio", "sqlite", "migrate"] }

# Configuration
dotenvy = "0.15"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Error handling
anyhow = "1.0"
thiserror = "1.0"

[dev-dependencies]
reqwest = { version = "0.11", features = ["json"] }
```

### å…³é”®ä»£ç 3

**src/models/todo.rs**:

```rust
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Todo {
    pub id: i64,
    pub title: String,
    pub completed: bool,
}

#[derive(Debug, Deserialize)]
pub struct CreateTodo {
    pub title: String,
}

#[derive(Debug, Deserialize)]
pub struct UpdateTodo {
    pub title: Option<String>,
    pub completed: Option<bool>,
}
```

**src/handlers/todo.rs**:

```rust
use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use sqlx::SqlitePool;

use crate::models::todo::{CreateTodo, Todo, UpdateTodo};

pub async fn list_todos(
    State(pool): State<SqlitePool>,
) -> Result<Json<Vec<Todo>>, StatusCode> {
    let todos = sqlx::query_as::<_, Todo>("SELECT * FROM todos")
        .fetch_all(&pool)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(todos))
}

pub async fn create_todo(
    State(pool): State<SqlitePool>,
    Json(payload): Json<CreateTodo>,
) -> Result<(StatusCode, Json<Todo>), StatusCode> {
    let todo = sqlx::query_as::<_, Todo>(
        "INSERT INTO todos (title, completed) VALUES (?, false) RETURNING *"
    )
    .bind(&payload.title)
    .fetch_one(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok((StatusCode::CREATED, Json(todo)))
}

// ... æ›´å¤šå¤„ç†å‡½æ•°
```

**src/main.rs**:

```rust
use axum::{
    routing::{get, post},
    Router,
};
use sqlx::sqlite::SqlitePoolOptions;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod config;
mod handlers;
mod models;
mod routes;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "todoapi=debug,tower_http=debug".into()),
        ))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // åŠ è½½é…ç½®
    dotenvy::dotenv().ok();

    // æ•°æ®åº“è¿æ¥
    let database_url = std::env::var("DATABASE_URL")?;
    let pool = SqlitePoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    // è¿è¡Œè¿ç§»
    sqlx::migrate!("./migrations").run(&pool).await?;

    // æ„å»ºè·¯ç”±
    let app = Router::new()
        .route("/todos", get(handlers::todo::list_todos))
        .route("/todos", post(handlers::todo::create_todo))
        .layer(TraceLayer::new_for_http())
        .with_state(pool);

    // å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    tracing::info!("listening on {}", listener.local_addr()?);
    axum::serve(listener, app).await?;

    Ok(())
}
```

### éƒ¨ç½²

```bash
# å¼€å‘ç¯å¢ƒ
cargo run

# ç”Ÿäº§æ„å»º
cargo build --release

# Docker éƒ¨ç½²
docker build -t todoapi .
docker run -p 3000:3000 todoapi
```

---

## æ¡ˆä¾‹ 4: å¤šåŒ…å·¥ä½œç©ºé—´

### é¡¹ç›®éœ€æ±‚4

åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„åº”ç”¨ç³»ç»Ÿï¼ŒåŒ…å«ï¼š

- å…±äº«çš„æ•°æ®æ¨¡å‹åº“
- åç«¯ API æœåŠ¡
- CLI å·¥å…·

### å·¥ä½œç©ºé—´ç»“æ„4

```text
my-project/
â”œâ”€â”€ Cargo.toml              # å·¥ä½œç©ºé—´æ¸…å•
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ common/                 # å…±äº«åº“
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ server/                 # åç«¯æœåŠ¡
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ main.rs
â”œâ”€â”€ cli/                    # CLI å·¥å…·
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ main.rs
â””â”€â”€ tests/                  # é›†æˆæµ‹è¯•
    â””â”€â”€ integration_test.rs
```

### å®ç°æ­¥éª¤4

**æ ¹ Cargo.toml**:

```toml
[workspace]
members = [
    "common",
    "server",
    "cli",
]
resolver = "3"

[workspace.package]
version = "0.1.0"
edition = "2024"
rust-version = "1.93"
authors = ["Your Name"]
license = "MIT"

[workspace.dependencies]
# å…±äº«ä¾èµ–
tokio = { version = "1.48", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
tracing = "0.1"

# å†…éƒ¨ä¾èµ–
common = { path = "./common" }
```

### å…³é”®é…ç½®

**common/Cargo.toml**:

```toml
[package]
name = "common"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
serde.workspace = true
serde_json.workspace = true
```

**server/Cargo.toml**:

```toml
[package]
name = "server"
version.workspace = true
edition.workspace = true

[dependencies]
common.workspace = true
tokio.workspace = true
axum = "0.7"
```

**cli/Cargo.toml**:

```toml
[package]
name = "cli"
version.workspace = true
edition.workspace = true

[dependencies]
common.workspace = true
clap = { version = "4.5", features = ["derive"] }
```

### å¼€å‘å·¥ä½œæµ

```bash
# æ„å»ºæ•´ä¸ªå·¥ä½œç©ºé—´
cargo build --workspace

# æµ‹è¯•æ•´ä¸ªå·¥ä½œç©ºé—´
cargo test --workspace

# è¿è¡Œç‰¹å®šåŒ…
cargo run -p server
cargo run -p cli -- --help

# å‘å¸ƒé¡ºåº
cargo publish -p common
cargo publish -p server
cargo publish -p cli
```

---

## æ¡ˆä¾‹ 5: ç³»ç»Ÿå·¥å…·åº“ï¼ˆno_stdï¼‰

### é¡¹ç›®éœ€æ±‚5

åˆ›å»ºä¸€ä¸ªåµŒå…¥å¼/ç³»ç»Ÿçº§çš„å·¥å…·åº“ `sysutil`ï¼Œæ”¯æŒï¼š

- no_std ç¯å¢ƒ
- å¯é€‰ std æ”¯æŒ
- æ ¸å¿ƒå·¥å…·å‡½æ•°

### é¡¹ç›®ç»“æ„5

```text
sysutil/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ math.rs             # æ•°å­¦å·¥å…·
â”‚   â””â”€â”€ buffer.rs           # ç¼“å†²åŒºç®¡ç†
â””â”€â”€ tests/
    â””â”€â”€ std_tests.rs        # std ç¯å¢ƒæµ‹è¯•
```

### å®ç°æ­¥éª¤5

**Cargo.toml**:

```toml
[package]
name = "sysutil"
version = "0.1.0"
edition = "2024"

[features]
default = ["std"]
std = []
alloc = []

[dependencies]
# no_std å…¼å®¹çš„ä¾èµ–

[dev-dependencies]
# æµ‹è¯•ä¾èµ–ï¼ˆéœ€è¦ stdï¼‰
```

### å…³é”®ä»£ç 5

**src/lib.rs**:

```rust
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "alloc")]
extern crate alloc;

#[cfg(feature = "std")]
extern crate std;

pub mod math;
pub mod buffer;

#[cfg(all(test, feature = "std"))]
mod tests {
    #[test]
    fn test_basic() {
        assert_eq!(2 + 2, 4);
    }
}
```

**src/math.rs**:

```rust
//! Math utilities for no_std environments

/// Calculate power without std
pub const fn pow(base: u32, exp: u32) -> u32 {
    let mut result = 1;
    let mut i = 0;
    while i < exp {
        result *= base;
        i += 1;
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pow() {
        assert_eq!(pow(2, 3), 8);
        assert_eq!(pow(10, 2), 100);
    }
}
```

---

## æ¡ˆä¾‹ 6: æ’ä»¶ç³»ç»Ÿ

### é¡¹ç›®éœ€æ±‚6

åˆ›å»ºä¸€ä¸ªæ”¯æŒåŠ¨æ€æ’ä»¶åŠ è½½çš„ç³»ç»Ÿï¼š

- æ’ä»¶ API å®šä¹‰
- æ’ä»¶åŠ è½½å™¨
- ç¤ºä¾‹æ’ä»¶

### é¡¹ç›®ç»“æ„6

```text
plugin-system/
â”œâ”€â”€ Cargo.toml              # å·¥ä½œç©ºé—´
â”œâ”€â”€ plugin-api/             # æ’ä»¶ API
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ plugin-loader/          # åŠ è½½å™¨
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ example-plugin/         # ç¤ºä¾‹æ’ä»¶
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â””â”€â”€ host/                   # ä¸»ç¨‹åº
    â”œâ”€â”€ Cargo.toml
    â””â”€â”€ src/
        â””â”€â”€ main.rs
```

### å®ç°æ­¥éª¤6

**plugin-api/src/lib.rs**:

```rust
//! Plugin API definition

use std::any::Any;

/// Plugin trait that all plugins must implement
pub trait Plugin: Send + Sync {
    /// Plugin name
    fn name(&self) -> &str;

    /// Plugin version
    fn version(&self) -> &str;

    /// Initialize plugin
    fn init(&mut self) -> Result<(), Box<dyn std::error::Error>>;

    /// Execute plugin
    fn execute(&self, input: &dyn Any) -> Result<Box<dyn Any>, Box<dyn std::error::Error>>;
}

/// Plugin constructor type
pub type PluginConstructor = fn() -> Box<dyn Plugin>;

#[macro_export]
macro_rules! declare_plugin {
    ($plugin_type:ty, $constructor:path) => {
        #[no_mangle]
        pub extern "C" fn _plugin_create() -> *mut dyn $crate::Plugin {
            let constructor: fn() -> Box<dyn $crate::Plugin> = $constructor;
            let object = constructor();
            Box::into_raw(object)
        }
    };
}
```

### å…³é”®ä»£ç 6

**example-plugin/src/lib.rs**:

```rust
use plugin_api::{declare_plugin, Plugin};
use std::any::Any;

pub struct ExamplePlugin {
    name: String,
}

impl Plugin for ExamplePlugin {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        "0.1.0"
    }

    fn init(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("Initializing {}", self.name);
        Ok(())
    }

    fn execute(&self, _input: &dyn Any) -> Result<Box<dyn Any>, Box<dyn std::error::Error>> {
        println!("Executing {}", self.name);
        Ok(Box::new(()))
    }
}

fn constructor() -> Box<dyn Plugin> {
    Box::new(ExamplePlugin {
        name: "Example Plugin".to_string(),
    })
}

declare_plugin!(Plugin, constructor);
```

---

## ğŸ“š æ¡ˆä¾‹å¯¹æ¯”

| ç‰¹æ€§ | CLI å·¥å…· | åº“ | Web API | å·¥ä½œç©ºé—´ | no_std | æ’ä»¶ |
| --- | --- | --- | --- | --- | --- | --- |
| å¤æ‚åº¦ | â­ | â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| ä¾èµ–æ•° | å°‘ | ä¸­ | å¤š | å¤š | æå°‘ | ä¸­ |
| å¼‚æ­¥ | å¦ | å¯é€‰ | æ˜¯ | æ··åˆ | å¦ | å¯é€‰ |
| æµ‹è¯• | ç®€å• | é‡è¦ | å¤æ‚ | åˆ†å±‚ | ç‰¹æ®Š | å¤æ‚ |
| æ–‡æ¡£ | åŸºç¡€ | å®Œæ•´ | API | åˆ†æ•£ | è¯¦ç»† | å®Œæ•´ |

---

## ğŸ’¡ ç»éªŒæ€»ç»“

### é€šç”¨å»ºè®®

1. **ä»ç®€å•å¼€å§‹**: å…ˆå®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œå†æ·»åŠ ç‰¹æ€§
2. **æµ‹è¯•ä¼˜å…ˆ**: ç¼–å†™æµ‹è¯•ä¿è¯ä»£ç è´¨é‡
3. **æ–‡æ¡£åŒæ­¥**: ä»£ç å’Œæ–‡æ¡£åŒæ­¥æ›´æ–°
4. **æŒç»­é›†æˆ**: ä½¿ç”¨ CI/CD è‡ªåŠ¨åŒ–æµç¨‹

### ç‰¹å®šå»ºè®®

**CLI å·¥å…·**:

- ä½¿ç”¨ `clap` ç®€åŒ–å‚æ•°è§£æ
- æä¾›å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
- æ·»åŠ  `--help` å’Œ `--version`

**åº“å¼€å‘**:

- è®¾è®¡æ¸…æ™°çš„ API
- æä¾›å®Œæ•´çš„æ–‡æ¡£å’Œç¤ºä¾‹
- ä½¿ç”¨ç‰¹æ€§ç³»ç»Ÿæ”¯æŒå¯é€‰åŠŸèƒ½

**Web æœåŠ¡**:

- ä½¿ç”¨å¼‚æ­¥è¿è¡Œæ—¶
- å®ç°é€‚å½“çš„é”™è¯¯å¤„ç†
- æ·»åŠ æ—¥å¿—å’Œç›‘æ§

**å·¥ä½œç©ºé—´**:

- åˆç†åˆ’åˆ†åŒ…çš„èŒè´£
- ä½¿ç”¨å·¥ä½œç©ºé—´ç»§æ‰¿
- ç»Ÿä¸€ç‰ˆæœ¬ç®¡ç†

---

## ğŸ”— å‚è€ƒèµ„æº

### ç¤ºä¾‹é¡¹ç›®

- [ripgrep](https://github.com/BurntSushi/ripgrep) - CLI å·¥å…·
- [serde](https://github.com/serde-rs/serde) - åº“
- [axum](https://github.com/tokio-rs/axum) - Web æ¡†æ¶
- [tokio](https://github.com/tokio-rs/tokio) - å·¥ä½œç©ºé—´

### å­¦ä¹ èµ„æº

- [Rust By Example](https://doc.rust-lang.org/rust-by-example/)
- [The Cargo Book](https://doc.rust-lang.org/cargo/)
- [Awesome Rust](https://github.com/rust-unofficial/awesome-rust)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2026-01-26
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.93.0+

*å®è·µæ˜¯æœ€å¥½çš„è€å¸ˆã€‚* ğŸ¦€ğŸ’¼
