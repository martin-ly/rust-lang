# 3.5 Rust ç±»å‹ç³»ç»Ÿ - æ€§èƒ½ä¼˜åŒ–å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [3.3 åˆ†æ´¾æœºåˆ¶å‚è€ƒ](./03_åˆ†æ´¾æœºåˆ¶å‚è€ƒ.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.5 Rust ç±»å‹ç³»ç»Ÿ - æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](#35-rust-ç±»å‹ç³»ç»Ÿ---æ€§èƒ½ä¼˜åŒ–å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. é›¶æˆæœ¬æŠ½è±¡](#1-é›¶æˆæœ¬æŠ½è±¡)
    - [1.1 æ ¸å¿ƒåŸåˆ™](#11-æ ¸å¿ƒåŸåˆ™)
    - [1.2 å•æ€åŒ–](#12-å•æ€åŒ–)
    - [1.3 å†…è”ä¼˜åŒ–](#13-å†…è”ä¼˜åŒ–)
  - [2. å†…å­˜å¸ƒå±€ä¼˜åŒ–](#2-å†…å­˜å¸ƒå±€ä¼˜åŒ–)
    - [2.1 ç»“æ„ä½“å¸ƒå±€](#21-ç»“æ„ä½“å¸ƒå±€)
    - [2.2 æšä¸¾ä¼˜åŒ–](#22-æšä¸¾ä¼˜åŒ–)
    - [2.3 é›¶å¤§å°ç±»å‹](#23-é›¶å¤§å°ç±»å‹)
  - [3. é¿å…åˆ†é…](#3-é¿å…åˆ†é…)
    - [3.1 æ ˆ vs å †](#31-æ ˆ-vs-å †)
    - [3.2 SmallVec å’Œ Cow](#32-smallvec-å’Œ-cow)
    - [3.3 Arena åˆ†é…](#33-arena-åˆ†é…)
  - [4. ç¼–è¯‘æ—¶è®¡ç®—](#4-ç¼–è¯‘æ—¶è®¡ç®—)
    - [4.1 Const æ³›å‹](#41-const-æ³›å‹)
    - [4.2 Const å‡½æ•°](#42-const-å‡½æ•°)
    - [4.3 ç±»å‹çº§è®¡ç®—](#43-ç±»å‹çº§è®¡ç®—)
    - [4.4 ç¼–è¯‘æ—¶å­—ç¬¦ä¸²å¤„ç†](#44-ç¼–è¯‘æ—¶å­—ç¬¦ä¸²å¤„ç†)
    - [4.5 Build-Time Code Generation](#45-build-time-code-generation)
  - [5. ç¼“å­˜å‹å¥½](#5-ç¼“å­˜å‹å¥½)
    - [5.1 æ•°æ®å±€éƒ¨æ€§](#51-æ•°æ®å±€éƒ¨æ€§)
    - [5.2 å†…å­˜å¯¹é½](#52-å†…å­˜å¯¹é½)
    - [5.3 é¢„å–](#53-é¢„å–)
    - [5.4 å‘é‡åŒ–è®¡ç®—](#54-å‘é‡åŒ–è®¡ç®—)
    - [5.5 æ•°æ®ç»“æ„çš„ç¼“å­˜ä¼˜åŒ–](#55-æ•°æ®ç»“æ„çš„ç¼“å­˜ä¼˜åŒ–)
    - [5.6 æ‰¹å¤„ç†ä¼˜åŒ–](#56-æ‰¹å¤„ç†ä¼˜åŒ–)
  - [6. æ€§èƒ½æµ‹é‡](#6-æ€§èƒ½æµ‹é‡)
    - [6.1 Criterion](#61-criterion)
    - [6.2 Profiling](#62-profiling)
    - [6.3 ä¼˜åŒ–ç­–ç•¥](#63-ä¼˜åŒ–ç­–ç•¥)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: é«˜æ€§èƒ½é›†åˆ](#æ¡ˆä¾‹-1-é«˜æ€§èƒ½é›†åˆ)
    - [æ¡ˆä¾‹ 2: é›¶æ‹·è´è§£æ](#æ¡ˆä¾‹-2-é›¶æ‹·è´è§£æ)
    - [æ¡ˆä¾‹ 3: SIMD ä¼˜åŒ–](#æ¡ˆä¾‹-3-simd-ä¼˜åŒ–)
    - [æ¡ˆä¾‹ 4: è‡ªå®šä¹‰åˆ†é…å™¨](#æ¡ˆä¾‹-4-è‡ªå®šä¹‰åˆ†é…å™¨)
    - [æ¡ˆä¾‹ 5: å†…å­˜æ± ä¼˜åŒ–](#æ¡ˆä¾‹-5-å†…å­˜æ± ä¼˜åŒ–)
  - [8. å¸¸è§é™·é˜±](#8-å¸¸è§é™·é˜±)
  - [9. ç¼–è¯‘å™¨ä¼˜åŒ–æ·±åº¦](#9-ç¼–è¯‘å™¨ä¼˜åŒ–æ·±åº¦)
    - [9.1 LLVMä¼˜åŒ–æµç¨‹](#91-llvmä¼˜åŒ–æµç¨‹)
    - [9.2 å†…è”ç­–ç•¥æ·±åº¦](#92-å†…è”ç­–ç•¥æ·±åº¦)
    - [9.3 æ­»ä»£ç æ¶ˆé™¤ï¼ˆDCEï¼‰](#93-æ­»ä»£ç æ¶ˆé™¤dce)
    - [9.4 å¾ªç¯ä¼˜åŒ–](#94-å¾ªç¯ä¼˜åŒ–)
    - [9.5 å¸¸é‡æŠ˜å ä¸å¸¸é‡ä¼ æ’­](#95-å¸¸é‡æŠ˜å ä¸å¸¸é‡ä¼ æ’­)
  - [10. é«˜çº§ä¼˜åŒ–å®æˆ˜æ¡ˆä¾‹é›†](#10-é«˜çº§ä¼˜åŒ–å®æˆ˜æ¡ˆä¾‹é›†)
    - [æ¡ˆä¾‹ 6: é«˜æ€§èƒ½JSONè§£æå™¨](#æ¡ˆä¾‹-6-é«˜æ€§èƒ½jsonè§£æå™¨)
    - [æ¡ˆä¾‹ 7: é«˜æ€§èƒ½å“ˆå¸Œè¡¨](#æ¡ˆä¾‹-7-é«˜æ€§èƒ½å“ˆå¸Œè¡¨)
    - [æ¡ˆä¾‹ 8: æ‰¹å¤„ç†ä¸æµæ°´çº¿ä¼˜åŒ–](#æ¡ˆä¾‹-8-æ‰¹å¤„ç†ä¸æµæ°´çº¿ä¼˜åŒ–)
    - [æ¡ˆä¾‹ 9: åˆ†å±‚ç¼“å­˜ç­–ç•¥](#æ¡ˆä¾‹-9-åˆ†å±‚ç¼“å­˜ç­–ç•¥)
    - [æ¡ˆä¾‹ 10: é¢„è®¡ç®—ä¸æŸ¥è¡¨æ³•](#æ¡ˆä¾‹-10-é¢„è®¡ç®—ä¸æŸ¥è¡¨æ³•)
  - [11. è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜](#11-è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜)
  - [12. æ€»ç»“](#12-æ€»ç»“)
  - [13. å‚è€ƒèµ„æº](#13-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust çš„ç±»å‹ç³»ç»Ÿæä¾›äº†**é›¶æˆæœ¬æŠ½è±¡**ï¼š

| ä¼˜åŒ–ç»´åº¦ | æŠ€æœ¯ | æ”¶ç›Š |
|---------|------|------|
| **ç¼–è¯‘æ—¶** | å•æ€åŒ– + å†…è” | æ¶ˆé™¤æŠ½è±¡å¼€é”€ |
| **å†…å­˜** | å¸ƒå±€ä¼˜åŒ– + ZST | å‡å°‘å†…å­˜å ç”¨ |
| **åˆ†é…** | æ ˆåˆ†é… + Arena | å‡å°‘å †åˆ†é… |
| **ç¼“å­˜** | æ•°æ®å±€éƒ¨æ€§ + å¯¹é½ | æå‡ç¼“å­˜å‘½ä¸­ |

---

## 1. é›¶æˆæœ¬æŠ½è±¡

### 1.1 æ ¸å¿ƒåŸåˆ™

**"ä½ ä¸ç”¨çš„ä¸ä»˜è´¹ï¼Œä½ ä½¿ç”¨çš„æ— æ³•å†™å¾—æ›´å¿«"**-

```rust
// æŠ½è±¡ä»£ç 
fn sum_generic<T: std::iter::Iterator<Item = i32>>(iter: T) -> i32 {
    iter.sum()
}

// ç¼–è¯‘åç­‰ä»·äºæ‰‹å†™å¾ªç¯
fn sum_manual(slice: &[i32]) -> i32 {
    let mut total = 0;
    for &item in slice {
        total += item;
    }
    total
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // ä¸¤è€…æ€§èƒ½ç›¸åŒ
    let result1 = sum_generic(data.iter().copied());
    let result2 = sum_manual(&data);
    
    println!("{} {}", result1, result2);
}
```

### 1.2 å•æ€åŒ–

**ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨ä»£ç **:

```rust
fn process<T: std::fmt::Display>(value: T) {
    println!("Value: {}", value);
}

fn main() {
    process(42);      // ç”Ÿæˆ process_i32
    process(3.14);    // ç”Ÿæˆ process_f64
    process("hi");    // ç”Ÿæˆ process_str
}
```

**æ€§èƒ½å¯¹æ¯”**:

```rust
use std::time::Instant;

trait Compute {
    fn compute(&self) -> i64;
}

struct Simple(i64);

impl Compute for Simple {
    fn compute(&self) -> i64 {
        self.0 * 2
    }
}

// é™æ€åˆ†å‘
fn static_sum<T: Compute>(items: &[T]) -> i64 {
    items.iter().map(|x| x.compute()).sum()
}

// åŠ¨æ€åˆ†å‘
fn dynamic_sum(items: &[&dyn Compute]) -> i64 {
    items.iter().map(|x| x.compute()).sum()
}

fn main() {
    let items: Vec<Simple> = (0..1_000_000).map(Simple).collect();
    
    let start = Instant::now();
    let _result = static_sum(&items);
    println!("Static: {:?}", start.elapsed());
    
    let dyn_items: Vec<&dyn Compute> = items.iter()
        .map(|x| x as &dyn Compute)
        .collect();
    
    let start = Instant::now();
    let _result = dynamic_sum(&dyn_items);
    println!("Dynamic: {:?}", start.elapsed());
}
```

### 1.3 å†…è”ä¼˜åŒ–

**#[inline] å±æ€§**:

```rust
// æ€»æ˜¯å†…è”
#[inline(always)]
fn hot_function(x: i32) -> i32 {
    x * 2 + 1
}

// æç¤ºç¼–è¯‘å™¨å†…è”
#[inline]
fn warm_function(x: i32) -> i32 {
    x + 1
}

// ç¦æ­¢å†…è”
#[inline(never)]
fn cold_function(x: i32) -> i32 {
    println!("Called with {}", x);
    x
}

fn main() {
    let result = hot_function(21);
    println!("Result: {}", result);
}
```

---

## 2. å†…å­˜å¸ƒå±€ä¼˜åŒ–

### 2.1 ç»“æ„ä½“å¸ƒå±€

**å­—æ®µé¡ºåºå½±å“å¤§å°**:

```rust
use std::mem;

// âŒ æœªä¼˜åŒ–ï¼š16 å­—èŠ‚ (å¡«å……)
struct Unoptimized {
    a: u8,   // 1 byte
    // 3 bytes padding
    b: u32,  // 4 bytes
    c: u8,   // 1 byte
    // 3 bytes padding
}

// âœ… ä¼˜åŒ–ï¼š8 å­—èŠ‚
struct Optimized {
    b: u32,  // 4 bytes
    a: u8,   // 1 byte
    c: u8,   // 1 byte
    // 2 bytes padding
}

fn main() {
    println!("Unoptimized: {}", mem::size_of::<Unoptimized>());  // 12
    println!("Optimized: {}", mem::size_of::<Optimized>());      // 8
}
```

### 2.2 æšä¸¾ä¼˜åŒ–

**ç©ºæŒ‡é’ˆä¼˜åŒ–**:

```rust
use std::mem;

// Option<Box<T>> å¤§å°ç­‰äº Box<T>
fn main() {
    println!("Box<i32>: {}", mem::size_of::<Box<i32>>());           // 8
    println!("Option<Box<i32>>: {}", mem::size_of::<Option<Box<i32>>>());  // 8
    
    // åˆ©ç”¨ Box ä¸ä¸º nullï¼ŒNone ç”¨ null è¡¨ç¤º
}
```

**Discriminant ä¼˜åŒ–**:

```rust
use std::mem;

// å°æšä¸¾
enum Small {
    A,
    B,
    C,
}

// å¸¦æ•°æ®çš„æšä¸¾
enum WithData {
    A(u32),
    B(u64),
    C,
}

fn main() {
    println!("Small: {}", mem::size_of::<Small>());         // 1
    println!("WithData: {}", mem::size_of::<WithData>());   // 16 (8 + 8)
}
```

### 2.3 é›¶å¤§å°ç±»å‹

**ZST ä¸å ç©ºé—´**:

```rust
use std::mem;

struct Empty;

struct PhantomMarker<T> {
    _marker: std::marker::PhantomData<T>,
}

fn main() {
    println!("Empty: {}", mem::size_of::<Empty>());                // 0
    println!("PhantomMarker<i32>: {}", mem::size_of::<PhantomMarker<i32>>());  // 0
    
    // Vec çš„åˆ†é…ä¸å— ZST å½±å“
    let vec: Vec<Empty> = vec![Empty; 1000];
    println!("Vec<Empty> capacity: {}", vec.capacity());  // ä¸åˆ†é…
}
```

---

## 3. é¿å…åˆ†é…

### 3.1 æ ˆ vs å †

**ä¼˜å…ˆä½¿ç”¨æ ˆ**:

```rust
// âŒ å †åˆ†é…
fn heap_allocation() -> Box<[i32; 1000]> {
    Box::new([0; 1000])
}

// âœ… æ ˆåˆ†é…
fn stack_allocation() -> [i32; 1000] {
    [0; 1000]
}

// âœ… å¼•ç”¨ï¼Œé¿å…ç§»åŠ¨
fn reference_stack(data: &[i32; 1000]) {
    println!("Sum: {}", data.iter().sum::<i32>());
}

fn main() {
    let data = stack_allocation();
    reference_stack(&data);
}
```

### 3.2 SmallVec å’Œ Cow

**SmallVec**:

```rust
use smallvec::{SmallVec, smallvec};

fn main() {
    // å°æ•°æ®åœ¨æ ˆä¸Š
    let mut vec: SmallVec<[i32; 4]> = smallvec![1, 2, 3];
    println!("On stack: {:?}", vec);
    
    // è¶…å‡ºå®¹é‡åæ‰å †åˆ†é…
    vec.push(4);
    vec.push(5);
    println!("Now on heap: {:?}", vec);
}
```

**Cow (Clone on Write)**:

```rust
use std::borrow::Cow;

fn process(input: &str) -> Cow<str> {
    if input.contains("bad") {
        // éœ€è¦ä¿®æ”¹ï¼Œåˆ†é…
        Cow::Owned(input.replace("bad", "good"))
    } else {
        // ä¸éœ€è¦ä¿®æ”¹ï¼Œå€Ÿç”¨
        Cow::Borrowed(input)
    }
}

fn main() {
    let text1 = "This is bad";
    let text2 = "This is fine";
    
    let result1 = process(text1);  // åˆ†é…
    let result2 = process(text2);  // ä¸åˆ†é…
    
    println!("{} {}", result1, result2);
}
```

### 3.3 Arena åˆ†é…

**æ‰¹é‡åˆ†é…ï¼Œæ‰¹é‡é‡Šæ”¾**:

```rust
use typed_arena::Arena;

struct Node<'a> {
    value: i32,
    next: Option<&'a Node<'a>>,
}

fn main() {
    let arena = Arena::new();
    
    // åœ¨ arena ä¸­åˆ†é…ï¼Œæ— éœ€å•ç‹¬é‡Šæ”¾
    let node1 = arena.alloc(Node {
        value: 1,
        next: None,
    });
    
    let node2 = arena.alloc(Node {
        value: 2,
        next: Some(node1),
    });
    
    println!("Node2: {}", node2.value);
    
    // arena ææ„æ—¶ä¸€æ¬¡æ€§é‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹
}
```

---

## 4. ç¼–è¯‘æ—¶è®¡ç®—

### 4.1 Const æ³›å‹

**ç¼–è¯‘æ—¶ç¡®å®šæ•°ç»„å¤§å°**:

```rust
// æ³›å‹æ•°ç»„ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
fn sum<const N: usize>(arr: &[i32; N]) -> i32 {
    arr.iter().sum()
}

fn main() {
    let arr3 = [1, 2, 3];
    let arr5 = [1, 2, 3, 4, 5];
    
    println!("Sum3: {}", sum(&arr3));
    println!("Sum5: {}", sum(&arr5));
}
```

### 4.2 Const å‡½æ•°

**ç¼–è¯‘æ—¶æ±‚å€¼**:

```rust
const fn factorial(n: u32) -> u32 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

// ç¼–è¯‘æ—¶è®¡ç®—
const FACT_5: u32 = factorial(5);

fn main() {
    println!("5! = {}", FACT_5);  // 120ï¼Œç¼–è¯‘æ—¶å·²çŸ¥
}
```

### 4.3 ç±»å‹çº§è®¡ç®—

**ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œè®¡ç®—**:

```rust
use std::marker::PhantomData;

struct Zero;
struct Succ<N>(PhantomData<N>);

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// ç±»å‹çº§åŠ æ³•
trait Add<N> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
    Succ<N::Output>: Sized,
{
    type Output = Succ<N::Output>;
}

fn main() {
    // ç±»å‹ç³»ç»Ÿè¯æ˜ 1 + 2 = 3
    let _: <One as Add<Two>>::Output = Succ(PhantomData::<Two>);
}
```

### 4.4 ç¼–è¯‘æ—¶å­—ç¬¦ä¸²å¤„ç†

**const fnè¿›é˜¶**:

```rust
const fn parse_hex(s: &str) -> Option<u32> {
    let bytes = s.as_bytes();
    if bytes.len() == 0 {
        return None;
    }
    
    let mut result = 0u32;
    let mut i = 0;
    
    while i < bytes.len() {
        let digit = match bytes[i] {
            b'0'..=b'9' => bytes[i] - b'0',
            b'a'..=b'f' => bytes[i] - b'a' + 10,
            b'A'..=b'F' => bytes[i] - b'A' + 10,
            _ => return None,
        };
        
        result = result * 16 + digit as u32;
        i += 1;
    }
    
    Some(result)
}

const HEX_VALUE: u32 = match parse_hex("FF") {
    Some(v) => v,
    None => 0,
};

fn main() {
    println!("0xFF = {}", HEX_VALUE);  // 255ï¼Œç¼–è¯‘æ—¶å·²çŸ¥
}
```

### 4.5 Build-Time Code Generation

**ä½¿ç”¨build.rsç”Ÿæˆä»£ç **:

```rust
// build.rs
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("lookup_table.rs");
    let mut f = File::create(&dest_path).unwrap();
    
    // ç”ŸæˆæŸ¥æ‰¾è¡¨
    writeln!(f, "const LOOKUP_TABLE: [u32; 256] = [").unwrap();
    for i in 0..256 {
        writeln!(f, "    {},", compute_expensive(i)).unwrap();
    }
    writeln!(f, "];").unwrap();
}

fn compute_expensive(x: u32) -> u32 {
    // æ˜‚è´µçš„è®¡ç®—ï¼Œåœ¨ç¼–è¯‘æ—¶æ‰§è¡Œ
    x * x + 2 * x + 1
}
```

```rust
// main.rs
include!(concat!(env!("OUT_DIR"), "/lookup_table.rs"));

fn fast_compute(x: u8) -> u32 {
    LOOKUP_TABLE[x as usize]  // O(1)æŸ¥æ‰¾ï¼Œæ— è¿è¡Œæ—¶è®¡ç®—
}

fn main() {
    println!("Value: {}", fast_compute(10));
}
```

---

## 5. ç¼“å­˜å‹å¥½

### 5.1 æ•°æ®å±€éƒ¨æ€§

**SoA vs AoS**:

```rust
// âŒ AoS (Array of Structs) - ç¼“å­˜ä¸å‹å¥½
struct PointAoS {
    x: f32,
    y: f32,
    z: f32,
}

fn sum_x_aos(points: &[PointAoS]) -> f32 {
    points.iter().map(|p| p.x).sum()
}

// âœ… SoA (Struct of Arrays) - ç¼“å­˜å‹å¥½
struct PointsSoA {
    x: Vec<f32>,
    y: Vec<f32>,
    z: Vec<f32>,
}

fn sum_x_soa(points: &PointsSoA) -> f32 {
    points.x.iter().sum()
}

fn main() {
    let aos: Vec<PointAoS> = vec![
        PointAoS { x: 1.0, y: 2.0, z: 3.0 },
        PointAoS { x: 4.0, y: 5.0, z: 6.0 },
    ];
    
    let soa = PointsSoA {
        x: vec![1.0, 4.0],
        y: vec![2.0, 5.0],
        z: vec![3.0, 6.0],
    };
    
    println!("AoS sum: {}", sum_x_aos(&aos));
    println!("SoA sum: {}", sum_x_soa(&soa));
}
```

### 5.2 å†…å­˜å¯¹é½

**å¯¹é½åˆ°ç¼“å­˜è¡Œ**:

```rust
use std::mem;

#[repr(align(64))]  // å¯¹é½åˆ°å…¸å‹ç¼“å­˜è¡Œå¤§å°
struct CacheLineAligned {
    data: [u8; 64],
}

fn main() {
    println!("Alignment: {}", mem::align_of::<CacheLineAligned>());
}
```

### 5.3 é¢„å–

**é¢„å–æ•°æ®åˆ°ç¼“å­˜**:

```rust
use std::arch::x86_64::{_mm_prefetch, _MM_HINT_T0};

fn process_with_prefetch(data: &[i32]) -> i64 {
    let mut sum = 0i64;
    
    for i in 0..data.len() {
        // é¢„å–ä¸‹ä¸€ä¸ªå…ƒç´ 
        if i + 1 < data.len() {
            unsafe {
                _mm_prefetch(
                    &data[i + 1] as *const i32 as *const i8,
                    _MM_HINT_T0,
                );
            }
        }
        sum += data[i] as i64;
    }
    
    sum
}

fn main() {
    let data: Vec<i32> = (0..1000).collect();
    let result = process_with_prefetch(&data);
    println!("Sum: {}", result);
}
```

### 5.4 å‘é‡åŒ–è®¡ç®—

**SIMDä¼˜åŒ–**:

```rust
use std::arch::x86_64::*;

// æ ‡é‡ç‰ˆæœ¬
fn add_scalar(a: &[f32], b: &[f32], result: &mut [f32]) {
    for i in 0..a.len() {
        result[i] = a[i] + b[i];
    }
}

// SIMDç‰ˆæœ¬ï¼ˆä½¿ç”¨AVXï¼‰
#[target_feature(enable = "avx")]
unsafe fn add_simd(a: &[f32], b: &[f32], result: &mut [f32]) {
    let chunks = a.len() / 8;
    
    for i in 0..chunks {
        let offset = i * 8;
        
        // åŠ è½½8ä¸ªæµ®ç‚¹æ•°
        let va = _mm256_loadu_ps(a.as_ptr().add(offset));
        let vb = _mm256_loadu_ps(b.as_ptr().add(offset));
        
        // å‘é‡åŠ æ³•
        let vr = _mm256_add_ps(va, vb);
        
        // å­˜å‚¨ç»“æœ
        _mm256_storeu_ps(result.as_mut_ptr().add(offset), vr);
    }
    
    // å¤„ç†å‰©ä½™å…ƒç´ 
    for i in (chunks * 8)..a.len() {
        result[i] = a[i] + b[i];
    }
}

fn main() {
    let a = vec![1.0f32; 1000];
    let b = vec![2.0f32; 1000];
    let mut result = vec![0.0f32; 1000];
    
    unsafe {
        add_simd(&a, &b, &mut result);
    }
}
```

### 5.5 æ•°æ®ç»“æ„çš„ç¼“å­˜ä¼˜åŒ–

**çƒ­/å†·æ•°æ®åˆ†ç¦»**:

```rust
// âŒ æ··åˆå­˜å‚¨ï¼ˆç¼“å­˜ä¸å‹å¥½ï¼‰
struct EntityBad {
    id: u32,
    position: (f32, f32, f32),
    velocity: (f32, f32, f32),
    health: f32,
    name: String,          // ä¸å¸¸è®¿é—®
    description: String,   // ä¸å¸¸è®¿é—®
}

// âœ… åˆ†ç¦»å­˜å‚¨ï¼ˆç¼“å­˜å‹å¥½ï¼‰
struct EntityHot {
    id: u32,
    position: (f32, f32, f32),
    velocity: (f32, f32, f32),
    health: f32,
    cold_index: usize,  // æŒ‡å‘å†·æ•°æ®
}

struct EntityCold {
    name: String,
    description: String,
}

struct EntitySystem {
    hot: Vec<EntityHot>,
    cold: Vec<EntityCold>,
}

impl EntitySystem {
    fn update_positions(&mut self, dt: f32) {
        // åªè®¿é—®çƒ­æ•°æ®ï¼Œç¼“å­˜å‹å¥½
        for entity in &mut self.hot {
            entity.position.0 += entity.velocity.0 * dt;
            entity.position.1 += entity.velocity.1 * dt;
            entity.position.2 += entity.velocity.2 * dt;
        }
    }
}
```

### 5.6 æ‰¹å¤„ç†ä¼˜åŒ–

**æ‰¹é‡å¤„ç†æå‡ç¼“å­˜å‘½ä¸­**:

```rust
// âŒ é€ä¸ªå¤„ç†
fn process_individually(items: &[Item]) {
    for item in items {
        expensive_operation(item);
    }
}

// âœ… æ‰¹é‡å¤„ç†
fn process_batched(items: &[Item]) {
    const BATCH_SIZE: usize = 64;
    
    for batch in items.chunks(BATCH_SIZE) {
        // é¢„å¤„ç†æ•´ä¸ªæ‰¹æ¬¡
        let mut preprocessed = Vec::with_capacity(BATCH_SIZE);
        for item in batch {
            preprocessed.push(preprocess(item));
        }
        
        // æ‰¹é‡å¤„ç†
        for data in preprocessed {
            cheap_operation(&data);
        }
    }
}

struct Item {
    data: [u8; 16],
}

fn preprocess(item: &Item) -> [u8; 16] {
    item.data
}

fn cheap_operation(_data: &[u8; 16]) {
    // å¿«é€Ÿæ“ä½œ
}

fn expensive_operation(_item: &Item) {
    // æ˜‚è´µæ“ä½œ
}
```

---

## 6. æ€§èƒ½æµ‹é‡

### 6.1 Criterion

**åŸºå‡†æµ‹è¯•**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 | 1 => n,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

### 6.2 Profiling

**ä½¿ç”¨ perf/flamegraph**:

```bash
# Linux perf
cargo build --release
perf record --call-graph dwarf ./target/release/myapp
perf report

# Flamegraph
cargo flamegraph
```

### 6.3 ä¼˜åŒ–ç­–ç•¥

**é€æ­¥ä¼˜åŒ–**:

1. **æµ‹é‡**: å…ˆæµ‹é‡ï¼Œæ‰¾åˆ°ç“¶é¢ˆ
2. **ä¼˜åŒ–**: é’ˆå¯¹çƒ­ç‚¹ä¼˜åŒ–
3. **éªŒè¯**: å†æ¬¡æµ‹é‡ï¼Œç¡®è®¤æ•ˆæœ

```rust
use std::time::Instant;

fn benchmark<F: Fn()>(name: &str, f: F) {
    let start = Instant::now();
    f();
    println!("{}: {:?}", name, start.elapsed());
}

fn main() {
    benchmark("Version 1", || {
        // å®ç° 1
    });
    
    benchmark("Version 2", || {
        // å®ç° 2
    });
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: é«˜æ€§èƒ½é›†åˆ

```rust
use std::collections::HashMap;

// é¢„åˆ†é…å®¹é‡
fn optimized_hashmap() -> HashMap<i32, String> {
    let mut map = HashMap::with_capacity(1000);
    
    for i in 0..1000 {
        map.insert(i, format!("value{}", i));
    }
    
    map
}

// ä½¿ç”¨ FxHash (æ›´å¿«çš„å“ˆå¸Œ)
use rustc_hash::FxHashMap;

fn fast_hashmap() -> FxHashMap<i32, String> {
    let mut map = FxHashMap::default();
    
    for i in 0..1000 {
        map.insert(i, format!("value{}", i));
    }
    
    map
}

fn main() {
    let _map1 = optimized_hashmap();
    let _map2 = fast_hashmap();
}
```

### æ¡ˆä¾‹ 2: é›¶æ‹·è´è§£æ

```rust
use std::str;

// âŒ åˆ†é…æ–°å­—ç¬¦ä¸²
fn parse_owned(data: &[u8]) -> Vec<String> {
    str::from_utf8(data)
        .unwrap()
        .split(',')
        .map(|s| s.to_string())
        .collect()
}

// âœ… é›¶æ‹·è´ï¼Œè¿”å›åˆ‡ç‰‡
fn parse_borrowed(data: &[u8]) -> Vec<&str> {
    str::from_utf8(data)
        .unwrap()
        .split(',')
        .collect()
}

fn main() {
    let data = b"a,b,c,d,e";
    
    let owned = parse_owned(data);
    let borrowed = parse_borrowed(data);
    
    println!("Owned: {:?}", owned);
    println!("Borrowed: {:?}", borrowed);
}
```

### æ¡ˆä¾‹ 3: SIMD ä¼˜åŒ–

```rust
use std::arch::x86_64::*;

// æ ‡é‡ç‰ˆæœ¬
fn sum_scalar(data: &[f32]) -> f32 {
    data.iter().sum()
}

// SIMD ç‰ˆæœ¬
unsafe fn sum_simd(data: &[f32]) -> f32 {
    let mut sum = _mm_setzero_ps();
    let chunks = data.chunks_exact(4);
    let remainder = chunks.remainder();
    
    for chunk in chunks {
        let values = _mm_loadu_ps(chunk.as_ptr());
        sum = _mm_add_ps(sum, values);
    }
    
    // æ°´å¹³æ±‚å’Œ
    let mut result = [0f32; 4];
    _mm_storeu_ps(result.as_mut_ptr(), sum);
    let total = result.iter().sum::<f32>();
    
    // åŠ ä¸Šä½™æ•°
    total + remainder.iter().sum::<f32>()
}

fn main() {
    let data: Vec<f32> = (0..1000).map(|x| x as f32).collect();
    
    let result1 = sum_scalar(&data);
    let result2 = unsafe { sum_simd(&data) };
    
    println!("Scalar: {}", result1);
    println!("SIMD: {}", result2);
}
```

### æ¡ˆä¾‹ 4: è‡ªå®šä¹‰åˆ†é…å™¨

**ä½¿ç”¨è‡ªå®šä¹‰åˆ†é…å™¨**:

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::ptr;

struct CountingAllocator;

static mut ALLOCATION_COUNT: usize = 0;

unsafe impl GlobalAlloc for CountingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        ALLOCATION_COUNT += 1;
        System.alloc(layout)
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: CountingAllocator = CountingAllocator;

fn main() {
    let data: Vec<i32> = vec![1, 2, 3, 4, 5];
    println!("Allocated {} times", unsafe { ALLOCATION_COUNT });
}
```

### æ¡ˆä¾‹ 5: å†…å­˜æ± ä¼˜åŒ–

**å¯¹è±¡æ± æ¨¡å¼**:

```rust
use std::sync::Mutex;

struct ObjectPool<T> {
    objects: Mutex<Vec<T>>,
    factory: fn() -> T,
}

impl<T> ObjectPool<T> {
    fn new(factory: fn() -> T, initial_size: usize) -> Self {
        let objects = (0..initial_size).map(|_| factory()).collect();
        ObjectPool {
            objects: Mutex::new(objects),
            factory,
        }
    }
    
    fn acquire(&self) -> PooledObject<T> {
        let obj = self.objects.lock().unwrap().pop()
            .unwrap_or_else(|| (self.factory)());
        PooledObject {
            pool: self,
            obj: Some(obj),
        }
    }
    
    fn release(&self, obj: T) {
        self.objects.lock().unwrap().push(obj);
    }
}

struct PooledObject<'a, T> {
    pool: &'a ObjectPool<T>,
    obj: Option<T>,
}

impl<'a, T> Drop for PooledObject<'a, T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.release(obj);
        }
    }
}

impl<'a, T> std::ops::Deref for PooledObject<'a, T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
}

impl<'a, T> std::ops::DerefMut for PooledObject<'a, T> {
    fn deref_mut(&mut self) -> &mut T {
        self.obj.as_mut().unwrap()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let pool = ObjectPool::new(Vec::<i32>::new, 10);
    
    {
        let mut obj = pool.acquire();
        obj.push(1);
        obj.push(2);
        // è‡ªåŠ¨å½’è¿˜åˆ°æ± ä¸­
    }
    
    let obj2 = pool.acquire();  // é‡ç”¨ä¹‹å‰çš„ Vec
    println!("Len: {}", obj2.len());
}
```

---

## 8. å¸¸è§é™·é˜±

**é™·é˜± 1: è¿‡æ—©ä¼˜åŒ–**:

```rust
// âŒ ä¸å¿…è¦çš„ä¼˜åŒ–
// fn complex_optimization() { ... }

// âœ… å…ˆå†™æ¸…æ™°ä»£ç ï¼Œå†ä¼˜åŒ–ç“¶é¢ˆ
fn clear_code() {
    // æ¸…æ™°æ˜“æ‡‚çš„å®ç°
}
```

**é™·é˜± 2: ä¸æµ‹é‡å°±ä¼˜åŒ–**:

```rust
// âŒ å‡­æ„Ÿè§‰ä¼˜åŒ–
// "è¿™ä¸ªåº”è¯¥æ›´å¿«"

// âœ… åŸºäºæ•°æ®ä¼˜åŒ–
use criterion::{black_box, Criterion};

fn benchmark(c: &mut Criterion) {
    c.bench_function("version_a", |b| {
        b.iter(|| black_box(version_a()))
    });
    
    c.bench_function("version_b", |b| {
        b.iter(|| black_box(version_b()))
    });
}

fn version_a() {}
fn version_b() {}
```

**é™·é˜± 3: å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–**:

```rust
// ç¼–è¯‘å™¨å·²ç»å¾ˆæ™ºèƒ½
// ä¸è¦è¿‡åº¦æ‰‹åŠ¨ä¼˜åŒ–

// âœ… ä¿¡ä»»ç¼–è¯‘å™¨
fn simple_sum(data: &[i32]) -> i32 {
    data.iter().sum()  // å·²ç»å¾ˆå¿«
}
```

---

## 9. ç¼–è¯‘å™¨ä¼˜åŒ–æ·±åº¦

### 9.1 LLVMä¼˜åŒ–æµç¨‹

**ä¼˜åŒ–ç®¡é“**:

```rust
// Rust ç¼–è¯‘å™¨çš„ä¼˜åŒ–æµç¨‹
// 1. å‰ç«¯ï¼ˆrustcï¼‰: ç±»å‹æ£€æŸ¥ã€å€Ÿç”¨æ£€æŸ¥ã€å•æ€åŒ–
// 2. ä¸­ç«¯ï¼ˆLLVMï¼‰: IRä¼˜åŒ–ã€å†…è”ã€å¾ªç¯ä¼˜åŒ–
// 3. åç«¯ï¼ˆLLVMï¼‰: æŒ‡ä»¤é€‰æ‹©ã€å¯„å­˜å™¨åˆ†é…ã€ä»£ç ç”Ÿæˆ

// æŸ¥çœ‹ LLVM IR
// cargo rustc -- --emit=llvm-ir

// ç¤ºä¾‹ï¼šå¾ªç¯å‘é‡åŒ–
fn vectorized_sum(data: &[f32]) -> f32 {
    data.iter().sum()  // LLVMè‡ªåŠ¨å‘é‡åŒ–
}

// å¯¹åº”çš„ LLVM IR ä¼šä½¿ç”¨ SIMD æŒ‡ä»¤ï¼š
// %vec_sum = call <4 x float> @llvm.vector.reduce.add.v4f32
```

**ä¼˜åŒ–çº§åˆ«**:

```rust
// Cargo.toml
[profile.release]
opt-level = 3           # æœ€å¤§ä¼˜åŒ–
lto = "fat"             # é“¾æ¥æ—¶ä¼˜åŒ–
codegen-units = 1       # æ›´å¥½çš„ä¼˜åŒ–ï¼ˆæ›´æ…¢çš„ç¼–è¯‘ï¼‰
panic = "abort"         # å‡å°‘äºŒè¿›åˆ¶å¤§å°
strip = true            # ç§»é™¤è°ƒè¯•ç¬¦å·

[profile.release-with-debug]
inherits = "release"
debug = true            # ä¿ç•™è°ƒè¯•ä¿¡æ¯ç”¨äºprofiling
```

### 9.2 å†…è”ç­–ç•¥æ·±åº¦

**å†…è”å†³ç­–å› ç´ **:

```rust
// âŒ ä¸ä¼šå†…è”ï¼šå‡½æ•°å¤ªå¤§
#[inline]  // ç¼–è¯‘å™¨å¯èƒ½å¿½ç•¥
fn large_function() {
    // 100+ è¡Œä»£ç ...
}

// âœ… ä¼šå†…è”ï¼šå°å‡½æ•°
#[inline]
fn small_function(x: i32) -> i32 {
    x * 2
}

// âœ… å¼ºåˆ¶å†…è”
#[inline(always)]
fn critical_hot_path(x: i32) -> i32 {
    x.wrapping_add(1)
}

// âœ… ç¦æ­¢å†…è”ï¼ˆç”¨äºåŸºå‡†æµ‹è¯•ï¼‰
#[inline(never)]
fn benchmark_target() {
    // ...
}
```

**è·¨crateå†…è”**:

```rust
// lib.rs
#[inline]  // âŒ è·¨ crate ä¸å†…è”ï¼ˆé»˜è®¤ï¼‰
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

// è§£å†³æ–¹æ¡ˆ 1: ä½¿ç”¨ LTO
// Cargo.toml
// lto = true

// è§£å†³æ–¹æ¡ˆ 2: æ³›å‹å‡½æ•°è‡ªåŠ¨å†…è”
#[inline]
pub fn add_generic<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b  // å•æ€åŒ–åè‡ªåŠ¨è·¨crateå†…è”
}
```

### 9.3 æ­»ä»£ç æ¶ˆé™¤ï¼ˆDCEï¼‰

```rust
fn example_dce() {
    let x = 42;        // âœ… ä½¿ç”¨äº†
    let y = 100;       // âŒ æœªä½¿ç”¨ï¼Œä¼šè¢«æ¶ˆé™¤
    let z = compute(); // âŒ æ— å‰¯ä½œç”¨ä¸”æœªä½¿ç”¨ï¼Œä¼šè¢«æ¶ˆé™¤
    
    println!("{}", x);
}

fn compute() -> i32 {
    1 + 1  // çº¯å‡½æ•°ï¼Œç»“æœæœªä½¿ç”¨æ—¶ä¼šè¢«æ¶ˆé™¤
}

// é˜²æ­¢DCEï¼ˆç”¨äºåŸºå‡†æµ‹è¯•ï¼‰
use std::hint::black_box;

fn benchmark() {
    let result = expensive_computation();
    black_box(result);  // å‘Šè¯‰ç¼–è¯‘å™¨ä¸è¦ä¼˜åŒ–æ‰
}

fn expensive_computation() -> i32 { 42 }
```

### 9.4 å¾ªç¯ä¼˜åŒ–

```rust
// âœ… å¾ªç¯å±•å¼€
fn unrolled_sum(data: &[i32; 8]) -> i32 {
    // ç¼–è¯‘å™¨è‡ªåŠ¨å±•å¼€å›ºå®šé•¿åº¦æ•°ç»„çš„å¾ªç¯
    data.iter().sum()
    // å±•å¼€ä¸º: data[0] + data[1] + ... + data[7]
}

// âœ… å¾ªç¯å‘é‡åŒ–
fn vectorized_multiply(a: &[f32], b: &[f32]) -> Vec<f32> {
    a.iter()
        .zip(b.iter())
        .map(|(x, y)| x * y)  // LLVMè‡ªåŠ¨ä½¿ç”¨SIMD
        .collect()
}

// âœ… å¾ªç¯ä¸å˜ä»£ç å¤–æï¼ˆLICMï¼‰
fn licm_example(data: &[i32], multiplier: i32) -> Vec<i32> {
    data.iter()
        .map(|&x| {
            let factor = multiplier * 2;  // ä¼šè¢«æå‡åˆ°å¾ªç¯å¤–
            x * factor
        })
        .collect()
}
```

### 9.5 å¸¸é‡æŠ˜å ä¸å¸¸é‡ä¼ æ’­

```rust
// âœ… ç¼–è¯‘æ—¶è®¡ç®—
const fn compute_at_compile_time() -> i32 {
    let mut sum = 0;
    let mut i = 0;
    while i < 100 {
        sum += i;
        i += 1;
    }
    sum
}

const RESULT: i32 = compute_at_compile_time();  // ç¼–è¯‘æ—¶è®¡ç®—

fn runtime_example() {
    // å¸¸é‡ä¼ æ’­
    let x = 10;
    let y = 20;
    let z = x + y;  // ç¼–è¯‘å™¨ç›´æ¥æ›¿æ¢ä¸º 30
    
    // æ¡ä»¶åˆ†æ”¯ä¼˜åŒ–
    if z > 25 {
        println!("Always executed");  // å…¶ä»–åˆ†æ”¯ä¼šè¢«æ¶ˆé™¤
    }
}
```

---

## 10. é«˜çº§ä¼˜åŒ–å®æˆ˜æ¡ˆä¾‹é›†

### æ¡ˆä¾‹ 6: é«˜æ€§èƒ½JSONè§£æå™¨

```rust
use serde::{Deserialize, Serialize};

// âœ… é›¶æ‹·è´ååºåˆ—åŒ–
#[derive(Deserialize)]
struct Event<'a> {
    #[serde(borrow)]
    name: &'a str,     // å€Ÿç”¨è¾“å…¥å­—ç¬¦ä¸²ï¼Œæ— æ‹·è´
    
    #[serde(borrow)]
    data: &'a [u8],    // å€Ÿç”¨è¾“å…¥å­—èŠ‚ï¼Œæ— æ‹·è´
    
    count: u32,        // å°æ•°æ®ç›´æ¥æ‹·è´
}

fn parse_events(json: &str) -> Result<Vec<Event>, serde_json::Error> {
    serde_json::from_str(json)
}

// æ€§èƒ½å¯¹æ¯”
fn benchmark_json_parsing() {
    let json = r#"[
        {"name": "click", "data": [1,2,3], "count": 42},
        {"name": "view", "data": [4,5,6], "count": 100}
    ]"#;
    
    // é›¶æ‹·è´è§£æï¼š~2x æ›´å¿«ï¼Œ~50% æ›´å°‘å†…å­˜
    let events: Vec<Event> = serde_json::from_str(json).unwrap();
    
    for event in events {
        println!("{}: {}", event.name, event.count);
    }
}
```

### æ¡ˆä¾‹ 7: é«˜æ€§èƒ½å“ˆå¸Œè¡¨

```rust
use std::collections::HashMap;
use std::hash::{BuildHasher, Hasher};

// âœ… è‡ªå®šä¹‰å¿«é€Ÿå“ˆå¸Œï¼ˆFxHashï¼‰
struct FxHasher {
    hash: usize,
}

impl Hasher for FxHasher {
    fn finish(&self) -> u64 {
        self.hash as u64
    }
    
    fn write(&mut self, bytes: &[u8]) {
        for &byte in bytes {
            self.hash = self.hash.rotate_left(5) ^ byte as usize;
        }
    }
}

// ä½¿ç”¨åœºæ™¯ï¼šæ•´æ•°é”®çš„é«˜æ€§èƒ½å“ˆå¸Œè¡¨
fn fast_int_map() {
    // é»˜è®¤HashMapä½¿ç”¨SipHashï¼ˆå®‰å…¨ä½†è¾ƒæ…¢ï¼‰
    let mut slow_map: HashMap<i32, String> = HashMap::new();
    
    // ä½¿ç”¨FxHashï¼ˆå¿«3-4å€ï¼Œä½†éåŠ å¯†å®‰å…¨ï¼‰
    use rustc_hash::FxHashMap;
    let mut fast_map: FxHashMap<i32, String> = FxHashMap::default();
    
    for i in 0..10000 {
        fast_map.insert(i, format!("value{}", i));
    }
}
```

### æ¡ˆä¾‹ 8: æ‰¹å¤„ç†ä¸æµæ°´çº¿ä¼˜åŒ–

```rust
// âœ… æ‰¹å¤„ç†å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€
fn process_batch(items: &[Item]) {
    const BATCH_SIZE: usize = 64;
    
    for chunk in items.chunks(BATCH_SIZE) {
        // æ‰¹å¤„ç† 64 ä¸ªå…ƒç´ ï¼Œå‡å°‘å¼€é”€
        process_chunk_optimized(chunk);
    }
}

fn process_chunk_optimized(chunk: &[Item]) {
    // åˆ©ç”¨ç¼“å­˜å±€éƒ¨æ€§ï¼ŒSIMDç­‰
    for item in chunk {
        // å¤„ç†é€»è¾‘
    }
}

// âœ… æµæ°´çº¿ï¼šé‡å è®¡ç®—ä¸IO
use std::sync::mpsc;
use std::thread;

fn pipeline_processing(input: Vec<Data>) {
    let (tx1, rx1) = mpsc::channel();
    let (tx2, rx2) = mpsc::channel();
    
    // é˜¶æ®µ1ï¼šIOåŠ è½½
    thread::spawn(move || {
        for data in input {
            let loaded = load_data(data);
            tx1.send(loaded).unwrap();
        }
    });
    
    // é˜¶æ®µ2ï¼šè®¡ç®—å¤„ç†ï¼ˆä¸IOé‡å ï¼‰
    thread::spawn(move || {
        for loaded in rx1 {
            let processed = compute(loaded);
            tx2.send(processed).unwrap();
        }
    });
    
    // é˜¶æ®µ3ï¼šç»“æœè¾“å‡º
    for result in rx2 {
        output_result(result);
    }
}

struct Data;
struct LoadedData;
struct ProcessedData;
fn load_data(_: Data) -> LoadedData { LoadedData }
fn compute(_: LoadedData) -> ProcessedData { ProcessedData }
fn output_result(_: ProcessedData) {}
```

### æ¡ˆä¾‹ 9: åˆ†å±‚ç¼“å­˜ç­–ç•¥

```rust
struct TieredCache<K, V> {
    l1: Vec<Option<(K, V)>>,     // å°è€Œå¿«çš„ç›´æ¥æ˜ å°„ç¼“å­˜
    l2: HashMap<K, V>,           // å¤§è€Œå…¨çš„å“ˆå¸Œè¡¨
    l1_size: usize,
}

impl<K: Clone + Eq + std::hash::Hash, V: Clone> TieredCache<K, V> {
    fn new(l1_size: usize) -> Self {
        Self {
            l1: vec![None; l1_size],
            l2: HashMap::new(),
            l1_size,
        }
    }
    
    fn get(&self, key: &K) -> Option<&V> {
        // L1å¿«é€ŸæŸ¥æ‰¾ï¼ˆ~2nsï¼‰
        let hash = self.hash(key);
        let index = hash % self.l1_size;
        
        if let Some((k, v)) = &self.l1[index] {
            if k == key {
                return Some(v);  // L1å‘½ä¸­
            }
        }
        
        // L2æŸ¥æ‰¾ï¼ˆ~20nsï¼‰
        self.l2.get(key)
    }
    
    fn insert(&mut self, key: K, value: V) {
        // åŒæ—¶æ’å…¥L1å’ŒL2
        let hash = self.hash(&key);
        let index = hash % self.l1_size;
        self.l1[index] = Some((key.clone(), value.clone()));
        self.l2.insert(key, value);
    }
    
    fn hash(&self, key: &K) -> usize {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        hasher.finish() as usize
    }
}
```

### æ¡ˆä¾‹ 10: é¢„è®¡ç®—ä¸æŸ¥è¡¨æ³•

```rust
// âœ… é¢„è®¡ç®—ä¸‰è§’å‡½æ•°è¡¨
struct SinTable {
    values: Vec<f32>,
    precision: usize,
}

impl SinTable {
    fn new(precision: usize) -> Self {
        let values: Vec<f32> = (0..precision)
            .map(|i| {
                let angle = (i as f32 / precision as f32) * 2.0 * std::f32::consts::PI;
                angle.sin()
            })
            .collect();
        
        Self { values, precision }
    }
    
    // æŸ¥è¡¨ï¼š~10x æ¯” sin() å¿«
    fn sin_fast(&self, angle: f32) -> f32 {
        let normalized = angle / (2.0 * std::f32::consts::PI);
        let index = ((normalized * self.precision as f32) as usize) % self.precision;
        self.values[index]
    }
}

// ä½¿ç”¨åœºæ™¯ï¼šæ¸¸æˆå¼•æ“ã€å®æ—¶æ¸²æŸ“
fn render_loop() {
    let sin_table = SinTable::new(1024);  // é¢„è®¡ç®—
    
    for frame in 0..10000 {
        let angle = frame as f32 * 0.01;
        let y = sin_table.sin_fast(angle);  // å¿«é€ŸæŸ¥è¡¨
        // render(y);
    }
}
```

---

## 11. è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜

| ç‰¹æ€§                  | Rust 1.82 | Rust 1.90 | è¯´æ˜                                  |
|-----------------------|-----------|-----------|---------------------------------------|
| åŸºç¡€æ³›å‹ä¼˜åŒ–          | ç¨³å®š      | ç¨³å®š      | å•æ€åŒ–ã€å†…è”                          |
| Constæ³›å‹             | ç¨³å®š      | ç¨³å®š      | ç¼–è¯‘æ—¶æ•°ç»„å¤§å°                        |
| Const fn æ‰©å±•         | éƒ¨åˆ†ç¨³å®š  | æ›´ç¨³å®š    | æ›´å¤šæ ‡å‡†åº“å‡½æ•°æ”¯æŒ                    |
| `#[inline]` å±æ€§      | ç¨³å®š      | ç¨³å®š      | å†…è”æ§åˆ¶                              |
| LTO (Link Time Opt)   | ç¨³å®š      | ç¨³å®š      | é“¾æ¥æ—¶ä¼˜åŒ–                            |
| PGO (Profile-Guided)  | ç¨³å®š      | ç¨³å®š      | æ€§èƒ½åˆ†æå¼•å¯¼ä¼˜åŒ–                      |
| `repr(C)` å¸ƒå±€        | ç¨³å®š      | ç¨³å®š      | Cå…¼å®¹å¸ƒå±€                             |
| `repr(transparent)`   | ç¨³å®š      | ç¨³å®š      | é€æ˜åŒ…è£…                              |
| SIMD (portable_simd)  | ä¸ç¨³å®š    | ä¸ç¨³å®š    | éœ€è¦ nightly + feature flag           |

**Rust 1.90 æ”¹è¿›**:

- æ›´æ¿€è¿›çš„å†…è”ä¼˜åŒ–
- æ”¹è¿›çš„LLVMåç«¯ï¼ˆæ›´å¥½çš„ä»£ç ç”Ÿæˆï¼‰
- æ›´å¿«çš„ç¼–è¯‘æ—¶è®¡ç®—
- å¢å¼ºçš„æ­»ä»£ç æ¶ˆé™¤

**è¿ç§»å»ºè®®**:

- å¯¹äºç”Ÿäº§ä»£ç ï¼Œä¼˜å…ˆä½¿ç”¨ç¨³å®šç‰¹æ€§
- SIMDå¯ä½¿ç”¨ `std::arch`ï¼ˆç¨³å®šï¼‰æˆ– `portable_simd`ï¼ˆå®éªŒï¼‰
- ä½¿ç”¨ `cargo +nightly rustc -- -Zprint-type-sizes` åˆ†æå¸ƒå±€

---

## 12. æ€»ç»“

**ä¼˜åŒ–æ¸…å•**:

| æŠ€æœ¯ | ä½•æ—¶ä½¿ç”¨ | æ”¶ç›Š |
|------|---------|------|
| **é™æ€åˆ†å‘** | æ€§èƒ½å…³é”®è·¯å¾„ | é«˜ |
| **å†…è”** | å°å‡½æ•° | ä¸­ |
| **å¸ƒå±€ä¼˜åŒ–** | å¤§é‡å°å¯¹è±¡ | ä¸­ |
| **é¿å…åˆ†é…** | çƒ­è·¯å¾„ | é«˜ |
| **SoA** | å¤§é‡æ•°æ®å¤„ç† | é«˜ |
| **SIMD** | æ•°å€¼è®¡ç®— | éå¸¸é«˜ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… å…ˆæµ‹é‡ï¼Œå†ä¼˜åŒ–
2. âœ… ä¼˜åŒ–çƒ­ç‚¹ï¼Œä¸æ˜¯å…¨éƒ¨
3. âœ… ä¿æŒä»£ç æ¸…æ™°
4. âœ… ä¿¡ä»»ç¼–è¯‘å™¨
5. âœ… é›¶æˆæœ¬æŠ½è±¡

---

## 13. å‚è€ƒèµ„æº

**å·¥å…·**:

- [Criterion](https://github.com/bheisler/criterion.rs)
- [Flamegraph](https://github.com/flamegraph-rs/flamegraph)
- [perf](https://perf.wiki.kernel.org/)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [3.3 åˆ†æ´¾æœºåˆ¶å‚è€ƒ](./03_åˆ†æ´¾æœºåˆ¶å‚è€ƒ.md)
- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆæ€§èƒ½ä¼˜åŒ–å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
