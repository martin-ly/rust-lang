# 3.5 Rust ç±»å‹ç³»ç»Ÿ - æ€§èƒ½ä¼˜åŒ–å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [3.3 åˆ†æ´¾æœºåˆ¶å‚è€ƒ](./03_åˆ†æ´¾æœºåˆ¶å‚è€ƒ.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.5 Rust ç±»å‹ç³»ç»Ÿ - æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](#35-rust-ç±»å‹ç³»ç»Ÿ---æ€§èƒ½ä¼˜åŒ–å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. é›¶æˆæœ¬æŠ½è±¡](#1-é›¶æˆæœ¬æŠ½è±¡)
    - [1.1 æ ¸å¿ƒåŸåˆ™](#11-æ ¸å¿ƒåŸåˆ™)
    - [1.2 å•æ€åŒ–](#12-å•æ€åŒ–)
    - [1.3 å†…è”ä¼˜åŒ–](#13-å†…è”ä¼˜åŒ–)
  - [2. å†…å­˜å¸ƒå±€ä¼˜åŒ–](#2-å†…å­˜å¸ƒå±€ä¼˜åŒ–)
    - [2.1 ç»“æ„ä½“å¸ƒå±€](#21-ç»“æ„ä½“å¸ƒå±€)
    - [2.2 æšä¸¾ä¼˜åŒ–](#22-æšä¸¾ä¼˜åŒ–)
    - [2.3 é›¶å¤§å°ç±»å‹](#23-é›¶å¤§å°ç±»å‹)
  - [3. é¿å…åˆ†é…](#3-é¿å…åˆ†é…)
    - [3.1 æ ˆ vs å †](#31-æ ˆ-vs-å †)
    - [3.2 SmallVec å’Œ Cow](#32-smallvec-å’Œ-cow)
    - [3.3 Arena åˆ†é…](#33-arena-åˆ†é…)
  - [4. ç¼–è¯‘æ—¶è®¡ç®—](#4-ç¼–è¯‘æ—¶è®¡ç®—)
    - [4.1 Const æ³›å‹](#41-const-æ³›å‹)
    - [4.2 Const å‡½æ•°](#42-const-å‡½æ•°)
    - [4.3 ç±»å‹çº§è®¡ç®—](#43-ç±»å‹çº§è®¡ç®—)
    - [4.4 ç¼–è¯‘æ—¶å­—ç¬¦ä¸²å¤„ç†](#44-ç¼–è¯‘æ—¶å­—ç¬¦ä¸²å¤„ç†)
    - [4.5 Build-Time Code Generation](#45-build-time-code-generation)
  - [5. ç¼“å­˜å‹å¥½](#5-ç¼“å­˜å‹å¥½)
    - [5.1 æ•°æ®å±€éƒ¨æ€§](#51-æ•°æ®å±€éƒ¨æ€§)
    - [5.2 å†…å­˜å¯¹é½](#52-å†…å­˜å¯¹é½)
    - [5.3 é¢„å–](#53-é¢„å–)
    - [5.4 å‘é‡åŒ–è®¡ç®—](#54-å‘é‡åŒ–è®¡ç®—)
    - [5.5 æ•°æ®ç»“æ„çš„ç¼“å­˜ä¼˜åŒ–](#55-æ•°æ®ç»“æ„çš„ç¼“å­˜ä¼˜åŒ–)
    - [5.6 æ‰¹å¤„ç†ä¼˜åŒ–](#56-æ‰¹å¤„ç†ä¼˜åŒ–)
  - [6. æ€§èƒ½æµ‹é‡](#6-æ€§èƒ½æµ‹é‡)
    - [6.1 Criterion](#61-criterion)
    - [6.2 Profiling](#62-profiling)
    - [6.3 ä¼˜åŒ–ç­–ç•¥](#63-ä¼˜åŒ–ç­–ç•¥)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: é«˜æ€§èƒ½é›†åˆ](#æ¡ˆä¾‹-1-é«˜æ€§èƒ½é›†åˆ)
    - [æ¡ˆä¾‹ 2: é›¶æ‹·è´è§£æ](#æ¡ˆä¾‹-2-é›¶æ‹·è´è§£æ)
    - [æ¡ˆä¾‹ 3: SIMD ä¼˜åŒ–](#æ¡ˆä¾‹-3-simd-ä¼˜åŒ–)
    - [æ¡ˆä¾‹ 4: è‡ªå®šä¹‰åˆ†é…å™¨](#æ¡ˆä¾‹-4-è‡ªå®šä¹‰åˆ†é…å™¨)
    - [æ¡ˆä¾‹ 5: å†…å­˜æ± ä¼˜åŒ–](#æ¡ˆä¾‹-5-å†…å­˜æ± ä¼˜åŒ–)
  - [8. å¸¸è§é™·é˜±](#8-å¸¸è§é™·é˜±)
  - [9. æ€»ç»“](#9-æ€»ç»“)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust çš„ç±»å‹ç³»ç»Ÿæä¾›äº†**é›¶æˆæœ¬æŠ½è±¡**ï¼š

| ä¼˜åŒ–ç»´åº¦ | æŠ€æœ¯ | æ”¶ç›Š |
|---------|------|------|
| **ç¼–è¯‘æ—¶** | å•æ€åŒ– + å†…è” | æ¶ˆé™¤æŠ½è±¡å¼€é”€ |
| **å†…å­˜** | å¸ƒå±€ä¼˜åŒ– + ZST | å‡å°‘å†…å­˜å ç”¨ |
| **åˆ†é…** | æ ˆåˆ†é… + Arena | å‡å°‘å †åˆ†é… |
| **ç¼“å­˜** | æ•°æ®å±€éƒ¨æ€§ + å¯¹é½ | æå‡ç¼“å­˜å‘½ä¸­ |

---

## 1. é›¶æˆæœ¬æŠ½è±¡

### 1.1 æ ¸å¿ƒåŸåˆ™

**"ä½ ä¸ç”¨çš„ä¸ä»˜è´¹ï¼Œä½ ä½¿ç”¨çš„æ— æ³•å†™å¾—æ›´å¿«"**-

```rust
// æŠ½è±¡ä»£ç 
fn sum_generic<T: std::iter::Iterator<Item = i32>>(iter: T) -> i32 {
    iter.sum()
}

// ç¼–è¯‘åç­‰ä»·äºæ‰‹å†™å¾ªç¯
fn sum_manual(slice: &[i32]) -> i32 {
    let mut total = 0;
    for &item in slice {
        total += item;
    }
    total
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // ä¸¤è€…æ€§èƒ½ç›¸åŒ
    let result1 = sum_generic(data.iter().copied());
    let result2 = sum_manual(&data);
    
    println!("{} {}", result1, result2);
}
```

### 1.2 å•æ€åŒ–

**ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨ä»£ç **:

```rust
fn process<T: std::fmt::Display>(value: T) {
    println!("Value: {}", value);
}

fn main() {
    process(42);      // ç”Ÿæˆ process_i32
    process(3.14);    // ç”Ÿæˆ process_f64
    process("hi");    // ç”Ÿæˆ process_str
}
```

**æ€§èƒ½å¯¹æ¯”**:

```rust
use std::time::Instant;

trait Compute {
    fn compute(&self) -> i64;
}

struct Simple(i64);

impl Compute for Simple {
    fn compute(&self) -> i64 {
        self.0 * 2
    }
}

// é™æ€åˆ†å‘
fn static_sum<T: Compute>(items: &[T]) -> i64 {
    items.iter().map(|x| x.compute()).sum()
}

// åŠ¨æ€åˆ†å‘
fn dynamic_sum(items: &[&dyn Compute]) -> i64 {
    items.iter().map(|x| x.compute()).sum()
}

fn main() {
    let items: Vec<Simple> = (0..1_000_000).map(Simple).collect();
    
    let start = Instant::now();
    let _result = static_sum(&items);
    println!("Static: {:?}", start.elapsed());
    
    let dyn_items: Vec<&dyn Compute> = items.iter()
        .map(|x| x as &dyn Compute)
        .collect();
    
    let start = Instant::now();
    let _result = dynamic_sum(&dyn_items);
    println!("Dynamic: {:?}", start.elapsed());
}
```

### 1.3 å†…è”ä¼˜åŒ–

**#[inline] å±æ€§**:

```rust
// æ€»æ˜¯å†…è”
#[inline(always)]
fn hot_function(x: i32) -> i32 {
    x * 2 + 1
}

// æç¤ºç¼–è¯‘å™¨å†…è”
#[inline]
fn warm_function(x: i32) -> i32 {
    x + 1
}

// ç¦æ­¢å†…è”
#[inline(never)]
fn cold_function(x: i32) -> i32 {
    println!("Called with {}", x);
    x
}

fn main() {
    let result = hot_function(21);
    println!("Result: {}", result);
}
```

---

## 2. å†…å­˜å¸ƒå±€ä¼˜åŒ–

### 2.1 ç»“æ„ä½“å¸ƒå±€

**å­—æ®µé¡ºåºå½±å“å¤§å°**:

```rust
use std::mem;

// âŒ æœªä¼˜åŒ–ï¼š16 å­—èŠ‚ (å¡«å……)
struct Unoptimized {
    a: u8,   // 1 byte
    // 3 bytes padding
    b: u32,  // 4 bytes
    c: u8,   // 1 byte
    // 3 bytes padding
}

// âœ… ä¼˜åŒ–ï¼š8 å­—èŠ‚
struct Optimized {
    b: u32,  // 4 bytes
    a: u8,   // 1 byte
    c: u8,   // 1 byte
    // 2 bytes padding
}

fn main() {
    println!("Unoptimized: {}", mem::size_of::<Unoptimized>());  // 12
    println!("Optimized: {}", mem::size_of::<Optimized>());      // 8
}
```

### 2.2 æšä¸¾ä¼˜åŒ–

**ç©ºæŒ‡é’ˆä¼˜åŒ–**:

```rust
use std::mem;

// Option<Box<T>> å¤§å°ç­‰äº Box<T>
fn main() {
    println!("Box<i32>: {}", mem::size_of::<Box<i32>>());           // 8
    println!("Option<Box<i32>>: {}", mem::size_of::<Option<Box<i32>>>());  // 8
    
    // åˆ©ç”¨ Box ä¸ä¸º nullï¼ŒNone ç”¨ null è¡¨ç¤º
}
```

**Discriminant ä¼˜åŒ–**:

```rust
use std::mem;

// å°æšä¸¾
enum Small {
    A,
    B,
    C,
}

// å¸¦æ•°æ®çš„æšä¸¾
enum WithData {
    A(u32),
    B(u64),
    C,
}

fn main() {
    println!("Small: {}", mem::size_of::<Small>());         // 1
    println!("WithData: {}", mem::size_of::<WithData>());   // 16 (8 + 8)
}
```

### 2.3 é›¶å¤§å°ç±»å‹

**ZST ä¸å ç©ºé—´**:

```rust
use std::mem;

struct Empty;

struct PhantomMarker<T> {
    _marker: std::marker::PhantomData<T>,
}

fn main() {
    println!("Empty: {}", mem::size_of::<Empty>());                // 0
    println!("PhantomMarker<i32>: {}", mem::size_of::<PhantomMarker<i32>>());  // 0
    
    // Vec çš„åˆ†é…ä¸å— ZST å½±å“
    let vec: Vec<Empty> = vec![Empty; 1000];
    println!("Vec<Empty> capacity: {}", vec.capacity());  // ä¸åˆ†é…
}
```

---

## 3. é¿å…åˆ†é…

### 3.1 æ ˆ vs å †

**ä¼˜å…ˆä½¿ç”¨æ ˆ**:

```rust
// âŒ å †åˆ†é…
fn heap_allocation() -> Box<[i32; 1000]> {
    Box::new([0; 1000])
}

// âœ… æ ˆåˆ†é…
fn stack_allocation() -> [i32; 1000] {
    [0; 1000]
}

// âœ… å¼•ç”¨ï¼Œé¿å…ç§»åŠ¨
fn reference_stack(data: &[i32; 1000]) {
    println!("Sum: {}", data.iter().sum::<i32>());
}

fn main() {
    let data = stack_allocation();
    reference_stack(&data);
}
```

### 3.2 SmallVec å’Œ Cow

**SmallVec**:

```rust
use smallvec::{SmallVec, smallvec};

fn main() {
    // å°æ•°æ®åœ¨æ ˆä¸Š
    let mut vec: SmallVec<[i32; 4]> = smallvec![1, 2, 3];
    println!("On stack: {:?}", vec);
    
    // è¶…å‡ºå®¹é‡åæ‰å †åˆ†é…
    vec.push(4);
    vec.push(5);
    println!("Now on heap: {:?}", vec);
}
```

**Cow (Clone on Write)**:

```rust
use std::borrow::Cow;

fn process(input: &str) -> Cow<str> {
    if input.contains("bad") {
        // éœ€è¦ä¿®æ”¹ï¼Œåˆ†é…
        Cow::Owned(input.replace("bad", "good"))
    } else {
        // ä¸éœ€è¦ä¿®æ”¹ï¼Œå€Ÿç”¨
        Cow::Borrowed(input)
    }
}

fn main() {
    let text1 = "This is bad";
    let text2 = "This is fine";
    
    let result1 = process(text1);  // åˆ†é…
    let result2 = process(text2);  // ä¸åˆ†é…
    
    println!("{} {}", result1, result2);
}
```

### 3.3 Arena åˆ†é…

**æ‰¹é‡åˆ†é…ï¼Œæ‰¹é‡é‡Šæ”¾**:

```rust
use typed_arena::Arena;

struct Node<'a> {
    value: i32,
    next: Option<&'a Node<'a>>,
}

fn main() {
    let arena = Arena::new();
    
    // åœ¨ arena ä¸­åˆ†é…ï¼Œæ— éœ€å•ç‹¬é‡Šæ”¾
    let node1 = arena.alloc(Node {
        value: 1,
        next: None,
    });
    
    let node2 = arena.alloc(Node {
        value: 2,
        next: Some(node1),
    });
    
    println!("Node2: {}", node2.value);
    
    // arena ææ„æ—¶ä¸€æ¬¡æ€§é‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹
}
```

---

## 4. ç¼–è¯‘æ—¶è®¡ç®—

### 4.1 Const æ³›å‹

**ç¼–è¯‘æ—¶ç¡®å®šæ•°ç»„å¤§å°**:

```rust
// æ³›å‹æ•°ç»„ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
fn sum<const N: usize>(arr: &[i32; N]) -> i32 {
    arr.iter().sum()
}

fn main() {
    let arr3 = [1, 2, 3];
    let arr5 = [1, 2, 3, 4, 5];
    
    println!("Sum3: {}", sum(&arr3));
    println!("Sum5: {}", sum(&arr5));
}
```

### 4.2 Const å‡½æ•°

**ç¼–è¯‘æ—¶æ±‚å€¼**:

```rust
const fn factorial(n: u32) -> u32 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

// ç¼–è¯‘æ—¶è®¡ç®—
const FACT_5: u32 = factorial(5);

fn main() {
    println!("5! = {}", FACT_5);  // 120ï¼Œç¼–è¯‘æ—¶å·²çŸ¥
}
```

### 4.3 ç±»å‹çº§è®¡ç®—

**ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œè®¡ç®—**:

```rust
use std::marker::PhantomData;

struct Zero;
struct Succ<N>(PhantomData<N>);

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// ç±»å‹çº§åŠ æ³•
trait Add<N> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
    Succ<N::Output>: Sized,
{
    type Output = Succ<N::Output>;
}

fn main() {
    // ç±»å‹ç³»ç»Ÿè¯æ˜ 1 + 2 = 3
    let _: <One as Add<Two>>::Output = Succ(PhantomData::<Two>);
}
```

### 4.4 ç¼–è¯‘æ—¶å­—ç¬¦ä¸²å¤„ç†

**const fnè¿›é˜¶**:

```rust
const fn parse_hex(s: &str) -> Option<u32> {
    let bytes = s.as_bytes();
    if bytes.len() == 0 {
        return None;
    }
    
    let mut result = 0u32;
    let mut i = 0;
    
    while i < bytes.len() {
        let digit = match bytes[i] {
            b'0'..=b'9' => bytes[i] - b'0',
            b'a'..=b'f' => bytes[i] - b'a' + 10,
            b'A'..=b'F' => bytes[i] - b'A' + 10,
            _ => return None,
        };
        
        result = result * 16 + digit as u32;
        i += 1;
    }
    
    Some(result)
}

const HEX_VALUE: u32 = match parse_hex("FF") {
    Some(v) => v,
    None => 0,
};

fn main() {
    println!("0xFF = {}", HEX_VALUE);  // 255ï¼Œç¼–è¯‘æ—¶å·²çŸ¥
}
```

### 4.5 Build-Time Code Generation

**ä½¿ç”¨build.rsç”Ÿæˆä»£ç **:

```rust
// build.rs
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("lookup_table.rs");
    let mut f = File::create(&dest_path).unwrap();
    
    // ç”ŸæˆæŸ¥æ‰¾è¡¨
    writeln!(f, "const LOOKUP_TABLE: [u32; 256] = [").unwrap();
    for i in 0..256 {
        writeln!(f, "    {},", compute_expensive(i)).unwrap();
    }
    writeln!(f, "];").unwrap();
}

fn compute_expensive(x: u32) -> u32 {
    // æ˜‚è´µçš„è®¡ç®—ï¼Œåœ¨ç¼–è¯‘æ—¶æ‰§è¡Œ
    x * x + 2 * x + 1
}
```

```rust
// main.rs
include!(concat!(env!("OUT_DIR"), "/lookup_table.rs"));

fn fast_compute(x: u8) -> u32 {
    LOOKUP_TABLE[x as usize]  // O(1)æŸ¥æ‰¾ï¼Œæ— è¿è¡Œæ—¶è®¡ç®—
}

fn main() {
    println!("Value: {}", fast_compute(10));
}
```

---

## 5. ç¼“å­˜å‹å¥½

### 5.1 æ•°æ®å±€éƒ¨æ€§

**SoA vs AoS**:

```rust
// âŒ AoS (Array of Structs) - ç¼“å­˜ä¸å‹å¥½
struct PointAoS {
    x: f32,
    y: f32,
    z: f32,
}

fn sum_x_aos(points: &[PointAoS]) -> f32 {
    points.iter().map(|p| p.x).sum()
}

// âœ… SoA (Struct of Arrays) - ç¼“å­˜å‹å¥½
struct PointsSoA {
    x: Vec<f32>,
    y: Vec<f32>,
    z: Vec<f32>,
}

fn sum_x_soa(points: &PointsSoA) -> f32 {
    points.x.iter().sum()
}

fn main() {
    let aos: Vec<PointAoS> = vec![
        PointAoS { x: 1.0, y: 2.0, z: 3.0 },
        PointAoS { x: 4.0, y: 5.0, z: 6.0 },
    ];
    
    let soa = PointsSoA {
        x: vec![1.0, 4.0],
        y: vec![2.0, 5.0],
        z: vec![3.0, 6.0],
    };
    
    println!("AoS sum: {}", sum_x_aos(&aos));
    println!("SoA sum: {}", sum_x_soa(&soa));
}
```

### 5.2 å†…å­˜å¯¹é½

**å¯¹é½åˆ°ç¼“å­˜è¡Œ**:

```rust
use std::mem;

#[repr(align(64))]  // å¯¹é½åˆ°å…¸å‹ç¼“å­˜è¡Œå¤§å°
struct CacheLineAligned {
    data: [u8; 64],
}

fn main() {
    println!("Alignment: {}", mem::align_of::<CacheLineAligned>());
}
```

### 5.3 é¢„å–

**é¢„å–æ•°æ®åˆ°ç¼“å­˜**:

```rust
use std::arch::x86_64::{_mm_prefetch, _MM_HINT_T0};

fn process_with_prefetch(data: &[i32]) -> i64 {
    let mut sum = 0i64;
    
    for i in 0..data.len() {
        // é¢„å–ä¸‹ä¸€ä¸ªå…ƒç´ 
        if i + 1 < data.len() {
            unsafe {
                _mm_prefetch(
                    &data[i + 1] as *const i32 as *const i8,
                    _MM_HINT_T0,
                );
            }
        }
        sum += data[i] as i64;
    }
    
    sum
}

fn main() {
    let data: Vec<i32> = (0..1000).collect();
    let result = process_with_prefetch(&data);
    println!("Sum: {}", result);
}
```

### 5.4 å‘é‡åŒ–è®¡ç®—

**SIMDä¼˜åŒ–**:

```rust
use std::arch::x86_64::*;

// æ ‡é‡ç‰ˆæœ¬
fn add_scalar(a: &[f32], b: &[f32], result: &mut [f32]) {
    for i in 0..a.len() {
        result[i] = a[i] + b[i];
    }
}

// SIMDç‰ˆæœ¬ï¼ˆä½¿ç”¨AVXï¼‰
#[target_feature(enable = "avx")]
unsafe fn add_simd(a: &[f32], b: &[f32], result: &mut [f32]) {
    let chunks = a.len() / 8;
    
    for i in 0..chunks {
        let offset = i * 8;
        
        // åŠ è½½8ä¸ªæµ®ç‚¹æ•°
        let va = _mm256_loadu_ps(a.as_ptr().add(offset));
        let vb = _mm256_loadu_ps(b.as_ptr().add(offset));
        
        // å‘é‡åŠ æ³•
        let vr = _mm256_add_ps(va, vb);
        
        // å­˜å‚¨ç»“æœ
        _mm256_storeu_ps(result.as_mut_ptr().add(offset), vr);
    }
    
    // å¤„ç†å‰©ä½™å…ƒç´ 
    for i in (chunks * 8)..a.len() {
        result[i] = a[i] + b[i];
    }
}

fn main() {
    let a = vec![1.0f32; 1000];
    let b = vec![2.0f32; 1000];
    let mut result = vec![0.0f32; 1000];
    
    unsafe {
        add_simd(&a, &b, &mut result);
    }
}
```

### 5.5 æ•°æ®ç»“æ„çš„ç¼“å­˜ä¼˜åŒ–

**çƒ­/å†·æ•°æ®åˆ†ç¦»**:

```rust
// âŒ æ··åˆå­˜å‚¨ï¼ˆç¼“å­˜ä¸å‹å¥½ï¼‰
struct EntityBad {
    id: u32,
    position: (f32, f32, f32),
    velocity: (f32, f32, f32),
    health: f32,
    name: String,          // ä¸å¸¸è®¿é—®
    description: String,   // ä¸å¸¸è®¿é—®
}

// âœ… åˆ†ç¦»å­˜å‚¨ï¼ˆç¼“å­˜å‹å¥½ï¼‰
struct EntityHot {
    id: u32,
    position: (f32, f32, f32),
    velocity: (f32, f32, f32),
    health: f32,
    cold_index: usize,  // æŒ‡å‘å†·æ•°æ®
}

struct EntityCold {
    name: String,
    description: String,
}

struct EntitySystem {
    hot: Vec<EntityHot>,
    cold: Vec<EntityCold>,
}

impl EntitySystem {
    fn update_positions(&mut self, dt: f32) {
        // åªè®¿é—®çƒ­æ•°æ®ï¼Œç¼“å­˜å‹å¥½
        for entity in &mut self.hot {
            entity.position.0 += entity.velocity.0 * dt;
            entity.position.1 += entity.velocity.1 * dt;
            entity.position.2 += entity.velocity.2 * dt;
        }
    }
}
```

### 5.6 æ‰¹å¤„ç†ä¼˜åŒ–

**æ‰¹é‡å¤„ç†æå‡ç¼“å­˜å‘½ä¸­**:

```rust
// âŒ é€ä¸ªå¤„ç†
fn process_individually(items: &[Item]) {
    for item in items {
        expensive_operation(item);
    }
}

// âœ… æ‰¹é‡å¤„ç†
fn process_batched(items: &[Item]) {
    const BATCH_SIZE: usize = 64;
    
    for batch in items.chunks(BATCH_SIZE) {
        // é¢„å¤„ç†æ•´ä¸ªæ‰¹æ¬¡
        let mut preprocessed = Vec::with_capacity(BATCH_SIZE);
        for item in batch {
            preprocessed.push(preprocess(item));
        }
        
        // æ‰¹é‡å¤„ç†
        for data in preprocessed {
            cheap_operation(&data);
        }
    }
}

struct Item {
    data: [u8; 16],
}

fn preprocess(item: &Item) -> [u8; 16] {
    item.data
}

fn cheap_operation(_data: &[u8; 16]) {
    // å¿«é€Ÿæ“ä½œ
}

fn expensive_operation(_item: &Item) {
    // æ˜‚è´µæ“ä½œ
}
```

---

## 6. æ€§èƒ½æµ‹é‡

### 6.1 Criterion

**åŸºå‡†æµ‹è¯•**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 | 1 => n,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

### 6.2 Profiling

**ä½¿ç”¨ perf/flamegraph**:

```bash
# Linux perf
cargo build --release
perf record --call-graph dwarf ./target/release/myapp
perf report

# Flamegraph
cargo flamegraph
```

### 6.3 ä¼˜åŒ–ç­–ç•¥

**é€æ­¥ä¼˜åŒ–**:

1. **æµ‹é‡**: å…ˆæµ‹é‡ï¼Œæ‰¾åˆ°ç“¶é¢ˆ
2. **ä¼˜åŒ–**: é’ˆå¯¹çƒ­ç‚¹ä¼˜åŒ–
3. **éªŒè¯**: å†æ¬¡æµ‹é‡ï¼Œç¡®è®¤æ•ˆæœ

```rust
use std::time::Instant;

fn benchmark<F: Fn()>(name: &str, f: F) {
    let start = Instant::now();
    f();
    println!("{}: {:?}", name, start.elapsed());
}

fn main() {
    benchmark("Version 1", || {
        // å®ç° 1
    });
    
    benchmark("Version 2", || {
        // å®ç° 2
    });
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: é«˜æ€§èƒ½é›†åˆ

```rust
use std::collections::HashMap;

// é¢„åˆ†é…å®¹é‡
fn optimized_hashmap() -> HashMap<i32, String> {
    let mut map = HashMap::with_capacity(1000);
    
    for i in 0..1000 {
        map.insert(i, format!("value{}", i));
    }
    
    map
}

// ä½¿ç”¨ FxHash (æ›´å¿«çš„å“ˆå¸Œ)
use rustc_hash::FxHashMap;

fn fast_hashmap() -> FxHashMap<i32, String> {
    let mut map = FxHashMap::default();
    
    for i in 0..1000 {
        map.insert(i, format!("value{}", i));
    }
    
    map
}

fn main() {
    let _map1 = optimized_hashmap();
    let _map2 = fast_hashmap();
}
```

### æ¡ˆä¾‹ 2: é›¶æ‹·è´è§£æ

```rust
use std::str;

// âŒ åˆ†é…æ–°å­—ç¬¦ä¸²
fn parse_owned(data: &[u8]) -> Vec<String> {
    str::from_utf8(data)
        .unwrap()
        .split(',')
        .map(|s| s.to_string())
        .collect()
}

// âœ… é›¶æ‹·è´ï¼Œè¿”å›åˆ‡ç‰‡
fn parse_borrowed(data: &[u8]) -> Vec<&str> {
    str::from_utf8(data)
        .unwrap()
        .split(',')
        .collect()
}

fn main() {
    let data = b"a,b,c,d,e";
    
    let owned = parse_owned(data);
    let borrowed = parse_borrowed(data);
    
    println!("Owned: {:?}", owned);
    println!("Borrowed: {:?}", borrowed);
}
```

### æ¡ˆä¾‹ 3: SIMD ä¼˜åŒ–

```rust
use std::arch::x86_64::*;

// æ ‡é‡ç‰ˆæœ¬
fn sum_scalar(data: &[f32]) -> f32 {
    data.iter().sum()
}

// SIMD ç‰ˆæœ¬
unsafe fn sum_simd(data: &[f32]) -> f32 {
    let mut sum = _mm_setzero_ps();
    let chunks = data.chunks_exact(4);
    let remainder = chunks.remainder();
    
    for chunk in chunks {
        let values = _mm_loadu_ps(chunk.as_ptr());
        sum = _mm_add_ps(sum, values);
    }
    
    // æ°´å¹³æ±‚å’Œ
    let mut result = [0f32; 4];
    _mm_storeu_ps(result.as_mut_ptr(), sum);
    let total = result.iter().sum::<f32>();
    
    // åŠ ä¸Šä½™æ•°
    total + remainder.iter().sum::<f32>()
}

fn main() {
    let data: Vec<f32> = (0..1000).map(|x| x as f32).collect();
    
    let result1 = sum_scalar(&data);
    let result2 = unsafe { sum_simd(&data) };
    
    println!("Scalar: {}", result1);
    println!("SIMD: {}", result2);
}
```

### æ¡ˆä¾‹ 4: è‡ªå®šä¹‰åˆ†é…å™¨

**ä½¿ç”¨è‡ªå®šä¹‰åˆ†é…å™¨**:

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::ptr;

struct CountingAllocator;

static mut ALLOCATION_COUNT: usize = 0;

unsafe impl GlobalAlloc for CountingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        ALLOCATION_COUNT += 1;
        System.alloc(layout)
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: CountingAllocator = CountingAllocator;

fn main() {
    let data: Vec<i32> = vec![1, 2, 3, 4, 5];
    println!("Allocated {} times", unsafe { ALLOCATION_COUNT });
}
```

### æ¡ˆä¾‹ 5: å†…å­˜æ± ä¼˜åŒ–

**å¯¹è±¡æ± æ¨¡å¼**:

```rust
use std::sync::Mutex;

struct ObjectPool<T> {
    objects: Mutex<Vec<T>>,
    factory: fn() -> T,
}

impl<T> ObjectPool<T> {
    fn new(factory: fn() -> T, initial_size: usize) -> Self {
        let objects = (0..initial_size).map(|_| factory()).collect();
        ObjectPool {
            objects: Mutex::new(objects),
            factory,
        }
    }
    
    fn acquire(&self) -> PooledObject<T> {
        let obj = self.objects.lock().unwrap().pop()
            .unwrap_or_else(|| (self.factory)());
        PooledObject {
            pool: self,
            obj: Some(obj),
        }
    }
    
    fn release(&self, obj: T) {
        self.objects.lock().unwrap().push(obj);
    }
}

struct PooledObject<'a, T> {
    pool: &'a ObjectPool<T>,
    obj: Option<T>,
}

impl<'a, T> Drop for PooledObject<'a, T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.release(obj);
        }
    }
}

impl<'a, T> std::ops::Deref for PooledObject<'a, T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.obj.as_ref().unwrap()
    }
}

impl<'a, T> std::ops::DerefMut for PooledObject<'a, T> {
    fn deref_mut(&mut self) -> &mut T {
        self.obj.as_mut().unwrap()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let pool = ObjectPool::new(Vec::<i32>::new, 10);
    
    {
        let mut obj = pool.acquire();
        obj.push(1);
        obj.push(2);
        // è‡ªåŠ¨å½’è¿˜åˆ°æ± ä¸­
    }
    
    let obj2 = pool.acquire();  // é‡ç”¨ä¹‹å‰çš„ Vec
    println!("Len: {}", obj2.len());
}
```

---

## 8. å¸¸è§é™·é˜±

**é™·é˜± 1: è¿‡æ—©ä¼˜åŒ–**:

```rust
// âŒ ä¸å¿…è¦çš„ä¼˜åŒ–
// fn complex_optimization() { ... }

// âœ… å…ˆå†™æ¸…æ™°ä»£ç ï¼Œå†ä¼˜åŒ–ç“¶é¢ˆ
fn clear_code() {
    // æ¸…æ™°æ˜“æ‡‚çš„å®ç°
}
```

**é™·é˜± 2: ä¸æµ‹é‡å°±ä¼˜åŒ–**:

```rust
// âŒ å‡­æ„Ÿè§‰ä¼˜åŒ–
// "è¿™ä¸ªåº”è¯¥æ›´å¿«"

// âœ… åŸºäºæ•°æ®ä¼˜åŒ–
use criterion::{black_box, Criterion};

fn benchmark(c: &mut Criterion) {
    c.bench_function("version_a", |b| {
        b.iter(|| black_box(version_a()))
    });
    
    c.bench_function("version_b", |b| {
        b.iter(|| black_box(version_b()))
    });
}

fn version_a() {}
fn version_b() {}
```

**é™·é˜± 3: å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–**:

```rust
// ç¼–è¯‘å™¨å·²ç»å¾ˆæ™ºèƒ½
// ä¸è¦è¿‡åº¦æ‰‹åŠ¨ä¼˜åŒ–

// âœ… ä¿¡ä»»ç¼–è¯‘å™¨
fn simple_sum(data: &[i32]) -> i32 {
    data.iter().sum()  // å·²ç»å¾ˆå¿«
}
```

---

## 9. æ€»ç»“

**ä¼˜åŒ–æ¸…å•**:

| æŠ€æœ¯ | ä½•æ—¶ä½¿ç”¨ | æ”¶ç›Š |
|------|---------|------|
| **é™æ€åˆ†å‘** | æ€§èƒ½å…³é”®è·¯å¾„ | é«˜ |
| **å†…è”** | å°å‡½æ•° | ä¸­ |
| **å¸ƒå±€ä¼˜åŒ–** | å¤§é‡å°å¯¹è±¡ | ä¸­ |
| **é¿å…åˆ†é…** | çƒ­è·¯å¾„ | é«˜ |
| **SoA** | å¤§é‡æ•°æ®å¤„ç† | é«˜ |
| **SIMD** | æ•°å€¼è®¡ç®— | éå¸¸é«˜ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… å…ˆæµ‹é‡ï¼Œå†ä¼˜åŒ–
2. âœ… ä¼˜åŒ–çƒ­ç‚¹ï¼Œä¸æ˜¯å…¨éƒ¨
3. âœ… ä¿æŒä»£ç æ¸…æ™°
4. âœ… ä¿¡ä»»ç¼–è¯‘å™¨
5. âœ… é›¶æˆæœ¬æŠ½è±¡

---

## 10. å‚è€ƒèµ„æº

**å·¥å…·**:

- [Criterion](https://github.com/bheisler/criterion.rs)
- [Flamegraph](https://github.com/flamegraph-rs/flamegraph)
- [perf](https://perf.wiki.kernel.org/)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [3.3 åˆ†æ´¾æœºåˆ¶å‚è€ƒ](./03_åˆ†æ´¾æœºåˆ¶å‚è€ƒ.md)
- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆæ€§èƒ½ä¼˜åŒ–å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
