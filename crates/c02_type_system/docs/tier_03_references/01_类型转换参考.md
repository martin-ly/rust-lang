# 3.1 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹è½¬æ¢å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹è½¬æ¢æœºåˆ¶å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.1 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹è½¬æ¢å‚è€ƒ](#31-rust-ç±»å‹ç³»ç»Ÿ---ç±»å‹è½¬æ¢å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. From å’Œ Into](#1-from-å’Œ-into)
    - [1.1 From Trait](#11-from-trait)
    - [1.2 Into Trait](#12-into-trait)
    - [1.3 è‡ªåŠ¨å®ç°](#13-è‡ªåŠ¨å®ç°)
    - [1.4 ä½¿ç”¨åœºæ™¯](#14-ä½¿ç”¨åœºæ™¯)
  - [2. TryFrom å’Œ TryInto](#2-tryfrom-å’Œ-tryinto)
    - [2.1 å¯å¤±è´¥è½¬æ¢](#21-å¯å¤±è´¥è½¬æ¢)
    - [2.2 é”™è¯¯å¤„ç†](#22-é”™è¯¯å¤„ç†)
    - [2.3 å®é™…åº”ç”¨](#23-å®é™…åº”ç”¨)
  - [3. AsRef å’Œ AsMut](#3-asref-å’Œ-asmut)
    - [3.1 å¼•ç”¨è½¬æ¢](#31-å¼•ç”¨è½¬æ¢)
    - [3.2 é€šç”¨ API è®¾è®¡](#32-é€šç”¨-api-è®¾è®¡)
    - [3.3 å¸¸è§ç”¨ä¾‹](#33-å¸¸è§ç”¨ä¾‹)
  - [4. Deref å’Œ DerefMut](#4-deref-å’Œ-derefmut)
    - [4.1 è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢](#41-è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢)
    - [4.2 æ™ºèƒ½æŒ‡é’ˆ](#42-æ™ºèƒ½æŒ‡é’ˆ)
    - [4.3 Newtype æ¨¡å¼](#43-newtype-æ¨¡å¼)
  - [5. Borrow å’Œ BorrowMut](#5-borrow-å’Œ-borrowmut)
    - [5.1 å€Ÿç”¨è¯­ä¹‰](#51-å€Ÿç”¨è¯­ä¹‰)
    - [5.2 ä¸ AsRef çš„åŒºåˆ«](#52-ä¸-asref-çš„åŒºåˆ«)
  - [6. ToOwned å’Œ Cow](#6-toowned-å’Œ-cow)
    - [6.1 å…‹éš†åˆ°æ‰€æœ‰æƒ](#61-å…‹éš†åˆ°æ‰€æœ‰æƒ)
    - [6.2 å†™æ—¶å…‹éš†](#62-å†™æ—¶å…‹éš†)
  - [7. ToString å’Œ Display](#7-tostring-å’Œ-display)
    - [7.1 å­—ç¬¦ä¸²è½¬æ¢](#71-å­—ç¬¦ä¸²è½¬æ¢)
    - [7.2 æ ¼å¼åŒ–è¾“å‡º](#72-æ ¼å¼åŒ–è¾“å‡º)
  - [8. as ç±»å‹è½¬æ¢](#8-as-ç±»å‹è½¬æ¢)
    - [8.1 åŸºç¡€ç±»å‹è½¬æ¢](#81-åŸºç¡€ç±»å‹è½¬æ¢)
    - [8.2 æŒ‡é’ˆè½¬æ¢](#82-æŒ‡é’ˆè½¬æ¢)
    - [8.3 ä½¿ç”¨é™åˆ¶](#83-ä½¿ç”¨é™åˆ¶)
  - [9. è½¬æ¢æœ€ä½³å®è·µ](#9-è½¬æ¢æœ€ä½³å®è·µ)
    - [9.1 é€‰æ‹©åˆé€‚çš„ Trait](#91-é€‰æ‹©åˆé€‚çš„-trait)
    - [9.2 æ€§èƒ½è€ƒè™‘](#92-æ€§èƒ½è€ƒè™‘)
    - [9.3 API è®¾è®¡](#93-api-è®¾è®¡)
  - [10. æ€»ç»“](#10-æ€»ç»“)
  - [11. å‚è€ƒèµ„æº](#11-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust æä¾›äº†ä¸°å¯Œçš„ç±»å‹è½¬æ¢æœºåˆ¶ï¼Œæ¯ç§éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œè¯­ä¹‰ï¼š

| Trait | ç”¨é€” | æ‰€æœ‰æƒ | å¤±è´¥å¤„ç† |
|-------|------|--------|---------|
| **From/Into** | å€¼è½¬æ¢ | æ¶ˆè€— | ä¸å¯å¤±è´¥ |
| **TryFrom/TryInto** | å€¼è½¬æ¢ | æ¶ˆè€— | å¯å¤±è´¥ |
| **AsRef/AsMut** | å¼•ç”¨è½¬æ¢ | å€Ÿç”¨ | ä¸å¯å¤±è´¥ |
| **Deref/DerefMut** | è§£å¼•ç”¨ | å€Ÿç”¨ | ä¸å¯å¤±è´¥ |
| **Borrow/BorrowMut** | å€Ÿç”¨è½¬æ¢ | å€Ÿç”¨ | ä¸å¯å¤±è´¥ |
| **ToOwned** | å…‹éš†åˆ°æ‰€æœ‰æƒ | åˆ›å»º | ä¸å¯å¤±è´¥ |
| **ToString** | å­—ç¬¦ä¸²è½¬æ¢ | åˆ›å»º | ä¸å¯å¤±è´¥ |

---

## 1. From å’Œ Into

### 1.1 From Trait

**å®šä¹‰**:

```rust
pub trait From<T>: Sized {
    fn from(value: T) -> Self;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl From<(i32, i32)> for Point {
    fn from(tuple: (i32, i32)) -> Self {
        Point {
            x: tuple.0,
            y: tuple.1,
        }
    }
}

fn main() {
    let point = Point::from((3, 4));
    println!("Point: ({}, {})", point.x, point.y);
}
```

### 1.2 Into Trait

**å®šä¹‰**:

```rust
pub trait Into<T>: Sized {
    fn into(self) -> T;
}
```

**ä½¿ç”¨ Into**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl From<(i32, i32)> for Point {
    fn from(tuple: (i32, i32)) -> Self {
        Point {
            x: tuple.0,
            y: tuple.1,
        }
    }
}

fn main() {
    // Into è‡ªåŠ¨å®ç°
    let point: Point = (3, 4).into();
    println!("Point: ({}, {})", point.x, point.y);
}
```

### 1.3 è‡ªåŠ¨å®ç°

**From è•´å« Into**:

```rust
// å®ç° From<T> for U
impl From<String> for Vec<u8> {
    fn from(s: String) -> Vec<u8> {
        s.into_bytes()
    }
}

// è‡ªåŠ¨è·å¾— Into<Vec<u8>> for String
fn main() {
    let s = String::from("hello");
    
    // ä½¿ç”¨ From
    let bytes1 = Vec::<u8>::from(s.clone());
    
    // ä½¿ç”¨ Into
    let bytes2: Vec<u8> = s.into();
    
    println!("Bytes: {:?}", bytes1);
}
```

### 1.4 ä½¿ç”¨åœºæ™¯

**API è®¾è®¡**:

```rust
use std::net::{IpAddr, Ipv4Addr};

struct Connection {
    addr: IpAddr,
    port: u16,
}

impl Connection {
    // æ¥å—ä»»ä½•å¯ä»¥è½¬æ¢ä¸º IpAddr çš„ç±»å‹
    fn new<A: Into<IpAddr>>(addr: A, port: u16) -> Self {
        Connection {
            addr: addr.into(),
            port,
        }
    }
}

fn main() {
    // ä» Ipv4Addr åˆ›å»º
    let conn1 = Connection::new(Ipv4Addr::new(127, 0, 0, 1), 8080);
    
    // ä» IpAddr åˆ›å»º
    let ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1));
    let conn2 = Connection::new(ip, 3000);
    
    println!("Connection 1: {}:{}", conn1.addr, conn1.port);
    println!("Connection 2: {}:{}", conn2.addr, conn2.port);
}
```

**é”™è¯¯è½¬æ¢**:

```rust
use std::fmt;
use std::io;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "IO error: {}", e),
            AppError::Parse(s) => write!(f, "Parse error: {}", s),
        }
    }
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

fn read_file() -> Result<String, AppError> {
    std::fs::read_to_string("file.txt")?  // ? è‡ªåŠ¨è½¬æ¢
}

fn main() {
    match read_file() {
        Ok(content) => println!("Content: {}", content),
        Err(e) => println!("Error: {}", e),
    }
}
```

---

## 2. TryFrom å’Œ TryInto

### 2.1 å¯å¤±è´¥è½¬æ¢

**å®šä¹‰**:

```rust
pub trait TryFrom<T>: Sized {
    type Error;
    fn try_from(value: T) -> Result<Self, Self::Error>;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::convert::TryFrom;

struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = String;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(format!("{} is not an even number", value))
        }
    }
}

fn main() {
    // æˆåŠŸæƒ…å†µ
    match EvenNumber::try_from(4) {
        Ok(n) => println!("Even number: {}", n.0),
        Err(e) => println!("Error: {}", e),
    }
    
    // å¤±è´¥æƒ…å†µ
    match EvenNumber::try_from(3) {
        Ok(n) => println!("Even number: {}", n.0),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2.2 é”™è¯¯å¤„ç†

**è‡ªå®šä¹‰é”™è¯¯ç±»å‹**:

```rust
use std::convert::TryFrom;
use std::fmt;

#[derive(Debug)]
struct InvalidAge;

impl fmt::Display for InvalidAge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Age must be between 0 and 150")
    }
}

struct Age(u8);

impl TryFrom<i32> for Age {
    type Error = InvalidAge;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value >= 0 && value <= 150 {
            Ok(Age(value as u8))
        } else {
            Err(InvalidAge)
        }
    }
}

fn main() {
    match Age::try_from(25) {
        Ok(age) => println!("Valid age: {}", age.0),
        Err(e) => println!("Error: {}", e),
    }
    
    match Age::try_from(200) {
        Ok(age) => println!("Valid age: {}", age.0),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2.3 å®é™…åº”ç”¨

**æ•°å€¼èŒƒå›´é™åˆ¶**:

```rust
use std::convert::TryFrom;

struct Port(u16);

impl TryFrom<i32> for Port {
    type Error = &'static str;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value > 0 && value <= 65535 {
            Ok(Port(value as u16))
        } else {
            Err("Port must be between 1 and 65535")
        }
    }
}

fn create_server(port_num: i32) -> Result<(), &'static str> {
    let port = Port::try_from(port_num)?;
    println!("Server listening on port {}", port.0);
    Ok(())
}

fn main() {
    create_server(8080).unwrap();
    // create_server(70000).unwrap(); // ä¼š panic
}
```

---

## 3. AsRef å’Œ AsMut

### 3.1 å¼•ç”¨è½¬æ¢

**å®šä¹‰**:

```rust
pub trait AsRef<T: ?Sized> {
    fn as_ref(&self) -> &T;
}

pub trait AsMut<T: ?Sized> {
    fn as_mut(&mut self) -> &mut T;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
fn print_slice<T: AsRef<[i32]>>(slice: T) {
    let s = slice.as_ref();
    println!("{:?}", s);
}

fn main() {
    print_slice(&[1, 2, 3]);        // &[i32]
    print_slice(vec![1, 2, 3]);     // Vec<i32>
    print_slice([1, 2, 3]);         // [i32; 3]
}
```

### 3.2 é€šç”¨ API è®¾è®¡

**æ–‡ä»¶è·¯å¾„**:

```rust
use std::fs::File;
use std::io::{self, Read};
use std::path::Path;

fn read_file<P: AsRef<Path>>(path: P) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() -> io::Result<()> {
    // æ¥å— &str
    let _ = read_file("file.txt");
    
    // æ¥å— String
    let _ = read_file(String::from("file.txt"));
    
    // æ¥å— Path
    let _ = read_file(Path::new("file.txt"));
    
    Ok(())
}
```

### 3.3 å¸¸è§ç”¨ä¾‹

**Boxed åˆ‡ç‰‡**:

```rust
struct Wrapper {
    data: Box<[u8]>,
}

impl AsRef<[u8]> for Wrapper {
    fn as_ref(&self) -> &[u8] {
        &self.data
    }
}

fn process_bytes<T: AsRef<[u8]>>(data: T) {
    let bytes = data.as_ref();
    println!("Processing {} bytes", bytes.len());
}

fn main() {
    let wrapper = Wrapper {
        data: vec![1, 2, 3, 4].into_boxed_slice(),
    };
    
    process_bytes(&wrapper);
    process_bytes(vec![5, 6, 7]);
}
```

---

## 4. Deref å’Œ DerefMut

### 4.1 è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢

**å®šä¹‰**:

```rust
pub trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

**åŸºæœ¬ç¤ºä¾‹**:

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y);  // è§£å¼•ç”¨
}
```

### 4.2 æ™ºèƒ½æŒ‡é’ˆ

**è‡ªåŠ¨è§£å¼•ç”¨**:

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = Box::new(String::from("Rust"));
    
    // Box<String> -> String -> &str
    hello(&m);  // ç¼–è¯‘å™¨è‡ªåŠ¨æ’å…¥ deref
}
```

**Rc å’Œ Arc**:

```rust
use std::rc::Rc;

fn main() {
    let shared = Rc::new(String::from("shared data"));
    
    // Rc å®ç°äº† Deref
    let len = shared.len();  // è‡ªåŠ¨è§£å¼•ç”¨åˆ° String
    println!("Length: {}", len);
}
```

### 4.3 Newtype æ¨¡å¼

```rust
use std::ops::Deref;

struct Meters(f64);

impl Deref for Meters {
    type Target = f64;
    
    fn deref(&self) -> &f64 {
        &self.0
    }
}

fn main() {
    let distance = Meters(100.0);
    
    // å¯ä»¥åƒ f64 ä¸€æ ·ä½¿ç”¨
    let doubled = *distance * 2.0;
    println!("Doubled: {}", doubled);
}
```

---

## 5. Borrow å’Œ BorrowMut

### 5.1 å€Ÿç”¨è¯­ä¹‰

**å®šä¹‰**:

```rust
pub trait Borrow<Borrowed: ?Sized> {
    fn borrow(&self) -> &Borrowed;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::borrow::Borrow;
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(String::from("key"), "value");
    
    // å¯ä»¥ç”¨ &str æŸ¥è¯¢ String é”®
    println!("{:?}", map.get("key"));
}
```

### 5.2 ä¸ AsRef çš„åŒºåˆ«

**Borrow vs AsRef**:

```rust
use std::borrow::Borrow;

// Borrow è¦æ±‚ Hash/Eq/Ord ä¿æŒä¸€è‡´
// AsRef åªæ˜¯å¼•ç”¨è½¬æ¢

fn check_borrow<T: Borrow<str>>(s: T) {
    let borrowed: &str = s.borrow();
    println!("{}", borrowed);
}

fn check_asref<T: AsRef<str>>(s: T) {
    let referenced: &str = s.as_ref();
    println!("{}", referenced);
}

fn main() {
    let s = String::from("hello");
    
    check_borrow(&s);
    check_asref(&s);
}
```

---

## 6. ToOwned å’Œ Cow

### 6.1 å…‹éš†åˆ°æ‰€æœ‰æƒ

**å®šä¹‰**:

```rust
pub trait ToOwned {
    type Owned: Borrow<Self>;
    fn to_owned(&self) -> Self::Owned;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
fn main() {
    let s: &str = "hello";
    let owned: String = s.to_owned();
    
    println!("Borrowed: {}", s);
    println!("Owned: {}", owned);
}
```

### 6.2 å†™æ—¶å…‹éš†

**Cow (Clone-on-Write)**:

```rust
use std::borrow::Cow;

fn process_text(input: &str) -> Cow<str> {
    if input.contains("bad") {
        // éœ€è¦ä¿®æ”¹ï¼Œåˆ›å»ºæ‹¥æœ‰çš„ç‰ˆæœ¬
        Cow::Owned(input.replace("bad", "good"))
    } else {
        // ä¸éœ€è¦ä¿®æ”¹ï¼Œå€Ÿç”¨
        Cow::Borrowed(input)
    }
}

fn main() {
    let text1 = "This is bad";
    let text2 = "This is fine";
    
    let result1 = process_text(text1);
    let result2 = process_text(text2);
    
    println!("Result 1: {}", result1);
    println!("Result 2: {}", result2);
    
    // åªåœ¨éœ€è¦æ—¶æ‰åˆ†é…å†…å­˜
}
```

**å®é™…åº”ç”¨**:

```rust
use std::borrow::Cow;

fn capitalize<'a>(s: &'a str) -> Cow<'a, str> {
    if s.is_empty() {
        return Cow::Borrowed(s);
    }
    
    let first_char = s.chars().next().unwrap();
    if first_char.is_uppercase() {
        Cow::Borrowed(s)
    } else {
        let capitalized = format!("{}{}", first_char.to_uppercase(), &s[1..]);
        Cow::Owned(capitalized)
    }
}

fn main() {
    println!("{}", capitalize("hello"));  // åˆ†é…
    println!("{}", capitalize("Hello"));  // ä¸åˆ†é…
}
```

---

## 7. ToString å’Œ Display

### 7.1 å­—ç¬¦ä¸²è½¬æ¢

**è‡ªåŠ¨å®ç°**:

```rust
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

// ToString è‡ªåŠ¨å®ç°
fn main() {
    let p = Point { x: 1, y: 2 };
    let s = p.to_string();
    println!("{}", s);
}
```

### 7.2 æ ¼å¼åŒ–è¾“å‡º

**Debug vs Display**:

```rust
use std::fmt;

#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} (age {})", self.name, self.age)
    }
}

fn main() {
    let person = Person {
        name: String::from("Alice"),
        age: 30,
    };
    
    println!("Debug: {:?}", person);
    println!("Display: {}", person);
    println!("ToString: {}", person.to_string());
}
```

---

## 8. as ç±»å‹è½¬æ¢

### 8.1 åŸºç¡€ç±»å‹è½¬æ¢

**æ•°å€¼è½¬æ¢**:

```rust
fn main() {
    let a: i32 = 42;
    let b: i64 = a as i64;  // æ‰©å±•è½¬æ¢
    let c: i16 = a as i16;  // æˆªæ–­è½¬æ¢
    
    println!("a: {}, b: {}, c: {}", a, b, c);
    
    // æµ®ç‚¹æ•°è½¬æ¢
    let f: f64 = 3.14;
    let i: i32 = f as i32;  // æˆªæ–­å°æ•°éƒ¨åˆ†
    println!("f: {}, i: {}", f, i);
}
```

### 8.2 æŒ‡é’ˆè½¬æ¢

**è£¸æŒ‡é’ˆ**:

```rust
fn main() {
    let x = 42;
    let ptr = &x as *const i32;
    
    unsafe {
        println!("Value: {}", *ptr);
    }
    
    // æŒ‡é’ˆè½¬æ•´æ•°
    let addr = ptr as usize;
    println!("Address: 0x{:x}", addr);
}
```

### 8.3 ä½¿ç”¨é™åˆ¶

**ä¸å®‰å…¨è½¬æ¢**:

```rust
fn main() {
    // âœ… å…è®¸ï¼šæ‰©å±•è½¬æ¢
    let a: u8 = 255;
    let b: u32 = a as u32;
    
    // âš ï¸ æ³¨æ„ï¼šæˆªæ–­è½¬æ¢å¯èƒ½ä¸¢å¤±æ•°æ®
    let c: u32 = 1000;
    let d: u8 = c as u8;  // 232 (1000 % 256)
    
    println!("a: {}, b: {}, c: {}, d: {}", a, b, c, d);
    
    // âŒ ä¸å…è®¸ï¼šæ— å…³ç±»å‹è½¬æ¢
    // let s = "hello";
    // let n = s as i32;  // ç¼–è¯‘é”™è¯¯
}
```

---

## 9. è½¬æ¢æœ€ä½³å®è·µ

### 9.1 é€‰æ‹©åˆé€‚çš„ Trait

**å†³ç­–æ ‘**:

```text
éœ€è¦è½¬æ¢å—ï¼Ÿ
â”œâ”€ æ¶ˆè€—æ‰€æœ‰æƒï¼Ÿ
â”‚  â”œâ”€ å¯èƒ½å¤±è´¥ï¼Ÿ
â”‚  â”‚  â”œâ”€ æ˜¯ â†’ TryFrom/TryInto
â”‚  â”‚  â””â”€ å¦ â†’ From/Into
â”‚  â””â”€ åªéœ€å¼•ç”¨ï¼Ÿ
â”‚     â”œâ”€ é€šç”¨å¼•ç”¨ï¼Ÿâ†’ AsRef/AsMut
â”‚     â”œâ”€ è§£å¼•ç”¨ï¼Ÿâ†’ Deref/DerefMut
â”‚     â””â”€ å€Ÿç”¨è¯­ä¹‰ï¼Ÿâ†’ Borrow/BorrowMut
â””â”€ åˆ›å»ºå‰¯æœ¬ï¼Ÿ
   â”œâ”€ å…‹éš†åˆ°æ‰€æœ‰æƒï¼Ÿâ†’ ToOwned
   â”œâ”€ å¯èƒ½é¿å…å…‹éš†ï¼Ÿâ†’ Cow
   â””â”€ è½¬å­—ç¬¦ä¸²ï¼Ÿâ†’ ToString/Display
```

### 9.2 æ€§èƒ½è€ƒè™‘

**é›¶æˆæœ¬æŠ½è±¡**:

```rust
use std::path::Path;

// âœ… å¥½ï¼šé›¶æˆæœ¬æŠ½è±¡
fn open_file<P: AsRef<Path>>(path: P) {
    let _path = path.as_ref();
    // ä½¿ç”¨ path...
}

// âŒ ä¸å¥½ï¼šä¸å¿…è¦çš„åˆ†é…
fn open_file_bad(path: String) {
    // å¼ºåˆ¶è°ƒç”¨è€…åˆ†é… String
}

fn main() {
    open_file("file.txt");  // ä¸åˆ†é…
    // open_file_bad("file.txt".to_string());  // åˆ†é…
}
```

### 9.3 API è®¾è®¡

**çµæ´»çš„æ¥å£**:

```rust
use std::borrow::Cow;

struct Config {
    name: Cow<'static, str>,
}

impl Config {
    // æ¥å— &str æˆ– String
    fn new<S: Into<Cow<'static, str>>>(name: S) -> Self {
        Config {
            name: name.into(),
        }
    }
}

fn main() {
    let _c1 = Config::new("default");  // ä¸åˆ†é…
    let _c2 = Config::new(String::from("custom"));  // ç§»åŠ¨
}
```

---

## 10. æ€»ç»“

**ç±»å‹è½¬æ¢ Trait å¯¹æ¯”**:

| Trait | æ¶ˆè€—æº | å¯å¤±è´¥ | å…¸å‹ç”¨é€” |
|-------|--------|--------|---------|
| **From/Into** | âœ… | âŒ | å€¼è½¬æ¢ |
| **TryFrom/TryInto** | âœ… | âœ… | å¯å¤±è´¥çš„å€¼è½¬æ¢ |
| **AsRef/AsMut** | âŒ | âŒ | å¼•ç”¨è½¬æ¢ |
| **Deref/DerefMut** | âŒ | âŒ | æ™ºèƒ½æŒ‡é’ˆ |
| **Borrow/BorrowMut** | âŒ | âŒ | å€Ÿç”¨è¯­ä¹‰ |
| **ToOwned** | âŒ | âŒ | å…‹éš†åˆ°æ‰€æœ‰æƒ |
| **Cow** | æ¡ä»¶ | âŒ | å†™æ—¶å…‹éš† |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… ä¼˜å…ˆä½¿ç”¨æ ‡å‡† Trait
2. âœ… From ä¼˜äº Intoï¼ˆå®ç° From è‡ªåŠ¨è·å¾— Intoï¼‰
3. âœ… AsRef ç”¨äºçµæ´»çš„ API
4. âœ… TryFrom ç”¨äºå¯å¤±è´¥è½¬æ¢
5. âœ… é¿å…æ»¥ç”¨ as è½¬æ¢
6. âœ… Cow ç”¨äºä¼˜åŒ–æ€§èƒ½

---

## 11. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [std::convert](https://doc.rust-lang.org/std/convert/)
- [std::borrow](https://doc.rust-lang.org/std/borrow/)
- [std::ops::Deref](https://doc.rust-lang.org/std/ops/trait.Deref.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)
- [3.2 ç±»å‹å‹å˜å‚è€ƒ](./02_ç±»å‹å‹å˜å‚è€ƒ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆç±»å‹è½¬æ¢å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
