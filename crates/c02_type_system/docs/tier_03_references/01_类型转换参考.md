# 3.1 Rust 类型系统 - 类型转换参考

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: 类型转换机制完整参考  
> **适用对象**: 中级 → 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [3.1 Rust 类型系统 - 类型转换参考](#31-rust-类型系统---类型转换参考)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. From 和 Into](#1-from-和-into)
    - [1.1 From Trait](#11-from-trait)
    - [1.2 Into Trait](#12-into-trait)
    - [1.3 自动实现](#13-自动实现)
    - [1.4 使用场景](#14-使用场景)
  - [2. TryFrom 和 TryInto](#2-tryfrom-和-tryinto)
    - [2.1 可失败转换](#21-可失败转换)
    - [2.2 错误处理](#22-错误处理)
    - [2.3 实际应用](#23-实际应用)
  - [3. AsRef 和 AsMut](#3-asref-和-asmut)
    - [3.1 引用转换](#31-引用转换)
    - [3.2 通用 API 设计](#32-通用-api-设计)
    - [3.3 常见用例](#33-常见用例)
  - [4. Deref 和 DerefMut](#4-deref-和-derefmut)
    - [4.1 解引用强制转换](#41-解引用强制转换)
    - [4.2 智能指针](#42-智能指针)
    - [4.3 Newtype 模式](#43-newtype-模式)
  - [5. Borrow 和 BorrowMut](#5-borrow-和-borrowmut)
    - [5.1 借用语义](#51-借用语义)
    - [5.2 与 AsRef 的区别](#52-与-asref-的区别)
  - [6. ToOwned 和 Cow](#6-toowned-和-cow)
    - [6.1 克隆到所有权](#61-克隆到所有权)
    - [6.2 写时克隆](#62-写时克隆)
  - [7. ToString 和 Display](#7-tostring-和-display)
    - [7.1 字符串转换](#71-字符串转换)
    - [7.2 格式化输出](#72-格式化输出)
  - [8. as 类型转换](#8-as-类型转换)
    - [8.1 基础类型转换](#81-基础类型转换)
    - [8.2 指针转换](#82-指针转换)
    - [8.3 使用限制](#83-使用限制)
  - [9. 转换最佳实践](#9-转换最佳实践)
    - [9.1 选择合适的 Trait](#91-选择合适的-trait)
    - [9.2 性能考虑](#92-性能考虑)
    - [9.3 API 设计](#93-api-设计)
  - [10. 总结](#10-总结)
  - [11. 参考资源](#11-参考资源)

---

## 🎯 概述

Rust 提供了丰富的类型转换机制，每种都有其特定的用途和语义：

| Trait | 用途 | 所有权 | 失败处理 |
|-------|------|--------|---------|
| **From/Into** | 值转换 | 消耗 | 不可失败 |
| **TryFrom/TryInto** | 值转换 | 消耗 | 可失败 |
| **AsRef/AsMut** | 引用转换 | 借用 | 不可失败 |
| **Deref/DerefMut** | 解引用 | 借用 | 不可失败 |
| **Borrow/BorrowMut** | 借用转换 | 借用 | 不可失败 |
| **ToOwned** | 克隆到所有权 | 创建 | 不可失败 |
| **ToString** | 字符串转换 | 创建 | 不可失败 |

---

## 1. From 和 Into

### 1.1 From Trait

**定义**:

```rust
pub trait From<T>: Sized {
    fn from(value: T) -> Self;
}
```

**基本用法**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl From<(i32, i32)> for Point {
    fn from(tuple: (i32, i32)) -> Self {
        Point {
            x: tuple.0,
            y: tuple.1,
        }
    }
}

fn main() {
    let point = Point::from((3, 4));
    println!("Point: ({}, {})", point.x, point.y);
}
```

### 1.2 Into Trait

**定义**:

```rust
pub trait Into<T>: Sized {
    fn into(self) -> T;
}
```

**使用 Into**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl From<(i32, i32)> for Point {
    fn from(tuple: (i32, i32)) -> Self {
        Point {
            x: tuple.0,
            y: tuple.1,
        }
    }
}

fn main() {
    // Into 自动实现
    let point: Point = (3, 4).into();
    println!("Point: ({}, {})", point.x, point.y);
}
```

### 1.3 自动实现

**From 蕴含 Into**:

```rust
// 实现 From<T> for U
impl From<String> for Vec<u8> {
    fn from(s: String) -> Vec<u8> {
        s.into_bytes()
    }
}

// 自动获得 Into<Vec<u8>> for String
fn main() {
    let s = String::from("hello");
    
    // 使用 From
    let bytes1 = Vec::<u8>::from(s.clone());
    
    // 使用 Into
    let bytes2: Vec<u8> = s.into();
    
    println!("Bytes: {:?}", bytes1);
}
```

### 1.4 使用场景

**API 设计**:

```rust
use std::net::{IpAddr, Ipv4Addr};

struct Connection {
    addr: IpAddr,
    port: u16,
}

impl Connection {
    // 接受任何可以转换为 IpAddr 的类型
    fn new<A: Into<IpAddr>>(addr: A, port: u16) -> Self {
        Connection {
            addr: addr.into(),
            port,
        }
    }
}

fn main() {
    // 从 Ipv4Addr 创建
    let conn1 = Connection::new(Ipv4Addr::new(127, 0, 0, 1), 8080);
    
    // 从 IpAddr 创建
    let ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1));
    let conn2 = Connection::new(ip, 3000);
    
    println!("Connection 1: {}:{}", conn1.addr, conn1.port);
    println!("Connection 2: {}:{}", conn2.addr, conn2.port);
}
```

**错误转换**:

```rust
use std::fmt;
use std::io;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "IO error: {}", e),
            AppError::Parse(s) => write!(f, "Parse error: {}", s),
        }
    }
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

fn read_file() -> Result<String, AppError> {
    std::fs::read_to_string("file.txt")?  // ? 自动转换
}

fn main() {
    match read_file() {
        Ok(content) => println!("Content: {}", content),
        Err(e) => println!("Error: {}", e),
    }
}
```

---

## 2. TryFrom 和 TryInto

### 2.1 可失败转换

**定义**:

```rust
pub trait TryFrom<T>: Sized {
    type Error;
    fn try_from(value: T) -> Result<Self, Self::Error>;
}
```

**基本用法**:

```rust
use std::convert::TryFrom;

struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = String;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(format!("{} is not an even number", value))
        }
    }
}

fn main() {
    // 成功情况
    match EvenNumber::try_from(4) {
        Ok(n) => println!("Even number: {}", n.0),
        Err(e) => println!("Error: {}", e),
    }
    
    // 失败情况
    match EvenNumber::try_from(3) {
        Ok(n) => println!("Even number: {}", n.0),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2.2 错误处理

**自定义错误类型**:

```rust
use std::convert::TryFrom;
use std::fmt;

#[derive(Debug)]
struct InvalidAge;

impl fmt::Display for InvalidAge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Age must be between 0 and 150")
    }
}

struct Age(u8);

impl TryFrom<i32> for Age {
    type Error = InvalidAge;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value >= 0 && value <= 150 {
            Ok(Age(value as u8))
        } else {
            Err(InvalidAge)
        }
    }
}

fn main() {
    match Age::try_from(25) {
        Ok(age) => println!("Valid age: {}", age.0),
        Err(e) => println!("Error: {}", e),
    }
    
    match Age::try_from(200) {
        Ok(age) => println!("Valid age: {}", age.0),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2.3 实际应用

**数值范围限制**:

```rust
use std::convert::TryFrom;

struct Port(u16);

impl TryFrom<i32> for Port {
    type Error = &'static str;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value > 0 && value <= 65535 {
            Ok(Port(value as u16))
        } else {
            Err("Port must be between 1 and 65535")
        }
    }
}

fn create_server(port_num: i32) -> Result<(), &'static str> {
    let port = Port::try_from(port_num)?;
    println!("Server listening on port {}", port.0);
    Ok(())
}

fn main() {
    create_server(8080).unwrap();
    // create_server(70000).unwrap(); // 会 panic
}
```

---

## 3. AsRef 和 AsMut

### 3.1 引用转换

**定义**:

```rust
pub trait AsRef<T: ?Sized> {
    fn as_ref(&self) -> &T;
}

pub trait AsMut<T: ?Sized> {
    fn as_mut(&mut self) -> &mut T;
}
```

**基本用法**:

```rust
fn print_slice<T: AsRef<[i32]>>(slice: T) {
    let s = slice.as_ref();
    println!("{:?}", s);
}

fn main() {
    print_slice(&[1, 2, 3]);        // &[i32]
    print_slice(vec![1, 2, 3]);     // Vec<i32>
    print_slice([1, 2, 3]);         // [i32; 3]
}
```

### 3.2 通用 API 设计

**文件路径**:

```rust
use std::fs::File;
use std::io::{self, Read};
use std::path::Path;

fn read_file<P: AsRef<Path>>(path: P) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() -> io::Result<()> {
    // 接受 &str
    let _ = read_file("file.txt");
    
    // 接受 String
    let _ = read_file(String::from("file.txt"));
    
    // 接受 Path
    let _ = read_file(Path::new("file.txt"));
    
    Ok(())
}
```

### 3.3 常见用例

**Boxed 切片**:

```rust
struct Wrapper {
    data: Box<[u8]>,
}

impl AsRef<[u8]> for Wrapper {
    fn as_ref(&self) -> &[u8] {
        &self.data
    }
}

fn process_bytes<T: AsRef<[u8]>>(data: T) {
    let bytes = data.as_ref();
    println!("Processing {} bytes", bytes.len());
}

fn main() {
    let wrapper = Wrapper {
        data: vec![1, 2, 3, 4].into_boxed_slice(),
    };
    
    process_bytes(&wrapper);
    process_bytes(vec![5, 6, 7]);
}
```

---

## 4. Deref 和 DerefMut

### 4.1 解引用强制转换

**定义**:

```rust
pub trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

**基本示例**:

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y);  // 解引用
}
```

### 4.2 智能指针

**自动解引用**:

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = Box::new(String::from("Rust"));
    
    // Box<String> -> String -> &str
    hello(&m);  // 编译器自动插入 deref
}
```

**Rc 和 Arc**:

```rust
use std::rc::Rc;

fn main() {
    let shared = Rc::new(String::from("shared data"));
    
    // Rc 实现了 Deref
    let len = shared.len();  // 自动解引用到 String
    println!("Length: {}", len);
}
```

### 4.3 Newtype 模式

```rust
use std::ops::Deref;

struct Meters(f64);

impl Deref for Meters {
    type Target = f64;
    
    fn deref(&self) -> &f64 {
        &self.0
    }
}

fn main() {
    let distance = Meters(100.0);
    
    // 可以像 f64 一样使用
    let doubled = *distance * 2.0;
    println!("Doubled: {}", doubled);
}
```

---

## 5. Borrow 和 BorrowMut

### 5.1 借用语义

**定义**:

```rust
pub trait Borrow<Borrowed: ?Sized> {
    fn borrow(&self) -> &Borrowed;
}
```

**基本用法**:

```rust
use std::borrow::Borrow;
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(String::from("key"), "value");
    
    // 可以用 &str 查询 String 键
    println!("{:?}", map.get("key"));
}
```

### 5.2 与 AsRef 的区别

**Borrow vs AsRef**:

```rust
use std::borrow::Borrow;

// Borrow 要求 Hash/Eq/Ord 保持一致
// AsRef 只是引用转换

fn check_borrow<T: Borrow<str>>(s: T) {
    let borrowed: &str = s.borrow();
    println!("{}", borrowed);
}

fn check_asref<T: AsRef<str>>(s: T) {
    let referenced: &str = s.as_ref();
    println!("{}", referenced);
}

fn main() {
    let s = String::from("hello");
    
    check_borrow(&s);
    check_asref(&s);
}
```

---

## 6. ToOwned 和 Cow

### 6.1 克隆到所有权

**定义**:

```rust
pub trait ToOwned {
    type Owned: Borrow<Self>;
    fn to_owned(&self) -> Self::Owned;
}
```

**基本用法**:

```rust
fn main() {
    let s: &str = "hello";
    let owned: String = s.to_owned();
    
    println!("Borrowed: {}", s);
    println!("Owned: {}", owned);
}
```

### 6.2 写时克隆

**Cow (Clone-on-Write)**:

```rust
use std::borrow::Cow;

fn process_text(input: &str) -> Cow<str> {
    if input.contains("bad") {
        // 需要修改，创建拥有的版本
        Cow::Owned(input.replace("bad", "good"))
    } else {
        // 不需要修改，借用
        Cow::Borrowed(input)
    }
}

fn main() {
    let text1 = "This is bad";
    let text2 = "This is fine";
    
    let result1 = process_text(text1);
    let result2 = process_text(text2);
    
    println!("Result 1: {}", result1);
    println!("Result 2: {}", result2);
    
    // 只在需要时才分配内存
}
```

**实际应用**:

```rust
use std::borrow::Cow;

fn capitalize<'a>(s: &'a str) -> Cow<'a, str> {
    if s.is_empty() {
        return Cow::Borrowed(s);
    }
    
    let first_char = s.chars().next().unwrap();
    if first_char.is_uppercase() {
        Cow::Borrowed(s)
    } else {
        let capitalized = format!("{}{}", first_char.to_uppercase(), &s[1..]);
        Cow::Owned(capitalized)
    }
}

fn main() {
    println!("{}", capitalize("hello"));  // 分配
    println!("{}", capitalize("Hello"));  // 不分配
}
```

---

## 7. ToString 和 Display

### 7.1 字符串转换

**自动实现**:

```rust
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

// ToString 自动实现
fn main() {
    let p = Point { x: 1, y: 2 };
    let s = p.to_string();
    println!("{}", s);
}
```

### 7.2 格式化输出

**Debug vs Display**:

```rust
use std::fmt;

#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} (age {})", self.name, self.age)
    }
}

fn main() {
    let person = Person {
        name: String::from("Alice"),
        age: 30,
    };
    
    println!("Debug: {:?}", person);
    println!("Display: {}", person);
    println!("ToString: {}", person.to_string());
}
```

---

## 8. as 类型转换

### 8.1 基础类型转换

**数值转换**:

```rust
fn main() {
    let a: i32 = 42;
    let b: i64 = a as i64;  // 扩展转换
    let c: i16 = a as i16;  // 截断转换
    
    println!("a: {}, b: {}, c: {}", a, b, c);
    
    // 浮点数转换
    let f: f64 = 3.14;
    let i: i32 = f as i32;  // 截断小数部分
    println!("f: {}, i: {}", f, i);
}
```

### 8.2 指针转换

**裸指针**:

```rust
fn main() {
    let x = 42;
    let ptr = &x as *const i32;
    
    unsafe {
        println!("Value: {}", *ptr);
    }
    
    // 指针转整数
    let addr = ptr as usize;
    println!("Address: 0x{:x}", addr);
}
```

### 8.3 使用限制

**不安全转换**:

```rust
fn main() {
    // ✅ 允许：扩展转换
    let a: u8 = 255;
    let b: u32 = a as u32;
    
    // ⚠️ 注意：截断转换可能丢失数据
    let c: u32 = 1000;
    let d: u8 = c as u8;  // 232 (1000 % 256)
    
    println!("a: {}, b: {}, c: {}, d: {}", a, b, c, d);
    
    // ❌ 不允许：无关类型转换
    // let s = "hello";
    // let n = s as i32;  // 编译错误
}
```

---

## 9. 转换最佳实践

### 9.1 选择合适的 Trait

**决策树**:

```text
需要转换吗？
├─ 消耗所有权？
│  ├─ 可能失败？
│  │  ├─ 是 → TryFrom/TryInto
│  │  └─ 否 → From/Into
│  └─ 只需引用？
│     ├─ 通用引用？→ AsRef/AsMut
│     ├─ 解引用？→ Deref/DerefMut
│     └─ 借用语义？→ Borrow/BorrowMut
└─ 创建副本？
   ├─ 克隆到所有权？→ ToOwned
   ├─ 可能避免克隆？→ Cow
   └─ 转字符串？→ ToString/Display
```

### 9.2 性能考虑

**零成本抽象**:

```rust
use std::path::Path;

// ✅ 好：零成本抽象
fn open_file<P: AsRef<Path>>(path: P) {
    let _path = path.as_ref();
    // 使用 path...
}

// ❌ 不好：不必要的分配
fn open_file_bad(path: String) {
    // 强制调用者分配 String
}

fn main() {
    open_file("file.txt");  // 不分配
    // open_file_bad("file.txt".to_string());  // 分配
}
```

### 9.3 API 设计

**灵活的接口**:

```rust
use std::borrow::Cow;

struct Config {
    name: Cow<'static, str>,
}

impl Config {
    // 接受 &str 或 String
    fn new<S: Into<Cow<'static, str>>>(name: S) -> Self {
        Config {
            name: name.into(),
        }
    }
}

fn main() {
    let _c1 = Config::new("default");  // 不分配
    let _c2 = Config::new(String::from("custom"));  // 移动
}
```

---

## 10. 总结

**类型转换 Trait 对比**:

| Trait | 消耗源 | 可失败 | 典型用途 |
|-------|--------|--------|---------|
| **From/Into** | ✅ | ❌ | 值转换 |
| **TryFrom/TryInto** | ✅ | ✅ | 可失败的值转换 |
| **AsRef/AsMut** | ❌ | ❌ | 引用转换 |
| **Deref/DerefMut** | ❌ | ❌ | 智能指针 |
| **Borrow/BorrowMut** | ❌ | ❌ | 借用语义 |
| **ToOwned** | ❌ | ❌ | 克隆到所有权 |
| **Cow** | 条件 | ❌ | 写时克隆 |

**核心原则**:

1. ✅ 优先使用标准 Trait
2. ✅ From 优于 Into（实现 From 自动获得 Into）
3. ✅ AsRef 用于灵活的 API
4. ✅ TryFrom 用于可失败转换
5. ✅ 避免滥用 as 转换
6. ✅ Cow 用于优化性能

---

## 11. 参考资源

**官方文档**:

- [std::convert](https://doc.rust-lang.org/std/convert/)
- [std::borrow](https://doc.rust-lang.org/std/borrow/)
- [std::ops::Deref](https://doc.rust-lang.org/std/ops/trait.Deref.html)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
- [3.2 类型型变参考](./02_类型型变参考.md)
- [1.1 主索引导航](../tier_01_foundations/02_主索引导航.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 3 - 参考层

---

**🎉 完成类型转换参考学习！** 🦀
