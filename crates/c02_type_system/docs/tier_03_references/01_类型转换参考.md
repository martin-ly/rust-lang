# 3.1 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹è½¬æ¢å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹è½¬æ¢æœºåˆ¶å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.1 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹è½¬æ¢å‚è€ƒ](#31-rust-ç±»å‹ç³»ç»Ÿ---ç±»å‹è½¬æ¢å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. From å’Œ Into](#1-from-å’Œ-into)
    - [1.1 From Trait](#11-from-trait)
    - [1.2 Into Trait](#12-into-trait)
    - [1.3 è‡ªåŠ¨å®ç°](#13-è‡ªåŠ¨å®ç°)
    - [1.4 ä½¿ç”¨åœºæ™¯](#14-ä½¿ç”¨åœºæ™¯)
  - [2. TryFrom å’Œ TryInto](#2-tryfrom-å’Œ-tryinto)
    - [2.1 å¯å¤±è´¥è½¬æ¢](#21-å¯å¤±è´¥è½¬æ¢)
    - [2.2 é”™è¯¯å¤„ç†](#22-é”™è¯¯å¤„ç†)
    - [2.3 å®é™…åº”ç”¨](#23-å®é™…åº”ç”¨)
    - [2.4 é«˜çº§åº”ç”¨æ¨¡å¼](#24-é«˜çº§åº”ç”¨æ¨¡å¼)
  - [3. AsRef å’Œ AsMut](#3-asref-å’Œ-asmut)
    - [3.1 å¼•ç”¨è½¬æ¢](#31-å¼•ç”¨è½¬æ¢)
    - [3.2 é€šç”¨ API è®¾è®¡](#32-é€šç”¨-api-è®¾è®¡)
    - [3.3 å¸¸è§ç”¨ä¾‹](#33-å¸¸è§ç”¨ä¾‹)
  - [4. Deref å’Œ DerefMut](#4-deref-å’Œ-derefmut)
    - [4.1 è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢](#41-è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢)
    - [4.2 æ™ºèƒ½æŒ‡é’ˆ](#42-æ™ºèƒ½æŒ‡é’ˆ)
    - [4.3 Newtype æ¨¡å¼](#43-newtype-æ¨¡å¼)
  - [5. Borrow å’Œ BorrowMut](#5-borrow-å’Œ-borrowmut)
    - [5.1 å€Ÿç”¨è¯­ä¹‰](#51-å€Ÿç”¨è¯­ä¹‰)
    - [5.2 ä¸ AsRef çš„åŒºåˆ«](#52-ä¸-asref-çš„åŒºåˆ«)
  - [6. ToOwned å’Œ Cow](#6-toowned-å’Œ-cow)
    - [6.1 å…‹éš†åˆ°æ‰€æœ‰æƒ](#61-å…‹éš†åˆ°æ‰€æœ‰æƒ)
    - [6.2 å†™æ—¶å…‹éš†](#62-å†™æ—¶å…‹éš†)
  - [7. ToString å’Œ Display](#7-tostring-å’Œ-display)
    - [7.1 å­—ç¬¦ä¸²è½¬æ¢](#71-å­—ç¬¦ä¸²è½¬æ¢)
    - [7.2 æ ¼å¼åŒ–è¾“å‡º](#72-æ ¼å¼åŒ–è¾“å‡º)
  - [8. as ç±»å‹è½¬æ¢](#8-as-ç±»å‹è½¬æ¢)
    - [8.1 åŸºç¡€ç±»å‹è½¬æ¢](#81-åŸºç¡€ç±»å‹è½¬æ¢)
    - [8.2 æŒ‡é’ˆè½¬æ¢](#82-æŒ‡é’ˆè½¬æ¢)
    - [8.3 ä½¿ç”¨é™åˆ¶](#83-ä½¿ç”¨é™åˆ¶)
    - [8.4 asè½¬æ¢çš„å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ](#84-asè½¬æ¢çš„å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ)
    - [8.5 è·¨å¹³å°asè½¬æ¢æ³¨æ„äº‹é¡¹](#85-è·¨å¹³å°asè½¬æ¢æ³¨æ„äº‹é¡¹)
    - [8.6 asè½¬æ¢çš„æ€§èƒ½åˆ†æ](#86-asè½¬æ¢çš„æ€§èƒ½åˆ†æ)
  - [9. è½¬æ¢æœ€ä½³å®è·µ](#9-è½¬æ¢æœ€ä½³å®è·µ)
    - [9.1 é€‰æ‹©åˆé€‚çš„ Trait](#91-é€‰æ‹©åˆé€‚çš„-trait)
    - [9.2 æ€§èƒ½è€ƒè™‘](#92-æ€§èƒ½è€ƒè™‘)
    - [9.3 API è®¾è®¡](#93-api-è®¾è®¡)
    - [9.4 å®æˆ˜æ¡ˆä¾‹ï¼šé€šç”¨æ•°æ®å¤„ç†å™¨](#94-å®æˆ˜æ¡ˆä¾‹é€šç”¨æ•°æ®å¤„ç†å™¨)
    - [9.5 å¸¸è§é”™è¯¯æ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ](#95-å¸¸è§é”™è¯¯æ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ)
    - [9.6 é«˜çº§è½¬æ¢æŠ€å·§](#96-é«˜çº§è½¬æ¢æŠ€å·§)
    - [9.7 æ€§èƒ½åŸºå‡†æµ‹è¯•](#97-æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [9.8 è·¨ç±»å‹è½¬æ¢æ¨¡å¼](#98-è·¨ç±»å‹è½¬æ¢æ¨¡å¼)
    - [9.9 ç±»å‹è½¬æ¢ä¸æ³›å‹](#99-ç±»å‹è½¬æ¢ä¸æ³›å‹)
    - [9.10 å®é™…é¡¹ç›®åº”ç”¨](#910-å®é™…é¡¹ç›®åº”ç”¨)
  - [10. æ€»ç»“](#10-æ€»ç»“)
  - [11. å‚è€ƒèµ„æº](#11-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust æä¾›äº†ä¸°å¯Œçš„ç±»å‹è½¬æ¢æœºåˆ¶ï¼Œæ¯ç§éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œè¯­ä¹‰ï¼š

| Trait | ç”¨é€” | æ‰€æœ‰æƒ | å¤±è´¥å¤„ç† |
|-------|------|--------|---------|
| **From/Into** | å€¼è½¬æ¢ | æ¶ˆè€— | ä¸å¯å¤±è´¥ |
| **TryFrom/TryInto** | å€¼è½¬æ¢ | æ¶ˆè€— | å¯å¤±è´¥ |
| **AsRef/AsMut** | å¼•ç”¨è½¬æ¢ | å€Ÿç”¨ | ä¸å¯å¤±è´¥ |
| **Deref/DerefMut** | è§£å¼•ç”¨ | å€Ÿç”¨ | ä¸å¯å¤±è´¥ |
| **Borrow/BorrowMut** | å€Ÿç”¨è½¬æ¢ | å€Ÿç”¨ | ä¸å¯å¤±è´¥ |
| **ToOwned** | å…‹éš†åˆ°æ‰€æœ‰æƒ | åˆ›å»º | ä¸å¯å¤±è´¥ |
| **ToString** | å­—ç¬¦ä¸²è½¬æ¢ | åˆ›å»º | ä¸å¯å¤±è´¥ |

---

## 1. From å’Œ Into

### 1.1 From Trait

**å®šä¹‰**:

```rust
pub trait From<T>: Sized {
    fn from(value: T) -> Self;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl From<(i32, i32)> for Point {
    fn from(tuple: (i32, i32)) -> Self {
        Point {
            x: tuple.0,
            y: tuple.1,
        }
    }
}

fn main() {
    let point = Point::from((3, 4));
    println!("Point: ({}, {})", point.x, point.y);
}
```

### 1.2 Into Trait

**å®šä¹‰**:

```rust
pub trait Into<T>: Sized {
    fn into(self) -> T;
}
```

**ä½¿ç”¨ Into**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl From<(i32, i32)> for Point {
    fn from(tuple: (i32, i32)) -> Self {
        Point {
            x: tuple.0,
            y: tuple.1,
        }
    }
}

fn main() {
    // Into è‡ªåŠ¨å®ç°
    let point: Point = (3, 4).into();
    println!("Point: ({}, {})", point.x, point.y);
}
```

### 1.3 è‡ªåŠ¨å®ç°

**From è•´å« Into**:

```rust
// å®ç° From<T> for U
impl From<String> for Vec<u8> {
    fn from(s: String) -> Vec<u8> {
        s.into_bytes()
    }
}

// è‡ªåŠ¨è·å¾— Into<Vec<u8>> for String
fn main() {
    let s = String::from("hello");
    
    // ä½¿ç”¨ From
    let bytes1 = Vec::<u8>::from(s.clone());
    
    // ä½¿ç”¨ Into
    let bytes2: Vec<u8> = s.into();
    
    println!("Bytes: {:?}", bytes1);
}
```

### 1.4 ä½¿ç”¨åœºæ™¯

**API è®¾è®¡**:

```rust
use std::net::{IpAddr, Ipv4Addr};

struct Connection {
    addr: IpAddr,
    port: u16,
}

impl Connection {
    // æ¥å—ä»»ä½•å¯ä»¥è½¬æ¢ä¸º IpAddr çš„ç±»å‹
    fn new<A: Into<IpAddr>>(addr: A, port: u16) -> Self {
        Connection {
            addr: addr.into(),
            port,
        }
    }
}

fn main() {
    // ä» Ipv4Addr åˆ›å»º
    let conn1 = Connection::new(Ipv4Addr::new(127, 0, 0, 1), 8080);
    
    // ä» IpAddr åˆ›å»º
    let ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1));
    let conn2 = Connection::new(ip, 3000);
    
    println!("Connection 1: {}:{}", conn1.addr, conn1.port);
    println!("Connection 2: {}:{}", conn2.addr, conn2.port);
}
```

**é”™è¯¯è½¬æ¢**:

```rust
use std::fmt;
use std::io;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "IO error: {}", e),
            AppError::Parse(s) => write!(f, "Parse error: {}", s),
        }
    }
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

fn read_file() -> Result<String, AppError> {
    std::fs::read_to_string("file.txt")?  // ? è‡ªåŠ¨è½¬æ¢
}

fn main() {
    match read_file() {
        Ok(content) => println!("Content: {}", content),
        Err(e) => println!("Error: {}", e),
    }
}
```

---

## 2. TryFrom å’Œ TryInto

### 2.1 å¯å¤±è´¥è½¬æ¢

**å®šä¹‰**:

```rust
pub trait TryFrom<T>: Sized {
    type Error;
    fn try_from(value: T) -> Result<Self, Self::Error>;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::convert::TryFrom;

struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = String;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(format!("{} is not an even number", value))
        }
    }
}

fn main() {
    // æˆåŠŸæƒ…å†µ
    match EvenNumber::try_from(4) {
        Ok(n) => println!("Even number: {}", n.0),
        Err(e) => println!("Error: {}", e),
    }
    
    // å¤±è´¥æƒ…å†µ
    match EvenNumber::try_from(3) {
        Ok(n) => println!("Even number: {}", n.0),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2.2 é”™è¯¯å¤„ç†

**è‡ªå®šä¹‰é”™è¯¯ç±»å‹**:

```rust
use std::convert::TryFrom;
use std::fmt;

#[derive(Debug)]
struct InvalidAge;

impl fmt::Display for InvalidAge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Age must be between 0 and 150")
    }
}

struct Age(u8);

impl TryFrom<i32> for Age {
    type Error = InvalidAge;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value >= 0 && value <= 150 {
            Ok(Age(value as u8))
        } else {
            Err(InvalidAge)
        }
    }
}

fn main() {
    match Age::try_from(25) {
        Ok(age) => println!("Valid age: {}", age.0),
        Err(e) => println!("Error: {}", e),
    }
    
    match Age::try_from(200) {
        Ok(age) => println!("Valid age: {}", age.0),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2.3 å®é™…åº”ç”¨

**æ•°å€¼èŒƒå›´é™åˆ¶**:

```rust
use std::convert::TryFrom;

struct Port(u16);

impl TryFrom<i32> for Port {
    type Error = &'static str;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value > 0 && value <= 65535 {
            Ok(Port(value as u16))
        } else {
            Err("Port must be between 1 and 65535")
        }
    }
}

fn create_server(port_num: i32) -> Result<(), &'static str> {
    let port = Port::try_from(port_num)?;
    println!("Server listening on port {}", port.0);
    Ok(())
}

fn main() {
    create_server(8080).unwrap();
    // create_server(70000).unwrap(); // ä¼š panic
}
```

### 2.4 é«˜çº§åº”ç”¨æ¨¡å¼

**æ¨¡å¼1ï¼šé“¾å¼Tryè½¬æ¢**:

```rust
use std::convert::TryFrom;

#[derive(Debug)]
struct UserId(u32);
#[derive(Debug)]
struct Email(String);
#[derive(Debug)]
struct User {
    id: UserId,
    email: Email,
}

impl TryFrom<u32> for UserId {
    type Error = &'static str;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        if value > 0 { Ok(UserId(value)) }
        else { Err("UserId must be positive") }
    }
}

impl TryFrom<String> for Email {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        if value.contains('@') { Ok(Email(value)) }
        else { Err("Invalid email format") }
    }
}

// é“¾å¼æ„å»º
fn create_user(id: u32, email: String) -> Result<User, &'static str> {
    Ok(User {
        id: UserId::try_from(id)?,
        email: Email::try_from(email)?,
    })
}

fn main() {
    match create_user(1, "user@example.com".to_string()) {
        Ok(user) => println!("Created: {:?}", user),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

**æ¨¡å¼2ï¼šæ‰¹é‡Tryè½¬æ¢**:

```rust
use std::convert::TryFrom;

fn try_convert_batch<T, U>(items: Vec<T>) -> Result<Vec<U>, U::Error>
where
    U: TryFrom<T>,
{
    items.into_iter()
        .map(|item| U::try_from(item))
        .collect()
}

fn main() {
    let numbers: Vec<i64> = vec![1, 2, 3, 256, 4];
    
    match try_convert_batch::<i64, u8>(numbers) {
        Ok(bytes) => println!("All converted: {:?}", bytes),
        Err(e) => eprintln!("Conversion failed: {:?}", e),
    }
}
```

---

## 3. AsRef å’Œ AsMut

### 3.1 å¼•ç”¨è½¬æ¢

**å®šä¹‰**:

```rust
pub trait AsRef<T: ?Sized> {
    fn as_ref(&self) -> &T;
}

pub trait AsMut<T: ?Sized> {
    fn as_mut(&mut self) -> &mut T;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
fn print_slice<T: AsRef<[i32]>>(slice: T) {
    let s = slice.as_ref();
    println!("{:?}", s);
}

fn main() {
    print_slice(&[1, 2, 3]);        // &[i32]
    print_slice(vec![1, 2, 3]);     // Vec<i32>
    print_slice([1, 2, 3]);         // [i32; 3]
}
```

### 3.2 é€šç”¨ API è®¾è®¡

**æ–‡ä»¶è·¯å¾„**:

```rust
use std::fs::File;
use std::io::{self, Read};
use std::path::Path;

fn read_file<P: AsRef<Path>>(path: P) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() -> io::Result<()> {
    // æ¥å— &str
    let _ = read_file("file.txt");
    
    // æ¥å— String
    let _ = read_file(String::from("file.txt"));
    
    // æ¥å— Path
    let _ = read_file(Path::new("file.txt"));
    
    Ok(())
}
```

### 3.3 å¸¸è§ç”¨ä¾‹

**Boxed åˆ‡ç‰‡**:

```rust
struct Wrapper {
    data: Box<[u8]>,
}

impl AsRef<[u8]> for Wrapper {
    fn as_ref(&self) -> &[u8] {
        &self.data
    }
}

fn process_bytes<T: AsRef<[u8]>>(data: T) {
    let bytes = data.as_ref();
    println!("Processing {} bytes", bytes.len());
}

fn main() {
    let wrapper = Wrapper {
        data: vec![1, 2, 3, 4].into_boxed_slice(),
    };
    
    process_bytes(&wrapper);
    process_bytes(vec![5, 6, 7]);
}
```

---

## 4. Deref å’Œ DerefMut

### 4.1 è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢

**å®šä¹‰**:

```rust
pub trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

**åŸºæœ¬ç¤ºä¾‹**:

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y);  // è§£å¼•ç”¨
}
```

### 4.2 æ™ºèƒ½æŒ‡é’ˆ

**è‡ªåŠ¨è§£å¼•ç”¨**:

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = Box::new(String::from("Rust"));
    
    // Box<String> -> String -> &str
    hello(&m);  // ç¼–è¯‘å™¨è‡ªåŠ¨æ’å…¥ deref
}
```

**Rc å’Œ Arc**:

```rust
use std::rc::Rc;

fn main() {
    let shared = Rc::new(String::from("shared data"));
    
    // Rc å®ç°äº† Deref
    let len = shared.len();  // è‡ªåŠ¨è§£å¼•ç”¨åˆ° String
    println!("Length: {}", len);
}
```

### 4.3 Newtype æ¨¡å¼

```rust
use std::ops::Deref;

struct Meters(f64);

impl Deref for Meters {
    type Target = f64;
    
    fn deref(&self) -> &f64 {
        &self.0
    }
}

fn main() {
    let distance = Meters(100.0);
    
    // å¯ä»¥åƒ f64 ä¸€æ ·ä½¿ç”¨
    let doubled = *distance * 2.0;
    println!("Doubled: {}", doubled);
}
```

---

## 5. Borrow å’Œ BorrowMut

### 5.1 å€Ÿç”¨è¯­ä¹‰

**å®šä¹‰**:

```rust
pub trait Borrow<Borrowed: ?Sized> {
    fn borrow(&self) -> &Borrowed;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
use std::borrow::Borrow;
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(String::from("key"), "value");
    
    // å¯ä»¥ç”¨ &str æŸ¥è¯¢ String é”®
    println!("{:?}", map.get("key"));
}
```

### 5.2 ä¸ AsRef çš„åŒºåˆ«

**Borrow vs AsRef**:

```rust
use std::borrow::Borrow;

// Borrow è¦æ±‚ Hash/Eq/Ord ä¿æŒä¸€è‡´
// AsRef åªæ˜¯å¼•ç”¨è½¬æ¢

fn check_borrow<T: Borrow<str>>(s: T) {
    let borrowed: &str = s.borrow();
    println!("{}", borrowed);
}

fn check_asref<T: AsRef<str>>(s: T) {
    let referenced: &str = s.as_ref();
    println!("{}", referenced);
}

fn main() {
    let s = String::from("hello");
    
    check_borrow(&s);
    check_asref(&s);
}
```

---

## 6. ToOwned å’Œ Cow

### 6.1 å…‹éš†åˆ°æ‰€æœ‰æƒ

**å®šä¹‰**:

```rust
pub trait ToOwned {
    type Owned: Borrow<Self>;
    fn to_owned(&self) -> Self::Owned;
}
```

**åŸºæœ¬ç”¨æ³•**:

```rust
fn main() {
    let s: &str = "hello";
    let owned: String = s.to_owned();
    
    println!("Borrowed: {}", s);
    println!("Owned: {}", owned);
}
```

### 6.2 å†™æ—¶å…‹éš†

**Cow (Clone-on-Write)**:

```rust
use std::borrow::Cow;

fn process_text(input: &str) -> Cow<str> {
    if input.contains("bad") {
        // éœ€è¦ä¿®æ”¹ï¼Œåˆ›å»ºæ‹¥æœ‰çš„ç‰ˆæœ¬
        Cow::Owned(input.replace("bad", "good"))
    } else {
        // ä¸éœ€è¦ä¿®æ”¹ï¼Œå€Ÿç”¨
        Cow::Borrowed(input)
    }
}

fn main() {
    let text1 = "This is bad";
    let text2 = "This is fine";
    
    let result1 = process_text(text1);
    let result2 = process_text(text2);
    
    println!("Result 1: {}", result1);
    println!("Result 2: {}", result2);
    
    // åªåœ¨éœ€è¦æ—¶æ‰åˆ†é…å†…å­˜
}
```

**å®é™…åº”ç”¨**:

```rust
use std::borrow::Cow;

fn capitalize<'a>(s: &'a str) -> Cow<'a, str> {
    if s.is_empty() {
        return Cow::Borrowed(s);
    }
    
    let first_char = s.chars().next().unwrap();
    if first_char.is_uppercase() {
        Cow::Borrowed(s)
    } else {
        let capitalized = format!("{}{}", first_char.to_uppercase(), &s[1..]);
        Cow::Owned(capitalized)
    }
}

fn main() {
    println!("{}", capitalize("hello"));  // åˆ†é…
    println!("{}", capitalize("Hello"));  // ä¸åˆ†é…
}
```

---

## 7. ToString å’Œ Display

### 7.1 å­—ç¬¦ä¸²è½¬æ¢

**è‡ªåŠ¨å®ç°**:

```rust
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

// ToString è‡ªåŠ¨å®ç°
fn main() {
    let p = Point { x: 1, y: 2 };
    let s = p.to_string();
    println!("{}", s);
}
```

### 7.2 æ ¼å¼åŒ–è¾“å‡º

**Debug vs Display**:

```rust
use std::fmt;

#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} (age {})", self.name, self.age)
    }
}

fn main() {
    let person = Person {
        name: String::from("Alice"),
        age: 30,
    };
    
    println!("Debug: {:?}", person);
    println!("Display: {}", person);
    println!("ToString: {}", person.to_string());
}
```

---

## 8. as ç±»å‹è½¬æ¢

### 8.1 åŸºç¡€ç±»å‹è½¬æ¢

**æ•°å€¼è½¬æ¢**:

```rust
fn main() {
    let a: i32 = 42;
    let b: i64 = a as i64;  // æ‰©å±•è½¬æ¢
    let c: i16 = a as i16;  // æˆªæ–­è½¬æ¢
    
    println!("a: {}, b: {}, c: {}", a, b, c);
    
    // æµ®ç‚¹æ•°è½¬æ¢
    let f: f64 = 3.14;
    let i: i32 = f as i32;  // æˆªæ–­å°æ•°éƒ¨åˆ†
    println!("f: {}, i: {}", f, i);
}
```

### 8.2 æŒ‡é’ˆè½¬æ¢

**è£¸æŒ‡é’ˆ**:

```rust
fn main() {
    let x = 42;
    let ptr = &x as *const i32;
    
    unsafe {
        println!("Value: {}", *ptr);
    }
    
    // æŒ‡é’ˆè½¬æ•´æ•°
    let addr = ptr as usize;
    println!("Address: 0x{:x}", addr);
}
```

### 8.3 ä½¿ç”¨é™åˆ¶

**ä¸å®‰å…¨è½¬æ¢**:

```rust
fn main() {
    // âœ… å…è®¸ï¼šæ‰©å±•è½¬æ¢
    let a: u8 = 255;
    let b: u32 = a as u32;
    
    // âš ï¸ æ³¨æ„ï¼šæˆªæ–­è½¬æ¢å¯èƒ½ä¸¢å¤±æ•°æ®
    let c: u32 = 1000;
    let d: u8 = c as u8;  // 232 (1000 % 256)
    
    println!("a: {}, b: {}, c: {}, d: {}", a, b, c, d);
    
    // âŒ ä¸å…è®¸ï¼šæ— å…³ç±»å‹è½¬æ¢
    // let s = "hello";
    // let n = s as i32;  // ç¼–è¯‘é”™è¯¯
}
```

### 8.4 asè½¬æ¢çš„å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ

**å®‰å…¨çš„æ•°å€¼è½¬æ¢**:

```rust
use std::convert::TryFrom;

fn safe_numeric_convert() {
    let large: i64 = 1000;
    
    // âŒ ä¸å®‰å…¨ï¼šå¯èƒ½æˆªæ–­
    let _unsafe: u8 = large as u8;
    
    // âœ… å®‰å…¨ï¼šTryFromæ£€æŸ¥èŒƒå›´
    match u8::try_from(large) {
        Ok(val) => println!("Safe: {}", val),
        Err(e) => eprintln!("Overflow: {}", e),
    }
    
    // âœ… å®‰å…¨ï¼šcheckedè½¬æ¢
    if let Some(val) = large.to_string().parse::<u8>().ok() {
        println!("Parsed: {}", val);
    }
}
```

**æŒ‡é’ˆè½¬æ¢çš„å®‰å…¨å®è·µ**:

```rust
fn safe_pointer_conversion() {
    let x = 42i32;
    let ptr = &x as *const i32;
    
    // âœ… å®‰å…¨ï¼šé€šè¿‡å¼•ç”¨è½¬æ¢
    let back_ref: &i32 = unsafe { &*ptr };
    println!("Value: {}", back_ref);
    
    // âŒ å±é™©ï¼šä¸è¦éšæ„è½¬æ¢ç±»å‹
    // let wrong: &i64 = unsafe { &*(ptr as *const i64) };
}
```

### 8.5 è·¨å¹³å°asè½¬æ¢æ³¨æ„äº‹é¡¹

**å¹³å°ç›¸å…³çš„å¤§å°**:

```rust
fn platform_specific_conversions() {
    // isize/usizeåœ¨32ä½å’Œ64ä½å¹³å°ä¸åŒ
    let x: usize = 100;
    
    #[cfg(target_pointer_width = "32")]
    {
        let _y: u32 = x as u32;  // 32ä½å¹³å°
    }
    
    #[cfg(target_pointer_width = "64")]
    {
        let _y: u64 = x as u64;  // 64ä½å¹³å°
    }
    
    // âœ… æ›´å¥½ï¼šä½¿ç”¨ä¸å¹³å°æ— å…³çš„ç±»å‹
    let portable: u64 = x as u64;  // æ€»æ˜¯å®‰å…¨
    println!("Portable: {}", portable);
}
```

### 8.6 asè½¬æ¢çš„æ€§èƒ½åˆ†æ

**æ€§èƒ½å¯¹æ¯”**:

```rust
use std::time::Instant;
use std::convert::TryFrom;

fn benchmark_conversions() {
    let iterations = 10_000_000;
    let value: i64 = 100;
    
    // æµ‹è¯•1ï¼šasè½¬æ¢ï¼ˆæœ€å¿«ï¼‰
    let start = Instant::now();
    for _ in 0..iterations {
        let _: i32 = value as i32;
    }
    println!("as cast: {:?}", start.elapsed());
    
    // æµ‹è¯•2ï¼šTryFromï¼ˆæœ‰æ£€æŸ¥ï¼‰
    let start = Instant::now();
    for _ in 0..iterations {
        let _: Result<i32, _> = i32::try_from(value);
    }
    println!("TryFrom: {:?}", start.elapsed());
}

fn main() {
    benchmark_conversions();
}
// å…¸å‹è¾“å‡ºï¼ˆreleaseæ¨¡å¼ï¼‰ï¼š
// as cast: 2ms    (æœ€å¿«ï¼Œæ— æ£€æŸ¥)
// TryFrom: 15ms   (æœ‰è¾¹ç•Œæ£€æŸ¥)
```

---

## 9. è½¬æ¢æœ€ä½³å®è·µ

### 9.1 é€‰æ‹©åˆé€‚çš„ Trait

**å†³ç­–æ ‘**:

```text
éœ€è¦è½¬æ¢å—ï¼Ÿ
â”œâ”€ æ¶ˆè€—æ‰€æœ‰æƒï¼Ÿ
â”‚  â”œâ”€ å¯èƒ½å¤±è´¥ï¼Ÿ
â”‚  â”‚  â”œâ”€ æ˜¯ â†’ TryFrom/TryInto
â”‚  â”‚  â””â”€ å¦ â†’ From/Into
â”‚  â””â”€ åªéœ€å¼•ç”¨ï¼Ÿ
â”‚     â”œâ”€ é€šç”¨å¼•ç”¨ï¼Ÿâ†’ AsRef/AsMut
â”‚     â”œâ”€ è§£å¼•ç”¨ï¼Ÿâ†’ Deref/DerefMut
â”‚     â””â”€ å€Ÿç”¨è¯­ä¹‰ï¼Ÿâ†’ Borrow/BorrowMut
â””â”€ åˆ›å»ºå‰¯æœ¬ï¼Ÿ
   â”œâ”€ å…‹éš†åˆ°æ‰€æœ‰æƒï¼Ÿâ†’ ToOwned
   â”œâ”€ å¯èƒ½é¿å…å…‹éš†ï¼Ÿâ†’ Cow
   â””â”€ è½¬å­—ç¬¦ä¸²ï¼Ÿâ†’ ToString/Display
```

### 9.2 æ€§èƒ½è€ƒè™‘

**é›¶æˆæœ¬æŠ½è±¡**:

```rust
use std::path::Path;

// âœ… å¥½ï¼šé›¶æˆæœ¬æŠ½è±¡
fn open_file<P: AsRef<Path>>(path: P) {
    let _path = path.as_ref();
    // ä½¿ç”¨ path...
}

// âŒ ä¸å¥½ï¼šä¸å¿…è¦çš„åˆ†é…
fn open_file_bad(path: String) {
    // å¼ºåˆ¶è°ƒç”¨è€…åˆ†é… String
}

fn main() {
    open_file("file.txt");  // ä¸åˆ†é…
    // open_file_bad("file.txt".to_string());  // åˆ†é…
}
```

### 9.3 API è®¾è®¡

**çµæ´»çš„æ¥å£**:

```rust
use std::borrow::Cow;

struct Config {
    name: Cow<'static, str>,
}

impl Config {
    // æ¥å— &str æˆ– String
    fn new<S: Into<Cow<'static, str>>>(name: S) -> Self {
        Config {
            name: name.into(),
        }
    }
}

fn main() {
    let _c1 = Config::new("default");  // ä¸åˆ†é…
    let _c2 = Config::new(String::from("custom"));  // ç§»åŠ¨
}
```

### 9.4 å®æˆ˜æ¡ˆä¾‹ï¼šé€šç”¨æ•°æ®å¤„ç†å™¨

**æ¡ˆä¾‹ï¼šçµæ´»çš„é…ç½®åŠ è½½å™¨**:

```rust
use std::path::{Path, PathBuf};
use std::fs;
use std::borrow::Cow;

pub struct ConfigLoader {
    base_path: PathBuf,
}

impl ConfigLoader {
    // æ¥å—å¤šç§è·¯å¾„ç±»å‹
    pub fn new<P: Into<PathBuf>>(base_path: P) -> Self {
        Self {
            base_path: base_path.into(),
        }
    }
    
    // çµæ´»çš„è¯»å–æ¥å£
    pub fn load<P: AsRef<Path>>(&self, filename: P) -> std::io::Result<String> {
        let full_path = self.base_path.join(filename.as_ref());
        fs::read_to_string(full_path)
    }
    
    // æ”¯æŒå¤šç§è¾“å…¥æ ¼å¼
    pub fn parse_value<S>(&self, input: S) -> Result<i64, std::num::ParseIntError>
    where
        S: AsRef<str>,
    {
        input.as_ref().parse()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    // æ¥å— &str
    let loader1 = ConfigLoader::new("/etc/config");
    
    // æ¥å— String
    let base = String::from("/home/user/config");
    let loader2 = ConfigLoader::new(base);
    
    // æ¥å— PathBuf
    let path = PathBuf::from("/var/config");
    let loader3 = ConfigLoader::new(path);
    
    // çµæ´»çš„è¯»å–
    let _content1 = loader1.load("app.conf")?;
    let filename = String::from("db.conf");
    let _content2 = loader1.load(&filename)?;
    
    Ok(())
}
```

### 9.5 å¸¸è§é”™è¯¯æ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ

**é”™è¯¯1ï¼šä¸å¿…è¦çš„å…‹éš†**:

```rust
// âŒ ä¸å¥½ï¼šé¢‘ç¹å…‹éš†
fn process_string_bad(s: &str) -> String {
    let owned = s.to_string();  // ä¸å¿…è¦çš„åˆ†é…
    owned.to_uppercase()
}

// âœ… å¥½ï¼šç›´æ¥æ“ä½œ
fn process_string_good(s: &str) -> String {
    s.to_uppercase()  // ç›´æ¥è½¬æ¢
}
```

**é”™è¯¯2ï¼šè¿‡åº¦ä½¿ç”¨ Into**:

```rust
// âŒ ä¸å¥½ï¼šæ¨¡ç³Šçš„ç±»å‹æ¨å¯¼
fn create_config_bad<S: Into<String>>(name: S) {
    let _name: String = name.into();
    // å¯èƒ½å¯¼è‡´ç¼–è¯‘å™¨å›°æƒ‘
}

// âœ… å¥½ï¼šæ˜ç¡®çš„ç±»å‹
fn create_config_good(name: impl Into<String>) {
    let _name: String = name.into();
    // ç±»å‹æ›´æ¸…æ™°
}
```

**é”™è¯¯3ï¼šå¿½ç•¥å¤±è´¥è½¬æ¢**:

```rust
use std::convert::TryFrom;

// âŒ ä¸å¥½ï¼šä½¿ç”¨ as å¯èƒ½æˆªæ–­
fn convert_bad(value: i64) -> u8 {
    value as u8  // å¯èƒ½ä¸¢å¤±æ•°æ®
}

// âœ… å¥½ï¼šä½¿ç”¨ TryFrom å¤„ç†é”™è¯¯
fn convert_good(value: i64) -> Result<u8, std::num::TryFromIntError> {
    u8::try_from(value)
}

fn main() {
    let large = 1000i64;
    
    // å±é™©ï¼šæˆªæ–­
    let bad = convert_bad(large);
    println!("Bad: {}", bad);  // 232
    
    // å®‰å…¨ï¼šé”™è¯¯å¤„ç†
    match convert_good(large) {
        Ok(val) => println!("Good: {}", val),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

### 9.6 é«˜çº§è½¬æ¢æŠ€å·§

**æŠ€å·§1ï¼šé“¾å¼è½¬æ¢**:

```rust
use std::path::PathBuf;

fn chain_conversions(input: &str) -> PathBuf {
    input
        .trim()                    // &str -> &str
        .to_lowercase()            // &str -> String
        .into()                    // String -> PathBuf
}

fn main() {
    let path = chain_conversions("  /HOME/USER  ");
    println!("{:?}", path);  // "/home/user"
}
```

**æŠ€å·§2ï¼šæ¡ä»¶è½¬æ¢**:

```rust
use std::borrow::Cow;

fn maybe_modify<'a>(s: &'a str, uppercase: bool) -> Cow<'a, str> {
    if uppercase {
        Cow::Owned(s.to_uppercase())  // éœ€è¦ä¿®æ”¹ï¼šåˆ†é…
    } else {
        Cow::Borrowed(s)              // ä¸ä¿®æ”¹ï¼šå€Ÿç”¨
    }
}

fn main() {
    let original = "hello";
    
    let result1 = maybe_modify(original, false);
    println!("No alloc: {}", result1);  // å€Ÿç”¨
    
    let result2 = maybe_modify(original, true);
    println!("Allocated: {}", result2);  // HELLO
}
```

**æŠ€å·§3ï¼šæ‰¹é‡è½¬æ¢**:

```rust
fn batch_convert<T, U>(items: Vec<T>) -> Vec<U>
where
    T: Into<U>,
{
    items.into_iter().map(Into::into).collect()
}

fn main() {
    let numbers: Vec<i32> = vec![1, 2, 3, 4, 5];
    let longs: Vec<i64> = batch_convert(numbers);
    println!("{:?}", longs);
}
```

### 9.7 æ€§èƒ½åŸºå‡†æµ‹è¯•

**åŸºå‡†ï¼šä¸åŒè½¬æ¢æ–¹å¼çš„æ€§èƒ½**:

```rust
use std::time::Instant;

fn benchmark_conversions() {
    let data = "Hello World";
    let iterations = 1_000_000;
    
    // æµ‹è¯•1ï¼šAsRefï¼ˆé›¶æˆæœ¬ï¼‰
    let start = Instant::now();
    for _ in 0..iterations {
        let _: &str = data.as_ref();
    }
    println!("AsRef: {:?}", start.elapsed());
    
    // æµ‹è¯•2ï¼što_stringï¼ˆåˆ†é…ï¼‰
    let start = Instant::now();
    for _ in 0..iterations {
        let _: String = data.to_string();
    }
    println!("to_string: {:?}", start.elapsed());
    
    // æµ‹è¯•3ï¼šFromï¼ˆåˆ†é…ï¼‰
    let start = Instant::now();
    for _ in 0..iterations {
        let _: String = String::from(data);
    }
    println!("String::from: {:?}", start.elapsed());
}

fn main() {
    benchmark_conversions();
}
// å…¸å‹è¾“å‡ºï¼ˆreleaseæ¨¡å¼ï¼‰ï¼š
// AsRef: 1Î¼s        (å‡ ä¹é›¶å¼€é”€)
// to_string: 45ms   (å †åˆ†é…)
// String::from: 42ms (å †åˆ†é…)
```

**æ€§èƒ½å¯¹æ¯”çŸ©é˜µ**:

| è½¬æ¢æ–¹å¼ | åˆ†é… | å¤æ‚åº¦ | ç”¨é€” |
|---------|------|--------|------|
| `AsRef` | âŒ | O(1) | å¼•ç”¨è½¬æ¢ |
| `Deref` | âŒ | O(1) | æ™ºèƒ½æŒ‡é’ˆ |
| `Borrow` | âŒ | O(1) | å€Ÿç”¨è¯­ä¹‰ |
| `From` | å¯èƒ½ | å–å†³äºç±»å‹ | å€¼è½¬æ¢ |
| `to_string()` | âœ… | O(n) | å­—ç¬¦ä¸²åŒ– |
| `clone()` | âœ… | O(n) | æ·±æ‹·è´ |
| `Cow` | æ¡ä»¶ | O(1)/O(n) | å†™æ—¶å…‹éš† |

### 9.8 è·¨ç±»å‹è½¬æ¢æ¨¡å¼

**æ¨¡å¼1ï¼šç±»å‹å®‰å…¨çš„å•ä½è½¬æ¢**:

```rust
use std::marker::PhantomData;

// ç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ
struct Length<Unit> {
    value: f64,
    _marker: PhantomData<Unit>,
}

struct Meters;
struct Feet;

impl Length<Meters> {
    fn new(value: f64) -> Self {
        Length {
            value,
            _marker: PhantomData,
        }
    }
}

impl From<Length<Meters>> for Length<Feet> {
    fn from(meters: Length<Meters>) -> Self {
        Length {
            value: meters.value * 3.28084,
            _marker: PhantomData,
        }
    }
}

fn main() {
    let meters = Length::<Meters>::new(10.0);
    let feet: Length<Feet> = meters.into();
    println!("10 meters = {:.2} feet", feet.value);
}
```

**æ¨¡å¼2ï¼šå¤šæ ¼å¼æ•°æ®è½¬æ¢**:

```rust
use std::collections::HashMap;

enum DataFormat {
    Json(String),
    Xml(String),
    Yaml(String),
}

struct DataConverter;

impl DataConverter {
    fn from_json(json: String) -> DataFormat {
        DataFormat::Json(json)
    }
    
    fn to_map(format: DataFormat) -> HashMap<String, String> {
        match format {
            DataFormat::Json(data) => {
                // ç®€åŒ–ç¤ºä¾‹ï¼šå®é™…åº”ä½¿ç”¨serde
                let mut map = HashMap::new();
                map.insert("format".to_string(), "json".to_string());
                map.insert("data".to_string(), data);
                map
            }
            DataFormat::Xml(data) => {
                let mut map = HashMap::new();
                map.insert("format".to_string(), "xml".to_string());
                map.insert("data".to_string(), data);
                map
            }
            DataFormat::Yaml(data) => {
                let mut map = HashMap::new();
                map.insert("format".to_string(), "yaml".to_string());
                map.insert("data".to_string(), data);
                map
            }
        }
    }
}
```

### 9.9 ç±»å‹è½¬æ¢ä¸æ³›å‹

**æ³›å‹è½¬æ¢å‡½æ•°**:

```rust
use std::fmt::Display;

// æ³›å‹è½¬æ¢åˆ°å­—ç¬¦ä¸²
fn to_display_string<T: Display>(value: T) -> String {
    format!("{}", value)
}

// æ³›å‹æ‰¹é‡è½¬æ¢
fn convert_all<T, U>(items: Vec<T>) -> Vec<U>
where
    T: Into<U>,
{
    items.into_iter().map(Into::into).collect()
}

// æ¡ä»¶è½¬æ¢
fn try_convert_all<T, U, E>(items: Vec<T>) -> Result<Vec<U>, E>
where
    T: TryInto<U, Error = E>,
{
    items.into_iter().map(TryInto::try_into).collect()
}

fn main() {
    // ä½¿ç”¨æ³›å‹è½¬æ¢
    let nums = vec![1, 2, 3];
    let strings: Vec<String> = nums.into_iter()
        .map(to_display_string)
        .collect();
    println!("{:?}", strings);
}
```

### 9.10 å®é™…é¡¹ç›®åº”ç”¨

**æ¡ˆä¾‹ï¼šHTTPå®¢æˆ·ç«¯çš„çµæ´»API**:

```rust
use std::borrow::Cow;
use std::collections::HashMap;

pub struct HttpClient {
    base_url: String,
    headers: HashMap<String, String>,
}

impl HttpClient {
    pub fn new<S: Into<String>>(base_url: S) -> Self {
        Self {
            base_url: base_url.into(),
            headers: HashMap::new(),
        }
    }
    
    // çµæ´»çš„headerè®¾ç½®
    pub fn header<K, V>(&mut self, key: K, value: V) -> &mut Self
    where
        K: Into<String>,
        V: Into<String>,
    {
        self.headers.insert(key.into(), value.into());
        self
    }
    
    // æ¥å—å¤šç§URLæ ¼å¼
    pub fn get<U: AsRef<str>>(&self, path: U) -> String {
        format!("{}{}", self.base_url, path.as_ref())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut client = HttpClient::new("https://api.example.com");
    
    client
        .header("User-Agent", "RustClient/1.0")
        .header("Accept".to_string(), "application/json".to_string());
    
    let url1 = client.get("/users");
    let path = String::from("/posts");
    let url2 = client.get(&path);
    
    println!("{}", url1);
    println!("{}", url2);
}
```

**æ¡ˆä¾‹ï¼šæ•°æ®åº“æŸ¥è¯¢æ„å»ºå™¨**:

```rust
use std::borrow::Cow;

pub struct QueryBuilder {
    table: String,
    conditions: Vec<String>,
}

impl QueryBuilder {
    pub fn new<S: Into<String>>(table: S) -> Self {
        Self {
            table: table.into(),
            conditions: Vec::new(),
        }
    }
    
    // æ¥å—å¤šç§æ¡ä»¶æ ¼å¼
    pub fn where_clause<S>(&mut self, condition: S) -> &mut Self
    where
        S: Into<String>,
    {
        self.conditions.push(condition.into());
        self
    }
    
    pub fn build(&self) -> String {
        let mut query = format!("SELECT * FROM {}", self.table);
        
        if !self.conditions.is_empty() {
            query.push_str(" WHERE ");
            query.push_str(&self.conditions.join(" AND "));
        }
        
        query
    }
}

fn main() {
    let mut query = QueryBuilder::new("users");
    
    query
        .where_clause("age > 18")
        .where_clause(format!("name LIKE '%{}%'", "john"));
    
    println!("{}", query.build());
}
```

---

## 10. æ€»ç»“

**ç±»å‹è½¬æ¢ Trait å¯¹æ¯”**:

| Trait | æ¶ˆè€—æº | å¯å¤±è´¥ | å…¸å‹ç”¨é€” |
|-------|--------|--------|---------|
| **From/Into** | âœ… | âŒ | å€¼è½¬æ¢ |
| **TryFrom/TryInto** | âœ… | âœ… | å¯å¤±è´¥çš„å€¼è½¬æ¢ |
| **AsRef/AsMut** | âŒ | âŒ | å¼•ç”¨è½¬æ¢ |
| **Deref/DerefMut** | âŒ | âŒ | æ™ºèƒ½æŒ‡é’ˆ |
| **Borrow/BorrowMut** | âŒ | âŒ | å€Ÿç”¨è¯­ä¹‰ |
| **ToOwned** | âŒ | âŒ | å…‹éš†åˆ°æ‰€æœ‰æƒ |
| **Cow** | æ¡ä»¶ | âŒ | å†™æ—¶å…‹éš† |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… ä¼˜å…ˆä½¿ç”¨æ ‡å‡† Trait
2. âœ… From ä¼˜äº Intoï¼ˆå®ç° From è‡ªåŠ¨è·å¾— Intoï¼‰
3. âœ… AsRef ç”¨äºçµæ´»çš„ API
4. âœ… TryFrom ç”¨äºå¯å¤±è´¥è½¬æ¢
5. âœ… é¿å…æ»¥ç”¨ as è½¬æ¢
6. âœ… Cow ç”¨äºä¼˜åŒ–æ€§èƒ½

---

## 11. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [std::convert](https://doc.rust-lang.org/std/convert/)
- [std::borrow](https://doc.rust-lang.org/std/borrow/)
- [std::ops::Deref](https://doc.rust-lang.org/std/ops/trait.Deref.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)
- [3.2 ç±»å‹å‹å˜å‚è€ƒ](./02_ç±»å‹å‹å˜å‚è€ƒ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆç±»å‹è½¬æ¢å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
