# 3.3 Rust 类型系统 - 分派机制参考

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: 静态分发与动态分发完整参考  
> **适用对象**: 中级 → 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)  
> **最后更新**: 2025-10-22

---


## 📊 目录

- [3.3 Rust 类型系统 - 分派机制参考](#33-rust-类型系统---分派机制参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 概述](#-概述)
  - [1. 分派机制基础](#1-分派机制基础)
    - [1.1 什么是分派](#11-什么是分派)
    - [1.2 静态 vs 动态](#12-静态-vs-动态)
  - [2. 静态分发](#2-静态分发)
    - [2.1 单态化](#21-单态化)
    - [2.2 性能优势](#22-性能优势)
    - [2.3 代码膨胀](#23-代码膨胀)
  - [3. 动态分发](#3-动态分发)
    - [3.1 Trait 对象](#31-trait-对象)
    - [3.2 虚函数表](#32-虚函数表)
    - [3.3 性能开销](#33-性能开销)
  - [4. 对象安全](#4-对象安全)
    - [4.1 规则](#41-规则)
    - [4.2 常见陷阱](#42-常见陷阱)
    - [4.3 解决方案](#43-解决方案)
  - [5. 选择合适的分发](#5-选择合适的分发)
    - [5.1 决策树](#51-决策树)
    - [5.2 性能对比](#52-性能对比)
    - [5.3 使用场景](#53-使用场景)
    - [5.4 性能测试与分析](#54-性能测试与分析)
    - [5.5 混合策略实践](#55-混合策略实践)
  - [6. 实战案例](#6-实战案例)
    - [案例 1: 插件系统](#案例-1-插件系统)
    - [案例 2: GUI 组件](#案例-2-gui-组件)
    - [案例 3: 日志系统](#案例-3-日志系统)
    - [案例 4: 序列化系统](#案例-4-序列化系统)
    - [案例 5: 事件处理系统](#案例-5-事件处理系统)
  - [7. 优化技巧](#7-优化技巧)
  - [8. 跨版本兼容性说明](#8-跨版本兼容性说明)
  - [9. 总结](#9-总结)
  - [10. 参考资源](#10-参考资源)


## 📋 目录

- [3.3 Rust 类型系统 - 分派机制参考](#33-rust-类型系统---分派机制参考)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 概述](#-概述)
  - [1. 分派机制基础](#1-分派机制基础)
    - [1.1 什么是分派](#11-什么是分派)
    - [1.2 静态 vs 动态](#12-静态-vs-动态)
  - [2. 静态分发](#2-静态分发)
    - [2.1 单态化](#21-单态化)
    - [2.2 性能优势](#22-性能优势)
    - [2.3 代码膨胀](#23-代码膨胀)
  - [3. 动态分发](#3-动态分发)
    - [3.1 Trait 对象](#31-trait-对象)
    - [3.2 虚函数表](#32-虚函数表)
    - [3.3 性能开销](#33-性能开销)
  - [4. 对象安全](#4-对象安全)
    - [4.1 规则](#41-规则)
    - [4.2 常见陷阱](#42-常见陷阱)
    - [4.3 解决方案](#43-解决方案)
  - [5. 选择合适的分发](#5-选择合适的分发)
    - [5.1 决策树](#51-决策树)
    - [5.2 性能对比](#52-性能对比)
    - [5.3 使用场景](#53-使用场景)
    - [5.4 性能测试与分析](#54-性能测试与分析)
    - [5.5 混合策略实践](#55-混合策略实践)
  - [6. 实战案例](#6-实战案例)
    - [案例 1: 插件系统](#案例-1-插件系统)
    - [案例 2: GUI 组件](#案例-2-gui-组件)
    - [案例 3: 日志系统](#案例-3-日志系统)
    - [案例 4: 序列化系统](#案例-4-序列化系统)
    - [案例 5: 事件处理系统](#案例-5-事件处理系统)
  - [7. 优化技巧](#7-优化技巧)
  - [8. 跨版本兼容性说明](#8-跨版本兼容性说明)
  - [9. 总结](#9-总结)
  - [10. 参考资源](#10-参考资源)

---

## 🎯 概述

**分派** (Dispatch) 决定在运行时调用哪个具体的方法实现。

| 特性 | 静态分发 | 动态分发 |
|------|---------|---------|
| **决定时间** | 编译时 | 运行时 |
| **机制** | 单态化 | 虚函数表 (vtable) |
| **性能** | ⚡ 快（可内联） | 🐢 慢（间接调用） |
| **代码大小** | 📈 较大 | 📉 较小 |
| **灵活性** | 🔒 编译时确定 | 🔄 运行时确定 |

---

## 1. 分派机制基础

### 1.1 什么是分派

**分派**：选择调用哪个方法实现的过程。

```rust
trait Animal {
    fn make_sound(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn make_sound(&self) {
        println!("Meow!");
    }
}

// 静态分发
fn static_dispatch<T: Animal>(animal: &T) {
    animal.make_sound();  // 编译时确定
}

// 动态分发
fn dynamic_dispatch(animal: &dyn Animal) {
    animal.make_sound();  // 运行时通过 vtable 查找
}

fn main() {
    let dog = Dog;
    let cat = Cat;
    
    static_dispatch(&dog);   // 编译时生成 Dog::make_sound
    static_dispatch(&cat);   // 编译时生成 Cat::make_sound
    
    dynamic_dispatch(&dog);  // 运行时查找
    dynamic_dispatch(&cat);  // 运行时查找
}
```

### 1.2 静态 vs 动态

**静态分发示例**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
struct Rectangle;

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle");
    }
}

// 泛型 = 静态分发
fn render<T: Draw>(shape: &T) {
    shape.draw();  // 编译时确定具体类型
}

fn main() {
    let circle = Circle;
    let rectangle = Rectangle;
    
    render(&circle);     // 调用 Circle::draw
    render(&rectangle);  // 调用 Rectangle::draw
}
```

**动态分发示例**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
struct Rectangle;

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle");
    }
}

// trait 对象 = 动态分发
fn render(shape: &dyn Draw) {
    shape.draw();  // 运行时通过 vtable 查找
}

fn main() {
    let circle = Circle;
    let rectangle = Rectangle;
    
    render(&circle);     // 运行时分发
    render(&rectangle);  // 运行时分发
    
    // 可以存储不同类型
    let shapes: Vec<&dyn Draw> = vec![&circle, &rectangle];
    for shape in shapes {
        shape.draw();
    }
}
```

---

## 2. 静态分发

### 2.1 单态化

**编译器生成专门化代码**:

```rust
fn process<T: std::fmt::Display>(value: T) {
    println!("Value: {}", value);
}

fn main() {
    process(42);        // 生成 process_i32
    process(3.14);      // 生成 process_f64
    process("hello");   // 生成 process_str
}

// 编译后等价于：
// fn process_i32(value: i32) { println!("Value: {}", value); }
// fn process_f64(value: f64) { println!("Value: {}", value); }
// fn process_str(value: &str) { println!("Value: {}", value); }
```

### 2.2 性能优势

**内联优化**:

```rust
trait Compute {
    fn compute(&self) -> i32;
}

struct FastCompute(i32);

impl Compute for FastCompute {
    #[inline]
    fn compute(&self) -> i32 {
        self.0 * 2
    }
}

// 静态分发允许内联
fn process_static<T: Compute>(c: &T) -> i32 {
    c.compute()  // 可以被内联
}

fn main() {
    let c = FastCompute(21);
    let result = process_static(&c);
    println!("Result: {}", result);
}
```

### 2.3 代码膨胀

**问题示例**:

```rust
fn large_function<T: std::fmt::Display>(value: T) {
    // 100+ 行代码
    println!("{}", value);
    // ... 更多代码 ...
}

fn main() {
    // 每个类型都生成一份完整代码
    large_function(1);
    large_function(2_i64);
    large_function(3_i8);
    large_function(4_u32);
    // ... 代码膨胀！
}
```

**优化方案**:

```rust
// 提取非泛型部分
fn common_logic() {
    // 通用代码只有一份
    println!("Common processing");
}

fn thin_wrapper<T: std::fmt::Display>(value: T) {
    common_logic();
    println!("{}", value);  // 只有这部分被单态化
}

fn main() {
    thin_wrapper(1);
    thin_wrapper(2_i64);
}
```

---

## 3. 动态分发

### 3.1 Trait 对象

**创建 trait 对象**:

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}

fn main() {
    // 创建 trait 对象
    let circle: Box<dyn Shape> = Box::new(Circle { radius: 5.0 });
    let rectangle: Box<dyn Shape> = Box::new(Rectangle {
        width: 10.0,
        height: 20.0,
    });
    
    // 存储不同类型
    let shapes: Vec<Box<dyn Shape>> = vec![circle, rectangle];
    
    for shape in shapes {
        println!("Area: {}", shape.area());
    }
}
```

### 3.2 虚函数表

**vtable 结构**:

```rust
// trait 对象的内部表示
struct TraitObject {
    data: *mut (),      // 指向数据
    vtable: *const (),  // 指向 vtable
}

// vtable 包含：
// - drop 函数指针
// - size 和 alignment
// - trait 方法指针
```

**示例**:

```rust
trait Animal {
    fn make_sound(&self);
    fn move_forward(&self);
}

struct Dog {
    name: String,
}

impl Animal for Dog {
    fn make_sound(&self) {
        println!("{} says Woof!", self.name);
    }
    
    fn move_forward(&self) {
        println!("{} runs forward", self.name);
    }
}

fn main() {
    let dog = Dog {
        name: String::from("Buddy"),
    };
    
    // 创建 trait 对象时，编译器生成 vtable
    let animal: &dyn Animal = &dog;
    
    // 通过 vtable 调用方法
    animal.make_sound();
    animal.move_forward();
}
```

### 3.3 性能开销

**基准测试**:

```rust
use std::time::Instant;

trait Processor {
    fn process(&self, x: i32) -> i32;
}

struct SimpleProcessor;

impl Processor for SimpleProcessor {
    fn process(&self, x: i32) -> i32 {
        x * 2
    }
}

// 静态分发
fn static_bench<T: Processor>(p: &T) -> i32 {
    let mut sum = 0;
    for i in 0..1_000_000 {
        sum += p.process(i);
    }
    sum
}

// 动态分发
fn dynamic_bench(p: &dyn Processor) -> i32 {
    let mut sum = 0;
    for i in 0..1_000_000 {
        sum += p.process(i);
    }
    sum
}

fn main() {
    let processor = SimpleProcessor;
    
    let start = Instant::now();
    let _result = static_bench(&processor);
    println!("Static: {:?}", start.elapsed());
    
    let start = Instant::now();
    let _result = dynamic_bench(&processor);
    println!("Dynamic: {:?}", start.elapsed());
}
```

---

## 4. 对象安全

### 4.1 规则

**对象安全的 trait 必须满足**:

1. ❌ 方法不返回 `Self`
2. ❌ 方法没有泛型类型参数
3. ✅ 方法有 `self` 接收者

```rust
// ✅ 对象安全
trait Safe {
    fn method(&self);
}

// ❌ 不对象安全：返回 Self
trait NotSafe1 {
    fn clone(&self) -> Self;
}

// ❌ 不对象安全：泛型方法
trait NotSafe2 {
    fn generic<T>(&self, value: T);
}

// ❌ 不对象安全：关联函数
trait NotSafe3 {
    fn new() -> Self;
}
```

### 4.2 常见陷阱

**Clone trait**:

```rust
// Clone 不是对象安全的
trait Animal: Clone {
    fn make_sound(&self);
}

struct Dog;

impl Clone for Dog {
    fn clone(&self) -> Self {
        Dog
    }
}

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    // let animal: &dyn Animal = &dog;  // 编译错误！
}
```

### 4.3 解决方案

**使用自定义方法**:

```rust
trait CloneableAnimal {
    fn make_sound(&self);
    fn clone_box(&self) -> Box<dyn CloneableAnimal>;
}

struct Dog;

impl CloneableAnimal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
    
    fn clone_box(&self) -> Box<dyn CloneableAnimal> {
        Box::new(Dog)
    }
}

fn main() {
    let dog = Dog;
    let animal: Box<dyn CloneableAnimal> = Box::new(dog);
    let cloned = animal.clone_box();
    cloned.make_sound();
}
```

---

## 5. 选择合适的分发

### 5.1 决策树

```text
需要存储不同类型吗？
├─ 是
│  └─ 使用动态分发 (trait 对象)
└─ 否
   └─ 需要最佳性能吗？
      ├─ 是 → 使用静态分发 (泛型)
      └─ 否 → 两者都可
```

### 5.2 性能对比

| 特性 | 静态分发 | 动态分发 |
|------|---------|---------|
| **调用开销** | 0 (可内联) | 1-2 指令 (vtable 查找) |
| **内存开销** | 0 | 2个指针 (数据+vtable) |
| **编译时间** | 较长 | 较短 |
| **二进制大小** | 较大 | 较小 |

### 5.3 使用场景

**静态分发适用于**:

- ✅ 性能关键代码
- ✅ 编译时知道所有类型
- ✅ 需要内联优化

**动态分发适用于**:

- ✅ 异构集合
- ✅ 插件系统
- ✅ 减小代码体积

### 5.4 性能测试与分析

**实际性能对比**:

```rust
use std::time::Instant;

trait Calculator {
    fn calculate(&self, a: i32, b: i32) -> i32;
}

struct Adder;
impl Calculator for Adder {
    fn calculate(&self, a: i32, b: i32) -> i32 {
        a + b
    }
}

// 静态分发
fn benchmark_static<C: Calculator>(calc: &C, iterations: usize) -> std::time::Duration {
    let start = Instant::now();
    let mut sum = 0;
    for i in 0..iterations {
        sum += calc.calculate(i as i32, i as i32);
    }
    start.elapsed()
}

// 动态分发
fn benchmark_dynamic(calc: &dyn Calculator, iterations: usize) -> std::time::Duration {
    let start = Instant::now();
    let mut sum = 0;
    for i in 0..iterations {
        sum += calc.calculate(i as i32, i as i32);
    }
    start.elapsed()
}

fn main() {
    let adder = Adder;
    let iterations = 10_000_000;
    
    let static_time = benchmark_static(&adder, iterations);
    let dynamic_time = benchmark_dynamic(&adder, iterations);
    
    println!("静态分发: {:?}", static_time);
    println!("动态分发: {:?}", dynamic_time);
    println!("动态开销: {:.1}%", 
        (dynamic_time.as_nanos() as f64 / static_time.as_nanos() as f64 - 1.0) * 100.0);
}
```

### 5.5 混合策略实践

**智能选择分发方式**:

```rust
enum Message {
    Text(String),
    Image(Vec<u8>),
    Complex(Box<dyn ComplexMessage>),
}

trait ComplexMessage {
    fn process(&self) -> String;
}

impl Message {
    fn handle(&self) -> String {
        match self {
            // 常见情况：静态分发（enum匹配）
            Message::Text(s) => s.clone(),
            Message::Image(data) => format!("Image: {} bytes", data.len()),
            // 特殊情况：动态分发
            Message::Complex(msg) => msg.process(),
        }
    }
}

struct VideoMessage {
    duration: u32,
}

impl ComplexMessage for VideoMessage {
    fn process(&self) -> String {
        format!("Video: {}s", self.duration)
    }
}

fn main() {
    let messages = vec![
        Message::Text("Hello".to_string()),
        Message::Image(vec![1, 2, 3]),
        Message::Complex(Box::new(VideoMessage { duration: 60 })),
    ];
    
    for msg in &messages {
        println!("{}", msg.handle());
    }
}
```

---

## 6. 实战案例

### 案例 1: 插件系统

```rust
trait Plugin {
    fn name(&self) -> &str;
    fn execute(&self);
}

struct LoggerPlugin;
struct CachePlugin;

impl Plugin for LoggerPlugin {
    fn name(&self) -> &str {
        "Logger"
    }
    
    fn execute(&self) {
        println!("[Logger] Executing");
    }
}

impl Plugin for CachePlugin {
    fn name(&self) -> &str {
        "Cache"
    }
    
    fn execute(&self) {
        println!("[Cache] Executing");
    }
}

struct PluginManager {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginManager {
    fn new() -> Self {
        PluginManager {
            plugins: Vec::new(),
        }
    }
    
    fn register(&mut self, plugin: Box<dyn Plugin>) {
        println!("Registering plugin: {}", plugin.name());
        self.plugins.push(plugin);
    }
    
    fn execute_all(&self) {
        for plugin in &self.plugins {
            plugin.execute();
        }
    }
}

fn main() {
    let mut manager = PluginManager::new();
    
    manager.register(Box::new(LoggerPlugin));
    manager.register(Box::new(CachePlugin));
    
    manager.execute_all();
}
```

### 案例 2: GUI 组件

```rust
trait Component {
    fn render(&self);
    fn handle_event(&mut self, event: &str);
}

struct Button {
    label: String,
}

struct TextBox {
    content: String,
}

impl Component for Button {
    fn render(&self) {
        println!("[Button] {}", self.label);
    }
    
    fn handle_event(&mut self, event: &str) {
        println!("[Button] Handling: {}", event);
    }
}

impl Component for TextBox {
    fn render(&self) {
        println!("[TextBox] {}", self.content);
    }
    
    fn handle_event(&mut self, event: &str) {
        if event == "input" {
            self.content.push_str("_input");
        }
    }
}

struct Window {
    components: Vec<Box<dyn Component>>,
}

impl Window {
    fn new() -> Self {
        Window {
            components: Vec::new(),
        }
    }
    
    fn add(&mut self, component: Box<dyn Component>) {
        self.components.push(component);
    }
    
    fn render_all(&self) {
        for component in &self.components {
            component.render();
        }
    }
}

fn main() {
    let mut window = Window::new();
    
    window.add(Box::new(Button {
        label: String::from("Click Me"),
    }));
    window.add(Box::new(TextBox {
        content: String::from("Enter text"),
    }));
    
    window.render_all();
}
```

### 案例 3: 日志系统

```rust
trait Logger {
    fn log(&self, message: &str);
}

struct ConsoleLogger;
struct FileLogger {
    path: String,
}

impl Logger for ConsoleLogger {
    fn log(&self, message: &str) {
        println!("[Console] {}", message);
    }
}

impl Logger for FileLogger {
    fn log(&self, message: &str) {
        println!("[File:{}] {}", self.path, message);
    }
}

// 静态分发版本：高性能
fn log_many_static<L: Logger>(logger: &L, count: usize) {
    for i in 0..count {
        logger.log(&format!("Message {}", i));
    }
}

// 动态分发版本：灵活
fn log_many_dynamic(logger: &dyn Logger, count: usize) {
    for i in 0..count {
        logger.log(&format!("Message {}", i));
    }
}

fn main() {
    let console = ConsoleLogger;
    let file = FileLogger {
        path: String::from("app.log"),
    };
    
    log_many_static(&console, 3);
    log_many_dynamic(&file, 3);
}
```

### 案例 4: 序列化系统

**动态分发的实际应用**:

```rust
trait Serializer {
    fn serialize_i32(&mut self, value: i32);
    fn serialize_string(&mut self, value: &str);
    fn finish(self: Box<Self>) -> Vec<u8>;
}

struct JsonSerializer {
    buffer: String,
}

impl JsonSerializer {
    fn new() -> Self {
        JsonSerializer {
            buffer: String::new(),
        }
    }
}

impl Serializer for JsonSerializer {
    fn serialize_i32(&mut self, value: i32) {
        self.buffer.push_str(&format!("{}", value));
    }
    
    fn serialize_string(&mut self, value: &str) {
        self.buffer.push_str(&format!("\"{}\"", value));
    }
    
    fn finish(self: Box<Self>) -> Vec<u8> {
        self.buffer.into_bytes()
    }
}

struct BinarySerializer {
    buffer: Vec<u8>,
}

impl BinarySerializer {
    fn new() -> Self {
        BinarySerializer {
            buffer: Vec::new(),
        }
    }
}

impl Serializer for BinarySerializer {
    fn serialize_i32(&mut self, value: i32) {
        self.buffer.extend_from_slice(&value.to_le_bytes());
    }
    
    fn serialize_string(&mut self, value: &str) {
        self.buffer.extend_from_slice(value.as_bytes());
    }
    
    fn finish(self: Box<Self>) -> Vec<u8> {
        self.buffer
    }
}

fn serialize_data(serializer: &mut dyn Serializer) {
    serializer.serialize_i32(42);
    serializer.serialize_string("Hello");
}

fn main() {
    let mut json = JsonSerializer::new();
    let mut binary = BinarySerializer::new();
    
    serialize_data(&mut json);
    serialize_data(&mut binary);
    
    let json_data = Box::new(json).finish();
    let binary_data = Box::new(binary).finish();
    
    println!("JSON: {:?}", String::from_utf8(json_data));
    println!("Binary: {:?}", binary_data);
}
```

### 案例 5: 事件处理系统

**混合使用静态和动态分发**:

```rust
trait EventHandler {
    fn handle(&mut self, event: &str);
}

struct ClickHandler;
struct KeyHandler {
    key_buffer: String,
}

impl EventHandler for ClickHandler {
    fn handle(&mut self, event: &str) {
        println!("[Click] {}", event);
    }
}

impl EventHandler for KeyHandler {
    fn handle(&mut self, event: &str) {
        self.key_buffer.push_str(event);
        println!("[Key] Buffer: {}", self.key_buffer);
    }
}

struct EventDispatcher {
    handlers: Vec<Box<dyn EventHandler>>,
}

impl EventDispatcher {
    fn new() -> Self {
        EventDispatcher {
            handlers: Vec::new(),
        }
    }
    
    fn register(&mut self, handler: Box<dyn EventHandler>) {
        self.handlers.push(handler);
    }
    
    fn dispatch(&mut self, event: &str) {
        for handler in &mut self.handlers {
            handler.handle(event);
        }
    }
}

fn main() {
    let mut dispatcher = EventDispatcher::new();
    
    dispatcher.register(Box::new(ClickHandler));
    dispatcher.register(Box::new(KeyHandler {
        key_buffer: String::new(),
    }));
    
    dispatcher.dispatch("click");
    dispatcher.dispatch("key_a");
}
```

---

## 7. 优化技巧

**技巧 1: 混合使用**:

```rust
trait Process {
    fn process(&self, data: &[u8]);
}

// 热路径：静态分发
fn fast_path<T: Process>(processor: &T, data: &[u8]) {
    processor.process(data);
}

// 冷路径：动态分发
fn slow_path(processor: &dyn Process, data: &[u8]) {
    processor.process(data);
}
```

**技巧 2: 小对象优化**:

```rust
enum SmallVec<T> {
    Inline([Option<T>; 4]),
    Heap(Vec<T>),
}
```

**技巧 3: 缓存 vtable 查找**:

```rust
// 在循环外获取方法指针
fn optimized(shapes: &[&dyn Shape]) {
    for shape in shapes {
        let area = shape.area();  // vtable 查找被优化
        println!("{}", area);
    }
}

trait Shape {
    fn area(&self) -> f64;
}
```

**技巧 4: 枚举分发**:

```rust
// 使用enum代替trait对象
enum Operation {
    Add(i32, i32),
    Sub(i32, i32),
    Mul(i32, i32),
}

impl Operation {
    fn execute(&self) -> i32 {
        match self {
            Operation::Add(a, b) => a + b,
            Operation::Sub(a, b) => a - b,
            Operation::Mul(a, b) => a * b,
        }
    }
}

// vs trait对象
trait OperationTrait {
    fn execute(&self) -> i32;
}

fn main() {
    let ops = vec![
        Operation::Add(1, 2),
        Operation::Sub(5, 3),
        Operation::Mul(4, 6),
    ];
    
    for op in ops {
        println!("{}", op.execute());  // 更快！
    }
}
```

**技巧 5: 内联小函数**:

```rust
trait Compute {
    #[inline(always)]
    fn compute(&self, x: i32) -> i32;
}

struct Doubler;

impl Compute for Doubler {
    #[inline(always)]
    fn compute(&self, x: i32) -> i32 {
        x * 2
    }
}

// 静态分发+内联 = 极致性能
fn process<C: Compute>(c: &C, values: &[i32]) -> Vec<i32> {
    values.iter().map(|&v| c.compute(v)).collect()
}
```

**技巧 6: 分层分发**:

```rust
// 使用enum分层减少动态分发
enum SimpleShape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl SimpleShape {
    fn area(&self) -> f64 {
        match self {
            SimpleShape::Circle { radius } => 3.14159 * radius * radius,
            SimpleShape::Rectangle { width, height } => width * height,
        }
    }
}

// 复杂形状才使用动态分发
trait ComplexShape {
    fn area(&self) -> f64;
}

enum Shape {
    Simple(SimpleShape),
    Complex(Box<dyn ComplexShape>),
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Simple(s) => s.area(),       // 快速路径
            Shape::Complex(s) => s.area(),      // 灵活路径
        }
    }
}
```

**技巧 7: Profile-Guided Optimization**:

```rust
// 使用profiling发现热点
use std::time::Instant;

fn benchmark_static<T: Process>(processor: &T, iterations: usize) {
    let start = Instant::now();
    for _ in 0..iterations {
        processor.process(&[1, 2, 3, 4, 5]);
    }
    println!("Static: {:?}", start.elapsed());
}

fn benchmark_dynamic(processor: &dyn Process, iterations: usize) {
    let start = Instant::now();
    for _ in 0..iterations {
        processor.process(&[1, 2, 3, 4, 5]);
    }
    println!("Dynamic: {:?}", start.elapsed());
}

trait Process {
    fn process(&self, data: &[i32]);
}
```

---

## 8. 跨版本兼容性说明

| 特性                     | Rust 1.82 | Rust 1.90 | 说明                                  |
|--------------------------|-----------|-----------|---------------------------------------|
| 基本 trait 分发          | 稳定      | 稳定      | 静态和动态分发核心功能                |
| `dyn Trait` 语法         | 稳定      | 稳定      | Rust 2018+ 推荐语法                   |
| 对象安全规则             | 稳定      | 稳定      | 自动检查，编译期保证                  |
| `#[inline]` 属性         | 稳定      | 稳定      | 控制内联行为                          |
| `impl Trait` 返回值      | 稳定      | 稳定      | 静态分发的抽象返回类型                |
| RPIT (Return Position)   | 稳定      | 稳定      | `fn foo() -> impl Trait`              |
| APIT (Argument Position) | 稳定      | 稳定      | `fn foo(x: impl Trait)`               |

**Rust 1.90 新增特性**:

- 改进的 trait 对象布局优化
- 更好的内联决策启发式算法
- 增强的动态分发性能分析工具

---

## 9. 总结

**选择指南**:

| 场景 | 推荐 |
|------|------|
| 性能关键 | 静态分发 |
| 异构集合 | 动态分发 |
| 插件系统 | 动态分发 |
| 通用库 | 静态分发 |
| GUI 组件 | 动态分发 |
| 数值计算 | 静态分发 |

**核心原则**:

1. ✅ 默认使用静态分发
2. ✅ 需要运行时多态时使用动态分发
3. ✅ 注意对象安全规则
4. ✅ 混合使用以获得最佳平衡

---

## 10. 参考资源

**官方文档**:

- [Trait Objects](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)
- [Performance](https://doc.rust-lang.org/book/ch19-04-advanced-types.html)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.4 Trait系统指南](../tier_02_guides/04_Trait系统指南.md)
- [3.5 性能优化参考](./05_性能优化参考.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 3 - 参考层

---

**🎉 完成分派机制参考学习！** 🦀
