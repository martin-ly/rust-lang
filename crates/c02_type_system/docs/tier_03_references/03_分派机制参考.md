# 3.3 Rust ç±»å‹ç³»ç»Ÿ - åˆ†æ´¾æœºåˆ¶å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: é™æ€åˆ†å‘ä¸åŠ¨æ€åˆ†å‘å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.3 Rust ç±»å‹ç³»ç»Ÿ - åˆ†æ´¾æœºåˆ¶å‚è€ƒ](#33-rust-ç±»å‹ç³»ç»Ÿ---åˆ†æ´¾æœºåˆ¶å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. åˆ†æ´¾æœºåˆ¶åŸºç¡€](#1-åˆ†æ´¾æœºåˆ¶åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯åˆ†æ´¾](#11-ä»€ä¹ˆæ˜¯åˆ†æ´¾)
    - [1.2 é™æ€ vs åŠ¨æ€](#12-é™æ€-vs-åŠ¨æ€)
  - [2. é™æ€åˆ†å‘](#2-é™æ€åˆ†å‘)
    - [2.1 å•æ€åŒ–](#21-å•æ€åŒ–)
    - [2.2 æ€§èƒ½ä¼˜åŠ¿](#22-æ€§èƒ½ä¼˜åŠ¿)
    - [2.3 ä»£ç è†¨èƒ€](#23-ä»£ç è†¨èƒ€)
  - [3. åŠ¨æ€åˆ†å‘](#3-åŠ¨æ€åˆ†å‘)
    - [3.1 Trait å¯¹è±¡](#31-trait-å¯¹è±¡)
    - [3.2 è™šå‡½æ•°è¡¨](#32-è™šå‡½æ•°è¡¨)
    - [3.3 æ€§èƒ½å¼€é”€](#33-æ€§èƒ½å¼€é”€)
  - [4. å¯¹è±¡å®‰å…¨](#4-å¯¹è±¡å®‰å…¨)
    - [4.1 è§„åˆ™](#41-è§„åˆ™)
    - [4.2 å¸¸è§é™·é˜±](#42-å¸¸è§é™·é˜±)
    - [4.3 è§£å†³æ–¹æ¡ˆ](#43-è§£å†³æ–¹æ¡ˆ)
  - [5. é€‰æ‹©åˆé€‚çš„åˆ†å‘](#5-é€‰æ‹©åˆé€‚çš„åˆ†å‘)
    - [5.1 å†³ç­–æ ‘](#51-å†³ç­–æ ‘)
    - [5.2 æ€§èƒ½å¯¹æ¯”](#52-æ€§èƒ½å¯¹æ¯”)
    - [5.3 ä½¿ç”¨åœºæ™¯](#53-ä½¿ç”¨åœºæ™¯)
    - [5.4 æ€§èƒ½æµ‹è¯•ä¸åˆ†æ](#54-æ€§èƒ½æµ‹è¯•ä¸åˆ†æ)
    - [5.5 æ··åˆç­–ç•¥å®è·µ](#55-æ··åˆç­–ç•¥å®è·µ)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: æ’ä»¶ç³»ç»Ÿ](#æ¡ˆä¾‹-1-æ’ä»¶ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 2: GUI ç»„ä»¶](#æ¡ˆä¾‹-2-gui-ç»„ä»¶)
    - [æ¡ˆä¾‹ 3: æ—¥å¿—ç³»ç»Ÿ](#æ¡ˆä¾‹-3-æ—¥å¿—ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 4: åºåˆ—åŒ–ç³»ç»Ÿ](#æ¡ˆä¾‹-4-åºåˆ—åŒ–ç³»ç»Ÿ)
    - [æ¡ˆä¾‹ 5: äº‹ä»¶å¤„ç†ç³»ç»Ÿ](#æ¡ˆä¾‹-5-äº‹ä»¶å¤„ç†ç³»ç»Ÿ)
  - [7. ä¼˜åŒ–æŠ€å·§](#7-ä¼˜åŒ–æŠ€å·§)
  - [8. æ€»ç»“](#8-æ€»ç»“)
  - [9. å‚è€ƒèµ„æº](#9-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

**åˆ†æ´¾** (Dispatch) å†³å®šåœ¨è¿è¡Œæ—¶è°ƒç”¨å“ªä¸ªå…·ä½“çš„æ–¹æ³•å®ç°ã€‚

| ç‰¹æ€§ | é™æ€åˆ†å‘ | åŠ¨æ€åˆ†å‘ |
|------|---------|---------|
| **å†³å®šæ—¶é—´** | ç¼–è¯‘æ—¶ | è¿è¡Œæ—¶ |
| **æœºåˆ¶** | å•æ€åŒ– | è™šå‡½æ•°è¡¨ (vtable) |
| **æ€§èƒ½** | âš¡ å¿«ï¼ˆå¯å†…è”ï¼‰ | ğŸ¢ æ…¢ï¼ˆé—´æ¥è°ƒç”¨ï¼‰ |
| **ä»£ç å¤§å°** | ğŸ“ˆ è¾ƒå¤§ | ğŸ“‰ è¾ƒå° |
| **çµæ´»æ€§** | ğŸ”’ ç¼–è¯‘æ—¶ç¡®å®š | ğŸ”„ è¿è¡Œæ—¶ç¡®å®š |

---

## 1. åˆ†æ´¾æœºåˆ¶åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯åˆ†æ´¾

**åˆ†æ´¾**ï¼šé€‰æ‹©è°ƒç”¨å“ªä¸ªæ–¹æ³•å®ç°çš„è¿‡ç¨‹ã€‚

```rust
trait Animal {
    fn make_sound(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn make_sound(&self) {
        println!("Meow!");
    }
}

// é™æ€åˆ†å‘
fn static_dispatch<T: Animal>(animal: &T) {
    animal.make_sound();  // ç¼–è¯‘æ—¶ç¡®å®š
}

// åŠ¨æ€åˆ†å‘
fn dynamic_dispatch(animal: &dyn Animal) {
    animal.make_sound();  // è¿è¡Œæ—¶é€šè¿‡ vtable æŸ¥æ‰¾
}

fn main() {
    let dog = Dog;
    let cat = Cat;
    
    static_dispatch(&dog);   // ç¼–è¯‘æ—¶ç”Ÿæˆ Dog::make_sound
    static_dispatch(&cat);   // ç¼–è¯‘æ—¶ç”Ÿæˆ Cat::make_sound
    
    dynamic_dispatch(&dog);  // è¿è¡Œæ—¶æŸ¥æ‰¾
    dynamic_dispatch(&cat);  // è¿è¡Œæ—¶æŸ¥æ‰¾
}
```

### 1.2 é™æ€ vs åŠ¨æ€

**é™æ€åˆ†å‘ç¤ºä¾‹**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
struct Rectangle;

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle");
    }
}

// æ³›å‹ = é™æ€åˆ†å‘
fn render<T: Draw>(shape: &T) {
    shape.draw();  // ç¼–è¯‘æ—¶ç¡®å®šå…·ä½“ç±»å‹
}

fn main() {
    let circle = Circle;
    let rectangle = Rectangle;
    
    render(&circle);     // è°ƒç”¨ Circle::draw
    render(&rectangle);  // è°ƒç”¨ Rectangle::draw
}
```

**åŠ¨æ€åˆ†å‘ç¤ºä¾‹**:

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
struct Rectangle;

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle");
    }
}

// trait å¯¹è±¡ = åŠ¨æ€åˆ†å‘
fn render(shape: &dyn Draw) {
    shape.draw();  // è¿è¡Œæ—¶é€šè¿‡ vtable æŸ¥æ‰¾
}

fn main() {
    let circle = Circle;
    let rectangle = Rectangle;
    
    render(&circle);     // è¿è¡Œæ—¶åˆ†å‘
    render(&rectangle);  // è¿è¡Œæ—¶åˆ†å‘
    
    // å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹
    let shapes: Vec<&dyn Draw> = vec![&circle, &rectangle];
    for shape in shapes {
        shape.draw();
    }
}
```

---

## 2. é™æ€åˆ†å‘

### 2.1 å•æ€åŒ–

**ç¼–è¯‘å™¨ç”Ÿæˆä¸“é—¨åŒ–ä»£ç **:

```rust
fn process<T: std::fmt::Display>(value: T) {
    println!("Value: {}", value);
}

fn main() {
    process(42);        // ç”Ÿæˆ process_i32
    process(3.14);      // ç”Ÿæˆ process_f64
    process("hello");   // ç”Ÿæˆ process_str
}

// ç¼–è¯‘åç­‰ä»·äºï¼š
// fn process_i32(value: i32) { println!("Value: {}", value); }
// fn process_f64(value: f64) { println!("Value: {}", value); }
// fn process_str(value: &str) { println!("Value: {}", value); }
```

### 2.2 æ€§èƒ½ä¼˜åŠ¿

**å†…è”ä¼˜åŒ–**:

```rust
trait Compute {
    fn compute(&self) -> i32;
}

struct FastCompute(i32);

impl Compute for FastCompute {
    #[inline]
    fn compute(&self) -> i32 {
        self.0 * 2
    }
}

// é™æ€åˆ†å‘å…è®¸å†…è”
fn process_static<T: Compute>(c: &T) -> i32 {
    c.compute()  // å¯ä»¥è¢«å†…è”
}

fn main() {
    let c = FastCompute(21);
    let result = process_static(&c);
    println!("Result: {}", result);
}
```

### 2.3 ä»£ç è†¨èƒ€

**é—®é¢˜ç¤ºä¾‹**:

```rust
fn large_function<T: std::fmt::Display>(value: T) {
    // 100+ è¡Œä»£ç 
    println!("{}", value);
    // ... æ›´å¤šä»£ç  ...
}

fn main() {
    // æ¯ä¸ªç±»å‹éƒ½ç”Ÿæˆä¸€ä»½å®Œæ•´ä»£ç 
    large_function(1);
    large_function(2_i64);
    large_function(3_i8);
    large_function(4_u32);
    // ... ä»£ç è†¨èƒ€ï¼
}
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```rust
// æå–éæ³›å‹éƒ¨åˆ†
fn common_logic() {
    // é€šç”¨ä»£ç åªæœ‰ä¸€ä»½
    println!("Common processing");
}

fn thin_wrapper<T: std::fmt::Display>(value: T) {
    common_logic();
    println!("{}", value);  // åªæœ‰è¿™éƒ¨åˆ†è¢«å•æ€åŒ–
}

fn main() {
    thin_wrapper(1);
    thin_wrapper(2_i64);
}
```

---

## 3. åŠ¨æ€åˆ†å‘

### 3.1 Trait å¯¹è±¡

**åˆ›å»º trait å¯¹è±¡**:

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}

fn main() {
    // åˆ›å»º trait å¯¹è±¡
    let circle: Box<dyn Shape> = Box::new(Circle { radius: 5.0 });
    let rectangle: Box<dyn Shape> = Box::new(Rectangle {
        width: 10.0,
        height: 20.0,
    });
    
    // å­˜å‚¨ä¸åŒç±»å‹
    let shapes: Vec<Box<dyn Shape>> = vec![circle, rectangle];
    
    for shape in shapes {
        println!("Area: {}", shape.area());
    }
}
```

### 3.2 è™šå‡½æ•°è¡¨

**vtable ç»“æ„**:

```rust
// trait å¯¹è±¡çš„å†…éƒ¨è¡¨ç¤º
struct TraitObject {
    data: *mut (),      // æŒ‡å‘æ•°æ®
    vtable: *const (),  // æŒ‡å‘ vtable
}

// vtable åŒ…å«ï¼š
// - drop å‡½æ•°æŒ‡é’ˆ
// - size å’Œ alignment
// - trait æ–¹æ³•æŒ‡é’ˆ
```

**ç¤ºä¾‹**:

```rust
trait Animal {
    fn make_sound(&self);
    fn move_forward(&self);
}

struct Dog {
    name: String,
}

impl Animal for Dog {
    fn make_sound(&self) {
        println!("{} says Woof!", self.name);
    }
    
    fn move_forward(&self) {
        println!("{} runs forward", self.name);
    }
}

fn main() {
    let dog = Dog {
        name: String::from("Buddy"),
    };
    
    // åˆ›å»º trait å¯¹è±¡æ—¶ï¼Œç¼–è¯‘å™¨ç”Ÿæˆ vtable
    let animal: &dyn Animal = &dog;
    
    // é€šè¿‡ vtable è°ƒç”¨æ–¹æ³•
    animal.make_sound();
    animal.move_forward();
}
```

### 3.3 æ€§èƒ½å¼€é”€

**åŸºå‡†æµ‹è¯•**:

```rust
use std::time::Instant;

trait Processor {
    fn process(&self, x: i32) -> i32;
}

struct SimpleProcessor;

impl Processor for SimpleProcessor {
    fn process(&self, x: i32) -> i32 {
        x * 2
    }
}

// é™æ€åˆ†å‘
fn static_bench<T: Processor>(p: &T) -> i32 {
    let mut sum = 0;
    for i in 0..1_000_000 {
        sum += p.process(i);
    }
    sum
}

// åŠ¨æ€åˆ†å‘
fn dynamic_bench(p: &dyn Processor) -> i32 {
    let mut sum = 0;
    for i in 0..1_000_000 {
        sum += p.process(i);
    }
    sum
}

fn main() {
    let processor = SimpleProcessor;
    
    let start = Instant::now();
    let _result = static_bench(&processor);
    println!("Static: {:?}", start.elapsed());
    
    let start = Instant::now();
    let _result = dynamic_bench(&processor);
    println!("Dynamic: {:?}", start.elapsed());
}
```

---

## 4. å¯¹è±¡å®‰å…¨

### 4.1 è§„åˆ™

**å¯¹è±¡å®‰å…¨çš„ trait å¿…é¡»æ»¡è¶³**:

1. âŒ æ–¹æ³•ä¸è¿”å› `Self`
2. âŒ æ–¹æ³•æ²¡æœ‰æ³›å‹ç±»å‹å‚æ•°
3. âœ… æ–¹æ³•æœ‰ `self` æ¥æ”¶è€…

```rust
// âœ… å¯¹è±¡å®‰å…¨
trait Safe {
    fn method(&self);
}

// âŒ ä¸å¯¹è±¡å®‰å…¨ï¼šè¿”å› Self
trait NotSafe1 {
    fn clone(&self) -> Self;
}

// âŒ ä¸å¯¹è±¡å®‰å…¨ï¼šæ³›å‹æ–¹æ³•
trait NotSafe2 {
    fn generic<T>(&self, value: T);
}

// âŒ ä¸å¯¹è±¡å®‰å…¨ï¼šå…³è”å‡½æ•°
trait NotSafe3 {
    fn new() -> Self;
}
```

### 4.2 å¸¸è§é™·é˜±

**Clone trait**:

```rust
// Clone ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„
trait Animal: Clone {
    fn make_sound(&self);
}

struct Dog;

impl Clone for Dog {
    fn clone(&self) -> Self {
        Dog
    }
}

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}

fn main() {
    let dog = Dog;
    // let animal: &dyn Animal = &dog;  // ç¼–è¯‘é”™è¯¯ï¼
}
```

### 4.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨è‡ªå®šä¹‰æ–¹æ³•**:

```rust
trait CloneableAnimal {
    fn make_sound(&self);
    fn clone_box(&self) -> Box<dyn CloneableAnimal>;
}

struct Dog;

impl CloneableAnimal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
    
    fn clone_box(&self) -> Box<dyn CloneableAnimal> {
        Box::new(Dog)
    }
}

fn main() {
    let dog = Dog;
    let animal: Box<dyn CloneableAnimal> = Box::new(dog);
    let cloned = animal.clone_box();
    cloned.make_sound();
}
```

---

## 5. é€‰æ‹©åˆé€‚çš„åˆ†å‘

### 5.1 å†³ç­–æ ‘

```text
éœ€è¦å­˜å‚¨ä¸åŒç±»å‹å—ï¼Ÿ
â”œâ”€ æ˜¯
â”‚  â””â”€ ä½¿ç”¨åŠ¨æ€åˆ†å‘ (trait å¯¹è±¡)
â””â”€ å¦
   â””â”€ éœ€è¦æœ€ä½³æ€§èƒ½å—ï¼Ÿ
      â”œâ”€ æ˜¯ â†’ ä½¿ç”¨é™æ€åˆ†å‘ (æ³›å‹)
      â””â”€ å¦ â†’ ä¸¤è€…éƒ½å¯
```

### 5.2 æ€§èƒ½å¯¹æ¯”

| ç‰¹æ€§ | é™æ€åˆ†å‘ | åŠ¨æ€åˆ†å‘ |
|------|---------|---------|
| **è°ƒç”¨å¼€é”€** | 0 (å¯å†…è”) | 1-2 æŒ‡ä»¤ (vtable æŸ¥æ‰¾) |
| **å†…å­˜å¼€é”€** | 0 | 2ä¸ªæŒ‡é’ˆ (æ•°æ®+vtable) |
| **ç¼–è¯‘æ—¶é—´** | è¾ƒé•¿ | è¾ƒçŸ­ |
| **äºŒè¿›åˆ¶å¤§å°** | è¾ƒå¤§ | è¾ƒå° |

### 5.3 ä½¿ç”¨åœºæ™¯

**é™æ€åˆ†å‘é€‚ç”¨äº**:

- âœ… æ€§èƒ½å…³é”®ä»£ç 
- âœ… ç¼–è¯‘æ—¶çŸ¥é“æ‰€æœ‰ç±»å‹
- âœ… éœ€è¦å†…è”ä¼˜åŒ–

**åŠ¨æ€åˆ†å‘é€‚ç”¨äº**:

- âœ… å¼‚æ„é›†åˆ
- âœ… æ’ä»¶ç³»ç»Ÿ
- âœ… å‡å°ä»£ç ä½“ç§¯

### 5.4 æ€§èƒ½æµ‹è¯•ä¸åˆ†æ

**å®é™…æ€§èƒ½å¯¹æ¯”**:

```rust
use std::time::Instant;

trait Calculator {
    fn calculate(&self, a: i32, b: i32) -> i32;
}

struct Adder;
impl Calculator for Adder {
    fn calculate(&self, a: i32, b: i32) -> i32 {
        a + b
    }
}

// é™æ€åˆ†å‘
fn benchmark_static<C: Calculator>(calc: &C, iterations: usize) -> std::time::Duration {
    let start = Instant::now();
    let mut sum = 0;
    for i in 0..iterations {
        sum += calc.calculate(i as i32, i as i32);
    }
    start.elapsed()
}

// åŠ¨æ€åˆ†å‘
fn benchmark_dynamic(calc: &dyn Calculator, iterations: usize) -> std::time::Duration {
    let start = Instant::now();
    let mut sum = 0;
    for i in 0..iterations {
        sum += calc.calculate(i as i32, i as i32);
    }
    start.elapsed()
}

fn main() {
    let adder = Adder;
    let iterations = 10_000_000;
    
    let static_time = benchmark_static(&adder, iterations);
    let dynamic_time = benchmark_dynamic(&adder, iterations);
    
    println!("é™æ€åˆ†å‘: {:?}", static_time);
    println!("åŠ¨æ€åˆ†å‘: {:?}", dynamic_time);
    println!("åŠ¨æ€å¼€é”€: {:.1}%", 
        (dynamic_time.as_nanos() as f64 / static_time.as_nanos() as f64 - 1.0) * 100.0);
}
```

### 5.5 æ··åˆç­–ç•¥å®è·µ

**æ™ºèƒ½é€‰æ‹©åˆ†å‘æ–¹å¼**:

```rust
enum Message {
    Text(String),
    Image(Vec<u8>),
    Complex(Box<dyn ComplexMessage>),
}

trait ComplexMessage {
    fn process(&self) -> String;
}

impl Message {
    fn handle(&self) -> String {
        match self {
            // å¸¸è§æƒ…å†µï¼šé™æ€åˆ†å‘ï¼ˆenumåŒ¹é…ï¼‰
            Message::Text(s) => s.clone(),
            Message::Image(data) => format!("Image: {} bytes", data.len()),
            // ç‰¹æ®Šæƒ…å†µï¼šåŠ¨æ€åˆ†å‘
            Message::Complex(msg) => msg.process(),
        }
    }
}

struct VideoMessage {
    duration: u32,
}

impl ComplexMessage for VideoMessage {
    fn process(&self) -> String {
        format!("Video: {}s", self.duration)
    }
}

fn main() {
    let messages = vec![
        Message::Text("Hello".to_string()),
        Message::Image(vec![1, 2, 3]),
        Message::Complex(Box::new(VideoMessage { duration: 60 })),
    ];
    
    for msg in &messages {
        println!("{}", msg.handle());
    }
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: æ’ä»¶ç³»ç»Ÿ

```rust
trait Plugin {
    fn name(&self) -> &str;
    fn execute(&self);
}

struct LoggerPlugin;
struct CachePlugin;

impl Plugin for LoggerPlugin {
    fn name(&self) -> &str {
        "Logger"
    }
    
    fn execute(&self) {
        println!("[Logger] Executing");
    }
}

impl Plugin for CachePlugin {
    fn name(&self) -> &str {
        "Cache"
    }
    
    fn execute(&self) {
        println!("[Cache] Executing");
    }
}

struct PluginManager {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginManager {
    fn new() -> Self {
        PluginManager {
            plugins: Vec::new(),
        }
    }
    
    fn register(&mut self, plugin: Box<dyn Plugin>) {
        println!("Registering plugin: {}", plugin.name());
        self.plugins.push(plugin);
    }
    
    fn execute_all(&self) {
        for plugin in &self.plugins {
            plugin.execute();
        }
    }
}

fn main() {
    let mut manager = PluginManager::new();
    
    manager.register(Box::new(LoggerPlugin));
    manager.register(Box::new(CachePlugin));
    
    manager.execute_all();
}
```

### æ¡ˆä¾‹ 2: GUI ç»„ä»¶

```rust
trait Component {
    fn render(&self);
    fn handle_event(&mut self, event: &str);
}

struct Button {
    label: String,
}

struct TextBox {
    content: String,
}

impl Component for Button {
    fn render(&self) {
        println!("[Button] {}", self.label);
    }
    
    fn handle_event(&mut self, event: &str) {
        println!("[Button] Handling: {}", event);
    }
}

impl Component for TextBox {
    fn render(&self) {
        println!("[TextBox] {}", self.content);
    }
    
    fn handle_event(&mut self, event: &str) {
        if event == "input" {
            self.content.push_str("_input");
        }
    }
}

struct Window {
    components: Vec<Box<dyn Component>>,
}

impl Window {
    fn new() -> Self {
        Window {
            components: Vec::new(),
        }
    }
    
    fn add(&mut self, component: Box<dyn Component>) {
        self.components.push(component);
    }
    
    fn render_all(&self) {
        for component in &self.components {
            component.render();
        }
    }
}

fn main() {
    let mut window = Window::new();
    
    window.add(Box::new(Button {
        label: String::from("Click Me"),
    }));
    window.add(Box::new(TextBox {
        content: String::from("Enter text"),
    }));
    
    window.render_all();
}
```

### æ¡ˆä¾‹ 3: æ—¥å¿—ç³»ç»Ÿ

```rust
trait Logger {
    fn log(&self, message: &str);
}

struct ConsoleLogger;
struct FileLogger {
    path: String,
}

impl Logger for ConsoleLogger {
    fn log(&self, message: &str) {
        println!("[Console] {}", message);
    }
}

impl Logger for FileLogger {
    fn log(&self, message: &str) {
        println!("[File:{}] {}", self.path, message);
    }
}

// é™æ€åˆ†å‘ç‰ˆæœ¬ï¼šé«˜æ€§èƒ½
fn log_many_static<L: Logger>(logger: &L, count: usize) {
    for i in 0..count {
        logger.log(&format!("Message {}", i));
    }
}

// åŠ¨æ€åˆ†å‘ç‰ˆæœ¬ï¼šçµæ´»
fn log_many_dynamic(logger: &dyn Logger, count: usize) {
    for i in 0..count {
        logger.log(&format!("Message {}", i));
    }
}

fn main() {
    let console = ConsoleLogger;
    let file = FileLogger {
        path: String::from("app.log"),
    };
    
    log_many_static(&console, 3);
    log_many_dynamic(&file, 3);
}
```

### æ¡ˆä¾‹ 4: åºåˆ—åŒ–ç³»ç»Ÿ

**åŠ¨æ€åˆ†å‘çš„å®é™…åº”ç”¨**:

```rust
trait Serializer {
    fn serialize_i32(&mut self, value: i32);
    fn serialize_string(&mut self, value: &str);
    fn finish(self: Box<Self>) -> Vec<u8>;
}

struct JsonSerializer {
    buffer: String,
}

impl JsonSerializer {
    fn new() -> Self {
        JsonSerializer {
            buffer: String::new(),
        }
    }
}

impl Serializer for JsonSerializer {
    fn serialize_i32(&mut self, value: i32) {
        self.buffer.push_str(&format!("{}", value));
    }
    
    fn serialize_string(&mut self, value: &str) {
        self.buffer.push_str(&format!("\"{}\"", value));
    }
    
    fn finish(self: Box<Self>) -> Vec<u8> {
        self.buffer.into_bytes()
    }
}

struct BinarySerializer {
    buffer: Vec<u8>,
}

impl BinarySerializer {
    fn new() -> Self {
        BinarySerializer {
            buffer: Vec::new(),
        }
    }
}

impl Serializer for BinarySerializer {
    fn serialize_i32(&mut self, value: i32) {
        self.buffer.extend_from_slice(&value.to_le_bytes());
    }
    
    fn serialize_string(&mut self, value: &str) {
        self.buffer.extend_from_slice(value.as_bytes());
    }
    
    fn finish(self: Box<Self>) -> Vec<u8> {
        self.buffer
    }
}

fn serialize_data(serializer: &mut dyn Serializer) {
    serializer.serialize_i32(42);
    serializer.serialize_string("Hello");
}

fn main() {
    let mut json = JsonSerializer::new();
    let mut binary = BinarySerializer::new();
    
    serialize_data(&mut json);
    serialize_data(&mut binary);
    
    let json_data = Box::new(json).finish();
    let binary_data = Box::new(binary).finish();
    
    println!("JSON: {:?}", String::from_utf8(json_data));
    println!("Binary: {:?}", binary_data);
}
```

### æ¡ˆä¾‹ 5: äº‹ä»¶å¤„ç†ç³»ç»Ÿ

**æ··åˆä½¿ç”¨é™æ€å’ŒåŠ¨æ€åˆ†å‘**:

```rust
trait EventHandler {
    fn handle(&mut self, event: &str);
}

struct ClickHandler;
struct KeyHandler {
    key_buffer: String,
}

impl EventHandler for ClickHandler {
    fn handle(&mut self, event: &str) {
        println!("[Click] {}", event);
    }
}

impl EventHandler for KeyHandler {
    fn handle(&mut self, event: &str) {
        self.key_buffer.push_str(event);
        println!("[Key] Buffer: {}", self.key_buffer);
    }
}

struct EventDispatcher {
    handlers: Vec<Box<dyn EventHandler>>,
}

impl EventDispatcher {
    fn new() -> Self {
        EventDispatcher {
            handlers: Vec::new(),
        }
    }
    
    fn register(&mut self, handler: Box<dyn EventHandler>) {
        self.handlers.push(handler);
    }
    
    fn dispatch(&mut self, event: &str) {
        for handler in &mut self.handlers {
            handler.handle(event);
        }
    }
}

fn main() {
    let mut dispatcher = EventDispatcher::new();
    
    dispatcher.register(Box::new(ClickHandler));
    dispatcher.register(Box::new(KeyHandler {
        key_buffer: String::new(),
    }));
    
    dispatcher.dispatch("click");
    dispatcher.dispatch("key_a");
}
```

---

## 7. ä¼˜åŒ–æŠ€å·§

**æŠ€å·§ 1: æ··åˆä½¿ç”¨**:

```rust
trait Process {
    fn process(&self, data: &[u8]);
}

// çƒ­è·¯å¾„ï¼šé™æ€åˆ†å‘
fn fast_path<T: Process>(processor: &T, data: &[u8]) {
    processor.process(data);
}

// å†·è·¯å¾„ï¼šåŠ¨æ€åˆ†å‘
fn slow_path(processor: &dyn Process, data: &[u8]) {
    processor.process(data);
}
```

**æŠ€å·§ 2: å°å¯¹è±¡ä¼˜åŒ–**:

```rust
enum SmallVec<T> {
    Inline([Option<T>; 4]),
    Heap(Vec<T>),
}
```

**æŠ€å·§ 3: ç¼“å­˜ vtable æŸ¥æ‰¾**:

```rust
// åœ¨å¾ªç¯å¤–è·å–æ–¹æ³•æŒ‡é’ˆ
fn optimized(shapes: &[&dyn Shape]) {
    for shape in shapes {
        let area = shape.area();  // vtable æŸ¥æ‰¾è¢«ä¼˜åŒ–
        println!("{}", area);
    }
}

trait Shape {
    fn area(&self) -> f64;
}
```

**æŠ€å·§ 4: æšä¸¾åˆ†å‘**:

```rust
// ä½¿ç”¨enumä»£æ›¿traitå¯¹è±¡
enum Operation {
    Add(i32, i32),
    Sub(i32, i32),
    Mul(i32, i32),
}

impl Operation {
    fn execute(&self) -> i32 {
        match self {
            Operation::Add(a, b) => a + b,
            Operation::Sub(a, b) => a - b,
            Operation::Mul(a, b) => a * b,
        }
    }
}

// vs traitå¯¹è±¡
trait OperationTrait {
    fn execute(&self) -> i32;
}

fn main() {
    let ops = vec![
        Operation::Add(1, 2),
        Operation::Sub(5, 3),
        Operation::Mul(4, 6),
    ];
    
    for op in ops {
        println!("{}", op.execute());  // æ›´å¿«ï¼
    }
}
```

**æŠ€å·§ 5: å†…è”å°å‡½æ•°**:

```rust
trait Compute {
    #[inline(always)]
    fn compute(&self, x: i32) -> i32;
}

struct Doubler;

impl Compute for Doubler {
    #[inline(always)]
    fn compute(&self, x: i32) -> i32 {
        x * 2
    }
}

// é™æ€åˆ†å‘+å†…è” = æè‡´æ€§èƒ½
fn process<C: Compute>(c: &C, values: &[i32]) -> Vec<i32> {
    values.iter().map(|&v| c.compute(v)).collect()
}
```

**æŠ€å·§ 6: åˆ†å±‚åˆ†å‘**:

```rust
// ä½¿ç”¨enumåˆ†å±‚å‡å°‘åŠ¨æ€åˆ†å‘
enum SimpleShape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl SimpleShape {
    fn area(&self) -> f64 {
        match self {
            SimpleShape::Circle { radius } => 3.14159 * radius * radius,
            SimpleShape::Rectangle { width, height } => width * height,
        }
    }
}

// å¤æ‚å½¢çŠ¶æ‰ä½¿ç”¨åŠ¨æ€åˆ†å‘
trait ComplexShape {
    fn area(&self) -> f64;
}

enum Shape {
    Simple(SimpleShape),
    Complex(Box<dyn ComplexShape>),
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Simple(s) => s.area(),       // å¿«é€Ÿè·¯å¾„
            Shape::Complex(s) => s.area(),      // çµæ´»è·¯å¾„
        }
    }
}
```

**æŠ€å·§ 7: Profile-Guided Optimization**:

```rust
// ä½¿ç”¨profilingå‘ç°çƒ­ç‚¹
use std::time::Instant;

fn benchmark_static<T: Process>(processor: &T, iterations: usize) {
    let start = Instant::now();
    for _ in 0..iterations {
        processor.process(&[1, 2, 3, 4, 5]);
    }
    println!("Static: {:?}", start.elapsed());
}

fn benchmark_dynamic(processor: &dyn Process, iterations: usize) {
    let start = Instant::now();
    for _ in 0..iterations {
        processor.process(&[1, 2, 3, 4, 5]);
    }
    println!("Dynamic: {:?}", start.elapsed());
}

trait Process {
    fn process(&self, data: &[i32]);
}
```

---

## 8. æ€»ç»“

**é€‰æ‹©æŒ‡å—**:

| åœºæ™¯ | æ¨è |
|------|------|
| æ€§èƒ½å…³é”® | é™æ€åˆ†å‘ |
| å¼‚æ„é›†åˆ | åŠ¨æ€åˆ†å‘ |
| æ’ä»¶ç³»ç»Ÿ | åŠ¨æ€åˆ†å‘ |
| é€šç”¨åº“ | é™æ€åˆ†å‘ |
| GUI ç»„ä»¶ | åŠ¨æ€åˆ†å‘ |
| æ•°å€¼è®¡ç®— | é™æ€åˆ†å‘ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… é»˜è®¤ä½¿ç”¨é™æ€åˆ†å‘
2. âœ… éœ€è¦è¿è¡Œæ—¶å¤šæ€æ—¶ä½¿ç”¨åŠ¨æ€åˆ†å‘
3. âœ… æ³¨æ„å¯¹è±¡å®‰å…¨è§„åˆ™
4. âœ… æ··åˆä½¿ç”¨ä»¥è·å¾—æœ€ä½³å¹³è¡¡

---

## 9. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Trait Objects](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)
- [Performance](https://doc.rust-lang.org/book/ch19-04-advanced-types.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.4 Traitç³»ç»ŸæŒ‡å—](../tier_02_guides/04_Traitç³»ç»ŸæŒ‡å—.md)
- [3.5 æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](./05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆåˆ†æ´¾æœºåˆ¶å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
