# 3.6 æµ®ç‚¹æ•°é«˜çº§ä¸»é¢˜ä¸ const fn è¯­ä¹‰ (Rust 1.90)

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: Rust 1.90 æµ®ç‚¹æ•°ç±»å‹é«˜çº§ç‰¹æ€§çš„æƒå¨æŠ€æœ¯å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æ·±å…¥ç†è§£æµ®ç‚¹æ•°è¯­ä¹‰å’Œ const fn èƒ½åŠ›çš„é«˜çº§å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [3.6 æµ®ç‚¹æ•°é«˜çº§ä¸»é¢˜ä¸ const fn è¯­ä¹‰ (Rust 1.90)](#36-æµ®ç‚¹æ•°é«˜çº§ä¸»é¢˜ä¸-const-fn-è¯­ä¹‰-rust-190)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Rust 1.90 æµ®ç‚¹æ•° const fn èƒ½åŠ›æ¦‚è§ˆ](#1-rust-190-æµ®ç‚¹æ•°-const-fn-èƒ½åŠ›æ¦‚è§ˆ)
    - [1.1 ç¨³å®šåŒ–çš„ const æµ®ç‚¹æ“ä½œ](#11-ç¨³å®šåŒ–çš„-const-æµ®ç‚¹æ“ä½œ)
    - [1.2 const ä¸Šä¸‹æ–‡ä¸­çš„é™åˆ¶](#12-const-ä¸Šä¸‹æ–‡ä¸­çš„é™åˆ¶)
  - [2. NaN (Not-a-Number) è¯­ä¹‰æ·±åº¦è§£æ](#2-nan-not-a-number-è¯­ä¹‰æ·±åº¦è§£æ)
    - [2.1 IEEE 754 NaN è¡¨ç¤º](#21-ieee-754-nan-è¡¨ç¤º)
    - [2.2 NaN çš„ä¼ æ’­è§„åˆ™](#22-nan-çš„ä¼ æ’­è§„åˆ™)
    - [2.3 NaN çš„æ¯”è¾ƒè¯­ä¹‰](#23-nan-çš„æ¯”è¾ƒè¯­ä¹‰)
    - [2.4 NaN åœ¨ const fn ä¸­çš„è¡Œä¸º](#24-nan-åœ¨-const-fn-ä¸­çš„è¡Œä¸º)
  - [3. ç‰¹æ®Šæµ®ç‚¹å€¼å¤„ç†](#3-ç‰¹æ®Šæµ®ç‚¹å€¼å¤„ç†)
    - [3.1 æ— ç©·å¤§ (Infinity) å¤„ç†](#31-æ— ç©·å¤§-infinity-å¤„ç†)
    - [3.2 é›¶å€¼ (+0.0 vs -0.0)](#32-é›¶å€¼-00-vs--00)
    - [3.3 æ¬¡æ­£è§„æ•° (Subnormal Numbers)](#33-æ¬¡æ­£è§„æ•°-subnormal-numbers)
  - [4. const fn æµ®ç‚¹æ“ä½œå®æˆ˜](#4-const-fn-æµ®ç‚¹æ“ä½œå®æˆ˜)
    - [4.1 ç¼–è¯‘æœŸå¸¸é‡è®¡ç®—](#41-ç¼–è¯‘æœŸå¸¸é‡è®¡ç®—)
    - [4.2 const fn ä¸­çš„æµ®ç‚¹åˆ†ç±»](#42-const-fn-ä¸­çš„æµ®ç‚¹åˆ†ç±»)
    - [4.3 ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹](#43-ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹)
  - [5. æµ®ç‚¹æ•°ä½æ¨¡å¼æ“ä½œ](#5-æµ®ç‚¹æ•°ä½æ¨¡å¼æ“ä½œ)
    - [5.1 to\_bits å’Œ from\_bits](#51-to_bits-å’Œ-from_bits)
    - [5.2 NaN payload è®¿é—®](#52-nan-payload-è®¿é—®)
    - [5.3 ä½æ¨¡å¼å®‰å…¨æ€§](#53-ä½æ¨¡å¼å®‰å…¨æ€§)
  - [6. å®é™…åº”ç”¨åœºæ™¯](#6-å®é™…åº”ç”¨åœºæ™¯)
    - [6.1 æ•°å€¼è®¡ç®—åº“ä¸­çš„ NaN å¤„ç†](#61-æ•°å€¼è®¡ç®—åº“ä¸­çš„-nan-å¤„ç†)
    - [6.2 ç¼–è¯‘æœŸç‰©ç†å¸¸æ•°å®šä¹‰](#62-ç¼–è¯‘æœŸç‰©ç†å¸¸æ•°å®šä¹‰)
    - [6.3 åµŒå…¥å¼ç³»ç»Ÿä¸­çš„æµ®ç‚¹ä¼˜åŒ–](#63-åµŒå…¥å¼ç³»ç»Ÿä¸­çš„æµ®ç‚¹ä¼˜åŒ–)
  - [7. æ€§èƒ½ä¸é™·é˜±](#7-æ€§èƒ½ä¸é™·é˜±)
    - [7.1 NaN æ£€æµ‹çš„æ€§èƒ½è€ƒè™‘](#71-nan-æ£€æµ‹çš„æ€§èƒ½è€ƒè™‘)
    - [7.2 å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•](#72-å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•)
    - [7.3 æµ®ç‚¹æ•°ç²¾åº¦æ·±åº¦åˆ†æ](#73-æµ®ç‚¹æ•°ç²¾åº¦æ·±åº¦åˆ†æ)
    - [7.4 æ•°å€¼ç¨³å®šæ€§æŠ€æœ¯](#74-æ•°å€¼ç¨³å®šæ€§æŠ€æœ¯)
    - [7.5 å®æˆ˜ï¼šé«˜ç²¾åº¦è®¡ç®—](#75-å®æˆ˜é«˜ç²¾åº¦è®¡ç®—)
    - [7.6 æµ®ç‚¹æ•°è°ƒè¯•æŠ€å·§](#76-æµ®ç‚¹æ•°è°ƒè¯•æŠ€å·§)
  - [8. å®æˆ˜æ¡ˆä¾‹é›†](#8-å®æˆ˜æ¡ˆä¾‹é›†)
    - [8.1 é‡‘èè®¡ç®—ï¼šé¿å…èˆå…¥è¯¯å·®](#81-é‡‘èè®¡ç®—é¿å…èˆå…¥è¯¯å·®)
    - [8.2 æ¸¸æˆå¼•æ“ï¼šå‘é‡è¿ç®—ä¼˜åŒ–](#82-æ¸¸æˆå¼•æ“å‘é‡è¿ç®—ä¼˜åŒ–)
    - [8.3 ç§‘å­¦è®¡ç®—ï¼šæ•°å€¼ç§¯åˆ†](#83-ç§‘å­¦è®¡ç®—æ•°å€¼ç§¯åˆ†)
    - [8.4 å›¾åƒå¤„ç†ï¼šé¢œè‰²ç©ºé—´è½¬æ¢](#84-å›¾åƒå¤„ç†é¢œè‰²ç©ºé—´è½¬æ¢)
    - [8.5 æœºå™¨å­¦ä¹ ï¼šSoftmaxç¨³å®šå®ç°](#85-æœºå™¨å­¦ä¹ softmaxç¨³å®šå®ç°)
  - [9. è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜](#9-è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜)
  - [9. ç›¸å…³èµ„æº](#9-ç›¸å…³èµ„æº)
    - [å†…éƒ¨æ–‡æ¡£](#å†…éƒ¨æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)
    - [ç›¸å…³ Crate](#ç›¸å…³-crate)

---

## 1. Rust 1.90 æµ®ç‚¹æ•° const fn èƒ½åŠ›æ¦‚è§ˆ

### 1.1 ç¨³å®šåŒ–çš„ const æµ®ç‚¹æ“ä½œ

è‡ª Rust 1.82 èµ·ï¼Œæµ®ç‚¹æ•°æ“ä½œå¼€å§‹é€æ­¥åœ¨ const ä¸Šä¸‹æ–‡ä¸­ç¨³å®šåŒ–ã€‚åœ¨ Rust 1.90 ä¸­ï¼Œä»¥ä¸‹èƒ½åŠ›å·²å®Œå…¨ç¨³å®šï¼š

```rust
// âœ… Rust 1.90 ç¨³å®šæ”¯æŒçš„ const æµ®ç‚¹æ“ä½œ
const CONST_OPERATIONS: () = {
    // åŸºæœ¬ç®—æœ¯è¿ç®—
    const ADD: f64 = 1.5 + 2.3;
    const SUB: f64 = 10.0 - 3.14;
    const MUL: f64 = 2.0 * 3.5;
    const DIV: f64 = 10.0 / 2.0;
    
    // å–è´Ÿå’Œç»å¯¹å€¼
    const NEG: f64 = -5.5;
    const ABS: f64 = (-3.14_f64).abs();
    
    // ç±»å‹è½¬æ¢ (as)
    const TO_INT: i32 = 3.14_f64 as i32;
    const TO_F32: f32 = 1.0_f64 as f32;
    
    // ç‰¹æ®Šå€¼å¸¸é‡
    const INFINITY: f64 = f64::INFINITY;
    const NEG_INFINITY: f64 = f64::NEG_INFINITY;
    const NAN: f64 = f64::NAN;
    
    // ä½æ¨¡å¼æ“ä½œ
    const BITS: u64 = 1.0_f64.to_bits();
    const FROM_BITS: f64 = f64::from_bits(0x3FF0000000000000);
};

fn main() {
    println!("ç¼–è¯‘æœŸè®¡ç®—ç»“æœ: {}", CONST_OPERATIONS::ADD);
}
```

**å…³é”®ç‚¹**ï¼š

- âœ… å››åˆ™è¿ç®—åœ¨ const ä¸Šä¸‹æ–‡ä¸­å®Œå…¨æ”¯æŒ
- âœ… `abs()`, `to_bits()`, `from_bits()` å¯ç”¨äº const fn
- âŒ è¶…è¶Šå‡½æ•° (`sin`, `cos`, `sqrt` ç­‰) åœ¨ Rust 1.90 ä¸­ä»ä¸æ”¯æŒ const

### 1.2 const ä¸Šä¸‹æ–‡ä¸­çš„é™åˆ¶

```rust
// âŒ Rust 1.90 ä¸­ä¸æ”¯æŒçš„ const æµ®ç‚¹æ“ä½œ
const fn unsupported_operations() -> f64 {
    // let sqrt = 4.0_f64.sqrt();      // âŒ è¶…è¶Šå‡½æ•°
    // let sin = 1.0_f64.sin();         // âŒ ä¸‰è§’å‡½æ•°
    // let log = 2.0_f64.ln();          // âŒ å¯¹æ•°å‡½æ•°
    // let pow = 2.0_f64.powf(3.0);     // âŒ å¹‚è¿ç®—
    
    // âœ… ä½†å¯ä»¥ä½¿ç”¨åŸºæœ¬è¿ç®—æ¨¡æ‹Ÿ
    let square = 2.0 * 2.0;
    square
}

// âœ… ç¼–è¯‘æœŸå¸¸é‡å®šä¹‰
const PI: f64 = 3.141592653589793;
const E: f64 = 2.718281828459045;

// âœ… const fn ä¸­å¯ä»¥ä½¿ç”¨çš„æ“ä½œ
const fn safe_sqrt_approx(x: f64) -> f64 {
    // ä½¿ç”¨ç‰›é¡¿è¿­ä»£æ³•çš„ç¼–è¯‘æœŸç‰ˆæœ¬ï¼ˆéœ€è¦å¾ªç¯æ”¯æŒï¼‰
    // è¿™é‡Œç®€åŒ–ä¸ºåŸºæœ¬è¿ç®—
    if x < 0.0 {
        f64::NAN
    } else {
        x / 2.0 // ç®€åŒ–çš„è¿‘ä¼¼
    }
}
```

---

## 2. NaN (Not-a-Number) è¯­ä¹‰æ·±åº¦è§£æ

### 2.1 IEEE 754 NaN è¡¨ç¤º

```rust
fn main() {
    // IEEE 754 è§„å®š NaN æœ‰ 2^52 - 2 ç§ä¸åŒçš„ä½æ¨¡å¼
    // Rust ä½¿ç”¨"é™é»˜ NaN" (quiet NaN) ä½œä¸ºæ ‡å‡† NaN
    
    // æ ‡å‡† NaN çš„ä½æ¨¡å¼ (f64)
    const NAN_BITS: u64 = f64::NAN.to_bits();
    println!("f64::NAN ä½æ¨¡å¼: 0x{:016X}", NAN_BITS);
    // è¾“å‡º: 0x7FF8000000000000
    //       ^^^^^^^^^^^^^^^^^^^
    //       ç¬¦å·ä½(1) | æŒ‡æ•°ä½(11) | å°¾æ•°ä½(52)
    //       0         | 11111111111 | 1000...000
    
    // ç¬¦å·ä½: 0 (æ­£ NaN)
    // æŒ‡æ•°ä½: å…¨1 (2047)
    // å°¾æ•°ä½: éé›¶ï¼Œæœ€é«˜ä½ä¸º1è¡¨ç¤ºé™é»˜ NaN
    
    // f32 çš„ NaN ä½æ¨¡å¼
    const NAN_F32_BITS: u32 = f32::NAN.to_bits();
    println!("f32::NAN ä½æ¨¡å¼: 0x{:08X}", NAN_F32_BITS);
    // è¾“å‡º: 0x7FC00000
}
```

**NaN åˆ†ç±»**ï¼š

- **é™é»˜ NaN (Quiet NaN, qNaN)**: å°¾æ•°æœ€é«˜ä½ä¸º1ï¼Œä¼ æ’­æ—¶ä¸è§¦å‘å¼‚å¸¸
- **ä¿¡å· NaN (Signaling NaN, sNaN)**: å°¾æ•°æœ€é«˜ä½ä¸º0ï¼Œç†è®ºä¸Šåº”è§¦å‘å¼‚å¸¸ï¼ˆRust ä¸ä½¿ç”¨ï¼‰

```rust
// åˆ›å»ºä¸åŒçš„ NaN
fn explore_nan_patterns() {
    // æ ‡å‡† NaN
    let nan = f64::NAN;
    
    // ä»ä½æ¨¡å¼åˆ›å»ºè‡ªå®šä¹‰ NaN (ä¿ç•™ payload)
    let custom_nan_bits: u64 = 0x7FF8_0000_0000_0001; // é™é»˜ NaN + payload
    let custom_nan = f64::from_bits(custom_nan_bits);
    
    // è¿ç®—äº§ç”Ÿçš„ NaN
    let zero_div_nan = 0.0_f64 / 0.0;
    let inf_sub_nan = f64::INFINITY - f64::INFINITY;
    let sqrt_neg_nan = (-1.0_f64).sqrt();
    
    // æ‰€æœ‰ NaN éƒ½ä¸ç›¸ç­‰
    println!("nan == custom_nan: {}", nan == custom_nan);      // false
    println!("nan == zero_div_nan: {}", nan == zero_div_nan);  // false
    
    // ä½†éƒ½æ˜¯ NaN
    println!("nan.is_nan(): {}", nan.is_nan());                // true
    println!("custom_nan.is_nan(): {}", custom_nan.is_nan());  // true
}
```

### 2.2 NaN çš„ä¼ æ’­è§„åˆ™

```rust
fn nan_propagation_rules() {
    let nan = f64::NAN;
    let x = 10.0_f64;
    
    // è§„åˆ™ 1: ä»»ä½•ç®—æœ¯è¿ç®—æ¶‰åŠ NaNï¼Œç»“æœä¸º NaN
    assert!((nan + x).is_nan());
    assert!((nan - x).is_nan());
    assert!((nan * x).is_nan());
    assert!((nan / x).is_nan());
    assert!((x / nan).is_nan());
    
    // è§„åˆ™ 2: NaN çš„ç¬¦å·è¿ç®—
    assert!((-nan).is_nan());           // å–è´Ÿä»ä¸º NaN
    assert!(nan.abs().is_nan());        // ç»å¯¹å€¼ä»ä¸º NaN
    
    // è§„åˆ™ 3: NaN ä¸æ— ç©·å¤§
    assert!((nan + f64::INFINITY).is_nan());
    assert!((nan * f64::INFINITY).is_nan());
    
    // è§„åˆ™ 4: 0 * Infinity = NaN
    assert!((0.0 * f64::INFINITY).is_nan());
    
    // è§„åˆ™ 5: Infinity / Infinity = NaN
    assert!((f64::INFINITY / f64::INFINITY).is_nan());
    
    // è§„åˆ™ 6: 0 / 0 = NaN
    assert!((0.0 / 0.0).is_nan());
}
```

### 2.3 NaN çš„æ¯”è¾ƒè¯­ä¹‰

```rust
fn nan_comparison_semantics() {
    let nan = f64::NAN;
    
    // æ ¸å¿ƒè§„åˆ™: NaN ä¸ä»»ä½•å€¼ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰æ¯”è¾ƒéƒ½ä¸º false
    assert!(!(nan == nan));       // false!
    assert!(!(nan < nan));        // false
    assert!(!(nan > nan));        // false
    assert!(!(nan <= nan));       // false
    assert!(!(nan >= nan));       // false
    assert!(nan != nan);          // true! (å”¯ä¸€ä¸º true çš„æ¯”è¾ƒ)
    
    // NaN ä¸å…¶ä»–å€¼çš„æ¯”è¾ƒ
    let x = 10.0_f64;
    assert!(!(nan == x));
    assert!(!(nan < x));
    assert!(!(nan > x));
    assert!(!(x < nan));
    assert!(!(x > nan));
    
    // è¿™å¯¼è‡´æ’åºæ—¶çš„ç‰¹æ®Šå¤„ç†
    let mut values = vec![1.0, f64::NAN, 2.0, 3.0];
    values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less));
    println!("æ’åºå: {:?}", values);
    // NaN é€šå¸¸è¢«æ”¾åœ¨å¼€å¤´æˆ–ç»“å°¾
}
```

**åœ¨é›†åˆä¸­çš„è¡Œä¸º**ï¼š

```rust
use std::collections::{HashSet, HashMap};

fn nan_in_collections() {
    // âš ï¸ NaN åœ¨ HashMap/HashSet ä¸­çš„è¡Œä¸ºä¸ç›´è§‚
    let mut set = HashSet::new();
    set.insert(f64::NAN);
    set.insert(f64::NAN);
    
    // NaN ä½æ¨¡å¼ç›¸åŒæ—¶ï¼Œè¢«è§†ä¸ºåŒä¸€ä¸ªé”®
    println!("set.len(): {}", set.len()); // è¾“å‡º: 1
    
    // ä½† contains å¯èƒ½è¿”å› false
    println!("contains NaN: {}", set.contains(&f64::NAN)); // å®ç°ä¾èµ–
    
    // æ¨è: æµ®ç‚¹æ•°ä½œä¸ºé”®æ—¶ï¼Œä½¿ç”¨ ordered_float ç­‰åº“
}
```

### 2.4 NaN åœ¨ const fn ä¸­çš„è¡Œä¸º

```rust
// âœ… const fn ä¸­å¯ä»¥ç”Ÿæˆå’Œæ£€æµ‹ NaN
const fn produce_nan() -> f64 {
    0.0 / 0.0  // ç¼–è¯‘æœŸç”Ÿæˆ NaN
}

const fn infinity_minus_infinity() -> f64 {
    f64::INFINITY - f64::INFINITY
}

// âŒ ä½† is_nan() åœ¨ Rust 1.90 ä¸­ä»ä¸èƒ½ç”¨äº const ä¸Šä¸‹æ–‡
// const fn check_nan(x: f64) -> bool {
//     x.is_nan()  // âŒ ç¼–è¯‘é”™è¯¯
// }

// âœ… å˜é€šæ–¹æ³•: ä½¿ç”¨ä½æ¨¡å¼æ£€æµ‹
const fn is_nan_const(x: f64) -> bool {
    let bits = x.to_bits();
    // NaN: æŒ‡æ•°ä½å…¨1ï¼Œå°¾æ•°ä½é0
    (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
        && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
}

const NAN_CHECK: bool = is_nan_const(f64::NAN);

fn main() {
    println!("ç¼–è¯‘æœŸ NaN æ£€æµ‹: {}", NAN_CHECK); // true
}
```

---

## 3. ç‰¹æ®Šæµ®ç‚¹å€¼å¤„ç†

### 3.1 æ— ç©·å¤§ (Infinity) å¤„ç†

```rust
fn infinity_operations() {
    let inf = f64::INFINITY;
    let neg_inf = f64::NEG_INFINITY;
    
    // æ— ç©·å¤§çš„ç®—æœ¯è¿ç®—
    assert_eq!(inf + 100.0, inf);           // âˆ + x = âˆ
    assert_eq!(inf * 2.0, inf);             // âˆ Ã— x = âˆ (x > 0)
    assert_eq!(inf * -2.0, neg_inf);        // âˆ Ã— x = -âˆ (x < 0)
    assert_eq!(1.0 / inf, 0.0);             // 1/âˆ = 0
    
    // æœªå®šä¹‰è¿ç®—äº§ç”Ÿ NaN
    assert!((inf - inf).is_nan());          // âˆ - âˆ = NaN
    assert!((inf / inf).is_nan());          // âˆ / âˆ = NaN
    assert!((inf * 0.0).is_nan());          // âˆ Ã— 0 = NaN
    
    // æ¯”è¾ƒè¯­ä¹‰
    assert!(inf > f64::MAX);
    assert!(neg_inf < f64::MIN);
    assert!(inf > neg_inf);
}

// const fn ä¸­ä½¿ç”¨æ— ç©·å¤§
const fn compute_with_infinity(x: f64) -> f64 {
    if x > 1e308 {  // æ¥è¿‘ f64::MAX
        f64::INFINITY
    } else {
        x * 2.0
    }
}
```

### 3.2 é›¶å€¼ (+0.0 vs -0.0)

```rust
fn signed_zero_semantics() {
    let pos_zero = 0.0_f64;
    let neg_zero = -0.0_f64;
    
    // IEEE 754 è§„å®š: +0.0 == -0.0
    assert_eq!(pos_zero, neg_zero);
    
    // ä½†ä½æ¨¡å¼ä¸åŒ
    assert_ne!(pos_zero.to_bits(), neg_zero.to_bits());
    println!("(+0.0).to_bits(): 0x{:016X}", pos_zero.to_bits()); // 0x0000000000000000
    println!("(-0.0).to_bits(): 0x{:016X}", neg_zero.to_bits()); // 0x8000000000000000
    
    // ç¬¦å·ä½å½±å“æŸäº›è¿ç®—
    assert_eq!(1.0 / pos_zero, f64::INFINITY);      // 1/+0 = +âˆ
    assert_eq!(1.0 / neg_zero, f64::NEG_INFINITY);  // 1/-0 = -âˆ
    
    // æŸäº›å‡½æ•°ä¿ç•™ç¬¦å·
    assert_eq!(pos_zero.copysign(1.0), pos_zero);
    assert_eq!(pos_zero.copysign(-1.0), neg_zero);
}

// æ£€æµ‹æœ‰ç¬¦å·é›¶
fn is_negative_zero(x: f64) -> bool {
    x == 0.0 && x.is_sign_negative()
}

const fn const_signed_zero_check(x: f64) -> bool {
    x.to_bits() == 0x8000_0000_0000_0000
}
```

### 3.3 æ¬¡æ­£è§„æ•° (Subnormal Numbers)

```rust
fn subnormal_numbers() {
    // f64 çš„æœ€å°æ­£è§„æ•°å’Œæœ€å°æ¬¡æ­£è§„æ•°
    const MIN_POSITIVE: f64 = f64::MIN_POSITIVE;  // 2^-1022 â‰ˆ 2.225e-308
    const MIN_SUBNORMAL: f64 = 5e-324;            // 2^-1074 (æœ€å°æ­£æ¬¡æ­£è§„æ•°)
    
    println!("æœ€å°æ­£è§„æ•°: {:.3e}", MIN_POSITIVE);
    println!("æœ€å°æ¬¡æ­£è§„æ•°: {:.3e}", MIN_SUBNORMAL);
    
    // æ¬¡æ­£è§„æ•°çš„ç‰¹å¾: æŒ‡æ•°ä½å…¨0ï¼Œå°¾æ•°ä½é0
    let is_subnormal = |x: f64| -> bool {
        let bits = x.to_bits();
        (bits & 0x7FF0_0000_0000_0000 == 0) && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
    };
    
    assert!(is_subnormal(MIN_SUBNORMAL));
    assert!(!is_subnormal(MIN_POSITIVE));
    
    // æ¬¡æ­£è§„æ•°çš„è¿ç®—å¯èƒ½ä¸§å¤±ç²¾åº¦
    let tiny = 1e-320;
    let result = tiny * tiny;
    println!("1e-320 * 1e-320 = {:.3e}", result); // å¯èƒ½ä¸‹æº¢ä¸º 0
}

// const fn ä¸­å¤„ç†æ¬¡æ­£è§„æ•°
const fn handle_subnormal(x: f64) -> f64 {
    // ç®€å•ç­–ç•¥: å°äºé˜ˆå€¼çš„å€¼æˆªæ–­ä¸º 0
    if x.abs() < f64::MIN_POSITIVE {
        0.0
    } else {
        x
    }
}
```

---

## 4. const fn æµ®ç‚¹æ“ä½œå®æˆ˜

### 4.1 ç¼–è¯‘æœŸå¸¸é‡è®¡ç®—

```rust
// ç‰©ç†å¸¸æ•°çš„ç¼–è¯‘æœŸå®šä¹‰
pub const SPEED_OF_LIGHT: f64 = 299_792_458.0;           // m/s
pub const PLANCK_CONSTANT: f64 = 6.62607015e-34;        // JÂ·s
pub const BOLTZMANN_CONSTANT: f64 = 1.380649e-23;       // J/K

// ç¼–è¯‘æœŸè®¡ç®—æ´¾ç”Ÿå¸¸æ•°
pub const REDUCED_PLANCK: f64 = PLANCK_CONSTANT / (2.0 * 3.141592653589793);

// const fn å‡½æ•°ç”¨äºå¤æ‚è®¡ç®—
const fn kelvin_to_celsius(k: f64) -> f64 {
    k - 273.15
}

const fn energy_from_frequency(frequency: f64) -> f64 {
    PLANCK_CONSTANT * frequency
}

// ç¼–è¯‘æœŸé…ç½®
const ROOM_TEMPERATURE_K: f64 = 293.15;
const ROOM_TEMPERATURE_C: f64 = kelvin_to_celsius(ROOM_TEMPERATURE_K);

fn main() {
    println!("å®¤æ¸© (æ‘„æ°): {:.2}Â°C", ROOM_TEMPERATURE_C);
    
    // ç¼–è¯‘æœŸè®¡ç®—çš„æ•°ç»„
    const TEMPS: [f64; 5] = [
        kelvin_to_celsius(273.15),
        kelvin_to_celsius(293.15),
        kelvin_to_celsius(373.15),
        kelvin_to_celsius(273.15 - 40.0),
        kelvin_to_celsius(0.0),
    ];
    println!("æ¸©åº¦æ•°ç»„: {:?}", TEMPS);
}
```

### 4.2 const fn ä¸­çš„æµ®ç‚¹åˆ†ç±»

```rust
// ä½¿ç”¨ä½æ¨¡å¼å®ç°ç¼–è¯‘æœŸæµ®ç‚¹åˆ†ç±»
const fn classify_float(x: f64) -> FloatClass {
    let bits = x.to_bits();
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    let sign = bits >> 63;
    
    if exp == 0 {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosZero
            } else {
                FloatClass::NegZero
            }
        } else {
            FloatClass::Subnormal
        }
    } else if exp == 0x7FF {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosInfinity
            } else {
                FloatClass::NegInfinity
            }
        } else {
            FloatClass::NaN
        }
    } else {
        FloatClass::Normal
    }
}

#[derive(Debug, PartialEq)]
enum FloatClass {
    PosZero,
    NegZero,
    Normal,
    Subnormal,
    PosInfinity,
    NegInfinity,
    NaN,
}

const CLASS_TESTS: [FloatClass; 7] = [
    classify_float(0.0),
    classify_float(-0.0),
    classify_float(1.0),
    classify_float(5e-324),
    classify_float(f64::INFINITY),
    classify_float(f64::NEG_INFINITY),
    classify_float(f64::NAN),
];

fn main() {
    for (i, class) in CLASS_TESTS.iter().enumerate() {
        println!("æµ‹è¯• {}: {:?}", i, class);
    }
}
```

### 4.3 ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹

```rust
// ä½¿ç”¨ const fn åœ¨ç¼–è¯‘æœŸæ£€æµ‹éæ³•é…ç½®
const fn validate_config(threshold: f64) -> f64 {
    // Rust 1.90 ä¸­ const panic å·²ç¨³å®š
    if threshold.is_infinite() {
        panic!("é˜ˆå€¼ä¸èƒ½ä¸ºæ— ç©·å¤§");
    }
    if threshold.is_nan() {
        panic!("é˜ˆå€¼ä¸èƒ½ä¸º NaN");
    }
    if threshold < 0.0 {
        panic!("é˜ˆå€¼å¿…é¡»ä¸ºéè´Ÿæ•°");
    }
    threshold
}

// ç¼–è¯‘æœŸéªŒè¯
const THRESHOLD: f64 = validate_config(0.001);
// const INVALID: f64 = validate_config(f64::NAN); // âŒ ç¼–è¯‘é”™è¯¯: NaN

// æ›´é«˜çº§çš„ç¼–è¯‘æœŸçº¦æŸ
const fn safe_divide(a: f64, b: f64) -> f64 {
    if b == 0.0 {
        panic!("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
    }
    a / b
}

const RATIO: f64 = safe_divide(10.0, 2.0);
// const BAD: f64 = safe_divide(10.0, 0.0); // âŒ ç¼–è¯‘é”™è¯¯

fn main() {
    println!("éªŒè¯çš„é˜ˆå€¼: {}", THRESHOLD);
    println!("å®‰å…¨çš„æ¯”ç‡: {}", RATIO);
}
```

---

## 5. æµ®ç‚¹æ•°ä½æ¨¡å¼æ“ä½œ

### 5.1 to_bits å’Œ from_bits

```rust
fn bit_pattern_operations() {
    let x = 1.0_f64;
    let bits = x.to_bits();
    
    // IEEE 754 åŒç²¾åº¦æ ¼å¼:
    // ä½ 63: ç¬¦å·ä½
    // ä½ 62-52: æŒ‡æ•° (11 ä½, åç§» 1023)
    // ä½ 51-0: å°¾æ•° (52 ä½, éšå«å‰å¯¼ 1)
    
    println!("1.0 çš„ä½æ¨¡å¼: 0x{:016X}", bits);
    // è¾“å‡º: 0x3FF0000000000000
    //       ^^^^ ^^^^
    //       ç¬¦å·(0) æŒ‡æ•°(01111111111=1023) å°¾æ•°(å…¨0)
    //       å®é™…å€¼: (-1)^0 Ã— 1.0 Ã— 2^(1023-1023) = 1.0
    
    // ä½æ“ä½œ
    let sign = bits >> 63;
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    
    println!("ç¬¦å·: {}, æŒ‡æ•°: {}, å°¾æ•°: 0x{:013X}", sign, exp, mantissa);
    
    // é‡æ–°æ„é€ 
    let reconstructed = f64::from_bits(bits);
    assert_eq!(x, reconstructed);
}

// const ä¸Šä¸‹æ–‡ä¸­çš„ä½æ“ä½œ
const fn extract_exponent(x: f64) -> u64 {
    (x.to_bits() >> 52) & 0x7FF
}

const fn extract_mantissa(x: f64) -> u64 {
    x.to_bits() & 0x000F_FFFF_FFFF_FFFF
}

const PI_EXP: u64 = extract_exponent(3.141592653589793);
const PI_MANTISSA: u64 = extract_mantissa(3.141592653589793);

fn main() {
    println!("Ï€ çš„æŒ‡æ•°: {} (å®é™…æŒ‡æ•°: {})", PI_EXP, PI_EXP as i64 - 1023);
    println!("Ï€ çš„å°¾æ•°: 0x{:013X}", PI_MANTISSA);
}
```

### 5.2 NaN payload è®¿é—®

```rust
// NaN çš„å°¾æ•°å¯ä»¥æºå¸¦"payload"ä¿¡æ¯
fn nan_payload() {
    // åˆ›å»ºå¸¦ payload çš„ NaN
    fn create_nan_with_payload(payload: u64) -> f64 {
        // ç¡®ä¿ payload å°äº 2^51 (ä¿ç•™æœ€é«˜ä½ä¸º1è¡¨ç¤ºé™é»˜ NaN)
        let payload = payload & 0x0007_FFFF_FFFF_FFFF;
        let nan_bits = 0x7FF8_0000_0000_0000 | payload;
        f64::from_bits(nan_bits)
    }
    
    // æå– payload
    fn extract_nan_payload(nan: f64) -> Option<u64> {
        if nan.is_nan() {
            Some(nan.to_bits() & 0x0007_FFFF_FFFF_FFFF)
        } else {
            None
        }
    }
    
    let error_code_1 = create_nan_with_payload(42);
    let error_code_2 = create_nan_with_payload(100);
    
    println!("NaN1 payload: {:?}", extract_nan_payload(error_code_1));
    println!("NaN2 payload: {:?}", extract_nan_payload(error_code_2));
    
    // æ³¨æ„: Rust ä¸ä¿è¯ NaN payload åœ¨è¿ç®—ä¸­ä¿ç•™
    let result = error_code_1 + 1.0;
    println!("è¿ç®—å payload: {:?}", extract_nan_payload(result));
}
```

### 5.3 ä½æ¨¡å¼å®‰å…¨æ€§

```rust
// from_bits ä¸æ£€æŸ¥è¾“å…¥åˆæ³•æ€§ï¼Œå¯èƒ½åˆ›å»ºéè§„èŒƒå€¼
fn bit_pattern_safety() {
    // âœ… åˆæ³•çš„ä½æ¨¡å¼
    let valid = f64::from_bits(0x3FF0_0000_0000_0000); // 1.0
    assert_eq!(valid, 1.0);
    
    // âš ï¸ ä¿¡å· NaN (sNaN) åœ¨æŸäº›å¹³å°å¯èƒ½è§¦å‘å¼‚å¸¸
    let signaling_nan = f64::from_bits(0x7FF0_0000_0000_0001);
    println!("sNaN is_nan: {}", signaling_nan.is_nan()); // true
    
    // âœ… æ¨è: ä½¿ç”¨é™é»˜ NaN
    let quiet_nan = f64::from_bits(0x7FF8_0000_0000_0001);
    
    // ä½æ¨¡å¼å¾€è¿”å¯èƒ½è§„èŒƒåŒ–
    let original_bits = 0x7FF0_0000_0000_0001; // sNaN
    let value = f64::from_bits(original_bits);
    let round_trip_bits = value.to_bits();
    
    // æŸäº›å¹³å°ä¼šå°† sNaN è½¬æ¢ä¸º qNaN
    if original_bits != round_trip_bits {
        println!("ä½æ¨¡å¼è¢«è§„èŒƒåŒ–: 0x{:016X} -> 0x{:016X}", 
                 original_bits, round_trip_bits);
    }
}

// const ä¸Šä¸‹æ–‡ä¸­çš„å®‰å…¨ä½æ“ä½œ
const fn safe_from_bits(bits: u64) -> f64 {
    // æ£€æµ‹ sNaN å¹¶è½¬æ¢ä¸º qNaN
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    
    if exp == 0x7FF && mantissa != 0 && (mantissa & 0x0008_0000_0000_0000) == 0 {
        // è¿™æ˜¯ sNaNï¼Œè½¬æ¢ä¸º qNaN
        f64::from_bits(bits | 0x0008_0000_0000_0000)
    } else {
        f64::from_bits(bits)
    }
}
```

---

## 6. å®é™…åº”ç”¨åœºæ™¯

### 6.1 æ•°å€¼è®¡ç®—åº“ä¸­çš„ NaN å¤„ç†

```rust
// ç»Ÿè®¡å‡½æ•°ä¸­çš„ NaN ä¼ æ’­
pub fn mean_with_nan_handling(data: &[f64]) -> f64 {
    if data.is_empty() {
        return f64::NAN;
    }
    
    let mut sum = 0.0;
    let mut count = 0;
    
    for &value in data {
        if !value.is_nan() {
            sum += value;
            count += 1;
        }
    }
    
    if count == 0 {
        f64::NAN
    } else {
        sum / count as f64
    }
}

// æ•°å€¼ç¨³å®šçš„æ±‚å’Œ
pub fn kahan_summation(data: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut compensation = 0.0;
    
    for &value in data {
        if value.is_nan() {
            return f64::NAN;
        }
        
        let y = value - compensation;
        let t = sum + y;
        compensation = (t - sum) - y;
        sum = t;
    }
    
    sum
}

fn main() {
    let data = vec![1.0, 2.0, f64::NAN, 4.0];
    println!("å‡å€¼ (å¿½ç•¥ NaN): {}", mean_with_nan_handling(&data));
    
    let clean_data = vec![1e-16, 1.0, 1e-16];
    println!("Kahan æ±‚å’Œ: {}", kahan_summation(&clean_data));
}
```

### 6.2 ç¼–è¯‘æœŸç‰©ç†å¸¸æ•°å®šä¹‰

```rust
// ç¼–è¯‘æœŸè®¡ç®—çš„ç‰©ç†å¸¸æ•°è¡¨
pub mod physics {
    // åŸºæœ¬å¸¸æ•°
    pub const C: f64 = 299_792_458.0;                    // å…‰é€Ÿ (m/s)
    pub const H: f64 = 6.62607015e-34;                   // æ™®æœ—å…‹å¸¸æ•° (JÂ·s)
    pub const K_B: f64 = 1.380649e-23;                   // ç»å°”å…¹æ›¼å¸¸æ•° (J/K)
    pub const E_0: f64 = 8.8541878128e-12;               // çœŸç©ºä»‹ç”µå¸¸æ•° (F/m)
    pub const MU_0: f64 = 1.25663706212e-6;              // çœŸç©ºç£å¯¼ç‡ (H/m)
    
    // æ´¾ç”Ÿå¸¸æ•° (ç¼–è¯‘æœŸè®¡ç®—)
    pub const H_BAR: f64 = H / (2.0 * 3.141592653589793);         // çº¦åŒ–æ™®æœ—å…‹å¸¸æ•°
    pub const IMPEDANCE_0: f64 = 376.730313668;                   // çœŸç©ºé˜»æŠ— (Î©)
    
    // å•ä½è½¬æ¢
    pub const EV_TO_JOULE: f64 = 1.602176634e-19;
    pub const JOULE_TO_EV: f64 = 1.0 / EV_TO_JOULE;
    
    // ç¼–è¯‘æœŸå‡½æ•°
    pub const fn wavelength_to_frequency(lambda: f64) -> f64 {
        C / lambda
    }
    
    pub const fn energy_to_wavelength(energy_joules: f64) -> f64 {
        (H * C) / energy_joules
    }
}

const VISIBLE_LIGHT_MIN_FREQ: f64 = physics::wavelength_to_frequency(700e-9);
const VISIBLE_LIGHT_MAX_FREQ: f64 = physics::wavelength_to_frequency(400e-9);

fn main() {
    println!("å¯è§å…‰é¢‘ç‡èŒƒå›´: {:.3e} - {:.3e} Hz", 
             VISIBLE_LIGHT_MIN_FREQ, VISIBLE_LIGHT_MAX_FREQ);
}
```

### 6.3 åµŒå…¥å¼ç³»ç»Ÿä¸­çš„æµ®ç‚¹ä¼˜åŒ–

```rust
// ç¼–è¯‘æœŸå†³å®šä½¿ç”¨è½¯æµ®ç‚¹è¿˜æ˜¯ç¡¬æµ®ç‚¹
#[cfg(target_feature = "fpu")]
const USE_HARDWARE_FLOAT: bool = true;
#[cfg(not(target_feature = "fpu"))]
const USE_HARDWARE_FLOAT: bool = false;

// ç¼–è¯‘æœŸé…ç½®ç²¾åº¦æƒè¡¡
const HIGH_PRECISION: bool = cfg!(feature = "high_precision");

const fn select_epsilon() -> f32 {
    if HIGH_PRECISION {
        1e-7
    } else {
        1e-5  // åµŒå…¥å¼ç³»ç»Ÿå¯æ¥å—çš„ç²¾åº¦
    }
}

const EPSILON: f32 = select_epsilon();

// å®šç‚¹æ•°æ¨¡æ‹Ÿæµ®ç‚¹æ•° (ç¼–è¯‘æœŸå†³ç­–)
const fn fixed_point_mul(a: i32, b: i32, scale: i32) -> i32 {
    ((a as i64 * b as i64) / scale as i64) as i32
}

const SCALE: i32 = 1000;
const RESULT: i32 = fixed_point_mul(1500, 2000, SCALE);

fn main() {
    println!("ä½¿ç”¨ç¡¬ä»¶æµ®ç‚¹: {}", USE_HARDWARE_FLOAT);
    println!("ç²¾åº¦é˜ˆå€¼: {}", EPSILON);
    println!("å®šç‚¹è¿ç®—: 1.5 * 2.0 = {}", RESULT as f32 / SCALE as f32);
}
```

---

## 7. æ€§èƒ½ä¸é™·é˜±

### 7.1 NaN æ£€æµ‹çš„æ€§èƒ½è€ƒè™‘

```rust
use std::time::Instant;

fn benchmark_nan_checks(data: &[f64], iterations: usize) {
    // æ–¹æ³• 1: is_nan()
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x.is_nan();
        }
    }
    let method1_time = start.elapsed();
    
    // æ–¹æ³• 2: è‡ªæ¯”è¾ƒ
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x != x;
        }
    }
    let method2_time = start.elapsed();
    
    // æ–¹æ³• 3: ä½æ¨¡å¼æ£€æŸ¥
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let bits = x.to_bits();
            let _ = (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
                && (bits & 0x000F_FFFF_FFFF_FFFF != 0);
        }
    }
    let method3_time = start.elapsed();
    
    println!("NaN æ£€æµ‹æ€§èƒ½ ({}æ¬¡è¿­ä»£):", iterations);
    println!("  is_nan():      {:?}", method1_time);
    println!("  x != x:        {:?}", method2_time);
    println!("  ä½æ¨¡å¼æ£€æŸ¥:     {:?}", method3_time);
}

fn main() {
    let data: Vec<f64> = (0..1000).map(|i| i as f64 * 0.1).collect();
    benchmark_nan_checks(&data, 10000);
}
```

**æ€§èƒ½å»ºè®®**ï¼š

- âœ… `is_nan()` é€šå¸¸æ˜¯æœ€å¿«çš„æ–¹æ³•ï¼ˆç¼–è¯‘å™¨ä¼˜åŒ–ï¼‰
- âœ… `x != x` è¯­ä¹‰æ¸…æ™°ï¼Œæ€§èƒ½æ¥è¿‘
- âŒ ä½æ¨¡å¼æ£€æŸ¥é€šå¸¸è¾ƒæ…¢ï¼Œé™¤ééœ€è¦ç²¾ç¡®æ§åˆ¶

### 7.2 å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•

```rust
// é™·é˜± 1: ä¸å½“çš„ NaN æ¯”è¾ƒ
fn pitfall_nan_comparison() {
    let nan = f64::NAN;
    
    // âŒ é”™è¯¯: æ°¸è¿œä¸ä¼šæ‰§è¡Œ
    if nan == f64::NAN {
        println!("This never prints");
    }
    
    // âœ… æ­£ç¡®
    if nan.is_nan() {
        println!("æ£€æµ‹åˆ° NaN");
    }
}

// é™·é˜± 2: æµ®ç‚¹æ•°ä½œä¸º HashMap é”®
fn pitfall_hash_key() {
    use std::collections::HashMap;
    
    let mut map = HashMap::new();
    map.insert(1.0, "one");
    
    // âš ï¸ æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜å¯èƒ½å¯¼è‡´é”®æŸ¥æ‰¾å¤±è´¥
    let key = 0.1 + 0.2; // 0.30000000000000004
    map.insert(key, "almost 0.3");
    
    // å¯èƒ½æ‰¾ä¸åˆ°
    println!("æŸ¥æ‰¾ 0.3: {:?}", map.get(&0.3));
    
    // âœ… æ¨è: ä½¿ç”¨æ•´æ•°æˆ– ordered_float::OrderedFloat
}

// é™·é˜± 3: ç´¯ç§¯è¯¯å·®
fn pitfall_accumulation() {
    // âŒ æœ´ç´ æ±‚å’Œ
    let mut sum = 0.0_f64;
    for _ in 0..1_000_000 {
        sum += 1e-10;
    }
    println!("æœ´ç´ æ±‚å’Œ: {:.15}", sum);
    // æœŸæœ›: 0.0001, å®é™…: è¯¯å·®è¾ƒå¤§
    
    // âœ… Kahan è¡¥å¿æ±‚å’Œ
    let mut sum = 0.0;
    let mut c = 0.0;
    for _ in 0..1_000_000 {
        let y = 1e-10 - c;
        let t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    println!("Kahan æ±‚å’Œ: {:.15}", sum);
}

// é™·é˜± 4: é™¤é›¶æ£€æŸ¥ä¸è¶³
fn pitfall_division() {
    let x = 10.0;
    let y = 0.0;
    
    // âš ï¸ ä¸ä¼š panicï¼Œä½†äº§ç”Ÿ Inf
    let result = x / y;
    println!("10.0 / 0.0 = {}", result); // Inf
    
    // âœ… æ˜¾å¼æ£€æŸ¥
    if y == 0.0 {
        eprintln!("é™¤æ•°ä¸ºé›¶");
    } else {
        println!("ç»“æœ: {}", x / y);
    }
    
    // âœ… ç»“æœéªŒè¯
    if result.is_finite() {
        println!("æœ‰é™ç»“æœ: {}", result);
    } else {
        eprintln!("ç»“æœéæœ‰é™: {}", result);
    }
}
```

### 7.3 æµ®ç‚¹æ•°ç²¾åº¦æ·±åº¦åˆ†æ

**IEEE 754ç²¾åº¦é™åˆ¶**:

```rust
fn precision_limits() {
    // f32: ~7ä½æœ‰æ•ˆåè¿›åˆ¶æ•°å­—
    let f32_val: f32 = 1.23456789;
    println!("f32ä¿ç•™ç²¾åº¦: {:.10}", f32_val);  // 1.2345678806
    
    // f64: ~15ä½æœ‰æ•ˆåè¿›åˆ¶æ•°å­—
    let f64_val: f64 = 1.234567890123456789;
    println!("f64ä¿ç•™ç²¾åº¦: {:.20}", f64_val);  // 1.23456789012345670000
    
    // è¶…å‡ºç²¾åº¦çš„æ•°å­—è¢«æˆªæ–­
    assert!(1.0 + 1e-16 != 1.0);  // f64èƒ½åŒºåˆ†
    assert!(1.0_f32 + 1e-8_f32 == 1.0_f32);  // f32æ— æ³•åŒºåˆ†
}
```

**æœºå™¨ç²¾åº¦ï¼ˆMachine Epsilonï¼‰**:

```rust
fn machine_epsilon() {
    // f32æœºå™¨ç²¾åº¦: 2^-23 â‰ˆ 1.19e-7
    let epsilon_f32 = f32::EPSILON;
    println!("f32 epsilon: {:.10e}", epsilon_f32);
    assert!(1.0_f32 + epsilon_f32 > 1.0_f32);
    assert!(1.0_f32 + epsilon_f32 / 2.0 == 1.0_f32);
    
    // f64æœºå™¨ç²¾åº¦: 2^-52 â‰ˆ 2.22e-16
    let epsilon_f64 = f64::EPSILON;
    println!("f64 epsilon: {:.20e}", epsilon_f64);
    assert!(1.0 + epsilon_f64 > 1.0);
    assert!(1.0 + epsilon_f64 / 2.0 == 1.0);
}
```

**ç›¸å¯¹è¯¯å·®åˆ†æ**:

```rust
fn relative_error_analysis() {
    let exact = 1.0 / 3.0;
    let approx = 0.333333333333333;
    
    let absolute_error = (exact - approx).abs();
    let relative_error = absolute_error / exact.abs();
    
    println!("ç»å¯¹è¯¯å·®: {:.20e}", absolute_error);
    println!("ç›¸å¯¹è¯¯å·®: {:.20e}", relative_error);
    
    // âœ… ç›¸å¯¹è¯¯å·®é€šå¸¸æ›´æœ‰æ„ä¹‰
    assert!(relative_error < 1e-15);
}
```

### 7.4 æ•°å€¼ç¨³å®šæ€§æŠ€æœ¯

**æŠ€æœ¯1ï¼šé¿å…ç¾éš¾æ€§æŠµæ¶ˆ**:

```rust
// âŒ ä¸ç¨³å®šï¼šä¸¤ä¸ªç›¸è¿‘æ•°ç›¸å‡
fn quadratic_unstable(a: f64, b: f64, c: f64) -> (f64, f64) {
    let discriminant = b * b - 4.0 * a * c;
    let sqrt_d = discriminant.sqrt();
    let x1 = (-b + sqrt_d) / (2.0 * a);
    let x2 = (-b - sqrt_d) / (2.0 * a);
    (x1, x2)
}

// âœ… ç¨³å®šï¼šä½¿ç”¨æ•°å€¼ç¨³å®šç®—æ³•
fn quadratic_stable(a: f64, b: f64, c: f64) -> (f64, f64) {
    let discriminant = b * b - 4.0 * a * c;
    let sqrt_d = discriminant.sqrt();
    
    // é¿å…ç¾éš¾æ€§æŠµæ¶ˆ
    let x1 = if b >= 0.0 {
        (-b - sqrt_d) / (2.0 * a)
    } else {
        (-b + sqrt_d) / (2.0 * a)
    };
    
    let x2 = c / (a * x1);  // ä½¿ç”¨éŸ¦è¾¾å®šç†
    (x1, x2)
}

fn main() {
    // æµ‹è¯•ç—…æ€æƒ…å†µ
    let (x1_unstable, x2_unstable) = quadratic_unstable(1.0, 1e8, 1.0);
    let (x1_stable, x2_stable) = quadratic_stable(1.0, 1e8, 1.0);
    
    println!("ä¸ç¨³å®šç®—æ³•: x1={:.15e}, x2={:.15e}", x1_unstable, x2_unstable);
    println!("ç¨³å®šç®—æ³•:   x1={:.15e}, x2={:.15e}", x1_stable, x2_stable);
}
```

**æŠ€æœ¯2ï¼šKahanç´¯åŠ ç®—æ³•**:

```rust
// âœ… é«˜ç²¾åº¦æ±‚å’Œ
fn kahan_sum(values: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut c = 0.0;  // è¯¯å·®è¡¥å¿
    
    for &value in values {
        let y = value - c;
        let t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    
    sum
}

// æ€§èƒ½æµ‹è¯•
fn compare_summation() {
    let values: Vec<f64> = (0..10_000_000)
        .map(|i| 1.0 / (i as f64 + 1.0))
        .collect();
    
    // æœ´ç´ æ±‚å’Œ
    let naive_sum: f64 = values.iter().sum();
    
    // Kahanæ±‚å’Œ
    let kahan = kahan_sum(&values);
    
    println!("æœ´ç´ æ±‚å’Œ: {:.15}", naive_sum);
    println!("Kahanæ±‚å’Œ: {:.15}", kahan);
    println!("å·®å¼‚: {:.15e}", (naive_sum - kahan).abs());
}
```

**æŠ€æœ¯3ï¼šé€’å½’å…³ç³»çš„ç¨³å®šæ€§**:

```rust
// âŒ ä¸ç¨³å®šï¼šå‘å‰é€’å½’
fn forward_recurrence(n: usize) -> f64 {
    if n == 0 {
        return 1.0;
    }
    if n == 1 {
        return 0.5;
    }
    (2.0 * n as f64 - 1.0) * forward_recurrence(n - 1) - forward_recurrence(n - 2)
}

// âœ… ç¨³å®šï¼šå‘åé€’å½’
fn backward_recurrence(n: usize) -> f64 {
    let mut values = vec![0.0; n + 1];
    values[n] = 1.0;
    values[n - 1] = 1.0;
    
    for i in (0..n-1).rev() {
        values[i] = ((2.0 * i as f64 + 1.0) * values[i + 1] - values[i + 2]) / (i as f64 + 1.0);
    }
    
    values[0]
}
```

### 7.5 å®æˆ˜ï¼šé«˜ç²¾åº¦è®¡ç®—

**æ¡ˆä¾‹1ï¼šè®¡ç®—æ•°å­¦å¸¸æ•°Ï€**:

```rust
// Machinå…¬å¼ï¼šÏ€/4 = 4*arctan(1/5) - arctan(1/239)
fn compute_pi(iterations: usize) -> f64 {
    fn arctan_series(x: f64, n: usize) -> f64 {
        let mut sum = 0.0;
        let x_squared = x * x;
        let mut term = x;
        
        for i in 0..n {
            let sign = if i % 2 == 0 { 1.0 } else { -1.0 };
            sum += sign * term / (2 * i + 1) as f64;
            term *= x_squared;
        }
        
        sum
    }
    
    4.0 * (4.0 * arctan_series(1.0 / 5.0, iterations) 
         - arctan_series(1.0 / 239.0, iterations))
}

fn main() {
    for n in [10, 50, 100] {
        let pi_approx = compute_pi(n);
        let error = (pi_approx - std::f64::consts::PI).abs();
        println!("n={:3}: Ï€â‰ˆ{:.15}, è¯¯å·®={:.2e}", n, pi_approx, error);
    }
}
```

**æ¡ˆä¾‹2ï¼šçŸ©é˜µè¿ç®—çš„æ•°å€¼ç¨³å®šæ€§**:

```rust
struct Matrix {
    data: Vec<Vec<f64>>,
}

impl Matrix {
    // âœ… åˆ—ä¸»å…ƒé«˜æ–¯æ¶ˆå…ƒï¼ˆæ•°å€¼ç¨³å®šï¼‰
    fn gaussian_elimination_pivoting(&mut self) -> Result<(), &'static str> {
        let n = self.data.len();
        
        for k in 0..n {
            // å¯»æ‰¾åˆ—ä¸»å…ƒ
            let mut max_row = k;
            for i in k+1..n {
                if self.data[i][k].abs() > self.data[max_row][k].abs() {
                    max_row = i;
                }
            }
            
            // äº¤æ¢è¡Œ
            if max_row != k {
                self.data.swap(k, max_row);
            }
            
            // æ£€æŸ¥å¥‡å¼‚æ€§
            if self.data[k][k].abs() < 1e-10 {
                return Err("çŸ©é˜µå¥‡å¼‚æˆ–ç—…æ€");
            }
            
            // æ¶ˆå…ƒ
            for i in k+1..n {
                let factor = self.data[i][k] / self.data[k][k];
                for j in k..n {
                    self.data[i][j] -= factor * self.data[k][j];
                }
            }
        }
        
        Ok(())
    }
}
```

### 7.6 æµ®ç‚¹æ•°è°ƒè¯•æŠ€å·§

**æŠ€å·§1ï¼šä½æ¨¡å¼æ£€æŸ¥**:

```rust
fn debug_float(value: f64) {
    let bits = value.to_bits();
    
    // æå–IEEE 754ç»„æˆéƒ¨åˆ†
    let sign = (bits >> 63) & 1;
    let exponent = ((bits >> 52) & 0x7FF) as i16 - 1023;
    let mantissa = bits & 0xFFFFFFFFFFFFF;
    
    println!("å€¼: {}", value);
    println!("ä½æ¨¡å¼: {:064b}", bits);
    println!("ç¬¦å·ä½: {}", sign);
    println!("æŒ‡æ•°: {} (biased: {})", exponent, exponent + 1023);
    println!("å°¾æ•°: {:052b}", mantissa);
    
    // åˆ†ç±»
    if value.is_nan() {
        println!("ç±»åˆ«: NaN");
    } else if value.is_infinite() {
        println!("ç±»åˆ«: æ— ç©·å¤§");
    } else if value == 0.0 {
        println!("ç±»åˆ«: é›¶ ({})", if sign == 0 { "+0.0" } else { "-0.0" });
    } else if value.is_subnormal() {
        println!("ç±»åˆ«: æ¬¡æ­£è§„æ•°");
    } else {
        println!("ç±»åˆ«: æ­£è§„æ•°");
    }
}

fn main() {
    debug_float(1.0);
    debug_float(-0.0);
    debug_float(f64::NAN);
    debug_float(f64::INFINITY);
    debug_float(f64::MIN_POSITIVE);
}
```

**æŠ€å·§2ï¼šæµ®ç‚¹æ•°æ¯”è¾ƒè¾…åŠ©å‡½æ•°**:

```rust
// âœ… å®‰å…¨çš„æµ®ç‚¹æ•°æ¯”è¾ƒ
fn approx_equal(a: f64, b: f64, rel_tol: f64, abs_tol: f64) -> bool {
    let diff = (a - b).abs();
    
    // å¤„ç†ç‰¹æ®Šå€¼
    if a == b {
        return true;  // åŒ…æ‹¬ Â±âˆ
    }
    if a.is_nan() || b.is_nan() {
        return false;
    }
    
    // ç›¸å¯¹è¯¯å·®æ£€æŸ¥
    let larger = a.abs().max(b.abs());
    diff <= larger * rel_tol || diff <= abs_tol
}

// æµ‹è¯•
fn test_comparisons() {
    assert!(approx_equal(0.1 + 0.2, 0.3, 1e-10, 1e-10));
    assert!(!approx_equal(1.0, 1.1, 1e-10, 1e-10));
    assert!(approx_equal(1e-20, 0.0, 1e-10, 1e-15));
}
```

**æŠ€å·§3ï¼šå•å…ƒæµ‹è¯•æµ®ç‚¹ä»£ç **:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_pi_computation() {
        let pi = compute_pi(100);
        assert!((pi - std::f64::consts::PI).abs() < 1e-10);
    }
    
    #[test]
    fn test_nan_handling() {
        let nan = f64::NAN;
        assert!(nan.is_nan());
        assert!(!(nan == nan));  // NaNä¸ç­‰äºè‡ªå·±
        assert!((nan + 1.0).is_nan());  // NaNä¼ æ’­
    }
    
    #[test]
    fn test_overflow() {
        let large = f64::MAX;
        let result = large * 2.0;
        assert!(result.is_infinite());
    }
    
    #[test]
    fn test_underflow() {
        let small = f64::MIN_POSITIVE;
        let result = small / 2.0;
        assert!(result > 0.0);  // æ¬¡æ­£è§„æ•°
        assert!(result < small);
    }
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹é›†

### 8.1 é‡‘èè®¡ç®—ï¼šé¿å…èˆå…¥è¯¯å·®

```rust
use std::ops::{Add, Sub, Mul, Div};

// âœ… ä½¿ç”¨æ•´æ•°è¡¨ç¤ºè´§å¸ï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼‰
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct Money {
    cents: i64,
}

impl Money {
    fn from_dollars(dollars: f64) -> Self {
        Self {
            cents: (dollars * 100.0).round() as i64,
        }
    }
    
    fn to_dollars(&self) -> f64 {
        self.cents as f64 / 100.0
    }
}

impl Add for Money {
    type Output = Self;
    fn add(self, rhs: Self) -> Self {
        Self { cents: self.cents + rhs.cents }
    }
}

// æµ‹è¯•
fn test_money() {
    let price1 = Money::from_dollars(10.10);
    let price2 = Money::from_dollars(20.20);
    let total = price1 + price2;
    
    assert_eq!(total.to_dollars(), 30.30);  // âœ… ç²¾ç¡®
    
    // âŒ æµ®ç‚¹æ•°ç›´æ¥è®¡ç®—ä¼šæœ‰è¯¯å·®
    assert!((10.10 + 20.20) != 30.30);
}
```

### 8.2 æ¸¸æˆå¼•æ“ï¼šå‘é‡è¿ç®—ä¼˜åŒ–

```rust
#[repr(C, align(16))]
#[derive(Clone, Copy)]
struct Vec3 {
    x: f32,
    y: f32,
    z: f32,
}

impl Vec3 {
    // âœ… SIMDå‹å¥½çš„å®ç°
    #[inline]
    fn dot(&self, other: &Vec3) -> f32 {
        // ä½¿ç”¨ FMA (Fused Multiply-Add) æé«˜ç²¾åº¦å’Œæ€§èƒ½
        self.x.mul_add(other.x, 
            self.y.mul_add(other.y, self.z * other.z))
    }
    
    #[inline]
    fn length(&self) -> f32 {
        self.dot(self).sqrt()
    }
    
    // âœ… å¿«é€Ÿè¿‘ä¼¼ï¼šé€†å¹³æ–¹æ ¹ï¼ˆQuake IIIç®—æ³•ï¼‰
    #[inline]
    fn fast_inv_sqrt(x: f32) -> f32 {
        let i = x.to_bits();
        let i = 0x5f3759df - (i >> 1);
        let y = f32::from_bits(i);
        
        // ç‰›é¡¿è¿­ä»£æ”¹è¿›
        y * (1.5 - 0.5 * x * y * y)
    }
    
    #[inline]
    fn normalize_fast(&self) -> Vec3 {
        let inv_len = Self::fast_inv_sqrt(self.dot(self));
        Vec3 {
            x: self.x * inv_len,
            y: self.y * inv_len,
            z: self.z * inv_len,
        }
    }
}

// æ€§èƒ½åŸºå‡†æµ‹è¯•
fn benchmark_normalization() {
    let v = Vec3 { x: 1.0, y: 2.0, z: 3.0 };
    
    // æ ‡å‡†æ–¹æ³•
    let start = std::time::Instant::now();
    for _ in 0..1_000_000 {
        let len = v.length();
        let _ = Vec3 {
            x: v.x / len,
            y: v.y / len,
            z: v.z / len,
        };
    }
    let standard_time = start.elapsed();
    
    // å¿«é€Ÿæ–¹æ³•
    let start = std::time::Instant::now();
    for _ in 0..1_000_000 {
        let _ = v.normalize_fast();
    }
    let fast_time = start.elapsed();
    
    println!("æ ‡å‡†å½’ä¸€åŒ–: {:?}", standard_time);
    println!("å¿«é€Ÿå½’ä¸€åŒ–: {:?}", fast_time);
    println!("åŠ é€Ÿæ¯”: {:.2}x", standard_time.as_secs_f64() / fast_time.as_secs_f64());
}
```

### 8.3 ç§‘å­¦è®¡ç®—ï¼šæ•°å€¼ç§¯åˆ†

```rust
// âœ… è‡ªé€‚åº”è¾›æ™®æ£®ç§¯åˆ†æ³•
fn adaptive_simpson<F>(f: F, a: f64, b: f64, tol: f64) -> f64
where
    F: Fn(f64) -> f64,
{
    fn simpson<F>(f: &F, a: f64, b: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let h = (b - a) / 2.0;
        let mid = (a + b) / 2.0;
        h / 3.0 * (f(a) + 4.0 * f(mid) + f(b))
    }
    
    fn adaptive_simpson_rec<F>(
        f: &F,
        a: f64,
        b: f64,
        tol: f64,
        whole: f64,
    ) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let mid = (a + b) / 2.0;
        let left = simpson(f, a, mid);
        let right = simpson(f, mid, b);
        
        if (left + right - whole).abs() < 15.0 * tol {
            left + right + (left + right - whole) / 15.0
        } else {
            adaptive_simpson_rec(f, a, mid, tol / 2.0, left)
                + adaptive_simpson_rec(f, mid, b, tol / 2.0, right)
        }
    }
    
    let whole = simpson(&f, a, b);
    adaptive_simpson_rec(&f, a, b, tol, whole)
}

// æµ‹è¯•
fn test_integration() {
    // âˆ«â‚€Â¹ xÂ² dx = 1/3
    let result = adaptive_simpson(|x| x * x, 0.0, 1.0, 1e-10);
    let exact = 1.0 / 3.0;
    println!("æ•°å€¼ç§¯åˆ†: {:.15}", result);
    println!("ç²¾ç¡®å€¼: {:.15}", exact);
    println!("è¯¯å·®: {:.2e}", (result - exact).abs());
}
```

### 8.4 å›¾åƒå¤„ç†ï¼šé¢œè‰²ç©ºé—´è½¬æ¢

```rust
#[derive(Clone, Copy)]
struct RGB {
    r: f32,  // [0.0, 1.0]
    g: f32,
    b: f32,
}

#[derive(Clone, Copy)]
struct HSV {
    h: f32,  // [0.0, 360.0)
    s: f32,  // [0.0, 1.0]
    v: f32,  // [0.0, 1.0]
}

impl RGB {
    // âœ… RGB â†’ HSV è½¬æ¢ï¼ˆæ•°å€¼ç¨³å®šï¼‰
    fn to_hsv(&self) -> HSV {
        let max = self.r.max(self.g).max(self.b);
        let min = self.r.min(self.g).min(self.b);
        let delta = max - min;
        
        let v = max;
        
        let s = if max > 1e-6 {
            delta / max
        } else {
            0.0
        };
        
        let h = if delta < 1e-6 {
            0.0  // ç°è‰²ï¼Œè‰²ç›¸æœªå®šä¹‰
        } else if (max - self.r).abs() < 1e-6 {
            60.0 * (((self.g - self.b) / delta) % 6.0)
        } else if (max - self.g).abs() < 1e-6 {
            60.0 * (((self.b - self.r) / delta) + 2.0)
        } else {
            60.0 * (((self.r - self.g) / delta) + 4.0)
        };
        
        let h = if h < 0.0 { h + 360.0 } else { h };
        
        HSV { h, s, v }
    }
}

impl HSV {
    // âœ… HSV â†’ RGB è½¬æ¢
    fn to_rgb(&self) -> RGB {
        let c = self.v * self.s;
        let h_prime = self.h / 60.0;
        let x = c * (1.0 - ((h_prime % 2.0) - 1.0).abs());
        
        let (r1, g1, b1) = match h_prime as i32 {
            0 => (c, x, 0.0),
            1 => (x, c, 0.0),
            2 => (0.0, c, x),
            3 => (0.0, x, c),
            4 => (x, 0.0, c),
            _ => (c, 0.0, x),
        };
        
        let m = self.v - c;
        RGB {
            r: r1 + m,
            g: g1 + m,
            b: b1 + m,
        }
    }
}
```

### 8.5 æœºå™¨å­¦ä¹ ï¼šSoftmaxç¨³å®šå®ç°

```rust
// âŒ ä¸ç¨³å®šï¼šç›´æ¥è®¡ç®—ä¼šä¸Šæº¢
fn softmax_unstable(logits: &[f64]) -> Vec<f64> {
    let sum: f64 = logits.iter().map(|&x| x.exp()).sum();
    logits.iter().map(|&x| x.exp() / sum).collect()
}

// âœ… ç¨³å®šï¼šå‡å»æœ€å¤§å€¼
fn softmax_stable(logits: &[f64]) -> Vec<f64> {
    let max = logits.iter().copied().fold(f64::NEG_INFINITY, f64::max);
    let exp_shifted: Vec<f64> = logits.iter().map(|&x| (x - max).exp()).collect();
    let sum: f64 = exp_shifted.iter().sum();
    exp_shifted.iter().map(|&x| x / sum).collect()
}

// æµ‹è¯•
fn test_softmax() {
    let logits = vec![1000.0, 1001.0, 1002.0];
    
    // ä¸ç¨³å®šç‰ˆæœ¬ä¼šäº§ç”ŸNaN
    let unstable = softmax_unstable(&logits);
    println!("ä¸ç¨³å®šç»“æœ: {:?}", unstable);
    
    // ç¨³å®šç‰ˆæœ¬äº§ç”Ÿæ­£ç¡®ç»“æœ
    let stable = softmax_stable(&logits);
    println!("ç¨³å®šç»“æœ: {:?}", stable);
    assert!((stable.iter().sum::<f64>() - 1.0).abs() < 1e-10);
}
```

---

## 9. è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜

| ç‰¹æ€§                          | Rust 1.82 | Rust 1.90 | è¯´æ˜                                  |
|-------------------------------|-----------|-----------|---------------------------------------|
| `f32/f64` åŸºæœ¬è¿ç®— const æ”¯æŒ | ç¨³å®š      | ç¨³å®š      | +, -, *, /, - (å–è´Ÿ)                  |
| `abs()` const æ”¯æŒ            | ç¨³å®š      | ç¨³å®š      | ç»å¯¹å€¼                                |
| `to_bits()/from_bits()` const | ç¨³å®š      | ç¨³å®š      | ä½æ¨¡å¼è½¬æ¢                            |
| `is_nan()/is_infinite()` const| ä¸ç¨³å®š    | **ç¨³å®š**  | **Rust 1.84+ ç¨³å®šåŒ–**                 |
| `copysign()` const            | ä¸ç¨³å®š    | **ç¨³å®š**  | **Rust 1.85+ ç¨³å®šåŒ–**                 |
| `min()/max()` const           | ä¸ç¨³å®š    | éƒ¨åˆ†ç¨³å®š  | éœ€è¦ feature flag (Rust 1.90)         |
| `sqrt()/sin()/cos()` const    | ä¸ç¨³å®š    | ä¸ç¨³å®š    | è¶…è¶Šå‡½æ•°ä»ä¸æ”¯æŒ                      |

**è¿ç§»å»ºè®®**ï¼š

- å¯¹äº Rust 1.90ï¼Œå¯å®‰å…¨ä½¿ç”¨åŸºæœ¬è¿ç®—å’Œä½æ¨¡å¼æ“ä½œ
- æµ®ç‚¹åˆ†ç±»å‡½æ•° (`is_nan()`, `is_finite()`) å¯é€šè¿‡ä½æ¨¡å¼æ¨¡æ‹Ÿ
- è¶…è¶Šå‡½æ•°éœ€ä¾èµ–è¿è¡Œæ—¶è®¡ç®—æˆ–ç¬¬ä¸‰æ–¹ const æ•°å­¦åº“

---

## 9. ç›¸å…³èµ„æº

### å†…éƒ¨æ–‡æ¡£

- [åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md) - æµ®ç‚¹æ•°åŸºç¡€
- [ç±»å‹è½¬æ¢å‚è€ƒ](01_ç±»å‹è½¬æ¢å‚è€ƒ.md) - æµ®ç‚¹æ•°ç±»å‹è½¬æ¢è§„åˆ™
- [æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md) - æµ®ç‚¹æ•°æ€§èƒ½ä¼˜åŒ–

### å¤–éƒ¨èµ„æº

- **IEEE 754 æ ‡å‡†**: <https://ieeexplore.ieee.org/document/8766229>
- **Rust RFC 3514 (const float ops)**: <https://github.com/rust-lang/rfcs/pull/3514>
- **Float Toy (å¯è§†åŒ–å·¥å…·)**: <https://evanw.github.io/float-toy/>
- **What Every Computer Scientist Should Know About Floating-Point Arithmetic**: <https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html>

### ç›¸å…³ Crate

- `ordered-float`: å®ç° `Ord` å’Œ `Hash` çš„æµ®ç‚¹åŒ…è£…å™¨
- `approx`: æµ®ç‚¹æ•°è¿‘ä¼¼æ¯”è¾ƒ
- `num-traits`: æ•°å€¼ç±»å‹ trait æŠ½è±¡
- `libm`: çº¯ Rust æ•°å­¦å‡½æ•°åº“ (æ”¯æŒ const)

---

**æ€»ç»“**ï¼šRust 1.90 çš„æµ®ç‚¹æ•° const fn èƒ½åŠ›ä¸ºç¼–è¯‘æœŸè®¡ç®—å’Œé…ç½®æä¾›äº†å¼ºå¤§æ”¯æŒã€‚ç†è§£ NaN è¯­ä¹‰ã€ç‰¹æ®Šå€¼å¤„ç†å’Œä½æ¨¡å¼æ“ä½œï¼Œèƒ½å¤Ÿç¼–å†™å‡ºæ›´å®‰å…¨ã€æ›´é«˜æ•ˆçš„æ•°å€¼è®¡ç®—ä»£ç ã€‚åœ¨ä½¿ç”¨ const fn æ—¶ï¼Œè¦æ³¨æ„å½“å‰ç‰ˆæœ¬çš„é™åˆ¶ï¼Œå¹¶æ ¹æ®éœ€è¦é‡‡ç”¨ä½æ“ä½œç­‰å˜é€šæ–¹æ³•ã€‚

**ä¸‹ä¸€æ­¥**ï¼šå»ºè®®é˜…è¯» [é«˜çº§æ³›å‹æ¨¡å¼](../tier_04_advanced/02_é«˜çº§æ³›å‹æ¨¡å¼.md) ä»¥äº†è§£æ³›å‹å¸¸é‡è¡¨è¾¾å¼ï¼ˆGeneric Const Exprsï¼‰ï¼Œå®ƒä¸ const fn ç»“åˆèƒ½å®ç°æ›´å¼ºå¤§çš„ç¼–è¯‘æœŸç¼–ç¨‹ã€‚
