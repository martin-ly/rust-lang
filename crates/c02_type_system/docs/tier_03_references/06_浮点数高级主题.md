# 3.6 浮点数高级主题与 const fn 语义 (Rust 1.92.0)

> **文档类型**: Tier 3 - 参考层
> **文档定位**: Rust 1.92.0 浮点数类型高级特性的权威技术参考
> **适用对象**: 需要深入理解浮点数语义和 const fn 能力的高级开发者
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [基础类型指南](../tier_02_guides/01_基础类型指南.md)

## 📋 目录

- [3.6 浮点数高级主题与 const fn 语义 (Rust 1.92.0)](#36-浮点数高级主题与-const-fn-语义-rust-1920)
  - [📋 目录](#-目录)
  - [1. Rust 1.92.0 浮点数 const fn 能力概览](#1-rust-1920-浮点数-const-fn-能力概览)
    - [1.1 稳定化的 const 浮点操作](#11-稳定化的-const-浮点操作)
    - [1.2 const 上下文中的限制](#12-const-上下文中的限制)
  - [2. NaN (Not-a-Number) 语义深度解析](#2-nan-not-a-number-语义深度解析)
    - [2.1 IEEE 754 NaN 表示](#21-ieee-754-nan-表示)
    - [2.2 NaN 的传播规则](#22-nan-的传播规则)
    - [2.3 NaN 的比较语义](#23-nan-的比较语义)
    - [2.4 NaN 在 const fn 中的行为](#24-nan-在-const-fn-中的行为)
  - [3. 特殊浮点值处理](#3-特殊浮点值处理)
    - [3.1 无穷大 (Infinity) 处理](#31-无穷大-infinity-处理)
    - [3.2 零值 (+0.0 vs -0.0)](#32-零值-00-vs--00)
    - [3.3 次正规数 (Subnormal Numbers)](#33-次正规数-subnormal-numbers)
  - [4. const fn 浮点操作实战](#4-const-fn-浮点操作实战)
    - [4.1 编译期常量计算](#41-编译期常量计算)
    - [4.2 const fn 中的浮点分类](#42-const-fn-中的浮点分类)
    - [4.3 编译期错误检测](#43-编译期错误检测)
  - [5. 浮点数位模式操作](#5-浮点数位模式操作)
    - [5.1 to\_bits 和 from\_bits](#51-to_bits-和-from_bits)
    - [5.2 NaN payload 访问](#52-nan-payload-访问)
    - [5.3 位模式安全性](#53-位模式安全性)
  - [6. 实际应用场景](#6-实际应用场景)
    - [6.1 数值计算库中的 NaN 处理](#61-数值计算库中的-nan-处理)
    - [6.2 编译期物理常数定义](#62-编译期物理常数定义)
    - [6.3 嵌入式系统中的浮点优化](#63-嵌入式系统中的浮点优化)
  - [7. 性能与陷阱](#7-性能与陷阱)
    - [7.1 NaN 检测的性能考虑](#71-nan-检测的性能考虑)
    - [7.2 常见陷阱与避免方法](#72-常见陷阱与避免方法)
    - [7.3 浮点数精度深度分析](#73-浮点数精度深度分析)
    - [7.4 数值稳定性技术](#74-数值稳定性技术)
    - [7.5 实战：高精度计算](#75-实战高精度计算)
    - [7.6 浮点数调试技巧](#76-浮点数调试技巧)
  - [8. 实战案例集](#8-实战案例集)
    - [8.1 金融计算：避免舍入误差](#81-金融计算避免舍入误差)
    - [8.2 游戏引擎：向量运算优化](#82-游戏引擎向量运算优化)
    - [8.3 科学计算：数值积分](#83-科学计算数值积分)
    - [8.4 图像处理：颜色空间转换](#84-图像处理颜色空间转换)
    - [8.5 机器学习：Softmax稳定实现](#85-机器学习softmax稳定实现)
  - [9. 跨版本兼容性说明](#9-跨版本兼容性说明)
  - [9. 相关资源](#9-相关资源)
    - [内部文档](#内部文档)
    - [外部资源](#外部资源)
    - [相关 Crate](#相关-crate)

---

## 1. Rust 1.92.0 浮点数 const fn 能力概览

### 1.1 稳定化的 const 浮点操作

自 Rust 1.82 起，浮点数操作开始逐步在 const 上下文中稳定化。在 Rust 1.92.0 中，以下能力已完全稳定：

```rust
// ✅ Rust 1.92.0 稳定支持的 const 浮点操作
const CONST_OPERATIONS: () = {
    // 基本算术运算
    const ADD: f64 = 1.5 + 2.3;
    const SUB: f64 = 10.0 - 3.14;
    const MUL: f64 = 2.0 * 3.5;
    const DIV: f64 = 10.0 / 2.0;

    // 取负和绝对值
    const NEG: f64 = -5.5;
    const ABS: f64 = (-3.14_f64).abs();

    // 类型转换 (as)
    const TO_INT: i32 = 3.14_f64 as i32;
    const TO_F32: f32 = 1.0_f64 as f32;

    // 特殊值常量
    const INFINITY: f64 = f64::INFINITY;
    const NEG_INFINITY: f64 = f64::NEG_INFINITY;
    const NAN: f64 = f64::NAN;

    // 位模式操作
    const BITS: u64 = 1.0_f64.to_bits();
    const FROM_BITS: f64 = f64::from_bits(0x3FF0000000000000);
};

fn main() {
    println!("编译期计算结果: {}", CONST_OPERATIONS::ADD);
}
```

**关键点**：

- ✅ 四则运算在 const 上下文中完全支持
- ✅ `abs()`, `to_bits()`, `from_bits()` 可用于 const fn
- ❌ 超越函数 (`sin`, `cos`, `sqrt` 等) 在 Rust 1.92.0 中仍不支持 const（预期未来版本支持）

### 1.2 const 上下文中的限制

```rust
// ❌ Rust 1.92.0 中不支持的 const 浮点操作（预期未来版本支持）
const fn unsupported_operations() -> f64 {
    // let sqrt = 4.0_f64.sqrt();      // ❌ 超越函数
    // let sin = 1.0_f64.sin();         // ❌ 三角函数
    // let log = 2.0_f64.ln();          // ❌ 对数函数
    // let pow = 2.0_f64.powf(3.0);     // ❌ 幂运算

    // ✅ 但可以使用基本运算模拟
    let square = 2.0 * 2.0;
    square
}

// ✅ 编译期常量定义
const PI: f64 = 3.141592653589793;
const E: f64 = 2.718281828459045;

// ✅ const fn 中可以使用的操作
const fn safe_sqrt_approx(x: f64) -> f64 {
    // 使用牛顿迭代法的编译期版本（需要循环支持）
    // 这里简化为基本运算
    if x < 0.0 {
        f64::NAN
    } else {
        x / 2.0 // 简化的近似
    }
}
```

---

## 2. NaN (Not-a-Number) 语义深度解析

### 2.1 IEEE 754 NaN 表示

```rust
fn main() {
    // IEEE 754 规定 NaN 有 2^52 - 2 种不同的位模式
    // Rust 使用"静默 NaN" (quiet NaN) 作为标准 NaN

    // 标准 NaN 的位模式 (f64)
    const NAN_BITS: u64 = f64::NAN.to_bits();
    println!("f64::NAN 位模式: 0x{:016X}", NAN_BITS);
    // 输出: 0x7FF8000000000000
    //       ^^^^^^^^^^^^^^^^^^^
    //       符号位(1) | 指数位(11) | 尾数位(52)
    //       0         | 11111111111 | 1000...000

    // 符号位: 0 (正 NaN)
    // 指数位: 全1 (2047)
    // 尾数位: 非零，最高位为1表示静默 NaN

    // f32 的 NaN 位模式
    const NAN_F32_BITS: u32 = f32::NAN.to_bits();
    println!("f32::NAN 位模式: 0x{:08X}", NAN_F32_BITS);
    // 输出: 0x7FC00000
}
```

**NaN 分类**：

- **静默 NaN (Quiet NaN, qNaN)**: 尾数最高位为1，传播时不触发异常
- **信号 NaN (Signaling NaN, sNaN)**: 尾数最高位为0，理论上应触发异常（Rust 不使用）

```rust
// 创建不同的 NaN
fn explore_nan_patterns() {
    // 标准 NaN
    let nan = f64::NAN;

    // 从位模式创建自定义 NaN (保留 payload)
    let custom_nan_bits: u64 = 0x7FF8_0000_0000_0001; // 静默 NaN + payload
    let custom_nan = f64::from_bits(custom_nan_bits);

    // 运算产生的 NaN
    let zero_div_nan = 0.0_f64 / 0.0;
    let inf_sub_nan = f64::INFINITY - f64::INFINITY;
    let sqrt_neg_nan = (-1.0_f64).sqrt();

    // 所有 NaN 都不相等
    println!("nan == custom_nan: {}", nan == custom_nan);      // false
    println!("nan == zero_div_nan: {}", nan == zero_div_nan);  // false

    // 但都是 NaN
    println!("nan.is_nan(): {}", nan.is_nan());                // true
    println!("custom_nan.is_nan(): {}", custom_nan.is_nan());  // true
}
```

### 2.2 NaN 的传播规则

```rust
fn nan_propagation_rules() {
    let nan = f64::NAN;
    let x = 10.0_f64;

    // 规则 1: 任何算术运算涉及 NaN，结果为 NaN
    assert!((nan + x).is_nan());
    assert!((nan - x).is_nan());
    assert!((nan * x).is_nan());
    assert!((nan / x).is_nan());
    assert!((x / nan).is_nan());

    // 规则 2: NaN 的符号运算
    assert!((-nan).is_nan());           // 取负仍为 NaN
    assert!(nan.abs().is_nan());        // 绝对值仍为 NaN

    // 规则 3: NaN 与无穷大
    assert!((nan + f64::INFINITY).is_nan());
    assert!((nan * f64::INFINITY).is_nan());

    // 规则 4: 0 * Infinity = NaN
    assert!((0.0 * f64::INFINITY).is_nan());

    // 规则 5: Infinity / Infinity = NaN
    assert!((f64::INFINITY / f64::INFINITY).is_nan());

    // 规则 6: 0 / 0 = NaN
    assert!((0.0 / 0.0).is_nan());
}
```

### 2.3 NaN 的比较语义

```rust
fn nan_comparison_semantics() {
    let nan = f64::NAN;

    // 核心规则: NaN 与任何值（包括自己）比较都为 false
    assert!(!(nan == nan));       // false!
    assert!(!(nan < nan));        // false
    assert!(!(nan > nan));        // false
    assert!(!(nan <= nan));       // false
    assert!(!(nan >= nan));       // false
    assert!(nan != nan);          // true! (唯一为 true 的比较)

    // NaN 与其他值的比较
    let x = 10.0_f64;
    assert!(!(nan == x));
    assert!(!(nan < x));
    assert!(!(nan > x));
    assert!(!(x < nan));
    assert!(!(x > nan));

    // 这导致排序时的特殊处理
    let mut values = vec![1.0, f64::NAN, 2.0, 3.0];
    values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less));
    println!("排序后: {:?}", values);
    // NaN 通常被放在开头或结尾
}
```

**在集合中的行为**：

```rust
use std::collections::{HashSet, HashMap};

fn nan_in_collections() {
    // ⚠️ NaN 在 HashMap/HashSet 中的行为不直观
    let mut set = HashSet::new();
    set.insert(f64::NAN);
    set.insert(f64::NAN);

    // NaN 位模式相同时，被视为同一个键
    println!("set.len(): {}", set.len()); // 输出: 1

    // 但 contains 可能返回 false
    println!("contains NaN: {}", set.contains(&f64::NAN)); // 实现依赖

    // 推荐: 浮点数作为键时，使用 ordered_float 等库
}
```

### 2.4 NaN 在 const fn 中的行为

```rust
// ✅ const fn 中可以生成和检测 NaN
const fn produce_nan() -> f64 {
    0.0 / 0.0  // 编译期生成 NaN
}

const fn infinity_minus_infinity() -> f64 {
    f64::INFINITY - f64::INFINITY
}

// ❌ 但 is_nan() 在 Rust 1.92.0 中仍不能用于 const 上下文（预期未来版本支持）
// const fn check_nan(x: f64) -> bool {
//     x.is_nan()  // ❌ 编译错误
// }

// ✅ 变通方法: 使用位模式检测
const fn is_nan_const(x: f64) -> bool {
    let bits = x.to_bits();
    // NaN: 指数位全1，尾数位非0
    (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
        && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
}

const NAN_CHECK: bool = is_nan_const(f64::NAN);

fn main() {
    println!("编译期 NaN 检测: {}", NAN_CHECK); // true
}
```

---

## 3. 特殊浮点值处理

### 3.1 无穷大 (Infinity) 处理

```rust
fn infinity_operations() {
    let inf = f64::INFINITY;
    let neg_inf = f64::NEG_INFINITY;

    // 无穷大的算术运算
    assert_eq!(inf + 100.0, inf);           // ∞ + x = ∞
    assert_eq!(inf * 2.0, inf);             // ∞ × x = ∞ (x > 0)
    assert_eq!(inf * -2.0, neg_inf);        // ∞ × x = -∞ (x < 0)
    assert_eq!(1.0 / inf, 0.0);             // 1/∞ = 0

    // 未定义运算产生 NaN
    assert!((inf - inf).is_nan());          // ∞ - ∞ = NaN
    assert!((inf / inf).is_nan());          // ∞ / ∞ = NaN
    assert!((inf * 0.0).is_nan());          // ∞ × 0 = NaN

    // 比较语义
    assert!(inf > f64::MAX);
    assert!(neg_inf < f64::MIN);
    assert!(inf > neg_inf);
}

// const fn 中使用无穷大
const fn compute_with_infinity(x: f64) -> f64 {
    if x > 1e308 {  // 接近 f64::MAX
        f64::INFINITY
    } else {
        x * 2.0
    }
}
```

### 3.2 零值 (+0.0 vs -0.0)

```rust
fn signed_zero_semantics() {
    let pos_zero = 0.0_f64;
    let neg_zero = -0.0_f64;

    // IEEE 754 规定: +0.0 == -0.0
    assert_eq!(pos_zero, neg_zero);

    // 但位模式不同
    assert_ne!(pos_zero.to_bits(), neg_zero.to_bits());
    println!("(+0.0).to_bits(): 0x{:016X}", pos_zero.to_bits()); // 0x0000000000000000
    println!("(-0.0).to_bits(): 0x{:016X}", neg_zero.to_bits()); // 0x8000000000000000

    // 符号位影响某些运算
    assert_eq!(1.0 / pos_zero, f64::INFINITY);      // 1/+0 = +∞
    assert_eq!(1.0 / neg_zero, f64::NEG_INFINITY);  // 1/-0 = -∞

    // 某些函数保留符号
    assert_eq!(pos_zero.copysign(1.0), pos_zero);
    assert_eq!(pos_zero.copysign(-1.0), neg_zero);
}

// 检测有符号零
fn is_negative_zero(x: f64) -> bool {
    x == 0.0 && x.is_sign_negative()
}

const fn const_signed_zero_check(x: f64) -> bool {
    x.to_bits() == 0x8000_0000_0000_0000
}
```

### 3.3 次正规数 (Subnormal Numbers)

```rust
fn subnormal_numbers() {
    // f64 的最小正规数和最小次正规数
    const MIN_POSITIVE: f64 = f64::MIN_POSITIVE;  // 2^-1022 ≈ 2.225e-308
    const MIN_SUBNORMAL: f64 = 5e-324;            // 2^-1074 (最小正次正规数)

    println!("最小正规数: {:.3e}", MIN_POSITIVE);
    println!("最小次正规数: {:.3e}", MIN_SUBNORMAL);

    // 次正规数的特征: 指数位全0，尾数位非0
    let is_subnormal = |x: f64| -> bool {
        let bits = x.to_bits();
        (bits & 0x7FF0_0000_0000_0000 == 0) && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
    };

    assert!(is_subnormal(MIN_SUBNORMAL));
    assert!(!is_subnormal(MIN_POSITIVE));

    // 次正规数的运算可能丧失精度
    let tiny = 1e-320;
    let result = tiny * tiny;
    println!("1e-320 * 1e-320 = {:.3e}", result); // 可能下溢为 0
}

// const fn 中处理次正规数
const fn handle_subnormal(x: f64) -> f64 {
    // 简单策略: 小于阈值的值截断为 0
    if x.abs() < f64::MIN_POSITIVE {
        0.0
    } else {
        x
    }
}
```

---

## 4. const fn 浮点操作实战

### 4.1 编译期常量计算

```rust
// 物理常数的编译期定义
pub const SPEED_OF_LIGHT: f64 = 299_792_458.0;           // m/s
pub const PLANCK_CONSTANT: f64 = 6.62607015e-34;        // J·s
pub const BOLTZMANN_CONSTANT: f64 = 1.380649e-23;       // J/K

// 编译期计算派生常数
pub const REDUCED_PLANCK: f64 = PLANCK_CONSTANT / (2.0 * 3.141592653589793);

// const fn 函数用于复杂计算
const fn kelvin_to_celsius(k: f64) -> f64 {
    k - 273.15
}

const fn energy_from_frequency(frequency: f64) -> f64 {
    PLANCK_CONSTANT * frequency
}

// 编译期配置
const ROOM_TEMPERATURE_K: f64 = 293.15;
const ROOM_TEMPERATURE_C: f64 = kelvin_to_celsius(ROOM_TEMPERATURE_K);

fn main() {
    println!("室温 (摄氏): {:.2}°C", ROOM_TEMPERATURE_C);

    // 编译期计算的数组
    const TEMPS: [f64; 5] = [
        kelvin_to_celsius(273.15),
        kelvin_to_celsius(293.15),
        kelvin_to_celsius(373.15),
        kelvin_to_celsius(273.15 - 40.0),
        kelvin_to_celsius(0.0),
    ];
    println!("温度数组: {:?}", TEMPS);
}
```

### 4.2 const fn 中的浮点分类

```rust
// 使用位模式实现编译期浮点分类
const fn classify_float(x: f64) -> FloatClass {
    let bits = x.to_bits();
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    let sign = bits >> 63;

    if exp == 0 {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosZero
            } else {
                FloatClass::NegZero
            }
        } else {
            FloatClass::Subnormal
        }
    } else if exp == 0x7FF {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosInfinity
            } else {
                FloatClass::NegInfinity
            }
        } else {
            FloatClass::NaN
        }
    } else {
        FloatClass::Normal
    }
}

#[derive(Debug, PartialEq)]
enum FloatClass {
    PosZero,
    NegZero,
    Normal,
    Subnormal,
    PosInfinity,
    NegInfinity,
    NaN,
}

const CLASS_TESTS: [FloatClass; 7] = [
    classify_float(0.0),
    classify_float(-0.0),
    classify_float(1.0),
    classify_float(5e-324),
    classify_float(f64::INFINITY),
    classify_float(f64::NEG_INFINITY),
    classify_float(f64::NAN),
];

fn main() {
    for (i, class) in CLASS_TESTS.iter().enumerate() {
        println!("测试 {}: {:?}", i, class);
    }
}
```

### 4.3 编译期错误检测

```rust
// 使用 const fn 在编译期检测非法配置
const fn validate_config(threshold: f64) -> f64 {
    // Rust 1.92.0 中 const panic 已稳定
    if threshold.is_infinite() {
        panic!("阈值不能为无穷大");
    }
    if threshold.is_nan() {
        panic!("阈值不能为 NaN");
    }
    if threshold < 0.0 {
        panic!("阈值必须为非负数");
    }
    threshold
}

// 编译期验证
const THRESHOLD: f64 = validate_config(0.001);
// const INVALID: f64 = validate_config(f64::NAN); // ❌ 编译错误: NaN

// 更高级的编译期约束
const fn safe_divide(a: f64, b: f64) -> f64 {
    if b == 0.0 {
        panic!("除数不能为零");
    }
    a / b
}

const RATIO: f64 = safe_divide(10.0, 2.0);
// const BAD: f64 = safe_divide(10.0, 0.0); // ❌ 编译错误

fn main() {
    println!("验证的阈值: {}", THRESHOLD);
    println!("安全的比率: {}", RATIO);
}
```

---

## 5. 浮点数位模式操作

### 5.1 to_bits 和 from_bits

```rust
fn bit_pattern_operations() {
    let x = 1.0_f64;
    let bits = x.to_bits();

    // IEEE 754 双精度格式:
    // 位 63: 符号位
    // 位 62-52: 指数 (11 位, 偏移 1023)
    // 位 51-0: 尾数 (52 位, 隐含前导 1)

    println!("1.0 的位模式: 0x{:016X}", bits);
    // 输出: 0x3FF0000000000000
    //       ^^^^ ^^^^
    //       符号(0) 指数(01111111111=1023) 尾数(全0)
    //       实际值: (-1)^0 × 1.0 × 2^(1023-1023) = 1.0

    // 位操作
    let sign = bits >> 63;
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;

    println!("符号: {}, 指数: {}, 尾数: 0x{:013X}", sign, exp, mantissa);

    // 重新构造
    let reconstructed = f64::from_bits(bits);
    assert_eq!(x, reconstructed);
}

// const 上下文中的位操作
const fn extract_exponent(x: f64) -> u64 {
    (x.to_bits() >> 52) & 0x7FF
}

const fn extract_mantissa(x: f64) -> u64 {
    x.to_bits() & 0x000F_FFFF_FFFF_FFFF
}

const PI_EXP: u64 = extract_exponent(3.141592653589793);
const PI_MANTISSA: u64 = extract_mantissa(3.141592653589793);

fn main() {
    println!("π 的指数: {} (实际指数: {})", PI_EXP, PI_EXP as i64 - 1023);
    println!("π 的尾数: 0x{:013X}", PI_MANTISSA);
}
```

### 5.2 NaN payload 访问

```rust
// NaN 的尾数可以携带"payload"信息
fn nan_payload() {
    // 创建带 payload 的 NaN
    fn create_nan_with_payload(payload: u64) -> f64 {
        // 确保 payload 小于 2^51 (保留最高位为1表示静默 NaN)
        let payload = payload & 0x0007_FFFF_FFFF_FFFF;
        let nan_bits = 0x7FF8_0000_0000_0000 | payload;
        f64::from_bits(nan_bits)
    }

    // 提取 payload
    fn extract_nan_payload(nan: f64) -> Option<u64> {
        if nan.is_nan() {
            Some(nan.to_bits() & 0x0007_FFFF_FFFF_FFFF)
        } else {
            None
        }
    }

    let error_code_1 = create_nan_with_payload(42);
    let error_code_2 = create_nan_with_payload(100);

    println!("NaN1 payload: {:?}", extract_nan_payload(error_code_1));
    println!("NaN2 payload: {:?}", extract_nan_payload(error_code_2));

    // 注意: Rust 不保证 NaN payload 在运算中保留
    let result = error_code_1 + 1.0;
    println!("运算后 payload: {:?}", extract_nan_payload(result));
}
```

### 5.3 位模式安全性

```rust
// from_bits 不检查输入合法性，可能创建非规范值
fn bit_pattern_safety() {
    // ✅ 合法的位模式
    let valid = f64::from_bits(0x3FF0_0000_0000_0000); // 1.0
    assert_eq!(valid, 1.0);

    // ⚠️ 信号 NaN (sNaN) 在某些平台可能触发异常
    let signaling_nan = f64::from_bits(0x7FF0_0000_0000_0001);
    println!("sNaN is_nan: {}", signaling_nan.is_nan()); // true

    // ✅ 推荐: 使用静默 NaN
    let quiet_nan = f64::from_bits(0x7FF8_0000_0000_0001);

    // 位模式往返可能规范化
    let original_bits = 0x7FF0_0000_0000_0001; // sNaN
    let value = f64::from_bits(original_bits);
    let round_trip_bits = value.to_bits();

    // 某些平台会将 sNaN 转换为 qNaN
    if original_bits != round_trip_bits {
        println!("位模式被规范化: 0x{:016X} -> 0x{:016X}",
                 original_bits, round_trip_bits);
    }
}

// const 上下文中的安全位操作
const fn safe_from_bits(bits: u64) -> f64 {
    // 检测 sNaN 并转换为 qNaN
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;

    if exp == 0x7FF && mantissa != 0 && (mantissa & 0x0008_0000_0000_0000) == 0 {
        // 这是 sNaN，转换为 qNaN
        f64::from_bits(bits | 0x0008_0000_0000_0000)
    } else {
        f64::from_bits(bits)
    }
}
```

---

## 6. 实际应用场景

### 6.1 数值计算库中的 NaN 处理

```rust
// 统计函数中的 NaN 传播
pub fn mean_with_nan_handling(data: &[f64]) -> f64 {
    if data.is_empty() {
        return f64::NAN;
    }

    let mut sum = 0.0;
    let mut count = 0;

    for &value in data {
        if !value.is_nan() {
            sum += value;
            count += 1;
        }
    }

    if count == 0 {
        f64::NAN
    } else {
        sum / count as f64
    }
}

// 数值稳定的求和
pub fn kahan_summation(data: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut compensation = 0.0;

    for &value in data {
        if value.is_nan() {
            return f64::NAN;
        }

        let y = value - compensation;
        let t = sum + y;
        compensation = (t - sum) - y;
        sum = t;
    }

    sum
}

fn main() {
    let data = vec![1.0, 2.0, f64::NAN, 4.0];
    println!("均值 (忽略 NaN): {}", mean_with_nan_handling(&data));

    let clean_data = vec![1e-16, 1.0, 1e-16];
    println!("Kahan 求和: {}", kahan_summation(&clean_data));
}
```

### 6.2 编译期物理常数定义

```rust
// 编译期计算的物理常数表
pub mod physics {
    // 基本常数
    pub const C: f64 = 299_792_458.0;                    // 光速 (m/s)
    pub const H: f64 = 6.62607015e-34;                   // 普朗克常数 (J·s)
    pub const K_B: f64 = 1.380649e-23;                   // 玻尔兹曼常数 (J/K)
    pub const E_0: f64 = 8.8541878128e-12;               // 真空介电常数 (F/m)
    pub const MU_0: f64 = 1.25663706212e-6;              // 真空磁导率 (H/m)

    // 派生常数 (编译期计算)
    pub const H_BAR: f64 = H / (2.0 * 3.141592653589793);         // 约化普朗克常数
    pub const IMPEDANCE_0: f64 = 376.730313668;                   // 真空阻抗 (Ω)

    // 单位转换
    pub const EV_TO_JOULE: f64 = 1.602176634e-19;
    pub const JOULE_TO_EV: f64 = 1.0 / EV_TO_JOULE;

    // 编译期函数
    pub const fn wavelength_to_frequency(lambda: f64) -> f64 {
        C / lambda
    }

    pub const fn energy_to_wavelength(energy_joules: f64) -> f64 {
        (H * C) / energy_joules
    }
}

const VISIBLE_LIGHT_MIN_FREQ: f64 = physics::wavelength_to_frequency(700e-9);
const VISIBLE_LIGHT_MAX_FREQ: f64 = physics::wavelength_to_frequency(400e-9);

fn main() {
    println!("可见光频率范围: {:.3e} - {:.3e} Hz",
             VISIBLE_LIGHT_MIN_FREQ, VISIBLE_LIGHT_MAX_FREQ);
}
```

### 6.3 嵌入式系统中的浮点优化

```rust
// 编译期决定使用软浮点还是硬浮点
#[cfg(target_feature = "fpu")]
const USE_HARDWARE_FLOAT: bool = true;
#[cfg(not(target_feature = "fpu"))]
const USE_HARDWARE_FLOAT: bool = false;

// 编译期配置精度权衡
const HIGH_PRECISION: bool = cfg!(feature = "high_precision");

const fn select_epsilon() -> f32 {
    if HIGH_PRECISION {
        1e-7
    } else {
        1e-5  // 嵌入式系统可接受的精度
    }
}

const EPSILON: f32 = select_epsilon();

// 定点数模拟浮点数 (编译期决策)
const fn fixed_point_mul(a: i32, b: i32, scale: i32) -> i32 {
    ((a as i64 * b as i64) / scale as i64) as i32
}

const SCALE: i32 = 1000;
const RESULT: i32 = fixed_point_mul(1500, 2000, SCALE);

fn main() {
    println!("使用硬件浮点: {}", USE_HARDWARE_FLOAT);
    println!("精度阈值: {}", EPSILON);
    println!("定点运算: 1.5 * 2.0 = {}", RESULT as f32 / SCALE as f32);
}
```

---

## 7. 性能与陷阱

### 7.1 NaN 检测的性能考虑

```rust
use std::time::Instant;

fn benchmark_nan_checks(data: &[f64], iterations: usize) {
    // 方法 1: is_nan()
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x.is_nan();
        }
    }
    let method1_time = start.elapsed();

    // 方法 2: 自比较
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x != x;
        }
    }
    let method2_time = start.elapsed();

    // 方法 3: 位模式检查
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let bits = x.to_bits();
            let _ = (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
                && (bits & 0x000F_FFFF_FFFF_FFFF != 0);
        }
    }
    let method3_time = start.elapsed();

    println!("NaN 检测性能 ({}次迭代):", iterations);
    println!("  is_nan():      {:?}", method1_time);
    println!("  x != x:        {:?}", method2_time);
    println!("  位模式检查:     {:?}", method3_time);
}

fn main() {
    let data: Vec<f64> = (0..1000).map(|i| i as f64 * 0.1).collect();
    benchmark_nan_checks(&data, 10000);
}
```

**性能建议**：

- ✅ `is_nan()` 通常是最快的方法（编译器优化）
- ✅ `x != x` 语义清晰，性能接近
- ❌ 位模式检查通常较慢，除非需要精确控制

### 7.2 常见陷阱与避免方法

```rust
// 陷阱 1: 不当的 NaN 比较
fn pitfall_nan_comparison() {
    let nan = f64::NAN;

    // ❌ 错误: 永远不会执行
    if nan == f64::NAN {
        println!("This never prints");
    }

    // ✅ 正确
    if nan.is_nan() {
        println!("检测到 NaN");
    }
}

// 陷阱 2: 浮点数作为 HashMap 键
fn pitfall_hash_key() {
    use std::collections::HashMap;

    let mut map = HashMap::new();
    map.insert(1.0, "one");

    // ⚠️ 浮点数精度问题可能导致键查找失败
    let key = 0.1 + 0.2; // 0.30000000000000004
    map.insert(key, "almost 0.3");

    // 可能找不到
    println!("查找 0.3: {:?}", map.get(&0.3));

    // ✅ 推荐: 使用整数或 ordered_float::OrderedFloat
}

// 陷阱 3: 累积误差
fn pitfall_accumulation() {
    // ❌ 朴素求和
    let mut sum = 0.0_f64;
    for _ in 0..1_000_000 {
        sum += 1e-10;
    }
    println!("朴素求和: {:.15}", sum);
    // 期望: 0.0001, 实际: 误差较大

    // ✅ Kahan 补偿求和
    let mut sum = 0.0;
    let mut c = 0.0;
    for _ in 0..1_000_000 {
        let y = 1e-10 - c;
        let t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    println!("Kahan 求和: {:.15}", sum);
}

// 陷阱 4: 除零检查不足
fn pitfall_division() {
    let x = 10.0;
    let y = 0.0;

    // ⚠️ 不会 panic，但产生 Inf
    let result = x / y;
    println!("10.0 / 0.0 = {}", result); // Inf

    // ✅ 显式检查
    if y == 0.0 {
        eprintln!("除数为零");
    } else {
        println!("结果: {}", x / y);
    }

    // ✅ 结果验证
    if result.is_finite() {
        println!("有限结果: {}", result);
    } else {
        eprintln!("结果非有限: {}", result);
    }
}
```

### 7.3 浮点数精度深度分析

**IEEE 754精度限制**:

```rust
fn precision_limits() {
    // f32: ~7位有效十进制数字
    let f32_val: f32 = 1.23456789;
    println!("f32保留精度: {:.10}", f32_val);  // 1.2345678806

    // f64: ~15位有效十进制数字
    let f64_val: f64 = 1.234567890123456789;
    println!("f64保留精度: {:.20}", f64_val);  // 1.23456789012345670000

    // 超出精度的数字被截断
    assert!(1.0 + 1e-16 != 1.0);  // f64能区分
    assert!(1.0_f32 + 1e-8_f32 == 1.0_f32);  // f32无法区分
}
```

**机器精度（Machine Epsilon）**:

```rust
fn machine_epsilon() {
    // f32机器精度: 2^-23 ≈ 1.19e-7
    let epsilon_f32 = f32::EPSILON;
    println!("f32 epsilon: {:.10e}", epsilon_f32);
    assert!(1.0_f32 + epsilon_f32 > 1.0_f32);
    assert!(1.0_f32 + epsilon_f32 / 2.0 == 1.0_f32);

    // f64机器精度: 2^-52 ≈ 2.22e-16
    let epsilon_f64 = f64::EPSILON;
    println!("f64 epsilon: {:.20e}", epsilon_f64);
    assert!(1.0 + epsilon_f64 > 1.0);
    assert!(1.0 + epsilon_f64 / 2.0 == 1.0);
}
```

**相对误差分析**:

```rust
fn relative_error_analysis() {
    let exact = 1.0 / 3.0;
    let approx = 0.333333333333333;

    let absolute_error = (exact - approx).abs();
    let relative_error = absolute_error / exact.abs();

    println!("绝对误差: {:.20e}", absolute_error);
    println!("相对误差: {:.20e}", relative_error);

    // ✅ 相对误差通常更有意义
    assert!(relative_error < 1e-15);
}
```

### 7.4 数值稳定性技术

**技术1：避免灾难性抵消**:

```rust
// ❌ 不稳定：两个相近数相减
fn quadratic_unstable(a: f64, b: f64, c: f64) -> (f64, f64) {
    let discriminant = b * b - 4.0 * a * c;
    let sqrt_d = discriminant.sqrt();
    let x1 = (-b + sqrt_d) / (2.0 * a);
    let x2 = (-b - sqrt_d) / (2.0 * a);
    (x1, x2)
}

// ✅ 稳定：使用数值稳定算法
fn quadratic_stable(a: f64, b: f64, c: f64) -> (f64, f64) {
    let discriminant = b * b - 4.0 * a * c;
    let sqrt_d = discriminant.sqrt();

    // 避免灾难性抵消
    let x1 = if b >= 0.0 {
        (-b - sqrt_d) / (2.0 * a)
    } else {
        (-b + sqrt_d) / (2.0 * a)
    };

    let x2 = c / (a * x1);  // 使用韦达定理
    (x1, x2)
}

fn main() {
    // 测试病态情况
    let (x1_unstable, x2_unstable) = quadratic_unstable(1.0, 1e8, 1.0);
    let (x1_stable, x2_stable) = quadratic_stable(1.0, 1e8, 1.0);

    println!("不稳定算法: x1={:.15e}, x2={:.15e}", x1_unstable, x2_unstable);
    println!("稳定算法:   x1={:.15e}, x2={:.15e}", x1_stable, x2_stable);
}
```

**技术2：Kahan累加算法**:

```rust
// ✅ 高精度求和
fn kahan_sum(values: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut c = 0.0;  // 误差补偿

    for &value in values {
        let y = value - c;
        let t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }

    sum
}

// 性能测试
fn compare_summation() {
    let values: Vec<f64> = (0..10_000_000)
        .map(|i| 1.0 / (i as f64 + 1.0))
        .collect();

    // 朴素求和
    let naive_sum: f64 = values.iter().sum();

    // Kahan求和
    let kahan = kahan_sum(&values);

    println!("朴素求和: {:.15}", naive_sum);
    println!("Kahan求和: {:.15}", kahan);
    println!("差异: {:.15e}", (naive_sum - kahan).abs());
}
```

**技术3：递归关系的稳定性**:

```rust
// ❌ 不稳定：向前递归
fn forward_recurrence(n: usize) -> f64 {
    if n == 0 {
        return 1.0;
    }
    if n == 1 {
        return 0.5;
    }
    (2.0 * n as f64 - 1.0) * forward_recurrence(n - 1) - forward_recurrence(n - 2)
}

// ✅ 稳定：向后递归
fn backward_recurrence(n: usize) -> f64 {
    let mut values = vec![0.0; n + 1];
    values[n] = 1.0;
    values[n - 1] = 1.0;

    for i in (0..n-1).rev() {
        values[i] = ((2.0 * i as f64 + 1.0) * values[i + 1] - values[i + 2]) / (i as f64 + 1.0);
    }

    values[0]
}
```

### 7.5 实战：高精度计算

**案例1：计算数学常数π**:

```rust
// Machin公式：π/4 = 4*arctan(1/5) - arctan(1/239)
fn compute_pi(iterations: usize) -> f64 {
    fn arctan_series(x: f64, n: usize) -> f64 {
        let mut sum = 0.0;
        let x_squared = x * x;
        let mut term = x;

        for i in 0..n {
            let sign = if i % 2 == 0 { 1.0 } else { -1.0 };
            sum += sign * term / (2 * i + 1) as f64;
            term *= x_squared;
        }

        sum
    }

    4.0 * (4.0 * arctan_series(1.0 / 5.0, iterations)
         - arctan_series(1.0 / 239.0, iterations))
}

fn main() {
    for n in [10, 50, 100] {
        let pi_approx = compute_pi(n);
        let error = (pi_approx - std::f64::consts::PI).abs();
        println!("n={:3}: π≈{:.15}, 误差={:.2e}", n, pi_approx, error);
    }
}
```

**案例2：矩阵运算的数值稳定性**:

```rust
struct Matrix {
    data: Vec<Vec<f64>>,
}

impl Matrix {
    // ✅ 列主元高斯消元（数值稳定）
    fn gaussian_elimination_pivoting(&mut self) -> Result<(), &'static str> {
        let n = self.data.len();

        for k in 0..n {
            // 寻找列主元
            let mut max_row = k;
            for i in k+1..n {
                if self.data[i][k].abs() > self.data[max_row][k].abs() {
                    max_row = i;
                }
            }

            // 交换行
            if max_row != k {
                self.data.swap(k, max_row);
            }

            // 检查奇异性
            if self.data[k][k].abs() < 1e-10 {
                return Err("矩阵奇异或病态");
            }

            // 消元
            for i in k+1..n {
                let factor = self.data[i][k] / self.data[k][k];
                for j in k..n {
                    self.data[i][j] -= factor * self.data[k][j];
                }
            }
        }

        Ok(())
    }
}
```

### 7.6 浮点数调试技巧

**技巧1：位模式检查**:

```rust
fn debug_float(value: f64) {
    let bits = value.to_bits();

    // 提取IEEE 754组成部分
    let sign = (bits >> 63) & 1;
    let exponent = ((bits >> 52) & 0x7FF) as i16 - 1023;
    let mantissa = bits & 0xFFFFFFFFFFFFF;

    println!("值: {}", value);
    println!("位模式: {:064b}", bits);
    println!("符号位: {}", sign);
    println!("指数: {} (biased: {})", exponent, exponent + 1023);
    println!("尾数: {:052b}", mantissa);

    // 分类
    if value.is_nan() {
        println!("类别: NaN");
    } else if value.is_infinite() {
        println!("类别: 无穷大");
    } else if value == 0.0 {
        println!("类别: 零 ({})", if sign == 0 { "+0.0" } else { "-0.0" });
    } else if value.is_subnormal() {
        println!("类别: 次正规数");
    } else {
        println!("类别: 正规数");
    }
}

fn main() {
    debug_float(1.0);
    debug_float(-0.0);
    debug_float(f64::NAN);
    debug_float(f64::INFINITY);
    debug_float(f64::MIN_POSITIVE);
}
```

**技巧2：浮点数比较辅助函数**:

```rust
// ✅ 安全的浮点数比较
fn approx_equal(a: f64, b: f64, rel_tol: f64, abs_tol: f64) -> bool {
    let diff = (a - b).abs();

    // 处理特殊值
    if a == b {
        return true;  // 包括 ±∞
    }
    if a.is_nan() || b.is_nan() {
        return false;
    }

    // 相对误差检查
    let larger = a.abs().max(b.abs());
    diff <= larger * rel_tol || diff <= abs_tol
}

// 测试
fn test_comparisons() {
    assert!(approx_equal(0.1 + 0.2, 0.3, 1e-10, 1e-10));
    assert!(!approx_equal(1.0, 1.1, 1e-10, 1e-10));
    assert!(approx_equal(1e-20, 0.0, 1e-10, 1e-15));
}
```

**技巧3：单元测试浮点代码**:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pi_computation() {
        let pi = compute_pi(100);
        assert!((pi - std::f64::consts::PI).abs() < 1e-10);
    }

    #[test]
    fn test_nan_handling() {
        let nan = f64::NAN;
        assert!(nan.is_nan());
        assert!(!(nan == nan));  // NaN不等于自己
        assert!((nan + 1.0).is_nan());  // NaN传播
    }

    #[test]
    fn test_overflow() {
        let large = f64::MAX;
        let result = large * 2.0;
        assert!(result.is_infinite());
    }

    #[test]
    fn test_underflow() {
        let small = f64::MIN_POSITIVE;
        let result = small / 2.0;
        assert!(result > 0.0);  // 次正规数
        assert!(result < small);
    }
}
```

---

## 8. 实战案例集

### 8.1 金融计算：避免舍入误差

```rust
use std::ops::{Add, Sub, Mul, Div};

// ✅ 使用整数表示货币（以分为单位）
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct Money {
    cents: i64,
}

impl Money {
    fn from_dollars(dollars: f64) -> Self {
        Self {
            cents: (dollars * 100.0).round() as i64,
        }
    }

    fn to_dollars(&self) -> f64 {
        self.cents as f64 / 100.0
    }
}

impl Add for Money {
    type Output = Self;
    fn add(self, rhs: Self) -> Self {
        Self { cents: self.cents + rhs.cents }
    }
}

// 测试
fn test_money() {
    let price1 = Money::from_dollars(10.10);
    let price2 = Money::from_dollars(20.20);
    let total = price1 + price2;

    assert_eq!(total.to_dollars(), 30.30);  // ✅ 精确

    // ❌ 浮点数直接计算会有误差
    assert!((10.10 + 20.20) != 30.30);
}
```

### 8.2 游戏引擎：向量运算优化

```rust
#[repr(C, align(16))]
#[derive(Clone, Copy)]
struct Vec3 {
    x: f32,
    y: f32,
    z: f32,
}

impl Vec3 {
    // ✅ SIMD友好的实现
    #[inline]
    fn dot(&self, other: &Vec3) -> f32 {
        // 使用 FMA (Fused Multiply-Add) 提高精度和性能
        self.x.mul_add(other.x,
            self.y.mul_add(other.y, self.z * other.z))
    }

    #[inline]
    fn length(&self) -> f32 {
        self.dot(self).sqrt()
    }

    // ✅ 快速近似：逆平方根（Quake III算法）
    #[inline]
    fn fast_inv_sqrt(x: f32) -> f32 {
        let i = x.to_bits();
        let i = 0x5f3759df - (i >> 1);
        let y = f32::from_bits(i);

        // 牛顿迭代改进
        y * (1.5 - 0.5 * x * y * y)
    }

    #[inline]
    fn normalize_fast(&self) -> Vec3 {
        let inv_len = Self::fast_inv_sqrt(self.dot(self));
        Vec3 {
            x: self.x * inv_len,
            y: self.y * inv_len,
            z: self.z * inv_len,
        }
    }
}

// 性能基准测试
fn benchmark_normalization() {
    let v = Vec3 { x: 1.0, y: 2.0, z: 3.0 };

    // 标准方法
    let start = std::time::Instant::now();
    for _ in 0..1_000_000 {
        let len = v.length();
        let _ = Vec3 {
            x: v.x / len,
            y: v.y / len,
            z: v.z / len,
        };
    }
    let standard_time = start.elapsed();

    // 快速方法
    let start = std::time::Instant::now();
    for _ in 0..1_000_000 {
        let _ = v.normalize_fast();
    }
    let fast_time = start.elapsed();

    println!("标准归一化: {:?}", standard_time);
    println!("快速归一化: {:?}", fast_time);
    println!("加速比: {:.2}x", standard_time.as_secs_f64() / fast_time.as_secs_f64());
}
```

### 8.3 科学计算：数值积分

```rust
// ✅ 自适应辛普森积分法
fn adaptive_simpson<F>(f: F, a: f64, b: f64, tol: f64) -> f64
where
    F: Fn(f64) -> f64,
{
    fn simpson<F>(f: &F, a: f64, b: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let h = (b - a) / 2.0;
        let mid = (a + b) / 2.0;
        h / 3.0 * (f(a) + 4.0 * f(mid) + f(b))
    }

    fn adaptive_simpson_rec<F>(
        f: &F,
        a: f64,
        b: f64,
        tol: f64,
        whole: f64,
    ) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let mid = (a + b) / 2.0;
        let left = simpson(f, a, mid);
        let right = simpson(f, mid, b);

        if (left + right - whole).abs() < 15.0 * tol {
            left + right + (left + right - whole) / 15.0
        } else {
            adaptive_simpson_rec(f, a, mid, tol / 2.0, left)
                + adaptive_simpson_rec(f, mid, b, tol / 2.0, right)
        }
    }

    let whole = simpson(&f, a, b);
    adaptive_simpson_rec(&f, a, b, tol, whole)
}

// 测试
fn test_integration() {
    // ∫₀¹ x² dx = 1/3
    let result = adaptive_simpson(|x| x * x, 0.0, 1.0, 1e-10);
    let exact = 1.0 / 3.0;
    println!("数值积分: {:.15}", result);
    println!("精确值: {:.15}", exact);
    println!("误差: {:.2e}", (result - exact).abs());
}
```

### 8.4 图像处理：颜色空间转换

```rust
#[derive(Clone, Copy)]
struct RGB {
    r: f32,  // [0.0, 1.0]
    g: f32,
    b: f32,
}

#[derive(Clone, Copy)]
struct HSV {
    h: f32,  // [0.0, 360.0)
    s: f32,  // [0.0, 1.0]
    v: f32,  // [0.0, 1.0]
}

impl RGB {
    // ✅ RGB → HSV 转换（数值稳定）
    fn to_hsv(&self) -> HSV {
        let max = self.r.max(self.g).max(self.b);
        let min = self.r.min(self.g).min(self.b);
        let delta = max - min;

        let v = max;

        let s = if max > 1e-6 {
            delta / max
        } else {
            0.0
        };

        let h = if delta < 1e-6 {
            0.0  // 灰色，色相未定义
        } else if (max - self.r).abs() < 1e-6 {
            60.0 * (((self.g - self.b) / delta) % 6.0)
        } else if (max - self.g).abs() < 1e-6 {
            60.0 * (((self.b - self.r) / delta) + 2.0)
        } else {
            60.0 * (((self.r - self.g) / delta) + 4.0)
        };

        let h = if h < 0.0 { h + 360.0 } else { h };

        HSV { h, s, v }
    }
}

impl HSV {
    // ✅ HSV → RGB 转换
    fn to_rgb(&self) -> RGB {
        let c = self.v * self.s;
        let h_prime = self.h / 60.0;
        let x = c * (1.0 - ((h_prime % 2.0) - 1.0).abs());

        let (r1, g1, b1) = match h_prime as i32 {
            0 => (c, x, 0.0),
            1 => (x, c, 0.0),
            2 => (0.0, c, x),
            3 => (0.0, x, c),
            4 => (x, 0.0, c),
            _ => (c, 0.0, x),
        };

        let m = self.v - c;
        RGB {
            r: r1 + m,
            g: g1 + m,
            b: b1 + m,
        }
    }
}
```

### 8.5 机器学习：Softmax稳定实现

```rust
// ❌ 不稳定：直接计算会上溢
fn softmax_unstable(logits: &[f64]) -> Vec<f64> {
    let sum: f64 = logits.iter().map(|&x| x.exp()).sum();
    logits.iter().map(|&x| x.exp() / sum).collect()
}

// ✅ 稳定：减去最大值
fn softmax_stable(logits: &[f64]) -> Vec<f64> {
    let max = logits.iter().copied().fold(f64::NEG_INFINITY, f64::max);
    let exp_shifted: Vec<f64> = logits.iter().map(|&x| (x - max).exp()).collect();
    let sum: f64 = exp_shifted.iter().sum();
    exp_shifted.iter().map(|&x| x / sum).collect()
}

// 测试
fn test_softmax() {
    let logits = vec![1000.0, 1001.0, 1002.0];

    // 不稳定版本会产生NaN
    let unstable = softmax_unstable(&logits);
    println!("不稳定结果: {:?}", unstable);

    // 稳定版本产生正确结果
    let stable = softmax_stable(&logits);
    println!("稳定结果: {:?}", stable);
    assert!((stable.iter().sum::<f64>() - 1.0).abs() < 1e-10);
}
```

---

## 9. 跨版本兼容性说明

| 特性                           | Rust 1.82 | Rust 1.90 | Rust 1.92.0           | 说明                   |
| ------------------------------ | --------- | --------- | --------------------- | ---------------------- |
| `f32/f64` 基本运算 const 支持  | 稳定      | 稳定      | +, -, \*, /, - (取负) |
| `abs()` const 支持             | 稳定      | 稳定      | 绝对值                |
| `to_bits()/from_bits()` const  | 稳定      | 稳定      | 位模式转换            |
| `is_nan()/is_infinite()` const | 不稳定    | **稳定**  | **Rust 1.84+ 稳定化** |
| `copysign()` const             | 不稳定    | **稳定**  | **Rust 1.85+ 稳定化** |
| `min()/max()` const            | 不稳定    | 部分稳定  | 稳定                  | 完全稳定 (Rust 1.92.0) |
| `sqrt()/sin()/cos()` const     | 不稳定    | 不稳定    | 超越函数仍不支持      |

**迁移建议**：

- 对于 Rust 1.92.0，可安全使用基本运算和位模式操作，包括 min()/max()
- 浮点分类函数 (`is_nan()`, `is_finite()`) 可通过位模式模拟
- 超越函数需依赖运行时计算或第三方 const 数学库

---

## 9. 相关资源

### 内部文档

- [基础类型指南](../tier_02_guides/01_基础类型指南.md) - 浮点数基础
- [类型转换参考](01_类型转换参考.md) - 浮点数类型转换规则
- [性能优化参考](05_性能优化参考.md) - 浮点数性能优化

### 外部资源

- **IEEE 754 标准**: <https://ieeexplore.ieee.org/document/8766229>
- **Rust RFC 3514 (const float ops)**: <https://github.com/rust-lang/rfcs/pull/3514>
- **Float Toy (可视化工具)**: <https://evanw.github.io/float-toy/>
- **What Every Computer Scientist Should Know About Floating-Point Arithmetic**: <https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html>

### 相关 Crate

- `ordered-float`: 实现 `Ord` 和 `Hash` 的浮点包装器
- `approx`: 浮点数近似比较
- `num-traits`: 数值类型 trait 抽象
- `libm`: 纯 Rust 数学函数库 (支持 const)

---

**总结**：Rust 1.92.0 的浮点数 const fn 能力为编译期计算和配置提供了强大支持（自 Rust 1.90 引入）。理解 NaN 语义、特殊值处理和位模式操作，能够编写出更安全、更高效的数值计算代码。在使用 const fn 时，要注意当前版本的限制，并根据需要采用位操作等变通方法。

**下一步**：建议阅读 [高级泛型模式](../tier_04_advanced/02_高级泛型模式.md) 以了解泛型常量表达式（Generic Const Exprs），它与 const fn 结合能实现更强大的编译期编程。
