# 3.6 æµ®ç‚¹æ•°é«˜çº§ä¸»é¢˜ä¸ const fn è¯­ä¹‰ (Rust 1.90)

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: Rust 1.90 æµ®ç‚¹æ•°ç±»å‹é«˜çº§ç‰¹æ€§çš„æƒå¨æŠ€æœ¯å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æ·±å…¥ç†è§£æµ®ç‚¹æ•°è¯­ä¹‰å’Œ const fn èƒ½åŠ›çš„é«˜çº§å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [3.6 æµ®ç‚¹æ•°é«˜çº§ä¸»é¢˜ä¸ const fn è¯­ä¹‰ (Rust 1.90)](#36-æµ®ç‚¹æ•°é«˜çº§ä¸»é¢˜ä¸-const-fn-è¯­ä¹‰-rust-190)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Rust 1.90 æµ®ç‚¹æ•° const fn èƒ½åŠ›æ¦‚è§ˆ](#1-rust-190-æµ®ç‚¹æ•°-const-fn-èƒ½åŠ›æ¦‚è§ˆ)
    - [1.1 ç¨³å®šåŒ–çš„ const æµ®ç‚¹æ“ä½œ](#11-ç¨³å®šåŒ–çš„-const-æµ®ç‚¹æ“ä½œ)
    - [1.2 const ä¸Šä¸‹æ–‡ä¸­çš„é™åˆ¶](#12-const-ä¸Šä¸‹æ–‡ä¸­çš„é™åˆ¶)
  - [2. NaN (Not-a-Number) è¯­ä¹‰æ·±åº¦è§£æ](#2-nan-not-a-number-è¯­ä¹‰æ·±åº¦è§£æ)
    - [2.1 IEEE 754 NaN è¡¨ç¤º](#21-ieee-754-nan-è¡¨ç¤º)
    - [2.2 NaN çš„ä¼ æ’­è§„åˆ™](#22-nan-çš„ä¼ æ’­è§„åˆ™)
    - [2.3 NaN çš„æ¯”è¾ƒè¯­ä¹‰](#23-nan-çš„æ¯”è¾ƒè¯­ä¹‰)
    - [2.4 NaN åœ¨ const fn ä¸­çš„è¡Œä¸º](#24-nan-åœ¨-const-fn-ä¸­çš„è¡Œä¸º)
  - [3. ç‰¹æ®Šæµ®ç‚¹å€¼å¤„ç†](#3-ç‰¹æ®Šæµ®ç‚¹å€¼å¤„ç†)
    - [3.1 æ— ç©·å¤§ (Infinity) å¤„ç†](#31-æ— ç©·å¤§-infinity-å¤„ç†)
    - [3.2 é›¶å€¼ (+0.0 vs -0.0)](#32-é›¶å€¼-00-vs--00)
    - [3.3 æ¬¡æ­£è§„æ•° (Subnormal Numbers)](#33-æ¬¡æ­£è§„æ•°-subnormal-numbers)
  - [4. const fn æµ®ç‚¹æ“ä½œå®æˆ˜](#4-const-fn-æµ®ç‚¹æ“ä½œå®æˆ˜)
    - [4.1 ç¼–è¯‘æœŸå¸¸é‡è®¡ç®—](#41-ç¼–è¯‘æœŸå¸¸é‡è®¡ç®—)
    - [4.2 const fn ä¸­çš„æµ®ç‚¹åˆ†ç±»](#42-const-fn-ä¸­çš„æµ®ç‚¹åˆ†ç±»)
    - [4.3 ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹](#43-ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹)
  - [5. æµ®ç‚¹æ•°ä½æ¨¡å¼æ“ä½œ](#5-æµ®ç‚¹æ•°ä½æ¨¡å¼æ“ä½œ)
    - [5.1 to\_bits å’Œ from\_bits](#51-to_bits-å’Œ-from_bits)
    - [5.2 NaN payload è®¿é—®](#52-nan-payload-è®¿é—®)
    - [5.3 ä½æ¨¡å¼å®‰å…¨æ€§](#53-ä½æ¨¡å¼å®‰å…¨æ€§)
  - [6. å®é™…åº”ç”¨åœºæ™¯](#6-å®é™…åº”ç”¨åœºæ™¯)
    - [6.1 æ•°å€¼è®¡ç®—åº“ä¸­çš„ NaN å¤„ç†](#61-æ•°å€¼è®¡ç®—åº“ä¸­çš„-nan-å¤„ç†)
    - [6.2 ç¼–è¯‘æœŸç‰©ç†å¸¸æ•°å®šä¹‰](#62-ç¼–è¯‘æœŸç‰©ç†å¸¸æ•°å®šä¹‰)
    - [6.3 åµŒå…¥å¼ç³»ç»Ÿä¸­çš„æµ®ç‚¹ä¼˜åŒ–](#63-åµŒå…¥å¼ç³»ç»Ÿä¸­çš„æµ®ç‚¹ä¼˜åŒ–)
  - [7. æ€§èƒ½ä¸é™·é˜±](#7-æ€§èƒ½ä¸é™·é˜±)
    - [7.1 NaN æ£€æµ‹çš„æ€§èƒ½è€ƒè™‘](#71-nan-æ£€æµ‹çš„æ€§èƒ½è€ƒè™‘)
    - [7.2 å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•](#72-å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•)
  - [8. è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜](#8-è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜)
  - [9. ç›¸å…³èµ„æº](#9-ç›¸å…³èµ„æº)
    - [å†…éƒ¨æ–‡æ¡£](#å†…éƒ¨æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)
    - [ç›¸å…³ Crate](#ç›¸å…³-crate)

---

## 1. Rust 1.90 æµ®ç‚¹æ•° const fn èƒ½åŠ›æ¦‚è§ˆ

### 1.1 ç¨³å®šåŒ–çš„ const æµ®ç‚¹æ“ä½œ

è‡ª Rust 1.82 èµ·ï¼Œæµ®ç‚¹æ•°æ“ä½œå¼€å§‹é€æ­¥åœ¨ const ä¸Šä¸‹æ–‡ä¸­ç¨³å®šåŒ–ã€‚åœ¨ Rust 1.90 ä¸­ï¼Œä»¥ä¸‹èƒ½åŠ›å·²å®Œå…¨ç¨³å®šï¼š

```rust
// âœ… Rust 1.90 ç¨³å®šæ”¯æŒçš„ const æµ®ç‚¹æ“ä½œ
const CONST_OPERATIONS: () = {
    // åŸºæœ¬ç®—æœ¯è¿ç®—
    const ADD: f64 = 1.5 + 2.3;
    const SUB: f64 = 10.0 - 3.14;
    const MUL: f64 = 2.0 * 3.5;
    const DIV: f64 = 10.0 / 2.0;
    
    // å–è´Ÿå’Œç»å¯¹å€¼
    const NEG: f64 = -5.5;
    const ABS: f64 = (-3.14_f64).abs();
    
    // ç±»å‹è½¬æ¢ (as)
    const TO_INT: i32 = 3.14_f64 as i32;
    const TO_F32: f32 = 1.0_f64 as f32;
    
    // ç‰¹æ®Šå€¼å¸¸é‡
    const INFINITY: f64 = f64::INFINITY;
    const NEG_INFINITY: f64 = f64::NEG_INFINITY;
    const NAN: f64 = f64::NAN;
    
    // ä½æ¨¡å¼æ“ä½œ
    const BITS: u64 = 1.0_f64.to_bits();
    const FROM_BITS: f64 = f64::from_bits(0x3FF0000000000000);
};

fn main() {
    println!("ç¼–è¯‘æœŸè®¡ç®—ç»“æœ: {}", CONST_OPERATIONS::ADD);
}
```

**å…³é”®ç‚¹**ï¼š

- âœ… å››åˆ™è¿ç®—åœ¨ const ä¸Šä¸‹æ–‡ä¸­å®Œå…¨æ”¯æŒ
- âœ… `abs()`, `to_bits()`, `from_bits()` å¯ç”¨äº const fn
- âŒ è¶…è¶Šå‡½æ•° (`sin`, `cos`, `sqrt` ç­‰) åœ¨ Rust 1.90 ä¸­ä»ä¸æ”¯æŒ const

### 1.2 const ä¸Šä¸‹æ–‡ä¸­çš„é™åˆ¶

```rust
// âŒ Rust 1.90 ä¸­ä¸æ”¯æŒçš„ const æµ®ç‚¹æ“ä½œ
const fn unsupported_operations() -> f64 {
    // let sqrt = 4.0_f64.sqrt();      // âŒ è¶…è¶Šå‡½æ•°
    // let sin = 1.0_f64.sin();         // âŒ ä¸‰è§’å‡½æ•°
    // let log = 2.0_f64.ln();          // âŒ å¯¹æ•°å‡½æ•°
    // let pow = 2.0_f64.powf(3.0);     // âŒ å¹‚è¿ç®—
    
    // âœ… ä½†å¯ä»¥ä½¿ç”¨åŸºæœ¬è¿ç®—æ¨¡æ‹Ÿ
    let square = 2.0 * 2.0;
    square
}

// âœ… ç¼–è¯‘æœŸå¸¸é‡å®šä¹‰
const PI: f64 = 3.141592653589793;
const E: f64 = 2.718281828459045;

// âœ… const fn ä¸­å¯ä»¥ä½¿ç”¨çš„æ“ä½œ
const fn safe_sqrt_approx(x: f64) -> f64 {
    // ä½¿ç”¨ç‰›é¡¿è¿­ä»£æ³•çš„ç¼–è¯‘æœŸç‰ˆæœ¬ï¼ˆéœ€è¦å¾ªç¯æ”¯æŒï¼‰
    // è¿™é‡Œç®€åŒ–ä¸ºåŸºæœ¬è¿ç®—
    if x < 0.0 {
        f64::NAN
    } else {
        x / 2.0 // ç®€åŒ–çš„è¿‘ä¼¼
    }
}
```

---

## 2. NaN (Not-a-Number) è¯­ä¹‰æ·±åº¦è§£æ

### 2.1 IEEE 754 NaN è¡¨ç¤º

```rust
fn main() {
    // IEEE 754 è§„å®š NaN æœ‰ 2^52 - 2 ç§ä¸åŒçš„ä½æ¨¡å¼
    // Rust ä½¿ç”¨"é™é»˜ NaN" (quiet NaN) ä½œä¸ºæ ‡å‡† NaN
    
    // æ ‡å‡† NaN çš„ä½æ¨¡å¼ (f64)
    const NAN_BITS: u64 = f64::NAN.to_bits();
    println!("f64::NAN ä½æ¨¡å¼: 0x{:016X}", NAN_BITS);
    // è¾“å‡º: 0x7FF8000000000000
    //       ^^^^^^^^^^^^^^^^^^^
    //       ç¬¦å·ä½(1) | æŒ‡æ•°ä½(11) | å°¾æ•°ä½(52)
    //       0         | 11111111111 | 1000...000
    
    // ç¬¦å·ä½: 0 (æ­£ NaN)
    // æŒ‡æ•°ä½: å…¨1 (2047)
    // å°¾æ•°ä½: éé›¶ï¼Œæœ€é«˜ä½ä¸º1è¡¨ç¤ºé™é»˜ NaN
    
    // f32 çš„ NaN ä½æ¨¡å¼
    const NAN_F32_BITS: u32 = f32::NAN.to_bits();
    println!("f32::NAN ä½æ¨¡å¼: 0x{:08X}", NAN_F32_BITS);
    // è¾“å‡º: 0x7FC00000
}
```

**NaN åˆ†ç±»**ï¼š

- **é™é»˜ NaN (Quiet NaN, qNaN)**: å°¾æ•°æœ€é«˜ä½ä¸º1ï¼Œä¼ æ’­æ—¶ä¸è§¦å‘å¼‚å¸¸
- **ä¿¡å· NaN (Signaling NaN, sNaN)**: å°¾æ•°æœ€é«˜ä½ä¸º0ï¼Œç†è®ºä¸Šåº”è§¦å‘å¼‚å¸¸ï¼ˆRust ä¸ä½¿ç”¨ï¼‰

```rust
// åˆ›å»ºä¸åŒçš„ NaN
fn explore_nan_patterns() {
    // æ ‡å‡† NaN
    let nan = f64::NAN;
    
    // ä»ä½æ¨¡å¼åˆ›å»ºè‡ªå®šä¹‰ NaN (ä¿ç•™ payload)
    let custom_nan_bits: u64 = 0x7FF8_0000_0000_0001; // é™é»˜ NaN + payload
    let custom_nan = f64::from_bits(custom_nan_bits);
    
    // è¿ç®—äº§ç”Ÿçš„ NaN
    let zero_div_nan = 0.0_f64 / 0.0;
    let inf_sub_nan = f64::INFINITY - f64::INFINITY;
    let sqrt_neg_nan = (-1.0_f64).sqrt();
    
    // æ‰€æœ‰ NaN éƒ½ä¸ç›¸ç­‰
    println!("nan == custom_nan: {}", nan == custom_nan);      // false
    println!("nan == zero_div_nan: {}", nan == zero_div_nan);  // false
    
    // ä½†éƒ½æ˜¯ NaN
    println!("nan.is_nan(): {}", nan.is_nan());                // true
    println!("custom_nan.is_nan(): {}", custom_nan.is_nan());  // true
}
```

### 2.2 NaN çš„ä¼ æ’­è§„åˆ™

```rust
fn nan_propagation_rules() {
    let nan = f64::NAN;
    let x = 10.0_f64;
    
    // è§„åˆ™ 1: ä»»ä½•ç®—æœ¯è¿ç®—æ¶‰åŠ NaNï¼Œç»“æœä¸º NaN
    assert!((nan + x).is_nan());
    assert!((nan - x).is_nan());
    assert!((nan * x).is_nan());
    assert!((nan / x).is_nan());
    assert!((x / nan).is_nan());
    
    // è§„åˆ™ 2: NaN çš„ç¬¦å·è¿ç®—
    assert!((-nan).is_nan());           // å–è´Ÿä»ä¸º NaN
    assert!(nan.abs().is_nan());        // ç»å¯¹å€¼ä»ä¸º NaN
    
    // è§„åˆ™ 3: NaN ä¸æ— ç©·å¤§
    assert!((nan + f64::INFINITY).is_nan());
    assert!((nan * f64::INFINITY).is_nan());
    
    // è§„åˆ™ 4: 0 * Infinity = NaN
    assert!((0.0 * f64::INFINITY).is_nan());
    
    // è§„åˆ™ 5: Infinity / Infinity = NaN
    assert!((f64::INFINITY / f64::INFINITY).is_nan());
    
    // è§„åˆ™ 6: 0 / 0 = NaN
    assert!((0.0 / 0.0).is_nan());
}
```

### 2.3 NaN çš„æ¯”è¾ƒè¯­ä¹‰

```rust
fn nan_comparison_semantics() {
    let nan = f64::NAN;
    
    // æ ¸å¿ƒè§„åˆ™: NaN ä¸ä»»ä½•å€¼ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰æ¯”è¾ƒéƒ½ä¸º false
    assert!(!(nan == nan));       // false!
    assert!(!(nan < nan));        // false
    assert!(!(nan > nan));        // false
    assert!(!(nan <= nan));       // false
    assert!(!(nan >= nan));       // false
    assert!(nan != nan);          // true! (å”¯ä¸€ä¸º true çš„æ¯”è¾ƒ)
    
    // NaN ä¸å…¶ä»–å€¼çš„æ¯”è¾ƒ
    let x = 10.0_f64;
    assert!(!(nan == x));
    assert!(!(nan < x));
    assert!(!(nan > x));
    assert!(!(x < nan));
    assert!(!(x > nan));
    
    // è¿™å¯¼è‡´æ’åºæ—¶çš„ç‰¹æ®Šå¤„ç†
    let mut values = vec![1.0, f64::NAN, 2.0, 3.0];
    values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less));
    println!("æ’åºå: {:?}", values);
    // NaN é€šå¸¸è¢«æ”¾åœ¨å¼€å¤´æˆ–ç»“å°¾
}
```

**åœ¨é›†åˆä¸­çš„è¡Œä¸º**ï¼š

```rust
use std::collections::{HashSet, HashMap};

fn nan_in_collections() {
    // âš ï¸ NaN åœ¨ HashMap/HashSet ä¸­çš„è¡Œä¸ºä¸ç›´è§‚
    let mut set = HashSet::new();
    set.insert(f64::NAN);
    set.insert(f64::NAN);
    
    // NaN ä½æ¨¡å¼ç›¸åŒæ—¶ï¼Œè¢«è§†ä¸ºåŒä¸€ä¸ªé”®
    println!("set.len(): {}", set.len()); // è¾“å‡º: 1
    
    // ä½† contains å¯èƒ½è¿”å› false
    println!("contains NaN: {}", set.contains(&f64::NAN)); // å®ç°ä¾èµ–
    
    // æ¨è: æµ®ç‚¹æ•°ä½œä¸ºé”®æ—¶ï¼Œä½¿ç”¨ ordered_float ç­‰åº“
}
```

### 2.4 NaN åœ¨ const fn ä¸­çš„è¡Œä¸º

```rust
// âœ… const fn ä¸­å¯ä»¥ç”Ÿæˆå’Œæ£€æµ‹ NaN
const fn produce_nan() -> f64 {
    0.0 / 0.0  // ç¼–è¯‘æœŸç”Ÿæˆ NaN
}

const fn infinity_minus_infinity() -> f64 {
    f64::INFINITY - f64::INFINITY
}

// âŒ ä½† is_nan() åœ¨ Rust 1.90 ä¸­ä»ä¸èƒ½ç”¨äº const ä¸Šä¸‹æ–‡
// const fn check_nan(x: f64) -> bool {
//     x.is_nan()  // âŒ ç¼–è¯‘é”™è¯¯
// }

// âœ… å˜é€šæ–¹æ³•: ä½¿ç”¨ä½æ¨¡å¼æ£€æµ‹
const fn is_nan_const(x: f64) -> bool {
    let bits = x.to_bits();
    // NaN: æŒ‡æ•°ä½å…¨1ï¼Œå°¾æ•°ä½é0
    (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
        && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
}

const NAN_CHECK: bool = is_nan_const(f64::NAN);

fn main() {
    println!("ç¼–è¯‘æœŸ NaN æ£€æµ‹: {}", NAN_CHECK); // true
}
```

---

## 3. ç‰¹æ®Šæµ®ç‚¹å€¼å¤„ç†

### 3.1 æ— ç©·å¤§ (Infinity) å¤„ç†

```rust
fn infinity_operations() {
    let inf = f64::INFINITY;
    let neg_inf = f64::NEG_INFINITY;
    
    // æ— ç©·å¤§çš„ç®—æœ¯è¿ç®—
    assert_eq!(inf + 100.0, inf);           // âˆ + x = âˆ
    assert_eq!(inf * 2.0, inf);             // âˆ Ã— x = âˆ (x > 0)
    assert_eq!(inf * -2.0, neg_inf);        // âˆ Ã— x = -âˆ (x < 0)
    assert_eq!(1.0 / inf, 0.0);             // 1/âˆ = 0
    
    // æœªå®šä¹‰è¿ç®—äº§ç”Ÿ NaN
    assert!((inf - inf).is_nan());          // âˆ - âˆ = NaN
    assert!((inf / inf).is_nan());          // âˆ / âˆ = NaN
    assert!((inf * 0.0).is_nan());          // âˆ Ã— 0 = NaN
    
    // æ¯”è¾ƒè¯­ä¹‰
    assert!(inf > f64::MAX);
    assert!(neg_inf < f64::MIN);
    assert!(inf > neg_inf);
}

// const fn ä¸­ä½¿ç”¨æ— ç©·å¤§
const fn compute_with_infinity(x: f64) -> f64 {
    if x > 1e308 {  // æ¥è¿‘ f64::MAX
        f64::INFINITY
    } else {
        x * 2.0
    }
}
```

### 3.2 é›¶å€¼ (+0.0 vs -0.0)

```rust
fn signed_zero_semantics() {
    let pos_zero = 0.0_f64;
    let neg_zero = -0.0_f64;
    
    // IEEE 754 è§„å®š: +0.0 == -0.0
    assert_eq!(pos_zero, neg_zero);
    
    // ä½†ä½æ¨¡å¼ä¸åŒ
    assert_ne!(pos_zero.to_bits(), neg_zero.to_bits());
    println!("(+0.0).to_bits(): 0x{:016X}", pos_zero.to_bits()); // 0x0000000000000000
    println!("(-0.0).to_bits(): 0x{:016X}", neg_zero.to_bits()); // 0x8000000000000000
    
    // ç¬¦å·ä½å½±å“æŸäº›è¿ç®—
    assert_eq!(1.0 / pos_zero, f64::INFINITY);      // 1/+0 = +âˆ
    assert_eq!(1.0 / neg_zero, f64::NEG_INFINITY);  // 1/-0 = -âˆ
    
    // æŸäº›å‡½æ•°ä¿ç•™ç¬¦å·
    assert_eq!(pos_zero.copysign(1.0), pos_zero);
    assert_eq!(pos_zero.copysign(-1.0), neg_zero);
}

// æ£€æµ‹æœ‰ç¬¦å·é›¶
fn is_negative_zero(x: f64) -> bool {
    x == 0.0 && x.is_sign_negative()
}

const fn const_signed_zero_check(x: f64) -> bool {
    x.to_bits() == 0x8000_0000_0000_0000
}
```

### 3.3 æ¬¡æ­£è§„æ•° (Subnormal Numbers)

```rust
fn subnormal_numbers() {
    // f64 çš„æœ€å°æ­£è§„æ•°å’Œæœ€å°æ¬¡æ­£è§„æ•°
    const MIN_POSITIVE: f64 = f64::MIN_POSITIVE;  // 2^-1022 â‰ˆ 2.225e-308
    const MIN_SUBNORMAL: f64 = 5e-324;            // 2^-1074 (æœ€å°æ­£æ¬¡æ­£è§„æ•°)
    
    println!("æœ€å°æ­£è§„æ•°: {:.3e}", MIN_POSITIVE);
    println!("æœ€å°æ¬¡æ­£è§„æ•°: {:.3e}", MIN_SUBNORMAL);
    
    // æ¬¡æ­£è§„æ•°çš„ç‰¹å¾: æŒ‡æ•°ä½å…¨0ï¼Œå°¾æ•°ä½é0
    let is_subnormal = |x: f64| -> bool {
        let bits = x.to_bits();
        (bits & 0x7FF0_0000_0000_0000 == 0) && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
    };
    
    assert!(is_subnormal(MIN_SUBNORMAL));
    assert!(!is_subnormal(MIN_POSITIVE));
    
    // æ¬¡æ­£è§„æ•°çš„è¿ç®—å¯èƒ½ä¸§å¤±ç²¾åº¦
    let tiny = 1e-320;
    let result = tiny * tiny;
    println!("1e-320 * 1e-320 = {:.3e}", result); // å¯èƒ½ä¸‹æº¢ä¸º 0
}

// const fn ä¸­å¤„ç†æ¬¡æ­£è§„æ•°
const fn handle_subnormal(x: f64) -> f64 {
    // ç®€å•ç­–ç•¥: å°äºé˜ˆå€¼çš„å€¼æˆªæ–­ä¸º 0
    if x.abs() < f64::MIN_POSITIVE {
        0.0
    } else {
        x
    }
}
```

---

## 4. const fn æµ®ç‚¹æ“ä½œå®æˆ˜

### 4.1 ç¼–è¯‘æœŸå¸¸é‡è®¡ç®—

```rust
// ç‰©ç†å¸¸æ•°çš„ç¼–è¯‘æœŸå®šä¹‰
pub const SPEED_OF_LIGHT: f64 = 299_792_458.0;           // m/s
pub const PLANCK_CONSTANT: f64 = 6.62607015e-34;        // JÂ·s
pub const BOLTZMANN_CONSTANT: f64 = 1.380649e-23;       // J/K

// ç¼–è¯‘æœŸè®¡ç®—æ´¾ç”Ÿå¸¸æ•°
pub const REDUCED_PLANCK: f64 = PLANCK_CONSTANT / (2.0 * 3.141592653589793);

// const fn å‡½æ•°ç”¨äºå¤æ‚è®¡ç®—
const fn kelvin_to_celsius(k: f64) -> f64 {
    k - 273.15
}

const fn energy_from_frequency(frequency: f64) -> f64 {
    PLANCK_CONSTANT * frequency
}

// ç¼–è¯‘æœŸé…ç½®
const ROOM_TEMPERATURE_K: f64 = 293.15;
const ROOM_TEMPERATURE_C: f64 = kelvin_to_celsius(ROOM_TEMPERATURE_K);

fn main() {
    println!("å®¤æ¸© (æ‘„æ°): {:.2}Â°C", ROOM_TEMPERATURE_C);
    
    // ç¼–è¯‘æœŸè®¡ç®—çš„æ•°ç»„
    const TEMPS: [f64; 5] = [
        kelvin_to_celsius(273.15),
        kelvin_to_celsius(293.15),
        kelvin_to_celsius(373.15),
        kelvin_to_celsius(273.15 - 40.0),
        kelvin_to_celsius(0.0),
    ];
    println!("æ¸©åº¦æ•°ç»„: {:?}", TEMPS);
}
```

### 4.2 const fn ä¸­çš„æµ®ç‚¹åˆ†ç±»

```rust
// ä½¿ç”¨ä½æ¨¡å¼å®ç°ç¼–è¯‘æœŸæµ®ç‚¹åˆ†ç±»
const fn classify_float(x: f64) -> FloatClass {
    let bits = x.to_bits();
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    let sign = bits >> 63;
    
    if exp == 0 {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosZero
            } else {
                FloatClass::NegZero
            }
        } else {
            FloatClass::Subnormal
        }
    } else if exp == 0x7FF {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosInfinity
            } else {
                FloatClass::NegInfinity
            }
        } else {
            FloatClass::NaN
        }
    } else {
        FloatClass::Normal
    }
}

#[derive(Debug, PartialEq)]
enum FloatClass {
    PosZero,
    NegZero,
    Normal,
    Subnormal,
    PosInfinity,
    NegInfinity,
    NaN,
}

const CLASS_TESTS: [FloatClass; 7] = [
    classify_float(0.0),
    classify_float(-0.0),
    classify_float(1.0),
    classify_float(5e-324),
    classify_float(f64::INFINITY),
    classify_float(f64::NEG_INFINITY),
    classify_float(f64::NAN),
];

fn main() {
    for (i, class) in CLASS_TESTS.iter().enumerate() {
        println!("æµ‹è¯• {}: {:?}", i, class);
    }
}
```

### 4.3 ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹

```rust
// ä½¿ç”¨ const fn åœ¨ç¼–è¯‘æœŸæ£€æµ‹éæ³•é…ç½®
const fn validate_config(threshold: f64) -> f64 {
    // Rust 1.90 ä¸­ const panic å·²ç¨³å®š
    if threshold.is_infinite() {
        panic!("é˜ˆå€¼ä¸èƒ½ä¸ºæ— ç©·å¤§");
    }
    if threshold.is_nan() {
        panic!("é˜ˆå€¼ä¸èƒ½ä¸º NaN");
    }
    if threshold < 0.0 {
        panic!("é˜ˆå€¼å¿…é¡»ä¸ºéè´Ÿæ•°");
    }
    threshold
}

// ç¼–è¯‘æœŸéªŒè¯
const THRESHOLD: f64 = validate_config(0.001);
// const INVALID: f64 = validate_config(f64::NAN); // âŒ ç¼–è¯‘é”™è¯¯: NaN

// æ›´é«˜çº§çš„ç¼–è¯‘æœŸçº¦æŸ
const fn safe_divide(a: f64, b: f64) -> f64 {
    if b == 0.0 {
        panic!("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
    }
    a / b
}

const RATIO: f64 = safe_divide(10.0, 2.0);
// const BAD: f64 = safe_divide(10.0, 0.0); // âŒ ç¼–è¯‘é”™è¯¯

fn main() {
    println!("éªŒè¯çš„é˜ˆå€¼: {}", THRESHOLD);
    println!("å®‰å…¨çš„æ¯”ç‡: {}", RATIO);
}
```

---

## 5. æµ®ç‚¹æ•°ä½æ¨¡å¼æ“ä½œ

### 5.1 to_bits å’Œ from_bits

```rust
fn bit_pattern_operations() {
    let x = 1.0_f64;
    let bits = x.to_bits();
    
    // IEEE 754 åŒç²¾åº¦æ ¼å¼:
    // ä½ 63: ç¬¦å·ä½
    // ä½ 62-52: æŒ‡æ•° (11 ä½, åç§» 1023)
    // ä½ 51-0: å°¾æ•° (52 ä½, éšå«å‰å¯¼ 1)
    
    println!("1.0 çš„ä½æ¨¡å¼: 0x{:016X}", bits);
    // è¾“å‡º: 0x3FF0000000000000
    //       ^^^^ ^^^^
    //       ç¬¦å·(0) æŒ‡æ•°(01111111111=1023) å°¾æ•°(å…¨0)
    //       å®é™…å€¼: (-1)^0 Ã— 1.0 Ã— 2^(1023-1023) = 1.0
    
    // ä½æ“ä½œ
    let sign = bits >> 63;
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    
    println!("ç¬¦å·: {}, æŒ‡æ•°: {}, å°¾æ•°: 0x{:013X}", sign, exp, mantissa);
    
    // é‡æ–°æ„é€ 
    let reconstructed = f64::from_bits(bits);
    assert_eq!(x, reconstructed);
}

// const ä¸Šä¸‹æ–‡ä¸­çš„ä½æ“ä½œ
const fn extract_exponent(x: f64) -> u64 {
    (x.to_bits() >> 52) & 0x7FF
}

const fn extract_mantissa(x: f64) -> u64 {
    x.to_bits() & 0x000F_FFFF_FFFF_FFFF
}

const PI_EXP: u64 = extract_exponent(3.141592653589793);
const PI_MANTISSA: u64 = extract_mantissa(3.141592653589793);

fn main() {
    println!("Ï€ çš„æŒ‡æ•°: {} (å®é™…æŒ‡æ•°: {})", PI_EXP, PI_EXP as i64 - 1023);
    println!("Ï€ çš„å°¾æ•°: 0x{:013X}", PI_MANTISSA);
}
```

### 5.2 NaN payload è®¿é—®

```rust
// NaN çš„å°¾æ•°å¯ä»¥æºå¸¦"payload"ä¿¡æ¯
fn nan_payload() {
    // åˆ›å»ºå¸¦ payload çš„ NaN
    fn create_nan_with_payload(payload: u64) -> f64 {
        // ç¡®ä¿ payload å°äº 2^51 (ä¿ç•™æœ€é«˜ä½ä¸º1è¡¨ç¤ºé™é»˜ NaN)
        let payload = payload & 0x0007_FFFF_FFFF_FFFF;
        let nan_bits = 0x7FF8_0000_0000_0000 | payload;
        f64::from_bits(nan_bits)
    }
    
    // æå– payload
    fn extract_nan_payload(nan: f64) -> Option<u64> {
        if nan.is_nan() {
            Some(nan.to_bits() & 0x0007_FFFF_FFFF_FFFF)
        } else {
            None
        }
    }
    
    let error_code_1 = create_nan_with_payload(42);
    let error_code_2 = create_nan_with_payload(100);
    
    println!("NaN1 payload: {:?}", extract_nan_payload(error_code_1));
    println!("NaN2 payload: {:?}", extract_nan_payload(error_code_2));
    
    // æ³¨æ„: Rust ä¸ä¿è¯ NaN payload åœ¨è¿ç®—ä¸­ä¿ç•™
    let result = error_code_1 + 1.0;
    println!("è¿ç®—å payload: {:?}", extract_nan_payload(result));
}
```

### 5.3 ä½æ¨¡å¼å®‰å…¨æ€§

```rust
// from_bits ä¸æ£€æŸ¥è¾“å…¥åˆæ³•æ€§ï¼Œå¯èƒ½åˆ›å»ºéè§„èŒƒå€¼
fn bit_pattern_safety() {
    // âœ… åˆæ³•çš„ä½æ¨¡å¼
    let valid = f64::from_bits(0x3FF0_0000_0000_0000); // 1.0
    assert_eq!(valid, 1.0);
    
    // âš ï¸ ä¿¡å· NaN (sNaN) åœ¨æŸäº›å¹³å°å¯èƒ½è§¦å‘å¼‚å¸¸
    let signaling_nan = f64::from_bits(0x7FF0_0000_0000_0001);
    println!("sNaN is_nan: {}", signaling_nan.is_nan()); // true
    
    // âœ… æ¨è: ä½¿ç”¨é™é»˜ NaN
    let quiet_nan = f64::from_bits(0x7FF8_0000_0000_0001);
    
    // ä½æ¨¡å¼å¾€è¿”å¯èƒ½è§„èŒƒåŒ–
    let original_bits = 0x7FF0_0000_0000_0001; // sNaN
    let value = f64::from_bits(original_bits);
    let round_trip_bits = value.to_bits();
    
    // æŸäº›å¹³å°ä¼šå°† sNaN è½¬æ¢ä¸º qNaN
    if original_bits != round_trip_bits {
        println!("ä½æ¨¡å¼è¢«è§„èŒƒåŒ–: 0x{:016X} -> 0x{:016X}", 
                 original_bits, round_trip_bits);
    }
}

// const ä¸Šä¸‹æ–‡ä¸­çš„å®‰å…¨ä½æ“ä½œ
const fn safe_from_bits(bits: u64) -> f64 {
    // æ£€æµ‹ sNaN å¹¶è½¬æ¢ä¸º qNaN
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    
    if exp == 0x7FF && mantissa != 0 && (mantissa & 0x0008_0000_0000_0000) == 0 {
        // è¿™æ˜¯ sNaNï¼Œè½¬æ¢ä¸º qNaN
        f64::from_bits(bits | 0x0008_0000_0000_0000)
    } else {
        f64::from_bits(bits)
    }
}
```

---

## 6. å®é™…åº”ç”¨åœºæ™¯

### 6.1 æ•°å€¼è®¡ç®—åº“ä¸­çš„ NaN å¤„ç†

```rust
// ç»Ÿè®¡å‡½æ•°ä¸­çš„ NaN ä¼ æ’­
pub fn mean_with_nan_handling(data: &[f64]) -> f64 {
    if data.is_empty() {
        return f64::NAN;
    }
    
    let mut sum = 0.0;
    let mut count = 0;
    
    for &value in data {
        if !value.is_nan() {
            sum += value;
            count += 1;
        }
    }
    
    if count == 0 {
        f64::NAN
    } else {
        sum / count as f64
    }
}

// æ•°å€¼ç¨³å®šçš„æ±‚å’Œ
pub fn kahan_summation(data: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut compensation = 0.0;
    
    for &value in data {
        if value.is_nan() {
            return f64::NAN;
        }
        
        let y = value - compensation;
        let t = sum + y;
        compensation = (t - sum) - y;
        sum = t;
    }
    
    sum
}

fn main() {
    let data = vec![1.0, 2.0, f64::NAN, 4.0];
    println!("å‡å€¼ (å¿½ç•¥ NaN): {}", mean_with_nan_handling(&data));
    
    let clean_data = vec![1e-16, 1.0, 1e-16];
    println!("Kahan æ±‚å’Œ: {}", kahan_summation(&clean_data));
}
```

### 6.2 ç¼–è¯‘æœŸç‰©ç†å¸¸æ•°å®šä¹‰

```rust
// ç¼–è¯‘æœŸè®¡ç®—çš„ç‰©ç†å¸¸æ•°è¡¨
pub mod physics {
    // åŸºæœ¬å¸¸æ•°
    pub const C: f64 = 299_792_458.0;                    // å…‰é€Ÿ (m/s)
    pub const H: f64 = 6.62607015e-34;                   // æ™®æœ—å…‹å¸¸æ•° (JÂ·s)
    pub const K_B: f64 = 1.380649e-23;                   // ç»å°”å…¹æ›¼å¸¸æ•° (J/K)
    pub const E_0: f64 = 8.8541878128e-12;               // çœŸç©ºä»‹ç”µå¸¸æ•° (F/m)
    pub const MU_0: f64 = 1.25663706212e-6;              // çœŸç©ºç£å¯¼ç‡ (H/m)
    
    // æ´¾ç”Ÿå¸¸æ•° (ç¼–è¯‘æœŸè®¡ç®—)
    pub const H_BAR: f64 = H / (2.0 * 3.141592653589793);         // çº¦åŒ–æ™®æœ—å…‹å¸¸æ•°
    pub const IMPEDANCE_0: f64 = 376.730313668;                   // çœŸç©ºé˜»æŠ— (Î©)
    
    // å•ä½è½¬æ¢
    pub const EV_TO_JOULE: f64 = 1.602176634e-19;
    pub const JOULE_TO_EV: f64 = 1.0 / EV_TO_JOULE;
    
    // ç¼–è¯‘æœŸå‡½æ•°
    pub const fn wavelength_to_frequency(lambda: f64) -> f64 {
        C / lambda
    }
    
    pub const fn energy_to_wavelength(energy_joules: f64) -> f64 {
        (H * C) / energy_joules
    }
}

const VISIBLE_LIGHT_MIN_FREQ: f64 = physics::wavelength_to_frequency(700e-9);
const VISIBLE_LIGHT_MAX_FREQ: f64 = physics::wavelength_to_frequency(400e-9);

fn main() {
    println!("å¯è§å…‰é¢‘ç‡èŒƒå›´: {:.3e} - {:.3e} Hz", 
             VISIBLE_LIGHT_MIN_FREQ, VISIBLE_LIGHT_MAX_FREQ);
}
```

### 6.3 åµŒå…¥å¼ç³»ç»Ÿä¸­çš„æµ®ç‚¹ä¼˜åŒ–

```rust
// ç¼–è¯‘æœŸå†³å®šä½¿ç”¨è½¯æµ®ç‚¹è¿˜æ˜¯ç¡¬æµ®ç‚¹
#[cfg(target_feature = "fpu")]
const USE_HARDWARE_FLOAT: bool = true;
#[cfg(not(target_feature = "fpu"))]
const USE_HARDWARE_FLOAT: bool = false;

// ç¼–è¯‘æœŸé…ç½®ç²¾åº¦æƒè¡¡
const HIGH_PRECISION: bool = cfg!(feature = "high_precision");

const fn select_epsilon() -> f32 {
    if HIGH_PRECISION {
        1e-7
    } else {
        1e-5  // åµŒå…¥å¼ç³»ç»Ÿå¯æ¥å—çš„ç²¾åº¦
    }
}

const EPSILON: f32 = select_epsilon();

// å®šç‚¹æ•°æ¨¡æ‹Ÿæµ®ç‚¹æ•° (ç¼–è¯‘æœŸå†³ç­–)
const fn fixed_point_mul(a: i32, b: i32, scale: i32) -> i32 {
    ((a as i64 * b as i64) / scale as i64) as i32
}

const SCALE: i32 = 1000;
const RESULT: i32 = fixed_point_mul(1500, 2000, SCALE);

fn main() {
    println!("ä½¿ç”¨ç¡¬ä»¶æµ®ç‚¹: {}", USE_HARDWARE_FLOAT);
    println!("ç²¾åº¦é˜ˆå€¼: {}", EPSILON);
    println!("å®šç‚¹è¿ç®—: 1.5 * 2.0 = {}", RESULT as f32 / SCALE as f32);
}
```

---

## 7. æ€§èƒ½ä¸é™·é˜±

### 7.1 NaN æ£€æµ‹çš„æ€§èƒ½è€ƒè™‘

```rust
use std::time::Instant;

fn benchmark_nan_checks(data: &[f64], iterations: usize) {
    // æ–¹æ³• 1: is_nan()
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x.is_nan();
        }
    }
    let method1_time = start.elapsed();
    
    // æ–¹æ³• 2: è‡ªæ¯”è¾ƒ
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x != x;
        }
    }
    let method2_time = start.elapsed();
    
    // æ–¹æ³• 3: ä½æ¨¡å¼æ£€æŸ¥
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let bits = x.to_bits();
            let _ = (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
                && (bits & 0x000F_FFFF_FFFF_FFFF != 0);
        }
    }
    let method3_time = start.elapsed();
    
    println!("NaN æ£€æµ‹æ€§èƒ½ ({}æ¬¡è¿­ä»£):", iterations);
    println!("  is_nan():      {:?}", method1_time);
    println!("  x != x:        {:?}", method2_time);
    println!("  ä½æ¨¡å¼æ£€æŸ¥:     {:?}", method3_time);
}

fn main() {
    let data: Vec<f64> = (0..1000).map(|i| i as f64 * 0.1).collect();
    benchmark_nan_checks(&data, 10000);
}
```

**æ€§èƒ½å»ºè®®**ï¼š

- âœ… `is_nan()` é€šå¸¸æ˜¯æœ€å¿«çš„æ–¹æ³•ï¼ˆç¼–è¯‘å™¨ä¼˜åŒ–ï¼‰
- âœ… `x != x` è¯­ä¹‰æ¸…æ™°ï¼Œæ€§èƒ½æ¥è¿‘
- âŒ ä½æ¨¡å¼æ£€æŸ¥é€šå¸¸è¾ƒæ…¢ï¼Œé™¤ééœ€è¦ç²¾ç¡®æ§åˆ¶

### 7.2 å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•

```rust
// é™·é˜± 1: ä¸å½“çš„ NaN æ¯”è¾ƒ
fn pitfall_nan_comparison() {
    let nan = f64::NAN;
    
    // âŒ é”™è¯¯: æ°¸è¿œä¸ä¼šæ‰§è¡Œ
    if nan == f64::NAN {
        println!("This never prints");
    }
    
    // âœ… æ­£ç¡®
    if nan.is_nan() {
        println!("æ£€æµ‹åˆ° NaN");
    }
}

// é™·é˜± 2: æµ®ç‚¹æ•°ä½œä¸º HashMap é”®
fn pitfall_hash_key() {
    use std::collections::HashMap;
    
    let mut map = HashMap::new();
    map.insert(1.0, "one");
    
    // âš ï¸ æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜å¯èƒ½å¯¼è‡´é”®æŸ¥æ‰¾å¤±è´¥
    let key = 0.1 + 0.2; // 0.30000000000000004
    map.insert(key, "almost 0.3");
    
    // å¯èƒ½æ‰¾ä¸åˆ°
    println!("æŸ¥æ‰¾ 0.3: {:?}", map.get(&0.3));
    
    // âœ… æ¨è: ä½¿ç”¨æ•´æ•°æˆ– ordered_float::OrderedFloat
}

// é™·é˜± 3: ç´¯ç§¯è¯¯å·®
fn pitfall_accumulation() {
    // âŒ æœ´ç´ æ±‚å’Œ
    let mut sum = 0.0_f64;
    for _ in 0..1_000_000 {
        sum += 1e-10;
    }
    println!("æœ´ç´ æ±‚å’Œ: {:.15}", sum);
    // æœŸæœ›: 0.0001, å®é™…: è¯¯å·®è¾ƒå¤§
    
    // âœ… Kahan è¡¥å¿æ±‚å’Œ
    let mut sum = 0.0;
    let mut c = 0.0;
    for _ in 0..1_000_000 {
        let y = 1e-10 - c;
        let t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    println!("Kahan æ±‚å’Œ: {:.15}", sum);
}

// é™·é˜± 4: é™¤é›¶æ£€æŸ¥ä¸è¶³
fn pitfall_division() {
    let x = 10.0;
    let y = 0.0;
    
    // âš ï¸ ä¸ä¼š panicï¼Œä½†äº§ç”Ÿ Inf
    let result = x / y;
    println!("10.0 / 0.0 = {}", result); // Inf
    
    // âœ… æ˜¾å¼æ£€æŸ¥
    if y == 0.0 {
        eprintln!("é™¤æ•°ä¸ºé›¶");
    } else {
        println!("ç»“æœ: {}", x / y);
    }
    
    // âœ… ç»“æœéªŒè¯
    if result.is_finite() {
        println!("æœ‰é™ç»“æœ: {}", result);
    } else {
        eprintln!("ç»“æœéæœ‰é™: {}", result);
    }
}
```

---

## 8. è·¨ç‰ˆæœ¬å…¼å®¹æ€§è¯´æ˜

| ç‰¹æ€§                          | Rust 1.82 | Rust 1.90 | è¯´æ˜                                  |
|-------------------------------|-----------|-----------|---------------------------------------|
| `f32/f64` åŸºæœ¬è¿ç®— const æ”¯æŒ | ç¨³å®š      | ç¨³å®š      | +, -, *, /, - (å–è´Ÿ)                  |
| `abs()` const æ”¯æŒ            | ç¨³å®š      | ç¨³å®š      | ç»å¯¹å€¼                                |
| `to_bits()/from_bits()` const | ç¨³å®š      | ç¨³å®š      | ä½æ¨¡å¼è½¬æ¢                            |
| `is_nan()/is_infinite()` const| ä¸ç¨³å®š    | **ç¨³å®š**  | **Rust 1.84+ ç¨³å®šåŒ–**                 |
| `copysign()` const            | ä¸ç¨³å®š    | **ç¨³å®š**  | **Rust 1.85+ ç¨³å®šåŒ–**                 |
| `min()/max()` const           | ä¸ç¨³å®š    | éƒ¨åˆ†ç¨³å®š  | éœ€è¦ feature flag (Rust 1.90)         |
| `sqrt()/sin()/cos()` const    | ä¸ç¨³å®š    | ä¸ç¨³å®š    | è¶…è¶Šå‡½æ•°ä»ä¸æ”¯æŒ                      |

**è¿ç§»å»ºè®®**ï¼š

- å¯¹äº Rust 1.90ï¼Œå¯å®‰å…¨ä½¿ç”¨åŸºæœ¬è¿ç®—å’Œä½æ¨¡å¼æ“ä½œ
- æµ®ç‚¹åˆ†ç±»å‡½æ•° (`is_nan()`, `is_finite()`) å¯é€šè¿‡ä½æ¨¡å¼æ¨¡æ‹Ÿ
- è¶…è¶Šå‡½æ•°éœ€ä¾èµ–è¿è¡Œæ—¶è®¡ç®—æˆ–ç¬¬ä¸‰æ–¹ const æ•°å­¦åº“

---

## 9. ç›¸å…³èµ„æº

### å†…éƒ¨æ–‡æ¡£

- [åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md) - æµ®ç‚¹æ•°åŸºç¡€
- [ç±»å‹è½¬æ¢å‚è€ƒ](01_ç±»å‹è½¬æ¢å‚è€ƒ.md) - æµ®ç‚¹æ•°ç±»å‹è½¬æ¢è§„åˆ™
- [æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md) - æµ®ç‚¹æ•°æ€§èƒ½ä¼˜åŒ–

### å¤–éƒ¨èµ„æº

- **IEEE 754 æ ‡å‡†**: <https://ieeexplore.ieee.org/document/8766229>
- **Rust RFC 3514 (const float ops)**: <https://github.com/rust-lang/rfcs/pull/3514>
- **Float Toy (å¯è§†åŒ–å·¥å…·)**: <https://evanw.github.io/float-toy/>
- **What Every Computer Scientist Should Know About Floating-Point Arithmetic**: <https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html>

### ç›¸å…³ Crate

- `ordered-float`: å®ç° `Ord` å’Œ `Hash` çš„æµ®ç‚¹åŒ…è£…å™¨
- `approx`: æµ®ç‚¹æ•°è¿‘ä¼¼æ¯”è¾ƒ
- `num-traits`: æ•°å€¼ç±»å‹ trait æŠ½è±¡
- `libm`: çº¯ Rust æ•°å­¦å‡½æ•°åº“ (æ”¯æŒ const)

---

**æ€»ç»“**ï¼šRust 1.90 çš„æµ®ç‚¹æ•° const fn èƒ½åŠ›ä¸ºç¼–è¯‘æœŸè®¡ç®—å’Œé…ç½®æä¾›äº†å¼ºå¤§æ”¯æŒã€‚ç†è§£ NaN è¯­ä¹‰ã€ç‰¹æ®Šå€¼å¤„ç†å’Œä½æ¨¡å¼æ“ä½œï¼Œèƒ½å¤Ÿç¼–å†™å‡ºæ›´å®‰å…¨ã€æ›´é«˜æ•ˆçš„æ•°å€¼è®¡ç®—ä»£ç ã€‚åœ¨ä½¿ç”¨ const fn æ—¶ï¼Œè¦æ³¨æ„å½“å‰ç‰ˆæœ¬çš„é™åˆ¶ï¼Œå¹¶æ ¹æ®éœ€è¦é‡‡ç”¨ä½æ“ä½œç­‰å˜é€šæ–¹æ³•ã€‚

**ä¸‹ä¸€æ­¥**ï¼šå»ºè®®é˜…è¯» [é«˜çº§æ³›å‹æ¨¡å¼](../tier_04_advanced/02_é«˜çº§æ³›å‹æ¨¡å¼.md) ä»¥äº†è§£æ³›å‹å¸¸é‡è¡¨è¾¾å¼ï¼ˆGeneric Const Exprsï¼‰ï¼Œå®ƒä¸ const fn ç»“åˆèƒ½å®ç°æ›´å¼ºå¤§çš„ç¼–è¯‘æœŸç¼–ç¨‹ã€‚
