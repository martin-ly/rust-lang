# 3.6 浮点数高级主题与 const fn 语义 (Rust 1.90)

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: Rust 1.90 浮点数类型高级特性的权威技术参考  
> **适用对象**: 需要深入理解浮点数语义和 const fn 能力的高级开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [基础类型指南](../tier_02_guides/01_基础类型指南.md)

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [3.6 浮点数高级主题与 const fn 语义 (Rust 1.90)](#36-浮点数高级主题与-const-fn-语义-rust-190)
  - [📋 目录](#-目录)
  - [1. Rust 1.90 浮点数 const fn 能力概览](#1-rust-190-浮点数-const-fn-能力概览)
    - [1.1 稳定化的 const 浮点操作](#11-稳定化的-const-浮点操作)
    - [1.2 const 上下文中的限制](#12-const-上下文中的限制)
  - [2. NaN (Not-a-Number) 语义深度解析](#2-nan-not-a-number-语义深度解析)
    - [2.1 IEEE 754 NaN 表示](#21-ieee-754-nan-表示)
    - [2.2 NaN 的传播规则](#22-nan-的传播规则)
    - [2.3 NaN 的比较语义](#23-nan-的比较语义)
    - [2.4 NaN 在 const fn 中的行为](#24-nan-在-const-fn-中的行为)
  - [3. 特殊浮点值处理](#3-特殊浮点值处理)
    - [3.1 无穷大 (Infinity) 处理](#31-无穷大-infinity-处理)
    - [3.2 零值 (+0.0 vs -0.0)](#32-零值-00-vs--00)
    - [3.3 次正规数 (Subnormal Numbers)](#33-次正规数-subnormal-numbers)
  - [4. const fn 浮点操作实战](#4-const-fn-浮点操作实战)
    - [4.1 编译期常量计算](#41-编译期常量计算)
    - [4.2 const fn 中的浮点分类](#42-const-fn-中的浮点分类)
    - [4.3 编译期错误检测](#43-编译期错误检测)
  - [5. 浮点数位模式操作](#5-浮点数位模式操作)
    - [5.1 to\_bits 和 from\_bits](#51-to_bits-和-from_bits)
    - [5.2 NaN payload 访问](#52-nan-payload-访问)
    - [5.3 位模式安全性](#53-位模式安全性)
  - [6. 实际应用场景](#6-实际应用场景)
    - [6.1 数值计算库中的 NaN 处理](#61-数值计算库中的-nan-处理)
    - [6.2 编译期物理常数定义](#62-编译期物理常数定义)
    - [6.3 嵌入式系统中的浮点优化](#63-嵌入式系统中的浮点优化)
  - [7. 性能与陷阱](#7-性能与陷阱)
    - [7.1 NaN 检测的性能考虑](#71-nan-检测的性能考虑)
    - [7.2 常见陷阱与避免方法](#72-常见陷阱与避免方法)
  - [8. 跨版本兼容性说明](#8-跨版本兼容性说明)
  - [9. 相关资源](#9-相关资源)
    - [内部文档](#内部文档)
    - [外部资源](#外部资源)
    - [相关 Crate](#相关-crate)

---

## 1. Rust 1.90 浮点数 const fn 能力概览

### 1.1 稳定化的 const 浮点操作

自 Rust 1.82 起，浮点数操作开始逐步在 const 上下文中稳定化。在 Rust 1.90 中，以下能力已完全稳定：

```rust
// ✅ Rust 1.90 稳定支持的 const 浮点操作
const CONST_OPERATIONS: () = {
    // 基本算术运算
    const ADD: f64 = 1.5 + 2.3;
    const SUB: f64 = 10.0 - 3.14;
    const MUL: f64 = 2.0 * 3.5;
    const DIV: f64 = 10.0 / 2.0;
    
    // 取负和绝对值
    const NEG: f64 = -5.5;
    const ABS: f64 = (-3.14_f64).abs();
    
    // 类型转换 (as)
    const TO_INT: i32 = 3.14_f64 as i32;
    const TO_F32: f32 = 1.0_f64 as f32;
    
    // 特殊值常量
    const INFINITY: f64 = f64::INFINITY;
    const NEG_INFINITY: f64 = f64::NEG_INFINITY;
    const NAN: f64 = f64::NAN;
    
    // 位模式操作
    const BITS: u64 = 1.0_f64.to_bits();
    const FROM_BITS: f64 = f64::from_bits(0x3FF0000000000000);
};

fn main() {
    println!("编译期计算结果: {}", CONST_OPERATIONS::ADD);
}
```

**关键点**：

- ✅ 四则运算在 const 上下文中完全支持
- ✅ `abs()`, `to_bits()`, `from_bits()` 可用于 const fn
- ❌ 超越函数 (`sin`, `cos`, `sqrt` 等) 在 Rust 1.90 中仍不支持 const

### 1.2 const 上下文中的限制

```rust
// ❌ Rust 1.90 中不支持的 const 浮点操作
const fn unsupported_operations() -> f64 {
    // let sqrt = 4.0_f64.sqrt();      // ❌ 超越函数
    // let sin = 1.0_f64.sin();         // ❌ 三角函数
    // let log = 2.0_f64.ln();          // ❌ 对数函数
    // let pow = 2.0_f64.powf(3.0);     // ❌ 幂运算
    
    // ✅ 但可以使用基本运算模拟
    let square = 2.0 * 2.0;
    square
}

// ✅ 编译期常量定义
const PI: f64 = 3.141592653589793;
const E: f64 = 2.718281828459045;

// ✅ const fn 中可以使用的操作
const fn safe_sqrt_approx(x: f64) -> f64 {
    // 使用牛顿迭代法的编译期版本（需要循环支持）
    // 这里简化为基本运算
    if x < 0.0 {
        f64::NAN
    } else {
        x / 2.0 // 简化的近似
    }
}
```

---

## 2. NaN (Not-a-Number) 语义深度解析

### 2.1 IEEE 754 NaN 表示

```rust
fn main() {
    // IEEE 754 规定 NaN 有 2^52 - 2 种不同的位模式
    // Rust 使用"静默 NaN" (quiet NaN) 作为标准 NaN
    
    // 标准 NaN 的位模式 (f64)
    const NAN_BITS: u64 = f64::NAN.to_bits();
    println!("f64::NAN 位模式: 0x{:016X}", NAN_BITS);
    // 输出: 0x7FF8000000000000
    //       ^^^^^^^^^^^^^^^^^^^
    //       符号位(1) | 指数位(11) | 尾数位(52)
    //       0         | 11111111111 | 1000...000
    
    // 符号位: 0 (正 NaN)
    // 指数位: 全1 (2047)
    // 尾数位: 非零，最高位为1表示静默 NaN
    
    // f32 的 NaN 位模式
    const NAN_F32_BITS: u32 = f32::NAN.to_bits();
    println!("f32::NAN 位模式: 0x{:08X}", NAN_F32_BITS);
    // 输出: 0x7FC00000
}
```

**NaN 分类**：

- **静默 NaN (Quiet NaN, qNaN)**: 尾数最高位为1，传播时不触发异常
- **信号 NaN (Signaling NaN, sNaN)**: 尾数最高位为0，理论上应触发异常（Rust 不使用）

```rust
// 创建不同的 NaN
fn explore_nan_patterns() {
    // 标准 NaN
    let nan = f64::NAN;
    
    // 从位模式创建自定义 NaN (保留 payload)
    let custom_nan_bits: u64 = 0x7FF8_0000_0000_0001; // 静默 NaN + payload
    let custom_nan = f64::from_bits(custom_nan_bits);
    
    // 运算产生的 NaN
    let zero_div_nan = 0.0_f64 / 0.0;
    let inf_sub_nan = f64::INFINITY - f64::INFINITY;
    let sqrt_neg_nan = (-1.0_f64).sqrt();
    
    // 所有 NaN 都不相等
    println!("nan == custom_nan: {}", nan == custom_nan);      // false
    println!("nan == zero_div_nan: {}", nan == zero_div_nan);  // false
    
    // 但都是 NaN
    println!("nan.is_nan(): {}", nan.is_nan());                // true
    println!("custom_nan.is_nan(): {}", custom_nan.is_nan());  // true
}
```

### 2.2 NaN 的传播规则

```rust
fn nan_propagation_rules() {
    let nan = f64::NAN;
    let x = 10.0_f64;
    
    // 规则 1: 任何算术运算涉及 NaN，结果为 NaN
    assert!((nan + x).is_nan());
    assert!((nan - x).is_nan());
    assert!((nan * x).is_nan());
    assert!((nan / x).is_nan());
    assert!((x / nan).is_nan());
    
    // 规则 2: NaN 的符号运算
    assert!((-nan).is_nan());           // 取负仍为 NaN
    assert!(nan.abs().is_nan());        // 绝对值仍为 NaN
    
    // 规则 3: NaN 与无穷大
    assert!((nan + f64::INFINITY).is_nan());
    assert!((nan * f64::INFINITY).is_nan());
    
    // 规则 4: 0 * Infinity = NaN
    assert!((0.0 * f64::INFINITY).is_nan());
    
    // 规则 5: Infinity / Infinity = NaN
    assert!((f64::INFINITY / f64::INFINITY).is_nan());
    
    // 规则 6: 0 / 0 = NaN
    assert!((0.0 / 0.0).is_nan());
}
```

### 2.3 NaN 的比较语义

```rust
fn nan_comparison_semantics() {
    let nan = f64::NAN;
    
    // 核心规则: NaN 与任何值（包括自己）比较都为 false
    assert!(!(nan == nan));       // false!
    assert!(!(nan < nan));        // false
    assert!(!(nan > nan));        // false
    assert!(!(nan <= nan));       // false
    assert!(!(nan >= nan));       // false
    assert!(nan != nan);          // true! (唯一为 true 的比较)
    
    // NaN 与其他值的比较
    let x = 10.0_f64;
    assert!(!(nan == x));
    assert!(!(nan < x));
    assert!(!(nan > x));
    assert!(!(x < nan));
    assert!(!(x > nan));
    
    // 这导致排序时的特殊处理
    let mut values = vec![1.0, f64::NAN, 2.0, 3.0];
    values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less));
    println!("排序后: {:?}", values);
    // NaN 通常被放在开头或结尾
}
```

**在集合中的行为**：

```rust
use std::collections::{HashSet, HashMap};

fn nan_in_collections() {
    // ⚠️ NaN 在 HashMap/HashSet 中的行为不直观
    let mut set = HashSet::new();
    set.insert(f64::NAN);
    set.insert(f64::NAN);
    
    // NaN 位模式相同时，被视为同一个键
    println!("set.len(): {}", set.len()); // 输出: 1
    
    // 但 contains 可能返回 false
    println!("contains NaN: {}", set.contains(&f64::NAN)); // 实现依赖
    
    // 推荐: 浮点数作为键时，使用 ordered_float 等库
}
```

### 2.4 NaN 在 const fn 中的行为

```rust
// ✅ const fn 中可以生成和检测 NaN
const fn produce_nan() -> f64 {
    0.0 / 0.0  // 编译期生成 NaN
}

const fn infinity_minus_infinity() -> f64 {
    f64::INFINITY - f64::INFINITY
}

// ❌ 但 is_nan() 在 Rust 1.90 中仍不能用于 const 上下文
// const fn check_nan(x: f64) -> bool {
//     x.is_nan()  // ❌ 编译错误
// }

// ✅ 变通方法: 使用位模式检测
const fn is_nan_const(x: f64) -> bool {
    let bits = x.to_bits();
    // NaN: 指数位全1，尾数位非0
    (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
        && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
}

const NAN_CHECK: bool = is_nan_const(f64::NAN);

fn main() {
    println!("编译期 NaN 检测: {}", NAN_CHECK); // true
}
```

---

## 3. 特殊浮点值处理

### 3.1 无穷大 (Infinity) 处理

```rust
fn infinity_operations() {
    let inf = f64::INFINITY;
    let neg_inf = f64::NEG_INFINITY;
    
    // 无穷大的算术运算
    assert_eq!(inf + 100.0, inf);           // ∞ + x = ∞
    assert_eq!(inf * 2.0, inf);             // ∞ × x = ∞ (x > 0)
    assert_eq!(inf * -2.0, neg_inf);        // ∞ × x = -∞ (x < 0)
    assert_eq!(1.0 / inf, 0.0);             // 1/∞ = 0
    
    // 未定义运算产生 NaN
    assert!((inf - inf).is_nan());          // ∞ - ∞ = NaN
    assert!((inf / inf).is_nan());          // ∞ / ∞ = NaN
    assert!((inf * 0.0).is_nan());          // ∞ × 0 = NaN
    
    // 比较语义
    assert!(inf > f64::MAX);
    assert!(neg_inf < f64::MIN);
    assert!(inf > neg_inf);
}

// const fn 中使用无穷大
const fn compute_with_infinity(x: f64) -> f64 {
    if x > 1e308 {  // 接近 f64::MAX
        f64::INFINITY
    } else {
        x * 2.0
    }
}
```

### 3.2 零值 (+0.0 vs -0.0)

```rust
fn signed_zero_semantics() {
    let pos_zero = 0.0_f64;
    let neg_zero = -0.0_f64;
    
    // IEEE 754 规定: +0.0 == -0.0
    assert_eq!(pos_zero, neg_zero);
    
    // 但位模式不同
    assert_ne!(pos_zero.to_bits(), neg_zero.to_bits());
    println!("(+0.0).to_bits(): 0x{:016X}", pos_zero.to_bits()); // 0x0000000000000000
    println!("(-0.0).to_bits(): 0x{:016X}", neg_zero.to_bits()); // 0x8000000000000000
    
    // 符号位影响某些运算
    assert_eq!(1.0 / pos_zero, f64::INFINITY);      // 1/+0 = +∞
    assert_eq!(1.0 / neg_zero, f64::NEG_INFINITY);  // 1/-0 = -∞
    
    // 某些函数保留符号
    assert_eq!(pos_zero.copysign(1.0), pos_zero);
    assert_eq!(pos_zero.copysign(-1.0), neg_zero);
}

// 检测有符号零
fn is_negative_zero(x: f64) -> bool {
    x == 0.0 && x.is_sign_negative()
}

const fn const_signed_zero_check(x: f64) -> bool {
    x.to_bits() == 0x8000_0000_0000_0000
}
```

### 3.3 次正规数 (Subnormal Numbers)

```rust
fn subnormal_numbers() {
    // f64 的最小正规数和最小次正规数
    const MIN_POSITIVE: f64 = f64::MIN_POSITIVE;  // 2^-1022 ≈ 2.225e-308
    const MIN_SUBNORMAL: f64 = 5e-324;            // 2^-1074 (最小正次正规数)
    
    println!("最小正规数: {:.3e}", MIN_POSITIVE);
    println!("最小次正规数: {:.3e}", MIN_SUBNORMAL);
    
    // 次正规数的特征: 指数位全0，尾数位非0
    let is_subnormal = |x: f64| -> bool {
        let bits = x.to_bits();
        (bits & 0x7FF0_0000_0000_0000 == 0) && (bits & 0x000F_FFFF_FFFF_FFFF != 0)
    };
    
    assert!(is_subnormal(MIN_SUBNORMAL));
    assert!(!is_subnormal(MIN_POSITIVE));
    
    // 次正规数的运算可能丧失精度
    let tiny = 1e-320;
    let result = tiny * tiny;
    println!("1e-320 * 1e-320 = {:.3e}", result); // 可能下溢为 0
}

// const fn 中处理次正规数
const fn handle_subnormal(x: f64) -> f64 {
    // 简单策略: 小于阈值的值截断为 0
    if x.abs() < f64::MIN_POSITIVE {
        0.0
    } else {
        x
    }
}
```

---

## 4. const fn 浮点操作实战

### 4.1 编译期常量计算

```rust
// 物理常数的编译期定义
pub const SPEED_OF_LIGHT: f64 = 299_792_458.0;           // m/s
pub const PLANCK_CONSTANT: f64 = 6.62607015e-34;        // J·s
pub const BOLTZMANN_CONSTANT: f64 = 1.380649e-23;       // J/K

// 编译期计算派生常数
pub const REDUCED_PLANCK: f64 = PLANCK_CONSTANT / (2.0 * 3.141592653589793);

// const fn 函数用于复杂计算
const fn kelvin_to_celsius(k: f64) -> f64 {
    k - 273.15
}

const fn energy_from_frequency(frequency: f64) -> f64 {
    PLANCK_CONSTANT * frequency
}

// 编译期配置
const ROOM_TEMPERATURE_K: f64 = 293.15;
const ROOM_TEMPERATURE_C: f64 = kelvin_to_celsius(ROOM_TEMPERATURE_K);

fn main() {
    println!("室温 (摄氏): {:.2}°C", ROOM_TEMPERATURE_C);
    
    // 编译期计算的数组
    const TEMPS: [f64; 5] = [
        kelvin_to_celsius(273.15),
        kelvin_to_celsius(293.15),
        kelvin_to_celsius(373.15),
        kelvin_to_celsius(273.15 - 40.0),
        kelvin_to_celsius(0.0),
    ];
    println!("温度数组: {:?}", TEMPS);
}
```

### 4.2 const fn 中的浮点分类

```rust
// 使用位模式实现编译期浮点分类
const fn classify_float(x: f64) -> FloatClass {
    let bits = x.to_bits();
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    let sign = bits >> 63;
    
    if exp == 0 {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosZero
            } else {
                FloatClass::NegZero
            }
        } else {
            FloatClass::Subnormal
        }
    } else if exp == 0x7FF {
        if mantissa == 0 {
            if sign == 0 {
                FloatClass::PosInfinity
            } else {
                FloatClass::NegInfinity
            }
        } else {
            FloatClass::NaN
        }
    } else {
        FloatClass::Normal
    }
}

#[derive(Debug, PartialEq)]
enum FloatClass {
    PosZero,
    NegZero,
    Normal,
    Subnormal,
    PosInfinity,
    NegInfinity,
    NaN,
}

const CLASS_TESTS: [FloatClass; 7] = [
    classify_float(0.0),
    classify_float(-0.0),
    classify_float(1.0),
    classify_float(5e-324),
    classify_float(f64::INFINITY),
    classify_float(f64::NEG_INFINITY),
    classify_float(f64::NAN),
];

fn main() {
    for (i, class) in CLASS_TESTS.iter().enumerate() {
        println!("测试 {}: {:?}", i, class);
    }
}
```

### 4.3 编译期错误检测

```rust
// 使用 const fn 在编译期检测非法配置
const fn validate_config(threshold: f64) -> f64 {
    // Rust 1.90 中 const panic 已稳定
    if threshold.is_infinite() {
        panic!("阈值不能为无穷大");
    }
    if threshold.is_nan() {
        panic!("阈值不能为 NaN");
    }
    if threshold < 0.0 {
        panic!("阈值必须为非负数");
    }
    threshold
}

// 编译期验证
const THRESHOLD: f64 = validate_config(0.001);
// const INVALID: f64 = validate_config(f64::NAN); // ❌ 编译错误: NaN

// 更高级的编译期约束
const fn safe_divide(a: f64, b: f64) -> f64 {
    if b == 0.0 {
        panic!("除数不能为零");
    }
    a / b
}

const RATIO: f64 = safe_divide(10.0, 2.0);
// const BAD: f64 = safe_divide(10.0, 0.0); // ❌ 编译错误

fn main() {
    println!("验证的阈值: {}", THRESHOLD);
    println!("安全的比率: {}", RATIO);
}
```

---

## 5. 浮点数位模式操作

### 5.1 to_bits 和 from_bits

```rust
fn bit_pattern_operations() {
    let x = 1.0_f64;
    let bits = x.to_bits();
    
    // IEEE 754 双精度格式:
    // 位 63: 符号位
    // 位 62-52: 指数 (11 位, 偏移 1023)
    // 位 51-0: 尾数 (52 位, 隐含前导 1)
    
    println!("1.0 的位模式: 0x{:016X}", bits);
    // 输出: 0x3FF0000000000000
    //       ^^^^ ^^^^
    //       符号(0) 指数(01111111111=1023) 尾数(全0)
    //       实际值: (-1)^0 × 1.0 × 2^(1023-1023) = 1.0
    
    // 位操作
    let sign = bits >> 63;
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    
    println!("符号: {}, 指数: {}, 尾数: 0x{:013X}", sign, exp, mantissa);
    
    // 重新构造
    let reconstructed = f64::from_bits(bits);
    assert_eq!(x, reconstructed);
}

// const 上下文中的位操作
const fn extract_exponent(x: f64) -> u64 {
    (x.to_bits() >> 52) & 0x7FF
}

const fn extract_mantissa(x: f64) -> u64 {
    x.to_bits() & 0x000F_FFFF_FFFF_FFFF
}

const PI_EXP: u64 = extract_exponent(3.141592653589793);
const PI_MANTISSA: u64 = extract_mantissa(3.141592653589793);

fn main() {
    println!("π 的指数: {} (实际指数: {})", PI_EXP, PI_EXP as i64 - 1023);
    println!("π 的尾数: 0x{:013X}", PI_MANTISSA);
}
```

### 5.2 NaN payload 访问

```rust
// NaN 的尾数可以携带"payload"信息
fn nan_payload() {
    // 创建带 payload 的 NaN
    fn create_nan_with_payload(payload: u64) -> f64 {
        // 确保 payload 小于 2^51 (保留最高位为1表示静默 NaN)
        let payload = payload & 0x0007_FFFF_FFFF_FFFF;
        let nan_bits = 0x7FF8_0000_0000_0000 | payload;
        f64::from_bits(nan_bits)
    }
    
    // 提取 payload
    fn extract_nan_payload(nan: f64) -> Option<u64> {
        if nan.is_nan() {
            Some(nan.to_bits() & 0x0007_FFFF_FFFF_FFFF)
        } else {
            None
        }
    }
    
    let error_code_1 = create_nan_with_payload(42);
    let error_code_2 = create_nan_with_payload(100);
    
    println!("NaN1 payload: {:?}", extract_nan_payload(error_code_1));
    println!("NaN2 payload: {:?}", extract_nan_payload(error_code_2));
    
    // 注意: Rust 不保证 NaN payload 在运算中保留
    let result = error_code_1 + 1.0;
    println!("运算后 payload: {:?}", extract_nan_payload(result));
}
```

### 5.3 位模式安全性

```rust
// from_bits 不检查输入合法性，可能创建非规范值
fn bit_pattern_safety() {
    // ✅ 合法的位模式
    let valid = f64::from_bits(0x3FF0_0000_0000_0000); // 1.0
    assert_eq!(valid, 1.0);
    
    // ⚠️ 信号 NaN (sNaN) 在某些平台可能触发异常
    let signaling_nan = f64::from_bits(0x7FF0_0000_0000_0001);
    println!("sNaN is_nan: {}", signaling_nan.is_nan()); // true
    
    // ✅ 推荐: 使用静默 NaN
    let quiet_nan = f64::from_bits(0x7FF8_0000_0000_0001);
    
    // 位模式往返可能规范化
    let original_bits = 0x7FF0_0000_0000_0001; // sNaN
    let value = f64::from_bits(original_bits);
    let round_trip_bits = value.to_bits();
    
    // 某些平台会将 sNaN 转换为 qNaN
    if original_bits != round_trip_bits {
        println!("位模式被规范化: 0x{:016X} -> 0x{:016X}", 
                 original_bits, round_trip_bits);
    }
}

// const 上下文中的安全位操作
const fn safe_from_bits(bits: u64) -> f64 {
    // 检测 sNaN 并转换为 qNaN
    let exp = (bits >> 52) & 0x7FF;
    let mantissa = bits & 0x000F_FFFF_FFFF_FFFF;
    
    if exp == 0x7FF && mantissa != 0 && (mantissa & 0x0008_0000_0000_0000) == 0 {
        // 这是 sNaN，转换为 qNaN
        f64::from_bits(bits | 0x0008_0000_0000_0000)
    } else {
        f64::from_bits(bits)
    }
}
```

---

## 6. 实际应用场景

### 6.1 数值计算库中的 NaN 处理

```rust
// 统计函数中的 NaN 传播
pub fn mean_with_nan_handling(data: &[f64]) -> f64 {
    if data.is_empty() {
        return f64::NAN;
    }
    
    let mut sum = 0.0;
    let mut count = 0;
    
    for &value in data {
        if !value.is_nan() {
            sum += value;
            count += 1;
        }
    }
    
    if count == 0 {
        f64::NAN
    } else {
        sum / count as f64
    }
}

// 数值稳定的求和
pub fn kahan_summation(data: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut compensation = 0.0;
    
    for &value in data {
        if value.is_nan() {
            return f64::NAN;
        }
        
        let y = value - compensation;
        let t = sum + y;
        compensation = (t - sum) - y;
        sum = t;
    }
    
    sum
}

fn main() {
    let data = vec![1.0, 2.0, f64::NAN, 4.0];
    println!("均值 (忽略 NaN): {}", mean_with_nan_handling(&data));
    
    let clean_data = vec![1e-16, 1.0, 1e-16];
    println!("Kahan 求和: {}", kahan_summation(&clean_data));
}
```

### 6.2 编译期物理常数定义

```rust
// 编译期计算的物理常数表
pub mod physics {
    // 基本常数
    pub const C: f64 = 299_792_458.0;                    // 光速 (m/s)
    pub const H: f64 = 6.62607015e-34;                   // 普朗克常数 (J·s)
    pub const K_B: f64 = 1.380649e-23;                   // 玻尔兹曼常数 (J/K)
    pub const E_0: f64 = 8.8541878128e-12;               // 真空介电常数 (F/m)
    pub const MU_0: f64 = 1.25663706212e-6;              // 真空磁导率 (H/m)
    
    // 派生常数 (编译期计算)
    pub const H_BAR: f64 = H / (2.0 * 3.141592653589793);         // 约化普朗克常数
    pub const IMPEDANCE_0: f64 = 376.730313668;                   // 真空阻抗 (Ω)
    
    // 单位转换
    pub const EV_TO_JOULE: f64 = 1.602176634e-19;
    pub const JOULE_TO_EV: f64 = 1.0 / EV_TO_JOULE;
    
    // 编译期函数
    pub const fn wavelength_to_frequency(lambda: f64) -> f64 {
        C / lambda
    }
    
    pub const fn energy_to_wavelength(energy_joules: f64) -> f64 {
        (H * C) / energy_joules
    }
}

const VISIBLE_LIGHT_MIN_FREQ: f64 = physics::wavelength_to_frequency(700e-9);
const VISIBLE_LIGHT_MAX_FREQ: f64 = physics::wavelength_to_frequency(400e-9);

fn main() {
    println!("可见光频率范围: {:.3e} - {:.3e} Hz", 
             VISIBLE_LIGHT_MIN_FREQ, VISIBLE_LIGHT_MAX_FREQ);
}
```

### 6.3 嵌入式系统中的浮点优化

```rust
// 编译期决定使用软浮点还是硬浮点
#[cfg(target_feature = "fpu")]
const USE_HARDWARE_FLOAT: bool = true;
#[cfg(not(target_feature = "fpu"))]
const USE_HARDWARE_FLOAT: bool = false;

// 编译期配置精度权衡
const HIGH_PRECISION: bool = cfg!(feature = "high_precision");

const fn select_epsilon() -> f32 {
    if HIGH_PRECISION {
        1e-7
    } else {
        1e-5  // 嵌入式系统可接受的精度
    }
}

const EPSILON: f32 = select_epsilon();

// 定点数模拟浮点数 (编译期决策)
const fn fixed_point_mul(a: i32, b: i32, scale: i32) -> i32 {
    ((a as i64 * b as i64) / scale as i64) as i32
}

const SCALE: i32 = 1000;
const RESULT: i32 = fixed_point_mul(1500, 2000, SCALE);

fn main() {
    println!("使用硬件浮点: {}", USE_HARDWARE_FLOAT);
    println!("精度阈值: {}", EPSILON);
    println!("定点运算: 1.5 * 2.0 = {}", RESULT as f32 / SCALE as f32);
}
```

---

## 7. 性能与陷阱

### 7.1 NaN 检测的性能考虑

```rust
use std::time::Instant;

fn benchmark_nan_checks(data: &[f64], iterations: usize) {
    // 方法 1: is_nan()
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x.is_nan();
        }
    }
    let method1_time = start.elapsed();
    
    // 方法 2: 自比较
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let _ = x != x;
        }
    }
    let method2_time = start.elapsed();
    
    // 方法 3: 位模式检查
    let start = Instant::now();
    for _ in 0..iterations {
        for &x in data {
            let bits = x.to_bits();
            let _ = (bits & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
                && (bits & 0x000F_FFFF_FFFF_FFFF != 0);
        }
    }
    let method3_time = start.elapsed();
    
    println!("NaN 检测性能 ({}次迭代):", iterations);
    println!("  is_nan():      {:?}", method1_time);
    println!("  x != x:        {:?}", method2_time);
    println!("  位模式检查:     {:?}", method3_time);
}

fn main() {
    let data: Vec<f64> = (0..1000).map(|i| i as f64 * 0.1).collect();
    benchmark_nan_checks(&data, 10000);
}
```

**性能建议**：

- ✅ `is_nan()` 通常是最快的方法（编译器优化）
- ✅ `x != x` 语义清晰，性能接近
- ❌ 位模式检查通常较慢，除非需要精确控制

### 7.2 常见陷阱与避免方法

```rust
// 陷阱 1: 不当的 NaN 比较
fn pitfall_nan_comparison() {
    let nan = f64::NAN;
    
    // ❌ 错误: 永远不会执行
    if nan == f64::NAN {
        println!("This never prints");
    }
    
    // ✅ 正确
    if nan.is_nan() {
        println!("检测到 NaN");
    }
}

// 陷阱 2: 浮点数作为 HashMap 键
fn pitfall_hash_key() {
    use std::collections::HashMap;
    
    let mut map = HashMap::new();
    map.insert(1.0, "one");
    
    // ⚠️ 浮点数精度问题可能导致键查找失败
    let key = 0.1 + 0.2; // 0.30000000000000004
    map.insert(key, "almost 0.3");
    
    // 可能找不到
    println!("查找 0.3: {:?}", map.get(&0.3));
    
    // ✅ 推荐: 使用整数或 ordered_float::OrderedFloat
}

// 陷阱 3: 累积误差
fn pitfall_accumulation() {
    // ❌ 朴素求和
    let mut sum = 0.0_f64;
    for _ in 0..1_000_000 {
        sum += 1e-10;
    }
    println!("朴素求和: {:.15}", sum);
    // 期望: 0.0001, 实际: 误差较大
    
    // ✅ Kahan 补偿求和
    let mut sum = 0.0;
    let mut c = 0.0;
    for _ in 0..1_000_000 {
        let y = 1e-10 - c;
        let t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    println!("Kahan 求和: {:.15}", sum);
}

// 陷阱 4: 除零检查不足
fn pitfall_division() {
    let x = 10.0;
    let y = 0.0;
    
    // ⚠️ 不会 panic，但产生 Inf
    let result = x / y;
    println!("10.0 / 0.0 = {}", result); // Inf
    
    // ✅ 显式检查
    if y == 0.0 {
        eprintln!("除数为零");
    } else {
        println!("结果: {}", x / y);
    }
    
    // ✅ 结果验证
    if result.is_finite() {
        println!("有限结果: {}", result);
    } else {
        eprintln!("结果非有限: {}", result);
    }
}
```

---

## 8. 跨版本兼容性说明

| 特性                          | Rust 1.82 | Rust 1.90 | 说明                                  |
|-------------------------------|-----------|-----------|---------------------------------------|
| `f32/f64` 基本运算 const 支持 | 稳定      | 稳定      | +, -, *, /, - (取负)                  |
| `abs()` const 支持            | 稳定      | 稳定      | 绝对值                                |
| `to_bits()/from_bits()` const | 稳定      | 稳定      | 位模式转换                            |
| `is_nan()/is_infinite()` const| 不稳定    | **稳定**  | **Rust 1.84+ 稳定化**                 |
| `copysign()` const            | 不稳定    | **稳定**  | **Rust 1.85+ 稳定化**                 |
| `min()/max()` const           | 不稳定    | 部分稳定  | 需要 feature flag (Rust 1.90)         |
| `sqrt()/sin()/cos()` const    | 不稳定    | 不稳定    | 超越函数仍不支持                      |

**迁移建议**：

- 对于 Rust 1.90，可安全使用基本运算和位模式操作
- 浮点分类函数 (`is_nan()`, `is_finite()`) 可通过位模式模拟
- 超越函数需依赖运行时计算或第三方 const 数学库

---

## 9. 相关资源

### 内部文档

- [基础类型指南](../tier_02_guides/01_基础类型指南.md) - 浮点数基础
- [类型转换参考](01_类型转换参考.md) - 浮点数类型转换规则
- [性能优化参考](05_性能优化参考.md) - 浮点数性能优化

### 外部资源

- **IEEE 754 标准**: <https://ieeexplore.ieee.org/document/8766229>
- **Rust RFC 3514 (const float ops)**: <https://github.com/rust-lang/rfcs/pull/3514>
- **Float Toy (可视化工具)**: <https://evanw.github.io/float-toy/>
- **What Every Computer Scientist Should Know About Floating-Point Arithmetic**: <https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html>

### 相关 Crate

- `ordered-float`: 实现 `Ord` 和 `Hash` 的浮点包装器
- `approx`: 浮点数近似比较
- `num-traits`: 数值类型 trait 抽象
- `libm`: 纯 Rust 数学函数库 (支持 const)

---

**总结**：Rust 1.90 的浮点数 const fn 能力为编译期计算和配置提供了强大支持。理解 NaN 语义、特殊值处理和位模式操作，能够编写出更安全、更高效的数值计算代码。在使用 const fn 时，要注意当前版本的限制，并根据需要采用位操作等变通方法。

**下一步**：建议阅读 [高级泛型模式](../tier_04_advanced/02_高级泛型模式.md) 以了解泛型常量表达式（Generic Const Exprs），它与 const fn 结合能实现更强大的编译期编程。
