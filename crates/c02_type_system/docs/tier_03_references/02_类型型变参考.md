# 3.2 Rust 类型系统 - 类型型变参考

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: 类型型变（Variance）完整参考  
> **适用对象**: 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.5 生命周期指南](../tier_02_guides/05_生命周期指南.md)  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [3.2 Rust 类型系统 - 类型型变参考](#32-rust-类型系统---类型型变参考)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 型变基础](#1-型变基础)
    - [1.1 什么是型变](#11-什么是型变)
    - [1.2 子类型关系](#12-子类型关系)
    - [1.3 型变的三种类型](#13-型变的三种类型)
  - [2. 协变 (Covariance)](#2-协变-covariance)
    - [2.1 定义](#21-定义)
    - [2.2 示例](#22-示例)
    - [2.3 常见协变类型](#23-常见协变类型)
  - [3. 逆变 (Contravariance)](#3-逆变-contravariance)
    - [3.1 定义](#31-定义)
    - [3.2 函数参数](#32-函数参数)
    - [3.3 实际应用](#33-实际应用)
  - [4. 不变 (Invariance)](#4-不变-invariance)
    - [4.1 定义](#41-定义)
    - [4.2 可变引用](#42-可变引用)
    - [4.3 为什么需要不变](#43-为什么需要不变)
  - [5. 生命周期的型变](#5-生命周期的型变)
    - [5.1 生命周期子类型](#51-生命周期子类型)
    - [5.2 引用的型变](#52-引用的型变)
    - [5.3 复合类型的型变](#53-复合类型的型变)
  - [6. PhantomData](#6-phantomdata)
    - [6.1 型变标记](#61-型变标记)
    - [6.2 Drop Check](#62-drop-check)
    - [6.3 实际应用](#63-实际应用)
  - [7. 型变规则表](#7-型变规则表)
  - [8. 实战案例](#8-实战案例)
    - [案例 1: 集合的型变](#案例-1-集合的型变)
    - [案例 2: 智能指针](#案例-2-智能指针)
    - [案例 3: 迭代器](#案例-3-迭代器)
  - [9. 常见陷阱](#9-常见陷阱)
  - [10. 总结](#10-总结)
  - [11. 参考资源](#11-参考资源)

---

## 🎯 概述

**型变** (Variance) 描述了泛型类型参数的子类型关系如何影响包含它们的复合类型的子类型关系。

**核心概念**:

- 🔄 **协变**: 保持子类型关系
- ↔️ **逆变**: 反转子类型关系  
- 🚫 **不变**: 不允许子类型替换

---

## 1. 型变基础

### 1.1 什么是型变

型变决定了：**当 `A` 是 `B` 的子类型时，`F<A>` 和 `F<B>` 是什么关系？**

```rust
// 如果 'static 是 'a 的子类型
// 那么：
// - &'static T 是 &'a T 的子类型吗？ (协变)
// - &'static mut T 是 &'a mut T 的子类型吗？ (不变)
```

### 1.2 子类型关系

**生命周期子类型**:

```rust
fn main() {
    // 'static 是所有生命周期的子类型
    let s: &'static str = "hello";
    let _: &str = s;  // ✅ 'static <: 'a
    
    // 更长的生命周期是更短生命周期的子类型
    let x = String::from("data");
    {
        let y = &x;  // 'long
        {
            let _z: &str = y;  // 'short, 'long <: 'short
        }
    }
}
```

### 1.3 型变的三种类型

| 型变类型 | 符号 | 含义 | 示例 |
|---------|------|------|------|
| **协变** | `F<A> <: F<B>` if `A <: B` | 保持关系 | `&'a T` |
| **逆变** | `F<B> <: F<A>` if `A <: B` | 反转关系 | `fn(T)` |
| **不变** | 无关系 | 不允许替换 | `&'a mut T` |

---

## 2. 协变 (Covariance)

### 2.1 定义

**协变**：如果 `A <: B`，则 `F<A> <: F<B>`。

```rust
// 'static <: 'a
// 所以 &'static str <: &'a str (协变)
fn foo<'a>(_: &'a str) {}

fn main() {
    let s: &'static str = "hello";
    foo(s);  // ✅ 可以传递更长的生命周期
}
```

### 2.2 示例

**不可变引用是协变的**:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let s1: &'static str = "hello";
    let s2 = String::from("world");
    
    // 'static <: 'a, 所以可以混用
    let result = longest(s1, &s2);
    println!("{}", result);
}
```

### 2.3 常见协变类型

```rust
use std::rc::Rc;
use std::sync::Arc;

fn main() {
    // Box<T> 在 T 上协变
    let b: Box<&'static str> = Box::new("hello");
    let _: Box<&str> = b;  // ✅
    
    // Vec<T> 在 T 上协变
    let v: Vec<&'static str> = vec!["a", "b"];
    let _: Vec<&str> = v;  // ✅
    
    // Rc<T> 在 T 上协变
    let rc: Rc<&'static str> = Rc::new("data");
    let _: Rc<&str> = rc;  // ✅
}
```

---

## 3. 逆变 (Contravariance)

### 3.1 定义

**逆变**：如果 `A <: B`，则 `F<B> <: F<A>`（关系反转）。

### 3.2 函数参数

**函数参数是逆变的**:

```rust
// 'a <: 'static
// 所以 fn(&'static str) <: fn(&'a str) (逆变)

fn apply<F>(f: F, value: &'static str)
where
    F: Fn(&str),  // 接受任意生命周期
{
    f(value);
}

fn main() {
    apply(|s| println!("{}", s), "hello");
}
```

### 3.3 实际应用

**回调函数**:

```rust
trait Callback {
    fn call(&self, data: &str);
}

struct Logger;

impl Callback for Logger {
    fn call(&self, data: &str) {
        println!("Log: {}", data);
    }
}

fn process<'a, C: Callback>(callback: &C, data: &'a str) {
    callback.call(data);
}

fn main() {
    let logger = Logger;
    let data = String::from("message");
    process(&logger, &data);
}
```

---

## 4. 不变 (Invariance)

### 4.1 定义

**不变**：即使 `A <: B`，`F<A>` 和 `F<B>` 也没有子类型关系。

### 4.2 可变引用

**`&mut T` 是不变的**:

```rust
fn main() {
    let mut s: &'static str = "hello";
    
    // ❌ 编译错误：&mut 是不变的
    // let r: &mut &str = &mut s;
    
    // 如果允许，可能导致悬垂引用
}
```

**为什么不变是必要的**:

```rust
// 假设 &mut 是协变的（实际上不是）
fn hypothetical_bad() {
    let mut x: &'static str = "hello";
    let mut y: &str;
    
    // 如果这样可以（实际不行）
    // let r: &mut &str = &mut x;
    // *r = &String::from("temporary");
    // 现在 x 指向已被销毁的 String！
}
```

### 4.3 为什么需要不变

**保证内存安全**:

```rust
fn extend_lifetime<'a>(r: &mut &'a str, s: &'a str) {
    *r = s;
}

fn main() {
    let mut long: &'static str = "long";
    {
        let short = String::from("short");
        // extend_lifetime(&mut long, &short);  // ❌ 编译错误
        // 如果允许，long 会指向已释放的内存
    }
    // println!("{}", long);  // 悬垂引用！
}
```

---

## 5. 生命周期的型变

### 5.1 生命周期子类型

```rust
// 'a: 'b 表示 'a 至少和 'b 一样长
// 即 'a 是 'b 的子类型
fn choose<'a: 'b, 'b>(first: &'a str, _second: &'b str) -> &'b str {
    first
}

fn main() {
    let s1: &'static str = "first";
    let s2 = String::from("second");
    let result = choose(s1, &s2);
    println!("{}", result);
}
```

### 5.2 引用的型变

```rust
use std::marker::PhantomData;

// &'a T 在 'a 和 T 上都是协变的
struct Ref<'a, T: 'a> {
    reference: &'a T,
}

// &'a mut T 在 'a 上协变，在 T 上不变
struct RefMut<'a, T: 'a> {
    reference: &'a mut T,
}

fn main() {
    let x = 42;
    let r = Ref { reference: &x };
    println!("Value: {}", r.reference);
}
```

### 5.3 复合类型的型变

```rust
// 结构体的型变由其字段决定
struct Container<'a, T> {
    data: &'a T,  // 协变
}

struct MutContainer<'a, T> {
    data: &'a mut T,  // 在 'a 上协变，在 T 上不变
}

fn main() {
    let x = String::from("data");
    let c = Container { data: &x };
    println!("{}", c.data);
}
```

---

## 6. PhantomData

### 6.1 型变标记

**显式标记型变**:

```rust
use std::marker::PhantomData;

// 不持有 T，但表现得像持有 T
struct MyType<T> {
    _marker: PhantomData<T>,
}

// 协变标记
struct CovariantType<T> {
    _marker: PhantomData<fn() -> T>,
}

// 逆变标记
struct ContravariantType<T> {
    _marker: PhantomData<fn(T)>,
}

// 不变标记
struct InvariantType<T> {
    _marker: PhantomData<fn(T) -> T>,
}

fn main() {
    let _: MyType<i32> = MyType {
        _marker: PhantomData,
    };
}
```

### 6.2 Drop Check

**Drop Check 和型变**:

```rust
use std::marker::PhantomData;

struct Inspector<'a, T: 'a> {
    _data: PhantomData<&'a T>,
}

impl<'a, T> Drop for Inspector<'a, T> {
    fn drop(&mut self) {
        println!("Dropping inspector");
    }
}

fn main() {
    let _inspector = Inspector::<i32> {
        _data: PhantomData,
    };
}
```

### 6.3 实际应用

**所有权标记**:

```rust
use std::marker::PhantomData;

struct Owned<T> {
    _marker: PhantomData<T>,
}

struct Borrowed<'a, T: 'a> {
    _marker: PhantomData<&'a T>,
}

fn main() {
    let _owned: Owned<String> = Owned {
        _marker: PhantomData,
    };
}
```

---

## 7. 型变规则表

**Rust 类型的型变规则**:

| 类型 | 'a | T |
|------|----|----|
| `&'a T` | 协变 | 协变 |
| `&'a mut T` | 协变 | **不变** |
| `*const T` | - | 协变 |
| `*mut T` | - | **不变** |
| `Box<T>` | - | 协变 |
| `Vec<T>` | - | 协变 |
| `Rc<T>` | - | 协变 |
| `Arc<T>` | - | 协变 |
| `Cell<T>` | - | **不变** |
| `RefCell<T>` | - | **不变** |
| `UnsafeCell<T>` | - | **不变** |
| `fn(T) -> U` | - | **逆变**(T), 协变(U) |

---

## 8. 实战案例

### 案例 1: 集合的型变

```rust
fn main() {
    // Vec 在 T 上协变
    let static_vec: Vec<&'static str> = vec!["a", "b", "c"];
    
    fn print_vec(v: Vec<&str>) {
        for item in v {
            println!("{}", item);
        }
    }
    
    // 可以传递 Vec<&'static str> 到期望 Vec<&str> 的地方
    print_vec(static_vec);
}
```

### 案例 2: 智能指针

```rust
use std::rc::Rc;

struct Node<'a> {
    value: &'a str,
}

fn main() {
    let static_node = Node {
        value: "static data",
    };
    
    // Rc 在 T 上协变
    let rc_static: Rc<Node<'static>> = Rc::new(static_node);
    let _rc_any: Rc<Node> = rc_static.clone();
}
```

### 案例 3: 迭代器

```rust
struct Iter<'a, T> {
    slice: &'a [T],
    index: usize,
}

impl<'a, T> Iter<'a, T> {
    fn new(slice: &'a [T]) -> Self {
        Iter { slice, index: 0 }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.slice.len() {
            let item = &self.slice[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let iter = Iter::new(&data);
    
    for value in iter {
        println!("{}", value);
    }
}
```

---

## 9. 常见陷阱

**陷阱 1: 误解可变引用的型变**:

```rust
// ❌ 错误理解：认为 &mut 是协变的
fn bad_example() {
    let mut s: &'static str = "hello";
    // let r: &mut &str = &mut s;  // 编译错误！
    // 如果允许，可能导致悬垂引用
}
```

**陷阱 2: PhantomData 使用不当**:

```rust
use std::marker::PhantomData;

// ❌ 错误：使用了错误的型变标记
struct WrongVariance<T> {
    _marker: PhantomData<T>,  // 应该使用 PhantomData<*const T>
}
```

**陷阱 3: Drop 和型变冲突**:

```rust
// Drop 实现可能影响型变规则
struct Wrapper<'a, T: 'a> {
    data: &'a T,
}

// Drop 会影响 borrow checker 的推断
impl<'a, T> Drop for Wrapper<'a, T> {
    fn drop(&mut self) {
        println!("Dropping wrapper");
    }
}

fn main() {
    let x = 42;
    let _w = Wrapper { data: &x };
}
```

---

## 10. 总结

**核心要点**:

1. **型变类型**
   - 协变：保持子类型关系
   - 逆变：反转子类型关系
   - 不变：不允许替换

2. **生命周期**
   - `&'a T` 在两者上协变
   - `&'a mut T` 在 `'a` 上协变，在 `T` 上不变

3. **安全性**
   - 不变保证内存安全
   - 防止悬垂引用

4. **PhantomData**
   - 标记型变行为
   - 影响 Drop Check

**记忆法则**:

- ✅ 只读 → 协变
- ⚠️ 可写 → 不变
- 🔄 函数参数 → 逆变

---

## 11. 参考资源

**官方文档**:

- [Rustonomicon - Subtyping and Variance](https://doc.rust-lang.org/nomicon/subtyping.html)
- [Rust Reference - Variance](https://doc.rust-lang.org/reference/subtyping.html)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.5 生命周期指南](../tier_02_guides/05_生命周期指南.md)
- [3.1 类型转换参考](./01_类型转换参考.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 3 - 参考层

---

**🎉 完成类型型变参考学习！** 🦀
