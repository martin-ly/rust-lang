# 3.2 Rust 类型系统 - 类型型变参考

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: 类型型变（Variance）完整参考  
> **适用对象**: 高级开发者  
> **前置知识**: [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md), [2.5 生命周期指南](../tier_02_guides/05_生命周期指南.md)  
> **最后更新**: 2025-10-22

---


## 📊 目录

- [3.2 Rust 类型系统 - 类型型变参考](#32-rust-类型系统---类型型变参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 概述](#-概述)
  - [1. 型变基础](#1-型变基础)
    - [1.1 什么是型变](#11-什么是型变)
    - [1.2 子类型关系](#12-子类型关系)
    - [1.3 型变的三种类型](#13-型变的三种类型)
    - [1.4 型变的形式化定义](#14-型变的形式化定义)
    - [1.5 型变规则的形式化证明](#15-型变规则的形式化证明)
    - [1.6 Rust型变系统的设计权衡](#16-rust型变系统的设计权衡)
    - [1.7 型变与内存安全的关系](#17-型变与内存安全的关系)
  - [2. 协变 (Covariance)](#2-协变-covariance)
    - [2.1 定义](#21-定义)
    - [2.2 示例](#22-示例)
    - [2.3 常见协变类型](#23-常见协变类型)
    - [2.4 `Vec<T>` 协变的深度分析](#24-vect-协变的深度分析)
    - [2.5 `Box<T>` 和智能指针的协变](#25-boxt-和智能指针的协变)
    - [2.6 `Option<T>` 和 `Result<T, E>` 的协变](#26-optiont-和-resultt-e-的协变)
  - [3. 逆变 (Contravariance)](#3-逆变-contravariance)
    - [3.1 定义](#31-定义)
    - [3.2 函数参数](#32-函数参数)
    - [3.3 实际应用](#33-实际应用)
  - [4. 不变 (Invariance)](#4-不变-invariance)
    - [4.1 定义](#41-定义)
    - [4.2 可变引用](#42-可变引用)
    - [4.3 为什么需要不变](#43-为什么需要不变)
    - [4.4 `Cell<T>` 和 `RefCell<T>` 的不变性](#44-cellt-和-refcellt-的不变性)
    - [4.5 `UnsafeCell<T>` 的不变性](#45-unsafecellt-的不变性)
    - [4.6 不变性的实际影响](#46-不变性的实际影响)
  - [5. 生命周期的型变](#5-生命周期的型变)
    - [5.1 生命周期子类型](#51-生命周期子类型)
    - [5.2 引用的型变](#52-引用的型变)
    - [5.3 复合类型的型变](#53-复合类型的型变)
    - [5.4 生命周期型变的实际案例](#54-生命周期型变的实际案例)
    - [5.5 生命周期型变的常见错误](#55-生命周期型变的常见错误)
    - [5.6 生命周期型变与泛型的组合](#56-生命周期型变与泛型的组合)
  - [6. PhantomData](#6-phantomdata)
    - [6.1 型变标记](#61-型变标记)
    - [6.2 Drop Check](#62-drop-check)
    - [6.3 实际应用](#63-实际应用)
  - [7. 型变规则表](#7-型变规则表)
  - [8. 实战案例](#8-实战案例)
    - [案例 1: 集合的型变](#案例-1-集合的型变)
    - [案例 2: 智能指针](#案例-2-智能指针)
    - [案例 3: 迭代器](#案例-3-迭代器)
  - [9. 常见陷阱](#9-常见陷阱)
    - [9.1 误解可变引用的型变](#91-误解可变引用的型变)
    - [9.2 PhantomData 使用不当](#92-phantomdata-使用不当)
    - [9.3 Drop 和型变冲突](#93-drop-和型变冲突)
    - [9.4 生命周期型变的常见错误](#94-生命周期型变的常见错误)
    - [9.5 Cell 和 RefCell 的型变陷阱](#95-cell-和-refcell-的型变陷阱)
    - [9.6 调试型变问题的技巧](#96-调试型变问题的技巧)
  - [10. 总结](#10-总结)
  - [11. 参考资源](#11-参考资源)


## 📋 目录

- [3.2 Rust 类型系统 - 类型型变参考](#32-rust-类型系统---类型型变参考)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 概述](#-概述)
  - [1. 型变基础](#1-型变基础)
    - [1.1 什么是型变](#11-什么是型变)
    - [1.2 子类型关系](#12-子类型关系)
    - [1.3 型变的三种类型](#13-型变的三种类型)
    - [1.4 型变的形式化定义](#14-型变的形式化定义)
    - [1.5 型变规则的形式化证明](#15-型变规则的形式化证明)
    - [1.6 Rust型变系统的设计权衡](#16-rust型变系统的设计权衡)
    - [1.7 型变与内存安全的关系](#17-型变与内存安全的关系)
  - [2. 协变 (Covariance)](#2-协变-covariance)
    - [2.1 定义](#21-定义)
    - [2.2 示例](#22-示例)
    - [2.3 常见协变类型](#23-常见协变类型)
    - [2.4 `Vec<T>` 协变的深度分析](#24-vect-协变的深度分析)
    - [2.5 `Box<T>` 和智能指针的协变](#25-boxt-和智能指针的协变)
    - [2.6 `Option<T>` 和 `Result<T, E>` 的协变](#26-optiont-和-resultt-e-的协变)
  - [3. 逆变 (Contravariance)](#3-逆变-contravariance)
    - [3.1 定义](#31-定义)
    - [3.2 函数参数](#32-函数参数)
    - [3.3 实际应用](#33-实际应用)
  - [4. 不变 (Invariance)](#4-不变-invariance)
    - [4.1 定义](#41-定义)
    - [4.2 可变引用](#42-可变引用)
    - [4.3 为什么需要不变](#43-为什么需要不变)
    - [4.4 `Cell<T>` 和 `RefCell<T>` 的不变性](#44-cellt-和-refcellt-的不变性)
    - [4.5 `UnsafeCell<T>` 的不变性](#45-unsafecellt-的不变性)
    - [4.6 不变性的实际影响](#46-不变性的实际影响)
  - [5. 生命周期的型变](#5-生命周期的型变)
    - [5.1 生命周期子类型](#51-生命周期子类型)
    - [5.2 引用的型变](#52-引用的型变)
    - [5.3 复合类型的型变](#53-复合类型的型变)
    - [5.4 生命周期型变的实际案例](#54-生命周期型变的实际案例)
    - [5.5 生命周期型变的常见错误](#55-生命周期型变的常见错误)
    - [5.6 生命周期型变与泛型的组合](#56-生命周期型变与泛型的组合)
  - [6. PhantomData](#6-phantomdata)
    - [6.1 型变标记](#61-型变标记)
    - [6.2 Drop Check](#62-drop-check)
    - [6.3 实际应用](#63-实际应用)
  - [7. 型变规则表](#7-型变规则表)
  - [8. 实战案例](#8-实战案例)
    - [案例 1: 集合的型变](#案例-1-集合的型变)
    - [案例 2: 智能指针](#案例-2-智能指针)
    - [案例 3: 迭代器](#案例-3-迭代器)
  - [9. 常见陷阱](#9-常见陷阱)
    - [9.1 误解可变引用的型变](#91-误解可变引用的型变)
    - [9.2 PhantomData 使用不当](#92-phantomdata-使用不当)
    - [9.3 Drop 和型变冲突](#93-drop-和型变冲突)
    - [9.4 生命周期型变的常见错误](#94-生命周期型变的常见错误)
    - [9.5 Cell 和 RefCell 的型变陷阱](#95-cell-和-refcell-的型变陷阱)
    - [9.6 调试型变问题的技巧](#96-调试型变问题的技巧)
  - [10. 总结](#10-总结)
  - [11. 参考资源](#11-参考资源)

---

## 🎯 概述

**型变** (Variance) 描述了泛型类型参数的子类型关系如何影响包含它们的复合类型的子类型关系。

**核心概念**:

- 🔄 **协变**: 保持子类型关系
- ↔️ **逆变**: 反转子类型关系  
- 🚫 **不变**: 不允许子类型替换

---

## 1. 型变基础

### 1.1 什么是型变

型变决定了：**当 `A` 是 `B` 的子类型时，`F<A>` 和 `F<B>` 是什么关系？**

```rust
// 如果 'static 是 'a 的子类型
// 那么：
// - &'static T 是 &'a T 的子类型吗？ (协变)
// - &'static mut T 是 &'a mut T 的子类型吗？ (不变)
```

### 1.2 子类型关系

**生命周期子类型**:

```rust
fn main() {
    // 'static 是所有生命周期的子类型
    let s: &'static str = "hello";
    let _: &str = s;  // ✅ 'static <: 'a
    
    // 更长的生命周期是更短生命周期的子类型
    let x = String::from("data");
    {
        let y = &x;  // 'long
        {
            let _z: &str = y;  // 'short, 'long <: 'short
        }
    }
}
```

### 1.3 型变的三种类型

| 型变类型 | 符号 | 含义 | 示例 |
|---------|------|------|------|
| **协变** | `F<A> <: F<B>` if `A <: B` | 保持关系 | `&'a T` |
| **逆变** | `F<B> <: F<A>` if `A <: B` | 反转关系 | `fn(T)` |
| **不变** | 无关系 | 不允许替换 | `&'a mut T` |

### 1.4 型变的形式化定义

**协变的数学定义**:

```text
给定类型构造器 F 和类型 A, B:

F 在其类型参数上是协变的，当且仅当：
∀ A, B. (A <: B) ⟹ (F<A> <: F<B>)

例如：
- 'static <: 'a
- 因此 &'static T <: &'a T (协变)
```

**逆变的数学定义**:

```text
F 在其类型参数上是逆变的，当且仅当：
∀ A, B. (A <: B) ⟹ (F<B> <: F<A>)

例如：
- 'a <: 'static
- 因此 fn(&'static T) <: fn(&'a T) (逆变)
```

**不变的数学定义**:

```text
F 在其类型参数上是不变的，当且仅当：
∀ A, B. (A <: B) ⟹ (F<A> 和 F<B> 无子类型关系)

例如：
- 'a <: 'static
- 但 &'a mut T 和 &'static mut T 无法互相转换
```

### 1.5 型变规则的形式化证明

**定理 1: 不可变引用的协变性是安全的**:

```text
Theorem: &'a T 在 'a 和 T 上都是协变的

Proof (关于 'a):
1. 假设 'a: 'b (即 'a ≥ 'b, 'a 至少和 'b 一样长)
2. 如果 x: &'a T, 则 x 指向的数据在 'a 内有效
3. 因为 'a ≥ 'b, 所以 x 指向的数据在 'b 内也有效
4. 因此 x 可以安全地用作 &'b T
5. 即 &'a T <: &'b T ✓

Proof (关于 T):
1. 假设 A <: B
2. 如果 x: &'a A, 则 x 只能读取
3. 因为 A <: B, A 的所有操作 B 都支持
4. 因此 x 可以安全地当作 &'a B 使用
5. 即 &'a A <: &'a B ✓
```

**定理 2: 可变引用必须是不变的**:

```text
Theorem: &'a mut T 在 T 上必须是不变的

Proof (反证法):
1. 假设 &'a mut T 在 T 上是协变的
2. 令 A <: B, 则 &'a mut A <: &'a mut B
3. 构造反例:
   - let x: &'a mut &'static str
   - 如果协变，可以转换为 y: &'a mut &'b str
   - 通过 y 写入一个 'b 的引用
   - x 现在指向一个 'b 的引用，但类型声称是 'static
   - 当 'b 结束时，x 指向已释放的内存（悬垂指针）
4. 矛盾！因此 &'a mut T 必须在 T 上不变 ✓
```

**定理 3: 函数参数的逆变性**:

```text
Theorem: fn(T) 在 T 上是逆变的

Proof:
1. 假设 A <: B
2. 函数 f: fn(A) 期望接收类型 A
3. 如果我们有 g: fn(B), g 可以接收类型 B
4. 因为 A <: B, 任何 A 都可以当作 B 使用
5. 因此 g 可以接收 A（更特化的类型）
6. 即 fn(B) <: fn(A) (关系反转)
7. 所以 fn(T) 在 T 上逆变 ✓
```

### 1.6 Rust型变系统的设计权衡

**设计原则**:

1. **安全优先**: 宁可过于限制，也不引入不安全性
2. **零成本抽象**: 型变检查在编译时完成
3. **实用性**: 大多数情况下自动推导

**关键设计决策**:

| 决策 | 原因 | 影响 |
|------|------|------|
| `&T` 协变 | 只读，无安全风险 | 灵活性高 |
| `&mut T` 不变 | 可写，防止悬垂引用 | 限制较多，但安全 |
| `fn(T)` 逆变 | 函数可以接受更泛化的输入 | 符合直觉 |
| `Box<T>` 协变 | 拥有所有权，类似 `&T` | 灵活 |
| `Cell<T>` 不变 | 内部可变性，需要保守 | 安全第一 |

**与其他语言对比**:

```text
| 语言 | 型变策略 | 特点 |
|------|---------|------|
| Rust | 保守（不变为主） | 安全性极高 |
| Java | 使用处型变 | 运行时检查 |
| C# | out/in关键字 | 显式标注 |
| Scala | +/- 符号 | 灵活但复杂 |
| C++ | 无正式型变系统 | 依赖模板 |
```

### 1.7 型变与内存安全的关系

**核心不变式**:

```rust
// Rust的类型系统保证以下不变式:

// 1. 引用有效性
// ∀ r: &'a T. r 指向的数据在 'a 内有效

// 2. 独占访问
// ∀ r: &'a mut T. 'a 期间无其他访问 r 指向数据的引用

// 3. 不变性保证
// ∀ r: &'a T. r 指向的数据在 'a 期间不会通过 &mut 被修改
```

**型变如何保护内存安全**:

```rust
// 案例 1: 协变保护
fn covariance_safety() {
    let long: &'static str = "static";
    let short = String::from("temporary");
    
    // ✅ 安全：长生命周期可以缩短
    fn use_short<'a>(s: &'a str) {
        println!("{}", s);
    }
    use_short(long);  // 'static <: 'a
}

// 案例 2: 不变保护
fn invariance_safety() {
    let mut long: &'static str = "static";
    {
        let short = String::from("temporary");
        // ❌ 不安全：如果 &mut 协变，这会编译通过
        // let r: &mut &str = &mut long;
        // *r = &short;
        // 现在 long 指向已释放的 short
    }
    // println!("{}", long);  // 悬垂指针！
}

// 案例 3: 逆变保护
fn contravariance_safety() {
    // 函数可以接受更特化的参数
    fn process<F>(f: F, data: &str)
    where
        F: Fn(&str),
    {
        f(data);
    }
    
    // ✅ 安全：fn(&'static str) 可以当作 fn(&str)
    let handler: fn(&'static str) = |s| println!("{}", s);
    let temporary = String::from("temp");
    // process(handler, &temporary);  // 实际中类型不完全匹配
}
```

---

## 2. 协变 (Covariance)

### 2.1 定义

**协变**：如果 `A <: B`，则 `F<A> <: F<B>`。

```rust
// 'static <: 'a
// 所以 &'static str <: &'a str (协变)
fn foo<'a>(_: &'a str) {}

fn main() {
    let s: &'static str = "hello";
    foo(s);  // ✅ 可以传递更长的生命周期
}
```

### 2.2 示例

**不可变引用是协变的**:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let s1: &'static str = "hello";
    let s2 = String::from("world");
    
    // 'static <: 'a, 所以可以混用
    let result = longest(s1, &s2);
    println!("{}", result);
}
```

### 2.3 常见协变类型

```rust
use std::rc::Rc;
use std::sync::Arc;

fn main() {
    // Box<T> 在 T 上协变
    let b: Box<&'static str> = Box::new("hello");
    let _: Box<&str> = b;  // ✅
    
    // Vec<T> 在 T 上协变
    let v: Vec<&'static str> = vec!["a", "b"];
    let _: Vec<&str> = v;  // ✅
    
    // Rc<T> 在 T 上协变
    let rc: Rc<&'static str> = Rc::new("data");
    let _: Rc<&str> = rc;  // ✅
}
```

### 2.4 `Vec<T>` 协变的深度分析

**为什么 `Vec<T>` 在 T 上协变是安全的？**

```rust
// Vec<T> 只读操作不会改变元素类型
fn demonstrate_vec_covariance() {
    let static_vec: Vec<&'static str> = vec!["a", "b", "c"];
    
    // ✅ 可以当作 Vec<&str> 使用（协变）
    fn process_vec<'a>(v: Vec<&'a str>) {
        for item in &v {
            println!("{}", item);
        }
    }
    
    process_vec(static_vec);
}

// Vec<T> 的只读方法都是协变安全的
fn vec_readonly_methods() {
    let v: Vec<&'static str> = vec!["hello"];
    
    // 所有只读方法都可以安全使用
    let _first: Option<&&str> = v.first();  // 协变
    let _last: Option<&&str> = v.last();    // 协变
    let _iter = v.iter();                   // 迭代器也协变
}
```

**`Vec<T>` vs &mut [T] 的型变差异**:

```rust
fn vec_vs_slice() {
    let mut v: Vec<&'static str> = vec!["a"];
    
    // Vec<T> 整体协变
    fn take_vec(v: Vec<&str>) {
        println!("{:?}", v);
    }
    take_vec(v);
    
    // 但 &mut [T] 在 T 上不变
    let mut arr: [&'static str; 1] = ["a"];
    // let r: &mut [&str] = &mut arr;  // ❌ 编译错误
}
```

### 2.5 `Box<T>` 和智能指针的协变

**`Box<T>` 协变的实际应用**:

```rust
// Box<T> 在 T 上协变
struct Node {
    data: Box<&'static str>,  // 可以协变为 Box<&'a str>
}

impl Node {
    fn new(s: &'static str) -> Self {
        Node { data: Box::new(s) }
    }
    
    fn get<'a>(&'a self) -> &'a str {
        // Box<&'static str> 可以安全地当作 Box<&'a str>
        self.data.as_ref()
    }
}

fn main() {
    let node = Node::new("hello");
    println!("{}", node.get());
}
```

**`Rc<T>` 和 `Arc<T>` 的协变**:

```rust
use std::rc::Rc;
use std::sync::Arc;

// Rc<T> 在 T 上协变
fn rc_covariance() {
    let long: Rc<&'static str> = Rc::new("long-lived");
    
    fn use_rc<'a>(rc: Rc<&'a str>) {
        println!("{}", rc);
    }
    
    use_rc(long);  // ✅ Rc<&'static str> <: Rc<&'a str>
}

// Arc<T> 同样协变
fn arc_covariance() {
    let shared: Arc<&'static str> = Arc::new("shared");
    
    fn use_arc<'a>(arc: Arc<&'a str>) {
        println!("{}", arc);
    }
    
    use_arc(shared);  // ✅ Arc<&'static str> <: Arc<&'a str>
}

fn main() {
    rc_covariance();
    arc_covariance();
}
```

### 2.6 `Option<T>` 和 `Result<T, E>` 的协变

**`Option<T>` 在 T 上协变**:

```rust
fn option_covariance() {
    let some_static: Option<&'static str> = Some("value");
    
    // ✅ Option<&'static str> <: Option<&'a str>
    fn use_option<'a>(opt: Option<&'a str>) {
        if let Some(s) = opt {
            println!("{}", s);
        }
    }
    
    use_option(some_static);
}

// Option<T> 在集合中的协变
fn option_in_collections() {
    let vec: Vec<Option<&'static str>> = vec![Some("a"), None, Some("b")];
    
    // ✅ Vec<Option<&'static str>> <: Vec<Option<&str>>
    fn process<'a>(v: Vec<Option<&'a str>>) {
        for opt in v {
            if let Some(s) = opt {
                println!("{}", s);
            }
        }
    }
    
    process(vec);
}
```

**Result<T, E> 在 T 和 E 上都协变**:

```rust
fn result_covariance() {
    let ok_static: Result<&'static str, &'static str> = Ok("success");
    
    // ✅ Result<&'static str, &'static str> <: Result<&'a str, &'a str>
    fn use_result<'a>(res: Result<&'a str, &'a str>) {
        match res {
            Ok(s) => println!("Success: {}", s),
            Err(e) => println!("Error: {}", e),
        }
    }
    
    use_result(ok_static);
}

fn main() {
    option_covariance();
    option_in_collections();
    result_covariance();
}
```

---

## 3. 逆变 (Contravariance)

### 3.1 定义

**逆变**：如果 `A <: B`，则 `F<B> <: F<A>`（关系反转）。

### 3.2 函数参数

**函数参数是逆变的**:

```rust
// 'a <: 'static
// 所以 fn(&'static str) <: fn(&'a str) (逆变)

fn apply<F>(f: F, value: &'static str)
where
    F: Fn(&str),  // 接受任意生命周期
{
    f(value);
}

fn main() {
    apply(|s| println!("{}", s), "hello");
}
```

### 3.3 实际应用

**回调函数**:

```rust
trait Callback {
    fn call(&self, data: &str);
}

struct Logger;

impl Callback for Logger {
    fn call(&self, data: &str) {
        println!("Log: {}", data);
    }
}

fn process<'a, C: Callback>(callback: &C, data: &'a str) {
    callback.call(data);
}

fn main() {
    let logger = Logger;
    let data = String::from("message");
    process(&logger, &data);
}
```

---

## 4. 不变 (Invariance)

### 4.1 定义

**不变**：即使 `A <: B`，`F<A>` 和 `F<B>` 也没有子类型关系。

### 4.2 可变引用

**`&mut T` 是不变的**:

```rust
fn main() {
    let mut s: &'static str = "hello";
    
    // ❌ 编译错误：&mut 是不变的
    // let r: &mut &str = &mut s;
    
    // 如果允许，可能导致悬垂引用
}
```

**为什么不变是必要的**:

```rust
// 假设 &mut 是协变的（实际上不是）
fn hypothetical_bad() {
    let mut x: &'static str = "hello";
    let mut y: &str;
    
    // 如果这样可以（实际不行）
    // let r: &mut &str = &mut x;
    // *r = &String::from("temporary");
    // 现在 x 指向已被销毁的 String！
}
```

### 4.3 为什么需要不变

**保证内存安全**:

```rust
fn extend_lifetime<'a>(r: &mut &'a str, s: &'a str) {
    *r = s;
}

fn main() {
    let mut long: &'static str = "long";
    {
        let short = String::from("short");
        // extend_lifetime(&mut long, &short);  // ❌ 编译错误
        // 如果允许，long 会指向已释放的内存
    }
    // println!("{}", long);  // 悬垂引用！
}
```

### 4.4 `Cell<T>` 和 `RefCell<T>` 的不变性

**`Cell<T>` 在 T 上不变**:

```rust
use std::cell::Cell;

fn cell_invariance() {
    let cell: Cell<&'static str> = Cell::new("static");
    
    // ❌ Cell<&'static str> 不是 Cell<&'a str> 的子类型
    // let shorter: Cell<&str> = cell;  // 编译错误
    
    // 原因：Cell 允许内部可变性
    // 如果协变，可能写入短生命周期的引用
}

// Cell<T> 不变的安全性
fn why_cell_invariant() {
    let cell: Cell<&'static str> = Cell::new("long");
    
    // 如果 Cell 协变（实际不是）：
    // fn bad<'a>(c: Cell<&'a str>) {
    //     let short = String::from("temp");
    //     c.set(&short);  // 写入短生命周期
    // }
    // bad(cell);  // 如果允许，cell 现在指向已释放的内存
    
    println!("{}", cell.get());
}

fn main() {
    cell_invariance();
    why_cell_invariant();
}
```

**`RefCell<T>` 同样不变**:

```rust
use std::cell::RefCell;

fn refcell_invariance() {
    let refcell: RefCell<&'static str> = RefCell::new("static");
    
    // ❌ RefCell<&'static str> 不是 RefCell<&'a str> 的子类型
    // let shorter: RefCell<&str> = refcell;  // 编译错误
    
    // RefCell 允许通过 borrow_mut 修改内容
    *refcell.borrow_mut() = "new static";  // 只能写入相同生命周期
}

// 对比：不可变引用是协变的
fn immutable_is_covariant() {
    let s: &'static str = "static";
    let _: &str = s;  // ✅ 协变
    
    // 但可变引用在 T 上不变
    let mut s_mut: &'static str = "static";
    // let r: &mut &str = &mut s_mut;  // ❌ 不变
}

fn main() {
    refcell_invariance();
    immutable_is_covariant();
}
```

### 4.5 `UnsafeCell<T>` 的不变性

**`UnsafeCell<T>` 是所有内部可变性的基础**:

```rust
use std::cell::UnsafeCell;

struct MyCell<T> {
    value: UnsafeCell<T>,
}

impl<T> MyCell<T> {
    fn new(value: T) -> Self {
        MyCell {
            value: UnsafeCell::new(value),
        }
    }
    
    fn get(&self) -> &T {
        unsafe { &*self.value.get() }
    }
    
    fn set(&self, value: T) {
        unsafe {
            *self.value.get() = value;
        }
    }
}

// UnsafeCell<T> 在 T 上不变
fn unsafe_cell_invariance() {
    let cell: MyCell<&'static str> = MyCell::new("static");
    
    // ❌ MyCell<&'static str> 不是 MyCell<&'a str> 的子类型
    // 因为 UnsafeCell 不变
    
    println!("{}", cell.get());
}

fn main() {
    unsafe_cell_invariance();
}
```

### 4.6 不变性的实际影响

**案例 1: 缓存系统**:

```rust
use std::cell::RefCell;
use std::collections::HashMap;

struct Cache<'a> {
    data: RefCell<HashMap<String, &'a str>>,
}

impl<'a> Cache<'a> {
    fn new() -> Self {
        Cache {
            data: RefCell::new(HashMap::new()),
        }
    }
    
    fn insert(&self, key: String, value: &'a str) {
        self.data.borrow_mut().insert(key, value);
    }
    
    fn get(&self, key: &str) -> Option<&'a str> {
        // 注意：这里需要复制值，因为不能返回 Ref 的引用
        self.data.borrow().get(key).copied()
    }
}

fn main() {
    let cache: Cache<'static> = Cache::new();
    cache.insert("key".to_string(), "static value");
    
    // ❌ 不能缩短生命周期（因为 RefCell 不变）
    // let shorter_cache: Cache<'_> = cache;  // 编译错误
    
    println!("{:?}", cache.get("key"));
}
```

**案例 2: 状态机**:

```rust
use std::cell::Cell;

struct StateMachine {
    state: Cell<&'static str>,
}

impl StateMachine {
    fn new() -> Self {
        StateMachine {
            state: Cell::new("initial"),
        }
    }
    
    fn transition(&self, new_state: &'static str) {
        self.state.set(new_state);
    }
    
    fn current(&self) -> &'static str {
        self.state.get()
    }
}

fn main() {
    let sm = StateMachine::new();
    sm.transition("running");
    println!("Current state: {}", sm.current());
    
    // Cell 的不变性确保状态生命周期一致
}
```

---

## 5. 生命周期的型变

### 5.1 生命周期子类型

```rust
// 'a: 'b 表示 'a 至少和 'b 一样长
// 即 'a 是 'b 的子类型
fn choose<'a: 'b, 'b>(first: &'a str, _second: &'b str) -> &'b str {
    first
}

fn main() {
    let s1: &'static str = "first";
    let s2 = String::from("second");
    let result = choose(s1, &s2);
    println!("{}", result);
}
```

### 5.2 引用的型变

```rust
use std::marker::PhantomData;

// &'a T 在 'a 和 T 上都是协变的
struct Ref<'a, T: 'a> {
    reference: &'a T,
}

// &'a mut T 在 'a 上协变，在 T 上不变
struct RefMut<'a, T: 'a> {
    reference: &'a mut T,
}

fn main() {
    let x = 42;
    let r = Ref { reference: &x };
    println!("Value: {}", r.reference);
}
```

### 5.3 复合类型的型变

```rust
// 结构体的型变由其字段决定
struct Container<'a, T> {
    data: &'a T,  // 协变
}

struct MutContainer<'a, T> {
    data: &'a mut T,  // 在 'a 上协变，在 T 上不变
}

fn main() {
    let x = String::from("data");
    let c = Container { data: &x };
    println!("{}", c.data);
}
```

### 5.4 生命周期型变的实际案例

**案例 1: 迭代器的生命周期型变**:

```rust
struct Split<'a> {
    text: &'a str,
    delimiter: char,
}

impl<'a> Split<'a> {
    fn new(text: &'a str, delimiter: char) -> Self {
        Split { text, delimiter }
    }
}

// Iterator 在生命周期上协变
impl<'a> Iterator for Split<'a> {
    type Item = &'a str;
    
    fn next(&mut self) -> Option<Self::Item> {
        if let Some(pos) = self.text.find(self.delimiter) {
            let result = &self.text[..pos];
            self.text = &self.text[pos + 1..];
            Some(result)
        } else if !self.text.is_empty() {
            let result = self.text;
            self.text = "";
            Some(result)
        } else {
            None
        }
    }
}

fn main() {
    let text = String::from("a,b,c");
    let split = Split::new(&text, ',');
    
    for part in split {
        println!("{}", part);
    }
}
```

**案例 2: 树结构的生命周期**:

```rust
struct Tree<'a, T> {
    value: T,
    children: Vec<&'a Tree<'a, T>>,
}

impl<'a, T> Tree<'a, T> {
    fn new(value: T) -> Self {
        Tree {
            value,
            children: Vec::new(),
        }
    }
    
    // 在 'a 上协变
    fn children(&self) -> &[&'a Tree<'a, T>] {
        &self.children
    }
}

fn main() {
    let root = Tree::new(1);
    let child1 = Tree::new(2);
    let child2 = Tree::new(3);
    
    // 注意：这个例子简化了，实际使用需要更复杂的生命周期管理
    println!("Root: {}", root.value);
    println!("Child count: {}", root.children().len());
}
```

### 5.5 生命周期型变的常见错误

**错误 1: 混淆生命周期长度**:

```rust
// ❌ 错误理解
fn wrong_understanding<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'a: 'b,  // 'a 比 'b 长
{
    // y  // ❌ 编译错误：y 的生命周期可能比 'a 短
    x  // ✅ 正确
}

// ✅ 正确理解
fn correct_understanding<'a, 'b>(x: &'a str, y: &'b str) -> &'b str
where
    'a: 'b,  // 'a 比 'b 长，所以 &'a str <: &'b str
{
    x  // ✅ 可以缩短生命周期
}
```

**错误 2: 不理解可变引用的不变性**:

```rust
fn demonstrate_mut_invariance() {
    let mut s1: &'static str = "static";
    let s2 = String::from("temporary");
    
    // ❌ 想要缩短生命周期
    // let r: &mut &str = &mut s1;
    // *r = &s2;  // 如果允许，会创建悬垂指针
}
```

### 5.6 生命周期型变与泛型的组合

**复杂型变场景**:

```rust
use std::marker::PhantomData;

// 在多个维度上的型变
struct Complex<'a, 'b, T, U> {
    a_ref: &'a T,           // 在 'a 和 T 上协变
    b_mut_ref: &'b mut U,   // 在 'b 上协变，在 U 上不变
    _phantom: PhantomData<fn(&'a T, &'b U)>,
}

impl<'a, 'b, T, U> Complex<'a, 'b, T, U> {
    fn new(a: &'a T, b: &'b mut U) -> Self {
        Complex {
            a_ref: a,
            b_mut_ref: b,
            _phantom: PhantomData,
        }
    }
    
    fn get_a(&self) -> &'a T {
        self.a_ref
    }
    
    fn get_b_mut(&mut self) -> &mut U {
        self.b_mut_ref
    }
}

fn main() {
    let x = 42;
    let mut y = String::from("hello");
    
    let complex = Complex::new(&x, &mut y);
    println!("A: {}", complex.get_a());
}
```

---

## 6. PhantomData

### 6.1 型变标记

**显式标记型变**:

```rust
use std::marker::PhantomData;

// 不持有 T，但表现得像持有 T
struct MyType<T> {
    _marker: PhantomData<T>,
}

// 协变标记
struct CovariantType<T> {
    _marker: PhantomData<fn() -> T>,
}

// 逆变标记
struct ContravariantType<T> {
    _marker: PhantomData<fn(T)>,
}

// 不变标记
struct InvariantType<T> {
    _marker: PhantomData<fn(T) -> T>,
}

fn main() {
    let _: MyType<i32> = MyType {
        _marker: PhantomData,
    };
}
```

### 6.2 Drop Check

**Drop Check 和型变**:

```rust
use std::marker::PhantomData;

struct Inspector<'a, T: 'a> {
    _data: PhantomData<&'a T>,
}

impl<'a, T> Drop for Inspector<'a, T> {
    fn drop(&mut self) {
        println!("Dropping inspector");
    }
}

fn main() {
    let _inspector = Inspector::<i32> {
        _data: PhantomData,
    };
}
```

### 6.3 实际应用

**所有权标记**:

```rust
use std::marker::PhantomData;

struct Owned<T> {
    _marker: PhantomData<T>,
}

struct Borrowed<'a, T: 'a> {
    _marker: PhantomData<&'a T>,
}

fn main() {
    let _owned: Owned<String> = Owned {
        _marker: PhantomData,
    };
}
```

---

## 7. 型变规则表

**Rust 类型的型变规则**:

| 类型 | 'a | T |
|------|----|----|
| `&'a T` | 协变 | 协变 |
| `&'a mut T` | 协变 | **不变** |
| `*const T` | - | 协变 |
| `*mut T` | - | **不变** |
| `Box<T>` | - | 协变 |
| `Vec<T>` | - | 协变 |
| `Rc<T>` | - | 协变 |
| `Arc<T>` | - | 协变 |
| `Cell<T>` | - | **不变** |
| `RefCell<T>` | - | **不变** |
| `UnsafeCell<T>` | - | **不变** |
| `fn(T) -> U` | - | **逆变**(T), 协变(U) |

---

## 8. 实战案例

### 案例 1: 集合的型变

```rust
fn main() {
    // Vec 在 T 上协变
    let static_vec: Vec<&'static str> = vec!["a", "b", "c"];
    
    fn print_vec(v: Vec<&str>) {
        for item in v {
            println!("{}", item);
        }
    }
    
    // 可以传递 Vec<&'static str> 到期望 Vec<&str> 的地方
    print_vec(static_vec);
}
```

### 案例 2: 智能指针

```rust
use std::rc::Rc;

struct Node<'a> {
    value: &'a str,
}

fn main() {
    let static_node = Node {
        value: "static data",
    };
    
    // Rc 在 T 上协变
    let rc_static: Rc<Node<'static>> = Rc::new(static_node);
    let _rc_any: Rc<Node> = rc_static.clone();
}
```

### 案例 3: 迭代器

```rust
struct Iter<'a, T> {
    slice: &'a [T],
    index: usize,
}

impl<'a, T> Iter<'a, T> {
    fn new(slice: &'a [T]) -> Self {
        Iter { slice, index: 0 }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.slice.len() {
            let item = &self.slice[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let iter = Iter::new(&data);
    
    for value in iter {
        println!("{}", value);
    }
}
```

---

## 9. 常见陷阱

### 9.1 误解可变引用的型变

**陷阱 1: 认为 &mut 是协变的**:

```rust
// ❌ 错误理解：认为 &mut 是协变的
fn bad_example() {
    let mut s: &'static str = "hello";
    // let r: &mut &str = &mut s;  // 编译错误！
    // 如果允许，可能导致悬垂引用
}

// 正确理解：&mut T 在 T 上不变
fn correct_example() {
    let mut s: &'static str = "hello";
    let r: &mut &'static str = &mut s;  // ✅ 必须精确匹配
    *r = "world";
    println!("{}", s);
}
```

**陷阱 2: 混淆 `Vec<T>` 和 &mut [T]**:

```rust
fn vec_vs_mut_slice() {
    // Vec<T> 在 T 上协变
    let v: Vec<&'static str> = vec!["a"];
    fn take_vec(v: Vec<&str>) {
        println!("{:?}", v);
    }
    take_vec(v);  // ✅
    
    // 但 &mut [T] 在 T 上不变
    let mut arr: [&'static str; 1] = ["a"];
    // fn take_slice(s: &mut [&str]) {}
    // take_slice(&mut arr);  // ❌ 编译错误
}
```

### 9.2 PhantomData 使用不当

**陷阱 3: 错误的 PhantomData 标记**:

```rust
use std::marker::PhantomData;

// ❌ 错误：使用了错误的型变标记
struct WrongVariance<T> {
    ptr: *const (),
    _marker: PhantomData<T>,  // 协变+逆变=不变
}

// ✅ 正确：明确指定协变
struct CorrectVariance<T> {
    ptr: *const (),
    _marker: PhantomData<fn() -> T>,  // 协变
}

// ✅ 或使用 *const T
struct AlsoCorrect<T> {
    ptr: *const (),
    _marker: PhantomData<*const T>,  // 协变
}
```

**陷阱 4: 忘记 PhantomData 的 Drop Check 影响**:

```rust
use std::marker::PhantomData;

// ❌ 可能导致问题
struct MaybeUnsafe<'a, T> {
    data: *const T,
    _phantom: PhantomData<&'a T>,  // Drop check 会检查 'a
}

// ✅ 如果确实不需要 drop check
struct SafeVersion<'a, T> {
    data: *const T,
    _phantom: PhantomData<&'a ()>,  // 只标记生命周期
}
```

### 9.3 Drop 和型变冲突

**陷阱 5: Drop实现影响型变**:

```rust
// Drop 实现可能影响型变规则
struct Wrapper<'a, T: 'a> {
    data: &'a T,
}

// Drop 会影响 borrow checker 的推断
impl<'a, T> Drop for Wrapper<'a, T> {
    fn drop(&mut self) {
        println!("Dropping wrapper");
    }
}

fn demonstrate_drop_issue() {
    let x = 42;
    let wrapper = Wrapper { data: &x };
    // wrapper 的 drop 会在 x 之前调用
    // 如果 drop 访问 data, 必须保证 x 还活着
}

fn main() {
    demonstrate_drop_issue();
}
```

**陷阱 6: Drop Check 的微妙之处**:

```rust
use std::marker::PhantomData;

struct Container<'a, T> {
    data: *const T,
    _phantom: PhantomData<&'a T>,
}

impl<'a, T> Drop for Container<'a, T> {
    fn drop(&mut self) {
        // 如果这里访问 *self.data，必须保证 T 还活着
        println!("Dropping container");
    }
}

fn may_dangle_example() {
    let x = String::from("data");
    let _container = Container {
        data: &x as *const String,
        _phantom: PhantomData,
    };
    // drop 顺序：container 先于 x
}

fn main() {
    may_dangle_example();
}
```

### 9.4 生命周期型变的常见错误

**陷阱 7: 过度约束生命周期**:

```rust
// ❌ 过度约束
fn bad<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'a: 'b,
    'b: 'a,  // 要求 'a == 'b，过于严格
{
    x
}

// ✅ 合理约束
fn good<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'a: 'b,  // 只要求 'a 至少和 'b 一样长
{
    x
}
```

**陷阱 8: 混淆协变和逆变**:

```rust
// 协变：保持关系
fn covariant_example<'a>(f: impl Fn() -> &'a str) {
    // 如果 'static: 'a, 则 fn() -> &'static str <: fn() -> &'a str
}

// 逆变：反转关系
fn contravariant_example<'a>(f: impl Fn(&'a str)) {
    // 如果 'static: 'a, 则 fn(&'a str) <: fn(&'static str)
}
```

### 9.5 Cell 和 RefCell 的型变陷阱

**陷阱 9: 误以为 Cell 协变**:

```rust
use std::cell::Cell;

fn cell_trap() {
    let cell: Cell<&'static str> = Cell::new("static");
    
    // ❌ 想要协变
    // fn shrink_lifetime<'a>(c: Cell<&'a str>) {
    //     let short = String::from("temporary");
    //     c.set(&short);  // 危险！
    // }
    // shrink_lifetime(cell);  // 编译错误（幸好）
}
```

**陷阱 10: RefCell 借用规则和型变**:

```rust
use std::cell::RefCell;

fn refcell_trap() {
    let cell: RefCell<&'static str> = RefCell::new("static");
    
    // ❌ 尝试修改为短生命周期
    {
        let temp = String::from("temp");
        let mut borrow = cell.borrow_mut();
        // *borrow = &temp;  // 类型不匹配
    }
    
    println!("{}", cell.borrow());
}

fn main() {
    refcell_trap();
}
```

### 9.6 调试型变问题的技巧

**技巧 1: 显式标注所有生命周期**:

```rust
// 当编译器报错时，显式标注所有生命周期
fn debug_variance<'a, 'b, 'c>(
    x: &'a str,
    y: &'b str,
) -> &'c str
where
    'a: 'c,
    'b: 'c,
{
    if x.len() > y.len() { x } else { y }
}
```

**技巧 2: 使用编译器错误信息**:

```rust
// 编译器会明确指出型变问题
fn use_compiler_help() {
    let mut s: &'static str = "hello";
    // let r: &mut &str = &mut s;
    // 错误信息会解释为什么 &mut 不是协变的
}
```

**技巧 3: 简化类型以理解问题**:

```rust
// 复杂类型出问题时，逐步简化
fn simplify_to_understand() {
    // 从简单情况开始
    let _: Box<&'static str> = Box::new("hello");  // ✅
    let _: Vec<&'static str> = vec!["hello"];      // ✅
    
    // 然后逐步增加复杂性
    let _: Vec<Box<&'static str>> = vec![Box::new("hello")];  // ✅
}
```

---

## 10. 总结

**核心要点**:

1. **型变类型**
   - 协变：保持子类型关系
   - 逆变：反转子类型关系
   - 不变：不允许替换

2. **生命周期**
   - `&'a T` 在两者上协变
   - `&'a mut T` 在 `'a` 上协变，在 `T` 上不变

3. **安全性**
   - 不变保证内存安全
   - 防止悬垂引用

4. **PhantomData**
   - 标记型变行为
   - 影响 Drop Check

**记忆法则**:

- ✅ 只读 → 协变
- ⚠️ 可写 → 不变
- 🔄 函数参数 → 逆变

---

## 11. 参考资源

**官方文档**:

- [Rustonomicon - Subtyping and Variance](https://doc.rust-lang.org/nomicon/subtyping.html)
- [Rust Reference - Variance](https://doc.rust-lang.org/reference/subtyping.html)

**相关文档**:

- [2.3 泛型编程指南](../tier_02_guides/03_泛型编程指南.md)
- [2.5 生命周期指南](../tier_02_guides/05_生命周期指南.md)
- [3.1 类型转换参考](./01_类型转换参考.md)

---

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档类型**: Tier 3 - 参考层

---

**🎉 完成类型型变参考学习！** 🦀
