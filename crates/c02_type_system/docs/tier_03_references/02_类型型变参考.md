# 3.2 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹å‹å˜å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹å‹å˜ï¼ˆVarianceï¼‰å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md), [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.2 Rust ç±»å‹ç³»ç»Ÿ - ç±»å‹å‹å˜å‚è€ƒ](#32-rust-ç±»å‹ç³»ç»Ÿ---ç±»å‹å‹å˜å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. å‹å˜åŸºç¡€](#1-å‹å˜åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯å‹å˜](#11-ä»€ä¹ˆæ˜¯å‹å˜)
    - [1.2 å­ç±»å‹å…³ç³»](#12-å­ç±»å‹å…³ç³»)
    - [1.3 å‹å˜çš„ä¸‰ç§ç±»å‹](#13-å‹å˜çš„ä¸‰ç§ç±»å‹)
    - [1.4 å‹å˜çš„å½¢å¼åŒ–å®šä¹‰](#14-å‹å˜çš„å½¢å¼åŒ–å®šä¹‰)
    - [1.5 å‹å˜è§„åˆ™çš„å½¢å¼åŒ–è¯æ˜](#15-å‹å˜è§„åˆ™çš„å½¢å¼åŒ–è¯æ˜)
    - [1.6 Rustå‹å˜ç³»ç»Ÿçš„è®¾è®¡æƒè¡¡](#16-rustå‹å˜ç³»ç»Ÿçš„è®¾è®¡æƒè¡¡)
    - [1.7 å‹å˜ä¸å†…å­˜å®‰å…¨çš„å…³ç³»](#17-å‹å˜ä¸å†…å­˜å®‰å…¨çš„å…³ç³»)
  - [2. åå˜ (Covariance)](#2-åå˜-covariance)
    - [2.1 å®šä¹‰](#21-å®šä¹‰)
    - [2.2 ç¤ºä¾‹](#22-ç¤ºä¾‹)
    - [2.3 å¸¸è§åå˜ç±»å‹](#23-å¸¸è§åå˜ç±»å‹)
    - [2.4 `Vec<T>` åå˜çš„æ·±åº¦åˆ†æ](#24-vect-åå˜çš„æ·±åº¦åˆ†æ)
    - [2.5 `Box<T>` å’Œæ™ºèƒ½æŒ‡é’ˆçš„åå˜](#25-boxt-å’Œæ™ºèƒ½æŒ‡é’ˆçš„åå˜)
    - [2.6 `Option<T>` å’Œ `Result<T, E>` çš„åå˜](#26-optiont-å’Œ-resultt-e-çš„åå˜)
  - [3. é€†å˜ (Contravariance)](#3-é€†å˜-contravariance)
    - [3.1 å®šä¹‰](#31-å®šä¹‰)
    - [3.2 å‡½æ•°å‚æ•°](#32-å‡½æ•°å‚æ•°)
    - [3.3 å®é™…åº”ç”¨](#33-å®é™…åº”ç”¨)
  - [4. ä¸å˜ (Invariance)](#4-ä¸å˜-invariance)
    - [4.1 å®šä¹‰](#41-å®šä¹‰)
    - [4.2 å¯å˜å¼•ç”¨](#42-å¯å˜å¼•ç”¨)
    - [4.3 ä¸ºä»€ä¹ˆéœ€è¦ä¸å˜](#43-ä¸ºä»€ä¹ˆéœ€è¦ä¸å˜)
    - [4.4 `Cell<T>` å’Œ `RefCell<T>` çš„ä¸å˜æ€§](#44-cellt-å’Œ-refcellt-çš„ä¸å˜æ€§)
    - [4.5 `UnsafeCell<T>` çš„ä¸å˜æ€§](#45-unsafecellt-çš„ä¸å˜æ€§)
    - [4.6 ä¸å˜æ€§çš„å®é™…å½±å“](#46-ä¸å˜æ€§çš„å®é™…å½±å“)
  - [5. ç”Ÿå‘½å‘¨æœŸçš„å‹å˜](#5-ç”Ÿå‘½å‘¨æœŸçš„å‹å˜)
    - [5.1 ç”Ÿå‘½å‘¨æœŸå­ç±»å‹](#51-ç”Ÿå‘½å‘¨æœŸå­ç±»å‹)
    - [5.2 å¼•ç”¨çš„å‹å˜](#52-å¼•ç”¨çš„å‹å˜)
    - [5.3 å¤åˆç±»å‹çš„å‹å˜](#53-å¤åˆç±»å‹çš„å‹å˜)
    - [5.4 ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å®é™…æ¡ˆä¾‹](#54-ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å®é™…æ¡ˆä¾‹)
    - [5.5 ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å¸¸è§é”™è¯¯](#55-ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å¸¸è§é”™è¯¯)
    - [5.6 ç”Ÿå‘½å‘¨æœŸå‹å˜ä¸æ³›å‹çš„ç»„åˆ](#56-ç”Ÿå‘½å‘¨æœŸå‹å˜ä¸æ³›å‹çš„ç»„åˆ)
  - [6. PhantomData](#6-phantomdata)
    - [6.1 å‹å˜æ ‡è®°](#61-å‹å˜æ ‡è®°)
    - [6.2 Drop Check](#62-drop-check)
    - [6.3 å®é™…åº”ç”¨](#63-å®é™…åº”ç”¨)
  - [7. å‹å˜è§„åˆ™è¡¨](#7-å‹å˜è§„åˆ™è¡¨)
  - [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: é›†åˆçš„å‹å˜](#æ¡ˆä¾‹-1-é›†åˆçš„å‹å˜)
    - [æ¡ˆä¾‹ 2: æ™ºèƒ½æŒ‡é’ˆ](#æ¡ˆä¾‹-2-æ™ºèƒ½æŒ‡é’ˆ)
    - [æ¡ˆä¾‹ 3: è¿­ä»£å™¨](#æ¡ˆä¾‹-3-è¿­ä»£å™¨)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
    - [9.1 è¯¯è§£å¯å˜å¼•ç”¨çš„å‹å˜](#91-è¯¯è§£å¯å˜å¼•ç”¨çš„å‹å˜)
    - [9.2 PhantomData ä½¿ç”¨ä¸å½“](#92-phantomdata-ä½¿ç”¨ä¸å½“)
    - [9.3 Drop å’Œå‹å˜å†²çª](#93-drop-å’Œå‹å˜å†²çª)
    - [9.4 ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å¸¸è§é”™è¯¯](#94-ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å¸¸è§é”™è¯¯)
    - [9.5 Cell å’Œ RefCell çš„å‹å˜é™·é˜±](#95-cell-å’Œ-refcell-çš„å‹å˜é™·é˜±)
    - [9.6 è°ƒè¯•å‹å˜é—®é¢˜çš„æŠ€å·§](#96-è°ƒè¯•å‹å˜é—®é¢˜çš„æŠ€å·§)
  - [10. æ€»ç»“](#10-æ€»ç»“)
  - [11. å‚è€ƒèµ„æº](#11-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

**å‹å˜** (Variance) æè¿°äº†æ³›å‹ç±»å‹å‚æ•°çš„å­ç±»å‹å…³ç³»å¦‚ä½•å½±å“åŒ…å«å®ƒä»¬çš„å¤åˆç±»å‹çš„å­ç±»å‹å…³ç³»ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

- ğŸ”„ **åå˜**: ä¿æŒå­ç±»å‹å…³ç³»
- â†”ï¸ **é€†å˜**: åè½¬å­ç±»å‹å…³ç³»  
- ğŸš« **ä¸å˜**: ä¸å…è®¸å­ç±»å‹æ›¿æ¢

---

## 1. å‹å˜åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯å‹å˜

å‹å˜å†³å®šäº†ï¼š**å½“ `A` æ˜¯ `B` çš„å­ç±»å‹æ—¶ï¼Œ`F<A>` å’Œ `F<B>` æ˜¯ä»€ä¹ˆå…³ç³»ï¼Ÿ**

```rust
// å¦‚æœ 'static æ˜¯ 'a çš„å­ç±»å‹
// é‚£ä¹ˆï¼š
// - &'static T æ˜¯ &'a T çš„å­ç±»å‹å—ï¼Ÿ (åå˜)
// - &'static mut T æ˜¯ &'a mut T çš„å­ç±»å‹å—ï¼Ÿ (ä¸å˜)
```

### 1.2 å­ç±»å‹å…³ç³»

**ç”Ÿå‘½å‘¨æœŸå­ç±»å‹**:

```rust
fn main() {
    // 'static æ˜¯æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸçš„å­ç±»å‹
    let s: &'static str = "hello";
    let _: &str = s;  // âœ… 'static <: 'a
    
    // æ›´é•¿çš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ›´çŸ­ç”Ÿå‘½å‘¨æœŸçš„å­ç±»å‹
    let x = String::from("data");
    {
        let y = &x;  // 'long
        {
            let _z: &str = y;  // 'short, 'long <: 'short
        }
    }
}
```

### 1.3 å‹å˜çš„ä¸‰ç§ç±»å‹

| å‹å˜ç±»å‹ | ç¬¦å· | å«ä¹‰ | ç¤ºä¾‹ |
|---------|------|------|------|
| **åå˜** | `F<A> <: F<B>` if `A <: B` | ä¿æŒå…³ç³» | `&'a T` |
| **é€†å˜** | `F<B> <: F<A>` if `A <: B` | åè½¬å…³ç³» | `fn(T)` |
| **ä¸å˜** | æ— å…³ç³» | ä¸å…è®¸æ›¿æ¢ | `&'a mut T` |

### 1.4 å‹å˜çš„å½¢å¼åŒ–å®šä¹‰

**åå˜çš„æ•°å­¦å®šä¹‰**:

```text
ç»™å®šç±»å‹æ„é€ å™¨ F å’Œç±»å‹ A, B:

F åœ¨å…¶ç±»å‹å‚æ•°ä¸Šæ˜¯åå˜çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
âˆ€ A, B. (A <: B) âŸ¹ (F<A> <: F<B>)

ä¾‹å¦‚ï¼š
- 'static <: 'a
- å› æ­¤ &'static T <: &'a T (åå˜)
```

**é€†å˜çš„æ•°å­¦å®šä¹‰**:

```text
F åœ¨å…¶ç±»å‹å‚æ•°ä¸Šæ˜¯é€†å˜çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
âˆ€ A, B. (A <: B) âŸ¹ (F<B> <: F<A>)

ä¾‹å¦‚ï¼š
- 'a <: 'static
- å› æ­¤ fn(&'static T) <: fn(&'a T) (é€†å˜)
```

**ä¸å˜çš„æ•°å­¦å®šä¹‰**:

```text
F åœ¨å…¶ç±»å‹å‚æ•°ä¸Šæ˜¯ä¸å˜çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
âˆ€ A, B. (A <: B) âŸ¹ (F<A> å’Œ F<B> æ— å­ç±»å‹å…³ç³»)

ä¾‹å¦‚ï¼š
- 'a <: 'static
- ä½† &'a mut T å’Œ &'static mut T æ— æ³•äº’ç›¸è½¬æ¢
```

### 1.5 å‹å˜è§„åˆ™çš„å½¢å¼åŒ–è¯æ˜

**å®šç† 1: ä¸å¯å˜å¼•ç”¨çš„åå˜æ€§æ˜¯å®‰å…¨çš„**:

```text
Theorem: &'a T åœ¨ 'a å’Œ T ä¸Šéƒ½æ˜¯åå˜çš„

Proof (å…³äº 'a):
1. å‡è®¾ 'a: 'b (å³ 'a â‰¥ 'b, 'a è‡³å°‘å’Œ 'b ä¸€æ ·é•¿)
2. å¦‚æœ x: &'a T, åˆ™ x æŒ‡å‘çš„æ•°æ®åœ¨ 'a å†…æœ‰æ•ˆ
3. å› ä¸º 'a â‰¥ 'b, æ‰€ä»¥ x æŒ‡å‘çš„æ•°æ®åœ¨ 'b å†…ä¹Ÿæœ‰æ•ˆ
4. å› æ­¤ x å¯ä»¥å®‰å…¨åœ°ç”¨ä½œ &'b T
5. å³ &'a T <: &'b T âœ“

Proof (å…³äº T):
1. å‡è®¾ A <: B
2. å¦‚æœ x: &'a A, åˆ™ x åªèƒ½è¯»å–
3. å› ä¸º A <: B, A çš„æ‰€æœ‰æ“ä½œ B éƒ½æ”¯æŒ
4. å› æ­¤ x å¯ä»¥å®‰å…¨åœ°å½“ä½œ &'a B ä½¿ç”¨
5. å³ &'a A <: &'a B âœ“
```

**å®šç† 2: å¯å˜å¼•ç”¨å¿…é¡»æ˜¯ä¸å˜çš„**:

```text
Theorem: &'a mut T åœ¨ T ä¸Šå¿…é¡»æ˜¯ä¸å˜çš„

Proof (åè¯æ³•):
1. å‡è®¾ &'a mut T åœ¨ T ä¸Šæ˜¯åå˜çš„
2. ä»¤ A <: B, åˆ™ &'a mut A <: &'a mut B
3. æ„é€ åä¾‹:
   - let x: &'a mut &'static str
   - å¦‚æœåå˜ï¼Œå¯ä»¥è½¬æ¢ä¸º y: &'a mut &'b str
   - é€šè¿‡ y å†™å…¥ä¸€ä¸ª 'b çš„å¼•ç”¨
   - x ç°åœ¨æŒ‡å‘ä¸€ä¸ª 'b çš„å¼•ç”¨ï¼Œä½†ç±»å‹å£°ç§°æ˜¯ 'static
   - å½“ 'b ç»“æŸæ—¶ï¼Œx æŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜ï¼ˆæ‚¬å‚æŒ‡é’ˆï¼‰
4. çŸ›ç›¾ï¼å› æ­¤ &'a mut T å¿…é¡»åœ¨ T ä¸Šä¸å˜ âœ“
```

**å®šç† 3: å‡½æ•°å‚æ•°çš„é€†å˜æ€§**:

```text
Theorem: fn(T) åœ¨ T ä¸Šæ˜¯é€†å˜çš„

Proof:
1. å‡è®¾ A <: B
2. å‡½æ•° f: fn(A) æœŸæœ›æ¥æ”¶ç±»å‹ A
3. å¦‚æœæˆ‘ä»¬æœ‰ g: fn(B), g å¯ä»¥æ¥æ”¶ç±»å‹ B
4. å› ä¸º A <: B, ä»»ä½• A éƒ½å¯ä»¥å½“ä½œ B ä½¿ç”¨
5. å› æ­¤ g å¯ä»¥æ¥æ”¶ Aï¼ˆæ›´ç‰¹åŒ–çš„ç±»å‹ï¼‰
6. å³ fn(B) <: fn(A) (å…³ç³»åè½¬)
7. æ‰€ä»¥ fn(T) åœ¨ T ä¸Šé€†å˜ âœ“
```

### 1.6 Rustå‹å˜ç³»ç»Ÿçš„è®¾è®¡æƒè¡¡

**è®¾è®¡åŸåˆ™**:

1. **å®‰å…¨ä¼˜å…ˆ**: å®å¯è¿‡äºé™åˆ¶ï¼Œä¹Ÿä¸å¼•å…¥ä¸å®‰å…¨æ€§
2. **é›¶æˆæœ¬æŠ½è±¡**: å‹å˜æ£€æŸ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆ
3. **å®ç”¨æ€§**: å¤§å¤šæ•°æƒ…å†µä¸‹è‡ªåŠ¨æ¨å¯¼

**å…³é”®è®¾è®¡å†³ç­–**:

| å†³ç­– | åŸå›  | å½±å“ |
|------|------|------|
| `&T` åå˜ | åªè¯»ï¼Œæ— å®‰å…¨é£é™© | çµæ´»æ€§é«˜ |
| `&mut T` ä¸å˜ | å¯å†™ï¼Œé˜²æ­¢æ‚¬å‚å¼•ç”¨ | é™åˆ¶è¾ƒå¤šï¼Œä½†å®‰å…¨ |
| `fn(T)` é€†å˜ | å‡½æ•°å¯ä»¥æ¥å—æ›´æ³›åŒ–çš„è¾“å…¥ | ç¬¦åˆç›´è§‰ |
| `Box<T>` åå˜ | æ‹¥æœ‰æ‰€æœ‰æƒï¼Œç±»ä¼¼ `&T` | çµæ´» |
| `Cell<T>` ä¸å˜ | å†…éƒ¨å¯å˜æ€§ï¼Œéœ€è¦ä¿å®ˆ | å®‰å…¨ç¬¬ä¸€ |

**ä¸å…¶ä»–è¯­è¨€å¯¹æ¯”**:

```text
| è¯­è¨€ | å‹å˜ç­–ç•¥ | ç‰¹ç‚¹ |
|------|---------|------|
| Rust | ä¿å®ˆï¼ˆä¸å˜ä¸ºä¸»ï¼‰ | å®‰å…¨æ€§æé«˜ |
| Java | ä½¿ç”¨å¤„å‹å˜ | è¿è¡Œæ—¶æ£€æŸ¥ |
| C# | out/inå…³é”®å­— | æ˜¾å¼æ ‡æ³¨ |
| Scala | +/- ç¬¦å· | çµæ´»ä½†å¤æ‚ |
| C++ | æ— æ­£å¼å‹å˜ç³»ç»Ÿ | ä¾èµ–æ¨¡æ¿ |
```

### 1.7 å‹å˜ä¸å†…å­˜å®‰å…¨çš„å…³ç³»

**æ ¸å¿ƒä¸å˜å¼**:

```rust
// Rustçš„ç±»å‹ç³»ç»Ÿä¿è¯ä»¥ä¸‹ä¸å˜å¼:

// 1. å¼•ç”¨æœ‰æ•ˆæ€§
// âˆ€ r: &'a T. r æŒ‡å‘çš„æ•°æ®åœ¨ 'a å†…æœ‰æ•ˆ

// 2. ç‹¬å è®¿é—®
// âˆ€ r: &'a mut T. 'a æœŸé—´æ— å…¶ä»–è®¿é—® r æŒ‡å‘æ•°æ®çš„å¼•ç”¨

// 3. ä¸å˜æ€§ä¿è¯
// âˆ€ r: &'a T. r æŒ‡å‘çš„æ•°æ®åœ¨ 'a æœŸé—´ä¸ä¼šé€šè¿‡ &mut è¢«ä¿®æ”¹
```

**å‹å˜å¦‚ä½•ä¿æŠ¤å†…å­˜å®‰å…¨**:

```rust
// æ¡ˆä¾‹ 1: åå˜ä¿æŠ¤
fn covariance_safety() {
    let long: &'static str = "static";
    let short = String::from("temporary");
    
    // âœ… å®‰å…¨ï¼šé•¿ç”Ÿå‘½å‘¨æœŸå¯ä»¥ç¼©çŸ­
    fn use_short<'a>(s: &'a str) {
        println!("{}", s);
    }
    use_short(long);  // 'static <: 'a
}

// æ¡ˆä¾‹ 2: ä¸å˜ä¿æŠ¤
fn invariance_safety() {
    let mut long: &'static str = "static";
    {
        let short = String::from("temporary");
        // âŒ ä¸å®‰å…¨ï¼šå¦‚æœ &mut åå˜ï¼Œè¿™ä¼šç¼–è¯‘é€šè¿‡
        // let r: &mut &str = &mut long;
        // *r = &short;
        // ç°åœ¨ long æŒ‡å‘å·²é‡Šæ”¾çš„ short
    }
    // println!("{}", long);  // æ‚¬å‚æŒ‡é’ˆï¼
}

// æ¡ˆä¾‹ 3: é€†å˜ä¿æŠ¤
fn contravariance_safety() {
    // å‡½æ•°å¯ä»¥æ¥å—æ›´ç‰¹åŒ–çš„å‚æ•°
    fn process<F>(f: F, data: &str)
    where
        F: Fn(&str),
    {
        f(data);
    }
    
    // âœ… å®‰å…¨ï¼šfn(&'static str) å¯ä»¥å½“ä½œ fn(&str)
    let handler: fn(&'static str) = |s| println!("{}", s);
    let temporary = String::from("temp");
    // process(handler, &temporary);  // å®é™…ä¸­ç±»å‹ä¸å®Œå…¨åŒ¹é…
}
```

---

## 2. åå˜ (Covariance)

### 2.1 å®šä¹‰

**åå˜**ï¼šå¦‚æœ `A <: B`ï¼Œåˆ™ `F<A> <: F<B>`ã€‚

```rust
// 'static <: 'a
// æ‰€ä»¥ &'static str <: &'a str (åå˜)
fn foo<'a>(_: &'a str) {}

fn main() {
    let s: &'static str = "hello";
    foo(s);  // âœ… å¯ä»¥ä¼ é€’æ›´é•¿çš„ç”Ÿå‘½å‘¨æœŸ
}
```

### 2.2 ç¤ºä¾‹

**ä¸å¯å˜å¼•ç”¨æ˜¯åå˜çš„**:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let s1: &'static str = "hello";
    let s2 = String::from("world");
    
    // 'static <: 'a, æ‰€ä»¥å¯ä»¥æ··ç”¨
    let result = longest(s1, &s2);
    println!("{}", result);
}
```

### 2.3 å¸¸è§åå˜ç±»å‹

```rust
use std::rc::Rc;
use std::sync::Arc;

fn main() {
    // Box<T> åœ¨ T ä¸Šåå˜
    let b: Box<&'static str> = Box::new("hello");
    let _: Box<&str> = b;  // âœ…
    
    // Vec<T> åœ¨ T ä¸Šåå˜
    let v: Vec<&'static str> = vec!["a", "b"];
    let _: Vec<&str> = v;  // âœ…
    
    // Rc<T> åœ¨ T ä¸Šåå˜
    let rc: Rc<&'static str> = Rc::new("data");
    let _: Rc<&str> = rc;  // âœ…
}
```

### 2.4 `Vec<T>` åå˜çš„æ·±åº¦åˆ†æ

**ä¸ºä»€ä¹ˆ `Vec<T>` åœ¨ T ä¸Šåå˜æ˜¯å®‰å…¨çš„ï¼Ÿ**

```rust
// Vec<T> åªè¯»æ“ä½œä¸ä¼šæ”¹å˜å…ƒç´ ç±»å‹
fn demonstrate_vec_covariance() {
    let static_vec: Vec<&'static str> = vec!["a", "b", "c"];
    
    // âœ… å¯ä»¥å½“ä½œ Vec<&str> ä½¿ç”¨ï¼ˆåå˜ï¼‰
    fn process_vec<'a>(v: Vec<&'a str>) {
        for item in &v {
            println!("{}", item);
        }
    }
    
    process_vec(static_vec);
}

// Vec<T> çš„åªè¯»æ–¹æ³•éƒ½æ˜¯åå˜å®‰å…¨çš„
fn vec_readonly_methods() {
    let v: Vec<&'static str> = vec!["hello"];
    
    // æ‰€æœ‰åªè¯»æ–¹æ³•éƒ½å¯ä»¥å®‰å…¨ä½¿ç”¨
    let _first: Option<&&str> = v.first();  // åå˜
    let _last: Option<&&str> = v.last();    // åå˜
    let _iter = v.iter();                   // è¿­ä»£å™¨ä¹Ÿåå˜
}
```

**`Vec<T>` vs &mut [T] çš„å‹å˜å·®å¼‚**:

```rust
fn vec_vs_slice() {
    let mut v: Vec<&'static str> = vec!["a"];
    
    // Vec<T> æ•´ä½“åå˜
    fn take_vec(v: Vec<&str>) {
        println!("{:?}", v);
    }
    take_vec(v);
    
    // ä½† &mut [T] åœ¨ T ä¸Šä¸å˜
    let mut arr: [&'static str; 1] = ["a"];
    // let r: &mut [&str] = &mut arr;  // âŒ ç¼–è¯‘é”™è¯¯
}
```

### 2.5 `Box<T>` å’Œæ™ºèƒ½æŒ‡é’ˆçš„åå˜

**`Box<T>` åå˜çš„å®é™…åº”ç”¨**:

```rust
// Box<T> åœ¨ T ä¸Šåå˜
struct Node {
    data: Box<&'static str>,  // å¯ä»¥åå˜ä¸º Box<&'a str>
}

impl Node {
    fn new(s: &'static str) -> Self {
        Node { data: Box::new(s) }
    }
    
    fn get<'a>(&'a self) -> &'a str {
        // Box<&'static str> å¯ä»¥å®‰å…¨åœ°å½“ä½œ Box<&'a str>
        self.data.as_ref()
    }
}

fn main() {
    let node = Node::new("hello");
    println!("{}", node.get());
}
```

**`Rc<T>` å’Œ `Arc<T>` çš„åå˜**:

```rust
use std::rc::Rc;
use std::sync::Arc;

// Rc<T> åœ¨ T ä¸Šåå˜
fn rc_covariance() {
    let long: Rc<&'static str> = Rc::new("long-lived");
    
    fn use_rc<'a>(rc: Rc<&'a str>) {
        println!("{}", rc);
    }
    
    use_rc(long);  // âœ… Rc<&'static str> <: Rc<&'a str>
}

// Arc<T> åŒæ ·åå˜
fn arc_covariance() {
    let shared: Arc<&'static str> = Arc::new("shared");
    
    fn use_arc<'a>(arc: Arc<&'a str>) {
        println!("{}", arc);
    }
    
    use_arc(shared);  // âœ… Arc<&'static str> <: Arc<&'a str>
}

fn main() {
    rc_covariance();
    arc_covariance();
}
```

### 2.6 `Option<T>` å’Œ `Result<T, E>` çš„åå˜

**`Option<T>` åœ¨ T ä¸Šåå˜**:

```rust
fn option_covariance() {
    let some_static: Option<&'static str> = Some("value");
    
    // âœ… Option<&'static str> <: Option<&'a str>
    fn use_option<'a>(opt: Option<&'a str>) {
        if let Some(s) = opt {
            println!("{}", s);
        }
    }
    
    use_option(some_static);
}

// Option<T> åœ¨é›†åˆä¸­çš„åå˜
fn option_in_collections() {
    let vec: Vec<Option<&'static str>> = vec![Some("a"), None, Some("b")];
    
    // âœ… Vec<Option<&'static str>> <: Vec<Option<&str>>
    fn process<'a>(v: Vec<Option<&'a str>>) {
        for opt in v {
            if let Some(s) = opt {
                println!("{}", s);
            }
        }
    }
    
    process(vec);
}
```

**Result<T, E> åœ¨ T å’Œ E ä¸Šéƒ½åå˜**:

```rust
fn result_covariance() {
    let ok_static: Result<&'static str, &'static str> = Ok("success");
    
    // âœ… Result<&'static str, &'static str> <: Result<&'a str, &'a str>
    fn use_result<'a>(res: Result<&'a str, &'a str>) {
        match res {
            Ok(s) => println!("Success: {}", s),
            Err(e) => println!("Error: {}", e),
        }
    }
    
    use_result(ok_static);
}

fn main() {
    option_covariance();
    option_in_collections();
    result_covariance();
}
```

---

## 3. é€†å˜ (Contravariance)

### 3.1 å®šä¹‰

**é€†å˜**ï¼šå¦‚æœ `A <: B`ï¼Œåˆ™ `F<B> <: F<A>`ï¼ˆå…³ç³»åè½¬ï¼‰ã€‚

### 3.2 å‡½æ•°å‚æ•°

**å‡½æ•°å‚æ•°æ˜¯é€†å˜çš„**:

```rust
// 'a <: 'static
// æ‰€ä»¥ fn(&'static str) <: fn(&'a str) (é€†å˜)

fn apply<F>(f: F, value: &'static str)
where
    F: Fn(&str),  // æ¥å—ä»»æ„ç”Ÿå‘½å‘¨æœŸ
{
    f(value);
}

fn main() {
    apply(|s| println!("{}", s), "hello");
}
```

### 3.3 å®é™…åº”ç”¨

**å›è°ƒå‡½æ•°**:

```rust
trait Callback {
    fn call(&self, data: &str);
}

struct Logger;

impl Callback for Logger {
    fn call(&self, data: &str) {
        println!("Log: {}", data);
    }
}

fn process<'a, C: Callback>(callback: &C, data: &'a str) {
    callback.call(data);
}

fn main() {
    let logger = Logger;
    let data = String::from("message");
    process(&logger, &data);
}
```

---

## 4. ä¸å˜ (Invariance)

### 4.1 å®šä¹‰

**ä¸å˜**ï¼šå³ä½¿ `A <: B`ï¼Œ`F<A>` å’Œ `F<B>` ä¹Ÿæ²¡æœ‰å­ç±»å‹å…³ç³»ã€‚

### 4.2 å¯å˜å¼•ç”¨

**`&mut T` æ˜¯ä¸å˜çš„**:

```rust
fn main() {
    let mut s: &'static str = "hello";
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼š&mut æ˜¯ä¸å˜çš„
    // let r: &mut &str = &mut s;
    
    // å¦‚æœå…è®¸ï¼Œå¯èƒ½å¯¼è‡´æ‚¬å‚å¼•ç”¨
}
```

**ä¸ºä»€ä¹ˆä¸å˜æ˜¯å¿…è¦çš„**:

```rust
// å‡è®¾ &mut æ˜¯åå˜çš„ï¼ˆå®é™…ä¸Šä¸æ˜¯ï¼‰
fn hypothetical_bad() {
    let mut x: &'static str = "hello";
    let mut y: &str;
    
    // å¦‚æœè¿™æ ·å¯ä»¥ï¼ˆå®é™…ä¸è¡Œï¼‰
    // let r: &mut &str = &mut x;
    // *r = &String::from("temporary");
    // ç°åœ¨ x æŒ‡å‘å·²è¢«é”€æ¯çš„ Stringï¼
}
```

### 4.3 ä¸ºä»€ä¹ˆéœ€è¦ä¸å˜

**ä¿è¯å†…å­˜å®‰å…¨**:

```rust
fn extend_lifetime<'a>(r: &mut &'a str, s: &'a str) {
    *r = s;
}

fn main() {
    let mut long: &'static str = "long";
    {
        let short = String::from("short");
        // extend_lifetime(&mut long, &short);  // âŒ ç¼–è¯‘é”™è¯¯
        // å¦‚æœå…è®¸ï¼Œlong ä¼šæŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜
    }
    // println!("{}", long);  // æ‚¬å‚å¼•ç”¨ï¼
}
```

### 4.4 `Cell<T>` å’Œ `RefCell<T>` çš„ä¸å˜æ€§

**`Cell<T>` åœ¨ T ä¸Šä¸å˜**:

```rust
use std::cell::Cell;

fn cell_invariance() {
    let cell: Cell<&'static str> = Cell::new("static");
    
    // âŒ Cell<&'static str> ä¸æ˜¯ Cell<&'a str> çš„å­ç±»å‹
    // let shorter: Cell<&str> = cell;  // ç¼–è¯‘é”™è¯¯
    
    // åŸå› ï¼šCell å…è®¸å†…éƒ¨å¯å˜æ€§
    // å¦‚æœåå˜ï¼Œå¯èƒ½å†™å…¥çŸ­ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
}

// Cell<T> ä¸å˜çš„å®‰å…¨æ€§
fn why_cell_invariant() {
    let cell: Cell<&'static str> = Cell::new("long");
    
    // å¦‚æœ Cell åå˜ï¼ˆå®é™…ä¸æ˜¯ï¼‰ï¼š
    // fn bad<'a>(c: Cell<&'a str>) {
    //     let short = String::from("temp");
    //     c.set(&short);  // å†™å…¥çŸ­ç”Ÿå‘½å‘¨æœŸ
    // }
    // bad(cell);  // å¦‚æœå…è®¸ï¼Œcell ç°åœ¨æŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜
    
    println!("{}", cell.get());
}

fn main() {
    cell_invariance();
    why_cell_invariant();
}
```

**`RefCell<T>` åŒæ ·ä¸å˜**:

```rust
use std::cell::RefCell;

fn refcell_invariance() {
    let refcell: RefCell<&'static str> = RefCell::new("static");
    
    // âŒ RefCell<&'static str> ä¸æ˜¯ RefCell<&'a str> çš„å­ç±»å‹
    // let shorter: RefCell<&str> = refcell;  // ç¼–è¯‘é”™è¯¯
    
    // RefCell å…è®¸é€šè¿‡ borrow_mut ä¿®æ”¹å†…å®¹
    *refcell.borrow_mut() = "new static";  // åªèƒ½å†™å…¥ç›¸åŒç”Ÿå‘½å‘¨æœŸ
}

// å¯¹æ¯”ï¼šä¸å¯å˜å¼•ç”¨æ˜¯åå˜çš„
fn immutable_is_covariant() {
    let s: &'static str = "static";
    let _: &str = s;  // âœ… åå˜
    
    // ä½†å¯å˜å¼•ç”¨åœ¨ T ä¸Šä¸å˜
    let mut s_mut: &'static str = "static";
    // let r: &mut &str = &mut s_mut;  // âŒ ä¸å˜
}

fn main() {
    refcell_invariance();
    immutable_is_covariant();
}
```

### 4.5 `UnsafeCell<T>` çš„ä¸å˜æ€§

**`UnsafeCell<T>` æ˜¯æ‰€æœ‰å†…éƒ¨å¯å˜æ€§çš„åŸºç¡€**:

```rust
use std::cell::UnsafeCell;

struct MyCell<T> {
    value: UnsafeCell<T>,
}

impl<T> MyCell<T> {
    fn new(value: T) -> Self {
        MyCell {
            value: UnsafeCell::new(value),
        }
    }
    
    fn get(&self) -> &T {
        unsafe { &*self.value.get() }
    }
    
    fn set(&self, value: T) {
        unsafe {
            *self.value.get() = value;
        }
    }
}

// UnsafeCell<T> åœ¨ T ä¸Šä¸å˜
fn unsafe_cell_invariance() {
    let cell: MyCell<&'static str> = MyCell::new("static");
    
    // âŒ MyCell<&'static str> ä¸æ˜¯ MyCell<&'a str> çš„å­ç±»å‹
    // å› ä¸º UnsafeCell ä¸å˜
    
    println!("{}", cell.get());
}

fn main() {
    unsafe_cell_invariance();
}
```

### 4.6 ä¸å˜æ€§çš„å®é™…å½±å“

**æ¡ˆä¾‹ 1: ç¼“å­˜ç³»ç»Ÿ**:

```rust
use std::cell::RefCell;
use std::collections::HashMap;

struct Cache<'a> {
    data: RefCell<HashMap<String, &'a str>>,
}

impl<'a> Cache<'a> {
    fn new() -> Self {
        Cache {
            data: RefCell::new(HashMap::new()),
        }
    }
    
    fn insert(&self, key: String, value: &'a str) {
        self.data.borrow_mut().insert(key, value);
    }
    
    fn get(&self, key: &str) -> Option<&'a str> {
        // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å¤åˆ¶å€¼ï¼Œå› ä¸ºä¸èƒ½è¿”å› Ref çš„å¼•ç”¨
        self.data.borrow().get(key).copied()
    }
}

fn main() {
    let cache: Cache<'static> = Cache::new();
    cache.insert("key".to_string(), "static value");
    
    // âŒ ä¸èƒ½ç¼©çŸ­ç”Ÿå‘½å‘¨æœŸï¼ˆå› ä¸º RefCell ä¸å˜ï¼‰
    // let shorter_cache: Cache<'_> = cache;  // ç¼–è¯‘é”™è¯¯
    
    println!("{:?}", cache.get("key"));
}
```

**æ¡ˆä¾‹ 2: çŠ¶æ€æœº**:

```rust
use std::cell::Cell;

struct StateMachine {
    state: Cell<&'static str>,
}

impl StateMachine {
    fn new() -> Self {
        StateMachine {
            state: Cell::new("initial"),
        }
    }
    
    fn transition(&self, new_state: &'static str) {
        self.state.set(new_state);
    }
    
    fn current(&self) -> &'static str {
        self.state.get()
    }
}

fn main() {
    let sm = StateMachine::new();
    sm.transition("running");
    println!("Current state: {}", sm.current());
    
    // Cell çš„ä¸å˜æ€§ç¡®ä¿çŠ¶æ€ç”Ÿå‘½å‘¨æœŸä¸€è‡´
}
```

---

## 5. ç”Ÿå‘½å‘¨æœŸçš„å‹å˜

### 5.1 ç”Ÿå‘½å‘¨æœŸå­ç±»å‹

```rust
// 'a: 'b è¡¨ç¤º 'a è‡³å°‘å’Œ 'b ä¸€æ ·é•¿
// å³ 'a æ˜¯ 'b çš„å­ç±»å‹
fn choose<'a: 'b, 'b>(first: &'a str, _second: &'b str) -> &'b str {
    first
}

fn main() {
    let s1: &'static str = "first";
    let s2 = String::from("second");
    let result = choose(s1, &s2);
    println!("{}", result);
}
```

### 5.2 å¼•ç”¨çš„å‹å˜

```rust
use std::marker::PhantomData;

// &'a T åœ¨ 'a å’Œ T ä¸Šéƒ½æ˜¯åå˜çš„
struct Ref<'a, T: 'a> {
    reference: &'a T,
}

// &'a mut T åœ¨ 'a ä¸Šåå˜ï¼Œåœ¨ T ä¸Šä¸å˜
struct RefMut<'a, T: 'a> {
    reference: &'a mut T,
}

fn main() {
    let x = 42;
    let r = Ref { reference: &x };
    println!("Value: {}", r.reference);
}
```

### 5.3 å¤åˆç±»å‹çš„å‹å˜

```rust
// ç»“æ„ä½“çš„å‹å˜ç”±å…¶å­—æ®µå†³å®š
struct Container<'a, T> {
    data: &'a T,  // åå˜
}

struct MutContainer<'a, T> {
    data: &'a mut T,  // åœ¨ 'a ä¸Šåå˜ï¼Œåœ¨ T ä¸Šä¸å˜
}

fn main() {
    let x = String::from("data");
    let c = Container { data: &x };
    println!("{}", c.data);
}
```

### 5.4 ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å®é™…æ¡ˆä¾‹

**æ¡ˆä¾‹ 1: è¿­ä»£å™¨çš„ç”Ÿå‘½å‘¨æœŸå‹å˜**:

```rust
struct Split<'a> {
    text: &'a str,
    delimiter: char,
}

impl<'a> Split<'a> {
    fn new(text: &'a str, delimiter: char) -> Self {
        Split { text, delimiter }
    }
}

// Iterator åœ¨ç”Ÿå‘½å‘¨æœŸä¸Šåå˜
impl<'a> Iterator for Split<'a> {
    type Item = &'a str;
    
    fn next(&mut self) -> Option<Self::Item> {
        if let Some(pos) = self.text.find(self.delimiter) {
            let result = &self.text[..pos];
            self.text = &self.text[pos + 1..];
            Some(result)
        } else if !self.text.is_empty() {
            let result = self.text;
            self.text = "";
            Some(result)
        } else {
            None
        }
    }
}

fn main() {
    let text = String::from("a,b,c");
    let split = Split::new(&text, ',');
    
    for part in split {
        println!("{}", part);
    }
}
```

**æ¡ˆä¾‹ 2: æ ‘ç»“æ„çš„ç”Ÿå‘½å‘¨æœŸ**:

```rust
struct Tree<'a, T> {
    value: T,
    children: Vec<&'a Tree<'a, T>>,
}

impl<'a, T> Tree<'a, T> {
    fn new(value: T) -> Self {
        Tree {
            value,
            children: Vec::new(),
        }
    }
    
    // åœ¨ 'a ä¸Šåå˜
    fn children(&self) -> &[&'a Tree<'a, T>] {
        &self.children
    }
}

fn main() {
    let root = Tree::new(1);
    let child1 = Tree::new(2);
    let child2 = Tree::new(3);
    
    // æ³¨æ„ï¼šè¿™ä¸ªä¾‹å­ç®€åŒ–äº†ï¼Œå®é™…ä½¿ç”¨éœ€è¦æ›´å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
    println!("Root: {}", root.value);
    println!("Child count: {}", root.children().len());
}
```

### 5.5 ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å¸¸è§é”™è¯¯

**é”™è¯¯ 1: æ··æ·†ç”Ÿå‘½å‘¨æœŸé•¿åº¦**:

```rust
// âŒ é”™è¯¯ç†è§£
fn wrong_understanding<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'a: 'b,  // 'a æ¯” 'b é•¿
{
    // y  // âŒ ç¼–è¯‘é”™è¯¯ï¼šy çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½æ¯” 'a çŸ­
    x  // âœ… æ­£ç¡®
}

// âœ… æ­£ç¡®ç†è§£
fn correct_understanding<'a, 'b>(x: &'a str, y: &'b str) -> &'b str
where
    'a: 'b,  // 'a æ¯” 'b é•¿ï¼Œæ‰€ä»¥ &'a str <: &'b str
{
    x  // âœ… å¯ä»¥ç¼©çŸ­ç”Ÿå‘½å‘¨æœŸ
}
```

**é”™è¯¯ 2: ä¸ç†è§£å¯å˜å¼•ç”¨çš„ä¸å˜æ€§**:

```rust
fn demonstrate_mut_invariance() {
    let mut s1: &'static str = "static";
    let s2 = String::from("temporary");
    
    // âŒ æƒ³è¦ç¼©çŸ­ç”Ÿå‘½å‘¨æœŸ
    // let r: &mut &str = &mut s1;
    // *r = &s2;  // å¦‚æœå…è®¸ï¼Œä¼šåˆ›å»ºæ‚¬å‚æŒ‡é’ˆ
}
```

### 5.6 ç”Ÿå‘½å‘¨æœŸå‹å˜ä¸æ³›å‹çš„ç»„åˆ

**å¤æ‚å‹å˜åœºæ™¯**:

```rust
use std::marker::PhantomData;

// åœ¨å¤šä¸ªç»´åº¦ä¸Šçš„å‹å˜
struct Complex<'a, 'b, T, U> {
    a_ref: &'a T,           // åœ¨ 'a å’Œ T ä¸Šåå˜
    b_mut_ref: &'b mut U,   // åœ¨ 'b ä¸Šåå˜ï¼Œåœ¨ U ä¸Šä¸å˜
    _phantom: PhantomData<fn(&'a T, &'b U)>,
}

impl<'a, 'b, T, U> Complex<'a, 'b, T, U> {
    fn new(a: &'a T, b: &'b mut U) -> Self {
        Complex {
            a_ref: a,
            b_mut_ref: b,
            _phantom: PhantomData,
        }
    }
    
    fn get_a(&self) -> &'a T {
        self.a_ref
    }
    
    fn get_b_mut(&mut self) -> &mut U {
        self.b_mut_ref
    }
}

fn main() {
    let x = 42;
    let mut y = String::from("hello");
    
    let complex = Complex::new(&x, &mut y);
    println!("A: {}", complex.get_a());
}
```

---

## 6. PhantomData

### 6.1 å‹å˜æ ‡è®°

**æ˜¾å¼æ ‡è®°å‹å˜**:

```rust
use std::marker::PhantomData;

// ä¸æŒæœ‰ Tï¼Œä½†è¡¨ç°å¾—åƒæŒæœ‰ T
struct MyType<T> {
    _marker: PhantomData<T>,
}

// åå˜æ ‡è®°
struct CovariantType<T> {
    _marker: PhantomData<fn() -> T>,
}

// é€†å˜æ ‡è®°
struct ContravariantType<T> {
    _marker: PhantomData<fn(T)>,
}

// ä¸å˜æ ‡è®°
struct InvariantType<T> {
    _marker: PhantomData<fn(T) -> T>,
}

fn main() {
    let _: MyType<i32> = MyType {
        _marker: PhantomData,
    };
}
```

### 6.2 Drop Check

**Drop Check å’Œå‹å˜**:

```rust
use std::marker::PhantomData;

struct Inspector<'a, T: 'a> {
    _data: PhantomData<&'a T>,
}

impl<'a, T> Drop for Inspector<'a, T> {
    fn drop(&mut self) {
        println!("Dropping inspector");
    }
}

fn main() {
    let _inspector = Inspector::<i32> {
        _data: PhantomData,
    };
}
```

### 6.3 å®é™…åº”ç”¨

**æ‰€æœ‰æƒæ ‡è®°**:

```rust
use std::marker::PhantomData;

struct Owned<T> {
    _marker: PhantomData<T>,
}

struct Borrowed<'a, T: 'a> {
    _marker: PhantomData<&'a T>,
}

fn main() {
    let _owned: Owned<String> = Owned {
        _marker: PhantomData,
    };
}
```

---

## 7. å‹å˜è§„åˆ™è¡¨

**Rust ç±»å‹çš„å‹å˜è§„åˆ™**:

| ç±»å‹ | 'a | T |
|------|----|----|
| `&'a T` | åå˜ | åå˜ |
| `&'a mut T` | åå˜ | **ä¸å˜** |
| `*const T` | - | åå˜ |
| `*mut T` | - | **ä¸å˜** |
| `Box<T>` | - | åå˜ |
| `Vec<T>` | - | åå˜ |
| `Rc<T>` | - | åå˜ |
| `Arc<T>` | - | åå˜ |
| `Cell<T>` | - | **ä¸å˜** |
| `RefCell<T>` | - | **ä¸å˜** |
| `UnsafeCell<T>` | - | **ä¸å˜** |
| `fn(T) -> U` | - | **é€†å˜**(T), åå˜(U) |

---

## 8. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: é›†åˆçš„å‹å˜

```rust
fn main() {
    // Vec åœ¨ T ä¸Šåå˜
    let static_vec: Vec<&'static str> = vec!["a", "b", "c"];
    
    fn print_vec(v: Vec<&str>) {
        for item in v {
            println!("{}", item);
        }
    }
    
    // å¯ä»¥ä¼ é€’ Vec<&'static str> åˆ°æœŸæœ› Vec<&str> çš„åœ°æ–¹
    print_vec(static_vec);
}
```

### æ¡ˆä¾‹ 2: æ™ºèƒ½æŒ‡é’ˆ

```rust
use std::rc::Rc;

struct Node<'a> {
    value: &'a str,
}

fn main() {
    let static_node = Node {
        value: "static data",
    };
    
    // Rc åœ¨ T ä¸Šåå˜
    let rc_static: Rc<Node<'static>> = Rc::new(static_node);
    let _rc_any: Rc<Node> = rc_static.clone();
}
```

### æ¡ˆä¾‹ 3: è¿­ä»£å™¨

```rust
struct Iter<'a, T> {
    slice: &'a [T],
    index: usize,
}

impl<'a, T> Iter<'a, T> {
    fn new(slice: &'a [T]) -> Self {
        Iter { slice, index: 0 }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.slice.len() {
            let item = &self.slice[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let iter = Iter::new(&data);
    
    for value in iter {
        println!("{}", value);
    }
}
```

---

## 9. å¸¸è§é™·é˜±

### 9.1 è¯¯è§£å¯å˜å¼•ç”¨çš„å‹å˜

**é™·é˜± 1: è®¤ä¸º &mut æ˜¯åå˜çš„**:

```rust
// âŒ é”™è¯¯ç†è§£ï¼šè®¤ä¸º &mut æ˜¯åå˜çš„
fn bad_example() {
    let mut s: &'static str = "hello";
    // let r: &mut &str = &mut s;  // ç¼–è¯‘é”™è¯¯ï¼
    // å¦‚æœå…è®¸ï¼Œå¯èƒ½å¯¼è‡´æ‚¬å‚å¼•ç”¨
}

// æ­£ç¡®ç†è§£ï¼š&mut T åœ¨ T ä¸Šä¸å˜
fn correct_example() {
    let mut s: &'static str = "hello";
    let r: &mut &'static str = &mut s;  // âœ… å¿…é¡»ç²¾ç¡®åŒ¹é…
    *r = "world";
    println!("{}", s);
}
```

**é™·é˜± 2: æ··æ·† `Vec<T>` å’Œ &mut [T]**:

```rust
fn vec_vs_mut_slice() {
    // Vec<T> åœ¨ T ä¸Šåå˜
    let v: Vec<&'static str> = vec!["a"];
    fn take_vec(v: Vec<&str>) {
        println!("{:?}", v);
    }
    take_vec(v);  // âœ…
    
    // ä½† &mut [T] åœ¨ T ä¸Šä¸å˜
    let mut arr: [&'static str; 1] = ["a"];
    // fn take_slice(s: &mut [&str]) {}
    // take_slice(&mut arr);  // âŒ ç¼–è¯‘é”™è¯¯
}
```

### 9.2 PhantomData ä½¿ç”¨ä¸å½“

**é™·é˜± 3: é”™è¯¯çš„ PhantomData æ ‡è®°**:

```rust
use std::marker::PhantomData;

// âŒ é”™è¯¯ï¼šä½¿ç”¨äº†é”™è¯¯çš„å‹å˜æ ‡è®°
struct WrongVariance<T> {
    ptr: *const (),
    _marker: PhantomData<T>,  // åå˜+é€†å˜=ä¸å˜
}

// âœ… æ­£ç¡®ï¼šæ˜ç¡®æŒ‡å®šåå˜
struct CorrectVariance<T> {
    ptr: *const (),
    _marker: PhantomData<fn() -> T>,  // åå˜
}

// âœ… æˆ–ä½¿ç”¨ *const T
struct AlsoCorrect<T> {
    ptr: *const (),
    _marker: PhantomData<*const T>,  // åå˜
}
```

**é™·é˜± 4: å¿˜è®° PhantomData çš„ Drop Check å½±å“**:

```rust
use std::marker::PhantomData;

// âŒ å¯èƒ½å¯¼è‡´é—®é¢˜
struct MaybeUnsafe<'a, T> {
    data: *const T,
    _phantom: PhantomData<&'a T>,  // Drop check ä¼šæ£€æŸ¥ 'a
}

// âœ… å¦‚æœç¡®å®ä¸éœ€è¦ drop check
struct SafeVersion<'a, T> {
    data: *const T,
    _phantom: PhantomData<&'a ()>,  // åªæ ‡è®°ç”Ÿå‘½å‘¨æœŸ
}
```

### 9.3 Drop å’Œå‹å˜å†²çª

**é™·é˜± 5: Dropå®ç°å½±å“å‹å˜**:

```rust
// Drop å®ç°å¯èƒ½å½±å“å‹å˜è§„åˆ™
struct Wrapper<'a, T: 'a> {
    data: &'a T,
}

// Drop ä¼šå½±å“ borrow checker çš„æ¨æ–­
impl<'a, T> Drop for Wrapper<'a, T> {
    fn drop(&mut self) {
        println!("Dropping wrapper");
    }
}

fn demonstrate_drop_issue() {
    let x = 42;
    let wrapper = Wrapper { data: &x };
    // wrapper çš„ drop ä¼šåœ¨ x ä¹‹å‰è°ƒç”¨
    // å¦‚æœ drop è®¿é—® data, å¿…é¡»ä¿è¯ x è¿˜æ´»ç€
}

fn main() {
    demonstrate_drop_issue();
}
```

**é™·é˜± 6: Drop Check çš„å¾®å¦™ä¹‹å¤„**:

```rust
use std::marker::PhantomData;

struct Container<'a, T> {
    data: *const T,
    _phantom: PhantomData<&'a T>,
}

impl<'a, T> Drop for Container<'a, T> {
    fn drop(&mut self) {
        // å¦‚æœè¿™é‡Œè®¿é—® *self.dataï¼Œå¿…é¡»ä¿è¯ T è¿˜æ´»ç€
        println!("Dropping container");
    }
}

fn may_dangle_example() {
    let x = String::from("data");
    let _container = Container {
        data: &x as *const String,
        _phantom: PhantomData,
    };
    // drop é¡ºåºï¼šcontainer å…ˆäº x
}

fn main() {
    may_dangle_example();
}
```

### 9.4 ç”Ÿå‘½å‘¨æœŸå‹å˜çš„å¸¸è§é”™è¯¯

**é™·é˜± 7: è¿‡åº¦çº¦æŸç”Ÿå‘½å‘¨æœŸ**:

```rust
// âŒ è¿‡åº¦çº¦æŸ
fn bad<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'a: 'b,
    'b: 'a,  // è¦æ±‚ 'a == 'bï¼Œè¿‡äºä¸¥æ ¼
{
    x
}

// âœ… åˆç†çº¦æŸ
fn good<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'a: 'b,  // åªè¦æ±‚ 'a è‡³å°‘å’Œ 'b ä¸€æ ·é•¿
{
    x
}
```

**é™·é˜± 8: æ··æ·†åå˜å’Œé€†å˜**:

```rust
// åå˜ï¼šä¿æŒå…³ç³»
fn covariant_example<'a>(f: impl Fn() -> &'a str) {
    // å¦‚æœ 'static: 'a, åˆ™ fn() -> &'static str <: fn() -> &'a str
}

// é€†å˜ï¼šåè½¬å…³ç³»
fn contravariant_example<'a>(f: impl Fn(&'a str)) {
    // å¦‚æœ 'static: 'a, åˆ™ fn(&'a str) <: fn(&'static str)
}
```

### 9.5 Cell å’Œ RefCell çš„å‹å˜é™·é˜±

**é™·é˜± 9: è¯¯ä»¥ä¸º Cell åå˜**:

```rust
use std::cell::Cell;

fn cell_trap() {
    let cell: Cell<&'static str> = Cell::new("static");
    
    // âŒ æƒ³è¦åå˜
    // fn shrink_lifetime<'a>(c: Cell<&'a str>) {
    //     let short = String::from("temporary");
    //     c.set(&short);  // å±é™©ï¼
    // }
    // shrink_lifetime(cell);  // ç¼–è¯‘é”™è¯¯ï¼ˆå¹¸å¥½ï¼‰
}
```

**é™·é˜± 10: RefCell å€Ÿç”¨è§„åˆ™å’Œå‹å˜**:

```rust
use std::cell::RefCell;

fn refcell_trap() {
    let cell: RefCell<&'static str> = RefCell::new("static");
    
    // âŒ å°è¯•ä¿®æ”¹ä¸ºçŸ­ç”Ÿå‘½å‘¨æœŸ
    {
        let temp = String::from("temp");
        let mut borrow = cell.borrow_mut();
        // *borrow = &temp;  // ç±»å‹ä¸åŒ¹é…
    }
    
    println!("{}", cell.borrow());
}

fn main() {
    refcell_trap();
}
```

### 9.6 è°ƒè¯•å‹å˜é—®é¢˜çš„æŠ€å·§

**æŠ€å·§ 1: æ˜¾å¼æ ‡æ³¨æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ**:

```rust
// å½“ç¼–è¯‘å™¨æŠ¥é”™æ—¶ï¼Œæ˜¾å¼æ ‡æ³¨æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ
fn debug_variance<'a, 'b, 'c>(
    x: &'a str,
    y: &'b str,
) -> &'c str
where
    'a: 'c,
    'b: 'c,
{
    if x.len() > y.len() { x } else { y }
}
```

**æŠ€å·§ 2: ä½¿ç”¨ç¼–è¯‘å™¨é”™è¯¯ä¿¡æ¯**:

```rust
// ç¼–è¯‘å™¨ä¼šæ˜ç¡®æŒ‡å‡ºå‹å˜é—®é¢˜
fn use_compiler_help() {
    let mut s: &'static str = "hello";
    // let r: &mut &str = &mut s;
    // é”™è¯¯ä¿¡æ¯ä¼šè§£é‡Šä¸ºä»€ä¹ˆ &mut ä¸æ˜¯åå˜çš„
}
```

**æŠ€å·§ 3: ç®€åŒ–ç±»å‹ä»¥ç†è§£é—®é¢˜**:

```rust
// å¤æ‚ç±»å‹å‡ºé—®é¢˜æ—¶ï¼Œé€æ­¥ç®€åŒ–
fn simplify_to_understand() {
    // ä»ç®€å•æƒ…å†µå¼€å§‹
    let _: Box<&'static str> = Box::new("hello");  // âœ…
    let _: Vec<&'static str> = vec!["hello"];      // âœ…
    
    // ç„¶åé€æ­¥å¢åŠ å¤æ‚æ€§
    let _: Vec<Box<&'static str>> = vec![Box::new("hello")];  // âœ…
}
```

---

## 10. æ€»ç»“

**æ ¸å¿ƒè¦ç‚¹**:

1. **å‹å˜ç±»å‹**
   - åå˜ï¼šä¿æŒå­ç±»å‹å…³ç³»
   - é€†å˜ï¼šåè½¬å­ç±»å‹å…³ç³»
   - ä¸å˜ï¼šä¸å…è®¸æ›¿æ¢

2. **ç”Ÿå‘½å‘¨æœŸ**
   - `&'a T` åœ¨ä¸¤è€…ä¸Šåå˜
   - `&'a mut T` åœ¨ `'a` ä¸Šåå˜ï¼Œåœ¨ `T` ä¸Šä¸å˜

3. **å®‰å…¨æ€§**
   - ä¸å˜ä¿è¯å†…å­˜å®‰å…¨
   - é˜²æ­¢æ‚¬å‚å¼•ç”¨

4. **PhantomData**
   - æ ‡è®°å‹å˜è¡Œä¸º
   - å½±å“ Drop Check

**è®°å¿†æ³•åˆ™**:

- âœ… åªè¯» â†’ åå˜
- âš ï¸ å¯å†™ â†’ ä¸å˜
- ğŸ”„ å‡½æ•°å‚æ•° â†’ é€†å˜

---

## 11. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rustonomicon - Subtyping and Variance](https://doc.rust-lang.org/nomicon/subtyping.html)
- [Rust Reference - Variance](https://doc.rust-lang.org/reference/subtyping.html)

**ç›¸å…³æ–‡æ¡£**:

- [2.3 æ³›å‹ç¼–ç¨‹æŒ‡å—](../tier_02_guides/03_æ³›å‹ç¼–ç¨‹æŒ‡å—.md)
- [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)
- [3.1 ç±»å‹è½¬æ¢å‚è€ƒ](./01_ç±»å‹è½¬æ¢å‚è€ƒ.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆç±»å‹å‹å˜å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
