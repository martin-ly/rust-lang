# 3.4 Rust ç±»å‹ç³»ç»Ÿ - å®‰å…¨æ€§å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹ç³»ç»Ÿå®‰å…¨æ€§å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.1 åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md), [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.4 Rust ç±»å‹ç³»ç»Ÿ - å®‰å…¨æ€§å‚è€ƒ](#34-rust-ç±»å‹ç³»ç»Ÿ---å®‰å…¨æ€§å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. ç±»å‹å®‰å…¨](#1-ç±»å‹å®‰å…¨)
    - [1.1 æ ¸å¿ƒåŸåˆ™](#11-æ ¸å¿ƒåŸåˆ™)
    - [1.2 å¼ºç±»å‹ç³»ç»Ÿ](#12-å¼ºç±»å‹ç³»ç»Ÿ)
    - [1.3 ç±»å‹æ¨æ–­](#13-ç±»å‹æ¨æ–­)
  - [2. å†…å­˜å®‰å…¨](#2-å†…å­˜å®‰å…¨)
    - [2.1 æ‰€æœ‰æƒç³»ç»Ÿ](#21-æ‰€æœ‰æƒç³»ç»Ÿ)
    - [2.2 å€Ÿç”¨æ£€æŸ¥](#22-å€Ÿç”¨æ£€æŸ¥)
    - [2.3 ç”Ÿå‘½å‘¨æœŸ](#23-ç”Ÿå‘½å‘¨æœŸ)
  - [3. çº¿ç¨‹å®‰å…¨](#3-çº¿ç¨‹å®‰å…¨)
    - [3.1 Send å’Œ Sync](#31-send-å’Œ-sync)
    - [3.2 æ•°æ®ç«äº‰ä¿æŠ¤](#32-æ•°æ®ç«äº‰ä¿æŠ¤)
    - [3.3 å¹¶å‘åŸè¯­](#33-å¹¶å‘åŸè¯­)
  - [4. ç©ºæŒ‡é’ˆå®‰å…¨](#4-ç©ºæŒ‡é’ˆå®‰å…¨)
    - [4.1 Option ç±»å‹](#41-option-ç±»å‹)
    - [4.2 Result ç±»å‹](#42-result-ç±»å‹)
    - [4.3 æ¶ˆé™¤ null](#43-æ¶ˆé™¤-null)
  - [5. å†…å­˜å¸ƒå±€å®‰å…¨](#5-å†…å­˜å¸ƒå±€å®‰å…¨)
    - [5.1 Sized å’Œ DST](#51-sized-å’Œ-dst)
    - [5.2 å¯¹é½å’Œå¡«å……](#52-å¯¹é½å’Œå¡«å……)
    - [5.3 repr å±æ€§](#53-repr-å±æ€§)
  - [6. Unsafe è¾¹ç•Œ](#6-unsafe-è¾¹ç•Œ)
    - [6.1 Unsafe æ“ä½œ](#61-unsafe-æ“ä½œ)
    - [6.2 å®‰å…¨æŠ½è±¡](#62-å®‰å…¨æŠ½è±¡)
    - [6.3 æœ€ä½³å®è·µ](#63-æœ€ä½³å®è·µ)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: ç±»å‹å®‰å…¨çš„ API](#æ¡ˆä¾‹-1-ç±»å‹å®‰å…¨çš„-api)
    - [æ¡ˆä¾‹ 2: å†…å­˜å®‰å…¨çš„ç¼“å†²åŒº](#æ¡ˆä¾‹-2-å†…å­˜å®‰å…¨çš„ç¼“å†²åŒº)
    - [æ¡ˆä¾‹ 3: çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨](#æ¡ˆä¾‹-3-çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨)
  - [8. å¸¸è§å®‰å…¨é™·é˜±](#8-å¸¸è§å®‰å…¨é™·é˜±)
  - [9. æ€»ç»“](#9-æ€»ç»“)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust çš„ç±»å‹ç³»ç»Ÿæä¾›äº†**ä¸‰å¤§å®‰å…¨ä¿è¯**ï¼š

| å®‰å…¨ç±»å‹ | ä¿è¯ | æœºåˆ¶ |
|---------|------|------|
| **ç±»å‹å®‰å…¨** | é˜²æ­¢ç±»å‹é”™è¯¯ | å¼ºç±»å‹ç³»ç»Ÿ + ç±»å‹æ£€æŸ¥ |
| **å†…å­˜å®‰å…¨** | é˜²æ­¢å†…å­˜é”™è¯¯ | æ‰€æœ‰æƒ + å€Ÿç”¨æ£€æŸ¥ + ç”Ÿå‘½å‘¨æœŸ |
| **çº¿ç¨‹å®‰å…¨** | é˜²æ­¢æ•°æ®ç«äº‰ | Send/Sync + å€Ÿç”¨è§„åˆ™ |

---

## 1. ç±»å‹å®‰å…¨

### 1.1 æ ¸å¿ƒåŸåˆ™

**ç±»å‹å®‰å…¨**ï¼šé˜²æ­¢åœ¨è¿è¡Œæ—¶å‡ºç°ç±»å‹é”™è¯¯ã€‚

```rust
fn main() {
    let x: i32 = 42;
    
    // âœ… ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶æ£€æŸ¥
    let y: i32 = x + 10;
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // let z: String = x;
    
    // âœ… éœ€è¦æ˜¾å¼è½¬æ¢
    let z: String = x.to_string();
    
    println!("y: {}, z: {}", y, z);
}
```

### 1.2 å¼ºç±»å‹ç³»ç»Ÿ

**æ²¡æœ‰éšå¼è½¬æ¢**:

```rust
fn process_number(n: i32) {
    println!("Number: {}", n);
}

fn main() {
    let x: i32 = 42;
    process_number(x);  // âœ…
    
    // âŒ å³ä½¿æ˜¯å…¼å®¹çš„æ•°å€¼ç±»å‹ä¹Ÿä¸èƒ½éšå¼è½¬æ¢
    // let y: i64 = 42;
    // process_number(y);  // ç¼–è¯‘é”™è¯¯
    
    // âœ… éœ€è¦æ˜¾å¼è½¬æ¢
    let y: i64 = 42;
    process_number(y as i32);
}
```

### 1.3 ç±»å‹æ¨æ–­

**ç¼–è¯‘æ—¶æ¨æ–­**:

```rust
fn main() {
    // ç¼–è¯‘å™¨æ¨æ–­ç±»å‹
    let x = 42;          // i32
    let y = 3.14;        // f64
    let z = "hello";     // &str
    let v = vec![1, 2];  // Vec<i32>
    
    // éœ€è¦ç±»å‹æ³¨è§£çš„æƒ…å†µ
    let numbers: Vec<i32> = Vec::new();
    
    // æ³›å‹éœ€è¦æ˜ç¡®ç±»å‹
    let parsed: i32 = "42".parse().unwrap();
    
    println!("{} {} {} {:?} {:?} {}", x, y, z, v, numbers, parsed);
}
```

---

## 2. å†…å­˜å®‰å…¨

### 2.1 æ‰€æœ‰æƒç³»ç»Ÿ

**é˜²æ­¢é‡å¤é‡Šæ”¾å’Œä½¿ç”¨åé‡Šæ”¾**:

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 moved
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šs1 å·²è¢«ç§»åŠ¨
    // println!("{}", s1);
    
    println!("{}", s2);  // âœ…
    
    // é˜²æ­¢åŒé‡é‡Šæ”¾
} // s2 dropped, s1 å·²å¤±æ•ˆ
```

**é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ**:

```rust
fn main() {
    let reference;
    {
        let value = String::from("hello");
        // âŒ ç¼–è¯‘é”™è¯¯ï¼švalue ç”Ÿå‘½å‘¨æœŸä¸å¤Ÿé•¿
        // reference = &value;
    }
    // println!("{}", reference);  // æ‚¬å‚æŒ‡é’ˆï¼
}
```

### 2.2 å€Ÿç”¨æ£€æŸ¥

**å€Ÿç”¨è§„åˆ™**:

1. ä»»æ„å¤šä¸ªä¸å¯å˜å¼•ç”¨ **æˆ–** ä¸€ä¸ªå¯å˜å¼•ç”¨
2. å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„

```rust
fn main() {
    let mut s = String::from("hello");
    
    // âœ… å¤šä¸ªä¸å¯å˜å¼•ç”¨
    let r1 = &s;
    let r2 = &s;
    println!("{} {}", r1, r2);
    
    // âŒ ä¸èƒ½åŒæ—¶æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨
    // let r3 = &mut s;
    // println!("{} {} {}", r1, r2, r3);
    
    // âœ… ä¸å¯å˜å¼•ç”¨ä½œç”¨åŸŸç»“æŸåå¯ä»¥åˆ›å»ºå¯å˜å¼•ç”¨
    let r3 = &mut s;
    r3.push_str(" world");
    println!("{}", r3);
}
```

### 2.3 ç”Ÿå‘½å‘¨æœŸ

**ç”Ÿå‘½å‘¨æœŸæ³¨è§£**:

```rust
// æ˜ç¡®å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string");
    {
        let string2 = String::from("short");
        let result = longest(&string1, &string2);
        println!("Longest: {}", result);
    }
    
    // âŒ å¦‚æœè¿”å›å€¼è¦åœ¨è¿™é‡Œä½¿ç”¨ä¼šç¼–è¯‘é”™è¯¯
    // println!("Longest: {}", result);
}
```

---

## 3. çº¿ç¨‹å®‰å…¨

### 3.1 Send å’Œ Sync

**å®šä¹‰**:

```rust
// Send: å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´ä¼ é€’æ‰€æœ‰æƒ
pub unsafe auto trait Send {}

// Sync: å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´å…±äº«å¼•ç”¨
pub unsafe auto trait Sync {}

// T: Sync â‡” &T: Send
```

**ç¤ºä¾‹**:

```rust
use std::thread;

fn main() {
    // âœ… i32 å®ç°äº† Send
    let number = 42;
    let handle = thread::spawn(move || {
        println!("Number: {}", number);
    });
    handle.join().unwrap();
    
    // âœ… String å®ç°äº† Send
    let s = String::from("hello");
    let handle = thread::spawn(move || {
        println!("String: {}", s);
    });
    handle.join().unwrap();
}
```

**ä¸æ»¡è¶³ Send/Sync çš„ç±»å‹**:

```rust
use std::rc::Rc;
use std::cell::RefCell;
use std::thread;

fn main() {
    // âŒ Rc ä¸æ˜¯ Send
    // let rc = Rc::new(42);
    // thread::spawn(move || {
    //     println!("{}", *rc);
    // });
    
    // âœ… ä½¿ç”¨ Arc (Atomic Rc)
    use std::sync::Arc;
    let arc = Arc::new(42);
    let arc_clone = arc.clone();
    thread::spawn(move || {
        println!("{}", *arc_clone);
    }).join().unwrap();
}
```

### 3.2 æ•°æ®ç«äº‰ä¿æŠ¤

**Mutex å’Œ RwLock**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

### 3.3 å¹¶å‘åŸè¯­

**åŸå­ç±»å‹**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", counter.load(Ordering::SeqCst));
}
```

---

## 4. ç©ºæŒ‡é’ˆå®‰å…¨

### 4.1 Option ç±»å‹

**æ¶ˆé™¤ null**:

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn main() {
    match find_user(1) {
        Some(name) => println!("Found: {}", name),
        None => println!("Not found"),
    }
    
    // âŒ ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œå¿…é¡»å¤„ç† None
    // let name = find_user(2);
    // println!("{}", name);  // ç¼–è¯‘é”™è¯¯
    
    // âœ… ä½¿ç”¨ unwrap_or
    let name = find_user(2).unwrap_or(String::from("Guest"));
    println!("{}", name);
}
```

### 4.2 Result ç±»å‹

**é”™è¯¯å¤„ç†**:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file("data.txt") {
        Ok(contents) => println!("Contents: {}", contents),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 4.3 æ¶ˆé™¤ null

**ç±»å‹ç³»ç»Ÿä¿è¯**:

```rust
// Rust æ²¡æœ‰ null
// æ‰€æœ‰å¼•ç”¨éƒ½å¿…é¡»æŒ‡å‘æœ‰æ•ˆæ•°æ®

fn main() {
    // âœ… å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„
    let x = 42;
    let r = &x;
    println!("{}", r);
    
    // âœ… ä½¿ç”¨ Option è¡¨ç¤ºå¯èƒ½ä¸å­˜åœ¨çš„å€¼
    let maybe_value: Option<i32> = Some(42);
    if let Some(value) = maybe_value {
        println!("{}", value);
    }
}
```

---

## 5. å†…å­˜å¸ƒå±€å®‰å…¨

### 5.1 Sized å’Œ DST

**Sized trait**:

```rust
// å¤§å¤šæ•°ç±»å‹éƒ½æ˜¯ Sized
fn process<T: Sized>(value: T) {
    // T çš„å¤§å°åœ¨ç¼–è¯‘æ—¶å·²çŸ¥
}

// DST (Dynamically Sized Types)
fn process_slice(slice: &[i32]) {
    // [i32] æ˜¯ DSTï¼Œå¤§å°åœ¨è¿è¡Œæ—¶ç¡®å®š
    println!("Length: {}", slice.len());
}

fn main() {
    process(42);
    process("hello");
    
    process_slice(&[1, 2, 3]);
}
```

### 5.2 å¯¹é½å’Œå¡«å……

**å†…å­˜å¯¹é½**:

```rust
use std::mem;

#[repr(C)]
struct Point {
    x: i32,  // 4 bytes
    y: i32,  // 4 bytes
}

#[repr(C)]
struct Mixed {
    a: u8,   // 1 byte
    // 3 bytes padding
    b: u32,  // 4 bytes
    c: u16,  // 2 bytes
    // 2 bytes padding
}

fn main() {
    println!("Point size: {}", mem::size_of::<Point>());     // 8
    println!("Point align: {}", mem::align_of::<Point>());   // 4
    
    println!("Mixed size: {}", mem::size_of::<Mixed>());     // 12
    println!("Mixed align: {}", mem::align_of::<Mixed>());   // 4
}
```

### 5.3 repr å±æ€§

**æ§åˆ¶å†…å­˜å¸ƒå±€**:

```rust
// Rust é»˜è®¤å¸ƒå±€ï¼ˆå¯ä¼˜åŒ–ï¼‰
struct DefaultRepr {
    a: u8,
    b: u32,
    c: u16,
}

// C å…¼å®¹å¸ƒå±€
#[repr(C)]
struct CRepr {
    a: u8,
    b: u32,
    c: u16,
}

// ç´§å‡‘å¸ƒå±€
#[repr(packed)]
struct PackedRepr {
    a: u8,
    b: u32,
    c: u16,
}

// å¯¹é½åˆ°æŒ‡å®šå­—èŠ‚
#[repr(align(16))]
struct AlignedRepr {
    a: u8,
}

fn main() {
    use std::mem::size_of;
    
    println!("Default: {}", size_of::<DefaultRepr>());  // ä¼˜åŒ–åå¯èƒ½æ˜¯ 8
    println!("C: {}", size_of::<CRepr>());              // 12 (å¸¦å¡«å……)
    println!("Packed: {}", size_of::<PackedRepr>());    // 7 (æ— å¡«å……)
    println!("Aligned: {}", size_of::<AlignedRepr>());  // 16
}
```

---

## 6. Unsafe è¾¹ç•Œ

### 6.1 Unsafe æ“ä½œ

**äº”ç§ unsafe æ“ä½œ**:

1. è§£å¼•ç”¨è£¸æŒ‡é’ˆ
2. è°ƒç”¨ unsafe å‡½æ•°
3. è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
4. å®ç° unsafe trait
5. è®¿é—® union å­—æ®µ

```rust
fn main() {
    let x = 42;
    let ptr = &x as *const i32;
    
    // âŒ ä¸èƒ½åœ¨å®‰å…¨ä»£ç ä¸­è§£å¼•ç”¨è£¸æŒ‡é’ˆ
    // let value = *ptr;
    
    // âœ… å¿…é¡»åœ¨ unsafe å—ä¸­
    unsafe {
        let value = *ptr;
        println!("Value: {}", value);
    }
}
```

### 6.2 å®‰å…¨æŠ½è±¡

**å°è£… unsafe**:

```rust
pub struct SafeVec<T> {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

impl<T> SafeVec<T> {
    pub fn new() -> Self {
        SafeVec {
            ptr: std::ptr::null_mut(),
            len: 0,
            cap: 0,
        }
    }
    
    // å®‰å…¨çš„å…¬å…± API
    pub fn push(&mut self, value: T) {
        // å†…éƒ¨ä½¿ç”¨ unsafeï¼Œä½†æ¥å£æ˜¯å®‰å…¨çš„
        unsafe {
            // ... unsafe å®ç° ...
        }
    }
    
    // å®‰å…¨çš„å…¬å…± API
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < self.len {
            unsafe {
                Some(&*self.ptr.add(index))
            }
        } else {
            None
        }
    }
}

fn main() {
    let mut vec = SafeVec::new();
    vec.push(42);  // âœ… å®‰å…¨è°ƒç”¨
    
    if let Some(value) = vec.get(0) {
        println!("Value: {}", value);
    }
}
```

### 6.3 æœ€ä½³å®è·µ

**æœ€å°åŒ– unsafe**:

```rust
// âœ… å¥½ï¼šunsafe é™åˆ¶åœ¨å°èŒƒå›´
fn safe_wrapper(data: &[u8]) -> u32 {
    assert!(data.len() >= 4);
    unsafe {
        // åªæœ‰å¿…è¦çš„ unsafe æ“ä½œ
        *(data.as_ptr() as *const u32)
    }
}

// âŒ åï¼šæ•´ä¸ªå‡½æ•°éƒ½æ˜¯ unsafe
unsafe fn bad_wrapper(data: &[u8]) -> u32 {
    // ä¸å¿…è¦åœ°å°†æ•´ä¸ªå‡½æ•°æ ‡è®°ä¸º unsafe
    let value = *(data.as_ptr() as *const u32);
    value + 10  // è¿™éƒ¨åˆ†ä¸éœ€è¦ unsafe
}

fn main() {
    let data = [1, 2, 3, 4];
    let value = safe_wrapper(&data);
    println!("Value: {}", value);
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: ç±»å‹å®‰å…¨çš„ API

```rust
use std::marker::PhantomData;

// çŠ¶æ€ç±»å‹
struct Draft;
struct Published;

// æ–‡æ¡£ç±»å‹ï¼Œä½¿ç”¨çŠ¶æ€æ ‡è®°
struct Document<State> {
    content: String,
    _state: PhantomData<State>,
}

impl Document<Draft> {
    fn new(content: String) -> Self {
        Document {
            content,
            _state: PhantomData,
        }
    }
    
    fn edit(&mut self, new_content: String) {
        self.content = new_content;
    }
    
    fn publish(self) -> Document<Published> {
        Document {
            content: self.content,
            _state: PhantomData,
        }
    }
}

impl Document<Published> {
    fn view(&self) -> &str {
        &self.content
    }
    
    // å·²å‘å¸ƒçš„æ–‡æ¡£ä¸èƒ½ç¼–è¾‘
    // fn edit(&mut self, new_content: String) {}  // ä¸æä¾›æ­¤æ–¹æ³•
}

fn main() {
    let mut draft = Document::<Draft>::new(String::from("Initial content"));
    draft.edit(String::from("Updated content"));
    
    let published = draft.publish();
    println!("Published: {}", published.view());
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šå·²å‘å¸ƒçš„æ–‡æ¡£ä¸èƒ½ç¼–è¾‘
    // published.edit(String::from("Cannot edit"));
}
```

### æ¡ˆä¾‹ 2: å†…å­˜å®‰å…¨çš„ç¼“å†²åŒº

```rust
struct SafeBuffer {
    data: Vec<u8>,
    read_pos: usize,
}

impl SafeBuffer {
    fn new(capacity: usize) -> Self {
        SafeBuffer {
            data: Vec::with_capacity(capacity),
            read_pos: 0,
        }
    }
    
    fn write(&mut self, bytes: &[u8]) {
        self.data.extend_from_slice(bytes);
    }
    
    fn read(&mut self, len: usize) -> Option<&[u8]> {
        if self.read_pos + len <= self.data.len() {
            let slice = &self.data[self.read_pos..self.read_pos + len];
            self.read_pos += len;
            Some(slice)
        } else {
            None
        }
    }
}

fn main() {
    let mut buffer = SafeBuffer::new(1024);
    
    buffer.write(b"Hello, ");
    buffer.write(b"World!");
    
    if let Some(data) = buffer.read(5) {
        println!("Read: {:?}", std::str::from_utf8(data).unwrap());
    }
    
    // ä¸ä¼šå‘ç”Ÿç¼“å†²åŒºæº¢å‡º
    if let Some(data) = buffer.read(100) {
        println!("Read: {:?}", data);
    } else {
        println!("Not enough data");
    }
}
```

### æ¡ˆä¾‹ 3: çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct ThreadSafeCounter {
    value: Arc<Mutex<i32>>,
}

impl ThreadSafeCounter {
    fn new() -> Self {
        ThreadSafeCounter {
            value: Arc::new(Mutex::new(0)),
        }
    }
    
    fn increment(&self) {
        let mut value = self.value.lock().unwrap();
        *value += 1;
    }
    
    fn get(&self) -> i32 {
        *self.value.lock().unwrap()
    }
    
    fn clone_counter(&self) -> Self {
        ThreadSafeCounter {
            value: Arc::clone(&self.value),
        }
    }
}

fn main() {
    let counter = ThreadSafeCounter::new();
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = counter.clone_counter();
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter_clone.increment();
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final count: {}", counter.get());
}
```

---

## 8. å¸¸è§å®‰å…¨é™·é˜±

**é™·é˜± 1: ç”Ÿå‘½å‘¨æœŸæ¨æ–­é”™è¯¯**:

```rust
// âŒ é”™è¯¯
// fn longest(x: &str, y: &str) -> &str {
//     if x.len() > y.len() { x } else { y }
// }

// âœ… æ­£ç¡®ï¼šæ˜ç¡®ç”Ÿå‘½å‘¨æœŸ
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

**é™·é˜± 2: å¯å˜æ€§å’Œä¸å¯å˜æ€§æ··ç”¨**:

```rust
fn main() {
    let mut data = vec![1, 2, 3];
    let r1 = &data;
    
    // âŒ ç¼–è¯‘é”™è¯¯
    // data.push(4);
    // println!("{:?}", r1);
    
    // âœ… æ­£ç¡®ï¼šr1 ä½œç”¨åŸŸç»“æŸåå†ä¿®æ”¹
    println!("{:?}", r1);
    data.push(4);
}
```

**é™·é˜± 3: Unsafe è¾¹ç•Œæ³„æ¼**:

```rust
// âŒ åï¼šunsafe æ³„æ¼åˆ°å…¬å…± API
// pub fn bad_api(ptr: *const i32) -> i32 {
//     unsafe { *ptr }
// }

// âœ… å¥½ï¼šå°è£… unsafe
pub fn safe_api(value: &i32) -> i32 {
    // å†…éƒ¨å¯ä»¥ä½¿ç”¨ unsafeï¼Œä½†ä¸æ³„æ¼
    *value
}
```

---

## 9. æ€»ç»“

**Rust å®‰å…¨æ€§ä¿è¯**:

| å®‰å…¨ç±»å‹ | æœºåˆ¶ | é˜²æ­¢ |
|---------|------|------|
| **ç±»å‹å®‰å…¨** | å¼ºç±»å‹ + ç±»å‹æ£€æŸ¥ | ç±»å‹é”™è¯¯ |
| **å†…å­˜å®‰å…¨** | æ‰€æœ‰æƒ + å€Ÿç”¨ + ç”Ÿå‘½å‘¨æœŸ | UAF, åŒé‡é‡Šæ”¾, æ‚¬å‚æŒ‡é’ˆ |
| **çº¿ç¨‹å®‰å…¨** | Send/Sync + Mutex | æ•°æ®ç«äº‰ |
| **ç©ºæŒ‡é’ˆå®‰å…¨** | Option/Result | Null è§£å¼•ç”¨ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… é›¶æˆæœ¬æŠ½è±¡
2. âœ… ç¼–è¯‘æ—¶ä¿è¯
3. âœ… å†…å­˜å®‰å…¨æ— è¿è¡Œæ—¶å¼€é”€
4. âœ… çº¿ç¨‹å®‰å…¨å†…å»ºäºç±»å‹ç³»ç»Ÿ
5. âœ… Unsafe æœ€å°åŒ–

---

## 10. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
- [Rust Book - Fearless Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [Rustonomicon](https://doc.rust-lang.org/nomicon/)

**ç›¸å…³æ–‡æ¡£**:

- [2.1 åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)
- [3.5 æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](./05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆå®‰å…¨æ€§å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
