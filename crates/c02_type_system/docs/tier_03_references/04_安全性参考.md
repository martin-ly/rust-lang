# 3.4 Rust ç±»å‹ç³»ç»Ÿ - å®‰å…¨æ€§å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: ç±»å‹ç³»ç»Ÿå®‰å…¨æ€§å®Œæ•´å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: ä¸­çº§ â†’ é«˜çº§å¼€å‘è€…  
> **å‰ç½®çŸ¥è¯†**: [2.1 åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md), [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [3.4 Rust ç±»å‹ç³»ç»Ÿ - å®‰å…¨æ€§å‚è€ƒ](#34-rust-ç±»å‹ç³»ç»Ÿ---å®‰å…¨æ€§å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. ç±»å‹å®‰å…¨](#1-ç±»å‹å®‰å…¨)
    - [1.1 æ ¸å¿ƒåŸåˆ™](#11-æ ¸å¿ƒåŸåˆ™)
    - [1.2 å¼ºç±»å‹ç³»ç»Ÿ](#12-å¼ºç±»å‹ç³»ç»Ÿ)
    - [1.3 ç±»å‹æ¨æ–­](#13-ç±»å‹æ¨æ–­)
  - [2. å†…å­˜å®‰å…¨](#2-å†…å­˜å®‰å…¨)
    - [2.1 æ‰€æœ‰æƒç³»ç»Ÿ](#21-æ‰€æœ‰æƒç³»ç»Ÿ)
    - [2.2 å€Ÿç”¨æ£€æŸ¥](#22-å€Ÿç”¨æ£€æŸ¥)
    - [2.3 ç”Ÿå‘½å‘¨æœŸ](#23-ç”Ÿå‘½å‘¨æœŸ)
    - [2.4 ç§»åŠ¨è¯­ä¹‰ä¸å†…å­˜å®‰å…¨](#24-ç§»åŠ¨è¯­ä¹‰ä¸å†…å­˜å®‰å…¨)
    - [2.5 å†…å­˜å®‰å…¨çš„é«˜çº§æ¨¡å¼](#25-å†…å­˜å®‰å…¨çš„é«˜çº§æ¨¡å¼)
    - [2.6 å†…å­˜å®‰å…¨å®æˆ˜æ¡ˆä¾‹](#26-å†…å­˜å®‰å…¨å®æˆ˜æ¡ˆä¾‹)
  - [3. çº¿ç¨‹å®‰å…¨](#3-çº¿ç¨‹å®‰å…¨)
    - [3.1 Send å’Œ Sync](#31-send-å’Œ-sync)
    - [3.2 æ•°æ®ç«äº‰ä¿æŠ¤](#32-æ•°æ®ç«äº‰ä¿æŠ¤)
    - [3.3 å¹¶å‘åŸè¯­](#33-å¹¶å‘åŸè¯­)
    - [3.4 çº¿ç¨‹å®‰å…¨çš„é«˜çº§æ¨¡å¼](#34-çº¿ç¨‹å®‰å…¨çš„é«˜çº§æ¨¡å¼)
  - [4. ç©ºæŒ‡é’ˆå®‰å…¨](#4-ç©ºæŒ‡é’ˆå®‰å…¨)
    - [4.1 Option ç±»å‹](#41-option-ç±»å‹)
    - [4.2 Result ç±»å‹](#42-result-ç±»å‹)
    - [4.3 æ¶ˆé™¤ null](#43-æ¶ˆé™¤-null)
  - [5. å†…å­˜å¸ƒå±€å®‰å…¨](#5-å†…å­˜å¸ƒå±€å®‰å…¨)
    - [5.1 Sized å’Œ DST](#51-sized-å’Œ-dst)
    - [5.2 å¯¹é½å’Œå¡«å……](#52-å¯¹é½å’Œå¡«å……)
    - [5.3 repr å±æ€§](#53-repr-å±æ€§)
  - [6. Unsafe è¾¹ç•Œ](#6-unsafe-è¾¹ç•Œ)
    - [6.1 Unsafe æ“ä½œ](#61-unsafe-æ“ä½œ)
    - [6.2 å®‰å…¨æŠ½è±¡](#62-å®‰å…¨æŠ½è±¡)
    - [6.3 æœ€ä½³å®è·µ](#63-æœ€ä½³å®è·µ)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: ç±»å‹å®‰å…¨çš„ API](#æ¡ˆä¾‹-1-ç±»å‹å®‰å…¨çš„-api)
    - [æ¡ˆä¾‹ 2: å†…å­˜å®‰å…¨çš„ç¼“å†²åŒº](#æ¡ˆä¾‹-2-å†…å­˜å®‰å…¨çš„ç¼“å†²åŒº)
    - [æ¡ˆä¾‹ 3: çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨](#æ¡ˆä¾‹-3-çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨)
  - [8. å¸¸è§å®‰å…¨é™·é˜±](#8-å¸¸è§å®‰å…¨é™·é˜±)
  - [9. æ€»ç»“](#9-æ€»ç»“)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ¦‚è¿°

Rust çš„ç±»å‹ç³»ç»Ÿæä¾›äº†**ä¸‰å¤§å®‰å…¨ä¿è¯**ï¼š

| å®‰å…¨ç±»å‹ | ä¿è¯ | æœºåˆ¶ |
|---------|------|------|
| **ç±»å‹å®‰å…¨** | é˜²æ­¢ç±»å‹é”™è¯¯ | å¼ºç±»å‹ç³»ç»Ÿ + ç±»å‹æ£€æŸ¥ |
| **å†…å­˜å®‰å…¨** | é˜²æ­¢å†…å­˜é”™è¯¯ | æ‰€æœ‰æƒ + å€Ÿç”¨æ£€æŸ¥ + ç”Ÿå‘½å‘¨æœŸ |
| **çº¿ç¨‹å®‰å…¨** | é˜²æ­¢æ•°æ®ç«äº‰ | Send/Sync + å€Ÿç”¨è§„åˆ™ |

---

## 1. ç±»å‹å®‰å…¨

### 1.1 æ ¸å¿ƒåŸåˆ™

**ç±»å‹å®‰å…¨**ï¼šé˜²æ­¢åœ¨è¿è¡Œæ—¶å‡ºç°ç±»å‹é”™è¯¯ã€‚

```rust
fn main() {
    let x: i32 = 42;
    
    // âœ… ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶æ£€æŸ¥
    let y: i32 = x + 10;
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // let z: String = x;
    
    // âœ… éœ€è¦æ˜¾å¼è½¬æ¢
    let z: String = x.to_string();
    
    println!("y: {}, z: {}", y, z);
}
```

### 1.2 å¼ºç±»å‹ç³»ç»Ÿ

**æ²¡æœ‰éšå¼è½¬æ¢**:

```rust
fn process_number(n: i32) {
    println!("Number: {}", n);
}

fn main() {
    let x: i32 = 42;
    process_number(x);  // âœ…
    
    // âŒ å³ä½¿æ˜¯å…¼å®¹çš„æ•°å€¼ç±»å‹ä¹Ÿä¸èƒ½éšå¼è½¬æ¢
    // let y: i64 = 42;
    // process_number(y);  // ç¼–è¯‘é”™è¯¯
    
    // âœ… éœ€è¦æ˜¾å¼è½¬æ¢
    let y: i64 = 42;
    process_number(y as i32);
}
```

### 1.3 ç±»å‹æ¨æ–­

**ç¼–è¯‘æ—¶æ¨æ–­**:

```rust
fn main() {
    // ç¼–è¯‘å™¨æ¨æ–­ç±»å‹
    let x = 42;          // i32
    let y = 3.14;        // f64
    let z = "hello";     // &str
    let v = vec![1, 2];  // Vec<i32>
    
    // éœ€è¦ç±»å‹æ³¨è§£çš„æƒ…å†µ
    let numbers: Vec<i32> = Vec::new();
    
    // æ³›å‹éœ€è¦æ˜ç¡®ç±»å‹
    let parsed: i32 = "42".parse().unwrap();
    
    println!("{} {} {} {:?} {:?} {}", x, y, z, v, numbers, parsed);
}
```

---

## 2. å†…å­˜å®‰å…¨

### 2.1 æ‰€æœ‰æƒç³»ç»Ÿ

**é˜²æ­¢é‡å¤é‡Šæ”¾å’Œä½¿ç”¨åé‡Šæ”¾**:

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 moved
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šs1 å·²è¢«ç§»åŠ¨
    // println!("{}", s1);
    
    println!("{}", s2);  // âœ…
    
    // é˜²æ­¢åŒé‡é‡Šæ”¾
} // s2 dropped, s1 å·²å¤±æ•ˆ
```

**é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ**:

```rust
fn main() {
    let reference;
    {
        let value = String::from("hello");
        // âŒ ç¼–è¯‘é”™è¯¯ï¼švalue ç”Ÿå‘½å‘¨æœŸä¸å¤Ÿé•¿
        // reference = &value;
    }
    // println!("{}", reference);  // æ‚¬å‚æŒ‡é’ˆï¼
}
```

### 2.2 å€Ÿç”¨æ£€æŸ¥

**å€Ÿç”¨è§„åˆ™**:

1. ä»»æ„å¤šä¸ªä¸å¯å˜å¼•ç”¨ **æˆ–** ä¸€ä¸ªå¯å˜å¼•ç”¨
2. å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„

```rust
fn main() {
    let mut s = String::from("hello");
    
    // âœ… å¤šä¸ªä¸å¯å˜å¼•ç”¨
    let r1 = &s;
    let r2 = &s;
    println!("{} {}", r1, r2);
    
    // âŒ ä¸èƒ½åŒæ—¶æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨
    // let r3 = &mut s;
    // println!("{} {} {}", r1, r2, r3);
    
    // âœ… ä¸å¯å˜å¼•ç”¨ä½œç”¨åŸŸç»“æŸåå¯ä»¥åˆ›å»ºå¯å˜å¼•ç”¨
    let r3 = &mut s;
    r3.push_str(" world");
    println!("{}", r3);
}
```

### 2.3 ç”Ÿå‘½å‘¨æœŸ

**ç”Ÿå‘½å‘¨æœŸæ³¨è§£**:

```rust
// æ˜ç¡®å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string");
    {
        let string2 = String::from("short");
        let result = longest(&string1, &string2);
        println!("Longest: {}", result);
    }
    
    // âŒ å¦‚æœè¿”å›å€¼è¦åœ¨è¿™é‡Œä½¿ç”¨ä¼šç¼–è¯‘é”™è¯¯
    // println!("Longest: {}", result);
}
```

### 2.4 ç§»åŠ¨è¯­ä¹‰ä¸å†…å­˜å®‰å…¨

**ç§»åŠ¨vså¤åˆ¶**:

```rust
// Copyç±»å‹ï¼šæŒ‰ä½å¤åˆ¶
fn copy_semantics() {
    let x = 5;
    let y = x;  // Copy
    println!("x={}, y={}", x, y);  // ä¸¤è€…éƒ½å¯ç”¨
}

// Moveç±»å‹ï¼šæ‰€æœ‰æƒè½¬ç§»
fn move_semantics() {
    let s1 = String::from("hello");
    let s2 = s1;  // Move
    // println!("{}", s1);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šs1å·²è¢«ç§»åŠ¨
    println!("{}", s2);  // âœ…
}
```

**éƒ¨åˆ†ç§»åŠ¨**:

```rust
#[derive(Debug)]
struct Data {
    name: String,
    count: i32,
}

fn partial_move() {
    let data = Data {
        name: String::from("test"),
        count: 42,
    };
    
    let name = data.name;  // ç§»åŠ¨nameå­—æ®µ
    let count = data.count;  // Copy countå­—æ®µ
    
    // println!("{:?}", data);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šnameå·²è¢«ç§»åŠ¨
    println!("name: {}, count: {}", name, count);  // âœ…
}
```

**é¿å…æ„å¤–ç§»åŠ¨**:

```rust
fn avoid_move() {
    let s = String::from("hello");
    
    // âŒ ä¸å¥½ï¼šç§»åŠ¨åˆ°å‡½æ•°
    // takes_ownership(s);
    // println!("{}", s);  // é”™è¯¯ï¼šså·²è¢«ç§»åŠ¨
    
    // âœ… å¥½ï¼šå€Ÿç”¨
    borrows(&s);
    println!("{}", s);  // âœ… sä»ç„¶æœ‰æ•ˆ
}

fn takes_ownership(s: String) {
    println!("{}", s);
}

fn borrows(s: &String) {
    println!("{}", s);
}
```

### 2.5 å†…å­˜å®‰å…¨çš„é«˜çº§æ¨¡å¼

**æ¨¡å¼1ï¼šå†…éƒ¨å¯å˜æ€§**:

```rust
use std::cell::RefCell;

struct SafeCounter {
    count: RefCell<i32>,
}

impl SafeCounter {
    fn new() -> Self {
        SafeCounter {
            count: RefCell::new(0),
        }
    }
    
    fn increment(&self) {
        *self.count.borrow_mut() += 1;
    }
    
    fn get(&self) -> i32 {
        *self.count.borrow()
    }
}

fn main() {
    let counter = SafeCounter::new();
    counter.increment();
    println!("Count: {}", counter.get());
}
```

**æ¨¡å¼2ï¼šåŠ¨æ€åˆ†é…ä¸Box**:

```rust
// å¤§å‹æ•°æ®æ”¾åœ¨å †ä¸Š
struct LargeData([u8; 10000]);

fn use_box() {
    let large = Box::new(LargeData([0; 10000]));
    // largeå­˜å‚¨åœ¨å †ä¸Šï¼Œåªåœ¨æ ˆä¸Šä¿å­˜æŒ‡é’ˆ
    println!("Size of Box: {} bytes", std::mem::size_of_val(&large));
}
```

**æ¨¡å¼3ï¼šå¼•ç”¨è®¡æ•°ï¼ˆRc/Arcï¼‰**:

```rust
use std::rc::Rc;

fn shared_ownership() {
    let data = Rc::new(String::from("shared"));
    
    let ref1 = Rc::clone(&data);
    let ref2 = Rc::clone(&data);
    
    println!("Count: {}", Rc::strong_count(&data));  // 3
    println!("Data: {}", data);
}
```

### 2.6 å†…å­˜å®‰å…¨å®æˆ˜æ¡ˆä¾‹

**æ¡ˆä¾‹1ï¼šå®‰å…¨çš„é“¾è¡¨å®ç°**:

```rust
use std::rc::Rc;
use std::cell::RefCell;

type Link<T> = Option<Rc<RefCell<Node<T>>>>;

struct Node<T> {
    value: T,
    next: Link<T>,
}

struct LinkedList<T> {
    head: Link<T>,
}

impl<T> LinkedList<T> {
    fn new() -> Self {
        LinkedList { head: None }
    }
    
    fn push(&mut self, value: T) {
        let new_node = Rc::new(RefCell::new(Node {
            value,
            next: self.head.take(),
        }));
        self.head = Some(new_node);
    }
}
```

**æ¡ˆä¾‹2ï¼šå†…å­˜æ± ç®¡ç†**:

```rust
struct MemoryPool<T> {
    items: Vec<T>,
    free_list: Vec<usize>,
}

impl<T: Default> MemoryPool<T> {
    fn new(capacity: usize) -> Self {
        MemoryPool {
            items: (0..capacity).map(|_| T::default()).collect(),
            free_list: (0..capacity).collect(),
        }
    }
    
    fn allocate(&mut self) -> Option<&mut T> {
        self.free_list.pop().map(|idx| &mut self.items[idx])
    }
    
    fn deallocate(&mut self, item: &T) {
        // å®‰å…¨åœ°å›æ”¶å†…å­˜
        let ptr = item as *const T;
        let base = self.items.as_ptr();
        let offset = unsafe { ptr.offset_from(base) };
        if offset >= 0 && (offset as usize) < self.items.len() {
            self.free_list.push(offset as usize);
        }
    }
}
```

---

## 3. çº¿ç¨‹å®‰å…¨

### 3.1 Send å’Œ Sync

**å®šä¹‰**:

```rust
// Send: å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´ä¼ é€’æ‰€æœ‰æƒ
pub unsafe auto trait Send {}

// Sync: å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´å…±äº«å¼•ç”¨
pub unsafe auto trait Sync {}

// T: Sync â‡” &T: Send
```

**ç¤ºä¾‹**:

```rust
use std::thread;

fn main() {
    // âœ… i32 å®ç°äº† Send
    let number = 42;
    let handle = thread::spawn(move || {
        println!("Number: {}", number);
    });
    handle.join().unwrap();
    
    // âœ… String å®ç°äº† Send
    let s = String::from("hello");
    let handle = thread::spawn(move || {
        println!("String: {}", s);
    });
    handle.join().unwrap();
}
```

**ä¸æ»¡è¶³ Send/Sync çš„ç±»å‹**:

```rust
use std::rc::Rc;
use std::cell::RefCell;
use std::thread;

fn main() {
    // âŒ Rc ä¸æ˜¯ Send
    // let rc = Rc::new(42);
    // thread::spawn(move || {
    //     println!("{}", *rc);
    // });
    
    // âœ… ä½¿ç”¨ Arc (Atomic Rc)
    use std::sync::Arc;
    let arc = Arc::new(42);
    let arc_clone = arc.clone();
    thread::spawn(move || {
        println!("{}", *arc_clone);
    }).join().unwrap();
}
```

### 3.2 æ•°æ®ç«äº‰ä¿æŠ¤

**Mutex å’Œ RwLock**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

### 3.3 å¹¶å‘åŸè¯­

**åŸå­ç±»å‹**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", counter.load(Ordering::SeqCst));
}
```

### 3.4 çº¿ç¨‹å®‰å…¨çš„é«˜çº§æ¨¡å¼

**æ¨¡å¼1ï¼šæ— é”æ•°æ®ç»“æ„**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

impl<T> LockFreeStack<T> {
    fn new() -> Self {
        LockFreeStack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head.compare_exchange(
                head,
                new_node,
                Ordering::Release,
                Ordering::Acquire,
            ).is_ok() {
                break;
            }
        }
    }
}
```

**æ¨¡å¼2ï¼šè¯»å†™é”ä¼˜åŒ–**:

```rust
use std::sync::RwLock;
use std::collections::HashMap;

struct Cache<K, V> {
    data: RwLock<HashMap<K, V>>,
}

impl<K: Eq + std::hash::Hash + Clone, V: Clone> Cache<K, V> {
    fn new() -> Self {
        Cache {
            data: RwLock::new(HashMap::new()),
        }
    }
    
    fn get(&self, key: &K) -> Option<V> {
        // è¯»é”ï¼šå…è®¸å¤šä¸ªå¹¶å‘è¯»å–
        let read_guard = self.data.read().unwrap();
        read_guard.get(key).cloned()
    }
    
    fn insert(&self, key: K, value: V) {
        // å†™é”ï¼šç‹¬å è®¿é—®
        let mut write_guard = self.data.write().unwrap();
        write_guard.insert(key, value);
    }
}

fn main() {
    use std::thread;
    use std::sync::Arc;
    
    let cache = Arc::new(Cache::new());
    
    // å¤šä¸ªè¯»è€…
    let mut handles = vec![];
    for i in 0..10 {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            cache.get(&i);
        });
        handles.push(handle);
    }
    
    // ä¸€ä¸ªå†™è€…
    let cache_writer = Arc::clone(&cache);
    let writer = thread::spawn(move || {
        cache_writer.insert(42, "value");
    });
    
    for handle in handles {
        handle.join().unwrap();
    }
    writer.join().unwrap();
}
```

**æ¨¡å¼3ï¼šChannelé€šä¿¡æ¨¡å¼**:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

enum Message {
    Data(String),
    Terminate,
}

fn worker_thread_pattern() {
    let (tx, rx) = mpsc::channel();
    
    // Workerçº¿ç¨‹
    let worker = thread::spawn(move || {
        loop {
            match rx.recv() {
                Ok(Message::Data(data)) => {
                    println!("Processing: {}", data);
                    thread::sleep(Duration::from_millis(100));
                }
                Ok(Message::Terminate) | Err(_) => {
                    println!("Worker terminating");
                    break;
                }
            }
        }
    });
    
    // ä¸»çº¿ç¨‹å‘é€ä»»åŠ¡
    for i in 0..5 {
        tx.send(Message::Data(format!("Task {}", i))).unwrap();
    }
    
    tx.send(Message::Terminate).unwrap();
    worker.join().unwrap();
}
```

**æ¨¡å¼4ï¼šçº¿ç¨‹æ± æ¨¡å¼**:

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::thread;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        
        let mut workers = Vec::with_capacity(size);
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }
        
        ThreadPool { workers, sender }
    }
    
    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();
            
            match job {
                Ok(job) => {
                    println!("Worker {} executing job", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} terminating", id);
                    break;
                }
            }
        });
        
        Worker { id, thread }
    }
}
```

---

## 4. ç©ºæŒ‡é’ˆå®‰å…¨

### 4.1 Option ç±»å‹

**æ¶ˆé™¤ null**:

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))
    } else {
        None
    }
}

fn main() {
    match find_user(1) {
        Some(name) => println!("Found: {}", name),
        None => println!("Not found"),
    }
    
    // âŒ ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œå¿…é¡»å¤„ç† None
    // let name = find_user(2);
    // println!("{}", name);  // ç¼–è¯‘é”™è¯¯
    
    // âœ… ä½¿ç”¨ unwrap_or
    let name = find_user(2).unwrap_or(String::from("Guest"));
    println!("{}", name);
}
```

### 4.2 Result ç±»å‹

**é”™è¯¯å¤„ç†**:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file("data.txt") {
        Ok(contents) => println!("Contents: {}", contents),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 4.3 æ¶ˆé™¤ null

**ç±»å‹ç³»ç»Ÿä¿è¯**:

```rust
// Rust æ²¡æœ‰ null
// æ‰€æœ‰å¼•ç”¨éƒ½å¿…é¡»æŒ‡å‘æœ‰æ•ˆæ•°æ®

fn main() {
    // âœ… å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„
    let x = 42;
    let r = &x;
    println!("{}", r);
    
    // âœ… ä½¿ç”¨ Option è¡¨ç¤ºå¯èƒ½ä¸å­˜åœ¨çš„å€¼
    let maybe_value: Option<i32> = Some(42);
    if let Some(value) = maybe_value {
        println!("{}", value);
    }
}
```

---

## 5. å†…å­˜å¸ƒå±€å®‰å…¨

### 5.1 Sized å’Œ DST

**Sized trait**:

```rust
// å¤§å¤šæ•°ç±»å‹éƒ½æ˜¯ Sized
fn process<T: Sized>(value: T) {
    // T çš„å¤§å°åœ¨ç¼–è¯‘æ—¶å·²çŸ¥
}

// DST (Dynamically Sized Types)
fn process_slice(slice: &[i32]) {
    // [i32] æ˜¯ DSTï¼Œå¤§å°åœ¨è¿è¡Œæ—¶ç¡®å®š
    println!("Length: {}", slice.len());
}

fn main() {
    process(42);
    process("hello");
    
    process_slice(&[1, 2, 3]);
}
```

### 5.2 å¯¹é½å’Œå¡«å……

**å†…å­˜å¯¹é½**:

```rust
use std::mem;

#[repr(C)]
struct Point {
    x: i32,  // 4 bytes
    y: i32,  // 4 bytes
}

#[repr(C)]
struct Mixed {
    a: u8,   // 1 byte
    // 3 bytes padding
    b: u32,  // 4 bytes
    c: u16,  // 2 bytes
    // 2 bytes padding
}

fn main() {
    println!("Point size: {}", mem::size_of::<Point>());     // 8
    println!("Point align: {}", mem::align_of::<Point>());   // 4
    
    println!("Mixed size: {}", mem::size_of::<Mixed>());     // 12
    println!("Mixed align: {}", mem::align_of::<Mixed>());   // 4
}
```

### 5.3 repr å±æ€§

**æ§åˆ¶å†…å­˜å¸ƒå±€**:

```rust
// Rust é»˜è®¤å¸ƒå±€ï¼ˆå¯ä¼˜åŒ–ï¼‰
struct DefaultRepr {
    a: u8,
    b: u32,
    c: u16,
}

// C å…¼å®¹å¸ƒå±€
#[repr(C)]
struct CRepr {
    a: u8,
    b: u32,
    c: u16,
}

// ç´§å‡‘å¸ƒå±€
#[repr(packed)]
struct PackedRepr {
    a: u8,
    b: u32,
    c: u16,
}

// å¯¹é½åˆ°æŒ‡å®šå­—èŠ‚
#[repr(align(16))]
struct AlignedRepr {
    a: u8,
}

fn main() {
    use std::mem::size_of;
    
    println!("Default: {}", size_of::<DefaultRepr>());  // ä¼˜åŒ–åå¯èƒ½æ˜¯ 8
    println!("C: {}", size_of::<CRepr>());              // 12 (å¸¦å¡«å……)
    println!("Packed: {}", size_of::<PackedRepr>());    // 7 (æ— å¡«å……)
    println!("Aligned: {}", size_of::<AlignedRepr>());  // 16
}
```

---

## 6. Unsafe è¾¹ç•Œ

### 6.1 Unsafe æ“ä½œ

**äº”ç§ unsafe æ“ä½œ**:

1. è§£å¼•ç”¨è£¸æŒ‡é’ˆ
2. è°ƒç”¨ unsafe å‡½æ•°
3. è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
4. å®ç° unsafe trait
5. è®¿é—® union å­—æ®µ

```rust
fn main() {
    let x = 42;
    let ptr = &x as *const i32;
    
    // âŒ ä¸èƒ½åœ¨å®‰å…¨ä»£ç ä¸­è§£å¼•ç”¨è£¸æŒ‡é’ˆ
    // let value = *ptr;
    
    // âœ… å¿…é¡»åœ¨ unsafe å—ä¸­
    unsafe {
        let value = *ptr;
        println!("Value: {}", value);
    }
}
```

### 6.2 å®‰å…¨æŠ½è±¡

**å°è£… unsafe**:

```rust
pub struct SafeVec<T> {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

impl<T> SafeVec<T> {
    pub fn new() -> Self {
        SafeVec {
            ptr: std::ptr::null_mut(),
            len: 0,
            cap: 0,
        }
    }
    
    // å®‰å…¨çš„å…¬å…± API
    pub fn push(&mut self, value: T) {
        // å†…éƒ¨ä½¿ç”¨ unsafeï¼Œä½†æ¥å£æ˜¯å®‰å…¨çš„
        unsafe {
            // ... unsafe å®ç° ...
        }
    }
    
    // å®‰å…¨çš„å…¬å…± API
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < self.len {
            unsafe {
                Some(&*self.ptr.add(index))
            }
        } else {
            None
        }
    }
}

fn main() {
    let mut vec = SafeVec::new();
    vec.push(42);  // âœ… å®‰å…¨è°ƒç”¨
    
    if let Some(value) = vec.get(0) {
        println!("Value: {}", value);
    }
}
```

### 6.3 æœ€ä½³å®è·µ

**æœ€å°åŒ– unsafe**:

```rust
// âœ… å¥½ï¼šunsafe é™åˆ¶åœ¨å°èŒƒå›´
fn safe_wrapper(data: &[u8]) -> u32 {
    assert!(data.len() >= 4);
    unsafe {
        // åªæœ‰å¿…è¦çš„ unsafe æ“ä½œ
        *(data.as_ptr() as *const u32)
    }
}

// âŒ åï¼šæ•´ä¸ªå‡½æ•°éƒ½æ˜¯ unsafe
unsafe fn bad_wrapper(data: &[u8]) -> u32 {
    // ä¸å¿…è¦åœ°å°†æ•´ä¸ªå‡½æ•°æ ‡è®°ä¸º unsafe
    let value = *(data.as_ptr() as *const u32);
    value + 10  // è¿™éƒ¨åˆ†ä¸éœ€è¦ unsafe
}

fn main() {
    let data = [1, 2, 3, 4];
    let value = safe_wrapper(&data);
    println!("Value: {}", value);
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: ç±»å‹å®‰å…¨çš„ API

```rust
use std::marker::PhantomData;

// çŠ¶æ€ç±»å‹
struct Draft;
struct Published;

// æ–‡æ¡£ç±»å‹ï¼Œä½¿ç”¨çŠ¶æ€æ ‡è®°
struct Document<State> {
    content: String,
    _state: PhantomData<State>,
}

impl Document<Draft> {
    fn new(content: String) -> Self {
        Document {
            content,
            _state: PhantomData,
        }
    }
    
    fn edit(&mut self, new_content: String) {
        self.content = new_content;
    }
    
    fn publish(self) -> Document<Published> {
        Document {
            content: self.content,
            _state: PhantomData,
        }
    }
}

impl Document<Published> {
    fn view(&self) -> &str {
        &self.content
    }
    
    // å·²å‘å¸ƒçš„æ–‡æ¡£ä¸èƒ½ç¼–è¾‘
    // fn edit(&mut self, new_content: String) {}  // ä¸æä¾›æ­¤æ–¹æ³•
}

fn main() {
    let mut draft = Document::<Draft>::new(String::from("Initial content"));
    draft.edit(String::from("Updated content"));
    
    let published = draft.publish();
    println!("Published: {}", published.view());
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šå·²å‘å¸ƒçš„æ–‡æ¡£ä¸èƒ½ç¼–è¾‘
    // published.edit(String::from("Cannot edit"));
}
```

### æ¡ˆä¾‹ 2: å†…å­˜å®‰å…¨çš„ç¼“å†²åŒº

```rust
struct SafeBuffer {
    data: Vec<u8>,
    read_pos: usize,
}

impl SafeBuffer {
    fn new(capacity: usize) -> Self {
        SafeBuffer {
            data: Vec::with_capacity(capacity),
            read_pos: 0,
        }
    }
    
    fn write(&mut self, bytes: &[u8]) {
        self.data.extend_from_slice(bytes);
    }
    
    fn read(&mut self, len: usize) -> Option<&[u8]> {
        if self.read_pos + len <= self.data.len() {
            let slice = &self.data[self.read_pos..self.read_pos + len];
            self.read_pos += len;
            Some(slice)
        } else {
            None
        }
    }
}

fn main() {
    let mut buffer = SafeBuffer::new(1024);
    
    buffer.write(b"Hello, ");
    buffer.write(b"World!");
    
    if let Some(data) = buffer.read(5) {
        println!("Read: {:?}", std::str::from_utf8(data).unwrap());
    }
    
    // ä¸ä¼šå‘ç”Ÿç¼“å†²åŒºæº¢å‡º
    if let Some(data) = buffer.read(100) {
        println!("Read: {:?}", data);
    } else {
        println!("Not enough data");
    }
}
```

### æ¡ˆä¾‹ 3: çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct ThreadSafeCounter {
    value: Arc<Mutex<i32>>,
}

impl ThreadSafeCounter {
    fn new() -> Self {
        ThreadSafeCounter {
            value: Arc::new(Mutex::new(0)),
        }
    }
    
    fn increment(&self) {
        let mut value = self.value.lock().unwrap();
        *value += 1;
    }
    
    fn get(&self) -> i32 {
        *self.value.lock().unwrap()
    }
    
    fn clone_counter(&self) -> Self {
        ThreadSafeCounter {
            value: Arc::clone(&self.value),
        }
    }
}

fn main() {
    let counter = ThreadSafeCounter::new();
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = counter.clone_counter();
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter_clone.increment();
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final count: {}", counter.get());
}
```

---

## 8. å¸¸è§å®‰å…¨é™·é˜±

**é™·é˜± 1: ç”Ÿå‘½å‘¨æœŸæ¨æ–­é”™è¯¯**:

```rust
// âŒ é”™è¯¯
// fn longest(x: &str, y: &str) -> &str {
//     if x.len() > y.len() { x } else { y }
// }

// âœ… æ­£ç¡®ï¼šæ˜ç¡®ç”Ÿå‘½å‘¨æœŸ
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

**é™·é˜± 2: å¯å˜æ€§å’Œä¸å¯å˜æ€§æ··ç”¨**:

```rust
fn main() {
    let mut data = vec![1, 2, 3];
    let r1 = &data;
    
    // âŒ ç¼–è¯‘é”™è¯¯
    // data.push(4);
    // println!("{:?}", r1);
    
    // âœ… æ­£ç¡®ï¼šr1 ä½œç”¨åŸŸç»“æŸåå†ä¿®æ”¹
    println!("{:?}", r1);
    data.push(4);
}
```

**é™·é˜± 3: Unsafe è¾¹ç•Œæ³„æ¼**:

```rust
// âŒ åï¼šunsafe æ³„æ¼åˆ°å…¬å…± API
// pub fn bad_api(ptr: *const i32) -> i32 {
//     unsafe { *ptr }
// }

// âœ… å¥½ï¼šå°è£… unsafe
pub fn safe_api(value: &i32) -> i32 {
    // å†…éƒ¨å¯ä»¥ä½¿ç”¨ unsafeï¼Œä½†ä¸æ³„æ¼
    *value
}
```

**é™·é˜± 4: æ•°æ®ç«äº‰**:

```rust
use std::thread;
use std::sync::{Arc, Mutex};

// âŒ å±é™©ï¼šå¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰
fn bad_shared_counter() {
    let counter = 0;
    let handles: Vec<_> = (0..10)
        .map(|_| {
            // ç¼–è¯‘é”™è¯¯ï¼šæ— æ³•åœ¨å¤šçº¿ç¨‹é—´å…±äº«å¯å˜å¼•ç”¨
            // thread::spawn(move || {
            //     counter += 1;
            // })
            unimplemented!()
        })
        .collect();
}

// âœ… å®‰å…¨ï¼šä½¿ç”¨Mutexä¿æŠ¤
fn safe_shared_counter() {
    let counter = Arc::new(Mutex::new(0));
    let handles: Vec<_> = (0..10)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                let mut num = counter.lock().unwrap();
                *num += 1;
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**é™·é˜± 5: æ•´æ•°æº¢å‡º**:

```rust
fn add_numbers(a: u8, b: u8) -> u8 {
    // âŒ å±é™©ï¼šå¯èƒ½æº¢å‡ºï¼ˆdebugæ¨¡å¼panicï¼Œreleaseæ¨¡å¼å›ç»•ï¼‰
    // a + b
    
    // âœ… å®‰å…¨ï¼šæ£€æŸ¥æº¢å‡º
    a.checked_add(b).expect("Overflow occurred")
}

fn safe_add(a: u8, b: u8) -> Option<u8> {
    a.checked_add(b)
}

fn main() {
    println!("Safe add: {:?}", safe_add(200, 100)); // None
}
```

**é™·é˜± 6: æ‚¬å‚å¼•ç”¨**:

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼šè¿”å›æ‚¬å‚å¼•ç”¨
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // såœ¨å‡½æ•°ç»“æŸæ—¶è¢«é‡Šæ”¾
// }

// âœ… æ­£ç¡®ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    String::from("hello")
}

// âœ… æˆ–è€…æ¥å—å¼•ç”¨å‚æ•°
fn borrow_string(s: &String) -> &str {
    &s[..]
}
```

**é™·é˜± 7: å†…å­˜æ³„æ¼ï¼ˆå¾ªç¯å¼•ç”¨ï¼‰**:

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    next: Option<Rc<RefCell<Node>>>,
    prev: Option<Rc<RefCell<Node>>>,
}

// âŒ å±é™©ï¼šå¯èƒ½å¯¼è‡´å¾ªç¯å¼•ç”¨
fn create_cycle() {
    let node1 = Rc::new(RefCell::new(Node {
        value: 1,
        next: None,
        prev: None,
    }));
    
    let node2 = Rc::new(RefCell::new(Node {
        value: 2,
        next: Some(Rc::clone(&node1)),
        prev: None,
    }));
    
    node1.borrow_mut().next = Some(Rc::clone(&node2));
    // å¾ªç¯å¼•ç”¨ï¼šnode1 -> node2 -> node1
}

// âœ… å®‰å…¨ï¼šä½¿ç”¨Weakæ‰“ç ´å¾ªç¯
use std::rc::Weak;

#[derive(Debug)]
struct SafeNode {
    value: i32,
    next: Option<Rc<RefCell<SafeNode>>>,
    prev: Option<Weak<RefCell<SafeNode>>>,  // ä½¿ç”¨Weak
}
```

**é™·é˜± 8: æœªæ£€æŸ¥çš„é”™è¯¯å¤„ç†**:

```rust
use std::fs::File;
use std::io::Read;

// âŒ å±é™©ï¼šå¿½ç•¥é”™è¯¯
fn read_file_bad(path: &str) -> String {
    let mut file = File::open(path).unwrap();  // å¯èƒ½panic
    let mut contents = String::new();
    file.read_to_string(&mut contents).unwrap();  // å¯èƒ½panic
    contents
}

// âœ… å®‰å…¨ï¼šæ­£ç¡®å¤„ç†é”™è¯¯
fn read_file_safe(path: &str) -> std::io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

**é™·é˜± 9: UnsafeæŒ‡é’ˆè§£å¼•ç”¨**:

```rust
fn main() {
    let x = 42;
    let ptr = &x as *const i32;
    
    // âŒ å±é™©ï¼šæœªæ£€æŸ¥çš„unsafe
    unsafe {
        let value = *ptr;
        println!("{}", value);
    }
    
    // âœ… æ›´å¥½ï¼šä¿æŒåœ¨å®‰å…¨è¾¹ç•Œå†…
    let safe_value = x;  // ç›´æ¥ä½¿ç”¨å€¼
    println!("{}", safe_value);
}

// âœ… æœ€ä½³ï¼šå°è£…unsafeåœ¨å®‰å…¨æ¥å£å
pub struct SafePtr<T> {
    ptr: *const T,
}

impl<T> SafePtr<T> {
    pub fn new(value: &T) -> Self {
        SafePtr { ptr: value as *const T }
    }
    
    pub fn get(&self) -> Option<&T> {
        if self.ptr.is_null() {
            None
        } else {
            Some(unsafe { &*self.ptr })
        }
    }
}
```

**é™·é˜± 10: å­—ç¬¦ä¸²åˆ†ç‰‡è¶Šç•Œ**:

```rust
fn main() {
    let s = String::from("hello");
    
    // âŒ å±é™©ï¼šå¯èƒ½panic
    // let slice = &s[0..10];  // panic: è¶Šç•Œ
    
    // âœ… å®‰å…¨ï¼šæ£€æŸ¥è¾¹ç•Œ
    let slice = s.get(0..5).unwrap_or("");
    println!("{}", slice);
    
    // âœ… æ›´å®‰å…¨ï¼šä½¿ç”¨checkedæ–¹æ³•
    if let Some(slice) = s.get(0..5) {
        println!("{}", slice);
    }
}
```

**é™·é˜± 11: Send/Syncè¯¯ç”¨**:

```rust
use std::rc::Rc;
use std::thread;

// âŒ ç¼–è¯‘é”™è¯¯ï¼šRcä¸æ˜¯Send
// fn bad_rc_thread() {
//     let rc = Rc::new(5);
//     thread::spawn(move || {
//         println!("{}", rc);
//     });
// }

// âœ… æ­£ç¡®ï¼šä½¿ç”¨Arc
use std::sync::Arc;

fn good_arc_thread() {
    let arc = Arc::new(5);
    let arc_clone = Arc::clone(&arc);
    thread::spawn(move || {
        println!("{}", arc_clone);
    }).join().unwrap();
}
```

**é™·é˜± 12: ç”Ÿå‘½å‘¨æœŸçœç•¥è¯¯è§£**:

```rust
// âŒ å¯èƒ½è¯¯è§£ï¼šä»¥ä¸ºéƒ½æœ‰ç›¸åŒç”Ÿå‘½å‘¨æœŸ
struct BadStruct<'a> {
    s1: &'a str,
    s2: &'a str,
}

// âœ… æ­£ç¡®ï¼šæ˜ç¡®ä¸åŒç”Ÿå‘½å‘¨æœŸ
struct GoodStruct<'a, 'b> {
    s1: &'a str,
    s2: &'b str,
}

impl<'a, 'b> GoodStruct<'a, 'b> {
    fn new(s1: &'a str, s2: &'b str) -> Self {
        GoodStruct { s1, s2 }
    }
}
```

**é™·é˜± 13: ä¸å½“çš„cloneä½¿ç”¨**:

```rust
use std::sync::Arc;

// âŒ ä½æ•ˆï¼šé¢‘ç¹cloneå¤§å¯¹è±¡
fn inefficient_clone(data: &Vec<u8>) -> Vec<u8> {
    data.clone()  // å¤åˆ¶æ•´ä¸ªVec
}

// âœ… é«˜æ•ˆï¼šä½¿ç”¨å¼•ç”¨æˆ–Arc
fn efficient_borrow(data: &Vec<u8>) -> &[u8] {
    &data[..]
}

fn efficient_arc(data: Arc<Vec<u8>>) -> Arc<Vec<u8>> {
    Arc::clone(&data)  // åªå¢åŠ å¼•ç”¨è®¡æ•°
}
```

**é™·é˜± 14: æ‹’ç»æœåŠ¡ï¼ˆDoSï¼‰æ”»å‡»**:

```rust
// âŒ å±é™©ï¼šæ— é™åˆ¶çš„é€’å½’
fn bad_recursive(n: u32) -> u32 {
    if n == 0 { 0 }
    else { n + bad_recursive(n - 1) }  // å¤§æ•°å­—å¯èƒ½æ ˆæº¢å‡º
}

// âœ… å®‰å…¨ï¼šæ·»åŠ æ·±åº¦é™åˆ¶
fn safe_recursive(n: u32, max_depth: u32) -> Option<u32> {
    if max_depth == 0 {
        return None;
    }
    if n == 0 {
        Some(0)
    } else {
        safe_recursive(n - 1, max_depth - 1).map(|sum| n + sum)
    }
}

// âœ… æœ€ä½³ï¼šä½¿ç”¨è¿­ä»£
fn iterative_sum(n: u32) -> u32 {
    (0..=n).sum()
}
```

**é™·é˜± 15: ä¾§ä¿¡é“æ”»å‡»**:

```rust
use std::time::Instant;

// âŒ å±é™©ï¼šæ—¶é—´æ”»å‡»
fn insecure_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    a.iter().zip(b.iter()).all(|(x, y)| x == y)
    // æå‰è¿”å›æ³„æ¼ä¿¡æ¯
}

// âœ… å®‰å…¨ï¼šå¸¸é‡æ—¶é—´æ¯”è¾ƒ
fn secure_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    let mut result = 0u8;
    for (x, y) in a.iter().zip(b.iter()) {
        result |= x ^ y;
    }
    result == 0
}
```

---

## 9. æ€»ç»“

**Rust å®‰å…¨æ€§ä¿è¯**:

| å®‰å…¨ç±»å‹ | æœºåˆ¶ | é˜²æ­¢ |
|---------|------|------|
| **ç±»å‹å®‰å…¨** | å¼ºç±»å‹ + ç±»å‹æ£€æŸ¥ | ç±»å‹é”™è¯¯ |
| **å†…å­˜å®‰å…¨** | æ‰€æœ‰æƒ + å€Ÿç”¨ + ç”Ÿå‘½å‘¨æœŸ | UAF, åŒé‡é‡Šæ”¾, æ‚¬å‚æŒ‡é’ˆ |
| **çº¿ç¨‹å®‰å…¨** | Send/Sync + Mutex | æ•°æ®ç«äº‰ |
| **ç©ºæŒ‡é’ˆå®‰å…¨** | Option/Result | Null è§£å¼•ç”¨ |

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… é›¶æˆæœ¬æŠ½è±¡
2. âœ… ç¼–è¯‘æ—¶ä¿è¯
3. âœ… å†…å­˜å®‰å…¨æ— è¿è¡Œæ—¶å¼€é”€
4. âœ… çº¿ç¨‹å®‰å…¨å†…å»ºäºç±»å‹ç³»ç»Ÿ
5. âœ… Unsafe æœ€å°åŒ–

---

## 10. å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Book - Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
- [Rust Book - Fearless Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [Rustonomicon](https://doc.rust-lang.org/nomicon/)

**ç›¸å…³æ–‡æ¡£**:

- [2.1 åŸºç¡€ç±»å‹æŒ‡å—](../tier_02_guides/01_åŸºç¡€ç±»å‹æŒ‡å—.md)
- [2.5 ç”Ÿå‘½å‘¨æœŸæŒ‡å—](../tier_02_guides/05_ç”Ÿå‘½å‘¨æœŸæŒ‡å—.md)
- [3.5 æ€§èƒ½ä¼˜åŒ–å‚è€ƒ](./05_æ€§èƒ½ä¼˜åŒ–å‚è€ƒ.md)

---

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚

---

**ğŸ‰ å®Œæˆå®‰å…¨æ€§å‚è€ƒå­¦ä¹ ï¼** ğŸ¦€
