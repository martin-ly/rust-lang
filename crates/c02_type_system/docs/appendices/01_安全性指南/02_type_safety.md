# Rust ç±»å‹å®‰å…¨ç³»ç»Ÿå®Œæ•´æŒ‡å—

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-27  
**Rustç‰ˆæœ¬**: 1.90+  
**éš¾åº¦ç­‰çº§**: ä¸­çº§åˆ°é«˜çº§  

## ğŸ“‹ ç›®å½•

- [Rust ç±»å‹å®‰å…¨ç³»ç»Ÿå®Œæ•´æŒ‡å—](#rust-ç±»å‹å®‰å…¨ç³»ç»Ÿå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç±»å‹å®‰å…¨åŸºç¡€](#1-ç±»å‹å®‰å…¨åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯ç±»å‹å®‰å…¨](#11-ä»€ä¹ˆæ˜¯ç±»å‹å®‰å…¨)
    - [1.2 ç±»å‹å®‰å…¨çš„é‡è¦æ€§](#12-ç±»å‹å®‰å…¨çš„é‡è¦æ€§)
    - [1.3 Rust çš„ç±»å‹å®‰å…¨ä¿è¯](#13-rust-çš„ç±»å‹å®‰å…¨ä¿è¯)
  - [2. ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥](#2-ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥)
    - [2.1 ç±»å‹æ¨æ–­](#21-ç±»å‹æ¨æ–­)
    - [2.2 ç±»å‹çº¦æŸ](#22-ç±»å‹çº¦æŸ)
    - [2.3 ç±»å‹é”™è¯¯è¯Šæ–­](#23-ç±»å‹é”™è¯¯è¯Šæ–­)
  - [3. è¿è¡Œæ—¶ç±»å‹å®‰å…¨](#3-è¿è¡Œæ—¶ç±»å‹å®‰å…¨)
    - [3.1 æ¨¡å¼åŒ¹é…](#31-æ¨¡å¼åŒ¹é…)
    - [3.2 ç±»å‹è½¬æ¢](#32-ç±»å‹è½¬æ¢)
    - [3.3 åŠ¨æ€ç±»å‹æ£€æŸ¥](#33-åŠ¨æ€ç±»å‹æ£€æŸ¥)
  - [4. æ³›å‹ç±»å‹å®‰å…¨](#4-æ³›å‹ç±»å‹å®‰å…¨)
    - [4.1 æ³›å‹çº¦æŸ](#41-æ³›å‹çº¦æŸ)
    - [4.2 ç‰¹å¾è¾¹ç•Œ](#42-ç‰¹å¾è¾¹ç•Œ)
    - [4.3 ç±»å‹æ“¦é™¤](#43-ç±»å‹æ“¦é™¤)
  - [5. ç”Ÿå‘½å‘¨æœŸç±»å‹å®‰å…¨](#5-ç”Ÿå‘½å‘¨æœŸç±»å‹å®‰å…¨)
    - [5.1 ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥](#51-ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥)
    - [5.2 å€Ÿç”¨æ£€æŸ¥](#52-å€Ÿç”¨æ£€æŸ¥)
    - [5.3 æ‚¬å‚æŒ‡é’ˆé˜²æŠ¤](#53-æ‚¬å‚æŒ‡é’ˆé˜²æŠ¤)
  - [6. å†…å­˜å®‰å…¨ä¸ç±»å‹å®‰å…¨](#6-å†…å­˜å®‰å…¨ä¸ç±»å‹å®‰å…¨)
    - [6.1 æ‰€æœ‰æƒç³»ç»Ÿ](#61-æ‰€æœ‰æƒç³»ç»Ÿ)
    - [6.2 å€Ÿç”¨ç³»ç»Ÿ](#62-å€Ÿç”¨ç³»ç»Ÿ)
    - [6.3 å†…å­˜å¸ƒå±€å®‰å…¨](#63-å†…å­˜å¸ƒå±€å®‰å…¨)
  - [7. ä¸å®‰å…¨ä»£ç çš„ç±»å‹å®‰å…¨](#7-ä¸å®‰å…¨ä»£ç çš„ç±»å‹å®‰å…¨)
    - [7.1 unsafe å—](#71-unsafe-å—)
    - [7.2 åŸå§‹æŒ‡é’ˆ](#72-åŸå§‹æŒ‡é’ˆ)
    - [7.3 å†…å­˜æ“ä½œ](#73-å†…å­˜æ“ä½œ)
  - [8. ç±»å‹å®‰å…¨æœ€ä½³å®è·µ](#8-ç±»å‹å®‰å…¨æœ€ä½³å®è·µ)
    - [8.1 è®¾è®¡åŸåˆ™](#81-è®¾è®¡åŸåˆ™)
    - [8.2 å¸¸è§é™·é˜±](#82-å¸¸è§é™·é˜±)
    - [8.3 è°ƒè¯•æŠ€å·§](#83-è°ƒè¯•æŠ€å·§)
  - [9. ç±»å‹å®‰å…¨å·¥å…·](#9-ç±»å‹å®‰å…¨å·¥å…·)
    - [9.1 ç¼–è¯‘å™¨æ£€æŸ¥](#91-ç¼–è¯‘å™¨æ£€æŸ¥)
    - [9.2 é™æ€åˆ†æ](#92-é™æ€åˆ†æ)
    - [9.3 æµ‹è¯•ç­–ç•¥](#93-æµ‹è¯•ç­–ç•¥)
  - [10. æ€»ç»“](#10-æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
    - [è¿›ä¸€æ­¥å­¦ä¹ ](#è¿›ä¸€æ­¥å­¦ä¹ )

## 1. ç±»å‹å®‰å…¨åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯ç±»å‹å®‰å…¨

ç±»å‹å®‰å…¨æ˜¯ç¼–ç¨‹è¯­è¨€çš„ä¸€ä¸ªé‡è¦ç‰¹æ€§ï¼Œå®ƒç¡®ä¿ç¨‹åºåœ¨è¿è¡Œæ—¶ä¸ä¼šå‡ºç°ç±»å‹ç›¸å…³çš„é”™è¯¯ã€‚

```rust
// ç±»å‹å®‰å…¨çš„ç¤ºä¾‹
fn add_numbers(a: i32, b: i32) -> i32 {
    a + b  // ç¼–è¯‘å™¨ç¡®ä¿ a å’Œ b éƒ½æ˜¯ i32 ç±»å‹
}

// ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
fn main() {
    let result = add_numbers(5, 10);  // âœ… æ­£ç¡®
    // let result = add_numbers("hello", 10);  // âŒ ç¼–è¯‘é”™è¯¯
}
```

### 1.2 ç±»å‹å®‰å…¨çš„é‡è¦æ€§

ç±»å‹å®‰å…¨æä¾›äº†ä»¥ä¸‹ä¿è¯ï¼š

1. **é˜²æ­¢ç±»å‹é”™è¯¯**: é¿å…åœ¨è¿è¡Œæ—¶å‡ºç°ç±»å‹ä¸åŒ¹é…çš„é”™è¯¯
2. **æé«˜ä»£ç è´¨é‡**: ç¼–è¯‘æ—¶å‘ç°æ½œåœ¨é—®é¢˜
3. **å¢å¼ºå¯ç»´æŠ¤æ€§**: ç±»å‹ä¿¡æ¯ä½œä¸ºæ–‡æ¡£
4. **ä¼˜åŒ–æ€§èƒ½**: ç¼–è¯‘å™¨å¯ä»¥è¿›è¡Œæ›´å¥½çš„ä¼˜åŒ–

### 1.3 Rust çš„ç±»å‹å®‰å…¨ä¿è¯

Rust æä¾›äº†å¼ºå¤§çš„ç±»å‹å®‰å…¨ä¿è¯ï¼š

```rust
// å¼ºç±»å‹ç³»ç»Ÿ
let x: i32 = 42;
let y: f64 = 3.14;

// ç±»å‹æ¨æ–­
let z = x + y;  // âŒ ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½ç›´æ¥ç›¸åŠ ä¸åŒç±»å‹çš„å€¼

// æ˜¾å¼ç±»å‹è½¬æ¢
let z = x as f64 + y;  // âœ… æ­£ç¡®ï¼šæ˜¾å¼è½¬æ¢
```

## 2. ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥

### 2.1 ç±»å‹æ¨æ–­

Rust çš„ç±»å‹æ¨æ–­ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶ç¡®å®šæ‰€æœ‰å˜é‡çš„ç±»å‹ï¼š

```rust
// ç±»å‹æ¨æ–­ç¤ºä¾‹
fn main() {
    let x = 42;           // æ¨æ–­ä¸º i32
    let y = 3.14;         // æ¨æ–­ä¸º f64
    let z = "hello";      // æ¨æ–­ä¸º &str
    
    // ç¼–è¯‘å™¨çŸ¥é“æ‰€æœ‰ç±»å‹ï¼Œå¯ä»¥è¿›è¡Œç±»å‹æ£€æŸ¥
    let result = x * 2;   // âœ… æ­£ç¡®
    // let result = x * y; // âŒ ç¼–è¯‘é”™è¯¯
}
```

### 2.2 ç±»å‹çº¦æŸ

ä½¿ç”¨æ³›å‹å’Œç‰¹å¾çº¦æŸç¡®ä¿ç±»å‹å®‰å…¨ï¼š

```rust
use std::ops::Add;

// æ³›å‹å‡½æ•°ï¼Œè¦æ±‚ T å®ç° Add ç‰¹å¾
fn add<T: Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// ä½¿ç”¨ where å­å¥
fn multiply<T>(a: T, b: T) -> T 
where 
    T: std::ops::Mul<Output = T> + Copy,
{
    a * b
}

fn main() {
    let result1 = add(5, 10);        // âœ… æ­£ç¡®
    let result2 = multiply(3.0, 4.0); // âœ… æ­£ç¡®
    // let result3 = add("hello", "world"); // âŒ ç¼–è¯‘é”™è¯¯
}
```

### 2.3 ç±»å‹é”™è¯¯è¯Šæ–­

Rust ç¼–è¯‘å™¨æä¾›è¯¦ç»†çš„ç±»å‹é”™è¯¯ä¿¡æ¯ï¼š

```rust
fn main() {
    let x: i32 = 42;
    let y: &str = "hello";
    
    // ç¼–è¯‘å™¨ä¼šæä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
    let result = x + y;  // âŒ é”™è¯¯ï¼šä¸èƒ½å°† i32 å’Œ &str ç›¸åŠ 
}
```

## 3. è¿è¡Œæ—¶ç±»å‹å®‰å…¨

### 3.1 æ¨¡å¼åŒ¹é…

ä½¿ç”¨æ¨¡å¼åŒ¹é…è¿›è¡Œè¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ï¼š

```rust
enum Value {
    Integer(i32),
    Float(f64),
    Text(String),
}

fn process_value(value: Value) {
    match value {
        Value::Integer(i) => println!("æ•´æ•°: {}", i),
        Value::Float(f) => println!("æµ®ç‚¹æ•°: {}", f),
        Value::Text(s) => println!("æ–‡æœ¬: {}", s),
    }
}

// ä½¿ç”¨ if let è¿›è¡Œæ¨¡å¼åŒ¹é…
fn extract_integer(value: Value) -> Option<i32> {
    if let Value::Integer(i) = value {
        Some(i)
    } else {
        None
    }
}
```

### 3.2 ç±»å‹è½¬æ¢

å®‰å…¨çš„ç±»å‹è½¬æ¢æ–¹æ³•ï¼š

```rust
use std::convert::TryFrom;

// ä½¿ç”¨ TryFrom è¿›è¡Œå®‰å…¨è½¬æ¢
fn safe_convert() {
    let x: i32 = 1000;
    
    // å®‰å…¨çš„ç±»å‹è½¬æ¢
    match u8::try_from(x) {
        Ok(value) => println!("è½¬æ¢æˆåŠŸ: {}", value),
        Err(_) => println!("è½¬æ¢å¤±è´¥ï¼šå€¼è¶…å‡ºèŒƒå›´"),
    }
    
    // ä½¿ç”¨ as è¿›è¡Œä¸å®‰å…¨çš„è½¬æ¢
    let y = x as u8;  // å¯èƒ½ä¸¢å¤±æ•°æ®
    println!("ä¸å®‰å…¨è½¬æ¢: {}", y);
}

// è‡ªå®šä¹‰ç±»å‹è½¬æ¢
#[derive(Debug)]
struct Temperature {
    celsius: f64,
}

impl Temperature {
    fn new(celsius: f64) -> Self {
        Self { celsius }
    }
    
    fn to_fahrenheit(&self) -> f64 {
        self.celsius * 9.0 / 5.0 + 32.0
    }
}
```

### 3.3 åŠ¨æ€ç±»å‹æ£€æŸ¥

ä½¿ç”¨ Any ç‰¹å¾è¿›è¡ŒåŠ¨æ€ç±»å‹æ£€æŸ¥ï¼š

```rust
use std::any::{Any, TypeId};

fn is_string<T: ?Sized + Any>(_s: &T) -> bool {
    TypeId::of::<String>() == TypeId::of::<T>()
}

fn main() {
    let s = String::from("hello");
    let i = 42;
    
    println!("s æ˜¯å­—ç¬¦ä¸²: {}", is_string(&s));
    println!("i æ˜¯å­—ç¬¦ä¸²: {}", is_string(&i));
}
```

## 4. æ³›å‹ç±»å‹å®‰å…¨

### 4.1 æ³›å‹çº¦æŸ

ä½¿ç”¨ç‰¹å¾çº¦æŸç¡®ä¿æ³›å‹ç±»å‹å®‰å…¨ï¼š

```rust
use std::fmt::Display;

// æ³›å‹å‡½æ•°ï¼Œè¦æ±‚ T å®ç° Display ç‰¹å¾
fn print_value<T: Display>(value: T) {
    println!("å€¼: {}", value);
}

// å¤šé‡çº¦æŸ
fn compare_and_print<T>(a: T, b: T) 
where 
    T: PartialOrd + Display,
{
    match a.partial_cmp(&b) {
        Some(std::cmp::Ordering::Less) => println!("{} < {}", a, b),
        Some(std::cmp::Ordering::Equal) => println!("{} = {}", a, b),
        Some(std::cmp::Ordering::Greater) => println!("{} > {}", a, b),
        None => println!("æ— æ³•æ¯”è¾ƒ {} å’Œ {}", a, b),
    }
}

fn main() {
    print_value(42);
    print_value("hello");
    
    compare_and_print(5, 10);
    compare_and_print(3.14, 2.71);
}
```

### 4.2 ç‰¹å¾è¾¹ç•Œ

ä½¿ç”¨ç‰¹å¾è¾¹ç•Œé™åˆ¶æ³›å‹å‚æ•°ï¼š

```rust
use std::ops::Add;

// æ³›å‹ç»“æ„ä½“
#[derive(Debug)]
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// ä¸ºå®ç°äº† Add ç‰¹å¾çš„ç±»å‹å®ç°æ–¹æ³•
impl<T: Add<Output = T> + Copy> Point<T> {
    fn add(&self, other: &Point<T>) -> Point<T> {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point::new(1, 2);
    let p2 = Point::new(3, 4);
    let p3 = p1.add(&p2);
    
    println!("ç»“æœ: {:?}", p3);
}
```

### 4.3 ç±»å‹æ“¦é™¤

ä½¿ç”¨ç‰¹å¾å¯¹è±¡å®ç°ç±»å‹æ“¦é™¤ï¼š

```rust
use std::fmt::Display;

// ç‰¹å¾å¯¹è±¡ï¼Œå®ç°ç±»å‹æ“¦é™¤
fn print_any<T: Display + 'static>(value: T) -> Box<dyn Display> {
    Box::new(value)
}

fn main() {
    let display1 = print_any(42);
    let display2 = print_any("hello");
    let display3 = print_any(3.14);
    
    println!("{}", display1);
    println!("{}", display2);
    println!("{}", display3);
}
```

## 5. ç”Ÿå‘½å‘¨æœŸç±»å‹å®‰å…¨

### 5.1 ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥

ç”Ÿå‘½å‘¨æœŸç¡®ä¿å¼•ç”¨çš„æœ‰æ•ˆæ€§ï¼š

```rust
// ç”Ÿå‘½å‘¨æœŸæ³¨è§£
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("æœ€é•¿çš„å­—ç¬¦ä¸²æ˜¯ {}", result);
}
```

### 5.2 å€Ÿç”¨æ£€æŸ¥

å€Ÿç”¨æ£€æŸ¥å™¨ç¡®ä¿å†…å­˜å®‰å…¨ï¼š

```rust
fn main() {
    let mut data = vec![1, 2, 3, 4, 5];
    
    // ä¸å¯å˜å€Ÿç”¨
    let first = &data[0];
    let second = &data[1];
    
    println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", first);
    println!("ç¬¬äºŒä¸ªå…ƒç´ : {}", second);
    
    // å¯å˜å€Ÿç”¨ï¼ˆåœ¨ä¸å¯å˜å€Ÿç”¨ç»“æŸåï¼‰
    data.push(6);  // âœ… æ­£ç¡®ï¼šä¸å¯å˜å€Ÿç”¨å·²ç»“æŸ
    
    println!("æ•°æ®: {:?}", data);
}
```

### 5.3 æ‚¬å‚æŒ‡é’ˆé˜²æŠ¤

é˜²æ­¢æ‚¬å‚æŒ‡é’ˆçš„äº§ç”Ÿï¼š

```rust
// è¿™ä¸ªå‡½æ•°ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºè¿”å›äº†æ‚¬å‚å¼•ç”¨
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // è¿”å› s çš„å¼•ç”¨ï¼Œä½† s åœ¨è¿™é‡Œè¢«ä¸¢å¼ƒ
// }

// æ­£ç¡®çš„åšæ³•ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // è¿”å› s çš„æ‰€æœ‰æƒ
}

fn main() {
    let s = no_dangle();
    println!("{}", s);
}
```

## 6. å†…å­˜å®‰å…¨ä¸ç±»å‹å®‰å…¨

### 6.1 æ‰€æœ‰æƒç³»ç»Ÿ

æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨ï¼š

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 çš„æ‰€æœ‰æƒç§»åŠ¨åˆ° s2
    
    // println!("{}", s1);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šs1 ä¸å†æœ‰æ•ˆ
    println!("{}", s2);  // âœ… æ­£ç¡®
}
```

### 6.2 å€Ÿç”¨ç³»ç»Ÿ

å€Ÿç”¨ç³»ç»Ÿå…è®¸å®‰å…¨åœ°å…±äº«æ•°æ®ï¼š

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);  // å€Ÿç”¨ s1
    
    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len);  // s1 ä»ç„¶æœ‰æ•ˆ
}
```

### 6.3 å†…å­˜å¸ƒå±€å®‰å…¨

ç¡®ä¿å†…å­˜å¸ƒå±€çš„ç±»å‹å®‰å…¨ï¼š

```rust
use std::mem;

#[repr(C)]  // ç¡®ä¿ C å…¼å®¹çš„å†…å­˜å¸ƒå±€
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let point = Point { x: 1.0, y: 2.0 };
    
    // å®‰å…¨åœ°è·å–å†…å­˜å¤§å°
    println!("Point å¤§å°: {} å­—èŠ‚", mem::size_of::<Point>());
    println!("Point å¯¹é½: {} å­—èŠ‚", mem::align_of::<Point>());
}
```

## 7. ä¸å®‰å…¨ä»£ç çš„ç±»å‹å®‰å…¨

### 7.1 unsafe å—

åœ¨ unsafe å—ä¸­ä¿æŒç±»å‹å®‰å…¨ï¼š

```rust
unsafe fn dangerous_operation() {
    // ä¸å®‰å…¨çš„æ“ä½œ
    let raw_ptr = 0x12345 as *const i32;
    // let value = *raw_ptr;  // å±é™©ï¼šå¯èƒ½è®¿é—®æ— æ•ˆå†…å­˜
}

fn safe_wrapper() {
    unsafe {
        dangerous_operation();
    }
}
```

### 7.2 åŸå§‹æŒ‡é’ˆ

å®‰å…¨åœ°ä½¿ç”¨åŸå§‹æŒ‡é’ˆï¼š

```rust
use std::ptr;

fn safe_pointer_operations() {
    let mut data = [1, 2, 3, 4, 5];
    
    unsafe {
        let ptr = data.as_mut_ptr();
        
        // å®‰å…¨åœ°æ“ä½œæŒ‡é’ˆ
        for i in 0..data.len() {
            let value = ptr.add(i);
            *value *= 2;
        }
    }
    
    println!("æ•°æ®: {:?}", data);
}
```

### 7.3 å†…å­˜æ“ä½œ

å®‰å…¨çš„å†…å­˜æ“ä½œï¼š

```rust
use std::alloc::{alloc, dealloc, Layout};

unsafe fn allocate_memory() -> *mut u8 {
    let layout = Layout::new::<i32>();
    let ptr = alloc(layout);
    
    if ptr.is_null() {
        panic!("å†…å­˜åˆ†é…å¤±è´¥");
    }
    
    ptr
}

unsafe fn deallocate_memory(ptr: *mut u8) {
    let layout = Layout::new::<i32>();
    dealloc(ptr, layout);
}
```

## 8. ç±»å‹å®‰å…¨æœ€ä½³å®è·µ

### 8.1 è®¾è®¡åŸåˆ™

1. **ä½¿ç”¨å¼ºç±»å‹**: é¿å…ä½¿ç”¨ `Any` æˆ– `Object` ç±»å‹
2. **æ˜ç¡®ç±»å‹çº¦æŸ**: ä½¿ç”¨ç‰¹å¾çº¦æŸæ˜ç¡®æ³›å‹è¦æ±‚
3. **é¿å…ç±»å‹è½¬æ¢**: å°½é‡å‡å°‘æ˜¾å¼ç±»å‹è½¬æ¢
4. **ä½¿ç”¨æšä¸¾**: ç”¨æšä¸¾æ›¿ä»£å­—ç¬¦ä¸²æˆ–æ•´æ•°å¸¸é‡

```rust
// å¥½çš„è®¾è®¡ï¼šä½¿ç”¨æšä¸¾
enum Status {
    Pending,
    Processing,
    Completed,
    Failed,
}

// é¿å…çš„è®¾è®¡ï¼šä½¿ç”¨å­—ç¬¦ä¸²
// fn process_status(status: &str) { ... }
```

### 8.2 å¸¸è§é™·é˜±

é¿å…å¸¸è§çš„ç±»å‹å®‰å…¨é™·é˜±ï¼š

```rust
// é™·é˜± 1ï¼šå¿½ç•¥ç”Ÿå‘½å‘¨æœŸ
// fn bad_function() -> &str {
//     let s = String::from("hello");
//     &s  // é”™è¯¯ï¼šè¿”å›æ‚¬å‚å¼•ç”¨
// }

// æ­£ç¡®çš„åšæ³•
fn good_function() -> String {
    let s = String::from("hello");
    s  // è¿”å›æ‰€æœ‰æƒ
}

// é™·é˜± 2ï¼šä¸å®‰å…¨çš„ç±»å‹è½¬æ¢
fn unsafe_cast() {
    let x: i32 = -1;
    let y = x as u32;  // å¯èƒ½äº§ç”Ÿæ„å¤–ç»“æœ
    println!("{}", y);  // è¾“å‡ºï¼š4294967295
}

// æ­£ç¡®çš„åšæ³•
fn safe_cast() {
    let x: i32 = -1;
    match u32::try_from(x) {
        Ok(y) => println!("{}", y),
        Err(_) => println!("è½¬æ¢å¤±è´¥"),
    }
}
```

### 8.3 è°ƒè¯•æŠ€å·§

ç±»å‹å®‰å…¨é—®é¢˜çš„è°ƒè¯•æŠ€å·§ï¼š

```rust
// ä½¿ç”¨ç±»å‹æ³¨è§£å¸®åŠ©è°ƒè¯•
fn debug_types() {
    let x = 42;  // ç¼–è¯‘å™¨æ¨æ–­ä¸º i32
    let y: i64 = x.into();  // æ˜¾å¼è½¬æ¢
    
    // ä½¿ç”¨ dbg! å®æŸ¥çœ‹ç±»å‹
    dbg!(x, y);
}

// ä½¿ç”¨ç¼–è¯‘å™¨é”™è¯¯ä¿¡æ¯
fn learn_from_errors() {
    let x = 42;
    let y = "hello";
    
    // è¿™ä¼šäº§ç”Ÿæœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
    // let result = x + y;  // å–æ¶ˆæ³¨é‡ŠæŸ¥çœ‹é”™è¯¯
}
```

## 9. ç±»å‹å®‰å…¨å·¥å…·

### 9.1 ç¼–è¯‘å™¨æ£€æŸ¥

åˆ©ç”¨ Rust ç¼–è¯‘å™¨çš„ç±»å‹æ£€æŸ¥ï¼š

```rust
// å¯ç”¨é¢å¤–çš„ç¼–è¯‘å™¨æ£€æŸ¥
#![deny(unused_variables)]
#![deny(dead_code)]

fn main() {
    let x = 42;  // å¦‚æœæœªä½¿ç”¨ä¼šäº§ç”Ÿè­¦å‘Š
    println!("Hello, world!");
}
```

### 9.2 é™æ€åˆ†æ

ä½¿ç”¨é™æ€åˆ†æå·¥å…·ï¼š

```rust
// ä½¿ç”¨ clippy è¿›è¡Œä»£ç æ£€æŸ¥
// åœ¨ Cargo.toml ä¸­æ·»åŠ ï¼š
// [dependencies]
// clippy = "0.1"

// è¿è¡Œï¼šcargo clippy
```

### 9.3 æµ‹è¯•ç­–ç•¥

ç¼–å†™ç±»å‹å®‰å…¨çš„æµ‹è¯•ï¼š

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_type_safety() {
        // æµ‹è¯•ç±»å‹çº¦æŸ
        let result = add(5, 10);
        assert_eq!(result, 15);
        
        // æµ‹è¯•ç±»å‹è½¬æ¢
        let temp = Temperature::new(0.0);
        assert_eq!(temp.to_fahrenheit(), 32.0);
    }
    
    #[test]
    #[should_panic]
    fn test_unsafe_operation() {
        // æµ‹è¯•ä¸å®‰å…¨çš„æ“ä½œ
        unsafe {
            let ptr = 0 as *const i32;
            let _ = *ptr;  // è¿™ä¼šå¯¼è‡´ panic
        }
    }
}
```

## 10. æ€»ç»“

### å…³é”®è¦ç‚¹

1. **ç¼–è¯‘æ—¶æ£€æŸ¥**: Rust çš„ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶æ•è·å¤§éƒ¨åˆ†ç±»å‹é”™è¯¯
2. **é›¶æˆæœ¬æŠ½è±¡**: ç±»å‹å®‰å…¨ä¸å¸¦æ¥è¿è¡Œæ—¶å¼€é”€
3. **å†…å­˜å®‰å…¨**: ç±»å‹å®‰å…¨ä¸å†…å­˜å®‰å…¨ç´§å¯†ç›¸å…³
4. **å·¥å…·æ”¯æŒ**: åˆ©ç”¨ç¼–è¯‘å™¨å’Œé™æ€åˆ†æå·¥å…·

### è¿›ä¸€æ­¥å­¦ä¹ 

- [Rust å®˜æ–¹æ–‡æ¡£ - ç±»å‹ç³»ç»Ÿ](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html)
- [Rust å®˜æ–¹æ–‡æ¡£ - æ³›å‹](https://doc.rust-lang.org/book/ch10-00-generics.html)
- [Rust å®˜æ–¹æ–‡æ¡£ - ç”Ÿå‘½å‘¨æœŸ](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)

---

**æ–‡æ¡£çŠ¶æ€**: å®Œæ•´ âœ…  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤çŠ¶æ€**: æŒç»­æ›´æ–°ä¸­
