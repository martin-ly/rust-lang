# C04: 常见问题解答 (FAQ)

> **文档定位**: 泛型编程常见问题的快速解答  
> **使用方式**: 查找遇到的问题，获取简明答案  
> **相关文档**: [泛型基础](./generic_fundamentals.md) | [术语表](./Glossary.md) | [主索引](./00_MASTER_INDEX.md)

**最后更新**: 2025-10-19  
**适用版本**: Rust 1.0+  
**文档类型**: ❓ 问答手册

---

## 📋 问题索引

- [C04: 常见问题解答 (FAQ)](#c04-常见问题解答-faq)
  - [📋 问题索引](#-问题索引)
  - [Q1: Rust 的泛型是零成本的，这是什么意思？它有什么缺点吗？\*\*](#q1-rust-的泛型是零成本的这是什么意思它有什么缺点吗)
  - [Q6: 2025年有哪些泛型新特性？ 🆕](#q6-2025年有哪些泛型新特性-)
  - [📚 延伸阅读](#-延伸阅读)

---

## Q1: Rust 的泛型是零成本的，这是什么意思？它有什么缺点吗？**

A1: "零成本"是指使用泛型不会带来任何**运行时**性能开销。这是通过**单态化**实现的：编译器为每个使用的具体类型生成一份专门的、非泛型的代码。因此，泛型代码的运行速度与手写具体类型版本的代码完全相同。其主要缺点是可能增加**编译时间**和最终**二进制文件的大小**，因为同一段泛型代码可能会被复制多份。不过，在实践中，编译器的优化通常能将此影响控制在合理范围内。

**Q2: 什么是静态分派 (Static Dispatch) 和动态分派 (Dynamic Dispatch)？**

A2:

- **静态分派**: 编译器在**编译时**就知道具体要调用哪个函数实现。Rust 的泛型使用的就是静态分派。因为没有运行时查找，所以速度非常快。
- **动态分派**: 编译器在编译时不知道要调用哪个函数，需要到**运行时**才能确定。Rust 的 Trait 对象 (`&dyn Trait`) 使用的就是动态分派。它通过 vtable（虚方法表）在运行时查找正确的函数地址，这会带来一点微小的性能开销。

**Q3: 什么时候应该使用泛型 (静态多态)，什么时候应该使用 Trait 对象 (动态多态)？**

A3:

- **使用泛型**: 当你在编写函数或数据结构时，希望最大化性能，并且可以在编译时确定所有涉及的类型时。这是 Rust 中最常用、最首选的方式。
- **使用 Trait 对象**: 当你需要一个集合（如 `Vec`）来存放多种不同类型的对象，只要它们都实现了同一个 Trait 时。例如，一个图形界面库可能有一个 `Vec<Box<dyn Widget>>` 来存放按钮、文本框等不同类型的 UI 组件。这种需要异构集合的场景是动态分派的主要优势所在。

**Q4: Trait 的关联类型 (Associated Types) 和泛型类型参数 (Generic Type Parameters) 有什么区别？**

A4: 主要区别在于一个类型能实现 Trait 的次数。

- **泛型类型参数**: 一个类型可以为不同的泛型参数多次实现同一个 Trait。例如 `impl From<i32> for MyType` 和 `impl From<f64> for MyType`。
- **关联类型**: 一个类型只能实现一次带有某个关联类型的 Trait，因为该关联类型在该实现中必须是唯一确定的。例如，一个迭代器（如 `vec![1, 2].iter()`）的 `Item` 类型只能是 `i32`，不可能是其他类型。因此，`Iterator` Trait 使用关联类型 `Item` 而不是泛型参数。

**Q5: 什么是高阶类型 (HKT)？为什么它在 Rust 社区中备受关注？**

A5: 高阶类型是泛化"容器"本身的能力。想象一下，你想写一个函数，它能对任何容器（如 `Vec<T>`, `Option<T>`, `Result<T, E>`）执行 `map` 操作，而无需关心这个容器具体是什么。HKT 就能让你表达这种 `F<_>` 形式的泛型，其中 `F` 是一个类型构造器。它之所以备受关注，是因为它能解锁更高层次的抽象，特别是在函数式编程领域，可以方便地实现像 `Functor`, `Monad` 等强大的设计模式，从而编写出更通用、更具组合性的库。虽然 Rust 目前没有原生支持，但它代表了类型系统演进的一个重要方向。

**相关**: [HKT讨论](./05_advanced_topics.md#53-a-note-on-higher-kinded-types-hkt)

---

## Q6: 2025年有哪些泛型新特性？ 🆕

**A6**: 截至2025年10月，主要的稳定特性包括：

- **GATs (Rust 1.65, 2022.11)**: 泛型关联类型已经稳定2年多，允许在关联类型上使用泛型参数
- **RPITIT (Rust 1.75, 2023.12)**: 在trait方法返回位置使用 `impl Trait`，避免Box开销
- **const泛型推断 (Rust 1.89, 2025.Q1)**: 可以使用 `_` 让编译器推断常量泛型参数
- **Rust 1.90 (2025.Q2)**: 主要改进在工具链（Cargo工作区发布、LLD链接器），泛型系统无重大变化

**注意**:

❌ **常见误解**: "GATs和RPITIT是Rust 1.90的新特性"  
✅ **正确信息**: 这些特性早在2022-2023年就已稳定

**详细信息**:

- [版本历史文档](./06_rust_features/RUST_VERSION_HISTORY_ACCURATE.md) - 准确的时间线
- [05_advanced_topics.md](./05_advanced_topics.md#54-现代泛型特性进展-2025年更新-) - 详细的特性说明

---

## 📚 延伸阅读

- [泛型基础](./generic_fundamentals.md) - 系统学习
- [实践指南](./PRACTICAL_GENERICS_GUIDE.md) - 实际代码示例
- [术语表](./Glossary.md) - 术语参考
- [主索引](./00_MASTER_INDEX.md) - 文档导航

---

**最后审核**: 2025-10-19  
**维护**: 定期更新问答和链接  
**反馈**: 如有新问题建议，请提交Issue
