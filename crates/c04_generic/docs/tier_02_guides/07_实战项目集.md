# ğŸ”§ C04: Generic Programming - å®æˆ˜é¡¹ç›®é›†

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C04 æ³›å‹ç¼–ç¨‹
> **ç›®æ ‡**: é€šè¿‡å®æˆ˜é¡¹ç›®æŒæ¡æ³›å‹ã€Trait Bounds å’Œç±»å‹ç³»ç»Ÿ

---

## ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•

- [ğŸ”§ C04: Generic Programming - å®æˆ˜é¡¹ç›®é›†](#-c04-generic-programming---å®æˆ˜é¡¹ç›®é›†)
  - [ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•](#-æœ¬æ–‡æ¡£ç›®å½•)
  - [ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ](#-é¡¹ç›®æ¦‚è§ˆ)
  - [é¡¹ç›®1: æ³›å‹å®¹å™¨](#é¡¹ç›®1-æ³›å‹å®¹å™¨)
    - [ğŸ“– é¡¹ç›®è¯´æ˜](#-é¡¹ç›®è¯´æ˜)
    - [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
    - [æ ¸å¿ƒä»£ç ](#æ ¸å¿ƒä»£ç )
    - [æµ‹è¯•è¾“å‡º](#æµ‹è¯•è¾“å‡º)
  - [é¡¹ç›®2: æ³›å‹ç®—æ³•åº“](#é¡¹ç›®2-æ³›å‹ç®—æ³•åº“)
    - [ğŸ“– é¡¹ç›®è¯´æ˜2](#-é¡¹ç›®è¯´æ˜2)
    - [å­¦ä¹ ç›®æ ‡2](#å­¦ä¹ ç›®æ ‡2)
    - [æ ¸å¿ƒä»£ç 2](#æ ¸å¿ƒä»£ç 2)
  - [é¡¹ç›®3: ç±»å‹çº§ç¼–ç¨‹](#é¡¹ç›®3-ç±»å‹çº§ç¼–ç¨‹)
    - [ğŸ“– é¡¹ç›®è¯´æ˜3](#-é¡¹ç›®è¯´æ˜3)
    - [å­¦ä¹ ç›®æ ‡3](#å­¦ä¹ ç›®æ ‡3)
    - [æ ¸å¿ƒä»£ç 3](#æ ¸å¿ƒä»£ç 3)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å…³é”®æ¦‚å¿µ](#å…³é”®æ¦‚å¿µ)

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

| #   | é¡¹ç›®åç§°                        | éš¾åº¦   | é¢„è®¡æ—¶é—´ | æ ¸å¿ƒæ¦‚å¿µ                 |
| :--- | :--- | :--- | :--- | :--- || 1   | [æ³›å‹å®¹å™¨](#é¡¹ç›®1-æ³›å‹å®¹å™¨)     | â­     | 1-2å°æ—¶  | æ³›å‹ç»“æ„ä½“ã€æ–¹æ³•         |
| 2   | [æ³›å‹ç®—æ³•åº“](#é¡¹ç›®2-æ³›å‹ç®—æ³•åº“) | â­â­   | 2-3å°æ—¶  | Trait Boundsã€where å­å¥ |
| 3   | [ç±»å‹çº§ç¼–ç¨‹](#é¡¹ç›®3-ç±»å‹çº§ç¼–ç¨‹) | â­â­â­ | 3-4å°æ—¶  | é›¶å¤§å°ç±»å‹ã€PhantomData  |

---

## é¡¹ç›®1: æ³›å‹å®¹å™¨

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­
**é¢„è®¡æ—¶é—´**: 1-2å°æ—¶

### å­¦ä¹ ç›®æ ‡

- å®ç°æ³›å‹ç»“æ„ä½“
- å®šä¹‰æ³›å‹æ–¹æ³•
- ä½¿ç”¨ Trait Bounds
- å®ç°å¸¸ç”¨å®¹å™¨æ–¹æ³•

### æ ¸å¿ƒä»£ç 

```rust
use std::fmt::Display;

/// æ³›å‹æ ˆ
struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { items: Vec::new() }
    }

    fn push(&mut self, item: T) {
        self.items.push(item);
    }

    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }

    fn peek(&self) -> Option<&T> {
        self.items.last()
    }

    fn len(&self) -> usize {
        self.items.len()
    }

    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
}

// ä¸ºå®ç°äº† Display çš„ç±»å‹æ·»åŠ é¢å¤–æ–¹æ³•
impl<T: Display> Stack<T> {
    fn print_all(&self) {
        println!("Stack contents:");
        for (i, item) in self.items.iter().enumerate() {
            println!("  [{}]: {}", i, item);
        }
    }
}

/// æ³›å‹é˜Ÿåˆ—
struct Queue<T> {
    items: Vec<T>,
}

impl<T> Queue<T> {
    fn new() -> Self {
        Queue { items: Vec::new() }
    }

    fn enqueue(&mut self, item: T) {
        self.items.push(item);
    }

    fn dequeue(&mut self) -> Option<T> {
        if self.items.is_empty() {
            None
        } else {
            Some(self.items.remove(0))
        }
    }

    fn peek(&self) -> Option<&T> {
        self.items.first()
    }

    fn len(&self) -> usize {
        self.items.len()
    }
}

/// æ³›å‹é…å¯¹
struct Pair<T, U> {
    first: T,
    second: U,
}

impl<T, U> Pair<T, U> {
    fn new(first: T, second: U) -> Self {
        Pair { first, second }
    }

    fn split(self) -> (T, U) {
        (self.first, self.second)
    }
}

impl<T: Display, U: Display> Pair<T, U> {
    fn show(&self) {
        println!("Pair: ({}, {})", self.first, self.second);
    }
}

fn main() {
    println!("===== æ³›å‹å®¹å™¨æµ‹è¯• =====\n");

    // æµ‹è¯•1: æ³›å‹æ ˆ
    {
        println!("æµ‹è¯•1: æ³›å‹æ ˆ\n");

        let mut stack = Stack::new();
        stack.push(1);
        stack.push(2);
        stack.push(3);

        println!("æ ˆå¤§å°: {}", stack.len());
        stack.print_all();

        println!("\nå¼¹å‡ºå…ƒç´ :");
        while let Some(item) = stack.pop() {
            println!("  {}", item);
        }
        println!();
    }

    // æµ‹è¯•2: å­—ç¬¦ä¸²æ ˆ
    {
        println!("æµ‹è¯•2: å­—ç¬¦ä¸²æ ˆ\n");

        let mut stack = Stack::new();
        stack.push("Hello".to_string());
        stack.push("Rust".to_string());

        stack.print_all();
        println!();
    }

    // æµ‹è¯•3: æ³›å‹é˜Ÿåˆ—
    {
        println!("æµ‹è¯•3: æ³›å‹é˜Ÿåˆ—\n");

        let mut queue = Queue::new();
        queue.enqueue("First");
        queue.enqueue("Second");
        queue.enqueue("Third");

        println!("é˜Ÿåˆ—å¤§å°: {}", queue.len());

        println!("å‡ºé˜Ÿ:");
        while let Some(item) = queue.dequeue() {
            println!("  {}", item);
        }
        println!();
    }

    // æµ‹è¯•4: æ³›å‹é…å¯¹
    {
        println!("æµ‹è¯•4: æ³›å‹é…å¯¹\n");

        let pair1 = Pair::new(10, "ten");
        pair1.show();

        let pair2 = Pair::new("key", 42);
        pair2.show();

        let (k, v) = pair2.split();
        println!("åˆ†ç¦»: {} = {}\n", k, v);
    }
}
```

### æµ‹è¯•è¾“å‡º

```text
===== æ³›å‹å®¹å™¨æµ‹è¯• =====

æµ‹è¯•1: æ³›å‹æ ˆ

æ ˆå¤§å°: 3
Stack contents:
  [0]: 1
  [1]: 2
  [2]: 3

å¼¹å‡ºå…ƒç´ :
  3
  2
  1

æµ‹è¯•2: å­—ç¬¦ä¸²æ ˆ

Stack contents:
  [0]: Hello
  [1]: Rust

æµ‹è¯•3: æ³›å‹é˜Ÿåˆ—

é˜Ÿåˆ—å¤§å°: 3
å‡ºé˜Ÿ:
  First
  Second
  Third
```

---

## é¡¹ç›®2: æ³›å‹ç®—æ³•åº“

### ğŸ“– é¡¹ç›®è¯´æ˜2

**éš¾åº¦**: â­â­
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶

### å­¦ä¹ ç›®æ ‡2

- ä½¿ç”¨å¤æ‚çš„ Trait Bounds
- å®ç°æ³›å‹ç®—æ³•
- ä½¿ç”¨ where å­å¥
- å…³è”ç±»å‹åº”ç”¨

### æ ¸å¿ƒä»£ç 2

```rust
use std::cmp::PartialOrd;
use std::fmt::Debug;

/// æŸ¥æ‰¾æœ€å¤§å€¼ï¼ˆæ³›å‹ï¼‰
fn find_max<T: PartialOrd + Copy>(slice: &[T]) -> Option<T> {
    if slice.is_empty() {
        return None;
    }

    let mut max = slice[0];
    for &item in slice.iter().skip(1) {
        if item > max {
            max = item;
        }
    }
    Some(max)
}

/// æ’åºç®—æ³•ï¼ˆå†’æ³¡æ’åºï¼‰
fn bubble_sort<T: PartialOrd>(slice: &mut [T]) {
    let len = slice.len();
    for i in 0..len {
        for j in 0..len - 1 - i {
            if slice[j] > slice[j + 1] {
                slice.swap(j, j + 1);
            }
        }
    }
}

/// äºŒåˆ†æŸ¥æ‰¾
fn binary_search<T: PartialOrd>(slice: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = slice.len();

    while left < right {
        let mid = (left + right) / 2;

        if slice[mid] < *target {
            left = mid + 1;
        } else if slice[mid] > *target {
            right = mid;
        } else {
            return Some(mid);
        }
    }

    None
}

/// æ˜ å°„å’Œè¿‡æ»¤
fn map_and_filter<T, U, F, P>(slice: &[T], map: F, predicate: P) -> Vec<U>
where
    T: Clone,
    F: Fn(&T) -> U,
    P: Fn(&U) -> bool,
{
    slice.iter()
        .map(map)
        .filter(predicate)
        .collect()
}

/// ç»Ÿè®¡ä¿¡æ¯
struct Stats<T> {
    min: T,
    max: T,
    count: usize,
}

fn calculate_stats<T>(slice: &[T]) -> Option<Stats<T>>
where
    T: PartialOrd + Copy + Debug,
{
    if slice.is_empty() {
        return None;
    }

    let mut min = slice[0];
    let mut max = slice[0];

    for &item in slice.iter() {
        if item < min {
            min = item;
        }
        if item > max {
            max = item;
        }
    }

    Some(Stats {
        min,
        max,
        count: slice.len(),
    })
}

fn main() {
    println!("===== æ³›å‹ç®—æ³•åº“æµ‹è¯• =====\n");

    // æµ‹è¯•1: æŸ¥æ‰¾æœ€å¤§å€¼
    {
        println!("æµ‹è¯•1: æŸ¥æ‰¾æœ€å¤§å€¼\n");

        let numbers = vec![3, 7, 2, 9, 1];
        if let Some(max) = find_max(&numbers) {
            println!("æœ€å¤§å€¼: {}", max);
        }

        let floats = vec![3.14, 2.71, 1.41, 9.81];
        if let Some(max) = find_max(&floats) {
            println!("æœ€å¤§æµ®ç‚¹æ•°: {}\n", max);
        }
    }

    // æµ‹è¯•2: æ’åº
    {
        println!("æµ‹è¯•2: å†’æ³¡æ’åº\n");

        let mut numbers = vec![5, 2, 8, 1, 9];
        println!("åŸå§‹: {:?}", numbers);

        bubble_sort(&mut numbers);
        println!("æ’åºå: {:?}\n", numbers);
    }

    // æµ‹è¯•3: äºŒåˆ†æŸ¥æ‰¾
    {
        println!("æµ‹è¯•3: äºŒåˆ†æŸ¥æ‰¾\n");

        let numbers = vec![1, 3, 5, 7, 9, 11];

        match binary_search(&numbers, &7) {
            Some(idx) => println!("æ‰¾åˆ° 7 åœ¨ç´¢å¼•: {}", idx),
            None => println!("æœªæ‰¾åˆ°"),
        }

        match binary_search(&numbers, &4) {
            Some(idx) => println!("æ‰¾åˆ° 4 åœ¨ç´¢å¼•: {}", idx),
            None => println!("æœªæ‰¾åˆ° 4\n"),
        }
    }

    // æµ‹è¯•4: æ˜ å°„å’Œè¿‡æ»¤
    {
        println!("æµ‹è¯•4: æ˜ å°„å’Œè¿‡æ»¤\n");

        let numbers = vec![1, 2, 3, 4, 5];

        let doubled_evens = map_and_filter(
            &numbers,
            |&n| n * 2,
            |&n| n % 2 == 0,
        );

        println!("åŸå§‹: {:?}", numbers);
        println!("åŠ å€çš„å¶æ•°: {:?}\n", doubled_evens);
    }

    // æµ‹è¯•5: ç»Ÿè®¡
    {
        println!("æµ‹è¯•5: ç»Ÿè®¡ä¿¡æ¯\n");

        let numbers = vec![3, 7, 2, 9, 1, 5];

        if let Some(stats) = calculate_stats(&numbers) {
            println!("æ•°æ®: {:?}", numbers);
            println!("æœ€å°å€¼: {:?}", stats.min);
            println!("æœ€å¤§å€¼: {:?}", stats.max);
            println!("æ•°é‡: {}", stats.count);
        }
    }
}
```

---

## é¡¹ç›®3: ç±»å‹çº§ç¼–ç¨‹

### ğŸ“– é¡¹ç›®è¯´æ˜3

**éš¾åº¦**: â­â­â­
**é¢„è®¡æ—¶é—´**: 3-4å°æ—¶

### å­¦ä¹ ç›®æ ‡3

- ä½¿ç”¨é›¶å¤§å°ç±»å‹ï¼ˆZSTï¼‰
- ç†è§£ PhantomData
- å®ç°ç±»å‹çŠ¶æ€æ¨¡å¼
- ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥

### æ ¸å¿ƒä»£ç 3

```rust
use std::marker::PhantomData;

/// çŠ¶æ€æ ‡è®°
struct Open;
struct Closed;

/// æ–‡ä»¶å¥æŸ„ï¼ˆç±»å‹çŠ¶æ€æ¨¡å¼ï¼‰
struct File<State> {
    name: String,
    _state: PhantomData<State>,
}

impl File<Closed> {
    fn new(name: String) -> Self {
        File {
            name,
            _state: PhantomData,
        }
    }

    fn open(self) -> File<Open> {
        println!("ğŸ“‚ æ‰“å¼€æ–‡ä»¶: {}", self.name);
        File {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl File<Open> {
    fn write(&self, data: &str) {
        println!("âœï¸  å†™å…¥: {}", data);
    }

    fn read(&self) -> String {
        println!("ğŸ“– è¯»å–æ–‡ä»¶");
        "file contents".to_string()
    }

    fn close(self) -> File<Closed> {
        println!("ğŸ”’ å…³é—­æ–‡ä»¶: {}", self.name);
        File {
            name: self.name,
            _state: PhantomData,
        }
    }
}

fn main() {
    println!("===== ç±»å‹çº§ç¼–ç¨‹æµ‹è¯• =====\n");

    let file = File::new("data.txt".to_string());

    // file.write("test");  // âŒ ç¼–è¯‘é”™è¯¯ï¼šå…³é—­çš„æ–‡ä»¶ä¸èƒ½å†™å…¥

    let file = file.open();
    file.write("Hello, Rust!");
    let _ = file.read();

    let file = file.close();

    // file.write("test");  // âŒ ç¼–è¯‘é”™è¯¯ï¼šå…³é—­çš„æ–‡ä»¶ä¸èƒ½å†™å…¥

    // å¯ä»¥é‡æ–°æ‰“å¼€
    let file = file.open();
    file.write("More data");
}
```

---

## ğŸ“ æ€»ç»“

### å…³é”®æ¦‚å¿µ

| æ¦‚å¿µ         | é¡¹ç›®1  | é¡¹ç›®2  | é¡¹ç›®3  |
| :--- | :--- | :--- | :--- || æ³›å‹ç»“æ„ä½“   | âœ…âœ…âœ… | âœ…     | âœ…âœ…   |
| æ³›å‹å‡½æ•°     | âœ…âœ…   | âœ…âœ…âœ… | âœ…     |
| Trait Bounds | âœ…âœ…   | âœ…âœ…âœ… | âœ…âœ…   |
| where å­å¥   | âŒ     | âœ…âœ…âœ… | âœ…     |
| PhantomData  | âŒ     | âŒ     | âœ…âœ…âœ… |
| ç±»å‹çŠ¶æ€     | âŒ     | âŒ     | âœ…âœ…âœ… |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25

**ğŸ¯ æŒæ¡æ³›å‹ç¼–ç¨‹ï¼Œå†™å‡ºçµæ´»ä¸”ç±»å‹å®‰å…¨çš„ä»£ç ï¼ğŸ¦€**-
