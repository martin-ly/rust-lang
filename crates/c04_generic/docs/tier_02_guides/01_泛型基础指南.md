# C04 æ³›å‹ç¼–ç¨‹ - æ³›å‹åŸºç¡€æŒ‡å—

**æ–‡æ¡£ç±»å‹**: Tier 2 å®è·µæŒ‡å—  
**éš¾åº¦çº§åˆ«**: â­â­ åˆçº§  
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4 å°æ—¶  
**æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•

- [C04 æ³›å‹ç¼–ç¨‹ - æ³›å‹åŸºç¡€æŒ‡å—](#c04-æ³›å‹ç¼–ç¨‹---æ³›å‹åŸºç¡€æŒ‡å—)
  - [ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•](#-æœ¬æ–‡æ¡£ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
  - [1. æ³›å‹æ¦‚è¿°](#1-æ³›å‹æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯æ³›å‹ï¼Ÿ](#11-ä»€ä¹ˆæ˜¯æ³›å‹)
    - [1.2 ä¸ºä»€ä¹ˆéœ€è¦æ³›å‹ï¼Ÿ](#12-ä¸ºä»€ä¹ˆéœ€è¦æ³›å‹)
    - [1.3 Rust æ³›å‹çš„ç‰¹ç‚¹](#13-rust-æ³›å‹çš„ç‰¹ç‚¹)
  - [2. æ³›å‹å‡½æ•°](#2-æ³›å‹å‡½æ•°)
    - [2.1 åŸºç¡€è¯­æ³•](#21-åŸºç¡€è¯­æ³•)
    - [2.2 å¤šä¸ªç±»å‹å‚æ•°](#22-å¤šä¸ªç±»å‹å‚æ•°)
    - [2.3 å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°](#23-å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°)
    - [2.4 å®æˆ˜æ¡ˆä¾‹ï¼šæŸ¥æ‰¾æœ€å¤§å€¼](#24-å®æˆ˜æ¡ˆä¾‹æŸ¥æ‰¾æœ€å¤§å€¼)
  - [3. æ³›å‹ç»“æ„ä½“](#3-æ³›å‹ç»“æ„ä½“)
    - [3.1 åŸºç¡€è¯­æ³•](#31-åŸºç¡€è¯­æ³•)
    - [3.2 å¤šä¸ªç±»å‹å‚æ•°](#32-å¤šä¸ªç±»å‹å‚æ•°)
    - [3.3 å­—æ®µä¸­ä½¿ç”¨æ³›å‹](#33-å­—æ®µä¸­ä½¿ç”¨æ³›å‹)
    - [3.4 å®æˆ˜æ¡ˆä¾‹ï¼šåæ ‡ç‚¹](#34-å®æˆ˜æ¡ˆä¾‹åæ ‡ç‚¹)
  - [4. æ³›å‹æšä¸¾](#4-æ³›å‹æšä¸¾)
    - [4.1 æ ‡å‡†åº“ä¸­çš„æ³›å‹æšä¸¾](#41-æ ‡å‡†åº“ä¸­çš„æ³›å‹æšä¸¾)
    - [4.2 è‡ªå®šä¹‰æ³›å‹æšä¸¾](#42-è‡ªå®šä¹‰æ³›å‹æšä¸¾)
    - [4.3 å®æˆ˜æ¡ˆä¾‹ï¼šæ ‘ç»“æ„](#43-å®æˆ˜æ¡ˆä¾‹æ ‘ç»“æ„)
  - [5. æ³›å‹æ–¹æ³•å®ç°](#5-æ³›å‹æ–¹æ³•å®ç°)
    - [5.1 ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•](#51-ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•)
    - [5.2 æ–¹æ³•ä¸­çš„æ³›å‹å‚æ•°](#52-æ–¹æ³•ä¸­çš„æ³›å‹å‚æ•°)
    - [5.3 ä¸ºå…·ä½“ç±»å‹å®ç°æ–¹æ³•](#53-ä¸ºå…·ä½“ç±»å‹å®ç°æ–¹æ³•)
  - [6. Const æ³›å‹](#6-const-æ³›å‹)
    - [6.1 åŸºç¡€è¯­æ³•](#61-åŸºç¡€è¯­æ³•)
    - [6.2 å®æˆ˜æ¡ˆä¾‹ï¼šå›ºå®šå¤§å°æ•°ç»„](#62-å®æˆ˜æ¡ˆä¾‹å›ºå®šå¤§å°æ•°ç»„)
  - [7. é»˜è®¤ç±»å‹å‚æ•°](#7-é»˜è®¤ç±»å‹å‚æ•°)
    - [7.1 åŸºç¡€è¯­æ³•](#71-åŸºç¡€è¯­æ³•)
    - [7.2 å®æˆ˜æ¡ˆä¾‹ï¼šå¯é…ç½®çš„å®¹å™¨](#72-å®æˆ˜æ¡ˆä¾‹å¯é…ç½®çš„å®¹å™¨)
  - [8. æ³›å‹çº¦æŸåŸºç¡€](#8-æ³›å‹çº¦æŸåŸºç¡€)
    - [8.1 å•ä¸ªçº¦æŸ](#81-å•ä¸ªçº¦æŸ)
    - [8.2 å¤šä¸ªçº¦æŸ](#82-å¤šä¸ªçº¦æŸ)
    - [8.3 where å­å¥](#83-where-å­å¥)
  - [9. å®æˆ˜ç»¼åˆæ¡ˆä¾‹](#9-å®æˆ˜ç»¼åˆæ¡ˆä¾‹)
    - [9.1 æ¡ˆä¾‹ 1ï¼šé€šç”¨ç¼“å­˜ç³»ç»Ÿ](#91-æ¡ˆä¾‹-1é€šç”¨ç¼“å­˜ç³»ç»Ÿ)
    - [9.2 æ¡ˆä¾‹ 2ï¼šæ•°æ®è½¬æ¢ç®¡é“](#92-æ¡ˆä¾‹-2æ•°æ®è½¬æ¢ç®¡é“)
  - [10. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#10-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [10.1 å¸¸è§é”™è¯¯](#101-å¸¸è§é”™è¯¯)
    - [10.2 æœ€ä½³å®è·µ](#102-æœ€ä½³å®è·µ)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ¯ ç»ƒä¹ é¢˜](#-ç»ƒä¹ é¢˜)
  - [ğŸ“ å°ç»“](#-å°ç»“)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬æŒ‡å—çš„å­¦ä¹ ï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£æ³›å‹çš„æ¦‚å¿µå’Œä»·å€¼
- âœ… ç¼–å†™æ³›å‹å‡½æ•°ã€ç»“æ„ä½“å’Œæšä¸¾
- âœ… ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•
- âœ… ä½¿ç”¨ const æ³›å‹å’Œé»˜è®¤ç±»å‹å‚æ•°
- âœ… æŒæ¡åŸºç¡€çš„æ³›å‹çº¦æŸ
- âœ… åº”ç”¨æ³›å‹è§£å†³å®é™…é—®é¢˜

---

## ğŸ“š å‰ç½®çŸ¥è¯†

åœ¨å­¦ä¹ æœ¬æŒ‡å—ä¹‹å‰ï¼Œä½ åº”è¯¥æŒæ¡ï¼š

- âœ… Rust åŸºç¡€è¯­æ³•ï¼ˆå˜é‡ã€å‡½æ•°ã€æ§åˆ¶æµï¼‰
- âœ… Rust æ‰€æœ‰æƒç³»ç»Ÿï¼ˆæ‰€æœ‰æƒã€å€Ÿç”¨ã€ç”Ÿå‘½å‘¨æœŸï¼‰
- âœ… ç»“æ„ä½“å’Œæšä¸¾çš„å®šä¹‰å’Œä½¿ç”¨
- âœ… trait çš„åŸºæœ¬æ¦‚å¿µï¼ˆåœ¨ [02_Traitç³»ç»ŸæŒ‡å—.md](./02_Traitç³»ç»ŸæŒ‡å—.md) ä¸­è¯¦ç»†è®²è§£ï¼‰

---

## 1. æ³›å‹æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯æ³›å‹ï¼Ÿ

**æ³›å‹** (Generics) æ˜¯ä¸€ç§ç¼–ç¨‹æŠ€æœ¯ï¼Œå…è®¸æˆ‘ä»¬åœ¨å®šä¹‰å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾å’Œæ–¹æ³•æ—¶ä½¿ç”¨**ç±»å‹å‚æ•°**ï¼Œè€Œä¸æ˜¯å…·ä½“çš„ç±»å‹ã€‚

```rust
// éæ³›å‹ï¼šåªèƒ½å¤„ç† i32
fn max_i32(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}

// æ³›å‹ï¼šå¯ä»¥å¤„ç†ä»»ä½•å¯æ¯”è¾ƒçš„ç±»å‹
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

fn main() {
    println!("{}", max(10, 20));       // 20
    println!("{}", max(3.14, 2.71));   // 3.14
    println!("{}", max('a', 'z'));     // 'z'
}
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦æ³›å‹ï¼Ÿ

**é—®é¢˜**: æ²¡æœ‰æ³›å‹æ—¶çš„ä»£ç é‡å¤

```rust
fn max_i32(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}

fn max_f64(a: f64, b: f64) -> f64 {
    if a > b { a } else { b }
}

fn max_char(a: char, b: char) -> char {
    if a > b { a } else { b }
}

// æ¯ç§ç±»å‹éƒ½éœ€è¦ä¸€ä¸ªå‡½æ•°ï¼
```

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨æ³›å‹

```rust
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// ä¸€ä¸ªå‡½æ•°å¤„ç†æ‰€æœ‰å¯æ¯”è¾ƒçš„ç±»å‹ï¼
```

**æ³›å‹çš„ä»·å€¼**:

1. **ä»£ç å¤ç”¨**: ä¸€ä»½ä»£ç ï¼Œå¤šç§ç±»å‹
2. **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
3. **é›¶æˆæœ¬æŠ½è±¡**: è¿è¡Œæ—¶æ— æ€§èƒ½æŸå¤±
4. **æ›´å¥½çš„å¯ç»´æŠ¤æ€§**: å‡å°‘é‡å¤ä»£ç 

### 1.3 Rust æ³›å‹çš„ç‰¹ç‚¹

**1. é™æ€åˆ†å‘ (Monomorphization)**:

```rust
fn print<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

fn main() {
    print(42);      // ç¼–è¯‘å™¨ç”Ÿæˆ print_i32
    print("hello"); // ç¼–è¯‘å™¨ç”Ÿæˆ print_str
}
```

ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨çš„å‡½æ•°ç‰ˆæœ¬ï¼Œå®ç°é›¶æˆæœ¬æŠ½è±¡ã€‚

**2. çº¦æŸç³»ç»Ÿ (Trait Bounds)**:

```rust
// T å¿…é¡»å®ç° Clone å’Œ Debug trait
fn duplicate<T: Clone + std::fmt::Debug>(value: T) -> (T, T) {
    let copy = value.clone();
    println!("Duplicating: {:?}", value);
    (value, copy)
}
```

**3. ç±»å‹æ¨æ–­**:

```rust
// ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨æ–­ç±»å‹å‚æ•°
let v = Vec::new();
v.push(42); // ç¼–è¯‘å™¨æ¨æ–­ Vec<i32>

// ä¹Ÿå¯ä»¥æ˜¾å¼æŒ‡å®š
let v: Vec<i32> = Vec::new();
let v = Vec::<i32>::new(); // Turbofish è¯­æ³•
```

---

## 2. æ³›å‹å‡½æ•°

### 2.1 åŸºç¡€è¯­æ³•

**è¯­æ³•æ ¼å¼**:

```rust
fn function_name<T>(param: T) -> T {
    // å‡½æ•°ä½“
}
```

**ç¤ºä¾‹ 1: ç®€å•æ³›å‹å‡½æ•°**:

```rust
// è¿”å›ä¼ å…¥çš„å€¼ï¼ˆèº«ä»½å‡½æ•°ï¼‰
fn identity<T>(value: T) -> T {
    value
}

fn main() {
    let num = identity(42);       // i32
    let text = identity("hello"); // &str
    let flag = identity(true);    // bool
    
    println!("{}, {}, {}", num, text, flag);
}
```

**ç¤ºä¾‹ 2: ä½¿ç”¨æ³›å‹å¼•ç”¨**:

```rust
// è¿”å›ä¸¤ä¸ªå€¼ä¸­çš„ç¬¬ä¸€ä¸ª
fn first<T>(a: T, b: T) -> T {
    a
}

// æ›´å®ç”¨çš„ç‰ˆæœ¬ï¼šä½¿ç”¨å¼•ç”¨é¿å…æ‰€æœ‰æƒè½¬ç§»
fn first_ref<T>(a: &T, b: &T) -> &T {
    a
}

fn main() {
    let x = String::from("hello");
    let y = String::from("world");
    
    // first(x, y); // é”™è¯¯ï¼šx, y çš„æ‰€æœ‰æƒè¢«ç§»èµ°
    
    let result = first_ref(&x, &y);
    println!("{}", result); // "hello"
    println!("{}, {}", x, y); // x, y ä»ç„¶å¯ç”¨
}
```

### 2.2 å¤šä¸ªç±»å‹å‚æ•°

```rust
// ä¸¤ä¸ªä¸åŒçš„ç±»å‹å‚æ•°
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

fn main() {
    let p1 = pair(42, "answer");     // (i32, &str)
    let p2 = pair(3.14, true);       // (f64, bool)
    let p3 = pair("x", 'y');         // (&str, char)
    
    println!("{:?}", p1);
}
```

### 2.3 å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°

```rust
use std::fmt::Display;

// T å¿…é¡»å®ç° Display trait
fn print_twice<T: Display>(value: T) {
    println!("{}", value);
    println!("{}", value);
}

fn main() {
    print_twice(42);
    print_twice("hello");
    // print_twice(vec![1, 2, 3]); // é”™è¯¯ï¼šVec æ²¡æœ‰å®ç° Display
}
```

### 2.4 å®æˆ˜æ¡ˆä¾‹ï¼šæŸ¥æ‰¾æœ€å¤§å€¼

```rust
// æŸ¥æ‰¾åˆ‡ç‰‡ä¸­çš„æœ€å¤§å€¼
fn find_max<T: PartialOrd + Clone>(list: &[T]) -> Option<T> {
    if list.is_empty() {
        return None;
    }
    
    let mut max = list[0].clone();
    for item in list.iter() {
        if item > &max {
            max = item.clone();
        }
    }
    
    Some(max)
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    println!("æœ€å¤§å€¼: {:?}", find_max(&numbers)); // Some(100)
    
    let chars = vec!['y', 'm', 'a', 'q'];
    println!("æœ€å¤§å­—ç¬¦: {:?}", find_max(&chars)); // Some('y')
    
    let empty: Vec<i32> = vec![];
    println!("ç©ºåˆ—è¡¨: {:?}", find_max(&empty)); // None
}
```

---

## 3. æ³›å‹ç»“æ„ä½“

### 3.1 åŸºç¡€è¯­æ³•

**è¯­æ³•æ ¼å¼**:

```rust
struct StructName<T> {
    field: T,
}
```

**ç¤ºä¾‹ 1: ç®€å•æ³›å‹ç»“æ„ä½“**:

```rust
struct Wrapper<T> {
    value: T,
}

fn main() {
    let int_wrapper = Wrapper { value: 42 };
    let str_wrapper = Wrapper { value: "hello" };
    let vec_wrapper = Wrapper { value: vec![1, 2, 3] };
    
    println!("{}", int_wrapper.value);
}
```

### 3.2 å¤šä¸ªç±»å‹å‚æ•°

```rust
struct Pair<T, U> {
    first: T,
    second: U,
}

fn main() {
    let pair1 = Pair {
        first: 10,
        second: "ten",
    };
    
    let pair2 = Pair {
        first: 3.14,
        second: true,
    };
    
    println!("{}, {}", pair1.first, pair1.second);
}
```

### 3.3 å­—æ®µä¸­ä½¿ç”¨æ³›å‹

```rust
struct Container<T> {
    items: Vec<T>,
    default: T,
}

impl<T: Clone> Container<T> {
    fn new(default: T) -> Self {
        Container {
            items: Vec::new(),
            default,
        }
    }
    
    fn add(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn get_or_default(&self, index: usize) -> T {
        self.items.get(index)
            .cloned()
            .unwrap_or_else(|| self.default.clone())
    }
}

fn main() {
    let mut container = Container::new(0);
    container.add(10);
    container.add(20);
    
    println!("{}", container.get_or_default(0)); // 10
    println!("{}", container.get_or_default(5)); // 0 (default)
}
```

### 3.4 å®æˆ˜æ¡ˆä¾‹ï¼šåæ ‡ç‚¹

```rust
#[derive(Debug, Clone, Copy)]
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
}

impl<T: std::ops::Add<Output = T>> Point<T> {
    fn add(self, other: Point<T>) -> Point<T> {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl Point<f64> {
    fn distance_from_origin(&self) -> f64 {
        (self.x * self.x + self.y * self.y).sqrt()
    }
}

fn main() {
    let p1 = Point::new(3, 4);
    let p2 = Point::new(5, 6);
    let p3 = p1.add(p2);
    println!("{:?}", p3); // Point { x: 8, y: 10 }
    
    let pf = Point::new(3.0, 4.0);
    println!("è·ç¦»: {}", pf.distance_from_origin()); // 5.0
}
```

---

## 4. æ³›å‹æšä¸¾

### 4.1 æ ‡å‡†åº“ä¸­çš„æ³›å‹æšä¸¾

**`Option<T>`**

```rust
enum Option<T> {
    Some(T),
    None,
}

fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Some(result) => println!("ç»“æœ: {}", result),
        None => println!("é™¤æ•°ä¸ºé›¶"),
    }
}
```

**`Result<T, E>`**

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn parse_number(s: &str) -> Result<i32, String> {
    s.parse::<i32>()
        .map_err(|_| format!("æ— æ³•è§£æ: {}", s))
}

fn main() {
    match parse_number("42") {
        Ok(n) => println!("æ•°å­—: {}", n),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

### 4.2 è‡ªå®šä¹‰æ³›å‹æšä¸¾

```rust
enum Data<T> {
    Single(T),
    Multiple(Vec<T>),
    Empty,
}

impl<T> Data<T> {
    fn count(&self) -> usize {
        match self {
            Data::Single(_) => 1,
            Data::Multiple(vec) => vec.len(),
            Data::Empty => 0,
        }
    }
}

fn main() {
    let d1 = Data::Single(42);
    let d2 = Data::Multiple(vec![1, 2, 3]);
    let d3: Data<i32> = Data::Empty;
    
    println!("{}, {}, {}", d1.count(), d2.count(), d3.count());
    // è¾“å‡º: 1, 3, 0
}
```

### 4.3 å®æˆ˜æ¡ˆä¾‹ï¼šæ ‘ç»“æ„

```rust
#[derive(Debug)]
enum Tree<T> {
    Leaf(T),
    Node {
        value: T,
        left: Box<Tree<T>>,
        right: Box<Tree<T>>,
    },
}

impl<T> Tree<T> {
    fn leaf(value: T) -> Self {
        Tree::Leaf(value)
    }
    
    fn node(value: T, left: Tree<T>, right: Tree<T>) -> Self {
        Tree::Node {
            value,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
}

impl<T: std::fmt::Display> Tree<T> {
    fn print(&self, depth: usize) {
        let indent = "  ".repeat(depth);
        match self {
            Tree::Leaf(v) => println!("{}Leaf({})", indent, v),
            Tree::Node { value, left, right } => {
                println!("{}Node({})", indent, value);
                left.print(depth + 1);
                right.print(depth + 1);
            }
        }
    }
}

fn main() {
    let tree = Tree::node(
        1,
        Tree::node(2, Tree::leaf(4), Tree::leaf(5)),
        Tree::leaf(3),
    );
    
    tree.print(0);
}
```

---

## 5. æ³›å‹æ–¹æ³•å®ç°

### 5.1 ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•

```rust
struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { items: Vec::new() }
    }
    
    fn push(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }
    
    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
}

fn main() {
    let mut stack = Stack::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);
    
    while let Some(item) = stack.pop() {
        println!("{}", item); // 3, 2, 1
    }
}
```

### 5.2 æ–¹æ³•ä¸­çš„æ³›å‹å‚æ•°

```rust
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }
    
    // æ–¹æ³•æœ‰è‡ªå·±çš„æ³›å‹å‚æ•° U
    fn map<U, F>(self, f: F) -> Container<U>
    where
        F: FnOnce(T) -> U,
    {
        Container {
            value: f(self.value),
        }
    }
}

fn main() {
    let c1 = Container::new(42);
    let c2 = c1.map(|x| x.to_string());
    let c3 = c2.map(|s| s.len());
    
    println!("{}", c3.value); // 2
}
```

### 5.3 ä¸ºå…·ä½“ç±»å‹å®ç°æ–¹æ³•

```rust
struct Point<T> {
    x: T,
    y: T,
}

// ä¸ºæ‰€æœ‰ç±»å‹å®ç°
impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
}

// åªä¸º f64 å®ç°
impl Point<f64> {
    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// åªä¸º i32 å®ç°
impl Point<i32> {
    fn manhattan_distance(&self) -> i32 {
        self.x.abs() + self.y.abs()
    }
}

fn main() {
    let pf = Point::new(3.0, 4.0);
    println!("æ¬§å‡ é‡Œå¾—è·ç¦»: {}", pf.distance_from_origin());
    
    let pi = Point::new(3, 4);
    println!("æ›¼å“ˆé¡¿è·ç¦»: {}", pi.manhattan_distance());
}
```

---

## 6. Const æ³›å‹

### 6.1 åŸºç¡€è¯­æ³•

Const æ³›å‹å…è®¸åœ¨ç±»å‹å‚æ•°ä¸­ä½¿ç”¨å¸¸é‡å€¼ã€‚

```rust
struct Array<T, const N: usize> {
    data: [T; N],
}

impl<T: Default + Copy, const N: usize> Array<T, N> {
    fn new() -> Self {
        Array {
            data: [T::default(); N],
        }
    }
}

fn main() {
    let arr1: Array<i32, 5> = Array::new();
    let arr2: Array<f64, 10> = Array::new();
    
    println!("arr1 size: {}", arr1.data.len());
    println!("arr2 size: {}", arr2.data.len());
}
```

### 6.2 å®æˆ˜æ¡ˆä¾‹ï¼šå›ºå®šå¤§å°æ•°ç»„

```rust
#[derive(Debug)]
struct FixedVec<T, const CAP: usize> {
    data: Vec<T>,
}

impl<T, const CAP: usize> FixedVec<T, CAP> {
    fn new() -> Self {
        FixedVec {
            data: Vec::with_capacity(CAP),
        }
    }
    
    fn push(&mut self, item: T) -> Result<(), &'static str> {
        if self.data.len() < CAP {
            self.data.push(item);
            Ok(())
        } else {
            Err("å®¹é‡å·²æ»¡")
        }
    }
    
    fn len(&self) -> usize {
        self.data.len()
    }
    
    fn capacity(&self) -> usize {
        CAP
    }
}

fn main() {
    let mut vec: FixedVec<i32, 3> = FixedVec::new();
    
    vec.push(1).unwrap();
    vec.push(2).unwrap();
    vec.push(3).unwrap();
    
    match vec.push(4) {
        Ok(_) => println!("æ·»åŠ æˆåŠŸ"),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
    
    println!("é•¿åº¦: {}/{}", vec.len(), vec.capacity());
}
```

---

## 7. é»˜è®¤ç±»å‹å‚æ•°

### 7.1 åŸºç¡€è¯­æ³•

```rust
struct Container<T = i32> {
    value: T,
}

fn main() {
    let c1 = Container { value: 42 };     // T = i32 (é»˜è®¤)
    let c2: Container<String> = Container {
        value: String::from("hello"),
    };
    
    println!("{}, {}", c1.value, c2.value);
}
```

### 7.2 å®æˆ˜æ¡ˆä¾‹ï¼šå¯é…ç½®çš„å®¹å™¨

```rust
use std::collections::HashMap;
use std::hash::Hash;

struct Cache<K, V, S = std::collections::hash_map::RandomState>
where
    K: Eq + Hash,
{
    map: HashMap<K, V, S>,
}

impl<K, V> Cache<K, V>
where
    K: Eq + Hash,
{
    fn new() -> Self {
        Cache {
            map: HashMap::new(),
        }
    }
    
    fn insert(&mut self, key: K, value: V) {
        self.map.insert(key, value);
    }
    
    fn get(&self, key: &K) -> Option<&V> {
        self.map.get(key)
    }
}

fn main() {
    let mut cache = Cache::new();
    cache.insert("key1", 100);
    cache.insert("key2", 200);
    
    println!("{:?}", cache.get(&"key1")); // Some(100)
}
```

---

## 8. æ³›å‹çº¦æŸåŸºç¡€

### 8.1 å•ä¸ªçº¦æŸ

```rust
use std::fmt::Display;

fn print_value<T: Display>(value: T) {
    println!("å€¼: {}", value);
}

fn main() {
    print_value(42);
    print_value("hello");
    print_value(3.14);
}
```

### 8.2 å¤šä¸ªçº¦æŸ

```rust
use std::fmt::{Display, Debug};

fn print_debug_and_display<T: Display + Debug>(value: T) {
    println!("Display: {}", value);
    println!("Debug: {:?}", value);
}

fn main() {
    print_debug_and_display(42);
    print_debug_and_display("hello");
}
```

### 8.3 where å­å¥

```rust
use std::fmt::Display;

// ä½¿ç”¨ where å­å¥æé«˜å¯è¯»æ€§
fn compare_and_print<T, U>(a: T, b: U)
where
    T: Display + PartialOrd,
    U: Display + PartialOrd,
{
    println!("a = {}, b = {}", a, b);
}

fn main() {
    compare_and_print(42, 3.14);
    compare_and_print("hello", "world");
}
```

---

## 9. å®æˆ˜ç»¼åˆæ¡ˆä¾‹

### 9.1 æ¡ˆä¾‹ 1ï¼šé€šç”¨ç¼“å­˜ç³»ç»Ÿ

```rust
use std::collections::HashMap;
use std::hash::Hash;

struct Cache<K, V>
where
    K: Eq + Hash + Clone,
    V: Clone,
{
    store: HashMap<K, V>,
    max_size: usize,
}

impl<K, V> Cache<K, V>
where
    K: Eq + Hash + Clone,
    V: Clone,
{
    fn new(max_size: usize) -> Self {
        Cache {
            store: HashMap::new(),
            max_size,
        }
    }
    
    fn get(&self, key: &K) -> Option<V> {
        self.store.get(key).cloned()
    }
    
    fn set(&mut self, key: K, value: V) {
        if self.store.len() >= self.max_size && !self.store.contains_key(&key) {
            // ç®€å•çš„ç­–ç•¥ï¼šæ‹’ç»æ–°æ¡ç›®
            return;
        }
        self.store.insert(key, value);
    }
    
    fn len(&self) -> usize {
        self.store.len()
    }
}

fn main() {
    let mut cache: Cache<String, i32> = Cache::new(3);
    
    cache.set(String::from("a"), 1);
    cache.set(String::from("b"), 2);
    cache.set(String::from("c"), 3);
    cache.set(String::from("d"), 4); // è¢«æ‹’ç»
    
    println!("ç¼“å­˜å¤§å°: {}", cache.len()); // 3
    println!("a = {:?}", cache.get(&String::from("a"))); // Some(1)
    println!("d = {:?}", cache.get(&String::from("d"))); // None
}
```

### 9.2 æ¡ˆä¾‹ 2ï¼šæ•°æ®è½¬æ¢ç®¡é“

```rust
struct Pipeline<T> {
    data: T,
}

impl<T> Pipeline<T> {
    fn new(data: T) -> Self {
        Pipeline { data }
    }
    
    fn map<U, F>(self, f: F) -> Pipeline<U>
    where
        F: FnOnce(T) -> U,
    {
        Pipeline {
            data: f(self.data),
        }
    }
    
    fn get(self) -> T {
        self.data
    }
}

fn main() {
    let result = Pipeline::new(5)
        .map(|x| x * 2)        // 10
        .map(|x| x + 3)        // 13
        .map(|x| x.to_string()) // "13"
        .map(|s| format!("Result: {}", s))
        .get();
    
    println!("{}", result); // "Result: 13"
}
```

---

## 10. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 10.1 å¸¸è§é”™è¯¯

**é”™è¯¯ 1: å¿˜è®°çº¦æŸ**:

```rust
// âŒ é”™è¯¯ï¼šT æ²¡æœ‰å®ç° PartialOrd
fn max<T>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// âœ… æ­£ç¡®
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}
```

**é”™è¯¯ 2: ç±»å‹å‚æ•°ä¸ä¸€è‡´**:

```rust
// âŒ é”™è¯¯ï¼šx å’Œ y çš„ç±»å‹ä¸åŒ
let p = Point { x: 5, y: 4.0 };

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ä¸¤ä¸ªç±»å‹å‚æ•°
struct Point<T, U> {
    x: T,
    y: U,
}
```

**é”™è¯¯ 3: æ‰€æœ‰æƒé—®é¢˜**:

```rust
// âŒ é”™è¯¯ï¼šå€¼è¢«ç§»èµ°
fn first<T>(a: T, b: T) -> T {
    a
}
let x = String::from("hello");
let y = String::from("world");
let z = first(x, y);
// println!("{}", x); // é”™è¯¯ï¼šx å·²è¢«ç§»èµ°

// âœ… æ­£ç¡®ï¼šä½¿ç”¨å¼•ç”¨
fn first<T>(a: &T, b: &T) -> &T {
    a
}
```

### 10.2 æœ€ä½³å®è·µ

**1. ä¼˜å…ˆä½¿ç”¨æ³›å‹è€Œä¸æ˜¯ä»£ç å¤åˆ¶**:

```rust
// âŒ ä¸æ¨è
fn print_i32(v: i32) { println!("{}", v); }
fn print_f64(v: f64) { println!("{}", v); }

// âœ… æ¨è
fn print<T: std::fmt::Display>(v: T) {
    println!("{}", v);
}
```

**2. ä¸ºç±»å‹å‚æ•°é€‰æ‹©æ¸…æ™°çš„åç§°**:

```rust
// âŒ ä¸æ¸…æ™°
fn convert<T, U, V>(a: T, b: U) -> V { ... }

// âœ… æ¸…æ™°
fn convert<Input, Output, Error>(
    input: Input,
    converter: Output,
) -> Result<Output, Error> { ... }
```

**3. ä½¿ç”¨ where å­å¥æé«˜å¯è¯»æ€§**:

```rust
// âŒ éš¾è¯»
fn func<T: Clone + Debug + Display + PartialOrd>(value: T) { ... }

// âœ… æ˜“è¯»
fn func<T>(value: T)
where
    T: Clone + Debug + Display + PartialOrd,
{ ... }
```

**4. åˆç†ä½¿ç”¨é»˜è®¤ç±»å‹å‚æ•°**:

```rust
// ä¸ºå¸¸è§æƒ…å†µæä¾›é»˜è®¤å€¼
struct Container<T, S = Vec<T>> {
    storage: S,
    _marker: std::marker::PhantomData<T>,
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [02_Traitç³»ç»ŸæŒ‡å—.md](./02_Traitç³»ç»ŸæŒ‡å—.md) - æ·±å…¥å­¦ä¹  trait ç³»ç»Ÿ
- [03_å…³è”ç±»å‹æŒ‡å—.md](./03_å…³è”ç±»å‹æŒ‡å—.md) - å­¦ä¹ å…³è”ç±»å‹å’Œ GAT
- [04_ç±»å‹æ¨æ–­æŒ‡å—.md](./04_ç±»å‹æ¨æ–­æŒ‡å—.md) - ç†è§£ç±»å‹æ¨æ–­æœºåˆ¶
- [../tier_03_references/01_æ³›å‹è¯­æ³•å‚è€ƒ.md](../tier_03_references/01_æ³›å‹è¯­æ³•å‚è€ƒ.md) - å®Œæ•´è¯­æ³•å‚è€ƒ
- [../tier_01_foundations/03_æœ¯è¯­è¡¨.md](../tier_01_foundations/03_æœ¯è¯­è¡¨.md) - æœ¯è¯­å®šä¹‰

---

## ğŸ¯ ç»ƒä¹ é¢˜

**ç»ƒä¹  1: æ³›å‹ swap å‡½æ•°**:

ç¼–å†™ä¸€ä¸ªæ³›å‹å‡½æ•°ï¼Œäº¤æ¢ä¸¤ä¸ªå€¼ã€‚

```rust
fn swap<T>(a: &mut T, b: &mut T) {
    // ä½ çš„ä»£ç 
}

fn main() {
    let mut x = 5;
    let mut y = 10;
    swap(&mut x, &mut y);
    assert_eq!(x, 10);
    assert_eq!(y, 5);
}
```

å‚è€ƒç­”æ¡ˆ

```rust
fn swap<T>(a: &mut T, b: &mut T) {
    std::mem::swap(a, b);
}
```

**ç»ƒä¹  2: æ³›å‹é˜Ÿåˆ—**:

å®ç°ä¸€ä¸ªç®€å•çš„æ³›å‹é˜Ÿåˆ—ã€‚

```rust
struct Queue<T> {
    // ä½ çš„å­—æ®µ
}

impl<T> Queue<T> {
    fn new() -> Self { todo!() }
    fn enqueue(&mut self, item: T) { todo!() }
    fn dequeue(&mut self) -> Option<T> { todo!() }
}
```

å‚è€ƒç­”æ¡ˆ

```rust
struct Queue<T> {
    items: Vec<T>,
}

impl<T> Queue<T> {
    fn new() -> Self {
        Queue { items: Vec::new() }
    }
    
    fn enqueue(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn dequeue(&mut self) -> Option<T> {
        if self.items.is_empty() {
            None
        } else {
            Some(self.items.remove(0))
        }
    }
}
```

**ç»ƒä¹  3: æ³›å‹äºŒå‰æœç´¢æ ‘**:

å®ç°ä¸€ä¸ªç®€å•çš„æ³›å‹äºŒå‰æœç´¢æ ‘çš„æ’å…¥åŠŸèƒ½ã€‚

---

## ğŸ“ å°ç»“

åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ï¼š

- âœ… **æ³›å‹çš„æ¦‚å¿µå’Œä»·å€¼**: ä»£ç å¤ç”¨ã€ç±»å‹å®‰å…¨ã€é›¶æˆæœ¬æŠ½è±¡
- âœ… **æ³›å‹å‡½æ•°**: åŸºç¡€è¯­æ³•ã€å¤šç±»å‹å‚æ•°ã€çº¦æŸ
- âœ… **æ³›å‹ç»“æ„ä½“**: å®šä¹‰ã€å®ç°æ–¹æ³•ã€å…·ä½“ç±»å‹ç‰¹åŒ–
- âœ… **æ³›å‹æšä¸¾**: Optionã€Resultã€è‡ªå®šä¹‰æšä¸¾
- âœ… **Const æ³›å‹**: ç¼–è¯‘æ—¶å¸¸é‡å‚æ•°
- âœ… **é»˜è®¤ç±»å‹å‚æ•°**: ç®€åŒ–å¸¸è§ç”¨æ³•
- âœ… **æ³›å‹çº¦æŸåŸºç¡€**: trait boundsã€where å­å¥

**ä¸‹ä¸€æ­¥å­¦ä¹ **:

1. [02_Traitç³»ç»ŸæŒ‡å—.md](./02_Traitç³»ç»ŸæŒ‡å—.md) - æ·±å…¥å­¦ä¹  trait ç³»ç»Ÿ
2. [03_å…³è”ç±»å‹æŒ‡å—.md](./03_å…³è”ç±»å‹æŒ‡å—.md) - å­¦ä¹ å…³è”ç±»å‹å’Œ GAT
3. [05_å®æˆ˜æ¨¡å¼æŒ‡å—.md](./05_å®æˆ˜æ¨¡å¼æŒ‡å—.md) - å­¦ä¹ æ³›å‹è®¾è®¡æ¨¡å¼

---

**æ–‡æ¡£å…ƒä¿¡æ¯**:

- åˆ›å»ºæ—¥æœŸ: 2025-10-22
- ä½œè€…: Rust-Lang Project
- è®¸å¯: MIT OR Apache-2.0
