# C04 泛型编程 - 实战模式指南

**文档类型**: Tier 2 实践指南  
**难度级别**: ⭐⭐⭐⭐ 高级  
**预计学习时间**: 5-6 小时  
**最后更新**: 2025-10-22

---

## 📋 本文档目录

- [C04 泛型编程 - 实战模式指南](#c04-泛型编程---实战模式指南)
  - [� 本文档目录](#-本文档目录)
  - [🎯 学习目标](#-学习目标)
  - [📚 前置知识](#-前置知识)
  - [1. 类型状态模式 (Type State Pattern)](#1-类型状态模式-type-state-pattern)
    - [1.1 什么是类型状态模式？](#11-什么是类型状态模式)
    - [1.2 基础实现](#12-基础实现)
    - [1.3 实战案例：HTTP 客户端](#13-实战案例http-客户端)
  - [2. 构建器模式 (Builder Pattern)](#2-构建器模式-builder-pattern)
    - [2.1 传统构建器](#21-传统构建器)
    - [2.2 类型安全构建器](#22-类型安全构建器)
    - [2.3 实战案例：配置构建器](#23-实战案例配置构建器)
  - [3. 新类型模式 (Newtype Pattern)](#3-新类型模式-newtype-pattern)
    - [3.1 基础用法](#31-基础用法)
    - [3.2 类型安全保证](#32-类型安全保证)
    - [3.3 实战案例：单位系统](#33-实战案例单位系统)
  - [4. PhantomData 模式](#4-phantomdata-模式)
    - [4.1 什么是 PhantomData？](#41-什么是-phantomdata)
    - [4.2 用途场景](#42-用途场景)
    - [4.3 实战案例：生命周期标记](#43-实战案例生命周期标记)
  - [5. 策略模式 (Strategy Pattern)](#5-策略模式-strategy-pattern)
    - [5.1 使用 Trait 实现](#51-使用-trait-实现)
    - [5.2 实战案例：排序策略](#52-实战案例排序策略)
  - [6. 访问者模式 (Visitor Pattern)](#6-访问者模式-visitor-pattern)
    - [6.1 基础实现](#61-基础实现)
    - [6.2 实战案例：AST 遍历](#62-实战案例ast-遍历)
  - [7. 适配器模式 (Adapter Pattern)](#7-适配器模式-adapter-pattern)
    - [7.1 使用 Trait 适配](#71-使用-trait-适配)
    - [7.2 实战案例：IO 适配器](#72-实战案例io-适配器)
  - [8. 类型级编程模式](#8-类型级编程模式)
    - [8.1 编译时计算](#81-编译时计算)
    - [8.2 类型级列表](#82-类型级列表)
    - [8.3 实战案例：类型安全的 SQL 查询](#83-实战案例类型安全的-sql-查询)
  - [9. 扩展 Trait 模式](#9-扩展-trait-模式)
    - [9.1 为外部类型添加功能](#91-为外部类型添加功能)
    - [9.2 实战案例：字符串扩展](#92-实战案例字符串扩展)
  - [10. 综合实战案例](#10-综合实战案例)
    - [10.1 案例 1：类型安全的 API 客户端](#101-案例-1类型安全的-api-客户端)
    - [10.2 案例 2：插件系统](#102-案例-2插件系统)
  - [11. 最佳实践](#11-最佳实践)
    - [11.1 选择合适的模式](#111-选择合适的模式)
    - [11.2 平衡类型安全与复杂度](#112-平衡类型安全与复杂度)
    - [11.3 性能考虑](#113-性能考虑)
  - [📚 延伸阅读](#-延伸阅读)
  - [🎯 练习题](#-练习题)
  - [📝 小结](#-小结)

---

## 🎯 学习目标

通过本指南的学习，你将能够：

- ✅ 掌握常见的 Rust 泛型设计模式
- ✅ 实现类型状态模式和构建器模式
- ✅ 使用 PhantomData 进行类型标记
- ✅ 应用策略模式和访问者模式
- ✅ 实现类型级编程技巧
- ✅ 设计类型安全的 API

---

## 📚 前置知识

在学习本指南之前，你应该掌握：

- ✅ [01_泛型基础指南.md](./01_泛型基础指南.md) - 泛型基础
- ✅ [02_Trait系统指南.md](./02_Trait系统指南.md) - Trait 系统
- ✅ [03_关联类型指南.md](./03_关联类型指南.md) - 关联类型
- ✅ 生命周期的基本概念

---

## 1. 类型状态模式 (Type State Pattern)

### 1.1 什么是类型状态模式？

**类型状态模式**使用类型系统在编译时强制执行状态机的正确转换。

**优势**:

- ✅ 编译时状态验证
- ✅ 防止非法状态转换
- ✅ 零运行时开销

### 1.2 基础实现

```rust
// 状态标记
struct Locked;
struct Unlocked;

// 带状态的类型
struct Door<State> {
    _state: std::marker::PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door created (locked)");
        Door {
            _state: std::marker::PhantomData,
        }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Door unlocked");
        Door {
            _state: std::marker::PhantomData,
        }
    }
}

impl Door<Unlocked> {
    fn lock(self) -> Door<Locked> {
        println!("Door locked");
        Door {
            _state: std::marker::PhantomData,
        }
    }
    
    fn open(&self) {
        println!("Door opened");
    }
}

fn main() {
    let door = Door::<Locked>::new();
    // door.open(); // ❌ 编译错误：locked 状态不能 open
    
    let door = door.unlock();
    door.open(); // ✅ 正确
    
    let door = door.lock();
    // door.open(); // ❌ 编译错误
}
```

### 1.3 实战案例：HTTP 客户端

```rust
use std::marker::PhantomData;

// 状态标记
struct NoMethod;
struct WithMethod;
struct NoUrl;
struct WithUrl;

// HTTP 请求构建器
struct HttpRequest<M, U> {
    method: Option<String>,
    url: Option<String>,
    headers: Vec<(String, String)>,
    _method_state: PhantomData<M>,
    _url_state: PhantomData<U>,
}

impl HttpRequest<NoMethod, NoUrl> {
    fn new() -> Self {
        HttpRequest {
            method: None,
            url: None,
            headers: Vec::new(),
            _method_state: PhantomData,
            _url_state: PhantomData,
        }
    }
}

impl<U> HttpRequest<NoMethod, U> {
    fn method(self, method: String) -> HttpRequest<WithMethod, U> {
        HttpRequest {
            method: Some(method),
            url: self.url,
            headers: self.headers,
            _method_state: PhantomData,
            _url_state: PhantomData,
        }
    }
}

impl<M> HttpRequest<M, NoUrl> {
    fn url(self, url: String) -> HttpRequest<M, WithUrl> {
        HttpRequest {
            method: self.method,
            url: Some(url),
            headers: self.headers,
            _method_state: PhantomData,
            _url_state: PhantomData,
        }
    }
}

impl<M, U> HttpRequest<M, U> {
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
}

impl HttpRequest<WithMethod, WithUrl> {
    fn send(&self) -> Result<String, String> {
        println!(
            "Sending {} request to {}",
            self.method.as_ref().unwrap(),
            self.url.as_ref().unwrap()
        );
        Ok(String::from("Response"))
    }
}

fn main() {
    let request = HttpRequest::new()
        .method(String::from("GET"))
        .url(String::from("https://example.com"))
        .header(String::from("Authorization"), String::from("Bearer token"))
        .send();
    
    println!("{:?}", request);
    
    // ❌ 以下代码会在编译时报错
    // let invalid = HttpRequest::new().send(); // 缺少 method 和 url
}
```

---

## 2. 构建器模式 (Builder Pattern)

### 2.1 传统构建器

```rust
#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
    timeout: u64,
    retries: u32,
}

struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    retries: Option<u32>,
}

impl ConfigBuilder {
    fn new() -> Self {
        ConfigBuilder {
            host: None,
            port: None,
            timeout: None,
            retries: None,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn retries(mut self, retries: u32) -> Self {
        self.retries = Some(retries);
        self
    }
    
    fn build(self) -> Result<Config, String> {
        Ok(Config {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(80),
            timeout: self.timeout.unwrap_or(30),
            retries: self.retries.unwrap_or(3),
        })
    }
}

fn main() {
    let config = ConfigBuilder::new()
        .host(String::from("localhost"))
        .port(8080)
        .timeout(60)
        .build()
        .unwrap();
    
    println!("{:?}", config);
}
```

### 2.2 类型安全构建器

```rust
use std::marker::PhantomData;

// 状态标记
struct NoHost;
struct WithHost;

#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
    timeout: u64,
}

struct ConfigBuilder<H> {
    host: Option<String>,
    port: u16,
    timeout: u64,
    _host_state: PhantomData<H>,
}

impl ConfigBuilder<NoHost> {
    fn new() -> Self {
        ConfigBuilder {
            host: None,
            port: 80,
            timeout: 30,
            _host_state: PhantomData,
        }
    }
}

impl<H> ConfigBuilder<H> {
    fn port(mut self, port: u16) -> Self {
        self.port = port;
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
}

impl ConfigBuilder<NoHost> {
    fn host(self, host: String) -> ConfigBuilder<WithHost> {
        ConfigBuilder {
            host: Some(host),
            port: self.port,
            timeout: self.timeout,
            _host_state: PhantomData,
        }
    }
}

impl ConfigBuilder<WithHost> {
    fn build(self) -> Config {
        Config {
            host: self.host.unwrap(),
            port: self.port,
            timeout: self.timeout,
        }
    }
}

fn main() {
    let config = ConfigBuilder::new()
        .host(String::from("localhost"))
        .port(8080)
        .build();
    
    println!("{:?}", config);
    
    // ❌ 编译错误：缺少必需的 host
    // let invalid = ConfigBuilder::new().build();
}
```

### 2.3 实战案例：配置构建器

```rust
#[derive(Debug)]
struct DatabaseConfig {
    host: String,
    port: u16,
    username: String,
    password: String,
    database: String,
    pool_size: usize,
    timeout: u64,
}

struct DatabaseConfigBuilder {
    host: String,
    port: u16,
    username: String,
    password: String,
    database: String,
    pool_size: usize,
    timeout: u64,
}

impl DatabaseConfigBuilder {
    fn new(username: String, password: String, database: String) -> Self {
        DatabaseConfigBuilder {
            host: String::from("localhost"),
            port: 5432,
            username,
            password,
            database,
            pool_size: 10,
            timeout: 30,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = host;
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = port;
        self
    }
    
    fn pool_size(mut self, size: usize) -> Self {
        self.pool_size = size;
        self
    }
    
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
    
    fn build(self) -> DatabaseConfig {
        DatabaseConfig {
            host: self.host,
            port: self.port,
            username: self.username,
            password: self.password,
            database: self.database,
            pool_size: self.pool_size,
            timeout: self.timeout,
        }
    }
}

fn main() {
    let config = DatabaseConfigBuilder::new(
        String::from("admin"),
        String::from("secret"),
        String::from("mydb"),
    )
    .host(String::from("db.example.com"))
    .port(3306)
    .pool_size(20)
    .build();
    
    println!("{:?}", config);
}
```

---

## 3. 新类型模式 (Newtype Pattern)

### 3.1 基础用法

```rust
// 为基本类型创建新类型
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) {
    println!("Getting user {}", id.0);
}

fn get_product(id: ProductId) {
    println!("Getting product {}", id.0);
}

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);
    
    get_user(user_id);
    get_product(product_id);
    
    // ❌ 类型不匹配，编译错误
    // get_user(product_id);
}
```

### 3.2 类型安全保证

```rust
use std::ops::Add;

struct Meters(f64);
struct Kilometers(f64);

impl Meters {
    fn to_kilometers(&self) -> Kilometers {
        Kilometers(self.0 / 1000.0)
    }
}

impl Kilometers {
    fn to_meters(&self) -> Meters {
        Meters(self.0 * 1000.0)
    }
}

impl Add for Meters {
    type Output = Meters;
    
    fn add(self, other: Meters) -> Meters {
        Meters(self.0 + other.0)
    }
}

fn main() {
    let d1 = Meters(1500.0);
    let d2 = Meters(500.0);
    let total = d1 + d2;
    
    println!("Total: {} meters", total.0);
    
    let km = total.to_kilometers();
    println!("Total: {} km", km.0);
}
```

### 3.3 实战案例：单位系统

```rust
use std::ops::{Add, Sub, Mul, Div};

#[derive(Debug, Clone, Copy)]
struct Celsius(f64);

#[derive(Debug, Clone, Copy)]
struct Fahrenheit(f64);

#[derive(Debug, Clone, Copy)]
struct Kelvin(f64);

impl Celsius {
    fn to_fahrenheit(&self) -> Fahrenheit {
        Fahrenheit(self.0 * 9.0 / 5.0 + 32.0)
    }
    
    fn to_kelvin(&self) -> Kelvin {
        Kelvin(self.0 + 273.15)
    }
}

impl Fahrenheit {
    fn to_celsius(&self) -> Celsius {
        Celsius((self.0 - 32.0) * 5.0 / 9.0)
    }
    
    fn to_kelvin(&self) -> Kelvin {
        self.to_celsius().to_kelvin()
    }
}

impl Kelvin {
    fn to_celsius(&self) -> Celsius {
        Celsius(self.0 - 273.15)
    }
    
    fn to_fahrenheit(&self) -> Fahrenheit {
        self.to_celsius().to_fahrenheit()
    }
}

impl Add for Celsius {
    type Output = Celsius;
    fn add(self, other: Celsius) -> Celsius {
        Celsius(self.0 + other.0)
    }
}

impl Sub for Celsius {
    type Output = Celsius;
    fn sub(self, other: Celsius) -> Celsius {
        Celsius(self.0 - other.0)
    }
}

fn main() {
    let temp_c = Celsius(25.0);
    let temp_f = temp_c.to_fahrenheit();
    let temp_k = temp_c.to_kelvin();
    
    println!("{:?} = {:?} = {:?}", temp_c, temp_f, temp_k);
    
    let sum = Celsius(20.0) + Celsius(5.0);
    println!("Sum: {:?}", sum);
}
```

---

## 4. PhantomData 模式

### 4.1 什么是 PhantomData？

`PhantomData<T>` 是一个零大小类型，用于标记类型参数的使用，但不实际存储该类型的值。

```rust
use std::marker::PhantomData;

struct Container<T> {
    _marker: PhantomData<T>,
}

impl<T> Container<T> {
    fn new() -> Self {
        Container {
            _marker: PhantomData,
        }
    }
}

fn main() {
    let c1: Container<i32> = Container::new();
    let c2: Container<String> = Container::new();
    
    // c1 和 c2 是不同的类型，但大小都为 0
    println!("Size of Container<i32>: {}", std::mem::size_of::<Container<i32>>());
    println!("Size of Container<String>: {}", std::mem::size_of::<Container<String>>());
}
```

### 4.2 用途场景

**场景 1: 类型状态模式**:

```rust
struct Locked;
struct Unlocked;

struct Door<State> {
    _state: PhantomData<State>,
}
```

**场景 2: 生命周期标记**:

```rust
struct Ref<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a T>,
}
```

**场景 3: 类型级标记**:

```rust
struct Validated;
struct Unvalidated;

struct Data<State> {
    content: String,
    _state: PhantomData<State>,
}
```

### 4.3 实战案例：生命周期标记

```rust
use std::marker::PhantomData;

struct Ref<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a T>,
}

impl<'a, T> Ref<'a, T> {
    fn new(reference: &'a T) -> Self {
        Ref {
            ptr: reference as *const T,
            _marker: PhantomData,
        }
    }
    
    fn get(&self) -> &'a T {
        unsafe { &*self.ptr }
    }
}

fn main() {
    let value = 42;
    let ref_val = Ref::new(&value);
    println!("Value: {}", ref_val.get());
}
```

---

## 5. 策略模式 (Strategy Pattern)

### 5.1 使用 Trait 实现

```rust
trait CompressionStrategy {
    fn compress(&self, data: &[u8]) -> Vec<u8>;
    fn decompress(&self, data: &[u8]) -> Vec<u8>;
}

struct GzipCompression;
struct ZlibCompression;

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        println!("Compressing with Gzip");
        data.to_vec() // 简化实现
    }
    
    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        println!("Decompressing with Gzip");
        data.to_vec()
    }
}

impl CompressionStrategy for ZlibCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        println!("Compressing with Zlib");
        data.to_vec()
    }
    
    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        println!("Decompressing with Zlib");
        data.to_vec()
    }
}

struct Compressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> Compressor<S> {
    fn new(strategy: S) -> Self {
        Compressor { strategy }
    }
    
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.compress(data)
    }
    
    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.decompress(data)
    }
}

fn main() {
    let data = b"Hello, World!";
    
    let gzip_compressor = Compressor::new(GzipCompression);
    let compressed = gzip_compressor.compress(data);
    let decompressed = gzip_compressor.decompress(&compressed);
    
    println!("{:?}", std::str::from_utf8(&decompressed).unwrap());
}
```

### 5.2 实战案例：排序策略

```rust
trait SortStrategy<T> {
    fn sort(&self, data: &mut [T]);
}

struct QuickSort;
struct MergeSort;
struct BubbleSort;

impl<T: Ord> SortStrategy<T> for QuickSort {
    fn sort(&self, data: &mut [T]) {
        println!("Sorting with QuickSort");
        data.sort(); // 使用标准库实现
    }
}

impl<T: Ord + Clone> SortStrategy<T> for MergeSort {
    fn sort(&self, data: &mut [T]) {
        println!("Sorting with MergeSort");
        data.sort(); // 简化实现
    }
}

impl<T: Ord> SortStrategy<T> for BubbleSort {
    fn sort(&self, data: &mut [T]) {
        println!("Sorting with BubbleSort");
        let len = data.len();
        for i in 0..len {
            for j in 0..len - i - 1 {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
}

struct Sorter<S, T> {
    strategy: S,
    _marker: PhantomData<T>,
}

impl<S, T> Sorter<S, T>
where
    S: SortStrategy<T>,
{
    fn new(strategy: S) -> Self {
        Sorter {
            strategy,
            _marker: PhantomData,
        }
    }
    
    fn sort(&self, data: &mut [T]) {
        self.strategy.sort(data);
    }
}

fn main() {
    let mut numbers = vec![5, 2, 8, 1, 9];
    
    let sorter = Sorter::new(BubbleSort);
    sorter.sort(&mut numbers);
    
    println!("{:?}", numbers);
}
```

---

## 6. 访问者模式 (Visitor Pattern)

### 6.1 基础实现

```rust
trait Visitor {
    fn visit_number(&mut self, value: i32);
    fn visit_string(&mut self, value: &str);
}

enum Element {
    Number(i32),
    Text(String),
}

impl Element {
    fn accept<V: Visitor>(&self, visitor: &mut V) {
        match self {
            Element::Number(n) => visitor.visit_number(*n),
            Element::Text(s) => visitor.visit_string(s),
        }
    }
}

struct PrintVisitor;

impl Visitor for PrintVisitor {
    fn visit_number(&mut self, value: i32) {
        println!("Number: {}", value);
    }
    
    fn visit_string(&mut self, value: &str) {
        println!("String: {}", value);
    }
}

struct SumVisitor {
    total: i32,
}

impl Visitor for SumVisitor {
    fn visit_number(&mut self, value: i32) {
        self.total += value;
    }
    
    fn visit_string(&mut self, _value: &str) {
        // Ignore strings
    }
}

fn main() {
    let elements = vec![
        Element::Number(10),
        Element::Text(String::from("hello")),
        Element::Number(20),
    ];
    
    let mut print_visitor = PrintVisitor;
    for elem in &elements {
        elem.accept(&mut print_visitor);
    }
    
    let mut sum_visitor = SumVisitor { total: 0 };
    for elem in &elements {
        elem.accept(&mut sum_visitor);
    }
    println!("Sum: {}", sum_visitor.total);
}
```

### 6.2 实战案例：AST 遍历

```rust
trait AstVisitor {
    fn visit_literal(&mut self, value: i32);
    fn visit_binary_op(&mut self, op: &str, left: &Expr, right: &Expr);
}

enum Expr {
    Literal(i32),
    BinaryOp {
        op: String,
        left: Box<Expr>,
        right: Box<Expr>,
    },
}

impl Expr {
    fn accept<V: AstVisitor>(&self, visitor: &mut V) {
        match self {
            Expr::Literal(value) => visitor.visit_literal(*value),
            Expr::BinaryOp { op, left, right } => {
                left.accept(visitor);
                right.accept(visitor);
                visitor.visit_binary_op(op, left, right);
            }
        }
    }
}

struct EvalVisitor {
    stack: Vec<i32>,
}

impl AstVisitor for EvalVisitor {
    fn visit_literal(&mut self, value: i32) {
        self.stack.push(value);
    }
    
    fn visit_binary_op(&mut self, op: &str, _left: &Expr, _right: &Expr) {
        let right = self.stack.pop().unwrap();
        let left = self.stack.pop().unwrap();
        
        let result = match op.as_str() {
            "+" => left + right,
            "-" => left - right,
            "*" => left * right,
            "/" => left / right,
            _ => 0,
        };
        
        self.stack.push(result);
    }
}

fn main() {
    // 表达式: (10 + 20) * 3
    let expr = Expr::BinaryOp {
        op: String::from("*"),
        left: Box::new(Expr::BinaryOp {
            op: String::from("+"),
            left: Box::new(Expr::Literal(10)),
            right: Box::new(Expr::Literal(20)),
        }),
        right: Box::new(Expr::Literal(3)),
    };
    
    let mut eval = EvalVisitor { stack: Vec::new() };
    expr.accept(&mut eval);
    
    println!("Result: {}", eval.stack[0]); // 90
}
```

---

## 7. 适配器模式 (Adapter Pattern)

### 7.1 使用 Trait 适配

```rust
trait Target {
    fn request(&self) -> String;
}

struct Adaptee {
    data: String,
}

impl Adaptee {
    fn specific_request(&self) -> String {
        format!("Adaptee: {}", self.data)
    }
}

struct Adapter {
    adaptee: Adaptee,
}

impl Target for Adapter {
    fn request(&self) -> String {
        self.adaptee.specific_request()
    }
}

fn client_code(target: &impl Target) {
    println!("{}", target.request());
}

fn main() {
    let adaptee = Adaptee {
        data: String::from("special data"),
    };
    let adapter = Adapter { adaptee };
    
    client_code(&adapter);
}
```

### 7.2 实战案例：IO 适配器

```rust
use std::io::{self, Read, Write};

trait DataSource {
    fn read_data(&mut self) -> io::Result<Vec<u8>>;
}

trait DataSink {
    fn write_data(&mut self, data: &[u8]) -> io::Result<()>;
}

struct FileAdapter<R: Read> {
    reader: R,
}

impl<R: Read> DataSource for FileAdapter<R> {
    fn read_data(&mut self) -> io::Result<Vec<u8>> {
        let mut buffer = Vec::new();
        self.reader.read_to_end(&mut buffer)?;
        Ok(buffer)
    }
}

struct WriterAdapter<W: Write> {
    writer: W,
}

impl<W: Write> DataSink for WriterAdapter<W> {
    fn write_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.writer.write_all(data)
    }
}

fn process_data<S: DataSource, D: DataSink>(
    source: &mut S,
    sink: &mut D,
) -> io::Result<()> {
    let data = source.read_data()?;
    sink.write_data(&data)?;
    Ok(())
}
```

---

## 8. 类型级编程模式

### 8.1 编译时计算

```rust
use std::marker::PhantomData;

trait Nat {
    fn to_usize() -> usize;
}

struct Zero;
struct Succ<N: Nat>(PhantomData<N>);

impl Nat for Zero {
    fn to_usize() -> usize {
        0
    }
}

impl<N: Nat> Nat for Succ<N> {
    fn to_usize() -> usize {
        1 + N::to_usize()
    }
}

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

fn main() {
    println!("Three = {}", Three::to_usize()); // 3
}
```

### 8.2 类型级列表

```rust
trait TypeList {
    fn len() -> usize;
}

struct Nil;
struct Cons<Head, Tail: TypeList>(PhantomData<(Head, Tail)>);

impl TypeList for Nil {
    fn len() -> usize {
        0
    }
}

impl<Head, Tail: TypeList> TypeList for Cons<Head, Tail> {
    fn len() -> usize {
        1 + Tail::len()
    }
}

type MyList = Cons<i32, Cons<String, Cons<bool, Nil>>>;

fn main() {
    println!("List length: {}", MyList::len()); // 3
}
```

### 8.3 实战案例：类型安全的 SQL 查询

```rust
use std::marker::PhantomData;

struct Selected;
struct NotSelected;

struct HasWhere;
struct NoWhere;

struct Query<S, W> {
    select: String,
    from: String,
    where_clause: Option<String>,
    _select_state: PhantomData<S>,
    _where_state: PhantomData<W>,
}

impl Query<NotSelected, NoWhere> {
    fn new() -> Self {
        Query {
            select: String::new(),
            from: String::new(),
            where_clause: None,
            _select_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<W> Query<NotSelected, W> {
    fn select(self, fields: &str) -> Query<Selected, W> {
        Query {
            select: fields.to_string(),
            from: self.from,
            where_clause: self.where_clause,
            _select_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<S> Query<S, NoWhere> {
    fn from(mut self, table: &str) -> Self {
        self.from = table.to_string();
        self
    }
    
    fn where_clause(self, condition: &str) -> Query<S, HasWhere> {
        Query {
            select: self.select,
            from: self.from,
            where_clause: Some(condition.to_string()),
            _select_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<W> Query<Selected, W> {
    fn build(&self) -> String {
        let mut sql = format!("SELECT {} FROM {}", self.select, self.from);
        if let Some(ref where_clause) = self.where_clause {
            sql.push_str(&format!(" WHERE {}", where_clause));
        }
        sql
    }
}

fn main() {
    let query = Query::new()
        .select("id, name")
        .from("users")
        .where_clause("age > 18")
        .build();
    
    println!("{}", query);
    // Output: SELECT id, name FROM users WHERE age > 18
    
    // ❌ 编译错误：必须先 select
    // let invalid = Query::new().from("users").build();
}
```

---

## 9. 扩展 Trait 模式

### 9.1 为外部类型添加功能

```rust
trait StringExt {
    fn is_palindrome(&self) -> bool;
    fn word_count(&self) -> usize;
}

impl StringExt for String {
    fn is_palindrome(&self) -> bool {
        let cleaned: String = self.chars()
            .filter(|c| c.is_alphanumeric())
            .map(|c| c.to_lowercase().next().unwrap())
            .collect();
        
        cleaned == cleaned.chars().rev().collect::<String>()
    }
    
    fn word_count(&self) -> usize {
        self.split_whitespace().count()
    }
}

impl StringExt for &str {
    fn is_palindrome(&self) -> bool {
        self.to_string().is_palindrome()
    }
    
    fn word_count(&self) -> usize {
        self.split_whitespace().count()
    }
}

fn main() {
    let s = String::from("A man a plan a canal Panama");
    println!("Is palindrome: {}", s.is_palindrome());
    println!("Word count: {}", s.word_count());
    
    let s2 = "Hello world";
    println!("Word count: {}", s2.word_count());
}
```

### 9.2 实战案例：字符串扩展

```rust
trait StrExt {
    fn truncate(&self, max_len: usize) -> String;
    fn capitalize(&self) -> String;
    fn snake_case(&self) -> String;
}

impl StrExt for str {
    fn truncate(&self, max_len: usize) -> String {
        if self.len() <= max_len {
            self.to_string()
        } else {
            format!("{}...", &self[..max_len])
        }
    }
    
    fn capitalize(&self) -> String {
        let mut chars = self.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => first.to_uppercase().chain(chars).collect(),
        }
    }
    
    fn snake_case(&self) -> String {
        self.chars()
            .flat_map(|c| {
                if c.is_uppercase() {
                    vec!['_', c.to_lowercase().next().unwrap()]
                } else {
                    vec![c]
                }
            })
            .collect::<String>()
            .trim_start_matches('_')
            .to_string()
    }
}

fn main() {
    println!("{}", "Hello, World!".truncate(8)); // "Hello, W..."
    println!("{}", "hello".capitalize());         // "Hello"
    println!("{}", "CamelCaseString".snake_case()); // "camel_case_string"
}
```

---

## 10. 综合实战案例

### 10.1 案例 1：类型安全的 API 客户端

```rust
use std::marker::PhantomData;

struct Unauthenticated;
struct Authenticated;

struct ApiClient<State> {
    base_url: String,
    token: Option<String>,
    _state: PhantomData<State>,
}

impl ApiClient<Unauthenticated> {
    fn new(base_url: String) -> Self {
        ApiClient {
            base_url,
            token: None,
            _state: PhantomData,
        }
    }
    
    fn authenticate(self, token: String) -> ApiClient<Authenticated> {
        ApiClient {
            base_url: self.base_url,
            token: Some(token),
            _state: PhantomData,
        }
    }
}

impl ApiClient<Authenticated> {
    fn get(&self, endpoint: &str) -> Result<String, String> {
        println!(
            "GET {}{} with token {}",
            self.base_url,
            endpoint,
            self.token.as_ref().unwrap()
        );
        Ok(String::from("response"))
    }
    
    fn post(&self, endpoint: &str, data: &str) -> Result<String, String> {
        println!(
            "POST {}{} with data: {}",
            self.base_url,
            endpoint,
            data
        );
        Ok(String::from("response"))
    }
}

fn main() {
    let client = ApiClient::new(String::from("https://api.example.com"));
    
    // ❌ 编译错误：未认证不能调用 get
    // client.get("/users");
    
    let client = client.authenticate(String::from("secret_token"));
    
    // ✅ 认证后可以调用
    let _ = client.get("/users");
    let _ = client.post("/users", r#"{"name": "Alice"}"#);
}
```

### 10.2 案例 2：插件系统

```rust
trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn version(&self) -> &str;
    fn initialize(&mut self) -> Result<(), String>;
    fn execute(&self, input: &str) -> Result<String, String>;
    fn shutdown(&mut self) -> Result<(), String>;
}

struct PluginRegistry {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginRegistry {
    fn new() -> Self {
        PluginRegistry {
            plugins: Vec::new(),
        }
    }
    
    fn register(&mut self, mut plugin: Box<dyn Plugin>) -> Result<(), String> {
        plugin.initialize()?;
        println!("Registered plugin: {} v{}", plugin.name(), plugin.version());
        self.plugins.push(plugin);
        Ok(())
    }
    
    fn execute_all(&self, input: &str) {
        for plugin in &self.plugins {
            match plugin.execute(input) {
                Ok(output) => println!("{}: {}", plugin.name(), output),
                Err(e) => println!("{} error: {}", plugin.name(), e),
            }
        }
    }
    
    fn shutdown(&mut self) {
        for plugin in &mut self.plugins {
            let _ = plugin.shutdown();
        }
    }
}

struct LoggerPlugin;

impl Plugin for LoggerPlugin {
    fn name(&self) -> &str {
        "Logger"
    }
    
    fn version(&self) -> &str {
        "1.0.0"
    }
    
    fn initialize(&mut self) -> Result<(), String> {
        println!("[Logger] Initializing...");
        Ok(())
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        Ok(format!("Logged: {}", input))
    }
    
    fn shutdown(&mut self) -> Result<(), String> {
        println!("[Logger] Shutting down...");
        Ok(())
    }
}

fn main() {
    let mut registry = PluginRegistry::new();
    registry.register(Box::new(LoggerPlugin)).unwrap();
    
    registry.execute_all("test input");
    
    registry.shutdown();
}
```

---

## 11. 最佳实践

### 11.1 选择合适的模式

| 场景 | 推荐模式 |
|------|----------|
| 状态机 | 类型状态模式 |
| 复杂对象构建 | 构建器模式 |
| 类型安全包装 | 新类型模式 |
| 算法切换 | 策略模式 |
| 数据结构遍历 | 访问者模式 |
| 接口适配 | 适配器模式 |
| 编译时计算 | 类型级编程 |

### 11.2 平衡类型安全与复杂度

```rust
// ❌ 过度复杂
struct Config<H, P, T, R> { /* ... */ }

// ✅ 合理使用
struct Config {
    host: String,
    port: u16,
}
```

### 11.3 性能考虑

- ✅ 类型状态模式是零成本抽象
- ✅ PhantomData 不占用空间
- ✅ 静态分发（trait bounds）比动态分发（trait objects）快
- ⚠️ 过多泛型会增加编译时间和二进制大小

---

## 📚 延伸阅读

- [../tier_04_advanced/01_高级类型技巧.md](../tier_04_advanced/01_高级类型技巧.md) - 高级类型技巧
- [../tier_04_advanced/04_类型级编程.md](../tier_04_advanced/04_类型级编程.md) - 类型级编程
- [../tier_04_advanced/05_设计模式进阶.md](../tier_04_advanced/05_设计模式进阶.md) - 设计模式进阶
- [../tier_03_references/01_泛型语法参考.md](../tier_03_references/01_泛型语法参考.md) - 完整语法参考

---

## 🎯 练习题

**练习 1: 实现类型安全的状态机**:

创建一个文件操作的状态机，状态包括：Closed、Open、Reading、Writing。

**练习 2: 实现类型安全的构建器**:

为数据库连接创建一个类型安全的构建器，确保必需字段在编译时验证。

**练习 3: 实现策略模式**:

创建一个支持多种加密算法的系统，使用策略模式。

---

## 📝 小结

在本指南中，我们学习了：

- ✅ **类型状态模式**: 编译时状态验证
- ✅ **构建器模式**: 类型安全的对象构建
- ✅ **新类型模式**: 类型安全包装
- ✅ **PhantomData**: 零大小类型标记
- ✅ **策略模式**: 算法切换
- ✅ **访问者模式**: 数据结构遍历
- ✅ **适配器模式**: 接口适配
- ✅ **类型级编程**: 编译时计算
- ✅ **扩展 Trait**: 功能扩展
- ✅ **综合案例**: 实战应用

**恭喜！** 你已经完成了 Tier 2 的所有实践指南。

**下一步学习**:

1. [../tier_03_references/](../tier_03_references/) - 完整参考文档
2. [../tier_04_advanced/](../tier_04_advanced/) - 高级主题
3. 实践项目：应用所学模式到实际项目

---

**文档元信息**:

- 创建日期: 2025-10-22
- 作者: Rust-Lang Project
- 许可: MIT OR Apache-2.0
