# C04 æ³›å‹ç¼–ç¨‹ - å®æˆ˜æ¨¡å¼æŒ‡å—

**æ–‡æ¡£ç±»å‹**: Tier 2 å®è·µæŒ‡å—
**éš¾åº¦çº§åˆ«**: â­â­â­â­ é«˜çº§
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 5-6 å°æ—¶
**æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•

- [C04 æ³›å‹ç¼–ç¨‹ - å®æˆ˜æ¨¡å¼æŒ‡å—](#c04-æ³›å‹ç¼–ç¨‹---å®æˆ˜æ¨¡å¼æŒ‡å—)
  - [ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•](#-æœ¬æ–‡æ¡£ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
  - [1. ç±»å‹çŠ¶æ€æ¨¡å¼ (Type State Pattern)](#1-ç±»å‹çŠ¶æ€æ¨¡å¼-type-state-pattern)
    - [1.1 ä»€ä¹ˆæ˜¯ç±»å‹çŠ¶æ€æ¨¡å¼ï¼Ÿ](#11-ä»€ä¹ˆæ˜¯ç±»å‹çŠ¶æ€æ¨¡å¼)
    - [1.2 åŸºç¡€å®ç°](#12-åŸºç¡€å®ç°)
    - [1.3 å®æˆ˜æ¡ˆä¾‹ï¼šHTTP å®¢æˆ·ç«¯](#13-å®æˆ˜æ¡ˆä¾‹http-å®¢æˆ·ç«¯)
  - [2. æ„å»ºå™¨æ¨¡å¼ (Builder Pattern)](#2-æ„å»ºå™¨æ¨¡å¼-builder-pattern)
    - [2.1 ä¼ ç»Ÿæ„å»ºå™¨](#21-ä¼ ç»Ÿæ„å»ºå™¨)
    - [2.2 ç±»å‹å®‰å…¨æ„å»ºå™¨](#22-ç±»å‹å®‰å…¨æ„å»ºå™¨)
    - [2.3 å®æˆ˜æ¡ˆä¾‹ï¼šé…ç½®æ„å»ºå™¨](#23-å®æˆ˜æ¡ˆä¾‹é…ç½®æ„å»ºå™¨)
  - [3. æ–°ç±»å‹æ¨¡å¼ (Newtype Pattern)](#3-æ–°ç±»å‹æ¨¡å¼-newtype-pattern)
    - [3.1 åŸºç¡€ç”¨æ³•](#31-åŸºç¡€ç”¨æ³•)
    - [3.2 ç±»å‹å®‰å…¨ä¿è¯](#32-ç±»å‹å®‰å…¨ä¿è¯)
    - [3.3 å®æˆ˜æ¡ˆä¾‹ï¼šå•ä½ç³»ç»Ÿ](#33-å®æˆ˜æ¡ˆä¾‹å•ä½ç³»ç»Ÿ)
  - [4. PhantomData æ¨¡å¼](#4-phantomdata-æ¨¡å¼)
    - [4.1 ä»€ä¹ˆæ˜¯ PhantomDataï¼Ÿ](#41-ä»€ä¹ˆæ˜¯-phantomdata)
    - [4.2 ç”¨é€”åœºæ™¯](#42-ç”¨é€”åœºæ™¯)
    - [4.3 å®æˆ˜æ¡ˆä¾‹ï¼šç”Ÿå‘½å‘¨æœŸæ ‡è®°](#43-å®æˆ˜æ¡ˆä¾‹ç”Ÿå‘½å‘¨æœŸæ ‡è®°)
  - [5. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)](#5-ç­–ç•¥æ¨¡å¼-strategy-pattern)
    - [5.1 ä½¿ç”¨ Trait å®ç°](#51-ä½¿ç”¨-trait-å®ç°)
    - [5.2 å®æˆ˜æ¡ˆä¾‹ï¼šæ’åºç­–ç•¥](#52-å®æˆ˜æ¡ˆä¾‹æ’åºç­–ç•¥)
  - [6. è®¿é—®è€…æ¨¡å¼ (Visitor Pattern)](#6-è®¿é—®è€…æ¨¡å¼-visitor-pattern)
    - [6.1 åŸºç¡€å®ç°](#61-åŸºç¡€å®ç°)
    - [6.2 å®æˆ˜æ¡ˆä¾‹ï¼šAST éå†](#62-å®æˆ˜æ¡ˆä¾‹ast-éå†)
  - [7. é€‚é…å™¨æ¨¡å¼ (Adapter Pattern)](#7-é€‚é…å™¨æ¨¡å¼-adapter-pattern)
    - [7.1 ä½¿ç”¨ Trait é€‚é…](#71-ä½¿ç”¨-trait-é€‚é…)
    - [7.2 å®æˆ˜æ¡ˆä¾‹ï¼šIO é€‚é…å™¨](#72-å®æˆ˜æ¡ˆä¾‹io-é€‚é…å™¨)
  - [8. ç±»å‹çº§ç¼–ç¨‹æ¨¡å¼](#8-ç±»å‹çº§ç¼–ç¨‹æ¨¡å¼)
    - [8.1 ç¼–è¯‘æ—¶è®¡ç®—](#81-ç¼–è¯‘æ—¶è®¡ç®—)
    - [8.2 ç±»å‹çº§åˆ—è¡¨](#82-ç±»å‹çº§åˆ—è¡¨)
    - [8.3 å®æˆ˜æ¡ˆä¾‹ï¼šç±»å‹å®‰å…¨çš„ SQL æŸ¥è¯¢](#83-å®æˆ˜æ¡ˆä¾‹ç±»å‹å®‰å…¨çš„-sql-æŸ¥è¯¢)
  - [9. æ‰©å±• Trait æ¨¡å¼](#9-æ‰©å±•-trait-æ¨¡å¼)
    - [9.1 ä¸ºå¤–éƒ¨ç±»å‹æ·»åŠ åŠŸèƒ½](#91-ä¸ºå¤–éƒ¨ç±»å‹æ·»åŠ åŠŸèƒ½)
    - [9.2 å®æˆ˜æ¡ˆä¾‹ï¼šå­—ç¬¦ä¸²æ‰©å±•](#92-å®æˆ˜æ¡ˆä¾‹å­—ç¬¦ä¸²æ‰©å±•)
  - [10. ç»¼åˆå®æˆ˜æ¡ˆä¾‹](#10-ç»¼åˆå®æˆ˜æ¡ˆä¾‹)
    - [10.1 æ¡ˆä¾‹ 1ï¼šç±»å‹å®‰å…¨çš„ API å®¢æˆ·ç«¯](#101-æ¡ˆä¾‹-1ç±»å‹å®‰å…¨çš„-api-å®¢æˆ·ç«¯)
    - [10.2 æ¡ˆä¾‹ 2ï¼šæ’ä»¶ç³»ç»Ÿ](#102-æ¡ˆä¾‹-2æ’ä»¶ç³»ç»Ÿ)
  - [11. æœ€ä½³å®è·µ](#11-æœ€ä½³å®è·µ)
    - [11.1 é€‰æ‹©åˆé€‚çš„æ¨¡å¼](#111-é€‰æ‹©åˆé€‚çš„æ¨¡å¼)
    - [11.2 å¹³è¡¡ç±»å‹å®‰å…¨ä¸å¤æ‚åº¦](#112-å¹³è¡¡ç±»å‹å®‰å…¨ä¸å¤æ‚åº¦)
    - [11.3 æ€§èƒ½è€ƒè™‘](#113-æ€§èƒ½è€ƒè™‘)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ¯ ç»ƒä¹ é¢˜](#-ç»ƒä¹ é¢˜)
  - [ğŸ“ å°ç»“](#-å°ç»“)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬æŒ‡å—çš„å­¦ä¹ ï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… æŒæ¡å¸¸è§çš„ Rust æ³›å‹è®¾è®¡æ¨¡å¼
- âœ… å®ç°ç±»å‹çŠ¶æ€æ¨¡å¼å’Œæ„å»ºå™¨æ¨¡å¼
- âœ… ä½¿ç”¨ PhantomData è¿›è¡Œç±»å‹æ ‡è®°
- âœ… åº”ç”¨ç­–ç•¥æ¨¡å¼å’Œè®¿é—®è€…æ¨¡å¼
- âœ… å®ç°ç±»å‹çº§ç¼–ç¨‹æŠ€å·§
- âœ… è®¾è®¡ç±»å‹å®‰å…¨çš„ API

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å®æˆ˜æ¨¡å¼æŒ‡å— (Practical Patterns Guide)**:

- **å®šä¹‰**: æŒæ¡å¸¸è§ Rust æ³›å‹è®¾è®¡æ¨¡å¼çš„å®è·µæŒ‡å—
- **ç±»å‹**: å®è·µæŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: æ³›å‹ç¼–ç¨‹ã€è®¾è®¡æ¨¡å¼
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: æ³›å‹æ¨¡å¼ã€ç±»å‹çŠ¶æ€ã€æ„å»ºå™¨ã€PhantomDataã€ç±»å‹çº§ç¼–ç¨‹

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **ç±»å‹çŠ¶æ€æ¨¡å¼**: ç¼–è¯‘æœŸçŠ¶æ€ç®¡ç†
- **æ„å»ºå™¨æ¨¡å¼**: ç±»å‹å®‰å…¨æ„å»ºå™¨
- **PhantomData**: ç±»å‹æ ‡è®°ã€ç”Ÿå‘½å‘¨æœŸæ ‡è®°
- **ç­–ç•¥æ¨¡å¼**: Trait å®ç°ç­–ç•¥
- **ç±»å‹çº§ç¼–ç¨‹**: ç¼–è¯‘æ—¶è®¡ç®—ã€ç±»å‹çº§åˆ—è¡¨

**æ€§èƒ½ç‰¹å¾**:

- **ç¼–è¯‘æ—¶ä¼˜åŒ–**: ç±»å‹çº§ç¼–ç¨‹åœ¨ç¼–è¯‘æ—¶å®Œæˆ
- **é›¶æˆæœ¬æŠ½è±¡**: æ¨¡å¼æœ¬èº«é›¶è¿è¡Œæ—¶å¼€é”€
- **é€‚ç”¨åœºæ™¯**: ç±»å‹å®‰å…¨ã€API è®¾è®¡ã€çŠ¶æ€ç®¡ç†

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- å®æˆ˜æ¨¡å¼æŒ‡å— --[covers]--> å¤šç§æ³›å‹è®¾è®¡æ¨¡å¼
- ç±»å‹å®‰å…¨ç¨‹åº --[uses]--> å®æˆ˜æ¨¡å¼

**ä¾èµ–å…³ç³»**:

- å®æˆ˜æ¨¡å¼ --[depends-on]--> æ³›å‹ç¼–ç¨‹
- æ¨¡å¼åº”ç”¨ --[depends-on]--> å®æˆ˜æ¨¡å¼æŒ‡å—

### æ€ç»´å¯¼å›¾

```text
å®æˆ˜æ¨¡å¼æŒ‡å—
â”‚
â”œâ”€â”€ ç±»å‹çŠ¶æ€æ¨¡å¼
â”‚   â””â”€â”€ ç¼–è¯‘æœŸçŠ¶æ€ç®¡ç†
â”œâ”€â”€ æ„å»ºå™¨æ¨¡å¼
â”‚   â””â”€â”€ ç±»å‹å®‰å…¨æ„å»ºå™¨
â”œâ”€â”€ PhantomData
â”‚   â””â”€â”€ ç±»å‹æ ‡è®°
â”œâ”€â”€ ç­–ç•¥æ¨¡å¼
â”‚   â””â”€â”€ Trait å®ç°
â””â”€â”€ ç±»å‹çº§ç¼–ç¨‹
    â””â”€â”€ ç¼–è¯‘æ—¶è®¡ç®—
```

---

## ğŸ“š å‰ç½®çŸ¥è¯†

åœ¨å­¦ä¹ æœ¬æŒ‡å—ä¹‹å‰ï¼Œä½ åº”è¯¥æŒæ¡ï¼š

- âœ… [01\_æ³›å‹åŸºç¡€æŒ‡å—.md](./01_æ³›å‹åŸºç¡€æŒ‡å—.md) - æ³›å‹åŸºç¡€
- âœ… [02_Traitç³»ç»ŸæŒ‡å—.md](./02_Traitç³»ç»ŸæŒ‡å—.md) - Trait ç³»ç»Ÿ
- âœ… [03\_å…³è”ç±»å‹æŒ‡å—.md](./03_å…³è”ç±»å‹æŒ‡å—.md) - å…³è”ç±»å‹
- âœ… ç”Ÿå‘½å‘¨æœŸçš„åŸºæœ¬æ¦‚å¿µ

---

## 1. ç±»å‹çŠ¶æ€æ¨¡å¼ (Type State Pattern)

### 1.1 ä»€ä¹ˆæ˜¯ç±»å‹çŠ¶æ€æ¨¡å¼ï¼Ÿ

**ç±»å‹çŠ¶æ€æ¨¡å¼**ä½¿ç”¨ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡ŒçŠ¶æ€æœºçš„æ­£ç¡®è½¬æ¢ã€‚

**ä¼˜åŠ¿**:

- âœ… ç¼–è¯‘æ—¶çŠ¶æ€éªŒè¯
- âœ… é˜²æ­¢éæ³•çŠ¶æ€è½¬æ¢
- âœ… é›¶è¿è¡Œæ—¶å¼€é”€

### 1.2 åŸºç¡€å®ç°

```rust
// çŠ¶æ€æ ‡è®°
struct Locked;
struct Unlocked;

// å¸¦çŠ¶æ€çš„ç±»å‹
struct Door<State> {
    _state: std::marker::PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door created (locked)");
        Door {
            _state: std::marker::PhantomData,
        }
    }

    fn unlock(self) -> Door<Unlocked> {
        println!("Door unlocked");
        Door {
            _state: std::marker::PhantomData,
        }
    }
}

impl Door<Unlocked> {
    fn lock(self) -> Door<Locked> {
        println!("Door locked");
        Door {
            _state: std::marker::PhantomData,
        }
    }

    fn open(&self) {
        println!("Door opened");
    }
}

fn main() {
    let door = Door::<Locked>::new();
    // door.open(); // âŒ ç¼–è¯‘é”™è¯¯ï¼šlocked çŠ¶æ€ä¸èƒ½ open

    let door = door.unlock();
    door.open(); // âœ… æ­£ç¡®

    let door = door.lock();
    // door.open(); // âŒ ç¼–è¯‘é”™è¯¯
}
```

### 1.3 å®æˆ˜æ¡ˆä¾‹ï¼šHTTP å®¢æˆ·ç«¯

```rust
use std::marker::PhantomData;

// çŠ¶æ€æ ‡è®°
struct NoMethod;
struct WithMethod;
struct NoUrl;
struct WithUrl;

// HTTP è¯·æ±‚æ„å»ºå™¨
struct HttpRequest<M, U> {
    method: Option<String>,
    url: Option<String>,
    headers: Vec<(String, String)>,
    _method_state: PhantomData<M>,
    _url_state: PhantomData<U>,
}

impl HttpRequest<NoMethod, NoUrl> {
    fn new() -> Self {
        HttpRequest {
            method: None,
            url: None,
            headers: Vec::new(),
            _method_state: PhantomData,
            _url_state: PhantomData,
        }
    }
}

impl<U> HttpRequest<NoMethod, U> {
    fn method(self, method: String) -> HttpRequest<WithMethod, U> {
        HttpRequest {
            method: Some(method),
            url: self.url,
            headers: self.headers,
            _method_state: PhantomData,
            _url_state: PhantomData,
        }
    }
}

impl<M> HttpRequest<M, NoUrl> {
    fn url(self, url: String) -> HttpRequest<M, WithUrl> {
        HttpRequest {
            method: self.method,
            url: Some(url),
            headers: self.headers,
            _method_state: PhantomData,
            _url_state: PhantomData,
        }
    }
}

impl<M, U> HttpRequest<M, U> {
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
}

impl HttpRequest<WithMethod, WithUrl> {
    fn send(&self) -> Result<String, String> {
        println!(
            "Sending {} request to {}",
            self.method.as_ref().unwrap(),
            self.url.as_ref().unwrap()
        );
        Ok(String::from("Response"))
    }
}

fn main() {
    let request = HttpRequest::new()
        .method(String::from("GET"))
        .url(String::from("https://example.com"))
        .header(String::from("Authorization"), String::from("Bearer token"))
        .send();

    println!("{:?}", request);

    // âŒ ä»¥ä¸‹ä»£ç ä¼šåœ¨ç¼–è¯‘æ—¶æŠ¥é”™
    // let invalid = HttpRequest::new().send(); // ç¼ºå°‘ method å’Œ url
}
```

---

## 2. æ„å»ºå™¨æ¨¡å¼ (Builder Pattern)

### 2.1 ä¼ ç»Ÿæ„å»ºå™¨

```rust
#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
    timeout: u64,
    retries: u32,
}

struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
    retries: Option<u32>,
}

impl ConfigBuilder {
    fn new() -> Self {
        ConfigBuilder {
            host: None,
            port: None,
            timeout: None,
            retries: None,
        }
    }

    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }

    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }

    fn retries(mut self, retries: u32) -> Self {
        self.retries = Some(retries);
        self
    }

    fn build(self) -> Result<Config, String> {
        Ok(Config {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(80),
            timeout: self.timeout.unwrap_or(30),
            retries: self.retries.unwrap_or(3),
        })
    }
}

fn main() {
    let config = ConfigBuilder::new()
        .host(String::from("localhost"))
        .port(8080)
        .timeout(60)
        .build()
        .unwrap();

    println!("{:?}", config);
}
```

### 2.2 ç±»å‹å®‰å…¨æ„å»ºå™¨

```rust
use std::marker::PhantomData;

// çŠ¶æ€æ ‡è®°
struct NoHost;
struct WithHost;

#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
    timeout: u64,
}

struct ConfigBuilder<H> {
    host: Option<String>,
    port: u16,
    timeout: u64,
    _host_state: PhantomData<H>,
}

impl ConfigBuilder<NoHost> {
    fn new() -> Self {
        ConfigBuilder {
            host: None,
            port: 80,
            timeout: 30,
            _host_state: PhantomData,
        }
    }
}

impl<H> ConfigBuilder<H> {
    fn port(mut self, port: u16) -> Self {
        self.port = port;
        self
    }

    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
}

impl ConfigBuilder<NoHost> {
    fn host(self, host: String) -> ConfigBuilder<WithHost> {
        ConfigBuilder {
            host: Some(host),
            port: self.port,
            timeout: self.timeout,
            _host_state: PhantomData,
        }
    }
}

impl ConfigBuilder<WithHost> {
    fn build(self) -> Config {
        Config {
            host: self.host.unwrap(),
            port: self.port,
            timeout: self.timeout,
        }
    }
}

fn main() {
    let config = ConfigBuilder::new()
        .host(String::from("localhost"))
        .port(8080)
        .build();

    println!("{:?}", config);

    // âŒ ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘å¿…éœ€çš„ host
    // let invalid = ConfigBuilder::new().build();
}
```

### 2.3 å®æˆ˜æ¡ˆä¾‹ï¼šé…ç½®æ„å»ºå™¨

```rust
#[derive(Debug)]
struct DatabaseConfig {
    host: String,
    port: u16,
    username: String,
    password: String,
    database: String,
    pool_size: usize,
    timeout: u64,
}

struct DatabaseConfigBuilder {
    host: String,
    port: u16,
    username: String,
    password: String,
    database: String,
    pool_size: usize,
    timeout: u64,
}

impl DatabaseConfigBuilder {
    fn new(username: String, password: String, database: String) -> Self {
        DatabaseConfigBuilder {
            host: String::from("localhost"),
            port: 5432,
            username,
            password,
            database,
            pool_size: 10,
            timeout: 30,
        }
    }

    fn host(mut self, host: String) -> Self {
        self.host = host;
        self
    }

    fn port(mut self, port: u16) -> Self {
        self.port = port;
        self
    }

    fn pool_size(mut self, size: usize) -> Self {
        self.pool_size = size;
        self
    }

    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }

    fn build(self) -> DatabaseConfig {
        DatabaseConfig {
            host: self.host,
            port: self.port,
            username: self.username,
            password: self.password,
            database: self.database,
            pool_size: self.pool_size,
            timeout: self.timeout,
        }
    }
}

fn main() {
    let config = DatabaseConfigBuilder::new(
        String::from("admin"),
        String::from("secret"),
        String::from("mydb"),
    )
    .host(String::from("db.example.com"))
    .port(3306)
    .pool_size(20)
    .build();

    println!("{:?}", config);
}
```

---

## 3. æ–°ç±»å‹æ¨¡å¼ (Newtype Pattern)

### 3.1 åŸºç¡€ç”¨æ³•

```rust
// ä¸ºåŸºæœ¬ç±»å‹åˆ›å»ºæ–°ç±»å‹
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) {
    println!("Getting user {}", id.0);
}

fn get_product(id: ProductId) {
    println!("Getting product {}", id.0);
}

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);

    get_user(user_id);
    get_product(product_id);

    // âŒ ç±»å‹ä¸åŒ¹é…ï¼Œç¼–è¯‘é”™è¯¯
    // get_user(product_id);
}
```

### 3.2 ç±»å‹å®‰å…¨ä¿è¯

```rust
use std::ops::Add;

struct Meters(f64);
struct Kilometers(f64);

impl Meters {
    fn to_kilometers(&self) -> Kilometers {
        Kilometers(self.0 / 1000.0)
    }
}

impl Kilometers {
    fn to_meters(&self) -> Meters {
        Meters(self.0 * 1000.0)
    }
}

impl Add for Meters {
    type Output = Meters;

    fn add(self, other: Meters) -> Meters {
        Meters(self.0 + other.0)
    }
}

fn main() {
    let d1 = Meters(1500.0);
    let d2 = Meters(500.0);
    let total = d1 + d2;

    println!("Total: {} meters", total.0);

    let km = total.to_kilometers();
    println!("Total: {} km", km.0);
}
```

### 3.3 å®æˆ˜æ¡ˆä¾‹ï¼šå•ä½ç³»ç»Ÿ

```rust
use std::ops::{Add, Sub, Mul, Div};

#[derive(Debug, Clone, Copy)]
struct Celsius(f64);

#[derive(Debug, Clone, Copy)]
struct Fahrenheit(f64);

#[derive(Debug, Clone, Copy)]
struct Kelvin(f64);

impl Celsius {
    fn to_fahrenheit(&self) -> Fahrenheit {
        Fahrenheit(self.0 * 9.0 / 5.0 + 32.0)
    }

    fn to_kelvin(&self) -> Kelvin {
        Kelvin(self.0 + 273.15)
    }
}

impl Fahrenheit {
    fn to_celsius(&self) -> Celsius {
        Celsius((self.0 - 32.0) * 5.0 / 9.0)
    }

    fn to_kelvin(&self) -> Kelvin {
        self.to_celsius().to_kelvin()
    }
}

impl Kelvin {
    fn to_celsius(&self) -> Celsius {
        Celsius(self.0 - 273.15)
    }

    fn to_fahrenheit(&self) -> Fahrenheit {
        self.to_celsius().to_fahrenheit()
    }
}

impl Add for Celsius {
    type Output = Celsius;
    fn add(self, other: Celsius) -> Celsius {
        Celsius(self.0 + other.0)
    }
}

impl Sub for Celsius {
    type Output = Celsius;
    fn sub(self, other: Celsius) -> Celsius {
        Celsius(self.0 - other.0)
    }
}

fn main() {
    let temp_c = Celsius(25.0);
    let temp_f = temp_c.to_fahrenheit();
    let temp_k = temp_c.to_kelvin();

    println!("{:?} = {:?} = {:?}", temp_c, temp_f, temp_k);

    let sum = Celsius(20.0) + Celsius(5.0);
    println!("Sum: {:?}", sum);
}
```

---

## 4. PhantomData æ¨¡å¼

### 4.1 ä»€ä¹ˆæ˜¯ PhantomDataï¼Ÿ

`PhantomData<T>` æ˜¯ä¸€ä¸ªé›¶å¤§å°ç±»å‹ï¼Œç”¨äºæ ‡è®°ç±»å‹å‚æ•°çš„ä½¿ç”¨ï¼Œä½†ä¸å®é™…å­˜å‚¨è¯¥ç±»å‹çš„å€¼ã€‚

```rust
use std::marker::PhantomData;

struct Container<T> {
    _marker: PhantomData<T>,
}

impl<T> Container<T> {
    fn new() -> Self {
        Container {
            _marker: PhantomData,
        }
    }
}

fn main() {
    let c1: Container<i32> = Container::new();
    let c2: Container<String> = Container::new();

    // c1 å’Œ c2 æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä½†å¤§å°éƒ½ä¸º 0
    println!("Size of Container<i32>: {}", std::mem::size_of::<Container<i32>>());
    println!("Size of Container<String>: {}", std::mem::size_of::<Container<String>>());
}
```

### 4.2 ç”¨é€”åœºæ™¯

**åœºæ™¯ 1: ç±»å‹çŠ¶æ€æ¨¡å¼**:

```rust
struct Locked;
struct Unlocked;

struct Door<State> {
    _state: PhantomData<State>,
}
```

**åœºæ™¯ 2: ç”Ÿå‘½å‘¨æœŸæ ‡è®°**:

```rust
struct Ref<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a T>,
}
```

**åœºæ™¯ 3: ç±»å‹çº§æ ‡è®°**:

```rust
struct Validated;
struct Unvalidated;

struct Data<State> {
    content: String,
    _state: PhantomData<State>,
}
```

### 4.3 å®æˆ˜æ¡ˆä¾‹ï¼šç”Ÿå‘½å‘¨æœŸæ ‡è®°

```rust
use std::marker::PhantomData;

struct Ref<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a T>,
}

impl<'a, T> Ref<'a, T> {
    fn new(reference: &'a T) -> Self {
        Ref {
            ptr: reference as *const T,
            _marker: PhantomData,
        }
    }

    fn get(&self) -> &'a T {
        unsafe { &*self.ptr }
    }
}

fn main() {
    let value = 42;
    let ref_val = Ref::new(&value);
    println!("Value: {}", ref_val.get());
}
```

---

## 5. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

### 5.1 ä½¿ç”¨ Trait å®ç°

```rust
trait CompressionStrategy {
    fn compress(&self, data: &[u8]) -> Vec<u8>;
    fn decompress(&self, data: &[u8]) -> Vec<u8>;
}

struct GzipCompression;
struct ZlibCompression;

impl CompressionStrategy for GzipCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        println!("Compressing with Gzip");
        data.to_vec() // ç®€åŒ–å®ç°
    }

    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        println!("Decompressing with Gzip");
        data.to_vec()
    }
}

impl CompressionStrategy for ZlibCompression {
    fn compress(&self, data: &[u8]) -> Vec<u8> {
        println!("Compressing with Zlib");
        data.to_vec()
    }

    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        println!("Decompressing with Zlib");
        data.to_vec()
    }
}

struct Compressor<S: CompressionStrategy> {
    strategy: S,
}

impl<S: CompressionStrategy> Compressor<S> {
    fn new(strategy: S) -> Self {
        Compressor { strategy }
    }

    fn compress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.compress(data)
    }

    fn decompress(&self, data: &[u8]) -> Vec<u8> {
        self.strategy.decompress(data)
    }
}

fn main() {
    let data = b"Hello, World!";

    let gzip_compressor = Compressor::new(GzipCompression);
    let compressed = gzip_compressor.compress(data);
    let decompressed = gzip_compressor.decompress(&compressed);

    println!("{:?}", std::str::from_utf8(&decompressed).unwrap());
}
```

### 5.2 å®æˆ˜æ¡ˆä¾‹ï¼šæ’åºç­–ç•¥

```rust
trait SortStrategy<T> {
    fn sort(&self, data: &mut [T]);
}

struct QuickSort;
struct MergeSort;
struct BubbleSort;

impl<T: Ord> SortStrategy<T> for QuickSort {
    fn sort(&self, data: &mut [T]) {
        println!("Sorting with QuickSort");
        data.sort(); // ä½¿ç”¨æ ‡å‡†åº“å®ç°
    }
}

impl<T: Ord + Clone> SortStrategy<T> for MergeSort {
    fn sort(&self, data: &mut [T]) {
        println!("Sorting with MergeSort");
        data.sort(); // ç®€åŒ–å®ç°
    }
}

impl<T: Ord> SortStrategy<T> for BubbleSort {
    fn sort(&self, data: &mut [T]) {
        println!("Sorting with BubbleSort");
        let len = data.len();
        for i in 0..len {
            for j in 0..len - i - 1 {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
}

struct Sorter<S, T> {
    strategy: S,
    _marker: PhantomData<T>,
}

impl<S, T> Sorter<S, T>
where
    S: SortStrategy<T>,
{
    fn new(strategy: S) -> Self {
        Sorter {
            strategy,
            _marker: PhantomData,
        }
    }

    fn sort(&self, data: &mut [T]) {
        self.strategy.sort(data);
    }
}

fn main() {
    let mut numbers = vec![5, 2, 8, 1, 9];

    let sorter = Sorter::new(BubbleSort);
    sorter.sort(&mut numbers);

    println!("{:?}", numbers);
}
```

---

## 6. è®¿é—®è€…æ¨¡å¼ (Visitor Pattern)

### 6.1 åŸºç¡€å®ç°

```rust
trait Visitor {
    fn visit_number(&mut self, value: i32);
    fn visit_string(&mut self, value: &str);
}

enum Element {
    Number(i32),
    Text(String),
}

impl Element {
    fn accept<V: Visitor>(&self, visitor: &mut V) {
        match self {
            Element::Number(n) => visitor.visit_number(*n),
            Element::Text(s) => visitor.visit_string(s),
        }
    }
}

struct PrintVisitor;

impl Visitor for PrintVisitor {
    fn visit_number(&mut self, value: i32) {
        println!("Number: {}", value);
    }

    fn visit_string(&mut self, value: &str) {
        println!("String: {}", value);
    }
}

struct SumVisitor {
    total: i32,
}

impl Visitor for SumVisitor {
    fn visit_number(&mut self, value: i32) {
        self.total += value;
    }

    fn visit_string(&mut self, _value: &str) {
        // Ignore strings
    }
}

fn main() {
    let elements = vec![
        Element::Number(10),
        Element::Text(String::from("hello")),
        Element::Number(20),
    ];

    let mut print_visitor = PrintVisitor;
    for elem in &elements {
        elem.accept(&mut print_visitor);
    }

    let mut sum_visitor = SumVisitor { total: 0 };
    for elem in &elements {
        elem.accept(&mut sum_visitor);
    }
    println!("Sum: {}", sum_visitor.total);
}
```

### 6.2 å®æˆ˜æ¡ˆä¾‹ï¼šAST éå†

```rust
trait AstVisitor {
    fn visit_literal(&mut self, value: i32);
    fn visit_binary_op(&mut self, op: &str, left: &Expr, right: &Expr);
}

enum Expr {
    Literal(i32),
    BinaryOp {
        op: String,
        left: Box<Expr>,
        right: Box<Expr>,
    },
}

impl Expr {
    fn accept<V: AstVisitor>(&self, visitor: &mut V) {
        match self {
            Expr::Literal(value) => visitor.visit_literal(*value),
            Expr::BinaryOp { op, left, right } => {
                left.accept(visitor);
                right.accept(visitor);
                visitor.visit_binary_op(op, left, right);
            }
        }
    }
}

struct EvalVisitor {
    stack: Vec<i32>,
}

impl AstVisitor for EvalVisitor {
    fn visit_literal(&mut self, value: i32) {
        self.stack.push(value);
    }

    fn visit_binary_op(&mut self, op: &str, _left: &Expr, _right: &Expr) {
        let right = self.stack.pop().unwrap();
        let left = self.stack.pop().unwrap();

        let result = match op.as_str() {
            "+" => left + right,
            "-" => left - right,
            "*" => left * right,
            "/" => left / right,
            _ => 0,
        };

        self.stack.push(result);
    }
}

fn main() {
    // è¡¨è¾¾å¼: (10 + 20) * 3
    let expr = Expr::BinaryOp {
        op: String::from("*"),
        left: Box::new(Expr::BinaryOp {
            op: String::from("+"),
            left: Box::new(Expr::Literal(10)),
            right: Box::new(Expr::Literal(20)),
        }),
        right: Box::new(Expr::Literal(3)),
    };

    let mut eval = EvalVisitor { stack: Vec::new() };
    expr.accept(&mut eval);

    println!("Result: {}", eval.stack[0]); // 90
}
```

---

## 7. é€‚é…å™¨æ¨¡å¼ (Adapter Pattern)

### 7.1 ä½¿ç”¨ Trait é€‚é…

```rust
trait Target {
    fn request(&self) -> String;
}

struct Adaptee {
    data: String,
}

impl Adaptee {
    fn specific_request(&self) -> String {
        format!("Adaptee: {}", self.data)
    }
}

struct Adapter {
    adaptee: Adaptee,
}

impl Target for Adapter {
    fn request(&self) -> String {
        self.adaptee.specific_request()
    }
}

fn client_code(target: &impl Target) {
    println!("{}", target.request());
}

fn main() {
    let adaptee = Adaptee {
        data: String::from("special data"),
    };
    let adapter = Adapter { adaptee };

    client_code(&adapter);
}
```

### 7.2 å®æˆ˜æ¡ˆä¾‹ï¼šIO é€‚é…å™¨

```rust
use std::io::{self, Read, Write};

trait DataSource {
    fn read_data(&mut self) -> io::Result<Vec<u8>>;
}

trait DataSink {
    fn write_data(&mut self, data: &[u8]) -> io::Result<()>;
}

struct FileAdapter<R: Read> {
    reader: R,
}

impl<R: Read> DataSource for FileAdapter<R> {
    fn read_data(&mut self) -> io::Result<Vec<u8>> {
        let mut buffer = Vec::new();
        self.reader.read_to_end(&mut buffer)?;
        Ok(buffer)
    }
}

struct WriterAdapter<W: Write> {
    writer: W,
}

impl<W: Write> DataSink for WriterAdapter<W> {
    fn write_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.writer.write_all(data)
    }
}

fn process_data<S: DataSource, D: DataSink>(
    source: &mut S,
    sink: &mut D,
) -> io::Result<()> {
    let data = source.read_data()?;
    sink.write_data(&data)?;
    Ok(())
}
```

---

## 8. ç±»å‹çº§ç¼–ç¨‹æ¨¡å¼

### 8.1 ç¼–è¯‘æ—¶è®¡ç®—

```rust
use std::marker::PhantomData;

trait Nat {
    fn to_usize() -> usize;
}

struct Zero;
struct Succ<N: Nat>(PhantomData<N>);

impl Nat for Zero {
    fn to_usize() -> usize {
        0
    }
}

impl<N: Nat> Nat for Succ<N> {
    fn to_usize() -> usize {
        1 + N::to_usize()
    }
}

type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

fn main() {
    println!("Three = {}", Three::to_usize()); // 3
}
```

### 8.2 ç±»å‹çº§åˆ—è¡¨

```rust
trait TypeList {
    fn len() -> usize;
}

struct Nil;
struct Cons<Head, Tail: TypeList>(PhantomData<(Head, Tail)>);

impl TypeList for Nil {
    fn len() -> usize {
        0
    }
}

impl<Head, Tail: TypeList> TypeList for Cons<Head, Tail> {
    fn len() -> usize {
        1 + Tail::len()
    }
}

type MyList = Cons<i32, Cons<String, Cons<bool, Nil>>>;

fn main() {
    println!("List length: {}", MyList::len()); // 3
}
```

### 8.3 å®æˆ˜æ¡ˆä¾‹ï¼šç±»å‹å®‰å…¨çš„ SQL æŸ¥è¯¢

```rust
use std::marker::PhantomData;

struct Selected;
struct NotSelected;

struct HasWhere;
struct NoWhere;

struct Query<S, W> {
    select: String,
    from: String,
    where_clause: Option<String>,
    _select_state: PhantomData<S>,
    _where_state: PhantomData<W>,
}

impl Query<NotSelected, NoWhere> {
    fn new() -> Self {
        Query {
            select: String::new(),
            from: String::new(),
            where_clause: None,
            _select_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<W> Query<NotSelected, W> {
    fn select(self, fields: &str) -> Query<Selected, W> {
        Query {
            select: fields.to_string(),
            from: self.from,
            where_clause: self.where_clause,
            _select_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<S> Query<S, NoWhere> {
    fn from(mut self, table: &str) -> Self {
        self.from = table.to_string();
        self
    }

    fn where_clause(self, condition: &str) -> Query<S, HasWhere> {
        Query {
            select: self.select,
            from: self.from,
            where_clause: Some(condition.to_string()),
            _select_state: PhantomData,
            _where_state: PhantomData,
        }
    }
}

impl<W> Query<Selected, W> {
    fn build(&self) -> String {
        let mut sql = format!("SELECT {} FROM {}", self.select, self.from);
        if let Some(ref where_clause) = self.where_clause {
            sql.push_str(&format!(" WHERE {}", where_clause));
        }
        sql
    }
}

fn main() {
    let query = Query::new()
        .select("id, name")
        .from("users")
        .where_clause("age > 18")
        .build();

    println!("{}", query);
    // Output: SELECT id, name FROM users WHERE age > 18

    // âŒ ç¼–è¯‘é”™è¯¯ï¼šå¿…é¡»å…ˆ select
    // let invalid = Query::new().from("users").build();
}
```

---

## 9. æ‰©å±• Trait æ¨¡å¼

### 9.1 ä¸ºå¤–éƒ¨ç±»å‹æ·»åŠ åŠŸèƒ½

```rust
trait StringExt {
    fn is_palindrome(&self) -> bool;
    fn word_count(&self) -> usize;
}

impl StringExt for String {
    fn is_palindrome(&self) -> bool {
        let cleaned: String = self.chars()
            .filter(|c| c.is_alphanumeric())
            .map(|c| c.to_lowercase().next().unwrap())
            .collect();

        cleaned == cleaned.chars().rev().collect::<String>()
    }

    fn word_count(&self) -> usize {
        self.split_whitespace().count()
    }
}

impl StringExt for &str {
    fn is_palindrome(&self) -> bool {
        self.to_string().is_palindrome()
    }

    fn word_count(&self) -> usize {
        self.split_whitespace().count()
    }
}

fn main() {
    let s = String::from("A man a plan a canal Panama");
    println!("Is palindrome: {}", s.is_palindrome());
    println!("Word count: {}", s.word_count());

    let s2 = "Hello world";
    println!("Word count: {}", s2.word_count());
}
```

### 9.2 å®æˆ˜æ¡ˆä¾‹ï¼šå­—ç¬¦ä¸²æ‰©å±•

```rust
trait StrExt {
    fn truncate(&self, max_len: usize) -> String;
    fn capitalize(&self) -> String;
    fn snake_case(&self) -> String;
}

impl StrExt for str {
    fn truncate(&self, max_len: usize) -> String {
        if self.len() <= max_len {
            self.to_string()
        } else {
            format!("{}...", &self[..max_len])
        }
    }

    fn capitalize(&self) -> String {
        let mut chars = self.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => first.to_uppercase().chain(chars).collect(),
        }
    }

    fn snake_case(&self) -> String {
        self.chars()
            .flat_map(|c| {
                if c.is_uppercase() {
                    vec!['_', c.to_lowercase().next().unwrap()]
                } else {
                    vec![c]
                }
            })
            .collect::<String>()
            .trim_start_matches('_')
            .to_string()
    }
}

fn main() {
    println!("{}", "Hello, World!".truncate(8)); // "Hello, W..."
    println!("{}", "hello".capitalize());         // "Hello"
    println!("{}", "CamelCaseString".snake_case()); // "camel_case_string"
}
```

---

## 10. ç»¼åˆå®æˆ˜æ¡ˆä¾‹

### 10.1 æ¡ˆä¾‹ 1ï¼šç±»å‹å®‰å…¨çš„ API å®¢æˆ·ç«¯

```rust
use std::marker::PhantomData;

struct Unauthenticated;
struct Authenticated;

struct ApiClient<State> {
    base_url: String,
    token: Option<String>,
    _state: PhantomData<State>,
}

impl ApiClient<Unauthenticated> {
    fn new(base_url: String) -> Self {
        ApiClient {
            base_url,
            token: None,
            _state: PhantomData,
        }
    }

    fn authenticate(self, token: String) -> ApiClient<Authenticated> {
        ApiClient {
            base_url: self.base_url,
            token: Some(token),
            _state: PhantomData,
        }
    }
}

impl ApiClient<Authenticated> {
    fn get(&self, endpoint: &str) -> Result<String, String> {
        println!(
            "GET {}{} with token {}",
            self.base_url,
            endpoint,
            self.token.as_ref().unwrap()
        );
        Ok(String::from("response"))
    }

    fn post(&self, endpoint: &str, data: &str) -> Result<String, String> {
        println!(
            "POST {}{} with data: {}",
            self.base_url,
            endpoint,
            data
        );
        Ok(String::from("response"))
    }
}

fn main() {
    let client = ApiClient::new(String::from("https://api.example.com"));

    // âŒ ç¼–è¯‘é”™è¯¯ï¼šæœªè®¤è¯ä¸èƒ½è°ƒç”¨ get
    // client.get("/users");

    let client = client.authenticate(String::from("secret_token"));

    // âœ… è®¤è¯åå¯ä»¥è°ƒç”¨
    let _ = client.get("/users");
    let _ = client.post("/users", r#"{"name": "Alice"}"#);
}
```

### 10.2 æ¡ˆä¾‹ 2ï¼šæ’ä»¶ç³»ç»Ÿ

```rust
trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn version(&self) -> &str;
    fn initialize(&mut self) -> Result<(), String>;
    fn execute(&self, input: &str) -> Result<String, String>;
    fn shutdown(&mut self) -> Result<(), String>;
}

struct PluginRegistry {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginRegistry {
    fn new() -> Self {
        PluginRegistry {
            plugins: Vec::new(),
        }
    }

    fn register(&mut self, mut plugin: Box<dyn Plugin>) -> Result<(), String> {
        plugin.initialize()?;
        println!("Registered plugin: {} v{}", plugin.name(), plugin.version());
        self.plugins.push(plugin);
        Ok(())
    }

    fn execute_all(&self, input: &str) {
        for plugin in &self.plugins {
            match plugin.execute(input) {
                Ok(output) => println!("{}: {}", plugin.name(), output),
                Err(e) => println!("{} error: {}", plugin.name(), e),
            }
        }
    }

    fn shutdown(&mut self) {
        for plugin in &mut self.plugins {
            let _ = plugin.shutdown();
        }
    }
}

struct LoggerPlugin;

impl Plugin for LoggerPlugin {
    fn name(&self) -> &str {
        "Logger"
    }

    fn version(&self) -> &str {
        "1.0.0"
    }

    fn initialize(&mut self) -> Result<(), String> {
        println!("[Logger] Initializing...");
        Ok(())
    }

    fn execute(&self, input: &str) -> Result<String, String> {
        Ok(format!("Logged: {}", input))
    }

    fn shutdown(&mut self) -> Result<(), String> {
        println!("[Logger] Shutting down...");
        Ok(())
    }
}

fn main() {
    let mut registry = PluginRegistry::new();
    registry.register(Box::new(LoggerPlugin)).unwrap();

    registry.execute_all("test input");

    registry.shutdown();
}
```

---

## 11. æœ€ä½³å®è·µ

### 11.1 é€‰æ‹©åˆé€‚çš„æ¨¡å¼

| åœºæ™¯         | æ¨èæ¨¡å¼     |
| ------------ | ------------ |
| çŠ¶æ€æœº       | ç±»å‹çŠ¶æ€æ¨¡å¼ |
| å¤æ‚å¯¹è±¡æ„å»º | æ„å»ºå™¨æ¨¡å¼   |
| ç±»å‹å®‰å…¨åŒ…è£… | æ–°ç±»å‹æ¨¡å¼   |
| ç®—æ³•åˆ‡æ¢     | ç­–ç•¥æ¨¡å¼     |
| æ•°æ®ç»“æ„éå† | è®¿é—®è€…æ¨¡å¼   |
| æ¥å£é€‚é…     | é€‚é…å™¨æ¨¡å¼   |
| ç¼–è¯‘æ—¶è®¡ç®—   | ç±»å‹çº§ç¼–ç¨‹   |

### 11.2 å¹³è¡¡ç±»å‹å®‰å…¨ä¸å¤æ‚åº¦

```rust
// âŒ è¿‡åº¦å¤æ‚
struct Config<H, P, T, R> { /* ... */ }

// âœ… åˆç†ä½¿ç”¨
struct Config {
    host: String,
    port: u16,
}
```

### 11.3 æ€§èƒ½è€ƒè™‘

- âœ… ç±»å‹çŠ¶æ€æ¨¡å¼æ˜¯é›¶æˆæœ¬æŠ½è±¡
- âœ… PhantomData ä¸å ç”¨ç©ºé—´
- âœ… é™æ€åˆ†å‘ï¼ˆtrait boundsï¼‰æ¯”åŠ¨æ€åˆ†å‘ï¼ˆtrait objectsï¼‰å¿«
- âš ï¸ è¿‡å¤šæ³›å‹ä¼šå¢åŠ ç¼–è¯‘æ—¶é—´å’ŒäºŒè¿›åˆ¶å¤§å°

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [../tier_04_advanced/01_é«˜çº§ç±»å‹æŠ€å·§.md](../tier_04_advanced/01_é«˜çº§ç±»å‹æŠ€å·§.md) - é«˜çº§ç±»å‹æŠ€å·§
- [../tier_04_advanced/04_ç±»å‹çº§ç¼–ç¨‹.md](../tier_04_advanced/04_ç±»å‹çº§ç¼–ç¨‹.md) - ç±»å‹çº§ç¼–ç¨‹
- [../tier_04_advanced/05_è®¾è®¡æ¨¡å¼è¿›é˜¶.md](../tier_04_advanced/05_è®¾è®¡æ¨¡å¼è¿›é˜¶.md) - è®¾è®¡æ¨¡å¼è¿›é˜¶
- [../tier_03_references/01_æ³›å‹è¯­æ³•å‚è€ƒ.md](../tier_03_references/01_æ³›å‹è¯­æ³•å‚è€ƒ.md) - å®Œæ•´è¯­æ³•å‚è€ƒ

---

## ğŸ¯ ç»ƒä¹ é¢˜

**ç»ƒä¹  1: å®ç°ç±»å‹å®‰å…¨çš„çŠ¶æ€æœº**:

åˆ›å»ºä¸€ä¸ªæ–‡ä»¶æ“ä½œçš„çŠ¶æ€æœºï¼ŒçŠ¶æ€åŒ…æ‹¬ï¼šClosedã€Openã€Readingã€Writingã€‚

**ç»ƒä¹  2: å®ç°ç±»å‹å®‰å…¨çš„æ„å»ºå™¨**:

ä¸ºæ•°æ®åº“è¿æ¥åˆ›å»ºä¸€ä¸ªç±»å‹å®‰å…¨çš„æ„å»ºå™¨ï¼Œç¡®ä¿å¿…éœ€å­—æ®µåœ¨ç¼–è¯‘æ—¶éªŒè¯ã€‚

**ç»ƒä¹  3: å®ç°ç­–ç•¥æ¨¡å¼**:

åˆ›å»ºä¸€ä¸ªæ”¯æŒå¤šç§åŠ å¯†ç®—æ³•çš„ç³»ç»Ÿï¼Œä½¿ç”¨ç­–ç•¥æ¨¡å¼ã€‚

---

## ğŸ“ å°ç»“

åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ï¼š

- âœ… **ç±»å‹çŠ¶æ€æ¨¡å¼**: ç¼–è¯‘æ—¶çŠ¶æ€éªŒè¯
- âœ… **æ„å»ºå™¨æ¨¡å¼**: ç±»å‹å®‰å…¨çš„å¯¹è±¡æ„å»º
- âœ… **æ–°ç±»å‹æ¨¡å¼**: ç±»å‹å®‰å…¨åŒ…è£…
- âœ… **PhantomData**: é›¶å¤§å°ç±»å‹æ ‡è®°
- âœ… **ç­–ç•¥æ¨¡å¼**: ç®—æ³•åˆ‡æ¢
- âœ… **è®¿é—®è€…æ¨¡å¼**: æ•°æ®ç»“æ„éå†
- âœ… **é€‚é…å™¨æ¨¡å¼**: æ¥å£é€‚é…
- âœ… **ç±»å‹çº§ç¼–ç¨‹**: ç¼–è¯‘æ—¶è®¡ç®—
- âœ… **æ‰©å±• Trait**: åŠŸèƒ½æ‰©å±•
- âœ… **ç»¼åˆæ¡ˆä¾‹**: å®æˆ˜åº”ç”¨

**æ­å–œï¼** ä½ å·²ç»å®Œæˆäº† Tier 2 çš„æ‰€æœ‰å®è·µæŒ‡å—ã€‚

**ä¸‹ä¸€æ­¥å­¦ä¹ **:

1. [../tier_03_references/](../tier_03_references/) - å®Œæ•´å‚è€ƒæ–‡æ¡£
2. [../tier_04_advanced/](../tier_04_advanced/) - é«˜çº§ä¸»é¢˜
3. å®è·µé¡¹ç›®ï¼šåº”ç”¨æ‰€å­¦æ¨¡å¼åˆ°å®é™…é¡¹ç›®

---

**æ–‡æ¡£å…ƒä¿¡æ¯**:

- åˆ›å»ºæ—¥æœŸ: 2025-10-22
- ä½œè€…: Rust-Lang Project
- è®¸å¯: MIT OR Apache-2.0
