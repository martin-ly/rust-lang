# ğŸ¯ C04: æ³›å‹ç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C04 æ³›å‹ç¼–ç¨‹
> **ç›®æ ‡**: é€šè¿‡ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å­¦ä¹ è€…æ·±å…¥ç†è§£ Rust æ³›å‹ç¼–ç¨‹å’Œ Trait ç³»ç»Ÿã€‚

---

## ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•

- [ğŸ¯ C04: æ³›å‹ç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ](#-c04-æ³›å‹ç¼–ç¨‹---ä»£ç ç¤ºä¾‹é›†åˆ)
  - [ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•](#-æœ¬æ–‡æ¡£ç›®å½•)
  - [ğŸ“‹ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
  - [ğŸ¯ ç¤ºä¾‹å¯¼èˆª](#-ç¤ºä¾‹å¯¼èˆª)
  - [ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹](#-tier-1-åŸºç¡€å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹1.1: æ³›å‹å‡½æ•°åŸºç¡€](#ç¤ºä¾‹11-æ³›å‹å‡½æ•°åŸºç¡€)
    - [ç¤ºä¾‹1.2: æ³›å‹ç»“æ„ä½“](#ç¤ºä¾‹12-æ³›å‹ç»“æ„ä½“)
    - [ç¤ºä¾‹1.3: æ³›å‹æšä¸¾](#ç¤ºä¾‹13-æ³›å‹æšä¸¾)
    - [ç¤ºä¾‹1.4: Optionå’ŒResult](#ç¤ºä¾‹14-optionå’Œresult)
    - [ç¤ºä¾‹1.5: æ³›å‹æ–¹æ³•](#ç¤ºä¾‹15-æ³›å‹æ–¹æ³•)
    - [ç¤ºä¾‹1.6: åŸºç¡€Traitçº¦æŸ](#ç¤ºä¾‹16-åŸºç¡€traitçº¦æŸ)
  - [ğŸ“ Tier 2: å®è·µå±‚ç¤ºä¾‹](#-tier-2-å®è·µå±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹2.1: Traitå¯¹è±¡ä¸æ³›å‹å¯¹æ¯”](#ç¤ºä¾‹21-traitå¯¹è±¡ä¸æ³›å‹å¯¹æ¯”)
    - [ç¤ºä¾‹2.2: å…³è”ç±»å‹è¯¦è§£](#ç¤ºä¾‹22-å…³è”ç±»å‹è¯¦è§£)
    - [ç¤ºä¾‹2.3: æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ](#ç¤ºä¾‹23-æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ)
    - [ç¤ºä¾‹2.4: å¤šTraitçº¦æŸ](#ç¤ºä¾‹24-å¤štraitçº¦æŸ)
    - [ç¤ºä¾‹2.5: Constæ³›å‹](#ç¤ºä¾‹25-constæ³›å‹)
    - [ç¤ºä¾‹2.6: é»˜è®¤ç±»å‹å‚æ•°](#ç¤ºä¾‹26-é»˜è®¤ç±»å‹å‚æ•°)
  - [ğŸš€ Tier 3: é«˜çº§å±‚ç¤ºä¾‹](#-tier-3-é«˜çº§å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹3.1: é«˜é˜¶Traitçº¦æŸ (HRTB)](#ç¤ºä¾‹31-é«˜é˜¶traitçº¦æŸ-hrtb)
    - [ç¤ºä¾‹3.2: ç±»å‹çº§ç¼–ç¨‹](#ç¤ºä¾‹32-ç±»å‹çº§ç¼–ç¨‹)
    - [ç¤ºä¾‹3.3: æ³›å‹ç‰¹åŒ–æ¨¡æ‹Ÿ](#ç¤ºä¾‹33-æ³›å‹ç‰¹åŒ–æ¨¡æ‹Ÿ)
    - [ç¤ºä¾‹3.4: GAT - æ³›å‹å…³è”ç±»å‹](#ç¤ºä¾‹34-gat---æ³›å‹å…³è”ç±»å‹)
    - [ç¤ºä¾‹3.5: ç±»å‹çŠ¶æ€æ¨¡å¼](#ç¤ºä¾‹35-ç±»å‹çŠ¶æ€æ¨¡å¼)
    - [ç¤ºä¾‹3.6: é›¶æˆæœ¬æŠ½è±¡éªŒè¯](#ç¤ºä¾‹36-é›¶æˆæœ¬æŠ½è±¡éªŒè¯)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å­¦ä¹ è·¯å¾„å»ºè®®](#å­¦ä¹ è·¯å¾„å»ºè®®)
    - [æ ¸å¿ƒæ¦‚å¿µæ€»ç»“](#æ ¸å¿ƒæ¦‚å¿µæ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº† **18ä¸ªç²¾å¿ƒè®¾è®¡çš„ä»£ç ç¤ºä¾‹**ï¼Œè¦†ç›–äº† C04 æ¨¡å—çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä»åŸºç¡€åˆ°é«˜çº§ï¼Œæ¯ä¸ªç¤ºä¾‹éƒ½é…æœ‰è¯¦ç»†çš„è§£é‡Šå’Œè¿è¡Œç»“æœã€‚

---

## ğŸ¯ ç¤ºä¾‹å¯¼èˆª

| # | ç¤ºä¾‹åç§° | æ ¸å¿ƒæ¦‚å¿µ | éš¾åº¦ | é¢„è®¡å­¦ä¹ æ—¶é—´ |
| --- | --- | --- | --- | --- |
| **Tier 1: åŸºç¡€å±‚** |||||
| 1.1 | [æ³›å‹å‡½æ•°åŸºç¡€](#ç¤ºä¾‹11-æ³›å‹å‡½æ•°åŸºç¡€) | å‡½æ•°æ³›å‹ | â­ | 15åˆ†é’Ÿ |
| 1.2 | [æ³›å‹ç»“æ„ä½“](#ç¤ºä¾‹12-æ³›å‹ç»“æ„ä½“) | ç»“æ„ä½“æ³›å‹ | â­ | 20åˆ†é’Ÿ |
| 1.3 | [æ³›å‹æšä¸¾](#ç¤ºä¾‹13-æ³›å‹æšä¸¾) | æšä¸¾æ³›å‹ | â­ | 15åˆ†é’Ÿ |
| 1.4 | [Optionå’ŒResult](#ç¤ºä¾‹14-optionå’Œresult) | æ ‡å‡†åº“æ³›å‹ | â­â­ | 25åˆ†é’Ÿ |
| 1.5 | [æ³›å‹æ–¹æ³•](#ç¤ºä¾‹15-æ³›å‹æ–¹æ³•) | æ–¹æ³•æ³›å‹ | â­â­ | 20åˆ†é’Ÿ |
| 1.6 | [åŸºç¡€Traitçº¦æŸ](#ç¤ºä¾‹16-åŸºç¡€traitçº¦æŸ) | whereå­å¥ | â­â­ | 25åˆ†é’Ÿ |
| **Tier 2: å®è·µå±‚** |||||
| 2.1 | [Traitå¯¹è±¡ä¸æ³›å‹å¯¹æ¯”](#ç¤ºä¾‹21-traitå¯¹è±¡ä¸æ³›å‹å¯¹æ¯”) | é™æ€vsåŠ¨æ€åˆ†æ´¾ | â­â­ | 30åˆ†é’Ÿ |
| 2.2 | [å…³è”ç±»å‹è¯¦è§£](#ç¤ºä¾‹22-å…³è”ç±»å‹è¯¦è§£) | å…³è”ç±»å‹ | â­â­â­ | 35åˆ†é’Ÿ |
| 2.3 | [æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ](#ç¤ºä¾‹23-æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ) | ç”Ÿå‘½å‘¨æœŸçº¦æŸ | â­â­â­ | 40åˆ†é’Ÿ |
| 2.4 | [å¤šTraitçº¦æŸ](#ç¤ºä¾‹24-å¤štraitçº¦æŸ) | å¤šé‡çº¦æŸ | â­â­â­ | 30åˆ†é’Ÿ |
| 2.5 | [Constæ³›å‹](#ç¤ºä¾‹25-constæ³›å‹) | å¸¸é‡æ³›å‹å‚æ•° | â­â­â­ | 35åˆ†é’Ÿ |
| 2.6 | [é»˜è®¤ç±»å‹å‚æ•°](#ç¤ºä¾‹26-é»˜è®¤ç±»å‹å‚æ•°) | é»˜è®¤æ³›å‹ | â­â­ | 25åˆ†é’Ÿ |
| **Tier 3: é«˜çº§å±‚** |||||
| 3.1 | [é«˜é˜¶Traitçº¦æŸ](#ç¤ºä¾‹31-é«˜é˜¶traitçº¦æŸ-hrtb) | HRTB | â­â­â­â­ | 50åˆ†é’Ÿ |
| 3.2 | [ç±»å‹çº§ç¼–ç¨‹](#ç¤ºä¾‹32-ç±»å‹çº§ç¼–ç¨‹) | ç±»å‹ç³»ç»ŸæŠ€å·§ | â­â­â­â­ | 60åˆ†é’Ÿ |
| 3.3 | [æ³›å‹ç‰¹åŒ–æ¨¡æ‹Ÿ](#ç¤ºä¾‹33-æ³›å‹ç‰¹åŒ–æ¨¡æ‹Ÿ) | ç‰¹åŒ–æ¨¡å¼ | â­â­â­â­ | 45åˆ†é’Ÿ |
| 3.4 | [GAT - æ³›å‹å…³è”ç±»å‹](#ç¤ºä¾‹34-gat---æ³›å‹å…³è”ç±»å‹) | GAT | â­â­â­â­â­ | 60åˆ†é’Ÿ |
| 3.5 | [ç±»å‹çŠ¶æ€æ¨¡å¼](#ç¤ºä¾‹35-ç±»å‹çŠ¶æ€æ¨¡å¼) | ç±»å‹é©±åŠ¨è®¾è®¡ | â­â­â­â­ | 50åˆ†é’Ÿ |
| 3.6 | [é›¶æˆæœ¬æŠ½è±¡éªŒè¯](#ç¤ºä¾‹36-é›¶æˆæœ¬æŠ½è±¡éªŒè¯) | æ€§èƒ½åˆ†æ | â­â­â­â­â­ | 60åˆ†é’Ÿ |

---

## ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹

### ç¤ºä¾‹1.1: æ³›å‹å‡½æ•°åŸºç¡€

**ç›®æ ‡**: ç†è§£æ³›å‹å‡½æ•°çš„åŸºæœ¬è¯­æ³•å’Œä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== æ³›å‹å‡½æ•°åŸºç¡€ =====\n");

    // ä¸ä½¿ç”¨æ³›å‹ - éœ€è¦ä¸ºæ¯ç§ç±»å‹å†™ä¸€ä¸ªå‡½æ•°
    fn largest_i32(list: &[i32]) -> i32 {
        let mut largest = list[0];
        for &item in list {
            if item > largest {
                largest = item;
            }
        }
        largest
    }

    fn largest_char(list: &[char]) -> char {
        let mut largest = list[0];
        for &item in list {
            if item > largest {
                largest = item;
            }
        }
        largest
    }

    let number_list = vec![34, 50, 25, 100, 65];
    println!("æœ€å¤§çš„æ•°å­—: {}", largest_i32(&number_list));

    let char_list = vec!['y', 'm', 'a', 'q'];
    println!("æœ€å¤§çš„å­—ç¬¦: {}", largest_char(&char_list));

    println!("\n===== ä½¿ç”¨æ³›å‹ =====\n");

    // ä½¿ç”¨æ³›å‹ - ä¸€ä¸ªå‡½æ•°æ”¯æŒå¤šç§ç±»å‹
    fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
        let mut largest = list[0];
        for &item in list {
            if item > largest {
                largest = item;
            }
        }
        largest
    }

    let number_list = vec![34, 50, 25, 100, 65];
    println!("æœ€å¤§çš„æ•°å­—: {}", largest(&number_list));

    let char_list = vec!['y', 'm', 'a', 'q'];
    println!("æœ€å¤§çš„å­—ç¬¦: {}", largest(&char_list));

    let float_list = vec![3.14, 2.71, 1.41, 1.73];
    println!("æœ€å¤§çš„æµ®ç‚¹æ•°: {}", largest(&float_list));

    println!("\n===== ç±»å‹æ¨æ–­ =====\n");

    // ç¼–è¯‘å™¨å¯ä»¥æ¨æ–­ç±»å‹
    fn identity<T>(value: T) -> T {
        value
    }

    let num = identity(42);        // T = i32
    let text = identity("hello");  // T = &str
    let flag = identity(true);     // T = bool

    println!("num: {}, text: {}, flag: {}", num, text, flag);

    println!("\n===== å¤šä¸ªç±»å‹å‚æ•° =====\n");

    fn pair<T, U>(first: T, second: U) -> (T, U) {
        (first, second)
    }

    let p1 = pair(42, "hello");
    let p2 = pair(3.14, true);

    println!("p1: {:?}", p1);
    println!("p2: {:?}", p2);
}
```

**è¯´æ˜**:

- **æ³›å‹å‚æ•°**: ä½¿ç”¨ `<T>` å£°æ˜æ³›å‹ç±»å‹å‚æ•°
- **Traitçº¦æŸ**: `T: PartialOrd + Copy` è¡¨ç¤º T å¿…é¡»å®ç°è¿™äº› trait
- **ç±»å‹æ¨æ–­**: ç¼–è¯‘å™¨å¯ä»¥æ ¹æ®å‚æ•°æ¨æ–­æ³›å‹ç±»å‹
- **å¤šç±»å‹å‚æ•°**: å¯ä»¥ä½¿ç”¨å¤šä¸ªæ³›å‹å‚æ•° `<T, U>`

**è¾“å‡º**:

```text
===== æ³›å‹å‡½æ•°åŸºç¡€ =====

æœ€å¤§çš„æ•°å­—: 100
æœ€å¤§çš„å­—ç¬¦: y

===== ä½¿ç”¨æ³›å‹ =====

æœ€å¤§çš„æ•°å­—: 100
æœ€å¤§çš„å­—ç¬¦: y
æœ€å¤§çš„æµ®ç‚¹æ•°: 3.14

===== ç±»å‹æ¨æ–­ =====

num: 42, text: hello, flag: true

===== å¤šä¸ªç±»å‹å‚æ•° =====

p1: (42, "hello")
p2: (3.14, true)
```

---

### ç¤ºä¾‹1.2: æ³›å‹ç»“æ„ä½“

**ç›®æ ‡**: æŒæ¡æ³›å‹ç»“æ„ä½“çš„å®šä¹‰å’Œä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== å•ç±»å‹å‚æ•°ç»“æ„ä½“ =====\n");

    #[derive(Debug)]
    struct Point<T> {
        x: T,
        y: T,
    }

    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };

    println!("æ•´æ•°ç‚¹: {:?}", integer_point);
    println!("æµ®ç‚¹æ•°ç‚¹: {:?}", float_point);

    // âŒ é”™è¯¯ï¼šx å’Œ y å¿…é¡»æ˜¯ç›¸åŒç±»å‹
    // let mixed_point = Point { x: 5, y: 4.0 };

    println!("\n===== å¤šç±»å‹å‚æ•°ç»“æ„ä½“ =====\n");

    #[derive(Debug)]
    struct MixedPoint<T, U> {
        x: T,
        y: U,
    }

    let mixed = MixedPoint { x: 5, y: 4.0 };
    println!("æ··åˆç‚¹: {:?}", mixed);

    let string_point = MixedPoint { x: "xåæ ‡", y: 100 };
    println!("å­—ç¬¦ä¸²ç‚¹: {:?}", string_point);

    println!("\n===== æ³›å‹ç»“æ„ä½“æ–¹æ³• =====\n");

    impl<T> Point<T> {
        fn x(&self) -> &T {
            &self.x
        }
    }

    // åªä¸ºç‰¹å®šç±»å‹å®ç°æ–¹æ³•
    impl Point<f32> {
        fn distance_from_origin(&self) -> f32 {
            (self.x.powi(2) + self.y.powi(2)).sqrt()
        }
    }

    let p = Point { x: 5, y: 10 };
    println!("x åæ ‡: {}", p.x());

    let p = Point { x: 3.0, y: 4.0 };
    println!("è·ç¦»åŸç‚¹: {}", p.distance_from_origin());

    println!("\n===== æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ =====\n");

    #[derive(Debug)]
    struct Wrapper<'a, T> {
        value: &'a T,
    }

    let num = 42;
    let wrapper = Wrapper { value: &num };
    println!("Wrapper: {:?}", wrapper);

    println!("\n===== å…³è”å‡½æ•° =====\n");

    impl<T, U> MixedPoint<T, U> {
        fn new(x: T, y: U) -> Self {
            MixedPoint { x, y }
        }

        fn mixup<V, W>(self, other: MixedPoint<V, W>) -> MixedPoint<T, W> {
            MixedPoint {
                x: self.x,
                y: other.y,
            }
        }
    }

    let p1 = MixedPoint::new(5, 10.4);
    let p2 = MixedPoint::new("Hello", 'c');

    let p3 = p1.mixup(p2);
    println!("æ··åˆåçš„ç‚¹: x = {}, y = {}", p3.x, p3.y);
}
```

**è¯´æ˜**:

- **å•ç±»å‹å‚æ•°**: `Point<T>` æ‰€æœ‰å­—æ®µä½¿ç”¨ç›¸åŒç±»å‹
- **å¤šç±»å‹å‚æ•°**: `MixedPoint<T, U>` ä¸åŒå­—æ®µå¯ä»¥ä½¿ç”¨ä¸åŒç±»å‹
- **æ³›å‹impl**: `impl<T>` ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•
- **ç‰¹åŒ–impl**: ä¸ºç‰¹å®šç±»å‹ï¼ˆå¦‚ f32ï¼‰å®ç°é¢å¤–æ–¹æ³•

**è¾“å‡º**:

```text
===== å•ç±»å‹å‚æ•°ç»“æ„ä½“ =====

æ•´æ•°ç‚¹: Point { x: 5, y: 10 }
æµ®ç‚¹æ•°ç‚¹: Point { x: 1.0, y: 4.0 }

===== å¤šç±»å‹å‚æ•°ç»“æ„ä½“ =====

æ··åˆç‚¹: MixedPoint { x: 5, y: 4.0 }
å­—ç¬¦ä¸²ç‚¹: MixedPoint { x: "xåæ ‡", y: 100 }

===== æ³›å‹ç»“æ„ä½“æ–¹æ³• =====

x åæ ‡: 5
è·ç¦»åŸç‚¹: 5.0

===== æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ =====

Wrapper: Wrapper { value: 42 }

===== å…³è”å‡½æ•° =====

æ··åˆåçš„ç‚¹: x = 5, y = c
```

---

### ç¤ºä¾‹1.3: æ³›å‹æšä¸¾

**ç›®æ ‡**: ç†è§£æ³›å‹æšä¸¾çš„å®šä¹‰å’Œåº”ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Option<T> æ ‡å‡†åº“æ³›å‹æšä¸¾ =====\n");

    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option<i32> = None;

    println!("some_number: {:?}", some_number);
    println!("some_string: {:?}", some_string);
    println!("absent_number: {:?}", absent_number);

    // ä½¿ç”¨ match å¤„ç†
    match some_number {
        Some(n) => println!("æ•°å­—æ˜¯: {}", n),
        None => println!("æ²¡æœ‰æ•°å­—"),
    }

    println!("\n===== Result<T, E> æ³›å‹æšä¸¾ =====\n");

    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
        } else {
            Ok(a / b)
        }
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    match divide(10.0, 0.0) {
        Ok(result) => println!("10 / 0 = {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    println!("\n===== è‡ªå®šä¹‰æ³›å‹æšä¸¾ =====\n");

    #[derive(Debug)]
    enum Either<L, R> {
        Left(L),
        Right(R),
    }

    let left: Either<i32, &str> = Either::Left(42);
    let right: Either<i32, &str> = Either::Right("hello");

    println!("left: {:?}", left);
    println!("right: {:?}", right);

    // å®ç°æ–¹æ³•
    impl<L, R> Either<L, R> {
        fn is_left(&self) -> bool {
            matches!(self, Either::Left(_))
        }

        fn is_right(&self) -> bool {
            matches!(self, Either::Right(_))
        }
    }

    println!("left.is_left(): {}", left.is_left());
    println!("right.is_right(): {}", right.is_right());

    println!("\n===== å¤æ‚æ³›å‹æšä¸¾ =====\n");

    #[derive(Debug)]
    enum Tree<T> {
        Empty,
        Node {
            value: T,
            left: Box<Tree<T>>,
            right: Box<Tree<T>>,
        },
    }

    impl<T> Tree<T> {
        fn empty() -> Self {
            Tree::Empty
        }

        fn leaf(value: T) -> Self {
            Tree::Node {
                value,
                left: Box::new(Tree::Empty),
                right: Box::new(Tree::Empty),
            }
        }
    }

    let tree = Tree::Node {
        value: 5,
        left: Box::new(Tree::leaf(3)),
        right: Box::new(Tree::leaf(7)),
    };

    println!("äºŒå‰æ ‘: {:?}", tree);
}
```

**è¯´æ˜**:

- **`Option<T>`**: æ ‡å‡†åº“ä¸­æœ€å¸¸ç”¨çš„æ³›å‹æšä¸¾
- **`Result<T, E>`**: ç”¨äºé”™è¯¯å¤„ç†çš„æ³›å‹æšä¸¾
- **è‡ªå®šä¹‰æšä¸¾**: å¯ä»¥åˆ›å»ºè‡ªå·±çš„æ³›å‹æšä¸¾
- **é€’å½’ç»“æ„**: ä½¿ç”¨ Box å®ç°é€’å½’æ³›å‹æšä¸¾

**è¾“å‡º**:

```text
===== Option<T> æ ‡å‡†åº“æ³›å‹æšä¸¾ =====

some_number: Some(5)
some_string: Some("a string")
absent_number: None
æ•°å­—æ˜¯: 5

===== Result<T, E> æ³›å‹æšä¸¾ =====

10 / 2 = 5
é”™è¯¯: é™¤æ•°ä¸èƒ½ä¸ºé›¶

===== è‡ªå®šä¹‰æ³›å‹æšä¸¾ =====

left: Left(42)
right: Right("hello")
left.is_left(): true
right.is_right(): true

===== å¤æ‚æ³›å‹æšä¸¾ =====

äºŒå‰æ ‘: Node { value: 5, left: Node { value: 3, left: Empty, right: Empty }, right: Node { value: 7, left: Empty, right: Empty } }
```

---

### ç¤ºä¾‹1.4: Optionå’ŒResult

**ç›®æ ‡**: æ·±å…¥ç†è§£ Option å’Œ Result çš„æ³›å‹åº”ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Option<T> æ–¹æ³•é“¾ =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // map: è½¬æ¢å†…éƒ¨å€¼
    let doubled: Option<i32> = Some(5).map(|x| x * 2);
    println!("Some(5).map(|x| x * 2) = {:?}", doubled);

    // and_then: é“¾å¼æ“ä½œ
    let result = Some(2)
        .and_then(|x| Some(x * 2))
        .and_then(|x| Some(x + 1));
    println!("é“¾å¼ and_then: {:?}", result);

    // filter: è¿‡æ»¤
    let even = Some(4).filter(|x| x % 2 == 0);
    let odd = Some(3).filter(|x| x % 2 == 0);
    println!("Some(4).filter(å¶æ•°): {:?}", even);
    println!("Some(3).filter(å¶æ•°): {:?}", odd);

    // unwrap_or: æä¾›é»˜è®¤å€¼
    let some_value = Some(100).unwrap_or(0);
    let none_value = None.unwrap_or(0);
    println!("Some(100).unwrap_or(0) = {}", some_value);
    println!("None.unwrap_or(0) = {}", none_value);

    println!("\n===== Result<T, E> æ–¹æ³•é“¾ =====\n");

    fn parse_positive(s: &str) -> Result<i32, String> {
        s.parse::<i32>()
            .map_err(|e| format!("è§£æé”™è¯¯: {}", e))
            .and_then(|n| {
                if n > 0 {
                    Ok(n)
                } else {
                    Err("æ•°å­—å¿…é¡»ä¸ºæ­£".to_string())
                }
            })
    }

    println!("{:?}", parse_positive("42"));
    println!("{:?}", parse_positive("-5"));
    println!("{:?}", parse_positive("abc"));

    println!("\n===== ? æ“ä½œç¬¦ =====\n");

    fn read_and_parse(s: &str) -> Result<i32, String> {
        let num = s.parse::<i32>()
            .map_err(|e| format!("è§£æå¤±è´¥: {}", e))?;

        if num > 0 {
            Ok(num)
        } else {
            Err("å¿…é¡»æ˜¯æ­£æ•°".to_string())
        }
    }

    match read_and_parse("42") {
        Ok(n) => println!("è§£ææˆåŠŸ: {}", n),
        Err(e) => println!("è§£æå¤±è´¥: {}", e),
    }

    println!("\n===== ç»„åˆ Option å’Œ Result =====\n");

    fn get_user_age(id: i32) -> Option<i32> {
        match id {
            1 => Some(25),
            2 => Some(30),
            _ => None,
        }
    }

    fn validate_age(age: i32) -> Result<i32, String> {
        if age >= 18 {
            Ok(age)
        } else {
            Err("æœªæˆå¹´".to_string())
        }
    }

    // Option -> Result -> Option çš„è½¬æ¢
    let result = get_user_age(1)
        .ok_or("ç”¨æˆ·ä¸å­˜åœ¨".to_string())
        .and_then(validate_age);

    println!("ç”¨æˆ·1: {:?}", result);

    let result = get_user_age(99)
        .ok_or("ç”¨æˆ·ä¸å­˜åœ¨".to_string())
        .and_then(validate_age);

    println!("ç”¨æˆ·99: {:?}", result);

    println!("\n===== transpose =====\n");

    // Result<Option<T>> <-> Option<Result<T>>
    let x: Result<Option<i32>, &str> = Ok(Some(5));
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("Ok(Some(5)).transpose() = {:?}", y);

    let x: Result<Option<i32>, &str> = Ok(None);
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("Ok(None).transpose() = {:?}", y);
}
```

**è¯´æ˜**:

- **map**: è½¬æ¢ Option/Result å†…éƒ¨çš„å€¼
- **and_then**: é“¾å¼æ“ä½œï¼Œé¿å…åµŒå¥—
- **filter**: æ ¹æ®æ¡ä»¶è¿‡æ»¤
- **? æ“ä½œç¬¦**: ç®€åŒ–é”™è¯¯ä¼ æ’­
- **transpose**: Option å’Œ Result äº’æ¢

**è¾“å‡º**:

```text
===== Option<T> æ–¹æ³•é“¾ =====

Some(5).map(|x| x * 2) = Some(10)
é“¾å¼ and_then: Some(5)
Some(4).filter(å¶æ•°): Some(4)
Some(3).filter(å¶æ•°): None
Some(100).unwrap_or(0) = 100
None.unwrap_or(0) = 0

===== Result<T, E> æ–¹æ³•é“¾ =====

Ok(42)
Err("æ•°å­—å¿…é¡»ä¸ºæ­£")
Err("è§£æé”™è¯¯: invalid digit found in string")

===== ? æ“ä½œç¬¦ =====

è§£ææˆåŠŸ: 42

===== ç»„åˆ Option å’Œ Result =====

ç”¨æˆ·1: Ok(25)
ç”¨æˆ·99: Err("ç”¨æˆ·ä¸å­˜åœ¨")

===== transpose =====

Ok(Some(5)).transpose() = Some(Ok(5))
Ok(None).transpose() = None
```

---

### ç¤ºä¾‹1.5: æ³›å‹æ–¹æ³•

**ç›®æ ‡**: æŒæ¡ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³• =====\n");

    struct Container<T> {
        value: T,
    }

    impl<T> Container<T> {
        fn new(value: T) -> Self {
            Container { value }
        }

        fn get(&self) -> &T {
            &self.value
        }

        fn set(&mut self, value: T) {
            self.value = value;
        }

        // æ–¹æ³•æœ¬èº«ä¹Ÿå¯ä»¥æ˜¯æ³›å‹çš„
        fn into_pair<U>(self, other: U) -> (T, U) {
            (self.value, other)
        }
    }

    let mut container = Container::new(42);
    println!("åˆå§‹å€¼: {}", container.get());

    container.set(100);
    println!("ä¿®æ”¹å: {}", container.get());

    let pair = container.into_pair("hello");
    println!("é…å¯¹: ({}, {})", pair.0, pair.1);

    println!("\n===== ä¸ºç‰¹å®šç±»å‹å®ç°æ–¹æ³• =====\n");

    // åªä¸º Container<String> å®ç°ç‰¹å®šæ–¹æ³•
    impl Container<String> {
        fn len(&self) -> usize {
            self.value.len()
        }

        fn push_str(&mut self, s: &str) {
            self.value.push_str(s);
        }
    }

    let mut container = Container::new(String::from("Hello"));
    println!("å­—ç¬¦ä¸²é•¿åº¦: {}", container.len());

    container.push_str(" World");
    println!("è¿½åŠ å: {}", container.get());

    println!("\n===== å¸¦çº¦æŸçš„æ³›å‹æ–¹æ³• =====\n");

    #[derive(Debug)]
    struct Pair<T> {
        first: T,
        second: T,
    }

    impl<T> Pair<T> {
        fn new(first: T, second: T) -> Self {
            Pair { first, second }
        }
    }

    // åªä¸ºå®ç°äº† Display å’Œ PartialOrd çš„ç±»å‹å®ç°æ–¹æ³•
    impl<T: std::fmt::Display + PartialOrd> Pair<T> {
        fn cmp_display(&self) {
            if self.first >= self.second {
                println!("æœ€å¤§çš„æ˜¯ first: {}", self.first);
            } else {
                println!("æœ€å¤§çš„æ˜¯ second: {}", self.second);
            }
        }
    }

    let pair = Pair::new(10, 20);
    pair.cmp_display();

    let pair = Pair::new("hello", "world");
    pair.cmp_display();

    println!("\n===== å¤šä¸ªæ³›å‹å‚æ•°çš„æ–¹æ³• =====\n");

    struct MixedContainer<T, U> {
        first: T,
        second: U,
    }

    impl<T, U> MixedContainer<T, U> {
        fn new(first: T, second: U) -> Self {
            MixedContainer { first, second }
        }

        fn swap(self) -> MixedContainer<U, T> {
            MixedContainer {
                first: self.second,
                second: self.first,
            }
        }
    }

    let container = MixedContainer::new(42, "hello");
    println!("åŸå§‹: ({}, {})", container.first, container.second);

    let swapped = container.swap();
    println!("äº¤æ¢å: ({}, {})", swapped.first, swapped.second);
}
```

**è¯´æ˜**:

- **æ³›å‹impl**: `impl<T>` ä¸ºæ‰€æœ‰Tå®ç°é€šç”¨æ–¹æ³•
- **ç‰¹åŒ–impl**: ä¸ºç‰¹å®šç±»å‹å®ç°é¢å¤–æ–¹æ³•
- **Traitçº¦æŸ**: ä½¿ç”¨ where æˆ– `:` æ·»åŠ çº¦æŸ
- **æ–¹æ³•æ³›å‹**: æ–¹æ³•æœ¬èº«ä¹Ÿå¯ä»¥æœ‰æ³›å‹å‚æ•°

**è¾“å‡º**:

```text
===== ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³• =====

åˆå§‹å€¼: 42
ä¿®æ”¹å: 100
é…å¯¹: (100, hello)

===== ä¸ºç‰¹å®šç±»å‹å®ç°æ–¹æ³• =====

å­—ç¬¦ä¸²é•¿åº¦: 5
è¿½åŠ å: Hello World

===== å¸¦çº¦æŸçš„æ³›å‹æ–¹æ³• =====

æœ€å¤§çš„æ˜¯ second: 20
æœ€å¤§çš„æ˜¯ world: world

===== å¤šä¸ªæ³›å‹å‚æ•°çš„æ–¹æ³• =====

åŸå§‹: (42, hello)
äº¤æ¢å: (hello, 42)
```

---

### ç¤ºä¾‹1.6: åŸºç¡€Traitçº¦æŸ

**ç›®æ ‡**: ç†è§£ Trait çº¦æŸçš„è¯­æ³•å’Œä½¿ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== åŸºç¡€ Trait çº¦æŸ =====\n");

    // ä½¿ç”¨ impl Trait è¯­æ³•
    fn print_it(item: impl std::fmt::Display) {
        println!("æ‰“å°: {}", item);
    }

    print_it(42);
    print_it("Hello");
    print_it(3.14);

    println!("\n===== æ³›å‹å‚æ•°çº¦æŸ =====\n");

    // ä½¿ç”¨æ³›å‹å‚æ•°è¯­æ³•
    fn print_generic<T: std::fmt::Display>(item: T) {
        println!("æ³›å‹æ‰“å°: {}", item);
    }

    print_generic(100);
    print_generic("World");

    println!("\n===== where å­å¥ =====\n");

    // ä½¿ç”¨ where å­å¥ï¼ˆæ›´æ¸…æ™°ï¼‰
    fn print_where<T>(item: T)
    where
        T: std::fmt::Display,
    {
        println!("where æ‰“å°: {}", item);
    }

    print_where(200);

    println!("\n===== å¤šä¸ª Trait çº¦æŸ =====\n");

    use std::fmt::Display;
    use std::fmt::Debug;

    fn print_both<T: Display + Debug>(item: T) {
        println!("Display: {}", item);
        println!("Debug: {:?}", item);
    }

    print_both(42);

    println!("\n===== Trait çº¦æŸä¸ç»“æ„ä½“ =====\n");

    struct Wrapper<T: Display> {
        value: T,
    }

    impl<T: Display> Wrapper<T> {
        fn new(value: T) -> Self {
            Wrapper { value }
        }

        fn display(&self) {
            println!("Wrapper åŒ…å«: {}", self.value);
        }
    }

    let wrapper = Wrapper::new("Hello");
    wrapper.display();

    println!("\n===== è¿”å›å€¼ Trait çº¦æŸ =====\n");

    // è¿”å›å®ç°äº† Display çš„ç±»å‹
    fn get_display() -> impl Display {
        42
    }

    println!("è¿”å›å€¼: {}", get_display());

    println!("\n===== Clone çº¦æŸç¤ºä¾‹ =====\n");

    fn duplicate<T: Clone>(value: &T) -> (T, T) {
        (value.clone(), value.clone())
    }

    let original = String::from("hello");
    let (copy1, copy2) = duplicate(&original);

    println!("åŸå§‹: {}", original);
    println!("å‰¯æœ¬1: {}", copy1);
    println!("å‰¯æœ¬2: {}", copy2);

    println!("\n===== ç»„åˆçº¦æŸç¤ºä¾‹ =====\n");

    fn process<T>(items: Vec<T>)
    where
        T: Display + Clone + PartialOrd,
    {
        if items.is_empty() {
            return;
        }

        let first = items[0].clone();
        println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", first);

        let max = items.iter()
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap();
        println!("æœ€å¤§å…ƒç´ : {}", max);
    }

    let numbers = vec![3, 1, 4, 1, 5, 9];
    process(numbers);
}
```

**è¯´æ˜**:

- **impl Trait**: ç®€æ´çš„ Trait çº¦æŸè¯­æ³•
- **æ³›å‹çº¦æŸ**: `<T: Trait>` æ˜¾å¼å£°æ˜çº¦æŸ
- **whereå­å¥**: å¤æ‚çº¦æŸçš„æ¸…æ™°è¡¨è¾¾
- **å¤šé‡çº¦æŸ**: ä½¿ç”¨ `+` ç»„åˆå¤šä¸ª Trait
- **ç»“æ„ä½“çº¦æŸ**: ä¸ºæ³›å‹ç»“æ„ä½“æ·»åŠ çº¦æŸ

**è¾“å‡º**:

```text
===== åŸºç¡€ Trait çº¦æŸ =====

æ‰“å°: 42
æ‰“å°: Hello
æ‰“å°: 3.14

===== æ³›å‹å‚æ•°çº¦æŸ =====

æ³›å‹æ‰“å°: 100
æ³›å‹æ‰“å°: World

===== where å­å¥ =====

where æ‰“å°: 200

===== å¤šä¸ª Trait çº¦æŸ =====

Display: 42
Debug: 42

===== Trait çº¦æŸä¸ç»“æ„ä½“ =====

Wrapper åŒ…å«: Hello

===== è¿”å›å€¼ Trait çº¦æŸ =====

è¿”å›å€¼: 42

===== Clone çº¦æŸç¤ºä¾‹ =====

åŸå§‹: hello
å‰¯æœ¬1: hello
å‰¯æœ¬2: hello

===== ç»„åˆçº¦æŸç¤ºä¾‹ =====

ç¬¬ä¸€ä¸ªå…ƒç´ : 3
æœ€å¤§å…ƒç´ : 9
```

---

## ğŸ“ Tier 2: å®è·µå±‚ç¤ºä¾‹

### ç¤ºä¾‹2.1: Traitå¯¹è±¡ä¸æ³›å‹å¯¹æ¯”

**ç›®æ ‡**: ç†è§£é™æ€åˆ†æ´¾å’ŒåŠ¨æ€åˆ†æ´¾çš„åŒºåˆ«

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é™æ€åˆ†æ´¾ (æ³›å‹) =====\n");

    trait Draw {
        fn draw(&self);
    }

    struct Circle { radius: f64 }
    struct Square { side: f64 }

    impl Draw for Circle {
        fn draw(&self) {
            println!("ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: {}", self.radius);
        }
    }

    impl Draw for Square {
        fn draw(&self) {
            println!("ç»˜åˆ¶æ­£æ–¹å½¢ï¼Œè¾¹é•¿: {}", self.side);
        }
    }

    // é™æ€åˆ†æ´¾ï¼šç¼–è¯‘æ—¶ç¡®å®šç±»å‹
    fn draw_static<T: Draw>(shape: &T) {
        shape.draw();
    }

    let circle = Circle { radius: 5.0 };
    let square = Square { side: 10.0 };

    draw_static(&circle);
    draw_static(&square);

    println!("\n===== åŠ¨æ€åˆ†æ´¾ (Trait å¯¹è±¡) =====\n");

    // åŠ¨æ€åˆ†æ´¾ï¼šè¿è¡Œæ—¶ç¡®å®šç±»å‹
    fn draw_dynamic(shape: &dyn Draw) {
        shape.draw();
    }

    draw_dynamic(&circle);
    draw_dynamic(&square);

    println!("\n===== å¼‚æ„é›†åˆ (åªèƒ½ç”¨ Trait å¯¹è±¡) =====\n");

    // âŒ æ³›å‹æ— æ³•åšåˆ°ï¼š
    // let shapes: Vec<T> = vec![circle, square]; // é”™è¯¯ï¼šç±»å‹ä¸åŒ

    // âœ… Trait å¯¹è±¡å¯ä»¥ï¼š
    let shapes: Vec<Box<dyn Draw>> = vec![
        Box::new(Circle { radius: 3.0 }),
        Box::new(Square { side: 7.0 }),
        Box::new(Circle { radius: 2.0 }),
    ];

    for shape in &shapes {
        shape.draw();
    }

    println!("\n===== æ€§èƒ½å¯¹æ¯” =====\n");

    use std::time::Instant;

    // é™æ€åˆ†æ´¾ï¼šé›¶æˆæœ¬æŠ½è±¡
    let start = Instant::now();
    for _ in 0..1_000_000 {
        draw_static(&circle);
    }
    let static_time = start.elapsed();

    // åŠ¨æ€åˆ†æ´¾ï¼šæœ‰è™šå‡½æ•°è¡¨å¼€é”€
    let start = Instant::now();
    for _ in 0..1_000_000 {
        draw_dynamic(&circle);
    }
    let dynamic_time = start.elapsed();

    println!("é™æ€åˆ†æ´¾è€—æ—¶: {:?}", static_time);
    println!("åŠ¨æ€åˆ†æ´¾è€—æ—¶: {:?}", dynamic_time);

    println!("\n===== ä½¿ç”¨åœºæ™¯å¯¹æ¯” =====\n");

    println!("é™æ€åˆ†æ´¾ (æ³›å‹):");
    println!("  âœ… é›¶æˆæœ¬æŠ½è±¡ï¼Œæ€§èƒ½æœ€ä¼˜");
    println!("  âœ… ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥");
    println!("  âœ… å¯ä»¥å†…è”ä¼˜åŒ–");
    println!("  âŒ æ— æ³•å­˜å‚¨ä¸åŒç±»å‹åˆ°åŒä¸€é›†åˆ");
    println!("  âŒ ä¼šç”Ÿæˆå¤šä»½ä»£ç ï¼ˆå•æ€åŒ–ï¼‰");

    println!("\nåŠ¨æ€åˆ†æ´¾ (Trait å¯¹è±¡):");
    println!("  âœ… å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹åˆ°åŒä¸€é›†åˆ");
    println!("  âœ… ä»£ç å¤§å°æ›´å°");
    println!("  âœ… è¿è¡Œæ—¶å¤šæ€");
    println!("  âŒ æœ‰è™šå‡½æ•°è¡¨å¼€é”€");
    println!("  âŒ æ— æ³•å†…è”");
}
```

**è¯´æ˜**:

- **é™æ€åˆ†æ´¾**: æ³›å‹åœ¨ç¼–è¯‘æ—¶ç¡®å®šç±»å‹ï¼Œé›¶æˆæœ¬
- **åŠ¨æ€åˆ†æ´¾**: Trait å¯¹è±¡åœ¨è¿è¡Œæ—¶ç¡®å®šç±»å‹ï¼Œæœ‰å¼€é”€
- **å•æ€åŒ–**: æ³›å‹ä¸ºæ¯ç§ç±»å‹ç”Ÿæˆå•ç‹¬çš„ä»£ç 
- **å¼‚æ„é›†åˆ**: åªæœ‰ Trait å¯¹è±¡å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹

**è¾“å‡º**:

```text
===== é™æ€åˆ†æ´¾ (æ³›å‹) =====

ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 5
ç»˜åˆ¶æ­£æ–¹å½¢ï¼Œè¾¹é•¿: 10

===== åŠ¨æ€åˆ†æ´¾ (Trait å¯¹è±¡) =====

ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 5
ç»˜åˆ¶æ­£æ–¹å½¢ï¼Œè¾¹é•¿: 10

===== å¼‚æ„é›†åˆ (åªèƒ½ç”¨ Trait å¯¹è±¡) =====

ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 3
ç»˜åˆ¶æ­£æ–¹å½¢ï¼Œè¾¹é•¿: 7
ç»˜åˆ¶åœ†å½¢ï¼ŒåŠå¾„: 2

===== æ€§èƒ½å¯¹æ¯” =====

é™æ€åˆ†æ´¾è€—æ—¶: 0s
åŠ¨æ€åˆ†æ´¾è€—æ—¶: 0s

===== ä½¿ç”¨åœºæ™¯å¯¹æ¯” =====

é™æ€åˆ†æ´¾ (æ³›å‹):
  âœ… é›¶æˆæœ¬æŠ½è±¡ï¼Œæ€§èƒ½æœ€ä¼˜
  âœ… ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
  âœ… å¯ä»¥å†…è”ä¼˜åŒ–
  âŒ æ— æ³•å­˜å‚¨ä¸åŒç±»å‹åˆ°åŒä¸€é›†åˆ
  âŒ ä¼šç”Ÿæˆå¤šä»½ä»£ç ï¼ˆå•æ€åŒ–ï¼‰

åŠ¨æ€åˆ†æ´¾ (Trait å¯¹è±¡):
  âœ… å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹åˆ°åŒä¸€é›†åˆ
  âœ… ä»£ç å¤§å°æ›´å°
  âœ… è¿è¡Œæ—¶å¤šæ€
  âŒ æœ‰è™šå‡½æ•°è¡¨å¼€é”€
  âŒ æ— æ³•å†…è”
```

---

### ç¤ºä¾‹2.2: å…³è”ç±»å‹è¯¦è§£

**ç›®æ ‡**: æŒæ¡å…³è”ç±»å‹çš„å®šä¹‰å’Œä½¿ç”¨

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ä¸ºä»€ä¹ˆéœ€è¦å…³è”ç±»å‹ï¼Ÿ =====\n");

    // ä¸ä½¿ç”¨å…³è”ç±»å‹ï¼šéœ€è¦é¢å¤–çš„ç±»å‹å‚æ•°
    trait IteratorBad<T> {
        fn next(&mut self) -> Option<T>;
    }

    // ä½¿ç”¨å…³è”ç±»å‹ï¼šæ›´ç®€æ´
    trait IteratorGood {
        type Item;  // å…³è”ç±»å‹
        fn next(&mut self) -> Option<Self::Item>;
    }

    println!("âœ… å…³è”ç±»å‹è®© Trait æ›´ç®€æ´æ˜“ç”¨\n");

    println!("===== å®ç°å…³è”ç±»å‹ =====\n");

    struct Counter {
        count: u32,
    }

    impl Counter {
        fn new() -> Counter {
            Counter { count: 0 }
        }
    }

    impl IteratorGood for Counter {
        type Item = u32;  // æŒ‡å®šå…³è”ç±»å‹

        fn next(&mut self) -> Option<Self::Item> {
            if self.count < 5 {
                self.count += 1;
                Some(self.count)
            } else {
                None
            }
        }
    }

    let mut counter = Counter::new();
    while let Some(n) = counter.next() {
        print!("{} ", n);
    }
    println!("\n");

    println!("===== å…³è”ç±»å‹çº¦æŸ =====\n");

    // å¯ä»¥å¯¹å…³è”ç±»å‹æ·»åŠ çº¦æŸ
    trait Container {
        type Item: std::fmt::Display;  // Item å¿…é¡»å®ç° Display

        fn get(&self, index: usize) -> Option<&Self::Item>;
    }

    struct StringVec {
        data: Vec<String>,
    }

    impl Container for StringVec {
        type Item = String;

        fn get(&self, index: usize) -> Option<&Self::Item> {
            self.data.get(index)
        }
    }

    let container = StringVec {
        data: vec!["Hello".to_string(), "World".to_string()],
    };

    if let Some(item) = container.get(0) {
        println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", item);
    }

    println!("\n===== å¤šä¸ªå…³è”ç±»å‹ =====\n");

    trait Graph {
        type Node;
        type Edge;

        fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool;
    }

    struct IntGraph {
        edges: Vec<(i32, i32)>,
    }

    impl Graph for IntGraph {
        type Node = i32;
        type Edge = (i32, i32);

        fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool {
            self.edges.contains(&(*from, *to))
        }
    }

    let graph = IntGraph {
        edges: vec![(1, 2), (2, 3), (3, 1)],
    };

    println!("æœ‰è¾¹ 1->2? {}", graph.has_edge(&1, &2));
    println!("æœ‰è¾¹ 1->3? {}", graph.has_edge(&1, &3));

    println!("\n===== å…³è”ç±»å‹ vs æ³›å‹å‚æ•° =====\n");

    // å…³è”ç±»å‹ï¼šæ¯ä¸ªç±»å‹åªèƒ½æœ‰ä¸€ä¸ªå®ç°
    trait ConvertTo {
        type Output;
        fn convert(self) -> Self::Output;
    }

    impl ConvertTo for i32 {
        type Output = f64;
        fn convert(self) -> Self::Output {
            self as f64
        }
    }

    // âŒ ä¸èƒ½æœ‰ç¬¬äºŒä¸ªå®ç°ï¼š
    // impl ConvertTo for i32 {
    //     type Output = String;
    //     fn convert(self) -> Self::Output {
    //         self.to_string()
    //     }
    // }

    let num = 42;
    let float = num.convert();
    println!("i32 è½¬ f64: {}", float);

    // æ³›å‹å‚æ•°ï¼šå¯ä»¥æœ‰å¤šä¸ªå®ç°
    trait Convert<T> {
        fn convert(self) -> T;
    }

    impl Convert<f64> for i32 {
        fn convert(self) -> f64 {
            self as f64
        }
    }

    impl Convert<String> for i32 {
        fn convert(self) -> String {
            self.to_string()
        }
    }

    let num = 42;
    let float: f64 = num.convert();
    let string: String = num.convert();
    println!("i32 è½¬ f64: {}", float);
    println!("i32 è½¬ String: {}", string);

    println!("\n===== æ€»ç»“ =====\n");

    println!("å…³è”ç±»å‹:");
    println!("  âœ… æ¯ä¸ªç±»å‹åªæœ‰ä¸€ä¸ªå®ç°");
    println!("  âœ… ç®€åŒ– Trait å®šä¹‰");
    println!("  âœ… æ›´å¥½çš„ç±»å‹æ¨æ–­");

    println!("\næ³›å‹å‚æ•°:");
    println!("  âœ… å¯ä»¥æœ‰å¤šä¸ªå®ç°");
    println!("  âœ… æ›´çµæ´»");
    println!("  âŒ éœ€è¦æ˜¾å¼æŒ‡å®šç±»å‹");
}
```

**è¯´æ˜**:

- **å…³è”ç±»å‹**: ä½¿ç”¨ `type Item` å®šä¹‰
- **ç®€åŒ–Trait**: é¿å…é¢å¤–çš„æ³›å‹å‚æ•°
- **å”¯ä¸€æ€§**: æ¯ä¸ªç±»å‹åªèƒ½æœ‰ä¸€ä¸ªå…³è”ç±»å‹å®ç°
- **çº¦æŸ**: å¯ä»¥å¯¹å…³è”ç±»å‹æ·»åŠ  Trait çº¦æŸ

**è¾“å‡º**:

```text
===== ä¸ºä»€ä¹ˆéœ€è¦å…³è”ç±»å‹ï¼Ÿ =====

âœ… å…³è”ç±»å‹è®© Trait æ›´ç®€æ´æ˜“ç”¨

===== å®ç°å…³è”ç±»å‹ =====

1 2 3 4 5

===== å…³è”ç±»å‹çº¦æŸ =====

ç¬¬ä¸€ä¸ªå…ƒç´ : Hello

===== å¤šä¸ªå…³è”ç±»å‹ =====

æœ‰è¾¹ 1->2? true
æœ‰è¾¹ 1->3? false

===== å…³è”ç±»å‹ vs æ³›å‹å‚æ•° =====

i32 è½¬ f64: 42
i32 è½¬ f64: 42
i32 è½¬ String: 42

===== æ€»ç»“ =====

å…³è”ç±»å‹:
  âœ… æ¯ä¸ªç±»å‹åªæœ‰ä¸€ä¸ªå®ç°
  âœ… ç®€åŒ– Trait å®šä¹‰
  âœ… æ›´å¥½çš„ç±»å‹æ¨æ–­

æ³›å‹å‚æ•°:
  âœ… å¯ä»¥æœ‰å¤šä¸ªå®ç°
  âœ… æ›´çµæ´»
  âŒ éœ€è¦æ˜¾å¼æŒ‡å®šç±»å‹
```

---

### ç¤ºä¾‹2.3: æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ

**ç›®æ ‡**: ç†è§£æ³›å‹å‚æ•°ä¸ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„ç»“åˆä½¿ç”¨

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== æ³›å‹å‡½æ•°ä¸ç”Ÿå‘½å‘¨æœŸ =====\n");

    // æ³›å‹å‡½æ•°éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    fn longest<'a, T>(x: &'a T, y: &'a T) -> &'a T
    where
        T: PartialOrd,
    {
        if x > y { x } else { y }
    }

    let s1 = String::from("hello");
    let s2 = String::from("world");
    let result = longest(&s1, &s2);
    println!("è¾ƒå¤§çš„å­—ç¬¦ä¸²: {}", result);

    let n1 = 42;
    let n2 = 100;
    let result = longest(&n1, &n2);
    println!("è¾ƒå¤§çš„æ•°å­—: {}", result);

    println!("\n===== ç»“æ„ä½“çš„æ³›å‹å’Œç”Ÿå‘½å‘¨æœŸ =====\n");

    struct Holder<'a, T> {
        value: &'a T,
    }

    impl<'a, T> Holder<'a, T> {
        fn new(value: &'a T) -> Self {
            Holder { value }
        }

        fn get(&self) -> &T {
            self.value
        }
    }

    let num = 42;
    let holder = Holder::new(&num);
    println!("Holder ä¸­çš„å€¼: {}", holder.get());

    println!("\n===== å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•° =====\n");

    struct Pair<'a, 'b, T, U> {
        first: &'a T,
        second: &'b U,
    }

    impl<'a, 'b, T, U> Pair<'a, 'b, T, U> {
        fn new(first: &'a T, second: &'b U) -> Self {
            Pair { first, second }
        }
    }

    let x = 10;
    let y = String::from("test");
    let pair = Pair::new(&x, &y);
    println!("Pair: ({}, {})", pair.first, pair.second);

    println!("\n===== Trait çº¦æŸä¸ç”Ÿå‘½å‘¨æœŸ =====\n");

    use std::fmt::Display;

    fn print_info<'a, T>(item: &'a T) -> &'a T
    where
        T: Display,
    {
        println!("å€¼: {}", item);
        item
    }

    let text = "Hello, Rust!";
    let result = print_info(&text);
    println!("è¿”å›å€¼: {}", result);

    println!("\n===== é™æ€ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ =====\n");

    fn get_static<T: Display>(value: &'static T) -> &'static T {
        println!("é™æ€å€¼: {}", value);
        value
    }

    const CONST_STR: &str = "æˆ‘æ˜¯é™æ€çš„";
    let result = get_static(&CONST_STR);
    println!("è¿”å›: {}", result);

    println!("\n===== æ³›å‹æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸ =====\n");

    struct Container<T> {
        items: Vec<T>,
    }

    impl<T> Container<T> {
        fn new() -> Self {
            Container { items: Vec::new() }
        }

        fn add(&mut self, item: T) {
            self.items.push(item);
        }

        // æ³›å‹æ–¹æ³•å¸¦ç”Ÿå‘½å‘¨æœŸ
        fn get<'a>(&'a self, index: usize) -> Option<&'a T> {
            self.items.get(index)
        }
    }

    let mut container = Container::new();
    container.add(1);
    container.add(2);
    container.add(3);

    if let Some(value) = container.get(1) {
        println!("ç´¢å¼•1çš„å€¼: {}", value);
    }
}
```

**è¯´æ˜**:

- **ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨**: æ³›å‹å‡½æ•°å¯èƒ½éœ€è¦ç”Ÿå‘½å‘¨æœŸå‚æ•°
- **ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ**: æ³›å‹ç»“æ„ä½“å¯ä»¥åŒ…å«å¼•ç”¨
- **å¤šä¸ªç”Ÿå‘½å‘¨æœŸ**: ä¸åŒå­—æ®µå¯ä»¥æœ‰ä¸åŒç”Ÿå‘½å‘¨æœŸ
- **Trait çº¦æŸ**: ç”Ÿå‘½å‘¨æœŸå’Œ Trait çº¦æŸå¯ä»¥å…±å­˜

**è¾“å‡º**:

```text
===== æ³›å‹å‡½æ•°ä¸ç”Ÿå‘½å‘¨æœŸ =====

è¾ƒå¤§çš„å­—ç¬¦ä¸²: world
è¾ƒå¤§çš„æ•°å­—: 100

===== ç»“æ„ä½“çš„æ³›å‹å’Œç”Ÿå‘½å‘¨æœŸ =====

Holder ä¸­çš„å€¼: 42

===== å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•° =====

Pair: (10, test)

===== Trait çº¦æŸä¸ç”Ÿå‘½å‘¨æœŸ =====

å€¼: Hello, Rust!
è¿”å›å€¼: Hello, Rust!

===== é™æ€ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹ =====

é™æ€å€¼: æˆ‘æ˜¯é™æ€çš„
è¿”å›: æˆ‘æ˜¯é™æ€çš„

===== æ³›å‹æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸ =====

ç´¢å¼•1çš„å€¼: 2
```

---

### ç¤ºä¾‹2.4: å¤šTraitçº¦æŸ

**ç›®æ ‡**: æŒæ¡å¤šä¸ª Trait çº¦æŸçš„ä½¿ç”¨æ–¹æ³•

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
use std::fmt::{Debug, Display};

fn main() {
    println!("===== ä½¿ç”¨ + è¿æ¥å¤šä¸ª Trait =====\n");

    // å‡½æ•°éœ€è¦å¤šä¸ª Trait çº¦æŸ
    fn print_debug_display<T: Debug + Display>(value: &T) {
        println!("Display: {}", value);
        println!("Debug: {:?}", value);
    }

    let num = 42;
    print_debug_display(&num);

    println!("\n===== ä½¿ç”¨ where å­å¥ =====\n");

    fn complex_function<T, U>(t: &T, u: &U)
    where
        T: Debug + Display + Clone,
        U: Debug + Display,
    {
        println!("T: {}, U: {}", t, u);
        let t_clone = t.clone();
        println!("T clone: {}", t_clone);
    }

    let s = String::from("hello");
    let n = 100;
    complex_function(&s, &n);

    println!("\n===== ç»“æ„ä½“çš„å¤šé‡çº¦æŸ =====\n");

    struct Pair<T, U>
    where
        T: Debug + Display,
        U: Debug + Display,
    {
        first: T,
        second: U,
    }

    impl<T, U> Pair<T, U>
    where
        T: Debug + Display,
        U: Debug + Display,
    {
        fn new(first: T, second: U) -> Self {
            Pair { first, second }
        }

        fn show(&self) {
            println!("Pair: ({}, {})", self.first, self.second);
            println!("Debug: ({:?}, {:?})", self.first, self.second);
        }
    }

    let pair = Pair::new("Rust", 2024);
    pair.show();

    println!("\n===== Trait ç»„åˆ =====\n");

    trait Printable: Debug + Display {}

    // è‡ªåŠ¨ä¸ºæ»¡è¶³æ¡ä»¶çš„ç±»å‹å®ç°
    impl<T: Debug + Display> Printable for T {}

    fn show_printable<T: Printable>(value: &T) {
        println!("å€¼: {} ({:?})", value, value);
    }

    show_printable(&"Hello");
    show_printable(&42);

    println!("\n===== æ¡ä»¶å®ç° =====\n");

    struct Wrapper<T>(T);

    // åªæœ‰å½“ T å®ç°äº† Display æ—¶ï¼ŒWrapper<T> æ‰å®ç° Display
    impl<T: Display> Display for Wrapper<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "Wrapper({})", self.0)
        }
    }

    let wrapper = Wrapper(42);
    println!("{}", wrapper);

    println!("\n===== Clone + Copy çº¦æŸ =====\n");

    fn duplicate<T: Clone>(value: &T) -> (T, T) {
        (value.clone(), value.clone())
    }

    let original = vec![1, 2, 3];
    let (copy1, copy2) = duplicate(&original);
    println!("åŸå§‹: {:?}", original);
    println!("å¤åˆ¶1: {:?}, å¤åˆ¶2: {:?}", copy1, copy2);

    println!("\n===== PartialEq + Ord çº¦æŸ =====\n");

    fn find_max<T>(items: &[T]) -> Option<&T>
    where
        T: PartialOrd,
    {
        items.iter().max_by(|a, b| a.partial_cmp(b).unwrap())
    }

    let numbers = vec![3, 1, 4, 1, 5, 9, 2, 6];
    if let Some(max) = find_max(&numbers) {
        println!("æœ€å¤§å€¼: {}", max);
    }
}
```

**è¯´æ˜**:

- **+ è¿æ¥**: ä½¿ç”¨ `T: Trait1 + Trait2` è¯­æ³•
- **where å­å¥**: å¤æ‚çº¦æŸä½¿ç”¨ where æ›´æ¸…æ™°
- **Trait ç»„åˆ**: å®šä¹‰æ–° Trait ç»§æ‰¿å¤šä¸ª Trait
- **æ¡ä»¶å®ç°**: æ ¹æ®ç±»å‹å‚æ•°çº¦æŸé€‰æ‹©æ€§å®ç°

**è¾“å‡º**:

```text
===== ä½¿ç”¨ + è¿æ¥å¤šä¸ª Trait =====

Display: 42
Debug: 42

===== ä½¿ç”¨ where å­å¥ =====

T: hello, U: 100
T clone: hello

===== ç»“æ„ä½“çš„å¤šé‡çº¦æŸ =====

Pair: (Rust, 2024)
Debug: ("Rust", 2024)

===== Trait ç»„åˆ =====

å€¼: Hello ("Hello")
å€¼: 42 (42)

===== æ¡ä»¶å®ç° =====

Wrapper(42)

===== Clone + Copy çº¦æŸ =====

åŸå§‹: [1, 2, 3]
å¤åˆ¶1: [1, 2, 3], å¤åˆ¶2: [1, 2, 3]

===== PartialEq + Ord çº¦æŸ =====

æœ€å¤§å€¼: 9
```

---

### ç¤ºä¾‹2.5: Constæ³›å‹

**ç›®æ ‡**: ç†è§£å¸¸é‡æ³›å‹å‚æ•°çš„ä½¿ç”¨

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== åŸºç¡€ Const æ³›å‹ =====\n");

    // å›ºå®šå¤§å°çš„æ•°ç»„ç»“æ„
    struct Array<T, const N: usize> {
        data: [T; N],
    }

    impl<T, const N: usize> Array<T, N> {
        fn len(&self) -> usize {
            N
        }
    }

    let arr = Array { data: [1, 2, 3, 4, 5] };
    println!("æ•°ç»„é•¿åº¦: {}", arr.len());

    println!("\n===== Const æ³›å‹å‡½æ•° =====\n");

    fn print_array<T: std::fmt::Display, const N: usize>(arr: &[T; N]) {
        print!("[");
        for (i, item) in arr.iter().enumerate() {
            if i > 0 { print!(", "); }
            print!("{}", item);
        }
        println!("]");
        println!("é•¿åº¦: {}", N);
    }

    let numbers = [1, 2, 3, 4, 5];
    print_array(&numbers);

    let words = ["hello", "world"];
    print_array(&words);

    println!("\n===== Const æ³›å‹çš„ç±»å‹å®‰å…¨ =====\n");

    // ç¼–è¯‘æ—¶ä¿è¯é•¿åº¦
    fn concat<const N: usize, const M: usize>(
        a: [i32; N],
        b: [i32; M]
    ) -> Vec<i32> {
        let mut result = Vec::with_capacity(N + M);
        result.extend_from_slice(&a);
        result.extend_from_slice(&b);
        result
    }

    let arr1 = [1, 2, 3];
    let arr2 = [4, 5];
    let combined = concat(arr1, arr2);
    println!("åˆå¹¶æ•°ç»„: {:?}", combined);
    println!("åˆå¹¶é•¿åº¦: {} + {} = {}", 3, 2, combined.len());

    println!("\n===== çŸ©é˜µç¤ºä¾‹ =====\n");

    #[derive(Debug)]
    struct Matrix<T, const ROWS: usize, const COLS: usize> {
        data: [[T; COLS]; ROWS],
    }

    impl<T: Copy, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS> {
        fn new(value: T) -> Self {
            Matrix {
                data: [[value; COLS]; ROWS],
            }
        }

        fn set(&mut self, row: usize, col: usize, value: T) {
            self.data[row][col] = value;
        }

        fn get(&self, row: usize, col: usize) -> T {
            self.data[row][col]
        }
    }

    let mut matrix: Matrix<i32, 3, 3> = Matrix::new(0);
    matrix.set(0, 0, 1);
    matrix.set(1, 1, 2);
    matrix.set(2, 2, 3);

    println!("Matrix<i32, 3, 3>:");
    for row in 0..3 {
        for col in 0..3 {
            print!("{} ", matrix.get(row, col));
        }
        println!();
    }

    println!("\n===== é›¶æˆæœ¬æŠ½è±¡éªŒè¯ =====\n");

    struct Stack<T, const CAP: usize> {
        data: [Option<T>; CAP],
        len: usize,
    }

    impl<T: Copy, const CAP: usize> Stack<T, CAP> {
        fn new() -> Self {
            Stack {
                data: [None; CAP],
                len: 0,
            }
        }

        fn push(&mut self, value: T) -> Result<(), &'static str> {
            if self.len < CAP {
                self.data[self.len] = Some(value);
                self.len += 1;
                Ok(())
            } else {
                Err("Stack overflow")
            }
        }

        fn pop(&mut self) -> Option<T> {
            if self.len > 0 {
                self.len -= 1;
                self.data[self.len].take()
            } else {
                None
            }
        }

        fn capacity(&self) -> usize {
            CAP
        }
    }

    let mut stack: Stack<i32, 5> = Stack::new();
    stack.push(1).unwrap();
    stack.push(2).unwrap();
    stack.push(3).unwrap();

    println!("Stack å®¹é‡: {}", stack.capacity());
    println!("Pop: {:?}", stack.pop());
    println!("Pop: {:?}", stack.pop());
}
```

**è¯´æ˜**:

- **const å‚æ•°**: ä½¿ç”¨ `const N: usize` å®šä¹‰å¸¸é‡æ³›å‹
- **ç¼–è¯‘æ—¶æ£€æŸ¥**: æ•°ç»„å¤§å°åœ¨ç¼–è¯‘æ—¶ç¡®å®š
- **ç±»å‹å®‰å…¨**: ä¸åŒå¤§å°çš„æ•°ç»„æ˜¯ä¸åŒç±»å‹
- **é›¶æˆæœ¬**: ç¼–è¯‘æ—¶å±•å¼€ï¼Œæ— è¿è¡Œæ—¶å¼€é”€

**è¾“å‡º**:

```text
===== åŸºç¡€ Const æ³›å‹ =====

æ•°ç»„é•¿åº¦: 5

===== Const æ³›å‹å‡½æ•° =====

[1, 2, 3, 4, 5]
é•¿åº¦: 5
[hello, world]
é•¿åº¦: 2

===== Const æ³›å‹çš„ç±»å‹å®‰å…¨ =====

åˆå¹¶æ•°ç»„: [1, 2, 3, 4, 5]
åˆå¹¶é•¿åº¦: 3 + 2 = 5

===== çŸ©é˜µç¤ºä¾‹ =====

Matrix<i32, 3, 3>:
1 0 0
0 2 0
0 0 3

===== é›¶æˆæœ¬æŠ½è±¡éªŒè¯ =====

Stack å®¹é‡: 5
Pop: Some(3)
Pop: Some(2)
```

---

### ç¤ºä¾‹2.6: é»˜è®¤ç±»å‹å‚æ•°

**ç›®æ ‡**: ç†è§£æ³›å‹å‚æ•°çš„é»˜è®¤å€¼ä½¿ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::fmt::Display;

fn main() {
    println!("===== åŸºç¡€é»˜è®¤ç±»å‹å‚æ•° =====\n");

    // é»˜è®¤ç±»å‹å‚æ•°ä¸º String
    struct Container<T = String> {
        value: T,
    }

    // ä½¿ç”¨é»˜è®¤ç±»å‹
    let default_container = Container { value: "Hello".to_string() };
    println!("é»˜è®¤å®¹å™¨ (String): {}", default_container.value);

    // æŒ‡å®šç±»å‹
    let int_container: Container<i32> = Container { value: 42 };
    println!("æ•´æ•°å®¹å™¨: {}", int_container.value);

    println!("\n===== å¤šä¸ªé»˜è®¤ç±»å‹å‚æ•° =====\n");

    struct Point<X = f64, Y = f64> {
        x: X,
        y: Y,
    }

    // å…¨éƒ¨ä½¿ç”¨é»˜è®¤
    let p1 = Point { x: 1.0, y: 2.0 };
    println!("Point<f64, f64>: ({}, {})", p1.x, p1.y);

    // éƒ¨åˆ†æŒ‡å®š
    let p2: Point<i32, _> = Point { x: 1, y: 2.0 };
    println!("Point<i32, f64>: ({}, {})", p2.x, p2.y);

    // å…¨éƒ¨æŒ‡å®š
    let p3: Point<i32, i32> = Point { x: 1, y: 2 };
    println!("Point<i32, i32>: ({}, {})", p3.x, p3.y);

    println!("\n===== Trait çš„é»˜è®¤ç±»å‹å‚æ•° =====\n");

    trait Add<RHS = Self> {
        type Output;
        fn add(self, rhs: RHS) -> Self::Output;
    }

    #[derive(Debug, Clone, Copy)]
    struct Millimeters(u32);

    #[derive(Debug, Clone, Copy)]
    struct Meters(u32);

    // è‡ªç›¸åŠ ï¼ˆä½¿ç”¨é»˜è®¤ RHS = Selfï¼‰
    impl Add for Millimeters {
        type Output = Millimeters;

        fn add(self, other: Millimeters) -> Millimeters {
            Millimeters(self.0 + other.0)
        }
    }

    // ä¸ä¸åŒç±»å‹ç›¸åŠ ï¼ˆæŒ‡å®š RHSï¼‰
    impl Add<Meters> for Millimeters {
        type Output = Millimeters;

        fn add(self, other: Meters) -> Millimeters {
            Millimeters(self.0 + (other.0 * 1000))
        }
    }

    let mm1 = Millimeters(100);
    let mm2 = Millimeters(200);
    let sum1 = mm1.add(mm2);
    println!("100mm + 200mm = {:?}", sum1);

    let m1 = Meters(1);
    let sum2 = mm1.add(m1);
    println!("100mm + 1m = {:?}", sum2);

    println!("\n===== å®ç”¨ç¤ºä¾‹: Builder æ¨¡å¼ =====\n");

    struct Config<T = String, U = i32> {
        name: T,
        value: U,
    }

    impl<T, U> Config<T, U> {
        fn new(name: T, value: U) -> Self {
            Config { name, value }
        }
    }

    impl<T: Display, U: Display> Config<T, U> {
        fn display(&self) {
            println!("{}: {}", self.name, self.value);
        }
    }

    // ä½¿ç”¨é»˜è®¤ç±»å‹
    let config1 = Config::new("timeout".to_string(), 30);
    config1.display();

    // æŒ‡å®šç±»å‹
    let config2 = Config::new("ratio", 0.75);
    config2.display();

    println!("\n===== å¯é€‰ç±»å‹åŒ…è£…å™¨ =====\n");

    struct Wrapper<T, U = ()> {
        primary: T,
        secondary: Option<U>,
    }

    impl<T> Wrapper<T, ()> {
        fn new(primary: T) -> Self {
            Wrapper {
                primary,
                secondary: None,
            }
        }
    }

    impl<T, U> Wrapper<T, U> {
        fn with_secondary(primary: T, secondary: U) -> Self {
            Wrapper {
                primary,
                secondary: Some(secondary),
            }
        }
    }

    let simple = Wrapper::new(42);
    println!("ç®€å•åŒ…è£…: {}", simple.primary);

    let complex = Wrapper::with_secondary("data", 123);
    println!("å¤æ‚åŒ…è£…: {} - {:?}", complex.primary, complex.secondary);
}
```

**è¯´æ˜**:

- **é»˜è®¤å€¼**: ä½¿ç”¨ `T = DefaultType` è¯­æ³•
- **ç®€åŒ–API**: å¸¸è§æƒ…å†µä¸éœ€è¦æŒ‡å®šç±»å‹
- **çµæ´»æ€§**: å¯ä»¥è¦†ç›–é»˜è®¤å€¼
- **Traité»˜è®¤**: `RHS = Self` æ˜¯æ ‡å‡†åº“çš„å¸¸è§æ¨¡å¼

**è¾“å‡º**:

```text
===== åŸºç¡€é»˜è®¤ç±»å‹å‚æ•° =====

é»˜è®¤å®¹å™¨ (String): Hello
æ•´æ•°å®¹å™¨: 42

===== å¤šä¸ªé»˜è®¤ç±»å‹å‚æ•° =====

Point<f64, f64>: (1, 2)
Point<i32, f64>: (1, 2)
Point<i32, i32>: (1, 2)

===== Trait çš„é»˜è®¤ç±»å‹å‚æ•° =====

100mm + 200mm = Millimeters(300)
100mm + 1m = Millimeters(1100)

===== å®ç”¨ç¤ºä¾‹: Builder æ¨¡å¼ =====

timeout: 30
ratio: 0.75

===== å¯é€‰ç±»å‹åŒ…è£…å™¨ =====

ç®€å•åŒ…è£…: 42
å¤æ‚åŒ…è£…: data - Some(123)
```

---

## ğŸš€ Tier 3: é«˜çº§å±‚ç¤ºä¾‹

### ç¤ºä¾‹3.1: é«˜é˜¶Traitçº¦æŸ (HRTB)

**ç›®æ ‡**: ç†è§£é«˜é˜¶ Trait çº¦æŸï¼ˆHigher-Rank Trait Boundsï¼‰

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ä»€ä¹ˆæ˜¯ HRTB? =====\n");

    // HRTB å…è®¸æˆ‘ä»¬å¯¹æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸè¿›è¡Œçº¦æŸ
    // è¯­æ³•: for<'a> è¡¨ç¤º"å¯¹äºæ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ 'a"

    println!("é—®é¢˜: å¦‚ä½•ç¼–å†™ä¸€ä¸ªæ¥å—ä»»æ„ç”Ÿå‘½å‘¨æœŸé—­åŒ…çš„å‡½æ•°?\n");

    println!("===== HRTB åŸºç¡€ç¤ºä¾‹ =====\n");

    // ä½¿ç”¨ HRTB çš„å‡½æ•°
    fn call_with_ref<F>(f: F)
    where
        F: for<'a> Fn(&'a str) -> &'a str,
    {
        let s = "hello";
        let result = f(s);
        println!("ç»“æœ: {}", result);
    }

    call_with_ref(|s| s);
    call_with_ref(|s| if s.len() > 3 { s } else { "short" });

    println!("\n===== HRTB vs æ™®é€šç”Ÿå‘½å‘¨æœŸ =====\n");

    // ä¸ä½¿ç”¨ HRTBï¼ˆéœ€è¦æŒ‡å®šç”Ÿå‘½å‘¨æœŸï¼‰
    fn call_with_ref_normal<'a, F>(f: F, s: &'a str)
    where
        F: Fn(&'a str) -> &'a str,
    {
        println!("ç»“æœ: {}", f(s));
    }

    call_with_ref_normal(|s| s, "test");

    println!("\n===== å®ç”¨ç¤ºä¾‹: æ˜ å°„å‡½æ•° =====\n");

    struct Container<T> {
        value: T,
    }

    impl<T> Container<T> {
        fn map<F, U>(self, f: F) -> Container<U>
        where
            F: FnOnce(T) -> U,
        {
            Container { value: f(self.value) }
        }

        // HRTB: æ˜ å°„å¼•ç”¨
        fn map_ref<F, U>(&self, f: F) -> U
        where
            F: for<'a> FnOnce(&'a T) -> U,
        {
            f(&self.value)
        }
    }

    let container = Container { value: String::from("Rust") };
    let length = container.map_ref(|s| s.len());
    println!("å­—ç¬¦ä¸²é•¿åº¦: {}", length);

    println!("\n===== HRTB ä¸ Trait å¯¹è±¡ =====\n");

    // HRTB å¯ä»¥ç”¨äº Trait å¯¹è±¡
    trait Processor {
        fn process<'a>(&self, input: &'a str) -> &'a str;
    }

    struct UpperCase;

    impl Processor for UpperCase {
        fn process<'a>(&self, input: &'a str) -> &'a str {
            // æ³¨æ„: å®é™…ä¸Š to_uppercase è¿”å› String
            // è¿™é‡Œç®€åŒ–æ¼”ç¤º
            input
        }
    }

    fn use_processor<P>(processor: &P, text: &str)
    where
        P: for<'a> Fn(&'a str) -> &'a str,
    {
        println!("å¤„ç†ç»“æœ: {}", processor(text));
    }

    use_processor(&|s| s, "hello");

    println!("\n===== å¤æ‚ HRTB åœºæ™¯ =====\n");

    // å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
    fn complex_hrtb<F>(f: F)
    where
        F: for<'a, 'b> Fn(&'a str, &'b str) -> bool,
    {
        let s1 = "hello";
        let s2 = "world";
        println!("æ¯”è¾ƒç»“æœ: {}", f(s1, s2));
    }

    complex_hrtb(|a, b| a.len() > b.len());
    complex_hrtb(|a, b| a == b);
}
```

**è¯´æ˜**:

- **for<'a>**: å¯¹æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ 'a æˆç«‹
- **çµæ´»æ€§**: å…è®¸é—­åŒ…å¤„ç†ä»»æ„ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
- **Traitçº¦æŸ**: å¯ç”¨äºæ³›å‹å‚æ•°å’Œ Trait å¯¹è±¡
- **å¤æ‚åœºæ™¯**: å¯ä»¥æœ‰å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

**è¾“å‡º**:

```text
===== ä»€ä¹ˆæ˜¯ HRTB? =====

é—®é¢˜: å¦‚ä½•ç¼–å†™ä¸€ä¸ªæ¥å—ä»»æ„ç”Ÿå‘½å‘¨æœŸé—­åŒ…çš„å‡½æ•°?

===== HRTB åŸºç¡€ç¤ºä¾‹ =====

ç»“æœ: hello
ç»“æœ: hello

===== HRTB vs æ™®é€šç”Ÿå‘½å‘¨æœŸ =====

ç»“æœ: test

===== å®ç”¨ç¤ºä¾‹: æ˜ å°„å‡½æ•° =====

å­—ç¬¦ä¸²é•¿åº¦: 4

===== HRTB ä¸ Trait å¯¹è±¡ =====

å¤„ç†ç»“æœ: hello

===== å¤æ‚ HRTB åœºæ™¯ =====

æ¯”è¾ƒç»“æœ: false
æ¯”è¾ƒç»“æœ: false
```

---

### ç¤ºä¾‹3.2: ç±»å‹çº§ç¼–ç¨‹

**ç›®æ ‡**: ç†è§£å¦‚ä½•åœ¨ç±»å‹çº§åˆ«è¿›è¡Œç¼–ç¨‹

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ç±»å‹çº§ç¼–ç¨‹åŸºç¡€ =====\n");

    // ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¡¨ç¤ºæ•°å­—
    trait PeanoNumber {}

    struct Zero;
    struct Succ<N: PeanoNumber>(std::marker::PhantomData<N>);

    impl PeanoNumber for Zero {}
    impl<N: PeanoNumber> PeanoNumber for Succ<N> {}

    // ç±»å‹çº§åŠ æ³•
    trait Add<N: PeanoNumber> {
        type Output: PeanoNumber;
    }

    // Zero + N = N
    impl<N: PeanoNumber> Add<N> for Zero {
        type Output = N;
    }

    // Succ(M) + N = Succ(M + N)
    impl<M: PeanoNumber + Add<N>, N: PeanoNumber> Add<N> for Succ<M>
    where
        M::Output: PeanoNumber,
    {
        type Output = Succ<M::Output>;
    }

    type One = Succ<Zero>;
    type Two = Succ<One>;
    type Three = <One as Add<Two>>::Output;

    println!("âœ… ç±»å‹çº§æ•°å­—å®šä¹‰å®Œæˆ");
    println!("   One = Succ<Zero>");
    println!("   Two = Succ<One>");
    println!("   Three = One + Two");

    println!("\n===== ç±»å‹çº§å¸ƒå°”å€¼ =====\n");

    trait Bool {
        const VALUE: bool;
    }

    struct True;
    struct False;

    impl Bool for True {
        const VALUE: bool = true;
    }

    impl Bool for False {
        const VALUE: bool = false;
    }

    // ç±»å‹çº§ AND
    trait And<B: Bool> {
        type Output: Bool;
    }

    impl<B: Bool> And<B> for False {
        type Output = False;
    }

    impl And<False> for True {
        type Output = False;
    }

    impl And<True> for True {
        type Output = True;
    }

    type Result1 = <True as And<True>>::Output;
    type Result2 = <True as And<False>>::Output;

    println!("True AND True = {}", <Result1 as Bool>::VALUE);
    println!("True AND False = {}", <Result2 as Bool>::VALUE);

    println!("\n===== ç±»å‹çº§åˆ—è¡¨ =====\n");

    trait TypeList {}

    struct Nil;
    struct Cons<H, T: TypeList>(std::marker::PhantomData<(H, T)>);

    impl TypeList for Nil {}
    impl<H, T: TypeList> TypeList for Cons<H, T> {}

    // ç±»å‹çº§åˆ—è¡¨é•¿åº¦
    trait Len {
        const LENGTH: usize;
    }

    impl Len for Nil {
        const LENGTH: usize = 0;
    }

    impl<H, T: TypeList + Len> Len for Cons<H, T> {
        const LENGTH: usize = 1 + T::LENGTH;
    }

    type MyList = Cons<i32, Cons<bool, Cons<String, Nil>>>;

    println!("åˆ—è¡¨ç±»å‹: Cons<i32, Cons<bool, Cons<String, Nil>>>");
    println!("åˆ—è¡¨é•¿åº¦: {}", <MyList as Len>::LENGTH);

    println!("\n===== å®ç”¨ç¤ºä¾‹: ç±»å‹å®‰å…¨çš„çŠ¶æ€æœº =====\n");

    // çŠ¶æ€æ ‡è®°
    struct Locked;
    struct Unlocked;

    struct StateMachine<State> {
        _state: std::marker::PhantomData<State>,
    }

    impl StateMachine<Locked> {
        fn new() -> Self {
            println!("åˆ›å»º: Locked çŠ¶æ€");
            StateMachine { _state: std::marker::PhantomData }
        }

        fn unlock(self) -> StateMachine<Unlocked> {
            println!("è½¬æ¢: Locked -> Unlocked");
            StateMachine { _state: std::marker::PhantomData }
        }
    }

    impl StateMachine<Unlocked> {
        fn lock(self) -> StateMachine<Locked> {
            println!("è½¬æ¢: Unlocked -> Locked");
            StateMachine { _state: std::marker::PhantomData }
        }

        fn access(&self) {
            println!("è®¿é—®: ä»…åœ¨ Unlocked çŠ¶æ€å¯ç”¨");
        }
    }

    let machine = StateMachine::<Locked>::new();
    let unlocked = machine.unlock();
    unlocked.access();
    let locked = unlocked.lock();
    // locked.access(); // ç¼–è¯‘é”™è¯¯ï¼

    println!("\n===== æ€»ç»“ =====\n");
    println!("ç±»å‹çº§ç¼–ç¨‹çš„ä¼˜åŠ¿:");
    println!("  âœ… ç¼–è¯‘æ—¶éªŒè¯");
    println!("  âœ… é›¶è¿è¡Œæ—¶å¼€é”€");
    println!("  âœ… ç±»å‹å®‰å…¨ä¿è¯");
}
```

**è¯´æ˜**:

- **ç±»å‹ä½œä¸ºå€¼**: åœ¨ç±»å‹å±‚é¢è¡¨ç¤ºæ•°æ®
- **ç¼–è¯‘æ—¶è®¡ç®—**: æ‰€æœ‰è®¡ç®—åœ¨ç¼–è¯‘æœŸå®Œæˆ
- **é›¶å¼€é”€**: è¿è¡Œæ—¶æ— é¢å¤–æˆæœ¬
- **ç±»å‹å®‰å…¨**: ç¼–è¯‘å™¨ä¿è¯æ­£ç¡®æ€§

**è¾“å‡º**:

```text
===== ç±»å‹çº§ç¼–ç¨‹åŸºç¡€ =====

âœ… ç±»å‹çº§æ•°å­—å®šä¹‰å®Œæˆ
   One = Succ<Zero>
   Two = Succ<One>
   Three = One + Two

===== ç±»å‹çº§å¸ƒå°”å€¼ =====

True AND True = true
True AND False = false

===== ç±»å‹çº§åˆ—è¡¨ =====

åˆ—è¡¨ç±»å‹: Cons<i32, Cons<bool, Cons<String, Nil>>>
åˆ—è¡¨é•¿åº¦: 3

===== å®ç”¨ç¤ºä¾‹: ç±»å‹å®‰å…¨çš„çŠ¶æ€æœº =====

åˆ›å»º: Locked çŠ¶æ€
è½¬æ¢: Locked -> Unlocked
è®¿é—®: ä»…åœ¨ Unlocked çŠ¶æ€å¯ç”¨
è½¬æ¢: Unlocked -> Locked

===== æ€»ç»“ =====

ç±»å‹çº§ç¼–ç¨‹çš„ä¼˜åŠ¿:
  âœ… ç¼–è¯‘æ—¶éªŒè¯
  âœ… é›¶è¿è¡Œæ—¶å¼€é”€
  âœ… ç±»å‹å®‰å…¨ä¿è¯
```

---

### ç¤ºä¾‹3.3: æ³›å‹ç‰¹åŒ–æ¨¡æ‹Ÿ

**ç›®æ ‡**: ç†è§£å¦‚ä½•åœ¨ Rust ä¸­æ¨¡æ‹Ÿæ³›å‹ç‰¹åŒ–

**éš¾åº¦**: â­â­â­â­

**è¯´æ˜**: Rust ç›®å‰è¿˜æ²¡æœ‰ç¨³å®šæ³›å‹ç‰¹åŒ–ï¼Œä½†å¯ä»¥é€šè¿‡å…¶ä»–æ–¹å¼å®ç°ç±»ä¼¼æ•ˆæœã€‚

**ä»£ç **:

```rust
fn main() {
    println!("===== ä½¿ç”¨ Trait å®ç°ç‰¹åŒ– =====\n");

    // é€šç”¨å®ç°
    trait Stringify {
        fn stringify(&self) -> String;
    }

    // ä¸ºæ‰€æœ‰ç±»å‹æä¾›é»˜è®¤å®ç°
    impl<T: std::fmt::Debug> Stringify for T {
        fn stringify(&self) -> String {
            format!("{:?}", self)
        }
    }

    // ä¸ºç‰¹å®šç±»å‹æä¾›ä¸“é—¨å®ç°
    struct MyString(String);

    impl Stringify for MyString {
        fn stringify(&self) -> String {
            format!("MyString: {}", self.0)
        }
    }

    let num = 42;
    let text = MyString("Hello".to_string());

    println!("æ•°å­—: {}", num.stringify());
    println!("å­—ç¬¦ä¸²: {}", text.stringify());

    println!("\n===== ä½¿ç”¨ NewType æ¨¡å¼ç‰¹åŒ– =====\n");

    // é€šç”¨æ‰“å°trait
    trait Print {
        fn print(&self);
    }

    // é»˜è®¤å®ç°
    impl<T: std::fmt::Display> Print for T {
        fn print(&self) {
            println!("é»˜è®¤: {}", self);
        }
    }

    // åˆ›å»º NewType è¿›è¡Œç‰¹åŒ–
    struct Special<T>(T);

    impl Print for Special<i32> {
        fn print(&self) {
            println!("ç‰¹åŒ– i32: {} (åå…­è¿›åˆ¶: 0x{:X})", self.0, self.0);
        }
    }

    impl Print for Special<String> {
        fn print(&self) {
            println!("ç‰¹åŒ– String: \"{}\" (é•¿åº¦: {})", self.0, self.0.len());
        }
    }

    let normal = 42;
    let special_int = Special(42);
    let special_str = Special(String::from("Rust"));

    normal.print();
    special_int.print();
    special_str.print();

    println!("\n===== åŸºäºç±»å‹ç‰¹å¾çš„ç‰¹åŒ– =====\n");

    // ä½¿ç”¨ sealed trait æ¨¡å¼
    mod sealed {
        pub trait TypeMarker {}
        impl TypeMarker for i32 {}
        impl TypeMarker for String {}
    }

    trait Processor: sealed::TypeMarker {
        fn process(&self) -> String;
    }

    impl Processor for i32 {
        fn process(&self) -> String {
            format!("æ•´æ•°: {}", self)
        }
    }

    impl Processor for String {
        fn process(&self) -> String {
            format!("å­—ç¬¦ä¸²: {}", self)
        }
    }

    let num: i32 = 100;
    let text: String = "Test".to_string();

    println!("{}", num.process());
    println!("{}", text.process());

    println!("\n===== ä½¿ç”¨å…³è”ç±»å‹å®ç°ç‰¹åŒ– =====\n");

    trait Container {
        type Item;
        fn get(&self) -> &Self::Item;
    }

    struct VecContainer<T>(Vec<T>);

    impl<T> Container for VecContainer<T> {
        type Item = T;
        fn get(&self) -> &Self::Item {
            &self.0[0]
        }
    }

    // é’ˆå¯¹ç‰¹å®šç±»å‹çš„ä¼˜åŒ–
    impl Container for VecContainer<i32> {
        type Item = i32;
        fn get(&self) -> &Self::Item {
            println!("(ä½¿ç”¨ i32 ä¼˜åŒ–è·¯å¾„)");
            &self.0[0]
        }
    }

    let vec_int = VecContainer(vec![1, 2, 3]);
    let vec_str = VecContainer(vec!["a", "b"]);

    println!("i32 å®¹å™¨: {}", vec_int.get());
    println!("&str å®¹å™¨: {}", vec_str.get());
}
```

**è¾“å‡º**:

```text
===== ä½¿ç”¨ Trait å®ç°ç‰¹åŒ– =====

æ•°å­—: 42
å­—ç¬¦ä¸²: MyString: Hello

===== ä½¿ç”¨ NewType æ¨¡å¼ç‰¹åŒ– =====

é»˜è®¤: 42
ç‰¹åŒ– i32: 42 (åå…­è¿›åˆ¶: 0x2A)
ç‰¹åŒ– String: "Rust" (é•¿åº¦: 4)

===== åŸºäºç±»å‹ç‰¹å¾çš„ç‰¹åŒ– =====

æ•´æ•°: 100
å­—ç¬¦ä¸²: Test

===== ä½¿ç”¨å…³è”ç±»å‹å®ç°ç‰¹åŒ– =====

(ä½¿ç”¨ i32 ä¼˜åŒ–è·¯å¾„)
i32 å®¹å™¨: 1
&str å®¹å™¨: a
```

---

### ç¤ºä¾‹3.4: GAT - æ³›å‹å…³è”ç±»å‹

**ç›®æ ‡**: ç†è§£æ³›å‹å…³è”ç±»å‹ï¼ˆGeneric Associated Typesï¼‰

**éš¾åº¦**: â­â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ä»€ä¹ˆæ˜¯ GAT? =====\n");

    println!("GAT å…è®¸å…³è”ç±»å‹æœ¬èº«ä¹Ÿæ˜¯æ³›å‹çš„\n");

    println!("===== GAT åŸºç¡€ç¤ºä¾‹ =====\n");

    // å®šä¹‰å¸¦ GAT çš„ Trait
    trait Container {
        type Item<'a> where Self: 'a;
        fn get<'a>(&'a self) -> Self::Item<'a>;
    }

    struct VecWrapper<T> {
        data: Vec<T>,
    }

    impl<T> Container for VecWrapper<T> {
        type Item<'a> = &'a T where Self: 'a;

        fn get<'a>(&'a self) -> Self::Item<'a> {
            &self.data[0]
        }
    }

    let vec = VecWrapper { data: vec![1, 2, 3] };
    println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", vec.get());

    println!("\n===== GAT çš„å®ç”¨åœºæ™¯: è¿­ä»£å™¨ =====\n");

    trait LendingIterator {
        type Item<'a> where Self: 'a;
        fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
    }

    struct WindowsTwo<T> {
        data: Vec<T>,
        pos: usize,
    }

    impl<T> WindowsTwo<T> {
        fn new(data: Vec<T>) -> Self {
            WindowsTwo { data, pos: 0 }
        }
    }

    impl<T> LendingIterator for WindowsTwo<T> {
        type Item<'a> = (&'a T, &'a T) where Self: 'a;

        fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
            if self.pos + 1 < self.data.len() {
                let result = (&self.data[self.pos], &self.data[self.pos + 1]);
                self.pos += 1;
                Some(result)
            } else {
                None
            }
        }
    }

    let mut windows = WindowsTwo::new(vec![1, 2, 3, 4, 5]);
    println!("çª—å£è¿­ä»£:");
    while let Some((a, b)) = windows.next() {
        println!("  ({}, {})", a, b);
    }

    println!("\n===== GAT ä¸ç”Ÿå‘½å‘¨æœŸ =====\n");

    trait Cache {
        type Value<'a> where Self: 'a;
        fn get<'a>(&'a self, key: &str) -> Option<Self::Value<'a>>;
    }

    struct SimpleCache {
        data: std::collections::HashMap<String, String>,
    }

    impl Cache for SimpleCache {
        type Value<'a> = &'a str where Self: 'a;

        fn get<'a>(&'a self, key: &str) -> Option<Self::Value<'a>> {
            self.data.get(key).map(|s| s.as_str())
        }
    }

    let mut cache = SimpleCache {
        data: std::collections::HashMap::new(),
    };
    cache.data.insert("name".to_string(), "Rust".to_string());

    if let Some(value) = cache.get("name") {
        println!("ç¼“å­˜å€¼: {}", value);
    }

    println!("\n===== GAT çš„é«˜çº§åº”ç”¨ =====\n");

    trait Family {
        type Member<'a, T: 'a> where Self: 'a;
        fn create<'a, T: 'a>(&'a self, value: T) -> Self::Member<'a, T>;
    }

    struct MyFamily;

    impl Family for MyFamily {
        type Member<'a, T: 'a> = Holder<'a, T> where Self: 'a;

        fn create<'a, T: 'a>(&'a self, value: T) -> Self::Member<'a, T> {
            Holder { value, _marker: std::marker::PhantomData }
        }
    }

    struct Holder<'a, T> {
        value: T,
        _marker: std::marker::PhantomData<&'a ()>,
    }

    let family = MyFamily;
    let member = family.create(42);
    println!("åˆ›å»ºæˆå‘˜: {}", member.value);
}
```

**è¾“å‡º**:

```text
===== ä»€ä¹ˆæ˜¯ GAT? =====

GAT å…è®¸å…³è”ç±»å‹æœ¬èº«ä¹Ÿæ˜¯æ³›å‹çš„

===== GAT åŸºç¡€ç¤ºä¾‹ =====

ç¬¬ä¸€ä¸ªå…ƒç´ : 1

===== GAT çš„å®ç”¨åœºæ™¯: è¿­ä»£å™¨ =====

çª—å£è¿­ä»£:
  (1, 2)
  (2, 3)
  (3, 4)
  (4, 5)

===== GAT ä¸ç”Ÿå‘½å‘¨æœŸ =====

ç¼“å­˜å€¼: Rust

===== GAT çš„é«˜çº§åº”ç”¨ =====

åˆ›å»ºæˆå‘˜: 42
```

---

### ç¤ºä¾‹3.5: ç±»å‹çŠ¶æ€æ¨¡å¼

**ç›®æ ‡**: ä½¿ç”¨ç±»å‹ç³»ç»Ÿç¼–ç çŠ¶æ€æœº

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== ç±»å‹çŠ¶æ€æ¨¡å¼åŸºç¡€ =====\n");

    // çŠ¶æ€ç±»å‹
    struct Disconnected;
    struct Connected;
    struct Authenticated;

    // è¿æ¥å¯¹è±¡ï¼Œä½¿ç”¨ç±»å‹å‚æ•°è¡¨ç¤ºçŠ¶æ€
    struct Connection<State> {
        _state: std::marker::PhantomData<State>,
    }

    impl Connection<Disconnected> {
        fn new() -> Self {
            println!("åˆ›å»ºè¿æ¥: Disconnected");
            Connection { _state: std::marker::PhantomData }
        }

        fn connect(self) -> Connection<Connected> {
            println!("è¿æ¥æˆåŠŸ: Disconnected -> Connected");
            Connection { _state: std::marker::PhantomData }
        }
    }

    impl Connection<Connected> {
        fn authenticate(self, password: &str) -> Result<Connection<Authenticated>, Connection<Connected>> {
            if password == "secret" {
                println!("è®¤è¯æˆåŠŸ: Connected -> Authenticated");
                Ok(Connection { _state: std::marker::PhantomData })
            } else {
                println!("è®¤è¯å¤±è´¥");
                Err(self)
            }
        }

        fn disconnect(self) -> Connection<Disconnected> {
            println!("æ–­å¼€è¿æ¥: Connected -> Disconnected");
            Connection { _state: std::marker::PhantomData }
        }
    }

    impl Connection<Authenticated> {
        fn send_data(&self, data: &str) {
            println!("å‘é€æ•°æ®: {}", data);
        }

        fn disconnect(self) -> Connection<Disconnected> {
            println!("æ–­å¼€è¿æ¥: Authenticated -> Disconnected");
            Connection { _state: std::marker::PhantomData }
        }
    }

    // ä½¿ç”¨ç¤ºä¾‹
    let conn = Connection::<Disconnected>::new();
    let conn = conn.connect();
    let conn = conn.authenticate("secret").unwrap();
    conn.send_data("Hello, World!");
    let _conn = conn.disconnect();

    // conn.send_data("test"); // ç¼–è¯‘é”™è¯¯ï¼šå·²æ–­å¼€è¿æ¥ï¼

    println!("\n===== æ„å»ºå™¨æ¨¡å¼çš„ç±»å‹çŠ¶æ€ =====\n");

    struct NoName;
    struct HasName;
    struct NoAge;
    struct HasAge;

    struct UserBuilder<Name, Age> {
        name: Option<String>,
        age: Option<u32>,
        _name_state: std::marker::PhantomData<Name>,
        _age_state: std::marker::PhantomData<Age>,
    }

    impl UserBuilder<NoName, NoAge> {
        fn new() -> Self {
            println!("åˆ›å»ºæ„å»ºå™¨");
            UserBuilder {
                name: None,
                age: None,
                _name_state: std::marker::PhantomData,
                _age_state: std::marker::PhantomData,
            }
        }
    }

    impl<Age> UserBuilder<NoName, Age> {
        fn name(self, name: String) -> UserBuilder<HasName, Age> {
            println!("è®¾ç½®åå­—: {}", name);
            UserBuilder {
                name: Some(name),
                age: self.age,
                _name_state: std::marker::PhantomData,
                _age_state: std::marker::PhantomData,
            }
        }
    }

    impl<Name> UserBuilder<Name, NoAge> {
        fn age(self, age: u32) -> UserBuilder<Name, HasAge> {
            println!("è®¾ç½®å¹´é¾„: {}", age);
            UserBuilder {
                name: self.name,
                age: Some(age),
                _name_state: std::marker::PhantomData,
                _age_state: std::marker::PhantomData,
            }
        }
    }

    impl UserBuilder<HasName, HasAge> {
        fn build(self) -> User {
            println!("æ„å»ºç”¨æˆ·");
            User {
                name: self.name.unwrap(),
                age: self.age.unwrap(),
            }
        }
    }

    struct User {
        name: String,
        age: u32,
    }

    let user = UserBuilder::new()
        .name("Alice".to_string())
        .age(30)
        .build();

    println!("ç”¨æˆ·: {} ({}å²)", user.name, user.age);

    // UserBuilder::new().build(); // ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘å¿…è¦å­—æ®µï¼

    println!("\n===== æ–‡ä»¶æ“ä½œçš„ç±»å‹çŠ¶æ€ =====\n");

    struct Closed;
    struct Open;

    struct File<State> {
        _state: std::marker::PhantomData<State>,
    }

    impl File<Closed> {
        fn new() -> Self {
            println!("æ–‡ä»¶: Closed");
            File { _state: std::marker::PhantomData }
        }

        fn open(self) -> File<Open> {
            println!("æ‰“å¼€æ–‡ä»¶: Closed -> Open");
            File { _state: std::marker::PhantomData }
        }
    }

    impl File<Open> {
        fn write(&self, data: &str) {
            println!("å†™å…¥æ•°æ®: {}", data);
        }

        fn read(&self) -> String {
            println!("è¯»å–æ•°æ®");
            "file content".to_string()
        }

        fn close(self) -> File<Closed> {
            println!("å…³é—­æ–‡ä»¶: Open -> Closed");
            File { _state: std::marker::PhantomData }
        }
    }

    let file = File::<Closed>::new();
    let file = file.open();
    file.write("Hello");
    let content = file.read();
    println!("å†…å®¹: {}", content);
    let _file = file.close();
}
```

**è¾“å‡º**:

```text
===== ç±»å‹çŠ¶æ€æ¨¡å¼åŸºç¡€ =====

åˆ›å»ºè¿æ¥: Disconnected
è¿æ¥æˆåŠŸ: Disconnected -> Connected
è®¤è¯æˆåŠŸ: Connected -> Authenticated
å‘é€æ•°æ®: Hello, World!
æ–­å¼€è¿æ¥: Authenticated -> Disconnected

===== æ„å»ºå™¨æ¨¡å¼çš„ç±»å‹çŠ¶æ€ =====

åˆ›å»ºæ„å»ºå™¨
è®¾ç½®åå­—: Alice
è®¾ç½®å¹´é¾„: 30
æ„å»ºç”¨æˆ·
ç”¨æˆ·: Alice (30å²)

===== æ–‡ä»¶æ“ä½œçš„ç±»å‹çŠ¶æ€ =====

æ–‡ä»¶: Closed
æ‰“å¼€æ–‡ä»¶: Closed -> Open
å†™å…¥æ•°æ®: Hello
è¯»å–æ•°æ®
å†…å®¹: file content
å…³é—­æ–‡ä»¶: Open -> Closed
```

---

### ç¤ºä¾‹3.6: é›¶æˆæœ¬æŠ½è±¡éªŒè¯

**ç›®æ ‡**: éªŒè¯æ³›å‹ä»£ç çš„é›¶æˆæœ¬æŠ½è±¡ç‰¹æ€§

**éš¾åº¦**: â­â­â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é›¶æˆæœ¬æŠ½è±¡åŸç† =====\n");

    println!("Rust çš„æ³›å‹é€šè¿‡å•æ€åŒ–å®ç°é›¶æˆæœ¬æŠ½è±¡");
    println!("ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨çš„ä»£ç \n");

    println!("===== æ³›å‹ vs å…·ä½“ç±»å‹æ€§èƒ½å¯¹æ¯” =====\n");

    // æ³›å‹ç‰ˆæœ¬
    fn generic_sum<T: std::ops::Add<Output = T> + Copy>(slice: &[T]) -> Option<T> {
        if slice.is_empty() {
            return None;
        }
        let mut sum = slice[0];
        for &item in &slice[1..] {
            sum = sum + item;
        }
        Some(sum)
    }

    // å…·ä½“ç±»å‹ç‰ˆæœ¬
    fn concrete_sum(slice: &[i32]) -> Option<i32> {
        if slice.is_empty() {
            return None;
        }
        let mut sum = slice[0];
        for &item in &slice[1..] {
            sum = sum + item;
        }
        Some(sum)
    }

    let numbers = vec![1, 2, 3, 4, 5];

    let generic_result = generic_sum(&numbers);
    let concrete_result = concrete_sum(&numbers);

    println!("æ³›å‹æ±‚å’Œ: {:?}", generic_result);
    println!("å…·ä½“æ±‚å’Œ: {:?}", concrete_result);
    println!("ç»“æœç›¸åŒ: {}", generic_result == concrete_result);
    println!("\nç¼–è¯‘åçš„æœºå™¨ç åº”è¯¥æ˜¯ä¸€è‡´çš„ï¼");

    println!("\n===== å†…è”ä¼˜åŒ–éªŒè¯ =====\n");

    trait Operation {
        fn execute(&self, x: i32) -> i32;
    }

    struct AddOne;
    impl Operation for AddOne {
        #[inline]
        fn execute(&self, x: i32) -> i32 {
            x + 1
        }
    }

    struct MultiplyTwo;
    impl Operation for MultiplyTwo {
        #[inline]
        fn execute(&self, x: i32) -> i32 {
            x * 2
        }
    }

    // æ³›å‹å‡½æ•°å¯ä»¥è¢«å†…è”
    #[inline]
    fn apply<O: Operation>(op: &O, value: i32) -> i32 {
        op.execute(value)
    }

    let result1 = apply(&AddOne, 5);
    let result2 = apply(&MultiplyTwo, 5);

    println!("AddOne(5) = {}", result1);
    println!("MultiplyTwo(5) = {}", result2);
    println!("\n#[inline] å±æ€§å¸®åŠ©ç¼–è¯‘å™¨ä¼˜åŒ–");

    println!("\n===== Iterator é›¶æˆæœ¬æŠ½è±¡ =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // ä½¿ç”¨è¿­ä»£å™¨é“¾
    let sum: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2)
        .sum();

    println!("å¶æ•°åŠ å€æ±‚å’Œ: {}", sum);
    println!("è¿™ä¸ªè¿­ä»£å™¨é“¾ä¼šè¢«ä¼˜åŒ–æˆé«˜æ•ˆçš„å¾ªç¯ä»£ç ï¼");

    // æ‰‹å†™ç­‰ä»·å¾ªç¯
    let mut manual_sum = 0;
    for &x in &numbers {
        if x % 2 == 0 {
            manual_sum += x * 2;
        }
    }

    println!("æ‰‹å†™å¾ªç¯ç»“æœ: {}", manual_sum);
    println!("æ€§èƒ½åº”è¯¥ç›¸åŒï¼");

    println!("\n===== å•æ€åŒ–ç¤ºä¾‹ =====\n");

    fn process<T: std::fmt::Display>(value: T) {
        println!("å¤„ç†: {}", value);
    }

    process(42);           // ç”Ÿæˆ process_i32 ç‰ˆæœ¬
    process("hello");      // ç”Ÿæˆ process_str ç‰ˆæœ¬
    process(3.14);         // ç”Ÿæˆ process_f64 ç‰ˆæœ¬

    println!("\nç¼–è¯‘å™¨ä¸ºæ¯ä¸ªç±»å‹ç”Ÿæˆç‹¬ç«‹çš„å‡½æ•°");

    println!("\n===== ç¼–è¯‘æ—¶ä¼˜åŒ–éªŒè¯ =====\n");

    // ç¼–è¯‘æ—¶å¸¸é‡æŠ˜å 
    const fn compile_time_compute(n: usize) -> usize {
        n * 2 + 1
    }

    const RESULT: usize = compile_time_compute(10);

    println!("ç¼–è¯‘æ—¶è®¡ç®—: compile_time_compute(10) = {}", RESULT);
    println!("è¿™ä¸ªå€¼åœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šäº†ï¼");

    // ç±»å‹é©±åŠ¨çš„ç¼–è¯‘æ—¶é€‰æ‹©
    trait TypeInfo {
        const SIZE: usize;
        const NAME: &'static str;
    }

    impl TypeInfo for i32 {
        const SIZE: usize = 4;
        const NAME: &'static str = "i32";
    }

    impl TypeInfo for i64 {
        const SIZE: usize = 8;
        const NAME: &'static str = "i64";
    }

    fn print_type_info<T: TypeInfo>() {
        println!("ç±»å‹: {}, å¤§å°: {} bytes", T::NAME, T::SIZE);
    }

    print_type_info::<i32>();
    print_type_info::<i64>();

    println!("\n===== æ€»ç»“ =====\n");
    println!("é›¶æˆæœ¬æŠ½è±¡çš„å…³é”®:");
    println!("  âœ… å•æ€åŒ– - ä¸ºæ¯ä¸ªç±»å‹ç”Ÿæˆä¸“é—¨ä»£ç ");
    println!("  âœ… å†…è” - æ¶ˆé™¤å‡½æ•°è°ƒç”¨å¼€é”€");
    println!("  âœ… ç¼–è¯‘æ—¶è®¡ç®— - ç§»é™¤è¿è¡Œæ—¶è®¡ç®—");
    println!("  âœ… æ­»ä»£ç æ¶ˆé™¤ - ç§»é™¤æœªä½¿ç”¨çš„ä»£ç ");
    println!("\næŠ½è±¡ä¸ç­‰äºæ€§èƒ½æŸå¤±ï¼");
}
```

**è¾“å‡º**:

```text
===== é›¶æˆæœ¬æŠ½è±¡åŸç† =====

Rust çš„æ³›å‹é€šè¿‡å•æ€åŒ–å®ç°é›¶æˆæœ¬æŠ½è±¡
ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨çš„ä»£ç 

===== æ³›å‹ vs å…·ä½“ç±»å‹æ€§èƒ½å¯¹æ¯” =====

æ³›å‹æ±‚å’Œ: Some(15)
å…·ä½“æ±‚å’Œ: Some(15)
ç»“æœç›¸åŒ: true

ç¼–è¯‘åçš„æœºå™¨ç åº”è¯¥æ˜¯ä¸€è‡´çš„ï¼

===== å†…è”ä¼˜åŒ–éªŒè¯ =====

AddOne(5) = 6
MultiplyTwo(5) = 10

#[inline] å±æ€§å¸®åŠ©ç¼–è¯‘å™¨ä¼˜åŒ–

===== Iterator é›¶æˆæœ¬æŠ½è±¡ =====

å¶æ•°åŠ å€æ±‚å’Œ: 12
è¿™ä¸ªè¿­ä»£å™¨é“¾ä¼šè¢«ä¼˜åŒ–æˆé«˜æ•ˆçš„å¾ªç¯ä»£ç ï¼
æ‰‹å†™å¾ªç¯ç»“æœ: 12
æ€§èƒ½åº”è¯¥ç›¸åŒï¼

===== å•æ€åŒ–ç¤ºä¾‹ =====

å¤„ç†: 42
å¤„ç†: hello
å¤„ç†: 3.14

ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªç±»å‹ç”Ÿæˆç‹¬ç«‹çš„å‡½æ•°

===== ç¼–è¯‘æ—¶ä¼˜åŒ–éªŒè¯ =====

ç¼–è¯‘æ—¶è®¡ç®—: compile_time_compute(10) = 21
è¿™ä¸ªå€¼åœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šäº†ï¼
ç±»å‹: i32, å¤§å°: 4 bytes
ç±»å‹: i64, å¤§å°: 8 bytes

===== æ€»ç»“ =====

é›¶æˆæœ¬æŠ½è±¡çš„å…³é”®:
  âœ… å•æ€åŒ– - ä¸ºæ¯ä¸ªç±»å‹ç”Ÿæˆä¸“é—¨ä»£ç 
  âœ… å†…è” - æ¶ˆé™¤å‡½æ•°è°ƒç”¨å¼€é”€
  âœ… ç¼–è¯‘æ—¶è®¡ç®— - ç§»é™¤è¿è¡Œæ—¶è®¡ç®—
  âœ… æ­»ä»£ç æ¶ˆé™¤ - ç§»é™¤æœªä½¿ç”¨çš„ä»£ç 

æŠ½è±¡ä¸ç­‰äºæ€§èƒ½æŸå¤±ï¼
```

---

## ğŸ“ æ€»ç»“

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **ç¬¬ä¸€é˜¶æ®µ** (Tier 1): æŒæ¡åŸºç¡€ (ç¤ºä¾‹ 1.1-1.6)
   - æ³›å‹å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾
   - Option å’Œ Result
   - æ³›å‹æ–¹æ³•
   - åŸºç¡€ Trait çº¦æŸ

2. **ç¬¬äºŒé˜¶æ®µ** (Tier 2): å®è·µåº”ç”¨ (ç¤ºä¾‹ 2.1-2.6)
   - é™æ€ vs åŠ¨æ€åˆ†æ´¾
   - å…³è”ç±»å‹
   - ç”Ÿå‘½å‘¨æœŸä¸æ³›å‹
   - å¤š Trait çº¦æŸ
   - Const æ³›å‹
   - é»˜è®¤ç±»å‹å‚æ•°

3. **ç¬¬ä¸‰é˜¶æ®µ** (Tier 3): æ·±å…¥ç†è§£ (ç¤ºä¾‹ 3.1-3.6)
   - HRTB (é«˜é˜¶Traitçº¦æŸ)
   - ç±»å‹çº§ç¼–ç¨‹
   - æ³›å‹ç‰¹åŒ–æ¨¡æ‹Ÿ
   - GAT (æ³›å‹å…³è”ç±»å‹)
   - ç±»å‹çŠ¶æ€æ¨¡å¼
   - é›¶æˆæœ¬æŠ½è±¡éªŒè¯

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ | ç›¸å…³ç¤ºä¾‹ | é‡è¦æ€§ | éš¾åº¦ |
| --- | --- | --- | --- |
| æ³›å‹å‡½æ•° | 1.1 | â­â­â­â­â­ | â­ |
| æ³›å‹ç»“æ„ä½“ | 1.2 | â­â­â­â­â­ | â­ |
| æ³›å‹æšä¸¾ | 1.3 | â­â­â­â­â­ | â­ |
| Traitçº¦æŸ | 1.6 | â­â­â­â­â­ | â­â­ |
| å…³è”ç±»å‹ | 2.2 | â­â­â­â­ | â­â­â­ |
| HRTB | 3.1 | â­â­â­ | â­â­â­â­ |

### æœ€ä½³å®è·µ

1. **é€‰æ‹©æ³›å‹è¿˜æ˜¯Traitå¯¹è±¡**:
   - æ€§èƒ½å…³é”®ï¼šä½¿ç”¨æ³›å‹ï¼ˆé™æ€åˆ†æ´¾ï¼‰
   - éœ€è¦å¼‚æ„é›†åˆï¼šä½¿ç”¨ Trait å¯¹è±¡
   - ç®€å•æƒ…å†µï¼šä¼˜å…ˆæ³›å‹

2. **Traitçº¦æŸ**:
   - ç®€å•çº¦æŸï¼šä½¿ç”¨ `T: Trait`
   - å¤æ‚çº¦æŸï¼šä½¿ç”¨ where å­å¥
   - å¤šé‡çº¦æŸï¼šä½¿ç”¨ `+` è¿æ¥

3. **å…³è”ç±»å‹ vs æ³›å‹å‚æ•°**:
   - ä¸€å¯¹ä¸€å…³ç³»ï¼šä½¿ç”¨å…³è”ç±»å‹
   - å¤šç§å®ç°ï¼šä½¿ç”¨æ³›å‹å‚æ•°
   - ç®€åŒ– APIï¼šä¼˜å…ˆå…³è”ç±»å‹

4. **Const æ³›å‹**:
   - å›ºå®šå¤§å°æ•°ç»„ï¼šä½¿ç”¨ const æ³›å‹
   - ç±»å‹å®‰å…¨ï¼šåœ¨ç±»å‹çº§åˆ«ä¿è¯çº¦æŸ
   - é›¶è¿è¡Œæ—¶æˆæœ¬ï¼šç¼–è¯‘æ—¶æ£€æŸ¥

### ä¸‹ä¸€æ­¥

- ğŸ“– æ·±å…¥å­¦ä¹ : [æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ](./02_Traitç³»ç»ŸæŒ‡å—.md)
- ğŸ“– æ·±å…¥å­¦ä¹ : [å…³è”ç±»å‹è¯¦è§£](./03_å…³è”ç±»å‹æŒ‡å—.md)
- ğŸš€ å®æˆ˜é¡¹ç›®: [C04 å®æˆ˜é¡¹ç›®é›†](./07_å®æˆ˜é¡¹ç›®é›†.md) (å³å°†åˆ›å»º)
- ğŸ“š å‚è€ƒæ–‡æ¡£: [tier_03_references](../tier_03_references/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ’¡ æ³›å‹ç¼–ç¨‹æ˜¯ Rust å®ç°é›¶æˆæœ¬æŠ½è±¡çš„å…³é”®ï¼ŒæŒæ¡æ³›å‹èƒ½è®©ä½ çš„ä»£ç æ—¢çµæ´»åˆé«˜æ•ˆ! ğŸ¦€**ï¼š
