# 🎯 C04: 泛型编程 - 代码示例集合

> **创建日期**: 2025-10-25  
> **文档版本**: v1.0  
> **适用模块**: C04 泛型编程  
> **目标**: 通过丰富的代码示例，帮助学习者深入理解 Rust 泛型编程和 Trait 系统。

---

## 📋 本文档目录

- [🎯 C04: 泛型编程 - 代码示例集合](#-c04-泛型编程---代码示例集合)
  - [📋 本文档目录](#-本文档目录)
  - [📋 文档概述](#-文档概述)
  - [🎯 示例导航](#-示例导航)
  - [🎓 Tier 1: 基础层示例](#-tier-1-基础层示例)
    - [示例1.1: 泛型函数基础](#示例11-泛型函数基础)
    - [示例1.2: 泛型结构体](#示例12-泛型结构体)
    - [示例1.3: 泛型枚举](#示例13-泛型枚举)
    - [示例1.4: Option和Result](#示例14-option和result)
    - [示例1.5: 泛型方法](#示例15-泛型方法)
    - [示例1.6: 基础Trait约束](#示例16-基础trait约束)
  - [🎓 Tier 2: 实践层示例](#-tier-2-实践层示例)
    - [示例2.1: Trait对象与泛型对比](#示例21-trait对象与泛型对比)
    - [示例2.2: 关联类型详解](#示例22-关联类型详解)
    - [示例2.3: 泛型与生命周期](#示例23-泛型与生命周期)
    - [示例2.4: 多Trait约束](#示例24-多trait约束)
    - [示例2.5: Const泛型](#示例25-const泛型)
    - [示例2.6: 默认类型参数](#示例26-默认类型参数)
  - [🚀 Tier 3: 高级层示例](#-tier-3-高级层示例)
    - [示例3.1: 高阶Trait约束 (HRTB)](#示例31-高阶trait约束-hrtb)
    - [示例3.2: 类型级编程](#示例32-类型级编程)
    - [示例3.3: 泛型特化模拟](#示例33-泛型特化模拟)
    - [示例3.4: GAT - 泛型关联类型](#示例34-gat---泛型关联类型)
    - [示例3.5: 类型状态模式](#示例35-类型状态模式)
    - [示例3.6: 零成本抽象验证](#示例36-零成本抽象验证)
  - [📝 总结](#-总结)
    - [学习路径建议](#学习路径建议)
    - [核心概念总结](#核心概念总结)
    - [最佳实践](#最佳实践)
    - [下一步](#下一步)

## 📋 文档概述

本文档提供了 **18个精心设计的代码示例**，覆盖了 C04 模块的核心概念，从基础到高级，每个示例都配有详细的解释和运行结果。

---

## 🎯 示例导航

| # | 示例名称 | 核心概念 | 难度 | 预计学习时间 |
|---|----------|----------|------|--------------|
| **Tier 1: 基础层** |||||
| 1.1 | [泛型函数基础](#示例11-泛型函数基础) | 函数泛型 | ⭐ | 15分钟 |
| 1.2 | [泛型结构体](#示例12-泛型结构体) | 结构体泛型 | ⭐ | 20分钟 |
| 1.3 | [泛型枚举](#示例13-泛型枚举) | 枚举泛型 | ⭐ | 15分钟 |
| 1.4 | [Option和Result](#示例14-option和result) | 标准库泛型 | ⭐⭐ | 25分钟 |
| 1.5 | [泛型方法](#示例15-泛型方法) | 方法泛型 | ⭐⭐ | 20分钟 |
| 1.6 | [基础Trait约束](#示例16-基础trait约束) | where子句 | ⭐⭐ | 25分钟 |
| **Tier 2: 实践层** |||||
| 2.1 | [Trait对象与泛型对比](#示例21-trait对象与泛型对比) | 静态vs动态分派 | ⭐⭐ | 30分钟 |
| 2.2 | [关联类型详解](#示例22-关联类型详解) | 关联类型 | ⭐⭐⭐ | 35分钟 |
| 2.3 | [泛型与生命周期](#示例23-泛型与生命周期) | 生命周期约束 | ⭐⭐⭐ | 40分钟 |
| 2.4 | [多Trait约束](#示例24-多trait约束) | 多重约束 | ⭐⭐⭐ | 30分钟 |
| 2.5 | [Const泛型](#示例25-const泛型) | 常量泛型参数 | ⭐⭐⭐ | 35分钟 |
| 2.6 | [默认类型参数](#示例26-默认类型参数) | 默认泛型 | ⭐⭐ | 25分钟 |
| **Tier 3: 高级层** |||||
| 3.1 | [高阶Trait约束](#示例31-高阶trait约束-hrtb) | HRTB | ⭐⭐⭐⭐ | 50分钟 |
| 3.2 | [类型级编程](#示例32-类型级编程) | 类型系统技巧 | ⭐⭐⭐⭐ | 60分钟 |
| 3.3 | [泛型特化模拟](#示例33-泛型特化模拟) | 特化模式 | ⭐⭐⭐⭐ | 45分钟 |
| 3.4 | [GAT - 泛型关联类型](#示例34-gat---泛型关联类型) | GAT | ⭐⭐⭐⭐⭐ | 60分钟 |
| 3.5 | [类型状态模式](#示例35-类型状态模式) | 类型驱动设计 | ⭐⭐⭐⭐ | 50分钟 |
| 3.6 | [零成本抽象验证](#示例36-零成本抽象验证) | 性能分析 | ⭐⭐⭐⭐⭐ | 60分钟 |

---

## 🎓 Tier 1: 基础层示例

### 示例1.1: 泛型函数基础

**目标**: 理解泛型函数的基本语法和使用

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== 泛型函数基础 =====\n");
    
    // 不使用泛型 - 需要为每种类型写一个函数
    fn largest_i32(list: &[i32]) -> i32 {
        let mut largest = list[0];
        for &item in list {
            if item > largest {
                largest = item;
            }
        }
        largest
    }
    
    fn largest_char(list: &[char]) -> char {
        let mut largest = list[0];
        for &item in list {
            if item > largest {
                largest = item;
            }
        }
        largest
    }
    
    let number_list = vec![34, 50, 25, 100, 65];
    println!("最大的数字: {}", largest_i32(&number_list));
    
    let char_list = vec!['y', 'm', 'a', 'q'];
    println!("最大的字符: {}", largest_char(&char_list));
    
    println!("\n===== 使用泛型 =====\n");
    
    // 使用泛型 - 一个函数支持多种类型
    fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
        let mut largest = list[0];
        for &item in list {
            if item > largest {
                largest = item;
            }
        }
        largest
    }
    
    let number_list = vec![34, 50, 25, 100, 65];
    println!("最大的数字: {}", largest(&number_list));
    
    let char_list = vec!['y', 'm', 'a', 'q'];
    println!("最大的字符: {}", largest(&char_list));
    
    let float_list = vec![3.14, 2.71, 1.41, 1.73];
    println!("最大的浮点数: {}", largest(&float_list));
    
    println!("\n===== 类型推断 =====\n");
    
    // 编译器可以推断类型
    fn identity<T>(value: T) -> T {
        value
    }
    
    let num = identity(42);        // T = i32
    let text = identity("hello");  // T = &str
    let flag = identity(true);     // T = bool
    
    println!("num: {}, text: {}, flag: {}", num, text, flag);
    
    println!("\n===== 多个类型参数 =====\n");
    
    fn pair<T, U>(first: T, second: U) -> (T, U) {
        (first, second)
    }
    
    let p1 = pair(42, "hello");
    let p2 = pair(3.14, true);
    
    println!("p1: {:?}", p1);
    println!("p2: {:?}", p2);
}
```

**说明**:

- **泛型参数**: 使用 `<T>` 声明泛型类型参数
- **Trait约束**: `T: PartialOrd + Copy` 表示 T 必须实现这些 trait
- **类型推断**: 编译器可以根据参数推断泛型类型
- **多类型参数**: 可以使用多个泛型参数 `<T, U>`

**输出**:

```text
===== 泛型函数基础 =====

最大的数字: 100
最大的字符: y

===== 使用泛型 =====

最大的数字: 100
最大的字符: y
最大的浮点数: 3.14

===== 类型推断 =====

num: 42, text: hello, flag: true

===== 多个类型参数 =====

p1: (42, "hello")
p2: (3.14, true)
```

---

### 示例1.2: 泛型结构体

**目标**: 掌握泛型结构体的定义和使用

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== 单类型参数结构体 =====\n");
    
    #[derive(Debug)]
    struct Point<T> {
        x: T,
        y: T,
    }
    
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };
    
    println!("整数点: {:?}", integer_point);
    println!("浮点数点: {:?}", float_point);
    
    // ❌ 错误：x 和 y 必须是相同类型
    // let mixed_point = Point { x: 5, y: 4.0 };
    
    println!("\n===== 多类型参数结构体 =====\n");
    
    #[derive(Debug)]
    struct MixedPoint<T, U> {
        x: T,
        y: U,
    }
    
    let mixed = MixedPoint { x: 5, y: 4.0 };
    println!("混合点: {:?}", mixed);
    
    let string_point = MixedPoint { x: "x坐标", y: 100 };
    println!("字符串点: {:?}", string_point);
    
    println!("\n===== 泛型结构体方法 =====\n");
    
    impl<T> Point<T> {
        fn x(&self) -> &T {
            &self.x
        }
    }
    
    // 只为特定类型实现方法
    impl Point<f32> {
        fn distance_from_origin(&self) -> f32 {
            (self.x.powi(2) + self.y.powi(2)).sqrt()
        }
    }
    
    let p = Point { x: 5, y: 10 };
    println!("x 坐标: {}", p.x());
    
    let p = Point { x: 3.0, y: 4.0 };
    println!("距离原点: {}", p.distance_from_origin());
    
    println!("\n===== 泛型与生命周期 =====\n");
    
    #[derive(Debug)]
    struct Wrapper<'a, T> {
        value: &'a T,
    }
    
    let num = 42;
    let wrapper = Wrapper { value: &num };
    println!("Wrapper: {:?}", wrapper);
    
    println!("\n===== 关联函数 =====\n");
    
    impl<T, U> MixedPoint<T, U> {
        fn new(x: T, y: U) -> Self {
            MixedPoint { x, y }
        }
        
        fn mixup<V, W>(self, other: MixedPoint<V, W>) -> MixedPoint<T, W> {
            MixedPoint {
                x: self.x,
                y: other.y,
            }
        }
    }
    
    let p1 = MixedPoint::new(5, 10.4);
    let p2 = MixedPoint::new("Hello", 'c');
    
    let p3 = p1.mixup(p2);
    println!("混合后的点: x = {}, y = {}", p3.x, p3.y);
}
```

**说明**:

- **单类型参数**: `Point<T>` 所有字段使用相同类型
- **多类型参数**: `MixedPoint<T, U>` 不同字段可以使用不同类型
- **泛型impl**: `impl<T>` 为泛型类型实现方法
- **特化impl**: 为特定类型（如 f32）实现额外方法

**输出**:

```text
===== 单类型参数结构体 =====

整数点: Point { x: 5, y: 10 }
浮点数点: Point { x: 1.0, y: 4.0 }

===== 多类型参数结构体 =====

混合点: MixedPoint { x: 5, y: 4.0 }
字符串点: MixedPoint { x: "x坐标", y: 100 }

===== 泛型结构体方法 =====

x 坐标: 5
距离原点: 5.0

===== 泛型与生命周期 =====

Wrapper: Wrapper { value: 42 }

===== 关联函数 =====

混合后的点: x = 5, y = c
```

---

### 示例1.3: 泛型枚举

**目标**: 理解泛型枚举的定义和应用

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== Option<T> 标准库泛型枚举 =====\n");
    
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option<i32> = None;
    
    println!("some_number: {:?}", some_number);
    println!("some_string: {:?}", some_string);
    println!("absent_number: {:?}", absent_number);
    
    // 使用 match 处理
    match some_number {
        Some(n) => println!("数字是: {}", n),
        None => println!("没有数字"),
    }
    
    println!("\n===== Result<T, E> 泛型枚举 =====\n");
    
    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err("除数不能为零".to_string())
        } else {
            Ok(a / b)
        }
    }
    
    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("错误: {}", e),
    }
    
    match divide(10.0, 0.0) {
        Ok(result) => println!("10 / 0 = {}", result),
        Err(e) => println!("错误: {}", e),
    }
    
    println!("\n===== 自定义泛型枚举 =====\n");
    
    #[derive(Debug)]
    enum Either<L, R> {
        Left(L),
        Right(R),
    }
    
    let left: Either<i32, &str> = Either::Left(42);
    let right: Either<i32, &str> = Either::Right("hello");
    
    println!("left: {:?}", left);
    println!("right: {:?}", right);
    
    // 实现方法
    impl<L, R> Either<L, R> {
        fn is_left(&self) -> bool {
            matches!(self, Either::Left(_))
        }
        
        fn is_right(&self) -> bool {
            matches!(self, Either::Right(_))
        }
    }
    
    println!("left.is_left(): {}", left.is_left());
    println!("right.is_right(): {}", right.is_right());
    
    println!("\n===== 复杂泛型枚举 =====\n");
    
    #[derive(Debug)]
    enum Tree<T> {
        Empty,
        Node {
            value: T,
            left: Box<Tree<T>>,
            right: Box<Tree<T>>,
        },
    }
    
    impl<T> Tree<T> {
        fn empty() -> Self {
            Tree::Empty
        }
        
        fn leaf(value: T) -> Self {
            Tree::Node {
                value,
                left: Box::new(Tree::Empty),
                right: Box::new(Tree::Empty),
            }
        }
    }
    
    let tree = Tree::Node {
        value: 5,
        left: Box::new(Tree::leaf(3)),
        right: Box::new(Tree::leaf(7)),
    };
    
    println!("二叉树: {:?}", tree);
}
```

**说明**:

- **`Option<T>`**: 标准库中最常用的泛型枚举
- **`Result<T, E>`**: 用于错误处理的泛型枚举
- **自定义枚举**: 可以创建自己的泛型枚举
- **递归结构**: 使用 Box 实现递归泛型枚举

**输出**:

```text
===== Option<T> 标准库泛型枚举 =====

some_number: Some(5)
some_string: Some("a string")
absent_number: None
数字是: 5

===== Result<T, E> 泛型枚举 =====

10 / 2 = 5
错误: 除数不能为零

===== 自定义泛型枚举 =====

left: Left(42)
right: Right("hello")
left.is_left(): true
right.is_right(): true

===== 复杂泛型枚举 =====

二叉树: Node { value: 5, left: Node { value: 3, left: Empty, right: Empty }, right: Node { value: 7, left: Empty, right: Empty } }
```

---

### 示例1.4: Option和Result

**目标**: 深入理解 Option 和 Result 的泛型应用

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== Option<T> 方法链 =====\n");
    
    let numbers = vec![1, 2, 3, 4, 5];
    
    // map: 转换内部值
    let doubled: Option<i32> = Some(5).map(|x| x * 2);
    println!("Some(5).map(|x| x * 2) = {:?}", doubled);
    
    // and_then: 链式操作
    let result = Some(2)
        .and_then(|x| Some(x * 2))
        .and_then(|x| Some(x + 1));
    println!("链式 and_then: {:?}", result);
    
    // filter: 过滤
    let even = Some(4).filter(|x| x % 2 == 0);
    let odd = Some(3).filter(|x| x % 2 == 0);
    println!("Some(4).filter(偶数): {:?}", even);
    println!("Some(3).filter(偶数): {:?}", odd);
    
    // unwrap_or: 提供默认值
    let some_value = Some(100).unwrap_or(0);
    let none_value = None.unwrap_or(0);
    println!("Some(100).unwrap_or(0) = {}", some_value);
    println!("None.unwrap_or(0) = {}", none_value);
    
    println!("\n===== Result<T, E> 方法链 =====\n");
    
    fn parse_positive(s: &str) -> Result<i32, String> {
        s.parse::<i32>()
            .map_err(|e| format!("解析错误: {}", e))
            .and_then(|n| {
                if n > 0 {
                    Ok(n)
                } else {
                    Err("数字必须为正".to_string())
                }
            })
    }
    
    println!("{:?}", parse_positive("42"));
    println!("{:?}", parse_positive("-5"));
    println!("{:?}", parse_positive("abc"));
    
    println!("\n===== ? 操作符 =====\n");
    
    fn read_and_parse(s: &str) -> Result<i32, String> {
        let num = s.parse::<i32>()
            .map_err(|e| format!("解析失败: {}", e))?;
        
        if num > 0 {
            Ok(num)
        } else {
            Err("必须是正数".to_string())
        }
    }
    
    match read_and_parse("42") {
        Ok(n) => println!("解析成功: {}", n),
        Err(e) => println!("解析失败: {}", e),
    }
    
    println!("\n===== 组合 Option 和 Result =====\n");
    
    fn get_user_age(id: i32) -> Option<i32> {
        match id {
            1 => Some(25),
            2 => Some(30),
            _ => None,
        }
    }
    
    fn validate_age(age: i32) -> Result<i32, String> {
        if age >= 18 {
            Ok(age)
        } else {
            Err("未成年".to_string())
        }
    }
    
    // Option -> Result -> Option 的转换
    let result = get_user_age(1)
        .ok_or("用户不存在".to_string())
        .and_then(validate_age);
    
    println!("用户1: {:?}", result);
    
    let result = get_user_age(99)
        .ok_or("用户不存在".to_string())
        .and_then(validate_age);
    
    println!("用户99: {:?}", result);
    
    println!("\n===== transpose =====\n");
    
    // Result<Option<T>> <-> Option<Result<T>>
    let x: Result<Option<i32>, &str> = Ok(Some(5));
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("Ok(Some(5)).transpose() = {:?}", y);
    
    let x: Result<Option<i32>, &str> = Ok(None);
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("Ok(None).transpose() = {:?}", y);
}
```

**说明**:

- **map**: 转换 Option/Result 内部的值
- **and_then**: 链式操作，避免嵌套
- **filter**: 根据条件过滤
- **? 操作符**: 简化错误传播
- **transpose**: Option 和 Result 互换

**输出**:

```text
===== Option<T> 方法链 =====

Some(5).map(|x| x * 2) = Some(10)
链式 and_then: Some(5)
Some(4).filter(偶数): Some(4)
Some(3).filter(偶数): None
Some(100).unwrap_or(0) = 100
None.unwrap_or(0) = 0

===== Result<T, E> 方法链 =====

Ok(42)
Err("数字必须为正")
Err("解析错误: invalid digit found in string")

===== ? 操作符 =====

解析成功: 42

===== 组合 Option 和 Result =====

用户1: Ok(25)
用户99: Err("用户不存在")

===== transpose =====

Ok(Some(5)).transpose() = Some(Ok(5))
Ok(None).transpose() = None
```

---

### 示例1.5: 泛型方法

**目标**: 掌握为泛型类型实现方法

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 为泛型类型实现方法 =====\n");
    
    struct Container<T> {
        value: T,
    }
    
    impl<T> Container<T> {
        fn new(value: T) -> Self {
            Container { value }
        }
        
        fn get(&self) -> &T {
            &self.value
        }
        
        fn set(&mut self, value: T) {
            self.value = value;
        }
        
        // 方法本身也可以是泛型的
        fn into_pair<U>(self, other: U) -> (T, U) {
            (self.value, other)
        }
    }
    
    let mut container = Container::new(42);
    println!("初始值: {}", container.get());
    
    container.set(100);
    println!("修改后: {}", container.get());
    
    let pair = container.into_pair("hello");
    println!("配对: ({}, {})", pair.0, pair.1);
    
    println!("\n===== 为特定类型实现方法 =====\n");
    
    // 只为 Container<String> 实现特定方法
    impl Container<String> {
        fn len(&self) -> usize {
            self.value.len()
        }
        
        fn push_str(&mut self, s: &str) {
            self.value.push_str(s);
        }
    }
    
    let mut container = Container::new(String::from("Hello"));
    println!("字符串长度: {}", container.len());
    
    container.push_str(" World");
    println!("追加后: {}", container.get());
    
    println!("\n===== 带约束的泛型方法 =====\n");
    
    #[derive(Debug)]
    struct Pair<T> {
        first: T,
        second: T,
    }
    
    impl<T> Pair<T> {
        fn new(first: T, second: T) -> Self {
            Pair { first, second }
        }
    }
    
    // 只为实现了 Display 和 PartialOrd 的类型实现方法
    impl<T: std::fmt::Display + PartialOrd> Pair<T> {
        fn cmp_display(&self) {
            if self.first >= self.second {
                println!("最大的是 first: {}", self.first);
            } else {
                println!("最大的是 second: {}", self.second);
            }
        }
    }
    
    let pair = Pair::new(10, 20);
    pair.cmp_display();
    
    let pair = Pair::new("hello", "world");
    pair.cmp_display();
    
    println!("\n===== 多个泛型参数的方法 =====\n");
    
    struct MixedContainer<T, U> {
        first: T,
        second: U,
    }
    
    impl<T, U> MixedContainer<T, U> {
        fn new(first: T, second: U) -> Self {
            MixedContainer { first, second }
        }
        
        fn swap(self) -> MixedContainer<U, T> {
            MixedContainer {
                first: self.second,
                second: self.first,
            }
        }
    }
    
    let container = MixedContainer::new(42, "hello");
    println!("原始: ({}, {})", container.first, container.second);
    
    let swapped = container.swap();
    println!("交换后: ({}, {})", swapped.first, swapped.second);
}
```

**说明**:

- **泛型impl**: `impl<T>` 为所有T实现通用方法
- **特化impl**: 为特定类型实现额外方法
- **Trait约束**: 使用 where 或 `:` 添加约束
- **方法泛型**: 方法本身也可以有泛型参数

**输出**:

```text
===== 为泛型类型实现方法 =====

初始值: 42
修改后: 100
配对: (100, hello)

===== 为特定类型实现方法 =====

字符串长度: 5
追加后: Hello World

===== 带约束的泛型方法 =====

最大的是 second: 20
最大的是 world: world

===== 多个泛型参数的方法 =====

原始: (42, hello)
交换后: (hello, 42)
```

---

### 示例1.6: 基础Trait约束

**目标**: 理解 Trait 约束的语法和使用

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 基础 Trait 约束 =====\n");
    
    // 使用 impl Trait 语法
    fn print_it(item: impl std::fmt::Display) {
        println!("打印: {}", item);
    }
    
    print_it(42);
    print_it("Hello");
    print_it(3.14);
    
    println!("\n===== 泛型参数约束 =====\n");
    
    // 使用泛型参数语法
    fn print_generic<T: std::fmt::Display>(item: T) {
        println!("泛型打印: {}", item);
    }
    
    print_generic(100);
    print_generic("World");
    
    println!("\n===== where 子句 =====\n");
    
    // 使用 where 子句（更清晰）
    fn print_where<T>(item: T)
    where
        T: std::fmt::Display,
    {
        println!("where 打印: {}", item);
    }
    
    print_where(200);
    
    println!("\n===== 多个 Trait 约束 =====\n");
    
    use std::fmt::Display;
    use std::fmt::Debug;
    
    fn print_both<T: Display + Debug>(item: T) {
        println!("Display: {}", item);
        println!("Debug: {:?}", item);
    }
    
    print_both(42);
    
    println!("\n===== Trait 约束与结构体 =====\n");
    
    struct Wrapper<T: Display> {
        value: T,
    }
    
    impl<T: Display> Wrapper<T> {
        fn new(value: T) -> Self {
            Wrapper { value }
        }
        
        fn display(&self) {
            println!("Wrapper 包含: {}", self.value);
        }
    }
    
    let wrapper = Wrapper::new("Hello");
    wrapper.display();
    
    println!("\n===== 返回值 Trait 约束 =====\n");
    
    // 返回实现了 Display 的类型
    fn get_display() -> impl Display {
        42
    }
    
    println!("返回值: {}", get_display());
    
    println!("\n===== Clone 约束示例 =====\n");
    
    fn duplicate<T: Clone>(value: &T) -> (T, T) {
        (value.clone(), value.clone())
    }
    
    let original = String::from("hello");
    let (copy1, copy2) = duplicate(&original);
    
    println!("原始: {}", original);
    println!("副本1: {}", copy1);
    println!("副本2: {}", copy2);
    
    println!("\n===== 组合约束示例 =====\n");
    
    fn process<T>(items: Vec<T>)
    where
        T: Display + Clone + PartialOrd,
    {
        if items.is_empty() {
            return;
        }
        
        let first = items[0].clone();
        println!("第一个元素: {}", first);
        
        let max = items.iter()
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap();
        println!("最大元素: {}", max);
    }
    
    let numbers = vec![3, 1, 4, 1, 5, 9];
    process(numbers);
}
```

**说明**:

- **impl Trait**: 简洁的 Trait 约束语法
- **泛型约束**: `<T: Trait>` 显式声明约束
- **where子句**: 复杂约束的清晰表达
- **多重约束**: 使用 `+` 组合多个 Trait
- **结构体约束**: 为泛型结构体添加约束

**输出**:

```text
===== 基础 Trait 约束 =====

打印: 42
打印: Hello
打印: 3.14

===== 泛型参数约束 =====

泛型打印: 100
泛型打印: World

===== where 子句 =====

where 打印: 200

===== 多个 Trait 约束 =====

Display: 42
Debug: 42

===== Trait 约束与结构体 =====

Wrapper 包含: Hello

===== 返回值 Trait 约束 =====

返回值: 42

===== Clone 约束示例 =====

原始: hello
副本1: hello
副本2: hello

===== 组合约束示例 =====

第一个元素: 3
最大元素: 9
```

---

## 🎓 Tier 2: 实践层示例

### 示例2.1: Trait对象与泛型对比

**目标**: 理解静态分派和动态分派的区别

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 静态分派 (泛型) =====\n");
    
    trait Draw {
        fn draw(&self);
    }
    
    struct Circle { radius: f64 }
    struct Square { side: f64 }
    
    impl Draw for Circle {
        fn draw(&self) {
            println!("绘制圆形，半径: {}", self.radius);
        }
    }
    
    impl Draw for Square {
        fn draw(&self) {
            println!("绘制正方形，边长: {}", self.side);
        }
    }
    
    // 静态分派：编译时确定类型
    fn draw_static<T: Draw>(shape: &T) {
        shape.draw();
    }
    
    let circle = Circle { radius: 5.0 };
    let square = Square { side: 10.0 };
    
    draw_static(&circle);
    draw_static(&square);
    
    println!("\n===== 动态分派 (Trait 对象) =====\n");
    
    // 动态分派：运行时确定类型
    fn draw_dynamic(shape: &dyn Draw) {
        shape.draw();
    }
    
    draw_dynamic(&circle);
    draw_dynamic(&square);
    
    println!("\n===== 异构集合 (只能用 Trait 对象) =====\n");
    
    // ❌ 泛型无法做到：
    // let shapes: Vec<T> = vec![circle, square]; // 错误：类型不同
    
    // ✅ Trait 对象可以：
    let shapes: Vec<Box<dyn Draw>> = vec![
        Box::new(Circle { radius: 3.0 }),
        Box::new(Square { side: 7.0 }),
        Box::new(Circle { radius: 2.0 }),
    ];
    
    for shape in &shapes {
        shape.draw();
    }
    
    println!("\n===== 性能对比 =====\n");
    
    use std::time::Instant;
    
    // 静态分派：零成本抽象
    let start = Instant::now();
    for _ in 0..1_000_000 {
        draw_static(&circle);
    }
    let static_time = start.elapsed();
    
    // 动态分派：有虚函数表开销
    let start = Instant::now();
    for _ in 0..1_000_000 {
        draw_dynamic(&circle);
    }
    let dynamic_time = start.elapsed();
    
    println!("静态分派耗时: {:?}", static_time);
    println!("动态分派耗时: {:?}", dynamic_time);
    
    println!("\n===== 使用场景对比 =====\n");
    
    println!("静态分派 (泛型):");
    println!("  ✅ 零成本抽象，性能最优");
    println!("  ✅ 编译时类型检查");
    println!("  ✅ 可以内联优化");
    println!("  ❌ 无法存储不同类型到同一集合");
    println!("  ❌ 会生成多份代码（单态化）");
    
    println!("\n动态分派 (Trait 对象):");
    println!("  ✅ 可以存储不同类型到同一集合");
    println!("  ✅ 代码大小更小");
    println!("  ✅ 运行时多态");
    println!("  ❌ 有虚函数表开销");
    println!("  ❌ 无法内联");
}
```

**说明**:

- **静态分派**: 泛型在编译时确定类型，零成本
- **动态分派**: Trait 对象在运行时确定类型，有开销
- **单态化**: 泛型为每种类型生成单独的代码
- **异构集合**: 只有 Trait 对象可以存储不同类型

**输出**:

```text
===== 静态分派 (泛型) =====

绘制圆形，半径: 5
绘制正方形，边长: 10

===== 动态分派 (Trait 对象) =====

绘制圆形，半径: 5
绘制正方形，边长: 10

===== 异构集合 (只能用 Trait 对象) =====

绘制圆形，半径: 3
绘制正方形，边长: 7
绘制圆形，半径: 2

===== 性能对比 =====

静态分派耗时: 0s
动态分派耗时: 0s

===== 使用场景对比 =====

静态分派 (泛型):
  ✅ 零成本抽象，性能最优
  ✅ 编译时类型检查
  ✅ 可以内联优化
  ❌ 无法存储不同类型到同一集合
  ❌ 会生成多份代码（单态化）

动态分派 (Trait 对象):
  ✅ 可以存储不同类型到同一集合
  ✅ 代码大小更小
  ✅ 运行时多态
  ❌ 有虚函数表开销
  ❌ 无法内联
```

---

### 示例2.2: 关联类型详解

**目标**: 掌握关联类型的定义和使用

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 为什么需要关联类型？ =====\n");
    
    // 不使用关联类型：需要额外的类型参数
    trait IteratorBad<T> {
        fn next(&mut self) -> Option<T>;
    }
    
    // 使用关联类型：更简洁
    trait IteratorGood {
        type Item;  // 关联类型
        fn next(&mut self) -> Option<Self::Item>;
    }
    
    println!("✅ 关联类型让 Trait 更简洁易用\n");
    
    println!("===== 实现关联类型 =====\n");
    
    struct Counter {
        count: u32,
    }
    
    impl Counter {
        fn new() -> Counter {
            Counter { count: 0 }
        }
    }
    
    impl IteratorGood for Counter {
        type Item = u32;  // 指定关联类型
        
        fn next(&mut self) -> Option<Self::Item> {
            if self.count < 5 {
                self.count += 1;
                Some(self.count)
            } else {
                None
            }
        }
    }
    
    let mut counter = Counter::new();
    while let Some(n) = counter.next() {
        print!("{} ", n);
    }
    println!("\n");
    
    println!("===== 关联类型约束 =====\n");
    
    // 可以对关联类型添加约束
    trait Container {
        type Item: std::fmt::Display;  // Item 必须实现 Display
        
        fn get(&self, index: usize) -> Option<&Self::Item>;
    }
    
    struct StringVec {
        data: Vec<String>,
    }
    
    impl Container for StringVec {
        type Item = String;
        
        fn get(&self, index: usize) -> Option<&Self::Item> {
            self.data.get(index)
        }
    }
    
    let container = StringVec {
        data: vec!["Hello".to_string(), "World".to_string()],
    };
    
    if let Some(item) = container.get(0) {
        println!("第一个元素: {}", item);
    }
    
    println!("\n===== 多个关联类型 =====\n");
    
    trait Graph {
        type Node;
        type Edge;
        
        fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool;
    }
    
    struct IntGraph {
        edges: Vec<(i32, i32)>,
    }
    
    impl Graph for IntGraph {
        type Node = i32;
        type Edge = (i32, i32);
        
        fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool {
            self.edges.contains(&(*from, *to))
        }
    }
    
    let graph = IntGraph {
        edges: vec![(1, 2), (2, 3), (3, 1)],
    };
    
    println!("有边 1->2? {}", graph.has_edge(&1, &2));
    println!("有边 1->3? {}", graph.has_edge(&1, &3));
    
    println!("\n===== 关联类型 vs 泛型参数 =====\n");
    
    // 关联类型：每个类型只能有一个实现
    trait ConvertTo {
        type Output;
        fn convert(self) -> Self::Output;
    }
    
    impl ConvertTo for i32 {
        type Output = f64;
        fn convert(self) -> Self::Output {
            self as f64
        }
    }
    
    // ❌ 不能有第二个实现：
    // impl ConvertTo for i32 {
    //     type Output = String;
    //     fn convert(self) -> Self::Output {
    //         self.to_string()
    //     }
    // }
    
    let num = 42;
    let float = num.convert();
    println!("i32 转 f64: {}", float);
    
    // 泛型参数：可以有多个实现
    trait Convert<T> {
        fn convert(self) -> T;
    }
    
    impl Convert<f64> for i32 {
        fn convert(self) -> f64 {
            self as f64
        }
    }
    
    impl Convert<String> for i32 {
        fn convert(self) -> String {
            self.to_string()
        }
    }
    
    let num = 42;
    let float: f64 = num.convert();
    let string: String = num.convert();
    println!("i32 转 f64: {}", float);
    println!("i32 转 String: {}", string);
    
    println!("\n===== 总结 =====\n");
    
    println!("关联类型:");
    println!("  ✅ 每个类型只有一个实现");
    println!("  ✅ 简化 Trait 定义");
    println!("  ✅ 更好的类型推断");
    
    println!("\n泛型参数:");
    println!("  ✅ 可以有多个实现");
    println!("  ✅ 更灵活");
    println!("  ❌ 需要显式指定类型");
}
```

**说明**:

- **关联类型**: 使用 `type Item` 定义
- **简化Trait**: 避免额外的泛型参数
- **唯一性**: 每个类型只能有一个关联类型实现
- **约束**: 可以对关联类型添加 Trait 约束

**输出**:

```text
===== 为什么需要关联类型？ =====

✅ 关联类型让 Trait 更简洁易用

===== 实现关联类型 =====

1 2 3 4 5 

===== 关联类型约束 =====

第一个元素: Hello

===== 多个关联类型 =====

有边 1->2? true
有边 1->3? false

===== 关联类型 vs 泛型参数 =====

i32 转 f64: 42
i32 转 f64: 42
i32 转 String: 42

===== 总结 =====

关联类型:
  ✅ 每个类型只有一个实现
  ✅ 简化 Trait 定义
  ✅ 更好的类型推断

泛型参数:
  ✅ 可以有多个实现
  ✅ 更灵活
  ❌ 需要显式指定类型
```

---

### 示例2.3: 泛型与生命周期

**目标**: 理解泛型参数与生命周期参数的结合使用

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 泛型函数与生命周期 =====\n");
    
    // 泛型函数需要生命周期标注
    fn longest<'a, T>(x: &'a T, y: &'a T) -> &'a T
    where
        T: PartialOrd,
    {
        if x > y { x } else { y }
    }
    
    let s1 = String::from("hello");
    let s2 = String::from("world");
    let result = longest(&s1, &s2);
    println!("较大的字符串: {}", result);
    
    let n1 = 42;
    let n2 = 100;
    let result = longest(&n1, &n2);
    println!("较大的数字: {}", result);
    
    println!("\n===== 结构体的泛型和生命周期 =====\n");
    
    struct Holder<'a, T> {
        value: &'a T,
    }
    
    impl<'a, T> Holder<'a, T> {
        fn new(value: &'a T) -> Self {
            Holder { value }
        }
        
        fn get(&self) -> &T {
            self.value
        }
    }
    
    let num = 42;
    let holder = Holder::new(&num);
    println!("Holder 中的值: {}", holder.get());
    
    println!("\n===== 多个生命周期参数 =====\n");
    
    struct Pair<'a, 'b, T, U> {
        first: &'a T,
        second: &'b U,
    }
    
    impl<'a, 'b, T, U> Pair<'a, 'b, T, U> {
        fn new(first: &'a T, second: &'b U) -> Self {
            Pair { first, second }
        }
    }
    
    let x = 10;
    let y = String::from("test");
    let pair = Pair::new(&x, &y);
    println!("Pair: ({}, {})", pair.first, pair.second);
    
    println!("\n===== Trait 约束与生命周期 =====\n");
    
    use std::fmt::Display;
    
    fn print_info<'a, T>(item: &'a T) -> &'a T
    where
        T: Display,
    {
        println!("值: {}", item);
        item
    }
    
    let text = "Hello, Rust!";
    let result = print_info(&text);
    println!("返回值: {}", result);
    
    println!("\n===== 静态生命周期与泛型 =====\n");
    
    fn get_static<T: Display>(value: &'static T) -> &'static T {
        println!("静态值: {}", value);
        value
    }
    
    const CONST_STR: &str = "我是静态的";
    let result = get_static(&CONST_STR);
    println!("返回: {}", result);
    
    println!("\n===== 泛型方法的生命周期 =====\n");
    
    struct Container<T> {
        items: Vec<T>,
    }
    
    impl<T> Container<T> {
        fn new() -> Self {
            Container { items: Vec::new() }
        }
        
        fn add(&mut self, item: T) {
            self.items.push(item);
        }
        
        // 泛型方法带生命周期
        fn get<'a>(&'a self, index: usize) -> Option<&'a T> {
            self.items.get(index)
        }
    }
    
    let mut container = Container::new();
    container.add(1);
    container.add(2);
    container.add(3);
    
    if let Some(value) = container.get(1) {
        println!("索引1的值: {}", value);
    }
}
```

**说明**:

- **生命周期标注**: 泛型函数可能需要生命周期参数
- **结构体生命周期**: 泛型结构体可以包含引用
- **多个生命周期**: 不同字段可以有不同生命周期
- **Trait 约束**: 生命周期和 Trait 约束可以共存

**输出**:

```text
===== 泛型函数与生命周期 =====

较大的字符串: world
较大的数字: 100

===== 结构体的泛型和生命周期 =====

Holder 中的值: 42

===== 多个生命周期参数 =====

Pair: (10, test)

===== Trait 约束与生命周期 =====

值: Hello, Rust!
返回值: Hello, Rust!

===== 静态生命周期与泛型 =====

静态值: 我是静态的
返回: 我是静态的

===== 泛型方法的生命周期 =====

索引1的值: 2
```

---

### 示例2.4: 多Trait约束

**目标**: 掌握多个 Trait 约束的使用方法

**难度**: ⭐⭐⭐

**代码**:

```rust
use std::fmt::{Debug, Display};

fn main() {
    println!("===== 使用 + 连接多个 Trait =====\n");
    
    // 函数需要多个 Trait 约束
    fn print_debug_display<T: Debug + Display>(value: &T) {
        println!("Display: {}", value);
        println!("Debug: {:?}", value);
    }
    
    let num = 42;
    print_debug_display(&num);
    
    println!("\n===== 使用 where 子句 =====\n");
    
    fn complex_function<T, U>(t: &T, u: &U)
    where
        T: Debug + Display + Clone,
        U: Debug + Display,
    {
        println!("T: {}, U: {}", t, u);
        let t_clone = t.clone();
        println!("T clone: {}", t_clone);
    }
    
    let s = String::from("hello");
    let n = 100;
    complex_function(&s, &n);
    
    println!("\n===== 结构体的多重约束 =====\n");
    
    struct Pair<T, U>
    where
        T: Debug + Display,
        U: Debug + Display,
    {
        first: T,
        second: U,
    }
    
    impl<T, U> Pair<T, U>
    where
        T: Debug + Display,
        U: Debug + Display,
    {
        fn new(first: T, second: U) -> Self {
            Pair { first, second }
        }
        
        fn show(&self) {
            println!("Pair: ({}, {})", self.first, self.second);
            println!("Debug: ({:?}, {:?})", self.first, self.second);
        }
    }
    
    let pair = Pair::new("Rust", 2024);
    pair.show();
    
    println!("\n===== Trait 组合 =====\n");
    
    trait Printable: Debug + Display {}
    
    // 自动为满足条件的类型实现
    impl<T: Debug + Display> Printable for T {}
    
    fn show_printable<T: Printable>(value: &T) {
        println!("值: {} ({:?})", value, value);
    }
    
    show_printable(&"Hello");
    show_printable(&42);
    
    println!("\n===== 条件实现 =====\n");
    
    struct Wrapper<T>(T);
    
    // 只有当 T 实现了 Display 时，Wrapper<T> 才实现 Display
    impl<T: Display> Display for Wrapper<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "Wrapper({})", self.0)
        }
    }
    
    let wrapper = Wrapper(42);
    println!("{}", wrapper);
    
    println!("\n===== Clone + Copy 约束 =====\n");
    
    fn duplicate<T: Clone>(value: &T) -> (T, T) {
        (value.clone(), value.clone())
    }
    
    let original = vec![1, 2, 3];
    let (copy1, copy2) = duplicate(&original);
    println!("原始: {:?}", original);
    println!("复制1: {:?}, 复制2: {:?}", copy1, copy2);
    
    println!("\n===== PartialEq + Ord 约束 =====\n");
    
    fn find_max<T>(items: &[T]) -> Option<&T>
    where
        T: PartialOrd,
    {
        items.iter().max_by(|a, b| a.partial_cmp(b).unwrap())
    }
    
    let numbers = vec![3, 1, 4, 1, 5, 9, 2, 6];
    if let Some(max) = find_max(&numbers) {
        println!("最大值: {}", max);
    }
}
```

**说明**:

- **+ 连接**: 使用 `T: Trait1 + Trait2` 语法
- **where 子句**: 复杂约束使用 where 更清晰
- **Trait 组合**: 定义新 Trait 继承多个 Trait
- **条件实现**: 根据类型参数约束选择性实现

**输出**:

```text
===== 使用 + 连接多个 Trait =====

Display: 42
Debug: 42

===== 使用 where 子句 =====

T: hello, U: 100
T clone: hello

===== 结构体的多重约束 =====

Pair: (Rust, 2024)
Debug: ("Rust", 2024)

===== Trait 组合 =====

值: Hello ("Hello")
值: 42 (42)

===== 条件实现 =====

Wrapper(42)

===== Clone + Copy 约束 =====

原始: [1, 2, 3]
复制1: [1, 2, 3], 复制2: [1, 2, 3]

===== PartialEq + Ord 约束 =====

最大值: 9
```

---

### 示例2.5: Const泛型

**目标**: 理解常量泛型参数的使用

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 基础 Const 泛型 =====\n");
    
    // 固定大小的数组结构
    struct Array<T, const N: usize> {
        data: [T; N],
    }
    
    impl<T, const N: usize> Array<T, N> {
        fn len(&self) -> usize {
            N
        }
    }
    
    let arr = Array { data: [1, 2, 3, 4, 5] };
    println!("数组长度: {}", arr.len());
    
    println!("\n===== Const 泛型函数 =====\n");
    
    fn print_array<T: std::fmt::Display, const N: usize>(arr: &[T; N]) {
        print!("[");
        for (i, item) in arr.iter().enumerate() {
            if i > 0 { print!(", "); }
            print!("{}", item);
        }
        println!("]");
        println!("长度: {}", N);
    }
    
    let numbers = [1, 2, 3, 4, 5];
    print_array(&numbers);
    
    let words = ["hello", "world"];
    print_array(&words);
    
    println!("\n===== Const 泛型的类型安全 =====\n");
    
    // 编译时保证长度
    fn concat<const N: usize, const M: usize>(
        a: [i32; N],
        b: [i32; M]
    ) -> Vec<i32> {
        let mut result = Vec::with_capacity(N + M);
        result.extend_from_slice(&a);
        result.extend_from_slice(&b);
        result
    }
    
    let arr1 = [1, 2, 3];
    let arr2 = [4, 5];
    let combined = concat(arr1, arr2);
    println!("合并数组: {:?}", combined);
    println!("合并长度: {} + {} = {}", 3, 2, combined.len());
    
    println!("\n===== 矩阵示例 =====\n");
    
    #[derive(Debug)]
    struct Matrix<T, const ROWS: usize, const COLS: usize> {
        data: [[T; COLS]; ROWS],
    }
    
    impl<T: Copy, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS> {
        fn new(value: T) -> Self {
            Matrix {
                data: [[value; COLS]; ROWS],
            }
        }
        
        fn set(&mut self, row: usize, col: usize, value: T) {
            self.data[row][col] = value;
        }
        
        fn get(&self, row: usize, col: usize) -> T {
            self.data[row][col]
        }
    }
    
    let mut matrix: Matrix<i32, 3, 3> = Matrix::new(0);
    matrix.set(0, 0, 1);
    matrix.set(1, 1, 2);
    matrix.set(2, 2, 3);
    
    println!("Matrix<i32, 3, 3>:");
    for row in 0..3 {
        for col in 0..3 {
            print!("{} ", matrix.get(row, col));
        }
        println!();
    }
    
    println!("\n===== 零成本抽象验证 =====\n");
    
    struct Stack<T, const CAP: usize> {
        data: [Option<T>; CAP],
        len: usize,
    }
    
    impl<T: Copy, const CAP: usize> Stack<T, CAP> {
        fn new() -> Self {
            Stack {
                data: [None; CAP],
                len: 0,
            }
        }
        
        fn push(&mut self, value: T) -> Result<(), &'static str> {
            if self.len < CAP {
                self.data[self.len] = Some(value);
                self.len += 1;
                Ok(())
            } else {
                Err("Stack overflow")
            }
        }
        
        fn pop(&mut self) -> Option<T> {
            if self.len > 0 {
                self.len -= 1;
                self.data[self.len].take()
            } else {
                None
            }
        }
        
        fn capacity(&self) -> usize {
            CAP
        }
    }
    
    let mut stack: Stack<i32, 5> = Stack::new();
    stack.push(1).unwrap();
    stack.push(2).unwrap();
    stack.push(3).unwrap();
    
    println!("Stack 容量: {}", stack.capacity());
    println!("Pop: {:?}", stack.pop());
    println!("Pop: {:?}", stack.pop());
}
```

**说明**:

- **const 参数**: 使用 `const N: usize` 定义常量泛型
- **编译时检查**: 数组大小在编译时确定
- **类型安全**: 不同大小的数组是不同类型
- **零成本**: 编译时展开，无运行时开销

**输出**:

```text
===== 基础 Const 泛型 =====

数组长度: 5

===== Const 泛型函数 =====

[1, 2, 3, 4, 5]
长度: 5
[hello, world]
长度: 2

===== Const 泛型的类型安全 =====

合并数组: [1, 2, 3, 4, 5]
合并长度: 3 + 2 = 5

===== 矩阵示例 =====

Matrix<i32, 3, 3>:
1 0 0 
0 2 0 
0 0 3 

===== 零成本抽象验证 =====

Stack 容量: 5
Pop: Some(3)
Pop: Some(2)
```

---

### 示例2.6: 默认类型参数

**目标**: 理解泛型参数的默认值使用

**难度**: ⭐⭐

**代码**:

```rust
use std::fmt::Display;

fn main() {
    println!("===== 基础默认类型参数 =====\n");
    
    // 默认类型参数为 String
    struct Container<T = String> {
        value: T,
    }
    
    // 使用默认类型
    let default_container = Container { value: "Hello".to_string() };
    println!("默认容器 (String): {}", default_container.value);
    
    // 指定类型
    let int_container: Container<i32> = Container { value: 42 };
    println!("整数容器: {}", int_container.value);
    
    println!("\n===== 多个默认类型参数 =====\n");
    
    struct Point<X = f64, Y = f64> {
        x: X,
        y: Y,
    }
    
    // 全部使用默认
    let p1 = Point { x: 1.0, y: 2.0 };
    println!("Point<f64, f64>: ({}, {})", p1.x, p1.y);
    
    // 部分指定
    let p2: Point<i32, _> = Point { x: 1, y: 2.0 };
    println!("Point<i32, f64>: ({}, {})", p2.x, p2.y);
    
    // 全部指定
    let p3: Point<i32, i32> = Point { x: 1, y: 2 };
    println!("Point<i32, i32>: ({}, {})", p3.x, p3.y);
    
    println!("\n===== Trait 的默认类型参数 =====\n");
    
    trait Add<RHS = Self> {
        type Output;
        fn add(self, rhs: RHS) -> Self::Output;
    }
    
    #[derive(Debug, Clone, Copy)]
    struct Millimeters(u32);
    
    #[derive(Debug, Clone, Copy)]
    struct Meters(u32);
    
    // 自相加（使用默认 RHS = Self）
    impl Add for Millimeters {
        type Output = Millimeters;
        
        fn add(self, other: Millimeters) -> Millimeters {
            Millimeters(self.0 + other.0)
        }
    }
    
    // 与不同类型相加（指定 RHS）
    impl Add<Meters> for Millimeters {
        type Output = Millimeters;
        
        fn add(self, other: Meters) -> Millimeters {
            Millimeters(self.0 + (other.0 * 1000))
        }
    }
    
    let mm1 = Millimeters(100);
    let mm2 = Millimeters(200);
    let sum1 = mm1.add(mm2);
    println!("100mm + 200mm = {:?}", sum1);
    
    let m1 = Meters(1);
    let sum2 = mm1.add(m1);
    println!("100mm + 1m = {:?}", sum2);
    
    println!("\n===== 实用示例: Builder 模式 =====\n");
    
    struct Config<T = String, U = i32> {
        name: T,
        value: U,
    }
    
    impl<T, U> Config<T, U> {
        fn new(name: T, value: U) -> Self {
            Config { name, value }
        }
    }
    
    impl<T: Display, U: Display> Config<T, U> {
        fn display(&self) {
            println!("{}: {}", self.name, self.value);
        }
    }
    
    // 使用默认类型
    let config1 = Config::new("timeout".to_string(), 30);
    config1.display();
    
    // 指定类型
    let config2 = Config::new("ratio", 0.75);
    config2.display();
    
    println!("\n===== 可选类型包装器 =====\n");
    
    struct Wrapper<T, U = ()> {
        primary: T,
        secondary: Option<U>,
    }
    
    impl<T> Wrapper<T, ()> {
        fn new(primary: T) -> Self {
            Wrapper {
                primary,
                secondary: None,
            }
        }
    }
    
    impl<T, U> Wrapper<T, U> {
        fn with_secondary(primary: T, secondary: U) -> Self {
            Wrapper {
                primary,
                secondary: Some(secondary),
            }
        }
    }
    
    let simple = Wrapper::new(42);
    println!("简单包装: {}", simple.primary);
    
    let complex = Wrapper::with_secondary("data", 123);
    println!("复杂包装: {} - {:?}", complex.primary, complex.secondary);
}
```

**说明**:

- **默认值**: 使用 `T = DefaultType` 语法
- **简化API**: 常见情况不需要指定类型
- **灵活性**: 可以覆盖默认值
- **Trait默认**: `RHS = Self` 是标准库的常见模式

**输出**:

```text
===== 基础默认类型参数 =====

默认容器 (String): Hello
整数容器: 42

===== 多个默认类型参数 =====

Point<f64, f64>: (1, 2)
Point<i32, f64>: (1, 2)
Point<i32, i32>: (1, 2)

===== Trait 的默认类型参数 =====

100mm + 200mm = Millimeters(300)
100mm + 1m = Millimeters(1100)

===== 实用示例: Builder 模式 =====

timeout: 30
ratio: 0.75

===== 可选类型包装器 =====

简单包装: 42
复杂包装: data - Some(123)
```

---

## 🚀 Tier 3: 高级层示例

### 示例3.1: 高阶Trait约束 (HRTB)

**目标**: 理解高阶 Trait 约束（Higher-Rank Trait Bounds）

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 什么是 HRTB? =====\n");
    
    // HRTB 允许我们对所有生命周期进行约束
    // 语法: for<'a> 表示"对于所有生命周期 'a"
    
    println!("问题: 如何编写一个接受任意生命周期闭包的函数?\n");
    
    println!("===== HRTB 基础示例 =====\n");
    
    // 使用 HRTB 的函数
    fn call_with_ref<F>(f: F)
    where
        F: for<'a> Fn(&'a str) -> &'a str,
    {
        let s = "hello";
        let result = f(s);
        println!("结果: {}", result);
    }
    
    call_with_ref(|s| s);
    call_with_ref(|s| if s.len() > 3 { s } else { "short" });
    
    println!("\n===== HRTB vs 普通生命周期 =====\n");
    
    // 不使用 HRTB（需要指定生命周期）
    fn call_with_ref_normal<'a, F>(f: F, s: &'a str)
    where
        F: Fn(&'a str) -> &'a str,
    {
        println!("结果: {}", f(s));
    }
    
    call_with_ref_normal(|s| s, "test");
    
    println!("\n===== 实用示例: 映射函数 =====\n");
    
    struct Container<T> {
        value: T,
    }
    
    impl<T> Container<T> {
        fn map<F, U>(self, f: F) -> Container<U>
        where
            F: FnOnce(T) -> U,
        {
            Container { value: f(self.value) }
        }
        
        // HRTB: 映射引用
        fn map_ref<F, U>(&self, f: F) -> U
        where
            F: for<'a> FnOnce(&'a T) -> U,
        {
            f(&self.value)
        }
    }
    
    let container = Container { value: String::from("Rust") };
    let length = container.map_ref(|s| s.len());
    println!("字符串长度: {}", length);
    
    println!("\n===== HRTB 与 Trait 对象 =====\n");
    
    // HRTB 可以用于 Trait 对象
    trait Processor {
        fn process<'a>(&self, input: &'a str) -> &'a str;
    }
    
    struct UpperCase;
    
    impl Processor for UpperCase {
        fn process<'a>(&self, input: &'a str) -> &'a str {
            // 注意: 实际上 to_uppercase 返回 String
            // 这里简化演示
            input
        }
    }
    
    fn use_processor<P>(processor: &P, text: &str)
    where
        P: for<'a> Fn(&'a str) -> &'a str,
    {
        println!("处理结果: {}", processor(text));
    }
    
    use_processor(&|s| s, "hello");
    
    println!("\n===== 复杂 HRTB 场景 =====\n");
    
    // 多个生命周期参数
    fn complex_hrtb<F>(f: F)
    where
        F: for<'a, 'b> Fn(&'a str, &'b str) -> bool,
    {
        let s1 = "hello";
        let s2 = "world";
        println!("比较结果: {}", f(s1, s2));
    }
    
    complex_hrtb(|a, b| a.len() > b.len());
    complex_hrtb(|a, b| a == b);
}
```

**说明**:

- **for<'a>**: 对所有生命周期 'a 成立
- **灵活性**: 允许闭包处理任意生命周期的引用
- **Trait约束**: 可用于泛型参数和 Trait 对象
- **复杂场景**: 可以有多个生命周期参数

**输出**:

```text
===== 什么是 HRTB? =====

问题: 如何编写一个接受任意生命周期闭包的函数?

===== HRTB 基础示例 =====

结果: hello
结果: hello

===== HRTB vs 普通生命周期 =====

结果: test

===== 实用示例: 映射函数 =====

字符串长度: 4

===== HRTB 与 Trait 对象 =====

处理结果: hello

===== 复杂 HRTB 场景 =====

比较结果: false
比较结果: false
```

---

### 示例3.2: 类型级编程

**目标**: 理解如何在类型级别进行编程

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 类型级编程基础 =====\n");
    
    // 使用类型系统表示数字
    trait PeanoNumber {}
    
    struct Zero;
    struct Succ<N: PeanoNumber>(std::marker::PhantomData<N>);
    
    impl PeanoNumber for Zero {}
    impl<N: PeanoNumber> PeanoNumber for Succ<N> {}
    
    // 类型级加法
    trait Add<N: PeanoNumber> {
        type Output: PeanoNumber;
    }
    
    // Zero + N = N
    impl<N: PeanoNumber> Add<N> for Zero {
        type Output = N;
    }
    
    // Succ(M) + N = Succ(M + N)
    impl<M: PeanoNumber + Add<N>, N: PeanoNumber> Add<N> for Succ<M>
    where
        M::Output: PeanoNumber,
    {
        type Output = Succ<M::Output>;
    }
    
    type One = Succ<Zero>;
    type Two = Succ<One>;
    type Three = <One as Add<Two>>::Output;
    
    println!("✅ 类型级数字定义完成");
    println!("   One = Succ<Zero>");
    println!("   Two = Succ<One>");
    println!("   Three = One + Two");
    
    println!("\n===== 类型级布尔值 =====\n");
    
    trait Bool {
        const VALUE: bool;
    }
    
    struct True;
    struct False;
    
    impl Bool for True {
        const VALUE: bool = true;
    }
    
    impl Bool for False {
        const VALUE: bool = false;
    }
    
    // 类型级 AND
    trait And<B: Bool> {
        type Output: Bool;
    }
    
    impl<B: Bool> And<B> for False {
        type Output = False;
    }
    
    impl And<False> for True {
        type Output = False;
    }
    
    impl And<True> for True {
        type Output = True;
    }
    
    type Result1 = <True as And<True>>::Output;
    type Result2 = <True as And<False>>::Output;
    
    println!("True AND True = {}", <Result1 as Bool>::VALUE);
    println!("True AND False = {}", <Result2 as Bool>::VALUE);
    
    println!("\n===== 类型级列表 =====\n");
    
    trait TypeList {}
    
    struct Nil;
    struct Cons<H, T: TypeList>(std::marker::PhantomData<(H, T)>);
    
    impl TypeList for Nil {}
    impl<H, T: TypeList> TypeList for Cons<H, T> {}
    
    // 类型级列表长度
    trait Len {
        const LENGTH: usize;
    }
    
    impl Len for Nil {
        const LENGTH: usize = 0;
    }
    
    impl<H, T: TypeList + Len> Len for Cons<H, T> {
        const LENGTH: usize = 1 + T::LENGTH;
    }
    
    type MyList = Cons<i32, Cons<bool, Cons<String, Nil>>>;
    
    println!("列表类型: Cons<i32, Cons<bool, Cons<String, Nil>>>");
    println!("列表长度: {}", <MyList as Len>::LENGTH);
    
    println!("\n===== 实用示例: 类型安全的状态机 =====\n");
    
    // 状态标记
    struct Locked;
    struct Unlocked;
    
    struct StateMachine<State> {
        _state: std::marker::PhantomData<State>,
    }
    
    impl StateMachine<Locked> {
        fn new() -> Self {
            println!("创建: Locked 状态");
            StateMachine { _state: std::marker::PhantomData }
        }
        
        fn unlock(self) -> StateMachine<Unlocked> {
            println!("转换: Locked -> Unlocked");
            StateMachine { _state: std::marker::PhantomData }
        }
    }
    
    impl StateMachine<Unlocked> {
        fn lock(self) -> StateMachine<Locked> {
            println!("转换: Unlocked -> Locked");
            StateMachine { _state: std::marker::PhantomData }
        }
        
        fn access(&self) {
            println!("访问: 仅在 Unlocked 状态可用");
        }
    }
    
    let machine = StateMachine::<Locked>::new();
    let unlocked = machine.unlock();
    unlocked.access();
    let locked = unlocked.lock();
    // locked.access(); // 编译错误！
    
    println!("\n===== 总结 =====\n");
    println!("类型级编程的优势:");
    println!("  ✅ 编译时验证");
    println!("  ✅ 零运行时开销");
    println!("  ✅ 类型安全保证");
}
```

**说明**:

- **类型作为值**: 在类型层面表示数据
- **编译时计算**: 所有计算在编译期完成
- **零开销**: 运行时无额外成本
- **类型安全**: 编译器保证正确性

**输出**:

```text
===== 类型级编程基础 =====

✅ 类型级数字定义完成
   One = Succ<Zero>
   Two = Succ<One>
   Three = One + Two

===== 类型级布尔值 =====

True AND True = true
True AND False = false

===== 类型级列表 =====

列表类型: Cons<i32, Cons<bool, Cons<String, Nil>>>
列表长度: 3

===== 实用示例: 类型安全的状态机 =====

创建: Locked 状态
转换: Locked -> Unlocked
访问: 仅在 Unlocked 状态可用
转换: Unlocked -> Locked

===== 总结 =====

类型级编程的优势:
  ✅ 编译时验证
  ✅ 零运行时开销
  ✅ 类型安全保证
```

---

### 示例3.3: 泛型特化模拟

**目标**: 理解如何在 Rust 中模拟泛型特化

**难度**: ⭐⭐⭐⭐

**说明**: Rust 目前还没有稳定泛型特化，但可以通过其他方式实现类似效果。

**代码**:

```rust
fn main() {
    println!("===== 使用 Trait 实现特化 =====\n");
    
    // 通用实现
    trait Stringify {
        fn stringify(&self) -> String;
    }
    
    // 为所有类型提供默认实现
    impl<T: std::fmt::Debug> Stringify for T {
        fn stringify(&self) -> String {
            format!("{:?}", self)
        }
    }
    
    // 为特定类型提供专门实现
    struct MyString(String);
    
    impl Stringify for MyString {
        fn stringify(&self) -> String {
            format!("MyString: {}", self.0)
        }
    }
    
    let num = 42;
    let text = MyString("Hello".to_string());
    
    println!("数字: {}", num.stringify());
    println!("字符串: {}", text.stringify());
    
    println!("\n===== 使用 NewType 模式特化 =====\n");
    
    // 通用打印trait
    trait Print {
        fn print(&self);
    }
    
    // 默认实现
    impl<T: std::fmt::Display> Print for T {
        fn print(&self) {
            println!("默认: {}", self);
        }
    }
    
    // 创建 NewType 进行特化
    struct Special<T>(T);
    
    impl Print for Special<i32> {
        fn print(&self) {
            println!("特化 i32: {} (十六进制: 0x{:X})", self.0, self.0);
        }
    }
    
    impl Print for Special<String> {
        fn print(&self) {
            println!("特化 String: \"{}\" (长度: {})", self.0, self.0.len());
        }
    }
    
    let normal = 42;
    let special_int = Special(42);
    let special_str = Special(String::from("Rust"));
    
    normal.print();
    special_int.print();
    special_str.print();
    
    println!("\n===== 基于类型特征的特化 =====\n");
    
    // 使用 sealed trait 模式
    mod sealed {
        pub trait TypeMarker {}
        impl TypeMarker for i32 {}
        impl TypeMarker for String {}
    }
    
    trait Processor: sealed::TypeMarker {
        fn process(&self) -> String;
    }
    
    impl Processor for i32 {
        fn process(&self) -> String {
            format!("整数: {}", self)
        }
    }
    
    impl Processor for String {
        fn process(&self) -> String {
            format!("字符串: {}", self)
        }
    }
    
    let num: i32 = 100;
    let text: String = "Test".to_string();
    
    println!("{}", num.process());
    println!("{}", text.process());
    
    println!("\n===== 使用关联类型实现特化 =====\n");
    
    trait Container {
        type Item;
        fn get(&self) -> &Self::Item;
    }
    
    struct VecContainer<T>(Vec<T>);
    
    impl<T> Container for VecContainer<T> {
        type Item = T;
        fn get(&self) -> &Self::Item {
            &self.0[0]
        }
    }
    
    // 针对特定类型的优化
    impl Container for VecContainer<i32> {
        type Item = i32;
        fn get(&self) -> &Self::Item {
            println!("(使用 i32 优化路径)");
            &self.0[0]
        }
    }
    
    let vec_int = VecContainer(vec![1, 2, 3]);
    let vec_str = VecContainer(vec!["a", "b"]);
    
    println!("i32 容器: {}", vec_int.get());
    println!("&str 容器: {}", vec_str.get());
}
```

**输出**:

```text
===== 使用 Trait 实现特化 =====

数字: 42
字符串: MyString: Hello

===== 使用 NewType 模式特化 =====

默认: 42
特化 i32: 42 (十六进制: 0x2A)
特化 String: "Rust" (长度: 4)

===== 基于类型特征的特化 =====

整数: 100
字符串: Test

===== 使用关联类型实现特化 =====

(使用 i32 优化路径)
i32 容器: 1
&str 容器: a
```

---

### 示例3.4: GAT - 泛型关联类型

**目标**: 理解泛型关联类型（Generic Associated Types）

**难度**: ⭐⭐⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 什么是 GAT? =====\n");
    
    println!("GAT 允许关联类型本身也是泛型的\n");
    
    println!("===== GAT 基础示例 =====\n");
    
    // 定义带 GAT 的 Trait
    trait Container {
        type Item<'a> where Self: 'a;
        fn get<'a>(&'a self) -> Self::Item<'a>;
    }
    
    struct VecWrapper<T> {
        data: Vec<T>,
    }
    
    impl<T> Container for VecWrapper<T> {
        type Item<'a> = &'a T where Self: 'a;
        
        fn get<'a>(&'a self) -> Self::Item<'a> {
            &self.data[0]
        }
    }
    
    let vec = VecWrapper { data: vec![1, 2, 3] };
    println!("第一个元素: {}", vec.get());
    
    println!("\n===== GAT 的实用场景: 迭代器 =====\n");
    
    trait LendingIterator {
        type Item<'a> where Self: 'a;
        fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
    }
    
    struct WindowsTwo<T> {
        data: Vec<T>,
        pos: usize,
    }
    
    impl<T> WindowsTwo<T> {
        fn new(data: Vec<T>) -> Self {
            WindowsTwo { data, pos: 0 }
        }
    }
    
    impl<T> LendingIterator for WindowsTwo<T> {
        type Item<'a> = (&'a T, &'a T) where Self: 'a;
        
        fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
            if self.pos + 1 < self.data.len() {
                let result = (&self.data[self.pos], &self.data[self.pos + 1]);
                self.pos += 1;
                Some(result)
            } else {
                None
            }
        }
    }
    
    let mut windows = WindowsTwo::new(vec![1, 2, 3, 4, 5]);
    println!("窗口迭代:");
    while let Some((a, b)) = windows.next() {
        println!("  ({}, {})", a, b);
    }
    
    println!("\n===== GAT 与生命周期 =====\n");
    
    trait Cache {
        type Value<'a> where Self: 'a;
        fn get<'a>(&'a self, key: &str) -> Option<Self::Value<'a>>;
    }
    
    struct SimpleCache {
        data: std::collections::HashMap<String, String>,
    }
    
    impl Cache for SimpleCache {
        type Value<'a> = &'a str where Self: 'a;
        
        fn get<'a>(&'a self, key: &str) -> Option<Self::Value<'a>> {
            self.data.get(key).map(|s| s.as_str())
        }
    }
    
    let mut cache = SimpleCache {
        data: std::collections::HashMap::new(),
    };
    cache.data.insert("name".to_string(), "Rust".to_string());
    
    if let Some(value) = cache.get("name") {
        println!("缓存值: {}", value);
    }
    
    println!("\n===== GAT 的高级应用 =====\n");
    
    trait Family {
        type Member<'a, T: 'a> where Self: 'a;
        fn create<'a, T: 'a>(&'a self, value: T) -> Self::Member<'a, T>;
    }
    
    struct MyFamily;
    
    impl Family for MyFamily {
        type Member<'a, T: 'a> = Holder<'a, T> where Self: 'a;
        
        fn create<'a, T: 'a>(&'a self, value: T) -> Self::Member<'a, T> {
            Holder { value, _marker: std::marker::PhantomData }
        }
    }
    
    struct Holder<'a, T> {
        value: T,
        _marker: std::marker::PhantomData<&'a ()>,
    }
    
    let family = MyFamily;
    let member = family.create(42);
    println!("创建成员: {}", member.value);
}
```

**输出**:

```text
===== 什么是 GAT? =====

GAT 允许关联类型本身也是泛型的

===== GAT 基础示例 =====

第一个元素: 1

===== GAT 的实用场景: 迭代器 =====

窗口迭代:
  (1, 2)
  (2, 3)
  (3, 4)
  (4, 5)

===== GAT 与生命周期 =====

缓存值: Rust

===== GAT 的高级应用 =====

创建成员: 42
```

---

### 示例3.5: 类型状态模式

**目标**: 使用类型系统编码状态机

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 类型状态模式基础 =====\n");
    
    // 状态类型
    struct Disconnected;
    struct Connected;
    struct Authenticated;
    
    // 连接对象，使用类型参数表示状态
    struct Connection<State> {
        _state: std::marker::PhantomData<State>,
    }
    
    impl Connection<Disconnected> {
        fn new() -> Self {
            println!("创建连接: Disconnected");
            Connection { _state: std::marker::PhantomData }
        }
        
        fn connect(self) -> Connection<Connected> {
            println!("连接成功: Disconnected -> Connected");
            Connection { _state: std::marker::PhantomData }
        }
    }
    
    impl Connection<Connected> {
        fn authenticate(self, password: &str) -> Result<Connection<Authenticated>, Connection<Connected>> {
            if password == "secret" {
                println!("认证成功: Connected -> Authenticated");
                Ok(Connection { _state: std::marker::PhantomData })
            } else {
                println!("认证失败");
                Err(self)
            }
        }
        
        fn disconnect(self) -> Connection<Disconnected> {
            println!("断开连接: Connected -> Disconnected");
            Connection { _state: std::marker::PhantomData }
        }
    }
    
    impl Connection<Authenticated> {
        fn send_data(&self, data: &str) {
            println!("发送数据: {}", data);
        }
        
        fn disconnect(self) -> Connection<Disconnected> {
            println!("断开连接: Authenticated -> Disconnected");
            Connection { _state: std::marker::PhantomData }
        }
    }
    
    // 使用示例
    let conn = Connection::<Disconnected>::new();
    let conn = conn.connect();
    let conn = conn.authenticate("secret").unwrap();
    conn.send_data("Hello, World!");
    let _conn = conn.disconnect();
    
    // conn.send_data("test"); // 编译错误：已断开连接！
    
    println!("\n===== 构建器模式的类型状态 =====\n");
    
    struct NoName;
    struct HasName;
    struct NoAge;
    struct HasAge;
    
    struct UserBuilder<Name, Age> {
        name: Option<String>,
        age: Option<u32>,
        _name_state: std::marker::PhantomData<Name>,
        _age_state: std::marker::PhantomData<Age>,
    }
    
    impl UserBuilder<NoName, NoAge> {
        fn new() -> Self {
            println!("创建构建器");
            UserBuilder {
                name: None,
                age: None,
                _name_state: std::marker::PhantomData,
                _age_state: std::marker::PhantomData,
            }
        }
    }
    
    impl<Age> UserBuilder<NoName, Age> {
        fn name(self, name: String) -> UserBuilder<HasName, Age> {
            println!("设置名字: {}", name);
            UserBuilder {
                name: Some(name),
                age: self.age,
                _name_state: std::marker::PhantomData,
                _age_state: std::marker::PhantomData,
            }
        }
    }
    
    impl<Name> UserBuilder<Name, NoAge> {
        fn age(self, age: u32) -> UserBuilder<Name, HasAge> {
            println!("设置年龄: {}", age);
            UserBuilder {
                name: self.name,
                age: Some(age),
                _name_state: std::marker::PhantomData,
                _age_state: std::marker::PhantomData,
            }
        }
    }
    
    impl UserBuilder<HasName, HasAge> {
        fn build(self) -> User {
            println!("构建用户");
            User {
                name: self.name.unwrap(),
                age: self.age.unwrap(),
            }
        }
    }
    
    struct User {
        name: String,
        age: u32,
    }
    
    let user = UserBuilder::new()
        .name("Alice".to_string())
        .age(30)
        .build();
    
    println!("用户: {} ({}岁)", user.name, user.age);
    
    // UserBuilder::new().build(); // 编译错误：缺少必要字段！
    
    println!("\n===== 文件操作的类型状态 =====\n");
    
    struct Closed;
    struct Open;
    
    struct File<State> {
        _state: std::marker::PhantomData<State>,
    }
    
    impl File<Closed> {
        fn new() -> Self {
            println!("文件: Closed");
            File { _state: std::marker::PhantomData }
        }
        
        fn open(self) -> File<Open> {
            println!("打开文件: Closed -> Open");
            File { _state: std::marker::PhantomData }
        }
    }
    
    impl File<Open> {
        fn write(&self, data: &str) {
            println!("写入数据: {}", data);
        }
        
        fn read(&self) -> String {
            println!("读取数据");
            "file content".to_string()
        }
        
        fn close(self) -> File<Closed> {
            println!("关闭文件: Open -> Closed");
            File { _state: std::marker::PhantomData }
        }
    }
    
    let file = File::<Closed>::new();
    let file = file.open();
    file.write("Hello");
    let content = file.read();
    println!("内容: {}", content);
    let _file = file.close();
}
```

**输出**:

```text
===== 类型状态模式基础 =====

创建连接: Disconnected
连接成功: Disconnected -> Connected
认证成功: Connected -> Authenticated
发送数据: Hello, World!
断开连接: Authenticated -> Disconnected

===== 构建器模式的类型状态 =====

创建构建器
设置名字: Alice
设置年龄: 30
构建用户
用户: Alice (30岁)

===== 文件操作的类型状态 =====

文件: Closed
打开文件: Closed -> Open
写入数据: Hello
读取数据
内容: file content
关闭文件: Open -> Closed
```

---

### 示例3.6: 零成本抽象验证

**目标**: 验证泛型代码的零成本抽象特性

**难度**: ⭐⭐⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 零成本抽象原理 =====\n");
    
    println!("Rust 的泛型通过单态化实现零成本抽象");
    println!("编译器为每个具体类型生成专门的代码\n");
    
    println!("===== 泛型 vs 具体类型性能对比 =====\n");
    
    // 泛型版本
    fn generic_sum<T: std::ops::Add<Output = T> + Copy>(slice: &[T]) -> Option<T> {
        if slice.is_empty() {
            return None;
        }
        let mut sum = slice[0];
        for &item in &slice[1..] {
            sum = sum + item;
        }
        Some(sum)
    }
    
    // 具体类型版本
    fn concrete_sum(slice: &[i32]) -> Option<i32> {
        if slice.is_empty() {
            return None;
        }
        let mut sum = slice[0];
        for &item in &slice[1..] {
            sum = sum + item;
        }
        Some(sum)
    }
    
    let numbers = vec![1, 2, 3, 4, 5];
    
    let generic_result = generic_sum(&numbers);
    let concrete_result = concrete_sum(&numbers);
    
    println!("泛型求和: {:?}", generic_result);
    println!("具体求和: {:?}", concrete_result);
    println!("结果相同: {}", generic_result == concrete_result);
    println!("\n编译后的机器码应该是一致的！");
    
    println!("\n===== 内联优化验证 =====\n");
    
    trait Operation {
        fn execute(&self, x: i32) -> i32;
    }
    
    struct AddOne;
    impl Operation for AddOne {
        #[inline]
        fn execute(&self, x: i32) -> i32 {
            x + 1
        }
    }
    
    struct MultiplyTwo;
    impl Operation for MultiplyTwo {
        #[inline]
        fn execute(&self, x: i32) -> i32 {
            x * 2
        }
    }
    
    // 泛型函数可以被内联
    #[inline]
    fn apply<O: Operation>(op: &O, value: i32) -> i32 {
        op.execute(value)
    }
    
    let result1 = apply(&AddOne, 5);
    let result2 = apply(&MultiplyTwo, 5);
    
    println!("AddOne(5) = {}", result1);
    println!("MultiplyTwo(5) = {}", result2);
    println!("\n#[inline] 属性帮助编译器优化");
    
    println!("\n===== Iterator 零成本抽象 =====\n");
    
    let numbers = vec![1, 2, 3, 4, 5];
    
    // 使用迭代器链
    let sum: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2)
        .sum();
    
    println!("偶数加倍求和: {}", sum);
    println!("这个迭代器链会被优化成高效的循环代码！");
    
    // 手写等价循环
    let mut manual_sum = 0;
    for &x in &numbers {
        if x % 2 == 0 {
            manual_sum += x * 2;
        }
    }
    
    println!("手写循环结果: {}", manual_sum);
    println!("性能应该相同！");
    
    println!("\n===== 单态化示例 =====\n");
    
    fn process<T: std::fmt::Display>(value: T) {
        println!("处理: {}", value);
    }
    
    process(42);           // 生成 process_i32 版本
    process("hello");      // 生成 process_str 版本
    process(3.14);         // 生成 process_f64 版本
    
    println!("\n编译器为每个类型生成独立的函数");
    
    println!("\n===== 编译时优化验证 =====\n");
    
    // 编译时常量折叠
    const fn compile_time_compute(n: usize) -> usize {
        n * 2 + 1
    }
    
    const RESULT: usize = compile_time_compute(10);
    
    println!("编译时计算: compile_time_compute(10) = {}", RESULT);
    println!("这个值在编译时就确定了！");
    
    // 类型驱动的编译时选择
    trait TypeInfo {
        const SIZE: usize;
        const NAME: &'static str;
    }
    
    impl TypeInfo for i32 {
        const SIZE: usize = 4;
        const NAME: &'static str = "i32";
    }
    
    impl TypeInfo for i64 {
        const SIZE: usize = 8;
        const NAME: &'static str = "i64";
    }
    
    fn print_type_info<T: TypeInfo>() {
        println!("类型: {}, 大小: {} bytes", T::NAME, T::SIZE);
    }
    
    print_type_info::<i32>();
    print_type_info::<i64>();
    
    println!("\n===== 总结 =====\n");
    println!("零成本抽象的关键:");
    println!("  ✅ 单态化 - 为每个类型生成专门代码");
    println!("  ✅ 内联 - 消除函数调用开销");
    println!("  ✅ 编译时计算 - 移除运行时计算");
    println!("  ✅ 死代码消除 - 移除未使用的代码");
    println!("\n抽象不等于性能损失！");
}
```

**输出**:

```text
===== 零成本抽象原理 =====

Rust 的泛型通过单态化实现零成本抽象
编译器为每个具体类型生成专门的代码

===== 泛型 vs 具体类型性能对比 =====

泛型求和: Some(15)
具体求和: Some(15)
结果相同: true

编译后的机器码应该是一致的！

===== 内联优化验证 =====

AddOne(5) = 6
MultiplyTwo(5) = 10

#[inline] 属性帮助编译器优化

===== Iterator 零成本抽象 =====

偶数加倍求和: 12
这个迭代器链会被优化成高效的循环代码！
手写循环结果: 12
性能应该相同！

===== 单态化示例 =====

处理: 42
处理: hello
处理: 3.14

编译器为每个类型生成独立的函数

===== 编译时优化验证 =====

编译时计算: compile_time_compute(10) = 21
这个值在编译时就确定了！
类型: i32, 大小: 4 bytes
类型: i64, 大小: 8 bytes

===== 总结 =====

零成本抽象的关键:
  ✅ 单态化 - 为每个类型生成专门代码
  ✅ 内联 - 消除函数调用开销
  ✅ 编译时计算 - 移除运行时计算
  ✅ 死代码消除 - 移除未使用的代码

抽象不等于性能损失！
```

---

## 📝 总结

### 学习路径建议

1. **第一阶段** (Tier 1): 掌握基础 (示例 1.1-1.6)
   - 泛型函数、结构体、枚举
   - Option 和 Result
   - 泛型方法
   - 基础 Trait 约束

2. **第二阶段** (Tier 2): 实践应用 (示例 2.1-2.6)
   - 静态 vs 动态分派
   - 关联类型
   - 生命周期与泛型
   - 多 Trait 约束
   - Const 泛型
   - 默认类型参数

3. **第三阶段** (Tier 3): 深入理解 (示例 3.1-3.6)
   - HRTB (高阶Trait约束)
   - 类型级编程
   - 泛型特化模拟
   - GAT (泛型关联类型)
   - 类型状态模式
   - 零成本抽象验证

### 核心概念总结

| 概念 | 相关示例 | 重要性 | 难度 |
|------|---------|--------|------|
| 泛型函数 | 1.1 | ⭐⭐⭐⭐⭐ | ⭐ |
| 泛型结构体 | 1.2 | ⭐⭐⭐⭐⭐ | ⭐ |
| 泛型枚举 | 1.3 | ⭐⭐⭐⭐⭐ | ⭐ |
| Trait约束 | 1.6 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 关联类型 | 2.2 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| HRTB | 3.1 | ⭐⭐⭐ | ⭐⭐⭐⭐ |

### 最佳实践

1. **选择泛型还是Trait对象**:
   - 性能关键：使用泛型（静态分派）
   - 需要异构集合：使用 Trait 对象
   - 简单情况：优先泛型

2. **Trait约束**:
   - 简单约束：使用 `T: Trait`
   - 复杂约束：使用 where 子句
   - 多重约束：使用 `+` 连接

3. **关联类型 vs 泛型参数**:
   - 一对一关系：使用关联类型
   - 多种实现：使用泛型参数
   - 简化 API：优先关联类型

4. **Const 泛型**:
   - 固定大小数组：使用 const 泛型
   - 类型安全：在类型级别保证约束
   - 零运行时成本：编译时检查

### 下一步

- 📖 深入学习: [泛型与生命周期](./02_Trait系统指南.md)
- 📖 深入学习: [关联类型详解](./03_关联类型指南.md)
- 🚀 实战项目: [C04 实战项目集](./07_实战项目集.md) (即将创建)
- 📚 参考文档: [tier_03_references](../tier_03_references/)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-25  
**维护状态**: 活跃维护

**💡 泛型编程是 Rust 实现零成本抽象的关键，掌握泛型能让你的代码既灵活又高效! 🦀**：
