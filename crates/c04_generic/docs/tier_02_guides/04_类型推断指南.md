# C04 æ³›å‹ç¼–ç¨‹ - ç±»å‹æ¨æ–­æŒ‡å—

**æ–‡æ¡£ç±»å‹**: Tier 2 å®è·µæŒ‡å—
**éš¾åº¦çº§åˆ«**: â­â­â­ ä¸­çº§
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 2-3 å°æ—¶
**æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•

- [C04 æ³›å‹ç¼–ç¨‹ - ç±»å‹æ¨æ–­æŒ‡å—](#c04-æ³›å‹ç¼–ç¨‹---ç±»å‹æ¨æ–­æŒ‡å—)
  - [ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•](#-æœ¬æ–‡æ¡£ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
  - [1. ç±»å‹æ¨æ–­åŸºç¡€](#1-ç±»å‹æ¨æ–­åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­ï¼Ÿ](#11-ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­)
    - [1.2 ç±»å‹æ¨æ–­çš„èŒƒå›´](#12-ç±»å‹æ¨æ–­çš„èŒƒå›´)
    - [1.3 ç±»å‹æ¨æ–­çš„é™åˆ¶](#13-ç±»å‹æ¨æ–­çš„é™åˆ¶)
  - [2. å±€éƒ¨å˜é‡çš„ç±»å‹æ¨æ–­](#2-å±€éƒ¨å˜é‡çš„ç±»å‹æ¨æ–­)
    - [2.1 åŸºç¡€æ¨æ–­](#21-åŸºç¡€æ¨æ–­)
    - [2.2 ä»ä½¿ç”¨å¤„æ¨æ–­](#22-ä»ä½¿ç”¨å¤„æ¨æ–­)
    - [2.3 æ³›å‹ç±»å‹çš„æ¨æ–­](#23-æ³›å‹ç±»å‹çš„æ¨æ–­)
  - [3. å‡½æ•°è¿”å›ç±»å‹æ¨æ–­](#3-å‡½æ•°è¿”å›ç±»å‹æ¨æ–­)
    - [3.1 æ˜¾å¼è¿”å›ç±»å‹](#31-æ˜¾å¼è¿”å›ç±»å‹)
    - [3.2 impl Trait è¿”å›ç±»å‹](#32-impl-trait-è¿”å›ç±»å‹)
  - [4. Turbofish è¯­æ³• (`::<>`)](#4-turbofish-è¯­æ³•-)
    - [4.1 ä»€ä¹ˆæ˜¯ Turbofishï¼Ÿ](#41-ä»€ä¹ˆæ˜¯-turbofish)
    - [4.2 ä½¿ç”¨åœºæ™¯](#42-ä½¿ç”¨åœºæ™¯)
    - [4.3 å®æˆ˜æ¡ˆä¾‹](#43-å®æˆ˜æ¡ˆä¾‹)
  - [5. ç±»å‹æ ‡æ³¨æŠ€å·§](#5-ç±»å‹æ ‡æ³¨æŠ€å·§)
    - [5.1 ä½•æ—¶éœ€è¦ç±»å‹æ ‡æ³¨](#51-ä½•æ—¶éœ€è¦ç±»å‹æ ‡æ³¨)
    - [5.2 ç±»å‹æ ‡æ³¨çš„ä½ç½®](#52-ç±»å‹æ ‡æ³¨çš„ä½ç½®)
    - [5.3 æœ€å°åŒ–ç±»å‹æ ‡æ³¨](#53-æœ€å°åŒ–ç±»å‹æ ‡æ³¨)
  - [6. æ³›å‹ä¸Šä¸‹æ–‡ä¸­çš„ç±»å‹æ¨æ–­](#6-æ³›å‹ä¸Šä¸‹æ–‡ä¸­çš„ç±»å‹æ¨æ–­)
    - [6.1 ä»å‚æ•°æ¨æ–­](#61-ä»å‚æ•°æ¨æ–­)
    - [6.2 ä»è¿”å›å€¼æ¨æ–­](#62-ä»è¿”å›å€¼æ¨æ–­)
    - [6.3 æ¨æ–­çš„ä¼ æ’­](#63-æ¨æ–­çš„ä¼ æ’­)
  - [7. å¸¸è§çš„ç±»å‹æ¨æ–­é—®é¢˜](#7-å¸¸è§çš„ç±»å‹æ¨æ–­é—®é¢˜)
    - [7.1 "type annotations needed" é”™è¯¯](#71-type-annotations-needed-é”™è¯¯)
    - [7.2 æ¨æ–­ä¸æ˜ç¡®](#72-æ¨æ–­ä¸æ˜ç¡®)
    - [7.3 æ•´æ•°å’Œæµ®ç‚¹æ•°çš„é»˜è®¤æ¨æ–­](#73-æ•´æ•°å’Œæµ®ç‚¹æ•°çš„é»˜è®¤æ¨æ–­)
  - [8. é«˜çº§æ¨æ–­æŠ€å·§](#8-é«˜çº§æ¨æ–­æŠ€å·§)
    - [8.1 ä½¿ç”¨ç±»å‹åˆ«åè¾…åŠ©æ¨æ–­](#81-ä½¿ç”¨ç±»å‹åˆ«åè¾…åŠ©æ¨æ–­)
    - [8.2 åˆ©ç”¨é—­åŒ…çš„ç±»å‹æ¨æ–­](#82-åˆ©ç”¨é—­åŒ…çš„ç±»å‹æ¨æ–­)
    - [8.3 æ–¹æ³•é“¾ä¸­çš„æ¨æ–­](#83-æ–¹æ³•é“¾ä¸­çš„æ¨æ–­)
  - [9. å®æˆ˜ç»¼åˆæ¡ˆä¾‹](#9-å®æˆ˜ç»¼åˆæ¡ˆä¾‹)
    - [9.1 æ¡ˆä¾‹ 1ï¼šé›†åˆç±»å‹çš„æ¨æ–­](#91-æ¡ˆä¾‹-1é›†åˆç±»å‹çš„æ¨æ–­)
    - [9.2 æ¡ˆä¾‹ 2ï¼šé”™è¯¯å¤„ç†ä¸­çš„æ¨æ–­](#92-æ¡ˆä¾‹-2é”™è¯¯å¤„ç†ä¸­çš„æ¨æ–­)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 ä½•æ—¶ä½¿ç”¨ç±»å‹æ ‡æ³¨](#101-ä½•æ—¶ä½¿ç”¨ç±»å‹æ ‡æ³¨)
    - [10.2 æé«˜ä»£ç å¯è¯»æ€§](#102-æé«˜ä»£ç å¯è¯»æ€§)
    - [10.3 é¿å…è¿‡åº¦æ ‡æ³¨](#103-é¿å…è¿‡åº¦æ ‡æ³¨)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ¯ ç»ƒä¹ é¢˜](#-ç»ƒä¹ é¢˜)
  - [ğŸ“ å°ç»“](#-å°ç»“)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬æŒ‡å—çš„å­¦ä¹ ï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£ Rust çš„ç±»å‹æ¨æ–­æœºåˆ¶
- âœ… æŒæ¡ Turbofish è¯­æ³•çš„ä½¿ç”¨
- âœ… è§£å†³å¸¸è§çš„ç±»å‹æ¨æ–­é”™è¯¯
- âœ… åœ¨æ³›å‹ç¼–ç¨‹ä¸­æœ‰æ•ˆåˆ©ç”¨ç±»å‹æ¨æ–­
- âœ… å†™å‡ºç®€æ´ä¸”ç±»å‹å®‰å…¨çš„ä»£ç 

---

## ğŸ“š å‰ç½®çŸ¥è¯†

åœ¨å­¦ä¹ æœ¬æŒ‡å—ä¹‹å‰ï¼Œä½ åº”è¯¥æŒæ¡ï¼š

- âœ… [01\_æ³›å‹åŸºç¡€æŒ‡å—.md](./01_æ³›å‹åŸºç¡€æŒ‡å—.md) - æ³›å‹åŸºç¡€
- âœ… [02_Traitç³»ç»ŸæŒ‡å—.md](./02_Traitç³»ç»ŸæŒ‡å—.md) - Trait ç³»ç»Ÿ
- âœ… Rust åŸºç¡€è¯­æ³•

---

## 1. ç±»å‹æ¨æ–­åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯ç±»å‹æ¨æ–­ï¼Ÿ

**ç±»å‹æ¨æ–­** (Type Inference) æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨ç¡®å®šè¡¨è¾¾å¼ç±»å‹çš„èƒ½åŠ›ï¼Œæ— éœ€ç¨‹åºå‘˜æ˜¾å¼æ ‡æ³¨ã€‚

```rust
// ç¼–è¯‘å™¨å¯ä»¥æ¨æ–­ç±»å‹
let x = 5;        // i32
let y = 3.14;     // f64
let z = "hello";  // &str

// ç­‰ä»·äºæ˜¾å¼æ ‡æ³¨
let x: i32 = 5;
let y: f64 = 3.14;
let z: &str = "hello";
```

**ç±»å‹æ¨æ–­çš„ä¼˜åŠ¿**:

- âœ… å‡å°‘æ ·æ¿ä»£ç 
- âœ… æé«˜ä»£ç å¯è¯»æ€§
- âœ… ä¿æŒç±»å‹å®‰å…¨
- âœ… ç®€åŒ–é‡æ„

### 1.2 ç±»å‹æ¨æ–­çš„èŒƒå›´

Rust çš„ç±»å‹æ¨æ–­æ˜¯**å±€éƒ¨çš„**ï¼Œä»…åœ¨å‡½æ•°ä½“å†…å·¥ä½œã€‚

```rust
// âœ… å‡½æ•°ä½“å†…å¯ä»¥æ¨æ–­
fn example() {
    let x = 42;        // æ¨æ–­ä¸º i32
    let v = vec![1, 2, 3];  // æ¨æ–­ä¸º Vec<i32>
}

// âŒ å‡½æ•°ç­¾åå¿…é¡»æ˜¾å¼æ ‡æ³¨
fn add(a, b) -> {  // é”™è¯¯ï¼šéœ€è¦ç±»å‹æ ‡æ³¨
    a + b
}

// âœ… æ­£ç¡®
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### 1.3 ç±»å‹æ¨æ–­çš„é™åˆ¶

**é™åˆ¶ 1: ä¸èƒ½è·¨å‡½æ•°è¾¹ç•Œ**:

```rust
// âŒ é”™è¯¯ï¼šè¿”å›ç±»å‹éœ€è¦æ˜ç¡®
fn create_vector() {  // ç¼ºå°‘è¿”å›ç±»å‹
    vec![1, 2, 3]
}

// âœ… æ­£ç¡®
fn create_vector() -> Vec<i32> {
    vec![1, 2, 3]
}
```

**é™åˆ¶ 2: éœ€è¦è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡**:

```rust
// âŒ é”™è¯¯ï¼šä¿¡æ¯ä¸è¶³
let v = Vec::new();  // ä»€ä¹ˆç±»å‹çš„ Vecï¼Ÿ

// âœ… æ­£ç¡®ï¼šæä¾›ä¸Šä¸‹æ–‡
let v: Vec<i32> = Vec::new();
let v = Vec::<i32>::new();
let mut v = Vec::new();
v.push(42);  // ä»ä½¿ç”¨æ¨æ–­å‡º Vec<i32>
```

---

## 2. å±€éƒ¨å˜é‡çš„ç±»å‹æ¨æ–­

### 2.1 åŸºç¡€æ¨æ–­

```rust
fn main() {
    // å­—é¢é‡æ¨æ–­
    let int = 42;           // i32 (é»˜è®¤æ•´æ•°ç±»å‹)
    let float = 3.14;       // f64 (é»˜è®¤æµ®ç‚¹ç±»å‹)
    let boolean = true;     // bool
    let character = 'a';    // char
    let string = "hello";   // &str

    // è¡¨è¾¾å¼æ¨æ–­
    let sum = 1 + 2;        // i32
    let product = 3.0 * 2.5; // f64

    // å‡½æ•°è°ƒç”¨æ¨æ–­
    let len = "hello".len(); // usize
}
```

### 2.2 ä»ä½¿ç”¨å¤„æ¨æ–­

```rust
fn main() {
    // ä»åç»­ä½¿ç”¨æ¨æ–­
    let mut v = Vec::new();  // ç±»å‹æœªçŸ¥
    v.push(1);               // ç°åœ¨æ¨æ–­ä¸º Vec<i32>
    v.push(2);

    // ä»å‡½æ•°å‚æ•°æ¨æ–­
    let x = Vec::new();
    process_vec(x);  // ä» process_vec çš„ç­¾åæ¨æ–­ x çš„ç±»å‹
}

fn process_vec(v: Vec<i32>) {
    println!("{:?}", v);
}
```

**æ¨æ–­é“¾**:

```rust
fn main() {
    let a = Vec::new();
    let b = a.clone();      // b çš„ç±»å‹å–å†³äº a
    let c = transform(b);   // c çš„ç±»å‹å–å†³äº transform
    println!("{:?}", c);    // è¿™é‡Œéœ€è¦ Debugï¼Œè¿›ä¸€æ­¥çº¦æŸç±»å‹
}

fn transform<T: Clone>(v: Vec<T>) -> Vec<T> {
    v
}
```

### 2.3 æ³›å‹ç±»å‹çš„æ¨æ–­

```rust
use std::collections::HashMap;

fn main() {
    // ä»åˆå§‹åŒ–æ¨æ–­
    let map = HashMap::from([
        ("a", 1),
        ("b", 2),
    ]);  // HashMap<&str, i32>

    // ä»æ–¹æ³•è°ƒç”¨æ¨æ–­
    let mut map = HashMap::new();
    map.insert("key", 42);  // HashMap<&str, i32>

    // éƒ¨åˆ†æ¨æ–­
    let map: HashMap<_, i32> = HashMap::new();
    map.insert("key", 42);  // ç¬¬ä¸€ä¸ªç±»å‹å‚æ•°ä»ä½¿ç”¨æ¨æ–­
}
```

---

## 3. å‡½æ•°è¿”å›ç±»å‹æ¨æ–­

### 3.1 æ˜¾å¼è¿”å›ç±»å‹

```rust
// âœ… å¿…é¡»æ˜¾å¼æ ‡æ³¨è¿”å›ç±»å‹
fn get_number() -> i32 {
    42
}

fn create_vec() -> Vec<String> {
    vec![String::from("hello")]
}

// âŒ ä¸èƒ½çœç•¥è¿”å›ç±»å‹
fn get_value() {  // é”™è¯¯
    42
}
```

### 3.2 impl Trait è¿”å›ç±»å‹

```rust
use std::fmt::Display;

// ä½¿ç”¨ impl Trait éšè—å…·ä½“ç±»å‹
fn get_displayable() -> impl Display {
    42  // è¿”å› i32ï¼Œä½†è°ƒç”¨è€…åªçŸ¥é“å®ƒå®ç°äº† Display
}

fn get_iterator() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}

fn main() {
    let value = get_displayable();
    println!("{}", value);  // å¯ä»¥ä½¿ç”¨ Display

    for num in get_iterator() {
        println!("{}", num);
    }
}
```

---

## 4. Turbofish è¯­æ³• (`::<>`)

### 4.1 ä»€ä¹ˆæ˜¯ Turbofishï¼Ÿ

**Turbofish** (`::<>`) æ˜¯åœ¨æ–¹æ³•æˆ–å‡½æ•°è°ƒç”¨æ—¶æ˜¾å¼æŒ‡å®šæ³›å‹ç±»å‹å‚æ•°çš„è¯­æ³•ã€‚

```rust
// åŸºç¡€è¯­æ³•
function::<Type>(args)
value.method::<Type>(args)

// ç¤ºä¾‹
let v = Vec::<i32>::new();
let result = parse::<i32>("42");
```

### 4.2 ä½¿ç”¨åœºæ™¯

**åœºæ™¯ 1: ç±»å‹æ— æ³•æ¨æ–­**:

```rust
fn main() {
    // âŒ é”™è¯¯ï¼šparse çš„è¿”å›ç±»å‹æ— æ³•æ¨æ–­
    let num = "42".parse().unwrap();

    // âœ… æ–¹å¼ 1ï¼šä½¿ç”¨å˜é‡ç±»å‹æ ‡æ³¨
    let num: i32 = "42".parse().unwrap();

    // âœ… æ–¹å¼ 2ï¼šä½¿ç”¨ Turbofish
    let num = "42".parse::<i32>().unwrap();
}
```

**åœºæ™¯ 2: éœ€è¦ç‰¹å®šç±»å‹**:

```rust
use std::collections::HashSet;

fn main() {
    // åˆ›å»ºç‰¹å®šç±»å‹çš„é›†åˆ
    let numbers = [1, 2, 3, 4, 5];

    // ä½¿ç”¨ Turbofish æŒ‡å®šç›®æ ‡ç±»å‹
    let set: HashSet<_> = numbers.iter().collect();
    let set = numbers.iter().collect::<HashSet<_>>();

    println!("{:?}", set);
}
```

**åœºæ™¯ 3: æ–¹æ³•é“¾ä¸­çš„ç±»å‹**:

```rust
fn main() {
    let result = vec![1, 2, 3, 4, 5]
        .iter()
        .map(|x| x * 2)
        .collect::<Vec<_>>();  // æ˜ç¡®æŒ‡å®š collect çš„ç›®æ ‡ç±»å‹

    println!("{:?}", result);
}
```

### 4.3 å®æˆ˜æ¡ˆä¾‹

**æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²è§£æ**:

```rust
fn parse_numbers(input: &str) -> Result<Vec<i32>, std::num::ParseIntError> {
    input
        .split(',')
        .map(|s| s.trim().parse::<i32>())  // Turbofish æŒ‡å®šè§£æä¸º i32
        .collect()
}

fn main() {
    let input = "1, 2, 3, 4, 5";
    match parse_numbers(input) {
        Ok(numbers) => println!("{:?}", numbers),
        Err(e) => println!("Error: {}", e),
    }
}
```

**æ¡ˆä¾‹ 2: ç±»å‹è½¬æ¢**:

```rust
fn main() {
    // From æ•°ç»„åˆ›å»º Vec
    let v1 = Vec::from([1, 2, 3]);

    // ä½¿ç”¨ Turbofish æ˜ç¡®ç›®æ ‡ç±»å‹
    let v2 = <Vec<i32>>::from([1, 2, 3]);

    // åœ¨å¤æ‚æƒ…å†µä¸‹æ›´æ¸…æ™°
    let v3 = <Vec<_>>::from([1, 2, 3]);

    println!("{:?}, {:?}, {:?}", v1, v2, v3);
}
```

**æ¡ˆä¾‹ 3: æ³›å‹å‡½æ•°è°ƒç”¨**:

```rust
fn identity<T>(value: T) -> T {
    value
}

fn main() {
    // é€šå¸¸å¯ä»¥æ¨æ–­
    let x = identity(42);  // T = i32

    // æŸäº›æƒ…å†µéœ€è¦ Turbofish
    let x = identity::<i32>(42);

    // å½“ç±»å‹æ— æ³•ä»å‚æ•°æ¨æ–­æ—¶
    let default_value = Default::default();  // âŒ é”™è¯¯ï¼šç±»å‹æœªçŸ¥
    let default_value = i32::default();      // âœ… æ­£ç¡®
    let default_value = <i32>::default();    // âœ… ä¹Ÿå¯ä»¥
}
```

---

## 5. ç±»å‹æ ‡æ³¨æŠ€å·§

### 5.1 ä½•æ—¶éœ€è¦ç±»å‹æ ‡æ³¨

**éœ€è¦æ ‡æ³¨çš„æƒ…å†µ**:

1. ç¼–è¯‘å™¨æ— æ³•æ¨æ–­
2. æé«˜ä»£ç å¯è¯»æ€§
3. é¿å…æ„å¤–çš„ç±»å‹è½¬æ¢

```rust
fn main() {
    // 1. ç¼–è¯‘å™¨æ— æ³•æ¨æ–­
    let v: Vec<i32> = Vec::new();

    // 2. æé«˜å¯è¯»æ€§
    let timeout_seconds: u64 = 30;  // æ˜ç¡®å•ä½

    // 3. æ˜ç¡®æ„å›¾
    let x: f32 = 3.14;  // æ˜ç¡®ä½¿ç”¨ f32 è€Œä¸æ˜¯é»˜è®¤çš„ f64
}
```

### 5.2 ç±»å‹æ ‡æ³¨çš„ä½ç½®

**ä½ç½® 1: å˜é‡å£°æ˜**:

```rust
let x: i32 = 42;
let v: Vec<String> = Vec::new();
```

**ä½ç½® 2: å‡½æ•°å‚æ•°å’Œè¿”å›å€¼**:

```rust
fn process(x: i32, y: f64) -> String {
    format!("{} {}", x, y)
}
```

**ä½ç½® 3: æ–¹æ³•è°ƒç”¨ (Turbofish)**:

```rust
let result = "42".parse::<i32>().unwrap();
```

**ä½ç½® 4: ç»“æ„ä½“å­—æ®µ**:

```rust
struct Config {
    timeout: u64,
    retries: u32,
}
```

### 5.3 æœ€å°åŒ–ç±»å‹æ ‡æ³¨

**ä½¿ç”¨ `_` éƒ¨åˆ†æ¨æ–­**:

```rust
use std::collections::HashMap;

fn main() {
    // åªæ ‡æ³¨ä¸€éƒ¨åˆ†ï¼Œå…¶ä½™è®©ç¼–è¯‘å™¨æ¨æ–­
    let map: HashMap<_, _> = [("a", 1), ("b", 2)]
        .iter()
        .cloned()
        .collect();

    // åªæ ‡æ³¨å€¼ç±»å‹
    let map: HashMap<_, i32> = [("a", 1), ("b", 2)]
        .iter()
        .cloned()
        .collect();
}
```

**åˆ©ç”¨ç±»å‹æ¨æ–­é“¾**:

```rust
fn main() {
    // åªéœ€åœ¨ä¸€å¤„æ ‡æ³¨
    let numbers: Vec<i32> = vec![1, 2, 3, 4, 5];
    let doubled = numbers.iter().map(|x| x * 2).collect::<Vec<_>>();
    let sum: i32 = doubled.iter().sum();  // ä» Vec<i32> æ¨æ–­
}
```

---

## 6. æ³›å‹ä¸Šä¸‹æ–‡ä¸­çš„ç±»å‹æ¨æ–­

### 6.1 ä»å‚æ•°æ¨æ–­

```rust
fn wrap<T>(value: T) -> Option<T> {
    Some(value)
}

fn main() {
    let x = wrap(42);        // T = i32
    let y = wrap("hello");   // T = &str
    let z = wrap(vec![1, 2]); // T = Vec<i32>
}
```

### 6.2 ä»è¿”å›å€¼æ¨æ–­

```rust
fn unwrap_or_default<T: Default>(opt: Option<T>) -> T {
    opt.unwrap_or_default()
}

fn main() {
    let x: i32 = unwrap_or_default(None);  // T = i32
    let y: String = unwrap_or_default(None); // T = String
}
```

### 6.3 æ¨æ–­çš„ä¼ æ’­

```rust
fn main() {
    let v = vec![1, 2, 3];  // Vec<i32>

    // æ¨æ–­ä¼ æ’­åˆ°æ•´ä¸ªè¡¨è¾¾å¼é“¾
    let result = v
        .iter()            // Iter<'_, i32>
        .map(|x| x * 2)    // Map<..., i32>
        .filter(|x| x > &5) // Filter<..., i32>
        .collect::<Vec<_>>(); // Vec<i32>

    println!("{:?}", result);
}
```

---

## 7. å¸¸è§çš„ç±»å‹æ¨æ–­é—®é¢˜

### 7.1 "type annotations needed" é”™è¯¯

**é—®é¢˜**:

```rust
fn main() {
    let v = Vec::new();  // é”™è¯¯ï¼šç±»å‹æœªçŸ¥
    println!("{:?}", v);
}
```

**è§£å†³æ–¹æ¡ˆ**:

```rust
// æ–¹å¼ 1ï¼šæ·»åŠ ç±»å‹æ ‡æ³¨
let v: Vec<i32> = Vec::new();

// æ–¹å¼ 2ï¼šä½¿ç”¨ Turbofish
let v = Vec::<i32>::new();

// æ–¹å¼ 3ï¼šé€šè¿‡ä½¿ç”¨æ¨æ–­
let mut v = Vec::new();
v.push(42);  // æ¨æ–­ä¸º Vec<i32>
```

### 7.2 æ¨æ–­ä¸æ˜ç¡®

**é—®é¢˜**:

```rust
fn main() {
    let result = "42".parse().unwrap();  // é”™è¯¯ï¼šparse å¯ä»¥è¿”å›å¤šç§ç±»å‹
}
```

**è§£å†³æ–¹æ¡ˆ**:

```rust
// æ–¹å¼ 1ï¼šå˜é‡ç±»å‹æ ‡æ³¨
let result: i32 = "42".parse().unwrap();

// æ–¹å¼ 2ï¼šTurbofish
let result = "42".parse::<i32>().unwrap();

// æ–¹å¼ 3ï¼šä»ä½¿ç”¨æ¨æ–­
let result = "42".parse().unwrap();
let doubled: i32 = result * 2;  // æ¨æ–­ result ä¸º i32
```

### 7.3 æ•´æ•°å’Œæµ®ç‚¹æ•°çš„é»˜è®¤æ¨æ–­

```rust
fn main() {
    // æ•´æ•°é»˜è®¤æ¨æ–­ä¸º i32
    let x = 42;       // i32
    let y = 42u64;    // ä½¿ç”¨åç¼€æŒ‡å®š u64
    let z: u64 = 42;  // ä½¿ç”¨ç±»å‹æ ‡æ³¨

    // æµ®ç‚¹æ•°é»˜è®¤æ¨æ–­ä¸º f64
    let a = 3.14;     // f64
    let b = 3.14f32;  // ä½¿ç”¨åç¼€æŒ‡å®š f32
    let c: f32 = 3.14; // ä½¿ç”¨ç±»å‹æ ‡æ³¨
}
```

---

## 8. é«˜çº§æ¨æ–­æŠ€å·§

### 8.1 ä½¿ç”¨ç±»å‹åˆ«åè¾…åŠ©æ¨æ–­

```rust
type UserId = u64;
type UserName = String;

fn create_user(id: UserId, name: UserName) {
    println!("User {} with ID {}", name, id);
}

fn main() {
    create_user(1, String::from("Alice"));
    // ç±»å‹åˆ«åä½¿æ„å›¾æ›´æ¸…æ™°
}
```

### 8.2 åˆ©ç”¨é—­åŒ…çš„ç±»å‹æ¨æ–­

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // é—­åŒ…å‚æ•°ç±»å‹ä»è¿­ä»£å™¨æ¨æ–­
    let doubled: Vec<_> = numbers
        .iter()
        .map(|x| x * 2)  // x çš„ç±»å‹ä» iter() æ¨æ–­ä¸º &i32
        .collect();

    println!("{:?}", doubled);
}
```

### 8.3 æ–¹æ³•é“¾ä¸­çš„æ¨æ–­

```rust
fn main() {
    let result = vec![1, 2, 3, 4, 5]
        .into_iter()
        .filter(|x| x % 2 == 0)
        .map(|x| x * x)
        .collect::<Vec<_>>();

    // æ•´ä¸ªé“¾çš„ç±»å‹éƒ½ä» vec![1, 2, 3, 4, 5] æ¨æ–­
    println!("{:?}", result);
}
```

---

## 9. å®æˆ˜ç»¼åˆæ¡ˆä¾‹

### 9.1 æ¡ˆä¾‹ 1ï¼šé›†åˆç±»å‹çš„æ¨æ–­

```rust
use std::collections::{HashMap, HashSet};

fn main() {
    // ä»åˆå§‹å€¼æ¨æ–­
    let map1 = HashMap::from([
        ("a", 1),
        ("b", 2),
    ]);  // HashMap<&str, i32>

    // ä½¿ç”¨ collect æ—¶éœ€è¦æŒ‡å®šç±»å‹
    let set1: HashSet<_> = vec![1, 2, 3].into_iter().collect();
    let set2 = vec![1, 2, 3].into_iter().collect::<HashSet<_>>();

    // ç»„åˆä½¿ç”¨
    let map2: HashMap<String, Vec<i32>> = HashMap::new();

    println!("{:?}", map1);
    println!("{:?}", set1);
    println!("{:?}", set2);
    println!("{:?}", map2);
}
```

### 9.2 æ¡ˆä¾‹ 2ï¼šé”™è¯¯å¤„ç†ä¸­çš„æ¨æ–­

```rust
use std::num::ParseIntError;

fn parse_and_double(input: &str) -> Result<i32, ParseIntError> {
    let num = input.parse::<i32>()?;  // Turbofish æŒ‡å®šç±»å‹
    Ok(num * 2)
}

fn parse_multiple(inputs: &[&str]) -> Result<Vec<i32>, ParseIntError> {
    inputs
        .iter()
        .map(|s| s.parse::<i32>())
        .collect()  // collect è‡ªåŠ¨æ¨æ–­ä¸º Result<Vec<i32>, ParseIntError>
}

fn main() {
    match parse_and_double("21") {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }

    match parse_multiple(&["1", "2", "3"]) {
        Ok(numbers) => println!("Numbers: {:?}", numbers),
        Err(e) => println!("Error: {}", e),
    }
}
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 ä½•æ—¶ä½¿ç”¨ç±»å‹æ ‡æ³¨

**æ¨èæ ‡æ³¨çš„æƒ…å†µ**:

1. **å‡½æ•°ç­¾å** - æ€»æ˜¯æ ‡æ³¨å‚æ•°å’Œè¿”å›ç±»å‹
2. **å…¬å…± API** - æé«˜æ–‡æ¡£æ¸…æ™°åº¦
3. **å¤æ‚ç±»å‹** - é¿å…æ¨æ–­æ­§ä¹‰
4. **æ€§èƒ½å…³é”®ä»£ç ** - æ˜ç¡®ç±»å‹é€‰æ‹©

```rust
// âœ… å¥½çš„å®è·µ
pub fn process_data(input: &[u8]) -> Result<Vec<String>, std::io::Error> {
    // å¤æ‚ç±»å‹æ˜ç¡®æ ‡æ³¨
    let cache: HashMap<String, Vec<u8>> = HashMap::new();
    // ...
    Ok(vec![])
}

// âš ï¸ å†…éƒ¨å®ç°å¯ä»¥ä¾èµ–æ¨æ–­
fn internal_helper() {
    let x = 42;  // ç®€å•æƒ…å†µå¯ä»¥çœç•¥
    let v = vec![1, 2, 3];
}
```

### 10.2 æé«˜ä»£ç å¯è¯»æ€§

```rust
// âŒ ä¸æ¸…æ¥š
let t = 3600;

// âœ… æ¸…æ™°
let timeout_seconds: u64 = 3600;

// âŒ ä¸æ¸…æ¥š
let r = calculate();

// âœ… æ¸…æ™°
let response: ApiResponse = calculate();
```

### 10.3 é¿å…è¿‡åº¦æ ‡æ³¨

```rust
// âŒ è¿‡åº¦æ ‡æ³¨
let x: i32 = 5 + 10;
let message: String = format!("Hello, {}", name);

// âœ… é€‚åº¦æ ‡æ³¨
let x = 5 + 10;  // æ˜æ˜¾æ˜¯ i32
let message = format!("Hello, {}", name);  // æ˜æ˜¾æ˜¯ String
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [01\_æ³›å‹åŸºç¡€æŒ‡å—.md](./01_æ³›å‹åŸºç¡€æŒ‡å—.md) - æ³›å‹åŸºç¡€
- [05\_å®æˆ˜æ¨¡å¼æŒ‡å—.md](./05_å®æˆ˜æ¨¡å¼æŒ‡å—.md) - å®æˆ˜è®¾è®¡æ¨¡å¼
- [../tier_03_references/01_æ³›å‹è¯­æ³•å‚è€ƒ.md](../tier_03_references/01_æ³›å‹è¯­æ³•å‚è€ƒ.md) - å®Œæ•´è¯­æ³•å‚è€ƒ
- [../tier_01_foundations/04_å¸¸è§é—®é¢˜.md](../tier_01_foundations/04_å¸¸è§é—®é¢˜.md#q41-ä¸ºä»€ä¹ˆéœ€è¦-turbofish--è¯­æ³•) - å¸¸è§é—®é¢˜

---

## ğŸ¯ ç»ƒä¹ é¢˜

**ç»ƒä¹  1: ä¿®å¤ç±»å‹æ¨æ–­é”™è¯¯**:

```rust
fn main() {
    let v = Vec::new();  // é”™è¯¯ï¼šç±»å‹æœªçŸ¥
    let first = v.first();
    println!("{:?}", first);
}
```

**ç»ƒä¹  2: ä½¿ç”¨ Turbofish**:

```rust
fn main() {
    let numbers = vec!["1", "2", "3", "4", "5"];
    let parsed = numbers
        .iter()
        .map(|s| s.parse().unwrap())  // ä½¿ç”¨ Turbofish æŒ‡å®šç±»å‹
        .collect();
    println!("{:?}", parsed);
}
```

**ç»ƒä¹  3: æœ€å°åŒ–ç±»å‹æ ‡æ³¨**:

ä¼˜åŒ–ä»¥ä¸‹ä»£ç ï¼Œç§»é™¤ä¸å¿…è¦çš„ç±»å‹æ ‡æ³¨ï¼š

```rust
fn main() {
    let x: i32 = 5 + 10;
    let y: f64 = 3.14 * 2.0;
    let message: String = format!("Result: {}", x);
    println!("{}", message);
}
```

---

## ğŸ“ å°ç»“

åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ï¼š

- âœ… **ç±»å‹æ¨æ–­åŸºç¡€**: èŒƒå›´ã€é™åˆ¶ã€å·¥ä½œåŸç†
- âœ… **å±€éƒ¨å˜é‡æ¨æ–­**: ä»å­—é¢é‡ã€ä½¿ç”¨ã€è¡¨è¾¾å¼æ¨æ–­
- âœ… **Turbofish è¯­æ³•**: ä½•æ—¶ä½¿ç”¨ã€å¦‚ä½•ä½¿ç”¨
- âœ… **ç±»å‹æ ‡æ³¨æŠ€å·§**: ä½ç½®ã€æœ€å°åŒ–ã€å¯è¯»æ€§
- âœ… **æ³›å‹ä¸Šä¸‹æ–‡æ¨æ–­**: å‚æ•°ã€è¿”å›å€¼ã€æ¨æ–­ä¼ æ’­
- âœ… **å¸¸è§é—®é¢˜**: è§£å†³ç±»å‹æ¨æ–­é”™è¯¯
- âœ… **æœ€ä½³å®è·µ**: ä½•æ—¶æ ‡æ³¨ã€ä½•æ—¶ä¾èµ–æ¨æ–­

**ä¸‹ä¸€æ­¥å­¦ä¹ **:

1. [05\_å®æˆ˜æ¨¡å¼æŒ‡å—.md](./05_å®æˆ˜æ¨¡å¼æŒ‡å—.md) - å­¦ä¹ å®æˆ˜è®¾è®¡æ¨¡å¼
2. [../tier_04_advanced/03_é›¶æˆæœ¬æŠ½è±¡.md](../tier_04_advanced/03_é›¶æˆæœ¬æŠ½è±¡.md) - ç†è§£é›¶æˆæœ¬æŠ½è±¡
3. [../tier_04_advanced/04_ç±»å‹çº§ç¼–ç¨‹.md](../tier_04_advanced/04_ç±»å‹çº§ç¼–ç¨‹.md) - é«˜çº§ç±»å‹æŠ€å·§

---

**æ–‡æ¡£å…ƒä¿¡æ¯**:

- åˆ›å»ºæ—¥æœŸ: 2025-10-22
- ä½œè€…: Rust-Lang Project
- è®¸å¯: MIT OR Apache-2.0
