# C04 æ³›å‹ç¼–ç¨‹ - å…³è”ç±»å‹æŒ‡å—

**æ–‡æ¡£ç±»å‹**: Tier 2 å®è·µæŒ‡å—  
**éš¾åº¦çº§åˆ«**: â­â­â­â­ é«˜çº§  
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4 å°æ—¶  
**æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•

- [C04 æ³›å‹ç¼–ç¨‹ - å…³è”ç±»å‹æŒ‡å—](#c04-æ³›å‹ç¼–ç¨‹---å…³è”ç±»å‹æŒ‡å—)
  - [ğŸ“‹ æœ¬æ–‡æ¡£ç›®å½•](#-æœ¬æ–‡æ¡£ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
  - [1. å…³è”ç±»å‹åŸºç¡€](#1-å…³è”ç±»å‹åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯å…³è”ç±»å‹ï¼Ÿ](#11-ä»€ä¹ˆæ˜¯å…³è”ç±»å‹)
    - [1.2 å…³è”ç±»å‹ vs æ³›å‹å‚æ•°](#12-å…³è”ç±»å‹-vs-æ³›å‹å‚æ•°)
    - [1.3 åŸºç¡€è¯­æ³•](#13-åŸºç¡€è¯­æ³•)
  - [2. å…³è”ç±»å‹çš„ä½¿ç”¨åœºæ™¯](#2-å…³è”ç±»å‹çš„ä½¿ç”¨åœºæ™¯)
    - [2.1 è¿­ä»£å™¨æ¨¡å¼](#21-è¿­ä»£å™¨æ¨¡å¼)
    - [2.2 å›¾ç®—æ³•](#22-å›¾ç®—æ³•)
    - [2.3 ç±»å‹è½¬æ¢](#23-ç±»å‹è½¬æ¢)
  - [3. æ³›å‹å…³è”ç±»å‹ (GAT)](#3-æ³›å‹å…³è”ç±»å‹-gat)
    - [3.1 ä»€ä¹ˆæ˜¯ GATï¼Ÿ](#31-ä»€ä¹ˆæ˜¯-gat)
    - [3.2 GAT çš„ä½¿ç”¨åœºæ™¯](#32-gat-çš„ä½¿ç”¨åœºæ™¯)
    - [3.3 Streaming Iterator](#33-streaming-iterator)
  - [4. å…³è”å¸¸é‡](#4-å…³è”å¸¸é‡)
    - [4.1 åŸºç¡€è¯­æ³•](#41-åŸºç¡€è¯­æ³•)
    - [4.2 å®æˆ˜æ¡ˆä¾‹](#42-å®æˆ˜æ¡ˆä¾‹)
  - [5. é«˜çº§æ¨¡å¼](#5-é«˜çº§æ¨¡å¼)
    - [5.1 å¤šä¸ªå…³è”ç±»å‹](#51-å¤šä¸ªå…³è”ç±»å‹)
    - [5.2 å…³è”ç±»å‹çš„çº¦æŸ](#52-å…³è”ç±»å‹çš„çº¦æŸ)
    - [5.3 å…³è”ç±»å‹çš„é»˜è®¤å€¼](#53-å…³è”ç±»å‹çš„é»˜è®¤å€¼)
  - [6. RPITIT (Return Position Impl Trait In Traits)](#6-rpitit-return-position-impl-trait-in-traits)
    - [6.1 ä»€ä¹ˆæ˜¯ RPITITï¼Ÿ](#61-ä»€ä¹ˆæ˜¯-rpitit)
    - [6.2 å®æˆ˜æ¡ˆä¾‹](#62-å®æˆ˜æ¡ˆä¾‹)
  - [7. å®æˆ˜ç»¼åˆæ¡ˆä¾‹](#7-å®æˆ˜ç»¼åˆæ¡ˆä¾‹)
    - [7.1 æ¡ˆä¾‹ 1ï¼šæ•°æ®åº“æŠ½è±¡å±‚](#71-æ¡ˆä¾‹-1æ•°æ®åº“æŠ½è±¡å±‚)
    - [7.2 æ¡ˆä¾‹ 2ï¼šParser Combinator](#72-æ¡ˆä¾‹-2parser-combinator)
  - [8. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#8-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [8.1 å¸¸è§é”™è¯¯](#81-å¸¸è§é”™è¯¯)
    - [8.2 æœ€ä½³å®è·µ](#82-æœ€ä½³å®è·µ)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ¯ ç»ƒä¹ é¢˜](#-ç»ƒä¹ é¢˜)
  - [ğŸ“ å°ç»“](#-å°ç»“)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬æŒ‡å—çš„å­¦ä¹ ï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£å…³è”ç±»å‹çš„æ¦‚å¿µå’Œä»·å€¼
- âœ… åŒºåˆ†å…³è”ç±»å‹å’Œæ³›å‹å‚æ•°çš„ä½¿ç”¨åœºæ™¯
- âœ… æŒæ¡æ³›å‹å…³è”ç±»å‹ (GAT) çš„ç”¨æ³•
- âœ… ä½¿ç”¨å…³è”å¸¸é‡
- âœ… ç†è§£ RPITIT (Return Position Impl Trait In Traits)
- âœ… è®¾è®¡åŸºäºå…³è”ç±»å‹çš„é«˜çº§æŠ½è±¡

---

## ğŸ“š å‰ç½®çŸ¥è¯†

åœ¨å­¦ä¹ æœ¬æŒ‡å—ä¹‹å‰ï¼Œä½ åº”è¯¥æŒæ¡ï¼š

- âœ… [01_æ³›å‹åŸºç¡€æŒ‡å—.md](./01_æ³›å‹åŸºç¡€æŒ‡å—.md) - æ³›å‹åŸºç¡€
- âœ… [02_Traitç³»ç»ŸæŒ‡å—.md](./02_Traitç³»ç»ŸæŒ‡å—.md) - Trait ç³»ç»Ÿ
- âœ… ç”Ÿå‘½å‘¨æœŸçš„åŸºæœ¬æ¦‚å¿µ

---

## 1. å…³è”ç±»å‹åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯å…³è”ç±»å‹ï¼Ÿ

**å…³è”ç±»å‹** (Associated Type) æ˜¯åœ¨ trait ä¸­å®šä¹‰çš„å ä½ç¬¦ç±»å‹ï¼Œå…·ä½“ç±»å‹ç”±å®ç° trait çš„ç±»å‹å†³å®šã€‚

```rust
trait Container {
    type Item;  // å…³è”ç±»å‹
    
    fn add(&mut self, item: Self::Item);
    fn get(&self, index: usize) -> Option<&Self::Item>;
}

struct NumberContainer {
    items: Vec<i32>,
}

impl Container for NumberContainer {
    type Item = i32;  // æŒ‡å®šå…³è”ç±»å‹ä¸º i32
    
    fn add(&mut self, item: i32) {
        self.items.push(item);
    }
    
    fn get(&self, index: usize) -> Option<&i32> {
        self.items.get(index)
    }
}
```

### 1.2 å…³è”ç±»å‹ vs æ³›å‹å‚æ•°

**ä½¿ç”¨æ³›å‹å‚æ•°**:

```rust
trait Container<T> {
    fn add(&mut self, item: T);
    fn get(&self, index: usize) -> Option<&T>;
}

// å¯ä»¥ä¸ºåŒä¸€ç±»å‹å®ç°å¤šæ¬¡ï¼Œä½†ä½¿ç”¨æ—¶éœ€è¦æŒ‡å®šç±»å‹
impl Container<i32> for MyContainer { /* ... */ }
impl Container<String> for MyContainer { /* ... */ }

fn use_container(c: &impl Container<i32>) { } // éœ€è¦æŒ‡å®šç±»å‹
```

**ä½¿ç”¨å…³è”ç±»å‹**:

```rust
trait Container {
    type Item;
    fn add(&mut self, item: Self::Item);
    fn get(&self, index: usize) -> Option<&Self::Item>;
}

// æ¯ä¸ªç±»å‹åªèƒ½æœ‰ä¸€ä¸ªå®ç°
impl Container for MyContainer {
    type Item = i32;
    // ...
}

fn use_container(c: &impl Container) { } // ä¸éœ€è¦æŒ‡å®šç±»å‹
```

**å…³é”®åŒºåˆ«**:

| ç‰¹æ€§ | æ³›å‹å‚æ•° | å…³è”ç±»å‹ |
|------|----------|----------|
| å®ç°æ¬¡æ•° | å¯å¤šæ¬¡ | åªèƒ½ä¸€æ¬¡ |
| ç±»å‹æŒ‡å®š | è°ƒç”¨æ—¶æŒ‡å®š | å®ç°æ—¶æŒ‡å®š |
| çµæ´»æ€§ | æ›´çµæ´» | æ›´ç®€æ´ |
| ä½¿ç”¨åœºæ™¯ | ä¸€å¯¹å¤šå…³ç³» | ä¸€å¯¹ä¸€å…³ç³» |

### 1.3 åŸºç¡€è¯­æ³•

**å®šä¹‰å…³è”ç±»å‹**:

```rust
trait MyTrait {
    type Item;              // æ— çº¦æŸ
    type Error: std::error::Error;  // æœ‰çº¦æŸ
    type Output = String;   // æœ‰é»˜è®¤å€¼ (Rust 1.90+)
}
```

**å®ç°å…³è”ç±»å‹**:

```rust
struct MyStruct;

impl MyTrait for MyStruct {
    type Item = i32;
    type Error = std::io::Error;
    // Output ä½¿ç”¨é»˜è®¤å€¼ String
}
```

**ä½¿ç”¨å…³è”ç±»å‹**:

```rust
fn process<T: MyTrait>(value: T) -> T::Item {
    // ä½¿ç”¨ T::Item å¼•ç”¨å…³è”ç±»å‹
}
```

---

## 2. å…³è”ç±»å‹çš„ä½¿ç”¨åœºæ™¯

### 2.1 è¿­ä»£å™¨æ¨¡å¼

**æ ‡å‡†åº“çš„ Iterator**:

```rust
trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    count: u32,
    max: u32,
}

impl Iterator for Counter {
    type Item = u32;
    
    fn next(&mut self) -> Option<u32> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut counter = Counter { count: 0, max: 5 };
    
    while let Some(num) = counter.next() {
        println!("{}", num);
    }
}
```

**è‡ªå®šä¹‰è¿­ä»£å™¨**:

```rust
struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;
    
    fn next(&mut self) -> Option<u32> {
        let current = self.curr;
        self.curr = self.next;
        self.next = current + self.next;
        
        Some(current)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    
    for num in fib.take(10) {
        println!("{}", num);
    }
}
```

### 2.2 å›¾ç®—æ³•

```rust
trait Graph {
    type Node;
    type Edge;
    
    fn nodes(&self) -> Vec<&Self::Node>;
    fn edges(&self, node: &Self::Node) -> Vec<&Self::Edge>;
}

struct SimpleGraph {
    nodes: Vec<String>,
    edges: Vec<(usize, usize)>,
}

impl Graph for SimpleGraph {
    type Node = String;
    type Edge = (usize, usize);
    
    fn nodes(&self) -> Vec<&String> {
        self.nodes.iter().collect()
    }
    
    fn edges(&self, _node: &String) -> Vec<&(usize, usize)> {
        self.edges.iter().collect()
    }
}
```

### 2.3 ç±»å‹è½¬æ¢

```rust
trait Convertible {
    type Output;
    
    fn convert(self) -> Self::Output;
}

struct Temperature(f64);

impl Convertible for Temperature {
    type Output = String;
    
    fn convert(self) -> String {
        format!("{}Â°C", self.0)
    }
}

fn main() {
    let temp = Temperature(25.5);
    let str_temp = temp.convert();
    println!("{}", str_temp); // "25.5Â°C"
}
```

---

## 3. æ³›å‹å…³è”ç±»å‹ (GAT)

### 3.1 ä»€ä¹ˆæ˜¯ GATï¼Ÿ

**æ³›å‹å…³è”ç±»å‹** (Generic Associated Types) å…è®¸å…³è”ç±»å‹æœ¬èº«å¸¦æœ‰æ³›å‹å‚æ•°ã€‚

```rust
trait Container {
    type Item<'a> where Self: 'a;  // GAT
    
    fn get<'a>(&'a self, index: usize) -> Option<Self::Item<'a>>;
}

struct VecContainer {
    items: Vec<String>,
}

impl Container for VecContainer {
    type Item<'a> = &'a String;
    
    fn get<'a>(&'a self, index: usize) -> Option<&'a String> {
        self.items.get(index)
    }
}
```

### 3.2 GAT çš„ä½¿ç”¨åœºæ™¯

**åœºæ™¯ 1: å€Ÿç”¨è¿­ä»£å™¨**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct WindowsIterator<T> {
    data: Vec<T>,
    window_size: usize,
    position: usize,
}

impl<T> LendingIterator for WindowsIterator<T> {
    type Item<'a> = &'a [T] where T: 'a;
    
    fn next<'a>(&'a mut self) -> Option<&'a [T]> {
        if self.position + self.window_size <= self.data.len() {
            let window = &self.data[self.position..self.position + self.window_size];
            self.position += 1;
            Some(window)
        } else {
            None
        }
    }
}
```

**åœºæ™¯ 2: å¼‚æ­¥è¿­ä»£å™¨**:

```rust
trait AsyncIterator {
    type Item<'a> where Self: 'a;
    
    async fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// ç¤ºä¾‹å®ç°
struct AsyncRange {
    current: u32,
    end: u32,
}

impl AsyncIterator for AsyncRange {
    type Item<'a> = u32;
    
    async fn next<'a>(&'a mut self) -> Option<u32> {
        if self.current < self.end {
            self.current += 1;
            Some(self.current - 1)
        } else {
            None
        }
    }
}
```

### 3.3 Streaming Iterator

```rust
trait StreamingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct ChunkIterator<'data> {
    data: &'data [u8],
    chunk_size: usize,
}

impl<'data> StreamingIterator for ChunkIterator<'data> {
    type Item<'a> = &'a [u8] where Self: 'a, 'data: 'a;
    
    fn next<'a>(&'a mut self) -> Option<&'a [u8]> {
        if self.data.is_empty() {
            None
        } else {
            let (chunk, rest) = self.data.split_at(
                self.chunk_size.min(self.data.len())
            );
            self.data = rest;
            Some(chunk)
        }
    }
}

fn main() {
    let data = b"Hello, World!";
    let mut iter = ChunkIterator {
        data,
        chunk_size: 5,
    };
    
    while let Some(chunk) = iter.next() {
        println!("{:?}", std::str::from_utf8(chunk).unwrap());
    }
}
```

---

## 4. å…³è”å¸¸é‡

### 4.1 åŸºç¡€è¯­æ³•

```rust
trait HasMetadata {
    const NAME: &'static str;
    const VERSION: u32;
}

struct MyPlugin;

impl HasMetadata for MyPlugin {
    const NAME: &'static str = "MyPlugin";
    const VERSION: u32 = 1;
}

fn main() {
    println!("{} v{}", MyPlugin::NAME, MyPlugin::VERSION);
}
```

### 4.2 å®æˆ˜æ¡ˆä¾‹

**æ¡ˆä¾‹ 1: æ•°ç»„å¤§å°**:

```rust
trait FixedSizeArray {
    type Item;
    const SIZE: usize;
    
    fn as_slice(&self) -> &[Self::Item];
}

struct Array8<T> {
    data: [T; 8],
}

impl<T> FixedSizeArray for Array8<T> {
    type Item = T;
    const SIZE: usize = 8;
    
    fn as_slice(&self) -> &[T] {
        &self.data
    }
}

fn print_array_info<A: FixedSizeArray>() {
    println!("Array size: {}", A::SIZE);
}

fn main() {
    print_array_info::<Array8<i32>>();
}
```

**æ¡ˆä¾‹ 2: ç±»å‹é™åˆ¶**:

```rust
trait Numeric {
    const MIN: Self;
    const MAX: Self;
}

impl Numeric for i32 {
    const MIN: i32 = i32::MIN;
    const MAX: i32 = i32::MAX;
}

impl Numeric for u32 {
    const MIN: u32 = u32::MIN;
    const MAX: u32 = u32::MAX;
}

fn print_range<T: Numeric + std::fmt::Display>() {
    println!("Range: {} to {}", T::MIN, T::MAX);
}

fn main() {
    print_range::<i32>();
    print_range::<u32>();
}
```

---

## 5. é«˜çº§æ¨¡å¼

### 5.1 å¤šä¸ªå…³è”ç±»å‹

```rust
trait Transformer {
    type Input;
    type Output;
    type Error;
    
    fn transform(&self, input: Self::Input) 
        -> Result<Self::Output, Self::Error>;
}

struct StringToInt;

impl Transformer for StringToInt {
    type Input = String;
    type Output = i32;
    type Error = std::num::ParseIntError;
    
    fn transform(&self, input: String) -> Result<i32, Self::Error> {
        input.parse()
    }
}

fn main() {
    let transformer = StringToInt;
    match transformer.transform(String::from("42")) {
        Ok(num) => println!("Number: {}", num),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 5.2 å…³è”ç±»å‹çš„çº¦æŸ

```rust
use std::fmt::Display;

trait Processor {
    type Item: Display + Clone;  // å…³è”ç±»å‹çº¦æŸ
    
    fn process(&self, item: Self::Item) -> Self::Item;
}

struct Doubler;

impl Processor for Doubler {
    type Item = i32;  // i32 å®ç°äº† Display å’Œ Clone
    
    fn process(&self, item: i32) -> i32 {
        item * 2
    }
}

fn print_processed<P: Processor>(processor: &P, item: P::Item) {
    let result = processor.process(item);
    println!("Result: {}", result);  // å¯ä»¥ä½¿ç”¨ Display
}
```

### 5.3 å…³è”ç±»å‹çš„é»˜è®¤å€¼

```rust
trait Parser {
    type Output = String;  // é»˜è®¤ç±»å‹
    
    fn parse(&self, input: &str) -> Self::Output;
}

struct IdentityParser;

impl Parser for IdentityParser {
    // ä½¿ç”¨é»˜è®¤ç±»å‹ String
    fn parse(&self, input: &str) -> String {
        input.to_string()
    }
}

struct IntParser;

impl Parser for IntParser {
    type Output = i32;  // è¦†ç›–é»˜è®¤ç±»å‹
    
    fn parse(&self, input: &str) -> i32 {
        input.parse().unwrap_or(0)
    }
}
```

---

## 6. RPITIT (Return Position Impl Trait In Traits)

### 6.1 ä»€ä¹ˆæ˜¯ RPITITï¼Ÿ

**RPITIT** å…è®¸åœ¨ trait æ–¹æ³•çš„è¿”å›ä½ç½®ä½¿ç”¨ `impl Trait`ã€‚

```rust
trait Factory {
    fn create(&self) -> impl Display;
}

struct NumberFactory;

impl Factory for NumberFactory {
    fn create(&self) -> impl Display {
        42  // è¿”å› i32ï¼Œå®ƒå®ç°äº† Display
    }
}

struct StringFactory;

impl Factory for StringFactory {
    fn create(&self) -> impl Display {
        "hello"  // è¿”å› &strï¼Œå®ƒå®ç°äº† Display
    }
}

fn main() {
    let nf = NumberFactory;
    let sf = StringFactory;
    
    println!("{}", nf.create());
    println!("{}", sf.create());
}
```

### 6.2 å®æˆ˜æ¡ˆä¾‹

**æ¡ˆä¾‹ 1: è¿­ä»£å™¨å·¥å‚**:

```rust
trait IteratorFactory {
    type Item;
    
    fn create_iterator(&self) -> impl Iterator<Item = Self::Item>;
}

struct RangeFactory {
    start: i32,
    end: i32,
}

impl IteratorFactory for RangeFactory {
    type Item = i32;
    
    fn create_iterator(&self) -> impl Iterator<Item = i32> {
        self.start..self.end
    }
}

fn main() {
    let factory = RangeFactory { start: 1, end: 6 };
    
    for num in factory.create_iterator() {
        println!("{}", num);
    }
}
```

**æ¡ˆä¾‹ 2: å¼‚æ­¥å·¥å‚**:

```rust
use std::future::Future;

trait AsyncFactory {
    type Output;
    
    fn create(&self) -> impl Future<Output = Self::Output>;
}

struct DelayedNumberFactory;

impl AsyncFactory for DelayedNumberFactory {
    type Output = i32;
    
    fn create(&self) -> impl Future<Output = i32> {
        async { 42 }
    }
}
```

---

## 7. å®æˆ˜ç»¼åˆæ¡ˆä¾‹

### 7.1 æ¡ˆä¾‹ 1ï¼šæ•°æ®åº“æŠ½è±¡å±‚

```rust
trait Database {
    type Connection;
    type Query;
    type Result;
    type Error;
    
    fn connect(&self) -> Result<Self::Connection, Self::Error>;
    fn execute(conn: &Self::Connection, query: Self::Query) 
        -> Result<Self::Result, Self::Error>;
}

// PostgreSQL å®ç°
struct PostgreSQL;

struct PgConnection;
struct PgQuery(String);
struct PgResult(Vec<String>);

#[derive(Debug)]
struct PgError(String);

impl Database for PostgreSQL {
    type Connection = PgConnection;
    type Query = PgQuery;
    type Result = PgResult;
    type Error = PgError;
    
    fn connect(&self) -> Result<PgConnection, PgError> {
        Ok(PgConnection)
    }
    
    fn execute(
        _conn: &PgConnection,
        query: PgQuery,
    ) -> Result<PgResult, PgError> {
        println!("Executing PostgreSQL query: {}", query.0);
        Ok(PgResult(vec![String::from("result")]))
    }
}

// SQLite å®ç°
struct SQLite;

struct SqliteConnection;
struct SqliteQuery(String);
struct SqliteResult(Vec<String>);

#[derive(Debug)]
struct SqliteError(String);

impl Database for SQLite {
    type Connection = SqliteConnection;
    type Query = SqliteQuery;
    type Result = SqliteResult;
    type Error = SqliteError;
    
    fn connect(&self) -> Result<SqliteConnection, SqliteError> {
        Ok(SqliteConnection)
    }
    
    fn execute(
        _conn: &SqliteConnection,
        query: SqliteQuery,
    ) -> Result<SqliteResult, SqliteError> {
        println!("Executing SQLite query: {}", query.0);
        Ok(SqliteResult(vec![String::from("result")]))
    }
}

fn use_database<D: Database>(db: &D) 
where
    D::Query: From<String>,
{
    match db.connect() {
        Ok(conn) => {
            let query = D::Query::from(String::from("SELECT * FROM users"));
            match D::execute(&conn, query) {
                Ok(_result) => println!("Query successful"),
                Err(_e) => println!("Query failed"),
            }
        }
        Err(_e) => println!("Connection failed"),
    }
}

impl From<String> for PgQuery {
    fn from(s: String) -> Self {
        PgQuery(s)
    }
}

impl From<String> for SqliteQuery {
    fn from(s: String) -> Self {
        SqliteQuery(s)
    }
}

fn main() {
    let pg = PostgreSQL;
    let sqlite = SQLite;
    
    use_database(&pg);
    use_database(&sqlite);
}
```

### 7.2 æ¡ˆä¾‹ 2ï¼šParser Combinator

```rust
trait Parser {
    type Input;
    type Output;
    type Error;
    
    fn parse(&self, input: Self::Input) 
        -> Result<(Self::Output, Self::Input), Self::Error>;
}

struct IntParser;

impl Parser for IntParser {
    type Input = String;
    type Output = i32;
    type Error = String;
    
    fn parse(&self, input: String) -> Result<(i32, String), String> {
        let parts: Vec<&str> = input.splitn(2, ' ').collect();
        if let Some(first) = parts.first() {
            if let Ok(num) = first.parse::<i32>() {
                let rest = parts.get(1)
                    .map(|s| s.to_string())
                    .unwrap_or_default();
                return Ok((num, rest));
            }
        }
        Err(String::from("Parse error"))
    }
}

fn main() {
    let parser = IntParser;
    let input = String::from("42 hello");
    
    match parser.parse(input) {
        Ok((num, rest)) => {
            println!("Parsed: {}", num);
            println!("Remaining: {}", rest);
        }
        Err(e) => println!("Error: {}", e),
    }
}
```

---

## 8. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### 8.1 å¸¸è§é”™è¯¯

**é”™è¯¯ 1: æ··æ·†å…³è”ç±»å‹å’Œæ³›å‹å‚æ•°**:

```rust
// âŒ é”™è¯¯ï¼šåº”è¯¥ä½¿ç”¨å…³è”ç±»å‹
trait Iterator<Item> {
    fn next(&mut self) -> Option<Item>;
}

// âœ… æ­£ç¡®
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

**é”™è¯¯ 2: GAT ç”Ÿå‘½å‘¨æœŸçº¦æŸé”™è¯¯**:

```rust
// âŒ é”™è¯¯ï¼šç¼ºå°‘ where å­å¥
trait LendingIterator {
    type Item<'a>;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// âœ… æ­£ç¡®
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}
```

**é”™è¯¯ 3: å…³è”ç±»å‹çº¦æŸé—æ¼**:

```rust
// âŒ é”™è¯¯ï¼šT::Item å¯èƒ½ä¸å®ç° Display
fn print_items<T: Iterator>(iter: &T) {
    // println!("{}", item); // ç¼–è¯‘é”™è¯¯
}

// âœ… æ­£ç¡®
fn print_items<T>(iter: &T)
where
    T: Iterator,
    T::Item: std::fmt::Display,
{
    // ç°åœ¨å¯ä»¥æ‰“å°äº†
}
```

### 8.2 æœ€ä½³å®è·µ

**1. é€‰æ‹©åˆé€‚çš„æŠ½è±¡**:

```rust
// ä½¿ç”¨å…³è”ç±»å‹ï¼šä¸€å¯¹ä¸€å…³ç³»
trait Container {
    type Item;
    fn get(&self, index: usize) -> Option<&Self::Item>;
}

// ä½¿ç”¨æ³›å‹å‚æ•°ï¼šä¸€å¯¹å¤šå…³ç³»
trait Converter<From, To> {
    fn convert(&self, from: From) -> To;
}
```

**2. ä¸ºå…³è”ç±»å‹æ·»åŠ çº¦æŸ**:

```rust
trait Processor {
    type Item: Clone + std::fmt::Debug;  // æ˜ç¡®çº¦æŸ
    
    fn process(&self, item: Self::Item) -> Self::Item;
}
```

**3. æä¾›åˆç†çš„é»˜è®¤å€¼**:

```rust
trait Config {
    type Storage = std::collections::HashMap<String, String>;
    
    fn get_storage(&self) -> Self::Storage;
}
```

**4. ä½¿ç”¨ GAT å¤„ç†å€Ÿç”¨**:

```rust
// å½“éœ€è¦è¿”å›å€Ÿç”¨æ—¶ï¼Œä½¿ç”¨ GAT
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [04_ç±»å‹æ¨æ–­æŒ‡å—.md](./04_ç±»å‹æ¨æ–­æŒ‡å—.md) - ç±»å‹æ¨æ–­ä¸å…³è”ç±»å‹
- [../tier_03_references/04_å…³è”ç±»å‹å‚è€ƒ.md](../tier_03_references/04_å…³è”ç±»å‹å‚è€ƒ.md) - å®Œæ•´è¯­æ³•å‚è€ƒ
- [../tier_04_advanced/02_æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ.md](../tier_04_advanced/02_æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ.md) - GAT ä¸ç”Ÿå‘½å‘¨æœŸ
- [../tier_01_foundations/03_æœ¯è¯­è¡¨.md](../tier_01_foundations/03_æœ¯è¯­è¡¨.md#gat-generic-associated-types) - GAT æœ¯è¯­

---

## ğŸ¯ ç»ƒä¹ é¢˜

**ç»ƒä¹  1: å®ç°ä¸€ä¸ªç®€å•çš„ LendingIterator**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// ä¸º Vec<String> å®ç° LendingIterator
struct VecIter {
    data: Vec<String>,
    index: usize,
}

// ä½ çš„å®ç°
```

**ç»ƒä¹  2: åˆ›å»ºä¸€ä¸ªç±»å‹å®‰å…¨çš„æ„å»ºå™¨**:

ä½¿ç”¨å…³è”ç±»å‹åˆ›å»ºä¸€ä¸ªç±»å‹å®‰å…¨çš„æ„å»ºå™¨æ¨¡å¼ã€‚

**ç»ƒä¹  3: å®ç° Parser Combinator**:

å®ç°ä¸€ä¸ªæ”¯æŒç»„åˆçš„è§£æå™¨ç³»ç»Ÿã€‚

---

## ğŸ“ å°ç»“

åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ï¼š

- âœ… **å…³è”ç±»å‹åŸºç¡€**: å®šä¹‰ã€å®ç°ã€ä½¿ç”¨åœºæ™¯
- âœ… **å…³è”ç±»å‹ vs æ³›å‹å‚æ•°**: ä½•æ—¶ä½¿ç”¨å“ªç§
- âœ… **GAT**: æ³›å‹å…³è”ç±»å‹çš„å¼ºå¤§åŠŸèƒ½
- âœ… **å…³è”å¸¸é‡**: ç±»å‹çº§åˆ«çš„å¸¸é‡
- âœ… **RPITIT**: è¿”å›ä½ç½® impl Trait
- âœ… **é«˜çº§æ¨¡å¼**: å¤šä¸ªå…³è”ç±»å‹ã€çº¦æŸã€é»˜è®¤å€¼
- âœ… **å®æˆ˜æ¡ˆä¾‹**: æ•°æ®åº“æŠ½è±¡ã€Parser Combinator

**ä¸‹ä¸€æ­¥å­¦ä¹ **:

1. [04_ç±»å‹æ¨æ–­æŒ‡å—.md](./04_ç±»å‹æ¨æ–­æŒ‡å—.md) - ç†è§£ç±»å‹æ¨æ–­
2. [05_å®æˆ˜æ¨¡å¼æŒ‡å—.md](./05_å®æˆ˜æ¨¡å¼æŒ‡å—.md) - å­¦ä¹ è®¾è®¡æ¨¡å¼
3. [../tier_04_advanced/04_ç±»å‹çº§ç¼–ç¨‹.md](../tier_04_advanced/04_ç±»å‹çº§ç¼–ç¨‹.md) - é«˜çº§ç±»å‹æŠ€å·§

---

**æ–‡æ¡£å…ƒä¿¡æ¯**:

- åˆ›å»ºæ—¥æœŸ: 2025-10-22
- ä½œè€…: Rust-Lang Project
- è®¸å¯: MIT OR Apache-2.0
