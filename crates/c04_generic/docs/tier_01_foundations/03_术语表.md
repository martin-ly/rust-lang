# C04 泛型编程 - 术语表

## 📊 目录

- [C04 泛型编程 - 术语表](#c04-泛型编程---术语表)
  - [📊 目录](#-目录)
  - [🎯 如何使用本术语表](#-如何使用本术语表)
    - [快速查找](#快速查找)
    - [术语标记](#术语标记)
    - [术语格式](#术语格式)
  - [📚 术语索引 (按字母顺序)](#-术语索引-按字母顺序)
    - [A-C](#a-c)
    - [D-G](#d-g)
    - [H-M](#h-m)
    - [N-S](#n-s)
    - [T-Z](#t-z)
  - [📖 术语详解 (按主题分类)](#-术语详解-按主题分类)
    - [A. 泛型基础](#a-泛型基础)
      - [Generic (泛型) 🔵](#generic-泛型-)
      - [Type Parameter (类型参数) 🔵](#type-parameter-类型参数-)
      - [Generic Function (泛型函数) 🔵](#generic-function-泛型函数-)
      - [Const Generic (常量泛型) 🟢](#const-generic-常量泛型-)
      - [Default Type Parameter (默认类型参数) 🟢](#default-type-parameter-默认类型参数-)
    - [B. Trait 系统](#b-trait-系统)
      - [Trait (trait) 🔵](#trait-trait-)
      - [Trait Bound (trait 约束) 🔵](#trait-bound-trait-约束-)
      - [Trait Object (trait 对象) 🟢](#trait-object-trait-对象-)
      - [Impl Trait (impl Trait) 🟢](#impl-trait-impl-trait-)
      - [Supertraits (超 trait) 🟢](#supertraits-超-trait-)
      - [Marker Trait (标记 trait) 🟢](#marker-trait-标记-trait-)
      - [Blanket Implementation (全面实现) 🟡](#blanket-implementation-全面实现-)
    - [C. 关联类型与 GAT](#c-关联类型与-gat)
      - [Associated Type (关联类型) 🟢](#associated-type-关联类型-)
      - [GAT (Generic Associated Types) (泛型关联类型) 🟡](#gat-generic-associated-types-泛型关联类型-)
      - [Associated Const (关联常量) 🟢](#associated-const-关联常量-)
    - [D. 约束与边界](#d-约束与边界)
      - [Bound (约束) 🔵](#bound-约束-)
      - [Where Clause (where 子句) 🔵](#where-clause-where-子句-)
      - [Higher-Rank Trait Bounds (HRTB) (高阶 trait 边界) 🟡](#higher-rank-trait-bounds-hrtb-高阶-trait-边界-)
    - [E. 生命周期](#e-生命周期)
      - [Lifetime (生命周期) 🔵](#lifetime-生命周期-)
      - [Variance (型变) 🔴](#variance-型变-)
      - [Subtyping (子类型) 🟡](#subtyping-子类型-)
    - [F. 编译器行为](#f-编译器行为)
      - [Monomorphization (单态化) 🟡](#monomorphization-单态化-)
      - [Type Erasure (类型擦除) 🟡](#type-erasure-类型擦除-)
      - [Static Dispatch (静态分发) 🟢](#static-dispatch-静态分发-)
      - [Dynamic Dispatch (动态分发) 🟢](#dynamic-dispatch-动态分发-)
      - [Fat Pointer (胖指针) 🟡](#fat-pointer-胖指针-)
    - [G. 高级特性](#g-高级特性)
      - [Phantom Data (幽灵数据) 🟡](#phantom-data-幽灵数据-)
      - [Zero-Sized Type (ZST) (零大小类型) 🟡](#zero-sized-type-zst-零大小类型-)
      - [RPITIT (返回位置 impl Trait) 🟢](#rpitit-返回位置-impl-trait-)
      - [Higher-Kinded Types (HKT) (高阶类型) 🔴](#higher-kinded-types-hkt-高阶类型-)
    - [H. 性能相关](#h-性能相关)
      - [Zero-Cost Abstraction (零成本抽象) 🟢](#zero-cost-abstraction-零成本抽象-)
      - [Turbofish (涡轮鱼语法) 🟢](#turbofish-涡轮鱼语法-)
    - [I. 类型理论](#i-类型理论)
      - [Polymorphism (多态性) 🔵](#polymorphism-多态性-)
      - [Type Constructor (类型构造器) 🟡](#type-constructor-类型构造器-)
      - [Coherence (一致性) 🟡](#coherence-一致性-)
      - [Orphan Rule (孤儿规则) 🟡](#orphan-rule-孤儿规则-)
  - [🔤 中英对照表](#-中英对照表)
    - [A-G](#a-g)
    - [H-Z](#h-z)
  - [📚 相关文档](#-相关文档)
    - [按术语级别](#按术语级别)
    - [深入理解](#深入理解)

**版本**: 1.0.0  
**最后更新**: 2025-10-22  
**术语数量**: 100+ 术语  
**索引类型**: 按字母顺序 + 按主题分类

---

## 🎯 如何使用本术语表

### 快速查找

1. **按字母查找**: 如果知道术语的英文或中文首字母，使用 [术语索引](#-术语索引-按字母顺序)
2. **按主题查找**: 如果想了解某个主题的所有术语，使用 [术语详解](#-术语详解-按主题分类)
3. **中英对照**: 如果想查找中英文对应，使用 [中英对照表](#-中英对照表)

### 术语标记

- 🔵 **基础术语**: 初学者必须掌握
- 🟢 **中级术语**: 实际开发中常用
- 🟡 **高级术语**: 深入理解需要
- 🔴 **专家术语**: 专家级别概念

### 术语格式

每个术语条目包含：

- **术语名称** (中文 / English)
- **定义**: 简洁准确的定义
- **代码示例**: 展示用法的简短代码
- **相关术语**: 关联的其他术语
- **参考文档**: 详细说明所在文档

---

## 📚 术语索引 (按字母顺序)

### A-C

| 术语 | 中文 | 级别 | 定义简述 |
|-----|------|------|---------|
| **Abstract Data Type (ADT)** | 抽象数据类型 | 🔵 | 定义数据和操作的抽象接口 |
| **Associated Const** | 关联常量 | 🟢 | trait 中定义的常量 |
| **Associated Type** | 关联类型 | 🟢 | trait 中定义的类型占位符 |
| **Blanket Implementation** | 全面实现 | 🟡 | 为满足条件的所有类型实现 trait |
| **Bound** | 约束 | 🔵 | 对类型参数的限制条件 |
| **Boxed Trait Object** | 装箱 trait 对象 | 🟢 | `Box<dyn Trait>` 形式的 trait 对象 |
| **Coherence** | 一致性 | 🟡 | 防止 trait 实现冲突的规则 |
| **Const Generic** | 常量泛型 | 🟢 | 使用常量作为泛型参数 |

### D-G

| 术语 | 中文 | 级别 | 定义简述 |
|-----|------|------|---------|
| **Default Type Parameter** | 默认类型参数 | 🟢 | 泛型参数的默认值 |
| **Dispatch** | 分发 | 🔵 | 选择具体方法实现的机制 |
| **Dynamic Dispatch** | 动态分发 | 🟢 | 运行时确定方法实现 |
| **Fat Pointer** | 胖指针 | 🟡 | 包含额外信息的指针 |
| **GAT (Generic Associated Types)** | 泛型关联类型 | 🟡 | 关联类型带泛型参数 |
| **Generic** | 泛型 | 🔵 | 参数化的类型或函数 |
| **Generic Function** | 泛型函数 | 🔵 | 使用类型参数的函数 |

### H-M

| 术语 | 中文 | 级别 | 定义简述 |
|-----|------|------|---------|
| **Higher-Kinded Types (HKT)** | 高阶类型 | 🔴 | 类型构造器的抽象 |
| **Higher-Rank Trait Bounds (HRTB)** | 高阶 trait 边界 | 🟡 | `for<'a>` 形式的边界 |
| **Impl Trait** | impl Trait | 🟢 | 返回/接受实现某 trait 的类型 |
| **Inference** | 类型推断 | 🔵 | 编译器自动推导类型 |
| **Lifetime** | 生命周期 | 🔵 | 引用有效性的作用域 |
| **Marker Trait** | 标记 trait | 🟢 | 不包含方法的 trait |
| **Monomorphization** | 单态化 | 🟡 | 为每个类型生成专门代码 |

### N-S

| 术语 | 中文 | 级别 | 定义简述 |
|-----|------|------|---------|
| **Orphan Rule** | 孤儿规则 | 🟡 | trait 实现的限制规则 |
| **Phantom Data** | 幽灵数据 | 🟡 | 零大小的类型标记 |
| **Polymorphism** | 多态性 | 🔵 | 一个接口多种实现 |
| **RPITIT** | 返回位置 impl Trait | 🟢 | trait 方法返回 impl Trait |
| **Static Dispatch** | 静态分发 | 🟢 | 编译时确定方法实现 |
| **Subtyping** | 子类型 | 🟡 | 类型之间的包含关系 |
| **Supertraits** | 超 trait | 🟢 | trait 的父 trait |

### T-Z

| 术语 | 中文 | 级别 | 定义简述 |
|-----|------|------|---------|
| **Trait** | trait | 🔵 | 定义行为的接口 |
| **Trait Bound** | trait 约束 | 🔵 | 要求类型实现某 trait |
| **Trait Object** | trait 对象 | 🟢 | `dyn Trait` 形式的动态类型 |
| **Turbofish** | 涡轮鱼语法 | 🟢 | `::<>` 显式指定类型 |
| **Type Alias** | 类型别名 | 🔵 | 为类型定义新名称 |
| **Type Constructor** | 类型构造器 | 🟡 | 构造新类型的机制 |
| **Type Erasure** | 类型擦除 | 🟡 | 删除类型信息的过程 |
| **Type Parameter** | 类型参数 | 🔵 | 泛型的参数 |
| **Variance** | 型变 | 🔴 | 泛型类型的子类型关系 |
| **Where Clause** | where 子句 | 🔵 | 指定 trait 约束的语法 |
| **Zero-Cost Abstraction** | 零成本抽象 | 🟢 | 无运行时开销的抽象 |
| **Zero-Sized Type (ZST)** | 零大小类型 | 🟡 | 不占用内存的类型 |

---

## 📖 术语详解 (按主题分类)

### A. 泛型基础

#### Generic (泛型) 🔵

**定义**: 参数化的类型或函数，允许在定义时使用类型参数，在使用时指定具体类型。

**代码示例**:

```rust
// 泛型函数
fn identity<T>(value: T) -> T {
    value
}

// 泛型结构体
struct Container<T> {
    value: T,
}

// 使用
let x = identity(42);         // T = i32
let c = Container { value: "hello" }; // T = &str
```

**相关术语**: [Type Parameter](#type-parameter-类型参数-), [Monomorphization](#monomorphization-单态化-), [Generic Function](#generic-function-泛型函数-)

**参考文档**: [`tier_02_guides/01_泛型基础指南.md`](../tier_02_guides/01_泛型基础指南.md)

---

#### Type Parameter (类型参数) 🔵

**定义**: 泛型定义中的占位符，代表任意类型，在使用时被具体类型替换。

**代码示例**:

```rust
// T 是类型参数
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// T 和 U 是不同的类型参数
struct Pair<T, U> {
    first: T,
    second: U,
}
```

**命名约定**:

- 单字母大写: `T`, `U`, `V`, `E`, `K`, `V`
- 描述性命名: `Item`, `Error`, `Key`, `Value`

**相关术语**: [Generic](#generic-泛型-), [Bound](#bound-约束-), [Default Type Parameter](#default-type-parameter-默认类型参数-)

**参考文档**: [`tier_03_references/01_泛型语法参考.md`](../tier_03_references/01_泛型语法参考.md)

---

#### Generic Function (泛型函数) 🔵

**定义**: 使用类型参数定义的函数，可以处理多种类型的数据。

**代码示例**:

```rust
// 简单泛型函数
fn swap<T>(a: &mut T, b: &mut T) {
    std::mem::swap(a, b);
}

// 带约束的泛型函数
fn print_value<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

// 多个类型参数
fn combine<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}
```

**相关术语**: [Type Parameter](#type-parameter-类型参数-), [Trait Bound](#trait-bound-trait-约束-), [Monomorphization](#monomorphization-单态化-)

**参考文档**: [`tier_02_guides/01_泛型基础指南.md`](../tier_02_guides/01_泛型基础指南.md)

---

#### Const Generic (常量泛型) 🟢

**定义**: 使用编译时常量作为泛型参数，允许在类型中编码数值信息。

**代码示例**:

```rust
// 数组长度作为泛型参数
struct Array<T, const N: usize> {
    data: [T; N],
}

// 使用
let arr: Array<i32, 5> = Array {
    data: [1, 2, 3, 4, 5],
};

// 泛型函数使用 const 泛型
fn sum<const N: usize>(arr: &[i32; N]) -> i32 {
    arr.iter().sum()
}
```

**应用场景**:

- 固定大小数组
- 矩阵维度
- 缓冲区大小

**相关术语**: [Type Parameter](#type-parameter-类型参数-), [Associated Const](#associated-const-关联常量-)

**参考文档**: [`tier_02_guides/01_泛型基础指南.md`](../tier_02_guides/01_泛型基础指南.md)

---

#### Default Type Parameter (默认类型参数) 🟢

**定义**: 为泛型参数指定默认类型，如果使用时未指定则使用默认值。

**代码示例**:

```rust
// E 默认为 std::io::Error
struct MyResult<T, E = std::io::Error> {
    value: Result<T, E>,
}

// 使用默认类型
let r1: MyResult<i32> = MyResult {
    value: Ok(42),  // E = std::io::Error
};

// 显式指定类型
let r2: MyResult<String, ParseError> = MyResult {
    value: Err(ParseError),  // E = ParseError
};
```

**相关术语**: [Type Parameter](#type-parameter-类型参数-), [Generic](#generic-泛型-)

**参考文档**: [`tier_03_references/01_泛型语法参考.md`](../tier_03_references/01_泛型语法参考.md)

---

### B. Trait 系统

#### Trait (trait) 🔵

**定义**: Rust 的接口机制，定义类型必须实现的方法集合，用于抽象行为。

**代码示例**:

```rust
// 定义 trait
trait Drawable {
    fn draw(&self);
    
    // 默认实现
    fn hide(&self) {
        println!("Hidden");
    }
}

// 实现 trait
struct Circle;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}
```

**标准库重要 trait**:

- `Clone`, `Copy`: 复制语义
- `Debug`, `Display`: 格式化输出
- `PartialEq`, `Eq`: 相等性比较
- `PartialOrd`, `Ord`: 排序比较
- `Iterator`: 迭代器
- `From`, `Into`: 类型转换

**相关术语**: [Trait Bound](#trait-bound-trait-约束-), [Trait Object](#trait-object-trait-对象-), [Supertraits](#supertraits-超-trait-)

**参考文档**: [`tier_02_guides/02_Trait系统指南.md`](../tier_02_guides/02_Trait系统指南.md)

---

#### Trait Bound (trait 约束) 🔵

**定义**: 对泛型参数的限制，要求类型必须实现指定的 trait。

**代码示例**:

```rust
// 单个 trait 约束
fn print<T: Display>(value: T) {
    println!("{}", value);
}

// 多个 trait 约束 (+)
fn process<T: Clone + Send>(value: T) { /* ... */ }

// where 子句（推荐用于复杂约束）
fn complex<T, U>(a: T, b: U)
where
    T: Clone + Display,
    U: Debug + PartialEq,
{
    // ...
}
```

**语法形式**:

1. `<T: Trait>`: 内联约束
2. `where T: Trait`: where 子句
3. `<T: Trait1 + Trait2>`: 多重约束
4. `<T: Trait<Item = Type>>`: 关联类型约束

**相关术语**: [Trait](#trait-trait-), [Where Clause](#where-clause-where-子句-), [HRTB](#higher-rank-trait-bounds-hrtb-高阶-trait-边界-)

**参考文档**: [`tier_03_references/03_边界约束参考.md`](../tier_03_references/03_边界约束参考.md)

---

#### Trait Object (trait 对象) 🟢

**定义**: 运行时多态的机制，使用 `dyn Trait` 语法，通过虚函数表实现动态分发。

**代码示例**:

```rust
trait Animal {
    fn make_sound(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn make_sound(&self) { println!("Woof!"); }
}

impl Animal for Cat {
    fn make_sound(&self) { println!("Meow!"); }
}

// trait 对象
fn make_noise(animal: &dyn Animal) {
    animal.make_sound();
}

// 使用
let dog = Dog;
let cat = Cat;
make_noise(&dog);  // Woof!
make_noise(&cat);  // Meow!

// Boxed trait object
let animals: Vec<Box<dyn Animal>> = vec![
    Box::new(Dog),
    Box::new(Cat),
];
```

**特点**:

- ✅ 运行时多态
- ✅ 类型擦除
- ❌ 性能开销（虚函数调用）
- ❌ 不是所有 trait 都可以成为 trait 对象（需满足对象安全）

**相关术语**: [Dynamic Dispatch](#dynamic-dispatch-动态分发-), [Fat Pointer](#fat-pointer-胖指针-), [Type Erasure](#type-erasure-类型擦除-)

**参考文档**: [`tier_02_guides/02_Trait系统指南.md`](../tier_02_guides/02_Trait系统指南.md)

---

#### Impl Trait (impl Trait) 🟢

**定义**: 在函数参数或返回值位置使用 `impl Trait` 语法，表示实现某 trait 的具体类型。

**代码示例**:

```rust
// 参数位置：接受任何实现 Display 的类型
fn print_something(value: impl Display) {
    println!("{}", value);
}

// 等价于
fn print_something<T: Display>(value: T) {
    println!("{}", value);
}

// 返回位置：返回实现 Iterator 的类型（编译器知道具体类型）
fn get_numbers() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}

// 多个 trait
fn process(x: impl Clone + Send + Display) { /* ... */ }
```

**与 trait 对象的对比**:

```rust
// impl Trait (静态分发)
fn static_dispatch() -> impl Display {
    42  // 编译器知道返回 i32
}

// trait 对象 (动态分发)
fn dynamic_dispatch() -> Box<dyn Display> {
    Box::new(42)  // 运行时确定类型
}
```

**相关术语**: [RPITIT](#rpitit-返回位置-impl-trait-), [Static Dispatch](#static-dispatch-静态分发-), [Trait Object](#trait-object-trait-对象-)

**参考文档**: [`tier_02_guides/02_Trait系统指南.md`](../tier_02_guides/02_Trait系统指南.md)

---

#### Supertraits (超 trait) 🟢

**定义**: trait 的依赖关系，子 trait 要求实现者必须先实现父 trait。

**代码示例**:

```rust
// Display 依赖 Debug
trait PrintableDebug: Debug {
    fn print_debug(&self) {
        println!("{:?}", self);
    }
}

// 多个超 trait
trait AdvancedDisplay: Display + Debug + Clone {
    fn fancy_display(&self) {
        println!("Fancy: {}", self);
    }
}

// 实现时必须先实现超 trait
#[derive(Debug, Clone)]
struct MyType(i32);

impl Display for MyType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl AdvancedDisplay for MyType {}
```

**相关术语**: [Trait](#trait-trait-), [Trait Bound](#trait-bound-trait-约束-)

**参考文档**: [`tier_03_references/02_Trait系统参考.md`](../tier_03_references/02_Trait系统参考.md)

---

#### Marker Trait (标记 trait) 🟢

**定义**: 不包含任何方法的 trait，仅用于标记类型具有某种特性。

**代码示例**:

```rust
// Rust 标准库的标记 trait
// Send: 可以安全地在线程间转移所有权
// Sync: 可以安全地在线程间共享引用
// Copy: 可以按位复制

// 自定义标记 trait
trait Serializable {}

struct Data {
    value: i32,
}

impl Serializable for Data {}

// 使用标记 trait 约束
fn save<T: Serializable>(data: T) {
    // 只接受实现了 Serializable 的类型
}
```

**常见标记 trait**:

- `Send`: 可跨线程传递
- `Sync`: 可跨线程共享
- `Copy`: 可按位复制
- `Sized`: 编译时已知大小
- `Unpin`: 可安全移动

**相关术语**: [Trait](#trait-trait-)

**参考文档**: [`tier_03_references/02_Trait系统参考.md`](../tier_03_references/02_Trait系统参考.md)

---

#### Blanket Implementation (全面实现) 🟡

**定义**: 为所有满足特定条件的类型自动实现 trait。

**代码示例**:

```rust
// 标准库示例：为所有实现 From 的类型自动实现 Into
impl<T, U> Into<U> for T
where
    U: From<T>,
{
    fn into(self) -> U {
        U::from(self)
    }
}

// 自定义全面实现
trait Printable {
    fn print(&self);
}

// 为所有实现 Display 的类型实现 Printable
impl<T: Display> Printable for T {
    fn print(&self) {
        println!("{}", self);
    }
}

// 现在任何实现 Display 的类型都自动实现了 Printable
42.print();        // ✅
"hello".print();   // ✅
```

**相关术语**: [Trait](#trait-trait-), [Coherence](#coherence-一致性-)

**参考文档**: [`tier_04_advanced/05_设计模式进阶.md`](../tier_04_advanced/05_设计模式进阶.md)

---

### C. 关联类型与 GAT

#### Associated Type (关联类型) 🟢

**定义**: trait 中定义的类型占位符，由实现者指定具体类型。

**代码示例**:

```rust
// 定义关联类型
trait Container {
    type Item;
    
    fn add(&mut self, item: Self::Item);
    fn get(&self, index: usize) -> Option<&Self::Item>;
}

// 实现并指定关联类型
struct IntList {
    items: Vec<i32>,
}

impl Container for IntList {
    type Item = i32;  // 指定 Item 为 i32
    
    fn add(&mut self, item: Self::Item) {
        self.items.push(item);
    }
    
    fn get(&self, index: usize) -> Option<&Self::Item> {
        self.items.get(index)
    }
}
```

**与泛型参数的对比**:

```rust
// 使用泛型参数（调用者选择类型）
trait ContainerGeneric<T> {
    fn add(&mut self, item: T);
}

// 使用关联类型（实现者选择类型）
trait ContainerAssoc {
    type Item;
    fn add(&mut self, item: Self::Item);
}
```

**相关术语**: [GAT](#gat-generic-associated-types-泛型关联类型-), [Trait](#trait-trait-), [Type Parameter](#type-parameter-类型参数-)

**参考文档**: [`tier_02_guides/03_关联类型指南.md`](../tier_02_guides/03_关联类型指南.md)

---

#### GAT (Generic Associated Types) (泛型关联类型) 🟡

**定义**: 关联类型带有泛型参数，允许关联类型本身是泛型的。(Rust 1.65+ 稳定)

**代码示例**:

```rust
// 经典示例：LendingIterator
trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// 实现：返回对内部数据的引用
struct WindowsMut<'data, T> {
    data: &'data mut [T],
    window_size: usize,
    index: usize,
}

impl<'data, T> LendingIterator for WindowsMut<'data, T> {
    type Item<'a> = &'a mut [T] where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        if self.index + self.window_size <= self.data.len() {
            let start = self.index;
            let end = start + self.window_size;
            self.index += 1;
            Some(&mut self.data[start..end])
        } else {
            None
        }
    }
}
```

**应用场景**:

- Lending iterators（借用迭代器）
- 返回引用的迭代器
- 数据库查询结果
- 异步 trait

**相关术语**: [Associated Type](#associated-type-关联类型-), [Lifetime](#lifetime-生命周期-), [HRTB](#higher-rank-trait-bounds-hrtb-高阶-trait-边界-)

**参考文档**: [`tier_03_references/04_关联类型参考.md`](../tier_03_references/04_关联类型参考.md)

---

#### Associated Const (关联常量) 🟢

**定义**: trait 中定义的常量，由实现者提供具体值。

**代码示例**:

```rust
trait Config {
    const MAX_SIZE: usize;
    const NAME: &'static str;
}

struct SmallConfig;
struct LargeConfig;

impl Config for SmallConfig {
    const MAX_SIZE: usize = 100;
    const NAME: &'static str = "Small";
}

impl Config for LargeConfig {
    const MAX_SIZE: usize = 10000;
    const NAME: &'static str = "Large";
}

// 使用
fn process<C: Config>(data: &[u8]) {
    assert!(data.len() <= C::MAX_SIZE);
    println!("Processing with {}", C::NAME);
}
```

**相关术语**: [Associated Type](#associated-type-关联类型-), [Const Generic](#const-generic-常量泛型-)

**参考文档**: [`tier_03_references/02_Trait系统参考.md`](../tier_03_references/02_Trait系统参考.md)

---

### D. 约束与边界

#### Bound (约束) 🔵

**定义**: 对泛型参数的限制条件，包括 trait 约束和生命周期约束。

**代码示例**:

```rust
// Trait 约束
fn process<T: Clone + Send>(value: T) { /* ... */ }

// 生命周期约束
fn get_ref<'a, T: 'a>(value: &'a T) -> &'a T { value }

// 关联类型约束
fn iterate<I>(iter: I)
where
    I: Iterator<Item = i32>,
{
    // ...
}
```

**约束类型**:

1. Trait bounds: `T: Trait`
2. Lifetime bounds: `'a: 'b`
3. Type bounds: `T: 'a`
4. Associated type bounds: `T::Item: Trait`

**相关术语**: [Trait Bound](#trait-bound-trait-约束-), [Where Clause](#where-clause-where-子句-), [HRTB](#higher-rank-trait-bounds-hrtb-高阶-trait-边界-)

**参考文档**: [`tier_03_references/03_边界约束参考.md`](../tier_03_references/03_边界约束参考.md)

---

#### Where Clause (where 子句) 🔵

**定义**: 在函数或类型定义末尾使用 `where` 关键字指定泛型约束，比内联约束更清晰。

**代码示例**:

```rust
// 复杂约束使用 where 子句
fn complex_function<T, U, V>(a: T, b: U, c: V)
where
    T: Display + Clone,
    U: Debug + Send,
    V: Iterator<Item = i32>,
{
    // ...
}

// 结构体使用 where 子句
struct Container<T>
where
    T: Clone + Send,
{
    value: T,
}

// impl 块使用 where 子句
impl<T> Container<T>
where
    T: Clone + Send + Default,
{
    fn new() -> Self {
        Container {
            value: T::default(),
        }
    }
}
```

**优势**:

- 更清晰的约束表达
- 支持复杂的约束组合
- 可读性更好

**相关术语**: [Bound](#bound-约束-), [Trait Bound](#trait-bound-trait-约束-)

**参考文档**: [`tier_03_references/03_边界约束参考.md`](../tier_03_references/03_边界约束参考.md)

---

#### Higher-Rank Trait Bounds (HRTB) (高阶 trait 边界) 🟡

**定义**: 使用 `for<'a>` 语法表示对所有可能的生命周期都成立的约束。

**代码示例**:

```rust
// 函数接受一个闭包，该闭包对任意生命周期 'a 的引用都适用
fn call_with_ref<F>(f: F)
where
    F: for<'a> Fn(&'a i32) -> &'a i32,
{
    let x = 42;
    let result = f(&x);
    println!("{}", result);
}

// 使用
call_with_ref(|x| x);  // ✅ 闭包对任意生命周期都有效

// Fn trait 的实际定义使用了 HRTB
trait Fn<Args>: FnMut<Args> {
    extern "rust-call" fn call(&self, args: Args) -> Self::Output;
}

// for<'a> 表示对所有 'a 都成立
fn process<F>(f: F)
where
    F: for<'a, 'b> Fn(&'a str, &'b str) -> String,
{
    // ...
}
```

**应用场景**:

- 闭包参数是引用
- trait 对象带生命周期
- 高阶函数

**相关术语**: [Lifetime](#lifetime-生命周期-), [Bound](#bound-约束-), [Where Clause](#where-clause-where-子句-)

**参考文档**: [`tier_04_advanced/02_泛型与生命周期.md`](../tier_04_advanced/02_泛型与生命周期.md)

---

### E. 生命周期

#### Lifetime (生命周期) 🔵

**定义**: 引用有效的作用域，确保引用始终指向有效的数据。

**代码示例**:

```rust
// 函数签名中的生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// 结构体中的生命周期
struct Borrowed<'a> {
    data: &'a str,
}

// impl 块中的生命周期
impl<'a> Borrowed<'a> {
    fn get_data(&self) -> &'a str {
        self.data
    }
}
```

**生命周期省略规则**:

1. 每个引用参数获得独立的生命周期
2. 如果只有一个输入生命周期，赋给所有输出
3. 如果有 `&self` 或 `&mut self`，其生命周期赋给所有输出

**相关术语**: [HRTB](#higher-rank-trait-bounds-hrtb-高阶-trait-边界-), [Variance](#variance-型变-), [Subtyping](#subtyping-子类型-)

**参考文档**: [`tier_04_advanced/02_泛型与生命周期.md`](../tier_04_advanced/02_泛型与生命周期.md)

---

#### Variance (型变) 🔴

**定义**: 泛型类型在其类型参数的子类型关系上的行为规则。

**三种型变**:

1. **Covariant (协变)**: `T'` 是 `T` 的子类型 ⇒ `F<T'>` 是 `F<T>` 的子类型
2. **Contravariant (逆变)**: `T'` 是 `T` 的子类型 ⇒ `F<T>` 是 `F<T'>` 的子类型
3. **Invariant (不变)**: 无子类型关系

**代码示例**:

```rust
// 协变：&'a T 对 'a 和 T 都是协变的
// 如果 'long: 'short，则 &'long T 是 &'short T 的子类型

fn covariant<'a, 'b>(x: &'a str) -> &'b str
where
    'a: 'b,  // 'a 比 'b 长
{
    x  // ✅ 可以将 &'a str 当作 &'b str 使用
}

// 不变：&mut T 对 T 是不变的
// &mut T' 和 &mut T 没有子类型关系

// 逆变：fn(T) 对 T 是逆变的
// 如果 T' 是 T 的子类型，则 fn(T) 是 fn(T') 的子类型
```

**常见类型的型变**:

- `&'a T`: 对 `'a` 和 `T` 都协变
- `&'a mut T`: 对 `'a` 协变，对 `T` 不变
- `fn(T) -> U`: 对 `T` 逆变，对 `U` 协变
- `Box<T>`, `Vec<T>`: 对 `T` 协变
- `Cell<T>`, `RefCell<T>`: 对 `T` 不变

**相关术语**: [Lifetime](#lifetime-生命周期-), [Subtyping](#subtyping-子类型-), [PhantomData](#phantom-data-幽灵数据-)

**参考文档**: [`tier_04_advanced/02_泛型与生命周期.md`](../tier_04_advanced/02_泛型与生命周期.md)

---

#### Subtyping (子类型) 🟡

**定义**: 类型之间的包含关系，主要体现在生命周期上。

**代码示例**:

```rust
// 生命周期的子类型关系
// 如果 'a: 'b（'a 比 'b 长），则 'a 是 'b 的子类型

fn use_subtyping<'a, 'b>(x: &'a str) -> &'b str
where
    'a: 'b,  // 'a 是 'b 的子类型
{
    x  // ✅ 可以将较长生命周期的引用当作较短生命周期使用
}

// 实际应用
fn example() {
    let long_lived = String::from("long");
    {
        let short_lived = String::from("short");
        // 'long > 'short
        let r: &str = use_subtyping(&long_lived);
        // ✅ 将 &'long str 用作 &'short str
    }
}
```

**相关术语**: [Lifetime](#lifetime-生命周期-), [Variance](#variance-型变-)

**参考文档**: [`tier_04_advanced/02_泛型与生命周期.md`](../tier_04_advanced/02_泛型与生命周期.md)

---

### F. 编译器行为

#### Monomorphization (单态化) 🟡

**定义**: 编译器为每个具体类型生成专门的代码，将泛型代码转换为具体类型的代码。

**代码示例**:

```rust
// 泛型函数
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// 使用
let x = add(1, 2);       // T = i32
let y = add(1.0, 2.0);   // T = f64

// 编译后生成（概念上）:
// fn add_i32(a: i32, b: i32) -> i32 { a + b }
// fn add_f64(a: f64, b: f64) -> f64 { a + b }
```

**特点**:

- ✅ 零运行时开销
- ✅ 静态分发，无虚函数调用
- ❌ 增加二进制大小
- ❌ 编译时间更长

**相关术语**: [Static Dispatch](#static-dispatch-静态分发-), [Zero-Cost Abstraction](#zero-cost-abstraction-零成本抽象-), [Type Erasure](#type-erasure-类型擦除-)

**参考文档**: [`tier_03_references/05_编译器行为参考.md`](../tier_03_references/05_编译器行为参考.md)

---

#### Type Erasure (类型擦除) 🟡

**定义**: 在编译或运行时删除类型信息，通常用于 trait 对象。

**代码示例**:

```rust
trait Animal {
    fn make_sound(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn make_sound(&self) { println!("Woof!"); }
}

impl Animal for Cat {
    fn make_sound(&self) { println!("Meow!"); }
}

// 类型擦除：Box<dyn Animal> 不知道具体是 Dog 还是 Cat
let animals: Vec<Box<dyn Animal>> = vec![
    Box::new(Dog),  // 类型信息被擦除
    Box::new(Cat),  // 类型信息被擦除
];

// 运行时通过 vtable 调用正确的方法
for animal in &animals {
    animal.make_sound();
}
```

**相关术语**: [Trait Object](#trait-object-trait-对象-), [Dynamic Dispatch](#dynamic-dispatch-动态分发-), [Monomorphization](#monomorphization-单态化-)

**参考文档**: [`tier_03_references/05_编译器行为参考.md`](../tier_03_references/05_编译器行为参考.md)

---

#### Static Dispatch (静态分发) 🟢

**定义**: 在编译时确定调用哪个方法实现，通过单态化实现，无运行时开销。

**代码示例**:

```rust
// 使用泛型 (静态分发)
fn process<T: Display>(value: T) {
    println!("{}", value);
}

// 编译时为每个类型生成专门代码
process(42);         // 调用 <i32 as Display>::fmt
process("hello");    // 调用 <&str as Display>::fmt
```

**相关术语**: [Monomorphization](#monomorphization-单态化-), [Dynamic Dispatch](#dynamic-dispatch-动态分发-)

**参考文档**: [`tier_04_advanced/03_零成本抽象.md`](../tier_04_advanced/03_零成本抽象.md)

---

#### Dynamic Dispatch (动态分发) 🟢

**定义**: 在运行时通过虚函数表 (vtable) 确定调用哪个方法实现。

**代码示例**:

```rust
// 使用 trait 对象 (动态分发)
fn process(value: &dyn Display) {
    println!("{}", value);
}

// 运行时通过 vtable 查找方法
let x: i32 = 42;
let y: &str = "hello";
process(&x);  // 运行时查找 <i32 as Display>::fmt
process(&y);  // 运行时查找 <&str as Display>::fmt
```

**vtable 结构**:

```rust
// 概念上的 vtable
struct DisplayVTable {
    drop: fn(*mut ()),
    size: usize,
    align: usize,
    fmt: fn(*const (), &mut Formatter) -> Result,
}

// Fat pointer (胖指针)
struct TraitObject {
    data: *const (),
    vtable: *const DisplayVTable,
}
```

**相关术语**: [Trait Object](#trait-object-trait-对象-), [Fat Pointer](#fat-pointer-胖指针-), [Static Dispatch](#static-dispatch-静态分发-)

**参考文档**: [`tier_04_advanced/03_零成本抽象.md`](../tier_04_advanced/03_零成本抽象.md)

---

#### Fat Pointer (胖指针) 🟡

**定义**: 包含额外信息的指针，如 trait 对象指针包含数据指针和 vtable 指针，切片指针包含数据指针和长度。

**代码示例**:

```rust
// trait 对象的胖指针
let x: i32 = 42;
let trait_obj: &dyn Display = &x;
// trait_obj 包含两个指针：
// 1. 指向 x 的数据指针
// 2. 指向 Display vtable 的指针

// 切片的胖指针
let arr = [1, 2, 3, 4, 5];
let slice: &[i32] = &arr[1..4];
// slice 包含：
// 1. 指向 arr[1] 的指针
// 2. 长度 3

// 大小对比
use std::mem::size_of;
assert_eq!(size_of::<&i32>(), 8);           // 普通引用：1个指针
assert_eq!(size_of::<&dyn Display>(), 16);  // trait 对象：2个指针
assert_eq!(size_of::<&[i32]>(), 16);        // 切片：指针+长度
```

**相关术语**: [Trait Object](#trait-object-trait-对象-), [Dynamic Dispatch](#dynamic-dispatch-动态分发-)

**参考文档**: [`tier_03_references/05_编译器行为参考.md`](../tier_03_references/05_编译器行为参考.md)

---

### G. 高级特性

#### Phantom Data (幽灵数据) 🟡

**定义**: 零大小的类型标记，用于在类型系统中携带类型信息而不占用运行时空间。

**代码示例**:

```rust
use std::marker::PhantomData;

// 类型状态模式
struct Locked;
struct Unlocked;

struct Door<State> {
    _state: PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        Door { _state: PhantomData }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        Door { _state: PhantomData }
    }
}

impl Door<Unlocked> {
    fn lock(self) -> Door<Locked> {
        Door { _state: PhantomData }
    }
    
    fn open(&self) {
        println!("Door opened");
    }
}

// 使用
let door = Door::<Locked>::new();
// door.open();  // ❌ 编译错误：Locked 状态不能打开
let door = door.unlock();
door.open();  // ✅ Unlocked 状态可以打开

// PhantomData 不占用空间
assert_eq!(std::mem::size_of::<Door<Locked>>(), 0);
```

**应用场景**:

- 类型状态模式
- 标记类型的 variance
- 绑定生命周期

**相关术语**: [Zero-Sized Type](#zero-sized-type-zst-零大小类型-), [Variance](#variance-型变-), [Marker Trait](#marker-trait-标记-trait-)

**参考文档**: [`tier_04_advanced/01_高级类型技巧.md`](../tier_04_advanced/01_高级类型技巧.md)

---

#### Zero-Sized Type (ZST) (零大小类型) 🟡

**定义**: 不占用内存空间的类型，编译器完全优化掉，只在类型系统中存在。

**代码示例**:

```rust
use std::mem::size_of;

// 单元类型
assert_eq!(size_of::<()>(), 0);

// 空结构体
struct Empty;
assert_eq!(size_of::<Empty>(), 0);

// PhantomData
use std::marker::PhantomData;
struct Marker<T>(PhantomData<T>);
assert_eq!(size_of::<Marker<i32>>(), 0);

// 空数组
assert_eq!(size_of::<[i32; 0]>(), 0);

// ZST 的向量不分配内存
let vec: Vec<()> = vec![(); 1000000];
// 没有分配任何堆内存！
```

**应用**:

- 状态标记
- 编译时计算
- 类型级编程

**相关术语**: [Phantom Data](#phantom-data-幽灵数据-), [Type Parameter](#type-parameter-类型参数-)

**参考文档**: [`tier_04_advanced/01_高级类型技巧.md`](../tier_04_advanced/01_高级类型技巧.md)

---

#### RPITIT (返回位置 impl Trait) 🟢

**定义**: Return Position Impl Trait In Traits，允许在 trait 方法的返回位置使用 `impl Trait`。(Rust 1.75+ 稳定)

**代码示例**:

```rust
trait Factory {
    // 返回实现 Display 的具体类型
    fn create(&self) -> impl Display;
    
    // 带生命周期
    fn create_ref(&self) -> impl Display + '_;
    
    // 多个 trait
    fn create_complex(&self) -> impl Display + Debug + Clone;
}

struct IntFactory;

impl Factory for IntFactory {
    fn create(&self) -> impl Display {
        42  // 返回 i32
    }
    
    fn create_ref(&self) -> impl Display + '_ {
        "hello"  // 返回 &str
    }
    
    fn create_complex(&self) -> impl Display + Debug + Clone {
        String::from("complex")
    }
}
```

**与 async trait 配合**:

```rust
trait AsyncService {
    // async 方法实际上是返回 impl Future
    async fn process(&self, data: &str) -> Result<String, Error>;
    
    // 等价于
    fn process(&self, data: &str) -> impl Future<Output = Result<String, Error>> + '_;
}
```

**相关术语**: [Impl Trait](#impl-trait-impl-trait-), [GAT](#gat-generic-associated-types-泛型关联类型-), [Associated Type](#associated-type-关联类型-)

**参考文档**: [`analysis/rust_features/RUST_190_COMPREHENSIVE_GUIDE.md`](../analysis/rust_features/RUST_190_COMPREHENSIVE_GUIDE.md)

---

#### Higher-Kinded Types (HKT) (高阶类型) 🔴

**定义**: 类型构造器的抽象，即"类型的类型"。Rust 不直接支持 HKT，但可以通过 GAT 和关联类型模拟部分功能。

**概念示例** (Rust 不支持此语法):

```rust
// 假设的 HKT 语法 (Rust 不支持)
trait Functor<F<_>> {
    fn map<A, B>(fa: F<A>, f: fn(A) -> B) -> F<B>;
}

// 可以为任何 F 实现，如 Option, Vec, Result 等
impl<F> Functor<F> for F {
    // ...
}
```

**Rust 中的近似实现** (使用 GAT):

```rust
trait Functor {
    type Inner<T>;
    
    fn map<A, B>(self, f: impl FnOnce(A) -> B) -> Self::Inner<B>
    where
        Self: Functor<Inner<A> = Self>;
}

// 为 Option 实现
impl Functor for Option<_> {
    type Inner<T> = Option<T>;
    
    fn map<A, B>(self, f: impl FnOnce(A) -> B) -> Option<B> {
        self.map(f)
    }
}
```

**相关术语**: [GAT](#gat-generic-associated-types-泛型关联类型-), [Type Constructor](#type-constructor-类型构造器-), [Associated Type](#associated-type-关联类型-)

**参考文档**: [`tier_04_advanced/04_类型级编程.md`](../tier_04_advanced/04_类型级编程.md)

---

### H. 性能相关

#### Zero-Cost Abstraction (零成本抽象) 🟢

**定义**: 高级抽象不会带来运行时性能损失，编译后的代码与手写的底层代码性能相同。

**代码示例**:

```rust
// 高级抽象（迭代器）
let sum: i32 = (1..=100)
    .filter(|x| x % 2 == 0)
    .map(|x| x * 2)
    .sum();

// 等价的手写循环
let mut sum = 0;
for x in 1..=100 {
    if x % 2 == 0 {
        sum += x * 2;
    }
}

// 编译后生成的汇编代码几乎相同！
```

**泛型的零成本抽象**:

```rust
// 泛型版本
fn process<T: Display>(items: &[T]) {
    for item in items {
        println!("{}", item);
    }
}

// 编译后为每个类型生成专门代码，无虚函数调用开销
```

**相关术语**: [Monomorphization](#monomorphization-单态化-), [Static Dispatch](#static-dispatch-静态分发-)

**参考文档**: [`tier_04_advanced/03_零成本抽象.md`](../tier_04_advanced/03_零成本抽象.md)

---

#### Turbofish (涡轮鱼语法) 🟢

**定义**: 使用 `::<>` 语法显式指定泛型参数的类型。

**代码示例**:

```rust
// 当类型无法推断时使用 turbofish
let numbers: Vec<_> = "42"
    .parse::<i32>()  // ← turbofish 语法
    .into_iter()
    .collect();

// 等价于
let numbers: Vec<i32> = "42"
    .parse()  // 从变量类型推断
    .into_iter()
    .collect();

// 在方法链中使用
let result = vec![1, 2, 3]
    .into_iter()
    .collect::<Vec<_>>();  // ← turbofish

// 泛型函数调用
fn identity<T>(x: T) -> T { x }
let x = identity::<i32>(42);  // ← turbofish
```

**命名来源**: 语法 `::<>` 看起来像一条鱼 🐟

**相关术语**: [Type Parameter](#type-parameter-类型参数-), [Generic](#generic-泛型-)

**参考文档**: [`tier_02_guides/04_类型推断指南.md`](../tier_02_guides/04_类型推断指南.md)

---

### I. 类型理论

#### Polymorphism (多态性) 🔵

**定义**: 同一接口可以有多种实现，包括参数多态、ad-hoc多态和子类型多态。

**三种多态**:

1. **参数多态 (Parametric Polymorphism)**: 泛型

    ```rust
    fn identity<T>(x: T) -> T { x }
    // 对所有类型 T 都适用
    ```

2. **Ad-hoc 多态**: trait 和重载

    ```rust
    trait Add<Rhs = Self> {
        type Output;
        fn add(self, rhs: Rhs) -> Self::Output;
    }
    // 不同类型有不同的实现
    ```

3. **子类型多态**: trait 对象

    ```rust
    let animal: &dyn Animal = &Dog;
    // 运行时多态
    ```

**相关术语**: [Generic](#generic-泛型-), [Trait Object](#trait-object-trait-对象-), [Static Dispatch](#static-dispatch-静态分发-), [Dynamic Dispatch](#dynamic-dispatch-动态分发-)

**参考文档**: [`tier_02_guides/02_Trait系统指南.md`](../tier_02_guides/02_Trait系统指南.md)

---

#### Type Constructor (类型构造器) 🟡

**定义**: 接受类型参数并产生新类型的机制。

**代码示例**:

```rust
// Vec 是类型构造器
// Vec<i32>, Vec<String> 是具体类型

// Option 是类型构造器
// Option<i32>, Option<String> 是具体类型

// Result 接受两个类型参数
// Result<T, E> 是类型构造器
// Result<i32, String> 是具体类型

// 自定义类型构造器
struct Container<T> {
    value: T,
}
// Container 是类型构造器
// Container<i32> 是具体类型
```

**相关术语**: [Generic](#generic-泛型-), [Type Parameter](#type-parameter-类型参数-), [Higher-Kinded Types](#higher-kinded-types-hkt-高阶类型-)

**参考文档**: [`tier_04_advanced/04_类型级编程.md`](../tier_04_advanced/04_类型级编程.md)

---

#### Coherence (一致性) 🟡

**定义**: Rust 的 trait 实现一致性规则，防止 trait 实现冲突。

**核心规则** (孤儿规则):

- trait 或类型至少有一个在当前 crate 中定义

**代码示例**:

```rust
// ✅ 可以：trait 和类型都在当前 crate
trait MyTrait {}
struct MyType;
impl MyTrait for MyType {}

// ✅ 可以：trait 在当前 crate
impl MyTrait for i32 {}

// ✅ 可以：类型在当前 crate
impl Display for MyType {
    fn fmt(&self, f: &mut Formatter) -> Result {
        // ...
    }
}

// ❌ 不可以：trait 和类型都在其他 crate
// impl Display for i32 {}  // 编译错误
```

**解决方法：newtype 模式**:

```rust
// 包装外部类型
struct MyInt(i32);

// 现在可以为 MyInt 实现外部 trait
impl Display for MyInt {
    fn fmt(&self, f: &mut Formatter) -> Result {
        write!(f, "{}", self.0)
    }
}
```

**相关术语**: [Trait](#trait-trait-), [Orphan Rule](#orphan-rule-孤儿规则-)

**参考文档**: [`tier_03_references/02_Trait系统参考.md`](../tier_03_references/02_Trait系统参考.md)

---

#### Orphan Rule (孤儿规则) 🟡

**定义**: coherence 规则的具体体现，要求 trait 或类型至少有一个在当前 crate 中定义。

**目的**: 防止上游 crate 的变更破坏下游 crate。

**示例**:

```rust
// 假设两个 crate 都为外部 trait 和外部类型实现
// crate A:
impl Display for Vec<i32> { /* ... */ }

// crate B:
impl Display for Vec<i32> { /* ... */ }

// 如果允许，当同时依赖 A 和 B 时，编译器无法确定使用哪个实现
// 孤儿规则防止了这种情况
```

**相关术语**: [Coherence](#coherence-一致性-), [Trait](#trait-trait-)

**参考文档**: [`tier_04_advanced/05_设计模式进阶.md`](../tier_04_advanced/05_设计模式进阶.md)

---

## 🔤 中英对照表

### A-G

| English | 中文 | 级别 |
|---------|------|------|
| Abstract Data Type (ADT) | 抽象数据类型 | 🔵 |
| Associated Const | 关联常量 | 🟢 |
| Associated Type | 关联类型 | 🟢 |
| Blanket Implementation | 全面实现 | 🟡 |
| Bound | 约束 | 🔵 |
| Boxed Trait Object | 装箱 trait 对象 | 🟢 |
| Coherence | 一致性 | 🟡 |
| Const Generic | 常量泛型 | 🟢 |
| Covariant | 协变 | 🔴 |
| Default Type Parameter | 默认类型参数 | 🟢 |
| Dispatch | 分发 | 🔵 |
| Dynamic Dispatch | 动态分发 | 🟢 |
| Fat Pointer | 胖指针 | 🟡 |
| GAT (Generic Associated Types) | 泛型关联类型 | 🟡 |
| Generic | 泛型 | 🔵 |
| Generic Function | 泛型函数 | 🔵 |

### H-Z

| English | 中文 | 级别 |
|---------|------|------|
| Higher-Kinded Types (HKT) | 高阶类型 | 🔴 |
| Higher-Rank Trait Bounds (HRTB) | 高阶 trait 边界 | 🟡 |
| Impl Trait | impl Trait | 🟢 |
| Inference | 类型推断 | 🔵 |
| Invariant | 不变 | 🔴 |
| Lifetime | 生命周期 | 🔵 |
| Marker Trait | 标记 trait | 🟢 |
| Monomorphization | 单态化 | 🟡 |
| Orphan Rule | 孤儿规则 | 🟡 |
| Phantom Data | 幽灵数据 | 🟡 |
| Polymorphism | 多态性 | 🔵 |
| RPITIT | 返回位置 impl Trait | 🟢 |
| Static Dispatch | 静态分发 | 🟢 |
| Subtyping | 子类型 | 🟡 |
| Supertraits | 超 trait | 🟢 |
| Trait | trait | 🔵 |
| Trait Bound | trait 约束 | 🔵 |
| Trait Object | trait 对象 | 🟢 |
| Turbofish | 涡轮鱼语法 | 🟢 |
| Type Alias | 类型别名 | 🔵 |
| Type Constructor | 类型构造器 | 🟡 |
| Type Erasure | 类型擦除 | 🟡 |
| Type Parameter | 类型参数 | 🔵 |
| Variance | 型变 | 🔴 |
| Where Clause | where 子句 | 🔵 |
| Zero-Cost Abstraction | 零成本抽象 | 🟢 |
| Zero-Sized Type (ZST) | 零大小类型 | 🟡 |

---

## 📚 相关文档

### 按术语级别

- 🔵 **基础术语**: 查看 [`tier_02_guides/01_泛型基础指南.md`](../tier_02_guides/01_泛型基础指南.md)
- 🟢 **中级术语**: 查看 [`tier_02_guides/`](../tier_02_guides/) 所有指南
- 🟡 **高级术语**: 查看 [`tier_03_references/`](../tier_03_references/) 完整参考
- 🔴 **专家术语**: 查看 [`tier_04_advanced/`](../tier_04_advanced/) 高级主题

### 深入理解

- 📚 **类型理论**: [`analysis/theory_deep_dive/README.md`](../analysis/theory_deep_dive/README.md)
- 📚 **知识图谱**: [`analysis/knowledge_enhanced/README.md`](../analysis/knowledge_enhanced/README.md)
- 📚 **对比矩阵**: [`analysis/knowledge_enhanced/`](../analysis/knowledge_enhanced/) (包含各种对比矩阵)

---

**术语表状态**: ✅ 100+ 术语完整收录  
**最后更新**: 2025-10-22  
**维护**: 持续更新中

---

*本术语表提供 C04 泛型编程所有核心术语的准确定义和代码示例。建议配合 [`02_主索引导航.md`](./02_主索引导航.md) 和 [`04_常见问题.md`](./04_常见问题.md) 一起使用。*
