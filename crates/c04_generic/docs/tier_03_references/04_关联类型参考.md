# C04 æ³›å‹ç¼–ç¨‹ - å…³è”ç±»å‹å®Œæ•´å‚è€ƒ

**æ–‡æ¡£ç±»å‹**: Tier 3 å®Œæ•´å‚è€ƒ  
**æœ€åæ›´æ–°**: 2025-10-22  
**Rust ç‰ˆæœ¬**: 1.90+  
**å‚è€ƒç±»å‹**: ğŸ” å…³è”ç±»å‹é€ŸæŸ¥

---

## ğŸ“‹ ç›®å½•

- [C04 æ³›å‹ç¼–ç¨‹ - å…³è”ç±»å‹å®Œæ•´å‚è€ƒ](#c04-æ³›å‹ç¼–ç¨‹---å…³è”ç±»å‹å®Œæ•´å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å…³è”ç±»å‹å®šä¹‰è¯­æ³•](#1-å…³è”ç±»å‹å®šä¹‰è¯­æ³•)
    - [1.1 å®Œæ•´ BNF è¯­æ³•](#11-å®Œæ•´-bnf-è¯­æ³•)
    - [1.2 åŸºç¡€å®šä¹‰](#12-åŸºç¡€å®šä¹‰)
    - [1.3 å®ç°å…³è”ç±»å‹](#13-å®ç°å…³è”ç±»å‹)
  - [2. æ³›å‹å…³è”ç±»å‹ (GAT)](#2-æ³›å‹å…³è”ç±»å‹-gat)
    - [2.1 GAT è¯­æ³• (Rust 1.65+)](#21-gat-è¯­æ³•-rust-165)
    - [2.2 GAT çº¦æŸ](#22-gat-çº¦æŸ)
    - [2.3 GAT ä½¿ç”¨åœºæ™¯](#23-gat-ä½¿ç”¨åœºæ™¯)
  - [3. å…³è”å¸¸é‡](#3-å…³è”å¸¸é‡)
    - [3.1 è¯­æ³•å®šä¹‰](#31-è¯­æ³•å®šä¹‰)
    - [3.2 åŸºç¡€ä½¿ç”¨](#32-åŸºç¡€ä½¿ç”¨)
    - [3.3 å…³è”å¸¸é‡çš„é«˜çº§ç”¨æ³•](#33-å…³è”å¸¸é‡çš„é«˜çº§ç”¨æ³•)
  - [4. RPITIT](#4-rpitit)
    - [4.1 å®šä¹‰ (Rust 1.75+)](#41-å®šä¹‰-rust-175)
    - [4.2 è¯­æ³•](#42-è¯­æ³•)
    - [4.3 RPITIT ä¸å…³è”ç±»å‹çš„åŒºåˆ«](#43-rpitit-ä¸å…³è”ç±»å‹çš„åŒºåˆ«)
    - [4.4 RPITIT çš„é«˜çº§ç”¨æ³•](#44-rpitit-çš„é«˜çº§ç”¨æ³•)
  - [5. å…³è”ç±»å‹çº¦æŸ](#5-å…³è”ç±»å‹çº¦æŸ)
    - [5.1 çº¦æŸè¯­æ³•](#51-çº¦æŸè¯­æ³•)
    - [5.2 åµŒå¥—å…³è”ç±»å‹çº¦æŸ](#52-åµŒå¥—å…³è”ç±»å‹çº¦æŸ)
    - [5.3 å…³è”ç±»å‹çš„ç­‰ä»·çº¦æŸ](#53-å…³è”ç±»å‹çš„ç­‰ä»·çº¦æŸ)
  - [6. å®Œæ•´ä½¿ç”¨æ¨¡å¼](#6-å®Œæ•´ä½¿ç”¨æ¨¡å¼)
    - [6.1 æ•°æ®åº“æŠ½è±¡å±‚](#61-æ•°æ®åº“æŠ½è±¡å±‚)
    - [6.2 Parser Combinator](#62-parser-combinator)
    - [6.3 å¼‚æ­¥è¿­ä»£å™¨](#63-å¼‚æ­¥è¿­ä»£å™¨)
  - [7. é€ŸæŸ¥è¡¨](#7-é€ŸæŸ¥è¡¨)
    - [7.1 å…³è”ç±»å‹ vs æ³›å‹å‚æ•°](#71-å…³è”ç±»å‹-vs-æ³›å‹å‚æ•°)
    - [7.2 å…³è”ç±»å‹é€ŸæŸ¥](#72-å…³è”ç±»å‹é€ŸæŸ¥)
    - [7.3 GAT ç‰¹æ€§è¡¨ (Rust 1.65+)](#73-gat-ç‰¹æ€§è¡¨-rust-165)
  - [ğŸ“š ç›¸å…³å‚è€ƒ](#-ç›¸å…³å‚è€ƒ)

---

## 1. å…³è”ç±»å‹å®šä¹‰è¯­æ³•

### 1.1 å®Œæ•´ BNF è¯­æ³•

```bnf
AssociatedType ::= 'type' Ident GenericParams? (':' TypeParamBounds?)? WhereClause? ('=' Type)?

AssociatedTypeImpl ::= 'type' Ident GenericArgs? '=' Type
```

### 1.2 åŸºç¡€å®šä¹‰

```rust
// åŸºç¡€å…³è”ç±»å‹
trait Container {
    type Item;
    fn get(&self) -> Option<&Self::Item>;
}

// å¸¦çº¦æŸçš„å…³è”ç±»å‹
trait Processor {
    type Output: Display;
    fn process(&self) -> Self::Output;
}

// å¸¦é»˜è®¤ç±»å‹
trait Config {
    type Storage = Vec<String>;
    fn get_storage(&self) -> Self::Storage;
}
```

### 1.3 å®ç°å…³è”ç±»å‹

```rust
struct IntContainer {
    items: Vec<i32>,
}

impl Container for IntContainer {
    type Item = i32;
    
    fn get(&self) -> Option<&i32> {
        self.items.first()
    }
}

// ä½¿ç”¨é»˜è®¤ç±»å‹
struct DefaultConfig;

impl Config for DefaultConfig {
    // ä½¿ç”¨é»˜è®¤çš„ Vec<String>
    fn get_storage(&self) -> Vec<String> {
        Vec::new()
    }
}

// è¦†ç›–é»˜è®¤ç±»å‹
struct CustomConfig;

impl Config for CustomConfig {
    type Storage = std::collections::HashSet<String>;
    
    fn get_storage(&self) -> Self::Storage {
        std::collections::HashSet::new()
    }
}
```

---

## 2. æ³›å‹å…³è”ç±»å‹ (GAT)

### 2.1 GAT è¯­æ³• (Rust 1.65+)

```rust
// GAT å®šä¹‰
trait Container {
    type Item<'a> where Self: 'a;
    fn get<'a>(&'a self) -> Option<Self::Item<'a>>;
}

// GAT å®ç°
struct VecContainer<T> {
    items: Vec<T>,
}

impl<T> Container for VecContainer<T> {
    type Item<'a> = &'a T where T: 'a;
    
    fn get<'a>(&'a self) -> Option<&'a T> {
        self.items.first()
    }
}
```

### 2.2 GAT çº¦æŸ

```rust
// å¸¦å¤šä¸ªçº¦æŸçš„ GAT
trait Processor {
    type Output<'a, T>
    where
        Self: 'a,
        T: 'a + Display;
    
    fn process<'a, T>(&'a self, input: T) -> Self::Output<'a, T>
    where
        T: Display;
}

// GAT ä¸å¸¸é‡æ³›å‹
trait Array {
    type Item<const N: usize>;
    fn create<const N: usize>() -> Self::Item<N>;
}
```

### 2.3 GAT ä½¿ç”¨åœºæ™¯

**åœºæ™¯ 1: Streaming Iterator**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct WindowsIterator<T> {
    data: Vec<T>,
    size: usize,
    pos: usize,
}

impl<T> LendingIterator for WindowsIterator<T> {
    type Item<'a> = &'a [T] where T: 'a;
    
    fn next<'a>(&'a mut self) -> Option<&'a [T]> {
        if self.pos + self.size <= self.data.len() {
            let slice = &self.data[self.pos..self.pos + self.size];
            self.pos += 1;
            Some(slice)
        } else {
            None
        }
    }
}
```

**åœºæ™¯ 2: Async Trait**:

```rust
trait AsyncProcessor {
    type Future<'a>: Future<Output = String> where Self: 'a;
    fn process<'a>(&'a self, input: &'a str) -> Self::Future<'a>;
}
```

**åœºæ™¯ 3: é«˜é˜¶æŠ½è±¡**:

```rust
trait Functor {
    type Mapped<U>;
    fn map<U, F>(self, f: F) -> Self::Mapped<U>
    where
        F: FnOnce(Self) -> U;
}
```

---

## 3. å…³è”å¸¸é‡

### 3.1 è¯­æ³•å®šä¹‰

```bnf
AssociatedConst ::= 'const' Ident ':' Type ('=' Expression)?

AssociatedConstImpl ::= 'const' Ident ':' Type '=' Expression
```

### 3.2 åŸºç¡€ä½¿ç”¨

```rust
// å®šä¹‰å…³è”å¸¸é‡
trait Numeric {
    const MAX: Self;
    const MIN: Self;
    const ZERO: Self;
}

// å®ç°å…³è”å¸¸é‡
impl Numeric for i32 {
    const MAX: i32 = i32::MAX;
    const MIN: i32 = i32::MIN;
    const ZERO: i32 = 0;
}

impl Numeric for f64 {
    const MAX: f64 = f64::MAX;
    const MIN: f64 = f64::MIN;
    const ZERO: f64 = 0.0;
}

// ä½¿ç”¨å…³è”å¸¸é‡
fn check_range<T: Numeric + PartialOrd>(value: T) -> bool {
    value >= T::MIN && value <= T::MAX
}
```

### 3.3 å…³è”å¸¸é‡çš„é«˜çº§ç”¨æ³•

```rust
// å¸¦æ³›å‹çš„å…³è”å¸¸é‡
trait Container {
    const CAPACITY: usize;
    type Item;
}

struct FixedArray<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> Container for FixedArray<T, N> {
    const CAPACITY: usize = N;
    type Item = T;
}

// ä½¿ç”¨åœºæ™¯
fn print_capacity<C: Container>() {
    println!("Capacity: {}", C::CAPACITY);
}
```

---

## 4. RPITIT

### 4.1 å®šä¹‰ (Rust 1.75+)

**RPITIT** = Return Position Impl Trait In Traits

å…è®¸åœ¨ trait æ–¹æ³•çš„è¿”å›ä½ç½®ä½¿ç”¨ `impl Trait`ã€‚

### 4.2 è¯­æ³•

```rust
// RPITIT å®šä¹‰
trait Factory {
    fn create(&self) -> impl Display;
}

// å®ç°
struct IntFactory;

impl Factory for IntFactory {
    fn create(&self) -> impl Display {
        42
    }
}

struct StringFactory;

impl Factory for StringFactory {
    fn create(&self) -> impl Display {
        "hello"
    }
}
```

### 4.3 RPITIT ä¸å…³è”ç±»å‹çš„åŒºåˆ«

```rust
// ä½¿ç”¨å…³è”ç±»å‹
trait Factory1 {
    type Output: Display;
    fn create(&self) -> Self::Output;
}

// ä½¿ç”¨ RPITIT
trait Factory2 {
    fn create(&self) -> impl Display;
}

// å…³è”ç±»å‹ï¼šè°ƒç”¨è€…çŸ¥é“å…·ä½“ç±»å‹
fn use_factory1<F: Factory1>(f: &F) -> F::Output {
    f.create()
}

// RPITITï¼šè°ƒç”¨è€…åªçŸ¥é“çº¦æŸ
fn use_factory2<F: Factory2>(f: &F) {
    let result = f.create();  // ç±»å‹ä¸é€æ˜
    println!("{}", result);
}
```

### 4.4 RPITIT çš„é«˜çº§ç”¨æ³•

```rust
// è¿”å›è¿­ä»£å™¨
trait DataSource {
    fn iter(&self) -> impl Iterator<Item = i32>;
}

struct RangeSource {
    start: i32,
    end: i32,
}

impl DataSource for RangeSource {
    fn iter(&self) -> impl Iterator<Item = i32> {
        self.start..self.end
    }
}

// è¿”å› Future
trait AsyncComputer {
    fn compute(&self, x: i32) -> impl Future<Output = i32>;
}
```

---

## 5. å…³è”ç±»å‹çº¦æŸ

### 5.1 çº¦æŸè¯­æ³•

```rust
// åœ¨ where å­å¥ä¸­çº¦æŸå…³è”ç±»å‹
fn process<T>(value: T)
where
    T: Iterator,
    T::Item: Display,
{
    for item in value {
        println!("{}", item);
    }
}

// å¤šä¸ªå…³è”ç±»å‹çº¦æŸ
fn convert<T>(value: T)
where
    T: IntoIterator,
    T::Item: Into<String>,
    T::IntoIter: ExactSizeIterator,
{
    println!("Length: {}", value.into_iter().len());
}
```

### 5.2 åµŒå¥—å…³è”ç±»å‹çº¦æŸ

```rust
fn nested<T>(value: T)
where
    T: Iterator,
    T::Item: IntoIterator,
    <T::Item as IntoIterator>::Item: Display,
{
    for item in value {
        for inner in item {
            println!("{}", inner);
        }
    }
}
```

### 5.3 å…³è”ç±»å‹çš„ç­‰ä»·çº¦æŸ

```rust
// çº¦æŸå…³è”ç±»å‹ç­‰äºç‰¹å®šç±»å‹
fn specific<T>(iter: T)
where
    T: Iterator<Item = i32>,
{
    for num in iter {
        println!("{}", num);
    }
}

// ç­‰ä»·äº
fn specific2<T>(iter: T)
where
    T: Iterator,
    T::Item == i32,  // æ³¨æ„ï¼šè¿™ä¸æ˜¯æœ‰æ•ˆè¯­æ³•
{
    // å®é™…ä½¿ç”¨ä¸Šé¢çš„è¯­æ³•
}
```

---

## 6. å®Œæ•´ä½¿ç”¨æ¨¡å¼

### 6.1 æ•°æ®åº“æŠ½è±¡å±‚

```rust
trait Database {
    type Connection;
    type Query;
    type Result<'a> where Self: 'a;
    type Error: std::error::Error;
    
    fn connect(&self) -> Result<Self::Connection, Self::Error>;
    fn execute<'a>(
        conn: &'a Self::Connection,
        query: Self::Query,
    ) -> Result<Self::Result<'a>, Self::Error>;
}

struct PostgreSQL;

impl Database for PostgreSQL {
    type Connection = PgConnection;
    type Query = String;
    type Result<'a> = &'a [Row];
    type Error = PgError;
    
    fn connect(&self) -> Result<PgConnection, PgError> {
        // ...
    }
    
    fn execute<'a>(
        conn: &'a PgConnection,
        query: String,
    ) -> Result<&'a [Row], PgError> {
        // ...
    }
}
```

### 6.2 Parser Combinator

```rust
trait Parser {
    type Input;
    type Output;
    type Error;
    
    fn parse(
        &self,
        input: Self::Input,
    ) -> Result<(Self::Output, Self::Input), Self::Error>;
}

trait ParserExt: Parser + Sized {
    fn map<F, U>(self, f: F) -> Map<Self, F>
    where
        F: Fn(Self::Output) -> U,
    {
        Map { parser: self, f }
    }
    
    fn and_then<F, P>(self, f: F) -> AndThen<Self, F>
    where
        F: Fn(Self::Output) -> P,
        P: Parser<Input = Self::Input, Error = Self::Error>,
    {
        AndThen { parser: self, f }
    }
}
```

### 6.3 å¼‚æ­¥è¿­ä»£å™¨

```rust
trait AsyncIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> impl Future<Output = Option<Self::Item<'a>>> + 'a;
}

struct AsyncRange {
    current: u32,
    end: u32,
}

impl AsyncIterator for AsyncRange {
    type Item<'a> = u32;
    
    async fn next<'a>(&'a mut self) -> Option<u32> {
        if self.current < self.end {
            self.current += 1;
            Some(self.current - 1)
        } else {
            None
        }
    }
}
```

---

## 7. é€ŸæŸ¥è¡¨

### 7.1 å…³è”ç±»å‹ vs æ³›å‹å‚æ•°

| ç‰¹æ€§ | å…³è”ç±»å‹ | æ³›å‹å‚æ•° |
|------|----------|----------|
| å®ç°æ¬¡æ•° | æ¯ä¸ªç±»å‹ä¸€æ¬¡ | æ¯ä¸ªç±»å‹å¤šæ¬¡ |
| ç±»å‹æŒ‡å®š | å®ç°æ—¶ | ä½¿ç”¨æ—¶ |
| çµæ´»æ€§ | è¾ƒä½ | è¾ƒé«˜ |
| ä½¿ç”¨åœºæ™¯ | ä¸€å¯¹ä¸€å…³ç³» | ä¸€å¯¹å¤šå…³ç³» |

### 7.2 å…³è”ç±»å‹é€ŸæŸ¥

| è¯­æ³• | è¯´æ˜ |
|------|------|
| `type Item` | åŸºç¡€å…³è”ç±»å‹ |
| `type Item: Trait` | å¸¦çº¦æŸçš„å…³è”ç±»å‹ |
| `type Item = Type` | å¸¦é»˜è®¤å€¼çš„å…³è”ç±»å‹ |
| `type Item<'a>` | GAT |
| `const NAME: Type` | å…³è”å¸¸é‡ |
| `-> impl Trait` | RPITIT |

### 7.3 GAT ç‰¹æ€§è¡¨ (Rust 1.65+)

| ç‰¹æ€§ | æ”¯æŒ |
|------|------|
| ç”Ÿå‘½å‘¨æœŸå‚æ•° | âœ… |
| ç±»å‹å‚æ•° | âœ… |
| const å‚æ•° | âœ… |
| çº¦æŸ | âœ… |
| é»˜è®¤å€¼ | âœ… |

---

## ğŸ“š ç›¸å…³å‚è€ƒ

- [01_æ³›å‹è¯­æ³•å‚è€ƒ.md](./01_æ³›å‹è¯­æ³•å‚è€ƒ.md) - æ³›å‹è¯­æ³•
- [02_Traitç³»ç»Ÿå‚è€ƒ.md](./02_Traitç³»ç»Ÿå‚è€ƒ.md) - Trait ç³»ç»Ÿ
- [03_è¾¹ç•Œçº¦æŸå‚è€ƒ.md](./03_è¾¹ç•Œçº¦æŸå‚è€ƒ.md) - çº¦æŸè¯­æ³•
- [../tier_02_guides/03_å…³è”ç±»å‹æŒ‡å—.md](../tier_02_guides/03_å…³è”ç±»å‹æŒ‡å—.md) - å…³è”ç±»å‹å®è·µ

---

**æ–‡æ¡£å…ƒä¿¡æ¯**:

- åˆ›å»ºæ—¥æœŸ: 2025-10-22
- ä½œè€…: Rust-Lang Project
- è®¸å¯: MIT OR Apache-2.0
- Rust ç‰ˆæœ¬: 1.90+
