# C04 泛型编程 - 关联类型完整参考

## 📊 目录

- [C04 泛型编程 - 关联类型完整参考](#c04-泛型编程---关联类型完整参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 关联类型定义语法](#1-关联类型定义语法)
    - [1.1 完整 BNF 语法](#11-完整-bnf-语法)
    - [1.2 基础定义](#12-基础定义)
    - [1.3 实现关联类型](#13-实现关联类型)
  - [2. 泛型关联类型 (GAT)](#2-泛型关联类型-gat)
    - [2.1 GAT 语法 (Rust 1.65+)](#21-gat-语法-rust-165)
    - [2.2 GAT 约束](#22-gat-约束)
    - [2.3 GAT 使用场景](#23-gat-使用场景)
  - [3. 关联常量](#3-关联常量)
    - [3.1 语法定义](#31-语法定义)
    - [3.2 基础使用](#32-基础使用)
    - [3.3 关联常量的高级用法](#33-关联常量的高级用法)
  - [4. RPITIT](#4-rpitit)
    - [4.1 定义 (Rust 1.75+)](#41-定义-rust-175)
    - [4.2 语法](#42-语法)
    - [4.3 RPITIT 与关联类型的区别](#43-rpitit-与关联类型的区别)
    - [4.4 RPITIT 的高级用法](#44-rpitit-的高级用法)
  - [5. 关联类型约束](#5-关联类型约束)
    - [5.1 约束语法](#51-约束语法)
    - [5.2 嵌套关联类型约束](#52-嵌套关联类型约束)
    - [5.3 关联类型的等价约束](#53-关联类型的等价约束)
  - [6. 完整使用模式](#6-完整使用模式)
    - [6.1 数据库抽象层](#61-数据库抽象层)
    - [6.2 Parser Combinator](#62-parser-combinator)
    - [6.3 异步迭代器](#63-异步迭代器)
  - [7. 速查表](#7-速查表)
    - [7.1 关联类型 vs 泛型参数](#71-关联类型-vs-泛型参数)
    - [7.2 关联类型速查](#72-关联类型速查)
    - [7.3 GAT 特性表 (Rust 1.65+)](#73-gat-特性表-rust-165)
  - [📚 相关参考](#-相关参考)

**文档类型**: Tier 3 完整参考  
**最后更新**: 2025-10-22  
**Rust 版本**: 1.90+  
**参考类型**: 🔍 关联类型速查

---

## 📋 目录

- [C04 泛型编程 - 关联类型完整参考](#c04-泛型编程---关联类型完整参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 关联类型定义语法](#1-关联类型定义语法)
    - [1.1 完整 BNF 语法](#11-完整-bnf-语法)
    - [1.2 基础定义](#12-基础定义)
    - [1.3 实现关联类型](#13-实现关联类型)
  - [2. 泛型关联类型 (GAT)](#2-泛型关联类型-gat)
    - [2.1 GAT 语法 (Rust 1.65+)](#21-gat-语法-rust-165)
    - [2.2 GAT 约束](#22-gat-约束)
    - [2.3 GAT 使用场景](#23-gat-使用场景)
  - [3. 关联常量](#3-关联常量)
    - [3.1 语法定义](#31-语法定义)
    - [3.2 基础使用](#32-基础使用)
    - [3.3 关联常量的高级用法](#33-关联常量的高级用法)
  - [4. RPITIT](#4-rpitit)
    - [4.1 定义 (Rust 1.75+)](#41-定义-rust-175)
    - [4.2 语法](#42-语法)
    - [4.3 RPITIT 与关联类型的区别](#43-rpitit-与关联类型的区别)
    - [4.4 RPITIT 的高级用法](#44-rpitit-的高级用法)
  - [5. 关联类型约束](#5-关联类型约束)
    - [5.1 约束语法](#51-约束语法)
    - [5.2 嵌套关联类型约束](#52-嵌套关联类型约束)
    - [5.3 关联类型的等价约束](#53-关联类型的等价约束)
  - [6. 完整使用模式](#6-完整使用模式)
    - [6.1 数据库抽象层](#61-数据库抽象层)
    - [6.2 Parser Combinator](#62-parser-combinator)
    - [6.3 异步迭代器](#63-异步迭代器)
  - [7. 速查表](#7-速查表)
    - [7.1 关联类型 vs 泛型参数](#71-关联类型-vs-泛型参数)
    - [7.2 关联类型速查](#72-关联类型速查)
    - [7.3 GAT 特性表 (Rust 1.65+)](#73-gat-特性表-rust-165)
  - [📚 相关参考](#-相关参考)

---

## 1. 关联类型定义语法

### 1.1 完整 BNF 语法

```bnf
AssociatedType ::= 'type' Ident GenericParams? (':' TypeParamBounds?)? WhereClause? ('=' Type)?

AssociatedTypeImpl ::= 'type' Ident GenericArgs? '=' Type
```

### 1.2 基础定义

```rust
// 基础关联类型
trait Container {
    type Item;
    fn get(&self) -> Option<&Self::Item>;
}

// 带约束的关联类型
trait Processor {
    type Output: Display;
    fn process(&self) -> Self::Output;
}

// 带默认类型
trait Config {
    type Storage = Vec<String>;
    fn get_storage(&self) -> Self::Storage;
}
```

### 1.3 实现关联类型

```rust
struct IntContainer {
    items: Vec<i32>,
}

impl Container for IntContainer {
    type Item = i32;
    
    fn get(&self) -> Option<&i32> {
        self.items.first()
    }
}

// 使用默认类型
struct DefaultConfig;

impl Config for DefaultConfig {
    // 使用默认的 Vec<String>
    fn get_storage(&self) -> Vec<String> {
        Vec::new()
    }
}

// 覆盖默认类型
struct CustomConfig;

impl Config for CustomConfig {
    type Storage = std::collections::HashSet<String>;
    
    fn get_storage(&self) -> Self::Storage {
        std::collections::HashSet::new()
    }
}
```

---

## 2. 泛型关联类型 (GAT)

### 2.1 GAT 语法 (Rust 1.65+)

```rust
// GAT 定义
trait Container {
    type Item<'a> where Self: 'a;
    fn get<'a>(&'a self) -> Option<Self::Item<'a>>;
}

// GAT 实现
struct VecContainer<T> {
    items: Vec<T>,
}

impl<T> Container for VecContainer<T> {
    type Item<'a> = &'a T where T: 'a;
    
    fn get<'a>(&'a self) -> Option<&'a T> {
        self.items.first()
    }
}
```

### 2.2 GAT 约束

```rust
// 带多个约束的 GAT
trait Processor {
    type Output<'a, T>
    where
        Self: 'a,
        T: 'a + Display;
    
    fn process<'a, T>(&'a self, input: T) -> Self::Output<'a, T>
    where
        T: Display;
}

// GAT 与常量泛型
trait Array {
    type Item<const N: usize>;
    fn create<const N: usize>() -> Self::Item<N>;
}
```

### 2.3 GAT 使用场景

**场景 1: Streaming Iterator**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct WindowsIterator<T> {
    data: Vec<T>,
    size: usize,
    pos: usize,
}

impl<T> LendingIterator for WindowsIterator<T> {
    type Item<'a> = &'a [T] where T: 'a;
    
    fn next<'a>(&'a mut self) -> Option<&'a [T]> {
        if self.pos + self.size <= self.data.len() {
            let slice = &self.data[self.pos..self.pos + self.size];
            self.pos += 1;
            Some(slice)
        } else {
            None
        }
    }
}
```

**场景 2: Async Trait**:

```rust
trait AsyncProcessor {
    type Future<'a>: Future<Output = String> where Self: 'a;
    fn process<'a>(&'a self, input: &'a str) -> Self::Future<'a>;
}
```

**场景 3: 高阶抽象**:

```rust
trait Functor {
    type Mapped<U>;
    fn map<U, F>(self, f: F) -> Self::Mapped<U>
    where
        F: FnOnce(Self) -> U;
}
```

---

## 3. 关联常量

### 3.1 语法定义

```bnf
AssociatedConst ::= 'const' Ident ':' Type ('=' Expression)?

AssociatedConstImpl ::= 'const' Ident ':' Type '=' Expression
```

### 3.2 基础使用

```rust
// 定义关联常量
trait Numeric {
    const MAX: Self;
    const MIN: Self;
    const ZERO: Self;
}

// 实现关联常量
impl Numeric for i32 {
    const MAX: i32 = i32::MAX;
    const MIN: i32 = i32::MIN;
    const ZERO: i32 = 0;
}

impl Numeric for f64 {
    const MAX: f64 = f64::MAX;
    const MIN: f64 = f64::MIN;
    const ZERO: f64 = 0.0;
}

// 使用关联常量
fn check_range<T: Numeric + PartialOrd>(value: T) -> bool {
    value >= T::MIN && value <= T::MAX
}
```

### 3.3 关联常量的高级用法

```rust
// 带泛型的关联常量
trait Container {
    const CAPACITY: usize;
    type Item;
}

struct FixedArray<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> Container for FixedArray<T, N> {
    const CAPACITY: usize = N;
    type Item = T;
}

// 使用场景
fn print_capacity<C: Container>() {
    println!("Capacity: {}", C::CAPACITY);
}
```

---

## 4. RPITIT

### 4.1 定义 (Rust 1.75+)

**RPITIT** = Return Position Impl Trait In Traits

允许在 trait 方法的返回位置使用 `impl Trait`。

### 4.2 语法

```rust
// RPITIT 定义
trait Factory {
    fn create(&self) -> impl Display;
}

// 实现
struct IntFactory;

impl Factory for IntFactory {
    fn create(&self) -> impl Display {
        42
    }
}

struct StringFactory;

impl Factory for StringFactory {
    fn create(&self) -> impl Display {
        "hello"
    }
}
```

### 4.3 RPITIT 与关联类型的区别

```rust
// 使用关联类型
trait Factory1 {
    type Output: Display;
    fn create(&self) -> Self::Output;
}

// 使用 RPITIT
trait Factory2 {
    fn create(&self) -> impl Display;
}

// 关联类型：调用者知道具体类型
fn use_factory1<F: Factory1>(f: &F) -> F::Output {
    f.create()
}

// RPITIT：调用者只知道约束
fn use_factory2<F: Factory2>(f: &F) {
    let result = f.create();  // 类型不透明
    println!("{}", result);
}
```

### 4.4 RPITIT 的高级用法

```rust
// 返回迭代器
trait DataSource {
    fn iter(&self) -> impl Iterator<Item = i32>;
}

struct RangeSource {
    start: i32,
    end: i32,
}

impl DataSource for RangeSource {
    fn iter(&self) -> impl Iterator<Item = i32> {
        self.start..self.end
    }
}

// 返回 Future
trait AsyncComputer {
    fn compute(&self, x: i32) -> impl Future<Output = i32>;
}
```

---

## 5. 关联类型约束

### 5.1 约束语法

```rust
// 在 where 子句中约束关联类型
fn process<T>(value: T)
where
    T: Iterator,
    T::Item: Display,
{
    for item in value {
        println!("{}", item);
    }
}

// 多个关联类型约束
fn convert<T>(value: T)
where
    T: IntoIterator,
    T::Item: Into<String>,
    T::IntoIter: ExactSizeIterator,
{
    println!("Length: {}", value.into_iter().len());
}
```

### 5.2 嵌套关联类型约束

```rust
fn nested<T>(value: T)
where
    T: Iterator,
    T::Item: IntoIterator,
    <T::Item as IntoIterator>::Item: Display,
{
    for item in value {
        for inner in item {
            println!("{}", inner);
        }
    }
}
```

### 5.3 关联类型的等价约束

```rust
// 约束关联类型等于特定类型
fn specific<T>(iter: T)
where
    T: Iterator<Item = i32>,
{
    for num in iter {
        println!("{}", num);
    }
}

// 等价于
fn specific2<T>(iter: T)
where
    T: Iterator,
    T::Item == i32,  // 注意：这不是有效语法
{
    // 实际使用上面的语法
}
```

---

## 6. 完整使用模式

### 6.1 数据库抽象层

```rust
trait Database {
    type Connection;
    type Query;
    type Result<'a> where Self: 'a;
    type Error: std::error::Error;
    
    fn connect(&self) -> Result<Self::Connection, Self::Error>;
    fn execute<'a>(
        conn: &'a Self::Connection,
        query: Self::Query,
    ) -> Result<Self::Result<'a>, Self::Error>;
}

struct PostgreSQL;

impl Database for PostgreSQL {
    type Connection = PgConnection;
    type Query = String;
    type Result<'a> = &'a [Row];
    type Error = PgError;
    
    fn connect(&self) -> Result<PgConnection, PgError> {
        // ...
    }
    
    fn execute<'a>(
        conn: &'a PgConnection,
        query: String,
    ) -> Result<&'a [Row], PgError> {
        // ...
    }
}
```

### 6.2 Parser Combinator

```rust
trait Parser {
    type Input;
    type Output;
    type Error;
    
    fn parse(
        &self,
        input: Self::Input,
    ) -> Result<(Self::Output, Self::Input), Self::Error>;
}

trait ParserExt: Parser + Sized {
    fn map<F, U>(self, f: F) -> Map<Self, F>
    where
        F: Fn(Self::Output) -> U,
    {
        Map { parser: self, f }
    }
    
    fn and_then<F, P>(self, f: F) -> AndThen<Self, F>
    where
        F: Fn(Self::Output) -> P,
        P: Parser<Input = Self::Input, Error = Self::Error>,
    {
        AndThen { parser: self, f }
    }
}
```

### 6.3 异步迭代器

```rust
trait AsyncIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> impl Future<Output = Option<Self::Item<'a>>> + 'a;
}

struct AsyncRange {
    current: u32,
    end: u32,
}

impl AsyncIterator for AsyncRange {
    type Item<'a> = u32;
    
    async fn next<'a>(&'a mut self) -> Option<u32> {
        if self.current < self.end {
            self.current += 1;
            Some(self.current - 1)
        } else {
            None
        }
    }
}
```

---

## 7. 速查表

### 7.1 关联类型 vs 泛型参数

| 特性 | 关联类型 | 泛型参数 |
|------|----------|----------|
| 实现次数 | 每个类型一次 | 每个类型多次 |
| 类型指定 | 实现时 | 使用时 |
| 灵活性 | 较低 | 较高 |
| 使用场景 | 一对一关系 | 一对多关系 |

### 7.2 关联类型速查

| 语法 | 说明 |
|------|------|
| `type Item` | 基础关联类型 |
| `type Item: Trait` | 带约束的关联类型 |
| `type Item = Type` | 带默认值的关联类型 |
| `type Item<'a>` | GAT |
| `const NAME: Type` | 关联常量 |
| `-> impl Trait` | RPITIT |

### 7.3 GAT 特性表 (Rust 1.65+)

| 特性 | 支持 |
|------|------|
| 生命周期参数 | ✅ |
| 类型参数 | ✅ |
| const 参数 | ✅ |
| 约束 | ✅ |
| 默认值 | ✅ |

---

## 📚 相关参考

- [01_泛型语法参考.md](./01_泛型语法参考.md) - 泛型语法
- [02_Trait系统参考.md](./02_Trait系统参考.md) - Trait 系统
- [03_边界约束参考.md](./03_边界约束参考.md) - 约束语法
- [../tier_02_guides/03_关联类型指南.md](../tier_02_guides/03_关联类型指南.md) - 关联类型实践

---

**文档元信息**:

- 创建日期: 2025-10-22
- 作者: Rust-Lang Project
- 许可: MIT OR Apache-2.0
- Rust 版本: 1.90+
