# C04 泛型编程 - 泛型语法参考

## 📊 目录

- [C04 泛型编程 - 泛型语法参考](#c04-泛型编程---泛型语法参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 泛型类型参数语法](#1-泛型类型参数语法)
    - [1.1 基础语法](#11-基础语法)
    - [1.2 类型参数命名约定](#12-类型参数命名约定)
  - [2. 泛型函数语法](#2-泛型函数语法)
    - [2.1 完整语法](#21-完整语法)
    - [2.2 返回类型语法](#22-返回类型语法)
  - [3. 泛型结构体语法](#3-泛型结构体语法)
    - [3.1 定义语法](#31-定义语法)
    - [3.2 可见性语法](#32-可见性语法)
  - [4. 泛型枚举语法](#4-泛型枚举语法)
    - [4.1 定义语法](#41-定义语法)
  - [5. 泛型实现语法](#5-泛型实现语法)
    - [5.1 impl 块语法](#51-impl-块语法)
    - [5.2 关联类型实现](#52-关联类型实现)
  - [6. Const 泛型语法](#6-const-泛型语法)
    - [6.1 基础语法](#61-基础语法)
    - [6.2 const 泛型约束](#62-const-泛型约束)
  - [7. 完整 BNF 语法](#7-完整-bnf-语法)
    - [7.1 核心语法定义](#71-核心语法定义)
    - [7.2 语法示例对照](#72-语法示例对照)
  - [8. 语法规则速查](#8-语法规则速查)
    - [8.1 类型参数作用域](#81-类型参数作用域)
    - [8.2 约束语法对比](#82-约束语法对比)
    - [8.3 类型参数位置规则](#83-类型参数位置规则)
    - [8.4 Turbofish 语法 (`::<>`)](#84-turbofish-语法-)
    - [8.5 约束传播规则](#85-约束传播规则)
  - [📚 相关参考](#-相关参考)
  - [🔍 快速查找](#-快速查找)
    - [常见语法查询](#常见语法查询)

**文档类型**: Tier 3 完整参考  
**最后更新**: 2025-10-22  
**Rust 版本**: 1.90+  
**参考类型**: 🔍 语法速查

---

## 📋 目录

- [C04 泛型编程 - 泛型语法参考](#c04-泛型编程---泛型语法参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 泛型类型参数语法](#1-泛型类型参数语法)
    - [1.1 基础语法](#11-基础语法)
    - [1.2 类型参数命名约定](#12-类型参数命名约定)
  - [2. 泛型函数语法](#2-泛型函数语法)
    - [2.1 完整语法](#21-完整语法)
    - [2.2 返回类型语法](#22-返回类型语法)
  - [3. 泛型结构体语法](#3-泛型结构体语法)
    - [3.1 定义语法](#31-定义语法)
    - [3.2 可见性语法](#32-可见性语法)
  - [4. 泛型枚举语法](#4-泛型枚举语法)
    - [4.1 定义语法](#41-定义语法)
  - [5. 泛型实现语法](#5-泛型实现语法)
    - [5.1 impl 块语法](#51-impl-块语法)
    - [5.2 关联类型实现](#52-关联类型实现)
  - [6. Const 泛型语法](#6-const-泛型语法)
    - [6.1 基础语法](#61-基础语法)
    - [6.2 const 泛型约束](#62-const-泛型约束)
  - [7. 完整 BNF 语法](#7-完整-bnf-语法)
    - [7.1 核心语法定义](#71-核心语法定义)
    - [7.2 语法示例对照](#72-语法示例对照)
  - [8. 语法规则速查](#8-语法规则速查)
    - [8.1 类型参数作用域](#81-类型参数作用域)
    - [8.2 约束语法对比](#82-约束语法对比)
    - [8.3 类型参数位置规则](#83-类型参数位置规则)
    - [8.4 Turbofish 语法 (`::<>`)](#84-turbofish-语法-)
    - [8.5 约束传播规则](#85-约束传播规则)
  - [📚 相关参考](#-相关参考)
  - [🔍 快速查找](#-快速查找)
    - [常见语法查询](#常见语法查询)

---

## 1. 泛型类型参数语法

### 1.1 基础语法

```bnf
GenericParams ::= '<' GenericParam (',' GenericParam)* ','? '>'

GenericParam ::= TypeParam | ConstParam | LifetimeParam

TypeParam ::= Ident (':' TypeParamBounds?)? ('=' Type)?

TypeParamBounds ::= TypeParamBound ('+' TypeParamBound)*

TypeParamBound ::= Trait | Lifetime
```

**示例**:

```rust
// 单个类型参数
struct Container<T> { value: T }

// 多个类型参数
struct Pair<T, U> { first: T, second: U }

// 带约束的类型参数
struct Sorted<T: Ord> { items: Vec<T> }

// 带默认值的类型参数
struct Config<T = String> { data: T }

// 多重约束
struct Printable<T: Display + Debug> { value: T }
```

### 1.2 类型参数命名约定

| 惯例 | 用途 | 示例 |
|------|------|------|
| `T` | 通用类型 | `Option<T>` |
| `U`, `V` | 额外类型 | `Result<T, E>` |
| `E` | 错误类型 | `Result<T, E>` |
| `K`, `V` | 键值对 | `HashMap<K, V>` |
| `I` | 迭代器项 | `impl Iterator<Item = I>` |

---

## 2. 泛型函数语法

### 2.1 完整语法

```bnf
Function ::= FunctionQualifiers 'fn' Ident GenericParams? 
             '(' FunctionParameters? ')' ReturnType? WhereClause? BlockExpression

GenericParams ::= '<' GenericParam (',' GenericParam)* ','? '>'

WhereClause ::= 'where' WhereClauseItem (',' WhereClauseItem)* ','?

WhereClauseItem ::= Type ':' TypeParamBounds
```

**示例**:

```rust
// 基础泛型函数
fn identity<T>(value: T) -> T {
    value
}

// 多个类型参数
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// 带约束
fn print<T: Display>(value: T) {
    println!("{}", value);
}

// 使用 where 子句
fn compare<T, U>(a: T, b: U) -> bool
where
    T: PartialEq<U>,
{
    a == b
}

// 关联类型约束
fn process<I>(iter: I)
where
    I: Iterator,
    I::Item: Display,
{
    for item in iter {
        println!("{}", item);
    }
}
```

### 2.2 返回类型语法

```rust
// 具体类型
fn create<T>() -> T where T: Default {
    T::default()
}

// impl Trait (RPIT)
fn get_iter() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}

// 泛型类型
fn wrap<T>(value: T) -> Option<T> {
    Some(value)
}
```

---

## 3. 泛型结构体语法

### 3.1 定义语法

```bnf
Struct ::= 'struct' Ident GenericParams? WhereClause? StructFields

StructFields ::= NamedFields | TupleFields | UnitStruct

NamedFields ::= '{' StructField (',' StructField)* ','? '}'

StructField ::= FieldName ':' Type
```

**示例**:

```rust
// 命名字段
struct Point<T> {
    x: T,
    y: T,
}

// 元组结构体
struct Wrapper<T>(T);

// 多个类型参数
struct Pair<T, U> {
    first: T,
    second: U,
}

// 生命周期参数
struct Ref<'a, T> {
    value: &'a T,
}

// 约束
struct Container<T: Clone> {
    items: Vec<T>,
}

// where 子句
struct Complex<T, U>
where
    T: Display,
    U: Debug,
{
    t: T,
    u: U,
}
```

### 3.2 可见性语法

```rust
// 公共泛型结构体
pub struct Public<T> {
    pub value: T,
}

// 限制可见性
pub(crate) struct Crate<T> {
    pub(crate) value: T,
}
```

---

## 4. 泛型枚举语法

### 4.1 定义语法

```bnf
Enum ::= 'enum' Ident GenericParams? WhereClause? '{' EnumVariants '}'

EnumVariants ::= EnumVariant (',' EnumVariant)* ','?

EnumVariant ::= Ident VariantKind?

VariantKind ::= TupleVariant | StructVariant
```

**示例**:

```rust
// 基础泛型枚举
enum Option<T> {
    Some(T),
    None,
}

// 多个类型参数
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// 命名字段变体
enum Message<T> {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    Data(T),
}

// 递归泛型
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}
```

---

## 5. 泛型实现语法

### 5.1 impl 块语法

```bnf
Implementation ::= 'impl' GenericParams? Type WhereClause? '{' AssociatedItem* '}'

TraitImplementation ::= 'impl' GenericParams? Trait 'for' Type WhereClause? '{' AssociatedItem* '}'
```

**示例**:

```rust
struct Container<T> {
    value: T,
}

// 为泛型类型实现方法
impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }
    
    fn get(&self) -> &T {
        &self.value
    }
}

// 为特定类型实现
impl Container<i32> {
    fn double(&self) -> i32 {
        self.value * 2
    }
}

// 条件实现
impl<T: Clone> Container<T> {
    fn duplicate(&self) -> T {
        self.value.clone()
    }
}

// 实现 trait
impl<T: Display> Display for Container<T> {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "Container({})", self.value)
    }
}
```

### 5.2 关联类型实现

```rust
trait Container {
    type Item;
    fn get(&self) -> &Self::Item;
}

struct IntContainer {
    value: i32,
}

impl Container for IntContainer {
    type Item = i32;
    
    fn get(&self) -> &i32 {
        &self.value
    }
}
```

---

## 6. Const 泛型语法

### 6.1 基础语法

```bnf
ConstParam ::= 'const' Ident ':' Type

ConstGenericArg ::= BlockExpression | LiteralExpression | PathInExpression
```

**示例**:

```rust
// 基础 const 泛型
struct Array<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> Array<T, N> {
    fn len(&self) -> usize {
        N
    }
}

// 使用
let arr: Array<i32, 5> = Array {
    data: [1, 2, 3, 4, 5],
};

// const 泛型函数
fn create_array<const N: usize>() -> [i32; N] {
    [0; N]
}
```

### 6.2 const 泛型约束

```rust
// const 泛型表达式 (Rust 1.90+)
struct Matrix<T, const ROWS: usize, const COLS: usize>
where
    [(); ROWS * COLS]:,
{
    data: [T; ROWS * COLS],
}
```

---

## 7. 完整 BNF 语法

### 7.1 核心语法定义

```bnf
# 泛型参数
GenericParams ::= '<' GenericParam (',' GenericParam)* ','? '>'

GenericParam ::= OuterAttribute* (LifetimeParam | TypeParam | ConstParam)

LifetimeParam ::= LIFETIME_OR_LABEL (':' LifetimeBounds)?

TypeParam ::= Ident (':' TypeParamBounds?)? ('=' Type)?

ConstParam ::= 'const' Ident ':' Type

# 类型参数约束
TypeParamBounds ::= TypeParamBound ('+' TypeParamBound)* '+'?

TypeParamBound ::= Lifetime | TraitBound

TraitBound ::= '?'? 'for'? '<' LifetimeParams '>'? TypePath

# Where 子句
WhereClause ::= 'where' WhereClauseItem (',' WhereClauseItem)* ','?

WhereClauseItem ::= LifetimeWhereClauseItem | TypeBoundWhereClauseItem

TypeBoundWhereClauseItem ::= 'for'? '<' LifetimeParams '>'? Type ':' TypeParamBounds?

# 泛型参数应用
GenericArgs ::= '<' GenericArg (',' GenericArg)* ','? '>'

GenericArg ::= Lifetime | Type | GenericArgsConst | GenericArgsBinding

GenericArgsConst ::= BlockExpression | LiteralExpression | PathInExpression

GenericArgsBinding ::= Ident '=' Type
```

### 7.2 语法示例对照

| 语法结构 | BNF | 示例 |
|---------|-----|------|
| 类型参数 | `TypeParam ::= Ident` | `T` |
| 约束参数 | `TypeParam ':' Bounds` | `T: Clone` |
| 默认参数 | `TypeParam '=' Type` | `T = i32` |
| const 参数 | `'const' Ident ':' Type` | `const N: usize` |
| 生命周期参数 | `LIFETIME_OR_LABEL` | `'a` |
| 多重约束 | `Bounds ('+' Bounds)*` | `T: Clone + Debug` |
| where 子句 | `'where' Constraints` | `where T: Clone` |

---

## 8. 语法规则速查

### 8.1 类型参数作用域

```rust
// 函数级作用域
fn example<T>(value: T) {
    // T 仅在此函数中有效
}

// 结构体级作用域
struct Container<T> {
    // T 在整个结构体定义中有效
    value: T,
}

impl<T> Container<T> {
    // 需要重新声明 T
    fn new(value: T) -> Self {
        Container { value }
    }
}
```

### 8.2 约束语法对比

| 语法位置 | 语法 | 使用场景 |
|---------|------|----------|
| 参数位置 | `<T: Trait>` | 简单约束 |
| where 子句 | `where T: Trait` | 复杂约束、关联类型约束 |
| impl Trait | `fn f(x: impl Trait)` | 参数位置简写 |
| dyn Trait | `Box<dyn Trait>` | trait 对象 |

**示例对比**:

```rust
// 1. 参数位置约束
fn print1<T: Display>(value: T) {
    println!("{}", value);
}

// 2. where 子句 (等价)
fn print2<T>(value: T)
where
    T: Display,
{
    println!("{}", value);
}

// 3. impl Trait (类似，但有区别)
fn print3(value: impl Display) {
    println!("{}", value);
}

// 4. trait object (动态分发)
fn print4(value: &dyn Display) {
    println!("{}", value);
}
```

### 8.3 类型参数位置规则

```rust
// ✅ 允许的位置
struct S<T> { /* ... */ }        // 结构体定义
enum E<T> { /* ... */ }          // 枚举定义
fn f<T>() { /* ... */ }          // 函数定义
impl<T> S<T> { /* ... */ }       // impl 块
trait Tr<T> { /* ... */ }        // trait 定义
type Alias<T> = /* ... */;       // 类型别名

// ❌ 不允许的位置
let x: <T> = /* ... */;          // 局部变量
const C: <T> = /* ... */;        // 常量
static S: <T> = /* ... */;       // 静态变量
```

### 8.4 Turbofish 语法 (`::<>`)

```rust
// 函数调用
let v = Vec::<i32>::new();
let n = "42".parse::<i32>().unwrap();

// 方法链
let set = numbers.iter().collect::<HashSet<_>>();

// 类型转换
let v = <Vec<i32>>::from([1, 2, 3]);

// 关联函数
let value = <i32 as Default>::default();
```

### 8.5 约束传播规则

```rust
// 约束自动传播到方法
struct Container<T: Clone> {
    value: T,
}

impl<T: Clone> Container<T> {
    fn duplicate(&self) -> T {
        // Clone 约束可用
        self.value.clone()
    }
}

// 额外约束
impl<T: Clone + Display> Container<T> {
    fn print_duplicate(&self) {
        // Clone 和 Display 都可用
        println!("{}", self.value.clone());
    }
}
```

---

## 📚 相关参考

- [02_Trait系统参考.md](./02_Trait系统参考.md) - Trait 完整语法
- [03_边界约束参考.md](./03_边界约束参考.md) - 约束语法详解
- [04_关联类型参考.md](./04_关联类型参考.md) - 关联类型语法
- [../tier_02_guides/01_泛型基础指南.md](../tier_02_guides/01_泛型基础指南.md) - 泛型基础教程

---

## 🔍 快速查找

### 常见语法查询

| 想要... | 查看章节 |
|--------|---------|
| 定义泛型函数 | [2.1 完整语法](#21-完整语法) |
| 定义泛型结构体 | [3.1 定义语法](#31-定义语法) |
| 添加类型约束 | [8.2 约束语法对比](#82-约束语法对比) |
| 使用 const 泛型 | [6.1 基础语法](#61-基础语法) |
| 理解 Turbofish | [8.4 Turbofish 语法](#84-turbofish-语法-) |
| 查看 BNF 定义 | [7.1 核心语法定义](#71-核心语法定义) |

---

**文档元信息**:

- 创建日期: 2025-10-22
- 作者: Rust-Lang Project
- 许可: MIT OR Apache-2.0
- Rust 版本: 1.90+
