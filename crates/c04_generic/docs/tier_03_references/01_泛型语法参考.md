# C04 æ³›å‹ç¼–ç¨‹ - æ³›å‹è¯­æ³•å‚è€ƒ

**æ–‡æ¡£ç±»å‹**: Tier 3 å®Œæ•´å‚è€ƒ  
**æœ€åæ›´æ–°**: 2025-10-22  
**Rust ç‰ˆæœ¬**: 1.90+  
**å‚è€ƒç±»å‹**: ğŸ” è¯­æ³•é€ŸæŸ¥

---

## ğŸ“‹ ç›®å½•

- [C04 æ³›å‹ç¼–ç¨‹ - æ³›å‹è¯­æ³•å‚è€ƒ](#c04-æ³›å‹ç¼–ç¨‹---æ³›å‹è¯­æ³•å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ³›å‹ç±»å‹å‚æ•°è¯­æ³•](#1-æ³›å‹ç±»å‹å‚æ•°è¯­æ³•)
    - [1.1 åŸºç¡€è¯­æ³•](#11-åŸºç¡€è¯­æ³•)
    - [1.2 ç±»å‹å‚æ•°å‘½åçº¦å®š](#12-ç±»å‹å‚æ•°å‘½åçº¦å®š)
  - [2. æ³›å‹å‡½æ•°è¯­æ³•](#2-æ³›å‹å‡½æ•°è¯­æ³•)
    - [2.1 å®Œæ•´è¯­æ³•](#21-å®Œæ•´è¯­æ³•)
    - [2.2 è¿”å›ç±»å‹è¯­æ³•](#22-è¿”å›ç±»å‹è¯­æ³•)
  - [3. æ³›å‹ç»“æ„ä½“è¯­æ³•](#3-æ³›å‹ç»“æ„ä½“è¯­æ³•)
    - [3.1 å®šä¹‰è¯­æ³•](#31-å®šä¹‰è¯­æ³•)
    - [3.2 å¯è§æ€§è¯­æ³•](#32-å¯è§æ€§è¯­æ³•)
  - [4. æ³›å‹æšä¸¾è¯­æ³•](#4-æ³›å‹æšä¸¾è¯­æ³•)
    - [4.1 å®šä¹‰è¯­æ³•](#41-å®šä¹‰è¯­æ³•)
  - [5. æ³›å‹å®ç°è¯­æ³•](#5-æ³›å‹å®ç°è¯­æ³•)
    - [5.1 impl å—è¯­æ³•](#51-impl-å—è¯­æ³•)
    - [5.2 å…³è”ç±»å‹å®ç°](#52-å…³è”ç±»å‹å®ç°)
  - [6. Const æ³›å‹è¯­æ³•](#6-const-æ³›å‹è¯­æ³•)
    - [6.1 åŸºç¡€è¯­æ³•](#61-åŸºç¡€è¯­æ³•)
    - [6.2 const æ³›å‹çº¦æŸ](#62-const-æ³›å‹çº¦æŸ)
  - [7. å®Œæ•´ BNF è¯­æ³•](#7-å®Œæ•´-bnf-è¯­æ³•)
    - [7.1 æ ¸å¿ƒè¯­æ³•å®šä¹‰](#71-æ ¸å¿ƒè¯­æ³•å®šä¹‰)
    - [7.2 è¯­æ³•ç¤ºä¾‹å¯¹ç…§](#72-è¯­æ³•ç¤ºä¾‹å¯¹ç…§)
  - [8. è¯­æ³•è§„åˆ™é€ŸæŸ¥](#8-è¯­æ³•è§„åˆ™é€ŸæŸ¥)
    - [8.1 ç±»å‹å‚æ•°ä½œç”¨åŸŸ](#81-ç±»å‹å‚æ•°ä½œç”¨åŸŸ)
    - [8.2 çº¦æŸè¯­æ³•å¯¹æ¯”](#82-çº¦æŸè¯­æ³•å¯¹æ¯”)
    - [8.3 ç±»å‹å‚æ•°ä½ç½®è§„åˆ™](#83-ç±»å‹å‚æ•°ä½ç½®è§„åˆ™)
    - [8.4 Turbofish è¯­æ³• (`::<>`)](#84-turbofish-è¯­æ³•-)
    - [8.5 çº¦æŸä¼ æ’­è§„åˆ™](#85-çº¦æŸä¼ æ’­è§„åˆ™)
  - [ğŸ“š ç›¸å…³å‚è€ƒ](#-ç›¸å…³å‚è€ƒ)
  - [ğŸ” å¿«é€ŸæŸ¥æ‰¾](#-å¿«é€ŸæŸ¥æ‰¾)
    - [å¸¸è§è¯­æ³•æŸ¥è¯¢](#å¸¸è§è¯­æ³•æŸ¥è¯¢)

---

## 1. æ³›å‹ç±»å‹å‚æ•°è¯­æ³•

### 1.1 åŸºç¡€è¯­æ³•

```bnf
GenericParams ::= '<' GenericParam (',' GenericParam)* ','? '>'

GenericParam ::= TypeParam | ConstParam | LifetimeParam

TypeParam ::= Ident (':' TypeParamBounds?)? ('=' Type)?

TypeParamBounds ::= TypeParamBound ('+' TypeParamBound)*

TypeParamBound ::= Trait | Lifetime
```

**ç¤ºä¾‹**:

```rust
// å•ä¸ªç±»å‹å‚æ•°
struct Container<T> { value: T }

// å¤šä¸ªç±»å‹å‚æ•°
struct Pair<T, U> { first: T, second: U }

// å¸¦çº¦æŸçš„ç±»å‹å‚æ•°
struct Sorted<T: Ord> { items: Vec<T> }

// å¸¦é»˜è®¤å€¼çš„ç±»å‹å‚æ•°
struct Config<T = String> { data: T }

// å¤šé‡çº¦æŸ
struct Printable<T: Display + Debug> { value: T }
```

### 1.2 ç±»å‹å‚æ•°å‘½åçº¦å®š

| æƒ¯ä¾‹ | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| `T` | é€šç”¨ç±»å‹ | `Option<T>` |
| `U`, `V` | é¢å¤–ç±»å‹ | `Result<T, E>` |
| `E` | é”™è¯¯ç±»å‹ | `Result<T, E>` |
| `K`, `V` | é”®å€¼å¯¹ | `HashMap<K, V>` |
| `I` | è¿­ä»£å™¨é¡¹ | `impl Iterator<Item = I>` |

---

## 2. æ³›å‹å‡½æ•°è¯­æ³•

### 2.1 å®Œæ•´è¯­æ³•

```bnf
Function ::= FunctionQualifiers 'fn' Ident GenericParams? 
             '(' FunctionParameters? ')' ReturnType? WhereClause? BlockExpression

GenericParams ::= '<' GenericParam (',' GenericParam)* ','? '>'

WhereClause ::= 'where' WhereClauseItem (',' WhereClauseItem)* ','?

WhereClauseItem ::= Type ':' TypeParamBounds
```

**ç¤ºä¾‹**:

```rust
// åŸºç¡€æ³›å‹å‡½æ•°
fn identity<T>(value: T) -> T {
    value
}

// å¤šä¸ªç±»å‹å‚æ•°
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// å¸¦çº¦æŸ
fn print<T: Display>(value: T) {
    println!("{}", value);
}

// ä½¿ç”¨ where å­å¥
fn compare<T, U>(a: T, b: U) -> bool
where
    T: PartialEq<U>,
{
    a == b
}

// å…³è”ç±»å‹çº¦æŸ
fn process<I>(iter: I)
where
    I: Iterator,
    I::Item: Display,
{
    for item in iter {
        println!("{}", item);
    }
}
```

### 2.2 è¿”å›ç±»å‹è¯­æ³•

```rust
// å…·ä½“ç±»å‹
fn create<T>() -> T where T: Default {
    T::default()
}

// impl Trait (RPIT)
fn get_iter() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}

// æ³›å‹ç±»å‹
fn wrap<T>(value: T) -> Option<T> {
    Some(value)
}
```

---

## 3. æ³›å‹ç»“æ„ä½“è¯­æ³•

### 3.1 å®šä¹‰è¯­æ³•

```bnf
Struct ::= 'struct' Ident GenericParams? WhereClause? StructFields

StructFields ::= NamedFields | TupleFields | UnitStruct

NamedFields ::= '{' StructField (',' StructField)* ','? '}'

StructField ::= FieldName ':' Type
```

**ç¤ºä¾‹**:

```rust
// å‘½åå­—æ®µ
struct Point<T> {
    x: T,
    y: T,
}

// å…ƒç»„ç»“æ„ä½“
struct Wrapper<T>(T);

// å¤šä¸ªç±»å‹å‚æ•°
struct Pair<T, U> {
    first: T,
    second: U,
}

// ç”Ÿå‘½å‘¨æœŸå‚æ•°
struct Ref<'a, T> {
    value: &'a T,
}

// çº¦æŸ
struct Container<T: Clone> {
    items: Vec<T>,
}

// where å­å¥
struct Complex<T, U>
where
    T: Display,
    U: Debug,
{
    t: T,
    u: U,
}
```

### 3.2 å¯è§æ€§è¯­æ³•

```rust
// å…¬å…±æ³›å‹ç»“æ„ä½“
pub struct Public<T> {
    pub value: T,
}

// é™åˆ¶å¯è§æ€§
pub(crate) struct Crate<T> {
    pub(crate) value: T,
}
```

---

## 4. æ³›å‹æšä¸¾è¯­æ³•

### 4.1 å®šä¹‰è¯­æ³•

```bnf
Enum ::= 'enum' Ident GenericParams? WhereClause? '{' EnumVariants '}'

EnumVariants ::= EnumVariant (',' EnumVariant)* ','?

EnumVariant ::= Ident VariantKind?

VariantKind ::= TupleVariant | StructVariant
```

**ç¤ºä¾‹**:

```rust
// åŸºç¡€æ³›å‹æšä¸¾
enum Option<T> {
    Some(T),
    None,
}

// å¤šä¸ªç±»å‹å‚æ•°
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// å‘½åå­—æ®µå˜ä½“
enum Message<T> {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    Data(T),
}

// é€’å½’æ³›å‹
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}
```

---

## 5. æ³›å‹å®ç°è¯­æ³•

### 5.1 impl å—è¯­æ³•

```bnf
Implementation ::= 'impl' GenericParams? Type WhereClause? '{' AssociatedItem* '}'

TraitImplementation ::= 'impl' GenericParams? Trait 'for' Type WhereClause? '{' AssociatedItem* '}'
```

**ç¤ºä¾‹**:

```rust
struct Container<T> {
    value: T,
}

// ä¸ºæ³›å‹ç±»å‹å®ç°æ–¹æ³•
impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }
    
    fn get(&self) -> &T {
        &self.value
    }
}

// ä¸ºç‰¹å®šç±»å‹å®ç°
impl Container<i32> {
    fn double(&self) -> i32 {
        self.value * 2
    }
}

// æ¡ä»¶å®ç°
impl<T: Clone> Container<T> {
    fn duplicate(&self) -> T {
        self.value.clone()
    }
}

// å®ç° trait
impl<T: Display> Display for Container<T> {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "Container({})", self.value)
    }
}
```

### 5.2 å…³è”ç±»å‹å®ç°

```rust
trait Container {
    type Item;
    fn get(&self) -> &Self::Item;
}

struct IntContainer {
    value: i32,
}

impl Container for IntContainer {
    type Item = i32;
    
    fn get(&self) -> &i32 {
        &self.value
    }
}
```

---

## 6. Const æ³›å‹è¯­æ³•

### 6.1 åŸºç¡€è¯­æ³•

```bnf
ConstParam ::= 'const' Ident ':' Type

ConstGenericArg ::= BlockExpression | LiteralExpression | PathInExpression
```

**ç¤ºä¾‹**:

```rust
// åŸºç¡€ const æ³›å‹
struct Array<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> Array<T, N> {
    fn len(&self) -> usize {
        N
    }
}

// ä½¿ç”¨
let arr: Array<i32, 5> = Array {
    data: [1, 2, 3, 4, 5],
};

// const æ³›å‹å‡½æ•°
fn create_array<const N: usize>() -> [i32; N] {
    [0; N]
}
```

### 6.2 const æ³›å‹çº¦æŸ

```rust
// const æ³›å‹è¡¨è¾¾å¼ (Rust 1.90+)
struct Matrix<T, const ROWS: usize, const COLS: usize>
where
    [(); ROWS * COLS]:,
{
    data: [T; ROWS * COLS],
}
```

---

## 7. å®Œæ•´ BNF è¯­æ³•

### 7.1 æ ¸å¿ƒè¯­æ³•å®šä¹‰

```bnf
# æ³›å‹å‚æ•°
GenericParams ::= '<' GenericParam (',' GenericParam)* ','? '>'

GenericParam ::= OuterAttribute* (LifetimeParam | TypeParam | ConstParam)

LifetimeParam ::= LIFETIME_OR_LABEL (':' LifetimeBounds)?

TypeParam ::= Ident (':' TypeParamBounds?)? ('=' Type)?

ConstParam ::= 'const' Ident ':' Type

# ç±»å‹å‚æ•°çº¦æŸ
TypeParamBounds ::= TypeParamBound ('+' TypeParamBound)* '+'?

TypeParamBound ::= Lifetime | TraitBound

TraitBound ::= '?'? 'for'? '<' LifetimeParams '>'? TypePath

# Where å­å¥
WhereClause ::= 'where' WhereClauseItem (',' WhereClauseItem)* ','?

WhereClauseItem ::= LifetimeWhereClauseItem | TypeBoundWhereClauseItem

TypeBoundWhereClauseItem ::= 'for'? '<' LifetimeParams '>'? Type ':' TypeParamBounds?

# æ³›å‹å‚æ•°åº”ç”¨
GenericArgs ::= '<' GenericArg (',' GenericArg)* ','? '>'

GenericArg ::= Lifetime | Type | GenericArgsConst | GenericArgsBinding

GenericArgsConst ::= BlockExpression | LiteralExpression | PathInExpression

GenericArgsBinding ::= Ident '=' Type
```

### 7.2 è¯­æ³•ç¤ºä¾‹å¯¹ç…§

| è¯­æ³•ç»“æ„ | BNF | ç¤ºä¾‹ |
|---------|-----|------|
| ç±»å‹å‚æ•° | `TypeParam ::= Ident` | `T` |
| çº¦æŸå‚æ•° | `TypeParam ':' Bounds` | `T: Clone` |
| é»˜è®¤å‚æ•° | `TypeParam '=' Type` | `T = i32` |
| const å‚æ•° | `'const' Ident ':' Type` | `const N: usize` |
| ç”Ÿå‘½å‘¨æœŸå‚æ•° | `LIFETIME_OR_LABEL` | `'a` |
| å¤šé‡çº¦æŸ | `Bounds ('+' Bounds)*` | `T: Clone + Debug` |
| where å­å¥ | `'where' Constraints` | `where T: Clone` |

---

## 8. è¯­æ³•è§„åˆ™é€ŸæŸ¥

### 8.1 ç±»å‹å‚æ•°ä½œç”¨åŸŸ

```rust
// å‡½æ•°çº§ä½œç”¨åŸŸ
fn example<T>(value: T) {
    // T ä»…åœ¨æ­¤å‡½æ•°ä¸­æœ‰æ•ˆ
}

// ç»“æ„ä½“çº§ä½œç”¨åŸŸ
struct Container<T> {
    // T åœ¨æ•´ä¸ªç»“æ„ä½“å®šä¹‰ä¸­æœ‰æ•ˆ
    value: T,
}

impl<T> Container<T> {
    // éœ€è¦é‡æ–°å£°æ˜ T
    fn new(value: T) -> Self {
        Container { value }
    }
}
```

### 8.2 çº¦æŸè¯­æ³•å¯¹æ¯”

| è¯­æ³•ä½ç½® | è¯­æ³• | ä½¿ç”¨åœºæ™¯ |
|---------|------|----------|
| å‚æ•°ä½ç½® | `<T: Trait>` | ç®€å•çº¦æŸ |
| where å­å¥ | `where T: Trait` | å¤æ‚çº¦æŸã€å…³è”ç±»å‹çº¦æŸ |
| impl Trait | `fn f(x: impl Trait)` | å‚æ•°ä½ç½®ç®€å†™ |
| dyn Trait | `Box<dyn Trait>` | trait å¯¹è±¡ |

**ç¤ºä¾‹å¯¹æ¯”**:

```rust
// 1. å‚æ•°ä½ç½®çº¦æŸ
fn print1<T: Display>(value: T) {
    println!("{}", value);
}

// 2. where å­å¥ (ç­‰ä»·)
fn print2<T>(value: T)
where
    T: Display,
{
    println!("{}", value);
}

// 3. impl Trait (ç±»ä¼¼ï¼Œä½†æœ‰åŒºåˆ«)
fn print3(value: impl Display) {
    println!("{}", value);
}

// 4. trait object (åŠ¨æ€åˆ†å‘)
fn print4(value: &dyn Display) {
    println!("{}", value);
}
```

### 8.3 ç±»å‹å‚æ•°ä½ç½®è§„åˆ™

```rust
// âœ… å…è®¸çš„ä½ç½®
struct S<T> { /* ... */ }        // ç»“æ„ä½“å®šä¹‰
enum E<T> { /* ... */ }          // æšä¸¾å®šä¹‰
fn f<T>() { /* ... */ }          // å‡½æ•°å®šä¹‰
impl<T> S<T> { /* ... */ }       // impl å—
trait Tr<T> { /* ... */ }        // trait å®šä¹‰
type Alias<T> = /* ... */;       // ç±»å‹åˆ«å

// âŒ ä¸å…è®¸çš„ä½ç½®
let x: <T> = /* ... */;          // å±€éƒ¨å˜é‡
const C: <T> = /* ... */;        // å¸¸é‡
static S: <T> = /* ... */;       // é™æ€å˜é‡
```

### 8.4 Turbofish è¯­æ³• (`::<>`)

```rust
// å‡½æ•°è°ƒç”¨
let v = Vec::<i32>::new();
let n = "42".parse::<i32>().unwrap();

// æ–¹æ³•é“¾
let set = numbers.iter().collect::<HashSet<_>>();

// ç±»å‹è½¬æ¢
let v = <Vec<i32>>::from([1, 2, 3]);

// å…³è”å‡½æ•°
let value = <i32 as Default>::default();
```

### 8.5 çº¦æŸä¼ æ’­è§„åˆ™

```rust
// çº¦æŸè‡ªåŠ¨ä¼ æ’­åˆ°æ–¹æ³•
struct Container<T: Clone> {
    value: T,
}

impl<T: Clone> Container<T> {
    fn duplicate(&self) -> T {
        // Clone çº¦æŸå¯ç”¨
        self.value.clone()
    }
}

// é¢å¤–çº¦æŸ
impl<T: Clone + Display> Container<T> {
    fn print_duplicate(&self) {
        // Clone å’Œ Display éƒ½å¯ç”¨
        println!("{}", self.value.clone());
    }
}
```

---

## ğŸ“š ç›¸å…³å‚è€ƒ

- [02_Traitç³»ç»Ÿå‚è€ƒ.md](./02_Traitç³»ç»Ÿå‚è€ƒ.md) - Trait å®Œæ•´è¯­æ³•
- [03_è¾¹ç•Œçº¦æŸå‚è€ƒ.md](./03_è¾¹ç•Œçº¦æŸå‚è€ƒ.md) - çº¦æŸè¯­æ³•è¯¦è§£
- [04_å…³è”ç±»å‹å‚è€ƒ.md](./04_å…³è”ç±»å‹å‚è€ƒ.md) - å…³è”ç±»å‹è¯­æ³•
- [../tier_02_guides/01_æ³›å‹åŸºç¡€æŒ‡å—.md](../tier_02_guides/01_æ³›å‹åŸºç¡€æŒ‡å—.md) - æ³›å‹åŸºç¡€æ•™ç¨‹

---

## ğŸ” å¿«é€ŸæŸ¥æ‰¾

### å¸¸è§è¯­æ³•æŸ¥è¯¢

| æƒ³è¦... | æŸ¥çœ‹ç« èŠ‚ |
|--------|---------|
| å®šä¹‰æ³›å‹å‡½æ•° | [2.1 å®Œæ•´è¯­æ³•](#21-å®Œæ•´è¯­æ³•) |
| å®šä¹‰æ³›å‹ç»“æ„ä½“ | [3.1 å®šä¹‰è¯­æ³•](#31-å®šä¹‰è¯­æ³•) |
| æ·»åŠ ç±»å‹çº¦æŸ | [8.2 çº¦æŸè¯­æ³•å¯¹æ¯”](#82-çº¦æŸè¯­æ³•å¯¹æ¯”) |
| ä½¿ç”¨ const æ³›å‹ | [6.1 åŸºç¡€è¯­æ³•](#61-åŸºç¡€è¯­æ³•) |
| ç†è§£ Turbofish | [8.4 Turbofish è¯­æ³•](#84-turbofish-è¯­æ³•-) |
| æŸ¥çœ‹ BNF å®šä¹‰ | [7.1 æ ¸å¿ƒè¯­æ³•å®šä¹‰](#71-æ ¸å¿ƒè¯­æ³•å®šä¹‰) |

---

**æ–‡æ¡£å…ƒä¿¡æ¯**:

- åˆ›å»ºæ—¥æœŸ: 2025-10-22
- ä½œè€…: Rust-Lang Project
- è®¸å¯: MIT OR Apache-2.0
- Rust ç‰ˆæœ¬: 1.90+
