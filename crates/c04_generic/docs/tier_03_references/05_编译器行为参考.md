# C04 泛型编程 - 编译器行为完整参考


## 📊 目录

- [C04 泛型编程 - 编译器行为完整参考](#c04-泛型编程---编译器行为完整参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. Monomorphization (单态化)](#1-monomorphization-单态化)
    - [1.1 定义](#11-定义)
    - [1.2 工作原理](#12-工作原理)
    - [1.3 优势与代价](#13-优势与代价)
    - [1.4 代码膨胀示例](#14-代码膨胀示例)
    - [1.5 查看单态化结果](#15-查看单态化结果)
  - [2. 静态分发 vs 动态分发](#2-静态分发-vs-动态分发)
    - [2.1 静态分发 (Static Dispatch)](#21-静态分发-static-dispatch)
    - [2.2 动态分发 (Dynamic Dispatch)](#22-动态分发-dynamic-dispatch)
    - [2.3 性能对比](#23-性能对比)
  - [3. Type Erasure (类型擦除)](#3-type-erasure-类型擦除)
    - [3.1 定义](#31-定义)
    - [3.2 类型擦除过程](#32-类型擦除过程)
    - [3.3 类型擦除的限制](#33-类型擦除的限制)
  - [4. Fat Pointer 结构](#4-fat-pointer-结构)
    - [4.1 定义](#41-定义)
    - [4.2 内存布局](#42-内存布局)
    - [4.3 VTable 结构](#43-vtable-结构)
    - [4.4 多个 Trait 的 Fat Pointer](#44-多个-trait-的-fat-pointer)
  - [5. 编译器优化](#5-编译器优化)
    - [5.1 内联优化](#51-内联优化)
    - [5.2 常量折叠](#52-常量折叠)
    - [5.3 死代码消除](#53-死代码消除)
  - [6. 性能特性](#6-性能特性)
    - [6.1 零成本抽象](#61-零成本抽象)
    - [6.2 性能基准测试](#62-性能基准测试)
    - [6.3 性能对比表](#63-性能对比表)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 何时使用静态分发](#71-何时使用静态分发)
    - [7.2 何时使用动态分发](#72-何时使用动态分发)
    - [7.3 代码大小优化](#73-代码大小优化)
    - [7.4 编译时间优化](#74-编译时间优化)
  - [📚 相关参考](#-相关参考)


**文档类型**: Tier 3 完整参考  
**最后更新**: 2025-10-22  
**Rust 版本**: 1.90+  
**参考类型**: 🔍 编译器行为速查

---

## 📋 目录

- [C04 泛型编程 - 编译器行为完整参考](#c04-泛型编程---编译器行为完整参考)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. Monomorphization (单态化)](#1-monomorphization-单态化)
    - [1.1 定义](#11-定义)
    - [1.2 工作原理](#12-工作原理)
    - [1.3 优势与代价](#13-优势与代价)
    - [1.4 代码膨胀示例](#14-代码膨胀示例)
    - [1.5 查看单态化结果](#15-查看单态化结果)
  - [2. 静态分发 vs 动态分发](#2-静态分发-vs-动态分发)
    - [2.1 静态分发 (Static Dispatch)](#21-静态分发-static-dispatch)
    - [2.2 动态分发 (Dynamic Dispatch)](#22-动态分发-dynamic-dispatch)
    - [2.3 性能对比](#23-性能对比)
  - [3. Type Erasure (类型擦除)](#3-type-erasure-类型擦除)
    - [3.1 定义](#31-定义)
    - [3.2 类型擦除过程](#32-类型擦除过程)
    - [3.3 类型擦除的限制](#33-类型擦除的限制)
  - [4. Fat Pointer 结构](#4-fat-pointer-结构)
    - [4.1 定义](#41-定义)
    - [4.2 内存布局](#42-内存布局)
    - [4.3 VTable 结构](#43-vtable-结构)
    - [4.4 多个 Trait 的 Fat Pointer](#44-多个-trait-的-fat-pointer)
  - [5. 编译器优化](#5-编译器优化)
    - [5.1 内联优化](#51-内联优化)
    - [5.2 常量折叠](#52-常量折叠)
    - [5.3 死代码消除](#53-死代码消除)
  - [6. 性能特性](#6-性能特性)
    - [6.1 零成本抽象](#61-零成本抽象)
    - [6.2 性能基准测试](#62-性能基准测试)
    - [6.3 性能对比表](#63-性能对比表)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 何时使用静态分发](#71-何时使用静态分发)
    - [7.2 何时使用动态分发](#72-何时使用动态分发)
    - [7.3 代码大小优化](#73-代码大小优化)
    - [7.4 编译时间优化](#74-编译时间优化)
  - [📚 相关参考](#-相关参考)

---

## 1. Monomorphization (单态化)

### 1.1 定义

**Monomorphization** 是编译器为每个具体类型生成泛型代码的专门版本的过程。

### 1.2 工作原理

```rust
// 源代码
fn print<T: Display>(value: T) {
    println!("{}", value);
}

fn main() {
    print(42);
    print("hello");
    print(3.14);
}

// 编译后生成（概念上）
fn print_i32(value: i32) {
    println!("{}", value);
}

fn print_str(value: &str) {
    println!("{}", value);
}

fn print_f64(value: f64) {
    println!("{}", value);
}

fn main() {
    print_i32(42);
    print_str("hello");
    print_f64(3.14);
}
```

### 1.3 优势与代价

**优势**:

- ✅ 零运行时开销
- ✅ 完全内联优化
- ✅ 编译时类型检查
- ✅ 无虚函数调用开销

**代价**:

- ❌ 代码膨胀 (Code Bloat)
- ❌ 编译时间增加
- ❌ 二进制文件增大
- ❌ 指令缓存压力

### 1.4 代码膨胀示例

```rust
// 每个具体类型都生成一份代码
fn process<T: Clone>(value: T) -> T {
    value.clone()
}

// 使用
process(42);              // 生成 process_i32
process("hello");         // 生成 process_str
process(vec![1, 2, 3]);   // 生成 process_vec_i32
process(Some(42));        // 生成 process_option_i32

// 结果：二进制中有4个 process 函数的副本
```

### 1.5 查看单态化结果

```bash
# 使用 cargo-bloat 查看代码大小
cargo install cargo-bloat
cargo bloat --release

# 查看生成的符号
rustc --emit=asm example.rs
```

---

## 2. 静态分发 vs 动态分发

### 2.1 静态分发 (Static Dispatch)

**定义**: 在编译时确定调用哪个函数。

```rust
// 静态分发：使用泛型
fn print_static<T: Display>(value: &T) {
    println!("{}", value);
}

// 编译时确定
print_static(&42);      // 调用 print_static::<i32>
print_static(&"hello"); // 调用 print_static::<&str>
```

**优势**:

- 零运行时开销
- 可以完全内联
- 编译时优化

**代价**:

- 代码膨胀
- 编译时间长

### 2.2 动态分发 (Dynamic Dispatch)

**定义**: 在运行时通过 vtable 确定调用哪个函数。

```rust
// 动态分发：使用 trait object
fn print_dynamic(value: &dyn Display) {
    println!("{}", value);
}

// 运行时确定
print_dynamic(&42);      // 通过 vtable 调用
print_dynamic(&"hello"); // 通过 vtable 调用
```

**优势**:

- 代码大小小
- 编译时间短
- 灵活性高

**代价**:

- 运行时开销 (虚函数调用)
- 无法内联
- 需要额外内存 (vtable)

### 2.3 性能对比

```rust
use std::time::Instant;

trait Compute {
    fn compute(&self) -> i32;
}

struct Value(i32);

impl Compute for Value {
    fn compute(&self) -> i32 {
        self.0 * 2
    }
}

// 静态分发
fn static_dispatch<T: Compute>(value: &T) -> i32 {
    value.compute()
}

// 动态分发
fn dynamic_dispatch(value: &dyn Compute) -> i32 {
    value.compute()
}

fn benchmark() {
    let value = Value(42);
    let iterations = 100_000_000;
    
    // 静态分发
    let start = Instant::now();
    for _ in 0..iterations {
        static_dispatch(&value);
    }
    println!("Static: {:?}", start.elapsed());
    
    // 动态分发
    let start = Instant::now();
    for _ in 0..iterations {
        dynamic_dispatch(&value);
    }
    println!("Dynamic: {:?}", start.elapsed());
}

// 典型结果：
// Static: 0ms (完全优化掉)
// Dynamic: ~100ms (虚函数调用开销)
```

---

## 3. Type Erasure (类型擦除)

### 3.1 定义

**类型擦除** 是在使用 trait object 时，具体类型信息被"擦除"，只保留 trait 的接口信息。

### 3.2 类型擦除过程

```rust
trait Animal {
    fn make_sound(&self);
}

struct Dog;
struct Cat;

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}

impl Animal for Cat {
    fn make_sound(&self) {
        println!("Meow!");
    }
}

// 类型擦除前
fn specific_dog(dog: &Dog) {
    dog.make_sound();
}

// 类型擦除后
fn any_animal(animal: &dyn Animal) {
    // 不知道具体是 Dog 还是 Cat
    animal.make_sound();
}
```

### 3.3 类型擦除的限制

```rust
trait Shape {
    fn area(&self) -> f64;
    fn clone(&self) -> Self;  // ❌ 返回 Self 不对象安全
}

// 解决方案：类型擦除友好的设计
trait Shape {
    fn area(&self) -> f64;
    fn clone_box(&self) -> Box<dyn Shape>;  // ✅ 返回 trait object
}
```

---

## 4. Fat Pointer 结构

### 4.1 定义

**Fat Pointer** (胖指针) 是指向 trait object 的指针，包含两部分：

1. 指向数据的指针
2. 指向 vtable 的指针

### 4.2 内存布局

```rust
trait Animal {
    fn make_sound(&self);
}

struct Dog {
    name: String,
}

impl Animal for Dog {
    fn make_sound(&self) {
        println!("Woof!");
    }
}

let dog = Dog {
    name: String::from("Buddy"),
};

let animal: &dyn Animal = &dog;

// animal 是一个 fat pointer:
// ┌──────────────────┐
// │ Data Pointer     │ ─→ Dog { name: "Buddy" }
// ├──────────────────┤
// │ VTable Pointer   │ ─→ VTable for Dog: Animal
// └──────────────────┘

// 大小对比
assert_eq!(std::mem::size_of::<&Dog>(), 8);       // 普通引用：8 字节
assert_eq!(std::mem::size_of::<&dyn Animal>(), 16); // Fat pointer：16 字节
```

### 4.3 VTable 结构

```text
VTable for Dog: Animal
┌──────────────────────┐
│ Drop Fn              │ ─→ dog 的 drop 函数
├──────────────────────┤
│ Size                 │ ─→ Dog 的大小
├──────────────────────┤
│ Alignment            │ ─→ Dog 的对齐
├──────────────────────┤
│ make_sound Fn        │ ─→ Dog::make_sound 实现
└──────────────────────┘
```

### 4.4 多个 Trait 的 Fat Pointer

```rust
trait Animal {
    fn make_sound(&self);
}

trait Pet {
    fn play(&self);
}

// 单个 trait
let a: &dyn Animal = &dog;  // 16 字节 (data + vtable)

// 多个 trait (trait object 不支持)
// let ap: &(dyn Animal + Pet) = &dog;  // ❌ 不支持

// 解决方案：组合 trait
trait AnimalPet: Animal + Pet {}
let ap: &dyn AnimalPet = &dog;  // 16 字节
```

---

## 5. 编译器优化

### 5.1 内联优化

```rust
// 小函数通常会被内联
#[inline]
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// 泛型函数更容易被内联
let result = add(1, 2);  // 编译后可能完全优化掉

// 使用泛型避免函数调用开销
fn process_vec<T, F>(vec: Vec<T>, f: F)
where
    F: Fn(T) -> T,
{
    // f 可能被完全内联
    vec.into_iter().map(f).collect()
}
```

### 5.2 常量折叠

```rust
// const 泛型支持编译时计算
fn create_array<const N: usize>() -> [i32; N] {
    [0; N]
}

// 编译时完全确定
let arr = create_array::<5>();  // 直接生成 [0, 0, 0, 0, 0]
```

### 5.3 死代码消除

```rust
fn maybe_use<T>(use_it: bool, value: T) {
    if use_it {
        // 使用 value
    }
    // 如果 use_it 是常量 false，整个函数可能被优化掉
}

maybe_use(false, expensive_computation());  // 可能完全优化掉
```

---

## 6. 性能特性

### 6.1 零成本抽象

```rust
// 抽象前
let mut sum = 0;
for i in 0..100 {
    sum += i;
}

// 使用泛型抽象
let sum: i32 = (0..100).sum();

// 两者生成相同的机器码 - 零成本抽象
```

### 6.2 性能基准测试

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

### 6.3 性能对比表

| 特性 | 静态分发 | 动态分发 | 开销 |
|------|---------|---------|------|
| 函数调用 | 直接 | 通过 vtable | ~1-2ns |
| 内联 | 可能 | 不可能 | - |
| 代码大小 | 大 | 小 | - |
| 缓存友好 | 可能不友好 | 友好 | - |

---

## 7. 最佳实践

### 7.1 何时使用静态分发

```rust
// ✅ 性能关键路径
fn hot_path<T: Compute>(value: &T) -> i32 {
    value.compute()
}

// ✅ 库 API (让用户决定)
pub fn sort<T: Ord>(slice: &mut [T]) {
    // 每个类型生成专门版本
}

// ✅ 编译时已知类型
fn process_known(value: i32) {
    // ...
}
```

### 7.2 何时使用动态分发

```rust
// ✅ 异构集合
let shapes: Vec<Box<dyn Shape>> = vec![
    Box::new(Circle { radius: 5.0 }),
    Box::new(Rectangle { width: 10.0, height: 5.0 }),
];

// ✅ 插件系统
trait Plugin {
    fn execute(&self);
}

struct PluginManager {
    plugins: Vec<Box<dyn Plugin>>,
}

// ✅ 减少代码膨胀
fn print(values: &[&dyn Display]) {
    for value in values {
        println!("{}", value);
    }
}
```

### 7.3 代码大小优化

```rust
// 提取公共代码
fn common_logic(data: &[u8]) {
    // 不依赖类型的逻辑
}

fn process<T>(value: T)
where
    T: AsRef<[u8]>,
{
    common_logic(value.as_ref());
    // 类型特定的逻辑
}

// 减少泛型实例化
fn process_impl(data: &[u8]) {
    // 实际逻辑
}

#[inline]
fn process<T: AsRef<[u8]>>(value: T) {
    process_impl(value.as_ref());
}
```

### 7.4 编译时间优化

```rust
// 减少泛型层数
// ❌ 不好：多层泛型
fn level3<A, B, C>(a: A, b: B, c: C) -> impl Fn()
where
    A: Fn() -> B,
    B: Fn() -> C,
    C: Display,
{
    // ...
}

// ✅ 好：简化泛型
fn level1<T: Display>(value: T) {
    // ...
}
```

---

## 📚 相关参考

- [01_泛型语法参考.md](./01_泛型语法参考.md) - 泛型语法
- [../tier_04_advanced/03_零成本抽象.md](../tier_04_advanced/03_零成本抽象.md) - 零成本抽象详解
- [../tier_02_guides/05_实战模式指南.md](../tier_02_guides/05_实战模式指南.md) - 实战模式

---

**文档元信息**:

- 创建日期: 2025-10-22
- 作者: Rust-Lang Project
- 许可: MIT OR Apache-2.0
- Rust 版本: 1.90+
