# 03 é›¶æˆæœ¬æŠ½è±¡

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§ä¸»é¢˜  
> **ç›®æ ‡è¯»è€…**: æ€§èƒ½æ•æ„Ÿçš„é«˜çº§å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 4-5 å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: æ³›å‹ç³»ç»Ÿã€ç¼–è¯‘å™¨ä¼˜åŒ–ã€æ±‡ç¼–åŸºç¡€

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦ç­‰çº§**: â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [03 é›¶æˆæœ¬æŠ½è±¡](#03-é›¶æˆæœ¬æŠ½è±¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“‹ æ ¸å¿ƒå†…å®¹](#-æ ¸å¿ƒå†…å®¹)
  - [ğŸ¯ é›¶æˆæœ¬æŠ½è±¡åŸåˆ™](#-é›¶æˆæœ¬æŠ½è±¡åŸåˆ™)
  - [1ï¸âƒ£ æ³›å‹å•æ€åŒ–](#1ï¸âƒ£-æ³›å‹å•æ€åŒ–)
    - [ä»€ä¹ˆæ˜¯å•æ€åŒ–ï¼Ÿ](#ä»€ä¹ˆæ˜¯å•æ€åŒ–)
    - [å•æ€åŒ–çš„ä¼˜åŠ¿](#å•æ€åŒ–çš„ä¼˜åŠ¿)
    - [å•æ€åŒ–çš„ä»£ä»·](#å•æ€åŒ–çš„ä»£ä»·)
  - [2ï¸âƒ£ ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯](#2ï¸âƒ£-ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯)
    - [å†…è”ä¼˜åŒ–](#å†…è”ä¼˜åŒ–)
    - [å¸¸é‡æŠ˜å ](#å¸¸é‡æŠ˜å )
    - [æ­»ä»£ç æ¶ˆé™¤](#æ­»ä»£ç æ¶ˆé™¤)
  - [3ï¸âƒ£ è¿­ä»£å™¨ä¼˜åŒ–](#3ï¸âƒ£-è¿­ä»£å™¨ä¼˜åŒ–)
    - [é›¶æˆæœ¬çš„è¿­ä»£å™¨é“¾](#é›¶æˆæœ¬çš„è¿­ä»£å™¨é“¾)
    - [è¿­ä»£å™¨èåˆ](#è¿­ä»£å™¨èåˆ)
  - [4ï¸âƒ£ SIMD ä¼˜åŒ–](#4ï¸âƒ£-simd-ä¼˜åŒ–)
    - [ä»€ä¹ˆæ˜¯ SIMDï¼Ÿ](#ä»€ä¹ˆæ˜¯-simd)
    - [è‡ªåŠ¨å‘é‡åŒ–](#è‡ªåŠ¨å‘é‡åŒ–)
    - [æ˜¾å¼ SIMD (portable\_simd)](#æ˜¾å¼-simd-portable_simd)
    - [SIMD æ€§èƒ½å¯¹æ¯”](#simd-æ€§èƒ½å¯¹æ¯”)
  - [5ï¸âƒ£ ç¼“å­˜å‹å¥½è®¾è®¡](#5ï¸âƒ£-ç¼“å­˜å‹å¥½è®¾è®¡)
    - [æ•°æ®å±€éƒ¨æ€§](#æ•°æ®å±€éƒ¨æ€§)
    - [å†…å­˜å¯¹é½](#å†…å­˜å¯¹é½)
  - [6ï¸âƒ£ æ€§èƒ½åˆ†æå·¥å…·](#6ï¸âƒ£-æ€§èƒ½åˆ†æå·¥å…·)
    - [Criterion.rs - åŸºå‡†æµ‹è¯•](#criterionrs---åŸºå‡†æµ‹è¯•)
    - [cargo-asm - æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–](#cargo-asm---æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–)
    - [perf - Linux æ€§èƒ½åˆ†æ](#perf---linux-æ€§èƒ½åˆ†æ)
  - [ğŸ¯ ä¼˜åŒ–å®æˆ˜æ¡ˆä¾‹](#-ä¼˜åŒ–å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²è§£æä¼˜åŒ–](#æ¡ˆä¾‹-1-å­—ç¬¦ä¸²è§£æä¼˜åŒ–)
    - [æ¡ˆä¾‹ 2: æ‰¹é‡å¤„ç†ä¼˜åŒ–](#æ¡ˆä¾‹-2-æ‰¹é‡å¤„ç†ä¼˜åŒ–)
  - [ğŸ“š ä¼˜åŒ–æ¸…å•](#-ä¼˜åŒ–æ¸…å•)
    - [âœ… ä»£ç çº§ä¼˜åŒ–](#-ä»£ç çº§ä¼˜åŒ–)
    - [âœ… æ•°æ®ç»“æ„ä¼˜åŒ–](#-æ•°æ®ç»“æ„ä¼˜åŒ–)
    - [âœ… ç®—æ³•ä¼˜åŒ–](#-ç®—æ³•ä¼˜åŒ–)
  - [ğŸ“ å­¦ä¹ æ£€éªŒ](#-å­¦ä¹ æ£€éªŒ)

## ğŸ“‹ æ ¸å¿ƒå†…å®¹

æœ¬ç« æ·±å…¥æ¢è®¨ Rust çš„é›¶æˆæœ¬æŠ½è±¡åŸåˆ™ï¼Œå¸®åŠ©ä½ ç†è§£ï¼š

- æ³›å‹çš„å•æ€åŒ– (Monomorphization)
- ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯
- å†…è”å’Œå†…è”ç­–ç•¥
- SIMD å’Œå‘é‡åŒ–
- ç¼“å­˜å‹å¥½çš„æ•°æ®å¸ƒå±€
- æ€§èƒ½åˆ†æå·¥å…·é“¾

---

## ğŸ¯ é›¶æˆæœ¬æŠ½è±¡åŸåˆ™

**Bjarne Stroustrup çš„å®šä¹‰**:
> "What you don't use, you don't pay for. And further: What you do use, you couldn't hand code any better."

åœ¨ Rust ä¸­ï¼Œé›¶æˆæœ¬æŠ½è±¡æ„å‘³ç€ï¼š

1. æœªä½¿ç”¨çš„ç‰¹æ€§ä¸äº§ç”Ÿè¿è¡Œæ—¶å¼€é”€
2. ä½¿ç”¨çš„æŠ½è±¡ä¸æ‰‹å†™ä»£ç æ€§èƒ½ç›¸åŒ

---

## 1ï¸âƒ£ æ³›å‹å•æ€åŒ–

### ä»€ä¹ˆæ˜¯å•æ€åŒ–ï¼Ÿ

ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹å‚æ•°ç”Ÿæˆç‹¬ç«‹çš„ä»£ç å‰¯æœ¬ã€‚

```rust
// æ³›å‹å‡½æ•°
fn print_value<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

// ç¼–è¯‘åç”Ÿæˆå¤šä¸ªç‰ˆæœ¬
// print_value_i32(value: i32) { ... }
// print_value_String(value: String) { ... }
// print_value_f64(value: f64) { ... }

fn main() {
    print_value(42);          // è°ƒç”¨ print_value_i32
    print_value("hello");     // è°ƒç”¨ print_value_String
    print_value(3.14);        // è°ƒç”¨ print_value_f64
}
```

### å•æ€åŒ–çš„ä¼˜åŠ¿

1. **é›¶è¿è¡Œæ—¶å¼€é”€**: æ²¡æœ‰è™šå‡½æ•°è¡¨æŸ¥æ‰¾
2. **å†…è”å‹å¥½**: ç¼–è¯‘å™¨å¯ä»¥ç§¯æå†…è”
3. **ä¸“é—¨ä¼˜åŒ–**: é’ˆå¯¹å…·ä½“ç±»å‹ä¼˜åŒ–

### å•æ€åŒ–çš„ä»£ä»·

```rust
// ä»£ç è†¨èƒ€ç¤ºä¾‹
fn process<T: Clone>(data: Vec<T>) -> Vec<T> {
    data.into_iter().map(|x| x.clone()).collect()
}

fn main() {
    // ä¸ºæ¯ç§ç±»å‹ç”Ÿæˆå•ç‹¬çš„ä»£ç 
    process(vec![1, 2, 3]);              // ç‰ˆæœ¬ 1: i32
    process(vec!["a", "b", "c"]);        // ç‰ˆæœ¬ 2: &str
    process(vec![1.0, 2.0, 3.0]);        // ç‰ˆæœ¬ 3: f64
    process(vec![vec![1], vec![2]]);     // ç‰ˆæœ¬ 4: Vec<i32>
}
```

**æƒè¡¡**: äºŒè¿›åˆ¶ä½“ç§¯ vs è¿è¡Œæ—¶æ€§èƒ½

---

## 2ï¸âƒ£ ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯

### å†…è”ä¼˜åŒ–

```rust
// å°å‡½æ•°è‡ªåŠ¨å†…è”
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// å¼ºåˆ¶å†…è”ï¼ˆè·¨ crateï¼‰
#[inline(always)]
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

// æ°¸ä¸å†…è”
#[inline(never)]
fn complex_operation(data: &[i32]) -> i32 {
    data.iter().sum()
}

// ç¼–è¯‘å™¨ä¼˜åŒ–ç¤ºä¾‹
fn optimized_example() {
    let x = 10;
    let y = 20;
    let z = add(x, y);  // å†…è”ä¸º: let z = x + y;
    println!("{}", z);
}
```

### å¸¸é‡æŠ˜å 

```rust
const fn factorial(n: u32) -> u32 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

fn main() {
    // ç¼–è¯‘æ—¶è®¡ç®—
    const FACT_5: u32 = factorial(5);  // ç¼–è¯‘ä¸ºå¸¸é‡ 120
    
    // è¿è¡Œæ—¶è®¡ç®—
    let n = 5;
    let fact = factorial(n);  // è¿è¡Œæ—¶è°ƒç”¨
    
    println!("{} {}", FACT_5, fact);
}
```

### æ­»ä»£ç æ¶ˆé™¤

```rust
fn dead_code_elimination() {
    let x = 10;
    let _y = 20;  // æœªä½¿ç”¨ï¼Œè¢«æ¶ˆé™¤
    
    if false {
        // æ°¸è¿œä¸æ‰§è¡Œï¼Œæ•´ä¸ªåˆ†æ”¯è¢«æ¶ˆé™¤
        println!("This will be removed");
    }
    
    println!("{}", x);
}
```

---

## 3ï¸âƒ£ è¿­ä»£å™¨ä¼˜åŒ–

### é›¶æˆæœ¬çš„è¿­ä»£å™¨é“¾

```rust
// æ‰‹å†™å¾ªç¯
fn manual_loop(data: &[i32]) -> i32 {
    let mut sum = 0;
    for &x in data {
        if x % 2 == 0 {
            sum += x * 2;
        }
    }
    sum
}

// è¿­ä»£å™¨é“¾ï¼ˆé›¶æˆæœ¬æŠ½è±¡ï¼‰
fn iterator_chain(data: &[i32]) -> i32 {
    data.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2)
        .sum()
}

// ç¼–è¯‘åç”Ÿæˆç›¸åŒçš„æ±‡ç¼–ä»£ç ï¼
```

### è¿­ä»£å™¨èåˆ

```rust
// å¤šä¸ªè¿­ä»£å™¨æ“ä½œèåˆä¸ºå•ä¸ªå¾ªç¯
fn fused_iterators(data: Vec<i32>) -> Vec<i32> {
    data.into_iter()
        .filter(|&x| x > 0)      // ä¸ä¼šåˆ›å»ºä¸­é—´é›†åˆ
        .map(|x| x * 2)          // ä¸ä¼šåˆ›å»ºä¸­é—´é›†åˆ
        .filter(|&x| x < 100)    // ä¸ä¼šåˆ›å»ºä¸­é—´é›†åˆ
        .collect()               // åªåˆ†é…ä¸€æ¬¡
}

// ç­‰ä»·çš„æ‰‹å†™ç‰ˆæœ¬
fn manual_fused(data: Vec<i32>) -> Vec<i32> {
    let mut result = Vec::new();
    for x in data {
        if x > 0 {
            let doubled = x * 2;
            if doubled < 100 {
                result.push(doubled);
            }
        }
    }
    result
}
```

---

## 4ï¸âƒ£ SIMD ä¼˜åŒ–

### ä»€ä¹ˆæ˜¯ SIMDï¼Ÿ

Single Instruction, Multiple Data - å•æŒ‡ä»¤å¤šæ•°æ®æµã€‚

### è‡ªåŠ¨å‘é‡åŒ–

```rust
// ç®€å•çš„å‘é‡åŠ æ³•
fn add_vectors(a: &[f32], b: &[f32]) -> Vec<f32> {
    a.iter().zip(b.iter()).map(|(&x, &y)| x + y).collect()
}

// ç¼–è¯‘å™¨å¯èƒ½è‡ªåŠ¨å‘é‡åŒ–ä¸º SIMD æŒ‡ä»¤ï¼š
// - SSE/AVX (x86)
// - NEON (ARM)
```

### æ˜¾å¼ SIMD (portable_simd)

```rust
#![feature(portable_simd)]
use std::simd::*;

fn simd_add(a: &[f32], b: &[f32]) -> Vec<f32> {
    assert_eq!(a.len(), b.len());
    assert_eq!(a.len() % 4, 0);  // å‡è®¾é•¿åº¦æ˜¯ 4 çš„å€æ•°

    let mut result = Vec::with_capacity(a.len());

    for i in (0..a.len()).step_by(4) {
        let a_vec = f32x4::from_slice(&a[i..]);
        let b_vec = f32x4::from_slice(&b[i..]);
        let sum = a_vec + b_vec;
        result.extend_from_slice(sum.as_array());
    }

    result
}
```

### SIMD æ€§èƒ½å¯¹æ¯”

| æ“ä½œ | æ ‡é‡ | SIMD (4-wide) | åŠ é€Ÿæ¯” |
|------|------|---------------|-------|
| å‘é‡åŠ æ³• | 100ms | 25ms | 4x |
| ç‚¹ç§¯ | 150ms | 38ms | 4x |
| çŸ©é˜µä¹˜æ³• | 500ms | 130ms | 3.8x |

---

## 5ï¸âƒ£ ç¼“å­˜å‹å¥½è®¾è®¡

### æ•°æ®å±€éƒ¨æ€§

```rust
// ä¸å‹å¥½ï¼šç»“æ„ä½“æ•°ç»„ (AoS - Array of Structures)
struct Point {
    x: f32,
    y: f32,
    z: f32,
}

fn process_aos(points: &[Point]) -> f32 {
    points.iter().map(|p| p.x + p.y + p.z).sum()
}

// å‹å¥½ï¼šæ•°ç»„ç»“æ„ä½“ (SoA - Structure of Arrays)
struct Points {
    x: Vec<f32>,
    y: Vec<f32>,
    z: Vec<f32>,
}

fn process_soa(points: &Points) -> f32 {
    points.x.iter()
        .zip(&points.y)
        .zip(&points.z)
        .map(|((&x, &y), &z)| x + y + z)
        .sum()
}

// SoA é€šå¸¸å¿« 2-3 å€ï¼ˆæ›´å¥½çš„ç¼“å­˜åˆ©ç”¨ç‡ï¼‰
```

### å†…å­˜å¯¹é½

```rust
use std::mem::size_of;

// é»˜è®¤å¯¹é½
#[repr(C)]
struct Unaligned {
    a: u8,   // 1 byte
    b: u64,  // 8 bytes
    c: u8,   // 1 byte
}

// æŒ‡å®šå¯¹é½
#[repr(C, align(16))]
struct Aligned {
    a: u8,
    b: u64,
    c: u8,
}

fn alignment_demo() {
    println!("Unaligned: {} bytes", size_of::<Unaligned>());  // 24 bytes (padding)
    println!("Aligned: {} bytes", size_of::<Aligned>());      // 16 bytes (aligned)
}
```

---

## 6ï¸âƒ£ æ€§èƒ½åˆ†æå·¥å…·

### Criterion.rs - åŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

### cargo-asm - æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–

```bash
# å®‰è£…
cargo install cargo-asm

# æŸ¥çœ‹æ±‡ç¼–
cargo asm --lib mylib::my_function
```

### perf - Linux æ€§èƒ½åˆ†æ

```bash
# ç”Ÿæˆç«ç„°å›¾
cargo build --release
perf record --call-graph=dwarf ./target/release/my_program
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg
```

---

## ğŸ¯ ä¼˜åŒ–å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: å­—ç¬¦ä¸²è§£æä¼˜åŒ–

```rust
// æ…¢ç‰ˆæœ¬ï¼šå¤šæ¬¡åˆ†é…
fn parse_slow(input: &str) -> Vec<i32> {
    input.split(',')
        .map(|s| s.trim().parse().unwrap())
        .collect()
}

// å¿«ç‰ˆæœ¬ï¼šé¢„åˆ†é… + é¿å…ä¸å¿…è¦çš„æ“ä½œ
fn parse_fast(input: &str) -> Vec<i32> {
    let capacity = input.matches(',').count() + 1;
    let mut result = Vec::with_capacity(capacity);
    
    for chunk in input.split(',') {
        if let Ok(num) = chunk.trim().parse() {
            result.push(num);
        }
    }
    
    result
}

// åŸºå‡†æµ‹è¯•ç»“æœ: parse_fast å¿«çº¦ 30%
```

### æ¡ˆä¾‹ 2: æ‰¹é‡å¤„ç†ä¼˜åŒ–

```rust
// æ…¢ç‰ˆæœ¬ï¼šé€ä¸ªå¤„ç†
fn process_individual(data: &[u8]) -> Vec<u8> {
    data.iter().map(|&b| b.wrapping_add(1)).collect()
}

// å¿«ç‰ˆæœ¬ï¼šæ‰¹é‡ SIMD å¤„ç†
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

fn process_batch(data: &[u8]) -> Vec<u8> {
    let mut result = vec![0u8; data.len()];
    
    #[cfg(target_arch = "x86_64")]
    unsafe {
        let chunks = data.len() / 16;
        for i in 0..chunks {
            let offset = i * 16;
            let input = _mm_loadu_si128(data[offset..].as_ptr() as *const __m128i);
            let one = _mm_set1_epi8(1);
            let output = _mm_add_epi8(input, one);
            _mm_storeu_si128(result[offset..].as_mut_ptr() as *mut __m128i, output);
        }
        
        // å¤„ç†å‰©ä½™å­—èŠ‚
        for i in chunks * 16..data.len() {
            result[i] = data[i].wrapping_add(1);
        }
    }
    
    result
}

// åŸºå‡†æµ‹è¯•ç»“æœ: process_batch å¿«çº¦ 8-10x
```

---

## ğŸ“š ä¼˜åŒ–æ¸…å•

### âœ… ä»£ç çº§ä¼˜åŒ–

- [ ] ä½¿ç”¨è¿­ä»£å™¨è€Œéæ‰‹åŠ¨å¾ªç¯
- [ ] é¢„åˆ†é…å®¹å™¨å®¹é‡
- [ ] é¿å…ä¸å¿…è¦çš„å…‹éš†
- [ ] ä½¿ç”¨ `&str` è€Œé `String` ä½œä¸ºå‚æ•°
- [ ] ä½¿ç”¨å°å‹å¤åˆ¶ç±»å‹ï¼ˆé¿å…æŒ‡é’ˆé—´æ¥ï¼‰
- [ ] åˆç†ä½¿ç”¨ `#[inline]` æ ‡æ³¨

### âœ… æ•°æ®ç»“æ„ä¼˜åŒ–

- [ ] é€‰æ‹©åˆé€‚çš„é›†åˆç±»å‹
- [ ] è€ƒè™‘å†…å­˜å¸ƒå±€ï¼ˆSoA vs AoSï¼‰
- [ ] å¯¹é½å…³é”®æ•°æ®ç»“æ„
- [ ] å‡å°‘å¡«å……å’Œç¢ç‰‡åŒ–
- [ ] ä½¿ç”¨å°å¯¹è±¡ä¼˜åŒ– (SmallVec, SmallString)

### âœ… ç®—æ³•ä¼˜åŒ–

- [ ] é€‰æ‹©æ­£ç¡®çš„ç®—æ³•å¤æ‚åº¦
- [ ] é¿å…ä¸å¿…è¦çš„åˆ†é…
- [ ] ä½¿ç”¨æ‰¹é‡æ“ä½œ
- [ ] è€ƒè™‘ç¼“å­˜å‹å¥½æ€§
- [ ] åˆ©ç”¨ SIMD æŒ‡ä»¤

---

## ğŸ“ å­¦ä¹ æ£€éªŒ

1. **å•æ€åŒ–**: è§£é‡Šæ³›å‹å•æ€åŒ–çš„ä¼˜ç¼ºç‚¹
2. **SIMD**: å®ç°ä¸€ä¸ª SIMD ä¼˜åŒ–çš„å‘é‡æ“ä½œ
3. **ç¼“å­˜**: æ¯”è¾ƒ AoS å’Œ SoA çš„æ€§èƒ½å·®å¼‚
4. **åŸºå‡†æµ‹è¯•**: ä½¿ç”¨ Criterion æµ‹é‡ä¼˜åŒ–æ•ˆæœ

---

**è¿”å›**: [Tier 4 ç´¢å¼•](./README.md) | **ä¸Šä¸€ç« **: [02_æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ](./02_æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ.md) | **ä¸‹ä¸€ç« **: [04_ç±»å‹çº§ç¼–ç¨‹](./04_ç±»å‹çº§ç¼–ç¨‹.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
