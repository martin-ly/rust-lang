# 01 é«˜çº§ç±»å‹æŠ€å·§

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§ä¸»é¢˜  
> **ç›®æ ‡è¯»è€…**: é«˜çº§åˆ°ä¸“å®¶çº§å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 4-6 å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: å®Œæ•´çš„æ³›å‹å’Œ Trait ç³»ç»Ÿç†è§£ã€ç”Ÿå‘½å‘¨æœŸã€æ‰€æœ‰æƒç³»ç»Ÿ

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [01 é«˜çº§ç±»å‹æŠ€å·§](#01-é«˜çº§ç±»å‹æŠ€å·§)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1ï¸âƒ£ PhantomData æ·±å…¥åº”ç”¨](#1ï¸âƒ£-phantomdata-æ·±å…¥åº”ç”¨)
    - [1.1 ä»€ä¹ˆæ˜¯ PhantomDataï¼Ÿ](#11-ä»€ä¹ˆæ˜¯-phantomdata)
    - [1.2 å‹å˜ (Variance) æ§åˆ¶](#12-å‹å˜-variance-æ§åˆ¶)
    - [1.3 ç±»å‹çŠ¶æ€æ¨¡å¼](#13-ç±»å‹çŠ¶æ€æ¨¡å¼)
    - [1.4 å¹½çµç±»å‹çš„é«˜çº§åº”ç”¨](#14-å¹½çµç±»å‹çš„é«˜çº§åº”ç”¨)
  - [2ï¸âƒ£ Zero-Sized Types (ZSTs)](#2ï¸âƒ£-zero-sized-types-zsts)
    - [2.1 ZST åŸºç¡€](#21-zst-åŸºç¡€)
    - [2.2 ZST çš„æ€§èƒ½ä¼˜åŠ¿](#22-zst-çš„æ€§èƒ½ä¼˜åŠ¿)
    - [2.3 ZST åœ¨æ ‡å‡†åº“ä¸­çš„åº”ç”¨](#23-zst-åœ¨æ ‡å‡†åº“ä¸­çš„åº”ç”¨)
    - [2.4 ZST çš„é«˜çº§æŠ€å·§](#24-zst-çš„é«˜çº§æŠ€å·§)
  - [3ï¸âƒ£ ç±»å‹çŠ¶æ€æ¨¡å¼ (Typestate Pattern)](#3ï¸âƒ£-ç±»å‹çŠ¶æ€æ¨¡å¼-typestate-pattern)
    - [3.1 ä»€ä¹ˆæ˜¯ç±»å‹çŠ¶æ€æ¨¡å¼ï¼Ÿ](#31-ä»€ä¹ˆæ˜¯ç±»å‹çŠ¶æ€æ¨¡å¼)
    - [3.2 å®ç°ç¼–è¯‘æ—¶çŠ¶æ€æœº](#32-å®ç°ç¼–è¯‘æ—¶çŠ¶æ€æœº)
    - [3.3 æ„å»ºå™¨æ¨¡å¼çš„ç±»å‹å®‰å…¨ç‰ˆæœ¬](#33-æ„å»ºå™¨æ¨¡å¼çš„ç±»å‹å®‰å…¨ç‰ˆæœ¬)
    - [3.4 åè®®çŠ¶æ€ç®¡ç†](#34-åè®®çŠ¶æ€ç®¡ç†)
  - [4ï¸âƒ£ ç±»å‹å®‰å…¨ API è®¾è®¡](#4ï¸âƒ£-ç±»å‹å®‰å…¨-api-è®¾è®¡)
    - [4.1 å•ä½ç±»å‹ (Unit Types)](#41-å•ä½ç±»å‹-unit-types)
    - [4.2 New Type Pattern](#42-new-type-pattern)
    - [4.3 ç±»å‹çº§ä¸å˜é‡](#43-ç±»å‹çº§ä¸å˜é‡)
    - [4.4 ç¼–è¯‘æ—¶éªŒè¯](#44-ç¼–è¯‘æ—¶éªŒè¯)
  - [5ï¸âƒ£ ç¼–è¯‘æ—¶çŠ¶æ€æœº](#5ï¸âƒ£-ç¼–è¯‘æ—¶çŠ¶æ€æœº)
    - [5.1 çŠ¶æ€æœºåŸºç¡€](#51-çŠ¶æ€æœºåŸºç¡€)
    - [5.2 ç±»å‹çº§çŠ¶æ€è½¬æ¢](#52-ç±»å‹çº§çŠ¶æ€è½¬æ¢)
    - [5.3 å®æˆ˜æ¡ˆä¾‹ï¼šTCP è¿æ¥çŠ¶æ€](#53-å®æˆ˜æ¡ˆä¾‹tcp-è¿æ¥çŠ¶æ€)
  - [6ï¸âƒ£ ç±»å‹çº§ä¸å˜é‡ä¸è¯æ˜](#6ï¸âƒ£-ç±»å‹çº§ä¸å˜é‡ä¸è¯æ˜)
    - [6.1 ä»€ä¹ˆæ˜¯ç±»å‹çº§ä¸å˜é‡ï¼Ÿ](#61-ä»€ä¹ˆæ˜¯ç±»å‹çº§ä¸å˜é‡)
    - [6.2 ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œè¯æ˜](#62-ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œè¯æ˜)
    - [6.3 ç´¢å¼•å®‰å…¨æ€§](#63-ç´¢å¼•å®‰å…¨æ€§)
  - [ğŸ¯ å®æˆ˜é¡¹ç›®](#-å®æˆ˜é¡¹ç›®)
    - [é¡¹ç›® 1: ç±»å‹å®‰å…¨çš„ SQL æŸ¥è¯¢æ„å»ºå™¨](#é¡¹ç›®-1-ç±»å‹å®‰å…¨çš„-sql-æŸ¥è¯¢æ„å»ºå™¨)
    - [é¡¹ç›® 2: ç¼–è¯‘æ—¶éªŒè¯çš„çŠ¶æ€æœº](#é¡¹ç›®-2-ç¼–è¯‘æ—¶éªŒè¯çš„çŠ¶æ€æœº)
  - [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
  - [ğŸ” å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ“ å­¦ä¹ æ£€éªŒ](#-å­¦ä¹ æ£€éªŒ)

---

## ğŸ“– ç« èŠ‚æ¦‚è§ˆ

æœ¬ç« æ·±å…¥æ¢è®¨ Rust ç±»å‹ç³»ç»Ÿçš„é«˜çº§æŠ€å·§ï¼ŒåŒ…æ‹¬ï¼š

- **PhantomData**: æ§åˆ¶å‹å˜ã€æ ‡è®°ç”Ÿå‘½å‘¨æœŸã€å¹½çµç±»å‹
- **Zero-Sized Types**: é›¶æˆæœ¬æŠ½è±¡ã€ç¼–è¯‘æ—¶ä¼˜åŒ–
- **ç±»å‹çŠ¶æ€æ¨¡å¼**: ç¼–è¯‘æ—¶çŠ¶æ€æœºã€API å®‰å…¨æ€§
- **ç±»å‹å®‰å…¨ API**: ç¼–è¯‘æ—¶éªŒè¯ã€ä¸å˜é‡ä¿è¯
- **ç¼–è¯‘æ—¶çŠ¶æ€æœº**: çŠ¶æ€è½¬æ¢ã€åè®®å®ç°
- **ç±»å‹çº§è¯æ˜**: ä¸å˜é‡ã€å®‰å…¨æ€§ä¿è¯

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£å¹¶åº”ç”¨ PhantomData è¿›è¡Œå‹å˜æ§åˆ¶
- âœ… ä½¿ç”¨ ZST å®ç°é›¶è¿è¡Œæ—¶å¼€é”€çš„æŠ½è±¡
- âœ… è®¾è®¡ç±»å‹çŠ¶æ€æ¨¡å¼çš„ API
- âœ… å®ç°ç¼–è¯‘æ—¶éªŒè¯çš„çŠ¶æ€æœº
- âœ… æ„å»ºç±»å‹å®‰å…¨çš„ DSL
- âœ… ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œä¸å˜é‡è¯æ˜

---

## 1ï¸âƒ£ PhantomData æ·±å…¥åº”ç”¨

### 1.1 ä»€ä¹ˆæ˜¯ PhantomDataï¼Ÿ

`PhantomData<T>` æ˜¯ä¸€ä¸ªé›¶å¤§å°ç±»å‹ (ZST)ï¼Œç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨æŸä¸ªç±»å‹"æ‹¥æœ‰"ç±»å‹ `T` çš„æ•°æ®ï¼Œå³ä½¿å®ƒå®é™…ä¸Šå¹¶ä¸åŒ…å«ä»»ä½• `T` ç±»å‹çš„å€¼ã€‚

**åŸºç¡€ç¤ºä¾‹**:

```rust
use std::marker::PhantomData;

// ä¸ä½¿ç”¨ PhantomData - ç¼–è¯‘é”™è¯¯
struct Slice<'a, T> {
    start: *const T,
    end: *const T,
    // ç¼ºå°‘ç”Ÿå‘½å‘¨æœŸæ ‡è®°ï¼Œç¼–è¯‘å™¨æ— æ³•æ¨æ–­ç”Ÿå‘½å‘¨æœŸå…³ç³»
}

// æ­£ç¡®ä½¿ç”¨ PhantomData
struct Slice<'a, T> {
    start: *const T,
    end: *const T,
    phantom: PhantomData<&'a T>,  // æ ‡è®°ç”Ÿå‘½å‘¨æœŸå’Œç±»å‹
}

impl<'a, T> Slice<'a, T> {
    fn new(data: &'a [T]) -> Self {
        Slice {
            start: data.as_ptr(),
            end: unsafe { data.as_ptr().add(data.len()) },
            phantom: PhantomData,
        }
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ PhantomDataï¼Ÿ**

1. **ç”Ÿå‘½å‘¨æœŸæ ‡è®°**: å‘Šè¯‰ç¼–è¯‘å™¨è¯¥ç±»å‹ä¸æŸä¸ªç”Ÿå‘½å‘¨æœŸç›¸å…³
2. **Drop Check**: å½±å“ Drop æ£€æŸ¥çš„è¡Œä¸º
3. **å‹å˜æ§åˆ¶**: æ§åˆ¶ç±»å‹å‚æ•°çš„å‹å˜æ€§ (variance)

---

### 1.2 å‹å˜ (Variance) æ§åˆ¶

**å‹å˜ç±»å‹**:

- **åå˜ (Covariant)**: `T'` æ˜¯ `T` çš„å­ç±»å‹ â‡’ `F<T'>` æ˜¯ `F<T>` çš„å­ç±»å‹
- **é€†å˜ (Contravariant)**: `T'` æ˜¯ `T` çš„å­ç±»å‹ â‡’ `F<T>` æ˜¯ `F<T'>` çš„å­ç±»å‹  
- **ä¸å˜ (Invariant)**: æ²¡æœ‰å­ç±»å‹å…³ç³»

**PhantomData çš„å‹å˜**:

```rust
use std::marker::PhantomData;

// åå˜: PhantomData<T>
struct Covariant<T> {
    phantom: PhantomData<T>,
}

// é€†å˜: PhantomData<fn(T)>
struct Contravariant<T> {
    phantom: PhantomData<fn(T)>,
}

// ä¸å˜: PhantomData<fn(T) -> T>
struct Invariant<T> {
    phantom: PhantomData<fn(T) -> T>,
}

// åå˜: PhantomData<&'a T>
struct CovariantRef<'a, T> {
    phantom: PhantomData<&'a T>,
}

// å®é™…åº”ç”¨ç¤ºä¾‹
struct Iter<'a, T> {
    ptr: *const T,
    end: *const T,
    // å¯¹ 'a å’Œ T éƒ½æ˜¯åå˜çš„
    _marker: PhantomData<&'a T>,
}

// ç”Ÿå‘½å‘¨æœŸåå˜å…è®¸è¿™ç§è½¬æ¢
fn use_iter<'a>(data: &'a [i32]) -> Iter<'a, i32> {
    // ...
    # Iter { ptr: std::ptr::null(), end: std::ptr::null(), _marker: PhantomData }
}

fn shorten_lifetime<'a, 'b: 'a>(iter: Iter<'b, i32>) -> Iter<'a, i32> {
    // 'b: 'a æ„å‘³ç€ 'b æ¯” 'a é•¿ï¼Œåå˜å…è®¸è¿™ç§ç¼©çŸ­
    iter
}
```

---

### 1.3 ç±»å‹çŠ¶æ€æ¨¡å¼

ä½¿ç”¨ PhantomData å®ç°ç±»å‹çŠ¶æ€æ¨¡å¼ï¼Œåœ¨ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡ŒçŠ¶æ€è½¬æ¢è§„åˆ™ã€‚

**ç¤ºä¾‹: HTTP è¯·æ±‚æ„å»ºå™¨**:

```rust
use std::marker::PhantomData;

// çŠ¶æ€æ ‡è®°
struct NoMethod;
struct Method;
struct NoUrl;
struct Url;

// HTTP è¯·æ±‚æ„å»ºå™¨ï¼Œä½¿ç”¨ç±»å‹çŠ¶æ€
struct HttpRequest<M, U> {
    method: Option<String>,
    url: Option<String>,
    headers: Vec<(String, String)>,
    _marker: PhantomData<(M, U)>,
}

impl HttpRequest<NoMethod, NoUrl> {
    fn new() -> Self {
        HttpRequest {
            method: None,
            url: None,
            headers: Vec::new(),
            _marker: PhantomData,
        }
    }
}

impl<U> HttpRequest<NoMethod, U> {
    // åªæœ‰åœ¨æ²¡æœ‰è®¾ç½® method æ—¶æ‰èƒ½è°ƒç”¨
    fn method(self, method: impl Into<String>) -> HttpRequest<Method, U> {
        HttpRequest {
            method: Some(method.into()),
            url: self.url,
            headers: self.headers,
            _marker: PhantomData,
        }
    }
}

impl<M> HttpRequest<M, NoUrl> {
    // åªæœ‰åœ¨æ²¡æœ‰è®¾ç½® url æ—¶æ‰èƒ½è°ƒç”¨
    fn url(self, url: impl Into<String>) -> HttpRequest<M, Url> {
        HttpRequest {
            method: self.method,
            url: Some(url.into()),
            headers: self.headers,
            _marker: PhantomData,
        }
    }
}

impl<M, U> HttpRequest<M, U> {
    // ä»»ä½•çŠ¶æ€éƒ½å¯ä»¥æ·»åŠ  header
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
}

impl HttpRequest<Method, Url> {
    // åªæœ‰åŒæ—¶è®¾ç½®äº† method å’Œ url æ‰èƒ½å‘é€
    fn send(self) -> Result<String, Box<dyn std::error::Error>> {
        println!("Sending {} request to {}", 
            self.method.unwrap(), 
            self.url.unwrap()
        );
        Ok("Response".to_string())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let request = HttpRequest::new()
        .method("GET")
        .url("https://api.example.com")
        .header("Authorization".to_string(), "Bearer token".to_string())
        .send();

    // ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘ method
    // let request = HttpRequest::new()
    //     .url("https://api.example.com")
    //     .send();

    // ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘ url
    // let request = HttpRequest::new()
    //     .method("GET")
    //     .send();
}
```

---

### 1.4 å¹½çµç±»å‹çš„é«˜çº§åº”ç”¨

**ç¤ºä¾‹ 1: å•ä½ç±»å‹ç³»ç»Ÿ**:

```rust
use std::marker::PhantomData;

// å•ä½æ ‡è®°
struct Meter;
struct Foot;
struct Second;

// è·ç¦»ç±»å‹
struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl Distance<Meter> {
    fn new_meters(value: f64) -> Self {
        Distance {
            value,
            _unit: PhantomData,
        }
    }

    fn to_feet(self) -> Distance<Foot> {
        Distance {
            value: self.value * 3.28084,
            _unit: PhantomData,
        }
    }
}

impl Distance<Foot> {
    fn new_feet(value: f64) -> Self {
        Distance {
            value,
            _unit: PhantomData,
        }
    }

    fn to_meters(self) -> Distance<Meter> {
        Distance {
            value: self.value / 3.28084,
            _unit: PhantomData,
        }
    }
}

// é€Ÿåº¦ç±»å‹
struct Speed<DistUnit, TimeUnit> {
    value: f64,
    _units: PhantomData<(DistUnit, TimeUnit)>,
}

impl Speed<Meter, Second> {
    fn new_mps(value: f64) -> Self {
        Speed {
            value,
            _units: PhantomData,
        }
    }
}

// ç±»å‹å®‰å…¨çš„è®¡ç®—
fn calculate_time(distance: Distance<Meter>, speed: Speed<Meter, Second>) -> f64 {
    distance.value / speed.value
}

// ç¼–è¯‘æ—¶å•ä½æ£€æŸ¥
fn example() {
    let distance = Distance::new_meters(100.0);
    let speed = Speed::new_mps(10.0);
    let time = calculate_time(distance, speed);

    // ç¼–è¯‘é”™è¯¯ï¼šå•ä½ä¸åŒ¹é…
    // let distance_feet = Distance::new_feet(100.0);
    // let time = calculate_time(distance_feet, speed);
}
```

**ç¤ºä¾‹ 2: ç±»å‹çº§æƒé™ç³»ç»Ÿ**:

```rust
use std::marker::PhantomData;

// æƒé™æ ‡è®°
struct Read;
struct Write;
struct Execute;

// æ–‡ä»¶å¥æŸ„ï¼Œå¸¦æƒé™æ ‡è®°
struct File<Perm> {
    path: String,
    _permission: PhantomData<Perm>,
}

impl File<Read> {
    fn open_read(path: String) -> Self {
        File {
            path,
            _permission: PhantomData,
        }
    }

    fn read(&self) -> String {
        format!("Reading from {}", self.path)
    }

    // å‡çº§æƒé™
    fn upgrade_to_write(self) -> File<Write> {
        File {
            path: self.path,
            _permission: PhantomData,
        }
    }
}

impl File<Write> {
    fn open_write(path: String) -> Self {
        File {
            path,
            _permission: PhantomData,
        }
    }

    fn write(&mut self, data: &str) -> Result<(), String> {
        println!("Writing '{}' to {}", data, self.path);
        Ok(())
    }

    // è¯»å’Œå†™æƒé™
    fn read(&self) -> String {
        format!("Reading from {}", self.path)
    }
}

impl File<Execute> {
    fn open_execute(path: String) -> Self {
        File {
            path,
            _permission: PhantomData,
        }
    }

    fn execute(&self) -> Result<(), String> {
        println!("Executing {}", self.path);
        Ok(())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let read_file = File::open_read("data.txt".to_string());
    let content = read_file.read();

    // ç¼–è¯‘é”™è¯¯ï¼šæ²¡æœ‰å†™æƒé™
    // read_file.write("new data");

    let mut write_file = File::open_write("output.txt".to_string());
    write_file.write("Hello, World!").unwrap();

    let exe_file = File::open_execute("program.exe".to_string());
    exe_file.execute().unwrap();

    // ç¼–è¯‘é”™è¯¯ï¼šæ‰§è¡Œæƒé™ä¸èƒ½è¯»å–
    // exe_file.read();
}
```

---

## 2ï¸âƒ£ Zero-Sized Types (ZSTs)

### 2.1 ZST åŸºç¡€

**ä»€ä¹ˆæ˜¯ ZSTï¼Ÿ**

Zero-Sized Types (é›¶å¤§å°ç±»å‹) æ˜¯ç¼–è¯‘æ—¶å­˜åœ¨ä½†è¿è¡Œæ—¶ä¸å ç”¨ä»»ä½•å†…å­˜çš„ç±»å‹ã€‚

```rust
use std::mem::size_of;

// ZST ç¤ºä¾‹
struct Unit;
struct Empty {}
enum Void {}

fn zst_basics() {
    assert_eq!(size_of::<()>(), 0);
    assert_eq!(size_of::<Unit>(), 0);
    assert_eq!(size_of::<Empty>(), 0);
    assert_eq!(size_of::<Void>(), 0);
    assert_eq!(size_of::<[(); 1000]>(), 0);  // 1000 ä¸ª ZST ä»ç„¶æ˜¯ 0

    // PhantomData ä¹Ÿæ˜¯ ZST
    assert_eq!(size_of::<std::marker::PhantomData<i32>>(), 0);
}
```

**ZST çš„ç‰¹æ€§**:

1. **é›¶å†…å­˜å¼€é”€**: ä¸å ç”¨æ ˆæˆ–å †å†…å­˜
2. **ç¼–è¯‘æ—¶ä¼˜åŒ–**: å®Œå…¨ä¼˜åŒ–æ‰
3. **æ— é™æ•°é‡**: å¯ä»¥åˆ›å»ºä»»æ„å¤šä¸ªå®ä¾‹
4. **ç±»å‹åŒºåˆ†**: ä¸åŒçš„ ZST æ˜¯ä¸åŒçš„ç±»å‹

---

### 2.2 ZST çš„æ€§èƒ½ä¼˜åŠ¿

**ç¤ºä¾‹ 1: é›¶æˆæœ¬çš„è¿­ä»£å™¨é€‚é…å™¨**:

```rust
struct FilterMap<I, F> {
    iter: I,
    func: F,
}

impl<I, F, T, U> Iterator for FilterMap<I, F>
where
    I: Iterator<Item = T>,
    F: FnMut(T) -> Option<U>,
{
    type Item = U;

    fn next(&mut self) -> Option<U> {
        for item in &mut self.iter {
            if let Some(mapped) = (self.func)(item) {
                return Some(mapped);
            }
        }
        None
    }
}

// ä½¿ç”¨é—­åŒ…æ—¶ï¼Œå¦‚æœé—­åŒ…ä¸æ•è·ä»»ä½•å˜é‡ï¼ŒF æ˜¯ ZST
fn example() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // è¿™ä¸ªé—­åŒ…ä¸æ•è·ä»»ä½•å˜é‡ï¼Œæ˜¯ ZST
    let filtered = FilterMap {
        iter: numbers.into_iter(),
        func: |x| if x % 2 == 0 { Some(x * 2) } else { None },
    };

    // é›¶è¿è¡Œæ—¶å¼€é”€ï¼
    for num in filtered {
        println!("{}", num);
    }
}
```

**ç¤ºä¾‹ 2: é›¶æˆæœ¬çš„ç±»å‹æ ‡è®°**:

```rust
use std::marker::PhantomData;

// ä¸åŒçš„æ’åºç­–ç•¥
struct Ascending;
struct Descending;

struct SortedVec<T, Order> {
    data: Vec<T>,
    _order: PhantomData<Order>,
}

impl<T: Ord> SortedVec<T, Ascending> {
    fn new(mut data: Vec<T>) -> Self {
        data.sort();
        SortedVec {
            data,
            _order: PhantomData,
        }
    }

    fn binary_search(&self, value: &T) -> Result<usize, usize> {
        self.data.binary_search(value)
    }
}

impl<T: Ord> SortedVec<T, Descending> {
    fn new(mut data: Vec<T>) -> Self {
        data.sort_by(|a, b| b.cmp(a));
        SortedVec {
            data,
            _order: PhantomData,
        }
    }

    fn binary_search(&self, value: &T) -> Result<usize, usize> {
        self.data.binary_search_by(|probe| value.cmp(probe))
    }
}

// PhantomData<Order> æ˜¯ ZSTï¼Œé›¶å†…å­˜å¼€é”€ï¼
fn example() {
    let asc = SortedVec::<i32, Ascending>::new(vec![3, 1, 4, 1, 5]);
    let desc = SortedVec::<i32, Descending>::new(vec![3, 1, 4, 1, 5]);

    assert_eq!(std::mem::size_of_val(&asc), std::mem::size_of::<Vec<i32>>());
    assert_eq!(std::mem::size_of_val(&desc), std::mem::size_of::<Vec<i32>>());
}
```

---

### 2.3 ZST åœ¨æ ‡å‡†åº“ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 1: Range å’Œ RangeFrom**:

```rust
use std::ops::{Range, RangeFrom};
use std::mem::size_of;

fn std_lib_zsts() {
    // RangeFrom æ˜¯ ZSTï¼ˆåœ¨æŸäº›æƒ…å†µä¸‹ï¼‰
    let range_from = 0..;
    println!("RangeFrom size: {}", size_of::<RangeFrom<i32>>());

    // HashSet å’Œ HashMap ä½¿ç”¨ ZST ä½œä¸ºå€¼
    use std::collections::HashSet;
    // HashSet<T> å†…éƒ¨æ˜¯ HashMap<T, ()>
    // () æ˜¯ ZSTï¼Œæ‰€ä»¥åªå­˜å‚¨é”®
}
```

**ç¤ºä¾‹ 2: æ ‡å‡†åº“çš„è¿­ä»£å™¨é€‚é…å™¨**:

```rust
fn iterator_adapters() {
    let numbers = vec![1, 2, 3, 4, 5];

    // è®¸å¤šè¿­ä»£å™¨é€‚é…å™¨ä¸­çš„é—­åŒ…æ˜¯ ZST
    let result: Vec<_> = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // å¦‚æœä¸æ•è·å˜é‡ï¼Œfilter çš„é—­åŒ…æ˜¯ ZST
        .map(|&x| x * 2)            // map çš„é—­åŒ…ä¹Ÿæ˜¯ ZST
        .collect();

    // æ•´ä¸ªè¿­ä»£å™¨é“¾åœ¨ç¼–è¯‘æ—¶ä¼˜åŒ–ï¼Œå‡ ä¹é›¶å¼€é”€
}
```

---

### 2.4 ZST çš„é«˜çº§æŠ€å·§

**ç¤ºä¾‹ 1: ä½¿ç”¨ ZST å®ç°ç±»å‹çº§è®¡æ•°**:

```rust
use std::marker::PhantomData;

// ç±»å‹çº§è‡ªç„¶æ•°ï¼ˆPeano æ•°ï¼‰
struct Zero;
struct Succ<N>(PhantomData<N>);

// ç±»å‹çº§åŠ æ³•
trait Add<N> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
{
    type Output = Succ<<N as Add<M>>::Output>;
}

// ç±»å‹å®‰å…¨çš„å›ºå®šé•¿åº¦æ•°ç»„
struct Array<T, N> {
    data: Vec<T>,
    _len: PhantomData<N>,
}

type Array0<T> = Array<T, Zero>;
type Array1<T> = Array<T, Succ<Zero>>;
type Array2<T> = Array<T, Succ<Succ<Zero>>>;

impl<T> Array<T, Zero> {
    fn new() -> Self {
        Array {
            data: Vec::new(),
            _len: PhantomData,
        }
    }
}

impl<T, N> Array<T, N> {
    fn push(self, value: T) -> Array<T, Succ<N>> {
        let mut data = self.data;
        data.push(value);
        Array {
            data,
            _len: PhantomData,
        }
    }
}

impl<T, N> Array<T, Succ<N>> {
    fn pop(self) -> (T, Array<T, N>) {
        let mut data = self.data;
        let value = data.pop().unwrap();
        (value, Array {
            data,
            _len: PhantomData,
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let arr = Array::<i32, Zero>::new();  // ç©ºæ•°ç»„
    let arr = arr.push(1);                // é•¿åº¦ 1
    let arr = arr.push(2);                // é•¿åº¦ 2
    let (value, arr) = arr.pop();         // è¿”å›é•¿åº¦ 1

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½å¯¹ç©ºæ•°ç»„è°ƒç”¨ pop
    // let empty = Array::<i32, Zero>::new();
    // let (_, _) = empty.pop();
}
```

**ç¤ºä¾‹ 2: ZST æ ‡è®°å’Œæ¡ä»¶ç¼–è¯‘**:

```rust
use std::marker::PhantomData;

// å¹³å°æ ‡è®°
struct Linux;
struct Windows;
struct MacOS;

struct Platform<OS> {
    _os: PhantomData<OS>,
}

impl Platform<Linux> {
    #[cfg(target_os = "linux")]
    fn new() -> Self {
        Platform { _os: PhantomData }
    }

    fn path_separator(&self) -> char {
        '/'
    }
}

impl Platform<Windows> {
    #[cfg(target_os = "windows")]
    fn new() -> Self {
        Platform { _os: PhantomData }
    }

    fn path_separator(&self) -> char {
        '\\'
    }
}

// ä½¿ç”¨ç±»å‹ç³»ç»Ÿç¡®ä¿å¹³å°ç›¸å…³ä»£ç çš„æ­£ç¡®æ€§
fn example() {
    #[cfg(target_os = "linux")]
    let platform = Platform::<Linux>::new();

    #[cfg(target_os = "windows")]
    let platform = Platform::<Windows>::new();
}
```

---

## 3ï¸âƒ£ ç±»å‹çŠ¶æ€æ¨¡å¼ (Typestate Pattern)

### 3.1 ä»€ä¹ˆæ˜¯ç±»å‹çŠ¶æ€æ¨¡å¼ï¼Ÿ

ç±»å‹çŠ¶æ€æ¨¡å¼ä½¿ç”¨ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡ŒçŠ¶æ€è½¬æ¢è§„åˆ™ï¼Œé˜²æ­¢æ— æ•ˆçš„çŠ¶æ€è½¬æ¢ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- æ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸€ä¸ªç±»å‹
- çŠ¶æ€è½¬æ¢æ˜¯ç±»å‹è½¬æ¢
- ç¼–è¯‘å™¨ä¿è¯çŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§

---

### 3.2 å®ç°ç¼–è¯‘æ—¶çŠ¶æ€æœº

**ç¤ºä¾‹: è¿æ¥çŠ¶æ€æœº**:

```rust
use std::marker::PhantomData;

// è¿æ¥çŠ¶æ€
struct Disconnected;
struct Connecting;
struct Connected;
struct Authenticated;

// è¿æ¥å¯¹è±¡
struct Connection<State> {
    socket: Option<String>,  // ç®€åŒ–è¡¨ç¤º
    auth_token: Option<String>,
    _state: PhantomData<State>,
}

impl Connection<Disconnected> {
    fn new() -> Self {
        Connection {
            socket: None,
            auth_token: None,
            _state: PhantomData,
        }
    }

    fn connect(self, address: &str) -> Connection<Connecting> {
        println!("Connecting to {}", address);
        Connection {
            socket: Some(address.to_string()),
            auth_token: None,
            _state: PhantomData,
        }
    }
}

impl Connection<Connecting> {
    fn handshake(self) -> Result<Connection<Connected>, Connection<Disconnected>> {
        println!("Performing handshake...");
        
        if self.socket.is_some() {
            Ok(Connection {
                socket: self.socket,
                auth_token: None,
                _state: PhantomData,
            })
        } else {
            Err(Connection {
                socket: None,
                auth_token: None,
                _state: PhantomData,
            })
        }
    }
}

impl Connection<Connected> {
    fn authenticate(self, token: String) -> Connection<Authenticated> {
        println!("Authenticating...");
        Connection {
            socket: self.socket,
            auth_token: Some(token),
            _state: PhantomData,
        }
    }

    fn send_unauthenticated(&self, data: &str) {
        println!("Sending (unauthenticated): {}", data);
    }

    fn disconnect(self) -> Connection<Disconnected> {
        println!("Disconnecting...");
        Connection {
            socket: None,
            auth_token: None,
            _state: PhantomData,
        }
    }
}

impl Connection<Authenticated> {
    fn send_authenticated(&self, data: &str) {
        println!("Sending (authenticated): {}", data);
    }

    fn disconnect(self) -> Connection<Disconnected> {
        println!("Disconnecting...");
        Connection {
            socket: None,
            auth_token: None,
            _state: PhantomData,
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() -> Result<(), ()> {
    let conn = Connection::new();
    let conn = conn.connect("192.168.1.1:8080");
    let conn = conn.handshake().map_err(|_| ())?;
    
    conn.send_unauthenticated("Hello");
    
    let conn = conn.authenticate("secret_token".to_string());
    conn.send_authenticated("Sensitive data");

    // ç¼–è¯‘é”™è¯¯ï¼šæœªè®¤è¯çš„è¿æ¥ä¸èƒ½å‘é€è®¤è¯æ¶ˆæ¯
    // let conn = Connection::new().connect("...").handshake().unwrap();
    // conn.send_authenticated("This won't compile");

    Ok(())
}
```

---

### 3.3 æ„å»ºå™¨æ¨¡å¼çš„ç±»å‹å®‰å…¨ç‰ˆæœ¬

**ç¤ºä¾‹: å¼ºç±»å‹çš„ SQL æŸ¥è¯¢æ„å»ºå™¨**:

```rust
use std::marker::PhantomData;

// æ„å»ºå™¨çŠ¶æ€
struct NoSelect;
struct Select;
struct NoFrom;
struct From;
struct NoWhere;
struct Where;

// SQL æŸ¥è¯¢æ„å»ºå™¨
struct QueryBuilder<S, F, W> {
    select_clause: Option<Vec<String>>,
    from_clause: Option<String>,
    where_clause: Option<String>,
    _state: PhantomData<(S, F, W)>,
}

impl QueryBuilder<NoSelect, NoFrom, NoWhere> {
    fn new() -> Self {
        QueryBuilder {
            select_clause: None,
            from_clause: None,
            where_clause: None,
            _state: PhantomData,
        }
    }
}

impl<F, W> QueryBuilder<NoSelect, F, W> {
    fn select(self, columns: Vec<String>) -> QueryBuilder<Select, F, W> {
        QueryBuilder {
            select_clause: Some(columns),
            from_clause: self.from_clause,
            where_clause: self.where_clause,
            _state: PhantomData,
        }
    }
}

impl<S, W> QueryBuilder<S, NoFrom, W> {
    fn from(self, table: String) -> QueryBuilder<S, From, W> {
        QueryBuilder {
            select_clause: self.select_clause,
            from_clause: Some(table),
            where_clause: self.where_clause,
            _state: PhantomData,
        }
    }
}

impl<S, F> QueryBuilder<S, F, NoWhere> {
    fn where_clause(self, condition: String) -> QueryBuilder<S, F, Where> {
        QueryBuilder {
            select_clause: self.select_clause,
            from_clause: self.from_clause,
            where_clause: Some(condition),
            _state: PhantomData,
        }
    }
}

impl QueryBuilder<Select, From, NoWhere> {
    fn build(self) -> String {
        format!(
            "SELECT {} FROM {}",
            self.select_clause.unwrap().join(", "),
            self.from_clause.unwrap()
        )
    }
}

impl QueryBuilder<Select, From, Where> {
    fn build(self) -> String {
        format!(
            "SELECT {} FROM {} WHERE {}",
            self.select_clause.unwrap().join(", "),
            self.from_clause.unwrap(),
            self.where_clause.unwrap()
        )
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let query = QueryBuilder::new()
        .select(vec!["id".to_string(), "name".to_string()])
        .from("users".to_string())
        .where_clause("age > 18".to_string())
        .build();

    println!("{}", query);

    // ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘ select
    // let invalid = QueryBuilder::new()
    //     .from("users".to_string())
    //     .build();

    // ç¼–è¯‘é”™è¯¯ï¼šç¼ºå°‘ from
    // let invalid = QueryBuilder::new()
    //     .select(vec!["*".to_string()])
    //     .build();
}
```

---

### 3.4 åè®®çŠ¶æ€ç®¡ç†

**ç¤ºä¾‹: HTTP åè®®çŠ¶æ€æœº**:

```rust
use std::marker::PhantomData;

// HTTP åè®®çŠ¶æ€
struct RequestLine;
struct Headers;
struct Body;
struct Complete;

// HTTP è¯·æ±‚è§£æå™¨
struct HttpParser<State> {
    method: Option<String>,
    path: Option<String>,
    headers: Vec<(String, String)>,
    body: Option<Vec<u8>>,
    _state: PhantomData<State>,
}

impl HttpParser<RequestLine> {
    fn new() -> Self {
        HttpParser {
            method: None,
            path: None,
            headers: Vec::new(),
            body: None,
            _state: PhantomData,
        }
    }

    fn parse_request_line(
        self,
        method: String,
        path: String,
    ) -> HttpParser<Headers> {
        HttpParser {
            method: Some(method),
            path: Some(path),
            headers: self.headers,
            body: self.body,
            _state: PhantomData,
        }
    }
}

impl HttpParser<Headers> {
    fn add_header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }

    fn finish_headers(self) -> HttpParser<Body> {
        HttpParser {
            method: self.method,
            path: self.path,
            headers: self.headers,
            body: self.body,
            _state: PhantomData,
        }
    }
}

impl HttpParser<Body> {
    fn set_body(self, body: Vec<u8>) -> HttpParser<Complete> {
        HttpParser {
            method: self.method,
            path: self.path,
            headers: self.headers,
            body: Some(body),
            _state: PhantomData,
        }
    }

    fn no_body(self) -> HttpParser<Complete> {
        HttpParser {
            method: self.method,
            path: self.path,
            headers: self.headers,
            body: None,
            _state: PhantomData,
        }
    }
}

impl HttpParser<Complete> {
    fn into_request(self) -> HttpRequest {
        HttpRequest {
            method: self.method.unwrap(),
            path: self.path.unwrap(),
            headers: self.headers,
            body: self.body,
        }
    }
}

struct HttpRequest {
    method: String,
    path: String,
    headers: Vec<(String, String)>,
    body: Option<Vec<u8>>,
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let request = HttpParser::new()
        .parse_request_line("GET".to_string(), "/api/users".to_string())
        .add_header("Content-Type".to_string(), "application/json".to_string())
        .add_header("Authorization".to_string(), "Bearer token".to_string())
        .finish_headers()
        .no_body()
        .into_request();

    println!("{} {}", request.method, request.path);
}
```

---

## 4ï¸âƒ£ ç±»å‹å®‰å…¨ API è®¾è®¡

### 4.1 å•ä½ç±»å‹ (Unit Types)

ä½¿ç”¨ç±»å‹ç³»ç»Ÿå¼ºåˆ¶æ‰§è¡Œå•ä½æ­£ç¡®æ€§ã€‚

**ç¤ºä¾‹: ç‰©ç†å•ä½ç³»ç»Ÿ**:

```rust
use std::marker::PhantomData;
use std::ops::{Add, Sub, Mul, Div};

// åŸºæœ¬å•ä½
struct Meter;
struct Second;
struct Kilogram;

// å¤åˆå•ä½
struct PerSecond<T>(PhantomData<T>);
struct Squared<T>(PhantomData<T>);

// æ•°é‡ç±»å‹
#[derive(Debug, Clone, Copy)]
struct Quantity<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<U> Quantity<U> {
    fn new(value: f64) -> Self {
        Quantity {
            value,
            _unit: PhantomData,
        }
    }

    fn value(&self) -> f64 {
        self.value
    }
}

// åŒå•ä½ç›¸åŠ 
impl<U> Add for Quantity<U> {
    type Output = Quantity<U>;

    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// åŒå•ä½ç›¸å‡
impl<U> Sub for Quantity<U> {
    type Output = Quantity<U>;

    fn sub(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value - rhs.value)
    }
}

// è·ç¦» / æ—¶é—´ = é€Ÿåº¦
impl Div<Quantity<Second>> for Quantity<Meter> {
    type Output = Quantity<PerSecond<Meter>>;

    fn div(self, rhs: Quantity<Second>) -> Self::Output {
        Quantity::new(self.value / rhs.value)
    }
}

// é€Ÿåº¦ * æ—¶é—´ = è·ç¦»
impl Mul<Quantity<Second>> for Quantity<PerSecond<Meter>> {
    type Output = Quantity<Meter>;

    fn mul(self, rhs: Quantity<Second>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

// ç±»å‹åˆ«å
type Distance = Quantity<Meter>;
type Time = Quantity<Second>;
type Speed = Quantity<PerSecond<Meter>>;
type Mass = Quantity<Kilogram>;

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let d1: Distance = Quantity::new(100.0);
    let d2: Distance = Quantity::new(50.0);
    let total_distance = d1 + d2;  // OK: åŒå•ä½

    let time: Time = Quantity::new(10.0);
    let speed: Speed = d1 / time;  // OK: ç±»å‹æ­£ç¡®

    let distance = speed * time;   // OK: é€Ÿåº¦ * æ—¶é—´ = è·ç¦»

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½å°†è·ç¦»å’Œæ—¶é—´ç›¸åŠ 
    // let invalid = d1 + time;

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½å°†è·ç¦»å’Œè´¨é‡ç›¸åŠ 
    // let mass: Mass = Quantity::new(70.0);
    // let invalid = d1 + mass;

    println!("Total distance: {} m", total_distance.value());
    println!("Speed: {} m/s", speed.value());
}
```

---

### 4.2 New Type Pattern

ä½¿ç”¨ newtype æ¨¡å¼åˆ›å»ºç±»å‹å®‰å…¨çš„åŒ…è£…å™¨ã€‚

**ç¤ºä¾‹: ç”¨æˆ· ID ç±»å‹å®‰å…¨**:

```rust
// ä¸å®‰å…¨çš„æ–¹å¼ï¼šä½¿ç”¨åŸå§‹ç±»å‹
fn unsafe_example() {
    fn get_user(user_id: u64) -> String {
        format!("User {}", user_id)
    }

    fn get_post(post_id: u64) -> String {
        format!("Post {}", post_id)
    }

    let user_id = 42;
    let post_id = 123;

    // å±é™©ï¼å¯èƒ½æ··æ·† user_id å’Œ post_id
    let user = get_user(post_id);  // è¿è¡Œæ—¶é”™è¯¯
}

// å®‰å…¨çš„æ–¹å¼ï¼šä½¿ç”¨ newtype
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct UserId(u64);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct PostId(u64);

impl UserId {
    fn new(id: u64) -> Self {
        UserId(id)
    }

    fn value(&self) -> u64 {
        self.0
    }
}

impl PostId {
    fn new(id: u64) -> Self {
        PostId(id)
    }

    fn value(&self) -> u64 {
        self.0
    }
}

fn get_user(user_id: UserId) -> String {
    format!("User {}", user_id.value())
}

fn get_post(post_id: PostId) -> String {
    format!("Post {}", post_id.value())
}

// ä½¿ç”¨ç¤ºä¾‹
fn safe_example() {
    let user_id = UserId::new(42);
    let post_id = PostId::new(123);

    let user = get_user(user_id);
    let post = get_post(post_id);

    // ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // let user = get_user(post_id);

    println!("{}", user);
    println!("{}", post);
}
```

---

### 4.3 ç±»å‹çº§ä¸å˜é‡

ä½¿ç”¨ç±»å‹ç³»ç»Ÿä¿è¯ä¸å˜é‡ã€‚

**ç¤ºä¾‹: éç©ºå‘é‡**:

```rust
// ä¿è¯éç©ºçš„å‘é‡
struct NonEmptyVec<T> {
    head: T,
    tail: Vec<T>,
}

impl<T> NonEmptyVec<T> {
    // æ„é€ å‡½æ•°ä¿è¯éç©º
    fn new(head: T) -> Self {
        NonEmptyVec {
            head,
            tail: Vec::new(),
        }
    }

    fn from_vec(vec: Vec<T>) -> Option<Self> {
        let mut iter = vec.into_iter();
        iter.next().map(|head| NonEmptyVec {
            head,
            tail: iter.collect(),
        })
    }

    fn push(&mut self, value: T) {
        self.tail.push(value);
    }

    // æ°¸è¿œå¯ä»¥å®‰å…¨åœ°è·å–ç¬¬ä¸€ä¸ªå…ƒç´ 
    fn first(&self) -> &T {
        &self.head
    }

    // æ°¸è¿œå¯ä»¥å®‰å…¨åœ°è·å–æœ€åä¸€ä¸ªå…ƒç´ 
    fn last(&self) -> &T {
        self.tail.last().unwrap_or(&self.head)
    }

    fn len(&self) -> usize {
        1 + self.tail.len()
    }

    fn iter(&self) -> impl Iterator<Item = &T> {
        std::iter::once(&self.head).chain(self.tail.iter())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let vec = NonEmptyVec::new(1);
    // vec.first() æ°¸è¿œä¸ä¼š panicï¼
    println!("First: {}", vec.first());

    // æ™®é€š Vec éœ€è¦å¤„ç†ç©ºçš„æƒ…å†µ
    let empty_vec: Vec<i32> = Vec::new();
    // empty_vec.first() ä¼šè¿”å› Option

    // ä»æ™®é€š Vec åˆ›å»º
    let vec = NonEmptyVec::from_vec(vec![1, 2, 3]).unwrap();
    println!("Last: {}", vec.last());
}
```

**ç¤ºä¾‹: æ’åºä¿è¯çš„å‘é‡**:

```rust
use std::marker::PhantomData;

struct Sorted;
struct Unsorted;

struct Vector<T, State> {
    data: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> Vector<T, Unsorted> {
    fn new(data: Vec<T>) -> Self {
        Vector {
            data,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> Vector<T, Unsorted> {
    fn sort(mut self) -> Vector<T, Sorted> {
        self.data.sort();
        Vector {
            data: self.data,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> Vector<T, Sorted> {
    // åªæœ‰æ’åºçš„å‘é‡å¯ä»¥è¿›è¡ŒäºŒåˆ†æœç´¢
    fn binary_search(&self, value: &T) -> Result<usize, usize> {
        self.data.binary_search(value)
    }

    // è·å–ä¸­ä½æ•°ï¼ˆä¿è¯å­˜åœ¨ï¼‰
    fn median(&self) -> Option<&T> {
        if self.data.is_empty() {
            None
        } else {
            Some(&self.data[self.data.len() / 2])
        }
    }
}

impl<T, S> Vector<T, S> {
    fn len(&self) -> usize {
        self.data.len()
    }

    fn get(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let unsorted = Vector::new(vec![3, 1, 4, 1, 5, 9, 2, 6]);
    
    // ç¼–è¯‘é”™è¯¯ï¼šæœªæ’åºçš„å‘é‡ä¸èƒ½äºŒåˆ†æœç´¢
    // unsorted.binary_search(&4);

    let sorted = unsorted.sort();
    
    // OKï¼šæ’åºçš„å‘é‡å¯ä»¥äºŒåˆ†æœç´¢
    match sorted.binary_search(&4) {
        Ok(index) => println!("Found at index {}", index),
        Err(_) => println!("Not found"),
    }

    if let Some(median) = sorted.median() {
        println!("Median: {}", median);
    }
}
```

---

### 4.4 ç¼–è¯‘æ—¶éªŒè¯

**ç¤ºä¾‹: ç¼–è¯‘æ—¶éªŒè¯çš„æ•°ç»„ç´¢å¼•**:

```rust
use std::marker::PhantomData;

// ç±»å‹çº§è‡ªç„¶æ•°
struct Zero;
struct Succ<N>(PhantomData<N>);

// å°äºå…³ç³»
trait LessThan<N> {}

impl<N> LessThan<Succ<N>> for Zero {}
impl<N, M> LessThan<Succ<M>> for Succ<N> where N: LessThan<M> {}

// å›ºå®šé•¿åº¦æ•°ç»„ï¼Œå¸¦ç¼–è¯‘æ—¶è¾¹ç•Œæ£€æŸ¥
struct FixedArray<T, N> {
    data: Vec<T>,
    _len: PhantomData<N>,
}

impl<T, N> FixedArray<T, N> {
    // ç¼–è¯‘æ—¶éªŒè¯çš„å®‰å…¨ç´¢å¼•
    fn get<I>(&self, _index: I) -> &T
    where
        I: LessThan<N>,
    {
        // ç”±äºç±»å‹ç³»ç»Ÿä¿è¯ I < Nï¼Œè¿™é‡Œå¯ä»¥å®‰å…¨åœ°ä½¿ç”¨
        // å®é™…å®ç°éœ€è¦å°†ç±»å‹çº§æ•°å­—è½¬æ¢ä¸ºè¿è¡Œæ—¶å€¼
        unimplemented!("éœ€è¦é¢å¤–çš„ç±»å‹çº§è½¬æ¢é€»è¾‘")
    }
}

// ç±»å‹åˆ«å
type Array3<T> = FixedArray<T, Succ<Succ<Succ<Zero>>>>;

type Index0 = Zero;
type Index1 = Succ<Zero>;
type Index2 = Succ<Succ<Zero>>;

// ä½¿ç”¨ç¤ºä¾‹ï¼ˆæ¦‚å¿µæ¼”ç¤ºï¼‰
fn example() {
    // é•¿åº¦ä¸º 3 çš„æ•°ç»„
    let arr: Array3<i32> = FixedArray {
        data: vec![10, 20, 30],
        _len: PhantomData,
    };

    // OK: 0 < 3, 1 < 3, 2 < 3
    // arr.get(Index0);
    // arr.get(Index1);
    // arr.get(Index2);

    // ç¼–è¯‘é”™è¯¯: 3 ä¸å°äº 3
    // arr.get(Succ<Succ<Succ<Zero>>>);
}
```

---

## 5ï¸âƒ£ ç¼–è¯‘æ—¶çŠ¶æ€æœº

### 5.1 çŠ¶æ€æœºåŸºç¡€

çŠ¶æ€æœºæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„åŸºæœ¬æ¦‚å¿µï¼Œä½¿ç”¨ç±»å‹ç³»ç»Ÿå¯ä»¥åœ¨ç¼–è¯‘æ—¶éªŒè¯çŠ¶æ€è½¬æ¢ã€‚

**ä¼ ç»ŸçŠ¶æ€æœº vs ç±»å‹çŠ¶æ€æœº**:

```rust
// ä¼ ç»Ÿæ–¹å¼ï¼šè¿è¡Œæ—¶æ£€æŸ¥
enum State {
    Init,
    Running,
    Stopped,
}

struct RuntimeStateMachine {
    state: State,
}

impl RuntimeStateMachine {
    fn new() -> Self {
        RuntimeStateMachine { state: State::Init }
    }

    fn start(&mut self) -> Result<(), String> {
        match self.state {
            State::Init => {
                self.state = State::Running;
                Ok(())
            }
            _ => Err("Can only start from Init state".to_string()),
        }
    }

    fn stop(&mut self) -> Result<(), String> {
        match self.state {
            State::Running => {
                self.state = State::Stopped;
                Ok(())
            }
            _ => Err("Can only stop from Running state".to_string()),
        }
    }
}

// ç±»å‹çŠ¶æ€æ–¹å¼ï¼šç¼–è¯‘æ—¶æ£€æŸ¥
use std::marker::PhantomData;

struct Init;
struct Running;
struct Stopped;

struct TypeStateMachine<S> {
    _state: PhantomData<S>,
}

impl TypeStateMachine<Init> {
    fn new() -> Self {
        TypeStateMachine { _state: PhantomData }
    }

    fn start(self) -> TypeStateMachine<Running> {
        TypeStateMachine { _state: PhantomData }
    }
}

impl TypeStateMachine<Running> {
    fn stop(self) -> TypeStateMachine<Stopped> {
        TypeStateMachine { _state: PhantomData }
    }
}

// ç¼–è¯‘æ—¶é”™è¯¯ï¼Œæ— æ³•ä» Init ç›´æ¥åˆ° Stopped
// impl TypeStateMachine<Init> {
//     fn stop(self) -> TypeStateMachine<Stopped> {
//         TypeStateMachine { _state: PhantomData }
//     }
// }

fn example() {
    let machine = TypeStateMachine::new();  // Init
    let machine = machine.start();          // Running
    let machine = machine.stop();           // Stopped

    // ç¼–è¯‘é”™è¯¯ï¼šStopped çŠ¶æ€æ²¡æœ‰ start æ–¹æ³•
    // machine.start();

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½ä» Init ç›´æ¥ stop
    // let machine = TypeStateMachine::new().stop();
}
```

---

### 5.2 ç±»å‹çº§çŠ¶æ€è½¬æ¢

**ç¤ºä¾‹: çŠ¶æ€è½¬æ¢å›¾**:

```rust
use std::marker::PhantomData;

// å®šä¹‰æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€
struct Idle;
struct Preparing;
struct Ready;
struct Executing;
struct Completed;
struct Failed;

// ä»»åŠ¡çŠ¶æ€æœº
struct Task<S> {
    name: String,
    _state: PhantomData<S>,
}

// çŠ¶æ€è½¬æ¢å®ç°
impl Task<Idle> {
    fn new(name: String) -> Self {
        Task {
            name,
            _state: PhantomData,
        }
    }

    fn prepare(self) -> Task<Preparing> {
        println!("{}: Idle -> Preparing", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Preparing> {
    fn mark_ready(self) -> Task<Ready> {
        println!("{}: Preparing -> Ready", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }

    fn fail(self) -> Task<Failed> {
        println!("{}: Preparing -> Failed", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Ready> {
    fn execute(self) -> Task<Executing> {
        println!("{}: Ready -> Executing", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Executing> {
    fn complete(self) -> Task<Completed> {
        println!("{}: Executing -> Completed", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }

    fn fail(self) -> Task<Failed> {
        println!("{}: Executing -> Failed", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Completed> {
    fn get_result(&self) -> String {
        format!("{}: Task completed successfully", self.name)
    }
}

impl Task<Failed> {
    fn get_error(&self) -> String {
        format!("{}: Task failed", self.name)
    }

    fn retry(self) -> Task<Idle> {
        println!("{}: Failed -> Idle (retrying)", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    // æˆåŠŸè·¯å¾„
    let task = Task::new("Task1".to_string());
    let task = task.prepare();
    let task = task.mark_ready();
    let task = task.execute();
    let task = task.complete();
    println!("{}", task.get_result());

    // å¤±è´¥å¹¶é‡è¯•
    let task = Task::new("Task2".to_string());
    let task = task.prepare();
    let task = task.fail();
    let task = task.retry();
    let task = task.prepare().mark_ready().execute().complete();
    println!("{}", task.get_result());

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½ä» Idle ç›´æ¥æ‰§è¡Œ
    // let task = Task::new("Invalid".to_string()).execute();

    // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½é‡å¤ prepare
    // let task = Task::new("Invalid".to_string()).prepare().prepare();
}
```

---

### 5.3 å®æˆ˜æ¡ˆä¾‹ï¼šTCP è¿æ¥çŠ¶æ€

**ç¤ºä¾‹: TCP è¿æ¥ç”Ÿå‘½å‘¨æœŸ**:

```rust
use std::marker::PhantomData;
use std::net::{TcpStream, SocketAddr};
use std::io::{self, Read, Write};

// TCP è¿æ¥çŠ¶æ€
struct Closed;
struct Listening;
struct Connecting;
struct Established;
struct Closing;

// TCP è¿æ¥
struct TcpConnection<S> {
    stream: Option<TcpStream>,
    addr: Option<SocketAddr>,
    _state: PhantomData<S>,
}

impl TcpConnection<Closed> {
    fn new() -> Self {
        TcpConnection {
            stream: None,
            addr: None,
            _state: PhantomData,
        }
    }

    fn connect(self, addr: SocketAddr) -> io::Result<TcpConnection<Connecting>> {
        Ok(TcpConnection {
            stream: None,
            addr: Some(addr),
            _state: PhantomData,
        })
    }
}

impl TcpConnection<Connecting> {
    fn handshake(self) -> io::Result<TcpConnection<Established>> {
        // æ¨¡æ‹Ÿ TCP ä¸‰æ¬¡æ¡æ‰‹
        let stream = TcpStream::connect(self.addr.unwrap())?;
        
        Ok(TcpConnection {
            stream: Some(stream),
            addr: self.addr,
            _state: PhantomData,
        })
    }

    fn timeout(self) -> TcpConnection<Closed> {
        TcpConnection {
            stream: None,
            addr: None,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Established> {
    fn send(&mut self, data: &[u8]) -> io::Result<usize> {
        self.stream.as_mut().unwrap().write(data)
    }

    fn receive(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.stream.as_mut().unwrap().read(buf)
    }

    fn close(self) -> TcpConnection<Closing> {
        TcpConnection {
            stream: self.stream,
            addr: self.addr,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Closing> {
    fn finalize(self) -> TcpConnection<Closed> {
        // TCP è¿æ¥å…³é—­ï¼Œé‡Šæ”¾èµ„æº
        drop(self.stream);
        
        TcpConnection {
            stream: None,
            addr: None,
            _state: PhantomData,
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() -> io::Result<()> {
    let conn = TcpConnection::new();
    let addr: SocketAddr = "127.0.0.1:8080".parse().unwrap();
    let conn = conn.connect(addr)?;
    let mut conn = conn.handshake()?;

    conn.send(b"Hello, Server!")?;

    let mut buf = [0u8; 1024];
    let n = conn.receive(&mut buf)?;
    println!("Received: {:?}", &buf[..n]);

    let conn = conn.close();
    let _conn = conn.finalize();

    // ç¼–è¯‘é”™è¯¯ï¼šå…³é—­çš„è¿æ¥ä¸èƒ½å‘é€
    // conn.send(b"data");

    Ok(())
}
```

---

## 6ï¸âƒ£ ç±»å‹çº§ä¸å˜é‡ä¸è¯æ˜

### 6.1 ä»€ä¹ˆæ˜¯ç±»å‹çº§ä¸å˜é‡ï¼Ÿ

ç±»å‹çº§ä¸å˜é‡ä½¿ç”¨ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶ä¿è¯æŸäº›å±æ€§å§‹ç»ˆä¸ºçœŸã€‚

**ç¤ºä¾‹: å¯†ç å¼ºåº¦éªŒè¯**:

```rust
use std::marker::PhantomData;

// å¯†ç å¼ºåº¦æ ‡è®°
struct Weak;
struct Medium;
struct Strong;

// å¯†ç ç±»å‹
struct Password<Strength> {
    value: String,
    _strength: PhantomData<Strength>,
}

impl Password<Weak> {
    fn new_unchecked(value: String) -> Self {
        Password {
            value,
            _strength: PhantomData,
        }
    }

    fn validate(self) -> Result<Password<Strong>, Password<Weak>> {
        let has_upper = self.value.chars().any(|c| c.is_uppercase());
        let has_lower = self.value.chars().any(|c| c.is_lowercase());
        let has_digit = self.value.chars().any(|c| c.is_numeric());
        let is_long_enough = self.value.len() >= 8;

        if has_upper && has_lower && has_digit && is_long_enough {
            Ok(Password {
                value: self.value,
                _strength: PhantomData,
            })
        } else {
            Err(self)
        }
    }
}

impl Password<Strong> {
    // åªæœ‰å¼ºå¯†ç å¯ä»¥ç”¨äºè®¤è¯
    fn authenticate(&self, stored_hash: &str) -> bool {
        // æ¨¡æ‹Ÿå¯†ç éªŒè¯
        // hash(&self.value) == stored_hash
        true
    }

    fn value(&self) -> &str {
        &self.value
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let weak_password = Password::new_unchecked("abc".to_string());
    
    // ç¼–è¯‘é”™è¯¯ï¼šå¼±å¯†ç ä¸èƒ½ç”¨äºè®¤è¯
    // weak_password.authenticate("hash");

    let strong_password = Password::new_unchecked("Abc123456".to_string())
        .validate()
        .expect("Password is not strong enough");

    // OKï¼šå¼ºå¯†ç å¯ä»¥ç”¨äºè®¤è¯
    strong_password.authenticate("stored_hash");
}
```

---

### 6.2 ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œè¯æ˜

**ç¤ºä¾‹: ç¼–è¯‘æ—¶éªŒè¯çš„é“¾è¡¨**:

```rust
use std::marker::PhantomData;

// éç©ºè¯æ˜
struct Empty;
struct NonEmpty;

// é“¾è¡¨
struct List<T, State> {
    data: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> List<T, Empty> {
    fn new() -> Self {
        List {
            data: Vec::new(),
            _state: PhantomData,
        }
    }

    fn push(self, value: T) -> List<T, NonEmpty> {
        let mut data = self.data;
        data.push(value);
        List {
            data,
            _state: PhantomData,
        }
    }
}

impl<T> List<T, NonEmpty> {
    // ä¿è¯éç©ºï¼Œå¯ä»¥å®‰å…¨åœ°è·å–å¤´éƒ¨
    fn head(&self) -> &T {
        &self.data[0]
    }

    // ä¿è¯éç©ºï¼Œå¯ä»¥å®‰å…¨åœ°è·å–å°¾éƒ¨
    fn tail(&self) -> &[T] {
        &self.data[1..]
    }

    fn push(self, value: T) -> List<T, NonEmpty> {
        let mut data = self.data;
        data.push(value);
        List {
            data,
            _state: PhantomData,
        }
    }

    fn pop(self) -> Result<(T, List<T, NonEmpty>), List<T, Empty>> {
        let mut data = self.data;
        if let Some(value) = data.pop() {
            if data.is_empty() {
                Err(List {
                    data,
                    _state: PhantomData,
                })
            } else {
                Ok((
                    value,
                    List {
                        data,
                        _state: PhantomData,
                    },
                ))
            }
        } else {
            unreachable!("NonEmpty list cannot be empty")
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let empty = List::<i32, Empty>::new();

    // ç¼–è¯‘é”™è¯¯ï¼šç©ºåˆ—è¡¨æ²¡æœ‰ head æ–¹æ³•
    // empty.head();

    let non_empty = empty.push(1).push(2).push(3);
    
    // OKï¼šéç©ºåˆ—è¡¨å¯ä»¥å®‰å…¨åœ°è·å–å¤´éƒ¨
    println!("Head: {}", non_empty.head());
    println!("Tail: {:?}", non_empty.tail());
}
```

---

### 6.3 ç´¢å¼•å®‰å…¨æ€§

**ç¤ºä¾‹: ç¼–è¯‘æ—¶éªŒè¯çš„æ•°ç»„è®¿é—®**:

```rust
use std::marker::PhantomData;

// èŒƒå›´è¯æ˜
trait InRange<const N: usize> {}

// å®ç° InRange traitï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
// å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„ç±»å‹çº§ç¼–ç¨‹

struct Index<const I: usize>;

impl<const I: usize, const N: usize> InRange<N> for Index<I>
where
    [(); (I < N) as usize]:,  // ç¼–è¯‘æ—¶æ£€æŸ¥ I < N
{
}

struct SafeArray<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> SafeArray<T, N> {
    fn new(data: [T; N]) -> Self {
        SafeArray { data }
    }

    // ç¼–è¯‘æ—¶éªŒè¯çš„ç´¢å¼•è®¿é—®
    fn get<const I: usize>(&self) -> &T
    where
        Index<I>: InRange<N>,
    {
        &self.data[I]
    }

    // è¿è¡Œæ—¶ç´¢å¼•ï¼ˆä½¿ç”¨ Optionï¼‰
    fn get_runtime(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example() {
    let arr = SafeArray::new([1, 2, 3, 4, 5]);

    // OKï¼šç¼–è¯‘æ—¶éªŒè¯ç´¢å¼•åœ¨èŒƒå›´å†…
    let value = arr.get::<2>();  // ç´¢å¼• 2 < 5
    println!("Value at index 2: {}", value);

    // ç¼–è¯‘é”™è¯¯ï¼šç´¢å¼•è¶…å‡ºèŒƒå›´
    // let value = arr.get::<10>();  // ç´¢å¼• 10 >= 5

    // è¿è¡Œæ—¶ç´¢å¼•ï¼ˆè¿”å› Optionï¼‰
    if let Some(value) = arr.get_runtime(2) {
        println!("Value: {}", value);
    }
}
```

---

## ğŸ¯ å®æˆ˜é¡¹ç›®

### é¡¹ç›® 1: ç±»å‹å®‰å…¨çš„ SQL æŸ¥è¯¢æ„å»ºå™¨

**ç›®æ ‡**: å®ç°ä¸€ä¸ªå®Œå…¨ç±»å‹å®‰å…¨çš„ SQL æŸ¥è¯¢æ„å»ºå™¨ï¼Œåœ¨ç¼–è¯‘æ—¶éªŒè¯æŸ¥è¯¢çš„æ­£ç¡®æ€§ã€‚

**è¦æ±‚**:

1. å®ç° SELECTã€FROMã€WHEREã€JOIN ç­‰å­å¥
2. ä½¿ç”¨ç±»å‹çŠ¶æ€æ¨¡å¼å¼ºåˆ¶æ‰§è¡Œæ­£ç¡®çš„æ„å»ºé¡ºåº
3. ç¼–è¯‘æ—¶éªŒè¯åˆ—åå’Œè¡¨åçš„æ­£ç¡®æ€§
4. æ”¯æŒé“¾å¼è°ƒç”¨

**æç¤º**:

```rust
// ä¼ªä»£ç ç¤ºä¾‹
let query = QueryBuilder::new()
    .select(&["id", "name"])
    .from("users")
    .where_("age > 18")
    .join("posts", "users.id = posts.user_id")
    .build();
```

---

### é¡¹ç›® 2: ç¼–è¯‘æ—¶éªŒè¯çš„çŠ¶æ€æœº

**ç›®æ ‡**: å®ç°ä¸€ä¸ªé€šç”¨çš„çŠ¶æ€æœºæ¡†æ¶ï¼Œåœ¨ç¼–è¯‘æ—¶éªŒè¯çŠ¶æ€è½¬æ¢ã€‚

**è¦æ±‚**:

1. æ”¯æŒå®šä¹‰ä»»æ„çŠ¶æ€å’Œè½¬æ¢
2. ç¼–è¯‘æ—¶éªŒè¯æ‰€æœ‰çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
3. æ”¯æŒçŠ¶æ€è½¬æ¢çš„å›è°ƒå‡½æ•°
4. é›¶è¿è¡Œæ—¶å¼€é”€

**æç¤º**:

```rust
// ä¼ªä»£ç ç¤ºä¾‹
define_state_machine! {
    states: [Init, Running, Stopped, Error],
    transitions: [
        Init -> Running,
        Running -> Stopped,
        Running -> Error,
        Error -> Init,
    ]
}
```

---

## ğŸ“Š æ€§èƒ½åˆ†æ

**ZST çš„æ€§èƒ½ä¼˜åŠ¿**:

| ç‰¹æ€§ | ä¼ ç»Ÿæ–¹å¼ | ZST æ–¹å¼ | æ€§èƒ½æå‡ |
|------|---------|---------|---------|
| å†…å­˜å ç”¨ | å®é™…ç±»å‹å¤§å° | 0 å­—èŠ‚ | 100% |
| è¿è¡Œæ—¶æ£€æŸ¥ | éœ€è¦ | ç¼–è¯‘æ—¶ä¼˜åŒ–æ‰ | æ¶ˆé™¤å¼€é”€ |
| çŠ¶æ€éªŒè¯ | è¿è¡Œæ—¶ | ç¼–è¯‘æ—¶ | é›¶è¿è¡Œæ—¶æˆæœ¬ |
| ç±»å‹æ ‡è®° | éœ€è¦å­—æ®µ | PhantomData (0 å­—èŠ‚) | 100% |

**Benchmark ç¤ºä¾‹**:

```rust
#[cfg(test)]
mod benches {
    use super::*;
    use std::time::Instant;

    #[test]
    fn benchmark_zst_vs_traditional() {
        // ä¼ ç»Ÿæ–¹å¼ï¼šè¿è¡Œæ—¶çŠ¶æ€æ£€æŸ¥
        let start = Instant::now();
        for _ in 0..1_000_000 {
            let mut machine = RuntimeStateMachine::new();
            machine.start().unwrap();
            machine.stop().unwrap();
        }
        let runtime_duration = start.elapsed();

        // ZST æ–¹å¼ï¼šç¼–è¯‘æ—¶çŠ¶æ€æ£€æŸ¥
        let start = Instant::now();
        for _ in 0..1_000_000 {
            let machine = TypeStateMachine::new();
            let machine = machine.start();
            let _machine = machine.stop();
        }
        let compile_time_duration = start.elapsed();

        println!("Runtime check: {:?}", runtime_duration);
        println!("Compile-time check: {:?}", compile_time_duration);
        println!(
            "Speedup: {:.2}x",
            runtime_duration.as_secs_f64() / compile_time_duration.as_secs_f64()
        );
    }
}
```

---

## ğŸ” å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

**é™·é˜± 1: Drop Check é—®é¢˜**:

```rust
use std::marker::PhantomData;

// é”™è¯¯ï¼šDrop check å¤±è´¥
struct Wrapper<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a T>,  // ä¸å¤Ÿï¼Œéœ€è¦ PhantomData<&'a mut T>
}

// æ­£ç¡®
struct WrapperCorrect<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a mut T>,  // å‘Šè¯‰ç¼–è¯‘å™¨æˆ‘ä»¬å¯èƒ½ä¼š drop T
}
```

**é™·é˜± 2: å‹å˜é—®é¢˜**:

```rust
// é—®é¢˜ï¼šä¸å½“çš„å‹å˜
struct Container<T> {
    value: *const T,
    _marker: PhantomData<T>,  // åå˜ï¼Œä½†æŒ‡é’ˆä¸æ˜¯
}

// è§£å†³ï¼šä½¿ç”¨æ­£ç¡®çš„å‹å˜
struct ContainerFixed<T> {
    value: *const T,
    _marker: PhantomData<*const T>,  // ä¸æŒ‡é’ˆçš„å‹å˜ä¸€è‡´
}
```

**é™·é˜± 3: è¿‡åº¦ä½¿ç”¨ç±»å‹çŠ¶æ€**:

```rust
// ä¸å¥½ï¼šè¿‡åº¦ä½¿ç”¨ç±»å‹çŠ¶æ€
struct OverlyComplex<S1, S2, S3, S4, S5> {
    // 5ä¸ªçŠ¶æ€å‚æ•°ï¼Œéš¾ä»¥ç»´æŠ¤
    _state: PhantomData<(S1, S2, S3, S4, S5)>,
}

// å¥½ï¼šåˆç†åˆ†ç»„çŠ¶æ€
struct Reasonable<MainState, SubState> {
    // åªä¿ç•™å¿…è¦çš„çŠ¶æ€
    _state: PhantomData<(MainState, SubState)>,
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

**æ¨èæ–‡ç« **:

1. [Phantom Types in Rust](https://doc.rust-lang.org/nomicon/phantom-data.html)
2. [The Typestate Pattern in Rust](http://cliffle.com/blog/rust-typestate/)
3. [Zero-Sized Types in Rust](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)
4. [Advanced Compile-Time Features](https://github.com/dtolnay/case-studies)

**ç›¸å…³åº“**:

- [`typed-builder`](https://crates.io/crates/typed-builder) - ç±»å‹å®‰å…¨çš„æ„å»ºå™¨
- [`state_machine_future`](https://crates.io/crates/state_machine_future) - çŠ¶æ€æœºæ¡†æ¶
- [`phantom-type`](https://crates.io/crates/phantom-type) - å¹½çµç±»å‹å·¥å…·

**å­¦æœ¯è®ºæ–‡**:

- "Type-State: A Programming Language Concept for Enhancing Software Reliability" (Strom & Yemini, 1986)
- "Phantom Types and Subtyping" (Leijen & Meijer, 1999)

---

## ğŸ“ å­¦ä¹ æ£€éªŒ

å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œè¯·å›ç­”ä»¥ä¸‹é—®é¢˜ï¼š

1. **PhantomData**:
   - è§£é‡Š PhantomData çš„ä¸‰ç§å‹å˜ç±»å‹
   - ä¸ºä»€ä¹ˆéœ€è¦ PhantomDataï¼Ÿ
   - å¦‚ä½•ä½¿ç”¨ PhantomData æ§åˆ¶ Drop checkï¼Ÿ

2. **ZST**:
   - åˆ—ä¸¾ä¸‰ä¸ª ZST çš„å®é™…åº”ç”¨
   - è§£é‡Šä¸ºä»€ä¹ˆ ZST èƒ½å¸¦æ¥æ€§èƒ½ä¼˜åŠ¿
   - ZST åœ¨æ ‡å‡†åº“ä¸­çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ

3. **ç±»å‹çŠ¶æ€æ¨¡å¼**:
   - å®ç°ä¸€ä¸ªç®€å•çš„æ–‡ä»¶çŠ¶æ€æœºï¼ˆæ‰“å¼€ã€è¯»å–ã€å†™å…¥ã€å…³é—­ï¼‰
   - è§£é‡Šç±»å‹çŠ¶æ€æ¨¡å¼ç›¸æ¯”è¿è¡Œæ—¶æ£€æŸ¥çš„ä¼˜åŠ¿
   - ä½•æ—¶åº”è¯¥ä½¿ç”¨ç±»å‹çŠ¶æ€æ¨¡å¼ï¼Ÿ

4. **ç±»å‹çº§ä¸å˜é‡**:
   - å¦‚ä½•ä½¿ç”¨ç±»å‹ç³»ç»Ÿä¿è¯éç©ºæ€§ï¼Ÿ
   - è§£é‡Š NewType æ¨¡å¼çš„ä½œç”¨
   - å®ç°ä¸€ä¸ªç¼–è¯‘æ—¶éªŒè¯çš„å•ä½ç±»å‹ç³»ç»Ÿ

**å®è·µç»ƒä¹ **:

1. å®ç°ä¸€ä¸ªç±»å‹å®‰å…¨çš„HTTP å®¢æˆ·ç«¯ï¼Œä½¿ç”¨ç±»å‹çŠ¶æ€æ¨¡å¼
2. åˆ›å»ºä¸€ä¸ªé›¶å¤§å°çš„è¿­ä»£å™¨é€‚é…å™¨
3. è®¾è®¡ä¸€ä¸ªç¼–è¯‘æ—¶éªŒè¯çš„é…ç½®æ„å»ºå™¨
4. å®ç°ä¸€ä¸ªç±»å‹å®‰å…¨çš„çŠ¶æ€æœºæ¡†æ¶

---

**è¿”å›**: [Tier 4 ç´¢å¼•](./README.md) | **ä¸‹ä¸€ç« **: [02_æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ](./02_æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
