# 01 高级类型技巧

> **文档类型**: Tier 4 - 高级主题
> **目标读者**: 高级到专家级开发者
> **预计学习时间**: 4-6 小时
> **前置知识**: 完整的泛型和 Trait 系统理解、生命周期、所有权系统

**最后更新**: 2025-12-11
**适用版本**: Rust 1.92.0+
**难度等级**: ⭐⭐⭐⭐⭐

---

## 📋 目录

- [01 高级类型技巧](#01-高级类型技巧)
  - [📋 目录](#-目录)
  - [📖 章节概览](#-章节概览)
  - [🎯 学习目标](#-学习目标)
  - [1️⃣ PhantomData 深入应用](#1️⃣-phantomdata-深入应用)
    - [1.1 什么是 PhantomData？](#11-什么是-phantomdata)
    - [1.2 型变 (Variance) 控制](#12-型变-variance-控制)
    - [1.3 类型状态模式](#13-类型状态模式)
    - [1.4 幽灵类型的高级应用](#14-幽灵类型的高级应用)
  - [2️⃣ Zero-Sized Types (ZSTs)](#2️⃣-zero-sized-types-zsts)
    - [2.1 ZST 基础](#21-zst-基础)
    - [2.2 ZST 的性能优势](#22-zst-的性能优势)
    - [2.3 ZST 在标准库中的应用](#23-zst-在标准库中的应用)
    - [2.4 ZST 的高级技巧](#24-zst-的高级技巧)
  - [3️⃣ 类型状态模式 (Typestate Pattern)](#3️⃣-类型状态模式-typestate-pattern)
    - [3.1 什么是类型状态模式？](#31-什么是类型状态模式)
    - [3.2 实现编译时状态机](#32-实现编译时状态机)
    - [3.3 构建器模式的类型安全版本](#33-构建器模式的类型安全版本)
    - [3.4 协议状态管理](#34-协议状态管理)
  - [4️⃣ 类型安全 API 设计](#4️⃣-类型安全-api-设计)
    - [4.1 单位类型 (Unit Types)](#41-单位类型-unit-types)
    - [4.2 New Type Pattern](#42-new-type-pattern)
    - [4.3 类型级不变量](#43-类型级不变量)
    - [4.4 编译时验证](#44-编译时验证)
  - [5️⃣ 编译时状态机](#5️⃣-编译时状态机)
    - [5.1 状态机基础](#51-状态机基础)
    - [5.2 类型级状态转换](#52-类型级状态转换)
    - [5.3 实战案例：TCP 连接状态](#53-实战案例tcp-连接状态)
  - [6️⃣ 类型级不变量与证明](#6️⃣-类型级不变量与证明)
    - [6.1 什么是类型级不变量？](#61-什么是类型级不变量)
    - [6.2 使用类型系统进行证明](#62-使用类型系统进行证明)
    - [6.3 索引安全性](#63-索引安全性)
  - [🎯 实战项目](#-实战项目)
    - [项目 1: 类型安全的 SQL 查询构建器](#项目-1-类型安全的-sql-查询构建器)
    - [项目 2: 编译时验证的状态机](#项目-2-编译时验证的状态机)
  - [📊 性能分析](#-性能分析)
  - [🔍 常见陷阱与解决方案](#-常见陷阱与解决方案)
  - [📚 延伸阅读](#-延伸阅读)
  - [🎓 学习检验](#-学习检验)

---

## 📖 章节概览

本章深入探讨 Rust 类型系统的高级技巧，包括：

- **PhantomData**: 控制型变、标记生命周期、幽灵类型
- **Zero-Sized Types**: 零成本抽象、编译时优化
- **类型状态模式**: 编译时状态机、API 安全性
- **类型安全 API**: 编译时验证、不变量保证
- **编译时状态机**: 状态转换、协议实现
- **类型级证明**: 不变量、安全性保证

---

## 🎯 学习目标

完成本章学习后，你将能够：

- ✅ 理解并应用 PhantomData 进行型变控制
- ✅ 使用 ZST 实现零运行时开销的抽象
- ✅ 设计类型状态模式的 API
- ✅ 实现编译时验证的状态机
- ✅ 构建类型安全的 DSL
- ✅ 使用类型系统进行不变量证明

---

## 1️⃣ PhantomData 深入应用

### 1.1 什么是 PhantomData？

`PhantomData<T>` 是一个零大小类型 (ZST)，用于告诉编译器某个类型"拥有"类型 `T` 的数据，即使它实际上并不包含任何 `T` 类型的值。

**基础示例**:

```rust
use std::marker::PhantomData;

// 不使用 PhantomData - 编译错误
struct Slice<'a, T> {
    start: *const T,
    end: *const T,
    // 缺少生命周期标记，编译器无法推断生命周期关系
}

// 正确使用 PhantomData
struct Slice<'a, T> {
    start: *const T,
    end: *const T,
    phantom: PhantomData<&'a T>,  // 标记生命周期和类型
}

impl<'a, T> Slice<'a, T> {
    fn new(data: &'a [T]) -> Self {
        Slice {
            start: data.as_ptr(),
            end: unsafe { data.as_ptr().add(data.len()) },
            phantom: PhantomData,
        }
    }
}
```

**为什么需要 PhantomData？**

1. **生命周期标记**: 告诉编译器该类型与某个生命周期相关
2. **Drop Check**: 影响 Drop 检查的行为
3. **型变控制**: 控制类型参数的型变性 (variance)

---

### 1.2 型变 (Variance) 控制

**型变类型**:

- **协变 (Covariant)**: `T'` 是 `T` 的子类型 ⇒ `F<T'>` 是 `F<T>` 的子类型
- **逆变 (Contravariant)**: `T'` 是 `T` 的子类型 ⇒ `F<T>` 是 `F<T'>` 的子类型
- **不变 (Invariant)**: 没有子类型关系

**PhantomData 的型变**:

```rust
use std::marker::PhantomData;

// 协变: PhantomData<T>
struct Covariant<T> {
    phantom: PhantomData<T>,
}

// 逆变: PhantomData<fn(T)>
struct Contravariant<T> {
    phantom: PhantomData<fn(T)>,
}

// 不变: PhantomData<fn(T) -> T>
struct Invariant<T> {
    phantom: PhantomData<fn(T) -> T>,
}

// 协变: PhantomData<&'a T>
struct CovariantRef<'a, T> {
    phantom: PhantomData<&'a T>,
}

// 实际应用示例
struct Iter<'a, T> {
    ptr: *const T,
    end: *const T,
    // 对 'a 和 T 都是协变的
    _marker: PhantomData<&'a T>,
}

// 生命周期协变允许这种转换
fn use_iter<'a>(data: &'a [i32]) -> Iter<'a, i32> {
    // ...
    # Iter { ptr: std::ptr::null(), end: std::ptr::null(), _marker: PhantomData }
}

fn shorten_lifetime<'a, 'b: 'a>(iter: Iter<'b, i32>) -> Iter<'a, i32> {
    // 'b: 'a 意味着 'b 比 'a 长，协变允许这种缩短
    iter
}
```

---

### 1.3 类型状态模式

使用 PhantomData 实现类型状态模式，在编译时强制执行状态转换规则。

**示例: HTTP 请求构建器**:

```rust
use std::marker::PhantomData;

// 状态标记
struct NoMethod;
struct Method;
struct NoUrl;
struct Url;

// HTTP 请求构建器，使用类型状态
struct HttpRequest<M, U> {
    method: Option<String>,
    url: Option<String>,
    headers: Vec<(String, String)>,
    _marker: PhantomData<(M, U)>,
}

impl HttpRequest<NoMethod, NoUrl> {
    fn new() -> Self {
        HttpRequest {
            method: None,
            url: None,
            headers: Vec::new(),
            _marker: PhantomData,
        }
    }
}

impl<U> HttpRequest<NoMethod, U> {
    // 只有在没有设置 method 时才能调用
    fn method(self, method: impl Into<String>) -> HttpRequest<Method, U> {
        HttpRequest {
            method: Some(method.into()),
            url: self.url,
            headers: self.headers,
            _marker: PhantomData,
        }
    }
}

impl<M> HttpRequest<M, NoUrl> {
    // 只有在没有设置 url 时才能调用
    fn url(self, url: impl Into<String>) -> HttpRequest<M, Url> {
        HttpRequest {
            method: self.method,
            url: Some(url.into()),
            headers: self.headers,
            _marker: PhantomData,
        }
    }
}

impl<M, U> HttpRequest<M, U> {
    // 任何状态都可以添加 header
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
}

impl HttpRequest<Method, Url> {
    // 只有同时设置了 method 和 url 才能发送
    fn send(self) -> Result<String, Box<dyn std::error::Error>> {
        println!("Sending {} request to {}",
            self.method.unwrap(),
            self.url.unwrap()
        );
        Ok("Response".to_string())
    }
}

// 使用示例
fn example() {
    let request = HttpRequest::new()
        .method("GET")
        .url("https://api.example.com")
        .header("Authorization".to_string(), "Bearer token".to_string())
        .send();

    // 编译错误：缺少 method
    // let request = HttpRequest::new()
    //     .url("https://api.example.com")
    //     .send();

    // 编译错误：缺少 url
    // let request = HttpRequest::new()
    //     .method("GET")
    //     .send();
}
```

---

### 1.4 幽灵类型的高级应用

**示例 1: 单位类型系统**:

```rust
use std::marker::PhantomData;

// 单位标记
struct Meter;
struct Foot;
struct Second;

// 距离类型
struct Distance<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl Distance<Meter> {
    fn new_meters(value: f64) -> Self {
        Distance {
            value,
            _unit: PhantomData,
        }
    }

    fn to_feet(self) -> Distance<Foot> {
        Distance {
            value: self.value * 3.28084,
            _unit: PhantomData,
        }
    }
}

impl Distance<Foot> {
    fn new_feet(value: f64) -> Self {
        Distance {
            value,
            _unit: PhantomData,
        }
    }

    fn to_meters(self) -> Distance<Meter> {
        Distance {
            value: self.value / 3.28084,
            _unit: PhantomData,
        }
    }
}

// 速度类型
struct Speed<DistUnit, TimeUnit> {
    value: f64,
    _units: PhantomData<(DistUnit, TimeUnit)>,
}

impl Speed<Meter, Second> {
    fn new_mps(value: f64) -> Self {
        Speed {
            value,
            _units: PhantomData,
        }
    }
}

// 类型安全的计算
fn calculate_time(distance: Distance<Meter>, speed: Speed<Meter, Second>) -> f64 {
    distance.value / speed.value
}

// 编译时单位检查
fn example() {
    let distance = Distance::new_meters(100.0);
    let speed = Speed::new_mps(10.0);
    let time = calculate_time(distance, speed);

    // 编译错误：单位不匹配
    // let distance_feet = Distance::new_feet(100.0);
    // let time = calculate_time(distance_feet, speed);
}
```

**示例 2: 类型级权限系统**:

```rust
use std::marker::PhantomData;

// 权限标记
struct Read;
struct Write;
struct Execute;

// 文件句柄，带权限标记
struct File<Perm> {
    path: String,
    _permission: PhantomData<Perm>,
}

impl File<Read> {
    fn open_read(path: String) -> Self {
        File {
            path,
            _permission: PhantomData,
        }
    }

    fn read(&self) -> String {
        format!("Reading from {}", self.path)
    }

    // 升级权限
    fn upgrade_to_write(self) -> File<Write> {
        File {
            path: self.path,
            _permission: PhantomData,
        }
    }
}

impl File<Write> {
    fn open_write(path: String) -> Self {
        File {
            path,
            _permission: PhantomData,
        }
    }

    fn write(&mut self, data: &str) -> Result<(), String> {
        println!("Writing '{}' to {}", data, self.path);
        Ok(())
    }

    // 读和写权限
    fn read(&self) -> String {
        format!("Reading from {}", self.path)
    }
}

impl File<Execute> {
    fn open_execute(path: String) -> Self {
        File {
            path,
            _permission: PhantomData,
        }
    }

    fn execute(&self) -> Result<(), String> {
        println!("Executing {}", self.path);
        Ok(())
    }
}

// 使用示例
fn example() {
    let read_file = File::open_read("data.txt".to_string());
    let content = read_file.read();

    // 编译错误：没有写权限
    // read_file.write("new data");

    let mut write_file = File::open_write("output.txt".to_string());
    write_file.write("Hello, World!").unwrap();

    let exe_file = File::open_execute("program.exe".to_string());
    exe_file.execute().unwrap();

    // 编译错误：执行权限不能读取
    // exe_file.read();
}
```

---

## 2️⃣ Zero-Sized Types (ZSTs)

### 2.1 ZST 基础

**什么是 ZST？**

Zero-Sized Types (零大小类型) 是编译时存在但运行时不占用任何内存的类型。

```rust
use std::mem::size_of;

// ZST 示例
struct Unit;
struct Empty {}
enum Void {}

fn zst_basics() {
    assert_eq!(size_of::<()>(), 0);
    assert_eq!(size_of::<Unit>(), 0);
    assert_eq!(size_of::<Empty>(), 0);
    assert_eq!(size_of::<Void>(), 0);
    assert_eq!(size_of::<[(); 1000]>(), 0);  // 1000 个 ZST 仍然是 0

    // PhantomData 也是 ZST
    assert_eq!(size_of::<std::marker::PhantomData<i32>>(), 0);
}
```

**ZST 的特性**:

1. **零内存开销**: 不占用栈或堆内存
2. **编译时优化**: 完全优化掉
3. **无限数量**: 可以创建任意多个实例
4. **类型区分**: 不同的 ZST 是不同的类型

---

### 2.2 ZST 的性能优势

**示例 1: 零成本的迭代器适配器**:

```rust
struct FilterMap<I, F> {
    iter: I,
    func: F,
}

impl<I, F, T, U> Iterator for FilterMap<I, F>
where
    I: Iterator<Item = T>,
    F: FnMut(T) -> Option<U>,
{
    type Item = U;

    fn next(&mut self) -> Option<U> {
        for item in &mut self.iter {
            if let Some(mapped) = (self.func)(item) {
                return Some(mapped);
            }
        }
        None
    }
}

// 使用闭包时，如果闭包不捕获任何变量，F 是 ZST
fn example() {
    let numbers = vec![1, 2, 3, 4, 5];

    // 这个闭包不捕获任何变量，是 ZST
    let filtered = FilterMap {
        iter: numbers.into_iter(),
        func: |x| if x % 2 == 0 { Some(x * 2) } else { None },
    };

    // 零运行时开销！
    for num in filtered {
        println!("{}", num);
    }
}
```

**示例 2: 零成本的类型标记**:

```rust
use std::marker::PhantomData;

// 不同的排序策略
struct Ascending;
struct Descending;

struct SortedVec<T, Order> {
    data: Vec<T>,
    _order: PhantomData<Order>,
}

impl<T: Ord> SortedVec<T, Ascending> {
    fn new(mut data: Vec<T>) -> Self {
        data.sort();
        SortedVec {
            data,
            _order: PhantomData,
        }
    }

    fn binary_search(&self, value: &T) -> Result<usize, usize> {
        self.data.binary_search(value)
    }
}

impl<T: Ord> SortedVec<T, Descending> {
    fn new(mut data: Vec<T>) -> Self {
        data.sort_by(|a, b| b.cmp(a));
        SortedVec {
            data,
            _order: PhantomData,
        }
    }

    fn binary_search(&self, value: &T) -> Result<usize, usize> {
        self.data.binary_search_by(|probe| value.cmp(probe))
    }
}

// PhantomData<Order> 是 ZST，零内存开销！
fn example() {
    let asc = SortedVec::<i32, Ascending>::new(vec![3, 1, 4, 1, 5]);
    let desc = SortedVec::<i32, Descending>::new(vec![3, 1, 4, 1, 5]);

    assert_eq!(std::mem::size_of_val(&asc), std::mem::size_of::<Vec<i32>>());
    assert_eq!(std::mem::size_of_val(&desc), std::mem::size_of::<Vec<i32>>());
}
```

---

### 2.3 ZST 在标准库中的应用

**示例 1: Range 和 RangeFrom**:

```rust
use std::ops::{Range, RangeFrom};
use std::mem::size_of;

fn std_lib_zsts() {
    // RangeFrom 是 ZST（在某些情况下）
    let range_from = 0..;
    println!("RangeFrom size: {}", size_of::<RangeFrom<i32>>());

    // HashSet 和 HashMap 使用 ZST 作为值
    use std::collections::HashSet;
    // HashSet<T> 内部是 HashMap<T, ()>
    // () 是 ZST，所以只存储键
}
```

**示例 2: 标准库的迭代器适配器**:

```rust
fn iterator_adapters() {
    let numbers = vec![1, 2, 3, 4, 5];

    // 许多迭代器适配器中的闭包是 ZST
    let result: Vec<_> = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // 如果不捕获变量，filter 的闭包是 ZST
        .map(|&x| x * 2)            // map 的闭包也是 ZST
        .collect();

    // 整个迭代器链在编译时优化，几乎零开销
}
```

---

### 2.4 ZST 的高级技巧

**示例 1: 使用 ZST 实现类型级计数**:

```rust
use std::marker::PhantomData;

// 类型级自然数（Peano 数）
struct Zero;
struct Succ<N>(PhantomData<N>);

// 类型级加法
trait Add<N> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
{
    type Output = Succ<<N as Add<M>>::Output>;
}

// 类型安全的固定长度数组
struct Array<T, N> {
    data: Vec<T>,
    _len: PhantomData<N>,
}

type Array0<T> = Array<T, Zero>;
type Array1<T> = Array<T, Succ<Zero>>;
type Array2<T> = Array<T, Succ<Succ<Zero>>>;

impl<T> Array<T, Zero> {
    fn new() -> Self {
        Array {
            data: Vec::new(),
            _len: PhantomData,
        }
    }
}

impl<T, N> Array<T, N> {
    fn push(self, value: T) -> Array<T, Succ<N>> {
        let mut data = self.data;
        data.push(value);
        Array {
            data,
            _len: PhantomData,
        }
    }
}

impl<T, N> Array<T, Succ<N>> {
    fn pop(self) -> (T, Array<T, N>) {
        let mut data = self.data;
        let value = data.pop().unwrap();
        (value, Array {
            data,
            _len: PhantomData,
        })
    }
}

// 使用示例
fn example() {
    let arr = Array::<i32, Zero>::new();  // 空数组
    let arr = arr.push(1);                // 长度 1
    let arr = arr.push(2);                // 长度 2
    let (value, arr) = arr.pop();         // 返回长度 1

    // 编译错误：不能对空数组调用 pop
    // let empty = Array::<i32, Zero>::new();
    // let (_, _) = empty.pop();
}
```

**示例 2: ZST 标记和条件编译**:

```rust
use std::marker::PhantomData;

// 平台标记
struct Linux;
struct Windows;
struct MacOS;

struct Platform<OS> {
    _os: PhantomData<OS>,
}

impl Platform<Linux> {
    #[cfg(target_os = "linux")]
    fn new() -> Self {
        Platform { _os: PhantomData }
    }

    fn path_separator(&self) -> char {
        '/'
    }
}

impl Platform<Windows> {
    #[cfg(target_os = "windows")]
    fn new() -> Self {
        Platform { _os: PhantomData }
    }

    fn path_separator(&self) -> char {
        '\\'
    }
}

// 使用类型系统确保平台相关代码的正确性
fn example() {
    #[cfg(target_os = "linux")]
    let platform = Platform::<Linux>::new();

    #[cfg(target_os = "windows")]
    let platform = Platform::<Windows>::new();
}
```

---

## 3️⃣ 类型状态模式 (Typestate Pattern)

### 3.1 什么是类型状态模式？

类型状态模式使用类型系统在编译时强制执行状态转换规则，防止无效的状态转换。

**核心思想**:

- 每个状态对应一个类型
- 状态转换是类型转换
- 编译器保证状态转换的正确性

---

### 3.2 实现编译时状态机

**示例: 连接状态机**:

```rust
use std::marker::PhantomData;

// 连接状态
struct Disconnected;
struct Connecting;
struct Connected;
struct Authenticated;

// 连接对象
struct Connection<State> {
    socket: Option<String>,  // 简化表示
    auth_token: Option<String>,
    _state: PhantomData<State>,
}

impl Connection<Disconnected> {
    fn new() -> Self {
        Connection {
            socket: None,
            auth_token: None,
            _state: PhantomData,
        }
    }

    fn connect(self, address: &str) -> Connection<Connecting> {
        println!("Connecting to {}", address);
        Connection {
            socket: Some(address.to_string()),
            auth_token: None,
            _state: PhantomData,
        }
    }
}

impl Connection<Connecting> {
    fn handshake(self) -> Result<Connection<Connected>, Connection<Disconnected>> {
        println!("Performing handshake...");

        if self.socket.is_some() {
            Ok(Connection {
                socket: self.socket,
                auth_token: None,
                _state: PhantomData,
            })
        } else {
            Err(Connection {
                socket: None,
                auth_token: None,
                _state: PhantomData,
            })
        }
    }
}

impl Connection<Connected> {
    fn authenticate(self, token: String) -> Connection<Authenticated> {
        println!("Authenticating...");
        Connection {
            socket: self.socket,
            auth_token: Some(token),
            _state: PhantomData,
        }
    }

    fn send_unauthenticated(&self, data: &str) {
        println!("Sending (unauthenticated): {}", data);
    }

    fn disconnect(self) -> Connection<Disconnected> {
        println!("Disconnecting...");
        Connection {
            socket: None,
            auth_token: None,
            _state: PhantomData,
        }
    }
}

impl Connection<Authenticated> {
    fn send_authenticated(&self, data: &str) {
        println!("Sending (authenticated): {}", data);
    }

    fn disconnect(self) -> Connection<Disconnected> {
        println!("Disconnecting...");
        Connection {
            socket: None,
            auth_token: None,
            _state: PhantomData,
        }
    }
}

// 使用示例
fn example() -> Result<(), ()> {
    let conn = Connection::new();
    let conn = conn.connect("192.168.1.1:8080");
    let conn = conn.handshake().map_err(|_| ())?;

    conn.send_unauthenticated("Hello");

    let conn = conn.authenticate("secret_token".to_string());
    conn.send_authenticated("Sensitive data");

    // 编译错误：未认证的连接不能发送认证消息
    // let conn = Connection::new().connect("...").handshake().unwrap();
    // conn.send_authenticated("This won't compile");

    Ok(())
}
```

---

### 3.3 构建器模式的类型安全版本

**示例: 强类型的 SQL 查询构建器**:

```rust
use std::marker::PhantomData;

// 构建器状态
struct NoSelect;
struct Select;
struct NoFrom;
struct From;
struct NoWhere;
struct Where;

// SQL 查询构建器
struct QueryBuilder<S, F, W> {
    select_clause: Option<Vec<String>>,
    from_clause: Option<String>,
    where_clause: Option<String>,
    _state: PhantomData<(S, F, W)>,
}

impl QueryBuilder<NoSelect, NoFrom, NoWhere> {
    fn new() -> Self {
        QueryBuilder {
            select_clause: None,
            from_clause: None,
            where_clause: None,
            _state: PhantomData,
        }
    }
}

impl<F, W> QueryBuilder<NoSelect, F, W> {
    fn select(self, columns: Vec<String>) -> QueryBuilder<Select, F, W> {
        QueryBuilder {
            select_clause: Some(columns),
            from_clause: self.from_clause,
            where_clause: self.where_clause,
            _state: PhantomData,
        }
    }
}

impl<S, W> QueryBuilder<S, NoFrom, W> {
    fn from(self, table: String) -> QueryBuilder<S, From, W> {
        QueryBuilder {
            select_clause: self.select_clause,
            from_clause: Some(table),
            where_clause: self.where_clause,
            _state: PhantomData,
        }
    }
}

impl<S, F> QueryBuilder<S, F, NoWhere> {
    fn where_clause(self, condition: String) -> QueryBuilder<S, F, Where> {
        QueryBuilder {
            select_clause: self.select_clause,
            from_clause: self.from_clause,
            where_clause: Some(condition),
            _state: PhantomData,
        }
    }
}

impl QueryBuilder<Select, From, NoWhere> {
    fn build(self) -> String {
        format!(
            "SELECT {} FROM {}",
            self.select_clause.unwrap().join(", "),
            self.from_clause.unwrap()
        )
    }
}

impl QueryBuilder<Select, From, Where> {
    fn build(self) -> String {
        format!(
            "SELECT {} FROM {} WHERE {}",
            self.select_clause.unwrap().join(", "),
            self.from_clause.unwrap(),
            self.where_clause.unwrap()
        )
    }
}

// 使用示例
fn example() {
    let query = QueryBuilder::new()
        .select(vec!["id".to_string(), "name".to_string()])
        .from("users".to_string())
        .where_clause("age > 18".to_string())
        .build();

    println!("{}", query);

    // 编译错误：缺少 select
    // let invalid = QueryBuilder::new()
    //     .from("users".to_string())
    //     .build();

    // 编译错误：缺少 from
    // let invalid = QueryBuilder::new()
    //     .select(vec!["*".to_string()])
    //     .build();
}
```

---

### 3.4 协议状态管理

**示例: HTTP 协议状态机**:

```rust
use std::marker::PhantomData;

// HTTP 协议状态
struct RequestLine;
struct Headers;
struct Body;
struct Complete;

// HTTP 请求解析器
struct HttpParser<State> {
    method: Option<String>,
    path: Option<String>,
    headers: Vec<(String, String)>,
    body: Option<Vec<u8>>,
    _state: PhantomData<State>,
}

impl HttpParser<RequestLine> {
    fn new() -> Self {
        HttpParser {
            method: None,
            path: None,
            headers: Vec::new(),
            body: None,
            _state: PhantomData,
        }
    }

    fn parse_request_line(
        self,
        method: String,
        path: String,
    ) -> HttpParser<Headers> {
        HttpParser {
            method: Some(method),
            path: Some(path),
            headers: self.headers,
            body: self.body,
            _state: PhantomData,
        }
    }
}

impl HttpParser<Headers> {
    fn add_header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }

    fn finish_headers(self) -> HttpParser<Body> {
        HttpParser {
            method: self.method,
            path: self.path,
            headers: self.headers,
            body: self.body,
            _state: PhantomData,
        }
    }
}

impl HttpParser<Body> {
    fn set_body(self, body: Vec<u8>) -> HttpParser<Complete> {
        HttpParser {
            method: self.method,
            path: self.path,
            headers: self.headers,
            body: Some(body),
            _state: PhantomData,
        }
    }

    fn no_body(self) -> HttpParser<Complete> {
        HttpParser {
            method: self.method,
            path: self.path,
            headers: self.headers,
            body: None,
            _state: PhantomData,
        }
    }
}

impl HttpParser<Complete> {
    fn into_request(self) -> HttpRequest {
        HttpRequest {
            method: self.method.unwrap(),
            path: self.path.unwrap(),
            headers: self.headers,
            body: self.body,
        }
    }
}

struct HttpRequest {
    method: String,
    path: String,
    headers: Vec<(String, String)>,
    body: Option<Vec<u8>>,
}

// 使用示例
fn example() {
    let request = HttpParser::new()
        .parse_request_line("GET".to_string(), "/api/users".to_string())
        .add_header("Content-Type".to_string(), "application/json".to_string())
        .add_header("Authorization".to_string(), "Bearer token".to_string())
        .finish_headers()
        .no_body()
        .into_request();

    println!("{} {}", request.method, request.path);
}
```

---

## 4️⃣ 类型安全 API 设计

### 4.1 单位类型 (Unit Types)

使用类型系统强制执行单位正确性。

**示例: 物理单位系统**:

```rust
use std::marker::PhantomData;
use std::ops::{Add, Sub, Mul, Div};

// 基本单位
struct Meter;
struct Second;
struct Kilogram;

// 复合单位
struct PerSecond<T>(PhantomData<T>);
struct Squared<T>(PhantomData<T>);

// 数量类型
#[derive(Debug, Clone, Copy)]
struct Quantity<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<U> Quantity<U> {
    fn new(value: f64) -> Self {
        Quantity {
            value,
            _unit: PhantomData,
        }
    }

    fn value(&self) -> f64 {
        self.value
    }
}

// 同单位相加
impl<U> Add for Quantity<U> {
    type Output = Quantity<U>;

    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// 同单位相减
impl<U> Sub for Quantity<U> {
    type Output = Quantity<U>;

    fn sub(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value - rhs.value)
    }
}

// 距离 / 时间 = 速度
impl Div<Quantity<Second>> for Quantity<Meter> {
    type Output = Quantity<PerSecond<Meter>>;

    fn div(self, rhs: Quantity<Second>) -> Self::Output {
        Quantity::new(self.value / rhs.value)
    }
}

// 速度 * 时间 = 距离
impl Mul<Quantity<Second>> for Quantity<PerSecond<Meter>> {
    type Output = Quantity<Meter>;

    fn mul(self, rhs: Quantity<Second>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

// 类型别名
type Distance = Quantity<Meter>;
type Time = Quantity<Second>;
type Speed = Quantity<PerSecond<Meter>>;
type Mass = Quantity<Kilogram>;

// 使用示例
fn example() {
    let d1: Distance = Quantity::new(100.0);
    let d2: Distance = Quantity::new(50.0);
    let total_distance = d1 + d2;  // OK: 同单位

    let time: Time = Quantity::new(10.0);
    let speed: Speed = d1 / time;  // OK: 类型正确

    let distance = speed * time;   // OK: 速度 * 时间 = 距离

    // 编译错误：不能将距离和时间相加
    // let invalid = d1 + time;

    // 编译错误：不能将距离和质量相加
    // let mass: Mass = Quantity::new(70.0);
    // let invalid = d1 + mass;

    println!("Total distance: {} m", total_distance.value());
    println!("Speed: {} m/s", speed.value());
}
```

---

### 4.2 New Type Pattern

使用 newtype 模式创建类型安全的包装器。

**示例: 用户 ID 类型安全**:

```rust
// 不安全的方式：使用原始类型
fn unsafe_example() {
    fn get_user(user_id: u64) -> String {
        format!("User {}", user_id)
    }

    fn get_post(post_id: u64) -> String {
        format!("Post {}", post_id)
    }

    let user_id = 42;
    let post_id = 123;

    // 危险！可能混淆 user_id 和 post_id
    let user = get_user(post_id);  // 运行时错误
}

// 安全的方式：使用 newtype
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct UserId(u64);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct PostId(u64);

impl UserId {
    fn new(id: u64) -> Self {
        UserId(id)
    }

    fn value(&self) -> u64 {
        self.0
    }
}

impl PostId {
    fn new(id: u64) -> Self {
        PostId(id)
    }

    fn value(&self) -> u64 {
        self.0
    }
}

fn get_user(user_id: UserId) -> String {
    format!("User {}", user_id.value())
}

fn get_post(post_id: PostId) -> String {
    format!("Post {}", post_id.value())
}

// 使用示例
fn safe_example() {
    let user_id = UserId::new(42);
    let post_id = PostId::new(123);

    let user = get_user(user_id);
    let post = get_post(post_id);

    // 编译错误：类型不匹配
    // let user = get_user(post_id);

    println!("{}", user);
    println!("{}", post);
}
```

---

### 4.3 类型级不变量

使用类型系统保证不变量。

**示例: 非空向量**:

```rust
// 保证非空的向量
struct NonEmptyVec<T> {
    head: T,
    tail: Vec<T>,
}

impl<T> NonEmptyVec<T> {
    // 构造函数保证非空
    fn new(head: T) -> Self {
        NonEmptyVec {
            head,
            tail: Vec::new(),
        }
    }

    fn from_vec(vec: Vec<T>) -> Option<Self> {
        let mut iter = vec.into_iter();
        iter.next().map(|head| NonEmptyVec {
            head,
            tail: iter.collect(),
        })
    }

    fn push(&mut self, value: T) {
        self.tail.push(value);
    }

    // 永远可以安全地获取第一个元素
    fn first(&self) -> &T {
        &self.head
    }

    // 永远可以安全地获取最后一个元素
    fn last(&self) -> &T {
        self.tail.last().unwrap_or(&self.head)
    }

    fn len(&self) -> usize {
        1 + self.tail.len()
    }

    fn iter(&self) -> impl Iterator<Item = &T> {
        std::iter::once(&self.head).chain(self.tail.iter())
    }
}

// 使用示例
fn example() {
    let vec = NonEmptyVec::new(1);
    // vec.first() 永远不会 panic！
    println!("First: {}", vec.first());

    // 普通 Vec 需要处理空的情况
    let empty_vec: Vec<i32> = Vec::new();
    // empty_vec.first() 会返回 Option

    // 从普通 Vec 创建
    let vec = NonEmptyVec::from_vec(vec![1, 2, 3]).unwrap();
    println!("Last: {}", vec.last());
}
```

**示例: 排序保证的向量**:

```rust
use std::marker::PhantomData;

struct Sorted;
struct Unsorted;

struct Vector<T, State> {
    data: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> Vector<T, Unsorted> {
    fn new(data: Vec<T>) -> Self {
        Vector {
            data,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> Vector<T, Unsorted> {
    fn sort(mut self) -> Vector<T, Sorted> {
        self.data.sort();
        Vector {
            data: self.data,
            _state: PhantomData,
        }
    }
}

impl<T: Ord> Vector<T, Sorted> {
    // 只有排序的向量可以进行二分搜索
    fn binary_search(&self, value: &T) -> Result<usize, usize> {
        self.data.binary_search(value)
    }

    // 获取中位数（保证存在）
    fn median(&self) -> Option<&T> {
        if self.data.is_empty() {
            None
        } else {
            Some(&self.data[self.data.len() / 2])
        }
    }
}

impl<T, S> Vector<T, S> {
    fn len(&self) -> usize {
        self.data.len()
    }

    fn get(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

// 使用示例
fn example() {
    let unsorted = Vector::new(vec![3, 1, 4, 1, 5, 9, 2, 6]);

    // 编译错误：未排序的向量不能二分搜索
    // unsorted.binary_search(&4);

    let sorted = unsorted.sort();

    // OK：排序的向量可以二分搜索
    match sorted.binary_search(&4) {
        Ok(index) => println!("Found at index {}", index),
        Err(_) => println!("Not found"),
    }

    if let Some(median) = sorted.median() {
        println!("Median: {}", median);
    }
}
```

---

### 4.4 编译时验证

**示例: 编译时验证的数组索引**:

```rust
use std::marker::PhantomData;

// 类型级自然数
struct Zero;
struct Succ<N>(PhantomData<N>);

// 小于关系
trait LessThan<N> {}

impl<N> LessThan<Succ<N>> for Zero {}
impl<N, M> LessThan<Succ<M>> for Succ<N> where N: LessThan<M> {}

// 固定长度数组，带编译时边界检查
struct FixedArray<T, N> {
    data: Vec<T>,
    _len: PhantomData<N>,
}

impl<T, N> FixedArray<T, N> {
    // 编译时验证的安全索引
    fn get<I>(&self, _index: I) -> &T
    where
        I: LessThan<N>,
    {
        // 由于类型系统保证 I < N，这里可以安全地使用
        // 实际实现需要将类型级数字转换为运行时值
        unimplemented!("需要额外的类型级转换逻辑")
    }
}

// 类型别名
type Array3<T> = FixedArray<T, Succ<Succ<Succ<Zero>>>>;

type Index0 = Zero;
type Index1 = Succ<Zero>;
type Index2 = Succ<Succ<Zero>>;

// 使用示例（概念演示）
fn example() {
    // 长度为 3 的数组
    let arr: Array3<i32> = FixedArray {
        data: vec![10, 20, 30],
        _len: PhantomData,
    };

    // OK: 0 < 3, 1 < 3, 2 < 3
    // arr.get(Index0);
    // arr.get(Index1);
    // arr.get(Index2);

    // 编译错误: 3 不小于 3
    // arr.get(Succ<Succ<Succ<Zero>>>);
}
```

---

## 5️⃣ 编译时状态机

### 5.1 状态机基础

状态机是计算机科学中的基本概念，使用类型系统可以在编译时验证状态转换。

**传统状态机 vs 类型状态机**:

```rust
// 传统方式：运行时检查
enum State {
    Init,
    Running,
    Stopped,
}

struct RuntimeStateMachine {
    state: State,
}

impl RuntimeStateMachine {
    fn new() -> Self {
        RuntimeStateMachine { state: State::Init }
    }

    fn start(&mut self) -> Result<(), String> {
        match self.state {
            State::Init => {
                self.state = State::Running;
                Ok(())
            }
            _ => Err("Can only start from Init state".to_string()),
        }
    }

    fn stop(&mut self) -> Result<(), String> {
        match self.state {
            State::Running => {
                self.state = State::Stopped;
                Ok(())
            }
            _ => Err("Can only stop from Running state".to_string()),
        }
    }
}

// 类型状态方式：编译时检查
use std::marker::PhantomData;

struct Init;
struct Running;
struct Stopped;

struct TypeStateMachine<S> {
    _state: PhantomData<S>,
}

impl TypeStateMachine<Init> {
    fn new() -> Self {
        TypeStateMachine { _state: PhantomData }
    }

    fn start(self) -> TypeStateMachine<Running> {
        TypeStateMachine { _state: PhantomData }
    }
}

impl TypeStateMachine<Running> {
    fn stop(self) -> TypeStateMachine<Stopped> {
        TypeStateMachine { _state: PhantomData }
    }
}

// 编译时错误，无法从 Init 直接到 Stopped
// impl TypeStateMachine<Init> {
//     fn stop(self) -> TypeStateMachine<Stopped> {
//         TypeStateMachine { _state: PhantomData }
//     }
// }

fn example() {
    let machine = TypeStateMachine::new();  // Init
    let machine = machine.start();          // Running
    let machine = machine.stop();           // Stopped

    // 编译错误：Stopped 状态没有 start 方法
    // machine.start();

    // 编译错误：不能从 Init 直接 stop
    // let machine = TypeStateMachine::new().stop();
}
```

---

### 5.2 类型级状态转换

**示例: 状态转换图**:

```rust
use std::marker::PhantomData;

// 定义所有可能的状态
struct Idle;
struct Preparing;
struct Ready;
struct Executing;
struct Completed;
struct Failed;

// 任务状态机
struct Task<S> {
    name: String,
    _state: PhantomData<S>,
}

// 状态转换实现
impl Task<Idle> {
    fn new(name: String) -> Self {
        Task {
            name,
            _state: PhantomData,
        }
    }

    fn prepare(self) -> Task<Preparing> {
        println!("{}: Idle -> Preparing", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Preparing> {
    fn mark_ready(self) -> Task<Ready> {
        println!("{}: Preparing -> Ready", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }

    fn fail(self) -> Task<Failed> {
        println!("{}: Preparing -> Failed", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Ready> {
    fn execute(self) -> Task<Executing> {
        println!("{}: Ready -> Executing", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Executing> {
    fn complete(self) -> Task<Completed> {
        println!("{}: Executing -> Completed", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }

    fn fail(self) -> Task<Failed> {
        println!("{}: Executing -> Failed", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Task<Completed> {
    fn get_result(&self) -> String {
        format!("{}: Task completed successfully", self.name)
    }
}

impl Task<Failed> {
    fn get_error(&self) -> String {
        format!("{}: Task failed", self.name)
    }

    fn retry(self) -> Task<Idle> {
        println!("{}: Failed -> Idle (retrying)", self.name);
        Task {
            name: self.name,
            _state: PhantomData,
        }
    }
}

// 使用示例
fn example() {
    // 成功路径
    let task = Task::new("Task1".to_string());
    let task = task.prepare();
    let task = task.mark_ready();
    let task = task.execute();
    let task = task.complete();
    println!("{}", task.get_result());

    // 失败并重试
    let task = Task::new("Task2".to_string());
    let task = task.prepare();
    let task = task.fail();
    let task = task.retry();
    let task = task.prepare().mark_ready().execute().complete();
    println!("{}", task.get_result());

    // 编译错误：不能从 Idle 直接执行
    // let task = Task::new("Invalid".to_string()).execute();

    // 编译错误：不能重复 prepare
    // let task = Task::new("Invalid".to_string()).prepare().prepare();
}
```

---

### 5.3 实战案例：TCP 连接状态

**示例: TCP 连接生命周期**:

```rust
use std::marker::PhantomData;
use std::net::{TcpStream, SocketAddr};
use std::io::{self, Read, Write};

// TCP 连接状态
struct Closed;
struct Listening;
struct Connecting;
struct Established;
struct Closing;

// TCP 连接
struct TcpConnection<S> {
    stream: Option<TcpStream>,
    addr: Option<SocketAddr>,
    _state: PhantomData<S>,
}

impl TcpConnection<Closed> {
    fn new() -> Self {
        TcpConnection {
            stream: None,
            addr: None,
            _state: PhantomData,
        }
    }

    fn connect(self, addr: SocketAddr) -> io::Result<TcpConnection<Connecting>> {
        Ok(TcpConnection {
            stream: None,
            addr: Some(addr),
            _state: PhantomData,
        })
    }
}

impl TcpConnection<Connecting> {
    fn handshake(self) -> io::Result<TcpConnection<Established>> {
        // 模拟 TCP 三次握手
        let stream = TcpStream::connect(self.addr.unwrap())?;

        Ok(TcpConnection {
            stream: Some(stream),
            addr: self.addr,
            _state: PhantomData,
        })
    }

    fn timeout(self) -> TcpConnection<Closed> {
        TcpConnection {
            stream: None,
            addr: None,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Established> {
    fn send(&mut self, data: &[u8]) -> io::Result<usize> {
        self.stream.as_mut().unwrap().write(data)
    }

    fn receive(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.stream.as_mut().unwrap().read(buf)
    }

    fn close(self) -> TcpConnection<Closing> {
        TcpConnection {
            stream: self.stream,
            addr: self.addr,
            _state: PhantomData,
        }
    }
}

impl TcpConnection<Closing> {
    fn finalize(self) -> TcpConnection<Closed> {
        // TCP 连接关闭，释放资源
        drop(self.stream);

        TcpConnection {
            stream: None,
            addr: None,
            _state: PhantomData,
        }
    }
}

// 使用示例
fn example() -> io::Result<()> {
    let conn = TcpConnection::new();
    let addr: SocketAddr = "127.0.0.1:8080".parse().unwrap();
    let conn = conn.connect(addr)?;
    let mut conn = conn.handshake()?;

    conn.send(b"Hello, Server!")?;

    let mut buf = [0u8; 1024];
    let n = conn.receive(&mut buf)?;
    println!("Received: {:?}", &buf[..n]);

    let conn = conn.close();
    let _conn = conn.finalize();

    // 编译错误：关闭的连接不能发送
    // conn.send(b"data");

    Ok(())
}
```

---

## 6️⃣ 类型级不变量与证明

### 6.1 什么是类型级不变量？

类型级不变量使用类型系统在编译时保证某些属性始终为真。

**示例: 密码强度验证**:

```rust
use std::marker::PhantomData;

// 密码强度标记
struct Weak;
struct Medium;
struct Strong;

// 密码类型
struct Password<Strength> {
    value: String,
    _strength: PhantomData<Strength>,
}

impl Password<Weak> {
    fn new_unchecked(value: String) -> Self {
        Password {
            value,
            _strength: PhantomData,
        }
    }

    fn validate(self) -> Result<Password<Strong>, Password<Weak>> {
        let has_upper = self.value.chars().any(|c| c.is_uppercase());
        let has_lower = self.value.chars().any(|c| c.is_lowercase());
        let has_digit = self.value.chars().any(|c| c.is_numeric());
        let is_long_enough = self.value.len() >= 8;

        if has_upper && has_lower && has_digit && is_long_enough {
            Ok(Password {
                value: self.value,
                _strength: PhantomData,
            })
        } else {
            Err(self)
        }
    }
}

impl Password<Strong> {
    // 只有强密码可以用于认证
    fn authenticate(&self, stored_hash: &str) -> bool {
        // 模拟密码验证
        // hash(&self.value) == stored_hash
        true
    }

    fn value(&self) -> &str {
        &self.value
    }
}

// 使用示例
fn example() {
    let weak_password = Password::new_unchecked("abc".to_string());

    // 编译错误：弱密码不能用于认证
    // weak_password.authenticate("hash");

    let strong_password = Password::new_unchecked("Abc123456".to_string())
        .validate()
        .expect("Password is not strong enough");

    // OK：强密码可以用于认证
    strong_password.authenticate("stored_hash");
}
```

---

### 6.2 使用类型系统进行证明

**示例: 编译时验证的链表**:

```rust
use std::marker::PhantomData;

// 非空证明
struct Empty;
struct NonEmpty;

// 链表
struct List<T, State> {
    data: Vec<T>,
    _state: PhantomData<State>,
}

impl<T> List<T, Empty> {
    fn new() -> Self {
        List {
            data: Vec::new(),
            _state: PhantomData,
        }
    }

    fn push(self, value: T) -> List<T, NonEmpty> {
        let mut data = self.data;
        data.push(value);
        List {
            data,
            _state: PhantomData,
        }
    }
}

impl<T> List<T, NonEmpty> {
    // 保证非空，可以安全地获取头部
    fn head(&self) -> &T {
        &self.data[0]
    }

    // 保证非空，可以安全地获取尾部
    fn tail(&self) -> &[T] {
        &self.data[1..]
    }

    fn push(self, value: T) -> List<T, NonEmpty> {
        let mut data = self.data;
        data.push(value);
        List {
            data,
            _state: PhantomData,
        }
    }

    fn pop(self) -> Result<(T, List<T, NonEmpty>), List<T, Empty>> {
        let mut data = self.data;
        if let Some(value) = data.pop() {
            if data.is_empty() {
                Err(List {
                    data,
                    _state: PhantomData,
                })
            } else {
                Ok((
                    value,
                    List {
                        data,
                        _state: PhantomData,
                    },
                ))
            }
        } else {
            unreachable!("NonEmpty list cannot be empty")
        }
    }
}

// 使用示例
fn example() {
    let empty = List::<i32, Empty>::new();

    // 编译错误：空列表没有 head 方法
    // empty.head();

    let non_empty = empty.push(1).push(2).push(3);

    // OK：非空列表可以安全地获取头部
    println!("Head: {}", non_empty.head());
    println!("Tail: {:?}", non_empty.tail());
}
```

---

### 6.3 索引安全性

**示例: 编译时验证的数组访问**:

```rust
use std::marker::PhantomData;

// 范围证明
trait InRange<const N: usize> {}

// 实现 InRange trait（简化版本）
// 实际实现需要更复杂的类型级编程

struct Index<const I: usize>;

impl<const I: usize, const N: usize> InRange<N> for Index<I>
where
    [(); (I < N) as usize]:,  // 编译时检查 I < N
{
}

struct SafeArray<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> SafeArray<T, N> {
    fn new(data: [T; N]) -> Self {
        SafeArray { data }
    }

    // 编译时验证的索引访问
    fn get<const I: usize>(&self) -> &T
    where
        Index<I>: InRange<N>,
    {
        &self.data[I]
    }

    // 运行时索引（使用 Option）
    fn get_runtime(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

// 使用示例
fn example() {
    let arr = SafeArray::new([1, 2, 3, 4, 5]);

    // OK：编译时验证索引在范围内
    let value = arr.get::<2>();  // 索引 2 < 5
    println!("Value at index 2: {}", value);

    // 编译错误：索引超出范围
    // let value = arr.get::<10>();  // 索引 10 >= 5

    // 运行时索引（返回 Option）
    if let Some(value) = arr.get_runtime(2) {
        println!("Value: {}", value);
    }
}
```

---

## 🎯 实战项目

### 项目 1: 类型安全的 SQL 查询构建器

**目标**: 实现一个完全类型安全的 SQL 查询构建器，在编译时验证查询的正确性。

**要求**:

1. 实现 SELECT、FROM、WHERE、JOIN 等子句
2. 使用类型状态模式强制执行正确的构建顺序
3. 编译时验证列名和表名的正确性
4. 支持链式调用

**提示**:

```rust
// 伪代码示例
let query = QueryBuilder::new()
    .select(&["id", "name"])
    .from("users")
    .where_("age > 18")
    .join("posts", "users.id = posts.user_id")
    .build();
```

---

### 项目 2: 编译时验证的状态机

**目标**: 实现一个通用的状态机框架，在编译时验证状态转换。

**要求**:

1. 支持定义任意状态和转换
2. 编译时验证所有状态转换的合法性
3. 支持状态转换的回调函数
4. 零运行时开销

**提示**:

```rust
// 伪代码示例
define_state_machine! {
    states: [Init, Running, Stopped, Error],
    transitions: [
        Init -> Running,
        Running -> Stopped,
        Running -> Error,
        Error -> Init,
    ]
}
```

---

## 📊 性能分析

**ZST 的性能优势**:

| 特性 | 传统方式 | ZST 方式 | 性能提升 |
| --- | --- | --- | --- |
| 内存占用 | 实际类型大小 | 0 字节 | 100% |
| 运行时检查 | 需要 | 编译时优化掉 | 消除开销 |
| 状态验证 | 运行时 | 编译时 | 零运行时成本 |
| 类型标记 | 需要字段 | PhantomData (0 字节) | 100% |

**Benchmark 示例**:

```rust
#[cfg(test)]
mod benches {
    use super::*;
    use std::time::Instant;

    #[test]
    fn benchmark_zst_vs_traditional() {
        // 传统方式：运行时状态检查
        let start = Instant::now();
        for _ in 0..1_000_000 {
            let mut machine = RuntimeStateMachine::new();
            machine.start().unwrap();
            machine.stop().unwrap();
        }
        let runtime_duration = start.elapsed();

        // ZST 方式：编译时状态检查
        let start = Instant::now();
        for _ in 0..1_000_000 {
            let machine = TypeStateMachine::new();
            let machine = machine.start();
            let _machine = machine.stop();
        }
        let compile_time_duration = start.elapsed();

        println!("Runtime check: {:?}", runtime_duration);
        println!("Compile-time check: {:?}", compile_time_duration);
        println!(
            "Speedup: {:.2}x",
            runtime_duration.as_secs_f64() / compile_time_duration.as_secs_f64()
        );
    }
}
```

---

## 🔍 常见陷阱与解决方案

**陷阱 1: Drop Check 问题**:

```rust
use std::marker::PhantomData;

// 错误：Drop check 失败
struct Wrapper<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a T>,  // 不够，需要 PhantomData<&'a mut T>
}

// 正确
struct WrapperCorrect<'a, T> {
    ptr: *const T,
    _marker: PhantomData<&'a mut T>,  // 告诉编译器我们可能会 drop T
}
```

**陷阱 2: 型变问题**:

```rust
// 问题：不当的型变
struct Container<T> {
    value: *const T,
    _marker: PhantomData<T>,  // 协变，但指针不是
}

// 解决：使用正确的型变
struct ContainerFixed<T> {
    value: *const T,
    _marker: PhantomData<*const T>,  // 与指针的型变一致
}
```

**陷阱 3: 过度使用类型状态**:

```rust
// 不好：过度使用类型状态
struct OverlyComplex<S1, S2, S3, S4, S5> {
    // 5个状态参数，难以维护
    _state: PhantomData<(S1, S2, S3, S4, S5)>,
}

// 好：合理分组状态
struct Reasonable<MainState, SubState> {
    // 只保留必要的状态
    _state: PhantomData<(MainState, SubState)>,
}
```

---

## 📚 延伸阅读

**推荐文章**:

1. [Phantom Types in Rust](https://doc.rust-lang.org/nomicon/phantom-data.html)
2. [The Typestate Pattern in Rust](http://cliffle.com/blog/rust-typestate/)
3. [Zero-Sized Types in Rust](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)
4. [Advanced Compile-Time Features](https://github.com/dtolnay/case-studies)

**相关库**:

- [`typed-builder`](https://crates.io/crates/typed-builder) - 类型安全的构建器
- [`state_machine_future`](https://crates.io/crates/state_machine_future) - 状态机框架
- [`phantom-type`](https://crates.io/crates/phantom-type) - 幽灵类型工具

**学术论文**:

- "Type-State: A Programming Language Concept for Enhancing Software Reliability" (Strom & Yemini, 1986)
- "Phantom Types and Subtyping" (Leijen & Meijer, 1999)

---

## 🎓 学习检验

完成本章学习后，请回答以下问题：

1. **PhantomData**:
   - 解释 PhantomData 的三种型变类型
   - 为什么需要 PhantomData？
   - 如何使用 PhantomData 控制 Drop check？

2. **ZST**:
   - 列举三个 ZST 的实际应用
   - 解释为什么 ZST 能带来性能优势
   - ZST 在标准库中的应用有哪些？

3. **类型状态模式**:
   - 实现一个简单的文件状态机（打开、读取、写入、关闭）
   - 解释类型状态模式相比运行时检查的优势
   - 何时应该使用类型状态模式？

4. **类型级不变量**:
   - 如何使用类型系统保证非空性？
   - 解释 NewType 模式的作用
   - 实现一个编译时验证的单位类型系统

**实践练习**:

1. 实现一个类型安全的HTTP 客户端，使用类型状态模式
2. 创建一个零大小的迭代器适配器
3. 设计一个编译时验证的配置构建器
4. 实现一个类型安全的状态机框架

---

**返回**: [Tier 4 索引](./README.md) | **下一章**: [02_泛型与生命周期](./02_泛型与生命周期.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-22
**最后更新**: 2025-12-11
**文档状态**: ✅ 完成
