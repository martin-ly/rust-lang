# 05 è®¾è®¡æ¨¡å¼è¿›é˜¶

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§ä¸»é¢˜  
> **ç›®æ ‡è¯»è€…**: æ¶æ„å¸ˆå’Œé«˜çº§å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 5-6 å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: è®¾è®¡æ¨¡å¼åŸºç¡€ã€å¹¶å‘ç¼–ç¨‹ã€å¼‚æ­¥ç¼–ç¨‹

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦ç­‰çº§**: â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [05 è®¾è®¡æ¨¡å¼è¿›é˜¶](#05-è®¾è®¡æ¨¡å¼è¿›é˜¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1ï¸âƒ£ æ³›å‹è®¾è®¡æ¨¡å¼](#1ï¸âƒ£-æ³›å‹è®¾è®¡æ¨¡å¼)
    - [ç­–ç•¥æ¨¡å¼ (Strategy Pattern)](#ç­–ç•¥æ¨¡å¼-strategy-pattern)
    - [è®¿é—®è€…æ¨¡å¼ (Visitor Pattern)](#è®¿é—®è€…æ¨¡å¼-visitor-pattern)
  - [2ï¸âƒ£ å¹¶å‘è®¾è®¡æ¨¡å¼](#2ï¸âƒ£-å¹¶å‘è®¾è®¡æ¨¡å¼)
    - [Actor æ¨¡å¼](#actor-æ¨¡å¼)
    - [ç®¡é“æ¨¡å¼ (Pipeline Pattern)](#ç®¡é“æ¨¡å¼-pipeline-pattern)
  - [3ï¸âƒ£ å¼‚æ­¥è®¾è®¡æ¨¡å¼](#3ï¸âƒ£-å¼‚æ­¥è®¾è®¡æ¨¡å¼)
    - [å¼‚æ­¥ Actor æ¨¡å¼](#å¼‚æ­¥-actor-æ¨¡å¼)
    - [å¼‚æ­¥æµæ°´çº¿](#å¼‚æ­¥æµæ°´çº¿)
  - [4ï¸âƒ£ ç±»å‹é©±åŠ¨è®¾è®¡](#4ï¸âƒ£-ç±»å‹é©±åŠ¨è®¾è®¡)
    - [æ–°ç±»å‹æ¨¡å¼å¢å¼º](#æ–°ç±»å‹æ¨¡å¼å¢å¼º)
    - [ç±»å‹çŠ¶æ€æ„å»ºå™¨](#ç±»å‹çŠ¶æ€æ„å»ºå™¨)
  - [5ï¸âƒ£ èµ„æºç®¡ç†æ¨¡å¼](#5ï¸âƒ£-èµ„æºç®¡ç†æ¨¡å¼)
    - [RAII (Resource Acquisition Is Initialization)](#raii-resource-acquisition-is-initialization)
  - [ğŸ¯ æ¶æ„æ¨¡å¼](#-æ¶æ„æ¨¡å¼)
    - [å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture)](#å…­è¾¹å½¢æ¶æ„-hexagonal-architecture)
  - [ğŸ“š æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [ğŸ“ å­¦ä¹ æ£€éªŒ](#-å­¦ä¹ æ£€éªŒ)

æœ¬ç« æ¢è®¨åœ¨ Rust ä¸­åº”ç”¨é«˜çº§è®¾è®¡æ¨¡å¼ï¼Œç‰¹åˆ«å…³æ³¨ï¼š

- æ³›å‹ä¸è®¾è®¡æ¨¡å¼çš„ç»“åˆ
- å¹¶å‘è®¾è®¡æ¨¡å¼
- å¼‚æ­¥è®¾è®¡æ¨¡å¼
- é›¶æˆæœ¬æŠ½è±¡çš„æ¶æ„æ¨¡å¼
- ç±»å‹é©±åŠ¨çš„è®¾è®¡

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬ç« åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… åº”ç”¨æ³›å‹å®ç°ç»å…¸è®¾è®¡æ¨¡å¼
- âœ… è®¾è®¡ç±»å‹å®‰å…¨çš„å¹¶å‘ç³»ç»Ÿ
- âœ… æ„å»ºé«˜æ€§èƒ½çš„å¼‚æ­¥æ¶æ„
- âœ… ä½¿ç”¨ç±»å‹ç³»ç»Ÿå¼ºåˆ¶æ‰§è¡Œæ¶æ„çº¦æŸ
- âœ… è®¾è®¡é›¶å¼€é”€çš„æŠ½è±¡å±‚

---

## 1ï¸âƒ£ æ³›å‹è®¾è®¡æ¨¡å¼

### ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

ä½¿ç”¨æ³›å‹å’Œ trait å®ç°ç­–ç•¥æ¨¡å¼ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ã€‚

```rust
// æ’åºç­–ç•¥ trait
trait SortStrategy<T> {
    fn sort(&self, data: &mut [T]);
}

// å¿«é€Ÿæ’åºç­–ç•¥
struct QuickSort;
impl<T: Ord> SortStrategy<T> for QuickSort {
    fn sort(&self, data: &mut [T]) {
        data.sort_unstable();
    }
}

// å½’å¹¶æ’åºç­–ç•¥
struct MergeSort;
impl<T: Ord> SortStrategy<T> for MergeSort {
    fn sort(&self, data: &mut [T]) {
        data.sort();
    }
}

// ä¸Šä¸‹æ–‡ï¼ˆä½¿ç”¨æ³›å‹ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ï¼‰
struct Sorter<T, S: SortStrategy<T>> {
    strategy: S,
    _marker: std::marker::PhantomData<T>,
}

impl<T: Ord, S: SortStrategy<T>> Sorter<T, S> {
    fn new(strategy: S) -> Self {
        Sorter {
            strategy,
            _marker: std::marker::PhantomData,
        }
    }

    fn sort(&self, data: &mut [T]) {
        self.strategy.sort(data);
    }
}

// ä½¿ç”¨ï¼ˆç¼–è¯‘æ—¶å†³å®šç­–ç•¥ï¼Œé›¶å¼€é”€ï¼‰
fn example() {
    let mut data = vec![3, 1, 4, 1, 5, 9, 2, 6];
    
    let sorter = Sorter::new(QuickSort);
    sorter.sort(&mut data);
    
    let sorter = Sorter::new(MergeSort);
    sorter.sort(&mut data);
}
```

### è®¿é—®è€…æ¨¡å¼ (Visitor Pattern)

```rust
// è¡¨è¾¾å¼ AST
enum Expr {
    Number(i32),
    Add(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
}

// è®¿é—®è€… trait
trait ExprVisitor {
    type Output;
    
    fn visit_number(&mut self, n: i32) -> Self::Output;
    fn visit_add(&mut self, left: &Expr, right: &Expr) -> Self::Output;
    fn visit_mul(&mut self, left: &Expr, right: &Expr) -> Self::Output;
}

impl Expr {
    fn accept<V: ExprVisitor>(&self, visitor: &mut V) -> V::Output {
        match self {
            Expr::Number(n) => visitor.visit_number(*n),
            Expr::Add(left, right) => visitor.visit_add(left, right),
            Expr::Mul(left, right) => visitor.visit_mul(left, right),
        }
    }
}

// æ±‚å€¼è®¿é—®è€…
struct Evaluator;
impl ExprVisitor for Evaluator {
    type Output = i32;
    
    fn visit_number(&mut self, n: i32) -> i32 {
        n
    }
    
    fn visit_add(&mut self, left: &Expr, right: &Expr) -> i32 {
        left.accept(self) + right.accept(self)
    }
    
    fn visit_mul(&mut self, left: &Expr, right: &Expr) -> i32 {
        left.accept(self) * right.accept(self)
    }
}

// æ‰“å°è®¿é—®è€…
struct Printer;
impl ExprVisitor for Printer {
    type Output = String;
    
    fn visit_number(&mut self, n: i32) -> String {
        n.to_string()
    }
    
    fn visit_add(&mut self, left: &Expr, right: &Expr) -> String {
        format!("({} + {})", left.accept(self), right.accept(self))
    }
    
    fn visit_mul(&mut self, left: &Expr, right: &Expr) -> String {
        format!("({} * {})", left.accept(self), right.accept(self))
    }
}
```

---

## 2ï¸âƒ£ å¹¶å‘è®¾è®¡æ¨¡å¼

### Actor æ¨¡å¼

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

// Actor trait
trait Actor: Send + 'static {
    type Message: Send;
    
    fn handle(&mut self, msg: Self::Message);
}

// Actor ä¸Šä¸‹æ–‡
struct ActorContext<A: Actor> {
    actor: A,
    receiver: Receiver<A::Message>,
}

impl<A: Actor> ActorContext<A> {
    fn new(actor: A, receiver: Receiver<A::Message>) -> Self {
        ActorContext { actor, receiver }
    }
    
    fn run(mut self) {
        while let Ok(msg) = self.receiver.recv() {
            self.actor.handle(msg);
        }
    }
}

// Actor å¥æŸ„
struct ActorHandle<M: Send> {
    sender: Sender<M>,
}

impl<M: Send> ActorHandle<M> {
    fn send(&self, msg: M) -> Result<(), String> {
        self.sender.send(msg).map_err(|_| "Send failed".to_string())
    }
}

// ç”Ÿæˆ Actor
fn spawn_actor<A: Actor>(actor: A) -> ActorHandle<A::Message> {
    let (sender, receiver) = channel();
    let context = ActorContext::new(actor, receiver);
    
    thread::spawn(move || {
        context.run();
    });
    
    ActorHandle { sender }
}

// ç¤ºä¾‹ Actor
struct CounterActor {
    count: i32,
}

enum CounterMessage {
    Increment,
    Decrement,
    GetCount(Sender<i32>),
}

impl Actor for CounterActor {
    type Message = CounterMessage;
    
    fn handle(&mut self, msg: CounterMessage) {
        match msg {
            CounterMessage::Increment => self.count += 1,
            CounterMessage::Decrement => self.count -= 1,
            CounterMessage::GetCount(sender) => {
                let _ = sender.send(self.count);
            }
        }
    }
}
```

### ç®¡é“æ¨¡å¼ (Pipeline Pattern)

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

// ç®¡é“é˜¶æ®µ trait
trait Stage<Input, Output>: Send + 'static {
    fn process(&mut self, input: Input) -> Output;
}

// åˆ›å»ºç®¡é“é˜¶æ®µ
fn spawn_stage<S, I, O>(mut stage: S) -> (Sender<I>, Receiver<O>)
where
    S: Stage<I, O>,
    I: Send + 'static,
    O: Send + 'static,
{
    let (input_tx, input_rx) = channel();
    let (output_tx, output_rx) = channel();
    
    thread::spawn(move || {
        while let Ok(input) = input_rx.recv() {
            let output = stage.process(input);
            if output_tx.send(output).is_err() {
                break;
            }
        }
    });
    
    (input_tx, output_rx)
}

// ç¤ºä¾‹ï¼šæ•°æ®å¤„ç†ç®¡é“
struct ParseStage;
impl Stage<String, i32> for ParseStage {
    fn process(&mut self, input: String) -> i32 {
        input.parse().unwrap_or(0)
    }
}

struct DoubleStage;
impl Stage<i32, i32> for DoubleStage {
    fn process(&mut self, input: i32) -> i32 {
        input * 2
    }
}

struct FormatStage;
impl Stage<i32, String> for FormatStage {
    fn process(&mut self, input: i32) -> String {
        format!("Result: {}", input)
    }
}

// æ„å»ºç®¡é“
fn build_pipeline() -> (Sender<String>, Receiver<String>) {
    let (parse_in, parse_out) = spawn_stage(ParseStage);
    let (double_in, double_out) = spawn_stage(DoubleStage);
    let (format_in, format_out) = spawn_stage(FormatStage);
    
    // è¿æ¥é˜¶æ®µ
    thread::spawn(move || {
        while let Ok(value) = parse_out.recv() {
            if double_in.send(value).is_err() {
                break;
            }
        }
    });
    
    thread::spawn(move || {
        while let Ok(value) = double_out.recv() {
            if format_in.send(value).is_err() {
                break;
            }
        }
    });
    
    (parse_in, format_out)
}
```

---

## 3ï¸âƒ£ å¼‚æ­¥è®¾è®¡æ¨¡å¼

### å¼‚æ­¥ Actor æ¨¡å¼

```rust
use tokio::sync::mpsc;
use async_trait::async_trait;

// å¼‚æ­¥ Actor trait
#[async_trait]
trait AsyncActor: Send + 'static {
    type Message: Send;
    
    async fn handle(&mut self, msg: Self::Message);
}

// å¼‚æ­¥ Actor ç³»ç»Ÿ
struct AsyncActorSystem<A: AsyncActor> {
    actor: A,
    receiver: mpsc::Receiver<A::Message>,
}

impl<A: AsyncActor> AsyncActorSystem<A> {
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            self.actor.handle(msg).await;
        }
    }
}

// ç”Ÿæˆå¼‚æ­¥ Actor
fn spawn_async_actor<A: AsyncActor>(actor: A) -> mpsc::Sender<A::Message> {
    let (sender, receiver) = mpsc::channel(100);
    let system = AsyncActorSystem { actor, receiver };
    
    tokio::spawn(async move {
        system.run().await;
    });
    
    sender
}
```

### å¼‚æ­¥æµæ°´çº¿

```rust
use tokio::sync::mpsc;
use async_trait::async_trait;
use futures::StreamExt;

// å¼‚æ­¥è½¬æ¢ trait
#[async_trait]
trait AsyncTransform<I, O>: Send + Sync {
    async fn transform(&self, input: I) -> O;
}

// å¼‚æ­¥ç®¡é“
struct AsyncPipeline<I, O> {
    input: mpsc::Receiver<I>,
    output: mpsc::Sender<O>,
}

impl<I: Send + 'static, O: Send + 'static> AsyncPipeline<I, O> {
    async fn process<T>(
        mut self,
        transform: T,
    ) where
        T: AsyncTransform<I, O> + 'static,
    {
        while let Some(input) = self.input.recv().await {
            let output = transform.transform(input).await;
            if self.output.send(output).await.is_err() {
                break;
            }
        }
    }
}
```

---

## 4ï¸âƒ£ ç±»å‹é©±åŠ¨è®¾è®¡

### æ–°ç±»å‹æ¨¡å¼å¢å¼º

```rust
// å¼ºç±»å‹ Email
struct Email(String);

impl Email {
    fn new(s: String) -> Result<Self, String> {
        if s.contains('@') {
            Ok(Email(s))
        } else {
            Err("Invalid email".to_string())
        }
    }
    
    fn as_str(&self) -> &str {
        &self.0
    }
}

// å¼ºç±»å‹ UserId
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct UserId(u64);

// å¼ºç±»å‹ Timestamp
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Timestamp(u64);

// ç±»å‹å®‰å…¨çš„ API
fn send_email(user_id: UserId, email: Email, timestamp: Timestamp) {
    println!("Sending email to user {:?} at {:?}: {}", 
        user_id, timestamp, email.as_str());
}

// ç¼–è¯‘æ—¶é˜²æ­¢å‚æ•°æ··æ·†
fn type_safe_example() {
    let user_id = UserId(12345);
    let email = Email::new("user@example.com".to_string()).unwrap();
    let timestamp = Timestamp(1234567890);
    
    send_email(user_id, email, timestamp);
    
    // ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // send_email(timestamp, email, user_id);
}
```

### ç±»å‹çŠ¶æ€æ„å»ºå™¨

```rust
use std::marker::PhantomData;

// æ„å»ºå™¨çŠ¶æ€
struct NoUrl;
struct HasUrl;
struct NoMethod;
struct HasMethod;

// HTTP è¯·æ±‚æ„å»ºå™¨
struct RequestBuilder<U, M> {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
    body: Option<String>,
    _url_state: PhantomData<U>,
    _method_state: PhantomData<M>,
}

impl RequestBuilder<NoUrl, NoMethod> {
    fn new() -> Self {
        RequestBuilder {
            url: None,
            method: None,
            headers: Vec::new(),
            body: None,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<M> RequestBuilder<NoUrl, M> {
    fn url(self, url: impl Into<String>) -> RequestBuilder<HasUrl, M> {
        RequestBuilder {
            url: Some(url.into()),
            method: self.method,
            headers: self.headers,
            body: self.body,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U> RequestBuilder<U, NoMethod> {
    fn method(self, method: impl Into<String>) -> RequestBuilder<U, HasMethod> {
        RequestBuilder {
            url: self.url,
            method: Some(method.into()),
            headers: self.headers,
            body: self.body,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U, M> RequestBuilder<U, M> {
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
    
    fn body(mut self, body: String) -> Self {
        self.body = Some(body);
        self
    }
}

impl RequestBuilder<HasUrl, HasMethod> {
    // åªæœ‰åŒæ—¶è®¾ç½®äº† URL å’Œ Method æ‰èƒ½æ„å»º
    fn build(self) -> Request {
        Request {
            url: self.url.unwrap(),
            method: self.method.unwrap(),
            headers: self.headers,
            body: self.body,
        }
    }
}

struct Request {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
    body: Option<String>,
}
```

---

## 5ï¸âƒ£ èµ„æºç®¡ç†æ¨¡å¼

### RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

// è‡ªåŠ¨ç®¡ç†æ–‡ä»¶çš„ RAII åŒ…è£…å™¨
struct ManagedFile {
    file: File,
    path: String,
}

impl ManagedFile {
    fn new(path: impl Into<String>) -> io::Result<Self> {
        let path = path.into();
        let file = File::create(&path)?;
        Ok(ManagedFile { file, path })
    }
    
    fn write(&mut self, data: &[u8]) -> io::Result<()> {
        self.file.write_all(data)
    }
}

impl Drop for ManagedFile {
    fn drop(&mut self) {
        println!("Closing file: {}", self.path);
        // æ–‡ä»¶è‡ªåŠ¨å…³é—­
    }
}

// Scope Guard æ¨¡å¼
struct ScopeGuard<F: FnOnce()> {
    cleanup: Option<F>,
}

impl<F: FnOnce()> ScopeGuard<F> {
    fn new(cleanup: F) -> Self {
        ScopeGuard {
            cleanup: Some(cleanup),
        }
    }
}

impl<F: FnOnce()> Drop for ScopeGuard<F> {
    fn drop(&mut self) {
        if let Some(cleanup) = self.cleanup.take() {
            cleanup();
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn scope_guard_example() {
    let _guard = ScopeGuard::new(|| {
        println!("Cleaning up resources");
    });
    
    // æ‰§è¡Œæ“ä½œ...
    println!("Doing work");
    
    // _guard åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨è°ƒç”¨æ¸…ç†å‡½æ•°
}
```

---

## ğŸ¯ æ¶æ„æ¨¡å¼

### å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture)

```rust
// é¢†åŸŸæ¨¡å‹
struct User {
    id: u64,
    name: String,
    email: String,
}

// ç«¯å£ (Port) - é¢†åŸŸå±‚æ¥å£
trait UserRepository {
    fn find_by_id(&self, id: u64) -> Option<User>;
    fn save(&mut self, user: User) -> Result<(), String>;
}

// é€‚é…å™¨ (Adapter) - å®ç°ç«¯å£
struct InMemoryUserRepository {
    users: std::collections::HashMap<u64, User>,
}

impl UserRepository for InMemoryUserRepository {
    fn find_by_id(&self, id: u64) -> Option<User> {
        self.users.get(&id).cloned()
    }
    
    fn save(&mut self, user: User) -> Result<(), String> {
        self.users.insert(user.id, user);
        Ok(())
    }
}

// åº”ç”¨æœåŠ¡
struct UserService<R: UserRepository> {
    repository: R,
}

impl<R: UserRepository> UserService<R> {
    fn new(repository: R) -> Self {
        UserService { repository }
    }
    
    fn register_user(&mut self, name: String, email: String) -> Result<User, String> {
        let user = User {
            id: 1,  // ç®€åŒ–ç¤ºä¾‹
            name,
            email,
        };
        
        self.repository.save(user.clone())?;
        Ok(user)
    }
}
```

---

## ğŸ“š æœ€ä½³å®è·µ

1. **ä½¿ç”¨æ³›å‹å®ç°ç­–ç•¥æ¨¡å¼**: é›¶è¿è¡Œæ—¶å¼€é”€
2. **ç±»å‹çŠ¶æ€æ¨¡å¼**: ç¼–è¯‘æ—¶éªŒè¯çŠ¶æ€è½¬æ¢
3. **æ–°ç±»å‹æ¨¡å¼**: ç±»å‹å®‰å…¨çš„é¢†åŸŸæ¨¡å‹
4. **RAII æ¨¡å¼**: è‡ªåŠ¨èµ„æºç®¡ç†
5. **ä¾èµ–æ³¨å…¥**: ä½¿ç”¨æ³›å‹å’Œ trait objects

---

## ğŸ“ å­¦ä¹ æ£€éªŒ

1. **å®ç°è§‚å¯Ÿè€…æ¨¡å¼**: ä½¿ç”¨ç±»å‹å®‰å…¨çš„æ–¹å¼
2. **è®¾è®¡å¹¶å‘ç³»ç»Ÿ**: ä½¿ç”¨ Actor æ¨¡å¼
3. **æ„å»ºå¼‚æ­¥ç®¡é“**: å¤„ç†æ•°æ®æµ
4. **ç±»å‹é©±åŠ¨è®¾è®¡**: å®ç°ç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ

---

**è¿”å›**: [Tier 4 ç´¢å¼•](./README.md) | **ä¸Šä¸€ç« **: [04_ç±»å‹çº§ç¼–ç¨‹](./04_ç±»å‹çº§ç¼–ç¨‹.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
