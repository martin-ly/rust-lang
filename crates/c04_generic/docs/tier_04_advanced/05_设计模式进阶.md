# 05 设计模式进阶

> **文档类型**: Tier 4 - 高级主题  
> **目标读者**: 架构师和高级开发者  
> **预计学习时间**: 5-6 小时  
> **前置知识**: 设计模式基础、并发编程、异步编程

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**难度等级**: ⭐⭐⭐⭐

---

## 📋 目录

- [05 设计模式进阶](#05-设计模式进阶)
  - [📋 目录](#-目录)
  - [🎯 学习目标](#-学习目标)
  - [1️⃣ 泛型设计模式](#1️⃣-泛型设计模式)
    - [策略模式 (Strategy Pattern)](#策略模式-strategy-pattern)
    - [访问者模式 (Visitor Pattern)](#访问者模式-visitor-pattern)
  - [2️⃣ 并发设计模式](#2️⃣-并发设计模式)
    - [Actor 模式](#actor-模式)
    - [管道模式 (Pipeline Pattern)](#管道模式-pipeline-pattern)
  - [3️⃣ 异步设计模式](#3️⃣-异步设计模式)
    - [异步 Actor 模式](#异步-actor-模式)
    - [异步流水线](#异步流水线)
  - [4️⃣ 类型驱动设计](#4️⃣-类型驱动设计)
    - [新类型模式增强](#新类型模式增强)
    - [类型状态构建器](#类型状态构建器)
  - [5️⃣ 资源管理模式](#5️⃣-资源管理模式)
    - [RAII (Resource Acquisition Is Initialization)](#raii-resource-acquisition-is-initialization)
  - [🎯 架构模式](#-架构模式)
    - [六边形架构 (Hexagonal Architecture)](#六边形架构-hexagonal-architecture)
  - [📚 最佳实践](#-最佳实践)
  - [🎓 学习检验](#-学习检验)

本章探讨在 Rust 中应用高级设计模式，特别关注：

- 泛型与设计模式的结合
- 并发设计模式
- 异步设计模式
- 零成本抽象的架构模式
- 类型驱动的设计

---

## 🎯 学习目标

完成本章后，你将能够：

- ✅ 应用泛型实现经典设计模式
- ✅ 设计类型安全的并发系统
- ✅ 构建高性能的异步架构
- ✅ 使用类型系统强制执行架构约束
- ✅ 设计零开销的抽象层

---

## 1️⃣ 泛型设计模式

### 策略模式 (Strategy Pattern)

使用泛型和 trait 实现策略模式，零运行时开销。

```rust
// 排序策略 trait
trait SortStrategy<T> {
    fn sort(&self, data: &mut [T]);
}

// 快速排序策略
struct QuickSort;
impl<T: Ord> SortStrategy<T> for QuickSort {
    fn sort(&self, data: &mut [T]) {
        data.sort_unstable();
    }
}

// 归并排序策略
struct MergeSort;
impl<T: Ord> SortStrategy<T> for MergeSort {
    fn sort(&self, data: &mut [T]) {
        data.sort();
    }
}

// 上下文（使用泛型，零运行时开销）
struct Sorter<T, S: SortStrategy<T>> {
    strategy: S,
    _marker: std::marker::PhantomData<T>,
}

impl<T: Ord, S: SortStrategy<T>> Sorter<T, S> {
    fn new(strategy: S) -> Self {
        Sorter {
            strategy,
            _marker: std::marker::PhantomData,
        }
    }

    fn sort(&self, data: &mut [T]) {
        self.strategy.sort(data);
    }
}

// 使用（编译时决定策略，零开销）
fn example() {
    let mut data = vec![3, 1, 4, 1, 5, 9, 2, 6];
    
    let sorter = Sorter::new(QuickSort);
    sorter.sort(&mut data);
    
    let sorter = Sorter::new(MergeSort);
    sorter.sort(&mut data);
}
```

### 访问者模式 (Visitor Pattern)

```rust
// 表达式 AST
enum Expr {
    Number(i32),
    Add(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
}

// 访问者 trait
trait ExprVisitor {
    type Output;
    
    fn visit_number(&mut self, n: i32) -> Self::Output;
    fn visit_add(&mut self, left: &Expr, right: &Expr) -> Self::Output;
    fn visit_mul(&mut self, left: &Expr, right: &Expr) -> Self::Output;
}

impl Expr {
    fn accept<V: ExprVisitor>(&self, visitor: &mut V) -> V::Output {
        match self {
            Expr::Number(n) => visitor.visit_number(*n),
            Expr::Add(left, right) => visitor.visit_add(left, right),
            Expr::Mul(left, right) => visitor.visit_mul(left, right),
        }
    }
}

// 求值访问者
struct Evaluator;
impl ExprVisitor for Evaluator {
    type Output = i32;
    
    fn visit_number(&mut self, n: i32) -> i32 {
        n
    }
    
    fn visit_add(&mut self, left: &Expr, right: &Expr) -> i32 {
        left.accept(self) + right.accept(self)
    }
    
    fn visit_mul(&mut self, left: &Expr, right: &Expr) -> i32 {
        left.accept(self) * right.accept(self)
    }
}

// 打印访问者
struct Printer;
impl ExprVisitor for Printer {
    type Output = String;
    
    fn visit_number(&mut self, n: i32) -> String {
        n.to_string()
    }
    
    fn visit_add(&mut self, left: &Expr, right: &Expr) -> String {
        format!("({} + {})", left.accept(self), right.accept(self))
    }
    
    fn visit_mul(&mut self, left: &Expr, right: &Expr) -> String {
        format!("({} * {})", left.accept(self), right.accept(self))
    }
}
```

---

## 2️⃣ 并发设计模式

### Actor 模式

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

// Actor trait
trait Actor: Send + 'static {
    type Message: Send;
    
    fn handle(&mut self, msg: Self::Message);
}

// Actor 上下文
struct ActorContext<A: Actor> {
    actor: A,
    receiver: Receiver<A::Message>,
}

impl<A: Actor> ActorContext<A> {
    fn new(actor: A, receiver: Receiver<A::Message>) -> Self {
        ActorContext { actor, receiver }
    }
    
    fn run(mut self) {
        while let Ok(msg) = self.receiver.recv() {
            self.actor.handle(msg);
        }
    }
}

// Actor 句柄
struct ActorHandle<M: Send> {
    sender: Sender<M>,
}

impl<M: Send> ActorHandle<M> {
    fn send(&self, msg: M) -> Result<(), String> {
        self.sender.send(msg).map_err(|_| "Send failed".to_string())
    }
}

// 生成 Actor
fn spawn_actor<A: Actor>(actor: A) -> ActorHandle<A::Message> {
    let (sender, receiver) = channel();
    let context = ActorContext::new(actor, receiver);
    
    thread::spawn(move || {
        context.run();
    });
    
    ActorHandle { sender }
}

// 示例 Actor
struct CounterActor {
    count: i32,
}

enum CounterMessage {
    Increment,
    Decrement,
    GetCount(Sender<i32>),
}

impl Actor for CounterActor {
    type Message = CounterMessage;
    
    fn handle(&mut self, msg: CounterMessage) {
        match msg {
            CounterMessage::Increment => self.count += 1,
            CounterMessage::Decrement => self.count -= 1,
            CounterMessage::GetCount(sender) => {
                let _ = sender.send(self.count);
            }
        }
    }
}
```

### 管道模式 (Pipeline Pattern)

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

// 管道阶段 trait
trait Stage<Input, Output>: Send + 'static {
    fn process(&mut self, input: Input) -> Output;
}

// 创建管道阶段
fn spawn_stage<S, I, O>(mut stage: S) -> (Sender<I>, Receiver<O>)
where
    S: Stage<I, O>,
    I: Send + 'static,
    O: Send + 'static,
{
    let (input_tx, input_rx) = channel();
    let (output_tx, output_rx) = channel();
    
    thread::spawn(move || {
        while let Ok(input) = input_rx.recv() {
            let output = stage.process(input);
            if output_tx.send(output).is_err() {
                break;
            }
        }
    });
    
    (input_tx, output_rx)
}

// 示例：数据处理管道
struct ParseStage;
impl Stage<String, i32> for ParseStage {
    fn process(&mut self, input: String) -> i32 {
        input.parse().unwrap_or(0)
    }
}

struct DoubleStage;
impl Stage<i32, i32> for DoubleStage {
    fn process(&mut self, input: i32) -> i32 {
        input * 2
    }
}

struct FormatStage;
impl Stage<i32, String> for FormatStage {
    fn process(&mut self, input: i32) -> String {
        format!("Result: {}", input)
    }
}

// 构建管道
fn build_pipeline() -> (Sender<String>, Receiver<String>) {
    let (parse_in, parse_out) = spawn_stage(ParseStage);
    let (double_in, double_out) = spawn_stage(DoubleStage);
    let (format_in, format_out) = spawn_stage(FormatStage);
    
    // 连接阶段
    thread::spawn(move || {
        while let Ok(value) = parse_out.recv() {
            if double_in.send(value).is_err() {
                break;
            }
        }
    });
    
    thread::spawn(move || {
        while let Ok(value) = double_out.recv() {
            if format_in.send(value).is_err() {
                break;
            }
        }
    });
    
    (parse_in, format_out)
}
```

---

## 3️⃣ 异步设计模式

### 异步 Actor 模式

```rust
use tokio::sync::mpsc;
use async_trait::async_trait;

// 异步 Actor trait
#[async_trait]
trait AsyncActor: Send + 'static {
    type Message: Send;
    
    async fn handle(&mut self, msg: Self::Message);
}

// 异步 Actor 系统
struct AsyncActorSystem<A: AsyncActor> {
    actor: A,
    receiver: mpsc::Receiver<A::Message>,
}

impl<A: AsyncActor> AsyncActorSystem<A> {
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            self.actor.handle(msg).await;
        }
    }
}

// 生成异步 Actor
fn spawn_async_actor<A: AsyncActor>(actor: A) -> mpsc::Sender<A::Message> {
    let (sender, receiver) = mpsc::channel(100);
    let system = AsyncActorSystem { actor, receiver };
    
    tokio::spawn(async move {
        system.run().await;
    });
    
    sender
}
```

### 异步流水线

```rust
use tokio::sync::mpsc;
use async_trait::async_trait;
use futures::StreamExt;

// 异步转换 trait
#[async_trait]
trait AsyncTransform<I, O>: Send + Sync {
    async fn transform(&self, input: I) -> O;
}

// 异步管道
struct AsyncPipeline<I, O> {
    input: mpsc::Receiver<I>,
    output: mpsc::Sender<O>,
}

impl<I: Send + 'static, O: Send + 'static> AsyncPipeline<I, O> {
    async fn process<T>(
        mut self,
        transform: T,
    ) where
        T: AsyncTransform<I, O> + 'static,
    {
        while let Some(input) = self.input.recv().await {
            let output = transform.transform(input).await;
            if self.output.send(output).await.is_err() {
                break;
            }
        }
    }
}
```

---

## 4️⃣ 类型驱动设计

### 新类型模式增强

```rust
// 强类型 Email
struct Email(String);

impl Email {
    fn new(s: String) -> Result<Self, String> {
        if s.contains('@') {
            Ok(Email(s))
        } else {
            Err("Invalid email".to_string())
        }
    }
    
    fn as_str(&self) -> &str {
        &self.0
    }
}

// 强类型 UserId
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct UserId(u64);

// 强类型 Timestamp
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Timestamp(u64);

// 类型安全的 API
fn send_email(user_id: UserId, email: Email, timestamp: Timestamp) {
    println!("Sending email to user {:?} at {:?}: {}", 
        user_id, timestamp, email.as_str());
}

// 编译时防止参数混淆
fn type_safe_example() {
    let user_id = UserId(12345);
    let email = Email::new("user@example.com".to_string()).unwrap();
    let timestamp = Timestamp(1234567890);
    
    send_email(user_id, email, timestamp);
    
    // 编译错误：类型不匹配
    // send_email(timestamp, email, user_id);
}
```

### 类型状态构建器

```rust
use std::marker::PhantomData;

// 构建器状态
struct NoUrl;
struct HasUrl;
struct NoMethod;
struct HasMethod;

// HTTP 请求构建器
struct RequestBuilder<U, M> {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
    body: Option<String>,
    _url_state: PhantomData<U>,
    _method_state: PhantomData<M>,
}

impl RequestBuilder<NoUrl, NoMethod> {
    fn new() -> Self {
        RequestBuilder {
            url: None,
            method: None,
            headers: Vec::new(),
            body: None,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<M> RequestBuilder<NoUrl, M> {
    fn url(self, url: impl Into<String>) -> RequestBuilder<HasUrl, M> {
        RequestBuilder {
            url: Some(url.into()),
            method: self.method,
            headers: self.headers,
            body: self.body,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U> RequestBuilder<U, NoMethod> {
    fn method(self, method: impl Into<String>) -> RequestBuilder<U, HasMethod> {
        RequestBuilder {
            url: self.url,
            method: Some(method.into()),
            headers: self.headers,
            body: self.body,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U, M> RequestBuilder<U, M> {
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
    
    fn body(mut self, body: String) -> Self {
        self.body = Some(body);
        self
    }
}

impl RequestBuilder<HasUrl, HasMethod> {
    // 只有同时设置了 URL 和 Method 才能构建
    fn build(self) -> Request {
        Request {
            url: self.url.unwrap(),
            method: self.method.unwrap(),
            headers: self.headers,
            body: self.body,
        }
    }
}

struct Request {
    url: String,
    method: String,
    headers: Vec<(String, String)>,
    body: Option<String>,
}
```

---

## 5️⃣ 资源管理模式

### RAII (Resource Acquisition Is Initialization)

```rust
use std::fs::File;
use std::io::{self, Write};

// 自动管理文件的 RAII 包装器
struct ManagedFile {
    file: File,
    path: String,
}

impl ManagedFile {
    fn new(path: impl Into<String>) -> io::Result<Self> {
        let path = path.into();
        let file = File::create(&path)?;
        Ok(ManagedFile { file, path })
    }
    
    fn write(&mut self, data: &[u8]) -> io::Result<()> {
        self.file.write_all(data)
    }
}

impl Drop for ManagedFile {
    fn drop(&mut self) {
        println!("Closing file: {}", self.path);
        // 文件自动关闭
    }
}

// Scope Guard 模式
struct ScopeGuard<F: FnOnce()> {
    cleanup: Option<F>,
}

impl<F: FnOnce()> ScopeGuard<F> {
    fn new(cleanup: F) -> Self {
        ScopeGuard {
            cleanup: Some(cleanup),
        }
    }
}

impl<F: FnOnce()> Drop for ScopeGuard<F> {
    fn drop(&mut self) {
        if let Some(cleanup) = self.cleanup.take() {
            cleanup();
        }
    }
}

// 使用示例
fn scope_guard_example() {
    let _guard = ScopeGuard::new(|| {
        println!("Cleaning up resources");
    });
    
    // 执行操作...
    println!("Doing work");
    
    // _guard 在作用域结束时自动调用清理函数
}
```

---

## 🎯 架构模式

### 六边形架构 (Hexagonal Architecture)

```rust
// 领域模型
struct User {
    id: u64,
    name: String,
    email: String,
}

// 端口 (Port) - 领域层接口
trait UserRepository {
    fn find_by_id(&self, id: u64) -> Option<User>;
    fn save(&mut self, user: User) -> Result<(), String>;
}

// 适配器 (Adapter) - 实现端口
struct InMemoryUserRepository {
    users: std::collections::HashMap<u64, User>,
}

impl UserRepository for InMemoryUserRepository {
    fn find_by_id(&self, id: u64) -> Option<User> {
        self.users.get(&id).cloned()
    }
    
    fn save(&mut self, user: User) -> Result<(), String> {
        self.users.insert(user.id, user);
        Ok(())
    }
}

// 应用服务
struct UserService<R: UserRepository> {
    repository: R,
}

impl<R: UserRepository> UserService<R> {
    fn new(repository: R) -> Self {
        UserService { repository }
    }
    
    fn register_user(&mut self, name: String, email: String) -> Result<User, String> {
        let user = User {
            id: 1,  // 简化示例
            name,
            email,
        };
        
        self.repository.save(user.clone())?;
        Ok(user)
    }
}
```

---

## 📚 最佳实践

1. **使用泛型实现策略模式**: 零运行时开销
2. **类型状态模式**: 编译时验证状态转换
3. **新类型模式**: 类型安全的领域模型
4. **RAII 模式**: 自动资源管理
5. **依赖注入**: 使用泛型和 trait objects

---

## 🎓 学习检验

1. **实现观察者模式**: 使用类型安全的方式
2. **设计并发系统**: 使用 Actor 模式
3. **构建异步管道**: 处理数据流
4. **类型驱动设计**: 实现类型安全的配置系统

---

**返回**: [Tier 4 索引](./README.md) | **上一章**: [04_类型级编程](./04_类型级编程.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-22  
**文档状态**: ✅ 完成
