# 02 æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§ä¸»é¢˜  
> **ç›®æ ‡è¯»è€…**: é«˜çº§åˆ°ä¸“å®¶çº§å¼€å‘è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 5-7 å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: æ·±å…¥ç†è§£ç”Ÿå‘½å‘¨æœŸã€é«˜çº§ Trait Boundsã€æ³›å‹ç³»ç»Ÿ

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [02 æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ](#02-æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1ï¸âƒ£ HRTB (Higher-Ranked Trait Bounds)](#1ï¸âƒ£-hrtb-higher-ranked-trait-bounds)
    - [ä»€ä¹ˆæ˜¯ HRTBï¼Ÿ](#ä»€ä¹ˆæ˜¯-hrtb)
    - [åŸºç¡€ç¤ºä¾‹](#åŸºç¡€ç¤ºä¾‹)
    - [HRTB çš„å®é™…åº”ç”¨](#hrtb-çš„å®é™…åº”ç”¨)
    - [HRTB ä¸ç”Ÿå‘½å‘¨æœŸæ¨æ–­](#hrtb-ä¸ç”Ÿå‘½å‘¨æœŸæ¨æ–­)
  - [2ï¸âƒ£ å‹å˜ (Variance) å’Œå­ç±»å‹ (Subtyping)](#2ï¸âƒ£-å‹å˜-variance-å’Œå­ç±»å‹-subtyping)
    - [å‹å˜åŸºç¡€](#å‹å˜åŸºç¡€)
    - [åå˜ç¤ºä¾‹](#åå˜ç¤ºä¾‹)
    - [é€†å˜ç¤ºä¾‹](#é€†å˜ç¤ºä¾‹)
    - [ä¸å˜ç¤ºä¾‹](#ä¸å˜ç¤ºä¾‹)
    - [å‹å˜è§„åˆ™è¡¨](#å‹å˜è§„åˆ™è¡¨)
  - [3ï¸âƒ£ ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™](#3ï¸âƒ£-ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™)
    - [Rust çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™](#rust-çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™)
    - [ç”Ÿå‘½å‘¨æœŸæ¨æ–­çš„å±€é™æ€§](#ç”Ÿå‘½å‘¨æœŸæ¨æ–­çš„å±€é™æ€§)
  - [4ï¸âƒ£ å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯](#4ï¸âƒ£-å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯)
    - [åœºæ™¯ 1: å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°](#åœºæ™¯-1-å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°)
    - [åœºæ™¯ 2: ç”Ÿå‘½å‘¨æœŸçº¦æŸ](#åœºæ™¯-2-ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
    - [åœºæ™¯ 3: ç”Ÿå‘½å‘¨æœŸä¸ Trait](#åœºæ™¯-3-ç”Ÿå‘½å‘¨æœŸä¸-trait)
  - [5ï¸âƒ£ è‡ªå¼•ç”¨ç»“æ„ä½“](#5ï¸âƒ£-è‡ªå¼•ç”¨ç»“æ„ä½“)
    - [ä¸ºä»€ä¹ˆè‡ªå¼•ç”¨æ˜¯å›°éš¾çš„ï¼Ÿ](#ä¸ºä»€ä¹ˆè‡ªå¼•ç”¨æ˜¯å›°éš¾çš„)
    - [è§£å†³æ–¹æ¡ˆ 1: Pin å’Œ PhantomPinned](#è§£å†³æ–¹æ¡ˆ-1-pin-å’Œ-phantompinned)
    - [è§£å†³æ–¹æ¡ˆ 2: ä½¿ç”¨ rental æ¨¡å¼](#è§£å†³æ–¹æ¡ˆ-2-ä½¿ç”¨-rental-æ¨¡å¼)
    - [è§£å†³æ–¹æ¡ˆ 3: ä½¿ç”¨ç´¢å¼•ä»£æ›¿å¼•ç”¨](#è§£å†³æ–¹æ¡ˆ-3-ä½¿ç”¨ç´¢å¼•ä»£æ›¿å¼•ç”¨)
  - [6ï¸âƒ£ GATs (Generic Associated Types)](#6ï¸âƒ£-gats-generic-associated-types)
    - [GATs åŸºç¡€ (Rust 1.65+ ç¨³å®š)](#gats-åŸºç¡€-rust-165-ç¨³å®š)
    - [GATs çš„é«˜çº§åº”ç”¨](#gats-çš„é«˜çº§åº”ç”¨)
  - [ğŸ¯ å®æˆ˜é¡¹ç›®](#-å®æˆ˜é¡¹ç›®)
    - [é¡¹ç›® 1: å®ç°ä¸€ä¸ªå€Ÿç”¨æ„ŸçŸ¥çš„å›¾æ•°æ®ç»“æ„](#é¡¹ç›®-1-å®ç°ä¸€ä¸ªå€Ÿç”¨æ„ŸçŸ¥çš„å›¾æ•°æ®ç»“æ„)
    - [é¡¹ç›® 2: å¼‚æ­¥è§£æå™¨æ¡†æ¶](#é¡¹ç›®-2-å¼‚æ­¥è§£æå™¨æ¡†æ¶)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ“ å­¦ä¹ æ£€éªŒ](#-å­¦ä¹ æ£€éªŒ)

æœ¬ç« å°†æ·±å…¥æ¢è®¨æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸçš„é«˜çº§äº¤äº’ï¼Œè¿™æ˜¯ Rust ç±»å‹ç³»ç»Ÿä¸­æœ€å¤æ‚ä½†ä¹Ÿæœ€å¼ºå¤§çš„éƒ¨åˆ†ã€‚

**ä¸»è¦ä¸»é¢˜**:

- HRTB (Higher-Ranked Trait Bounds) é«˜é˜¶ Trait è¾¹ç•Œ
- å‹å˜ (Variance) å’Œå­ç±»å‹ (Subtyping)
- ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™
- å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯
- è‡ªå¼•ç”¨ç»“æ„ä½“
- GATs (Generic Associated Types) 1.65+ ç¨³å®šç‰¹æ€§

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬ç« åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£å¹¶åº”ç”¨ HRTB è§£å†³é«˜é˜¶ç”Ÿå‘½å‘¨æœŸé—®é¢˜
- âœ… æŒæ¡å‹å˜çš„æ¦‚å¿µå¹¶æ­£ç¡®ä½¿ç”¨
- âœ… å¤„ç†å¤æ‚çš„è‡ªå¼•ç”¨æ•°æ®ç»“æ„
- âœ… ä½¿ç”¨ GATs æ„å»ºé«˜çº§æŠ½è±¡
- âœ… ç†è§£ç”Ÿå‘½å‘¨æœŸæ¨æ–­çš„åº•å±‚æœºåˆ¶
- âœ… è§£å†³é«˜çº§å€Ÿç”¨æ£€æŸ¥é—®é¢˜

---

## 1ï¸âƒ£ HRTB (Higher-Ranked Trait Bounds)

### ä»€ä¹ˆæ˜¯ HRTBï¼Ÿ

HRTB å…è®¸æˆ‘ä»¬è¡¨è¾¾"å¯¹äºæ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ"çš„çº¦æŸï¼Œè€Œä¸æ˜¯"å¯¹äºæŸä¸ªç‰¹å®šç”Ÿå‘½å‘¨æœŸ"ã€‚

**è¯­æ³•**: `for<'a>` - "å¯¹äºæ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ 'a"

### åŸºç¡€ç¤ºä¾‹

```rust
// ä¸ä½¿ç”¨ HRTB - å—é™
fn process<'a, F>(f: F)
where
    F: Fn(&'a str) -> &'a str,
{
    let result = f("hello");
    println!("{}", result);
}

// ä½¿ç”¨ HRTB - æ›´çµæ´»
fn process_hrtb<F>(f: F)
where
    F: for<'a> Fn(&'a str) -> &'a str,  // å¯¹äºä»»ä½•ç”Ÿå‘½å‘¨æœŸ 'a
{
    let result = f("hello");
    println!("{}", result);
    
    let result2 = f("world");  // å¯ä»¥å¤šæ¬¡è°ƒç”¨ï¼Œæ¯æ¬¡ä½¿ç”¨ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
    println!("{}", result2);
}

fn example() {
    // HRTB å…è®¸é—­åŒ…é€‚åº”ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
    process_hrtb(|s| s);
}
```

### HRTB çš„å®é™…åº”ç”¨

**æ¡ˆä¾‹ 1: é€šç”¨çš„è¿­ä»£å™¨æ˜ å°„**:

```rust
trait Mapper {
    fn map<'a>(&self, input: &'a str) -> &'a str;
}

struct IdentityMapper;

impl Mapper for IdentityMapper {
    fn map<'a>(&self, input: &'a str) -> &'a str {
        input
    }
}

// ä½¿ç”¨ HRTB å¤„ç†ä»»æ„ Mapper
fn apply_mapper<M>(mapper: &M, items: Vec<&str>) -> Vec<&str>
where
    M: for<'a> Fn(&'a str) -> &'a str,  // HRTB
{
    items.into_iter().map(|s| mapper(s)).collect()
}
```

**æ¡ˆä¾‹ 2: é—­åŒ…ä½œä¸º Trait è¾¹ç•Œ**:

```rust
// æ ‡å‡†åº“ä¸­çš„ Fn trait è‡ªåŠ¨ä½¿ç”¨ HRTB
fn call_with_data<F>(f: F)
where
    F: Fn(&str),  // å®é™…ä¸Šæ˜¯ for<'a> Fn(&'a str)
{
    f("data1");
    f("data2");
}

fn example() {
    call_with_data(|s| println!("{}", s));
}
```

### HRTB ä¸ç”Ÿå‘½å‘¨æœŸæ¨æ–­

```rust
use std::fmt::Debug;

// å¤æ‚çš„ HRTB åœºæ™¯
trait Processor {
    type Output;
    fn process<'a>(&self, input: &'a str) -> Self::Output;
}

fn use_processor<P>(processor: &P)
where
    P: for<'a> Processor,
    for<'a> <P as Processor>::Output: Debug,  // è¾“å‡ºç±»å‹å¯¹æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸéƒ½å®ç° Debug
{
    let result = processor.process("test");
    println!("{:?}", result);
}
```

---

## 2ï¸âƒ£ å‹å˜ (Variance) å’Œå­ç±»å‹ (Subtyping)

### å‹å˜åŸºç¡€

**ä¸‰ç§å‹å˜ç±»å‹**:

1. **åå˜ (Covariant)**: `'a: 'b` â‡’ `T<'a>: T<'b>`
2. **é€†å˜ (Contravariant)**: `'a: 'b` â‡’ `T<'b>: T<'a>`
3. **ä¸å˜ (Invariant)**: æ²¡æœ‰å­ç±»å‹å…³ç³»

### åå˜ç¤ºä¾‹

```rust
// &'a T å¯¹ 'a æ˜¯åå˜çš„
fn covariant_example<'a, 'b: 'a>(longer: &'b str) -> &'a str {
    // 'b æ¯” 'a é•¿ï¼Œåå˜å…è®¸è¿™ç§è½¬æ¢
    longer  // &'b str å¯ä»¥è½¬æ¢ä¸º &'a str
}

// å®é™…åº”ç”¨
struct Container<'a> {
    data: &'a str,
}

fn extend_lifetime<'short, 'long: 'short>(
    container: Container<'long>,
) -> Container<'short> {
    // Container<'a> å¯¹ 'a æ˜¯åå˜çš„
    container
}
```

### é€†å˜ç¤ºä¾‹

```rust
// Fn(&'a T) å¯¹ 'a æ˜¯é€†å˜çš„
fn contravariant_example() {
    // é•¿ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°å¯ä»¥ç”¨äºçŸ­ç”Ÿå‘½å‘¨æœŸ
    let long_fn: fn(&'static str) = |s| println!("{}", s);
    
    let short_data = String::from("hello");
    let short_fn: fn(&str) = long_fn;  // OK: 'static -> 'short
    short_fn(&short_data);
}
```

### ä¸å˜ç¤ºä¾‹

```rust
use std::cell::Cell;

// Cell<'a> å¯¹ 'a æ˜¯ä¸å˜çš„
fn invariant_example() {
    let cell: Cell<&'static str> = Cell::new("static");
    
    // ç¼–è¯‘é”™è¯¯ï¼šCell æ˜¯ä¸å˜çš„ï¼Œä¸èƒ½æ”¹å˜ç”Ÿå‘½å‘¨æœŸ
    // let cell2: Cell<&str> = cell;
}

// ä¸ºä»€ä¹ˆ &mut T æ˜¯ä¸å˜çš„ï¼Ÿ
fn why_mut_is_invariant() {
    let mut data = "hello".to_string();
    let mut_ref: &mut &str = &mut (&data[..] as &str);
    
    // å¦‚æœ &mut &'a str å¯¹ 'a åå˜ï¼Œå¯èƒ½å¯¼è‡´æ‚¬å‚å¼•ç”¨
    // *mut_ref = &String::from("temp")[..];  // ä¸´æ—¶å€¼ï¼Œç”Ÿå‘½å‘¨æœŸå¤ªçŸ­
}
```

### å‹å˜è§„åˆ™è¡¨

| ç±»å‹ | 'a çš„å‹å˜ | T çš„å‹å˜ |
|------|----------|---------|
| `&'a T` | åå˜ | åå˜ |
| `&'a mut T` | åå˜ | **ä¸å˜** |
| `Box<T>` | - | åå˜ |
| `Vec<T>` | - | åå˜ |
| `Cell<T>` | - | **ä¸å˜** |
| `Fn(&'a T) -> U` | **é€†å˜** | åå˜ (U) |
| `*const T` | - | åå˜ |
| `*mut T` | - | **ä¸å˜** |

---

## 3ï¸âƒ£ ç”Ÿå‘½å‘¨æœŸæ¨æ–­è§„åˆ™

### Rust çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

**ä¸‰æ¡è§„åˆ™**:

1. æ¯ä¸ªå¼•ç”¨å‚æ•°è·å¾—ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
2. å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡º
3. å¦‚æœæœ‰ `&self` æˆ– `&mut self`ï¼Œ`self` çš„ç”Ÿå‘½å‘¨æœŸèµ‹äºˆæ‰€æœ‰è¾“å‡º

```rust
// è§„åˆ™ 1: æ¯ä¸ªå‚æ•°ç‹¬ç«‹ç”Ÿå‘½å‘¨æœŸ
fn rule1(x: &str, y: &str) {}
// å±•å¼€ä¸º: fn rule1<'a, 'b>(x: &'a str, y: &'b str)

// è§„åˆ™ 2: å•ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸ
fn rule2(x: &str) -> &str { x }
// å±•å¼€ä¸º: fn rule2<'a>(x: &'a str) -> &'a str

// è§„åˆ™ 3: self çš„ç”Ÿå‘½å‘¨æœŸ
struct Parser<'a> {
    data: &'a str,
}

impl<'a> Parser<'a> {
    fn parse(&self) -> &str { self.data }
    // å±•å¼€ä¸º: fn parse<'b>(&'b self) -> &'b str
}
```

### ç”Ÿå‘½å‘¨æœŸæ¨æ–­çš„å±€é™æ€§

```rust
// ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½æ¨æ–­
// fn problematic<'a>(x: &'a str, y: &str) -> &str {
//     if x.len() > y.len() { x } else { y }
// }

// æ­£ç¡®ï¼šæ˜¾å¼æ ‡æ³¨
fn fixed<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

---

## 4ï¸âƒ£ å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯

### åœºæ™¯ 1: å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
struct Parser<'input, 'output> {
    input: &'input str,
    output: Option<&'output str>,
}

impl<'input, 'output> Parser<'input, 'output> {
    fn new(input: &'input str) -> Self {
        Parser {
            input,
            output: None,
        }
    }

    fn parse(&mut self, data: &'output str) {
        self.output = Some(data);
    }
}

// ä½¿ç”¨ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
fn example() {
    let input = String::from("input data");
    let mut parser = Parser::new(&input);

    {
        let output = String::from("output data");
        parser.parse(&output);
        // output çš„ç”Ÿå‘½å‘¨æœŸåœ¨è¿™é‡Œç»“æŸ
    }

    // parser.output å·²ç»å¤±æ•ˆ
}
```

### åœºæ™¯ 2: ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rust
// 'a: 'b è¡¨ç¤º 'a æ¯” 'b æ´»å¾—æ›´ä¹…
struct Context<'long, 'short>
where
    'long: 'short,  // 'long å¿…é¡»æ¯” 'short é•¿
{
    long_lived: &'long str,
    short_lived: &'short str,
}

fn create_context<'a, 'b>(long: &'a str, short: &'b str) -> Context<'a, 'b>
where
    'a: 'b,
{
    Context {
        long_lived: long,
        short_lived: short,
    }
}
```

### åœºæ™¯ 3: ç”Ÿå‘½å‘¨æœŸä¸ Trait

```rust
trait Processor<'a> {
    type Output;
    fn process(&self, input: &'a str) -> Self::Output;
}

struct StringProcessor;

impl<'a> Processor<'a> for StringProcessor {
    type Output = &'a str;

    fn process(&self, input: &'a str) -> &'a str {
        input
    }
}

// ä½¿ç”¨ HRTB
fn use_any_processor<P>(processor: &P, inputs: Vec<&str>)
where
    P: for<'a> Processor<'a, Output = &'a str>,
{
    for input in inputs {
        let result = processor.process(input);
        println!("{}", result);
    }
}
```

---

## 5ï¸âƒ£ è‡ªå¼•ç”¨ç»“æ„ä½“

### ä¸ºä»€ä¹ˆè‡ªå¼•ç”¨æ˜¯å›°éš¾çš„ï¼Ÿ

```rust
// ä¸å®‰å…¨çš„è‡ªå¼•ç”¨ï¼ˆä¼šå¯¼è‡´æ‚¬å‚æŒ‡é’ˆï¼‰
// struct SelfReferential {
//     data: String,
//     ptr: &str,  // æŒ‡å‘ data
// }

// fn create() -> SelfReferential {
//     let data = String::from("hello");
//     let ptr = &data[..];
//     SelfReferential { data, ptr }  // ç§»åŠ¨å ptr å¤±æ•ˆï¼
// }
```

### è§£å†³æ–¹æ¡ˆ 1: Pin å’Œ PhantomPinned

```rust
use std::marker::PhantomPinned;
use std::pin::Pin;
use std::ptr::NonNull;

struct SelfReferential {
    data: String,
    ptr: Option<NonNull<String>>,
    _pin: PhantomPinned,
}

impl SelfReferential {
    fn new(data: String) -> Pin<Box<Self>> {
        let mut boxed = Box::pin(SelfReferential {
            data,
            ptr: None,
            _pin: PhantomPinned,
        });

        // å®‰å…¨ï¼šä½¿ç”¨ unsafe è®¾ç½®è‡ªå¼•ç”¨
        let self_ptr: NonNull<String> = NonNull::from(&boxed.data);
        unsafe {
            let mut_ref = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).ptr = Some(self_ptr);
        }

        boxed
    }

    fn get_data(&self) -> &str {
        &self.data
    }

    fn get_ptr_data(&self) -> Option<&String> {
        self.ptr.map(|ptr| unsafe { ptr.as_ref() })
    }
}
```

### è§£å†³æ–¹æ¡ˆ 2: ä½¿ç”¨ rental æ¨¡å¼

```rust
// ä½¿ç”¨ ouroboros crateï¼ˆæ¨èï¼‰
use ouroboros::self_referencing;

#[self_referencing]
struct MyStruct {
    data: String,
    #[borrows(data)]
    data_ref: &'this str,
}

fn example() {
    let my_struct = MyStructBuilder {
        data: "Hello".to_string(),
        data_ref_builder: |data| &data[..],
    }.build();

    my_struct.with_data_ref(|ref_| println!("{}", ref_));
}
```

### è§£å†³æ–¹æ¡ˆ 3: ä½¿ç”¨ç´¢å¼•ä»£æ›¿å¼•ç”¨

```rust
struct Arena {
    data: Vec<String>,
}

struct Handle(usize);

impl Arena {
    fn new() -> Self {
        Arena { data: Vec::new() }
    }

    fn add(&mut self, s: String) -> Handle {
        let index = self.data.len();
        self.data.push(s);
        Handle(index)
    }

    fn get(&self, handle: Handle) -> &str {
        &self.data[handle.0]
    }
}

// ä½¿ç”¨å¥æŸ„è€Œä¸æ˜¯å¼•ç”¨
struct Node {
    value: String,
    parent: Option<Handle>,
}
```

---

## 6ï¸âƒ£ GATs (Generic Associated Types)

### GATs åŸºç¡€ (Rust 1.65+ ç¨³å®š)

```rust
trait Container {
    type Item<'a> where Self: 'a;

    fn get<'a>(&'a self) -> Self::Item<'a>;
}

// å®ç° 1: å¼•ç”¨å®¹å™¨
struct RefContainer<T> {
    data: Vec<T>,
}

impl<T> Container for RefContainer<T> {
    type Item<'a> = &'a T where T: 'a;

    fn get<'a>(&'a self) -> &'a T {
        &self.data[0]
    }
}

// å®ç° 2: æ‹¥æœ‰å€¼çš„å®¹å™¨
struct OwnedContainer<T: Clone> {
    data: Vec<T>,
}

impl<T: Clone> Container for OwnedContainer<T> {
    type Item<'a> = T where T: 'a;

    fn get<'a>(&'a self) -> T {
        self.data[0].clone()
    }
}
```

### GATs çš„é«˜çº§åº”ç”¨

**æ¡ˆä¾‹ 1: é€šç”¨è¿­ä»£å™¨ Trait**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;

    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// å®ç°ï¼šçª—å£è¿­ä»£å™¨
struct WindowsIterator<'data, T> {
    data: &'data [T],
    window_size: usize,
    pos: usize,
}

impl<'data, T> LendingIterator for WindowsIterator<'data, T> {
    type Item<'a> = &'a [T] where Self: 'a;

    fn next<'a>(&'a mut self) -> Option<&'a [T]> {
        if self.pos + self.window_size <= self.data.len() {
            let window = &self.data[self.pos..self.pos + self.window_size];
            self.pos += 1;
            Some(window)
        } else {
            None
        }
    }
}
```

**æ¡ˆä¾‹ 2: å¼‚æ­¥ Trait**:

```rust
trait AsyncIterator {
    type Item<'a> where Self: 'a;

    async fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// å®ç°ï¼šå¼‚æ­¥æ•°æ®æµ
struct AsyncStream<T> {
    buffer: Vec<T>,
    pos: usize,
}

impl<T> AsyncIterator for AsyncStream<T> {
    type Item<'a> = &'a T where T: 'a;

    async fn next<'a>(&'a mut self) -> Option<&'a T> {
        if self.pos < self.buffer.len() {
            let item = &self.buffer[self.pos];
            self.pos += 1;
            Some(item)
        } else {
            None
        }
    }
}
```

---

## ğŸ¯ å®æˆ˜é¡¹ç›®

### é¡¹ç›® 1: å®ç°ä¸€ä¸ªå€Ÿç”¨æ„ŸçŸ¥çš„å›¾æ•°æ®ç»“æ„

ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå’Œ GATs å®ç°ä¸€ä¸ªå®‰å…¨çš„å›¾ç»“æ„ï¼Œæ”¯æŒï¼š

- èŠ‚ç‚¹ä¹‹é—´çš„å¼•ç”¨
- éå†ä¸ä¼šäº§ç”Ÿæ‚¬å‚æŒ‡é’ˆ
- ç¼–è¯‘æ—¶ä¿è¯å†…å­˜å®‰å…¨

### é¡¹ç›® 2: å¼‚æ­¥è§£æå™¨æ¡†æ¶

ä½¿ç”¨ HRTB å’Œ GATs å®ç°ä¸€ä¸ªé€šç”¨çš„å¼‚æ­¥è§£æå™¨æ¡†æ¶ï¼š

- æ”¯æŒæµå¼è§£æ
- é›¶æ‹·è´æ“ä½œ
- ç±»å‹å®‰å…¨çš„ç»„åˆå­

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

**æ¨èèµ„æº**:

1. [Rust Nomicon - Lifetimes](https://doc.rust-lang.org/nomicon/lifetimes.html)
2. [Subtyping and Variance](https://doc.rust-lang.org/nomicon/subtyping.html)
3. [RFC 1598 - GATs](https://rust-lang.github.io/rfcs/1598-generic_associated_types.html)
4. [Pin and Unpin](https://doc.rust-lang.org/std/pin/)

**ç›¸å…³ Crates**:

- [`ouroboros`](https://crates.io/crates/ouroboros) - è‡ªå¼•ç”¨ç»“æ„ä½“
- [`pin-project`](https://crates.io/crates/pin-project) - Pin æŠ•å½±
- [`rental`](https://crates.io/crates/rental) - è‡ªå¼•ç”¨ï¼ˆå·²å¼ƒç”¨ï¼Œç”¨ ouroborosï¼‰

---

## ğŸ“ å­¦ä¹ æ£€éªŒ

1. **HRTB**: è§£é‡Š `for<'a>` çš„å«ä¹‰ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªå®é™…åº”ç”¨åœºæ™¯
2. **å‹å˜**: è¯´æ˜ä¸ºä»€ä¹ˆ `&mut T` å¯¹ `T` æ˜¯ä¸å˜çš„
3. **è‡ªå¼•ç”¨**: å®ç°ä¸€ä¸ªå®‰å…¨çš„è‡ªå¼•ç”¨é“¾è¡¨èŠ‚ç‚¹
4. **GATs**: ä½¿ç”¨ GATs å®ç°ä¸€ä¸ªé€šç”¨çš„æµ Trait

---

**è¿”å›**: [Tier 4 ç´¢å¼•](./README.md) | **ä¸Šä¸€ç« **: [01_é«˜çº§ç±»å‹æŠ€å·§](./01_é«˜çº§ç±»å‹æŠ€å·§.md) | **ä¸‹ä¸€ç« **: [03_é›¶æˆæœ¬æŠ½è±¡](./03_é›¶æˆæœ¬æŠ½è±¡.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
