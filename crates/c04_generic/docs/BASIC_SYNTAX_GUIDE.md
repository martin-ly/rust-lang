# Rust æ³›å‹åŸºç¡€è¯­æ³•å…¨é¢æŒ‡å—

> **æ–‡æ¡£å®šä½**: å…¨é¢ç³»ç»Ÿçš„æ³›å‹è¯­æ³•å‚è€ƒæŒ‡å—ï¼ŒåŒ…å«å¤§é‡å®è·µä»£ç ç¤ºä¾‹  
> **å…ˆä¿®çŸ¥è¯†**: RuståŸºç¡€è¯­æ³•  
> **ç›¸å…³æ–‡æ¡£**: [æ³›å‹åŸºç¡€](./generic_fundamentals.md) | [å®è·µæŒ‡å—](./PRACTICAL_GENERICS_GUIDE.md) | [ä¸»ç´¢å¼•](./00_MASTER_INDEX.md)

**æœ€åæ›´æ–°**: 2025-10-19  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.0+ (éƒ¨åˆ†é«˜çº§ç‰¹æ€§éœ€è¦æ›´é«˜ç‰ˆæœ¬)  
**éš¾åº¦ç­‰çº§**: â­â­â­  
**æ–‡æ¡£ç±»å‹**: ğŸ“– å‚è€ƒæ‰‹å†Œ

---

## ğŸ“‹ æœ¬æ–‡å†…å®¹

æœ¬æŒ‡å—å…¨é¢ä»‹ç»äº† Rust æ³›å‹ç¼–ç¨‹çš„åŸºç¡€è¯­æ³•å’Œæ¦‚å¿µï¼ŒåŒ…æ‹¬è¯¦ç»†çš„ä»£ç ç¤ºä¾‹ã€æœ€ä½³å®è·µå’Œå®é™…åº”ç”¨åœºæ™¯ã€‚é€‚åˆåˆå­¦è€…å’Œæœ‰ä¸€å®šç»éªŒçš„å¼€å‘è€…æ·±å…¥å­¦ä¹  Rust æ³›å‹ç³»ç»Ÿã€‚

---

## ç›®å½•

- [Rust æ³›å‹åŸºç¡€è¯­æ³•å…¨é¢æŒ‡å—](#rust-æ³›å‹åŸºç¡€è¯­æ³•å…¨é¢æŒ‡å—)
  - [ğŸ“‹ æœ¬æ–‡å†…å®¹](#-æœ¬æ–‡å†…å®¹)
  - [ç›®å½•](#ç›®å½•)
  - [æ³›å‹åŸºç¡€æ¦‚å¿µ](#æ³›å‹åŸºç¡€æ¦‚å¿µ)
    - [ä»€ä¹ˆæ˜¯æ³›å‹ï¼Ÿ](#ä»€ä¹ˆæ˜¯æ³›å‹)
    - [æ³›å‹çš„ä¼˜åŠ¿](#æ³›å‹çš„ä¼˜åŠ¿)
    - [åŸºæœ¬è¯­æ³•](#åŸºæœ¬è¯­æ³•)
  - [æ³›å‹å‡½æ•°](#æ³›å‹å‡½æ•°)
    - [åŸºæœ¬æ³›å‹å‡½æ•°](#åŸºæœ¬æ³›å‹å‡½æ•°)
    - [å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°](#å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°)
    - [å¤šç±»å‹å‚æ•°å‡½æ•°](#å¤šç±»å‹å‚æ•°å‡½æ•°)
    - [å¤æ‚çº¦æŸç¤ºä¾‹](#å¤æ‚çº¦æŸç¤ºä¾‹)
  - [æ³›å‹ç»“æ„ä½“](#æ³›å‹ç»“æ„ä½“)
    - [åŸºæœ¬æ³›å‹ç»“æ„ä½“](#åŸºæœ¬æ³›å‹ç»“æ„ä½“)
    - [å¤šç±»å‹å‚æ•°ç»“æ„ä½“](#å¤šç±»å‹å‚æ•°ç»“æ„ä½“)
    - [å¤æ‚æ³›å‹ç»“æ„ä½“](#å¤æ‚æ³›å‹ç»“æ„ä½“)
  - [æ³›å‹æšä¸¾](#æ³›å‹æšä¸¾)
    - [åŸºæœ¬æ³›å‹æšä¸¾](#åŸºæœ¬æ³›å‹æšä¸¾)
    - [å•å‚æ•°æ³›å‹æšä¸¾](#å•å‚æ•°æ³›å‹æšä¸¾)
  - [æ³›å‹æ–¹æ³•å®ç°](#æ³›å‹æ–¹æ³•å®ç°)
    - [åŸºæœ¬æ³›å‹æ–¹æ³•](#åŸºæœ¬æ³›å‹æ–¹æ³•)
    - [ç‰¹å®šç±»å‹çš„æ–¹æ³•å®ç°](#ç‰¹å®šç±»å‹çš„æ–¹æ³•å®ç°)
    - [å¸¦çº¦æŸçš„æ³›å‹æ–¹æ³•](#å¸¦çº¦æŸçš„æ³›å‹æ–¹æ³•)
  - [ç”Ÿå‘½å‘¨æœŸå‚æ•°](#ç”Ÿå‘½å‘¨æœŸå‚æ•°)
    - [åŸºæœ¬ç”Ÿå‘½å‘¨æœŸå‚æ•°](#åŸºæœ¬ç”Ÿå‘½å‘¨æœŸå‚æ•°)
    - [ç”Ÿå‘½å‘¨æœŸå‚æ•°å‡½æ•°](#ç”Ÿå‘½å‘¨æœŸå‚æ•°å‡½æ•°)
    - [å¤šç”Ÿå‘½å‘¨æœŸå‚æ•°](#å¤šç”Ÿå‘½å‘¨æœŸå‚æ•°)
  - [æ³›å‹ trait å®ç°](#æ³›å‹-trait-å®ç°)
    - [åŸºæœ¬æ³›å‹ trait](#åŸºæœ¬æ³›å‹-trait)
    - [å…·ä½“ç±»å‹å®ç°](#å…·ä½“ç±»å‹å®ç°)
    - [æ³›å‹å‡½æ•°ä½¿ç”¨ trait](#æ³›å‹å‡½æ•°ä½¿ç”¨-trait)
  - [é«˜çº§æ³›å‹æ¨¡å¼](#é«˜çº§æ³›å‹æ¨¡å¼)
    - [ç±»å‹æ ‡è®°æ¨¡å¼](#ç±»å‹æ ‡è®°æ¨¡å¼)
    - [çŠ¶æ€æœºæ¨¡å¼](#çŠ¶æ€æœºæ¨¡å¼)
    - [æ„å»ºå™¨æ¨¡å¼](#æ„å»ºå™¨æ¨¡å¼)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. åˆç†ä½¿ç”¨æ³›å‹çº¦æŸ](#1-åˆç†ä½¿ç”¨æ³›å‹çº¦æŸ)
    - [2. ç”Ÿå‘½å‘¨æœŸç®¡ç†](#2-ç”Ÿå‘½å‘¨æœŸç®¡ç†)
    - [3. ç±»å‹å®‰å…¨](#3-ç±»å‹å®‰å…¨)
    - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
  - [å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ](#å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ)
    - [1. ç±»å‹æ¨æ–­å¤±è´¥](#1-ç±»å‹æ¨æ–­å¤±è´¥)
    - [2. ç”Ÿå‘½å‘¨æœŸé”™è¯¯](#2-ç”Ÿå‘½å‘¨æœŸé”™è¯¯)
    - [3. æ³›å‹çº¦æŸé”™è¯¯](#3-æ³›å‹çº¦æŸé”™è¯¯)
    - [4. æ‰€æœ‰æƒé—®é¢˜](#4-æ‰€æœ‰æƒé—®é¢˜)
  - [æ€»ç»“](#æ€»ç»“)
  - [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)

## æ³›å‹åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯æ³›å‹ï¼Ÿ

æ³›å‹æ˜¯ Rust ä¸­ä¸€ç§å¼ºå¤§çš„æŠ½è±¡æœºåˆ¶ï¼Œå…è®¸æˆ‘ä»¬ç¼–å†™å¯ä»¥å¤„ç†å¤šç§ç±»å‹çš„ä»£ç ï¼Œè€Œä¸éœ€è¦ä¸ºæ¯ç§ç±»å‹é‡å¤ç¼–å†™ç›¸åŒçš„é€»è¾‘ã€‚

### æ³›å‹çš„ä¼˜åŠ¿

1. **ä»£ç å¤ç”¨**ï¼šä¸€æ¬¡ç¼–å†™ï¼Œå¤šç§ç±»å‹ä½¿ç”¨
2. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé›¶æˆæœ¬æŠ½è±¡
4. **çµæ´»æ€§**ï¼šæ”¯æŒå¤æ‚çš„ç±»å‹ç»„åˆ

### åŸºæœ¬è¯­æ³•

```rust
// æ³›å‹å‡½æ•°
fn identity<T>(value: T) -> T {
    value
}

// æ³›å‹ç»“æ„ä½“
struct Wrapper<T> {
    value: T,
}

// æ³›å‹æšä¸¾
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

## æ³›å‹å‡½æ•°

### åŸºæœ¬æ³›å‹å‡½æ•°

```rust
/// æ³›å‹æ’ç­‰å‡½æ•° - æœ€ç®€å•çš„æ³›å‹å‡½æ•°ç¤ºä¾‹
/// 
/// # å‚æ•°
/// * `value` - ä»»æ„ç±»å‹çš„å€¼
/// 
/// # è¿”å›å€¼
/// è¿”å›ç›¸åŒç±»å‹çš„å€¼
/// 
/// # ç¤ºä¾‹
/// ```
/// let x = identity(42);
/// let y = identity("hello");
/// ```
pub fn identity<T>(value: T) -> T {
    value
}
```

### å¸¦çº¦æŸçš„æ³›å‹å‡½æ•°

```rust
/// æ³›å‹æœ€å¤§å€¼å‡½æ•° - å±•ç¤º trait çº¦æŸ
/// 
/// # å‚æ•°
/// * `a` - ç¬¬ä¸€ä¸ªå€¼
/// * `b` - ç¬¬äºŒä¸ªå€¼
/// 
/// # è¿”å›å€¼
/// è¿”å›è¾ƒå¤§çš„å€¼
/// 
/// # çº¦æŸ
/// T å¿…é¡»å®ç° PartialOrd å’Œ Copy trait
/// 
/// # ç¤ºä¾‹
/// ```
/// let max_val = max(10, 20);
/// assert_eq!(max_val, 20);
/// ```
pub fn max<T>(a: T, b: T) -> T
where
    T: PartialOrd + Copy,
{
    if a > b { a } else { b }
}
```

### å¤šç±»å‹å‚æ•°å‡½æ•°

```rust
/// æ³›å‹äº¤æ¢å‡½æ•° - å±•ç¤ºæ³›å‹å‚æ•°çš„ä½¿ç”¨
/// 
/// # å‚æ•°
/// * `a` - ç¬¬ä¸€ä¸ªå€¼
/// * `b` - ç¬¬äºŒä¸ªå€¼
/// 
/// # è¿”å›å€¼
/// è¿”å›äº¤æ¢åçš„å…ƒç»„ (b, a)
/// 
/// # ç¤ºä¾‹
/// ```
/// let (x, y) = swap(1, 2);
/// assert_eq!(x, 2);
/// assert_eq!(y, 1);
/// ```
pub fn swap<T, U>(a: T, b: U) -> (U, T) {
    (b, a)
}
```

### å¤æ‚çº¦æŸç¤ºä¾‹

```rust
/// æ³›å‹æ‰“å°å‡½æ•° - å±•ç¤º Debug trait çº¦æŸ
/// 
/// # å‚æ•°
/// * `value` - éœ€è¦æ‰“å°çš„å€¼
/// 
/// # çº¦æŸ
/// T å¿…é¡»å®ç° Debug trait
/// 
/// # ç¤ºä¾‹
/// ```
/// print_debug(42);
/// print_debug("hello");
/// ```
pub fn print_debug<T>(value: T)
where
    T: Debug,
{
    println!("è°ƒè¯•ä¿¡æ¯: {:?}", value);
}
```

## æ³›å‹ç»“æ„ä½“

### åŸºæœ¬æ³›å‹ç»“æ„ä½“

```rust
/// æ³›å‹åŒ…è£…å™¨ç»“æ„ä½“
/// 
/// è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ³›å‹ç»“æ„ä½“ï¼Œå¯ä»¥åŒ…è£…ä»»æ„ç±»å‹çš„å€¼
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - è¢«åŒ…è£…çš„å€¼çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let wrapper = Wrapper::new(42);
/// let value = wrapper.get();
/// ```
#[derive(Debug, Clone, PartialEq)]
pub struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    /// åˆ›å»ºæ–°çš„åŒ…è£…å™¨å®ä¾‹
    /// 
    /// # å‚æ•°
    /// * `value` - è¦åŒ…è£…çš„å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ Wrapper å®ä¾‹
    pub fn new(value: T) -> Self {
        Self { value }
    }

    /// è·å–åŒ…è£…çš„å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›åŒ…è£…çš„å€¼çš„å¼•ç”¨
    pub fn get(&self) -> &T {
        &self.value
    }

    /// è·å–åŒ…è£…çš„å€¼ï¼ˆå¯å˜å¼•ç”¨ï¼‰
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›åŒ…è£…çš„å€¼çš„å¯å˜å¼•ç”¨
    pub fn get_mut(&mut self) -> &mut T {
        &mut self.value
    }

    /// è§£åŒ…å¹¶è¿”å›å†…éƒ¨å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›åŒ…è£…çš„å€¼ï¼Œæ¶ˆè´¹ Wrapper
    pub fn unwrap(self) -> T {
        self.value
    }
}
```

### å¤šç±»å‹å‚æ•°ç»“æ„ä½“

```rust
/// æ³›å‹å¯¹ç»“æ„ä½“ - å±•ç¤ºå¤šä¸ªç±»å‹å‚æ•°
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - ç¬¬ä¸€ä¸ªå€¼çš„ç±»å‹
/// * `U` - ç¬¬äºŒä¸ªå€¼çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let pair = Pair::new(42, "hello");
/// ```
#[derive(Debug, Clone, PartialEq)]
pub struct Pair<T, U> {
    pub first: T,
    pub second: U,
}

impl<T, U> Pair<T, U> {
    /// åˆ›å»ºæ–°çš„å¯¹å®ä¾‹
    /// 
    /// # å‚æ•°
    /// * `first` - ç¬¬ä¸€ä¸ªå€¼
    /// * `second` - ç¬¬äºŒä¸ªå€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ Pair å®ä¾‹
    pub fn new(first: T, second: U) -> Self {
        Self { first, second }
    }

    /// äº¤æ¢å¯¹ä¸­çš„å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›äº¤æ¢åçš„æ–°å¯¹
    pub fn swap(self) -> Pair<U, T> {
        Pair {
            first: self.second,
            second: self.first,
        }
    }
}
```

### å¤æ‚æ³›å‹ç»“æ„ä½“

```rust
/// æ³›å‹èŠ‚ç‚¹ç»“æ„ä½“ - å±•ç¤ºæ›´å¤æ‚çš„æ³›å‹ç»“æ„ä½“
/// 
/// è¿™ä¸ªç»“æ„ä½“å±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„é“¾è¡¨èŠ‚ç‚¹
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - èŠ‚ç‚¹å­˜å‚¨çš„æ•°æ®ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let node = Node::new(42);
/// ```
#[derive(Debug, Clone)]
pub struct Node<T> {
    pub data: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T> Node<T> {
    /// åˆ›å»ºæ–°çš„èŠ‚ç‚¹
    /// 
    /// # å‚æ•°
    /// * `data` - èŠ‚ç‚¹å­˜å‚¨çš„æ•°æ®
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ Node å®ä¾‹
    pub fn new(data: T) -> Self {
        Self {
            data,
            next: None,
        }
    }

    /// è®¾ç½®ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    /// 
    /// # å‚æ•°
    /// * `next` - ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    pub fn set_next(&mut self, next: Node<T>) {
        self.next = Some(Box::new(next));
    }

    /// è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› None
    pub fn get_next(&self) -> Option<&Node<T>> {
        self.next.as_ref().map(|node| node.as_ref())
    }
}
```

## æ³›å‹æšä¸¾

### åŸºæœ¬æ³›å‹æšä¸¾

```rust
/// æ³›å‹ç»“æœæšä¸¾ - å±•ç¤ºæ³›å‹æšä¸¾çš„åŸºæœ¬ç”¨æ³•
/// 
/// è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ Result ç±»å‹ï¼Œç”¨äºæ¼”ç¤ºæ³›å‹æšä¸¾
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - æˆåŠŸå€¼çš„ç±»å‹
/// * `E` - é”™è¯¯å€¼çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let success: MyResult<i32, String> = MyResult::Ok(42);
/// let error: MyResult<i32, String> = MyResult::Err("å‡ºé”™äº†".to_string());
/// ```
#[derive(Debug, Clone, PartialEq)]
pub enum MyResult<T, E> {
    /// æˆåŠŸæƒ…å†µï¼ŒåŒ…å«å€¼
    Ok(T),
    /// é”™è¯¯æƒ…å†µï¼ŒåŒ…å«é”™è¯¯ä¿¡æ¯
    Err(E),
}

impl<T, E> MyResult<T, E> {
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæˆåŠŸç»“æœ
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœæ˜¯ Ok åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn is_ok(&self) -> bool {
        matches!(self, MyResult::Ok(_))
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºé”™è¯¯ç»“æœ
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœæ˜¯ Err åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn is_err(&self) -> bool {
        matches!(self, MyResult::Err(_))
    }

    /// è·å–æˆåŠŸå€¼ï¼Œå¦‚æœæ˜¯é”™è¯¯åˆ™ panic
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æˆåŠŸå€¼
    /// 
    /// # Panics
    /// å¦‚æœç»“æœæ˜¯é”™è¯¯åˆ™ panic
    pub fn unwrap(self) -> T {
        match self {
            MyResult::Ok(value) => value,
            MyResult::Err(_) => panic!("å°è¯•è§£åŒ…é”™è¯¯ç»“æœ"),
        }
    }

    /// è·å–æˆåŠŸå€¼ï¼Œå¦‚æœæ˜¯é”™è¯¯åˆ™è¿”å›é»˜è®¤å€¼
    /// 
    /// # å‚æ•°
    /// * `default` - é»˜è®¤å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æˆåŠŸå€¼æˆ–é»˜è®¤å€¼
    pub fn unwrap_or(self, default: T) -> T {
        match self {
            MyResult::Ok(value) => value,
            MyResult::Err(_) => default,
        }
    }
}
```

### å•å‚æ•°æ³›å‹æšä¸¾

```rust
/// æ³›å‹é€‰é¡¹æšä¸¾ - å±•ç¤ºå•å‚æ•°æ³›å‹æšä¸¾
/// 
/// è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ Option ç±»å‹
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - å€¼çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let some: MyOption<i32> = MyOption::Some(42);
/// let none: MyOption<i32> = MyOption::None;
/// ```
#[derive(Debug, Clone, PartialEq)]
pub enum MyOption<T> {
    /// æœ‰å€¼çš„æƒ…å†µ
    Some(T),
    /// æ— å€¼çš„æƒ…å†µ
    None,
}

impl<T> MyOption<T> {
    /// æ£€æŸ¥æ˜¯å¦æœ‰å€¼
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœæ˜¯ Some åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn is_some(&self) -> bool {
        matches!(self, MyOption::Some(_))
    }

    /// æ£€æŸ¥æ˜¯å¦æ— å€¼
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœæ˜¯ None åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn is_none(&self) -> bool {
        matches!(self, MyOption::None)
    }

    /// è·å–å€¼ï¼Œå¦‚æœæ˜¯ None åˆ™ panic
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›å€¼
    /// 
    /// # Panics
    /// å¦‚æœæ˜¯ None åˆ™ panic
    pub fn unwrap(self) -> T {
        match self {
            MyOption::Some(value) => value,
            MyOption::None => panic!("å°è¯•è§£åŒ… None å€¼"),
        }
    }

    /// è·å–å€¼ï¼Œå¦‚æœæ˜¯ None åˆ™è¿”å›é»˜è®¤å€¼
    /// 
    /// # å‚æ•°
    /// * `default` - é»˜è®¤å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›å€¼æˆ–é»˜è®¤å€¼
    pub fn unwrap_or(self, default: T) -> T {
        match self {
            MyOption::Some(value) => value,
            MyOption::None => default,
        }
    }
}
```

## æ³›å‹æ–¹æ³•å®ç°

### åŸºæœ¬æ³›å‹æ–¹æ³•

```rust
/// æ³›å‹å®¹å™¨ç»“æ„ä½“
/// 
/// è¿™ä¸ªç»“æ„ä½“å±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„æ³›å‹å®¹å™¨
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - å®¹å™¨ä¸­å­˜å‚¨çš„å…ƒç´ ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let mut container = Container::new();
/// container.push(42);
/// let value = container.pop();
/// ```
#[derive(Debug, Clone)]
pub struct Container<T> {
    items: Vec<T>,
}

impl<T> Container<T> {
    /// åˆ›å»ºæ–°çš„ç©ºå®¹å™¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ç©ºå®¹å™¨
    pub fn new() -> Self {
        Self {
            items: Vec::new(),
        }
    }

    /// å‘å®¹å™¨ä¸­æ·»åŠ å…ƒç´ 
    /// 
    /// # å‚æ•°
    /// * `item` - è¦æ·»åŠ çš„å…ƒç´ 
    pub fn push(&mut self, item: T) {
        self.items.push(item);
    }

    /// ä»å®¹å™¨ä¸­ç§»é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´ 
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœå®¹å™¨ä¸ºç©ºåˆ™è¿”å› None
    pub fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }

    /// è·å–å®¹å™¨ä¸­å…ƒç´ çš„æ•°é‡
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›å…ƒç´ æ•°é‡
    pub fn len(&self) -> usize {
        self.items.len()
    }

    /// æ£€æŸ¥å®¹å™¨æ˜¯å¦ä¸ºç©º
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœå®¹å™¨ä¸ºç©ºåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
}
```

### ç‰¹å®šç±»å‹çš„æ–¹æ³•å®ç°

```rust
/// ä¸ºç‰¹å®šç±»å‹å®ç°ç‰¹æ®Šæ–¹æ³•
impl Container<String> {
    /// è¿æ¥æ‰€æœ‰å­—ç¬¦ä¸²å…ƒç´ 
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›è¿æ¥åçš„å­—ç¬¦ä¸²
    /// 
    /// # ç¤ºä¾‹
    /// ```
    /// let mut container = Container::new();
    /// container.push("Hello".to_string());
    /// container.push("World".to_string());
    /// let result = container.join();
    /// assert_eq!(result, "HelloWorld");
    /// ```
    pub fn join(&self) -> String {
        self.items.join("")
    }

    /// è¿æ¥æ‰€æœ‰å­—ç¬¦ä¸²å…ƒç´ ï¼Œä½¿ç”¨æŒ‡å®šåˆ†éš”ç¬¦
    /// 
    /// # å‚æ•°
    /// * `separator` - åˆ†éš”ç¬¦
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›è¿æ¥åçš„å­—ç¬¦ä¸²
    pub fn join_with(&self, separator: &str) -> String {
        self.items.join(separator)
    }
}
```

### å¸¦çº¦æŸçš„æ³›å‹æ–¹æ³•

```rust
/// ä¸ºå®ç°äº†ç‰¹å®š trait çš„ç±»å‹å®ç°æ–¹æ³•
impl<T> Container<T>
where
    T: Clone + PartialEq,
{
    /// æŸ¥æ‰¾æŒ‡å®šå…ƒç´ çš„ä½ç½®
    /// 
    /// # å‚æ•°
    /// * `item` - è¦æŸ¥æ‰¾çš„å…ƒç´ 
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›å…ƒç´ çš„ä½ç½®ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› None
    pub fn find(&self, item: &T) -> Option<usize> {
        self.items.iter().position(|x| x == item)
    }

    /// æ£€æŸ¥å®¹å™¨æ˜¯å¦åŒ…å«æŒ‡å®šå…ƒç´ 
    /// 
    /// # å‚æ•°
    /// * `item` - è¦æ£€æŸ¥çš„å…ƒç´ 
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœåŒ…å«åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn contains(&self, item: &T) -> bool {
        self.items.contains(item)
    }

    /// ç§»é™¤æŒ‡å®šå…ƒç´ 
    /// 
    /// # å‚æ•°
    /// * `item` - è¦ç§»é™¤çš„å…ƒç´ 
    /// 
    /// # è¿”å›å€¼
    /// å¦‚æœæ‰¾åˆ°å¹¶ç§»é™¤äº†å…ƒç´ åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
    pub fn remove_item(&mut self, item: &T) -> bool {
        if let Some(pos) = self.find(item) {
            self.items.remove(pos);
            true
        } else {
            false
        }
    }
}
```

## ç”Ÿå‘½å‘¨æœŸå‚æ•°

### åŸºæœ¬ç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
/// å¸¦ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„å¼•ç”¨åŒ…è£…å™¨
/// 
/// è¿™ä¸ªç»“æ„ä½“å±•ç¤ºå¦‚ä½•åœ¨æ³›å‹ä¸­ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°
/// 
/// # ç”Ÿå‘½å‘¨æœŸå‚æ•°
/// * `'a` - å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - å¼•ç”¨çš„å€¼çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let value = 42;
/// let wrapper = RefWrapper::new(&value);
/// ```
#[derive(Debug)]
pub struct RefWrapper<'a, T> {
    value: &'a T,
}

impl<'a, T> RefWrapper<'a, T> {
    /// åˆ›å»ºæ–°çš„å¼•ç”¨åŒ…è£…å™¨
    /// 
    /// # å‚æ•°
    /// * `value` - è¦åŒ…è£…çš„å¼•ç”¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ RefWrapper å®ä¾‹
    pub fn new(value: &'a T) -> Self {
        Self { value }
    }

    /// è·å–åŒ…è£…çš„å¼•ç”¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›åŒ…è£…çš„å¼•ç”¨
    pub fn get(&self) -> &'a T {
        self.value
    }
}
```

### ç”Ÿå‘½å‘¨æœŸå‚æ•°å‡½æ•°

```rust
/// æ¯”è¾ƒä¸¤ä¸ªå¼•ç”¨çš„å‡½æ•°
/// 
/// # ç”Ÿå‘½å‘¨æœŸå‚æ•°
/// * `'a` - å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - æ¯”è¾ƒçš„å€¼çš„ç±»å‹
/// 
/// # å‚æ•°
/// * `a` - ç¬¬ä¸€ä¸ªå¼•ç”¨
/// * `b` - ç¬¬äºŒä¸ªå¼•ç”¨
/// 
/// # è¿”å›å€¼
/// è¿”å›è¾ƒé•¿çš„å¼•ç”¨
/// 
/// # çº¦æŸ
/// T å¿…é¡»å®ç° PartialOrd trait
/// 
/// # ç¤ºä¾‹
/// ```
/// let x = 10;
/// let y = 20;
/// let longer = longer_ref(&x, &y);
/// ```
pub fn longer_ref<'a, T>(a: &'a T, b: &'a T) -> &'a T
where
    T: PartialOrd,
{
    if a > b { a } else { b }
}
```

### å¤šç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
/// æ³›å‹ç»“æ„ä½“ï¼ŒåŒ…å«å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
/// 
/// # ç”Ÿå‘½å‘¨æœŸå‚æ•°
/// * `'a` - ç¬¬ä¸€ä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
/// * `'b` - ç¬¬äºŒä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - ç¬¬ä¸€ä¸ªå€¼çš„ç±»å‹
/// * `U` - ç¬¬äºŒä¸ªå€¼çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let x = 42;
/// let y = "hello";
/// let pair = RefPair::new(&x, &y);
/// ```
#[derive(Debug)]
pub struct RefPair<'a, 'b, T, U> {
    first: &'a T,
    second: &'b U,
}

impl<'a, 'b, T, U> RefPair<'a, 'b, T, U> {
    /// åˆ›å»ºæ–°çš„å¼•ç”¨å¯¹
    /// 
    /// # å‚æ•°
    /// * `first` - ç¬¬ä¸€ä¸ªå¼•ç”¨
    /// * `second` - ç¬¬äºŒä¸ªå¼•ç”¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ RefPair å®ä¾‹
    pub fn new(first: &'a T, second: &'b U) -> Self {
        Self { first, second }
    }

    /// è·å–ç¬¬ä¸€ä¸ªå¼•ç”¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›ç¬¬ä¸€ä¸ªå¼•ç”¨
    pub fn first(&self) -> &'a T {
        self.first
    }

    /// è·å–ç¬¬äºŒä¸ªå¼•ç”¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›ç¬¬äºŒä¸ªå¼•ç”¨
    pub fn second(&self) -> &'b U {
        self.second
    }
}
```

## æ³›å‹ trait å®ç°

### åŸºæœ¬æ³›å‹ trait

```rust
/// å¯æ¯”è¾ƒ trait
/// 
/// è¿™ä¸ª trait å®šä¹‰äº†æ¯”è¾ƒæ“ä½œ
pub trait Comparable<T> {
    /// æ¯”è¾ƒä¸¤ä¸ªå€¼
    /// 
    /// # å‚æ•°
    /// * `other` - è¦æ¯”è¾ƒçš„å€¼
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ¯”è¾ƒç»“æœ
    fn compare(&self, other: &T) -> ComparisonResult;
}

/// æ¯”è¾ƒç»“æœæšä¸¾
#[derive(Debug, Clone, PartialEq)]
pub enum ComparisonResult {
    /// å°äº
    Less,
    /// ç­‰äº
    Equal,
    /// å¤§äº
    Greater,
}
```

### å…·ä½“ç±»å‹å®ç°

```rust
/// ä¸ºæ•´æ•°å®ç° Comparable trait
impl Comparable<i32> for i32 {
    fn compare(&self, other: &i32) -> ComparisonResult {
        if self < other {
            ComparisonResult::Less
        } else if self > other {
            ComparisonResult::Greater
        } else {
            ComparisonResult::Equal
        }
    }
}

/// ä¸ºå­—ç¬¦ä¸²å®ç° Comparable trait
impl Comparable<String> for String {
    fn compare(&self, other: &String) -> ComparisonResult {
        match self.cmp(other) {
            std::cmp::Ordering::Less => ComparisonResult::Less,
            std::cmp::Ordering::Equal => ComparisonResult::Equal,
            std::cmp::Ordering::Greater => ComparisonResult::Greater,
        }
    }
}
```

### æ³›å‹å‡½æ•°ä½¿ç”¨ trait

```rust
/// æ³›å‹æ¯”è¾ƒå‡½æ•°
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - æ¯”è¾ƒçš„å€¼çš„ç±»å‹
/// 
/// # å‚æ•°
/// * `a` - ç¬¬ä¸€ä¸ªå€¼
/// * `b` - ç¬¬äºŒä¸ªå€¼
/// 
/// # è¿”å›å€¼
/// è¿”å›æ¯”è¾ƒç»“æœ
/// 
/// # çº¦æŸ
/// T å¿…é¡»å®ç° Comparable<T> trait
/// 
/// # ç¤ºä¾‹
/// ```
/// let result = compare_values(10, 20);
/// ```
pub fn compare_values<T>(a: &T, b: &T) -> ComparisonResult
where
    T: Comparable<T>,
{
    a.compare(b)
}
```

## é«˜çº§æ³›å‹æ¨¡å¼

### ç±»å‹æ ‡è®°æ¨¡å¼

```rust
/// ç±»å‹æ ‡è®°ç»“æ„ä½“
/// 
/// è¿™ä¸ªç»“æ„ä½“ç”¨äºåœ¨ç±»å‹ç³»ç»Ÿä¸­æ ‡è®°ä¸åŒçš„çŠ¶æ€
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - æ ‡è®°çš„ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let marker = TypeMarker::<String>::new();
/// ```
#[derive(Debug, Clone, PartialEq)]
pub struct TypeMarker<T> {
    _phantom: PhantomData<T>,
}

impl<T> TypeMarker<T> {
    /// åˆ›å»ºæ–°çš„ç±»å‹æ ‡è®°
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ TypeMarker å®ä¾‹
    pub fn new() -> Self {
        Self {
            _phantom: PhantomData,
        }
    }
}
```

### çŠ¶æ€æœºæ¨¡å¼

```rust
/// çŠ¶æ€æœºç»“æ„ä½“
/// 
/// è¿™ä¸ªç»“æ„ä½“å±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„çŠ¶æ€æœº
/// 
/// # ç±»å‹å‚æ•°
/// * `State` - çŠ¶æ€ç±»å‹
/// * `Data` - æ•°æ®ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let state_machine = StateMachine::<Idle, i32>::new(42);
/// ```
#[derive(Debug)]
pub struct StateMachine<State, Data> {
    state: TypeMarker<State>,
    data: Data,
}

/// ç©ºé—²çŠ¶æ€æ ‡è®°
#[derive(Debug, Clone, PartialEq)]
pub struct Idle;

/// è¿è¡ŒçŠ¶æ€æ ‡è®°
#[derive(Debug, Clone, PartialEq)]
pub struct Running;

/// åœæ­¢çŠ¶æ€æ ‡è®°
#[derive(Debug, Clone, PartialEq)]
pub struct Stopped;

impl<State, Data> StateMachine<State, Data> {
    /// åˆ›å»ºæ–°çš„çŠ¶æ€æœº
    /// 
    /// # å‚æ•°
    /// * `data` - åˆå§‹æ•°æ®
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ StateMachine å®ä¾‹
    pub fn new(data: Data) -> Self {
        Self {
            state: TypeMarker::new(),
            data,
        }
    }

    /// è·å–æ•°æ®
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ•°æ®çš„å¼•ç”¨
    pub fn data(&self) -> &Data {
        &self.data
    }
}

/// ä¸ºç‰¹å®šçŠ¶æ€å®ç°æ–¹æ³•
impl<Data> StateMachine<Idle, Data> {
    /// å¯åŠ¨çŠ¶æ€æœº
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›è¿è¡ŒçŠ¶æ€çš„çŠ¶æ€æœº
    pub fn start(self) -> StateMachine<Running, Data> {
        StateMachine {
            state: TypeMarker::new(),
            data: self.data,
        }
    }
}
```

### æ„å»ºå™¨æ¨¡å¼

```rust
/// æ³›å‹æ„å»ºå™¨æ¨¡å¼
/// 
/// è¿™ä¸ªç»“æ„ä½“å±•ç¤ºäº†ä¸€ä¸ªæ³›å‹æ„å»ºå™¨
/// 
/// # ç±»å‹å‚æ•°
/// * `T` - æ„å»ºçš„ç›®æ ‡ç±»å‹
/// 
/// # ç¤ºä¾‹
/// ```
/// let builder = Builder::<String>::new();
/// let result = builder.add("Hello").add(" ").add("World").build();
/// ```
#[derive(Debug)]
pub struct Builder<T> {
    parts: Vec<T>,
}

impl<T> Builder<T> {
    /// åˆ›å»ºæ–°çš„æ„å»ºå™¨
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ–°çš„ Builder å®ä¾‹
    pub fn new() -> Self {
        Self {
            parts: Vec::new(),
        }
    }

    /// æ·»åŠ éƒ¨åˆ†
    /// 
    /// # å‚æ•°
    /// * `part` - è¦æ·»åŠ çš„éƒ¨åˆ†
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›æ„å»ºå™¨æœ¬èº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
    pub fn add(mut self, part: T) -> Self {
        self.parts.push(part);
        self
    }
}

/// ä¸ºå­—ç¬¦ä¸²æ„å»ºå™¨å®ç°ç‰¹æ®Šæ–¹æ³•
impl Builder<String> {
    /// æ„å»ºå­—ç¬¦ä¸²
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›è¿æ¥åçš„å­—ç¬¦ä¸²
    pub fn build(self) -> String {
        self.parts.join("")
    }

    /// ä½¿ç”¨åˆ†éš”ç¬¦æ„å»ºå­—ç¬¦ä¸²
    /// 
    /// # å‚æ•°
    /// * `separator` - åˆ†éš”ç¬¦
    /// 
    /// # è¿”å›å€¼
    /// è¿”å›è¿æ¥åçš„å­—ç¬¦ä¸²
    pub fn build_with_separator(self, separator: &str) -> String {
        self.parts.join(separator)
    }
}
```

## æœ€ä½³å®è·µ

### 1. åˆç†ä½¿ç”¨æ³›å‹çº¦æŸ

```rust
// å¥½çš„åšæ³•ï¼šæ˜ç¡®çš„çº¦æŸ
fn process_data<T>(data: T) -> T
where
    T: Clone + Debug + PartialEq,
{
    data
}

// é¿å…ï¼šè¿‡äºå®½æ³›çš„çº¦æŸ
fn bad_process_data<T>(data: T) -> T {
    data  // æ²¡æœ‰çº¦æŸï¼Œå¯èƒ½å¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
}
```

### 2. ç”Ÿå‘½å‘¨æœŸç®¡ç†

```rust
// å¥½çš„åšæ³•ï¼šæ˜ç¡®çš„ç”Ÿå‘½å‘¨æœŸ
fn get_reference<'a, T>(data: &'a [T], index: usize) -> Option<&'a T> {
    data.get(index)
}

// é¿å…ï¼šä¸å¿…è¦çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
fn bad_get_reference<'a, 'b, T>(data: &'a [T], index: usize) -> Option<&'b T> {
    data.get(index)  // ç”Ÿå‘½å‘¨æœŸä¸åŒ¹é…
}
```

### 3. ç±»å‹å®‰å…¨

```rust
// å¥½çš„åšæ³•ï¼šä½¿ç”¨ Option å¤„ç†å¯èƒ½å¤±è´¥çš„æ“ä½œ
fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

// é¿å…ï¼šç›´æ¥ panic
fn bad_divide(a: i32, b: i32) -> i32 {
    a / b  // å¦‚æœ b ä¸º 0 ä¼š panic
}
```

### 4. æ€§èƒ½ä¼˜åŒ–

```rust
// å¥½çš„åšæ³•ï¼šä½¿ç”¨å¼•ç”¨é¿å…ä¸å¿…è¦çš„å…‹éš†
fn process_large_data<T>(data: &[T]) -> usize
where
    T: Clone,
{
    data.len()  // ä¸éœ€è¦å…‹éš†æ•°æ®
}

// é¿å…ï¼šä¸å¿…è¦çš„å…‹éš†
fn bad_process_large_data<T>(data: Vec<T>) -> usize
where
    T: Clone,
{
    data.len()  // ä¼ é€’æ‰€æœ‰æƒï¼Œå¯èƒ½ä¸å¿…è¦
}
```

## å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### 1. ç±»å‹æ¨æ–­å¤±è´¥

```rust
// é—®é¢˜ï¼šç±»å‹æ¨æ–­å¤±è´¥
let result = data.into_iter().map(|x| x * 2).collect();  // é”™è¯¯

// è§£å†³æ–¹æ¡ˆï¼šæä¾›ç±»å‹æ³¨è§£
let result: Vec<i32> = data.into_iter().map(|x| x * 2).collect();
```

### 2. ç”Ÿå‘½å‘¨æœŸé”™è¯¯

```rust
// é—®é¢˜ï¼šç”Ÿå‘½å‘¨æœŸä¸åŒ¹é…
fn bad_function<'a, 'b>(data: &'a [i32]) -> &'b i32 {
    &data[0]  // é”™è¯¯ï¼š'a å’Œ 'b ä¸åŒ¹é…
}

// è§£å†³æ–¹æ¡ˆï¼šç»Ÿä¸€ç”Ÿå‘½å‘¨æœŸ
fn good_function<'a>(data: &'a [i32]) -> &'a i32 {
    &data[0]
}
```

### 3. æ³›å‹çº¦æŸé”™è¯¯

```rust
// é—®é¢˜ï¼šç¼ºå°‘å¿…è¦çš„çº¦æŸ
fn bad_function<T>(data: T) -> T {
    data.clone()  // é”™è¯¯ï¼šT å¯èƒ½ä¸å®ç° Clone
}

// è§£å†³æ–¹æ¡ˆï¼šæ·»åŠ çº¦æŸ
fn good_function<T>(data: T) -> T
where
    T: Clone,
{
    data.clone()
}
```

### 4. æ‰€æœ‰æƒé—®é¢˜

```rust
// é—®é¢˜ï¼šæ‰€æœ‰æƒè½¬ç§»
fn bad_function<T>(data: T) -> T {
    let result = data;
    result  // é”™è¯¯ï¼šdata å·²ç»è¢«ç§»åŠ¨
}

// è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨å¼•ç”¨æˆ–å…‹éš†
fn good_function<T>(data: &T) -> T
where
    T: Clone,
{
    data.clone()
}
```

## æ€»ç»“

Rust æ³›å‹ç³»ç»Ÿæ˜¯ä¸€ä¸ªå¼ºå¤§è€Œçµæ´»çš„å·¥å…·ï¼Œé€šè¿‡åˆç†ä½¿ç”¨å¯ä»¥ç¼–å†™å‡ºé«˜æ•ˆã€å®‰å…¨ã€å¯ç»´æŠ¤çš„ä»£ç ã€‚æœ¬æŒ‡å—æ¶µç›–äº†æ³›å‹ç¼–ç¨‹çš„åŸºç¡€æ¦‚å¿µå’Œé«˜çº§æ¨¡å¼ï¼ŒåŒ…æ‹¬ï¼š

1. **æ³›å‹å‡½æ•°**ï¼šå¤„ç†å¤šç§ç±»å‹çš„å‡½æ•°
2. **æ³›å‹ç»“æ„ä½“**ï¼šå¯ä»¥å­˜å‚¨ä»»æ„ç±»å‹çš„ç»“æ„ä½“
3. **æ³›å‹æšä¸¾**ï¼šå¯ä»¥è¡¨ç¤ºå¤šç§æƒ…å†µçš„æšä¸¾
4. **æ³›å‹æ–¹æ³•**ï¼šä¸ºæ³›å‹ç±»å‹å®ç°çš„æ–¹æ³•
5. **ç”Ÿå‘½å‘¨æœŸå‚æ•°**ï¼šç®¡ç†å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
6. **æ³›å‹ trait**ï¼šå®šä¹‰å¯é‡ç”¨çš„è¡Œä¸º
7. **é«˜çº§æ¨¡å¼**ï¼šå¤æ‚çš„è®¾è®¡æ¨¡å¼å®ç°

é€šè¿‡æŒæ¡è¿™äº›æ¦‚å¿µå’Œæœ€ä½³å®è·µï¼Œå¯ä»¥å……åˆ†åˆ©ç”¨ Rust æ³›å‹ç³»ç»Ÿçš„ä¼˜åŠ¿ï¼Œç¼–å†™å‡ºé«˜è´¨é‡çš„ä»£ç ã€‚

## å‚è€ƒèµ„æ–™

- [Rust æ³›å‹ç¼–ç¨‹æŒ‡å—](https://doc.rust-lang.org/book/ch10-00-generics.html)
- [Rust ç±»å‹ç³»ç»Ÿå‚è€ƒ](https://doc.rust-lang.org/reference/types.html)
- [Rust ç”Ÿå‘½å‘¨æœŸæŒ‡å—](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)
- [Rust æœ€ä½³å®è·µ](https://doc.rust-lang.org/book/ch17-00-oop.html)
