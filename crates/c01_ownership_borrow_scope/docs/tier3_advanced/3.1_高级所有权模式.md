# 3.1 高级所有权模式

**文档版本**: 2.0  
**适用 Rust 版本**: 1.90+  
**最后更新**: 2025-10-22  
**文档类型**: Tier 3 高级实践指南

---

## 📋 目录

- [3.1 高级所有权模式](#31-高级所有权模式)
  - [📋 目录](#-目录)
  - [文档概览](#文档概览)
    - [🎯 学习目标](#-学习目标)
    - [📚 前置知识](#-前置知识)
    - [🎨 文档特色](#-文档特色)
    - [📖 核心内容](#-核心内容)
  - [1. 内部可变性模式](#1-内部可变性模式)
    - [概念导航](#概念导航)
    - [1.1 RefCell 深度解析](#11-refcell-深度解析)
      - [核心原理](#核心原理)
      - [使用场景](#使用场景)
      - [常见陷阱 ⚠️](#常见陷阱-️)
      - [最佳实践 ✅](#最佳实践-)
    - [1.2 Cell 使用场景](#12-cell-使用场景)
      - [核心特点](#核心特点)
      - [适用场景](#适用场景)
      - [Cell vs RefCell 对比](#cell-vs-refcell-对比)
    - [1.3 并发内部可变性](#13-并发内部可变性)
      - [`Mutex<T>` - 互斥锁](#mutext---互斥锁)
      - [`RwLock<T>` - 读写锁](#rwlockt---读写锁)
      - [性能对比](#性能对比)
    - [1.4 选择指南](#14-选择指南)
      - [决策流程图](#决策流程图)
      - [选择矩阵](#选择矩阵)
      - [实例对比](#实例对比)
  - [2. 智能指针高级用法](#2-智能指针高级用法)
    - [2.1 Box 优化技巧](#21-box-优化技巧)
      - [基本用法](#基本用法)
      - [性能优化](#性能优化)
      - [常见陷阱](#常见陷阱)
    - [2.2 Rc 引用计数模式](#22-rc-引用计数模式)
      - [基本概念](#基本概念)
      - [高级模式](#高级模式)
      - [性能考虑](#性能考虑)
    - [2.3 Arc 跨线程共享](#23-arc-跨线程共享)
      - [基本使用](#基本使用)
      - [与 Mutex 配合](#与-mutex-配合)
      - [Rc vs Arc 对比](#rc-vs-arc-对比)
    - [2.4 Weak 弱引用](#24-weak-弱引用)
      - [解决循环引用](#解决循环引用)
      - [缓存模式](#缓存模式)
      - [观察者模式](#观察者模式)
  - [3. 复杂所有权设计](#3-复杂所有权设计)
    - [3.1 自引用结构](#31-自引用结构)
      - [问题描述](#问题描述)
      - [解决方案 1: Pin + Unsafe](#解决方案-1-pin--unsafe)
      - [解决方案 2: 使用索引](#解决方案-2-使用索引)
      - [解决方案 3: Rental/Ouroboros Crate](#解决方案-3-rentalouroboros-crate)
    - [3.2 树和图结构](#32-树和图结构)
      - [树结构实现](#树结构实现)
      - [图结构实现](#图结构实现)
    - [3.3 观察者模式](#33-观察者模式)
    - [3.4 状态机设计](#34-状态机设计)
  - [4. 实战案例](#4-实战案例)
    - [4.1 Web 服务器设计](#41-web-服务器设计)
    - [4.2 数据库连接池](#42-数据库连接池)
    - [4.3 缓存系统](#43-缓存系统)
    - [4.4 插件架构](#44-插件架构)
  - [相关资源](#相关资源)
    - [📖 核心文档](#-核心文档)
    - [🔗 相关主题](#-相关主题)
    - [📚 学习路径](#-学习路径)
    - [🎯 学习检查清单](#-学习检查清单)

---

## 文档概览

### 🎯 学习目标

完成本文档学习后，你将能够:

- ✅ 深入理解 Rust 的内部可变性模式及其使用场景
- ✅ 熟练运用各种智能指针解决复杂的所有权问题
- ✅ 设计和实现复杂的所有权结构（树、图、自引用）
- ✅ 在实际项目中应用高级所有权模式
- ✅ 识别和解决常见的所有权设计问题
- ✅ 在安全性、性能和可用性之间做出合理权衡

### 📚 前置知识

学习本文档前，你需要:

- ✅ 掌握基本的所有权、借用和生命周期概念
- ✅ 熟悉 Rust 的基本数据类型和控制流
- ✅ 了解 Trait 和泛型的基础知识
- ✅ 有一定的 Rust 编程实践经验

**推荐先学习**: [Tier 2 核心概念](../tier2_core_concepts/README.md)

### 🎨 文档特色

本文档提供:

- 📖 **深度解析**: 深入讲解每种模式的原理和实现
- 💡 **实践指南**: 提供丰富的代码示例和实战案例
- ⚠️ **常见陷阱**: 标注易错点和最佳实践
- 🔗 **知识关联**: 建立概念之间的联系
- 🏆 **性能优化**: 讨论不同方案的性能影响

### 📖 核心内容

**[📖 高级所有权模式完整文档](../03_advanced/01_advanced_ownership.md)**

本文档是对完整文档的深度解读和实践指南，包含更多的实战经验和设计建议。

---

## 1. 内部可变性模式

### 概念导航

**内部可变性 (Interior Mutability)** 是 Rust 中一个强大但需要谨慎使用的模式。它允许你在拥有不可变引用的情况下修改数据，通过将借用检查从编译时移到运行时实现。

### 1.1 RefCell 深度解析

#### 核心原理

`RefCell<T>` 提供了运行时借用检查机制:

- **编译时**: 正常的借用规则在编译时无法验证
- **运行时**: 通过 `borrow()` 和 `borrow_mut()` 在运行时检查借用规则
- **panic**: 违反借用规则会导致运行时 panic

#### 使用场景

✅ **适合使用 RefCell 的场景**:

1. **当你确信代码遵守借用规则，但编译器无法证明时**

   ```rust
   use std::cell::RefCell;
   
   struct Graph {
       nodes: Vec<RefCell<Node>>,
   }
   
   struct Node {
       edges: Vec<usize>,  // 存储节点索引
       data: String,
   }
   
   impl Graph {
       fn update_node(&self, index: usize, new_data: String) {
           // 即使 self 是不可变引用，也可以修改节点
           self.nodes[index].borrow_mut().data = new_data;
       }
   }
   ```

2. **实现复杂的内部状态管理**

   ```rust
   use std::cell::RefCell;
   
   struct Counter {
       // 即使 Counter 本身不可变，也能修改计数
       count: RefCell<u32>,
   }
   
   impl Counter {
       fn new() -> Self {
           Self { count: RefCell::new(0) }
       }
       
       // 注意：这里是 &self，不是 &mut self
       fn increment(&self) {
           *self.count.borrow_mut() += 1;
       }
       
       fn get(&self) -> u32 {
           *self.count.borrow()
       }
   }
   
   fn main() {
       let counter = Counter::new();  // 不可变绑定
       counter.increment();  // 但可以修改内部状态
       counter.increment();
       assert_eq!(counter.get(), 2);
   }
   ```

3. **与 Rc 配合实现共享可变状态**

   ```rust
   use std::rc::Rc;
   use std::cell::RefCell;
   
   type SharedMutData = Rc<RefCell<Vec<i32>>>;
   
   fn share_and_modify() {
       let data: SharedMutData = Rc::new(RefCell::new(vec![1, 2, 3]));
       let data_clone = Rc::clone(&data);
       
       // 通过第一个引用修改
       data.borrow_mut().push(4);
       
       // 通过第二个引用访问修改后的数据
       assert_eq!(*data_clone.borrow(), vec![1, 2, 3, 4]);
   }
   ```

#### 常见陷阱 ⚠️

1. **运行时 panic**

   ```rust
   use std::cell::RefCell;
   
   let data = RefCell::new(5);
   
   let borrow1 = data.borrow_mut();  // 可变借用
   // let borrow2 = data.borrow();    // ❌ PANIC! 同时存在可变借用
   // let borrow3 = data.borrow_mut(); // ❌ PANIC! 同时存在多个可变借用
   ```

2. **忘记释放借用**

   ```rust
   use std::cell::RefCell;
   
   fn problematic_code(data: &RefCell<Vec<i32>>) {
       let mut borrowed = data.borrow_mut();
       borrowed.push(1);
       
       // ❌ borrowed 在函数结束前一直持有可变借用
       // 这会阻止其他代码访问 data
       
       // ✅ 正确做法：显式 drop
       // drop(borrowed);
       // 或者使用代码块限制借用的生命周期
   }
   ```

3. **循环借用导致死锁**

   ```rust
   use std::rc::Rc;
   use std::cell::RefCell;
   
   struct Node {
       value: i32,
       next: Option<Rc<RefCell<Node>>>,
   }
   
   // ⚠️ 小心：这种模式可能导致难以追踪的借用冲突
   fn iterate_and_modify(head: Rc<RefCell<Node>>) {
       let mut current = Some(Rc::clone(&head));
       while let Some(node) = current {
           let borrowed = node.borrow();  // 借用当前节点
           // let mut borrowed_mut = node.borrow_mut();  // ❌ 会 panic
           current = borrowed.next.as_ref().map(Rc::clone);
       }
   }
   ```

#### 最佳实践 ✅

1. **限制借用的作用域**

   ```rust
   use std::cell::RefCell;
   
   let data = RefCell::new(vec![1, 2, 3]);
   
   // ✅ 使用代码块限制借用范围
   {
       let mut borrowed = data.borrow_mut();
       borrowed.push(4);
   }  // borrowed 在这里被 drop
   
   // 现在可以安全地再次借用
   let read_borrow = data.borrow();
   ```

2. **使用 try_borrow 避免 panic**

   ```rust
   use std::cell::RefCell;
   
   let data = RefCell::new(5);
   
   match data.try_borrow_mut() {
       Ok(mut value) => {
           *value += 1;
           println!("Updated: {}", *value);
       }
       Err(_) => {
           eprintln!("Cannot borrow: already borrowed");
       }
   }
   ```

3. **清晰的文档说明**

   ```rust
   use std::cell::RefCell;
   
   /// 数据容器，支持内部可变性
   /// 
   /// # Panics
   /// 
   /// - `get_mut()` 在已有任何借用时会 panic
   /// - `get()` 在已有可变借用时会 panic
   /// 
   /// # Examples
   /// 
   /// ```
   /// let container = Container::new(42);
   /// container.set(100);
   /// assert_eq!(container.get(), 100);
   /// ```
   struct Container {
       data: RefCell<i32>,
   }
   
   impl Container {
       fn new(value: i32) -> Self {
           Self { data: RefCell::new(value) }
       }
       
       fn get(&self) -> i32 {
           *self.data.borrow()
       }
       
       fn set(&self, value: i32) {
           *self.data.borrow_mut() = value;
       }
   }
   ```

### 1.2 Cell 使用场景

#### 核心特点

`Cell<T>` 是 `RefCell<T>` 的简化版本:

- ✅ **零开销**: 没有运行时借用检查
- ✅ **简单**: 只能通过值访问（get/set）
- ⚠️ **限制**: 只适用于 `Copy` 类型

#### 适用场景

1. **简单值类型的缓存**

   ```rust
   use std::cell::Cell;
   
   struct CachedCalculation {
       input: u32,
       cache: Cell<Option<u32>>,
   }
   
   impl CachedCalculation {
       fn new(input: u32) -> Self {
           Self {
               input,
               cache: Cell::new(None),
           }
       }
       
       fn calculate(&self) -> u32 {
           if let Some(cached) = self.cache.get() {
               return cached;
           }
           
           // 昂贵的计算
           let result = self.input * self.input;
           self.cache.set(Some(result));
           result
       }
   }
   ```

2. **性能计数器**

   ```rust
   use std::cell::Cell;
   
   struct PerformanceTracker {
       request_count: Cell<u64>,
       error_count: Cell<u64>,
   }
   
   impl PerformanceTracker {
       fn new() -> Self {
           Self {
               request_count: Cell::new(0),
               error_count: Cell::new(0),
           }
       }
       
       fn record_request(&self) {
           self.request_count.set(self.request_count.get() + 1);
       }
       
       fn record_error(&self) {
           self.error_count.set(self.error_count.get() + 1);
       }
       
       fn error_rate(&self) -> f64 {
           let requests = self.request_count.get() as f64;
           let errors = self.error_count.get() as f64;
           if requests == 0.0 { 0.0 } else { errors / requests }
       }
   }
   ```

3. **标志位和状态**

   ```rust
   use std::cell::Cell;
   
   struct Connection {
       is_open: Cell<bool>,
       retry_count: Cell<u32>,
   }
   
   impl Connection {
       fn new() -> Self {
           Self {
               is_open: Cell::new(false),
               retry_count: Cell::new(0),
           }
       }
       
       fn connect(&self) -> Result<(), String> {
           if self.is_open.get() {
               return Ok(());
           }
           
           // 尝试连接...
           self.retry_count.set(self.retry_count.get() + 1);
           self.is_open.set(true);
           Ok(())
       }
       
       fn disconnect(&self) {
           self.is_open.set(false);
       }
   }
   ```

#### Cell vs RefCell 对比

| 特性 | `Cell<T>` | `RefCell<T>` |
|------|---------|------------|
| **类型要求** | T: Copy | 任何类型 |
| **访问方式** | get()/set() 值访问 | borrow()/borrow_mut() 引用访问 |
| **运行时开销** | ❌ 无 | ✅ 有（借用检查） |
| **panic 风险** | ❌ 不会 | ✅ 可能（借用冲突） |
| **性能** | 🏆 最优 | ⚠️ 略有开销 |
| **适用场景** | 简单值类型 | 复杂类型和引用 |

### 1.3 并发内部可变性

#### `Mutex<T>` - 互斥锁

用于跨线程的内部可变性:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

**关键特点**:

- ✅ 线程安全（实现了 `Sync`）
- ⚠️ 可能死锁
- ⚠️ 性能开销（需要操作系统支持）

#### `RwLock<T>` - 读写锁

允许多个读取者或一个写入者:

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // 多个读取线程
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data_clone.read().unwrap();
            println!("Thread {} read: {:?}", i, *data);
        });
        handles.push(handle);
    }
    
    // 一个写入线程
    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut data = data_clone.write().unwrap();
        data.push(4);
        println!("Write complete");
    });
    handles.push(handle);
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**使用场景**:

- ✅ 读多写少的场景
- ✅ 需要细粒度并发控制
- ⚠️ 写入者可能饥饿

#### 性能对比

| 类型 | 适用线程 | 性能 | 特点 |
|------|---------|------|------|
| **`Cell<T>`** | 单线程 | 🏆🏆🏆 最快 | 零开销，Copy 类型 |
| **`RefCell<T>`** | 单线程 | 🏆🏆 很快 | 运行时检查 |
| **`Mutex<T>`** | 多线程 | ⚠️ 较慢 | 操作系统级锁 |
| **`RwLock<T>`** | 多线程 | ⚠️ 较慢 | 读优化 |
| **Atomic*** | 多线程 | 🏆🏆 很快 | 原子类型 |

### 1.4 选择指南

#### 决策流程图

```text
需要内部可变性？
    ↓ 是
需要跨线程共享？
    ↓ 否                              ↓ 是
类型是 Copy？                      是否读多写少？
    ↓ 是          ↓ 否                  ↓ 是         ↓ 否
使用 Cell<T>   使用 RefCell<T>       使用 RwLock<T>   使用 Mutex<T>
```

#### 选择矩阵

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 单线程 + Copy 类型 | `Cell<T>` | 零开销 |
| 单线程 + 非 Copy 类型 | `RefCell<T>` | 灵活性 |
| 多线程 + 频繁读取 | `RwLock<T>` | 读并发 |
| 多线程 + 频繁写入 | `Mutex<T>` | 简单可靠 |
| 多线程 + 原子操作 | `AtomicXxx` | 最高性能 |
| 不需要内部可变性 | `&mut T` | 编译时保证 |

#### 实例对比

```rust
use std::cell::{Cell, RefCell};
use std::sync::{Arc, Mutex, RwLock};
use std::thread;

// 场景 1：单线程简单计数 → Cell
struct SimpleCounter {
    count: Cell<u32>,
}

// 场景 2：单线程复杂数据 → RefCell
struct ComplexData {
    items: RefCell<Vec<String>>,
}

// 场景 3：多线程计数 → Arc<Mutex<T>>
fn multi_thread_counter() {
    let counter = Arc::new(Mutex::new(0));
    // ... 使用 ...
}

// 场景 4：多线程读多写少 → Arc<RwLock<T>>
fn cached_data() {
    let cache = Arc::new(RwLock::new(Vec::new()));
    // ... 使用 ...
}
```

---

## 2. 智能指针高级用法

### 2.1 Box 优化技巧

#### 基本用法

`Box<T>` 用于堆分配，有多种高级用法:

```rust
// 1. 递归类型
enum List {
    Cons(i32, Box<List>),
    Nil,
}

// 2. 大型数据
struct LargeStruct {
    data: [u8; 10000],
}

fn avoid_stack_overflow() {
    // ❌ 栈分配，可能溢出
    // let large = LargeStruct { data: [0; 10000] };
    
    // ✅ 堆分配
    let large = Box::new(LargeStruct { data: [0; 10000] });
}

// 3. Trait 对象
trait Draw {
    fn draw(&self);
}

fn use_trait_object(drawable: Box<dyn Draw>) {
    drawable.draw();
}
```

#### 性能优化

1. **使用 Box::leak 创建 'static 生命周期**

   ```rust
   fn create_static_string(s: String) -> &'static str {
       Box::leak(s.into_boxed_str())
   }
   
   fn main() {
       let static_str = create_static_string("Hello".to_string());
       // static_str 现在有 'static 生命周期
       // ⚠️ 注意：这会导致内存泄漏，除非是有意为之
   }
   ```

2. **Box::into_raw 用于 FFI**

   ```rust
   use std::ffi::CString;
   
   #[no_mangle]
   pub extern "C" fn create_string() -> *mut libc::c_char {
       let s = CString::new("Hello from Rust").unwrap();
       Box::into_raw(Box::new(s)) as *mut libc::c_char
   }
   
   #[no_mangle]
   pub unsafe extern "C" fn free_string(ptr: *mut libc::c_char) {
       if !ptr.is_null() {
           // 重新获取所有权并自动释放
           let _ = Box::from_raw(ptr);
       }
   }
   ```

3. **原地初始化（Rust 1.90+）**

   ```rust
   // 对于非常大的结构，避免栈上临时构造
   fn create_large_array() -> Box<[u8; 1000000]> {
       // 直接在堆上分配
       Box::new([0u8; 1000000])
   }
   ```

#### 常见陷阱

```rust
// ❌ 错误：不必要的 Box
fn unnecessary_box(x: Box<i32>) -> Box<i32> {
    Box::new(*x + 1)  // 解引用后又装箱
}

// ✅ 正确：直接操作
fn better(x: Box<i32>) -> Box<i32> {
    x  // 如果不需要修改，直接返回
}

// ✅ 或者避免使用 Box
fn best(x: i32) -> i32 {
    x + 1
}
```

### 2.2 Rc 引用计数模式

#### 基本概念

`Rc<T>` (Reference Counted) 实现共享所有权:

```rust
use std::rc::Rc;

fn rc_basic_example() {
    let data = Rc::new(vec![1, 2, 3]);
    
    println!("引用计数: {}", Rc::strong_count(&data));  // 1
    
    let data2 = Rc::clone(&data);
    println!("引用计数: {}", Rc::strong_count(&data));  // 2
    
    let data3 = Rc::clone(&data);
    println!("引用计数: {}", Rc::strong_count(&data));  // 3
    
    drop(data2);
    println!("引用计数: {}", Rc::strong_count(&data));  // 2
}
```

#### 高级模式

1. **Rc + RefCell 实现共享可变状态**

   ```rust
   use std::rc::Rc;
   use std::cell::RefCell;
   
   #[derive(Debug)]
   struct Node {
       value: i32,
       children: RefCell<Vec<Rc<Node>>>,
   }
   
   impl Node {
       fn new(value: i32) -> Rc<Self> {
           Rc::new(Node {
               value,
               children: RefCell::new(vec![]),
           })
       }
       
       fn add_child(self: &Rc<Self>, child: Rc<Node>) {
           self.children.borrow_mut().push(child);
       }
   }
   
   fn tree_example() {
       let root = Node::new(1);
       let child1 = Node::new(2);
       let child2 = Node::new(3);
       
       root.add_child(child1);
       root.add_child(child2);
       
       println!("Root: {:?}", root);
   }
   ```

2. **计数器和缓存**

   ```rust
   use std::rc::Rc;
   use std::collections::HashMap;
   
   struct StringCache {
       cache: HashMap<String, Rc<String>>,
   }
   
   impl StringCache {
       fn new() -> Self {
           Self { cache: HashMap::new() }
       }
       
       fn get(&mut self, s: &str) -> Rc<String> {
           self.cache
               .entry(s.to_string())
               .or_insert_with(|| Rc::new(s.to_string()))
               .clone()
       }
   }
   
   fn cache_example() {
       let mut cache = StringCache::new();
       
       let s1 = cache.get("hello");
       let s2 = cache.get("hello");  // 复用相同的 Rc
       
       assert_eq!(Rc::strong_count(&s1), 3);  // cache + s1 + s2
   }
   ```

#### 性能考虑

- ✅ **克隆开销**: `Rc::clone()` 只增加引用计数，开销很小
- ⚠️ **不是线程安全的**: 只能在单线程中使用
- ⚠️ **循环引用**: 可能导致内存泄漏（需要使用 `Weak`）

### 2.3 Arc 跨线程共享

#### 基本使用

`Arc<T>` (Atomic Reference Counted) 是 `Rc<T>` 的线程安全版本:

```rust
use std::sync::Arc;
use std::thread;

fn arc_basic_example() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("Thread {}: {:?}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

#### 与 Mutex 配合

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct SharedState {
    counter: Mutex<u32>,
    data: Vec<String>,  // 不可变数据不需要 Mutex
}

fn shared_state_example() {
    let state = Arc::new(SharedState {
        counter: Mutex::new(0),
        data: vec!["a".into(), "b".into(), "c".into()],
    });
    
    let mut handles = vec![];
    
    for _ in 0..10 {
        let state_clone = Arc::clone(&state);
        let handle = thread::spawn(move || {
            // 读取不可变数据（无锁）
            println!("Data: {:?}", state_clone.data);
            
            // 修改可变数据（需要锁）
            let mut counter = state_clone.counter.lock().unwrap();
            *counter += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final counter: {}", *state.counter.lock().unwrap());
}
```

#### Rc vs Arc 对比

| 特性 | `Rc<T>` | `Arc<T>` |
|------|-------|--------|
| **线程安全** | ❌ 否 | ✅ 是 |
| **性能** | 🏆 快 | ⚠️ 略慢 |
| **适用场景** | 单线程共享 | 多线程共享 |
| **引用计数** | 非原子 | 原子操作 |
| **Send/Sync** | 不实现 | 实现（T: Send + Sync） |

### 2.4 Weak 弱引用

#### 解决循环引用

`Weak<T>` 不增加强引用计数，防止循环引用导致内存泄漏:

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

impl Node {
    fn new(value: i32) -> Rc<Self> {
        Rc::new(Node {
            value,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![]),
        })
    }
    
    fn add_child(parent: &Rc<Node>, child: Rc<Node>) {
        // 子节点持有父节点的弱引用
        *child.parent.borrow_mut() = Rc::downgrade(parent);
        // 父节点持有子节点的强引用
        parent.children.borrow_mut().push(child);
    }
}

fn tree_with_parent() {
    let root = Node::new(1);
    let child = Node::new(2);
    
    Node::add_child(&root, Rc::clone(&child));
    
    // 子节点可以访问父节点
    if let Some(parent) = child.parent.borrow().upgrade() {
        println!("Child's parent: {}", parent.value);
    }
    
    println!("Strong count: {}", Rc::strong_count(&root));
    println!("Weak count: {}", Rc::weak_count(&root));
}
```

#### 缓存模式

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;
use std::collections::HashMap;

struct Cache {
    data: RefCell<HashMap<String, Weak<String>>>,
}

impl Cache {
    fn new() -> Self {
        Self { data: RefCell::new(HashMap::new()) }
    }
    
    fn get_or_insert(&self, key: &str, create: impl FnOnce() -> String) -> Rc<String> {
        let mut cache = self.data.borrow_mut();
        
        // 尝试升级弱引用
        if let Some(weak) = cache.get(key) {
            if let Some(strong) = weak.upgrade() {
                return strong;
            }
        }
        
        // 创建新值
        let value = Rc::new(create());
        cache.insert(key.to_string(), Rc::downgrade(&value));
        value
    }
    
    fn cleanup(&self) {
        // 清理已失效的弱引用
        self.data.borrow_mut().retain(|_, weak| weak.strong_count() > 0);
    }
}
```

#### 观察者模式

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

trait Observer {
    fn update(&self, message: &str);
}

struct Subject {
    observers: RefCell<Vec<Weak<dyn Observer>>>,
}

impl Subject {
    fn new() -> Self {
        Self { observers: RefCell::new(vec![]) }
    }
    
    fn attach(&self, observer: Weak<dyn Observer>) {
        self.observers.borrow_mut().push(observer);
    }
    
    fn notify(&self, message: &str) {
        // 自动清理失效的观察者
        self.observers.borrow_mut().retain(|weak| {
            if let Some(observer) = weak.upgrade() {
                observer.update(message);
                true
            } else {
                false  // 观察者已销毁，从列表中移除
            }
        });
    }
}
```

---

## 3. 复杂所有权设计

### 3.1 自引用结构

#### 问题描述

自引用结构是指结构体的某个字段引用结构体自身的其他字段:

```rust
// ❌ 这个设计无法编译
struct SelfReferential {
    data: String,
    pointer: &String,  // 想要指向 self.data
}
```

**为什么不行**？

- 移动 `SelfReferential` 会使 `pointer` 失效
- Rust 的所有权系统不允许这种不安全的引用

#### 解决方案 1: Pin + Unsafe

```rust
use std::pin::Pin;
use std::marker::PhantomPinned;

struct SelfReferential {
    data: String,
    // 使用原始指针
    pointer: *const String,
    _pin: PhantomPinned,
}

impl SelfReferential {
    fn new(data: String) -> Pin<Box<Self>> {
        let mut boxed = Box::pin(SelfReferential {
            data,
            pointer: std::ptr::null(),
            _pin: PhantomPinned,
        });
        
        unsafe {
            let ptr = &boxed.data as *const String;
            let mut_ref = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).pointer = ptr;
        }
        
        boxed
    }
    
    fn data(&self) -> &str {
        &self.data
    }
    
    fn pointer_value(&self) -> &str {
        unsafe { &*self.pointer }
    }
}

fn main() {
    let pinned = SelfReferential::new("Hello".to_string());
    println!("Data: {}", pinned.data());
    println!("Pointer: {}", pinned.pointer_value());
}
```

#### 解决方案 2: 使用索引

```rust
// ✅ 推荐：使用索引代替引用
struct Arena {
    data: Vec<String>,
}

struct Item {
    value: String,
    related_index: usize,  // 索引而非引用
}

impl Arena {
    fn new() -> Self {
        Self { data: Vec::new() }
    }
    
    fn add(&mut self, value: String) -> usize {
        let index = self.data.len();
        self.data.push(value);
        index
    }
    
    fn get(&self, index: usize) -> Option<&String> {
        self.data.get(index)
    }
}
```

#### 解决方案 3: Rental/Ouroboros Crate

```rust
// 使用 ouroboros crate (Rust 1.90+)
// Cargo.toml: ouroboros = "0.15"

use ouroboros::self_referencing;

#[self_referencing]
struct MyStruct {
    data: String,
    #[borrows(data)]
    pointer: &'this str,
}

fn main() {
    let my_struct = MyStructBuilder {
        data: "Hello".to_string(),
        pointer_builder: |data| &data[0..5],
    }.build();
    
    my_struct.with_pointer(|ptr| {
        println!("Pointer: {}", ptr);
    });
}
```

### 3.2 树和图结构

#### 树结构实现

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

type TreeNode = Rc<RefCell<Node>>;
type WeakNode = Weak<RefCell<Node>>;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<WeakNode>,
    children: RefCell<Vec<TreeNode>>,
}

impl Node {
    fn new(value: i32) -> TreeNode {
        Rc::new(RefCell::new(Node {
            value,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![]),
        }))
    }
    
    fn add_child(parent: &TreeNode, child: TreeNode) {
        *child.borrow_mut().parent.borrow_mut() = Rc::downgrade(parent);
        parent.borrow_mut().children.borrow_mut().push(child);
    }
    
    fn print_tree(node: &TreeNode, indent: usize) {
        let node_ref = node.borrow();
        println!("{:indent$}{}", "", node_ref.value, indent = indent * 2);
        
        for child in node_ref.children.borrow().iter() {
            Self::print_tree(child, indent + 1);
        }
    }
}

fn tree_example() {
    let root = Node::new(1);
    let child1 = Node::new(2);
    let child2 = Node::new(3);
    let grandchild = Node::new(4);
    
    Node::add_child(&root, Rc::clone(&child1));
    Node::add_child(&root, Rc::clone(&child2));
    Node::add_child(&child1, grandchild);
    
    Node::print_tree(&root, 0);
}
```

#### 图结构实现

```rust
use std::collections::HashMap;
use std::rc::Rc;
use std::cell::RefCell;

type NodeId = usize;
type GraphNode = Rc<RefCell<Node>>;

struct Node {
    id: NodeId,
    value: String,
    edges: Vec<NodeId>,  // 使用 ID 而非引用
}

struct Graph {
    nodes: HashMap<NodeId, GraphNode>,
    next_id: NodeId,
}

impl Graph {
    fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            next_id: 0,
        }
    }
    
    fn add_node(&mut self, value: String) -> NodeId {
        let id = self.next_id;
        self.next_id += 1;
        
        let node = Rc::new(RefCell::new(Node {
            id,
            value,
            edges: vec![],
        }));
        
        self.nodes.insert(id, node);
        id
    }
    
    fn add_edge(&mut self, from: NodeId, to: NodeId) -> Result<(), String> {
        if !self.nodes.contains_key(&to) {
            return Err(format!("Node {} does not exist", to));
        }
        
        if let Some(node) = self.nodes.get(&from) {
            node.borrow_mut().edges.push(to);
            Ok(())
        } else {
            Err(format!("Node {} does not exist", from))
        }
    }
    
    fn get_neighbors(&self, id: NodeId) -> Option<Vec<NodeId>> {
        self.nodes.get(&id).map(|node| node.borrow().edges.clone())
    }
    
    fn print_graph(&self) {
        for (id, node) in &self.nodes {
            let node_ref = node.borrow();
            println!("Node {}: {} -> {:?}", id, node_ref.value, node_ref.edges);
        }
    }
}

fn graph_example() {
    let mut graph = Graph::new();
    
    let a = graph.add_node("A".to_string());
    let b = graph.add_node("B".to_string());
    let c = graph.add_node("C".to_string());
    
    graph.add_edge(a, b).unwrap();
    graph.add_edge(a, c).unwrap();
    graph.add_edge(b, c).unwrap();
    graph.add_edge(c, a).unwrap();  // 形成循环
    
    graph.print_graph();
}
```

### 3.3 观察者模式

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

trait Observer {
    fn on_notify(&self, event: &str);
    fn name(&self) -> &str;
}

struct ConcreteObserver {
    name: String,
}

impl Observer for ConcreteObserver {
    fn on_notify(&self, event: &str) {
        println!("{} received: {}", self.name, event);
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

struct Subject {
    observers: RefCell<Vec<Weak<dyn Observer>>>,
}

impl Subject {
    fn new() -> Self {
        Self {
            observers: RefCell::new(vec![]),
        }
    }
    
    fn attach(&self, observer: &Rc<dyn Observer>) {
        self.observers.borrow_mut().push(Rc::downgrade(observer));
    }
    
    fn detach(&self, name: &str) {
        self.observers.borrow_mut().retain(|weak| {
            weak.upgrade()
                .map(|obs| obs.name() != name)
                .unwrap_or(false)
        });
    }
    
    fn notify(&self, event: &str) {
        // 通知所有观察者，同时清理失效的引用
        self.observers.borrow_mut().retain(|weak| {
            if let Some(observer) = weak.upgrade() {
                observer.on_notify(event);
                true
            } else {
                false
            }
        });
    }
}

fn observer_pattern_example() {
    let subject = Subject::new();
    
    let observer1: Rc<dyn Observer> = Rc::new(ConcreteObserver {
        name: "Observer1".to_string(),
    });
    
    let observer2: Rc<dyn Observer> = Rc::new(ConcreteObserver {
        name: "Observer2".to_string(),
    });
    
    subject.attach(&observer1);
    subject.attach(&observer2);
    
    subject.notify("Event 1");
    
    subject.detach("Observer1");
    
    subject.notify("Event 2");
}
```

### 3.4 状态机设计

```rust
// 类型状态模式：使用类型系统保证状态转换的正确性

struct Locked;
struct Unlocked;

struct Door<State> {
    state: std::marker::PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door created (locked)");
        Door {
            state: std::marker::PhantomData,
        }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Door unlocked");
        Door {
            state: std::marker::PhantomData,
        }
    }
}

impl Door<Unlocked> {
    fn open(&self) {
        println!("Door opened");
    }
    
    fn lock(self) -> Door<Locked> {
        println!("Door locked");
        Door {
            state: std::marker::PhantomData,
        }
    }
}

fn typestate_example() {
    let door = Door::<Locked>::new();
    // door.open();  // ❌ 编译错误：locked 状态不能 open
    
    let door = door.unlock();
    door.open();  // ✅ OK
    
    let door = door.lock();
    // door.open();  // ❌ 编译错误
}

// 传统状态机模式
enum State {
    Locked,
    Unlocked,
}

struct StateMachine {
    state: State,
}

impl StateMachine {
    fn new() -> Self {
        Self { state: State::Locked }
    }
    
    fn unlock(&mut self) -> Result<(), &str> {
        match self.state {
            State::Locked => {
                self.state = State::Unlocked;
                println!("Unlocked");
                Ok(())
            }
            State::Unlocked => Err("Already unlocked"),
        }
    }
    
    fn lock(&mut self) -> Result<(), &str> {
        match self.state {
            State::Unlocked => {
                self.state = State::Locked;
                println!("Locked");
                Ok(())
            }
            State::Locked => Err("Already locked"),
        }
    }
    
    fn open(&self) -> Result<(), &str> {
        match self.state {
            State::Unlocked => {
                println!("Opened");
                Ok(())
            }
            State::Locked => Err("Cannot open: door is locked"),
        }
    }
}
```

---

## 4. 实战案例

### 4.1 Web 服务器设计

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::thread;

// 共享状态：连接池
struct ConnectionPool {
    connections: Mutex<Vec<Connection>>,
    max_size: usize,
}

struct Connection {
    id: usize,
    is_busy: bool,
}

impl ConnectionPool {
    fn new(max_size: usize) -> Arc<Self> {
        let connections = (0..max_size)
            .map(|id| Connection { id, is_busy: false })
            .collect();
        
        Arc::new(ConnectionPool {
            connections: Mutex::new(connections),
            max_size,
        })
    }
    
    fn acquire(&self) -> Option<usize> {
        let mut conns = self.connections.lock().unwrap();
        conns.iter_mut()
            .find(|c| !c.is_busy)
            .map(|c| {
                c.is_busy = true;
                c.id
            })
    }
    
    fn release(&self, id: usize) {
        let mut conns = self.connections.lock().unwrap();
        if let Some(conn) = conns.iter_mut().find(|c| c.id == id) {
            conn.is_busy = false;
        }
    }
}

// 请求处理器
struct RequestHandler {
    pool: Arc<ConnectionPool>,
    cache: Arc<Mutex<HashMap<String, String>>>,
}

impl RequestHandler {
    fn new(pool: Arc<ConnectionPool>) -> Self {
        Self {
            pool,
            cache: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn handle_request(&self, request: &str) -> Result<String, String> {
        // 检查缓存
        if let Some(cached) = self.cache.lock().unwrap().get(request) {
            return Ok(cached.clone());
        }
        
        // 获取连接
        let conn_id = self.pool.acquire()
            .ok_or("No available connections")?;
        
        // 模拟处理
        thread::sleep(std::time::Duration::from_millis(100));
        let response = format!("Response to: {}", request);
        
        // 更新缓存
        self.cache.lock().unwrap()
            .insert(request.to_string(), response.clone());
        
        // 释放连接
        self.pool.release(conn_id);
        
        Ok(response)
    }
}

fn web_server_example() {
    let pool = ConnectionPool::new(5);
    let handler = Arc::new(RequestHandler::new(pool));
    
    let mut handles = vec![];
    
    for i in 0..10 {
        let handler_clone = Arc::clone(&handler);
        let handle = thread::spawn(move || {
            let request = format!("request-{}", i % 3);  // 3 种不同的请求
            match handler_clone.handle_request(&request) {
                Ok(response) => println!("✅ {}: {}", i, response),
                Err(e) => eprintln!("❌ {}: {}", i, e),
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 4.2 数据库连接池

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::time::Duration;

struct DbConnection {
    id: usize,
}

impl DbConnection {
    fn query(&self, sql: &str) -> Result<String, String> {
        // 模拟数据库查询
        println!("Connection {} executing: {}", self.id, sql);
        thread::sleep(Duration::from_millis(50));
        Ok(format!("Result from connection {}", self.id))
    }
}

struct DbPool {
    available: Mutex<Vec<DbConnection>>,
    condvar: Condvar,
    max_size: usize,
}

impl DbPool {
    fn new(size: usize) -> Arc<Self> {
        let connections = (0..size)
            .map(|id| DbConnection { id })
            .collect();
        
        Arc::new(DbPool {
            available: Mutex::new(connections),
            condvar: Condvar::new(),
            max_size: size,
        })
    }
    
    fn get_connection(&self) -> DbConnection {
        let mut available = self.available.lock().unwrap();
        
        // 等待直到有可用连接
        while available.is_empty() {
            available = self.condvar.wait(available).unwrap();
        }
        
        available.pop().unwrap()
    }
    
    fn return_connection(&self, conn: DbConnection) {
        let mut available = self.available.lock().unwrap();
        available.push(conn);
        
        // 通知等待的线程
        self.condvar.notify_one();
    }
}

fn db_pool_example() {
    let pool = DbPool::new(3);
    let mut handles = vec![];
    
    for i in 0..10 {
        let pool_clone = Arc::clone(&pool);
        let handle = thread::spawn(move || {
            let conn = pool_clone.get_connection();
            println!("Thread {} got connection {}", i, conn.id);
            
            let _ = conn.query(&format!("SELECT * FROM table WHERE id = {}", i));
            
            pool_clone.return_connection(conn);
            println!("Thread {} returned connection", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 4.3 缓存系统

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

struct CacheEntry<T> {
    value: T,
    expires_at: Instant,
}

struct Cache<T: Clone> {
    data: RwLock<HashMap<String, CacheEntry<T>>>,
    default_ttl: Duration,
}

impl<T: Clone> Cache<T> {
    fn new(default_ttl: Duration) -> Arc<Self> {
        Arc::new(Cache {
            data: RwLock::new(HashMap::new()),
            default_ttl,
        })
    }
    
    fn get(&self, key: &str) -> Option<T> {
        let data = self.data.read().unwrap();
        
        if let Some(entry) = data.get(key) {
            if entry.expires_at > Instant::now() {
                return Some(entry.value.clone());
            }
        }
        
        None
    }
    
    fn set(&self, key: String, value: T) {
        self.set_with_ttl(key, value, self.default_ttl);
    }
    
    fn set_with_ttl(&self, key: String, value: T, ttl: Duration) {
        let mut data = self.data.write().unwrap();
        
        data.insert(key, CacheEntry {
            value,
            expires_at: Instant::now() + ttl,
        });
    }
    
    fn cleanup(&self) {
        let mut data = self.data.write().unwrap();
        let now = Instant::now();
        
        data.retain(|_, entry| entry.expires_at > now);
    }
    
    fn get_or_insert_with<F>(&self, key: &str, create: F) -> T
    where
        F: FnOnce() -> T,
    {
        // 先尝试读取
        if let Some(value) = self.get(key) {
            return value;
        }
        
        // 需要创建新值
        let value = create();
        self.set(key.to_string(), value.clone());
        value
    }
}

fn cache_example() {
    let cache = Cache::<String>::new(Duration::from_secs(60));
    
    // 基本用法
    cache.set("key1".to_string(), "value1".to_string());
    assert_eq!(cache.get("key1"), Some("value1".to_string()));
    
    // 获取或插入
    let value = cache.get_or_insert_with("key2", || {
        println!("Computing expensive value...");
        "computed_value".to_string()
    });
    assert_eq!(value, "computed_value");
    
    // 第二次调用会使用缓存
    let value = cache.get_or_insert_with("key2", || {
        println!("This won't be printed");
        "new_value".to_string()
    });
    assert_eq!(value, "computed_value");
}
```

### 4.4 插件架构

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn execute(&self, input: &str) -> Result<String, String>;
}

struct PluginManager {
    plugins: RwLock<HashMap<String, Arc<dyn Plugin>>>,
}

impl PluginManager {
    fn new() -> Arc<Self> {
        Arc::new(PluginManager {
            plugins: RwLock::new(HashMap::new()),
        })
    }
    
    fn register(&self, plugin: Arc<dyn Plugin>) -> Result<(), String> {
        let name = plugin.name().to_string();
        let mut plugins = self.plugins.write().unwrap();
        
        if plugins.contains_key(&name) {
            return Err(format!("Plugin '{}' already registered", name));
        }
        
        plugins.insert(name, plugin);
        Ok(())
    }
    
    fn unregister(&self, name: &str) -> Result<(), String> {
        let mut plugins = self.plugins.write().unwrap();
        
        plugins.remove(name)
            .map(|_| ())
            .ok_or_else(|| format!("Plugin '{}' not found", name))
    }
    
    fn execute(&self, plugin_name: &str, input: &str) -> Result<String, String> {
        let plugins = self.plugins.read().unwrap();
        
        plugins.get(plugin_name)
            .ok_or_else(|| format!("Plugin '{}' not found", plugin_name))?
            .execute(input)
    }
    
    fn list_plugins(&self) -> Vec<String> {
        let plugins = self.plugins.read().unwrap();
        plugins.keys().cloned().collect()
    }
}

// 示例插件
struct UppercasePlugin;

impl Plugin for UppercasePlugin {
    fn name(&self) -> &str {
        "uppercase"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        Ok(input.to_uppercase())
    }
}

struct ReversePlugin;

impl Plugin for ReversePlugin {
    fn name(&self) -> &str {
        "reverse"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        Ok(input.chars().rev().collect())
    }
}

fn plugin_system_example() {
    let manager = PluginManager::new();
    
    // 注册插件
    manager.register(Arc::new(UppercasePlugin)).unwrap();
    manager.register(Arc::new(ReversePlugin)).unwrap();
    
    println!("Available plugins: {:?}", manager.list_plugins());
    
    // 使用插件
    let result = manager.execute("uppercase", "hello").unwrap();
    println!("Uppercase: {}", result);
    
    let result = manager.execute("reverse", "hello").unwrap();
    println!("Reverse: {}", result);
}
```

---

## 相关资源

### 📖 核心文档

- **[高级所有权模式完整文档](../03_advanced/01_advanced_ownership.md)**: 详细的高级模式和最佳实践
- **[内存安全分析](../04_safety/01_memory_safety.md)**: 深入理解内存安全机制
- **[并发编程指南](../05_practice/05_concurrent_programming.md)**: 并发场景的所有权模式

### 🔗 相关主题

- **Tier 2 核心概念**
  - [2.1 所有权系统](../tier2_core_concepts/2.1_所有权系统.md)
  - [2.2 借用检查器](../tier2_core_concepts/2.2_借用检查器.md)
  - [2.3 生命周期](../tier2_core_concepts/2.3_生命周期.md)

- **Tier 3 高级主题**
  - [3.2 零成本抽象](./3.2_零成本抽象.md)
  - [3.3 内存安全最佳实践](./3.3_内存安全最佳实践.md)
  - [3.4 性能优化](./3.4_性能优化.md)

- **Tier 4 理论深度**
  - [4.1 类型系统理论](../tier4_theoretical/4.1_类型系统理论.md)
  - [4.2 形式化验证](../tier4_theoretical/4.2_形式化验证.md)

### 📚 学习路径

**进阶路径**:

1. 完成本文档学习（预估 8-12 小时）
2. 实践至少 3 个实战案例
3. 深入学习 [零成本抽象](./3.2_零成本抽象.md)
4. 进阶到 [类型系统理论](../tier4_theoretical/4.1_类型系统理论.md)

**实践建议**:

- 🔨 实现一个简单的树或图结构
- 🔨 编写一个使用 RefCell/Rc 的状态管理系统
- 🔨 设计一个线程安全的缓存系统
- 🔨 实现一个插件架构的小型应用

### 🎯 学习检查清单

完成以下任务以验证学习效果:

- [ ] 理解 Cell/RefCell/Mutex/RwLock 的区别和使用场景
- [ ] 能够选择合适的内部可变性工具
- [ ] 掌握 Rc/Arc/Weak 的使用模式
- [ ] 理解并避免循环引用问题
- [ ] 能够设计复杂的树和图结构
- [ ] 实现至少一个完整的实战案例
- [ ] 理解自引用结构的问题和解决方案
- [ ] 能够在性能和安全性之间做出权衡

---

**最后更新**: 2025-10-22  
**文档版本**: 2.0 (扩展版)  
**适用 Rust 版本**: 1.90+  
**预估学习时间**: 8-12 小时  
**难度级别**: ⭐⭐⭐⭐ (高级)

---

END OF DOCUMENT
