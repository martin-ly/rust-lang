# 1.2 快速开始指南

## 📋 目录

- [1.2 快速开始指南](#12-快速开始指南)
  - [📋 目录](#-目录)
  - [🎯 学习目标](#-学习目标)
  - [🚀 5分钟快速开始](#-5分钟快速开始)
    - [第一步：环境准备 (2分钟)](#第一步环境准备-2分钟)
    - [第二步：运行第一个示例 (3分钟)](#第二步运行第一个示例-3分钟)
  - [📚 核心概念速览 (30分钟)](#-核心概念速览-30分钟)
    - [1️⃣ 所有权 (10分钟)](#1️⃣-所有权-10分钟)
      - [三大规则](#三大规则)
      - [实战示例](#实战示例)
      - [Copy vs Move](#copy-vs-move)
      - [练习：理解所有权](#练习理解所有权)
    - [2️⃣ 借用 (15分钟)](#2️⃣-借用-15分钟)
      - [不可变借用](#不可变借用)
      - [多个不可变借用](#多个不可变借用)
      - [可变借用](#可变借用)
      - [借用规则示例](#借用规则示例)
      - [NLL (Non-Lexical Lifetimes)](#nll-non-lexical-lifetimes)
      - [练习：理解借用](#练习理解借用)
    - [3️⃣ 生命周期 (5分钟)](#3️⃣-生命周期-5分钟)
      - [基本概念](#基本概念)
      - [为什么需要生命周期注解？](#为什么需要生命周期注解)
      - [生命周期省略规则](#生命周期省略规则)
  - [🎯 完成检查](#-完成检查)
  - [🚀 下一步](#-下一步)
    - [立即行动](#立即行动)
    - [继续学习](#继续学习)
    - [实践建议](#实践建议)
  - [📚 额外资源](#-额外资源)
    - [可视化学习](#可视化学习)
    - [代码示例](#代码示例)
    - [完整文档](#完整文档)
  - [💡 学习建议](#-学习建议)
    - [✅ 应该做的](#-应该做的)
    - [❌ 不应该做的](#-不应该做的)
  - [🎉 恭喜](#-恭喜)

## 🎯 学习目标

完成本指南后，你将能够：

- ✅ 理解所有权的三大核心规则
- ✅ 掌握基本的借用操作
- ✅ 理解生命周期的基本概念
- ✅ 运行和修改简单的 Rust 代码

## 🚀 5分钟快速开始

### 第一步：环境准备 (2分钟)

确保你已经安装了 Rust 1.90 或更高版本：

```bash
# 检查 Rust 版本
rustc --version

# 如果版本低于 1.90，请更新
rustup update stable
```

### 第二步：运行第一个示例 (3分钟)

```bash
# 进入项目目录
cd crates/c01_ownership_borrow_scope

# 运行第一个示例
cargo run --example ownership_examples

# 运行测试
cargo test
```

**期望输出**：所有测试通过 ✅

## 📚 核心概念速览 (30分钟)

### 1️⃣ 所有权 (10分钟)

#### 三大规则

Rust 所有权系统的核心就是这三条规则。
从引用一致性视角看，这些规则是**资源控制权的逻辑证明**：

```text
规则 1: 每个资源都有唯一的所有者（逻辑证明）
规则 2: 同一时间只能有一个所有者（排他控制权）
规则 3: 所有者离开作用域时，资源被自动释放（编译期证明的资源生命周期）
```

#### 实战示例

```rust
// 示例 1: 基本所有权
fn example_ownership() {
    let s1 = String::from("hello");  // s1 是 "hello" 的所有者
    let s2 = s1;                      // 所有权转移给 s2

    // println!("{}", s1);            // ❌ 编译错误：s1 已失效
    println!("{}", s2);               // ✅ s2 有效
}
```

**关键理解**（引用一致性视角）：

- `String::from("hello")` 创建字符串资源（资源控制权）
- `let s2 = s1` 将资源控制权从 s1 **移动（Move）**到 s2（逻辑转移，非物理内存）
- s1 从此不再可用（编译期证明的排他性）
- 当 s2 离开作用域时，资源被自动释放（编译期证明的资源生命周期，非内存管理）

#### Copy vs Move

```rust
// Copy 类型：复制值
let x = 5;       // i32 是 Copy 类型
let y = x;       // 复制值，x 仍然有效
println!("x = {}, y = {}", x, y);  // ✅ 都有效

// Move 类型：转移所有权
let s1 = String::from("hello");  // String 是 Move 类型
let s2 = s1;                     // 转移所有权，s1 失效
// println!("{}", s1);           // ❌ 编译错误
```

**记住**：

- **Copy 类型**：整数、浮点数、布尔值、字符、元组（如果所有元素都是 Copy）
- **Move 类型**：String、Vec、自定义结构体（默认）

#### 练习：理解所有权

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);         // s 被移动到函数中
    // println!("{}", s);       // ❌ s 已失效

    let x = 5;
    makes_copy(x);              // x 被复制到函数中
    println!("{}", x);          // ✅ x 仍然有效
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string 离开作用域，资源被释放（编译期证明的资源生命周期）

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
} // some_integer 离开作用域，但只是拷贝，无需特殊处理
```

**动手练习**：修改上面的代码，尝试在 `takes_ownership` 调用后使用 `s`，看看会发生什么错误。

### 2️⃣ 借用 (15分钟)

借用（Borrowing）允许你在不转移资源控制权的情况下获取对资源的访问能力。
从引用一致性视角看，借用是**能力转移与受限授权**，而非内存地址传递。

#### 不可变借用

```rust
fn main() {
    let s = String::from("hello");

    let len = calculate_length(&s);  // 借用 s，不转移资源控制权

    println!("The length of '{}' is {}", s, len);  // ✅ s 仍然有效
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // s 是引用（访问许可证），离开作用域时不会释放原始资源
```

**关键点**（引用一致性视角）：

- `&s` 创建一个只读访问许可证（存在性证明）
- 函数使用引用 `&String` 而不获取资源控制权（逻辑转移，非物理内存）
- 可以同时存在多个不可变引用（编译期排他性契约）

#### 多个不可变借用

```rust
let s = String::from("hello");

let r1 = &s;  // 第一个不可变引用
let r2 = &s;  // 第二个不可变引用
let r3 = &s;  // 第三个不可变引用

println!("{}, {}, {}", r1, r2, r3);  // ✅ 都可以同时使用
```

#### 可变借用

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);  // 可变借用

    println!("{}", s);  // 输出: "hello, world"
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

**关键规则**：

```text
✅ 可以有任意多个不可变引用 (&T)
   OR
✅ 可以有且仅有一个可变引用 (&mut T)

❌ 不可变引用和可变引用不能同时存在
```

#### 借用规则示例

```rust
let mut s = String::from("hello");

// ❌ 错误：不能同时有多个可变借用
let r1 = &mut s;
let r2 = &mut s;  // 编译错误
println!("{}, {}", r1, r2);

// ✅ 正确：通过作用域分离
let r1 = &mut s;
println!("{}", r1);
// r1 作用域结束

let r2 = &mut s;  // OK
println!("{}", r2);
```

#### NLL (Non-Lexical Lifetimes)

Rust 1.31+ 引入了 NLL，使借用规则更灵活：

```rust
let mut s = String::from("hello");

let r1 = &s;
let r2 = &s;
println!("{} {}", r1, r2);
// r1 和 r2 最后一次使用后就不再需要了

let r3 = &mut s;  // ✅ OK，因为 r1 和 r2 不再使用
println!("{}", r3);
```

**Rust 1.90 增强**：NLL 已经非常成熟，大多数情况下借用检查器都能正确推断借用的结束时机。

#### 练习：理解借用

```rust
fn main() {
    let mut s = String::from("hello");

    // 练习1：多个不可变借用
    let r1 = &s;
    let r2 = &s;
    println!("{} {}", r1, r2);

    // 练习2：可变借用
    let r3 = &mut s;
    r3.push_str(" world");
    println!("{}", r3);

    // 练习3：思考下面的代码能否编译
    let r4 = &s;
    let r5 = &mut s;  // 这行会编译吗？为什么？
}
```

### 3️⃣ 生命周期 (5分钟)

生命周期（Lifetime）是编译期构造的证明变量，用于证明引用在其使用期间始终指向有效的资源。
从引用一致性视角看，生命周期是**有效性的编译期证明**，而非内存地址的有效时间段。

#### 基本概念

```rust
// 生命周期注解语法
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**说明**（引用一致性视角）：

- `'a` 是生命周期参数（证明变量）
- 它表示返回值的生命周期与 x 和 y 中较短的那个相同（逻辑关系，非物理时间）
- 编译器会通过逻辑证明确保返回的引用在使用时仍然有效（编译期证明，非运行时检查）

#### 为什么需要生命周期注解？

从引用一致性视角看，生命周期注解是**编译期逻辑证明**的组成部分，用于证明引用的有效性。

```rust
// ❌ 悬垂引用 (Dangling Reference)
fn dangle() -> &String {
    let s = String::from("hello");
    &s  // 错误：逻辑关系错误，引用会失效（逻辑证明的失败，非内存地址失效）
}

// ✅ 返回所有权
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // 转移资源控制权，调用者拥有资源
}
```

#### 生命周期省略规则

大多数情况下，编译器可以自动推断生命周期：

```rust
// 自动推断，无需显式标注
fn first_word(s: &str) -> &str {
    &s[..1]
}

// 等价于（编译器自动添加）
fn first_word<'a>(s: &'a str) -> &'a str {
    &s[..1]
}
```

**记住**：只有在编译器无法推断时才需要显式标注生命周期。

## 🎯 完成检查

完成以上内容后，检查你是否能够：

- [ ] 解释所有权的三大规则
- [ ] 区分 Copy 类型和 Move 类型
- [ ] 理解借用规则（不可变借用 vs 可变借用）
- [ ] 知道什么是生命周期以及为什么需要它
- [ ] 能够编写简单的函数并正确管理参数的所有权

## 🚀 下一步

### 立即行动

1. **运行代码**：复制本文中的所有示例到 Rust Playground 或本地运行
2. **修改实验**：尝试修改代码，看看会产生什么错误
3. **理解错误**：仔细阅读编译器的错误信息，它会教你正确的做法

### 继续学习

- 📖 **查阅术语表**：[1.3 核心概念术语表](./1.3_核心概念术语表.md) - 理解关键概念
- ❓ **解决常见问题**：[1.4 常见问题解答](./1.4_常见问题解答.md) - 新手常遇到的问题
- 📚 **深入学习**：[Tier 2: 核心概念层](../tier_02_guides/README.md) - 系统学习核心机制

### 实践建议

**新手实践项目**：

1. **字符串处理器**：编写一个程序，接受字符串输入并进行各种处理（反转、大小写转换等）
2. **简单计算器**：实现一个支持四则运算的计算器
3. **待办事项列表**：创建一个命令行待办事项管理工具

## 📚 额外资源

### 可视化学习

- 📊 [知识图谱](../KNOWLEDGE_GRAPH.md) - 概念关系可视化
- 🧠 [思维导图](../MIND_MAP.md) - 学习路径可视化
- 🗺️ [可视化索引](../VISUALIZATION_INDEX.md) - 所有可视化资源

### 代码示例

- 💻 **所有权系统示例** → [所有权系统基础](../02_core/01_ownership_fundamentals.md) (包含 15+ 完整示例)
- 📦 **借用系统示例** → [借用系统详解](../02_core/02_borrowing_system.md) (包含 20+ 实用示例)
- ⏰ **生命周期示例** → [生命周期注解](../02_core/03_lifetime_annotations.md) (包含 18+ 场景示例)

### 完整文档

- 📖 [完整学习指南](../COMPREHENSIVE_LEARNING_GUIDE.md) - 系统化学习路径
- 🎯 [主索引](../00_MASTER_INDEX.md) - 所有文档导航

## 💡 学习建议

### ✅ 应该做的

1. **慢慢来**：不要着急，理解比速度重要
2. **多实践**：每个示例都要亲自运行
3. **读错误**：编译器的错误信息非常有帮助
4. **问问题**：遇到不懂的及时查阅文档或提问

### ❌ 不应该做的

1. **不要跳过基础**：所有权是 Rust 的核心，必须扎实掌握
2. **不要死记硬背**：理解原理，而不是记忆规则
3. **不要害怕错误**：错误是学习的一部分
4. **不要急于学高级特性**：基础不牢，地动山摇

## 🎉 恭喜

你已经完成了快速开始指南！

现在你已经了解了 Rust 所有权系统的基本概念。继续深入学习，你将能够编写安全、高效的 Rust 程序。

**下一步**：[1.3 核心概念术语表](./1.3_核心概念术语表.md)

---

**反馈**: 如果你在学习过程中遇到任何问题或有改进建议，欢迎提交 Issue！

**最后更新**: 2025-10-22
**维护状态**: ✅ 活跃维护
