# Tier 4: 所有权性能优化

> **文档类型**: 高级主题
> **难度**: ⭐⭐⭐⭐⭐
> **适用版本**: Rust 1.92.0+

---

## 📊 目录

- [Tier 4: 所有权性能优化](#tier-4-所有权性能优化)
  - [📊 目录](#-目录)
  - [1. 避免不必要的 Clone](#1-避免不必要的-clone)
  - [2. Copy on Write (Cow)](#2-copy-on-write-cow)
  - [3. 内存布局优化](#3-内存布局优化)
  - [4. 零拷贝优化](#4-零拷贝优化)
  - [5. 移动语义优化](#5-移动语义优化)

## 1. 避免不必要的 Clone

```rust
// ❌ 不必要的 clone
fn process(data: &String) {
    let owned = data.clone(); // 昂贵的堆分配
    // 使用 owned
}

// ✅ 使用引用
fn process(data: &str) {
    // 直接使用引用
}
```

---

## 2. Copy on Write (Cow)

```rust
use std::borrow::Cow;

fn process<'a>(input: &'a str) -> Cow<'a, str> {
    if input.contains("special") {
        Cow::Owned(input.replace("special", "normal"))
    } else {
        Cow::Borrowed(input)
    }
}
```

---

## 3. 内存布局优化

```rust
// ❌ 内存浪费
struct Wasteful {
    a: u8,    // 1 byte
    b: u64,   // 8 bytes (需要 8 字节对齐)
    c: u8,    // 1 byte
} // 总共 24 字节（含填充）

// ✅ 优化后
struct Optimized {
    b: u64,   // 8 bytes
    a: u8,    // 1 byte
    c: u8,    // 1 byte
} // 总共 16 字节
```

---

## 4. 零拷贝优化

```rust
use std::fmt;

// 定义数据结构
#[derive(Debug, Clone)]
struct Data {
    header: u32,
    payload: Vec<u8>,
}

// 定义错误类型
#[derive(Debug)]
enum Error {
    InvalidHeader,
    InvalidLength,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::InvalidHeader => write!(f, "Invalid header"),
            Error::InvalidLength => write!(f, "Invalid length"),
        }
    }
}

impl std::error::Error for Error {}

// ✅ 零拷贝解析：使用 &[u8] 而非 Vec<u8>
// 避免不必要的内存分配和拷贝
fn parse_data(data: &[u8]) -> Result<Data, Error> {
    // 检查最小长度
    if data.len() < 4 {
        return Err(Error::InvalidLength);
    }

    // 零拷贝读取 header（直接引用原始数据）
    let header = u32::from_le_bytes([
        data[0], data[1], data[2], data[3]
    ]);

    // 验证 header
    if header == 0 {
        return Err(Error::InvalidHeader);
    }

    // 零拷贝：直接引用原始数据的切片部分
    // 只有在需要拥有数据时才进行拷贝
    let payload = if data.len() > 4 {
        data[4..].to_vec() // 这里需要拥有数据，所以进行拷贝
    } else {
        Vec::new()
    };

    Ok(Data { header, payload })
}

// ✅ 更进一步的零拷贝优化：返回引用
fn parse_data_zero_copy<'a>(data: &'a [u8]) -> Result<(u32, &'a [u8]), Error> {
    if data.len() < 4 {
        return Err(Error::InvalidLength);
    }

    let header = u32::from_le_bytes([
        data[0], data[1], data[2], data[3]
    ]);

    if header == 0 {
        return Err(Error::InvalidHeader);
    }

    // 完全零拷贝：直接返回原始数据的引用
    let payload = if data.len() > 4 {
        &data[4..]
    } else {
        &[]
    };

    Ok((header, payload))
}

// 使用示例
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_zero_copy_parsing() {
        let data = vec![1, 0, 0, 0, 10, 20, 30, 40];

        // 使用零拷贝解析
        let result = parse_data(&data);
        assert!(result.is_ok());

        // 使用完全零拷贝解析
        let (header, payload) = parse_data_zero_copy(&data).unwrap();
        assert_eq!(header, 1);
        assert_eq!(payload, &[10, 20, 30, 40]);
    }
}
```

---

## 5. 移动语义优化

从引用一致性视角看，移动语义是**资源控制权的逻辑转移**，而非物理内存的拷贝。编译器可以通过优化来避免不必要的物理拷贝，但逻辑上的资源控制权转移仍然存在。

```rust
// ✅ RVO (Return Value Optimization)
// 从引用一致性视角看，这是资源控制权的逻辑转移，编译器优化避免了物理拷贝
fn create_large() -> Vec<u8> {
    vec![0; 1024 * 1024] // 资源控制权转移给调用者
}
```

---

**相关文档**:

- [Tier 3: 09_性能优化参考](../tier_03_references/09_性能优化参考.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-22
