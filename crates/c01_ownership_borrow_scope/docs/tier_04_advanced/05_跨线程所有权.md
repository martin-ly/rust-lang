# Tier 4: 跨线程所有权

> **文档类型**: 高级主题  
> **难度**: ⭐⭐⭐⭐⭐  
> **适用版本**: Rust 1.90+

---

## 1. Send 和 Sync

### Send trait

```rust
// Send: 可以安全地在线程间转移所有权
pub unsafe auto trait Send {}

// 实现 Send 的类型
impl<T: Send> Send for Vec<T> {}
impl<T: Send> Send for Box<T> {}

// 不实现 Send
impl<T> !Send for Rc<T> {}
```

### Sync trait

```rust
// Sync: 可以安全地在线程间共享引用
pub unsafe auto trait Sync {}

// T 是 Sync 当且仅当 &T 是 Send
```

---

## 2. Arc + Mutex 模式

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(0));

let handles: Vec<_> = (0..10)
    .map(|_| {
        let data = Arc::clone(&data);
        thread::spawn(move || {
            let mut num = data.lock().unwrap();
            *num += 1;
        })
    })
    .collect();

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *data.lock().unwrap());
```

---

## 3. Scoped Threads

```rust
use std::thread;

let mut data = vec![1, 2, 3];

thread::scope(|s| {
    s.spawn(|| {
        data.push(4);
    });
    
    s.spawn(|| {
        data.push(5);
    });
}); // 自动 join

println!("{:?}", data);
```

---

## 4. Atomic 类型

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

let counter = Arc::new(AtomicUsize::new(0));

let handles: Vec<_> = (0..10)
    .map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            counter.fetch_add(1, Ordering::SeqCst);
        })
    })
    .collect();

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", counter.load(Ordering::SeqCst));
```

---

## 5. 无锁数据结构

```rust
use std::sync::Arc;
use crossbeam::queue::ArrayQueue;

let queue = Arc::new(ArrayQueue::new(100));

// 无锁队列 - 高性能并发
```

---

**相关文档**:

- [C05 Threads](../../../c05_threads/)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22
