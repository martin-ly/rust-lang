# 3.2 é›¶æˆæœ¬æŠ½è±¡

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.90+  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç±»å‹**: Tier 3 é«˜çº§å®è·µæŒ‡å—

---

## ğŸ“‹ ç›®å½•

- [3.2 é›¶æˆæœ¬æŠ½è±¡](#32-é›¶æˆæœ¬æŠ½è±¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è§ˆ](#æ–‡æ¡£æ¦‚è§ˆ)
    - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
    - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
    - [ğŸ¨ æ–‡æ¡£ç‰¹è‰²](#-æ–‡æ¡£ç‰¹è‰²)
  - [1. é›¶æˆæœ¬æŠ½è±¡æ ¸å¿ƒåŸç†](#1-é›¶æˆæœ¬æŠ½è±¡æ ¸å¿ƒåŸç†)
    - [1.1 ä»€ä¹ˆæ˜¯é›¶æˆæœ¬æŠ½è±¡](#11-ä»€ä¹ˆæ˜¯é›¶æˆæœ¬æŠ½è±¡)
      - [å®šä¹‰](#å®šä¹‰)
      - [æ ¸å¿ƒæ‰¿è¯º](#æ ¸å¿ƒæ‰¿è¯º)
      - [Rust é›¶æˆæœ¬æŠ½è±¡çš„èŒƒå›´](#rust-é›¶æˆæœ¬æŠ½è±¡çš„èŒƒå›´)
    - [1.2 ç¼–è¯‘å™¨ä¼˜åŒ–æœºåˆ¶](#12-ç¼–è¯‘å™¨ä¼˜åŒ–æœºåˆ¶)
      - [LLVM ä¼˜åŒ–æµç¨‹](#llvm-ä¼˜åŒ–æµç¨‹)
      - [å…³é”®ä¼˜åŒ–](#å…³é”®ä¼˜åŒ–)
      - [ä¼˜åŒ–çº§åˆ«](#ä¼˜åŒ–çº§åˆ«)
    - [1.3 ä¸ C++ çš„å¯¹æ¯”](#13-ä¸-c-çš„å¯¹æ¯”)
      - [é›¶æˆæœ¬æŠ½è±¡å¯¹æ¯”](#é›¶æˆæœ¬æŠ½è±¡å¯¹æ¯”)
      - [æ€§èƒ½å¯¹æ¯”æ¡ˆä¾‹](#æ€§èƒ½å¯¹æ¯”æ¡ˆä¾‹)
  - [2. å•æ€åŒ– (Monomorphization)](#2-å•æ€åŒ–-monomorphization)
    - [2.1 æ³›å‹çš„ç¼–è¯‘æ—¶å±•å¼€](#21-æ³›å‹çš„ç¼–è¯‘æ—¶å±•å¼€)
      - [ä»€ä¹ˆæ˜¯å•æ€åŒ–](#ä»€ä¹ˆæ˜¯å•æ€åŒ–)
      - [ä¼˜åŠ¿](#ä¼˜åŠ¿)
      - [ç¤ºä¾‹: å®¹å™¨](#ç¤ºä¾‹-å®¹å™¨)
    - [2.2 å•æ€åŒ–çš„æˆæœ¬](#22-å•æ€åŒ–çš„æˆæœ¬)
      - [ä»£ç è†¨èƒ€ (Code Bloat)](#ä»£ç è†¨èƒ€-code-bloat)
      - [æµ‹é‡ä»£ç å¤§å°](#æµ‹é‡ä»£ç å¤§å°)
    - [2.3 ä¼˜åŒ–ç­–ç•¥](#23-ä¼˜åŒ–ç­–ç•¥)
      - [ç­–ç•¥ 1: æå–éæ³›å‹é€»è¾‘](#ç­–ç•¥-1-æå–éæ³›å‹é€»è¾‘)
      - [ç­–ç•¥ 2: ä½¿ç”¨ Trait å¯¹è±¡ï¼ˆå½“é€‚åˆæ—¶ï¼‰](#ç­–ç•¥-2-ä½¿ç”¨-trait-å¯¹è±¡å½“é€‚åˆæ—¶)
      - [ç­–ç•¥ 3: ç±»å‹è¾¹ç•Œä¼˜åŒ–](#ç­–ç•¥-3-ç±»å‹è¾¹ç•Œä¼˜åŒ–)
  - [3. å†…è”ä¼˜åŒ–](#3-å†…è”ä¼˜åŒ–)
    - [3.1 å†…è”åŸºç¡€](#31-å†…è”åŸºç¡€)
      - [ä»€ä¹ˆæ˜¯å†…è”](#ä»€ä¹ˆæ˜¯å†…è”)
      - [å†…è”çš„ä¼˜åŠ¿](#å†…è”çš„ä¼˜åŠ¿)
      - [å†…è”çš„æˆæœ¬](#å†…è”çš„æˆæœ¬)
    - [3.2 å†…è”å±æ€§](#32-å†…è”å±æ€§)
      - [#\[inline\]](#inline)
      - [#\[inline(always)\]](#inlinealways)
      - [#\[inline(never)\]](#inlinenever)
      - [è·¨ Crate å†…è”](#è·¨-crate-å†…è”)
    - [3.3 å†…è”çš„æƒè¡¡](#33-å†…è”çš„æƒè¡¡)
      - [å†³ç­–çŸ©é˜µ](#å†³ç­–çŸ©é˜µ)
      - [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)
  - [4. Trait å¯¹è±¡ vs æ³›å‹](#4-trait-å¯¹è±¡-vs-æ³›å‹)
    - [4.1 é™æ€åˆ†å‘ vs åŠ¨æ€åˆ†å‘](#41-é™æ€åˆ†å‘-vs-åŠ¨æ€åˆ†å‘)
      - [é™æ€åˆ†å‘ï¼ˆæ³›å‹ï¼‰](#é™æ€åˆ†å‘æ³›å‹)
      - [åŠ¨æ€åˆ†å‘ï¼ˆTrait å¯¹è±¡ï¼‰](#åŠ¨æ€åˆ†å‘trait-å¯¹è±¡)
      - [è™šå‡½æ•°è¡¨ (vtable)](#è™šå‡½æ•°è¡¨-vtable)
    - [4.2 æ€§èƒ½å¯¹æ¯”](#42-æ€§èƒ½å¯¹æ¯”)
      - [åŸºå‡†æµ‹è¯•](#åŸºå‡†æµ‹è¯•)
    - [4.3 é€‰æ‹©æŒ‡å—](#43-é€‰æ‹©æŒ‡å—)
      - [å†³ç­–æµç¨‹å›¾](#å†³ç­–æµç¨‹å›¾)
      - [ä½¿ç”¨åœºæ™¯å¯¹æ¯”](#ä½¿ç”¨åœºæ™¯å¯¹æ¯”)
      - [æ··åˆä½¿ç”¨](#æ··åˆä½¿ç”¨)
  - [5. è¿­ä»£å™¨ä¼˜åŒ–](#5-è¿­ä»£å™¨ä¼˜åŒ–)
    - [5.1 è¿­ä»£å™¨é›¶æˆæœ¬](#51-è¿­ä»£å™¨é›¶æˆæœ¬)
      - [æ ¸å¿ƒåŸç†](#æ ¸å¿ƒåŸç†)
      - [æ€§èƒ½è¯æ˜](#æ€§èƒ½è¯æ˜)
    - [5.2 é“¾å¼è°ƒç”¨ä¼˜åŒ–](#52-é“¾å¼è°ƒç”¨ä¼˜åŒ–)
      - [å¤æ‚é“¾å¼æ“ä½œ](#å¤æ‚é“¾å¼æ“ä½œ)
      - [æƒ°æ€§æ±‚å€¼](#æƒ°æ€§æ±‚å€¼)
    - [5.3 è¿­ä»£å™¨ vs å¾ªç¯](#53-è¿­ä»£å™¨-vs-å¾ªç¯)
      - [ä½•æ—¶ä½¿ç”¨è¿­ä»£å™¨](#ä½•æ—¶ä½¿ç”¨è¿­ä»£å™¨)
      - [ä½•æ—¶ä½¿ç”¨å¾ªç¯](#ä½•æ—¶ä½¿ç”¨å¾ªç¯)
      - [æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹](#æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹)
  - [6. æ‰€æœ‰æƒç³»ç»Ÿçš„é›¶æˆæœ¬](#6-æ‰€æœ‰æƒç³»ç»Ÿçš„é›¶æˆæœ¬)
    - [6.1 ç¼–è¯‘æ—¶å€Ÿç”¨æ£€æŸ¥](#61-ç¼–è¯‘æ—¶å€Ÿç”¨æ£€æŸ¥)
      - [é›¶è¿è¡Œæ—¶å¼€é”€](#é›¶è¿è¡Œæ—¶å¼€é”€)
      - [ä¸ C++ å¯¹æ¯”](#ä¸-c-å¯¹æ¯”)
    - [6.2 Move è¯­ä¹‰](#62-move-è¯­ä¹‰)
      - [é›¶æˆæœ¬æ‰€æœ‰æƒè½¬ç§»](#é›¶æˆæœ¬æ‰€æœ‰æƒè½¬ç§»)
      - [ä¼˜åŒ– Clone](#ä¼˜åŒ–-clone)
    - [6.3 ç”Ÿå‘½å‘¨æœŸé›¶æˆæœ¬](#63-ç”Ÿå‘½å‘¨æœŸé›¶æˆæœ¬)
      - [ç”Ÿå‘½å‘¨æœŸæ“¦é™¤](#ç”Ÿå‘½å‘¨æœŸæ“¦é™¤)
      - [æ€§èƒ½è¯æ˜6](#æ€§èƒ½è¯æ˜6)
  - [7. å®æˆ˜æ¡ˆä¾‹åˆ†æ](#7-å®æˆ˜æ¡ˆä¾‹åˆ†æ)
    - [7.1 å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–](#71-å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–)
      - [æ¡ˆä¾‹: å­—ç¬¦ä¸²è¿æ¥](#æ¡ˆä¾‹-å­—ç¬¦ä¸²è¿æ¥)
    - [7.2 é›†åˆæ“ä½œä¼˜åŒ–](#72-é›†åˆæ“ä½œä¼˜åŒ–)
      - [æ¡ˆä¾‹: è¿‡æ»¤å’Œè½¬æ¢](#æ¡ˆä¾‹-è¿‡æ»¤å’Œè½¬æ¢)
    - [7.3 é”™è¯¯å¤„ç†ä¼˜åŒ–](#73-é”™è¯¯å¤„ç†ä¼˜åŒ–)
      - [æ¡ˆä¾‹: Result ä¼ æ’­](#æ¡ˆä¾‹-result-ä¼ æ’­)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
    - [ğŸ“– æ ¸å¿ƒæ–‡æ¡£](#-æ ¸å¿ƒæ–‡æ¡£)
    - [ğŸ”— ç›¸å…³ä¸»é¢˜](#-ç›¸å…³ä¸»é¢˜)
    - [ğŸ› ï¸ å·¥å…·å’Œèµ„æº](#ï¸-å·¥å…·å’Œèµ„æº)
    - [ğŸ“š å­¦ä¹ è·¯å¾„](#-å­¦ä¹ è·¯å¾„)
    - [ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•](#-å­¦ä¹ æ£€æŸ¥æ¸…å•)

---

## æ–‡æ¡£æ¦‚è§ˆ

### ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ å°†èƒ½å¤Ÿ:

- âœ… æ·±å…¥ç†è§£ Rust é›¶æˆæœ¬æŠ½è±¡çš„æ ¸å¿ƒåŸç†
- âœ… æŒæ¡ç¼–è¯‘å™¨ä¼˜åŒ–æœºåˆ¶åŠå…¶å¯¹æ€§èƒ½çš„å½±å“
- âœ… ç†è§£æ³›å‹ã€å•æ€åŒ–å’Œå†…è”çš„å·¥ä½œæ–¹å¼
- âœ… åœ¨é™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘ä¹‹é—´åšå‡ºæ˜æ™ºé€‰æ‹©
- âœ… å……åˆ†åˆ©ç”¨è¿­ä»£å™¨çš„é›¶æˆæœ¬ç‰¹æ€§
- âœ… ç¼–å†™é«˜æ€§èƒ½ä¸”å®‰å…¨çš„ Rust ä»£ç 

### ğŸ“š å‰ç½®çŸ¥è¯†

å­¦ä¹ æœ¬æ–‡æ¡£å‰ï¼Œä½ éœ€è¦:

- âœ… æŒæ¡ Rust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨ç³»ç»Ÿ
- âœ… ç†Ÿæ‚‰æ³›å‹å’Œ Trait çš„åŸºæœ¬ä½¿ç”¨
- âœ… äº†è§£è¿­ä»£å™¨çš„åŸºæœ¬æ¦‚å¿µ
- âœ… æœ‰ä¸€å®šçš„æ€§èƒ½ä¼˜åŒ–æ„è¯†

**æ¨èå…ˆå­¦ä¹ **: [Tier 2 æ ¸å¿ƒæ¦‚å¿µ](../tier2_core_concepts/README.md)

### ğŸ¨ æ–‡æ¡£ç‰¹è‰²

æœ¬æ–‡æ¡£æä¾›:

- ğŸ“– **åŸç†æ·±åº¦**: æ·±å…¥ç¼–è¯‘å™¨å†…éƒ¨ï¼Œç†è§£ä¼˜åŒ–æœºåˆ¶
- ğŸ’¡ **å¯¹æ¯”åˆ†æ**: æ€§èƒ½å¯¹æ¯”å’Œæƒè¡¡è®¨è®º
- âš¡ **å®æˆ˜ä¼˜åŒ–**: å…·ä½“çš„ä¼˜åŒ–æŠ€å·§å’Œæ¡ˆä¾‹
- ğŸ“Š **æ€§èƒ½æ•°æ®**: åŸºå‡†æµ‹è¯•å’Œæ€§èƒ½åˆ†æ
- ğŸ”— **å·¥å…·é“¾**: ç›¸å…³å·¥å…·å’Œè°ƒè¯•æŠ€å·§

---

## 1. é›¶æˆæœ¬æŠ½è±¡æ ¸å¿ƒåŸç†

### 1.1 ä»€ä¹ˆæ˜¯é›¶æˆæœ¬æŠ½è±¡

#### å®šä¹‰

**é›¶æˆæœ¬æŠ½è±¡ (Zero-Cost Abstractions)** æ˜¯ Rust çš„æ ¸å¿ƒè®¾è®¡åŸåˆ™ä¹‹ä¸€ï¼Œæ„å‘³ç€:

> ä½ ä¸éœ€è¦ä¸ºä½ ä¸ä½¿ç”¨çš„åŠŸèƒ½ä»˜å‡ºä»£ä»·ï¼Œè€Œä½ ä½¿ç”¨çš„åŠŸèƒ½ï¼Œæ‰‹å†™ä¹Ÿä¸ä¼šæ¯”å®ƒæ›´å¿«ã€‚

ç”¨ Bjarne Stroustrupï¼ˆC++ ä¹‹çˆ¶ï¼‰çš„è¯è¯´:
> "What you don't use, you don't pay for. And what you do use, you couldn't hand code any better."

#### æ ¸å¿ƒæ‰¿è¯º

```rust
// é«˜çº§æŠ½è±¡ä»£ç 
let sum: i32 = (0..1000)
    .filter(|x| x % 2 == 0)
    .map(|x| x * x)
    .sum();

// ç¼–è¯‘åç­‰ä»·äºæ‰‹å†™çš„å¾ªç¯
let mut sum = 0;
for i in 0..1000 {
    if i % 2 == 0 {
        sum += i * i;
    }
}
```

**å…³é”®ç‚¹**:

- âœ… æŠ½è±¡å±‚ä¸å¼•å…¥è¿è¡Œæ—¶å¼€é”€
- âœ… ç¼–è¯‘å™¨ä¼˜åŒ–åˆ°ä¸æ‰‹å†™ä»£ç ç›¸åŒçš„æ€§èƒ½
- âœ… ä¿æŒä»£ç å¯è¯»æ€§å’Œå®‰å…¨æ€§

#### Rust é›¶æˆæœ¬æŠ½è±¡çš„èŒƒå›´

| ç‰¹æ€§ | è¿è¡Œæ—¶å¼€é”€ | è¯´æ˜ |
|------|----------|------|
| **æ³›å‹** | âŒ æ—  | ç¼–è¯‘æ—¶å•æ€åŒ– |
| **è¿­ä»£å™¨** | âŒ æ—  | å®Œå…¨å†…è”å’Œä¼˜åŒ– |
| **æ‰€æœ‰æƒ** | âŒ æ—  | ç¼–è¯‘æ—¶æ£€æŸ¥ |
| **ç”Ÿå‘½å‘¨æœŸ** | âŒ æ—  | ç¼–è¯‘æ—¶æ“¦é™¤ |
| **Match** | âŒ æ—  | ç¼–è¯‘ä¸ºé«˜æ•ˆçš„è·³è½¬è¡¨ |
| **é—­åŒ…** | âŒ æ—  | å†…è”æˆ–å•æ€åŒ– |
| **Trait (é™æ€)** | âŒ æ—  | ç¼–è¯‘æ—¶è§£æ |
| **Trait (åŠ¨æ€)** | âœ… æœ‰ | è™šå‡½æ•°è¡¨æŸ¥æ‰¾ |
| **Arc/Rc** | âœ… æœ‰ | åŸå­/éåŸå­å¼•ç”¨è®¡æ•° |
| **RefCell** | âœ… æœ‰ | è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥ |

### 1.2 ç¼–è¯‘å™¨ä¼˜åŒ–æœºåˆ¶

#### LLVM ä¼˜åŒ–æµç¨‹

Rust ç¼–è¯‘å™¨ä¾èµ– LLVM è¿›è¡Œä»£ç ä¼˜åŒ–:

```text
Rust æºä»£ç 
    â†“ (rustc å‰ç«¯)
HIR (High-level IR)
    â†“ (ç±»å‹æ£€æŸ¥ã€å€Ÿç”¨æ£€æŸ¥)
MIR (Mid-level IR)
    â†“ (å•æ€åŒ–)
LLVM IR
    â†“ (LLVM ä¼˜åŒ–)
æœºå™¨ç 
```

#### å…³é”®ä¼˜åŒ–

1. **å¸¸é‡æŠ˜å  (Constant Folding)**

   ```rust
   // æºä»£ç 
   fn compute() -> i32 {
       let x = 5;
       let y = 10;
       x * y + 20
   }
   
   // ç¼–è¯‘å™¨ä¼˜åŒ–ä¸º
   fn compute() -> i32 {
       70  // ç›´æ¥è¿”å›è®¡ç®—ç»“æœ
   }
   ```

2. **æ­»ä»£ç æ¶ˆé™¤ (Dead Code Elimination)**

   ```rust
   // æºä»£ç 
   fn process(use_cache: bool) {
       if use_cache {
           println!("Using cache");
       } else {
           println!("Not using cache");
       }
   }
   
   // å½“ use_cache æ˜¯ç¼–è¯‘æ—¶å¸¸é‡æ—¶
   fn process_with_cache() {
       println!("Using cache");
       // else åˆ†æ”¯è¢«å®Œå…¨ç§»é™¤
   }
   ```

3. **å†…è” (Inlining)**

   ```rust
   #[inline]
   fn add(a: i32, b: i32) -> i32 {
       a + b
   }
   
   fn compute() -> i32 {
       add(5, 10)  // å†…è”ä¸º: 5 + 10
   }
   
   // ä¼˜åŒ–å
   fn compute() -> i32 {
       15  // å¸¸é‡æŠ˜å  + å†…è”
   }
   ```

4. **å‘é‡åŒ– (Vectorization)**

   ```rust
   // è‡ªåŠ¨å‘é‡åŒ–ï¼ˆä½¿ç”¨ SIMDï¼‰
   fn sum_array(arr: &[i32]) -> i32 {
       arr.iter().sum()
   }
   
   // ç¼–è¯‘å™¨å¯èƒ½ç”Ÿæˆ SIMD æŒ‡ä»¤ï¼Œä¸€æ¬¡å¤„ç†å¤šä¸ªå…ƒç´ 
   ```

#### ä¼˜åŒ–çº§åˆ«

| çº§åˆ« | æ ‡å¿— | è¯´æ˜ | ä½¿ç”¨åœºæ™¯ |
|------|------|------|---------|
| **0** | `-C opt-level=0` | æ— ä¼˜åŒ– | å¼€å‘è°ƒè¯• |
| **1** | `-C opt-level=1` | åŸºæœ¬ä¼˜åŒ– | å¿«é€Ÿæ„å»º |
| **2** | `-C opt-level=2` | é»˜è®¤ä¼˜åŒ– | Release æ„å»º |
| **3** | `-C opt-level=3` | æ¿€è¿›ä¼˜åŒ– | æ€§èƒ½å…³é”®åº”ç”¨ |
| **s** | `-C opt-level=s` | ä»£ç å¤§å°ä¼˜åŒ– | åµŒå…¥å¼ç³»ç»Ÿ |
| **z** | `-C opt-level=z` | æè‡´ä»£ç å¤§å° | èµ„æºå—é™ç¯å¢ƒ |

```toml
# Cargo.toml
[profile.release]
opt-level = 3
lto = true  # Link-Time Optimization
codegen-units = 1  # æ›´å¥½çš„ä¼˜åŒ–ï¼Œä½†ç¼–è¯‘æ…¢
```

### 1.3 ä¸ C++ çš„å¯¹æ¯”

#### é›¶æˆæœ¬æŠ½è±¡å¯¹æ¯”

| ç‰¹æ€§ | Rust | C++ | èƒœè€… |
|------|------|-----|------|
| **æ³›å‹** | å•æ€åŒ– | æ¨¡æ¿å±•å¼€ | ğŸ¤ å¹³æ‰‹ |
| **è¿­ä»£å™¨** | é›¶æˆæœ¬ | æœ‰æ—¶é›¶æˆæœ¬ | ğŸ¦€ Rust |
| **æ™ºèƒ½æŒ‡é’ˆ** | Arc/Rc/Box | shared_ptr/unique_ptr | ğŸ¤ å¹³æ‰‹ |
| **ç§»åŠ¨è¯­ä¹‰** | é»˜è®¤ move | æ˜¾å¼ std::move | ğŸ¦€ Rust |
| **RAII** | è‡ªåŠ¨ Drop | è‡ªåŠ¨ææ„ | ğŸ¤ å¹³æ‰‹ |
| **é”™è¯¯å¤„ç†** | Result (é›¶æˆæœ¬) | å¼‚å¸¸ (æœ‰å¼€é”€) | ğŸ¦€ Rust |
| **å†…å­˜å®‰å…¨** | ç¼–è¯‘æ—¶æ£€æŸ¥ | è¿è¡Œæ—¶UB | ğŸ¦€ Rust |

#### æ€§èƒ½å¯¹æ¯”æ¡ˆä¾‹

**æ¡ˆä¾‹ 1: è¿­ä»£å™¨æ±‚å’Œ**:

```rust
// Rust
fn sum_rust(data: &[i32]) -> i32 {
    data.iter().sum()
}
```

```cpp
// C++
int sum_cpp(const std::vector<int>& data) {
    return std::accumulate(data.begin(), data.end(), 0);
}
```

**æ€§èƒ½**: ğŸ¤ ç›¸åŒï¼ˆéƒ½ä¼˜åŒ–ä¸ºé«˜æ•ˆçš„å¾ªç¯ï¼‰

**æ¡ˆä¾‹ 2: é”™è¯¯å¤„ç†**:

```rust
// Rust (é›¶æˆæœ¬)
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

fn caller() -> Result<i32, String> {
    let result = divide(10, 2)?;  // é›¶æˆæœ¬ä¼ æ’­
    Ok(result * 2)
}
```

```cpp
// C++ (å¼‚å¸¸æœ‰å¼€é”€)
int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int caller() {
    try {
        int result = divide(10, 2);
        return result * 2;
    } catch (const std::exception& e) {
        // å¼‚å¸¸å¤„ç†è·¯å¾„æœ‰å¼€é”€
        return 0;
    }
}
```

**æ€§èƒ½**: ğŸ¦€ Rust æ›´ä¼˜ï¼ˆResult æ˜¯é›¶æˆæœ¬ï¼ŒC++ å¼‚å¸¸æœ‰å¼€é”€ï¼‰

---

## 2. å•æ€åŒ– (Monomorphization)

### 2.1 æ³›å‹çš„ç¼–è¯‘æ—¶å±•å¼€

#### ä»€ä¹ˆæ˜¯å•æ€åŒ–

å•æ€åŒ–æ˜¯ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆç‹¬ç«‹ä»£ç çš„è¿‡ç¨‹:

```rust
// æ³›å‹å‡½æ•°
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

fn main() {
    let i = max(5, 10);        // i32 ç‰ˆæœ¬
    let f = max(3.14, 2.71);   // f64 ç‰ˆæœ¬
    let s = max("hello", "world"); // &str ç‰ˆæœ¬
}
```

**ç¼–è¯‘å™¨ç”Ÿæˆ**:

```rust
// ç¼–è¯‘å™¨å®é™…ç”Ÿæˆçš„ä»£ç ï¼ˆæ¦‚å¿µä¸Šï¼‰
fn max_i32(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}

fn max_f64(a: f64, b: f64) -> f64 {
    if a > b { a } else { b }
}

fn max_str<'a>(a: &'a str, b: &'a str) -> &'a str {
    if a > b { a } else { b }
}

fn main() {
    let i = max_i32(5, 10);
    let f = max_f64(3.14, 2.71);
    let s = max_str("hello", "world");
}
```

#### ä¼˜åŠ¿

âœ… **é›¶è¿è¡Œæ—¶å¼€é”€**: æ— è™šå‡½æ•°è¡¨æŸ¥æ‰¾
âœ… **æ›´å¥½çš„ä¼˜åŒ–**: ç¼–è¯‘å™¨å¯é’ˆå¯¹å…·ä½“ç±»å‹ä¼˜åŒ–
âœ… **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥

#### ç¤ºä¾‹: å®¹å™¨

```rust
use std::collections::HashMap;

fn main() {
    let mut map1 = HashMap::new();
    map1.insert("key", 42);  // HashMap<&str, i32>
    
    let mut map2 = HashMap::new();
    map2.insert(1, "value");  // HashMap<i32, &str>
}

// ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªç±»å‹ç»„åˆç”Ÿæˆç‹¬ç«‹çš„ HashMap å®ç°
// HashMap_str_i32, HashMap_i32_str, etc.
```

### 2.2 å•æ€åŒ–çš„æˆæœ¬

#### ä»£ç è†¨èƒ€ (Code Bloat)

```rust
// è¿™ä¸ªå‡½æ•°ä¼šä¸ºæ¯ä¸ªç±»å‹ç”Ÿæˆä¸€ä»½ä»£ç 
fn process<T: std::fmt::Debug>(items: Vec<T>) {
    for item in items {
        println!("{:?}", item);
    }
}

fn main() {
    process(vec![1, 2, 3]);          // process_i32
    process(vec![1.0, 2.0, 3.0]);    // process_f64
    process(vec!["a", "b", "c"]);    // process_str
    process(vec![true, false]);       // process_bool
    // ... æ¯ä¸ªç±»å‹éƒ½ç”Ÿæˆä¸€ä»½ä»£ç 
}
```

**å½±å“**:

- âš ï¸ **äºŒè¿›åˆ¶å¤§å°å¢åŠ **: æ¯ä¸ªç±»å‹éƒ½æœ‰ç‹¬ç«‹å®ç°
- âš ï¸ **ç¼–è¯‘æ—¶é—´å¢åŠ **: éœ€è¦ç”Ÿæˆæ›´å¤šä»£ç 
- âš ï¸ **æŒ‡ä»¤ç¼“å­˜å‹åŠ›**: æ›´å¤šä»£ç å¯èƒ½é™ä½ç¼“å­˜æ•ˆç‡

#### æµ‹é‡ä»£ç å¤§å°

```bash
# æŸ¥çœ‹äºŒè¿›åˆ¶å¤§å°
cargo build --release
ls -lh target/release/your_binary

# åˆ†æäºŒè¿›åˆ¶ç»„æˆ
cargo bloat --release

# æŸ¥çœ‹å•æ€åŒ–çš„å½±å“
cargo build --release -Z print-type-sizes
```

### 2.3 ä¼˜åŒ–ç­–ç•¥

#### ç­–ç•¥ 1: æå–éæ³›å‹é€»è¾‘

```rust
// âŒ æ¯ä¸ªç±»å‹éƒ½ç”Ÿæˆå®Œæ•´ä»£ç 
fn process<T: std::fmt::Debug>(items: Vec<T>) {
    println!("Starting process...");
    for item in items {
        println!("{:?}", item);
    }
    println!("Process complete!");
}

// âœ… æå–éæ³›å‹éƒ¨åˆ†
fn process_header() {
    println!("Starting process...");
}

fn process_footer() {
    println!("Process complete!");
}

fn process<T: std::fmt::Debug>(items: Vec<T>) {
    process_header();  // åªæœ‰ä¸€ä»½ä»£ç 
    for item in items {
        println!("{:?}", item);
    }
    process_footer();  // åªæœ‰ä¸€ä»½ä»£ç 
}
```

#### ç­–ç•¥ 2: ä½¿ç”¨ Trait å¯¹è±¡ï¼ˆå½“é€‚åˆæ—¶ï¼‰

```rust
// é™æ€åˆ†å‘ï¼šä»£ç è†¨èƒ€
fn static_dispatch<T: std::fmt::Display>(items: Vec<T>) {
    for item in items {
        println!("{}", item);
    }
}

// åŠ¨æ€åˆ†å‘ï¼šä»£ç å…±äº«
fn dynamic_dispatch(items: Vec<Box<dyn std::fmt::Display>>) {
    for item in items {
        println!("{}", item);
    }
}

// æƒè¡¡ï¼š
// - é™æ€åˆ†å‘ï¼šæ›´å¿«ï¼Œä½†ä»£ç æ›´å¤§
// - åŠ¨æ€åˆ†å‘ï¼šä»£ç å°ï¼Œä½†æœ‰è™šå‡½æ•°å¼€é”€
```

#### ç­–ç•¥ 3: ç±»å‹è¾¹ç•Œä¼˜åŒ–

```rust
// âŒ è¿‡å®½çš„ç±»å‹è¾¹ç•Œ
fn process<T: Clone + std::fmt::Debug + Send + Sync + 'static>(value: T) {
    println!("{:?}", value);
}

// âœ… åªä½¿ç”¨å¿…è¦çš„è¾¹ç•Œ
fn process<T: std::fmt::Debug>(value: T) {
    println!("{:?}", value);
}
```

---

## 3. å†…è”ä¼˜åŒ–

### 3.1 å†…è”åŸºç¡€

#### ä»€ä¹ˆæ˜¯å†…è”

å†…è”æ˜¯å°†å‡½æ•°è°ƒç”¨æ›¿æ¢ä¸ºå‡½æ•°ä½“çš„è¿‡ç¨‹:

```rust
// å®šä¹‰
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// è°ƒç”¨
fn compute() -> i32 {
    let x = add(5, 10);
    let y = add(x, 20);
    x + y
}

// å†…è”åï¼ˆæ¦‚å¿µä¸Šï¼‰
fn compute() -> i32 {
    let x = 5 + 10;      // add(5, 10) å†…è”
    let y = x + 20;       // add(x, 20) å†…è”
    x + y
}

// è¿›ä¸€æ­¥ä¼˜åŒ–
fn compute() -> i32 {
    55  // å¸¸é‡æŠ˜å 
}
```

#### å†…è”çš„ä¼˜åŠ¿

âœ… **æ¶ˆé™¤å‡½æ•°è°ƒç”¨å¼€é”€**: æ— éœ€ä¿å­˜/æ¢å¤å¯„å­˜å™¨ã€è·³è½¬ç­‰
âœ… **å¯ç”¨æ›´å¤šä¼˜åŒ–**: ç¼–è¯‘å™¨å¯ä»¥çœ‹åˆ°æ›´å¤§çš„ä¸Šä¸‹æ–‡
âœ… **å‡å°‘åˆ†æ”¯é¢„æµ‹å¤±è´¥**: å‡å°‘å‡½æ•°è°ƒç”¨å¯¼è‡´çš„åˆ†æ”¯

#### å†…è”çš„æˆæœ¬

âš ï¸ **ä»£ç è†¨èƒ€**: ç›¸åŒä»£ç åœ¨å¤šå¤„å¤åˆ¶
âš ï¸ **æŒ‡ä»¤ç¼“å­˜å‹åŠ›**: ä»£ç å˜å¤§å¯èƒ½é™ä½ç¼“å­˜å‘½ä¸­ç‡
âš ï¸ **ç¼–è¯‘æ—¶é—´**: ç¼–è¯‘å™¨éœ€è¦å¤„ç†æ›´å¤šä»£ç 

### 3.2 å†…è”å±æ€§

#### #[inline]

å»ºè®®ç¼–è¯‘å™¨å†…è”ï¼ˆç¼–è¯‘å™¨å¯èƒ½å¿½ç•¥ï¼‰:

```rust
#[inline]
fn fast_path(x: i32) -> i32 {
    x * 2
}
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… å°å‡½æ•°ï¼ˆå‡ è¡Œä»£ç ï¼‰
- âœ… çƒ­è·¯å¾„å‡½æ•°
- âœ… æ³›å‹å‡½æ•°ï¼ˆè·¨ crateï¼‰

#### #[inline(always)]

å¼ºåˆ¶ç¼–è¯‘å™¨å†…è”ï¼ˆé™¤éç»å¯¹ä¸å¯èƒ½ï¼‰:

```rust
#[inline(always)]
fn critical_tiny_function(x: i32) -> i32 {
    x + 1
}
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… æå°çš„å…³é”®å‡½æ•°
- âš ï¸ **è°¨æ…ä½¿ç”¨**: å¯èƒ½å¯¼è‡´ä»£ç è†¨èƒ€

#### #[inline(never)]

ç¦æ­¢å†…è”:

```rust
#[inline(never)]
fn debugging_function() {
    // è°ƒè¯•æ—¶éœ€è¦ä¿ç•™è°ƒç”¨æ ˆ
}
```

**ä½¿ç”¨åœºæ™¯**:

- ğŸ” è°ƒè¯•ï¼ˆä¿ç•™è°ƒç”¨æ ˆï¼‰
- ğŸ” æ€§èƒ½åˆ†æï¼ˆæ¸…æ™°çš„æ€§èƒ½å‰–æï¼‰

#### è·¨ Crate å†…è”

```rust
// lib.rs
#[inline]  // âš ï¸ æ²¡æœ‰è¿™ä¸ªï¼Œè·¨ crate è°ƒç”¨ä¸ä¼šå†…è”
pub fn public_api() {
    // ...
}
```

**å…³é”®ç‚¹**:

- âš ï¸ æ²¡æœ‰ `#[inline]` çš„å…¬å…±å‡½æ•°ä¸ä¼šè·¨ crate å†…è”
- âœ… æ³›å‹å‡½æ•°è‡ªåŠ¨è·¨ crate å†…è”ï¼ˆå•æ€åŒ–ï¼‰

### 3.3 å†…è”çš„æƒè¡¡

#### å†³ç­–çŸ©é˜µ

| å‡½æ•°ç‰¹å¾ | å†…è”å»ºè®® | åŸå›  |
|---------|---------|------|
| **1-3 è¡Œ** | âœ… æ€»æ˜¯å†…è” | å‡ ä¹æ²¡æœ‰ç¼ºç‚¹ |
| **4-10 è¡Œ** | âœ… é€šå¸¸å†…è” | åˆ©å¤§äºå¼Š |
| **10-30 è¡Œ** | âš ï¸ è°¨æ…è€ƒè™‘ | å–å†³äºè°ƒç”¨é¢‘ç‡ |
| **30+ è¡Œ** | âŒ é€šå¸¸ä¸å†…è” | ä»£ç è†¨èƒ€é£é™© |
| **çƒ­è·¯å¾„** | âœ… ä¼˜å…ˆè€ƒè™‘ | æ€§èƒ½æ•æ„Ÿ |
| **å†·è·¯å¾„** | âŒ ä¸å»ºè®® | ä»£ç å¤§å°æ›´é‡è¦ |
| **é€’å½’** | âŒ ä¸å¯èƒ½/ä¸å»ºè®® | æ— é™å±•å¼€ |

#### å®æˆ˜æ¡ˆä¾‹

```rust
// âœ… åº”è¯¥å†…è”ï¼šå°ä¸”é¢‘ç¹è°ƒç”¨
#[inline]
pub fn point_distance(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt()
}

// âš ï¸ å¯èƒ½å†…è”ï¼šä¸­ç­‰å¤§å°ï¼Œå–å†³äºè°ƒç”¨é¢‘ç‡
#[inline]
pub fn parse_config(text: &str) -> Option<Config> {
    let lines: Vec<&str> = text.lines().collect();
    if lines.len() < 2 {
        return None;
    }
    // ... 10-20 è¡Œè§£æé€»è¾‘
    Some(Config { /* ... */ })
}

// âŒ ä¸åº”å†…è”ï¼šå¤§å‹å‡½æ•°
// #[inline]  // âŒ ä¸åŠ è¿™ä¸ª
pub fn complex_algorithm(data: &[i32]) -> Vec<i32> {
    // ... 50+ è¡Œå¤æ‚é€»è¾‘
}
```

---

## 4. Trait å¯¹è±¡ vs æ³›å‹

### 4.1 é™æ€åˆ†å‘ vs åŠ¨æ€åˆ†å‘

#### é™æ€åˆ†å‘ï¼ˆæ³›å‹ï¼‰

```rust
// é™æ€åˆ†å‘ï¼šç¼–è¯‘æ—¶ç¡®å®š
fn process_static<T: std::fmt::Display>(item: T) {
    println!("Item: {}", item);
}

fn main() {
    process_static(42);       // ç”Ÿæˆ process_static_i32
    process_static("hello");   // ç”Ÿæˆ process_static_str
}
```

**ç‰¹ç‚¹**:

- âœ… é›¶è¿è¡Œæ—¶å¼€é”€
- âœ… å¯å†…è”
- âš ï¸ ä»£ç è†¨èƒ€

#### åŠ¨æ€åˆ†å‘ï¼ˆTrait å¯¹è±¡ï¼‰

```rust
// åŠ¨æ€åˆ†å‘ï¼šè¿è¡Œæ—¶ç¡®å®š
fn process_dynamic(item: &dyn std::fmt::Display) {
    println!("Item: {}", item);
}

fn main() {
    process_dynamic(&42);      // éƒ½ä½¿ç”¨åŒä¸€ä¸ªå‡½æ•°
    process_dynamic(&"hello");
}
```

**ç‰¹ç‚¹**:

- âœ… ä»£ç å…±äº«
- âœ… çµæ´»æ€§ï¼ˆå¼‚æ„é›†åˆï¼‰
- âš ï¸ è™šå‡½æ•°è¡¨æŸ¥æ‰¾å¼€é”€
- âš ï¸ æ— æ³•å†…è”

#### è™šå‡½æ•°è¡¨ (vtable)

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
impl Draw for Circle {
    fn draw(&self) { println!("Drawing circle"); }
}

struct Square;
impl Draw for Square {
    fn draw(&self) { println!("Drawing square"); }
}

// åŠ¨æ€åˆ†å‘
let shapes: Vec<Box<dyn Draw>> = vec![
    Box::new(Circle),
    Box::new(Square),
];

for shape in shapes {
    shape.draw();  // é€šè¿‡ vtable æŸ¥æ‰¾å¹¶è°ƒç”¨
}
```

**vtable ç»“æ„**:

```text
Box<dyn Draw>
    â”œâ”€ data pointer (æŒ‡å‘å®é™…å¯¹è±¡)
    â””â”€ vtable pointer
           â”œâ”€ draw å‡½æ•°æŒ‡é’ˆ
           â”œâ”€ drop å‡½æ•°æŒ‡é’ˆ
           â””â”€ size/alignment ç­‰å…ƒæ•°æ®
```

### 4.2 æ€§èƒ½å¯¹æ¯”

#### åŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

trait Operation {
    fn execute(&self, x: i32) -> i32;
}

struct AddOne;
impl Operation for AddOne {
    fn execute(&self, x: i32) -> i32 { x + 1 }
}

// é™æ€åˆ†å‘
fn static_dispatch<T: Operation>(op: &T, data: &[i32]) -> i32 {
    data.iter().map(|x| op.execute(*x)).sum()
}

// åŠ¨æ€åˆ†å‘
fn dynamic_dispatch(op: &dyn Operation, data: &[i32]) -> i32 {
    data.iter().map(|x| op.execute(*x)).sum()
}

fn benchmark(c: &mut Criterion) {
    let data: Vec<i32> = (0..1000).collect();
    let op = AddOne;
    
    c.bench_function("static_dispatch", |b| {
        b.iter(|| static_dispatch(black_box(&op), black_box(&data)))
    });
    
    c.bench_function("dynamic_dispatch", |b| {
        b.iter(|| dynamic_dispatch(black_box(&op), black_box(&data)))
    });
}

criterion_group!(benches, benchmark);
criterion_main!(benches);
```

**å…¸å‹ç»“æœ**:

| æ–¹æ³• | æ—¶é—´ | ç›¸å¯¹æ€§èƒ½ |
|------|------|---------|
| **é™æ€åˆ†å‘** | 300 ns | åŸºå‡† (1.0x) |
| **åŠ¨æ€åˆ†å‘** | 350 ns | ~1.15x æ…¢ |

**ç»“è®º**:

- åŠ¨æ€åˆ†å‘å¼€é”€é€šå¸¸åœ¨ 10-20% èŒƒå›´å†…
- å¯¹äºç®€å•æ“ä½œï¼Œå¼€é”€æ›´æ˜æ˜¾
- å¯¹äºå¤æ‚æ“ä½œï¼Œå¼€é”€å¯å¿½ç•¥

### 4.3 é€‰æ‹©æŒ‡å—

#### å†³ç­–æµç¨‹å›¾

```text
éœ€è¦è¿è¡Œæ—¶å¤šæ€ï¼Ÿ
    â†“ å¦                           â†“ æ˜¯
ä½¿ç”¨æ³›å‹                      èƒ½å¦ä½¿ç”¨ enumï¼Ÿ
(é™æ€åˆ†å‘)                        â†“ æ˜¯           â†“ å¦
                             ä½¿ç”¨ enum        ç±»å‹é›†åˆå›ºå®šï¼Ÿ
                          (æ¨¡å¼åŒ¹é…)            â†“ æ˜¯         â†“ å¦
                                          è€ƒè™‘æ³›å‹        ä½¿ç”¨ Trait å¯¹è±¡
                                       (æœ‰é™ç±»å‹)        (åŠ¨æ€åˆ†å‘)
```

#### ä½¿ç”¨åœºæ™¯å¯¹æ¯”

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | åŸå›  |
|------|---------|------|
| **å·²çŸ¥ç±»å‹** | æ³›å‹ | é›¶æˆæœ¬ |
| **å¼‚æ„é›†åˆ** | Trait å¯¹è±¡ | çµæ´»æ€§ |
| **æ’ä»¶ç³»ç»Ÿ** | Trait å¯¹è±¡ | è¿è¡Œæ—¶åŠ è½½ |
| **æ€§èƒ½å…³é”®** | æ³›å‹ | æœ€å¿« |
| **åº“ API** | æ³›å‹ | ç”¨æˆ·å‹å¥½ |
| **å°‘é‡ç±»å‹** | Enum | æœ€ä¼˜ï¼ˆæ¨¡å¼åŒ¹é…ï¼‰ |

#### æ··åˆä½¿ç”¨

```rust
trait Processor {
    fn process(&self, data: &str) -> String;
}

// é™æ€åˆ†å‘ APIï¼ˆé«˜æ€§èƒ½ï¼‰
pub fn process_fast<P: Processor>(processor: &P, data: &str) -> String {
    processor.process(data)
}

// åŠ¨æ€åˆ†å‘ APIï¼ˆçµæ´»æ€§ï¼‰
pub fn process_flexible(processor: &dyn Processor, data: &str) -> String {
    processor.process(data)
}

// ç”¨æˆ·å¯æ ¹æ®éœ€æ±‚é€‰æ‹©
```

---

## 5. è¿­ä»£å™¨ä¼˜åŒ–

### 5.1 è¿­ä»£å™¨é›¶æˆæœ¬

#### æ ¸å¿ƒåŸç†

Rust è¿­ä»£å™¨ç¼–è¯‘åä¸æ‰‹å†™å¾ªç¯æ€§èƒ½ç›¸åŒ:

```rust
// é«˜çº§è¿­ä»£å™¨
let sum: i32 = (0..1000)
    .filter(|x| x % 2 == 0)
    .map(|x| x * x)
    .sum();

// ç¼–è¯‘å™¨ç”Ÿæˆï¼ˆç­‰ä»·äºï¼‰
let mut sum = 0;
let mut i = 0;
while i < 1000 {
    if i % 2 == 0 {
        sum += i * i;
    }
    i += 1;
}
```

**ä¸ºä»€ä¹ˆé›¶æˆæœ¬**ï¼Ÿ

1. âœ… **å†…è”**: æ‰€æœ‰è¿­ä»£å™¨æ–¹æ³•éƒ½å†…è”
2. âœ… **å•æ€åŒ–**: æ¯ä¸ªè¿­ä»£å™¨é“¾ç”Ÿæˆä¸“é—¨çš„ä»£ç 
3. âœ… **LLVM ä¼˜åŒ–**: è¿›ä¸€æ­¥ä¼˜åŒ–ä¸ºæœ€ä¼˜æœºå™¨ç 

#### æ€§èƒ½è¯æ˜

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn iterator_sum(data: &[i32]) -> i32 {
    data.iter().sum()
}

fn loop_sum(data: &[i32]) -> i32 {
    let mut sum = 0;
    for item in data {
        sum += item;
    }
    sum
}

fn manual_loop_sum(data: &[i32]) -> i32 {
    let mut sum = 0;
    let mut i = 0;
    while i < data.len() {
        sum += data[i];
        i += 1;
    }
    sum
}

fn benchmark(c: &mut Criterion) {
    let data: Vec<i32> = (0..10000).collect();
    
    c.bench_function("iterator", |b| {
        b.iter(|| iterator_sum(black_box(&data)))
    });
    
    c.bench_function("for_loop", |b| {
        b.iter(|| loop_sum(black_box(&data)))
    });
    
    c.bench_function("while_loop", |b| {
        b.iter(|| manual_loop_sum(black_box(&data)))
    });
}

criterion_group!(benches, benchmark);
criterion_main!(benches);
```

**å…¸å‹ç»“æœ**: ä¸‰è€…æ€§èƒ½å®Œå…¨ç›¸åŒï¼

### 5.2 é“¾å¼è°ƒç”¨ä¼˜åŒ–

#### å¤æ‚é“¾å¼æ“ä½œ

```rust
let result: Vec<_> = data
    .iter()
    .filter(|x| **x > 0)
    .map(|x| x * 2)
    .filter(|x| x % 3 == 0)
    .take(100)
    .collect();

// ç¼–è¯‘åèåˆä¸ºå•ä¸€å¾ªç¯
let mut result = Vec::new();
let mut count = 0;
for x in data {
    if x > 0 {
        let doubled = x * 2;
        if doubled % 3 == 0 {
            result.push(doubled);
            count += 1;
            if count >= 100 {
                break;
            }
        }
    }
}
```

**å…³é”®ä¼˜åŒ–**:

- âœ… **å¾ªç¯èåˆ**: å¤šä¸ªæ“ä½œåˆå¹¶ä¸ºä¸€ä¸ªå¾ªç¯
- âœ… **çŸ­è·¯ä¼˜åŒ–**: `take` æå‰ç»ˆæ­¢
- âœ… **æ— ä¸­é—´åˆ†é…**: ä¸åˆ›å»ºä¸´æ—¶é›†åˆ

#### æƒ°æ€§æ±‚å€¼

```rust
let iter = data
    .iter()
    .filter(|x| {
        println!("Filtering {}", x);  // åªåœ¨å®é™…è¿­ä»£æ—¶æ‰§è¡Œ
        **x > 0
    });

// æ­¤æ—¶æ²¡æœ‰ä»»ä½•è¾“å‡ºï¼Œå› ä¸ºè¿­ä»£å™¨æ˜¯æƒ°æ€§çš„

for item in iter.take(3) {
    println!("Item: {}", item);
}
// åªä¼šè¿‡æ»¤å’Œæ‰“å°å‰3ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
```

### 5.3 è¿­ä»£å™¨ vs å¾ªç¯

#### ä½•æ—¶ä½¿ç”¨è¿­ä»£å™¨

âœ… **æ¨èä½¿ç”¨è¿­ä»£å™¨**:

```rust
// âœ… æ•°æ®è½¬æ¢
let doubled: Vec<_> = numbers.iter().map(|x| x * 2).collect();

// âœ… è¿‡æ»¤
let evens: Vec<_> = numbers.iter().filter(|x| *x % 2 == 0).collect();

// âœ… èšåˆ
let sum: i32 = numbers.iter().sum();
let max: Option<&i32> = numbers.iter().max();

// âœ… ç»„åˆæ“ä½œ
let result = numbers
    .iter()
    .filter(|x| **x > 0)
    .map(|x| x * x)
    .sum();
```

#### ä½•æ—¶ä½¿ç”¨å¾ªç¯

âš ï¸ **è€ƒè™‘ä½¿ç”¨å¾ªç¯**:

```rust
// âš ï¸ å¤æ‚æ§åˆ¶æµ
for item in items {
    if some_condition {
        continue;
    }
    if other_condition {
        break;
    }
    // å¤æ‚é€»è¾‘
}

// âš ï¸ å¤šä¸ªå¯å˜å˜é‡
let mut sum = 0;
let mut count = 0;
for item in items {
    if item > 0 {
        sum += item;
        count += 1;
    }
}

// âš ï¸ éœ€è¦ç´¢å¼•çš„å¤æ‚æ“ä½œ
for i in 0..data.len() {
    if i > 0 && data[i] == data[i-1] {
        // æ¯”è¾ƒç›¸é‚»å…ƒç´ 
    }
}
```

#### æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹

```rust
// è¿­ä»£å™¨ï¼šæ¸…æ™°ä¸”é«˜æ•ˆ
fn process_iterator(data: &[i32]) -> Vec<i32> {
    data.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .collect()
}

// ç­‰ä»·çš„å¾ªç¯ï¼šåŒæ ·é«˜æ•ˆï¼Œä½†æ›´å†—é•¿
fn process_loop(data: &[i32]) -> Vec<i32> {
    let mut result = Vec::new();
    for &item in data {
        if item > 0 {
            result.push(item * 2);
        }
    }
    result
}

// æ€§èƒ½ï¼šå®Œå…¨ç›¸åŒï¼
```

---

## 6. æ‰€æœ‰æƒç³»ç»Ÿçš„é›¶æˆæœ¬

### 6.1 ç¼–è¯‘æ—¶å€Ÿç”¨æ£€æŸ¥

#### é›¶è¿è¡Œæ—¶å¼€é”€

Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨åœ¨ç¼–è¯‘æ—¶å·¥ä½œï¼Œä¸å¼•å…¥ä»»ä½•è¿è¡Œæ—¶å¼€é”€:

```rust
fn process_data(data: &Vec<i32>) {
    // å€Ÿç”¨æ£€æŸ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆ
    println!("First: {}", data[0]);
}

// ç¼–è¯‘åçš„æœºå™¨ç ç­‰ä»·äº C:
// void process_data(const std::vector<int>* data) {
//     printf("First: %d\n", (*data)[0]);
// }
```

**å…³é”®ç‚¹**:

- âœ… æ— è¿è¡Œæ—¶å€Ÿç”¨è·Ÿè¸ª
- âœ… æ— å¼•ç”¨è®¡æ•°
- âœ… ç›´æ¥æŒ‡é’ˆæ“ä½œ

#### ä¸ C++ å¯¹æ¯”

```rust
// Rust: ç¼–è¯‘æ—¶å®‰å…¨ï¼Œé›¶å¼€é”€
fn rust_version(data: &[i32]) -> i32 {
    data.iter().sum()  // å®‰å…¨ + é›¶æˆæœ¬
}
```

```cpp
// C++: åŒæ ·æ€§èƒ½ï¼Œä½†æ— å®‰å…¨ä¿è¯
int cpp_version(const std::vector<int>& data) {
    return std::accumulate(data.begin(), data.end(), 0);
}
```

### 6.2 Move è¯­ä¹‰

#### é›¶æˆæœ¬æ‰€æœ‰æƒè½¬ç§»

```rust
struct LargeData {
    buffer: Vec<u8>,  // å‡è®¾å¾ˆå¤§
}

fn take_ownership(data: LargeData) {
    // data è¢« moveï¼Œæ— æ‹·è´
}

fn main() {
    let data = LargeData {
        buffer: vec![0; 1_000_000],
    };
    
    take_ownership(data);  // åªä¼ é€’æŒ‡é’ˆï¼ŒO(1)
    // data ä¸å†å¯ç”¨ï¼Œç¼–è¯‘æ—¶æ£€æŸ¥
}
```

**ç¼–è¯‘å**:

```text
Stack:
    data (8 bytes):  [ptr to heap | len | capacity]
                          â†“
    ä¼ é€’ç»™å‡½æ•° (8 bytes æ‹·è´)
                          â†“
    å‡½æ•°æ¥æ”¶ (8 bytes)
```

**ä¸ C++ å¯¹æ¯”**:

```cpp
// C++ (C++11)
std::vector<uint8_t> data(1'000'000, 0);

// éœ€è¦æ˜¾å¼ std::move
take_ownership(std::move(data));

// Rust: é»˜è®¤ moveï¼Œç¼–è¯‘æ—¶æ£€æŸ¥
// C++: éœ€è¦æ˜¾å¼ moveï¼Œå¯èƒ½å¿˜è®°
```

#### ä¼˜åŒ– Clone

```rust
// âŒ ä¸å¿…è¦çš„å…‹éš†
fn process(data: Vec<i32>) -> Vec<i32> {
    let mut result = data.clone();  // æ˜‚è´µ
    result.push(42);
    result
}

// âœ… ç›´æ¥ä¿®æ”¹
fn process(mut data: Vec<i32>) -> Vec<i32> {
    data.push(42);
    data  // move è¿”å›ï¼Œé›¶æˆæœ¬
}
```

### 6.3 ç”Ÿå‘½å‘¨æœŸé›¶æˆæœ¬

#### ç”Ÿå‘½å‘¨æœŸæ“¦é™¤

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨åœ¨ç¼–è¯‘åå®Œå…¨æ“¦é™¤:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// ç¼–è¯‘åç­‰ä»·äºï¼ˆæ— ç”Ÿå‘½å‘¨æœŸä¿¡æ¯ï¼‰:
// const char* longest(const char* x, const char* y) {
//     return strlen(x) > strlen(y) ? x : y;
// }
```

**å…³é”®ç‚¹**:

- âœ… ç”Ÿå‘½å‘¨æœŸåªåœ¨ç¼–è¯‘æ—¶å­˜åœ¨
- âœ… è¿è¡Œæ—¶æ— ä»»ä½•è¿½è¸ª
- âœ… ç›´æ¥æŒ‡é’ˆæ“ä½œ

#### æ€§èƒ½è¯æ˜6

```rust
// å¤æ‚ç”Ÿå‘½å‘¨æœŸ
struct ComplexRef<'a, 'b> {
    field1: &'a str,
    field2: &'b [i32],
}

fn process<'a, 'b>(data: ComplexRef<'a, 'b>) -> &'a str {
    data.field1
}

// ç¼–è¯‘å: åªæ˜¯ç®€å•çš„æŒ‡é’ˆæ“ä½œï¼Œæ— å¼€é”€
```

---

## 7. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 7.1 å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–

#### æ¡ˆä¾‹: å­—ç¬¦ä¸²è¿æ¥

```rust
// âŒ ä½æ•ˆï¼šå¤šæ¬¡åˆ†é…
fn concat_bad(strings: &[String]) -> String {
    let mut result = String::new();
    for s in strings {
        result = result + s;  // æ¯æ¬¡éƒ½åˆ†é…æ–°å†…å­˜
    }
    result
}

// âœ… é«˜æ•ˆï¼šé¢„åˆ†é… + push_str
fn concat_good(strings: &[String]) -> String {
    let total_len: usize = strings.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(total_len);
    for s in strings {
        result.push_str(s);  // æ— é¢å¤–åˆ†é…
    }
    result
}

// âœ… æœ€ä½³ï¼šä½¿ç”¨è¿­ä»£å™¨ï¼ˆé›¶æˆæœ¬ï¼‰
fn concat_best(strings: &[String]) -> String {
    strings.join("")
}
```

**æ€§èƒ½å¯¹æ¯”** (1000 ä¸ªå­—ç¬¦ä¸²):

| æ–¹æ³• | æ—¶é—´ | åˆ†é…æ¬¡æ•° |
|------|------|---------|
| `concat_bad` | 50 ms | ~1000 |
| `concat_good` | 5 ms | 1 |
| `concat_best` | 5 ms | 1 |

### 7.2 é›†åˆæ“ä½œä¼˜åŒ–

#### æ¡ˆä¾‹: è¿‡æ»¤å’Œè½¬æ¢

```rust
// âŒ åˆ›å»ºä¸­é—´é›†åˆ
fn transform_bad(numbers: Vec<i32>) -> Vec<i32> {
    let filtered: Vec<i32> = numbers
        .iter()
        .filter(|&&x| x > 0)
        .copied()
        .collect();  // ä¸­é—´åˆ†é…
    
    filtered
        .iter()
        .map(|&x| x * 2)
        .collect()  // ç¬¬äºŒæ¬¡åˆ†é…
}

// âœ… å•æ¬¡éå†
fn transform_good(numbers: Vec<i32>) -> Vec<i32> {
    numbers
        .into_iter()
        .filter(|&x| x > 0)
        .map(|x| x * 2)
        .collect()  // åªåˆ†é…ä¸€æ¬¡
}

// âœ… åŸåœ°ä¿®æ”¹ï¼ˆå¦‚æœå¯èƒ½ï¼‰
fn transform_best(mut numbers: Vec<i32>) -> Vec<i32> {
    numbers.retain(|&x| x > 0);
    for x in &mut numbers {
        *x *= 2;
    }
    numbers  // é›¶é¢å¤–åˆ†é…
}
```

### 7.3 é”™è¯¯å¤„ç†ä¼˜åŒ–

#### æ¡ˆä¾‹: Result ä¼ æ’­

```rust
use std::fs::File;
use std::io::{self, Read};

// âŒ æ˜¾å¼åŒ¹é…ï¼ˆå†—é•¿ï¼‰
fn read_file_bad(path: &str) -> Result<String, io::Error> {
    let file = match File::open(path) {
        Ok(f) => f,
        Err(e) => return Err(e),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

// âœ… ä½¿ç”¨ ? æ“ä½œç¬¦ï¼ˆé›¶æˆæœ¬ï¼‰
fn read_file_good(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// âœ… é“¾å¼è°ƒç”¨
fn read_file_best(path: &str) -> Result<String, io::Error> {
    std::fs::read_to_string(path)
}
```

**å…³é”®ç‚¹**:

- `?` æ“ä½œç¬¦æ˜¯é›¶æˆæœ¬çš„ï¼ˆç¼–è¯‘ä¸ºç®€å•çš„åˆ†æ”¯ï¼‰
- ä¸ C++ å¼‚å¸¸ç›¸æ¯”ï¼Œæ— æ ˆå±•å¼€å¼€é”€
- ä¸æ˜¾å¼ match æ€§èƒ½å®Œå…¨ç›¸åŒ

---

## ç›¸å…³èµ„æº

### ğŸ“– æ ¸å¿ƒæ–‡æ¡£

- **[æ€§èƒ½ä¼˜åŒ–](../04_safety/03_performance_optimization.md)**: æ·±å…¥çš„æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- **[æ€§èƒ½è°ƒä¼˜](../05_practice/04_performance_tuning.md)**: å®è·µä¸­çš„æ€§èƒ½è°ƒä¼˜
- **[é«˜çº§æ‰€æœ‰æƒæ¨¡å¼](./3.1_é«˜çº§æ‰€æœ‰æƒæ¨¡å¼.md)**: æ‰€æœ‰æƒç³»ç»Ÿçš„é«˜çº§ç”¨æ³•

### ğŸ”— ç›¸å…³ä¸»é¢˜

- **Tier 3 é«˜çº§ä¸»é¢˜**
  - [3.1 é«˜çº§æ‰€æœ‰æƒæ¨¡å¼](./3.1_é«˜çº§æ‰€æœ‰æƒæ¨¡å¼.md)
  - [3.3 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ](./3.3_å†…å­˜å®‰å…¨æœ€ä½³å®è·µ.md)
  - [3.4 æ€§èƒ½ä¼˜åŒ–](./3.4_æ€§èƒ½ä¼˜åŒ–.md)

- **Tier 4 ç†è®ºæ·±åº¦**
  - [4.1 ç±»å‹ç³»ç»Ÿç†è®º](../tier4_theoretical/4.1_ç±»å‹ç³»ç»Ÿç†è®º.md)

### ğŸ› ï¸ å·¥å…·å’Œèµ„æº

**æ€§èƒ½åˆ†æå·¥å…·**:

- `cargo bench` - åŸºå‡†æµ‹è¯•
- `criterion` - é«˜çº§åŸºå‡†æµ‹è¯•æ¡†æ¶
- `perf` - Linux æ€§èƒ½åˆ†æ
- `Instruments` - macOS æ€§èƒ½åˆ†æ
- `cargo-bloat` - åˆ†æäºŒè¿›åˆ¶å¤§å°
- `cargo-asm` - æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–ä»£ç 

**å­¦ä¹ èµ„æº**:

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Rust Compiler Optimizations](https://doc.rust-lang.org/rustc/codegen-options/)
- [LLVM Optimization Remarks](https://llvm.org/docs/Remarks.html)

### ğŸ“š å­¦ä¹ è·¯å¾„

**è¿›é˜¶è·¯å¾„**:

1. å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ ï¼ˆé¢„ä¼° 6-8 å°æ—¶ï¼‰
2. å®è·µæ€§èƒ½åŸºå‡†æµ‹è¯•
3. åˆ†æå®é™…é¡¹ç›®çš„æ€§èƒ½ç“¶é¢ˆ
4. æ·±å…¥å­¦ä¹  [æ€§èƒ½ä¼˜åŒ–](./3.4_æ€§èƒ½ä¼˜åŒ–.md)

**å®è·µå»ºè®®**:

- ğŸ”¨ ä¸ºè‡ªå·±çš„ä»£ç ç¼–å†™åŸºå‡†æµ‹è¯•
- ğŸ”¨ ä½¿ç”¨ `cargo-asm` æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–ä»£ç 
- ğŸ”¨ å¯¹æ¯”ä¸åŒå®ç°çš„æ€§èƒ½
- ğŸ”¨ åˆ†æä»£ç çš„äºŒè¿›åˆ¶å¤§å°

### ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ä»¥éªŒè¯å­¦ä¹ æ•ˆæœ:

- [ ] ç†è§£é›¶æˆæœ¬æŠ½è±¡çš„æ ¸å¿ƒåŸç†
- [ ] æŒæ¡å•æ€åŒ–å’Œå†…è”æœºåˆ¶
- [ ] èƒ½å¤Ÿåœ¨é™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘ä¹‹é—´åšå‡ºé€‰æ‹©
- [ ] å……åˆ†åˆ©ç”¨è¿­ä»£å™¨çš„é›¶æˆæœ¬ç‰¹æ€§
- [ ] ç†è§£æ‰€æœ‰æƒç³»ç»Ÿçš„æ€§èƒ½ä¼˜åŠ¿
- [ ] èƒ½å¤Ÿç¼–å†™å’Œè¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
- [ ] è¯†åˆ«å’Œä¼˜åŒ–æ€§èƒ½ç“¶é¢ˆ
- [ ] åœ¨æ€§èƒ½å’Œä»£ç å¯è¯»æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0 (æ‰©å±•ç‰ˆ)  
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.90+  
**é¢„ä¼°å­¦ä¹ æ—¶é—´**: 6-8 å°æ—¶  
**éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

END OF DOCUMENT
