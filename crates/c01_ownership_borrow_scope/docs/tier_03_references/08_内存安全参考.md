# 3.3 内存安全最佳实践

**文档版本**: 2.0
**适用 Rust 版本**: 1.92.0+
**最后更新**: 2025-12-11
**文档类型**: Tier 3 高级实践指南

---

## 📋 目录

- [3.3 内存安全最佳实践](#33-内存安全最佳实践)
  - [📋 目录](#-目录)
  - [文档概览](#文档概览)
    - [🎯 学习目标](#-学习目标)
    - [📚 前置知识](#-前置知识)
    - [🎨 文档特色](#-文档特色)
    - [📖 核心内容](#-核心内容)
  - [1. 内存安全核心原则](#1-内存安全核心原则)
    - [1.1 Rust 内存安全保证](#11-rust-内存安全保证)
      - [核心保证](#核心保证)
      - [内存安全层次](#内存安全层次)
    - [1.2 内存安全边界](#12-内存安全边界)
      - [Unsafe 边界](#unsafe-边界)
      - [安全抽象](#安全抽象)
    - [1.3 常见内存错误预防](#13-常见内存错误预防)
      - [1. Use-After-Free](#1-use-after-free)
      - [2. Double-Free](#2-double-free)
      - [3. Memory Leak](#3-memory-leak)
      - [4. Data Race](#4-data-race)
  - [2. 安全 Rust 最佳实践](#2-安全-rust-最佳实践)
    - [2.1 所有权模式](#21-所有权模式)
      - [模式 1: 明确所有权](#模式-1-明确所有权)
      - [模式 2: 借用优先](#模式-2-借用优先)
      - [模式 3: Cow 模式](#模式-3-cow-模式)
    - [2.2 生命周期管理](#22-生命周期管理)
      - [最佳实践 1: 生命周期省略](#最佳实践-1-生命周期省略)
      - [最佳实践 2: 避免复杂生命周期](#最佳实践-2-避免复杂生命周期)
      - [最佳实践 3: 生命周期边界](#最佳实践-3-生命周期边界)
    - [2.3 类型安全设计](#23-类型安全设计)
      - [模式 1: 新类型模式](#模式-1-新类型模式)
      - [模式 2: 类型状态模式](#模式-2-类型状态模式)
      - [模式 3: Builder 模式](#模式-3-builder-模式)
  - [3. Unsafe Rust 使用指南](#3-unsafe-rust-使用指南)
    - [3.1 何时使用 Unsafe](#31-何时使用-unsafe)
      - [合理使用场景](#合理使用场景)
      - [避免使用场景](#避免使用场景)
    - [3.2 Unsafe 代码模式](#32-unsafe-代码模式)
      - [模式 1: 最小化 Unsafe 边界](#模式-1-最小化-unsafe-边界)
      - [模式 2: 文档化不变量](#模式-2-文档化不变量)
      - [模式 3: Unsafe 函数 vs Unsafe 块](#模式-3-unsafe-函数-vs-unsafe-块)
    - [3.3 Unsafe 代码审计](#33-unsafe-代码审计)
      - [审计清单](#审计清单)
      - [审计工具](#审计工具)
  - [4. FFI 安全性](#4-ffi-安全性)
    - [4.1 C 互操作性](#41-c-互操作性)
      - [基本 FFI 模式](#基本-ffi-模式)
      - [从 C 接收字符串](#从-c-接收字符串)
      - [传递结构体给 C](#传递结构体给-c)
    - [4.2 内存布局保证](#42-内存布局保证)
      - [Repr 属性](#repr-属性)
      - [对齐和大小](#对齐和大小)
    - [4.3 FFI 最佳实践](#43-ffi-最佳实践)
      - [最佳实践 1: 错误处理](#最佳实践-1-错误处理)
      - [最佳实践 2: 内存管理](#最佳实践-2-内存管理)
      - [最佳实践 3: 版本管理](#最佳实践-3-版本管理)
  - [5. 并发安全模式](#5-并发安全模式)
    - [5.1 数据竞争预防](#51-数据竞争预防)
      - [Send 和 Sync 基础](#send-和-sync-基础)
      - [共享状态模式](#共享状态模式)
    - [5.2 Send 和 Sync](#52-send-和-sync)
      - [手动实现 Send/Sync](#手动实现-sendsync)
      - [常见类型的 Send/Sync 状态](#常见类型的-sendsync-状态)
    - [5.3 并发内存模型](#53-并发内存模型)
      - [原子操作](#原子操作)
      - [内存顺序](#内存顺序)
  - [6. 内存泄漏预防](#6-内存泄漏预防)
    - [6.1 循环引用检测](#61-循环引用检测)
      - [检测工具](#检测工具)
    - [6.2 资源管理模式](#62-资源管理模式)
      - [RAII 模式](#raii-模式)
    - [6.3 Drop 最佳实践](#63-drop-最佳实践)
  - [7. 安全性审计和工具](#7-安全性审计和工具)
    - [7.1 静态分析工具](#71-静态分析工具)
    - [7.2 动态检测工具](#72-动态检测工具)
    - [7.3 安全性测试](#73-安全性测试)
  - [相关资源](#相关资源)
    - [📖 核心文档](#-核心文档)
    - [🔗 相关主题](#-相关主题)
    - [🛠️ 工具和资源](#️-工具和资源)
    - [📚 学习路径](#-学习路径)
    - [🎯 学习检查清单](#-学习检查清单)

---

## 文档概览

### 🎯 学习目标

完成本文档学习后，你将能够:

- ✅ 深入理解 Rust 资源安全的核心原则和保证（编译期逻辑证明，非内存检查）
- ✅ 掌握安全 Rust 代码的最佳实践（资源控制权的逻辑证明）
- ✅ 正确和安全地使用 Unsafe Rust（资源安全的边界）
- ✅ 实现安全的 FFI 互操作（资源管理的编译期证明）
- ✅ 设计和实现线程安全的并发代码（编译期排他性契约的验证）
- ✅ 识别和预防资源泄漏（逻辑证明的失败）
- ✅ 使用工具进行安全性审计

### 📚 前置知识

学习本文档前，你需要:

- ✅ 精通 Rust 的所有权、借用和生命周期系统
- ✅ 熟悉 Rust 的类型系统和 Trait
- ✅ 了解并发编程基础
- ✅ 有一定的系统编程经验

**推荐先学习**: [Tier 2 核心概念](../tier2_core_concepts/README.md), [3.1 高级所有权模式](./3.1_高级所有权模式.md)

### 🎨 文档特色

本文档提供:

- 🛡️ **安全保证**: 详解 Rust 的内存安全机制
- ⚠️ **常见陷阱**: 标注易错点和危险模式
- 💡 **最佳实践**: 经过验证的安全模式
- 🔍 **审计指南**: 代码审查和安全检查方法
- 🛠️ **工具链**: 安全分析和检测工具

### 📖 核心内容

**相关完整文档**:

- **[内存安全分析](../04_safety/01_memory_safety.md)**: 深入的内存安全机制分析
- **[并发编程](../05_practice/05_concurrent_programming.md)**: 并发场景的安全实践
- **[Unsafe Rust](../04_safety/02_unsafe_rust.md)**: Unsafe 代码详细指南

---

## 1. 内存安全核心原则

### 1.1 Rust 内存安全保证

#### 核心保证

Rust 在编译时保证以下资源安全特性（引用一致性视角）:

1. **无空指针解引用**（编译期逻辑证明）

   ```rust
   // ❌ C/C++: 可能崩溃
   // int* ptr = nullptr;
   // *ptr = 42;  // undefined behavior

   // ✅ Rust: 编译时阻止
   let ptr: Option<Box<i32>> = None;
   // let value = *ptr;  // ❌ 编译错误

   // 必须显式处理
   if let Some(boxed) = ptr {
       let value = *boxed;  // ✅ 安全
   }
   ```

2. **无悬垂引用**（引用一致性视角）

   ```rust
   // ❌ 不可能创建悬垂引用（逻辑证明的失败，非内存地址失效）
   fn dangling_pointer() -> &String {
       let s = String::from("hello");
       &s  // ❌ 编译错误：逻辑关系错误，引用会失效（编译期逻辑证明）
   }

   // ✅ 正确做法：转移所有权
   fn valid_return() -> String {
       let s = String::from("hello");
       s  // ✅ 所有权转移
   }
   ```

3. **无数据竞争**

   ```rust
   use std::sync::Mutex;
   use std::thread;

   // ✅ Rust 保证线程安全
   let data = Mutex::new(0);

   let handles: Vec<_> = (0..10)
       .map(|_| {
           let data = data.clone();  // ❌ 编译错误：Mutex 不能 clone
           thread::spawn(move || {
               let mut num = data.lock().unwrap();
               *num += 1;
           })
       })
       .collect();

   // ✅ 正确做法：使用 Arc
   use std::sync::Arc;
   let data = Arc::new(Mutex::new(0));
   ```

4. **无缓冲区溢出**

   ```rust
   // ✅ Rust 自动边界检查
   let arr = [1, 2, 3, 4, 5];
   // let x = arr[10];  // ❌ 运行时 panic（而非 undefined behavior）

   // ✅ 安全访问
   if let Some(&x) = arr.get(10) {
       println!("{}", x);
   } else {
       println!("Index out of bounds");
   }
   ```

5. **无迭代器失效**

   ```rust
   let mut vec = vec![1, 2, 3];

   // ❌ C++: undefined behavior
   // for (auto& item : vec) {
   //     vec.push_back(item * 2);  // 迭代器失效
   // }

   // ✅ Rust: 编译时阻止
   for item in &vec {
       // vec.push(*item * 2);  // ❌ 编译错误：已有不可变借用
   }
   ```

#### 内存安全层次

```text
完全安全
    ↑
    ├─ Safe Rust (默认)
    │   - 编译器保证内存安全
    │   - 无 undefined behavior
    │   - 可能有 panic (受控)
    │
    ├─ Unsafe Rust
    │   - 绕过部分检查
    │   - 程序员负责安全性
    │   - 必须维护不变量
    │
    ├─ FFI (Foreign Function Interface)
    │   - 与 C/C++ 互操作
    │   - 无安全保证
    │   - 需要 unsafe 边界
    │
    └─ Assembly / 内联汇编
        - 完全无保护
        - 需要极度小心
```

### 1.2 内存安全边界

#### Unsafe 边界

Unsafe 代码必须维护的不变量:

```rust
// Unsafe 边界：确保传入的指针有效
unsafe fn read_ptr<T>(ptr: *const T) -> T {
    // 调用者必须保证：
    // 1. ptr 非空
    // 2. ptr 指向有效的 T
    // 3. ptr 对齐正确
    // 4. T 的内存已初始化
    std::ptr::read(ptr)
}

// ✅ 安全包装
fn safe_read<T: Copy>(slice: &[T], index: usize) -> Option<T> {
    slice.get(index).copied()
}
```

#### 安全抽象

```rust
// ✅ 内部使用 unsafe，但对外保证安全
pub struct SafeBuffer {
    data: Vec<u8>,
    len: usize,
}

impl SafeBuffer {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            len: 0,
        }
    }

    // ✅ 公共 API 完全安全
    pub fn push(&mut self, byte: u8) {
        if self.len < self.data.capacity() {
            unsafe {
                // 安全：已检查容量
                let ptr = self.data.as_mut_ptr().add(self.len);
                std::ptr::write(ptr, byte);
            }
            self.len += 1;
            unsafe {
                // 安全：len 与实际数据同步
                self.data.set_len(self.len);
            }
        }
    }

    pub fn get(&self, index: usize) -> Option<u8> {
        if index < self.len {
            Some(self.data[index])
        } else {
            None
        }
    }
}
```

### 1.3 常见内存错误预防

#### 1. Use-After-Free

```rust
// ❌ C/C++: use-after-free
// int* ptr = new int(42);
// delete ptr;
// *ptr = 100;  // undefined behavior

// ✅ Rust: 不可能
let ptr = Box::new(42);
drop(ptr);
// *ptr = 100;  // ❌ 编译错误：ptr 已 moved
```

#### 2. Double-Free

```rust
// ❌ C/C++: double-free
// int* ptr = new int(42);
// delete ptr;
// delete ptr;  // undefined behavior

// ✅ Rust: 不可能
let ptr = Box::new(42);
drop(ptr);
// drop(ptr);  // ❌ 编译错误：ptr 已 moved
```

#### 3. Memory Leak

```rust
use std::rc::Rc;
use std::cell::RefCell;

// ⚠️ 可能发生：循环引用
struct Node {
    next: Option<Rc<RefCell<Node>>>,
}

fn leak_example() {
    let a = Rc::new(RefCell::new(Node { next: None }));
    let b = Rc::new(RefCell::new(Node { next: Some(Rc::clone(&a)) }));
    a.borrow_mut().next = Some(Rc::clone(&b));
    // a 和 b 形成循环引用，内存泄漏
}

// ✅ 解决方案：使用 Weak
use std::rc::Weak;

struct SafeNode {
    next: Option<Weak<RefCell<SafeNode>>>,
}
```

#### 4. Data Race

```rust
use std::sync::Arc;
use std::thread;

// ❌ 编译错误：数据竞争
fn data_race_attempt() {
    let mut data = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        data.push(4);
    });

    // data.push(5);  // ❌ 编译错误：data 已 moved

    handle.join().unwrap();
}

// ✅ 正确做法：使用 Mutex
use std::sync::Mutex;

fn no_data_race() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        data_clone.lock().unwrap().push(4);
    });

    data.lock().unwrap().push(5);

    handle.join().unwrap();
}
```

---

## 2. 安全 Rust 最佳实践

### 2.1 所有权模式

#### 模式 1: 明确所有权

```rust
// ✅ 明确的所有权语义
struct Configuration {
    settings: HashMap<String, String>,
}

impl Configuration {
    // 获取所有权
    fn new(settings: HashMap<String, String>) -> Self {
        Self { settings }
    }

    // 借用
    fn get(&self, key: &str) -> Option<&String> {
        self.settings.get(key)
    }

    // 可变借用
    fn set(&mut self, key: String, value: String) {
        self.settings.insert(key, value);
    }

    // 转移所有权
    fn into_inner(self) -> HashMap<String, String> {
        self.settings
    }
}
```

#### 模式 2: 借用优先

```rust
// ✅ 优先使用借用，减少不必要的拷贝
fn process_string(s: &str) {  // &str 而非 String
    println!("Processing: {}", s);
}

fn process_slice(data: &[i32]) {  // &[i32] 而非 Vec<i32>
    println!("Length: {}", data.len());
}

// ✅ 灵活接受多种类型
fn flexible_api(s: impl AsRef<str>) {
    let s_ref: &str = s.as_ref();
    println!("{}", s_ref);
}

fn main() {
    flexible_api("string literal");
    flexible_api(String::from("owned string"));
}
```

#### 模式 3: Cow 模式

```rust
use std::borrow::Cow;

// ✅ 根据需要选择借用或拥有
fn process_text(text: Cow<str>) -> Cow<str> {
    if text.contains("bad_word") {
        // 需要修改：转换为 Owned
        Cow::Owned(text.replace("bad_word", "***"))
    } else {
        // 无需修改：保持 Borrowed
        text
    }
}

fn main() {
    let text1 = "Hello world";
    let result1 = process_text(Cow::Borrowed(text1));  // 无拷贝

    let text2 = "Hello bad_word";
    let result2 = process_text(Cow::Borrowed(text2));  // 仅在需要时拷贝
}
```

### 2.2 生命周期管理

#### 最佳实践 1: 生命周期省略

```rust
// ✅ 利用生命周期省略规则
impl MyStruct {
    // 省略规则：返回值生命周期与 &self 相同
    fn get_name(&self) -> &str {
        &self.name
    }

    // 显式标注（当省略规则不适用时）
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() { x } else { y }
    }
}
```

#### 最佳实践 2: 避免复杂生命周期

```rust
// ❌ 复杂的生命周期
struct ComplexStruct<'a, 'b, 'c> {
    field1: &'a str,
    field2: &'b str,
    field3: &'c str,
}

// ✅ 简化：使用统一生命周期或拥有型
struct SimplerStruct<'a> {
    field1: &'a str,
    field2: &'a str,
    field3: String,  // 拥有型，无生命周期
}

// ✅ 或完全拥有型
struct OwnedStruct {
    field1: String,
    field2: String,
    field3: String,
}
```

#### 最佳实践 3: 生命周期边界

```rust
// ✅ 明确生命周期边界
struct Cache<'a, T: 'a> {
    data: HashMap<String, &'a T>,
}

impl<'a, T: 'a> Cache<'a, T> {
    fn new() -> Self {
        Self { data: HashMap::new() }
    }

    fn insert(&mut self, key: String, value: &'a T) {
        self.data.insert(key, value);
    }

    fn get(&self, key: &str) -> Option<&&'a T> {
        self.data.get(key)
    }
}
```

### 2.3 类型安全设计

#### 模式 1: 新类型模式

```rust
// ✅ 使用新类型提供类型安全
struct UserId(u64);
struct ProductId(u64);
struct OrderId(u64);

// 编译时阻止混用
fn get_user(id: UserId) -> User { /* ... */ }
fn get_product(id: ProductId) -> Product { /* ... */ }

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);

    get_user(user_id);  // ✅ OK
    // get_user(product_id);  // ❌ 编译错误：类型不匹配
}
```

#### 模式 2: 类型状态模式

```rust
// ✅ 使用类型系统强制状态转换

// 状态标记
struct Open;
struct Closed;

struct File<State> {
    path: PathBuf,
    _state: PhantomData<State>,
}

impl File<Closed> {
    fn new(path: PathBuf) -> Self {
        Self {
            path,
            _state: PhantomData,
        }
    }

    fn open(self) -> Result<File<Open>, std::io::Error> {
        // 打开文件...
        Ok(File {
            path: self.path,
            _state: PhantomData,
        })
    }
}

impl File<Open> {
    fn read(&self) -> Result<String, std::io::Error> {
        std::fs::read_to_string(&self.path)
    }

    fn close(self) -> File<Closed> {
        File {
            path: self.path,
            _state: PhantomData,
        }
    }
}

fn main() {
    let file = File::<Closed>::new(PathBuf::from("file.txt"));
    // file.read();  // ❌ 编译错误：文件未打开

    let file = file.open().unwrap();
    file.read().unwrap();  // ✅ OK
}
```

#### 模式 3: Builder 模式

```rust
// ✅ 使用 Builder 确保必要字段设置
struct Config {
    host: String,
    port: u16,
    timeout: Duration,
}

struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<Duration>,
}

impl ConfigBuilder {
    fn new() -> Self {
        Self {
            host: None,
            port: None,
            timeout: None,
        }
    }

    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }

    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    fn timeout(mut self, timeout: Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }

    fn build(self) -> Result<Config, &'static str> {
        Ok(Config {
            host: self.host.ok_or("host is required")?,
            port: self.port.ok_or("port is required")?,
            timeout: self.timeout.unwrap_or(Duration::from_secs(30)),
        })
    }
}
```

---

## 3. Unsafe Rust 使用指南

### 3.1 何时使用 Unsafe

#### 合理使用场景

✅ **1. 性能关键路径**

```rust
// 示例：跳过边界检查（当已验证安全时）
fn sum_optimized(data: &[i32]) -> i32 {
    let mut sum = 0;
    for i in 0..data.len() {
        // 安全：循环保证 i < data.len()
        unsafe {
            sum += *data.get_unchecked(i);
        }
    }
    sum
}
```

✅ **2. FFI 互操作**

```rust
extern "C" {
    fn c_function(x: i32) -> i32;
}

pub fn safe_wrapper(x: i32) -> i32 {
    unsafe { c_function(x) }
}
```

✅ **3. 底层数据结构**

```rust
// 示例：实现高效的环形缓冲区
pub struct RingBuffer<T> {
    buffer: Vec<T>,
    head: usize,
    tail: usize,
}

impl<T> RingBuffer<T> {
    pub fn push(&mut self, item: T) {
        unsafe {
            // 安全：capacity 已预分配
            let ptr = self.buffer.as_mut_ptr().add(self.tail);
            std::ptr::write(ptr, item);
        }
        self.tail = (self.tail + 1) % self.buffer.capacity();
    }
}
```

#### 避免使用场景

❌ **1. 绕过借用检查器**

```rust
// ❌ 不要为了"方便"使用 unsafe
let mut x = 5;
let ptr = &mut x as *mut i32;
unsafe {
    *ptr = 10;
}
// 应该重新设计代码，避免需要 unsafe
```

❌ **2. 过早优化**

```rust
// ❌ 没有证明性能瓶颈就使用 unsafe
fn premature_optimization(data: &[i32]) -> i32 {
    unsafe {
        // 复杂且危险的 unsafe 代码
    }
}

// ✅ 先使用安全代码，再根据性能测试优化
fn safe_version(data: &[i32]) -> i32 {
    data.iter().sum()
}
```

### 3.2 Unsafe 代码模式

#### 模式 1: 最小化 Unsafe 边界

```rust
// ✅ 将 unsafe 限制在小范围内
fn process_buffer(data: &[u8]) -> Vec<u8> {
    let mut result = Vec::with_capacity(data.len());

    unsafe {
        // 只在必要时使用 unsafe
        let src = data.as_ptr();
        let dst = result.as_mut_ptr();
        std::ptr::copy_nonoverlapping(src, dst, data.len());
        result.set_len(data.len());
    }

    result
}
```

#### 模式 2: 文档化不变量

```rust
/// 原始指针包装器
///
/// # Safety
///
/// 使用者必须保证：
/// 1. 指针在整个生命周期内有效
/// 2. 指针指向的内存已正确初始化
/// 3. 不存在其他可变引用
pub struct RawWrapper<T> {
    ptr: *const T,
}

impl<T> RawWrapper<T> {
    /// 从引用创建
    ///
    /// # Safety
    ///
    /// 安全：从有效引用创建
    pub fn new(reference: &T) -> Self {
        Self { ptr: reference as *const T }
    }

    /// 解引用指针
    ///
    /// # Safety
    ///
    /// 调用者必须保证指针仍然有效
    pub unsafe fn get(&self) -> &T {
        &*self.ptr
    }
}
```

#### 模式 3: Unsafe 函数 vs Unsafe 块

```rust
// ✅ Unsafe 函数：调用者负责安全性
pub unsafe fn read_unaligned<T>(ptr: *const T) -> T {
    std::ptr::read_unaligned(ptr)
}

// ✅ 安全函数（内部unsafe）：实现者负责安全性
pub fn safe_read<T: Copy>(slice: &[T], index: usize) -> Option<T> {
    if index < slice.len() {
        Some(unsafe {
            // 安全：已检查索引
            *slice.get_unchecked(index)
        })
    } else {
        None
    }
}
```

### 3.3 Unsafe 代码审计

#### 审计清单

**基本检查**:

- [ ] 所有 unsafe 块都有注释说明为何安全
- [ ] 边界检查已在 unsafe 前完成
- [ ] 指针解引用前已验证非空和有效性
- [ ] 内存对齐需求已满足
- [ ] 生命周期约束已正确处理
- [ ] 并发访问已正确同步

**常见问题**:

```rust
// ❌ 未检查边界
unsafe fn bad_access(slice: &[i32], index: usize) -> i32 {
    *slice.get_unchecked(index)  // 可能越界
}

// ✅ 已检查边界
fn good_access(slice: &[i32], index: usize) -> Option<i32> {
    if index < slice.len() {
        Some(unsafe { *slice.get_unchecked(index) })
    } else {
        None
    }
}

// ❌ 未验证指针有效性
unsafe fn bad_ptr_deref(ptr: *const i32) -> i32 {
    *ptr  // 可能是空指针或悬垂指针
}

// ✅ 已验证指针
fn good_ptr_deref(ptr: *const i32) -> Option<i32> {
    if ptr.is_null() {
        None
    } else {
        Some(unsafe { *ptr })
    }
}
```

#### 审计工具

```bash
# Miri: Rust 的运行时 undefined behavior 检测器
cargo +nightly miri test

# Clippy: 静态分析 (包括 unsafe 相关 lint)
cargo clippy -- -W clippy::undocumented_unsafe_blocks

# AddressSanitizer: 检测内存错误
RUSTFLAGS="-Z sanitizer=address" cargo +nightly build
```

---

## 4. FFI 安全性

### 4.1 C 互操作性

#### 基本 FFI 模式

```rust
use std::os::raw::{c_char, c_int};
use std::ffi::{CStr, CString};

// 声明 C 函数
extern "C" {
    fn strlen(s: *const c_char) -> usize;
    fn strcmp(s1: *const c_char, s2: *const c_char) -> c_int;
}

// ✅ 安全包装
pub fn safe_strlen(s: &str) -> usize {
    let c_string = CString::new(s).expect("CString::new failed");
    unsafe { strlen(c_string.as_ptr()) }
}

pub fn safe_strcmp(s1: &str, s2: &str) -> std::cmp::Ordering {
    let c_s1 = CString::new(s1).expect("CString::new failed");
    let c_s2 = CString::new(s2).expect("CString::new failed");

    let result = unsafe { strcmp(c_s1.as_ptr(), c_s2.as_ptr()) };

    match result {
        x if x < 0 => std::cmp::Ordering::Less,
        0 => std::cmp::Ordering::Equal,
        _ => std::cmp::Ordering::Greater,
    }
}
```

#### 从 C 接收字符串

```rust
use std::ffi::CStr;
use std::os::raw::c_char;

// C 函数返回字符串
extern "C" {
    fn get_c_string() -> *const c_char;
}

// ✅ 安全转换
pub fn get_string() -> Result<String, std::str::Utf8Error> {
    unsafe {
        let ptr = get_c_string();
        if ptr.is_null() {
            return Ok(String::new());
        }

        let c_str = CStr::from_ptr(ptr);
        c_str.to_str().map(|s| s.to_owned())
    }
}
```

#### 传递结构体给 C

```rust
// ✅ 使用 #[repr(C)] 保证内存布局
#[repr(C)]
pub struct Point {
    x: f64,
    y: f64,
}

extern "C" {
    fn process_point(p: *const Point);
}

pub fn safe_process_point(p: &Point) {
    unsafe { process_point(p as *const Point) }
}
```

### 4.2 内存布局保证

#### Repr 属性

```rust
// ✅ #[repr(C)]: C 兼容布局
#[repr(C)]
struct CCompatible {
    a: u32,
    b: u64,
}

// ✅ #[repr(transparent)]: 与内部类型相同布局
#[repr(transparent)]
struct Wrapper(u64);

// ⚠️ 默认 Rust 布局：可能重排字段
struct RustDefault {
    a: u8,
    b: u64,
    c: u8,
}

// ✅ #[repr(packed)]: 无填充（危险）
#[repr(packed)]
struct Packed {
    a: u8,
    b: u64,
}
```

#### 对齐和大小

```rust
use std::mem::{size_of, align_of};

#[repr(C)]
struct Example {
    a: u8,   // 1 byte
    // 7 bytes padding
    b: u64,  // 8 bytes
    c: u8,   // 1 byte
    // 7 bytes padding
}

fn check_layout() {
    assert_eq!(size_of::<Example>(), 24);
    assert_eq!(align_of::<Example>(), 8);
}
```

### 4.3 FFI 最佳实践

#### 最佳实践 1: 错误处理

```rust
use std::panic;

// ✅ 捕获 panic，避免跨 FFI 边界展开
#[no_mangle]
pub extern "C" fn safe_ffi_function(x: i32) -> i32 {
    match panic::catch_unwind(|| {
        // 可能 panic 的代码
        if x < 0 {
            panic!("Negative input");
        }
        x * 2
    }) {
        Ok(result) => result,
        Err(_) => -1,  // 返回错误码
    }
}
```

#### 最佳实践 2: 内存管理

```rust
// ✅ 明确的内存所有权

#[no_mangle]
pub extern "C" fn create_string(text: *const c_char) -> *mut c_char {
    let c_str = unsafe { CStr::from_ptr(text) };
    let rust_str = c_str.to_str().unwrap();
    let owned = CString::new(rust_str).unwrap();
    owned.into_raw()  // 转移所有权给 C
}

#[no_mangle]
pub extern "C" fn free_string(ptr: *mut c_char) {
    if !ptr.is_null() {
        unsafe {
            // 重新获取所有权并自动 drop
            let _ = CString::from_raw(ptr);
        }
    }
}
```

#### 最佳实践 3: 版本管理

```rust
// ✅ 版本化 API

#[no_mangle]
pub extern "C" fn lib_version() -> u32 {
    0x010000  // 1.0.0
}

#[no_mangle]
pub extern "C" fn lib_function_v1(x: i32) -> i32 {
    x * 2
}

#[no_mangle]
pub extern "C" fn lib_function_v2(x: i32, y: i32) -> i32 {
    x * 2 + y
}
```

---

## 5. 并发安全模式

### 5.1 数据竞争预防

#### Send 和 Sync 基础

```rust
// Send: 可跨线程转移所有权
// Sync: 可跨线程共享引用 (&T 是 Send)

// ✅ 大多数类型自动实现 Send + Sync
struct SafeData {
    value: i32,
    text: String,
}
// SafeData: Send + Sync

// ❌ Rc 不是 Send
use std::rc::Rc;
let rc = Rc::new(5);
// thread::spawn(move || { println!("{}", rc); });  // 编译错误

// ✅ Arc 是 Send + Sync
use std::sync::Arc;
let arc = Arc::new(5);
thread::spawn(move || { println!("{}", arc); });  // OK
```

#### 共享状态模式

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// ✅ 模式 1: Arc + Mutex
fn arc_mutex_pattern() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut data = data_clone.lock().unwrap();
            data.push(i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}

// ✅ 模式 2: Arc + RwLock (读多写少)
use std::sync::RwLock;

fn arc_rwlock_pattern() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // 多个读取者
    for _ in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data_clone.read().unwrap();
            println!("Data: {:?}", *data);
        });
        handles.push(handle);
    }

    // 一个写入者
    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut data = data_clone.write().unwrap();
        data.push(4);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 5.2 Send 和 Sync

#### 手动实现 Send/Sync

```rust
use std::marker::PhantomData;

// 原始指针默认不是 Send/Sync
struct RawPointer {
    ptr: *const i32,
}

// ⚠️ 仅当确信安全时才实现
unsafe impl Send for RawPointer {}
unsafe impl Sync for RawPointer {}

// ✅ 使用 PhantomData 控制 Send/Sync
struct NotSendOrSync<T> {
    data: T,
    _marker: PhantomData<*const ()>,  // 阻止 Send/Sync
}
```

#### 常见类型的 Send/Sync 状态

| 类型 | Send | Sync | 说明 |
|------|------|------|------|
| `i32`, `String` | ✅ | ✅ | 基本类型 |
| `Box<T>` | T: Send | T: Sync | 跟随内部类型 |
| `Rc<T>` | ❌ | ❌ | 非线程安全 |
| `Arc<T>` | T: Send + Sync | T: Send + Sync | 线程安全 |
| `Mutex<T>` | T: Send | T: Send | 提供内部可变性 |
| `RefCell<T>` | T: Send | ❌ | 非线程安全 |
| `*const T`, `*mut T` | ❌ | ❌ | 原始指针 |
| `&T`, `&mut T` | T: Sync | T: Sync | 引用 |

### 5.3 并发内存模型

#### 原子操作

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

// ✅ 原子计数器（无锁）
struct AtomicCounter {
    count: AtomicUsize,
}

impl AtomicCounter {
    fn new() -> Self {
        Self { count: AtomicUsize::new(0) }
    }

    fn increment(&self) {
        self.count.fetch_add(1, Ordering::SeqCst);
    }

    fn get(&self) -> usize {
        self.count.load(Ordering::SeqCst)
    }
}
```

#### 内存顺序

```rust
use std::sync::atomic::Ordering;

// Ordering 类型：
// - Relaxed: 最弱，仅保证原子性
// - Acquire: 加载时同步
// - Release: 存储时同步
// - AcqRel: Acquire + Release
// - SeqCst: 最强，顺序一致性

fn memory_ordering_example() {
    let flag = AtomicBool::new(false);
    let data = AtomicUsize::new(0);

    // 线程 1: 写入
    thread::spawn(move || {
        data.store(42, Ordering::Relaxed);
        flag.store(true, Ordering::Release);  // Release
    });

    // 线程 2: 读取
    while !flag.load(Ordering::Acquire) {}  // Acquire
    assert_eq!(data.load(Ordering::Relaxed), 42);  // 保证可见性
}
```

---

## 6. 内存泄漏预防

### 6.1 循环引用检测

#### 检测工具

```rust
// 使用 Rc::strong_count 和 Rc::weak_count

use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    next: Option<Rc<RefCell<Node>>>,
    prev: Option<Weak<RefCell<Node>>>,
}

fn detect_cycle() {
    let node1 = Rc::new(RefCell::new(Node {
        value: 1,
        next: None,
        prev: None,
    }));

    let node2 = Rc::new(RefCell::new(Node {
        value: 2,
        next: Some(Rc::clone(&node1)),
        prev: None,
    }));

    node1.borrow_mut().prev = Some(Rc::downgrade(&node2));

    println!("node1 strong: {}", Rc::strong_count(&node1));  // 2
    println!("node1 weak: {}", Rc::weak_count(&node1));      // 1
    println!("node2 strong: {}", Rc::strong_count(&node2));  // 1
    println!("node2 weak: {}", Rc::weak_count(&node2));      // 0
}
```

### 6.2 资源管理模式

#### RAII 模式

```rust
// ✅ 利用 Drop 自动清理

use std::fs::File;

struct FileGuard {
    file: File,
}

impl FileGuard {
    fn new(path: &str) -> std::io::Result<Self> {
        Ok(Self { file: File::open(path)? })
    }
}

impl Drop for FileGuard {
    fn drop(&mut self) {
        println!("File closed automatically");
    }
}
```

### 6.3 Drop 最佳实践

```rust
// ✅ 自定义 Drop 实现

struct CustomResource {
    id: usize,
}

impl Drop for CustomResource {
    fn drop(&mut self) {
        println!("Cleaning up resource {}", self.id);
        // 清理逻辑
    }
}

// ⚠️ Drop 顺序：先内部字段，后自定义 Drop
```

---

## 7. 安全性审计和工具

### 7.1 静态分析工具

```bash
# Clippy: Rust linter
cargo clippy

# Rustfmt: 代码格式化
cargo fmt

# Cargo-audit: 依赖安全审计
cargo install cargo-audit
cargo audit

# Cargo-geiger: 检测 unsafe 代码
cargo install cargo-geiger
cargo geiger
```

### 7.2 动态检测工具

```bash
# Miri: undefined behavior 检测
cargo +nightly miri test

# AddressSanitizer: 内存错误检测
RUSTFLAGS="-Z sanitizer=address" cargo +nightly build

# ThreadSanitizer: 数据竞争检测
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly build

# MemorySanitizer: 未初始化内存检测
RUSTFLAGS="-Z sanitizer=memory" cargo +nightly build
```

### 7.3 安全性测试

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_safety() {
        // 边界测试
        let mut vec = vec![1, 2, 3];
        assert_eq!(vec.get(10), None);  // 不会 panic

        // 生命周期测试
        let x = 5;
        let r;
        {
            let y = 10;
            // r = &y;  // ❌ 编译错误
            r = &x;  // ✅ OK
        }
        println!("{}", r);
    }

    #[test]
    fn test_thread_safety() {
        use std::sync::{Arc, Mutex};
        use std::thread;

        let data = Arc::new(Mutex::new(0));
        let mut handles = vec![];

        for _ in 0..10 {
            let data = Arc::clone(&data);
            let handle = thread::spawn(move || {
                let mut num = data.lock().unwrap();
                *num += 1;
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.join().unwrap();
        }

        assert_eq!(*data.lock().unwrap(), 10);
    }
}
```

---

## 相关资源

### 📖 核心文档

- **[内存安全分析](../04_safety/01_memory_safety.md)**: 深入的内存安全机制分析
- **[Unsafe Rust](../04_safety/02_unsafe_rust.md)**: Unsafe 代码详细指南
- **[并发编程](../05_practice/05_concurrent_programming.md)**: 并发场景的安全实践

### 🔗 相关主题

- **Tier 3 高级主题**
  - [3.1 高级所有权模式](./3.1_高级所有权模式.md)
  - [3.2 零成本抽象](./3.2_零成本抽象.md)
  - [3.4 性能优化](./3.4_性能优化.md)

- **Tier 4 理论深度**
  - [4.1 类型系统理论](../tier4_theoretical/4.1_类型系统理论.md)
  - [4.2 形式化验证](../tier4_theoretical/4.2_形式化验证.md)

### 🛠️ 工具和资源

**安全工具**:

- `cargo-audit` - 依赖安全审计
- `cargo-geiger` - unsafe 代码检测
- `cargo-clippy` - Lint 工具
- `miri` - undefined behavior 检测
- `sanitizers` - 内存/线程安全检测

**学习资源**:

- [The Rustonomicon](https://doc.rust-lang.org/nomicon/) - Unsafe Rust 权威指南
- [Rust Security Guidelines](https://anssi-fr.github.io/rust-guide/)
- [Secure Rust Guidelines](https://github.com/rust-secure-code/projects)

### 📚 学习路径

**进阶路径**:

1. 完成本文档学习（预估 10-15 小时）
2. 深入学习 The Rustonomicon
3. 实践 unsafe 代码审计
4. 研究形式化验证方法

**实践建议**:

- 🔨 审计开源项目的 unsafe 代码
- 🔨 为自己的项目运行所有安全检测工具
- 🔨 实现一个安全的 FFI 包装
- 🔨 参与安全代码评审

### 🎯 学习检查清单

完成以下任务以验证学习效果:

- [ ] 理解 Rust 内存安全的核心保证
- [ ] 掌握安全 Rust 的最佳实践
- [ ] 能够正确使用 unsafe 代码
- [ ] 实现安全的 FFI 互操作
- [ ] 设计线程安全的并发系统
- [ ] 识别和预防内存泄漏
- [ ] 使用工具进行安全性审计
- [ ] 能够审计和评估 unsafe 代码

---

**最后更新**: 2025-12-11
**文档版本**: 2.0 (扩展版)
**适用 Rust 版本**: 1.92.0+
**预估学习时间**: 10-15 小时
**难度级别**: ⭐⭐⭐⭐⭐ (高级+)

---

END OF DOCUMENT
