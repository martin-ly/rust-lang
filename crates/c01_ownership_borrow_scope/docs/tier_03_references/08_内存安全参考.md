# 3.3 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.92.0+
**æœ€åæ›´æ–°**: 2025-12-11
**æ–‡æ¡£ç±»å‹**: Tier 3 é«˜çº§å®è·µæŒ‡å—

---

## ğŸ“‹ ç›®å½•

- [3.3 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ](#33-å†…å­˜å®‰å…¨æœ€ä½³å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è§ˆ](#æ–‡æ¡£æ¦‚è§ˆ)
    - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
    - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
    - [ğŸ¨ æ–‡æ¡£ç‰¹è‰²](#-æ–‡æ¡£ç‰¹è‰²)
    - [ğŸ“– æ ¸å¿ƒå†…å®¹](#-æ ¸å¿ƒå†…å®¹)
  - [1. å†…å­˜å®‰å…¨æ ¸å¿ƒåŸåˆ™](#1-å†…å­˜å®‰å…¨æ ¸å¿ƒåŸåˆ™)
    - [1.1 Rust å†…å­˜å®‰å…¨ä¿è¯](#11-rust-å†…å­˜å®‰å…¨ä¿è¯)
      - [æ ¸å¿ƒä¿è¯](#æ ¸å¿ƒä¿è¯)
      - [å†…å­˜å®‰å…¨å±‚æ¬¡](#å†…å­˜å®‰å…¨å±‚æ¬¡)
    - [1.2 å†…å­˜å®‰å…¨è¾¹ç•Œ](#12-å†…å­˜å®‰å…¨è¾¹ç•Œ)
      - [Unsafe è¾¹ç•Œ](#unsafe-è¾¹ç•Œ)
      - [å®‰å…¨æŠ½è±¡](#å®‰å…¨æŠ½è±¡)
    - [1.3 å¸¸è§å†…å­˜é”™è¯¯é¢„é˜²](#13-å¸¸è§å†…å­˜é”™è¯¯é¢„é˜²)
      - [1. Use-After-Free](#1-use-after-free)
      - [2. Double-Free](#2-double-free)
      - [3. Memory Leak](#3-memory-leak)
      - [4. Data Race](#4-data-race)
  - [2. å®‰å…¨ Rust æœ€ä½³å®è·µ](#2-å®‰å…¨-rust-æœ€ä½³å®è·µ)
    - [2.1 æ‰€æœ‰æƒæ¨¡å¼](#21-æ‰€æœ‰æƒæ¨¡å¼)
      - [æ¨¡å¼ 1: æ˜ç¡®æ‰€æœ‰æƒ](#æ¨¡å¼-1-æ˜ç¡®æ‰€æœ‰æƒ)
      - [æ¨¡å¼ 2: å€Ÿç”¨ä¼˜å…ˆ](#æ¨¡å¼-2-å€Ÿç”¨ä¼˜å…ˆ)
      - [æ¨¡å¼ 3: Cow æ¨¡å¼](#æ¨¡å¼-3-cow-æ¨¡å¼)
    - [2.2 ç”Ÿå‘½å‘¨æœŸç®¡ç†](#22-ç”Ÿå‘½å‘¨æœŸç®¡ç†)
      - [æœ€ä½³å®è·µ 1: ç”Ÿå‘½å‘¨æœŸçœç•¥](#æœ€ä½³å®è·µ-1-ç”Ÿå‘½å‘¨æœŸçœç•¥)
      - [æœ€ä½³å®è·µ 2: é¿å…å¤æ‚ç”Ÿå‘½å‘¨æœŸ](#æœ€ä½³å®è·µ-2-é¿å…å¤æ‚ç”Ÿå‘½å‘¨æœŸ)
      - [æœ€ä½³å®è·µ 3: ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ](#æœ€ä½³å®è·µ-3-ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ)
    - [2.3 ç±»å‹å®‰å…¨è®¾è®¡](#23-ç±»å‹å®‰å…¨è®¾è®¡)
      - [æ¨¡å¼ 1: æ–°ç±»å‹æ¨¡å¼](#æ¨¡å¼-1-æ–°ç±»å‹æ¨¡å¼)
      - [æ¨¡å¼ 2: ç±»å‹çŠ¶æ€æ¨¡å¼](#æ¨¡å¼-2-ç±»å‹çŠ¶æ€æ¨¡å¼)
      - [æ¨¡å¼ 3: Builder æ¨¡å¼](#æ¨¡å¼-3-builder-æ¨¡å¼)
  - [3. Unsafe Rust ä½¿ç”¨æŒ‡å—](#3-unsafe-rust-ä½¿ç”¨æŒ‡å—)
    - [3.1 ä½•æ—¶ä½¿ç”¨ Unsafe](#31-ä½•æ—¶ä½¿ç”¨-unsafe)
      - [åˆç†ä½¿ç”¨åœºæ™¯](#åˆç†ä½¿ç”¨åœºæ™¯)
      - [é¿å…ä½¿ç”¨åœºæ™¯](#é¿å…ä½¿ç”¨åœºæ™¯)
    - [3.2 Unsafe ä»£ç æ¨¡å¼](#32-unsafe-ä»£ç æ¨¡å¼)
      - [æ¨¡å¼ 1: æœ€å°åŒ– Unsafe è¾¹ç•Œ](#æ¨¡å¼-1-æœ€å°åŒ–-unsafe-è¾¹ç•Œ)
      - [æ¨¡å¼ 2: æ–‡æ¡£åŒ–ä¸å˜é‡](#æ¨¡å¼-2-æ–‡æ¡£åŒ–ä¸å˜é‡)
      - [æ¨¡å¼ 3: Unsafe å‡½æ•° vs Unsafe å—](#æ¨¡å¼-3-unsafe-å‡½æ•°-vs-unsafe-å—)
    - [3.3 Unsafe ä»£ç å®¡è®¡](#33-unsafe-ä»£ç å®¡è®¡)
      - [å®¡è®¡æ¸…å•](#å®¡è®¡æ¸…å•)
      - [å®¡è®¡å·¥å…·](#å®¡è®¡å·¥å…·)
  - [4. FFI å®‰å…¨æ€§](#4-ffi-å®‰å…¨æ€§)
    - [4.1 C äº’æ“ä½œæ€§](#41-c-äº’æ“ä½œæ€§)
      - [åŸºæœ¬ FFI æ¨¡å¼](#åŸºæœ¬-ffi-æ¨¡å¼)
      - [ä» C æ¥æ”¶å­—ç¬¦ä¸²](#ä»-c-æ¥æ”¶å­—ç¬¦ä¸²)
      - [ä¼ é€’ç»“æ„ä½“ç»™ C](#ä¼ é€’ç»“æ„ä½“ç»™-c)
    - [4.2 å†…å­˜å¸ƒå±€ä¿è¯](#42-å†…å­˜å¸ƒå±€ä¿è¯)
      - [Repr å±æ€§](#repr-å±æ€§)
      - [å¯¹é½å’Œå¤§å°](#å¯¹é½å’Œå¤§å°)
    - [4.3 FFI æœ€ä½³å®è·µ](#43-ffi-æœ€ä½³å®è·µ)
      - [æœ€ä½³å®è·µ 1: é”™è¯¯å¤„ç†](#æœ€ä½³å®è·µ-1-é”™è¯¯å¤„ç†)
      - [æœ€ä½³å®è·µ 2: å†…å­˜ç®¡ç†](#æœ€ä½³å®è·µ-2-å†…å­˜ç®¡ç†)
      - [æœ€ä½³å®è·µ 3: ç‰ˆæœ¬ç®¡ç†](#æœ€ä½³å®è·µ-3-ç‰ˆæœ¬ç®¡ç†)
  - [5. å¹¶å‘å®‰å…¨æ¨¡å¼](#5-å¹¶å‘å®‰å…¨æ¨¡å¼)
    - [5.1 æ•°æ®ç«äº‰é¢„é˜²](#51-æ•°æ®ç«äº‰é¢„é˜²)
      - [Send å’Œ Sync åŸºç¡€](#send-å’Œ-sync-åŸºç¡€)
      - [å…±äº«çŠ¶æ€æ¨¡å¼](#å…±äº«çŠ¶æ€æ¨¡å¼)
    - [5.2 Send å’Œ Sync](#52-send-å’Œ-sync)
      - [æ‰‹åŠ¨å®ç° Send/Sync](#æ‰‹åŠ¨å®ç°-sendsync)
      - [å¸¸è§ç±»å‹çš„ Send/Sync çŠ¶æ€](#å¸¸è§ç±»å‹çš„-sendsync-çŠ¶æ€)
    - [5.3 å¹¶å‘å†…å­˜æ¨¡å‹](#53-å¹¶å‘å†…å­˜æ¨¡å‹)
      - [åŸå­æ“ä½œ](#åŸå­æ“ä½œ)
      - [å†…å­˜é¡ºåº](#å†…å­˜é¡ºåº)
  - [6. å†…å­˜æ³„æ¼é¢„é˜²](#6-å†…å­˜æ³„æ¼é¢„é˜²)
    - [6.1 å¾ªç¯å¼•ç”¨æ£€æµ‹](#61-å¾ªç¯å¼•ç”¨æ£€æµ‹)
      - [æ£€æµ‹å·¥å…·](#æ£€æµ‹å·¥å…·)
    - [6.2 èµ„æºç®¡ç†æ¨¡å¼](#62-èµ„æºç®¡ç†æ¨¡å¼)
      - [RAII æ¨¡å¼](#raii-æ¨¡å¼)
    - [6.3 Drop æœ€ä½³å®è·µ](#63-drop-æœ€ä½³å®è·µ)
  - [7. å®‰å…¨æ€§å®¡è®¡å’Œå·¥å…·](#7-å®‰å…¨æ€§å®¡è®¡å’Œå·¥å…·)
    - [7.1 é™æ€åˆ†æå·¥å…·](#71-é™æ€åˆ†æå·¥å…·)
    - [7.2 åŠ¨æ€æ£€æµ‹å·¥å…·](#72-åŠ¨æ€æ£€æµ‹å·¥å…·)
    - [7.3 å®‰å…¨æ€§æµ‹è¯•](#73-å®‰å…¨æ€§æµ‹è¯•)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
    - [ğŸ“– æ ¸å¿ƒæ–‡æ¡£](#-æ ¸å¿ƒæ–‡æ¡£)
    - [ğŸ”— ç›¸å…³ä¸»é¢˜](#-ç›¸å…³ä¸»é¢˜)
    - [ğŸ› ï¸ å·¥å…·å’Œèµ„æº](#ï¸-å·¥å…·å’Œèµ„æº)
    - [ğŸ“š å­¦ä¹ è·¯å¾„](#-å­¦ä¹ è·¯å¾„)
    - [ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•](#-å­¦ä¹ æ£€æŸ¥æ¸…å•)

---

## æ–‡æ¡£æ¦‚è§ˆ

### ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ å°†èƒ½å¤Ÿ:

- âœ… æ·±å…¥ç†è§£ Rust èµ„æºå®‰å…¨çš„æ ¸å¿ƒåŸåˆ™å’Œä¿è¯ï¼ˆç¼–è¯‘æœŸé€»è¾‘è¯æ˜ï¼Œéå†…å­˜æ£€æŸ¥ï¼‰
- âœ… æŒæ¡å®‰å…¨ Rust ä»£ç çš„æœ€ä½³å®è·µï¼ˆèµ„æºæ§åˆ¶æƒçš„é€»è¾‘è¯æ˜ï¼‰
- âœ… æ­£ç¡®å’Œå®‰å…¨åœ°ä½¿ç”¨ Unsafe Rustï¼ˆèµ„æºå®‰å…¨çš„è¾¹ç•Œï¼‰
- âœ… å®ç°å®‰å…¨çš„ FFI äº’æ“ä½œï¼ˆèµ„æºç®¡ç†çš„ç¼–è¯‘æœŸè¯æ˜ï¼‰
- âœ… è®¾è®¡å’Œå®ç°çº¿ç¨‹å®‰å…¨çš„å¹¶å‘ä»£ç ï¼ˆç¼–è¯‘æœŸæ’ä»–æ€§å¥‘çº¦çš„éªŒè¯ï¼‰
- âœ… è¯†åˆ«å’Œé¢„é˜²èµ„æºæ³„æ¼ï¼ˆé€»è¾‘è¯æ˜çš„å¤±è´¥ï¼‰
- âœ… ä½¿ç”¨å·¥å…·è¿›è¡Œå®‰å…¨æ€§å®¡è®¡

### ğŸ“š å‰ç½®çŸ¥è¯†

å­¦ä¹ æœ¬æ–‡æ¡£å‰ï¼Œä½ éœ€è¦:

- âœ… ç²¾é€š Rust çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ
- âœ… ç†Ÿæ‚‰ Rust çš„ç±»å‹ç³»ç»Ÿå’Œ Trait
- âœ… äº†è§£å¹¶å‘ç¼–ç¨‹åŸºç¡€
- âœ… æœ‰ä¸€å®šçš„ç³»ç»Ÿç¼–ç¨‹ç»éªŒ

**æ¨èå…ˆå­¦ä¹ **: [Tier 2 æ ¸å¿ƒæ¦‚å¿µ](../tier_02_guides/README.md), [06 é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ](./06_é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ.md)

### ğŸ¨ æ–‡æ¡£ç‰¹è‰²

æœ¬æ–‡æ¡£æä¾›:

- ğŸ›¡ï¸ **å®‰å…¨ä¿è¯**: è¯¦è§£ Rust çš„å†…å­˜å®‰å…¨æœºåˆ¶
- âš ï¸ **å¸¸è§é™·é˜±**: æ ‡æ³¨æ˜“é”™ç‚¹å’Œå±é™©æ¨¡å¼
- ğŸ’¡ **æœ€ä½³å®è·µ**: ç»è¿‡éªŒè¯çš„å®‰å…¨æ¨¡å¼
- ğŸ” **å®¡è®¡æŒ‡å—**: ä»£ç å®¡æŸ¥å’Œå®‰å…¨æ£€æŸ¥æ–¹æ³•
- ğŸ› ï¸ **å·¥å…·é“¾**: å®‰å…¨åˆ†æå’Œæ£€æµ‹å·¥å…·

### ğŸ“– æ ¸å¿ƒå†…å®¹

**ç›¸å…³å®Œæ•´æ–‡æ¡£**:

- **[å†…å­˜å®‰å…¨åˆ†æ](../04_safety/01_memory_safety.md)**: æ·±å…¥çš„å†…å­˜å®‰å…¨æœºåˆ¶åˆ†æ
- **[å¹¶å‘ç¼–ç¨‹](../05_practice/05_concurrent_programming.md)**: å¹¶å‘åœºæ™¯çš„å®‰å…¨å®è·µ
- **[Unsafe Rust](../04_safety/02_unsafe_rust.md)**: Unsafe ä»£ç è¯¦ç»†æŒ‡å—

---

## 1. å†…å­˜å®‰å…¨æ ¸å¿ƒåŸåˆ™

### 1.1 Rust å†…å­˜å®‰å…¨ä¿è¯

#### æ ¸å¿ƒä¿è¯

Rust åœ¨ç¼–è¯‘æ—¶ä¿è¯ä»¥ä¸‹èµ„æºå®‰å…¨ç‰¹æ€§ï¼ˆå¼•ç”¨ä¸€è‡´æ€§è§†è§’ï¼‰:

1. **æ— ç©ºæŒ‡é’ˆè§£å¼•ç”¨**ï¼ˆç¼–è¯‘æœŸé€»è¾‘è¯æ˜ï¼‰

   ```rust
   // âŒ C/C++: å¯èƒ½å´©æºƒ
   // int* ptr = nullptr;
   // *ptr = 42;  // undefined behavior

   // âœ… Rust: ç¼–è¯‘æ—¶é˜»æ­¢
   let ptr: Option<Box<i32>> = None;
   // let value = *ptr;  // âŒ ç¼–è¯‘é”™è¯¯

   // å¿…é¡»æ˜¾å¼å¤„ç†
   if let Some(boxed) = ptr {
       let value = *boxed;  // âœ… å®‰å…¨
   }
   ```

2. **æ— æ‚¬å‚å¼•ç”¨**ï¼ˆå¼•ç”¨ä¸€è‡´æ€§è§†è§’ï¼‰

   ```rust
   // âŒ ä¸å¯èƒ½åˆ›å»ºæ‚¬å‚å¼•ç”¨ï¼ˆé€»è¾‘è¯æ˜çš„å¤±è´¥ï¼Œéå†…å­˜åœ°å€å¤±æ•ˆï¼‰
   fn dangling_pointer() -> &String {
       let s = String::from("hello");
       &s  // âŒ ç¼–è¯‘é”™è¯¯ï¼šé€»è¾‘å…³ç³»é”™è¯¯ï¼Œå¼•ç”¨ä¼šå¤±æ•ˆï¼ˆç¼–è¯‘æœŸé€»è¾‘è¯æ˜ï¼‰
   }

   // âœ… æ­£ç¡®åšæ³•ï¼šè½¬ç§»æ‰€æœ‰æƒ
   fn valid_return() -> String {
       let s = String::from("hello");
       s  // âœ… æ‰€æœ‰æƒè½¬ç§»
   }
   ```

3. **æ— æ•°æ®ç«äº‰**

   ```rust
   use std::sync::Mutex;
   use std::thread;

   // âœ… Rust ä¿è¯çº¿ç¨‹å®‰å…¨
   let data = Mutex::new(0);

   let handles: Vec<_> = (0..10)
       .map(|_| {
           let data = data.clone();  // âŒ ç¼–è¯‘é”™è¯¯ï¼šMutex ä¸èƒ½ clone
           thread::spawn(move || {
               let mut num = data.lock().unwrap();
               *num += 1;
           })
       })
       .collect();

   // âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ Arc
   use std::sync::Arc;
   let data = Arc::new(Mutex::new(0));
   ```

4. **æ— ç¼“å†²åŒºæº¢å‡º**

   ```rust
   // âœ… Rust è‡ªåŠ¨è¾¹ç•Œæ£€æŸ¥
   let arr = [1, 2, 3, 4, 5];
   // let x = arr[10];  // âŒ è¿è¡Œæ—¶ panicï¼ˆè€Œé undefined behaviorï¼‰

   // âœ… å®‰å…¨è®¿é—®
   if let Some(&x) = arr.get(10) {
       println!("{}", x);
   } else {
       println!("Index out of bounds");
   }
   ```

5. **æ— è¿­ä»£å™¨å¤±æ•ˆ**

   ```rust
   let mut vec = vec![1, 2, 3];

   // âŒ C++: undefined behavior
   // for (auto& item : vec) {
   //     vec.push_back(item * 2);  // è¿­ä»£å™¨å¤±æ•ˆ
   // }

   // âœ… Rust: ç¼–è¯‘æ—¶é˜»æ­¢
   for item in &vec {
       // vec.push(*item * 2);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šå·²æœ‰ä¸å¯å˜å€Ÿç”¨
   }
   ```

#### å†…å­˜å®‰å…¨å±‚æ¬¡

```text
å®Œå…¨å®‰å…¨
    â†‘
    â”œâ”€ Safe Rust (é»˜è®¤)
    â”‚   - ç¼–è¯‘å™¨ä¿è¯å†…å­˜å®‰å…¨
    â”‚   - æ—  undefined behavior
    â”‚   - å¯èƒ½æœ‰ panic (å—æ§)
    â”‚
    â”œâ”€ Unsafe Rust
    â”‚   - ç»•è¿‡éƒ¨åˆ†æ£€æŸ¥
    â”‚   - ç¨‹åºå‘˜è´Ÿè´£å®‰å…¨æ€§
    â”‚   - å¿…é¡»ç»´æŠ¤ä¸å˜é‡
    â”‚
    â”œâ”€ FFI (Foreign Function Interface)
    â”‚   - ä¸ C/C++ äº’æ“ä½œ
    â”‚   - æ— å®‰å…¨ä¿è¯
    â”‚   - éœ€è¦ unsafe è¾¹ç•Œ
    â”‚
    â””â”€ Assembly / å†…è”æ±‡ç¼–
        - å®Œå…¨æ— ä¿æŠ¤
        - éœ€è¦æåº¦å°å¿ƒ
```

### 1.2 å†…å­˜å®‰å…¨è¾¹ç•Œ

#### Unsafe è¾¹ç•Œ

Unsafe ä»£ç å¿…é¡»ç»´æŠ¤çš„ä¸å˜é‡:

```rust
// Unsafe è¾¹ç•Œï¼šç¡®ä¿ä¼ å…¥çš„æŒ‡é’ˆæœ‰æ•ˆ
unsafe fn read_ptr<T>(ptr: *const T) -> T {
    // è°ƒç”¨è€…å¿…é¡»ä¿è¯ï¼š
    // 1. ptr éç©º
    // 2. ptr æŒ‡å‘æœ‰æ•ˆçš„ T
    // 3. ptr å¯¹é½æ­£ç¡®
    // 4. T çš„å†…å­˜å·²åˆå§‹åŒ–
    std::ptr::read(ptr)
}

// âœ… å®‰å…¨åŒ…è£…
fn safe_read<T: Copy>(slice: &[T], index: usize) -> Option<T> {
    slice.get(index).copied()
}
```

#### å®‰å…¨æŠ½è±¡

```rust
// âœ… å†…éƒ¨ä½¿ç”¨ unsafeï¼Œä½†å¯¹å¤–ä¿è¯å®‰å…¨
pub struct SafeBuffer {
    data: Vec<u8>,
    len: usize,
}

impl SafeBuffer {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            len: 0,
        }
    }

    // âœ… å…¬å…± API å®Œå…¨å®‰å…¨
    pub fn push(&mut self, byte: u8) {
        if self.len < self.data.capacity() {
            unsafe {
                // å®‰å…¨ï¼šå·²æ£€æŸ¥å®¹é‡
                let ptr = self.data.as_mut_ptr().add(self.len);
                std::ptr::write(ptr, byte);
            }
            self.len += 1;
            unsafe {
                // å®‰å…¨ï¼šlen ä¸å®é™…æ•°æ®åŒæ­¥
                self.data.set_len(self.len);
            }
        }
    }

    pub fn get(&self, index: usize) -> Option<u8> {
        if index < self.len {
            Some(self.data[index])
        } else {
            None
        }
    }
}
```

### 1.3 å¸¸è§å†…å­˜é”™è¯¯é¢„é˜²

#### 1. Use-After-Free

```rust
// âŒ C/C++: use-after-free
// int* ptr = new int(42);
// delete ptr;
// *ptr = 100;  // undefined behavior

// âœ… Rust: ä¸å¯èƒ½
let ptr = Box::new(42);
drop(ptr);
// *ptr = 100;  // âŒ ç¼–è¯‘é”™è¯¯ï¼šptr å·² moved
```

#### 2. Double-Free

```rust
// âŒ C/C++: double-free
// int* ptr = new int(42);
// delete ptr;
// delete ptr;  // undefined behavior

// âœ… Rust: ä¸å¯èƒ½
let ptr = Box::new(42);
drop(ptr);
// drop(ptr);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šptr å·² moved
```

#### 3. Memory Leak

```rust
use std::rc::Rc;
use std::cell::RefCell;

// âš ï¸ å¯èƒ½å‘ç”Ÿï¼šå¾ªç¯å¼•ç”¨
struct Node {
    next: Option<Rc<RefCell<Node>>>,
}

fn leak_example() {
    let a = Rc::new(RefCell::new(Node { next: None }));
    let b = Rc::new(RefCell::new(Node { next: Some(Rc::clone(&a)) }));
    a.borrow_mut().next = Some(Rc::clone(&b));
    // a å’Œ b å½¢æˆå¾ªç¯å¼•ç”¨ï¼Œå†…å­˜æ³„æ¼
}

// âœ… è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ Weak
use std::rc::Weak;

struct SafeNode {
    next: Option<Weak<RefCell<SafeNode>>>,
}
```

#### 4. Data Race

```rust
use std::sync::Arc;
use std::thread;

// âŒ ç¼–è¯‘é”™è¯¯ï¼šæ•°æ®ç«äº‰
fn data_race_attempt() {
    let mut data = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        data.push(4);
    });

    // data.push(5);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šdata å·² moved

    handle.join().unwrap();
}

// âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ Mutex
use std::sync::Mutex;

fn no_data_race() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        data_clone.lock().unwrap().push(4);
    });

    data.lock().unwrap().push(5);

    handle.join().unwrap();
}
```

---

## 2. å®‰å…¨ Rust æœ€ä½³å®è·µ

### 2.1 æ‰€æœ‰æƒæ¨¡å¼

#### æ¨¡å¼ 1: æ˜ç¡®æ‰€æœ‰æƒ

```rust
// âœ… æ˜ç¡®çš„æ‰€æœ‰æƒè¯­ä¹‰
struct Configuration {
    settings: HashMap<String, String>,
}

impl Configuration {
    // è·å–æ‰€æœ‰æƒ
    fn new(settings: HashMap<String, String>) -> Self {
        Self { settings }
    }

    // å€Ÿç”¨
    fn get(&self, key: &str) -> Option<&String> {
        self.settings.get(key)
    }

    // å¯å˜å€Ÿç”¨
    fn set(&mut self, key: String, value: String) {
        self.settings.insert(key, value);
    }

    // è½¬ç§»æ‰€æœ‰æƒ
    fn into_inner(self) -> HashMap<String, String> {
        self.settings
    }
}
```

#### æ¨¡å¼ 2: å€Ÿç”¨ä¼˜å…ˆ

```rust
// âœ… ä¼˜å…ˆä½¿ç”¨å€Ÿç”¨ï¼Œå‡å°‘ä¸å¿…è¦çš„æ‹·è´
fn process_string(s: &str) {  // &str è€Œé String
    println!("Processing: {}", s);
}

fn process_slice(data: &[i32]) {  // &[i32] è€Œé Vec<i32>
    println!("Length: {}", data.len());
}

// âœ… çµæ´»æ¥å—å¤šç§ç±»å‹
fn flexible_api(s: impl AsRef<str>) {
    let s_ref: &str = s.as_ref();
    println!("{}", s_ref);
}

fn main() {
    flexible_api("string literal");
    flexible_api(String::from("owned string"));
}
```

#### æ¨¡å¼ 3: Cow æ¨¡å¼

```rust
use std::borrow::Cow;

// âœ… æ ¹æ®éœ€è¦é€‰æ‹©å€Ÿç”¨æˆ–æ‹¥æœ‰
fn process_text(text: Cow<str>) -> Cow<str> {
    if text.contains("bad_word") {
        // éœ€è¦ä¿®æ”¹ï¼šè½¬æ¢ä¸º Owned
        Cow::Owned(text.replace("bad_word", "***"))
    } else {
        // æ— éœ€ä¿®æ”¹ï¼šä¿æŒ Borrowed
        text
    }
}

fn main() {
    let text1 = "Hello world";
    let result1 = process_text(Cow::Borrowed(text1));  // æ— æ‹·è´

    let text2 = "Hello bad_word";
    let result2 = process_text(Cow::Borrowed(text2));  // ä»…åœ¨éœ€è¦æ—¶æ‹·è´
}
```

### 2.2 ç”Ÿå‘½å‘¨æœŸç®¡ç†

#### æœ€ä½³å®è·µ 1: ç”Ÿå‘½å‘¨æœŸçœç•¥

```rust
// âœ… åˆ©ç”¨ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
impl MyStruct {
    // çœç•¥è§„åˆ™ï¼šè¿”å›å€¼ç”Ÿå‘½å‘¨æœŸä¸ &self ç›¸åŒ
    fn get_name(&self) -> &str {
        &self.name
    }

    // æ˜¾å¼æ ‡æ³¨ï¼ˆå½“çœç•¥è§„åˆ™ä¸é€‚ç”¨æ—¶ï¼‰
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() { x } else { y }
    }
}
```

#### æœ€ä½³å®è·µ 2: é¿å…å¤æ‚ç”Ÿå‘½å‘¨æœŸ

```rust
// âŒ å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸ
struct ComplexStruct<'a, 'b, 'c> {
    field1: &'a str,
    field2: &'b str,
    field3: &'c str,
}

// âœ… ç®€åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€ç”Ÿå‘½å‘¨æœŸæˆ–æ‹¥æœ‰å‹
struct SimplerStruct<'a> {
    field1: &'a str,
    field2: &'a str,
    field3: String,  // æ‹¥æœ‰å‹ï¼Œæ— ç”Ÿå‘½å‘¨æœŸ
}

// âœ… æˆ–å®Œå…¨æ‹¥æœ‰å‹
struct OwnedStruct {
    field1: String,
    field2: String,
    field3: String,
}
```

#### æœ€ä½³å®è·µ 3: ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ

```rust
// âœ… æ˜ç¡®ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ
struct Cache<'a, T: 'a> {
    data: HashMap<String, &'a T>,
}

impl<'a, T: 'a> Cache<'a, T> {
    fn new() -> Self {
        Self { data: HashMap::new() }
    }

    fn insert(&mut self, key: String, value: &'a T) {
        self.data.insert(key, value);
    }

    fn get(&self, key: &str) -> Option<&&'a T> {
        self.data.get(key)
    }
}
```

### 2.3 ç±»å‹å®‰å…¨è®¾è®¡

#### æ¨¡å¼ 1: æ–°ç±»å‹æ¨¡å¼

```rust
// âœ… ä½¿ç”¨æ–°ç±»å‹æä¾›ç±»å‹å®‰å…¨
struct UserId(u64);
struct ProductId(u64);
struct OrderId(u64);

// ç¼–è¯‘æ—¶é˜»æ­¢æ··ç”¨
fn get_user(id: UserId) -> User { /* ... */ }
fn get_product(id: ProductId) -> Product { /* ... */ }

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);

    get_user(user_id);  // âœ… OK
    // get_user(product_id);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
}
```

#### æ¨¡å¼ 2: ç±»å‹çŠ¶æ€æ¨¡å¼

```rust
// âœ… ä½¿ç”¨ç±»å‹ç³»ç»Ÿå¼ºåˆ¶çŠ¶æ€è½¬æ¢

// çŠ¶æ€æ ‡è®°
struct Open;
struct Closed;

struct File<State> {
    path: PathBuf,
    _state: PhantomData<State>,
}

impl File<Closed> {
    fn new(path: PathBuf) -> Self {
        Self {
            path,
            _state: PhantomData,
        }
    }

    fn open(self) -> Result<File<Open>, std::io::Error> {
        // æ‰“å¼€æ–‡ä»¶...
        Ok(File {
            path: self.path,
            _state: PhantomData,
        })
    }
}

impl File<Open> {
    fn read(&self) -> Result<String, std::io::Error> {
        std::fs::read_to_string(&self.path)
    }

    fn close(self) -> File<Closed> {
        File {
            path: self.path,
            _state: PhantomData,
        }
    }
}

fn main() {
    let file = File::<Closed>::new(PathBuf::from("file.txt"));
    // file.read();  // âŒ ç¼–è¯‘é”™è¯¯ï¼šæ–‡ä»¶æœªæ‰“å¼€

    let file = file.open().unwrap();
    file.read().unwrap();  // âœ… OK
}
```

#### æ¨¡å¼ 3: Builder æ¨¡å¼

```rust
// âœ… ä½¿ç”¨ Builder ç¡®ä¿å¿…è¦å­—æ®µè®¾ç½®
struct Config {
    host: String,
    port: u16,
    timeout: Duration,
}

struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<Duration>,
}

impl ConfigBuilder {
    fn new() -> Self {
        Self {
            host: None,
            port: None,
            timeout: None,
        }
    }

    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }

    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    fn timeout(mut self, timeout: Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }

    fn build(self) -> Result<Config, &'static str> {
        Ok(Config {
            host: self.host.ok_or("host is required")?,
            port: self.port.ok_or("port is required")?,
            timeout: self.timeout.unwrap_or(Duration::from_secs(30)),
        })
    }
}
```

---

## 3. Unsafe Rust ä½¿ç”¨æŒ‡å—

### 3.1 ä½•æ—¶ä½¿ç”¨ Unsafe

#### åˆç†ä½¿ç”¨åœºæ™¯

âœ… **1. æ€§èƒ½å…³é”®è·¯å¾„**

```rust
// ç¤ºä¾‹ï¼šè·³è¿‡è¾¹ç•Œæ£€æŸ¥ï¼ˆå½“å·²éªŒè¯å®‰å…¨æ—¶ï¼‰
fn sum_optimized(data: &[i32]) -> i32 {
    let mut sum = 0;
    for i in 0..data.len() {
        // å®‰å…¨ï¼šå¾ªç¯ä¿è¯ i < data.len()
        unsafe {
            sum += *data.get_unchecked(i);
        }
    }
    sum
}
```

âœ… **2. FFI äº’æ“ä½œ**

```rust
extern "C" {
    fn c_function(x: i32) -> i32;
}

pub fn safe_wrapper(x: i32) -> i32 {
    unsafe { c_function(x) }
}
```

âœ… **3. åº•å±‚æ•°æ®ç»“æ„**

```rust
// ç¤ºä¾‹ï¼šå®ç°é«˜æ•ˆçš„ç¯å½¢ç¼“å†²åŒº
pub struct RingBuffer<T> {
    buffer: Vec<T>,
    head: usize,
    tail: usize,
}

impl<T> RingBuffer<T> {
    pub fn push(&mut self, item: T) {
        unsafe {
            // å®‰å…¨ï¼šcapacity å·²é¢„åˆ†é…
            let ptr = self.buffer.as_mut_ptr().add(self.tail);
            std::ptr::write(ptr, item);
        }
        self.tail = (self.tail + 1) % self.buffer.capacity();
    }
}
```

#### é¿å…ä½¿ç”¨åœºæ™¯

âŒ **1. ç»•è¿‡å€Ÿç”¨æ£€æŸ¥å™¨**

```rust
// âŒ ä¸è¦ä¸ºäº†"æ–¹ä¾¿"ä½¿ç”¨ unsafe
let mut x = 5;
let ptr = &mut x as *mut i32;
unsafe {
    *ptr = 10;
}
// åº”è¯¥é‡æ–°è®¾è®¡ä»£ç ï¼Œé¿å…éœ€è¦ unsafe
```

âŒ **2. è¿‡æ—©ä¼˜åŒ–**

```rust
// âŒ æ²¡æœ‰è¯æ˜æ€§èƒ½ç“¶é¢ˆå°±ä½¿ç”¨ unsafe
fn premature_optimization(data: &[i32]) -> i32 {
    unsafe {
        // å¤æ‚ä¸”å±é™©çš„ unsafe ä»£ç 
    }
}

// âœ… å…ˆä½¿ç”¨å®‰å…¨ä»£ç ï¼Œå†æ ¹æ®æ€§èƒ½æµ‹è¯•ä¼˜åŒ–
fn safe_version(data: &[i32]) -> i32 {
    data.iter().sum()
}
```

### 3.2 Unsafe ä»£ç æ¨¡å¼

#### æ¨¡å¼ 1: æœ€å°åŒ– Unsafe è¾¹ç•Œ

```rust
// âœ… å°† unsafe é™åˆ¶åœ¨å°èŒƒå›´å†…
fn process_buffer(data: &[u8]) -> Vec<u8> {
    let mut result = Vec::with_capacity(data.len());

    unsafe {
        // åªåœ¨å¿…è¦æ—¶ä½¿ç”¨ unsafe
        let src = data.as_ptr();
        let dst = result.as_mut_ptr();
        std::ptr::copy_nonoverlapping(src, dst, data.len());
        result.set_len(data.len());
    }

    result
}
```

#### æ¨¡å¼ 2: æ–‡æ¡£åŒ–ä¸å˜é‡

```rust
/// åŸå§‹æŒ‡é’ˆåŒ…è£…å™¨
///
/// # Safety
///
/// ä½¿ç”¨è€…å¿…é¡»ä¿è¯ï¼š
/// 1. æŒ‡é’ˆåœ¨æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆ
/// 2. æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜å·²æ­£ç¡®åˆå§‹åŒ–
/// 3. ä¸å­˜åœ¨å…¶ä»–å¯å˜å¼•ç”¨
pub struct RawWrapper<T> {
    ptr: *const T,
}

impl<T> RawWrapper<T> {
    /// ä»å¼•ç”¨åˆ›å»º
    ///
    /// # Safety
    ///
    /// å®‰å…¨ï¼šä»æœ‰æ•ˆå¼•ç”¨åˆ›å»º
    pub fn new(reference: &T) -> Self {
        Self { ptr: reference as *const T }
    }

    /// è§£å¼•ç”¨æŒ‡é’ˆ
    ///
    /// # Safety
    ///
    /// è°ƒç”¨è€…å¿…é¡»ä¿è¯æŒ‡é’ˆä»ç„¶æœ‰æ•ˆ
    pub unsafe fn get(&self) -> &T {
        &*self.ptr
    }
}
```

#### æ¨¡å¼ 3: Unsafe å‡½æ•° vs Unsafe å—

```rust
// âœ… Unsafe å‡½æ•°ï¼šè°ƒç”¨è€…è´Ÿè´£å®‰å…¨æ€§
pub unsafe fn read_unaligned<T>(ptr: *const T) -> T {
    std::ptr::read_unaligned(ptr)
}

// âœ… å®‰å…¨å‡½æ•°ï¼ˆå†…éƒ¨unsafeï¼‰ï¼šå®ç°è€…è´Ÿè´£å®‰å…¨æ€§
pub fn safe_read<T: Copy>(slice: &[T], index: usize) -> Option<T> {
    if index < slice.len() {
        Some(unsafe {
            // å®‰å…¨ï¼šå·²æ£€æŸ¥ç´¢å¼•
            *slice.get_unchecked(index)
        })
    } else {
        None
    }
}
```

### 3.3 Unsafe ä»£ç å®¡è®¡

#### å®¡è®¡æ¸…å•

**åŸºæœ¬æ£€æŸ¥**:

- [ ] æ‰€æœ‰ unsafe å—éƒ½æœ‰æ³¨é‡Šè¯´æ˜ä¸ºä½•å®‰å…¨
- [ ] è¾¹ç•Œæ£€æŸ¥å·²åœ¨ unsafe å‰å®Œæˆ
- [ ] æŒ‡é’ˆè§£å¼•ç”¨å‰å·²éªŒè¯éç©ºå’Œæœ‰æ•ˆæ€§
- [ ] å†…å­˜å¯¹é½éœ€æ±‚å·²æ»¡è¶³
- [ ] ç”Ÿå‘½å‘¨æœŸçº¦æŸå·²æ­£ç¡®å¤„ç†
- [ ] å¹¶å‘è®¿é—®å·²æ­£ç¡®åŒæ­¥

**å¸¸è§é—®é¢˜**:

```rust
// âŒ æœªæ£€æŸ¥è¾¹ç•Œ
unsafe fn bad_access(slice: &[i32], index: usize) -> i32 {
    *slice.get_unchecked(index)  // å¯èƒ½è¶Šç•Œ
}

// âœ… å·²æ£€æŸ¥è¾¹ç•Œ
fn good_access(slice: &[i32], index: usize) -> Option<i32> {
    if index < slice.len() {
        Some(unsafe { *slice.get_unchecked(index) })
    } else {
        None
    }
}

// âŒ æœªéªŒè¯æŒ‡é’ˆæœ‰æ•ˆæ€§
unsafe fn bad_ptr_deref(ptr: *const i32) -> i32 {
    *ptr  // å¯èƒ½æ˜¯ç©ºæŒ‡é’ˆæˆ–æ‚¬å‚æŒ‡é’ˆ
}

// âœ… å·²éªŒè¯æŒ‡é’ˆ
fn good_ptr_deref(ptr: *const i32) -> Option<i32> {
    if ptr.is_null() {
        None
    } else {
        Some(unsafe { *ptr })
    }
}
```

#### å®¡è®¡å·¥å…·

```bash
# Miri: Rust çš„è¿è¡Œæ—¶ undefined behavior æ£€æµ‹å™¨
cargo +nightly miri test

# Clippy: é™æ€åˆ†æ (åŒ…æ‹¬ unsafe ç›¸å…³ lint)
cargo clippy -- -W clippy::undocumented_unsafe_blocks

# AddressSanitizer: æ£€æµ‹å†…å­˜é”™è¯¯
RUSTFLAGS="-Z sanitizer=address" cargo +nightly build
```

---

## 4. FFI å®‰å…¨æ€§

### 4.1 C äº’æ“ä½œæ€§

#### åŸºæœ¬ FFI æ¨¡å¼

```rust
use std::os::raw::{c_char, c_int};
use std::ffi::{CStr, CString};

// å£°æ˜ C å‡½æ•°
extern "C" {
    fn strlen(s: *const c_char) -> usize;
    fn strcmp(s1: *const c_char, s2: *const c_char) -> c_int;
}

// âœ… å®‰å…¨åŒ…è£…
pub fn safe_strlen(s: &str) -> usize {
    let c_string = CString::new(s).expect("CString::new failed");
    unsafe { strlen(c_string.as_ptr()) }
}

pub fn safe_strcmp(s1: &str, s2: &str) -> std::cmp::Ordering {
    let c_s1 = CString::new(s1).expect("CString::new failed");
    let c_s2 = CString::new(s2).expect("CString::new failed");

    let result = unsafe { strcmp(c_s1.as_ptr(), c_s2.as_ptr()) };

    match result {
        x if x < 0 => std::cmp::Ordering::Less,
        0 => std::cmp::Ordering::Equal,
        _ => std::cmp::Ordering::Greater,
    }
}
```

#### ä» C æ¥æ”¶å­—ç¬¦ä¸²

```rust
use std::ffi::CStr;
use std::os::raw::c_char;

// C å‡½æ•°è¿”å›å­—ç¬¦ä¸²
extern "C" {
    fn get_c_string() -> *const c_char;
}

// âœ… å®‰å…¨è½¬æ¢
pub fn get_string() -> Result<String, std::str::Utf8Error> {
    unsafe {
        let ptr = get_c_string();
        if ptr.is_null() {
            return Ok(String::new());
        }

        let c_str = CStr::from_ptr(ptr);
        c_str.to_str().map(|s| s.to_owned())
    }
}
```

#### ä¼ é€’ç»“æ„ä½“ç»™ C

```rust
// âœ… ä½¿ç”¨ #[repr(C)] ä¿è¯å†…å­˜å¸ƒå±€
#[repr(C)]
pub struct Point {
    x: f64,
    y: f64,
}

extern "C" {
    fn process_point(p: *const Point);
}

pub fn safe_process_point(p: &Point) {
    unsafe { process_point(p as *const Point) }
}
```

### 4.2 å†…å­˜å¸ƒå±€ä¿è¯

#### Repr å±æ€§

```rust
// âœ… #[repr(C)]: C å…¼å®¹å¸ƒå±€
#[repr(C)]
struct CCompatible {
    a: u32,
    b: u64,
}

// âœ… #[repr(transparent)]: ä¸å†…éƒ¨ç±»å‹ç›¸åŒå¸ƒå±€
#[repr(transparent)]
struct Wrapper(u64);

// âš ï¸ é»˜è®¤ Rust å¸ƒå±€ï¼šå¯èƒ½é‡æ’å­—æ®µ
struct RustDefault {
    a: u8,
    b: u64,
    c: u8,
}

// âœ… #[repr(packed)]: æ— å¡«å……ï¼ˆå±é™©ï¼‰
#[repr(packed)]
struct Packed {
    a: u8,
    b: u64,
}
```

#### å¯¹é½å’Œå¤§å°

```rust
use std::mem::{size_of, align_of};

#[repr(C)]
struct Example {
    a: u8,   // 1 byte
    // 7 bytes padding
    b: u64,  // 8 bytes
    c: u8,   // 1 byte
    // 7 bytes padding
}

fn check_layout() {
    assert_eq!(size_of::<Example>(), 24);
    assert_eq!(align_of::<Example>(), 8);
}
```

### 4.3 FFI æœ€ä½³å®è·µ

#### æœ€ä½³å®è·µ 1: é”™è¯¯å¤„ç†

```rust
use std::panic;

// âœ… æ•è· panicï¼Œé¿å…è·¨ FFI è¾¹ç•Œå±•å¼€
#[no_mangle]
pub extern "C" fn safe_ffi_function(x: i32) -> i32 {
    match panic::catch_unwind(|| {
        // å¯èƒ½ panic çš„ä»£ç 
        if x < 0 {
            panic!("Negative input");
        }
        x * 2
    }) {
        Ok(result) => result,
        Err(_) => -1,  // è¿”å›é”™è¯¯ç 
    }
}
```

#### æœ€ä½³å®è·µ 2: å†…å­˜ç®¡ç†

```rust
// âœ… æ˜ç¡®çš„å†…å­˜æ‰€æœ‰æƒ

#[no_mangle]
pub extern "C" fn create_string(text: *const c_char) -> *mut c_char {
    let c_str = unsafe { CStr::from_ptr(text) };
    let rust_str = c_str.to_str().unwrap();
    let owned = CString::new(rust_str).unwrap();
    owned.into_raw()  // è½¬ç§»æ‰€æœ‰æƒç»™ C
}

#[no_mangle]
pub extern "C" fn free_string(ptr: *mut c_char) {
    if !ptr.is_null() {
        unsafe {
            // é‡æ–°è·å–æ‰€æœ‰æƒå¹¶è‡ªåŠ¨ drop
            let _ = CString::from_raw(ptr);
        }
    }
}
```

#### æœ€ä½³å®è·µ 3: ç‰ˆæœ¬ç®¡ç†

```rust
// âœ… ç‰ˆæœ¬åŒ– API

#[no_mangle]
pub extern "C" fn lib_version() -> u32 {
    0x010000  // 1.0.0
}

#[no_mangle]
pub extern "C" fn lib_function_v1(x: i32) -> i32 {
    x * 2
}

#[no_mangle]
pub extern "C" fn lib_function_v2(x: i32, y: i32) -> i32 {
    x * 2 + y
}
```

---

## 5. å¹¶å‘å®‰å…¨æ¨¡å¼

### 5.1 æ•°æ®ç«äº‰é¢„é˜²

#### Send å’Œ Sync åŸºç¡€

```rust
// Send: å¯è·¨çº¿ç¨‹è½¬ç§»æ‰€æœ‰æƒ
// Sync: å¯è·¨çº¿ç¨‹å…±äº«å¼•ç”¨ (&T æ˜¯ Send)

// âœ… å¤§å¤šæ•°ç±»å‹è‡ªåŠ¨å®ç° Send + Sync
struct SafeData {
    value: i32,
    text: String,
}
// SafeData: Send + Sync

// âŒ Rc ä¸æ˜¯ Send
use std::rc::Rc;
let rc = Rc::new(5);
// thread::spawn(move || { println!("{}", rc); });  // ç¼–è¯‘é”™è¯¯

// âœ… Arc æ˜¯ Send + Sync
use std::sync::Arc;
let arc = Arc::new(5);
thread::spawn(move || { println!("{}", arc); });  // OK
```

#### å…±äº«çŠ¶æ€æ¨¡å¼

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// âœ… æ¨¡å¼ 1: Arc + Mutex
fn arc_mutex_pattern() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut data = data_clone.lock().unwrap();
            data.push(i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}

// âœ… æ¨¡å¼ 2: Arc + RwLock (è¯»å¤šå†™å°‘)
use std::sync::RwLock;

fn arc_rwlock_pattern() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // å¤šä¸ªè¯»å–è€…
    for _ in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data_clone.read().unwrap();
            println!("Data: {:?}", *data);
        });
        handles.push(handle);
    }

    // ä¸€ä¸ªå†™å…¥è€…
    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut data = data_clone.write().unwrap();
        data.push(4);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 5.2 Send å’Œ Sync

#### æ‰‹åŠ¨å®ç° Send/Sync

```rust
use std::marker::PhantomData;

// åŸå§‹æŒ‡é’ˆé»˜è®¤ä¸æ˜¯ Send/Sync
struct RawPointer {
    ptr: *const i32,
}

// âš ï¸ ä»…å½“ç¡®ä¿¡å®‰å…¨æ—¶æ‰å®ç°
unsafe impl Send for RawPointer {}
unsafe impl Sync for RawPointer {}

// âœ… ä½¿ç”¨ PhantomData æ§åˆ¶ Send/Sync
struct NotSendOrSync<T> {
    data: T,
    _marker: PhantomData<*const ()>,  // é˜»æ­¢ Send/Sync
}
```

#### å¸¸è§ç±»å‹çš„ Send/Sync çŠ¶æ€

| ç±»å‹                 | Send           | Sync           | è¯´æ˜           |
| -------------------- | -------------- | -------------- | -------------- |
| `i32`, `String`      | âœ…             | âœ…             | åŸºæœ¬ç±»å‹       |
| `Box<T>`             | T: Send        | T: Sync        | è·Ÿéšå†…éƒ¨ç±»å‹   |
| `Rc<T>`              | âŒ             | âŒ             | éçº¿ç¨‹å®‰å…¨     |
| `Arc<T>`             | T: Send + Sync | T: Send + Sync | çº¿ç¨‹å®‰å…¨       |
| `Mutex<T>`           | T: Send        | T: Send        | æä¾›å†…éƒ¨å¯å˜æ€§ |
| `RefCell<T>`         | T: Send        | âŒ             | éçº¿ç¨‹å®‰å…¨     |
| `*const T`, `*mut T` | âŒ             | âŒ             | åŸå§‹æŒ‡é’ˆ       |
| `&T`, `&mut T`       | T: Sync        | T: Sync        | å¼•ç”¨           |

### 5.3 å¹¶å‘å†…å­˜æ¨¡å‹

#### åŸå­æ“ä½œ

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

// âœ… åŸå­è®¡æ•°å™¨ï¼ˆæ— é”ï¼‰
struct AtomicCounter {
    count: AtomicUsize,
}

impl AtomicCounter {
    fn new() -> Self {
        Self { count: AtomicUsize::new(0) }
    }

    fn increment(&self) {
        self.count.fetch_add(1, Ordering::SeqCst);
    }

    fn get(&self) -> usize {
        self.count.load(Ordering::SeqCst)
    }
}
```

#### å†…å­˜é¡ºåº

```rust
use std::sync::atomic::Ordering;

// Ordering ç±»å‹ï¼š
// - Relaxed: æœ€å¼±ï¼Œä»…ä¿è¯åŸå­æ€§
// - Acquire: åŠ è½½æ—¶åŒæ­¥
// - Release: å­˜å‚¨æ—¶åŒæ­¥
// - AcqRel: Acquire + Release
// - SeqCst: æœ€å¼ºï¼Œé¡ºåºä¸€è‡´æ€§

fn memory_ordering_example() {
    let flag = AtomicBool::new(false);
    let data = AtomicUsize::new(0);

    // çº¿ç¨‹ 1: å†™å…¥
    thread::spawn(move || {
        data.store(42, Ordering::Relaxed);
        flag.store(true, Ordering::Release);  // Release
    });

    // çº¿ç¨‹ 2: è¯»å–
    while !flag.load(Ordering::Acquire) {}  // Acquire
    assert_eq!(data.load(Ordering::Relaxed), 42);  // ä¿è¯å¯è§æ€§
}
```

---

## 6. å†…å­˜æ³„æ¼é¢„é˜²

### 6.1 å¾ªç¯å¼•ç”¨æ£€æµ‹

#### æ£€æµ‹å·¥å…·

```rust
// ä½¿ç”¨ Rc::strong_count å’Œ Rc::weak_count

use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    next: Option<Rc<RefCell<Node>>>,
    prev: Option<Weak<RefCell<Node>>>,
}

fn detect_cycle() {
    let node1 = Rc::new(RefCell::new(Node {
        value: 1,
        next: None,
        prev: None,
    }));

    let node2 = Rc::new(RefCell::new(Node {
        value: 2,
        next: Some(Rc::clone(&node1)),
        prev: None,
    }));

    node1.borrow_mut().prev = Some(Rc::downgrade(&node2));

    println!("node1 strong: {}", Rc::strong_count(&node1));  // 2
    println!("node1 weak: {}", Rc::weak_count(&node1));      // 1
    println!("node2 strong: {}", Rc::strong_count(&node2));  // 1
    println!("node2 weak: {}", Rc::weak_count(&node2));      // 0
}
```

### 6.2 èµ„æºç®¡ç†æ¨¡å¼

#### RAII æ¨¡å¼

```rust
// âœ… åˆ©ç”¨ Drop è‡ªåŠ¨æ¸…ç†

use std::fs::File;

struct FileGuard {
    file: File,
}

impl FileGuard {
    fn new(path: &str) -> std::io::Result<Self> {
        Ok(Self { file: File::open(path)? })
    }
}

impl Drop for FileGuard {
    fn drop(&mut self) {
        println!("File closed automatically");
    }
}
```

### 6.3 Drop æœ€ä½³å®è·µ

```rust
// âœ… è‡ªå®šä¹‰ Drop å®ç°

struct CustomResource {
    id: usize,
}

impl Drop for CustomResource {
    fn drop(&mut self) {
        println!("Cleaning up resource {}", self.id);
        // æ¸…ç†é€»è¾‘
    }
}

// âš ï¸ Drop é¡ºåºï¼šå…ˆå†…éƒ¨å­—æ®µï¼Œåè‡ªå®šä¹‰ Drop
```

---

## 7. å®‰å…¨æ€§å®¡è®¡å’Œå·¥å…·

### 7.1 é™æ€åˆ†æå·¥å…·

```bash
# Clippy: Rust linter
cargo clippy

# Rustfmt: ä»£ç æ ¼å¼åŒ–
cargo fmt

# Cargo-audit: ä¾èµ–å®‰å…¨å®¡è®¡
cargo install cargo-audit
cargo audit

# Cargo-geiger: æ£€æµ‹ unsafe ä»£ç 
cargo install cargo-geiger
cargo geiger
```

### 7.2 åŠ¨æ€æ£€æµ‹å·¥å…·

```bash
# Miri: undefined behavior æ£€æµ‹
cargo +nightly miri test

# AddressSanitizer: å†…å­˜é”™è¯¯æ£€æµ‹
RUSTFLAGS="-Z sanitizer=address" cargo +nightly build

# ThreadSanitizer: æ•°æ®ç«äº‰æ£€æµ‹
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly build

# MemorySanitizer: æœªåˆå§‹åŒ–å†…å­˜æ£€æµ‹
RUSTFLAGS="-Z sanitizer=memory" cargo +nightly build
```

### 7.3 å®‰å…¨æ€§æµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_safety() {
        // è¾¹ç•Œæµ‹è¯•
        let mut vec = vec![1, 2, 3];
        assert_eq!(vec.get(10), None);  // ä¸ä¼š panic

        // ç”Ÿå‘½å‘¨æœŸæµ‹è¯•
        let x = 5;
        let r;
        {
            let y = 10;
            // r = &y;  // âŒ ç¼–è¯‘é”™è¯¯
            r = &x;  // âœ… OK
        }
        println!("{}", r);
    }

    #[test]
    fn test_thread_safety() {
        use std::sync::{Arc, Mutex};
        use std::thread;

        let data = Arc::new(Mutex::new(0));
        let mut handles = vec![];

        for _ in 0..10 {
            let data = Arc::clone(&data);
            let handle = thread::spawn(move || {
                let mut num = data.lock().unwrap();
                *num += 1;
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.join().unwrap();
        }

        assert_eq!(*data.lock().unwrap(), 10);
    }
}
```

---

## ç›¸å…³èµ„æº

### ğŸ“– æ ¸å¿ƒæ–‡æ¡£

- **[å†…å­˜å®‰å…¨åˆ†æ](../04_safety/01_memory_safety.md)**: æ·±å…¥çš„å†…å­˜å®‰å…¨æœºåˆ¶åˆ†æ
- **[Unsafe Rust](../04_safety/02_unsafe_rust.md)**: Unsafe ä»£ç è¯¦ç»†æŒ‡å—
- **[å¹¶å‘ç¼–ç¨‹](../05_practice/05_concurrent_programming.md)**: å¹¶å‘åœºæ™¯çš„å®‰å…¨å®è·µ

### ğŸ”— ç›¸å…³ä¸»é¢˜

- **Tier 3 é«˜çº§ä¸»é¢˜**
  - [06 é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ](./06_é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ.md)
  - [3.2 é›¶æˆæœ¬æŠ½è±¡](./3.2_é›¶æˆæœ¬æŠ½è±¡.md)
  - [3.4 æ€§èƒ½ä¼˜åŒ–](./3.4_æ€§èƒ½ä¼˜åŒ–.md)

- **Tier 4 ç†è®ºæ·±åº¦**
  - [4.1 ç±»å‹ç³»ç»Ÿç†è®º](../tier4_theoretical/4.1_ç±»å‹ç³»ç»Ÿç†è®º.md)
  - [4.2 å½¢å¼åŒ–éªŒè¯](../tier4_theoretical/4.2_å½¢å¼åŒ–éªŒè¯.md)

### ğŸ› ï¸ å·¥å…·å’Œèµ„æº

**å®‰å…¨å·¥å…·**:

- `cargo-audit` - ä¾èµ–å®‰å…¨å®¡è®¡
- `cargo-geiger` - unsafe ä»£ç æ£€æµ‹
- `cargo-clippy` - Lint å·¥å…·
- `miri` - undefined behavior æ£€æµ‹
- `sanitizers` - å†…å­˜/çº¿ç¨‹å®‰å…¨æ£€æµ‹

**å­¦ä¹ èµ„æº**:

- [The Rustonomicon](https://doc.rust-lang.org/nomicon/) - Unsafe Rust æƒå¨æŒ‡å—
- [Rust Security Guidelines](https://anssi-fr.github.io/rust-guide/)
- [Secure Rust Guidelines](https://github.com/rust-secure-code/projects)

### ğŸ“š å­¦ä¹ è·¯å¾„

**è¿›é˜¶è·¯å¾„**:

1. å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ ï¼ˆé¢„ä¼° 10-15 å°æ—¶ï¼‰
2. æ·±å…¥å­¦ä¹  The Rustonomicon
3. å®è·µ unsafe ä»£ç å®¡è®¡
4. ç ”ç©¶å½¢å¼åŒ–éªŒè¯æ–¹æ³•

**å®è·µå»ºè®®**:

- ğŸ”¨ å®¡è®¡å¼€æºé¡¹ç›®çš„ unsafe ä»£ç 
- ğŸ”¨ ä¸ºè‡ªå·±çš„é¡¹ç›®è¿è¡Œæ‰€æœ‰å®‰å…¨æ£€æµ‹å·¥å…·
- ğŸ”¨ å®ç°ä¸€ä¸ªå®‰å…¨çš„ FFI åŒ…è£…
- ğŸ”¨ å‚ä¸å®‰å…¨ä»£ç è¯„å®¡

### ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ä»¥éªŒè¯å­¦ä¹ æ•ˆæœ:

- [ ] ç†è§£ Rust å†…å­˜å®‰å…¨çš„æ ¸å¿ƒä¿è¯
- [ ] æŒæ¡å®‰å…¨ Rust çš„æœ€ä½³å®è·µ
- [ ] èƒ½å¤Ÿæ­£ç¡®ä½¿ç”¨ unsafe ä»£ç 
- [ ] å®ç°å®‰å…¨çš„ FFI äº’æ“ä½œ
- [ ] è®¾è®¡çº¿ç¨‹å®‰å…¨çš„å¹¶å‘ç³»ç»Ÿ
- [ ] è¯†åˆ«å’Œé¢„é˜²å†…å­˜æ³„æ¼
- [ ] ä½¿ç”¨å·¥å…·è¿›è¡Œå®‰å…¨æ€§å®¡è®¡
- [ ] èƒ½å¤Ÿå®¡è®¡å’Œè¯„ä¼° unsafe ä»£ç 

---

**æœ€åæ›´æ–°**: 2025-12-11
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0 (æ‰©å±•ç‰ˆ)
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.92.0+
**é¢„ä¼°å­¦ä¹ æ—¶é—´**: 10-15 å°æ—¶
**éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (é«˜çº§+)

---

END OF DOCUMENT
