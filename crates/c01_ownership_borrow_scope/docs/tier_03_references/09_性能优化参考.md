# 3.4 æ€§èƒ½ä¼˜åŒ–

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.92.0+
**æœ€åæ›´æ–°**: 2026-01-26
**æ–‡æ¡£ç±»å‹**: Tier 3 é«˜çº§å®è·µæŒ‡å—

---

## ğŸ“‹ ç›®å½•

- [3.4 æ€§èƒ½ä¼˜åŒ–](#34-æ€§èƒ½ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è§ˆ](#æ–‡æ¡£æ¦‚è§ˆ)
    - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
    - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
    - [ğŸ¨ æ–‡æ¡£ç‰¹è‰²](#-æ–‡æ¡£ç‰¹è‰²)
  - [1. æ€§èƒ½åˆ†æåŸºç¡€](#1-æ€§èƒ½åˆ†æåŸºç¡€)
    - [1.1 æ€§èƒ½åˆ†æå·¥å…·é“¾](#11-æ€§èƒ½åˆ†æå·¥å…·é“¾)
      - [Criterion.rs - åŸºå‡†æµ‹è¯•æ¡†æ¶](#criterionrs---åŸºå‡†æµ‹è¯•æ¡†æ¶)
      - [Flamegraph - æ€§èƒ½ç«ç„°å›¾](#flamegraph---æ€§èƒ½ç«ç„°å›¾)
      - [perf (Linux)](#perf-linux)
      - [Instruments (macOS)](#instruments-macos)
      - [cargo-asm - æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–](#cargo-asm---æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–)
    - [1.2 åŸºå‡†æµ‹è¯•æ¡†æ¶](#12-åŸºå‡†æµ‹è¯•æ¡†æ¶)
      - [Criterion é«˜çº§ç”¨æ³•](#criterion-é«˜çº§ç”¨æ³•)
      - [ç»Ÿè®¡åˆ†æ](#ç»Ÿè®¡åˆ†æ)
    - [1.3 æ€§èƒ½å‰–ææ–¹æ³•](#13-æ€§èƒ½å‰–ææ–¹æ³•)
      - [CPU æ€§èƒ½å‰–æ](#cpu-æ€§èƒ½å‰–æ)
      - [å†…å­˜å‰–æ](#å†…å­˜å‰–æ)
      - [ç¼“å­˜æ€§èƒ½åˆ†æ](#ç¼“å­˜æ€§èƒ½åˆ†æ)
  - [2. æ‰€æœ‰æƒç³»ç»Ÿæ€§èƒ½å½±å“](#2-æ‰€æœ‰æƒç³»ç»Ÿæ€§èƒ½å½±å“)
    - [2.1 Move vs Copy vs Clone](#21-move-vs-copy-vs-clone)
      - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
      - [ä¼˜åŒ–ç­–ç•¥](#ä¼˜åŒ–ç­–ç•¥)
    - [2.2 å€Ÿç”¨æ£€æŸ¥å™¨å¼€é”€](#22-å€Ÿç”¨æ£€æŸ¥å™¨å¼€é”€)
      - [è¿è¡Œæ—¶å¼€é”€](#è¿è¡Œæ—¶å¼€é”€)
      - [RefCell çš„è¿è¡Œæ—¶å¼€é”€](#refcell-çš„è¿è¡Œæ—¶å¼€é”€)
    - [2.3 ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¼˜åŒ–](#23-ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¼˜åŒ–)
      - [ç”Ÿå‘½å‘¨æœŸé›¶æˆæœ¬](#ç”Ÿå‘½å‘¨æœŸé›¶æˆæœ¬)
  - [3. å†…å­˜å¸ƒå±€ä¼˜åŒ–](#3-å†…å­˜å¸ƒå±€ä¼˜åŒ–)
    - [3.1 æ•°æ®å¯¹é½å’Œå¡«å……](#31-æ•°æ®å¯¹é½å’Œå¡«å……)
      - [ç†è§£å†…å­˜å¸ƒå±€](#ç†è§£å†…å­˜å¸ƒå±€)
      - [å­—æ®µæ’åºä¼˜åŒ–](#å­—æ®µæ’åºä¼˜åŒ–)
      - [ä½¿ç”¨å·¥å…·æ£€æŸ¥](#ä½¿ç”¨å·¥å…·æ£€æŸ¥)
      - [#\[repr\] å±æ€§](#repr-å±æ€§)
    - [3.2 ç¼“å­˜å‹å¥½è®¾è®¡](#32-ç¼“å­˜å‹å¥½è®¾è®¡)
      - [CPU ç¼“å­˜åŸºç¡€](#cpu-ç¼“å­˜åŸºç¡€)
      - [æ•°æ®å±€éƒ¨æ€§ä¼˜åŒ–](#æ•°æ®å±€éƒ¨æ€§ä¼˜åŒ–)
      - [False Sharing é¿å…](#false-sharing-é¿å…)
    - [3.3 å†…å­˜åˆ†é…ä¼˜åŒ–](#33-å†…å­˜åˆ†é…ä¼˜åŒ–)
      - [é¢„åˆ†é…å®¹é‡](#é¢„åˆ†é…å®¹é‡)
      - [é‡ç”¨åˆ†é…](#é‡ç”¨åˆ†é…)
      - [è‡ªå®šä¹‰åˆ†é…å™¨](#è‡ªå®šä¹‰åˆ†é…å™¨)
  - [4. ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€å·§](#4-ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€å·§)
    - [4.1 å†…è”ç­–ç•¥](#41-å†…è”ç­–ç•¥)
      - [å†…è”å†³ç­–](#å†…è”å†³ç­–)
      - [æŸ¥çœ‹å†…è”æ•ˆæœ](#æŸ¥çœ‹å†…è”æ•ˆæœ)
    - [4.2 ç¼–è¯‘æ ‡å¿—è°ƒä¼˜](#42-ç¼–è¯‘æ ‡å¿—è°ƒä¼˜)
      - [Cargo.toml ä¼˜åŒ–é…ç½®](#cargotoml-ä¼˜åŒ–é…ç½®)
      - [CPU ç‰¹å®šä¼˜åŒ–](#cpu-ç‰¹å®šä¼˜åŒ–)
    - [4.3 LTO å’Œ PGO](#43-lto-å’Œ-pgo)
      - [LTO (Link-Time Optimization)](#lto-link-time-optimization)
      - [PGO (Profile-Guided Optimization)](#pgo-profile-guided-optimization)
  - [5. ç®—æ³•å’Œæ•°æ®ç»“æ„ä¼˜åŒ–](#5-ç®—æ³•å’Œæ•°æ®ç»“æ„ä¼˜åŒ–)
    - [5.1 å®¹å™¨é€‰æ‹©](#51-å®¹å™¨é€‰æ‹©)
      - [5.1.1 æ€§èƒ½å¯¹æ¯”](#511-æ€§èƒ½å¯¹æ¯”)
      - [é€‰æ‹©æŒ‡å—](#é€‰æ‹©æŒ‡å—)
    - [5.2 è¿­ä»£å™¨ä¼˜åŒ–](#52-è¿­ä»£å™¨ä¼˜åŒ–)
      - [è¿­ä»£å™¨ vs å¾ªç¯](#è¿­ä»£å™¨-vs-å¾ªç¯)
      - [å¹¶è¡Œè¿­ä»£å™¨](#å¹¶è¡Œè¿­ä»£å™¨)
    - [5.3 å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–](#53-å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–)
      - [å­—ç¬¦ä¸²è¿æ¥](#å­—ç¬¦ä¸²è¿æ¥)
  - [6. å¹¶å‘æ€§èƒ½ä¼˜åŒ–](#6-å¹¶å‘æ€§èƒ½ä¼˜åŒ–)
    - [6.1 é”ç«äº‰ä¼˜åŒ–](#61-é”ç«äº‰ä¼˜åŒ–)
      - [å‡å°‘é”æŒæœ‰æ—¶é—´](#å‡å°‘é”æŒæœ‰æ—¶é—´)
      - [åˆ†ç‰‡é”](#åˆ†ç‰‡é”)
    - [6.2 æ— é”æ•°æ®ç»“æ„](#62-æ— é”æ•°æ®ç»“æ„)
      - [åŸå­æ“ä½œ](#åŸå­æ“ä½œ)
      - [æ— é”é˜Ÿåˆ—](#æ— é”é˜Ÿåˆ—)
    - [6.3 å¹¶è¡Œè¿­ä»£å™¨](#63-å¹¶è¡Œè¿­ä»£å™¨)
      - [Rayon å¹¶è¡ŒåŒ–](#rayon-å¹¶è¡ŒåŒ–)
  - [7. å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹](#7-å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹)
    - [7.1 JSON è§£æä¼˜åŒ–](#71-json-è§£æä¼˜åŒ–)
    - [7.2 HTTP æœåŠ¡å™¨ä¼˜åŒ–](#72-http-æœåŠ¡å™¨ä¼˜åŒ–)
    - [7.3 æ•°æ®å¤„ç†ç®¡é“ä¼˜åŒ–](#73-æ•°æ®å¤„ç†ç®¡é“ä¼˜åŒ–)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
    - [ğŸ“– æ ¸å¿ƒæ–‡æ¡£](#-æ ¸å¿ƒæ–‡æ¡£)
    - [ğŸ”— ç›¸å…³ä¸»é¢˜](#-ç›¸å…³ä¸»é¢˜)
    - [ğŸ› ï¸ å·¥å…·å’Œèµ„æº](#ï¸-å·¥å…·å’Œèµ„æº)
    - [ğŸ“š å­¦ä¹ è·¯å¾„](#-å­¦ä¹ è·¯å¾„)
    - [ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•](#-å­¦ä¹ æ£€æŸ¥æ¸…å•)

---

## æ–‡æ¡£æ¦‚è§ˆ

### ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ å°†èƒ½å¤Ÿ:

- âœ… ä½¿ç”¨ä¸“ä¸šå·¥å…·è¿›è¡Œæ€§èƒ½åˆ†æå’ŒåŸºå‡†æµ‹è¯•
- âœ… ç†è§£æ‰€æœ‰æƒç³»ç»Ÿå¯¹æ€§èƒ½çš„å½±å“
- âœ… ä¼˜åŒ–å†…å­˜å¸ƒå±€å’Œåˆ†é…ç­–ç•¥
- âœ… åˆ©ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–æå‡æ€§èƒ½
- âœ… é€‰æ‹©å’Œä¼˜åŒ–ç®—æ³•ã€æ•°æ®ç»“æ„
- âœ… å®ç°é«˜æ€§èƒ½å¹¶å‘ä»£ç 
- âœ… åº”ç”¨ä¼˜åŒ–æŠ€å·§åˆ°å®é™…é¡¹ç›®

### ğŸ“š å‰ç½®çŸ¥è¯†

å­¦ä¹ æœ¬æ–‡æ¡£å‰ï¼Œä½ éœ€è¦:

- âœ… ç²¾é€š Rust çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ
- âœ… äº†è§£é›¶æˆæœ¬æŠ½è±¡åŸç†
- âœ… ç†Ÿæ‚‰æ€§èƒ½åˆ†æåŸºæœ¬æ¦‚å¿µ
- âœ… æœ‰å®é™…çš„ Rust é¡¹ç›®ç»éªŒ

**æ¨èå…ˆå­¦ä¹ **: [3.2 é›¶æˆæœ¬æŠ½è±¡](./3.2_é›¶æˆæœ¬æŠ½è±¡.md)

### ğŸ¨ æ–‡æ¡£ç‰¹è‰²

æœ¬æ–‡æ¡£æä¾›:

- âš¡ **å®æˆ˜å¯¼å‘**: çœŸå®é¡¹ç›®çš„ä¼˜åŒ–æ¡ˆä¾‹
- ğŸ“Š **æ•°æ®é©±åŠ¨**: è¯¦ç»†çš„æ€§èƒ½æµ‹è¯•æ•°æ®
- ğŸ› ï¸ **å·¥å…·æŒ‡å—**: å®Œæ•´çš„å·¥å…·é“¾ä½¿ç”¨æ–¹æ³•
- ğŸ’¡ **ä¼˜åŒ–æ¨¡å¼**: ç»è¿‡éªŒè¯çš„ä¼˜åŒ–æŠ€å·§
- âš–ï¸ **æƒè¡¡åˆ†æ**: æ€§èƒ½ä¸å¯ç»´æŠ¤æ€§çš„å¹³è¡¡

---

## 1. æ€§èƒ½åˆ†æåŸºç¡€

### 1.1 æ€§èƒ½åˆ†æå·¥å…·é“¾

#### Criterion.rs - åŸºå‡†æµ‹è¯•æ¡†æ¶

```toml
# Cargo.toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "my_benchmark"
harness = false
```

```rust
// benches/my_benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

**è¿è¡ŒåŸºå‡†æµ‹è¯•**:

```bash
cargo bench
```

#### Flamegraph - æ€§èƒ½ç«ç„°å›¾

```bash
# å®‰è£…
cargo install flamegraph

# ç”Ÿæˆç«ç„°å›¾
cargo flamegraph --bin your_app

# è¾“å‡º: flamegraph.svg
```

#### perf (Linux)

```bash
# è®°å½•æ€§èƒ½æ•°æ®
perf record --call-graph dwarf ./target/release/your_app

# æŸ¥çœ‹æŠ¥å‘Š
perf report

# ç”Ÿæˆç«ç„°å›¾
perf script | stackcollapse-perf.pl | flamegraph.pl > perf.svg
```

#### Instruments (macOS)

```bash
# ä½¿ç”¨ Instruments è¿›è¡Œæ€§èƒ½åˆ†æ
instruments -t "Time Profiler" ./target/release/your_app
```

#### cargo-asm - æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–

```bash
# å®‰è£…
cargo install cargo-asm

# æŸ¥çœ‹å‡½æ•°çš„æ±‡ç¼–ä»£ç 
cargo asm your_crate::module::function
```

### 1.2 åŸºå‡†æµ‹è¯•æ¡†æ¶

#### Criterion é«˜çº§ç”¨æ³•

```rust
use criterion::{
    black_box, criterion_group, criterion_main,
    BenchmarkId, Criterion, Throughput
};

fn bench_with_input(c: &mut Criterion) {
    let mut group = c.benchmark_group("vector_operations");

    for size in [100, 1000, 10000].iter() {
        group.throughput(Throughput::Elements(*size as u64));

        group.bench_with_input(
            BenchmarkId::from_parameter(size),
            size,
            |b, &size| {
                let vec: Vec<i32> = (0..size).collect();
                b.iter(|| {
                    vec.iter().map(|x| x * 2).sum::<i32>()
                });
            },
        );
    }

    group.finish();
}

// å¯¹æ¯”ä¸åŒå®ç°
fn bench_comparison(c: &mut Criterion) {
    let mut group = c.benchmark_group("string_concat");
    let strings: Vec<String> = vec!["hello"; 1000]
        .into_iter()
        .map(String::from)
        .collect();

    group.bench_function("push_str", |b| {
        b.iter(|| {
            let mut result = String::new();
            for s in &strings {
                result.push_str(s);
            }
            result
        });
    });

    group.bench_function("join", |b| {
        b.iter(|| {
            strings.join("")
        });
    });

    group.finish();
}

criterion_group!(benches, bench_with_input, bench_comparison);
criterion_main!(benches);
```

#### ç»Ÿè®¡åˆ†æ

Criterion è‡ªåŠ¨æä¾›:

- **å¹³å‡å€¼å’Œä¸­ä½æ•°**
- **æ ‡å‡†å·®**
- **å¼‚å¸¸å€¼æ£€æµ‹**
- **å›å½’æ£€æµ‹**ï¼ˆä¸ä¹‹å‰çš„è¿è¡Œå¯¹æ¯”ï¼‰

### 1.3 æ€§èƒ½å‰–ææ–¹æ³•

#### CPU æ€§èƒ½å‰–æ

```rust
// ä½¿ç”¨ pprof-rs è¿›è¡Œ CPU å‰–æ
use pprof::ProfilerGuard;

fn main() {
    let guard = ProfilerGuard::new(100).unwrap();

    // ä½ çš„ä»£ç 
    expensive_computation();

    if let Ok(report) = guard.report().build() {
        let file = std::fs::File::create("profile.svg").unwrap();
        report.flamegraph(file).unwrap();
    }
}
```

#### å†…å­˜å‰–æ

```bash
# ä½¿ç”¨ valgrind (Linux)
valgrind --tool=massif ./target/release/your_app

# æŸ¥çœ‹æŠ¥å‘Š
ms_print massif.out.*

# ä½¿ç”¨ heaptrack (Linux)
heaptrack ./target/release/your_app
heaptrack_gui heaptrack.your_app.*.gz
```

#### ç¼“å­˜æ€§èƒ½åˆ†æ

```bash
# perf ç¼“å­˜åˆ†æ
perf stat -e cache-references,cache-misses ./target/release/your_app

# è¯¦ç»†ç¼“å­˜åˆ†æ
perf stat -d ./target/release/your_app
```

---

## 2. æ‰€æœ‰æƒç³»ç»Ÿæ€§èƒ½å½±å“

### 2.1 Move vs Copy vs Clone

#### æ€§èƒ½å¯¹æ¯”

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

#[derive(Clone)]
struct LargeStruct {
    data: Vec<u8>,
}

#[derive(Copy, Clone)]
struct SmallStruct {
    x: i64,
    y: i64,
}

fn bench_move_copy_clone(c: &mut Criterion) {
    let mut group = c.benchmark_group("ownership_patterns");

    // Move (é›¶æˆæœ¬)
    group.bench_function("move_large", |b| {
        b.iter(|| {
            let data = LargeStruct { data: vec![0; 1000] };
            let moved = data;  // Moveï¼Œåªä¼ é€’æŒ‡é’ˆ
            black_box(moved);
        });
    });

    // Clone (æ˜‚è´µ)
    group.bench_function("clone_large", |b| {
        let data = LargeStruct { data: vec![0; 1000] };
        b.iter(|| {
            let cloned = data.clone();  // æ·±æ‹·è´
            black_box(cloned);
        });
    });

    // Copy (å»‰ä»·)
    group.bench_function("copy_small", |b| {
        let data = SmallStruct { x: 42, y: 100 };
        b.iter(|| {
            let copied = data;  // æ ˆæ‹·è´ï¼Œéå¸¸å¿«
            black_box(copied);
        });
    });

    group.finish();
}

criterion_group!(benches, bench_move_copy_clone);
criterion_main!(benches);
```

**å…¸å‹ç»“æœ**:

| æ“ä½œ      | æ•°æ®å¤§å° | æ—¶é—´    | è¯´æ˜          |
| --------- | -------- | ------- | ------------- |
| **Move**  | 1KB      | ~2 ns   | åªä¼ é€’æŒ‡é’ˆ    |
| **Clone** | 1KB      | ~100 ns | å †åˆ†é… + æ‹·è´ |
| **Copy**  | 16 bytes | ~0.5 ns | æ ˆæ‹·è´        |

#### ä¼˜åŒ–ç­–ç•¥

```rust
// âŒ ä¸å¿…è¦çš„ Clone
fn process_bad(data: &Vec<i32>) -> Vec<i32> {
    let mut result = data.clone();  // æ˜‚è´µçš„å…‹éš†
    result.push(42);
    result
}

// âœ… ä½¿ç”¨ Move
fn process_good(mut data: Vec<i32>) -> Vec<i32> {
    data.push(42);
    data  // Move è¿”å›ï¼Œé›¶æˆæœ¬
}

// âœ… åŸåœ°ä¿®æ”¹
fn process_best(data: &mut Vec<i32>) {
    data.push(42);
}
```

### 2.2 å€Ÿç”¨æ£€æŸ¥å™¨å¼€é”€

#### è¿è¡Œæ—¶å¼€é”€

å€Ÿç”¨æ£€æŸ¥æ˜¯**ç¼–è¯‘æ—¶**è¿›è¡Œçš„ï¼Œ**æ— è¿è¡Œæ—¶å¼€é”€**:

```rust
fn borrow_example(data: &Vec<i32>) -> i32 {
    data.iter().sum()
}

// ç¼–è¯‘åç­‰ä»·äº C:
// int borrow_example(const std::vector<int>* data) {
//     return std::accumulate(data->begin(), data->end(), 0);
// }
```

**å…³é”®ç‚¹**:

- âœ… å€Ÿç”¨æ£€æŸ¥å™¨ä¸ç”Ÿæˆä»»ä½•è¿è¡Œæ—¶ä»£ç 
- âœ… å¼•ç”¨å°±æ˜¯æŒ‡é’ˆï¼Œæ— é¢å¤–å¼€é”€
- âœ… ç”Ÿå‘½å‘¨æœŸåœ¨ç¼–è¯‘åå®Œå…¨æ“¦é™¤

#### RefCell çš„è¿è¡Œæ—¶å¼€é”€

```rust
use std::cell::RefCell;
use criterion::{black_box, Criterion};

fn bench_refcell_overhead(c: &mut Criterion) {
    let mut group = c.benchmark_group("borrow_check");

    // ç›´æ¥è®¿é—®ï¼ˆæ— å¼€é”€ï¼‰
    group.bench_function("direct", |b| {
        let mut data = vec![1, 2, 3];
        b.iter(|| {
            data.push(black_box(4));
            data.pop();
        });
    });

    // RefCellï¼ˆæœ‰è¿è¡Œæ—¶æ£€æŸ¥ï¼‰
    group.bench_function("refcell", |b| {
        let data = RefCell::new(vec![1, 2, 3]);
        b.iter(|| {
            data.borrow_mut().push(black_box(4));
            data.borrow_mut().pop();
        });
    });

    group.finish();
}
```

**å…¸å‹å¼€é”€**: RefCell å¢åŠ çº¦ 5-10% çš„å¼€é”€ï¼ˆæ¯æ¬¡ borrow_mutï¼‰

### 2.3 ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¼˜åŒ–

#### ç”Ÿå‘½å‘¨æœŸé›¶æˆæœ¬

```rust
// å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn complex_lifetimes<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where 'b: 'a  // 'b å¿…é¡»è‡³å°‘å’Œ 'a ä¸€æ ·é•¿
{
    if x.len() > y.len() { x } else { y }
}

// ç¼–è¯‘åï¼šç”Ÿå‘½å‘¨æœŸå®Œå…¨æ“¦é™¤ï¼Œæ— å¼€é”€
// const char* complex_lifetimes(const char* x, const char* y) {
//     return strlen(x) > strlen(y) ? x : y;
// }
```

**å…³é”®ç‚¹**:

- âœ… ç”Ÿå‘½å‘¨æœŸæ˜¯é›¶æˆæœ¬æŠ½è±¡
- âœ… åªåœ¨ç¼–è¯‘æ—¶å­˜åœ¨
- âœ… è¿è¡Œæ—¶ç­‰ä»·äºåŸå§‹æŒ‡é’ˆæ“ä½œ

---

## 3. å†…å­˜å¸ƒå±€ä¼˜åŒ–

### 3.1 æ•°æ®å¯¹é½å’Œå¡«å……

#### ç†è§£å†…å­˜å¸ƒå±€

```rust
use std::mem::{size_of, align_of};

// é»˜è®¤å¸ƒå±€ï¼ˆå¯èƒ½æœ‰å¡«å……ï¼‰
struct Unoptimized {
    a: u8,   // 1 byte
    // 7 bytes padding
    b: u64,  // 8 bytes
    c: u8,   // 1 byte
    // 7 bytes padding
}

// ä¼˜åŒ–åçš„å¸ƒå±€
struct Optimized {
    b: u64,  // 8 bytes
    a: u8,   // 1 byte
    c: u8,   // 1 byte
    // 6 bytes padding
}

fn main() {
    println!("Unoptimized: {} bytes", size_of::<Unoptimized>());  // 24
    println!("Optimized: {} bytes", size_of::<Optimized>());      // 16

    // èŠ‚çœ 33% å†…å­˜ï¼
}
```

#### å­—æ®µæ’åºä¼˜åŒ–

```rust
// âŒ ç³Ÿç³•çš„å¸ƒå±€
struct Bad {
    a: u8,    // 1 byte, 7 padding
    b: u64,   // 8 bytes
    c: u16,   // 2 bytes, 6 padding
    d: u32,   // 4 bytes, 4 padding
}
// æ€»è®¡: 32 bytes

// âœ… ä¼˜åŒ–åçš„å¸ƒå±€
struct Good {
    b: u64,   // 8 bytes (æœ€å¤§çš„å…ˆ)
    d: u32,   // 4 bytes
    c: u16,   // 2 bytes
    a: u8,    // 1 byte
    // 1 byte padding
}
// æ€»è®¡: 16 bytes (èŠ‚çœ 50%)
```

#### ä½¿ç”¨å·¥å…·æ£€æŸ¥

```bash
# æŸ¥çœ‹ç±»å‹å¤§å°å’Œå¸ƒå±€
cargo rustc -- -Z print-type-sizes
```

#### #[repr] å±æ€§

```rust
// C å…¼å®¹å¸ƒå±€
#[repr(C)]
struct CLayout {
    a: u8,
    b: u64,
}

// ç´§å‡‘å¸ƒå±€ï¼ˆæ— å¡«å……ï¼Œä½†å¯èƒ½æœªå¯¹é½ï¼‰
#[repr(packed)]
struct Packed {
    a: u8,
    b: u64,  // âš ï¸ å¯èƒ½æœªå¯¹é½ï¼Œè®¿é—®è¾ƒæ…¢
}

// å¯¹é½åˆ°ç‰¹å®šå­—èŠ‚
#[repr(align(64))]  // ç¼“å­˜è¡Œå¯¹é½
struct CacheAligned {
    data: [u8; 64],
}
```

### 3.2 ç¼“å­˜å‹å¥½è®¾è®¡

#### CPU ç¼“å­˜åŸºç¡€

ç°ä»£ CPU ç¼“å­˜å±‚æ¬¡:

```text
L1 Cache: 32-64 KB, ~4 cycles, æ¯æ ¸ç§æœ‰
L2 Cache: 256 KB-1 MB, ~12 cycles, æ¯æ ¸ç§æœ‰
L3 Cache: 8-64 MB, ~40 cycles, æ‰€æœ‰æ ¸å…±äº«
ä¸»å†…å­˜: GBçº§, ~100-300 cycles
```

**ç¼“å­˜è¡Œ**: é€šå¸¸ 64 å­—èŠ‚

#### æ•°æ®å±€éƒ¨æ€§ä¼˜åŒ–

```rust
// âŒ ç¼“å­˜ä¸å‹å¥½ï¼šAoS (Array of Structures)
struct ParticleBad {
    position: [f32; 3],  // 12 bytes
    velocity: [f32; 3],  // 12 bytes
    mass: f32,           // 4 bytes
    _padding: [u8; 8],   // 8 bytes (å¯¹é½åˆ° 32)
}

fn update_positions_bad(particles: &mut [ParticleBad]) {
    for particle in particles {
        particle.position[0] += particle.velocity[0];
        particle.position[1] += particle.velocity[1];
        particle.position[2] += particle.velocity[2];
    }
    // æ¯ä¸ªç²’å­å ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªç¼“å­˜è¡Œ
    // ä½†æˆ‘ä»¬åªä½¿ç”¨äº†éƒ¨åˆ†æ•°æ®ï¼ˆposition å’Œ velocityï¼‰
}

// âœ… ç¼“å­˜å‹å¥½ï¼šSoA (Structure of Arrays)
struct ParticlesGood {
    positions_x: Vec<f32>,
    positions_y: Vec<f32>,
    positions_z: Vec<f32>,
    velocities_x: Vec<f32>,
    velocities_y: Vec<f32>,
    velocities_z: Vec<f32>,
}

fn update_positions_good(particles: &mut ParticlesGood) {
    for i in 0..particles.positions_x.len() {
        particles.positions_x[i] += particles.velocities_x[i];
        particles.positions_y[i] += particles.velocities_y[i];
        particles.positions_z[i] += particles.velocities_z[i];
    }
    // è¿ç»­è®¿é—®ï¼Œæ¯ä¸ªç¼“å­˜è¡Œéƒ½å……åˆ†åˆ©ç”¨
}
```

**æ€§èƒ½æå‡**: SoA é€šå¸¸æ¯” AoS å¿« 2-4x

#### False Sharing é¿å…

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread;

// âŒ False sharing: å¤šä¸ªçº¿ç¨‹ä¿®æ”¹åŒä¸€ç¼“å­˜è¡Œ
struct BadCounters {
    counter1: AtomicU64,  // 8 bytes
    counter2: AtomicU64,  // 8 bytes (åœ¨åŒä¸€ç¼“å­˜è¡Œ)
}

// âœ… é¿å… false sharing: å¡«å……åˆ°ä¸åŒç¼“å­˜è¡Œ
#[repr(align(64))]  // ç¼“å­˜è¡Œå¯¹é½
struct GoodCounter {
    counter: AtomicU64,
    _padding: [u8; 56],  // å¡«å……åˆ° 64 å­—èŠ‚
}

struct GoodCounters {
    counter1: GoodCounter,
    counter2: GoodCounter,
}

fn bench_false_sharing() {
    let bad = std::sync::Arc::new(BadCounters {
        counter1: AtomicU64::new(0),
        counter2: AtomicU64::new(0),
    });

    let good = std::sync::Arc::new(GoodCounters {
        counter1: GoodCounter { counter: AtomicU64::new(0), _padding: [0; 56] },
        counter2: GoodCounter { counter: AtomicU64::new(0), _padding: [0; 56] },
    });

    // æµ‹è¯•ä¼šæ˜¾ç¤º GoodCounters å¿«å¾ˆå¤š
}
```

### 3.3 å†…å­˜åˆ†é…ä¼˜åŒ–

#### é¢„åˆ†é…å®¹é‡

```rust
use criterion::{black_box, Criterion};

fn bench_allocation(c: &mut Criterion) {
    let mut group = c.benchmark_group("allocation");

    // âŒ åŠ¨æ€å¢é•¿ï¼ˆå¤šæ¬¡åˆ†é…ï¼‰
    group.bench_function("dynamic", |b| {
        b.iter(|| {
            let mut vec = Vec::new();
            for i in 0..1000 {
                vec.push(black_box(i));
            }
        });
    });

    // âœ… é¢„åˆ†é…
    group.bench_function("preallocated", |b| {
        b.iter(|| {
            let mut vec = Vec::with_capacity(1000);
            for i in 0..1000 {
                vec.push(black_box(i));
            }
        });
    });

    group.finish();
}

// æ€§èƒ½æå‡: 2-3x
```

#### é‡ç”¨åˆ†é…

```rust
// âœ… é‡ç”¨ Vec é¿å…åˆ†é…
fn process_batches(batches: &[Vec<i32>]) -> Vec<Vec<i32>> {
    let mut result = Vec::new();
    let mut buffer = Vec::new();  // é‡ç”¨ç¼“å†²åŒº

    for batch in batches {
        buffer.clear();  // æ¸…ç©ºä½†ä¿ç•™å®¹é‡
        buffer.extend(batch.iter().filter(|&&x| x > 0));
        result.push(buffer.clone());
    }

    result
}

// æ›´å¥½ï¼šä½¿ç”¨å¯¹è±¡æ± 
use std::collections::VecDeque;

struct VecPool {
    pool: VecDeque<Vec<i32>>,
}

impl VecPool {
    fn get(&mut self) -> Vec<i32> {
        self.pool.pop_front().unwrap_or_else(Vec::new)
    }

    fn put(&mut self, mut vec: Vec<i32>) {
        vec.clear();
        self.pool.push_back(vec);
    }
}
```

#### è‡ªå®šä¹‰åˆ†é…å™¨

```rust
use std::alloc::{GlobalAlloc, System, Layout};

struct CountingAllocator;

static ALLOCATED: std::sync::atomic::AtomicUsize =
    std::sync::atomic::AtomicUsize::new(0);

unsafe impl GlobalAlloc for CountingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        ALLOCATED.fetch_add(layout.size(), std::sync::atomic::Ordering::SeqCst);
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        ALLOCATED.fetch_sub(layout.size(), std::sync::atomic::Ordering::SeqCst);
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: CountingAllocator = CountingAllocator;

// ç°åœ¨å¯ä»¥è¿½è¸ªå†…å­˜åˆ†é…
fn main() {
    println!("Allocated: {} bytes", ALLOCATED.load(std::sync::atomic::Ordering::SeqCst));
}
```

---

## 4. ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€å·§

### 4.1 å†…è”ç­–ç•¥

#### å†…è”å†³ç­–

```rust
// âœ… å°å‡½æ•°ï¼šæ€»æ˜¯å†…è”
#[inline(always)]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// âœ… ä¸­ç­‰å‡½æ•°ï¼šå»ºè®®å†…è”
#[inline]
fn process(data: &[i32]) -> i32 {
    data.iter().map(|x| x * 2).sum()
}

// âŒ å¤§å‡½æ•°ï¼šä¸å†…è”
// #[inline]  // ä¸åŠ 
fn complex_processing(data: &[i32]) -> Vec<i32> {
    // 50+ è¡Œå¤æ‚é€»è¾‘
}

// âœ… è·¨ crate å†…è”
#[inline]
pub fn public_api(x: i32) -> i32 {
    x * 2
}
```

#### æŸ¥çœ‹å†…è”æ•ˆæœ

```bash
# æŸ¥çœ‹æ˜¯å¦å†…è”
cargo asm --lib your_crate::function

# ä½¿ç”¨ LLVM IR
cargo rustc --release -- --emit=llvm-ir
```

### 4.2 ç¼–è¯‘æ ‡å¿—è°ƒä¼˜

#### Cargo.toml ä¼˜åŒ–é…ç½®

```toml
[profile.release]
# ä¼˜åŒ–çº§åˆ« (0-3, s, z)
opt-level = 3

# LTO: é“¾æ¥æ—¶ä¼˜åŒ–
lto = true

# ä»£ç ç”Ÿæˆå•å…ƒ (è¶Šå°‘ä¼˜åŒ–è¶Šå¥½ï¼Œä½†ç¼–è¯‘æ…¢)
codegen-units = 1

# ä¿ç•™è°ƒè¯•ä¿¡æ¯
debug = false

# æº¢å‡ºæ£€æŸ¥
overflow-checks = false

# å¢é‡ç¼–è¯‘
incremental = false

# æ›´æ¿€è¿›çš„ä¼˜åŒ–
[profile.release.build-override]
opt-level = 3
```

#### CPU ç‰¹å®šä¼˜åŒ–

```toml
# .cargo/config.toml
[build]
rustflags = [
    "-C", "target-cpu=native",  # ä½¿ç”¨æœ¬æœº CPU ç‰¹æ€§
]
```

```bash
# å‘½ä»¤è¡Œ
RUSTFLAGS="-C target-cpu=native" cargo build --release
```

### 4.3 LTO å’Œ PGO

#### LTO (Link-Time Optimization)

```toml
[profile.release]
lto = "fat"  # å®Œæ•´ LTO (æœ€æ…¢ä½†æœ€ä¼˜)
# lto = "thin"  # è½»é‡ LTO (å¹³è¡¡)
# lto = true  # ç­‰äº "fat"
```

**æ•ˆæœ**: é€šå¸¸ 5-15% æ€§èƒ½æå‡

#### PGO (Profile-Guided Optimization)

```bash
# æ­¥éª¤ 1: æ„å»º instrumented ç‰ˆæœ¬
RUSTFLAGS="-Cprofile-generate=/tmp/pgo-data" \
    cargo build --release

# æ­¥éª¤ 2: è¿è¡Œå…¸å‹å·¥ä½œè´Ÿè½½
./target/release/your_app

# æ­¥éª¤ 3: ä½¿ç”¨ profile æ•°æ®é‡æ–°ç¼–è¯‘
RUSTFLAGS="-Cprofile-use=/tmp/pgo-data/merged.profdata" \
    cargo build --release
```

**æ•ˆæœ**: é€šå¸¸ 10-30% æ€§èƒ½æå‡

---

## 5. ç®—æ³•å’Œæ•°æ®ç»“æ„ä¼˜åŒ–

### 5.1 å®¹å™¨é€‰æ‹©

#### 5.1.1 æ€§èƒ½å¯¹æ¯”

| æ“ä½œ              | Vec     | VecDeque | LinkedList | HashMap | BTreeMap |
| ----------------- | ------- | -------- | ---------- | ------- | -------- |
| **Push back**     | O(1)\*  | O(1)\*   | O(1)       | -       | -        |
| **Push front**    | O(n)    | O(1)\*   | O(1)       | -       | -        |
| **Random access** | O(1)    | O(1)     | O(n)       | -       | -        |
| **Insert**        | O(n)    | O(n)     | O(1)       | O(1)\*  | O(log n) |
| **Search**        | O(n)    | O(n)     | O(n)       | O(1)\*  | O(log n) |
| **Memory**        | ç´§å‡‘    | è¾ƒç´§å‡‘   | åˆ†æ•£       | åˆ†æ•£    | åˆ†æ•£     |
| **Cache**         | âœ… ä¼˜ç§€ | âš ï¸ ä¸­ç­‰  | âŒ å·®      | âš ï¸ ä¸­ç­‰ | âš ï¸ ä¸­ç­‰  |

\* æ‘Šé”€

#### é€‰æ‹©æŒ‡å—

```rust
// âœ… é¡ºåºè®¿é—®ã€éšæœºè®¿é—® â†’ Vec
let mut vec = Vec::new();
vec.push(1);
let x = vec[0];

// âœ… åŒç«¯é˜Ÿåˆ— â†’ VecDeque
use std::collections::VecDeque;
let mut deque = VecDeque::new();
deque.push_front(1);
deque.push_back(2);

// âŒ å¾ˆå°‘éœ€è¦ LinkedList
// åªåœ¨é¢‘ç¹ä¸­é—´æ’å…¥ä¸”ä¸éœ€è¦éšæœºè®¿é—®æ—¶è€ƒè™‘

// âœ… é”®å€¼æŸ¥æ‰¾ â†’ HashMap (å¿«) æˆ– BTreeMap (æœ‰åº)
use std::collections::HashMap;
let mut map = HashMap::new();
map.insert("key", "value");

// âœ… å°é›†åˆ â†’ SmallVec (æ ˆä¸Šä¼˜åŒ–)
use smallvec::SmallVec;
let mut vec: SmallVec<[i32; 8]> = SmallVec::new();
vec.push(1);  // å‰8ä¸ªå…ƒç´ åœ¨æ ˆä¸Š
```

### 5.2 è¿­ä»£å™¨ä¼˜åŒ–

#### è¿­ä»£å™¨ vs å¾ªç¯

```rust
use criterion::{black_box, Criterion};

fn bench_iteration(c: &mut Criterion) {
    let data: Vec<i32> = (0..10000).collect();
    let mut group = c.benchmark_group("iteration");

    // è¿­ä»£å™¨ï¼ˆé›¶æˆæœ¬ï¼‰
    group.bench_function("iterator", |b| {
        b.iter(|| {
            data.iter()
                .filter(|&&x| x % 2 == 0)
                .map(|&x| x * 2)
                .sum::<i32>()
        });
    });

    // æ‰‹å†™å¾ªç¯ï¼ˆç­‰ä»·æ€§èƒ½ï¼‰
    group.bench_function("loop", |b| {
        b.iter(|| {
            let mut sum = 0;
            for &x in &data {
                if x % 2 == 0 {
                    sum += x * 2;
                }
            }
            sum
        });
    });

    group.finish();
}

// ç»“æœï¼šå®Œå…¨ç›¸åŒçš„æ€§èƒ½
```

#### å¹¶è¡Œè¿­ä»£å™¨

```rust
use rayon::prelude::*;

fn bench_parallel(c: &mut Criterion) {
    let data: Vec<i32> = (0..1_000_000).collect();
    let mut group = c.benchmark_group("parallel");

    // é¡ºåº
    group.bench_function("sequential", |b| {
        b.iter(|| {
            data.iter().map(|&x| expensive_computation(x)).sum::<i32>()
        });
    });

    // å¹¶è¡Œ
    group.bench_function("parallel", |b| {
        b.iter(|| {
            data.par_iter().map(|&x| expensive_computation(x)).sum::<i32>()
        });
    });

    group.finish();
}

fn expensive_computation(x: i32) -> i32 {
    (0..100).fold(x, |acc, _| (acc * 31) % 1000)
}

// å¹¶è¡Œå¯èƒ½å¿« 4-8x (å–å†³äºæ ¸å¿ƒæ•°)
```

### 5.3 å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–

#### å­—ç¬¦ä¸²è¿æ¥

```rust
fn bench_string_concat(c: &mut Criterion) {
    let strings: Vec<&str> = vec!["hello"; 1000];
    let mut group = c.benchmark_group("string_concat");

    // âŒ æœ€æ…¢ï¼šé‡å¤åˆ†é…
    group.bench_function("plus_operator", |b| {
        b.iter(|| {
            let mut result = String::new();
            for s in &strings {
                result = result + s;  // æ¯æ¬¡åˆ†é…æ–°å†…å­˜
            }
            result
        });
    });

    // âœ… è¾ƒå¥½ï¼špush_str
    group.bench_function("push_str", |b| {
        b.iter(|| {
            let mut result = String::new();
            for s in &strings {
                result.push_str(s);
            }
            result
        });
    });

    // âœ… æœ€å¥½ï¼šé¢„åˆ†é… + push_str
    group.bench_function("with_capacity", |b| {
        b.iter(|| {
            let capacity = strings.iter().map(|s| s.len()).sum();
            let mut result = String::with_capacity(capacity);
            for s in &strings {
                result.push_str(s);
            }
            result
        });
    });

    // âœ… æœ€ä½³ï¼šä½¿ç”¨ join
    group.bench_function("join", |b| {
        b.iter(|| strings.join(""));
    });

    group.finish();
}

// æ€§èƒ½æ¯”è¾ƒ:
// plus_operator: 100ms
// push_str: 10ms
// with_capacity: 5ms
// join: 5ms
```

---

## 6. å¹¶å‘æ€§èƒ½ä¼˜åŒ–

### 6.1 é”ç«äº‰ä¼˜åŒ–

#### å‡å°‘é”æŒæœ‰æ—¶é—´

```rust
use std::sync::{Arc, Mutex};

// âŒ é”æŒæœ‰æ—¶é—´è¿‡é•¿
fn bad_locking(data: Arc<Mutex<Vec<i32>>>, value: i32) {
    let mut data = data.lock().unwrap();
    // åœ¨é”å†…è¿›è¡Œæ˜‚è´µè®¡ç®—
    let processed = expensive_computation(value);
    data.push(processed);
}

// âœ… æœ€å°åŒ–é”èŒƒå›´
fn good_locking(data: Arc<Mutex<Vec<i32>>>, value: i32) {
    // åœ¨é”å¤–è¿›è¡Œæ˜‚è´µè®¡ç®—
    let processed = expensive_computation(value);

    // åªåœ¨å¿…è¦æ—¶æŒæœ‰é”
    let mut data = data.lock().unwrap();
    data.push(processed);
}
```

#### åˆ†ç‰‡é”

```rust
use std::sync::Mutex;

// âŒ å•ä¸ªé”ï¼ˆé«˜ç«äº‰ï¼‰
struct BadCache {
    data: Mutex<HashMap<String, String>>,
}

// âœ… åˆ†ç‰‡é”ï¼ˆä½ç«äº‰ï¼‰
const SHARDS: usize = 16;

struct GoodCache {
    shards: [Mutex<HashMap<String, String>>; SHARDS],
}

impl GoodCache {
    fn new() -> Self {
        Self {
            shards: std::array::from_fn(|_| Mutex::new(HashMap::new())),
        }
    }

    fn get(&self, key: &str) -> Option<String> {
        let shard_idx = self.hash(key) % SHARDS;
        self.shards[shard_idx].lock().unwrap().get(key).cloned()
    }

    fn insert(&self, key: String, value: String) {
        let shard_idx = self.hash(&key) % SHARDS;
        self.shards[shard_idx].lock().unwrap().insert(key, value);
    }

    fn hash(&self, key: &str) -> usize {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        hasher.finish() as usize
    }
}
```

### 6.2 æ— é”æ•°æ®ç»“æ„

#### åŸå­æ“ä½œ

```rust
use std::sync::atomic::{AtomicU64, Ordering};

// âœ… æ— é”è®¡æ•°å™¨
struct LockFreeCounter {
    count: AtomicU64,
}

impl LockFreeCounter {
    fn new() -> Self {
        Self { count: AtomicU64::new(0) }
    }

    fn increment(&self) -> u64 {
        self.count.fetch_add(1, Ordering::SeqCst)
    }

    fn get(&self) -> u64 {
        self.count.load(Ordering::SeqCst)
    }
}

// æ¯” Mutex<u64> å¿« 10-100x
```

#### æ— é”é˜Ÿåˆ—

```rust
use crossbeam::queue::SegQueue;

// âœ… æ— é”å¹¶å‘é˜Ÿåˆ—
fn lockfree_queue_example() {
    let queue = Arc::new(SegQueue::new());

    // å¤šä¸ªç”Ÿäº§è€…
    let mut producers = vec![];
    for i in 0..4 {
        let queue = Arc::clone(&queue);
        producers.push(thread::spawn(move || {
            for j in 0..1000 {
                queue.push(i * 1000 + j);
            }
        }));
    }

    // å¤šä¸ªæ¶ˆè´¹è€…
    let mut consumers = vec![];
    for _ in 0..4 {
        let queue = Arc::clone(&queue);
        consumers.push(thread::spawn(move || {
            while let Some(item) = queue.pop() {
                // å¤„ç†
            }
        }));
    }

    for p in producers { p.join().unwrap(); }
    for c in consumers { c.join().unwrap(); }
}
```

### 6.3 å¹¶è¡Œè¿­ä»£å™¨

#### Rayon å¹¶è¡ŒåŒ–

```rust
use rayon::prelude::*;

// âœ… ç®€å•å¹¶è¡ŒåŒ–
fn parallel_example() {
    let data: Vec<i32> = (0..1_000_000).collect();

    // å¹¶è¡Œ map-reduce
    let sum: i32 = data.par_iter()
        .map(|&x| expensive_computation(x))
        .sum();

    // å¹¶è¡Œ filter-map
    let results: Vec<_> = data.par_iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2)
        .collect();

    // å¹¶è¡Œæ’åº
    let mut data = data;
    data.par_sort_unstable();
}

// æ€§èƒ½æå‡: é€šå¸¸æ˜¯æ ¸å¿ƒæ•°çš„ 70-90%
```

---

## 7. å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹

### 7.1 JSON è§£æä¼˜åŒ–

```rust
use serde_json::Value;

// âŒ å¤šæ¬¡è§£æ
fn bad_json_processing(json_str: &str) -> Result<(), Box<dyn std::error::Error>> {
    for _ in 0..1000 {
        let value: Value = serde_json::from_str(json_str)?;
        // å¤„ç†
    }
    Ok(())
}

// âœ… ä½¿ç”¨é›¶æ‹·è´è§£æ
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize)]
struct Data<'a> {
    #[serde(borrow)]
    name: &'a str,
    value: i32,
}

fn good_json_processing(json_str: &str) -> Result<(), Box<dyn std::error::Error>> {
    let data: Data = serde_json::from_str(json_str)?;
    // data.name é›¶æ‹·è´å¼•ç”¨åŸå§‹å­—ç¬¦ä¸²
    Ok(())
}

// âœ… ä½¿ç”¨ simd-json (æ›´å¿«)
// use simd_json;
```

### 7.2 HTTP æœåŠ¡å™¨ä¼˜åŒ–

```rust
// ä½¿ç”¨ Tokio å¼‚æ­¥è¿è¡Œæ—¶ä¼˜åŒ–

// âŒ é˜»å¡ I/O
fn sync_handler(request: Request) -> Response {
    let data = std::fs::read_to_string("file.txt").unwrap();
    Response::new(data)
}

// âœ… å¼‚æ­¥ I/O
async fn async_handler(request: Request) -> Response {
    let data = tokio::fs::read_to_string("file.txt").await.unwrap();
    Response::new(data)
}

// âœ… è¿æ¥æ± 
use deadpool_postgres::{Manager, Pool};

async fn with_connection_pool(pool: &Pool, query: &str) -> Result<(), Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let rows = client.query(query, &[]).await?;
    Ok(())
}
```

### 7.3 æ•°æ®å¤„ç†ç®¡é“ä¼˜åŒ–

```rust
// âœ… æ‰¹å¤„ç†ä¼˜åŒ–
fn process_in_batches(data: Vec<Item>) -> Vec<ProcessedItem> {
    const BATCH_SIZE: usize = 1000;

    data.chunks(BATCH_SIZE)
        .flat_map(|batch| process_batch(batch))
        .collect()
}

// âœ… æµå¼å¤„ç†é¿å…å†…å­˜å³°å€¼
use futures::stream::{self, StreamExt};

async fn streaming_processing() {
    let stream = stream::iter(0..1_000_000)
        .map(|x| async move { expensive_async_computation(x).await })
        .buffer_unordered(100);  // å¹¶å‘é™åˆ¶

    stream.for_each(|result| async {
        // å¤„ç†ç»“æœ
    }).await;
}
```

---

## ç›¸å…³èµ„æº

### ğŸ“– æ ¸å¿ƒæ–‡æ¡£

- **[æ€§èƒ½ä¼˜åŒ–å®è·µ](../04_safety/03_performance_optimization.md)**: æ·±å…¥çš„æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- **[é›¶æˆæœ¬æŠ½è±¡](./3.2_é›¶æˆæœ¬æŠ½è±¡.md)**: ç†è§£é›¶æˆæœ¬æŠ½è±¡åŸç†
- **[é«˜çº§æ‰€æœ‰æƒæ¨¡å¼](./06_é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ.md)**: æ‰€æœ‰æƒç³»ç»Ÿçš„é«˜çº§ç”¨æ³•

### ğŸ”— ç›¸å…³ä¸»é¢˜

- **Tier 3 é«˜çº§ä¸»é¢˜**
  - [06 é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ](./06_é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å‚è€ƒ.md)
  - [3.2 é›¶æˆæœ¬æŠ½è±¡](./3.2_é›¶æˆæœ¬æŠ½è±¡.md)
  - [3.3 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ](./3.3_å†…å­˜å®‰å…¨æœ€ä½³å®è·µ.md)

- **Tier 4 ç†è®ºæ·±åº¦**
  - [4.1 ç±»å‹ç³»ç»Ÿç†è®º](../tier4_theoretical/4.1_ç±»å‹ç³»ç»Ÿç†è®º.md)

### ğŸ› ï¸ å·¥å…·å’Œèµ„æº

**æ€§èƒ½å·¥å…·**:

- `criterion` - åŸºå‡†æµ‹è¯•æ¡†æ¶
- `flamegraph` - ç«ç„°å›¾ç”Ÿæˆ
- `perf` - Linux æ€§èƒ½åˆ†æ
- `cargo-asm` - æ±‡ç¼–ä»£ç æŸ¥çœ‹
- `cargo-bloat` - äºŒè¿›åˆ¶å¤§å°åˆ†æ
- `heaptrack` - å†…å­˜å‰–æ

**Crates**:

- `rayon` - å¹¶è¡Œè¿­ä»£å™¨
- `crossbeam` - å¹¶å‘åŸè¯­
- `parking_lot` - æ›´å¿«çš„é”
- `smallvec` - æ ˆä¼˜åŒ– Vec
- `ahash` - æ›´å¿«çš„å“ˆå¸Œå‡½æ•°

**å­¦ä¹ èµ„æº**:

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Benchmarking and Optimization](https://doc.rust-lang.org/book/ch14-04-performance.html)
- [Optimizing Rust](https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1)

### ğŸ“š å­¦ä¹ è·¯å¾„

**è¿›é˜¶è·¯å¾„**:

1. å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ ï¼ˆé¢„ä¼° 8-12 å°æ—¶ï¼‰
2. ä¸ºè‡ªå·±çš„é¡¹ç›®è®¾ç½®æ€§èƒ½åŸºå‡†
3. ä½¿ç”¨ç«ç„°å›¾è¯†åˆ«ç“¶é¢ˆ
4. åº”ç”¨ä¼˜åŒ–æŠ€å·§å¹¶æµ‹é‡æ•ˆæœ
5. ç ”ç©¶é«˜æ€§èƒ½ Rust é¡¹ç›®æºç 

**å®è·µå»ºè®®**:

- ğŸ”¨ ä¸ºå…³é”®å‡½æ•°ç¼–å†™åŸºå‡†æµ‹è¯•
- ğŸ”¨ ä½¿ç”¨ flamegraph åˆ†æå®é™…åº”ç”¨
- ğŸ”¨ ä¼˜åŒ–ä¸€ä¸ªå®é™…é¡¹ç›®çš„æ€§èƒ½ç“¶é¢ˆ
- ğŸ”¨ å¯¹æ¯”ä¸åŒå®ç°çš„æ€§èƒ½
- ğŸ”¨ å­¦ä¹ ä½¿ç”¨ perf/Instruments

### ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ä»¥éªŒè¯å­¦ä¹ æ•ˆæœ:

- [ ] æŒæ¡ä½¿ç”¨ Criterion è¿›è¡ŒåŸºå‡†æµ‹è¯•
- [ ] èƒ½å¤Ÿä½¿ç”¨ flamegraph åˆ†ææ€§èƒ½
- [ ] ç†è§£æ‰€æœ‰æƒç³»ç»Ÿçš„æ€§èƒ½ç‰¹æ€§
- [ ] ä¼˜åŒ–å†…å­˜å¸ƒå±€å’Œåˆ†é…ç­–ç•¥
- [ ] åˆç†ä½¿ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–é€‰é¡¹
- [ ] é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„å’Œç®—æ³•
- [ ] å®ç°é«˜æ€§èƒ½å¹¶å‘ä»£ç 
- [ ] å®Œæˆè‡³å°‘ä¸€ä¸ªå®é™…é¡¹ç›®çš„æ€§èƒ½ä¼˜åŒ–

---

**æœ€åæ›´æ–°**: 2026-01-26
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0 (æ‰©å±•ç‰ˆ)
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.92.0+
**é¢„ä¼°å­¦ä¹ æ—¶é—´**: 8-12 å°æ—¶
**éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

END OF DOCUMENT
