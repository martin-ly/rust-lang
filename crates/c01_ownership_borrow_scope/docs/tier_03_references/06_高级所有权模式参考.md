# 3.1 é«˜çº§æ‰€æœ‰æƒæ¨¡å¼

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.90+  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç±»å‹**: Tier 3 é«˜çº§å®è·µæŒ‡å—

---

## ğŸ“‹ ç›®å½•

- [3.1 é«˜çº§æ‰€æœ‰æƒæ¨¡å¼](#31-é«˜çº§æ‰€æœ‰æƒæ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è§ˆ](#æ–‡æ¡£æ¦‚è§ˆ)
    - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
    - [ğŸ“š å‰ç½®çŸ¥è¯†](#-å‰ç½®çŸ¥è¯†)
    - [ğŸ¨ æ–‡æ¡£ç‰¹è‰²](#-æ–‡æ¡£ç‰¹è‰²)
    - [ğŸ“– æ ¸å¿ƒå†…å®¹](#-æ ¸å¿ƒå†…å®¹)
  - [1. å†…éƒ¨å¯å˜æ€§æ¨¡å¼](#1-å†…éƒ¨å¯å˜æ€§æ¨¡å¼)
    - [æ¦‚å¿µå¯¼èˆª](#æ¦‚å¿µå¯¼èˆª)
    - [1.1 RefCell æ·±åº¦è§£æ](#11-refcell-æ·±åº¦è§£æ)
      - [æ ¸å¿ƒåŸç†](#æ ¸å¿ƒåŸç†)
      - [ä½¿ç”¨åœºæ™¯](#ä½¿ç”¨åœºæ™¯)
      - [å¸¸è§é™·é˜± âš ï¸](#å¸¸è§é™·é˜±-ï¸)
      - [æœ€ä½³å®è·µ âœ…](#æœ€ä½³å®è·µ-)
    - [1.2 Cell ä½¿ç”¨åœºæ™¯](#12-cell-ä½¿ç”¨åœºæ™¯)
      - [æ ¸å¿ƒç‰¹ç‚¹](#æ ¸å¿ƒç‰¹ç‚¹)
      - [é€‚ç”¨åœºæ™¯](#é€‚ç”¨åœºæ™¯)
      - [Cell vs RefCell å¯¹æ¯”](#cell-vs-refcell-å¯¹æ¯”)
    - [1.3 å¹¶å‘å†…éƒ¨å¯å˜æ€§](#13-å¹¶å‘å†…éƒ¨å¯å˜æ€§)
      - [`Mutex<T>` - äº’æ–¥é”](#mutext---äº’æ–¥é”)
      - [`RwLock<T>` - è¯»å†™é”](#rwlockt---è¯»å†™é”)
      - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
    - [1.4 é€‰æ‹©æŒ‡å—](#14-é€‰æ‹©æŒ‡å—)
      - [å†³ç­–æµç¨‹å›¾](#å†³ç­–æµç¨‹å›¾)
      - [é€‰æ‹©çŸ©é˜µ](#é€‰æ‹©çŸ©é˜µ)
      - [å®ä¾‹å¯¹æ¯”](#å®ä¾‹å¯¹æ¯”)
  - [2. æ™ºèƒ½æŒ‡é’ˆé«˜çº§ç”¨æ³•](#2-æ™ºèƒ½æŒ‡é’ˆé«˜çº§ç”¨æ³•)
    - [2.1 Box ä¼˜åŒ–æŠ€å·§](#21-box-ä¼˜åŒ–æŠ€å·§)
      - [åŸºæœ¬ç”¨æ³•](#åŸºæœ¬ç”¨æ³•)
      - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
      - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
    - [2.2 Rc å¼•ç”¨è®¡æ•°æ¨¡å¼](#22-rc-å¼•ç”¨è®¡æ•°æ¨¡å¼)
      - [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
      - [é«˜çº§æ¨¡å¼](#é«˜çº§æ¨¡å¼)
      - [æ€§èƒ½è€ƒè™‘](#æ€§èƒ½è€ƒè™‘)
    - [2.3 Arc è·¨çº¿ç¨‹å…±äº«](#23-arc-è·¨çº¿ç¨‹å…±äº«)
      - [åŸºæœ¬ä½¿ç”¨](#åŸºæœ¬ä½¿ç”¨)
      - [ä¸ Mutex é…åˆ](#ä¸-mutex-é…åˆ)
      - [Rc vs Arc å¯¹æ¯”](#rc-vs-arc-å¯¹æ¯”)
    - [2.4 Weak å¼±å¼•ç”¨](#24-weak-å¼±å¼•ç”¨)
      - [è§£å†³å¾ªç¯å¼•ç”¨](#è§£å†³å¾ªç¯å¼•ç”¨)
      - [ç¼“å­˜æ¨¡å¼](#ç¼“å­˜æ¨¡å¼)
      - [è§‚å¯Ÿè€…æ¨¡å¼](#è§‚å¯Ÿè€…æ¨¡å¼)
  - [3. å¤æ‚æ‰€æœ‰æƒè®¾è®¡](#3-å¤æ‚æ‰€æœ‰æƒè®¾è®¡)
    - [3.1 è‡ªå¼•ç”¨ç»“æ„](#31-è‡ªå¼•ç”¨ç»“æ„)
      - [é—®é¢˜æè¿°](#é—®é¢˜æè¿°)
      - [è§£å†³æ–¹æ¡ˆ 1: Pin + Unsafe](#è§£å†³æ–¹æ¡ˆ-1-pin--unsafe)
      - [è§£å†³æ–¹æ¡ˆ 2: ä½¿ç”¨ç´¢å¼•](#è§£å†³æ–¹æ¡ˆ-2-ä½¿ç”¨ç´¢å¼•)
      - [è§£å†³æ–¹æ¡ˆ 3: Rental/Ouroboros Crate](#è§£å†³æ–¹æ¡ˆ-3-rentalouroboros-crate)
    - [3.2 æ ‘å’Œå›¾ç»“æ„](#32-æ ‘å’Œå›¾ç»“æ„)
      - [æ ‘ç»“æ„å®ç°](#æ ‘ç»“æ„å®ç°)
      - [å›¾ç»“æ„å®ç°](#å›¾ç»“æ„å®ç°)
    - [3.3 è§‚å¯Ÿè€…æ¨¡å¼](#33-è§‚å¯Ÿè€…æ¨¡å¼)
    - [3.4 çŠ¶æ€æœºè®¾è®¡](#34-çŠ¶æ€æœºè®¾è®¡)
  - [4. å®æˆ˜æ¡ˆä¾‹](#4-å®æˆ˜æ¡ˆä¾‹)
    - [4.1 Web æœåŠ¡å™¨è®¾è®¡](#41-web-æœåŠ¡å™¨è®¾è®¡)
    - [4.2 æ•°æ®åº“è¿æ¥æ± ](#42-æ•°æ®åº“è¿æ¥æ± )
    - [4.3 ç¼“å­˜ç³»ç»Ÿ](#43-ç¼“å­˜ç³»ç»Ÿ)
    - [4.4 æ’ä»¶æ¶æ„](#44-æ’ä»¶æ¶æ„)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
    - [ğŸ“– æ ¸å¿ƒæ–‡æ¡£](#-æ ¸å¿ƒæ–‡æ¡£)
    - [ğŸ”— ç›¸å…³ä¸»é¢˜](#-ç›¸å…³ä¸»é¢˜)
    - [ğŸ“š å­¦ä¹ è·¯å¾„](#-å­¦ä¹ è·¯å¾„)
    - [ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•](#-å­¦ä¹ æ£€æŸ¥æ¸…å•)

---

## æ–‡æ¡£æ¦‚è§ˆ

### ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ å°†èƒ½å¤Ÿ:

- âœ… æ·±å…¥ç†è§£ Rust çš„å†…éƒ¨å¯å˜æ€§æ¨¡å¼åŠå…¶ä½¿ç”¨åœºæ™¯
- âœ… ç†Ÿç»ƒè¿ç”¨å„ç§æ™ºèƒ½æŒ‡é’ˆè§£å†³å¤æ‚çš„æ‰€æœ‰æƒé—®é¢˜
- âœ… è®¾è®¡å’Œå®ç°å¤æ‚çš„æ‰€æœ‰æƒç»“æ„ï¼ˆæ ‘ã€å›¾ã€è‡ªå¼•ç”¨ï¼‰
- âœ… åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨é«˜çº§æ‰€æœ‰æƒæ¨¡å¼
- âœ… è¯†åˆ«å’Œè§£å†³å¸¸è§çš„æ‰€æœ‰æƒè®¾è®¡é—®é¢˜
- âœ… åœ¨å®‰å…¨æ€§ã€æ€§èƒ½å’Œå¯ç”¨æ€§ä¹‹é—´åšå‡ºåˆç†æƒè¡¡

### ğŸ“š å‰ç½®çŸ¥è¯†

å­¦ä¹ æœ¬æ–‡æ¡£å‰ï¼Œä½ éœ€è¦:

- âœ… æŒæ¡åŸºæœ¬çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸæ¦‚å¿µ
- âœ… ç†Ÿæ‚‰ Rust çš„åŸºæœ¬æ•°æ®ç±»å‹å’Œæ§åˆ¶æµ
- âœ… äº†è§£ Trait å’Œæ³›å‹çš„åŸºç¡€çŸ¥è¯†
- âœ… æœ‰ä¸€å®šçš„ Rust ç¼–ç¨‹å®è·µç»éªŒ

**æ¨èå…ˆå­¦ä¹ **: [Tier 2 æ ¸å¿ƒæ¦‚å¿µ](../tier2_core_concepts/README.md)

### ğŸ¨ æ–‡æ¡£ç‰¹è‰²

æœ¬æ–‡æ¡£æä¾›:

- ğŸ“– **æ·±åº¦è§£æ**: æ·±å…¥è®²è§£æ¯ç§æ¨¡å¼çš„åŸç†å’Œå®ç°
- ğŸ’¡ **å®è·µæŒ‡å—**: æä¾›ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹å’Œå®æˆ˜æ¡ˆä¾‹
- âš ï¸ **å¸¸è§é™·é˜±**: æ ‡æ³¨æ˜“é”™ç‚¹å’Œæœ€ä½³å®è·µ
- ğŸ”— **çŸ¥è¯†å…³è”**: å»ºç«‹æ¦‚å¿µä¹‹é—´çš„è”ç³»
- ğŸ† **æ€§èƒ½ä¼˜åŒ–**: è®¨è®ºä¸åŒæ–¹æ¡ˆçš„æ€§èƒ½å½±å“

### ğŸ“– æ ¸å¿ƒå†…å®¹

**[ğŸ“– é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å®Œæ•´æ–‡æ¡£](../03_advanced/01_advanced_ownership.md)**

æœ¬æ–‡æ¡£æ˜¯å¯¹å®Œæ•´æ–‡æ¡£çš„æ·±åº¦è§£è¯»å’Œå®è·µæŒ‡å—ï¼ŒåŒ…å«æ›´å¤šçš„å®æˆ˜ç»éªŒå’Œè®¾è®¡å»ºè®®ã€‚

---

## 1. å†…éƒ¨å¯å˜æ€§æ¨¡å¼

### æ¦‚å¿µå¯¼èˆª

**å†…éƒ¨å¯å˜æ€§ (Interior Mutability)** æ˜¯ Rust ä¸­ä¸€ä¸ªå¼ºå¤§ä½†éœ€è¦è°¨æ…ä½¿ç”¨çš„æ¨¡å¼ã€‚å®ƒå…è®¸ä½ åœ¨æ‹¥æœ‰ä¸å¯å˜å¼•ç”¨çš„æƒ…å†µä¸‹ä¿®æ”¹æ•°æ®ï¼Œé€šè¿‡å°†å€Ÿç”¨æ£€æŸ¥ä»ç¼–è¯‘æ—¶ç§»åˆ°è¿è¡Œæ—¶å®ç°ã€‚

### 1.1 RefCell æ·±åº¦è§£æ

#### æ ¸å¿ƒåŸç†

`RefCell<T>` æä¾›äº†è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥æœºåˆ¶:

- **ç¼–è¯‘æ—¶**: æ­£å¸¸çš„å€Ÿç”¨è§„åˆ™åœ¨ç¼–è¯‘æ—¶æ— æ³•éªŒè¯
- **è¿è¡Œæ—¶**: é€šè¿‡ `borrow()` å’Œ `borrow_mut()` åœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™
- **panic**: è¿åå€Ÿç”¨è§„åˆ™ä¼šå¯¼è‡´è¿è¡Œæ—¶ panic

#### ä½¿ç”¨åœºæ™¯

âœ… **é€‚åˆä½¿ç”¨ RefCell çš„åœºæ™¯**:

1. **å½“ä½ ç¡®ä¿¡ä»£ç éµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œä½†ç¼–è¯‘å™¨æ— æ³•è¯æ˜æ—¶**

   ```rust
   use std::cell::RefCell;
   
   struct Graph {
       nodes: Vec<RefCell<Node>>,
   }
   
   struct Node {
       edges: Vec<usize>,  // å­˜å‚¨èŠ‚ç‚¹ç´¢å¼•
       data: String,
   }
   
   impl Graph {
       fn update_node(&self, index: usize, new_data: String) {
           // å³ä½¿ self æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œä¹Ÿå¯ä»¥ä¿®æ”¹èŠ‚ç‚¹
           self.nodes[index].borrow_mut().data = new_data;
       }
   }
   ```

2. **å®ç°å¤æ‚çš„å†…éƒ¨çŠ¶æ€ç®¡ç†**

   ```rust
   use std::cell::RefCell;
   
   struct Counter {
       // å³ä½¿ Counter æœ¬èº«ä¸å¯å˜ï¼Œä¹Ÿèƒ½ä¿®æ”¹è®¡æ•°
       count: RefCell<u32>,
   }
   
   impl Counter {
       fn new() -> Self {
           Self { count: RefCell::new(0) }
       }
       
       // æ³¨æ„ï¼šè¿™é‡Œæ˜¯ &selfï¼Œä¸æ˜¯ &mut self
       fn increment(&self) {
           *self.count.borrow_mut() += 1;
       }
       
       fn get(&self) -> u32 {
           *self.count.borrow()
       }
   }
   
   fn main() {
       let counter = Counter::new();  // ä¸å¯å˜ç»‘å®š
       counter.increment();  // ä½†å¯ä»¥ä¿®æ”¹å†…éƒ¨çŠ¶æ€
       counter.increment();
       assert_eq!(counter.get(), 2);
   }
   ```

3. **ä¸ Rc é…åˆå®ç°å…±äº«å¯å˜çŠ¶æ€**

   ```rust
   use std::rc::Rc;
   use std::cell::RefCell;
   
   type SharedMutData = Rc<RefCell<Vec<i32>>>;
   
   fn share_and_modify() {
       let data: SharedMutData = Rc::new(RefCell::new(vec![1, 2, 3]));
       let data_clone = Rc::clone(&data);
       
       // é€šè¿‡ç¬¬ä¸€ä¸ªå¼•ç”¨ä¿®æ”¹
       data.borrow_mut().push(4);
       
       // é€šè¿‡ç¬¬äºŒä¸ªå¼•ç”¨è®¿é—®ä¿®æ”¹åçš„æ•°æ®
       assert_eq!(*data_clone.borrow(), vec![1, 2, 3, 4]);
   }
   ```

#### å¸¸è§é™·é˜± âš ï¸

1. **è¿è¡Œæ—¶ panic**

   ```rust
   use std::cell::RefCell;
   
   let data = RefCell::new(5);
   
   let borrow1 = data.borrow_mut();  // å¯å˜å€Ÿç”¨
   // let borrow2 = data.borrow();    // âŒ PANIC! åŒæ—¶å­˜åœ¨å¯å˜å€Ÿç”¨
   // let borrow3 = data.borrow_mut(); // âŒ PANIC! åŒæ—¶å­˜åœ¨å¤šä¸ªå¯å˜å€Ÿç”¨
   ```

2. **å¿˜è®°é‡Šæ”¾å€Ÿç”¨**

   ```rust
   use std::cell::RefCell;
   
   fn problematic_code(data: &RefCell<Vec<i32>>) {
       let mut borrowed = data.borrow_mut();
       borrowed.push(1);
       
       // âŒ borrowed åœ¨å‡½æ•°ç»“æŸå‰ä¸€ç›´æŒæœ‰å¯å˜å€Ÿç”¨
       // è¿™ä¼šé˜»æ­¢å…¶ä»–ä»£ç è®¿é—® data
       
       // âœ… æ­£ç¡®åšæ³•ï¼šæ˜¾å¼ drop
       // drop(borrowed);
       // æˆ–è€…ä½¿ç”¨ä»£ç å—é™åˆ¶å€Ÿç”¨çš„ç”Ÿå‘½å‘¨æœŸ
   }
   ```

3. **å¾ªç¯å€Ÿç”¨å¯¼è‡´æ­»é”**

   ```rust
   use std::rc::Rc;
   use std::cell::RefCell;
   
   struct Node {
       value: i32,
       next: Option<Rc<RefCell<Node>>>,
   }
   
   // âš ï¸ å°å¿ƒï¼šè¿™ç§æ¨¡å¼å¯èƒ½å¯¼è‡´éš¾ä»¥è¿½è¸ªçš„å€Ÿç”¨å†²çª
   fn iterate_and_modify(head: Rc<RefCell<Node>>) {
       let mut current = Some(Rc::clone(&head));
       while let Some(node) = current {
           let borrowed = node.borrow();  // å€Ÿç”¨å½“å‰èŠ‚ç‚¹
           // let mut borrowed_mut = node.borrow_mut();  // âŒ ä¼š panic
           current = borrowed.next.as_ref().map(Rc::clone);
       }
   }
   ```

#### æœ€ä½³å®è·µ âœ…

1. **é™åˆ¶å€Ÿç”¨çš„ä½œç”¨åŸŸ**

   ```rust
   use std::cell::RefCell;
   
   let data = RefCell::new(vec![1, 2, 3]);
   
   // âœ… ä½¿ç”¨ä»£ç å—é™åˆ¶å€Ÿç”¨èŒƒå›´
   {
       let mut borrowed = data.borrow_mut();
       borrowed.push(4);
   }  // borrowed åœ¨è¿™é‡Œè¢« drop
   
   // ç°åœ¨å¯ä»¥å®‰å…¨åœ°å†æ¬¡å€Ÿç”¨
   let read_borrow = data.borrow();
   ```

2. **ä½¿ç”¨ try_borrow é¿å… panic**

   ```rust
   use std::cell::RefCell;
   
   let data = RefCell::new(5);
   
   match data.try_borrow_mut() {
       Ok(mut value) => {
           *value += 1;
           println!("Updated: {}", *value);
       }
       Err(_) => {
           eprintln!("Cannot borrow: already borrowed");
       }
   }
   ```

3. **æ¸…æ™°çš„æ–‡æ¡£è¯´æ˜**

   ```rust
   use std::cell::RefCell;
   
   /// æ•°æ®å®¹å™¨ï¼Œæ”¯æŒå†…éƒ¨å¯å˜æ€§
   /// 
   /// # Panics
   /// 
   /// - `get_mut()` åœ¨å·²æœ‰ä»»ä½•å€Ÿç”¨æ—¶ä¼š panic
   /// - `get()` åœ¨å·²æœ‰å¯å˜å€Ÿç”¨æ—¶ä¼š panic
   /// 
   /// # Examples
   /// 
   /// ```
   /// let container = Container::new(42);
   /// container.set(100);
   /// assert_eq!(container.get(), 100);
   /// ```
   struct Container {
       data: RefCell<i32>,
   }
   
   impl Container {
       fn new(value: i32) -> Self {
           Self { data: RefCell::new(value) }
       }
       
       fn get(&self) -> i32 {
           *self.data.borrow()
       }
       
       fn set(&self, value: i32) {
           *self.data.borrow_mut() = value;
       }
   }
   ```

### 1.2 Cell ä½¿ç”¨åœºæ™¯

#### æ ¸å¿ƒç‰¹ç‚¹

`Cell<T>` æ˜¯ `RefCell<T>` çš„ç®€åŒ–ç‰ˆæœ¬:

- âœ… **é›¶å¼€é”€**: æ²¡æœ‰è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥
- âœ… **ç®€å•**: åªèƒ½é€šè¿‡å€¼è®¿é—®ï¼ˆget/setï¼‰
- âš ï¸ **é™åˆ¶**: åªé€‚ç”¨äº `Copy` ç±»å‹

#### é€‚ç”¨åœºæ™¯

1. **ç®€å•å€¼ç±»å‹çš„ç¼“å­˜**

   ```rust
   use std::cell::Cell;
   
   struct CachedCalculation {
       input: u32,
       cache: Cell<Option<u32>>,
   }
   
   impl CachedCalculation {
       fn new(input: u32) -> Self {
           Self {
               input,
               cache: Cell::new(None),
           }
       }
       
       fn calculate(&self) -> u32 {
           if let Some(cached) = self.cache.get() {
               return cached;
           }
           
           // æ˜‚è´µçš„è®¡ç®—
           let result = self.input * self.input;
           self.cache.set(Some(result));
           result
       }
   }
   ```

2. **æ€§èƒ½è®¡æ•°å™¨**

   ```rust
   use std::cell::Cell;
   
   struct PerformanceTracker {
       request_count: Cell<u64>,
       error_count: Cell<u64>,
   }
   
   impl PerformanceTracker {
       fn new() -> Self {
           Self {
               request_count: Cell::new(0),
               error_count: Cell::new(0),
           }
       }
       
       fn record_request(&self) {
           self.request_count.set(self.request_count.get() + 1);
       }
       
       fn record_error(&self) {
           self.error_count.set(self.error_count.get() + 1);
       }
       
       fn error_rate(&self) -> f64 {
           let requests = self.request_count.get() as f64;
           let errors = self.error_count.get() as f64;
           if requests == 0.0 { 0.0 } else { errors / requests }
       }
   }
   ```

3. **æ ‡å¿—ä½å’ŒçŠ¶æ€**

   ```rust
   use std::cell::Cell;
   
   struct Connection {
       is_open: Cell<bool>,
       retry_count: Cell<u32>,
   }
   
   impl Connection {
       fn new() -> Self {
           Self {
               is_open: Cell::new(false),
               retry_count: Cell::new(0),
           }
       }
       
       fn connect(&self) -> Result<(), String> {
           if self.is_open.get() {
               return Ok(());
           }
           
           // å°è¯•è¿æ¥...
           self.retry_count.set(self.retry_count.get() + 1);
           self.is_open.set(true);
           Ok(())
       }
       
       fn disconnect(&self) {
           self.is_open.set(false);
       }
   }
   ```

#### Cell vs RefCell å¯¹æ¯”

| ç‰¹æ€§ | `Cell<T>` | `RefCell<T>` |
|------|---------|------------|
| **ç±»å‹è¦æ±‚** | T: Copy | ä»»ä½•ç±»å‹ |
| **è®¿é—®æ–¹å¼** | get()/set() å€¼è®¿é—® | borrow()/borrow_mut() å¼•ç”¨è®¿é—® |
| **è¿è¡Œæ—¶å¼€é”€** | âŒ æ—  | âœ… æœ‰ï¼ˆå€Ÿç”¨æ£€æŸ¥ï¼‰ |
| **panic é£é™©** | âŒ ä¸ä¼š | âœ… å¯èƒ½ï¼ˆå€Ÿç”¨å†²çªï¼‰ |
| **æ€§èƒ½** | ğŸ† æœ€ä¼˜ | âš ï¸ ç•¥æœ‰å¼€é”€ |
| **é€‚ç”¨åœºæ™¯** | ç®€å•å€¼ç±»å‹ | å¤æ‚ç±»å‹å’Œå¼•ç”¨ |

### 1.3 å¹¶å‘å†…éƒ¨å¯å˜æ€§

#### `Mutex<T>` - äº’æ–¥é”

ç”¨äºè·¨çº¿ç¨‹çš„å†…éƒ¨å¯å˜æ€§:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

**å…³é”®ç‰¹ç‚¹**:

- âœ… çº¿ç¨‹å®‰å…¨ï¼ˆå®ç°äº† `Sync`ï¼‰
- âš ï¸ å¯èƒ½æ­»é”
- âš ï¸ æ€§èƒ½å¼€é”€ï¼ˆéœ€è¦æ“ä½œç³»ç»Ÿæ”¯æŒï¼‰

#### `RwLock<T>` - è¯»å†™é”

å…è®¸å¤šä¸ªè¯»å–è€…æˆ–ä¸€ä¸ªå†™å…¥è€…:

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // å¤šä¸ªè¯»å–çº¿ç¨‹
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data_clone.read().unwrap();
            println!("Thread {} read: {:?}", i, *data);
        });
        handles.push(handle);
    }
    
    // ä¸€ä¸ªå†™å…¥çº¿ç¨‹
    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut data = data_clone.write().unwrap();
        data.push(4);
        println!("Write complete");
    });
    handles.push(handle);
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… è¯»å¤šå†™å°‘çš„åœºæ™¯
- âœ… éœ€è¦ç»†ç²’åº¦å¹¶å‘æ§åˆ¶
- âš ï¸ å†™å…¥è€…å¯èƒ½é¥¥é¥¿

#### æ€§èƒ½å¯¹æ¯”

| ç±»å‹ | é€‚ç”¨çº¿ç¨‹ | æ€§èƒ½ | ç‰¹ç‚¹ |
|------|---------|------|------|
| **`Cell<T>`** | å•çº¿ç¨‹ | ğŸ†ğŸ†ğŸ† æœ€å¿« | é›¶å¼€é”€ï¼ŒCopy ç±»å‹ |
| **`RefCell<T>`** | å•çº¿ç¨‹ | ğŸ†ğŸ† å¾ˆå¿« | è¿è¡Œæ—¶æ£€æŸ¥ |
| **`Mutex<T>`** | å¤šçº¿ç¨‹ | âš ï¸ è¾ƒæ…¢ | æ“ä½œç³»ç»Ÿçº§é” |
| **`RwLock<T>`** | å¤šçº¿ç¨‹ | âš ï¸ è¾ƒæ…¢ | è¯»ä¼˜åŒ– |
| **Atomic*** | å¤šçº¿ç¨‹ | ğŸ†ğŸ† å¾ˆå¿« | åŸå­ç±»å‹ |

### 1.4 é€‰æ‹©æŒ‡å—

#### å†³ç­–æµç¨‹å›¾

```text
éœ€è¦å†…éƒ¨å¯å˜æ€§ï¼Ÿ
    â†“ æ˜¯
éœ€è¦è·¨çº¿ç¨‹å…±äº«ï¼Ÿ
    â†“ å¦                              â†“ æ˜¯
ç±»å‹æ˜¯ Copyï¼Ÿ                      æ˜¯å¦è¯»å¤šå†™å°‘ï¼Ÿ
    â†“ æ˜¯          â†“ å¦                  â†“ æ˜¯         â†“ å¦
ä½¿ç”¨ Cell<T>   ä½¿ç”¨ RefCell<T>       ä½¿ç”¨ RwLock<T>   ä½¿ç”¨ Mutex<T>
```

#### é€‰æ‹©çŸ©é˜µ

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | åŸå›  |
|------|---------|------|
| å•çº¿ç¨‹ + Copy ç±»å‹ | `Cell<T>` | é›¶å¼€é”€ |
| å•çº¿ç¨‹ + é Copy ç±»å‹ | `RefCell<T>` | çµæ´»æ€§ |
| å¤šçº¿ç¨‹ + é¢‘ç¹è¯»å– | `RwLock<T>` | è¯»å¹¶å‘ |
| å¤šçº¿ç¨‹ + é¢‘ç¹å†™å…¥ | `Mutex<T>` | ç®€å•å¯é  |
| å¤šçº¿ç¨‹ + åŸå­æ“ä½œ | `AtomicXxx` | æœ€é«˜æ€§èƒ½ |
| ä¸éœ€è¦å†…éƒ¨å¯å˜æ€§ | `&mut T` | ç¼–è¯‘æ—¶ä¿è¯ |

#### å®ä¾‹å¯¹æ¯”

```rust
use std::cell::{Cell, RefCell};
use std::sync::{Arc, Mutex, RwLock};
use std::thread;

// åœºæ™¯ 1ï¼šå•çº¿ç¨‹ç®€å•è®¡æ•° â†’ Cell
struct SimpleCounter {
    count: Cell<u32>,
}

// åœºæ™¯ 2ï¼šå•çº¿ç¨‹å¤æ‚æ•°æ® â†’ RefCell
struct ComplexData {
    items: RefCell<Vec<String>>,
}

// åœºæ™¯ 3ï¼šå¤šçº¿ç¨‹è®¡æ•° â†’ Arc<Mutex<T>>
fn multi_thread_counter() {
    let counter = Arc::new(Mutex::new(0));
    // ... ä½¿ç”¨ ...
}

// åœºæ™¯ 4ï¼šå¤šçº¿ç¨‹è¯»å¤šå†™å°‘ â†’ Arc<RwLock<T>>
fn cached_data() {
    let cache = Arc::new(RwLock::new(Vec::new()));
    // ... ä½¿ç”¨ ...
}
```

---

## 2. æ™ºèƒ½æŒ‡é’ˆé«˜çº§ç”¨æ³•

### 2.1 Box ä¼˜åŒ–æŠ€å·§

#### åŸºæœ¬ç”¨æ³•

`Box<T>` ç”¨äºå †åˆ†é…ï¼Œæœ‰å¤šç§é«˜çº§ç”¨æ³•:

```rust
// 1. é€’å½’ç±»å‹
enum List {
    Cons(i32, Box<List>),
    Nil,
}

// 2. å¤§å‹æ•°æ®
struct LargeStruct {
    data: [u8; 10000],
}

fn avoid_stack_overflow() {
    // âŒ æ ˆåˆ†é…ï¼Œå¯èƒ½æº¢å‡º
    // let large = LargeStruct { data: [0; 10000] };
    
    // âœ… å †åˆ†é…
    let large = Box::new(LargeStruct { data: [0; 10000] });
}

// 3. Trait å¯¹è±¡
trait Draw {
    fn draw(&self);
}

fn use_trait_object(drawable: Box<dyn Draw>) {
    drawable.draw();
}
```

#### æ€§èƒ½ä¼˜åŒ–

1. **ä½¿ç”¨ Box::leak åˆ›å»º 'static ç”Ÿå‘½å‘¨æœŸ**

   ```rust
   fn create_static_string(s: String) -> &'static str {
       Box::leak(s.into_boxed_str())
   }
   
   fn main() {
       let static_str = create_static_string("Hello".to_string());
       // static_str ç°åœ¨æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ
       // âš ï¸ æ³¨æ„ï¼šè¿™ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ï¼Œé™¤éæ˜¯æœ‰æ„ä¸ºä¹‹
   }
   ```

2. **Box::into_raw ç”¨äº FFI**

   ```rust
   use std::ffi::CString;
   
   #[no_mangle]
   pub extern "C" fn create_string() -> *mut libc::c_char {
       let s = CString::new("Hello from Rust").unwrap();
       Box::into_raw(Box::new(s)) as *mut libc::c_char
   }
   
   #[no_mangle]
   pub unsafe extern "C" fn free_string(ptr: *mut libc::c_char) {
       if !ptr.is_null() {
           // é‡æ–°è·å–æ‰€æœ‰æƒå¹¶è‡ªåŠ¨é‡Šæ”¾
           let _ = Box::from_raw(ptr);
       }
   }
   ```

3. **åŸåœ°åˆå§‹åŒ–ï¼ˆRust 1.90+ï¼‰**

   ```rust
   // å¯¹äºéå¸¸å¤§çš„ç»“æ„ï¼Œé¿å…æ ˆä¸Šä¸´æ—¶æ„é€ 
   fn create_large_array() -> Box<[u8; 1000000]> {
       // ç›´æ¥åœ¨å †ä¸Šåˆ†é…
       Box::new([0u8; 1000000])
   }
   ```

#### å¸¸è§é™·é˜±

```rust
// âŒ é”™è¯¯ï¼šä¸å¿…è¦çš„ Box
fn unnecessary_box(x: Box<i32>) -> Box<i32> {
    Box::new(*x + 1)  // è§£å¼•ç”¨ååˆè£…ç®±
}

// âœ… æ­£ç¡®ï¼šç›´æ¥æ“ä½œ
fn better(x: Box<i32>) -> Box<i32> {
    x  // å¦‚æœä¸éœ€è¦ä¿®æ”¹ï¼Œç›´æ¥è¿”å›
}

// âœ… æˆ–è€…é¿å…ä½¿ç”¨ Box
fn best(x: i32) -> i32 {
    x + 1
}
```

### 2.2 Rc å¼•ç”¨è®¡æ•°æ¨¡å¼

#### åŸºæœ¬æ¦‚å¿µ

`Rc<T>` (Reference Counted) å®ç°å…±äº«æ‰€æœ‰æƒ:

```rust
use std::rc::Rc;

fn rc_basic_example() {
    let data = Rc::new(vec![1, 2, 3]);
    
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data));  // 1
    
    let data2 = Rc::clone(&data);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data));  // 2
    
    let data3 = Rc::clone(&data);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data));  // 3
    
    drop(data2);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data));  // 2
}
```

#### é«˜çº§æ¨¡å¼

1. **Rc + RefCell å®ç°å…±äº«å¯å˜çŠ¶æ€**

   ```rust
   use std::rc::Rc;
   use std::cell::RefCell;
   
   #[derive(Debug)]
   struct Node {
       value: i32,
       children: RefCell<Vec<Rc<Node>>>,
   }
   
   impl Node {
       fn new(value: i32) -> Rc<Self> {
           Rc::new(Node {
               value,
               children: RefCell::new(vec![]),
           })
       }
       
       fn add_child(self: &Rc<Self>, child: Rc<Node>) {
           self.children.borrow_mut().push(child);
       }
   }
   
   fn tree_example() {
       let root = Node::new(1);
       let child1 = Node::new(2);
       let child2 = Node::new(3);
       
       root.add_child(child1);
       root.add_child(child2);
       
       println!("Root: {:?}", root);
   }
   ```

2. **è®¡æ•°å™¨å’Œç¼“å­˜**

   ```rust
   use std::rc::Rc;
   use std::collections::HashMap;
   
   struct StringCache {
       cache: HashMap<String, Rc<String>>,
   }
   
   impl StringCache {
       fn new() -> Self {
           Self { cache: HashMap::new() }
       }
       
       fn get(&mut self, s: &str) -> Rc<String> {
           self.cache
               .entry(s.to_string())
               .or_insert_with(|| Rc::new(s.to_string()))
               .clone()
       }
   }
   
   fn cache_example() {
       let mut cache = StringCache::new();
       
       let s1 = cache.get("hello");
       let s2 = cache.get("hello");  // å¤ç”¨ç›¸åŒçš„ Rc
       
       assert_eq!(Rc::strong_count(&s1), 3);  // cache + s1 + s2
   }
   ```

#### æ€§èƒ½è€ƒè™‘

- âœ… **å…‹éš†å¼€é”€**: `Rc::clone()` åªå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå¼€é”€å¾ˆå°
- âš ï¸ **ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„**: åªèƒ½åœ¨å•çº¿ç¨‹ä¸­ä½¿ç”¨
- âš ï¸ **å¾ªç¯å¼•ç”¨**: å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ï¼ˆéœ€è¦ä½¿ç”¨ `Weak`ï¼‰

### 2.3 Arc è·¨çº¿ç¨‹å…±äº«

#### åŸºæœ¬ä½¿ç”¨

`Arc<T>` (Atomic Reference Counted) æ˜¯ `Rc<T>` çš„çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬:

```rust
use std::sync::Arc;
use std::thread;

fn arc_basic_example() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("Thread {}: {:?}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

#### ä¸ Mutex é…åˆ

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct SharedState {
    counter: Mutex<u32>,
    data: Vec<String>,  // ä¸å¯å˜æ•°æ®ä¸éœ€è¦ Mutex
}

fn shared_state_example() {
    let state = Arc::new(SharedState {
        counter: Mutex::new(0),
        data: vec!["a".into(), "b".into(), "c".into()],
    });
    
    let mut handles = vec![];
    
    for _ in 0..10 {
        let state_clone = Arc::clone(&state);
        let handle = thread::spawn(move || {
            // è¯»å–ä¸å¯å˜æ•°æ®ï¼ˆæ— é”ï¼‰
            println!("Data: {:?}", state_clone.data);
            
            // ä¿®æ”¹å¯å˜æ•°æ®ï¼ˆéœ€è¦é”ï¼‰
            let mut counter = state_clone.counter.lock().unwrap();
            *counter += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final counter: {}", *state.counter.lock().unwrap());
}
```

#### Rc vs Arc å¯¹æ¯”

| ç‰¹æ€§ | `Rc<T>` | `Arc<T>` |
|------|-------|--------|
| **çº¿ç¨‹å®‰å…¨** | âŒ å¦ | âœ… æ˜¯ |
| **æ€§èƒ½** | ğŸ† å¿« | âš ï¸ ç•¥æ…¢ |
| **é€‚ç”¨åœºæ™¯** | å•çº¿ç¨‹å…±äº« | å¤šçº¿ç¨‹å…±äº« |
| **å¼•ç”¨è®¡æ•°** | éåŸå­ | åŸå­æ“ä½œ |
| **Send/Sync** | ä¸å®ç° | å®ç°ï¼ˆT: Send + Syncï¼‰ |

### 2.4 Weak å¼±å¼•ç”¨

#### è§£å†³å¾ªç¯å¼•ç”¨

`Weak<T>` ä¸å¢åŠ å¼ºå¼•ç”¨è®¡æ•°ï¼Œé˜²æ­¢å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼:

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

impl Node {
    fn new(value: i32) -> Rc<Self> {
        Rc::new(Node {
            value,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![]),
        })
    }
    
    fn add_child(parent: &Rc<Node>, child: Rc<Node>) {
        // å­èŠ‚ç‚¹æŒæœ‰çˆ¶èŠ‚ç‚¹çš„å¼±å¼•ç”¨
        *child.parent.borrow_mut() = Rc::downgrade(parent);
        // çˆ¶èŠ‚ç‚¹æŒæœ‰å­èŠ‚ç‚¹çš„å¼ºå¼•ç”¨
        parent.children.borrow_mut().push(child);
    }
}

fn tree_with_parent() {
    let root = Node::new(1);
    let child = Node::new(2);
    
    Node::add_child(&root, Rc::clone(&child));
    
    // å­èŠ‚ç‚¹å¯ä»¥è®¿é—®çˆ¶èŠ‚ç‚¹
    if let Some(parent) = child.parent.borrow().upgrade() {
        println!("Child's parent: {}", parent.value);
    }
    
    println!("Strong count: {}", Rc::strong_count(&root));
    println!("Weak count: {}", Rc::weak_count(&root));
}
```

#### ç¼“å­˜æ¨¡å¼

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;
use std::collections::HashMap;

struct Cache {
    data: RefCell<HashMap<String, Weak<String>>>,
}

impl Cache {
    fn new() -> Self {
        Self { data: RefCell::new(HashMap::new()) }
    }
    
    fn get_or_insert(&self, key: &str, create: impl FnOnce() -> String) -> Rc<String> {
        let mut cache = self.data.borrow_mut();
        
        // å°è¯•å‡çº§å¼±å¼•ç”¨
        if let Some(weak) = cache.get(key) {
            if let Some(strong) = weak.upgrade() {
                return strong;
            }
        }
        
        // åˆ›å»ºæ–°å€¼
        let value = Rc::new(create());
        cache.insert(key.to_string(), Rc::downgrade(&value));
        value
    }
    
    fn cleanup(&self) {
        // æ¸…ç†å·²å¤±æ•ˆçš„å¼±å¼•ç”¨
        self.data.borrow_mut().retain(|_, weak| weak.strong_count() > 0);
    }
}
```

#### è§‚å¯Ÿè€…æ¨¡å¼

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

trait Observer {
    fn update(&self, message: &str);
}

struct Subject {
    observers: RefCell<Vec<Weak<dyn Observer>>>,
}

impl Subject {
    fn new() -> Self {
        Self { observers: RefCell::new(vec![]) }
    }
    
    fn attach(&self, observer: Weak<dyn Observer>) {
        self.observers.borrow_mut().push(observer);
    }
    
    fn notify(&self, message: &str) {
        // è‡ªåŠ¨æ¸…ç†å¤±æ•ˆçš„è§‚å¯Ÿè€…
        self.observers.borrow_mut().retain(|weak| {
            if let Some(observer) = weak.upgrade() {
                observer.update(message);
                true
            } else {
                false  // è§‚å¯Ÿè€…å·²é”€æ¯ï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤
            }
        });
    }
}
```

---

## 3. å¤æ‚æ‰€æœ‰æƒè®¾è®¡

### 3.1 è‡ªå¼•ç”¨ç»“æ„

#### é—®é¢˜æè¿°

è‡ªå¼•ç”¨ç»“æ„æ˜¯æŒ‡ç»“æ„ä½“çš„æŸä¸ªå­—æ®µå¼•ç”¨ç»“æ„ä½“è‡ªèº«çš„å…¶ä»–å­—æ®µ:

```rust
// âŒ è¿™ä¸ªè®¾è®¡æ— æ³•ç¼–è¯‘
struct SelfReferential {
    data: String,
    pointer: &String,  // æƒ³è¦æŒ‡å‘ self.data
}
```

**ä¸ºä»€ä¹ˆä¸è¡Œ**ï¼Ÿ

- ç§»åŠ¨ `SelfReferential` ä¼šä½¿ `pointer` å¤±æ•ˆ
- Rust çš„æ‰€æœ‰æƒç³»ç»Ÿä¸å…è®¸è¿™ç§ä¸å®‰å…¨çš„å¼•ç”¨

#### è§£å†³æ–¹æ¡ˆ 1: Pin + Unsafe

```rust
use std::pin::Pin;
use std::marker::PhantomPinned;

struct SelfReferential {
    data: String,
    // ä½¿ç”¨åŸå§‹æŒ‡é’ˆ
    pointer: *const String,
    _pin: PhantomPinned,
}

impl SelfReferential {
    fn new(data: String) -> Pin<Box<Self>> {
        let mut boxed = Box::pin(SelfReferential {
            data,
            pointer: std::ptr::null(),
            _pin: PhantomPinned,
        });
        
        unsafe {
            let ptr = &boxed.data as *const String;
            let mut_ref = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).pointer = ptr;
        }
        
        boxed
    }
    
    fn data(&self) -> &str {
        &self.data
    }
    
    fn pointer_value(&self) -> &str {
        unsafe { &*self.pointer }
    }
}

fn main() {
    let pinned = SelfReferential::new("Hello".to_string());
    println!("Data: {}", pinned.data());
    println!("Pointer: {}", pinned.pointer_value());
}
```

#### è§£å†³æ–¹æ¡ˆ 2: ä½¿ç”¨ç´¢å¼•

```rust
// âœ… æ¨èï¼šä½¿ç”¨ç´¢å¼•ä»£æ›¿å¼•ç”¨
struct Arena {
    data: Vec<String>,
}

struct Item {
    value: String,
    related_index: usize,  // ç´¢å¼•è€Œéå¼•ç”¨
}

impl Arena {
    fn new() -> Self {
        Self { data: Vec::new() }
    }
    
    fn add(&mut self, value: String) -> usize {
        let index = self.data.len();
        self.data.push(value);
        index
    }
    
    fn get(&self, index: usize) -> Option<&String> {
        self.data.get(index)
    }
}
```

#### è§£å†³æ–¹æ¡ˆ 3: Rental/Ouroboros Crate

```rust
// ä½¿ç”¨ ouroboros crate (Rust 1.90+)
// Cargo.toml: ouroboros = "0.15"

use ouroboros::self_referencing;

#[self_referencing]
struct MyStruct {
    data: String,
    #[borrows(data)]
    pointer: &'this str,
}

fn main() {
    let my_struct = MyStructBuilder {
        data: "Hello".to_string(),
        pointer_builder: |data| &data[0..5],
    }.build();
    
    my_struct.with_pointer(|ptr| {
        println!("Pointer: {}", ptr);
    });
}
```

### 3.2 æ ‘å’Œå›¾ç»“æ„

#### æ ‘ç»“æ„å®ç°

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

type TreeNode = Rc<RefCell<Node>>;
type WeakNode = Weak<RefCell<Node>>;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<WeakNode>,
    children: RefCell<Vec<TreeNode>>,
}

impl Node {
    fn new(value: i32) -> TreeNode {
        Rc::new(RefCell::new(Node {
            value,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![]),
        }))
    }
    
    fn add_child(parent: &TreeNode, child: TreeNode) {
        *child.borrow_mut().parent.borrow_mut() = Rc::downgrade(parent);
        parent.borrow_mut().children.borrow_mut().push(child);
    }
    
    fn print_tree(node: &TreeNode, indent: usize) {
        let node_ref = node.borrow();
        println!("{:indent$}{}", "", node_ref.value, indent = indent * 2);
        
        for child in node_ref.children.borrow().iter() {
            Self::print_tree(child, indent + 1);
        }
    }
}

fn tree_example() {
    let root = Node::new(1);
    let child1 = Node::new(2);
    let child2 = Node::new(3);
    let grandchild = Node::new(4);
    
    Node::add_child(&root, Rc::clone(&child1));
    Node::add_child(&root, Rc::clone(&child2));
    Node::add_child(&child1, grandchild);
    
    Node::print_tree(&root, 0);
}
```

#### å›¾ç»“æ„å®ç°

```rust
use std::collections::HashMap;
use std::rc::Rc;
use std::cell::RefCell;

type NodeId = usize;
type GraphNode = Rc<RefCell<Node>>;

struct Node {
    id: NodeId,
    value: String,
    edges: Vec<NodeId>,  // ä½¿ç”¨ ID è€Œéå¼•ç”¨
}

struct Graph {
    nodes: HashMap<NodeId, GraphNode>,
    next_id: NodeId,
}

impl Graph {
    fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            next_id: 0,
        }
    }
    
    fn add_node(&mut self, value: String) -> NodeId {
        let id = self.next_id;
        self.next_id += 1;
        
        let node = Rc::new(RefCell::new(Node {
            id,
            value,
            edges: vec![],
        }));
        
        self.nodes.insert(id, node);
        id
    }
    
    fn add_edge(&mut self, from: NodeId, to: NodeId) -> Result<(), String> {
        if !self.nodes.contains_key(&to) {
            return Err(format!("Node {} does not exist", to));
        }
        
        if let Some(node) = self.nodes.get(&from) {
            node.borrow_mut().edges.push(to);
            Ok(())
        } else {
            Err(format!("Node {} does not exist", from))
        }
    }
    
    fn get_neighbors(&self, id: NodeId) -> Option<Vec<NodeId>> {
        self.nodes.get(&id).map(|node| node.borrow().edges.clone())
    }
    
    fn print_graph(&self) {
        for (id, node) in &self.nodes {
            let node_ref = node.borrow();
            println!("Node {}: {} -> {:?}", id, node_ref.value, node_ref.edges);
        }
    }
}

fn graph_example() {
    let mut graph = Graph::new();
    
    let a = graph.add_node("A".to_string());
    let b = graph.add_node("B".to_string());
    let c = graph.add_node("C".to_string());
    
    graph.add_edge(a, b).unwrap();
    graph.add_edge(a, c).unwrap();
    graph.add_edge(b, c).unwrap();
    graph.add_edge(c, a).unwrap();  // å½¢æˆå¾ªç¯
    
    graph.print_graph();
}
```

### 3.3 è§‚å¯Ÿè€…æ¨¡å¼

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

trait Observer {
    fn on_notify(&self, event: &str);
    fn name(&self) -> &str;
}

struct ConcreteObserver {
    name: String,
}

impl Observer for ConcreteObserver {
    fn on_notify(&self, event: &str) {
        println!("{} received: {}", self.name, event);
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

struct Subject {
    observers: RefCell<Vec<Weak<dyn Observer>>>,
}

impl Subject {
    fn new() -> Self {
        Self {
            observers: RefCell::new(vec![]),
        }
    }
    
    fn attach(&self, observer: &Rc<dyn Observer>) {
        self.observers.borrow_mut().push(Rc::downgrade(observer));
    }
    
    fn detach(&self, name: &str) {
        self.observers.borrow_mut().retain(|weak| {
            weak.upgrade()
                .map(|obs| obs.name() != name)
                .unwrap_or(false)
        });
    }
    
    fn notify(&self, event: &str) {
        // é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…ï¼ŒåŒæ—¶æ¸…ç†å¤±æ•ˆçš„å¼•ç”¨
        self.observers.borrow_mut().retain(|weak| {
            if let Some(observer) = weak.upgrade() {
                observer.on_notify(event);
                true
            } else {
                false
            }
        });
    }
}

fn observer_pattern_example() {
    let subject = Subject::new();
    
    let observer1: Rc<dyn Observer> = Rc::new(ConcreteObserver {
        name: "Observer1".to_string(),
    });
    
    let observer2: Rc<dyn Observer> = Rc::new(ConcreteObserver {
        name: "Observer2".to_string(),
    });
    
    subject.attach(&observer1);
    subject.attach(&observer2);
    
    subject.notify("Event 1");
    
    subject.detach("Observer1");
    
    subject.notify("Event 2");
}
```

### 3.4 çŠ¶æ€æœºè®¾è®¡

```rust
// ç±»å‹çŠ¶æ€æ¨¡å¼ï¼šä½¿ç”¨ç±»å‹ç³»ç»Ÿä¿è¯çŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§

struct Locked;
struct Unlocked;

struct Door<State> {
    state: std::marker::PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door created (locked)");
        Door {
            state: std::marker::PhantomData,
        }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Door unlocked");
        Door {
            state: std::marker::PhantomData,
        }
    }
}

impl Door<Unlocked> {
    fn open(&self) {
        println!("Door opened");
    }
    
    fn lock(self) -> Door<Locked> {
        println!("Door locked");
        Door {
            state: std::marker::PhantomData,
        }
    }
}

fn typestate_example() {
    let door = Door::<Locked>::new();
    // door.open();  // âŒ ç¼–è¯‘é”™è¯¯ï¼šlocked çŠ¶æ€ä¸èƒ½ open
    
    let door = door.unlock();
    door.open();  // âœ… OK
    
    let door = door.lock();
    // door.open();  // âŒ ç¼–è¯‘é”™è¯¯
}

// ä¼ ç»ŸçŠ¶æ€æœºæ¨¡å¼
enum State {
    Locked,
    Unlocked,
}

struct StateMachine {
    state: State,
}

impl StateMachine {
    fn new() -> Self {
        Self { state: State::Locked }
    }
    
    fn unlock(&mut self) -> Result<(), &str> {
        match self.state {
            State::Locked => {
                self.state = State::Unlocked;
                println!("Unlocked");
                Ok(())
            }
            State::Unlocked => Err("Already unlocked"),
        }
    }
    
    fn lock(&mut self) -> Result<(), &str> {
        match self.state {
            State::Unlocked => {
                self.state = State::Locked;
                println!("Locked");
                Ok(())
            }
            State::Locked => Err("Already locked"),
        }
    }
    
    fn open(&self) -> Result<(), &str> {
        match self.state {
            State::Unlocked => {
                println!("Opened");
                Ok(())
            }
            State::Locked => Err("Cannot open: door is locked"),
        }
    }
}
```

---

## 4. å®æˆ˜æ¡ˆä¾‹

### 4.1 Web æœåŠ¡å™¨è®¾è®¡

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::thread;

// å…±äº«çŠ¶æ€ï¼šè¿æ¥æ± 
struct ConnectionPool {
    connections: Mutex<Vec<Connection>>,
    max_size: usize,
}

struct Connection {
    id: usize,
    is_busy: bool,
}

impl ConnectionPool {
    fn new(max_size: usize) -> Arc<Self> {
        let connections = (0..max_size)
            .map(|id| Connection { id, is_busy: false })
            .collect();
        
        Arc::new(ConnectionPool {
            connections: Mutex::new(connections),
            max_size,
        })
    }
    
    fn acquire(&self) -> Option<usize> {
        let mut conns = self.connections.lock().unwrap();
        conns.iter_mut()
            .find(|c| !c.is_busy)
            .map(|c| {
                c.is_busy = true;
                c.id
            })
    }
    
    fn release(&self, id: usize) {
        let mut conns = self.connections.lock().unwrap();
        if let Some(conn) = conns.iter_mut().find(|c| c.id == id) {
            conn.is_busy = false;
        }
    }
}

// è¯·æ±‚å¤„ç†å™¨
struct RequestHandler {
    pool: Arc<ConnectionPool>,
    cache: Arc<Mutex<HashMap<String, String>>>,
}

impl RequestHandler {
    fn new(pool: Arc<ConnectionPool>) -> Self {
        Self {
            pool,
            cache: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn handle_request(&self, request: &str) -> Result<String, String> {
        // æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.cache.lock().unwrap().get(request) {
            return Ok(cached.clone());
        }
        
        // è·å–è¿æ¥
        let conn_id = self.pool.acquire()
            .ok_or("No available connections")?;
        
        // æ¨¡æ‹Ÿå¤„ç†
        thread::sleep(std::time::Duration::from_millis(100));
        let response = format!("Response to: {}", request);
        
        // æ›´æ–°ç¼“å­˜
        self.cache.lock().unwrap()
            .insert(request.to_string(), response.clone());
        
        // é‡Šæ”¾è¿æ¥
        self.pool.release(conn_id);
        
        Ok(response)
    }
}

fn web_server_example() {
    let pool = ConnectionPool::new(5);
    let handler = Arc::new(RequestHandler::new(pool));
    
    let mut handles = vec![];
    
    for i in 0..10 {
        let handler_clone = Arc::clone(&handler);
        let handle = thread::spawn(move || {
            let request = format!("request-{}", i % 3);  // 3 ç§ä¸åŒçš„è¯·æ±‚
            match handler_clone.handle_request(&request) {
                Ok(response) => println!("âœ… {}: {}", i, response),
                Err(e) => eprintln!("âŒ {}: {}", i, e),
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 4.2 æ•°æ®åº“è¿æ¥æ± 

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::time::Duration;

struct DbConnection {
    id: usize,
}

impl DbConnection {
    fn query(&self, sql: &str) -> Result<String, String> {
        // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        println!("Connection {} executing: {}", self.id, sql);
        thread::sleep(Duration::from_millis(50));
        Ok(format!("Result from connection {}", self.id))
    }
}

struct DbPool {
    available: Mutex<Vec<DbConnection>>,
    condvar: Condvar,
    max_size: usize,
}

impl DbPool {
    fn new(size: usize) -> Arc<Self> {
        let connections = (0..size)
            .map(|id| DbConnection { id })
            .collect();
        
        Arc::new(DbPool {
            available: Mutex::new(connections),
            condvar: Condvar::new(),
            max_size: size,
        })
    }
    
    fn get_connection(&self) -> DbConnection {
        let mut available = self.available.lock().unwrap();
        
        // ç­‰å¾…ç›´åˆ°æœ‰å¯ç”¨è¿æ¥
        while available.is_empty() {
            available = self.condvar.wait(available).unwrap();
        }
        
        available.pop().unwrap()
    }
    
    fn return_connection(&self, conn: DbConnection) {
        let mut available = self.available.lock().unwrap();
        available.push(conn);
        
        // é€šçŸ¥ç­‰å¾…çš„çº¿ç¨‹
        self.condvar.notify_one();
    }
}

fn db_pool_example() {
    let pool = DbPool::new(3);
    let mut handles = vec![];
    
    for i in 0..10 {
        let pool_clone = Arc::clone(&pool);
        let handle = thread::spawn(move || {
            let conn = pool_clone.get_connection();
            println!("Thread {} got connection {}", i, conn.id);
            
            let _ = conn.query(&format!("SELECT * FROM table WHERE id = {}", i));
            
            pool_clone.return_connection(conn);
            println!("Thread {} returned connection", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 4.3 ç¼“å­˜ç³»ç»Ÿ

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

struct CacheEntry<T> {
    value: T,
    expires_at: Instant,
}

struct Cache<T: Clone> {
    data: RwLock<HashMap<String, CacheEntry<T>>>,
    default_ttl: Duration,
}

impl<T: Clone> Cache<T> {
    fn new(default_ttl: Duration) -> Arc<Self> {
        Arc::new(Cache {
            data: RwLock::new(HashMap::new()),
            default_ttl,
        })
    }
    
    fn get(&self, key: &str) -> Option<T> {
        let data = self.data.read().unwrap();
        
        if let Some(entry) = data.get(key) {
            if entry.expires_at > Instant::now() {
                return Some(entry.value.clone());
            }
        }
        
        None
    }
    
    fn set(&self, key: String, value: T) {
        self.set_with_ttl(key, value, self.default_ttl);
    }
    
    fn set_with_ttl(&self, key: String, value: T, ttl: Duration) {
        let mut data = self.data.write().unwrap();
        
        data.insert(key, CacheEntry {
            value,
            expires_at: Instant::now() + ttl,
        });
    }
    
    fn cleanup(&self) {
        let mut data = self.data.write().unwrap();
        let now = Instant::now();
        
        data.retain(|_, entry| entry.expires_at > now);
    }
    
    fn get_or_insert_with<F>(&self, key: &str, create: F) -> T
    where
        F: FnOnce() -> T,
    {
        // å…ˆå°è¯•è¯»å–
        if let Some(value) = self.get(key) {
            return value;
        }
        
        // éœ€è¦åˆ›å»ºæ–°å€¼
        let value = create();
        self.set(key.to_string(), value.clone());
        value
    }
}

fn cache_example() {
    let cache = Cache::<String>::new(Duration::from_secs(60));
    
    // åŸºæœ¬ç”¨æ³•
    cache.set("key1".to_string(), "value1".to_string());
    assert_eq!(cache.get("key1"), Some("value1".to_string()));
    
    // è·å–æˆ–æ’å…¥
    let value = cache.get_or_insert_with("key2", || {
        println!("Computing expensive value...");
        "computed_value".to_string()
    });
    assert_eq!(value, "computed_value");
    
    // ç¬¬äºŒæ¬¡è°ƒç”¨ä¼šä½¿ç”¨ç¼“å­˜
    let value = cache.get_or_insert_with("key2", || {
        println!("This won't be printed");
        "new_value".to_string()
    });
    assert_eq!(value, "computed_value");
}
```

### 4.4 æ’ä»¶æ¶æ„

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn execute(&self, input: &str) -> Result<String, String>;
}

struct PluginManager {
    plugins: RwLock<HashMap<String, Arc<dyn Plugin>>>,
}

impl PluginManager {
    fn new() -> Arc<Self> {
        Arc::new(PluginManager {
            plugins: RwLock::new(HashMap::new()),
        })
    }
    
    fn register(&self, plugin: Arc<dyn Plugin>) -> Result<(), String> {
        let name = plugin.name().to_string();
        let mut plugins = self.plugins.write().unwrap();
        
        if plugins.contains_key(&name) {
            return Err(format!("Plugin '{}' already registered", name));
        }
        
        plugins.insert(name, plugin);
        Ok(())
    }
    
    fn unregister(&self, name: &str) -> Result<(), String> {
        let mut plugins = self.plugins.write().unwrap();
        
        plugins.remove(name)
            .map(|_| ())
            .ok_or_else(|| format!("Plugin '{}' not found", name))
    }
    
    fn execute(&self, plugin_name: &str, input: &str) -> Result<String, String> {
        let plugins = self.plugins.read().unwrap();
        
        plugins.get(plugin_name)
            .ok_or_else(|| format!("Plugin '{}' not found", plugin_name))?
            .execute(input)
    }
    
    fn list_plugins(&self) -> Vec<String> {
        let plugins = self.plugins.read().unwrap();
        plugins.keys().cloned().collect()
    }
}

// ç¤ºä¾‹æ’ä»¶
struct UppercasePlugin;

impl Plugin for UppercasePlugin {
    fn name(&self) -> &str {
        "uppercase"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        Ok(input.to_uppercase())
    }
}

struct ReversePlugin;

impl Plugin for ReversePlugin {
    fn name(&self) -> &str {
        "reverse"
    }
    
    fn execute(&self, input: &str) -> Result<String, String> {
        Ok(input.chars().rev().collect())
    }
}

fn plugin_system_example() {
    let manager = PluginManager::new();
    
    // æ³¨å†Œæ’ä»¶
    manager.register(Arc::new(UppercasePlugin)).unwrap();
    manager.register(Arc::new(ReversePlugin)).unwrap();
    
    println!("Available plugins: {:?}", manager.list_plugins());
    
    // ä½¿ç”¨æ’ä»¶
    let result = manager.execute("uppercase", "hello").unwrap();
    println!("Uppercase: {}", result);
    
    let result = manager.execute("reverse", "hello").unwrap();
    println!("Reverse: {}", result);
}
```

---

## ç›¸å…³èµ„æº

### ğŸ“– æ ¸å¿ƒæ–‡æ¡£

- **[é«˜çº§æ‰€æœ‰æƒæ¨¡å¼å®Œæ•´æ–‡æ¡£](../03_advanced/01_advanced_ownership.md)**: è¯¦ç»†çš„é«˜çº§æ¨¡å¼å’Œæœ€ä½³å®è·µ
- **[å†…å­˜å®‰å…¨åˆ†æ](../04_safety/01_memory_safety.md)**: æ·±å…¥ç†è§£å†…å­˜å®‰å…¨æœºåˆ¶
- **[å¹¶å‘ç¼–ç¨‹æŒ‡å—](../05_practice/05_concurrent_programming.md)**: å¹¶å‘åœºæ™¯çš„æ‰€æœ‰æƒæ¨¡å¼

### ğŸ”— ç›¸å…³ä¸»é¢˜

- **Tier 2 æ ¸å¿ƒæ¦‚å¿µ**
  - [2.1 æ‰€æœ‰æƒç³»ç»Ÿ](../tier2_core_concepts/2.1_æ‰€æœ‰æƒç³»ç»Ÿ.md)
  - [2.2 å€Ÿç”¨æ£€æŸ¥å™¨](../tier2_core_concepts/2.2_å€Ÿç”¨æ£€æŸ¥å™¨.md)
  - [2.3 ç”Ÿå‘½å‘¨æœŸ](../tier2_core_concepts/2.3_ç”Ÿå‘½å‘¨æœŸ.md)

- **Tier 3 é«˜çº§ä¸»é¢˜**
  - [3.2 é›¶æˆæœ¬æŠ½è±¡](./3.2_é›¶æˆæœ¬æŠ½è±¡.md)
  - [3.3 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ](./3.3_å†…å­˜å®‰å…¨æœ€ä½³å®è·µ.md)
  - [3.4 æ€§èƒ½ä¼˜åŒ–](./3.4_æ€§èƒ½ä¼˜åŒ–.md)

- **Tier 4 ç†è®ºæ·±åº¦**
  - [4.1 ç±»å‹ç³»ç»Ÿç†è®º](../tier4_theoretical/4.1_ç±»å‹ç³»ç»Ÿç†è®º.md)
  - [4.2 å½¢å¼åŒ–éªŒè¯](../tier4_theoretical/4.2_å½¢å¼åŒ–éªŒè¯.md)

### ğŸ“š å­¦ä¹ è·¯å¾„

**è¿›é˜¶è·¯å¾„**:

1. å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ ï¼ˆé¢„ä¼° 8-12 å°æ—¶ï¼‰
2. å®è·µè‡³å°‘ 3 ä¸ªå®æˆ˜æ¡ˆä¾‹
3. æ·±å…¥å­¦ä¹  [é›¶æˆæœ¬æŠ½è±¡](./3.2_é›¶æˆæœ¬æŠ½è±¡.md)
4. è¿›é˜¶åˆ° [ç±»å‹ç³»ç»Ÿç†è®º](../tier4_theoretical/4.1_ç±»å‹ç³»ç»Ÿç†è®º.md)

**å®è·µå»ºè®®**:

- ğŸ”¨ å®ç°ä¸€ä¸ªç®€å•çš„æ ‘æˆ–å›¾ç»“æ„
- ğŸ”¨ ç¼–å†™ä¸€ä¸ªä½¿ç”¨ RefCell/Rc çš„çŠ¶æ€ç®¡ç†ç³»ç»Ÿ
- ğŸ”¨ è®¾è®¡ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„ç¼“å­˜ç³»ç»Ÿ
- ğŸ”¨ å®ç°ä¸€ä¸ªæ’ä»¶æ¶æ„çš„å°å‹åº”ç”¨

### ğŸ¯ å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ä»¥éªŒè¯å­¦ä¹ æ•ˆæœ:

- [ ] ç†è§£ Cell/RefCell/Mutex/RwLock çš„åŒºåˆ«å’Œä½¿ç”¨åœºæ™¯
- [ ] èƒ½å¤Ÿé€‰æ‹©åˆé€‚çš„å†…éƒ¨å¯å˜æ€§å·¥å…·
- [ ] æŒæ¡ Rc/Arc/Weak çš„ä½¿ç”¨æ¨¡å¼
- [ ] ç†è§£å¹¶é¿å…å¾ªç¯å¼•ç”¨é—®é¢˜
- [ ] èƒ½å¤Ÿè®¾è®¡å¤æ‚çš„æ ‘å’Œå›¾ç»“æ„
- [ ] å®ç°è‡³å°‘ä¸€ä¸ªå®Œæ•´çš„å®æˆ˜æ¡ˆä¾‹
- [ ] ç†è§£è‡ªå¼•ç”¨ç»“æ„çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
- [ ] èƒ½å¤Ÿåœ¨æ€§èƒ½å’Œå®‰å…¨æ€§ä¹‹é—´åšå‡ºæƒè¡¡

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0 (æ‰©å±•ç‰ˆ)  
**é€‚ç”¨ Rust ç‰ˆæœ¬**: 1.90+  
**é¢„ä¼°å­¦ä¹ æ—¶é—´**: 8-12 å°æ—¶  
**éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

END OF DOCUMENT
