# Tier 3: 所有权规则完整参考

> **文档类型**: 技术参考  
> **适用版本**: Rust 1.90+  
> **用途**: 完整的所有权规则手册

---

## 目录

- [Tier 3: 所有权规则完整参考](#tier-3-所有权规则完整参考)
  - [目录](#目录)
  - [📖 1. 核心规则](#-1-核心规则)
    - [1.1 所有权三大规则](#11-所有权三大规则)
    - [1.2 所有权转移规则](#12-所有权转移规则)
  - [📦 2. Move 语义](#-2-move-语义)
    - [2.1 完整移动](#21-完整移动)
    - [2.2 部分移动](#22-部分移动)
  - [📋 3. Copy 语义](#-3-copy-语义)
    - [3.1 Copy trait 规则](#31-copy-trait-规则)
    - [3.2 Copy 类型列表](#32-copy-类型列表)
  - [🔄 4. Clone 语义](#-4-clone-语义)
  - [📚 5. 函数调用规则](#-5-函数调用规则)
    - [5.1 传值 (by value)](#51-传值-by-value)
    - [5.2 传引用 (by reference)](#52-传引用-by-reference)
  - [🎯 6. 返回值规则](#-6-返回值规则)
  - [⚙️ 7. 结构体所有权](#️-7-结构体所有权)
  - [📊 8. 集合所有权](#-8-集合所有权)
  - [🔍 9. 所有权检查时机](#-9-所有权检查时机)
  - [⚠️ 10. 常见错误](#️-10-常见错误)
    - [错误 1: Use after move](#错误-1-use-after-move)
    - [错误 2: 部分移动后使用整体](#错误-2-部分移动后使用整体)
    - [错误 3: 函数参数移动](#错误-3-函数参数移动)

---

## 📖 1. 核心规则

### 1.1 所有权三大规则

**规则 1: 唯一所有者**:

```rust
// ✅ 每个值有且仅有一个所有者
let s = String::from("hello"); // s 是所有者

// ❌ 不能有多个所有者（除非使用 Rc/Arc）
// let s2 = s; // s 的所有权已转移
```

**规则 2: 作用域结束释放**:

```rust
{
    let s = String::from("hello"); // s 进入作用域
    // 使用 s
} // s 离开作用域，自动调用 drop，释放内存
```

**规则 3: 转移后失效**:

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权转移给 s2
// println!("{}", s1); // ❌ 编译错误: s1 已失效
println!("{}", s2); // ✅ 正确
```

---

### 1.2 所有权转移规则

**规则 4: 赋值转移**:

```rust
let s1 = String::from("hello");
let s2 = s1; // 所有权从 s1 转移到 s2
```

**规则 5: 函数传参转移**:

```rust
fn take_ownership(s: String) {
    println!("{}", s);
} // s 在这里被 drop

let s = String::from("hello");
take_ownership(s); // s 的所有权转移到函数
// println!("{}", s); // ❌ 错误
```

**规则 6: 函数返回转移**:

```rust
fn give_ownership() -> String {
    let s = String::from("hello");
    s // 所有权转移给调用者
}

let s = give_ownership(); // s 获得所有权
```

---

## 📦 2. Move 语义

### 2.1 完整移动

**非 Copy 类型的移动**:

```rust
// String, Vec, Box 等都是 Move 类型
let s1 = String::from("hello");
let s2 = s1; // 完整移动

let v1 = vec![1, 2, 3];
let v2 = v1; // 完整移动

let b1 = Box::new(5);
let b2 = b1; // 完整移动
```

**移动后内存布局**:

```text
移动前:
s1: [ptr]--> [h][e][l][l][o] (heap)

移动后:
s1: [无效] 
s2: [ptr]--> [h][e][l][l][o] (heap)
```

---

### 2.2 部分移动

**结构体部分移动**:

```rust
struct Point {
    x: i32,
    y: String,
}

let p = Point {
    x: 10,
    y: String::from("hello"),
};

let x = p.x; // Copy (i32 是 Copy)
let y = p.y; // Move (String 是 Move)

// println!("{}", p.x); // ✅ x 是 Copy，p.x 仍有效
// println!("{}", p.y); // ❌ y 已被移动
// println!("{:?}", p);  // ❌ p 部分失效
```

**元组部分移动**:

```rust
let t = (String::from("hello"), 42);
let s = t.0; // Move
// let n = t.1; // ❌ t 已部分失效
```

---

## 📋 3. Copy 语义

### 3.1 Copy trait 规则

**规则 7: Copy 类型的复制**:

```rust
// Copy 类型赋值是复制，而非移动
let x = 5;
let y = x; // 复制 x 的值
println!("x = {}, y = {}", x, y); // ✅ x 仍有效
```

**规则 8: Copy 的约束**:

- 必须实现 `Copy` trait
- 所有字段都必须是 `Copy`
- 不能实现 `Drop` trait

```rust
// ✅ 可以是 Copy
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

// ❌ 不能是 Copy (有 non-Copy 字段)
struct Data {
    name: String, // String 不是 Copy
}
```

---

### 3.2 Copy 类型列表

**标准库 Copy 类型**:

| 类型类别 | 具体类型 |
|---------|---------|
| **基本类型** | `bool`, `char` |
| **整数** | `i8` ~ `i128`, `u8` ~ `u128`, `isize`, `usize` |
| **浮点数** | `f32`, `f64` |
| **指针** | `*const T`, `*mut T` |
| **引用** | `&T`, `&mut T` (引用本身) |
| **数组** | `[T; N]` (T 是 Copy) |
| **元组** | `(T1, T2, ...)` (所有 T 都是 Copy) |
| **Option** | `Option<T>` (T 是 Copy) |
| **Result** | `Result<T, E>` (T 和 E 都是 Copy) |

**非 Copy 类型**:

- `String`, `Vec<T>`, `Box<T>`
- 任何实现了 `Drop` 的类型
- 包含非 Copy 字段的结构体

---

## 🔄 4. Clone 语义

**规则 9: Clone 的显式复制**:

```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // 显式深拷贝
println!("s1 = {}, s2 = {}", s1, s2); // ✅ s1 仍有效
```

**Clone vs Copy**:

| 特性 | Copy | Clone |
|------|------|-------|
| **触发方式** | 隐式 | 显式 (`clone()`) |
| **开销** | O(1) | O(n) |
| **实现约束** | 严格 | 宽松 |
| **典型用途** | 简单类型 | 复杂类型 |

---

## 📚 5. 函数调用规则

### 5.1 传值 (by value)

**规则 10: 所有权转移到函数**:

```rust
fn process(s: String) {
    println!("{}", s);
} // s 被 drop

let data = String::from("hello");
process(data); // data 的所有权转移
// println!("{}", data); // ❌ 错误
```

---

### 5.2 传引用 (by reference)

**不可变引用**:

```rust
fn read(s: &String) {
    println!("{}", s);
}

let data = String::from("hello");
read(&data); // 借用，不转移所有权
println!("{}", data); // ✅ data 仍有效
```

**可变引用**:

```rust
fn modify(s: &mut String) {
    s.push_str(", world");
}

let mut data = String::from("hello");
modify(&mut data); // 可变借用
println!("{}", data); // "hello, world"
```

---

## 🎯 6. 返回值规则

**规则 11: 返回转移所有权**:

```rust
fn create() -> String {
    let s = String::from("hello");
    s // 所有权转移给调用者
}

let data = create(); // data 获得所有权
```

**规则 12: 返回引用必须有效**:

```rust
// ❌ 返回悬垂引用
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s // s 在这里被 drop，返回悬垂引用
// }

// ✅ 返回所有权
fn no_dangle() -> String {
    String::from("hello")
}
```

---

## ⚙️ 7. 结构体所有权

**规则 13: 结构体拥有字段**:

```rust
struct User {
    username: String,
    email: String,
}

let user = User {
    username: String::from("alice"),
    email: String::from("alice@example.com"),
};
// user 拥有 username 和 email
```

**规则 14: 结构体移动**:

```rust
let user1 = User {
    username: String::from("alice"),
    email: String::from("alice@example.com"),
};

let user2 = user1; // user1 整体移动
// println!("{}", user1.username); // ❌ user1 已失效
```

---

## 📊 8. 集合所有权

**规则 15: 集合拥有元素**:

```rust
let v = vec![
    String::from("a"),
    String::from("b"),
];
// v 拥有所有 String

drop(v); // v 和所有元素都被 drop
```

**规则 16: 从集合移出元素**:

```rust
let mut v = vec![
    String::from("a"),
    String::from("b"),
];

// 方法 1: swap_remove (O(1))
let s = v.swap_remove(0);

// 方法 2: remove (O(n))
let s = v.remove(0);

// 方法 3: take (需要 Option)
let mut v = vec![Some(String::from("a"))];
let s = v[0].take(); // Option::take
```

---

## 🔍 9. 所有权检查时机

**编译时检查**:

- ✅ 所有权转移
- ✅ 借用规则
- ✅ 生命周期

**运行时检查** (少数情况):

- `RefCell<T>` 的借用
- `Mutex<T>` 的锁

---

## ⚠️ 10. 常见错误

### 错误 1: Use after move

```rust
let s = String::from("hello");
let s2 = s;
// println!("{}", s); // ❌ use of moved value: `s`
```

**解决方案**:

```rust
// 1. clone
let s = String::from("hello");
let s2 = s.clone();
println!("{}, {}", s, s2); // ✅

// 2. 借用
let s = String::from("hello");
let s2 = &s;
println!("{}, {}", s, s2); // ✅
```

---

### 错误 2: 部分移动后使用整体

```rust
let s = Some(String::from("hello"));
let inner = s.unwrap();
// println!("{:?}", s); // ❌ s 已被移动
```

---

### 错误 3: 函数参数移动

```rust
fn process(s: String) {
    println!("{}", s);
}

let s = String::from("hello");
process(s);
// process(s); // ❌ use of moved value
```

**解决方案**:

```rust
// 使用引用
fn process(s: &String) {
    println!("{}", s);
}

let s = String::from("hello");
process(&s);
process(&s); // ✅ 可以多次调用
```

---

**相关文档**:

- [Tier 2: 01_所有权快速入门](../tier_02_guides/01_所有权快速入门.md)
- [Tier 4: 03_所有权性能优化](../tier_04_advanced/03_所有权性能优化.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
