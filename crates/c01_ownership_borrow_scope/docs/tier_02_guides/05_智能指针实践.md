# Tier 2: æ™ºèƒ½æŒ‡é’ˆå®è·µæŒ‡å—

> **æ–‡æ¡£ç±»å‹**: å®è·µæŒ‡å—
> **éš¾åº¦çº§åˆ«**: â­â­â­ ä¸­çº§
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4 å°æ—¶
> **å‰ç½®çŸ¥è¯†**: å®Œæˆ Tier 2 å‰ 4 ç¯‡æ–‡æ¡£

---

## ç›®å½•

- [Tier 2: æ™ºèƒ½æŒ‡é’ˆå®è·µæŒ‡å—](#tier-2-æ™ºèƒ½æŒ‡é’ˆå®è·µæŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [ğŸ“– 1. æ¦‚è¿°](#-1-æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆ?](#ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆ)
    - [ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½æŒ‡é’ˆï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½æŒ‡é’ˆ)
  - [ğŸ“¦ 2. `Box<T>` - å †åˆ†é…](#-2-boxt---å †åˆ†é…)
    - [åŸºæœ¬ç”¨æ³•](#åŸºæœ¬ç”¨æ³•)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
      - [åœºæ™¯ 1: å¤§å‹æ•°æ®ç»“æ„](#åœºæ™¯-1-å¤§å‹æ•°æ®ç»“æ„)
      - [åœºæ™¯ 2: é€’å½’ç±»å‹](#åœºæ™¯-2-é€’å½’ç±»å‹)
      - [åœºæ™¯ 3: Trait å¯¹è±¡](#åœºæ™¯-3-trait-å¯¹è±¡)
  - [ğŸ”— 3. `Rc<T>` - å¼•ç”¨è®¡æ•°](#-3-rct---å¼•ç”¨è®¡æ•°)
    - [3.1 åŸºæœ¬ç”¨æ³•](#31-åŸºæœ¬ç”¨æ³•)
    - [3.2 åº”ç”¨åœºæ™¯](#32-åº”ç”¨åœºæ™¯)
      - [åœºæ™¯ 1: å›¾æ•°æ®ç»“æ„](#åœºæ™¯-1-å›¾æ•°æ®ç»“æ„)
      - [åœºæ™¯ 2: å…±äº«é…ç½®](#åœºæ™¯-2-å…±äº«é…ç½®)
  - [ğŸ” 4. `Arc<T>` - åŸå­å¼•ç”¨è®¡æ•°](#-4-arct---åŸå­å¼•ç”¨è®¡æ•°)
    - [4.1 åŸºæœ¬ç”¨æ³•](#41-åŸºæœ¬ç”¨æ³•)
    - [4.2 åº”ç”¨åœºæ™¯](#42-åº”ç”¨åœºæ™¯)
      - [åœºæ™¯ 1: å¤šçº¿ç¨‹å…±äº«æ•°æ®](#åœºæ™¯-1-å¤šçº¿ç¨‹å…±äº«æ•°æ®)
      - [åœºæ™¯ 2: å¹¶å‘ç¼“å­˜](#åœºæ™¯-2-å¹¶å‘ç¼“å­˜)
  - [ğŸ§¬ 5. `RefCell<T>` - å†…éƒ¨å¯å˜æ€§](#-5-refcellt---å†…éƒ¨å¯å˜æ€§)
    - [5.1 åŸºæœ¬ç”¨æ³•](#51-åŸºæœ¬ç”¨æ³•)
    - [5.2 åº”ç”¨åœºæ™¯](#52-åº”ç”¨åœºæ™¯)
      - [åœºæ™¯ 1: Mock æµ‹è¯•](#åœºæ™¯-1-mock-æµ‹è¯•)
      - [åœºæ™¯ 2: è§‚å¯Ÿè€…æ¨¡å¼](#åœºæ™¯-2-è§‚å¯Ÿè€…æ¨¡å¼)
  - [ğŸ”„ 6. ç»„åˆä½¿ç”¨](#-6-ç»„åˆä½¿ç”¨)
    - [`Rc<RefCell<T>>`](#rcrefcellt)
    - [`Arc<Mutex<T>>`](#arcmutext)
  - [âš ï¸ 7. å¸¸è§é™·é˜±](#ï¸-7-å¸¸è§é™·é˜±)
    - [é™·é˜± 1: å¾ªç¯å¼•ç”¨](#é™·é˜±-1-å¾ªç¯å¼•ç”¨)
    - [é™·é˜± 2: RefCell panic](#é™·é˜±-2-refcell-panic)
    - [é™·é˜± 3: Arc æ€§èƒ½](#é™·é˜±-3-arc-æ€§èƒ½)
  - [âœ… 8. æœ€ä½³å®è·µ](#-8-æœ€ä½³å®è·µ)
    - [é€‰æ‹©æŒ‡å—](#é€‰æ‹©æŒ‡å—)
    - [å®è·µå»ºè®®](#å®è·µå»ºè®®)
  - [ğŸ“š 9. å»¶ä¼¸é˜…è¯»](#-9-å»¶ä¼¸é˜…è¯»)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ™ºèƒ½æŒ‡é’ˆå®è·µæŒ‡å— (Smart Pointer Practice Guide)**:

- **å®šä¹‰**: ç³»ç»Ÿå­¦ä¹  Rust æ™ºèƒ½æŒ‡é’ˆçš„å®è·µæŒ‡å—
- **ç±»å‹**: å®è·µæŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: æ‰€æœ‰æƒç³»ç»Ÿã€å†…å­˜ç®¡ç†
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: æ™ºèƒ½æŒ‡é’ˆã€Boxã€Rcã€Arcã€RefCellã€å†…éƒ¨å¯å˜æ€§

**æ™ºèƒ½æŒ‡é’ˆ (Smart Pointer)**:

- **å®šä¹‰**: è¡Œä¸ºç±»ä¼¼æŒ‡é’ˆä½†æ‹¥æœ‰é¢å¤–å…ƒæ•°æ®å’ŒåŠŸèƒ½çš„æ•°æ®ç»“æ„
- **ç±»å‹**: å†…å­˜ç®¡ç†æœºåˆ¶
- **å±æ€§**: æ‹¥æœ‰æ•°æ®ã€è‡ªåŠ¨æ¸…ç†ã€å¼•ç”¨è®¡æ•°ã€å†…éƒ¨å¯å˜æ€§
- **å…³ç³»**: ä¸æ‰€æœ‰æƒã€å¼•ç”¨è®¡æ•°ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **Box<T>**: å †åˆ†é…ã€å¤§å‹æ•°æ®ç»“æ„ã€é€’å½’ç±»å‹
- **Rc<T>**: å¼•ç”¨è®¡æ•°ã€å•çº¿ç¨‹å…±äº«æ‰€æœ‰æƒ
- **Arc<T>**: åŸå­å¼•ç”¨è®¡æ•°ã€å¤šçº¿ç¨‹å…±äº«æ‰€æœ‰æƒ
- **RefCell<T>**: å†…éƒ¨å¯å˜æ€§ã€è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥

**æ€§èƒ½ç‰¹å¾**:

- **å †åˆ†é…**: Box ä½¿ç”¨å †åˆ†é…
- **å¼•ç”¨è®¡æ•°å¼€é”€**: Rc/Arc æœ‰å¼•ç”¨è®¡æ•°å¼€é”€
- **è¿è¡Œæ—¶æ£€æŸ¥**: RefCell è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥
- **é€‚ç”¨åœºæ™¯**: å…±äº«æ‰€æœ‰æƒã€å†…éƒ¨å¯å˜æ€§ã€å¤šçº¿ç¨‹

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- Box --[is-a]--> æ™ºèƒ½æŒ‡é’ˆ
- Rc --[is-a]--> æ™ºèƒ½æŒ‡é’ˆ

**ç»„åˆå…³ç³»**:

- æ™ºèƒ½æŒ‡é’ˆå®è·µæŒ‡å— --[covers]--> å¤šç§æ™ºèƒ½æŒ‡é’ˆ
- å†…å­˜ç®¡ç†ç¨‹åº --[uses]--> æ™ºèƒ½æŒ‡é’ˆ

**ä¾èµ–å…³ç³»**:

- æ™ºèƒ½æŒ‡é’ˆ --[depends-on]--> æ‰€æœ‰æƒç³»ç»Ÿ
- å…±äº«æ‰€æœ‰æƒ --[depends-on]--> æ™ºèƒ½æŒ‡é’ˆ

### æ€ç»´å¯¼å›¾

```text
æ™ºèƒ½æŒ‡é’ˆå®è·µæŒ‡å—
â”‚
â”œâ”€â”€ Box<T>
â”‚   â””â”€â”€ å †åˆ†é…
â”œâ”€â”€ Rc<T>
â”‚   â””â”€â”€ å¼•ç”¨è®¡æ•°
â”œâ”€â”€ Arc<T>
â”‚   â””â”€â”€ åŸå­å¼•ç”¨è®¡æ•°
â”œâ”€â”€ RefCell<T>
â”‚   â””â”€â”€ å†…éƒ¨å¯å˜æ€§
â””â”€â”€ ç»„åˆä½¿ç”¨
    â””â”€â”€ Rc<RefCell<T>>
```

---

## ğŸ“– 1. æ¦‚è¿°

### ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆ?

æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸€ç§è¡Œä¸ºç±»ä¼¼æŒ‡é’ˆä½†æ‹¥æœ‰é¢å¤–å…ƒæ•°æ®å’ŒåŠŸèƒ½çš„æ•°æ®ç»“æ„ã€‚ä¸æ™®é€šå¼•ç”¨ç›¸æ¯”ï¼Œæ™ºèƒ½æŒ‡é’ˆé€šå¸¸ **æ‹¥æœ‰** å®ƒä»¬æŒ‡å‘çš„æ•°æ®ã€‚

**Rust æ ¸å¿ƒæ™ºèƒ½æŒ‡é’ˆ**:

- `Box<T>` - å †åˆ†é…
- `Rc<T>` - å¼•ç”¨è®¡æ•°ï¼ˆå•çº¿ç¨‹ï¼‰
- `Arc<T>` - åŸå­å¼•ç”¨è®¡æ•°ï¼ˆå¤šçº¿ç¨‹ï¼‰
- `RefCell<T>` - å†…éƒ¨å¯å˜æ€§
- `Weak<T>` - å¼±å¼•ç”¨

---

### ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½æŒ‡é’ˆï¼Ÿ

1. **å †åˆ†é…**: æ•°æ®å¤§å°æœªçŸ¥æˆ–éœ€è¦è½¬ç§»æ‰€æœ‰æƒ
2. **å…±äº«æ‰€æœ‰æƒ**: å¤šä¸ªæ‹¥æœ‰è€…å…±äº«æ•°æ®
3. **å†…éƒ¨å¯å˜æ€§**: åœ¨ä¸å¯å˜å¼•ç”¨ä¸‹ä¿®æ”¹æ•°æ®
4. **é˜²æ­¢å†…å­˜æ³„æ¼**: è‡ªåŠ¨ç®¡ç†å¼•ç”¨è®¡æ•°

---

## ğŸ“¦ 2. `Box<T>` - å †åˆ†é…

`Box<T>` æ˜¯æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆï¼Œç”¨äºåœ¨å †ä¸Šåˆ†é…æ•°æ®ã€‚

### åŸºæœ¬ç”¨æ³•

```rust
// å †åˆ†é…å•ä¸ªå€¼
let b = Box::new(5);
println!("b = {}", b);

// é€’å½’ç±»å‹
#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
println!("{:?}", list);
```

**ç‰¹ç‚¹**:

- âœ… å•ä¸€æ‰€æœ‰æƒ
- âœ… è‡ªåŠ¨ Drop
- âœ… é›¶è¿è¡Œæ—¶å¼€é”€ï¼ˆé™¤äº†å †åˆ†é…ï¼‰
- âœ… å®ç°äº† `Deref` å’Œ `DerefMut`

---

### åº”ç”¨åœºæ™¯

#### åœºæ™¯ 1: å¤§å‹æ•°æ®ç»“æ„

```rust
struct LargeStruct {
    data: [u8; 1024 * 1024], // 1MB
}

// é¿å…æ ˆæº¢å‡º
let large = Box::new(LargeStruct {
    data: [0; 1024 * 1024],
});
```

#### åœºæ™¯ 2: é€’å½’ç±»å‹

```rust
// äºŒå‰æ ‘
struct TreeNode {
    value: i32,
    left: Option<Box<TreeNode>>,
    right: Option<Box<TreeNode>>,
}

impl TreeNode {
    fn new(value: i32) -> Self {
        TreeNode {
            value,
            left: None,
            right: None,
        }
    }

    fn insert(&mut self, value: i32) {
        if value < self.value {
            match self.left {
                Some(ref mut node) => node.insert(value),
                None => self.left = Some(Box::new(TreeNode::new(value))),
            }
        } else {
            match self.right {
                Some(ref mut node) => node.insert(value),
                None => self.right = Some(Box::new(TreeNode::new(value))),
            }
        }
    }
}
```

#### åœºæ™¯ 3: Trait å¯¹è±¡

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

// åŠ¨æ€åˆ†å‘
let shapes: Vec<Box<dyn Draw>> = vec![
    Box::new(Circle),
];

for shape in shapes {
    shape.draw();
}
```

---

## ğŸ”— 3. `Rc<T>` - å¼•ç”¨è®¡æ•°

`Rc<T>` (Reference Counted) å…è®¸å¤šä¸ªæ‰€æœ‰è€…å…±äº«æ•°æ®ï¼Œä½† **åªèƒ½åœ¨å•çº¿ç¨‹ä¸­ä½¿ç”¨**ã€‚

### 3.1 åŸºæœ¬ç”¨æ³•

```rust
use std::rc::Rc;

let a = Rc::new(5);
let b = Rc::clone(&a); // å¢åŠ å¼•ç”¨è®¡æ•°
let c = Rc::clone(&a);

println!("count = {}", Rc::strong_count(&a)); // è¾“å‡º: count = 3

// å½“æ‰€æœ‰ Rc ç¦»å¼€ä½œç”¨åŸŸï¼Œæ•°æ®è¢«é‡Šæ”¾
```

**ç‰¹ç‚¹**:

- âœ… å¤šä¸ªæ‰€æœ‰è€…
- âŒ ä¸èƒ½ä¿®æ”¹ï¼ˆä¸å¯å˜ï¼‰
- âŒ ä¸æ˜¯çº¿ç¨‹å®‰å…¨ï¼ˆä½¿ç”¨ Arc ä»£æ›¿ï¼‰
- âœ… è‡ªåŠ¨å¼•ç”¨è®¡æ•°

---

### 3.2 åº”ç”¨åœºæ™¯

#### åœºæ™¯ 1: å›¾æ•°æ®ç»“æ„

```rust
use std::rc::Rc;

struct Node {
    value: i32,
    children: Vec<Rc<Node>>,
}

// å¤šä¸ªçˆ¶èŠ‚ç‚¹å…±äº«å­èŠ‚ç‚¹
let child = Rc::new(Node {
    value: 10,
    children: vec![],
});

let parent1 = Node {
    value: 1,
    children: vec![Rc::clone(&child)],
};

let parent2 = Node {
    value: 2,
    children: vec![Rc::clone(&child)],
};
```

#### åœºæ™¯ 2: å…±äº«é…ç½®

```rust
use std::rc::Rc;

struct Config {
    host: String,
    port: u16,
}

// å¤šä¸ªç»„ä»¶å…±äº«é…ç½®
let config = Rc::new(Config {
    host: "localhost".to_string(),
    port: 8080,
});

let server1 = Rc::clone(&config);
let server2 = Rc::clone(&config);
```

---

## ğŸ” 4. `Arc<T>` - åŸå­å¼•ç”¨è®¡æ•°

`Arc<T>` (Atomically Reference Counted) æ˜¯ `Rc<T>` çš„çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ã€‚

### 4.1 åŸºæœ¬ç”¨æ³•

```rust
use std::sync::Arc;
use std::thread;

let data = Arc::new(vec![1, 2, 3]);

let mut handles = vec![];

for _ in 0..3 {
    let data = Arc::clone(&data);
    let handle = thread::spawn(move |
| {
        println!("Data: {:?}", data);
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
```

**ç‰¹ç‚¹**:

- âœ… å¤šä¸ªæ‰€æœ‰è€…
- âœ… çº¿ç¨‹å®‰å…¨
- âŒ ä¸èƒ½ä¿®æ”¹ï¼ˆéœ€é…åˆ Mutex/RwLockï¼‰
- âš ï¸ æ€§èƒ½å¼€é”€ï¼ˆåŸå­æ“ä½œï¼‰

---

### 4.2 åº”ç”¨åœºæ™¯

#### åœºæ™¯ 1: å¤šçº¿ç¨‹å…±äº«æ•°æ®

```rust
use std::sync::Arc;
use std::thread;

let numbers = Arc::new(vec![1, 2, 3, 4, 5]);

let handles: Vec<_> = (0..3)
    .map(|i| {
        let numbers = Arc::clone(&numbers);
        thread::spawn(move |
| {
            let sum: i32 = numbers.iter().sum();
            println!("Thread {}: sum = {}", i, sum);
        })
    })
    .collect();

for handle in handles {
    handle.join().unwrap();
}
```

#### åœºæ™¯ 2: å¹¶å‘ç¼“å­˜

```rust
use std::collections::HashMap;
use std::sync::Arc;

struct Cache {
    data: HashMap<String, String>,
}

// å¤šä¸ªçº¿ç¨‹å…±äº«ç¼“å­˜ï¼ˆåªè¯»ï¼‰
let cache = Arc::new(Cache {
    data: HashMap::new(),
});

let cache1 = Arc::clone(&cache);
let cache2 = Arc::clone(&cache);
```

---

## ğŸ§¬ 5. `RefCell<T>` - å†…éƒ¨å¯å˜æ€§

`RefCell<T>` å…è®¸åœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™ï¼Œå®ç°å†…éƒ¨å¯å˜æ€§ã€‚

### 5.1 åŸºæœ¬ç”¨æ³•

```rust
use std::cell::RefCell;

let data = RefCell::new(5);

// å¯å˜å€Ÿç”¨
*data.borrow_mut() += 1;

// ä¸å¯å˜å€Ÿç”¨
println!("data = {}", data.borrow());

// è¿è¡Œæ—¶ panicï¼ˆè¿åå€Ÿç”¨è§„åˆ™ï¼‰
// let r1 = data.borrow_mut();
// let r2 = data.borrow_mut(); // panic!
```

**ç‰¹ç‚¹**:

- âœ… å†…éƒ¨å¯å˜æ€§
- âš ï¸ è¿è¡Œæ—¶æ£€æŸ¥ï¼ˆå¯èƒ½ panicï¼‰
- âŒ ä¸æ˜¯çº¿ç¨‹å®‰å…¨
- âœ… å•çº¿ç¨‹åœºæ™¯

---

### 5.2 åº”ç”¨åœºæ™¯

#### åœºæ™¯ 1: Mock æµ‹è¯•

```rust
use std::cell::RefCell;

struct Counter {
    count: RefCell<i32>,
}

impl Counter {
    fn new() -> Self {
        Counter {
            count: RefCell::new(0),
        }
    }

    // åœ¨ä¸å¯å˜æ–¹æ³•ä¸­ä¿®æ”¹
    fn increment(&self) {
        *self.count.borrow_mut() += 1;
    }

    fn get(&self) -> i32 {
        *self.count.borrow()
    }
}

let counter = Counter::new();
counter.increment(); // &self æ–¹æ³•
counter.increment();
println!("count = {}", counter.get());
```

#### åœºæ™¯ 2: è§‚å¯Ÿè€…æ¨¡å¼

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Observable {
    observers: RefCell<Vec<Rc<dyn Observer>>>,
}

trait Observer {
    fn update(&self);
}

impl Observable {
    fn subscribe(&self, observer: Rc<dyn Observer>) {
        self.observers.borrow_mut().push(observer);
    }

    fn notify(&self) {
        for observer in self.observers.borrow().iter() {
            observer.update();
        }
    }
}
```

---

## ğŸ”„ 6. ç»„åˆä½¿ç”¨

### `Rc<RefCell<T>>`

**ç”¨é€”**: å•çº¿ç¨‹ä¸­çš„å¤šä¸ªæ‰€æœ‰è€… + å¯å˜æ€§

```rust
use std::cell::RefCell;
use std::rc::Rc;

let data = Rc::new(RefCell::new(5));

// å¤šä¸ªæ‰€æœ‰è€…
let data1 = Rc::clone(&data);
let data2 = Rc::clone(&data);

// å¯å˜ä¿®æ”¹
*data1.borrow_mut() += 10;
*data2.borrow_mut() += 20;

println!("data = {}", data.borrow()); // 35
```

**åº”ç”¨**: å›¾ã€æ ‘ã€è§‚å¯Ÿè€…æ¨¡å¼

---

### `Arc<Mutex<T>>`

**ç”¨é€”**: å¤šçº¿ç¨‹ä¸­çš„å¤šä¸ªæ‰€æœ‰è€… + å¯å˜æ€§

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let counter = Arc::new(Mutex::new(0));

let mut handles = vec![];

for _ in 0..10 {
    let counter = Arc::clone(&counter);
    let handle = thread::spawn(move |
| {
        let mut num = counter.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *counter.lock().unwrap());
```

**åº”ç”¨**: å¹¶å‘è®¡æ•°å™¨ã€å…±äº«çŠ¶æ€

---

## âš ï¸ 7. å¸¸è§é™·é˜±

### é™·é˜± 1: å¾ªç¯å¼•ç”¨

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Node {
    next: Option<Rc<RefCell<Node>>>,
}

// âŒ å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼
let a = Rc::new(RefCell::new(Node { next: None }));
let b = Rc::new(RefCell::new(Node { next: Some(Rc::clone(&a)) }));
a.borrow_mut().next = Some(Rc::clone(&b)); // å¾ªç¯

// âœ… ä½¿ç”¨ Weak æ‰“ç ´å¾ªç¯
use std::rc::Weak;

struct SafeNode {
    next: Option<Weak<RefCell<SafeNode>>>,
}
```

---

### é™·é˜± 2: RefCell panic

```rust
use std::cell::RefCell;

let data = RefCell::new(5);

// âŒ åŒæ—¶å­˜åœ¨å¯å˜å’Œä¸å¯å˜å€Ÿç”¨
let r1 = data.borrow_mut();
// let r2 = data.borrow(); // panic at runtime!

// âœ… ç¡®ä¿å€Ÿç”¨ä¸é‡å 
drop(r1);
let r2 = data.borrow();
```

---

### é™·é˜± 3: Arc æ€§èƒ½

```rust
// âŒ é¢‘ç¹ clone
for _ in 0..1000000 {
    let arc = Arc::new(42);
    // Arc clone æœ‰åŸå­æ“ä½œå¼€é”€
}

// âœ… å¤ç”¨ Arc
let arc = Arc::new(42);
for _ in 0..1000000 {
    let _clone = Arc::clone(&arc);
}
```

---

## âœ… 8. æœ€ä½³å®è·µ

### é€‰æ‹©æŒ‡å—

```text
éœ€è¦å…±äº«æ‰€æœ‰æƒï¼Ÿ
â”œâ”€ å¦ â†’ ä½¿ç”¨ Box<T>
â””â”€ æ˜¯
   â”œâ”€ å•çº¿ç¨‹ï¼Ÿ
   â”‚  â”œâ”€ éœ€è¦å¯å˜ï¼Ÿ
   â”‚  â”‚  â””â”€ ä½¿ç”¨ Rc<RefCell<T>>
   â”‚  â””â”€ åªè¯»
   â”‚     â””â”€ ä½¿ç”¨ Rc<T>
   â””â”€ å¤šçº¿ç¨‹
      â”œâ”€ éœ€è¦å¯å˜ï¼Ÿ
      â”‚  â””â”€ ä½¿ç”¨ Arc<Mutex<T>> æˆ– Arc<RwLock<T>>
      â””â”€ åªè¯»
         â””â”€ ä½¿ç”¨ Arc<T>
```

---

### å®è·µå»ºè®®

1. **ä¼˜å…ˆä½¿ç”¨æ‰€æœ‰æƒ**: åªåœ¨å¿…è¦æ—¶ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
2. **Box ä¼˜å…ˆ**: ç®€å•å †åˆ†é…é¦–é€‰ Box
3. **é¿å…å¾ªç¯å¼•ç”¨**: ä½¿ç”¨ Weak æ‰“ç ´å¾ªç¯
4. **å‡å°‘ clone**: ç‰¹åˆ«æ˜¯ Arc
5. **å°å¿ƒ RefCell**: ç¡®ä¿è¿è¡Œæ—¶å€Ÿç”¨è§„åˆ™
6. **æ€§èƒ½è€ƒè™‘**: Arc > Rc > Box (å¼€é”€)

---

## ğŸ“š 9. å»¶ä¼¸é˜…è¯»

- **å‚è€ƒæ–‡æ¡£**: [Tier 3: 05\_æ™ºèƒ½æŒ‡é’ˆAPIå‚è€ƒ](../tier_03_references/05_æ™ºèƒ½æŒ‡é’ˆAPIå‚è€ƒ.md)
- **é«˜çº§ä¸»é¢˜**: [Tier 4: 02\_è‡ªå¼•ç”¨ç»“æ„](../tier_04_advanced/02_è‡ªå¼•ç”¨ç»“æ„.md)
- **å®˜æ–¹æ–‡æ¡£**: [Smart Pointers - The Rust Book](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)

---

**ä¸‹ä¸€æ­¥**: å®Œæˆæœ¬æ–‡æ¡£åï¼Œè¿›å…¥ [Tier 3 æŠ€æœ¯å‚è€ƒå±‚](../tier_03_references/) æ·±å…¥å­¦ä¹ ï¼

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
