# Tier 2: 智能指针实践指南

> **文档类型**: 实践指南  
> **难度级别**: ⭐⭐⭐ 中级  
> **预计学习时间**: 3-4 小时  
> **前置知识**: 完成 Tier 2 前 4 篇文档

---

## 目录

- [Tier 2: 智能指针实践指南](#tier-2-智能指针实践指南)
  - [目录](#目录)
  - [📖 1. 概述](#-1-概述)
    - [什么是智能指针?](#什么是智能指针)
    - [为什么需要智能指针？](#为什么需要智能指针)
  - [📦 2. `Box<T>` - 堆分配](#-2-boxt---堆分配)
    - [基本用法](#基本用法)
    - [应用场景](#应用场景)
      - [场景 1: 大型数据结构](#场景-1-大型数据结构)
      - [场景 2: 递归类型](#场景-2-递归类型)
      - [场景 3: Trait 对象](#场景-3-trait-对象)
  - [🔗 3. `Rc<T>` - 引用计数](#-3-rct---引用计数)
    - [3.1 基本用法](#31-基本用法)
    - [3.2 应用场景](#32-应用场景)
      - [场景 1: 图数据结构](#场景-1-图数据结构)
      - [场景 2: 共享配置](#场景-2-共享配置)
  - [🔐 4. `Arc<T>` - 原子引用计数](#-4-arct---原子引用计数)
    - [4.1 基本用法](#41-基本用法)
    - [4.2 应用场景](#42-应用场景)
      - [场景 1: 多线程共享数据](#场景-1-多线程共享数据)
      - [场景 2: 并发缓存](#场景-2-并发缓存)
  - [🧬 5. `RefCell<T>` - 内部可变性](#-5-refcellt---内部可变性)
    - [5.1 基本用法](#51-基本用法)
    - [5.2 应用场景](#52-应用场景)
      - [场景 1: Mock 测试](#场景-1-mock-测试)
      - [场景 2: 观察者模式](#场景-2-观察者模式)
  - [🔄 6. 组合使用](#-6-组合使用)
    - [`Rc<RefCell<T>>`](#rcrefcellt)
    - [`Arc<Mutex<T>>`](#arcmutext)
  - [⚠️ 7. 常见陷阱](#️-7-常见陷阱)
    - [陷阱 1: 循环引用](#陷阱-1-循环引用)
    - [陷阱 2: RefCell panic](#陷阱-2-refcell-panic)
    - [陷阱 3: Arc 性能](#陷阱-3-arc-性能)
  - [✅ 8. 最佳实践](#-8-最佳实践)
    - [选择指南](#选择指南)
    - [实践建议](#实践建议)
  - [📚 9. 延伸阅读](#-9-延伸阅读)

---

## 📖 1. 概述

### 什么是智能指针?

智能指针是一种行为类似指针但拥有额外元数据和功能的数据结构。与普通引用相比，智能指针通常 **拥有** 它们指向的数据。

**Rust 核心智能指针**:

- `Box<T>` - 堆分配
- `Rc<T>` - 引用计数（单线程）
- `Arc<T>` - 原子引用计数（多线程）
- `RefCell<T>` - 内部可变性
- `Weak<T>` - 弱引用

---

### 为什么需要智能指针？

1. **堆分配**: 数据大小未知或需要转移所有权
2. **共享所有权**: 多个拥有者共享数据
3. **内部可变性**: 在不可变引用下修改数据
4. **防止内存泄漏**: 自动管理引用计数

---

## 📦 2. `Box<T>` - 堆分配

`Box<T>` 是最简单的智能指针，用于在堆上分配数据。

### 基本用法

```rust
// 堆分配单个值
let b = Box::new(5);
println!("b = {}", b);

// 递归类型
#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
println!("{:?}", list);
```

**特点**:

- ✅ 单一所有权
- ✅ 自动 Drop
- ✅ 零运行时开销（除了堆分配）
- ✅ 实现了 `Deref` 和 `DerefMut`

---

### 应用场景

#### 场景 1: 大型数据结构

```rust
struct LargeStruct {
    data: [u8; 1024 * 1024], // 1MB
}

// 避免栈溢出
let large = Box::new(LargeStruct {
    data: [0; 1024 * 1024],
});
```

#### 场景 2: 递归类型

```rust
// 二叉树
struct TreeNode {
    value: i32,
    left: Option<Box<TreeNode>>,
    right: Option<Box<TreeNode>>,
}

impl TreeNode {
    fn new(value: i32) -> Self {
        TreeNode {
            value,
            left: None,
            right: None,
        }
    }

    fn insert(&mut self, value: i32) {
        if value < self.value {
            match self.left {
                Some(ref mut node) => node.insert(value),
                None => self.left = Some(Box::new(TreeNode::new(value))),
            }
        } else {
            match self.right {
                Some(ref mut node) => node.insert(value),
                None => self.right = Some(Box::new(TreeNode::new(value))),
            }
        }
    }
}
```

#### 场景 3: Trait 对象

```rust
trait Draw {
    fn draw(&self);
}

struct Circle;
impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

// 动态分发
let shapes: Vec<Box<dyn Draw>> = vec![
    Box::new(Circle),
];

for shape in shapes {
    shape.draw();
}
```

---

## 🔗 3. `Rc<T>` - 引用计数

`Rc<T>` (Reference Counted) 允许多个所有者共享数据，但 **只能在单线程中使用**。

### 3.1 基本用法

```rust
use std::rc::Rc;

let a = Rc::new(5);
let b = Rc::clone(&a); // 增加引用计数
let c = Rc::clone(&a);

println!("count = {}", Rc::strong_count(&a)); // 输出: count = 3

// 当所有 Rc 离开作用域，数据被释放
```

**特点**:

- ✅ 多个所有者
- ❌ 不能修改（不可变）
- ❌ 不是线程安全（使用 Arc 代替）
- ✅ 自动引用计数

---

### 3.2 应用场景

#### 场景 1: 图数据结构

```rust
use std::rc::Rc;

struct Node {
    value: i32,
    children: Vec<Rc<Node>>,
}

// 多个父节点共享子节点
let child = Rc::new(Node {
    value: 10,
    children: vec![],
});

let parent1 = Node {
    value: 1,
    children: vec![Rc::clone(&child)],
};

let parent2 = Node {
    value: 2,
    children: vec![Rc::clone(&child)],
};
```

#### 场景 2: 共享配置

```rust
use std::rc::Rc;

struct Config {
    host: String,
    port: u16,
}

// 多个组件共享配置
let config = Rc::new(Config {
    host: "localhost".to_string(),
    port: 8080,
});

let server1 = Rc::clone(&config);
let server2 = Rc::clone(&config);
```

---

## 🔐 4. `Arc<T>` - 原子引用计数

`Arc<T>` (Atomically Reference Counted) 是 `Rc<T>` 的线程安全版本。

### 4.1 基本用法

```rust
use std::sync::Arc;
use std::thread;

let data = Arc::new(vec![1, 2, 3]);

let mut handles = vec![];

for _ in 0..3 {
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        println!("Data: {:?}", data);
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
```

**特点**:

- ✅ 多个所有者
- ✅ 线程安全
- ❌ 不能修改（需配合 Mutex/RwLock）
- ⚠️ 性能开销（原子操作）

---

### 4.2 应用场景

#### 场景 1: 多线程共享数据

```rust
use std::sync::Arc;
use std::thread;

let numbers = Arc::new(vec![1, 2, 3, 4, 5]);

let handles: Vec<_> = (0..3)
    .map(|i| {
        let numbers = Arc::clone(&numbers);
        thread::spawn(move || {
            let sum: i32 = numbers.iter().sum();
            println!("Thread {}: sum = {}", i, sum);
        })
    })
    .collect();

for handle in handles {
    handle.join().unwrap();
}
```

#### 场景 2: 并发缓存

```rust
use std::collections::HashMap;
use std::sync::Arc;

struct Cache {
    data: HashMap<String, String>,
}

// 多个线程共享缓存（只读）
let cache = Arc::new(Cache {
    data: HashMap::new(),
});

let cache1 = Arc::clone(&cache);
let cache2 = Arc::clone(&cache);
```

---

## 🧬 5. `RefCell<T>` - 内部可变性

`RefCell<T>` 允许在运行时检查借用规则，实现内部可变性。

### 5.1 基本用法

```rust
use std::cell::RefCell;

let data = RefCell::new(5);

// 可变借用
*data.borrow_mut() += 1;

// 不可变借用
println!("data = {}", data.borrow());

// 运行时 panic（违反借用规则）
// let r1 = data.borrow_mut();
// let r2 = data.borrow_mut(); // panic!
```

**特点**:

- ✅ 内部可变性
- ⚠️ 运行时检查（可能 panic）
- ❌ 不是线程安全
- ✅ 单线程场景

---

### 5.2 应用场景

#### 场景 1: Mock 测试

```rust
use std::cell::RefCell;

struct Counter {
    count: RefCell<i32>,
}

impl Counter {
    fn new() -> Self {
        Counter {
            count: RefCell::new(0),
        }
    }

    // 在不可变方法中修改
    fn increment(&self) {
        *self.count.borrow_mut() += 1;
    }

    fn get(&self) -> i32 {
        *self.count.borrow()
    }
}

let counter = Counter::new();
counter.increment(); // &self 方法
counter.increment();
println!("count = {}", counter.get());
```

#### 场景 2: 观察者模式

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Observable {
    observers: RefCell<Vec<Rc<dyn Observer>>>,
}

trait Observer {
    fn update(&self);
}

impl Observable {
    fn subscribe(&self, observer: Rc<dyn Observer>) {
        self.observers.borrow_mut().push(observer);
    }

    fn notify(&self) {
        for observer in self.observers.borrow().iter() {
            observer.update();
        }
    }
}
```

---

## 🔄 6. 组合使用

### `Rc<RefCell<T>>`

**用途**: 单线程中的多个所有者 + 可变性

```rust
use std::cell::RefCell;
use std::rc::Rc;

let data = Rc::new(RefCell::new(5));

// 多个所有者
let data1 = Rc::clone(&data);
let data2 = Rc::clone(&data);

// 可变修改
*data1.borrow_mut() += 10;
*data2.borrow_mut() += 20;

println!("data = {}", data.borrow()); // 35
```

**应用**: 图、树、观察者模式

---

### `Arc<Mutex<T>>`

**用途**: 多线程中的多个所有者 + 可变性

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let counter = Arc::new(Mutex::new(0));

let mut handles = vec![];

for _ in 0..10 {
    let counter = Arc::clone(&counter);
    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *counter.lock().unwrap());
```

**应用**: 并发计数器、共享状态

---

## ⚠️ 7. 常见陷阱

### 陷阱 1: 循环引用

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Node {
    next: Option<Rc<RefCell<Node>>>,
}

// ❌ 循环引用导致内存泄漏
let a = Rc::new(RefCell::new(Node { next: None }));
let b = Rc::new(RefCell::new(Node { next: Some(Rc::clone(&a)) }));
a.borrow_mut().next = Some(Rc::clone(&b)); // 循环

// ✅ 使用 Weak 打破循环
use std::rc::Weak;

struct SafeNode {
    next: Option<Weak<RefCell<SafeNode>>>,
}
```

---

### 陷阱 2: RefCell panic

```rust
use std::cell::RefCell;

let data = RefCell::new(5);

// ❌ 同时存在可变和不可变借用
let r1 = data.borrow_mut();
// let r2 = data.borrow(); // panic at runtime!

// ✅ 确保借用不重叠
drop(r1);
let r2 = data.borrow();
```

---

### 陷阱 3: Arc 性能

```rust
// ❌ 频繁 clone
for _ in 0..1000000 {
    let arc = Arc::new(42);
    // Arc clone 有原子操作开销
}

// ✅ 复用 Arc
let arc = Arc::new(42);
for _ in 0..1000000 {
    let _clone = Arc::clone(&arc);
}
```

---

## ✅ 8. 最佳实践

### 选择指南

```text
需要共享所有权？
├─ 否 → 使用 Box<T>
└─ 是
   ├─ 单线程？
   │  ├─ 需要可变？
   │  │  └─ 使用 Rc<RefCell<T>>
   │  └─ 只读
   │     └─ 使用 Rc<T>
   └─ 多线程
      ├─ 需要可变？
      │  └─ 使用 Arc<Mutex<T>> 或 Arc<RwLock<T>>
      └─ 只读
         └─ 使用 Arc<T>
```

---

### 实践建议

1. **优先使用所有权**: 只在必要时使用智能指针
2. **Box 优先**: 简单堆分配首选 Box
3. **避免循环引用**: 使用 Weak 打破循环
4. **减少 clone**: 特别是 Arc
5. **小心 RefCell**: 确保运行时借用规则
6. **性能考虑**: Arc > Rc > Box (开销)

---

## 📚 9. 延伸阅读

- **参考文档**: [Tier 3: 05_智能指针API参考](../tier_03_references/05_智能指针API参考.md)
- **高级主题**: [Tier 4: 02_自引用结构](../tier_04_advanced/02_自引用结构.md)
- **官方文档**: [Smart Pointers - The Rust Book](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)

---

**下一步**: 完成本文档后，进入 [Tier 3 技术参考层](../tier_03_references/) 深入学习！

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
