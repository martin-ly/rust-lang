# ğŸš€ C01: Ownership & Borrow - å®æˆ˜é¡¹ç›®é›†

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C01 æ‰€æœ‰æƒã€å€Ÿç”¨å’Œä½œç”¨åŸŸ
> **ç›®æ ‡**: é€šè¿‡å®æˆ˜é¡¹ç›®æ·±å…¥ç†è§£ Rust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨æœºåˆ¶

---

## ç›®å½•

- [ğŸš€ C01: Ownership \& Borrow - å®æˆ˜é¡¹ç›®é›†](#-c01-ownership--borrow---å®æˆ˜é¡¹ç›®é›†)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ](#-é¡¹ç›®æ¦‚è§ˆ)
  - [é¡¹ç›®1: ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ](#é¡¹ç›®1-ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ)
    - [ğŸ“– é¡¹ç›®è¯´æ˜](#-é¡¹ç›®è¯´æ˜)
    - [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
    - [åŠŸèƒ½éœ€æ±‚](#åŠŸèƒ½éœ€æ±‚)
      - [åŸºç¡€åŠŸèƒ½](#åŸºç¡€åŠŸèƒ½)
      - [è¿›é˜¶åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰](#è¿›é˜¶åŠŸèƒ½å¯é€‰)
    - [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
    - [æ ¸å¿ƒä»£ç å®ç°](#æ ¸å¿ƒä»£ç å®ç°)
      - [`simple_box.rs`](#simple_boxrs)
      - [`main.rs`](#mainrs)
    - [æµ‹è¯•æ–¹å¼](#æµ‹è¯•æ–¹å¼)
    - [é¢„æœŸè¾“å‡º](#é¢„æœŸè¾“å‡º)
    - [å…³é”®çŸ¥è¯†ç‚¹](#å…³é”®çŸ¥è¯†ç‚¹)
    - [æ‰©å±•æ–¹å‘](#æ‰©å±•æ–¹å‘)
  - [é¡¹ç›®2: å­—ç¬¦ä¸²å¤„ç†å·¥å…·](#é¡¹ç›®2-å­—ç¬¦ä¸²å¤„ç†å·¥å…·)
    - [ğŸ“– é¡¹ç›®è¯´æ˜2](#-é¡¹ç›®è¯´æ˜2)
    - [å­¦ä¹ ç›®æ ‡2](#å­¦ä¹ ç›®æ ‡2)
    - [åŠŸèƒ½éœ€æ±‚2](#åŠŸèƒ½éœ€æ±‚2)
      - [åŸºç¡€åŠŸèƒ½2](#åŸºç¡€åŠŸèƒ½2)
      - [è¿›é˜¶åŠŸèƒ½2](#è¿›é˜¶åŠŸèƒ½2)
    - [é¡¹ç›®ç»“æ„2](#é¡¹ç›®ç»“æ„2)
    - [æ ¸å¿ƒä»£ç å®ç°2](#æ ¸å¿ƒä»£ç å®ç°2)
      - [`lib.rs`](#librs)
      - [`main.rs`-](#mainrs-)
    - [æµ‹è¯•æ–¹å¼-](#æµ‹è¯•æ–¹å¼-)
    - [é¢„æœŸè¾“å‡º-](#é¢„æœŸè¾“å‡º-)
    - [å…³é”®çŸ¥è¯†ç‚¹-](#å…³é”®çŸ¥è¯†ç‚¹-)
    - [æ‰©å±•æ–¹å‘-](#æ‰©å±•æ–¹å‘-)
  - [é¡¹ç›®3: å¼•ç”¨è®¡æ•°å®¹å™¨](#é¡¹ç›®3-å¼•ç”¨è®¡æ•°å®¹å™¨)
    - [ğŸ“– é¡¹ç›®è¯´æ˜3](#-é¡¹ç›®è¯´æ˜3)
    - [å­¦ä¹ ç›®æ ‡3](#å­¦ä¹ ç›®æ ‡3)
    - [åŠŸèƒ½éœ€æ±‚3](#åŠŸèƒ½éœ€æ±‚3)
      - [åŸºç¡€åŠŸèƒ½3](#åŸºç¡€åŠŸèƒ½3)
      - [è¿›é˜¶åŠŸèƒ½3](#è¿›é˜¶åŠŸèƒ½3)
    - [é¡¹ç›®ç»“æ„3](#é¡¹ç›®ç»“æ„3)
    - [æ ¸å¿ƒä»£ç å®ç°3](#æ ¸å¿ƒä»£ç å®ç°3)
      - [`container.rs`](#containerrs)
      - [`main.rs`--](#mainrs--)
    - [æµ‹è¯•æ–¹å¼3](#æµ‹è¯•æ–¹å¼3)
    - [é¢„æœŸè¾“å‡º3](#é¢„æœŸè¾“å‡º3)
    - [å…³é”®çŸ¥è¯†ç‚¹3](#å…³é”®çŸ¥è¯†ç‚¹3)
    - [æ‰©å±•æ–¹å‘3](#æ‰©å±•æ–¹å‘3)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [é¡¹ç›®éš¾åº¦é€’è¿›](#é¡¹ç›®éš¾åº¦é€’è¿›)
    - [æ ¸å¿ƒæ¦‚å¿µå¯¹åº”](#æ ¸å¿ƒæ¦‚å¿µå¯¹åº”)
    - [å­¦ä¹ å»ºè®®](#å­¦ä¹ å»ºè®®)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

æœ¬æ–‡æ¡£æä¾›äº† **3ä¸ªç²¾å¿ƒè®¾è®¡çš„å®æˆ˜é¡¹ç›®**ï¼Œä»å…¥é—¨åˆ°è¿›é˜¶ï¼Œå¸®åŠ©ä½ åœ¨å®è·µä¸­æŒæ¡ Rust çš„æ ¸å¿ƒæ¦‚å¿µã€‚

| #   | é¡¹ç›®åç§°                                | éš¾åº¦   | é¢„è®¡æ—¶é—´ | æ ¸å¿ƒæ¦‚å¿µ             |
| :--- | :--- | :--- | :--- | :--- |
| 1   | [ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ](#é¡¹ç›®1-ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ) | â­     | 1-2å°æ—¶  | æ‰€æœ‰æƒè½¬ç§»ã€Drop     |
| 2   | [å­—ç¬¦ä¸²å¤„ç†å·¥å…·](#é¡¹ç›®2-å­—ç¬¦ä¸²å¤„ç†å·¥å…·) | â­â­   | 2-3å°æ—¶  | å€Ÿç”¨ã€åˆ‡ç‰‡ã€ç”Ÿå‘½å‘¨æœŸ |
| 3   | [å¼•ç”¨è®¡æ•°å®¹å™¨](#é¡¹ç›®3-å¼•ç”¨è®¡æ•°å®¹å™¨)     | â­â­â­ | 3-4å°æ—¶  | RefCellã€å†…éƒ¨å¯å˜æ€§  |

---

## é¡¹ç›®1: ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­
**é¢„è®¡æ—¶é—´**: 1-2å°æ—¶
**ç›®æ ‡**: ç†è§£æ‰€æœ‰æƒè½¬ç§»å’Œ Drop trait

### å­¦ä¹ ç›®æ ‡

1. ç†è§£æ‰€æœ‰æƒçš„ç§»åŠ¨è¯­ä¹‰
2. å®ç°è‡ªå®šä¹‰ Drop trait
3. æŒæ¡å †å†…å­˜åˆ†é…
4. ç†è§£ RAII æ¨¡å¼

### åŠŸèƒ½éœ€æ±‚

#### åŸºç¡€åŠŸèƒ½

1. åˆ›å»ºä¸€ä¸ªç®€å•çš„ `Box` å°è£…
2. æ”¯æŒåˆ›å»ºã€è®¿é—®æ•°æ®
3. è‡ªåŠ¨é‡Šæ”¾å†…å­˜
4. è¿½è¸ªå†…å­˜åˆ†é…å’Œé‡Šæ”¾

#### è¿›é˜¶åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰

1. å®ç° `Deref` trait
2. å®ç° `DerefMut` trait
3. æ·»åŠ ç»Ÿè®¡åŠŸèƒ½

### é¡¹ç›®ç»“æ„

```text
simple_box/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â””â”€â”€ simple_box.rs
```

### æ ¸å¿ƒä»£ç å®ç°

#### `simple_box.rs`

```rust
use std::fmt;

/// ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆå®ç°
pub struct SimpleBox<T> {
    data: *mut T,  // åŸå§‹æŒ‡é’ˆ
}

impl<T> SimpleBox<T> {
    /// åˆ›å»ºæ–°çš„ SimpleBox
    pub fn new(value: T) -> Self {
        // åˆ†é…å †å†…å­˜
        let ptr = Box::into_raw(Box::new(value));
        println!("ğŸ“¦ SimpleBox åˆ›å»º: åˆ†é…å†…å­˜ {:p}", ptr);

        SimpleBox { data: ptr }
    }

    /// è·å–ä¸å¯å˜å¼•ç”¨
    pub fn get(&self) -> &T {
        unsafe { &*self.data }
    }

    /// è·å–å¯å˜å¼•ç”¨
    pub fn get_mut(&mut self) -> &mut T {
        unsafe { &mut *self.data }
    }

    /// è§£æ„å¹¶è¿”å›å†…éƒ¨å€¼
    pub fn into_inner(self) -> T {
        let value = unsafe { Box::from_raw(self.data) };
        std::mem::forget(self);  // é˜²æ­¢ Drop
        *value
    }
}

// å®ç° Drop trait - RAII æ¨¡å¼
impl<T> Drop for SimpleBox<T> {
    fn drop(&mut self) {
        println!("ğŸ—‘ï¸  SimpleBox é”€æ¯: é‡Šæ”¾å†…å­˜ {:p}", self.data);
        unsafe {
            // ä»åŸå§‹æŒ‡é’ˆæ¢å¤ Boxï¼Œç„¶åè‡ªåŠ¨ drop
            let _ = Box::from_raw(self.data);
        }
    }
}

// å®ç° Debug trait
impl<T: fmt::Debug> fmt::Debug for SimpleBox<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SimpleBox({:?})", self.get())
    }
}

// å®ç° Deref trait (è¿›é˜¶)
use std::ops::Deref;

impl<T> Deref for SimpleBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.get()
    }
}

// å®ç° DerefMut trait (è¿›é˜¶)
use std::ops::DerefMut;

impl<T> DerefMut for SimpleBox<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.get_mut()
    }
}
```

#### `main.rs`

```rust
mod simple_box;
use simple_box::SimpleBox;

fn main() {
    println!("===== SimpleBox æµ‹è¯• =====\n");

    // æµ‹è¯•1: åŸºç¡€åˆ›å»ºå’Œè®¿é—®
    {
        println!("æµ‹è¯•1: åŸºç¡€åˆ›å»ºå’Œè®¿é—®");
        let boxed = SimpleBox::new(42);
        println!("å€¼: {}", boxed.get());
        println!("Debug: {:?}\n", boxed);
    } // boxed åœ¨è¿™é‡Œè¢« drop

    // æµ‹è¯•2: å¯å˜è®¿é—®
    {
        println!("æµ‹è¯•2: å¯å˜è®¿é—®");
        let mut boxed = SimpleBox::new(String::from("Hello"));
        println!("åŸå§‹å€¼: {}", boxed.get());

        boxed.get_mut().push_str(", World!");
        println!("ä¿®æ”¹å: {}\n", boxed.get());
    }

    // æµ‹è¯•3: æ‰€æœ‰æƒè½¬ç§»
    {
        println!("æµ‹è¯•3: æ‰€æœ‰æƒè½¬ç§»");
        let boxed = SimpleBox::new(vec![1, 2, 3]);

        // è½¬ç§»æ‰€æœ‰æƒ
        let moved = take_ownership(boxed);
        println!("è¿”å›çš„å€¼: {:?}\n", moved);
    }

    // æµ‹è¯•4: Deref trait
    {
        println!("æµ‹è¯•4: Deref è‡ªåŠ¨è§£å¼•ç”¨");
        let boxed = SimpleBox::new(String::from("Rust"));

        // é€šè¿‡ Deref è‡ªåŠ¨è§£å¼•ç”¨
        println!("é•¿åº¦: {}", boxed.len());  // String::len()
        println!("å¤§å†™: {}\n", boxed.to_uppercase());
    }

    // æµ‹è¯•5: into_inner
    {
        println!("æµ‹è¯•5: è§£æ„");
        let boxed = SimpleBox::new(100);
        let value = boxed.into_inner();
        println!("æå–çš„å€¼: {}\n", value);
        // boxed ä¸ä¼šè¢« dropï¼Œå› ä¸ºä½¿ç”¨äº† mem::forget
    }

    println!("===== ç¨‹åºç»“æŸ =====");
}

fn take_ownership(boxed: SimpleBox<Vec<i32>>) -> Vec<i32> {
    boxed.into_inner()
}
```

### æµ‹è¯•æ–¹å¼

```bash
cargo new simple_box
cd simple_box
# å¤åˆ¶ä¸Šè¿°ä»£ç 
cargo run
```

### é¢„æœŸè¾“å‡º

```text
===== SimpleBox æµ‹è¯• =====

æµ‹è¯•1: åŸºç¡€åˆ›å»ºå’Œè®¿é—®
ğŸ“¦ SimpleBox åˆ›å»º: åˆ†é…å†…å­˜ 0x...
å€¼: 42
Debug: SimpleBox(42)
ğŸ—‘ï¸  SimpleBox é”€æ¯: é‡Šæ”¾å†…å­˜ 0x...

æµ‹è¯•2: å¯å˜è®¿é—®
ğŸ“¦ SimpleBox åˆ›å»º: åˆ†é…å†…å­˜ 0x...
åŸå§‹å€¼: Hello
ä¿®æ”¹å: Hello, World!
ğŸ—‘ï¸  SimpleBox é”€æ¯: é‡Šæ”¾å†…å­˜ 0x...

æµ‹è¯•3: æ‰€æœ‰æƒè½¬ç§»
ğŸ“¦ SimpleBox åˆ›å»º: åˆ†é…å†…å­˜ 0x...
è¿”å›çš„å€¼: [1, 2, 3]

æµ‹è¯•4: Deref è‡ªåŠ¨è§£å¼•ç”¨
ğŸ“¦ SimpleBox åˆ›å»º: åˆ†é…å†…å­˜ 0x...
é•¿åº¦: 4
å¤§å†™: RUST
ğŸ—‘ï¸  SimpleBox é”€æ¯: é‡Šæ”¾å†…å­˜ 0x...

æµ‹è¯•5: è§£æ„
ğŸ“¦ SimpleBox åˆ›å»º: åˆ†é…å†…å­˜ 0x...
æå–çš„å€¼: 100

===== ç¨‹åºç»“æŸ =====
```

### å…³é”®çŸ¥è¯†ç‚¹

1. **æ‰€æœ‰æƒè½¬ç§»**: `SimpleBox` æ‹¥æœ‰å †ä¸Šæ•°æ®çš„æ‰€æœ‰æƒ
2. **RAII**: é€šè¿‡ `Drop` trait è‡ªåŠ¨é‡Šæ”¾èµ„æº
3. **åŸå§‹æŒ‡é’ˆ**: ä½¿ç”¨ `*mut T` å­˜å‚¨æ•°æ®
4. **Deref**: å®ç°è‡ªåŠ¨è§£å¼•ç”¨ï¼Œæ›´æ–¹ä¾¿ä½¿ç”¨
5. **å†…å­˜å®‰å…¨**: é˜²æ­¢åŒé‡é‡Šæ”¾å’Œå†…å­˜æ³„æ¼

### æ‰©å±•æ–¹å‘

1. æ·»åŠ å¼•ç”¨è®¡æ•°ï¼ˆç±»ä¼¼ `Rc`ï¼‰
2. å®ç° `Clone` trait
3. æ·»åŠ å†…å­˜ç»Ÿè®¡åŠŸèƒ½
4. å®ç°å¼±å¼•ç”¨ï¼ˆç±»ä¼¼ `Weak`ï¼‰

---

## é¡¹ç›®2: å­—ç¬¦ä¸²å¤„ç†å·¥å…·

### ğŸ“– é¡¹ç›®è¯´æ˜2

**éš¾åº¦**: â­â­
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶
**ç›®æ ‡**: æŒæ¡å€Ÿç”¨ã€åˆ‡ç‰‡å’Œç”Ÿå‘½å‘¨æœŸ

### å­¦ä¹ ç›®æ ‡2

1. ç†è§£ `&str` å’Œ `String` çš„åŒºåˆ«
2. æŒæ¡åˆ‡ç‰‡çš„ä½¿ç”¨
3. ç†è§£ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
4. å¤„ç† UTF-8 ç¼–ç 

### åŠŸèƒ½éœ€æ±‚2

#### åŸºç¡€åŠŸèƒ½2

1. å­—ç¬¦ä¸²åˆ‡å‰²ï¼ˆsplitï¼‰
2. å­—ç¬¦ä¸²æŸ¥æ‰¾ï¼ˆfindï¼‰
3. å­—ç¬¦ä¸²æ›¿æ¢ï¼ˆreplaceï¼‰
4. å»é™¤ç©ºç™½å­—ç¬¦ï¼ˆtrimï¼‰

#### è¿›é˜¶åŠŸèƒ½2

1. å¤šç§åˆ†éš”ç¬¦æ”¯æŒ
2. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ï¼ˆå¯é€‰ï¼‰
3. Unicode å­—ç¬¦å¤„ç†

### é¡¹ç›®ç»“æ„2

```text
string_utils/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â””â”€â”€ lib.rs
```

### æ ¸å¿ƒä»£ç å®ç°2

#### `lib.rs`

```rust
/// å­—ç¬¦ä¸²å·¥å…·æ¨¡å—

/// æŒ‰åˆ†éš”ç¬¦åˆ†å‰²å­—ç¬¦ä¸²
pub fn split_str<'a>(text: &'a str, delimiter: &str) -> Vec<&'a str> {
    text.split(delimiter).collect()
}

/// æŸ¥æ‰¾å­å­—ç¬¦ä¸²çš„ä½ç½®
pub fn find_substring(text: &str, pattern: &str) -> Option<usize> {
    text.find(pattern)
}

/// æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…ä½ç½®
pub fn find_all(text: &str, pattern: &str) -> Vec<usize> {
    let mut positions = Vec::new();
    let mut start = 0;

    while let Some(pos) = text[start..].find(pattern) {
        positions.push(start + pos);
        start += pos + pattern.len();
    }

    positions
}

/// æ›¿æ¢æ‰€æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²
pub fn replace_all(text: &str, from: &str, to: &str) -> String {
    text.replace(from, to)
}

/// å»é™¤é¦–å°¾ç©ºç™½å­—ç¬¦
pub fn trim_whitespace(text: &str) -> &str {
    text.trim()
}

/// æŒ‰å­—ç¬¦æ•°é‡åˆ‡å‰²å­—ç¬¦ä¸²
pub fn slice_chars(text: &str, start: usize, len: usize) -> Option<String> {
    let chars: Vec<char> = text.chars().collect();

    if start + len > chars.len() {
        return None;
    }

    Some(chars[start..start + len].iter().collect())
}

/// å­—ç¬¦ä¸²åè½¬ï¼ˆæ”¯æŒ Unicodeï¼‰
pub fn reverse_string(text: &str) -> String {
    text.chars().rev().collect()
}

/// ç»Ÿè®¡å•è¯æ•°é‡
pub fn count_words(text: &str) -> usize {
    text.split_whitespace().count()
}

/// æå–æœ€é•¿çš„å•è¯
pub fn longest_word<'a>(text: &'a str) -> Option<&'a str> {
    text.split_whitespace()
        .max_by_key(|word| word.len())
}

/// æ£€æŸ¥æ˜¯å¦ä¸ºå›æ–‡
pub fn is_palindrome(text: &str) -> bool {
    let cleaned: String = text.chars()
        .filter(|c| c.is_alphanumeric())
        .map(|c| c.to_lowercase().next().unwrap())
        .collect();

    let reversed: String = cleaned.chars().rev().collect();
    cleaned == reversed
}

/// é¦–å­—æ¯å¤§å†™
pub fn capitalize(text: &str) -> String {
    let mut chars = text.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => {
            first.to_uppercase().collect::<String>() + chars.as_str()
        }
    }
}

/// æŒ‰è¡Œåˆ†å‰²å¹¶å¤„ç†
pub struct LineIterator<'a> {
    remaining: &'a str,
}

impl<'a> LineIterator<'a> {
    pub fn new(text: &'a str) -> Self {
        LineIterator { remaining: text }
    }
}

impl<'a> Iterator for LineIterator<'a> {
    type Item = &'a str;

    fn next(&mut self) -> Option<Self::Item> {
        if self.remaining.is_empty() {
            return None;
        }

        match self.remaining.find('\n') {
            Some(pos) => {
                let line = &self.remaining[..pos];
                self.remaining = &self.remaining[pos + 1..];
                Some(line)
            }
            None => {
                let line = self.remaining;
                self.remaining = "";
                Some(line)
            }
        }
    }
}
```

#### `main.rs`-

```rust
mod lib;
use lib::*;

fn main() {
    println!("===== å­—ç¬¦ä¸²å¤„ç†å·¥å…·æµ‹è¯• =====\n");

    // æµ‹è¯•1: å­—ç¬¦ä¸²åˆ†å‰²
    {
        println!("æµ‹è¯•1: å­—ç¬¦ä¸²åˆ†å‰²");
        let text = "apple,banana,cherry";
        let parts = split_str(text, ",");
        println!("åŸå§‹: {}", text);
        println!("åˆ†å‰²: {:?}\n", parts);
    }

    // æµ‹è¯•2: æŸ¥æ‰¾å­å­—ç¬¦ä¸²
    {
        println!("æµ‹è¯•2: æŸ¥æ‰¾å­å­—ç¬¦ä¸²");
        let text = "Hello, Rust! Rust is great!";

        if let Some(pos) = find_substring(text, "Rust") {
            println!("æ‰¾åˆ° 'Rust' åœ¨ä½ç½®: {}", pos);
        }

        let all_positions = find_all(text, "Rust");
        println!("æ‰€æœ‰ 'Rust' çš„ä½ç½®: {:?}\n", all_positions);
    }

    // æµ‹è¯•3: å­—ç¬¦ä¸²æ›¿æ¢
    {
        println!("æµ‹è¯•3: å­—ç¬¦ä¸²æ›¿æ¢");
        let text = "I like Python. Python is easy.";
        let replaced = replace_all(text, "Python", "Rust");
        println!("åŸå§‹: {}", text);
        println!("æ›¿æ¢: {}\n", replaced);
    }

    // æµ‹è¯•4: Unicode å¤„ç†
    {
        println!("æµ‹è¯•4: Unicode å¤„ç†");
        let text = "Hello ä¸–ç•Œ ğŸ¦€";
        println!("åŸå§‹: {}", text);
        println!("åè½¬: {}", reverse_string(text));

        if let Some(slice) = slice_chars(text, 6, 2) {
            println!("åˆ‡ç‰‡ [6..8]: {}\n", slice);
        }
    }

    // æµ‹è¯•5: å•è¯ç»Ÿè®¡
    {
        println!("æµ‹è¯•5: å•è¯ç»Ÿè®¡");
        let text = "Rust is a systems programming language";
        println!("æ–‡æœ¬: {}", text);
        println!("å•è¯æ•°: {}", count_words(text));

        if let Some(longest) = longest_word(text) {
            println!("æœ€é•¿å•è¯: {}\n", longest);
        }
    }

    // æµ‹è¯•6: å›æ–‡æ£€æŸ¥
    {
        println!("æµ‹è¯•6: å›æ–‡æ£€æŸ¥");
        let test_cases = vec![
            "A man a plan a canal Panama",
            "race car",
            "Hello",
        ];

        for text in test_cases {
            println!("{:?} æ˜¯å›æ–‡: {}", text, is_palindrome(text));
        }
        println!();
    }

    // æµ‹è¯•7: é¦–å­—æ¯å¤§å†™
    {
        println!("æµ‹è¯•7: é¦–å­—æ¯å¤§å†™");
        let words = vec!["hello", "rust", "world"];
        let capitalized: Vec<String> = words.iter()
            .map(|&w| capitalize(w))
            .collect();
        println!("åŸå§‹: {:?}", words);
        println!("å¤§å†™: {:?}\n", capitalized);
    }

    // æµ‹è¯•8: è¡Œè¿­ä»£å™¨
    {
        println!("æµ‹è¯•8: è¡Œè¿­ä»£å™¨");
        let text = "Line 1\nLine 2\nLine 3";
        println!("åŸå§‹æ–‡æœ¬:\n{}\n", text);

        println!("é€è¡Œå¤„ç†:");
        for (i, line) in LineIterator::new(text).enumerate() {
            println!("  ç¬¬{}è¡Œ: {}", i + 1, line);
        }
    }
}
```

### æµ‹è¯•æ–¹å¼-

```bash
cargo new string_utils
cd string_utils
# å¤åˆ¶ä¸Šè¿°ä»£ç 
cargo run
```

### é¢„æœŸè¾“å‡º-

```text
===== å­—ç¬¦ä¸²å¤„ç†å·¥å…·æµ‹è¯• =====

æµ‹è¯•1: å­—ç¬¦ä¸²åˆ†å‰²
åŸå§‹: apple,banana,cherry
åˆ†å‰²: ["apple", "banana", "cherry"]

æµ‹è¯•2: æŸ¥æ‰¾å­å­—ç¬¦ä¸²
æ‰¾åˆ° 'Rust' åœ¨ä½ç½®: 7
æ‰€æœ‰ 'Rust' çš„ä½ç½®: [7, 13]

æµ‹è¯•3: å­—ç¬¦ä¸²æ›¿æ¢
åŸå§‹: I like Python. Python is easy.
æ›¿æ¢: I like Rust. Rust is easy.

æµ‹è¯•4: Unicode å¤„ç†
åŸå§‹: Hello ä¸–ç•Œ ğŸ¦€
åè½¬: ğŸ¦€ç•Œä¸– olleH
åˆ‡ç‰‡ [6..8]: ä¸–ç•Œ

æµ‹è¯•5: å•è¯ç»Ÿè®¡
æ–‡æœ¬: Rust is a systems programming language
å•è¯æ•°: 6
æœ€é•¿å•è¯: programming

æµ‹è¯•6: å›æ–‡æ£€æŸ¥
"A man a plan a canal Panama" æ˜¯å›æ–‡: true
"race car" æ˜¯å›æ–‡: true
"Hello" æ˜¯å›æ–‡: false

æµ‹è¯•7: é¦–å­—æ¯å¤§å†™
åŸå§‹: ["hello", "rust", "world"]
å¤§å†™: ["Hello", "Rust", "World"]

æµ‹è¯•8: è¡Œè¿­ä»£å™¨
åŸå§‹æ–‡æœ¬:
Line 1
Line 2
Line 3

é€è¡Œå¤„ç†:
  ç¬¬1è¡Œ: Line 1
  ç¬¬2è¡Œ: Line 2
  ç¬¬3è¡Œ: Line 3
```

### å…³é”®çŸ¥è¯†ç‚¹-

1. **ç”Ÿå‘½å‘¨æœŸ**: è¿”å›çš„åˆ‡ç‰‡ä¸è¾“å…¥æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
2. **å€Ÿç”¨**: å¤šä¸ªå‡½æ•°å¯ä»¥åŒæ—¶å€Ÿç”¨åŒä¸€ä¸ªå­—ç¬¦ä¸²
3. **åˆ‡ç‰‡**: `&str` æ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œä¸æ‹¥æœ‰æ•°æ®
4. **UTF-8**: æ­£ç¡®å¤„ç†å¤šå­—èŠ‚å­—ç¬¦
5. **è¿­ä»£å™¨**: è‡ªå®šä¹‰è¿­ä»£å™¨å¤„ç†æ–‡æœ¬

### æ‰©å±•æ–¹å‘-

1. æ·»åŠ æ­£åˆ™è¡¨è¾¾å¼æ”¯æŒï¼ˆä½¿ç”¨ `regex` crateï¼‰
2. å®ç°æ›´å¤šçš„å­—ç¬¦ä¸²ç®—æ³•ï¼ˆKMPã€Boyer-Mooreï¼‰
3. æ·»åŠ æ€§èƒ½åŸºå‡†æµ‹è¯•
4. æ”¯æŒæµå¼å¤„ç†å¤§æ–‡ä»¶

---

## é¡¹ç›®3: å¼•ç”¨è®¡æ•°å®¹å™¨

### ğŸ“– é¡¹ç›®è¯´æ˜3

**éš¾åº¦**: â­â­â­
**é¢„è®¡æ—¶é—´**: 3-4å°æ—¶
**ç›®æ ‡**: æŒæ¡ `RefCell` å’Œå†…éƒ¨å¯å˜æ€§

### å­¦ä¹ ç›®æ ‡3

1. ç†è§£å†…éƒ¨å¯å˜æ€§æ¨¡å¼
2. æŒæ¡ `RefCell` å’Œ `Rc` çš„ä½¿ç”¨
3. å®ç°å…±äº«å¯å˜çŠ¶æ€
4. ç†è§£è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥

### åŠŸèƒ½éœ€æ±‚3

#### åŸºç¡€åŠŸèƒ½3

1. åˆ›å»ºå¼•ç”¨è®¡æ•°å®¹å™¨
2. æ”¯æŒå…±äº«è®¿é—®
3. æ”¯æŒå†…éƒ¨å¯å˜æ€§
4. è¿½è¸ªå¼•ç”¨è®¡æ•°

#### è¿›é˜¶åŠŸèƒ½3

1. å®ç°è§‚å¯Ÿè€…æ¨¡å¼
2. å¾ªç¯å¼•ç”¨æ£€æµ‹
3. å¼±å¼•ç”¨æ”¯æŒ

### é¡¹ç›®ç»“æ„3

```text
shared_container/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â””â”€â”€ container.rs
```

### æ ¸å¿ƒä»£ç å®ç°3

#### `container.rs`

```rust
use std::cell::RefCell;
use std::rc::Rc;

/// å…±äº«å®¹å™¨ï¼Œæ”¯æŒå†…éƒ¨å¯å˜æ€§
#[derive(Debug)]
pub struct SharedContainer<T> {
    data: Rc<RefCell<T>>,
}

impl<T> SharedContainer<T> {
    /// åˆ›å»ºæ–°çš„å…±äº«å®¹å™¨
    pub fn new(value: T) -> Self {
        SharedContainer {
            data: Rc::new(RefCell::new(value)),
        }
    }

    /// è·å–å¼•ç”¨è®¡æ•°
    pub fn ref_count(&self) -> usize {
        Rc::strong_count(&self.data)
    }

    /// å€Ÿç”¨å†…éƒ¨æ•°æ®ï¼ˆä¸å¯å˜ï¼‰
    pub fn borrow(&self) -> std::cell::Ref<'_, T> {
        self.data.borrow()
    }

    /// å€Ÿç”¨å†…éƒ¨æ•°æ®ï¼ˆå¯å˜ï¼‰
    pub fn borrow_mut(&self) -> std::cell::RefMut<'_, T> {
        self.data.borrow_mut()
    }

    /// å°è¯•å€Ÿç”¨ï¼ˆå¯å˜ï¼‰ï¼Œå¦‚æœå·²è¢«å€Ÿç”¨åˆ™è¿”å› None
    pub fn try_borrow_mut(&self) -> Option<std::cell::RefMut<'_, T>> {
        self.data.try_borrow_mut().ok()
    }
}

impl<T> Clone for SharedContainer<T> {
    fn clone(&self) -> Self {
        SharedContainer {
            data: Rc::clone(&self.data),
        }
    }
}

/// è®¡æ•°å™¨ç¤ºä¾‹
pub struct Counter {
    count: i32,
    observers: Vec<Rc<RefCell<dyn Observer>>>,
}

impl Counter {
    pub fn new() -> Self {
        Counter {
            count: 0,
            observers: Vec::new(),
        }
    }

    pub fn increment(&mut self) {
        self.count += 1;
        self.notify();
    }

    pub fn decrement(&mut self) {
        self.count -= 1;
        self.notify();
    }

    pub fn get(&self) -> i32 {
        self.count
    }

    pub fn add_observer(&mut self, observer: Rc<RefCell<dyn Observer>>) {
        self.observers.push(observer);
    }

    fn notify(&self) {
        for observer in &self.observers {
            observer.borrow_mut().update(self.count);
        }
    }
}

/// è§‚å¯Ÿè€… trait
pub trait Observer {
    fn update(&mut self, value: i32);
}

/// æ—¥å¿—è§‚å¯Ÿè€…
pub struct LogObserver {
    name: String,
}

impl LogObserver {
    pub fn new(name: &str) -> Self {
        LogObserver {
            name: name.to_string(),
        }
    }
}

impl Observer for LogObserver {
    fn update(&mut self, value: i32) {
        println!("ğŸ“¢ [{}] æ”¶åˆ°æ›´æ–°: {}", self.name, value);
    }
}

/// ç»Ÿè®¡è§‚å¯Ÿè€…
pub struct StatsObserver {
    min: i32,
    max: i32,
    updates: usize,
}

impl StatsObserver {
    pub fn new() -> Self {
        StatsObserver {
            min: i32::MAX,
            max: i32::MIN,
            updates: 0,
        }
    }

    pub fn report(&self) {
        println!("ğŸ“Š ç»Ÿè®¡: min={}, max={}, updates={}",
                 self.min, self.max, self.updates);
    }
}

impl Observer for StatsObserver {
    fn update(&mut self, value: i32) {
        self.min = self.min.min(value);
        self.max = self.max.max(value);
        self.updates += 1;
    }
}
```

#### `main.rs`--

```rust
mod container;
use container::*;
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    println!("===== å¼•ç”¨è®¡æ•°å®¹å™¨æµ‹è¯• =====\n");

    // æµ‹è¯•1: åŸºç¡€å…±äº«å®¹å™¨
    {
        println!("æµ‹è¯•1: åŸºç¡€å…±äº«å®¹å™¨");
        let container = SharedContainer::new(vec![1, 2, 3]);
        println!("å¼•ç”¨è®¡æ•°: {}", container.ref_count());

        // å…‹éš†å®¹å™¨ï¼ˆå¢åŠ å¼•ç”¨è®¡æ•°ï¼‰
        let container2 = container.clone();
        println!("å…‹éš†åå¼•ç”¨è®¡æ•°: {}", container.ref_count());

        // ä¸å¯å˜å€Ÿç”¨
        {
            let data = container.borrow();
            println!("æ•°æ®: {:?}", *data);
        }

        // å¯å˜å€Ÿç”¨
        {
            let mut data = container.borrow_mut();
            data.push(4);
            println!("ä¿®æ”¹å: {:?}", *data);
        }

        // é€šè¿‡ç¬¬äºŒä¸ªå¼•ç”¨è®¿é—®
        {
            let data = container2.borrow();
            println!("é€šè¿‡ container2 è®¿é—®: {:?}\n", *data);
        }
    }

    // æµ‹è¯•2: å¤šä¸ªå¯å˜å¼•ç”¨ï¼ˆè¿è¡Œæ—¶æ£€æŸ¥ï¼‰
    {
        println!("æµ‹è¯•2: å€Ÿç”¨æ£€æŸ¥");
        let container = SharedContainer::new(100);

        // ç¬¬ä¸€ä¸ªå¯å˜å€Ÿç”¨
        let mut ref1 = container.borrow_mut();
        *ref1 += 10;
        println!("ç¬¬ä¸€æ¬¡ä¿®æ”¹: {}", *ref1);

        // å°è¯•ç¬¬äºŒä¸ªå¯å˜å€Ÿç”¨ï¼ˆä¼šå¤±è´¥ï¼‰
        match container.try_borrow_mut() {
            Some(_) => println!("è·å–ç¬¬äºŒä¸ªå¯å˜å¼•ç”¨æˆåŠŸ"),
            None => println!("âŒ æ— æ³•è·å–ç¬¬äºŒä¸ªå¯å˜å¼•ç”¨ï¼ˆå·²è¢«å€Ÿç”¨ï¼‰"),
        }

        drop(ref1);  // é‡Šæ”¾ç¬¬ä¸€ä¸ªå€Ÿç”¨

        // ç°åœ¨å¯ä»¥å€Ÿç”¨äº†
        match container.try_borrow_mut() {
            Some(mut ref2) => {
                *ref2 += 20;
                println!("âœ… é‡Šæ”¾åè·å–å¯å˜å¼•ç”¨æˆåŠŸ: {}\n", *ref2);
            }
            None => println!("å¤±è´¥"),
        }
    }

    // æµ‹è¯•3: è§‚å¯Ÿè€…æ¨¡å¼
    {
        println!("æµ‹è¯•3: è§‚å¯Ÿè€…æ¨¡å¼");

        let counter = SharedContainer::new(Counter::new());

        // åˆ›å»ºè§‚å¯Ÿè€…
        let log_observer = Rc::new(RefCell::new(
            LogObserver::new("Logger")
        ));
        let stats_observer = Rc::new(RefCell::new(
            StatsObserver::new()
        ));

        // æ³¨å†Œè§‚å¯Ÿè€…
        counter.borrow_mut().add_observer(Rc::clone(&log_observer));
        counter.borrow_mut().add_observer(Rc::clone(&stats_observer));

        // æ‰§è¡Œæ“ä½œ
        println!("å¼€å§‹è®¡æ•°:");
        counter.borrow_mut().increment();
        counter.borrow_mut().increment();
        counter.borrow_mut().increment();
        counter.borrow_mut().decrement();

        println!("\nå½“å‰è®¡æ•°: {}", counter.borrow().get());

        // æ˜¾ç¤ºç»Ÿè®¡
        stats_observer.borrow().report();
        println!();
    }

    // æµ‹è¯•4: å…±äº«å¯å˜çŠ¶æ€
    {
        println!("æµ‹è¯•4: å…±äº«å¯å˜çŠ¶æ€");

        struct Node {
            value: i32,
            next: Option<Rc<RefCell<Node>>>,
        }

        let node1 = Rc::new(RefCell::new(Node {
            value: 1,
            next: None,
        }));

        let node2 = Rc::new(RefCell::new(Node {
            value: 2,
            next: Some(Rc::clone(&node1)),
        }));

        let node3 = Rc::new(RefCell::new(Node {
            value: 3,
            next: Some(Rc::clone(&node2)),
        }));

        // éå†é“¾è¡¨
        let mut current = Some(Rc::clone(&node3));
        print!("é“¾è¡¨: ");
        while let Some(node) = current {
            let node_ref = node.borrow();
            print!("{} ", node_ref.value);
            current = node_ref.next.as_ref().map(Rc::clone);
        }
        println!();

        // ä¿®æ”¹èŠ‚ç‚¹
        node2.borrow_mut().value = 20;

        // å†æ¬¡éå†
        let mut current = Some(Rc::clone(&node3));
        print!("ä¿®æ”¹å: ");
        while let Some(node) = current {
            let node_ref = node.borrow();
            print!("{} ", node_ref.value);
            current = node_ref.next.as_ref().map(Rc::clone);
        }
        println!();
    }
}
```

### æµ‹è¯•æ–¹å¼3

```bash
cargo new shared_container
cd shared_container
# å¤åˆ¶ä¸Šè¿°ä»£ç 
cargo run
```

### é¢„æœŸè¾“å‡º3

```text
===== å¼•ç”¨è®¡æ•°å®¹å™¨æµ‹è¯• =====

æµ‹è¯•1: åŸºç¡€å…±äº«å®¹å™¨
å¼•ç”¨è®¡æ•°: 1
å…‹éš†åå¼•ç”¨è®¡æ•°: 2
æ•°æ®: [1, 2, 3]
ä¿®æ”¹å: [1, 2, 3, 4]
é€šè¿‡ container2 è®¿é—®: [1, 2, 3, 4]

æµ‹è¯•2: å€Ÿç”¨æ£€æŸ¥
ç¬¬ä¸€æ¬¡ä¿®æ”¹: 110
âŒ æ— æ³•è·å–ç¬¬äºŒä¸ªå¯å˜å¼•ç”¨ï¼ˆå·²è¢«å€Ÿç”¨ï¼‰
âœ… é‡Šæ”¾åè·å–å¯å˜å¼•ç”¨æˆåŠŸ: 130

æµ‹è¯•3: è§‚å¯Ÿè€…æ¨¡å¼
å¼€å§‹è®¡æ•°:
ğŸ“¢ [Logger] æ”¶åˆ°æ›´æ–°: 1
ğŸ“¢ [Logger] æ”¶åˆ°æ›´æ–°: 2
ğŸ“¢ [Logger] æ”¶åˆ°æ›´æ–°: 3
ğŸ“¢ [Logger] æ”¶åˆ°æ›´æ–°: 2

å½“å‰è®¡æ•°: 2
ğŸ“Š ç»Ÿè®¡: min=1, max=3, updates=4

æµ‹è¯•4: å…±äº«å¯å˜çŠ¶æ€
é“¾è¡¨: 3 2 1
ä¿®æ”¹å: 3 20 1
```

### å…³é”®çŸ¥è¯†ç‚¹3

1. **å†…éƒ¨å¯å˜æ€§**: `RefCell` å…è®¸åœ¨ä¸å¯å˜å¼•ç”¨ä¸‹ä¿®æ”¹æ•°æ®
2. **å¼•ç”¨è®¡æ•°**: `Rc` å®ç°å…±äº«æ‰€æœ‰æƒ
3. **è¿è¡Œæ—¶æ£€æŸ¥**: `RefCell` åœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™
4. **è§‚å¯Ÿè€…æ¨¡å¼**: ä½¿ç”¨ `Rc<RefCell<T>>` å®ç°å…±äº«å¯å˜çŠ¶æ€
5. **å€Ÿç”¨è§„åˆ™**: åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨æˆ–å¤šä¸ªä¸å¯å˜å€Ÿç”¨

### æ‰©å±•æ–¹å‘3

1. å®ç° `Weak` å¼±å¼•ç”¨ï¼Œé˜²æ­¢å¾ªç¯å¼•ç”¨
2. æ·»åŠ çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ï¼ˆä½¿ç”¨ `Arc` å’Œ `Mutex`ï¼‰
3. å®ç°å›¾æ•°æ®ç»“æ„
4. æ·»åŠ å¾ªç¯å¼•ç”¨æ£€æµ‹

---

## ğŸ“ æ€»ç»“

### é¡¹ç›®éš¾åº¦é€’è¿›

1. **é¡¹ç›®1**: ç†è§£æ‰€æœ‰æƒçš„åŸºç¡€ - å•ä¸€æ‰€æœ‰è€…
2. **é¡¹ç›®2**: ç†è§£å€Ÿç”¨çš„å®è·µ - å¤šä¸ªå€Ÿç”¨è€…
3. **é¡¹ç›®3**: ç†è§£å…±äº«çš„é«˜çº§ - å…±äº«æ‰€æœ‰æƒ

### æ ¸å¿ƒæ¦‚å¿µå¯¹åº”

| é¡¹ç›®  | æ‰€æœ‰æƒ | å€Ÿç”¨   | ç”Ÿå‘½å‘¨æœŸ | å†…éƒ¨å¯å˜æ€§ |
| :--- | :--- | :--- | :--- | :--- |
| é¡¹ç›®1 | âœ…âœ…âœ… | âœ…     | âœ…       | âŒ         |
| é¡¹ç›®2 | âœ…     | âœ…âœ…âœ… | âœ…âœ…âœ…   | âŒ         |
| é¡¹ç›®3 | âœ…âœ…   | âœ…âœ…   | âœ…       | âœ…âœ…âœ…     |

### å­¦ä¹ å»ºè®®

1. **å¾ªåºæ¸è¿›**: æŒ‰é¡¹ç›®1 â†’ 2 â†’ 3 çš„é¡ºåºå­¦ä¹ 
2. **åŠ¨æ‰‹å®è·µ**: è‡ªå·±å®ç°å¹¶è¿è¡Œä»£ç 
3. **ç†è§£åŸç†**: æ€è€ƒä¸ºä»€ä¹ˆéœ€è¦è¿™äº›è§„åˆ™
4. **å°è¯•æ‰©å±•**: å®ç°å»ºè®®çš„æ‰©å±•åŠŸèƒ½

### ç›¸å…³æ–‡æ¡£

- ğŸ“– [ä»£ç ç¤ºä¾‹é›†åˆ](./06_ä»£ç ç¤ºä¾‹é›†åˆ.md)
- ğŸ“– [æ‰€æœ‰æƒåŸºç¡€](../tier_01_foundations/01_æ‰€æœ‰æƒåŸºç¡€.md)
- ğŸ“– [å€Ÿç”¨ä¸å¼•ç”¨](../tier_01_foundations/02_å€Ÿç”¨ä¸å¼•ç”¨.md)
- ğŸ“– [ç”Ÿå‘½å‘¨æœŸ](../tier_01_foundations/03_ç”Ÿå‘½å‘¨æœŸåŸºç¡€.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ¯ é€šè¿‡å®æˆ˜é¡¹ç›®ï¼ŒçœŸæ­£æŒæ¡ Rust çš„æ‰€æœ‰æƒç³»ç»Ÿï¼ğŸ¦€**-
