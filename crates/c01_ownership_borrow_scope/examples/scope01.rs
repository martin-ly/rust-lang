// 所有权和借用
// 所有权是Rust中的一个重要概念，它决定了变量的生命周期和内存管理。
// 借用是Rust中的一种机制，允许在不转移所有权的情况下访问和修改数据。
// 借用分为不可变借用和可变借用。
// 不可变借用：借用者不能修改借用的数据，只能读取数据。
// 可变借用：借用者可以修改借用的数据。
// 借用在编译时进行检查，确保借用不会超过变量的生命周期。

// 所有权和借用的规则：
// 1. 每个值都有一个所有者。
// 2. 值的所有权可以转移给其他变量。
// 3. 当所有者离开作用域时，值会被释放。
// 4. 借用者在借用期间不能修改借用的数据。
// 5. 可变借用可以修改借用的数据。

// 所有权和借用的示例：


fn main() {
    let s1 = String::from("Hello"); // s1是一个可变的字符串
    let s2 = s1; // 移动语义：s1的所有权被转移到s2，s1不再有效

    // println!("{}", s1); // 这行代码会导致编译错误，因为s1的所有权已被转移

    let s3 = &s2; // 借用：s3是对s2的不可变借用
    println!("{}", s3); // 可以通过s3访问s2的值

    // s2.push_str(", world!"); // 这行代码会导致编译错误，因为s3的借用使得s2不可变

    let mut s4 = String::from("Rust"); // s4是一个可变的字符串
    change(&mut s4); // 可变借用：将s4的可变引用传递给change函数
    println!("{}", s4); // 输出 "Rust programming"

    scope();
}

fn change(s: &mut String) {
    s.push_str(" programming"); // 修改借用的字符串
}

// 所有权和借用的示例 冲突
fn scope() {
    let mut x  =5;
    let y = &mut x;

    // 这里会报错，因为x已经被借用，不能再次被借用
    //let z = &mut x;

    *y += 1;
    // 这里会报错，因为z已经被借用，不能再次被借用 与y 冲突
    //println!("{}", z);

    println!("{}", y);
}
