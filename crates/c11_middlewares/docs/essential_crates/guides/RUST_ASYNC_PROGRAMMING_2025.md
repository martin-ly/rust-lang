# Rust å¼‚æ­¥ç¼–ç¨‹å®æˆ˜æŒ‡å— 2025

> **æœ€åæ›´æ–°**: 2025-10-20  
> **Rust ç‰ˆæœ¬**: 1.83+  
> **éš¾åº¦**: â­â­â­â­ (ä¸­é«˜çº§)

## ğŸ“‹ ç›®å½•1

- [Rust å¼‚æ­¥ç¼–ç¨‹å®æˆ˜æŒ‡å— 2025](#rust-å¼‚æ­¥ç¼–ç¨‹å®æˆ˜æŒ‡å—-2025)
  - [ğŸ“‹ ç›®å½•1](#-ç›®å½•1)
  - [1. å¼‚æ­¥ç¼–ç¨‹åŸºç¡€](#1-å¼‚æ­¥ç¼–ç¨‹åŸºç¡€)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ç¼–ç¨‹](#11-ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ç¼–ç¨‹)
    - [1.2 Future å’Œ Poll æœºåˆ¶](#12-future-å’Œ-poll-æœºåˆ¶)
    - [1.3 async/await è¯­æ³•](#13-asyncawait-è¯­æ³•)
  - [2. Tokio è¿è¡Œæ—¶æ·±å…¥](#2-tokio-è¿è¡Œæ—¶æ·±å…¥)
    - [2.1 è¿è¡Œæ—¶æ¶æ„](#21-è¿è¡Œæ—¶æ¶æ„)
    - [2.2 å¤šçº¿ç¨‹è°ƒåº¦å™¨](#22-å¤šçº¿ç¨‹è°ƒåº¦å™¨)
    - [2.3 Work-Stealing ç®—æ³•](#23-work-stealing-ç®—æ³•)
    - [2.4 è¿è¡Œæ—¶é…ç½®](#24-è¿è¡Œæ—¶é…ç½®)
  - [3. å¼‚æ­¥ IO æ“ä½œ](#3-å¼‚æ­¥-io-æ“ä½œ)
    - [3.1 æ–‡ä»¶ IO](#31-æ–‡ä»¶-io)
    - [3.2 ç½‘ç»œ IO](#32-ç½‘ç»œ-io)
    - [3.3 IO å¤šè·¯å¤ç”¨ (epoll/kqueue)](#33-io-å¤šè·¯å¤ç”¨-epollkqueue)
  - [4. ä»»åŠ¡å’Œå¹¶å‘](#4-ä»»åŠ¡å’Œå¹¶å‘)
    - [4.1 spawn å’Œ join](#41-spawn-å’Œ-join)
    - [4.2 select å¤šè·¯é€‰æ‹©](#42-select-å¤šè·¯é€‰æ‹©)
    - [4.3 å¹¶å‘é™åˆ¶](#43-å¹¶å‘é™åˆ¶)
    - [4.4 è¶…æ—¶å’Œå–æ¶ˆ](#44-è¶…æ—¶å’Œå–æ¶ˆ)
  - [5. å¼‚æ­¥é€šä¿¡](#5-å¼‚æ­¥é€šä¿¡)
    - [5.1 Channel (mpsc)](#51-channel-mpsc)
    - [5.2 Broadcast Channel](#52-broadcast-channel)
    - [5.3 Watch Channel](#53-watch-channel)
    - [5.4 Oneshot Channel](#54-oneshot-channel)
  - [6. å¼‚æ­¥é”å’ŒåŒæ­¥åŸè¯­](#6-å¼‚æ­¥é”å’ŒåŒæ­¥åŸè¯­)
    - [6.1 Mutex å’Œ RwLock](#61-mutex-å’Œ-rwlock)
    - [6.2 Semaphore (ä¿¡å·é‡)](#62-semaphore-ä¿¡å·é‡)
    - [6.3 Barrier](#63-barrier)
    - [6.4 Notify](#64-notify)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 å¼‚æ­¥ Web çˆ¬è™«](#71-å¼‚æ­¥-web-çˆ¬è™«)
    - [7.2 å®æ—¶èŠå¤©æœåŠ¡å™¨](#72-å®æ—¶èŠå¤©æœåŠ¡å™¨)
    - [7.3 å¼‚æ­¥æ‰¹å¤„ç†ç³»ç»Ÿ](#73-å¼‚æ­¥æ‰¹å¤„ç†ç³»ç»Ÿ)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [8.1 å‡å°‘åˆ†é…](#81-å‡å°‘åˆ†é…)
    - [8.2 é¿å…ä¸å¿…è¦çš„ await](#82-é¿å…ä¸å¿…è¦çš„-await)
    - [8.3 æ‰¹å¤„ç†ä¼˜åŒ–](#83-æ‰¹å¤„ç†ä¼˜åŒ–)
    - [8.4 é›¶æ‹·è´æŠ€æœ¯](#84-é›¶æ‹·è´æŠ€æœ¯)
  - [9. è°ƒè¯•å’Œè¯Šæ–­](#9-è°ƒè¯•å’Œè¯Šæ–­)
    - [9.1 tokio-console](#91-tokio-console)
    - [9.2 tracing é›†æˆ](#92-tracing-é›†æˆ)
    - [9.3 æ­»é”æ£€æµ‹](#93-æ­»é”æ£€æµ‹)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
  - [11. å¸¸è§é™·é˜±](#11-å¸¸è§é™·é˜±)
  - [12. å‚è€ƒèµ„æº](#12-å‚è€ƒèµ„æº)

---

## 1. å¼‚æ­¥ç¼–ç¨‹åŸºç¡€

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ç¼–ç¨‹

**åŒæ­¥ vs å¼‚æ­¥å¯¹æ¯”:**

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åŒæ­¥ IO (é˜»å¡)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Thread 1: [â–ˆâ–ˆâ–ˆâ–ˆ Read â–ˆâ–ˆâ–ˆâ–ˆ] [â–ˆâ–ˆâ–ˆâ–ˆ Process]
â”‚ Thread 2: [â–ˆâ–ˆâ–ˆâ–ˆ Read â–ˆâ–ˆâ–ˆâ–ˆ] [â–ˆâ–ˆâ–ˆâ–ˆ Process]
â”‚ Thread 3: [â–ˆâ–ˆâ–ˆâ–ˆ Read â–ˆâ–ˆâ–ˆâ–ˆ] [â–ˆâ–ˆâ–ˆâ–ˆ Process]
â”‚                                         â”‚
â”‚ é—®é¢˜: æ¯ä¸ªçº¿ç¨‹åœ¨ IO æ—¶é˜»å¡ï¼Œæµªè´¹èµ„æº    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¼‚æ­¥ IO (éé˜»å¡)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Task 1: [â–ˆâ–ˆ Read][Process][â–ˆâ–ˆ Read]
â”‚ Task 2:    [â–ˆâ–ˆ Read][Process][â–ˆâ–ˆ Read]
â”‚ Task 3:       [â–ˆâ–ˆ Read][Process][â–ˆâ–ˆ Read]
â”‚                                         â”‚
â”‚ ä¼˜åŠ¿: å•çº¿ç¨‹å¤„ç†å¤šä»»åŠ¡ï¼Œé«˜å¹¶å‘ä½å¼€é”€    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ€§èƒ½å¯¹æ¯” (10K å¹¶å‘è¿æ¥):**

| æ–¹å¼         | å†…å­˜å ç”¨ | CPU ä½¿ç”¨ç‡ | å»¶è¿Ÿ (p99) |
|--------------|----------|------------|------------|
| çº¿ç¨‹æ±  (1K)  | ~10 GB   | 80%        | 500ms      |
| å¼‚æ­¥ (Tokio) | ~500 MB  | 30%        | 50ms       |

### 1.2 Future å’Œ Poll æœºåˆ¶

**Future trait å®šä¹‰:**

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// ç®€åŒ–çš„ Future trait
pub trait Future {
    type Output;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

// Poll æšä¸¾
pub enum Poll<T> {
    Ready(T),    // ä»»åŠ¡å®Œæˆ
    Pending,     // ä»»åŠ¡æœªå®Œæˆï¼Œéœ€è¦å†æ¬¡è½®è¯¢
}
```

**è‡ªå®šä¹‰ Future å®ç°:**

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// è‡ªå®šä¹‰å®šæ—¶å™¨ Future
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
struct Delay {
    when: Instant,
}

impl Delay {
    fn new(duration: Duration) -> Self {
        Self {
            when: Instant::now() + duration,
        }
    }
}

impl Future for Delay {
    type Output = ();
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if Instant::now() >= self.when {
            // æ—¶é—´å·²åˆ°ï¼Œè¿”å› Ready
            Poll::Ready(())
        } else {
            // æ—¶é—´æœªåˆ°ï¼Œæ³¨å†Œ waker å¹¶è¿”å› Pending
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    println!("å¼€å§‹ç­‰å¾…...");
    Delay::new(Duration::from_secs(2)).await;
    println!("ç­‰å¾…å®Œæˆï¼");
}
```

### 1.3 async/await è¯­æ³•

**åŸºæœ¬è¯­æ³•:**

```rust
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// async å‡½æ•°è‡ªåŠ¨è¿”å› impl Future
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
async fn read_file(path: &str) -> std::io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}

async fn write_file(path: &str, data: &str) -> std::io::Result<()> {
    let mut file = File::create(path).await?;
    file.write_all(data.as_bytes()).await?;
    Ok(())
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// å¹¶å‘æ‰§è¡Œå¤šä¸ªå¼‚æ­¥ä»»åŠ¡
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#[tokio::main]
async fn main() -> std::io::Result<()> {
    // 1. é¡ºåºæ‰§è¡Œ (æ€»è€—æ—¶ = t1 + t2)
    let content1 = read_file("file1.txt").await?;
    let content2 = read_file("file2.txt").await?;
    
    // 2. å¹¶å‘æ‰§è¡Œ (æ€»è€—æ—¶ = max(t1, t2))
    let (content1, content2) = tokio::join!(
        read_file("file1.txt"),
        read_file("file2.txt"),
    );
    
    // 3. å¹¶å‘æ‰§è¡Œ + é”™è¯¯å¤„ç†
    let results = tokio::try_join!(
        read_file("file1.txt"),
        read_file("file2.txt"),
        read_file("file3.txt"),
    )?;
    
    Ok(())
}
```

---

## 2. Tokio è¿è¡Œæ—¶æ·±å…¥

### 2.1 è¿è¡Œæ—¶æ¶æ„

**Tokio è¿è¡Œæ—¶ç»„ä»¶:**

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Tokio Runtime                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Scheduler   â”‚  â”‚  IO Driver   â”‚  â”‚ Time Driver  â”‚ â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚ â”‚
â”‚  â”‚ Work-Steal   â”‚  â”‚ epoll/kqueue â”‚  â”‚ Timer Wheel  â”‚ â”‚
â”‚  â”‚ Queues       â”‚  â”‚              â”‚  â”‚              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                  â”‚                 â”‚         â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                            â”‚                           â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚                  â”‚   Task Executor   â”‚                 â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                            â”‚                           â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚         â”‚                  â”‚                  â”‚        â”‚
â”‚    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”‚
â”‚    â”‚ Worker 1â”‚        â”‚ Worker 2â”‚        â”‚ Worker Nâ”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 å¤šçº¿ç¨‹è°ƒåº¦å™¨

**è¿è¡Œæ—¶é…ç½®:**

```rust
use tokio::runtime::Builder;
use std::time::Duration;

fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. å¤šçº¿ç¨‹è¿è¡Œæ—¶ (é»˜è®¤é…ç½®)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let rt = Builder::new_multi_thread()
        .worker_threads(4)                // 4 ä¸ª worker çº¿ç¨‹
        .thread_name("my-runtime-worker")
        .thread_stack_size(3 * 1024 * 1024) // 3MB stack
        .enable_all()                     // å¯ç”¨æ‰€æœ‰åŠŸèƒ½
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("è¿è¡Œåœ¨å¤šçº¿ç¨‹è¿è¡Œæ—¶");
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. å•çº¿ç¨‹è¿è¡Œæ—¶ (é€‚åˆ IO å¯†é›†å‹)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let rt = Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("è¿è¡Œåœ¨å•çº¿ç¨‹è¿è¡Œæ—¶");
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 3. è‡ªå®šä¹‰é…ç½® (é«˜çº§)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let rt = Builder::new_multi_thread()
        .worker_threads(8)
        .max_blocking_threads(16)         // é˜»å¡çº¿ç¨‹æ± å¤§å°
        .thread_keep_alive(Duration::from_secs(60))
        .global_queue_interval(31)        // æ¯ 31 æ¬¡è½®è¯¢æ£€æŸ¥å…¨å±€é˜Ÿåˆ—
        .event_interval(61)               // æ¯ 61 æ¬¡è½®è¯¢æ£€æŸ¥ IO äº‹ä»¶
        .enable_all()
        .build()
        .unwrap();
}
```

### 2.3 Work-Stealing ç®—æ³•

**å·¥ä½œçªƒå–æœºåˆ¶:**

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Work-Stealing Scheduler                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Global Queue (å…¨å±€é˜Ÿåˆ—)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [Task] [Task] [Task] [Task] [Task]              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚         â”‚         â”‚                           â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                   â”‚                                     â”‚
â”‚  Local Queues (æœ¬åœ°é˜Ÿåˆ—)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Worker 1     â”‚ â”‚ Worker 2     â”‚ â”‚ Worker 3     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ [T] [T] [T]  â”‚ â”‚ [T] [T]      â”‚ â”‚              â”‚   â”‚
â”‚  â”‚ [T] [T]      â”‚ â”‚              â”‚ â”‚              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚                             â–²                 â”‚
â”‚         â”‚                             â”‚                 â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ steal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                   (çªƒå–ä»»åŠ¡)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

çªƒå–ç­–ç•¥:
1. Worker ä¼˜å…ˆæ‰§è¡Œæœ¬åœ°é˜Ÿåˆ—ä»»åŠ¡
2. æœ¬åœ°é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œä»å…¨å±€é˜Ÿåˆ—è·å–
3. å…¨å±€é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œä»å…¶ä»– Worker çªƒå–ä»»åŠ¡
4. æ‰€æœ‰é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œè¿›å…¥ä¼‘çœ ç­‰å¾…
```

### 2.4 è¿è¡Œæ—¶é…ç½®

**æœ€ä½³é…ç½®æŒ‡å—:**

```rust
use tokio::runtime::Builder;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// åœºæ™¯1: Web æœåŠ¡å™¨ (IO å¯†é›†å‹)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
let rt_web = Builder::new_multi_thread()
    .worker_threads(num_cpus::get())  // CPU æ ¸å¿ƒæ•°
    .max_blocking_threads(512)        // å¤§é‡é˜»å¡æ“ä½œ
    .enable_all()
    .build()
    .unwrap();

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// åœºæ™¯2: æ•°æ®å¤„ç† (CPU å¯†é›†å‹)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
let rt_compute = Builder::new_multi_thread()
    .worker_threads(num_cpus::get() * 2) // è¶…é…
    .max_blocking_threads(4)             // å°‘é‡é˜»å¡æ“ä½œ
    .enable_all()
    .build()
    .unwrap();

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// åœºæ™¯3: åµŒå…¥å¼/è½»é‡çº§ (å•çº¿ç¨‹)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
let rt_embedded = Builder::new_current_thread()
    .enable_all()
    .build()
    .unwrap();
```

---

## 3. å¼‚æ­¥ IO æ“ä½œ

### 3.1 æ–‡ä»¶ IO

```rust
use tokio::fs::{File, OpenOptions};
use tokio::io::{AsyncReadExt, AsyncWriteExt, AsyncBufReadExt, BufReader};

#[tokio::main]
async fn main() -> std::io::Result<()> {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. è¯»å–æ•´ä¸ªæ–‡ä»¶
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let content = tokio::fs::read_to_string("file.txt").await?;
    println!("æ–‡ä»¶å†…å®¹: {}", content);
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. å†™å…¥æ–‡ä»¶
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::fs::write("output.txt", "Hello, Tokio!").await?;
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 3. è¿½åŠ å†™å…¥
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open("log.txt")
        .await?;
    
    file.write_all(b"æ–°æ—¥å¿—è¡Œ\n").await?;
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 4. é€è¡Œè¯»å– (å¤§æ–‡ä»¶)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let file = File::open("large.txt").await?;
    let reader = BufReader::new(file);
    let mut lines = reader.lines();
    
    while let Some(line) = lines.next_line().await? {
        println!("è¡Œ: {}", line);
    }
    
    Ok(())
}
```

### 3.2 ç½‘ç»œ IO

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// TCP æœåŠ¡å™¨
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#[tokio::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("æœåŠ¡å™¨å¯åŠ¨: {}", listener.local_addr()?);
    
    loop {
        let (socket, addr) = listener.accept().await?;
        println!("æ–°è¿æ¥: {}", addr);
        
        // ä¸ºæ¯ä¸ªè¿æ¥ç”Ÿæˆä¸€ä¸ªä»»åŠ¡
        tokio::spawn(async move {
            if let Err(e) = handle_client(socket).await {
                eprintln!("å¤„ç†å®¢æˆ·ç«¯å¤±è´¥: {:?}", e);
            }
        });
    }
}

async fn handle_client(mut socket: TcpStream) -> std::io::Result<()> {
    let mut buf = [0; 1024];
    
    loop {
        let n = socket.read(&mut buf).await?;
        
        if n == 0 {
            return Ok(()); // è¿æ¥å…³é—­
        }
        
        // å›æ˜¾æ•°æ®
        socket.write_all(&buf[0..n]).await?;
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// TCP å®¢æˆ·ç«¯
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
async fn tcp_client() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    
    // å‘é€æ•°æ®
    stream.write_all(b"Hello, Server!").await?;
    
    // æ¥æ”¶æ•°æ®
    let mut buf = [0; 1024];
    let n = stream.read(&mut buf).await?;
    println!("æ”¶åˆ°å“åº”: {}", String::from_utf8_lossy(&buf[0..n]));
    
    Ok(())
}
```

### 3.3 IO å¤šè·¯å¤ç”¨ (epoll/kqueue)

**Tokio IO é©±åŠ¨åŸç†:**

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IO Driver (åŸºäº epoll/kqueue/IOCP)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Reactor (IO äº‹ä»¶å¾ªç¯)                           â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚  epoll_wait() / kqueue() / GetQueuedCompletionStatus()
â”‚  â”‚       â”‚                                         â”‚   â”‚
â”‚  â”‚       â–¼                                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚   â”‚
â”‚  â”‚  â”‚ Interest Map (æ³¨å†Œçš„ IO äº‹ä»¶)       â”‚       â”‚   â”‚
â”‚  â”‚  â”‚                                     â”‚       â”‚   â”‚
â”‚  â”‚  â”‚ fd=10 â†’ Read  â†’ Waker 1             â”‚       â”‚   â”‚
â”‚  â”‚  â”‚ fd=11 â†’ Write â†’ Waker 2             â”‚       â”‚   â”‚
â”‚  â”‚  â”‚ fd=12 â†’ Read  â†’ Waker 3             â”‚       â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚  å½“ fd å°±ç»ªæ—¶:                                  â”‚   â”‚
â”‚  â”‚  1. ä» Interest Map è·å–å¯¹åº”çš„ Waker            â”‚   â”‚
â”‚  â”‚  2. è°ƒç”¨ waker.wake() å”¤é†’ä»»åŠ¡                  â”‚   â”‚
â”‚  â”‚  3. ä»»åŠ¡é‡æ–°è¢«è°ƒåº¦æ‰§è¡Œ                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. ä»»åŠ¡å’Œå¹¶å‘

### 4.1 spawn å’Œ join

```rust
use tokio::task;
use std::time::Duration;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. spawn: ç”Ÿæˆæ–°ä»»åŠ¡ (å¹¶å‘æ‰§è¡Œ)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let task1 = task::spawn(async {
        tokio::time::sleep(Duration::from_secs(1)).await;
        "ä»»åŠ¡1å®Œæˆ"
    });
    
    let task2 = task::spawn(async {
        tokio::time::sleep(Duration::from_secs(2)).await;
        "ä»»åŠ¡2å®Œæˆ"
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. join: ç­‰å¾…ä»»åŠ¡å®Œæˆ
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let result1 = task1.await.unwrap();
    let result2 = task2.await.unwrap();
    
    println!("{}, {}", result1, result2);
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 3. JoinSet: ç®¡ç†å¤šä¸ªä»»åŠ¡
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    use tokio::task::JoinSet;
    
    let mut set = JoinSet::new();
    
    for i in 0..10 {
        set.spawn(async move {
            tokio::time::sleep(Duration::from_millis(100 * i)).await;
            i
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    while let Some(res) = set.join_next().await {
        println!("ä»»åŠ¡å®Œæˆ: {:?}", res);
    }
}
```

### 4.2 select å¤šè·¯é€‰æ‹©

```rust
use tokio::time::{sleep, Duration};
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. select! å®: åŒæ—¶ç­‰å¾…å¤šä¸ª Future
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        sleep(Duration::from_secs(2)).await;
        tx.send("æ¶ˆæ¯").await.unwrap();
    });
    
    tokio::select! {
        msg = rx.recv() => {
            println!("æ”¶åˆ°æ¶ˆæ¯: {:?}", msg);
        }
        _ = sleep(Duration::from_secs(1)) => {
            println!("è¶…æ—¶ï¼");
        }
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. biased æ¨¡å¼: ä¼˜å…ˆçº§é€‰æ‹©
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::select! {
        biased; // æŒ‰é¡ºåºæ£€æŸ¥åˆ†æ”¯
        
        msg = rx.recv() => {
            println!("é«˜ä¼˜å…ˆçº§: æ¶ˆæ¯");
        }
        _ = sleep(Duration::from_secs(1)) => {
            println!("ä½ä¼˜å…ˆçº§: è¶…æ—¶");
        }
    }
}
```

### 4.3 å¹¶å‘é™åˆ¶

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// é™åˆ¶å¹¶å‘æ•°é‡ (ä¾‹å¦‚: æœ€å¤š 10 ä¸ªå¹¶å‘è¯·æ±‚)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(10)); // æœ€å¤š 10 ä¸ªå¹¶å‘
    let mut tasks = vec![];
    
    for i in 0..100 {
        let sem = Arc::clone(&semaphore);
        
        let task = tokio::spawn(async move {
            let _permit = sem.acquire().await.unwrap(); // è·å–è®¸å¯
            
            // æ‰§è¡Œè€—æ—¶æ“ä½œ
            println!("å¤„ç†ä»»åŠ¡ {}", i);
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            
            // _permit è¢« drop æ—¶è‡ªåŠ¨é‡Šæ”¾
        });
        
        tasks.push(task);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for task in tasks {
        task.await.unwrap();
    }
}
```

### 4.4 è¶…æ—¶å’Œå–æ¶ˆ

```rust
use tokio::time::{timeout, Duration};
use tokio::select;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. timeout: ä¸º Future è®¾ç½®è¶…æ—¶
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let result = timeout(Duration::from_secs(2), async {
        tokio::time::sleep(Duration::from_secs(5)).await;
        "å®Œæˆ"
    }).await;
    
    match result {
        Ok(val) => println!("ç»“æœ: {}", val),
        Err(_) => println!("è¶…æ—¶ï¼"),
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. å–æ¶ˆ: ä½¿ç”¨ CancellationToken
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    use tokio_util::sync::CancellationToken;
    
    let token = CancellationToken::new();
    let token_clone = token.clone();
    
    let task = tokio::spawn(async move {
        select! {
            _ = token_clone.cancelled() => {
                println!("ä»»åŠ¡è¢«å–æ¶ˆ");
            }
            _ = tokio::time::sleep(Duration::from_secs(10)) => {
                println!("ä»»åŠ¡å®Œæˆ");
            }
        }
    });
    
    // 1ç§’åå–æ¶ˆä»»åŠ¡
    tokio::time::sleep(Duration::from_secs(1)).await;
    token.cancel();
    
    task.await.unwrap();
}
```

---

## 5. å¼‚æ­¥é€šä¿¡

### 5.1 Channel (mpsc)

```rust
use tokio::sync::mpsc;
use std::time::Duration;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // åˆ›å»º channel (ç¼“å†²åŒºå¤§å°ä¸º 32)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let (tx, mut rx) = mpsc::channel(32);
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ç”Ÿäº§è€…ä»»åŠ¡
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::spawn(async move {
        for i in 0..10 {
            if tx.send(i).await.is_err() {
                println!("æ¥æ”¶è€…å·²å…³é—­");
                break;
            }
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // æ¶ˆè´¹è€…ä»»åŠ¡
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    while let Some(msg) = rx.recv().await {
        println!("æ”¶åˆ°æ¶ˆæ¯: {}", msg);
    }
    
    println!("Channel å·²å…³é—­");
}
```

### 5.2 Broadcast Channel

```rust
use tokio::sync::broadcast;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // åˆ›å»ºå¹¿æ’­ channel (å¤šä¸ªæ¥æ”¶è€…)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let (tx, mut rx1) = broadcast::channel(16);
    let mut rx2 = tx.subscribe();
    let mut rx3 = tx.subscribe();
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ç”Ÿäº§è€…
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::spawn(async move {
        for i in 0..5 {
            tx.send(i).unwrap();
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // å¤šä¸ªæ¶ˆè´¹è€…
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::spawn(async move {
        while let Ok(msg) = rx1.recv().await {
            println!("æ¥æ”¶è€…1: {}", msg);
        }
    });
    
    tokio::spawn(async move {
        while let Ok(msg) = rx2.recv().await {
            println!("æ¥æ”¶è€…2: {}", msg);
        }
    });
    
    tokio::spawn(async move {
        while let Ok(msg) = rx3.recv().await {
            println!("æ¥æ”¶è€…3: {}", msg);
        }
    });
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

### 5.3 Watch Channel

```rust
use tokio::sync::watch;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Watch channel: ç”¨äºçŠ¶æ€åŒæ­¥ (åªä¿ç•™æœ€æ–°å€¼)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let (tx, mut rx) = watch::channel("åˆå§‹å€¼");
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // è®¢é˜…è€…
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::spawn(async move {
        while rx.changed().await.is_ok() {
            println!("å€¼å·²æ›´æ–°: {}", *rx.borrow());
        }
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // å‘å¸ƒè€…
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tx.send("æ–°å€¼1").unwrap();
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    tx.send("æ–°å€¼2").unwrap();
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    tx.send("æ–°å€¼3").unwrap();
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
}
```

### 5.4 Oneshot Channel

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Oneshot channel: åªå‘é€ä¸€æ¬¡æ¶ˆæ¯
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let (tx, rx) = oneshot::channel();
    
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        tx.send("è®¡ç®—ç»“æœ").unwrap();
    });
    
    match rx.await {
        Ok(result) => println!("æ”¶åˆ°ç»“æœ: {}", result),
        Err(_) => println!("å‘é€è€…å·²å…³é—­"),
    }
}
```

---

## 6. å¼‚æ­¥é”å’ŒåŒæ­¥åŸè¯­

### 6.1 Mutex å’Œ RwLock

```rust
use tokio::sync::{Mutex, RwLock};
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. Mutex: äº’æ–¥é”
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let data = Arc::new(Mutex::new(0));
    let mut tasks = vec![];
    
    for _ in 0..10 {
        let data = Arc::clone(&data);
        let task = tokio::spawn(async move {
            let mut guard = data.lock().await;
            *guard += 1;
        });
        tasks.push(task);
    }
    
    for task in tasks {
        task.await.unwrap();
    }
    
    println!("æœ€ç»ˆå€¼: {}", *data.lock().await);
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. RwLock: è¯»å†™é” (å¤šè¯»ä¸€å†™)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    
    // å¤šä¸ªè¯»é”å¯ä»¥åŒæ—¶å­˜åœ¨
    let read1 = data.read().await;
    let read2 = data.read().await;
    println!("è¯»å–: {:?}, {:?}", *read1, *read2);
    drop(read1);
    drop(read2);
    
    // å†™é”æ˜¯æ’ä»–çš„
    let mut write = data.write().await;
    write.push(4);
    println!("å†™å…¥å: {:?}", *write);
}
```

### 6.2 Semaphore (ä¿¡å·é‡)

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ä¿¡å·é‡: é™åˆ¶å¹¶å‘è®¿é—®æ•°é‡
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let semaphore = Arc::new(Semaphore::new(3)); // æœ€å¤š 3 ä¸ªå¹¶å‘
    let mut tasks = vec![];
    
    for i in 0..10 {
        let sem = Arc::clone(&semaphore);
        let task = tokio::spawn(async move {
            let _permit = sem.acquire().await.unwrap();
            println!("ä»»åŠ¡ {} å¼€å§‹æ‰§è¡Œ", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            println!("ä»»åŠ¡ {} å®Œæˆ", i);
        });
        tasks.push(task);
    }
    
    for task in tasks {
        task.await.unwrap();
    }
}
```

### 6.3 Barrier

```rust
use tokio::sync::Barrier;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Barrier: ç­‰å¾…æ‰€æœ‰ä»»åŠ¡åˆ°è¾¾åŒæ­¥ç‚¹
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let barrier = Arc::new(Barrier::new(3)); // ç­‰å¾… 3 ä¸ªä»»åŠ¡
    let mut tasks = vec![];
    
    for i in 0..3 {
        let b = Arc::clone(&barrier);
        let task = tokio::spawn(async move {
            println!("ä»»åŠ¡ {} å‡†å¤‡ä¸­...", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(i)).await;
            
            println!("ä»»åŠ¡ {} åˆ°è¾¾å±éšœ", i);
            b.wait().await;
            
            println!("ä»»åŠ¡ {} ç»§ç»­æ‰§è¡Œ", i);
        });
        tasks.push(task);
    }
    
    for task in tasks {
        task.await.unwrap();
    }
}
```

### 6.4 Notify

```rust
use tokio::sync::Notify;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Notify: ç®€å•çš„é€šçŸ¥æœºåˆ¶
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let notify = Arc::new(Notify::new());
    let notify_clone = Arc::clone(&notify);
    
    tokio::spawn(async move {
        println!("ç­‰å¾…é€šçŸ¥...");
        notify_clone.notified().await;
        println!("æ”¶åˆ°é€šçŸ¥ï¼");
    });
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    println!("å‘é€é€šçŸ¥");
    notify.notify_one(); // é€šçŸ¥ä¸€ä¸ªç­‰å¾…è€…
    
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 å¼‚æ­¥ Web çˆ¬è™«

```rust
use reqwest;
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let urls = vec![
        "https://example.com/page1",
        "https://example.com/page2",
        "https://example.com/page3",
        // ... æ›´å¤š URL
    ];
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // é™åˆ¶å¹¶å‘æ•° (é¿å…è¿‡è½½)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let semaphore = Arc::new(Semaphore::new(10)); // æœ€å¤š 10 ä¸ªå¹¶å‘è¯·æ±‚
    let client = reqwest::Client::new();
    let mut tasks = vec![];
    
    for url in urls {
        let sem = Arc::clone(&semaphore);
        let client = client.clone();
        
        let task = tokio::spawn(async move {
            let _permit = sem.acquire().await.unwrap();
            
            match fetch_page(&client, url).await {
                Ok(content) => {
                    println!("æŠ“å–æˆåŠŸ: {} ({} bytes)", url, content.len());
                }
                Err(e) => {
                    eprintln!("æŠ“å–å¤±è´¥: {} - {:?}", url, e);
                }
            }
        });
        
        tasks.push(task);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for task in tasks {
        task.await?;
    }
    
    Ok(())
}

async fn fetch_page(client: &reqwest::Client, url: &str) -> Result<String, reqwest::Error> {
    let response = client.get(url).send().await?;
    let content = response.text().await?;
    Ok(content)
}
```

### 7.2 å®æ—¶èŠå¤©æœåŠ¡å™¨

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};

#[tokio::main]
async fn main() -> std::io::Result<()> {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // åˆ›å»ºå¹¿æ’­ channel (ç”¨äºæ¶ˆæ¯åˆ†å‘)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let (tx, _rx) = broadcast::channel::<String>(100);
    
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("èŠå¤©æœåŠ¡å™¨å¯åŠ¨: 127.0.0.1:8080");
    
    loop {
        let (socket, addr) = listener.accept().await?;
        let tx = tx.clone();
        let rx = tx.subscribe();
        
        tokio::spawn(async move {
            handle_client(socket, addr.to_string(), tx, rx).await;
        });
    }
}

async fn handle_client(
    socket: TcpStream,
    addr: String,
    tx: broadcast::Sender<String>,
    mut rx: broadcast::Receiver<String>,
) {
    let (reader, mut writer) = socket.into_split();
    let mut reader = BufReader::new(reader);
    let mut line = String::new();
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // å‘é€æ¬¢è¿æ¶ˆæ¯
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let welcome = format!("æ¬¢è¿åŠ å…¥èŠå¤©å®¤ï¼ä½ çš„åœ°å€: {}\n", addr);
    writer.write_all(welcome.as_bytes()).await.ok();
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // å¹¿æ’­åŠ å…¥æ¶ˆæ¯
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let join_msg = format!("{} åŠ å…¥äº†èŠå¤©å®¤", addr);
    tx.send(join_msg).ok();
    
    loop {
        tokio::select! {
            // è¯»å–å®¢æˆ·ç«¯æ¶ˆæ¯
            result = reader.read_line(&mut line) => {
                match result {
                    Ok(0) => break, // è¿æ¥å…³é—­
                    Ok(_) => {
                        let msg = format!("{}: {}", addr, line.trim());
                        tx.send(msg).ok();
                        line.clear();
                    }
                    Err(_) => break,
                }
            }
            
            // æ¥æ”¶å¹¿æ’­æ¶ˆæ¯
            Ok(msg) = rx.recv() => {
                writer.write_all(format!("{}\n", msg).as_bytes()).await.ok();
            }
        }
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // å¹¿æ’­ç¦»å¼€æ¶ˆæ¯
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    let leave_msg = format!("{} ç¦»å¼€äº†èŠå¤©å®¤", addr);
    tx.send(leave_msg).ok();
}
```

### 7.3 å¼‚æ­¥æ‰¹å¤„ç†ç³»ç»Ÿ

```rust
use tokio::sync::mpsc;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(100);
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ç”Ÿäº§è€…: ç”Ÿæˆä»»åŠ¡
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    tokio::spawn(async move {
        for i in 0..100 {
            tx.send(i).await.unwrap();
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    });
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // æ¶ˆè´¹è€…: æ‰¹å¤„ç†ä»»åŠ¡
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    batch_processor(rx, 10, Duration::from_millis(100)).await;
}

async fn batch_processor(
    mut rx: mpsc::Receiver<i32>,
    batch_size: usize,
    timeout: Duration,
) {
    let mut batch = Vec::new();
    
    loop {
        tokio::select! {
            // æ¥æ”¶æ–°ä»»åŠ¡
            Some(task) = rx.recv() => {
                batch.push(task);
                
                // è¾¾åˆ°æ‰¹é‡å¤§å°æ—¶ç«‹å³å¤„ç†
                if batch.len() >= batch_size {
                    process_batch(&batch).await;
                    batch.clear();
                }
            }
            
            // è¶…æ—¶æ—¶å¤„ç†å‰©ä½™ä»»åŠ¡
            _ = tokio::time::sleep(timeout), if !batch.is_empty() => {
                process_batch(&batch).await;
                batch.clear();
            }
            
            // Channel å…³é—­
            else => break,
        }
    }
    
    // å¤„ç†æœ€åçš„æ‰¹æ¬¡
    if !batch.is_empty() {
        process_batch(&batch).await;
    }
}

async fn process_batch(batch: &[i32]) {
    println!("å¤„ç†æ‰¹æ¬¡ (å¤§å°: {}): {:?}", batch.len(), batch);
    tokio::time::sleep(Duration::from_millis(50)).await;
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 å‡å°‘åˆ†é…

```rust
use bytes::Bytes;

// âŒ é”™è¯¯: æ¯æ¬¡éƒ½åˆ†é…æ–° Vec
async fn bad_example() {
    let data = vec![0u8; 1024];
    // ...
}

// âœ… æ­£ç¡®: ä½¿ç”¨ bytes::Bytes (å¼•ç”¨è®¡æ•°, é›¶æ‹·è´)
async fn good_example() {
    let data = Bytes::from_static(&[0u8; 1024]);
    // ...
}
```

### 8.2 é¿å…ä¸å¿…è¦çš„ await

```rust
// âŒ é”™è¯¯: ä¸å¿…è¦çš„ await
async fn bad_compute() -> i32 {
    let result = compute().await; // compute æ˜¯åŒæ­¥å‡½æ•°
    result
}

fn compute() -> i32 {
    42
}

// âœ… æ­£ç¡®: ç›´æ¥è°ƒç”¨åŒæ­¥å‡½æ•°
async fn good_compute() -> i32 {
    compute() // ä¸éœ€è¦ await
}
```

### 8.3 æ‰¹å¤„ç†ä¼˜åŒ–

```rust
use tokio::sync::mpsc;

// âŒ é”™è¯¯: æ¯æ¬¡å†™å…¥ä¸€æ¡è®°å½•
async fn bad_insert(rx: &mut mpsc::Receiver<String>) {
    while let Some(data) = rx.recv().await {
        database_insert_one(data).await;
    }
}

// âœ… æ­£ç¡®: æ‰¹é‡å†™å…¥
async fn good_insert(rx: &mut mpsc::Receiver<String>) {
    let mut batch = Vec::new();
    
    while let Some(data) = rx.recv().await {
        batch.push(data);
        
        if batch.len() >= 100 {
            database_insert_batch(&batch).await;
            batch.clear();
        }
    }
}

async fn database_insert_one(_data: String) {}
async fn database_insert_batch(_batch: &[String]) {}
```

### 8.4 é›¶æ‹·è´æŠ€æœ¯

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ä½¿ç”¨ tokio::io::copy å®ç°é›¶æ‹·è´è½¬å‘
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
async fn proxy(mut client: TcpStream, mut server: TcpStream) -> std::io::Result<()> {
    let (mut client_read, mut client_write) = client.split();
    let (mut server_read, mut server_write) = server.split();
    
    // åŒå‘è½¬å‘ (é›¶æ‹·è´)
    tokio::try_join!(
        tokio::io::copy(&mut client_read, &mut server_write),
        tokio::io::copy(&mut server_read, &mut client_write),
    )?;
    
    Ok(())
}
```

---

## 9. è°ƒè¯•å’Œè¯Šæ–­

### 9.1 tokio-console

**å®‰è£…å’Œé…ç½®:**

```toml
# Cargo.toml
[dependencies]
tokio = { version = "1.0", features = ["full", "tracing"] }
console-subscriber = "0.2"
```

```rust
fn main() {
    // å¯åŠ¨ tokio-console
    console_subscriber::init();
    
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        // ä½ çš„å¼‚æ­¥ä»£ç 
    });
}
```

**è¿è¡Œ:**

```bash
# 1. å¯åŠ¨åº”ç”¨
cargo run

# 2. åœ¨å¦ä¸€ä¸ªç»ˆç«¯å¯åŠ¨ console
cargo install tokio-console
tokio-console
```

### 9.2 tracing é›†æˆ

```rust
use tracing::{info, warn, error, instrument};

#[instrument]
async fn fetch_user(user_id: u64) -> Result<String, &'static str> {
    info!("å¼€å§‹è·å–ç”¨æˆ·");
    
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    if user_id == 0 {
        error!("æ— æ•ˆçš„ç”¨æˆ· ID");
        return Err("æ— æ•ˆçš„ç”¨æˆ· ID");
    }
    
    info!("ç”¨æˆ·è·å–æˆåŠŸ");
    Ok(format!("User {}", user_id))
}

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ– tracing
    tracing_subscriber::fmt::init();
    
    fetch_user(123).await.ok();
    fetch_user(0).await.ok();
}
```

### 9.3 æ­»é”æ£€æµ‹

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let lock1 = Arc::new(Mutex::new(0));
    let lock2 = Arc::new(Mutex::new(0));
    
    let lock1_clone = Arc::clone(&lock1);
    let lock2_clone = Arc::clone(&lock2);
    
    // âŒ å¯èƒ½æ­»é”çš„ä»£ç 
    tokio::spawn(async move {
        let _g1 = lock1_clone.lock().await;
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        let _g2 = lock2_clone.lock().await;
    });
    
    tokio::spawn(async move {
        let _g2 = lock2.lock().await;
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        let _g1 = lock1.lock().await;
    });
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

---

## 10. æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶é…ç½®**
   - IO å¯†é›†å‹: å¤šçº¿ç¨‹è¿è¡Œæ—¶ (é»˜è®¤)
   - CPU å¯†é›†å‹: ä½¿ç”¨ `tokio::task::spawn_blocking`
   - åµŒå…¥å¼/è½»é‡çº§: å•çº¿ç¨‹è¿è¡Œæ—¶

2. **é™åˆ¶å¹¶å‘æ•°é‡**

   ```rust
   use tokio::sync::Semaphore;
   let sem = Semaphore::new(100); // é™åˆ¶å¹¶å‘
   ```

3. **ä½¿ç”¨æ‰¹å¤„ç†**
   - å‡å°‘æ•°æ®åº“/ç½‘ç»œå¾€è¿”æ¬¡æ•°
   - æé«˜ååé‡

4. **é¿å…é˜»å¡æ“ä½œ**

   ```rust
   // âŒ é”™è¯¯: é˜»å¡ async å‡½æ•°
   async fn bad() {
       std::thread::sleep(Duration::from_secs(1));
   }
   
   // âœ… æ­£ç¡®: ä½¿ç”¨ spawn_blocking
   async fn good() {
       tokio::task::spawn_blocking(|| {
           std::thread::sleep(Duration::from_secs(1));
       }).await.unwrap();
   }
   ```

5. **åˆç†ä½¿ç”¨ select!**
   - ä½¿ç”¨ `biased` æ¨¡å¼æ§åˆ¶ä¼˜å…ˆçº§
   - é¿å…é¥¥é¥¿é—®é¢˜

6. **é”™è¯¯å¤„ç†**

   ```rust
   // ä½¿ç”¨ ? æ“ä½œç¬¦ç®€åŒ–é”™è¯¯ä¼ æ’­
   async fn fetch() -> Result<String, reqwest::Error> {
       let resp = reqwest::get("https://example.com").await?;
       let text = resp.text().await?;
       Ok(text)
   }
   ```

7. **èµ„æºæ¸…ç†**

   ```rust
   // ä½¿ç”¨ Drop guard ç¡®ä¿èµ„æºé‡Šæ”¾
   struct Guard {
       name: String,
   }
   
   impl Drop for Guard {
       fn drop(&mut self) {
           println!("{} è¢«æ¸…ç†", self.name);
       }
   }
   ```

8. **ç›‘æ§å’Œå¯è§‚æµ‹æ€§**
   - ä½¿ç”¨ `tracing` è®°å½•æ—¥å¿—
   - ä½¿ç”¨ `tokio-console` ç›‘æ§è¿è¡Œæ—¶
   - ä½¿ç”¨ `metrics` æ”¶é›†æ€§èƒ½æŒ‡æ ‡

9. **æµ‹è¯•**

   ```rust
   #[tokio::test]
   async fn test_async_function() {
       let result = my_async_function().await;
       assert_eq!(result, expected);
   }
   ```

10. **é¿å…è¿‡åº¦åµŒå¥—**

    ```rust
    // âŒ é”™è¯¯: åµŒå¥—è¿‡æ·±
    async fn bad() {
        tokio::spawn(async {
            tokio::spawn(async {
                tokio::spawn(async {
                    // ...
                });
            });
        });
    }
    
    // âœ… æ­£ç¡®: æ‰å¹³åŒ–
    async fn good() {
        let task1 = tokio::spawn(task1());
        let task2 = tokio::spawn(task2());
        let task3 = tokio::spawn(task3());
        
        tokio::try_join!(task1, task2, task3).ok();
    }
    
    async fn task1() {}
    async fn task2() {}
    async fn task3() {}
    ```

---

## 11. å¸¸è§é™·é˜±

1. **å¿˜è®° .await**

   ```rust
   // âŒ é”™è¯¯: æ²¡æœ‰ await, Future ä¸ä¼šæ‰§è¡Œ
   async fn bad() {
       fetch_data(); // ä»€ä¹ˆä¹Ÿä¸åš
   }
   
   // âœ… æ­£ç¡®
   async fn good() {
       fetch_data().await;
   }
   
   async fn fetch_data() {}
   ```

2. **åœ¨ async å‡½æ•°ä¸­ä½¿ç”¨æ ‡å‡†åº“çš„é˜»å¡ API**

   ```rust
   // âŒ é”™è¯¯: é˜»å¡æ•´ä¸ªè¿è¡Œæ—¶
   async fn bad() {
       std::fs::read_to_string("file.txt").unwrap();
   }
   
   // âœ… æ­£ç¡®: ä½¿ç”¨ Tokio çš„å¼‚æ­¥ç‰ˆæœ¬
   async fn good() {
       tokio::fs::read_to_string("file.txt").await.unwrap();
   }
   ```

3. **è¿‡åº¦ä½¿ç”¨ `Arc<Mutex>`**

   ```rust
   // âŒ å¯èƒ½å¯¼è‡´æ€§èƒ½é—®é¢˜
   use std::sync::Arc;
   use tokio::sync::Mutex;
   
   let data = Arc::new(Mutex::new(vec![]));
   
   // âœ… è€ƒè™‘ä½¿ç”¨ channel ä»£æ›¿
   use tokio::sync::mpsc;
   let (tx, rx) = mpsc::channel(100);
   ```

4. **select! ä¸­çš„æ‰€æœ‰æƒé—®é¢˜**

   ```rust
   // âŒ é”™è¯¯: value moved
   async fn bad() {
       let data = String::from("data");
       tokio::select! {
           _ = process(&data) => {},
           _ = other(&data) => {}, // Error: value moved
       }
   }
   
   // âœ… æ­£ç¡®: ä½¿ç”¨å¼•ç”¨
   async fn good() {
       let data = String::from("data");
       tokio::select! {
           _ = process(&data) => {},
           _ = other(&data) => {},
       }
   }
   
   async fn process(_s: &str) {}
   async fn other(_s: &str) {}
   ```

5. **æ³„æ¼ JoinHandle**

   ```rust
   // âŒ é”™è¯¯: ä»»åŠ¡å¯èƒ½æ°¸è¿œä¸ä¼šå®Œæˆ
   async fn bad() {
       tokio::spawn(async {
           // é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
       });
       // JoinHandle è¢«ä¸¢å¼ƒ, ä»»åŠ¡åœ¨åå°è¿è¡Œ
   }
   
   // âœ… æ­£ç¡®: ä¿å­˜ JoinHandle å¹¶ç­‰å¾…
   async fn good() {
       let handle = tokio::spawn(async {
           // é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
       });
       handle.await.unwrap();
   }
   ```

6. **Send çº¦æŸé—®é¢˜**

   ```rust
   // âŒ é”™è¯¯: Rc ä¸æ˜¯ Send
   use std::rc::Rc;
   
   async fn bad() {
       let data = Rc::new(42);
       tokio::spawn(async move {
           println!("{}", data); // Error: Rc is not Send
       });
   }
   
   // âœ… æ­£ç¡®: ä½¿ç”¨ Arc
   use std::sync::Arc;
   
   async fn good() {
       let data = Arc::new(42);
       tokio::spawn(async move {
           println!("{}", data);
       });
   }
   ```

7. **åœ¨å¾ªç¯ä¸­åˆ›å»ºè¿‡å¤šä»»åŠ¡**

   ```rust
   // âŒ é”™è¯¯: å¯èƒ½è€—å°½èµ„æº
   async fn bad() {
       for i in 0..1000000 {
           tokio::spawn(async move {
               // ...
           });
       }
   }
   
   // âœ… æ­£ç¡®: ä½¿ç”¨ Semaphore é™æµ
   use tokio::sync::Semaphore;
   use std::sync::Arc;
   
   async fn good() {
       let sem = Arc::new(Semaphore::new(100));
       for i in 0..1000000 {
           let sem = Arc::clone(&sem);
           tokio::spawn(async move {
               let _permit = sem.acquire().await;
               // ...
           });
       }
   }
   ```

8. **ä¸æ­£ç¡®çš„è¶…æ—¶å¤„ç†**

   ```rust
   // âŒ é”™è¯¯: è¶…æ—¶åä»»åŠ¡ä»åœ¨è¿è¡Œ
   use tokio::time::{timeout, Duration};
   
   async fn bad() {
       let result = timeout(Duration::from_secs(1), long_task()).await;
       // long_task() å¯èƒ½ä»åœ¨åå°è¿è¡Œ
   }
   
   // âœ… æ­£ç¡®: ä½¿ç”¨ CancellationToken
   use tokio_util::sync::CancellationToken;
   
   async fn good() {
       let token = CancellationToken::new();
       let token_clone = token.clone();
       
       let task = tokio::spawn(async move {
           cancellable_task(token_clone).await
       });
       
       tokio::select! {
           _ = task => {},
           _ = tokio::time::sleep(Duration::from_secs(1)) => {
               token.cancel();
           }
       }
   }
   
   async fn long_task() {}
   async fn cancellable_task(_token: CancellationToken) {}
   ```

---

## 12. å‚è€ƒèµ„æº

- **å®˜æ–¹æ–‡æ¡£**:
  - [Tokio å®˜æ–¹æ–‡æ¡£](https://tokio.rs/)
  - [async book](https://rust-lang.github.io/async-book/)
  - [std::future](https://doc.rust-lang.org/std/future/)

- **æ•™ç¨‹**:
  - [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
  - [async-std book](https://book.async.rs/)

- **å·¥å…·**:
  - [tokio-console](https://github.com/tokio-rs/console)
  - [tracing](https://github.com/tokio-rs/tracing)
  - [criterion](https://github.com/bheisler/criterion.rs)

- **åº“**:
  - [tokio](https://github.com/tokio-rs/tokio)
  - [async-std](https://github.com/async-rs/async-std)
  - [smol](https://github.com/smol-rs/smol)
  - [futures](https://github.com/rust-lang/futures-rs)

- **ç¤¾åŒº**:
  - [Tokio Discord](https://discord.gg/tokio)
  - [Rust å¼‚æ­¥å·¥ä½œç»„](https://rust-lang.github.io/wg-async/)

---

> **å®Œæˆï¼** ğŸ‰
>
> æœ¬æŒ‡å—æ¶µç›–äº† Rust å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µã€Tokio è¿è¡Œæ—¶ã€å¼‚æ­¥ IOã€ä»»åŠ¡ç®¡ç†ã€é€šä¿¡æœºåˆ¶ã€åŒæ­¥åŸè¯­ã€å®æˆ˜æ¡ˆä¾‹ã€æ€§èƒ½ä¼˜åŒ–ã€è°ƒè¯•è¯Šæ–­ã€æœ€ä½³å®è·µå’Œå¸¸è§é™·é˜±ã€‚å¸Œæœ›è¿™ä»½æŒ‡å—èƒ½å¸®åŠ©ä½ æŒæ¡ Rust å¼‚æ­¥ç¼–ç¨‹ï¼Œæ„å»ºé«˜æ€§èƒ½çš„å¼‚æ­¥åº”ç”¨ï¼
