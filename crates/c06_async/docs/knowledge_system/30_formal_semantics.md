# å¼‚æ­¥ç¼–ç¨‹å½¢å¼è¯­ä¹‰ (Formal Semantics)

> **æ–‡æ¡£ç±»å‹**: ğŸ”¬ æ•°å­¦æ¨¡å‹ | ğŸ“ å½¢å¼åŒ–æ–¹æ³• | ğŸ“ ç†è®ºåŸºç¡€  
> **ç›®æ ‡**: æä¾›å¼‚æ­¥ç¼–ç¨‹çš„ç²¾ç¡®æ•°å­¦è¯­ä¹‰å’Œå½¢å¼åŒ–è§„èŒƒ  
> **æ–¹æ³•**: æ“ä½œè¯­ä¹‰ + æŒ‡ç§°è¯­ä¹‰ + ç±»å‹è®º + èŒƒç•´è®º

**æœ€åæ›´æ–°**: 2025-10-19

---

## ğŸ“‹ å½¢å¼ç³»ç»Ÿæ¦‚è§ˆ

### è¯­ä¹‰å±‚æ¬¡

```text
å½¢å¼è¯­ä¹‰ä½“ç³»
â”œâ”€â”€ è¯­æ³• (Syntax)
â”‚   â”œâ”€â”€ abstract syntax
â”‚   â”œâ”€â”€ type grammar
â”‚   â””â”€â”€ well-formedness rules
â”‚
â”œâ”€â”€ ç±»å‹ç³»ç»Ÿ (Type System)
â”‚   â”œâ”€â”€ typing rules
â”‚   â”œâ”€â”€ subtyping
â”‚   â””â”€â”€ type safety
â”‚
â”œâ”€â”€ æ“ä½œè¯­ä¹‰ (Operational Semantics)
â”‚   â”œâ”€â”€ small-step semantics
â”‚   â”œâ”€â”€ big-step semantics
â”‚   â””â”€â”€ reduction rules
â”‚
â”œâ”€â”€ æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)
â”‚   â”œâ”€â”€ domain theory
â”‚   â”œâ”€â”€ mathematical mapping
â”‚   â””â”€â”€ compositional semantics
â”‚
â””â”€â”€ ä»£æ•°è¯­ä¹‰ (Algebraic Semantics)
    â”œâ”€â”€ equational laws
    â”œâ”€â”€ category theory
    â””â”€â”€ monad laws
```

---

## ğŸ¯ ç¬¬ä¸€éƒ¨åˆ†: æŠ½è±¡è¯­æ³•

### 1.1 æ ¸å¿ƒè¯­æ³•

#### ç±»å‹è¯­æ³•

```text
Ï„ ::= T                        // åŸºç¡€ç±»å‹
    | Ï„â‚ â†’ Ï„â‚‚                  // å‡½æ•°ç±»å‹
    | Future<Ï„>                // Futureç±»å‹
    | Pin<Ptr<Ï„>>              // Pinç±»å‹
    | (Ï„â‚, Ï„â‚‚, ..., Ï„â‚™)        // å…ƒç»„ç±»å‹
    | &'a Ï„                    // å¼•ç”¨ç±»å‹
    | &'a mut Ï„                // å¯å˜å¼•ç”¨

Ptr ::= Box<Ï„>                 // å †æŒ‡é’ˆ
      | &Ï„                     // å¼•ç”¨
      | &mut Ï„                 // å¯å˜å¼•ç”¨

çº¦æŸ ::= T: Send               // Sendçº¦æŸ
       | T: Sync               // Syncçº¦æŸ
       | T: Unpin              // Unpinçº¦æŸ
       | T: 'static            // é™æ€ç”Ÿå‘½å‘¨æœŸ
```

#### è¡¨è¾¾å¼è¯­æ³•

```text
e ::= x                        // å˜é‡
    | v                        // å€¼
    | eâ‚ eâ‚‚                    // å‡½æ•°åº”ç”¨
    | Î»x: Ï„. e                 // lambdaæŠ½è±¡
    | async { e }              // å¼‚æ­¥å—
    | e.await                  // awaitè¡¨è¾¾å¼
    | poll(e, cx)              // pollæ“ä½œ
    | let x = eâ‚ in eâ‚‚         // letç»‘å®š
    | (eâ‚, eâ‚‚, ..., eâ‚™)        // å…ƒç»„

v ::= ()                       // unit
    | n                        // æ•´æ•°
    | Ready(v)                 // Readyå€¼
    | Pending                  // Pendingå€¼
    | Future(S, k)             // Futureå€¼ (çŠ¶æ€S, å»¶ç»­k)
    | Pin(ptr)                 // Pinå€¼
```

#### è¿è¡Œæ—¶è¯­æ³•

```text
çŠ¶æ€ S ::= Sâ‚€                  // åˆå§‹çŠ¶æ€
         | Sâ‚                  // ä¸­é—´çŠ¶æ€
         | ...
         | Sâ‚™                  // æœ€ç»ˆçŠ¶æ€

ä¸Šä¸‹æ–‡ Î“ ::= âˆ…                 // ç©ºä¸Šä¸‹æ–‡
          | Î“, x: Ï„            // å˜é‡ç»‘å®š
          | Î“, 'a              // ç”Ÿå‘½å‘¨æœŸå‚æ•°

æ‰§è¡Œä¸Šä¸‹æ–‡ cx ::= Context {
    waker: Waker,
    local: TaskLocal,
    ...
}
```

---

## ğŸ¯ ç¬¬äºŒéƒ¨åˆ†: ç±»å‹ç³»ç»Ÿ

### 2.1 ç±»å‹è§„åˆ™

#### Futureç±»å‹

```text
Futureç±»å‹è§„åˆ™:

              Î“ âŠ¢ e: Ï„
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ async { e }: Future<Ï„>

              Î“ âŠ¢ e: Future<Ï„>
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ e.await: Ï„

å‰æ: Î“æ˜¯asyncä¸Šä¸‹æ–‡
```

#### Pinç±»å‹

```text
Pinç±»å‹è§„åˆ™:

    Ï„: Unpin    Î“ âŠ¢ ptr: Ptr<Ï„>
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ Pin::new(ptr): Pin<Ptr<Ï„>>

    Î“ âŠ¢ ptr: Ptr<Ï„>
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (unsafe)
    Î“ âŠ¢ Pin::new_unchecked(ptr): Pin<Ptr<Ï„>>

    Î“ âŠ¢ p: Pin<Ptr<Ï„>>    Ï„: Unpin
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ Pin::into_inner(p): Ptr<Ï„>
```

#### Send/Syncè§„åˆ™

```text
Sendä¼ é€’è§„åˆ™:

    Î“ âŠ¢ Ï„â‚: Send    Î“ âŠ¢ Ï„â‚‚: Send
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ (Ï„â‚, Ï„â‚‚): Send

    Î“ âŠ¢ Ï„: Send
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ Vec<Ï„>: Send

    Î“ âŠ¢ Ï„: Send + Sync
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ Arc<Ï„>: Send + Sync

Syncå®šä¹‰:

    Î“ âŠ¢ &Ï„: Send
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Î“ âŠ¢ Ï„: Sync
```

### 2.2 å­ç±»å‹å…³ç³»

```text
å­ç±»å‹è§„åˆ™:

    Ï„ <: Ï„                     // åå°„æ€§

    Ï„â‚ <: Ï„â‚‚    Ï„â‚‚ <: Ï„â‚ƒ
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       // ä¼ é€’æ€§
    Ï„â‚ <: Ï„â‚ƒ

    Ï„â‚‚ <: Ï„â‚    Ï„â‚ƒ <: Ï„â‚„
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     // å‡½æ•°é€†å˜/åå˜
    Ï„â‚ â†’ Ï„â‚ƒ <: Ï„â‚‚ â†’ Ï„â‚„

    Ï„ <: Ï„'
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     // Futureåå˜
    Future<Ï„> <: Future<Ï„'>

    'a âŠ† 'b    Ï„ <: Ï„'
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     // å¼•ç”¨é€†å˜/åå˜
    &'b Ï„ <: &'a Ï„'
```

---

## ğŸ¯ ç¬¬ä¸‰éƒ¨åˆ†: æ“ä½œè¯­ä¹‰

### 3.1 Small-Stepè¯­ä¹‰

#### åŸºæœ¬è§„åˆ™

```text
æ±‚å€¼å…³ç³»: âŸ¨e, ÏƒâŸ© â†’ âŸ¨e', Ïƒ'âŸ©
(è¡¨è¾¾å¼eåœ¨çŠ¶æ€Ïƒä¸‹å½’çº¦åˆ°e'å’Œæ–°çŠ¶æ€Ïƒ')

å˜é‡æŸ¥æ‰¾:
    âŸ¨x, ÏƒâŸ© â†’ âŸ¨v, ÏƒâŸ©    where Ïƒ(x) = v

å‡½æ•°åº”ç”¨:
    âŸ¨(Î»x. e) v, ÏƒâŸ© â†’ âŸ¨e[v/x], ÏƒâŸ©

letç»‘å®š:
    âŸ¨let x = v in e, ÏƒâŸ© â†’ âŸ¨e, Ïƒ[x â†¦ v]âŸ©
```

#### Futureè§„çº¦

```text
asyncå—åˆ›å»º:
    âŸ¨async { e }, ÏƒâŸ© â†’ âŸ¨Future(Sâ‚€, e), ÏƒâŸ©
    
    where Sâ‚€ = initial state
          e = continuation

awaitè§„çº¦:
    âŸ¨Future(Ready(v)).await, ÏƒâŸ© â†’ âŸ¨v, ÏƒâŸ©

    âŸ¨Future(Pending).await, ÏƒâŸ© â†’ âŸ¨Pending, ÏƒâŸ©
    (æš‚åœï¼Œè¿”å›ç»™è¿è¡Œæ—¶)

pollè°ƒç”¨:
    âŸ¨poll(Future(S, k), cx), ÏƒâŸ© â†’ 
        âŸ¨match execute_state(S, k, cx) {
            Ready(v) => Ready(v),
            Pending => {
                register_waker(cx.waker);
                Pending
            }
        }, Ïƒ'âŸ©
```

#### çŠ¶æ€æœºè½¬æ¢

```text
çŠ¶æ€è½¬æ¢è§„åˆ™:

åˆå§‹çŠ¶æ€:
    Sâ‚€ â”€executeâ”€> Sâ‚    or    Ready(v)

ä¸­é—´çŠ¶æ€:
    Sáµ¢ â”€pollâ”€> Sáµ¢â‚Šâ‚    or    Ready(v)    or    Pending

.awaitç‚¹:
    Sáµ¢ at await_point â”€poll_innerâ”€> 
        if inner.poll() == Ready(v):
            Sáµ¢â‚Šâ‚ with v
        else:
            Pending (save Sáµ¢)

å®Œæˆ:
    Sâ‚™ â”€> Ready(final_value)
```

### 3.2 å¹¶å‘è¯­ä¹‰

#### joinè¯­ä¹‰

```text
joinè§„åˆ™:

    âŸ¨poll(fâ‚, cx)âŸ© â†’ Ready(vâ‚)
    âŸ¨poll(fâ‚‚, cx)âŸ© â†’ Ready(vâ‚‚)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    âŸ¨join(fâ‚, fâ‚‚)âŸ© â†’ Ready((vâ‚, vâ‚‚))

    âŸ¨poll(fâ‚, cx)âŸ© â†’ Pending  âˆ¨  âŸ¨poll(fâ‚‚, cx)âŸ© â†’ Pending
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    âŸ¨join(fâ‚, fâ‚‚)âŸ© â†’ Pending

å¹¶å‘æ€§è´¨:
    join(fâ‚, fâ‚‚) â‰¡ join(fâ‚‚, fâ‚)    // äº¤æ¢å¾‹
    join(join(fâ‚, fâ‚‚), fâ‚ƒ) â‰¡ join(fâ‚, join(fâ‚‚, fâ‚ƒ))    // ç»“åˆå¾‹
```

#### selectè¯­ä¹‰

```text
selectè§„åˆ™:

    âŸ¨poll(fâ‚, cx)âŸ© â†’ Ready(vâ‚)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    âŸ¨select(fâ‚, fâ‚‚)âŸ© â†’ Ready(vâ‚)
    (å¹¶å–æ¶ˆfâ‚‚)

    âŸ¨poll(fâ‚‚, cx)âŸ© â†’ Ready(vâ‚‚)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    âŸ¨select(fâ‚, fâ‚‚)âŸ© â†’ Ready(vâ‚‚)
    (å¹¶å–æ¶ˆfâ‚)

    âŸ¨poll(fâ‚, cx)âŸ© â†’ Pending  âˆ§  âŸ¨poll(fâ‚‚, cx)âŸ© â†’ Pending
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    âŸ¨select(fâ‚, fâ‚‚)âŸ© â†’ Pending

éç¡®å®šæ€§:
    select(fâ‚, fâ‚‚) â‰¢ select(fâ‚‚, fâ‚)    // å¯èƒ½ä¸åŒ
```

---

## ğŸ¯ ç¬¬å››éƒ¨åˆ†: æŒ‡ç§°è¯­ä¹‰

### 4.1 è¯­ä¹‰åŸŸ

#### åŸŸå®šä¹‰

```text
å€¼åŸŸ V = {(), n, Ready(V), Pending, ...}

FutureåŸŸ F:
    F[Ï„] = (State Ã— Context) â†’ (Poll[Ï„] Ã— State)

    where Poll[Ï„] = Ready(Ï„) | Pending

çŠ¶æ€åŸŸ State:
    State = å±€éƒ¨å˜é‡ Ã— æ•è·å˜é‡ Ã— ç¨‹åºè®¡æ•°å™¨

ä¸Šä¸‹æ–‡åŸŸ Context:
    Context = Waker Ã— TaskLocal
```

### 4.2 è¯­ä¹‰å‡½æ•°

#### è¡¨è¾¾å¼è¯­ä¹‰

```text
è¯­ä¹‰å‡½æ•° âŸ¦Â·âŸ§: Expr â†’ Env â†’ Value

âŸ¦xâŸ§(Ï) = Ï(x)

âŸ¦vâŸ§(Ï) = v

âŸ¦Î»x. eâŸ§(Ï) = Closure(x, e, Ï)

âŸ¦eâ‚ eâ‚‚âŸ§(Ï) = 
    let vâ‚ = âŸ¦eâ‚âŸ§(Ï)
    let vâ‚‚ = âŸ¦eâ‚‚âŸ§(Ï)
    apply(vâ‚, vâ‚‚)

âŸ¦async { e }âŸ§(Ï) = 
    Future(Î»(s, cx). 
        let v = âŸ¦eâŸ§(Ï âŠ• {state: s, context: cx})
        match v {
            Ready(v) => (Ready(v), s'),
            Pending => (Pending, s)
        }
    )

âŸ¦e.awaitâŸ§(Ï) = 
    let Future(f) = âŸ¦eâŸ§(Ï)
    loop {
        match f(state, cx) {
            (Ready(v), s') => return v,
            (Pending, s') => {
                save_state(s');
                yield_to_runtime();
            }
        }
    }
```

### 4.3 ç»„åˆæ€§åŸç†

```text
ç»„åˆæ€§ (Compositionality):
    âŸ¦e[e'/x]âŸ§ = âŸ¦eâŸ§[âŸ¦e'âŸ§/x]

å•è°ƒæ€§ (Monotonicity):
    e âŠ‘ e' âŸ¹ âŸ¦eâŸ§ âŠ‘ âŸ¦e'âŸ§

è¿ç»­æ€§ (Continuity):
    âŸ¦âŠ”áµ¢ eáµ¢âŸ§ = âŠ”áµ¢ âŸ¦eáµ¢âŸ§
```

---

## ğŸ¯ ç¬¬äº”éƒ¨åˆ†: ä»£æ•°è¯­ä¹‰

### 5.1 Monadç»“æ„

#### Future Monad

```text
Futureä½œä¸ºMonad:

unit (return):
    return: Ï„ â†’ Future<Ï„>
    return(v) = ready(v)

bind (>>=):
    (>>=): Future<Ï„> â†’ (Ï„ â†’ Future<Ï…>) â†’ Future<Ï…>
    m >>= f = then(m, f)

Monadå¾‹:

1. å·¦å•ä½å¾‹:
    return(v) >>= f  â‰¡  f(v)

2. å³å•ä½å¾‹:
    m >>= return  â‰¡  m

3. ç»“åˆå¾‹:
    (m >>= f) >>= g  â‰¡  m >>= (Î»x. f(x) >>= g)

è¯æ˜:
    ä½¿ç”¨æŒ‡ç§°è¯­ä¹‰å±•å¼€éªŒè¯æ¯æ¡å®šå¾‹
```

### 5.2 Functorç»“æ„

```text
Futureä½œä¸ºFunctor:

fmap (map):
    fmap: (Ï„ â†’ Ï…) â†’ Future<Ï„> â†’ Future<Ï…>
    fmap(f, m) = map(m, f)

Functorå¾‹:

1. æ’ç­‰å¾‹:
    fmap(id, m)  â‰¡  m

2. ç»„åˆå¾‹:
    fmap(g âˆ˜ f, m)  â‰¡  fmap(g, fmap(f, m))

å®ç°:
    fmap(f, Future(poll)) = Future(Î»cx. 
        match poll(cx) {
            Ready(v) => Ready(f(v)),
            Pending => Pending
        }
    )
```

### 5.3 Applicativeç»“æ„

```text
Futureä½œä¸ºApplicative:

pure:
    pure: Ï„ â†’ Future<Ï„>
    pure = return

ap (<*>):
    (<*>): Future<Ï„ â†’ Ï…> â†’ Future<Ï„> â†’ Future<Ï…>
    ff <*> fa = join(ff, fa).map(|(f, a)| f(a))

Applicativeå¾‹:

1. æ’ç­‰å¾‹:
    pure(id) <*> v  â‰¡  v

2. ç»„åˆå¾‹:
    pure(âˆ˜) <*> u <*> v <*> w  â‰¡  u <*> (v <*> w)

3. åŒæ€å¾‹:
    pure(f) <*> pure(x)  â‰¡  pure(f(x))

4. äº¤æ¢å¾‹:
    u <*> pure(y)  â‰¡  pure(Î»f. f(y)) <*> u
```

### 5.4 ç­‰å¼æ¨ç†

#### ç»„åˆå­ç­‰å¼

```text
mapç­‰å¼:
    map(ready(v), f)  â‰¡  ready(f(v))
    map(pending, f)  â‰¡  pending
    map(map(m, f), g)  â‰¡  map(m, g âˆ˜ f)

thenç­‰å¼:
    then(ready(v), f)  â‰¡  f(v)
    then(pending, f)  â‰¡  pending
    then(then(m, f), g)  â‰¡  then(m, Î»x. then(f(x), g))

joinç­‰å¼:
    join(ready(vâ‚), ready(vâ‚‚))  â‰¡  ready((vâ‚, vâ‚‚))
    join(mâ‚, mâ‚‚)  â‰¡  join(mâ‚‚, mâ‚)
    join(join(mâ‚, mâ‚‚), mâ‚ƒ)  â‰¡  join(mâ‚, join(mâ‚‚, mâ‚ƒ))

selectç­‰å¼:
    select(ready(v), m)  â‰¡  ready(v)
    select(m, ready(v))  â‰¡  ready(v)
    // æ³¨: selectä¸æ»¡è¶³ç»“åˆå¾‹å’Œäº¤æ¢å¾‹ (éç¡®å®šæ€§)
```

---

## ğŸ¯ ç¬¬å…­éƒ¨åˆ†: å¹¶å‘æ¨¡å‹

### 6.1 è¿›ç¨‹æ¼”ç®—

#### CCSé£æ ¼

```text
è¿›ç¨‹è¯­æ³•:
    P ::= 0                    // ç©ºè¿›ç¨‹
        | a.P                  // å‰ç¼€
        | P | Q                // å¹¶å‘
        | P + Q                // é€‰æ‹©
        | (Î½a)P                // é™åˆ¶
        | !P                   // å¤åˆ¶

å¼‚æ­¥è¿›ç¨‹:
    async(e) | rest  â‰ˆ  spawn(e) ; rest
    await(f) | rest  â‰ˆ  f.poll() ; (if Ready(v) then rest[v] else suspend)

é€šä¿¡:
    send(ch, v) | recv(ch)  â†’  0 | âŸ¨vâŸ©
```

### 6.2 CSPæ¨¡å‹

```text
CSPè¿›ç¨‹:
    P ::= SKIP                 // æˆåŠŸç»ˆæ­¢
        | STOP                 // æ­»é”
        | a â†’ P                // å‰ç¼€
        | P â–¡ Q                // å¤–éƒ¨é€‰æ‹©
        | P âŠ“ Q                // å†…éƒ¨é€‰æ‹©
        | P ||| Q              // äº¤é”™
        | P || Q               // å¹¶è¡Œ

æ˜ å°„åˆ°å¼‚æ­¥:
    select(fâ‚, fâ‚‚)  â‰ˆ  (await fâ‚ â†’ P) âŠ“ (await fâ‚‚ â†’ Q)
    join(fâ‚, fâ‚‚)  â‰ˆ  (await fâ‚ â†’ P) ||| (await fâ‚‚ â†’ Q)
```

### 6.3 Actoræ¨¡å‹

```text
Actor = (State, Behavior, Mailbox)

å¼‚æ­¥Actor:
    actor A {
        state: S
        
        async fn handle(msg: M) -> Response {
            match msg {
                Msg1 => ...,
                Msg2 => ...,
            }
        }
    }

æ¶ˆæ¯ä¼ é€’:
    A ! msg  â‰ˆ  channel.send(msg).await
    receive  â‰ˆ  channel.recv().await
```

---

## ğŸ¯ ç¬¬ä¸ƒéƒ¨åˆ†: æ­£ç¡®æ€§æ€§è´¨

### 7.1 ç±»å‹å®‰å…¨

```text
ç±»å‹å®‰å…¨å®šç† (Type Safety):

è¿›å±•æ€§ (Progress):
    âˆ€ e, Ï„. (âˆ… âŠ¢ e: Ï„) âŸ¹ (e = v âˆ¨ âˆƒ e'. e â†’ e')

ä¿å‹æ€§ (Preservation):
    âˆ€ e, e', Ï„. (âˆ… âŠ¢ e: Ï„ âˆ§ e â†’ e') âŸ¹ âˆ… âŠ¢ e': Ï„

è¯æ˜æ€è·¯:
    å¯¹ç±»å‹æ¨å¯¼è§„åˆ™å’Œå½’çº¦è§„åˆ™è¿›è¡Œç»“æ„å½’çº³
```

### 7.2 å†…å­˜å®‰å…¨

```text
Pinå®‰å…¨æ€§:

å®šç†: Pinä¿è¯å†…å­˜ä½ç½®ä¸å˜
    âˆ€ p: Pin<&mut T>, tâ‚, tâ‚‚.
        addr(p@tâ‚) = addr(p@tâ‚‚)

è¯æ˜:
    1. Pinæ„é€ å—é™ (newéœ€T: Unpinæˆ–unsafe)
    2. Pin::into_inneréœ€T: Unpin
    3. ä¸æš´éœ²&mut T (é™¤éT: Unpin)
```

### 7.3 æ•°æ®ç«äº‰è‡ªç”±

```text
Send/Syncä¿è¯:

å®šç†: æ— æ•°æ®ç«äº‰
    âˆ€ T: Send, çº¿ç¨‹Tâ‚, Tâ‚‚.
        Tâ‚æ‹¥æœ‰x: T âˆ§ Tâ‚ send x to Tâ‚‚ âŸ¹ 
        Â¬(Tâ‚è®¿é—®x âˆ§ Tâ‚‚è®¿é—®x åŒæ—¶å‘ç”Ÿ)

å®šç†: å…±äº«å®‰å…¨
    âˆ€ T: Sync, çº¿ç¨‹Tâ‚, Tâ‚‚.
        Tâ‚æŒæœ‰&x: &T âˆ§ Tâ‚‚æŒæœ‰&y: &T âˆ§ x = y âŸ¹
        å®‰å…¨ (æ— æ•°æ®ç«äº‰)
```

### 7.4 æ´»æ€§æ€§è´¨

```text
æœ€ç»ˆå®Œæˆæ€§ (Eventual Completion):

å‡è®¾:
    1. èµ„æºå……è¶³
    2. æ‰€æœ‰wakerä¼šè¢«è°ƒç”¨
    3. æ— æ­»é”

å®šç†:
    âˆ€ f: Future<T>. 
        will_complete(f) âŸº 
        âˆƒ n. pollâ¿(f) = Ready(v)

æ³¨: å®é™…ä¸­å¯èƒ½å› æ­»é”ã€èµ„æºè€—å°½ç­‰æ— æ³•ä¿è¯
```

---

## ğŸ“ æ€»ç»“

### å½¢å¼åŒ–æ¡†æ¶

```text
ä¸‰å±‚è¯­ä¹‰:
    æ“ä½œè¯­ä¹‰ - å¦‚ä½•æ‰§è¡Œ
    æŒ‡ç§°è¯­ä¹‰ - è¡¨ç¤ºä»€ä¹ˆ
    ä»£æ•°è¯­ä¹‰ - å¦‚ä½•ç»„åˆ

å››å¤§æ€§è´¨:
    ç±»å‹å®‰å…¨ - è¿›å±•æ€§+ä¿å‹æ€§
    å†…å­˜å®‰å…¨ - Pinæœºåˆ¶
    å¹¶å‘å®‰å…¨ - Send/Sync
    æ´»æ€§æ€§è´¨ - æœ€ç»ˆå®Œæˆ

å…³é”®æ´å¯Ÿ:
    1. Futureæ˜¯Monad - ç»„åˆæ€§
    2. Pinä¿è¯å®‰å…¨æ€§ - å†…å­˜ä¸å˜
    3. Send/Syncä¿è¯å¹¶å‘ - æ— æ•°æ®ç«äº‰
    4. åä½œå¼è°ƒåº¦ - æ˜¾å¼è®©å‡º
```

---

**ç†è®ºåŸºç¡€**: Type Theory + Category Theory + Process Calculus  
**å½¢å¼åŒ–ç¨‹åº¦**: â­â­â­â­â­  
**ç‰ˆæœ¬**: v1.0

ğŸ”¬ **ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€ä¸ºå¼‚æ­¥ç¼–ç¨‹æä¾›åšå®ç†è®ºä¿éšœï¼**
