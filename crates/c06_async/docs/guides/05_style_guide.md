# Rust 异步风格规范（Rust 1.90 适用）


## 📊 目录

- [命名与可读性](#命名与可读性)
- [结构化并发](#结构化并发)
- [取消与资源释放](#取消与资源释放)
- [背压与容量规划](#背压与容量规划)
- [错误处理](#错误处理)
- [时间语义](#时间语义)
- [观测与调试](#观测与调试)


## 命名与可读性

- 避免缩写：`download_all_pages` 胜于 `dl_pages`。
- 明确返回语义：异步函数名使用动词短语，错误类型统一 `anyhow::Result<T>` 或自定义错误。
- 尽量小函数化：将 `select!` 分支、`JoinSet` 任务体抽成独立异步函数，便于测试与复用。

## 结构化并发

- 首选 `JoinSet` 管理动态任务集合；失败即驱动取消并收敛错误。
- 使用 `tokio::select!` 表达多路等待，分支中保持幂等或补偿逻辑。
- 对固定数量并发优先 `try_join!`；对动态集合优先 `JoinSet`；批量流式优先 `buffer_unordered`。

## 取消与资源释放

- 以 `Drop` 作为取消后资源回收的最后防线；持有 `Semaphore` 许可用 `OwnedSemaphorePermit`。
- 在 `select!` 的未选分支中避免留下悬挂的外部句柄（网络连接、文件描述符）。
- 不在持锁期间 `await`；许可/FD 等资源释放要么借助 `Drop`，要么显式在取消路径释放。

## 背压与容量规划

- 默认使用有界 mpsc；容量与生产/消费速率匹配，必要时配合 `Semaphore` 和窗口批处理。
- 任务间传递大对象时优先 `Arc` 或零拷贝引用（确保生命周期与并发安全）。
- 流控顺序：先用 bounded mpsc 传压，再用 `Semaphore` 控并发，必要时加速率限制（interval/token bucket）。

## 错误处理

- 用 `?` 直通错误；在边界层统一封装上下文（`with_context`）。
- 对批量并发用 `try_join!` 或 `buffer_unordered` + 聚合错误策略。
- 错误分级处理：可重试 vs 不可重试；在日志中打印失败次数与最终错误。

## 时间语义

- 超时尽量放在调用方；对外暴露 API 时用截止时间（deadline）而非裸超时值。
- `sleep`/`interval` 属于协作式调度，务必考虑跳票与时钟源。
- 倾向在调用边界使用 `deadline` (`sleep_until`) 以传递全链路时间预算。

## 观测与调试

- 全链路打点：trace span 包含 request id/tenant 等关键维度。
- 开发期可启用 `tokio-console`，生产禁用或限流采样。
- 在关键执行路径（入队/开始/完成/取消/超时）打点，输出 p50/p95。
