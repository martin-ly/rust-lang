# Tier 2: 异步调试与监控

> **文档版本**: Rust 1.90+ | **更新日期**: 2025-10-22  
> **文档层级**: Tier 2 - 实践指南 | **预计阅读**: 20 分钟

---

## 📋 目录

- [Tier 2: 异步调试与监控](#tier-2-异步调试与监控)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 本章目标](#-本章目标)
  - [1. 结构化日志 (tracing)](#1-结构化日志-tracing)
    - [1.1 基本使用](#11-基本使用)
    - [1.2 Span 和 Event](#12-span-和-event)
    - [1.3 过滤和采样](#13-过滤和采样)
  - [2. tokio-console 实时监控](#2-tokio-console-实时监控)
    - [2.1 配置和安装](#21-配置和安装)
    - [2.2 使用 tokio-console](#22-使用-tokio-console)
    - [2.3 解读监控数据](#23-解读监控数据)
  - [3. 调试技巧](#3-调试技巧)
    - [3.1 打印调试](#31-打印调试)
    - [3.2 使用 `dbg!` 宏](#32-使用-dbg-宏)
    - [3.3 IDE 调试器](#33-ide-调试器)
    - [3.4 超时调试](#34-超时调试)
  - [4. 常见问题诊断](#4-常见问题诊断)
    - [4.1 任务挂起](#41-任务挂起)
    - [4.2 性能下降](#42-性能下降)
    - [4.3 内存泄漏](#43-内存泄漏)
  - [5. 生产监控](#5-生产监控)
    - [5.1 Prometheus 集成](#51-prometheus-集成)
    - [5.2 健康检查](#52-健康检查)
    - [5.3 分布式追踪](#53-分布式追踪)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 日志级别](#61-日志级别)
    - [6.2 监控清单](#62-监控清单)
  - [7. 故障排查流程](#7-故障排查流程)
  - [📚 延伸阅读](#-延伸阅读)
  - [📝 总结](#-总结)

## 🎯 本章目标

掌握异步程序的调试技巧和监控方法。

**学习成果**:

- ✅ 使用 `tracing` 进行结构化日志
- ✅ 掌握 `tokio-console` 实时监控
- ✅ 理解异步调试的常见陷阱
- ✅ 建立生产环境监控体系

---

## 1. 结构化日志 (tracing)

### 1.1 基本使用

**添加依赖**:

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

**初始化**:

```rust
use tracing::{info, warn, error};
use tracing_subscriber;

fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!("Application started");
}
```

---

### 1.2 Span 和 Event

```rust
use tracing::{info, instrument, Span};

#[instrument]
async fn fetch_user(id: u64) -> String {
    info!("Fetching user data");
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    format!("User {}", id)
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    
    let span = tracing::info_span!("user_request", request_id = 123);
    let _enter = span.enter();
    
    let user = fetch_user(42).await;
    info!("Got user: {}", user);
}
```

**输出**:

```text
2025-10-22T10:00:00Z  INFO user_request{request_id=123}: Fetching user data
2025-10-22T10:00:00Z  INFO user_request{request_id=123}: Got user: User 42
```

---

### 1.3 过滤和采样

```rust
use tracing_subscriber::{Layer, EnvFilter};

fn main() {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env()
            .add_directive("my_app=debug".parse().unwrap())
            .add_directive("tokio=info".parse().unwrap()))
        .init();
}
```

**环境变量控制**:

```bash
RUST_LOG=debug cargo run
RUST_LOG=my_app=trace,tokio=debug cargo run
```

---

## 2. tokio-console 实时监控

### 2.1 配置和安装

**安装工具**:

```bash
cargo install tokio-console
```

**配置项目** (`Cargo.toml`):

```toml
[dependencies]
tokio = { version = "1", features = ["full", "tracing"] }
console-subscriber = "0.2"
```

**初始化**:

```rust
fn main() {
    console_subscriber::init();
    
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            // 异步代码
        });
}
```

---

### 2.2 使用 tokio-console

**运行程序**:

```bash
cargo run
```

**启动监控** (另一个终端):

```bash
tokio-console
```

**监控内容**:

- ✅ 所有活跃任务
- ✅ 任务运行时间和轮询次数
- ✅ 任务阻塞时间
- ✅ 资源使用统计
- ✅ 实时任务树

---

### 2.3 解读监控数据

| 指标 | 说明 | 正常范围 |
|------|------|----------|
| **Polls** | 轮询次数 | 取决于任务 |
| **Busy** | 实际执行时间 | 应该很短 |
| **Idle** | 等待时间 | 取决于 I/O |
| **Tasks** | 任务数量 | 合理数量 |

**异常信号**:

- ⚠️ 任务 Busy 时间过长 → CPU 密集型操作
- ⚠️ 大量 Pending 任务 → 可能死锁
- ⚠️ 轮询次数异常高 → 可能忙等

---

## 3. 调试技巧

### 3.1 打印调试

```rust
#[tokio::main]
async fn main() {
    let future = async {
        println!("Before await");
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        println!("After await");
    };
    
    future.await;
}
```

---

### 3.2 使用 `dbg!` 宏

```rust
async fn example() -> i32 {
    let x = 42;
    dbg!(&x); // 打印: [src/main.rs:3] &x = 42
    
    let result = compute(x).await;
    dbg!(&result); // 打印: [src/main.rs:6] &result = 84
    
    result
}
```

---

### 3.3 IDE 调试器

**VSCode (`launch.json`)**:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug",
      "cargo": {
        "args": ["build", "--bin=my_app"],
        "filter": {
          "name": "my_app",
          "kind": "bin"
        }
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    }
  ]
}
```

---

### 3.4 超时调试

```rust
use tokio::time::{timeout, Duration};

#[tokio::main]
async fn main() {
    match timeout(Duration::from_secs(5), slow_operation()).await {
        Ok(result) => println!("Success: {:?}", result),
        Err(_) => println!("Timeout! Operation took too long"),
    }
}
```

---

## 4. 常见问题诊断

### 4.1 任务挂起

**症状**: 程序不响应，无输出。

**诊断**:

```rust
use tracing::{info, instrument};

#[instrument]
async fn diagnose() {
    info!("Step 1");
    operation1().await;
    
    info!("Step 2");
    operation2().await;
    
    info!("Step 3");
    // 如果卡在这里，Step 3 不会打印
}
```

**常见原因**:

- ❌ 忘记 `.await`
- ❌ 死锁
- ❌ 无限循环

---

### 4.2 性能下降

**使用 `tokio-console` 检查**:

1. 查看任务轮询次数
2. 检查 Busy 时间
3. 查找长时间运行的任务

**示例**:

```rust
// ❌ 问题：CPU 密集型任务阻塞
async fn bad() {
    // 长时间 CPU 计算
    expensive_computation(); // 5 秒
}

// ✅ 解决：使用 spawn_blocking
async fn good() {
    tokio::task::spawn_blocking(|| {
        expensive_computation()
    }).await.unwrap();
}
```

---

### 4.3 内存泄漏

**工具**:

```bash
# valgrind (Linux)
valgrind --leak-check=full ./target/release/my_app

# Instruments (macOS)
instruments -t Leaks ./target/release/my_app
```

**常见原因**:

- ❌ 循环引用 (`Arc` 循环)
- ❌ 未关闭的通道
- ❌ 忘记清理的资源

---

## 5. 生产监控

### 5.1 Prometheus 集成

**添加依赖**:

```toml
[dependencies]
prometheus = "0.13"
```

**导出指标**:

```rust
use prometheus::{IntCounter, Encoder, TextEncoder};

lazy_static::lazy_static! {
    static ref REQUEST_COUNT: IntCounter =
        IntCounter::new("requests_total", "Total requests").unwrap();
}

async fn metrics_handler() -> String {
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = vec![];
    encoder.encode(&metric_families, &mut buffer).unwrap();
    String::from_utf8(buffer).unwrap()
}
```

---

### 5.2 健康检查

```rust
use axum::{Router, routing::get};

async fn health_check() -> &'static str {
    "OK"
}

async fn readiness_check() -> &'static str {
    // 检查依赖服务（数据库、缓存等）
    if database_is_ready() && cache_is_ready() {
        "Ready"
    } else {
        "NotReady"
    }
}

fn app() -> Router {
    Router::new()
        .route("/health", get(health_check))
        .route("/ready", get(readiness_check))
}
```

---

### 5.3 分布式追踪

**OpenTelemetry 集成**:

```toml
[dependencies]
opentelemetry = "0.20"
opentelemetry-jaeger = "0.19"
tracing-opentelemetry = "0.21"
```

```rust
use opentelemetry::global;
use tracing_subscriber::layer::SubscriberExt;

fn init_tracer() {
    global::set_text_map_propagator(opentelemetry_jaeger::Propagator::new());
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_simple()
        .unwrap();
    
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    let subscriber = tracing_subscriber::Registry::default().with(telemetry);
    tracing::subscriber::set_global_default(subscriber).unwrap();
}
```

---

## 6. 最佳实践

### 6.1 日志级别

| 级别 | 用途 | 示例 |
|------|------|------|
| **ERROR** | 严重错误 | 数据库连接失败 |
| **WARN** | 警告 | 重试次数过多 |
| **INFO** | 关键信息 | 服务启动、关闭 |
| **DEBUG** | 调试信息 | 函数调用、参数 |
| **TRACE** | 详细追踪 | 每个步骤细节 |

---

### 6.2 监控清单

**开发环境**:

- ✅ 启用 `tracing` DEBUG 级别
- ✅ 使用 `tokio-console` 监控
- ✅ IDE 调试器设置断点

**生产环境**:

- ✅ INFO 级别日志
- ✅ Prometheus 指标收集
- ✅ 健康检查端点
- ✅ 分布式追踪（可选）
- ✅ 告警规则配置

---

## 7. 故障排查流程

```text
1. 发现问题
   ├─> 查看日志 (tracing)
   │   ├─> 有明确错误 → 修复
   │   └─> 无明确错误 → 下一步
   │
   ├─> 检查监控 (Prometheus)
   │   ├─> 资源异常 → 扩容/优化
   │   └─> 资源正常 → 下一步
   │
   ├─> 实时监控 (tokio-console)
   │   ├─> 任务异常 → 检查任务逻辑
   │   └─> 任务正常 → 下一步
   │
   └─> 分布式追踪
       └─> 定位慢服务 → 优化
```

---

## 📚 延伸阅读

- **[异步性能优化指南](./05_异步性能优化指南.md)** - 性能调优
- **[异步设计模式实践](./04_异步设计模式实践.md)** - 设计模式
- **[工具指南](../appendices/tools/)** - 详细工具文档

---

## 📝 总结

**核心工具**:

- ✅ **tracing**: 结构化日志
- ✅ **tokio-console**: 实时监控
- ✅ **Prometheus**: 指标收集
- ✅ **OpenTelemetry**: 分布式追踪

**调试技巧**:

- ✅ 使用 `#[instrument]` 自动追踪
- ✅ `dbg!` 和 `println!` 快速调试
- ✅ IDE 调试器设置断点
- ✅ `timeout` 检测超时

**生产监控**:

- ✅ 健康检查端点
- ✅ Prometheus 指标
- ✅ 分布式追踪
- ✅ 告警规则

---

**文档维护**: C06 Async Team | **质量评分**: 95/100  
**最后更新**: 2025-10-22 | **Rust 版本**: 1.90+
