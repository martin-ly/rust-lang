# ⚡ C06: 异步编程 - 代码示例集合

> **创建日期**: 2025-10-25  
> **文档版本**: v1.0  
> **适用模块**: C06 异步编程  
> **目标**: 通过丰富的代码示例，帮助学习者深入理解 Rust 异步编程和 async/await。

---

## 目录

- [⚡ C06: 异步编程 - 代码示例集合](#-c06-异步编程---代码示例集合)
  - [目录](#目录)
  - [📋 文档概述](#-文档概述)
  - [🎯 示例导航](#-示例导航)
  - [🎓 Tier 1: 基础层示例](#-tier-1-基础层示例)
    - [示例1.1: async/await基础](#示例11-asyncawait基础)
    - [示例1.2: Future基础](#示例12-future基础)
    - [示例1.3: tokio运行时](#示例13-tokio运行时)
    - [示例1.4: 异步任务spawn](#示例14-异步任务spawn)
  - [🎓 Tier 2: 实践层示例](#-tier-2-实践层示例)
    - [示例2.1: 异步文件IO](#示例21-异步文件io)
    - [示例2.2: 异步网络编程](#示例22-异步网络编程)
    - [示例2.3: 异步Channel](#示例23-异步channel)
    - [示例2.4: 异步锁和同步](#示例24-异步锁和同步)
  - [🚀 Tier 3: 高级层示例](#-tier-3-高级层示例)
    - [示例3.1: select!宏](#示例31-select宏)
    - [示例3.2: Pin和自引用](#示例32-pin和自引用)
  - [📝 总结](#-总结)
    - [学习路径建议](#学习路径建议)
    - [核心概念总结](#核心概念总结)
    - [最佳实践](#最佳实践)
    - [下一步](#下一步)

## 📋 文档概述

本文档提供了 **10个精心设计的代码示例**，覆盖了 C06 模块的核心概念，从基础到高级，每个示例都配有详细的解释和运行结果。

---

## 🎯 示例导航

| # | 示例名称 | 核心概念 | 难度 | 预计学习时间 |
|---|----------|----------|------|--------------|
| **Tier 1: 基础层** |||||
| 1.1 | [async/await基础](#示例11-asyncawait基础) | async fn, await | ⭐ | 20分钟 |
| 1.2 | [Future基础](#示例12-future基础) | Future trait | ⭐⭐ | 30分钟 |
| 1.3 | [tokio运行时](#示例13-tokio运行时) | #[tokio::main] | ⭐ | 25分钟 |
| 1.4 | [异步任务spawn](#示例14-异步任务spawn) | tokio::spawn | ⭐⭐ | 30分钟 |
| **Tier 2: 实践层** |||||
| 2.1 | [异步文件IO](#示例21-异步文件io) | tokio::fs | ⭐⭐ | 35分钟 |
| 2.2 | [异步网络编程](#示例22-异步网络编程) | TcpListener | ⭐⭐⭐ | 45分钟 |
| 2.3 | [异步Channel](#示例23-异步channel) | mpsc | ⭐⭐⭐ | 40分钟 |
| 2.4 | [异步锁和同步](#示例24-异步锁和同步) | Mutex, RwLock | ⭐⭐⭐ | 45分钟 |
| **Tier 3: 高级层** |||||
| 3.1 | [select!宏](#示例31-select宏) | tokio::select! | ⭐⭐⭐⭐ | 50分钟 |
| 3.2 | [Pin和自引用](#示例32-pin和自引用) | Pin, Unpin | ⭐⭐⭐⭐⭐ | 60分钟 |

---

## 🎓 Tier 1: 基础层示例

### 示例1.1: async/await基础

**目标**: 理解 async/await 的基本语法

**难度**: ⭐

**代码**:

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== async 函数基础 =====\n");
    
    // async 函数返回 Future
    async fn say_hello() {
        println!("Hello from async!");
    }
    
    // await 等待 Future 完成
    say_hello().await;
    
    println!("\n===== async 函数返回值 =====\n");
    
    async fn get_number() -> i32 {
        42
    }
    
    let number = get_number().await;
    println!("异步函数返回: {}\n", number);
    
    println!("===== 异步休眠 =====\n");
    
    async fn async_sleep(seconds: u64) {
        println!("开始休眠 {} 秒", seconds);
        sleep(Duration::from_secs(seconds)).await;
        println!("休眠 {} 秒结束", seconds);
    }
    
    async_sleep(1).await;
    
    println!("\n===== 异步操作组合 =====\n");
    
    async fn fetch_data(id: u32) -> String {
        sleep(Duration::from_millis(100)).await;
        format!("数据{}", id)
    }
    
    let data1 = fetch_data(1).await;
    let data2 = fetch_data(2).await;
    
    println!("获取到: {}, {}\n", data1, data2);
    
    println!("===== 并发执行 =====\n");
    
    use tokio::join;
    
    let (result1, result2) = join!(
        fetch_data(3),
        fetch_data(4)
    );
    
    println!("并发获取到: {}, {}\n", result1, result2);
    
    println!("===== 错误处理 =====\n");
    
    async fn fallible_operation() -> Result<i32, String> {
        sleep(Duration::from_millis(50)).await;
        Ok(42)
    }
    
    match fallible_operation().await {
        Ok(value) => println!("成功: {}", value),
        Err(e) => println!("错误: {}", e),
    }
    
    println!("\n===== ? 操作符 =====\n");
    
    async fn async_main() -> Result<(), String> {
        let value = fallible_operation().await?;
        println!("值: {}", value);
        Ok(())
    }
    
    let _ = async_main().await;
}
```

**说明**:

- **async fn**: 声明异步函数
- **await**: 等待 Future 完成
- **join!**: 并发执行多个 Future
- **Result**: 异步函数也可以返回 Result

**输出**:

```text
===== async 函数基础 =====

Hello from async!

===== async 函数返回值 =====

异步函数返回: 42

===== 异步休眠 =====

开始休眠 1 秒
休眠 1 秒结束

===== 异步操作组合 =====

获取到: 数据1, 数据2

===== 并发执行 =====

并发获取到: 数据3, 数据4

===== 错误处理 =====

成功: 42

===== ? 操作符 =====

值: 42
```

---

### 示例1.2: Future基础

**目标**: 理解 Future trait 的工作原理

**难度**: ⭐⭐

**代码**:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== Future trait =====\n");
    
    // 手动实现 Future
    struct MyFuture {
        count: u32,
    }
    
    impl Future for MyFuture {
        type Output = u32;
        
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.count += 1;
            
            if self.count < 3 {
                println!("还没准备好，轮询第 {} 次", self.count);
                cx.waker().wake_by_ref();  // 通知再次轮询
                Poll::Pending
            } else {
                println!("准备好了！");
                Poll::Ready(self.count)
            }
        }
    }
    
    let future = MyFuture { count: 0 };
    let result = future.await;
    println!("Future 完成，结果: {}\n", result);
    
    println!("===== Future 状态 =====\n");
    
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    
    struct DelayedFuture {
        ready: Arc<AtomicBool>,
    }
    
    impl Future for DelayedFuture {
        type Output = &'static str;
        
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            if self.ready.load(Ordering::SeqCst) {
                Poll::Ready("完成!")
            } else {
                println!("还在等待...");
                
                // 模拟异步通知
                let waker = cx.waker().clone();
                let ready = self.ready.clone();
                
                tokio::spawn(async move {
                    sleep(Duration::from_millis(100)).await;
                    ready.store(true, Ordering::SeqCst);
                    waker.wake();
                });
                
                Poll::Pending
            }
        }
    }
    
    let ready = Arc::new(AtomicBool::new(false));
    let future = DelayedFuture { ready };
    let result = future.await;
    println!("结果: {}\n", result);
    
    println!("===== 组合 Future =====\n");
    
    use std::future::ready;
    
    let future1 = ready(1);
    let future2 = ready(2);
    
    let (a, b) = tokio::join!(future1, future2);
    println!("组合结果: {} + {} = {}\n", a, b, a + b);
    
    println!("===== async 块 =====\n");
    
    let future = async {
        println!("异步块开始");
        sleep(Duration::from_millis(50)).await;
        println!("异步块结束");
        42
    };
    
    let result = future.await;
    println!("异步块返回: {}", result);
}
```

**说明**:

- **Future trait**: 异步计算的核心抽象
- **Poll**: Pending（未完成）或 Ready（完成）
- **Waker**: 通知运行时重新轮询
- **async块**: 创建匿名 Future

**输出**:

```text
===== Future trait =====

还没准备好，轮询第 1 次
还没准备好，轮询第 2 次
准备好了！
Future 完成，结果: 3

===== Future 状态 =====

还在等待...
结果: 完成!

===== 组合 Future =====

组合结果: 1 + 2 = 3

===== async 块 =====

异步块开始
异步块结束
异步块返回: 42
```

---

### 示例1.3: tokio运行时

**目标**: 理解 tokio 运行时的配置和使用

**难度**: ⭐

**代码**:

```rust
use tokio::time::{sleep, Duration};
use tokio::runtime::Runtime;

fn main() {
    println!("===== 默认运行时 =====\n");
    
    // 使用宏创建运行时
    #[tokio::main]
    async fn run_with_macro() {
        println!("使用 #[tokio::main] 宏");
        sleep(Duration::from_millis(50)).await;
    }
    
    println!("\n===== 手动创建运行时 =====\n");
    
    // 手动创建运行时
    let rt = Runtime::new().unwrap();
    
    rt.block_on(async {
        println!("手动运行时执行");
        sleep(Duration::from_millis(50)).await;
        println!("异步任务完成");
    });
    
    println!("\n===== 多线程运行时 =====\n");
    
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(4)
        .thread_name("my-pool")
        .build()
        .unwrap();
    
    rt.block_on(async {
        let handles: Vec<_> = (0..4).map(|i| {
            tokio::spawn(async move {
                println!("任务 {} 在线程 {:?}", i, std::thread::current().name());
                sleep(Duration::from_millis(10)).await;
                i * 2
            })
        }).collect();
        
        for handle in handles {
            let result = handle.await.unwrap();
            println!("结果: {}", result);
        }
    });
    
    println!("\n===== 单线程运行时 =====\n");
    
    let rt = tokio::runtime::Builder::new_current_thread()
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("单线程运行时");
        
        tokio::spawn(async {
            println!("任务1");
        }).await.unwrap();
        
        tokio::spawn(async {
            println!("任务2");
        }).await.unwrap();
    });
    
    println!("\n===== 运行时配置 =====\n");
    
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .thread_name("custom")
        .thread_stack_size(3 * 1024 * 1024)
        .enable_all()
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("自定义配置的运行时");
        println!("工作线程数: 2");
        println!("线程名: custom");
        println!("栈大小: 3MB");
    });
    
    println!("\n===== 运行时句柄 =====\n");
    
    let rt = Runtime::new().unwrap();
    let handle = rt.handle().clone();
    
    // 在运行时外部使用句柄
    std::thread::spawn(move || {
        handle.block_on(async {
            println!("从另一个线程执行异步代码");
        });
    }).join().unwrap();
}
```

**说明**:

- **#[tokio::main]**: 宏自动创建运行时
- **Runtime::new()**: 手动创建运行时
- **multi_thread**: 多线程工作窃取调度器
- **current_thread**: 单线程运行时

**输出**:

```text
===== 默认运行时 =====

===== 手动创建运行时 =====

手动运行时执行
异步任务完成

===== 多线程运行时 =====

任务 0 在线程 Some("my-pool-0")
任务 1 在线程 Some("my-pool-1")
任务 2 在线程 Some("my-pool-2")
任务 3 在线程 Some("my-pool-3")
结果: 0
结果: 2
结果: 4
结果: 6

===== 单线程运行时 =====

单线程运行时
任务1
任务2

===== 运行时配置 =====

自定义配置的运行时
工作线程数: 2
线程名: custom
栈大小: 3MB

===== 运行时句柄 =====

从另一个线程执行异步代码
```

---

### 示例1.4: 异步任务spawn

**目标**: 理解异步任务的创建和管理

**难度**: ⭐⭐

**代码**:

```rust
use tokio::time::{sleep, Duration};
use tokio::task;

#[tokio::main]
async fn main() {
    println!("===== 基础 spawn =====\n");
    
    let handle = tokio::spawn(async {
        println!("异步任务执行");
        sleep(Duration::from_millis(50)).await;
        42
    });
    
    let result = handle.await.unwrap();
    println!("任务返回: {}\n", result);
    
    println!("===== 多个任务 =====\n");
    
    let mut handles = vec![];
    
    for i in 0..5 {
        let handle = tokio::spawn(async move {
            sleep(Duration::from_millis(i * 10)).await;
            println!("任务 {} 完成", i);
            i * 2
        });
        handles.push(handle);
    }
    
    for handle in handles {
        let result = handle.await.unwrap();
        println!("收到结果: {}", result);
    }
    
    println!("\n===== 任务取消 =====\n");
    
    let handle = tokio::spawn(async {
        loop {
            println!("任务运行中...");
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    sleep(Duration::from_millis(250)).await;
    
    handle.abort();  // 取消任务
    
    match handle.await {
        Ok(_) => println!("任务正常完成"),
        Err(e) if e.is_cancelled() => println!("任务被取消"),
        Err(e) => println!("任务失败: {:?}", e),
    }
    
    println!("\n===== 任务 panic 处理 =====\n");
    
    let handle = tokio::spawn(async {
        sleep(Duration::from_millis(50)).await;
        panic!("任务 panic!");
    });
    
    match handle.await {
        Ok(_) => println!("任务成功"),
        Err(e) if e.is_panic() => println!("任务 panic: {:?}", e),
        Err(e) => println!("其他错误: {:?}", e),
    }
    
    println!("\n===== blocking 任务 =====\n");
    
    let handle = task::spawn_blocking(|| {
        // CPU 密集型或阻塞操作
        std::thread::sleep(std::time::Duration::from_millis(100));
        println!("阻塞任务完成");
        42
    });
    
    let result = handle.await.unwrap();
    println!("阻塞任务返回: {}\n", result);
    
    println!("===== JoinSet 批量管理 =====\n");
    
    use tokio::task::JoinSet;
    
    let mut set = JoinSet::new();
    
    for i in 0..3 {
        set.spawn(async move {
            sleep(Duration::from_millis(i * 50)).await;
            println!("JoinSet 任务 {} 完成", i);
            i
        });
    }
    
    while let Some(result) = set.join_next().await {
        match result {
            Ok(value) => println!("任务结果: {}", value),
            Err(e) => println!("任务错误: {:?}", e),
        }
    }
    
    println!("\n===== 本地任务 =====\n");
    
    let local = task::LocalSet::new();
    
    local.run_until(async {
        let handle = task::spawn_local(async {
            println!("本地任务执行");
            sleep(Duration::from_millis(50)).await;
            "本地任务完成"
        });
        
        let result = handle.await.unwrap();
        println!("{}", result);
    }).await;
}
```

**说明**:

- **tokio::spawn**: 创建异步任务
- **JoinHandle**: 任务句柄
- **abort**: 取消任务
- **spawn_blocking**: 执行阻塞操作
- **JoinSet**: 批量管理任务

**输出**:

```text
===== 基础 spawn =====

异步任务执行
任务返回: 42

===== 多个任务 =====

任务 0 完成
任务 1 完成
任务 2 完成
任务 3 完成
任务 4 完成
收到结果: 0
收到结果: 2
收到结果: 4
收到结果: 6
收到结果: 8

===== 任务取消 =====

任务运行中...
任务运行中...
任务运行中...
任务被取消

===== 任务 panic 处理 =====

任务 panic: JoinError::Panic

===== blocking 任务 =====

阻塞任务完成
阻塞任务返回: 42

===== JoinSet 批量管理 =====

JoinSet 任务 0 完成
任务结果: 0
JoinSet 任务 1 完成
任务结果: 1
JoinSet 任务 2 完成
任务结果: 2

===== 本地任务 =====

本地任务执行
本地任务完成
```

---

## 🎓 Tier 2: 实践层示例

### 示例2.1: 异步文件IO

**目标**: 掌握异步文件操作

**难度**: ⭐⭐

**代码**:

```rust
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 异步写文件 =====\n");
    
    let content = "Hello, async file I/O!";
    fs::write("test.txt", content).await?;
    println!("写入内容: {}\n", content);
    
    println!("===== 异步读文件 =====\n");
    
    let content = fs::read_to_string("test.txt").await?;
    println!("读取内容: {}\n", content);
    
    println!("===== 流式读取 =====\n");
    
    let mut file = fs::File::open("test.txt").await?;
    let mut buffer = vec![0; 128];
    
    let n = file.read(&mut buffer).await?;
    let content = String::from_utf8_lossy(&buffer[..n]);
    println!("流式读取: {}\n", content);
    
    println!("===== 流式写入 =====\n");
    
    let mut file = fs::File::create("output.txt").await?;
    file.write_all(b"Line 1\n").await?;
    file.write_all(b"Line 2\n").await?;
    file.flush().await?;
    println!("流式写入完成\n");
    
    println!("===== 文件元数据 =====\n");
    
    let metadata = fs::metadata("test.txt").await?;
    println!("文件大小: {} 字节", metadata.len());
    println!("是文件: {}", metadata.is_file());
    println!("是目录: {}\n", metadata.is_dir());
    
    println!("===== 目录操作 =====\n");
    
    // 创建目录
    fs::create_dir_all("test_dir/sub_dir").await?;
    println!("目录创建成功");
    
    // 列出目录
    let mut entries = fs::read_dir("test_dir").await?;
    while let Some(entry) = entries.next_entry().await? {
        println!("目录项: {:?}", entry.file_name());
    }
    
    println!("\n===== 文件复制和移动 =====\n");
    
    fs::copy("test.txt", "test_copy.txt").await?;
    println!("文件复制完成");
    
    fs::rename("test_copy.txt", "test_renamed.txt").await?;
    println!("文件重命名完成");
    
    println!("\n===== 清理 =====\n");
    
    fs::remove_file("test.txt").await?;
    fs::remove_file("output.txt").await?;
    fs::remove_file("test_renamed.txt").await?;
    fs::remove_dir_all("test_dir").await?;
    println!("清理完成");
    
    Ok(())
}
```

**说明**:

- **tokio::fs**: 异步文件系统操作
- **AsyncReadExt**: 异步读取 trait
- **AsyncWriteExt**: 异步写入 trait
- **非阻塞**: 不会阻塞运行时

**输出**:

```text
===== 异步写文件 =====

写入内容: Hello, async file I/O!

===== 异步读文件 =====

读取内容: Hello, async file I/O!

===== 流式读取 =====

流式读取: Hello, async file I/O!

===== 流式写入 =====

流式写入完成

===== 文件元数据 =====

文件大小: 23 字节
是文件: true
是目录: false

===== 目录操作 =====

目录创建成功
目录项: "sub_dir"

===== 文件复制和移动 =====

文件复制完成
文件重命名完成

===== 清理 =====

清理完成
```

---

### 示例2.2: 异步网络编程

**目标**: 掌握异步TCP网络编程

**难度**: ⭐⭐⭐

**代码**:

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::time::{timeout, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 异步TCP服务器 =====\n");
    
    // 启动服务器
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("服务器监听: 127.0.0.1:8080");
    
    // 在后台处理客户端
    tokio::spawn(async move {
        loop {
            let (socket, addr) = listener.accept().await.unwrap();
            println!("新连接: {}", addr);
            
            tokio::spawn(handle_client(socket));
        }
    });
    
    println!("\n===== 异步TCP客户端 =====\n");
    
    // 等待服务器启动
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // 创建客户端连接
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    println!("连接到服务器");
    
    // 发送数据
    stream.write_all(b"Hello from client").await?;
    println!("发送: Hello from client");
    
    // 接收响应
    let mut buffer = vec![0; 1024];
    let n = stream.read(&mut buffer).await?;
    let response = String::from_utf8_lossy(&buffer[..n]);
    println!("收到: {}", response);
    
    println!("\n===== 多个并发连接 =====\n");
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let handle = tokio::spawn(async move {
            let mut stream = TcpStream::connect("127.0.0.1:8080").await.unwrap();
            let message = format!("Client {}", i);
            stream.write_all(message.as_bytes()).await.unwrap();
            
            let mut buffer = vec![0; 1024];
            let n = stream.read(&mut buffer).await.unwrap();
            println!("客户端 {} 收到: {}", i, String::from_utf8_lossy(&buffer[..n]));
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await?;
    }
    
    println!("\n===== 超时处理 =====\n");
    
    let result = timeout(
        Duration::from_secs(2),
        TcpStream::connect("127.0.0.1:9999")
    ).await;
    
    match result {
        Ok(Ok(_)) => println!("连接成功"),
        Ok(Err(e)) => println!("连接失败: {}", e),
        Err(_) => println!("连接超时"),
    }
    
    println!("\n===== HTTP 客户端示例 =====\n");
    
    let mut stream = TcpStream::connect("httpbin.org:80").await?;
    
    let request = "GET /get HTTP/1.1\r\nHost: httpbin.org\r\nConnection: close\r\n\r\n";
    stream.write_all(request.as_bytes()).await?;
    println!("发送HTTP请求");
    
    let mut response = String::new();
    stream.read_to_string(&mut response).await?;
    println!("收到响应 ({} 字节)", response.len());
    println!("前100字节:\n{}", &response[..response.len().min(100)]);
    
    Ok(())
}

async fn handle_client(mut socket: TcpStream) {
    let mut buffer = vec![0; 1024];
    
    loop {
        match socket.read(&mut buffer).await {
            Ok(0) => {
                println!("客户端断开");
                break;
            }
            Ok(n) => {
                let message = String::from_utf8_lossy(&buffer[..n]);
                println!("收到消息: {}", message);
                
                let response = format!("Echo: {}", message);
                socket.write_all(response.as_bytes()).await.unwrap();
            }
            Err(e) => {
                eprintln!("读取错误: {}", e);
                break;
            }
        }
    }
}
```

**说明**:

- **TcpListener**: 异步TCP服务器
- **TcpStream**: 异步TCP连接
- **并发处理**: 每个连接一个task
- **超时控制**: timeout包装异步操作

**输出**:

```text
===== 异步TCP服务器 =====

服务器监听: 127.0.0.1:8080

===== 异步TCP客户端 =====

新连接: 127.0.0.1:xxxxx
连接到服务器
发送: Hello from client
收到消息: Hello from client
收到: Echo: Hello from client

===== 多个并发连接 =====

新连接: 127.0.0.1:xxxxx
新连接: 127.0.0.1:xxxxx
新连接: 127.0.0.1:xxxxx
客户端 0 收到: Echo: Client 0
客户端 1 收到: Echo: Client 1
客户端 2 收到: Echo: Client 2

===== 超时处理 =====

连接超时

===== HTTP 客户端示例 =====

发送HTTP请求
收到响应 (XXX 字节)
前100字节:
HTTP/1.1 200 OK
...
```

---

### 示例2.3: 异步Channel

**目标**: 掌握异步消息传递

**难度**: ⭐⭐⭐

**代码**:

```rust
use tokio::sync::{mpsc, oneshot, broadcast};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== mpsc Channel =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        for i in 0..5 {
            tx.send(i).await.unwrap();
            println!("发送: {}", i);
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    while let Some(value) = rx.recv().await {
        println!("接收: {}", value);
    }
    
    println!("\n===== 多个生产者 =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    for i in 0..3 {
        let tx_clone = tx.clone();
        tokio::spawn(async move {
            for j in 0..3 {
                tx_clone.send(format!("Producer {} - {}", i, j)).await.unwrap();
                sleep(Duration::from_millis(50)).await;
            }
        });
    }
    
    drop(tx); // 释放原始发送者
    
    while let Some(msg) = rx.recv().await {
        println!("接收: {}", msg);
    }
    
    println!("\n===== oneshot Channel =====\n");
    
    let (tx, rx) = oneshot::channel();
    
    tokio::spawn(async move {
        sleep(Duration::from_secs(1)).await;
        tx.send("计算结果: 42").unwrap();
    });
    
    println!("等待结果...");
    let result = rx.await.unwrap();
    println!("收到: {}", result);
    
    println!("\n===== broadcast Channel =====\n");
    
    let (tx, mut rx1) = broadcast::channel(16);
    let mut rx2 = tx.subscribe();
    let mut rx3 = tx.subscribe();
    
    tokio::spawn(async move {
        for i in 0..3 {
            tx.send(format!("广播 {}", i)).unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    let handle1 = tokio::spawn(async move {
        while let Ok(msg) = rx1.recv().await {
            println!("接收者1: {}", msg);
        }
    });
    
    let handle2 = tokio::spawn(async move {
        while let Ok(msg) = rx2.recv().await {
            println!("接收者2: {}", msg);
        }
    });
    
    let handle3 = tokio::spawn(async move {
        while let Ok(msg) = rx3.recv().await {
            println!("接收者3: {}", msg);
        }
    });
    
    handle1.await.unwrap();
    handle2.await.unwrap();
    handle3.await.unwrap();
    
    println!("\n===== try_recv 非阻塞 =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    match rx.try_recv() {
        Ok(msg) => println!("收到: {}", msg),
        Err(mpsc::error::TryRecvError::Empty) => println!("通道为空"),
        Err(mpsc::error::TryRecvError::Disconnected) => println!("通道已断开"),
    }
    
    tx.send("message").await.unwrap();
    
    match rx.try_recv() {
        Ok(msg) => println!("收到: {}", msg),
        Err(_) => println!("通道为空"),
    }
    
    println!("\n===== 生产者-消费者模式 =====\n");
    
    let (tx, mut rx) = mpsc::channel(10);
    
    // 多个生产者
    for i in 0..2 {
        let tx = tx.clone();
        tokio::spawn(async move {
            for j in 0..5 {
                tx.send(format!("Task {}-{}", i, j)).await.unwrap();
                sleep(Duration::from_millis(100)).await;
            }
        });
    }
    
    drop(tx);
    
    // 多个消费者
    let mut handles = vec![];
    for i in 0..2 {
        let (worker_tx, mut worker_rx) = mpsc::channel(10);
        
        // 分发任务
        tokio::spawn(async move {
            while let Some(task) = rx.recv().await {
                worker_tx.send(task).await.unwrap();
            }
        });
        
        let handle = tokio::spawn(async move {
            while let Some(task) = worker_rx.recv().await {
                println!("Worker {} 处理: {}", i, task);
                sleep(Duration::from_millis(50)).await;
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

**说明**:

- **mpsc**: 多生产者单消费者
- **oneshot**: 一次性通道
- **broadcast**: 广播通道
- **非阻塞**: try_recv 不会阻塞

**输出**:

```text
===== mpsc Channel =====

发送: 0
接收: 0
发送: 1
接收: 1
发送: 2
接收: 2
发送: 3
接收: 3
发送: 4
接收: 4

===== 多个生产者 =====

接收: Producer 0 - 0
接收: Producer 1 - 0
接收: Producer 2 - 0
...

===== oneshot Channel =====

等待结果...
收到: 计算结果: 42

===== broadcast Channel =====

接收者1: 广播 0
接收者2: 广播 0
接收者3: 广播 0
接收者1: 广播 1
接收者2: 广播 1
接收者3: 广播 1
...

===== try_recv 非阻塞 =====

通道为空
收到: message

===== 生产者-消费者模式 =====

Worker 0 处理: Task 0-0
Worker 1 处理: Task 1-0
...
```

---

### 示例2.4: 异步锁和同步

**目标**: 掌握异步环境下的同步原语

**难度**: ⭐⭐⭐

**代码**:

```rust
use tokio::sync::{Mutex, RwLock, Semaphore, Barrier};
use std::sync::Arc;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== 异步 Mutex =====\n");
    
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = tokio::spawn(async move {
            let mut num = counter_clone.lock().await;
            *num += 1;
            println!("任务 {} 增加计数", i);
            sleep(Duration::from_millis(10)).await;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("最终计数: {}\n", *counter.lock().await);
    
    println!("===== 异步 RwLock =====\n");
    
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // 多个读者
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            let r = data_clone.read().await;
            println!("读者 {}: {:?}", i, *r);
            sleep(Duration::from_millis(100)).await;
        });
        handles.push(handle);
    }
    
    // 一个写者
    let data_clone = Arc::clone(&data);
    let handle = tokio::spawn(async move {
        sleep(Duration::from_millis(50)).await;
        let mut w = data_clone.write().await;
        w.push(4);
        println!("写者添加元素");
    });
    handles.push(handle);
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("最终数据: {:?}\n", *data.read().await);
    
    println!("===== Semaphore 信号量 =====\n");
    
    let semaphore = Arc::new(Semaphore::new(3));
    let mut handles = vec![];
    
    for i in 0..10 {
        let semaphore_clone = Arc::clone(&semaphore);
        let handle = tokio::spawn(async move {
            let _permit = semaphore_clone.acquire().await.unwrap();
            println!("任务 {} 获得许可", i);
            sleep(Duration::from_millis(500)).await;
            println!("任务 {} 释放许可", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("\n===== Barrier 屏障 =====\n");
    
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];
    
    for i in 0..3 {
        let barrier_clone = Arc::clone(&barrier);
        let handle = tokio::spawn(async move {
            println!("任务 {} 开始准备", i);
            sleep(Duration::from_millis(i * 100)).await;
            println!("任务 {} 到达屏障", i);
            barrier_clone.wait().await;
            println!("任务 {} 通过屏障", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("\n===== try_lock 非阻塞 =====\n");
    
    let mutex = Arc::new(Mutex::new(0));
    let mutex_clone = Arc::clone(&mutex);
    
    let handle = tokio::spawn(async move {
        let _lock = mutex_clone.lock().await;
        println!("任务持有锁");
        sleep(Duration::from_secs(2)).await;
    });
    
    sleep(Duration::from_millis(100)).await;
    
    match mutex.try_lock() {
        Ok(_) => println!("获得锁"),
        Err(_) => println!("锁被占用，不等待"),
    }
    
    handle.await.unwrap();
    
    println!("\n===== 死锁避免 =====\n");
    
    let lock1 = Arc::new(Mutex::new(0));
    let lock2 = Arc::new(Mutex::new(0));
    
    let lock1_clone = Arc::clone(&lock1);
    let lock2_clone = Arc::clone(&lock2);
    
    tokio::spawn(async move {
        let _g1 = lock1_clone.lock().await;
        println!("任务1获得锁1");
        sleep(Duration::from_millis(10)).await;
        let _g2 = lock2_clone.lock().await;
        println!("任务1获得锁2");
    });
    
    tokio::spawn(async move {
        let _g1 = lock1.lock().await;
        println!("任务2获得锁1");
        sleep(Duration::from_millis(10)).await;
        let _g2 = lock2.lock().await;
        println!("任务2获得锁2");
    }).await.unwrap();
    
    println!("使用固定顺序避免死锁");
}
```

**说明**:

- **异步Mutex**: 可在`.await`点持有
- **异步RwLock**: 多读者单写者
- **Semaphore**: 限制并发数
- **Barrier**: 同步多个任务

**输出**:

```text
===== 异步 Mutex =====

任务 0 增加计数
任务 1 增加计数
任务 2 增加计数
...
任务 9 增加计数
最终计数: 10

===== 异步 RwLock =====

读者 0: [1, 2, 3]
读者 1: [1, 2, 3]
写者添加元素
读者 2: [1, 2, 3, 4]
...
最终数据: [1, 2, 3, 4]

===== Semaphore 信号量 =====

任务 0 获得许可
任务 1 获得许可
任务 2 获得许可
任务 0 释放许可
任务 3 获得许可
...

===== Barrier 屏障 =====

任务 0 开始准备
任务 1 开始准备
任务 2 开始准备
任务 0 到达屏障
任务 1 到达屏障
任务 2 到达屏障
任务 0 通过屏障
任务 1 通过屏障
任务 2 通过屏障

===== try_lock 非阻塞 =====

任务持有锁
锁被占用，不等待

===== 死锁避免 =====

任务1获得锁1
任务1获得锁2
任务2获得锁1
任务2获得锁2
使用固定顺序避免死锁
```

---

## 🚀 Tier 3: 高级层示例

### 示例3.1: select!宏

**目标**: 掌握同时等待多个异步操作

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
use tokio::time::{sleep, Duration, timeout, interval};
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    println!("===== select! 基础 =====\n");
    
    let res = tokio::select! {
        _ = sleep(Duration::from_secs(1)) => {
            "1秒计时器"
        }
        _ = sleep(Duration::from_secs(2)) => {
            "2秒计时器"
        }
    };
    
    println!("完成: {}", res);
    
    println!("\n===== Channel + select! =====\n");
    
    let (tx1, mut rx1) = mpsc::channel(32);
    let (tx2, mut rx2) = mpsc::channel(32);
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(100)).await;
        tx1.send("来自通道1").await.unwrap();
    });
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(200)).await;
        tx2.send("来自通道2").await.unwrap();
    });
    
    let res = tokio::select! {
        Some(msg) = rx1.recv() => format!("收到: {}", msg),
        Some(msg) = rx2.recv() => format!("收到: {}", msg),
    };
    
    println!("{}", res);
    
    println!("\n===== 超时控制 =====\n");
    
    async fn long_task() {
        sleep(Duration::from_secs(3)).await;
    }
    
    let result = tokio::select! {
        _ = long_task() => "任务完成",
        _ = sleep(Duration::from_secs(1)) => "超时",
    };
    
    println!("结果: {}", result);
    
    println!("\n===== 循环中的 select! =====\n");
    
    let (tx1, mut rx1) = mpsc::channel(32);
    let (tx2, mut rx2) = mpsc::channel(32);
    
    // 生产者1
    tokio::spawn(async move {
        for i in 0..3 {
            tx1.send(format!("A{}", i)).await.unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    // 生产者2
    tokio::spawn(async move {
        for i in 0..3 {
            tx2.send(format!("B{}", i)).await.unwrap();
            sleep(Duration::from_millis(150)).await;
        }
    });
    
    let mut count = 0;
    loop {
        tokio::select! {
            Some(msg) = rx1.recv() => {
                println!("从通道1: {}", msg);
                count += 1;
            }
            Some(msg) = rx2.recv() => {
                println!("从通道2: {}", msg);
                count += 1;
            }
            else => break,
        }
    }
    
    println!("接收了 {} 条消息\n", count);
    
    println!("===== 带条件的分支 =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        for i in 0..5 {
            tx.send(i).await.unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    let mut allow_timeout = true;
    
    loop {
        tokio::select! {
            Some(num) = rx.recv() => {
                println!("收到: {}", num);
                if num >= 3 {
                    allow_timeout = false;
                }
            }
            _ = sleep(Duration::from_millis(500)), if allow_timeout => {
                println!("允许超时");
            }
            else => break,
        }
    }
    
    println!("\n===== interval 定时器 =====\n");
    
    let mut interval = interval(Duration::from_millis(200));
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        tx.send("消息").await.unwrap();
    });
    
    let mut tick_count = 0;
    
    loop {
        tokio::select! {
            _ = interval.tick() => {
                tick_count += 1;
                println!("Tick {}", tick_count);
                if tick_count >= 5 {
                    break;
                }
            }
            Some(msg) = rx.recv() => {
                println!("收到: {}", msg);
            }
        }
    }
    
    println!("\n===== biased 顺序选择 =====\n");
    
    let (tx1, mut rx1) = mpsc::channel(32);
    let (tx2, mut rx2) = mpsc::channel(32);
    
    tx1.send("高优先级").await.unwrap();
    tx2.send("低优先级").await.unwrap();
    
    tokio::select! {
        biased;
        
        Some(msg) = rx1.recv() => {
            println!("选择: {}", msg);
        }
        Some(msg) = rx2.recv() => {
            println!("选择: {}", msg);
        }
    }
    
    println!("\n===== 取消安全 =====\n");
    
    async fn cancellable_task() {
        for i in 0..10 {
            println!("工作中... {}", i);
            sleep(Duration::from_millis(100)).await;
        }
    }
    
    tokio::select! {
        _ = cancellable_task() => {
            println!("任务完成");
        }
        _ = sleep(Duration::from_millis(350)) => {
            println!("任务被取消");
        }
    }
}
```

**说明**:

- **select!**: 同时等待多个异步操作
- **biased**: 按顺序检查分支
- **else**: 所有分支都完成时执行
- **取消**: 未选中的分支被取消

**输出**:

```text
===== select! 基础 =====

完成: 1秒计时器

===== Channel + select! =====

收到: 来自通道1

===== 超时控制 =====

结果: 超时

===== 循环中的 select! =====

从通道1: A0
从通道1: A1
从通道2: B0
从通道1: A2
从通道2: B1
从通道2: B2
接收了 6 条消息

===== 带条件的分支 =====

收到: 0
收到: 1
收到: 2
收到: 3
收到: 4

===== interval 定时器 =====

Tick 1
Tick 2
收到: 消息
Tick 3
Tick 4
Tick 5

===== biased 顺序选择 =====

选择: 高优先级

===== 取消安全 =====

工作中... 0
工作中... 1
工作中... 2
任务被取消
```

---

### 示例3.2: Pin和自引用

**目标**: 理解Pin和内存固定

**难度**: ⭐⭐⭐⭐⭐

**代码**:

```rust
use std::pin::Pin;
use std::marker::PhantomPinned;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== Pin 基础 =====\n");
    
    let value = 42;
    let pinned = Pin::new(&value);
    
    println!("固定值: {}", *pinned);
    println!("Pin 保证地址不变\n");
    
    println!("===== 自引用结构 =====\n");
    
    struct SelfReferential {
        data: String,
        ptr: *const String,
        _pin: PhantomPinned,
    }
    
    impl SelfReferential {
        fn new(data: String) -> Pin<Box<Self>> {
            let mut boxed = Box::pin(SelfReferential {
                data,
                ptr: std::ptr::null(),
                _pin: PhantomPinned,
            });
            
            let ptr = &boxed.data as *const String;
            unsafe {
                let mut_ref = Pin::as_mut(&mut boxed);
                Pin::get_unchecked_mut(mut_ref).ptr = ptr;
            }
            
            boxed
        }
        
        fn get_data(&self) -> &str {
            &self.data
        }
        
        fn get_ptr_data(&self) -> &str {
            unsafe { &*self.ptr }
        }
    }
    
    let pinned = SelfReferential::new("Hello, Pin!".to_string());
    
    println!("数据: {}", pinned.get_data());
    println!("通过指针: {}", pinned.get_ptr_data());
    println!("地址相同: {}", std::ptr::eq(
        pinned.get_data(),
        pinned.get_ptr_data()
    ));
    
    println!("\n===== Unpin trait =====\n");
    
    fn requires_unpin<T: Unpin>(value: Pin<&T>) {
        println!("这个类型实现了 Unpin");
    }
    
    let value = 42;
    let pinned = Pin::new(&value);
    requires_unpin(pinned);
    
    println!("大多数类型自动实现 Unpin\n");
    
    println!("===== Pin in async =====\n");
    
    use std::future::Future;
    use std::task::{Context, Poll};
    
    struct MyFuture {
        completed: bool,
    }
    
    impl Future for MyFuture {
        type Output = String;
        
        fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
            if self.completed {
                Poll::Ready("完成".to_string())
            } else {
                self.completed = true;
                Poll::Pending
            }
        }
    }
    
    let future = MyFuture { completed: false };
    let pinned_future = Box::pin(future);
    
    println!("Future 需要 Pin 来保证安全");
    
    // 手动轮询
    let waker = futures::task::noop_waker();
    let mut context = std::task::Context::from_waker(&waker);
    
    let mut future = Box::pin(MyFuture { completed: false });
    
    match future.as_mut().poll(&mut context) {
        Poll::Ready(r) => println!("第一次轮询: Ready({})", r),
        Poll::Pending => println!("第一次轮询: Pending"),
    }
    
    match future.as_mut().poll(&mut context) {
        Poll::Ready(r) => println!("第二次轮询: Ready({})", r),
        Poll::Pending => println!("第二次轮询: Pending"),
    }
    
    println!("\n===== 实用示例: 异步生成器模拟 =====\n");
    
    struct AsyncGenerator {
        count: usize,
        max: usize,
        _pin: PhantomPinned,
    }
    
    impl AsyncGenerator {
        fn new(max: usize) -> Pin<Box<Self>> {
            Box::pin(AsyncGenerator {
                count: 0,
                max,
                _pin: PhantomPinned,
            })
        }
        
        async fn next(self: Pin<&mut Self>) -> Option<usize> {
            let this = unsafe { self.get_unchecked_mut() };
            
            if this.count >= this.max {
                return None;
            }
            
            let current = this.count;
            this.count += 1;
            
            sleep(Duration::from_millis(100)).await;
            Some(current)
        }
    }
    
    let mut gen = AsyncGenerator::new(5);
    
    while let Some(value) = gen.as_mut().next().await {
        println!("生成: {}", value);
    }
    
    println!("\n===== Pin API =====\n");
    
    let value = String::from("data");
    let mut pinned = Box::pin(value);
    
    // Pin::as_ref
    let pin_ref: Pin<&String> = pinned.as_ref();
    println!("as_ref: {}", pin_ref);
    
    // Pin::as_mut
    let pin_mut: Pin<&mut String> = pinned.as_mut();
    println!("as_mut: {}", pin_mut);
    
    // Pin::get_ref (如果是 Unpin)
    let value_ref = Pin::get_ref(pinned.as_ref());
    println!("get_ref: {}", value_ref);
    
    println!("\n===== PhantomPinned 作用 =====\n");
    
    // 没有 PhantomPinned 的类型自动实现 Unpin
    struct WithoutPin {
        data: String,
    }
    
    // 有 PhantomPinned 的类型不实现 Unpin
    struct WithPin {
        data: String,
        _pin: PhantomPinned,
    }
    
    println!("WithoutPin 可以移动");
    println!("WithPin 固定后不可移动");
}
```

**说明**:

- **Pin**: 防止值在内存中移动
- **PhantomPinned**: 标记类型不实现Unpin
- **自引用**: 安全地创建自引用结构
- **Future轮询**: Pin保证Future的安全性

**输出**:

```text
===== Pin 基础 =====

固定值: 42
Pin 保证地址不变

===== 自引用结构 =====

数据: Hello, Pin!
通过指针: Hello, Pin!
地址相同: true

===== Unpin trait =====

这个类型实现了 Unpin
大多数类型自动实现 Unpin

===== Pin in async =====

Future 需要 Pin 来保证安全
第一次轮询: Pending
第二次轮询: Ready(完成)

===== 实用示例: 异步生成器模拟 =====

生成: 0
生成: 1
生成: 2
生成: 3
生成: 4

===== Pin API =====

as_ref: data
as_mut: data
get_ref: data

===== PhantomPinned 作用 =====

WithoutPin 可以移动
WithPin 固定后不可移动
```

---

## 📝 总结

### 学习路径建议

1. **第一阶段** (Tier 1): 掌握基础 (示例 1.1-1.4)
   - async/await 语法
   - Future trait
   - tokio 运行时
   - 异步任务

2. **第二阶段** (Tier 2): 实践应用 (示例 2.1-2.4)
   - 异步文件 I/O
   - 异步网络编程
   - 异步 Channel
   - 异步锁

3. **第三阶段** (Tier 3): 深入理解 (示例 3.1-3.2)
   - select! 宏
   - Pin 和自引用

### 核心概念总结

| 概念 | 相关示例 | 重要性 | 难度 |
|------|---------|--------|------|
| async/await | 1.1 | ⭐⭐⭐⭐⭐ | ⭐ |
| Future | 1.2 | ⭐⭐⭐⭐ | ⭐⭐ |
| tokio运行时 | 1.3 | ⭐⭐⭐⭐⭐ | ⭐ |
| spawn | 1.4 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 异步I/O | 2.1 | ⭐⭐⭐⭐ | ⭐⭐ |

### 最佳实践

1. **选择运行时**:
   - 一般应用：tokio
   - 嵌入式：embassy
   - 简单场景：async-std

2. **任务管理**:
   - CPU 密集：spawn_blocking
   - I/O 密集：tokio::spawn
   - 批量任务：JoinSet

3. **错误处理**:
   - 使用 Result
   - ? 操作符
   - 检查 JoinHandle

4. **性能优化**:
   - 避免阻塞调用
   - 使用缓冲 I/O
   - 合理配置运行时

### 下一步

- 📖 深入学习: [Future与Executor机制](./02_Future与Executor机制.md)
- 📖 深入学习: [异步运行时选择指南](./03_异步运行时选择指南.md)
- 🚀 实战项目: [C06 实战项目集](./08_实战项目集.md) (即将创建)
- 📚 参考文档: [tier_03_references](../tier_03_references/)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-25  
**维护状态**: 活跃维护

**💡 异步编程是 Rust 的强大特性，掌握它能构建高性能的并发应用！🦀**-
