# âš¡ C06: å¼‚æ­¥ç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25  
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **é€‚ç”¨æ¨¡å—**: C06 å¼‚æ­¥ç¼–ç¨‹  
> **ç›®æ ‡**: é€šè¿‡ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å­¦ä¹ è€…æ·±å…¥ç†è§£ Rust å¼‚æ­¥ç¼–ç¨‹å’Œ async/awaitã€‚

---

## ç›®å½•

- [âš¡ C06: å¼‚æ­¥ç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ](#-c06-å¼‚æ­¥ç¼–ç¨‹---ä»£ç ç¤ºä¾‹é›†åˆ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
  - [ğŸ¯ ç¤ºä¾‹å¯¼èˆª](#-ç¤ºä¾‹å¯¼èˆª)
  - [ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹](#-tier-1-åŸºç¡€å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹1.1: async/awaitåŸºç¡€](#ç¤ºä¾‹11-asyncawaitåŸºç¡€)
    - [ç¤ºä¾‹1.2: FutureåŸºç¡€](#ç¤ºä¾‹12-futureåŸºç¡€)
    - [ç¤ºä¾‹1.3: tokioè¿è¡Œæ—¶](#ç¤ºä¾‹13-tokioè¿è¡Œæ—¶)
    - [ç¤ºä¾‹1.4: å¼‚æ­¥ä»»åŠ¡spawn](#ç¤ºä¾‹14-å¼‚æ­¥ä»»åŠ¡spawn)
  - [ğŸ“ Tier 2: å®è·µå±‚ç¤ºä¾‹](#-tier-2-å®è·µå±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹2.1: å¼‚æ­¥æ–‡ä»¶IO](#ç¤ºä¾‹21-å¼‚æ­¥æ–‡ä»¶io)
    - [ç¤ºä¾‹2.2: å¼‚æ­¥ç½‘ç»œç¼–ç¨‹](#ç¤ºä¾‹22-å¼‚æ­¥ç½‘ç»œç¼–ç¨‹)
    - [ç¤ºä¾‹2.3: å¼‚æ­¥Channel](#ç¤ºä¾‹23-å¼‚æ­¥channel)
    - [ç¤ºä¾‹2.4: å¼‚æ­¥é”å’ŒåŒæ­¥](#ç¤ºä¾‹24-å¼‚æ­¥é”å’ŒåŒæ­¥)
  - [ğŸš€ Tier 3: é«˜çº§å±‚ç¤ºä¾‹](#-tier-3-é«˜çº§å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹3.1: select!å®](#ç¤ºä¾‹31-selectå®)
    - [ç¤ºä¾‹3.2: Pinå’Œè‡ªå¼•ç”¨](#ç¤ºä¾‹32-pinå’Œè‡ªå¼•ç”¨)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å­¦ä¹ è·¯å¾„å»ºè®®](#å­¦ä¹ è·¯å¾„å»ºè®®)
    - [æ ¸å¿ƒæ¦‚å¿µæ€»ç»“](#æ ¸å¿ƒæ¦‚å¿µæ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº† **10ä¸ªç²¾å¿ƒè®¾è®¡çš„ä»£ç ç¤ºä¾‹**ï¼Œè¦†ç›–äº† C06 æ¨¡å—çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä»åŸºç¡€åˆ°é«˜çº§ï¼Œæ¯ä¸ªç¤ºä¾‹éƒ½é…æœ‰è¯¦ç»†çš„è§£é‡Šå’Œè¿è¡Œç»“æœã€‚

---

## ğŸ¯ ç¤ºä¾‹å¯¼èˆª

| # | ç¤ºä¾‹åç§° | æ ¸å¿ƒæ¦‚å¿µ | éš¾åº¦ | é¢„è®¡å­¦ä¹ æ—¶é—´ |
|---|----------|----------|------|--------------|
| **Tier 1: åŸºç¡€å±‚** |||||
| 1.1 | [async/awaitåŸºç¡€](#ç¤ºä¾‹11-asyncawaitåŸºç¡€) | async fn, await | â­ | 20åˆ†é’Ÿ |
| 1.2 | [FutureåŸºç¡€](#ç¤ºä¾‹12-futureåŸºç¡€) | Future trait | â­â­ | 30åˆ†é’Ÿ |
| 1.3 | [tokioè¿è¡Œæ—¶](#ç¤ºä¾‹13-tokioè¿è¡Œæ—¶) | #[tokio::main] | â­ | 25åˆ†é’Ÿ |
| 1.4 | [å¼‚æ­¥ä»»åŠ¡spawn](#ç¤ºä¾‹14-å¼‚æ­¥ä»»åŠ¡spawn) | tokio::spawn | â­â­ | 30åˆ†é’Ÿ |
| **Tier 2: å®è·µå±‚** |||||
| 2.1 | [å¼‚æ­¥æ–‡ä»¶IO](#ç¤ºä¾‹21-å¼‚æ­¥æ–‡ä»¶io) | tokio::fs | â­â­ | 35åˆ†é’Ÿ |
| 2.2 | [å¼‚æ­¥ç½‘ç»œç¼–ç¨‹](#ç¤ºä¾‹22-å¼‚æ­¥ç½‘ç»œç¼–ç¨‹) | TcpListener | â­â­â­ | 45åˆ†é’Ÿ |
| 2.3 | [å¼‚æ­¥Channel](#ç¤ºä¾‹23-å¼‚æ­¥channel) | mpsc | â­â­â­ | 40åˆ†é’Ÿ |
| 2.4 | [å¼‚æ­¥é”å’ŒåŒæ­¥](#ç¤ºä¾‹24-å¼‚æ­¥é”å’ŒåŒæ­¥) | Mutex, RwLock | â­â­â­ | 45åˆ†é’Ÿ |
| **Tier 3: é«˜çº§å±‚** |||||
| 3.1 | [select!å®](#ç¤ºä¾‹31-selectå®) | tokio::select! | â­â­â­â­ | 50åˆ†é’Ÿ |
| 3.2 | [Pinå’Œè‡ªå¼•ç”¨](#ç¤ºä¾‹32-pinå’Œè‡ªå¼•ç”¨) | Pin, Unpin | â­â­â­â­â­ | 60åˆ†é’Ÿ |

---

## ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹

### ç¤ºä¾‹1.1: async/awaitåŸºç¡€

**ç›®æ ‡**: ç†è§£ async/await çš„åŸºæœ¬è¯­æ³•

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== async å‡½æ•°åŸºç¡€ =====\n");
    
    // async å‡½æ•°è¿”å› Future
    async fn say_hello() {
        println!("Hello from async!");
    }
    
    // await ç­‰å¾… Future å®Œæˆ
    say_hello().await;
    
    println!("\n===== async å‡½æ•°è¿”å›å€¼ =====\n");
    
    async fn get_number() -> i32 {
        42
    }
    
    let number = get_number().await;
    println!("å¼‚æ­¥å‡½æ•°è¿”å›: {}\n", number);
    
    println!("===== å¼‚æ­¥ä¼‘çœ  =====\n");
    
    async fn async_sleep(seconds: u64) {
        println!("å¼€å§‹ä¼‘çœ  {} ç§’", seconds);
        sleep(Duration::from_secs(seconds)).await;
        println!("ä¼‘çœ  {} ç§’ç»“æŸ", seconds);
    }
    
    async_sleep(1).await;
    
    println!("\n===== å¼‚æ­¥æ“ä½œç»„åˆ =====\n");
    
    async fn fetch_data(id: u32) -> String {
        sleep(Duration::from_millis(100)).await;
        format!("æ•°æ®{}", id)
    }
    
    let data1 = fetch_data(1).await;
    let data2 = fetch_data(2).await;
    
    println!("è·å–åˆ°: {}, {}\n", data1, data2);
    
    println!("===== å¹¶å‘æ‰§è¡Œ =====\n");
    
    use tokio::join;
    
    let (result1, result2) = join!(
        fetch_data(3),
        fetch_data(4)
    );
    
    println!("å¹¶å‘è·å–åˆ°: {}, {}\n", result1, result2);
    
    println!("===== é”™è¯¯å¤„ç† =====\n");
    
    async fn fallible_operation() -> Result<i32, String> {
        sleep(Duration::from_millis(50)).await;
        Ok(42)
    }
    
    match fallible_operation().await {
        Ok(value) => println!("æˆåŠŸ: {}", value),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
    
    println!("\n===== ? æ“ä½œç¬¦ =====\n");
    
    async fn async_main() -> Result<(), String> {
        let value = fallible_operation().await?;
        println!("å€¼: {}", value);
        Ok(())
    }
    
    let _ = async_main().await;
}
```

**è¯´æ˜**:

- **async fn**: å£°æ˜å¼‚æ­¥å‡½æ•°
- **await**: ç­‰å¾… Future å®Œæˆ
- **join!**: å¹¶å‘æ‰§è¡Œå¤šä¸ª Future
- **Result**: å¼‚æ­¥å‡½æ•°ä¹Ÿå¯ä»¥è¿”å› Result

**è¾“å‡º**:

```text
===== async å‡½æ•°åŸºç¡€ =====

Hello from async!

===== async å‡½æ•°è¿”å›å€¼ =====

å¼‚æ­¥å‡½æ•°è¿”å›: 42

===== å¼‚æ­¥ä¼‘çœ  =====

å¼€å§‹ä¼‘çœ  1 ç§’
ä¼‘çœ  1 ç§’ç»“æŸ

===== å¼‚æ­¥æ“ä½œç»„åˆ =====

è·å–åˆ°: æ•°æ®1, æ•°æ®2

===== å¹¶å‘æ‰§è¡Œ =====

å¹¶å‘è·å–åˆ°: æ•°æ®3, æ•°æ®4

===== é”™è¯¯å¤„ç† =====

æˆåŠŸ: 42

===== ? æ“ä½œç¬¦ =====

å€¼: 42
```

---

### ç¤ºä¾‹1.2: FutureåŸºç¡€

**ç›®æ ‡**: ç†è§£ Future trait çš„å·¥ä½œåŸç†

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== Future trait =====\n");
    
    // æ‰‹åŠ¨å®ç° Future
    struct MyFuture {
        count: u32,
    }
    
    impl Future for MyFuture {
        type Output = u32;
        
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.count += 1;
            
            if self.count < 3 {
                println!("è¿˜æ²¡å‡†å¤‡å¥½ï¼Œè½®è¯¢ç¬¬ {} æ¬¡", self.count);
                cx.waker().wake_by_ref();  // é€šçŸ¥å†æ¬¡è½®è¯¢
                Poll::Pending
            } else {
                println!("å‡†å¤‡å¥½äº†ï¼");
                Poll::Ready(self.count)
            }
        }
    }
    
    let future = MyFuture { count: 0 };
    let result = future.await;
    println!("Future å®Œæˆï¼Œç»“æœ: {}\n", result);
    
    println!("===== Future çŠ¶æ€ =====\n");
    
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    
    struct DelayedFuture {
        ready: Arc<AtomicBool>,
    }
    
    impl Future for DelayedFuture {
        type Output = &'static str;
        
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            if self.ready.load(Ordering::SeqCst) {
                Poll::Ready("å®Œæˆ!")
            } else {
                println!("è¿˜åœ¨ç­‰å¾…...");
                
                // æ¨¡æ‹Ÿå¼‚æ­¥é€šçŸ¥
                let waker = cx.waker().clone();
                let ready = self.ready.clone();
                
                tokio::spawn(async move {
                    sleep(Duration::from_millis(100)).await;
                    ready.store(true, Ordering::SeqCst);
                    waker.wake();
                });
                
                Poll::Pending
            }
        }
    }
    
    let ready = Arc::new(AtomicBool::new(false));
    let future = DelayedFuture { ready };
    let result = future.await;
    println!("ç»“æœ: {}\n", result);
    
    println!("===== ç»„åˆ Future =====\n");
    
    use std::future::ready;
    
    let future1 = ready(1);
    let future2 = ready(2);
    
    let (a, b) = tokio::join!(future1, future2);
    println!("ç»„åˆç»“æœ: {} + {} = {}\n", a, b, a + b);
    
    println!("===== async å— =====\n");
    
    let future = async {
        println!("å¼‚æ­¥å—å¼€å§‹");
        sleep(Duration::from_millis(50)).await;
        println!("å¼‚æ­¥å—ç»“æŸ");
        42
    };
    
    let result = future.await;
    println!("å¼‚æ­¥å—è¿”å›: {}", result);
}
```

**è¯´æ˜**:

- **Future trait**: å¼‚æ­¥è®¡ç®—çš„æ ¸å¿ƒæŠ½è±¡
- **Poll**: Pendingï¼ˆæœªå®Œæˆï¼‰æˆ– Readyï¼ˆå®Œæˆï¼‰
- **Waker**: é€šçŸ¥è¿è¡Œæ—¶é‡æ–°è½®è¯¢
- **asyncå—**: åˆ›å»ºåŒ¿å Future

**è¾“å‡º**:

```text
===== Future trait =====

è¿˜æ²¡å‡†å¤‡å¥½ï¼Œè½®è¯¢ç¬¬ 1 æ¬¡
è¿˜æ²¡å‡†å¤‡å¥½ï¼Œè½®è¯¢ç¬¬ 2 æ¬¡
å‡†å¤‡å¥½äº†ï¼
Future å®Œæˆï¼Œç»“æœ: 3

===== Future çŠ¶æ€ =====

è¿˜åœ¨ç­‰å¾…...
ç»“æœ: å®Œæˆ!

===== ç»„åˆ Future =====

ç»„åˆç»“æœ: 1 + 2 = 3

===== async å— =====

å¼‚æ­¥å—å¼€å§‹
å¼‚æ­¥å—ç»“æŸ
å¼‚æ­¥å—è¿”å›: 42
```

---

### ç¤ºä¾‹1.3: tokioè¿è¡Œæ—¶

**ç›®æ ‡**: ç†è§£ tokio è¿è¡Œæ—¶çš„é…ç½®å’Œä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use tokio::time::{sleep, Duration};
use tokio::runtime::Runtime;

fn main() {
    println!("===== é»˜è®¤è¿è¡Œæ—¶ =====\n");
    
    // ä½¿ç”¨å®åˆ›å»ºè¿è¡Œæ—¶
    #[tokio::main]
    async fn run_with_macro() {
        println!("ä½¿ç”¨ #[tokio::main] å®");
        sleep(Duration::from_millis(50)).await;
    }
    
    println!("\n===== æ‰‹åŠ¨åˆ›å»ºè¿è¡Œæ—¶ =====\n");
    
    // æ‰‹åŠ¨åˆ›å»ºè¿è¡Œæ—¶
    let rt = Runtime::new().unwrap();
    
    rt.block_on(async {
        println!("æ‰‹åŠ¨è¿è¡Œæ—¶æ‰§è¡Œ");
        sleep(Duration::from_millis(50)).await;
        println!("å¼‚æ­¥ä»»åŠ¡å®Œæˆ");
    });
    
    println!("\n===== å¤šçº¿ç¨‹è¿è¡Œæ—¶ =====\n");
    
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(4)
        .thread_name("my-pool")
        .build()
        .unwrap();
    
    rt.block_on(async {
        let handles: Vec<_> = (0..4).map(|i| {
            tokio::spawn(async move {
                println!("ä»»åŠ¡ {} åœ¨çº¿ç¨‹ {:?}", i, std::thread::current().name());
                sleep(Duration::from_millis(10)).await;
                i * 2
            })
        }).collect();
        
        for handle in handles {
            let result = handle.await.unwrap();
            println!("ç»“æœ: {}", result);
        }
    });
    
    println!("\n===== å•çº¿ç¨‹è¿è¡Œæ—¶ =====\n");
    
    let rt = tokio::runtime::Builder::new_current_thread()
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("å•çº¿ç¨‹è¿è¡Œæ—¶");
        
        tokio::spawn(async {
            println!("ä»»åŠ¡1");
        }).await.unwrap();
        
        tokio::spawn(async {
            println!("ä»»åŠ¡2");
        }).await.unwrap();
    });
    
    println!("\n===== è¿è¡Œæ—¶é…ç½® =====\n");
    
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .thread_name("custom")
        .thread_stack_size(3 * 1024 * 1024)
        .enable_all()
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("è‡ªå®šä¹‰é…ç½®çš„è¿è¡Œæ—¶");
        println!("å·¥ä½œçº¿ç¨‹æ•°: 2");
        println!("çº¿ç¨‹å: custom");
        println!("æ ˆå¤§å°: 3MB");
    });
    
    println!("\n===== è¿è¡Œæ—¶å¥æŸ„ =====\n");
    
    let rt = Runtime::new().unwrap();
    let handle = rt.handle().clone();
    
    // åœ¨è¿è¡Œæ—¶å¤–éƒ¨ä½¿ç”¨å¥æŸ„
    std::thread::spawn(move || {
        handle.block_on(async {
            println!("ä»å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå¼‚æ­¥ä»£ç ");
        });
    }).join().unwrap();
}
```

**è¯´æ˜**:

- **#[tokio::main]**: å®è‡ªåŠ¨åˆ›å»ºè¿è¡Œæ—¶
- **Runtime::new()**: æ‰‹åŠ¨åˆ›å»ºè¿è¡Œæ—¶
- **multi_thread**: å¤šçº¿ç¨‹å·¥ä½œçªƒå–è°ƒåº¦å™¨
- **current_thread**: å•çº¿ç¨‹è¿è¡Œæ—¶

**è¾“å‡º**:

```text
===== é»˜è®¤è¿è¡Œæ—¶ =====

===== æ‰‹åŠ¨åˆ›å»ºè¿è¡Œæ—¶ =====

æ‰‹åŠ¨è¿è¡Œæ—¶æ‰§è¡Œ
å¼‚æ­¥ä»»åŠ¡å®Œæˆ

===== å¤šçº¿ç¨‹è¿è¡Œæ—¶ =====

ä»»åŠ¡ 0 åœ¨çº¿ç¨‹ Some("my-pool-0")
ä»»åŠ¡ 1 åœ¨çº¿ç¨‹ Some("my-pool-1")
ä»»åŠ¡ 2 åœ¨çº¿ç¨‹ Some("my-pool-2")
ä»»åŠ¡ 3 åœ¨çº¿ç¨‹ Some("my-pool-3")
ç»“æœ: 0
ç»“æœ: 2
ç»“æœ: 4
ç»“æœ: 6

===== å•çº¿ç¨‹è¿è¡Œæ—¶ =====

å•çº¿ç¨‹è¿è¡Œæ—¶
ä»»åŠ¡1
ä»»åŠ¡2

===== è¿è¡Œæ—¶é…ç½® =====

è‡ªå®šä¹‰é…ç½®çš„è¿è¡Œæ—¶
å·¥ä½œçº¿ç¨‹æ•°: 2
çº¿ç¨‹å: custom
æ ˆå¤§å°: 3MB

===== è¿è¡Œæ—¶å¥æŸ„ =====

ä»å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå¼‚æ­¥ä»£ç 
```

---

### ç¤ºä¾‹1.4: å¼‚æ­¥ä»»åŠ¡spawn

**ç›®æ ‡**: ç†è§£å¼‚æ­¥ä»»åŠ¡çš„åˆ›å»ºå’Œç®¡ç†

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use tokio::time::{sleep, Duration};
use tokio::task;

#[tokio::main]
async fn main() {
    println!("===== åŸºç¡€ spawn =====\n");
    
    let handle = tokio::spawn(async {
        println!("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ");
        sleep(Duration::from_millis(50)).await;
        42
    });
    
    let result = handle.await.unwrap();
    println!("ä»»åŠ¡è¿”å›: {}\n", result);
    
    println!("===== å¤šä¸ªä»»åŠ¡ =====\n");
    
    let mut handles = vec![];
    
    for i in 0..5 {
        let handle = tokio::spawn(async move {
            sleep(Duration::from_millis(i * 10)).await;
            println!("ä»»åŠ¡ {} å®Œæˆ", i);
            i * 2
        });
        handles.push(handle);
    }
    
    for handle in handles {
        let result = handle.await.unwrap();
        println!("æ”¶åˆ°ç»“æœ: {}", result);
    }
    
    println!("\n===== ä»»åŠ¡å–æ¶ˆ =====\n");
    
    let handle = tokio::spawn(async {
        loop {
            println!("ä»»åŠ¡è¿è¡Œä¸­...");
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    sleep(Duration::from_millis(250)).await;
    
    handle.abort();  // å–æ¶ˆä»»åŠ¡
    
    match handle.await {
        Ok(_) => println!("ä»»åŠ¡æ­£å¸¸å®Œæˆ"),
        Err(e) if e.is_cancelled() => println!("ä»»åŠ¡è¢«å–æ¶ˆ"),
        Err(e) => println!("ä»»åŠ¡å¤±è´¥: {:?}", e),
    }
    
    println!("\n===== ä»»åŠ¡ panic å¤„ç† =====\n");
    
    let handle = tokio::spawn(async {
        sleep(Duration::from_millis(50)).await;
        panic!("ä»»åŠ¡ panic!");
    });
    
    match handle.await {
        Ok(_) => println!("ä»»åŠ¡æˆåŠŸ"),
        Err(e) if e.is_panic() => println!("ä»»åŠ¡ panic: {:?}", e),
        Err(e) => println!("å…¶ä»–é”™è¯¯: {:?}", e),
    }
    
    println!("\n===== blocking ä»»åŠ¡ =====\n");
    
    let handle = task::spawn_blocking(|| {
        // CPU å¯†é›†å‹æˆ–é˜»å¡æ“ä½œ
        std::thread::sleep(std::time::Duration::from_millis(100));
        println!("é˜»å¡ä»»åŠ¡å®Œæˆ");
        42
    });
    
    let result = handle.await.unwrap();
    println!("é˜»å¡ä»»åŠ¡è¿”å›: {}\n", result);
    
    println!("===== JoinSet æ‰¹é‡ç®¡ç† =====\n");
    
    use tokio::task::JoinSet;
    
    let mut set = JoinSet::new();
    
    for i in 0..3 {
        set.spawn(async move {
            sleep(Duration::from_millis(i * 50)).await;
            println!("JoinSet ä»»åŠ¡ {} å®Œæˆ", i);
            i
        });
    }
    
    while let Some(result) = set.join_next().await {
        match result {
            Ok(value) => println!("ä»»åŠ¡ç»“æœ: {}", value),
            Err(e) => println!("ä»»åŠ¡é”™è¯¯: {:?}", e),
        }
    }
    
    println!("\n===== æœ¬åœ°ä»»åŠ¡ =====\n");
    
    let local = task::LocalSet::new();
    
    local.run_until(async {
        let handle = task::spawn_local(async {
            println!("æœ¬åœ°ä»»åŠ¡æ‰§è¡Œ");
            sleep(Duration::from_millis(50)).await;
            "æœ¬åœ°ä»»åŠ¡å®Œæˆ"
        });
        
        let result = handle.await.unwrap();
        println!("{}", result);
    }).await;
}
```

**è¯´æ˜**:

- **tokio::spawn**: åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
- **JoinHandle**: ä»»åŠ¡å¥æŸ„
- **abort**: å–æ¶ˆä»»åŠ¡
- **spawn_blocking**: æ‰§è¡Œé˜»å¡æ“ä½œ
- **JoinSet**: æ‰¹é‡ç®¡ç†ä»»åŠ¡

**è¾“å‡º**:

```text
===== åŸºç¡€ spawn =====

å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ
ä»»åŠ¡è¿”å›: 42

===== å¤šä¸ªä»»åŠ¡ =====

ä»»åŠ¡ 0 å®Œæˆ
ä»»åŠ¡ 1 å®Œæˆ
ä»»åŠ¡ 2 å®Œæˆ
ä»»åŠ¡ 3 å®Œæˆ
ä»»åŠ¡ 4 å®Œæˆ
æ”¶åˆ°ç»“æœ: 0
æ”¶åˆ°ç»“æœ: 2
æ”¶åˆ°ç»“æœ: 4
æ”¶åˆ°ç»“æœ: 6
æ”¶åˆ°ç»“æœ: 8

===== ä»»åŠ¡å–æ¶ˆ =====

ä»»åŠ¡è¿è¡Œä¸­...
ä»»åŠ¡è¿è¡Œä¸­...
ä»»åŠ¡è¿è¡Œä¸­...
ä»»åŠ¡è¢«å–æ¶ˆ

===== ä»»åŠ¡ panic å¤„ç† =====

ä»»åŠ¡ panic: JoinError::Panic

===== blocking ä»»åŠ¡ =====

é˜»å¡ä»»åŠ¡å®Œæˆ
é˜»å¡ä»»åŠ¡è¿”å›: 42

===== JoinSet æ‰¹é‡ç®¡ç† =====

JoinSet ä»»åŠ¡ 0 å®Œæˆ
ä»»åŠ¡ç»“æœ: 0
JoinSet ä»»åŠ¡ 1 å®Œæˆ
ä»»åŠ¡ç»“æœ: 1
JoinSet ä»»åŠ¡ 2 å®Œæˆ
ä»»åŠ¡ç»“æœ: 2

===== æœ¬åœ°ä»»åŠ¡ =====

æœ¬åœ°ä»»åŠ¡æ‰§è¡Œ
æœ¬åœ°ä»»åŠ¡å®Œæˆ
```

---

## ğŸ“ Tier 2: å®è·µå±‚ç¤ºä¾‹

### ç¤ºä¾‹2.1: å¼‚æ­¥æ–‡ä»¶IO

**ç›®æ ‡**: æŒæ¡å¼‚æ­¥æ–‡ä»¶æ“ä½œ

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== å¼‚æ­¥å†™æ–‡ä»¶ =====\n");
    
    let content = "Hello, async file I/O!";
    fs::write("test.txt", content).await?;
    println!("å†™å…¥å†…å®¹: {}\n", content);
    
    println!("===== å¼‚æ­¥è¯»æ–‡ä»¶ =====\n");
    
    let content = fs::read_to_string("test.txt").await?;
    println!("è¯»å–å†…å®¹: {}\n", content);
    
    println!("===== æµå¼è¯»å– =====\n");
    
    let mut file = fs::File::open("test.txt").await?;
    let mut buffer = vec![0; 128];
    
    let n = file.read(&mut buffer).await?;
    let content = String::from_utf8_lossy(&buffer[..n]);
    println!("æµå¼è¯»å–: {}\n", content);
    
    println!("===== æµå¼å†™å…¥ =====\n");
    
    let mut file = fs::File::create("output.txt").await?;
    file.write_all(b"Line 1\n").await?;
    file.write_all(b"Line 2\n").await?;
    file.flush().await?;
    println!("æµå¼å†™å…¥å®Œæˆ\n");
    
    println!("===== æ–‡ä»¶å…ƒæ•°æ® =====\n");
    
    let metadata = fs::metadata("test.txt").await?;
    println!("æ–‡ä»¶å¤§å°: {} å­—èŠ‚", metadata.len());
    println!("æ˜¯æ–‡ä»¶: {}", metadata.is_file());
    println!("æ˜¯ç›®å½•: {}\n", metadata.is_dir());
    
    println!("===== ç›®å½•æ“ä½œ =====\n");
    
    // åˆ›å»ºç›®å½•
    fs::create_dir_all("test_dir/sub_dir").await?;
    println!("ç›®å½•åˆ›å»ºæˆåŠŸ");
    
    // åˆ—å‡ºç›®å½•
    let mut entries = fs::read_dir("test_dir").await?;
    while let Some(entry) = entries.next_entry().await? {
        println!("ç›®å½•é¡¹: {:?}", entry.file_name());
    }
    
    println!("\n===== æ–‡ä»¶å¤åˆ¶å’Œç§»åŠ¨ =====\n");
    
    fs::copy("test.txt", "test_copy.txt").await?;
    println!("æ–‡ä»¶å¤åˆ¶å®Œæˆ");
    
    fs::rename("test_copy.txt", "test_renamed.txt").await?;
    println!("æ–‡ä»¶é‡å‘½åå®Œæˆ");
    
    println!("\n===== æ¸…ç† =====\n");
    
    fs::remove_file("test.txt").await?;
    fs::remove_file("output.txt").await?;
    fs::remove_file("test_renamed.txt").await?;
    fs::remove_dir_all("test_dir").await?;
    println!("æ¸…ç†å®Œæˆ");
    
    Ok(())
}
```

**è¯´æ˜**:

- **tokio::fs**: å¼‚æ­¥æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
- **AsyncReadExt**: å¼‚æ­¥è¯»å– trait
- **AsyncWriteExt**: å¼‚æ­¥å†™å…¥ trait
- **éé˜»å¡**: ä¸ä¼šé˜»å¡è¿è¡Œæ—¶

**è¾“å‡º**:

```text
===== å¼‚æ­¥å†™æ–‡ä»¶ =====

å†™å…¥å†…å®¹: Hello, async file I/O!

===== å¼‚æ­¥è¯»æ–‡ä»¶ =====

è¯»å–å†…å®¹: Hello, async file I/O!

===== æµå¼è¯»å– =====

æµå¼è¯»å–: Hello, async file I/O!

===== æµå¼å†™å…¥ =====

æµå¼å†™å…¥å®Œæˆ

===== æ–‡ä»¶å…ƒæ•°æ® =====

æ–‡ä»¶å¤§å°: 23 å­—èŠ‚
æ˜¯æ–‡ä»¶: true
æ˜¯ç›®å½•: false

===== ç›®å½•æ“ä½œ =====

ç›®å½•åˆ›å»ºæˆåŠŸ
ç›®å½•é¡¹: "sub_dir"

===== æ–‡ä»¶å¤åˆ¶å’Œç§»åŠ¨ =====

æ–‡ä»¶å¤åˆ¶å®Œæˆ
æ–‡ä»¶é‡å‘½åå®Œæˆ

===== æ¸…ç† =====

æ¸…ç†å®Œæˆ
```

---

### ç¤ºä¾‹2.2: å¼‚æ­¥ç½‘ç»œç¼–ç¨‹

**ç›®æ ‡**: æŒæ¡å¼‚æ­¥TCPç½‘ç»œç¼–ç¨‹

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::time::{timeout, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== å¼‚æ­¥TCPæœåŠ¡å™¨ =====\n");
    
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("æœåŠ¡å™¨ç›‘å¬: 127.0.0.1:8080");
    
    // åœ¨åå°å¤„ç†å®¢æˆ·ç«¯
    tokio::spawn(async move {
        loop {
            let (socket, addr) = listener.accept().await.unwrap();
            println!("æ–°è¿æ¥: {}", addr);
            
            tokio::spawn(handle_client(socket));
        }
    });
    
    println!("\n===== å¼‚æ­¥TCPå®¢æˆ·ç«¯ =====\n");
    
    // ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    println!("è¿æ¥åˆ°æœåŠ¡å™¨");
    
    // å‘é€æ•°æ®
    stream.write_all(b"Hello from client").await?;
    println!("å‘é€: Hello from client");
    
    // æ¥æ”¶å“åº”
    let mut buffer = vec![0; 1024];
    let n = stream.read(&mut buffer).await?;
    let response = String::from_utf8_lossy(&buffer[..n]);
    println!("æ”¶åˆ°: {}", response);
    
    println!("\n===== å¤šä¸ªå¹¶å‘è¿æ¥ =====\n");
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let handle = tokio::spawn(async move {
            let mut stream = TcpStream::connect("127.0.0.1:8080").await.unwrap();
            let message = format!("Client {}", i);
            stream.write_all(message.as_bytes()).await.unwrap();
            
            let mut buffer = vec![0; 1024];
            let n = stream.read(&mut buffer).await.unwrap();
            println!("å®¢æˆ·ç«¯ {} æ”¶åˆ°: {}", i, String::from_utf8_lossy(&buffer[..n]));
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await?;
    }
    
    println!("\n===== è¶…æ—¶å¤„ç† =====\n");
    
    let result = timeout(
        Duration::from_secs(2),
        TcpStream::connect("127.0.0.1:9999")
    ).await;
    
    match result {
        Ok(Ok(_)) => println!("è¿æ¥æˆåŠŸ"),
        Ok(Err(e)) => println!("è¿æ¥å¤±è´¥: {}", e),
        Err(_) => println!("è¿æ¥è¶…æ—¶"),
    }
    
    println!("\n===== HTTP å®¢æˆ·ç«¯ç¤ºä¾‹ =====\n");
    
    let mut stream = TcpStream::connect("httpbin.org:80").await?;
    
    let request = "GET /get HTTP/1.1\r\nHost: httpbin.org\r\nConnection: close\r\n\r\n";
    stream.write_all(request.as_bytes()).await?;
    println!("å‘é€HTTPè¯·æ±‚");
    
    let mut response = String::new();
    stream.read_to_string(&mut response).await?;
    println!("æ”¶åˆ°å“åº” ({} å­—èŠ‚)", response.len());
    println!("å‰100å­—èŠ‚:\n{}", &response[..response.len().min(100)]);
    
    Ok(())
}

async fn handle_client(mut socket: TcpStream) {
    let mut buffer = vec![0; 1024];
    
    loop {
        match socket.read(&mut buffer).await {
            Ok(0) => {
                println!("å®¢æˆ·ç«¯æ–­å¼€");
                break;
            }
            Ok(n) => {
                let message = String::from_utf8_lossy(&buffer[..n]);
                println!("æ”¶åˆ°æ¶ˆæ¯: {}", message);
                
                let response = format!("Echo: {}", message);
                socket.write_all(response.as_bytes()).await.unwrap();
            }
            Err(e) => {
                eprintln!("è¯»å–é”™è¯¯: {}", e);
                break;
            }
        }
    }
}
```

**è¯´æ˜**:

- **TcpListener**: å¼‚æ­¥TCPæœåŠ¡å™¨
- **TcpStream**: å¼‚æ­¥TCPè¿æ¥
- **å¹¶å‘å¤„ç†**: æ¯ä¸ªè¿æ¥ä¸€ä¸ªtask
- **è¶…æ—¶æ§åˆ¶**: timeoutåŒ…è£…å¼‚æ­¥æ“ä½œ

**è¾“å‡º**:

```text
===== å¼‚æ­¥TCPæœåŠ¡å™¨ =====

æœåŠ¡å™¨ç›‘å¬: 127.0.0.1:8080

===== å¼‚æ­¥TCPå®¢æˆ·ç«¯ =====

æ–°è¿æ¥: 127.0.0.1:xxxxx
è¿æ¥åˆ°æœåŠ¡å™¨
å‘é€: Hello from client
æ”¶åˆ°æ¶ˆæ¯: Hello from client
æ”¶åˆ°: Echo: Hello from client

===== å¤šä¸ªå¹¶å‘è¿æ¥ =====

æ–°è¿æ¥: 127.0.0.1:xxxxx
æ–°è¿æ¥: 127.0.0.1:xxxxx
æ–°è¿æ¥: 127.0.0.1:xxxxx
å®¢æˆ·ç«¯ 0 æ”¶åˆ°: Echo: Client 0
å®¢æˆ·ç«¯ 1 æ”¶åˆ°: Echo: Client 1
å®¢æˆ·ç«¯ 2 æ”¶åˆ°: Echo: Client 2

===== è¶…æ—¶å¤„ç† =====

è¿æ¥è¶…æ—¶

===== HTTP å®¢æˆ·ç«¯ç¤ºä¾‹ =====

å‘é€HTTPè¯·æ±‚
æ”¶åˆ°å“åº” (XXX å­—èŠ‚)
å‰100å­—èŠ‚:
HTTP/1.1 200 OK
...
```

---

### ç¤ºä¾‹2.3: å¼‚æ­¥Channel

**ç›®æ ‡**: æŒæ¡å¼‚æ­¥æ¶ˆæ¯ä¼ é€’

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
use tokio::sync::{mpsc, oneshot, broadcast};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== mpsc Channel =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        for i in 0..5 {
            tx.send(i).await.unwrap();
            println!("å‘é€: {}", i);
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    while let Some(value) = rx.recv().await {
        println!("æ¥æ”¶: {}", value);
    }
    
    println!("\n===== å¤šä¸ªç”Ÿäº§è€… =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    for i in 0..3 {
        let tx_clone = tx.clone();
        tokio::spawn(async move {
            for j in 0..3 {
                tx_clone.send(format!("Producer {} - {}", i, j)).await.unwrap();
                sleep(Duration::from_millis(50)).await;
            }
        });
    }
    
    drop(tx); // é‡Šæ”¾åŸå§‹å‘é€è€…
    
    while let Some(msg) = rx.recv().await {
        println!("æ¥æ”¶: {}", msg);
    }
    
    println!("\n===== oneshot Channel =====\n");
    
    let (tx, rx) = oneshot::channel();
    
    tokio::spawn(async move {
        sleep(Duration::from_secs(1)).await;
        tx.send("è®¡ç®—ç»“æœ: 42").unwrap();
    });
    
    println!("ç­‰å¾…ç»“æœ...");
    let result = rx.await.unwrap();
    println!("æ”¶åˆ°: {}", result);
    
    println!("\n===== broadcast Channel =====\n");
    
    let (tx, mut rx1) = broadcast::channel(16);
    let mut rx2 = tx.subscribe();
    let mut rx3 = tx.subscribe();
    
    tokio::spawn(async move {
        for i in 0..3 {
            tx.send(format!("å¹¿æ’­ {}", i)).unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    let handle1 = tokio::spawn(async move {
        while let Ok(msg) = rx1.recv().await {
            println!("æ¥æ”¶è€…1: {}", msg);
        }
    });
    
    let handle2 = tokio::spawn(async move {
        while let Ok(msg) = rx2.recv().await {
            println!("æ¥æ”¶è€…2: {}", msg);
        }
    });
    
    let handle3 = tokio::spawn(async move {
        while let Ok(msg) = rx3.recv().await {
            println!("æ¥æ”¶è€…3: {}", msg);
        }
    });
    
    handle1.await.unwrap();
    handle2.await.unwrap();
    handle3.await.unwrap();
    
    println!("\n===== try_recv éé˜»å¡ =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    match rx.try_recv() {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(mpsc::error::TryRecvError::Empty) => println!("é€šé“ä¸ºç©º"),
        Err(mpsc::error::TryRecvError::Disconnected) => println!("é€šé“å·²æ–­å¼€"),
    }
    
    tx.send("message").await.unwrap();
    
    match rx.try_recv() {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(_) => println!("é€šé“ä¸ºç©º"),
    }
    
    println!("\n===== ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ =====\n");
    
    let (tx, mut rx) = mpsc::channel(10);
    
    // å¤šä¸ªç”Ÿäº§è€…
    for i in 0..2 {
        let tx = tx.clone();
        tokio::spawn(async move {
            for j in 0..5 {
                tx.send(format!("Task {}-{}", i, j)).await.unwrap();
                sleep(Duration::from_millis(100)).await;
            }
        });
    }
    
    drop(tx);
    
    // å¤šä¸ªæ¶ˆè´¹è€…
    let mut handles = vec![];
    for i in 0..2 {
        let (worker_tx, mut worker_rx) = mpsc::channel(10);
        
        // åˆ†å‘ä»»åŠ¡
        tokio::spawn(async move {
            while let Some(task) = rx.recv().await {
                worker_tx.send(task).await.unwrap();
            }
        });
        
        let handle = tokio::spawn(async move {
            while let Some(task) = worker_rx.recv().await {
                println!("Worker {} å¤„ç†: {}", i, task);
                sleep(Duration::from_millis(50)).await;
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

**è¯´æ˜**:

- **mpsc**: å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…
- **oneshot**: ä¸€æ¬¡æ€§é€šé“
- **broadcast**: å¹¿æ’­é€šé“
- **éé˜»å¡**: try_recv ä¸ä¼šé˜»å¡

**è¾“å‡º**:

```text
===== mpsc Channel =====

å‘é€: 0
æ¥æ”¶: 0
å‘é€: 1
æ¥æ”¶: 1
å‘é€: 2
æ¥æ”¶: 2
å‘é€: 3
æ¥æ”¶: 3
å‘é€: 4
æ¥æ”¶: 4

===== å¤šä¸ªç”Ÿäº§è€… =====

æ¥æ”¶: Producer 0 - 0
æ¥æ”¶: Producer 1 - 0
æ¥æ”¶: Producer 2 - 0
...

===== oneshot Channel =====

ç­‰å¾…ç»“æœ...
æ”¶åˆ°: è®¡ç®—ç»“æœ: 42

===== broadcast Channel =====

æ¥æ”¶è€…1: å¹¿æ’­ 0
æ¥æ”¶è€…2: å¹¿æ’­ 0
æ¥æ”¶è€…3: å¹¿æ’­ 0
æ¥æ”¶è€…1: å¹¿æ’­ 1
æ¥æ”¶è€…2: å¹¿æ’­ 1
æ¥æ”¶è€…3: å¹¿æ’­ 1
...

===== try_recv éé˜»å¡ =====

é€šé“ä¸ºç©º
æ”¶åˆ°: message

===== ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ =====

Worker 0 å¤„ç†: Task 0-0
Worker 1 å¤„ç†: Task 1-0
...
```

---

### ç¤ºä¾‹2.4: å¼‚æ­¥é”å’ŒåŒæ­¥

**ç›®æ ‡**: æŒæ¡å¼‚æ­¥ç¯å¢ƒä¸‹çš„åŒæ­¥åŸè¯­

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
use tokio::sync::{Mutex, RwLock, Semaphore, Barrier};
use std::sync::Arc;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== å¼‚æ­¥ Mutex =====\n");
    
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = tokio::spawn(async move {
            let mut num = counter_clone.lock().await;
            *num += 1;
            println!("ä»»åŠ¡ {} å¢åŠ è®¡æ•°", i);
            sleep(Duration::from_millis(10)).await;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("æœ€ç»ˆè®¡æ•°: {}\n", *counter.lock().await);
    
    println!("===== å¼‚æ­¥ RwLock =====\n");
    
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // å¤šä¸ªè¯»è€…
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            let r = data_clone.read().await;
            println!("è¯»è€… {}: {:?}", i, *r);
            sleep(Duration::from_millis(100)).await;
        });
        handles.push(handle);
    }
    
    // ä¸€ä¸ªå†™è€…
    let data_clone = Arc::clone(&data);
    let handle = tokio::spawn(async move {
        sleep(Duration::from_millis(50)).await;
        let mut w = data_clone.write().await;
        w.push(4);
        println!("å†™è€…æ·»åŠ å…ƒç´ ");
    });
    handles.push(handle);
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("æœ€ç»ˆæ•°æ®: {:?}\n", *data.read().await);
    
    println!("===== Semaphore ä¿¡å·é‡ =====\n");
    
    let semaphore = Arc::new(Semaphore::new(3));
    let mut handles = vec![];
    
    for i in 0..10 {
        let semaphore_clone = Arc::clone(&semaphore);
        let handle = tokio::spawn(async move {
            let _permit = semaphore_clone.acquire().await.unwrap();
            println!("ä»»åŠ¡ {} è·å¾—è®¸å¯", i);
            sleep(Duration::from_millis(500)).await;
            println!("ä»»åŠ¡ {} é‡Šæ”¾è®¸å¯", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("\n===== Barrier å±éšœ =====\n");
    
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];
    
    for i in 0..3 {
        let barrier_clone = Arc::clone(&barrier);
        let handle = tokio::spawn(async move {
            println!("ä»»åŠ¡ {} å¼€å§‹å‡†å¤‡", i);
            sleep(Duration::from_millis(i * 100)).await;
            println!("ä»»åŠ¡ {} åˆ°è¾¾å±éšœ", i);
            barrier_clone.wait().await;
            println!("ä»»åŠ¡ {} é€šè¿‡å±éšœ", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("\n===== try_lock éé˜»å¡ =====\n");
    
    let mutex = Arc::new(Mutex::new(0));
    let mutex_clone = Arc::clone(&mutex);
    
    let handle = tokio::spawn(async move {
        let _lock = mutex_clone.lock().await;
        println!("ä»»åŠ¡æŒæœ‰é”");
        sleep(Duration::from_secs(2)).await;
    });
    
    sleep(Duration::from_millis(100)).await;
    
    match mutex.try_lock() {
        Ok(_) => println!("è·å¾—é”"),
        Err(_) => println!("é”è¢«å ç”¨ï¼Œä¸ç­‰å¾…"),
    }
    
    handle.await.unwrap();
    
    println!("\n===== æ­»é”é¿å… =====\n");
    
    let lock1 = Arc::new(Mutex::new(0));
    let lock2 = Arc::new(Mutex::new(0));
    
    let lock1_clone = Arc::clone(&lock1);
    let lock2_clone = Arc::clone(&lock2);
    
    tokio::spawn(async move {
        let _g1 = lock1_clone.lock().await;
        println!("ä»»åŠ¡1è·å¾—é”1");
        sleep(Duration::from_millis(10)).await;
        let _g2 = lock2_clone.lock().await;
        println!("ä»»åŠ¡1è·å¾—é”2");
    });
    
    tokio::spawn(async move {
        let _g1 = lock1.lock().await;
        println!("ä»»åŠ¡2è·å¾—é”1");
        sleep(Duration::from_millis(10)).await;
        let _g2 = lock2.lock().await;
        println!("ä»»åŠ¡2è·å¾—é”2");
    }).await.unwrap();
    
    println!("ä½¿ç”¨å›ºå®šé¡ºåºé¿å…æ­»é”");
}
```

**è¯´æ˜**:

- **å¼‚æ­¥Mutex**: å¯åœ¨`.await`ç‚¹æŒæœ‰
- **å¼‚æ­¥RwLock**: å¤šè¯»è€…å•å†™è€…
- **Semaphore**: é™åˆ¶å¹¶å‘æ•°
- **Barrier**: åŒæ­¥å¤šä¸ªä»»åŠ¡

**è¾“å‡º**:

```text
===== å¼‚æ­¥ Mutex =====

ä»»åŠ¡ 0 å¢åŠ è®¡æ•°
ä»»åŠ¡ 1 å¢åŠ è®¡æ•°
ä»»åŠ¡ 2 å¢åŠ è®¡æ•°
...
ä»»åŠ¡ 9 å¢åŠ è®¡æ•°
æœ€ç»ˆè®¡æ•°: 10

===== å¼‚æ­¥ RwLock =====

è¯»è€… 0: [1, 2, 3]
è¯»è€… 1: [1, 2, 3]
å†™è€…æ·»åŠ å…ƒç´ 
è¯»è€… 2: [1, 2, 3, 4]
...
æœ€ç»ˆæ•°æ®: [1, 2, 3, 4]

===== Semaphore ä¿¡å·é‡ =====

ä»»åŠ¡ 0 è·å¾—è®¸å¯
ä»»åŠ¡ 1 è·å¾—è®¸å¯
ä»»åŠ¡ 2 è·å¾—è®¸å¯
ä»»åŠ¡ 0 é‡Šæ”¾è®¸å¯
ä»»åŠ¡ 3 è·å¾—è®¸å¯
...

===== Barrier å±éšœ =====

ä»»åŠ¡ 0 å¼€å§‹å‡†å¤‡
ä»»åŠ¡ 1 å¼€å§‹å‡†å¤‡
ä»»åŠ¡ 2 å¼€å§‹å‡†å¤‡
ä»»åŠ¡ 0 åˆ°è¾¾å±éšœ
ä»»åŠ¡ 1 åˆ°è¾¾å±éšœ
ä»»åŠ¡ 2 åˆ°è¾¾å±éšœ
ä»»åŠ¡ 0 é€šè¿‡å±éšœ
ä»»åŠ¡ 1 é€šè¿‡å±éšœ
ä»»åŠ¡ 2 é€šè¿‡å±éšœ

===== try_lock éé˜»å¡ =====

ä»»åŠ¡æŒæœ‰é”
é”è¢«å ç”¨ï¼Œä¸ç­‰å¾…

===== æ­»é”é¿å… =====

ä»»åŠ¡1è·å¾—é”1
ä»»åŠ¡1è·å¾—é”2
ä»»åŠ¡2è·å¾—é”1
ä»»åŠ¡2è·å¾—é”2
ä½¿ç”¨å›ºå®šé¡ºåºé¿å…æ­»é”
```

---

## ğŸš€ Tier 3: é«˜çº§å±‚ç¤ºä¾‹

### ç¤ºä¾‹3.1: select!å®

**ç›®æ ‡**: æŒæ¡åŒæ—¶ç­‰å¾…å¤šä¸ªå¼‚æ­¥æ“ä½œ

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
use tokio::time::{sleep, Duration, timeout, interval};
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    println!("===== select! åŸºç¡€ =====\n");
    
    let res = tokio::select! {
        _ = sleep(Duration::from_secs(1)) => {
            "1ç§’è®¡æ—¶å™¨"
        }
        _ = sleep(Duration::from_secs(2)) => {
            "2ç§’è®¡æ—¶å™¨"
        }
    };
    
    println!("å®Œæˆ: {}", res);
    
    println!("\n===== Channel + select! =====\n");
    
    let (tx1, mut rx1) = mpsc::channel(32);
    let (tx2, mut rx2) = mpsc::channel(32);
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(100)).await;
        tx1.send("æ¥è‡ªé€šé“1").await.unwrap();
    });
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(200)).await;
        tx2.send("æ¥è‡ªé€šé“2").await.unwrap();
    });
    
    let res = tokio::select! {
        Some(msg) = rx1.recv() => format!("æ”¶åˆ°: {}", msg),
        Some(msg) = rx2.recv() => format!("æ”¶åˆ°: {}", msg),
    };
    
    println!("{}", res);
    
    println!("\n===== è¶…æ—¶æ§åˆ¶ =====\n");
    
    async fn long_task() {
        sleep(Duration::from_secs(3)).await;
    }
    
    let result = tokio::select! {
        _ = long_task() => "ä»»åŠ¡å®Œæˆ",
        _ = sleep(Duration::from_secs(1)) => "è¶…æ—¶",
    };
    
    println!("ç»“æœ: {}", result);
    
    println!("\n===== å¾ªç¯ä¸­çš„ select! =====\n");
    
    let (tx1, mut rx1) = mpsc::channel(32);
    let (tx2, mut rx2) = mpsc::channel(32);
    
    // ç”Ÿäº§è€…1
    tokio::spawn(async move {
        for i in 0..3 {
            tx1.send(format!("A{}", i)).await.unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    // ç”Ÿäº§è€…2
    tokio::spawn(async move {
        for i in 0..3 {
            tx2.send(format!("B{}", i)).await.unwrap();
            sleep(Duration::from_millis(150)).await;
        }
    });
    
    let mut count = 0;
    loop {
        tokio::select! {
            Some(msg) = rx1.recv() => {
                println!("ä»é€šé“1: {}", msg);
                count += 1;
            }
            Some(msg) = rx2.recv() => {
                println!("ä»é€šé“2: {}", msg);
                count += 1;
            }
            else => break,
        }
    }
    
    println!("æ¥æ”¶äº† {} æ¡æ¶ˆæ¯\n", count);
    
    println!("===== å¸¦æ¡ä»¶çš„åˆ†æ”¯ =====\n");
    
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        for i in 0..5 {
            tx.send(i).await.unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    let mut allow_timeout = true;
    
    loop {
        tokio::select! {
            Some(num) = rx.recv() => {
                println!("æ”¶åˆ°: {}", num);
                if num >= 3 {
                    allow_timeout = false;
                }
            }
            _ = sleep(Duration::from_millis(500)), if allow_timeout => {
                println!("å…è®¸è¶…æ—¶");
            }
            else => break,
        }
    }
    
    println!("\n===== interval å®šæ—¶å™¨ =====\n");
    
    let mut interval = interval(Duration::from_millis(200));
    let (tx, mut rx) = mpsc::channel(32);
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        tx.send("æ¶ˆæ¯").await.unwrap();
    });
    
    let mut tick_count = 0;
    
    loop {
        tokio::select! {
            _ = interval.tick() => {
                tick_count += 1;
                println!("Tick {}", tick_count);
                if tick_count >= 5 {
                    break;
                }
            }
            Some(msg) = rx.recv() => {
                println!("æ”¶åˆ°: {}", msg);
            }
        }
    }
    
    println!("\n===== biased é¡ºåºé€‰æ‹© =====\n");
    
    let (tx1, mut rx1) = mpsc::channel(32);
    let (tx2, mut rx2) = mpsc::channel(32);
    
    tx1.send("é«˜ä¼˜å…ˆçº§").await.unwrap();
    tx2.send("ä½ä¼˜å…ˆçº§").await.unwrap();
    
    tokio::select! {
        biased;
        
        Some(msg) = rx1.recv() => {
            println!("é€‰æ‹©: {}", msg);
        }
        Some(msg) = rx2.recv() => {
            println!("é€‰æ‹©: {}", msg);
        }
    }
    
    println!("\n===== å–æ¶ˆå®‰å…¨ =====\n");
    
    async fn cancellable_task() {
        for i in 0..10 {
            println!("å·¥ä½œä¸­... {}", i);
            sleep(Duration::from_millis(100)).await;
        }
    }
    
    tokio::select! {
        _ = cancellable_task() => {
            println!("ä»»åŠ¡å®Œæˆ");
        }
        _ = sleep(Duration::from_millis(350)) => {
            println!("ä»»åŠ¡è¢«å–æ¶ˆ");
        }
    }
}
```

**è¯´æ˜**:

- **select!**: åŒæ—¶ç­‰å¾…å¤šä¸ªå¼‚æ­¥æ“ä½œ
- **biased**: æŒ‰é¡ºåºæ£€æŸ¥åˆ†æ”¯
- **else**: æ‰€æœ‰åˆ†æ”¯éƒ½å®Œæˆæ—¶æ‰§è¡Œ
- **å–æ¶ˆ**: æœªé€‰ä¸­çš„åˆ†æ”¯è¢«å–æ¶ˆ

**è¾“å‡º**:

```text
===== select! åŸºç¡€ =====

å®Œæˆ: 1ç§’è®¡æ—¶å™¨

===== Channel + select! =====

æ”¶åˆ°: æ¥è‡ªé€šé“1

===== è¶…æ—¶æ§åˆ¶ =====

ç»“æœ: è¶…æ—¶

===== å¾ªç¯ä¸­çš„ select! =====

ä»é€šé“1: A0
ä»é€šé“1: A1
ä»é€šé“2: B0
ä»é€šé“1: A2
ä»é€šé“2: B1
ä»é€šé“2: B2
æ¥æ”¶äº† 6 æ¡æ¶ˆæ¯

===== å¸¦æ¡ä»¶çš„åˆ†æ”¯ =====

æ”¶åˆ°: 0
æ”¶åˆ°: 1
æ”¶åˆ°: 2
æ”¶åˆ°: 3
æ”¶åˆ°: 4

===== interval å®šæ—¶å™¨ =====

Tick 1
Tick 2
æ”¶åˆ°: æ¶ˆæ¯
Tick 3
Tick 4
Tick 5

===== biased é¡ºåºé€‰æ‹© =====

é€‰æ‹©: é«˜ä¼˜å…ˆçº§

===== å–æ¶ˆå®‰å…¨ =====

å·¥ä½œä¸­... 0
å·¥ä½œä¸­... 1
å·¥ä½œä¸­... 2
ä»»åŠ¡è¢«å–æ¶ˆ
```

---

### ç¤ºä¾‹3.2: Pinå’Œè‡ªå¼•ç”¨

**ç›®æ ‡**: ç†è§£Pinå’Œå†…å­˜å›ºå®š

**éš¾åº¦**: â­â­â­â­â­

**ä»£ç **:

```rust
use std::pin::Pin;
use std::marker::PhantomPinned;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("===== Pin åŸºç¡€ =====\n");
    
    let value = 42;
    let pinned = Pin::new(&value);
    
    println!("å›ºå®šå€¼: {}", *pinned);
    println!("Pin ä¿è¯åœ°å€ä¸å˜\n");
    
    println!("===== è‡ªå¼•ç”¨ç»“æ„ =====\n");
    
    struct SelfReferential {
        data: String,
        ptr: *const String,
        _pin: PhantomPinned,
    }
    
    impl SelfReferential {
        fn new(data: String) -> Pin<Box<Self>> {
            let mut boxed = Box::pin(SelfReferential {
                data,
                ptr: std::ptr::null(),
                _pin: PhantomPinned,
            });
            
            let ptr = &boxed.data as *const String;
            unsafe {
                let mut_ref = Pin::as_mut(&mut boxed);
                Pin::get_unchecked_mut(mut_ref).ptr = ptr;
            }
            
            boxed
        }
        
        fn get_data(&self) -> &str {
            &self.data
        }
        
        fn get_ptr_data(&self) -> &str {
            unsafe { &*self.ptr }
        }
    }
    
    let pinned = SelfReferential::new("Hello, Pin!".to_string());
    
    println!("æ•°æ®: {}", pinned.get_data());
    println!("é€šè¿‡æŒ‡é’ˆ: {}", pinned.get_ptr_data());
    println!("åœ°å€ç›¸åŒ: {}", std::ptr::eq(
        pinned.get_data(),
        pinned.get_ptr_data()
    ));
    
    println!("\n===== Unpin trait =====\n");
    
    fn requires_unpin<T: Unpin>(value: Pin<&T>) {
        println!("è¿™ä¸ªç±»å‹å®ç°äº† Unpin");
    }
    
    let value = 42;
    let pinned = Pin::new(&value);
    requires_unpin(pinned);
    
    println!("å¤§å¤šæ•°ç±»å‹è‡ªåŠ¨å®ç° Unpin\n");
    
    println!("===== Pin in async =====\n");
    
    use std::future::Future;
    use std::task::{Context, Poll};
    
    struct MyFuture {
        completed: bool,
    }
    
    impl Future for MyFuture {
        type Output = String;
        
        fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
            if self.completed {
                Poll::Ready("å®Œæˆ".to_string())
            } else {
                self.completed = true;
                Poll::Pending
            }
        }
    }
    
    let future = MyFuture { completed: false };
    let pinned_future = Box::pin(future);
    
    println!("Future éœ€è¦ Pin æ¥ä¿è¯å®‰å…¨");
    
    // æ‰‹åŠ¨è½®è¯¢
    let waker = futures::task::noop_waker();
    let mut context = std::task::Context::from_waker(&waker);
    
    let mut future = Box::pin(MyFuture { completed: false });
    
    match future.as_mut().poll(&mut context) {
        Poll::Ready(r) => println!("ç¬¬ä¸€æ¬¡è½®è¯¢: Ready({})", r),
        Poll::Pending => println!("ç¬¬ä¸€æ¬¡è½®è¯¢: Pending"),
    }
    
    match future.as_mut().poll(&mut context) {
        Poll::Ready(r) => println!("ç¬¬äºŒæ¬¡è½®è¯¢: Ready({})", r),
        Poll::Pending => println!("ç¬¬äºŒæ¬¡è½®è¯¢: Pending"),
    }
    
    println!("\n===== å®ç”¨ç¤ºä¾‹: å¼‚æ­¥ç”Ÿæˆå™¨æ¨¡æ‹Ÿ =====\n");
    
    struct AsyncGenerator {
        count: usize,
        max: usize,
        _pin: PhantomPinned,
    }
    
    impl AsyncGenerator {
        fn new(max: usize) -> Pin<Box<Self>> {
            Box::pin(AsyncGenerator {
                count: 0,
                max,
                _pin: PhantomPinned,
            })
        }
        
        async fn next(self: Pin<&mut Self>) -> Option<usize> {
            let this = unsafe { self.get_unchecked_mut() };
            
            if this.count >= this.max {
                return None;
            }
            
            let current = this.count;
            this.count += 1;
            
            sleep(Duration::from_millis(100)).await;
            Some(current)
        }
    }
    
    let mut gen = AsyncGenerator::new(5);
    
    while let Some(value) = gen.as_mut().next().await {
        println!("ç”Ÿæˆ: {}", value);
    }
    
    println!("\n===== Pin API =====\n");
    
    let value = String::from("data");
    let mut pinned = Box::pin(value);
    
    // Pin::as_ref
    let pin_ref: Pin<&String> = pinned.as_ref();
    println!("as_ref: {}", pin_ref);
    
    // Pin::as_mut
    let pin_mut: Pin<&mut String> = pinned.as_mut();
    println!("as_mut: {}", pin_mut);
    
    // Pin::get_ref (å¦‚æœæ˜¯ Unpin)
    let value_ref = Pin::get_ref(pinned.as_ref());
    println!("get_ref: {}", value_ref);
    
    println!("\n===== PhantomPinned ä½œç”¨ =====\n");
    
    // æ²¡æœ‰ PhantomPinned çš„ç±»å‹è‡ªåŠ¨å®ç° Unpin
    struct WithoutPin {
        data: String,
    }
    
    // æœ‰ PhantomPinned çš„ç±»å‹ä¸å®ç° Unpin
    struct WithPin {
        data: String,
        _pin: PhantomPinned,
    }
    
    println!("WithoutPin å¯ä»¥ç§»åŠ¨");
    println!("WithPin å›ºå®šåä¸å¯ç§»åŠ¨");
}
```

**è¯´æ˜**:

- **Pin**: é˜²æ­¢å€¼åœ¨å†…å­˜ä¸­ç§»åŠ¨
- **PhantomPinned**: æ ‡è®°ç±»å‹ä¸å®ç°Unpin
- **è‡ªå¼•ç”¨**: å®‰å…¨åœ°åˆ›å»ºè‡ªå¼•ç”¨ç»“æ„
- **Futureè½®è¯¢**: Pinä¿è¯Futureçš„å®‰å…¨æ€§

**è¾“å‡º**:

```text
===== Pin åŸºç¡€ =====

å›ºå®šå€¼: 42
Pin ä¿è¯åœ°å€ä¸å˜

===== è‡ªå¼•ç”¨ç»“æ„ =====

æ•°æ®: Hello, Pin!
é€šè¿‡æŒ‡é’ˆ: Hello, Pin!
åœ°å€ç›¸åŒ: true

===== Unpin trait =====

è¿™ä¸ªç±»å‹å®ç°äº† Unpin
å¤§å¤šæ•°ç±»å‹è‡ªåŠ¨å®ç° Unpin

===== Pin in async =====

Future éœ€è¦ Pin æ¥ä¿è¯å®‰å…¨
ç¬¬ä¸€æ¬¡è½®è¯¢: Pending
ç¬¬äºŒæ¬¡è½®è¯¢: Ready(å®Œæˆ)

===== å®ç”¨ç¤ºä¾‹: å¼‚æ­¥ç”Ÿæˆå™¨æ¨¡æ‹Ÿ =====

ç”Ÿæˆ: 0
ç”Ÿæˆ: 1
ç”Ÿæˆ: 2
ç”Ÿæˆ: 3
ç”Ÿæˆ: 4

===== Pin API =====

as_ref: data
as_mut: data
get_ref: data

===== PhantomPinned ä½œç”¨ =====

WithoutPin å¯ä»¥ç§»åŠ¨
WithPin å›ºå®šåä¸å¯ç§»åŠ¨
```

---

## ğŸ“ æ€»ç»“

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **ç¬¬ä¸€é˜¶æ®µ** (Tier 1): æŒæ¡åŸºç¡€ (ç¤ºä¾‹ 1.1-1.4)
   - async/await è¯­æ³•
   - Future trait
   - tokio è¿è¡Œæ—¶
   - å¼‚æ­¥ä»»åŠ¡

2. **ç¬¬äºŒé˜¶æ®µ** (Tier 2): å®è·µåº”ç”¨ (ç¤ºä¾‹ 2.1-2.4)
   - å¼‚æ­¥æ–‡ä»¶ I/O
   - å¼‚æ­¥ç½‘ç»œç¼–ç¨‹
   - å¼‚æ­¥ Channel
   - å¼‚æ­¥é”

3. **ç¬¬ä¸‰é˜¶æ®µ** (Tier 3): æ·±å…¥ç†è§£ (ç¤ºä¾‹ 3.1-3.2)
   - select! å®
   - Pin å’Œè‡ªå¼•ç”¨

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ | ç›¸å…³ç¤ºä¾‹ | é‡è¦æ€§ | éš¾åº¦ |
|------|---------|--------|------|
| async/await | 1.1 | â­â­â­â­â­ | â­ |
| Future | 1.2 | â­â­â­â­ | â­â­ |
| tokioè¿è¡Œæ—¶ | 1.3 | â­â­â­â­â­ | â­ |
| spawn | 1.4 | â­â­â­â­â­ | â­â­ |
| å¼‚æ­¥I/O | 2.1 | â­â­â­â­ | â­â­ |

### æœ€ä½³å®è·µ

1. **é€‰æ‹©è¿è¡Œæ—¶**:
   - ä¸€èˆ¬åº”ç”¨ï¼štokio
   - åµŒå…¥å¼ï¼šembassy
   - ç®€å•åœºæ™¯ï¼šasync-std

2. **ä»»åŠ¡ç®¡ç†**:
   - CPU å¯†é›†ï¼šspawn_blocking
   - I/O å¯†é›†ï¼štokio::spawn
   - æ‰¹é‡ä»»åŠ¡ï¼šJoinSet

3. **é”™è¯¯å¤„ç†**:
   - ä½¿ç”¨ Result
   - ? æ“ä½œç¬¦
   - æ£€æŸ¥ JoinHandle

4. **æ€§èƒ½ä¼˜åŒ–**:
   - é¿å…é˜»å¡è°ƒç”¨
   - ä½¿ç”¨ç¼“å†² I/O
   - åˆç†é…ç½®è¿è¡Œæ—¶

### ä¸‹ä¸€æ­¥

- ğŸ“– æ·±å…¥å­¦ä¹ : [Futureä¸Executoræœºåˆ¶](./02_Futureä¸Executoræœºåˆ¶.md)
- ğŸ“– æ·±å…¥å­¦ä¹ : [å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©æŒ‡å—](./03_å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©æŒ‡å—.md)
- ğŸš€ å®æˆ˜é¡¹ç›®: [C06 å®æˆ˜é¡¹ç›®é›†](./08_å®æˆ˜é¡¹ç›®é›†.md) (å³å°†åˆ›å»º)
- ğŸ“š å‚è€ƒæ–‡æ¡£: [tier_03_references](../tier_03_references/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25  
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ’¡ å¼‚æ­¥ç¼–ç¨‹æ˜¯ Rust çš„å¼ºå¤§ç‰¹æ€§ï¼ŒæŒæ¡å®ƒèƒ½æ„å»ºé«˜æ€§èƒ½çš„å¹¶å‘åº”ç”¨ï¼ğŸ¦€**-
