# âš¡ C06: Async Programming - å®æˆ˜é¡¹ç›®é›†

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C06 å¼‚æ­¥ç¼–ç¨‹
> **ç›®æ ‡**: é€šè¿‡å®æˆ˜é¡¹ç›®æŒæ¡å¼‚æ­¥ç¼–ç¨‹å’Œ tokio è¿è¡Œæ—¶

---

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

| # | é¡¹ç›®åç§° | éš¾åº¦ | é¢„è®¡æ—¶é—´ | æ ¸å¿ƒæ¦‚å¿µ |
|---|----------|------|---------|---------|
| 1 | [å¼‚æ­¥æ–‡ä»¶æ‰¹å¤„ç†](#é¡¹ç›®1-å¼‚æ­¥æ–‡ä»¶æ‰¹å¤„ç†) | â­ | 1-2å°æ—¶ | async/awaitã€tokio::fs |
| 2 | [å¼‚æ­¥ HTTP å®¢æˆ·ç«¯](#é¡¹ç›®2-å¼‚æ­¥-http-å®¢æˆ·ç«¯) | â­â­ | 2-3å°æ—¶ | reqwestã€å¹¶å‘è¯·æ±‚ |
| 3 | [å¼‚æ­¥ä»»åŠ¡è°ƒåº¦å™¨](#é¡¹ç›®3-å¼‚æ­¥ä»»åŠ¡è°ƒåº¦å™¨) | â­â­â­ | 3-4å°æ—¶ | tokio::spawnã€JoinSet |

---

## é¡¹ç›®1: å¼‚æ­¥æ–‡ä»¶æ‰¹å¤„ç†

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­
**é¢„è®¡æ—¶é—´**: 1-2å°æ—¶

### æ ¸å¿ƒä»£ç 

```rust
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::path::Path;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== å¼‚æ­¥æ–‡ä»¶æ‰¹å¤„ç† =====\n");

    // æ‰¹é‡è¯»å–æ–‡ä»¶
    let files = vec!["file1.txt", "file2.txt", "file3.txt"];

    let mut handles = vec![];

    for file in files {
        let handle = tokio::spawn(async move {
            match fs::read_to_string(file).await {
                Ok(content) => {
                    println!("ğŸ“– è¯»å– {}: {} å­—èŠ‚", file, content.len());
                    Some(content)
                }
                Err(e) => {
                    println!("âŒ è¯»å– {} å¤±è´¥: {}", file, e);
                    None
                }
            }
        });
        handles.push(handle);
    }

    let mut contents = Vec::new();
    for handle in handles {
        if let Some(content) = handle.await? {
            contents.push(content);
        }
    }

    // åˆå¹¶å†…å®¹
    let merged = contents.join("\n");

    // å†™å…¥è¾“å‡ºæ–‡ä»¶
    fs::write("output.txt", merged).await?;
    println!("\nâœ… åˆå¹¶å®Œæˆ: output.txt");

    Ok(())
}
```

---

## é¡¹ç›®2: å¼‚æ­¥ HTTP å®¢æˆ·ç«¯

### ğŸ“– é¡¹ç›®è¯´æ˜2

**éš¾åº¦**: â­â­
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶

### æ ¸å¿ƒä»£ç 2

```rust
use tokio;
use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== å¼‚æ­¥ HTTP å®¢æˆ·ç«¯ =====\n");

    let urls = vec![
        "https://api.github.com/users/rust-lang",
        "https://api.github.com/users/tokio-rs",
        "https://api.github.com/users/serde-rs",
    ];

    // å¹¶å‘è¯·æ±‚
    let mut handles = vec![];

    for url in urls {
        let handle = tokio::spawn(async move {
            println!("ğŸ“¡ è¯·æ±‚: {}", url);

            match reqwest::get(url).await {
                Ok(resp) => {
                    match resp.text().await {
                        Ok(body) => {
                            println!("âœ… å“åº”: {} å­—èŠ‚", body.len());
                            Some(body)
                        }
                        Err(e) => {
                            println!("âŒ è¯»å–å“åº”å¤±è´¥: {}", e);
                            None
                        }
                    }
                }
                Err(e) => {
                    println!("âŒ è¯·æ±‚å¤±è´¥: {}", e);
                    None
                }
            }
        });

        handles.push(handle);
    }

    // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    let mut responses = Vec::new();
    for handle in handles {
        if let Some(body) = handle.await? {
            responses.push(body);
        }
    }

    println!("\næ”¶åˆ° {} ä¸ªå“åº”", responses.len());

    Ok(())
}
```

---

## é¡¹ç›®3: å¼‚æ­¥ä»»åŠ¡è°ƒåº¦å™¨

### ğŸ“– é¡¹ç›®è¯´æ˜3

**éš¾åº¦**: â­â­â­
**é¢„è®¡æ—¶é—´**: 3-4å°æ—¶

### æ ¸å¿ƒä»£ç 3

```rust
use tokio;
use tokio::time::{sleep, Duration};
use tokio::task::JoinSet;
use std::sync::Arc;
use tokio::sync::Mutex;

struct Scheduler {
    tasks: Arc<Mutex<Vec<Task>>>,
}

struct Task {
    id: usize,
    name: String,
    duration: Duration,
}

impl Scheduler {
    fn new() -> Self {
        Scheduler {
            tasks: Arc::new(Mutex::new(Vec::new())),
        }
    }

    async fn add_task(&self, id: usize, name: String, duration: Duration) {
        let mut tasks = self.tasks.lock().await;
        tasks.push(Task { id, name, duration });
        println!("ğŸ“ æ·»åŠ ä»»åŠ¡: {} ({}ç§’)", name, duration.as_secs());
    }

    async fn run(&self) {
        let tasks = self.tasks.lock().await.clone();

        let mut set = JoinSet::new();

        for task in tasks {
            set.spawn(async move {
                println!("ğŸš€ å¯åŠ¨ä»»åŠ¡: {}", task.name);
                sleep(task.duration).await;
                println!("âœ… å®Œæˆä»»åŠ¡: {}", task.name);
                task.id
            });
        }

        while let Some(result) = set.join_next().await {
            match result {
                Ok(id) => println!("ä»»åŠ¡ {} å·²å®Œæˆ", id),
                Err(e) => println!("ä»»åŠ¡é”™è¯¯: {:?}", e),
            }
        }
    }
}

#[tokio::main]
async fn main() {
    println!("===== å¼‚æ­¥ä»»åŠ¡è°ƒåº¦å™¨ =====\n");

    let scheduler = Scheduler::new();

    scheduler.add_task(1, "ä»»åŠ¡A".to_string(), Duration::from_secs(2)).await;
    scheduler.add_task(2, "ä»»åŠ¡B".to_string(), Duration::from_secs(1)).await;
    scheduler.add_task(3, "ä»»åŠ¡C".to_string(), Duration::from_secs(3)).await;

    println!("\nå¼€å§‹æ‰§è¡Œ...\n");
    scheduler.run().await;

    println!("\næ‰€æœ‰ä»»åŠ¡å®Œæˆï¼");
}
```

---

## ğŸ“ æ€»ç»“

### å…³é”®æ¦‚å¿µ

| æ¦‚å¿µ | é¡¹ç›®1 | é¡¹ç›®2 | é¡¹ç›®3 |
|------|-------|-------|-------|
| async/await | âœ…âœ…âœ… | âœ…âœ…âœ… | âœ…âœ…âœ… |
| tokio::spawn | âœ…âœ… | âœ…âœ…âœ… | âœ…âœ…âœ… |
| å¼‚æ­¥ I/O | âœ…âœ…âœ… | âœ…âœ… | âŒ |
| å¹¶å‘æ§åˆ¶ | âœ…âœ… | âœ…âœ…âœ… | âœ…âœ…âœ… |
| JoinSet | âŒ | âŒ | âœ…âœ…âœ… |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25

**ğŸ¯ æŒæ¡å¼‚æ­¥ç¼–ç¨‹ï¼Œæ„å»ºé«˜æ€§èƒ½ I/O åº”ç”¨ï¼ğŸ¦€**-
