# ⚡ C06: Async Programming - 实战项目集

> **创建日期**: 2025-10-25
> **文档版本**: v1.0
> **适用模块**: C06 异步编程
> **目标**: 通过实战项目掌握异步编程和 tokio 运行时

---

## 📋 项目概览

| # | 项目名称 | 难度 | 预计时间 | 核心概念 |
|---|----------|------|---------|---------|
| 1 | [异步文件批处理](#项目1-异步文件批处理) | ⭐ | 1-2小时 | async/await、tokio::fs |
| 2 | [异步 HTTP 客户端](#项目2-异步-http-客户端) | ⭐⭐ | 2-3小时 | reqwest、并发请求 |
| 3 | [异步任务调度器](#项目3-异步任务调度器) | ⭐⭐⭐ | 3-4小时 | tokio::spawn、JoinSet |

---

## 项目1: 异步文件批处理

### 📖 项目说明

**难度**: ⭐
**预计时间**: 1-2小时

### 核心代码

```rust
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::path::Path;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 异步文件批处理 =====\n");

    // 批量读取文件
    let files = vec!["file1.txt", "file2.txt", "file3.txt"];

    let mut handles = vec![];

    for file in files {
        let handle = tokio::spawn(async move {
            match fs::read_to_string(file).await {
                Ok(content) => {
                    println!("📖 读取 {}: {} 字节", file, content.len());
                    Some(content)
                }
                Err(e) => {
                    println!("❌ 读取 {} 失败: {}", file, e);
                    None
                }
            }
        });
        handles.push(handle);
    }

    let mut contents = Vec::new();
    for handle in handles {
        if let Some(content) = handle.await? {
            contents.push(content);
        }
    }

    // 合并内容
    let merged = contents.join("\n");

    // 写入输出文件
    fs::write("output.txt", merged).await?;
    println!("\n✅ 合并完成: output.txt");

    Ok(())
}
```

---

## 项目2: 异步 HTTP 客户端

### 📖 项目说明2

**难度**: ⭐⭐
**预计时间**: 2-3小时

### 核心代码2

```rust
use tokio;
use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("===== 异步 HTTP 客户端 =====\n");

    let urls = vec![
        "https://api.github.com/users/rust-lang",
        "https://api.github.com/users/tokio-rs",
        "https://api.github.com/users/serde-rs",
    ];

    // 并发请求
    let mut handles = vec![];

    for url in urls {
        let handle = tokio::spawn(async move {
            println!("📡 请求: {}", url);

            match reqwest::get(url).await {
                Ok(resp) => {
                    match resp.text().await {
                        Ok(body) => {
                            println!("✅ 响应: {} 字节", body.len());
                            Some(body)
                        }
                        Err(e) => {
                            println!("❌ 读取响应失败: {}", e);
                            None
                        }
                    }
                }
                Err(e) => {
                    println!("❌ 请求失败: {}", e);
                    None
                }
            }
        });

        handles.push(handle);
    }

    // 等待所有请求完成
    let mut responses = Vec::new();
    for handle in handles {
        if let Some(body) = handle.await? {
            responses.push(body);
        }
    }

    println!("\n收到 {} 个响应", responses.len());

    Ok(())
}
```

---

## 项目3: 异步任务调度器

### 📖 项目说明3

**难度**: ⭐⭐⭐
**预计时间**: 3-4小时

### 核心代码3

```rust
use tokio;
use tokio::time::{sleep, Duration};
use tokio::task::JoinSet;
use std::sync::Arc;
use tokio::sync::Mutex;

struct Scheduler {
    tasks: Arc<Mutex<Vec<Task>>>,
}

struct Task {
    id: usize,
    name: String,
    duration: Duration,
}

impl Scheduler {
    fn new() -> Self {
        Scheduler {
            tasks: Arc::new(Mutex::new(Vec::new())),
        }
    }

    async fn add_task(&self, id: usize, name: String, duration: Duration) {
        let mut tasks = self.tasks.lock().await;
        tasks.push(Task { id, name, duration });
        println!("📝 添加任务: {} ({}秒)", name, duration.as_secs());
    }

    async fn run(&self) {
        let tasks = self.tasks.lock().await.clone();

        let mut set = JoinSet::new();

        for task in tasks {
            set.spawn(async move {
                println!("🚀 启动任务: {}", task.name);
                sleep(task.duration).await;
                println!("✅ 完成任务: {}", task.name);
                task.id
            });
        }

        while let Some(result) = set.join_next().await {
            match result {
                Ok(id) => println!("任务 {} 已完成", id),
                Err(e) => println!("任务错误: {:?}", e),
            }
        }
    }
}

#[tokio::main]
async fn main() {
    println!("===== 异步任务调度器 =====\n");

    let scheduler = Scheduler::new();

    scheduler.add_task(1, "任务A".to_string(), Duration::from_secs(2)).await;
    scheduler.add_task(2, "任务B".to_string(), Duration::from_secs(1)).await;
    scheduler.add_task(3, "任务C".to_string(), Duration::from_secs(3)).await;

    println!("\n开始执行...\n");
    scheduler.run().await;

    println!("\n所有任务完成！");
}
```

---

## 📝 总结

### 关键概念

| 概念 | 项目1 | 项目2 | 项目3 |
|------|-------|-------|-------|
| async/await | ✅✅✅ | ✅✅✅ | ✅✅✅ |
| tokio::spawn | ✅✅ | ✅✅✅ | ✅✅✅ |
| 异步 I/O | ✅✅✅ | ✅✅ | ❌ |
| 并发控制 | ✅✅ | ✅✅✅ | ✅✅✅ |
| JoinSet | ❌ | ❌ | ✅✅✅ |

---

**文档版本**: v1.0
**创建日期**: 2025-10-25

**🎯 掌握异步编程，构建高性能 I/O 应用！🦀**-
