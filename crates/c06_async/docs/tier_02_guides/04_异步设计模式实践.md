# Tier 2: å¼‚æ­¥è®¾è®¡æ¨¡å¼å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 2 - å®è·µæŒ‡å— | **é¢„è®¡é˜…è¯»**: 25 åˆ†é’Ÿ

---

## ğŸ¯ æœ¬ç« ç›®æ ‡

æŒæ¡å¸¸è§çš„å¼‚æ­¥è®¾è®¡æ¨¡å¼ï¼Œæå‡ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§ã€‚

**å­¦ä¹ æˆæœ**:

- âœ… ç†è§£ Actorã€Reactorã€CSP ç­‰å¹¶å‘æ¨¡å¼
- âœ… æŒæ¡ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†
- âœ… å­¦ä¼šä¼˜é›…å…³é—­å’Œé”™è¯¯ä¼ æ’­
- âœ… å®è·µèƒŒå‹å’Œæµé‡æ§åˆ¶

---

## 1. æ ¸å¿ƒè®¾è®¡æ¨¡å¼

### 1.1 Actor æ¨¡å¼

**æ¦‚å¿µ**: æ¯ä¸ª Actor æ‹¥æœ‰ç§æœ‰çŠ¶æ€ï¼Œé€šè¿‡æ¶ˆæ¯é€šä¿¡ã€‚

```rust
use tokio::sync::mpsc;

struct Counter {
    count: u32,
    rx: mpsc::Receiver<CounterMsg>,
}

enum CounterMsg {
    Increment,
    GetCount(mpsc::Sender<u32>),
}

impl Counter {
    fn new() -> (Self, mpsc::Sender<CounterMsg>) {
        let (tx, rx) = mpsc::channel(100);
        (Self { count: 0, rx }, tx)
    }
    
    async fn run(mut self) {
        while let Some(msg) = self.rx.recv().await {
            match msg {
                CounterMsg::Increment => self.count += 1,
                CounterMsg::GetCount(reply) => {
                    let _ = reply.send(self.count).await;
                }
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let (counter, tx) = Counter::new();
    
    // å¯åŠ¨ Actor
    tokio::spawn(counter.run());
    
    // å‘é€æ¶ˆæ¯
    tx.send(CounterMsg::Increment).await.unwrap();
    
    let (reply_tx, mut reply_rx) = mpsc::channel(1);
    tx.send(CounterMsg::GetCount(reply_tx)).await.unwrap();
    
    let count = reply_rx.recv().await.unwrap();
    println!("Count: {}", count);
}
```

---

### 1.2 Reactor æ¨¡å¼

**æ¦‚å¿µ**: äº‹ä»¶å¾ªç¯ï¼Œç­‰å¾…äº‹ä»¶å¹¶åˆ†å‘å¤„ç†ã€‚

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn handle_client(mut socket: TcpStream) {
    let mut buf = vec![0; 1024];
    
    loop {
        match socket.read(&mut buf).await {
            Ok(0) => break, // è¿æ¥å…³é—­
            Ok(n) => {
                // Echo back
                if socket.write_all(&buf[..n]).await.is_err() {
                    break;
                }
            }
            Err(_) => break,
        }
    }
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    
    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(handle_client(socket));
    }
}
```

---

### 1.3 CSP (Communicating Sequential Processes)

**æ¦‚å¿µ**: é€šè¿‡é€šé“è¿›è¡Œé€šä¿¡ï¼Œä¸å…±äº«å†…å­˜ã€‚

```rust
use tokio::sync::mpsc;

async fn producer(tx: mpsc::Sender<i32>) {
    for i in 0..10 {
        tx.send(i).await.unwrap();
    }
}

async fn consumer(mut rx: mpsc::Receiver<i32>) {
    while let Some(val) = rx.recv().await {
        println!("Received: {}", val);
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(100);
    
    tokio::join!(
        producer(tx),
        consumer(rx),
    );
}
```

---

## 2. ç»“æ„åŒ–å¹¶å‘

### 2.1 JoinSet - ä»»åŠ¡ç»„ç®¡ç†

```rust
use tokio::task::JoinSet;

#[tokio::main]
async fn main() {
    let mut set = JoinSet::new();
    
    // æ·»åŠ ä»»åŠ¡
    for i in 0..10 {
        set.spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(100 * i)).await;
            i
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    while let Some(result) = set.join_next().await {
        match result {
            Ok(val) => println!("Task completed: {}", val),
            Err(e) => eprintln!("Task failed: {}", e),
        }
    }
}
```

---

### 2.2 Select - å¤šè·¯é€‰æ‹©

```rust
use tokio::sync::mpsc;
use tokio::select;

#[tokio::main]
async fn main() {
    let (tx1, mut rx1) = mpsc::channel(10);
    let (tx2, mut rx2) = mpsc::channel(10);
    
    tokio::spawn(async move {
        tx1.send("from channel 1").await.unwrap();
    });
    
    tokio::spawn(async move {
        tx2.send("from channel 2").await.unwrap();
    });
    
    select! {
        msg = rx1.recv() => println!("rx1: {:?}", msg),
        msg = rx2.recv() => println!("rx2: {:?}", msg),
    }
}
```

---

## 3. ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 3.1 ä¼˜é›…å…³é—­

```rust
use tokio::sync::broadcast;
use tokio::signal;

async fn worker(id: usize, mut shutdown: broadcast::Receiver<()>) {
    loop {
        tokio::select! {
            _ = shutdown.recv() => {
                println!("Worker {} shutting down", id);
                break;
            }
            _ = tokio::time::sleep(tokio::time::Duration::from_secs(1)) => {
                println!("Worker {} working", id);
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let (shutdown_tx, _) = broadcast::channel(1);
    
    // å¯åŠ¨ workers
    let mut handles = vec![];
    for i in 0..3 {
        let rx = shutdown_tx.subscribe();
        handles.push(tokio::spawn(worker(i, rx)));
    }
    
    // ç­‰å¾… Ctrl+C
    signal::ctrl_c().await.unwrap();
    println!("Shutting down...");
    
    // å‘é€å…³é—­ä¿¡å·
    let _ = shutdown_tx.send(());
    
    // ç­‰å¾…æ‰€æœ‰ workers
    for handle in handles {
        let _ = handle.await;
    }
}
```

---

### 3.2 ä»»åŠ¡å–æ¶ˆ

```rust
use tokio_util::sync::CancellationToken;

async fn long_running_task(token: CancellationToken) {
    loop {
        tokio::select! {
            _ = token.cancelled() => {
                println!("Task cancelled");
                break;
            }
            _ = tokio::time::sleep(tokio::time::Duration::from_millis(100)) => {
                println!("Working...");
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let token = CancellationToken::new();
    let child_token = token.child_token();
    
    let handle = tokio::spawn(long_running_task(child_token));
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    token.cancel();
    
    handle.await.unwrap();
}
```

---

## 4. é”™è¯¯å¤„ç†æ¨¡å¼

### 4.1 é”™è¯¯ä¼ æ’­

```rust
use anyhow::{Context, Result};

async fn fetch_user(id: u64) -> Result<String> {
    Ok(format!("User {}", id))
}

async fn fetch_profile(user: &str) -> Result<String> {
    Ok(format!("Profile of {}", user))
}

async fn get_user_info(id: u64) -> Result<String> {
    let user = fetch_user(id)
        .await
        .context("Failed to fetch user")?;
    
    let profile = fetch_profile(&user)
        .await
        .context("Failed to fetch profile")?;
    
    Ok(format!("{} - {}", user, profile))
}

#[tokio::main]
async fn main() {
    match get_user_info(1).await {
        Ok(info) => println!("{}", info),
        Err(e) => eprintln!("Error: {:?}", e),
    }
}
```

---

### 4.2 é‡è¯•æ¨¡å¼

```rust
use tokio::time::{sleep, Duration};

async fn retry_operation<F, Fut, T, E>(
    mut operation: F,
    max_attempts: usize,
    delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Fut,
    Fut: std::future::Future<Output = Result<T, E>>,
{
    for attempt in 1..=max_attempts {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempt == max_attempts => return Err(e),
            Err(_) => {
                sleep(delay * attempt as u32).await;
            }
        }
    }
    unreachable!()
}

#[tokio::main]
async fn main() {
    let result = retry_operation(
        || async {
            // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
            Err::<(), &str>("Failed")
        },
        3,
        Duration::from_millis(100),
    ).await;
    
    println!("Result: {:?}", result);
}
```

---

## 5. æµé‡æ§åˆ¶

### 5.1 èƒŒå‹ (Backpressure)

```rust
use tokio::sync::mpsc;

async fn producer_with_backpressure(tx: mpsc::Sender<i32>) {
    for i in 0..100 {
        // send() ä¼šåœ¨é€šé“æ»¡æ—¶ç­‰å¾…
        match tx.send(i).await {
            Ok(_) => println!("Sent: {}", i),
            Err(_) => {
                println!("Receiver dropped");
                break;
            }
        }
    }
}

async fn slow_consumer(mut rx: mpsc::Receiver<i32>) {
    while let Some(val) = rx.recv().await {
        // æ¨¡æ‹Ÿæ…¢é€Ÿå¤„ç†
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        println!("Processed: {}", val);
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10); // é™åˆ¶ç¼“å†²åŒºå¤§å°
    
    tokio::join!(
        producer_with_backpressure(tx),
        slow_consumer(rx),
    );
}
```

---

### 5.2 é€Ÿç‡é™åˆ¶

```rust
use tokio::time::{interval, Duration};

async fn rate_limited_task() {
    let mut interval = interval(Duration::from_millis(100));
    
    for i in 0..10 {
        interval.tick().await;
        println!("Task {} at {:?}", i, std::time::Instant::now());
    }
}

#[tokio::main]
async fn main() {
    rate_limited_task().await;
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 è®¾è®¡åŸåˆ™

1. **ä¼˜å…ˆä½¿ç”¨é€šé“**: é¿å…å…±äº«çŠ¶æ€
2. **ç»“æ„åŒ–å¹¶å‘**: ä½¿ç”¨ JoinSet ç®¡ç†ä»»åŠ¡ç»„
3. **ä¼˜é›…å…³é—­**: æ­£ç¡®å¤„ç†ä¿¡å·å’Œæ¸…ç†
4. **é”™è¯¯ä¼ æ’­**: ä½¿ç”¨ `?` å’Œ `Context`
5. **èƒŒå‹æ§åˆ¶**: é™åˆ¶ç¼“å†²åŒºå¤§å°

### 6.2 å¸¸è§é™·é˜±

âŒ **è¿‡åº¦ä½¿ç”¨ `Arc<Mutex>`**:

```rust
// ä¸æ¨è
let counter = Arc::new(Mutex::new(0));
```

âœ… **ä½¿ç”¨é€šé“æˆ– Actor**:

```rust
// æ¨è
let (tx, rx) = mpsc::channel(100);
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- **[Futureä¸Executoræœºåˆ¶](./02_Futureä¸Executoræœºåˆ¶.md)** - ç†è§£åŸç†
- **[å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–æŒ‡å—](./05_å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md)** - æ€§èƒ½è°ƒä¼˜
- **[å¼‚æ­¥è°ƒè¯•ä¸ç›‘æ§](./06_å¼‚æ­¥è°ƒè¯•ä¸ç›‘æ§.md)** - è°ƒè¯•æŠ€å·§

---

## ğŸ“ æ€»ç»“

**æ ¸å¿ƒæ¨¡å¼**:

- âœ… **Actor**: æ¶ˆæ¯é©±åŠ¨çš„çŠ¶æ€éš”ç¦»
- âœ… **Reactor**: äº‹ä»¶å¾ªç¯å’Œåˆ†å‘
- âœ… **CSP**: é€šé“é€šä¿¡
- âœ… **ç»“æ„åŒ–å¹¶å‘**: JoinSet å’Œ Select

**å…³é”®æŠ€æœ¯**:

- âœ… ä¼˜é›…å…³é—­å’Œä»»åŠ¡å–æ¶ˆ
- âœ… é”™è¯¯ä¼ æ’­å’Œé‡è¯•
- âœ… èƒŒå‹å’Œé€Ÿç‡é™åˆ¶

---

**æ–‡æ¡£ç»´æŠ¤**: C06 Async Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **Rust ç‰ˆæœ¬**: 1.90+
