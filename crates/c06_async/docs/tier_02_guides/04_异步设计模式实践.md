# Tier 2: 异步设计模式实践

> **文档版本**: Rust 1.92.0+ | **更新日期**: 2025-12-11
> **文档层级**: Tier 2 - 实践指南 | **预计阅读**: 25 分钟

---

## 📋 目录

- [Tier 2: 异步设计模式实践](#tier-2-异步设计模式实践)
  - [📋 目录](#-目录)
  - [🎯 本章目标](#-本章目标)
  - [1. 核心设计模式](#1-核心设计模式)
    - [1.1 Actor 模式](#11-actor-模式)
    - [1.2 Reactor 模式](#12-reactor-模式)
    - [1.3 CSP (Communicating Sequential Processes)](#13-csp-communicating-sequential-processes)
  - [2. 结构化并发](#2-结构化并发)
    - [2.1 JoinSet - 任务组管理](#21-joinset---任务组管理)
    - [2.2 Select - 多路选择](#22-select---多路选择)
  - [3. 生命周期管理](#3-生命周期管理)
    - [3.1 优雅关闭](#31-优雅关闭)
    - [3.2 任务取消](#32-任务取消)
  - [4. 错误处理模式](#4-错误处理模式)
    - [4.1 错误传播](#41-错误传播)
    - [4.2 重试模式](#42-重试模式)
  - [5. 流量控制](#5-流量控制)
    - [5.1 背压 (Backpressure)](#51-背压-backpressure)
    - [5.2 速率限制](#52-速率限制)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 设计原则](#61-设计原则)
    - [6.2 常见陷阱](#62-常见陷阱)
  - [📚 延伸阅读](#-延伸阅读)
  - [📝 总结](#-总结)

## 📐 知识结构

### 概念定义

**异步设计模式 (Async Design Patterns)**:

- **定义**: 在异步编程中使用的设计模式，用于组织和管理异步代码
- **类型**: 设计模式
- **范畴**: 异步编程、软件设计
- **版本**: Rust 1.39+
- **相关概念**: Actor模式、Reactor模式、CSP、结构化并发

**Actor 模式**:

- **定义**: 每个 Actor 拥有私有状态，通过消息通信的并发模式
- **类型**: 并发模式
- **属性**: 消息传递、状态封装、并发安全
- **关系**: 与消息传递、并发编程相关

### 属性特征

**核心属性**:

- **Actor**: 私有状态、消息通信、并发安全
- **Reactor**: 事件循环、事件分发、非阻塞 I/O
- **CSP**: 通道通信、顺序进程、同步点
- **结构化并发**: 任务组管理、生命周期控制

**性能特征**:

- **Actor**: 适合状态管理、消息驱动
- **Reactor**: 适合 I/O 密集型、事件驱动
- **适用场景**: 高并发服务器、实时系统、分布式系统

### 关系连接

**继承关系**:

- Actor 模式 --[is-a]--> 并发模式
- Reactor 模式 --[is-a]--> 事件驱动模式

**组合关系**:

- 异步应用 --[uses]--> 异步设计模式
- 结构化并发 --[uses]--> 任务组管理

**依赖关系**:

- 异步设计模式 --[depends-on]--> 异步运行时
- Actor 模式 --[depends-on]--> 消息通道

### 思维导图

```text
异步设计模式实践
│
├── 核心设计模式
│   ├── Actor 模式
│   ├── Reactor 模式
│   └── CSP
├── 结构化并发
│   ├── JoinSet
│   └── Select
├── 生命周期管理
│   ├── 优雅关闭
│   └── 任务取消
├── 错误处理模式
│   ├── 错误传播
│   └── 重试模式
└── 流量控制
    ├── 背压
    └── 速率限制
```

---

## 🎯 本章目标

掌握常见的异步设计模式，提升代码质量和可维护性。

**学习成果**:

- ✅ 理解 Actor、Reactor、CSP 等并发模式
- ✅ 掌握任务生命周期管理
- ✅ 学会优雅关闭和错误传播
- ✅ 实践背压和流量控制

---

## 1. 核心设计模式

### 1.1 Actor 模式

**概念**: 每个 Actor 拥有私有状态，通过消息通信。

```rust
use tokio::sync::mpsc;

struct Counter {
    count: u32,
    rx: mpsc::Receiver<CounterMsg>,
}

enum CounterMsg {
    Increment,
    GetCount(mpsc::Sender<u32>),
}

impl Counter {
    fn new() -> (Self, mpsc::Sender<CounterMsg>) {
        let (tx, rx) = mpsc::channel(100);
        (Self { count: 0, rx }, tx)
    }

    async fn run(mut self) {
        while let Some(msg) = self.rx.recv().await {
            match msg {
                CounterMsg::Increment => self.count += 1,
                CounterMsg::GetCount(reply) => {
                    let _ = reply.send(self.count).await;
                }
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let (counter, tx) = Counter::new();

    // 启动 Actor
    tokio::spawn(counter.run());

    // 发送消息
    tx.send(CounterMsg::Increment).await.unwrap();

    let (reply_tx, mut reply_rx) = mpsc::channel(1);
    tx.send(CounterMsg::GetCount(reply_tx)).await.unwrap();

    let count = reply_rx.recv().await.unwrap();
    println!("Count: {}", count);
}
```

---

### 1.2 Reactor 模式

**概念**: 事件循环，等待事件并分发处理。

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn handle_client(mut socket: TcpStream) {
    let mut buf = vec![0; 1024];

    loop {
        match socket.read(&mut buf).await {
            Ok(0) => break, // 连接关闭
            Ok(n) => {
                // Echo back
                if socket.write_all(&buf[..n]).await.is_err() {
                    break;
                }
            }
            Err(_) => break,
        }
    }
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (socket, _) = listener.accept().await?;
        tokio::spawn(handle_client(socket));
    }
}
```

---

### 1.3 CSP (Communicating Sequential Processes)

**概念**: 通过通道进行通信，不共享内存。

```rust
use tokio::sync::mpsc;

async fn producer(tx: mpsc::Sender<i32>) {
    for i in 0..10 {
        tx.send(i).await.unwrap();
    }
}

async fn consumer(mut rx: mpsc::Receiver<i32>) {
    while let Some(val) = rx.recv().await {
        println!("Received: {}", val);
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(100);

    tokio::join!(
        producer(tx),
        consumer(rx),
    );
}
```

---

## 2. 结构化并发

### 2.1 JoinSet - 任务组管理

```rust
use tokio::task::JoinSet;

#[tokio::main]
async fn main() {
    let mut set = JoinSet::new();

    // 添加任务
    for i in 0..10 {
        set.spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(100 * i)).await;
            i
        });
    }

    // 等待所有任务完成
    while let Some(result) = set.join_next().await {
        match result {
            Ok(val) => println!("Task completed: {}", val),
            Err(e) => eprintln!("Task failed: {}", e),
        }
    }
}
```

---

### 2.2 Select - 多路选择

```rust
use tokio::sync::mpsc;
use tokio::select;

#[tokio::main]
async fn main() {
    let (tx1, mut rx1) = mpsc::channel(10);
    let (tx2, mut rx2) = mpsc::channel(10);

    tokio::spawn(async move {
        tx1.send("from channel 1").await.unwrap();
    });

    tokio::spawn(async move {
        tx2.send("from channel 2").await.unwrap();
    });

    select! {
        msg = rx1.recv() => println!("rx1: {:?}", msg),
        msg = rx2.recv() => println!("rx2: {:?}", msg),
    }
}
```

---

## 3. 生命周期管理

### 3.1 优雅关闭

```rust
use tokio::sync::broadcast;
use tokio::signal;

async fn worker(id: usize, mut shutdown: broadcast::Receiver<()>) {
    loop {
        tokio::select! {
            _ = shutdown.recv() => {
                println!("Worker {} shutting down", id);
                break;
            }
            _ = tokio::time::sleep(tokio::time::Duration::from_secs(1)) => {
                println!("Worker {} working", id);
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let (shutdown_tx, _) = broadcast::channel(1);

    // 启动 workers
    let mut handles = vec![];
    for i in 0..3 {
        let rx = shutdown_tx.subscribe();
        handles.push(tokio::spawn(worker(i, rx)));
    }

    // 等待 Ctrl+C
    signal::ctrl_c().await.unwrap();
    println!("Shutting down...");

    // 发送关闭信号
    let _ = shutdown_tx.send(());

    // 等待所有 workers
    for handle in handles {
        let _ = handle.await;
    }
}
```

---

### 3.2 任务取消

```rust
use tokio_util::sync::CancellationToken;

async fn long_running_task(token: CancellationToken) {
    loop {
        tokio::select! {
            _ = token.cancelled() => {
                println!("Task cancelled");
                break;
            }
            _ = tokio::time::sleep(tokio::time::Duration::from_millis(100)) => {
                println!("Working...");
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let token = CancellationToken::new();
    let child_token = token.child_token();

    let handle = tokio::spawn(long_running_task(child_token));

    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    token.cancel();

    handle.await.unwrap();
}
```

---

## 4. 错误处理模式

### 4.1 错误传播

```rust
use anyhow::{Context, Result};

async fn fetch_user(id: u64) -> Result<String> {
    Ok(format!("User {}", id))
}

async fn fetch_profile(user: &str) -> Result<String> {
    Ok(format!("Profile of {}", user))
}

async fn get_user_info(id: u64) -> Result<String> {
    let user = fetch_user(id)
        .await
        .context("Failed to fetch user")?;

    let profile = fetch_profile(&user)
        .await
        .context("Failed to fetch profile")?;

    Ok(format!("{} - {}", user, profile))
}

#[tokio::main]
async fn main() {
    match get_user_info(1).await {
        Ok(info) => println!("{}", info),
        Err(e) => eprintln!("Error: {:?}", e),
    }
}
```

---

### 4.2 重试模式

```rust
use tokio::time::{sleep, Duration};

async fn retry_operation<F, Fut, T, E>(
    mut operation: F,
    max_attempts: usize,
    delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Fut,
    Fut: std::future::Future<Output = Result<T, E>>,
{
    for attempt in 1..=max_attempts {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(e) if attempt == max_attempts => return Err(e),
            Err(_) => {
                sleep(delay * attempt as u32).await;
            }
        }
    }
    unreachable!()
}

#[tokio::main]
async fn main() {
    let result = retry_operation(
        || async {
            // 模拟可能失败的操作
            Err::<(), &str>("Failed")
        },
        3,
        Duration::from_millis(100),
    ).await;

    println!("Result: {:?}", result);
}
```

---

## 5. 流量控制

### 5.1 背压 (Backpressure)

```rust
use tokio::sync::mpsc;

async fn producer_with_backpressure(tx: mpsc::Sender<i32>) {
    for i in 0..100 {
        // send() 会在通道满时等待
        match tx.send(i).await {
            Ok(_) => println!("Sent: {}", i),
            Err(_) => {
                println!("Receiver dropped");
                break;
            }
        }
    }
}

async fn slow_consumer(mut rx: mpsc::Receiver<i32>) {
    while let Some(val) = rx.recv().await {
        // 模拟慢速处理
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        println!("Processed: {}", val);
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10); // 限制缓冲区大小

    tokio::join!(
        producer_with_backpressure(tx),
        slow_consumer(rx),
    );
}
```

---

### 5.2 速率限制

```rust
use tokio::time::{interval, Duration};

async fn rate_limited_task() {
    let mut interval = interval(Duration::from_millis(100));

    for i in 0..10 {
        interval.tick().await;
        println!("Task {} at {:?}", i, std::time::Instant::now());
    }
}

#[tokio::main]
async fn main() {
    rate_limited_task().await;
}
```

---

## 6. 最佳实践

### 6.1 设计原则

1. **优先使用通道**: 避免共享状态
2. **结构化并发**: 使用 JoinSet 管理任务组
3. **优雅关闭**: 正确处理信号和清理
4. **错误传播**: 使用 `?` 和 `Context`
5. **背压控制**: 限制缓冲区大小

### 6.2 常见陷阱

❌ **过度使用 `Arc<Mutex>`**:

```rust
// 不推荐
let counter = Arc::new(Mutex::new(0));
```

✅ **使用通道或 Actor**:

```rust
// 推荐
let (tx, rx) = mpsc::channel(100);
```

---

## 📚 延伸阅读

- **[Future与Executor机制](./02_Future与Executor机制.md)** - 理解原理
- **[异步性能优化指南](./05_异步性能优化指南.md)** - 性能调优
- **[异步调试与监控](./06_异步调试与监控.md)** - 调试技巧

---

## 📝 总结

**核心模式**:

- ✅ **Actor**: 消息驱动的状态隔离
- ✅ **Reactor**: 事件循环和分发
- ✅ **CSP**: 通道通信
- ✅ **结构化并发**: JoinSet 和 Select

**关键技术**:

- ✅ 优雅关闭和任务取消
- ✅ 错误传播和重试
- ✅ 背压和速率限制

---

**文档维护**: C06 Async Team | **质量评分**: 95/100
**最后更新**: 2025-12-11 | **Rust 版本**: 1.92.0+
