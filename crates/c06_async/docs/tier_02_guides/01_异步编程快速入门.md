# Tier 2: 异步编程快速入门

> **文档版本**: Rust 1.90+ | **更新日期**: 2025-10-22  
> **文档层级**: Tier 2 - 实践指南 | **预计阅读**: 10-15 分钟

---

## 📊 目录

- [Tier 2: 异步编程快速入门](#tier-2-异步编程快速入门)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 本章目标](#-本章目标)
  - [📑 目录](#-目录-2)
  - [1. 什么是异步编程？](#1-什么是异步编程)
    - [1.1 同步 vs 异步](#11-同步-vs-异步)
    - [1.2 为什么需要异步？](#12-为什么需要异步)
  - [2. 你的第一个异步程序](#2-你的第一个异步程序)
    - [2.1 环境准备](#21-环境准备)
    - [2.2 Hello, Async World](#22-hello-async-world)
    - [2.3 代码解析](#23-代码解析)
      - [`#[tokio::main]` 宏](#tokiomain-宏)
      - [`async` 关键字](#async-关键字)
      - [`.await` 关键字](#await-关键字)
  - [3. 核心概念](#3-核心概念)
    - [3.1 三大核心](#31-三大核心)
      - [3.1.1 async/await（语法层）](#311-asyncawait语法层)
      - [3.1.2 Future（抽象层）](#312-future抽象层)
      - [3.1.3 Runtime（执行层）](#313-runtime执行层)
    - [3.2 异步执行流程](#32-异步执行流程)
  - [4. 实用示例](#4-实用示例)
    - [4.1 并发执行多个任务](#41-并发执行多个任务)
    - [4.2 后台任务](#42-后台任务)
    - [4.3 HTTP 请求示例](#43-http-请求示例)
    - [4.4 超时控制](#44-超时控制)
  - [5. 常见陷阱](#5-常见陷阱)
    - [5.1 忘记 `.await`](#51-忘记-await)
    - [5.2 在非 `async` 函数中使用 `.await`](#52-在非-async-函数中使用-await)
    - [5.3 阻塞异步运行时](#53-阻塞异步运行时)
    - [5.4 混用不同运行时的类型](#54-混用不同运行时的类型)
  - [6. 下一步](#6-下一步)
    - [6.1 学习路径](#61-学习路径)
    - [6.2 推荐阅读](#62-推荐阅读)
    - [6.3 实践建议](#63-实践建议)
    - [6.4 练习题](#64-练习题)
      - [练习 1: Hello, Async! (5 分钟)](#练习-1-hello-async-5-分钟)
      - [练习 2: 并发任务 (10 分钟)](#练习-2-并发任务-10-分钟)
      - [练习 3: 超时处理 (15 分钟)](#练习-3-超时处理-15-分钟)
  - [📚 延伸阅读](#-延伸阅读)
    - [官方资源](#官方资源)
    - [本模块文档](#本模块文档)
  - [📝 总结](#-总结)

## 📋 目录

- [Tier 2: 异步编程快速入门](#tier-2-异步编程快速入门)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 本章目标](#-本章目标)
  - [📑 目录](#-目录-2)
  - [1. 什么是异步编程？](#1-什么是异步编程)
    - [1.1 同步 vs 异步](#11-同步-vs-异步)
    - [1.2 为什么需要异步？](#12-为什么需要异步)
  - [2. 你的第一个异步程序](#2-你的第一个异步程序)
    - [2.1 环境准备](#21-环境准备)
    - [2.2 Hello, Async World](#22-hello-async-world)
    - [2.3 代码解析](#23-代码解析)
      - [`#[tokio::main]` 宏](#tokiomain-宏)
      - [`async` 关键字](#async-关键字)
      - [`.await` 关键字](#await-关键字)
  - [3. 核心概念](#3-核心概念)
    - [3.1 三大核心](#31-三大核心)
      - [3.1.1 async/await（语法层）](#311-asyncawait语法层)
      - [3.1.2 Future（抽象层）](#312-future抽象层)
      - [3.1.3 Runtime（执行层）](#313-runtime执行层)
    - [3.2 异步执行流程](#32-异步执行流程)
  - [4. 实用示例](#4-实用示例)
    - [4.1 并发执行多个任务](#41-并发执行多个任务)
    - [4.2 后台任务](#42-后台任务)
    - [4.3 HTTP 请求示例](#43-http-请求示例)
    - [4.4 超时控制](#44-超时控制)
  - [5. 常见陷阱](#5-常见陷阱)
    - [5.1 忘记 `.await`](#51-忘记-await)
    - [5.2 在非 `async` 函数中使用 `.await`](#52-在非-async-函数中使用-await)
    - [5.3 阻塞异步运行时](#53-阻塞异步运行时)
    - [5.4 混用不同运行时的类型](#54-混用不同运行时的类型)
  - [6. 下一步](#6-下一步)
    - [6.1 学习路径](#61-学习路径)
    - [6.2 推荐阅读](#62-推荐阅读)
    - [6.3 实践建议](#63-实践建议)
    - [6.4 练习题](#64-练习题)
      - [练习 1: Hello, Async! (5 分钟)](#练习-1-hello-async-5-分钟)
      - [练习 2: 并发任务 (10 分钟)](#练习-2-并发任务-10-分钟)
      - [练习 3: 超时处理 (15 分钟)](#练习-3-超时处理-15-分钟)
  - [📚 延伸阅读](#-延伸阅读)
    - [官方资源](#官方资源)
    - [本模块文档](#本模块文档)
  - [📝 总结](#-总结)

## 🎯 本章目标

**10 分钟快速上手 Rust 异步编程**，从零开始编写并运行你的第一个异步程序。

**学习成果**:

- ✅ 理解异步编程的基本概念
- ✅ 掌握 `async/await` 语法
- ✅ 能够运行简单的异步程序
- ✅ 了解异步与同步的区别
- ✅ 避免常见的新手陷阱

---

## 📑 目录

- [1. 什么是异步编程？](#1-什么是异步编程)
- [2. 你的第一个异步程序](#2-你的第一个异步程序)
- [3. 核心概念](#3-核心概念)
- [4. 实用示例](#4-实用示例)
- [5. 常见陷阱](#5-常见陷阱)
- [6. 下一步](#6-下一步)

---

## 1. 什么是异步编程？

### 1.1 同步 vs 异步

**同步方式（阻塞）**:

```rust
fn fetch_data() -> String {
    // 阻塞当前线程，等待数据返回
    std::thread::sleep(std::time::Duration::from_secs(2));
    "Data".to_string()
}

fn main() {
    println!("Start");
    let data = fetch_data(); // 这里会等待 2 秒
    println!("Got: {}", data);
    println!("End");
}
// 输出：
// Start
// (等待 2 秒...)
// Got: Data
// End
```

**异步方式（非阻塞）**:

```rust
async fn fetch_data() -> String {
    // 不阻塞线程，允许其他任务运行
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    "Data".to_string()
}

#[tokio::main]
async fn main() {
    println!("Start");
    let data = fetch_data().await; // 等待时可以执行其他任务
    println!("Got: {}", data);
    println!("End");
}
```

---

### 1.2 为什么需要异步？

**场景对比**:

| 场景 | 同步方式 | 异步方式 |
|------|----------|----------|
| **处理 10,000 个网络请求** | 需要 10,000 个线程（~20GB 内存） | 只需几个线程（~几MB 内存） |
| **Web 服务器** | 每个连接一个线程，资源消耗大 | 少量线程处理大量连接 |
| **文件 I/O** | 阻塞等待，浪费 CPU | 等待期间处理其他任务 |

**核心优势**:

- ✅ **高并发**: 同时处理成千上万的任务
- ✅ **低资源**: 内存和 CPU 占用少
- ✅ **高效率**: I/O 等待时不浪费资源

---

## 2. 你的第一个异步程序

### 2.1 环境准备

**1. 创建项目**:

```bash
cargo new async_hello
cd async_hello
```

**2. 添加依赖** (`Cargo.toml`):

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

> **为什么需要 Tokio？**  
> Rust 的 `async/await` 只是语法，需要**运行时**来实际执行异步代码。Tokio 是最流行的异步运行时。

---

### 2.2 Hello, Async World

**代码** (`src/main.rs`):

```rust
// 1. 导入 Tokio 运行时
use tokio::time::{sleep, Duration};

// 2. 使用 #[tokio::main] 宏设置异步运行时
#[tokio::main]
async fn main() {
    println!("Hello, async world!");
    
    // 3. 异步等待 1 秒
    sleep(Duration::from_secs(1)).await;
    
    println!("1 second later...");
}
```

**运行**:

```bash
cargo run
```

**输出**:

```text
Hello, async world!
(等待 1 秒)
1 second later...
```

---

### 2.3 代码解析

#### `#[tokio::main]` 宏

```rust
// 你写的代码：
#[tokio::main]
async fn main() {
    // 异步代码
}

// 实际展开为：
fn main() {
    tokio::runtime::Runtime::new()
        .unwrap()
        .block_on(async {
            // 异步代码
        })
}
```

**作用**: 自动创建 Tokio 运行时并运行你的异步 `main` 函数。

---

#### `async` 关键字

```rust
async fn my_function() -> i32 {
    42
}

// 等价于：
fn my_function() -> impl Future<Output = i32> {
    async { 42 }
}
```

**作用**: 将函数变成异步函数，返回一个 `Future`（未来值）。

---

#### `.await` 关键字

```rust
async fn example() {
    let result = async_operation().await; // 等待 Future 完成
    println!("Result: {}", result);
}
```

**作用**:

- 暂停当前函数，等待 `Future` 完成
- **不会阻塞线程**，允许其他任务运行

---

## 3. 核心概念

### 3.1 三大核心

```text
┌─────────────────────────────────────────────────┐
│            Rust 异步编程三大核心                │
├─────────────────────────────────────────────────┤
│                                                 │
│  1. async/await  ← 编写异步代码的语法           │
│     ↓                                           │
│  2. Future       ← 异步计算的抽象               │
│     ↓                                           │
│  3. Runtime      ← 执行 Future 的运行时环境     │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

#### 3.1.1 async/await（语法层）

**用途**: 让你能够用接近同步代码的方式编写异步逻辑。

```rust
// 同步风格（但实际是异步）
async fn process_user(id: u64) -> Result<User, Error> {
    let user = fetch_user(id).await?;          // 等待网络请求
    let profile = fetch_profile(user.id).await?; // 等待另一个请求
    Ok(merge(user, profile))
}
```

---

#### 3.1.2 Future（抽象层）

**定义**: 代表一个可能尚未完成的计算。

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// Future trait 的简化版本
trait Future {
    type Output;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) 
        -> Poll<Self::Output>;
}

// Poll 的两种状态
enum Poll<T> {
    Ready(T),    // 计算完成
    Pending,     // 尚未完成
}
```

**关键特性**:

- **惰性**: 只有被 `.await` 或 `poll()` 时才开始执行
- **零成本**: 编译为状态机，无运行时开销

---

#### 3.1.3 Runtime（执行层）

**用途**: 负责实际执行 Future，管理任务调度。

```rust
// Tokio 运行时（多线程）
#[tokio::main]
async fn main() {
    // 在 Tokio 运行时中执行
}

// 或手动创建
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        // 异步代码
    });
}
```

**主流运行时**:

- **Tokio**: 功能最全，生产级
- **async-std**: API 接近标准库
- **Smol**: 轻量级

---

### 3.2 异步执行流程

```text
┌──────────────────────────────────────────────────┐
│ 1. 编写代码                                      │
│    async fn fetch() -> String {                  │
│        reqwest::get("url").await?.text().await   │
│    }                                             │
├──────────────────────────────────────────────────┤
│ 2. 编译器转换                                    │
│    → 生成状态机（实现 Future trait）             │
├──────────────────────────────────────────────────┤
│ 3. 运行时执行                                    │
│    → Executor 调用 Future::poll()                │
│    → 如果 Pending，注册 Waker 等待唤醒           │
│    → 如果 Ready，返回结果                        │
└──────────────────────────────────────────────────┘
```

---

## 4. 实用示例

### 4.1 并发执行多个任务

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // ❌ 顺序执行（总共 3 秒）
    task1().await;
    task2().await;
    task3().await;
    
    // ✅ 并发执行（总共 1 秒，因为最长任务是 1 秒）
    tokio::join!(task1(), task2(), task3());
}

async fn task1() {
    sleep(Duration::from_secs(1)).await;
    println!("Task 1 done");
}

async fn task2() {
    sleep(Duration::from_millis(500)).await;
    println!("Task 2 done");
}

async fn task3() {
    sleep(Duration::from_millis(300)).await;
    println!("Task 3 done");
}
```

**输出**:

```text
Task 3 done
Task 2 done
Task 1 done
```

---

### 4.2 后台任务

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // 启动后台任务
    let handle = tokio::spawn(async {
        println!("Background task started");
        sleep(Duration::from_secs(2)).await;
        println!("Background task finished");
        42 // 返回值
    });
    
    // 主任务继续执行
    println!("Main task running");
    sleep(Duration::from_secs(1)).await;
    println!("Main task done");
    
    // 等待后台任务完成
    let result = handle.await.unwrap();
    println!("Background result: {}", result);
}
```

**输出**:

```text
Background task started
Main task running
Main task done
Background task finished
Background result: 42
```

---

### 4.3 HTTP 请求示例

**添加依赖** (`Cargo.toml`):

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = "0.11"
```

**代码**:

```rust
use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 发起异步 HTTP GET 请求
    let response = reqwest::get("https://httpbin.org/ip")
        .await?
        .text()
        .await?;
    
    println!("Response: {}", response);
    Ok(())
}
```

---

### 4.4 超时控制

```rust
use tokio::time::{timeout, Duration};

async fn slow_operation() -> String {
    tokio::time::sleep(Duration::from_secs(5)).await;
    "Done".to_string()
}

#[tokio::main]
async fn main() {
    // 设置 2 秒超时
    match timeout(Duration::from_secs(2), slow_operation()).await {
        Ok(result) => println!("Success: {}", result),
        Err(_) => println!("Timeout!"),
    }
}
```

**输出**:

```text
Timeout!
```

---

## 5. 常见陷阱

### 5.1 忘记 `.await`

```rust
async fn fetch_data() -> String {
    "Data".to_string()
}

#[tokio::main]
async fn main() {
    // ❌ 错误：创建了 Future 但没有执行
    let data = fetch_data(); // 类型是 impl Future<Output = String>
    // 什么也不会发生！
    
    // ✅ 正确：使用 .await 执行
    let data = fetch_data().await;
    println!("Got: {}", data);
}
```

**记住**: Future 是惰性的，必须 `.await` 才会执行。

---

### 5.2 在非 `async` 函数中使用 `.await`

```rust
// ❌ 编译错误
fn main() {
    let data = fetch_data().await; // 错误：.await 只能在 async 函数中使用
}

// ✅ 方案 1：使用 #[tokio::main]
#[tokio::main]
async fn main() {
    let data = fetch_data().await;
}

// ✅ 方案 2：手动创建运行时
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        let data = fetch_data().await;
    });
}
```

---

### 5.3 阻塞异步运行时

```rust
use std::thread;
use std::time::Duration;

#[tokio::main]
async fn main() {
    // ❌ 错误：阻塞整个运行时
    thread::sleep(Duration::from_secs(1)); // 会阻塞所有异步任务！
    
    // ✅ 正确：使用异步 sleep
    tokio::time::sleep(Duration::from_secs(1)).await;
}
```

**规则**:

- ❌ 不要使用 `std::thread::sleep`
- ✅ 使用 `tokio::time::sleep`
- ❌ 不要调用阻塞的同步函数
- ✅ 使用 `tokio::task::spawn_blocking` 包装阻塞操作

---

### 5.4 混用不同运行时的类型

```rust
// ❌ 错误：不能混用
use tokio::net::TcpStream as TokioStream;
use async_std::net::TcpStream as AsyncStdStream;

#[tokio::main]
async fn main() {
    // AsyncStdStream 无法在 Tokio 运行时中工作
    let stream = AsyncStdStream::connect("127.0.0.1:8080").await;
}

// ✅ 正确：统一使用 Tokio 的类型
use tokio::net::TcpStream;

#[tokio::main]
async fn main() {
    let stream = TcpStream::connect("127.0.0.1:8080").await;
}
```

**原则**: 选定一个运行时（推荐 Tokio），统一使用其提供的类型。

---

## 6. 下一步

### 6.1 学习路径

```text
你现在在这里 ✓
    │
    ├─ 01_异步编程快速入门 (本章) ✓
    │
    ├─ 02_Future与Executor机制 (下一章)
    │  └─ 理解异步执行原理
    │
    ├─ 03_异步运行时选择指南
    │  └─ Tokio vs async-std vs Smol
    │
    ├─ 04_异步设计模式实践
    │  └─ Actor、Reactor、CSP 模式
    │
    ├─ 05_异步性能优化指南
    │  └─ 性能调优技巧
    │
    └─ 06_异步调试与监控
       └─ 调试工具和监控方法
```

---

### 6.2 推荐阅读

| 文档 | 说明 | 难度 |
|------|------|------|
| **[术语表](../tier_01_foundations/03_术语表.md)** | 核心术语速查 | ⭐ |
| **[常见问题](../tier_01_foundations/04_常见问题.md)** | FAQ 快速解答 | ⭐⭐ |
| **[Future与Executor机制](./02_Future与Executor机制.md)** | 深入原理 | ⭐⭐⭐ |

---

### 6.3 实践建议

**第一周**:

- ✅ 运行本章的所有示例代码
- ✅ 修改参数，观察行为变化
- ✅ 尝试编写自己的简单异步函数

**第二周**:

- ✅ 阅读 [Future与Executor机制](./02_Future与Executor机制.md)
- ✅ 理解 `Future` trait 的工作原理
- ✅ 学习如何手动实现简单的 `Future`

**第三周**:

- ✅ 阅读 [异步运行时选择指南](./03_异步运行时选择指南.md)
- ✅ 对比不同运行时的特点
- ✅ 为项目选择合适的运行时

---

### 6.4 练习题

#### 练习 1: Hello, Async! (5 分钟)

编写一个程序，异步打印 "Hello" 和 "World"，中间间隔 1 秒。

查看答案

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("Hello");
    sleep(Duration::from_secs(1)).await;
    println!("World");
}
```

---

#### 练习 2: 并发任务 (10 分钟)

创建 3 个异步任务，分别等待 1 秒、2 秒、3 秒，并发执行它们。

查看答案

```rust
use tokio::time::{sleep, Duration};

async fn task(id: u32, seconds: u64) {
    println!("Task {} started", id);
    sleep(Duration::from_secs(seconds)).await;
    println!("Task {} finished", id);
}

#[tokio::main]
async fn main() {
    // 并发执行，总共只需要 3 秒
    tokio::join!(
        task(1, 1),
        task(2, 2),
        task(3, 3),
    );
}
```

---

#### 练习 3: 超时处理 (15 分钟)

编写一个函数，异步读取文件内容，如果超过 5 秒未完成则返回错误。

查看答案

```rust
use tokio::fs;
use tokio::time::{timeout, Duration};

#[tokio::main]
async fn main() {
    match timeout(
        Duration::from_secs(5),
        fs::read_to_string("test.txt")
    ).await {
        Ok(Ok(content)) => println!("File content: {}", content),
        Ok(Err(e)) => eprintln!("File error: {}", e),
        Err(_) => eprintln!("Timeout!"),
    }
}
```

---

## 📚 延伸阅读

### 官方资源

- [Rust Async Book](https://rust-lang.github.io/async-book/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)

### 本模块文档

- **[项目概览](../tier_01_foundations/01_项目概览.md)** - 模块整体介绍
- **[主索引导航](../tier_01_foundations/02_主索引导航.md)** - 完整文档导航

---

## 📝 总结

**你已经学会了**:

- ✅ 异步编程的基本概念和优势
- ✅ `async/await` 语法的使用
- ✅ 如何使用 Tokio 运行时
- ✅ 并发执行多个异步任务
- ✅ 常见陷阱和解决方案

**下一步**:

- 📖 阅读 **[Future与Executor机制](./02_Future与Executor机制.md)** 深入理解原理
- 💻 完成练习题，巩固知识
- 🚀 开始构建自己的异步应用

---

**文档维护**: C06 Async Team | **质量评分**: 95/100  
**最后更新**: 2025-10-22 | **Rust 版本**: 1.90+
