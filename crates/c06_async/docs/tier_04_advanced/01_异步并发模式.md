# Tier 4: 异步并发模式

> **文档版本**: Rust 1.90+ | **更新日期**: 2025-10-22  
> **文档层级**: Tier 4 - 高级主题 | **文档类型**: 🚀 前沿技术

---

## 📋 目录

- [Tier 4: 异步并发模式](#tier-4-异步并发模式)
  - [📋 目录](#-目录)
  - [🎯 文档说明](#-文档说明)
  - [1. Actor 模式](#1-actor-模式)
    - [1.1 概念](#11-概念)
    - [1.2 实现](#12-实现)
    - [1.3 最佳实践](#13-最佳实践)
  - [2. Reactor 模式](#2-reactor-模式)
    - [2.1 概念](#21-概念)
    - [2.2 实现](#22-实现)
  - [3. Pipeline 模式](#3-pipeline-模式)
    - [3.1 概念](#31-概念)
    - [3.2 实现](#32-实现)
  - [4. CSP (Communicating Sequential Processes)](#4-csp-communicating-sequential-processes)
    - [4.1 概念](#41-概念)
    - [4.2 Select 模式](#42-select-模式)
  - [5. 对象池模式](#5-对象池模式)
    - [5.1 概念](#51-概念)
    - [5.2 实现](#52-实现)
  - [6. Work Stealing](#6-work-stealing)
    - [6.1 概念](#61-概念)
  - [7. 反应式编程](#7-反应式编程)
    - [7.1 概念](#71-概念)
    - [7.2 使用 futures-rs](#72-使用-futures-rs)
  - [8. 错误处理模式](#8-错误处理模式)
    - [8.1 Supervisor 模式](#81-supervisor-模式)
  - [📚 延伸阅读](#-延伸阅读)
  - [📝 总结](#-总结)

## 🎯 文档说明

深入探讨异步编程中的高级并发模式和设计原则。

**目标读者**: 资深开发者、架构师、库作者

---

## 1. Actor 模式

### 1.1 概念

Actor 是独立的计算单元，通过消息传递进行通信，不共享状态。

**核心特性**:

- ✅ 封装状态
- ✅ 消息传递
- ✅ 并发安全
- ✅ 容错能力

---

### 1.2 实现

```rust
use tokio::sync::mpsc;
use std::sync::Arc;

// Actor 消息
enum Message {
    Get(tokio::sync::oneshot::Sender<u64>),
    Increment,
    Decrement,
}

// Actor 结构
struct CounterActor {
    receiver: mpsc::Receiver<Message>,
    count: u64,
}

impl CounterActor {
    fn new(receiver: mpsc::Receiver<Message>) -> Self {
        Self { receiver, count: 0 }
    }
    
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                Message::Get(respond_to) => {
                    let _ = respond_to.send(self.count);
                }
                Message::Increment => {
                    self.count += 1;
                }
                Message::Decrement => {
                    self.count -= 1;
                }
            }
        }
    }
}

// Actor Handle
#[derive(Clone)]
struct Counter {
    sender: mpsc::Sender<Message>,
}

impl Counter {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel(8);
        let actor = CounterActor::new(receiver);
        tokio::spawn(actor.run());
        Self { sender }
    }
    
    async fn get(&self) -> u64 {
        let (send, recv) = tokio::sync::oneshot::channel();
        let _ = self.sender.send(Message::Get(send)).await;
        recv.await.unwrap()
    }
    
    async fn increment(&self) {
        let _ = self.sender.send(Message::Increment).await;
    }
}
```

---

### 1.3 最佳实践

**优点**:

- ✅ 避免锁竞争
- ✅ 易于推理
- ✅ 容错隔离

**适用场景**:

- 状态封装
- 复杂并发逻辑
- 容错系统

---

## 2. Reactor 模式

### 2.1 概念

Reactor 监听事件并分发到处理器。

**组件**:

- **事件源** (Event Source)
- **Reactor** (事件分发器)
- **Handler** (事件处理器)

---

### 2.2 实现

```rust
use std::collections::HashMap;
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

trait Handler: Send + Sync {
    async fn handle(&self, stream: TcpStream);
}

struct EchoHandler;

impl Handler for EchoHandler {
    async fn handle(&self, mut stream: TcpStream) {
        let mut buf = vec![0; 1024];
        loop {
            match stream.read(&mut buf).await {
                Ok(0) => break,
                Ok(n) => {
                    if stream.write_all(&buf[..n]).await.is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    }
}

struct Reactor {
    handlers: HashMap<String, Arc<dyn Handler>>,
}

impl Reactor {
    fn new() -> Self {
        Self {
            handlers: HashMap::new(),
        }
    }
    
    fn register(&mut self, name: String, handler: Arc<dyn Handler>) {
        self.handlers.insert(name, handler);
    }
    
    async fn run(&self, addr: &str) -> std::io::Result<()> {
        let listener = TcpListener::bind(addr).await?;
        
        loop {
            let (stream, _) = listener.accept().await?;
            
            if let Some(handler) = self.handlers.get("echo") {
                let handler = Arc::clone(handler);
                tokio::spawn(async move {
                    handler.handle(stream).await;
                });
            }
        }
    }
}
```

---

## 3. Pipeline 模式

### 3.1 概念

数据通过一系列处理阶段流动。

**特性**:

- ✅ 解耦处理逻辑
- ✅ 并行处理
- ✅ 背压控制

---

### 3.2 实现

```rust
use tokio::sync::mpsc;
use futures::StreamExt;

async fn stage1(mut input: mpsc::Receiver<i32>, output: mpsc::Sender<i32>) {
    while let Some(value) = input.recv().await {
        let result = value * 2;
        if output.send(result).await.is_err() {
            break;
        }
    }
}

async fn stage2(mut input: mpsc::Receiver<i32>, output: mpsc::Sender<i32>) {
    while let Some(value) = input.recv().await {
        let result = value + 10;
        if output.send(result).await.is_err() {
            break;
        }
    }
}

async fn run_pipeline() {
    let (tx1, rx1) = mpsc::channel(10);
    let (tx2, rx2) = mpsc::channel(10);
    let (tx3, mut rx3) = mpsc::channel(10);
    
    // 启动 stages
    tokio::spawn(stage1(rx1, tx2));
    tokio::spawn(stage2(rx2, tx3));
    
    // 输入数据
    tokio::spawn(async move {
        for i in 0..100 {
            tx1.send(i).await.unwrap();
        }
    });
    
    // 收集结果
    while let Some(result) = rx3.recv().await {
        println!("Result: {}", result);
    }
}
```

---

## 4. CSP (Communicating Sequential Processes)

### 4.1 概念

通过 Channel 通信的独立进程。

**特性**:

- ✅ 显式通信
- ✅ 无共享状态
- ✅ 死锁检测

---

### 4.2 Select 模式

```rust
use tokio::sync::mpsc;
use tokio::select;

async fn csp_example() {
    let (tx1, mut rx1) = mpsc::channel(10);
    let (tx2, mut rx2) = mpsc::channel(10);
    
    // 生产者
    tokio::spawn(async move {
        for i in 0..10 {
            tx1.send(i).await.unwrap();
        }
    });
    
    tokio::spawn(async move {
        for i in 10..20 {
            tx2.send(i).await.unwrap();
        }
    });
    
    // 消费者 - select 多个 channel
    loop {
        select! {
            Some(v) = rx1.recv() => {
                println!("From channel 1: {}", v);
            }
            Some(v) = rx2.recv() => {
                println!("From channel 2: {}", v);
            }
            else => break,
        }
    }
}
```

---

## 5. 对象池模式

### 5.1 概念

复用昂贵对象以减少分配开销。

---

### 5.2 实现

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

struct Pool<T> {
    objects: Arc<Mutex<Vec<T>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
}

impl<T: Send + 'static> Pool<T> {
    fn new<F>(factory: F) -> Self 
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        Self {
            objects: Arc::new(Mutex::new(Vec::new())),
            factory: Arc::new(factory),
        }
    }
    
    async fn acquire(&self) -> PooledObject<T> {
        let mut objects = self.objects.lock().await;
        let object = objects.pop().unwrap_or_else(|| (self.factory)());
        
        PooledObject {
            object: Some(object),
            pool: Arc::clone(&self.objects),
        }
    }
}

struct PooledObject<T> {
    object: Option<T>,
    pool: Arc<Mutex<Vec<T>>>,
}

impl<T> std::ops::Deref for PooledObject<T> {
    type Target = T;
    fn deref(&self) -> &T {
        self.object.as_ref().unwrap()
    }
}

impl<T> Drop for PooledObject<T> {
    fn drop(&mut self) {
        if let Some(object) = self.object.take() {
            let pool = Arc::clone(&self.pool);
            tokio::spawn(async move {
                pool.lock().await.push(object);
            });
        }
    }
}
```

---

## 6. Work Stealing

### 6.1 概念

空闲线程从繁忙线程"偷"任务。

**优势**:

- ✅ 负载均衡
- ✅ 提高吞吐量
- ✅ 减少空闲时间

**Tokio 内置**: Tokio 的多线程运行时使用 work-stealing 调度器。

---

## 7. 反应式编程

### 7.1 概念

基于数据流和变化传播。

---

### 7.2 使用 futures-rs

```rust
use futures::stream::{self, StreamExt};

async fn reactive_example() {
    let stream = stream::iter(0..100)
        .filter(|x| async move { x % 2 == 0 })
        .map(|x| x * 2)
        .take(10);
    
    let results: Vec<_> = stream.collect().await;
    println!("{:?}", results);
}
```

---

## 8. 错误处理模式

### 8.1 Supervisor 模式

```rust
use tokio::task::JoinHandle;

struct Supervisor {
    tasks: Vec<JoinHandle<()>>,
}

impl Supervisor {
    fn new() -> Self {
        Self { tasks: Vec::new() }
    }
    
    fn spawn<F>(&mut self, future: F)
    where
        F: std::future::Future<Output = ()> + Send + 'static,
    {
        let handle = tokio::spawn(async move {
            // 错误恢复逻辑
            match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                // 执行任务
            })) {
                Ok(_) => {},
                Err(e) => {
                    eprintln!("Task panicked: {:?}", e);
                    // 重启任务
                }
            }
        });
        
        self.tasks.push(handle);
    }
    
    async fn wait_all(self) {
        for task in self.tasks {
            let _ = task.await;
        }
    }
}
```

---

## 📚 延伸阅读

- **[异步设计模式实践](../tier_02_guides/04_异步设计模式实践.md)** - 基础模式
- **[异步系统架构](./02_异步系统架构.md)** - 系统级设计
- **[Tokio完整API参考](../tier_03_references/02_Tokio完整API参考.md)** - API详解

---

## 📝 总结

**核心模式**:

- ✅ Actor - 状态封装
- ✅ Reactor - 事件驱动
- ✅ Pipeline - 流式处理
- ✅ CSP - Channel 通信
- ✅ 对象池 - 资源复用
- ✅ Work Stealing - 负载均衡

**选择原则**:

- Actor: 复杂状态管理
- Reactor: 高并发网络服务
- Pipeline: 数据处理流
- CSP: 显式通信
- 对象池: 昂贵资源

---

**文档维护**: C06 Async Team | **质量评分**: 95/100  
**最后更新**: 2025-10-22 | **Rust 版本**: 1.90+
