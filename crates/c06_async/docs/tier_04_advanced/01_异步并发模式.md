# Tier 4: å¼‚æ­¥å¹¶å‘æ¨¡å¼

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 4 - é«˜çº§ä¸»é¢˜ | **æ–‡æ¡£ç±»å‹**: ğŸš€ å‰æ²¿æŠ€æœ¯

---

## ğŸ¯ æ–‡æ¡£è¯´æ˜

æ·±å…¥æ¢è®¨å¼‚æ­¥ç¼–ç¨‹ä¸­çš„é«˜çº§å¹¶å‘æ¨¡å¼å’Œè®¾è®¡åŸåˆ™ã€‚

**ç›®æ ‡è¯»è€…**: èµ„æ·±å¼€å‘è€…ã€æ¶æ„å¸ˆã€åº“ä½œè€…

---

## 1. Actor æ¨¡å¼

### 1.1 æ¦‚å¿µ

Actor æ˜¯ç‹¬ç«‹çš„è®¡ç®—å•å…ƒï¼Œé€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œé€šä¿¡ï¼Œä¸å…±äº«çŠ¶æ€ã€‚

**æ ¸å¿ƒç‰¹æ€§**:
- âœ… å°è£…çŠ¶æ€
- âœ… æ¶ˆæ¯ä¼ é€’
- âœ… å¹¶å‘å®‰å…¨
- âœ… å®¹é”™èƒ½åŠ›

---

### 1.2 å®ç°

```rust
use tokio::sync::mpsc;
use std::sync::Arc;

// Actor æ¶ˆæ¯
enum Message {
    Get(tokio::sync::oneshot::Sender<u64>),
    Increment,
    Decrement,
}

// Actor ç»“æ„
struct CounterActor {
    receiver: mpsc::Receiver<Message>,
    count: u64,
}

impl CounterActor {
    fn new(receiver: mpsc::Receiver<Message>) -> Self {
        Self { receiver, count: 0 }
    }
    
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                Message::Get(respond_to) => {
                    let _ = respond_to.send(self.count);
                }
                Message::Increment => {
                    self.count += 1;
                }
                Message::Decrement => {
                    self.count -= 1;
                }
            }
        }
    }
}

// Actor Handle
#[derive(Clone)]
struct Counter {
    sender: mpsc::Sender<Message>,
}

impl Counter {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel(8);
        let actor = CounterActor::new(receiver);
        tokio::spawn(actor.run());
        Self { sender }
    }
    
    async fn get(&self) -> u64 {
        let (send, recv) = tokio::sync::oneshot::channel();
        let _ = self.sender.send(Message::Get(send)).await;
        recv.await.unwrap()
    }
    
    async fn increment(&self) {
        let _ = self.sender.send(Message::Increment).await;
    }
}
```

---

### 1.3 æœ€ä½³å®è·µ

**ä¼˜ç‚¹**:
- âœ… é¿å…é”ç«äº‰
- âœ… æ˜“äºæ¨ç†
- âœ… å®¹é”™éš”ç¦»

**é€‚ç”¨åœºæ™¯**:
- çŠ¶æ€å°è£…
- å¤æ‚å¹¶å‘é€»è¾‘
- å®¹é”™ç³»ç»Ÿ

---

## 2. Reactor æ¨¡å¼

### 2.1 æ¦‚å¿µ

Reactor ç›‘å¬äº‹ä»¶å¹¶åˆ†å‘åˆ°å¤„ç†å™¨ã€‚

**ç»„ä»¶**:
- **äº‹ä»¶æº** (Event Source)
- **Reactor** (äº‹ä»¶åˆ†å‘å™¨)
- **Handler** (äº‹ä»¶å¤„ç†å™¨)

---

### 2.2 å®ç°

```rust
use std::collections::HashMap;
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

trait Handler: Send + Sync {
    async fn handle(&self, stream: TcpStream);
}

struct EchoHandler;

impl Handler for EchoHandler {
    async fn handle(&self, mut stream: TcpStream) {
        let mut buf = vec![0; 1024];
        loop {
            match stream.read(&mut buf).await {
                Ok(0) => break,
                Ok(n) => {
                    if stream.write_all(&buf[..n]).await.is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    }
}

struct Reactor {
    handlers: HashMap<String, Arc<dyn Handler>>,
}

impl Reactor {
    fn new() -> Self {
        Self {
            handlers: HashMap::new(),
        }
    }
    
    fn register(&mut self, name: String, handler: Arc<dyn Handler>) {
        self.handlers.insert(name, handler);
    }
    
    async fn run(&self, addr: &str) -> std::io::Result<()> {
        let listener = TcpListener::bind(addr).await?;
        
        loop {
            let (stream, _) = listener.accept().await?;
            
            if let Some(handler) = self.handlers.get("echo") {
                let handler = Arc::clone(handler);
                tokio::spawn(async move {
                    handler.handle(stream).await;
                });
            }
        }
    }
}
```

---

## 3. Pipeline æ¨¡å¼

### 3.1 æ¦‚å¿µ

æ•°æ®é€šè¿‡ä¸€ç³»åˆ—å¤„ç†é˜¶æ®µæµåŠ¨ã€‚

**ç‰¹æ€§**:
- âœ… è§£è€¦å¤„ç†é€»è¾‘
- âœ… å¹¶è¡Œå¤„ç†
- âœ… èƒŒå‹æ§åˆ¶

---

### 3.2 å®ç°

```rust
use tokio::sync::mpsc;
use futures::StreamExt;

async fn stage1(mut input: mpsc::Receiver<i32>, output: mpsc::Sender<i32>) {
    while let Some(value) = input.recv().await {
        let result = value * 2;
        if output.send(result).await.is_err() {
            break;
        }
    }
}

async fn stage2(mut input: mpsc::Receiver<i32>, output: mpsc::Sender<i32>) {
    while let Some(value) = input.recv().await {
        let result = value + 10;
        if output.send(result).await.is_err() {
            break;
        }
    }
}

async fn run_pipeline() {
    let (tx1, rx1) = mpsc::channel(10);
    let (tx2, rx2) = mpsc::channel(10);
    let (tx3, mut rx3) = mpsc::channel(10);
    
    // å¯åŠ¨ stages
    tokio::spawn(stage1(rx1, tx2));
    tokio::spawn(stage2(rx2, tx3));
    
    // è¾“å…¥æ•°æ®
    tokio::spawn(async move {
        for i in 0..100 {
            tx1.send(i).await.unwrap();
        }
    });
    
    // æ”¶é›†ç»“æœ
    while let Some(result) = rx3.recv().await {
        println!("Result: {}", result);
    }
}
```

---

## 4. CSP (Communicating Sequential Processes)

### 4.1 æ¦‚å¿µ

é€šè¿‡ Channel é€šä¿¡çš„ç‹¬ç«‹è¿›ç¨‹ã€‚

**ç‰¹æ€§**:
- âœ… æ˜¾å¼é€šä¿¡
- âœ… æ— å…±äº«çŠ¶æ€
- âœ… æ­»é”æ£€æµ‹

---

### 4.2 Select æ¨¡å¼

```rust
use tokio::sync::mpsc;
use tokio::select;

async fn csp_example() {
    let (tx1, mut rx1) = mpsc::channel(10);
    let (tx2, mut rx2) = mpsc::channel(10);
    
    // ç”Ÿäº§è€…
    tokio::spawn(async move {
        for i in 0..10 {
            tx1.send(i).await.unwrap();
        }
    });
    
    tokio::spawn(async move {
        for i in 10..20 {
            tx2.send(i).await.unwrap();
        }
    });
    
    // æ¶ˆè´¹è€… - select å¤šä¸ª channel
    loop {
        select! {
            Some(v) = rx1.recv() => {
                println!("From channel 1: {}", v);
            }
            Some(v) = rx2.recv() => {
                println!("From channel 2: {}", v);
            }
            else => break,
        }
    }
}
```

---

## 5. å¯¹è±¡æ± æ¨¡å¼

### 5.1 æ¦‚å¿µ

å¤ç”¨æ˜‚è´µå¯¹è±¡ä»¥å‡å°‘åˆ†é…å¼€é”€ã€‚

---

### 5.2 å®ç°

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

struct Pool<T> {
    objects: Arc<Mutex<Vec<T>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
}

impl<T: Send + 'static> Pool<T> {
    fn new<F>(factory: F) -> Self 
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        Self {
            objects: Arc::new(Mutex::new(Vec::new())),
            factory: Arc::new(factory),
        }
    }
    
    async fn acquire(&self) -> PooledObject<T> {
        let mut objects = self.objects.lock().await;
        let object = objects.pop().unwrap_or_else(|| (self.factory)());
        
        PooledObject {
            object: Some(object),
            pool: Arc::clone(&self.objects),
        }
    }
}

struct PooledObject<T> {
    object: Option<T>,
    pool: Arc<Mutex<Vec<T>>>,
}

impl<T> std::ops::Deref for PooledObject<T> {
    type Target = T;
    fn deref(&self) -> &T {
        self.object.as_ref().unwrap()
    }
}

impl<T> Drop for PooledObject<T> {
    fn drop(&mut self) {
        if let Some(object) = self.object.take() {
            let pool = Arc::clone(&self.pool);
            tokio::spawn(async move {
                pool.lock().await.push(object);
            });
        }
    }
}
```

---

## 6. Work Stealing

### 6.1 æ¦‚å¿µ

ç©ºé—²çº¿ç¨‹ä»ç¹å¿™çº¿ç¨‹"å·"ä»»åŠ¡ã€‚

**ä¼˜åŠ¿**:
- âœ… è´Ÿè½½å‡è¡¡
- âœ… æé«˜ååé‡
- âœ… å‡å°‘ç©ºé—²æ—¶é—´

**Tokio å†…ç½®**: Tokio çš„å¤šçº¿ç¨‹è¿è¡Œæ—¶ä½¿ç”¨ work-stealing è°ƒåº¦å™¨ã€‚

---

## 7. ååº”å¼ç¼–ç¨‹

### 7.1 æ¦‚å¿µ

åŸºäºæ•°æ®æµå’Œå˜åŒ–ä¼ æ’­ã€‚

---

### 7.2 ä½¿ç”¨ futures-rs

```rust
use futures::stream::{self, StreamExt};

async fn reactive_example() {
    let stream = stream::iter(0..100)
        .filter(|x| async move { x % 2 == 0 })
        .map(|x| x * 2)
        .take(10);
    
    let results: Vec<_> = stream.collect().await;
    println!("{:?}", results);
}
```

---

## 8. é”™è¯¯å¤„ç†æ¨¡å¼

### 8.1 Supervisor æ¨¡å¼

```rust
use tokio::task::JoinHandle;

struct Supervisor {
    tasks: Vec<JoinHandle<()>>,
}

impl Supervisor {
    fn new() -> Self {
        Self { tasks: Vec::new() }
    }
    
    fn spawn<F>(&mut self, future: F)
    where
        F: std::future::Future<Output = ()> + Send + 'static,
    {
        let handle = tokio::spawn(async move {
            // é”™è¯¯æ¢å¤é€»è¾‘
            match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                // æ‰§è¡Œä»»åŠ¡
            })) {
                Ok(_) => {},
                Err(e) => {
                    eprintln!("Task panicked: {:?}", e);
                    // é‡å¯ä»»åŠ¡
                }
            }
        });
        
        self.tasks.push(handle);
    }
    
    async fn wait_all(self) {
        for task in self.tasks {
            let _ = task.await;
        }
    }
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- **[å¼‚æ­¥è®¾è®¡æ¨¡å¼å®è·µ](../tier_02_guides/04_å¼‚æ­¥è®¾è®¡æ¨¡å¼å®è·µ.md)** - åŸºç¡€æ¨¡å¼
- **[å¼‚æ­¥ç³»ç»Ÿæ¶æ„](./02_å¼‚æ­¥ç³»ç»Ÿæ¶æ„.md)** - ç³»ç»Ÿçº§è®¾è®¡
- **[Tokioå®Œæ•´APIå‚è€ƒ](../tier_03_references/02_Tokioå®Œæ•´APIå‚è€ƒ.md)** - APIè¯¦è§£

---

## ğŸ“ æ€»ç»“

**æ ¸å¿ƒæ¨¡å¼**:
- âœ… Actor - çŠ¶æ€å°è£…
- âœ… Reactor - äº‹ä»¶é©±åŠ¨
- âœ… Pipeline - æµå¼å¤„ç†
- âœ… CSP - Channel é€šä¿¡
- âœ… å¯¹è±¡æ±  - èµ„æºå¤ç”¨
- âœ… Work Stealing - è´Ÿè½½å‡è¡¡

**é€‰æ‹©åŸåˆ™**:
- Actor: å¤æ‚çŠ¶æ€ç®¡ç†
- Reactor: é«˜å¹¶å‘ç½‘ç»œæœåŠ¡
- Pipeline: æ•°æ®å¤„ç†æµ
- CSP: æ˜¾å¼é€šä¿¡
- å¯¹è±¡æ± : æ˜‚è´µèµ„æº

---

**æ–‡æ¡£ç»´æŠ¤**: C06 Async Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **Rust ç‰ˆæœ¬**: 1.90+

