# Tier 4: å¼‚æ­¥æ€§èƒ½å·¥ç¨‹

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 4 - é«˜çº§ä¸»é¢˜ | **æ–‡æ¡£ç±»å‹**: ğŸš€ æ€§èƒ½ä¼˜åŒ–

---

## ğŸ¯ æ–‡æ¡£è¯´æ˜

æ·±å…¥å¼‚æ­¥ç¨‹åºçš„æè‡´æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ã€‚

---

## 1. é›¶æ‹·è´ I/O

### 1.1 ä½¿ç”¨ `bytes::Bytes`

```rust
use bytes::Bytes;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn zero_copy_example(mut stream: TcpStream) -> std::io::Result<()> {
    let mut buf = BytesMut::with_capacity(4096);
    stream.read_buf(&mut buf).await?;
    
    // é›¶æ‹·è´åˆ‡ç‰‡
    let slice = buf.freeze();
    stream.write_all(&slice).await?;
    
    Ok(())
}
```

---

### 1.2 sendfile

```rust
use std::os::unix::io::AsRawFd;

async fn sendfile_example(file: &File, socket: &TcpStream) {
    let file_fd = file.as_raw_fd();
    let socket_fd = socket.as_raw_fd();
    
    // å†…æ ¸ç›´æ¥ä¼ è¾“ï¼Œæ— ç”¨æˆ·æ€æ‹·è´
    unsafe {
        libc::sendfile(socket_fd, file_fd, std::ptr::null_mut(), file_size);
    }
}
```

---

## 2. å†…å­˜æ± 

### 2.1 è‡ªå®šä¹‰åˆ†é…å™¨

```rust
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;
```

---

### 2.2 å¯¹è±¡å¤ç”¨

```rust
struct BufferPool {
    pool: Mutex<Vec<Vec<u8>>>,
}

impl BufferPool {
    fn acquire(&self) -> Vec<u8> {
        self.pool.lock().unwrap()
            .pop()
            .unwrap_or_else(|| Vec::with_capacity(4096))
    }
    
    fn release(&self, mut buf: Vec<u8>) {
        buf.clear();
        self.pool.lock().unwrap().push(buf);
    }
}
```

---

## 3. æ‰¹å¤„ç†

### 3.1 æ‰¹é‡æ“ä½œ

```rust
async fn batch_insert(pool: &PgPool, records: Vec<Record>) {
    const BATCH_SIZE: usize = 1000;
    
    for chunk in records.chunks(BATCH_SIZE) {
        let mut query = sqlx::query("INSERT INTO records VALUES ");
        
        for (i, record) in chunk.iter().enumerate() {
            if i > 0 {
                query = query.sql(",");
            }
            query = query.sql(&format!("({}, '{}')", record.id, record.name));
        }
        
        query.execute(pool).await.unwrap();
    }
}
```

---

## 4. å¼‚æ­¥èšåˆ

### 4.1 Coalescing

```rust
use tokio::sync::Mutex;
use std::collections::HashMap;

struct Coalescer<K, V> {
    pending: Mutex<HashMap<K, Vec<oneshot::Sender<V>>>>,
}

impl<K: Eq + Hash, V: Clone> Coalescer<K, V> {
    async fn get(&self, key: K, fetch: impl Future<Output = V>) -> V {
        let (tx, rx) = oneshot::channel();
        
        {
            let mut pending = self.pending.lock().await;
            let senders = pending.entry(key).or_insert_with(Vec::new);
            
            if senders.is_empty() {
                // é¦–æ¬¡è¯·æ±‚ï¼Œå¯åŠ¨è·å–
                tokio::spawn(async move {
                    let value = fetch.await;
                    // é€šçŸ¥æ‰€æœ‰ç­‰å¾…è€…
                });
            }
            
            senders.push(tx);
        }
        
        rx.await.unwrap()
    }
}
```

---

## 5. æ— é”æ•°æ®ç»“æ„

### 5.1 Lock-Free Queue

```rust
use crossbeam::queue::SegQueue;

struct LockFreeQueue<T> {
    queue: Arc<SegQueue<T>>,
}

impl<T> LockFreeQueue<T> {
    fn push(&self, value: T) {
        self.queue.push(value);
    }
    
    fn pop(&self) -> Option<T> {
        self.queue.pop()
    }
}
```

---

## 6. SIMD ä¼˜åŒ–

### 6.1 æ•°æ®å¹¶è¡Œ

```rust
use std::simd::*;

fn simd_sum(data: &[f32]) -> f32 {
    let mut sum = f32x8::splat(0.0);
    
    for chunk in data.chunks_exact(8) {
        let vec = f32x8::from_slice(chunk);
        sum += vec;
    }
    
    sum.horizontal_sum()
}
```

---

## 7. é¢„å–ä¼˜åŒ–

### 7.1 Prefetching

```rust
#[inline(always)]
fn prefetch<T>(ptr: *const T) {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        std::arch::x86_64::_mm_prefetch(
            ptr as *const i8,
            std::arch::x86_64::_MM_HINT_T0,
        );
    }
}
```

---

## 8. CPU äº²å’Œæ€§

### 8.1 çº¿ç¨‹ç»‘å®š

```rust
use core_affinity;

fn pin_to_core(core_id: usize) {
    let core_ids = core_affinity::get_core_ids().unwrap();
    core_affinity::set_for_current(core_ids[core_id]);
}
```

---

## 9. æ€§èƒ½åˆ†æ

### 9.1 ç«ç„°å›¾

```bash
# ç”Ÿæˆç«ç„°å›¾
cargo flamegraph --bin myapp

# perf åˆ†æ
perf record -F 99 -g -- ./target/release/myapp
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg
```

---

### 9.2 CPU æ€§èƒ½è®¡æ•°å™¨

```rust
use pprof::ProfilerGuard;

async fn profile_section() {
    let guard = ProfilerGuard::new(100).unwrap();
    
    // è¢«åˆ†æçš„ä»£ç 
    heavy_work().await;
    
    // ç”ŸæˆæŠ¥å‘Š
    if let Ok(report) = guard.report().build() {
        let file = std::fs::File::create("profile.pb").unwrap();
        report.pprof().unwrap().write_to_writer(&mut file).unwrap();
    }
}
```

---

## 10. ç½‘ç»œä¼˜åŒ–

### 10.1 TCP å‚æ•°è°ƒä¼˜

```rust
use tokio::net::TcpStream;
use socket2::{Socket, Domain, Type};

async fn optimize_tcp(stream: &TcpStream) -> std::io::Result<()> {
    let socket = Socket::from(stream.as_raw_fd());
    
    // TCP_NODELAY (ç¦ç”¨ Nagle ç®—æ³•)
    socket.set_nodelay(true)?;
    
    // SO_SNDBUF / SO_RCVBUF
    socket.set_send_buffer_size(262144)?;
    socket.set_recv_buffer_size(262144)?;
    
    Ok(())
}
```

---

### 10.2 io_uring (Linux)

```rust
use tokio_uring::fs::File;

async fn io_uring_read() {
    let file = File::open("data.txt").await.unwrap();
    let buf = vec![0u8; 4096];
    
    let (res, buf) = file.read_at(buf, 0).await;
    let n = res.unwrap();
    
    println!("Read {} bytes", n);
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- **[å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../tier_02_guides/05_å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md)** - åŸºç¡€ä¼˜åŒ–
- **[æ€§èƒ½åŸºå‡†å‚è€ƒ](../tier_03_references/05_æ€§èƒ½åŸºå‡†å‚è€ƒ.md)** - åŸºå‡†æ•°æ®
- **[å¼‚æ­¥è°ƒè¯•ä¸ç›‘æ§](../tier_02_guides/06_å¼‚æ­¥è°ƒè¯•ä¸ç›‘æ§.md)** - æ€§èƒ½åˆ†æ

---

## ğŸ“ æ€»ç»“

**æ ¸å¿ƒæŠ€æœ¯**:

- âœ… é›¶æ‹·è´ I/O - å‡å°‘å†…å­˜æ‹·è´
- âœ… å†…å­˜æ±  - å¯¹è±¡å¤ç”¨
- âœ… æ‰¹å¤„ç† - å‡å°‘ç³»ç»Ÿè°ƒç”¨
- âœ… æ— é”ç»“æ„ - é¿å…ç«äº‰
- âœ… SIMD - æ•°æ®å¹¶è¡Œ
- âœ… CPU äº²å’Œæ€§ - ç¼“å­˜å±€éƒ¨æ€§
- âœ… ç½‘ç»œè°ƒä¼˜ - TCP ä¼˜åŒ–

**æ€§èƒ½å·¥å…·**:

- flamegraph
- perf
- pprof
- tokio-console

**ä¼˜åŒ–åŸåˆ™**:

- æµ‹é‡å…ˆè¡Œ
- æ¸è¿›ä¼˜åŒ–
- æƒè¡¡å–èˆ

---

**æ–‡æ¡£ç»´æŠ¤**: C06 Async Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **Rust ç‰ˆæœ¬**: 1.90+
