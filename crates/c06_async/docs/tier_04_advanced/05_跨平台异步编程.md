# Tier 4: 跨平台异步编程

> **文档版本**: Rust 1.90+ | **更新日期**: 2025-10-22
> **文档层级**: Tier 4 - 高级主题 | **文档类型**: 🚀 平台适配

---

## 📊 目录

- [Tier 4: 跨平台异步编程](#tier-4-跨平台异步编程)
  - [📊 目录](#-目录)
  - [🎯 文档说明](#-文档说明)
  - [1. 平台特定 I/O](#1-平台特定-io)
    - [1.1 条件编译](#11-条件编译)
  - [2. 信号处理](#2-信号处理)
    - [2.1 Unix 信号](#21-unix-信号)
    - [2.2 Windows 信号](#22-windows-信号)
  - [3. 文件系统](#3-文件系统)
    - [3.1 跨平台路径](#31-跨平台路径)
  - [4. 网络编程](#4-网络编程)
    - [4.1 平台特定 API](#41-平台特定-api)
  - [5. 线程模型](#5-线程模型)
    - [5.1 平台差异](#51-平台差异)
  - [6. WASM 支持](#6-wasm-支持)
    - [6.1 wasm-bindgen](#61-wasm-bindgen)
  - [7. Android/iOS](#7-androidios)
    - [7.1 Android (JNI)](#71-android-jni)
    - [7.2 iOS (Swift 互操作)](#72-ios-swift-互操作)
  - [8. 嵌入式系统](#8-嵌入式系统)
    - [8.1 no\_std 支持](#81-no_std-支持)
  - [9. 测试策略](#9-测试策略)
    - [9.1 条件测试](#91-条件测试)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 抽象层](#101-抽象层)
    - [10.2 Feature Flags](#102-feature-flags)
  - [📚 延伸阅读](#-延伸阅读)
  - [📝 总结](#-总结)

## 🎯 文档说明

处理不同操作系统和平台的异步编程差异。

---

## 1. 平台特定 I/O

### 1.1 条件编译

```rust
#[cfg(unix)]
use tokio::net::UnixStream;

#[cfg(windows)]
use tokio::net::windows::named_pipe::NamedPipeClient;

async fn platform_specific_io() -> std::io::Result<()> {
    #[cfg(unix)]
    {
        let stream = UnixStream::connect("/tmp/socket").await?;
    }

    #[cfg(windows)]
    {
        let client = NamedPipeClient::connect(r"\\.\pipe\mypipe").await?;
    }

    Ok(())
}
```

---

## 2. 信号处理

### 2.1 Unix 信号

```rust
#[cfg(unix)]
async fn handle_unix_signals() {
    use tokio::signal::unix::{signal, SignalKind};

    let mut sigterm = signal(SignalKind::terminate()).unwrap();
    let mut sigint = signal(SignalKind::interrupt()).unwrap();

    tokio::select! {
        _ = sigterm.recv() => println!("SIGTERM received"),
        _ = sigint.recv() => println!("SIGINT received"),
    }
}
```

---

### 2.2 Windows 信号

```rust
#[cfg(windows)]
async fn handle_windows_signals() {
    use tokio::signal::windows;

    let mut ctrl_c = windows::ctrl_c().unwrap();
    let mut ctrl_break = windows::ctrl_break().unwrap();

    tokio::select! {
        _ = ctrl_c.recv() => println!("Ctrl-C received"),
        _ = ctrl_break.recv() => println!("Ctrl-Break received"),
    }
}
```

---

## 3. 文件系统

### 3.1 跨平台路径

```rust
use std::path::PathBuf;

fn cross_platform_path() -> PathBuf {
    #[cfg(windows)]
    let path = PathBuf::from(r"C:\Users\user\file.txt");

    #[cfg(unix)]
    let path = PathBuf::from("/home/user/file.txt");

    path
}
```

---

## 4. 网络编程

### 4.1 平台特定 API

```rust
// Windows: IOCP
#[cfg(windows)]
async fn windows_network() {
    use tokio::net::TcpSocket;

    let socket = TcpSocket::new_v4().unwrap();
    // IOCP 自动使用
}

// Linux: epoll
#[cfg(target_os = "linux")]
async fn linux_network() {
    // epoll 自动使用
}

// macOS: kqueue
#[cfg(target_os = "macos")]
async fn macos_network() {
    // kqueue 自动使用
}
```

---

## 5. 线程模型

### 5.1 平台差异

```rust
fn configure_runtime() -> tokio::runtime::Runtime {
    #[cfg(target_os = "linux")]
    {
        tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cpus::get())
            .build()
            .unwrap()
    }

    #[cfg(target_os = "windows")]
    {
        tokio::runtime::Builder::new_multi_thread()
            .worker_threads((num_cpus::get() * 3) / 2) // Windows 超线程
            .build()
            .unwrap()
    }

    #[cfg(not(any(target_os = "linux", target_os = "windows")))]
    {
        tokio::runtime::Runtime::new().unwrap()
    }
}
```

---

## 6. WASM 支持

### 6.1 wasm-bindgen

```rust
#[cfg(target_arch = "wasm32")]
use wasm_bindgen::prelude::*;

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
pub async fn fetch_data() -> Result<String, JsValue> {
    let window = web_sys::window().unwrap();
    let resp_value = JsFuture::from(
        window.fetch_with_str("https://api.example.com/data")
    ).await?;

    let resp: web_sys::Response = resp_value.dyn_into()?;
    let text = JsFuture::from(resp.text()?).await?;

    Ok(text.as_string().unwrap())
}
```

---

## 7. Android/iOS

### 7.1 Android (JNI)

```rust
#[cfg(target_os = "android")]
use jni::JNIEnv;

#[cfg(target_os = "android")]
#[no_mangle]
pub extern "C" fn Java_com_example_MyClass_asyncTask(
    env: JNIEnv,
    _class: jni::objects::JClass,
) {
    let runtime = tokio::runtime::Runtime::new().unwrap();
    runtime.block_on(async {
        // 异步任务
    });
}
```

---

### 7.2 iOS (Swift 互操作)

```rust
#[cfg(target_os = "ios")]
#[no_mangle]
pub extern "C" fn rust_async_task(callback: extern "C" fn(*const i8)) {
    let runtime = tokio::runtime::Runtime::new().unwrap();
    runtime.spawn(async move {
        let result = async_operation().await;
        let c_str = CString::new(result).unwrap();
        callback(c_str.as_ptr());
    });
}
```

---

## 8. 嵌入式系统

### 8.1 no_std 支持

```rust
#![no_std]

use embassy_executor::Spawner;
use embassy_time::{Duration, Timer};

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    loop {
        // 异步延时
        Timer::after(Duration::from_millis(1000)).await;
    }
}
```

---

## 9. 测试策略

### 9.1 条件测试

```rust
#[cfg(unix)]
#[tokio::test]
async fn test_unix_specific() {
    // Unix 特定测试
}

#[cfg(windows)]
#[tokio::test]
async fn test_windows_specific() {
    // Windows 特定测试
}

#[tokio::test]
async fn test_cross_platform() {
    // 跨平台测试
}
```

---

## 10. 最佳实践

### 10.1 抽象层

```rust
#[cfg(unix)]
mod platform {
    pub type PlatformStream = tokio::net::UnixStream;
    pub async fn connect(path: &str) -> std::io::Result<PlatformStream> {
        PlatformStream::connect(path).await
    }
}

#[cfg(windows)]
mod platform {
    pub type PlatformStream = tokio::net::windows::named_pipe::NamedPipeClient;
    pub async fn connect(path: &str) -> std::io::Result<PlatformStream> {
        PlatformStream::connect(path).await
    }
}

// 统一接口
async fn use_platform_stream() {
    let stream = platform::connect("path").await.unwrap();
}
```

---

### 10.2 Feature Flags

```toml
[features]
default = ["tokio-runtime"]
tokio-runtime = ["tokio"]
async-std-runtime = ["async-std"]
smol-runtime = ["smol"]
```

```rust
#[cfg(feature = "tokio-runtime")]
use tokio::runtime::Runtime;

#[cfg(feature = "async-std-runtime")]
use async_std::task;
```

---

## 📚 延伸阅读

- **[异步运行时选择指南](../tier_02_guides/03_异步运行时选择指南.md)** - 运行时对比
- **[Tokio完整API参考](../tier_03_references/02_Tokio完整API参考.md)** - Tokio API
- [Rust 平台支持](https://doc.rust-lang.org/nightly/rustc/platform-support.html)

---

## 📝 总结

**核心策略**:

- ✅ 条件编译 - 平台特定代码
- ✅ 抽象层 - 统一接口
- ✅ Feature Flags - 运行时选择
- ✅ 测试覆盖 - 多平台测试

**支持平台**:

- ✅ Linux/Unix - epoll
- ✅ Windows - IOCP
- ✅ macOS - kqueue
- ✅ WASM - 浏览器
- ✅ Android/iOS - 移动端
- ✅ 嵌入式 - no_std

**注意事项**:

- 信号处理差异
- 文件系统差异
- 网络 API 差异
- 线程模型差异

---

**文档维护**: C06 Async Team | **质量评分**: 95/100
**最后更新**: 2025-10-22 | **Rust 版本**: 1.90+
