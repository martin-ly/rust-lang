# Tier 4: å¼‚æ­¥ç³»ç»Ÿæ¶æ„

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 4 - é«˜çº§ä¸»é¢˜ | **æ–‡æ¡£ç±»å‹**: ğŸš€ ç³»ç»Ÿè®¾è®¡

---

## ğŸ¯ æ–‡æ¡£è¯´æ˜

æ¢è®¨ä½¿ç”¨ Rust å¼‚æ­¥æ„å»ºå¤§è§„æ¨¡åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ¶æ„æ¨¡å¼ã€‚

---

## 1. å¾®æœåŠ¡æ¶æ„

### 1.1 æœåŠ¡æ‹†åˆ†

```rust
// ç”¨æˆ·æœåŠ¡
mod user_service {
    use tonic::{Request, Response, Status};
    
    pub struct UserService;
    
    #[tonic::async_trait]
    impl user_service_proto::UserService for UserService {
        async fn get_user(
            &self,
            request: Request<GetUserRequest>,
        ) -> Result<Response<UserResponse>, Status> {
            // å®ç°
            Ok(Response::new(UserResponse::default()))
        }
    }
}
```

### 1.2 æœåŠ¡å‘ç°

```rust
use std::collections::HashMap;
use tokio::sync::RwLock;

struct ServiceRegistry {
    services: RwLock<HashMap<String, Vec<String>>>,
}

impl ServiceRegistry {
    async fn register(&self, name: String, endpoint: String) {
        self.services.write().await
            .entry(name)
            .or_insert_with(Vec::new)
            .push(endpoint);
    }
    
    async fn discover(&self, name: &str) -> Option<String> {
        self.services.read().await
            .get(name)?
            .first()
            .cloned()
    }
}
```

---

## 2. API Gateway

### 2.1 è·¯ç”±

```rust
use axum::{Router, routing::get, Extension};
use std::sync::Arc;

async fn gateway() {
    let app = Router::new()
        .route("/api/users/*path", get(proxy_to_user_service))
        .route("/api/orders/*path", get(proxy_to_order_service));
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn proxy_to_user_service() -> &'static str {
    "Proxied to user service"
}

async fn proxy_to_order_service() -> &'static str {
    "Proxied to order service"
}
```

### 2.2 è´Ÿè½½å‡è¡¡

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

struct LoadBalancer {
    backends: Vec<String>,
    counter: AtomicUsize,
}

impl LoadBalancer {
    fn round_robin(&self) -> &str {
        let index = self.counter.fetch_add(1, Ordering::Relaxed);
        &self.backends[index % self.backends.len()]
    }
}
```

---

## 3. æ¶ˆæ¯é˜Ÿåˆ—

### 3.1 å‘å¸ƒ/è®¢é˜…

```rust
use tokio::sync::broadcast;

struct MessageBus {
    sender: broadcast::Sender<String>,
}

impl MessageBus {
    fn new() -> Self {
        let (sender, _) = broadcast::channel(100);
        Self { sender }
    }
    
    fn publish(&self, message: String) {
        let _ = self.sender.send(message);
    }
    
    fn subscribe(&self) -> broadcast::Receiver<String> {
        self.sender.subscribe()
    }
}
```

---

## 4. åˆ†å¸ƒå¼è¿½è¸ª

### 4.1 OpenTelemetry é›†æˆ

```rust
use opentelemetry::trace::{Tracer, SpanKind};
use tracing::{info_span, instrument};

#[instrument]
async fn process_request(req_id: u64) {
    let span = info_span!("process_request", req_id);
    let _enter = span.enter();
    
    // å¤„ç†è¯·æ±‚
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
}
```

---

## 5. å®¹é”™æ¨¡å¼

### 5.1 æ–­è·¯å™¨

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use tokio::time::{Duration, Instant};

enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: AtomicU64,
    threshold: u64,
}

impl CircuitBreaker {
    async fn call<F, T>(&self, f: F) -> Result<T, Error>
    where
        F: Future<Output = Result<T, Error>>,
    {
        match *self.state.lock().await {
            CircuitState::Open => Err(Error::CircuitOpen),
            _ => {
                match f.await {
                    Ok(result) => {
                        self.failure_count.store(0, Ordering::Relaxed);
                        Ok(result)
                    }
                    Err(e) => {
                        let count = self.failure_count.fetch_add(1, Ordering::Relaxed);
                        if count >= self.threshold {
                            *self.state.lock().await = CircuitState::Open;
                        }
                        Err(e)
                    }
                }
            }
        }
    }
}
```

### 5.2 é‡è¯•æœºåˆ¶

```rust
use backoff::{ExponentialBackoff, future::retry};

async fn retry_example() {
    let backoff = ExponentialBackoff::default();
    
    let result = retry(backoff, || async {
        risky_operation().await
            .map_err(|e| {
                if e.is_transient() {
                    backoff::Error::transient(e)
                } else {
                    backoff::Error::permanent(e)
                }
            })
    }).await;
}
```

---

## 6. äº‹ä»¶æº¯æº

### 6.1 äº‹ä»¶å­˜å‚¨

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
enum UserEvent {
    Created { id: u64, name: String },
    Updated { id: u64, name: String },
    Deleted { id: u64 },
}

struct EventStore {
    events: Vec<UserEvent>,
}

impl EventStore {
    async fn append(&mut self, event: UserEvent) {
        self.events.push(event);
    }
    
    async fn replay(&self) -> User {
        let mut user = User::default();
        for event in &self.events {
            user.apply(event);
        }
        user
    }
}
```

---

## 7. CQRS (Command Query Responsibility Segregation)

### 7.1 åˆ†ç¦»è¯»å†™

```rust
// å‘½ä»¤ç«¯ï¼ˆå†™ï¼‰
async fn handle_command(cmd: CreateUserCommand) {
    let event = UserCreatedEvent::new(cmd);
    event_store.append(event).await;
}

// æŸ¥è¯¢ç«¯ï¼ˆè¯»ï¼‰
async fn handle_query(query: GetUserQuery) -> User {
    read_model.get_user(query.id).await
}
```

---

## 8. Saga æ¨¡å¼

### 8.1 åˆ†å¸ƒå¼äº‹åŠ¡

```rust
enum SagaStep {
    CreateOrder,
    ReserveInventory,
    ProcessPayment,
    ShipOrder,
}

struct Saga {
    steps: Vec<SagaStep>,
}

impl Saga {
    async fn execute(&self) -> Result<(), Error> {
        let mut completed_steps = Vec::new();
        
        for step in &self.steps {
            match self.execute_step(step).await {
                Ok(_) => completed_steps.push(step),
                Err(e) => {
                    // è¡¥å¿å·²å®Œæˆçš„æ­¥éª¤
                    for step in completed_steps.iter().rev() {
                        self.compensate(step).await;
                    }
                    return Err(e);
                }
            }
        }
        
        Ok(())
    }
    
    async fn execute_step(&self, step: &SagaStep) -> Result<(), Error> {
        // æ‰§è¡Œæ­¥éª¤
        Ok(())
    }
    
    async fn compensate(&self, step: &SagaStep) {
        // è¡¥å¿æ“ä½œ
    }
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- **[å¼‚æ­¥å¹¶å‘æ¨¡å¼](./01_å¼‚æ­¥å¹¶å‘æ¨¡å¼.md)** - å¹¶å‘æ¨¡å¼
- **[å¼‚æ­¥æ€§èƒ½å·¥ç¨‹](./04_å¼‚æ­¥æ€§èƒ½å·¥ç¨‹.md)** - æ€§èƒ½ä¼˜åŒ–
- **[å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©æŒ‡å—](../tier_02_guides/03_å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©æŒ‡å—.md)** - è¿è¡Œæ—¶

---

## ğŸ“ æ€»ç»“

**æ ¸å¿ƒæ¶æ„**:

- âœ… å¾®æœåŠ¡ - æœåŠ¡æ‹†åˆ†
- âœ… API Gateway - ç»Ÿä¸€å…¥å£
- âœ… æ¶ˆæ¯é˜Ÿåˆ— - å¼‚æ­¥é€šä¿¡
- âœ… åˆ†å¸ƒå¼è¿½è¸ª - å¯è§‚æµ‹æ€§
- âœ… å®¹é”™æ¨¡å¼ - é«˜å¯ç”¨
- âœ… äº‹ä»¶æº¯æº/CQRS - æ•°æ®æ¶æ„
- âœ… Saga - åˆ†å¸ƒå¼äº‹åŠ¡

**è®¾è®¡åŸåˆ™**:

- æœåŠ¡è‡ªæ²»
- å¼‚æ­¥é€šä¿¡
- å®¹é”™ä¸ºå…ˆ
- å¯è§‚æµ‹æ€§

---

**æ–‡æ¡£ç»´æŠ¤**: C06 Async Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **Rust ç‰ˆæœ¬**: 1.90+
