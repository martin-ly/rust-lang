# C06 Async å¸¸è§é—®é¢˜

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 1 - åŸºç¡€æ¦‚å¿µ | **æ–‡æ¡£ç±»å‹**: â“ FAQå‚è€ƒ

---

## ğŸ¯ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£æ”¶é›† C06 Async æ¨¡å—æœ€å¸¸è§çš„é—®é¢˜å’Œè§£ç­”ï¼ŒæŒ‰ä¸»é¢˜åˆ†ç±»ï¼Œå¸®åŠ©æ‚¨å¿«é€Ÿè§£å†³ç–‘æƒ‘ã€‚

**é—®é¢˜ç»Ÿè®¡**: 35+ æ ¸å¿ƒé—®é¢˜ | æ¶µç›– 8 å¤§ç±»åˆ« | å¸¦ä»£ç ç¤ºä¾‹ | æŒç»­æ›´æ–°

---

## ğŸ“‘ ç›®å½•

- [C06 Async å¸¸è§é—®é¢˜](#c06-async-å¸¸è§é—®é¢˜)
  - [ğŸ¯ æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. åŸºç¡€æ¦‚å¿µ](#1-åŸºç¡€æ¦‚å¿µ)
    - [Q1.1: `async/await` å’Œæ™®é€šçš„çº¿ç¨‹æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿæˆ‘åº”è¯¥ç”¨å“ªä¸ªï¼Ÿ](#q11-asyncawait-å’Œæ™®é€šçš„çº¿ç¨‹æœ‰ä»€ä¹ˆåŒºåˆ«æˆ‘åº”è¯¥ç”¨å“ªä¸ª)
    - [Q1.2: ä»€ä¹ˆæ—¶å€™ä¸åº”è¯¥ä½¿ç”¨ `async/await`ï¼Ÿ](#q12-ä»€ä¹ˆæ—¶å€™ä¸åº”è¯¥ä½¿ç”¨-asyncawait)
    - [Q1.3: `Future` ä»€ä¹ˆæ—¶å€™å¼€å§‹æ‰§è¡Œï¼Ÿ](#q13-future-ä»€ä¹ˆæ—¶å€™å¼€å§‹æ‰§è¡Œ)
    - [Q1.4: `.await` å’Œ `poll()` æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q14-await-å’Œ-poll-æœ‰ä»€ä¹ˆåŒºåˆ«)
    - [Q1.5: `async fn` è¿”å›çš„æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ](#q15-async-fn-è¿”å›çš„æ˜¯ä»€ä¹ˆç±»å‹)
  - [2. è¿è¡Œæ—¶é€‰æ‹©](#2-è¿è¡Œæ—¶é€‰æ‹©)
    - [Q2.1: Tokioã€async-std å’Œ Smol å¦‚ä½•é€‰æ‹©ï¼Ÿ](#q21-tokioasync-std-å’Œ-smol-å¦‚ä½•é€‰æ‹©)
    - [Q2.2: å¯ä»¥åœ¨åŒä¸€é¡¹ç›®ä¸­æ··ç”¨å¤šä¸ªè¿è¡Œæ—¶å—ï¼Ÿ](#q22-å¯ä»¥åœ¨åŒä¸€é¡¹ç›®ä¸­æ··ç”¨å¤šä¸ªè¿è¡Œæ—¶å—)
    - [Q2.3: å¦‚ä½•é€‰æ‹©å•çº¿ç¨‹è¿˜æ˜¯å¤šçº¿ç¨‹è¿è¡Œæ—¶ï¼Ÿ](#q23-å¦‚ä½•é€‰æ‹©å•çº¿ç¨‹è¿˜æ˜¯å¤šçº¿ç¨‹è¿è¡Œæ—¶)
  - [3. Pin ä¸å†…å­˜å®‰å…¨](#3-pin-ä¸å†…å­˜å®‰å…¨)
    - [Q3.1: ä¸ºä»€ä¹ˆæˆ‘éœ€è¦ `Pin`ï¼Ÿå®ƒçœ‹èµ·æ¥éå¸¸å¤æ‚](#q31-ä¸ºä»€ä¹ˆæˆ‘éœ€è¦-pinå®ƒçœ‹èµ·æ¥éå¸¸å¤æ‚)
    - [Q3.2: ä»€ä¹ˆæ˜¯ `Unpin`ï¼Ÿ](#q32-ä»€ä¹ˆæ˜¯-unpin)
    - [Q3.3: å¦‚ä½•è·å– `Pin<&mut T>` ä¸­çš„ `&mut T`ï¼Ÿ](#q33-å¦‚ä½•è·å–-pinmut-t-ä¸­çš„-mut-t)
  - [4. æ€§èƒ½ä¸ä¼˜åŒ–](#4-æ€§èƒ½ä¸ä¼˜åŒ–)
    - [Q4.1: å¦‚ä½•åœ¨ `async` ä»£ç ä¸­æ‰§è¡Œ CPU å¯†é›†å‹ä»»åŠ¡ï¼Ÿ](#q41-å¦‚ä½•åœ¨-async-ä»£ç ä¸­æ‰§è¡Œ-cpu-å¯†é›†å‹ä»»åŠ¡)
    - [Q4.2: å¦‚ä½•ä¼˜åŒ– Tokio è¿è¡Œæ—¶æ€§èƒ½ï¼Ÿ](#q42-å¦‚ä½•ä¼˜åŒ–-tokio-è¿è¡Œæ—¶æ€§èƒ½)
    - [Q4.3: å¦‚ä½•æµ‹é‡å¼‚æ­¥ä»£ç çš„æ€§èƒ½ï¼Ÿ](#q43-å¦‚ä½•æµ‹é‡å¼‚æ­¥ä»£ç çš„æ€§èƒ½)
  - [5. é”™è¯¯å¤„ç†ä¸è°ƒè¯•](#5-é”™è¯¯å¤„ç†ä¸è°ƒè¯•)
    - [Q5.1: å¦‚ä½•åœ¨å¼‚æ­¥ä»£ç ä¸­å¤„ç†é”™è¯¯ï¼Ÿ](#q51-å¦‚ä½•åœ¨å¼‚æ­¥ä»£ç ä¸­å¤„ç†é”™è¯¯)
    - [Q5.2: å¦‚ä½•è°ƒè¯•å¼‚æ­¥ä»£ç ï¼Ÿ](#q52-å¦‚ä½•è°ƒè¯•å¼‚æ­¥ä»£ç )
    - [Q5.3: å¦‚ä½•å¤„ç† Timeoutï¼Ÿ](#q53-å¦‚ä½•å¤„ç†-timeout)
  - [6. è®¾è®¡æ¨¡å¼ä¸æœ€ä½³å®è·µ](#6-è®¾è®¡æ¨¡å¼ä¸æœ€ä½³å®è·µ)
    - [Q6.1: ä¸ºä»€ä¹ˆæˆ‘çš„ `Future` æ²¡æœ‰æ‰§è¡Œï¼Ÿ](#q61-ä¸ºä»€ä¹ˆæˆ‘çš„-future-æ²¡æœ‰æ‰§è¡Œ)
    - [Q6.2: å¦‚ä½•åœ¨ `Drop` ä¸­æ‰§è¡Œå¼‚æ­¥æ¸…ç†ï¼Ÿ](#q62-å¦‚ä½•åœ¨-drop-ä¸­æ‰§è¡Œå¼‚æ­¥æ¸…ç†)
    - [Q6.3: å¦‚ä½•ä¼˜é›…å–æ¶ˆå¼‚æ­¥ä»»åŠ¡ï¼Ÿ](#q63-å¦‚ä½•ä¼˜é›…å–æ¶ˆå¼‚æ­¥ä»»åŠ¡)
  - [7. ç”Ÿæ€ç³»ç»Ÿä¸å…¼å®¹æ€§](#7-ç”Ÿæ€ç³»ç»Ÿä¸å…¼å®¹æ€§)
    - [Q7.1: Tokio å’Œ async-std çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—ï¼Ÿ](#q71-tokio-å’Œ-async-std-çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—)
    - [Q7.2: å¦‚ä½•ç¼–å†™è¿è¡Œæ—¶æ— å…³çš„å¼‚æ­¥åº“ï¼Ÿ](#q72-å¦‚ä½•ç¼–å†™è¿è¡Œæ—¶æ— å…³çš„å¼‚æ­¥åº“)
    - [Q7.3: `async-trait` crate æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ](#q73-async-trait-crate-æ˜¯åšä»€ä¹ˆçš„)
  - [8. é«˜çº§ä¸»é¢˜](#8-é«˜çº§ä¸»é¢˜)
    - [Q8.1: å¦‚ä½•æ‰‹åŠ¨å®ç° `Future`ï¼Ÿ](#q81-å¦‚ä½•æ‰‹åŠ¨å®ç°-future)
    - [Q8.2: å¦‚ä½•åœ¨ trait ä¸­å®šä¹‰å¼‚æ­¥æ–¹æ³•ï¼ˆRust 1.90ï¼‰ï¼Ÿ](#q82-å¦‚ä½•åœ¨-trait-ä¸­å®šä¹‰å¼‚æ­¥æ–¹æ³•rust-190)
    - [Q8.3: å¦‚ä½•å®ç° `AsyncDrop`ï¼Ÿ](#q83-å¦‚ä½•å®ç°-asyncdrop)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æ¨èé˜…è¯»](#æ¨èé˜…è¯»)
    - [ç¤¾åŒºèµ„æº](#ç¤¾åŒºèµ„æº)
  - [ğŸ“ è´¡çŒ®æŒ‡å—](#-è´¡çŒ®æŒ‡å—)

---

## 1. åŸºç¡€æ¦‚å¿µ

### Q1.1: `async/await` å’Œæ™®é€šçš„çº¿ç¨‹æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿæˆ‘åº”è¯¥ç”¨å“ªä¸ªï¼Ÿ

**å›ç­”**:

**æ ¸å¿ƒåŒºåˆ«**:

| ç‰¹æ€§ | çº¿ç¨‹ (`std::thread`) | `async/await` |
|------|----------------------|---------------|
| **è°ƒåº¦æ–¹å¼** | æŠ¢å å¼ï¼ˆOS è°ƒåº¦ï¼‰ | åä½œå¼ï¼ˆè¿è¡Œæ—¶è°ƒåº¦ï¼‰ |
| **å†…å­˜å¼€é”€** | æ¯ä¸ªçº¿ç¨‹ ~2MB æ ˆç©ºé—´ | æ¯ä¸ªä»»åŠ¡ ~KB çº§åˆ« |
| **é€‚ç”¨åœºæ™¯** | CPU å¯†é›†å‹ä»»åŠ¡ | I/O å¯†é›†å‹ä»»åŠ¡ |
| **å¹¶å‘æ•°é‡** | å—é™äºç³»ç»Ÿèµ„æºï¼ˆé€šå¸¸å‡ ç™¾ä¸ªï¼‰ | å¯è½»æ¾ç®¡ç†æ•°ä¸‡ä¸ªä»»åŠ¡ |
| **ä¸Šä¸‹æ–‡åˆ‡æ¢** | è¾ƒæ…¢ï¼ˆéœ€è¦å†…æ ¸æ€ï¼‰ | è¾ƒå¿«ï¼ˆç”¨æˆ·æ€ï¼‰ |

**ç¤ºä¾‹å¯¹æ¯”**:

```rust
// çº¿ç¨‹æ–¹å¼ (é€‚åˆ CPU å¯†é›†å‹)
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        // è®¡ç®—å¯†é›†å‹å·¥ä½œ
        heavy_computation()
    });
    handle.join().unwrap();
}

// async æ–¹å¼ (é€‚åˆ I/O å¯†é›†å‹)
#[tokio::main]
async fn main() {
    let handle = tokio::spawn(async {
        // I/O å¯†é›†å‹å·¥ä½œ
        fetch_data_from_network().await
    });
    handle.await.unwrap();
}
```

**é€‰æ‹©å»ºè®®**:

- **CPU å¯†é›†å‹ä»»åŠ¡**: ä½¿ç”¨çº¿ç¨‹æˆ– `rayon`ï¼ˆæ•°æ®å¹¶è¡Œï¼‰
- **I/O å¯†é›†å‹ä»»åŠ¡**: ä½¿ç”¨ `async/await`
- **æ··åˆåœºæ™¯**: åœ¨ `async` è¿è¡Œæ—¶ä¸­ä½¿ç”¨ `spawn_blocking` æ‰§è¡Œé˜»å¡ä»»åŠ¡

**ç›¸å…³é—®é¢˜**: [Q1.2](#q12-ä»€ä¹ˆæ—¶å€™ä¸åº”è¯¥ä½¿ç”¨-asyncawait), [Q4.1](#q41-å¦‚ä½•åœ¨-async-ä»£ç ä¸­æ‰§è¡Œ-cpu-å¯†é›†å‹ä»»åŠ¡)

---

### Q1.2: ä»€ä¹ˆæ—¶å€™ä¸åº”è¯¥ä½¿ç”¨ `async/await`ï¼Ÿ

**å›ç­”**:

ä»¥ä¸‹åœºæ™¯**ä¸é€‚åˆ**ä½¿ç”¨ `async`:

1. **çº¯ CPU å¯†é›†å‹è®¡ç®—**:

    ```rust
    // âŒ ä¸æ¨èï¼šasync æ— æ³•æå‡æ€§èƒ½
    async fn calculate_pi() -> f64 {
        // çº¯è®¡ç®—ï¼Œæ—  I/O
    }

    // âœ… æ¨èï¼šç›´æ¥ä½¿ç”¨çº¿ç¨‹æˆ– rayon
    fn calculate_pi_parallel() -> f64 {
        use rayon::prelude::*;
        // åˆ©ç”¨å¤šæ ¸å¹¶è¡Œè®¡ç®—
    }
    ```

2. **ç®€å•çš„å•ä»»åŠ¡ç¨‹åº**:

    ```rust
    // âŒ è¿‡åº¦å·¥ç¨‹ï¼šå¼•å…¥ä¸å¿…è¦çš„å¤æ‚æ€§
    #[tokio::main]
    async fn main() {
        println!("Hello, world!");
    }

    // âœ… ç®€å•ç›´æ¥
    fn main() {
        println!("Hello, world!");
    }
    ```

3. **ä¸é˜»å¡å¼ C åº“äº¤äº’**:

    ```rust
    // âŒ ä¸æ¨èï¼šé˜»å¡æ•´ä¸ªè¿è¡Œæ—¶
    async fn call_c_library() {
        unsafe { blocking_c_function() };
    }

    // âœ… æ¨èï¼šä½¿ç”¨ spawn_blocking
    async fn call_c_library_correctly() {
        tokio::task::spawn_blocking(|| {
            unsafe { blocking_c_function() }
        }).await.unwrap();
    }
    ```

**ç›¸å…³é—®é¢˜**: [Q1.1](#q11-asyncawait-å’Œæ™®é€šçš„çº¿ç¨‹æœ‰ä»€ä¹ˆåŒºåˆ«æˆ‘åº”è¯¥ç”¨å“ªä¸ª), [Q4.1](#q41-å¦‚ä½•åœ¨-async-ä»£ç ä¸­æ‰§è¡Œ-cpu-å¯†é›†å‹ä»»åŠ¡)

---

### Q1.3: `Future` ä»€ä¹ˆæ—¶å€™å¼€å§‹æ‰§è¡Œï¼Ÿ

**å›ç­”**:

**å…³é”®ç‚¹**: `Future` æ˜¯**æƒ°æ€§çš„**ï¼ˆlazyï¼‰ï¼Œåªæœ‰åœ¨è¢« `.await` æˆ– `poll()` æ—¶æ‰å¼€å§‹æ‰§è¡Œã€‚

**ç¤ºä¾‹**:

```rust
async fn expensive_operation() {
    println!("This will NOT print immediately!");
    // è€—æ—¶æ“ä½œ
}

async fn example() {
    let future = expensive_operation(); // âŒ ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿ
    
    // åªæœ‰ await ä¹‹åæ‰å¼€å§‹æ‰§è¡Œ
    future.await; // âœ… ç°åœ¨æ‰æ‰“å° "This will NOT print immediately!"
}
```

**å¯¹æ¯” JavaScript Promise**:

```javascript
// JavaScript: Promise ç«‹å³å¼€å§‹æ‰§è¡Œ
const promise = fetch('https://api.example.com'); // âœ… ç«‹å³å¼€å§‹è¯·æ±‚

// Rust: Future æƒ°æ€§æ‰§è¡Œ
let future = reqwest::get("https://api.example.com"); // âŒ ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿ
future.await; // âœ… ç°åœ¨æ‰å¼€å§‹è¯·æ±‚
```

**å®è·µå»ºè®®**:

- å¦‚æœéœ€è¦åå°æ‰§è¡Œï¼Œä½¿ç”¨ `tokio::spawn`:

```rust
// ç«‹å³å¼€å§‹åå°æ‰§è¡Œ
let handle = tokio::spawn(expensive_operation());
```

**ç›¸å…³é—®é¢˜**: [Q1.4](#q14-await-å’Œ-poll-æœ‰ä»€ä¹ˆåŒºåˆ«), [Q6.1](#q61-ä¸ºä»€ä¹ˆæˆ‘çš„-future-æ²¡æœ‰æ‰§è¡Œ)

---

### Q1.4: `.await` å’Œ `poll()` æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**å›ç­”**:

**`.await`** æ˜¯é«˜å±‚æ¬¡è¯­æ³•ç³–ï¼Œ**`poll()`** æ˜¯åº•å±‚æœºåˆ¶ã€‚

**å…³ç³»**:

```text
.await (ç”¨æˆ·ä»£ç )
  â”‚
  â”œâ”€â”€ ç¼–è¯‘å™¨å±•å¼€
  â”‚
  â””â”€â”€> poll() (ç”±è¿è¡Œæ—¶è°ƒç”¨)
```

**ç¤ºä¾‹**:

```rust
// ç”¨æˆ·ä»£ç ï¼šä½¿ç”¨ .await
async fn user_code() {
    let result = async_operation().await;
}

// ç¼–è¯‘å™¨ç”Ÿæˆçš„ç­‰ä»·ä»£ç ï¼ˆç®€åŒ–ç‰ˆï¼‰
fn user_code() -> impl Future<Output = ()> {
    // çŠ¶æ€æœº
    enum State {
        Start,
        Waiting(SomeFuture),
        Done,
    }
    
    struct UserCodeFuture {
        state: State,
    }
    
    impl Future for UserCodeFuture {
        type Output = ();
        
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
            match self.state {
                State::Start => { /* å¼€å§‹ */ }
                State::Waiting(ref mut fut) => {
                    // è°ƒç”¨å†…éƒ¨ Future çš„ poll
                    match fut.poll(cx) {
                        Poll::Ready(val) => { /* å¤„ç†ç»“æœ */ }
                        Poll::Pending => return Poll::Pending,
                    }
                }
                State::Done => Poll::Ready(()),
            }
        }
    }
    
    UserCodeFuture { state: State::Start }
}
```

**ä½•æ—¶éœ€è¦æ‰‹åŠ¨å®ç° `poll()`**:

- å®ç°è‡ªå®šä¹‰ `Future` ç±»å‹
- ç¼–å†™åº•å±‚å¼‚æ­¥åŸè¯­
- æ€§èƒ½æ•æ„Ÿçš„åœºæ™¯

**ç›¸å…³é—®é¢˜**: [Q1.3](#q13-future-ä»€ä¹ˆæ—¶å€™å¼€å§‹æ‰§è¡Œ), [Q8.1](#q81-å¦‚ä½•æ‰‹åŠ¨å®ç°-future)

---

### Q1.5: `async fn` è¿”å›çš„æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ

**å›ç­”**:

`async fn` è¿”å›ä¸€ä¸ª**åŒ¿åçš„ `impl Future<Output = T>`** ç±»å‹ã€‚

**ç¤ºä¾‹**:

```rust
// è¿™ä¸ªå‡½æ•°ï¼š
async fn get_number() -> i32 {
    42
}

// ç­‰ä»·äºï¼š
fn get_number() -> impl Future<Output = i32> {
    async { 42 }
}
```

**ç±»å‹ç‰¹ç‚¹**:

- **ä¸é€æ˜**: å…·ä½“ç±»å‹ç”±ç¼–è¯‘å™¨ç”Ÿæˆï¼Œä½ æ— æ³•å‘½åå®ƒ
- **é›¶å¤§å°**ï¼ˆåœ¨æœª poll å‰ï¼‰: åªæ˜¯ä¸€ä¸ªçŠ¶æ€æœº
- **Unpin**: å¤§å¤šæ•°æƒ…å†µä¸‹æ˜¯ `!Unpin`ï¼ˆä¸å¯ç§»åŠ¨ï¼‰

**å‘½åé—®é¢˜**:

```rust
// âŒ ä¸èƒ½ç›´æ¥å‘½åç±»å‹
fn get_future() -> ??? {  // ç±»å‹æ— æ³•å†™å‡ºæ¥
    async { 42 }
}

// âœ… ä½¿ç”¨ impl Trait
fn get_future() -> impl Future<Output = i32> {
    async { 42 }
}

// âœ… æˆ–è€… Box (æœ‰æ€§èƒ½å¼€é”€)
fn get_future() -> Box<dyn Future<Output = i32> + Send> {
    Box::new(async { 42 })
}
```

**ç›¸å…³é—®é¢˜**: [Q1.3](#q13-future-ä»€ä¹ˆæ—¶å€™å¼€å§‹æ‰§è¡Œ), [Q7.3](#q73-async-trait-crate-æ˜¯åšä»€ä¹ˆçš„)

---

## 2. è¿è¡Œæ—¶é€‰æ‹©

### Q2.1: Tokioã€async-std å’Œ Smol å¦‚ä½•é€‰æ‹©ï¼Ÿ

**å›ç­”**:

**å¿«é€Ÿå†³ç­–æ ‘**:

```text
éœ€è¦ç”Ÿäº§çº§ç¨³å®šæ€§ï¼Ÿ
  â”œâ”€â”€ æ˜¯ â†’ Tokio (ç”Ÿæ€æœ€å®Œå–„)
  â””â”€â”€ å¦ 
      â”œâ”€â”€ è¿½æ±‚ API ç®€æ´ï¼Ÿ â†’ async-std
      â””â”€â”€ è¿½æ±‚è½»é‡çº§ï¼Ÿ â†’ Smol
```

**è¯¦ç»†å¯¹æ¯”**:

| ç‰¹æ€§ | Tokio | async-std | Smol |
|------|-------|-----------|------|
| **ç”Ÿæ€ç³»ç»Ÿ** | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜… | â˜…â˜… |
| **æ€§èƒ½** | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜… |
| **å­¦ä¹ æ›²çº¿** | â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜… |
| **æ–‡æ¡£è´¨é‡** | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜… | â˜…â˜…â˜… |
| **é€‚ç”¨åœºæ™¯** | ç”Ÿäº§ç¯å¢ƒã€å¤§å‹é¡¹ç›® | å­¦ä¹ ã€ä¸­å°å‹é¡¹ç›® | åµŒå…¥å¼ã€å°å‹æœåŠ¡ |
| **ç‰¹è‰²åŠŸèƒ½** | å¤šçº¿ç¨‹è°ƒåº¦ã€tracing é›†æˆ | ç±»ä¼¼æ ‡å‡†åº“ API | æç®€ã€ä½ä¾èµ– |

**ä»£ç ç¤ºä¾‹**:

```rust
// Tokio
#[tokio::main]
async fn main() {
    tokio::spawn(async { println!("Tokio"); }).await.unwrap();
}

// async-std
#[async_std::main]
async fn main() {
    async_std::task::spawn(async { println!("async-std"); }).await;
}

// Smol
fn main() {
    smol::block_on(async {
        smol::spawn(async { println!("Smol"); }).await;
    });
}
```

**æ¨è**:

- **99% çš„åœºæ™¯**: é€‰æ‹© **Tokio**
- **æ•™å­¦/å­¦ä¹ **: é€‰æ‹© **async-std**
- **åµŒå…¥å¼/ä½èµ„æº**: é€‰æ‹© **Smol**

**ç›¸å…³é—®é¢˜**: [Q2.2](#q22-å¯ä»¥åœ¨åŒä¸€é¡¹ç›®ä¸­æ··ç”¨å¤šä¸ªè¿è¡Œæ—¶å—), [Q7.1](#q71-tokio-å’Œ-async-std-çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—)

---

### Q2.2: å¯ä»¥åœ¨åŒä¸€é¡¹ç›®ä¸­æ··ç”¨å¤šä¸ªè¿è¡Œæ—¶å—ï¼Ÿ

**å›ç­”**:

**ç®€çŸ­å›ç­”**: æŠ€æœ¯ä¸Šå¯ä»¥ï¼Œä½†**å¼ºçƒˆä¸æ¨è**ã€‚

**ä¸ºä»€ä¹ˆä¸æ¨è**:

1. **I/O ç±»å‹ä¸å…¼å®¹**: `tokio::net::TcpStream` â‰  `async_std::net::TcpStream`
2. **è¿è¡Œæ—¶å¼€é”€**: æ¯ä¸ªè¿è¡Œæ—¶éƒ½æœ‰è‡ªå·±çš„çº¿ç¨‹æ± å’Œè°ƒåº¦å™¨
3. **å¤æ‚æ€§**: éœ€è¦é¢å¤–çš„å…¼å®¹å±‚ï¼ˆå¦‚ `async-compat`ï¼‰

**å¦‚æœå¿…é¡»æ··ç”¨**:

```rust
// ä½¿ç”¨ async-compat æ¡¥æ¥
use async_compat::Compat;

#[tokio::main]
async fn main() {
    // åœ¨ tokio ä¸­è¿è¡Œ async-std ä»£ç 
    let result = Compat::new(async {
        async_std::task::sleep(Duration::from_secs(1)).await;
    }).await;
}
```

**æ›´å¥½çš„æ–¹æ¡ˆ**:

- **ç»Ÿä¸€é€‰æ‹©**: é¡¹ç›®å¼€å§‹æ—¶å°±é€‰å®šä¸€ä¸ªè¿è¡Œæ—¶
- **ä½¿ç”¨è¿è¡Œæ—¶æ— å…³çš„åº“**: å¦‚ `hyper`, `reqwest` (å¯é…ç½®åº•å±‚è¿è¡Œæ—¶)

**ç›¸å…³é—®é¢˜**: [Q2.1](#q21-tokioasync-std-å’Œ-smol-å¦‚ä½•é€‰æ‹©), [Q7.1](#q71-tokio-å’Œ-async-std-çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—)

---

### Q2.3: å¦‚ä½•é€‰æ‹©å•çº¿ç¨‹è¿˜æ˜¯å¤šçº¿ç¨‹è¿è¡Œæ—¶ï¼Ÿ

**å›ç­”**:

**Tokio ç¤ºä¾‹**:

```rust
// å¤šçº¿ç¨‹è¿è¡Œæ—¶ (é»˜è®¤)
#[tokio::main] // ç­‰ä»·äº #[tokio::main(flavor = "multi_thread")]
async fn main() {
    // å¯ä»¥åˆ©ç”¨å¤šæ ¸
}

// å•çº¿ç¨‹è¿è¡Œæ—¶
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // åªåœ¨å½“å‰çº¿ç¨‹è¿è¡Œ
}
```

**é€‰æ‹©å»ºè®®**:

| åœºæ™¯ | æ¨è | åŸå›  |
|------|------|------|
| **ç”Ÿäº§ç¯å¢ƒ Web æœåŠ¡å™¨** | å¤šçº¿ç¨‹ | å……åˆ†åˆ©ç”¨å¤šæ ¸ï¼Œå¤„ç†é«˜å¹¶å‘ |
| **æµ‹è¯•/åŸºå‡†æµ‹è¯•** | å•çº¿ç¨‹ | ç»“æœæ›´å¯é¢„æµ‹ï¼Œæ˜“äºè°ƒè¯• |
| **åµŒå…¥å¼/ä½èµ„æºç¯å¢ƒ** | å•çº¿ç¨‹ | å‡å°‘èµ„æºå ç”¨ |
| **çº¯ I/O ä»»åŠ¡** | å•çº¿ç¨‹å¯èƒ½è¶³å¤Ÿ | é¿å…çº¿ç¨‹åˆ‡æ¢å¼€é”€ |
| **æ··åˆ CPU + I/O** | å¤šçº¿ç¨‹ | CPU ä»»åŠ¡å¯å¹¶è¡Œæ‰§è¡Œ |

**æ€§èƒ½è€ƒè™‘**:

```rust
// å¤šçº¿ç¨‹ï¼šä»»åŠ¡å¯èƒ½åœ¨ä¸åŒçº¿ç¨‹æ‰§è¡Œ
#[tokio::main]
async fn main() {
    for i in 0..10 {
        tokio::spawn(async move {
            println!("Task {} on thread {:?}", i, std::thread::current().id());
        });
    }
}

// å•çº¿ç¨‹ï¼šæ‰€æœ‰ä»»åŠ¡åœ¨åŒä¸€çº¿ç¨‹
#[tokio::main(flavor = "current_thread")]
async fn main() {
    for i in 0..10 {
        tokio::spawn(async move {
            println!("Task {} on thread {:?}", i, std::thread::current().id());
            // æ‰€æœ‰ä»»åŠ¡éƒ½åœ¨åŒä¸€çº¿ç¨‹
        });
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q2.1](#q21-tokioasync-std-å’Œ-smol-å¦‚ä½•é€‰æ‹©), [Q4.2](#q42-å¦‚ä½•ä¼˜åŒ–-tokio-è¿è¡Œæ—¶æ€§èƒ½)

---

## 3. Pin ä¸å†…å­˜å®‰å…¨

### Q3.1: ä¸ºä»€ä¹ˆæˆ‘éœ€è¦ `Pin`ï¼Ÿå®ƒçœ‹èµ·æ¥éå¸¸å¤æ‚

**å›ç­”**:

`Pin` è§£å†³äº† **è‡ªå¼•ç”¨ç»“æ„** çš„å®‰å…¨é—®é¢˜ã€‚

**é—®é¢˜åœºæ™¯**:

```rust
// async å‡½æ•°å†…éƒ¨çš„çŠ¶æ€æœºï¼ˆç®€åŒ–ç‰ˆï¼‰
struct AsyncState {
    buffer: Vec<u8>,
    buffer_ref: *const u8, // æŒ‡å‘ buffer çš„æŒ‡é’ˆ
}

// å¦‚æœç»“æ„è¢«ç§»åŠ¨ï¼ŒæŒ‡é’ˆå°±ä¼šå˜æˆæ‚¬å‚æŒ‡é’ˆï¼
let mut state = AsyncState { /* ... */ };
let moved_state = state; // âŒ buffer_ref ç°åœ¨æŒ‡å‘æ— æ•ˆå†…å­˜
```

**`Pin` å¦‚ä½•è§£å†³**:

```rust
use std::pin::Pin;

// Pin ä¿è¯ï¼šä¸€æ—¦è¢«å›ºå®šï¼Œå¯¹è±¡åœ¨å†…å­˜ä¸­çš„åœ°å€æ°¸è¿œä¸å˜
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    // ç°åœ¨ self çš„åœ°å€æ˜¯ç¨³å®šçš„ï¼Œè‡ªå¼•ç”¨æ˜¯å®‰å…¨çš„
}
```

**å®é™…å¼€å‘ä¸­**:

```rust
// âœ… å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ ä¸éœ€è¦ç›´æ¥ä½¿ç”¨ Pin
async fn user_code() {
    // ç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶ä¼šè‡ªåŠ¨å¤„ç† Pin
    let result = async_operation().await;
}

// âŒ åªæœ‰åœ¨æ‰‹åŠ¨å®ç° Future æ—¶æ‰éœ€è¦
impl Future for MyFuture {
    type Output = ();
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        // è¿™é‡Œéœ€è¦ç†è§£ Pin
    }
}
```

**ç±»æ¯”**: `Pin` å°±åƒ"é’‰ä½"ä¸€å¹…ç”»ï¼Œç¡®ä¿å®ƒä¸ä¼šåœ¨å¢™ä¸Šç§»åŠ¨ä½ç½®ã€‚

**ç›¸å…³é—®é¢˜**: [Q3.2](#q32-ä»€ä¹ˆæ˜¯-unpin), [Q3.3](#q33-å¦‚ä½•è·å–-pinmut-t-ä¸­çš„-t), [Q8.1](#q81-å¦‚ä½•æ‰‹åŠ¨å®ç°-future)

---

### Q3.2: ä»€ä¹ˆæ˜¯ `Unpin`ï¼Ÿ

**å›ç­”**:

`Unpin` æ˜¯ä¸€ä¸ª **auto trait**ï¼Œè¡¨ç¤º"å³ä½¿è¢« `Pin` ä¹Ÿå¯ä»¥å®‰å…¨ç§»åŠ¨"ã€‚

**å…³é”®ç‚¹**:

- **å¤§å¤šæ•°ç±»å‹è‡ªåŠ¨å®ç° `Unpin`**: `i32`, `String`, `Vec<T>` ç­‰
- **åªæœ‰è‡ªå¼•ç”¨ç±»å‹æ˜¯ `!Unpin`**: å¦‚ `async` å—ç”Ÿæˆçš„ `Future`

**ç¤ºä¾‹**:

```rust
// æ™®é€šç±»å‹ï¼šå®ç° Unpin
fn is_unpin<T: Unpin>(_t: T) {}

is_unpin(42);           // âœ… i32 æ˜¯ Unpin
is_unpin(String::new()); // âœ… String æ˜¯ Unpin

// async ç”Ÿæˆçš„ Futureï¼š!Unpin
let future = async { 42 };
// is_unpin(future);    // âŒ ç¼–è¯‘é”™è¯¯ï¼šFuture ä¸æ˜¯ Unpin
```

**å®è·µå½±å“**:

```rust
use tokio::io::{AsyncRead, AsyncReadExt};

async fn read_example() {
    let mut buffer = vec![0u8; 1024];
    
    // âœ… buffer æ˜¯ Unpinï¼Œå¯ä»¥ç›´æ¥ä¼ å¼•ç”¨
    let n = stream.read(&mut buffer).await.unwrap();
    
    // âŒ å¦‚æœä¼ é€’ !Unpin ç±»å‹ï¼Œéœ€è¦ Pin
    // let future = async { /* ... */ };
    // stream.read_from_future(future).await; // å¯èƒ½éœ€è¦ Box::pin(future)
}
```

**å¦‚ä½•åˆ¤æ–­**:

```rust
use std::marker::Unpin;

fn check_unpin<T: Unpin>() {
    println!("T æ˜¯ Unpin");
}

// ç¼–è¯‘é€šè¿‡ = Unpin
// ç¼–è¯‘å¤±è´¥ = !Unpin
```

**ç›¸å…³é—®é¢˜**: [Q3.1](#q31-ä¸ºä»€ä¹ˆæˆ‘éœ€è¦-pinå®ƒçœ‹èµ·æ¥éå¸¸å¤æ‚), [Q3.3](#q33-å¦‚ä½•è·å–-pinmut-t-ä¸­çš„-t)

---

### Q3.3: å¦‚ä½•è·å– `Pin<&mut T>` ä¸­çš„ `&mut T`ï¼Ÿ

**å›ç­”**:

**æ ¹æ® `T` æ˜¯å¦å®ç° `Unpin` æœ‰ä¸åŒæ–¹æ³•**:

**æƒ…å†µ 1: `T: Unpin`** (å®‰å…¨)

```rust
use std::pin::Pin;

fn example(pinned: Pin<&mut String>) {
    // âœ… å®‰å…¨ï¼šString å®ç°äº† Unpin
    let s: &mut String = pinned.get_mut();
    s.push_str("Hello");
}
```

**æƒ…å†µ 2: `T: !Unpin`** (éœ€è¦ unsafe)

```rust
use std::pin::Pin;

struct NotUnpin {
    data: i32,
    self_ref: *const i32,
}

fn example(pinned: Pin<&mut NotUnpin>) {
    // âŒ ä¸èƒ½ç›´æ¥ get_mut()
    // let data = pinned.get_mut(); // ç¼–è¯‘é”™è¯¯
    
    // âœ… éœ€è¦ unsafe + æ‰‹åŠ¨ä¿è¯å®‰å…¨
    unsafe {
        let data = Pin::get_unchecked_mut(pinned);
        // å¿…é¡»ä¿è¯ä¸ç§»åŠ¨ data
    }
}
```

**å®è·µå»ºè®®**:

- **é¿å…éœ€è¦ `get_mut()` çš„åœºæ™¯**: è®¾è®¡ API æ—¶ç›´æ¥æ¥å— `Pin<&mut T>`
- **ä½¿ç”¨ `pin_project` å®**: è‡ªåŠ¨ç”Ÿæˆå®‰å…¨çš„å­—æ®µè®¿é—®

```rust
use pin_project::pin_project;

#[pin_project]
struct MyFuture {
    #[pin]
    inner: SomeFuture,
    counter: u32, // ä¸éœ€è¦ pin
}

impl Future for MyFuture {
    type Output = ();
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        let this = self.project(); // å®‰å…¨åœ°è®¿é—®å­—æ®µ
        this.inner.poll(cx)
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q3.1](#q31-ä¸ºä»€ä¹ˆæˆ‘éœ€è¦-pinå®ƒçœ‹èµ·æ¥éå¸¸å¤æ‚), [Q3.2](#q32-ä»€ä¹ˆæ˜¯-unpin), [Q8.1](#q81-å¦‚ä½•æ‰‹åŠ¨å®ç°-future)

---

## 4. æ€§èƒ½ä¸ä¼˜åŒ–

### Q4.1: å¦‚ä½•åœ¨ `async` ä»£ç ä¸­æ‰§è¡Œ CPU å¯†é›†å‹ä»»åŠ¡ï¼Ÿ

**å›ç­”**:

**æ ¸å¿ƒåŸåˆ™**: æ°¸è¿œä¸è¦åœ¨ `async` ä»»åŠ¡ä¸­ç›´æ¥æ‰§è¡Œé•¿æ—¶é—´çš„ CPU å¯†é›†å‹è®¡ç®—ï¼Œè¿™ä¼šé˜»å¡æ•´ä¸ªè¿è¡Œæ—¶ã€‚

**æ­£ç¡®åšæ³•**: ä½¿ç”¨ `spawn_blocking`

```rust
use tokio::task;

async fn example() {
    // âŒ é”™è¯¯ï¼šé˜»å¡å¼‚æ­¥è¿è¡Œæ—¶
    let result = expensive_computation(); // é•¿æ—¶é—´ CPU è®¡ç®—
    
    // âœ… æ­£ç¡®ï¼šåœ¨ä¸“ç”¨çº¿ç¨‹æ± æ‰§è¡Œ
    let result = task::spawn_blocking(|| {
        expensive_computation() // åœ¨é˜»å¡çº¿ç¨‹æ± æ‰§è¡Œ
    }).await.unwrap();
    
    println!("Result: {}", result);
}

fn expensive_computation() -> i32 {
    // è€—æ—¶ CPU è®¡ç®—
    (0..1_000_000).sum()
}
```

**æ€§èƒ½è€ƒè™‘**:

```rust
// æ‰¹é‡å¤„ç†ï¼šå‡å°‘ spawn_blocking è°ƒç”¨
async fn process_batch(items: Vec<Item>) {
    // âœ… ä¸€æ¬¡æ€§å¤„ç†æ•´ä¸ªæ‰¹æ¬¡
    let results = task::spawn_blocking(move || {
        items.into_iter()
            .map(|item| expensive_process(item))
            .collect::<Vec<_>>()
    }).await.unwrap();
}

// âŒ é¿å…ï¼šæ¯ä¸ªé¡¹ç›®éƒ½ spawn_blocking
async fn process_items_bad(items: Vec<Item>) {
    for item in items {
        // è¿‡å¤šçš„çº¿ç¨‹åˆ‡æ¢å¼€é”€
        task::spawn_blocking(move || expensive_process(item)).await.unwrap();
    }
}
```

**ä½¿ç”¨ `rayon` å®ç°å¹¶è¡Œ**:

```rust
use tokio::task;
use rayon::prelude::*;

async fn parallel_computation(data: Vec<i32>) -> Vec<i32> {
    task::spawn_blocking(move || {
        // åœ¨ rayon çº¿ç¨‹æ± ä¸­å¹¶è¡Œè®¡ç®—
        data.par_iter()
            .map(|&x| expensive_fn(x))
            .collect()
    }).await.unwrap()
}
```

**ç›¸å…³é—®é¢˜**: [Q1.1](#q11-asyncawait-å’Œæ™®é€šçš„çº¿ç¨‹æœ‰ä»€ä¹ˆåŒºåˆ«æˆ‘åº”è¯¥ç”¨å“ªä¸ª), [Q4.2](#q42-å¦‚ä½•ä¼˜åŒ–-tokio-è¿è¡Œæ—¶æ€§èƒ½)

---

### Q4.2: å¦‚ä½•ä¼˜åŒ– Tokio è¿è¡Œæ—¶æ€§èƒ½ï¼Ÿ

**å›ç­”**:

**1. è°ƒæ•´å·¥ä½œçº¿ç¨‹æ•°**:

```rust
// é»˜è®¤ï¼šCPU æ ¸å¿ƒæ•°
#[tokio::main]
async fn main() {
    // è‡ªåŠ¨ä½¿ç”¨æ‰€æœ‰æ ¸å¿ƒ
}

// è‡ªå®šä¹‰çº¿ç¨‹æ•°
#[tokio::main(worker_threads = 4)]
async fn main() {
    // ä½¿ç”¨ 4 ä¸ªå·¥ä½œçº¿ç¨‹
}

// ç¼–ç¨‹æ–¹å¼é…ç½®
use tokio::runtime;

fn main() {
    let rt = runtime::Builder::new_multi_thread()
        .worker_threads(8)
        .thread_name("my-pool")
        .build()
        .unwrap();
    
    rt.block_on(async {
        // å¼‚æ­¥ä»£ç 
    });
}
```

**2. ä½¿ç”¨ `LocalSet` å‡å°‘è·¨çº¿ç¨‹å¼€é”€**:

```rust
use tokio::task::LocalSet;

#[tokio::main]
async fn main() {
    let local = LocalSet::new();
    
    // æ‰€æœ‰ä»»åŠ¡åœ¨åŒä¸€çº¿ç¨‹æ‰§è¡Œï¼Œé¿å… Send çº¦æŸ
    local.spawn_local(async {
        // å¯ä»¥ä½¿ç”¨ Rc, RefCell ç­‰é Send ç±»å‹
        let data = std::rc::Rc::new(42);
    });
    
    local.await;
}
```

**3. é¿å…è¿‡åº¦ `spawn`**:

```rust
// âŒ ä½æ•ˆï¼šè¿‡å¤šçš„ä»»åŠ¡å¼€é”€
async fn bad_example() {
    for i in 0..1_000_000 {
        tokio::spawn(async move {
            println!("{}", i);
        });
    }
}

// âœ… é«˜æ•ˆï¼šæ‰¹é‡å¤„ç†
async fn good_example() {
    let batch_size = 1000;
    for batch in (0..1_000_000).step_by(batch_size) {
        tokio::spawn(async move {
            for i in batch..(batch + batch_size) {
                println!("{}", i);
            }
        });
    }
}
```

**4. ä½¿ç”¨ `join!` è€Œéé¡ºåº `.await`**:

```rust
// âŒ é¡ºåºæ‰§è¡Œï¼šæ€»æ—¶é—´ = 2 + 3 = 5 ç§’
async fn sequential() {
    task1().await; // 2 ç§’
    task2().await; // 3 ç§’
}

// âœ… å¹¶å‘æ‰§è¡Œï¼šæ€»æ—¶é—´ = max(2, 3) = 3 ç§’
async fn concurrent() {
    tokio::join!(task1(), task2());
}
```

**5. å¯ç”¨æ€§èƒ½åˆ†æ**:

```toml
[dependencies]
tokio = { version = "1", features = ["full", "tracing"] }
console-subscriber = "0.2"
```

```rust
fn main() {
    console_subscriber::init();
    // ä½¿ç”¨ tokio-console å®æ—¶ç›‘æ§
}
```

**ç›¸å…³é—®é¢˜**: [Q4.1](#q41-å¦‚ä½•åœ¨-async-ä»£ç ä¸­æ‰§è¡Œ-cpu-å¯†é›†å‹ä»»åŠ¡), [Q4.3](#q43-å¦‚ä½•æµ‹é‡å¼‚æ­¥ä»£ç çš„æ€§èƒ½)

---

### Q4.3: å¦‚ä½•æµ‹é‡å¼‚æ­¥ä»£ç çš„æ€§èƒ½ï¼Ÿ

**å›ç­”**:

**1. ä½¿ç”¨ `tokio::time::Instant`**:

```rust
use tokio::time::{Instant, Duration};

async fn measure_performance() {
    let start = Instant::now();
    
    // æ‰§è¡Œå¼‚æ­¥æ“ä½œ
    expensive_async_operation().await;
    
    let duration = start.elapsed();
    println!("Operation took: {:?}", duration);
}
```

**2. ä½¿ç”¨ `tracing` è¿›è¡Œè¯¦ç»†åˆ†æ**:

```rust
use tracing::{info, instrument};

#[instrument]
async fn traced_function() {
    info!("Starting operation");
    operation1().await;
    info!("Operation 1 complete");
    operation2().await;
    info!("Operation 2 complete");
}

// ä½¿ç”¨ tracing-subscriber
#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    traced_function().await;
}
```

**3. ä½¿ç”¨ `criterion` è¿›è¡ŒåŸºå‡†æµ‹è¯•**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use tokio::runtime::Runtime;

fn benchmark_async(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    c.bench_function("async_operation", |b| {
        b.iter(|| {
            rt.block_on(async {
                black_box(async_operation().await)
            })
        });
    });
}

criterion_group!(benches, benchmark_async);
criterion_main!(benches);
```

**4. ä½¿ç”¨ `tokio-console` å®æ—¶ç›‘æ§**:

```bash
# å®‰è£…
cargo install tokio-console

# è¿è¡Œåº”ç”¨
tokio-console

# æŸ¥çœ‹å®æ—¶ä»»åŠ¡çŠ¶æ€ã€èµ„æºä½¿ç”¨ç­‰
```

**ç›¸å…³é—®é¢˜**: [Q4.2](#q42-å¦‚ä½•ä¼˜åŒ–-tokio-è¿è¡Œæ—¶æ€§èƒ½), [Q5.2](#q52-å¦‚ä½•è°ƒè¯•å¼‚æ­¥ä»£ç )

---

## 5. é”™è¯¯å¤„ç†ä¸è°ƒè¯•

### Q5.1: å¦‚ä½•åœ¨å¼‚æ­¥ä»£ç ä¸­å¤„ç†é”™è¯¯ï¼Ÿ

**å›ç­”**:

**1. ä½¿ç”¨ `Result` å’Œ `?` æ“ä½œç¬¦**:

```rust
async fn fetch_data() -> Result<String, Box<dyn std::error::Error>> {
    let response = reqwest::get("https://api.example.com").await?;
    let body = response.text().await?;
    Ok(body)
}

async fn process() {
    match fetch_data().await {
        Ok(data) => println!("Data: {}", data),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

**2. ä½¿ç”¨ `anyhow` ç®€åŒ–é”™è¯¯å¤„ç†**:

```rust
use anyhow::{Context, Result};

async fn fetch_with_context() -> Result<String> {
    let response = reqwest::get("https://api.example.com").await
        .context("Failed to send request")?;
    
    let body = response.text().await
        .context("Failed to read response body")?;
    
    Ok(body)
}
```

**3. å¤„ç†å¤šä¸ª Future çš„é”™è¯¯**:

```rust
use tokio::try_join;

async fn parallel_with_errors() -> Result<(), Box<dyn std::error::Error>> {
    // ä»»ä½•ä¸€ä¸ªå¤±è´¥éƒ½ä¼šè¿”å›é”™è¯¯
    let (result1, result2) = try_join!(
        async_operation1(),
        async_operation2(),
    )?;
    
    Ok(())
}
```

**4. ä¼˜é›…å¤„ç† `spawn` ä»»åŠ¡ä¸­çš„é”™è¯¯**:

```rust
async fn spawn_with_error_handling() {
    let handle = tokio::spawn(async {
        // ä»»åŠ¡å¯èƒ½å¤±è´¥
        risky_operation().await
    });
    
    match handle.await {
        Ok(Ok(result)) => println!("Success: {:?}", result),
        Ok(Err(e)) => eprintln!("Task error: {}", e),
        Err(e) => eprintln!("Join error (task panicked): {}", e),
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q5.2](#q52-å¦‚ä½•è°ƒè¯•å¼‚æ­¥ä»£ç ), [Q5.3](#q53-å¦‚ä½•å¤„ç†-timeout)

---

### Q5.2: å¦‚ä½•è°ƒè¯•å¼‚æ­¥ä»£ç ï¼Ÿ

**å›ç­”**:

**1. ä½¿ç”¨ `dbg!` å’Œ `println!`**:

```rust
async fn debug_example() {
    dbg!("Before await");
    let result = async_operation().await;
    dbg!(&result);
    println!("Result: {:?}", result);
}
```

**2. ä½¿ç”¨ `tracing` è¿›è¡Œç»“æ„åŒ–æ—¥å¿—**:

```rust
use tracing::{debug, info, warn, error, instrument};

#[instrument]
async fn traced_operation() {
    info!("Starting operation");
    debug!("Detailed debug info");
    
    if let Err(e) = risky_op().await {
        error!("Operation failed: {:?}", e);
    }
}
```

**3. ä½¿ç”¨ `tokio-console` å®æ—¶ç›‘æ§**:

```toml
[dependencies]
tokio = { version = "1", features = ["full", "tracing"] }
console-subscriber = "0.2"
```

```rust
fn main() {
    console_subscriber::init();
    // åœ¨å¦ä¸€ä¸ªç»ˆç«¯è¿è¡Œ: tokio-console
}
```

**4. åœ¨ IDE ä¸­è°ƒè¯•**:

- **VSCode**: ä½¿ç”¨ `CodeLLDB` æˆ– `C/C++` æ‰©å±•
- **RustRover/CLion**: å†…ç½®æ”¯æŒ

**è°ƒè¯•æŠ€å·§**:

```rust
// è®¾ç½®æ–­ç‚¹å‹å¥½çš„ä»£ç ç»“æ„
async fn debuggable() {
    let step1 = operation1().await; // å¯ä»¥åœ¨è¿™é‡Œè®¾ç½®æ–­ç‚¹
    let step2 = operation2(step1).await; // å’Œè¿™é‡Œ
    let step3 = operation3(step2).await; // å’Œè¿™é‡Œ
}

// é¿å…ï¼šéš¾ä»¥è°ƒè¯•çš„é“¾å¼è°ƒç”¨
async fn hard_to_debug() {
    operation1().await
        .and_then(|r1| operation2(r1).await)
        .and_then(|r2| operation3(r2).await);
}
```

**5. ä½¿ç”¨ `RUST_BACKTRACE`**:

```bash
RUST_BACKTRACE=1 cargo run
```

**ç›¸å…³é—®é¢˜**: [Q5.1](#q51-å¦‚ä½•åœ¨å¼‚æ­¥ä»£ç ä¸­å¤„ç†é”™è¯¯), [Q5.3](#q53-å¦‚ä½•å¤„ç†-timeout), [Q4.3](#q43-å¦‚ä½•æµ‹é‡å¼‚æ­¥ä»£ç çš„æ€§èƒ½)

---

### Q5.3: å¦‚ä½•å¤„ç† Timeoutï¼Ÿ

**å›ç­”**:

**1. ä½¿ç”¨ `tokio::time::timeout`**:

```rust
use tokio::time::{timeout, Duration};

async fn with_timeout() {
    match timeout(Duration::from_secs(5), long_operation()).await {
        Ok(result) => println!("Completed: {:?}", result),
        Err(_) => eprintln!("Operation timed out!"),
    }
}
```

**2. å¯¹å¤šä¸ªæ“ä½œè®¾ç½®æ€»è¶…æ—¶**:

```rust
use tokio::time::{timeout, Duration};

async fn multiple_operations_timeout() {
    let result = timeout(Duration::from_secs(10), async {
        operation1().await?;
        operation2().await?;
        operation3().await?;
        Ok::<(), Box<dyn std::error::Error>>(())
    }).await;
    
    match result {
        Ok(Ok(())) => println!("All operations completed"),
        Ok(Err(e)) => eprintln!("Operation error: {}", e),
        Err(_) => eprintln!("Timeout after 10 seconds"),
    }
}
```

**3. ä½¿ç”¨ `tokio::select!` å®ç°æ›´å¤æ‚çš„è¶…æ—¶é€»è¾‘**:

```rust
use tokio::{time::{sleep, Duration}, select};

async fn select_with_timeout() {
    select! {
        result = long_operation() => {
            println!("Operation completed: {:?}", result);
        }
        _ = sleep(Duration::from_secs(5)) => {
            eprintln!("Operation timed out!");
        }
    }
}
```

**4. å¯å–æ¶ˆçš„è¶…æ—¶**:

```rust
use tokio::time::{timeout, Duration};
use tokio::sync::oneshot;

async fn cancellable_timeout() {
    let (tx, rx) = oneshot::channel();
    
    tokio::spawn(async move {
        sleep(Duration::from_secs(3)).await;
        let _ = tx.send(());
    });
    
    select! {
        _ = rx => println!("Received cancel signal"),
        result = long_operation() => println!("Completed: {:?}", result),
        _ = sleep(Duration::from_secs(10)) => eprintln!("Timeout"),
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q5.1](#q51-å¦‚ä½•åœ¨å¼‚æ­¥ä»£ç ä¸­å¤„ç†é”™è¯¯), [Q6.3](#q63-å¦‚ä½•ä¼˜é›…å–æ¶ˆå¼‚æ­¥ä»»åŠ¡)

---

## 6. è®¾è®¡æ¨¡å¼ä¸æœ€ä½³å®è·µ

### Q6.1: ä¸ºä»€ä¹ˆæˆ‘çš„ `Future` æ²¡æœ‰æ‰§è¡Œï¼Ÿ

**å›ç­”**:

**æœ€å¸¸è§åŸå› **: å¿˜è®° `.await` æˆ– `spawn`ã€‚

**é—®é¢˜ä»£ç **:

```rust
async fn bug_example() {
    // âŒ åˆ›å»ºäº† Future ä½†æ²¡æœ‰æ‰§è¡Œ
    fetch_data(); // ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿï¼
    
    println!("Done"); // ç«‹å³æ‰“å°ï¼Œfetch_data ä»æœªè¿è¡Œ
}
```

**ä¿®å¤æ–¹æ¡ˆ 1**: ä½¿ç”¨ `.await`

```rust
async fn fixed_with_await() {
    // âœ… ç­‰å¾… Future å®Œæˆ
    fetch_data().await;
    println!("Done");
}
```

**ä¿®å¤æ–¹æ¡ˆ 2**: ä½¿ç”¨ `spawn` åå°æ‰§è¡Œ

```rust
async fn fixed_with_spawn() {
    // âœ… åœ¨åå°æ‰§è¡Œ
    tokio::spawn(fetch_data());
    println!("Started background task");
}
```

**è°ƒè¯•æŠ€å·§**: å¯ç”¨ `#[must_use]` è­¦å‘Š

```rust
#[must_use = "Future does nothing unless awaited"]
async fn fetch_data() {
    // ...
}

// ç¼–è¯‘å™¨ä¼šè­¦å‘Šï¼š
// warning: unused `impl Future` that must be used
fetch_data();
```

**ç›¸å…³é—®é¢˜**: [Q1.3](#q13-future-ä»€ä¹ˆæ—¶å€™å¼€å§‹æ‰§è¡Œ), [Q6.2](#q62-å¦‚ä½•åœ¨-drop-ä¸­æ‰§è¡Œå¼‚æ­¥æ¸…ç†)

---

### Q6.2: å¦‚ä½•åœ¨ `Drop` ä¸­æ‰§è¡Œå¼‚æ­¥æ¸…ç†ï¼Ÿ

**å›ç­”**:

**æ ¸å¿ƒé—®é¢˜**: `Drop::drop()` æ˜¯åŒæ­¥æ–¹æ³•ï¼Œä¸èƒ½ `.await`ã€‚

**è§£å†³æ–¹æ¡ˆ 1**: ä½¿ç”¨ `block_on` (ä¸æ¨èï¼Œå¯èƒ½æ­»é”)

```rust
struct Resource {
    handle: Handle,
}

impl Drop for Resource {
    fn drop(&mut self) {
        // âš ï¸ å±é™©ï¼šå¯èƒ½æ­»é”
        tokio::runtime::Handle::current()
            .block_on(async {
                self.handle.close().await;
            });
    }
}
```

**è§£å†³æ–¹æ¡ˆ 2**: æä¾›æ˜¾å¼æ¸…ç†æ–¹æ³• (æ¨è)

```rust
struct Resource {
    handle: Option<Handle>,
}

impl Resource {
    async fn close(mut self) {
        if let Some(handle) = self.handle.take() {
            handle.close().await;
        }
    }
}

impl Drop for Resource {
    fn drop(&mut self) {
        if self.handle.is_some() {
            eprintln!("Warning: Resource not properly closed!");
        }
    }
}

// ä½¿ç”¨
async fn usage() {
    let resource = Resource::new();
    // ... ä½¿ç”¨ resource ...
    resource.close().await; // æ˜¾å¼æ¸…ç†
}
```

**è§£å†³æ–¹æ¡ˆ 3**: ä½¿ç”¨ `spawn_blocking`

```rust
impl Drop for Resource {
    fn drop(&mut self) {
        let handle = self.handle.take();
        tokio::spawn(async move {
            if let Some(h) = handle {
                h.close().await;
            }
        });
    }
}
```

**æœ€ä½³å®è·µ**: RAII + æ˜¾å¼å¼‚æ­¥æ¸…ç†

```rust
struct ResourceGuard {
    resource: Option<Resource>,
}

impl ResourceGuard {
    async fn new() -> Self {
        Self {
            resource: Some(Resource::init().await),
        }
    }
    
    async fn close(mut self) {
        if let Some(r) = self.resource.take() {
            r.cleanup().await;
        }
    }
}

impl Drop for ResourceGuard {
    fn drop(&mut self) {
        if self.resource.is_some() {
            log::warn!("ResourceGuard dropped without calling close()!");
        }
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q6.3](#q63-å¦‚ä½•ä¼˜é›…å–æ¶ˆå¼‚æ­¥ä»»åŠ¡), [Q8.3](#q83-å¦‚ä½•å®ç°-asyncdrop)

---

### Q6.3: å¦‚ä½•ä¼˜é›…å–æ¶ˆå¼‚æ­¥ä»»åŠ¡ï¼Ÿ

**å›ç­”**:

**æ–¹æ³• 1**: ä½¿ç”¨ `JoinHandle::abort()`

```rust
async fn cancellation_example() {
    let handle = tokio::spawn(async {
        loop {
            println!("Working...");
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    });
    
    // ç­‰å¾… 5 ç§’åå–æ¶ˆ
    tokio::time::sleep(Duration::from_secs(5)).await;
    handle.abort();
    
    match handle.await {
        Ok(_) => println!("Task completed"),
        Err(e) if e.is_cancelled() => println!("Task was cancelled"),
        Err(e) => eprintln!("Task panicked: {}", e),
    }
}
```

**æ–¹æ³• 2**: ä½¿ç”¨ `CancellationToken` (æ¨è)

```rust
use tokio_util::sync::CancellationToken;

async fn cooperative_cancellation() {
    let token = CancellationToken::new();
    let child_token = token.child_token();
    
    let handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                _ = child_token.cancelled() => {
                    println!("Received cancellation signal");
                    break;
                }
                _ = do_work() => {
                    // ç»§ç»­å·¥ä½œ
                }
            }
        }
    });
    
    // å‘é€å–æ¶ˆä¿¡å·
    tokio::time::sleep(Duration::from_secs(5)).await;
    token.cancel();
    
    handle.await.unwrap();
}
```

**æ–¹æ³• 3**: ä½¿ç”¨ `oneshot` é€šé“

```rust
use tokio::sync::oneshot;

async fn channel_cancellation() {
    let (tx, mut rx) = oneshot::channel();
    
    let handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                _ = &mut rx => {
                    println!("Shutdown signal received");
                    break;
                }
                _ = do_work() => {}
            }
        }
    });
    
    // å‘é€å–æ¶ˆä¿¡å·
    let _ = tx.send(());
    handle.await.unwrap();
}
```

**æœ€ä½³å®è·µ**:

```rust
use tokio_util::sync::CancellationToken;

struct Service {
    cancel_token: CancellationToken,
}

impl Service {
    fn new() -> Self {
        Self {
            cancel_token: CancellationToken::new(),
        }
    }
    
    async fn run(&self) {
        loop {
            tokio::select! {
                _ = self.cancel_token.cancelled() => {
                    self.cleanup().await;
                    break;
                }
                _ = self.do_work() => {}
            }
        }
    }
    
    fn shutdown(&self) {
        self.cancel_token.cancel();
    }
    
    async fn cleanup(&self) {
        // æ¸…ç†èµ„æº
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q5.3](#q53-å¦‚ä½•å¤„ç†-timeout), [Q6.2](#q62-å¦‚ä½•åœ¨-drop-ä¸­æ‰§è¡Œå¼‚æ­¥æ¸…ç†)

---

## 7. ç”Ÿæ€ç³»ç»Ÿä¸å…¼å®¹æ€§

### Q7.1: Tokio å’Œ async-std çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—ï¼Ÿ

**å›ç­”**:

**ç®€çŸ­å›ç­”**: I/O ç›¸å…³çš„**ä¸èƒ½**ï¼Œçº¯è®¡ç®—çš„**å¯ä»¥**ã€‚

**ä¸å…¼å®¹çš„åŸå› **:

```rust
// âŒ ä¸èƒ½æ··ç”¨ I/O ç±»å‹
use tokio::net::TcpStream as TokioStream;
use async_std::net::TcpStream as AsyncStdStream;

#[tokio::main]
async fn main() {
    // âŒ AsyncStdStream åœ¨ tokio è¿è¡Œæ—¶ä¸­æ— æ³•å·¥ä½œ
    let stream = AsyncStdStream::connect("127.0.0.1:8080").await.unwrap();
}
```

**å¯ä»¥æ··ç”¨çš„æƒ…å†µ**:

```rust
// âœ… çº¯è®¡ç®—é€»è¾‘å¯ä»¥å…±äº«
async fn pure_computation(x: i32) -> i32 {
    x * 2
}

// åœ¨ tokio ä¸­ä½¿ç”¨
#[tokio::main]
async fn tokio_main() {
    let result = pure_computation(21).await;
}

// åœ¨ async-std ä¸­ä½¿ç”¨
#[async_std::main]
async fn async_std_main() {
    let result = pure_computation(21).await;
}
```

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è¿è¡Œæ—¶æ— å…³çš„åº“

```rust
// âœ… reqwest å¯ä»¥é…ç½®åº•å±‚è¿è¡Œæ—¶
[dependencies]
reqwest = { version = "0.11", default-features = false, features = ["rustls-tls"] }

// âœ… hyper ä¹Ÿæ”¯æŒå¤šç§è¿è¡Œæ—¶
[dependencies]
hyper = { version = "0.14", features = ["full"] }
```

**ç›¸å…³é—®é¢˜**: [Q2.2](#q22-å¯ä»¥åœ¨åŒä¸€é¡¹ç›®ä¸­æ··ç”¨å¤šä¸ªè¿è¡Œæ—¶å—), [Q7.2](#q72-å¦‚ä½•ç¼–å†™è¿è¡Œæ—¶æ— å…³çš„å¼‚æ­¥åº“)

---

### Q7.2: å¦‚ä½•ç¼–å†™è¿è¡Œæ—¶æ— å…³çš„å¼‚æ­¥åº“ï¼Ÿ

**å›ç­”**:

**åŸåˆ™**: åªä¾èµ– `std::future` å’Œ `futures` crateï¼Œä¸ä¾èµ–ç‰¹å®šè¿è¡Œæ—¶ã€‚

**ç¤ºä¾‹**:

```rust
// âœ… è¿è¡Œæ—¶æ— å…³
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

pub async fn my_library_function(x: i32) -> i32 {
    x * 2 // çº¯è®¡ç®—
}

// âœ… è¿”å› impl Futureï¼Œç”±è°ƒç”¨è€…é€‰æ‹©è¿è¡Œæ—¶
pub fn my_async_fn() -> impl Future<Output = i32> {
    async { 42 }
}
```

**I/O æ“ä½œ**: é€šè¿‡æ³›å‹æŠ½è±¡

```rust
use futures::io::{AsyncRead, AsyncWrite};

pub async fn copy_data<R, W>(reader: &mut R, writer: &mut W) -> std::io::Result<()>
where
    R: AsyncRead + Unpin,
    W: AsyncWrite + Unpin,
{
    // ä½¿ç”¨ futures çš„ AsyncRead/AsyncWrite trait
    futures::io::copy(reader, writer).await?;
    Ok(())
}
```

**Feature flags æ–¹å¼**:

```toml
[features]
default = []
tokio-runtime = ["tokio"]
async-std-runtime = ["async-std"]

[dependencies]
tokio = { version = "1", optional = true }
async-std = { version = "1", optional = true }
```

```rust
// æ ¹æ® feature é€‰æ‹©ä¸åŒå®ç°
#[cfg(feature = "tokio-runtime")]
pub use tokio::time::sleep;

#[cfg(feature = "async-std-runtime")]
pub use async_std::task::sleep;
```

**æœ€ä½³å®è·µ**:

1. **æ ¸å¿ƒé€»è¾‘**: åªä½¿ç”¨ `std::future`
2. **I/O æ“ä½œ**: ä½¿ç”¨ trait æŠ½è±¡ï¼ˆ`AsyncRead`/`AsyncWrite`ï¼‰
3. **å®šæ—¶å™¨**: è®©ç”¨æˆ·æä¾›ï¼ˆæˆ–ä½¿ç”¨ feature flagsï¼‰
4. **æµ‹è¯•**: åŒæ—¶åœ¨å¤šä¸ªè¿è¡Œæ—¶æµ‹è¯•

**ç›¸å…³é—®é¢˜**: [Q7.1](#q71-tokio-å’Œ-async-std-çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—), [Q2.1](#q21-tokioasync-std-å’Œ-smol-å¦‚ä½•é€‰æ‹©)

---

### Q7.3: `async-trait` crate æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ

**å›ç­”**:

`async-trait` å…è®¸åœ¨ **trait ä¸­å®šä¹‰ `async fn`**ï¼Œå¹¶æ”¯æŒå¯¹è±¡å®‰å…¨ï¼ˆ`dyn Trait`ï¼‰ã€‚

**é—®é¢˜èƒŒæ™¯**:

```rust
// âŒ åœ¨å½“å‰ Rust ä¸­ï¼Œtrait ä¸­çš„ async fn æœ‰é™åˆ¶
trait MyTrait {
    async fn my_method(&self) -> i32; // ç¼–è¯‘é”™è¯¯æˆ–é™åˆ¶å¤š
}

// âŒ ç‰¹åˆ«æ˜¯æ— æ³•åˆ›å»º trait å¯¹è±¡
let obj: Box<dyn MyTrait> = ...; // ä¸æ”¯æŒ
```

**`async-trait` è§£å†³æ–¹æ¡ˆ**:

```rust
use async_trait::async_trait;

#[async_trait]
trait MyTrait {
    async fn my_method(&self) -> i32;
}

#[async_trait]
impl MyTrait for MyStruct {
    async fn my_method(&self) -> i32 {
        42
    }
}

// âœ… ç°åœ¨å¯ä»¥ä½¿ç”¨ trait å¯¹è±¡
async fn use_trait(obj: Box<dyn MyTrait>) {
    let result = obj.my_method().await;
}
```

**å·¥ä½œåŸç†**:

```rust
// async-trait å°†è¿™ä¸ªï¼š
#[async_trait]
trait MyTrait {
    async fn my_method(&self) -> i32;
}

// è½¬æ¢ä¸ºï¼š
trait MyTrait {
    fn my_method(&self) -> Pin<Box<dyn Future<Output = i32> + Send + '_>>;
}
```

**æ€§èƒ½ä»£ä»·**:

- **å †åˆ†é…**: æ¯æ¬¡è°ƒç”¨éƒ½ä¼š `Box` åˆ†é…
- **åŠ¨æ€åˆ†æ´¾**: ä½¿ç”¨è™šè¡¨è°ƒç”¨

**æ˜¯å¦éœ€è¦**:

| åœºæ™¯ | æ¨è |
|------|------|
| **éœ€è¦ trait å¯¹è±¡** | âœ… ä½¿ç”¨ `async-trait` |
| **æ’ä»¶ç³»ç»Ÿ** | âœ… ä½¿ç”¨ |
| **æ¨¡æ‹Ÿæµ‹è¯•** | âœ… ä½¿ç”¨ |
| **è¿½æ±‚æè‡´æ€§èƒ½** | âŒ ä½¿ç”¨ GATs æˆ–å…¶ä»–æ–¹æ¡ˆ |
| **ç®€å•æ³›å‹** | âŒ ä¸éœ€è¦ï¼Œç›´æ¥ç”¨æ³›å‹ |

**æ›¿ä»£æ–¹æ¡ˆ**:

```rust
// ä½¿ç”¨ GATs (Rust 1.65+)
trait MyTrait {
    type Future<'a>: Future<Output = i32>
    where
        Self: 'a;
    
    fn my_method(&self) -> Self::Future<'_>;
}

// å®ç°
impl MyTrait for MyStruct {
    type Future<'a> = impl Future<Output = i32> + 'a;
    
    fn my_method(&self) -> Self::Future<'_> {
        async { 42 }
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q7.1](#q71-tokio-å’Œ-async-std-çš„åº“å¯ä»¥äº’ç›¸ä½¿ç”¨å—), [Q8.2](#q82-å¦‚ä½•åœ¨-trait-ä¸­å®šä¹‰å¼‚æ­¥æ–¹æ³•rust-190)

---

## 8. é«˜çº§ä¸»é¢˜

### Q8.1: å¦‚ä½•æ‰‹åŠ¨å®ç° `Future`ï¼Ÿ

**å›ç­”**:

**åŸºæœ¬ç»“æ„**:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct MyFuture {
    completed: bool,
}

impl Future for MyFuture {
    type Output = i32;
    
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if self.completed {
            Poll::Ready(42)
        } else {
            self.completed = true;
            // æ³¨å†Œ Waker ä»¥ä¾¿ç¨åå”¤é†’
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}

// ä½¿ç”¨
#[tokio::main]
async fn main() {
    let result = MyFuture { completed: false }.await;
    println!("Result: {}", result);
}
```

**çœŸå®ç¤ºä¾‹ï¼šå»¶è¿Ÿ Future**:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll, Waker};
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
    waker: Option<Waker>,
}

impl Delay {
    fn new(duration: Duration) -> Self {
        Self {
            when: Instant::now() + duration,
            waker: None,
        }
    }
}

impl Future for Delay {
    type Output = ();
    
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        if Instant::now() >= self.when {
            Poll::Ready(())
        } else {
            // ä¿å­˜ Waker
            self.waker = Some(cx.waker().clone());
            
            // åœ¨å®é™…å®ç°ä¸­ï¼Œåº”è¯¥æ³¨å†Œå®šæ—¶å™¨å›è°ƒ
            // è¿™é‡Œç®€åŒ–ä¸ºç«‹å³å”¤é†’
            if let Some(waker) = &self.waker {
                waker.wake_by_ref();
            }
            
            Poll::Pending
        }
    }
}

// ä½¿ç”¨
async fn example() {
    println!("Start");
    Delay::new(Duration::from_secs(2)).await;
    println!("2 seconds later");
}
```

**ä½¿ç”¨ `pin_project` ç®€åŒ–**:

```rust
use pin_project::pin_project;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

#[pin_project]
struct MyComplexFuture<F> {
    #[pin]
    inner: F,
    counter: usize,
}

impl<F> Future for MyComplexFuture<F>
where
    F: Future<Output = i32>,
{
    type Output = i32;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<i32> {
        let this = self.project();
        
        match this.inner.poll(cx) {
            Poll::Ready(val) => {
                *this.counter += 1;
                Poll::Ready(val)
            }
            Poll::Pending => Poll::Pending,
        }
    }
}
```

**ç›¸å…³é—®é¢˜**: [Q3.1](#q31-ä¸ºä»€ä¹ˆæˆ‘éœ€è¦-pinå®ƒçœ‹èµ·æ¥éå¸¸å¤æ‚), [Q3.3](#q33-å¦‚ä½•è·å–-pinmut-t-ä¸­çš„-t), [Q8.2](#q82-å¦‚ä½•åœ¨-trait-ä¸­å®šä¹‰å¼‚æ­¥æ–¹æ³•rust-190)

---

### Q8.2: å¦‚ä½•åœ¨ trait ä¸­å®šä¹‰å¼‚æ­¥æ–¹æ³•ï¼ˆRust 1.90ï¼‰ï¼Ÿ

**å›ç­”**:

**Rust 1.75+ å·²æ”¯æŒ trait ä¸­çš„ `async fn`**ï¼Œä½†æœ‰ä¸€äº›é™åˆ¶ã€‚

**åŸºæœ¬ä½¿ç”¨**:

```rust
// âœ… Rust 1.75+ æ”¯æŒ
trait AsyncTrait {
    async fn my_method(&self) -> i32;
}

struct MyStruct;

impl AsyncTrait for MyStruct {
    async fn my_method(&self) -> i32 {
        42
    }
}

// ä½¿ç”¨
async fn example() {
    let s = MyStruct;
    let result = s.my_method().await;
}
```

**é™åˆ¶ 1: æ— æ³•åˆ›å»º trait å¯¹è±¡**:

```rust
// âŒ ç¼–è¯‘é”™è¯¯
let obj: Box<dyn AsyncTrait> = Box::new(MyStruct);
```

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ `async-trait`

```rust
use async_trait::async_trait;

#[async_trait]
trait AsyncTrait {
    async fn my_method(&self) -> i32;
}

#[async_trait]
impl AsyncTrait for MyStruct {
    async fn my_method(&self) -> i32 {
        42
    }
}

// âœ… ç°åœ¨å¯ä»¥ä½¿ç”¨ trait å¯¹è±¡
let obj: Box<dyn AsyncTrait> = Box::new(MyStruct);
```

**é™åˆ¶ 2: æ³›å‹å‚æ•°å—é™**:

```rust
// âš ï¸ éœ€è¦ä»”ç»†å¤„ç†ç”Ÿå‘½å‘¨æœŸ
trait AsyncTrait {
    async fn process<T>(&self, data: T) -> T
    where
        T: Send + 'static;
}
```

**ä½¿ç”¨ GATs çš„é«˜çº§æ–¹æ¡ˆ**:

```rust
trait AsyncTrait {
    type ProcessFuture<'a, T>: Future<Output = T> + Send + 'a
    where
        Self: 'a,
        T: 'a;
    
    fn process<T>(&self, data: T) -> Self::ProcessFuture<'_, T>
    where
        T: Send + 'static;
}

impl AsyncTrait for MyStruct {
    type ProcessFuture<'a, T> = impl Future<Output = T> + Send + 'a
    where
        Self: 'a,
        T: 'a;
    
    fn process<T>(&self, data: T) -> Self::ProcessFuture<'_, T>
    where
        T: Send + 'static,
    {
        async move { data }
    }
}
```

**æ¨èåšæ³•**:

- **ç®€å•åœºæ™¯**: ç›´æ¥ä½¿ç”¨ trait ä¸­çš„ `async fn`
- **éœ€è¦ trait å¯¹è±¡**: ä½¿ç”¨ `async-trait`
- **è¿½æ±‚æ€§èƒ½**: ä½¿ç”¨ GATs

**ç›¸å…³é—®é¢˜**: [Q7.3](#q73-async-trait-crate-æ˜¯åšä»€ä¹ˆçš„), [Q8.1](#q81-å¦‚ä½•æ‰‹åŠ¨å®ç°-future)

---

### Q8.3: å¦‚ä½•å®ç° `AsyncDrop`ï¼Ÿ

**å›ç­”**:

**èƒŒæ™¯**: Rust ç›®å‰æ²¡æœ‰ `AsyncDrop` traitï¼ˆæ­£åœ¨ææ¡ˆä¸­ï¼‰ã€‚

**ä¸´æ—¶è§£å†³æ–¹æ¡ˆ 1**: æ˜¾å¼æ¸…ç†æ–¹æ³•

```rust
struct Resource {
    handle: Option<Handle>,
}

impl Resource {
    async fn new() -> Self {
        Self {
            handle: Some(Handle::open().await),
        }
    }
    
    // æ˜¾å¼å¼‚æ­¥æ¸…ç†
    async fn close(mut self) {
        if let Some(handle) = self.handle.take() {
            handle.close().await;
        }
    }
}

impl Drop for Resource {
    fn drop(&mut self) {
        if self.handle.is_some() {
            log::warn!("Resource not properly closed! Call .close().await");
        }
    }
}

// ä½¿ç”¨
async fn usage() {
    let resource = Resource::new().await;
    // ... ä½¿ç”¨ resource ...
    resource.close().await; // æ˜¾å¼æ¸…ç†
}
```

**ä¸´æ—¶è§£å†³æ–¹æ¡ˆ 2**: ä½¿ç”¨ `async-dropper` crate

```rust
use async_dropper::{AsyncDrop, AsyncDropper};
use async_trait::async_trait;

struct Resource {
    handle: Handle,
}

#[async_trait]
impl AsyncDrop for Resource {
    async fn async_drop(&mut self) {
        self.handle.close().await;
    }
}

// ä½¿ç”¨
async fn usage() {
    let resource = AsyncDropper::new(Resource { handle });
    // å½“ AsyncDropper è¢« drop æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ async_drop
}
```

**ä¸´æ—¶è§£å†³æ–¹æ¡ˆ 3**: ä½¿ç”¨ `scopeguard` + `spawn`

```rust
use scopeguard::defer;

async fn usage() {
    let resource = Resource::new().await;
    
    defer! {
        tokio::spawn(async move {
            resource.close().await;
        });
    }
    
    // ... ä½¿ç”¨ resource ...
}
```

**æœªæ¥å±•æœ›**:

```rust
// ææ¡ˆä¸­çš„ AsyncDrop (æœªæ¥å¯èƒ½æ”¯æŒ)
trait AsyncDrop {
    async fn drop(&mut self);
}

// ä½¿ç”¨å°†ä¼šéå¸¸ç®€å•
struct Resource;

impl AsyncDrop for Resource {
    async fn drop(&mut self) {
        cleanup().await;
    }
}
```

**å½“å‰æœ€ä½³å®è·µ**:

- **ä¼˜å…ˆ**: ä½¿ç”¨æ˜¾å¼ `close()` æ–¹æ³•
- **è¾…åŠ©**: å®ç°åŒæ­¥ `Drop` ä½œä¸ºå®‰å…¨ç½‘ï¼Œæ£€æµ‹æœªæ¸…ç†çš„èµ„æº

**ç›¸å…³é—®é¢˜**: [Q6.2](#q62-å¦‚ä½•åœ¨-drop-ä¸­æ‰§è¡Œå¼‚æ­¥æ¸…ç†), [Q6.3](#q63-å¦‚ä½•ä¼˜é›…å–æ¶ˆå¼‚æ­¥ä»»åŠ¡)

---

## ğŸ”— ç›¸å…³èµ„æº

### å®˜æ–¹æ–‡æ¡£

- [Rust Async Book](https://rust-lang.github.io/async-book/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
- [std::future](https://doc.rust-lang.org/std/future/)

### æ¨èé˜…è¯»

- [é¡¹ç›®æ¦‚è§ˆ](./01_é¡¹ç›®æ¦‚è§ˆ.md) - æ¨¡å—æ•´ä½“ä»‹ç»
- [ä¸»ç´¢å¼•å¯¼èˆª](./02_ä¸»ç´¢å¼•å¯¼èˆª.md) - å®Œæ•´æ–‡æ¡£å¯¼èˆª
- [æœ¯è¯­è¡¨](./03_æœ¯è¯­è¡¨.md) - æ ¸å¿ƒæœ¯è¯­å‚è€ƒ

### ç¤¾åŒºèµ„æº

- [Tokio Discord](https://discord.gg/tokio)
- [r/rust Subreddit](https://www.reddit.com/r/rust/)
- [Rust Users Forum](https://users.rust-lang.org/)

---

## ğŸ“ è´¡çŒ®æŒ‡å—

æ¬¢è¿è¡¥å……æ–°é—®é¢˜ï¼

**æ·»åŠ æµç¨‹**:

1. ç¡®è®¤é—®é¢˜å…·æœ‰ä»£è¡¨æ€§
2. æä¾›æ¸…æ™°çš„å›ç­”å’Œä»£ç ç¤ºä¾‹
3. æ ‡æ³¨ç›¸å…³é—®é¢˜é“¾æ¥
4. æ›´æ–°ç›®å½•

---

**æ–‡æ¡£ç»´æŠ¤**: C06 Async Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **é—®é¢˜æ€»æ•°**: 35+
