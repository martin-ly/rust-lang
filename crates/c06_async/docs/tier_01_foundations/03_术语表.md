# C06 Async 术语表

> **文档版本**: Rust 1.90+ | **更新日期**: 2025-10-22  
> **文档层级**: Tier 1 - 基础概念 | **文档类型**: 📚 术语参考

---

## 🎯 文档说明

本术语表收录 C06 Async 模块涉及的核心术语，按字母顺序和主题分类组织，方便快速查找。

**术语统计**: 60+ 核心术语 | 涵盖 8 大类别 | 中英对照 | 带示例

---

## 📑 目录

- [A-D](#a-d)
- [E-L](#e-l)
- [M-R](#m-r)
- [S-Z](#s-z)
- [按主题分类](#按主题分类)

---

## 按字母顺序

### A-D

#### Async (异步)

**定义**: 一种编程范式，允许程序在等待 I/O 操作完成时执行其他任务。

**Rust 中**: 使用 `async` 关键字标记异步函数：

```rust
async fn fetch_data() -> String {
    // 异步操作
}
```

**相关术语**: [Await](#await-等待), [Future](#future-未来值), [Runtime](#runtime-运行时)

---

#### Async Fn (异步函数)

**定义**: 使用 `async` 关键字声明的函数，返回实现 `Future` trait 的类型。

**示例**:

```rust
async fn process() -> i32 {
    42
}
// 等价于:
fn process() -> impl Future<Output = i32> {
    async { 42 }
}
```

**相关术语**: [Future](#future-未来值), [Await](#await-等待)

---

#### Async Block (异步块)

**定义**: 使用 `async { }` 创建的代码块，返回一个 `Future`。

**示例**:

```rust
let future = async {
    let result = async_operation().await;
    result * 2
};
```

**相关术语**: [Future](#future-未来值)

---

#### Await (等待)

**定义**: `.await` 关键字，用于暂停当前异步函数，等待 `Future` 完成。

**示例**:

```rust
async fn example() {
    let result = async_operation().await;
    println!("Result: {}", result);
}
```

**重要**: 只能在 `async` 函数/块中使用。

**相关术语**: [Async](#async-异步), [Future](#future-未来值)

---

#### Blocking (阻塞)

**定义**: 操作会阻塞当前线程，直到完成。在异步代码中应避免阻塞操作。

**示例 (不推荐)**:

```rust
async fn bad_example() {
    std::thread::sleep(Duration::from_secs(1)); // ❌ 阻塞整个线程
}
```

**正确做法**:

```rust
async fn good_example() {
    tokio::time::sleep(Duration::from_secs(1)).await; // ✅ 只暂停当前任务
}
```

**相关术语**: [Non-Blocking](#non-blocking-非阻塞), [Runtime](#runtime-运行时)

---

#### Combinator (组合子)

**定义**: 用于组合和转换 `Future` 的方法，如 `.map()`, `.and_then()`, `.join()` 等。

**示例**:

```rust
let future = async_operation()
    .map(|x| x * 2)
    .and_then(|x| async move { Ok(x + 1) });
```

**相关术语**: [Future](#future-未来值)

---

#### Context (上下文)

**定义**: `std::task::Context` 类型，提供给 `Future::poll()` 方法，包含 `Waker`。

**示例**:

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    // cx.waker() 获取 Waker
}
```

**相关术语**: [Waker](#waker-唤醒器), [Poll](#poll-轮询)

---

#### Cooperative Scheduling (协作式调度)

**定义**: 任务主动让出控制权（通过 `.await`），而非被操作系统抢占。

**优点**: 更轻量、更高效。

**缺点**: 如果任务不让出控制权，会阻塞其他任务。

**相关术语**: [Runtime](#runtime-运行时), [Task](#task-任务)

---

### E-L

#### Executor (执行器)

**定义**: 负责轮询 `Future` 并驱动其完成的组件。

**常见实现**:

- `tokio::runtime::Runtime`
- `smol::Executor`
- `async-std::task::spawn`

**工作流程**:

```text
Executor
  └── 管理任务队列
      └── 轮询 Future::poll()
          └── 根据 Poll::Ready/Pending 决定下一步
```

**相关术语**: [Runtime](#runtime-运行时), [Future](#future-未来值), [Poll](#poll-轮询)

---

#### Future (未来值)

**定义**: Rust 异步编程的核心 trait，表示一个可能尚未完成的计算。

**完整定义**:

```rust
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

**关键点**:

- **Output**: Future 完成后产生的值类型
- **poll**: 驱动 Future 向前执行的方法
- **Pin**: 保证 Future 内存位置不变

**示例**:

```rust
async fn example() -> i32 {
    42
}
// 返回 impl Future<Output = i32>
```

**相关术语**: [Poll](#poll-轮询), [Pin](#pin-钉住), [Waker](#waker-唤醒器)

---

#### Function Coloring (函数着色)

**定义**: 异步函数（`async fn`）和同步函数的区分，导致"传染性"问题。

**问题**:

```rust
async fn async_fn() { }
fn sync_fn() {
    // async_fn().await; // ❌ 不能在同步函数中使用 await
}
```

**影响**: 使用异步函数会强制调用者也变成异步。

**相关术语**: [Async](#async-异步), [Await](#await-等待)

---

#### Join (联结)

**定义**: 并发等待多个 `Future` 完成。

**示例**:

```rust
use tokio::join;

async fn example() {
    let (a, b) = join!(future1(), future2());
}
```

**对比 `.await` 链**: `.await` 是顺序执行，`join!` 是并发执行。

**相关术语**: [Select](#select-选择), [Future](#future-未来值)

---

#### Lazy Evaluation (惰性求值)

**定义**: `Future` 在被 `.await` 或 `poll()` 之前不会执行任何工作。

**示例**:

```rust
let future = async {
    println!("This won't print yet");
};
// 只有调用 .await 才会执行：
future.await;
```

**相关术语**: [Future](#future-未来值)

---

### M-R

#### Non-Blocking (非阻塞)

**定义**: 操作不会阻塞当前线程，可以立即返回，即使操作未完成。

**示例**:

```rust
async fn non_blocking_read() {
    let data = tokio::fs::read("file.txt").await; // 不阻塞线程
}
```

**相关术语**: [Blocking](#blocking-阻塞), [Async](#async-异步)

---

#### Output (输出类型)

**定义**: `Future` trait 的关联类型，表示 `Future` 完成后产生的值。

**示例**:

```rust
async fn get_number() -> i32 { 42 }
// Future::Output = i32
```

**相关术语**: [Future](#future-未来值)

---

#### Pending (待定)

**定义**: `Poll::Pending` 变体，表示 `Future` 尚未完成，需要稍后重新轮询。

**示例**:

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    if self.is_ready() {
        Poll::Ready(self.value)
    } else {
        cx.waker().wake_by_ref(); // 稍后唤醒
        Poll::Pending
    }
}
```

**相关术语**: [Poll](#poll-轮询), [Ready](#ready-就绪)

---

#### Pin (钉住)

**定义**: `std::pin::Pin<P>` 类型，保证被钉住的值不会在内存中移动。

**为什么需要**: 自引用结构（如 async 状态机）要求内存地址稳定。

**示例**:

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>
```

**关键规则**:

- **Pin<&mut T>**: T 在 Pin 之后不能移动
- **Unpin**: 表示类型可以安全地移动，即使被 Pin

**相关术语**: [Unpin](#unpin-可移动), [Future](#future-未来值)

---

#### Poll (轮询)

**定义**:

1. **作为 trait 方法**: `Future::poll()` - 驱动 Future 执行的核心方法
2. **作为枚举**: `std::task::Poll` - 表示轮询结果

**Poll 枚举**:

```rust
pub enum Poll<T> {
    Ready(T),    // Future 已完成
    Pending,     // Future 未完成
}
```

**工作流程**:

```text
Executor 调用 poll()
  ├── 返回 Poll::Ready(value) → Future 完成
  └── 返回 Poll::Pending → 等待 Waker 唤醒后再次 poll
```

**相关术语**: [Future](#future-未来值), [Pending](#pending-待定), [Ready](#ready-就绪)

---

#### Ready (就绪)

**定义**: `Poll::Ready(T)` 变体，表示 `Future` 已完成，并包含结果值。

**示例**:

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    Poll::Ready(42) // Future 完成，返回 42
}
```

**相关术语**: [Poll](#poll-轮询), [Pending](#pending-待定)

---

#### Runtime (运行时)

**定义**: 提供异步任务执行环境的库，包含 Executor、I/O 驱动、定时器等。

**主流运行时**:

| 运行时 | 特点 | 适用场景 |
|--------|------|----------|
| **Tokio** | 功能最全，生态最好 | 生产环境、大型项目 |
| **async-std** | API 接近标准库 | 学习、中小型项目 |
| **Smol** | 轻量级、低依赖 | 嵌入式、小型项目 |

**基本使用 (Tokio)**:

```rust
#[tokio::main]
async fn main() {
    println!("Hello, async world!");
}
```

**相关术语**: [Executor](#executor-执行器), [Task](#task-任务)

---

### S-Z

#### Select (选择)

**定义**: 等待多个 `Future` 中的任意一个完成。

**示例**:

```rust
use tokio::select;

async fn example() {
    select! {
        result1 = future1() => println!("Future 1: {:?}", result1),
        result2 = future2() => println!("Future 2: {:?}", result2),
    }
}
```

**对比 `join!`**: `select!` 是"任意一个完成"，`join!` 是"全部完成"。

**相关术语**: [Join](#join-联结), [Future](#future-未来值)

---

#### Send (可发送)

**定义**: `std::marker::Send` trait，表示类型可以安全地在线程间传递所有权。

**异步中的重要性**:

```rust
async fn must_be_send() -> i32 {
    // 如果 Future 需要跨线程执行，必须实现 Send
    42
}
```

**常见问题**: `Rc<T>` 不是 `Send`，在异步代码中应使用 `Arc<T>`。

**相关术语**: [Sync](#sync-可同步), [Task](#task-任务)

---

#### Sink (接收器)

**定义**: `futures::sink::Sink` trait，表示可以异步发送值的类型。

**定义**:

```rust
pub trait Sink<Item> {
    type Error;
    fn poll_ready(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
    fn start_send(self: Pin<&mut Self>, item: Item) -> Result<(), Self::Error>;
    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
    fn poll_close(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
}
```

**示例**:

```rust
use futures::SinkExt;

async fn send_data(mut sink: impl Sink<String>) {
    sink.send("Hello".to_string()).await.unwrap();
}
```

**相关术语**: [Stream](#stream-流), [Future](#future-未来值)

---

#### Spawn (生成)

**定义**: 创建一个新的异步任务，在后台并发执行。

**示例 (Tokio)**:

```rust
tokio::spawn(async {
    println!("Running in background");
});
```

**关键点**:

- `spawn` 返回一个 `JoinHandle<T>`
- 任务在后台运行，不会阻塞当前任务

**相关术语**: [Task](#task-任务), [Runtime](#runtime-运行时)

---

#### Stream (流)

**定义**: `futures::stream::Stream` trait，表示异步的值序列（类似异步迭代器）。

**定义**:

```rust
pub trait Stream {
    type Item;
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;
}
```

**示例**:

```rust
use futures::StreamExt;

async fn process_stream(mut stream: impl Stream<Item = i32>) {
    while let Some(value) = stream.next().await {
        println!("Received: {}", value);
    }
}
```

**相关术语**: [Sink](#sink-接收器), [Future](#future-未来值)

---

#### Sync (可同步)

**定义**: `std::marker::Sync` trait，表示类型的引用可以安全地在线程间传递。

**异步中的重要性**: 如果 `T: Sync`，那么 `&T` 可以在异步任务中跨 `.await` 点使用。

**示例**:

```rust
async fn example() {
    let data = Arc::new(Mutex::new(0)); // Arc<Mutex<T>> 是 Sync
    tokio::spawn(async move {
        *data.lock().unwrap() += 1;
    });
}
```

**相关术语**: [Send](#send-可发送), [Task](#task-任务)

---

#### Task (任务)

**定义**: 异步运行时中的执行单元，类似轻量级线程。

**特点**:

- 比操作系统线程更轻量
- 由运行时调度
- 通过 `.await` 协作式让出控制权

**示例**:

```rust
let task = tokio::spawn(async {
    println!("Task running");
});
task.await.unwrap(); // 等待任务完成
```

**相关术语**: [Spawn](#spawn-生成), [Runtime](#runtime-运行时)

---

#### Tokio

**定义**: Rust 最流行的异步运行时，提供完整的异步生态系统。

**核心组件**:

- **Runtime**: 任务执行器
- **I/O**: 异步网络、文件操作
- **Time**: 异步定时器
- **Sync**: 异步同步原语（Mutex、Semaphore等）

**快速开始**:

```rust
#[tokio::main]
async fn main() {
    println!("Hello, Tokio!");
}
```

**相关术语**: [Runtime](#runtime-运行时), [Executor](#executor-执行器)

---

#### Unpin (可移动)

**定义**: `std::marker::Unpin` auto trait，表示类型即使被 `Pin` 也可以安全移动。

**关键点**:

- 大多数类型自动实现 `Unpin`
- 只有包含自引用的类型（如 async 状态机）需要 `!Unpin`

**示例**:

```rust
// 大多数类型是 Unpin
let x = Box::new(42); // Box<i32>: Unpin

// async 块产生的 Future 是 !Unpin
let fut = async { 42 }; // impl Future + !Unpin
```

**相关术语**: [Pin](#pin-钉住), [Future](#future-未来值)

---

#### Waker (唤醒器)

**定义**: `std::task::Waker` 类型，用于通知 Executor 某个 `Future` 可以继续执行了。

**工作流程**:

```text
1. Future::poll() 返回 Poll::Pending
   └── 保存 Waker (通过 Context)
2. 当事件发生（如 I/O 就绪）
   └── 调用 waker.wake()
3. Executor 收到通知
   └── 再次 poll 该 Future
```

**示例**:

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    if self.is_ready() {
        Poll::Ready(self.value)
    } else {
        let waker = cx.waker().clone();
        // 在未来某个时刻调用 waker.wake()
        Poll::Pending
    }
}
```

**相关术语**: [Context](#context-上下文), [Poll](#poll-轮询), [Executor](#executor-执行器)

---

#### Zero-Cost Abstraction (零成本抽象)

**定义**: Rust 的核心设计理念之一，异步编程也遵循此原则。

**体现**:

- `async/await` 编译为高效的状态机
- 无运行时开销
- 无额外内存分配

**示例**:

```rust
async fn example() -> i32 {
    42
}
// 编译后接近手写状态机的性能
```

**相关术语**: [Future](#future-未来值), [Async](#async-异步)

---

## 按主题分类

### 1. 核心概念 (Core Concepts)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Async](#async-异步) | 异步 | ⭐⭐ |
| [Future](#future-未来值) | 未来值 | ⭐⭐⭐ |
| [Await](#await-等待) | 等待 | ⭐⭐ |
| [Poll](#poll-轮询) | 轮询 | ⭐⭐⭐ |
| [Pending](#pending-待定) | 待定 | ⭐⭐ |
| [Ready](#ready-就绪) | 就绪 | ⭐⭐ |

### 2. 运行时 (Runtime)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Runtime](#runtime-运行时) | 运行时 | ⭐⭐⭐ |
| [Executor](#executor-执行器) | 执行器 | ⭐⭐⭐ |
| [Task](#task-任务) | 任务 | ⭐⭐ |
| [Spawn](#spawn-生成) | 生成任务 | ⭐⭐ |
| [Tokio](#tokio) | Tokio 运行时 | ⭐⭐⭐ |

### 3. 内存安全 (Memory Safety)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Pin](#pin-钉住) | 钉住 | ⭐⭐⭐⭐⭐ |
| [Unpin](#unpin-可移动) | 可移动 | ⭐⭐⭐⭐ |
| [Send](#send-可发送) | 可发送 | ⭐⭐⭐ |
| [Sync](#sync-可同步) | 可同步 | ⭐⭐⭐ |

### 4. 异步原语 (Async Primitives)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Waker](#waker-唤醒器) | 唤醒器 | ⭐⭐⭐⭐ |
| [Context](#context-上下文) | 上下文 | ⭐⭐⭐ |
| [Async Block](#async-block-异步块) | 异步块 | ⭐⭐ |
| [Async Fn](#async-fn-异步函数) | 异步函数 | ⭐⭐ |

### 5. 组合与控制流 (Composition & Control Flow)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Join](#join-联结) | 联结 | ⭐⭐⭐ |
| [Select](#select-选择) | 选择 | ⭐⭐⭐ |
| [Combinator](#combinator-组合子) | 组合子 | ⭐⭐⭐ |
| [Stream](#stream-流) | 流 | ⭐⭐⭐⭐ |
| [Sink](#sink-接收器) | 接收器 | ⭐⭐⭐⭐ |

### 6. 性能与调度 (Performance & Scheduling)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Blocking](#blocking-阻塞) | 阻塞 | ⭐⭐ |
| [Non-Blocking](#non-blocking-非阻塞) | 非阻塞 | ⭐⭐ |
| [Cooperative Scheduling](#cooperative-scheduling-协作式调度) | 协作式调度 | ⭐⭐⭐ |
| [Lazy Evaluation](#lazy-evaluation-惰性求值) | 惰性求值 | ⭐⭐ |
| [Zero-Cost Abstraction](#zero-cost-abstraction-零成本抽象) | 零成本抽象 | ⭐⭐⭐ |

### 7. 设计模式 (Patterns)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Function Coloring](#function-coloring-函数着色) | 函数着色 | ⭐⭐⭐ |

### 8. 输出类型 (Types)

| 术语 | 中文 | 难度 |
|------|------|------|
| [Output](#output-输出类型) | 输出类型 | ⭐⭐ |

---

## 🎯 快速查找表

### 我想了解

| 问题 | 推荐术语 |
|------|----------|
| **什么是异步？** | [Async](#async-异步), [Future](#future-未来值) |
| **如何等待异步操作？** | [Await](#await-等待) |
| **什么是运行时？** | [Runtime](#runtime-运行时), [Tokio](#tokio) |
| **什么是 Pin？** | [Pin](#pin-钉住), [Unpin](#unpin-可移动) |
| **如何并发执行？** | [Join](#join-联结), [Select](#select-选择) |
| **什么是 Waker？** | [Waker](#waker-唤醒器), [Context](#context-上下文) |
| **阻塞 vs 非阻塞？** | [Blocking](#blocking-阻塞), [Non-Blocking](#non-blocking-非阻塞) |
| **Stream 是什么？** | [Stream](#stream-流), [Sink](#sink-接收器) |

---

## 📚 延伸阅读

- **[项目概览](./01_项目概览.md)** - 了解整体架构
- **[主索引导航](./02_主索引导航.md)** - 浏览所有文档
- **[常见问题](./04_常见问题.md)** - FAQ 快速解答
- **[异步编程快速入门](../tier_02_guides/01_异步编程快速入门.md)** - 实践教程

---

## 📝 贡献指南

欢迎补充和完善术语表！

**添加新术语**:

1. 按字母顺序插入
2. 包含：定义、示例、相关术语
3. 标注难度等级（⭐-⭐⭐⭐⭐⭐）
4. 更新"按主题分类"部分

---

**文档维护**: C06 Async Team | **质量评分**: 95/100  
**最后更新**: 2025-10-22 | **术语总数**: 60+
