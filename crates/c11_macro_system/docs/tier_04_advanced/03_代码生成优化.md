# 03 代码生成优化

## 目录

- [03 代码生成优化](#03-代码生成优化)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 生成代码质量](#2-生成代码质量)
    - [2.1 可读性优化](#21-可读性优化)
      - [2.1.1 生成易读的代码](#211-生成易读的代码)
      - [2.1.2 添加文档注释](#212-添加文档注释)
    - [2.2 性能优化](#22-性能优化)
      - [2.2.1 内联关键路径](#221-内联关键路径)
      - [2.2.2 避免不必要的分配](#222-避免不必要的分配)
    - [2.3 可调试性](#23-可调试性)
      - [2.3.1 保留 Span 信息](#231-保留-span-信息)
      - [2.3.2 生成调试友好的代码](#232-生成调试友好的代码)
    - [2.4 代码规范](#24-代码规范)
      - [2.4.1 遵循 Clippy 规范](#241-遵循-clippy-规范)
  - [3. 编译时间优化](#3-编译时间优化)
    - [3.1 避免宏递归爆炸](#31-避免宏递归爆炸)
      - [3.1.1 使用迭代替代递归](#311-使用迭代替代递归)
      - [3.1.2 限制递归深度](#312-限制递归深度)
    - [3.2 减少单态化开销](#32-减少单态化开销)
      - [3.2.1 泛型参数精简](#321-泛型参数精简)
      - [3.2.2 共享泛型实现](#322-共享泛型实现)
    - [3.3 增量编译友好](#33-增量编译友好)
      - [3.3.1 避免全局状态](#331-避免全局状态)
      - [3.3.2 模块化宏定义](#332-模块化宏定义)
    - [3.4 并行编译优化](#34-并行编译优化)
      - [3.4.1 减少依赖链](#341-减少依赖链)
  - [4. 代码膨胀控制](#4-代码膨胀控制)
    - [4.1 泛型特化](#41-泛型特化)
      - [4.1.1 使用 min\_specialization](#411-使用-min_specialization)
    - [4.2 条件编译](#42-条件编译)
      - [4.2.1 Feature Flags](#421-feature-flags)
      - [4.2.2 目标平台优化](#422-目标平台优化)
    - [4.3 共享代码路径](#43-共享代码路径)
      - [4.3.1 提取公共逻辑](#431-提取公共逻辑)
    - [4.4 静态 vs 动态分发](#44-静态-vs-动态分发)
      - [4.4.1 权衡分析](#441-权衡分析)
  - [5. 高级优化技术](#5-高级优化技术)
    - [5.1 常量折叠](#51-常量折叠)
      - [5.1.1 编译期计算](#511-编译期计算)
      - [5.1.2 常量传播](#512-常量传播)
    - [5.2 死代码消除](#52-死代码消除)
      - [5.2.1 条件编译](#521-条件编译)
      - [5.2.2 Dead Code Elimination（DCE）](#522-dead-code-eliminationdce)
    - [5.3 循环展开](#53-循环展开)
      - [5.3.1 手动展开](#531-手动展开)
    - [5.4 SIMD 优化](#54-simd-优化)
      - [5.4.1 自动向量化提示](#541-自动向量化提示)
      - [5.4.2 显式 SIMD](#542-显式-simd)
  - [6. 性能测量](#6-性能测量)
    - [6.1 编译时间分析](#61-编译时间分析)
      - [6.1.1 cargo build --timings](#611-cargo-build---timings)
      - [6.1.2 cargo-llvm-lines](#612-cargo-llvm-lines)
    - [6.2 二进制大小分析](#62-二进制大小分析)
      - [6.2.1 cargo-bloat](#621-cargo-bloat)
      - [6.2.2 优化策略](#622-优化策略)
    - [6.3 运行时性能](#63-运行时性能)
      - [6.3.1 Criterion 基准测试](#631-criterion-基准测试)
  - [7. 实战案例](#7-实战案例)
    - [7.1 优化序列化代码生成](#71-优化序列化代码生成)
      - [7.1.1 优化前](#711-优化前)
      - [7.1.2 优化后](#712-优化后)
    - [7.2 减少泛型膨胀](#72-减少泛型膨胀)
      - [7.2.1 问题识别](#721-问题识别)
      - [7.2.2 解决方案](#722-解决方案)
  - [8. 相关资源](#8-相关资源)
    - [8.1 工具](#81-工具)
    - [8.2 学习资源](#82-学习资源)

---

## 1. 概述

**代码生成优化**是宏系统开发中的关键环节，直接影响编译速度、二进制大小和运行时性能。本文档聚焦于如何生成**高质量、高效率、低开销**的代码。

**本文档涵盖**：

- **生成代码质量**：可读性、性能、可调试性
- **编译时间优化**：避免递归爆炸、减少单态化
- **代码膨胀控制**：泛型特化、条件编译、共享路径
- **高级优化技术**：常量折叠、死代码消除、SIMD

**适用场景**：

- ✅ 开发高性能宏库
- ✅ 优化大型项目编译时间
- ✅ 减少二进制体积
- ✅ 提升生成代码的运行时性能

**学习路径**：

1. 理解生成代码的质量标准
2. 掌握编译时间优化技术
3. 学习控制代码膨胀
4. 应用高级优化技术
5. 测量和验证优化效果

---

## 2. 生成代码质量

### 2.1 可读性优化

#### 2.1.1 生成易读的代码

```rust
// ❌ 糟糕：难以阅读
macro_rules! bad_gen {
    ($name:ident) => {
        struct $name{x:i32,y:i32}impl $name{fn new(x:i32,y:i32)->Self{Self{x,y}}}
    };
}

// ✅ 好：格式化良好
macro_rules! good_gen {
    ($name:ident) => {
        struct $name {
            x: i32,
            y: i32,
        }
        
        impl $name {
            fn new(x: i32, y: i32) -> Self {
                Self { x, y }
            }
        }
    };
}
```

#### 2.1.2 添加文档注释

```rust
macro_rules! generate_with_docs {
    ($name:ident, $doc:expr) => {
        #[doc = $doc]
        struct $name {
            value: i32,
        }
        
        impl $name {
            #[doc = concat!("Creates a new instance of `", stringify!($name), "`")]
            pub fn new(value: i32) -> Self {
                Self { value }
            }
        }
    };
}

// 使用示例
generate_with_docs!(Counter, "A simple counter struct");

// 生成的代码：
// /// A simple counter struct
// struct Counter {
//     value: i32,
// }
// impl Counter {
//     /// Creates a new instance of `Counter`
//     pub fn new(value: i32) -> Self { ... }
// }
```

---

### 2.2 性能优化

#### 2.2.1 内联关键路径

```rust
macro_rules! generate_accessor {
    ($name:ident, $field:ident, $ty:ty) => {
        // ✅ 内联简单访问器
        #[inline(always)]
        pub fn $name(&self) -> &$ty {
            &self.$field
        }
        
        // ✅ 内联简单修改器
        #[inline(always)]
        pub fn [<set_ $name>](&mut self, value: $ty) {
            self.$field = value;
        }
    };
}
```

#### 2.2.2 避免不必要的分配

```rust
// ❌ 糟糕：每次调用都分配
macro_rules! bad_format {
    ($val:expr) => {
        format!("Value: {}", $val).as_str()
    };
}

// ✅ 好：使用引用或 &'static str
macro_rules! good_format {
    ($val:expr) => {{
        const RESULT: &str = concat!("Value: ", stringify!($val));
        RESULT
    }};
}
```

---

### 2.3 可调试性

#### 2.3.1 保留 Span 信息

```rust
use proc_macro2::Span;

// ✅ 保留原始代码位置信息
fn generate_error(span: Span, message: &str) -> syn::Error {
    syn::Error::new(span, message)
}

// 错误消息会指向原始宏调用位置
```

#### 2.3.2 生成调试友好的代码

```rust
macro_rules! debug_wrapper {
    ($name:ident, $inner:ty) => {
        #[derive(Debug, Clone)] // ✅ 自动派生 Debug
        pub struct $name($inner);
        
        impl $name {
            #[track_caller] // ✅ 保留调用栈信息
            pub fn new(value: $inner) -> Self {
                Self(value)
            }
        }
    };
}
```

---

### 2.4 代码规范

#### 2.4.1 遵循 Clippy 规范

```rust
macro_rules! generate_struct {
    ($name:ident) => {
        #[allow(dead_code)] // 如果有意图不使用
        #[derive(Clone, Copy, PartialEq, Eq)] // ✅ 派生常见 trait
        pub struct $name {
            value: i32,
        }
        
        impl $name {
            #[must_use] // ✅ 标记应该使用返回值的函数
            pub const fn new(value: i32) -> Self {
                Self { value }
            }
        }
    };
}
```

---

## 3. 编译时间优化

### 3.1 避免宏递归爆炸

#### 3.1.1 使用迭代替代递归

```rust
// ❌ 糟糕：递归宏（编译慢）
macro_rules! bad_repeat {
    (0, $body:expr) => {};
    ($n:expr, $body:expr) => {
        $body;
        bad_repeat!($n - 1, $body);
    };
}

// ✅ 好：运行时循环（编译快）
macro_rules! good_repeat {
    ($n:expr, $body:expr) => {
        for _ in 0..$n {
            $body;
        }
    };
}
```

#### 3.1.2 限制递归深度

```rust
macro_rules! limited_recursion {
    (@depth 0, $($rest:tt)*) => {
        compile_error!("Recursion depth limit exceeded");
    };
    (@depth $d:expr, [$head:expr, $($tail:expr),*]) => {
        $head;
        limited_recursion!(@depth $d - 1, [$($tail),*]);
    };
    (@depth $d:expr, []) => {};
    ([$($items:expr),*]) => {
        limited_recursion!(@depth 100, [$($items),*]);
    };
}
```

---

### 3.2 减少单态化开销

#### 3.2.1 泛型参数精简

```rust
// ❌ 糟糕：过多泛型参数
struct Bad<A, B, C, D, E> {
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
}

// ✅ 好：使用关联类型
trait Config {
    type A;
    type B;
    type C;
    type D;
    type E;
}

struct Good<C: Config> {
    a: C::A,
    b: C::B,
    c: C::C,
    d: C::D,
    e: C::E,
}
```

#### 3.2.2 共享泛型实现

```rust
// ✅ 共享非泛型部分
struct Container<T> {
    data: Vec<T>,
}

impl<T> Container<T> {
    // ✅ 泛型方法（单态化）
    pub fn push(&mut self, item: T) {
        self.data.push(item);
    }
}

impl Container<()> {
    // ✅ 非泛型方法（共享）
    fn internal_helper(&self) -> usize {
        self.data.len()
    }
}

impl<T> Container<T> {
    pub fn len(&self) -> usize {
        // 重用非泛型实现
        unsafe { &*(self as *const _ as *const Container<()>) }
            .internal_helper()
    }
}
```

---

### 3.3 增量编译友好

#### 3.3.1 避免全局状态

```rust
// ❌ 糟糕：修改全局状态会触发大量重编译
static mut COUNTER: i32 = 0;

macro_rules! bad_macro {
    () => {{
        unsafe {
            COUNTER += 1;
            COUNTER
        }
    }};
}

// ✅ 好：使用局部状态
macro_rules! good_macro {
    () => {{
        let mut counter = 0;
        counter += 1;
        counter
    }};
}
```

#### 3.3.2 模块化宏定义

```rust
// ✅ 将宏拆分到多个模块
// macros/common.rs
macro_rules! common_util {
    // ...
}

// macros/specialized.rs
macro_rules! specialized_feature {
    // 依赖 common_util
}

// lib.rs
#[macro_use]
mod macros;
```

---

### 3.4 并行编译优化

#### 3.4.1 减少依赖链

```rust
// ❌ 糟糕：长依赖链
// A -> B -> C -> D -> E

// ✅ 好：并行依赖
// A -> C
// B -> C
// D -> E
```

---

## 4. 代码膨胀控制

### 4.1 泛型特化

#### 4.1.1 使用 min_specialization

```rust
#![feature(min_specialization)]

trait Process {
    fn process(&self);
}

impl<T> Process for T {
    default fn process(&self) {
        // 通用慢速实现
        println!("Generic process");
    }
}

impl Process for i32 {
    fn process(&self) {
        // i32 特化快速实现
        println!("Specialized process for i32: {}", self);
    }
}
```

---

### 4.2 条件编译

#### 4.2.1 Feature Flags

```rust
// Cargo.toml
// [features]
// simd = []

#[cfg(feature = "simd")]
fn optimized_version() {
    // SIMD 实现（仅在启用 feature 时编译）
}

#[cfg(not(feature = "simd"))]
fn optimized_version() {
    // 标量实现（回退）
}
```

#### 4.2.2 目标平台优化

```rust
#[cfg(target_arch = "x86_64")]
fn platform_specific() {
    // x86_64 优化
}

#[cfg(target_arch = "aarch64")]
fn platform_specific() {
    // ARM 优化
}

#[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64")))]
fn platform_specific() {
    // 通用实现
}
```

---

### 4.3 共享代码路径

#### 4.3.1 提取公共逻辑

```rust
// ❌ 糟糕：重复代码
impl MyType<i32> {
    pub fn process(&self) {
        // 大量相同代码
        println!("Processing i32...");
        // 具体逻辑
    }
}

impl MyType<u32> {
    pub fn process(&self) {
        // 大量相同代码（重复）
        println!("Processing u32...");
        // 具体逻辑
    }
}

// ✅ 好：共享公共逻辑
fn common_process<T>(type_name: &str) {
    println!("Processing {}...", type_name);
}

impl MyType<i32> {
    pub fn process(&self) {
        common_process::<i32>("i32");
        // 具体逻辑
    }
}

impl MyType<u32> {
    pub fn process(&self) {
        common_process::<u32>("u32");
        // 具体逻辑
    }
}
```

---

### 4.4 静态 vs 动态分发

#### 4.4.1 权衡分析

| 特性 | 静态分发 (`impl Trait`) | 动态分发 (`dyn Trait`) |
|------|------------------------|----------------------|
| **性能** | 更快（内联优化） | 稍慢（vtable 查找） |
| **二进制大小** | 更大（每个类型单态化） | 更小（共享代码） |
| **灵活性** | 编译期确定 | 运行时确定 |
| **适用场景** | 性能关键路径 | 插件系统、抽象接口 |

```rust
// ✅ 静态分发：性能优先
fn static_dispatch<T: Compute>(c: &T) -> i32 {
    c.compute() // 编译期内联
}

// ✅ 动态分发：大小优先
fn dynamic_dispatch(c: &dyn Compute) -> i32 {
    c.compute() // 运行时查找
}
```

---

## 5. 高级优化技术

### 5.1 常量折叠

#### 5.1.1 编译期计算

```rust
const fn factorial(n: u32) -> u32 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

// ✅ 编译期计算（零运行时开销）
const FACT_10: u32 = factorial(10); // 3628800

fn use_constant() {
    // 直接使用常量（无函数调用）
    println!("Factorial: {}", FACT_10);
}
```

#### 5.1.2 常量传播

```rust
macro_rules! const_compute {
    ($expr:expr) => {{
        const RESULT: i32 = $expr;
        RESULT
    }};
}

// 使用示例
let value = const_compute!(2 + 3 * 4); // 编译期计算为 14
```

---

### 5.2 死代码消除

#### 5.2.1 条件编译

```rust
macro_rules! debug_only {
    ($($code:tt)*) => {
        #[cfg(debug_assertions)]
        {
            $($code)*
        }
    };
}

// 使用示例
debug_only! {
    println!("Debug info"); // Release 构建中完全移除
}
```

#### 5.2.2 Dead Code Elimination（DCE）

```rust
#[inline(always)]
fn maybe_use(condition: bool) {
    if condition {
        expensive_operation();
    }
}

fn optimized_caller() {
    // ✅ 编译器会完全消除 expensive_operation
    maybe_use(false);
}

fn expensive_operation() {
    // 大量计算...
}
```

---

### 5.3 循环展开

#### 5.3.1 手动展开

```rust
macro_rules! unroll_4 {
    ($i:ident in $start:expr, $body:expr) => {{
        let $i = $start;
        $body;
        let $i = $start + 1;
        $body;
        let $i = $start + 2;
        $body;
        let $i = $start + 3;
        $body;
    }};
}

// 使用示例
fn unrolled_loop(data: &mut [i32; 8]) {
    unroll_4!(i in 0, {
        data[i] *= 2;
    });
    unroll_4!(i in 4, {
        data[i] *= 2;
    });
}
```

---

### 5.4 SIMD 优化

#### 5.4.1 自动向量化提示

```rust
#[inline(always)]
fn vectorizable_loop(data: &mut [f32]) {
    // ✅ 编译器友好的循环（易于向量化）
    for i in 0..data.len() {
        data[i] = data[i] * 2.0 + 1.0;
    }
}
```

#### 5.4.2 显式 SIMD

```rust
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

#[cfg(target_arch = "x86_64")]
#[target_feature(enable = "avx2")]
unsafe fn simd_multiply(a: &[f32], b: &[f32], result: &mut [f32]) {
    for i in (0..a.len()).step_by(8) {
        let va = _mm256_loadu_ps(a.as_ptr().add(i));
        let vb = _mm256_loadu_ps(b.as_ptr().add(i));
        let vr = _mm256_mul_ps(va, vb);
        _mm256_storeu_ps(result.as_mut_ptr().add(i), vr);
    }
}
```

---

## 6. 性能测量

### 6.1 编译时间分析

#### 6.1.1 cargo build --timings

```bash
# 生成编译时间报告
cargo build --release --timings

# 查看 HTML 报告
# target/cargo-timings/cargo-timing.html
```

#### 6.1.2 cargo-llvm-lines

```bash
# 安装
cargo install cargo-llvm-lines

# 分析 LLVM IR 行数（识别单态化膨胀）
cargo llvm-lines | head -20
```

**示例输出**：

```text
Lines        Copies  Function name
-----        ------  -------------
101211 (100%)  2482 (100%)  (TOTAL)
  4373 (4.3%)    1 (0.0%)  main
  3012 (3.0%)   18 (0.7%)  <alloc::vec::Vec<T> as core::ops::drop::Drop>::drop
  2591 (2.6%)   12 (0.5%)  <my_crate::MyType<T> as core::fmt::Display>::fmt
```

---

### 6.2 二进制大小分析

#### 6.2.1 cargo-bloat

```bash
# 安装
cargo install cargo-bloat

# 分析二进制大小
cargo bloat --release
```

**示例输出**：

```text
File  .text     Size Crate Name
0.5%   0.3%   4.5KiB  std  <alloc::vec::Vec<T> as core::ops::drop::Drop>::drop
0.4%   0.2%   3.2KiB  myapp my_function
```

#### 6.2.2 优化策略

```toml
# Cargo.toml
[profile.release]
opt-level = "z"    # 优化大小而非速度
lto = true         # 链接时优化
codegen-units = 1  # 更好的优化（编译更慢）
strip = true       # 剥离符号
```

---

### 6.3 运行时性能

#### 6.3.1 Criterion 基准测试

```toml
[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "my_benchmark"
harness = false
```

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_generated_code(c: &mut Criterion) {
    c.bench_function("generated_function", |b| {
        b.iter(|| {
            // 测试生成的代码
            my_generated_function(black_box(42))
        });
    });
}

criterion_group!(benches, benchmark_generated_code);
criterion_main!(benches);
```

---

## 7. 实战案例

### 7.1 优化序列化代码生成

#### 7.1.1 优化前

```rust
// ❌ 每个字段单独序列化（多次分配）
macro_rules! serialize_bad {
    ($struct:ident { $($field:ident),* }) => {
        impl Serialize for $struct {
            fn serialize(&self) -> String {
                let mut result = String::new();
                $(
                    result.push_str(&format!("{}: {}, ", stringify!($field), self.$field));
                )*
                result
            }
        }
    };
}
```

#### 7.1.2 优化后

```rust
// ✅ 预计算大小，单次分配
macro_rules! serialize_good {
    ($struct:ident { $($field:ident),* }) => {
        impl Serialize for $struct {
            fn serialize(&self) -> String {
                // 预估容量
                let capacity = 0 $(+ stringify!($field).len() + 10)*;
                let mut result = String::with_capacity(capacity);
                
                $(
                    use std::fmt::Write;
                    write!(&mut result, "{}: {}, ", stringify!($field), self.$field).unwrap();
                )*
                
                result
            }
        }
    };
}
```

---

### 7.2 减少泛型膨胀

#### 7.2.1 问题识别

```bash
# 使用 cargo-llvm-lines 发现膨胀
cargo llvm-lines | grep 'my_generic_function'

# 输出：
# 25000 (24.7%)  500 (20.1%)  my_generic_function<...>
```

#### 7.2.2 解决方案

```rust
// ❌ 原始：大量单态化
pub fn my_generic_function<T: Display>(items: &[T]) {
    for item in items {
        println!("{}", item);
        // 大量业务逻辑...
    }
}

// ✅ 优化：提取非泛型部分
fn print_item(item: &dyn Display) {
    println!("{}", item);
}

pub fn my_generic_function<T: Display>(items: &[T]) {
    for item in items {
        // ✅ 共享非泛型实现
        print_item(item);
    }
}
```

---

## 8. 相关资源

### 8.1 工具

- **cargo-llvm-lines**: 分析 LLVM IR 行数
- **cargo-bloat**: 分析二进制大小
- **cargo-flamegraph**: 生成火焰图
- **Criterion**: 基准测试框架

### 8.2 学习资源

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Rust Compiler Performance](https://perf.rust-lang.org/)
- [LLVM Optimization Passes](https://llvm.org/docs/Passes.html)

---

**下一步**：

- → 阅读 [04_宏调试深化.md](./04_宏调试深化.md) 学习调试技术
- → 参考 [C11 主索引](../../02_主索引导航.md) 探索其他主题
- → 实践 [Tier 2 宏开发指南](../../tier_02_guides/README.md) 巩固知识

---

*最后更新: 2025-10-23*
*版本: 1.0.0*
*作者: Rust 学习系统团队*
