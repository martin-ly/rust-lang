# 01 宏元编程

## 目录

- [01 宏元编程](#01-宏元编程)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 类型级编程](#2-类型级编程)
    - [2.1 PhantomData 与零大小类型](#21-phantomdata-与零大小类型)
      - [2.1.1 PhantomData 基础](#211-phantomdata-基础)
      - [2.1.2 类型安全的单位系统](#212-类型安全的单位系统)
    - [2.2 类型状态模式](#22-类型状态模式)
      - [2.2.1 状态机的类型级实现](#221-状态机的类型级实现)
      - [2.2.2 宏生成的状态机](#222-宏生成的状态机)
    - [2.3 类型级计算](#23-类型级计算)
      - [2.3.1 Peano 数字](#231-peano-数字)
      - [2.3.2 类型级布尔运算](#232-类型级布尔运算)
    - [2.4 HList 异构列表](#24-hlist-异构列表)
      - [2.4.1 基本实现](#241-基本实现)
      - [2.4.2 类型安全的 Get](#242-类型安全的-get)
  - [3. 编译期计算](#3-编译期计算)
    - [3.1 const fn 与 const 泛型](#31-const-fn-与-const-泛型)
      - [3.1.1 const fn 基础](#311-const-fn-基础)
      - [3.1.2 编译期字符串操作](#312-编译期字符串操作)
    - [3.2 编译期断言](#32-编译期断言)
      - [3.2.1 静态断言宏](#321-静态断言宏)
      - [3.2.2 类型级断言](#322-类型级断言)
    - [3.3 编译期优化](#33-编译期优化)
      - [3.3.1 循环展开](#331-循环展开)
      - [3.3.2 分支消除](#332-分支消除)
    - [3.4 宏驱动的代码生成](#34-宏驱动的代码生成)
      - [3.4.1 自动生成样板代码](#341-自动生成样板代码)
  - [4. 零成本抽象](#4-零成本抽象)
    - [4.1 内联与单态化](#41-内联与单态化)
      - [4.1.1 强制内联](#411-强制内联)
      - [4.1.2 泛型单态化](#412-泛型单态化)
    - [4.2 宏生成的零成本包装](#42-宏生成的零成本包装)
      - [4.2.1 Newtype 模式](#421-newtype-模式)
    - [4.3 编译期多态](#43-编译期多态)
      - [4.3.1 Trait 静态分发](#431-trait-静态分发)
  - [5. 高级宏模式](#5-高级宏模式)
    - [5.1 TT Munching](#51-tt-munching)
      - [5.1.1 解析逗号分隔列表](#511-解析逗号分隔列表)
    - [5.2 Push-Down Accumulation](#52-push-down-accumulation)
    - [5.3 Internal Rules](#53-internal-rules)
    - [5.4 Callback 模式](#54-callback-模式)
  - [6. 实战案例](#6-实战案例)
    - [6.1 类型安全的 Builder](#61-类型安全的-builder)
    - [6.2 编译期 SQL 验证](#62-编译期-sql-验证)
    - [6.3 零成本状态机](#63-零成本状态机)
  - [7. 相关资源](#7-相关资源)
    - [7.1 工具与库](#71-工具与库)
    - [7.2 学习资源](#72-学习资源)

---

## 1. 概述

**宏元编程**是 Rust 中最强大的元编程技术之一，结合了**类型级编程**和**编译期计算**，可以在编译期执行复杂逻辑，生成高效的零成本抽象代码。

**本文档涵盖**：

- **类型级编程**：使用类型系统进行编译期计算
- **编译期计算**：`const fn`、`const 泛型`、宏驱动优化
- **零成本抽象**：内联、单态化、编译期多态
- **高级宏模式**：TT Munching、递归宏、Callback

**适用场景**：

- ✅ 构建类型安全的 DSL 和 API
- ✅ 实现零运行时开销的状态机
- ✅ 编译期验证（如 SQL、配置）
- ✅ 生成高性能序列化/反序列化代码

**学习路径**：

1. 理解类型级编程的基本概念
2. 掌握编译期计算技术
3. 学习零成本抽象的实现
4. 实践高级宏模式
5. 应用于实际项目

---

## 2. 类型级编程

### 2.1 PhantomData 与零大小类型

#### 2.1.1 PhantomData 基础

`PhantomData` 是一个**零大小类型标记**，用于告知编译器某个类型参数的存在，即使它没有实际的字段。

```rust
use std::marker::PhantomData;

// ❌ 错误：未使用的类型参数
// struct MyType<T> {
//     value: i32,
// }

// ✅ 正确：使用 PhantomData
struct MyType<T> {
    value: i32,
    _marker: PhantomData<T>,
}

impl<T> MyType<T> {
    fn new(value: i32) -> Self {
        Self {
            value,
            _marker: PhantomData,
        }
    }
}

// 零大小验证
assert_eq!(std::mem::size_of::<MyType<String>>(), std::mem::size_of::<i32>());
```

**PhantomData 的用途**：

1. **类型安全标记**：区分不同状态或配置
2. **生命周期控制**：模拟字段的生命周期
3. **型变控制**：影响类型的协变/逆变行为

#### 2.1.2 类型安全的单位系统

```rust
use std::marker::PhantomData;

// 单位标记
struct Meter;
struct Kilometer;
struct Second;

// 测量值
struct Measurement<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<Unit> Measurement<Unit> {
    fn new(value: f64) -> Self {
        Self {
            value,
            _unit: PhantomData,
        }
    }
}

// ✅ 仅允许相同单位的运算
impl<Unit> std::ops::Add for Measurement<Unit> {
    type Output = Self;
    
    fn add(self, other: Self) -> Self {
        Self::new(self.value + other.value)
    }
}

// ✅ 单位转换
impl Measurement<Kilometer> {
    fn to_meters(self) -> Measurement<Meter> {
        Measurement::new(self.value * 1000.0)
    }
}

// 使用示例
fn type_safe_units() {
    let dist1 = Measurement::<Kilometer>::new(5.0);
    let dist2 = Measurement::<Kilometer>::new(3.0);
    
    let total_km = dist1 + dist2; // ✅ OK
    // let time = Measurement::<Second>::new(10.0);
    // let invalid = total_km + time; // ❌ 编译错误：类型不匹配！
    
    let total_m = total_km.to_meters();
    println!("Total: {} meters", total_m.value);
}
```

---

### 2.2 类型状态模式

#### 2.2.1 状态机的类型级实现

```rust
use std::marker::PhantomData;

// 状态标记
struct Unlocked;
struct Locked;

// 保险箱
struct Safe<State> {
    content: Vec<String>,
    _state: PhantomData<State>,
}

// 初始状态：未锁定
impl Safe<Unlocked> {
    fn new() -> Self {
        Self {
            content: Vec::new(),
            _state: PhantomData,
        }
    }
    
    // ✅ 仅未锁定状态可以添加物品
    fn add_item(mut self, item: String) -> Self {
        self.content.push(item);
        self
    }
    
    // 锁定，状态转换
    fn lock(self) -> Safe<Locked> {
        Safe {
            content: self.content,
            _state: PhantomData,
        }
    }
}

// 锁定状态
impl Safe<Locked> {
    // ✅ 仅锁定状态可以解锁
    fn unlock(self) -> Safe<Unlocked> {
        Safe {
            content: self.content,
            _state: PhantomData,
        }
    }
    
    // ✅ 锁定状态可以查看（只读）
    fn view(&self) -> &[String] {
        &self.content
    }
}

// 使用示例
fn typestate_example() {
    let safe = Safe::new()
        .add_item("Gold".to_string())
        .add_item("Diamonds".to_string())
        .lock();
    
    // safe.add_item("More gold".to_string()); // ❌ 编译错误：Locked 状态无此方法
    
    println!("Contents: {:?}", safe.view());
    
    let safe = safe.unlock();
    let safe = safe.add_item("More gold".to_string()).lock();
}
```

#### 2.2.2 宏生成的状态机

```rust
macro_rules! define_state_machine {
    (
        $name:ident {
            states: [ $($state:ident),+ $(,)? ],
            initial: $initial:ident,
            transitions: {
                $( $from:ident -> $to:ident via $method:ident ),+ $(,)?
            }
        }
    ) => {
        // 状态标记
        $(
            struct $state;
        )+
        
        // 状态机结构
        struct $name<State> {
            _state: std::marker::PhantomData<State>,
        }
        
        // 初始状态构造
        impl $name<$initial> {
            fn new() -> Self {
                Self {
                    _state: std::marker::PhantomData,
                }
            }
        }
        
        // 状态转换方法
        $(
            impl $name<$from> {
                fn $method(self) -> $name<$to> {
                    $name {
                        _state: std::marker::PhantomData,
                    }
                }
            }
        )+
    };
}

// 使用宏定义状态机
define_state_machine! {
    TrafficLight {
        states: [Red, Yellow, Green],
        initial: Red,
        transitions: {
            Red -> Green via change_to_green,
            Green -> Yellow via change_to_yellow,
            Yellow -> Red via change_to_red,
        }
    }
}

fn traffic_light_example() {
    let light = TrafficLight::new(); // Red
    let light = light.change_to_green(); // Green
    let light = light.change_to_yellow(); // Yellow
    let light = light.change_to_red(); // Red
    
    // light.change_to_green(); // ❌ 编译错误：Red 状态不能直接变绿（需要先变黄）
}
```

---

### 2.3 类型级计算

#### 2.3.1 Peano 数字

```rust
use std::marker::PhantomData;

// 类型级自然数
trait Nat {}

struct Zero;
struct Succ<N: Nat>(PhantomData<N>);

impl Nat for Zero {}
impl<N: Nat> Nat for Succ<N> {}

// 类型别名
type One = Succ<Zero>;
type Two = Succ<One>;
type Three = Succ<Two>;

// 类型级加法
trait Add<Rhs: Nat>: Nat {
    type Output: Nat;
}

impl<N: Nat> Add<Zero> for N {
    type Output = N;
}

impl<N: Nat, M: Nat> Add<Succ<M>> for N
where
    N: Add<M>,
{
    type Output = Succ<<N as Add<M>>::Output>;
}

// 使用示例
fn type_level_arithmetic() {
    // 类型级：1 + 2 = 3
    type OnePlusTwo = <One as Add<Two>>::Output;
    
    // 验证结果
    fn assert_three<N: Nat>() where N: Add<Zero, Output = Three> {}
    assert_three::<OnePlusTwo>(); // ✅ 编译通过
}
```

#### 2.3.2 类型级布尔运算

```rust
trait Bool {}

struct True;
struct False;

impl Bool for True {}
impl Bool for False {}

// 类型级 AND
trait And<Rhs: Bool>: Bool {
    type Output: Bool;
}

impl And<True> for True {
    type Output = True;
}

impl And<False> for True {
    type Output = False;
}

impl<Rhs: Bool> And<Rhs> for False {
    type Output = False;
}

// 类型级 NOT
trait Not: Bool {
    type Output: Bool;
}

impl Not for True {
    type Output = False;
}

impl Not for False {
    type Output = True;
}
```

---

### 2.4 HList 异构列表

#### 2.4.1 基本实现

```rust
use std::marker::PhantomData;

// HList 定义
trait HList {}

struct HNil;
struct HCons<H, T: HList> {
    head: H,
    tail: T,
}

impl HList for HNil {}
impl<H, T: HList> HList for HCons<H, T> {}

// 类型别名宏
macro_rules! hlist {
    () => { HNil };
    ($head:expr) => {
        HCons { head: $head, tail: HNil }
    };
    ($head:expr, $($tail:expr),+ $(,)?) => {
        HCons {
            head: $head,
            tail: hlist!($($tail),+),
        }
    };
}

// 使用示例
fn hlist_example() {
    let list = hlist![1, "hello", 3.14, true];
    
    println!("Head: {}", list.head); // 1
    println!("Second: {}", list.tail.head); // "hello"
}
```

#### 2.4.2 类型安全的 Get

```rust
// 索引 trait
trait Index<N> {
    type Output;
    fn get(&self) -> &Self::Output;
}

// Base case: 获取第 0 个元素
impl<H, T: HList> Index<Zero> for HCons<H, T> {
    type Output = H;
    
    fn get(&self) -> &H {
        &self.head
    }
}

// Recursive case: 获取第 N+1 个元素
impl<H, T: HList, N> Index<Succ<N>> for HCons<H, T>
where
    T: Index<N>,
{
    type Output = T::Output;
    
    fn get(&self) -> &T::Output {
        self.tail.get()
    }
}

// 使用示例
fn hlist_indexing() {
    let list = hlist![42, "Rust", 3.14];
    
    let first: &i32 = list.get::<Zero>();
    let second: &str = list.get::<One>();
    
    println!("First: {}, Second: {}", first, second);
}
```

---

## 3. 编译期计算

### 3.1 const fn 与 const 泛型

#### 3.1.1 const fn 基础

```rust
// ✅ 编译期计算
const fn factorial(n: u32) -> u32 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

// 编译期常量
const FACT_5: u32 = factorial(5); // 120

// const 泛型
fn fixed_array<const N: usize>() -> [i32; N] {
    [0; N]
}

fn const_generics_example() {
    let arr = fixed_array::<10>(); // [i32; 10]
    println!("Array: {:?}", arr);
}
```

#### 3.1.2 编译期字符串操作

```rust
const fn str_len(s: &str) -> usize {
    s.as_bytes().len()
}

const fn is_empty(s: &str) -> bool {
    str_len(s) == 0
}

const GREETING: &str = "Hello, Rust!";
const GREETING_LEN: usize = str_len(GREETING); // 12

// 编译期断言
const _: () = assert!(GREETING_LEN == 12);
```

---

### 3.2 编译期断言

#### 3.2.1 静态断言宏

```rust
macro_rules! static_assert {
    ($condition:expr) => {
        const _: () = assert!($condition);
    };
    ($condition:expr, $message:expr) => {
        const _: () = assert!($condition, $message);
    };
}

// 使用示例
static_assert!(std::mem::size_of::<usize>() == 8, "Requires 64-bit architecture");
static_assert!(std::mem::align_of::<i32>() == 4);

// ❌ 如果断言失败，编译会失败
// static_assert!(1 + 1 == 3); // error: assertion failed
```

#### 3.2.2 类型级断言

```rust
trait AssertSame<T> {}

impl<T> AssertSame<T> for T {}

// 使用示例：确保两个类型相同
fn assert_same_type<T, U>()
where
    T: AssertSame<U>,
{}

fn type_assertions() {
    assert_same_type::<i32, i32>(); // ✅ OK
    // assert_same_type::<i32, u32>(); // ❌ 编译错误
}
```

---

### 3.3 编译期优化

#### 3.3.1 循环展开

```rust
macro_rules! unroll {
    ($count:expr, |$i:ident| $body:expr) => {{
        unroll!(@inner 0, $count, $i, $body);
    }};
    (@inner $current:expr, $count:expr, $i:ident, $body:expr) => {
        if $current < $count {
            let $i = $current;
            $body;
            unroll!(@inner $current + 1, $count, $i, $body);
        }
    };
}

// 使用示例（编译期展开 5 次循环）
fn unrolled_loop() {
    let mut sum = 0;
    unroll!(5, |i| {
        sum += i;
        println!("Iteration {}", i);
    });
    
    println!("Sum: {}", sum);
}
```

#### 3.3.2 分支消除

```rust
macro_rules! conditional_compile {
    (if $feature:literal { $($then:tt)* } else { $($else:tt)* }) => {
        #[cfg(feature = $feature)]
        { $($then)* }
        
        #[cfg(not(feature = $feature))]
        { $($else)* }
    };
}

// 使用示例
fn optimized_function() {
    conditional_compile! {
        if "simd" {
            // SIMD 实现（编译期选择）
            println!("Using SIMD");
        } else {
            // 标量实现
            println!("Using scalar");
        }
    }
}
```

---

### 3.4 宏驱动的代码生成

#### 3.4.1 自动生成样板代码

```rust
macro_rules! generate_getters {
    (
        struct $name:ident {
            $( $field:ident: $ty:ty ),+ $(,)?
        }
    ) => {
        struct $name {
            $( $field: $ty ),+
        }
        
        impl $name {
            $(
                paste::paste! {
                    pub fn [<get_ $field>](&self) -> &$ty {
                        &self.$field
                    }
                    
                    pub fn [<set_ $field>](&mut self, value: $ty) {
                        self.$field = value;
                    }
                }
            )+
        }
    };
}

// 使用宏生成结构体和方法
generate_getters! {
    struct Person {
        name: String,
        age: u32,
        email: String,
    }
}

fn generated_code_example() {
    let mut person = Person {
        name: "Alice".to_string(),
        age: 30,
        email: "alice@example.com".to_string(),
    };
    
    println!("Name: {}", person.get_name());
    person.set_age(31);
    println!("Age: {}", person.get_age());
}
```

---

## 4. 零成本抽象

### 4.1 内联与单态化

#### 4.1.1 强制内联

```rust
#[inline(always)]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[inline(never)]
fn complex_function() {
    // 强制不内联（用于调试）
}

// 编译器生成的代码等价于：
fn caller() {
    let result = 1 + 2; // add() 被内联
}
```

#### 4.1.2 泛型单态化

```rust
fn print_value<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

// 编译器为每个具体类型生成独立函数：
// fn print_value_i32(value: i32) { println!("{}", value); }
// fn print_value_str(value: &str) { println!("{}", value); }

fn monomorphization_example() {
    print_value(42);        // 调用 print_value_i32
    print_value("hello");   // 调用 print_value_str
}
```

---

### 4.2 宏生成的零成本包装

#### 4.2.1 Newtype 模式

```rust
macro_rules! newtype {
    ($name:ident($inner:ty)) => {
        #[repr(transparent)] // 零成本：与 $inner 内存布局相同
        struct $name($inner);
        
        impl From<$inner> for $name {
            #[inline(always)]
            fn from(value: $inner) -> Self {
                Self(value)
            }
        }
        
        impl std::ops::Deref for $name {
            type Target = $inner;
            
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
    };
}

// 使用宏生成零成本包装
newtype!(UserId(u64));
newtype!(Email(String));

fn newtype_example() {
    let user_id = UserId::from(12345);
    let raw_id: u64 = *user_id; // 零成本解包
    
    // 编译后的汇编与直接使用 u64 相同
}
```

---

### 4.3 编译期多态

#### 4.3.1 Trait 静态分发

```rust
trait Compute {
    fn compute(&self) -> i32;
}

struct Fast;
struct Slow;

impl Compute for Fast {
    #[inline(always)]
    fn compute(&self) -> i32 {
        42 // 快速路径
    }
}

impl Compute for Slow {
    fn compute(&self) -> i32 {
        std::thread::sleep(std::time::Duration::from_millis(100));
        42 // 慢速路径
    }
}

// ✅ 静态分发（零成本）
fn static_dispatch<C: Compute>(c: &C) -> i32 {
    c.compute() // 编译期确定调用哪个实现
}

// ❌ 动态分发（有运行时开销）
fn dynamic_dispatch(c: &dyn Compute) -> i32 {
    c.compute() // 运行时通过 vtable 查找
}
```

---

## 5. 高级宏模式

### 5.1 TT Munching

**TT Munching** 是一种递归宏模式，逐个"吃掉" token。

```rust
macro_rules! count {
    () => { 0 };
    ($head:tt $($tail:tt)*) => {
        1 + count!($($tail)*)
    };
}

// 使用示例
const COUNT: usize = count!(a b c d e); // 5
```

#### 5.1.1 解析逗号分隔列表

```rust
macro_rules! parse_list {
    // Base case: 空列表
    () => {
        vec![]
    };
    // Single element
    ($single:expr) => {
        vec![$single]
    };
    // Multiple elements (递归)
    ($head:expr, $($tail:expr),+ $(,)?) => {{
        let mut vec = vec![$head];
        vec.extend(parse_list!($($tail),+));
        vec
    }};
}

fn tt_munching_example() {
    let list = parse_list!(1, 2, 3, 4, 5);
    println!("{:?}", list); // [1, 2, 3, 4, 5]
}
```

---

### 5.2 Push-Down Accumulation

```rust
macro_rules! reverse {
    // Base case
    (@accum [] [$($rev:tt)*]) => {
        ($($rev),*)
    };
    // Recursive case
    (@accum [$head:tt $($tail:tt)*] [$($rev:tt)*]) => {
        reverse!(@accum [$($tail)*] [$head $($rev)*])
    };
    // Entry point
    ($($tokens:tt)*) => {
        reverse!(@accum [$($tokens)*] [])
    };
}

// 使用示例
const REVERSED: (i32, i32, i32) = reverse!(1 2 3); // (3, 2, 1)
```

---

### 5.3 Internal Rules

```rust
macro_rules! calculate {
    // 公共接口
    ($($expr:tt)+) => {
        calculate!(@internal 0, $($expr)+)
    };
    // 内部规则：处理加法
    (@internal $acc:expr, + $num:expr $($rest:tt)*) => {
        calculate!(@internal $acc + $num, $($rest)*)
    };
    // 内部规则：处理乘法
    (@internal $acc:expr, * $num:expr $($rest:tt)*) => {
        calculate!(@internal $acc * $num, $($rest)*)
    };
    // Base case
    (@internal $acc:expr,) => {
        $acc
    };
}

// 使用示例
const RESULT: i32 = calculate!(+ 5 * 3 + 2); // 5 * 3 + 2 = 17
```

---

### 5.4 Callback 模式

```rust
macro_rules! with_numbers {
    ($callback:ident) => {
        $callback!(1, 2, 3, 4, 5);
    };
}

macro_rules! sum {
    ($($n:expr),+) => {
        0 $(+ $n)+
    };
}

macro_rules! product {
    ($($n:expr),+) => {
        1 $(* $n)+
    };
}

// 使用回调
fn callback_pattern() {
    const SUM: i32 = with_numbers!(sum);       // 15
    const PRODUCT: i32 = with_numbers!(product); // 120
    
    println!("Sum: {}, Product: {}", SUM, PRODUCT);
}
```

---

## 6. 实战案例

### 6.1 类型安全的 Builder

```rust
use std::marker::PhantomData;

// 构建器状态
struct Required;
struct Optional;

struct UserBuilder<Name, Email> {
    name: Option<String>,
    email: Option<String>,
    age: Option<u32>,
    _name_state: PhantomData<Name>,
    _email_state: PhantomData<Email>,
}

impl UserBuilder<Required, Required> {
    fn new() -> UserBuilder<Optional, Optional> {
        UserBuilder {
            name: None,
            email: None,
            age: None,
            _name_state: PhantomData,
            _email_state: PhantomData,
        }
    }
}

impl<Email> UserBuilder<Optional, Email> {
    fn name(self, name: String) -> UserBuilder<Required, Email> {
        UserBuilder {
            name: Some(name),
            email: self.email,
            age: self.age,
            _name_state: PhantomData,
            _email_state: PhantomData,
        }
    }
}

impl<Name> UserBuilder<Name, Optional> {
    fn email(self, email: String) -> UserBuilder<Name, Required> {
        UserBuilder {
            name: self.name,
            email: Some(email),
            age: self.age,
            _name_state: PhantomData,
            _email_state: PhantomData,
        }
    }
}

impl<Name, Email> UserBuilder<Name, Email> {
    fn age(mut self, age: u32) -> Self {
        self.age = Some(age);
        self
    }
}

impl UserBuilder<Required, Required> {
    fn build(self) -> User {
        User {
            name: self.name.unwrap(),
            email: self.email.unwrap(),
            age: self.age,
        }
    }
}

struct User {
    name: String,
    email: String,
    age: Option<u32>,
}

fn type_safe_builder() {
    let user = UserBuilder::new()
        .name("Alice".to_string())
        .email("alice@example.com".to_string())
        .age(30)
        .build();
    
    // let invalid = UserBuilder::new().build(); // ❌ 编译错误：缺少必填字段
}
```

---

### 6.2 编译期 SQL 验证

```rust
macro_rules! sql {
    (SELECT $($field:ident),+ FROM $table:ident WHERE $condition:expr) => {{
        // 编译期验证字段是否存在
        $(
            let _ = $table::$field;
        )+
        
        // 生成 SQL 查询
        format!(
            "SELECT {} FROM {} WHERE {}",
            stringify!($($field),+),
            stringify!($table),
            stringify!($condition)
        )
    }};
}

// 表定义
mod users {
    pub const id: &str = "id";
    pub const name: &str = "name";
    pub const email: &str = "email";
}

fn compile_time_sql() {
    let query = sql!(SELECT id, name FROM users WHERE id > 100);
    println!("Query: {}", query);
    
    // let invalid = sql!(SELECT invalid_field FROM users WHERE id > 100);
    // ❌ 编译错误：字段不存在
}
```

---

### 6.3 零成本状态机

```rust
macro_rules! state_machine {
    (
        $name:ident {
            $($state:ident { $($transition:ident -> $target:ident),* $(,)? }),+ $(,)?
        }
    ) => {
        $(
            struct $state;
        )+
        
        struct $name<State> {
            _state: PhantomData<State>,
        }
        
        $(
            impl $name<$state> {
                $(
                    #[inline(always)]
                    fn $transition(self) -> $name<$target> {
                        $name { _state: PhantomData }
                    }
                )*
            }
        )+
    };
}

state_machine! {
    Connection {
        Disconnected {
            connect -> Connected,
        },
        Connected {
            disconnect -> Disconnected,
            send_data -> Connected,
        },
    }
}

fn zero_cost_state_machine() {
    let conn = Connection::<Disconnected> { _state: PhantomData };
    let conn = conn.connect();
    let conn = conn.send_data();
    let conn = conn.disconnect();
    
    // conn.send_data(); // ❌ 编译错误：Disconnected 状态不能发送数据
}
```

---

## 7. 相关资源

### 7.1 工具与库

- **frunk**: HList 和类型级编程工具
- **typenum**: 类型级数字
- **const-fn**: 编译期计算工具
- **paste**: 宏内标识符拼接

### 7.2 学习资源

- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [Rust Reference - Type-level Programming](https://doc.rust-lang.org/reference/type-system.html)
- [Frunk Documentation](https://docs.rs/frunk/)

---

**下一步**：

- → 阅读 [02_DSL构建实践.md](./02_DSL构建实践.md) 学习 DSL 设计
- → 参考 [C11 主索引](../../02_主索引导航.md) 探索其他主题
- → 实践 [Tier 2 宏开发指南](../../tier_02_guides/README.md) 巩固知识

---

*最后更新: 2025-10-23*
*版本: 1.0.0*
*作者: Rust 学习系统团队*
