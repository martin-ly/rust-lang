# å£°æ˜å®å®Œæ•´å‚è€ƒ - macro_rules

**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+

æœ¬æ–‡æ¡£æä¾› `macro_rules!` å£°æ˜å®çš„å®Œæ•´è¯­æ³•å‚è€ƒå’Œè¯¦ç»†è§„åˆ™ã€‚

---

## ğŸ“‹ ç›®å½•

- [å£°æ˜å®å®Œæ•´å‚è€ƒ - macro\_rules](#å£°æ˜å®å®Œæ•´å‚è€ƒ---macro_rules)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. åŸºç¡€è¯­æ³•](#1-åŸºç¡€è¯­æ³•)
    - [1.1 å®å®šä¹‰ç»“æ„](#11-å®å®šä¹‰ç»“æ„)
    - [1.2 å®è°ƒç”¨å½¢å¼](#12-å®è°ƒç”¨å½¢å¼)
    - [1.3 å®å¯¼å‡º](#13-å®å¯¼å‡º)
  - [2. ç‰‡æ®µè¯´æ˜ç¬¦ (Fragment Specifiers)](#2-ç‰‡æ®µè¯´æ˜ç¬¦-fragment-specifiers)
    - [2.1 å®Œæ•´åˆ—è¡¨](#21-å®Œæ•´åˆ—è¡¨)
    - [2.2 åç»­è§„åˆ™ (Follow-Set Ambiguity)](#22-åç»­è§„åˆ™-follow-set-ambiguity)
    - [2.3 ä½¿ç”¨ç¤ºä¾‹](#23-ä½¿ç”¨ç¤ºä¾‹)
  - [3. é‡å¤æ¨¡å¼ (Repetition)](#3-é‡å¤æ¨¡å¼-repetition)
    - [3.1 é‡å¤è¯­æ³•](#31-é‡å¤è¯­æ³•)
    - [3.2 åµŒå¥—é‡å¤](#32-åµŒå¥—é‡å¤)
    - [3.3 åˆ†éš”ç¬¦è§„åˆ™](#33-åˆ†éš”ç¬¦è§„åˆ™)
  - [4. æ¨¡å¼åŒ¹é…è§„åˆ™](#4-æ¨¡å¼åŒ¹é…è§„åˆ™)
    - [4.1 åŒ¹é…ä¼˜å…ˆçº§](#41-åŒ¹é…ä¼˜å…ˆçº§)
    - [4.2 è´ªå©ªåŒ¹é…](#42-è´ªå©ªåŒ¹é…)
    - [4.3 æ­§ä¹‰å¤„ç†](#43-æ­§ä¹‰å¤„ç†)
  - [5. å…ƒå˜é‡ (Metavariables)](#5-å…ƒå˜é‡-metavariables)
    - [5.1 å‘½åè§„åˆ™](#51-å‘½åè§„åˆ™)
    - [5.2 ä½œç”¨åŸŸ](#52-ä½œç”¨åŸŸ)
    - [5.3 é‡å¤ä¸­çš„å…ƒå˜é‡](#53-é‡å¤ä¸­çš„å…ƒå˜é‡)
  - [6. å†…ç½®å®æ“ä½œ](#6-å†…ç½®å®æ“ä½œ)
    - [6.1 stringify](#61-stringify)
    - [6.2 concat](#62-concat)
    - [6.3 å…¶ä»–å·¥å…·å®](#63-å…¶ä»–å·¥å…·å®)
  - [7. é€’å½’å®](#7-é€’å½’å®)
    - [7.1 é€’å½’æ¨¡å¼](#71-é€’å½’æ¨¡å¼)
    - [7.2 é€’å½’é™åˆ¶](#72-é€’å½’é™åˆ¶)
    - [7.3 å°¾é€’å½’ä¼˜åŒ–](#73-å°¾é€’å½’ä¼˜åŒ–)
  - [8. é«˜çº§æŠ€å·§](#8-é«˜çº§æŠ€å·§)
    - [8.1 TT Munching](#81-tt-munching)
    - [8.2 å¢é‡ TT Muncher](#82-å¢é‡-tt-muncher)
    - [8.3 å›è°ƒæ¨¡å¼](#83-å›è°ƒæ¨¡å¼)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
    - [9.1 å«ç”Ÿæ€§é—®é¢˜](#91-å«ç”Ÿæ€§é—®é¢˜)
    - [9.2 ç±»å‹æ¨æ–­å¤±è´¥](#92-ç±»å‹æ¨æ–­å¤±è´¥)
    - [9.3 è¡¨è¾¾å¼æ­§ä¹‰](#93-è¡¨è¾¾å¼æ­§ä¹‰)

---

## 1. åŸºç¡€è¯­æ³•

### 1.1 å®å®šä¹‰ç»“æ„

```rust
macro_rules! macro_name {
    // è§„åˆ™ 1ï¼šæ¨¡å¼ => å±•å¼€
    (pattern1) => {
        // å±•å¼€ä»£ç 
    };

    // è§„åˆ™ 2
    (pattern2) => {
        // å±•å¼€ä»£ç 
    };

    // å¯ä»¥æœ‰ä»»æ„å¤šä¸ªè§„åˆ™
}
```

**å®Œæ•´ç¤ºä¾‹**:

```rust
macro_rules! create_function {
    // è§„åˆ™ 1ï¼šæ— å‚æ•°å‡½æ•°
    ($func_name:ident) => {
        fn $func_name() {
            println!("You called {:?}()", stringify!($func_name));
        }
    };

    // è§„åˆ™ 2ï¼šå¸¦å‚æ•°å‡½æ•°
    ($func_name:ident, $arg:ident: $type:ty) => {
        fn $func_name($arg: $type) {
            println!("You called {:?}({}: {:?})",
                     stringify!($func_name),
                     stringify!($arg),
                     stringify!($type));
        }
    };
}

create_function!(foo);
create_function!(bar, x: i32);
```

---

### 1.2 å®è°ƒç”¨å½¢å¼

å®å¯ä»¥ç”¨ä¸‰ç§åˆ†éš”ç¬¦è°ƒç”¨ï¼š

```rust
// åœ†æ‹¬å· ()
my_macro!(arg1, arg2);

// æ–¹æ‹¬å· []
my_macro![arg1, arg2];

// èŠ±æ‹¬å· {}
my_macro! { arg1, arg2 }
```

**çº¦å®š**:

- `()` - å‡½æ•°å¼è°ƒç”¨ï¼ˆå¦‚ `vec!()`, `println!()`ï¼‰
- `[]` - æ•°ç»„å¼è°ƒç”¨ï¼ˆå¦‚ `vec![1, 2, 3]`ï¼‰
- `{}` - ä»£ç å—å¼è°ƒç”¨ï¼ˆå¦‚ `thread_local! {}`ï¼‰

---

### 1.3 å®å¯¼å‡º

```rust
// å¯¼å‡ºåˆ° crate æ ¹
#[macro_export]
macro_rules! my_macro {
    () => { println!("Hello!"); };
}

// ç”¨æˆ·ä½¿ç”¨
use my_crate::my_macro;
my_macro!();
```

**æ³¨æ„**: `#[macro_export]` ä¼šå°†å®æ”¾åœ¨ crate æ ¹ï¼Œå³ä½¿å®šä¹‰åœ¨æ¨¡å—ä¸­ã€‚

---

## 2. ç‰‡æ®µè¯´æ˜ç¬¦ (Fragment Specifiers)

### 2.1 å®Œæ•´åˆ—è¡¨

| è¯´æ˜ç¬¦ | åŒ¹é…å†…å®¹ | ç¤ºä¾‹ |
|--------|---------|------|
| `ident` | æ ‡è¯†ç¬¦ | `x`, `foo`, `_value` |
| `expr` | è¡¨è¾¾å¼ | `1 + 2`, `foo()` |
| `ty` | ç±»å‹ | `i32`, `Vec<T>` |
| `pat` | æ¨¡å¼ | `Some(x)`, `_` |
| `stmt` | è¯­å¥ | `let x = 5;` |
| `block` | ä»£ç å— | `{ ... }` |
| `item` | é¡¹ | `fn`, `struct`, `mod` |
| `meta` | å±æ€§å†…å®¹ | `#[derive(Debug)]` ä¸­çš„ `derive(Debug)` |
| `tt` | Token Tree | ä»»æ„å•ä¸ª token |
| `path` | è·¯å¾„ | `std::vec::Vec` |
| `literal` | å­—é¢é‡ | `42`, `"hello"` |
| `lifetime` | ç”Ÿå‘½å‘¨æœŸ | `'a`, `'static` |
| `vis` | å¯è§æ€§ | `pub`, `pub(crate)` |

---

### 2.2 åç»­è§„åˆ™ (Follow-Set Ambiguity)

æŸäº›ç‰‡æ®µè¯´æ˜ç¬¦åé¢åªèƒ½è·Ÿç‰¹å®š tokenï¼š

| è¯´æ˜ç¬¦ | åç»­å…è®¸çš„ token |
|--------|----------------|
| `expr`, `stmt` | `=>`, `,`, `;` |
| `pat` | `=>`, `,`, `=`, `\|`, `if`, `in` |
| `path`, `ty` | `=>`, `,`, `=`, `\|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, `where` |
| `vis` | `,`, `ident` (éå…³é”®å­—), ä»»æ„é `priv` çš„ token |
| `ident`, `tt`, `item`, `block`, `meta` | ä»»æ„ token |

**ç¤ºä¾‹**:

```rust
macro_rules! follow_set {
    // âœ… åˆæ³•ï¼šexpr åè·Ÿ =>
    ($e:expr => $b:block) => { $b };

    // âŒ éæ³•ï¼šexpr åä¸èƒ½ç›´æ¥è·Ÿ ident
    // ($e:expr $i:ident) => { };
}
```

---

### 2.3 ä½¿ç”¨ç¤ºä¾‹

```rust
macro_rules! fragment_examples {
    // ident: æ ‡è¯†ç¬¦
    (ident $i:ident) => {
        let $i = 42;
    };

    // expr: è¡¨è¾¾å¼
    (expr $e:expr) => {
        println!("Result: {}", $e);
    };

    // ty: ç±»å‹
    (ty $t:ty) => {
        let _x: $t = Default::default();
    };

    // pat: æ¨¡å¼
    (pat $p:pat = $e:expr) => {
        let $p = $e;
    };

    // block: ä»£ç å—
    (block $b:block) => {
        $b
    };

    // tt: ä»»æ„ token
    (tt $($t:tt)*) => {
        $($t)*
    };
}

// ä½¿ç”¨
fragment_examples!(ident my_var);
fragment_examples!(expr 1 + 2 * 3);
fragment_examples!(ty Vec<i32>);
fragment_examples!(pat Some(x) = Some(10));
fragment_examples!(block { println!("Block"); });
fragment_examples!(tt let x = vec![1, 2, 3];);
```

---

## 3. é‡å¤æ¨¡å¼ (Repetition)

### 3.1 é‡å¤è¯­æ³•

```rust
$( pattern )* separator
```

- `*` - é›¶æ¬¡æˆ–å¤šæ¬¡
- `+` - ä¸€æ¬¡æˆ–å¤šæ¬¡
- `?` - é›¶æ¬¡æˆ–ä¸€æ¬¡

```rust
macro_rules! repeat_demo {
    // é›¶æ¬¡æˆ–å¤šæ¬¡ï¼Œé€—å·åˆ†éš”
    ($($x:expr),*) => {
        vec![$($x),*]
    };

    // ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œåˆ†å·åˆ†éš”
    ($($x:expr);+) => {
        [$($x);+]
    };

    // é›¶æ¬¡æˆ–ä¸€æ¬¡ï¼ˆå¯é€‰ï¼‰
    ($x:expr $(, $y:expr)?) => {
        ($x $(, $y)?)
    };
}

// ä½¿ç”¨
let v1 = repeat_demo!(1, 2, 3);        // vec![1, 2, 3]
let v2 = repeat_demo!(1; 2; 3);        // [1, 2, 3]
let t1 = repeat_demo!(1);              // (1,)
let t2 = repeat_demo!(1, 2);           // (1, 2)
```

---

### 3.2 åµŒå¥—é‡å¤

```rust
macro_rules! nested_repeat {
    ($(
        $outer:ident => [
            $($inner:expr),*
        ]
    ),*) => {
        $(
            let $outer = vec![$($inner),*];
        )*
    };
}

// ä½¿ç”¨
nested_repeat!(
    a => [1, 2, 3],
    b => [4, 5],
    c => [6, 7, 8, 9]
);
// å±•å¼€ä¸ºï¼š
// let a = vec![1, 2, 3];
// let b = vec![4, 5];
// let c = vec![6, 7, 8, 9];
```

---

### 3.3 åˆ†éš”ç¬¦è§„åˆ™

```rust
macro_rules! separator_demo {
    // æ— åˆ†éš”ç¬¦
    ($($x:expr)*) => { };

    // é€—å·åˆ†éš”
    ($($x:expr),*) => { };

    // åˆ†å·åˆ†éš”
    ($($x:expr);*) => { };

    // è‡ªå®šä¹‰åˆ†éš”ç¬¦
    ($($x:expr)and*) => { };
}

// ä½¿ç”¨
separator_demo!(1 2 3);           // æ— åˆ†éš”ç¬¦
separator_demo!(1, 2, 3);         // é€—å·
separator_demo!(1; 2; 3);         // åˆ†å·
separator_demo!(1 and 2 and 3);   // è‡ªå®šä¹‰
```

---

## 4. æ¨¡å¼åŒ¹é…è§„åˆ™

### 4.1 åŒ¹é…ä¼˜å…ˆçº§

å®æŒ‰å®šä¹‰é¡ºåºåŒ¹é…ï¼Œç¬¬ä¸€ä¸ªåŒ¹é…çš„è§„åˆ™è¢«ä½¿ç”¨ï¼š

```rust
macro_rules! priority_demo {
    // è§„åˆ™ 1ï¼šæ›´å…·ä½“
    (special) => { println!("Special case"); };

    // è§„åˆ™ 2ï¼šæ›´é€šç”¨
    ($x:ident) => { println!("General case: {}", stringify!($x)); };
}

priority_demo!(special);  // åŒ¹é…è§„åˆ™ 1
priority_demo!(foo);      // åŒ¹é…è§„åˆ™ 2
```

---

### 4.2 è´ªå©ªåŒ¹é…

é‡å¤åŒ¹é…æ˜¯è´ªå©ªçš„ï¼š

```rust
macro_rules! greedy {
    ($($x:expr),* , $last:expr) => {
        println!("Items: {:?}, Last: {:?}",
                 vec![$(stringify!($x)),*],
                 stringify!($last));
    };
}

greedy!(1, 2, 3, 4);
// åŒ¹é…: $x = [1, 2, 3], $last = 4
```

---

### 4.3 æ­§ä¹‰å¤„ç†

é¿å…æ­§ä¹‰çš„æœ€ä½³å®è·µï¼š

```rust
macro_rules! avoid_ambiguity {
    // âŒ æ­§ä¹‰ï¼šéš¾ä»¥åŒºåˆ†
    // ($($x:expr),* $y:expr) => { };

    // âœ… æ˜ç¡®ï¼šä½¿ç”¨ä¸åŒåˆ†éš”ç¬¦
    ($($x:expr),* ; $y:expr) => {
        vec![$($x),* , $y]
    };
}

let v = avoid_ambiguity!(1, 2, 3 ; 4);
```

---

## 5. å…ƒå˜é‡ (Metavariables)

### 5.1 å‘½åè§„åˆ™

```rust
macro_rules! naming {
    // åˆæ³•åç§°
    ($x:expr) => { };
    ($value:expr) => { };
    ($_underscore:expr) => { };

    // çº¦å®šä¿—æˆ
    ($e:expr) => { };      // e for expression
    ($i:ident) => { };     // i for identifier
    ($t:ty) => { };        // t for type
    ($p:pat) => { };       // p for pattern
}
```

---

### 5.2 ä½œç”¨åŸŸ

å…ƒå˜é‡åªåœ¨å½“å‰è§„åˆ™å†…æœ‰æ•ˆï¼š

```rust
macro_rules! scope_demo {
    ($x:expr) => {
        {
            let val = $x;  // âœ… åˆæ³•
            val * 2
        }
    };

    // ä¸èƒ½è®¿é—®å…¶ä»–è§„åˆ™çš„ $x
    ($x:expr, $y:expr) => {
        $x + $y  // è¿™é‡Œçš„ $x æ˜¯æ–°çš„æ•è·
    };
}
```

---

### 5.3 é‡å¤ä¸­çš„å…ƒå˜é‡

```rust
macro_rules! repeat_vars {
    ($($name:ident : $value:expr),*) => {
        $(
            let $name = $value;  // $name å’Œ $value åŒæ­¥è¿­ä»£
        )*
    };
}

repeat_vars!(x: 1, y: 2, z: 3);
// å±•å¼€ä¸ºï¼š
// let x = 1;
// let y = 2;
// let z = 3;
```

---

## 6. å†…ç½®å®æ“ä½œ

### 6.1 stringify

å°† token è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼š

```rust
macro_rules! debug_var {
    ($var:ident) => {
        println!("{} = {:?}", stringify!($var), $var);
    };
}

let x = 42;
debug_var!(x);  // è¾“å‡º: x = 42
```

---

### 6.2 concat

è¿æ¥å­—ç¬¦ä¸²å­—é¢é‡ï¼š

```rust
macro_rules! const_name {
    ($prefix:expr, $suffix:expr) => {
        concat!($prefix, "_", $suffix)
    };
}

const NAME: &str = const_name!("Hello", "World");
// NAME = "Hello_World"
```

---

### 6.3 å…¶ä»–å·¥å…·å®

```rust
macro_rules! tools {
    () => {
        // line!() - å½“å‰è¡Œå·
        println!("Line: {}", line!());

        // column!() - å½“å‰åˆ—å·
        println!("Column: {}", column!());

        // file!() - å½“å‰æ–‡ä»¶å
        println!("File: {}", file!());

        // module_path!() - å½“å‰æ¨¡å—è·¯å¾„
        println!("Module: {}", module_path!());
    };
}
```

---

## 7. é€’å½’å®

### 7.1 é€’å½’æ¨¡å¼

```rust
macro_rules! count {
    // é€’å½’ç»ˆæ­¢ï¼šç©º
    () => { 0 };

    // é€’å½’ï¼šæ¶ˆè€—ä¸€ä¸ªå…ƒç´ 
    ($x:tt $($rest:tt)*) => {
        1 + count!($($rest)*)
    };
}

const LEN: usize = count!(a b c d e);  // 5
```

---

### 7.2 é€’å½’é™åˆ¶

é»˜è®¤é€’å½’æ·±åº¦é™åˆ¶ä¸º 128ï¼š

```rust
#![recursion_limit = "256"]  // å¢åŠ é™åˆ¶

macro_rules! deep_recursion {
    (0) => { 0 };
    ($n:tt) => { 1 + deep_recursion!($n - 1) };
}
```

---

### 7.3 å°¾é€’å½’ä¼˜åŒ–

```rust
macro_rules! sum {
    // ç´¯åŠ å™¨æ¨¡å¼ï¼ˆå°¾é€’å½’ï¼‰
    (@acc $acc:expr) => { $acc };
    (@acc $acc:expr, $x:expr $(, $rest:expr)*) => {
        sum!(@acc $acc + $x $(, $rest)*)
    };

    // å…¬å¼€æ¥å£
    ($($x:expr),*) => {
        sum!(@acc 0 $(, $x)*)
    };
}

const TOTAL: i32 = sum!(1, 2, 3, 4, 5);  // 15
```

---

## 8. é«˜çº§æŠ€å·§

### 8.1 TT Munching

é€ä¸ªæ¶ˆè´¹ tokenï¼š

```rust
macro_rules! tt_muncher {
    // ç»ˆæ­¢æ¡ä»¶
    () => { };

    // æ¶ˆè´¹ä¸€ä¸ª token
    ($tt:tt $($rest:tt)*) => {
        println!("Token: {}", stringify!($tt));
        tt_muncher!($($rest)*);
    };
}

tt_muncher!(let x = 1 + 2;);
```

---

### 8.2 å¢é‡ TT Muncher

æ„å»ºç»“æœçš„ TT muncherï¼š

```rust
macro_rules! reverse {
    // ç»ˆæ­¢ï¼šè¾“å‡ºç´¯ç§¯ç»“æœ
    (@rev [] [$($acc:tt)*]) => {
        $($acc)*
    };

    // é€’å½’ï¼šå°† head æ·»åŠ åˆ°ç´¯ç§¯å™¨å‰é¢
    (@rev [$head:tt $($tail:tt)*] [$($acc:tt)*]) => {
        reverse!(@rev [$($tail)*] [$head $($acc)*])
    };

    // å…¬å¼€æ¥å£
    ($($tt:tt)*) => {
        reverse!(@rev [$($tt)*] [])
    };
}

reverse!(1 + 2 * 3);  // å±•å¼€ä¸º: 3 * 2 + 1
```

---

### 8.3 å›è°ƒæ¨¡å¼

å°†å®ä½œä¸ºå‚æ•°ä¼ é€’ï¼š

```rust
macro_rules! call_with_result {
    ($callback:ident, $value:expr) => {
        $callback!($value)
    };
}

macro_rules! double {
    ($x:expr) => { $x * 2 };
}

const RESULT: i32 = call_with_result!(double, 21);  // 42
```

---

## 9. å¸¸è§é™·é˜±

### 9.1 å«ç”Ÿæ€§é—®é¢˜

```rust
macro_rules! hygiene_trap {
    ($x:expr) => {
        {
            let value = $x;  // å±€éƒ¨ valueï¼Œä¸ä¼šæ³„éœ²
            value * 2
        }
    };
}

let value = 10;
let result = hygiene_trap!(5);  // value ä¸å—å½±å“
```

---

### 9.2 ç±»å‹æ¨æ–­å¤±è´¥

```rust
macro_rules! infer_fail {
    () => {
        // âŒ ç±»å‹æ¨æ–­å¯èƒ½å¤±è´¥
        // vec![]

        // âœ… æ˜ç¡®ç±»å‹
        Vec::<i32>::new()
    };
}
```

---

### 9.3 è¡¨è¾¾å¼æ­§ä¹‰

```rust
macro_rules! expr_ambiguity {
    // âŒ å¯èƒ½æ­§ä¹‰ï¼ša + b * c
    ($a:expr + $b:expr * $c:expr) => { };

    // âœ… ä½¿ç”¨æ‹¬å·æ˜ç¡®ä¼˜å…ˆçº§
    (($a:expr) + ($b:expr) * ($c:expr)) => { };
}
```

---

**ç›¸å…³æ–‡æ¡£**:

- [è¿‡ç¨‹å®APIå‚è€ƒ](./02_è¿‡ç¨‹å®APIå‚è€ƒ.md)
- [syn-quoteå‚è€ƒ](./03_syn-quoteå‚è€ƒ.md)
- [å®å«ç”Ÿæ€§å‚è€ƒ](./04_å®å«ç”Ÿæ€§å‚è€ƒ.md)
