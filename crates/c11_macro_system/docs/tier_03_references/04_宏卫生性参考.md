# 宏卫生性完整参考

**最后更新**: 2025-10-24
**适用版本**: Rust 1.90+

本文档详细说明 Rust 宏的卫生性(Hygiene)机制、作用域规则和最佳实践。

---

## 📋 目录

- [宏卫生性完整参考](#宏卫生性完整参考)
  - [📋 目录](#-目录)
  - [1. 卫生性基础](#1-卫生性基础)
    - [1.1 什么是卫生性](#11-什么是卫生性)
    - [1.2 为什么需要卫生性](#12-为什么需要卫生性)
    - [1.3 Rust 的卫生性模型](#13-rust-的卫生性模型)
  - [2. 声明宏卫生性](#2-声明宏卫生性)
    - [2.1 局部变量](#21-局部变量)
    - [2.2 函数和类型](#22-函数和类型)
    - [2.3 模块和导入](#23-模块和导入)
  - [3. 过程宏 Span](#3-过程宏-span)
    - [3.1 call\_site()](#31-call_site)
    - [3.2 def\_site()](#32-def_site)
    - [3.3 mixed\_site()](#33-mixed_site)
  - [4. 作用域规则](#4-作用域规则)
    - [4.1 声明宏作用域](#41-声明宏作用域)
    - [4.2 过程宏作用域](#42-过程宏作用域)
    - [4.3 跨 crate 作用域](#43-跨-crate-作用域)
  - [5. 打破卫生性](#5-打破卫生性)
    - [5.1 何时需要](#51-何时需要)
    - [5.2 声明宏技巧](#52-声明宏技巧)
    - [5.3 过程宏技巧](#53-过程宏技巧)
  - [6. 常见问题](#6-常见问题)
    - [6.1 变量捕获](#61-变量捕获)
    - [6.2 类型解析](#62-类型解析)
    - [6.3 trait 解析](#63-trait-解析)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 设计原则](#71-设计原则)
    - [7.2 调试技巧](#72-调试技巧)
  - [8. 高级主题](#8-高级主题)
    - [8.1 宏 2.0 (未稳定)](#81-宏-20-未稳定)
    - [8.2 与其他语言对比](#82-与其他语言对比)

---

## 1. 卫生性基础

### 1.1 什么是卫生性

**卫生性 (Hygiene)** 是指宏展开后，宏内外的标识符不会意外冲突的特性。

**卫生宏**:

- 宏内定义的变量不泄露到外部
- 宏外的变量不被宏意外捕获

**非卫生宏** (C/C++):

```c
#define SWAP(a, b) { int temp = a; a = b; b = temp; }

int temp = 1;
int x = 2, y = 3;
SWAP(x, y);  // ❌ temp 被覆盖！
```

---

### 1.2 为什么需要卫生性

**问题场景**:

```rust
// 假设宏不卫生
macro_rules! bad_macro {
    ($e:expr) => {
        {
            let result = $e;  // 如果不卫生，可能冲突
            result * 2
        }
    };
}

let result = 10;
let x = bad_macro!(result + 1);  // 如果不卫生会有问题
```

**卫生性的好处**:

1. 避免意外的名称冲突
2. 提高宏的可组合性
3. 使宏行为可预测

---

### 1.3 Rust 的卫生性模型

Rust 使用 **语法上下文 (Syntax Context)** 追踪标识符来源：

```rust
macro_rules! demo {
    () => {
        let x = 1;  // x 有 "宏定义" 上下文
    };
}

let x = 0;      // x 有 "调用点" 上下文
demo!();
println!("{}", x);  // 0，使用调用点的 x
```

**关键概念**:

- 每个标识符都有关联的 **Span**
- Span 包含 **Syntax Context**
- 不同上下文的同名标识符被视为不同

---

## 2. 声明宏卫生性

### 2.1 局部变量

```rust
macro_rules! with_temp {
    ($e:expr) => {
        {
            let temp = $e;  // 宏定义的 temp
            temp * 2
        }
    };
}

let temp = 10;
let result = with_temp!(5);  // 15
println!("temp = {}", temp); // 10，不受影响
```

**规则**:

- 宏内定义的局部变量 **不会** 泄露到外部
- 宏外的局部变量 **不会** 被宏内引用（除非通过 `$var`）

---

### 2.2 函数和类型

```rust
macro_rules! call_helper {
    () => {
        helper_function()
    };
}

fn helper_function() -> i32 {
    42
}

// ✅ 如果 helper_function 在调用点作用域内可见
let result = call_helper!();  // OK

// ❌ 如果 helper_function 不在作用域内
mod inner {
    // let result = call_helper!();  // 错误！
}
```

**规则**:

- 宏内引用的函数/类型，在 **调用点** 解析
- 使用完整路径避免歧义：`::std::vec::Vec`

---

### 2.3 模块和导入

```rust
macro_rules! use_hashmap {
    () => {
        {
            use std::collections::HashMap;  // 导入在宏内
            let mut map = HashMap::new();
            map.insert("key", "value");
            map
        }
    };
}

// HashMap 不在外部作用域
let map = use_hashmap!();
// let another = HashMap::new();  // 错误！HashMap 未导入
```

**规则**:

- `use` 语句在宏内生效
- 不会影响外部作用域

---

## 3. 过程宏 Span

### 3.1 call_site()

**最卫生的选择**，标识符使用调用点的作用域：

```rust
use proc_macro::Span;
use quote::quote;

let ident = syn::Ident::new("result", Span::call_site());

quote! {
    let #ident = 42;  // 使用调用点作用域
}
```

**效果**:

```rust
// 调用
my_macro!();

// 展开为（概念上）
let result = 42;  // result 在调用点作用域
```

---

### 3.2 def_site()

**不卫生**，标识符使用宏定义点的作用域（需要 nightly）：

```rust
#![feature(proc_macro_def_site)]

use proc_macro::Span;

let ident = syn::Ident::new("internal_var", Span::def_site());

quote! {
    let #ident = 42;  // internal_var 在宏定义作用域
}
```

**用途**:

- 宏内部辅助变量
- 避免与用户代码冲突

---

### 3.3 mixed_site()

**折中方案**，适合大多数场景（Rust 1.45+）：

```rust
use proc_macro::Span;

let ident = syn::Ident::new("helper", Span::mixed_site());

quote! {
    fn #ident() {  // helper 使用混合上下文
        // ...
    }
}
```

**特点**:

- 对 `macro_rules!` 扩展更友好
- 平衡卫生性和灵活性

---

## 4. 作用域规则

### 4.1 声明宏作用域

```rust
macro_rules! outer {
    () => {
        macro_rules! inner {  // 内部宏
            () => { 42 };
        }
        inner!()  // ✅ 可以调用
    };
}

let x = outer!();  // 42
// inner!();  // ❌ inner 不在作用域
```

**规则**:

- 宏可以定义宏
- 内部宏作用域限于外部宏展开的代码块

---

### 4.2 过程宏作用域

```rust
use quote::quote;

#[proc_macro]
pub fn gen_code(_input: TokenStream) -> TokenStream {
    quote! {
        mod internal {
            pub fn helper() -> i32 { 42 }
        }

        internal::helper()  // 可访问
    }.into()
}

// 使用
let x = gen_code!();
// internal::helper();  // ❌ internal 不在外部作用域
```

**规则**:

- 宏生成的项（函数、结构体、模块）在展开位置可见
- 除非明确标记 `pub`，否则不会泄露到外部

---

### 4.3 跨 crate 作用域

```rust
// 库 crate
#[macro_export]
macro_rules! my_macro {
    () => {
        // 使用完整路径
        ::std::vec::Vec::<i32>::new()
    };
}

// 用户 crate
use my_crate::my_macro;

let v = my_macro!();  // ✅ 即使未导入 Vec
```

**最佳实践**:

- 跨 crate 宏使用完整路径：`::std::...`
- 避免依赖调用点的导入

---

## 5. 打破卫生性

### 5.1 何时需要

**合理场景**:

1. DSL 宏需要访问外部变量
2. 测试框架需要注入变量
3. 特定领域约定

**示例**:

```rust
// 测试框架
macro_rules! assert_eq_with_context {
    ($left:expr, $right:expr) => {
        {
            let left_val = $left;
            let right_val = $right;
            assert_eq!(left_val, right_val,
                "Assertion failed in test");
        }
    };
}
```

---

### 5.2 声明宏技巧

**技巧 1: 约定的变量名**:

```rust
macro_rules! with_context {
    ($body:expr) => {
        {
            let ctx = Context::new();  // 约定名称
            $body  // 用户代码可访问 ctx
        }
    };
}

// 使用
with_context!({
    ctx.do_something();  // ❌ 实际不行，因为卫生性
});
```

**技巧 2: 显式参数**:

```rust
macro_rules! with_context {
    ($ctx:ident, $body:expr) => {
        {
            let $ctx = Context::new();  // 用户指定名称
            $body
        }
    };
}

// 使用
with_context!(ctx, {
    ctx.do_something();  // ✅ 可以访问
});
```

---

### 5.3 过程宏技巧

**使用 `Span::call_site()` + 约定**:

```rust
use proc_macro::Span;
use quote::quote;

#[proc_macro_attribute]
pub fn inject_var(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let item: syn::ItemFn = syn::parse(item).unwrap();

    // 使用 call_site，让标识符在用户作用域
    let injected = syn::Ident::new("injected_var", Span::call_site());

    quote! {
        #item

        // 用户函数可以访问 injected_var
        let #injected = 42;
    }.into()
}
```

---

## 6. 常见问题

### 6.1 变量捕获

**问题**:

```rust
macro_rules! double {
    ($x:ident) => {
        $x * 2  // ✅ 捕获用户的 $x
    };
}

let value = 10;
let result = double!(value);  // 20
```

**注意**:

- `$x:ident` 捕获标识符，保留其上下文
- `$x:expr` 捕获表达式，在宏内求值

---

### 6.2 类型解析

**问题**:

```rust
macro_rules! use_vec {
    () => {
        Vec::new()  // ❌ 如果 Vec 未导入
    };
}

// 解决：使用完整路径
macro_rules! use_vec {
    () => {
        ::std::vec::Vec::new()  // ✅
    };
}
```

---

### 6.3 trait 解析

**问题**:

```rust
macro_rules! default_value {
    ($t:ty) => {
        <$t>::default()  // ❌ 如果 Default 未导入
    };
}

// 解决
macro_rules! default_value {
    ($t:ty) => {
        <$t as ::std::default::Default>::default()  // ✅
    };
}
```

---

## 7. 最佳实践

### 7.1 设计原则

1. **默认使用卫生宏**

   ```rust
   macro_rules! good {
       ($e:expr) => {
           {
               let _temp = $e;  // 使用 _ 前缀避免冲突
               _temp
           }
       };
   }
   ```

2. **使用完整路径**

   ```rust
   macro_rules! safe {
       () => {
           ::std::vec::Vec::<i32>::new()
       };
   }
   ```

3. **明确文档化非卫生行为**

   ```rust
   /// ⚠️ 此宏会在当前作用域定义 `result` 变量
   macro_rules! defines_result {
       ($e:expr) => {
           let result = $e;
       };
   }
   ```

---

### 7.2 调试技巧

**技巧 1: 使用 cargo expand**:

```bash
cargo expand my_module::my_function
```

**技巧 2: 添加诊断**:

```rust
macro_rules! debug_hygiene {
    ($x:ident) => {
        {
            let local = 42;
            println!("Macro local: {}", local);
            println!("User var: {}", $x);
        }
    };
}
```

**技巧 3: 单元测试**:

```rust
#[test]
fn test_hygiene() {
    let local = 10;
    my_macro!(local);
    assert_eq!(local, 10);  // 确保未被修改
}
```

---

## 8. 高级主题

### 8.1 宏 2.0 (未稳定)

```rust
#![feature(decl_macro)]

pub macro my_macro($e:expr) {
    $e * 2
}
```

**特性**:

- 更好的卫生性控制
- 更灵活的导出
- 改进的作用域规则

---

### 8.2 与其他语言对比

| 语言 | 卫生性 | 机制 |
|------|-------|------|
| **Rust** | ✅ 是 | Syntax Context |
| C/C++ | ❌ 否 | 文本替换 |
| Scheme | ✅ 是 | Syntax Objects |
| Lisp | ⚠️ 部分 | 依赖实现 |
| Scala | ⚠️ 部分 | 准引用 |

---

**相关文档**:

- [声明宏完整参考](./01_声明宏完整参考.md)
- [过程宏API参考](./02_过程宏API参考.md)
- [syn-quote参考](./03_syn-quote参考.md)
