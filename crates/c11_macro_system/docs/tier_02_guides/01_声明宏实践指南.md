# C11 Macro System - Tier 2: 声明宏实践指南

> **文档版本**: v1.0.0
> **最后更新**: 2025-12-11
> **Rust 版本**: 1.92.0+
> **预计阅读**: 35 分钟

---

## 📋 目录

- [C11 Macro System - Tier 2: 声明宏实践指南](#c11-macro-system---tier-2-声明宏实践指南)
  - [📋 目录](#-目录)
  - [1. 声明宏概述](#1-声明宏概述)
  - [2. 基础语法](#2-基础语法)
    - [2.1 简单宏](#21-简单宏)
    - [2.2 带参数宏](#22-带参数宏)
    - [2.3 多分支宏](#23-多分支宏)
  - [3. 模式匹配](#3-模式匹配)
    - [3.1 片段指示符](#31-片段指示符)
    - [3.2 表达式匹配](#32-表达式匹配)
    - [3.3 类型匹配](#33-类型匹配)
  - [4. 重复语法](#4-重复语法)
    - [4.1 基础重复](#41-基础重复)
    - [4.2 嵌套重复](#42-嵌套重复)
    - [4.3 计数器](#43-计数器)
  - [5. 递归宏](#5-递归宏)
    - [5.1 列表求和](#51-列表求和)
    - [5.2 编译期斐波那契](#52-编译期斐波那契)
    - [5.3 树形结构](#53-树形结构)
  - [6. 卫生宏](#6-卫生宏)
    - [6.1 卫生宏原理](#61-卫生宏原理)
    - [6.2 破坏卫生性](#62-破坏卫生性)
  - [7. 实战案例](#7-实战案例)
    - [7.1 vec! 宏实现](#71-vec-宏实现)
    - [7.2 HashMap 初始化宏](#72-hashmap-初始化宏)
    - [7.3 assert\_matches! 宏](#73-assert_matches-宏)
    - [7.4 DSL 示例：SQL 查询](#74-dsl-示例sql-查询)
    - [7.5 测试宏](#75-测试宏)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 声明宏概述

**声明宏** (`macro_rules!`) 是 Rust 最常用的宏类型，通过模式匹配进行代码生成。

**特点**:

- ✅ 编译期展开
- ✅ 卫生宏 (Hygiene)
- ✅ 模式匹配驱动
- ✅ 零运行时开销

**基本语法**:

```rust
macro_rules! macro_name {
    (pattern) => {
        expansion
    };
}
```

---

## 2. 基础语法

### 2.1 简单宏

```rust
// 无参数宏
macro_rules! hello {
    () => {
        println!("Hello, macro!");
    };
}

fn main() {
    hello!();  // 输出: Hello, macro!
}
```

### 2.2 带参数宏

```rust
// 单参数宏
macro_rules! say {
    ($msg:expr) => {
        println!("{}", $msg);
    };
}

fn main() {
    say!("Hello");        // 输出: Hello
    say!(42);             // 输出: 42
    say!(2 + 3);          // 输出: 5
}
```

### 2.3 多分支宏

```rust
macro_rules! calculate {
    ($a:expr) => {
        $a
    };
    ($a:expr, $b:expr) => {
        $a + $b
    };
    ($a:expr, $b:expr, $c:expr) => {
        $a + $b + $c
    };
}

fn main() {
    assert_eq!(calculate!(5), 5);
    assert_eq!(calculate!(2, 3), 5);
    assert_eq!(calculate!(1, 2, 3), 6);
}
```

---

## 3. 模式匹配

### 3.1 片段指示符

| 指示符 | 匹配类型 | 示例 |
| --- | --- | --- |
| `expr` | 表达式 | `2 + 3` |
| `ident` | 标识符 | `foo` |
| `ty` | 类型 | `i32` |
| `pat` | 模式 | `Some(x)` |
| `stmt` | 语句 | `let x = 5;` |
| `block` | 代码块 | `{ ... }` |
| `item` | 项 | `fn foo() {}` |
| `tt` | Token 树 | `(a, b)` |

### 3.2 表达式匹配

```rust
macro_rules! debug {
    ($val:expr) => {
        println!("{} = {:?}", stringify!($val), $val);
    };
}

fn main() {
    let x = 42;
    debug!(x);        // 输出: x = 42
    debug!(x + 10);   // 输出: x + 10 = 52
}
```

### 3.3 类型匹配

```rust
macro_rules! create_vec {
    ($ty:ty) => {
        Vec::<$ty>::new()
    };
}

fn main() {
    let v1 = create_vec!(i32);
    let v2 = create_vec!(String);
}
```

---

## 4. 重复语法

### 4.1 基础重复

```rust
macro_rules! vec_of_strings {
    ($($x:expr),*) => {
        vec![$($x.to_string()),*]
    };
}

fn main() {
    let v = vec_of_strings!["a", "b", "c"];
    assert_eq!(v, vec!["a", "b", "c"]);
}
```

**重复语法**:

- `$(...)*`: 零次或多次
- `$(...)+`: 一次或多次
- `$(...)?`: 零次或一次

### 4.2 嵌套重复

```rust
macro_rules! matrix {
    ($([$($x:expr),*]),*) => {
        vec![$(vec![$($x),*]),*]
    };
}

fn main() {
    let m = matrix![
        [1, 2, 3],
        [4, 5, 6]
    ];
    assert_eq!(m, vec![vec![1,2,3], vec![4,5,6]]);
}
```

### 4.3 计数器

```rust
macro_rules! count {
    () => (0);
    ($x:tt $($xs:tt)*) => (1 + count!($($xs)*));
}

fn main() {
    assert_eq!(count!(), 0);
    assert_eq!(count!(a), 1);
    assert_eq!(count!(a b c), 3);
}
```

---

## 5. 递归宏

### 5.1 列表求和

```rust
macro_rules! sum {
    ($x:expr) => { $x };
    ($x:expr, $($xs:expr),+) => {
        $x + sum!($($xs),+)
    };
}

fn main() {
    assert_eq!(sum!(1), 1);
    assert_eq!(sum!(1, 2, 3, 4), 10);
}
```

### 5.2 编译期斐波那契

```rust
macro_rules! fib {
    (0) => { 0 };
    (1) => { 1 };
    ($n:expr) => {
        fib!($n - 1) + fib!($n - 2)
    };
}

// 注意：这不是真正的编译期计算，只是语法展开
// 实际使用应该用 const fn
```

### 5.3 树形结构

```rust
macro_rules! build_tree {
    ($root:expr) => {
        Node::new($root)
    };
    ($root:expr, $($child:tt)*) => {
        {
            let mut node = Node::new($root);
            $(
                node.add_child(build_tree!($child));
            )*
            node
        }
    };
}

struct Node {
    value: i32,
    children: Vec<Node>,
}

impl Node {
    fn new(value: i32) -> Self {
        Self { value, children: Vec::new() }
    }

    fn add_child(&mut self, child: Node) {
        self.children.push(child);
    }
}
```

---

## 6. 卫生宏

### 6.1 卫生宏原理

Rust 宏是 **卫生的 (hygienic)**，避免名称冲突：

```rust
macro_rules! using_temp {
    ($e:expr) => {
        {
            let temp = 1;  // 宏内部的 temp
            $e + temp
        }
    };
}

fn main() {
    let temp = 2;  // 外部的 temp
    let result = using_temp!(temp);
    assert_eq!(result, 3);  // 2 (外部) + 1 (宏内部)
}
```

### 6.2 破坏卫生性

使用 `$` 前缀可以跨越卫生边界：

```rust
macro_rules! declare_var {
    ($name:ident, $value:expr) => {
        let $name = $value;
    };
}

fn main() {
    declare_var!(x, 42);
    println!("{}", x);  // 可以访问 x
}
```

---

## 7. 实战案例

### 7.1 vec! 宏实现

```rust
#[macro_export]
macro_rules! my_vec {
    () => {
        Vec::new()
    };
    ($elem:expr; $n:expr) => {
        {
            let mut v = Vec::new();
            v.resize($n, $elem);
            v
        }
    };
    ($($x:expr),+ $(,)?) => {
        {
            let mut v = Vec::new();
            $(
                v.push($x);
            )+
            v
        }
    };
}

fn main() {
    let v1 = my_vec![];
    let v2 = my_vec![1, 2, 3];
    let v3 = my_vec![0; 5];
}
```

### 7.2 HashMap 初始化宏

```rust
#[macro_export]
macro_rules! hashmap {
    ($($key:expr => $val:expr),* $(,)?) => {
        {
            let mut map = std::collections::HashMap::new();
            $(
                map.insert($key, $val);
            )*
            map
        }
    };
}

fn main() {
    let map = hashmap! {
        "a" => 1,
        "b" => 2,
        "c" => 3,
    };
    assert_eq!(map.get("a"), Some(&1));
}
```

### 7.3 assert_matches! 宏

```rust
#[macro_export]
macro_rules! assert_matches {
    ($expr:expr, $pat:pat) => {
        match $expr {
            $pat => {},
            ref e => panic!("assertion failed: `{:?}` does not match `{}`",
                           e, stringify!($pat)),
        }
    };
}

fn main() {
    let x = Some(42);
    assert_matches!(x, Some(_));
    assert_matches!(x, Some(42));

    // assert_matches!(x, None);  // 会 panic
}
```

### 7.4 DSL 示例：SQL 查询

```rust
macro_rules! sql {
    (SELECT $($field:ident),+ FROM $table:ident WHERE $cond:expr) => {
        {
            let mut query = String::from("SELECT ");
            let fields = vec![$(stringify!($field)),+];
            query.push_str(&fields.join(", "));
            query.push_str(" FROM ");
            query.push_str(stringify!($table));
            query.push_str(" WHERE ");
            query.push_str(stringify!($cond));
            query
        }
    };
}

fn main() {
    let query = sql!(SELECT id, name, email FROM users WHERE age > 18);
    println!("{}", query);
    // 输出: SELECT id, name, email FROM users WHERE age > 18
}
```

### 7.5 测试宏

```rust
#[macro_export]
macro_rules! test_case {
    ($name:ident, $input:expr => $expected:expr) => {
        #[test]
        fn $name() {
            assert_eq!($input, $expected);
        }
    };
}

// 使用
test_case!(test_add, 2 + 2 => 4);
test_case!(test_sub, 5 - 3 => 2);
test_case!(test_mul, 3 * 4 => 12);
```

---

## 8. 总结

### 核心要点

1. **模式匹配**: 使用片段指示符 (`expr`, `ident`, `ty` 等)
2. **重复语法**: `$(...)* +  ?` 处理可变参数
3. **递归**: 实现复杂的编译期逻辑
4. **卫生性**: 避免变量名冲突
5. **DSL**: 构建领域特定语言

### 最佳实践

| 场景 | 推荐做法 |
| --- | --- |
| **简单替换** | 使用 `expr` 捕获表达式 |
| **可变参数** | 使用 `$()*` 重复语法 |
| **类型生成** | 使用 `ty` 捕获类型 |
| **DSL** | 组合多个模式分支 |
| **调试** | 使用 `cargo expand` 查看展开 |

**常见陷阱**:

- ❌ 过度使用宏，降低可读性
- ❌ 递归宏导致编译时间过长
- ❌ 忽略卫生性，导致名称冲突
- ❌ 宏错误信息不清晰
- ✅ 优先使用函数和泛型
- ✅ 为宏添加文档和示例
- ✅ 使用 `#[macro_export]` 导出宏
- ✅ 限制宏的复杂度

---

## 📚 参考资源

**官方文档**:

- [The Rust Programming Language - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [Rust Reference - Macros](https://doc.rust-lang.org/reference/macros.html)

**工具**:

- `cargo expand` - 查看宏展开结果
- `cargo rustc -- -Z macro-backtrace` - 宏错误追踪

**相关文档**:

- [Tier 2: Derive 宏开发指南](./02_Derive宏开发指南.md)
- [Tier 2: 属性宏开发指南](./03_属性宏开发指南.md)
- [Tier 3: 理论参考](../tier_03_references/)

---

**文档维护**: C11 Macro System Team
**最后审核**: 2025-10-23
**下次更新**: 2026-01-23
