# C11 Macro System - Tier 2: å‡½æ•°å®å¼€å‘æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
> **æœ€åæ›´æ–°**: 2025-12-11
> **Rust ç‰ˆæœ¬**: 1.92.0+
> **é¢„è®¡é˜…è¯»**: 30 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C11 Macro System - Tier 2: å‡½æ•°å®å¼€å‘æŒ‡å—](#c11-macro-system---tier-2-å‡½æ•°å®å¼€å‘æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å‡½æ•°å®æ¦‚è¿°](#1-å‡½æ•°å®æ¦‚è¿°)
  - [2. åŸºç¡€è¯­æ³•](#2-åŸºç¡€è¯­æ³•)
    - [2.1 å®šä¹‰å‡½æ•°å®](#21-å®šä¹‰å‡½æ•°å®)
    - [2.2 ä½¿ç”¨å‡½æ•°å®](#22-ä½¿ç”¨å‡½æ•°å®)
  - [3. Token æµè§£æ](#3-token-æµè§£æ)
    - [3.1 æ‰‹åŠ¨è§£æ](#31-æ‰‹åŠ¨è§£æ)
    - [3.2 ä½¿ç”¨ syn è§£æ](#32-ä½¿ç”¨-syn-è§£æ)
  - [4. å®æˆ˜æ¡ˆä¾‹](#4-å®æˆ˜æ¡ˆä¾‹)
    - [4.1 SQL æŸ¥è¯¢å®](#41-sql-æŸ¥è¯¢å®)
    - [4.2 JSON å®](#42-json-å®)
    - [4.3 HTML æ¨¡æ¿å®](#43-html-æ¨¡æ¿å®)
    - [4.4 æ­£åˆ™è¡¨è¾¾å¼å®](#44-æ­£åˆ™è¡¨è¾¾å¼å®)
    - [4.5 æµ‹è¯•å®](#45-æµ‹è¯•å®)
  - [5. æ€»ç»“](#5-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å‡½æ•°å®å¼€å‘æŒ‡å— (Function-like Macro Development Guide)**:

- **å®šä¹‰**: å¼€å‘å‡½æ•°å¼è¿‡ç¨‹å®çš„å®è·µæŒ‡å—ï¼Œç”¨äº DSL å’Œä»£ç ç”Ÿæˆ
- **ç±»å‹**: å¼€å‘æŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: è¿‡ç¨‹å®ã€å…ƒç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.15+ (è¿‡ç¨‹å®)
- **ç›¸å…³æ¦‚å¿µ**: å‡½æ•°å®ã€è¿‡ç¨‹å®ã€Token æµã€DSL

**å‡½æ•°å® (Function-like Macro)**:

- **å®šä¹‰**: çœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨çš„è¿‡ç¨‹å®ï¼Œåœ¨ç¼–è¯‘æœŸå±•å¼€ï¼Œå¯ä»¥æ¥å—ä»»æ„ Token æµä½œä¸ºè¾“å…¥
- **ç±»å‹**: è¿‡ç¨‹å®
- **å±æ€§**: ç±»ä¼¼å‡½æ•°è°ƒç”¨ã€æ¥å—ä»»æ„è¯­æ³•ã€è¿”å›ä»»æ„ä»£ç 
- **å…³ç³»**: ä¸å£°æ˜å®ã€å±æ€§å®ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **ç±»ä¼¼å‡½æ•°è°ƒç”¨**: `macro!(args)` è¯­æ³•
- **æ¥å—ä»»æ„è¯­æ³•**: å¯ä»¥æ¥å—ä»»æ„ Token æµ
- **è¿”å›ä»»æ„ä»£ç **: å¯ä»¥ç”Ÿæˆä»»æ„ä»£ç 
- **DSL æ”¯æŒ**: ç”¨äºæ„å»º DSL

**æ€§èƒ½ç‰¹å¾**:

- **ç¼–è¯‘æ—¶å±•å¼€**: åœ¨ç¼–è¯‘æ—¶å±•å¼€
- **é›¶è¿è¡Œæ—¶å¼€é”€**: å±•å¼€åçš„ä»£ç æ— é¢å¤–å¼€é”€
- **é€‚ç”¨åœºæ™¯**: DSLã€ä»£ç ç”Ÿæˆã€æ¨¡æ¿ç³»ç»Ÿ

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- å‡½æ•°å® --[is-a]--> è¿‡ç¨‹å®
- SQL æŸ¥è¯¢å® --[is-a]--> å‡½æ•°å®

**ç»„åˆå…³ç³»**:

- å‡½æ•°å®å¼€å‘æŒ‡å— --[uses]--> Token æµè§£æ
- DSL æ„å»º --[uses]--> å‡½æ•°å®

**ä¾èµ–å…³ç³»**:

- å‡½æ•°å® --[depends-on]--> è¿‡ç¨‹å®æ”¯æŒ
- DSL å¼€å‘ --[depends-on]--> å‡½æ•°å®

### æ€ç»´å¯¼å›¾

```text
å‡½æ•°å®å¼€å‘æŒ‡å—
â”‚
â”œâ”€â”€ åŸºç¡€è¯­æ³•
â”‚   â”œâ”€â”€ å®šä¹‰å‡½æ•°å®
â”‚   â””â”€â”€ ä½¿ç”¨å‡½æ•°å®
â”œâ”€â”€ Token æµè§£æ
â”‚   â”œâ”€â”€ æ‰‹åŠ¨è§£æ
â”‚   â””â”€â”€ ä½¿ç”¨ syn è§£æ
â””â”€â”€ å®æˆ˜æ¡ˆä¾‹
    â”œâ”€â”€ SQL æŸ¥è¯¢å®
    â””â”€â”€ JSON å®
```

---

## 1. å‡½æ•°å®æ¦‚è¿°

**å‡½æ•°å®** çœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ï¼Œä½†åœ¨ç¼–è¯‘æœŸå±•å¼€ï¼Œå¯ä»¥æ¥å—ä»»æ„ Token æµä½œä¸ºè¾“å…¥ã€‚

**ç‰¹ç‚¹**:

- âœ… ç±»ä¼¼å‡½æ•°è°ƒç”¨ `macro!(args)`
- âœ… æ¥å—ä»»æ„è¯­æ³•
- âœ… è¿”å›ä»»æ„ä»£ç 
- âœ… ç”¨äº DSL å’Œä»£ç ç”Ÿæˆ

---

## 2. åŸºç¡€è¯­æ³•

### 2.1 å®šä¹‰å‡½æ•°å®

```rust
use proc_macro::TokenStream;

#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // å¤„ç†è¾“å…¥ï¼Œè¿”å›è¾“å‡º
    input
}
```

### 2.2 ä½¿ç”¨å‡½æ•°å®

```rust
use my_macros::my_macro;

fn main() {
    my_macro!(some input here);
}
```

---

## 3. Token æµè§£æ

### 3.1 æ‰‹åŠ¨è§£æ

```rust
use proc_macro::TokenStream;

#[proc_macro]
pub fn parse_example(input: TokenStream) -> TokenStream {
    for token in input {
        println!("{:?}", token);
    }
    TokenStream::new()
}
```

### 3.2 ä½¿ç”¨ syn è§£æ

```rust
use syn::parse::{Parse, ParseStream};
use syn::{Ident, Token, LitStr};

struct SqlQuery {
    table: Ident,
    _where: Token![where],
    condition: LitStr,
}

impl Parse for SqlQuery {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(SqlQuery {
            table: input.parse()?,
            _where: input.parse()?,
            condition: input.parse()?,
        })
    }
}

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let query = parse_macro_input!(input as SqlQuery);

    let table = &query.table;
    let condition = &query.condition;

    let expanded = quote! {
        format!("SELECT * FROM {} WHERE {}",
                stringify!(#table), #condition)
    };

    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// let query = sql!(users where "age > 18");
```

---

## 4. å®æˆ˜æ¡ˆä¾‹

### 4.1 SQL æŸ¥è¯¢å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::parse::{Parse, ParseStream};
use syn::{Ident, LitStr, Token};

struct SelectQuery {
    _select: Token![select],
    fields: Vec<Ident>,
    _from: Token![from],
    table: Ident,
    _where: Option<Token![where]>,
    condition: Option<LitStr>,
}

impl Parse for SelectQuery {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let _select: Token![select] = input.parse()?;

        let mut fields = Vec::new();
        loop {
            fields.push(input.parse()?);
            if input.peek(Token![from]) {
                break;
            }
            input.parse::<Token![,]>()?;
        }

        let _from: Token![from] = input.parse()?;
        let table: Ident = input.parse()?;

        let _where = input.parse().ok();
        let condition = if _where.is_some() {
            Some(input.parse()?)
        } else {
            None
        };

        Ok(SelectQuery {
            _select,
            fields,
            _from,
            table,
            _where,
            condition,
        })
    }
}

#[proc_macro]
pub fn sql_select(input: TokenStream) -> TokenStream {
    let query = parse_macro_input!(input as SelectQuery);

    let fields = &query.fields;
    let table = &query.table;

    let field_str = fields.iter()
        .map(|f| f.to_string())
        .collect::<Vec<_>>()
        .join(", ");

    let where_clause = if let Some(cond) = &query.condition {
        format!(" WHERE {}", cond.value())
    } else {
        String::new()
    };

    let sql = format!("SELECT {} FROM {}{}",
                      field_str,
                      table.to_string(),
                      where_clause);

    let expanded = quote! {
        #sql
    };

    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// let query = sql_select!(select id, name, email from users where "age > 18");
```

### 4.2 JSON å®

```rust
#[proc_macro]
pub fn json(input: TokenStream) -> TokenStream {
    // ç®€åŒ–å®ç°
    let expanded = quote! {
        serde_json::json!(#input)
    };
    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// let data = json!({
//     "name": "Alice",
//     "age": 30
// });
```

### 4.3 HTML æ¨¡æ¿å®

```rust
#[proc_macro]
pub fn html(input: TokenStream) -> TokenStream {
    // å°† HTML DSL è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    let html_str = input.to_string();

    let expanded = quote! {
        format!(#html_str)
    };

    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// let page = html!{
//     <html>
//         <body>
//             <h1>Hello</h1>
//         </body>
//     </html>
// };
```

### 4.4 æ­£åˆ™è¡¨è¾¾å¼å®

```rust
#[proc_macro]
pub fn regex(input: TokenStream) -> TokenStream {
    let pattern = input.to_string();

    // ç¼–è¯‘æœŸéªŒè¯æ­£åˆ™è¡¨è¾¾å¼
    if let Err(e) = regex::Regex::new(&pattern) {
        panic!("Invalid regex: {}", e);
    }

    let expanded = quote! {
        regex::Regex::new(#pattern).unwrap()
    };

    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// let re = regex!(r"\d{3}-\d{4}");
```

### 4.5 æµ‹è¯•å®

```rust
#[proc_macro]
pub fn test_cases(input: TokenStream) -> TokenStream {
    // è§£ææµ‹è¯•ç”¨ä¾‹åˆ—è¡¨
    // ç”Ÿæˆå¤šä¸ª #[test] å‡½æ•°

    let expanded = quote! {
        #[test]
        fn test_case_1() {
            assert_eq!(2 + 2, 4);
        }

        #[test]
        fn test_case_2() {
            assert_eq!(3 + 3, 6);
        }
    };

    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// test_cases! {
//     (2 + 2) == 4,
//     (3 + 3) == 6,
// }
```

---

## 5. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å®šä¹‰**: `#[proc_macro]`
2. **è¾“å…¥**: `TokenStream` (ä»»æ„è¯­æ³•)
3. **è¾“å‡º**: `TokenStream` (ç”Ÿæˆçš„ä»£ç )
4. **è§£æ**: è‡ªå®šä¹‰è§£ææˆ–ä½¿ç”¨ `syn`
5. **ç”¨é€”**: DSLã€ä»£ç ç”Ÿæˆã€ç¼–è¯‘æœŸéªŒè¯

### æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èåšæ³• |
| --- | --- |
| **DSL** | å®šä¹‰æ¸…æ™°çš„è¯­æ³•è§„åˆ™ |
| **ä»£ç ç”Ÿæˆ** | ä½¿ç”¨ `quote!` |
| **ç¼–è¯‘æœŸéªŒè¯** | åœ¨å®ä¸­è¿›è¡Œæ£€æŸ¥ |
| **é”™è¯¯å¤„ç†** | ä½¿ç”¨ `compile_error!` |
| **æ–‡æ¡£** | æä¾›æ¸…æ™°çš„ç”¨æ³•ç¤ºä¾‹ |

**å¸¸è§é™·é˜±**:

- âŒ è¿‡äºå¤æ‚çš„è¯­æ³•
- âŒ é”™è¯¯ä¿¡æ¯ä¸æ¸…æ™°
- âŒ ç¼ºå°‘ç¼–è¯‘æœŸéªŒè¯
- âŒ æ€§èƒ½é—®é¢˜
- âœ… ä¿æŒè¯­æ³•ç®€å•
- âœ… æä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
- âœ… åˆ©ç”¨ç¼–è¯‘æœŸæ£€æŸ¥
- âœ… é¿å…ç”Ÿæˆè¿‡å¤šä»£ç 

---

## ğŸ“š å‚è€ƒèµ„æº

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: å£°æ˜å®å®è·µæŒ‡å—](./01_å£°æ˜å®å®è·µæŒ‡å—.md)
- [Tier 2: Derive å®å¼€å‘æŒ‡å—](./02_Deriveå®å¼€å‘æŒ‡å—.md)
- [Tier 2: å®è°ƒè¯•ä¸æµ‹è¯•](./05_å®è°ƒè¯•ä¸æµ‹è¯•.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C11 Macro System Team
**æœ€åå®¡æ ¸**: 2025-10-23
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
