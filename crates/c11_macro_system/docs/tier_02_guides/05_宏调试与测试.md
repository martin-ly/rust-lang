# C11 Macro System - Tier 2: å®è°ƒè¯•ä¸æµ‹è¯•

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
> **æœ€åæ›´æ–°**: 2025-12-11
> **Rust ç‰ˆæœ¬**: 1.92.0+
> **é¢„è®¡é˜…è¯»**: 30 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C11 Macro System - Tier 2: å®è°ƒè¯•ä¸æµ‹è¯•](#c11-macro-system---tier-2-å®è°ƒè¯•ä¸æµ‹è¯•)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. è°ƒè¯•å·¥å…·](#1-è°ƒè¯•å·¥å…·)
    - [1.1 cargo expand](#11-cargo-expand)
    - [1.2 println! è°ƒè¯•](#12-println-è°ƒè¯•)
    - [1.3 IDE æ”¯æŒ](#13-ide-æ”¯æŒ)
  - [2. å®å±•å¼€](#2-å®å±•å¼€)
    - [2.1 æŸ¥çœ‹å±•å¼€ç»“æœ](#21-æŸ¥çœ‹å±•å¼€ç»“æœ)
    - [2.2 éƒ¨åˆ†å±•å¼€](#22-éƒ¨åˆ†å±•å¼€)
  - [3. é”™è¯¯å¤„ç†](#3-é”™è¯¯å¤„ç†)
    - [3.1 ç¼–è¯‘é”™è¯¯](#31-ç¼–è¯‘é”™è¯¯)
    - [3.2 è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯](#32-è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯)
  - [4. æµ‹è¯•ç­–ç•¥](#4-æµ‹è¯•ç­–ç•¥)
    - [4.1 é›†æˆæµ‹è¯•](#41-é›†æˆæµ‹è¯•)
    - [4.2 ç¼–è¯‘å¤±è´¥æµ‹è¯•](#42-ç¼–è¯‘å¤±è´¥æµ‹è¯•)
    - [4.3 å¿«ç…§æµ‹è¯•](#43-å¿«ç…§æµ‹è¯•)
  - [5. å®æˆ˜æ¡ˆä¾‹](#5-å®æˆ˜æ¡ˆä¾‹)
    - [5.1 è°ƒè¯• Builder å®](#51-è°ƒè¯•-builder-å®)
    - [5.2 é”™è¯¯è¯Šæ–­](#52-é”™è¯¯è¯Šæ–­)
    - [5.3 æ€§èƒ½æµ‹è¯•](#53-æ€§èƒ½æµ‹è¯•)
  - [6. æ€»ç»“](#6-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å®è°ƒè¯•ä¸æµ‹è¯•æŒ‡å— (Macro Debugging and Testing Guide)**:

- **å®šä¹‰**: å®è°ƒè¯•å’Œæµ‹è¯•çš„å®è·µæŒ‡å—ï¼ŒåŒ…æ‹¬è°ƒè¯•å·¥å…·ã€æµ‹è¯•ç­–ç•¥å’Œé”™è¯¯å¤„ç†
- **ç±»å‹**: è°ƒè¯•å’Œæµ‹è¯•æŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: å®ç³»ç»Ÿã€è°ƒè¯•ã€æµ‹è¯•
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: å®è°ƒè¯•ã€å®æµ‹è¯•ã€é”™è¯¯å¤„ç†ã€æ€§èƒ½æµ‹è¯•

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **è°ƒè¯•å·¥å…·**: cargo expandã€println! è°ƒè¯•ã€IDE æ”¯æŒ
- **å®å±•å¼€**: æŸ¥çœ‹å±•å¼€ç»“æœã€éƒ¨åˆ†å±•å¼€
- **é”™è¯¯å¤„ç†**: ç¼–è¯‘é”™è¯¯ã€è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯
- **æµ‹è¯•ç­–ç•¥**: é›†æˆæµ‹è¯•ã€ç¼–è¯‘å¤±è´¥æµ‹è¯•ã€å¿«ç…§æµ‹è¯•

**æ€§èƒ½ç‰¹å¾**:

- **è°ƒè¯•æ•ˆç‡**: ä½¿ç”¨å·¥å…·æå‡è°ƒè¯•æ•ˆç‡
- **æµ‹è¯•è¦†ç›–**: å…¨é¢çš„æµ‹è¯•ç­–ç•¥
- **é€‚ç”¨åœºæ™¯**: å®å¼€å‘ã€å®ç»´æŠ¤ã€å®ä¼˜åŒ–

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- å®è°ƒè¯•ä¸æµ‹è¯•æŒ‡å— --[uses]--> å¤šç§è°ƒè¯•å’Œæµ‹è¯•å·¥å…·
- å®å¼€å‘ --[uses]--> å®è°ƒè¯•ä¸æµ‹è¯•

**ä¾èµ–å…³ç³»**:

- å®è°ƒè¯•ä¸æµ‹è¯• --[depends-on]--> è°ƒè¯•å·¥å…·
- å®è´¨é‡ä¿è¯ --[depends-on]--> å®è°ƒè¯•ä¸æµ‹è¯•

### æ€ç»´å¯¼å›¾

```text
å®è°ƒè¯•ä¸æµ‹è¯•æŒ‡å—
â”‚
â”œâ”€â”€ è°ƒè¯•å·¥å…·
â”‚   â”œâ”€â”€ cargo expand
â”‚   â””â”€â”€ println! è°ƒè¯•
â”œâ”€â”€ å®å±•å¼€
â”‚   â””â”€â”€ æŸ¥çœ‹å±•å¼€ç»“æœ
â”œâ”€â”€ é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ ç¼–è¯‘é”™è¯¯
â”‚   â””â”€â”€ è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯
â””â”€â”€ æµ‹è¯•ç­–ç•¥
    â”œâ”€â”€ é›†æˆæµ‹è¯•
    â””â”€â”€ ç¼–è¯‘å¤±è´¥æµ‹è¯•
```

---

## 1. è°ƒè¯•å·¥å…·

### 1.1 cargo expand

```bash
# å®‰è£…
cargo install cargo-expand

# æŸ¥çœ‹å®å±•å¼€
cargo expand

# å±•å¼€ç‰¹å®šæ¨¡å—
cargo expand module_name

# å±•å¼€ç‰¹å®šå‡½æ•°
cargo expand function_name
```

### 1.2 println! è°ƒè¯•

```rust
#[proc_macro]
pub fn debug_macro(input: TokenStream) -> TokenStream {
    // æ‰“å°è¾“å…¥
    eprintln!("Input: {:?}", input);

    let output = process(input);

    // æ‰“å°è¾“å‡º
    eprintln!("Output: {:?}", output);

    output
}
```

### 1.3 IDE æ”¯æŒ

- **rust-analyzer**: å†…è”æ˜¾ç¤ºå®å±•å¼€
- **IntelliJ RUST**: å®å±•å¼€å’Œè°ƒè¯•æ”¯æŒ

---

## 2. å®å±•å¼€

### 2.1 æŸ¥çœ‹å±•å¼€ç»“æœ

```rust
// åŸå§‹ä»£ç 
#[derive(Debug, Clone)]
struct User {
    name: String,
    age: u32,
}

// å±•å¼€å (cargo expand)
struct User {
    name: String,
    age: u32,
}

impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("User")
            .field("name", &self.name)
            .field("age", &self.age)
            .finish()
    }
}

impl std::clone::Clone for User {
    fn clone(&self) -> Self {
        User {
            name: self.name.clone(),
            age: self.age.clone(),
        }
    }
}
```

### 2.2 éƒ¨åˆ†å±•å¼€

```bash
# åªå±•å¼€ç‰¹å®šå®
cargo expand --ugly  # ä¿ç•™åŸå§‹æ ¼å¼

# å±•å¼€åˆ°æ–‡ä»¶
cargo expand > expanded.rs
```

---

## 3. é”™è¯¯å¤„ç†

### 3.1 ç¼–è¯‘é”™è¯¯

```rust
use proc_macro::TokenStream;
use syn::Error;

#[proc_macro_derive(MyTrait)]
pub fn derive_my_trait(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    // æ£€æŸ¥æ˜¯å¦ä¸ºç»“æ„ä½“
    match input.data {
        Data::Struct(_) => {},
        _ => {
            return Error::new_spanned(
                input,
                "MyTrait can only be derived for structs"
            ).to_compile_error().into();
        }
    }

    TokenStream::new()
}
```

### 3.2 è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯

```rust
#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let fields = match &input.data {
        Data::Struct(data) => {
            match &data.fields {
                Fields::Named(fields) => &fields.named,
                Fields::Unnamed(_) => {
                    return Error::new_spanned(
                        data,
                        "Builder derive does not support tuple structs.\n\
                         Use a struct with named fields instead:\n\
                         struct MyStruct {{ field: Type }}"
                    ).to_compile_error().into();
                }
                Fields::Unit => {
                    return Error::new_spanned(
                        data,
                        "Builder derive does not support unit structs"
                    ).to_compile_error().into();
                }
            }
        }
        _ => {
            return Error::new_spanned(
                input,
                "Builder can only be derived for structs"
            ).to_compile_error().into();
        }
    };

    TokenStream::new()
}
```

---

## 4. æµ‹è¯•ç­–ç•¥

### 4.1 é›†æˆæµ‹è¯•

```rust
// tests/integration_test.rs
use my_macros::*;

#[test]
fn test_derive_builder() {
    #[derive(Builder)]
    struct User {
        name: String,
        age: u32,
    }

    let user = User::builder()
        .name("Alice".to_string())
        .age(30)
        .build()
        .unwrap();

    assert_eq!(user.name, "Alice");
    assert_eq!(user.age, 30);
}
```

### 4.2 ç¼–è¯‘å¤±è´¥æµ‹è¯•

```rust
// ä½¿ç”¨ trybuild
#[test]
fn test_compile_fail() {
    let t = trybuild::TestCases::new();
    t.compile_fail("tests/ui/fail_*.rs");
}

// tests/ui/fail_unsupported_type.rs
use my_macros::Builder;

#[derive(Builder)]
enum MyEnum {  // åº”è¯¥ç¼–è¯‘å¤±è´¥
    Variant,
}

fn main() {}
```

### 4.3 å¿«ç…§æµ‹è¯•

```rust
#[test]
fn test_expansion() {
    let input = quote! {
        #[derive(Builder)]
        struct User {
            name: String,
        }
    };

    let expected = quote! {
        // é¢„æœŸçš„å±•å¼€ç»“æœ
    };

    assert_eq!(
        derive_builder(input.into()).to_string(),
        expected.to_string()
    );
}
```

---

## 5. å®æˆ˜æ¡ˆä¾‹

### 5.1 è°ƒè¯• Builder å®

```rust
#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    // è°ƒè¯•ï¼šæ‰“å°ç»“æ„ä½“åç§°
    eprintln!("Processing struct: {}", input.ident);

    let fields = match &input.data {
        Data::Struct(data) => {
            match &data.fields {
                Fields::Named(fields) => {
                    // è°ƒè¯•ï¼šæ‰“å°å­—æ®µæ•°é‡
                    eprintln!("Found {} fields", fields.named.len());
                    &fields.named
                }
                _ => panic!("Only named fields supported"),
            }
        }
        _ => panic!("Only structs supported"),
    };

    // è°ƒè¯•ï¼šæ‰“å°æ¯ä¸ªå­—æ®µ
    for field in fields {
        eprintln!("Field: {:?}", field.ident);
    }

    TokenStream::new()
}
```

### 5.2 é”™è¯¯è¯Šæ–­

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as AttributeArgs);
    let input = parse_macro_input!(item as ItemFn);

    // éªŒè¯å‚æ•°æ•°é‡
    if args.is_empty() {
        return Error::new_spanned(
            &input.sig.ident,
            "route attribute requires at least one argument: method and path\n\
             Example: #[route(\"GET\", \"/users\")]"
        ).to_compile_error().into();
    }

    if args.len() > 2 {
        return Error::new_spanned(
            &input.sig.ident,
            "route attribute takes at most 2 arguments: method and path"
        ).to_compile_error().into();
    }

    TokenStream::new()
}
```

### 5.3 æ€§èƒ½æµ‹è¯•

```rust
#[test]
fn bench_macro_expansion() {
    use std::time::Instant;

    let input = quote! {
        #[derive(Builder)]
        struct LargeStruct {
            field1: String,
            field2: i32,
            // ... 100 ä¸ªå­—æ®µ
        }
    };

    let start = Instant::now();
    let _ = derive_builder(input.into());
    let duration = start.elapsed();

    assert!(duration.as_millis() < 100, "Macro expansion took too long");
}
```

---

## 6. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **cargo expand**: æŸ¥çœ‹å®å±•å¼€ç»“æœ
2. **é”™è¯¯å¤„ç†**: ä½¿ç”¨ `syn::Error` æä¾›æ¸…æ™°é”™è¯¯
3. **æµ‹è¯•**: é›†æˆæµ‹è¯• + ç¼–è¯‘å¤±è´¥æµ‹è¯•
4. **è°ƒè¯•**: `eprintln!` + IDE æ”¯æŒ
5. **æ€§èƒ½**: é¿å…ç”Ÿæˆè¿‡å¤šä»£ç 

### æœ€ä½³å®è·µ

| åœºæ™¯     | æ¨èåšæ³•                     |
| -------- | ---------------------------- |
| **è°ƒè¯•** | ä½¿ç”¨ `cargo expand`          |
| **é”™è¯¯** | æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œå»ºè®®     |
| **æµ‹è¯•** | ä½¿ç”¨ `trybuild` æµ‹è¯•ç¼–è¯‘å¤±è´¥ |
| **æ€§èƒ½** | é¿å…é€’å½’ç”Ÿæˆä»£ç              |
| **æ–‡æ¡£** | æ·»åŠ  `#[doc]` å±æ€§           |

**å¸¸è§é™·é˜±**:

- âŒ é”™è¯¯ä¿¡æ¯ä¸æ¸…æ™°
- âŒ ç¼ºå°‘æµ‹è¯•
- âŒ ç”Ÿæˆçš„ä»£ç ä¸ç¬¦åˆé¢„æœŸ
- âŒ æ€§èƒ½é—®é¢˜
- âœ… æä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
- âœ… ç¼–å†™å®Œæ•´çš„æµ‹è¯•
- âœ… ä½¿ç”¨ `cargo expand` éªŒè¯
- âœ… ç›‘æ§ç¼–è¯‘æ—¶é—´

---

## ğŸ“š å‚è€ƒèµ„æº

**å·¥å…·**:

- `cargo expand` - å®å±•å¼€
- `trybuild` - ç¼–è¯‘å¤±è´¥æµ‹è¯•
- `rust-analyzer` - IDE æ”¯æŒ

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: å£°æ˜å®å®è·µæŒ‡å—](./01_å£°æ˜å®å®è·µæŒ‡å—.md)
- [Tier 2: Derive å®å¼€å‘æŒ‡å—](./02_Deriveå®å¼€å‘æŒ‡å—.md)
- [Tier 3: ç†è®ºå‚è€ƒ](../tier_03_references/)

---

**æ–‡æ¡£ç»´æŠ¤**: C11 Macro System Team
**æœ€åå®¡æ ¸**: 2025-10-23
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
