# æ§åˆ¶æµä¸å‡½æ•° - æ¦‚å¿µæœ¬ä½“å®šä¹‰

> **æ–‡æ¡£ç±»å‹**: ğŸ“š çŸ¥è¯†æœ¬ä½“ | ğŸ”¬ å½¢å¼åŒ–å®šä¹‰  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-19  
> **Rust ç‰ˆæœ¬**: 1.90+

---

## ç›®å½•

- [æ§åˆ¶æµä¸å‡½æ•° - æ¦‚å¿µæœ¬ä½“å®šä¹‰](#æ§åˆ¶æµä¸å‡½æ•°---æ¦‚å¿µæœ¬ä½“å®šä¹‰)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
    - [çŸ¥è¯†æœ¬ä½“çš„ä½œç”¨](#çŸ¥è¯†æœ¬ä½“çš„ä½œç”¨)
  - [ğŸ¯ æœ¬ä½“ç»“æ„](#-æœ¬ä½“ç»“æ„)
  - [1ï¸âƒ£ æ ¸å¿ƒæŠ½è±¡å±‚æ¦‚å¿µ](#1ï¸âƒ£-æ ¸å¿ƒæŠ½è±¡å±‚æ¦‚å¿µ)
    - [1.1 è¡¨è¾¾å¼ (Expression)](#11-è¡¨è¾¾å¼-expression)
    - [1.2 è¯­å¥ (Statement)](#12-è¯­å¥-statement)
    - [1.3 å—è¡¨è¾¾å¼ (Block Expression)](#13-å—è¡¨è¾¾å¼-block-expression)
  - [2ï¸âƒ£ æ§åˆ¶æµå±‚æ¦‚å¿µ](#2ï¸âƒ£-æ§åˆ¶æµå±‚æ¦‚å¿µ)
    - [2.1 æ¡ä»¶è¡¨è¾¾å¼ (Conditional Expression)](#21-æ¡ä»¶è¡¨è¾¾å¼-conditional-expression)
      - [2.1.1 ifè¡¨è¾¾å¼](#211-ifè¡¨è¾¾å¼)
      - [2.1.2 matchè¡¨è¾¾å¼](#212-matchè¡¨è¾¾å¼)
      - [2.1.3 if letè¡¨è¾¾å¼](#213-if-letè¡¨è¾¾å¼)
      - [2.1.4 let-elseæ¨¡å¼](#214-let-elseæ¨¡å¼)
    - [2.2 å¾ªç¯æ§åˆ¶ (Loop Control)](#22-å¾ªç¯æ§åˆ¶-loop-control)
      - [2.2.1 loopå¾ªç¯](#221-loopå¾ªç¯)
      - [2.2.2 whileå¾ªç¯](#222-whileå¾ªç¯)
      - [2.2.3 while letå¾ªç¯](#223-while-letå¾ªç¯)
      - [2.2.4 forå¾ªç¯](#224-forå¾ªç¯)
    - [2.3 è·³è½¬æ§åˆ¶ (Jump Control)](#23-è·³è½¬æ§åˆ¶-jump-control)
      - [2.3.1 break](#231-break)
      - [2.3.2 continue](#232-continue)
      - [2.3.3 return](#233-return)
  - [3ï¸âƒ£ å‡½æ•°å±‚æ¦‚å¿µ](#3ï¸âƒ£-å‡½æ•°å±‚æ¦‚å¿µ)
    - [3.1 å‡½æ•°å®šä¹‰ (Function Definition)](#31-å‡½æ•°å®šä¹‰-function-definition)
    - [3.2 å‡½æ•°ç±»å‹](#32-å‡½æ•°ç±»å‹)
      - [3.2.1 æ™®é€šå‡½æ•° (Free Function)](#321-æ™®é€šå‡½æ•°-free-function)
      - [3.2.2 å…³è”å‡½æ•° (Associated Function)](#322-å…³è”å‡½æ•°-associated-function)
      - [3.2.3 æ–¹æ³• (Method)](#323-æ–¹æ³•-method)
    - [3.3 å‚æ•°ä¼ é€’ (Parameter Passing)](#33-å‚æ•°ä¼ é€’-parameter-passing)
    - [3.4 è¿”å›ç±»å‹ (Return Type)](#34-è¿”å›ç±»å‹-return-type)
  - [4ï¸âƒ£ æ¨¡å¼å±‚æ¦‚å¿µ](#4ï¸âƒ£-æ¨¡å¼å±‚æ¦‚å¿µ)
    - [4.1 æ¨¡å¼ç±»å‹ (Pattern Types)](#41-æ¨¡å¼ç±»å‹-pattern-types)
      - [4.1.1 æ¨¡å¼åˆ†ç±»](#411-æ¨¡å¼åˆ†ç±»)
      - [4.1.2 å¯åé©³æ€§ (Refutability)](#412-å¯åé©³æ€§-refutability)
    - [4.2 æ¨¡å¼ç‰¹æ€§](#42-æ¨¡å¼ç‰¹æ€§)
      - [4.2.1 ç»‘å®šæ¨¡å¼ (@-binding)](#421-ç»‘å®šæ¨¡å¼--binding)
      - [4.2.2 å¼•ç”¨æ¨¡å¼](#422-å¼•ç”¨æ¨¡å¼)
      - [4.2.3 å®ˆå«æ¡ä»¶ (Pattern Guards)](#423-å®ˆå«æ¡ä»¶-pattern-guards)
    - [4.3 ç©·å°½æ€§æ£€æŸ¥ (Exhaustiveness Checking)](#43-ç©·å°½æ€§æ£€æŸ¥-exhaustiveness-checking)
  - [5ï¸âƒ£ ç»„åˆå±‚æ¦‚å¿µ](#5ï¸âƒ£-ç»„åˆå±‚æ¦‚å¿µ)
    - [5.1 é—­åŒ…ç³»ç»Ÿ (Closure System)](#51-é—­åŒ…ç³»ç»Ÿ-closure-system)
      - [5.1.1 æ•è·æ¨¡å¼](#511-æ•è·æ¨¡å¼)
      - [5.1.2 Fn Traits](#512-fn-traits)
    - [5.2 è¿­ä»£å™¨ç³»ç»Ÿ (Iterator System)](#52-è¿­ä»£å™¨ç³»ç»Ÿ-iterator-system)
      - [5.2.1 è¿­ä»£å™¨åˆ†ç±»](#521-è¿­ä»£å™¨åˆ†ç±»)
      - [5.2.2 æ‰€æœ‰æƒæ¨¡å¼](#522-æ‰€æœ‰æƒæ¨¡å¼)
    - [5.3 é”™è¯¯å¤„ç†ç³»ç»Ÿ (Error Handling System)](#53-é”™è¯¯å¤„ç†ç³»ç»Ÿ-error-handling-system)
      - [5.3.1 Resultç±»å‹](#531-resultç±»å‹)
      - [5.3.2 Optionç±»å‹](#532-optionç±»å‹)
      - [5.3.3 ?è¿ç®—ç¬¦](#533-è¿ç®—ç¬¦)
  - [6ï¸âƒ£ ç±»å‹ç³»ç»Ÿé›†æˆ](#6ï¸âƒ£-ç±»å‹ç³»ç»Ÿé›†æˆ)
    - [6.1 Neverç±»å‹ (!)](#61-neverç±»å‹-)
    - [6.2 ç±»å‹æ¨æ–­](#62-ç±»å‹æ¨æ–­)
    - [6.3 ç±»å‹ç»Ÿä¸€](#63-ç±»å‹ç»Ÿä¸€)
  - [ğŸ”— æ¦‚å¿µå…³ç³»æ€»ç»“](#-æ¦‚å¿µå…³ç³»æ€»ç»“)
    - [æ ¸å¿ƒä¾èµ–å…³ç³»](#æ ¸å¿ƒä¾èµ–å…³ç³»)
    - [ç»„åˆå…³ç³»](#ç»„åˆå…³ç³»)
  - [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› Rust æ§åˆ¶æµä¸å‡½æ•°ç³»ç»Ÿçš„**å½¢å¼åŒ–æ¦‚å¿µå®šä¹‰**ï¼Œæ„å»ºé¢†åŸŸçŸ¥è¯†çš„æœ¬ä½“ç»“æ„ã€‚

### çŸ¥è¯†æœ¬ä½“çš„ä½œç”¨

1. **ç»Ÿä¸€æœ¯è¯­**: æä¾›æ ‡å‡†ã€ç²¾ç¡®çš„æ¦‚å¿µå®šä¹‰
2. **å…³ç³»åŸºç¡€**: ä¸ºå…³ç³»ç½‘ç»œæä¾›èŠ‚ç‚¹å®šä¹‰
3. **æ¨ç†åŸºç¡€**: ä¸ºè‡ªåŠ¨æ¨ç†æä¾›å½¢å¼åŒ–è§„åˆ™
4. **çŸ¥è¯†å…±äº«**: ä¿ƒè¿›å›¢é˜Ÿé—´çš„çŸ¥è¯†äº¤æµ

---

## ğŸ¯ æœ¬ä½“ç»“æ„

```text
æ§åˆ¶æµä¸å‡½æ•°æœ¬ä½“
â”œâ”€â”€ æ ¸å¿ƒæŠ½è±¡å±‚
â”‚   â”œâ”€â”€ è¡¨è¾¾å¼ç³»ç»Ÿ
â”‚   â”œâ”€â”€ ç±»å‹ç³»ç»Ÿ
â”‚   â””â”€â”€ æ‰§è¡Œè¯­ä¹‰
â”œâ”€â”€ æ§åˆ¶æµå±‚
â”‚   â”œâ”€â”€ æ¡ä»¶æ§åˆ¶
â”‚   â”œâ”€â”€ å¾ªç¯æ§åˆ¶
â”‚   â””â”€â”€ è·³è½¬æ§åˆ¶
â”œâ”€â”€ å‡½æ•°å±‚
â”‚   â”œâ”€â”€ å‡½æ•°å®šä¹‰
â”‚   â”œâ”€â”€ å‚æ•°ä¼ é€’
â”‚   â””â”€â”€ è¿”å›æœºåˆ¶
â”œâ”€â”€ æ¨¡å¼å±‚
â”‚   â”œâ”€â”€ æ¨¡å¼ç±»å‹
â”‚   â”œâ”€â”€ åŒ¹é…è¯­ä¹‰
â”‚   â””â”€â”€ è§£æ„ç»‘å®š
â””â”€â”€ ç»„åˆå±‚
    â”œâ”€â”€ é—­åŒ…ç³»ç»Ÿ
    â”œâ”€â”€ è¿­ä»£å™¨ç³»ç»Ÿ
    â””â”€â”€ é”™è¯¯å¤„ç†ç³»ç»Ÿ
```

---

## 1ï¸âƒ£ æ ¸å¿ƒæŠ½è±¡å±‚æ¦‚å¿µ

### 1.1 è¡¨è¾¾å¼ (Expression)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Expression := Value | Operation | ControlFlow
where:
  - Value: å­—é¢é‡æˆ–å˜é‡
  - Operation: å‡½æ•°è°ƒç”¨æˆ–è¿ç®—ç¬¦
  - ControlFlow: if | match | loop | block
```

**æœ¬ä½“å±æ€§**:

- **è¯­ä¹‰ç±»å‹** (Semantic Type): æ±‚å€¼å‹ (Evaluates to value)
- **å‰¯ä½œç”¨** (Side Effects): å¯èƒ½æœ‰
- **è¿”å›å€¼** (Return Value): ç±»å‹T
- **ç»„åˆæ€§** (Composability): é«˜

**å®ä¾‹**:

```rust
// è¡¨è¾¾å¼æ±‚å€¼
let x = 5 + 3;                    // ç®—æœ¯è¡¨è¾¾å¼
let y = if cond { 1 } else { 2 }; // æ§åˆ¶æµè¡¨è¾¾å¼
let z = { let a = 1; a + 2 };     // å—è¡¨è¾¾å¼
```

**å…¬ç†**:

1. æ‰€æœ‰è¡¨è¾¾å¼éƒ½æœ‰ç±»å‹
2. è¡¨è¾¾å¼å¯ä»¥åµŒå¥—ç»„åˆ
3. æœ€åçš„è¡¨è¾¾å¼å†³å®šå—çš„è¿”å›å€¼

### 1.2 è¯­å¥ (Statement)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Statement := LetBinding | Expression; | Item
where:
  - LetBinding: let pattern = expr
  - Expression;: è¡¨è¾¾å¼ + åˆ†å·
  - Item: å‡½æ•°/ç»“æ„ä½“/implå®šä¹‰
```

**æœ¬ä½“å±æ€§**:

- **è¯­ä¹‰ç±»å‹**: æ‰§è¡Œå‹ (Executes for effect)
- **å‰¯ä½œç”¨**: é€šå¸¸æœ‰
- **è¿”å›å€¼**: () (å•å…ƒç±»å‹)
- **ç»„åˆæ€§**: ä½

**åŒºåˆ«è¡¨è¾¾å¼**:

```rust
// è¯­å¥
let x = 5;           // letè¯­å¥
println!("Hello");   // è¡¨è¾¾å¼è¯­å¥ï¼ˆæœ‰åˆ†å·ï¼‰

// è¡¨è¾¾å¼
x + 1                // æ— åˆ†å·ï¼Œæœ‰è¿”å›å€¼
if x > 0 { x }       // æ§åˆ¶æµè¡¨è¾¾å¼
```

### 1.3 å—è¡¨è¾¾å¼ (Block Expression)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Block := { Statement* Expression? }
return_value := 
  | Expression  (if present)
  | ()          (if absent or last is statement)
```

**æœ¬ä½“å±æ€§**:

- **ä½œç”¨åŸŸ**: åˆ›å»ºæ–°ä½œç”¨åŸŸ
- **è¿”å›å€¼**: æœ€åè¡¨è¾¾å¼çš„å€¼
- **ç”Ÿå‘½å‘¨æœŸ**: å—å†…å˜é‡åœ¨å—ç»“æŸæ—¶é”€æ¯

**ç¤ºä¾‹**:

```rust
let result = {
    let temp = expensive_computation();
    temp * 2  // è¿”å›å€¼ï¼ˆæ— åˆ†å·ï¼‰
};
```

---

## 2ï¸âƒ£ æ§åˆ¶æµå±‚æ¦‚å¿µ

### 2.1 æ¡ä»¶è¡¨è¾¾å¼ (Conditional Expression)

#### 2.1.1 ifè¡¨è¾¾å¼

**å½¢å¼åŒ–å®šä¹‰**:

```text
IfExpr := if Condition Block (else Block)?
where:
  Condition: boolç±»å‹è¡¨è¾¾å¼
  æ‰€æœ‰åˆ†æ”¯ç±»å‹å¿…é¡»ç»Ÿä¸€
```

**æœ¬ä½“å±æ€§**:

- **æ¡ä»¶ç±»å‹**: å¸ƒå°”è¡¨è¾¾å¼
- **ç©·å°½æ€§**: å¯é€‰elseåˆ†æ”¯
- **è¿”å›ç±»å‹**: æ‰€æœ‰åˆ†æ”¯çš„ç»Ÿä¸€ç±»å‹
- **ç¼–è¯‘æ—¶æ£€æŸ¥**: ç±»å‹ç»Ÿä¸€æ€§

**ç±»å‹è§„åˆ™**:

```text
Î“ âŠ¢ cond: bool
Î“ âŠ¢ then_block: T
Î“ âŠ¢ else_block: T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ if cond then_block else else_block: T
```

**Rust 1.90 å¢å¼º**:

- æ›´å¥½çš„ç±»å‹æ¨æ–­
- æ”¹è¿›çš„é”™è¯¯æ¶ˆæ¯

#### 2.1.2 matchè¡¨è¾¾å¼

**å½¢å¼åŒ–å®šä¹‰**:

```text
MatchExpr := match Scrutinee { Pattern => Expression,+ }
where:
  Scrutinee: è¢«åŒ¹é…çš„å€¼
  Pattern: æ¨¡å¼ï¼ˆå¿…é¡»ç©·å°½ï¼‰
  Expression: åˆ†æ”¯è¡¨è¾¾å¼
```

**æœ¬ä½“å±æ€§**:

- **ç©·å°½æ€§**: ç¼–è¯‘æ—¶å¼ºåˆ¶æ£€æŸ¥
- **æ¨¡å¼ç±»å‹**: å­—é¢é‡ã€å˜é‡ã€ç»“æ„ã€æšä¸¾ã€é€šé…ç¬¦
- **å®ˆå«æ¡ä»¶**: å¯é€‰çš„ifæ¡ä»¶
- **æ€§èƒ½**: ä¼˜åŒ–ä¸ºè·³è½¬è¡¨æˆ–å†³ç­–æ ‘

**ç©·å°½æ€§è§„åˆ™**:

```text
match scrutinee {
    Pattern_1 => expr_1,
    ...
    Pattern_n => expr_n,
}

Required: Pattern_1 | ... | Pattern_n = Universal Set
```

**ç¤ºä¾‹**:

```rust
match value {
    Some(x) if x > 0 => println!("æ­£æ•°"),  // å¸¦å®ˆå«
    Some(x) => println!("éæ­£æ•°"),
    None => println!("æ— å€¼"),
}  // âœ… ç©·å°½
```

#### 2.1.3 if letè¡¨è¾¾å¼

**å½¢å¼åŒ–å®šä¹‰**:

```text
IfLetExpr := if let Pattern = Scrutinee Block (else Block)?
where:
  Pattern: å•ä¸ªæ¨¡å¼
  Scrutinee: è¢«åŒ¹é…çš„å€¼
```

**æœ¬ä½“å±æ€§**:

- **æ¨¡å¼æ•°é‡**: å•ä¸ªæ¨¡å¼
- **ç©·å°½æ€§**: ä¸è¦æ±‚
- **è¯­æ³•ç³–**: matchçš„ç®€åŒ–å½¢å¼

**ç­‰ä»·è½¬æ¢**:

```rust
// if let
if let Some(x) = option {
    use(x);
}

// ç­‰ä»·äº
match option {
    Some(x) => use(x),
    _ => {}
}
```

**Rust 1.90: if-let é“¾**:

```rust
if let Some(x) = opt1 
   && let Ok(y) = res2 
   && x > y {
    // é“¾å¼åŒ¹é…
}
```

#### 2.1.4 let-elseæ¨¡å¼

**å½¢å¼åŒ–å®šä¹‰**:

```text
LetElseStmt := let Pattern = Scrutinee else Block;
where:
  Pattern: å¯åé©³æ¨¡å¼
  Block: å‘æ•£å— (å¿…é¡»return/break/panic)
```

**æœ¬ä½“å±æ€§**:

- **Rustç‰ˆæœ¬**: 1.89+ (1.90ç¨³å®š)
- **ç”¨é€”**: æ—©æœŸè¿”å›æ¨¡å¼
- **å‘æ•£è¦æ±‚**: elseå—å¿…é¡»å‘æ•£

**ç¤ºä¾‹**:

```rust
fn process(opt: Option<i32>) -> Result<i32, &'static str> {
    let Some(value) = opt else {
        return Err("æ— å€¼");  // å¿…é¡»å‘æ•£
    };
    Ok(value * 2)
}
```

### 2.2 å¾ªç¯æ§åˆ¶ (Loop Control)

#### 2.2.1 loopå¾ªç¯

**å½¢å¼åŒ–å®šä¹‰**:

```text
LoopExpr := ('label:)? loop Block
where:
  'label: å¯é€‰çš„ç”Ÿå‘½å‘¨æœŸæ ‡ç­¾
  Block: å¾ªç¯ä½“
  ç»ˆæ­¢: æ˜¾å¼break
```

**æœ¬ä½“å±æ€§**:

- **ç»ˆæ­¢æ¡ä»¶**: æ˜¾å¼break
- **è¿”å›å€¼**: breakè¡¨è¾¾å¼çš„å€¼
- **ç±»å‹**: breakå€¼çš„ç±»å‹
- **æ ‡ç­¾**: æ”¯æŒå¤šå±‚å¾ªç¯æ§åˆ¶

**break with value** (Rust 1.0+):

```rust
let result = loop {
    if condition {
        break compute_value();  // è¿”å›å€¼
    }
};
```

**æ ‡ç­¾å—** (Rust 1.90å¢å¼º):

```rust
'outer: loop {
    'inner: loop {
        break 'outer;  // è·³å‡ºå¤–å±‚å¾ªç¯
    }
}
```

#### 2.2.2 whileå¾ªç¯

**å½¢å¼åŒ–å®šä¹‰**:

```text
WhileExpr := while Condition Block
where:
  Condition: boolè¡¨è¾¾å¼
  Block: å¾ªç¯ä½“
```

**æœ¬ä½“å±æ€§**:

- **ç»ˆæ­¢æ¡ä»¶**: æ¡ä»¶ä¸ºfalse
- **è¿”å›å€¼**: ()
- **ç±»å‹**: å•å…ƒç±»å‹

#### 2.2.3 while letå¾ªç¯

**å½¢å¼åŒ–å®šä¹‰**:

```text
WhileLetExpr := while let Pattern = Scrutinee Block
where:
  Pattern: æ¨¡å¼
  Scrutinee: è¢«åŒ¹é…çš„è¡¨è¾¾å¼
```

**æœ¬ä½“å±æ€§**:

- **ç»ˆæ­¢æ¡ä»¶**: æ¨¡å¼åŒ¹é…å¤±è´¥
- **å…¸å‹ç”¨é€”**: éå†ç›´åˆ°None

**Rust 1.90: while-leté“¾**:

```rust
while let Some(x) = iter.next() 
      && x > 0 {
    // é“¾å¼æ¡ä»¶
}
```

#### 2.2.4 forå¾ªç¯

**å½¢å¼åŒ–å®šä¹‰**:

```text
ForExpr := for Pattern in IntoIterator Block
where:
  Pattern: æ¨¡å¼
  IntoIterator: impl IntoIterator
  Block: å¾ªç¯ä½“
```

**æœ¬ä½“å±æ€§**:

- **ç»ˆæ­¢æ¡ä»¶**: è¿­ä»£å™¨è€—å°½
- **æ‰€æœ‰æƒ**: å–å†³äºinto_iter/iter/iter_mut
- **è¿”å›å€¼**: ()

**æ‰€æœ‰æƒæ¨¡å¼**:

```rust
for item in vec        // into_iter: ç§»åŠ¨
for item in &vec       // iter: ä¸å¯å˜å€Ÿç”¨
for item in &mut vec   // iter_mut: å¯å˜å€Ÿç”¨
```

### 2.3 è·³è½¬æ§åˆ¶ (Jump Control)

#### 2.3.1 break

**å½¢å¼åŒ–å®šä¹‰**:

```text
BreakExpr := break ('label)? Expression?
where:
  'label: å¯é€‰æ ‡ç­¾
  Expression: å¯é€‰è¿”å›å€¼
```

**æœ¬ä½“å±æ€§**:

- **ä½œç”¨**: é€€å‡ºå¾ªç¯
- **è¿”å›å€¼**: å¯æºå¸¦å€¼
- **ç›®æ ‡**: æœ€è¿‘çš„å¾ªç¯æˆ–æ ‡ç­¾å—

#### 2.3.2 continue

**å½¢å¼åŒ–å®šä¹‰**:

```text
ContinueExpr := continue ('label)?
```

**æœ¬ä½“å±æ€§**:

- **ä½œç”¨**: è·³åˆ°ä¸‹æ¬¡è¿­ä»£
- **è¿”å›å€¼**: ! (neverç±»å‹)

#### 2.3.3 return

**å½¢å¼åŒ–å®šä¹‰**:

```text
ReturnExpr := return Expression?
```

**æœ¬ä½“å±æ€§**:

- **ä½œç”¨**: ä»å‡½æ•°è¿”å›
- **è¿”å›å€¼**: ! (neverç±»å‹)
- **æå‰é€€å‡º**: å¯åœ¨ä»»ä½•ä½ç½®

---

## 3ï¸âƒ£ å‡½æ•°å±‚æ¦‚å¿µ

### 3.1 å‡½æ•°å®šä¹‰ (Function Definition)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Function := fn name<Generics>(Parameters) -> ReturnType
            where Bounds
            { Body }
where:
  Generics: ç±»å‹å‚æ•°
  Parameters: (pattern: Type),*
  ReturnType: è¿”å›ç±»å‹ï¼ˆé»˜è®¤()ï¼‰
  Bounds: whereå­å¥çº¦æŸ
  Body: å‡½æ•°ä½“è¡¨è¾¾å¼
```

**æœ¬ä½“å±æ€§**:

- **å‘½å**: æ ‡è¯†ç¬¦
- **å‚æ•°**: å‚æ•°åˆ—è¡¨
- **è¿”å›ç±»å‹**: æ˜¾å¼æˆ–æ¨æ–­
- **æ³›å‹**: å¯é€‰ç±»å‹å‚æ•°
- **å¯è§æ€§**: pub/pub(crate)/private

### 3.2 å‡½æ•°ç±»å‹

#### 3.2.1 æ™®é€šå‡½æ•° (Free Function)

**å®šä¹‰**: ç‹¬ç«‹çš„å‡½æ•°ï¼Œä¸å±äºä»»ä½•ç±»å‹

**ç¤ºä¾‹**:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

#### 3.2.2 å…³è”å‡½æ•° (Associated Function)

**å®šä¹‰**: ä¸ç±»å‹å…³è”çš„å‡½æ•°ï¼Œæ— selfå‚æ•°

**ç¤ºä¾‹**:

```rust
impl MyType {
    fn new() -> Self { ... }  // æ„é€ å‡½æ•°
}
```

#### 3.2.3 æ–¹æ³• (Method)

**å®šä¹‰**: ä¸ç±»å‹å…³è”çš„å‡½æ•°ï¼Œæœ‰selfå‚æ•°

**selfæ¨¡å¼**:

```rust
impl MyType {
    fn by_value(self) { ... }      // ç§»åŠ¨æ‰€æœ‰æƒ
    fn by_ref(&self) { ... }       // ä¸å¯å˜å€Ÿç”¨
    fn by_mut_ref(&mut self) { ... }  // å¯å˜å€Ÿç”¨
}
```

### 3.3 å‚æ•°ä¼ é€’ (Parameter Passing)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Parameter := 
  | T               // æŒ‰å€¼ä¼ é€’
  | &T              // ä¸å¯å˜å¼•ç”¨
  | &mut T          // å¯å˜å¼•ç”¨
  | impl Trait      // impl Traitè¯­æ³•
```

**æœ¬ä½“å±æ€§**:

| æ¨¡å¼ | æ‰€æœ‰æƒ | å¯å˜æ€§ | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|------|-------|-------|------|---------|
| T | è½¬ç§» | å–å†³äºç»‘å®š | å¯èƒ½å¤åˆ¶ | æ¶ˆè´¹å€¼ |
| &T | å€Ÿç”¨ | ä¸å¯å˜ | é›¶æˆæœ¬ | åªè¯»è®¿é—® |
| &mut T | å€Ÿç”¨ | å¯å˜ | é›¶æˆæœ¬ | ä¿®æ”¹æ•°æ® |

### 3.4 è¿”å›ç±»å‹ (Return Type)

**å½¢å¼åŒ–å®šä¹‰**:

```text
ReturnType := 
  | T                    // å…·ä½“ç±»å‹
  | impl Trait          // impl Trait
  | -> !                // Neverç±»å‹
  | (çœç•¥)              // é»˜è®¤()
```

**impl Trait** (Rust 1.26+):

```rust
fn make_iter() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}
```

**Neverç±»å‹** (Rust 1.90):

```rust
fn diverges() -> ! {
    panic!("æ°¸è¿œä¸è¿”å›");
}
```

---

## 4ï¸âƒ£ æ¨¡å¼å±‚æ¦‚å¿µ

### 4.1 æ¨¡å¼ç±»å‹ (Pattern Types)

#### 4.1.1 æ¨¡å¼åˆ†ç±»

**å½¢å¼åŒ–å®šä¹‰**:

```text
Pattern := 
  | Literal           // å­—é¢é‡: 1, "str"
  | Variable          // å˜é‡: x, mut y
  | Wildcard          // é€šé…ç¬¦: _
  | Tuple             // å…ƒç»„: (a, b, c)
  | Struct            // ç»“æ„: Point { x, y }
  | Enum              // æšä¸¾: Some(x), None
  | Reference         // å¼•ç”¨: &x, ref x
  | Range             // èŒƒå›´: 1..=10
```

#### 4.1.2 å¯åé©³æ€§ (Refutability)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Irrefutable Pattern: æ€»æ˜¯åŒ¹é…æˆåŠŸ
  - å˜é‡æ¨¡å¼: x
  - é€šé…ç¬¦: _
  - å…ƒç»„æ¨¡å¼ï¼ˆæ‰€æœ‰å­æ¨¡å¼ä¸å¯åé©³ï¼‰

Refutable Pattern: å¯èƒ½åŒ¹é…å¤±è´¥
  - å­—é¢é‡: 42
  - æšä¸¾å˜ä½“: Some(x)
  - èŒƒå›´: 1..=10
```

**ä½¿ç”¨è§„åˆ™**:

```rust
// letéœ€è¦ä¸å¯åé©³æ¨¡å¼
let x = 5;           // âœ…
let Some(x) = opt;   // âŒ å¯åé©³

// if let/matchå…è®¸å¯åé©³æ¨¡å¼
if let Some(x) = opt { ... }  // âœ…
match opt {
    Some(x) => ...,
    None => ...,
}  // âœ…
```

### 4.2 æ¨¡å¼ç‰¹æ€§

#### 4.2.1 ç»‘å®šæ¨¡å¼ (@-binding)

**å½¢å¼åŒ–å®šä¹‰**:

```text
@-Pattern := identifier @ Pattern
```

**ç”¨é€”**: åŒæ—¶åŒ¹é…å’Œç»‘å®š

**ç¤ºä¾‹**:

```rust
match value {
    x @ 1..=5 => println!("1-5èŒƒå›´: {}", x),
    x @ 6..=10 => println!("6-10èŒƒå›´: {}", x),
    _ => {}
}
```

#### 4.2.2 å¼•ç”¨æ¨¡å¼

**ä¸¤ç§å½¢å¼**:

```rust
// 1. &æ¨¡å¼ - åŒ¹é…å¼•ç”¨
match &value {
    &Some(x) => use(x),
    &None => {}
}

// 2. refå…³é”®å­— - åˆ›å»ºå¼•ç”¨
match value {
    Some(ref x) => use(x),  // xæ˜¯&T
    None => {}
}
```

#### 4.2.3 å®ˆå«æ¡ä»¶ (Pattern Guards)

**å½¢å¼åŒ–å®šä¹‰**:

```text
GuardedPattern := Pattern if Condition
where Condition: boolè¡¨è¾¾å¼
```

**ç¤ºä¾‹**:

```rust
match value {
    Some(x) if x > 0 => println!("æ­£æ•°"),
    Some(x) if x < 0 => println!("è´Ÿæ•°"),
    Some(0) => println!("é›¶"),
    None => println!("æ— å€¼"),
}
```

### 4.3 ç©·å°½æ€§æ£€æŸ¥ (Exhaustiveness Checking)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Exhaustiveness := âˆ€v âˆˆ T, âˆƒi âˆˆ {1..n}, Pattern_i matches v
```

**æ£€æŸ¥ç®—æ³•**: åŸºäºå†³ç­–æ ‘çš„ç¬¦å·æ‰§è¡Œ

**Rust 1.90 æ”¹è¿›**:

- æ›´ç²¾ç¡®çš„ç©·å°½æ€§åˆ†æ
- æ›´å¥½çš„ä¸å¯è¾¾ä»£ç æ£€æµ‹

---

## 5ï¸âƒ£ ç»„åˆå±‚æ¦‚å¿µ

### 5.1 é—­åŒ…ç³»ç»Ÿ (Closure System)

**å½¢å¼åŒ–å®šä¹‰**:

```text
Closure := |Parameters| Body
         | |Parameters| -> ReturnType Body
         | move |Parameters| Body
where:
  Parameters: å‚æ•°åˆ—è¡¨ï¼ˆç±»å‹å¯æ¨æ–­ï¼‰
  Body: è¡¨è¾¾å¼æˆ–å—
  move: æ˜¾å¼ç§»åŠ¨æ•è·
```

**æœ¬ä½“å±æ€§**:

- **åŒ¿åæ€§**: æ— éœ€å‘½å
- **ç¯å¢ƒæ•è·**: å¯è®¿é—®å¤–éƒ¨å˜é‡
- **ç±»å‹æ¨æ–­**: å‚æ•°å’Œè¿”å›ç±»å‹å¯æ¨æ–­
- **Fn Traits**: å®ç°Fn/FnMut/FnOnce

#### 5.1.1 æ•è·æ¨¡å¼

**å½¢å¼åŒ–å®šä¹‰**:

```text
Capture := 
  | Borrow(&T)          // ä¸å¯å˜å€Ÿç”¨
  | MutBorrow(&mut T)   // å¯å˜å€Ÿç”¨
  | Move(T)             // ç§»åŠ¨æ‰€æœ‰æƒ
```

**è‡ªåŠ¨æ¨æ–­è§„åˆ™**:

```rust
// è§„åˆ™1: é»˜è®¤æœ€å°åŒ–æ•è·
let x = vec![1, 2, 3];
let closure = || println!("{:?}", x);  // æ•è·&x

// è§„åˆ™2: æ ¹æ®ä½¿ç”¨æ¨æ–­
let mut count = 0;
let mut inc = || count += 1;  // æ•è·&mut count

// è§„åˆ™3: moveå¼ºåˆ¶ç§»åŠ¨
let closure = move || drop(x);  // ç§»åŠ¨x
```

**Rust 1.90 æ”¹è¿›**: æ›´ç²¾ç¡®çš„æ•è·ï¼ˆæ•è·å­—æ®µè€Œéæ•´ä¸ªç»“æ„ä½“ï¼‰

#### 5.1.2 Fn Traits

**å½¢å¼åŒ–å®šä¹‰**:

```text
trait FnOnce<Args> {
    type Output;
    fn call_once(self, args: Args) -> Self::Output;
}

trait FnMut<Args>: FnOnce<Args> {
    fn call_mut(&mut self, args: Args) -> Self::Output;
}

trait Fn<Args>: FnMut<Args> {
    fn call(&self, args: Args) -> Self::Output;
}
```

**å±‚æ¬¡å…³ç³»**:

```text
Fn âŠ‚ FnMut âŠ‚ FnOnce

Fn:     å¯å¤šæ¬¡è°ƒç”¨ï¼Œä¸å¯å˜å€Ÿç”¨
FnMut:  å¯å¤šæ¬¡è°ƒç”¨ï¼Œå¯å˜å€Ÿç”¨
FnOnce: åªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œæ¶ˆè´¹self
```

### 5.2 è¿­ä»£å™¨ç³»ç»Ÿ (Iterator System)

**å½¢å¼åŒ–å®šä¹‰**:

```text
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    
    // å¤§é‡é»˜è®¤æ–¹æ³•...
}

trait IntoIterator {
    type Item;
    type IntoIter: Iterator<Item = Self::Item>;
    fn into_iter(self) -> Self::IntoIter;
}
```

**æœ¬ä½“å±æ€§**:

- **æƒ°æ€§æ±‚å€¼**: æ–¹æ³•é“¾ä¸ç«‹å³æ‰§è¡Œ
- **é›¶æˆæœ¬æŠ½è±¡**: ä¼˜åŒ–åç­‰ä»·æ‰‹å†™å¾ªç¯
- **è¿­ä»£å™¨èåˆ**: å¤šæ¬¡éå†åˆå¹¶ä¸ºå•æ¬¡

#### 5.2.1 è¿­ä»£å™¨åˆ†ç±»

**æŒ‰æ–¹æ³•ç±»å‹**:

```text
Adapter:   è¿”å›æ–°è¿­ä»£å™¨ï¼ˆæƒ°æ€§ï¼‰
  - map, filter, take, skip, chain, zip, flat_map

Consumer:  æ¶ˆè´¹è¿­ä»£å™¨ï¼Œè¿”å›å€¼ï¼ˆç«‹å³ï¼‰
  - collect, fold, reduce, sum, count

Searcher:  æœç´¢å…ƒç´ ï¼ˆçŸ­è·¯ï¼‰
  - find, any, all, position
```

#### 5.2.2 æ‰€æœ‰æƒæ¨¡å¼

**ä¸‰ç§è¿­ä»£æ–¹å¼**:

```rust
let vec = vec![1, 2, 3];

vec.into_iter()  // æ¶ˆè´¹vecï¼Œè·å¾—T
vec.iter()       // å€Ÿç”¨vecï¼Œè·å¾—&T
vec.iter_mut()   // å¯å˜å€Ÿç”¨vecï¼Œè·å¾—&mut T
```

### 5.3 é”™è¯¯å¤„ç†ç³»ç»Ÿ (Error Handling System)

#### 5.3.1 Resultç±»å‹

**å½¢å¼åŒ–å®šä¹‰**:

```text
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**æœ¬ä½“å±æ€§**:

- **ç±»å‹**: æšä¸¾
- **è¯­ä¹‰**: æˆåŠŸæˆ–å¤±è´¥
- **å•å­**: å®ç°Monadæ¨¡å¼

#### 5.3.2 Optionç±»å‹

**å½¢å¼åŒ–å®šä¹‰**:

```text
enum Option<T> {
    Some(T),
    None,
}
```

**æœ¬ä½“å±æ€§**:

- **ç±»å‹**: æšä¸¾
- **è¯­ä¹‰**: æœ‰å€¼æˆ–æ— å€¼
- **å•å­**: å®ç°Monadæ¨¡å¼

#### 5.3.3 ?è¿ç®—ç¬¦

**å½¢å¼åŒ–å®šä¹‰**:

```text
expr? := 
  match expr {
      Ok(val) => val,
      Err(e) => return Err(From::from(e)),
  }

  // æˆ–å¯¹äºOption:
  match expr {
      Some(val) => val,
      None => return None,
  }
```

**æœ¬ä½“å±æ€§**:

- **è¯­æ³•ç³–**: ç®€åŒ–é”™è¯¯ä¼ æ’­
- **ç±»å‹è½¬æ¢**: è‡ªåŠ¨Fromè½¬æ¢
- **æ§åˆ¶æµ**: æ—©æœŸè¿”å›

**Traitæ”¯æŒ**:

```rust
trait Try {
    type Output;
    type Residual;
    
    fn from_output(output: Self::Output) -> Self;
    fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;
}

trait FromResidual<R> {
    fn from_residual(residual: R) -> Self;
}
```

---

## 6ï¸âƒ£ ç±»å‹ç³»ç»Ÿé›†æˆ

### 6.1 Neverç±»å‹ (!)

**å½¢å¼åŒ–å®šä¹‰**:

```text
! := ç©ºç±»å‹ï¼ˆæ— å€¼ï¼‰
```

**æœ¬ä½“å±æ€§**:

- **å€¼**: æ— ï¼ˆuninhabited typeï¼‰
- **ç”¨é€”**: è¡¨ç¤ºæ°¸ä¸è¿”å›
- **ç±»å‹å¼ºåˆ¶**: å¯è½¬æ¢ä¸ºä»»ä½•ç±»å‹
- **Rust 1.90**: å®Œå…¨ç¨³å®š

**ç¤ºä¾‹**:

```rust
fn diverges() -> ! {
    panic!("never returns");
}

let x: i32 = if cond {
    42
} else {
    diverges()  // ! coerces to i32
};
```

### 6.2 ç±»å‹æ¨æ–­

**æœ¬ä½“å±æ€§**:

- **å±€éƒ¨æ¨æ–­**: å‡½æ•°å†…ç±»å‹æ¨æ–­
- **å…¨å±€æ¨æ–­**: æ³›å‹å‚æ•°æ¨æ–­
- **åŒå‘æ¨æ–­**: ä»è¿”å›ç±»å‹æ¨æ–­å‚æ•°

### 6.3 ç±»å‹ç»Ÿä¸€

**å½¢å¼åŒ–è§„åˆ™**:

```text
Unification Rule (ifè¡¨è¾¾å¼):
Î“ âŠ¢ then_branch: Tâ‚
Î“ âŠ¢ else_branch: Tâ‚‚
Tâ‚ = Tâ‚‚  (æˆ– Tâ‚/Tâ‚‚ å¯åå˜)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ if expr { then } else { els }: Tâ‚
```

---

## ğŸ”— æ¦‚å¿µå…³ç³»æ€»ç»“

### æ ¸å¿ƒä¾èµ–å…³ç³»

```text
è¡¨è¾¾å¼ â”€â”€is-base-ofâ”€â”€â†’ æ§åˆ¶æµ
ç±»å‹ç³»ç»Ÿ â”€â”€constrainsâ”€â”€â†’ æ‰€æœ‰æ¦‚å¿µ
æ¨¡å¼åŒ¹é… â”€â”€enablesâ”€â”€â†’ match/if-let/let-else
å‡½æ•° â”€â”€is-generalized-byâ”€â”€â†’ é—­åŒ…
è¿­ä»£å™¨ â”€â”€usesâ”€â”€â†’ forå¾ªç¯
Result/Option â”€â”€enablesâ”€â”€â†’ ?è¿ç®—ç¬¦
```

### ç»„åˆå…³ç³»

```text
å¾ªç¯ + æ¨¡å¼ = while-let
æ¡ä»¶ + æ¨¡å¼ = if-let
æ¨¡å¼ + æ—©è¿”å› = let-else
å‡½æ•° + æ•è· = é—­åŒ…
Iterator + æ–¹æ³•é“¾ = å£°æ˜å¼ç¼–ç¨‹
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [å…³ç³»ç½‘ç»œ](./02_relationship_network.md) - æ¦‚å¿µé—´çš„è¯¦ç»†å…³ç³»
- [å±æ€§ç©ºé—´](./03_property_space.md) - å¤šç»´å±æ€§åˆ†æ
- [æ¨ç†è§„åˆ™](./04_reasoning_rules.md) - è‡ªåŠ¨æ¨ç†è§„åˆ™
- [Rust Reference - Expressions](https://doc.rust-lang.org/reference/expressions.html)

---

**æ–‡æ¡£ç»´æŠ¤**: Rust å­¦ä¹ ç¤¾åŒº  
**æ›´æ–°é¢‘ç‡**: éšRustç‰ˆæœ¬æ›´æ–°  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
