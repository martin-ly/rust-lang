# 04. 函数与闭包 (Functions and Closures)

> **文档类型**：基础  
> **难度等级**：⭐⭐⭐  
> **预计阅读时间**：2小时  
> **前置知识**：Rust 基本语法、所有权与借用、trait 基础


## 📊 目录

- [04. 函数与闭包 (Functions and Closures)](#04-函数与闭包-functions-and-closures)
  - [📊 目录](#-目录)
  - [📖 内容概述](#-内容概述)
  - [🎯 学习目标](#-学习目标)
  - [📚 目录](#-目录-1)
  - [4.1. 函数 (Functions)](#41-函数-functions)
  - [4.2. 闭包 (Closures)](#42-闭包-closures)
    - [4.2.1. 定义与环境捕获](#421-定义与环境捕获)
    - [4.2.2. `move` 关键字](#422-move-关键字)
    - [4.2.3. 作为控制流机制](#423-作为控制流机制)


## 📖 内容概述

函数和闭包是 Rust 中组织代码和转移控制流的核心单元。本文档深入讲解函数的控制流转移、所有权传递、闭包的环境捕获机制，以及 Fn trait 系统。

## 🎯 学习目标

完成本文档学习后，你将能够：

- [ ] 理解函数调用的控制流转移机制
- [ ] 掌握函数参数的所有权传递规则
- [ ] 理解发散函数和 never 类型的作用
- [ ] 掌握闭包的三种捕获模式
- [ ] 理解 Fn、FnMut、FnOnce trait 的区别
- [ ] 能够编写高阶函数和闭包组合器

## 📚 目录

- [04. 函数与闭包 (Functions and Closures)](#04-函数与闭包-functions-and-closures)
  - [� 目录](#-目录)
  - [📖 内容概述](#-内容概述)
  - [🎯 学习目标](#-学习目标)
  - [📚 目录](#-目录-1)
  - [4.1. 函数 (Functions)](#41-函数-functions)
  - [4.2. 闭包 (Closures)](#42-闭包-closures)
    - [4.2.1. 定义与环境捕获](#421-定义与环境捕获)
    - [4.2.2. `move` 关键字](#422-move-关键字)
    - [4.2.3. 作为控制流机制](#423-作为控制流机制)

---

## 4.1. 函数 (Functions)

函数是具名的、可复用的代码块。在控制流的视角下，函数调用是一种控制权的转移。

**核心概念**:

1. **控制流转移**:
    - **调用 (Call)**: 当一个函数被调用时，程序的执行控制权从调用点转移到函数的入口。
    - **返回 (Return)**: 函数通过 `return` 关键字或在函数体最后一个表达式隐式返回值，将控制权和计算结果（如果有）交还给调用点。

2. **所有权转移**:
    函数参数的传递和返回值的传递严格遵循所有权规则：
    - **传值 (Move)**: `fn process(s: String)` - `s` 的所有权被移入函数。
    - **不可变借用**: `fn view(s: &String)` - `s` 被不可变地借用。
    - **可变借用**: `fn mutate(s: &mut String)` - `s` 被可变地借用。

3. **递归 (Recursion)**:
    函数可以调用自身，形成递归。这是实现某些算法（如树的遍历）的自然方式。Rust 编译器不进行尾调用优化（TCO），因此深度递归可能导致栈溢出。

4. **发散函数 (Diverging Functions)**:
    - **定义**: 发散函数是永不返回的函数，其返回类型为 `!` (never type)。
    - **作用**: 它向编译器明确表示该路径的控制流将不会返回到调用点。常见的发散函数包括 `panic!`, `std::process::exit`，以及无限循环 `loop {}`。
    - **类型系统**: `!` 类型可以被强制转换 (coerce) 为任何其他类型。这使得它可以在 `match` 分支等要求所有分支返回同一类型的地方使用。

**代码示例**:

```rust
// 发散函数作为 match 分支
fn check_input(input: i32) -> String {
    match input {
        0..=100 => format!("Valid input: {}", input),
        _ => panic!("Input out of range!"), // panic! 返回 `!`
    }
    // 编译器知道 panic! 分支不会返回，因此类型检查通过
}
```

## 4.2. 闭包 (Closures)

闭包是匿名的、可以捕获其所在环境的函数式结构。它们在需要传递函数作为参数的场景（如迭代器适配器）中非常强大。

### 4.2.1. 定义与环境捕获

闭包的语法为 `|arg1, arg2, ...| { body }`。其核心特性是能够捕获 (capture) 定义它时所在作用域中的变量。

捕获方式有三种，由闭包如何使用被捕获的变量决定，并对应三种 `Fn` Trait：

1. **`FnOnce`**:
    - **行为**: **消耗**被捕获的变量（通过移动所有权）。
    - **调用**: 只能被调用一次。
    - **例子**: `|s: String| drop(s)`。

2. **`FnMut`**:
    - **行为**: **可变地借用**被捕获的变量。
    - **调用**: 可以被多次调用，并在调用期间修改环境。
    - **例子**: `|vec: &mut Vec<i32>| vec.push(1)`。

3. **`Fn`**:
    - **行为**: **不可变地借用**被捕获的变量。
    - **调用**: 可以被多次调用，不能修改环境。
    - **例子**: `|x: &i32| println!("{}", x)`。

**Trait 关系**: `Fn` 是 `FnMut` 的子 trait，`FnMut` 是 `FnOnce` 的子 trait。即任何 `Fn` 闭包都可以被当作 `FnMut` 或 `FnOnce` 使用。编译器会为每个闭包自动推断出最合适的 trait。

### 4.2.2. `move` 关键字

在闭包定义前使用 `move` 关键字 (`move || ...`) 会强制闭包获得其捕获的所有变量的**所有权**。这在多线程编程中至关重要，可以确保闭包的生命周期不会超过其引用的变量。

```rust
use std::thread;

let data = vec![1, 2, 3];

// `move` 关键字将 `data` 的所有权转移给新线程
let handle = thread::spawn(move || {
    // 如果没有 `move`，`data` 的借用可能在主线程结束后失效，导致悬垂引用
    println!("Here's the data: {:?}", data);
});

// `data` 在此已不可用
// println!("{:?}", data); // 编译错误

handle.join().unwrap();
```

### 4.2.3. 作为控制流机制

闭包是 Rust 中实现高阶函数 (Higher-Order Functions) 和延迟执行 (Lazy Execution) 的关键。

- **高阶函数**: 接受函数（闭包）作为参数或返回函数的函数。最典型的例子是 `Iterator` trait 的各种适配器，如 `map`, `filter`, `fold`。
- **延迟执行**: 闭包封装了一段代码，但直到它被显式调用时才会执行。

**代码示例**:

```rust
let numbers = vec![1, 2, 3, 4, 5];

// `filter` 和 `map` 接受闭包作为参数来定义控制流
let sum_of_even_squares: i32 = numbers
    .iter() // 产生一个迭代器
    .filter(|&&n| n % 2 == 0) // 闭包定义过滤条件
    .map(|&n| n * n) // 闭包定义转换逻辑
    .sum(); // 消耗迭代器并求和

println!("Sum: {}", sum_of_even_squares); // (2*2 + 4*4) = 20
```

在这个链式调用中，控制流由一系列闭包驱动，每个闭包定义了数据流中的一步操作。

---

**章节导航:**

- **上一章 ->** `03_iterative_constructs.md`
- **下一章 ->** `05_error_handling_as_control_flow.md`: 将 `Option` 和 `Result` 视为一种控制流机制。
- **返回目录 ->** `_index.md`
