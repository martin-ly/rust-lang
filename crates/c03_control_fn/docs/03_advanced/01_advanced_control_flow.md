# 01. é«˜çº§æ§åˆ¶æµæ¨¡å¼ (Advanced Control Flow Patterns)

> **æ–‡æ¡£ç±»å‹**ï¼šé«˜çº§  
> **éš¾åº¦ç­‰çº§**ï¼šâ­â­â­â­  
> **é¢„è®¡é˜…è¯»æ—¶é—´**ï¼š2-3å°æ—¶  
> **å‰ç½®çŸ¥è¯†**ï¼šRust åŸºç¡€ã€å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µã€ç±»å‹ç³»ç»Ÿ

## ğŸ“– å†…å®¹æ¦‚è¿°

é™¤äº†åŸºç¡€çš„æ¡ä»¶å’Œå¾ªç¯ï¼ŒRust è¿˜æä¾›äº†æ›´é«˜çº§çš„æ¨¡å¼æ¥ç®¡ç†å¤æ‚çš„æ§åˆ¶æµã€‚æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å¼‚æ­¥æ§åˆ¶æµå’Œç±»å‹çŠ¶æ€æ¨¡å¼ä¸¤ç§å¼ºå¤§æœºåˆ¶ï¼Œå±•ç¤ºå¦‚ä½•åˆ©ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿå®ç°ç¼–è¯‘æ—¶ä¿è¯ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- [ ] ç†è§£ async/await çš„çŠ¶æ€æœºè½¬æ¢æœºåˆ¶
- [ ] æŒæ¡ Future trait çš„å·¥ä½œåŸç†
- [ ] ç†è§£ç±»å‹çŠ¶æ€æ¨¡å¼çš„è®¾è®¡æ€æƒ³
- [ ] å®ç°ç¼–è¯‘æ—¶çŠ¶æ€æ£€æŸ¥
- [ ] åº”ç”¨é«˜çº§æ§åˆ¶æµæ¨¡å¼è§£å†³å®é™…é—®é¢˜

## ğŸ“š ç›®å½•

- [01. é«˜çº§æ§åˆ¶æµæ¨¡å¼ (Advanced Control Flow Patterns)](#01-é«˜çº§æ§åˆ¶æµæ¨¡å¼-advanced-control-flow-patterns)
  - [ğŸ“– å†…å®¹æ¦‚è¿°](#-å†…å®¹æ¦‚è¿°)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1.1. å¼‚æ­¥æ§åˆ¶æµ (Asynchronous Control Flow)](#11-å¼‚æ­¥æ§åˆ¶æµ-asynchronous-control-flow)
    - [6.1.1. `async`, `await`, ä¸ `Future`](#611-async-await-ä¸-future)
    - [6.1.2. çŠ¶æ€æœºè½¬æ¢çš„å½¢å¼åŒ–è§†è§’](#612-çŠ¶æ€æœºè½¬æ¢çš„å½¢å¼åŒ–è§†è§’)
  - [6.2. ç±»å‹é©±åŠ¨çš„æ§åˆ¶æµ (Type-Driven Control Flow)](#62-ç±»å‹é©±åŠ¨çš„æ§åˆ¶æµ-type-driven-control-flow)
    - [6.2.1. ç±»å‹çŠ¶æ€æ¨¡å¼](#621-ç±»å‹çŠ¶æ€æ¨¡å¼)

---

## 1.1. å¼‚æ­¥æ§åˆ¶æµ (Asynchronous Control Flow)

ä¼ ç»Ÿçš„åŒæ­¥å‡½æ•°ä¼šé˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ°æ“ä½œå®Œæˆã€‚è€Œå¼‚æ­¥ç¼–ç¨‹å…è®¸ç¨‹åºåœ¨ç­‰å¾…ä¸€ä¸ªé•¿æ—¶é—´æ“ä½œï¼ˆå¦‚ç½‘ç»œè¯·æ±‚æˆ–æ–‡ä»¶ I/Oï¼‰æ—¶ï¼Œå°†çº¿ç¨‹çš„æ§åˆ¶æƒäº¤è¿˜ç»™è¿è¡Œæ—¶ï¼Œä»¥ä¾¿æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼Œä»è€Œå®ç°é«˜å¹¶å‘ã€‚

### 6.1.1. `async`, `await`, ä¸ `Future`

Rust çš„å¼‚æ­¥æ¨¡å‹ä¸»è¦å›´ç»•ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µæ„å»ºï¼š

1. **`async fn`**:
    - `async` å…³é”®å­—ç”¨äºå°†ä¸€ä¸ªæ™®é€šå‡½æ•°è½¬æ¢ä¸ºå¼‚æ­¥å‡½æ•°ã€‚
    - `async fn` ä¸ä¼šç«‹å³æ‰§è¡Œå‡½æ•°ä½“ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªå®ç°äº† `Future` trait çš„åŒ¿åç±»å‹ã€‚

2. **`Future` Trait**:
    - `Future` æ˜¯å¯¹ä¸€ä¸ªæœªæ¥æŸä¸ªæ—¶åˆ»æ‰èƒ½äº§ç”Ÿçš„"å€¼"çš„æŠ½è±¡ã€‚å®ƒä»£è¡¨ä¸€ä¸ªå¯ä»¥è¢«è½®è¯¢ï¼ˆpollï¼‰çš„å¼‚æ­¥è®¡ç®—ã€‚
    - å…¶æ ¸å¿ƒæ–¹æ³•æ˜¯ `poll`ï¼Œå®ƒä¼šå°è¯•æ¨è¿›è®¡ç®—ã€‚`poll` çš„è¿”å›ç»“æœæ˜¯ `Poll<Self::Output>`ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼š
        - `Poll::Ready(value)`: è®¡ç®—å®Œæˆï¼Œè¿”å›æœ€ç»ˆå€¼ã€‚
        - `Poll::Pending`: è®¡ç®—å°šæœªå®Œæˆï¼Œè¿è¡Œæ—¶åº”è¯¥åœ¨ç¨åå†æ¬¡è½®è¯¢ã€‚

3. **`.await`**:
    - `.await` å…³é”®å­—ç”¨äºæš‚åœä¸€ä¸ª `async fn` çš„æ‰§è¡Œï¼Œç›´åˆ°å…¶ç­‰å¾…çš„ `Future` å®Œæˆã€‚
    - å½“ `.await` è¢«è°ƒç”¨æ—¶ï¼Œå®ƒä¼šå°†å½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒ**è®©æ¸¡ (yield)** ç»™å¼‚æ­¥è¿è¡Œæ—¶ï¼ˆå¦‚ `tokio` æˆ– `async-std`ï¼‰ã€‚è¿è¡Œæ—¶å¯ä»¥å»æ‰§è¡Œå…¶ä»–å°±ç»ªçš„ä»»åŠ¡ã€‚å½“è¢«ç­‰å¾…çš„ `Future` å®Œæˆåï¼Œè¿è¡Œæ—¶ä¼šå”¤é†’è¿™ä¸ªä»»åŠ¡å¹¶ä» `.await` çš„æš‚åœç‚¹ç»§ç»­æ‰§è¡Œã€‚

### 6.1.2. çŠ¶æ€æœºè½¬æ¢çš„å½¢å¼åŒ–è§†è§’

åœ¨åº•å±‚ï¼Œ`async fn` è¢«ç¼–è¯‘å™¨è½¬æ¢ä¸ºä¸€ä¸ª**çŠ¶æ€æœº (State Machine)**ã€‚

- å‡½æ•°ä½“ä¸­çš„æ¯ä¸ª `.await` ç‚¹éƒ½ä»£è¡¨ä¸€ä¸ªæ½œåœ¨çš„**çŠ¶æ€è½¬æ¢**ã€‚
- å‡½æ•°çš„æ‰€æœ‰å±€éƒ¨å˜é‡ï¼ˆåŒ…æ‹¬åœ¨ `.await` ç‚¹ä¹‹é—´ä¼ é€’çš„å˜é‡ï¼‰éƒ½ä¼šæˆä¸ºè¿™ä¸ªçŠ¶æ€æœºç»“æ„ä½“çš„æˆå‘˜ã€‚
- æ¯æ¬¡è°ƒç”¨ `poll` æ—¶ï¼ŒçŠ¶æ€æœºä¼šä»å½“å‰çŠ¶æ€å¼€å§‹æ‰§è¡Œï¼Œç›´åˆ°ä¸‹ä¸€ä¸ª `.await` ç‚¹ï¼ˆè¿›å…¥ `Pending` çŠ¶æ€ï¼‰æˆ–å‡½æ•°è¿”å›ï¼ˆè¿›å…¥ `Ready` çŠ¶æ€ï¼‰ã€‚

è¿™ç§è½¬æ¢æ˜¯é›¶æˆæœ¬æŠ½è±¡çš„å…¸èŒƒï¼šå®ƒå°†é«˜çº§çš„ã€çœ‹ä¼¼é¡ºåºçš„ `async/await` ä»£ç ï¼Œç¼–è¯‘æˆäº†é«˜æ•ˆçš„ã€åŸºäºçŠ¶æ€æœºçš„åº•å±‚å®ç°ï¼Œè€Œæ— éœ€æ‰‹å†™å¤æ‚çš„å›è°ƒã€‚

**ä»£ç ç¤ºä¾‹**:

```rust
async fn fetch_data() -> u32 {
    // æ¨¡æ‹Ÿä¸€ä¸ªéœ€è¦ 1 ç§’çš„å¼‚æ­¥æ“ä½œ
    println!("Fetching data...");
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    println!("Data fetched.");
    42
}

async fn process_data() {
    println!("About to process data.");
    let data = fetch_data().await; // æ§åˆ¶æµåœ¨æ­¤æš‚åœï¼Œè®©å‡ºçº¿ç¨‹
    println!("Processing data: {}", data); // Futureå®Œæˆåï¼Œä»è¿™é‡Œç»§ç»­
}

#[tokio::main]
async fn main() {
    process_data().await;
}
```

## 6.2. ç±»å‹é©±åŠ¨çš„æ§åˆ¶æµ (Type-Driven Control Flow)

è¿™æ˜¯ä¸€ç§æ›´é«˜çº§çš„æ¨¡å¼ï¼Œå®ƒåˆ©ç”¨ Rust å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿåœ¨**ç¼–è¯‘æ—¶**å¼ºåˆ¶æ‰§è¡Œç‰¹å®šçš„çŠ¶æ€è½¬æ¢é€»è¾‘ï¼Œä»è€Œä½¿éæ³•çš„æ§åˆ¶æµè·¯å¾„å˜å¾—**ä¸å¯è¡¨ç¤º (unrepresentable)**ã€‚è¿™ç§æ¨¡å¼æœ€å…¸å‹çš„å®ç°æ˜¯**ç±»å‹çŠ¶æ€æ¨¡å¼ (Type State Pattern)**ã€‚

### 6.2.1. ç±»å‹çŠ¶æ€æ¨¡å¼

è¯¥æ¨¡å¼é€šè¿‡å°†å¯¹è±¡çš„çŠ¶æ€ç¼–ç ä¸ºæ³›å‹ç±»å‹å‚æ•°æ¥å®ç°ã€‚å¯¹è±¡çš„æ–¹æ³•è¢«å®šä¹‰åœ¨ç‰¹å®šçš„çŠ¶æ€ç±»å‹ä¸Šï¼Œå› æ­¤åªæœ‰å½“å¯¹è±¡å¤„äºè¯¥çŠ¶æ€æ—¶ï¼Œå¯¹åº”çš„æ–¹æ³•æ‰å¯ç”¨ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- ä¸€ä¸ªç»“æ„ä½“ `Machine<State>` çš„çŠ¶æ€ç”±å…¶ç±»å‹å‚æ•° `State` è¡¨ç¤ºã€‚
- çŠ¶æ€æœ¬èº«æ˜¯ç‹¬ç«‹çš„ç±»å‹ï¼ˆé€šå¸¸æ˜¯é›¶å¤§å°çš„ç©ºç»“æ„ä½“ï¼‰ã€‚
- æ¶ˆè€— `self` çš„æ–¹æ³• (`fn method(self) -> Machine<NewState>`) ç”¨äºå®ç°çŠ¶æ€è½¬æ¢ã€‚

**å½¢å¼åŒ–è§†è§’**:
è¿™å®è´¨ä¸Šæ˜¯åœ¨ç±»å‹ç³»ç»Ÿå±‚é¢æ„å»ºäº†ä¸€ä¸ªæœ‰é™çŠ¶æ€è‡ªåŠ¨æœº (Finite State Automaton, FSA)ã€‚

- **çŠ¶æ€ (States)**: ç”±ä¸åŒçš„ç±»å‹ï¼ˆå¦‚ `Uninitialized`, `Running`, `Stopped`ï¼‰è¡¨ç¤ºã€‚
- **è½¬æ¢ (Transitions)**: ç”±æ¶ˆè€—æ—§çŠ¶æ€å¹¶è¿”å›æ–°çŠ¶æ€çš„æ–¹æ³•è¡¨ç¤ºã€‚
- **ç¼–è¯‘æ—¶ä¿è¯**: ç¼–è¯‘å™¨æˆä¸ºçŠ¶æ€æœºçš„éªŒè¯å™¨ã€‚ä»»ä½•éæ³•çš„çŠ¶æ€è½¬æ¢ï¼ˆä¾‹å¦‚ï¼Œåœ¨ `Stopped` çŠ¶æ€ä¸‹è°ƒç”¨ `run` æ–¹æ³•ï¼‰éƒ½ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºè¯¥æ–¹æ³•åœ¨ `Machine<Stopped>` ç±»å‹ä¸Šæ ¹æœ¬ä¸å­˜åœ¨ã€‚

**ä»£ç ç¤ºä¾‹**:

```rust
// 1. å®šä¹‰çŠ¶æ€ç±»å‹
struct Uninitialized;
struct Initialized { data: String }
struct Active;

// 2. å®šä¹‰æŒæœ‰çŠ¶æ€çš„ç»“æ„ä½“
struct Process<State> {
    _state: std::marker::PhantomData<State>,
}

// 3. åœ¨ç‰¹å®šçŠ¶æ€ä¸Šå®ç°æ–¹æ³•
impl Process<Uninitialized> {
    // "new" æ„é€ å™¨åˆ›å»ºä¸€ä¸ªå¤„äºæœªåˆå§‹åŒ–çŠ¶æ€çš„ Process
    fn new() -> Process<Uninitialized> {
        Process { _state: std::marker::PhantomData }
    }
    // åªèƒ½åœ¨ Uninitialized çŠ¶æ€ä¸‹è°ƒç”¨ initialize
    fn initialize(self) -> Process<Initialized> {
        println!("Process Initializing...");
        Process { _state: std::marker::PhantomData }
    }
}

impl Process<Initialized> {
    // åªèƒ½åœ¨ Initialized çŠ¶æ€ä¸‹è°ƒç”¨ activate
    fn activate(self) -> Process<Active> {
        println!("Process Activating...");
        Process { _state: std::marker::PhantomData }
    }
}

fn main() {
    let p = Process::new();
    // p.activate(); // ç¼–è¯‘é”™è¯¯! `activate` æ–¹æ³•åœ¨ `Process<Uninitialized>` ä¸Šä¸å­˜åœ¨

    let p_init = p.initialize(); // p è¢«æ¶ˆè€—, çŠ¶æ€è½¬æ¢ä¸º Initialized
    let p_active = p_init.activate(); // p_init è¢«æ¶ˆè€—, çŠ¶æ€è½¬æ¢ä¸º Active
}
```

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬åˆ©ç”¨ç±»å‹ç³»ç»Ÿæ¥ä¿è¯äº† `initialize` å¿…é¡»åœ¨ `activate` ä¹‹å‰è¢«è°ƒç”¨ï¼Œå°†è¿è¡Œæ—¶é€»è¾‘é”™è¯¯æå‡ä¸ºäº†ç¼–è¯‘æ—¶ç±»å‹é”™è¯¯ã€‚

---

**ç« èŠ‚å¯¼èˆª:**

- **ä¸Šä¸€ç«  ->** `05_error_handling_as_control_flow.md`
- **è¿”å›ç›®å½• ->** `_index.md`
