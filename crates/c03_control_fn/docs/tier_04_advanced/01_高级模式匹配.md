# 4.1 高级模式匹配

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 深入探讨Rust模式匹配的高级技巧和最佳实践  
> **适用对象**: 需要掌握复杂模式匹配的高级开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [模式匹配指南](../tier_02_guides/04_模式匹配指南.md)


## 📊 目录

- [4.1 高级模式匹配](#41-高级模式匹配)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 复杂嵌套模式](#1-复杂嵌套模式)
    - [深度嵌套解构](#深度嵌套解构)
    - [组合结构体与枚举](#组合结构体与枚举)
  - [2. 守卫与绑定](#2-守卫与绑定)
    - [复杂守卫表达式](#复杂守卫表达式)
    - [@ 绑定高级用法](#-绑定高级用法)
    - [多重绑定](#多重绑定)
  - [3. 切片模式](#3-切片模式)
    - [基本切片匹配](#基本切片匹配)
    - [复杂切片模式](#复杂切片模式)
    - [字符串切片模式](#字符串切片模式)
  - [4. 或模式与范围](#4-或模式与范围)
    - [复杂或模式](#复杂或模式)
    - [范围模式技巧](#范围模式技巧)
    - [或模式与守卫](#或模式与守卫)
  - [5. 引用模式](#5-引用模式)
    - [ref 与 ref mut](#ref-与-ref-mut)
    - [解引用模式](#解引用模式)
    - [引用与所有权](#引用与所有权)
  - [6. 结构化绑定](#6-结构化绑定)
    - [let-else 模式](#let-else-模式)
    - [if-let 与 while-let](#if-let-与-while-let)
    - [函数参数模式](#函数参数模式)
  - [7. 宏与模式](#7-宏与模式)
    - [使用宏生成模式](#使用宏生成模式)
    - [模式匹配宏](#模式匹配宏)
  - [8. 无可实例化类型模式匹配 (Rust 1.90)](#8-无可实例化类型模式匹配-rust-190)
    - [空枚举 (Empty Enum)](#空枚举-empty-enum)
    - [Never 类型 (!)](#never-类型-)
    - [省略不可达分支](#省略不可达分支)
    - [编译器优化](#编译器优化)
    - [实际应用：状态机中的不可达状态](#实际应用状态机中的不可达状态)
  - [9. 性能优化](#9-性能优化)
    - [避免不必要的克隆](#避免不必要的克隆)
    - [穷尽性与优化](#穷尽性与优化)
    - [大型枚举优化](#大型枚举优化)


**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [4.1 高级模式匹配](#41-高级模式匹配)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 复杂嵌套模式](#1-复杂嵌套模式)
    - [深度嵌套解构](#深度嵌套解构)
    - [组合结构体与枚举](#组合结构体与枚举)
  - [2. 守卫与绑定](#2-守卫与绑定)
    - [复杂守卫表达式](#复杂守卫表达式)
    - [@ 绑定高级用法](#-绑定高级用法)
    - [多重绑定](#多重绑定)
  - [3. 切片模式](#3-切片模式)
    - [基本切片匹配](#基本切片匹配)
    - [复杂切片模式](#复杂切片模式)
    - [字符串切片模式](#字符串切片模式)
  - [4. 或模式与范围](#4-或模式与范围)
    - [复杂或模式](#复杂或模式)
    - [范围模式技巧](#范围模式技巧)
    - [或模式与守卫](#或模式与守卫)
  - [5. 引用模式](#5-引用模式)
    - [ref 与 ref mut](#ref-与-ref-mut)
    - [解引用模式](#解引用模式)
    - [引用与所有权](#引用与所有权)
  - [6. 结构化绑定](#6-结构化绑定)
    - [let-else 模式](#let-else-模式)
    - [if-let 与 while-let](#if-let-与-while-let)
    - [函数参数模式](#函数参数模式)
  - [7. 宏与模式](#7-宏与模式)
    - [使用宏生成模式](#使用宏生成模式)
    - [模式匹配宏](#模式匹配宏)
  - [8. 无可实例化类型模式匹配 (Rust 1.90)](#8-无可实例化类型模式匹配-rust-190)
    - [空枚举 (Empty Enum)](#空枚举-empty-enum)
    - [Never 类型 (!)](#never-类型-)
    - [省略不可达分支](#省略不可达分支)
    - [编译器优化](#编译器优化)
    - [实际应用：状态机中的不可达状态](#实际应用状态机中的不可达状态)
  - [9. 性能优化](#9-性能优化)
    - [避免不必要的克隆](#避免不必要的克隆)
    - [穷尽性与优化](#穷尽性与优化)
    - [大型枚举优化](#大型枚举优化)

---

## 1. 复杂嵌套模式

### 深度嵌套解构

```rust
#[derive(Debug)]
enum Message {
    Move { x: i32, y: i32 },
    Echo(String),
    ChangeColor(i32, i32, i32),
    Quit,
}

#[derive(Debug)]
struct State {
    position: (i32, i32),
    message: Option<Message>,
    history: Vec<String>,
}

fn main() {
    let state = State {
        position: (10, 20),
        message: Some(Message::Move { x: 5, y: 15 }),
        history: vec!["start".to_string(), "moving".to_string()],
    };
    
    // 多层嵌套解构
    match state {
        State {
            position: (x, y),
            message: Some(Message::Move { x: mx, y: my }),
            history,
        } if x + mx == 15 => {
            println!("目标位置: ({}, {})", x + mx, y + my);
            println!("历史: {:?}", history);
        },
        State {
            message: Some(Message::Echo(ref msg)),
            ..
        } => {
            println!("回显: {}", msg);
        },
        _ => println!("其他情况"),
    }
}
```

### 组合结构体与枚举

```rust
struct Point {
    x: i32,
    y: i32,
}

enum Shape {
    Circle { center: Point, radius: f64 },
    Rectangle { top_left: Point, bottom_right: Point },
    Triangle(Point, Point, Point),
}

fn analyze_shape(shape: &Shape) {
    match shape {
        // 嵌套结构体解构
        Shape::Circle { 
            center: Point { x, y }, 
            radius 
        } if *radius > 10.0 => {
            println!("大圆: 中心({}, {}), 半径{}", x, y, radius);
        },
        
        // 多个绑定
        Shape::Rectangle { 
            top_left: Point { x: x1, y: y1 },
            bottom_right: Point { x: x2, y: y2 }
        } if x2 - x1 == y2 - y1 => {
            println!("正方形: 边长{}", x2 - x1);
        },
        
        // 元组变体解构
        Shape::Triangle(
            Point { x: x1, .. },
            Point { x: x2, .. },
            Point { x: x3, .. }
        ) if x1 == x2 && x2 == x3 => {
            println!("垂直三角形");
        },
        
        _ => println!("其他形状"),
    }
}

fn main() {
    let circle = Shape::Circle {
        center: Point { x: 0, y: 0 },
        radius: 15.0,
    };
    analyze_shape(&circle);
}
```

---

## 2. 守卫与绑定

### 复杂守卫表达式

```rust
fn main() {
    let pair = (2, -2);
    
    // 守卫中的复杂逻辑
    match pair {
        (x, y) if x == y => println!("相等"),
        (x, y) if x + y == 0 => println!("互为相反数"),
        (x, y) if x * y > 0 => println!("同号"),
        (x, y) if x.abs() == y.abs() => println!("绝对值相等"),
        _ => println!("其他情况"),
    }
    
    // 守卫中调用函数
    fn is_prime(n: i32) -> bool {
        if n < 2 { return false; }
        (2..n).all(|i| n % i != 0)
    }
    
    let numbers = vec![2, 3, 4, 5, 6, 7];
    for &n in &numbers {
        match n {
            x if is_prime(x) => println!("{} 是质数", x),
            x => println!("{} 不是质数", x),
        }
    }
}
```

### @ 绑定高级用法

```rust
fn main() {
    // @ 与范围组合
    let age = 25;
    match age {
        n @ 0..=12 => println!("儿童: {}", n),
        n @ 13..=17 => println!("青少年: {}", n),
        n @ 18..=59 => println!("成年人: {}", n),
        n @ 60.. => println!("老年人: {}", n),
    }
    
    // @ 与守卫组合
    let value = Some(42);
    match value {
        Some(n @ 0..=50) if n % 2 == 0 => {
            println!("小偶数: {}", n);
        },
        Some(n @ 51..) if n % 2 == 0 => {
            println!("大偶数: {}", n);
        },
        Some(n) => println!("奇数: {}", n),
        None => println!("无值"),
    }
    
    // @ 与或模式
    enum Status {
        Active,
        Pending,
        Inactive,
    }
    
    let status = Status::Active;
    match status {
        s @ (Status::Active | Status::Pending) => {
            println!("活动状态: {:?}", s);
        },
        Status::Inactive => println!("非活动"),
    }
}
```

### 多重绑定

```rust
struct Wrapper<T> {
    value: T,
}

fn main() {
    let nested = Wrapper {
        value: Wrapper {
            value: 42,
        },
    };
    
    // 多层 @ 绑定
    match nested {
        Wrapper { 
            value: inner @ Wrapper { value: num }
        } if num > 40 => {
            println!("内层: {:?}, 值: {}", inner.value, num);
        },
        _ => println!("其他"),
    }
    
    // 元组多重绑定
    let tuple = ((1, 2), (3, 4));
    match tuple {
        pair @ ((x, _), (_, y)) if x + y == 5 => {
            println!("配对: {:?}, x={}, y={}", pair, x, y);
        },
        _ => println!("不匹配"),
    }
}
```

---

## 3. 切片模式

### 基本切片匹配

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];
    
    // 固定长度匹配
    match &numbers[..] {
        [first, second, ..] => {
            println!("前两个: {}, {}", first, second);
        },
        _ => unreachable!(),
    }
    
    // 精确匹配
    match &numbers[..] {
        [1, 2, 3, 4, 5] => println!("精确匹配"),
        _ => println!("不匹配"),
    }
    
    // 中间元素
    match &numbers[..] {
        [first, .., last] => {
            println!("首尾: {}, {}", first, last);
        },
        _ => unreachable!(),
    }
}
```

### 复杂切片模式

```rust
fn analyze_sequence(seq: &[i32]) {
    match seq {
        // 空序列
        [] => println!("空序列"),
        
        // 单元素
        [x] => println!("单元素: {}", x),
        
        // 两元素
        [x, y] => println!("两元素: {}, {}", x, y),
        
        // 首尾模式
        [first, .., last] if first == last => {
            println!("首尾相同: {}", first);
        },
        
        // 递增序列检测
        [first, rest @ ..] if rest.iter().all(|&x| x > *first) => {
            println!("递增序列");
        },
        
        // 特定模式
        [1, 2, rest @ ..] => {
            println!("以1,2开头，后续: {:?}", rest);
        },
        
        _ => println!("其他模式"),
    }
}

fn main() {
    analyze_sequence(&[]);
    analyze_sequence(&[42]);
    analyze_sequence(&[1, 2, 3, 4, 5]);
    analyze_sequence(&[5, 4, 3, 2, 1]);
}
```

### 字符串切片模式

```rust
fn parse_command(input: &str) {
    match input.split_whitespace().collect::<Vec<_>>().as_slice() {
        ["get", key] => {
            println!("获取键: {}", key);
        },
        ["set", key, value] => {
            println!("设置 {} = {}", key, value);
        },
        ["delete", keys @ ..] => {
            println!("删除键: {:?}", keys);
        },
        _ => println!("未知命令"),
    }
}

fn main() {
    parse_command("get name");
    parse_command("set age 30");
    parse_command("delete id name email");
}
```

---

## 4. 或模式与范围

### 复杂或模式

```rust
fn main() {
    // 多值或模式
    let digit = '7';
    match digit {
        '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => {
            println!("数字字符");
        },
        _ => println!("非数字"),
    }
    
    // 嵌套或模式
    enum Color {
        RGB(u8, u8, u8),
        HSV(f32, f32, f32),
    }
    
    let color = Color::RGB(255, 0, 0);
    match color {
        Color::RGB(255, 0, 0) | Color::RGB(0, 255, 0) | Color::RGB(0, 0, 255) => {
            println!("纯色");
        },
        Color::RGB(r, g, b) if r == g && g == b => {
            println!("灰度");
        },
        _ => println!("其他颜色"),
    }
}
```

### 范围模式技巧

```rust
fn main() {
    // 字符范围
    let ch = 'k';
    match ch {
        'a'..='z' => println!("小写字母"),
        'A'..='Z' => println!("大写字母"),
        '0'..='9' => println!("数字"),
        _ => println!("其他字符"),
    }
    
    // 数值范围组合
    let score = 85;
    match score {
        90..=100 => println!("优秀"),
        80..=89 => println!("良好"),
        70..=79 => println!("中等"),
        60..=69 => println!("及格"),
        0..=59 => println!("不及格"),
        _ => println!("无效分数"),
    }
    
    // 开放范围
    let value = 1000;
    match value {
        0..=100 => println!("小"),
        101..=500 => println!("中"),
        501.. => println!("大"),
    }
}
```

### 或模式与守卫

```rust
fn main() {
    let point = (3, 4);
    
    // 或模式 + 守卫
    match point {
        (x, 0) | (0, x) if x > 0 => {
            println!("坐标轴上的正值点: {}", x);
        },
        (x, y) if x == y => {
            println!("对角线上的点");
        },
        (x, y) if x.abs() == y.abs() => {
            println!("副对角线上的点");
        },
        _ => println!("其他点"),
    }
}
```

---

## 5. 引用模式

### ref 与 ref mut

```rust
fn main() {
    let mut data = vec![1, 2, 3];
    
    // ref 获取不可变引用
    match data.first() {
        Some(ref first) => {
            println!("首元素引用: {}", first);
            // first 的类型是 &i32
        },
        None => println!("空"),
    }
    
    // ref mut 获取可变引用
    match data.first_mut() {
        Some(ref mut first) => {
            *first += 10;
            println!("修改后: {}", first);
        },
        None => println!("空"),
    }
    
    println!("数据: {:?}", data);
}
```

### 解引用模式

```rust
fn main() {
    let reference = &42;
    
    // & 模式自动解引用
    match reference {
        &val => println!("值: {}", val),
    }
    
    // 嵌套引用
    let double_ref = &&42;
    match double_ref {
        &&val => println!("双重解引用: {}", val),
    }
    
    // 复杂解引用
    struct Wrapper(i32);
    let wrapped = &Wrapper(100);
    
    match wrapped {
        &Wrapper(value) => println!("解包: {}", value),
    }
}
```

### 引用与所有权

```rust
fn main() {
    let s = String::from("hello");
    
    // 使用 ref 避免移动
    match Some(s) {
        Some(ref inner) => {
            println!("引用: {}", inner);
            // s 的所有权未被移动
        },
        None => {},
    }
    
    // 可以继续使用 s
    // println!("{}", s);  // 错误：s已被移动
    
    // 正确方式：使用引用
    let s = String::from("world");
    match Some(&s) {
        Some(inner) => {
            println!("引用: {}", inner);
        },
        None => {},
    }
    println!("{}", s);  // OK
}
```

---

## 6. 结构化绑定

### let-else 模式

```rust
fn main() {
    // 基本 let-else
    let Some(value) = Some(42) else {
        panic!("无值");
    };
    println!("值: {}", value);
    
    // 复杂模式
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    
    let Ok(number) = Result::Ok(100) else {
        eprintln!("错误");
        return;
    };
    println!("数字: {}", number);
}
```

### if-let 与 while-let

```rust
fn main() {
    // if-let 链
    let value = Some(Some(42));
    
    if let Some(inner) = value {
        if let Some(num) = inner {
            println!("嵌套值: {}", num);
        }
    }
    
    // while-let 迭代
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("弹出: {}", top);
    }
    
    // if-let 守卫
    let data = Some(50);
    if let Some(n) = data {
        if n > 40 {
            println!("大值: {}", n);
        }
    }
}
```

### 函数参数模式

```rust
// 元组解构参数
fn print_coords(&(x, y): &(i32, i32)) {
    println!("坐标: ({}, {})", x, y);
}

// 结构体解构参数
struct Point {
    x: i32,
    y: i32,
}

fn distance(Point { x: x1, y: y1 }: Point, Point { x: x2, y: y2 }: Point) -> f64 {
    (((x2 - x1).pow(2) + (y2 - y1).pow(2)) as f64).sqrt()
}

fn main() {
    print_coords(&(10, 20));
    
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 3, y: 4 };
    println!("距离: {}", distance(p1, p2));
}
```

---

## 7. 宏与模式

### 使用宏生成模式

```rust
macro_rules! match_pair {
    ($val:expr, $($pattern:pat => $result:expr),*) => {
        match $val {
            $($pattern => $result,)*
        }
    };
}

fn main() {
    let value = 5;
    
    let result = match_pair!(value,
        1 => "one",
        2 => "two",
        3 => "three",
        _ => "other"
    );
    
    println!("结果: {}", result);
}
```

### 模式匹配宏

```rust
macro_rules! extract {
    ($opt:expr, Some($val:ident)) => {
        if let Some($val) = $opt {
            $val
        } else {
            panic!("None值");
        }
    };
    ($res:expr, Ok($val:ident)) => {
        match $res {
            Ok($val) => $val,
            Err(e) => panic!("错误: {:?}", e),
        }
    };
}

fn main() {
    let opt = Some(42);
    let value = extract!(opt, Some(v));
    println!("提取值: {}", value);
}
```

---

## 8. 无可实例化类型模式匹配 (Rust 1.90)

**无可实例化类型** (Uninhabited Types) 是指在运行时永远无法构造出实例的类型。Rust 1.26+ 引入了对空枚举的支持，Rust 1.90 进一步完善了编译器对此类型的优化和模式匹配省略能力。

### 空枚举 (Empty Enum)

空枚举是最直接的无可实例化类型：

```rust
// 定义一个无可实例化类型
enum Void {}

// ✅ 可以在函数签名中使用
fn impossible_function(_x: Void) -> u32 {
    // 因为 Void 无法实例化，这个函数体永远不会执行
    // 可以省略任何返回值，或者使用 match 来表达不可达性
    match _x {}  // 空 match 表达式，编译器知道这永远不会匹配
}

fn main() {
    // ❌ 无法创建 Void 的实例
    // let v: Void = ???;  // 编译错误：没有任何方式构造 Void
    
    // 因此 impossible_function 实际上永远无法被调用
    // let result = impossible_function(v);
}
```

**应用场景**：类型级别的不可能性证明

```rust
enum Void {}

// 使用无可实例化类型表示"不可能的错误"
type Infallible = Void;

fn always_succeeds() -> Result<i32, Infallible> {
    Ok(42)  // 永远不会返回 Err
}

fn main() {
    match always_succeeds() {
        Ok(value) => println!("值: {}", value),
        // ✅ Rust 1.90: 可以省略 Err 分支
        // 因为编译器知道 Infallible 无法实例化
    }
}
```

**注意**：标准库在 Rust 1.82 中稳定化了 `core::convert::Infallible`，它就是一个无可实例化枚举。

### Never 类型 (!)

Never 类型 `!` 是 Rust 的另一种无可实例化类型，表示"永不返回"：

```rust
// ✅ 发散函数 (Diverging Functions)
fn exit_program() -> ! {
    std::process::exit(0)
}

fn infinite_loop() -> ! {
    loop {
        println!("Forever...");
    }
}

fn always_panic() -> ! {
    panic!("This never returns");
}

fn main() {
    // Never 类型可以强制转换为任何类型
    let x: i32 = if false {
        42
    } else {
        exit_program()  // ! 类型可以转换为 i32
    };
    
    println!("x: {}", x);
}
```

**Never 类型的模式匹配**：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// 当错误类型是 ! 时，可以省略 Err 分支
fn parse_infallible(s: &str) -> Result<i32, !> {
    Ok(s.parse().unwrap())
}

fn main() {
    // ✅ Rust 1.90: 编译器允许省略不可达的 Err 分支
    let Result::Ok(value) = parse_infallible("42");
    println!("解析结果: {}", value);
    
    // 或者使用完整 match，但 Err 分支可以是空的
    match parse_infallible("100") {
        Result::Ok(v) => println!("值: {}", v),
        // Err(_) => {}  // 可省略
    }
}
```

**Never 类型的子类型规则**：

```rust
fn demonstrate_never_coercion() {
    // ! 是所有类型的子类型 (Bottom Type)
    let x: i32 = return;  // return 的类型是 !
    let y: String = panic!("error");  // panic! 的类型是 !
    
    // 这使得以下代码合法
    let result: i32 = if some_condition() {
        calculate()
    } else {
        return;  // ! 强制转换为 i32
    };
}

fn some_condition() -> bool { true }
fn calculate() -> i32 { 42 }
```

### 省略不可达分支

Rust 1.90 允许在模式匹配中省略无可实例化类型的分支：

```rust
enum Void {}

enum Either<L, R> {
    Left(L),
    Right(R),
}

fn demo_omit_branches() {
    // 当 Right 的类型是 Void 时，它永远不会出现
    let value: Either<i32, Void> = Either::Left(42);
    
    // ✅ 方式 1: 使用空 match 来处理不可达分支
    match value {
        Either::Left(x) => println!("左值: {}", x),
        Either::Right(void) => match void {},  // 空 match 表示不可达
    }
    
    // ✅ 方式 2: 直接省略不可达分支 (Rust 1.90+)
    let Either::Left(x) = value;
    println!("提取的值: {}", x);
    
    // ✅ 方式 3: 使用 if let
    if let Either::Left(x) = value {
        println!("if let: {}", x);
    }
    // 不需要 else 分支
}
```

**更复杂的例子**：泛型函数中的不可达性

```rust
enum Void {}

fn process_result<T, E>(result: Result<T, E>) -> T 
where
    E: std::fmt::Debug,
{
    match result {
        Ok(value) => value,
        Err(err) => panic!("错误: {:?}", err),
    }
}

// 特化版本：当错误类型是 Void 时
fn process_infallible<T>(result: Result<T, Void>) -> T {
    // ✅ 可以使用 match 和空分支
    match result {
        Ok(value) => value,
        Err(void) => match void {},  // 编译器知道这永远不会执行
    }
}

// ✅ 更简洁的写法
fn process_infallible_v2<T>(result: Result<T, Void>) -> T {
    let Ok(value) = result;
    value
}

fn main() {
    let result: Result<i32, Void> = Ok(42);
    println!("处理结果: {}", process_infallible_v2(result));
}
```

### 编译器优化

编译器对无可实例化类型有特殊的优化：

```rust
use std::mem::size_of;

enum Void {}

fn main() {
    // 优化 1: 零大小
    assert_eq!(size_of::<Void>(), 0);
    assert_eq!(size_of::<[Void; 1000]>(), 0);
    
    // 优化 2: Option 布局优化
    // Result<T, Void> 的大小等于 T
    assert_eq!(size_of::<Result<i32, Void>>(), size_of::<i32>());
    
    // 优化 3: 自动判定代码不可达
    let impossible: Result<i32, Void> = Ok(42);
    let value = match impossible {
        Ok(x) => x * 2,
        Err(void) => {
            // 编译器知道这个分支永远不会执行
            // 因此不会为这个分支生成任何代码
            match void {}
        }
    };
    println!("值: {}", value);
}
```

**LLVM 层面的优化**：

```rust
enum Void {}

// 编译器生成的汇编代码会非常简洁
pub fn extract_ok(r: Result<i32, Void>) -> i32 {
    match r {
        Ok(x) => x,
        Err(void) => match void {},
    }
}

// 等价于直接返回：
pub fn extract_ok_optimized(r: Result<i32, Void>) -> i32 {
    // 编译器知道 r 永远是 Ok(_)，因此直接访问其值
    unsafe { std::mem::transmute(r) }  // 仅用于说明，实际不需要 unsafe
}
```

### 实际应用：状态机中的不可达状态

```rust
enum Void {}

struct StateMachine<S> {
    state: S,
}

struct Initial;
struct Running;
struct Terminated;

impl StateMachine<Initial> {
    fn new() -> Self {
        StateMachine { state: Initial }
    }
    
    fn start(self) -> StateMachine<Running> {
        StateMachine { state: Running }
    }
}

impl StateMachine<Running> {
    fn stop(self) -> StateMachine<Terminated> {
        StateMachine { state: Terminated }
    }
    
    // 这个函数永远不会失败
    fn process(&self) -> Result<(), Void> {
        println!("处理中...");
        Ok(())
    }
}

impl StateMachine<Terminated> {
    // 终止状态无法重启，用 ! 表示
    fn restart(self) -> ! {
        panic!("终止状态无法重启");
    }
}

fn main() {
    let machine = StateMachine::new()
        .start();
    
    // ✅ 不需要处理 Err 分支
    let Ok(()) = machine.process();
    
    let machine = machine.stop();
    
    // machine.restart();  // 这会 panic，类型系统无法阻止，但函数签名已表明
}
```

**最佳实践**：

1. **使用 `core::convert::Infallible`** 而不是自定义空枚举（Rust 1.82+）
2. **类型级别不变式**：用无可实例化类型表达"不可能发生"
3. **API 设计**：在无错误路径的函数中使用 `Result<T, Infallible>`
4. **状态机**：使用类型状态模式时，不可达状态可用 `!` 或空枚举表示

---

## 9. 性能优化

### 避免不必要的克隆

```rust
fn main() {
    let data = vec![String::from("hello"), String::from("world")];
    
    // ❌ 不好：克隆
    for item in &data {
        let s = item.clone();
        println!("{}", s);
    }
    
    // ✅ 好：使用引用
    for item in &data {
        println!("{}", item);
    }
    
    // ✅ 好：模式匹配引用
    match data.first() {
        Some(first) => println!("首元素: {}", first),
        None => {},
    }
}
```

### 穷尽性与优化

```rust
fn main() {
    // 编译器优化：穷尽性已知
    let value = Some(42);
    let result = match value {
        Some(x) => x,
        None => 0,
    };
    
    // vs 使用unwrap_or（相同性能）
    let result2 = value.unwrap_or(0);
    
    assert_eq!(result, result2);
}
```

### 大型枚举优化

```rust
enum Large {
    Small(u8),
    Big(Box<[u8; 1000]>),  // 使用Box避免栈溢出
}

fn main() {
    let value = Large::Big(Box::new([0; 1000]));
    
    match value {
        Large::Small(x) => println!("小: {}", x),
        Large::Big(ref data) => println!("大: {} 字节", data.len()),
    }
}
```

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🔥 掌握高级模式匹配，编写更优雅的Rust代码！** 🦀✨
