# 4.1 é«˜çº§æ¨¡å¼åŒ¹é…

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: æ·±å…¥æ¢è®¨Rustæ¨¡å¼åŒ¹é…çš„é«˜çº§æŠ€å·§å’Œæœ€ä½³å®è·µ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æŒæ¡å¤æ‚æ¨¡å¼åŒ¹é…çš„é«˜çº§å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [æ¨¡å¼åŒ¹é…æŒ‡å—](../tier_02_guides/04_æ¨¡å¼åŒ¹é…æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [4.1 é«˜çº§æ¨¡å¼åŒ¹é…](#41-é«˜çº§æ¨¡å¼åŒ¹é…)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¤æ‚åµŒå¥—æ¨¡å¼](#1-å¤æ‚åµŒå¥—æ¨¡å¼)
    - [æ·±åº¦åµŒå¥—è§£æ„](#æ·±åº¦åµŒå¥—è§£æ„)
    - [ç»„åˆç»“æ„ä½“ä¸æšä¸¾](#ç»„åˆç»“æ„ä½“ä¸æšä¸¾)
  - [2. å®ˆå«ä¸ç»‘å®š](#2-å®ˆå«ä¸ç»‘å®š)
    - [å¤æ‚å®ˆå«è¡¨è¾¾å¼](#å¤æ‚å®ˆå«è¡¨è¾¾å¼)
    - [@ ç»‘å®šé«˜çº§ç”¨æ³•](#-ç»‘å®šé«˜çº§ç”¨æ³•)
    - [å¤šé‡ç»‘å®š](#å¤šé‡ç»‘å®š)
  - [3. åˆ‡ç‰‡æ¨¡å¼](#3-åˆ‡ç‰‡æ¨¡å¼)
    - [åŸºæœ¬åˆ‡ç‰‡åŒ¹é…](#åŸºæœ¬åˆ‡ç‰‡åŒ¹é…)
    - [å¤æ‚åˆ‡ç‰‡æ¨¡å¼](#å¤æ‚åˆ‡ç‰‡æ¨¡å¼)
    - [å­—ç¬¦ä¸²åˆ‡ç‰‡æ¨¡å¼](#å­—ç¬¦ä¸²åˆ‡ç‰‡æ¨¡å¼)
  - [4. æˆ–æ¨¡å¼ä¸èŒƒå›´](#4-æˆ–æ¨¡å¼ä¸èŒƒå›´)
    - [å¤æ‚æˆ–æ¨¡å¼](#å¤æ‚æˆ–æ¨¡å¼)
    - [èŒƒå›´æ¨¡å¼æŠ€å·§](#èŒƒå›´æ¨¡å¼æŠ€å·§)
    - [æˆ–æ¨¡å¼ä¸å®ˆå«](#æˆ–æ¨¡å¼ä¸å®ˆå«)
  - [5. å¼•ç”¨æ¨¡å¼](#5-å¼•ç”¨æ¨¡å¼)
    - [ref ä¸ ref mut](#ref-ä¸-ref-mut)
    - [è§£å¼•ç”¨æ¨¡å¼](#è§£å¼•ç”¨æ¨¡å¼)
    - [å¼•ç”¨ä¸æ‰€æœ‰æƒ](#å¼•ç”¨ä¸æ‰€æœ‰æƒ)
  - [6. ç»“æ„åŒ–ç»‘å®š](#6-ç»“æ„åŒ–ç»‘å®š)
    - [let-else æ¨¡å¼](#let-else-æ¨¡å¼)
    - [if-let ä¸ while-let](#if-let-ä¸-while-let)
    - [å‡½æ•°å‚æ•°æ¨¡å¼](#å‡½æ•°å‚æ•°æ¨¡å¼)
  - [7. å®ä¸æ¨¡å¼](#7-å®ä¸æ¨¡å¼)
    - [ä½¿ç”¨å®ç”Ÿæˆæ¨¡å¼](#ä½¿ç”¨å®ç”Ÿæˆæ¨¡å¼)
    - [æ¨¡å¼åŒ¹é…å®](#æ¨¡å¼åŒ¹é…å®)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [é¿å…ä¸å¿…è¦çš„å…‹éš†](#é¿å…ä¸å¿…è¦çš„å…‹éš†)
    - [ç©·å°½æ€§ä¸ä¼˜åŒ–](#ç©·å°½æ€§ä¸ä¼˜åŒ–)
    - [å¤§å‹æšä¸¾ä¼˜åŒ–](#å¤§å‹æšä¸¾ä¼˜åŒ–)

---

## 1. å¤æ‚åµŒå¥—æ¨¡å¼

### æ·±åº¦åµŒå¥—è§£æ„

```rust
#[derive(Debug)]
enum Message {
    Move { x: i32, y: i32 },
    Echo(String),
    ChangeColor(i32, i32, i32),
    Quit,
}

#[derive(Debug)]
struct State {
    position: (i32, i32),
    message: Option<Message>,
    history: Vec<String>,
}

fn main() {
    let state = State {
        position: (10, 20),
        message: Some(Message::Move { x: 5, y: 15 }),
        history: vec!["start".to_string(), "moving".to_string()],
    };
    
    // å¤šå±‚åµŒå¥—è§£æ„
    match state {
        State {
            position: (x, y),
            message: Some(Message::Move { x: mx, y: my }),
            history,
        } if x + mx == 15 => {
            println!("ç›®æ ‡ä½ç½®: ({}, {})", x + mx, y + my);
            println!("å†å²: {:?}", history);
        },
        State {
            message: Some(Message::Echo(ref msg)),
            ..
        } => {
            println!("å›æ˜¾: {}", msg);
        },
        _ => println!("å…¶ä»–æƒ…å†µ"),
    }
}
```

### ç»„åˆç»“æ„ä½“ä¸æšä¸¾

```rust
struct Point {
    x: i32,
    y: i32,
}

enum Shape {
    Circle { center: Point, radius: f64 },
    Rectangle { top_left: Point, bottom_right: Point },
    Triangle(Point, Point, Point),
}

fn analyze_shape(shape: &Shape) {
    match shape {
        // åµŒå¥—ç»“æ„ä½“è§£æ„
        Shape::Circle { 
            center: Point { x, y }, 
            radius 
        } if *radius > 10.0 => {
            println!("å¤§åœ†: ä¸­å¿ƒ({}, {}), åŠå¾„{}", x, y, radius);
        },
        
        // å¤šä¸ªç»‘å®š
        Shape::Rectangle { 
            top_left: Point { x: x1, y: y1 },
            bottom_right: Point { x: x2, y: y2 }
        } if x2 - x1 == y2 - y1 => {
            println!("æ­£æ–¹å½¢: è¾¹é•¿{}", x2 - x1);
        },
        
        // å…ƒç»„å˜ä½“è§£æ„
        Shape::Triangle(
            Point { x: x1, .. },
            Point { x: x2, .. },
            Point { x: x3, .. }
        ) if x1 == x2 && x2 == x3 => {
            println!("å‚ç›´ä¸‰è§’å½¢");
        },
        
        _ => println!("å…¶ä»–å½¢çŠ¶"),
    }
}

fn main() {
    let circle = Shape::Circle {
        center: Point { x: 0, y: 0 },
        radius: 15.0,
    };
    analyze_shape(&circle);
}
```

---

## 2. å®ˆå«ä¸ç»‘å®š

### å¤æ‚å®ˆå«è¡¨è¾¾å¼

```rust
fn main() {
    let pair = (2, -2);
    
    // å®ˆå«ä¸­çš„å¤æ‚é€»è¾‘
    match pair {
        (x, y) if x == y => println!("ç›¸ç­‰"),
        (x, y) if x + y == 0 => println!("äº’ä¸ºç›¸åæ•°"),
        (x, y) if x * y > 0 => println!("åŒå·"),
        (x, y) if x.abs() == y.abs() => println!("ç»å¯¹å€¼ç›¸ç­‰"),
        _ => println!("å…¶ä»–æƒ…å†µ"),
    }
    
    // å®ˆå«ä¸­è°ƒç”¨å‡½æ•°
    fn is_prime(n: i32) -> bool {
        if n < 2 { return false; }
        (2..n).all(|i| n % i != 0)
    }
    
    let numbers = vec![2, 3, 4, 5, 6, 7];
    for &n in &numbers {
        match n {
            x if is_prime(x) => println!("{} æ˜¯è´¨æ•°", x),
            x => println!("{} ä¸æ˜¯è´¨æ•°", x),
        }
    }
}
```

### @ ç»‘å®šé«˜çº§ç”¨æ³•

```rust
fn main() {
    // @ ä¸èŒƒå›´ç»„åˆ
    let age = 25;
    match age {
        n @ 0..=12 => println!("å„¿ç«¥: {}", n),
        n @ 13..=17 => println!("é’å°‘å¹´: {}", n),
        n @ 18..=59 => println!("æˆå¹´äºº: {}", n),
        n @ 60.. => println!("è€å¹´äºº: {}", n),
    }
    
    // @ ä¸å®ˆå«ç»„åˆ
    let value = Some(42);
    match value {
        Some(n @ 0..=50) if n % 2 == 0 => {
            println!("å°å¶æ•°: {}", n);
        },
        Some(n @ 51..) if n % 2 == 0 => {
            println!("å¤§å¶æ•°: {}", n);
        },
        Some(n) => println!("å¥‡æ•°: {}", n),
        None => println!("æ— å€¼"),
    }
    
    // @ ä¸æˆ–æ¨¡å¼
    enum Status {
        Active,
        Pending,
        Inactive,
    }
    
    let status = Status::Active;
    match status {
        s @ (Status::Active | Status::Pending) => {
            println!("æ´»åŠ¨çŠ¶æ€: {:?}", s);
        },
        Status::Inactive => println!("éæ´»åŠ¨"),
    }
}
```

### å¤šé‡ç»‘å®š

```rust
struct Wrapper<T> {
    value: T,
}

fn main() {
    let nested = Wrapper {
        value: Wrapper {
            value: 42,
        },
    };
    
    // å¤šå±‚ @ ç»‘å®š
    match nested {
        Wrapper { 
            value: inner @ Wrapper { value: num }
        } if num > 40 => {
            println!("å†…å±‚: {:?}, å€¼: {}", inner.value, num);
        },
        _ => println!("å…¶ä»–"),
    }
    
    // å…ƒç»„å¤šé‡ç»‘å®š
    let tuple = ((1, 2), (3, 4));
    match tuple {
        pair @ ((x, _), (_, y)) if x + y == 5 => {
            println!("é…å¯¹: {:?}, x={}, y={}", pair, x, y);
        },
        _ => println!("ä¸åŒ¹é…"),
    }
}
```

---

## 3. åˆ‡ç‰‡æ¨¡å¼

### åŸºæœ¬åˆ‡ç‰‡åŒ¹é…

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];
    
    // å›ºå®šé•¿åº¦åŒ¹é…
    match &numbers[..] {
        [first, second, ..] => {
            println!("å‰ä¸¤ä¸ª: {}, {}", first, second);
        },
        _ => unreachable!(),
    }
    
    // ç²¾ç¡®åŒ¹é…
    match &numbers[..] {
        [1, 2, 3, 4, 5] => println!("ç²¾ç¡®åŒ¹é…"),
        _ => println!("ä¸åŒ¹é…"),
    }
    
    // ä¸­é—´å…ƒç´ 
    match &numbers[..] {
        [first, .., last] => {
            println!("é¦–å°¾: {}, {}", first, last);
        },
        _ => unreachable!(),
    }
}
```

### å¤æ‚åˆ‡ç‰‡æ¨¡å¼

```rust
fn analyze_sequence(seq: &[i32]) {
    match seq {
        // ç©ºåºåˆ—
        [] => println!("ç©ºåºåˆ—"),
        
        // å•å…ƒç´ 
        [x] => println!("å•å…ƒç´ : {}", x),
        
        // ä¸¤å…ƒç´ 
        [x, y] => println!("ä¸¤å…ƒç´ : {}, {}", x, y),
        
        // é¦–å°¾æ¨¡å¼
        [first, .., last] if first == last => {
            println!("é¦–å°¾ç›¸åŒ: {}", first);
        },
        
        // é€’å¢åºåˆ—æ£€æµ‹
        [first, rest @ ..] if rest.iter().all(|&x| x > *first) => {
            println!("é€’å¢åºåˆ—");
        },
        
        // ç‰¹å®šæ¨¡å¼
        [1, 2, rest @ ..] => {
            println!("ä»¥1,2å¼€å¤´ï¼Œåç»­: {:?}", rest);
        },
        
        _ => println!("å…¶ä»–æ¨¡å¼"),
    }
}

fn main() {
    analyze_sequence(&[]);
    analyze_sequence(&[42]);
    analyze_sequence(&[1, 2, 3, 4, 5]);
    analyze_sequence(&[5, 4, 3, 2, 1]);
}
```

### å­—ç¬¦ä¸²åˆ‡ç‰‡æ¨¡å¼

```rust
fn parse_command(input: &str) {
    match input.split_whitespace().collect::<Vec<_>>().as_slice() {
        ["get", key] => {
            println!("è·å–é”®: {}", key);
        },
        ["set", key, value] => {
            println!("è®¾ç½® {} = {}", key, value);
        },
        ["delete", keys @ ..] => {
            println!("åˆ é™¤é”®: {:?}", keys);
        },
        _ => println!("æœªçŸ¥å‘½ä»¤"),
    }
}

fn main() {
    parse_command("get name");
    parse_command("set age 30");
    parse_command("delete id name email");
}
```

---

## 4. æˆ–æ¨¡å¼ä¸èŒƒå›´

### å¤æ‚æˆ–æ¨¡å¼

```rust
fn main() {
    // å¤šå€¼æˆ–æ¨¡å¼
    let digit = '7';
    match digit {
        '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => {
            println!("æ•°å­—å­—ç¬¦");
        },
        _ => println!("éæ•°å­—"),
    }
    
    // åµŒå¥—æˆ–æ¨¡å¼
    enum Color {
        RGB(u8, u8, u8),
        HSV(f32, f32, f32),
    }
    
    let color = Color::RGB(255, 0, 0);
    match color {
        Color::RGB(255, 0, 0) | Color::RGB(0, 255, 0) | Color::RGB(0, 0, 255) => {
            println!("çº¯è‰²");
        },
        Color::RGB(r, g, b) if r == g && g == b => {
            println!("ç°åº¦");
        },
        _ => println!("å…¶ä»–é¢œè‰²"),
    }
}
```

### èŒƒå›´æ¨¡å¼æŠ€å·§

```rust
fn main() {
    // å­—ç¬¦èŒƒå›´
    let ch = 'k';
    match ch {
        'a'..='z' => println!("å°å†™å­—æ¯"),
        'A'..='Z' => println!("å¤§å†™å­—æ¯"),
        '0'..='9' => println!("æ•°å­—"),
        _ => println!("å…¶ä»–å­—ç¬¦"),
    }
    
    // æ•°å€¼èŒƒå›´ç»„åˆ
    let score = 85;
    match score {
        90..=100 => println!("ä¼˜ç§€"),
        80..=89 => println!("è‰¯å¥½"),
        70..=79 => println!("ä¸­ç­‰"),
        60..=69 => println!("åŠæ ¼"),
        0..=59 => println!("ä¸åŠæ ¼"),
        _ => println!("æ— æ•ˆåˆ†æ•°"),
    }
    
    // å¼€æ”¾èŒƒå›´
    let value = 1000;
    match value {
        0..=100 => println!("å°"),
        101..=500 => println!("ä¸­"),
        501.. => println!("å¤§"),
    }
}
```

### æˆ–æ¨¡å¼ä¸å®ˆå«

```rust
fn main() {
    let point = (3, 4);
    
    // æˆ–æ¨¡å¼ + å®ˆå«
    match point {
        (x, 0) | (0, x) if x > 0 => {
            println!("åæ ‡è½´ä¸Šçš„æ­£å€¼ç‚¹: {}", x);
        },
        (x, y) if x == y => {
            println!("å¯¹è§’çº¿ä¸Šçš„ç‚¹");
        },
        (x, y) if x.abs() == y.abs() => {
            println!("å‰¯å¯¹è§’çº¿ä¸Šçš„ç‚¹");
        },
        _ => println!("å…¶ä»–ç‚¹"),
    }
}
```

---

## 5. å¼•ç”¨æ¨¡å¼

### ref ä¸ ref mut

```rust
fn main() {
    let mut data = vec![1, 2, 3];
    
    // ref è·å–ä¸å¯å˜å¼•ç”¨
    match data.first() {
        Some(ref first) => {
            println!("é¦–å…ƒç´ å¼•ç”¨: {}", first);
            // first çš„ç±»å‹æ˜¯ &i32
        },
        None => println!("ç©º"),
    }
    
    // ref mut è·å–å¯å˜å¼•ç”¨
    match data.first_mut() {
        Some(ref mut first) => {
            *first += 10;
            println!("ä¿®æ”¹å: {}", first);
        },
        None => println!("ç©º"),
    }
    
    println!("æ•°æ®: {:?}", data);
}
```

### è§£å¼•ç”¨æ¨¡å¼

```rust
fn main() {
    let reference = &42;
    
    // & æ¨¡å¼è‡ªåŠ¨è§£å¼•ç”¨
    match reference {
        &val => println!("å€¼: {}", val),
    }
    
    // åµŒå¥—å¼•ç”¨
    let double_ref = &&42;
    match double_ref {
        &&val => println!("åŒé‡è§£å¼•ç”¨: {}", val),
    }
    
    // å¤æ‚è§£å¼•ç”¨
    struct Wrapper(i32);
    let wrapped = &Wrapper(100);
    
    match wrapped {
        &Wrapper(value) => println!("è§£åŒ…: {}", value),
    }
}
```

### å¼•ç”¨ä¸æ‰€æœ‰æƒ

```rust
fn main() {
    let s = String::from("hello");
    
    // ä½¿ç”¨ ref é¿å…ç§»åŠ¨
    match Some(s) {
        Some(ref inner) => {
            println!("å¼•ç”¨: {}", inner);
            // s çš„æ‰€æœ‰æƒæœªè¢«ç§»åŠ¨
        },
        None => {},
    }
    
    // å¯ä»¥ç»§ç»­ä½¿ç”¨ s
    // println!("{}", s);  // é”™è¯¯ï¼šså·²è¢«ç§»åŠ¨
    
    // æ­£ç¡®æ–¹å¼ï¼šä½¿ç”¨å¼•ç”¨
    let s = String::from("world");
    match Some(&s) {
        Some(inner) => {
            println!("å¼•ç”¨: {}", inner);
        },
        None => {},
    }
    println!("{}", s);  // OK
}
```

---

## 6. ç»“æ„åŒ–ç»‘å®š

### let-else æ¨¡å¼

```rust
fn main() {
    // åŸºæœ¬ let-else
    let Some(value) = Some(42) else {
        panic!("æ— å€¼");
    };
    println!("å€¼: {}", value);
    
    // å¤æ‚æ¨¡å¼
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    
    let Ok(number) = Result::Ok(100) else {
        eprintln!("é”™è¯¯");
        return;
    };
    println!("æ•°å­—: {}", number);
}
```

### if-let ä¸ while-let

```rust
fn main() {
    // if-let é“¾
    let value = Some(Some(42));
    
    if let Some(inner) = value {
        if let Some(num) = inner {
            println!("åµŒå¥—å€¼: {}", num);
        }
    }
    
    // while-let è¿­ä»£
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("å¼¹å‡º: {}", top);
    }
    
    // if-let å®ˆå«
    let data = Some(50);
    if let Some(n) = data {
        if n > 40 {
            println!("å¤§å€¼: {}", n);
        }
    }
}
```

### å‡½æ•°å‚æ•°æ¨¡å¼

```rust
// å…ƒç»„è§£æ„å‚æ•°
fn print_coords(&(x, y): &(i32, i32)) {
    println!("åæ ‡: ({}, {})", x, y);
}

// ç»“æ„ä½“è§£æ„å‚æ•°
struct Point {
    x: i32,
    y: i32,
}

fn distance(Point { x: x1, y: y1 }: Point, Point { x: x2, y: y2 }: Point) -> f64 {
    (((x2 - x1).pow(2) + (y2 - y1).pow(2)) as f64).sqrt()
}

fn main() {
    print_coords(&(10, 20));
    
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 3, y: 4 };
    println!("è·ç¦»: {}", distance(p1, p2));
}
```

---

## 7. å®ä¸æ¨¡å¼

### ä½¿ç”¨å®ç”Ÿæˆæ¨¡å¼

```rust
macro_rules! match_pair {
    ($val:expr, $($pattern:pat => $result:expr),*) => {
        match $val {
            $($pattern => $result,)*
        }
    };
}

fn main() {
    let value = 5;
    
    let result = match_pair!(value,
        1 => "one",
        2 => "two",
        3 => "three",
        _ => "other"
    );
    
    println!("ç»“æœ: {}", result);
}
```

### æ¨¡å¼åŒ¹é…å®

```rust
macro_rules! extract {
    ($opt:expr, Some($val:ident)) => {
        if let Some($val) = $opt {
            $val
        } else {
            panic!("Noneå€¼");
        }
    };
    ($res:expr, Ok($val:ident)) => {
        match $res {
            Ok($val) => $val,
            Err(e) => panic!("é”™è¯¯: {:?}", e),
        }
    };
}

fn main() {
    let opt = Some(42);
    let value = extract!(opt, Some(v));
    println!("æå–å€¼: {}", value);
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### é¿å…ä¸å¿…è¦çš„å…‹éš†

```rust
fn main() {
    let data = vec![String::from("hello"), String::from("world")];
    
    // âŒ ä¸å¥½ï¼šå…‹éš†
    for item in &data {
        let s = item.clone();
        println!("{}", s);
    }
    
    // âœ… å¥½ï¼šä½¿ç”¨å¼•ç”¨
    for item in &data {
        println!("{}", item);
    }
    
    // âœ… å¥½ï¼šæ¨¡å¼åŒ¹é…å¼•ç”¨
    match data.first() {
        Some(first) => println!("é¦–å…ƒç´ : {}", first),
        None => {},
    }
}
```

### ç©·å°½æ€§ä¸ä¼˜åŒ–

```rust
fn main() {
    // ç¼–è¯‘å™¨ä¼˜åŒ–ï¼šç©·å°½æ€§å·²çŸ¥
    let value = Some(42);
    let result = match value {
        Some(x) => x,
        None => 0,
    };
    
    // vs ä½¿ç”¨unwrap_orï¼ˆç›¸åŒæ€§èƒ½ï¼‰
    let result2 = value.unwrap_or(0);
    
    assert_eq!(result, result2);
}
```

### å¤§å‹æšä¸¾ä¼˜åŒ–

```rust
enum Large {
    Small(u8),
    Big(Box<[u8; 1000]>),  // ä½¿ç”¨Boxé¿å…æ ˆæº¢å‡º
}

fn main() {
    let value = Large::Big(Box::new([0; 1000]));
    
    match value {
        Large::Small(x) => println!("å°: {}", x),
        Large::Big(ref data) => println!("å¤§: {} å­—èŠ‚", data.len()),
    }
}
```

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ”¥ æŒæ¡é«˜çº§æ¨¡å¼åŒ¹é…ï¼Œç¼–å†™æ›´ä¼˜é›…çš„Rustä»£ç ï¼** ğŸ¦€âœ¨
