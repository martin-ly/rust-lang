# 4.1 高级模式匹配

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 深入探讨Rust模式匹配的高级技巧和最佳实践  
> **适用对象**: 需要掌握复杂模式匹配的高级开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [模式匹配指南](../tier_02_guides/04_模式匹配指南.md)

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [4.1 高级模式匹配](#41-高级模式匹配)
  - [📋 目录](#-目录)
  - [1. 复杂嵌套模式](#1-复杂嵌套模式)
    - [深度嵌套解构](#深度嵌套解构)
    - [组合结构体与枚举](#组合结构体与枚举)
  - [2. 守卫与绑定](#2-守卫与绑定)
    - [复杂守卫表达式](#复杂守卫表达式)
    - [@ 绑定高级用法](#-绑定高级用法)
    - [多重绑定](#多重绑定)
  - [3. 切片模式](#3-切片模式)
    - [基本切片匹配](#基本切片匹配)
    - [复杂切片模式](#复杂切片模式)
    - [字符串切片模式](#字符串切片模式)
  - [4. 或模式与范围](#4-或模式与范围)
    - [复杂或模式](#复杂或模式)
    - [范围模式技巧](#范围模式技巧)
    - [或模式与守卫](#或模式与守卫)
  - [5. 引用模式](#5-引用模式)
    - [ref 与 ref mut](#ref-与-ref-mut)
    - [解引用模式](#解引用模式)
    - [引用与所有权](#引用与所有权)
  - [6. 结构化绑定](#6-结构化绑定)
    - [let-else 模式](#let-else-模式)
    - [if-let 与 while-let](#if-let-与-while-let)
    - [函数参数模式](#函数参数模式)
  - [7. 宏与模式](#7-宏与模式)
    - [使用宏生成模式](#使用宏生成模式)
    - [模式匹配宏](#模式匹配宏)
  - [8. 性能优化](#8-性能优化)
    - [避免不必要的克隆](#避免不必要的克隆)
    - [穷尽性与优化](#穷尽性与优化)
    - [大型枚举优化](#大型枚举优化)

---

## 1. 复杂嵌套模式

### 深度嵌套解构

```rust
#[derive(Debug)]
enum Message {
    Move { x: i32, y: i32 },
    Echo(String),
    ChangeColor(i32, i32, i32),
    Quit,
}

#[derive(Debug)]
struct State {
    position: (i32, i32),
    message: Option<Message>,
    history: Vec<String>,
}

fn main() {
    let state = State {
        position: (10, 20),
        message: Some(Message::Move { x: 5, y: 15 }),
        history: vec!["start".to_string(), "moving".to_string()],
    };
    
    // 多层嵌套解构
    match state {
        State {
            position: (x, y),
            message: Some(Message::Move { x: mx, y: my }),
            history,
        } if x + mx == 15 => {
            println!("目标位置: ({}, {})", x + mx, y + my);
            println!("历史: {:?}", history);
        },
        State {
            message: Some(Message::Echo(ref msg)),
            ..
        } => {
            println!("回显: {}", msg);
        },
        _ => println!("其他情况"),
    }
}
```

### 组合结构体与枚举

```rust
struct Point {
    x: i32,
    y: i32,
}

enum Shape {
    Circle { center: Point, radius: f64 },
    Rectangle { top_left: Point, bottom_right: Point },
    Triangle(Point, Point, Point),
}

fn analyze_shape(shape: &Shape) {
    match shape {
        // 嵌套结构体解构
        Shape::Circle { 
            center: Point { x, y }, 
            radius 
        } if *radius > 10.0 => {
            println!("大圆: 中心({}, {}), 半径{}", x, y, radius);
        },
        
        // 多个绑定
        Shape::Rectangle { 
            top_left: Point { x: x1, y: y1 },
            bottom_right: Point { x: x2, y: y2 }
        } if x2 - x1 == y2 - y1 => {
            println!("正方形: 边长{}", x2 - x1);
        },
        
        // 元组变体解构
        Shape::Triangle(
            Point { x: x1, .. },
            Point { x: x2, .. },
            Point { x: x3, .. }
        ) if x1 == x2 && x2 == x3 => {
            println!("垂直三角形");
        },
        
        _ => println!("其他形状"),
    }
}

fn main() {
    let circle = Shape::Circle {
        center: Point { x: 0, y: 0 },
        radius: 15.0,
    };
    analyze_shape(&circle);
}
```

---

## 2. 守卫与绑定

### 复杂守卫表达式

```rust
fn main() {
    let pair = (2, -2);
    
    // 守卫中的复杂逻辑
    match pair {
        (x, y) if x == y => println!("相等"),
        (x, y) if x + y == 0 => println!("互为相反数"),
        (x, y) if x * y > 0 => println!("同号"),
        (x, y) if x.abs() == y.abs() => println!("绝对值相等"),
        _ => println!("其他情况"),
    }
    
    // 守卫中调用函数
    fn is_prime(n: i32) -> bool {
        if n < 2 { return false; }
        (2..n).all(|i| n % i != 0)
    }
    
    let numbers = vec![2, 3, 4, 5, 6, 7];
    for &n in &numbers {
        match n {
            x if is_prime(x) => println!("{} 是质数", x),
            x => println!("{} 不是质数", x),
        }
    }
}
```

### @ 绑定高级用法

```rust
fn main() {
    // @ 与范围组合
    let age = 25;
    match age {
        n @ 0..=12 => println!("儿童: {}", n),
        n @ 13..=17 => println!("青少年: {}", n),
        n @ 18..=59 => println!("成年人: {}", n),
        n @ 60.. => println!("老年人: {}", n),
    }
    
    // @ 与守卫组合
    let value = Some(42);
    match value {
        Some(n @ 0..=50) if n % 2 == 0 => {
            println!("小偶数: {}", n);
        },
        Some(n @ 51..) if n % 2 == 0 => {
            println!("大偶数: {}", n);
        },
        Some(n) => println!("奇数: {}", n),
        None => println!("无值"),
    }
    
    // @ 与或模式
    enum Status {
        Active,
        Pending,
        Inactive,
    }
    
    let status = Status::Active;
    match status {
        s @ (Status::Active | Status::Pending) => {
            println!("活动状态: {:?}", s);
        },
        Status::Inactive => println!("非活动"),
    }
}
```

### 多重绑定

```rust
struct Wrapper<T> {
    value: T,
}

fn main() {
    let nested = Wrapper {
        value: Wrapper {
            value: 42,
        },
    };
    
    // 多层 @ 绑定
    match nested {
        Wrapper { 
            value: inner @ Wrapper { value: num }
        } if num > 40 => {
            println!("内层: {:?}, 值: {}", inner.value, num);
        },
        _ => println!("其他"),
    }
    
    // 元组多重绑定
    let tuple = ((1, 2), (3, 4));
    match tuple {
        pair @ ((x, _), (_, y)) if x + y == 5 => {
            println!("配对: {:?}, x={}, y={}", pair, x, y);
        },
        _ => println!("不匹配"),
    }
}
```

---

## 3. 切片模式

### 基本切片匹配

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];
    
    // 固定长度匹配
    match &numbers[..] {
        [first, second, ..] => {
            println!("前两个: {}, {}", first, second);
        },
        _ => unreachable!(),
    }
    
    // 精确匹配
    match &numbers[..] {
        [1, 2, 3, 4, 5] => println!("精确匹配"),
        _ => println!("不匹配"),
    }
    
    // 中间元素
    match &numbers[..] {
        [first, .., last] => {
            println!("首尾: {}, {}", first, last);
        },
        _ => unreachable!(),
    }
}
```

### 复杂切片模式

```rust
fn analyze_sequence(seq: &[i32]) {
    match seq {
        // 空序列
        [] => println!("空序列"),
        
        // 单元素
        [x] => println!("单元素: {}", x),
        
        // 两元素
        [x, y] => println!("两元素: {}, {}", x, y),
        
        // 首尾模式
        [first, .., last] if first == last => {
            println!("首尾相同: {}", first);
        },
        
        // 递增序列检测
        [first, rest @ ..] if rest.iter().all(|&x| x > *first) => {
            println!("递增序列");
        },
        
        // 特定模式
        [1, 2, rest @ ..] => {
            println!("以1,2开头，后续: {:?}", rest);
        },
        
        _ => println!("其他模式"),
    }
}

fn main() {
    analyze_sequence(&[]);
    analyze_sequence(&[42]);
    analyze_sequence(&[1, 2, 3, 4, 5]);
    analyze_sequence(&[5, 4, 3, 2, 1]);
}
```

### 字符串切片模式

```rust
fn parse_command(input: &str) {
    match input.split_whitespace().collect::<Vec<_>>().as_slice() {
        ["get", key] => {
            println!("获取键: {}", key);
        },
        ["set", key, value] => {
            println!("设置 {} = {}", key, value);
        },
        ["delete", keys @ ..] => {
            println!("删除键: {:?}", keys);
        },
        _ => println!("未知命令"),
    }
}

fn main() {
    parse_command("get name");
    parse_command("set age 30");
    parse_command("delete id name email");
}
```

---

## 4. 或模式与范围

### 复杂或模式

```rust
fn main() {
    // 多值或模式
    let digit = '7';
    match digit {
        '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => {
            println!("数字字符");
        },
        _ => println!("非数字"),
    }
    
    // 嵌套或模式
    enum Color {
        RGB(u8, u8, u8),
        HSV(f32, f32, f32),
    }
    
    let color = Color::RGB(255, 0, 0);
    match color {
        Color::RGB(255, 0, 0) | Color::RGB(0, 255, 0) | Color::RGB(0, 0, 255) => {
            println!("纯色");
        },
        Color::RGB(r, g, b) if r == g && g == b => {
            println!("灰度");
        },
        _ => println!("其他颜色"),
    }
}
```

### 范围模式技巧

```rust
fn main() {
    // 字符范围
    let ch = 'k';
    match ch {
        'a'..='z' => println!("小写字母"),
        'A'..='Z' => println!("大写字母"),
        '0'..='9' => println!("数字"),
        _ => println!("其他字符"),
    }
    
    // 数值范围组合
    let score = 85;
    match score {
        90..=100 => println!("优秀"),
        80..=89 => println!("良好"),
        70..=79 => println!("中等"),
        60..=69 => println!("及格"),
        0..=59 => println!("不及格"),
        _ => println!("无效分数"),
    }
    
    // 开放范围
    let value = 1000;
    match value {
        0..=100 => println!("小"),
        101..=500 => println!("中"),
        501.. => println!("大"),
    }
}
```

### 或模式与守卫

```rust
fn main() {
    let point = (3, 4);
    
    // 或模式 + 守卫
    match point {
        (x, 0) | (0, x) if x > 0 => {
            println!("坐标轴上的正值点: {}", x);
        },
        (x, y) if x == y => {
            println!("对角线上的点");
        },
        (x, y) if x.abs() == y.abs() => {
            println!("副对角线上的点");
        },
        _ => println!("其他点"),
    }
}
```

---

## 5. 引用模式

### ref 与 ref mut

```rust
fn main() {
    let mut data = vec![1, 2, 3];
    
    // ref 获取不可变引用
    match data.first() {
        Some(ref first) => {
            println!("首元素引用: {}", first);
            // first 的类型是 &i32
        },
        None => println!("空"),
    }
    
    // ref mut 获取可变引用
    match data.first_mut() {
        Some(ref mut first) => {
            *first += 10;
            println!("修改后: {}", first);
        },
        None => println!("空"),
    }
    
    println!("数据: {:?}", data);
}
```

### 解引用模式

```rust
fn main() {
    let reference = &42;
    
    // & 模式自动解引用
    match reference {
        &val => println!("值: {}", val),
    }
    
    // 嵌套引用
    let double_ref = &&42;
    match double_ref {
        &&val => println!("双重解引用: {}", val),
    }
    
    // 复杂解引用
    struct Wrapper(i32);
    let wrapped = &Wrapper(100);
    
    match wrapped {
        &Wrapper(value) => println!("解包: {}", value),
    }
}
```

### 引用与所有权

```rust
fn main() {
    let s = String::from("hello");
    
    // 使用 ref 避免移动
    match Some(s) {
        Some(ref inner) => {
            println!("引用: {}", inner);
            // s 的所有权未被移动
        },
        None => {},
    }
    
    // 可以继续使用 s
    // println!("{}", s);  // 错误：s已被移动
    
    // 正确方式：使用引用
    let s = String::from("world");
    match Some(&s) {
        Some(inner) => {
            println!("引用: {}", inner);
        },
        None => {},
    }
    println!("{}", s);  // OK
}
```

---

## 6. 结构化绑定

### let-else 模式

```rust
fn main() {
    // 基本 let-else
    let Some(value) = Some(42) else {
        panic!("无值");
    };
    println!("值: {}", value);
    
    // 复杂模式
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    
    let Ok(number) = Result::Ok(100) else {
        eprintln!("错误");
        return;
    };
    println!("数字: {}", number);
}
```

### if-let 与 while-let

```rust
fn main() {
    // if-let 链
    let value = Some(Some(42));
    
    if let Some(inner) = value {
        if let Some(num) = inner {
            println!("嵌套值: {}", num);
        }
    }
    
    // while-let 迭代
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("弹出: {}", top);
    }
    
    // if-let 守卫
    let data = Some(50);
    if let Some(n) = data {
        if n > 40 {
            println!("大值: {}", n);
        }
    }
}
```

### 函数参数模式

```rust
// 元组解构参数
fn print_coords(&(x, y): &(i32, i32)) {
    println!("坐标: ({}, {})", x, y);
}

// 结构体解构参数
struct Point {
    x: i32,
    y: i32,
}

fn distance(Point { x: x1, y: y1 }: Point, Point { x: x2, y: y2 }: Point) -> f64 {
    (((x2 - x1).pow(2) + (y2 - y1).pow(2)) as f64).sqrt()
}

fn main() {
    print_coords(&(10, 20));
    
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 3, y: 4 };
    println!("距离: {}", distance(p1, p2));
}
```

---

## 7. 宏与模式

### 使用宏生成模式

```rust
macro_rules! match_pair {
    ($val:expr, $($pattern:pat => $result:expr),*) => {
        match $val {
            $($pattern => $result,)*
        }
    };
}

fn main() {
    let value = 5;
    
    let result = match_pair!(value,
        1 => "one",
        2 => "two",
        3 => "three",
        _ => "other"
    );
    
    println!("结果: {}", result);
}
```

### 模式匹配宏

```rust
macro_rules! extract {
    ($opt:expr, Some($val:ident)) => {
        if let Some($val) = $opt {
            $val
        } else {
            panic!("None值");
        }
    };
    ($res:expr, Ok($val:ident)) => {
        match $res {
            Ok($val) => $val,
            Err(e) => panic!("错误: {:?}", e),
        }
    };
}

fn main() {
    let opt = Some(42);
    let value = extract!(opt, Some(v));
    println!("提取值: {}", value);
}
```

---

## 8. 性能优化

### 避免不必要的克隆

```rust
fn main() {
    let data = vec![String::from("hello"), String::from("world")];
    
    // ❌ 不好：克隆
    for item in &data {
        let s = item.clone();
        println!("{}", s);
    }
    
    // ✅ 好：使用引用
    for item in &data {
        println!("{}", item);
    }
    
    // ✅ 好：模式匹配引用
    match data.first() {
        Some(first) => println!("首元素: {}", first),
        None => {},
    }
}
```

### 穷尽性与优化

```rust
fn main() {
    // 编译器优化：穷尽性已知
    let value = Some(42);
    let result = match value {
        Some(x) => x,
        None => 0,
    };
    
    // vs 使用unwrap_or（相同性能）
    let result2 = value.unwrap_or(0);
    
    assert_eq!(result, result2);
}
```

### 大型枚举优化

```rust
enum Large {
    Small(u8),
    Big(Box<[u8; 1000]>),  // 使用Box避免栈溢出
}

fn main() {
    let value = Large::Big(Box::new([0; 1000]));
    
    match value {
        Large::Small(x) => println!("小: {}", x),
        Large::Big(ref data) => println!("大: {} 字节", data.len()),
    }
}
```

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🔥 掌握高级模式匹配，编写更优雅的Rust代码！** 🦀✨
