# 4.2 é—­åŒ…æ·±å…¥

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: æ·±å…¥æ¢è®¨Rusté—­åŒ…çš„å†…éƒ¨æœºåˆ¶å’Œé«˜çº§åº”ç”¨  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æ·±å…¥ç†è§£é—­åŒ…å®ç°çš„é«˜çº§å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [å‡½æ•°ç³»ç»ŸæŒ‡å—](../tier_02_guides/03_å‡½æ•°ç³»ç»ŸæŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [4.2 é—­åŒ…æ·±å…¥](#42-é—­åŒ…æ·±å…¥)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. é—­åŒ…çš„å†…éƒ¨è¡¨ç¤º](#1-é—­åŒ…çš„å†…éƒ¨è¡¨ç¤º)
    - [ç¼–è¯‘å™¨å¦‚ä½•å¤„ç†é—­åŒ…](#ç¼–è¯‘å™¨å¦‚ä½•å¤„ç†é—­åŒ…)
    - [é›¶å¤§å°é—­åŒ…](#é›¶å¤§å°é—­åŒ…)
    - [æ•è·å¤§å°åˆ†æ](#æ•è·å¤§å°åˆ†æ)
  - [2. é«˜é˜¶å‡½æ•°æ¨¡å¼](#2-é«˜é˜¶å‡½æ•°æ¨¡å¼)
    - [é—­åŒ…ä½œä¸ºè¿”å›å€¼](#é—­åŒ…ä½œä¸ºè¿”å›å€¼)
    - [é—­åŒ…ç»„åˆå­](#é—­åŒ…ç»„åˆå­)
    - [æŸ¯é‡ŒåŒ–](#æŸ¯é‡ŒåŒ–)
  - [3. é—­åŒ…ä¸ç”Ÿå‘½å‘¨æœŸ](#3-é—­åŒ…ä¸ç”Ÿå‘½å‘¨æœŸ)
    - [å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯](#å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯)
    - [HRTBï¼ˆé«˜é˜¶traitè¾¹ç•Œï¼‰](#hrtbé«˜é˜¶traitè¾¹ç•Œ)
    - [é—­åŒ…è¿”å›å¼•ç”¨](#é—­åŒ…è¿”å›å¼•ç”¨)
  - [4. é—­åŒ…traitå¯¹è±¡](#4-é—­åŒ…traitå¯¹è±¡)
    - [åŠ¨æ€åˆ†å‘](#åŠ¨æ€åˆ†å‘)
    - [traitå¯¹è±¡ç”Ÿå‘½å‘¨æœŸ](#traitå¯¹è±¡ç”Ÿå‘½å‘¨æœŸ)
  - [5. æ•è·ç­–ç•¥ä¼˜åŒ–](#5-æ•è·ç­–ç•¥ä¼˜åŒ–)
    - [æœ€å°åŒ–æ•è·](#æœ€å°åŒ–æ•è·)
    - [Clone vs Move](#clone-vs-move)
  - [6. é€’å½’é—­åŒ…](#6-é€’å½’é—­åŒ…)
    - [ä½¿ç”¨ Box](#ä½¿ç”¨-box)
    - [Yç»„åˆå­](#yç»„åˆå­)
  - [7. å¼‚æ­¥é—­åŒ…](#7-å¼‚æ­¥é—­åŒ…)
    - [async é—­åŒ…åŸºç¡€](#async-é—­åŒ…åŸºç¡€)
    - [async move ä¸ç”Ÿå‘½å‘¨æœŸ](#async-move-ä¸ç”Ÿå‘½å‘¨æœŸ)
  - [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
    - [äº‹ä»¶å¤„ç†ç³»ç»Ÿ](#äº‹ä»¶å¤„ç†ç³»ç»Ÿ)
    - [æƒ°æ€§æ±‚å€¼](#æƒ°æ€§æ±‚å€¼)
    - [å‡½æ•°ç¼“å­˜ï¼ˆMemoizationï¼‰](#å‡½æ•°ç¼“å­˜memoization)

---

## 1. é—­åŒ…çš„å†…éƒ¨è¡¨ç¤º

### ç¼–è¯‘å™¨å¦‚ä½•å¤„ç†é—­åŒ…

```rust
fn main() {
    let x = 10;
    let y = 20;
    
    // é—­åŒ…å®šä¹‰
    let closure = |z| x + y + z;
    
    // ç¼–è¯‘å™¨å¤§è‡´ç”Ÿæˆç±»ä¼¼ä»¥ä¸‹ç»“æ„ï¼š
    struct ClosureEnv {
        x: i32,
        y: i32,
    }
    
    impl FnOnce<(i32,)> for ClosureEnv {
        type Output = i32;
        fn call_once(self, args: (i32,)) -> i32 {
            self.x + self.y + args.0
        }
    }
    
    impl FnMut<(i32,)> for ClosureEnv {
        fn call_mut(&mut self, args: (i32,)) -> i32 {
            self.x + self.y + args.0
        }
    }
    
    impl Fn<(i32,)> for ClosureEnv {
        fn call(&self, args: (i32,)) -> i32 {
            self.x + self.y + args.0
        }
    }
    
    println!("{}", closure(5));  // 35
}
```

### é›¶å¤§å°é—­åŒ…

```rust
fn main() {
    // ä¸æ•è·ä»»ä½•å˜é‡çš„é—­åŒ…æ˜¯é›¶å¤§å°ç±»å‹
    let no_capture = || 42;
    
    // ç­‰ä»·äºå‡½æ•°æŒ‡é’ˆ
    fn function() -> i32 { 42 }
    
    // ä¸¤è€…æ€§èƒ½ç›¸åŒï¼Œéƒ½æ˜¯é›¶æˆæœ¬
    assert_eq!(std::mem::size_of_val(&no_capture), 0);
    
    // å¯ä»¥å¼ºåˆ¶è½¬æ¢ä¸ºå‡½æ•°æŒ‡é’ˆ
    let fn_ptr: fn() -> i32 = no_capture;
    println!("{}", fn_ptr());
}
```

### æ•è·å¤§å°åˆ†æ

```rust
fn main() {
    let a = 1u8;
    let b = 2u16;
    let c = 3u32;
    
    // é—­åŒ…å¤§å° = æ•è·å˜é‡å¤§å°ä¹‹å’Œï¼ˆå¯èƒ½æœ‰å¯¹é½ï¼‰
    let closure = || (a, b, c);
    
    println!("é—­åŒ…å¤§å°: {}", std::mem::size_of_val(&closure));
    // è¾“å‡º: 8 (1 + 2 + 4 + padding)
    
    // moveåçš„å¤§å°
    let moved = move || (a, b, c);
    println!("moveé—­åŒ…å¤§å°: {}", std::mem::size_of_val(&moved));
    // ç›¸åŒå¤§å°ï¼Œå› ä¸º u8/u16/u32 éƒ½æ˜¯ Copy
}
```

---

## 2. é«˜é˜¶å‡½æ•°æ¨¡å¼

### é—­åŒ…ä½œä¸ºè¿”å›å€¼

```rust
// è¿”å›é—­åŒ…ï¼šä½¿ç”¨ impl Trait
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}

// è¿”å›ä¸åŒç±»å‹çš„é—­åŒ…ï¼šä½¿ç”¨ Box
fn make_operation(op: &str) -> Box<dyn Fn(i32, i32) -> i32> {
    match op {
        "add" => Box::new(|a, b| a + b),
        "mul" => Box::new(|a, b| a * b),
        "sub" => Box::new(|a, b| a - b),
        _ => Box::new(|a, b| a / b),
    }
}

fn main() {
    let add_5 = make_adder(5);
    println!("{}", add_5(10));  // 15
    
    let op = make_operation("mul");
    println!("{}", op(3, 4));  // 12
}
```

### é—­åŒ…ç»„åˆå­

```rust
fn compose<A, B, C, F, G>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

fn main() {
    let add_one = |x: i32| x + 1;
    let double = |x: i32| x * 2;
    
    // å…ˆåŠ 1ï¼Œå†ä¹˜2
    let combined = compose(add_one, double);
    println!("{}", combined(5));  // 12
    
    // é“¾å¼ç»„åˆ
    let triple = compose(double, |x| x + x / 2);
    println!("{}", triple(10));  // 30
}
```

### æŸ¯é‡ŒåŒ–

```rust
fn curry<A, B, C, F>(f: F) -> impl Fn(A) -> Box<dyn Fn(B) -> C>
where
    F: Fn(A, B) -> C + 'static,
    A: 'static,
    B: 'static,
    C: 'static,
{
    move |a| {
        let f = f.clone();
        Box::new(move |b| f(a, b))
    }
}

fn main() {
    let add = |x: i32, y: i32| x + y;
    
    // ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œå› ä¸ºéœ€è¦ Clone
    // ä½¿ç”¨ Rc æ¥å…±äº«
    use std::rc::Rc;
    let add_rc = Rc::new(add);
    
    let add_5 = {
        let add_rc = add_rc.clone();
        move |y| add_rc(5, y)
    };
    
    println!("{}", add_5(10));  // 15
}
```

---

## 3. é—­åŒ…ä¸ç”Ÿå‘½å‘¨æœŸ

### å¤æ‚ç”Ÿå‘½å‘¨æœŸåœºæ™¯

```rust
fn make_closure<'a>(s: &'a str) -> impl Fn() + 'a {
    move || println!("{}", s)
}

fn make_closure_boxed<'a>(s: &'a str) -> Box<dyn Fn() + 'a> {
    Box::new(move || println!("{}", s))
}

fn main() {
    let text = String::from("hello");
    
    let closure = make_closure(&text);
    closure();
    
    let boxed = make_closure_boxed(&text);
    boxed();
    
    // text ä»ç„¶æœ‰æ•ˆ
    println!("{}", text);
}
```

### HRTBï¼ˆé«˜é˜¶traitè¾¹ç•Œï¼‰

```rust
fn apply<F>(f: F)
where
    F: for<'a> Fn(&'a str) -> &'a str,
{
    let s = String::from("hello");
    let result = f(&s);
    println!("{}", result);
}

fn main() {
    // æ¥å—ä»»æ„ç”Ÿå‘½å‘¨æœŸçš„ &str
    apply(|s| {
        if s.len() > 3 {
            &s[..3]
        } else {
            s
        }
    });
}
```

### é—­åŒ…è¿”å›å¼•ç”¨

```rust
fn make_ref_closure<'a>(data: &'a [i32]) -> impl Fn(usize) -> &'a i32 {
    move |index| &data[index]
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let getter = make_ref_closure(&numbers);
    
    println!("{}", getter(2));  // 3
    println!("{}", getter(4));  // 5
}
```

---

## 4. é—­åŒ…traitå¯¹è±¡

### åŠ¨æ€åˆ†å‘

```rust
fn main() {
    let closures: Vec<Box<dyn Fn(i32) -> i32>> = vec![
        Box::new(|x| x + 1),
        Box::new(|x| x * 2),
        Box::new(|x| x * x),
    ];
    
    for (i, closure) in closures.iter().enumerate() {
        println!("é—­åŒ… {}: {}", i, closure(5));
    }
}
```

### traitå¯¹è±¡ç”Ÿå‘½å‘¨æœŸ

```rust
struct Processor<'a> {
    callbacks: Vec<Box<dyn Fn(&str) + 'a>>,
}

impl<'a> Processor<'a> {
    fn new() -> Self {
        Processor {
            callbacks: Vec::new(),
        }
    }
    
    fn add_callback<F>(&mut self, f: F)
    where
        F: Fn(&str) + 'a,
    {
        self.callbacks.push(Box::new(f));
    }
    
    fn process(&self, data: &str) {
        for callback in &self.callbacks {
            callback(data);
        }
    }
}

fn main() {
    let mut processor = Processor::new();
    
    let prefix = String::from("LOG:");
    processor.add_callback(move |msg| {
        println!("{} {}", prefix, msg);
    });
    
    processor.add_callback(|msg| {
        println!("é•¿åº¦: {}", msg.len());
    });
    
    processor.process("æµ‹è¯•æ¶ˆæ¯");
}
```

---

## 5. æ•è·ç­–ç•¥ä¼˜åŒ–

### æœ€å°åŒ–æ•è·

```rust
fn main() {
    struct Data {
        id: u32,
        name: String,
        value: i32,
    }
    
    let data = Data {
        id: 1,
        name: String::from("test"),
        value: 42,
    };
    
    // âŒ æ•è·æ•´ä¸ªç»“æ„ä½“
    let closure_bad = || {
        println!("{}", data.value);
        // data çš„æ‰€æœ‰å­—æ®µéƒ½è¢«æ•è·
    };
    
    // âœ… åªæ•è·éœ€è¦çš„å­—æ®µ
    let value = data.value;
    let closure_good = || {
        println!("{}", value);
        // åªæ•è· i32
    };
    
    // data.name ä»å¯ä»¥ä½¿ç”¨
    println!("{}", data.name);
}
```

### Clone vs Move

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // âŒ ä¸å¥½ï¼šç§»åŠ¨æ•´ä¸ª Vec
    let closure1 = move || {
        println!("{:?}", data);
    };
    // data ä¸å¯å†ç”¨
    
    // âœ… å¥½ï¼šå…‹éš†åç§»åŠ¨
    let data = vec![1, 2, 3, 4, 5];
    let data_clone = data.clone();
    let closure2 = move || {
        println!("{:?}", data_clone);
    };
    // data ä»å¯ç”¨
    println!("{:?}", data);
}
```

---

## 6. é€’å½’é—­åŒ…

### ä½¿ç”¨ Box

```rust
fn main() {
    // é€’å½’é—­åŒ…éœ€è¦ç±»å‹æ³¨è§£
    let factorial: Box<dyn Fn(u64) -> u64> = Box::new(|n| {
        if n == 0 {
            1
        } else {
            // é”™è¯¯ï¼šé—­åŒ…æ— æ³•è°ƒç”¨è‡ªèº«
            // n * factorial(n - 1)
            0  // å ä½
        }
    });
    
    // éœ€è¦ä½¿ç”¨ Rc å’Œ RefCell
    use std::rc::Rc;
    use std::cell::RefCell;
    
    let factorial = Rc::new(RefCell::new(None));
    let factorial_clone = factorial.clone();
    
    *factorial.borrow_mut() = Some(Box::new(move |n: u64| -> u64 {
        if n == 0 {
            1
        } else {
            let f = factorial_clone.borrow();
            let f = f.as_ref().unwrap();
            n * f(n - 1)
        }
    }) as Box<dyn Fn(u64) -> u64>);
    
    let f = factorial.borrow();
    let f = f.as_ref().unwrap();
    println!("5! = {}", f(5));  // 120
}
```

### Yç»„åˆå­

```rust
// Yç»„åˆå­çš„ Rust å®ç°
fn fix<A, R, F>(f: F) -> impl Fn(A) -> R
where
    F: Fn(&dyn Fn(A) -> R, A) -> R,
    A: 'static,
    R: 'static,
{
    use std::rc::Rc;
    
    let rc = Rc::new(f);
    let rc_clone = rc.clone();
    
    move |a| {
        let g: Box<dyn Fn(A) -> R> = Box::new({
            let rc = rc_clone.clone();
            move |a| {
                let rc = rc.clone();
                rc(&*Box::new(move |a| g(a)), a)
            }
        });
        rc(&*g, a)
    }
}

fn main() {
    let factorial = fix(|f, n: u64| {
        if n == 0 {
            1
        } else {
            n * f(n - 1)
        }
    });
    
    println!("5! = {}", factorial(5));
}
```

---

## 7. å¼‚æ­¥é—­åŒ…

### async é—­åŒ…åŸºç¡€

```rust
async fn process_async() {
    println!("å¼‚æ­¥å¤„ç†");
}

fn main() {
    // async é—­åŒ…ï¼ˆéœ€è¦è¿è¡Œæ—¶ï¼‰
    let async_closure = async || {
        println!("å¼‚æ­¥é—­åŒ…");
        42
    };
    
    // éœ€è¦ runtime æ‰èƒ½æ‰§è¡Œ
    // let result = async_closure().await;
    
    println!("å¼‚æ­¥é—­åŒ…ç¤ºä¾‹ï¼ˆéœ€è¦è¿è¡Œæ—¶æ‰§è¡Œï¼‰");
}
```

### async move ä¸ç”Ÿå‘½å‘¨æœŸ

```rust
fn spawn_task(data: String) -> impl std::future::Future<Output = ()> {
    // ä½¿ç”¨ async move æ•è·æ‰€æœ‰æƒ
    async move {
        println!("å¤„ç†: {}", data);
    }
}

fn main() {
    let data = String::from("test");
    let future = spawn_task(data);
    // data å·²è¢«ç§»åŠ¨
    
    // éœ€è¦è¿è¡Œæ—¶æ‰§è¡Œ
    // runtime.block_on(future);
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### äº‹ä»¶å¤„ç†ç³»ç»Ÿ

```rust
struct EventHandler {
    handlers: Vec<Box<dyn Fn(&str)>>,
}

impl EventHandler {
    fn new() -> Self {
        EventHandler {
            handlers: Vec::new(),
        }
    }
    
    fn on<F>(&mut self, handler: F)
    where
        F: Fn(&str) + 'static,
    {
        self.handlers.push(Box::new(handler));
    }
    
    fn emit(&self, event: &str) {
        for handler in &self.handlers {
            handler(event);
        }
    }
}

fn main() {
    let mut eh = EventHandler::new();
    
    let mut count = 0;
    eh.on(move |event| {
        count += 1;
        println!("å¤„ç†å™¨1: {} (æ¬¡æ•°: {})", event, count);
    });
    
    eh.on(|event| {
        println!("å¤„ç†å™¨2: {}", event);
    });
    
    eh.emit("click");
    eh.emit("hover");
}
```

### æƒ°æ€§æ±‚å€¼

```rust
struct Lazy<T, F>
where
    F: FnOnce() -> T,
{
    value: Option<T>,
    init: Option<F>,
}

impl<T, F> Lazy<T, F>
where
    F: FnOnce() -> T,
{
    fn new(f: F) -> Self {
        Lazy {
            value: None,
            init: Some(f),
        }
    }
    
    fn get(&mut self) -> &T {
        if self.value.is_none() {
            let init = self.init.take().unwrap();
            self.value = Some(init());
        }
        self.value.as_ref().unwrap()
    }
}

fn main() {
    let mut lazy = Lazy::new(|| {
        println!("è®¡ç®—ä¸­...");
        42
    });
    
    println!("åˆ›å»ºå®Œæˆ");
    println!("å€¼: {}", lazy.get());  // è§¦å‘è®¡ç®—
    println!("å€¼: {}", lazy.get());  // ä½¿ç”¨ç¼“å­˜
}
```

### å‡½æ•°ç¼“å­˜ï¼ˆMemoizationï¼‰

```rust
use std::collections::HashMap;

struct Memoized<F, A, R>
where
    F: FnMut(A) -> R,
    A: Eq + std::hash::Hash + Clone,
    R: Clone,
{
    func: F,
    cache: HashMap<A, R>,
}

impl<F, A, R> Memoized<F, A, R>
where
    F: FnMut(A) -> R,
    A: Eq + std::hash::Hash + Clone,
    R: Clone,
{
    fn new(func: F) -> Self {
        Memoized {
            func,
            cache: HashMap::new(),
        }
    }
    
    fn call(&mut self, arg: A) -> R {
        if let Some(result) = self.cache.get(&arg) {
            return result.clone();
        }
        
        let result = (self.func)(arg.clone());
        self.cache.insert(arg, result.clone());
        result
    }
}

fn main() {
    let mut fib = Memoized::new(|n: u64| {
        println!("è®¡ç®— fib({})", n);
        match n {
            0 => 0,
            1 => 1,
            n => {
                // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–äº†ï¼Œå®é™…éœ€è¦é€’å½’è°ƒç”¨ç¼“å­˜ç‰ˆæœ¬
                n
            }
        }
    });
    
    println!("{}", fib.call(5));
    println!("{}", fib.call(5));  // ä½¿ç”¨ç¼“å­˜
}
```

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸš€ æ·±å…¥æŒæ¡Rusté—­åŒ…ï¼Œé‡Šæ”¾å‡½æ•°å¼ç¼–ç¨‹çš„å¨åŠ›ï¼** ğŸ¦€âœ¨
