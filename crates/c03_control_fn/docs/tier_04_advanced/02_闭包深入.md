# 4.2 闭包深入

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 深入探讨Rust闭包的内部机制和高级应用  
> **适用对象**: 需要深入理解闭包实现的高级开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [函数系统指南](../tier_02_guides/03_函数系统指南.md)

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [4.2 闭包深入](#42-闭包深入)
  - [📋 目录](#-目录)
  - [1. 闭包的内部表示](#1-闭包的内部表示)
    - [编译器如何处理闭包](#编译器如何处理闭包)
    - [零大小闭包](#零大小闭包)
    - [捕获大小分析](#捕获大小分析)
  - [2. 高阶函数模式](#2-高阶函数模式)
    - [闭包作为返回值](#闭包作为返回值)
    - [闭包组合子](#闭包组合子)
    - [柯里化](#柯里化)
  - [3. 闭包与生命周期](#3-闭包与生命周期)
    - [复杂生命周期场景](#复杂生命周期场景)
    - [HRTB（高阶trait边界）](#hrtb高阶trait边界)
    - [闭包返回引用](#闭包返回引用)
  - [4. 闭包trait对象](#4-闭包trait对象)
    - [动态分发](#动态分发)
    - [trait对象生命周期](#trait对象生命周期)
  - [5. 捕获策略优化](#5-捕获策略优化)
    - [最小化捕获](#最小化捕获)
    - [Clone vs Move](#clone-vs-move)
  - [6. 递归闭包](#6-递归闭包)
    - [使用 Box](#使用-box)
    - [Y组合子](#y组合子)
  - [7. 异步闭包](#7-异步闭包)
    - [async 闭包基础](#async-闭包基础)
    - [async move 与生命周期](#async-move-与生命周期)
  - [8. 实战案例](#8-实战案例)
    - [事件处理系统](#事件处理系统)
    - [惰性求值](#惰性求值)
    - [函数缓存（Memoization）](#函数缓存memoization)

---

## 1. 闭包的内部表示

### 编译器如何处理闭包

```rust
fn main() {
    let x = 10;
    let y = 20;
    
    // 闭包定义
    let closure = |z| x + y + z;
    
    // 编译器大致生成类似以下结构：
    struct ClosureEnv {
        x: i32,
        y: i32,
    }
    
    impl FnOnce<(i32,)> for ClosureEnv {
        type Output = i32;
        fn call_once(self, args: (i32,)) -> i32 {
            self.x + self.y + args.0
        }
    }
    
    impl FnMut<(i32,)> for ClosureEnv {
        fn call_mut(&mut self, args: (i32,)) -> i32 {
            self.x + self.y + args.0
        }
    }
    
    impl Fn<(i32,)> for ClosureEnv {
        fn call(&self, args: (i32,)) -> i32 {
            self.x + self.y + args.0
        }
    }
    
    println!("{}", closure(5));  // 35
}
```

### 零大小闭包

```rust
fn main() {
    // 不捕获任何变量的闭包是零大小类型
    let no_capture = || 42;
    
    // 等价于函数指针
    fn function() -> i32 { 42 }
    
    // 两者性能相同，都是零成本
    assert_eq!(std::mem::size_of_val(&no_capture), 0);
    
    // 可以强制转换为函数指针
    let fn_ptr: fn() -> i32 = no_capture;
    println!("{}", fn_ptr());
}
```

### 捕获大小分析

```rust
fn main() {
    let a = 1u8;
    let b = 2u16;
    let c = 3u32;
    
    // 闭包大小 = 捕获变量大小之和（可能有对齐）
    let closure = || (a, b, c);
    
    println!("闭包大小: {}", std::mem::size_of_val(&closure));
    // 输出: 8 (1 + 2 + 4 + padding)
    
    // move后的大小
    let moved = move || (a, b, c);
    println!("move闭包大小: {}", std::mem::size_of_val(&moved));
    // 相同大小，因为 u8/u16/u32 都是 Copy
}
```

---

## 2. 高阶函数模式

### 闭包作为返回值

```rust
// 返回闭包：使用 impl Trait
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}

// 返回不同类型的闭包：使用 Box
fn make_operation(op: &str) -> Box<dyn Fn(i32, i32) -> i32> {
    match op {
        "add" => Box::new(|a, b| a + b),
        "mul" => Box::new(|a, b| a * b),
        "sub" => Box::new(|a, b| a - b),
        _ => Box::new(|a, b| a / b),
    }
}

fn main() {
    let add_5 = make_adder(5);
    println!("{}", add_5(10));  // 15
    
    let op = make_operation("mul");
    println!("{}", op(3, 4));  // 12
}
```

### 闭包组合子

```rust
fn compose<A, B, C, F, G>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

fn main() {
    let add_one = |x: i32| x + 1;
    let double = |x: i32| x * 2;
    
    // 先加1，再乘2
    let combined = compose(add_one, double);
    println!("{}", combined(5));  // 12
    
    // 链式组合
    let triple = compose(double, |x| x + x / 2);
    println!("{}", triple(10));  // 30
}
```

### 柯里化

```rust
fn curry<A, B, C, F>(f: F) -> impl Fn(A) -> Box<dyn Fn(B) -> C>
where
    F: Fn(A, B) -> C + 'static,
    A: 'static,
    B: 'static,
    C: 'static,
{
    move |a| {
        let f = f.clone();
        Box::new(move |b| f(a, b))
    }
}

fn main() {
    let add = |x: i32, y: i32| x + y;
    
    // 不能直接使用，因为需要 Clone
    // 使用 Rc 来共享
    use std::rc::Rc;
    let add_rc = Rc::new(add);
    
    let add_5 = {
        let add_rc = add_rc.clone();
        move |y| add_rc(5, y)
    };
    
    println!("{}", add_5(10));  // 15
}
```

---

## 3. 闭包与生命周期

### 复杂生命周期场景

```rust
fn make_closure<'a>(s: &'a str) -> impl Fn() + 'a {
    move || println!("{}", s)
}

fn make_closure_boxed<'a>(s: &'a str) -> Box<dyn Fn() + 'a> {
    Box::new(move || println!("{}", s))
}

fn main() {
    let text = String::from("hello");
    
    let closure = make_closure(&text);
    closure();
    
    let boxed = make_closure_boxed(&text);
    boxed();
    
    // text 仍然有效
    println!("{}", text);
}
```

### HRTB（高阶trait边界）

```rust
fn apply<F>(f: F)
where
    F: for<'a> Fn(&'a str) -> &'a str,
{
    let s = String::from("hello");
    let result = f(&s);
    println!("{}", result);
}

fn main() {
    // 接受任意生命周期的 &str
    apply(|s| {
        if s.len() > 3 {
            &s[..3]
        } else {
            s
        }
    });
}
```

### 闭包返回引用

```rust
fn make_ref_closure<'a>(data: &'a [i32]) -> impl Fn(usize) -> &'a i32 {
    move |index| &data[index]
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let getter = make_ref_closure(&numbers);
    
    println!("{}", getter(2));  // 3
    println!("{}", getter(4));  // 5
}
```

---

## 4. 闭包trait对象

### 动态分发

```rust
fn main() {
    let closures: Vec<Box<dyn Fn(i32) -> i32>> = vec![
        Box::new(|x| x + 1),
        Box::new(|x| x * 2),
        Box::new(|x| x * x),
    ];
    
    for (i, closure) in closures.iter().enumerate() {
        println!("闭包 {}: {}", i, closure(5));
    }
}
```

### trait对象生命周期

```rust
struct Processor<'a> {
    callbacks: Vec<Box<dyn Fn(&str) + 'a>>,
}

impl<'a> Processor<'a> {
    fn new() -> Self {
        Processor {
            callbacks: Vec::new(),
        }
    }
    
    fn add_callback<F>(&mut self, f: F)
    where
        F: Fn(&str) + 'a,
    {
        self.callbacks.push(Box::new(f));
    }
    
    fn process(&self, data: &str) {
        for callback in &self.callbacks {
            callback(data);
        }
    }
}

fn main() {
    let mut processor = Processor::new();
    
    let prefix = String::from("LOG:");
    processor.add_callback(move |msg| {
        println!("{} {}", prefix, msg);
    });
    
    processor.add_callback(|msg| {
        println!("长度: {}", msg.len());
    });
    
    processor.process("测试消息");
}
```

---

## 5. 捕获策略优化

### 最小化捕获

```rust
fn main() {
    struct Data {
        id: u32,
        name: String,
        value: i32,
    }
    
    let data = Data {
        id: 1,
        name: String::from("test"),
        value: 42,
    };
    
    // ❌ 捕获整个结构体
    let closure_bad = || {
        println!("{}", data.value);
        // data 的所有字段都被捕获
    };
    
    // ✅ 只捕获需要的字段
    let value = data.value;
    let closure_good = || {
        println!("{}", value);
        // 只捕获 i32
    };
    
    // data.name 仍可以使用
    println!("{}", data.name);
}
```

### Clone vs Move

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // ❌ 不好：移动整个 Vec
    let closure1 = move || {
        println!("{:?}", data);
    };
    // data 不可再用
    
    // ✅ 好：克隆后移动
    let data = vec![1, 2, 3, 4, 5];
    let data_clone = data.clone();
    let closure2 = move || {
        println!("{:?}", data_clone);
    };
    // data 仍可用
    println!("{:?}", data);
}
```

---

## 6. 递归闭包

### 使用 Box

```rust
fn main() {
    // 递归闭包需要类型注解
    let factorial: Box<dyn Fn(u64) -> u64> = Box::new(|n| {
        if n == 0 {
            1
        } else {
            // 错误：闭包无法调用自身
            // n * factorial(n - 1)
            0  // 占位
        }
    });
    
    // 需要使用 Rc 和 RefCell
    use std::rc::Rc;
    use std::cell::RefCell;
    
    let factorial = Rc::new(RefCell::new(None));
    let factorial_clone = factorial.clone();
    
    *factorial.borrow_mut() = Some(Box::new(move |n: u64| -> u64 {
        if n == 0 {
            1
        } else {
            let f = factorial_clone.borrow();
            let f = f.as_ref().unwrap();
            n * f(n - 1)
        }
    }) as Box<dyn Fn(u64) -> u64>);
    
    let f = factorial.borrow();
    let f = f.as_ref().unwrap();
    println!("5! = {}", f(5));  // 120
}
```

### Y组合子

```rust
// Y组合子的 Rust 实现
fn fix<A, R, F>(f: F) -> impl Fn(A) -> R
where
    F: Fn(&dyn Fn(A) -> R, A) -> R,
    A: 'static,
    R: 'static,
{
    use std::rc::Rc;
    
    let rc = Rc::new(f);
    let rc_clone = rc.clone();
    
    move |a| {
        let g: Box<dyn Fn(A) -> R> = Box::new({
            let rc = rc_clone.clone();
            move |a| {
                let rc = rc.clone();
                rc(&*Box::new(move |a| g(a)), a)
            }
        });
        rc(&*g, a)
    }
}

fn main() {
    let factorial = fix(|f, n: u64| {
        if n == 0 {
            1
        } else {
            n * f(n - 1)
        }
    });
    
    println!("5! = {}", factorial(5));
}
```

---

## 7. 异步闭包

### async 闭包基础

```rust
async fn process_async() {
    println!("异步处理");
}

fn main() {
    // async 闭包（需要运行时）
    let async_closure = async || {
        println!("异步闭包");
        42
    };
    
    // 需要 runtime 才能执行
    // let result = async_closure().await;
    
    println!("异步闭包示例（需要运行时执行）");
}
```

### async move 与生命周期

```rust
fn spawn_task(data: String) -> impl std::future::Future<Output = ()> {
    // 使用 async move 捕获所有权
    async move {
        println!("处理: {}", data);
    }
}

fn main() {
    let data = String::from("test");
    let future = spawn_task(data);
    // data 已被移动
    
    // 需要运行时执行
    // runtime.block_on(future);
}
```

---

## 8. 实战案例

### 事件处理系统

```rust
struct EventHandler {
    handlers: Vec<Box<dyn Fn(&str)>>,
}

impl EventHandler {
    fn new() -> Self {
        EventHandler {
            handlers: Vec::new(),
        }
    }
    
    fn on<F>(&mut self, handler: F)
    where
        F: Fn(&str) + 'static,
    {
        self.handlers.push(Box::new(handler));
    }
    
    fn emit(&self, event: &str) {
        for handler in &self.handlers {
            handler(event);
        }
    }
}

fn main() {
    let mut eh = EventHandler::new();
    
    let mut count = 0;
    eh.on(move |event| {
        count += 1;
        println!("处理器1: {} (次数: {})", event, count);
    });
    
    eh.on(|event| {
        println!("处理器2: {}", event);
    });
    
    eh.emit("click");
    eh.emit("hover");
}
```

### 惰性求值

```rust
struct Lazy<T, F>
where
    F: FnOnce() -> T,
{
    value: Option<T>,
    init: Option<F>,
}

impl<T, F> Lazy<T, F>
where
    F: FnOnce() -> T,
{
    fn new(f: F) -> Self {
        Lazy {
            value: None,
            init: Some(f),
        }
    }
    
    fn get(&mut self) -> &T {
        if self.value.is_none() {
            let init = self.init.take().unwrap();
            self.value = Some(init());
        }
        self.value.as_ref().unwrap()
    }
}

fn main() {
    let mut lazy = Lazy::new(|| {
        println!("计算中...");
        42
    });
    
    println!("创建完成");
    println!("值: {}", lazy.get());  // 触发计算
    println!("值: {}", lazy.get());  // 使用缓存
}
```

### 函数缓存（Memoization）

```rust
use std::collections::HashMap;

struct Memoized<F, A, R>
where
    F: FnMut(A) -> R,
    A: Eq + std::hash::Hash + Clone,
    R: Clone,
{
    func: F,
    cache: HashMap<A, R>,
}

impl<F, A, R> Memoized<F, A, R>
where
    F: FnMut(A) -> R,
    A: Eq + std::hash::Hash + Clone,
    R: Clone,
{
    fn new(func: F) -> Self {
        Memoized {
            func,
            cache: HashMap::new(),
        }
    }
    
    fn call(&mut self, arg: A) -> R {
        if let Some(result) = self.cache.get(&arg) {
            return result.clone();
        }
        
        let result = (self.func)(arg.clone());
        self.cache.insert(arg, result.clone());
        result
    }
}

fn main() {
    let mut fib = Memoized::new(|n: u64| {
        println!("计算 fib({})", n);
        match n {
            0 => 0,
            1 => 1,
            n => {
                // 注意：这里简化了，实际需要递归调用缓存版本
                n
            }
        }
    });
    
    println!("{}", fib.call(5));
    println!("{}", fib.call(5));  // 使用缓存
}
```

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🚀 深入掌握Rust闭包，释放函数式编程的威力！** 🦀✨
