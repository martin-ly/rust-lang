# 4.5 性能优化

> **文档类型**: Tier 4 - 高级层  
> **文档定位**: 控制流与函数相关的性能优化技巧  
> **适用对象**: 需要优化关键性能路径的高级开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)


## 📊 目录

- [4.5 性能优化](#45-性能优化)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 迭代器优化](#1-迭代器优化)
    - [避免collect后再迭代](#避免collect后再迭代)
    - [使用iter而非into\_iter](#使用iter而非into_iter)
    - [迭代器融合](#迭代器融合)
  - [2. 分支预测](#2-分支预测)
    - [likely/unlikely 提示](#likelyunlikely-提示)
    - [减少分支](#减少分支)
  - [3. 内联优化](#3-内联优化)
    - [使用#\[inline\]](#使用inline)
    - [泛型单态化](#泛型单态化)
  - [4. 零成本抽象](#4-零成本抽象)
    - [迭代器vs手写循环](#迭代器vs手写循环)
    - [闭包vs函数指针](#闭包vs函数指针)
  - [5. 避免不必要的分配](#5-避免不必要的分配)
    - [使用\&str而非String](#使用str而非string)
    - [预分配容量](#预分配容量)
    - [复用缓冲区](#复用缓冲区)
  - [6. SIMD与向量化](#6-simd与向量化)
    - [使用slice方法](#使用slice方法)
    - [使用迭代器（易向量化）](#使用迭代器易向量化)
  - [7. 编译器优化提示](#7-编译器优化提示)
    - [使用const](#使用const)
    - [使用#\[cold\]标记冷路径](#使用cold标记冷路径)
    - [unreachable\_unchecked](#unreachable_unchecked)
  - [8. 性能测试与分析](#8-性能测试与分析)
    - [基准测试](#基准测试)
    - [性能分析工具](#性能分析工具)
    - [性能比较](#性能比较)


**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [4.5 性能优化](#45-性能优化)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 迭代器优化](#1-迭代器优化)
    - [避免collect后再迭代](#避免collect后再迭代)
    - [使用iter而非into\_iter](#使用iter而非into_iter)
    - [迭代器融合](#迭代器融合)
  - [2. 分支预测](#2-分支预测)
    - [likely/unlikely 提示](#likelyunlikely-提示)
    - [减少分支](#减少分支)
  - [3. 内联优化](#3-内联优化)
    - [使用#\[inline\]](#使用inline)
    - [泛型单态化](#泛型单态化)
  - [4. 零成本抽象](#4-零成本抽象)
    - [迭代器vs手写循环](#迭代器vs手写循环)
    - [闭包vs函数指针](#闭包vs函数指针)
  - [5. 避免不必要的分配](#5-避免不必要的分配)
    - [使用\&str而非String](#使用str而非string)
    - [预分配容量](#预分配容量)
    - [复用缓冲区](#复用缓冲区)
  - [6. SIMD与向量化](#6-simd与向量化)
    - [使用slice方法](#使用slice方法)
    - [使用迭代器（易向量化）](#使用迭代器易向量化)
  - [7. 编译器优化提示](#7-编译器优化提示)
    - [使用const](#使用const)
    - [使用#\[cold\]标记冷路径](#使用cold标记冷路径)
    - [unreachable\_unchecked](#unreachable_unchecked)
  - [8. 性能测试与分析](#8-性能测试与分析)
    - [基准测试](#基准测试)
    - [性能分析工具](#性能分析工具)
    - [性能比较](#性能比较)

---

## 1. 迭代器优化

### 避免collect后再迭代

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // ❌ 不好：中间分配
    let doubled: Vec<_> = numbers.iter().map(|x| x * 2).collect();
    let sum: i32 = doubled.iter().sum();
    
    // ✅ 好：链式迭代
    let sum: i32 = numbers.iter().map(|x| x * 2).sum();
    
    println!("sum: {}", sum);
}
```

### 使用iter而非into_iter

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // ❌ 如果不需要所有权，不要使用into_iter
    // let sum: i32 = numbers.into_iter().sum();
    
    // ✅ 使用引用迭代
    let sum: i32 = numbers.iter().sum();
    
    // numbers 仍可用
    println!("{:?}", numbers);
}
```

### 迭代器融合

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // 编译器会将多个适配器融合为单次迭代
    let result: Vec<_> = data.iter()
        .filter(|&&x| x % 2 == 0)  // 融合
        .map(|&x| x * x)            // 融合
        .filter(|&x| x > 10)        // 融合
        .collect();                 // 单次迭代
    
    println!("{:?}", result);
}
```

---

## 2. 分支预测

### likely/unlikely 提示

```rust
// Rust标准库中没有内置likely/unlikely，但可以使用这种模式

#[inline(always)]
fn likely(b: bool) -> bool {
    if !b {
        std::hint::unreachable_unchecked();
    }
    true
}

fn process_hot_path(value: i32) -> i32 {
    // 使用 if let 处理常见情况
    if value > 0 {  // 假设这是热路径
        value * 2
    } else if value < 0 {
        -value
    } else {
        0
    }
}

fn main() {
    println!("{}", process_hot_path(10));
}
```

### 减少分支

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // ❌ 有分支
    let sum1 = numbers.iter().fold(0, |acc, &x| {
        if x % 2 == 0 {
            acc + x
        } else {
            acc
        }
    });
    
    // ✅ 无分支（使用算术）
    let sum2: i32 = numbers.iter()
        .map(|&x| x * (x % 2 == 0) as i32)
        .sum();
    
    assert_eq!(sum1, sum2);
}
```

---

## 3. 内联优化

### 使用#[inline]

```rust
// 小函数：建议内联
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// 强制内联
#[inline(always)]
fn critical_path(x: i32) -> i32 {
    x * x + 2 * x + 1
}

// 建议不内联
#[inline(never)]
fn large_function() {
    // 大型函数体
}

fn main() {
    println!("{}", add(3, 4));
    println!("{}", critical_path(5));
}
```

### 泛型单态化

```rust
// 泛型函数会为每个具体类型生成特化版本
#[inline]
fn process<T: std::ops::Add<Output = T> + Copy>(a: T, b: T) -> T {
    a + b
}

fn main() {
    // 生成 process_i32
    let r1 = process(1i32, 2i32);
    
    // 生成 process_f64
    let r2 = process(1.0f64, 2.0f64);
    
    println!("{}, {}", r1, r2);
}
```

---

## 4. 零成本抽象

### 迭代器vs手写循环

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // 迭代器版本（零成本）
    let sum1: i32 = data.iter().sum();
    
    // 手写循环
    let mut sum2 = 0;
    for &x in &data {
        sum2 += x;
    }
    
    // 编译后生成相同的机器码
    assert_eq!(sum1, sum2);
}
```

### 闭包vs函数指针

```rust
fn apply_twice(f: impl Fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn apply_twice_ptr(f: fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn main() {
    let double = |x| x * 2;
    
    // 使用闭包（可能内联）
    let r1 = apply_twice(double, 5);
    
    // 使用函数指针（动态调用）
    fn double_fn(x: i32) -> i32 { x * 2 }
    let r2 = apply_twice_ptr(double_fn, 5);
    
    assert_eq!(r1, r2);
}
```

---

## 5. 避免不必要的分配

### 使用&str而非String

```rust
fn main() {
    // ❌ 不必要的分配
    fn process_bad(s: String) {
        println!("{}", s);
    }
    
    // ✅ 使用引用
    fn process_good(s: &str) {
        println!("{}", s);
    }
    
    process_good("hello");
    process_good(&String::from("world"));
}
```

### 预分配容量

```rust
fn main() {
    // ❌ 多次重新分配
    let mut vec1 = Vec::new();
    for i in 0..1000 {
        vec1.push(i);
    }
    
    // ✅ 预分配容量
    let mut vec2 = Vec::with_capacity(1000);
    for i in 0..1000 {
        vec2.push(i);
    }
}
```

### 复用缓冲区

```rust
fn main() {
    let mut buffer = Vec::with_capacity(100);
    
    for i in 0..10 {
        buffer.clear();  // 清空但保留容量
        for j in 0..10 {
            buffer.push(i * 10 + j);
        }
        println!("迭代 {}: {} 个元素", i, buffer.len());
    }
}
```

---

## 6. SIMD与向量化

### 使用slice方法

```rust
fn main() {
    let a = [1, 2, 3, 4, 5, 6, 7, 8];
    let b = [2, 3, 4, 5, 6, 7, 8, 9];
    
    // 编译器可能自动向量化
    let mut result = [0; 8];
    for i in 0..8 {
        result[i] = a[i] + b[i];
    }
    
    println!("{:?}", result);
}
```

### 使用迭代器（易向量化）

```rust
fn main() {
    let data = vec![1.0f32; 1000];
    
    // 容易向量化
    let result: Vec<_> = data.iter()
        .map(|&x| x * 2.0)
        .collect();
    
    println!("处理了 {} 个元素", result.len());
}
```

---

## 7. 编译器优化提示

### 使用const

```rust
const THRESHOLD: i32 = 100;

fn process(value: i32) -> i32 {
    // 编译器可以优化常量比较
    if value > THRESHOLD {
        value * 2
    } else {
        value
    }
}

fn main() {
    println!("{}", process(150));
}
```

### 使用#[cold]标记冷路径

```rust
#[cold]
fn error_handler() {
    eprintln!("发生错误");
}

fn process(value: i32) -> Result<i32, ()> {
    if value < 0 {
        error_handler();
        return Err(());
    }
    Ok(value * 2)
}

fn main() {
    let _ = process(10);
}
```

### unreachable_unchecked

```rust
fn process(value: u8) -> &'static str {
    match value {
        0 => "zero",
        1 => "one",
        2 => "two",
        _ => unsafe {
            // 如果确信不会到达这里
            std::hint::unreachable_unchecked()
        }
    }
}

fn main() {
    // 只使用 0, 1, 2
    println!("{}", process(1));
}
```

---

## 8. 性能测试与分析

### 基准测试

```rust
// 使用 criterion 进行基准测试（示例）
/*
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
*/
```

### 性能分析工具

```rust
// 使用 flamegraph 分析
fn expensive_operation() {
    let mut sum = 0;
    for i in 0..1_000_000 {
        sum += i * i;
    }
}

fn main() {
    // cargo flamegraph 会生成火焰图
    expensive_operation();
}
```

### 性能比较

```rust
use std::time::Instant;

fn measure<F: FnOnce()>(name: &str, f: F) {
    let start = Instant::now();
    f();
    let duration = start.elapsed();
    println!("{}: {:?}", name, duration);
}

fn main() {
    let data: Vec<_> = (0..1_000_000).collect();
    
    measure("方法1: for循环", || {
        let mut sum = 0;
        for &x in &data {
            sum += x;
        }
    });
    
    measure("方法2: 迭代器", || {
        let _sum: i32 = data.iter().sum();
    });
    
    measure("方法3: fold", || {
        let _sum = data.iter().fold(0, |acc, &x| acc + x);
    });
}
```

---

**性能优化检查清单**:

- [ ] 使用迭代器而非手写循环
- [ ] 避免不必要的collect
- [ ] 预分配容量
- [ ] 使用&str而非String
- [ ] 合理使用#[inline]
- [ ] 减少分支
- [ ] 避免不必要的克隆
- [ ] 使用Copy类型
- [ ] 复用缓冲区
- [ ] 进行基准测试

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**⚡ 掌握性能优化技巧，让Rust代码飞起来！** 🦀✨
