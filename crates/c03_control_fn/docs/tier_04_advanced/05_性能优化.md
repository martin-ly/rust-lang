# 4.5 æ€§èƒ½ä¼˜åŒ–

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: æ§åˆ¶æµä¸å‡½æ•°ç›¸å…³çš„æ€§èƒ½ä¼˜åŒ–æŠ€å·§  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦ä¼˜åŒ–å…³é”®æ€§èƒ½è·¯å¾„çš„é«˜çº§å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [4.5 æ€§èƒ½ä¼˜åŒ–](#45-æ€§èƒ½ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è¿­ä»£å™¨ä¼˜åŒ–](#1-è¿­ä»£å™¨ä¼˜åŒ–)
    - [é¿å…collectåå†è¿­ä»£](#é¿å…collectåå†è¿­ä»£)
    - [ä½¿ç”¨iterè€Œéinto\_iter](#ä½¿ç”¨iterè€Œéinto_iter)
    - [è¿­ä»£å™¨èåˆ](#è¿­ä»£å™¨èåˆ)
  - [2. åˆ†æ”¯é¢„æµ‹](#2-åˆ†æ”¯é¢„æµ‹)
    - [likely/unlikely æç¤º](#likelyunlikely-æç¤º)
    - [å‡å°‘åˆ†æ”¯](#å‡å°‘åˆ†æ”¯)
  - [3. å†…è”ä¼˜åŒ–](#3-å†…è”ä¼˜åŒ–)
    - [ä½¿ç”¨#\[inline\]](#ä½¿ç”¨inline)
    - [æ³›å‹å•æ€åŒ–](#æ³›å‹å•æ€åŒ–)
  - [4. é›¶æˆæœ¬æŠ½è±¡](#4-é›¶æˆæœ¬æŠ½è±¡)
    - [è¿­ä»£å™¨vsæ‰‹å†™å¾ªç¯](#è¿­ä»£å™¨vsæ‰‹å†™å¾ªç¯)
    - [é—­åŒ…vså‡½æ•°æŒ‡é’ˆ](#é—­åŒ…vså‡½æ•°æŒ‡é’ˆ)
  - [5. é¿å…ä¸å¿…è¦çš„åˆ†é…](#5-é¿å…ä¸å¿…è¦çš„åˆ†é…)
    - [ä½¿ç”¨\&strè€ŒéString](#ä½¿ç”¨strè€Œéstring)
    - [é¢„åˆ†é…å®¹é‡](#é¢„åˆ†é…å®¹é‡)
    - [å¤ç”¨ç¼“å†²åŒº](#å¤ç”¨ç¼“å†²åŒº)
  - [6. SIMDä¸å‘é‡åŒ–](#6-simdä¸å‘é‡åŒ–)
    - [ä½¿ç”¨sliceæ–¹æ³•](#ä½¿ç”¨sliceæ–¹æ³•)
    - [ä½¿ç”¨è¿­ä»£å™¨ï¼ˆæ˜“å‘é‡åŒ–ï¼‰](#ä½¿ç”¨è¿­ä»£å™¨æ˜“å‘é‡åŒ–)
  - [7. ç¼–è¯‘å™¨ä¼˜åŒ–æç¤º](#7-ç¼–è¯‘å™¨ä¼˜åŒ–æç¤º)
    - [ä½¿ç”¨const](#ä½¿ç”¨const)
    - [ä½¿ç”¨#\[cold\]æ ‡è®°å†·è·¯å¾„](#ä½¿ç”¨coldæ ‡è®°å†·è·¯å¾„)
    - [unreachable\_unchecked](#unreachable_unchecked)
  - [8. æ€§èƒ½æµ‹è¯•ä¸åˆ†æ](#8-æ€§èƒ½æµ‹è¯•ä¸åˆ†æ)
    - [åŸºå‡†æµ‹è¯•](#åŸºå‡†æµ‹è¯•)
    - [æ€§èƒ½åˆ†æå·¥å…·](#æ€§èƒ½åˆ†æå·¥å…·)
    - [æ€§èƒ½æ¯”è¾ƒ](#æ€§èƒ½æ¯”è¾ƒ)

---

## 1. è¿­ä»£å™¨ä¼˜åŒ–

### é¿å…collectåå†è¿­ä»£

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // âŒ ä¸å¥½ï¼šä¸­é—´åˆ†é…
    let doubled: Vec<_> = numbers.iter().map(|x| x * 2).collect();
    let sum: i32 = doubled.iter().sum();
    
    // âœ… å¥½ï¼šé“¾å¼è¿­ä»£
    let sum: i32 = numbers.iter().map(|x| x * 2).sum();
    
    println!("sum: {}", sum);
}
```

### ä½¿ç”¨iterè€Œéinto_iter

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // âŒ å¦‚æœä¸éœ€è¦æ‰€æœ‰æƒï¼Œä¸è¦ä½¿ç”¨into_iter
    // let sum: i32 = numbers.into_iter().sum();
    
    // âœ… ä½¿ç”¨å¼•ç”¨è¿­ä»£
    let sum: i32 = numbers.iter().sum();
    
    // numbers ä»å¯ç”¨
    println!("{:?}", numbers);
}
```

### è¿­ä»£å™¨èåˆ

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // ç¼–è¯‘å™¨ä¼šå°†å¤šä¸ªé€‚é…å™¨èåˆä¸ºå•æ¬¡è¿­ä»£
    let result: Vec<_> = data.iter()
        .filter(|&&x| x % 2 == 0)  // èåˆ
        .map(|&x| x * x)            // èåˆ
        .filter(|&x| x > 10)        // èåˆ
        .collect();                 // å•æ¬¡è¿­ä»£
    
    println!("{:?}", result);
}
```

---

## 2. åˆ†æ”¯é¢„æµ‹

### likely/unlikely æç¤º

```rust
// Rustæ ‡å‡†åº“ä¸­æ²¡æœ‰å†…ç½®likely/unlikelyï¼Œä½†å¯ä»¥ä½¿ç”¨è¿™ç§æ¨¡å¼

#[inline(always)]
fn likely(b: bool) -> bool {
    if !b {
        std::hint::unreachable_unchecked();
    }
    true
}

fn process_hot_path(value: i32) -> i32 {
    // ä½¿ç”¨ if let å¤„ç†å¸¸è§æƒ…å†µ
    if value > 0 {  // å‡è®¾è¿™æ˜¯çƒ­è·¯å¾„
        value * 2
    } else if value < 0 {
        -value
    } else {
        0
    }
}

fn main() {
    println!("{}", process_hot_path(10));
}
```

### å‡å°‘åˆ†æ”¯

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // âŒ æœ‰åˆ†æ”¯
    let sum1 = numbers.iter().fold(0, |acc, &x| {
        if x % 2 == 0 {
            acc + x
        } else {
            acc
        }
    });
    
    // âœ… æ— åˆ†æ”¯ï¼ˆä½¿ç”¨ç®—æœ¯ï¼‰
    let sum2: i32 = numbers.iter()
        .map(|&x| x * (x % 2 == 0) as i32)
        .sum();
    
    assert_eq!(sum1, sum2);
}
```

---

## 3. å†…è”ä¼˜åŒ–

### ä½¿ç”¨#[inline]

```rust
// å°å‡½æ•°ï¼šå»ºè®®å†…è”
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// å¼ºåˆ¶å†…è”
#[inline(always)]
fn critical_path(x: i32) -> i32 {
    x * x + 2 * x + 1
}

// å»ºè®®ä¸å†…è”
#[inline(never)]
fn large_function() {
    // å¤§å‹å‡½æ•°ä½“
}

fn main() {
    println!("{}", add(3, 4));
    println!("{}", critical_path(5));
}
```

### æ³›å‹å•æ€åŒ–

```rust
// æ³›å‹å‡½æ•°ä¼šä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆç‰¹åŒ–ç‰ˆæœ¬
#[inline]
fn process<T: std::ops::Add<Output = T> + Copy>(a: T, b: T) -> T {
    a + b
}

fn main() {
    // ç”Ÿæˆ process_i32
    let r1 = process(1i32, 2i32);
    
    // ç”Ÿæˆ process_f64
    let r2 = process(1.0f64, 2.0f64);
    
    println!("{}, {}", r1, r2);
}
```

---

## 4. é›¶æˆæœ¬æŠ½è±¡

### è¿­ä»£å™¨vsæ‰‹å†™å¾ªç¯

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // è¿­ä»£å™¨ç‰ˆæœ¬ï¼ˆé›¶æˆæœ¬ï¼‰
    let sum1: i32 = data.iter().sum();
    
    // æ‰‹å†™å¾ªç¯
    let mut sum2 = 0;
    for &x in &data {
        sum2 += x;
    }
    
    // ç¼–è¯‘åç”Ÿæˆç›¸åŒçš„æœºå™¨ç 
    assert_eq!(sum1, sum2);
}
```

### é—­åŒ…vså‡½æ•°æŒ‡é’ˆ

```rust
fn apply_twice(f: impl Fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn apply_twice_ptr(f: fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn main() {
    let double = |x| x * 2;
    
    // ä½¿ç”¨é—­åŒ…ï¼ˆå¯èƒ½å†…è”ï¼‰
    let r1 = apply_twice(double, 5);
    
    // ä½¿ç”¨å‡½æ•°æŒ‡é’ˆï¼ˆåŠ¨æ€è°ƒç”¨ï¼‰
    fn double_fn(x: i32) -> i32 { x * 2 }
    let r2 = apply_twice_ptr(double_fn, 5);
    
    assert_eq!(r1, r2);
}
```

---

## 5. é¿å…ä¸å¿…è¦çš„åˆ†é…

### ä½¿ç”¨&strè€ŒéString

```rust
fn main() {
    // âŒ ä¸å¿…è¦çš„åˆ†é…
    fn process_bad(s: String) {
        println!("{}", s);
    }
    
    // âœ… ä½¿ç”¨å¼•ç”¨
    fn process_good(s: &str) {
        println!("{}", s);
    }
    
    process_good("hello");
    process_good(&String::from("world"));
}
```

### é¢„åˆ†é…å®¹é‡

```rust
fn main() {
    // âŒ å¤šæ¬¡é‡æ–°åˆ†é…
    let mut vec1 = Vec::new();
    for i in 0..1000 {
        vec1.push(i);
    }
    
    // âœ… é¢„åˆ†é…å®¹é‡
    let mut vec2 = Vec::with_capacity(1000);
    for i in 0..1000 {
        vec2.push(i);
    }
}
```

### å¤ç”¨ç¼“å†²åŒº

```rust
fn main() {
    let mut buffer = Vec::with_capacity(100);
    
    for i in 0..10 {
        buffer.clear();  // æ¸…ç©ºä½†ä¿ç•™å®¹é‡
        for j in 0..10 {
            buffer.push(i * 10 + j);
        }
        println!("è¿­ä»£ {}: {} ä¸ªå…ƒç´ ", i, buffer.len());
    }
}
```

---

## 6. SIMDä¸å‘é‡åŒ–

### ä½¿ç”¨sliceæ–¹æ³•

```rust
fn main() {
    let a = [1, 2, 3, 4, 5, 6, 7, 8];
    let b = [2, 3, 4, 5, 6, 7, 8, 9];
    
    // ç¼–è¯‘å™¨å¯èƒ½è‡ªåŠ¨å‘é‡åŒ–
    let mut result = [0; 8];
    for i in 0..8 {
        result[i] = a[i] + b[i];
    }
    
    println!("{:?}", result);
}
```

### ä½¿ç”¨è¿­ä»£å™¨ï¼ˆæ˜“å‘é‡åŒ–ï¼‰

```rust
fn main() {
    let data = vec![1.0f32; 1000];
    
    // å®¹æ˜“å‘é‡åŒ–
    let result: Vec<_> = data.iter()
        .map(|&x| x * 2.0)
        .collect();
    
    println!("å¤„ç†äº† {} ä¸ªå…ƒç´ ", result.len());
}
```

---

## 7. ç¼–è¯‘å™¨ä¼˜åŒ–æç¤º

### ä½¿ç”¨const

```rust
const THRESHOLD: i32 = 100;

fn process(value: i32) -> i32 {
    // ç¼–è¯‘å™¨å¯ä»¥ä¼˜åŒ–å¸¸é‡æ¯”è¾ƒ
    if value > THRESHOLD {
        value * 2
    } else {
        value
    }
}

fn main() {
    println!("{}", process(150));
}
```

### ä½¿ç”¨#[cold]æ ‡è®°å†·è·¯å¾„

```rust
#[cold]
fn error_handler() {
    eprintln!("å‘ç”Ÿé”™è¯¯");
}

fn process(value: i32) -> Result<i32, ()> {
    if value < 0 {
        error_handler();
        return Err(());
    }
    Ok(value * 2)
}

fn main() {
    let _ = process(10);
}
```

### unreachable_unchecked

```rust
fn process(value: u8) -> &'static str {
    match value {
        0 => "zero",
        1 => "one",
        2 => "two",
        _ => unsafe {
            // å¦‚æœç¡®ä¿¡ä¸ä¼šåˆ°è¾¾è¿™é‡Œ
            std::hint::unreachable_unchecked()
        }
    }
}

fn main() {
    // åªä½¿ç”¨ 0, 1, 2
    println!("{}", process(1));
}
```

---

## 8. æ€§èƒ½æµ‹è¯•ä¸åˆ†æ

### åŸºå‡†æµ‹è¯•

```rust
// ä½¿ç”¨ criterion è¿›è¡ŒåŸºå‡†æµ‹è¯•ï¼ˆç¤ºä¾‹ï¼‰
/*
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
*/
```

### æ€§èƒ½åˆ†æå·¥å…·

```rust
// ä½¿ç”¨ flamegraph åˆ†æ
fn expensive_operation() {
    let mut sum = 0;
    for i in 0..1_000_000 {
        sum += i * i;
    }
}

fn main() {
    // cargo flamegraph ä¼šç”Ÿæˆç«ç„°å›¾
    expensive_operation();
}
```

### æ€§èƒ½æ¯”è¾ƒ

```rust
use std::time::Instant;

fn measure<F: FnOnce()>(name: &str, f: F) {
    let start = Instant::now();
    f();
    let duration = start.elapsed();
    println!("{}: {:?}", name, duration);
}

fn main() {
    let data: Vec<_> = (0..1_000_000).collect();
    
    measure("æ–¹æ³•1: forå¾ªç¯", || {
        let mut sum = 0;
        for &x in &data {
            sum += x;
        }
    });
    
    measure("æ–¹æ³•2: è¿­ä»£å™¨", || {
        let _sum: i32 = data.iter().sum();
    });
    
    measure("æ–¹æ³•3: fold", || {
        let _sum = data.iter().fold(0, |acc, &x| acc + x);
    });
}
```

---

**æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•**:

- [ ] ä½¿ç”¨è¿­ä»£å™¨è€Œéæ‰‹å†™å¾ªç¯
- [ ] é¿å…ä¸å¿…è¦çš„collect
- [ ] é¢„åˆ†é…å®¹é‡
- [ ] ä½¿ç”¨&strè€ŒéString
- [ ] åˆç†ä½¿ç”¨#[inline]
- [ ] å‡å°‘åˆ†æ”¯
- [ ] é¿å…ä¸å¿…è¦çš„å…‹éš†
- [ ] ä½¿ç”¨Copyç±»å‹
- [ ] å¤ç”¨ç¼“å†²åŒº
- [ ] è¿›è¡ŒåŸºå‡†æµ‹è¯•

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**âš¡ æŒæ¡æ€§èƒ½ä¼˜åŒ–æŠ€å·§ï¼Œè®©Rustä»£ç é£èµ·æ¥ï¼** ğŸ¦€âœ¨
