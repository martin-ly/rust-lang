# 4.4 é”™è¯¯å¤„ç†è¿›é˜¶

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: Rusté”™è¯¯å¤„ç†çš„é«˜çº§æ¨¡å¼å’Œæœ€ä½³å®è·µ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æ„å»ºå¥å£®é”™è¯¯å¤„ç†ç³»ç»Ÿçš„é«˜çº§å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é”™è¯¯å¤„ç†æŒ‡å—](../tier_02_guides/05_é”™è¯¯å¤„ç†æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [4.4 é”™è¯¯å¤„ç†è¿›é˜¶](#44-é”™è¯¯å¤„ç†è¿›é˜¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#1-è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [æšä¸¾é”™è¯¯ç±»å‹](#æšä¸¾é”™è¯¯ç±»å‹)
    - [ç»“æ„ä½“é”™è¯¯ç±»å‹](#ç»“æ„ä½“é”™è¯¯ç±»å‹)
  - [2. é”™è¯¯é“¾ä¸ä¸Šä¸‹æ–‡](#2-é”™è¯¯é“¾ä¸ä¸Šä¸‹æ–‡)
    - [é”™è¯¯åŒ…è£…](#é”™è¯¯åŒ…è£…)
    - [ä½¿ç”¨anyhowå’Œthiserror](#ä½¿ç”¨anyhowå’Œthiserror)
  - [3. é”™è¯¯è½¬æ¢ä¸ä¼ æ’­](#3-é”™è¯¯è½¬æ¢ä¸ä¼ æ’­)
    - [æ™ºèƒ½é”™è¯¯è½¬æ¢](#æ™ºèƒ½é”™è¯¯è½¬æ¢)
  - [4. å¤šé”™è¯¯ç±»å‹å¤„ç†](#4-å¤šé”™è¯¯ç±»å‹å¤„ç†)
    - [`Box<dyn Error>`](#boxdyn-error)
    - [é”™è¯¯ç±»å‹æ“¦é™¤](#é”™è¯¯ç±»å‹æ“¦é™¤)
  - [5. å¼‚å¸¸å®‰å…¨æ€§](#5-å¼‚å¸¸å®‰å…¨æ€§)
    - [RAII æ¨¡å¼](#raii-æ¨¡å¼)
    - [Panic å®‰å…¨](#panic-å®‰å…¨)
  - [6. é”™è¯¯æ¢å¤ç­–ç•¥](#6-é”™è¯¯æ¢å¤ç­–ç•¥)
    - [é‡è¯•æœºåˆ¶](#é‡è¯•æœºåˆ¶)
    - [é™çº§ç­–ç•¥](#é™çº§ç­–ç•¥)
  - [7. é”™è¯¯å¤„ç†æ€§èƒ½](#7-é”™è¯¯å¤„ç†æ€§èƒ½)
    - [é¿å…ä¸å¿…è¦çš„åˆ†é…](#é¿å…ä¸å¿…è¦çš„åˆ†é…)
    - [ä½¿ç”¨Copyç±»å‹çš„é”™è¯¯](#ä½¿ç”¨copyç±»å‹çš„é”™è¯¯)
  - [8. å®æˆ˜æ¨¡å¼](#8-å®æˆ˜æ¨¡å¼)
    - [åˆ†å±‚é”™è¯¯å¤„ç†](#åˆ†å±‚é”™è¯¯å¤„ç†)
    - [é”™è¯¯æ—¥å¿—è®°å½•](#é”™è¯¯æ—¥å¿—è®°å½•)

---

## 1. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### æšä¸¾é”™è¯¯ç±»å‹

```rust
use std::fmt;

#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    ValidationError(String),
    NetworkError { code: u16, message: String },
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::IoError(e) => write!(f, "IOé”™è¯¯: {}", e),
            AppError::ParseError(e) => write!(f, "è§£æé”™è¯¯: {}", e),
            AppError::ValidationError(msg) => write!(f, "éªŒè¯é”™è¯¯: {}", msg),
            AppError::NetworkError { code, message } => {
                write!(f, "ç½‘ç»œé”™è¯¯({}): {}", code, message)
            }
        }
    }
}

impl std::error::Error for AppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            AppError::IoError(e) => Some(e),
            AppError::ParseError(e) => Some(e),
            _ => None,
        }
    }
}

// è‡ªåŠ¨è½¬æ¢
impl From<std::io::Error> for AppError {
    fn from(error: std::io::Error) -> Self {
        AppError::IoError(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::ParseError(error)
    }
}

fn main() -> Result<(), AppError> {
    let content = std::fs::read_to_string("file.txt")?;
    let number: i32 = content.trim().parse()?;
    
    if number < 0 {
        return Err(AppError::ValidationError("æ•°å­—ä¸èƒ½ä¸ºè´Ÿ".to_string()));
    }
    
    Ok(())
}
```

### ç»“æ„ä½“é”™è¯¯ç±»å‹

```rust
use std::{fmt, error::Error};

#[derive(Debug)]
struct ValidationError {
    field: String,
    message: String,
    value: String,
}

impl ValidationError {
    fn new(field: impl Into<String>, message: impl Into<String>, value: impl Into<String>) -> Self {
        ValidationError {
            field: field.into(),
            message: message.into(),
            value: value.into(),
        }
    }
}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "å­—æ®µ'{}': {} (å€¼: '{}')", 
               self.field, self.message, self.value)
    }
}

impl Error for ValidationError {}

fn validate_age(age: &str) -> Result<i32, ValidationError> {
    let age_num = age.parse::<i32>()
        .map_err(|_| ValidationError::new("age", "æ— æ•ˆçš„æ•°å­—", age))?;
    
    if age_num < 0 {
        return Err(ValidationError::new("age", "ä¸èƒ½ä¸ºè´Ÿæ•°", age));
    }
    
    if age_num > 150 {
        return Err(ValidationError::new("age", "è¶…å‡ºåˆç†èŒƒå›´", age));
    }
    
    Ok(age_num)
}

fn main() {
    match validate_age("200") {
        Ok(age) => println!("å¹´é¾„: {}", age),
        Err(e) => eprintln!("é”™è¯¯: {}", e),
    }
}
```

---

## 2. é”™è¯¯é“¾ä¸ä¸Šä¸‹æ–‡

### é”™è¯¯åŒ…è£…

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct WrappedError {
    context: String,
    source: Box<dyn Error + Send + Sync>,
}

impl WrappedError {
    fn new(context: impl Into<String>, source: impl Error + Send + Sync + 'static) -> Self {
        WrappedError {
            context: context.into(),
            source: Box::new(source),
        }
    }
}

impl fmt::Display for WrappedError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}: {}", self.context, self.source)
    }
}

impl Error for WrappedError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(self.source.as_ref())
    }
}

fn read_config() -> Result<String, WrappedError> {
    std::fs::read_to_string("config.toml")
        .map_err(|e| WrappedError::new("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥", e))
}

fn parse_config(content: &str) -> Result<i32, WrappedError> {
    content.trim().parse()
        .map_err(|e| WrappedError::new("è§£æé…ç½®å¤±è´¥", e))
}

fn main() {
    let result = read_config()
        .and_then(|content| parse_config(&content));
    
    if let Err(e) = result {
        eprintln!("é”™è¯¯: {}", e);
        
        // æ‰“å°é”™è¯¯é“¾
        let mut source = e.source();
        while let Some(err) = source {
            eprintln!("  ç”±: {}", err);
            source = err.source();
        }
    }
}
```

### ä½¿ç”¨anyhowå’Œthiserror

```rust
// ç¤ºä¾‹ä»£ç ï¼ˆéœ€è¦æ·»åŠ ä¾èµ–ï¼‰
/*
use anyhow::{Context, Result};

fn process_file(path: &str) -> Result<String> {
    let content = std::fs::read_to_string(path)
        .context(format!("æ— æ³•è¯»å–æ–‡ä»¶: {}", path))?;
    
    let trimmed = content.trim();
    if trimmed.is_empty() {
        anyhow::bail!("æ–‡ä»¶ä¸ºç©º");
    }
    
    Ok(trimmed.to_string())
}

// ä½¿ç”¨ thiserror å®šä¹‰é”™è¯¯
use thiserror::Error;

#[derive(Error, Debug)]
enum MyError {
    #[error("IOé”™è¯¯: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("è§£æé”™è¯¯: {0}")]
    Parse(#[from] std::num::ParseIntError),
    
    #[error("éªŒè¯å¤±è´¥: {0}")]
    Validation(String),
}
*/
```

---

## 3. é”™è¯¯è½¬æ¢ä¸ä¼ æ’­

### æ™ºèƒ½é”™è¯¯è½¬æ¢

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
enum DatabaseError {
    Connection(String),
    Query(String),
    NotFound,
}

impl fmt::Display for DatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DatabaseError::Connection(msg) => write!(f, "è¿æ¥é”™è¯¯: {}", msg),
            DatabaseError::Query(msg) => write!(f, "æŸ¥è¯¢é”™è¯¯: {}", msg),
            DatabaseError::NotFound => write!(f, "è®°å½•æœªæ‰¾åˆ°"),
        }
    }
}

impl Error for DatabaseError {}

#[derive(Debug)]
enum ServiceError {
    Database(DatabaseError),
    Validation(String),
    Unauthorized,
}

impl fmt::Display for ServiceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ServiceError::Database(e) => write!(f, "æ•°æ®åº“é”™è¯¯: {}", e),
            ServiceError::Validation(msg) => write!(f, "éªŒè¯é”™è¯¯: {}", msg),
            ServiceError::Unauthorized => write!(f, "æœªæˆæƒ"),
        }
    }
}

impl Error for ServiceError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            ServiceError::Database(e) => Some(e),
            _ => None,
        }
    }
}

impl From<DatabaseError> for ServiceError {
    fn from(error: DatabaseError) -> Self {
        ServiceError::Database(error)
    }
}

fn database_operation() -> Result<(), DatabaseError> {
    Err(DatabaseError::NotFound)
}

fn service_operation() -> Result<(), ServiceError> {
    database_operation()?;  // è‡ªåŠ¨è½¬æ¢
    Ok(())
}

fn main() {
    if let Err(e) = service_operation() {
        eprintln!("æœåŠ¡é”™è¯¯: {}", e);
    }
}
```

---

## 4. å¤šé”™è¯¯ç±»å‹å¤„ç†

### `Box<dyn Error>`

```rust
use std::error::Error;

fn process() -> Result<(), Box<dyn Error>> {
    let content = std::fs::read_to_string("file.txt")?;
    let number: i32 = content.trim().parse()?;
    println!("æ•°å­—: {}", number);
    Ok(())
}

fn main() {
    if let Err(e) = process() {
        eprintln!("é”™è¯¯: {}", e);
    }
}
```

### é”™è¯¯ç±»å‹æ“¦é™¤

```rust
type DynError = Box<dyn std::error::Error + Send + Sync>;

fn read_and_parse(path: &str) -> Result<i32, DynError> {
    let content = std::fs::read_to_string(path)?;
    let number = content.trim().parse()?;
    Ok(number)
}

fn main() {
    match read_and_parse("number.txt") {
        Ok(n) => println!("æ•°å­—: {}", n),
        Err(e) => eprintln!("é”™è¯¯: {}", e),
    }
}
```

---

## 5. å¼‚å¸¸å®‰å…¨æ€§

### RAII æ¨¡å¼

```rust
struct Resource {
    name: String,
}

impl Resource {
    fn new(name: impl Into<String>) -> Result<Self, String> {
        println!("è·å–èµ„æº: {}", name.into());
        Ok(Resource {
            name: name.into(),
        })
    }
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("é‡Šæ”¾èµ„æº: {}", self.name);
    }
}

fn process() -> Result<(), String> {
    let _r1 = Resource::new("resource1")?;
    let _r2 = Resource::new("resource2")?;
    
    // å‘ç”Ÿé”™è¯¯æ—¶ï¼ŒDrop è‡ªåŠ¨è°ƒç”¨
    Err("å¤„ç†å¤±è´¥".to_string())
}

fn main() {
    let _ = process();
    println!("ç»“æŸ");
}
```

### Panic å®‰å…¨

```rust
use std::panic;

fn risky_operation() {
    panic!("å‡ºé”™äº†ï¼");
}

fn safe_wrapper() -> Result<(), String> {
    match panic::catch_unwind(|| {
        risky_operation();
    }) {
        Ok(_) => Ok(()),
        Err(_) => Err("æ“ä½œpanic".to_string()),
    }
}

fn main() {
    match safe_wrapper() {
        Ok(_) => println!("æˆåŠŸ"),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

---

## 6. é”™è¯¯æ¢å¤ç­–ç•¥

### é‡è¯•æœºåˆ¶

```rust
fn retry<F, T, E>(mut operation: F, max_retries: u32) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    loop {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("é‡è¯• {}/{}", attempts, max_retries);
            },
            Err(e) => return Err(e),
        }
    }
}

fn unreliable_operation() -> Result<i32, String> {
    use std::sync::atomic::{AtomicU32, Ordering};
    static COUNTER: AtomicU32 = AtomicU32::new(0);
    
    let count = COUNTER.fetch_add(1, Ordering::SeqCst);
    if count < 2 {
        Err("å¤±è´¥".to_string())
    } else {
        Ok(42)
    }
}

fn main() {
    let result = retry(unreliable_operation, 3);
    println!("{:?}", result);
}
```

### é™çº§ç­–ç•¥

```rust
fn fetch_from_cache() -> Result<String, String> {
    Ok("ç¼“å­˜æ•°æ®".to_string())
}

fn fetch_from_database() -> Result<String, String> {
    Err("æ•°æ®åº“è¿æ¥å¤±è´¥".to_string())
}

fn fetch_with_fallback() -> Result<String, String> {
    fetch_from_database()
        .or_else(|_| {
            println!("æ•°æ®åº“å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜");
            fetch_from_cache()
        })
}

fn main() {
    match fetch_with_fallback() {
        Ok(data) => println!("æ•°æ®: {}", data),
        Err(e) => eprintln!("é”™è¯¯: {}", e),
    }
}
```

---

## 7. é”™è¯¯å¤„ç†æ€§èƒ½

### é¿å…ä¸å¿…è¦çš„åˆ†é…

```rust
// âŒ ä¸å¥½ï¼šæ¯æ¬¡éƒ½åˆ†é…String
fn bad_validate(value: i32) -> Result<i32, String> {
    if value < 0 {
        return Err(format!("å€¼ä¸èƒ½ä¸ºè´Ÿ: {}", value));
    }
    Ok(value)
}

// âœ… å¥½ï¼šä½¿ç”¨é™æ€å­—ç¬¦ä¸²
fn good_validate(value: i32) -> Result<i32, &'static str> {
    if value < 0 {
        return Err("å€¼ä¸èƒ½ä¸ºè´Ÿ");
    }
    Ok(value)
}

fn main() {
    println!("{:?}", good_validate(-5));
}
```

### ä½¿ç”¨Copyç±»å‹çš„é”™è¯¯

```rust
#[derive(Debug, Clone, Copy)]
enum SimpleError {
    InvalidInput,
    OutOfRange,
    NotFound,
}

// é›¶æˆæœ¬é”™è¯¯ä¼ é€’
fn process(value: i32) -> Result<i32, SimpleError> {
    if value < 0 {
        return Err(SimpleError::InvalidInput);
    }
    if value > 100 {
        return Err(SimpleError::OutOfRange);
    }
    Ok(value * 2)
}

fn main() {
    println!("{:?}", process(-5));
}
```

---

## 8. å®æˆ˜æ¨¡å¼

### åˆ†å±‚é”™è¯¯å¤„ç†

```rust
// åº•å±‚é”™è¯¯
mod database {
    use std::{fmt, error::Error};
    
    #[derive(Debug)]
    pub enum DbError {
        ConnectionFailed,
        QueryFailed(String),
    }
    
    impl fmt::Display for DbError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                DbError::ConnectionFailed => write!(f, "æ•°æ®åº“è¿æ¥å¤±è´¥"),
                DbError::QueryFailed(q) => write!(f, "æŸ¥è¯¢å¤±è´¥: {}", q),
            }
        }
    }
    
    impl Error for DbError {}
}

// ä¸­é—´å±‚é”™è¯¯
mod service {
    use super::database::DbError;
    use std::{fmt, error::Error};
    
    #[derive(Debug)]
    pub enum ServiceError {
        Database(DbError),
        BusinessLogic(String),
    }
    
    impl fmt::Display for ServiceError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                ServiceError::Database(e) => write!(f, "æœåŠ¡æ•°æ®åº“é”™è¯¯: {}", e),
                ServiceError::BusinessLogic(msg) => write!(f, "ä¸šåŠ¡é€»è¾‘é”™è¯¯: {}", msg),
            }
        }
    }
    
    impl Error for ServiceError {}
    
    impl From<DbError> for ServiceError {
        fn from(error: DbError) -> Self {
            ServiceError::Database(error)
        }
    }
}

// APIå±‚é”™è¯¯
mod api {
    use super::service::ServiceError;
    use std::{fmt, error::Error};
    
    #[derive(Debug)]
    pub struct ApiError {
        pub code: u16,
        pub message: String,
    }
    
    impl fmt::Display for ApiError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "APIé”™è¯¯({}): {}", self.code, self.message)
        }
    }
    
    impl Error for ApiError {}
    
    impl From<ServiceError> for ApiError {
        fn from(error: ServiceError) -> Self {
            ApiError {
                code: 500,
                message: error.to_string(),
            }
        }
    }
}

fn main() {
    println!("åˆ†å±‚é”™è¯¯å¤„ç†ç¤ºä¾‹");
}
```

### é”™è¯¯æ—¥å¿—è®°å½•

```rust
use std::error::Error;

fn log_error(error: &dyn Error) {
    eprintln!("ERROR: {}", error);
    
    let mut source = error.source();
    while let Some(err) = source {
        eprintln!("  caused by: {}", err);
        source = err.source();
    }
}

fn operation() -> Result<(), Box<dyn Error>> {
    Err("æ“ä½œå¤±è´¥")?
}

fn main() {
    if let Err(e) = operation() {
        log_error(e.as_ref());
    }
}
```

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ’¡ æ„å»ºå¥å£®çš„é”™è¯¯å¤„ç†ç³»ç»Ÿï¼Œè®©Ruståº”ç”¨æ›´å¯é ï¼** ğŸ¦€âœ¨
