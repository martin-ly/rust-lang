# 4.4 错误处理进阶

> **文档类型**: Tier 4 - 高级层
> **文档定位**: Rust错误处理的高级模式和最佳实践
> **适用对象**: 需要构建健壮错误处理系统的高级开发者
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [错误处理指南](../tier_02_guides/05_错误处理指南.md)

**最后更新**: 2025-10-22
**适用版本**: Rust 1.90+
**文档版本**: v2025.1.0

---

## 📋 目录

- [4.4 错误处理进阶](#44-错误处理进阶)
  - [📋 目录](#-目录)
  - [1. 自定义错误类型](#1-自定义错误类型)
    - [枚举错误类型](#枚举错误类型)
    - [结构体错误类型](#结构体错误类型)
  - [2. 错误链与上下文](#2-错误链与上下文)
    - [错误包装](#错误包装)
    - [使用anyhow和thiserror](#使用anyhow和thiserror)
  - [3. 错误转换与传播](#3-错误转换与传播)
    - [智能错误转换](#智能错误转换)
  - [4. 多错误类型处理](#4-多错误类型处理)
    - [`Box<dyn Error>`](#boxdyn-error)
    - [错误类型擦除](#错误类型擦除)
  - [5. 异常安全性](#5-异常安全性)
    - [RAII 模式](#raii-模式)
    - [Panic 安全](#panic-安全)
  - [6. 错误恢复策略](#6-错误恢复策略)
    - [重试机制](#重试机制)
    - [降级策略](#降级策略)
  - [7. 错误处理性能](#7-错误处理性能)
    - [避免不必要的分配](#避免不必要的分配)
    - [使用Copy类型的错误](#使用copy类型的错误)
  - [8. 实战模式](#8-实战模式)
    - [分层错误处理](#分层错误处理)
    - [错误日志记录](#错误日志记录)

---

## 1. 自定义错误类型

### 枚举错误类型

```rust
use std::fmt;

#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    ValidationError(String),
    NetworkError { code: u16, message: String },
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::IoError(e) => write!(f, "IO错误: {}", e),
            AppError::ParseError(e) => write!(f, "解析错误: {}", e),
            AppError::ValidationError(msg) => write!(f, "验证错误: {}", msg),
            AppError::NetworkError { code, message } => {
                write!(f, "网络错误({}): {}", code, message)
            }
        }
    }
}

impl std::error::Error for AppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            AppError::IoError(e) => Some(e),
            AppError::ParseError(e) => Some(e),
            _ => None,
        }
    }
}

// 自动转换
impl From<std::io::Error> for AppError {
    fn from(error: std::io::Error) -> Self {
        AppError::IoError(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::ParseError(error)
    }
}

fn main() -> Result<(), AppError> {
    let content = std::fs::read_to_string("file.txt")?;
    let number: i32 = content.trim().parse()?;

    if number < 0 {
        return Err(AppError::ValidationError("数字不能为负".to_string()));
    }

    Ok(())
}
```

### 结构体错误类型

```rust
use std::{fmt, error::Error};

#[derive(Debug)]
struct ValidationError {
    field: String,
    message: String,
    value: String,
}

impl ValidationError {
    fn new(field: impl Into<String>, message: impl Into<String>, value: impl Into<String>) -> Self {
        ValidationError {
            field: field.into(),
            message: message.into(),
            value: value.into(),
        }
    }
}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "字段'{}': {} (值: '{}')",
               self.field, self.message, self.value)
    }
}

impl Error for ValidationError {}

fn validate_age(age: &str) -> Result<i32, ValidationError> {
    let age_num = age.parse::<i32>()
        .map_err(|_| ValidationError::new("age", "无效的数字", age))?;

    if age_num < 0 {
        return Err(ValidationError::new("age", "不能为负数", age));
    }

    if age_num > 150 {
        return Err(ValidationError::new("age", "超出合理范围", age));
    }

    Ok(age_num)
}

fn main() {
    match validate_age("200") {
        Ok(age) => println!("年龄: {}", age),
        Err(e) => eprintln!("错误: {}", e),
    }
}
```

---

## 2. 错误链与上下文

### 错误包装

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct WrappedError {
    context: String,
    source: Box<dyn Error + Send + Sync>,
}

impl WrappedError {
    fn new(context: impl Into<String>, source: impl Error + Send + Sync + 'static) -> Self {
        WrappedError {
            context: context.into(),
            source: Box::new(source),
        }
    }
}

impl fmt::Display for WrappedError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}: {}", self.context, self.source)
    }
}

impl Error for WrappedError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(self.source.as_ref())
    }
}

fn read_config() -> Result<String, WrappedError> {
    std::fs::read_to_string("config.toml")
        .map_err(|e| WrappedError::new("读取配置文件失败", e))
}

fn parse_config(content: &str) -> Result<i32, WrappedError> {
    content.trim().parse()
        .map_err(|e| WrappedError::new("解析配置失败", e))
}

fn main() {
    let result = read_config()
        .and_then(|content| parse_config(&content));

    if let Err(e) = result {
        eprintln!("错误: {}", e);

        // 打印错误链
        let mut source = e.source();
        while let Some(err) = source {
            eprintln!("  由: {}", err);
            source = err.source();
        }
    }
}
```

### 使用anyhow和thiserror

```rust
// 示例代码（需要添加依赖）
/*
use anyhow::{Context, Result};

fn process_file(path: &str) -> Result<String> {
    let content = std::fs::read_to_string(path)
        .context(format!("无法读取文件: {}", path))?;

    let trimmed = content.trim();
    if trimmed.is_empty() {
        anyhow::bail!("文件为空");
    }

    Ok(trimmed.to_string())
}

// 使用 thiserror 定义错误
use thiserror::Error;

#[derive(Error, Debug)]
enum MyError {
    #[error("IO错误: {0}")]
    Io(#[from] std::io::Error),

    #[error("解析错误: {0}")]
    Parse(#[from] std::num::ParseIntError),

    #[error("验证失败: {0}")]
    Validation(String),
}
*/
```

---

## 3. 错误转换与传播

### 智能错误转换

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
enum DatabaseError {
    Connection(String),
    Query(String),
    NotFound,
}

impl fmt::Display for DatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DatabaseError::Connection(msg) => write!(f, "连接错误: {}", msg),
            DatabaseError::Query(msg) => write!(f, "查询错误: {}", msg),
            DatabaseError::NotFound => write!(f, "记录未找到"),
        }
    }
}

impl Error for DatabaseError {}

#[derive(Debug)]
enum ServiceError {
    Database(DatabaseError),
    Validation(String),
    Unauthorized,
}

impl fmt::Display for ServiceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ServiceError::Database(e) => write!(f, "数据库错误: {}", e),
            ServiceError::Validation(msg) => write!(f, "验证错误: {}", msg),
            ServiceError::Unauthorized => write!(f, "未授权"),
        }
    }
}

impl Error for ServiceError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            ServiceError::Database(e) => Some(e),
            _ => None,
        }
    }
}

impl From<DatabaseError> for ServiceError {
    fn from(error: DatabaseError) -> Self {
        ServiceError::Database(error)
    }
}

fn database_operation() -> Result<(), DatabaseError> {
    Err(DatabaseError::NotFound)
}

fn service_operation() -> Result<(), ServiceError> {
    database_operation()?;  // 自动转换
    Ok(())
}

fn main() {
    if let Err(e) = service_operation() {
        eprintln!("服务错误: {}", e);
    }
}
```

---

## 4. 多错误类型处理

### `Box<dyn Error>`

```rust
use std::error::Error;

fn process() -> Result<(), Box<dyn Error>> {
    let content = std::fs::read_to_string("file.txt")?;
    let number: i32 = content.trim().parse()?;
    println!("数字: {}", number);
    Ok(())
}

fn main() {
    if let Err(e) = process() {
        eprintln!("错误: {}", e);
    }
}
```

### 错误类型擦除

```rust
type DynError = Box<dyn std::error::Error + Send + Sync>;

fn read_and_parse(path: &str) -> Result<i32, DynError> {
    let content = std::fs::read_to_string(path)?;
    let number = content.trim().parse()?;
    Ok(number)
}

fn main() {
    match read_and_parse("number.txt") {
        Ok(n) => println!("数字: {}", n),
        Err(e) => eprintln!("错误: {}", e),
    }
}
```

---

## 5. 异常安全性

### RAII 模式

```rust
struct Resource {
    name: String,
}

impl Resource {
    fn new(name: impl Into<String>) -> Result<Self, String> {
        println!("获取资源: {}", name.into());
        Ok(Resource {
            name: name.into(),
        })
    }
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("释放资源: {}", self.name);
    }
}

fn process() -> Result<(), String> {
    let _r1 = Resource::new("resource1")?;
    let _r2 = Resource::new("resource2")?;

    // 发生错误时，Drop 自动调用
    Err("处理失败".to_string())
}

fn main() {
    let _ = process();
    println!("结束");
}
```

### Panic 安全

```rust
use std::panic;

fn risky_operation() {
    panic!("出错了！");
}

fn safe_wrapper() -> Result<(), String> {
    match panic::catch_unwind(|| {
        risky_operation();
    }) {
        Ok(_) => Ok(()),
        Err(_) => Err("操作panic".to_string()),
    }
}

fn main() {
    match safe_wrapper() {
        Ok(_) => println!("成功"),
        Err(e) => println!("错误: {}", e),
    }
}
```

---

## 6. 错误恢复策略

### 重试机制

```rust
fn retry<F, T, E>(mut operation: F, max_retries: u32) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    loop {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("重试 {}/{}", attempts, max_retries);
            },
            Err(e) => return Err(e),
        }
    }
}

fn unreliable_operation() -> Result<i32, String> {
    use std::sync::atomic::{AtomicU32, Ordering};
    static COUNTER: AtomicU32 = AtomicU32::new(0);

    let count = COUNTER.fetch_add(1, Ordering::SeqCst);
    if count < 2 {
        Err("失败".to_string())
    } else {
        Ok(42)
    }
}

fn main() {
    let result = retry(unreliable_operation, 3);
    println!("{:?}", result);
}
```

### 降级策略

```rust
fn fetch_from_cache() -> Result<String, String> {
    Ok("缓存数据".to_string())
}

fn fetch_from_database() -> Result<String, String> {
    Err("数据库连接失败".to_string())
}

fn fetch_with_fallback() -> Result<String, String> {
    fetch_from_database()
        .or_else(|_| {
            println!("数据库失败，使用缓存");
            fetch_from_cache()
        })
}

fn main() {
    match fetch_with_fallback() {
        Ok(data) => println!("数据: {}", data),
        Err(e) => eprintln!("错误: {}", e),
    }
}
```

---

## 7. 错误处理性能

### 避免不必要的分配

```rust
// ❌ 不好：每次都分配String
fn bad_validate(value: i32) -> Result<i32, String> {
    if value < 0 {
        return Err(format!("值不能为负: {}", value));
    }
    Ok(value)
}

// ✅ 好：使用静态字符串
fn good_validate(value: i32) -> Result<i32, &'static str> {
    if value < 0 {
        return Err("值不能为负");
    }
    Ok(value)
}

fn main() {
    println!("{:?}", good_validate(-5));
}
```

### 使用Copy类型的错误

```rust
#[derive(Debug, Clone, Copy)]
enum SimpleError {
    InvalidInput,
    OutOfRange,
    NotFound,
}

// 零成本错误传递
fn process(value: i32) -> Result<i32, SimpleError> {
    if value < 0 {
        return Err(SimpleError::InvalidInput);
    }
    if value > 100 {
        return Err(SimpleError::OutOfRange);
    }
    Ok(value * 2)
}

fn main() {
    println!("{:?}", process(-5));
}
```

---

## 8. 实战模式

### 分层错误处理

```rust
// 底层错误
mod database {
    use std::{fmt, error::Error};

    #[derive(Debug)]
    pub enum DbError {
        ConnectionFailed,
        QueryFailed(String),
    }

    impl fmt::Display for DbError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                DbError::ConnectionFailed => write!(f, "数据库连接失败"),
                DbError::QueryFailed(q) => write!(f, "查询失败: {}", q),
            }
        }
    }

    impl Error for DbError {}
}

// 中间层错误
mod service {
    use super::database::DbError;
    use std::{fmt, error::Error};

    #[derive(Debug)]
    pub enum ServiceError {
        Database(DbError),
        BusinessLogic(String),
    }

    impl fmt::Display for ServiceError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                ServiceError::Database(e) => write!(f, "服务数据库错误: {}", e),
                ServiceError::BusinessLogic(msg) => write!(f, "业务逻辑错误: {}", msg),
            }
        }
    }

    impl Error for ServiceError {}

    impl From<DbError> for ServiceError {
        fn from(error: DbError) -> Self {
            ServiceError::Database(error)
        }
    }
}

// API层错误
mod api {
    use super::service::ServiceError;
    use std::{fmt, error::Error};

    #[derive(Debug)]
    pub struct ApiError {
        pub code: u16,
        pub message: String,
    }

    impl fmt::Display for ApiError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "API错误({}): {}", self.code, self.message)
        }
    }

    impl Error for ApiError {}

    impl From<ServiceError> for ApiError {
        fn from(error: ServiceError) -> Self {
            ApiError {
                code: 500,
                message: error.to_string(),
            }
        }
    }
}

fn main() {
    println!("分层错误处理示例");
}
```

### 错误日志记录

```rust
use std::error::Error;

fn log_error(error: &dyn Error) {
    eprintln!("ERROR: {}", error);

    let mut source = error.source();
    while let Some(err) = source {
        eprintln!("  caused by: {}", err);
        source = err.source();
    }
}

fn operation() -> Result<(), Box<dyn Error>> {
    Err("操作失败")?
}

fn main() {
    if let Err(e) = operation() {
        log_error(e.as_ref());
    }
}
```

---

**最后更新**: 2025-10-22
**文档版本**: v2025.1.0
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**💡 构建健壮的错误处理系统，让Rust应用更可靠！** 🦀✨
