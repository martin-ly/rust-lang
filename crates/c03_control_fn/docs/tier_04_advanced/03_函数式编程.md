# 4.3 å‡½æ•°å¼ç¼–ç¨‹

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§å±‚  
> **æ–‡æ¡£å®šä½**: Rustä¸­çš„å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼å’ŒæŠ€å·§  
> **é€‚ç”¨å¯¹è±¡**: å¸Œæœ›ä½¿ç”¨å‡½æ•°å¼é£æ ¼ç¼–å†™Rustä»£ç çš„å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [å‡½æ•°ç³»ç»ŸæŒ‡å—](../tier_02_guides/03_å‡½æ•°ç³»ç»ŸæŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [4.3 å‡½æ•°å¼ç¼–ç¨‹](#43-å‡½æ•°å¼ç¼–ç¨‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ä¸å¯å˜æ€§ä¸çº¯å‡½æ•°](#1-ä¸å¯å˜æ€§ä¸çº¯å‡½æ•°)
    - [çº¯å‡½æ•°è®¾è®¡](#çº¯å‡½æ•°è®¾è®¡)
    - [æŒä¹…åŒ–æ•°æ®ç»“æ„](#æŒä¹…åŒ–æ•°æ®ç»“æ„)
  - [2. é«˜é˜¶å‡½æ•°](#2-é«˜é˜¶å‡½æ•°)
    - [map/filter/reduce æ¨¡å¼](#mapfilterreduce-æ¨¡å¼)
    - [è‡ªå®šä¹‰é«˜é˜¶å‡½æ•°](#è‡ªå®šä¹‰é«˜é˜¶å‡½æ•°)
  - [3. å‡½å­ä¸å•å­](#3-å‡½å­ä¸å•å­)
    - [Functor (å‡½å­)](#functor-å‡½å­)
    - [Monad (å•å­)](#monad-å•å­)
    - [Maybe Monad æ¨¡å¼](#maybe-monad-æ¨¡å¼)
  - [4. å‡½æ•°ç»„åˆ](#4-å‡½æ•°ç»„åˆ)
    - [åŸºç¡€ç»„åˆ](#åŸºç¡€ç»„åˆ)
    - [ç‚¹è‡ªç”±é£æ ¼ï¼ˆPoint-Free Styleï¼‰](#ç‚¹è‡ªç”±é£æ ¼point-free-style)
  - [5. æƒ°æ€§æ±‚å€¼](#5-æƒ°æ€§æ±‚å€¼)
    - [è¿­ä»£å™¨æƒ°æ€§](#è¿­ä»£å™¨æƒ°æ€§)
    - [è‡ªå®šä¹‰æƒ°æ€§ç»“æ„](#è‡ªå®šä¹‰æƒ°æ€§ç»“æ„)
  - [6. é€’å½’ä¸å°¾é€’å½’](#6-é€’å½’ä¸å°¾é€’å½’)
    - [é€’å½’æ¨¡å¼](#é€’å½’æ¨¡å¼)
    - [ç›¸äº’é€’å½’](#ç›¸äº’é€’å½’)
  - [7. ä»£æ•°æ•°æ®ç±»å‹](#7-ä»£æ•°æ•°æ®ç±»å‹)
    - [å’Œç±»å‹ï¼ˆSum Typesï¼‰](#å’Œç±»å‹sum-types)
    - [ç§¯ç±»å‹ï¼ˆProduct Typesï¼‰](#ç§¯ç±»å‹product-types)
  - [8. å®æˆ˜æ¨¡å¼](#8-å®æˆ˜æ¨¡å¼)
    - [Railway-Oriented Programming](#railway-oriented-programming)
    - [æµå¼æ•°æ®å¤„ç†](#æµå¼æ•°æ®å¤„ç†)
    - [å‡½æ•°å¼é”™è¯¯å¤„ç†é“¾](#å‡½æ•°å¼é”™è¯¯å¤„ç†é“¾)

---

## 1. ä¸å¯å˜æ€§ä¸çº¯å‡½æ•°

### çº¯å‡½æ•°è®¾è®¡

```rust
// âœ… çº¯å‡½æ•°ï¼šæ— å‰¯ä½œç”¨ï¼Œç¡®å®šæ€§è¾“å‡º
fn pure_add(a: i32, b: i32) -> i32 {
    a + b
}

// âœ… çº¯å‡½æ•°ï¼šä¸ä¿®æ”¹è¾“å…¥
fn pure_filter(numbers: &[i32], threshold: i32) -> Vec<i32> {
    numbers.iter()
        .filter(|&&x| x > threshold)
        .copied()
        .collect()
}

// âŒ éçº¯å‡½æ•°ï¼šæœ‰å‰¯ä½œç”¨
fn impure_add(a: i32, b: i32) -> i32 {
    println!("Adding {} + {}", a, b);  // å‰¯ä½œç”¨
    a + b
}

fn main() {
    assert_eq!(pure_add(2, 3), 5);
    
    let numbers = vec![1, 2, 3, 4, 5];
    let filtered = pure_filter(&numbers, 2);
    assert_eq!(filtered, vec![3, 4, 5]);
    
    // numbers æœªè¢«ä¿®æ”¹
    assert_eq!(numbers, vec![1, 2, 3, 4, 5]);
}
```

### æŒä¹…åŒ–æ•°æ®ç»“æ„

```rust
use std::rc::Rc;

#[derive(Debug, Clone)]
struct List<T> {
    head: Option<Rc<Node<T>>>,
}

#[derive(Debug)]
struct Node<T> {
    value: T,
    next: Option<Rc<Node<T>>>,
}

impl<T> List<T> {
    fn new() -> Self {
        List { head: None }
    }
    
    fn prepend(&self, value: T) -> Self {
        List {
            head: Some(Rc::new(Node {
                value,
                next: self.head.clone(),
            })),
        }
    }
    
    fn head(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.value)
    }
    
    fn tail(&self) -> Self {
        List {
            head: self.head.as_ref()
                .and_then(|node| node.next.clone()),
        }
    }
}

fn main() {
    let list1 = List::new().prepend(1).prepend(2).prepend(3);
    let list2 = list1.prepend(4);
    
    println!("list1 head: {:?}", list1.head());  // Some(3)
    println!("list2 head: {:?}", list2.head());  // Some(4)
}
```

---

## 2. é«˜é˜¶å‡½æ•°

### map/filter/reduce æ¨¡å¼

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // Map: è½¬æ¢
    let doubled: Vec<_> = numbers.iter()
        .map(|x| x * 2)
        .collect();
    
    // Filter: è¿‡æ»¤
    let even: Vec<_> = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .collect();
    
    // Reduce: èšåˆ
    let sum: i32 = numbers.iter().sum();
    let product: i32 = numbers.iter().product();
    
    // ç»„åˆ
    let result: i32 = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * x)
        .sum();
    
    println!("doubled: {:?}", doubled);
    println!("even: {:?}", even);
    println!("sum: {}, product: {}", sum, product);
    println!("result: {}", result);
}
```

### è‡ªå®šä¹‰é«˜é˜¶å‡½æ•°

```rust
fn map<T, U, F>(items: Vec<T>, f: F) -> Vec<U>
where
    F: Fn(T) -> U,
{
    items.into_iter().map(f).collect()
}

fn filter<T, F>(items: Vec<T>, predicate: F) -> Vec<T>
where
    F: Fn(&T) -> bool,
{
    items.into_iter().filter(|item| predicate(item)).collect()
}

fn fold<T, U, F>(items: Vec<T>, init: U, f: F) -> U
where
    F: Fn(U, T) -> U,
{
    items.into_iter().fold(init, f)
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    let doubled = map(numbers.clone(), |x| x * 2);
    let even = filter(numbers.clone(), |x| x % 2 == 0);
    let sum = fold(numbers, 0, |acc, x| acc + x);
    
    println!("{:?}, {:?}, {}", doubled, even, sum);
}
```

---

## 3. å‡½å­ä¸å•å­

### Functor (å‡½å­)

```rust
trait Functor<A> {
    type Output<B>;
    fn fmap<B, F>(self, f: F) -> Self::Output<B>
    where
        F: Fn(A) -> B;
}

// Option æ˜¯å‡½å­
impl<A> Functor<A> for Option<A> {
    type Output<B> = Option<B>;
    
    fn fmap<B, F>(self, f: F) -> Option<B>
    where
        F: Fn(A) -> B,
    {
        self.map(f)
    }
}

fn main() {
    let some_value = Some(42);
    let mapped = some_value.fmap(|x| x * 2);
    println!("{:?}", mapped);  // Some(84)
}
```

### Monad (å•å­)

```rust
trait Monad<A>: Sized {
    fn unit(value: A) -> Self;
    fn bind<B, F>(self, f: F) -> Self::Output<B>
    where
        F: Fn(A) -> Self::Output<B>;
    
    type Output<B>: Monad<B>;
}

// Option ä½œä¸ºå•å­
impl<A> Monad<A> for Option<A> {
    type Output<B> = Option<B>;
    
    fn unit(value: A) -> Self {
        Some(value)
    }
    
    fn bind<B, F>(self, f: F) -> Option<B>
    where
        F: Fn(A) -> Option<B>,
    {
        self.and_then(f)
    }
}

fn main() {
    let result = Option::unit(10)
        .bind(|x| Some(x + 5))
        .bind(|x| if x > 10 { Some(x * 2) } else { None });
    
    println!("{:?}", result);  // Some(30)
}
```

### Maybe Monad æ¨¡å¼

```rust
fn safe_divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}

fn safe_sqrt(x: f64) -> Option<f64> {
    if x < 0.0 {
        None
    } else {
        Some(x.sqrt())
    }
}

fn main() {
    // é“¾å¼è®¡ç®—
    let result = Some(100.0)
        .and_then(|x| safe_divide(x, 4.0))
        .and_then(|x| safe_sqrt(x));
    
    println!("{:?}", result);  // Some(5.0)
    
    // ä¸­é€”å¤±è´¥
    let failed = Some(-100.0)
        .and_then(|x| safe_divide(x, 4.0))
        .and_then(|x| safe_sqrt(x));  // å¤±è´¥åœ¨è¿™é‡Œ
    
    println!("{:?}", failed);  // None
}
```

---

## 4. å‡½æ•°ç»„åˆ

### åŸºç¡€ç»„åˆ

```rust
fn compose<A, B, C, F, G>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

fn pipe<A, B, C, F, G>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

fn main() {
    let add_one = |x: i32| x + 1;
    let double = |x: i32| x * 2;
    let square = |x: i32| x * x;
    
    // ç»„åˆï¼šå…ˆdoubleå†add_one
    let f = compose(double, add_one);
    println!("{}", f(5));  // 11
    
    // ç®¡é“ï¼šå…ˆadd_oneå†double
    let g = pipe(add_one, double);
    println!("{}", g(5));  // 12
    
    // å¤šé‡ç»„åˆ
    let h = compose(add_one, compose(double, square));
    println!("{}", h(3));  // 37 ((3+1)*2)^2
}
```

### ç‚¹è‡ªç”±é£æ ¼ï¼ˆPoint-Free Styleï¼‰

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // ä¼ ç»Ÿé£æ ¼
    let result1: Vec<_> = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * x)
        .collect();
    
    // ç‚¹è‡ªç”±é£æ ¼
    fn is_even(x: &&i32) -> bool { **x % 2 == 0 }
    fn square(x: &i32) -> i32 { x * x }
    
    let result2: Vec<_> = numbers.iter()
        .filter(is_even)
        .map(square)
        .collect();
    
    assert_eq!(result1, result2);
}
```

---

## 5. æƒ°æ€§æ±‚å€¼

### è¿­ä»£å™¨æƒ°æ€§

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // åˆ›å»ºè¿­ä»£å™¨ï¼ˆæƒ°æ€§ï¼‰
    let iter = numbers.iter()
        .inspect(|x| println!("mapå‰: {}", x))
        .map(|x| {
            println!("æ˜ å°„: {}", x);
            x * 2
        })
        .inspect(|x| println!("filterå‰: {}", x))
        .filter(|&&x| {
            println!("è¿‡æ»¤: {}", x);
            x > 5
        });
    
    println!("è¿­ä»£å™¨åˆ›å»ºå®Œæˆ");
    
    // æ¶ˆè´¹è¿­ä»£å™¨ï¼ˆè§¦å‘è®¡ç®—ï¼‰
    let result: Vec<_> = iter.collect();
    println!("ç»“æœ: {:?}", result);
}
```

### è‡ªå®šä¹‰æƒ°æ€§ç»“æ„

```rust
struct LazySeq<T, F>
where
    F: Fn(usize) -> T,
{
    generator: F,
}

impl<T, F> LazySeq<T, F>
where
    F: Fn(usize) -> T,
{
    fn new(generator: F) -> Self {
        LazySeq { generator }
    }
    
    fn take(&self, n: usize) -> Vec<T> {
        (0..n).map(|i| (self.generator)(i)).collect()
    }
}

fn main() {
    // æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆæƒ°æ€§ç”Ÿæˆï¼‰
    let fib = LazySeq::new(|n| {
        match n {
            0 => 0,
            1 => 1,
            n => {
                // ç®€åŒ–ç‰ˆæœ¬ï¼ˆå®é™…éœ€è¦ç¼“å­˜ï¼‰
                n
            }
        }
    });
    
    println!("{:?}", fib.take(10));
}
```

---

## 6. é€’å½’ä¸å°¾é€’å½’

### é€’å½’æ¨¡å¼

```rust
// æ ‡å‡†é€’å½’
fn factorial(n: u64) -> u64 {
    match n {
        0 => 1,
        n => n * factorial(n - 1),
    }
}

// å°¾é€’å½’ä¼˜åŒ–
fn factorial_tail(n: u64) -> u64 {
    fn helper(n: u64, acc: u64) -> u64 {
        match n {
            0 => acc,
            n => helper(n - 1, n * acc),
        }
    }
    helper(n, 1)
}

fn main() {
    println!("{}", factorial(5));
    println!("{}", factorial_tail(5));
}
```

### ç›¸äº’é€’å½’

```rust
fn is_even(n: u32) -> bool {
    match n {
        0 => true,
        n => is_odd(n - 1),
    }
}

fn is_odd(n: u32) -> bool {
    match n {
        0 => false,
        n => is_even(n - 1),
    }
}

fn main() {
    println!("4 is even: {}", is_even(4));
    println!("5 is odd: {}", is_odd(5));
}
```

---

## 7. ä»£æ•°æ•°æ®ç±»å‹

### å’Œç±»å‹ï¼ˆSum Typesï¼‰

```rust
// æšä¸¾æ˜¯å’Œç±»å‹
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
    Triangle(f64, f64, f64),
}

fn area(shape: &Shape) -> f64 {
    match shape {
        Shape::Circle(r) => std::f64::consts::PI * r * r,
        Shape::Rectangle(w, h) => w * h,
        Shape::Triangle(a, b, c) => {
            let s = (a + b + c) / 2.0;
            (s * (s - a) * (s - b) * (s - c)).sqrt()
        },
    }
}

fn main() {
    let circle = Shape::Circle(5.0);
    let rect = Shape::Rectangle(3.0, 4.0);
    
    println!("Circle area: {}", area(&circle));
    println!("Rectangle area: {}", area(&rect));
}
```

### ç§¯ç±»å‹ï¼ˆProduct Typesï¼‰

```rust
// ç»“æ„ä½“æ˜¯ç§¯ç±»å‹
struct Point {
    x: f64,
    y: f64,
}

struct Color {
    r: u8,
    g: u8,
    b: u8,
}

// ç§¯ç±»å‹ç»„åˆ
struct ColoredPoint {
    point: Point,
    color: Color,
}

fn main() {
    let cp = ColoredPoint {
        point: Point { x: 10.0, y: 20.0 },
        color: Color { r: 255, g: 0, b: 0 },
    };
    
    println!("Point: ({}, {})", cp.point.x, cp.point.y);
}
```

---

## 8. å®æˆ˜æ¨¡å¼

### Railway-Oriented Programming

```rust
type Result<T> = std::result::Result<T, String>;

fn validate_age(age: i32) -> Result<i32> {
    if age < 0 {
        Err("å¹´é¾„ä¸èƒ½ä¸ºè´Ÿ".to_string())
    } else if age > 150 {
        Err("å¹´é¾„ä¸åˆç†".to_string())
    } else {
        Ok(age)
    }
}

fn calculate_category(age: i32) -> Result<String> {
    Ok(match age {
        0..=12 => "å„¿ç«¥",
        13..=17 => "é’å°‘å¹´",
        18..=59 => "æˆå¹´äºº",
        _ => "è€å¹´äºº",
    }.to_string())
}

fn format_result(category: String) -> Result<String> {
    Ok(format!("åˆ†ç±»: {}", category))
}

fn main() {
    let process = |age| {
        validate_age(age)
            .and_then(calculate_category)
            .and_then(format_result)
    };
    
    println!("{:?}", process(25));    // Ok("åˆ†ç±»: æˆå¹´äºº")
    println!("{:?}", process(-5));    // Err("å¹´é¾„ä¸èƒ½ä¸ºè´Ÿ")
    println!("{:?}", process(200));   // Err("å¹´é¾„ä¸åˆç†")
}
```

### æµå¼æ•°æ®å¤„ç†

```rust
fn main() {
    let data = vec![
        ("Alice", 25),
        ("Bob", 30),
        ("Charlie", 35),
        ("David", 40),
    ];
    
    let result: Vec<_> = data.iter()
        .filter(|(_, age)| *age >= 30)
        .map(|(name, age)| (name.to_uppercase(), age + 10))
        .collect();
    
    println!("{:?}", result);
}
```

### å‡½æ•°å¼é”™è¯¯å¤„ç†é“¾

```rust
fn parse_int(s: &str) -> Option<i32> {
    s.parse().ok()
}

fn double(x: i32) -> Option<i32> {
    Some(x * 2)
}

fn validate(x: i32) -> Option<i32> {
    if x > 100 {
        None
    } else {
        Some(x)
    }
}

fn main() {
    let result = Some("42")
        .and_then(parse_int)
        .and_then(double)
        .and_then(validate);
    
    println!("{:?}", result);  // Some(84)
    
    let failed = Some("50")
        .and_then(parse_int)
        .and_then(double)
        .and_then(validate);
    
    println!("{:?}", failed);  // None (100 > 100)
}
```

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ¯ æ‹¥æŠ±å‡½æ•°å¼ç¼–ç¨‹ï¼Œç¼–å†™æ›´ç®€æ´ã€æ›´å¯é çš„Rustä»£ç ï¼** ğŸ¦€âœ¨
