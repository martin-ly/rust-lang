# 控制流性能与工程准则（覆盖至 Rust 1.90）

本篇总结分支与数据流的性能经验：分支预测友好、无分支技巧、迭代器链与手写循环的权衡、错误处理的早退路径布局。

## 分支预测与布局

- 将“常见路径”放在前面（早返回或直接走主干）；
- 对热点函数启用 `#[inline]` 建议，交由编译器决策。

```rust
#[inline]
fn classify(x: i32) -> i32 {
    if x == 0 { return 0; }
    if x > 0 { 1 } else { -1 }
}
```

## 无分支技巧（仅在确有收益时）

```rust
fn abs_i32(x: i32) -> i32 { if x >= 0 { x } else { -x } }
```

- 对现代编译器而言，清晰的分支往往更易优化；
- 使用 `select` 风格或位运算前先做基准。

## 迭代器链 vs 手写循环

- 迭代器链表达力强、易组合；
- 手写循环便于微调内层控制流与缓存局部性；
- 用基准来决定，两者性能常接近。

## 错误处理与早退

- 失败尽早返回（`let-else`、`?`、`try`）；
- 避免深层嵌套；
- 错误映射集中在边界层。

---

工程建议：

- 先写清晰可读的控制流，再用基准定位优化点；
- 对热路径减少分配与拷贝；
- 使用 `cargo bench`/`criterion` 进行对比评估。
