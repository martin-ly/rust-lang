# ğŸ’» C03: æ§åˆ¶æµä¸å‡½æ•° - ä»£ç ç¤ºä¾‹é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **éš¾åº¦**: â­ åŸºç¡€ â†’ â­â­â­ è¿›é˜¶
> **ç›®æ ‡**: é€šè¿‡ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹æ·±å…¥ç†è§£æ§åˆ¶æµå’Œå‡½æ•°ç³»ç»Ÿ

---

## ğŸ“Š ç›®å½•

- [ğŸ’» C03: æ§åˆ¶æµä¸å‡½æ•° - ä»£ç ç¤ºä¾‹é›†åˆ](#-c03-æ§åˆ¶æµä¸å‡½æ•°---ä»£ç ç¤ºä¾‹é›†åˆ)
  - [ğŸ“Š ç›®å½•](#-ç›®å½•)
  - [ğŸ“‹ ç¤ºä¾‹å¯¼èˆª](#-ç¤ºä¾‹å¯¼èˆª)
  - [ğŸŒŸ Tier 1: åŸºç¡€æ§åˆ¶æµç¤ºä¾‹](#-tier-1-åŸºç¡€æ§åˆ¶æµç¤ºä¾‹)
    - [ç¤ºä¾‹1.1: åŸºç¡€ match è¡¨è¾¾å¼](#ç¤ºä¾‹11-åŸºç¡€-match-è¡¨è¾¾å¼)
    - [ç¤ºä¾‹1.2: if let å’Œ while let](#ç¤ºä¾‹12-if-let-å’Œ-while-let)
    - [ç¤ºä¾‹1.3: å¾ªç¯ç»“æ„](#ç¤ºä¾‹13-å¾ªç¯ç»“æ„)
    - [ç¤ºä¾‹1.4: åŸºç¡€å‡½æ•°å®šä¹‰](#ç¤ºä¾‹14-åŸºç¡€å‡½æ•°å®šä¹‰)
    - [ç¤ºä¾‹1.5: å‡½æ•°å¼è¿­ä»£å™¨](#ç¤ºä¾‹15-å‡½æ•°å¼è¿­ä»£å™¨)
    - [ç¤ºä¾‹1.6: Range å’Œè¿­ä»£](#ç¤ºä¾‹16-range-å’Œè¿­ä»£)
  - [ğŸš€ Tier 2: å®è·µåº”ç”¨ç¤ºä¾‹](#-tier-2-å®è·µåº”ç”¨ç¤ºä¾‹)
    - [ç¤ºä¾‹2.1: é—­åŒ…åŸºç¡€](#ç¤ºä¾‹21-é—­åŒ…åŸºç¡€)
    - [ç¤ºä¾‹2.2: é—­åŒ…æ•è·æ¨¡å¼](#ç¤ºä¾‹22-é—­åŒ…æ•è·æ¨¡å¼)
    - [ç¤ºä¾‹2.3: Result é”™è¯¯å¤„ç†](#ç¤ºä¾‹23-result-é”™è¯¯å¤„ç†)
    - [ç¤ºä¾‹2.4: Option å¤„ç†](#ç¤ºä¾‹24-option-å¤„ç†)
    - [ç¤ºä¾‹2.5: è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#ç¤ºä¾‹25-è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [ç¤ºä¾‹2.6: é«˜é˜¶å‡½æ•°](#ç¤ºä¾‹26-é«˜é˜¶å‡½æ•°)
  - [ğŸ“ Tier 3: é«˜çº§åº”ç”¨ç¤ºä¾‹](#-tier-3-é«˜çº§åº”ç”¨ç¤ºä¾‹)
    - [ç¤ºä¾‹3.1: é«˜çº§é—­åŒ…æ¨¡å¼](#ç¤ºä¾‹31-é«˜çº§é—­åŒ…æ¨¡å¼)
    - [ç¤ºä¾‹3.2: è¿­ä»£å™¨è‡ªå®šä¹‰](#ç¤ºä¾‹32-è¿­ä»£å™¨è‡ªå®šä¹‰)
    - [ç¤ºä¾‹3.3: é”™è¯¯å¤„ç†ç»„åˆ](#ç¤ºä¾‹33-é”™è¯¯å¤„ç†ç»„åˆ)
    - [ç¤ºä¾‹3.4: å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼](#ç¤ºä¾‹34-å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å­¦ä¹ è·¯å¾„å»ºè®®](#å­¦ä¹ è·¯å¾„å»ºè®®)
    - [æ ¸å¿ƒæ¦‚å¿µæ€»ç»“](#æ ¸å¿ƒæ¦‚å¿µæ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

## ğŸ“‹ ç¤ºä¾‹å¯¼èˆª

| ç¼–å· | ä¸»é¢˜ | éš¾åº¦ | é‡ç‚¹æ¦‚å¿µ |
|------|------|------|---------|
| [1.1](#ç¤ºä¾‹11-åŸºç¡€-match-è¡¨è¾¾å¼) | åŸºç¡€ match è¡¨è¾¾å¼ | â­ | matchã€æ¨¡å¼åŒ¹é… |
| [1.2](#ç¤ºä¾‹12-if-let-å’Œ-while-let) | if let å’Œ while let | â­ | ç®€åŒ–åŒ¹é… |
| [1.3](#ç¤ºä¾‹13-å¾ªç¯ç»“æ„) | å¾ªç¯ç»“æ„ | â­ | loopã€whileã€for |
| [1.4](#ç¤ºä¾‹14-åŸºç¡€å‡½æ•°å®šä¹‰) | åŸºç¡€å‡½æ•°å®šä¹‰ | â­ | fnã€å‚æ•°ã€è¿”å›å€¼ |
| [1.5](#ç¤ºä¾‹15-å‡½æ•°å¼è¿­ä»£å™¨) | å‡½æ•°å¼è¿­ä»£å™¨ | â­â­ | mapã€filterã€fold |
| [1.6](#ç¤ºä¾‹16-range-å’Œè¿­ä»£) | Range å’Œè¿­ä»£ | â­ | èŒƒå›´ã€è¿­ä»£ |
| [2.1](#ç¤ºä¾‹21-é—­åŒ…åŸºç¡€) | é—­åŒ…åŸºç¡€ | â­â­ | æ•è·ã€Fn Traits |
| [2.2](#ç¤ºä¾‹22-é—­åŒ…æ•è·æ¨¡å¼) | é—­åŒ…æ•è·æ¨¡å¼ | â­â­ | moveã€å€Ÿç”¨ |
| [2.3](#ç¤ºä¾‹23-result-é”™è¯¯å¤„ç†) | Result é”™è¯¯å¤„ç† | â­â­ | ?ã€é”™è¯¯ä¼ æ’­ |
| [2.4](#ç¤ºä¾‹24-option-å¤„ç†) | Option å¤„ç† | â­â­ | æ–¹æ³•é“¾ã€ç»„åˆ |
| [2.5](#ç¤ºä¾‹25-è‡ªå®šä¹‰é”™è¯¯ç±»å‹) | è‡ªå®šä¹‰é”™è¯¯ç±»å‹ | â­â­ | Error trait |
| [2.6](#ç¤ºä¾‹26-é«˜é˜¶å‡½æ•°) | é«˜é˜¶å‡½æ•° | â­â­â­ | å‡½æ•°ä½œä¸ºå‚æ•° |
| [3.1](#ç¤ºä¾‹31-é«˜çº§é—­åŒ…æ¨¡å¼) | é«˜çº§é—­åŒ…æ¨¡å¼ | â­â­â­ | FnOnceã€FnMut |
| [3.2](#ç¤ºä¾‹32-è¿­ä»£å™¨è‡ªå®šä¹‰) | è¿­ä»£å™¨è‡ªå®šä¹‰ | â­â­â­ | Iterator trait |
| [3.3](#ç¤ºä¾‹33-é”™è¯¯å¤„ç†ç»„åˆ) | é”™è¯¯å¤„ç†ç»„åˆ | â­â­â­ | and_thenã€or_else |
| [3.4](#ç¤ºä¾‹34-å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼) | å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼ | â­â­â­ | ç»„åˆã€æŸ¯é‡ŒåŒ– |

---

## ğŸŒŸ Tier 1: åŸºç¡€æ§åˆ¶æµç¤ºä¾‹

### ç¤ºä¾‹1.1: åŸºç¡€ match è¡¨è¾¾å¼

**ç›®æ ‡**: æŒæ¡ match è¡¨è¾¾å¼çš„å„ç§ç”¨æ³•

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== åŸºç¡€ match =====\n");

    let number = 3;

    match number {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        4 | 5 => println!("å››æˆ–äº”"),  // å¤šä¸ªæ¨¡å¼
        _ => println!("å…¶ä»–"),
    }

    println!("\n===== match è¿”å›å€¼ =====\n");

    let result = match number {
        1 => "ä¸€",
        2 => "äºŒ",
        3 => "ä¸‰",
        _ => "å…¶ä»–",
    };

    println!("ç»“æœ: {}", result);

    println!("\n===== èŒƒå›´åŒ¹é… =====\n");

    let score = 85;

    let grade = match score {
        90..=100 => "A",
        80..=89 => "B",
        70..=79 => "C",
        60..=69 => "D",
        _ => "F",
    };

    println!("åˆ†æ•° {} å¯¹åº”ç­‰çº§ {}", score, grade);

    println!("\n===== åŒ¹é…å®ˆå« =====\n");

    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("å°äº5: {}", x),
        Some(x) => println!("å¤§äºç­‰äº5: {}", x),
        None => println!("æ²¡æœ‰å€¼"),
    }

    println!("\n===== è§£æ„å…ƒç»„ =====\n");

    let pair = (0, -2);

    match pair {
        (0, y) => println!("ç¬¬ä¸€ä¸ªæ˜¯0, y = {}", y),
        (x, 0) => println!("x = {}, ç¬¬äºŒä¸ªæ˜¯0", x),
        _ => println!("ä»»æ„ç»„åˆ: {:?}", pair),
    }

    println!("\n===== è§£æ„æšä¸¾ =====\n");

    #[derive(Debug)]
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("é€€å‡º");
        }
        Message::Move { x, y } => {
            println!("ç§»åŠ¨åˆ° ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("æ–‡æœ¬æ¶ˆæ¯: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("æ”¹å˜é¢œè‰²: RGB({}, {}, {})", r, g, b);
        }
    }

    println!("\n===== @ ç»‘å®š =====\n");

    let value = 15;

    match value {
        n @ 1..=10 => println!("1åˆ°10: {}", n),
        n @ 11..=20 => println!("11åˆ°20: {}", n),
        _ => println!("å…¶ä»–"),
    }
}
```

**è¯´æ˜**:

- **match**: Rust çš„ä¸»è¦æ§åˆ¶æµå·¥å…·ï¼Œå¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½
- **è¿”å›å€¼**: match æ˜¯è¡¨è¾¾å¼ï¼Œå¯ä»¥è¿”å›å€¼
- **æ¨¡å¼**: æ”¯æŒå­—é¢å€¼ã€èŒƒå›´ã€è§£æ„ã€å®ˆå«ç­‰å¤šç§æ¨¡å¼
- **@ ç»‘å®š**: åœ¨æ¨¡å¼åŒ¹é…çš„åŒæ—¶ç»‘å®šå€¼

**è¾“å‡º**:

```text
===== åŸºç¡€ match =====

ä¸‰

===== match è¿”å›å€¼ =====

ç»“æœ: ä¸‰

===== èŒƒå›´åŒ¹é… =====

åˆ†æ•° 85 å¯¹åº”ç­‰çº§ B

===== åŒ¹é…å®ˆå« =====

å°äº5: 4

===== è§£æ„å…ƒç»„ =====

ç¬¬ä¸€ä¸ªæ˜¯0, y = -2

===== è§£æ„æšä¸¾ =====

æ”¹å˜é¢œè‰²: RGB(0, 160, 255)

===== @ ç»‘å®š =====

11åˆ°20: 15
```

---

### ç¤ºä¾‹1.2: if let å’Œ while let

**ç›®æ ‡**: æŒæ¡ç®€åŒ–çš„æ¨¡å¼åŒ¹é…è¯­æ³•

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== if let åŸºç¡€ =====\n");

    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    // if let: åªå…³å¿ƒä¸€ç§æ¨¡å¼
    if let Some(color) = favorite_color {
        println!("ä½¿ç”¨ä½ å–œæ¬¢çš„é¢œè‰²: {}", color);
    } else if is_tuesday {
        println!("æ˜ŸæœŸäºŒæ˜¯ç»¿è‰²çš„æ—¥å­!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("ä½¿ç”¨ç´«è‰²ä½œä¸ºèƒŒæ™¯è‰²");
        } else {
            println!("ä½¿ç”¨æ©™è‰²ä½œä¸ºèƒŒæ™¯è‰²");
        }
    } else {
        println!("ä½¿ç”¨è“è‰²ä½œä¸ºèƒŒæ™¯è‰²");
    }

    println!("\n===== while let å¾ªç¯ =====\n");

    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    // while let: æŒç»­åŒ¹é…ç›´åˆ°å¤±è´¥
    while let Some(top) = stack.pop() {
        println!("å¼¹å‡º: {}", top);
    }

    println!("\n===== å®é™…åº”ç”¨: è§£æè¾“å…¥ =====\n");

    let inputs = vec![
        Some("42"),
        Some("abc"),
        None,
        Some("123"),
    ];

    for input in inputs {
        if let Some(s) = input {
            if let Ok(num) = s.parse::<i32>() {
                println!("è§£ææˆåŠŸ: {}", num);
            } else {
                println!("è§£æå¤±è´¥: {}", s);
            }
        } else {
            println!("è¾“å…¥ä¸ºç©º");
        }
    }

    println!("\n===== åŒ¹é…å®ˆå« =====\n");

    let numbers = vec![1, 2, 3, 4, 5, 6];
    let mut iter = numbers.iter();

    while let Some(&num) = iter.next() {
        if num % 2 == 0 {
            println!("å¶æ•°: {}", num);
        }
    }
}
```

**è¯´æ˜**:

- **if let**: ç®€åŒ–åªåŒ¹é…ä¸€ç§æ¨¡å¼çš„æƒ…å†µ
- **while let**: å¾ªç¯åŒ¹é…ï¼Œå¸¸ç”¨äºè¿­ä»£å™¨
- **vs match**: å½“åªå…³å¿ƒä¸€ç§æ¨¡å¼æ—¶æ›´ç®€æ´
- **ç»„åˆ**: å¯ä»¥ä¸ else ifã€else ç­‰ç»„åˆä½¿ç”¨

**è¾“å‡º**:

```text
===== if let åŸºç¡€ =====

ä½¿ç”¨ç´«è‰²ä½œä¸ºèƒŒæ™¯è‰²

===== while let å¾ªç¯ =====

å¼¹å‡º: 3
å¼¹å‡º: 2
å¼¹å‡º: 1

===== å®é™…åº”ç”¨: è§£æè¾“å…¥ =====

è§£ææˆåŠŸ: 42
è§£æå¤±è´¥: abc
è¾“å…¥ä¸ºç©º
è§£ææˆåŠŸ: 123

===== åŒ¹é…å®ˆå« =====

å¶æ•°: 2
å¶æ•°: 4
å¶æ•°: 6
```

---

### ç¤ºä¾‹1.3: å¾ªç¯ç»“æ„

**ç›®æ ‡**: æŒæ¡ Rust çš„ä¸‰ç§å¾ªç¯

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== loop æ— é™å¾ªç¯ =====\n");

    let mut counter = 0;

    // loop: æ— é™å¾ªç¯ï¼Œéœ€è¦ break é€€å‡º
    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;  // loop å¯ä»¥è¿”å›å€¼
        }
    };

    println!("å¾ªç¯è¿”å›å€¼: {}", result);

    println!("\n===== while æ¡ä»¶å¾ªç¯ =====\n");

    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("èµ·é£!");

    println!("\n===== for è¿­ä»£å¾ªç¯ =====\n");

    let arr = [10, 20, 30, 40, 50];

    // for: è¿­ä»£é›†åˆ
    for element in arr {
        println!("å€¼: {}", element);
    }

    // ä½¿ç”¨èŒƒå›´
    for number in 1..=5 {
        println!("æ•°å­—: {}", number);
    }

    // å¸¦ç´¢å¼•çš„è¿­ä»£
    for (index, value) in arr.iter().enumerate() {
        println!("arr[{}] = {}", index, value);
    }

    println!("\n===== å¾ªç¯æ ‡ç­¾ =====\n");

    let mut count = 0;

    // å¾ªç¯æ ‡ç­¾: ç”¨äºåµŒå¥—å¾ªç¯
    'outer: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;  // é€€å‡ºå†…å±‚å¾ªç¯
            }
            if count == 2 {
                break 'outer;  // é€€å‡ºå¤–å±‚å¾ªç¯
            }
            remaining -= 1;
        }

        count += 1;
    }

    println!("å¾ªç¯ç»“æŸ");

    println!("\n===== å¾ªç¯æ€§èƒ½å¯¹æ¯” =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // for å¾ªç¯ (æ¨è): æœ€æ¸…æ™°
    for num in &numbers {
        print!("{} ", num);
    }
    println!();

    // while å¾ªç¯: ä¸å¦‚ for æ¸…æ™°
    let mut index = 0;
    while index < numbers.len() {
        print!("{} ", numbers[index]);
        index += 1;
    }
    println!();

    // loop å¾ªç¯: æœ€ä¸æ¸…æ™°
    let mut index = 0;
    loop {
        if index >= numbers.len() {
            break;
        }
        print!("{} ", numbers[index]);
        index += 1;
    }
    println!();

    println!("\n===== continue å’Œ break =====\n");

    for num in 1..=10 {
        if num % 2 == 0 {
            continue;  // è·³è¿‡å¶æ•°
        }

        if num > 7 {
            break;  // å¤§äº7å°±é€€å‡º
        }

        println!("å¥‡æ•°: {}", num);
    }
}
```

**è¯´æ˜**:

- **loop**: æ— é™å¾ªç¯ï¼Œå¯ä»¥è¿”å›å€¼
- **while**: æ¡ä»¶å¾ªç¯ï¼Œå½“æ¡ä»¶ä¸ºçœŸæ—¶æ‰§è¡Œ
- **for**: è¿­ä»£å¾ªç¯ï¼Œéå†é›†åˆï¼ˆæœ€æ¨èï¼‰
- **æ ‡ç­¾**: ç”¨äºåµŒå¥—å¾ªç¯çš„è·³è½¬

**è¾“å‡º**:

```text
===== loop æ— é™å¾ªç¯ =====

å¾ªç¯è¿”å›å€¼: 20

===== while æ¡ä»¶å¾ªç¯ =====

3!
2!
1!
èµ·é£!

===== for è¿­ä»£å¾ªç¯ =====

å€¼: 10
å€¼: 20
å€¼: 30
å€¼: 40
å€¼: 50
æ•°å­—: 1
æ•°å­—: 2
æ•°å­—: 3
æ•°å­—: 4
æ•°å­—: 5
arr[0] = 10
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 50

===== å¾ªç¯æ ‡ç­¾ =====

count = 0
remaining = 10
count = 1
remaining = 10
count = 2
remaining = 10
å¾ªç¯ç»“æŸ

===== å¾ªç¯æ€§èƒ½å¯¹æ¯” =====

1 2 3 4 5
1 2 3 4 5
1 2 3 4 5

===== continue å’Œ break =====

å¥‡æ•°: 1
å¥‡æ•°: 3
å¥‡æ•°: 5
å¥‡æ•°: 7
```

---

### ç¤ºä¾‹1.4: åŸºç¡€å‡½æ•°å®šä¹‰

**ç›®æ ‡**: æŒæ¡å‡½æ•°çš„å®šä¹‰å’Œè°ƒç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== åŸºç¡€å‡½æ•° =====\n");

    // æ— å‚æ•°æ— è¿”å›å€¼
    fn greet() {
        println!("ä½ å¥½!");
    }

    greet();

    // æœ‰å‚æ•°
    fn greet_name(name: &str) {
        println!("ä½ å¥½, {}!", name);
    }

    greet_name("Alice");

    // æœ‰è¿”å›å€¼
    fn add(a: i32, b: i32) -> i32 {
        a + b  // è¡¨è¾¾å¼è¿”å›å€¼ (æ— åˆ†å·)
    }

    let sum = add(5, 3);
    println!("5 + 3 = {}", sum);

    println!("\n===== è¯­å¥ vs è¡¨è¾¾å¼ =====\n");

    fn calculate() -> i32 {
        let x = 5;        // è¯­å¥
        let y = {         // ä»£ç å—æ˜¯è¡¨è¾¾å¼
            let z = 3;
            z + 1         // è¡¨è¾¾å¼è¿”å› 4
        };
        x + y             // è¡¨è¾¾å¼è¿”å› 9
    }

    println!("ç»“æœ: {}", calculate());

    println!("\n===== æå‰è¿”å› =====\n");

    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            return Err(String::from("é™¤æ•°ä¸èƒ½ä¸ºé›¶"));  // æå‰è¿”å›
        }
        Ok(a / b)
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    match divide(10.0, 0.0) {
        Ok(result) => println!("10 / 0 = {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    println!("\n===== å¤šè¿”å›å€¼ =====\n");

    fn swap(a: i32, b: i32) -> (i32, i32) {
        (b, a)  // ä½¿ç”¨å…ƒç»„è¿”å›å¤šä¸ªå€¼
    }

    let (x, y) = swap(1, 2);
    println!("äº¤æ¢å: x = {}, y = {}", x, y);

    println!("\n===== ä¸è¿”å›çš„å‡½æ•° =====\n");

    fn infinite_loop() -> ! {
        loop {
            // æ°¸ä¸è¿”å›
        }
    }

    fn exit_program() -> ! {
        std::process::exit(0);
    }

    println!("! ç±»å‹è¡¨ç¤ºæ°¸ä¸è¿”å›");

    println!("\n===== å‡½æ•°ä½œä¸ºå€¼ =====\n");

    fn double(x: i32) -> i32 {
        x * 2
    }

    // å‡½æ•°æŒ‡é’ˆ
    let f: fn(i32) -> i32 = double;
    println!("double(5) = {}", f(5));

    // å‡½æ•°ä½œä¸ºå‚æ•°
    fn apply(f: fn(i32) -> i32, value: i32) -> i32 {
        f(value)
    }

    println!("apply(double, 3) = {}", apply(double, 3));
}
```

**è¯´æ˜**:

- **å‡½æ•°ç­¾å**: `fn name(params) -> return_type`
- **è¡¨è¾¾å¼**: å‡½æ•°ä½“çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯è¿”å›å€¼
- **æå‰è¿”å›**: ä½¿ç”¨ `return` å…³é”®å­—
- **! ç±»å‹**: è¡¨ç¤ºæ°¸ä¸è¿”å›çš„å‡½æ•°

**è¾“å‡º**:

```text
===== åŸºç¡€å‡½æ•° =====

ä½ å¥½!
ä½ å¥½, Alice!
5 + 3 = 8

===== è¯­å¥ vs è¡¨è¾¾å¼ =====

ç»“æœ: 9

===== æå‰è¿”å› =====

10 / 2 = 5
é”™è¯¯: é™¤æ•°ä¸èƒ½ä¸ºé›¶

===== å¤šè¿”å›å€¼ =====

äº¤æ¢å: x = 2, y = 1

===== ä¸è¿”å›çš„å‡½æ•° =====

! ç±»å‹è¡¨ç¤ºæ°¸ä¸è¿”å›

===== å‡½æ•°ä½œä¸ºå€¼ =====

double(5) = 10
apply(double, 3) = 6
```

---

### ç¤ºä¾‹1.5: å‡½æ•°å¼è¿­ä»£å™¨

**ç›®æ ‡**: æŒæ¡è¿­ä»£å™¨çš„å‡½æ•°å¼æ“ä½œ

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== map: æ˜ å°„è½¬æ¢ =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // map: è½¬æ¢æ¯ä¸ªå…ƒç´ 
    let doubled: Vec<_> = numbers.iter().map(|x| x * 2).collect();

    println!("åŸå§‹: {:?}", numbers);
    println!("åŠ å€: {:?}", doubled);

    println!("\n===== filter: è¿‡æ»¤ =====\n");

    // filter: ä¿ç•™æ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
    let evens: Vec<_> = numbers.iter().filter(|&&x| x % 2 == 0).collect();

    println!("å¶æ•°: {:?}", evens);

    println!("\n===== é“¾å¼è°ƒç”¨ =====\n");

    let result: Vec<_> = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // è¿‡æ»¤å¶æ•°
        .map(|x| x * x)             // å¹³æ–¹
        .collect();

    println!("å¶æ•°çš„å¹³æ–¹: {:?}", result);

    println!("\n===== fold: ç´¯ç§¯ =====\n");

    // fold: ç´¯ç§¯è®¡ç®—
    let sum = numbers.iter().fold(0, |acc, &x| acc + x);

    println!("æ€»å’Œ: {}", sum);

    // è®¡ç®—ä¹˜ç§¯
    let product = numbers.iter().fold(1, |acc, &x| acc * x);

    println!("ä¹˜ç§¯: {}", product);

    println!("\n===== for_each: å‰¯ä½œç”¨ =====\n");

    // for_each: å¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œæ“ä½œ
    numbers.iter().for_each(|x| {
        println!("å¤„ç†: {}", x);
    });

    println!("\n===== å¸¸ç”¨è¿­ä»£å™¨æ–¹æ³• =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // any: æ˜¯å¦å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
    let has_even = numbers.iter().any(|&x| x % 2 == 0);
    println!("æ˜¯å¦æœ‰å¶æ•°: {}", has_even);

    // all: æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³æ¡ä»¶
    let all_positive = numbers.iter().all(|&x| x > 0);
    println!("æ˜¯å¦éƒ½ä¸ºæ­£æ•°: {}", all_positive);

    // find: æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
    let first_even = numbers.iter().find(|&&x| x % 2 == 0);
    println!("ç¬¬ä¸€ä¸ªå¶æ•°: {:?}", first_even);

    // position: æŸ¥æ‰¾å…ƒç´ çš„ä½ç½®
    let pos = numbers.iter().position(|&x| x == 3);
    println!("3çš„ä½ç½®: {:?}", pos);

    // take: å–å‰ n ä¸ªå…ƒç´ 
    let first_three: Vec<_> = numbers.iter().take(3).collect();
    println!("å‰ä¸‰ä¸ª: {:?}", first_three);

    // skip: è·³è¿‡å‰ n ä¸ªå…ƒç´ 
    let after_two: Vec<_> = numbers.iter().skip(2).collect();
    println!("è·³è¿‡å‰ä¸¤ä¸ª: {:?}", after_two);

    println!("\n===== æƒ°æ€§æ±‚å€¼ =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // åˆ›å»ºè¿­ä»£å™¨ (ä¸ä¼šç«‹å³æ‰§è¡Œ)
    let iter = numbers.iter().map(|x| {
        println!("æ˜ å°„ {}", x);
        x * 2
    });

    println!("è¿­ä»£å™¨å·²åˆ›å»º,ä½†è¿˜æœªæ‰§è¡Œ");

    // collect è§¦å‘æ±‚å€¼
    let result: Vec<_> = iter.collect();

    println!("ç»“æœ: {:?}", result);

    println!("\n===== å®é™…åº”ç”¨ =====\n");

    // å¤„ç†å­—ç¬¦ä¸²
    let words = vec!["hello", "world", "rust"];

    let uppercase: Vec<String> = words
        .iter()
        .map(|&s| s.to_uppercase())
        .collect();

    println!("å¤§å†™: {:?}", uppercase);

    // é“¾å¼è¿‡æ»¤å’Œè½¬æ¢
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let result: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // å¶æ•°
        .map(|&x| x * x)            // å¹³æ–¹
        .sum();                     // æ±‚å’Œ

    println!("å¶æ•°å¹³æ–¹å’Œ: {}", result);
}
```

**è¯´æ˜**:

- **map**: è½¬æ¢æ¯ä¸ªå…ƒç´ 
- **filter**: è¿‡æ»¤å…ƒç´ 
- **fold**: ç´¯ç§¯è®¡ç®—
- **æƒ°æ€§æ±‚å€¼**: è¿­ä»£å™¨åœ¨è°ƒç”¨ collect ç­‰æ¶ˆè´¹è€…æ—¶æ‰æ‰§è¡Œ

**è¾“å‡º**:

```text
===== map: æ˜ å°„è½¬æ¢ =====

åŸå§‹: [1, 2, 3, 4, 5]
åŠ å€: [2, 4, 6, 8, 10]

===== filter: è¿‡æ»¤ =====

å¶æ•°: [2, 4]

===== é“¾å¼è°ƒç”¨ =====

å¶æ•°çš„å¹³æ–¹: [4, 16]

===== fold: ç´¯ç§¯ =====

æ€»å’Œ: 15
ä¹˜ç§¯: 120

===== for_each: å‰¯ä½œç”¨ =====

å¤„ç†: 1
å¤„ç†: 2
å¤„ç†: 3
å¤„ç†: 4
å¤„ç†: 5

===== å¸¸ç”¨è¿­ä»£å™¨æ–¹æ³• =====

æ˜¯å¦æœ‰å¶æ•°: true
æ˜¯å¦éƒ½ä¸ºæ­£æ•°: true
ç¬¬ä¸€ä¸ªå¶æ•°: Some(2)
3çš„ä½ç½®: Some(2)
å‰ä¸‰ä¸ª: [1, 2, 3]
è·³è¿‡å‰ä¸¤ä¸ª: [3, 4, 5]

===== æƒ°æ€§æ±‚å€¼ =====

è¿­ä»£å™¨å·²åˆ›å»º,ä½†è¿˜æœªæ‰§è¡Œ
æ˜ å°„ 1
æ˜ å°„ 2
æ˜ å°„ 3
æ˜ å°„ 4
æ˜ å°„ 5
ç»“æœ: [2, 4, 6, 8, 10]

===== å®é™…åº”ç”¨ =====

å¤§å†™: ["HELLO", "WORLD", "RUST"]
å¶æ•°å¹³æ–¹å’Œ: 120
```

---

### ç¤ºä¾‹1.6: Range å’Œè¿­ä»£

**ç›®æ ‡**: æŒæ¡èŒƒå›´å’Œè¿­ä»£çš„ä½¿ç”¨

**éš¾åº¦**: â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Range èŒƒå›´ =====\n");

    // 1..5: åŠå¼€åŒºé—´ [1, 5)
    for i in 1..5 {
        print!("{} ", i);
    }
    println!();

    // 1..=5: é—­åŒºé—´ [1, 5]
    for i in 1..=5 {
        print!("{} ", i);
    }
    println!();

    println!("\n===== Range æ–¹æ³• =====\n");

    // collect æˆå‘é‡
    let range: Vec<_> = (1..=10).collect();
    println!("Range å‘é‡: {:?}", range);

    // èŒƒå›´æ±‚å’Œ
    let sum: i32 = (1..=100).sum();
    println!("1åˆ°100çš„å’Œ: {}", sum);

    // èŒƒå›´è¿‡æ»¤
    let evens: Vec<_> = (1..=10).filter(|x| x % 2 == 0).collect();
    println!("1åˆ°10çš„å¶æ•°: {:?}", evens);

    println!("\n===== å­—ç¬¦èŒƒå›´ =====\n");

    // å­—ç¬¦èŒƒå›´
    for c in 'a'..='z' {
        print!("{}", c);
    }
    println!();

    println!("\n===== æ­¥é•¿è¿­ä»£ =====\n");

    // step_by: æŒ‡å®šæ­¥é•¿
    let step: Vec<_> = (0..10).step_by(2).collect();
    println!("æ­¥é•¿ä¸º2: {:?}", step);

    // rev: åå‘è¿­ä»£
    let reversed: Vec<_> = (1..=5).rev().collect();
    println!("åå‘: {:?}", reversed);

    println!("\n===== æ— é™èŒƒå›´ =====\n");

    // 1..: æ— é™èŒƒå›´
    let first_five: Vec<_> = (1..).take(5).collect();
    println!("å‰äº”ä¸ªè‡ªç„¶æ•°: {:?}", first_five);

    // enumerate: æ·»åŠ ç´¢å¼•
    for (index, value) in (10..15).enumerate() {
        println!("[{}] = {}", index, value);
    }

    println!("\n===== å®é™…åº”ç”¨ =====\n");

    // ç”Ÿæˆæ•°ç»„ç´¢å¼•
    let arr = vec!['a', 'b', 'c', 'd', 'e'];

    for i in 0..arr.len() {
        println!("arr[{}] = {}", i, arr[i]);
    }

    // å€’åºéå†
    for i in (0..arr.len()).rev() {
        println!("åå‘ arr[{}] = {}", i, arr[i]);
    }

    // éƒ¨åˆ†èŒƒå›´
    for i in 1..arr.len()-1 {
        println!("ä¸­é—´ arr[{}] = {}", i, arr[i]);
    }
}
```

**è¯´æ˜**:

- **Range**: `start..end` (åŠå¼€) å’Œ `start..=end` (é—­åŒºé—´)
- **æ­¥é•¿**: ä½¿ç”¨ `step_by` æ–¹æ³•
- **åå‘**: ä½¿ç”¨ `rev` æ–¹æ³•
- **æ— é™**: `start..` åˆ›å»ºæ— é™èŒƒå›´

**è¾“å‡º**:

```text
===== Range èŒƒå›´ =====

1 2 3 4
1 2 3 4 5

===== Range æ–¹æ³• =====

Range å‘é‡: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
1åˆ°100çš„å’Œ: 5050
1åˆ°10çš„å¶æ•°: [2, 4, 6, 8, 10]

===== å­—ç¬¦èŒƒå›´ =====

abcdefghijklmnopqrstuvwxyz

===== æ­¥é•¿è¿­ä»£ =====

æ­¥é•¿ä¸º2: [0, 2, 4, 6, 8]
åå‘: [5, 4, 3, 2, 1]

===== æ— é™èŒƒå›´ =====

å‰äº”ä¸ªè‡ªç„¶æ•°: [1, 2, 3, 4, 5]
[0] = 10
[1] = 11
[2] = 12
[3] = 13
[4] = 14

===== å®é™…åº”ç”¨ =====

arr[0] = a
arr[1] = b
arr[2] = c
arr[3] = d
arr[4] = e
åå‘ arr[4] = e
åå‘ arr[3] = d
åå‘ arr[2] = c
åå‘ arr[1] = b
åå‘ arr[0] = a
ä¸­é—´ arr[1] = b
ä¸­é—´ arr[2] = c
ä¸­é—´ arr[3] = d
```

---

## ğŸš€ Tier 2: å®è·µåº”ç”¨ç¤ºä¾‹

### ç¤ºä¾‹2.1: é—­åŒ…åŸºç¡€

**ç›®æ ‡**: æŒæ¡é—­åŒ…çš„å®šä¹‰å’Œä½¿ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é—­åŒ…è¯­æ³• =====\n");

    // å®Œæ•´è¯­æ³•
    let add_one_v1 = |x: i32| -> i32 { x + 1 };

    // ç±»å‹æ¨æ–­
    let add_one_v2 = |x| { x + 1 };

    // ç®€å†™ (å•è¡¨è¾¾å¼)
    let add_one_v3 = |x| x + 1;

    println!("add_one_v1(5) = {}", add_one_v1(5));
    println!("add_one_v2(5) = {}", add_one_v2(5));
    println!("add_one_v3(5) = {}", add_one_v3(5));

    println!("\n===== æ•è·ç¯å¢ƒ =====\n");

    let x = 4;

    // é—­åŒ…å¯ä»¥æ•è·å¤–éƒ¨å˜é‡
    let equal_to_x = |z| z == x;

    let y = 4;
    println!("equal_to_x(y) = {}", equal_to_x(y));

    // å‡½æ•°ä¸èƒ½æ•è·ç¯å¢ƒ
    // fn equal_to_x_fn(z: i32) -> bool {
    //     z == x  // âŒ é”™è¯¯!
    // }

    println!("\n===== ä¸å¯å˜å€Ÿç”¨ =====\n");

    let list = vec![1, 2, 3];
    println!("æ•è·å‰: {:?}", list);

    // é—­åŒ…ä¸å¯å˜å€Ÿç”¨ list
    let only_borrows = || println!("é—­åŒ…ä¸­: {:?}", list);

    println!("è°ƒç”¨å‰: {:?}", list);
    only_borrows();
    println!("è°ƒç”¨å: {:?}", list);

    println!("\n===== å¯å˜å€Ÿç”¨ =====\n");

    let mut list = vec![1, 2, 3];
    println!("ä¿®æ”¹å‰: {:?}", list);

    // é—­åŒ…å¯å˜å€Ÿç”¨ list
    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("ä¿®æ”¹å: {:?}", list);

    println!("\n===== Fn Traits =====\n");

    // Fn: ä¸å¯å˜å€Ÿç”¨
    let x = vec![1, 2, 3];
    let fn_closure = || println!("{:?}", x);
    fn_closure();
    fn_closure();  // å¯ä»¥å¤šæ¬¡è°ƒç”¨

    // FnMut: å¯å˜å€Ÿç”¨
    let mut x = vec![1, 2, 3];
    let mut fn_mut_closure = || x.push(4);
    fn_mut_closure();
    // fn_mut_closure();  // å¯ä»¥å¤šæ¬¡è°ƒç”¨

    // FnOnce: è·å–æ‰€æœ‰æƒ
    let x = vec![1, 2, 3];
    let fn_once_closure = move || {
        println!("{:?}", x);
        // x è¢«æ¶ˆè´¹
    };
    fn_once_closure();
    // fn_once_closure();  // âŒ ä¸èƒ½å†æ¬¡è°ƒç”¨

    println!("\n===== é—­åŒ…ä½œä¸ºå‚æ•° =====\n");

    fn apply<F>(f: F, x: i32) -> i32
    where
        F: Fn(i32) -> i32,
    {
        f(x)
    }

    let double = |x| x * 2;
    println!("apply(double, 5) = {}", apply(double, 5));

    println!("\n===== é—­åŒ…ä½œä¸ºè¿”å›å€¼ =====\n");

    fn create_adder(n: i32) -> impl Fn(i32) -> i32 {
        move |x| x + n
    }

    let add_5 = create_adder(5);
    println!("add_5(10) = {}", add_5(10));
}
```

**è¯´æ˜**:

- **é—­åŒ…**: å¯ä»¥æ•è·ç¯å¢ƒçš„åŒ¿åå‡½æ•°
- **Fn Traits**: Fn (ä¸å¯å˜å€Ÿç”¨)ã€FnMut (å¯å˜å€Ÿç”¨)ã€FnOnce (æ‰€æœ‰æƒ)
- **ç±»å‹æ¨æ–­**: é—­åŒ…çš„ç±»å‹å¯ä»¥è‡ªåŠ¨æ¨æ–­
- **move**: å¼ºåˆ¶è·å–æ‰€æœ‰æƒ

**è¾“å‡º**:

```text
===== é—­åŒ…è¯­æ³• =====

add_one_v1(5) = 6
add_one_v2(5) = 6
add_one_v3(5) = 6

===== æ•è·ç¯å¢ƒ =====

equal_to_x(y) = true

===== ä¸å¯å˜å€Ÿç”¨ =====

æ•è·å‰: [1, 2, 3]
è°ƒç”¨å‰: [1, 2, 3]
é—­åŒ…ä¸­: [1, 2, 3]
è°ƒç”¨å: [1, 2, 3]

===== å¯å˜å€Ÿç”¨ =====

ä¿®æ”¹å‰: [1, 2, 3]
ä¿®æ”¹å: [1, 2, 3, 7]

===== Fn Traits =====

[1, 2, 3]
[1, 2, 3]

===== é—­åŒ…ä½œä¸ºå‚æ•° =====

apply(double, 5) = 10

===== é—­åŒ…ä½œä¸ºè¿”å›å€¼ =====

add_5(10) = 15
```

---

### ç¤ºä¾‹2.2: é—­åŒ…æ•è·æ¨¡å¼

**ç›®æ ‡**: ç†è§£é—­åŒ…çš„ä¸åŒæ•è·æ–¹å¼

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== move å…³é”®å­— =====\n");

    let x = vec![1, 2, 3];

    // ä¸ä½¿ç”¨ move: å€Ÿç”¨
    let closure1 = || println!("å€Ÿç”¨: {:?}", x);
    closure1();
    println!("x ä»ç„¶æœ‰æ•ˆ: {:?}", x);

    // ä½¿ç”¨ move: è·å–æ‰€æœ‰æƒ
    let closure2 = move || println!("æ‹¥æœ‰: {:?}", x);
    closure2();
    // println!("{:?}", x);  // âŒ x å·²è¢«ç§»åŠ¨

    println!("\n===== Copy ç±»å‹ =====\n");

    let x = 5;  // i32 å®ç°äº† Copy

    // move å¯¹ Copy ç±»å‹çš„å½±å“ä¸åŒ
    let closure = move || println!("x = {}", x);
    closure();
    println!("x ä»ç„¶æœ‰æ•ˆ: {}", x);  // âœ… Copy ç±»å‹

    println!("\n===== å¤šä¸ªæ•è· =====\n");

    let s = String::from("hello");
    let n = 42;

    // æ•è·å¤šä¸ªå˜é‡
    let closure = move || {
        println!("String: {}", s);  // ç§»åŠ¨
        println!("Number: {}", n);  // Copy
    };

    closure();
    // println!("{}", s);  // âŒ s å·²è¢«ç§»åŠ¨
    println!("n ä»ç„¶æœ‰æ•ˆ: {}", n);  // âœ… Copy

    println!("\n===== é€‰æ‹©æ€§æ•è· =====\n");

    let mut x = 10;
    let y = 20;

    {
        // åªæ•è·éœ€è¦çš„å˜é‡
        let mut closure = || {
            x += 1;
            println!("x = {}", x);
        };
        closure();
    }

    // y æ²¡æœ‰è¢«æ•è·,ä»ç„¶å¯ä»¥ä½¿ç”¨
    println!("y = {}", y);
    println!("x = {}", x);

    println!("\n===== é—­åŒ…ä¸çº¿ç¨‹ =====\n");

    use std::thread;

    let data = vec![1, 2, 3];

    // çº¿ç¨‹é—­åŒ…éœ€è¦ move
    let handle = thread::spawn(move || {
        println!("çº¿ç¨‹ä¸­: {:?}", data);
    });

    handle.join().unwrap();
    // println!("{:?}", data);  // âŒ data å·²è¢«ç§»åŠ¨åˆ°çº¿ç¨‹
}
```

**è¯´æ˜**:

- **move**: å¼ºåˆ¶é—­åŒ…è·å–æ•è·å˜é‡çš„æ‰€æœ‰æƒ
- **Copy**: å¯¹äº Copy ç±»å‹ï¼Œmove åªæ˜¯æ‹·è´
- **çº¿ç¨‹**: è·¨çº¿ç¨‹ä¼ é€’æ•°æ®å¿…é¡»ä½¿ç”¨ move

**è¾“å‡º**:

```text
===== move å…³é”®å­— =====

å€Ÿç”¨: [1, 2, 3]
x ä»ç„¶æœ‰æ•ˆ: [1, 2, 3]
æ‹¥æœ‰: [1, 2, 3]

===== Copy ç±»å‹ =====

x = 5
x ä»ç„¶æœ‰æ•ˆ: 5

===== å¤šä¸ªæ•è· =====

String: hello
Number: 42
n ä»ç„¶æœ‰æ•ˆ: 42

===== é€‰æ‹©æ€§æ•è· =====

x = 11
y = 20
x = 11

===== é—­åŒ…ä¸çº¿ç¨‹ =====

çº¿ç¨‹ä¸­: [1, 2, 3]
```

---

### ç¤ºä¾‹2.3: Result é”™è¯¯å¤„ç†

**ç›®æ ‡**: æŒæ¡ Result ç±»å‹çš„é”™è¯¯å¤„ç†

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::fs::File;
use std::io::{self, Read};

fn main() {
    println!("===== Result åŸºç¡€ =====\n");

    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
        } else {
            Ok(a / b)
        }
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    println!("\n===== ? æ“ä½œç¬¦ =====\n");

    fn read_username_from_file() -> Result<String, io::Error> {
        let mut file = File::open("username.txt")?;  // é”™è¯¯ä¼šè‡ªåŠ¨ä¼ æ’­
        let mut username = String::new();
        file.read_to_string(&mut username)?;
        Ok(username)
    }

    match read_username_from_file() {
        Ok(username) => println!("ç”¨æˆ·å: {}", username),
        Err(e) => println!("è¯»å–å¤±è´¥: {}", e),
    }

    println!("\n===== é“¾å¼æ–¹æ³• =====\n");

    // ä½¿ç”¨ ? æ“ä½œç¬¦çš„ç®€åŒ–ç‰ˆæœ¬
    fn read_username_short() -> Result<String, io::Error> {
        let mut username = String::new();
        File::open("username.txt")?.read_to_string(&mut username)?;
        Ok(username)
    }

    // ä½¿ç”¨ fs::read_to_string æ›´ç®€æ´
    fn read_username_shortest() -> Result<String, io::Error> {
        std::fs::read_to_string("username.txt")
    }

    println!("\n===== unwrap å’Œ expect =====\n");

    let good: Result<i32, &str> = Ok(42);
    let value = good.unwrap();  // å¦‚æœæ˜¯ Err ä¼š panic
    println!("value: {}", value);

    // expect å¯ä»¥è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯
    let value = good.expect("åº”è¯¥æ˜¯ Ok å€¼");
    println!("value: {}", value);

    // let bad: Result<i32, &str> = Err("å‡ºé”™äº†");
    // bad.unwrap();  // âŒ panic!

    println!("\n===== unwrap_or å’Œ unwrap_or_else =====\n");

    let ok_value: Result<i32, &str> = Ok(42);
    let err_value: Result<i32, &str> = Err("é”™è¯¯");

    // unwrap_or: æä¾›é»˜è®¤å€¼
    println!("ok: {}", ok_value.unwrap_or(0));
    println!("err: {}", err_value.unwrap_or(0));

    // unwrap_or_else: æä¾›è®¡ç®—é»˜è®¤å€¼çš„é—­åŒ…
    println!("err: {}", err_value.unwrap_or_else(|e| {
        println!("è®¡ç®—é»˜è®¤å€¼ï¼Œé”™è¯¯: {}", e);
        -1
    }));

    println!("\n===== map å’Œ map_err =====\n");

    let result: Result<i32, &str> = Ok(2);

    // map: è½¬æ¢æˆåŠŸå€¼
    let doubled = result.map(|x| x * 2);
    println!("doubled: {:?}", doubled);

    // map_err: è½¬æ¢é”™è¯¯å€¼
    let result: Result<i32, &str> = Err("é”™è¯¯");
    let mapped_err = result.map_err(|e| format!("æ˜ å°„é”™è¯¯: {}", e));
    println!("mapped_err: {:?}", mapped_err);

    println!("\n===== and_then =====\n");

    fn parse_then_double(s: &str) -> Result<i32, std::num::ParseIntError> {
        s.parse::<i32>()
            .and_then(|n| Ok(n * 2))
    }

    println!("parse_then_double(\"42\"): {:?}", parse_then_double("42"));
    println!("parse_then_double(\"abc\"): {:?}", parse_then_double("abc"));
}
```

**è¯´æ˜**:

- **Result**: `Ok(T)` è¡¨ç¤ºæˆåŠŸï¼Œ`Err(E)` è¡¨ç¤ºé”™è¯¯
- **? æ“ä½œç¬¦**: ç®€åŒ–é”™è¯¯ä¼ æ’­
- **unwrap**: å–å‡ºå€¼æˆ– panic
- **æ–¹æ³•é“¾**: mapã€and_then ç­‰ç»„åˆå™¨

**è¾“å‡º**:

```text
===== Result åŸºç¡€ =====

10 / 2 = 5

===== ? æ“ä½œç¬¦ =====

è¯»å–å¤±è´¥: No such file or directory (os error 2)

===== é“¾å¼æ–¹æ³• =====

===== unwrap å’Œ expect =====

value: 42
value: 42

===== unwrap_or å’Œ unwrap_or_else =====

ok: 42
err: 0
è®¡ç®—é»˜è®¤å€¼ï¼Œé”™è¯¯: é”™è¯¯
err: -1

===== map å’Œ map_err =====

doubled: Ok(4)
mapped_err: Err("æ˜ å°„é”™è¯¯: é”™è¯¯")

===== and_then =====

parse_then_double("42"): Ok(84)
parse_then_double("abc"): Err(ParseIntError { kind: InvalidDigit })
```

---

### ç¤ºä¾‹2.4: Option å¤„ç†

**ç›®æ ‡**: æŒæ¡ Option ç±»å‹çš„å¤„ç†æ–¹æ³•

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Option åŸºç¡€ =====\n");

    let some_number = Some(5);
    let no_number: Option<i32> = None;

    // match å¤„ç†
    match some_number {
        Some(n) => println!("æœ‰å€¼: {}", n),
        None => println!("æ²¡æœ‰å€¼"),
    }

    // if let å¤„ç†
    if let Some(n) = some_number {
        println!("if let: {}", n);
    }

    println!("\n===== å¸¸ç”¨æ–¹æ³• =====\n");

    let x = Some(2);

    // is_some / is_none
    println!("is_some: {}", x.is_some());
    println!("is_none: {}", x.is_none());

    // unwrap_or
    println!("unwrap_or(0): {}", x.unwrap_or(0));
    println!("None.unwrap_or(0): {}", None.unwrap_or(0));

    // unwrap_or_else
    println!("unwrap_or_else: {}", x.unwrap_or_else(|| 0));

    // unwrap_or_default
    let y: Option<i32> = None;
    println!("unwrap_or_default: {}", y.unwrap_or_default());

    println!("\n===== map è½¬æ¢ =====\n");

    let some_string = Some("hello");

    // map: è½¬æ¢å†…éƒ¨å€¼
    let some_len = some_string.map(|s| s.len());
    println!("é•¿åº¦: {:?}", some_len);

    let none_string: Option<&str> = None;
    let none_len = none_string.map(|s| s.len());
    println!("None çš„ map: {:?}", none_len);

    println!("\n===== and_then é“¾å¼ =====\n");

    fn square(x: i32) -> Option<i32> {
        Some(x * x)
    }

    fn negate(x: i32) -> Option<i32> {
        Some(-x)
    }

    let result = Some(2)
        .and_then(square)
        .and_then(negate);

    println!("ç»“æœ: {:?}", result);

    println!("\n===== filter è¿‡æ»¤ =====\n");

    let is_even = |x: &i32| x % 2 == 0;

    println!("{:?}", Some(4).filter(is_even));  // Some(4)
    println!("{:?}", Some(3).filter(is_even));  // None

    println!("\n===== or å’Œ or_else =====\n");

    let x = Some(2);
    let y = None;

    println!("x.or(y): {:?}", x.or(y));  // Some(2)
    println!("y.or(x): {:?}", y.or(x));  // Some(2)

    println!("\n===== zip =====\n");

    let x = Some(1);
    let y = Some("hi");
    let z: Option<i32> = None;

    // zip: ç»„åˆä¸¤ä¸ª Option
    println!("x.zip(y): {:?}", x.zip(y));  // Some((1, "hi"))
    println!("x.zip(z): {:?}", x.zip(z));  // None

    println!("\n===== å®é™…åº”ç”¨ =====\n");

    fn get_user_id(name: &str) -> Option<u32> {
        match name {
            "alice" => Some(1),
            "bob" => Some(2),
            _ => None,
        }
    }

    fn get_user_email(id: u32) -> Option<String> {
        match id {
            1 => Some("alice@example.com".to_string()),
            2 => Some("bob@example.com".to_string()),
            _ => None,
        }
    }

    // é“¾å¼æŸ¥è¯¢
    let email = get_user_id("alice")
        .and_then(get_user_email);

    println!("Email: {:?}", email);

    // ä½¿ç”¨é»˜è®¤å€¼
    let email = get_user_id("charlie")
        .and_then(get_user_email)
        .unwrap_or_else(|| "unknown@example.com".to_string());

    println!("Email (é»˜è®¤): {}", email);
}
```

**è¯´æ˜**:

- **Option**: è¡¨ç¤ºå¯èƒ½å­˜åœ¨æˆ–ä¸å­˜åœ¨çš„å€¼
- **map**: è½¬æ¢å†…éƒ¨å€¼
- **and_then**: é“¾å¼æ“ä½œ
- **filter**: æ ¹æ®æ¡ä»¶è¿‡æ»¤

**è¾“å‡º**:

```text
===== Option åŸºç¡€ =====

æœ‰å€¼: 5
if let: 5

===== å¸¸ç”¨æ–¹æ³• =====

is_some: true
is_none: false
unwrap_or(0): 2
None.unwrap_or(0): 0
unwrap_or_else: 2
unwrap_or_default: 0

===== map è½¬æ¢ =====

é•¿åº¦: Some(5)
None çš„ map: None

===== and_then é“¾å¼ =====

ç»“æœ: Some(-4)

===== filter è¿‡æ»¤ =====

Some(4)
None

===== or å’Œ or_else =====

x.or(y): Some(2)
y.or(x): Some(2)

===== zip =====

x.zip(y): Some((1, "hi"))
x.zip(z): None

===== å®é™…åº”ç”¨ =====

Email: Some("alice@example.com")
Email (é»˜è®¤): unknown@example.com
```

---

### ç¤ºä¾‹2.5: è‡ªå®šä¹‰é”™è¯¯ç±»å‹

**ç›®æ ‡**: åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯ç±»å‹

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::fmt;
use std::error::Error;

fn main() {
    println!("===== ç®€å•æšä¸¾é”™è¯¯ =====\n");

    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NegativeSquareRoot,
    }

    fn divide(a: f64, b: f64) -> Result<f64, MathError> {
        if b == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(a / b)
        }
    }

    fn sqrt(x: f64) -> Result<f64, MathError> {
        if x < 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    match sqrt(-4.0) {
        Ok(result) => println!("sqrt(-4) = {}", result),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    println!("\n===== å®ç° Error trait =====\n");

    #[derive(Debug)]
    struct AppError {
        message: String,
        code: u32,
    }

    impl fmt::Display for AppError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "é”™è¯¯ä»£ç  {}: {}", self.code, self.message)
        }
    }

    impl Error for AppError {}

    fn might_fail() -> Result<(), AppError> {
        Err(AppError {
            message: "æ“ä½œå¤±è´¥".to_string(),
            code: 404,
        })
    }

    match might_fail() {
        Ok(()) => println!("æˆåŠŸ"),
        Err(e) => println!("å¤±è´¥: {}", e),
    }

    println!("\n===== é”™è¯¯è½¬æ¢ =====\n");

    #[derive(Debug)]
    enum NetworkError {
        ConnectionError(String),
        TimeoutError,
        ParseError(std::num::ParseIntError),
    }

    impl From<std::num::ParseIntError> for NetworkError {
        fn from(err: std::num::ParseIntError) -> Self {
            NetworkError::ParseError(err)
        }
    }

    fn fetch_data(s: &str) -> Result<i32, NetworkError> {
        s.parse::<i32>()
            .map_err(NetworkError::from)  // è‡ªåŠ¨è½¬æ¢
            // æˆ–è€…ä½¿ç”¨ ? æ“ä½œç¬¦è‡ªåŠ¨è½¬æ¢
    }

    match fetch_data("42") {
        Ok(n) => println!("æ•°æ®: {}", n),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    match fetch_data("abc") {
        Ok(n) => println!("æ•°æ®: {}", n),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    println!("\n===== é”™è¯¯ä¸Šä¸‹æ–‡ =====\n");

    #[derive(Debug)]
    struct DetailedError {
        operation: String,
        source: Box<dyn Error>,
    }

    impl fmt::Display for DetailedError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "æ‰§è¡Œ {} æ—¶å‡ºé”™: {}", self.operation, self.source)
        }
    }

    impl Error for DetailedError {
        fn source(&self) -> Option<&(dyn Error + 'static)> {
            Some(&*self.source)
        }
    }

    println!("é”™è¯¯ä¸Šä¸‹æ–‡æä¾›æ›´å¤šè°ƒè¯•ä¿¡æ¯");
}
```

**è¯´æ˜**:

- **è‡ªå®šä¹‰é”™è¯¯**: ä½¿ç”¨æšä¸¾å®šä¹‰é”™è¯¯ç±»å‹
- **Error trait**: å®ç° Display å’Œ Error trait
- **From trait**: å®ç°é”™è¯¯ç±»å‹ä¹‹é—´çš„è½¬æ¢
- **é”™è¯¯é“¾**: ä½¿ç”¨ source() æ–¹æ³•å»ºç«‹é”™è¯¯é“¾

**è¾“å‡º**:

```text
===== ç®€å•æšä¸¾é”™è¯¯ =====

10 / 2 = 5
é”™è¯¯: NegativeSquareRoot

===== å®ç° Error trait =====

å¤±è´¥: é”™è¯¯ä»£ç  404: æ“ä½œå¤±è´¥

===== é”™è¯¯è½¬æ¢ =====

æ•°æ®: 42
é”™è¯¯: ParseError(ParseIntError { kind: InvalidDigit })

===== é”™è¯¯ä¸Šä¸‹æ–‡ =====

é”™è¯¯ä¸Šä¸‹æ–‡æä¾›æ›´å¤šè°ƒè¯•ä¿¡æ¯
```

---

### ç¤ºä¾‹2.6: é«˜é˜¶å‡½æ•°

**ç›®æ ‡**: æŒæ¡é«˜é˜¶å‡½æ•°çš„ä½¿ç”¨

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== å‡½æ•°ä½œä¸ºå‚æ•° =====\n");

    fn apply<F>(f: F, x: i32) -> i32
    where
        F: Fn(i32) -> i32,
    {
        f(x)
    }

    fn double(x: i32) -> i32 {
        x * 2
    }

    let triple = |x| x * 3;

    println!("apply(double, 5) = {}", apply(double, 5));
    println!("apply(triple, 5) = {}", apply(triple, 5));

    println!("\n===== å‡½æ•°ä½œä¸ºè¿”å›å€¼ =====\n");

    fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
        move |x| x * factor
    }

    let times_5 = create_multiplier(5);
    let times_10 = create_multiplier(10);

    println!("times_5(3) = {}", times_5(3));
    println!("times_10(3) = {}", times_10(3));

    println!("\n===== å‡½æ•°ç»„åˆ =====\n");

    fn compose<F, G, A, B, C>(f: F, g: G) -> impl Fn(A) -> C
    where
        F: Fn(A) -> B,
        G: Fn(B) -> C,
    {
        move |x| g(f(x))
    }

    let add_one = |x| x + 1;
    let double = |x| x * 2;

    let add_then_double = compose(add_one, double);

    println!("(5 + 1) * 2 = {}", add_then_double(5));

    println!("\n===== map_reduce æ¨¡å¼ =====\n");

    fn map_reduce<T, U, F, R>(data: &[T], map: F, reduce: R) -> U
    where
        F: Fn(&T) -> U,
        R: Fn(U, U) -> U,
        U: Clone,
    {
        let mut iter = data.iter().map(map);
        let first = iter.next().cloned().unwrap();
        iter.fold(first, reduce)
    }

    let numbers = vec![1, 2, 3, 4, 5];

    // å¹³æ–¹æ±‚å’Œ
    let sum_of_squares = map_reduce(
        &numbers,
        |&x| x * x,      // map: å¹³æ–¹
        |a, b| a + b,    // reduce: æ±‚å’Œ
    );

    println!("å¹³æ–¹å’Œ: {}", sum_of_squares);

    println!("\n===== æŸ¯é‡ŒåŒ– =====\n");

    // éƒ¨åˆ†åº”ç”¨
    fn partial_add(a: i32) -> impl Fn(i32) -> i32 {
        move |b| a + b
    }

    let add_5 = partial_add(5);
    println!("add_5(10) = {}", add_5(10));
    println!("add_5(20) = {}", add_5(20));

    println!("\n===== é“¾å¼æ„å»ºå™¨ =====\n");

    struct QueryBuilder {
        query: String,
    }

    impl QueryBuilder {
        fn new() -> Self {
            QueryBuilder {
                query: String::new(),
            }
        }

        fn select(mut self, fields: &str) -> Self {
            self.query.push_str(&format!("SELECT {} ", fields));
            self
        }

        fn from(mut self, table: &str) -> Self {
            self.query.push_str(&format!("FROM {} ", table));
            self
        }

        fn where_clause(mut self, condition: &str) -> Self {
            self.query.push_str(&format!("WHERE {} ", condition));
            self
        }

        fn build(self) -> String {
            self.query
        }
    }

    let query = QueryBuilder::new()
        .select("name, age")
        .from("users")
        .where_clause("age > 18")
        .build();

    println!("SQL: {}", query);
}
```

**è¯´æ˜**:

- **é«˜é˜¶å‡½æ•°**: æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°
- **å‡½æ•°ç»„åˆ**: å°†å¤šä¸ªå‡½æ•°ç»„åˆæˆæ–°å‡½æ•°
- **æŸ¯é‡ŒåŒ–**: å°†å¤šå‚æ•°å‡½æ•°è½¬æ¢ä¸ºå•å‚æ•°å‡½æ•°é“¾
- **æ„å»ºå™¨æ¨¡å¼**: é“¾å¼è°ƒç”¨æ„å»ºå¤æ‚å¯¹è±¡

**è¾“å‡º**:

```text
===== å‡½æ•°ä½œä¸ºå‚æ•° =====

apply(double, 5) = 10
apply(triple, 5) = 15

===== å‡½æ•°ä½œä¸ºè¿”å›å€¼ =====

times_5(3) = 15
times_10(3) = 30

===== å‡½æ•°ç»„åˆ =====

(5 + 1) * 2 = 12

===== map_reduce æ¨¡å¼ =====

å¹³æ–¹å’Œ: 55

===== æŸ¯é‡ŒåŒ– =====

add_5(10) = 15
add_5(20) = 25

===== é“¾å¼æ„å»ºå™¨ =====

SQL: SELECT name, age FROM users WHERE age > 18
```

---

## ğŸ“ Tier 3: é«˜çº§åº”ç”¨ç¤ºä¾‹

### ç¤ºä¾‹3.1: é«˜çº§é—­åŒ…æ¨¡å¼

**ç›®æ ‡**: æ·±å…¥ç†è§£ FnOnceã€FnMut å’Œ Fn

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== Fn: ä¸å¯å˜å€Ÿç”¨ =====\n");

    let s = String::from("hello");

    // Fn: å¯ä»¥å¤šæ¬¡è°ƒç”¨
    let print = || println!("s = {}", s);

    print();
    print();  // âœ… å¯ä»¥å¤šæ¬¡è°ƒç”¨
    print();

    println!("\n===== FnMut: å¯å˜å€Ÿç”¨ =====\n");

    let mut counter = 0;

    // FnMut: å¯ä»¥ä¿®æ”¹æ•è·çš„å˜é‡
    let mut increment = || {
        counter += 1;
        println!("counter = {}", counter);
    };

    increment();
    increment();
    increment();

    println!("\n===== FnOnce: æ¶ˆè´¹æ‰€æœ‰æƒ =====\n");

    let s = String::from("hello");

    // FnOnce: åªèƒ½è°ƒç”¨ä¸€æ¬¡
    let consume = || {
        let _moved = s;  // æ¶ˆè´¹ s
        println!("æ¶ˆè´¹äº† s");
    };

    consume();
    // consume();  // âŒ ä¸èƒ½å†æ¬¡è°ƒç”¨

    println!("\n===== å¼ºåˆ¶ FnOnce =====\n");

    let s = String::from("hello");

    // move ä½¿é—­åŒ…è·å–æ‰€æœ‰æƒ
    let take = move || {
        drop(s);  // æ˜¾å¼æ¶ˆè´¹
    };

    take();
    // take();  // âŒ ä¸èƒ½å†æ¬¡è°ƒç”¨

    println!("\n===== Trait çº¦æŸ =====\n");

    fn call_once<F>(f: F)
    where
        F: FnOnce(),
    {
        f();
    }

    fn call_mut<F>(mut f: F)
    where
        F: FnMut(),
    {
        f();
        f();
    }

    fn call_fn<F>(f: F)
    where
        F: Fn(),
    {
        f();
        f();
        f();
    }

    let s = String::from("hello");

    call_once(|| println!("{}", s));
    call_fn(|| println!("{}", s));

    println!("\n===== å®é™…åº”ç”¨: å›è°ƒ =====\n");

    struct EventHandler<F>
    where
        F: FnMut(i32),
    {
        callback: F,
    }

    impl<F> EventHandler<F>
    where
        F: FnMut(i32),
    {
        fn new(callback: F) -> Self {
            EventHandler { callback }
        }

        fn trigger(&mut self, value: i32) {
            (self.callback)(value);
        }
    }

    let mut handler = EventHandler::new(|x| {
        println!("æ¥æ”¶åˆ°äº‹ä»¶: {}", x);
    });

    handler.trigger(10);
    handler.trigger(20);
    handler.trigger(30);
}
```

**è¯´æ˜**:

- **Fn**: ä¸ä¿®æ”¹æ•è·çš„å˜é‡ï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨
- **FnMut**: å¯ä»¥ä¿®æ”¹æ•è·çš„å˜é‡ï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨
- **FnOnce**: æ¶ˆè´¹æ•è·çš„å˜é‡ï¼Œåªèƒ½è°ƒç”¨ä¸€æ¬¡
- **å±‚çº§**: Fn âŠ‚ FnMut âŠ‚ FnOnce

**è¾“å‡º**:

```text
===== Fn: ä¸å¯å˜å€Ÿç”¨ =====

s = hello
s = hello
s = hello

===== FnMut: å¯å˜å€Ÿç”¨ =====

counter = 1
counter = 2
counter = 3

===== FnOnce: æ¶ˆè´¹æ‰€æœ‰æƒ =====

æ¶ˆè´¹äº† s

===== å¼ºåˆ¶ FnOnce =====

===== Trait çº¦æŸ =====

hello
hello
hello
hello

===== å®é™…åº”ç”¨: å›è°ƒ =====

æ¥æ”¶åˆ°äº‹ä»¶: 10
æ¥æ”¶åˆ°äº‹ä»¶: 20
æ¥æ”¶åˆ°äº‹ä»¶: 30
```

---

### ç¤ºä¾‹3.2: è¿­ä»£å™¨è‡ªå®šä¹‰

**ç›®æ ‡**: å®ç°è‡ªå®šä¹‰è¿­ä»£å™¨

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== è‡ªå®šä¹‰è¿­ä»£å™¨ =====\n");

    struct Counter {
        count: u32,
        max: u32,
    }

    impl Counter {
        fn new(max: u32) -> Counter {
            Counter { count: 0, max }
        }
    }

    impl Iterator for Counter {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            if self.count < self.max {
                self.count += 1;
                Some(self.count)
            } else {
                None
            }
        }
    }

    let mut counter = Counter::new(5);

    println!("æ‰‹åŠ¨è°ƒç”¨ next:");
    println!("{:?}", counter.next());
    println!("{:?}", counter.next());
    println!("{:?}", counter.next());

    // ä½¿ç”¨ for å¾ªç¯
    println!("\nä½¿ç”¨ for å¾ªç¯:");
    for num in Counter::new(5) {
        println!("{}", num);
    }

    println!("\n===== å®ç° DoubleEndedIterator =====\n");

    struct Countdown {
        count: u32,
    }

    impl Countdown {
        fn new(count: u32) -> Self {
            Countdown { count }
        }
    }

    impl Iterator for Countdown {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            if self.count > 0 {
                self.count -= 1;
                Some(self.count + 1)
            } else {
                None
            }
        }
    }

    for num in Countdown::new(5) {
        print!("{} ", num);
    }
    println!();

    println!("\n===== è¿­ä»£å™¨é€‚é…å™¨ =====\n");

    let result: Vec<_> = Counter::new(5)
        .map(|x| x * x)
        .filter(|x| x % 2 == 0)
        .collect();

    println!("å¶æ•°å¹³æ–¹: {:?}", result);

    println!("\n===== è‡ªå®šä¹‰ collect =====\n");

    struct Fibonacci {
        curr: u32,
        next: u32,
    }

    impl Iterator for Fibonacci {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            let current = self.curr;

            self.curr = self.next;
            self.next = current + self.next;

            Some(current)
        }
    }

    fn fibonacci() -> Fibonacci {
        Fibonacci { curr: 0, next: 1 }
    }

    let fib: Vec<_> = fibonacci().take(10).collect();
    println!("æ–æ³¢é‚£å¥‘æ•°åˆ—: {:?}", fib);

    println!("\n===== IntoIterator =====\n");

    struct MyCollection {
        data: Vec<i32>,
    }

    impl IntoIterator for MyCollection {
        type Item = i32;
        type IntoIter = std::vec::IntoIter<i32>;

        fn into_iter(self) -> Self::IntoIter {
            self.data.into_iter()
        }
    }

    let collection = MyCollection {
        data: vec![1, 2, 3, 4, 5],
    };

    for item in collection {
        print!("{} ", item);
    }
    println!();
}
```

**è¯´æ˜**:

- **Iterator trait**: å®ç° next() æ–¹æ³•
- **type Item**: å…³è”ç±»å‹ï¼ŒæŒ‡å®šè¿­ä»£å™¨äº§ç”Ÿçš„ç±»å‹
- **IntoIterator**: ä½¿ç±»å‹å¯ä»¥è½¬æ¢ä¸ºè¿­ä»£å™¨
- **é€‚é…å™¨**: å¯ä»¥ä½¿ç”¨æ ‡å‡†åº“çš„æ‰€æœ‰è¿­ä»£å™¨æ–¹æ³•

**è¾“å‡º**:

```text
===== è‡ªå®šä¹‰è¿­ä»£å™¨ =====

æ‰‹åŠ¨è°ƒç”¨ next:
Some(1)
Some(2)
Some(3)

ä½¿ç”¨ for å¾ªç¯:
1
2
3
4
5

===== å®ç° DoubleEndedIterator =====

5 4 3 2 1

===== è¿­ä»£å™¨é€‚é…å™¨ =====

å¶æ•°å¹³æ–¹: [4, 16]

===== è‡ªå®šä¹‰ collect =====

æ–æ³¢é‚£å¥‘æ•°åˆ—: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

===== IntoIterator =====

1 2 3 4 5
```

---

### ç¤ºä¾‹3.3: é”™è¯¯å¤„ç†ç»„åˆ

**ç›®æ ‡**: æŒæ¡å¤æ‚çš„é”™è¯¯å¤„ç†æ¨¡å¼

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== and_then é“¾å¼ =====\n");

    fn parse(s: &str) -> Result<i32, std::num::ParseIntError> {
        s.parse()
    }

    fn double(n: i32) -> Result<i32, std::num::ParseIntError> {
        Ok(n * 2)
    }

    let result = parse("42")
        .and_then(double);

    println!("ç»“æœ: {:?}", result);

    println!("\n===== or_else å¤‡é€‰ =====\n");

    fn primary() -> Result<i32, &'static str> {
        Err("ä¸»è¦æ–¹æ³•å¤±è´¥")
    }

    fn fallback() -> Result<i32, &'static str> {
        Ok(42)
    }

    let result = primary()
        .or_else(|_| fallback());

    println!("ç»“æœ: {:?}", result);

    println!("\n===== å¤šä¸ªé”™è¯¯ç±»å‹ =====\n");

    use std::num::ParseIntError;
    use std::io;

    #[derive(Debug)]
    enum AppError {
        Parse(ParseIntError),
        Io(io::Error),
    }

    impl From<ParseIntError> for AppError {
        fn from(err: ParseIntError) -> Self {
            AppError::Parse(err)
        }
    }

    impl From<io::Error> for AppError {
        fn from(err: io::Error) -> Self {
            AppError::Io(err)
        }
    }

    fn complex_operation() -> Result<i32, AppError> {
        let n = "42".parse::<i32>()?;  // è‡ªåŠ¨è½¬æ¢ ParseIntError
        // std::fs::read_to_string("file.txt")?;  // è‡ªåŠ¨è½¬æ¢ io::Error
        Ok(n)
    }

    match complex_operation() {
        Ok(n) => println!("æˆåŠŸ: {}", n),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    println!("\n===== é”™è¯¯ä¸Šä¸‹æ–‡ =====\n");

    fn read_config() -> Result<String, String> {
        std::fs::read_to_string("config.toml")
            .map_err(|e| format!("è¯»å–é…ç½®å¤±è´¥: {}", e))
    }

    fn parse_config(content: String) -> Result<i32, String> {
        content.trim().parse()
            .map_err(|e: ParseIntError| format!("è§£æé…ç½®å¤±è´¥: {}", e))
    }

    fn load_config() -> Result<i32, String> {
        read_config()
            .and_then(parse_config)
    }

    match load_config() {
        Ok(config) => println!("é…ç½®: {}", config),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    println!("\n===== transpose =====\n");

    let x: Result<Option<i32>, &str> = Ok(Some(5));
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("transpose: {:?}", y);

    let x: Result<Option<i32>, &str> = Ok(None);
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("transpose: {:?}", y);

    println!("\n===== collect ç»“æœ =====\n");

    let strings = vec!["42", "93", "invalid", "18"];

    let results: Vec<_> = strings
        .iter()
        .map(|s| s.parse::<i32>())
        .collect();

    println!("ç‹¬ç«‹ç»“æœ: {:?}", results);

    // collect æˆ Result: é‡åˆ°ç¬¬ä¸€ä¸ªé”™è¯¯å°±å¤±è´¥
    let result: Result<Vec<_>, _> = strings
        .iter()
        .map(|s| s.parse::<i32>())
        .collect();

    println!("åˆå¹¶ç»“æœ: {:?}", result);

    // è¿‡æ»¤é”™è¯¯
    let numbers: Vec<_> = strings
        .iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();

    println!("åªä¿ç•™æˆåŠŸ: {:?}", numbers);
}
```

**è¯´æ˜**:

- **and_then**: é“¾å¼å¤„ç†æˆåŠŸæƒ…å†µ
- **or_else**: æä¾›å¤‡é€‰æ–¹æ¡ˆ
- **map_err**: è½¬æ¢é”™è¯¯ç±»å‹
- **transpose**: Result å’Œ Option äº’æ¢

**è¾“å‡º**:

```text
===== and_then é“¾å¼ =====

ç»“æœ: Ok(84)

===== or_else å¤‡é€‰ =====

ç»“æœ: Ok(42)

===== å¤šä¸ªé”™è¯¯ç±»å‹ =====

æˆåŠŸ: 42

===== é”™è¯¯ä¸Šä¸‹æ–‡ =====

é”™è¯¯: è¯»å–é…ç½®å¤±è´¥: No such file or directory (os error 2)

===== transpose =====

transpose: Some(Ok(5))
transpose: None

===== collect ç»“æœ =====

ç‹¬ç«‹ç»“æœ: [Ok(42), Ok(93), Err(ParseIntError { kind: InvalidDigit }), Ok(18)]
åˆå¹¶ç»“æœ: Err(ParseIntError { kind: InvalidDigit })
åªä¿ç•™æˆåŠŸ: [42, 93, 18]
```

---

### ç¤ºä¾‹3.4: å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼

**ç›®æ ‡**: æŒæ¡å‡½æ•°å¼ç¼–ç¨‹æŠ€å·§

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
fn main() {
    println!("===== é“¾å¼è½¬æ¢ =====\n");

    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let result: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // è¿‡æ»¤å¶æ•°
        .map(|&x| x * x)            // å¹³æ–¹
        .sum();                     // æ±‚å’Œ

    println!("å¶æ•°å¹³æ–¹å’Œ: {}", result);

    println!("\n===== fold ç´¯ç§¯ =====\n");

    // fold: ä»åˆå§‹å€¼å¼€å§‹ç´¯ç§¯
    let sum = numbers.iter().fold(0, |acc, &x| acc + x);
    println!("æ€»å’Œ: {}", sum);

    // å®ç° product
    let product = numbers.iter().take(5).fold(1, |acc, &x| acc * x);
    println!("å‰5ä¸ªæ•°çš„ä¹˜ç§¯: {}", product);

    // å®ç° max
    let max = numbers.iter().fold(i32::MIN, |acc, &x| acc.max(x));
    println!("æœ€å¤§å€¼: {}", max);

    println!("\n===== scan æœ‰çŠ¶æ€è½¬æ¢ =====\n");

    // scan: ç±»ä¼¼ map ä½†ä¿æŒçŠ¶æ€
    let factorials: Vec<_> = (1..=5)
        .scan(1, |state, x| {
            *state *= x;
            Some(*state)
        })
        .collect();

    println!("é˜¶ä¹˜åºåˆ—: {:?}", factorials);

    println!("\n===== partition åˆ†ç»„ =====\n");

    let (evens, odds): (Vec<_>, Vec<_>) = numbers
        .iter()
        .partition(|&&x| x % 2 == 0);

    println!("å¶æ•°: {:?}", evens);
    println!("å¥‡æ•°: {:?}", odds);

    println!("\n===== flat_map æ‰å¹³åŒ– =====\n");

    let words = vec!["hello world", "rust programming"];

    let all_words: Vec<_> = words
        .iter()
        .flat_map(|s| s.split_whitespace())
        .collect();

    println!("æ‰€æœ‰å•è¯: {:?}", all_words);

    println!("\n===== zip ç»„åˆ =====\n");

    let names = vec!["Alice", "Bob", "Charlie"];
    let ages = vec![30, 25, 35];

    let people: Vec<_> = names.iter()
        .zip(ages.iter())
        .collect();

    println!("äººå‘˜ä¿¡æ¯: {:?}", people);

    println!("\n===== æƒ°æ€§æ±‚å€¼ =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // åˆ›å»ºè¿­ä»£å™¨é“¾ (ä¸ä¼šç«‹å³æ‰§è¡Œ)
    let iter = numbers.iter()
        .map(|x| {
            println!("map: {}", x);
            x * 2
        })
        .filter(|x| {
            println!("filter: {}", x);
            x % 4 == 0
        });

    println!("è¿­ä»£å™¨å·²åˆ›å»º");

    // collect è§¦å‘æ±‚å€¼
    let result: Vec<_> = iter.collect();
    println!("ç»“æœ: {:?}", result);

    println!("\n===== å®é™…åº”ç”¨: æ•°æ®å¤„ç†ç®¡é“ =====\n");

    #[derive(Debug)]
    struct User {
        name: String,
        age: u32,
        active: bool,
    }

    let users = vec![
        User { name: "Alice".to_string(), age: 30, active: true },
        User { name: "Bob".to_string(), age: 25, active: false },
        User { name: "Charlie".to_string(), age: 35, active: true },
        User { name: "David".to_string(), age: 28, active: true },
    ];

    let active_names: Vec<_> = users
        .iter()
        .filter(|u| u.active)      // åªä¿ç•™æ´»è·ƒç”¨æˆ·
        .filter(|u| u.age > 28)    // å¹´é¾„å¤§äº28
        .map(|u| &u.name)           // æå–åå­—
        .collect();

    println!("æ´»è·ƒä¸”å¹´é¾„>28çš„ç”¨æˆ·: {:?}", active_names);
}
```

**è¯´æ˜**:

- **é“¾å¼**: ç»„åˆå¤šä¸ªè¿­ä»£å™¨æ–¹æ³•
- **fold**: ç´¯ç§¯è®¡ç®—
- **scan**: æœ‰çŠ¶æ€çš„ map
- **partition**: æŒ‰æ¡ä»¶åˆ†ç»„
- **æƒ°æ€§æ±‚å€¼**: åªåœ¨æ¶ˆè´¹æ—¶æ‰æ‰§è¡Œ

**è¾“å‡º**:

```text
===== é“¾å¼è½¬æ¢ =====

å¶æ•°å¹³æ–¹å’Œ: 220

===== fold ç´¯ç§¯ =====

æ€»å’Œ: 55
å‰5ä¸ªæ•°çš„ä¹˜ç§¯: 120
æœ€å¤§å€¼: 10

===== scan æœ‰çŠ¶æ€è½¬æ¢ =====

é˜¶ä¹˜åºåˆ—: [1, 2, 6, 24, 120]

===== partition åˆ†ç»„ =====

å¶æ•°: [2, 4, 6, 8, 10]
å¥‡æ•°: [1, 3, 5, 7, 9]

===== flat_map æ‰å¹³åŒ– =====

æ‰€æœ‰å•è¯: ["hello", "world", "rust", "programming"]

===== zip ç»„åˆ =====

äººå‘˜ä¿¡æ¯: [("Alice", 30), ("Bob", 25), ("Charlie", 35)]

===== æƒ°æ€§æ±‚å€¼ =====

è¿­ä»£å™¨å·²åˆ›å»º
map: 1
filter: 2
map: 2
filter: 4
map: 3
filter: 6
map: 4
filter: 8
map: 5
filter: 10
ç»“æœ: [4, 8]

===== å®é™…åº”ç”¨: æ•°æ®å¤„ç†ç®¡é“ =====

æ´»è·ƒä¸”å¹´é¾„>28çš„ç”¨æˆ·: ["Alice", "Charlie"]
```

---

## ğŸ“ æ€»ç»“

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **ç¬¬ä¸€é˜¶æ®µ** (Tier 1): æŒæ¡åŸºç¡€ (ç¤ºä¾‹ 1.1-1.6)
   - match è¡¨è¾¾å¼å’Œæ¨¡å¼åŒ¹é…
   - å¾ªç¯ç»“æ„
   - å‡½æ•°å®šä¹‰
   - è¿­ä»£å™¨åŸºç¡€

2. **ç¬¬äºŒé˜¶æ®µ** (Tier 2): å®è·µåº”ç”¨ (ç¤ºä¾‹ 2.1-2.6)
   - é—­åŒ…å’Œæ•è·
   - Result/Option é”™è¯¯å¤„ç†
   - è‡ªå®šä¹‰é”™è¯¯ç±»å‹
   - é«˜é˜¶å‡½æ•°

3. **ç¬¬ä¸‰é˜¶æ®µ** (Tier 3): æ·±å…¥ç†è§£ (ç¤ºä¾‹ 3.1-3.4)
   - Fn Traits è¯¦è§£
   - è‡ªå®šä¹‰è¿­ä»£å™¨
   - é”™è¯¯å¤„ç†ç»„åˆ
   - å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ | ç›¸å…³ç¤ºä¾‹ | é‡è¦æ€§ | éš¾åº¦ |
|------|---------|--------|------|
| match è¡¨è¾¾å¼ | 1.1, 1.2 | â­â­â­â­â­ | â­ |
| å¾ªç¯ | 1.3, 1.6 | â­â­â­â­â­ | â­ |
| å‡½æ•° | 1.4 | â­â­â­â­â­ | â­ |
| è¿­ä»£å™¨ | 1.5, 3.2 | â­â­â­â­â­ | â­â­ |
| é—­åŒ… | 2.1, 2.2, 3.1 | â­â­â­â­â­ | â­â­ |
| é”™è¯¯å¤„ç† | 2.3, 2.4, 2.5, 3.3 | â­â­â­â­â­ | â­â­ |
| é«˜é˜¶å‡½æ•° | 2.6 | â­â­â­â­ | â­â­â­ |
| å‡½æ•°å¼ç¼–ç¨‹ | 3.4 | â­â­â­â­ | â­â­â­ |

### æœ€ä½³å®è·µ

1. **æ§åˆ¶æµ**:
   - ä¼˜å…ˆä½¿ç”¨ match è¿›è¡Œç©·å°½æ€§æ£€æŸ¥
   - ä½¿ç”¨ if let/while let ç®€åŒ–å•ä¸€æ¨¡å¼åŒ¹é…
   - for å¾ªç¯ä¼˜äº while å¾ªç¯

2. **å‡½æ•°è®¾è®¡**:
   - ä½¿ç”¨ Result å’Œ Option å¤„ç†é”™è¯¯
   - è¿”å› impl Trait è€Œéå…·ä½“ç±»å‹
   - å‡½æ•°åº”è¯¥å°è€Œä¸“æ³¨

3. **è¿­ä»£å™¨**:
   - ä¼˜å…ˆä½¿ç”¨è¿­ä»£å™¨è€Œéå¾ªç¯
   - åˆ©ç”¨æƒ°æ€§æ±‚å€¼æé«˜æ€§èƒ½
   - é“¾å¼è°ƒç”¨ä¿æŒä»£ç ç®€æ´

4. **é”™è¯¯å¤„ç†**:
   - ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
   - ä¸ºåº”ç”¨å®šä¹‰è‡ªå®šä¹‰é”™è¯¯ç±»å‹
   - æä¾›é”™è¯¯ä¸Šä¸‹æ–‡ä¿¡æ¯

### ä¸‹ä¸€æ­¥

- ğŸ“– æ·±å…¥å­¦ä¹ : [æ¨¡å¼åŒ¹é…æŒ‡å—](./04_æ¨¡å¼åŒ¹é…æŒ‡å—.md)
- ğŸ“– æ·±å…¥å­¦ä¹ : [é”™è¯¯å¤„ç†æŒ‡å—](./05_é”™è¯¯å¤„ç†æŒ‡å—.md)
- ğŸš€ å®æˆ˜é¡¹ç›®: [C03 å®æˆ˜é¡¹ç›®é›†](./07_å®æˆ˜é¡¹ç›®é›†.md) (å³å°†åˆ›å»º)
- ğŸ“š å‚è€ƒæ–‡æ¡£: [tier_03_references](../tier_03_references/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ’¡ æŒæ¡æ§åˆ¶æµå’Œå‡½æ•°æ˜¯ Rust ç¼–ç¨‹çš„åŸºç¡€ï¼Œç†Ÿç»ƒä½¿ç”¨è¿­ä»£å™¨å’Œé—­åŒ…èƒ½å¤§å¤§æå‡ä»£ç è´¨é‡! ğŸ¦€**-
