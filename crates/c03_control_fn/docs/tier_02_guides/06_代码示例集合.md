# 💻 C03: 控制流与函数 - 代码示例集合

> **创建日期**: 2025-10-25
> **难度**: ⭐ 基础 → ⭐⭐⭐ 进阶
> **目标**: 通过丰富的代码示例深入理解控制流和函数系统

---

## 📊 目录

- [💻 C03: 控制流与函数 - 代码示例集合](#-c03-控制流与函数---代码示例集合)
  - [📊 目录](#-目录)
  - [📋 示例导航](#-示例导航)
  - [🌟 Tier 1: 基础控制流示例](#-tier-1-基础控制流示例)
    - [示例1.1: 基础 match 表达式](#示例11-基础-match-表达式)
    - [示例1.2: if let 和 while let](#示例12-if-let-和-while-let)
    - [示例1.3: 循环结构](#示例13-循环结构)
    - [示例1.4: 基础函数定义](#示例14-基础函数定义)
    - [示例1.5: 函数式迭代器](#示例15-函数式迭代器)
    - [示例1.6: Range 和迭代](#示例16-range-和迭代)
  - [🚀 Tier 2: 实践应用示例](#-tier-2-实践应用示例)
    - [示例2.1: 闭包基础](#示例21-闭包基础)
    - [示例2.2: 闭包捕获模式](#示例22-闭包捕获模式)
    - [示例2.3: Result 错误处理](#示例23-result-错误处理)
    - [示例2.4: Option 处理](#示例24-option-处理)
    - [示例2.5: 自定义错误类型](#示例25-自定义错误类型)
    - [示例2.6: 高阶函数](#示例26-高阶函数)
  - [🎓 Tier 3: 高级应用示例](#-tier-3-高级应用示例)
    - [示例3.1: 高级闭包模式](#示例31-高级闭包模式)
    - [示例3.2: 迭代器自定义](#示例32-迭代器自定义)
    - [示例3.3: 错误处理组合](#示例33-错误处理组合)
    - [示例3.4: 函数式编程模式](#示例34-函数式编程模式)
  - [📝 总结](#-总结)
    - [学习路径建议](#学习路径建议)
    - [核心概念总结](#核心概念总结)
    - [最佳实践](#最佳实践)
    - [下一步](#下一步)

## 📋 示例导航

| 编号 | 主题 | 难度 | 重点概念 |
|------|------|------|---------|
| [1.1](#示例11-基础-match-表达式) | 基础 match 表达式 | ⭐ | match、模式匹配 |
| [1.2](#示例12-if-let-和-while-let) | if let 和 while let | ⭐ | 简化匹配 |
| [1.3](#示例13-循环结构) | 循环结构 | ⭐ | loop、while、for |
| [1.4](#示例14-基础函数定义) | 基础函数定义 | ⭐ | fn、参数、返回值 |
| [1.5](#示例15-函数式迭代器) | 函数式迭代器 | ⭐⭐ | map、filter、fold |
| [1.6](#示例16-range-和迭代) | Range 和迭代 | ⭐ | 范围、迭代 |
| [2.1](#示例21-闭包基础) | 闭包基础 | ⭐⭐ | 捕获、Fn Traits |
| [2.2](#示例22-闭包捕获模式) | 闭包捕获模式 | ⭐⭐ | move、借用 |
| [2.3](#示例23-result-错误处理) | Result 错误处理 | ⭐⭐ | ?、错误传播 |
| [2.4](#示例24-option-处理) | Option 处理 | ⭐⭐ | 方法链、组合 |
| [2.5](#示例25-自定义错误类型) | 自定义错误类型 | ⭐⭐ | Error trait |
| [2.6](#示例26-高阶函数) | 高阶函数 | ⭐⭐⭐ | 函数作为参数 |
| [3.1](#示例31-高级闭包模式) | 高级闭包模式 | ⭐⭐⭐ | FnOnce、FnMut |
| [3.2](#示例32-迭代器自定义) | 迭代器自定义 | ⭐⭐⭐ | Iterator trait |
| [3.3](#示例33-错误处理组合) | 错误处理组合 | ⭐⭐⭐ | and_then、or_else |
| [3.4](#示例34-函数式编程模式) | 函数式编程模式 | ⭐⭐⭐ | 组合、柯里化 |

---

## 🌟 Tier 1: 基础控制流示例

### 示例1.1: 基础 match 表达式

**目标**: 掌握 match 表达式的各种用法

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== 基础 match =====\n");

    let number = 3;

    match number {
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        4 | 5 => println!("四或五"),  // 多个模式
        _ => println!("其他"),
    }

    println!("\n===== match 返回值 =====\n");

    let result = match number {
        1 => "一",
        2 => "二",
        3 => "三",
        _ => "其他",
    };

    println!("结果: {}", result);

    println!("\n===== 范围匹配 =====\n");

    let score = 85;

    let grade = match score {
        90..=100 => "A",
        80..=89 => "B",
        70..=79 => "C",
        60..=69 => "D",
        _ => "F",
    };

    println!("分数 {} 对应等级 {}", score, grade);

    println!("\n===== 匹配守卫 =====\n");

    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("小于5: {}", x),
        Some(x) => println!("大于等于5: {}", x),
        None => println!("没有值"),
    }

    println!("\n===== 解构元组 =====\n");

    let pair = (0, -2);

    match pair {
        (0, y) => println!("第一个是0, y = {}", y),
        (x, 0) => println!("x = {}, 第二个是0", x),
        _ => println!("任意组合: {:?}", pair),
    }

    println!("\n===== 解构枚举 =====\n");

    #[derive(Debug)]
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("退出");
        }
        Message::Move { x, y } => {
            println!("移动到 ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("文本消息: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("改变颜色: RGB({}, {}, {})", r, g, b);
        }
    }

    println!("\n===== @ 绑定 =====\n");

    let value = 15;

    match value {
        n @ 1..=10 => println!("1到10: {}", n),
        n @ 11..=20 => println!("11到20: {}", n),
        _ => println!("其他"),
    }
}
```

**说明**:

- **match**: Rust 的主要控制流工具，必须穷尽所有可能
- **返回值**: match 是表达式，可以返回值
- **模式**: 支持字面值、范围、解构、守卫等多种模式
- **@ 绑定**: 在模式匹配的同时绑定值

**输出**:

```text
===== 基础 match =====

三

===== match 返回值 =====

结果: 三

===== 范围匹配 =====

分数 85 对应等级 B

===== 匹配守卫 =====

小于5: 4

===== 解构元组 =====

第一个是0, y = -2

===== 解构枚举 =====

改变颜色: RGB(0, 160, 255)

===== @ 绑定 =====

11到20: 15
```

---

### 示例1.2: if let 和 while let

**目标**: 掌握简化的模式匹配语法

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== if let 基础 =====\n");

    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    // if let: 只关心一种模式
    if let Some(color) = favorite_color {
        println!("使用你喜欢的颜色: {}", color);
    } else if is_tuesday {
        println!("星期二是绿色的日子!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("使用紫色作为背景色");
        } else {
            println!("使用橙色作为背景色");
        }
    } else {
        println!("使用蓝色作为背景色");
    }

    println!("\n===== while let 循环 =====\n");

    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    // while let: 持续匹配直到失败
    while let Some(top) = stack.pop() {
        println!("弹出: {}", top);
    }

    println!("\n===== 实际应用: 解析输入 =====\n");

    let inputs = vec![
        Some("42"),
        Some("abc"),
        None,
        Some("123"),
    ];

    for input in inputs {
        if let Some(s) = input {
            if let Ok(num) = s.parse::<i32>() {
                println!("解析成功: {}", num);
            } else {
                println!("解析失败: {}", s);
            }
        } else {
            println!("输入为空");
        }
    }

    println!("\n===== 匹配守卫 =====\n");

    let numbers = vec![1, 2, 3, 4, 5, 6];
    let mut iter = numbers.iter();

    while let Some(&num) = iter.next() {
        if num % 2 == 0 {
            println!("偶数: {}", num);
        }
    }
}
```

**说明**:

- **if let**: 简化只匹配一种模式的情况
- **while let**: 循环匹配，常用于迭代器
- **vs match**: 当只关心一种模式时更简洁
- **组合**: 可以与 else if、else 等组合使用

**输出**:

```text
===== if let 基础 =====

使用紫色作为背景色

===== while let 循环 =====

弹出: 3
弹出: 2
弹出: 1

===== 实际应用: 解析输入 =====

解析成功: 42
解析失败: abc
输入为空
解析成功: 123

===== 匹配守卫 =====

偶数: 2
偶数: 4
偶数: 6
```

---

### 示例1.3: 循环结构

**目标**: 掌握 Rust 的三种循环

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== loop 无限循环 =====\n");

    let mut counter = 0;

    // loop: 无限循环，需要 break 退出
    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;  // loop 可以返回值
        }
    };

    println!("循环返回值: {}", result);

    println!("\n===== while 条件循环 =====\n");

    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("起飞!");

    println!("\n===== for 迭代循环 =====\n");

    let arr = [10, 20, 30, 40, 50];

    // for: 迭代集合
    for element in arr {
        println!("值: {}", element);
    }

    // 使用范围
    for number in 1..=5 {
        println!("数字: {}", number);
    }

    // 带索引的迭代
    for (index, value) in arr.iter().enumerate() {
        println!("arr[{}] = {}", index, value);
    }

    println!("\n===== 循环标签 =====\n");

    let mut count = 0;

    // 循环标签: 用于嵌套循环
    'outer: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;  // 退出内层循环
            }
            if count == 2 {
                break 'outer;  // 退出外层循环
            }
            remaining -= 1;
        }

        count += 1;
    }

    println!("循环结束");

    println!("\n===== 循环性能对比 =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // for 循环 (推荐): 最清晰
    for num in &numbers {
        print!("{} ", num);
    }
    println!();

    // while 循环: 不如 for 清晰
    let mut index = 0;
    while index < numbers.len() {
        print!("{} ", numbers[index]);
        index += 1;
    }
    println!();

    // loop 循环: 最不清晰
    let mut index = 0;
    loop {
        if index >= numbers.len() {
            break;
        }
        print!("{} ", numbers[index]);
        index += 1;
    }
    println!();

    println!("\n===== continue 和 break =====\n");

    for num in 1..=10 {
        if num % 2 == 0 {
            continue;  // 跳过偶数
        }

        if num > 7 {
            break;  // 大于7就退出
        }

        println!("奇数: {}", num);
    }
}
```

**说明**:

- **loop**: 无限循环，可以返回值
- **while**: 条件循环，当条件为真时执行
- **for**: 迭代循环，遍历集合（最推荐）
- **标签**: 用于嵌套循环的跳转

**输出**:

```text
===== loop 无限循环 =====

循环返回值: 20

===== while 条件循环 =====

3!
2!
1!
起飞!

===== for 迭代循环 =====

值: 10
值: 20
值: 30
值: 40
值: 50
数字: 1
数字: 2
数字: 3
数字: 4
数字: 5
arr[0] = 10
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 50

===== 循环标签 =====

count = 0
remaining = 10
count = 1
remaining = 10
count = 2
remaining = 10
循环结束

===== 循环性能对比 =====

1 2 3 4 5
1 2 3 4 5
1 2 3 4 5

===== continue 和 break =====

奇数: 1
奇数: 3
奇数: 5
奇数: 7
```

---

### 示例1.4: 基础函数定义

**目标**: 掌握函数的定义和调用

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== 基础函数 =====\n");

    // 无参数无返回值
    fn greet() {
        println!("你好!");
    }

    greet();

    // 有参数
    fn greet_name(name: &str) {
        println!("你好, {}!", name);
    }

    greet_name("Alice");

    // 有返回值
    fn add(a: i32, b: i32) -> i32 {
        a + b  // 表达式返回值 (无分号)
    }

    let sum = add(5, 3);
    println!("5 + 3 = {}", sum);

    println!("\n===== 语句 vs 表达式 =====\n");

    fn calculate() -> i32 {
        let x = 5;        // 语句
        let y = {         // 代码块是表达式
            let z = 3;
            z + 1         // 表达式返回 4
        };
        x + y             // 表达式返回 9
    }

    println!("结果: {}", calculate());

    println!("\n===== 提前返回 =====\n");

    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            return Err(String::from("除数不能为零"));  // 提前返回
        }
        Ok(a / b)
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("错误: {}", e),
    }

    match divide(10.0, 0.0) {
        Ok(result) => println!("10 / 0 = {}", result),
        Err(e) => println!("错误: {}", e),
    }

    println!("\n===== 多返回值 =====\n");

    fn swap(a: i32, b: i32) -> (i32, i32) {
        (b, a)  // 使用元组返回多个值
    }

    let (x, y) = swap(1, 2);
    println!("交换后: x = {}, y = {}", x, y);

    println!("\n===== 不返回的函数 =====\n");

    fn infinite_loop() -> ! {
        loop {
            // 永不返回
        }
    }

    fn exit_program() -> ! {
        std::process::exit(0);
    }

    println!("! 类型表示永不返回");

    println!("\n===== 函数作为值 =====\n");

    fn double(x: i32) -> i32 {
        x * 2
    }

    // 函数指针
    let f: fn(i32) -> i32 = double;
    println!("double(5) = {}", f(5));

    // 函数作为参数
    fn apply(f: fn(i32) -> i32, value: i32) -> i32 {
        f(value)
    }

    println!("apply(double, 3) = {}", apply(double, 3));
}
```

**说明**:

- **函数签名**: `fn name(params) -> return_type`
- **表达式**: 函数体的最后一个表达式是返回值
- **提前返回**: 使用 `return` 关键字
- **! 类型**: 表示永不返回的函数

**输出**:

```text
===== 基础函数 =====

你好!
你好, Alice!
5 + 3 = 8

===== 语句 vs 表达式 =====

结果: 9

===== 提前返回 =====

10 / 2 = 5
错误: 除数不能为零

===== 多返回值 =====

交换后: x = 2, y = 1

===== 不返回的函数 =====

! 类型表示永不返回

===== 函数作为值 =====

double(5) = 10
apply(double, 3) = 6
```

---

### 示例1.5: 函数式迭代器

**目标**: 掌握迭代器的函数式操作

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== map: 映射转换 =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // map: 转换每个元素
    let doubled: Vec<_> = numbers.iter().map(|x| x * 2).collect();

    println!("原始: {:?}", numbers);
    println!("加倍: {:?}", doubled);

    println!("\n===== filter: 过滤 =====\n");

    // filter: 保留满足条件的元素
    let evens: Vec<_> = numbers.iter().filter(|&&x| x % 2 == 0).collect();

    println!("偶数: {:?}", evens);

    println!("\n===== 链式调用 =====\n");

    let result: Vec<_> = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // 过滤偶数
        .map(|x| x * x)             // 平方
        .collect();

    println!("偶数的平方: {:?}", result);

    println!("\n===== fold: 累积 =====\n");

    // fold: 累积计算
    let sum = numbers.iter().fold(0, |acc, &x| acc + x);

    println!("总和: {}", sum);

    // 计算乘积
    let product = numbers.iter().fold(1, |acc, &x| acc * x);

    println!("乘积: {}", product);

    println!("\n===== for_each: 副作用 =====\n");

    // for_each: 对每个元素执行操作
    numbers.iter().for_each(|x| {
        println!("处理: {}", x);
    });

    println!("\n===== 常用迭代器方法 =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // any: 是否存在满足条件的元素
    let has_even = numbers.iter().any(|&x| x % 2 == 0);
    println!("是否有偶数: {}", has_even);

    // all: 是否所有元素都满足条件
    let all_positive = numbers.iter().all(|&x| x > 0);
    println!("是否都为正数: {}", all_positive);

    // find: 查找第一个满足条件的元素
    let first_even = numbers.iter().find(|&&x| x % 2 == 0);
    println!("第一个偶数: {:?}", first_even);

    // position: 查找元素的位置
    let pos = numbers.iter().position(|&x| x == 3);
    println!("3的位置: {:?}", pos);

    // take: 取前 n 个元素
    let first_three: Vec<_> = numbers.iter().take(3).collect();
    println!("前三个: {:?}", first_three);

    // skip: 跳过前 n 个元素
    let after_two: Vec<_> = numbers.iter().skip(2).collect();
    println!("跳过前两个: {:?}", after_two);

    println!("\n===== 惰性求值 =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // 创建迭代器 (不会立即执行)
    let iter = numbers.iter().map(|x| {
        println!("映射 {}", x);
        x * 2
    });

    println!("迭代器已创建,但还未执行");

    // collect 触发求值
    let result: Vec<_> = iter.collect();

    println!("结果: {:?}", result);

    println!("\n===== 实际应用 =====\n");

    // 处理字符串
    let words = vec!["hello", "world", "rust"];

    let uppercase: Vec<String> = words
        .iter()
        .map(|&s| s.to_uppercase())
        .collect();

    println!("大写: {:?}", uppercase);

    // 链式过滤和转换
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let result: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // 偶数
        .map(|&x| x * x)            // 平方
        .sum();                     // 求和

    println!("偶数平方和: {}", result);
}
```

**说明**:

- **map**: 转换每个元素
- **filter**: 过滤元素
- **fold**: 累积计算
- **惰性求值**: 迭代器在调用 collect 等消费者时才执行

**输出**:

```text
===== map: 映射转换 =====

原始: [1, 2, 3, 4, 5]
加倍: [2, 4, 6, 8, 10]

===== filter: 过滤 =====

偶数: [2, 4]

===== 链式调用 =====

偶数的平方: [4, 16]

===== fold: 累积 =====

总和: 15
乘积: 120

===== for_each: 副作用 =====

处理: 1
处理: 2
处理: 3
处理: 4
处理: 5

===== 常用迭代器方法 =====

是否有偶数: true
是否都为正数: true
第一个偶数: Some(2)
3的位置: Some(2)
前三个: [1, 2, 3]
跳过前两个: [3, 4, 5]

===== 惰性求值 =====

迭代器已创建,但还未执行
映射 1
映射 2
映射 3
映射 4
映射 5
结果: [2, 4, 6, 8, 10]

===== 实际应用 =====

大写: ["HELLO", "WORLD", "RUST"]
偶数平方和: 120
```

---

### 示例1.6: Range 和迭代

**目标**: 掌握范围和迭代的使用

**难度**: ⭐

**代码**:

```rust
fn main() {
    println!("===== Range 范围 =====\n");

    // 1..5: 半开区间 [1, 5)
    for i in 1..5 {
        print!("{} ", i);
    }
    println!();

    // 1..=5: 闭区间 [1, 5]
    for i in 1..=5 {
        print!("{} ", i);
    }
    println!();

    println!("\n===== Range 方法 =====\n");

    // collect 成向量
    let range: Vec<_> = (1..=10).collect();
    println!("Range 向量: {:?}", range);

    // 范围求和
    let sum: i32 = (1..=100).sum();
    println!("1到100的和: {}", sum);

    // 范围过滤
    let evens: Vec<_> = (1..=10).filter(|x| x % 2 == 0).collect();
    println!("1到10的偶数: {:?}", evens);

    println!("\n===== 字符范围 =====\n");

    // 字符范围
    for c in 'a'..='z' {
        print!("{}", c);
    }
    println!();

    println!("\n===== 步长迭代 =====\n");

    // step_by: 指定步长
    let step: Vec<_> = (0..10).step_by(2).collect();
    println!("步长为2: {:?}", step);

    // rev: 反向迭代
    let reversed: Vec<_> = (1..=5).rev().collect();
    println!("反向: {:?}", reversed);

    println!("\n===== 无限范围 =====\n");

    // 1..: 无限范围
    let first_five: Vec<_> = (1..).take(5).collect();
    println!("前五个自然数: {:?}", first_five);

    // enumerate: 添加索引
    for (index, value) in (10..15).enumerate() {
        println!("[{}] = {}", index, value);
    }

    println!("\n===== 实际应用 =====\n");

    // 生成数组索引
    let arr = vec!['a', 'b', 'c', 'd', 'e'];

    for i in 0..arr.len() {
        println!("arr[{}] = {}", i, arr[i]);
    }

    // 倒序遍历
    for i in (0..arr.len()).rev() {
        println!("反向 arr[{}] = {}", i, arr[i]);
    }

    // 部分范围
    for i in 1..arr.len()-1 {
        println!("中间 arr[{}] = {}", i, arr[i]);
    }
}
```

**说明**:

- **Range**: `start..end` (半开) 和 `start..=end` (闭区间)
- **步长**: 使用 `step_by` 方法
- **反向**: 使用 `rev` 方法
- **无限**: `start..` 创建无限范围

**输出**:

```text
===== Range 范围 =====

1 2 3 4
1 2 3 4 5

===== Range 方法 =====

Range 向量: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
1到100的和: 5050
1到10的偶数: [2, 4, 6, 8, 10]

===== 字符范围 =====

abcdefghijklmnopqrstuvwxyz

===== 步长迭代 =====

步长为2: [0, 2, 4, 6, 8]
反向: [5, 4, 3, 2, 1]

===== 无限范围 =====

前五个自然数: [1, 2, 3, 4, 5]
[0] = 10
[1] = 11
[2] = 12
[3] = 13
[4] = 14

===== 实际应用 =====

arr[0] = a
arr[1] = b
arr[2] = c
arr[3] = d
arr[4] = e
反向 arr[4] = e
反向 arr[3] = d
反向 arr[2] = c
反向 arr[1] = b
反向 arr[0] = a
中间 arr[1] = b
中间 arr[2] = c
中间 arr[3] = d
```

---

## 🚀 Tier 2: 实践应用示例

### 示例2.1: 闭包基础

**目标**: 掌握闭包的定义和使用

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 闭包语法 =====\n");

    // 完整语法
    let add_one_v1 = |x: i32| -> i32 { x + 1 };

    // 类型推断
    let add_one_v2 = |x| { x + 1 };

    // 简写 (单表达式)
    let add_one_v3 = |x| x + 1;

    println!("add_one_v1(5) = {}", add_one_v1(5));
    println!("add_one_v2(5) = {}", add_one_v2(5));
    println!("add_one_v3(5) = {}", add_one_v3(5));

    println!("\n===== 捕获环境 =====\n");

    let x = 4;

    // 闭包可以捕获外部变量
    let equal_to_x = |z| z == x;

    let y = 4;
    println!("equal_to_x(y) = {}", equal_to_x(y));

    // 函数不能捕获环境
    // fn equal_to_x_fn(z: i32) -> bool {
    //     z == x  // ❌ 错误!
    // }

    println!("\n===== 不可变借用 =====\n");

    let list = vec![1, 2, 3];
    println!("捕获前: {:?}", list);

    // 闭包不可变借用 list
    let only_borrows = || println!("闭包中: {:?}", list);

    println!("调用前: {:?}", list);
    only_borrows();
    println!("调用后: {:?}", list);

    println!("\n===== 可变借用 =====\n");

    let mut list = vec![1, 2, 3];
    println!("修改前: {:?}", list);

    // 闭包可变借用 list
    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("修改后: {:?}", list);

    println!("\n===== Fn Traits =====\n");

    // Fn: 不可变借用
    let x = vec![1, 2, 3];
    let fn_closure = || println!("{:?}", x);
    fn_closure();
    fn_closure();  // 可以多次调用

    // FnMut: 可变借用
    let mut x = vec![1, 2, 3];
    let mut fn_mut_closure = || x.push(4);
    fn_mut_closure();
    // fn_mut_closure();  // 可以多次调用

    // FnOnce: 获取所有权
    let x = vec![1, 2, 3];
    let fn_once_closure = move || {
        println!("{:?}", x);
        // x 被消费
    };
    fn_once_closure();
    // fn_once_closure();  // ❌ 不能再次调用

    println!("\n===== 闭包作为参数 =====\n");

    fn apply<F>(f: F, x: i32) -> i32
    where
        F: Fn(i32) -> i32,
    {
        f(x)
    }

    let double = |x| x * 2;
    println!("apply(double, 5) = {}", apply(double, 5));

    println!("\n===== 闭包作为返回值 =====\n");

    fn create_adder(n: i32) -> impl Fn(i32) -> i32 {
        move |x| x + n
    }

    let add_5 = create_adder(5);
    println!("add_5(10) = {}", add_5(10));
}
```

**说明**:

- **闭包**: 可以捕获环境的匿名函数
- **Fn Traits**: Fn (不可变借用)、FnMut (可变借用)、FnOnce (所有权)
- **类型推断**: 闭包的类型可以自动推断
- **move**: 强制获取所有权

**输出**:

```text
===== 闭包语法 =====

add_one_v1(5) = 6
add_one_v2(5) = 6
add_one_v3(5) = 6

===== 捕获环境 =====

equal_to_x(y) = true

===== 不可变借用 =====

捕获前: [1, 2, 3]
调用前: [1, 2, 3]
闭包中: [1, 2, 3]
调用后: [1, 2, 3]

===== 可变借用 =====

修改前: [1, 2, 3]
修改后: [1, 2, 3, 7]

===== Fn Traits =====

[1, 2, 3]
[1, 2, 3]

===== 闭包作为参数 =====

apply(double, 5) = 10

===== 闭包作为返回值 =====

add_5(10) = 15
```

---

### 示例2.2: 闭包捕获模式

**目标**: 理解闭包的不同捕获方式

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== move 关键字 =====\n");

    let x = vec![1, 2, 3];

    // 不使用 move: 借用
    let closure1 = || println!("借用: {:?}", x);
    closure1();
    println!("x 仍然有效: {:?}", x);

    // 使用 move: 获取所有权
    let closure2 = move || println!("拥有: {:?}", x);
    closure2();
    // println!("{:?}", x);  // ❌ x 已被移动

    println!("\n===== Copy 类型 =====\n");

    let x = 5;  // i32 实现了 Copy

    // move 对 Copy 类型的影响不同
    let closure = move || println!("x = {}", x);
    closure();
    println!("x 仍然有效: {}", x);  // ✅ Copy 类型

    println!("\n===== 多个捕获 =====\n");

    let s = String::from("hello");
    let n = 42;

    // 捕获多个变量
    let closure = move || {
        println!("String: {}", s);  // 移动
        println!("Number: {}", n);  // Copy
    };

    closure();
    // println!("{}", s);  // ❌ s 已被移动
    println!("n 仍然有效: {}", n);  // ✅ Copy

    println!("\n===== 选择性捕获 =====\n");

    let mut x = 10;
    let y = 20;

    {
        // 只捕获需要的变量
        let mut closure = || {
            x += 1;
            println!("x = {}", x);
        };
        closure();
    }

    // y 没有被捕获,仍然可以使用
    println!("y = {}", y);
    println!("x = {}", x);

    println!("\n===== 闭包与线程 =====\n");

    use std::thread;

    let data = vec![1, 2, 3];

    // 线程闭包需要 move
    let handle = thread::spawn(move || {
        println!("线程中: {:?}", data);
    });

    handle.join().unwrap();
    // println!("{:?}", data);  // ❌ data 已被移动到线程
}
```

**说明**:

- **move**: 强制闭包获取捕获变量的所有权
- **Copy**: 对于 Copy 类型，move 只是拷贝
- **线程**: 跨线程传递数据必须使用 move

**输出**:

```text
===== move 关键字 =====

借用: [1, 2, 3]
x 仍然有效: [1, 2, 3]
拥有: [1, 2, 3]

===== Copy 类型 =====

x = 5
x 仍然有效: 5

===== 多个捕获 =====

String: hello
Number: 42
n 仍然有效: 42

===== 选择性捕获 =====

x = 11
y = 20
x = 11

===== 闭包与线程 =====

线程中: [1, 2, 3]
```

---

### 示例2.3: Result 错误处理

**目标**: 掌握 Result 类型的错误处理

**难度**: ⭐⭐

**代码**:

```rust
use std::fs::File;
use std::io::{self, Read};

fn main() {
    println!("===== Result 基础 =====\n");

    fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err("除数不能为零".to_string())
        } else {
            Ok(a / b)
        }
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("错误: {}", e),
    }

    println!("\n===== ? 操作符 =====\n");

    fn read_username_from_file() -> Result<String, io::Error> {
        let mut file = File::open("username.txt")?;  // 错误会自动传播
        let mut username = String::new();
        file.read_to_string(&mut username)?;
        Ok(username)
    }

    match read_username_from_file() {
        Ok(username) => println!("用户名: {}", username),
        Err(e) => println!("读取失败: {}", e),
    }

    println!("\n===== 链式方法 =====\n");

    // 使用 ? 操作符的简化版本
    fn read_username_short() -> Result<String, io::Error> {
        let mut username = String::new();
        File::open("username.txt")?.read_to_string(&mut username)?;
        Ok(username)
    }

    // 使用 fs::read_to_string 更简洁
    fn read_username_shortest() -> Result<String, io::Error> {
        std::fs::read_to_string("username.txt")
    }

    println!("\n===== unwrap 和 expect =====\n");

    let good: Result<i32, &str> = Ok(42);
    let value = good.unwrap();  // 如果是 Err 会 panic
    println!("value: {}", value);

    // expect 可以自定义错误消息
    let value = good.expect("应该是 Ok 值");
    println!("value: {}", value);

    // let bad: Result<i32, &str> = Err("出错了");
    // bad.unwrap();  // ❌ panic!

    println!("\n===== unwrap_or 和 unwrap_or_else =====\n");

    let ok_value: Result<i32, &str> = Ok(42);
    let err_value: Result<i32, &str> = Err("错误");

    // unwrap_or: 提供默认值
    println!("ok: {}", ok_value.unwrap_or(0));
    println!("err: {}", err_value.unwrap_or(0));

    // unwrap_or_else: 提供计算默认值的闭包
    println!("err: {}", err_value.unwrap_or_else(|e| {
        println!("计算默认值，错误: {}", e);
        -1
    }));

    println!("\n===== map 和 map_err =====\n");

    let result: Result<i32, &str> = Ok(2);

    // map: 转换成功值
    let doubled = result.map(|x| x * 2);
    println!("doubled: {:?}", doubled);

    // map_err: 转换错误值
    let result: Result<i32, &str> = Err("错误");
    let mapped_err = result.map_err(|e| format!("映射错误: {}", e));
    println!("mapped_err: {:?}", mapped_err);

    println!("\n===== and_then =====\n");

    fn parse_then_double(s: &str) -> Result<i32, std::num::ParseIntError> {
        s.parse::<i32>()
            .and_then(|n| Ok(n * 2))
    }

    println!("parse_then_double(\"42\"): {:?}", parse_then_double("42"));
    println!("parse_then_double(\"abc\"): {:?}", parse_then_double("abc"));
}
```

**说明**:

- **Result**: `Ok(T)` 表示成功，`Err(E)` 表示错误
- **? 操作符**: 简化错误传播
- **unwrap**: 取出值或 panic
- **方法链**: map、and_then 等组合器

**输出**:

```text
===== Result 基础 =====

10 / 2 = 5

===== ? 操作符 =====

读取失败: No such file or directory (os error 2)

===== 链式方法 =====

===== unwrap 和 expect =====

value: 42
value: 42

===== unwrap_or 和 unwrap_or_else =====

ok: 42
err: 0
计算默认值，错误: 错误
err: -1

===== map 和 map_err =====

doubled: Ok(4)
mapped_err: Err("映射错误: 错误")

===== and_then =====

parse_then_double("42"): Ok(84)
parse_then_double("abc"): Err(ParseIntError { kind: InvalidDigit })
```

---

### 示例2.4: Option 处理

**目标**: 掌握 Option 类型的处理方法

**难度**: ⭐⭐

**代码**:

```rust
fn main() {
    println!("===== Option 基础 =====\n");

    let some_number = Some(5);
    let no_number: Option<i32> = None;

    // match 处理
    match some_number {
        Some(n) => println!("有值: {}", n),
        None => println!("没有值"),
    }

    // if let 处理
    if let Some(n) = some_number {
        println!("if let: {}", n);
    }

    println!("\n===== 常用方法 =====\n");

    let x = Some(2);

    // is_some / is_none
    println!("is_some: {}", x.is_some());
    println!("is_none: {}", x.is_none());

    // unwrap_or
    println!("unwrap_or(0): {}", x.unwrap_or(0));
    println!("None.unwrap_or(0): {}", None.unwrap_or(0));

    // unwrap_or_else
    println!("unwrap_or_else: {}", x.unwrap_or_else(|| 0));

    // unwrap_or_default
    let y: Option<i32> = None;
    println!("unwrap_or_default: {}", y.unwrap_or_default());

    println!("\n===== map 转换 =====\n");

    let some_string = Some("hello");

    // map: 转换内部值
    let some_len = some_string.map(|s| s.len());
    println!("长度: {:?}", some_len);

    let none_string: Option<&str> = None;
    let none_len = none_string.map(|s| s.len());
    println!("None 的 map: {:?}", none_len);

    println!("\n===== and_then 链式 =====\n");

    fn square(x: i32) -> Option<i32> {
        Some(x * x)
    }

    fn negate(x: i32) -> Option<i32> {
        Some(-x)
    }

    let result = Some(2)
        .and_then(square)
        .and_then(negate);

    println!("结果: {:?}", result);

    println!("\n===== filter 过滤 =====\n");

    let is_even = |x: &i32| x % 2 == 0;

    println!("{:?}", Some(4).filter(is_even));  // Some(4)
    println!("{:?}", Some(3).filter(is_even));  // None

    println!("\n===== or 和 or_else =====\n");

    let x = Some(2);
    let y = None;

    println!("x.or(y): {:?}", x.or(y));  // Some(2)
    println!("y.or(x): {:?}", y.or(x));  // Some(2)

    println!("\n===== zip =====\n");

    let x = Some(1);
    let y = Some("hi");
    let z: Option<i32> = None;

    // zip: 组合两个 Option
    println!("x.zip(y): {:?}", x.zip(y));  // Some((1, "hi"))
    println!("x.zip(z): {:?}", x.zip(z));  // None

    println!("\n===== 实际应用 =====\n");

    fn get_user_id(name: &str) -> Option<u32> {
        match name {
            "alice" => Some(1),
            "bob" => Some(2),
            _ => None,
        }
    }

    fn get_user_email(id: u32) -> Option<String> {
        match id {
            1 => Some("alice@example.com".to_string()),
            2 => Some("bob@example.com".to_string()),
            _ => None,
        }
    }

    // 链式查询
    let email = get_user_id("alice")
        .and_then(get_user_email);

    println!("Email: {:?}", email);

    // 使用默认值
    let email = get_user_id("charlie")
        .and_then(get_user_email)
        .unwrap_or_else(|| "unknown@example.com".to_string());

    println!("Email (默认): {}", email);
}
```

**说明**:

- **Option**: 表示可能存在或不存在的值
- **map**: 转换内部值
- **and_then**: 链式操作
- **filter**: 根据条件过滤

**输出**:

```text
===== Option 基础 =====

有值: 5
if let: 5

===== 常用方法 =====

is_some: true
is_none: false
unwrap_or(0): 2
None.unwrap_or(0): 0
unwrap_or_else: 2
unwrap_or_default: 0

===== map 转换 =====

长度: Some(5)
None 的 map: None

===== and_then 链式 =====

结果: Some(-4)

===== filter 过滤 =====

Some(4)
None

===== or 和 or_else =====

x.or(y): Some(2)
y.or(x): Some(2)

===== zip =====

x.zip(y): Some((1, "hi"))
x.zip(z): None

===== 实际应用 =====

Email: Some("alice@example.com")
Email (默认): unknown@example.com
```

---

### 示例2.5: 自定义错误类型

**目标**: 创建自定义错误类型

**难度**: ⭐⭐

**代码**:

```rust
use std::fmt;
use std::error::Error;

fn main() {
    println!("===== 简单枚举错误 =====\n");

    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NegativeSquareRoot,
    }

    fn divide(a: f64, b: f64) -> Result<f64, MathError> {
        if b == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(a / b)
        }
    }

    fn sqrt(x: f64) -> Result<f64, MathError> {
        if x < 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    match divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("错误: {:?}", e),
    }

    match sqrt(-4.0) {
        Ok(result) => println!("sqrt(-4) = {}", result),
        Err(e) => println!("错误: {:?}", e),
    }

    println!("\n===== 实现 Error trait =====\n");

    #[derive(Debug)]
    struct AppError {
        message: String,
        code: u32,
    }

    impl fmt::Display for AppError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "错误代码 {}: {}", self.code, self.message)
        }
    }

    impl Error for AppError {}

    fn might_fail() -> Result<(), AppError> {
        Err(AppError {
            message: "操作失败".to_string(),
            code: 404,
        })
    }

    match might_fail() {
        Ok(()) => println!("成功"),
        Err(e) => println!("失败: {}", e),
    }

    println!("\n===== 错误转换 =====\n");

    #[derive(Debug)]
    enum NetworkError {
        ConnectionError(String),
        TimeoutError,
        ParseError(std::num::ParseIntError),
    }

    impl From<std::num::ParseIntError> for NetworkError {
        fn from(err: std::num::ParseIntError) -> Self {
            NetworkError::ParseError(err)
        }
    }

    fn fetch_data(s: &str) -> Result<i32, NetworkError> {
        s.parse::<i32>()
            .map_err(NetworkError::from)  // 自动转换
            // 或者使用 ? 操作符自动转换
    }

    match fetch_data("42") {
        Ok(n) => println!("数据: {}", n),
        Err(e) => println!("错误: {:?}", e),
    }

    match fetch_data("abc") {
        Ok(n) => println!("数据: {}", n),
        Err(e) => println!("错误: {:?}", e),
    }

    println!("\n===== 错误上下文 =====\n");

    #[derive(Debug)]
    struct DetailedError {
        operation: String,
        source: Box<dyn Error>,
    }

    impl fmt::Display for DetailedError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "执行 {} 时出错: {}", self.operation, self.source)
        }
    }

    impl Error for DetailedError {
        fn source(&self) -> Option<&(dyn Error + 'static)> {
            Some(&*self.source)
        }
    }

    println!("错误上下文提供更多调试信息");
}
```

**说明**:

- **自定义错误**: 使用枚举定义错误类型
- **Error trait**: 实现 Display 和 Error trait
- **From trait**: 实现错误类型之间的转换
- **错误链**: 使用 source() 方法建立错误链

**输出**:

```text
===== 简单枚举错误 =====

10 / 2 = 5
错误: NegativeSquareRoot

===== 实现 Error trait =====

失败: 错误代码 404: 操作失败

===== 错误转换 =====

数据: 42
错误: ParseError(ParseIntError { kind: InvalidDigit })

===== 错误上下文 =====

错误上下文提供更多调试信息
```

---

### 示例2.6: 高阶函数

**目标**: 掌握高阶函数的使用

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 函数作为参数 =====\n");

    fn apply<F>(f: F, x: i32) -> i32
    where
        F: Fn(i32) -> i32,
    {
        f(x)
    }

    fn double(x: i32) -> i32 {
        x * 2
    }

    let triple = |x| x * 3;

    println!("apply(double, 5) = {}", apply(double, 5));
    println!("apply(triple, 5) = {}", apply(triple, 5));

    println!("\n===== 函数作为返回值 =====\n");

    fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
        move |x| x * factor
    }

    let times_5 = create_multiplier(5);
    let times_10 = create_multiplier(10);

    println!("times_5(3) = {}", times_5(3));
    println!("times_10(3) = {}", times_10(3));

    println!("\n===== 函数组合 =====\n");

    fn compose<F, G, A, B, C>(f: F, g: G) -> impl Fn(A) -> C
    where
        F: Fn(A) -> B,
        G: Fn(B) -> C,
    {
        move |x| g(f(x))
    }

    let add_one = |x| x + 1;
    let double = |x| x * 2;

    let add_then_double = compose(add_one, double);

    println!("(5 + 1) * 2 = {}", add_then_double(5));

    println!("\n===== map_reduce 模式 =====\n");

    fn map_reduce<T, U, F, R>(data: &[T], map: F, reduce: R) -> U
    where
        F: Fn(&T) -> U,
        R: Fn(U, U) -> U,
        U: Clone,
    {
        let mut iter = data.iter().map(map);
        let first = iter.next().cloned().unwrap();
        iter.fold(first, reduce)
    }

    let numbers = vec![1, 2, 3, 4, 5];

    // 平方求和
    let sum_of_squares = map_reduce(
        &numbers,
        |&x| x * x,      // map: 平方
        |a, b| a + b,    // reduce: 求和
    );

    println!("平方和: {}", sum_of_squares);

    println!("\n===== 柯里化 =====\n");

    // 部分应用
    fn partial_add(a: i32) -> impl Fn(i32) -> i32 {
        move |b| a + b
    }

    let add_5 = partial_add(5);
    println!("add_5(10) = {}", add_5(10));
    println!("add_5(20) = {}", add_5(20));

    println!("\n===== 链式构建器 =====\n");

    struct QueryBuilder {
        query: String,
    }

    impl QueryBuilder {
        fn new() -> Self {
            QueryBuilder {
                query: String::new(),
            }
        }

        fn select(mut self, fields: &str) -> Self {
            self.query.push_str(&format!("SELECT {} ", fields));
            self
        }

        fn from(mut self, table: &str) -> Self {
            self.query.push_str(&format!("FROM {} ", table));
            self
        }

        fn where_clause(mut self, condition: &str) -> Self {
            self.query.push_str(&format!("WHERE {} ", condition));
            self
        }

        fn build(self) -> String {
            self.query
        }
    }

    let query = QueryBuilder::new()
        .select("name, age")
        .from("users")
        .where_clause("age > 18")
        .build();

    println!("SQL: {}", query);
}
```

**说明**:

- **高阶函数**: 接受函数作为参数或返回函数的函数
- **函数组合**: 将多个函数组合成新函数
- **柯里化**: 将多参数函数转换为单参数函数链
- **构建器模式**: 链式调用构建复杂对象

**输出**:

```text
===== 函数作为参数 =====

apply(double, 5) = 10
apply(triple, 5) = 15

===== 函数作为返回值 =====

times_5(3) = 15
times_10(3) = 30

===== 函数组合 =====

(5 + 1) * 2 = 12

===== map_reduce 模式 =====

平方和: 55

===== 柯里化 =====

add_5(10) = 15
add_5(20) = 25

===== 链式构建器 =====

SQL: SELECT name, age FROM users WHERE age > 18
```

---

## 🎓 Tier 3: 高级应用示例

### 示例3.1: 高级闭包模式

**目标**: 深入理解 FnOnce、FnMut 和 Fn

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== Fn: 不可变借用 =====\n");

    let s = String::from("hello");

    // Fn: 可以多次调用
    let print = || println!("s = {}", s);

    print();
    print();  // ✅ 可以多次调用
    print();

    println!("\n===== FnMut: 可变借用 =====\n");

    let mut counter = 0;

    // FnMut: 可以修改捕获的变量
    let mut increment = || {
        counter += 1;
        println!("counter = {}", counter);
    };

    increment();
    increment();
    increment();

    println!("\n===== FnOnce: 消费所有权 =====\n");

    let s = String::from("hello");

    // FnOnce: 只能调用一次
    let consume = || {
        let _moved = s;  // 消费 s
        println!("消费了 s");
    };

    consume();
    // consume();  // ❌ 不能再次调用

    println!("\n===== 强制 FnOnce =====\n");

    let s = String::from("hello");

    // move 使闭包获取所有权
    let take = move || {
        drop(s);  // 显式消费
    };

    take();
    // take();  // ❌ 不能再次调用

    println!("\n===== Trait 约束 =====\n");

    fn call_once<F>(f: F)
    where
        F: FnOnce(),
    {
        f();
    }

    fn call_mut<F>(mut f: F)
    where
        F: FnMut(),
    {
        f();
        f();
    }

    fn call_fn<F>(f: F)
    where
        F: Fn(),
    {
        f();
        f();
        f();
    }

    let s = String::from("hello");

    call_once(|| println!("{}", s));
    call_fn(|| println!("{}", s));

    println!("\n===== 实际应用: 回调 =====\n");

    struct EventHandler<F>
    where
        F: FnMut(i32),
    {
        callback: F,
    }

    impl<F> EventHandler<F>
    where
        F: FnMut(i32),
    {
        fn new(callback: F) -> Self {
            EventHandler { callback }
        }

        fn trigger(&mut self, value: i32) {
            (self.callback)(value);
        }
    }

    let mut handler = EventHandler::new(|x| {
        println!("接收到事件: {}", x);
    });

    handler.trigger(10);
    handler.trigger(20);
    handler.trigger(30);
}
```

**说明**:

- **Fn**: 不修改捕获的变量，可以多次调用
- **FnMut**: 可以修改捕获的变量，可以多次调用
- **FnOnce**: 消费捕获的变量，只能调用一次
- **层级**: Fn ⊂ FnMut ⊂ FnOnce

**输出**:

```text
===== Fn: 不可变借用 =====

s = hello
s = hello
s = hello

===== FnMut: 可变借用 =====

counter = 1
counter = 2
counter = 3

===== FnOnce: 消费所有权 =====

消费了 s

===== 强制 FnOnce =====

===== Trait 约束 =====

hello
hello
hello
hello

===== 实际应用: 回调 =====

接收到事件: 10
接收到事件: 20
接收到事件: 30
```

---

### 示例3.2: 迭代器自定义

**目标**: 实现自定义迭代器

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 自定义迭代器 =====\n");

    struct Counter {
        count: u32,
        max: u32,
    }

    impl Counter {
        fn new(max: u32) -> Counter {
            Counter { count: 0, max }
        }
    }

    impl Iterator for Counter {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            if self.count < self.max {
                self.count += 1;
                Some(self.count)
            } else {
                None
            }
        }
    }

    let mut counter = Counter::new(5);

    println!("手动调用 next:");
    println!("{:?}", counter.next());
    println!("{:?}", counter.next());
    println!("{:?}", counter.next());

    // 使用 for 循环
    println!("\n使用 for 循环:");
    for num in Counter::new(5) {
        println!("{}", num);
    }

    println!("\n===== 实现 DoubleEndedIterator =====\n");

    struct Countdown {
        count: u32,
    }

    impl Countdown {
        fn new(count: u32) -> Self {
            Countdown { count }
        }
    }

    impl Iterator for Countdown {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            if self.count > 0 {
                self.count -= 1;
                Some(self.count + 1)
            } else {
                None
            }
        }
    }

    for num in Countdown::new(5) {
        print!("{} ", num);
    }
    println!();

    println!("\n===== 迭代器适配器 =====\n");

    let result: Vec<_> = Counter::new(5)
        .map(|x| x * x)
        .filter(|x| x % 2 == 0)
        .collect();

    println!("偶数平方: {:?}", result);

    println!("\n===== 自定义 collect =====\n");

    struct Fibonacci {
        curr: u32,
        next: u32,
    }

    impl Iterator for Fibonacci {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            let current = self.curr;

            self.curr = self.next;
            self.next = current + self.next;

            Some(current)
        }
    }

    fn fibonacci() -> Fibonacci {
        Fibonacci { curr: 0, next: 1 }
    }

    let fib: Vec<_> = fibonacci().take(10).collect();
    println!("斐波那契数列: {:?}", fib);

    println!("\n===== IntoIterator =====\n");

    struct MyCollection {
        data: Vec<i32>,
    }

    impl IntoIterator for MyCollection {
        type Item = i32;
        type IntoIter = std::vec::IntoIter<i32>;

        fn into_iter(self) -> Self::IntoIter {
            self.data.into_iter()
        }
    }

    let collection = MyCollection {
        data: vec![1, 2, 3, 4, 5],
    };

    for item in collection {
        print!("{} ", item);
    }
    println!();
}
```

**说明**:

- **Iterator trait**: 实现 next() 方法
- **type Item**: 关联类型，指定迭代器产生的类型
- **IntoIterator**: 使类型可以转换为迭代器
- **适配器**: 可以使用标准库的所有迭代器方法

**输出**:

```text
===== 自定义迭代器 =====

手动调用 next:
Some(1)
Some(2)
Some(3)

使用 for 循环:
1
2
3
4
5

===== 实现 DoubleEndedIterator =====

5 4 3 2 1

===== 迭代器适配器 =====

偶数平方: [4, 16]

===== 自定义 collect =====

斐波那契数列: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

===== IntoIterator =====

1 2 3 4 5
```

---

### 示例3.3: 错误处理组合

**目标**: 掌握复杂的错误处理模式

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== and_then 链式 =====\n");

    fn parse(s: &str) -> Result<i32, std::num::ParseIntError> {
        s.parse()
    }

    fn double(n: i32) -> Result<i32, std::num::ParseIntError> {
        Ok(n * 2)
    }

    let result = parse("42")
        .and_then(double);

    println!("结果: {:?}", result);

    println!("\n===== or_else 备选 =====\n");

    fn primary() -> Result<i32, &'static str> {
        Err("主要方法失败")
    }

    fn fallback() -> Result<i32, &'static str> {
        Ok(42)
    }

    let result = primary()
        .or_else(|_| fallback());

    println!("结果: {:?}", result);

    println!("\n===== 多个错误类型 =====\n");

    use std::num::ParseIntError;
    use std::io;

    #[derive(Debug)]
    enum AppError {
        Parse(ParseIntError),
        Io(io::Error),
    }

    impl From<ParseIntError> for AppError {
        fn from(err: ParseIntError) -> Self {
            AppError::Parse(err)
        }
    }

    impl From<io::Error> for AppError {
        fn from(err: io::Error) -> Self {
            AppError::Io(err)
        }
    }

    fn complex_operation() -> Result<i32, AppError> {
        let n = "42".parse::<i32>()?;  // 自动转换 ParseIntError
        // std::fs::read_to_string("file.txt")?;  // 自动转换 io::Error
        Ok(n)
    }

    match complex_operation() {
        Ok(n) => println!("成功: {}", n),
        Err(e) => println!("错误: {:?}", e),
    }

    println!("\n===== 错误上下文 =====\n");

    fn read_config() -> Result<String, String> {
        std::fs::read_to_string("config.toml")
            .map_err(|e| format!("读取配置失败: {}", e))
    }

    fn parse_config(content: String) -> Result<i32, String> {
        content.trim().parse()
            .map_err(|e: ParseIntError| format!("解析配置失败: {}", e))
    }

    fn load_config() -> Result<i32, String> {
        read_config()
            .and_then(parse_config)
    }

    match load_config() {
        Ok(config) => println!("配置: {}", config),
        Err(e) => println!("错误: {}", e),
    }

    println!("\n===== transpose =====\n");

    let x: Result<Option<i32>, &str> = Ok(Some(5));
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("transpose: {:?}", y);

    let x: Result<Option<i32>, &str> = Ok(None);
    let y: Option<Result<i32, &str>> = x.transpose();
    println!("transpose: {:?}", y);

    println!("\n===== collect 结果 =====\n");

    let strings = vec!["42", "93", "invalid", "18"];

    let results: Vec<_> = strings
        .iter()
        .map(|s| s.parse::<i32>())
        .collect();

    println!("独立结果: {:?}", results);

    // collect 成 Result: 遇到第一个错误就失败
    let result: Result<Vec<_>, _> = strings
        .iter()
        .map(|s| s.parse::<i32>())
        .collect();

    println!("合并结果: {:?}", result);

    // 过滤错误
    let numbers: Vec<_> = strings
        .iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();

    println!("只保留成功: {:?}", numbers);
}
```

**说明**:

- **and_then**: 链式处理成功情况
- **or_else**: 提供备选方案
- **map_err**: 转换错误类型
- **transpose**: Result 和 Option 互换

**输出**:

```text
===== and_then 链式 =====

结果: Ok(84)

===== or_else 备选 =====

结果: Ok(42)

===== 多个错误类型 =====

成功: 42

===== 错误上下文 =====

错误: 读取配置失败: No such file or directory (os error 2)

===== transpose =====

transpose: Some(Ok(5))
transpose: None

===== collect 结果 =====

独立结果: [Ok(42), Ok(93), Err(ParseIntError { kind: InvalidDigit }), Ok(18)]
合并结果: Err(ParseIntError { kind: InvalidDigit })
只保留成功: [42, 93, 18]
```

---

### 示例3.4: 函数式编程模式

**目标**: 掌握函数式编程技巧

**难度**: ⭐⭐⭐

**代码**:

```rust
fn main() {
    println!("===== 链式转换 =====\n");

    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let result: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // 过滤偶数
        .map(|&x| x * x)            // 平方
        .sum();                     // 求和

    println!("偶数平方和: {}", result);

    println!("\n===== fold 累积 =====\n");

    // fold: 从初始值开始累积
    let sum = numbers.iter().fold(0, |acc, &x| acc + x);
    println!("总和: {}", sum);

    // 实现 product
    let product = numbers.iter().take(5).fold(1, |acc, &x| acc * x);
    println!("前5个数的乘积: {}", product);

    // 实现 max
    let max = numbers.iter().fold(i32::MIN, |acc, &x| acc.max(x));
    println!("最大值: {}", max);

    println!("\n===== scan 有状态转换 =====\n");

    // scan: 类似 map 但保持状态
    let factorials: Vec<_> = (1..=5)
        .scan(1, |state, x| {
            *state *= x;
            Some(*state)
        })
        .collect();

    println!("阶乘序列: {:?}", factorials);

    println!("\n===== partition 分组 =====\n");

    let (evens, odds): (Vec<_>, Vec<_>) = numbers
        .iter()
        .partition(|&&x| x % 2 == 0);

    println!("偶数: {:?}", evens);
    println!("奇数: {:?}", odds);

    println!("\n===== flat_map 扁平化 =====\n");

    let words = vec!["hello world", "rust programming"];

    let all_words: Vec<_> = words
        .iter()
        .flat_map(|s| s.split_whitespace())
        .collect();

    println!("所有单词: {:?}", all_words);

    println!("\n===== zip 组合 =====\n");

    let names = vec!["Alice", "Bob", "Charlie"];
    let ages = vec![30, 25, 35];

    let people: Vec<_> = names.iter()
        .zip(ages.iter())
        .collect();

    println!("人员信息: {:?}", people);

    println!("\n===== 惰性求值 =====\n");

    let numbers = vec![1, 2, 3, 4, 5];

    // 创建迭代器链 (不会立即执行)
    let iter = numbers.iter()
        .map(|x| {
            println!("map: {}", x);
            x * 2
        })
        .filter(|x| {
            println!("filter: {}", x);
            x % 4 == 0
        });

    println!("迭代器已创建");

    // collect 触发求值
    let result: Vec<_> = iter.collect();
    println!("结果: {:?}", result);

    println!("\n===== 实际应用: 数据处理管道 =====\n");

    #[derive(Debug)]
    struct User {
        name: String,
        age: u32,
        active: bool,
    }

    let users = vec![
        User { name: "Alice".to_string(), age: 30, active: true },
        User { name: "Bob".to_string(), age: 25, active: false },
        User { name: "Charlie".to_string(), age: 35, active: true },
        User { name: "David".to_string(), age: 28, active: true },
    ];

    let active_names: Vec<_> = users
        .iter()
        .filter(|u| u.active)      // 只保留活跃用户
        .filter(|u| u.age > 28)    // 年龄大于28
        .map(|u| &u.name)           // 提取名字
        .collect();

    println!("活跃且年龄>28的用户: {:?}", active_names);
}
```

**说明**:

- **链式**: 组合多个迭代器方法
- **fold**: 累积计算
- **scan**: 有状态的 map
- **partition**: 按条件分组
- **惰性求值**: 只在消费时才执行

**输出**:

```text
===== 链式转换 =====

偶数平方和: 220

===== fold 累积 =====

总和: 55
前5个数的乘积: 120
最大值: 10

===== scan 有状态转换 =====

阶乘序列: [1, 2, 6, 24, 120]

===== partition 分组 =====

偶数: [2, 4, 6, 8, 10]
奇数: [1, 3, 5, 7, 9]

===== flat_map 扁平化 =====

所有单词: ["hello", "world", "rust", "programming"]

===== zip 组合 =====

人员信息: [("Alice", 30), ("Bob", 25), ("Charlie", 35)]

===== 惰性求值 =====

迭代器已创建
map: 1
filter: 2
map: 2
filter: 4
map: 3
filter: 6
map: 4
filter: 8
map: 5
filter: 10
结果: [4, 8]

===== 实际应用: 数据处理管道 =====

活跃且年龄>28的用户: ["Alice", "Charlie"]
```

---

## 📝 总结

### 学习路径建议

1. **第一阶段** (Tier 1): 掌握基础 (示例 1.1-1.6)
   - match 表达式和模式匹配
   - 循环结构
   - 函数定义
   - 迭代器基础

2. **第二阶段** (Tier 2): 实践应用 (示例 2.1-2.6)
   - 闭包和捕获
   - Result/Option 错误处理
   - 自定义错误类型
   - 高阶函数

3. **第三阶段** (Tier 3): 深入理解 (示例 3.1-3.4)
   - Fn Traits 详解
   - 自定义迭代器
   - 错误处理组合
   - 函数式编程模式

### 核心概念总结

| 概念 | 相关示例 | 重要性 | 难度 |
|------|---------|--------|------|
| match 表达式 | 1.1, 1.2 | ⭐⭐⭐⭐⭐ | ⭐ |
| 循环 | 1.3, 1.6 | ⭐⭐⭐⭐⭐ | ⭐ |
| 函数 | 1.4 | ⭐⭐⭐⭐⭐ | ⭐ |
| 迭代器 | 1.5, 3.2 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 闭包 | 2.1, 2.2, 3.1 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 错误处理 | 2.3, 2.4, 2.5, 3.3 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 高阶函数 | 2.6 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 函数式编程 | 3.4 | ⭐⭐⭐⭐ | ⭐⭐⭐ |

### 最佳实践

1. **控制流**:
   - 优先使用 match 进行穷尽性检查
   - 使用 if let/while let 简化单一模式匹配
   - for 循环优于 while 循环

2. **函数设计**:
   - 使用 Result 和 Option 处理错误
   - 返回 impl Trait 而非具体类型
   - 函数应该小而专注

3. **迭代器**:
   - 优先使用迭代器而非循环
   - 利用惰性求值提高性能
   - 链式调用保持代码简洁

4. **错误处理**:
   - 使用 ? 操作符传播错误
   - 为应用定义自定义错误类型
   - 提供错误上下文信息

### 下一步

- 📖 深入学习: [模式匹配指南](./04_模式匹配指南.md)
- 📖 深入学习: [错误处理指南](./05_错误处理指南.md)
- 🚀 实战项目: [C03 实战项目集](./07_实战项目集.md) (即将创建)
- 📚 参考文档: [tier_03_references](../tier_03_references/)

---

**文档版本**: v1.0
**创建日期**: 2025-10-25
**维护状态**: 活跃维护

**💡 掌握控制流和函数是 Rust 编程的基础，熟练使用迭代器和闭包能大大提升代码质量! 🦀**-
