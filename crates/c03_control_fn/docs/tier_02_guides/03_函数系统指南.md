# 2.3 函数系统指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统化学习Rust函数系统，掌握函数、闭包、高阶函数  
> **学习时间**: 2-3天  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [项目概览](../tier_01_foundations/01_项目概览.md)

## 📋 目录

- [2.3 函数系统指南](#23-函数系统指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. 函数基础](#1-函数基础)
    - [1.1 函数定义](#11-函数定义)
    - [1.2 参数传递](#12-参数传递)
    - [1.3 返回值](#13-返回值)
    - [1.4 函数签名](#14-函数签名)
  - [2. 闭包](#2-闭包)
    - [2.1 闭包语法](#21-闭包语法)
    - [2.2 环境捕获](#22-环境捕获)
    - [2.3 闭包trait](#23-闭包trait)
    - [2.4 move语义](#24-move语义)
  - [3. 函数指针](#3-函数指针)
    - [3.1 函数作为参数](#31-函数作为参数)
    - [3.2 fn类型](#32-fn类型)
    - [3.3 函数指针与闭包](#33-函数指针与闭包)
  - [4. 高阶函数](#4-高阶函数)
    - [4.1 接受函数参数](#41-接受函数参数)
    - [4.2 返回函数](#42-返回函数)
    - [4.3 函数组合](#43-函数组合)
  - [5. 方法](#5-方法)
    - [5.1 关联函数](#51-关联函数)
    - [5.2 self参数](#52-self参数)
    - [5.3 方法链](#53-方法链)
  - [6. 泛型函数](#6-泛型函数)
    - [6.1 类型参数](#61-类型参数)
    - [6.2 trait约束](#62-trait约束)
    - [6.3 where子句](#63-where子句)
  - [7. 异步函数](#7-异步函数)
    - [7.1 async/await](#71-asyncawait)
    - [7.2 Future trait](#72-future-trait)
    - [7.3 异步闭包 (Rust 1.90+)](#73-异步闭包-rust-190)
  - [8. 实战案例](#8-实战案例)
    - [案例1: 策略模式](#案例1-策略模式)
    - [案例2: 函数式数据处理](#案例2-函数式数据处理)
    - [案例3: 回调系统](#案例3-回调系统)
    - [案例4: 装饰器模式](#案例4-装饰器模式)
    - [案例5: 惰性求值](#案例5-惰性求值)
  - [9. 常见陷阱](#9-常见陷阱)
  - [10. 最佳实践](#10-最佳实践)
  - [11. 性能优化](#11-性能优化)
  - [12. 小结](#12-小结)
  - [13. 延伸阅读](#13-延伸阅读)
  - [14. 练习题](#14-练习题)

---

## 🎯 学习目标

完成本指南学习后，您将能够：

- ✅ 掌握函数定义、参数、返回值
- ✅ 理解闭包的捕获机制和trait
- ✅ 熟练使用函数指针和高阶函数
- ✅ 应用方法和关联函数
- ✅ 编写泛型函数和异步函数
- ✅ 避免常见陷阱，编写高效代码

---

## 1. 函数基础

### 1.1 函数定义

Rust 函数使用 `fn` 关键字定义：

```rust
// 基本函数
fn greet() {
    println!("Hello!");
}

// 带参数的函数
fn greet_name(name: &str) {
    println!("Hello, {}!", name);
}

// 带返回值的函数
fn add(a: i32, b: i32) -> i32 {
    a + b  // 表达式作为返回值，不加分号
}

// 显式return
fn subtract(a: i32, b: i32) -> i32 {
    return a - b;  // 使用return关键字
}

// 多个参数
fn describe_point(x: f64, y: f64, z: f64) {
    println!("Point: ({}, {}, {})", x, y, z);
}

fn main() {
    greet();
    greet_name("Alice");
    
    let sum = add(5, 3);
    println!("5 + 3 = {}", sum);
    
    let diff = subtract(10, 4);
    println!("10 - 4 = {}", diff);
    
    describe_point(1.0, 2.0, 3.0);
}
```

**关键要点**:

- 函数名使用 snake_case
- 参数必须指定类型
- 返回值类型使用 `->` 指定
- 最后一个表达式是返回值（无分号）

### 1.2 参数传递

Rust 使用值传递，但可通过引用传递：

```rust
// 值传递（所有权转移）
fn take_ownership(s: String) {
    println!("拥有: {}", s);
    // s 在这里被drop
}

// 不可变引用
fn borrow(s: &String) {
    println!("借用: {}", s);
    // 不能修改s
}

// 可变引用
fn borrow_mut(s: &mut String) {
    s.push_str(" world");
    println!("可变借用: {}", s);
}

// 基本类型（Copy）
fn use_number(n: i32) {
    println!("数字: {}", n);
    // i32 是 Copy，原值不受影响
}

// 多个参数
fn process(data: &[i32], factor: i32) -> Vec<i32> {
    data.iter().map(|&x| x * factor).collect()
}

fn main() {
    // 所有权转移
    let s1 = String::from("hello");
    take_ownership(s1);
    // println!("{}", s1);  // 错误：s1已被移动
    
    // 借用
    let s2 = String::from("hello");
    borrow(&s2);
    println!("s2仍可用: {}", s2);
    
    // 可变借用
    let mut s3 = String::from("hello");
    borrow_mut(&mut s3);
    println!("修改后: {}", s3);
    
    // Copy类型
    let num = 42;
    use_number(num);
    println!("num仍可用: {}", num);
    
    // 多个参数
    let data = vec![1, 2, 3, 4];
    let result = process(&data, 2);
    println!("{:?}", result);
}
```

### 1.3 返回值

函数可以返回值或 unit 类型：

```rust
// 返回具体值
fn get_value() -> i32 {
    42
}

// 返回元组
fn get_coordinates() -> (f64, f64) {
    (3.14, 2.71)
}

// 返回 Option
fn divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}

// 返回 Result
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse()
}

// 返回引用（需要生命周期）
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 无返回值（unit类型 ()）
fn print_message(msg: &str) {
    println!("{}", msg);
    // 隐式返回 ()
}

// 提前返回
fn check_positive(n: i32) -> Result<i32, String> {
    if n < 0 {
        return Err("负数".to_string());
    }
    
    if n == 0 {
        return Err("零".to_string());
    }
    
    Ok(n)
}

fn main() {
    println!("值: {}", get_value());
    
    let (x, y) = get_coordinates();
    println!("坐标: ({}, {})", x, y);
    
    match divide(10.0, 2.0) {
        Some(result) => println!("10 / 2 = {}", result),
        None => println!("除零错误"),
    }
    
    match parse_number("42") {
        Ok(n) => println!("解析成功: {}", n),
        Err(e) => println!("解析失败: {}", e),
    }
    
    let s1 = "hello";
    let s2 = "world!";
    println!("更长的是: {}", longest(s1, s2));
    
    print_message("Hello");
    
    match check_positive(5) {
        Ok(n) => println!("正数: {}", n),
        Err(e) => println!("错误: {}", e),
    }
}
```

### 1.4 函数签名

函数签名描述函数的类型：

```rust
// 函数签名: fn(i32, i32) -> i32
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// 函数签名: fn(&str) -> String
fn to_uppercase(s: &str) -> String {
    s.to_uppercase()
}

// 函数签名: fn(Vec<i32>) -> Vec<i32>
fn double_vec(v: Vec<i32>) -> Vec<i32> {
    v.into_iter().map(|x| x * 2).collect()
}

// 泛型函数签名: fn<T>(T, T) -> T
fn first<T>(a: T, b: T) -> T {
    a
}

// 带约束的泛型签名: fn<T: Display>(T) -> ()
use std::fmt::Display;
fn print_it<T: Display>(value: T) {
    println!("{}", value);
}

fn main() {
    // 使用函数签名进行类型推断
    let f: fn(i32, i32) -> i32 = add;
    println!("3 + 4 = {}", f(3, 4));
    
    let g: fn(&str) -> String = to_uppercase;
    println!("{}", g("hello"));
}
```

---

## 2. 闭包

### 2.1 闭包语法

闭包是匿名函数，可以捕获环境：

```rust
fn main() {
    // 基本闭包
    let add = |a, b| a + b;
    println!("5 + 3 = {}", add(5, 3));
    
    // 指定类型
    let multiply: fn(i32, i32) -> i32 = |a, b| a * b;
    println!("4 * 3 = {}", multiply(4, 3));
    
    // 带类型标注的闭包
    let divide = |a: f64, b: f64| -> f64 {
        a / b
    };
    println!("10 / 2 = {}", divide(10.0, 2.0));
    
    // 多行闭包
    let complex = |x: i32| {
        let squared = x * x;
        let doubled = squared * 2;
        doubled + x
    };
    println!("复杂计算: {}", complex(5));
    
    // 无参数闭包
    let greet = || {
        println!("Hello!");
    };
    greet();
    
    // 类型推断
    let numbers = vec![1, 2, 3, 4, 5];
    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();
    println!("{:?}", doubled);
}
```

### 2.2 环境捕获

闭包可以捕获外部变量：

```rust
fn main() {
    let x = 10;
    
    // 不可变借用捕获
    let print_x = || {
        println!("x = {}", x);
    };
    print_x();
    println!("x仍可用: {}", x);
    
    // 可变借用捕获
    let mut count = 0;
    let mut increment = || {
        count += 1;
        println!("count = {}", count);
    };
    increment();
    increment();
    // println!("{}", count);  // 错误：可变借用期间不能使用
    
    // 所有权转移捕获（move）
    let s = String::from("hello");
    let take_s = move || {
        println!("拥有字符串: {}", s);
    };
    take_s();
    // println!("{}", s);  // 错误：s已被移动
    
    // 捕获多个变量
    let a = 5;
    let b = 10;
    let sum = || a + b;
    println!("sum = {}", sum());
    
    // 捕获可变引用
    let mut vec = vec![1, 2, 3];
    {
        let mut push_4 = || {
            vec.push(4);
        };
        push_4();
    }  // 可变借用结束
    println!("{:?}", vec);
}
```

### 2.3 闭包trait

闭包实现三个trait之一：

```rust
fn main() {
    // FnOnce: 消费捕获的值，只能调用一次
    let s = String::from("hello");
    let consume = || {
        let _s = s;  // 获取所有权
    };
    consume();
    // consume();  // 错误：只能调用一次
    
    // FnMut: 可变借用，可多次调用
    let mut count = 0;
    let mut increment = || {
        count += 1;
    };
    increment();
    increment();
    println!("count = {}", count);
    
    // Fn: 不可变借用，可多次调用
    let x = 10;
    let print = || {
        println!("x = {}", x);
    };
    print();
    print();
    
    // 作为参数传递
    fn call_once<F>(f: F) where F: FnOnce() {
        f();
    }
    
    fn call_mut<F>(mut f: F) where F: FnMut() {
        f();
        f();
    }
    
    fn call_fn<F>(f: F) where F: Fn() {
        f();
        f();
    }
    
    call_fn(|| println!("Fn closure"));
    
    let mut n = 0;
    call_mut(|| n += 1);
    println!("n = {}", n);
}
```

**trait层次**:

- `Fn` 继承自 `FnMut`
- `FnMut` 继承自 `FnOnce`
- 所有闭包都实现 `FnOnce`
- 只有不修改捕获变量的闭包实现 `Fn`

### 2.4 move语义

使用 `move` 强制闭包获取所有权：

```rust
use std::thread;

fn main() {
    // 基本 move
    let x = 10;
    let closure = move || {
        println!("x = {}", x);
    };
    closure();
    // x 是 Copy 类型，仍然可用
    println!("x = {}", x);
    
    // move 非Copy类型
    let s = String::from("hello");
    let closure = move || {
        println!("s = {}", s);
    };
    closure();
    // println!("{}", s);  // 错误：s已被移动
    
    // 在线程中使用 move
    let data = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("data = {:?}", data);
    });
    handle.join().unwrap();
    // println!("{:?}", data);  // 错误：data已被移动
    
    // move 与 Clone
    let s = String::from("world");
    let s_clone = s.clone();
    let closure = move || {
        println!("拥有克隆: {}", s_clone);
    };
    closure();
    println!("原始字符串: {}", s);
}
```

---

## 3. 函数指针

### 3.1 函数作为参数

函数可以作为参数传递：

```rust
// 接受函数作为参数
fn apply_operation(x: i32, y: i32, op: fn(i32, i32) -> i32) -> i32 {
    op(x, y)
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn main() {
    let result1 = apply_operation(5, 3, add);
    println!("5 + 3 = {}", result1);
    
    let result2 = apply_operation(5, 3, multiply);
    println!("5 * 3 = {}", result2);
    
    // 使用闭包（无捕获）
    let result3 = apply_operation(5, 3, |a, b| a - b);
    println!("5 - 3 = {}", result3);
}
```

### 3.2 fn类型

`fn` 是函数指针类型：

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    // 函数指针
    let f: fn(i32, i32) -> i32 = add;
    println!("结果: {}", f(3, 4));
    
    // 函数指针数组
    let operations: [fn(i32, i32) -> i32; 3] = [
        |a, b| a + b,
        |a, b| a - b,
        |a, b| a * b,
    ];
    
    for (i, op) in operations.iter().enumerate() {
        println!("操作{}: 5 op 3 = {}", i, op(5, 3));
    }
    
    // 返回函数指针
    fn get_operation(op_type: &str) -> fn(i32, i32) -> i32 {
        match op_type {
            "add" => |a, b| a + b,
            "sub" => |a, b| a - b,
            "mul" => |a, b| a * b,
            _ => |_, _| 0,
        }
    }
    
    let op = get_operation("mul");
    println!("动态操作: {}", op(4, 5));
}
```

### 3.3 函数指针与闭包

理解 `fn` 与 `Fn` trait 的区别：

```rust
fn main() {
    // fn 类型：普通函数指针
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    let f: fn(i32, i32) -> i32 = add;
    println!("fn: {}", f(3, 4));
    
    // Fn trait：可以是闭包
    let x = 10;
    let add_x = |a: i32| a + x;  // 捕获环境
    
    // 接受 Fn trait
    fn call_with_one<F>(f: F) -> i32
    where
        F: Fn(i32) -> i32,
    {
        f(1)
    }
    
    println!("Fn trait: {}", call_with_one(add_x));
    
    // fn 可以转换为 Fn
    fn double(x: i32) -> i32 {
        x * 2
    }
    
    println!("fn as Fn: {}", call_with_one(double));
    
    // Fn 不一定能转换为 fn
    // let f: fn(i32) -> i32 = add_x;  // 错误：捕获了环境
}
```

---

## 4. 高阶函数

### 4.1 接受函数参数

高阶函数接受函数作为参数：

```rust
// 基本高阶函数
fn apply<F>(value: i32, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    f(value)
}

// 接受多个函数
fn compose<F, G>(x: i32, f: F, g: G) -> i32
where
    F: Fn(i32) -> i32,
    G: Fn(i32) -> i32,
{
    g(f(x))
}

// 条件执行
fn conditional_apply<F>(value: i32, condition: bool, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    if condition {
        f(value)
    } else {
        value
    }
}

// 重复应用
fn repeat<F>(value: i32, n: usize, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    let mut result = value;
    for _ in 0..n {
        result = f(result);
    }
    result
}

fn main() {
    let result = apply(5, |x| x * 2);
    println!("应用函数: {}", result);
    
    let result = compose(5, |x| x * 2, |x| x + 3);
    println!("组合函数: {}", result);
    
    let result = conditional_apply(10, true, |x| x * 2);
    println!("条件应用: {}", result);
    
    let result = repeat(2, 3, |x| x * 2);
    println!("重复应用: {}", result);
}
```

### 4.2 返回函数

返回闭包需要使用 Box：

```rust
// 返回函数指针
fn get_adder(x: i32) -> fn(i32) -> i32 {
    fn add_impl(y: i32) -> i32 {
        y + 10  // 不能捕获x，因为fn不捕获环境
    }
    add_impl
}

// 返回 Box<dyn Fn>
fn get_closure_adder(x: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |y| y + x)
}

// 返回 impl Fn
fn get_impl_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| y + x
}

// 工厂函数
fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
    move |x| x * factor
}

fn main() {
    // 使用函数指针
    let f = get_adder(5);
    println!("fn: {}", f(10));
    
    // 使用 Box<dyn Fn>
    let g = get_closure_adder(5);
    println!("Box<dyn Fn>: {}", g(10));
    
    // 使用 impl Fn
    let h = get_impl_adder(5);
    println!("impl Fn: {}", h(10));
    
    // 工厂函数
    let times_two = create_multiplier(2);
    let times_three = create_multiplier(3);
    
    println!("2 * 5 = {}", times_two(5));
    println!("3 * 5 = {}", times_three(5));
}
```

### 4.3 函数组合

实现函数组合器：

```rust
// 函数组合
fn compose<F, G, A, B, C>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

// 柯里化
fn curry<F, A, B, C>(f: F) -> impl Fn(A) -> Box<dyn Fn(B) -> C>
where
    F: Fn(A, B) -> C + 'static,
    A: 'static,
    B: 'static,
    C: 'static,
{
    move |a| Box::new(move |b| f(a, b))
}

// 偏函数应用
fn partial<F, A, B, C>(f: F, a: A) -> impl Fn(B) -> C
where
    F: Fn(A, B) -> C,
    A: Clone,
{
    move |b| f(a.clone(), b)
}

fn main() {
    // 函数组合
    let add_one = |x: i32| x + 1;
    let double = |x: i32| x * 2;
    
    let add_one_then_double = compose(add_one, double);
    println!("(5 + 1) * 2 = {}", add_one_then_double(5));
    
    // 柯里化
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    let curried_add = curry(add);
    let add_5 = curried_add(5);
    println!("柯里化: 5 + 3 = {}", add_5(3));
    
    // 偏函数应用
    fn multiply(a: i32, b: i32) -> i32 {
        a * b
    }
    
    let double_partial = partial(multiply, 2);
    println!("偏应用: 2 * 7 = {}", double_partial(7));
}
```

---

## 5. 方法

### 5.1 关联函数

关联函数定义在 impl 块中：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数（构造器）
    fn new(width: u32, height: u32) -> Self {
        Rectangle { width, height }
    }
    
    // 带默认值的构造器
    fn square(size: u32) -> Self {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    // 其他关联函数
    fn default() -> Self {
        Rectangle {
            width: 10,
            height: 10,
        }
    }
}

fn main() {
    let rect1 = Rectangle::new(30, 50);
    let rect2 = Rectangle::square(25);
    let rect3 = Rectangle::default();
    
    println!("rect1: {}x{}", rect1.width, rect1.height);
    println!("rect2: {}x{}", rect2.width, rect2.height);
    println!("rect3: {}x{}", rect3.width, rect3.height);
}
```

### 5.2 self参数

方法可以借用 self 或获取所有权：

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Self {
        Counter { count: 0 }
    }
    
    // 不可变借用 &self
    fn get(&self) -> u32 {
        self.count
    }
    
    // 可变借用 &mut self
    fn increment(&mut self) {
        self.count += 1;
    }
    
    fn add(&mut self, n: u32) {
        self.count += n;
    }
    
    // 获取所有权 self
    fn consume(self) -> u32 {
        println!("消费Counter");
        self.count
    }
}

fn main() {
    let mut counter = Counter::new();
    
    println!("初始: {}", counter.get());
    
    counter.increment();
    println!("递增后: {}", counter.get());
    
    counter.add(5);
    println!("加5后: {}", counter.get());
    
    let final_count = counter.consume();
    println!("最终: {}", final_count);
    
    // counter 已被消费，不能再使用
    // println!("{}", counter.get());  // 错误
}
```

### 5.3 方法链

实现流畅的方法链：

```rust
struct Builder {
    value: String,
}

impl Builder {
    fn new() -> Self {
        Builder {
            value: String::new(),
        }
    }
    
    // 返回 &mut self 支持链式调用
    fn add(&mut self, s: &str) -> &mut Self {
        self.value.push_str(s);
        self
    }
    
    fn add_line(&mut self, s: &str) -> &mut Self {
        self.value.push_str(s);
        self.value.push('\n');
        self
    }
    
    fn repeat(&mut self, s: &str, times: usize) -> &mut Self {
        for _ in 0..times {
            self.value.push_str(s);
        }
        self
    }
    
    fn build(self) -> String {
        self.value
    }
}

fn main() {
    let result = Builder::new()
        .add("Hello")
        .add(" ")
        .add("World")
        .add_line("!")
        .repeat("*", 5)
        .build();
    
    println!("{}", result);
}
```

---

## 6. 泛型函数

### 6.1 类型参数

使用泛型参数编写通用函数：

```rust
// 基本泛型函数
fn identity<T>(value: T) -> T {
    value
}

// 多个类型参数
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// 泛型与引用
fn first<T>(slice: &[T]) -> Option<&T> {
    slice.first()
}

// 泛型与生命周期
fn longest<'a, T>(x: &'a [T], y: &'a [T]) -> &'a [T] {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let num = identity(42);
    let text = identity("hello");
    println!("num: {}, text: {}", num, text);
    
    let p = pair(1, "one");
    println!("{:?}", p);
    
    let numbers = vec![1, 2, 3];
    if let Some(first) = first(&numbers) {
        println!("第一个: {}", first);
    }
    
    let a = vec![1, 2, 3];
    let b = vec![4, 5];
    let longer = longest(&a, &b);
    println!("更长: {:?}", longer);
}
```

### 6.2 trait约束

使用 trait bounds 限制泛型：

```rust
use std::fmt::Display;

// 单个约束
fn print_it<T: Display>(value: T) {
    println!("{}", value);
}

// 多个约束
fn compare_and_print<T: Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} > {}", a, b);
    } else {
        println!("{} <= {}", a, b);
    }
}

// Clone 约束
fn duplicate<T: Clone>(value: T) -> (T, T) {
    (value.clone(), value)
}

// Debug 约束
use std::fmt::Debug;

fn debug_print<T: Debug>(value: T) {
    println!("{:?}", value);
}

fn main() {
    print_it(42);
    print_it("hello");
    
    compare_and_print(10, 20);
    compare_and_print("apple", "banana");
    
    let (a, b) = duplicate(vec![1, 2, 3]);
    println!("{:?}, {:?}", a, b);
    
    debug_print(vec![1, 2, 3]);
}
```

### 6.3 where子句

使用 where 子句简化复杂约束：

```rust
use std::fmt::{Debug, Display};

// 复杂约束
fn complex_function<T, U>(t: T, u: U) -> String
where
    T: Display + Clone,
    U: Debug + Clone,
{
    format!("t = {}, u = {:?}", t, u.clone())
}

// 返回值约束
fn make_pair<T, U>(t: T, u: U) -> impl Display
where
    T: Display,
    U: Display,
{
    format!("({}, {})", t, u)
}

// 关联类型约束
fn process_iterator<I>(iter: I) -> Vec<I::Item>
where
    I: Iterator,
    I::Item: Clone,
{
    iter.cloned().collect()
}

fn main() {
    let result = complex_function("hello", vec![1, 2, 3]);
    println!("{}", result);
    
    let pair = make_pair(42, "world");
    println!("{}", pair);
}
```

---

## 7. 异步函数

### 7.1 async/await

使用 async/await 编写异步代码：

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// 基本异步函数
async fn hello_async() {
    println!("Hello from async!");
}

// 带返回值的异步函数
async fn get_number() -> i32 {
    42
}

// 异步函数调用其他异步函数
async fn compute() -> i32 {
    let a = get_number().await;
    let b = get_number().await;
    a + b
}

// 错误处理
async fn fetch_data() -> Result<String, String> {
    Ok("data".to_string())
}

async fn process_data() -> Result<(), String> {
    let data = fetch_data().await?;
    println!("数据: {}", data);
    Ok(())
}

fn main() {
    // 需要运行时执行异步代码
    // 这里只是示例，实际需要 tokio 或 async-std
    println!("异步函数示例");
}
```

### 7.2 Future trait

理解 Future trait：

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// 自定义 Future
struct DelayedValue {
    value: i32,
    ready: bool,
}

impl Future for DelayedValue {
    type Output = i32;
    
    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        if self.ready {
            Poll::Ready(self.value)
        } else {
            self.ready = true;
            Poll::Pending
        }
    }
}

fn main() {
    println!("Future trait 示例");
}
```

### 7.3 异步闭包 (Rust 1.90+)

Rust 1.90+ 支持异步闭包：

```rust
// 异步闭包（概念示例）
async fn example() {
    // 异步闭包
    let async_closure = async || {
        println!("异步闭包");
        42
    };
    
    let result = async_closure().await;
    println!("结果: {}", result);
}

fn main() {
    println!("异步闭包需要运行时支持");
}
```

---

## 8. 实战案例

### 案例1: 策略模式

```rust
// 策略trait
trait SortStrategy {
    fn sort(&self, data: &mut [i32]);
}

// 冒泡排序策略
struct BubbleSort;

impl SortStrategy for BubbleSort {
    fn sort(&self, data: &mut [i32]) {
        let len = data.len();
        for i in 0..len {
            for j in 0..len - i - 1 {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
}

// 快速排序策略
struct QuickSort;

impl SortStrategy for QuickSort {
    fn sort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        let pivot = data[0];
        let mut left = vec![];
        let mut right = vec![];
        
        for &item in &data[1..] {
            if item <= pivot {
                left.push(item);
            } else {
                right.push(item);
            }
        }
        
        self.sort(&mut left);
        self.sort(&mut right);
        
        let mut i = 0;
        for item in left.iter().chain(std::iter::once(&pivot)).chain(right.iter()) {
            data[i] = *item;
            i += 1;
        }
    }
}

// 排序器
struct Sorter {
    strategy: Box<dyn SortStrategy>,
}

impl Sorter {
    fn new(strategy: Box<dyn SortStrategy>) -> Self {
        Sorter { strategy }
    }
    
    fn sort(&self, data: &mut [i32]) {
        self.strategy.sort(data);
    }
}

fn main() {
    let mut data1 = vec![5, 2, 8, 1, 9];
    let sorter = Sorter::new(Box::new(BubbleSort));
    sorter.sort(&mut data1);
    println!("冒泡排序: {:?}", data1);
    
    let mut data2 = vec![5, 2, 8, 1, 9];
    let sorter = Sorter::new(Box::new(QuickSort));
    sorter.sort(&mut data2);
    println!("快速排序: {:?}", data2);
}
```

### 案例2: 函数式数据处理

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // 链式处理
    let result: Vec<i32> = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // 筛选偶数
        .map(|&x| x * x)           // 平方
        .filter(|&x| x > 10)       // 大于10
        .collect();
    
    println!("处理结果: {:?}", result);
    
    // fold累积
    let sum: i32 = numbers.iter().fold(0, |acc, &x| acc + x);
    println!("总和: {}", sum);
    
    // scan状态转换
    let running_sum: Vec<i32> = numbers
        .iter()
        .scan(0, |state, &x| {
            *state += x;
            Some(*state)
        })
        .collect();
    
    println!("累计和: {:?}", running_sum);
    
    // partition分组
    let (even, odd): (Vec<_>, Vec<_>) = numbers
        .iter()
        .partition(|&&x| x % 2 == 0);
    
    println!("偶数: {:?}", even);
    println!("奇数: {:?}", odd);
}
```

### 案例3: 回调系统

```rust
type Callback = Box<dyn Fn(i32)>;

struct EventEmitter {
    listeners: Vec<Callback>,
}

impl EventEmitter {
    fn new() -> Self {
        EventEmitter {
            listeners: Vec::new(),
        }
    }
    
    fn on(&mut self, callback: Callback) {
        self.listeners.push(callback);
    }
    
    fn emit(&self, value: i32) {
        for listener in &self.listeners {
            listener(value);
        }
    }
}

fn main() {
    let mut emitter = EventEmitter::new();
    
    emitter.on(Box::new(|x| {
        println!("监听器1: {}", x);
    }));
    
    emitter.on(Box::new(|x| {
        println!("监听器2: {}", x * 2);
    }));
    
    emitter.on(Box::new(|x| {
        if x > 5 {
            println!("监听器3: {} 大于5", x);
        }
    }));
    
    emitter.emit(3);
    emitter.emit(7);
}
```

### 案例4: 装饰器模式

```rust
// 基础函数类型
type Operation = Box<dyn Fn(i32) -> i32>;

// 日志装饰器
fn with_logging(op: Operation) -> Operation {
    Box::new(move |x| {
        println!("调用函数，输入: {}", x);
        let result = op(x);
        println!("返回结果: {}", result);
        result
    })
}

// 计时装饰器
fn with_timing(op: Operation) -> Operation {
    Box::new(move |x| {
        use std::time::Instant;
        let start = Instant::now();
        let result = op(x);
        let elapsed = start.elapsed();
        println!("执行时间: {:?}", elapsed);
        result
    })
}

// 缓存装饰器
fn with_cache(mut op: Operation) -> Operation {
    use std::collections::HashMap;
    let mut cache = HashMap::new();
    
    Box::new(move |x| {
        if let Some(&cached) = cache.get(&x) {
            println!("缓存命中: {} -> {}", x, cached);
            cached
        } else {
            let result = op(x);
            cache.insert(x, result);
            result
        }
    })
}

fn main() {
    // 基础函数
    let square: Operation = Box::new(|x| x * x);
    
    // 添加装饰器
    let decorated = with_cache(with_timing(with_logging(square)));
    
    println!("第一次调用:");
    decorated(5);
    
    println!("\n第二次调用（应该命中缓存）:");
    decorated(5);
    
    println!("\n第三次调用（新值）:");
    decorated(7);
}
```

### 案例5: 惰性求值

```rust
struct LazyValue<F>
where
    F: FnOnce() -> i32,
{
    init: Option<F>,
    value: Option<i32>,
}

impl<F> LazyValue<F>
where
    F: FnOnce() -> i32,
{
    fn new(init: F) -> Self {
        LazyValue {
            init: Some(init),
            value: None,
        }
    }
    
    fn get(&mut self) -> i32 {
        if let Some(value) = self.value {
            println!("返回缓存值");
            value
        } else {
            println!("计算初始值");
            let init = self.init.take().unwrap();
            let value = init();
            self.value = Some(value);
            value
        }
    }
}

fn main() {
    let mut lazy = LazyValue::new(|| {
        println!("执行昂贵计算...");
        std::thread::sleep(std::time::Duration::from_millis(100));
        42
    });
    
    println!("LazyValue已创建");
    println!("第一次访问: {}", lazy.get());
    println!("第二次访问: {}", lazy.get());
    println!("第三次访问: {}", lazy.get());
}
```

---

## 9. 常见陷阱

```rust
fn main() {
    // ❌ 错误：闭包捕获可变借用后不能再使用原变量
    let mut vec = vec![1, 2, 3];
    /*
    let mut closure = || vec.push(4);
    println!("{:?}", vec);  // 错误
    closure();
    */
    
    // ✅ 正确：先完成借用再使用
    let mut vec = vec![1, 2, 3];
    {
        let mut closure = || vec.push(4);
        closure();
    }
    println!("{:?}", vec);
    
    // ❌ 错误：返回闭包需要 Box 或 impl Trait
    /*
    fn bad_return() -> dyn Fn(i32) -> i32 {
        |x| x + 1
    }
    */
    
    // ✅ 正确：使用 impl Trait
    fn good_return() -> impl Fn(i32) -> i32 {
        |x| x + 1
    }
    
    let f = good_return();
    println!("{}", f(10));
}
```

---

## 10. 最佳实践

1. **优先使用闭包而非函数指针**
2. **使用 impl Trait 简化返回类型**
3. **合理使用 move 关键字**
4. **避免过度嵌套闭包**
5. **使用迭代器方法替代显式循环**
6. **为复杂闭包添加类型注解**
7. **使用 trait bounds 而非具体类型**
8. **考虑闭包的生命周期和所有权**

---

## 11. 性能优化

1. **内联**: 小函数和闭包会被内联
2. **避免不必要的 Box**: 使用 impl Trait
3. **零成本抽象**: 闭包无运行时开销
4. **避免动态分发**: 优先泛型而非 trait对象
5. **使用迭代器**: 编译器可优化迭代器链

---

## 12. 小结

- 函数是Rust的基本抽象单元
- 闭包提供灵活的函数式编程
- 高阶函数支持强大的抽象
- 方法提供面向对象风格
- 泛型函数实现代码复用
- 异步函数支持并发编程

---

## 13. 延伸阅读

**内部文档**:

- [闭包深入](../tier_04_advanced/02_闭包深入.md)
- [函数式编程](../tier_04_advanced/03_函数式编程.md)
- [异步编程指南](../../c06_async/docs/README.md)

**外部资源**:

- [Rust Book - Functions](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)
- [Rust Book - Closures](https://doc.rust-lang.org/book/ch13-01-closures.html)
- [Rust by Example - Functions](https://doc.rust-lang.org/rust-by-example/fn.html)

---

## 14. 练习题

1. 实现一个通用的缓存函数装饰器
2. 编写一个支持链式调用的构建器模式
3. 实现函数组合和管道操作符
4. 创建一个事件系统，支持多个监听器
5. 实现惰性求值的斐波那契数列生成器

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🎯 掌握Rust函数系统，编写优雅的函数式代码！** 🦀✨
