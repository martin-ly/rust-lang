# 2.3 å‡½æ•°ç³»ç»ŸæŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚  
> **æ–‡æ¡£å®šä½**: ç³»ç»ŸåŒ–å­¦ä¹ Rustå‡½æ•°ç³»ç»Ÿï¼ŒæŒæ¡å‡½æ•°ã€é—­åŒ…ã€é«˜é˜¶å‡½æ•°  
> **å­¦ä¹ æ—¶é—´**: 2-3å¤©  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [2.3 å‡½æ•°ç³»ç»ŸæŒ‡å—](#23-å‡½æ•°ç³»ç»ŸæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. å‡½æ•°åŸºç¡€](#1-å‡½æ•°åŸºç¡€)
    - [1.1 å‡½æ•°å®šä¹‰](#11-å‡½æ•°å®šä¹‰)
    - [1.2 å‚æ•°ä¼ é€’](#12-å‚æ•°ä¼ é€’)
    - [1.3 è¿”å›å€¼](#13-è¿”å›å€¼)
    - [1.4 å‡½æ•°ç­¾å](#14-å‡½æ•°ç­¾å)
  - [2. é—­åŒ…](#2-é—­åŒ…)
    - [2.1 é—­åŒ…è¯­æ³•](#21-é—­åŒ…è¯­æ³•)
    - [2.2 ç¯å¢ƒæ•è·](#22-ç¯å¢ƒæ•è·)
    - [2.3 é—­åŒ…trait](#23-é—­åŒ…trait)
    - [2.4 moveè¯­ä¹‰](#24-moveè¯­ä¹‰)
  - [3. å‡½æ•°æŒ‡é’ˆ](#3-å‡½æ•°æŒ‡é’ˆ)
    - [3.1 å‡½æ•°ä½œä¸ºå‚æ•°](#31-å‡½æ•°ä½œä¸ºå‚æ•°)
    - [3.2 fnç±»å‹](#32-fnç±»å‹)
    - [3.3 å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…](#33-å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…)
  - [4. é«˜é˜¶å‡½æ•°](#4-é«˜é˜¶å‡½æ•°)
    - [4.1 æ¥å—å‡½æ•°å‚æ•°](#41-æ¥å—å‡½æ•°å‚æ•°)
    - [4.2 è¿”å›å‡½æ•°](#42-è¿”å›å‡½æ•°)
    - [4.3 å‡½æ•°ç»„åˆ](#43-å‡½æ•°ç»„åˆ)
  - [5. æ–¹æ³•](#5-æ–¹æ³•)
    - [5.1 å…³è”å‡½æ•°](#51-å…³è”å‡½æ•°)
    - [5.2 selfå‚æ•°](#52-selfå‚æ•°)
    - [5.3 æ–¹æ³•é“¾](#53-æ–¹æ³•é“¾)
  - [6. æ³›å‹å‡½æ•°](#6-æ³›å‹å‡½æ•°)
    - [6.1 ç±»å‹å‚æ•°](#61-ç±»å‹å‚æ•°)
    - [6.2 traitçº¦æŸ](#62-traitçº¦æŸ)
    - [6.3 whereå­å¥](#63-whereå­å¥)
  - [7. å¼‚æ­¥å‡½æ•°](#7-å¼‚æ­¥å‡½æ•°)
    - [7.1 async/await](#71-asyncawait)
    - [7.2 Future trait](#72-future-trait)
    - [7.3 å¼‚æ­¥é—­åŒ… (Rust 1.90+)](#73-å¼‚æ­¥é—­åŒ…-rust-190)
  - [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: ç­–ç•¥æ¨¡å¼](#æ¡ˆä¾‹1-ç­–ç•¥æ¨¡å¼)
    - [æ¡ˆä¾‹2: å‡½æ•°å¼æ•°æ®å¤„ç†](#æ¡ˆä¾‹2-å‡½æ•°å¼æ•°æ®å¤„ç†)
    - [æ¡ˆä¾‹3: å›è°ƒç³»ç»Ÿ](#æ¡ˆä¾‹3-å›è°ƒç³»ç»Ÿ)
    - [æ¡ˆä¾‹4: è£…é¥°å™¨æ¨¡å¼](#æ¡ˆä¾‹4-è£…é¥°å™¨æ¨¡å¼)
    - [æ¡ˆä¾‹5: æƒ°æ€§æ±‚å€¼](#æ¡ˆä¾‹5-æƒ°æ€§æ±‚å€¼)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
  - [11. æ€§èƒ½ä¼˜åŒ–](#11-æ€§èƒ½ä¼˜åŒ–)
  - [12. å°ç»“](#12-å°ç»“)
  - [13. å»¶ä¼¸é˜…è¯»](#13-å»¶ä¼¸é˜…è¯»)
  - [14. ç»ƒä¹ é¢˜](#14-ç»ƒä¹ é¢˜)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… æŒæ¡å‡½æ•°å®šä¹‰ã€å‚æ•°ã€è¿”å›å€¼
- âœ… ç†è§£é—­åŒ…çš„æ•è·æœºåˆ¶å’Œtrait
- âœ… ç†Ÿç»ƒä½¿ç”¨å‡½æ•°æŒ‡é’ˆå’Œé«˜é˜¶å‡½æ•°
- âœ… åº”ç”¨æ–¹æ³•å’Œå…³è”å‡½æ•°
- âœ… ç¼–å†™æ³›å‹å‡½æ•°å’Œå¼‚æ­¥å‡½æ•°
- âœ… é¿å…å¸¸è§é™·é˜±ï¼Œç¼–å†™é«˜æ•ˆä»£ç 

---

## 1. å‡½æ•°åŸºç¡€

### 1.1 å‡½æ•°å®šä¹‰

Rust å‡½æ•°ä½¿ç”¨ `fn` å…³é”®å­—å®šä¹‰ï¼š

```rust
// åŸºæœ¬å‡½æ•°
fn greet() {
    println!("Hello!");
}

// å¸¦å‚æ•°çš„å‡½æ•°
fn greet_name(name: &str) {
    println!("Hello, {}!", name);
}

// å¸¦è¿”å›å€¼çš„å‡½æ•°
fn add(a: i32, b: i32) -> i32 {
    a + b  // è¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼ï¼Œä¸åŠ åˆ†å·
}

// æ˜¾å¼return
fn subtract(a: i32, b: i32) -> i32 {
    return a - b;  // ä½¿ç”¨returnå…³é”®å­—
}

// å¤šä¸ªå‚æ•°
fn describe_point(x: f64, y: f64, z: f64) {
    println!("Point: ({}, {}, {})", x, y, z);
}

fn main() {
    greet();
    greet_name("Alice");
    
    let sum = add(5, 3);
    println!("5 + 3 = {}", sum);
    
    let diff = subtract(10, 4);
    println!("10 - 4 = {}", diff);
    
    describe_point(1.0, 2.0, 3.0);
}
```

**å…³é”®è¦ç‚¹**:

- å‡½æ•°åä½¿ç”¨ snake_case
- å‚æ•°å¿…é¡»æŒ‡å®šç±»å‹
- è¿”å›å€¼ç±»å‹ä½¿ç”¨ `->` æŒ‡å®š
- æœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯è¿”å›å€¼ï¼ˆæ— åˆ†å·ï¼‰

### 1.2 å‚æ•°ä¼ é€’

Rust ä½¿ç”¨å€¼ä¼ é€’ï¼Œä½†å¯é€šè¿‡å¼•ç”¨ä¼ é€’ï¼š

```rust
// å€¼ä¼ é€’ï¼ˆæ‰€æœ‰æƒè½¬ç§»ï¼‰
fn take_ownership(s: String) {
    println!("æ‹¥æœ‰: {}", s);
    // s åœ¨è¿™é‡Œè¢«drop
}

// ä¸å¯å˜å¼•ç”¨
fn borrow(s: &String) {
    println!("å€Ÿç”¨: {}", s);
    // ä¸èƒ½ä¿®æ”¹s
}

// å¯å˜å¼•ç”¨
fn borrow_mut(s: &mut String) {
    s.push_str(" world");
    println!("å¯å˜å€Ÿç”¨: {}", s);
}

// åŸºæœ¬ç±»å‹ï¼ˆCopyï¼‰
fn use_number(n: i32) {
    println!("æ•°å­—: {}", n);
    // i32 æ˜¯ Copyï¼ŒåŸå€¼ä¸å—å½±å“
}

// å¤šä¸ªå‚æ•°
fn process(data: &[i32], factor: i32) -> Vec<i32> {
    data.iter().map(|&x| x * factor).collect()
}

fn main() {
    // æ‰€æœ‰æƒè½¬ç§»
    let s1 = String::from("hello");
    take_ownership(s1);
    // println!("{}", s1);  // é”™è¯¯ï¼šs1å·²è¢«ç§»åŠ¨
    
    // å€Ÿç”¨
    let s2 = String::from("hello");
    borrow(&s2);
    println!("s2ä»å¯ç”¨: {}", s2);
    
    // å¯å˜å€Ÿç”¨
    let mut s3 = String::from("hello");
    borrow_mut(&mut s3);
    println!("ä¿®æ”¹å: {}", s3);
    
    // Copyç±»å‹
    let num = 42;
    use_number(num);
    println!("numä»å¯ç”¨: {}", num);
    
    // å¤šä¸ªå‚æ•°
    let data = vec![1, 2, 3, 4];
    let result = process(&data, 2);
    println!("{:?}", result);
}
```

### 1.3 è¿”å›å€¼

å‡½æ•°å¯ä»¥è¿”å›å€¼æˆ– unit ç±»å‹ï¼š

```rust
// è¿”å›å…·ä½“å€¼
fn get_value() -> i32 {
    42
}

// è¿”å›å…ƒç»„
fn get_coordinates() -> (f64, f64) {
    (3.14, 2.71)
}

// è¿”å› Option
fn divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}

// è¿”å› Result
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse()
}

// è¿”å›å¼•ç”¨ï¼ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸï¼‰
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// æ— è¿”å›å€¼ï¼ˆunitç±»å‹ ()ï¼‰
fn print_message(msg: &str) {
    println!("{}", msg);
    // éšå¼è¿”å› ()
}

// æå‰è¿”å›
fn check_positive(n: i32) -> Result<i32, String> {
    if n < 0 {
        return Err("è´Ÿæ•°".to_string());
    }
    
    if n == 0 {
        return Err("é›¶".to_string());
    }
    
    Ok(n)
}

fn main() {
    println!("å€¼: {}", get_value());
    
    let (x, y) = get_coordinates();
    println!("åæ ‡: ({}, {})", x, y);
    
    match divide(10.0, 2.0) {
        Some(result) => println!("10 / 2 = {}", result),
        None => println!("é™¤é›¶é”™è¯¯"),
    }
    
    match parse_number("42") {
        Ok(n) => println!("è§£ææˆåŠŸ: {}", n),
        Err(e) => println!("è§£æå¤±è´¥: {}", e),
    }
    
    let s1 = "hello";
    let s2 = "world!";
    println!("æ›´é•¿çš„æ˜¯: {}", longest(s1, s2));
    
    print_message("Hello");
    
    match check_positive(5) {
        Ok(n) => println!("æ­£æ•°: {}", n),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

### 1.4 å‡½æ•°ç­¾å

å‡½æ•°ç­¾åæè¿°å‡½æ•°çš„ç±»å‹ï¼š

```rust
// å‡½æ•°ç­¾å: fn(i32, i32) -> i32
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// å‡½æ•°ç­¾å: fn(&str) -> String
fn to_uppercase(s: &str) -> String {
    s.to_uppercase()
}

// å‡½æ•°ç­¾å: fn(Vec<i32>) -> Vec<i32>
fn double_vec(v: Vec<i32>) -> Vec<i32> {
    v.into_iter().map(|x| x * 2).collect()
}

// æ³›å‹å‡½æ•°ç­¾å: fn<T>(T, T) -> T
fn first<T>(a: T, b: T) -> T {
    a
}

// å¸¦çº¦æŸçš„æ³›å‹ç­¾å: fn<T: Display>(T) -> ()
use std::fmt::Display;
fn print_it<T: Display>(value: T) {
    println!("{}", value);
}

fn main() {
    // ä½¿ç”¨å‡½æ•°ç­¾åè¿›è¡Œç±»å‹æ¨æ–­
    let f: fn(i32, i32) -> i32 = add;
    println!("3 + 4 = {}", f(3, 4));
    
    let g: fn(&str) -> String = to_uppercase;
    println!("{}", g("hello"));
}
```

---

## 2. é—­åŒ…

### 2.1 é—­åŒ…è¯­æ³•

é—­åŒ…æ˜¯åŒ¿åå‡½æ•°ï¼Œå¯ä»¥æ•è·ç¯å¢ƒï¼š

```rust
fn main() {
    // åŸºæœ¬é—­åŒ…
    let add = |a, b| a + b;
    println!("5 + 3 = {}", add(5, 3));
    
    // æŒ‡å®šç±»å‹
    let multiply: fn(i32, i32) -> i32 = |a, b| a * b;
    println!("4 * 3 = {}", multiply(4, 3));
    
    // å¸¦ç±»å‹æ ‡æ³¨çš„é—­åŒ…
    let divide = |a: f64, b: f64| -> f64 {
        a / b
    };
    println!("10 / 2 = {}", divide(10.0, 2.0));
    
    // å¤šè¡Œé—­åŒ…
    let complex = |x: i32| {
        let squared = x * x;
        let doubled = squared * 2;
        doubled + x
    };
    println!("å¤æ‚è®¡ç®—: {}", complex(5));
    
    // æ— å‚æ•°é—­åŒ…
    let greet = || {
        println!("Hello!");
    };
    greet();
    
    // ç±»å‹æ¨æ–­
    let numbers = vec![1, 2, 3, 4, 5];
    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();
    println!("{:?}", doubled);
}
```

### 2.2 ç¯å¢ƒæ•è·

é—­åŒ…å¯ä»¥æ•è·å¤–éƒ¨å˜é‡ï¼š

```rust
fn main() {
    let x = 10;
    
    // ä¸å¯å˜å€Ÿç”¨æ•è·
    let print_x = || {
        println!("x = {}", x);
    };
    print_x();
    println!("xä»å¯ç”¨: {}", x);
    
    // å¯å˜å€Ÿç”¨æ•è·
    let mut count = 0;
    let mut increment = || {
        count += 1;
        println!("count = {}", count);
    };
    increment();
    increment();
    // println!("{}", count);  // é”™è¯¯ï¼šå¯å˜å€Ÿç”¨æœŸé—´ä¸èƒ½ä½¿ç”¨
    
    // æ‰€æœ‰æƒè½¬ç§»æ•è·ï¼ˆmoveï¼‰
    let s = String::from("hello");
    let take_s = move || {
        println!("æ‹¥æœ‰å­—ç¬¦ä¸²: {}", s);
    };
    take_s();
    // println!("{}", s);  // é”™è¯¯ï¼šså·²è¢«ç§»åŠ¨
    
    // æ•è·å¤šä¸ªå˜é‡
    let a = 5;
    let b = 10;
    let sum = || a + b;
    println!("sum = {}", sum());
    
    // æ•è·å¯å˜å¼•ç”¨
    let mut vec = vec![1, 2, 3];
    {
        let mut push_4 = || {
            vec.push(4);
        };
        push_4();
    }  // å¯å˜å€Ÿç”¨ç»“æŸ
    println!("{:?}", vec);
}
```

### 2.3 é—­åŒ…trait

é—­åŒ…å®ç°ä¸‰ä¸ªtraitä¹‹ä¸€ï¼š

```rust
fn main() {
    // FnOnce: æ¶ˆè´¹æ•è·çš„å€¼ï¼Œåªèƒ½è°ƒç”¨ä¸€æ¬¡
    let s = String::from("hello");
    let consume = || {
        let _s = s;  // è·å–æ‰€æœ‰æƒ
    };
    consume();
    // consume();  // é”™è¯¯ï¼šåªèƒ½è°ƒç”¨ä¸€æ¬¡
    
    // FnMut: å¯å˜å€Ÿç”¨ï¼Œå¯å¤šæ¬¡è°ƒç”¨
    let mut count = 0;
    let mut increment = || {
        count += 1;
    };
    increment();
    increment();
    println!("count = {}", count);
    
    // Fn: ä¸å¯å˜å€Ÿç”¨ï¼Œå¯å¤šæ¬¡è°ƒç”¨
    let x = 10;
    let print = || {
        println!("x = {}", x);
    };
    print();
    print();
    
    // ä½œä¸ºå‚æ•°ä¼ é€’
    fn call_once<F>(f: F) where F: FnOnce() {
        f();
    }
    
    fn call_mut<F>(mut f: F) where F: FnMut() {
        f();
        f();
    }
    
    fn call_fn<F>(f: F) where F: Fn() {
        f();
        f();
    }
    
    call_fn(|| println!("Fn closure"));
    
    let mut n = 0;
    call_mut(|| n += 1);
    println!("n = {}", n);
}
```

**traitå±‚æ¬¡**:

- `Fn` ç»§æ‰¿è‡ª `FnMut`
- `FnMut` ç»§æ‰¿è‡ª `FnOnce`
- æ‰€æœ‰é—­åŒ…éƒ½å®ç° `FnOnce`
- åªæœ‰ä¸ä¿®æ”¹æ•è·å˜é‡çš„é—­åŒ…å®ç° `Fn`

### 2.4 moveè¯­ä¹‰

ä½¿ç”¨ `move` å¼ºåˆ¶é—­åŒ…è·å–æ‰€æœ‰æƒï¼š

```rust
use std::thread;

fn main() {
    // åŸºæœ¬ move
    let x = 10;
    let closure = move || {
        println!("x = {}", x);
    };
    closure();
    // x æ˜¯ Copy ç±»å‹ï¼Œä»ç„¶å¯ç”¨
    println!("x = {}", x);
    
    // move éCopyç±»å‹
    let s = String::from("hello");
    let closure = move || {
        println!("s = {}", s);
    };
    closure();
    // println!("{}", s);  // é”™è¯¯ï¼šså·²è¢«ç§»åŠ¨
    
    // åœ¨çº¿ç¨‹ä¸­ä½¿ç”¨ move
    let data = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("data = {:?}", data);
    });
    handle.join().unwrap();
    // println!("{:?}", data);  // é”™è¯¯ï¼šdataå·²è¢«ç§»åŠ¨
    
    // move ä¸ Clone
    let s = String::from("world");
    let s_clone = s.clone();
    let closure = move || {
        println!("æ‹¥æœ‰å…‹éš†: {}", s_clone);
    };
    closure();
    println!("åŸå§‹å­—ç¬¦ä¸²: {}", s);
}
```

---

## 3. å‡½æ•°æŒ‡é’ˆ

### 3.1 å‡½æ•°ä½œä¸ºå‚æ•°

å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ï¼š

```rust
// æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°
fn apply_operation(x: i32, y: i32, op: fn(i32, i32) -> i32) -> i32 {
    op(x, y)
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn main() {
    let result1 = apply_operation(5, 3, add);
    println!("5 + 3 = {}", result1);
    
    let result2 = apply_operation(5, 3, multiply);
    println!("5 * 3 = {}", result2);
    
    // ä½¿ç”¨é—­åŒ…ï¼ˆæ— æ•è·ï¼‰
    let result3 = apply_operation(5, 3, |a, b| a - b);
    println!("5 - 3 = {}", result3);
}
```

### 3.2 fnç±»å‹

`fn` æ˜¯å‡½æ•°æŒ‡é’ˆç±»å‹ï¼š

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    // å‡½æ•°æŒ‡é’ˆ
    let f: fn(i32, i32) -> i32 = add;
    println!("ç»“æœ: {}", f(3, 4));
    
    // å‡½æ•°æŒ‡é’ˆæ•°ç»„
    let operations: [fn(i32, i32) -> i32; 3] = [
        |a, b| a + b,
        |a, b| a - b,
        |a, b| a * b,
    ];
    
    for (i, op) in operations.iter().enumerate() {
        println!("æ“ä½œ{}: 5 op 3 = {}", i, op(5, 3));
    }
    
    // è¿”å›å‡½æ•°æŒ‡é’ˆ
    fn get_operation(op_type: &str) -> fn(i32, i32) -> i32 {
        match op_type {
            "add" => |a, b| a + b,
            "sub" => |a, b| a - b,
            "mul" => |a, b| a * b,
            _ => |_, _| 0,
        }
    }
    
    let op = get_operation("mul");
    println!("åŠ¨æ€æ“ä½œ: {}", op(4, 5));
}
```

### 3.3 å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…

ç†è§£ `fn` ä¸ `Fn` trait çš„åŒºåˆ«ï¼š

```rust
fn main() {
    // fn ç±»å‹ï¼šæ™®é€šå‡½æ•°æŒ‡é’ˆ
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    let f: fn(i32, i32) -> i32 = add;
    println!("fn: {}", f(3, 4));
    
    // Fn traitï¼šå¯ä»¥æ˜¯é—­åŒ…
    let x = 10;
    let add_x = |a: i32| a + x;  // æ•è·ç¯å¢ƒ
    
    // æ¥å— Fn trait
    fn call_with_one<F>(f: F) -> i32
    where
        F: Fn(i32) -> i32,
    {
        f(1)
    }
    
    println!("Fn trait: {}", call_with_one(add_x));
    
    // fn å¯ä»¥è½¬æ¢ä¸º Fn
    fn double(x: i32) -> i32 {
        x * 2
    }
    
    println!("fn as Fn: {}", call_with_one(double));
    
    // Fn ä¸ä¸€å®šèƒ½è½¬æ¢ä¸º fn
    // let f: fn(i32) -> i32 = add_x;  // é”™è¯¯ï¼šæ•è·äº†ç¯å¢ƒ
}
```

---

## 4. é«˜é˜¶å‡½æ•°

### 4.1 æ¥å—å‡½æ•°å‚æ•°

é«˜é˜¶å‡½æ•°æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°ï¼š

```rust
// åŸºæœ¬é«˜é˜¶å‡½æ•°
fn apply<F>(value: i32, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    f(value)
}

// æ¥å—å¤šä¸ªå‡½æ•°
fn compose<F, G>(x: i32, f: F, g: G) -> i32
where
    F: Fn(i32) -> i32,
    G: Fn(i32) -> i32,
{
    g(f(x))
}

// æ¡ä»¶æ‰§è¡Œ
fn conditional_apply<F>(value: i32, condition: bool, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    if condition {
        f(value)
    } else {
        value
    }
}

// é‡å¤åº”ç”¨
fn repeat<F>(value: i32, n: usize, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    let mut result = value;
    for _ in 0..n {
        result = f(result);
    }
    result
}

fn main() {
    let result = apply(5, |x| x * 2);
    println!("åº”ç”¨å‡½æ•°: {}", result);
    
    let result = compose(5, |x| x * 2, |x| x + 3);
    println!("ç»„åˆå‡½æ•°: {}", result);
    
    let result = conditional_apply(10, true, |x| x * 2);
    println!("æ¡ä»¶åº”ç”¨: {}", result);
    
    let result = repeat(2, 3, |x| x * 2);
    println!("é‡å¤åº”ç”¨: {}", result);
}
```

### 4.2 è¿”å›å‡½æ•°

è¿”å›é—­åŒ…éœ€è¦ä½¿ç”¨ Boxï¼š

```rust
// è¿”å›å‡½æ•°æŒ‡é’ˆ
fn get_adder(x: i32) -> fn(i32) -> i32 {
    fn add_impl(y: i32) -> i32 {
        y + 10  // ä¸èƒ½æ•è·xï¼Œå› ä¸ºfnä¸æ•è·ç¯å¢ƒ
    }
    add_impl
}

// è¿”å› Box<dyn Fn>
fn get_closure_adder(x: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |y| y + x)
}

// è¿”å› impl Fn
fn get_impl_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| y + x
}

// å·¥å‚å‡½æ•°
fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
    move |x| x * factor
}

fn main() {
    // ä½¿ç”¨å‡½æ•°æŒ‡é’ˆ
    let f = get_adder(5);
    println!("fn: {}", f(10));
    
    // ä½¿ç”¨ Box<dyn Fn>
    let g = get_closure_adder(5);
    println!("Box<dyn Fn>: {}", g(10));
    
    // ä½¿ç”¨ impl Fn
    let h = get_impl_adder(5);
    println!("impl Fn: {}", h(10));
    
    // å·¥å‚å‡½æ•°
    let times_two = create_multiplier(2);
    let times_three = create_multiplier(3);
    
    println!("2 * 5 = {}", times_two(5));
    println!("3 * 5 = {}", times_three(5));
}
```

### 4.3 å‡½æ•°ç»„åˆ

å®ç°å‡½æ•°ç»„åˆå™¨ï¼š

```rust
// å‡½æ•°ç»„åˆ
fn compose<F, G, A, B, C>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

// æŸ¯é‡ŒåŒ–
fn curry<F, A, B, C>(f: F) -> impl Fn(A) -> Box<dyn Fn(B) -> C>
where
    F: Fn(A, B) -> C + 'static,
    A: 'static,
    B: 'static,
    C: 'static,
{
    move |a| Box::new(move |b| f(a, b))
}

// åå‡½æ•°åº”ç”¨
fn partial<F, A, B, C>(f: F, a: A) -> impl Fn(B) -> C
where
    F: Fn(A, B) -> C,
    A: Clone,
{
    move |b| f(a.clone(), b)
}

fn main() {
    // å‡½æ•°ç»„åˆ
    let add_one = |x: i32| x + 1;
    let double = |x: i32| x * 2;
    
    let add_one_then_double = compose(add_one, double);
    println!("(5 + 1) * 2 = {}", add_one_then_double(5));
    
    // æŸ¯é‡ŒåŒ–
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    let curried_add = curry(add);
    let add_5 = curried_add(5);
    println!("æŸ¯é‡ŒåŒ–: 5 + 3 = {}", add_5(3));
    
    // åå‡½æ•°åº”ç”¨
    fn multiply(a: i32, b: i32) -> i32 {
        a * b
    }
    
    let double_partial = partial(multiply, 2);
    println!("ååº”ç”¨: 2 * 7 = {}", double_partial(7));
}
```

---

## 5. æ–¹æ³•

### 5.1 å…³è”å‡½æ•°

å…³è”å‡½æ•°å®šä¹‰åœ¨ impl å—ä¸­ï¼š

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // å…³è”å‡½æ•°ï¼ˆæ„é€ å™¨ï¼‰
    fn new(width: u32, height: u32) -> Self {
        Rectangle { width, height }
    }
    
    // å¸¦é»˜è®¤å€¼çš„æ„é€ å™¨
    fn square(size: u32) -> Self {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    // å…¶ä»–å…³è”å‡½æ•°
    fn default() -> Self {
        Rectangle {
            width: 10,
            height: 10,
        }
    }
}

fn main() {
    let rect1 = Rectangle::new(30, 50);
    let rect2 = Rectangle::square(25);
    let rect3 = Rectangle::default();
    
    println!("rect1: {}x{}", rect1.width, rect1.height);
    println!("rect2: {}x{}", rect2.width, rect2.height);
    println!("rect3: {}x{}", rect3.width, rect3.height);
}
```

### 5.2 selfå‚æ•°

æ–¹æ³•å¯ä»¥å€Ÿç”¨ self æˆ–è·å–æ‰€æœ‰æƒï¼š

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Self {
        Counter { count: 0 }
    }
    
    // ä¸å¯å˜å€Ÿç”¨ &self
    fn get(&self) -> u32 {
        self.count
    }
    
    // å¯å˜å€Ÿç”¨ &mut self
    fn increment(&mut self) {
        self.count += 1;
    }
    
    fn add(&mut self, n: u32) {
        self.count += n;
    }
    
    // è·å–æ‰€æœ‰æƒ self
    fn consume(self) -> u32 {
        println!("æ¶ˆè´¹Counter");
        self.count
    }
}

fn main() {
    let mut counter = Counter::new();
    
    println!("åˆå§‹: {}", counter.get());
    
    counter.increment();
    println!("é€’å¢å: {}", counter.get());
    
    counter.add(5);
    println!("åŠ 5å: {}", counter.get());
    
    let final_count = counter.consume();
    println!("æœ€ç»ˆ: {}", final_count);
    
    // counter å·²è¢«æ¶ˆè´¹ï¼Œä¸èƒ½å†ä½¿ç”¨
    // println!("{}", counter.get());  // é”™è¯¯
}
```

### 5.3 æ–¹æ³•é“¾

å®ç°æµç•…çš„æ–¹æ³•é“¾ï¼š

```rust
struct Builder {
    value: String,
}

impl Builder {
    fn new() -> Self {
        Builder {
            value: String::new(),
        }
    }
    
    // è¿”å› &mut self æ”¯æŒé“¾å¼è°ƒç”¨
    fn add(&mut self, s: &str) -> &mut Self {
        self.value.push_str(s);
        self
    }
    
    fn add_line(&mut self, s: &str) -> &mut Self {
        self.value.push_str(s);
        self.value.push('\n');
        self
    }
    
    fn repeat(&mut self, s: &str, times: usize) -> &mut Self {
        for _ in 0..times {
            self.value.push_str(s);
        }
        self
    }
    
    fn build(self) -> String {
        self.value
    }
}

fn main() {
    let result = Builder::new()
        .add("Hello")
        .add(" ")
        .add("World")
        .add_line("!")
        .repeat("*", 5)
        .build();
    
    println!("{}", result);
}
```

---

## 6. æ³›å‹å‡½æ•°

### 6.1 ç±»å‹å‚æ•°

ä½¿ç”¨æ³›å‹å‚æ•°ç¼–å†™é€šç”¨å‡½æ•°ï¼š

```rust
// åŸºæœ¬æ³›å‹å‡½æ•°
fn identity<T>(value: T) -> T {
    value
}

// å¤šä¸ªç±»å‹å‚æ•°
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// æ³›å‹ä¸å¼•ç”¨
fn first<T>(slice: &[T]) -> Option<&T> {
    slice.first()
}

// æ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸ
fn longest<'a, T>(x: &'a [T], y: &'a [T]) -> &'a [T] {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let num = identity(42);
    let text = identity("hello");
    println!("num: {}, text: {}", num, text);
    
    let p = pair(1, "one");
    println!("{:?}", p);
    
    let numbers = vec![1, 2, 3];
    if let Some(first) = first(&numbers) {
        println!("ç¬¬ä¸€ä¸ª: {}", first);
    }
    
    let a = vec![1, 2, 3];
    let b = vec![4, 5];
    let longer = longest(&a, &b);
    println!("æ›´é•¿: {:?}", longer);
}
```

### 6.2 traitçº¦æŸ

ä½¿ç”¨ trait bounds é™åˆ¶æ³›å‹ï¼š

```rust
use std::fmt::Display;

// å•ä¸ªçº¦æŸ
fn print_it<T: Display>(value: T) {
    println!("{}", value);
}

// å¤šä¸ªçº¦æŸ
fn compare_and_print<T: Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} > {}", a, b);
    } else {
        println!("{} <= {}", a, b);
    }
}

// Clone çº¦æŸ
fn duplicate<T: Clone>(value: T) -> (T, T) {
    (value.clone(), value)
}

// Debug çº¦æŸ
use std::fmt::Debug;

fn debug_print<T: Debug>(value: T) {
    println!("{:?}", value);
}

fn main() {
    print_it(42);
    print_it("hello");
    
    compare_and_print(10, 20);
    compare_and_print("apple", "banana");
    
    let (a, b) = duplicate(vec![1, 2, 3]);
    println!("{:?}, {:?}", a, b);
    
    debug_print(vec![1, 2, 3]);
}
```

### 6.3 whereå­å¥

ä½¿ç”¨ where å­å¥ç®€åŒ–å¤æ‚çº¦æŸï¼š

```rust
use std::fmt::{Debug, Display};

// å¤æ‚çº¦æŸ
fn complex_function<T, U>(t: T, u: U) -> String
where
    T: Display + Clone,
    U: Debug + Clone,
{
    format!("t = {}, u = {:?}", t, u.clone())
}

// è¿”å›å€¼çº¦æŸ
fn make_pair<T, U>(t: T, u: U) -> impl Display
where
    T: Display,
    U: Display,
{
    format!("({}, {})", t, u)
}

// å…³è”ç±»å‹çº¦æŸ
fn process_iterator<I>(iter: I) -> Vec<I::Item>
where
    I: Iterator,
    I::Item: Clone,
{
    iter.cloned().collect()
}

fn main() {
    let result = complex_function("hello", vec![1, 2, 3]);
    println!("{}", result);
    
    let pair = make_pair(42, "world");
    println!("{}", pair);
}
```

---

## 7. å¼‚æ­¥å‡½æ•°

### 7.1 async/await

ä½¿ç”¨ async/await ç¼–å†™å¼‚æ­¥ä»£ç ï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// åŸºæœ¬å¼‚æ­¥å‡½æ•°
async fn hello_async() {
    println!("Hello from async!");
}

// å¸¦è¿”å›å€¼çš„å¼‚æ­¥å‡½æ•°
async fn get_number() -> i32 {
    42
}

// å¼‚æ­¥å‡½æ•°è°ƒç”¨å…¶ä»–å¼‚æ­¥å‡½æ•°
async fn compute() -> i32 {
    let a = get_number().await;
    let b = get_number().await;
    a + b
}

// é”™è¯¯å¤„ç†
async fn fetch_data() -> Result<String, String> {
    Ok("data".to_string())
}

async fn process_data() -> Result<(), String> {
    let data = fetch_data().await?;
    println!("æ•°æ®: {}", data);
    Ok(())
}

fn main() {
    // éœ€è¦è¿è¡Œæ—¶æ‰§è¡Œå¼‚æ­¥ä»£ç 
    // è¿™é‡Œåªæ˜¯ç¤ºä¾‹ï¼Œå®é™…éœ€è¦ tokio æˆ– async-std
    println!("å¼‚æ­¥å‡½æ•°ç¤ºä¾‹");
}
```

### 7.2 Future trait

ç†è§£ Future traitï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// è‡ªå®šä¹‰ Future
struct DelayedValue {
    value: i32,
    ready: bool,
}

impl Future for DelayedValue {
    type Output = i32;
    
    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        if self.ready {
            Poll::Ready(self.value)
        } else {
            self.ready = true;
            Poll::Pending
        }
    }
}

fn main() {
    println!("Future trait ç¤ºä¾‹");
}
```

### 7.3 å¼‚æ­¥é—­åŒ… (Rust 1.90+)

Rust 1.90+ æ”¯æŒå¼‚æ­¥é—­åŒ…ï¼š

```rust
// å¼‚æ­¥é—­åŒ…ï¼ˆæ¦‚å¿µç¤ºä¾‹ï¼‰
async fn example() {
    // å¼‚æ­¥é—­åŒ…
    let async_closure = async || {
        println!("å¼‚æ­¥é—­åŒ…");
        42
    };
    
    let result = async_closure().await;
    println!("ç»“æœ: {}", result);
}

fn main() {
    println!("å¼‚æ­¥é—­åŒ…éœ€è¦è¿è¡Œæ—¶æ”¯æŒ");
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: ç­–ç•¥æ¨¡å¼

```rust
// ç­–ç•¥trait
trait SortStrategy {
    fn sort(&self, data: &mut [i32]);
}

// å†’æ³¡æ’åºç­–ç•¥
struct BubbleSort;

impl SortStrategy for BubbleSort {
    fn sort(&self, data: &mut [i32]) {
        let len = data.len();
        for i in 0..len {
            for j in 0..len - i - 1 {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
}

// å¿«é€Ÿæ’åºç­–ç•¥
struct QuickSort;

impl SortStrategy for QuickSort {
    fn sort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        let pivot = data[0];
        let mut left = vec![];
        let mut right = vec![];
        
        for &item in &data[1..] {
            if item <= pivot {
                left.push(item);
            } else {
                right.push(item);
            }
        }
        
        self.sort(&mut left);
        self.sort(&mut right);
        
        let mut i = 0;
        for item in left.iter().chain(std::iter::once(&pivot)).chain(right.iter()) {
            data[i] = *item;
            i += 1;
        }
    }
}

// æ’åºå™¨
struct Sorter {
    strategy: Box<dyn SortStrategy>,
}

impl Sorter {
    fn new(strategy: Box<dyn SortStrategy>) -> Self {
        Sorter { strategy }
    }
    
    fn sort(&self, data: &mut [i32]) {
        self.strategy.sort(data);
    }
}

fn main() {
    let mut data1 = vec![5, 2, 8, 1, 9];
    let sorter = Sorter::new(Box::new(BubbleSort));
    sorter.sort(&mut data1);
    println!("å†’æ³¡æ’åº: {:?}", data1);
    
    let mut data2 = vec![5, 2, 8, 1, 9];
    let sorter = Sorter::new(Box::new(QuickSort));
    sorter.sort(&mut data2);
    println!("å¿«é€Ÿæ’åº: {:?}", data2);
}
```

### æ¡ˆä¾‹2: å‡½æ•°å¼æ•°æ®å¤„ç†

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // é“¾å¼å¤„ç†
    let result: Vec<i32> = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)  // ç­›é€‰å¶æ•°
        .map(|&x| x * x)           // å¹³æ–¹
        .filter(|&x| x > 10)       // å¤§äº10
        .collect();
    
    println!("å¤„ç†ç»“æœ: {:?}", result);
    
    // foldç´¯ç§¯
    let sum: i32 = numbers.iter().fold(0, |acc, &x| acc + x);
    println!("æ€»å’Œ: {}", sum);
    
    // scançŠ¶æ€è½¬æ¢
    let running_sum: Vec<i32> = numbers
        .iter()
        .scan(0, |state, &x| {
            *state += x;
            Some(*state)
        })
        .collect();
    
    println!("ç´¯è®¡å’Œ: {:?}", running_sum);
    
    // partitionåˆ†ç»„
    let (even, odd): (Vec<_>, Vec<_>) = numbers
        .iter()
        .partition(|&&x| x % 2 == 0);
    
    println!("å¶æ•°: {:?}", even);
    println!("å¥‡æ•°: {:?}", odd);
}
```

### æ¡ˆä¾‹3: å›è°ƒç³»ç»Ÿ

```rust
type Callback = Box<dyn Fn(i32)>;

struct EventEmitter {
    listeners: Vec<Callback>,
}

impl EventEmitter {
    fn new() -> Self {
        EventEmitter {
            listeners: Vec::new(),
        }
    }
    
    fn on(&mut self, callback: Callback) {
        self.listeners.push(callback);
    }
    
    fn emit(&self, value: i32) {
        for listener in &self.listeners {
            listener(value);
        }
    }
}

fn main() {
    let mut emitter = EventEmitter::new();
    
    emitter.on(Box::new(|x| {
        println!("ç›‘å¬å™¨1: {}", x);
    }));
    
    emitter.on(Box::new(|x| {
        println!("ç›‘å¬å™¨2: {}", x * 2);
    }));
    
    emitter.on(Box::new(|x| {
        if x > 5 {
            println!("ç›‘å¬å™¨3: {} å¤§äº5", x);
        }
    }));
    
    emitter.emit(3);
    emitter.emit(7);
}
```

### æ¡ˆä¾‹4: è£…é¥°å™¨æ¨¡å¼

```rust
// åŸºç¡€å‡½æ•°ç±»å‹
type Operation = Box<dyn Fn(i32) -> i32>;

// æ—¥å¿—è£…é¥°å™¨
fn with_logging(op: Operation) -> Operation {
    Box::new(move |x| {
        println!("è°ƒç”¨å‡½æ•°ï¼Œè¾“å…¥: {}", x);
        let result = op(x);
        println!("è¿”å›ç»“æœ: {}", result);
        result
    })
}

// è®¡æ—¶è£…é¥°å™¨
fn with_timing(op: Operation) -> Operation {
    Box::new(move |x| {
        use std::time::Instant;
        let start = Instant::now();
        let result = op(x);
        let elapsed = start.elapsed();
        println!("æ‰§è¡Œæ—¶é—´: {:?}", elapsed);
        result
    })
}

// ç¼“å­˜è£…é¥°å™¨
fn with_cache(mut op: Operation) -> Operation {
    use std::collections::HashMap;
    let mut cache = HashMap::new();
    
    Box::new(move |x| {
        if let Some(&cached) = cache.get(&x) {
            println!("ç¼“å­˜å‘½ä¸­: {} -> {}", x, cached);
            cached
        } else {
            let result = op(x);
            cache.insert(x, result);
            result
        }
    })
}

fn main() {
    // åŸºç¡€å‡½æ•°
    let square: Operation = Box::new(|x| x * x);
    
    // æ·»åŠ è£…é¥°å™¨
    let decorated = with_cache(with_timing(with_logging(square)));
    
    println!("ç¬¬ä¸€æ¬¡è°ƒç”¨:");
    decorated(5);
    
    println!("\nç¬¬äºŒæ¬¡è°ƒç”¨ï¼ˆåº”è¯¥å‘½ä¸­ç¼“å­˜ï¼‰:");
    decorated(5);
    
    println!("\nç¬¬ä¸‰æ¬¡è°ƒç”¨ï¼ˆæ–°å€¼ï¼‰:");
    decorated(7);
}
```

### æ¡ˆä¾‹5: æƒ°æ€§æ±‚å€¼

```rust
struct LazyValue<F>
where
    F: FnOnce() -> i32,
{
    init: Option<F>,
    value: Option<i32>,
}

impl<F> LazyValue<F>
where
    F: FnOnce() -> i32,
{
    fn new(init: F) -> Self {
        LazyValue {
            init: Some(init),
            value: None,
        }
    }
    
    fn get(&mut self) -> i32 {
        if let Some(value) = self.value {
            println!("è¿”å›ç¼“å­˜å€¼");
            value
        } else {
            println!("è®¡ç®—åˆå§‹å€¼");
            let init = self.init.take().unwrap();
            let value = init();
            self.value = Some(value);
            value
        }
    }
}

fn main() {
    let mut lazy = LazyValue::new(|| {
        println!("æ‰§è¡Œæ˜‚è´µè®¡ç®—...");
        std::thread::sleep(std::time::Duration::from_millis(100));
        42
    });
    
    println!("LazyValueå·²åˆ›å»º");
    println!("ç¬¬ä¸€æ¬¡è®¿é—®: {}", lazy.get());
    println!("ç¬¬äºŒæ¬¡è®¿é—®: {}", lazy.get());
    println!("ç¬¬ä¸‰æ¬¡è®¿é—®: {}", lazy.get());
}
```

---

## 9. å¸¸è§é™·é˜±

```rust
fn main() {
    // âŒ é”™è¯¯ï¼šé—­åŒ…æ•è·å¯å˜å€Ÿç”¨åä¸èƒ½å†ä½¿ç”¨åŸå˜é‡
    let mut vec = vec![1, 2, 3];
    /*
    let mut closure = || vec.push(4);
    println!("{:?}", vec);  // é”™è¯¯
    closure();
    */
    
    // âœ… æ­£ç¡®ï¼šå…ˆå®Œæˆå€Ÿç”¨å†ä½¿ç”¨
    let mut vec = vec![1, 2, 3];
    {
        let mut closure = || vec.push(4);
        closure();
    }
    println!("{:?}", vec);
    
    // âŒ é”™è¯¯ï¼šè¿”å›é—­åŒ…éœ€è¦ Box æˆ– impl Trait
    /*
    fn bad_return() -> dyn Fn(i32) -> i32 {
        |x| x + 1
    }
    */
    
    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ impl Trait
    fn good_return() -> impl Fn(i32) -> i32 {
        |x| x + 1
    }
    
    let f = good_return();
    println!("{}", f(10));
}
```

---

## 10. æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨é—­åŒ…è€Œéå‡½æ•°æŒ‡é’ˆ**
2. **ä½¿ç”¨ impl Trait ç®€åŒ–è¿”å›ç±»å‹**
3. **åˆç†ä½¿ç”¨ move å…³é”®å­—**
4. **é¿å…è¿‡åº¦åµŒå¥—é—­åŒ…**
5. **ä½¿ç”¨è¿­ä»£å™¨æ–¹æ³•æ›¿ä»£æ˜¾å¼å¾ªç¯**
6. **ä¸ºå¤æ‚é—­åŒ…æ·»åŠ ç±»å‹æ³¨è§£**
7. **ä½¿ç”¨ trait bounds è€Œéå…·ä½“ç±»å‹**
8. **è€ƒè™‘é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸå’Œæ‰€æœ‰æƒ**

---

## 11. æ€§èƒ½ä¼˜åŒ–

1. **å†…è”**: å°å‡½æ•°å’Œé—­åŒ…ä¼šè¢«å†…è”
2. **é¿å…ä¸å¿…è¦çš„ Box**: ä½¿ç”¨ impl Trait
3. **é›¶æˆæœ¬æŠ½è±¡**: é—­åŒ…æ— è¿è¡Œæ—¶å¼€é”€
4. **é¿å…åŠ¨æ€åˆ†å‘**: ä¼˜å…ˆæ³›å‹è€Œé traitå¯¹è±¡
5. **ä½¿ç”¨è¿­ä»£å™¨**: ç¼–è¯‘å™¨å¯ä¼˜åŒ–è¿­ä»£å™¨é“¾

---

## 12. å°ç»“

- å‡½æ•°æ˜¯Rustçš„åŸºæœ¬æŠ½è±¡å•å…ƒ
- é—­åŒ…æä¾›çµæ´»çš„å‡½æ•°å¼ç¼–ç¨‹
- é«˜é˜¶å‡½æ•°æ”¯æŒå¼ºå¤§çš„æŠ½è±¡
- æ–¹æ³•æä¾›é¢å‘å¯¹è±¡é£æ ¼
- æ³›å‹å‡½æ•°å®ç°ä»£ç å¤ç”¨
- å¼‚æ­¥å‡½æ•°æ”¯æŒå¹¶å‘ç¼–ç¨‹

---

## 13. å»¶ä¼¸é˜…è¯»

**å†…éƒ¨æ–‡æ¡£**:

- [é—­åŒ…æ·±å…¥](../tier_04_advanced/02_é—­åŒ…æ·±å…¥.md)
- [å‡½æ•°å¼ç¼–ç¨‹](../tier_04_advanced/03_å‡½æ•°å¼ç¼–ç¨‹.md)
- [å¼‚æ­¥ç¼–ç¨‹æŒ‡å—](../../c06_async/docs/README.md)

**å¤–éƒ¨èµ„æº**:

- [Rust Book - Functions](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)
- [Rust Book - Closures](https://doc.rust-lang.org/book/ch13-01-closures.html)
- [Rust by Example - Functions](https://doc.rust-lang.org/rust-by-example/fn.html)

---

## 14. ç»ƒä¹ é¢˜

1. å®ç°ä¸€ä¸ªé€šç”¨çš„ç¼“å­˜å‡½æ•°è£…é¥°å™¨
2. ç¼–å†™ä¸€ä¸ªæ”¯æŒé“¾å¼è°ƒç”¨çš„æ„å»ºå™¨æ¨¡å¼
3. å®ç°å‡½æ•°ç»„åˆå’Œç®¡é“æ“ä½œç¬¦
4. åˆ›å»ºä¸€ä¸ªäº‹ä»¶ç³»ç»Ÿï¼Œæ”¯æŒå¤šä¸ªç›‘å¬å™¨
5. å®ç°æƒ°æ€§æ±‚å€¼çš„æ–æ³¢é‚£å¥‘æ•°åˆ—ç”Ÿæˆå™¨

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ¯ æŒæ¡Rustå‡½æ•°ç³»ç»Ÿï¼Œç¼–å†™ä¼˜é›…çš„å‡½æ•°å¼ä»£ç ï¼** ğŸ¦€âœ¨
