# 2.1 条件语句指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统化学习Rust条件语句，掌握if/match/if let核心用法  
> **学习时间**: 1-2天  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [项目概览](../tier_01_foundations/01_项目概览.md)


## 📊 目录

- [2.1 条件语句指南](#21-条件语句指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. if 表达式](#1-if-表达式)
    - [1.1 基本语法](#11-基本语法)
    - [1.2 if 作为表达式](#12-if-作为表达式)
    - [1.3 多重分支](#13-多重分支)
    - [1.4 嵌套 if](#14-嵌套-if)
    - [1.5 最佳实践](#15-最佳实践)
  - [2. match 表达式](#2-match-表达式)
    - [2.1 基本语法](#21-基本语法)
    - [2.2 模式匹配基础](#22-模式匹配基础)
    - [2.3 守卫条件](#23-守卫条件)
    - [2.4 匹配多个值](#24-匹配多个值)
    - [2.5 绑定模式](#25-绑定模式)
    - [2.6 完整性检查](#26-完整性检查)
  - [3. if let 表达式](#3-if-let-表达式)
    - [3.1 基本用法](#31-基本用法)
    - [3.2 链式 if let (Rust 1.90+)](#32-链式-if-let-rust-190)
    - [3.3 if let 与 else](#33-if-let-与-else)
  - [4. let else 语句 (Rust 1.65+)](#4-let-else-语句-rust-165)
    - [4.1 基本语法](#41-基本语法)
    - [4.2 使用场景](#42-使用场景)
    - [4.3 与其他模式的对比](#43-与其他模式的对比)
  - [5. 条件语句对比](#5-条件语句对比)
    - [5.1 功能对比](#51-功能对比)
    - [5.2 性能对比](#52-性能对比)
    - [5.3 选择指南](#53-选择指南)
  - [6. 实战案例](#6-实战案例)
    - [案例1: 配置解析器](#案例1-配置解析器)
    - [案例2: HTTP状态码处理](#案例2-http状态码处理)
    - [案例3: 命令行参数解析](#案例3-命令行参数解析)
    - [案例4: 状态机实现](#案例4-状态机实现)
    - [案例5: 表达式求值器](#案例5-表达式求值器)
  - [7. 常见陷阱](#7-常见陷阱)
    - [7.1 类型不一致](#71-类型不一致)
    - [7.2 忘记 else 分支](#72-忘记-else-分支)
    - [7.3 不完整的 match](#73-不完整的-match)
    - [7.4 过度嵌套](#74-过度嵌套)
  - [8. 最佳实践](#8-最佳实践)
  - [9. 性能优化](#9-性能优化)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)


**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [2.1 条件语句指南](#21-条件语句指南)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. if 表达式](#1-if-表达式)
    - [1.1 基本语法](#11-基本语法)
    - [1.2 if 作为表达式](#12-if-作为表达式)
    - [1.3 多重分支](#13-多重分支)
    - [1.4 嵌套 if](#14-嵌套-if)
    - [1.5 最佳实践](#15-最佳实践)
  - [2. match 表达式](#2-match-表达式)
    - [2.1 基本语法](#21-基本语法)
    - [2.2 模式匹配基础](#22-模式匹配基础)
    - [2.3 守卫条件](#23-守卫条件)
    - [2.4 匹配多个值](#24-匹配多个值)
    - [2.5 绑定模式](#25-绑定模式)
    - [2.6 完整性检查](#26-完整性检查)
  - [3. if let 表达式](#3-if-let-表达式)
    - [3.1 基本用法](#31-基本用法)
    - [3.2 链式 if let (Rust 1.90+)](#32-链式-if-let-rust-190)
    - [3.3 if let 与 else](#33-if-let-与-else)
  - [4. let else 语句 (Rust 1.65+)](#4-let-else-语句-rust-165)
    - [4.1 基本语法](#41-基本语法)
    - [4.2 使用场景](#42-使用场景)
    - [4.3 与其他模式的对比](#43-与其他模式的对比)
  - [5. 条件语句对比](#5-条件语句对比)
    - [5.1 功能对比](#51-功能对比)
    - [5.2 性能对比](#52-性能对比)
    - [5.3 选择指南](#53-选择指南)
  - [6. 实战案例](#6-实战案例)
    - [案例1: 配置解析器](#案例1-配置解析器)
    - [案例2: HTTP状态码处理](#案例2-http状态码处理)
    - [案例3: 命令行参数解析](#案例3-命令行参数解析)
    - [案例4: 状态机实现](#案例4-状态机实现)
    - [案例5: 表达式求值器](#案例5-表达式求值器)
  - [7. 常见陷阱](#7-常见陷阱)
    - [7.1 类型不一致](#71-类型不一致)
    - [7.2 忘记 else 分支](#72-忘记-else-分支)
    - [7.3 不完整的 match](#73-不完整的-match)
    - [7.4 过度嵌套](#74-过度嵌套)
  - [8. 最佳实践](#8-最佳实践)
  - [9. 性能优化](#9-性能优化)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)

---

## 🎯 学习目标

完成本指南学习后，您将能够：

- ✅ 掌握 if/else 表达式的使用
- ✅ 理解 match 表达式的模式匹配
- ✅ 熟练使用 if let 简化代码
- ✅ 应用 let else 处理错误情况
- ✅ 根据场景选择合适的条件语句
- ✅ 避免常见陷阱，编写高质量代码

---

## 1. if 表达式

### 1.1 基本语法

if 表达式是 Rust 中最基本的条件语句：

```rust
fn main() {
    let number = 5;
    
    // 基本 if
    if number < 10 {
        println!("数字小于10");
    }
    
    // if-else
    if number < 0 {
        println!("负数");
    } else {
        println!("非负数");
    }
    
    // if-else if-else
    if number < 0 {
        println!("负数");
    } else if number == 0 {
        println!("零");
    } else {
        println!("正数");
    }
}
```

**关键要点**:

- 条件表达式必须是 `bool` 类型
- 不需要括号包围条件（但可以加）
- 代码块必须用花括号 `{}` 包围

### 1.2 if 作为表达式

在 Rust 中，if 是表达式，可以返回值：

```rust
fn main() {
    let number = 5;
    
    // if 表达式赋值
    let description = if number < 10 {
        "小于10"
    } else {
        "大于等于10"
    };
    
    println!("数字{}: {}", number, description);
    
    // 在函数中返回
    let result = classify_number(15);
    println!("分类: {}", result);
}

fn classify_number(n: i32) -> &'static str {
    if n < 0 {
        "负数"
    } else if n == 0 {
        "零"
    } else if n < 10 {
        "个位数"
    } else if n < 100 {
        "两位数"
    } else {
        "三位数或更大"
    }
}
```

**关键要点**:

- 所有分支必须返回相同类型
- 最后一个表达式不加分号
- 如果作为表达式使用，必须有 else 分支

### 1.3 多重分支

处理多个条件时的模式：

```rust
fn main() {
    let score = 85;
    
    // 方式1: if-else if 链
    let grade = if score >= 90 {
        'A'
    } else if score >= 80 {
        'B'
    } else if score >= 70 {
        'C'
    } else if score >= 60 {
        'D'
    } else {
        'F'
    };
    
    println!("分数 {} 对应等级 {}", score, grade);
    
    // 方式2: 嵌套 if（不推荐）
    let grade2 = if score >= 60 {
        if score >= 70 {
            if score >= 80 {
                if score >= 90 {
                    'A'
                } else {
                    'B'
                }
            } else {
                'C'
            }
        } else {
            'D'
        }
    } else {
        'F'
    };
    
    // 方式3: 使用范围模式的 match（推荐）
    let grade3 = match score {
        90..=100 => 'A',
        80..=89 => 'B',
        70..=79 => 'C',
        60..=69 => 'D',
        _ => 'F',
    };
    
    println!("grade: {}, grade2: {}, grade3: {}", grade, grade2, grade3);
}
```

### 1.4 嵌套 if

有时需要嵌套使用 if：

```rust
fn main() {
    let age = 25;
    let has_license = true;
    let is_sober = true;
    
    // 嵌套 if
    if age >= 18 {
        if has_license {
            if is_sober {
                println!("可以驾驶");
            } else {
                println!("酒后不能驾驶");
            }
        } else {
            println!("需要驾照");
        }
    } else {
        println!("年龄不够");
    }
    
    // 使用逻辑运算符简化（推荐）
    if age >= 18 && has_license && is_sober {
        println!("可以驾驶");
    } else if age < 18 {
        println!("年龄不够");
    } else if !has_license {
        println!("需要驾照");
    } else {
        println!("酒后不能驾驶");
    }
    
    // 早期返回模式（函数中推荐）
    check_driving_eligibility(age, has_license, is_sober);
}

fn check_driving_eligibility(age: u32, has_license: bool, is_sober: bool) {
    if age < 18 {
        println!("年龄不够");
        return;
    }
    
    if !has_license {
        println!("需要驾照");
        return;
    }
    
    if !is_sober {
        println!("酒后不能驾驶");
        return;
    }
    
    println!("可以驾驶");
}
```

### 1.5 最佳实践

```rust
fn main() {
    let value = Some(42);
    
    // ❌ 不推荐：过度嵌套
    if value.is_some() {
        if value.unwrap() > 0 {
            if value.unwrap() < 100 {
                println!("值在范围内");
            }
        }
    }
    
    // ✅ 推荐：使用 if let
    if let Some(v) = value {
        if v > 0 && v < 100 {
            println!("值在范围内");
        }
    }
    
    // ✅ 推荐：链式条件
    if let Some(v) = value {
        if (1..100).contains(&v) {
            println!("值在范围内");
        }
    }
}
```

---

## 2. match 表达式

### 2.1 基本语法

match 是 Rust 中最强大的条件语句：

```rust
fn main() {
    let number = 3;
    
    // 基本 match
    match number {
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        4 => println!("四"),
        5 => println!("五"),
        _ => println!("其他"),
    }
    
    // match 表达式
    let chinese = match number {
        1 => "一",
        2 => "二",
        3 => "三",
        4 => "四",
        5 => "五",
        _ => "其他",
    };
    
    println!("数字 {} 的中文是 {}", number, chinese);
    
    // 多行代码块
    let result = match number {
        1 => {
            println!("匹配到1");
            "一"
        },
        2 => {
            println!("匹配到2");
            "二"
        },
        _ => {
            println!("匹配到其他");
            "其他"
        },
    };
    
    println!("结果: {}", result);
}
```

### 2.2 模式匹配基础

match 支持多种模式：

```rust
fn main() {
    // 字面量模式
    let x = 1;
    match x {
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        _ => println!("其他"),
    }
    
    // 范围模式
    let age = 25;
    match age {
        0..=12 => println!("儿童"),
        13..=19 => println!("青少年"),
        20..=59 => println!("成年人"),
        60.. => println!("老年人"),
    }
    
    // 多个值
    let day = 3;
    match day {
        1 | 2 | 3 | 4 | 5 => println!("工作日"),
        6 | 7 => println!("周末"),
        _ => println!("无效的日期"),
    }
    
    // 枚举匹配
    enum Direction {
        North,
        South,
        East,
        West,
    }
    
    let dir = Direction::North;
    match dir {
        Direction::North => println!("向北"),
        Direction::South => println!("向南"),
        Direction::East => println!("向东"),
        Direction::West => println!("向西"),
    }
    
    // Option 匹配
    let optional = Some(5);
    match optional {
        Some(value) => println!("有值: {}", value),
        None => println!("无值"),
    }
    
    // Result 匹配
    let result: Result<i32, &str> = Ok(42);
    match result {
        Ok(value) => println!("成功: {}", value),
        Err(error) => println!("错误: {}", error),
    }
}
```

### 2.3 守卫条件

使用 if 添加额外的条件：

```rust
fn main() {
    let number = 4;
    
    match number {
        n if n < 0 => println!("{} 是负数", n),
        n if n == 0 => println!("零"),
        n if n % 2 == 0 => println!("{} 是正偶数", n),
        n => println!("{} 是正奇数", n),
    }
    
    // 复杂守卫
    let point = (0, 5);
    match point {
        (x, y) if x == 0 && y == 0 => println!("原点"),
        (x, 0) if x != 0 => println!("在x轴上"),
        (0, y) if y != 0 => println!("在y轴上"),
        (x, y) if x == y => println!("在y=x线上"),
        (x, y) if x == -y => println!("在y=-x线上"),
        _ => println!("一般点"),
    }
    
    // 结合枚举
    enum Message {
        Text(String),
        Number(i32),
    }
    
    let msg = Message::Number(42);
    match msg {
        Message::Text(s) if s.len() > 10 => {
            println!("长文本: {}", s);
        },
        Message::Text(s) => {
            println!("短文本: {}", s);
        },
        Message::Number(n) if n < 0 => {
            println!("负数: {}", n);
        },
        Message::Number(n) => {
            println!("非负数: {}", n);
        },
    }
}
```

### 2.4 匹配多个值

```rust
fn main() {
    // 使用 | 匹配多个值
    let number = 2;
    match number {
        1 | 2 | 3 => println!("小数字"),
        4 | 5 | 6 => println!("中等数字"),
        7 | 8 | 9 => println!("大数字"),
        _ => println!("其他数字"),
    }
    
    // 结合范围
    let value = 45;
    match value {
        0..=10 | 90..=100 => println!("边界值"),
        11..=89 => println!("中间值"),
        _ => println!("其他"),
    }
    
    // 元组匹配
    let pair = (2, 3);
    match pair {
        (1, 1) | (2, 2) | (3, 3) => println!("相同的数字"),
        (1, 2) | (2, 1) => println!("1和2"),
        (_, 3) | (3, _) => println!("包含3"),
        _ => println!("其他组合"),
    }
}
```

### 2.5 绑定模式

使用 @ 绑定值：

```rust
fn main() {
    let number = 15;
    
    // @ 绑定
    match number {
        n @ 1..=10 => println!("{} 在1到10之间", n),
        n @ 11..=20 => println!("{} 在11到20之间", n),
        n => println!("{} 不在1到20之间", n),
    }
    
    // 结合守卫
    match number {
        n @ 1..=100 if n % 2 == 0 => {
            println!("{} 是1到100之间的偶数", n);
        },
        n @ 1..=100 => {
            println!("{} 是1到100之间的奇数", n);
        },
        n => {
            println!("{} 不在1到100之间", n);
        },
    }
    
    // 结构体绑定
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 5, y: 10 };
    match point {
        Point { x: 0, y: 0 } => println!("原点"),
        Point { x: 0, y } => println!("在y轴上，y={}", y),
        Point { x, y: 0 } => println!("在x轴上，x={}", x),
        Point { x, y } if x == y => println!("在对角线上，x=y={}", x),
        p @ Point { x: 1..=5, y: 1..=5 } => {
            println!("在小方格内: ({}, {})", p.x, p.y);
        },
        Point { x, y } => println!("一般点: ({}, {})", x, y),
    }
}
```

### 2.6 完整性检查

Rust 要求 match 必须穷尽所有可能：

```rust
fn main() {
    enum Color {
        Red,
        Green,
        Blue,
    }
    
    let color = Color::Red;
    
    // ❌ 编译错误：未覆盖所有情况
    // match color {
    //     Color::Red => println!("红色"),
    //     Color::Green => println!("绿色"),
    //     // 缺少 Blue
    // }
    
    // ✅ 正确：覆盖所有情况
    match color {
        Color::Red => println!("红色"),
        Color::Green => println!("绿色"),
        Color::Blue => println!("蓝色"),
    }
    
    // ✅ 正确：使用通配符
    match color {
        Color::Red => println!("红色"),
        _ => println!("其他颜色"),
    }
    
    // Option 必须处理 None
    let value: Option<i32> = Some(5);
    
    // ✅ 完整匹配
    match value {
        Some(v) => println!("值: {}", v),
        None => println!("无值"),
    }
    
    // Result 必须处理 Err
    let result: Result<i32, &str> = Ok(10);
    
    // ✅ 完整匹配
    match result {
        Ok(v) => println!("成功: {}", v),
        Err(e) => println!("错误: {}", e),
    }
}
```

---

## 3. if let 表达式

### 3.1 基本用法

if let 是 match 的语法糖，用于只关心一种情况：

```rust
fn main() {
    let some_value = Some(3);
    
    // 使用 match（繁琐）
    match some_value {
        Some(3) => println!("三"),
        _ => (),
    }
    
    // 使用 if let（简洁）
    if let Some(3) = some_value {
        println!("三");
    }
    
    // 绑定值
    if let Some(value) = some_value {
        println!("值是: {}", value);
    }
    
    // 带 else
    if let Some(value) = some_value {
        println!("有值: {}", value);
    } else {
        println!("无值");
    }
    
    // Result 处理
    let result: Result<i32, &str> = Ok(42);
    if let Ok(value) = result {
        println!("成功: {}", value);
    } else {
        println!("失败");
    }
}
```

### 3.2 链式 if let (Rust 1.90+)

Rust 1.90 引入了链式 if let：

```rust
fn main() {
    let value = Some(10);
    
    // 旧方式：嵌套
    if let Some(v) = value {
        if v > 5 {
            println!("大于5");
        }
    }
    
    // Rust 1.90+: 链式 if let
    if let Some(v) = value && v > 5 {
        println!("大于5");
    }
    
    // 多个条件
    let result: Result<i32, &str> = Ok(20);
    if let Ok(v) = result && v > 10 && v < 30 {
        println!("值在10到30之间: {}", v);
    }
    
    // 复杂示例
    struct Config {
        enabled: bool,
        value: Option<i32>,
    }
    
    let config = Config {
        enabled: true,
        value: Some(15),
    };
    
    // 链式条件
    if config.enabled && let Some(v) = config.value && v > 10 {
        println!("配置启用且值大于10: {}", v);
    }
}
```

### 3.3 if let 与 else

```rust
fn main() {
    let value = Some(5);
    
    // if let-else
    if let Some(v) = value {
        println!("有值: {}", v);
    } else {
        println!("无值");
    }
    
    // if let-else if-else
    if let Some(v) = value {
        if v > 10 {
            println!("大于10");
        } else {
            println!("不大于10");
        }
    } else {
        println!("无值");
    }
    
    // if let-else if let
    enum Message {
        Text(String),
        Number(i32),
        None,
    }
    
    let msg = Message::Number(42);
    
    if let Message::Text(s) = msg {
        println!("文本: {}", s);
    } else if let Message::Number(n) = msg {
        println!("数字: {}", n);
    } else {
        println!("无消息");
    }
}
```

---

## 4. let else 语句 (Rust 1.65+)

### 4.1 基本语法

let else 用于在模式不匹配时提前返回：

```rust
fn main() {
    let config = Some("config.toml");
    
    // 传统方式
    let config_file = if let Some(file) = config {
        file
    } else {
        return;
    };
    
    println!("配置文件: {}", config_file);
}

fn process_value(value: Option<i32>) {
    // let else 方式
    let Some(v) = value else {
        println!("无值，提前返回");
        return;
    };
    
    println!("处理值: {}", v);
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    // let else 用于 Result
    let Ok(()) = check_divisor(b) else {
        return Err("除数无效".to_string());
    };
    
    Ok(a / b)
}

fn check_divisor(b: i32) -> Result<(), String> {
    if b == 0 {
        Err("除数不能为零".to_string())
    } else {
        Ok(())
    }
}
```

### 4.2 使用场景

let else 适合早期返回的场景：

```rust
fn parse_config(config: Option<&str>) -> Result<(), String> {
    // 检查配置存在
    let Some(cfg) = config else {
        return Err("配置不存在".to_string());
    };
    
    // 检查配置非空
    let true = !cfg.is_empty() else {
        return Err("配置为空".to_string());
    };
    
    println!("配置: {}", cfg);
    Ok(())
}

fn process_user(user_id: Option<u32>, name: Option<String>) -> Result<(), String> {
    // 多个检查
    let Some(id) = user_id else {
        return Err("用户ID缺失".to_string());
    };
    
    let Some(n) = name else {
        return Err("用户名缺失".to_string());
    };
    
    println!("用户 {} (ID: {})", n, id);
    Ok(())
}

fn validate_input(input: Result<String, String>) -> Result<String, String> {
    // Result 解构
    let Ok(value) = input else {
        return Err("输入无效".to_string());
    };
    
    let true = value.len() > 0 else {
        return Err("输入为空".to_string());
    };
    
    Ok(value)
}

fn main() {
    process_value(Some(42));
    process_value(None);
    
    let _ = parse_config(Some("config.toml"));
    let _ = parse_config(None);
    
    let _ = process_user(Some(1), Some("Alice".to_string()));
    let _ = process_user(None, Some("Bob".to_string()));
}
```

### 4.3 与其他模式的对比

```rust
fn main() {
    let value = Some(10);
    
    // 方式1: unwrap_or (简单默认值)
    let v1 = value.unwrap_or(0);
    println!("v1: {}", v1);
    
    // 方式2: if let (需要使用值)
    if let Some(v) = value {
        println!("v2: {}", v);
    } else {
        println!("无值");
        return;
    }
    
    // 方式3: match (多种情况)
    let v3 = match value {
        Some(v) => v,
        None => {
            println!("无值");
            return;
        }
    };
    println!("v3: {}", v3);
    
    // 方式4: let else (提前返回，推荐)
    let Some(v4) = value else {
        println!("无值");
        return;
    };
    println!("v4: {}", v4);
}
```

---

## 5. 条件语句对比

### 5.1 功能对比

| 特性 | if | match | if let | let else |
|------|----|----|--------|----------|
| **简单条件** | ✅ 最佳 | ❌ 过于复杂 | ❌ 不适用 | ❌ 不适用 |
| **多个分支** | ⚠️ 可以但繁琐 | ✅ 最佳 | ❌ 不适用 | ❌ 不适用 |
| **模式匹配** | ❌ 不支持 | ✅ 最佳 | ✅ 单一模式 | ✅ 早期返回 |
| **Option处理** | ⚠️ 需要is_some | ✅ 完整 | ✅ 简洁 | ✅ 提前返回 |
| **Result处理** | ⚠️ 需要is_ok | ✅ 完整 | ✅ 简洁 | ✅ 提前返回 |
| **守卫条件** | ✅ && 运算符 | ✅ if 守卫 | ✅ && 运算符 | ❌ 不支持 |
| **完整性检查** | ❌ 编译器不检查 | ✅ 强制穷尽 | ❌ 不检查 | ❌ 不检查 |
| **早期返回** | ⚠️ 需要嵌套 | ⚠️ 需要嵌套 | ⚠️ 需要嵌套 | ✅ 最佳 |

### 5.2 性能对比

```rust
use std::time::Instant;

fn benchmark() {
    let iterations = 10_000_000;
    let value = Some(42);
    
    // if-else 性能
    let start = Instant::now();
    for _ in 0..iterations {
        let _result = if value.is_some() {
            value.unwrap()
        } else {
            0
        };
    }
    println!("if-else: {:?}", start.elapsed());
    
    // match 性能
    let start = Instant::now();
    for _ in 0..iterations {
        let _result = match value {
            Some(v) => v,
            None => 0,
        };
    }
    println!("match: {:?}", start.elapsed());
    
    // if let 性能
    let start = Instant::now();
    for _ in 0..iterations {
        let _result = if let Some(v) = value {
            v
        } else {
            0
        };
    }
    println!("if let: {:?}", start.elapsed());
}

fn main() {
    benchmark();
}
```

**性能结论**:

- 在优化编译后，三者性能几乎相同
- 编译器会将它们优化为相同的机器码
- 选择时应优先考虑可读性和安全性

### 5.3 选择指南

```rust
fn main() {
    // ✅ 使用 if: 简单布尔条件
    let x = 5;
    if x > 0 {
        println!("正数");
    }
    
    // ✅ 使用 match: 多个分支或枚举
    enum Status {
        Active,
        Inactive,
        Pending,
    }
    let status = Status::Active;
    match status {
        Status::Active => println!("活跃"),
        Status::Inactive => println!("不活跃"),
        Status::Pending => println!("待定"),
    }
    
    // ✅ 使用 if let: 只关心一种情况
    let value = Some(10);
    if let Some(v) = value {
        println!("值: {}", v);
    }
    
    // ✅ 使用 let else: 需要提前返回
    fn process(value: Option<i32>) -> Result<(), String> {
        let Some(v) = value else {
            return Err("无值".to_string());
        };
        println!("处理: {}", v);
        Ok(())
    }
    
    let _ = process(value);
}
```

---

## 6. 实战案例

### 案例1: 配置解析器

```rust
#[derive(Debug)]
enum ConfigValue {
    String(String),
    Integer(i64),
    Boolean(bool),
    Array(Vec<ConfigValue>),
}

struct Config {
    values: std::collections::HashMap<String, ConfigValue>,
}

impl Config {
    fn new() -> Self {
        Config {
            values: std::collections::HashMap::new(),
        }
    }
    
    fn set(&mut self, key: String, value: ConfigValue) {
        self.values.insert(key, value);
    }
    
    fn get_string(&self, key: &str) -> Option<&str> {
        // 使用 if let 提取字符串
        if let Some(ConfigValue::String(s)) = self.values.get(key) {
            Some(s.as_str())
        } else {
            None
        }
    }
    
    fn get_integer(&self, key: &str) -> Option<i64> {
        // 使用 match 处理多种情况
        match self.values.get(key) {
            Some(ConfigValue::Integer(n)) => Some(*n),
            Some(ConfigValue::String(s)) => s.parse().ok(),
            _ => None,
        }
    }
    
    fn get_boolean(&self, key: &str) -> bool {
        // 使用 match 提供默认值
        match self.values.get(key) {
            Some(ConfigValue::Boolean(b)) => *b,
            Some(ConfigValue::String(s)) => {
                matches!(s.to_lowercase().as_str(), "true" | "yes" | "1")
            },
            Some(ConfigValue::Integer(n)) => *n != 0,
            _ => false,
        }
    }
}

fn main() {
    let mut config = Config::new();
    config.set("name".to_string(), ConfigValue::String("MyApp".to_string()));
    config.set("port".to_string(), ConfigValue::Integer(8080));
    config.set("debug".to_string(), ConfigValue::Boolean(true));
    
    println!("Name: {:?}", config.get_string("name"));
    println!("Port: {:?}", config.get_integer("port"));
    println!("Debug: {}", config.get_boolean("debug"));
}
```

### 案例2: HTTP状态码处理

```rust
#[derive(Debug, PartialEq)]
enum HttpStatus {
    Ok,
    Created,
    BadRequest,
    Unauthorized,
    NotFound,
    InternalServerError,
    Unknown(u16),
}

impl HttpStatus {
    fn from_code(code: u16) -> Self {
        match code {
            200 => HttpStatus::Ok,
            201 => HttpStatus::Created,
            400 => HttpStatus::BadRequest,
            401 => HttpStatus::Unauthorized,
            404 => HttpStatus::NotFound,
            500 => HttpStatus::InternalServerError,
            _ => HttpStatus::Unknown(code),
        }
    }
    
    fn is_success(&self) -> bool {
        match self {
            HttpStatus::Ok | HttpStatus::Created => true,
            _ => false,
        }
    }
    
    fn is_client_error(&self) -> bool {
        match self {
            HttpStatus::BadRequest 
            | HttpStatus::Unauthorized 
            | HttpStatus::NotFound => true,
            HttpStatus::Unknown(code) if (400..500).contains(code) => true,
            _ => false,
        }
    }
    
    fn message(&self) -> &'static str {
        match self {
            HttpStatus::Ok => "请求成功",
            HttpStatus::Created => "资源已创建",
            HttpStatus::BadRequest => "请求格式错误",
            HttpStatus::Unauthorized => "未授权",
            HttpStatus::NotFound => "资源未找到",
            HttpStatus::InternalServerError => "服务器内部错误",
            HttpStatus::Unknown(_) => "未知状态",
        }
    }
}

fn handle_response(status: HttpStatus, body: Option<String>) {
    // 使用 match 处理不同状态
    match status {
        HttpStatus::Ok => {
            if let Some(data) = body {
                println!("成功: {}", data);
            } else {
                println!("成功: 无响应体");
            }
        },
        HttpStatus::NotFound => {
            println!("错误: 资源不存在");
        },
        HttpStatus::Unauthorized => {
            println!("错误: 需要认证");
        },
        s if s.is_client_error() => {
            println!("客户端错误: {}", s.message());
        },
        HttpStatus::InternalServerError => {
            println!("服务器错误: {}", status.message());
        },
        _ => {
            println!("其他状态: {:?}", status);
        },
    }
}

fn main() {
    handle_response(HttpStatus::from_code(200), Some("OK".to_string()));
    handle_response(HttpStatus::from_code(404), None);
    handle_response(HttpStatus::from_code(500), None);
}
```

### 案例3: 命令行参数解析

```rust
#[derive(Debug)]
enum Command {
    Help,
    Version,
    Run { file: String, verbose: bool },
    Build { target: String, release: bool },
}

fn parse_args(args: &[String]) -> Result<Command, String> {
    // let else 提前返回
    let Some(cmd) = args.get(1) else {
        return Err("缺少命令".to_string());
    };
    
    // match 处理不同命令
    match cmd.as_str() {
        "help" | "-h" | "--help" => Ok(Command::Help),
        "version" | "-v" | "--version" => Ok(Command::Version),
        "run" => {
            let Some(file) = args.get(2) else {
                return Err("run命令需要指定文件".to_string());
            };
            
            let verbose = args.contains(&"--verbose".to_string());
            
            Ok(Command::Run {
                file: file.clone(),
                verbose,
            })
        },
        "build" => {
            let target = args.get(2)
                .map(|s| s.clone())
                .unwrap_or_else(|| "debug".to_string());
            
            let release = args.contains(&"--release".to_string());
            
            Ok(Command::Build { target, release })
        },
        _ => Err(format!("未知命令: {}", cmd)),
    }
}

fn execute_command(command: Command) {
    match command {
        Command::Help => {
            println!("使用方法:");
            println!("  help - 显示帮助");
            println!("  version - 显示版本");
            println!("  run <file> [--verbose] - 运行文件");
            println!("  build [target] [--release] - 构建项目");
        },
        Command::Version => {
            println!("版本 1.0.0");
        },
        Command::Run { file, verbose } => {
            if verbose {
                println!("详细模式：运行文件 {}", file);
            } else {
                println!("运行文件 {}", file);
            }
        },
        Command::Build { target, release } => {
            let mode = if release { "release" } else { "debug" };
            println!("构建目标 {} ({}模式)", target, mode);
        },
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    match parse_args(&args) {
        Ok(command) => execute_command(command),
        Err(err) => {
            eprintln!("错误: {}", err);
            eprintln!("使用 'help' 查看使用方法");
        },
    }
}
```

### 案例4: 状态机实现

```rust
#[derive(Debug, PartialEq)]
enum State {
    Idle,
    Running,
    Paused,
    Stopped,
}

#[derive(Debug)]
enum Event {
    Start,
    Pause,
    Resume,
    Stop,
}

struct StateMachine {
    state: State,
}

impl StateMachine {
    fn new() -> Self {
        StateMachine { state: State::Idle }
    }
    
    fn handle_event(&mut self, event: Event) -> Result<(), String> {
        // 使用嵌套 match 处理状态转换
        let new_state = match (&self.state, event) {
            // Idle 状态
            (State::Idle, Event::Start) => State::Running,
            (State::Idle, Event::Stop) => State::Stopped,
            
            // Running 状态
            (State::Running, Event::Pause) => State::Paused,
            (State::Running, Event::Stop) => State::Stopped,
            
            // Paused 状态
            (State::Paused, Event::Resume) => State::Running,
            (State::Paused, Event::Stop) => State::Stopped,
            
            // Stopped 状态（终止状态）
            (State::Stopped, _) => {
                return Err("已停止，无法接收事件".to_string());
            },
            
            // 无效转换
            (state, event) => {
                return Err(format!(
                    "无效状态转换: {:?} -> {:?}",
                    state, event
                ));
            },
        };
        
        println!("状态转换: {:?} -> {:?}", self.state, new_state);
        self.state = new_state;
        Ok(())
    }
    
    fn current_state(&self) -> &State {
        &self.state
    }
}

fn main() {
    let mut machine = StateMachine::new();
    
    assert_eq!(machine.current_state(), &State::Idle);
    
    machine.handle_event(Event::Start).unwrap();
    assert_eq!(machine.current_state(), &State::Running);
    
    machine.handle_event(Event::Pause).unwrap();
    assert_eq!(machine.current_state(), &State::Paused);
    
    machine.handle_event(Event::Resume).unwrap();
    assert_eq!(machine.current_state(), &State::Running);
    
    machine.handle_event(Event::Stop).unwrap();
    assert_eq!(machine.current_state(), &State::Stopped);
    
    // 尝试无效转换
    if let Err(err) = machine.handle_event(Event::Start) {
        println!("预期错误: {}", err);
    }
}
```

### 案例5: 表达式求值器

```rust
#[derive(Debug, Clone)]
enum Expr {
    Number(f64),
    Add(Box<Expr>, Box<Expr>),
    Sub(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
    Div(Box<Expr>, Box<Expr>),
}

fn eval(expr: &Expr) -> Result<f64, String> {
    // 使用 match 递归求值
    match expr {
        Expr::Number(n) => Ok(*n),
        
        Expr::Add(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l + r)
        },
        
        Expr::Sub(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l - r)
        },
        
        Expr::Mul(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l * r)
        },
        
        Expr::Div(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            
            // 检查除零
            if r == 0.0 {
                Err("除零错误".to_string())
            } else {
                Ok(l / r)
            }
        },
    }
}

fn optimize(expr: Expr) -> Expr {
    // 使用 match 进行编译时优化
    match expr {
        // 加法优化
        Expr::Add(left, right) => {
            let left = optimize(*left);
            let right = optimize(*right);
            
            match (&left, &right) {
                (Expr::Number(0.0), r) => r.clone(),
                (l, Expr::Number(0.0)) => l.clone(),
                (Expr::Number(a), Expr::Number(b)) => Expr::Number(a + b),
                _ => Expr::Add(Box::new(left), Box::new(right)),
            }
        },
        
        // 乘法优化
        Expr::Mul(left, right) => {
            let left = optimize(*left);
            let right = optimize(*right);
            
            match (&left, &right) {
                (Expr::Number(0.0), _) | (_, Expr::Number(0.0)) => Expr::Number(0.0),
                (Expr::Number(1.0), r) => r.clone(),
                (l, Expr::Number(1.0)) => l.clone(),
                (Expr::Number(a), Expr::Number(b)) => Expr::Number(a * b),
                _ => Expr::Mul(Box::new(left), Box::new(right)),
            }
        },
        
        // 其他表达式递归优化
        Expr::Sub(left, right) => {
            Expr::Sub(Box::new(optimize(*left)), Box::new(optimize(*right)))
        },
        Expr::Div(left, right) => {
            Expr::Div(Box::new(optimize(*left)), Box::new(optimize(*right)))
        },
        Expr::Number(n) => Expr::Number(n),
    }
}

fn main() {
    // (2 + 3) * 4
    let expr = Expr::Mul(
        Box::new(Expr::Add(
            Box::new(Expr::Number(2.0)),
            Box::new(Expr::Number(3.0)),
        )),
        Box::new(Expr::Number(4.0)),
    );
    
    println!("表达式: {:?}", expr);
    println!("结果: {:?}", eval(&expr));
    
    // 优化示例: 0 * x
    let expr2 = Expr::Mul(
        Box::new(Expr::Number(0.0)),
        Box::new(Expr::Add(
            Box::new(Expr::Number(10.0)),
            Box::new(Expr::Number(20.0)),
        )),
    );
    
    println!("\n优化前: {:?}", expr2);
    let optimized = optimize(expr2);
    println!("优化后: {:?}", optimized);
}
```

---

## 7. 常见陷阱

### 7.1 类型不一致

```rust
fn main() {
    let number = 5;
    
    // ❌ 错误：分支类型不一致
    // let result = if number > 0 {
    //     "positive"  // &str
    // } else {
    //     0  // i32
    // };
    
    // ✅ 正确：类型一致
    let result = if number > 0 {
        "positive"
    } else {
        "zero or negative"
    };
    
    println!("{}", result);
}
```

### 7.2 忘记 else 分支

```rust
fn main() {
    let number = 5;
    
    // ❌ 错误：作为表达式时必须有 else
    // let result = if number > 0 {
    //     "positive"
    // };
    
    // ✅ 正确：添加 else
    let result = if number > 0 {
        "positive"
    } else {
        "not positive"
    };
    
    // ✅ 正确：不作为表达式
    if number > 0 {
        println!("positive");
    }
    
    println!("{}", result);
}
```

### 7.3 不完整的 match

```rust
fn main() {
    enum Status {
        Active,
        Inactive,
    }
    
    let status = Status::Active;
    
    // ❌ 错误：未穷尽所有情况
    // match status {
    //     Status::Active => println!("活跃"),
    //     // 缺少 Inactive
    // }
    
    // ✅ 正确：穷尽所有情况
    match status {
        Status::Active => println!("活跃"),
        Status::Inactive => println!("不活跃"),
    }
}
```

### 7.4 过度嵌套

```rust
fn main() {
    let value1 = Some(5);
    let value2 = Some(10);
    let value3 = Some(15);
    
    // ❌ 不推荐：过度嵌套
    if let Some(v1) = value1 {
        if let Some(v2) = value2 {
            if let Some(v3) = value3 {
                println!("Sum: {}", v1 + v2 + v3);
            }
        }
    }
    
    // ✅ 推荐：提前返回
    let Some(v1) = value1 else { return };
    let Some(v2) = value2 else { return };
    let Some(v3) = value3 else { return };
    println!("Sum: {}", v1 + v2 + v3);
    
    // ✅ 推荐：使用方法链
    if let (Some(v1), Some(v2), Some(v3)) = (value1, value2, value3) {
        println!("Sum: {}", v1 + v2 + v3);
    }
}
```

---

## 8. 最佳实践

1. **优先使用 match 处理枚举**
2. **简单条件使用 if**
3. **单一模式匹配使用 if let**
4. **需要提前返回使用 let else**
5. **避免过度嵌套**
6. **利用编译器的完整性检查**
7. **保持分支类型一致**
8. **使用守卫条件简化逻辑**

---

## 9. 性能优化

1. **编译器优化**: 在 release 模式下，不同条件语句的性能差异很小
2. **避免重复计算**: 将复杂表达式结果缓存
3. **使用合适的数据结构**: 考虑使用 HashMap 替代大量的 if-else
4. **Profile 优先**: 先测量再优化

---

## 10. 小结

- if 表达式适合简单条件判断
- match 表达式提供强大的模式匹配能力
- if let 简化单一模式匹配
- let else 优雅处理提前返回
- 根据具体场景选择合适的条件语句

---

## 11. 延伸阅读

**内部文档**:

- [循环结构指南](./02_循环结构指南.md)
- [模式匹配指南](./04_模式匹配指南.md)
- [控制流参考](../tier_03_references/01_控制流参考.md)

**外部资源**:

- [Rust Book - Control Flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html)
- [Rust Reference - Expressions](https://doc.rust-lang.org/reference/expressions.html)
- [Rust by Example - Flow Control](https://doc.rust-lang.org/rust-by-example/flow_control.html)

---

## 12. 练习题

1. 编写一个函数，使用 match 判断一个数字是否是闰年
2. 使用 if let 处理嵌套的 `Option<Option<i32>>`
3. 实现一个简单的计算器，支持四则运算
4. 使用 let else 重构一个包含多层嵌套 if let 的函数
5. 设计一个状态机来模拟红绿灯控制系统

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🎯 掌握Rust条件语句，编写清晰简洁的控制逻辑！** 🦀✨
