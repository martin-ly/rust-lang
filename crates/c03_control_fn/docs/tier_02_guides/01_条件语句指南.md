# 2.1 æ¡ä»¶è¯­å¥æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚  
> **æ–‡æ¡£å®šä½**: ç³»ç»ŸåŒ–å­¦ä¹ Rustæ¡ä»¶è¯­å¥ï¼ŒæŒæ¡if/match/if letæ ¸å¿ƒç”¨æ³•  
> **å­¦ä¹ æ—¶é—´**: 1-2å¤©  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [2.1 æ¡ä»¶è¯­å¥æŒ‡å—](#21-æ¡ä»¶è¯­å¥æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. if è¡¨è¾¾å¼](#1-if-è¡¨è¾¾å¼)
    - [1.1 åŸºæœ¬è¯­æ³•](#11-åŸºæœ¬è¯­æ³•)
    - [1.2 if ä½œä¸ºè¡¨è¾¾å¼](#12-if-ä½œä¸ºè¡¨è¾¾å¼)
    - [1.3 å¤šé‡åˆ†æ”¯](#13-å¤šé‡åˆ†æ”¯)
    - [1.4 åµŒå¥— if](#14-åµŒå¥—-if)
    - [1.5 æœ€ä½³å®è·µ](#15-æœ€ä½³å®è·µ)
  - [2. match è¡¨è¾¾å¼](#2-match-è¡¨è¾¾å¼)
    - [2.1 åŸºæœ¬è¯­æ³•](#21-åŸºæœ¬è¯­æ³•)
    - [2.2 æ¨¡å¼åŒ¹é…åŸºç¡€](#22-æ¨¡å¼åŒ¹é…åŸºç¡€)
    - [2.3 å®ˆå«æ¡ä»¶](#23-å®ˆå«æ¡ä»¶)
    - [2.4 åŒ¹é…å¤šä¸ªå€¼](#24-åŒ¹é…å¤šä¸ªå€¼)
    - [2.5 ç»‘å®šæ¨¡å¼](#25-ç»‘å®šæ¨¡å¼)
    - [2.6 å®Œæ•´æ€§æ£€æŸ¥](#26-å®Œæ•´æ€§æ£€æŸ¥)
  - [3. if let è¡¨è¾¾å¼](#3-if-let-è¡¨è¾¾å¼)
    - [3.1 åŸºæœ¬ç”¨æ³•](#31-åŸºæœ¬ç”¨æ³•)
    - [3.2 é“¾å¼ if let (Rust 1.90+)](#32-é“¾å¼-if-let-rust-190)
    - [3.3 if let ä¸ else](#33-if-let-ä¸-else)
  - [4. let else è¯­å¥ (Rust 1.65+)](#4-let-else-è¯­å¥-rust-165)
    - [4.1 åŸºæœ¬è¯­æ³•](#41-åŸºæœ¬è¯­æ³•)
    - [4.2 ä½¿ç”¨åœºæ™¯](#42-ä½¿ç”¨åœºæ™¯)
    - [4.3 ä¸å…¶ä»–æ¨¡å¼çš„å¯¹æ¯”](#43-ä¸å…¶ä»–æ¨¡å¼çš„å¯¹æ¯”)
  - [5. æ¡ä»¶è¯­å¥å¯¹æ¯”](#5-æ¡ä»¶è¯­å¥å¯¹æ¯”)
    - [5.1 åŠŸèƒ½å¯¹æ¯”](#51-åŠŸèƒ½å¯¹æ¯”)
    - [5.2 æ€§èƒ½å¯¹æ¯”](#52-æ€§èƒ½å¯¹æ¯”)
    - [5.3 é€‰æ‹©æŒ‡å—](#53-é€‰æ‹©æŒ‡å—)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: é…ç½®è§£æå™¨](#æ¡ˆä¾‹1-é…ç½®è§£æå™¨)
    - [æ¡ˆä¾‹2: HTTPçŠ¶æ€ç å¤„ç†](#æ¡ˆä¾‹2-httpçŠ¶æ€ç å¤„ç†)
    - [æ¡ˆä¾‹3: å‘½ä»¤è¡Œå‚æ•°è§£æ](#æ¡ˆä¾‹3-å‘½ä»¤è¡Œå‚æ•°è§£æ)
    - [æ¡ˆä¾‹4: çŠ¶æ€æœºå®ç°](#æ¡ˆä¾‹4-çŠ¶æ€æœºå®ç°)
    - [æ¡ˆä¾‹5: è¡¨è¾¾å¼æ±‚å€¼å™¨](#æ¡ˆä¾‹5-è¡¨è¾¾å¼æ±‚å€¼å™¨)
  - [7. å¸¸è§é™·é˜±](#7-å¸¸è§é™·é˜±)
    - [7.1 ç±»å‹ä¸ä¸€è‡´](#71-ç±»å‹ä¸ä¸€è‡´)
    - [7.2 å¿˜è®° else åˆ†æ”¯](#72-å¿˜è®°-else-åˆ†æ”¯)
    - [7.3 ä¸å®Œæ•´çš„ match](#73-ä¸å®Œæ•´çš„-match)
    - [7.4 è¿‡åº¦åµŒå¥—](#74-è¿‡åº¦åµŒå¥—)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
  - [9. æ€§èƒ½ä¼˜åŒ–](#9-æ€§èƒ½ä¼˜åŒ–)
  - [10. å°ç»“](#10-å°ç»“)
  - [11. å»¶ä¼¸é˜…è¯»](#11-å»¶ä¼¸é˜…è¯»)
  - [12. ç»ƒä¹ é¢˜](#12-ç»ƒä¹ é¢˜)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… æŒæ¡ if/else è¡¨è¾¾å¼çš„ä½¿ç”¨
- âœ… ç†è§£ match è¡¨è¾¾å¼çš„æ¨¡å¼åŒ¹é…
- âœ… ç†Ÿç»ƒä½¿ç”¨ if let ç®€åŒ–ä»£ç 
- âœ… åº”ç”¨ let else å¤„ç†é”™è¯¯æƒ…å†µ
- âœ… æ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚çš„æ¡ä»¶è¯­å¥
- âœ… é¿å…å¸¸è§é™·é˜±ï¼Œç¼–å†™é«˜è´¨é‡ä»£ç 

---

## 1. if è¡¨è¾¾å¼

### 1.1 åŸºæœ¬è¯­æ³•

if è¡¨è¾¾å¼æ˜¯ Rust ä¸­æœ€åŸºæœ¬çš„æ¡ä»¶è¯­å¥ï¼š

```rust
fn main() {
    let number = 5;
    
    // åŸºæœ¬ if
    if number < 10 {
        println!("æ•°å­—å°äº10");
    }
    
    // if-else
    if number < 0 {
        println!("è´Ÿæ•°");
    } else {
        println!("éè´Ÿæ•°");
    }
    
    // if-else if-else
    if number < 0 {
        println!("è´Ÿæ•°");
    } else if number == 0 {
        println!("é›¶");
    } else {
        println!("æ­£æ•°");
    }
}
```

**å…³é”®è¦ç‚¹**:

- æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»æ˜¯ `bool` ç±»å‹
- ä¸éœ€è¦æ‹¬å·åŒ…å›´æ¡ä»¶ï¼ˆä½†å¯ä»¥åŠ ï¼‰
- ä»£ç å—å¿…é¡»ç”¨èŠ±æ‹¬å· `{}` åŒ…å›´

### 1.2 if ä½œä¸ºè¡¨è¾¾å¼

åœ¨ Rust ä¸­ï¼Œif æ˜¯è¡¨è¾¾å¼ï¼Œå¯ä»¥è¿”å›å€¼ï¼š

```rust
fn main() {
    let number = 5;
    
    // if è¡¨è¾¾å¼èµ‹å€¼
    let description = if number < 10 {
        "å°äº10"
    } else {
        "å¤§äºç­‰äº10"
    };
    
    println!("æ•°å­—{}: {}", number, description);
    
    // åœ¨å‡½æ•°ä¸­è¿”å›
    let result = classify_number(15);
    println!("åˆ†ç±»: {}", result);
}

fn classify_number(n: i32) -> &'static str {
    if n < 0 {
        "è´Ÿæ•°"
    } else if n == 0 {
        "é›¶"
    } else if n < 10 {
        "ä¸ªä½æ•°"
    } else if n < 100 {
        "ä¸¤ä½æ•°"
    } else {
        "ä¸‰ä½æ•°æˆ–æ›´å¤§"
    }
}
```

**å…³é”®è¦ç‚¹**:

- æ‰€æœ‰åˆ†æ”¯å¿…é¡»è¿”å›ç›¸åŒç±»å‹
- æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä¸åŠ åˆ†å·
- å¦‚æœä½œä¸ºè¡¨è¾¾å¼ä½¿ç”¨ï¼Œå¿…é¡»æœ‰ else åˆ†æ”¯

### 1.3 å¤šé‡åˆ†æ”¯

å¤„ç†å¤šä¸ªæ¡ä»¶æ—¶çš„æ¨¡å¼ï¼š

```rust
fn main() {
    let score = 85;
    
    // æ–¹å¼1: if-else if é“¾
    let grade = if score >= 90 {
        'A'
    } else if score >= 80 {
        'B'
    } else if score >= 70 {
        'C'
    } else if score >= 60 {
        'D'
    } else {
        'F'
    };
    
    println!("åˆ†æ•° {} å¯¹åº”ç­‰çº§ {}", score, grade);
    
    // æ–¹å¼2: åµŒå¥— ifï¼ˆä¸æ¨èï¼‰
    let grade2 = if score >= 60 {
        if score >= 70 {
            if score >= 80 {
                if score >= 90 {
                    'A'
                } else {
                    'B'
                }
            } else {
                'C'
            }
        } else {
            'D'
        }
    } else {
        'F'
    };
    
    // æ–¹å¼3: ä½¿ç”¨èŒƒå›´æ¨¡å¼çš„ matchï¼ˆæ¨èï¼‰
    let grade3 = match score {
        90..=100 => 'A',
        80..=89 => 'B',
        70..=79 => 'C',
        60..=69 => 'D',
        _ => 'F',
    };
    
    println!("grade: {}, grade2: {}, grade3: {}", grade, grade2, grade3);
}
```

### 1.4 åµŒå¥— if

æœ‰æ—¶éœ€è¦åµŒå¥—ä½¿ç”¨ ifï¼š

```rust
fn main() {
    let age = 25;
    let has_license = true;
    let is_sober = true;
    
    // åµŒå¥— if
    if age >= 18 {
        if has_license {
            if is_sober {
                println!("å¯ä»¥é©¾é©¶");
            } else {
                println!("é…’åä¸èƒ½é©¾é©¶");
            }
        } else {
            println!("éœ€è¦é©¾ç…§");
        }
    } else {
        println!("å¹´é¾„ä¸å¤Ÿ");
    }
    
    // ä½¿ç”¨é€»è¾‘è¿ç®—ç¬¦ç®€åŒ–ï¼ˆæ¨èï¼‰
    if age >= 18 && has_license && is_sober {
        println!("å¯ä»¥é©¾é©¶");
    } else if age < 18 {
        println!("å¹´é¾„ä¸å¤Ÿ");
    } else if !has_license {
        println!("éœ€è¦é©¾ç…§");
    } else {
        println!("é…’åä¸èƒ½é©¾é©¶");
    }
    
    // æ—©æœŸè¿”å›æ¨¡å¼ï¼ˆå‡½æ•°ä¸­æ¨èï¼‰
    check_driving_eligibility(age, has_license, is_sober);
}

fn check_driving_eligibility(age: u32, has_license: bool, is_sober: bool) {
    if age < 18 {
        println!("å¹´é¾„ä¸å¤Ÿ");
        return;
    }
    
    if !has_license {
        println!("éœ€è¦é©¾ç…§");
        return;
    }
    
    if !is_sober {
        println!("é…’åä¸èƒ½é©¾é©¶");
        return;
    }
    
    println!("å¯ä»¥é©¾é©¶");
}
```

### 1.5 æœ€ä½³å®è·µ

```rust
fn main() {
    let value = Some(42);
    
    // âŒ ä¸æ¨èï¼šè¿‡åº¦åµŒå¥—
    if value.is_some() {
        if value.unwrap() > 0 {
            if value.unwrap() < 100 {
                println!("å€¼åœ¨èŒƒå›´å†…");
            }
        }
    }
    
    // âœ… æ¨èï¼šä½¿ç”¨ if let
    if let Some(v) = value {
        if v > 0 && v < 100 {
            println!("å€¼åœ¨èŒƒå›´å†…");
        }
    }
    
    // âœ… æ¨èï¼šé“¾å¼æ¡ä»¶
    if let Some(v) = value {
        if (1..100).contains(&v) {
            println!("å€¼åœ¨èŒƒå›´å†…");
        }
    }
}
```

---

## 2. match è¡¨è¾¾å¼

### 2.1 åŸºæœ¬è¯­æ³•

match æ˜¯ Rust ä¸­æœ€å¼ºå¤§çš„æ¡ä»¶è¯­å¥ï¼š

```rust
fn main() {
    let number = 3;
    
    // åŸºæœ¬ match
    match number {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        4 => println!("å››"),
        5 => println!("äº”"),
        _ => println!("å…¶ä»–"),
    }
    
    // match è¡¨è¾¾å¼
    let chinese = match number {
        1 => "ä¸€",
        2 => "äºŒ",
        3 => "ä¸‰",
        4 => "å››",
        5 => "äº”",
        _ => "å…¶ä»–",
    };
    
    println!("æ•°å­— {} çš„ä¸­æ–‡æ˜¯ {}", number, chinese);
    
    // å¤šè¡Œä»£ç å—
    let result = match number {
        1 => {
            println!("åŒ¹é…åˆ°1");
            "ä¸€"
        },
        2 => {
            println!("åŒ¹é…åˆ°2");
            "äºŒ"
        },
        _ => {
            println!("åŒ¹é…åˆ°å…¶ä»–");
            "å…¶ä»–"
        },
    };
    
    println!("ç»“æœ: {}", result);
}
```

### 2.2 æ¨¡å¼åŒ¹é…åŸºç¡€

match æ”¯æŒå¤šç§æ¨¡å¼ï¼š

```rust
fn main() {
    // å­—é¢é‡æ¨¡å¼
    let x = 1;
    match x {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        _ => println!("å…¶ä»–"),
    }
    
    // èŒƒå›´æ¨¡å¼
    let age = 25;
    match age {
        0..=12 => println!("å„¿ç«¥"),
        13..=19 => println!("é’å°‘å¹´"),
        20..=59 => println!("æˆå¹´äºº"),
        60.. => println!("è€å¹´äºº"),
    }
    
    // å¤šä¸ªå€¼
    let day = 3;
    match day {
        1 | 2 | 3 | 4 | 5 => println!("å·¥ä½œæ—¥"),
        6 | 7 => println!("å‘¨æœ«"),
        _ => println!("æ— æ•ˆçš„æ—¥æœŸ"),
    }
    
    // æšä¸¾åŒ¹é…
    enum Direction {
        North,
        South,
        East,
        West,
    }
    
    let dir = Direction::North;
    match dir {
        Direction::North => println!("å‘åŒ—"),
        Direction::South => println!("å‘å—"),
        Direction::East => println!("å‘ä¸œ"),
        Direction::West => println!("å‘è¥¿"),
    }
    
    // Option åŒ¹é…
    let optional = Some(5);
    match optional {
        Some(value) => println!("æœ‰å€¼: {}", value),
        None => println!("æ— å€¼"),
    }
    
    // Result åŒ¹é…
    let result: Result<i32, &str> = Ok(42);
    match result {
        Ok(value) => println!("æˆåŠŸ: {}", value),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
}
```

### 2.3 å®ˆå«æ¡ä»¶

ä½¿ç”¨ if æ·»åŠ é¢å¤–çš„æ¡ä»¶ï¼š

```rust
fn main() {
    let number = 4;
    
    match number {
        n if n < 0 => println!("{} æ˜¯è´Ÿæ•°", n),
        n if n == 0 => println!("é›¶"),
        n if n % 2 == 0 => println!("{} æ˜¯æ­£å¶æ•°", n),
        n => println!("{} æ˜¯æ­£å¥‡æ•°", n),
    }
    
    // å¤æ‚å®ˆå«
    let point = (0, 5);
    match point {
        (x, y) if x == 0 && y == 0 => println!("åŸç‚¹"),
        (x, 0) if x != 0 => println!("åœ¨xè½´ä¸Š"),
        (0, y) if y != 0 => println!("åœ¨yè½´ä¸Š"),
        (x, y) if x == y => println!("åœ¨y=xçº¿ä¸Š"),
        (x, y) if x == -y => println!("åœ¨y=-xçº¿ä¸Š"),
        _ => println!("ä¸€èˆ¬ç‚¹"),
    }
    
    // ç»“åˆæšä¸¾
    enum Message {
        Text(String),
        Number(i32),
    }
    
    let msg = Message::Number(42);
    match msg {
        Message::Text(s) if s.len() > 10 => {
            println!("é•¿æ–‡æœ¬: {}", s);
        },
        Message::Text(s) => {
            println!("çŸ­æ–‡æœ¬: {}", s);
        },
        Message::Number(n) if n < 0 => {
            println!("è´Ÿæ•°: {}", n);
        },
        Message::Number(n) => {
            println!("éè´Ÿæ•°: {}", n);
        },
    }
}
```

### 2.4 åŒ¹é…å¤šä¸ªå€¼

```rust
fn main() {
    // ä½¿ç”¨ | åŒ¹é…å¤šä¸ªå€¼
    let number = 2;
    match number {
        1 | 2 | 3 => println!("å°æ•°å­—"),
        4 | 5 | 6 => println!("ä¸­ç­‰æ•°å­—"),
        7 | 8 | 9 => println!("å¤§æ•°å­—"),
        _ => println!("å…¶ä»–æ•°å­—"),
    }
    
    // ç»“åˆèŒƒå›´
    let value = 45;
    match value {
        0..=10 | 90..=100 => println!("è¾¹ç•Œå€¼"),
        11..=89 => println!("ä¸­é—´å€¼"),
        _ => println!("å…¶ä»–"),
    }
    
    // å…ƒç»„åŒ¹é…
    let pair = (2, 3);
    match pair {
        (1, 1) | (2, 2) | (3, 3) => println!("ç›¸åŒçš„æ•°å­—"),
        (1, 2) | (2, 1) => println!("1å’Œ2"),
        (_, 3) | (3, _) => println!("åŒ…å«3"),
        _ => println!("å…¶ä»–ç»„åˆ"),
    }
}
```

### 2.5 ç»‘å®šæ¨¡å¼

ä½¿ç”¨ @ ç»‘å®šå€¼ï¼š

```rust
fn main() {
    let number = 15;
    
    // @ ç»‘å®š
    match number {
        n @ 1..=10 => println!("{} åœ¨1åˆ°10ä¹‹é—´", n),
        n @ 11..=20 => println!("{} åœ¨11åˆ°20ä¹‹é—´", n),
        n => println!("{} ä¸åœ¨1åˆ°20ä¹‹é—´", n),
    }
    
    // ç»“åˆå®ˆå«
    match number {
        n @ 1..=100 if n % 2 == 0 => {
            println!("{} æ˜¯1åˆ°100ä¹‹é—´çš„å¶æ•°", n);
        },
        n @ 1..=100 => {
            println!("{} æ˜¯1åˆ°100ä¹‹é—´çš„å¥‡æ•°", n);
        },
        n => {
            println!("{} ä¸åœ¨1åˆ°100ä¹‹é—´", n);
        },
    }
    
    // ç»“æ„ä½“ç»‘å®š
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 5, y: 10 };
    match point {
        Point { x: 0, y: 0 } => println!("åŸç‚¹"),
        Point { x: 0, y } => println!("åœ¨yè½´ä¸Šï¼Œy={}", y),
        Point { x, y: 0 } => println!("åœ¨xè½´ä¸Šï¼Œx={}", x),
        Point { x, y } if x == y => println!("åœ¨å¯¹è§’çº¿ä¸Šï¼Œx=y={}", x),
        p @ Point { x: 1..=5, y: 1..=5 } => {
            println!("åœ¨å°æ–¹æ ¼å†…: ({}, {})", p.x, p.y);
        },
        Point { x, y } => println!("ä¸€èˆ¬ç‚¹: ({}, {})", x, y),
    }
}
```

### 2.6 å®Œæ•´æ€§æ£€æŸ¥

Rust è¦æ±‚ match å¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½ï¼š

```rust
fn main() {
    enum Color {
        Red,
        Green,
        Blue,
    }
    
    let color = Color::Red;
    
    // âŒ ç¼–è¯‘é”™è¯¯ï¼šæœªè¦†ç›–æ‰€æœ‰æƒ…å†µ
    // match color {
    //     Color::Red => println!("çº¢è‰²"),
    //     Color::Green => println!("ç»¿è‰²"),
    //     // ç¼ºå°‘ Blue
    // }
    
    // âœ… æ­£ç¡®ï¼šè¦†ç›–æ‰€æœ‰æƒ…å†µ
    match color {
        Color::Red => println!("çº¢è‰²"),
        Color::Green => println!("ç»¿è‰²"),
        Color::Blue => println!("è“è‰²"),
    }
    
    // âœ… æ­£ç¡®ï¼šä½¿ç”¨é€šé…ç¬¦
    match color {
        Color::Red => println!("çº¢è‰²"),
        _ => println!("å…¶ä»–é¢œè‰²"),
    }
    
    // Option å¿…é¡»å¤„ç† None
    let value: Option<i32> = Some(5);
    
    // âœ… å®Œæ•´åŒ¹é…
    match value {
        Some(v) => println!("å€¼: {}", v),
        None => println!("æ— å€¼"),
    }
    
    // Result å¿…é¡»å¤„ç† Err
    let result: Result<i32, &str> = Ok(10);
    
    // âœ… å®Œæ•´åŒ¹é…
    match result {
        Ok(v) => println!("æˆåŠŸ: {}", v),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

---

## 3. if let è¡¨è¾¾å¼

### 3.1 åŸºæœ¬ç”¨æ³•

if let æ˜¯ match çš„è¯­æ³•ç³–ï¼Œç”¨äºåªå…³å¿ƒä¸€ç§æƒ…å†µï¼š

```rust
fn main() {
    let some_value = Some(3);
    
    // ä½¿ç”¨ matchï¼ˆç¹çï¼‰
    match some_value {
        Some(3) => println!("ä¸‰"),
        _ => (),
    }
    
    // ä½¿ç”¨ if letï¼ˆç®€æ´ï¼‰
    if let Some(3) = some_value {
        println!("ä¸‰");
    }
    
    // ç»‘å®šå€¼
    if let Some(value) = some_value {
        println!("å€¼æ˜¯: {}", value);
    }
    
    // å¸¦ else
    if let Some(value) = some_value {
        println!("æœ‰å€¼: {}", value);
    } else {
        println!("æ— å€¼");
    }
    
    // Result å¤„ç†
    let result: Result<i32, &str> = Ok(42);
    if let Ok(value) = result {
        println!("æˆåŠŸ: {}", value);
    } else {
        println!("å¤±è´¥");
    }
}
```

### 3.2 é“¾å¼ if let (Rust 1.90+)

Rust 1.90 å¼•å…¥äº†é“¾å¼ if letï¼š

```rust
fn main() {
    let value = Some(10);
    
    // æ—§æ–¹å¼ï¼šåµŒå¥—
    if let Some(v) = value {
        if v > 5 {
            println!("å¤§äº5");
        }
    }
    
    // Rust 1.90+: é“¾å¼ if let
    if let Some(v) = value && v > 5 {
        println!("å¤§äº5");
    }
    
    // å¤šä¸ªæ¡ä»¶
    let result: Result<i32, &str> = Ok(20);
    if let Ok(v) = result && v > 10 && v < 30 {
        println!("å€¼åœ¨10åˆ°30ä¹‹é—´: {}", v);
    }
    
    // å¤æ‚ç¤ºä¾‹
    struct Config {
        enabled: bool,
        value: Option<i32>,
    }
    
    let config = Config {
        enabled: true,
        value: Some(15),
    };
    
    // é“¾å¼æ¡ä»¶
    if config.enabled && let Some(v) = config.value && v > 10 {
        println!("é…ç½®å¯ç”¨ä¸”å€¼å¤§äº10: {}", v);
    }
}
```

### 3.3 if let ä¸ else

```rust
fn main() {
    let value = Some(5);
    
    // if let-else
    if let Some(v) = value {
        println!("æœ‰å€¼: {}", v);
    } else {
        println!("æ— å€¼");
    }
    
    // if let-else if-else
    if let Some(v) = value {
        if v > 10 {
            println!("å¤§äº10");
        } else {
            println!("ä¸å¤§äº10");
        }
    } else {
        println!("æ— å€¼");
    }
    
    // if let-else if let
    enum Message {
        Text(String),
        Number(i32),
        None,
    }
    
    let msg = Message::Number(42);
    
    if let Message::Text(s) = msg {
        println!("æ–‡æœ¬: {}", s);
    } else if let Message::Number(n) = msg {
        println!("æ•°å­—: {}", n);
    } else {
        println!("æ— æ¶ˆæ¯");
    }
}
```

---

## 4. let else è¯­å¥ (Rust 1.65+)

### 4.1 åŸºæœ¬è¯­æ³•

let else ç”¨äºåœ¨æ¨¡å¼ä¸åŒ¹é…æ—¶æå‰è¿”å›ï¼š

```rust
fn main() {
    let config = Some("config.toml");
    
    // ä¼ ç»Ÿæ–¹å¼
    let config_file = if let Some(file) = config {
        file
    } else {
        return;
    };
    
    println!("é…ç½®æ–‡ä»¶: {}", config_file);
}

fn process_value(value: Option<i32>) {
    // let else æ–¹å¼
    let Some(v) = value else {
        println!("æ— å€¼ï¼Œæå‰è¿”å›");
        return;
    };
    
    println!("å¤„ç†å€¼: {}", v);
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    // let else ç”¨äº Result
    let Ok(()) = check_divisor(b) else {
        return Err("é™¤æ•°æ— æ•ˆ".to_string());
    };
    
    Ok(a / b)
}

fn check_divisor(b: i32) -> Result<(), String> {
    if b == 0 {
        Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
    } else {
        Ok(())
    }
}
```

### 4.2 ä½¿ç”¨åœºæ™¯

let else é€‚åˆæ—©æœŸè¿”å›çš„åœºæ™¯ï¼š

```rust
fn parse_config(config: Option<&str>) -> Result<(), String> {
    // æ£€æŸ¥é…ç½®å­˜åœ¨
    let Some(cfg) = config else {
        return Err("é…ç½®ä¸å­˜åœ¨".to_string());
    };
    
    // æ£€æŸ¥é…ç½®éç©º
    let true = !cfg.is_empty() else {
        return Err("é…ç½®ä¸ºç©º".to_string());
    };
    
    println!("é…ç½®: {}", cfg);
    Ok(())
}

fn process_user(user_id: Option<u32>, name: Option<String>) -> Result<(), String> {
    // å¤šä¸ªæ£€æŸ¥
    let Some(id) = user_id else {
        return Err("ç”¨æˆ·IDç¼ºå¤±".to_string());
    };
    
    let Some(n) = name else {
        return Err("ç”¨æˆ·åç¼ºå¤±".to_string());
    };
    
    println!("ç”¨æˆ· {} (ID: {})", n, id);
    Ok(())
}

fn validate_input(input: Result<String, String>) -> Result<String, String> {
    // Result è§£æ„
    let Ok(value) = input else {
        return Err("è¾“å…¥æ— æ•ˆ".to_string());
    };
    
    let true = value.len() > 0 else {
        return Err("è¾“å…¥ä¸ºç©º".to_string());
    };
    
    Ok(value)
}

fn main() {
    process_value(Some(42));
    process_value(None);
    
    let _ = parse_config(Some("config.toml"));
    let _ = parse_config(None);
    
    let _ = process_user(Some(1), Some("Alice".to_string()));
    let _ = process_user(None, Some("Bob".to_string()));
}
```

### 4.3 ä¸å…¶ä»–æ¨¡å¼çš„å¯¹æ¯”

```rust
fn main() {
    let value = Some(10);
    
    // æ–¹å¼1: unwrap_or (ç®€å•é»˜è®¤å€¼)
    let v1 = value.unwrap_or(0);
    println!("v1: {}", v1);
    
    // æ–¹å¼2: if let (éœ€è¦ä½¿ç”¨å€¼)
    if let Some(v) = value {
        println!("v2: {}", v);
    } else {
        println!("æ— å€¼");
        return;
    }
    
    // æ–¹å¼3: match (å¤šç§æƒ…å†µ)
    let v3 = match value {
        Some(v) => v,
        None => {
            println!("æ— å€¼");
            return;
        }
    };
    println!("v3: {}", v3);
    
    // æ–¹å¼4: let else (æå‰è¿”å›ï¼Œæ¨è)
    let Some(v4) = value else {
        println!("æ— å€¼");
        return;
    };
    println!("v4: {}", v4);
}
```

---

## 5. æ¡ä»¶è¯­å¥å¯¹æ¯”

### 5.1 åŠŸèƒ½å¯¹æ¯”

| ç‰¹æ€§ | if | match | if let | let else |
|------|----|----|--------|----------|
| **ç®€å•æ¡ä»¶** | âœ… æœ€ä½³ | âŒ è¿‡äºå¤æ‚ | âŒ ä¸é€‚ç”¨ | âŒ ä¸é€‚ç”¨ |
| **å¤šä¸ªåˆ†æ”¯** | âš ï¸ å¯ä»¥ä½†ç¹ç | âœ… æœ€ä½³ | âŒ ä¸é€‚ç”¨ | âŒ ä¸é€‚ç”¨ |
| **æ¨¡å¼åŒ¹é…** | âŒ ä¸æ”¯æŒ | âœ… æœ€ä½³ | âœ… å•ä¸€æ¨¡å¼ | âœ… æ—©æœŸè¿”å› |
| **Optionå¤„ç†** | âš ï¸ éœ€è¦is_some | âœ… å®Œæ•´ | âœ… ç®€æ´ | âœ… æå‰è¿”å› |
| **Resultå¤„ç†** | âš ï¸ éœ€è¦is_ok | âœ… å®Œæ•´ | âœ… ç®€æ´ | âœ… æå‰è¿”å› |
| **å®ˆå«æ¡ä»¶** | âœ… && è¿ç®—ç¬¦ | âœ… if å®ˆå« | âœ… && è¿ç®—ç¬¦ | âŒ ä¸æ”¯æŒ |
| **å®Œæ•´æ€§æ£€æŸ¥** | âŒ ç¼–è¯‘å™¨ä¸æ£€æŸ¥ | âœ… å¼ºåˆ¶ç©·å°½ | âŒ ä¸æ£€æŸ¥ | âŒ ä¸æ£€æŸ¥ |
| **æ—©æœŸè¿”å›** | âš ï¸ éœ€è¦åµŒå¥— | âš ï¸ éœ€è¦åµŒå¥— | âš ï¸ éœ€è¦åµŒå¥— | âœ… æœ€ä½³ |

### 5.2 æ€§èƒ½å¯¹æ¯”

```rust
use std::time::Instant;

fn benchmark() {
    let iterations = 10_000_000;
    let value = Some(42);
    
    // if-else æ€§èƒ½
    let start = Instant::now();
    for _ in 0..iterations {
        let _result = if value.is_some() {
            value.unwrap()
        } else {
            0
        };
    }
    println!("if-else: {:?}", start.elapsed());
    
    // match æ€§èƒ½
    let start = Instant::now();
    for _ in 0..iterations {
        let _result = match value {
            Some(v) => v,
            None => 0,
        };
    }
    println!("match: {:?}", start.elapsed());
    
    // if let æ€§èƒ½
    let start = Instant::now();
    for _ in 0..iterations {
        let _result = if let Some(v) = value {
            v
        } else {
            0
        };
    }
    println!("if let: {:?}", start.elapsed());
}

fn main() {
    benchmark();
}
```

**æ€§èƒ½ç»“è®º**:

- åœ¨ä¼˜åŒ–ç¼–è¯‘åï¼Œä¸‰è€…æ€§èƒ½å‡ ä¹ç›¸åŒ
- ç¼–è¯‘å™¨ä¼šå°†å®ƒä»¬ä¼˜åŒ–ä¸ºç›¸åŒçš„æœºå™¨ç 
- é€‰æ‹©æ—¶åº”ä¼˜å…ˆè€ƒè™‘å¯è¯»æ€§å’Œå®‰å…¨æ€§

### 5.3 é€‰æ‹©æŒ‡å—

```rust
fn main() {
    // âœ… ä½¿ç”¨ if: ç®€å•å¸ƒå°”æ¡ä»¶
    let x = 5;
    if x > 0 {
        println!("æ­£æ•°");
    }
    
    // âœ… ä½¿ç”¨ match: å¤šä¸ªåˆ†æ”¯æˆ–æšä¸¾
    enum Status {
        Active,
        Inactive,
        Pending,
    }
    let status = Status::Active;
    match status {
        Status::Active => println!("æ´»è·ƒ"),
        Status::Inactive => println!("ä¸æ´»è·ƒ"),
        Status::Pending => println!("å¾…å®š"),
    }
    
    // âœ… ä½¿ç”¨ if let: åªå…³å¿ƒä¸€ç§æƒ…å†µ
    let value = Some(10);
    if let Some(v) = value {
        println!("å€¼: {}", v);
    }
    
    // âœ… ä½¿ç”¨ let else: éœ€è¦æå‰è¿”å›
    fn process(value: Option<i32>) -> Result<(), String> {
        let Some(v) = value else {
            return Err("æ— å€¼".to_string());
        };
        println!("å¤„ç†: {}", v);
        Ok(())
    }
    
    let _ = process(value);
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: é…ç½®è§£æå™¨

```rust
#[derive(Debug)]
enum ConfigValue {
    String(String),
    Integer(i64),
    Boolean(bool),
    Array(Vec<ConfigValue>),
}

struct Config {
    values: std::collections::HashMap<String, ConfigValue>,
}

impl Config {
    fn new() -> Self {
        Config {
            values: std::collections::HashMap::new(),
        }
    }
    
    fn set(&mut self, key: String, value: ConfigValue) {
        self.values.insert(key, value);
    }
    
    fn get_string(&self, key: &str) -> Option<&str> {
        // ä½¿ç”¨ if let æå–å­—ç¬¦ä¸²
        if let Some(ConfigValue::String(s)) = self.values.get(key) {
            Some(s.as_str())
        } else {
            None
        }
    }
    
    fn get_integer(&self, key: &str) -> Option<i64> {
        // ä½¿ç”¨ match å¤„ç†å¤šç§æƒ…å†µ
        match self.values.get(key) {
            Some(ConfigValue::Integer(n)) => Some(*n),
            Some(ConfigValue::String(s)) => s.parse().ok(),
            _ => None,
        }
    }
    
    fn get_boolean(&self, key: &str) -> bool {
        // ä½¿ç”¨ match æä¾›é»˜è®¤å€¼
        match self.values.get(key) {
            Some(ConfigValue::Boolean(b)) => *b,
            Some(ConfigValue::String(s)) => {
                matches!(s.to_lowercase().as_str(), "true" | "yes" | "1")
            },
            Some(ConfigValue::Integer(n)) => *n != 0,
            _ => false,
        }
    }
}

fn main() {
    let mut config = Config::new();
    config.set("name".to_string(), ConfigValue::String("MyApp".to_string()));
    config.set("port".to_string(), ConfigValue::Integer(8080));
    config.set("debug".to_string(), ConfigValue::Boolean(true));
    
    println!("Name: {:?}", config.get_string("name"));
    println!("Port: {:?}", config.get_integer("port"));
    println!("Debug: {}", config.get_boolean("debug"));
}
```

### æ¡ˆä¾‹2: HTTPçŠ¶æ€ç å¤„ç†

```rust
#[derive(Debug, PartialEq)]
enum HttpStatus {
    Ok,
    Created,
    BadRequest,
    Unauthorized,
    NotFound,
    InternalServerError,
    Unknown(u16),
}

impl HttpStatus {
    fn from_code(code: u16) -> Self {
        match code {
            200 => HttpStatus::Ok,
            201 => HttpStatus::Created,
            400 => HttpStatus::BadRequest,
            401 => HttpStatus::Unauthorized,
            404 => HttpStatus::NotFound,
            500 => HttpStatus::InternalServerError,
            _ => HttpStatus::Unknown(code),
        }
    }
    
    fn is_success(&self) -> bool {
        match self {
            HttpStatus::Ok | HttpStatus::Created => true,
            _ => false,
        }
    }
    
    fn is_client_error(&self) -> bool {
        match self {
            HttpStatus::BadRequest 
            | HttpStatus::Unauthorized 
            | HttpStatus::NotFound => true,
            HttpStatus::Unknown(code) if (400..500).contains(code) => true,
            _ => false,
        }
    }
    
    fn message(&self) -> &'static str {
        match self {
            HttpStatus::Ok => "è¯·æ±‚æˆåŠŸ",
            HttpStatus::Created => "èµ„æºå·²åˆ›å»º",
            HttpStatus::BadRequest => "è¯·æ±‚æ ¼å¼é”™è¯¯",
            HttpStatus::Unauthorized => "æœªæˆæƒ",
            HttpStatus::NotFound => "èµ„æºæœªæ‰¾åˆ°",
            HttpStatus::InternalServerError => "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯",
            HttpStatus::Unknown(_) => "æœªçŸ¥çŠ¶æ€",
        }
    }
}

fn handle_response(status: HttpStatus, body: Option<String>) {
    // ä½¿ç”¨ match å¤„ç†ä¸åŒçŠ¶æ€
    match status {
        HttpStatus::Ok => {
            if let Some(data) = body {
                println!("æˆåŠŸ: {}", data);
            } else {
                println!("æˆåŠŸ: æ— å“åº”ä½“");
            }
        },
        HttpStatus::NotFound => {
            println!("é”™è¯¯: èµ„æºä¸å­˜åœ¨");
        },
        HttpStatus::Unauthorized => {
            println!("é”™è¯¯: éœ€è¦è®¤è¯");
        },
        s if s.is_client_error() => {
            println!("å®¢æˆ·ç«¯é”™è¯¯: {}", s.message());
        },
        HttpStatus::InternalServerError => {
            println!("æœåŠ¡å™¨é”™è¯¯: {}", status.message());
        },
        _ => {
            println!("å…¶ä»–çŠ¶æ€: {:?}", status);
        },
    }
}

fn main() {
    handle_response(HttpStatus::from_code(200), Some("OK".to_string()));
    handle_response(HttpStatus::from_code(404), None);
    handle_response(HttpStatus::from_code(500), None);
}
```

### æ¡ˆä¾‹3: å‘½ä»¤è¡Œå‚æ•°è§£æ

```rust
#[derive(Debug)]
enum Command {
    Help,
    Version,
    Run { file: String, verbose: bool },
    Build { target: String, release: bool },
}

fn parse_args(args: &[String]) -> Result<Command, String> {
    // let else æå‰è¿”å›
    let Some(cmd) = args.get(1) else {
        return Err("ç¼ºå°‘å‘½ä»¤".to_string());
    };
    
    // match å¤„ç†ä¸åŒå‘½ä»¤
    match cmd.as_str() {
        "help" | "-h" | "--help" => Ok(Command::Help),
        "version" | "-v" | "--version" => Ok(Command::Version),
        "run" => {
            let Some(file) = args.get(2) else {
                return Err("runå‘½ä»¤éœ€è¦æŒ‡å®šæ–‡ä»¶".to_string());
            };
            
            let verbose = args.contains(&"--verbose".to_string());
            
            Ok(Command::Run {
                file: file.clone(),
                verbose,
            })
        },
        "build" => {
            let target = args.get(2)
                .map(|s| s.clone())
                .unwrap_or_else(|| "debug".to_string());
            
            let release = args.contains(&"--release".to_string());
            
            Ok(Command::Build { target, release })
        },
        _ => Err(format!("æœªçŸ¥å‘½ä»¤: {}", cmd)),
    }
}

fn execute_command(command: Command) {
    match command {
        Command::Help => {
            println!("ä½¿ç”¨æ–¹æ³•:");
            println!("  help - æ˜¾ç¤ºå¸®åŠ©");
            println!("  version - æ˜¾ç¤ºç‰ˆæœ¬");
            println!("  run <file> [--verbose] - è¿è¡Œæ–‡ä»¶");
            println!("  build [target] [--release] - æ„å»ºé¡¹ç›®");
        },
        Command::Version => {
            println!("ç‰ˆæœ¬ 1.0.0");
        },
        Command::Run { file, verbose } => {
            if verbose {
                println!("è¯¦ç»†æ¨¡å¼ï¼šè¿è¡Œæ–‡ä»¶ {}", file);
            } else {
                println!("è¿è¡Œæ–‡ä»¶ {}", file);
            }
        },
        Command::Build { target, release } => {
            let mode = if release { "release" } else { "debug" };
            println!("æ„å»ºç›®æ ‡ {} ({}æ¨¡å¼)", target, mode);
        },
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    match parse_args(&args) {
        Ok(command) => execute_command(command),
        Err(err) => {
            eprintln!("é”™è¯¯: {}", err);
            eprintln!("ä½¿ç”¨ 'help' æŸ¥çœ‹ä½¿ç”¨æ–¹æ³•");
        },
    }
}
```

### æ¡ˆä¾‹4: çŠ¶æ€æœºå®ç°

```rust
#[derive(Debug, PartialEq)]
enum State {
    Idle,
    Running,
    Paused,
    Stopped,
}

#[derive(Debug)]
enum Event {
    Start,
    Pause,
    Resume,
    Stop,
}

struct StateMachine {
    state: State,
}

impl StateMachine {
    fn new() -> Self {
        StateMachine { state: State::Idle }
    }
    
    fn handle_event(&mut self, event: Event) -> Result<(), String> {
        // ä½¿ç”¨åµŒå¥— match å¤„ç†çŠ¶æ€è½¬æ¢
        let new_state = match (&self.state, event) {
            // Idle çŠ¶æ€
            (State::Idle, Event::Start) => State::Running,
            (State::Idle, Event::Stop) => State::Stopped,
            
            // Running çŠ¶æ€
            (State::Running, Event::Pause) => State::Paused,
            (State::Running, Event::Stop) => State::Stopped,
            
            // Paused çŠ¶æ€
            (State::Paused, Event::Resume) => State::Running,
            (State::Paused, Event::Stop) => State::Stopped,
            
            // Stopped çŠ¶æ€ï¼ˆç»ˆæ­¢çŠ¶æ€ï¼‰
            (State::Stopped, _) => {
                return Err("å·²åœæ­¢ï¼Œæ— æ³•æ¥æ”¶äº‹ä»¶".to_string());
            },
            
            // æ— æ•ˆè½¬æ¢
            (state, event) => {
                return Err(format!(
                    "æ— æ•ˆçŠ¶æ€è½¬æ¢: {:?} -> {:?}",
                    state, event
                ));
            },
        };
        
        println!("çŠ¶æ€è½¬æ¢: {:?} -> {:?}", self.state, new_state);
        self.state = new_state;
        Ok(())
    }
    
    fn current_state(&self) -> &State {
        &self.state
    }
}

fn main() {
    let mut machine = StateMachine::new();
    
    assert_eq!(machine.current_state(), &State::Idle);
    
    machine.handle_event(Event::Start).unwrap();
    assert_eq!(machine.current_state(), &State::Running);
    
    machine.handle_event(Event::Pause).unwrap();
    assert_eq!(machine.current_state(), &State::Paused);
    
    machine.handle_event(Event::Resume).unwrap();
    assert_eq!(machine.current_state(), &State::Running);
    
    machine.handle_event(Event::Stop).unwrap();
    assert_eq!(machine.current_state(), &State::Stopped);
    
    // å°è¯•æ— æ•ˆè½¬æ¢
    if let Err(err) = machine.handle_event(Event::Start) {
        println!("é¢„æœŸé”™è¯¯: {}", err);
    }
}
```

### æ¡ˆä¾‹5: è¡¨è¾¾å¼æ±‚å€¼å™¨

```rust
#[derive(Debug, Clone)]
enum Expr {
    Number(f64),
    Add(Box<Expr>, Box<Expr>),
    Sub(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
    Div(Box<Expr>, Box<Expr>),
}

fn eval(expr: &Expr) -> Result<f64, String> {
    // ä½¿ç”¨ match é€’å½’æ±‚å€¼
    match expr {
        Expr::Number(n) => Ok(*n),
        
        Expr::Add(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l + r)
        },
        
        Expr::Sub(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l - r)
        },
        
        Expr::Mul(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l * r)
        },
        
        Expr::Div(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            
            // æ£€æŸ¥é™¤é›¶
            if r == 0.0 {
                Err("é™¤é›¶é”™è¯¯".to_string())
            } else {
                Ok(l / r)
            }
        },
    }
}

fn optimize(expr: Expr) -> Expr {
    // ä½¿ç”¨ match è¿›è¡Œç¼–è¯‘æ—¶ä¼˜åŒ–
    match expr {
        // åŠ æ³•ä¼˜åŒ–
        Expr::Add(left, right) => {
            let left = optimize(*left);
            let right = optimize(*right);
            
            match (&left, &right) {
                (Expr::Number(0.0), r) => r.clone(),
                (l, Expr::Number(0.0)) => l.clone(),
                (Expr::Number(a), Expr::Number(b)) => Expr::Number(a + b),
                _ => Expr::Add(Box::new(left), Box::new(right)),
            }
        },
        
        // ä¹˜æ³•ä¼˜åŒ–
        Expr::Mul(left, right) => {
            let left = optimize(*left);
            let right = optimize(*right);
            
            match (&left, &right) {
                (Expr::Number(0.0), _) | (_, Expr::Number(0.0)) => Expr::Number(0.0),
                (Expr::Number(1.0), r) => r.clone(),
                (l, Expr::Number(1.0)) => l.clone(),
                (Expr::Number(a), Expr::Number(b)) => Expr::Number(a * b),
                _ => Expr::Mul(Box::new(left), Box::new(right)),
            }
        },
        
        // å…¶ä»–è¡¨è¾¾å¼é€’å½’ä¼˜åŒ–
        Expr::Sub(left, right) => {
            Expr::Sub(Box::new(optimize(*left)), Box::new(optimize(*right)))
        },
        Expr::Div(left, right) => {
            Expr::Div(Box::new(optimize(*left)), Box::new(optimize(*right)))
        },
        Expr::Number(n) => Expr::Number(n),
    }
}

fn main() {
    // (2 + 3) * 4
    let expr = Expr::Mul(
        Box::new(Expr::Add(
            Box::new(Expr::Number(2.0)),
            Box::new(Expr::Number(3.0)),
        )),
        Box::new(Expr::Number(4.0)),
    );
    
    println!("è¡¨è¾¾å¼: {:?}", expr);
    println!("ç»“æœ: {:?}", eval(&expr));
    
    // ä¼˜åŒ–ç¤ºä¾‹: 0 * x
    let expr2 = Expr::Mul(
        Box::new(Expr::Number(0.0)),
        Box::new(Expr::Add(
            Box::new(Expr::Number(10.0)),
            Box::new(Expr::Number(20.0)),
        )),
    );
    
    println!("\nä¼˜åŒ–å‰: {:?}", expr2);
    let optimized = optimize(expr2);
    println!("ä¼˜åŒ–å: {:?}", optimized);
}
```

---

## 7. å¸¸è§é™·é˜±

### 7.1 ç±»å‹ä¸ä¸€è‡´

```rust
fn main() {
    let number = 5;
    
    // âŒ é”™è¯¯ï¼šåˆ†æ”¯ç±»å‹ä¸ä¸€è‡´
    // let result = if number > 0 {
    //     "positive"  // &str
    // } else {
    //     0  // i32
    // };
    
    // âœ… æ­£ç¡®ï¼šç±»å‹ä¸€è‡´
    let result = if number > 0 {
        "positive"
    } else {
        "zero or negative"
    };
    
    println!("{}", result);
}
```

### 7.2 å¿˜è®° else åˆ†æ”¯

```rust
fn main() {
    let number = 5;
    
    // âŒ é”™è¯¯ï¼šä½œä¸ºè¡¨è¾¾å¼æ—¶å¿…é¡»æœ‰ else
    // let result = if number > 0 {
    //     "positive"
    // };
    
    // âœ… æ­£ç¡®ï¼šæ·»åŠ  else
    let result = if number > 0 {
        "positive"
    } else {
        "not positive"
    };
    
    // âœ… æ­£ç¡®ï¼šä¸ä½œä¸ºè¡¨è¾¾å¼
    if number > 0 {
        println!("positive");
    }
    
    println!("{}", result);
}
```

### 7.3 ä¸å®Œæ•´çš„ match

```rust
fn main() {
    enum Status {
        Active,
        Inactive,
    }
    
    let status = Status::Active;
    
    // âŒ é”™è¯¯ï¼šæœªç©·å°½æ‰€æœ‰æƒ…å†µ
    // match status {
    //     Status::Active => println!("æ´»è·ƒ"),
    //     // ç¼ºå°‘ Inactive
    // }
    
    // âœ… æ­£ç¡®ï¼šç©·å°½æ‰€æœ‰æƒ…å†µ
    match status {
        Status::Active => println!("æ´»è·ƒ"),
        Status::Inactive => println!("ä¸æ´»è·ƒ"),
    }
}
```

### 7.4 è¿‡åº¦åµŒå¥—

```rust
fn main() {
    let value1 = Some(5);
    let value2 = Some(10);
    let value3 = Some(15);
    
    // âŒ ä¸æ¨èï¼šè¿‡åº¦åµŒå¥—
    if let Some(v1) = value1 {
        if let Some(v2) = value2 {
            if let Some(v3) = value3 {
                println!("Sum: {}", v1 + v2 + v3);
            }
        }
    }
    
    // âœ… æ¨èï¼šæå‰è¿”å›
    let Some(v1) = value1 else { return };
    let Some(v2) = value2 else { return };
    let Some(v3) = value3 else { return };
    println!("Sum: {}", v1 + v2 + v3);
    
    // âœ… æ¨èï¼šä½¿ç”¨æ–¹æ³•é“¾
    if let (Some(v1), Some(v2), Some(v3)) = (value1, value2, value3) {
        println!("Sum: {}", v1 + v2 + v3);
    }
}
```

---

## 8. æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨ match å¤„ç†æšä¸¾**
2. **ç®€å•æ¡ä»¶ä½¿ç”¨ if**
3. **å•ä¸€æ¨¡å¼åŒ¹é…ä½¿ç”¨ if let**
4. **éœ€è¦æå‰è¿”å›ä½¿ç”¨ let else**
5. **é¿å…è¿‡åº¦åµŒå¥—**
6. **åˆ©ç”¨ç¼–è¯‘å™¨çš„å®Œæ•´æ€§æ£€æŸ¥**
7. **ä¿æŒåˆ†æ”¯ç±»å‹ä¸€è‡´**
8. **ä½¿ç”¨å®ˆå«æ¡ä»¶ç®€åŒ–é€»è¾‘**

---

## 9. æ€§èƒ½ä¼˜åŒ–

1. **ç¼–è¯‘å™¨ä¼˜åŒ–**: åœ¨ release æ¨¡å¼ä¸‹ï¼Œä¸åŒæ¡ä»¶è¯­å¥çš„æ€§èƒ½å·®å¼‚å¾ˆå°
2. **é¿å…é‡å¤è®¡ç®—**: å°†å¤æ‚è¡¨è¾¾å¼ç»“æœç¼“å­˜
3. **ä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„**: è€ƒè™‘ä½¿ç”¨ HashMap æ›¿ä»£å¤§é‡çš„ if-else
4. **Profile ä¼˜å…ˆ**: å…ˆæµ‹é‡å†ä¼˜åŒ–

---

## 10. å°ç»“

- if è¡¨è¾¾å¼é€‚åˆç®€å•æ¡ä»¶åˆ¤æ–­
- match è¡¨è¾¾å¼æä¾›å¼ºå¤§çš„æ¨¡å¼åŒ¹é…èƒ½åŠ›
- if let ç®€åŒ–å•ä¸€æ¨¡å¼åŒ¹é…
- let else ä¼˜é›…å¤„ç†æå‰è¿”å›
- æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©åˆé€‚çš„æ¡ä»¶è¯­å¥

---

## 11. å»¶ä¼¸é˜…è¯»

**å†…éƒ¨æ–‡æ¡£**:

- [å¾ªç¯ç»“æ„æŒ‡å—](./02_å¾ªç¯ç»“æ„æŒ‡å—.md)
- [æ¨¡å¼åŒ¹é…æŒ‡å—](./04_æ¨¡å¼åŒ¹é…æŒ‡å—.md)
- [æ§åˆ¶æµå‚è€ƒ](../tier_03_references/01_æ§åˆ¶æµå‚è€ƒ.md)

**å¤–éƒ¨èµ„æº**:

- [Rust Book - Control Flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html)
- [Rust Reference - Expressions](https://doc.rust-lang.org/reference/expressions.html)
- [Rust by Example - Flow Control](https://doc.rust-lang.org/rust-by-example/flow_control.html)

---

## 12. ç»ƒä¹ é¢˜

1. ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œä½¿ç”¨ match åˆ¤æ–­ä¸€ä¸ªæ•°å­—æ˜¯å¦æ˜¯é—°å¹´
2. ä½¿ç”¨ if let å¤„ç†åµŒå¥—çš„ `Option<Option<i32>>`
3. å®ç°ä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨ï¼Œæ”¯æŒå››åˆ™è¿ç®—
4. ä½¿ç”¨ let else é‡æ„ä¸€ä¸ªåŒ…å«å¤šå±‚åµŒå¥— if let çš„å‡½æ•°
5. è®¾è®¡ä¸€ä¸ªçŠ¶æ€æœºæ¥æ¨¡æ‹Ÿçº¢ç»¿ç¯æ§åˆ¶ç³»ç»Ÿ

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ¯ æŒæ¡Rustæ¡ä»¶è¯­å¥ï¼Œç¼–å†™æ¸…æ™°ç®€æ´çš„æ§åˆ¶é€»è¾‘ï¼** ğŸ¦€âœ¨
