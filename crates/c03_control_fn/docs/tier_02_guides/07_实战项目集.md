# âš™ï¸ C03: Control Flow & Functions - å®æˆ˜é¡¹ç›®é›†

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25  
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **é€‚ç”¨æ¨¡å—**: C03 æ§åˆ¶æµå’Œå‡½æ•°  
> **ç›®æ ‡**: é€šè¿‡å®æˆ˜é¡¹ç›®æŒæ¡æ§åˆ¶æµã€å‡½æ•°å’Œé”™è¯¯å¤„ç†

---

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

| # | é¡¹ç›®åç§° | éš¾åº¦ | é¢„è®¡æ—¶é—´ | æ ¸å¿ƒæ¦‚å¿µ |
|---|----------|------|---------|---------|
| 1 | [è®¡ç®—å™¨ CLI](#é¡¹ç›®1-è®¡ç®—å™¨-cli) | â­ | 1-2å°æ—¶ | æ§åˆ¶æµã€matchã€å‡½æ•° |
| 2 | [é”™è¯¯å¤„ç†æ¡†æ¶](#é¡¹ç›®2-é”™è¯¯å¤„ç†æ¡†æ¶) | â­â­ | 2-3å°æ—¶ | Resultã€è‡ªå®šä¹‰é”™è¯¯ã€? æ“ä½œç¬¦ |
| 3 | [è¡¨è¾¾å¼è§£æå™¨](#é¡¹ç›®3-è¡¨è¾¾å¼è§£æå™¨) | â­â­â­ | 3-4å°æ—¶ | é€’å½’ã€é—­åŒ…ã€é«˜é˜¶å‡½æ•° |

---

## é¡¹ç›®1: è®¡ç®—å™¨ CLI

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­  
**é¢„è®¡æ—¶é—´**: 1-2å°æ—¶

### å­¦ä¹ ç›®æ ‡

- æŒæ¡ `match` è¡¨è¾¾å¼
- ç†è§£æ§åˆ¶æµè¯­å¥
- å®ç°å‘½ä»¤è¡Œäº¤äº’
- å¤„ç†ç”¨æˆ·è¾“å…¥

### æ ¸å¿ƒä»£ç 

```rust
use std::io::{self, Write};

fn main() {
    println!("===== ç®€å•è®¡ç®—å™¨ =====");
    println!("æ”¯æŒ: +, -, *, /");
    println!("è¾“å…¥ 'quit' é€€å‡º\n");
    
    loop {
        print!("è¯·è¾“å…¥è¡¨è¾¾å¼ (å¦‚: 5 + 3): ");
        io::stdout().flush().unwrap();
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        
        let input = input.trim();
        
        if input == "quit" {
            println!("å†è§ï¼");
            break;
        }
        
        match calculate(input) {
            Ok(result) => println!("ç»“æœ: {}\n", result),
            Err(e) => println!("âŒ é”™è¯¯: {}\n", e),
        }
    }
}

fn calculate(expr: &str) -> Result<f64, String> {
    let parts: Vec<&str> = expr.split_whitespace().collect();
    
    if parts.len() != 3 {
        return Err("æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º: æ•°å­— è¿ç®—ç¬¦ æ•°å­—".to_string());
    }
    
    let a: f64 = parts[0].parse()
        .map_err(|_| format!("æ— æ•ˆçš„æ•°å­—: {}", parts[0]))?;
    let op = parts[1];
    let b: f64 = parts[2].parse()
        .map_err(|_| format!("æ— æ•ˆçš„æ•°å­—: {}", parts[2]))?;
    
    match op {
        "+" => Ok(a + b),
        "-" => Ok(a - b),
        "*" => Ok(a * b),
        "/" => {
            if b == 0.0 {
                Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
            } else {
                Ok(a / b)
            }
        }
        _ => Err(format!("æœªçŸ¥è¿ç®—ç¬¦: {}", op)),
    }
}
```

### æµ‹è¯•è¾“å‡º

```text
===== ç®€å•è®¡ç®—å™¨ =====
æ”¯æŒ: +, -, *, /
è¾“å…¥ 'quit' é€€å‡º

è¯·è¾“å…¥è¡¨è¾¾å¼ (å¦‚: 5 + 3): 10 + 20
ç»“æœ: 30

è¯·è¾“å…¥è¡¨è¾¾å¼ (å¦‚: 5 + 3): 15 / 3
ç»“æœ: 5

è¯·è¾“å…¥è¡¨è¾¾å¼ (å¦‚: 5 + 3): 10 / 0
âŒ é”™è¯¯: é™¤æ•°ä¸èƒ½ä¸ºé›¶
```

---

## é¡¹ç›®2: é”™è¯¯å¤„ç†æ¡†æ¶

### ğŸ“– é¡¹ç›®è¯´æ˜2

**éš¾åº¦**: â­â­  
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶

### å­¦ä¹ ç›®æ ‡2

- å®šä¹‰è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- å®ç° `Error` trait
- ä½¿ç”¨ `?` æ“ä½œç¬¦
- é”™è¯¯è½¬æ¢å’Œä¼ æ’­

### æ ¸å¿ƒä»£ç 2

```rust
use std::fmt;
use std::error::Error;
use std::num::ParseIntError;
use std::io;

/// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
    Validation(String),
    NotFound(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(err) => write!(f, "IO é”™è¯¯: {}", err),
            AppError::Parse(err) => write!(f, "è§£æé”™è¯¯: {}", err),
            AppError::Validation(msg) => write!(f, "éªŒè¯é”™è¯¯: {}", msg),
            AppError::NotFound(msg) => write!(f, "æœªæ‰¾åˆ°: {}", msg),
        }
    }
}

impl Error for AppError {}

// é”™è¯¯è½¬æ¢
impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<ParseIntError> for AppError {
    fn from(error: ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

/// ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ
struct UserManager {
    users: Vec<User>,
}

struct User {
    id: u32,
    name: String,
    age: u8,
}

impl UserManager {
    fn new() -> Self {
        UserManager { users: Vec::new() }
    }
    
    /// æ·»åŠ ç”¨æˆ· - æ¼”ç¤ºéªŒè¯é”™è¯¯
    fn add_user(&mut self, name: String, age: u8) -> Result<(), AppError> {
        // éªŒè¯å¹´é¾„
        if age < 18 {
            return Err(AppError::Validation(
                "å¹´é¾„å¿…é¡»å¤§äºç­‰äº18".to_string()
            ));
        }
        
        // éªŒè¯å§“å
        if name.is_empty() {
            return Err(AppError::Validation(
                "å§“åä¸èƒ½ä¸ºç©º".to_string()
            ));
        }
        
        let id = self.users.len() as u32 + 1;
        self.users.push(User { id, name, age });
        Ok(())
    }
    
    /// æŸ¥æ‰¾ç”¨æˆ· - æ¼”ç¤º NotFound é”™è¯¯
    fn find_user(&self, id: u32) -> Result<&User, AppError> {
        self.users.iter()
            .find(|u| u.id == id)
            .ok_or_else(|| AppError::NotFound(format!("ç”¨æˆ· {} ä¸å­˜åœ¨", id)))
    }
    
    /// è§£æç”¨æˆ·è¾“å…¥ - æ¼”ç¤º ? æ“ä½œç¬¦å’Œé”™è¯¯è½¬æ¢
    fn parse_age(input: &str) -> Result<u8, AppError> {
        let age: u8 = input.parse()?;  // ParseIntError è‡ªåŠ¨è½¬æ¢ä¸º AppError
        
        if age > 120 {
            return Err(AppError::Validation(
                "å¹´é¾„ä¸åˆç†".to_string()
            ));
        }
        
        Ok(age)
    }
}

fn main() -> Result<(), AppError> {
    println!("===== é”™è¯¯å¤„ç†æ¡†æ¶æµ‹è¯• =====\n");
    
    let mut manager = UserManager::new();
    
    // æµ‹è¯•1: æˆåŠŸæ·»åŠ ç”¨æˆ·
    println!("æµ‹è¯•1: æ·»åŠ æœ‰æ•ˆç”¨æˆ·");
    manager.add_user("Alice".to_string(), 25)?;
    manager.add_user("Bob".to_string(), 30)?;
    println!("âœ… æˆåŠŸæ·»åŠ  2 ä¸ªç”¨æˆ·\n");
    
    // æµ‹è¯•2: éªŒè¯é”™è¯¯
    println!("æµ‹è¯•2: éªŒè¯é”™è¯¯");
    match manager.add_user("Charlie".to_string(), 15) {
        Ok(_) => println!("æˆåŠŸ"),
        Err(e) => println!("âŒ {}\n", e),
    }
    
    // æµ‹è¯•3: æŸ¥æ‰¾ç”¨æˆ·
    println!("æµ‹è¯•3: æŸ¥æ‰¾ç”¨æˆ·");
    match manager.find_user(1) {
        Ok(user) => println!("âœ… æ‰¾åˆ°ç”¨æˆ·: {} (å¹´é¾„: {})", user.name, user.age),
        Err(e) => println!("âŒ {}", e),
    }
    
    match manager.find_user(999) {
        Ok(user) => println!("æ‰¾åˆ°: {}", user.name),
        Err(e) => println!("âŒ {}\n", e),
    }
    
    // æµ‹è¯•4: è§£æé”™è¯¯
    println!("æµ‹è¯•4: è§£æå¹´é¾„");
    match UserManager::parse_age("25") {
        Ok(age) => println!("âœ… è§£ææˆåŠŸ: {}", age),
        Err(e) => println!("âŒ {}", e),
    }
    
    match UserManager::parse_age("abc") {
        Ok(age) => println!("è§£æ: {}", age),
        Err(e) => println!("âŒ {}\n", e),
    }
    
    Ok(())
}
```

### æµ‹è¯•è¾“å‡º2

```text
===== é”™è¯¯å¤„ç†æ¡†æ¶æµ‹è¯• =====

æµ‹è¯•1: æ·»åŠ æœ‰æ•ˆç”¨æˆ·
âœ… æˆåŠŸæ·»åŠ  2 ä¸ªç”¨æˆ·

æµ‹è¯•2: éªŒè¯é”™è¯¯
âŒ éªŒè¯é”™è¯¯: å¹´é¾„å¿…é¡»å¤§äºç­‰äº18

æµ‹è¯•3: æŸ¥æ‰¾ç”¨æˆ·
âœ… æ‰¾åˆ°ç”¨æˆ·: Alice (å¹´é¾„: 25)
âŒ æœªæ‰¾åˆ°: ç”¨æˆ· 999 ä¸å­˜åœ¨

æµ‹è¯•4: è§£æå¹´é¾„
âœ… è§£ææˆåŠŸ: 25
âŒ è§£æé”™è¯¯: invalid digit found in string
```

---

## é¡¹ç›®3: è¡¨è¾¾å¼è§£æå™¨

### ğŸ“– é¡¹ç›®è¯´æ˜3

**éš¾åº¦**: â­â­â­  
**é¢„è®¡æ—¶é—´**: 3-4å°æ—¶

### å­¦ä¹ ç›®æ ‡3

- å®ç°é€’å½’å‡½æ•°
- ä½¿ç”¨é—­åŒ…å’Œé«˜é˜¶å‡½æ•°
- æ¨¡å¼åŒ¹é…é«˜çº§ç”¨æ³•
- è§£æç®—æ³•å®ç°

### æ ¸å¿ƒä»£ç ï¼ˆç®€åŒ–ç‰ˆï¼‰

```rust
/// è¡¨è¾¾å¼èŠ‚ç‚¹
#[derive(Debug, PartialEq)]
enum Expr {
    Number(f64),
    BinaryOp {
        op: Op,
        left: Box<Expr>,
        right: Box<Expr>,
    },
}

#[derive(Debug, PartialEq)]
enum Op {
    Add,
    Sub,
    Mul,
    Div,
}

/// è¯æ³•åˆ†æå™¨
struct Lexer {
    input: Vec<char>,
    pos: usize,
}

impl Lexer {
    fn new(input: &str) -> Self {
        Lexer {
            input: input.chars().collect(),
            pos: 0,
        }
    }
    
    fn peek(&self) -> Option<char> {
        if self.pos < self.input.len() {
            Some(self.input[self.pos])
        } else {
            None
        }
    }
    
    fn advance(&mut self) {
        self.pos += 1;
    }
    
    fn skip_whitespace(&mut self) {
        while let Some(c) = self.peek() {
            if c.is_whitespace() {
                self.advance();
            } else {
                break;
            }
        }
    }
}

/// é€’å½’ä¸‹é™è§£æå™¨
struct Parser {
    lexer: Lexer,
}

impl Parser {
    fn new(input: &str) -> Self {
        Parser {
            lexer: Lexer::new(input),
        }
    }
    
    fn parse(&mut self) -> Result<Expr, String> {
        self.parse_expr()
    }
    
    fn parse_expr(&mut self) -> Result<Expr, String> {
        // è§£æåŠ å‡æ³•
        let mut left = self.parse_term()?;
        
        loop {
            self.lexer.skip_whitespace();
            match self.lexer.peek() {
                Some('+') => {
                    self.lexer.advance();
                    let right = self.parse_term()?;
                    left = Expr::BinaryOp {
                        op: Op::Add,
                        left: Box::new(left),
                        right: Box::new(right),
                    };
                }
                Some('-') => {
                    self.lexer.advance();
                    let right = self.parse_term()?;
                    left = Expr::BinaryOp {
                        op: Op::Sub,
                        left: Box::new(left),
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }
        
        Ok(left)
    }
    
    fn parse_term(&mut self) -> Result<Expr, String> {
        // è§£æä¹˜é™¤æ³•
        let mut left = self.parse_number()?;
        
        loop {
            self.lexer.skip_whitespace();
            match self.lexer.peek() {
                Some('*') => {
                    self.lexer.advance();
                    let right = self.parse_number()?;
                    left = Expr::BinaryOp {
                        op: Op::Mul,
                        left: Box::new(left),
                        right: Box::new(right),
                    };
                }
                Some('/') => {
                    self.lexer.advance();
                    let right = self.parse_number()?;
                    left = Expr::BinaryOp {
                        op: Op::Div,
                        left: Box::new(left),
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }
        
        Ok(left)
    }
    
    fn parse_number(&mut self) -> Result<Expr, String> {
        self.lexer.skip_whitespace();
        
        let mut num_str = String::new();
        while let Some(c) = self.lexer.peek() {
            if c.is_numeric() || c == '.' {
                num_str.push(c);
                self.lexer.advance();
            } else {
                break;
            }
        }
        
        if num_str.is_empty() {
            return Err("æœŸæœ›æ•°å­—".to_string());
        }
        
        let num: f64 = num_str.parse()
            .map_err(|_| "æ— æ•ˆçš„æ•°å­—".to_string())?;
        
        Ok(Expr::Number(num))
    }
}

/// æ±‚å€¼å™¨
fn eval(expr: &Expr) -> Result<f64, String> {
    match expr {
        Expr::Number(n) => Ok(*n),
        Expr::BinaryOp { op, left, right } => {
            let left_val = eval(left)?;
            let right_val = eval(right)?;
            
            match op {
                Op::Add => Ok(left_val + right_val),
                Op::Sub => Ok(left_val - right_val),
                Op::Mul => Ok(left_val * right_val),
                Op::Div => {
                    if right_val == 0.0 {
                        Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
                    } else {
                        Ok(left_val / right_val)
                    }
                }
            }
        }
    }
}

fn main() {
    println!("===== è¡¨è¾¾å¼è§£æå™¨æµ‹è¯• =====\n");
    
    let test_cases = vec![
        "3 + 5",
        "10 - 3",
        "4 * 5",
        "20 / 4",
        "2 + 3 * 4",
        "10 / 2 + 3",
    ];
    
    for expr_str in test_cases {
        println!("è¡¨è¾¾å¼: {}", expr_str);
        
        let mut parser = Parser::new(expr_str);
        match parser.parse() {
            Ok(expr) => {
                println!("  AST: {:?}", expr);
                match eval(&expr) {
                    Ok(result) => println!("  âœ… ç»“æœ: {}\n", result),
                    Err(e) => println!("  âŒ æ±‚å€¼é”™è¯¯: {}\n", e),
                }
            }
            Err(e) => println!("  âŒ è§£æé”™è¯¯: {}\n", e),
        }
    }
}
```

### æµ‹è¯•è¾“å‡º3

```text
===== è¡¨è¾¾å¼è§£æå™¨æµ‹è¯• =====

è¡¨è¾¾å¼: 3 + 5
  AST: BinaryOp { op: Add, left: Number(3.0), right: Number(5.0) }
  âœ… ç»“æœ: 8

è¡¨è¾¾å¼: 2 + 3 * 4
  AST: BinaryOp { op: Add, left: Number(2.0), right: BinaryOp { ... } }
  âœ… ç»“æœ: 14
```

---

## ğŸ“ æ€»ç»“

### å…³é”®æ¦‚å¿µ

| æ¦‚å¿µ | é¡¹ç›®1 | é¡¹ç›®2 | é¡¹ç›®3 |
|------|-------|-------|-------|
| æ§åˆ¶æµ | âœ…âœ…âœ… | âœ…âœ… | âœ…âœ… |
| match | âœ…âœ…âœ… | âœ…âœ… | âœ…âœ…âœ… |
| Result | âœ…âœ… | âœ…âœ…âœ… | âœ…âœ…âœ… |
| è‡ªå®šä¹‰é”™è¯¯ | âŒ | âœ…âœ…âœ… | âœ…âœ… |
| é€’å½’ | âŒ | âŒ | âœ…âœ…âœ… |
| é—­åŒ… | âŒ | âœ… | âœ…âœ… |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25

**ğŸ¯ æŒæ¡æ§åˆ¶æµå’Œé”™è¯¯å¤„ç†ï¼Œå†™å‡ºå¥å£®çš„ Rust ç¨‹åºï¼ğŸ¦€**-
