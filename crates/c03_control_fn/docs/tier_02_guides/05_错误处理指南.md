# 2.5 é”™è¯¯å¤„ç†æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚
> **æ–‡æ¡£å®šä½**: ç³»ç»ŸåŒ–å­¦ä¹ Rusté”™è¯¯å¤„ç†ï¼ŒæŒæ¡Result/Option/panicæœºåˆ¶
> **å­¦ä¹ æ—¶é—´**: 1-2å¤©
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)

**æœ€åæ›´æ–°**: 2025-12-11
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.92.0+
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [2.5 é”™è¯¯å¤„ç†æŒ‡å—](#25-é”™è¯¯å¤„ç†æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. é”™è¯¯å¤„ç†åŸºç¡€](#1-é”™è¯¯å¤„ç†åŸºç¡€)
    - [1.1 å¯æ¢å¤é”™è¯¯vsä¸å¯æ¢å¤é”™è¯¯](#11-å¯æ¢å¤é”™è¯¯vsä¸å¯æ¢å¤é”™è¯¯)
    - [1.2 é”™è¯¯å¤„ç†å“²å­¦](#12-é”™è¯¯å¤„ç†å“²å­¦)
  - [2. Optionç±»å‹](#2-optionç±»å‹)
    - [2.1 åŸºæœ¬ç”¨æ³•](#21-åŸºæœ¬ç”¨æ³•)
    - [2.2 Optionæ–¹æ³•](#22-optionæ–¹æ³•)
    - [2.3 ç»„åˆOption](#23-ç»„åˆoption)
  - [3. Resultç±»å‹](#3-resultç±»å‹)
    - [3.1 åŸºæœ¬ç”¨æ³•](#31-åŸºæœ¬ç”¨æ³•)
    - [3.2 Resultæ–¹æ³•](#32-resultæ–¹æ³•)
    - [3.3 ?æ“ä½œç¬¦](#33-æ“ä½œç¬¦)
  - [4. panicå®](#4-panicå®)
    - [4.1 ä½•æ—¶ä½¿ç”¨panic](#41-ä½•æ—¶ä½¿ç”¨panic)
    - [4.2 unwrapå’Œexpect](#42-unwrapå’Œexpect)
    - [4.3 panicå¤„ç†](#43-panicå¤„ç†)
  - [5. è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#5-è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [5.1 ç®€å•é”™è¯¯ç±»å‹](#51-ç®€å•é”™è¯¯ç±»å‹)
    - [5.2 Error trait](#52-error-trait)
    - [5.3 é”™è¯¯è½¬æ¢](#53-é”™è¯¯è½¬æ¢)
  - [6. é”™è¯¯ä¼ æ’­](#6-é”™è¯¯ä¼ æ’­)
    - [6.1 æ˜¾å¼ä¼ æ’­](#61-æ˜¾å¼ä¼ æ’­)
    - [6.2 ?æ“ä½œç¬¦é“¾](#62-æ“ä½œç¬¦é“¾)
    - [6.3 å¤šç§é”™è¯¯ç±»å‹](#63-å¤šç§é”™è¯¯ç±»å‹)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: æ–‡ä»¶æ“ä½œ](#æ¡ˆä¾‹1-æ–‡ä»¶æ“ä½œ)
    - [æ¡ˆä¾‹2: ç½‘ç»œè¯·æ±‚](#æ¡ˆä¾‹2-ç½‘ç»œè¯·æ±‚)
    - [æ¡ˆä¾‹3: é…ç½®ç®¡ç†](#æ¡ˆä¾‹3-é…ç½®ç®¡ç†)
    - [æ¡ˆä¾‹4: æ•°æ®éªŒè¯](#æ¡ˆä¾‹4-æ•°æ®éªŒè¯)
    - [7.5 è¾¹ç•Œæ¡ˆä¾‹ä¸è¿›é˜¶](#75-è¾¹ç•Œæ¡ˆä¾‹ä¸è¿›é˜¶)
      - [From/Into é”™è¯¯æ˜ å°„](#frominto-é”™è¯¯æ˜ å°„)
      - [anyhow vs thiserror é€‰å‹](#anyhow-vs-thiserror-é€‰å‹)
      - [æ—©è¿”å›ä¸ RAII](#æ—©è¿”å›ä¸-raii)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
  - [10. å°ç»“](#10-å°ç»“)
  - [11. å»¶ä¼¸é˜…è¯»](#11-å»¶ä¼¸é˜…è¯»)
  - [12. ç»ƒä¹ é¢˜](#12-ç»ƒä¹ é¢˜)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£Rusté”™è¯¯å¤„ç†æœºåˆ¶
- âœ… ç†Ÿç»ƒä½¿ç”¨Optionå’ŒResult
- âœ… æŒæ¡?æ“ä½œç¬¦å’Œé”™è¯¯ä¼ æ’­
- âœ… è®¾è®¡è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- âœ… ç¼–å†™å¥å£®çš„é”™è¯¯å¤„ç†ä»£ç 
- âœ… é€‰æ‹©åˆé€‚çš„é”™è¯¯å¤„ç†ç­–ç•¥

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**é”™è¯¯å¤„ç†æŒ‡å— (Error Handling Guide)**:

- **å®šä¹‰**: ç³»ç»ŸåŒ–å­¦ä¹  Rust é”™è¯¯å¤„ç†çš„å®è·µæŒ‡å—ï¼ŒåŒ…æ‹¬ Resultã€Optionã€panic æœºåˆ¶
- **ç±»å‹**: å®è·µæŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: é”™è¯¯å¤„ç†ã€ç±»å‹ç³»ç»Ÿ
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: Resultã€Optionã€é”™è¯¯å¤„ç†ã€panicã€é”™è¯¯ä¼ æ’­

**é”™è¯¯å¤„ç† (Error Handling)**:

- **å®šä¹‰**: å¤„ç†ç¨‹åºä¸­å¯èƒ½å‡ºç°çš„é”™è¯¯æƒ…å†µçš„æœºåˆ¶
- **ç±»å‹**: ç¼–ç¨‹èŒƒå¼
- **å±æ€§**: å¯æ¢å¤é”™è¯¯ã€ä¸å¯æ¢å¤é”™è¯¯ã€é”™è¯¯ä¼ æ’­
- **å…³ç³»**: ä¸ Resultã€Optionã€panic ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **Option ç±»å‹**: è¡¨ç¤ºå¯èƒ½ä¸ºç©ºçš„å€¼
- **Result ç±»å‹**: è¡¨ç¤ºå¯èƒ½å¤±è´¥çš„æ“ä½œ
- **panic æœºåˆ¶**: ä¸å¯æ¢å¤é”™è¯¯å¤„ç†
- **é”™è¯¯ä¼ æ’­**: ? æ“ä½œç¬¦ã€é”™è¯¯è½¬æ¢

**æ€§èƒ½ç‰¹å¾**:

- **é›¶æˆæœ¬æŠ½è±¡**: Option å’Œ Result é›¶å¼€é”€
- **ç¼–è¯‘æ—¶æ£€æŸ¥**: ç¼–è¯‘å™¨å¼ºåˆ¶å¤„ç†é”™è¯¯
- **é€‚ç”¨åœºæ™¯**: é”™è¯¯å¤„ç†ã€ç©ºå€¼å¤„ç†ã€å¼‚å¸¸æƒ…å†µ

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- Result --[is-a]--> é”™è¯¯å¤„ç†ç±»å‹
- Option --[is-a]--> å¯é€‰å€¼ç±»å‹

**ç»„åˆå…³ç³»**:

- é”™è¯¯å¤„ç†æŒ‡å— --[covers]--> å¤šç§é”™è¯¯å¤„ç†æœºåˆ¶
- å¥å£®ç¨‹åº --[uses]--> é”™è¯¯å¤„ç†

**ä¾èµ–å…³ç³»**:

- é”™è¯¯å¤„ç† --[depends-on]--> ç±»å‹ç³»ç»Ÿ
- ç¨‹åºå¯é æ€§ --[depends-on]--> é”™è¯¯å¤„ç†

### æ€ç»´å¯¼å›¾

```text
é”™è¯¯å¤„ç†æŒ‡å—
â”‚
â”œâ”€â”€ Option ç±»å‹
â”‚   â”œâ”€â”€ åŸºæœ¬ç”¨æ³•
â”‚   â””â”€â”€ Option æ–¹æ³•
â”œâ”€â”€ Result ç±»å‹
â”‚   â”œâ”€â”€ åŸºæœ¬ç”¨æ³•
â”‚   â””â”€â”€ ? æ“ä½œç¬¦
â”œâ”€â”€ panic æœºåˆ¶
â”‚   â””â”€â”€ unwrap/expect
â”œâ”€â”€ è‡ªå®šä¹‰é”™è¯¯ç±»å‹
â”‚   â””â”€â”€ Error trait
â””â”€â”€ é”™è¯¯ä¼ æ’­
    â””â”€â”€ ? æ“ä½œç¬¦é“¾
```

---

## 1. é”™è¯¯å¤„ç†åŸºç¡€

### 1.1 å¯æ¢å¤é”™è¯¯vsä¸å¯æ¢å¤é”™è¯¯

Rustå°†é”™è¯¯åˆ†ä¸ºä¸¤ç±»ï¼š

```rust
fn main() {
    // å¯æ¢å¤é”™è¯¯ï¼šä½¿ç”¨Result
    let result = std::fs::read_to_string("file.txt");
    match result {
        Ok(content) => println!("å†…å®¹: {}", content),
        Err(error) => println!("é”™è¯¯: {}", error),
    }

    // ä¸å¯æ¢å¤é”™è¯¯ï¼šä½¿ç”¨panic
    // panic!("è‡´å‘½é”™è¯¯ï¼");  // ç¨‹åºä¼šç»ˆæ­¢

    // å¯èƒ½ä¸ºç©ºçš„å€¼ï¼šä½¿ç”¨Option
    let numbers = vec![1, 2, 3];
    match numbers.get(10) {
        Some(value) => println!("å€¼: {}", value),
        None => println!("ç´¢å¼•è¶Šç•Œ"),
    }
}
```

**å…³é”®åŒºåˆ«**:

- **Result**: è¡¨ç¤ºå¯èƒ½å¤±è´¥çš„æ“ä½œ
- **Option**: è¡¨ç¤ºå¯èƒ½ä¸å­˜åœ¨çš„å€¼
- **panic**: è¡¨ç¤ºä¸å¯æ¢å¤çš„é”™è¯¯

### 1.2 é”™è¯¯å¤„ç†å“²å­¦

Rustçš„é”™è¯¯å¤„ç†åŸåˆ™ï¼š

```rust
fn main() {
    // åŸåˆ™1: æ˜¾å¼å¤„ç†é”™è¯¯
    fn divide(a: i32, b: i32) -> Result<i32, String> {
        if b == 0 {
            Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
        } else {
            Ok(a / b)
        }
    }

    // åŸåˆ™2: é”™è¯¯æ˜¯å€¼
    let result = divide(10, 2);
    match result {
        Ok(value) => println!("ç»“æœ: {}", value),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    // åŸåˆ™3: ç±»å‹å®‰å…¨
    fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
        s.parse()  // ç¼–è¯‘å™¨çŸ¥é“å…·ä½“é”™è¯¯ç±»å‹
    }

    // åŸåˆ™4: é›¶æˆæœ¬æŠ½è±¡
    // Resultå’ŒOptionåœ¨è¿è¡Œæ—¶æ²¡æœ‰é¢å¤–å¼€é”€
}
```

---

## 2. Optionç±»å‹

### 2.1 åŸºæœ¬ç”¨æ³•

Optionè¡¨ç¤ºå¯èƒ½ä¸å­˜åœ¨çš„å€¼ï¼š

```rust
fn main() {
    // åˆ›å»ºOption
    let some_number = Some(5);
    let no_number: Option<i32> = None;

    // åŒ¹é…Option
    match some_number {
        Some(n) => println!("æœ‰æ•°å­—: {}", n),
        None => println!("æ²¡æœ‰æ•°å­—"),
    }

    // if letç®€åŒ–
    if let Some(n) = some_number {
        println!("æ•°å­—æ˜¯: {}", n);
    }

    // ä»é›†åˆè·å–Option
    let vec = vec![1, 2, 3];
    let first = vec.get(0);  // Some(&1)
    let tenth = vec.get(9);  // None

    println!("ç¬¬ä¸€ä¸ª: {:?}", first);
    println!("ç¬¬åä¸ª: {:?}", tenth);
}
```

### 2.2 Optionæ–¹æ³•

Optionæä¾›ä¸°å¯Œçš„æ–¹æ³•ï¼š

```rust
fn main() {
    let some_num = Some(5);
    let no_num: Option<i32> = None;

    // unwrap_or: æä¾›é»˜è®¤å€¼
    let value = some_num.unwrap_or(0);
    println!("å€¼: {}", value);

    let value = no_num.unwrap_or(0);
    println!("é»˜è®¤å€¼: {}", value);

    // unwrap_or_else: æƒ°æ€§è®¡ç®—é»˜è®¤å€¼
    let value = no_num.unwrap_or_else(|| {
        println!("è®¡ç®—é»˜è®¤å€¼");
        42
    });
    println!("è®¡ç®—çš„å€¼: {}", value);

    // map: è½¬æ¢Optionå†…çš„å€¼
    let some_string = some_num.map(|n| n.to_string());
    println!("{:?}", some_string);  // Some("5")

    // and_then: é“¾å¼Optionæ“ä½œ
    let result = some_num.and_then(|n| {
        if n > 0 {
            Some(n * 2)
        } else {
            None
        }
    });
    println!("{:?}", result);  // Some(10)

    // filter: è¿‡æ»¤Option
    let filtered = some_num.filter(|&n| n > 3);
    println!("{:?}", filtered);  // Some(5)

    // is_some/is_none: æ£€æŸ¥çŠ¶æ€
    println!("æœ‰å€¼? {}", some_num.is_some());
    println!("æ— å€¼? {}", no_num.is_none());

    // take: å–å‡ºå€¼å¹¶ç•™ä¸‹None
    let mut opt = Some(42);
    let taken = opt.take();
    println!("å–å‡º: {:?}, å‰©ä½™: {:?}", taken, opt);

    // replace: æ›¿æ¢å€¼
    let mut opt = Some(5);
    let old = opt.replace(10);
    println!("æ—§å€¼: {:?}, æ–°å€¼: {:?}", old, opt);
}
```

### 2.3 ç»„åˆOption

ç»„åˆå¤šä¸ªOptionï¼š

```rust
fn main() {
    let x = Some(2);
    let y = Some(3);
    let z: Option<i32> = None;

    // ä½¿ç”¨andç»„åˆ
    let result = x.and(y);  // Some(3) - è¿”å›ç¬¬äºŒä¸ª
    println!("{:?}", result);

    let result = x.and(z);  // None - æœ‰ä¸€ä¸ªæ˜¯None
    println!("{:?}", result);

    // ä½¿ç”¨orç»„åˆ
    let result = x.or(y);  // Some(2) - è¿”å›ç¬¬ä¸€ä¸ªSome
    println!("{:?}", result);

    let result = z.or(y);  // Some(3) - ç¬¬ä¸€ä¸ªæ˜¯Noneï¼Œè¿”å›ç¬¬äºŒä¸ª
    println!("{:?}", result);

    // xor: å¼‚æˆ–
    let result = x.xor(y);  // None - ä¸¤ä¸ªéƒ½æ˜¯Some
    println!("{:?}", result);

    let result = x.xor(z);  // Some(2) - åªæœ‰ä¸€ä¸ªæ˜¯Some
    println!("{:?}", result);

    // zip: ç»„åˆä¸¤ä¸ªOptionä¸ºå…ƒç»„
    let result = x.zip(y);  // Some((2, 3))
    println!("{:?}", result);

    let result = x.zip(z);  // None - æœ‰ä¸€ä¸ªæ˜¯None
    println!("{:?}", result);
}
```

---

## 3. Resultç±»å‹

### 3.1 åŸºæœ¬ç”¨æ³•

Resultè¡¨ç¤ºå¯èƒ½å¤±è´¥çš„æ“ä½œï¼š

```rust
fn main() {
    // åˆ›å»ºResult
    let success: Result<i32, String> = Ok(42);
    let failure: Result<i32, String> = Err("å‡ºé”™äº†".to_string());

    // åŒ¹é…Result
    match success {
        Ok(value) => println!("æˆåŠŸ: {}", value),
        Err(error) => println!("é”™è¯¯: {}", error),
    }

    // if letç®€åŒ–
    if let Ok(value) = success {
        println!("å€¼: {}", value);
    }

    // æ ‡å‡†åº“ä¸­çš„Result
    let result = "42".parse::<i32>();
    match result {
        Ok(num) => println!("è§£ææˆåŠŸ: {}", num),
        Err(e) => println!("è§£æå¤±è´¥: {}", e),
    }
}
```

### 3.2 Resultæ–¹æ³•

Resultæä¾›ä¸°å¯Œçš„æ–¹æ³•ï¼š

```rust
fn main() {
    let ok: Result<i32, String> = Ok(10);
    let err: Result<i32, String> = Err("error".to_string());

    // unwrap_or: æä¾›é»˜è®¤å€¼
    let value = ok.unwrap_or(0);
    println!("æˆåŠŸå€¼: {}", value);

    let value = err.unwrap_or(0);
    println!("é”™è¯¯æ—¶çš„é»˜è®¤å€¼: {}", value);

    // unwrap_or_else: å¤„ç†é”™è¯¯
    let value = err.unwrap_or_else(|e| {
        println!("é”™è¯¯: {}", e);
        0
    });
    println!("å¤„ç†åçš„å€¼: {}", value);

    // map: è½¬æ¢æˆåŠŸå€¼
    let mapped = ok.map(|n| n * 2);
    println!("{:?}", mapped);  // Ok(20)

    // map_err: è½¬æ¢é”™è¯¯
    let mapped_err = err.map_err(|e| format!("é”™è¯¯: {}", e));
    println!("{:?}", mapped_err);

    // and_then: é“¾å¼æ“ä½œ
    let result = ok.and_then(|n| {
        if n > 5 {
            Ok(n * 2)
        } else {
            Err("too small".to_string())
        }
    });
    println!("{:?}", result);  // Ok(20)

    // or_else: é”™è¯¯æ¢å¤
    let recovered = err.or_else(|_| Ok(0));
    println!("{:?}", recovered);  // Ok(0)

    // is_ok/is_err: æ£€æŸ¥çŠ¶æ€
    println!("æˆåŠŸ? {}", ok.is_ok());
    println!("å¤±è´¥? {}", err.is_err());
}
```

### 3.3 ?æ“ä½œç¬¦

?æ“ä½œç¬¦ç®€åŒ–é”™è¯¯ä¼ æ’­ï¼š

```rust
use std::fs::File;
use std::io::{self, Read};

// æ˜¾å¼é”™è¯¯ä¼ æ’­ï¼ˆç¹çï¼‰
fn read_username_from_file_verbose() -> Result<String, io::Error> {
    let file_result = File::open("username.txt");

    let mut file = match file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}

// ä½¿ç”¨?æ“ä½œç¬¦ï¼ˆç®€æ´ï¼‰
fn read_username_from_file() -> Result<String, io::Error> {
    let mut file = File::open("username.txt")?;
    let mut username = String::new();
    file.read_to_string(&mut username)?;
    Ok(username)
}

// é“¾å¼?æ“ä½œç¬¦
fn read_username_chained() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("username.txt")?.read_to_string(&mut username)?;
    Ok(username)
}

// ?æ“ä½œç¬¦é€‚ç”¨äºOption
fn get_first_char(text: &str) -> Option<char> {
    text.chars().next()
}

fn get_first_word_first_char(text: &str) -> Option<char> {
    text.split_whitespace().next()?.chars().next()
}

fn main() {
    // ä½¿ç”¨ç¤ºä¾‹
    match read_username_from_file() {
        Ok(name) => println!("ç”¨æˆ·å: {}", name),
        Err(e) => println!("é”™è¯¯: {}", e),
    }

    let result = get_first_word_first_char("hello world");
    println!("ç¬¬ä¸€ä¸ªå­—ç¬¦: {:?}", result);
}
```

---

## 4. panicå®

### 4.1 ä½•æ—¶ä½¿ç”¨panic

panicåº”è¯¥ç”¨äºä¸å¯æ¢å¤çš„é”™è¯¯ï¼š

```rust
fn main() {
    // âœ… åˆç†ä½¿ç”¨panicçš„åœºæ™¯

    // 1. ä¸å˜é‡è¢«ç ´å
    fn new_positive(value: i32) -> i32 {
        if value <= 0 {
            panic!("å€¼å¿…é¡»ä¸ºæ­£æ•°ï¼");
        }
        value
    }

    // 2. æ•°ç»„è¶Šç•Œï¼ˆè‡ªåŠ¨panicï¼‰
    let arr = [1, 2, 3];
    // let _ = arr[10];  // ä¼španic

    // 3. æ•´æ•°æº¢å‡ºï¼ˆdebugæ¨¡å¼ä¼španicï¼‰
    // let x: u8 = 255;
    // let y = x + 1;  // debugæ¨¡å¼panic

    // 4. ç¤ºä¾‹å’ŒåŸå‹ä»£ç 
    // let value = "not a number".parse::<i32>().unwrap();

    // âŒ ä¸åº”è¯¥panicçš„åœºæ™¯

    // 1. å¯æ¢å¤çš„é”™è¯¯åº”è¯¥ç”¨Result
    fn divide_bad(a: i32, b: i32) -> i32 {
        if b == 0 {
            panic!("é™¤æ•°ä¸èƒ½ä¸ºé›¶");  // ä¸å¥½
        }
        a / b
    }

    fn divide_good(a: i32, b: i32) -> Result<i32, String> {
        if b == 0 {
            Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())  // å¥½
        } else {
            Ok(a / b)
        }
    }

    let _ = divide_good(10, 2);
}
```

### 4.2 unwrapå’Œexpect

unwrapå’Œexpectä¼šåœ¨é”™è¯¯æ—¶panicï¼š

```rust
fn main() {
    // unwrap: æˆåŠŸè¿”å›å€¼ï¼Œå¤±è´¥panic
    let ok: Result<i32, String> = Ok(42);
    let value = ok.unwrap();
    println!("å€¼: {}", value);

    // let err: Result<i32, String> = Err("error".to_string());
    // let value = err.unwrap();  // panic: "error"

    // expect: å¸¦è‡ªå®šä¹‰æ¶ˆæ¯çš„unwrap
    let value = ok.expect("åº”è¯¥æœ‰å€¼");
    println!("å€¼: {}", value);

    // let value = err.expect("æœŸæœ›æˆåŠŸ");  // panic: "æœŸæœ›æˆåŠŸ: error"

    // Optionçš„unwrap
    let some = Some(5);
    let value = some.unwrap();
    println!("Optionå€¼: {}", value);

    // let none: Option<i32> = None;
    // let value = none.unwrap();  // panic: "called `Option::unwrap()` on a `None` value"

    // æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ
    let result: Result<i32, String> = Err("error".to_string());

    // ä½¿ç”¨unwrap_or
    let value = result.unwrap_or(0);
    println!("å®‰å…¨çš„å€¼: {}", value);

    // ä½¿ç”¨unwrap_or_default
    let value = result.unwrap_or_default();
    println!("é»˜è®¤å€¼: {}", value);
}
```

### 4.3 panicå¤„ç†

è®¾ç½®panic hookï¼š

```rust
use std::panic;

fn main() {
    // è®¾ç½®è‡ªå®šä¹‰panic hook
    panic::set_hook(Box::new(|panic_info| {
        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            println!("panicæ¶ˆæ¯: {}", s);
        }

        if let Some(location) = panic_info.location() {
            println!("panicä½ç½®: {}:{}", location.file(), location.line());
        }
    }));

    // æ•è·panic
    let result = panic::catch_unwind(|| {
        println!("å¯èƒ½panicçš„ä»£ç ");
        // panic!("æµ‹è¯•panic");
        42
    });

    match result {
        Ok(value) => println!("æˆåŠŸ: {}", value),
        Err(_) => println!("æ•è·åˆ°panic"),
    }
}
```

---

## 5. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### 5.1 ç®€å•é”™è¯¯ç±»å‹

åˆ›å»ºç®€å•çš„é”™è¯¯ç±»å‹ï¼š

```rust
// æšä¸¾é”™è¯¯
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    NegativeSquareRoot,
}

fn divide(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

fn sqrt(x: f64) -> Result<f64, MathError> {
    if x < 0.0 {
        Err(MathError::NegativeSquareRoot)
    } else {
        Ok(x.sqrt())
    }
}

fn main() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("ç»“æœ: {}", result),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    match sqrt(-1.0) {
        Ok(result) => println!("å¹³æ–¹æ ¹: {}", result),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }
}
```

### 5.2 Error trait

å®ç°Error traitï¼š

```rust
use std::fmt;
use std::error::Error;

#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    Custom(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::IoError(e) => write!(f, "IOé”™è¯¯: {}", e),
            AppError::ParseError(e) => write!(f, "è§£æé”™è¯¯: {}", e),
            AppError::Custom(msg) => write!(f, "è‡ªå®šä¹‰é”™è¯¯: {}", msg),
        }
    }
}

impl Error for AppError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            AppError::IoError(e) => Some(e),
            AppError::ParseError(e) => Some(e),
            AppError::Custom(_) => None,
        }
    }
}

fn main() {
    let error = AppError::Custom("something went wrong".to_string());
    println!("é”™è¯¯: {}", error);

    if let Some(source) = error.source() {
        println!("é”™è¯¯æº: {}", source);
    }
}
```

### 5.3 é”™è¯¯è½¬æ¢

ä½¿ç”¨Fromå®ç°é”™è¯¯è½¬æ¢ï¼š

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

// è‡ªåŠ¨è½¬æ¢io::Error
impl From<io::Error> for MyError {
    fn from(error: io::Error) -> Self {
        MyError::Io(error)
    }
}

// è‡ªåŠ¨è½¬æ¢ParseIntError
impl From<ParseIntError> for MyError {
    fn from(error: ParseIntError) -> Self {
        MyError::Parse(error)
    }
}

// ç°åœ¨å¯ä»¥ä½¿ç”¨?è‡ªåŠ¨è½¬æ¢
fn read_and_parse() -> Result<i32, MyError> {
    let content = std::fs::read_to_string("number.txt")?;  // io::Errorè‡ªåŠ¨è½¬æ¢
    let number = content.trim().parse()?;  // ParseIntErrorè‡ªåŠ¨è½¬æ¢
    Ok(number)
}

fn main() {
    match read_and_parse() {
        Ok(num) => println!("æ•°å­—: {}", num),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }
}
```

---

## 6. é”™è¯¯ä¼ æ’­

### 6.1 æ˜¾å¼ä¼ æ’­

æ‰‹åŠ¨ä¼ æ’­é”™è¯¯ï¼š

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_manual(path: &str) -> Result<String, io::Error> {
    let file = File::open(path);

    let mut file = match file {
        Ok(f) => f,
        Err(e) => return Err(e),
    };

    let mut contents = String::new();

    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

fn main() {
    match read_file_manual("test.txt") {
        Ok(content) => println!("å†…å®¹: {}", content),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

### 6.2 ?æ“ä½œç¬¦é“¾

é“¾å¼ä½¿ç”¨?æ“ä½œç¬¦ï¼š

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_chain(path: &str) -> Result<String, io::Error> {
    let mut contents = String::new();
    File::open(path)?.read_to_string(&mut contents)?;
    Ok(contents)
}

// æ›´ç®€æ´çš„ç‰ˆæœ¬
fn read_file_simple(path: &str) -> Result<String, io::Error> {
    std::fs::read_to_string(path)
}

fn main() {
    match read_file_chain("test.txt") {
        Ok(content) => println!("å†…å®¹: {}", content),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

### 6.3 å¤šç§é”™è¯¯ç±»å‹

å¤„ç†å¤šç§é”™è¯¯ç±»å‹ï¼š

```rust
use std::fs;
use std::io;

// æ–¹å¼1: æšä¸¾æ‰€æœ‰é”™è¯¯
#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(std::num::ParseIntError),
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

fn process_file(path: &str) -> Result<i32, AppError> {
    let content = fs::read_to_string(path)?;
    let number = content.trim().parse()?;
    Ok(number)
}

// æ–¹å¼2: ä½¿ç”¨Box<dyn Error>
fn process_file_boxed(path: &str) -> Result<i32, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(path)?;
    let number = content.trim().parse()?;
    Ok(number)
}

fn main() {
    match process_file("number.txt") {
        Ok(num) => println!("æ•°å­—: {}", num),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: æ–‡ä»¶æ“ä½œ

```rust
use std::fs::File;
use std::io::{self, Read, Write};
use std::path::Path;

#[derive(Debug)]
enum FileError {
    NotFound(String),
    PermissionDenied(String),
    Other(io::Error),
}

impl From<io::Error> for FileError {
    fn from(error: io::Error) -> Self {
        match error.kind() {
            io::ErrorKind::NotFound => {
                FileError::NotFound(error.to_string())
            },
            io::ErrorKind::PermissionDenied => {
                FileError::PermissionDenied(error.to_string())
            },
            _ => FileError::Other(error),
        }
    }
}

fn read_config(path: &str) -> Result<String, FileError> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn write_config(path: &str, content: &str) -> Result<(), FileError> {
    let mut file = File::create(path)?;
    file.write_all(content.as_bytes())?;
    Ok(())
}

fn safe_read_or_create(path: &str, default: &str) -> Result<String, FileError> {
    match read_config(path) {
        Ok(content) => Ok(content),
        Err(FileError::NotFound(_)) => {
            write_config(path, default)?;
            Ok(default.to_string())
        },
        Err(e) => Err(e),
    }
}

fn main() {
    match safe_read_or_create("config.txt", "default config") {
        Ok(content) => println!("é…ç½®: {}", content),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }
}
```

### æ¡ˆä¾‹2: ç½‘ç»œè¯·æ±‚

```rust
#[derive(Debug)]
enum NetworkError {
    Timeout,
    ConnectionFailed(String),
    InvalidResponse,
    HttpError(u16),
}

struct Response {
    status: u16,
    body: String,
}

fn make_request(url: &str) -> Result<Response, NetworkError> {
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
    if url.is_empty() {
        return Err(NetworkError::ConnectionFailed("URLä¸ºç©º".to_string()));
    }

    // æ¨¡æ‹ŸæˆåŠŸå“åº”
    Ok(Response {
        status: 200,
        body: "å“åº”æ•°æ®".to_string(),
    })
}

fn fetch_with_retry(url: &str, max_retries: u32) -> Result<Response, NetworkError> {
    let mut attempts = 0;

    loop {
        attempts += 1;

        match make_request(url) {
            Ok(response) => return Ok(response),
            Err(NetworkError::Timeout) if attempts < max_retries => {
                println!("è¶…æ—¶ï¼Œé‡è¯• {}/{}", attempts, max_retries);
                continue;
            },
            Err(e) => return Err(e),
        }
    }
}

fn main() {
    match fetch_with_retry("https://example.com", 3) {
        Ok(response) => println!("çŠ¶æ€: {}, å†…å®¹: {}", response.status, response.body),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }
}
```

### æ¡ˆä¾‹3: é…ç½®ç®¡ç†

```rust
use std::collections::HashMap;

#[derive(Debug)]
enum ConfigError {
    KeyNotFound(String),
    InvalidType(String),
    ParseError(String),
}

struct Config {
    data: HashMap<String, String>,
}

impl Config {
    fn new() -> Self {
        Config {
            data: HashMap::new(),
        }
    }

    fn set(&mut self, key: String, value: String) {
        self.data.insert(key, value);
    }

    fn get_string(&self, key: &str) -> Result<&str, ConfigError> {
        self.data
            .get(key)
            .map(|s| s.as_str())
            .ok_or_else(|| ConfigError::KeyNotFound(key.to_string()))
    }

    fn get_int(&self, key: &str) -> Result<i32, ConfigError> {
        let value = self.get_string(key)?;
        value
            .parse()
            .map_err(|_| ConfigError::ParseError(format!("æ— æ³•è§£æ '{}' ä¸ºæ•´æ•°", value)))
    }

    fn get_bool(&self, key: &str) -> Result<bool, ConfigError> {
        let value = self.get_string(key)?;
        match value.to_lowercase().as_str() {
            "true" | "yes" | "1" => Ok(true),
            "false" | "no" | "0" => Ok(false),
            _ => Err(ConfigError::ParseError(format!(
                "æ— æ³•è§£æ '{}' ä¸ºå¸ƒå°”å€¼",
                value
            ))),
        }
    }
}

fn main() {
    let mut config = Config::new();
    config.set("name".to_string(), "MyApp".to_string());
    config.set("port".to_string(), "8080".to_string());
    config.set("debug".to_string(), "true".to_string());

    match config.get_string("name") {
        Ok(name) => println!("åº”ç”¨å: {}", name),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    match config.get_int("port") {
        Ok(port) => println!("ç«¯å£: {}", port),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }

    match config.get_bool("debug") {
        Ok(debug) => println!("è°ƒè¯•æ¨¡å¼: {}", debug),
        Err(e) => println!("é”™è¯¯: {:?}", e),
    }
}
```

### æ¡ˆä¾‹4: æ•°æ®éªŒè¯

```rust
#[derive(Debug)]
enum ValidationError {
    TooShort { field: String, min: usize },
    TooLong { field: String, max: usize },
    InvalidFormat { field: String, reason: String },
    Required(String),
}

struct User {
    username: String,
    email: String,
    age: u32,
}

fn validate_username(username: &str) -> Result<(), ValidationError> {
    if username.is_empty() {
        return Err(ValidationError::Required("username".to_string()));
    }

    if username.len() < 3 {
        return Err(ValidationError::TooShort {
            field: "username".to_string(),
            min: 3,
        });
    }

    if username.len() > 20 {
        return Err(ValidationError::TooLong {
            field: "username".to_string(),
            max: 20,
        });
    }

    if !username.chars().all(|c| c.is_alphanumeric() || c == '_') {
        return Err(ValidationError::InvalidFormat {
            field: "username".to_string(),
            reason: "åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿".to_string(),
        });
    }

    Ok(())
}

fn validate_email(email: &str) -> Result<(), ValidationError> {
    if email.is_empty() {
        return Err(ValidationError::Required("email".to_string()));
    }

    if !email.contains('@') {
        return Err(ValidationError::InvalidFormat {
            field: "email".to_string(),
            reason: "å¿…é¡»åŒ…å«@ç¬¦å·".to_string(),
        });
    }

    Ok(())
}

fn validate_age(age: u32) -> Result<(), ValidationError> {
    if age < 18 {
        return Err(ValidationError::InvalidFormat {
            field: "age".to_string(),
            reason: "å¿…é¡»å¹´æ»¡18å²".to_string(),
        });
    }

    Ok(())
}

fn create_user(username: &str, email: &str, age: u32) -> Result<User, Vec<ValidationError>> {
    let mut errors = Vec::new();

    if let Err(e) = validate_username(username) {
        errors.push(e);
    }

    if let Err(e) = validate_email(email) {
        errors.push(e);
    }

    if let Err(e) = validate_age(age) {
        errors.push(e);
    }

    if !errors.is_empty() {
        return Err(errors);
    }

    Ok(User {
        username: username.to_string(),
        email: email.to_string(),
        age,
    })
}

fn main() {
    match create_user("alice", "alice@example.com", 25) {
        Ok(user) => println!("ç”¨æˆ·åˆ›å»ºæˆåŠŸ: {}", user.username),
        Err(errors) => {
            println!("éªŒè¯å¤±è´¥:");
            for error in errors {
                println!("  {:?}", error);
            }
        },
    }

    match create_user("ab", "invalid-email", 16) {
        Ok(user) => println!("ç”¨æˆ·åˆ›å»ºæˆåŠŸ: {}", user.username),
        Err(errors) => {
            println!("éªŒè¯å¤±è´¥:");
            for error in errors {
                println!("  {:?}", error);
            }
        },
    }
}
```

### 7.5 è¾¹ç•Œæ¡ˆä¾‹ä¸è¿›é˜¶

#### From/Into é”™è¯¯æ˜ å°„

`From` ä½¿ `?` èƒ½è‡ªåŠ¨è½¬æ¢é”™è¯¯ç±»å‹ï¼›`Into` ç”± `From` è‡ªåŠ¨å®ç°ï¼š

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
}

impl From<io::Error> for AppError {
    fn from(e: io::Error) -> Self { AppError::Io(e) }
}
impl From<ParseIntError> for AppError {
    fn from(e: ParseIntError) -> Self { AppError::Parse(e) }
}

// ? è‡ªåŠ¨è°ƒç”¨ Into::intoï¼Œå°† io::Error/ParseIntError è½¬ä¸º AppError
fn load_config(path: &str) -> Result<i32, AppError> {
    let s = std::fs::read_to_string(path)?;
    Ok(s.trim().parse()?)
}
```

#### anyhow vs thiserror é€‰å‹

| åœºæ™¯ | æ¨è | è¯´æ˜ |
| :--- | :--- | :--- || åº”ç”¨å±‚ï¼ˆmainã€äºŒè¿›åˆ¶ï¼‰ | **anyhow** | `Result<T, anyhow::Error>`ï¼Œä¾¿äºå¿«é€Ÿä¼ æ’­ã€æ·»åŠ ä¸Šä¸‹æ–‡ |
| åº“/API å±‚ | **thiserror** | å®šä¹‰ç»“æ„åŒ–é”™è¯¯ç±»å‹ï¼Œä¾¿äºè°ƒç”¨æ–¹åŒ¹é…ä¸å¤„ç† |
| ç»„åˆä½¿ç”¨ | å¸¸è§ | åº“ç”¨ thiserror å®šä¹‰é”™è¯¯ï¼Œåº”ç”¨ç”¨ anyhow åŒ…è£… |

```rust
// åº“ï¼ˆéœ€ thiserrorï¼‰ï¼š#[derive(Error)] pub enum LibError { Io(#[from] std::io::Error) }
// åº”ç”¨ï¼ˆéœ€ anyhowï¼‰ï¼šfn main() -> Result<(), anyhow::Error> { ... }
```

è¯¦è§ [é”™è¯¯å¤„ç†è¿›é˜¶](../tier_04_advanced/04_é”™è¯¯å¤„ç†è¿›é˜¶.md)ã€‚

#### æ—©è¿”å›ä¸ RAII

**æ—©è¿”å›**ï¼šé‡é”™å³ `return Err(...)`ï¼Œé¿å…æ·±å±‚åµŒå¥—ï¼š

```rust
fn process(path: &str) -> Result<String, std::io::Error> {
    let f = std::fs::File::open(path)?;  // å¤±è´¥åˆ™æ—©è¿”å›
    let mut s = String::new();
    use std::io::Read;
    f.take(1024).read_to_string(&mut s)?;
    Ok(s)
}
```

**RAII**ï¼šèµ„æºåœ¨ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾ï¼Œå³ä½¿å‘ç”Ÿé”™è¯¯æˆ– panic ä¹Ÿèƒ½ä¿è¯æ¸…ç†ï¼š

```rust
struct Guard;
impl Drop for Guard {
    fn drop(&mut self) { println!("èµ„æºå·²é‡Šæ”¾"); }
}

fn with_guard() -> Result<(), std::io::Error> {
    let _g = Guard;
    std::fs::read_to_string("x.txt")?;  // å‡ºé”™æ—¶ _g ä»ä¼š drop
    Ok(())
}
```

è¯¦è§ [é”™è¯¯å¤„ç†è¿›é˜¶ - RAII æ¨¡å¼](../tier_04_advanced/04_é”™è¯¯å¤„ç†è¿›é˜¶.md#5-å¼‚å¸¸å®‰å…¨æ€§)ã€‚

---

## 8. æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨Resultè€Œépanic**
2. **ä¸ºå…¬å…±APIè®¾è®¡è‰¯å¥½çš„é”™è¯¯ç±»å‹**
3. **ä½¿ç”¨?æ“ä½œç¬¦ç®€åŒ–é”™è¯¯ä¼ æ’­**
4. **ä¸ºé”™è¯¯æä¾›ä¸Šä¸‹æ–‡ä¿¡æ¯**
5. **å®ç°Error traitæä¾›å®Œæ•´é”™è¯¯ä¿¡æ¯**
6. **è€ƒè™‘é”™è¯¯æ¢å¤ç­–ç•¥**
7. **åœ¨é€‚å½“çš„å±‚çº§å¤„ç†é”™è¯¯**
8. **ä¸ºåº“ç”¨æˆ·æä¾›é”™è¯¯æ–‡æ¡£**

---

## 9. å¸¸è§é™·é˜±

```rust
fn main() {
    // âŒ é™·é˜±1: è¿‡åº¦ä½¿ç”¨unwrap
    // let value = some_result.unwrap();  // å¯èƒ½panic

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨?æˆ–matchå¤„ç†
    fn process() -> Result<(), String> {
        let value = some_result()?;
        Ok(())
    }

    fn some_result() -> Result<i32, String> {
        Ok(42)
    }

    // âŒ é™·é˜±2: å¿½ç•¥é”™è¯¯
    // let _ = some_fallible_operation();  // é”™è¯¯è¢«å¿½ç•¥

    // âœ… æ­£ç¡®ï¼šå¤„ç†æˆ–ä¼ æ’­é”™è¯¯
    match some_fallible_operation() {
        Ok(_) => {},
        Err(e) => eprintln!("è­¦å‘Š: {}", e),
    }

    fn some_fallible_operation() -> Result<(), String> {
        Ok(())
    }

    // âŒ é™·é˜±3: ä½¿ç”¨Stringä½œä¸ºé”™è¯¯ç±»å‹
    // fn bad() -> Result<(), String> { ... }

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ä¸“é—¨çš„é”™è¯¯ç±»å‹
    #[derive(Debug)]
    enum MyError {
        IoError,
        ParseError,
    }

    fn good() -> Result<(), MyError> {
        Ok(())
    }

    let _ = process();
    let _ = good();
}
```

---

## 10. å°ç»“

- Resultå’ŒOptionæ˜¯Rusté”™è¯¯å¤„ç†çš„æ ¸å¿ƒ
- ?æ“ä½œç¬¦ç®€åŒ–é”™è¯¯ä¼ æ’­
- panicç”¨äºä¸å¯æ¢å¤çš„é”™è¯¯
- è‡ªå®šä¹‰é”™è¯¯ç±»å‹æä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯
- é”™è¯¯å¤„ç†æ˜¯ä»£ç è´¨é‡çš„é‡è¦ç»„æˆéƒ¨åˆ†

---

## 11. å»¶ä¼¸é˜…è¯»

**å†…éƒ¨æ–‡æ¡£**:

- [æ¡ä»¶è¯­å¥æŒ‡å—](./01_æ¡ä»¶è¯­å¥æŒ‡å—.md)
- [æ¨¡å¼åŒ¹é…æŒ‡å—](./04_æ¨¡å¼åŒ¹é…æŒ‡å—.md)
- [é”™è¯¯å¤„ç†è¿›é˜¶](../tier_04_advanced/04_é”™è¯¯å¤„ç†è¿›é˜¶.md)

**å¤–éƒ¨èµ„æº**:

- [Rust Book - Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [Rust by Example - Error Handling](https://doc.rust-lang.org/rust-by-example/error.html)
- [anyhow crate](https://docs.rs/anyhow/)
- [thiserror crate](https://docs.rs/thiserror/)

---

## 12. ç»ƒä¹ é¢˜

1. å®ç°ä¸€ä¸ªæ–‡ä»¶è¯»å–å‡½æ•°ï¼Œå¤„ç†å„ç§IOé”™è¯¯
2. åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼ŒåŒ…å«å¤šç§é”™è¯¯æƒ…å†µ
3. ç¼–å†™ä¸€ä¸ªæ•°æ®éªŒè¯ç³»ç»Ÿï¼Œæ”¶é›†æ‰€æœ‰éªŒè¯é”™è¯¯
4. å®ç°å¸¦é‡è¯•æœºåˆ¶çš„ç½‘ç»œè¯·æ±‚å‡½æ•°
5. è®¾è®¡ä¸€ä¸ªé…ç½®ç®¡ç†å™¨ï¼Œæ”¯æŒç±»å‹å®‰å…¨çš„é…ç½®è®¿é—®

---

**æœ€åæ›´æ–°**: 2025-12-11
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ¯ æŒæ¡Rusté”™è¯¯å¤„ç†ï¼Œç¼–å†™å¥å£®å¯é çš„ä»£ç ï¼** ğŸ¦€âœ¨
