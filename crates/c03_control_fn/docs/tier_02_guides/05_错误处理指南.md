# 2.5 错误处理指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统化学习Rust错误处理，掌握Result/Option/panic机制  
> **学习时间**: 1-2天  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [项目概览](../tier_01_foundations/01_项目概览.md)


## 📊 目录

- [2.5 错误处理指南](#25-错误处理指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. 错误处理基础](#1-错误处理基础)
    - [1.1 可恢复错误vs不可恢复错误](#11-可恢复错误vs不可恢复错误)
    - [1.2 错误处理哲学](#12-错误处理哲学)
  - [2. Option类型](#2-option类型)
    - [2.1 基本用法](#21-基本用法)
    - [2.2 Option方法](#22-option方法)
    - [2.3 组合Option](#23-组合option)
  - [3. Result类型](#3-result类型)
    - [3.1 基本用法](#31-基本用法)
    - [3.2 Result方法](#32-result方法)
    - [3.3 ?操作符](#33-操作符)
  - [4. panic宏](#4-panic宏)
    - [4.1 何时使用panic](#41-何时使用panic)
    - [4.2 unwrap和expect](#42-unwrap和expect)
    - [4.3 panic处理](#43-panic处理)
  - [5. 自定义错误类型](#5-自定义错误类型)
    - [5.1 简单错误类型](#51-简单错误类型)
    - [5.2 Error trait](#52-error-trait)
    - [5.3 错误转换](#53-错误转换)
  - [6. 错误传播](#6-错误传播)
    - [6.1 显式传播](#61-显式传播)
    - [6.2 ?操作符链](#62-操作符链)
    - [6.3 多种错误类型](#63-多种错误类型)
  - [7. 实战案例](#7-实战案例)
    - [案例1: 文件操作](#案例1-文件操作)
    - [案例2: 网络请求](#案例2-网络请求)
    - [案例3: 配置管理](#案例3-配置管理)
    - [案例4: 数据验证](#案例4-数据验证)
  - [8. 最佳实践](#8-最佳实践)
  - [9. 常见陷阱](#9-常见陷阱)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)


**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [2.5 错误处理指南](#25-错误处理指南)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. 错误处理基础](#1-错误处理基础)
    - [1.1 可恢复错误vs不可恢复错误](#11-可恢复错误vs不可恢复错误)
    - [1.2 错误处理哲学](#12-错误处理哲学)
  - [2. Option类型](#2-option类型)
    - [2.1 基本用法](#21-基本用法)
    - [2.2 Option方法](#22-option方法)
    - [2.3 组合Option](#23-组合option)
  - [3. Result类型](#3-result类型)
    - [3.1 基本用法](#31-基本用法)
    - [3.2 Result方法](#32-result方法)
    - [3.3 ?操作符](#33-操作符)
  - [4. panic宏](#4-panic宏)
    - [4.1 何时使用panic](#41-何时使用panic)
    - [4.2 unwrap和expect](#42-unwrap和expect)
    - [4.3 panic处理](#43-panic处理)
  - [5. 自定义错误类型](#5-自定义错误类型)
    - [5.1 简单错误类型](#51-简单错误类型)
    - [5.2 Error trait](#52-error-trait)
    - [5.3 错误转换](#53-错误转换)
  - [6. 错误传播](#6-错误传播)
    - [6.1 显式传播](#61-显式传播)
    - [6.2 ?操作符链](#62-操作符链)
    - [6.3 多种错误类型](#63-多种错误类型)
  - [7. 实战案例](#7-实战案例)
    - [案例1: 文件操作](#案例1-文件操作)
    - [案例2: 网络请求](#案例2-网络请求)
    - [案例3: 配置管理](#案例3-配置管理)
    - [案例4: 数据验证](#案例4-数据验证)
  - [8. 最佳实践](#8-最佳实践)
  - [9. 常见陷阱](#9-常见陷阱)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)

---

## 🎯 学习目标

完成本指南学习后，您将能够：

- ✅ 理解Rust错误处理机制
- ✅ 熟练使用Option和Result
- ✅ 掌握?操作符和错误传播
- ✅ 设计自定义错误类型
- ✅ 编写健壮的错误处理代码
- ✅ 选择合适的错误处理策略

---

## 1. 错误处理基础

### 1.1 可恢复错误vs不可恢复错误

Rust将错误分为两类：

```rust
fn main() {
    // 可恢复错误：使用Result
    let result = std::fs::read_to_string("file.txt");
    match result {
        Ok(content) => println!("内容: {}", content),
        Err(error) => println!("错误: {}", error),
    }
    
    // 不可恢复错误：使用panic
    // panic!("致命错误！");  // 程序会终止
    
    // 可能为空的值：使用Option
    let numbers = vec![1, 2, 3];
    match numbers.get(10) {
        Some(value) => println!("值: {}", value),
        None => println!("索引越界"),
    }
}
```

**关键区别**:

- **Result**: 表示可能失败的操作
- **Option**: 表示可能不存在的值
- **panic**: 表示不可恢复的错误

### 1.2 错误处理哲学

Rust的错误处理原则：

```rust
fn main() {
    // 原则1: 显式处理错误
    fn divide(a: i32, b: i32) -> Result<i32, String> {
        if b == 0 {
            Err("除数不能为零".to_string())
        } else {
            Ok(a / b)
        }
    }
    
    // 原则2: 错误是值
    let result = divide(10, 2);
    match result {
        Ok(value) => println!("结果: {}", value),
        Err(e) => println!("错误: {}", e),
    }
    
    // 原则3: 类型安全
    fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
        s.parse()  // 编译器知道具体错误类型
    }
    
    // 原则4: 零成本抽象
    // Result和Option在运行时没有额外开销
}
```

---

## 2. Option类型

### 2.1 基本用法

Option表示可能不存在的值：

```rust
fn main() {
    // 创建Option
    let some_number = Some(5);
    let no_number: Option<i32> = None;
    
    // 匹配Option
    match some_number {
        Some(n) => println!("有数字: {}", n),
        None => println!("没有数字"),
    }
    
    // if let简化
    if let Some(n) = some_number {
        println!("数字是: {}", n);
    }
    
    // 从集合获取Option
    let vec = vec![1, 2, 3];
    let first = vec.get(0);  // Some(&1)
    let tenth = vec.get(9);  // None
    
    println!("第一个: {:?}", first);
    println!("第十个: {:?}", tenth);
}
```

### 2.2 Option方法

Option提供丰富的方法：

```rust
fn main() {
    let some_num = Some(5);
    let no_num: Option<i32> = None;
    
    // unwrap_or: 提供默认值
    let value = some_num.unwrap_or(0);
    println!("值: {}", value);
    
    let value = no_num.unwrap_or(0);
    println!("默认值: {}", value);
    
    // unwrap_or_else: 惰性计算默认值
    let value = no_num.unwrap_or_else(|| {
        println!("计算默认值");
        42
    });
    println!("计算的值: {}", value);
    
    // map: 转换Option内的值
    let some_string = some_num.map(|n| n.to_string());
    println!("{:?}", some_string);  // Some("5")
    
    // and_then: 链式Option操作
    let result = some_num.and_then(|n| {
        if n > 0 {
            Some(n * 2)
        } else {
            None
        }
    });
    println!("{:?}", result);  // Some(10)
    
    // filter: 过滤Option
    let filtered = some_num.filter(|&n| n > 3);
    println!("{:?}", filtered);  // Some(5)
    
    // is_some/is_none: 检查状态
    println!("有值? {}", some_num.is_some());
    println!("无值? {}", no_num.is_none());
    
    // take: 取出值并留下None
    let mut opt = Some(42);
    let taken = opt.take();
    println!("取出: {:?}, 剩余: {:?}", taken, opt);
    
    // replace: 替换值
    let mut opt = Some(5);
    let old = opt.replace(10);
    println!("旧值: {:?}, 新值: {:?}", old, opt);
}
```

### 2.3 组合Option

组合多个Option：

```rust
fn main() {
    let x = Some(2);
    let y = Some(3);
    let z: Option<i32> = None;
    
    // 使用and组合
    let result = x.and(y);  // Some(3) - 返回第二个
    println!("{:?}", result);
    
    let result = x.and(z);  // None - 有一个是None
    println!("{:?}", result);
    
    // 使用or组合
    let result = x.or(y);  // Some(2) - 返回第一个Some
    println!("{:?}", result);
    
    let result = z.or(y);  // Some(3) - 第一个是None，返回第二个
    println!("{:?}", result);
    
    // xor: 异或
    let result = x.xor(y);  // None - 两个都是Some
    println!("{:?}", result);
    
    let result = x.xor(z);  // Some(2) - 只有一个是Some
    println!("{:?}", result);
    
    // zip: 组合两个Option为元组
    let result = x.zip(y);  // Some((2, 3))
    println!("{:?}", result);
    
    let result = x.zip(z);  // None - 有一个是None
    println!("{:?}", result);
}
```

---

## 3. Result类型

### 3.1 基本用法

Result表示可能失败的操作：

```rust
fn main() {
    // 创建Result
    let success: Result<i32, String> = Ok(42);
    let failure: Result<i32, String> = Err("出错了".to_string());
    
    // 匹配Result
    match success {
        Ok(value) => println!("成功: {}", value),
        Err(error) => println!("错误: {}", error),
    }
    
    // if let简化
    if let Ok(value) = success {
        println!("值: {}", value);
    }
    
    // 标准库中的Result
    let result = "42".parse::<i32>();
    match result {
        Ok(num) => println!("解析成功: {}", num),
        Err(e) => println!("解析失败: {}", e),
    }
}
```

### 3.2 Result方法

Result提供丰富的方法：

```rust
fn main() {
    let ok: Result<i32, String> = Ok(10);
    let err: Result<i32, String> = Err("error".to_string());
    
    // unwrap_or: 提供默认值
    let value = ok.unwrap_or(0);
    println!("成功值: {}", value);
    
    let value = err.unwrap_or(0);
    println!("错误时的默认值: {}", value);
    
    // unwrap_or_else: 处理错误
    let value = err.unwrap_or_else(|e| {
        println!("错误: {}", e);
        0
    });
    println!("处理后的值: {}", value);
    
    // map: 转换成功值
    let mapped = ok.map(|n| n * 2);
    println!("{:?}", mapped);  // Ok(20)
    
    // map_err: 转换错误
    let mapped_err = err.map_err(|e| format!("错误: {}", e));
    println!("{:?}", mapped_err);
    
    // and_then: 链式操作
    let result = ok.and_then(|n| {
        if n > 5 {
            Ok(n * 2)
        } else {
            Err("too small".to_string())
        }
    });
    println!("{:?}", result);  // Ok(20)
    
    // or_else: 错误恢复
    let recovered = err.or_else(|_| Ok(0));
    println!("{:?}", recovered);  // Ok(0)
    
    // is_ok/is_err: 检查状态
    println!("成功? {}", ok.is_ok());
    println!("失败? {}", err.is_err());
}
```

### 3.3 ?操作符

?操作符简化错误传播：

```rust
use std::fs::File;
use std::io::{self, Read};

// 显式错误传播（繁琐）
fn read_username_from_file_verbose() -> Result<String, io::Error> {
    let file_result = File::open("username.txt");
    
    let mut file = match file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    
    let mut username = String::new();
    
    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}

// 使用?操作符（简洁）
fn read_username_from_file() -> Result<String, io::Error> {
    let mut file = File::open("username.txt")?;
    let mut username = String::new();
    file.read_to_string(&mut username)?;
    Ok(username)
}

// 链式?操作符
fn read_username_chained() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("username.txt")?.read_to_string(&mut username)?;
    Ok(username)
}

// ?操作符适用于Option
fn get_first_char(text: &str) -> Option<char> {
    text.chars().next()
}

fn get_first_word_first_char(text: &str) -> Option<char> {
    text.split_whitespace().next()?.chars().next()
}

fn main() {
    // 使用示例
    match read_username_from_file() {
        Ok(name) => println!("用户名: {}", name),
        Err(e) => println!("错误: {}", e),
    }
    
    let result = get_first_word_first_char("hello world");
    println!("第一个字符: {:?}", result);
}
```

---

## 4. panic宏

### 4.1 何时使用panic

panic应该用于不可恢复的错误：

```rust
fn main() {
    // ✅ 合理使用panic的场景
    
    // 1. 不变量被破坏
    fn new_positive(value: i32) -> i32 {
        if value <= 0 {
            panic!("值必须为正数！");
        }
        value
    }
    
    // 2. 数组越界（自动panic）
    let arr = [1, 2, 3];
    // let _ = arr[10];  // 会panic
    
    // 3. 整数溢出（debug模式会panic）
    // let x: u8 = 255;
    // let y = x + 1;  // debug模式panic
    
    // 4. 示例和原型代码
    // let value = "not a number".parse::<i32>().unwrap();
    
    // ❌ 不应该panic的场景
    
    // 1. 可恢复的错误应该用Result
    fn divide_bad(a: i32, b: i32) -> i32 {
        if b == 0 {
            panic!("除数不能为零");  // 不好
        }
        a / b
    }
    
    fn divide_good(a: i32, b: i32) -> Result<i32, String> {
        if b == 0 {
            Err("除数不能为零".to_string())  // 好
        } else {
            Ok(a / b)
        }
    }
    
    let _ = divide_good(10, 2);
}
```

### 4.2 unwrap和expect

unwrap和expect会在错误时panic：

```rust
fn main() {
    // unwrap: 成功返回值，失败panic
    let ok: Result<i32, String> = Ok(42);
    let value = ok.unwrap();
    println!("值: {}", value);
    
    // let err: Result<i32, String> = Err("error".to_string());
    // let value = err.unwrap();  // panic: "error"
    
    // expect: 带自定义消息的unwrap
    let value = ok.expect("应该有值");
    println!("值: {}", value);
    
    // let value = err.expect("期望成功");  // panic: "期望成功: error"
    
    // Option的unwrap
    let some = Some(5);
    let value = some.unwrap();
    println!("Option值: {}", value);
    
    // let none: Option<i32> = None;
    // let value = none.unwrap();  // panic: "called `Option::unwrap()` on a `None` value"
    
    // 更安全的替代方案
    let result: Result<i32, String> = Err("error".to_string());
    
    // 使用unwrap_or
    let value = result.unwrap_or(0);
    println!("安全的值: {}", value);
    
    // 使用unwrap_or_default
    let value = result.unwrap_or_default();
    println!("默认值: {}", value);
}
```

### 4.3 panic处理

设置panic hook：

```rust
use std::panic;

fn main() {
    // 设置自定义panic hook
    panic::set_hook(Box::new(|panic_info| {
        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            println!("panic消息: {}", s);
        }
        
        if let Some(location) = panic_info.location() {
            println!("panic位置: {}:{}", location.file(), location.line());
        }
    }));
    
    // 捕获panic
    let result = panic::catch_unwind(|| {
        println!("可能panic的代码");
        // panic!("测试panic");
        42
    });
    
    match result {
        Ok(value) => println!("成功: {}", value),
        Err(_) => println!("捕获到panic"),
    }
}
```

---

## 5. 自定义错误类型

### 5.1 简单错误类型

创建简单的错误类型：

```rust
// 枚举错误
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    NegativeSquareRoot,
}

fn divide(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

fn sqrt(x: f64) -> Result<f64, MathError> {
    if x < 0.0 {
        Err(MathError::NegativeSquareRoot)
    } else {
        Ok(x.sqrt())
    }
}

fn main() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("结果: {}", result),
        Err(e) => println!("错误: {:?}", e),
    }
    
    match sqrt(-1.0) {
        Ok(result) => println!("平方根: {}", result),
        Err(e) => println!("错误: {:?}", e),
    }
}
```

### 5.2 Error trait

实现Error trait：

```rust
use std::fmt;
use std::error::Error;

#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    Custom(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::IoError(e) => write!(f, "IO错误: {}", e),
            AppError::ParseError(e) => write!(f, "解析错误: {}", e),
            AppError::Custom(msg) => write!(f, "自定义错误: {}", msg),
        }
    }
}

impl Error for AppError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            AppError::IoError(e) => Some(e),
            AppError::ParseError(e) => Some(e),
            AppError::Custom(_) => None,
        }
    }
}

fn main() {
    let error = AppError::Custom("something went wrong".to_string());
    println!("错误: {}", error);
    
    if let Some(source) = error.source() {
        println!("错误源: {}", source);
    }
}
```

### 5.3 错误转换

使用From实现错误转换：

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

// 自动转换io::Error
impl From<io::Error> for MyError {
    fn from(error: io::Error) -> Self {
        MyError::Io(error)
    }
}

// 自动转换ParseIntError
impl From<ParseIntError> for MyError {
    fn from(error: ParseIntError) -> Self {
        MyError::Parse(error)
    }
}

// 现在可以使用?自动转换
fn read_and_parse() -> Result<i32, MyError> {
    let content = std::fs::read_to_string("number.txt")?;  // io::Error自动转换
    let number = content.trim().parse()?;  // ParseIntError自动转换
    Ok(number)
}

fn main() {
    match read_and_parse() {
        Ok(num) => println!("数字: {}", num),
        Err(e) => println!("错误: {:?}", e),
    }
}
```

---

## 6. 错误传播

### 6.1 显式传播

手动传播错误：

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_manual(path: &str) -> Result<String, io::Error> {
    let file = File::open(path);
    
    let mut file = match file {
        Ok(f) => f,
        Err(e) => return Err(e),
    };
    
    let mut contents = String::new();
    
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

fn main() {
    match read_file_manual("test.txt") {
        Ok(content) => println!("内容: {}", content),
        Err(e) => println!("错误: {}", e),
    }
}
```

### 6.2 ?操作符链

链式使用?操作符：

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_chain(path: &str) -> Result<String, io::Error> {
    let mut contents = String::new();
    File::open(path)?.read_to_string(&mut contents)?;
    Ok(contents)
}

// 更简洁的版本
fn read_file_simple(path: &str) -> Result<String, io::Error> {
    std::fs::read_to_string(path)
}

fn main() {
    match read_file_chain("test.txt") {
        Ok(content) => println!("内容: {}", content),
        Err(e) => println!("错误: {}", e),
    }
}
```

### 6.3 多种错误类型

处理多种错误类型：

```rust
use std::fs;
use std::io;

// 方式1: 枚举所有错误
#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(std::num::ParseIntError),
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

fn process_file(path: &str) -> Result<i32, AppError> {
    let content = fs::read_to_string(path)?;
    let number = content.trim().parse()?;
    Ok(number)
}

// 方式2: 使用Box<dyn Error>
fn process_file_boxed(path: &str) -> Result<i32, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(path)?;
    let number = content.trim().parse()?;
    Ok(number)
}

fn main() {
    match process_file("number.txt") {
        Ok(num) => println!("数字: {}", num),
        Err(e) => println!("错误: {:?}", e),
    }
}
```

---

## 7. 实战案例

### 案例1: 文件操作

```rust
use std::fs::File;
use std::io::{self, Read, Write};
use std::path::Path;

#[derive(Debug)]
enum FileError {
    NotFound(String),
    PermissionDenied(String),
    Other(io::Error),
}

impl From<io::Error> for FileError {
    fn from(error: io::Error) -> Self {
        match error.kind() {
            io::ErrorKind::NotFound => {
                FileError::NotFound(error.to_string())
            },
            io::ErrorKind::PermissionDenied => {
                FileError::PermissionDenied(error.to_string())
            },
            _ => FileError::Other(error),
        }
    }
}

fn read_config(path: &str) -> Result<String, FileError> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn write_config(path: &str, content: &str) -> Result<(), FileError> {
    let mut file = File::create(path)?;
    file.write_all(content.as_bytes())?;
    Ok(())
}

fn safe_read_or_create(path: &str, default: &str) -> Result<String, FileError> {
    match read_config(path) {
        Ok(content) => Ok(content),
        Err(FileError::NotFound(_)) => {
            write_config(path, default)?;
            Ok(default.to_string())
        },
        Err(e) => Err(e),
    }
}

fn main() {
    match safe_read_or_create("config.txt", "default config") {
        Ok(content) => println!("配置: {}", content),
        Err(e) => println!("错误: {:?}", e),
    }
}
```

### 案例2: 网络请求

```rust
#[derive(Debug)]
enum NetworkError {
    Timeout,
    ConnectionFailed(String),
    InvalidResponse,
    HttpError(u16),
}

struct Response {
    status: u16,
    body: String,
}

fn make_request(url: &str) -> Result<Response, NetworkError> {
    // 模拟网络请求
    if url.is_empty() {
        return Err(NetworkError::ConnectionFailed("URL为空".to_string()));
    }
    
    // 模拟成功响应
    Ok(Response {
        status: 200,
        body: "响应数据".to_string(),
    })
}

fn fetch_with_retry(url: &str, max_retries: u32) -> Result<Response, NetworkError> {
    let mut attempts = 0;
    
    loop {
        attempts += 1;
        
        match make_request(url) {
            Ok(response) => return Ok(response),
            Err(NetworkError::Timeout) if attempts < max_retries => {
                println!("超时，重试 {}/{}", attempts, max_retries);
                continue;
            },
            Err(e) => return Err(e),
        }
    }
}

fn main() {
    match fetch_with_retry("https://example.com", 3) {
        Ok(response) => println!("状态: {}, 内容: {}", response.status, response.body),
        Err(e) => println!("错误: {:?}", e),
    }
}
```

### 案例3: 配置管理

```rust
use std::collections::HashMap;

#[derive(Debug)]
enum ConfigError {
    KeyNotFound(String),
    InvalidType(String),
    ParseError(String),
}

struct Config {
    data: HashMap<String, String>,
}

impl Config {
    fn new() -> Self {
        Config {
            data: HashMap::new(),
        }
    }
    
    fn set(&mut self, key: String, value: String) {
        self.data.insert(key, value);
    }
    
    fn get_string(&self, key: &str) -> Result<&str, ConfigError> {
        self.data
            .get(key)
            .map(|s| s.as_str())
            .ok_or_else(|| ConfigError::KeyNotFound(key.to_string()))
    }
    
    fn get_int(&self, key: &str) -> Result<i32, ConfigError> {
        let value = self.get_string(key)?;
        value
            .parse()
            .map_err(|_| ConfigError::ParseError(format!("无法解析 '{}' 为整数", value)))
    }
    
    fn get_bool(&self, key: &str) -> Result<bool, ConfigError> {
        let value = self.get_string(key)?;
        match value.to_lowercase().as_str() {
            "true" | "yes" | "1" => Ok(true),
            "false" | "no" | "0" => Ok(false),
            _ => Err(ConfigError::ParseError(format!(
                "无法解析 '{}' 为布尔值",
                value
            ))),
        }
    }
}

fn main() {
    let mut config = Config::new();
    config.set("name".to_string(), "MyApp".to_string());
    config.set("port".to_string(), "8080".to_string());
    config.set("debug".to_string(), "true".to_string());
    
    match config.get_string("name") {
        Ok(name) => println!("应用名: {}", name),
        Err(e) => println!("错误: {:?}", e),
    }
    
    match config.get_int("port") {
        Ok(port) => println!("端口: {}", port),
        Err(e) => println!("错误: {:?}", e),
    }
    
    match config.get_bool("debug") {
        Ok(debug) => println!("调试模式: {}", debug),
        Err(e) => println!("错误: {:?}", e),
    }
}
```

### 案例4: 数据验证

```rust
#[derive(Debug)]
enum ValidationError {
    TooShort { field: String, min: usize },
    TooLong { field: String, max: usize },
    InvalidFormat { field: String, reason: String },
    Required(String),
}

struct User {
    username: String,
    email: String,
    age: u32,
}

fn validate_username(username: &str) -> Result<(), ValidationError> {
    if username.is_empty() {
        return Err(ValidationError::Required("username".to_string()));
    }
    
    if username.len() < 3 {
        return Err(ValidationError::TooShort {
            field: "username".to_string(),
            min: 3,
        });
    }
    
    if username.len() > 20 {
        return Err(ValidationError::TooLong {
            field: "username".to_string(),
            max: 20,
        });
    }
    
    if !username.chars().all(|c| c.is_alphanumeric() || c == '_') {
        return Err(ValidationError::InvalidFormat {
            field: "username".to_string(),
            reason: "只能包含字母、数字和下划线".to_string(),
        });
    }
    
    Ok(())
}

fn validate_email(email: &str) -> Result<(), ValidationError> {
    if email.is_empty() {
        return Err(ValidationError::Required("email".to_string()));
    }
    
    if !email.contains('@') {
        return Err(ValidationError::InvalidFormat {
            field: "email".to_string(),
            reason: "必须包含@符号".to_string(),
        });
    }
    
    Ok(())
}

fn validate_age(age: u32) -> Result<(), ValidationError> {
    if age < 18 {
        return Err(ValidationError::InvalidFormat {
            field: "age".to_string(),
            reason: "必须年满18岁".to_string(),
        });
    }
    
    Ok(())
}

fn create_user(username: &str, email: &str, age: u32) -> Result<User, Vec<ValidationError>> {
    let mut errors = Vec::new();
    
    if let Err(e) = validate_username(username) {
        errors.push(e);
    }
    
    if let Err(e) = validate_email(email) {
        errors.push(e);
    }
    
    if let Err(e) = validate_age(age) {
        errors.push(e);
    }
    
    if !errors.is_empty() {
        return Err(errors);
    }
    
    Ok(User {
        username: username.to_string(),
        email: email.to_string(),
        age,
    })
}

fn main() {
    match create_user("alice", "alice@example.com", 25) {
        Ok(user) => println!("用户创建成功: {}", user.username),
        Err(errors) => {
            println!("验证失败:");
            for error in errors {
                println!("  {:?}", error);
            }
        },
    }
    
    match create_user("ab", "invalid-email", 16) {
        Ok(user) => println!("用户创建成功: {}", user.username),
        Err(errors) => {
            println!("验证失败:");
            for error in errors {
                println!("  {:?}", error);
            }
        },
    }
}
```

---

## 8. 最佳实践

1. **优先使用Result而非panic**
2. **为公共API设计良好的错误类型**
3. **使用?操作符简化错误传播**
4. **为错误提供上下文信息**
5. **实现Error trait提供完整错误信息**
6. **考虑错误恢复策略**
7. **在适当的层级处理错误**
8. **为库用户提供错误文档**

---

## 9. 常见陷阱

```rust
fn main() {
    // ❌ 陷阱1: 过度使用unwrap
    // let value = some_result.unwrap();  // 可能panic
    
    // ✅ 正确：使用?或match处理
    fn process() -> Result<(), String> {
        let value = some_result()?;
        Ok(())
    }
    
    fn some_result() -> Result<i32, String> {
        Ok(42)
    }
    
    // ❌ 陷阱2: 忽略错误
    // let _ = some_fallible_operation();  // 错误被忽略
    
    // ✅ 正确：处理或传播错误
    match some_fallible_operation() {
        Ok(_) => {},
        Err(e) => eprintln!("警告: {}", e),
    }
    
    fn some_fallible_operation() -> Result<(), String> {
        Ok(())
    }
    
    // ❌ 陷阱3: 使用String作为错误类型
    // fn bad() -> Result<(), String> { ... }
    
    // ✅ 正确：使用专门的错误类型
    #[derive(Debug)]
    enum MyError {
        IoError,
        ParseError,
    }
    
    fn good() -> Result<(), MyError> {
        Ok(())
    }
    
    let _ = process();
    let _ = good();
}
```

---

## 10. 小结

- Result和Option是Rust错误处理的核心
- ?操作符简化错误传播
- panic用于不可恢复的错误
- 自定义错误类型提供更好的错误信息
- 错误处理是代码质量的重要组成部分

---

## 11. 延伸阅读

**内部文档**:

- [条件语句指南](./01_条件语句指南.md)
- [模式匹配指南](./04_模式匹配指南.md)
- [错误处理进阶](../tier_04_advanced/04_错误处理进阶.md)

**外部资源**:

- [Rust Book - Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [Rust by Example - Error Handling](https://doc.rust-lang.org/rust-by-example/error.html)
- [anyhow crate](https://docs.rs/anyhow/)
- [thiserror crate](https://docs.rs/thiserror/)

---

## 12. 练习题

1. 实现一个文件读取函数，处理各种IO错误
2. 创建一个自定义错误类型，包含多种错误情况
3. 编写一个数据验证系统，收集所有验证错误
4. 实现带重试机制的网络请求函数
5. 设计一个配置管理器，支持类型安全的配置访问

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🎯 掌握Rust错误处理，编写健壮可靠的代码！** 🦀✨
