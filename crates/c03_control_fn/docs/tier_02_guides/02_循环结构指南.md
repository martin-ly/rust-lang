# 2.2 å¾ªç¯ç»“æ„æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚
> **æ–‡æ¡£å®šä½**: ç³»ç»ŸåŒ–å­¦ä¹ Rustå¾ªç¯ç»“æ„ï¼ŒæŒæ¡loop/while/foræ ¸å¿ƒç”¨æ³•
> **å­¦ä¹ æ—¶é—´**: 1-2å¤©
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)

## ğŸ“‹ ç›®å½•

- [2.2 å¾ªç¯ç»“æ„æŒ‡å—](#22-å¾ªç¯ç»“æ„æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. loop æ— é™å¾ªç¯](#1-loop-æ— é™å¾ªç¯)
    - [1.1 åŸºæœ¬è¯­æ³•](#11-åŸºæœ¬è¯­æ³•)
    - [1.2 å¾ªç¯æ ‡ç­¾](#12-å¾ªç¯æ ‡ç­¾)
    - [1.3 ä»å¾ªç¯è¿”å›å€¼](#13-ä»å¾ªç¯è¿”å›å€¼)
    - [1.4 ä½¿ç”¨åœºæ™¯](#14-ä½¿ç”¨åœºæ™¯)
  - [2. while æ¡ä»¶å¾ªç¯](#2-while-æ¡ä»¶å¾ªç¯)
    - [2.1 åŸºæœ¬è¯­æ³•](#21-åŸºæœ¬è¯­æ³•)
    - [2.2 while let æ¨¡å¼](#22-while-let-æ¨¡å¼)
    - [2.3 å¸¸è§æ¨¡å¼](#23-å¸¸è§æ¨¡å¼)
  - [3. for è¿­ä»£å¾ªç¯](#3-for-è¿­ä»£å¾ªç¯)
    - [3.1 åŸºæœ¬è¯­æ³•](#31-åŸºæœ¬è¯­æ³•)
    - [3.2 è¿­ä»£å™¨æ–¹æ³•](#32-è¿­ä»£å™¨æ–¹æ³•)
    - [3.3 èŒƒå›´è¡¨è¾¾å¼](#33-èŒƒå›´è¡¨è¾¾å¼)
    - [3.4 è‡ªå®šä¹‰è¿­ä»£å™¨](#34-è‡ªå®šä¹‰è¿­ä»£å™¨)
  - [4. break å’Œ continue](#4-break-å’Œ-continue)
    - [4.1 åŸºæœ¬ç”¨æ³•](#41-åŸºæœ¬ç”¨æ³•)
    - [4.2 å¸¦æ ‡ç­¾çš„break/continue](#42-å¸¦æ ‡ç­¾çš„breakcontinue)
    - [4.3 ä»å¾ªç¯è¿”å›å€¼](#43-ä»å¾ªç¯è¿”å›å€¼)
  - [5. å¾ªç¯å¯¹æ¯”](#5-å¾ªç¯å¯¹æ¯”)
    - [5.1 åŠŸèƒ½å¯¹æ¯”](#51-åŠŸèƒ½å¯¹æ¯”)
    - [5.2 æ€§èƒ½å¯¹æ¯”](#52-æ€§èƒ½å¯¹æ¯”)
    - [5.3 é€‰æ‹©æŒ‡å—](#53-é€‰æ‹©æŒ‡å—)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: äº‹ä»¶å¾ªç¯å¤„ç†](#æ¡ˆä¾‹1-äº‹ä»¶å¾ªç¯å¤„ç†)
    - [æ¡ˆä¾‹2: æ•°æ®æµå¤„ç†å™¨](#æ¡ˆä¾‹2-æ•°æ®æµå¤„ç†å™¨)
    - [æ¡ˆä¾‹3: æ¸¸æˆä¸»å¾ªç¯](#æ¡ˆä¾‹3-æ¸¸æˆä¸»å¾ªç¯)
    - [æ¡ˆä¾‹4: å¹¶å‘ä»»åŠ¡è°ƒåº¦](#æ¡ˆä¾‹4-å¹¶å‘ä»»åŠ¡è°ƒåº¦)
    - [æ¡ˆä¾‹5: è¿­ä»£å™¨ç»„åˆå™¨](#æ¡ˆä¾‹5-è¿­ä»£å™¨ç»„åˆå™¨)
    - [æ¡ˆä¾‹6: è¿­ä»£å™¨ä¸é—­åŒ…ååŒ](#æ¡ˆä¾‹6-è¿­ä»£å™¨ä¸é—­åŒ…ååŒ)
  - [7. å¸¸è§é™·é˜±](#7-å¸¸è§é™·é˜±)
    - [7.1 æ— é™å¾ªç¯](#71-æ— é™å¾ªç¯)
    - [7.2 æ‰€æœ‰æƒé—®é¢˜](#72-æ‰€æœ‰æƒé—®é¢˜)
    - [7.3 æ€§èƒ½é™·é˜±](#73-æ€§èƒ½é™·é˜±)
    - [7.4 å¯å˜æ€§é—®é¢˜](#74-å¯å˜æ€§é—®é¢˜)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
  - [9. æ€§èƒ½ä¼˜åŒ–](#9-æ€§èƒ½ä¼˜åŒ–)
  - [10. å°ç»“](#10-å°ç»“)
  - [11. å»¶ä¼¸é˜…è¯»](#11-å»¶ä¼¸é˜…è¯»)
  - [12. ç»ƒä¹ é¢˜](#12-ç»ƒä¹ é¢˜)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… æŒæ¡ loop/while/for ä¸‰ç§å¾ªç¯çš„ä½¿ç”¨
- âœ… ç†è§£å¾ªç¯æ ‡ç­¾å’Œæ§åˆ¶æµ
- âœ… ç†Ÿç»ƒä½¿ç”¨è¿­ä»£å™¨è¿›è¡Œæ•°æ®å¤„ç†
- âœ… åº”ç”¨å¾ªç¯è§£å†³å®é™…é—®é¢˜
- âœ… ä¼˜åŒ–å¾ªç¯æ€§èƒ½
- âœ… é¿å…å¸¸è§é™·é˜±ï¼Œç¼–å†™é«˜æ•ˆä»£ç 

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å¾ªç¯ç»“æ„æŒ‡å— (Loop Structures Guide)**:

- **å®šä¹‰**: ç³»ç»ŸåŒ–å­¦ä¹  Rust å¾ªç¯ç»“æ„çš„å®è·µæŒ‡å—ï¼ŒåŒ…æ‹¬ loopã€whileã€for ç­‰
- **ç±»å‹**: å®è·µæŒ‡å—æ–‡æ¡£
- **èŒƒç•´**: æ§åˆ¶æµã€è¿­ä»£å™¨
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: å¾ªç¯ç»“æ„ã€è¿­ä»£å™¨ã€æ§åˆ¶æµã€å¾ªç¯æ§åˆ¶

**å¾ªç¯ç»“æ„ (Loop Structures)**:

- **å®šä¹‰**: é‡å¤æ‰§è¡Œä»£ç å—çš„æ§åˆ¶æµç»“æ„
- **ç±»å‹**: æ§åˆ¶æµè¯­å¥
- **å±æ€§**: é‡å¤æ‰§è¡Œã€å¾ªç¯æ§åˆ¶ã€è¿­ä»£å™¨æ”¯æŒ
- **å…³ç³»**: ä¸è¿­ä»£å™¨ã€æ§åˆ¶æµç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **loop å¾ªç¯**: æ— é™å¾ªç¯ã€å¾ªç¯æ ‡ç­¾ã€è¿”å›å€¼
- **while å¾ªç¯**: æ¡ä»¶å¾ªç¯ã€while let æ¨¡å¼
- **for å¾ªç¯**: è¿­ä»£å™¨å¾ªç¯ã€èŒƒå›´è¡¨è¾¾å¼
- **å¾ªç¯æ§åˆ¶**: breakã€continueã€æ ‡ç­¾

**æ€§èƒ½ç‰¹å¾**:

- **è¿­ä»£å™¨ä¼˜åŒ–**: ç¼–è¯‘å™¨ä¼˜åŒ–è¿­ä»£å™¨å¾ªç¯
- **é›¶æˆæœ¬æŠ½è±¡**: è¿­ä»£å™¨æ€§èƒ½ç­‰åŒäºæ‰‹å†™å¾ªç¯
- **é€‚ç”¨åœºæ™¯**: é‡å¤æ‰§è¡Œã€æ•°æ®å¤„ç†ã€äº‹ä»¶å¾ªç¯

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- loop å¾ªç¯ --[is-a]--> å¾ªç¯ç»“æ„
- for å¾ªç¯ --[is-a]--> å¾ªç¯ç»“æ„

**ç»„åˆå…³ç³»**:

- å¾ªç¯ç»“æ„æŒ‡å— --[covers]--> å¤šç§å¾ªç¯ç»“æ„
- æ§åˆ¶æµç¨‹åº --[uses]--> å¾ªç¯ç»“æ„

**ä¾èµ–å…³ç³»**:

- å¾ªç¯ç»“æ„ --[depends-on]--> è¿­ä»£å™¨
- é‡å¤æ‰§è¡Œé€»è¾‘ --[depends-on]--> å¾ªç¯ç»“æ„

### æ€ç»´å¯¼å›¾

```text
å¾ªç¯ç»“æ„æŒ‡å—
â”‚
â”œâ”€â”€ loop æ— é™å¾ªç¯
â”‚   â”œâ”€â”€ å¾ªç¯æ ‡ç­¾
â”‚   â””â”€â”€ è¿”å›å€¼
â”œâ”€â”€ while æ¡ä»¶å¾ªç¯
â”‚   â””â”€â”€ while let æ¨¡å¼
â”œâ”€â”€ for è¿­ä»£å¾ªç¯
â”‚   â”œâ”€â”€ è¿­ä»£å™¨æ–¹æ³•
â”‚   â””â”€â”€ èŒƒå›´è¡¨è¾¾å¼
â”œâ”€â”€ å¾ªç¯æ§åˆ¶
â”‚   â”œâ”€â”€ break
â”‚   â””â”€â”€ continue
â””â”€â”€ å®æˆ˜æ¡ˆä¾‹
    â””â”€â”€ äº‹ä»¶å¾ªç¯å¤„ç†
```

---

## 1. loop æ— é™å¾ªç¯

### 1.1 åŸºæœ¬è¯­æ³•

loop åˆ›å»ºæ— é™å¾ªç¯ï¼Œå¿…é¡»æ˜¾å¼ breakï¼š

```rust
fn main() {
    // åŸºæœ¬æ— é™å¾ªç¯
    let mut count = 0;
    loop {
        count += 1;
        println!("è®¡æ•°: {}", count);

        if count >= 5 {
            break;
        }
    }

    // ç­‰åŒäºä¼ ç»Ÿè¯­è¨€çš„ while(true)
    let mut i = 0;
    loop {
        if i >= 3 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}
```

**å…³é”®è¦ç‚¹**:

- loop æ˜¯è¡¨è¾¾å¼ï¼Œå¯ä»¥è¿”å›å€¼
- å¿…é¡»æœ‰ break æˆ– return é€€å‡ºï¼ˆé™¤éç¨‹åºç»ˆæ­¢ï¼‰
- ç¼–è¯‘å™¨çŸ¥é“ loop ä¼šä¸€ç›´æ‰§è¡Œï¼Œæœ‰åŠ©äºä¼˜åŒ–

### 1.2 å¾ªç¯æ ‡ç­¾

ä½¿ç”¨æ ‡ç­¾æ§åˆ¶åµŒå¥—å¾ªç¯ï¼š

```rust
fn main() {
    // åµŒå¥—å¾ªç¯æ ‡ç­¾
    'outer: loop {
        println!("è¿›å…¥å¤–å±‚å¾ªç¯");
        let mut inner_count = 0;

        'inner: loop {
            inner_count += 1;
            println!("  å†…å±‚å¾ªç¯: {}", inner_count);

            if inner_count >= 3 {
                println!("  è·³å‡ºå¤–å±‚å¾ªç¯");
                break 'outer;  // è·³å‡ºå¤–å±‚å¾ªç¯
            }

            if inner_count == 1 {
                continue 'inner;  // ç»§ç»­å†…å±‚å¾ªç¯
            }
        }
    }

    println!("å¾ªç¯ç»“æŸ");

    // å¤šå±‚åµŒå¥—
    'first: loop {
        'second: loop {
            'third: loop {
                println!("æœ€å†…å±‚");
                break 'first;  // ç›´æ¥è·³å‡ºæœ€å¤–å±‚
            }
            println!("è¿™è¡Œä¸ä¼šæ‰§è¡Œ");
        }
        println!("è¿™è¡Œä¹Ÿä¸ä¼šæ‰§è¡Œ");
    }
    println!("å®Œå…¨é€€å‡º");
}
```

### 1.3 ä»å¾ªç¯è¿”å›å€¼

loop å¯ä»¥é€šè¿‡ break è¿”å›å€¼ï¼š

```rust
fn main() {
    // ä»å¾ªç¯è¿”å›å€¼
    let mut counter = 0;
    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;  // è¿”å›å€¼
        }
    };

    println!("ç»“æœ: {}", result);  // 20

    // å¤æ‚è¿”å›å€¼
    let value = loop {
        let random = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() % 100;

        if random > 50 {
            break Some(random);
        }

        if counter > 100 {
            break None;
        }

        counter += 1;
    };

    println!("æ‰¾åˆ°çš„å€¼: {:?}", value);

    // å¸¦æ ‡ç­¾çš„è¿”å›å€¼
    let result = 'block: loop {
        let x = 10;
        loop {
            if x == 10 {
                break 'block x * 2;  // ä»å¤–å±‚å¾ªç¯è¿”å›
            }
        }
    };

    println!("æ ‡ç­¾è¿”å›å€¼: {}", result);
}
```

### 1.4 ä½¿ç”¨åœºæ™¯

loop é€‚åˆçš„å…¸å‹åœºæ™¯ï¼š

```rust
use std::io::{self, Write};

fn main() {
    // åœºæ™¯1: äº‹ä»¶å¾ªç¯
    event_loop();

    // åœºæ™¯2: é‡è¯•é€»è¾‘
    let result = retry_operation(|| {
        // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
        Ok(42)
    }, 3);
    println!("é‡è¯•ç»“æœ: {:?}", result);

    // åœºæ™¯3: çŠ¶æ€æœº
    run_state_machine();
}

fn event_loop() {
    let mut should_quit = false;
    let mut event_count = 0;

    loop {
        // æ¨¡æ‹Ÿäº‹ä»¶å¤„ç†
        event_count += 1;
        println!("å¤„ç†äº‹ä»¶ #{}", event_count);

        if event_count >= 3 {
            should_quit = true;
        }

        if should_quit {
            println!("é€€å‡ºäº‹ä»¶å¾ªç¯");
            break;
        }
    }
}

fn retry_operation<F, T, E>(mut operation: F, max_retries: u32) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;

    loop {
        attempts += 1;

        match operation() {
            Ok(value) => break Ok(value),
            Err(err) if attempts >= max_retries => break Err(err),
            Err(_) => {
                println!("é‡è¯• {}/{}", attempts, max_retries);
                continue;
            }
        }
    }
}

#[derive(Debug)]
enum State {
    Start,
    Processing,
    Done,
}

fn run_state_machine() {
    let mut state = State::Start;
    let mut iterations = 0;

    loop {
        iterations += 1;
        println!("çŠ¶æ€: {:?}", state);

        state = match state {
            State::Start => State::Processing,
            State::Processing if iterations > 2 => State::Done,
            State::Processing => State::Processing,
            State::Done => break,
        };
    }

    println!("çŠ¶æ€æœºå®Œæˆ");
}
```

---

## 2. while æ¡ä»¶å¾ªç¯

### 2.1 åŸºæœ¬è¯­æ³•

while åœ¨æ¡ä»¶ä¸ºçœŸæ—¶å¾ªç¯ï¼š

```rust
fn main() {
    // åŸºæœ¬ while
    let mut count = 0;
    while count < 5 {
        println!("count = {}", count);
        count += 1;
    }

    // å¤æ‚æ¡ä»¶
    let mut x = 10;
    let mut y = 20;
    while x < y && x < 15 {
        x += 1;
        y -= 1;
        println!("x = {}, y = {}", x, y);
    }

    // å¸ƒå°”å˜é‡æ§åˆ¶
    let mut running = true;
    let mut tick = 0;
    while running {
        tick += 1;
        println!("Tick {}", tick);

        if tick >= 3 {
            running = false;
        }
    }
}
```

**å…³é”®è¦ç‚¹**:

- æ¡ä»¶åœ¨æ¯æ¬¡è¿­ä»£å‰æ£€æŸ¥
- æ¡ä»¶å¿…é¡»æ˜¯ bool ç±»å‹
- æ¡ä»¶ä¸º false æ—¶é€€å‡ºå¾ªç¯

### 2.2 while let æ¨¡å¼

while let ç”¨äºæ¨¡å¼åŒ¹é…å¾ªç¯ï¼š

```rust
fn main() {
    // Option è§£åŒ…
    let mut stack = vec![1, 2, 3, 4, 5];

    while let Some(top) = stack.pop() {
        println!("å¼¹å‡º: {}", top);
    }

    // è¿­ä»£å™¨æ¨¡å¼
    let mut iter = vec![10, 20, 30].into_iter();
    while let Some(value) = iter.next() {
        println!("å€¼: {}", value);
    }

    // Result å¤„ç†
    fn get_next() -> Option<Result<i32, String>> {
        static mut COUNTER: i32 = 0;
        unsafe {
            COUNTER += 1;
            if COUNTER <= 3 {
                Some(Ok(COUNTER))
            } else {
                None
            }
        }
    }

    while let Some(Ok(value)) = get_next() {
        println!("æˆåŠŸå€¼: {}", value);
    }

    // è§£æ„æšä¸¾
    #[derive(Debug)]
    enum Message {
        Text(String),
        Number(i32),
        Quit,
    }

    let messages = vec![
        Message::Text("Hello".to_string()),
        Message::Number(42),
        Message::Text("World".to_string()),
        Message::Quit,
    ];

    let mut iter = messages.into_iter();
    while let Some(msg) = iter.next() {
        match msg {
            Message::Text(s) => println!("æ–‡æœ¬: {}", s),
            Message::Number(n) => println!("æ•°å­—: {}", n),
            Message::Quit => {
                println!("é€€å‡º");
                break;
            }
        }
    }
}
```

### 2.3 å¸¸è§æ¨¡å¼

while å¾ªç¯çš„å…¸å‹ä½¿ç”¨æ¨¡å¼ï¼š

```rust
use std::collections::VecDeque;

fn main() {
    // æ¨¡å¼1: å€’è®¡æ—¶
    let mut countdown = 5;
    while countdown > 0 {
        println!("{}...", countdown);
        countdown -= 1;
    }
    println!("å‘å°„ï¼");

    // æ¨¡å¼2: é˜Ÿåˆ—å¤„ç†
    let mut queue: VecDeque<i32> = VecDeque::new();
    queue.push_back(1);
    queue.push_back(2);
    queue.push_back(3);

    while let Some(item) = queue.pop_front() {
        println!("å¤„ç†é˜Ÿåˆ—é¡¹: {}", item);
    }

    // æ¨¡å¼3: æ¡ä»¶ç´¯ç§¯
    let mut sum = 0;
    let mut n = 1;
    while sum < 100 {
        sum += n;
        n += 1;
    }
    println!("ç´¯ç§¯åˆ°100éœ€è¦åŠ åˆ°: {}, æ€»å’Œ: {}", n - 1, sum);

    // æ¨¡å¼4: æœç´¢ç›´åˆ°æ‰¾åˆ°
    let numbers = vec![1, 3, 5, 7, 9, 10, 12];
    let mut index = 0;
    while index < numbers.len() && numbers[index] % 2 != 0 {
        index += 1;
    }

    if index < numbers.len() {
        println!("ç¬¬ä¸€ä¸ªå¶æ•°åœ¨ç´¢å¼• {}: {}", index, numbers[index]);
    } else {
        println!("æ²¡æœ‰æ‰¾åˆ°å¶æ•°");
    }
}
```

---

## 3. for è¿­ä»£å¾ªç¯

### 3.1 åŸºæœ¬è¯­æ³•

for ç”¨äºéå†è¿­ä»£å™¨ï¼š

```rust
fn main() {
    // éå†æ•°ç»„
    let array = [10, 20, 30, 40, 50];
    for element in array {
        println!("å…ƒç´ : {}", element);
    }

    // éå† Vec
    let vec = vec![1, 2, 3, 4, 5];
    for num in &vec {  // å€Ÿç”¨
        println!("æ•°å­—: {}", num);
    }

    // å¯å˜éå†
    let mut vec = vec![1, 2, 3];
    for num in &mut vec {
        *num *= 2;
    }
    println!("åŠ å€å: {:?}", vec);

    // æ¶ˆè´¹éå†
    let vec = vec![String::from("a"), String::from("b")];
    for s in vec {  // è·å–æ‰€æœ‰æƒ
        println!("å­—ç¬¦ä¸²: {}", s);
    }
    // vec å·²è¢«ç§»åŠ¨ï¼Œä¸èƒ½å†ä½¿ç”¨

    // éå†èŒƒå›´
    for i in 0..5 {
        println!("i = {}", i);
    }

    // åŒ…å«èŒƒå›´
    for i in 0..=5 {
        println!("åŒ…å«5: i = {}", i);
    }
}
```

**å…³é”®è¦ç‚¹**:

- for ä½¿ç”¨ IntoIterator trait
- `&collection` å€Ÿç”¨å…ƒç´ 
- `&mut collection` å¯å˜å€Ÿç”¨
- `collection` è·å–æ‰€æœ‰æƒ

### 3.2 è¿­ä»£å™¨æ–¹æ³•

ä½¿ç”¨è¿­ä»£å™¨æ–¹æ³•å¢å¼º for å¾ªç¯ï¼š

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];

    // enumerate - è·å–ç´¢å¼•
    for (index, value) in vec.iter().enumerate() {
        println!("ç´¢å¼• {}: å€¼ {}", index, value);
    }

    // rev - åå‘è¿­ä»£
    for num in (1..=5).rev() {
        println!("å€’æ•°: {}", num);
    }

    // filter - è¿‡æ»¤
    for even in (1..=10).filter(|x| x % 2 == 0) {
        println!("å¶æ•°: {}", even);
    }

    // map - è½¬æ¢
    for squared in (1..=5).map(|x| x * x) {
        println!("å¹³æ–¹: {}", squared);
    }

    // zip - ç»„åˆä¸¤ä¸ªè¿­ä»£å™¨
    let names = vec!["Alice", "Bob", "Carol"];
    let scores = vec![85, 92, 78];

    for (name, score) in names.iter().zip(scores.iter()) {
        println!("{}: {}", name, score);
    }

    // chain - è¿æ¥è¿­ä»£å™¨
    let a = vec![1, 2, 3];
    let b = vec![4, 5, 6];

    for num in a.iter().chain(b.iter()) {
        println!("è¿æ¥: {}", num);
    }

    // take - é™åˆ¶æ•°é‡
    for num in (1..).take(5) {
        println!("å‰5ä¸ª: {}", num);
    }

    // skip - è·³è¿‡å…ƒç´ 
    for num in (1..=10).skip(5) {
        println!("è·³è¿‡å‰5ä¸ª: {}", num);
    }
}
```

### 3.3 èŒƒå›´è¡¨è¾¾å¼

Rust æä¾›å¤šç§èŒƒå›´è¡¨è¾¾å¼ï¼š

```rust
fn main() {
    // å·¦é—­å³å¼€: 0..5 => [0, 1, 2, 3, 4]
    for i in 0..5 {
        print!("{} ", i);
    }
    println!();

    // å·¦é—­å³é—­: 0..=5 => [0, 1, 2, 3, 4, 5]
    for i in 0..=5 {
        print!("{} ", i);
    }
    println!();

    // å¼€å§‹èŒƒå›´: 5.. (æ— é™)
    for i in (5..).take(3) {
        print!("{} ", i);
    }
    println!();

    // ç»“æŸèŒƒå›´: ..5 => [0, 1, 2, 3, 4]
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    for i in &arr[..5] {
        print!("{} ", i);
    }
    println!();

    // å…¨èŒƒå›´: .. (ç”¨äºåˆ‡ç‰‡)
    for i in &arr[..] {
        print!("{} ", i);
    }
    println!();

    // æ­¥é•¿ï¼ˆéœ€è¦ step_byï¼‰
    for i in (0..10).step_by(2) {
        print!("{} ", i);
    }
    println!();

    // åå‘æ­¥é•¿
    for i in (0..10).rev().step_by(2) {
        print!("{} ", i);
    }
    println!();
}
```

### 3.4 è‡ªå®šä¹‰è¿­ä»£å™¨

å®ç° Iterator trait åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨ï¼š

```rust
// ç®€å•è®¡æ•°å™¨
struct Counter {
    count: u32,
    max: u32,
}

impl Counter {
    fn new(max: u32) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

// æ–æ³¢é‚£å¥‘æ•°åˆ—
struct Fibonacci {
    curr: u64,
    next: u64,
}

impl Fibonacci {
    fn new() -> Self {
        Fibonacci { curr: 0, next: 1 }
    }
}

impl Iterator for Fibonacci {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        let current = self.curr;
        self.curr = self.next;
        self.next = current + self.next;
        Some(current)
    }
}

// èŒƒå›´è¿­ä»£å™¨
struct RangeIter {
    start: i32,
    end: i32,
    step: i32,
}

impl RangeIter {
    fn new(start: i32, end: i32, step: i32) -> Self {
        RangeIter { start, end, step }
    }
}

impl Iterator for RangeIter {
    type Item = i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.start < self.end {
            let current = self.start;
            self.start += self.step;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    // ä½¿ç”¨è‡ªå®šä¹‰è®¡æ•°å™¨
    println!("è®¡æ•°å™¨:");
    for num in Counter::new(5) {
        print!("{} ", num);
    }
    println!();

    // ä½¿ç”¨æ–æ³¢é‚£å¥‘
    println!("æ–æ³¢é‚£å¥‘æ•°åˆ—å‰10ä¸ª:");
    for fib in Fibonacci::new().take(10) {
        print!("{} ", fib);
    }
    println!();

    // ä½¿ç”¨èŒƒå›´è¿­ä»£å™¨
    println!("æ­¥é•¿ä¸º3çš„èŒƒå›´:");
    for num in RangeIter::new(0, 20, 3) {
        print!("{} ", num);
    }
    println!();
}
```

---

## 4. break å’Œ continue

### 4.1 åŸºæœ¬ç”¨æ³•

break é€€å‡ºå¾ªç¯ï¼Œcontinue è·³è¿‡å½“å‰è¿­ä»£ï¼š

```rust
fn main() {
    // break åŸºæœ¬ç”¨æ³•
    for i in 0..10 {
        if i == 5 {
            break;  // åœ¨5æ—¶é€€å‡º
        }
        println!("i = {}", i);
    }

    // continue åŸºæœ¬ç”¨æ³•
    for i in 0..10 {
        if i % 2 == 0 {
            continue;  // è·³è¿‡å¶æ•°
        }
        println!("å¥‡æ•°: {}", i);
    }

    // ç»“åˆä½¿ç”¨
    for i in 0..20 {
        if i % 2 == 0 {
            continue;  // è·³è¿‡å¶æ•°
        }
        if i > 10 {
            break;  // å¤§äº10é€€å‡º
        }
        println!("å¥‡æ•°ä¸”<=10: {}", i);
    }
}
```

### 4.2 å¸¦æ ‡ç­¾çš„break/continue

åœ¨åµŒå¥—å¾ªç¯ä¸­ä½¿ç”¨æ ‡ç­¾ï¼š

```rust
fn main() {
    // åµŒå¥—å¾ªç¯çš„ break
    'outer: for i in 0..5 {
        for j in 0..5 {
            if i * j > 10 {
                println!("ä¸­æ–­åœ¨ i={}, j={}", i, j);
                break 'outer;  // è·³å‡ºå¤–å±‚
            }
            print!("({},{}) ", i, j);
        }
        println!();
    }

    // åµŒå¥—å¾ªç¯çš„ continue
    'outer: for i in 0..5 {
        for j in 0..5 {
            if j == 2 {
                continue 'outer;  // è·³åˆ°å¤–å±‚ä¸‹ä¸€æ¬¡
            }
            print!("({},{}) ", i, j);
        }
        println!();
    }

    // å¤æ‚åµŒå¥—
    'search: for i in 0..10 {
        'inner: for j in 0..10 {
            for k in 0..10 {
                if i + j + k == 15 {
                    println!("æ‰¾åˆ°: i={}, j={}, k={}", i, j, k);
                    break 'search;  // è·³å‡ºæ‰€æœ‰å¾ªç¯
                }
            }
        }
    }
}
```

### 4.3 ä»å¾ªç¯è¿”å›å€¼

ä½¿ç”¨ break è¿”å›å€¼ï¼š

```rust
fn main() {
    // ä» loop è¿”å›å€¼
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("ç»“æœ: {}", result);

    // æœç´¢å¹¶è¿”å›
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let first_even = loop {
        static mut INDEX: usize = 0;
        unsafe {
            if INDEX >= numbers.len() {
                break None;
            }
            let num = numbers[INDEX];
            INDEX += 1;
            if num % 2 == 0 {
                break Some(num);
            }
        }
    };
    println!("ç¬¬ä¸€ä¸ªå¶æ•°: {:?}", first_even);

    // å¸¦æ ‡ç­¾è¿”å›å€¼
    let result = 'block: loop {
        for i in 0..10 {
            if i == 5 {
                break 'block i * 10;
            }
        }
    };
    println!("æ ‡ç­¾è¿”å›å€¼: {}", result);
}
```

---

## 5. å¾ªç¯å¯¹æ¯”

### 5.1 åŠŸèƒ½å¯¹æ¯”

| ç‰¹æ€§         | loop           | while        | for        |
| :--- | :--- | :--- | :--- || **ç”¨é€”**     | æ— é™å¾ªç¯       | æ¡ä»¶å¾ªç¯     | è¿­ä»£å¾ªç¯   |
| **é€€å‡ºæ¡ä»¶** | æ˜¾å¼ break     | æ¡ä»¶ä¸º false | è¿­ä»£å™¨è€—å°½ |
| **è¿”å›å€¼**   | âœ… æ”¯æŒ        | âŒ ä¸æ”¯æŒ    | âŒ ä¸æ”¯æŒ  |
| **æ ‡ç­¾**     | âœ… æ”¯æŒ        | âœ… æ”¯æŒ      | âœ… æ”¯æŒ    |
| **é€‚ç”¨åœºæ™¯** | äº‹ä»¶å¾ªç¯ã€é‡è¯• | æ¡ä»¶åˆ¤æ–­     | é›†åˆéå†   |
| **æ€§èƒ½**     | æœ€ä¼˜åŒ–         | è‰¯å¥½         | æœ€ä¼˜       |
| **å¯è¯»æ€§**   | ä¸­ç­‰           | è‰¯å¥½         | æœ€ä½³       |

### 5.2 æ€§èƒ½å¯¹æ¯”

```rust
use std::time::Instant;

fn benchmark_loops() {
    let iterations = 10_000_000;

    // loop æ€§èƒ½
    let start = Instant::now();
    let mut sum = 0;
    let mut i = 0;
    loop {
        if i >= iterations {
            break;
        }
        sum += i;
        i += 1;
    }
    println!("loop: {:?}, sum = {}", start.elapsed(), sum);

    // while æ€§èƒ½
    let start = Instant::now();
    let mut sum = 0;
    let mut i = 0;
    while i < iterations {
        sum += i;
        i += 1;
    }
    println!("while: {:?}, sum = {}", start.elapsed(), sum);

    // for æ€§èƒ½
    let start = Instant::now();
    let mut sum = 0;
    for i in 0..iterations {
        sum += i;
    }
    println!("for: {:?}, sum = {}", start.elapsed(), sum);

    // è¿­ä»£å™¨æ€§èƒ½
    let start = Instant::now();
    let sum: i64 = (0..iterations).sum();
    println!("iterator sum: {:?}, sum = {}", start.elapsed(), sum);
}

fn main() {
    benchmark_loops();
}
```

**æ€§èƒ½ç»“è®º**:

- åœ¨ release æ¨¡å¼ä¸‹ï¼Œä¸‰è€…æ€§èƒ½åŸºæœ¬ç›¸åŒ
- ç¼–è¯‘å™¨ä¼šä¼˜åŒ–ä¸ºç›¸ä¼¼çš„æœºå™¨ç 
- for + è¿­ä»£å™¨é€šå¸¸æœ€æ˜“ä¼˜åŒ–
- ä¼˜å…ˆè€ƒè™‘å¯è¯»æ€§ï¼Œè€Œéå¾®å°æ€§èƒ½å·®å¼‚

### 5.3 é€‰æ‹©æŒ‡å—

```rust
fn main() {
    // âœ… ä½¿ç”¨ loop: æ— é™å¾ªç¯ã€äº‹ä»¶å¾ªç¯
    let mut server_running = true;
    let mut count = 0;
    loop {
        // å¤„ç†è¯·æ±‚
        count += 1;
        if count > 3 {
            server_running = false;
        }
        if !server_running {
            break;
        }
    }

    // âœ… ä½¿ç”¨ while: æ¡ä»¶ä¸ç¡®å®š
    let mut value = 100;
    while value > 0 {
        value -= 7;
    }
    println!("value: {}", value);

    // âœ… ä½¿ç”¨ for: éå†é›†åˆ
    let numbers = vec![1, 2, 3, 4, 5];
    for num in &numbers {
        println!("num: {}", num);
    }

    // âœ… ä½¿ç”¨ while let: æ¶ˆè´¹ç›´åˆ°None
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("pop: {}", top);
    }
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: äº‹ä»¶å¾ªç¯å¤„ç†

```rust
use std::collections::VecDeque;

#[derive(Debug)]
enum Event {
    KeyPress(char),
    MouseClick(i32, i32),
    Quit,
}

struct EventLoop {
    events: VecDeque<Event>,
    running: bool,
}

impl EventLoop {
    fn new() -> Self {
        EventLoop {
            events: VecDeque::new(),
            running: true,
        }
    }

    fn push_event(&mut self, event: Event) {
        self.events.push_back(event);
    }

    fn run(&mut self) {
        loop {
            // å¤„ç†æ‰€æœ‰å¾…å¤„ç†äº‹ä»¶
            while let Some(event) = self.events.pop_front() {
                self.handle_event(event);
            }

            // æ£€æŸ¥æ˜¯å¦åº”è¯¥é€€å‡º
            if !self.running {
                break;
            }

            // æ¨¡æ‹Ÿç­‰å¾…æ–°äº‹ä»¶
            std::thread::sleep(std::time::Duration::from_millis(100));
        }
    }

    fn handle_event(&mut self, event: Event) {
        match event {
            Event::KeyPress(c) => {
                println!("æŒ‰é”®: {}", c);
                if c == 'q' {
                    self.running = false;
                }
            },
            Event::MouseClick(x, y) => {
                println!("é¼ æ ‡ç‚¹å‡»: ({}, {})", x, y);
            },
            Event::Quit => {
                println!("é€€å‡ºäº‹ä»¶");
                self.running = false;
            },
        }
    }
}

fn main() {
    let mut event_loop = EventLoop::new();

    // æ·»åŠ ä¸€äº›æµ‹è¯•äº‹ä»¶
    event_loop.push_event(Event::KeyPress('a'));
    event_loop.push_event(Event::MouseClick(10, 20));
    event_loop.push_event(Event::KeyPress('b'));
    event_loop.push_event(Event::Quit);

    event_loop.run();
}
```

### æ¡ˆä¾‹2: æ•°æ®æµå¤„ç†å™¨

```rust
struct DataProcessor<T> {
    buffer: Vec<T>,
    batch_size: usize,
}

impl<T: Clone> DataProcessor<T> {
    fn new(batch_size: usize) -> Self {
        DataProcessor {
            buffer: Vec::new(),
            batch_size,
        }
    }

    fn process_stream<I>(&mut self, stream: I)
    where
        I: Iterator<Item = T>,
    {
        for item in stream {
            self.buffer.push(item);

            // å½“ç¼“å†²åŒºæ»¡æ—¶å¤„ç†æ‰¹æ¬¡
            if self.buffer.len() >= self.batch_size {
                self.process_batch();
            }
        }

        // å¤„ç†å‰©ä½™æ•°æ®
        if !self.buffer.is_empty() {
            self.process_batch();
        }
    }

    fn process_batch(&mut self) {
        println!("å¤„ç†æ‰¹æ¬¡ï¼Œå¤§å°: {}", self.buffer.len());
        // å®é™…å¤„ç†é€»è¾‘
        self.buffer.clear();
    }
}

fn main() {
    let mut processor = DataProcessor::new(3);
    let data = 1..=10;

    processor.process_stream(data);
}
```

### æ¡ˆä¾‹3: æ¸¸æˆä¸»å¾ªç¯

```rust
use std::time::{Duration, Instant};

struct Game {
    running: bool,
    score: i32,
    frame_count: u64,
    target_fps: u32,
}

impl Game {
    fn new() -> Self {
        Game {
            running: true,
            score: 0,
            frame_count: 0,
            target_fps: 60,
        }
    }

    fn run(&mut self) {
        let frame_duration = Duration::from_secs(1) / self.target_fps;

        'game: loop {
            let frame_start = Instant::now();

            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            self.update();

            // æ¸²æŸ“
            self.render();

            // å¤„ç†è¾“å…¥
            self.handle_input();

            // æ£€æŸ¥é€€å‡º
            if !self.running {
                break 'game;
            }

            self.frame_count += 1;

            // å¸§ç‡é™åˆ¶
            let elapsed = frame_start.elapsed();
            if elapsed < frame_duration {
                std::thread::sleep(frame_duration - elapsed);
            }

            // æ¨¡æ‹Ÿï¼šè¿è¡Œ10å¸§åé€€å‡º
            if self.frame_count >= 10 {
                self.running = false;
            }
        }

        println!("æ¸¸æˆç»“æŸï¼æ€»å¸§æ•°: {}, å¾—åˆ†: {}", self.frame_count, self.score);
    }

    fn update(&mut self) {
        // æ›´æ–°æ¸¸æˆé€»è¾‘
        self.score += 1;
    }

    fn render(&self) {
        println!("æ¸²æŸ“å¸§ #{}, å¾—åˆ†: {}", self.frame_count, self.score);
    }

    fn handle_input(&mut self) {
        // å¤„ç†ç”¨æˆ·è¾“å…¥
    }
}

fn main() {
    let mut game = Game::new();
    game.run();
}
```

### æ¡ˆä¾‹4: å¹¶å‘ä»»åŠ¡è°ƒåº¦

```rust
use std::collections::VecDeque;

#[derive(Debug, Clone)]
struct Task {
    id: usize,
    priority: u8,
    work: fn() -> i32,
}

struct Scheduler {
    tasks: VecDeque<Task>,
    max_iterations: usize,
}

impl Scheduler {
    fn new(max_iterations: usize) -> Self {
        Scheduler {
            tasks: VecDeque::new(),
            max_iterations,
        }
    }

    fn add_task(&mut self, task: Task) {
        // æŒ‰ä¼˜å…ˆçº§æ’å…¥
        let mut inserted = false;
        for (i, existing) in self.tasks.iter().enumerate() {
            if task.priority > existing.priority {
                self.tasks.insert(i, task.clone());
                inserted = true;
                break;
            }
        }

        if !inserted {
            self.tasks.push_back(task);
        }
    }

    fn run(&mut self) {
        let mut iterations = 0;

        'schedule: loop {
            // æ‰§è¡Œä¸€ä¸ªä»»åŠ¡
            if let Some(task) = self.tasks.pop_front() {
                println!("æ‰§è¡Œä»»åŠ¡ {} (ä¼˜å…ˆçº§ {})", task.id, task.priority);
                let result = (task.work)();
                println!("ä»»åŠ¡ {} å®Œæˆï¼Œç»“æœ: {}", task.id, result);
            }

            iterations += 1;

            // æ£€æŸ¥é€€å‡ºæ¡ä»¶
            if self.tasks.is_empty() || iterations >= self.max_iterations {
                break 'schedule;
            }
        }

        println!("è°ƒåº¦å®Œæˆï¼Œæ‰§è¡Œäº† {} æ¬¡è¿­ä»£", iterations);
    }
}

fn work1() -> i32 {
    println!("  å·¥ä½œ1æ‰§è¡Œä¸­...");
    42
}

fn work2() -> i32 {
    println!("  å·¥ä½œ2æ‰§è¡Œä¸­...");
    100
}

fn work3() -> i32 {
    println!("  å·¥ä½œ3æ‰§è¡Œä¸­...");
    7
}

fn main() {
    let mut scheduler = Scheduler::new(10);

    scheduler.add_task(Task { id: 1, priority: 5, work: work1 });
    scheduler.add_task(Task { id: 2, priority: 10, work: work2 });
    scheduler.add_task(Task { id: 3, priority: 3, work: work3 });

    scheduler.run();
}
```

### æ¡ˆä¾‹5: è¿­ä»£å™¨ç»„åˆå™¨

```rust
struct ChunkIterator<I>
where
    I: Iterator,
{
    inner: I,
    chunk_size: usize,
}

impl<I> ChunkIterator<I>
where
    I: Iterator,
{
    fn new(inner: I, chunk_size: usize) -> Self {
        ChunkIterator { inner, chunk_size }
    }
}

impl<I> Iterator for ChunkIterator<I>
where
    I: Iterator,
{
    type Item = Vec<I::Item>;

    fn next(&mut self) -> Option<Self::Item> {
        let mut chunk = Vec::with_capacity(self.chunk_size);

        for _ in 0..self.chunk_size {
            match self.inner.next() {
                Some(item) => chunk.push(item),
                None => break,
            }
        }

        if chunk.is_empty() {
            None
        } else {
            Some(chunk)
        }
    }
}

// æ»‘åŠ¨çª—å£è¿­ä»£å™¨
struct WindowIterator<I>
where
    I: Iterator,
{
    inner: I,
    window: VecDeque<I::Item>,
    window_size: usize,
    started: bool,
}

impl<I> WindowIterator<I>
where
    I: Iterator,
    I::Item: Clone,
{
    fn new(mut inner: I, window_size: usize) -> Self {
        let mut window = VecDeque::with_capacity(window_size);

        // åˆå§‹åŒ–çª—å£
        for _ in 0..window_size {
            if let Some(item) = inner.next() {
                window.push_back(item);
            }
        }

        WindowIterator {
            inner,
            window,
            window_size,
            started: false,
        }
    }
}

impl<I> Iterator for WindowIterator<I>
where
    I: Iterator,
    I::Item: Clone,
{
    type Item = Vec<I::Item>;

    fn next(&mut self) -> Option<Self::Item> {
        if !self.started {
            self.started = true;
            if self.window.len() == self.window_size {
                return Some(self.window.iter().cloned().collect());
            }
        }

        if let Some(item) = self.inner.next() {
            self.window.pop_front();
            self.window.push_back(item);
            Some(self.window.iter().cloned().collect())
        } else {
            None
        }
    }
}

fn main() {
    // ä½¿ç”¨å—è¿­ä»£å™¨
    println!("å—è¿­ä»£å™¨:");
    let chunks = ChunkIterator::new(1..=10, 3);
    for chunk in chunks {
        println!("{:?}", chunk);
    }

    // ä½¿ç”¨æ»‘åŠ¨çª—å£
    println!("\næ»‘åŠ¨çª—å£:");
    let windows = WindowIterator::new(1..=8, 3);
    for window in windows {
        println!("{:?}", window);
    }
}
```

### æ¡ˆä¾‹6: è¿­ä»£å™¨ä¸é—­åŒ…ååŒ

è¿­ä»£å™¨ä¸é—­åŒ…åœ¨æ§åˆ¶æµä¸­ååŒï¼šé—­åŒ…ä½œä¸ºé€‚é…å™¨å‚æ•°ï¼Œå®ç°è¿‡æ»¤ã€è½¬æ¢ã€æŠ˜å ç­‰ï¼š

```rust
fn main() {
    let nums = vec![1, 2, 3, 4, 5];

    // é—­åŒ… + filter + mapï¼šè¿‡æ»¤å¶æ•°å¹¶å¹³æ–¹
    let result: Vec<_> = nums.iter()
        .filter(|&x| x % 2 == 0)      // é—­åŒ…ï¼šè°“è¯
        .map(|x| x * x)                // é—­åŒ…ï¼šè½¬æ¢
        .collect();
    assert_eq!(result, vec![4, 16]);

    // é—­åŒ… + foldï¼šç´¯åŠ ï¼ˆå¸¦åˆå§‹å€¼ï¼‰
    let sum: i32 = nums.iter().fold(0, |acc, x| acc + x);
    assert_eq!(sum, 15);

    // é—­åŒ… + filter_mapï¼šè¿‡æ»¤å¹¶è½¬æ¢ï¼ˆOptionï¼‰
    let parsed: Vec<i32> = ["1", "a", "2", "b", "3"]
        .iter()
        .filter_map(|s| s.parse().ok())  // é—­åŒ…è¿”å› Option
        .collect();
    assert_eq!(parsed, vec![1, 2, 3]);

    // é—­åŒ…æ•è·ï¼šåœ¨è¿­ä»£ä¸­ç´¯ç§¯çŠ¶æ€
    let mut counter = 0;
    let indexed: Vec<_> = nums.iter()
        .map(|x| {
            counter += 1;
            (counter - 1, x)
        })
        .collect();
    assert_eq!(indexed, vec![(0, &1), (1, &2), (2, &3), (3, &4), (4, &5)]);
}
```

è¯¦è§ [è¿­ä»£å™¨å‚è€ƒ](../tier_03_references/02_è¿­ä»£å™¨å‚è€ƒ.md)ã€[é—­åŒ…æ·±å…¥](../tier_04_advanced/02_é—­åŒ…æ·±å…¥.md)ã€‚

---

## 7. å¸¸è§é™·é˜±

### 7.1 æ— é™å¾ªç¯

```rust
fn main() {
    // âŒ å¿˜è®°æ›´æ–°æ¡ä»¶
    /*
    let mut x = 0;
    while x < 10 {
        println!("x = {}", x);
        // å¿˜è®° x += 1ï¼Œå¯¼è‡´æ— é™å¾ªç¯
    }
    */

    // âœ… æ­£ç¡®ï¼šæ›´æ–°æ¡ä»¶
    let mut x = 0;
    while x < 10 {
        println!("x = {}", x);
        x += 1;
    }

    // âŒ é”™è¯¯çš„breakæ¡ä»¶
    /*
    let mut count = 0;
    loop {
        count += 1;
        if count > 10 {  // åº”è¯¥æ˜¯ >= æˆ– ==
            // break;  // å¿˜è®° break
        }
    }
    */

    // âœ… æ­£ç¡®ï¼šæ˜ç¡®çš„é€€å‡ºæ¡ä»¶
    let mut count = 0;
    loop {
        count += 1;
        if count >= 10 {
            break;
        }
    }
}
```

### 7.2 æ‰€æœ‰æƒé—®é¢˜

```rust
fn main() {
    // âŒ é”™è¯¯ï¼šç§»åŠ¨æ‰€æœ‰æƒ
    let vec = vec![String::from("a"), String::from("b")];
    /*
    for s in vec {
        println!("{}", s);
    }
    // vec å·²è¢«ç§»åŠ¨
    println!("{:?}", vec);  // é”™è¯¯ï¼
    */

    // âœ… æ­£ç¡®ï¼šå€Ÿç”¨
    let vec = vec![String::from("a"), String::from("b")];
    for s in &vec {
        println!("{}", s);
    }
    println!("{:?}", vec);  // å¯ä»¥ä½¿ç”¨

    // âŒ é”™è¯¯ï¼šå¯å˜å€Ÿç”¨å†²çª
    let mut vec = vec![1, 2, 3];
    /*
    for item in &vec {
        vec.push(*item);  // é”™è¯¯ï¼šåŒæ—¶å­˜åœ¨ä¸å¯å˜å’Œå¯å˜å€Ÿç”¨
    }
    */

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ç´¢å¼•
    let mut vec = vec![1, 2, 3];
    let len = vec.len();
    for i in 0..len {
        vec.push(vec[i]);
    }
    println!("{:?}", vec);
}
```

### 7.3 æ€§èƒ½é™·é˜±

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];

    // âŒ ä¸æ¨èï¼šåœ¨å¾ªç¯ä¸­å…‹éš†
    /*
    for i in 0..vec.len() {
        let item = vec[i].clone();  // ä¸å¿…è¦çš„å…‹éš†
        println!("{}", item);
    }
    */

    // âœ… æ¨èï¼šç›´æ¥å€Ÿç”¨
    for item in &vec {
        println!("{}", item);
    }

    // âŒ ä¸æ¨èï¼šé‡å¤è®¡ç®—
    let data = vec![1, 2, 3, 4, 5];
    /*
    for i in 0..data.len() {  // æ¯æ¬¡è¿­ä»£éƒ½è®¡ç®— len()
        println!("{}", data[i]);
    }
    */

    // âœ… æ¨èï¼šä½¿ç”¨è¿­ä»£å™¨
    for item in &data {
        println!("{}", item);
    }

    // âŒ ä¸æ¨èï¼šä¸å¿…è¦çš„è¾¹ç•Œæ£€æŸ¥
    /*
    for i in 0..vec.len() {
        println!("{}", vec[i]);  // è¾¹ç•Œæ£€æŸ¥
    }
    */

    // âœ… æ¨èï¼šä½¿ç”¨è¿­ä»£å™¨ï¼ˆæ— è¾¹ç•Œæ£€æŸ¥ï¼‰
    for item in &vec {
        println!("{}", item);
    }
}
```

### 7.4 å¯å˜æ€§é—®é¢˜

```rust
fn main() {
    // âŒ é”™è¯¯ï¼šå¿˜è®° mut
    /*
    let mut vec = vec![1, 2, 3];
    for item in &vec {  // ä¸å¯å˜å€Ÿç”¨
        *item += 1;  // é”™è¯¯ï¼šæ— æ³•ä¿®æ”¹
    }
    */

    // âœ… æ­£ç¡®ï¼šå¯å˜å€Ÿç”¨
    let mut vec = vec![1, 2, 3];
    for item in &mut vec {
        *item += 1;
    }
    println!("{:?}", vec);

    // âŒ é”™è¯¯ï¼šå¾ªç¯ä¸­ä¿®æ”¹é›†åˆå¤§å°
    let mut vec = vec![1, 2, 3, 4, 5];
    /*
    for (i, &item) in vec.iter().enumerate() {
        if item % 2 == 0 {
            vec.remove(i);  // å±é™©ï¼šä¿®æ”¹æ­£åœ¨è¿­ä»£çš„é›†åˆ
        }
    }
    */

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ retain
    let mut vec = vec![1, 2, 3, 4, 5];
    vec.retain(|&x| x % 2 != 0);
    println!("{:?}", vec);

    // âœ… æ­£ç¡®ï¼šæ”¶é›†ç´¢å¼•ååˆ é™¤
    let mut vec = vec![1, 2, 3, 4, 5];
    let to_remove: Vec<usize> = vec.iter()
        .enumerate()
        .filter(|(_, &item)| item % 2 == 0)
        .map(|(i, _)| i)
        .collect();

    for &i in to_remove.iter().rev() {
        vec.remove(i);
    }
    println!("{:?}", vec);
}
```

---

## 8. æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨ for å¾ªç¯éå†é›†åˆ**
2. **ä½¿ç”¨è¿­ä»£å™¨æ–¹æ³•ç®€åŒ–ä»£ç **
3. **é¿å…åœ¨å¾ªç¯ä¸­è¿›è¡Œæ˜‚è´µæ“ä½œ**
4. **ä½¿ç”¨å€Ÿç”¨è€Œéç§»åŠ¨æ‰€æœ‰æƒ**
5. **åˆç†ä½¿ç”¨å¾ªç¯æ ‡ç­¾æ§åˆ¶åµŒå¥—å¾ªç¯**
6. **è€ƒè™‘ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨æ›¿ä»£æ˜¾å¼å¾ªç¯**
7. **åœ¨éœ€è¦è¿”å›å€¼æ—¶ä½¿ç”¨ loop**
8. **é¿å…ä¿®æ”¹æ­£åœ¨è¿­ä»£çš„é›†åˆ**

---

## 9. æ€§èƒ½ä¼˜åŒ–

1. **ä½¿ç”¨è¿­ä»£å™¨**: ç¼–è¯‘å™¨å¯ä»¥æ›´å¥½åœ°ä¼˜åŒ–
2. **é¿å…è¾¹ç•Œæ£€æŸ¥**: ä½¿ç”¨è¿­ä»£å™¨è€Œéç´¢å¼•
3. **å‡å°‘å…‹éš†**: ä½¿ç”¨å¼•ç”¨
4. **ç¼“å­˜è®¡ç®—ç»“æœ**: é¿å…é‡å¤è®¡ç®—
5. **è€ƒè™‘å¹¶è¡Œè¿­ä»£**: ä½¿ç”¨ rayon ç­‰åº“
6. **ä½¿ç”¨ `collect` é¢„åˆ†é…**: æŒ‡å®šå®¹é‡é¿å…å¤šæ¬¡åˆ†é…

---

## 10. å°ç»“

- loop ç”¨äºæ— é™å¾ªç¯ï¼Œå¯è¿”å›å€¼
- while ç”¨äºæ¡ä»¶å¾ªç¯
- for ç”¨äºè¿­ä»£é›†åˆï¼Œæœ€å¸¸ç”¨
- è¿­ä»£å™¨æä¾›å¼ºå¤§çš„æ•°æ®å¤„ç†èƒ½åŠ›
- åˆç†ä½¿ç”¨ break/continue æ§åˆ¶æµç¨‹
- ä¼˜å…ˆè€ƒè™‘å¯è¯»æ€§å’Œæ­£ç¡®æ€§

---

## 11. å»¶ä¼¸é˜…è¯»

**å†…éƒ¨æ–‡æ¡£**:

- [æ¡ä»¶è¯­å¥æŒ‡å—](./01_æ¡ä»¶è¯­å¥æŒ‡å—.md)
- [è¿­ä»£å™¨å‚è€ƒ](../tier_03_references/02_è¿­ä»£å™¨å‚è€ƒ.md)
- [æ§åˆ¶æµå‚è€ƒ](../tier_03_references/01_æ§åˆ¶æµå‚è€ƒ.md)

**å¤–éƒ¨èµ„æº**:

- [Rust Book - Loops](https://doc.rust-lang.org/book/ch03-05-control-flow.html#repetition-with-loops)
- [Rust Reference - Loop Expressions](https://doc.rust-lang.org/reference/expressions/loop-expr.html)
- [Rust by Example - Loops](https://doc.rust-lang.org/rust-by-example/flow_control/loop.html)

---

## 12. ç»ƒä¹ é¢˜

1. å®ç°ä¸€ä¸ªè‡ªå®šä¹‰è¿­ä»£å™¨ï¼Œç”Ÿæˆè´¨æ•°åºåˆ—
2. ä½¿ç”¨å¾ªç¯æ ‡ç­¾å®ç°å¤šå±‚å¾ªç¯çš„å¤æ‚æ§åˆ¶
3. ç¼–å†™ä¸€ä¸ªæ•°æ®æµå¤„ç†å™¨ï¼Œæ”¯æŒæ‰¹å¤„ç†å’Œæµå¼å¤„ç†
4. å®ç°ä¸€ä¸ªç®€å•çš„ä»»åŠ¡è°ƒåº¦å™¨ï¼Œæ”¯æŒä¼˜å…ˆçº§é˜Ÿåˆ—
5. ä½¿ç”¨è¿­ä»£å™¨ç»„åˆå®ç°æ»‘åŠ¨çª—å£ç®—æ³•

---

**æœ€åæ›´æ–°**: 2025-12-11
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ¯ æŒæ¡Rustå¾ªç¯ç»“æ„ï¼Œé«˜æ•ˆå¤„ç†æ•°æ®è¿­ä»£ï¼** ğŸ¦€âœ¨
