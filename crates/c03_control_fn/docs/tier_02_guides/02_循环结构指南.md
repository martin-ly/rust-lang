# 2.2 循环结构指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统化学习Rust循环结构，掌握loop/while/for核心用法  
> **学习时间**: 1-2天  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [项目概览](../tier_01_foundations/01_项目概览.md)

## 📋 目录

- [2.2 循环结构指南](#22-循环结构指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. loop 无限循环](#1-loop-无限循环)
    - [1.1 基本语法](#11-基本语法)
    - [1.2 循环标签](#12-循环标签)
    - [1.3 从循环返回值](#13-从循环返回值)
    - [1.4 使用场景](#14-使用场景)
  - [2. while 条件循环](#2-while-条件循环)
    - [2.1 基本语法](#21-基本语法)
    - [2.2 while let 模式](#22-while-let-模式)
    - [2.3 常见模式](#23-常见模式)
  - [3. for 迭代循环](#3-for-迭代循环)
    - [3.1 基本语法](#31-基本语法)
    - [3.2 迭代器方法](#32-迭代器方法)
    - [3.3 范围表达式](#33-范围表达式)
    - [3.4 自定义迭代器](#34-自定义迭代器)
  - [4. break 和 continue](#4-break-和-continue)
    - [4.1 基本用法](#41-基本用法)
    - [4.2 带标签的break/continue](#42-带标签的breakcontinue)
    - [4.3 从循环返回值](#43-从循环返回值)
  - [5. 循环对比](#5-循环对比)
    - [5.1 功能对比](#51-功能对比)
    - [5.2 性能对比](#52-性能对比)
    - [5.3 选择指南](#53-选择指南)
  - [6. 实战案例](#6-实战案例)
    - [案例1: 事件循环处理](#案例1-事件循环处理)
    - [案例2: 数据流处理器](#案例2-数据流处理器)
    - [案例3: 游戏主循环](#案例3-游戏主循环)
    - [案例4: 并发任务调度](#案例4-并发任务调度)
    - [案例5: 迭代器组合器](#案例5-迭代器组合器)
  - [7. 常见陷阱](#7-常见陷阱)
    - [7.1 无限循环](#71-无限循环)
    - [7.2 所有权问题](#72-所有权问题)
    - [7.3 性能陷阱](#73-性能陷阱)
    - [7.4 可变性问题](#74-可变性问题)
  - [8. 最佳实践](#8-最佳实践)
  - [9. 性能优化](#9-性能优化)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)

---

## 🎯 学习目标

完成本指南学习后，您将能够：

- ✅ 掌握 loop/while/for 三种循环的使用
- ✅ 理解循环标签和控制流
- ✅ 熟练使用迭代器进行数据处理
- ✅ 应用循环解决实际问题
- ✅ 优化循环性能
- ✅ 避免常见陷阱，编写高效代码

---

## 1. loop 无限循环

### 1.1 基本语法

loop 创建无限循环，必须显式 break：

```rust
fn main() {
    // 基本无限循环
    let mut count = 0;
    loop {
        count += 1;
        println!("计数: {}", count);
        
        if count >= 5 {
            break;
        }
    }
    
    // 等同于传统语言的 while(true)
    let mut i = 0;
    loop {
        if i >= 3 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}
```

**关键要点**:

- loop 是表达式，可以返回值
- 必须有 break 或 return 退出（除非程序终止）
- 编译器知道 loop 会一直执行，有助于优化

### 1.2 循环标签

使用标签控制嵌套循环：

```rust
fn main() {
    // 嵌套循环标签
    'outer: loop {
        println!("进入外层循环");
        let mut inner_count = 0;
        
        'inner: loop {
            inner_count += 1;
            println!("  内层循环: {}", inner_count);
            
            if inner_count >= 3 {
                println!("  跳出外层循环");
                break 'outer;  // 跳出外层循环
            }
            
            if inner_count == 1 {
                continue 'inner;  // 继续内层循环
            }
        }
    }
    
    println!("循环结束");
    
    // 多层嵌套
    'first: loop {
        'second: loop {
            'third: loop {
                println!("最内层");
                break 'first;  // 直接跳出最外层
            }
            println!("这行不会执行");
        }
        println!("这行也不会执行");
    }
    println!("完全退出");
}
```

### 1.3 从循环返回值

loop 可以通过 break 返回值：

```rust
fn main() {
    // 从循环返回值
    let mut counter = 0;
    let result = loop {
        counter += 1;
        
        if counter == 10 {
            break counter * 2;  // 返回值
        }
    };
    
    println!("结果: {}", result);  // 20
    
    // 复杂返回值
    let value = loop {
        let random = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() % 100;
        
        if random > 50 {
            break Some(random);
        }
        
        if counter > 100 {
            break None;
        }
        
        counter += 1;
    };
    
    println!("找到的值: {:?}", value);
    
    // 带标签的返回值
    let result = 'block: loop {
        let x = 10;
        loop {
            if x == 10 {
                break 'block x * 2;  // 从外层循环返回
            }
        }
    };
    
    println!("标签返回值: {}", result);
}
```

### 1.4 使用场景

loop 适合的典型场景：

```rust
use std::io::{self, Write};

fn main() {
    // 场景1: 事件循环
    event_loop();
    
    // 场景2: 重试逻辑
    let result = retry_operation(|| {
        // 模拟可能失败的操作
        Ok(42)
    }, 3);
    println!("重试结果: {:?}", result);
    
    // 场景3: 状态机
    run_state_machine();
}

fn event_loop() {
    let mut should_quit = false;
    let mut event_count = 0;
    
    loop {
        // 模拟事件处理
        event_count += 1;
        println!("处理事件 #{}", event_count);
        
        if event_count >= 3 {
            should_quit = true;
        }
        
        if should_quit {
            println!("退出事件循环");
            break;
        }
    }
}

fn retry_operation<F, T, E>(mut operation: F, max_retries: u32) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        attempts += 1;
        
        match operation() {
            Ok(value) => break Ok(value),
            Err(err) if attempts >= max_retries => break Err(err),
            Err(_) => {
                println!("重试 {}/{}", attempts, max_retries);
                continue;
            }
        }
    }
}

#[derive(Debug)]
enum State {
    Start,
    Processing,
    Done,
}

fn run_state_machine() {
    let mut state = State::Start;
    let mut iterations = 0;
    
    loop {
        iterations += 1;
        println!("状态: {:?}", state);
        
        state = match state {
            State::Start => State::Processing,
            State::Processing if iterations > 2 => State::Done,
            State::Processing => State::Processing,
            State::Done => break,
        };
    }
    
    println!("状态机完成");
}
```

---

## 2. while 条件循环

### 2.1 基本语法

while 在条件为真时循环：

```rust
fn main() {
    // 基本 while
    let mut count = 0;
    while count < 5 {
        println!("count = {}", count);
        count += 1;
    }
    
    // 复杂条件
    let mut x = 10;
    let mut y = 20;
    while x < y && x < 15 {
        x += 1;
        y -= 1;
        println!("x = {}, y = {}", x, y);
    }
    
    // 布尔变量控制
    let mut running = true;
    let mut tick = 0;
    while running {
        tick += 1;
        println!("Tick {}", tick);
        
        if tick >= 3 {
            running = false;
        }
    }
}
```

**关键要点**:

- 条件在每次迭代前检查
- 条件必须是 bool 类型
- 条件为 false 时退出循环

### 2.2 while let 模式

while let 用于模式匹配循环：

```rust
fn main() {
    // Option 解包
    let mut stack = vec![1, 2, 3, 4, 5];
    
    while let Some(top) = stack.pop() {
        println!("弹出: {}", top);
    }
    
    // 迭代器模式
    let mut iter = vec![10, 20, 30].into_iter();
    while let Some(value) = iter.next() {
        println!("值: {}", value);
    }
    
    // Result 处理
    fn get_next() -> Option<Result<i32, String>> {
        static mut COUNTER: i32 = 0;
        unsafe {
            COUNTER += 1;
            if COUNTER <= 3 {
                Some(Ok(COUNTER))
            } else {
                None
            }
        }
    }
    
    while let Some(Ok(value)) = get_next() {
        println!("成功值: {}", value);
    }
    
    // 解构枚举
    #[derive(Debug)]
    enum Message {
        Text(String),
        Number(i32),
        Quit,
    }
    
    let messages = vec![
        Message::Text("Hello".to_string()),
        Message::Number(42),
        Message::Text("World".to_string()),
        Message::Quit,
    ];
    
    let mut iter = messages.into_iter();
    while let Some(msg) = iter.next() {
        match msg {
            Message::Text(s) => println!("文本: {}", s),
            Message::Number(n) => println!("数字: {}", n),
            Message::Quit => {
                println!("退出");
                break;
            }
        }
    }
}
```

### 2.3 常见模式

while 循环的典型使用模式：

```rust
use std::collections::VecDeque;

fn main() {
    // 模式1: 倒计时
    let mut countdown = 5;
    while countdown > 0 {
        println!("{}...", countdown);
        countdown -= 1;
    }
    println!("发射！");
    
    // 模式2: 队列处理
    let mut queue: VecDeque<i32> = VecDeque::new();
    queue.push_back(1);
    queue.push_back(2);
    queue.push_back(3);
    
    while let Some(item) = queue.pop_front() {
        println!("处理队列项: {}", item);
    }
    
    // 模式3: 条件累积
    let mut sum = 0;
    let mut n = 1;
    while sum < 100 {
        sum += n;
        n += 1;
    }
    println!("累积到100需要加到: {}, 总和: {}", n - 1, sum);
    
    // 模式4: 搜索直到找到
    let numbers = vec![1, 3, 5, 7, 9, 10, 12];
    let mut index = 0;
    while index < numbers.len() && numbers[index] % 2 != 0 {
        index += 1;
    }
    
    if index < numbers.len() {
        println!("第一个偶数在索引 {}: {}", index, numbers[index]);
    } else {
        println!("没有找到偶数");
    }
}
```

---

## 3. for 迭代循环

### 3.1 基本语法

for 用于遍历迭代器：

```rust
fn main() {
    // 遍历数组
    let array = [10, 20, 30, 40, 50];
    for element in array {
        println!("元素: {}", element);
    }
    
    // 遍历 Vec
    let vec = vec![1, 2, 3, 4, 5];
    for num in &vec {  // 借用
        println!("数字: {}", num);
    }
    
    // 可变遍历
    let mut vec = vec![1, 2, 3];
    for num in &mut vec {
        *num *= 2;
    }
    println!("加倍后: {:?}", vec);
    
    // 消费遍历
    let vec = vec![String::from("a"), String::from("b")];
    for s in vec {  // 获取所有权
        println!("字符串: {}", s);
    }
    // vec 已被移动，不能再使用
    
    // 遍历范围
    for i in 0..5 {
        println!("i = {}", i);
    }
    
    // 包含范围
    for i in 0..=5 {
        println!("包含5: i = {}", i);
    }
}
```

**关键要点**:

- for 使用 IntoIterator trait
- `&collection` 借用元素
- `&mut collection` 可变借用
- `collection` 获取所有权

### 3.2 迭代器方法

使用迭代器方法增强 for 循环：

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // enumerate - 获取索引
    for (index, value) in vec.iter().enumerate() {
        println!("索引 {}: 值 {}", index, value);
    }
    
    // rev - 反向迭代
    for num in (1..=5).rev() {
        println!("倒数: {}", num);
    }
    
    // filter - 过滤
    for even in (1..=10).filter(|x| x % 2 == 0) {
        println!("偶数: {}", even);
    }
    
    // map - 转换
    for squared in (1..=5).map(|x| x * x) {
        println!("平方: {}", squared);
    }
    
    // zip - 组合两个迭代器
    let names = vec!["Alice", "Bob", "Carol"];
    let scores = vec![85, 92, 78];
    
    for (name, score) in names.iter().zip(scores.iter()) {
        println!("{}: {}", name, score);
    }
    
    // chain - 连接迭代器
    let a = vec![1, 2, 3];
    let b = vec![4, 5, 6];
    
    for num in a.iter().chain(b.iter()) {
        println!("连接: {}", num);
    }
    
    // take - 限制数量
    for num in (1..).take(5) {
        println!("前5个: {}", num);
    }
    
    // skip - 跳过元素
    for num in (1..=10).skip(5) {
        println!("跳过前5个: {}", num);
    }
}
```

### 3.3 范围表达式

Rust 提供多种范围表达式：

```rust
fn main() {
    // 左闭右开: 0..5 => [0, 1, 2, 3, 4]
    for i in 0..5 {
        print!("{} ", i);
    }
    println!();
    
    // 左闭右闭: 0..=5 => [0, 1, 2, 3, 4, 5]
    for i in 0..=5 {
        print!("{} ", i);
    }
    println!();
    
    // 开始范围: 5.. (无限)
    for i in (5..).take(3) {
        print!("{} ", i);
    }
    println!();
    
    // 结束范围: ..5 => [0, 1, 2, 3, 4]
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    for i in &arr[..5] {
        print!("{} ", i);
    }
    println!();
    
    // 全范围: .. (用于切片)
    for i in &arr[..] {
        print!("{} ", i);
    }
    println!();
    
    // 步长（需要 step_by）
    for i in (0..10).step_by(2) {
        print!("{} ", i);
    }
    println!();
    
    // 反向步长
    for i in (0..10).rev().step_by(2) {
        print!("{} ", i);
    }
    println!();
}
```

### 3.4 自定义迭代器

实现 Iterator trait 创建自定义迭代器：

```rust
// 简单计数器
struct Counter {
    count: u32,
    max: u32,
}

impl Counter {
    fn new(max: u32) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = u32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

// 斐波那契数列
struct Fibonacci {
    curr: u64,
    next: u64,
}

impl Fibonacci {
    fn new() -> Self {
        Fibonacci { curr: 0, next: 1 }
    }
}

impl Iterator for Fibonacci {
    type Item = u64;
    
    fn next(&mut self) -> Option<Self::Item> {
        let current = self.curr;
        self.curr = self.next;
        self.next = current + self.next;
        Some(current)
    }
}

// 范围迭代器
struct RangeIter {
    start: i32,
    end: i32,
    step: i32,
}

impl RangeIter {
    fn new(start: i32, end: i32, step: i32) -> Self {
        RangeIter { start, end, step }
    }
}

impl Iterator for RangeIter {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.start < self.end {
            let current = self.start;
            self.start += self.step;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    // 使用自定义计数器
    println!("计数器:");
    for num in Counter::new(5) {
        print!("{} ", num);
    }
    println!();
    
    // 使用斐波那契
    println!("斐波那契数列前10个:");
    for fib in Fibonacci::new().take(10) {
        print!("{} ", fib);
    }
    println!();
    
    // 使用范围迭代器
    println!("步长为3的范围:");
    for num in RangeIter::new(0, 20, 3) {
        print!("{} ", num);
    }
    println!();
}
```

---

## 4. break 和 continue

### 4.1 基本用法

break 退出循环，continue 跳过当前迭代：

```rust
fn main() {
    // break 基本用法
    for i in 0..10 {
        if i == 5 {
            break;  // 在5时退出
        }
        println!("i = {}", i);
    }
    
    // continue 基本用法
    for i in 0..10 {
        if i % 2 == 0 {
            continue;  // 跳过偶数
        }
        println!("奇数: {}", i);
    }
    
    // 结合使用
    for i in 0..20 {
        if i % 2 == 0 {
            continue;  // 跳过偶数
        }
        if i > 10 {
            break;  // 大于10退出
        }
        println!("奇数且<=10: {}", i);
    }
}
```

### 4.2 带标签的break/continue

在嵌套循环中使用标签：

```rust
fn main() {
    // 嵌套循环的 break
    'outer: for i in 0..5 {
        for j in 0..5 {
            if i * j > 10 {
                println!("中断在 i={}, j={}", i, j);
                break 'outer;  // 跳出外层
            }
            print!("({},{}) ", i, j);
        }
        println!();
    }
    
    // 嵌套循环的 continue
    'outer: for i in 0..5 {
        for j in 0..5 {
            if j == 2 {
                continue 'outer;  // 跳到外层下一次
            }
            print!("({},{}) ", i, j);
        }
        println!();
    }
    
    // 复杂嵌套
    'search: for i in 0..10 {
        'inner: for j in 0..10 {
            for k in 0..10 {
                if i + j + k == 15 {
                    println!("找到: i={}, j={}, k={}", i, j, k);
                    break 'search;  // 跳出所有循环
                }
            }
        }
    }
}
```

### 4.3 从循环返回值

使用 break 返回值：

```rust
fn main() {
    // 从 loop 返回值
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("结果: {}", result);
    
    // 搜索并返回
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let first_even = loop {
        static mut INDEX: usize = 0;
        unsafe {
            if INDEX >= numbers.len() {
                break None;
            }
            let num = numbers[INDEX];
            INDEX += 1;
            if num % 2 == 0 {
                break Some(num);
            }
        }
    };
    println!("第一个偶数: {:?}", first_even);
    
    // 带标签返回值
    let result = 'block: loop {
        for i in 0..10 {
            if i == 5 {
                break 'block i * 10;
            }
        }
    };
    println!("标签返回值: {}", result);
}
```

---

## 5. 循环对比

### 5.1 功能对比

| 特性 | loop | while | for |
|------|------|-------|-----|
| **用途** | 无限循环 | 条件循环 | 迭代循环 |
| **退出条件** | 显式 break | 条件为 false | 迭代器耗尽 |
| **返回值** | ✅ 支持 | ❌ 不支持 | ❌ 不支持 |
| **标签** | ✅ 支持 | ✅ 支持 | ✅ 支持 |
| **适用场景** | 事件循环、重试 | 条件判断 | 集合遍历 |
| **性能** | 最优化 | 良好 | 最优 |
| **可读性** | 中等 | 良好 | 最佳 |

### 5.2 性能对比

```rust
use std::time::Instant;

fn benchmark_loops() {
    let iterations = 10_000_000;
    
    // loop 性能
    let start = Instant::now();
    let mut sum = 0;
    let mut i = 0;
    loop {
        if i >= iterations {
            break;
        }
        sum += i;
        i += 1;
    }
    println!("loop: {:?}, sum = {}", start.elapsed(), sum);
    
    // while 性能
    let start = Instant::now();
    let mut sum = 0;
    let mut i = 0;
    while i < iterations {
        sum += i;
        i += 1;
    }
    println!("while: {:?}, sum = {}", start.elapsed(), sum);
    
    // for 性能
    let start = Instant::now();
    let mut sum = 0;
    for i in 0..iterations {
        sum += i;
    }
    println!("for: {:?}, sum = {}", start.elapsed(), sum);
    
    // 迭代器性能
    let start = Instant::now();
    let sum: i64 = (0..iterations).sum();
    println!("iterator sum: {:?}, sum = {}", start.elapsed(), sum);
}

fn main() {
    benchmark_loops();
}
```

**性能结论**:

- 在 release 模式下，三者性能基本相同
- 编译器会优化为相似的机器码
- for + 迭代器通常最易优化
- 优先考虑可读性，而非微小性能差异

### 5.3 选择指南

```rust
fn main() {
    // ✅ 使用 loop: 无限循环、事件循环
    let mut server_running = true;
    let mut count = 0;
    loop {
        // 处理请求
        count += 1;
        if count > 3 {
            server_running = false;
        }
        if !server_running {
            break;
        }
    }
    
    // ✅ 使用 while: 条件不确定
    let mut value = 100;
    while value > 0 {
        value -= 7;
    }
    println!("value: {}", value);
    
    // ✅ 使用 for: 遍历集合
    let numbers = vec![1, 2, 3, 4, 5];
    for num in &numbers {
        println!("num: {}", num);
    }
    
    // ✅ 使用 while let: 消费直到None
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("pop: {}", top);
    }
}
```

---

## 6. 实战案例

### 案例1: 事件循环处理

```rust
use std::collections::VecDeque;

#[derive(Debug)]
enum Event {
    KeyPress(char),
    MouseClick(i32, i32),
    Quit,
}

struct EventLoop {
    events: VecDeque<Event>,
    running: bool,
}

impl EventLoop {
    fn new() -> Self {
        EventLoop {
            events: VecDeque::new(),
            running: true,
        }
    }
    
    fn push_event(&mut self, event: Event) {
        self.events.push_back(event);
    }
    
    fn run(&mut self) {
        loop {
            // 处理所有待处理事件
            while let Some(event) = self.events.pop_front() {
                self.handle_event(event);
            }
            
            // 检查是否应该退出
            if !self.running {
                break;
            }
            
            // 模拟等待新事件
            std::thread::sleep(std::time::Duration::from_millis(100));
        }
    }
    
    fn handle_event(&mut self, event: Event) {
        match event {
            Event::KeyPress(c) => {
                println!("按键: {}", c);
                if c == 'q' {
                    self.running = false;
                }
            },
            Event::MouseClick(x, y) => {
                println!("鼠标点击: ({}, {})", x, y);
            },
            Event::Quit => {
                println!("退出事件");
                self.running = false;
            },
        }
    }
}

fn main() {
    let mut event_loop = EventLoop::new();
    
    // 添加一些测试事件
    event_loop.push_event(Event::KeyPress('a'));
    event_loop.push_event(Event::MouseClick(10, 20));
    event_loop.push_event(Event::KeyPress('b'));
    event_loop.push_event(Event::Quit);
    
    event_loop.run();
}
```

### 案例2: 数据流处理器

```rust
struct DataProcessor<T> {
    buffer: Vec<T>,
    batch_size: usize,
}

impl<T: Clone> DataProcessor<T> {
    fn new(batch_size: usize) -> Self {
        DataProcessor {
            buffer: Vec::new(),
            batch_size,
        }
    }
    
    fn process_stream<I>(&mut self, stream: I)
    where
        I: Iterator<Item = T>,
    {
        for item in stream {
            self.buffer.push(item);
            
            // 当缓冲区满时处理批次
            if self.buffer.len() >= self.batch_size {
                self.process_batch();
            }
        }
        
        // 处理剩余数据
        if !self.buffer.is_empty() {
            self.process_batch();
        }
    }
    
    fn process_batch(&mut self) {
        println!("处理批次，大小: {}", self.buffer.len());
        // 实际处理逻辑
        self.buffer.clear();
    }
}

fn main() {
    let mut processor = DataProcessor::new(3);
    let data = 1..=10;
    
    processor.process_stream(data);
}
```

### 案例3: 游戏主循环

```rust
use std::time::{Duration, Instant};

struct Game {
    running: bool,
    score: i32,
    frame_count: u64,
    target_fps: u32,
}

impl Game {
    fn new() -> Self {
        Game {
            running: true,
            score: 0,
            frame_count: 0,
            target_fps: 60,
        }
    }
    
    fn run(&mut self) {
        let frame_duration = Duration::from_secs(1) / self.target_fps;
        
        'game: loop {
            let frame_start = Instant::now();
            
            // 更新游戏状态
            self.update();
            
            // 渲染
            self.render();
            
            // 处理输入
            self.handle_input();
            
            // 检查退出
            if !self.running {
                break 'game;
            }
            
            self.frame_count += 1;
            
            // 帧率限制
            let elapsed = frame_start.elapsed();
            if elapsed < frame_duration {
                std::thread::sleep(frame_duration - elapsed);
            }
            
            // 模拟：运行10帧后退出
            if self.frame_count >= 10 {
                self.running = false;
            }
        }
        
        println!("游戏结束！总帧数: {}, 得分: {}", self.frame_count, self.score);
    }
    
    fn update(&mut self) {
        // 更新游戏逻辑
        self.score += 1;
    }
    
    fn render(&self) {
        println!("渲染帧 #{}, 得分: {}", self.frame_count, self.score);
    }
    
    fn handle_input(&mut self) {
        // 处理用户输入
    }
}

fn main() {
    let mut game = Game::new();
    game.run();
}
```

### 案例4: 并发任务调度

```rust
use std::collections::VecDeque;

#[derive(Debug, Clone)]
struct Task {
    id: usize,
    priority: u8,
    work: fn() -> i32,
}

struct Scheduler {
    tasks: VecDeque<Task>,
    max_iterations: usize,
}

impl Scheduler {
    fn new(max_iterations: usize) -> Self {
        Scheduler {
            tasks: VecDeque::new(),
            max_iterations,
        }
    }
    
    fn add_task(&mut self, task: Task) {
        // 按优先级插入
        let mut inserted = false;
        for (i, existing) in self.tasks.iter().enumerate() {
            if task.priority > existing.priority {
                self.tasks.insert(i, task.clone());
                inserted = true;
                break;
            }
        }
        
        if !inserted {
            self.tasks.push_back(task);
        }
    }
    
    fn run(&mut self) {
        let mut iterations = 0;
        
        'schedule: loop {
            // 执行一个任务
            if let Some(task) = self.tasks.pop_front() {
                println!("执行任务 {} (优先级 {})", task.id, task.priority);
                let result = (task.work)();
                println!("任务 {} 完成，结果: {}", task.id, result);
            }
            
            iterations += 1;
            
            // 检查退出条件
            if self.tasks.is_empty() || iterations >= self.max_iterations {
                break 'schedule;
            }
        }
        
        println!("调度完成，执行了 {} 次迭代", iterations);
    }
}

fn work1() -> i32 {
    println!("  工作1执行中...");
    42
}

fn work2() -> i32 {
    println!("  工作2执行中...");
    100
}

fn work3() -> i32 {
    println!("  工作3执行中...");
    7
}

fn main() {
    let mut scheduler = Scheduler::new(10);
    
    scheduler.add_task(Task { id: 1, priority: 5, work: work1 });
    scheduler.add_task(Task { id: 2, priority: 10, work: work2 });
    scheduler.add_task(Task { id: 3, priority: 3, work: work3 });
    
    scheduler.run();
}
```

### 案例5: 迭代器组合器

```rust
struct ChunkIterator<I>
where
    I: Iterator,
{
    inner: I,
    chunk_size: usize,
}

impl<I> ChunkIterator<I>
where
    I: Iterator,
{
    fn new(inner: I, chunk_size: usize) -> Self {
        ChunkIterator { inner, chunk_size }
    }
}

impl<I> Iterator for ChunkIterator<I>
where
    I: Iterator,
{
    type Item = Vec<I::Item>;
    
    fn next(&mut self) -> Option<Self::Item> {
        let mut chunk = Vec::with_capacity(self.chunk_size);
        
        for _ in 0..self.chunk_size {
            match self.inner.next() {
                Some(item) => chunk.push(item),
                None => break,
            }
        }
        
        if chunk.is_empty() {
            None
        } else {
            Some(chunk)
        }
    }
}

// 滑动窗口迭代器
struct WindowIterator<I>
where
    I: Iterator,
{
    inner: I,
    window: VecDeque<I::Item>,
    window_size: usize,
    started: bool,
}

impl<I> WindowIterator<I>
where
    I: Iterator,
    I::Item: Clone,
{
    fn new(mut inner: I, window_size: usize) -> Self {
        let mut window = VecDeque::with_capacity(window_size);
        
        // 初始化窗口
        for _ in 0..window_size {
            if let Some(item) = inner.next() {
                window.push_back(item);
            }
        }
        
        WindowIterator {
            inner,
            window,
            window_size,
            started: false,
        }
    }
}

impl<I> Iterator for WindowIterator<I>
where
    I: Iterator,
    I::Item: Clone,
{
    type Item = Vec<I::Item>;
    
    fn next(&mut self) -> Option<Self::Item> {
        if !self.started {
            self.started = true;
            if self.window.len() == self.window_size {
                return Some(self.window.iter().cloned().collect());
            }
        }
        
        if let Some(item) = self.inner.next() {
            self.window.pop_front();
            self.window.push_back(item);
            Some(self.window.iter().cloned().collect())
        } else {
            None
        }
    }
}

fn main() {
    // 使用块迭代器
    println!("块迭代器:");
    let chunks = ChunkIterator::new(1..=10, 3);
    for chunk in chunks {
        println!("{:?}", chunk);
    }
    
    // 使用滑动窗口
    println!("\n滑动窗口:");
    let windows = WindowIterator::new(1..=8, 3);
    for window in windows {
        println!("{:?}", window);
    }
}
```

---

## 7. 常见陷阱

### 7.1 无限循环

```rust
fn main() {
    // ❌ 忘记更新条件
    /*
    let mut x = 0;
    while x < 10 {
        println!("x = {}", x);
        // 忘记 x += 1，导致无限循环
    }
    */
    
    // ✅ 正确：更新条件
    let mut x = 0;
    while x < 10 {
        println!("x = {}", x);
        x += 1;
    }
    
    // ❌ 错误的break条件
    /*
    let mut count = 0;
    loop {
        count += 1;
        if count > 10 {  // 应该是 >= 或 ==
            // break;  // 忘记 break
        }
    }
    */
    
    // ✅ 正确：明确的退出条件
    let mut count = 0;
    loop {
        count += 1;
        if count >= 10 {
            break;
        }
    }
}
```

### 7.2 所有权问题

```rust
fn main() {
    // ❌ 错误：移动所有权
    let vec = vec![String::from("a"), String::from("b")];
    /*
    for s in vec {
        println!("{}", s);
    }
    // vec 已被移动
    println!("{:?}", vec);  // 错误！
    */
    
    // ✅ 正确：借用
    let vec = vec![String::from("a"), String::from("b")];
    for s in &vec {
        println!("{}", s);
    }
    println!("{:?}", vec);  // 可以使用
    
    // ❌ 错误：可变借用冲突
    let mut vec = vec![1, 2, 3];
    /*
    for item in &vec {
        vec.push(*item);  // 错误：同时存在不可变和可变借用
    }
    */
    
    // ✅ 正确：使用索引
    let mut vec = vec![1, 2, 3];
    let len = vec.len();
    for i in 0..len {
        vec.push(vec[i]);
    }
    println!("{:?}", vec);
}
```

### 7.3 性能陷阱

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // ❌ 不推荐：在循环中克隆
    /*
    for i in 0..vec.len() {
        let item = vec[i].clone();  // 不必要的克隆
        println!("{}", item);
    }
    */
    
    // ✅ 推荐：直接借用
    for item in &vec {
        println!("{}", item);
    }
    
    // ❌ 不推荐：重复计算
    let data = vec![1, 2, 3, 4, 5];
    /*
    for i in 0..data.len() {  // 每次迭代都计算 len()
        println!("{}", data[i]);
    }
    */
    
    // ✅ 推荐：使用迭代器
    for item in &data {
        println!("{}", item);
    }
    
    // ❌ 不推荐：不必要的边界检查
    /*
    for i in 0..vec.len() {
        println!("{}", vec[i]);  // 边界检查
    }
    */
    
    // ✅ 推荐：使用迭代器（无边界检查）
    for item in &vec {
        println!("{}", item);
    }
}
```

### 7.4 可变性问题

```rust
fn main() {
    // ❌ 错误：忘记 mut
    /*
    let mut vec = vec![1, 2, 3];
    for item in &vec {  // 不可变借用
        *item += 1;  // 错误：无法修改
    }
    */
    
    // ✅ 正确：可变借用
    let mut vec = vec![1, 2, 3];
    for item in &mut vec {
        *item += 1;
    }
    println!("{:?}", vec);
    
    // ❌ 错误：循环中修改集合大小
    let mut vec = vec![1, 2, 3, 4, 5];
    /*
    for (i, &item) in vec.iter().enumerate() {
        if item % 2 == 0 {
            vec.remove(i);  // 危险：修改正在迭代的集合
        }
    }
    */
    
    // ✅ 正确：使用 retain
    let mut vec = vec![1, 2, 3, 4, 5];
    vec.retain(|&x| x % 2 != 0);
    println!("{:?}", vec);
    
    // ✅ 正确：收集索引后删除
    let mut vec = vec![1, 2, 3, 4, 5];
    let to_remove: Vec<usize> = vec.iter()
        .enumerate()
        .filter(|(_, &item)| item % 2 == 0)
        .map(|(i, _)| i)
        .collect();
    
    for &i in to_remove.iter().rev() {
        vec.remove(i);
    }
    println!("{:?}", vec);
}
```

---

## 8. 最佳实践

1. **优先使用 for 循环遍历集合**
2. **使用迭代器方法简化代码**
3. **避免在循环中进行昂贵操作**
4. **使用借用而非移动所有权**
5. **合理使用循环标签控制嵌套循环**
6. **考虑使用迭代器适配器替代显式循环**
7. **在需要返回值时使用 loop**
8. **避免修改正在迭代的集合**

---

## 9. 性能优化

1. **使用迭代器**: 编译器可以更好地优化
2. **避免边界检查**: 使用迭代器而非索引
3. **减少克隆**: 使用引用
4. **缓存计算结果**: 避免重复计算
5. **考虑并行迭代**: 使用 rayon 等库
6. **使用 `collect` 预分配**: 指定容量避免多次分配

---

## 10. 小结

- loop 用于无限循环，可返回值
- while 用于条件循环
- for 用于迭代集合，最常用
- 迭代器提供强大的数据处理能力
- 合理使用 break/continue 控制流程
- 优先考虑可读性和正确性

---

## 11. 延伸阅读

**内部文档**:

- [条件语句指南](./01_条件语句指南.md)
- [迭代器参考](../tier_03_references/02_迭代器参考.md)
- [控制流参考](../tier_03_references/01_控制流参考.md)

**外部资源**:

- [Rust Book - Loops](https://doc.rust-lang.org/book/ch03-05-control-flow.html#repetition-with-loops)
- [Rust Reference - Loop Expressions](https://doc.rust-lang.org/reference/expressions/loop-expr.html)
- [Rust by Example - Loops](https://doc.rust-lang.org/rust-by-example/flow_control/loop.html)

---

## 12. 练习题

1. 实现一个自定义迭代器，生成质数序列
2. 使用循环标签实现多层循环的复杂控制
3. 编写一个数据流处理器，支持批处理和流式处理
4. 实现一个简单的任务调度器，支持优先级队列
5. 使用迭代器组合实现滑动窗口算法

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🎯 掌握Rust循环结构，高效处理数据迭代！** 🦀✨
