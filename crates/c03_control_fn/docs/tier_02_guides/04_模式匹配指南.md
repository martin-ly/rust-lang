# 2.4 模式匹配指南

> **文档类型**: Tier 2 - 指南层  
> **文档定位**: 系统化学习Rust模式匹配，掌握各种模式和解构技巧  
> **学习时间**: 1-2天  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [项目概览](../tier_01_foundations/01_项目概览.md)

## 📊 目录

- [2.4 模式匹配指南](#24-模式匹配指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. 模式基础](#1-模式基础)
    - [1.1 字面量模式](#11-字面量模式)
    - [1.2 变量模式](#12-变量模式)
    - [1.3 通配符模式](#13-通配符模式)
  - [2. 结构化模式](#2-结构化模式)
    - [2.1 元组模式](#21-元组模式)
    - [2.2 数组和切片模式](#22-数组和切片模式)
    - [2.3 结构体模式](#23-结构体模式)
    - [2.4 枚举模式](#24-枚举模式)
  - [3. 高级模式](#3-高级模式)
    - [3.1 范围模式](#31-范围模式)
    - [3.2 绑定模式](#32-绑定模式)
    - [3.3 守卫模式](#33-守卫模式)
    - [3.4 或模式](#34-或模式)
  - [4. 引用和解引用模式](#4-引用和解引用模式)
    - [4.1 引用模式](#41-引用模式)
    - [4.2 解引用模式](#42-解引用模式)
    - [4.3 可变性模式](#43-可变性模式)
  - [5. 忽略模式](#5-忽略模式)
    - [5.1 下划线模式](#51-下划线模式)
    - [5.2 嵌套忽略](#52-嵌套忽略)
    - [5.3 剩余模式](#53-剩余模式)
  - [6. 模式位置](#6-模式位置)
    - [6.1 let绑定](#61-let绑定)
    - [6.2 函数参数](#62-函数参数)
    - [6.3 for循环](#63-for循环)
    - [6.4 if let和while let](#64-if-let和while-let)
  - [7. 实战案例](#7-实战案例)
    - [案例1: 配置解析](#案例1-配置解析)
    - [案例2: JSON处理](#案例2-json处理)
    - [案例3: 状态机](#案例3-状态机)
    - [案例4: 命令解析器](#案例4-命令解析器)
    - [案例5: 树结构遍历](#案例5-树结构遍历)
  - [8. 常见陷阱](#8-常见陷阱)
  - [9. 最佳实践](#9-最佳实践)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [2.4 模式匹配指南](#24-模式匹配指南)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [🎯 学习目标](#-学习目标)
  - [1. 模式基础](#1-模式基础)
    - [1.1 字面量模式](#11-字面量模式)
    - [1.2 变量模式](#12-变量模式)
    - [1.3 通配符模式](#13-通配符模式)
  - [2. 结构化模式](#2-结构化模式)
    - [2.1 元组模式](#21-元组模式)
    - [2.2 数组和切片模式](#22-数组和切片模式)
    - [2.3 结构体模式](#23-结构体模式)
    - [2.4 枚举模式](#24-枚举模式)
  - [3. 高级模式](#3-高级模式)
    - [3.1 范围模式](#31-范围模式)
    - [3.2 绑定模式](#32-绑定模式)
    - [3.3 守卫模式](#33-守卫模式)
    - [3.4 或模式](#34-或模式)
  - [4. 引用和解引用模式](#4-引用和解引用模式)
    - [4.1 引用模式](#41-引用模式)
    - [4.2 解引用模式](#42-解引用模式)
    - [4.3 可变性模式](#43-可变性模式)
  - [5. 忽略模式](#5-忽略模式)
    - [5.1 下划线模式](#51-下划线模式)
    - [5.2 嵌套忽略](#52-嵌套忽略)
    - [5.3 剩余模式](#53-剩余模式)
  - [6. 模式位置](#6-模式位置)
    - [6.1 let绑定](#61-let绑定)
    - [6.2 函数参数](#62-函数参数)
    - [6.3 for循环](#63-for循环)
    - [6.4 if let和while let](#64-if-let和while-let)
  - [7. 实战案例](#7-实战案例)
    - [案例1: 配置解析](#案例1-配置解析)
    - [案例2: JSON处理](#案例2-json处理)
    - [案例3: 状态机](#案例3-状态机)
    - [案例4: 命令解析器](#案例4-命令解析器)
    - [案例5: 树结构遍历](#案例5-树结构遍历)
  - [8. 常见陷阱](#8-常见陷阱)
  - [9. 最佳实践](#9-最佳实践)
  - [10. 小结](#10-小结)
  - [11. 延伸阅读](#11-延伸阅读)
  - [12. 练习题](#12-练习题)

---

## 🎯 学习目标

完成本指南学习后，您将能够：

- ✅ 掌握各种模式匹配语法
- ✅ 理解解构和绑定机制
- ✅ 熟练使用守卫和范围模式
- ✅ 应用模式匹配解决实际问题
- ✅ 编写简洁高效的模式代码
- ✅ 避免常见陷阱和反模式

---

## 1. 模式基础

### 1.1 字面量模式

匹配具体的字面量值：

```rust
fn main() {
    let x = 1;
    
    // 整数字面量
    match x {
        0 => println!("零"),
        1 => println!("一"),
        2 => println!("二"),
        _ => println!("其他"),
    }
    
    // 字符字面量
    let ch = 'a';
    match ch {
        'a' => println!("字母a"),
        'b' => println!("字母b"),
        _ => println!("其他字母"),
    }
    
    // 布尔字面量
    let flag = true;
    match flag {
        true => println!("真"),
        false => println!("假"),
    }
    
    // 字符串切片字面量
    let text = "hello";
    match text {
        "hello" => println!("你好"),
        "world" => println!("世界"),
        _ => println!("其他"),
    }
}
```

### 1.2 变量模式

绑定匹配的值到变量：

```rust
fn main() {
    let x = 5;
    
    // 绑定到新变量
    match x {
        n => println!("值是: {}", n),
    }
    
    // 特定值或绑定
    match x {
        0 => println!("零"),
        n => println!("非零值: {}", n),
    }
    
    // Option 绑定
    let maybe_number = Some(42);
    match maybe_number {
        Some(n) => println!("有值: {}", n),
        None => println!("无值"),
    }
    
    // Result 绑定
    let result: Result<i32, &str> = Ok(10);
    match result {
        Ok(value) => println!("成功: {}", value),
        Err(error) => println!("错误: {}", error),
    }
}
```

### 1.3 通配符模式

使用 `_` 匹配但不绑定值：

```rust
fn main() {
    let x = 3;
    
    // 基本通配符
    match x {
        1 => println!("一"),
        2 => println!("二"),
        _ => println!("其他"),
    }
    
    // 忽略部分值
    let pair = (1, 2);
    match pair {
        (1, _) => println!("第一个是1"),
        (_, 2) => println!("第二个是2"),
        _ => println!("其他"),
    }
    
    // 忽略 Some 的值
    let maybe = Some(5);
    match maybe {
        Some(_) => println!("有值（但不关心具体值）"),
        None => println!("无值"),
    }
}
```

---

## 2. 结构化模式

### 2.1 元组模式

解构元组：

```rust
fn main() {
    // 完全解构
    let pair = (1, 2);
    let (x, y) = pair;
    println!("x = {}, y = {}", x, y);
    
    // match 中的元组模式
    match pair {
        (0, 0) => println!("原点"),
        (x, 0) => println!("x轴上: {}", x),
        (0, y) => println!("y轴上: {}", y),
        (x, y) => println!("其他点: ({}, {})", x, y),
    }
    
    // 嵌套元组
    let nested = ((1, 2), (3, 4));
    match nested {
        ((1, _), (_, 4)) => println!("匹配"),
        _ => println!("不匹配"),
    }
    
    // 三元组
    let triple = (1, 2, 3);
    let (a, b, c) = triple;
    println!("a={}, b={}, c={}", a, b, c);
    
    // 部分匹配
    match triple {
        (1, _, _) => println!("第一个是1"),
        (_, 2, _) => println!("第二个是2"),
        (_, _, 3) => println!("第三个是3"),
        _ => println!("其他"),
    }
}
```

### 2.2 数组和切片模式

解构数组和切片：

```rust
fn main() {
    // 数组模式
    let arr = [1, 2, 3];
    let [a, b, c] = arr;
    println!("a={}, b={}, c={}", a, b, c);
    
    // match 数组
    match arr {
        [1, 2, 3] => println!("精确匹配"),
        [1, _, _] => println!("第一个是1"),
        _ => println!("其他"),
    }
    
    // 切片模式（需要借用）
    let slice = &[1, 2, 3, 4, 5][..];
    match slice {
        [] => println!("空切片"),
        [x] => println!("单元素: {}", x),
        [x, y] => println!("两个元素: {}, {}", x, y),
        [first, middle @ .., last] => {
            println!("首: {}, 尾: {}, 中间: {:?}", first, last, middle);
        },
    }
    
    // 固定长度模式
    let arr5 = [1, 2, 3, 4, 5];
    match arr5 {
        [a, b, c, d, e] => {
            println!("5个元素: {}, {}, {}, {}, {}", a, b, c, d, e);
        },
    }
}
```

### 2.3 结构体模式

解构结构体：

```rust
struct Point {
    x: i32,
    y: i32,
}

struct Person {
    name: String,
    age: u32,
}

fn main() {
    // 完全解构
    let p = Point { x: 0, y: 7 };
    let Point { x, y } = p;
    println!("x={}, y={}", x, y);
    
    // 重命名绑定
    let Point { x: px, y: py } = p;
    println!("px={}, py={}", px, py);
    
    // match 结构体
    match p {
        Point { x: 0, y: 0 } => println!("原点"),
        Point { x: 0, y } => println!("y轴: y={}", y),
        Point { x, y: 0 } => println!("x轴: x={}", x),
        Point { x, y } => println!("其他: ({}, {})", x, y),
    }
    
    // 简写语法
    match p {
        Point { x, .. } => println!("x={}", x),
    }
    
    // 结构体与守卫
    let person = Person {
        name: String::from("Alice"),
        age: 25,
    };
    
    match person {
        Person { age: a, .. } if a >= 18 => {
            println!("成年人");
        },
        Person { age: a, .. } => {
            println!("未成年: {} 岁", a);
        },
    }
}
```

### 2.4 枚举模式

解构枚举：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

enum Option<T> {
    Some(T),
    None,
}

fn main() {
    // 无数据枚举
    let msg = Message::Quit;
    match msg {
        Message::Quit => println!("退出"),
        _ => println!("其他消息"),
    }
    
    // 结构体风格枚举
    let msg = Message::Move { x: 10, y: 20 };
    match msg {
        Message::Move { x, y } => {
            println!("移动到 ({}, {})", x, y);
        },
        _ => {},
    }
    
    // 元组风格枚举
    let msg = Message::Write(String::from("Hello"));
    match msg {
        Message::Write(text) => {
            println!("写入: {}", text);
        },
        _ => {},
    }
    
    // 多字段元组
    let msg = Message::ChangeColor(255, 0, 0);
    match msg {
        Message::ChangeColor(r, g, b) => {
            println!("颜色: RGB({}, {}, {})", r, g, b);
        },
        _ => {},
    }
    
    // 完整匹配
    let msg = Message::Move { x: 5, y: 10 };
    match msg {
        Message::Quit => println!("退出"),
        Message::Move { x, y } => println!("移动: ({}, {})", x, y),
        Message::Write(s) => println!("写入: {}", s),
        Message::ChangeColor(r, g, b) => println!("颜色: ({}, {}, {})", r, g, b),
    }
}
```

---

## 3. 高级模式

### 3.1 范围模式

使用范围匹配值：

```rust
fn main() {
    let x = 5;
    
    // 数字范围
    match x {
        1..=5 => println!("1到5"),
        6..=10 => println!("6到10"),
        _ => println!("其他"),
    }
    
    // 开放范围
    match x {
        ..=5 => println!("小于等于5"),
        _ => println!("大于5"),
    }
    
    match x {
        10.. => println!("大于等于10"),
        _ => println!("小于10"),
    }
    
    // 字符范围
    let ch = 'c';
    match ch {
        'a'..='z' => println!("小写字母"),
        'A'..='Z' => println!("大写字母"),
        '0'..='9' => println!("数字"),
        _ => println!("其他字符"),
    }
    
    // 组合范围
    let score = 85;
    match score {
        90..=100 => println!("A"),
        80..=89 => println!("B"),
        70..=79 => println!("C"),
        60..=69 => println!("D"),
        0..=59 => println!("F"),
        _ => println!("无效分数"),
    }
}
```

### 3.2 绑定模式

使用 @ 绑定和匹配：

```rust
fn main() {
    let x = 5;
    
    // 基本 @ 绑定
    match x {
        n @ 1..=5 => println!("{} 在1到5之间", n),
        n @ 6..=10 => println!("{} 在6到10之间", n),
        n => println!("{} 在其他范围", n),
    }
    
    // 结构体中的 @ 绑定
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 3, y: 5 };
    match point {
        p @ Point { x: 0..=5, y: 0..=5 } => {
            println!("点 ({}, {}) 在小方格内", p.x, p.y);
        },
        Point { x, y } => {
            println!("点 ({}, {}) 不在小方格内", x, y);
        },
    }
    
    // Option 中的 @ 绑定
    let value = Some(42);
    match value {
        Some(n @ 1..=50) => println!("{} 在范围内", n),
        Some(n) => println!("{} 超出范围", n),
        None => println!("无值"),
    }
    
    // 嵌套 @ 绑定
    enum Message {
        Hello { id: i32 },
    }
    
    let msg = Message::Hello { id: 5 };
    match msg {
        Message::Hello { id: id_var @ 3..=7 } => {
            println!("ID {} 在范围内", id_var);
        },
        Message::Hello { id } => {
            println!("ID {} 超出范围", id);
        },
    }
}
```

### 3.3 守卫模式

使用 if 添加额外条件：

```rust
fn main() {
    let num = 4;
    
    // 基本守卫
    match num {
        x if x < 5 => println!("{} 小于5", x),
        x if x == 5 => println!("等于5"),
        x => println!("{} 大于5", x),
    }
    
    // 组合守卫
    match num {
        x if x % 2 == 0 && x < 10 => {
            println!("{} 是小于10的偶数", x);
        },
        x if x % 2 == 0 => {
            println!("{} 是偶数", x);
        },
        x => println!("{} 是奇数", x),
    }
    
    // 元组守卫
    let pair = (2, 3);
    match pair {
        (x, y) if x + y == 5 => println!("和为5"),
        (x, y) if x == y => println!("相等"),
        (x, y) => println!("其他: ({}, {})", x, y),
    }
    
    // Option 守卫
    let maybe = Some(6);
    match maybe {
        Some(x) if x % 2 == 0 => println!("偶数: {}", x),
        Some(x) => println!("奇数: {}", x),
        None => println!("无值"),
    }
    
    // 外部变量守卫
    let flag = true;
    let value = 10;
    match value {
        x if flag && x > 5 => println!("条件满足: {}", x),
        _ => println!("条件不满足"),
    }
}
```

### 3.4 或模式

使用 | 匹配多个模式：

```rust
fn main() {
    let x = 2;
    
    // 基本或模式
    match x {
        1 | 2 | 3 => println!("小数字"),
        4 | 5 | 6 => println!("中等数字"),
        _ => println!("其他数字"),
    }
    
    // 或模式与范围
    match x {
        1..=3 | 7..=9 => println!("在范围内"),
        _ => println!("不在范围内"),
    }
    
    // 枚举或模式
    enum Direction {
        North,
        South,
        East,
        West,
    }
    
    let dir = Direction::North;
    match dir {
        Direction::North | Direction::South => println!("垂直"),
        Direction::East | Direction::West => println!("水平"),
    }
    
    // 结构化或模式
    let pair = (1, 2);
    match pair {
        (1, _) | (_, 1) => println!("包含1"),
        (2, _) | (_, 2) => println!("包含2"),
        _ => println!("其他"),
    }
    
    // 字符或模式
    let ch = 'a';
    match ch {
        'a' | 'e' | 'i' | 'o' | 'u' => println!("元音"),
        'A' | 'E' | 'I' | 'O' | 'U' => println!("大写元音"),
        _ => println!("辅音或其他"),
    }
}
```

---

## 4. 引用和解引用模式

### 4.1 引用模式

匹配引用：

```rust
fn main() {
    let value = 5;
    let reference = &value;
    
    // 匹配引用
    match reference {
        &val => println!("值: {}", val),
    }
    
    // 不解引用
    match reference {
        r => println!("引用: {:p}", r as *const _),
    }
    
    // Vec 引用
    let vec = vec![1, 2, 3];
    match &vec[..] {
        [first, .., last] => {
            println!("首: {}, 尾: {}", first, last);
        },
        _ => {},
    }
    
    // Option 引用
    let maybe = Some(42);
    match &maybe {
        Some(n) => println!("引用值: {}", n),
        None => println!("无值"),
    }
}
```

### 4.2 解引用模式

自动解引用：

```rust
fn main() {
    let x = 5;
    let r = &x;
    
    // 显式解引用
    match r {
        &val => println!("解引用: {}", val),
    }
    
    // 隐式解引用（在某些情况下）
    if let Some(&value) = Some(&10) {
        println!("值: {}", value);
    }
    
    // Box 解引用
    let boxed = Box::new(5);
    match boxed {
        b => println!("Box中的值: {}", b),
    }
}
```

### 4.3 可变性模式

匹配可变引用：

```rust
fn main() {
    let mut x = 5;
    
    // 可变引用模式
    let r = &mut x;
    match r {
        value => {
            *value += 1;
            println!("修改后: {}", value);
        },
    }
    
    // let mut 绑定
    let mut v = vec![1, 2, 3];
    for item in &mut v {
        *item *= 2;
    }
    println!("{:?}", v);
}
```

---

## 5. 忽略模式

### 5.1 下划线模式

忽略值：

```rust
fn main() {
    // 忽略完整值
    let _ = 5;
    
    // 忽略元组部分
    let (x, _) = (1, 2);
    println!("x: {}", x);
    
    // 忽略函数返回值
    fn get_value() -> i32 {
        42
    }
    let _ = get_value();
    
    // 忽略 Result
    let result: Result<i32, &str> = Ok(10);
    let _ = result;  // 不处理 Result
    
    // 部分忽略结构体
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }
    
    let p = Point { x: 1, y: 2, z: 3 };
    let Point { x, .. } = p;
    println!("只关心x: {}", x);
}
```

### 5.2 嵌套忽略

在复杂结构中忽略部分：

```rust
fn main() {
    // 嵌套元组忽略
    let nested = ((1, 2), (3, 4));
    let ((a, _), (_, b)) = nested;
    println!("a: {}, b: {}", a, b);
    
    // 结构体嵌套忽略
    struct Outer {
        inner: Inner,
        value: i32,
    }
    
    struct Inner {
        x: i32,
        y: i32,
    }
    
    let outer = Outer {
        inner: Inner { x: 1, y: 2 },
        value: 10,
    };
    
    let Outer { inner: Inner { x, .. }, .. } = outer;
    println!("只取 inner.x: {}", x);
}
```

### 5.3 剩余模式

使用 `..` 忽略剩余部分：

```rust
fn main() {
    // 元组剩余
    let tuple = (1, 2, 3, 4, 5);
    let (first, .., last) = tuple;
    println!("首: {}, 尾: {}", first, last);
    
    // 数组剩余
    let arr = [1, 2, 3, 4, 5];
    match arr {
        [first, .., last] => {
            println!("首: {}, 尾: {}", first, last);
        },
    }
    
    // 结构体剩余
    struct Point3D {
        x: i32,
        y: i32,
        z: i32,
    }
    
    let p = Point3D { x: 1, y: 2, z: 3 };
    let Point3D { x, .. } = p;
    println!("x: {}", x);
    
    // 切片模式
    let slice = &[1, 2, 3, 4, 5][..];
    match slice {
        [first, second, ..] => {
            println!("前两个: {}, {}", first, second);
        },
        _ => {},
    }
}
```

---

## 6. 模式位置

### 6.1 let绑定

在 let 语句中使用模式：

```rust
fn main() {
    // 基本绑定
    let x = 5;
    
    // 元组绑定
    let (x, y, z) = (1, 2, 3);
    println!("{}, {}, {}", x, y, z);
    
    // 结构体绑定
    struct Point {
        x: i32,
        y: i32,
    }
    
    let p = Point { x: 10, y: 20 };
    let Point { x, y } = p;
    println!("x={}, y={}", x, y);
    
    // 数组绑定
    let [a, b, c] = [1, 2, 3];
    println!("{}, {}, {}", a, b, c);
    
    // 嵌套绑定
    let ((a, b), (c, d)) = ((1, 2), (3, 4));
    println!("{}, {}, {}, {}", a, b, c, d);
}
```

### 6.2 函数参数

在函数参数中使用模式：

```rust
// 元组参数
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("坐标: ({}, {})", x, y);
}

// 结构体参数
struct Point {
    x: i32,
    y: i32,
}

fn print_point(Point { x, y }: Point) {
    println!("点: ({}, {})", x, y);
}

// 引用参数
fn print_ref(&value: &i32) {
    println!("值: {}", value);
}

fn main() {
    let tuple = (3, 5);
    print_coordinates(&tuple);
    
    let point = Point { x: 10, y: 20 };
    print_point(point);
    
    let num = 42;
    print_ref(&num);
}
```

### 6.3 for循环

在 for 循环中使用模式：

```rust
fn main() {
    // 元组迭代
    let v = vec![(1, 2), (3, 4), (5, 6)];
    for (x, y) in v {
        println!("({}, {})", x, y);
    }
    
    // enumerate 模式
    let v = vec!['a', 'b', 'c'];
    for (index, value) in v.iter().enumerate() {
        println!("{}: {}", index, value);
    }
    
    // 结构体迭代
    struct Point {
        x: i32,
        y: i32,
    }
    
    let points = vec![
        Point { x: 0, y: 0 },
        Point { x: 1, y: 1 },
    ];
    
    for Point { x, y } in points {
        println!("点: ({}, {})", x, y);
    }
}
```

### 6.4 if let和while let

在条件语句中使用模式：

```rust
fn main() {
    // if let
    let maybe = Some(5);
    if let Some(x) = maybe {
        println!("有值: {}", x);
    }
    
    // if let 带 else
    if let Some(x) = maybe {
        println!("有值: {}", x);
    } else {
        println!("无值");
    }
    
    // while let
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("弹出: {}", top);
    }
    
    // let else (Rust 1.65+)
    fn process(value: Option<i32>) {
        let Some(x) = value else {
            println!("无值，提前返回");
            return;
        };
        println!("处理值: {}", x);
    }
    
    process(Some(10));
    process(None);
}
```

---

## 7. 实战案例

### 案例1: 配置解析

```rust
#[derive(Debug)]
enum ConfigValue {
    String(String),
    Int(i64),
    Bool(bool),
    Array(Vec<ConfigValue>),
    Object(std::collections::HashMap<String, ConfigValue>),
}

fn parse_config(value: &ConfigValue) {
    match value {
        ConfigValue::String(s) => {
            println!("字符串配置: {}", s);
        },
        ConfigValue::Int(n) => {
            println!("整数配置: {}", n);
        },
        ConfigValue::Bool(b) => {
            println!("布尔配置: {}", b);
        },
        ConfigValue::Array(arr) => {
            println!("数组配置:");
            for (i, item) in arr.iter().enumerate() {
                print!("  [{}] ", i);
                parse_config(item);
            }
        },
        ConfigValue::Object(map) => {
            println!("对象配置:");
            for (key, val) in map {
                print!("  {}: ", key);
                parse_config(val);
            }
        },
    }
}

fn main() {
    let config = ConfigValue::Object({
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), ConfigValue::String("MyApp".to_string()));
        map.insert("port".to_string(), ConfigValue::Int(8080));
        map.insert("debug".to_string(), ConfigValue::Bool(true));
        map
    });
    
    parse_config(&config);
}
```

### 案例2: JSON处理

```rust
#[derive(Debug)]
enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(std::collections::HashMap<String, JsonValue>),
}

fn extract_string(value: &JsonValue) -> Option<&str> {
    match value {
        JsonValue::String(s) => Some(s.as_str()),
        _ => None,
    }
}

fn extract_number(value: &JsonValue) -> Option<f64> {
    match value {
        JsonValue::Number(n) => Some(*n),
        _ => None,
    }
}

fn pretty_print(value: &JsonValue, indent: usize) {
    let spaces = " ".repeat(indent);
    match value {
        JsonValue::Null => print!("null"),
        JsonValue::Bool(b) => print!("{}", b),
        JsonValue::Number(n) => print!("{}", n),
        JsonValue::String(s) => print!("\"{}\"", s),
        JsonValue::Array(arr) => {
            println!("[");
            for (i, item) in arr.iter().enumerate() {
                print!("{}", spaces);
                pretty_print(item, indent + 2);
                if i < arr.len() - 1 {
                    println!(",");
                } else {
                    println!();
                }
            }
            print!("{}]", " ".repeat(indent.saturating_sub(2)));
        },
        JsonValue::Object(map) => {
            println!("{{");
            let items: Vec<_> = map.iter().collect();
            for (i, (key, val)) in items.iter().enumerate() {
                print!("{}\"{}\": ", spaces, key);
                pretty_print(val, indent + 2);
                if i < items.len() - 1 {
                    println!(",");
                } else {
                    println!();
                }
            }
            print!("{}}}", " ".repeat(indent.saturating_sub(2)));
        },
    }
}

fn main() {
    let json = JsonValue::Object({
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), JsonValue::String("Alice".to_string()));
        map.insert("age".to_string(), JsonValue::Number(25.0));
        map.insert("active".to_string(), JsonValue::Bool(true));
        map
    });
    
    pretty_print(&json, 2);
    println!();
}
```

### 案例3: 状态机

```rust
#[derive(Debug, PartialEq)]
enum State {
    Idle,
    Running(u32),  // 带有剩余时间
    Paused(u32),   // 带有暂停时的剩余时间
    Completed,
    Failed(String),
}

#[derive(Debug)]
enum Event {
    Start(u32),  // 启动，指定时长
    Pause,
    Resume,
    Tick,
    Complete,
    Fail(String),
}

struct StateMachine {
    state: State,
}

impl StateMachine {
    fn new() -> Self {
        StateMachine { state: State::Idle }
    }
    
    fn handle(&mut self, event: Event) -> Result<(), String> {
        let new_state = match (&self.state, event) {
            // Idle 状态
            (State::Idle, Event::Start(duration)) => State::Running(duration),
            
            // Running 状态
            (State::Running(time), Event::Pause) if *time > 0 => State::Paused(*time),
            (State::Running(time), Event::Tick) if *time > 1 => State::Running(time - 1),
            (State::Running(1), Event::Tick) => State::Completed,
            (State::Running(_), Event::Complete) => State::Completed,
            (State::Running(_), Event::Fail(reason)) => State::Failed(reason),
            
            // Paused 状态
            (State::Paused(time), Event::Resume) => State::Running(*time),
            (State::Paused(_), Event::Fail(reason)) => State::Failed(reason),
            
            // Completed/Failed 状态（终止状态）
            (State::Completed, Event::Start(duration)) => State::Running(duration),
            (State::Failed(_), Event::Start(duration)) => State::Running(duration),
            
            // 无效转换
            (state, event) => {
                return Err(format!("无效转换: {:?} + {:?}", state, event));
            },
        };
        
        println!("{:?} -> {:?}", self.state, new_state);
        self.state = new_state;
        Ok(())
    }
    
    fn current_state(&self) -> &State {
        &self.state
    }
}

fn main() {
    let mut machine = StateMachine::new();
    
    machine.handle(Event::Start(5)).unwrap();
    machine.handle(Event::Tick).unwrap();
    machine.handle(Event::Pause).unwrap();
    machine.handle(Event::Resume).unwrap();
    machine.handle(Event::Tick).unwrap();
    machine.handle(Event::Complete).unwrap();
}
```

### 案例4: 命令解析器

```rust
#[derive(Debug)]
enum Command {
    Get { key: String },
    Set { key: String, value: String },
    Delete { key: String },
    List,
    Help,
    Exit,
}

fn parse_command(input: &str) -> Result<Command, String> {
    let parts: Vec<&str> = input.trim().split_whitespace().collect();
    
    match parts.as_slice() {
        ["get", key] => Ok(Command::Get {
            key: key.to_string(),
        }),
        ["set", key, value] => Ok(Command::Set {
            key: key.to_string(),
            value: value.to_string(),
        }),
        ["delete", key] | ["del", key] => Ok(Command::Delete {
            key: key.to_string(),
        }),
        ["list"] | ["ls"] => Ok(Command::List),
        ["help"] | ["h"] | ["?"] => Ok(Command::Help),
        ["exit"] | ["quit"] | ["q"] => Ok(Command::Exit),
        [] => Err("空命令".to_string()),
        _ => Err(format!("未知命令: {}", input)),
    }
}

fn execute_command(cmd: Command) {
    match cmd {
        Command::Get { key } => {
            println!("获取键: {}", key);
        },
        Command::Set { key, value } => {
            println!("设置 {} = {}", key, value);
        },
        Command::Delete { key } => {
            println!("删除键: {}", key);
        },
        Command::List => {
            println!("列出所有键");
        },
        Command::Help => {
            println!("命令帮助:");
            println!("  get <key>         - 获取值");
            println!("  set <key> <value> - 设置值");
            println!("  delete <key>      - 删除键");
            println!("  list              - 列出所有");
            println!("  help              - 显示帮助");
            println!("  exit              - 退出");
        },
        Command::Exit => {
            println!("退出程序");
        },
    }
}

fn main() {
    let commands = vec![
        "get mykey",
        "set mykey myvalue",
        "list",
        "delete mykey",
        "help",
    ];
    
    for input in commands {
        println!("\n> {}", input);
        match parse_command(input) {
            Ok(cmd) => execute_command(cmd),
            Err(e) => println!("错误: {}", e),
        }
    }
}
```

### 案例5: 树结构遍历

```rust
#[derive(Debug)]
enum Tree<T> {
    Empty,
    Node {
        value: T,
        left: Box<Tree<T>>,
        right: Box<Tree<T>>,
    },
}

impl<T> Tree<T> {
    fn leaf(value: T) -> Self {
        Tree::Node {
            value,
            left: Box::new(Tree::Empty),
            right: Box::new(Tree::Empty),
        }
    }
    
    fn node(value: T, left: Tree<T>, right: Tree<T>) -> Self {
        Tree::Node {
            value,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
}

impl<T: std::fmt::Display> Tree<T> {
    fn inorder(&self) {
        match self {
            Tree::Empty => {},
            Tree::Node { value, left, right } => {
                left.inorder();
                print!("{} ", value);
                right.inorder();
            },
        }
    }
    
    fn preorder(&self) {
        match self {
            Tree::Empty => {},
            Tree::Node { value, left, right } => {
                print!("{} ", value);
                left.preorder();
                right.preorder();
            },
        }
    }
    
    fn postorder(&self) {
        match self {
            Tree::Empty => {},
            Tree::Node { value, left, right } => {
                left.postorder();
                right.postorder();
                print!("{} ", value);
            },
        }
    }
    
    fn height(&self) -> usize {
        match self {
            Tree::Empty => 0,
            Tree::Node { left, right, .. } => {
                1 + left.height().max(right.height())
            },
        }
    }
}

fn main() {
    let tree = Tree::node(
        1,
        Tree::node(
            2,
            Tree::leaf(4),
            Tree::leaf(5),
        ),
        Tree::node(
            3,
            Tree::leaf(6),
            Tree::leaf(7),
        ),
    );
    
    print!("中序: ");
    tree.inorder();
    println!();
    
    print!("前序: ");
    tree.preorder();
    println!();
    
    print!("后序: ");
    tree.postorder();
    println!();
    
    println!("高度: {}", tree.height());
}
```

---

## 8. 常见陷阱

```rust
fn main() {
    // ❌ 错误：不可达模式
    /*
    let x = 5;
    match x {
        _ => println!("任何值"),
        5 => println!("五"),  // 错误：永远不会执行
    }
    */
    
    // ✅ 正确：特定模式在前
    let x = 5;
    match x {
        5 => println!("五"),
        _ => println!("其他"),
    }
    
    // ❌ 错误：守卫影响穷尽性检查
    /*
    enum Status {
        Active,
        Inactive,
    }
    let status = Status::Active;
    match status {
        Status::Active if true => println!("活跃"),
        // 缺少 Inactive 和 Active(false) 的情况
    }
    */
    
    // ✅ 正确：完整匹配
    enum Status {
        Active,
        Inactive,
    }
    let status = Status::Active;
    match status {
        Status::Active => println!("活跃"),
        Status::Inactive => println!("不活跃"),
    }
}
```

---

## 9. 最佳实践

1. **优先使用穷尽性匹配**
2. **避免过度使用通配符**
3. **合理使用守卫条件**
4. **使用 @ 绑定避免重复**
5. **结构化匹配优于多层 if**
6. **使用类型驱动设计**
7. **为复杂模式添加注释**
8. **考虑模式的可读性**

---

## 10. 小结

- 模式匹配是Rust的核心特性
- 支持多种模式类型和组合
- 提供类型安全的解构
- 编译器保证穷尽性
- 是函数式编程的基础

---

## 11. 延伸阅读

**内部文档**:

- [条件语句指南](./01_条件语句指南.md)
- [枚举与模式](../../c02_type_system/docs/README.md)
- [高级模式](../tier_04_advanced/01_高级模式.md)

**外部资源**:

- [Rust Book - Patterns](https://doc.rust-lang.org/book/ch18-00-patterns.html)
- [Rust Reference - Patterns](https://doc.rust-lang.org/reference/patterns.html)
- [Rust by Example - Match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html)

---

## 12. 练习题

1. 实现一个表达式解析器，使用模式匹配
2. 编写一个状态机，使用枚举和模式匹配
3. 实现树遍历算法，利用递归模式匹配
4. 创建一个命令行解析器，支持复杂命令
5. 设计一个类型安全的配置系统

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**🎯 掌握Rust模式匹配，编写简洁优雅的代码！** 🦀✨
