# 2.4 æ¨¡å¼åŒ¹é…æŒ‡å—

> **æ–‡æ¡£ç±»å‹**: Tier 2 - æŒ‡å—å±‚  
> **æ–‡æ¡£å®šä½**: ç³»ç»ŸåŒ–å­¦ä¹ Rustæ¨¡å¼åŒ¹é…ï¼ŒæŒæ¡å„ç§æ¨¡å¼å’Œè§£æ„æŠ€å·§  
> **å­¦ä¹ æ—¶é—´**: 1-2å¤©  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [2.4 æ¨¡å¼åŒ¹é…æŒ‡å—](#24-æ¨¡å¼åŒ¹é…æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. æ¨¡å¼åŸºç¡€](#1-æ¨¡å¼åŸºç¡€)
    - [1.1 å­—é¢é‡æ¨¡å¼](#11-å­—é¢é‡æ¨¡å¼)
    - [1.2 å˜é‡æ¨¡å¼](#12-å˜é‡æ¨¡å¼)
    - [1.3 é€šé…ç¬¦æ¨¡å¼](#13-é€šé…ç¬¦æ¨¡å¼)
  - [2. ç»“æ„åŒ–æ¨¡å¼](#2-ç»“æ„åŒ–æ¨¡å¼)
    - [2.1 å…ƒç»„æ¨¡å¼](#21-å…ƒç»„æ¨¡å¼)
    - [2.2 æ•°ç»„å’Œåˆ‡ç‰‡æ¨¡å¼](#22-æ•°ç»„å’Œåˆ‡ç‰‡æ¨¡å¼)
    - [2.3 ç»“æ„ä½“æ¨¡å¼](#23-ç»“æ„ä½“æ¨¡å¼)
    - [2.4 æšä¸¾æ¨¡å¼](#24-æšä¸¾æ¨¡å¼)
  - [3. é«˜çº§æ¨¡å¼](#3-é«˜çº§æ¨¡å¼)
    - [3.1 èŒƒå›´æ¨¡å¼](#31-èŒƒå›´æ¨¡å¼)
    - [3.2 ç»‘å®šæ¨¡å¼](#32-ç»‘å®šæ¨¡å¼)
    - [3.3 å®ˆå«æ¨¡å¼](#33-å®ˆå«æ¨¡å¼)
    - [3.4 æˆ–æ¨¡å¼](#34-æˆ–æ¨¡å¼)
  - [4. å¼•ç”¨å’Œè§£å¼•ç”¨æ¨¡å¼](#4-å¼•ç”¨å’Œè§£å¼•ç”¨æ¨¡å¼)
    - [4.1 å¼•ç”¨æ¨¡å¼](#41-å¼•ç”¨æ¨¡å¼)
    - [4.2 è§£å¼•ç”¨æ¨¡å¼](#42-è§£å¼•ç”¨æ¨¡å¼)
    - [4.3 å¯å˜æ€§æ¨¡å¼](#43-å¯å˜æ€§æ¨¡å¼)
  - [5. å¿½ç•¥æ¨¡å¼](#5-å¿½ç•¥æ¨¡å¼)
    - [5.1 ä¸‹åˆ’çº¿æ¨¡å¼](#51-ä¸‹åˆ’çº¿æ¨¡å¼)
    - [5.2 åµŒå¥—å¿½ç•¥](#52-åµŒå¥—å¿½ç•¥)
    - [5.3 å‰©ä½™æ¨¡å¼](#53-å‰©ä½™æ¨¡å¼)
  - [6. æ¨¡å¼ä½ç½®](#6-æ¨¡å¼ä½ç½®)
    - [6.1 letç»‘å®š](#61-letç»‘å®š)
    - [6.2 å‡½æ•°å‚æ•°](#62-å‡½æ•°å‚æ•°)
    - [6.3 forå¾ªç¯](#63-forå¾ªç¯)
    - [6.4 if letå’Œwhile let](#64-if-letå’Œwhile-let)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: é…ç½®è§£æ](#æ¡ˆä¾‹1-é…ç½®è§£æ)
    - [æ¡ˆä¾‹2: JSONå¤„ç†](#æ¡ˆä¾‹2-jsonå¤„ç†)
    - [æ¡ˆä¾‹3: çŠ¶æ€æœº](#æ¡ˆä¾‹3-çŠ¶æ€æœº)
    - [æ¡ˆä¾‹4: å‘½ä»¤è§£æå™¨](#æ¡ˆä¾‹4-å‘½ä»¤è§£æå™¨)
    - [æ¡ˆä¾‹5: æ ‘ç»“æ„éå†](#æ¡ˆä¾‹5-æ ‘ç»“æ„éå†)
  - [8. å¸¸è§é™·é˜±](#8-å¸¸è§é™·é˜±)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [10. å°ç»“](#10-å°ç»“)
  - [11. å»¶ä¼¸é˜…è¯»](#11-å»¶ä¼¸é˜…è¯»)
  - [12. ç»ƒä¹ é¢˜](#12-ç»ƒä¹ é¢˜)

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- âœ… æŒæ¡å„ç§æ¨¡å¼åŒ¹é…è¯­æ³•
- âœ… ç†è§£è§£æ„å’Œç»‘å®šæœºåˆ¶
- âœ… ç†Ÿç»ƒä½¿ç”¨å®ˆå«å’ŒèŒƒå›´æ¨¡å¼
- âœ… åº”ç”¨æ¨¡å¼åŒ¹é…è§£å†³å®é™…é—®é¢˜
- âœ… ç¼–å†™ç®€æ´é«˜æ•ˆçš„æ¨¡å¼ä»£ç 
- âœ… é¿å…å¸¸è§é™·é˜±å’Œåæ¨¡å¼

---

## 1. æ¨¡å¼åŸºç¡€

### 1.1 å­—é¢é‡æ¨¡å¼

åŒ¹é…å…·ä½“çš„å­—é¢é‡å€¼ï¼š

```rust
fn main() {
    let x = 1;
    
    // æ•´æ•°å­—é¢é‡
    match x {
        0 => println!("é›¶"),
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        _ => println!("å…¶ä»–"),
    }
    
    // å­—ç¬¦å­—é¢é‡
    let ch = 'a';
    match ch {
        'a' => println!("å­—æ¯a"),
        'b' => println!("å­—æ¯b"),
        _ => println!("å…¶ä»–å­—æ¯"),
    }
    
    // å¸ƒå°”å­—é¢é‡
    let flag = true;
    match flag {
        true => println!("çœŸ"),
        false => println!("å‡"),
    }
    
    // å­—ç¬¦ä¸²åˆ‡ç‰‡å­—é¢é‡
    let text = "hello";
    match text {
        "hello" => println!("ä½ å¥½"),
        "world" => println!("ä¸–ç•Œ"),
        _ => println!("å…¶ä»–"),
    }
}
```

### 1.2 å˜é‡æ¨¡å¼

ç»‘å®šåŒ¹é…çš„å€¼åˆ°å˜é‡ï¼š

```rust
fn main() {
    let x = 5;
    
    // ç»‘å®šåˆ°æ–°å˜é‡
    match x {
        n => println!("å€¼æ˜¯: {}", n),
    }
    
    // ç‰¹å®šå€¼æˆ–ç»‘å®š
    match x {
        0 => println!("é›¶"),
        n => println!("éé›¶å€¼: {}", n),
    }
    
    // Option ç»‘å®š
    let maybe_number = Some(42);
    match maybe_number {
        Some(n) => println!("æœ‰å€¼: {}", n),
        None => println!("æ— å€¼"),
    }
    
    // Result ç»‘å®š
    let result: Result<i32, &str> = Ok(10);
    match result {
        Ok(value) => println!("æˆåŠŸ: {}", value),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
}
```

### 1.3 é€šé…ç¬¦æ¨¡å¼

ä½¿ç”¨ `_` åŒ¹é…ä½†ä¸ç»‘å®šå€¼ï¼š

```rust
fn main() {
    let x = 3;
    
    // åŸºæœ¬é€šé…ç¬¦
    match x {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        _ => println!("å…¶ä»–"),
    }
    
    // å¿½ç•¥éƒ¨åˆ†å€¼
    let pair = (1, 2);
    match pair {
        (1, _) => println!("ç¬¬ä¸€ä¸ªæ˜¯1"),
        (_, 2) => println!("ç¬¬äºŒä¸ªæ˜¯2"),
        _ => println!("å…¶ä»–"),
    }
    
    // å¿½ç•¥ Some çš„å€¼
    let maybe = Some(5);
    match maybe {
        Some(_) => println!("æœ‰å€¼ï¼ˆä½†ä¸å…³å¿ƒå…·ä½“å€¼ï¼‰"),
        None => println!("æ— å€¼"),
    }
}
```

---

## 2. ç»“æ„åŒ–æ¨¡å¼

### 2.1 å…ƒç»„æ¨¡å¼

è§£æ„å…ƒç»„ï¼š

```rust
fn main() {
    // å®Œå…¨è§£æ„
    let pair = (1, 2);
    let (x, y) = pair;
    println!("x = {}, y = {}", x, y);
    
    // match ä¸­çš„å…ƒç»„æ¨¡å¼
    match pair {
        (0, 0) => println!("åŸç‚¹"),
        (x, 0) => println!("xè½´ä¸Š: {}", x),
        (0, y) => println!("yè½´ä¸Š: {}", y),
        (x, y) => println!("å…¶ä»–ç‚¹: ({}, {})", x, y),
    }
    
    // åµŒå¥—å…ƒç»„
    let nested = ((1, 2), (3, 4));
    match nested {
        ((1, _), (_, 4)) => println!("åŒ¹é…"),
        _ => println!("ä¸åŒ¹é…"),
    }
    
    // ä¸‰å…ƒç»„
    let triple = (1, 2, 3);
    let (a, b, c) = triple;
    println!("a={}, b={}, c={}", a, b, c);
    
    // éƒ¨åˆ†åŒ¹é…
    match triple {
        (1, _, _) => println!("ç¬¬ä¸€ä¸ªæ˜¯1"),
        (_, 2, _) => println!("ç¬¬äºŒä¸ªæ˜¯2"),
        (_, _, 3) => println!("ç¬¬ä¸‰ä¸ªæ˜¯3"),
        _ => println!("å…¶ä»–"),
    }
}
```

### 2.2 æ•°ç»„å’Œåˆ‡ç‰‡æ¨¡å¼

è§£æ„æ•°ç»„å’Œåˆ‡ç‰‡ï¼š

```rust
fn main() {
    // æ•°ç»„æ¨¡å¼
    let arr = [1, 2, 3];
    let [a, b, c] = arr;
    println!("a={}, b={}, c={}", a, b, c);
    
    // match æ•°ç»„
    match arr {
        [1, 2, 3] => println!("ç²¾ç¡®åŒ¹é…"),
        [1, _, _] => println!("ç¬¬ä¸€ä¸ªæ˜¯1"),
        _ => println!("å…¶ä»–"),
    }
    
    // åˆ‡ç‰‡æ¨¡å¼ï¼ˆéœ€è¦å€Ÿç”¨ï¼‰
    let slice = &[1, 2, 3, 4, 5][..];
    match slice {
        [] => println!("ç©ºåˆ‡ç‰‡"),
        [x] => println!("å•å…ƒç´ : {}", x),
        [x, y] => println!("ä¸¤ä¸ªå…ƒç´ : {}, {}", x, y),
        [first, middle @ .., last] => {
            println!("é¦–: {}, å°¾: {}, ä¸­é—´: {:?}", first, last, middle);
        },
    }
    
    // å›ºå®šé•¿åº¦æ¨¡å¼
    let arr5 = [1, 2, 3, 4, 5];
    match arr5 {
        [a, b, c, d, e] => {
            println!("5ä¸ªå…ƒç´ : {}, {}, {}, {}, {}", a, b, c, d, e);
        },
    }
}
```

### 2.3 ç»“æ„ä½“æ¨¡å¼

è§£æ„ç»“æ„ä½“ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

struct Person {
    name: String,
    age: u32,
}

fn main() {
    // å®Œå…¨è§£æ„
    let p = Point { x: 0, y: 7 };
    let Point { x, y } = p;
    println!("x={}, y={}", x, y);
    
    // é‡å‘½åç»‘å®š
    let Point { x: px, y: py } = p;
    println!("px={}, py={}", px, py);
    
    // match ç»“æ„ä½“
    match p {
        Point { x: 0, y: 0 } => println!("åŸç‚¹"),
        Point { x: 0, y } => println!("yè½´: y={}", y),
        Point { x, y: 0 } => println!("xè½´: x={}", x),
        Point { x, y } => println!("å…¶ä»–: ({}, {})", x, y),
    }
    
    // ç®€å†™è¯­æ³•
    match p {
        Point { x, .. } => println!("x={}", x),
    }
    
    // ç»“æ„ä½“ä¸å®ˆå«
    let person = Person {
        name: String::from("Alice"),
        age: 25,
    };
    
    match person {
        Person { age: a, .. } if a >= 18 => {
            println!("æˆå¹´äºº");
        },
        Person { age: a, .. } => {
            println!("æœªæˆå¹´: {} å²", a);
        },
    }
}
```

### 2.4 æšä¸¾æ¨¡å¼

è§£æ„æšä¸¾ï¼š

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

enum Option<T> {
    Some(T),
    None,
}

fn main() {
    // æ— æ•°æ®æšä¸¾
    let msg = Message::Quit;
    match msg {
        Message::Quit => println!("é€€å‡º"),
        _ => println!("å…¶ä»–æ¶ˆæ¯"),
    }
    
    // ç»“æ„ä½“é£æ ¼æšä¸¾
    let msg = Message::Move { x: 10, y: 20 };
    match msg {
        Message::Move { x, y } => {
            println!("ç§»åŠ¨åˆ° ({}, {})", x, y);
        },
        _ => {},
    }
    
    // å…ƒç»„é£æ ¼æšä¸¾
    let msg = Message::Write(String::from("Hello"));
    match msg {
        Message::Write(text) => {
            println!("å†™å…¥: {}", text);
        },
        _ => {},
    }
    
    // å¤šå­—æ®µå…ƒç»„
    let msg = Message::ChangeColor(255, 0, 0);
    match msg {
        Message::ChangeColor(r, g, b) => {
            println!("é¢œè‰²: RGB({}, {}, {})", r, g, b);
        },
        _ => {},
    }
    
    // å®Œæ•´åŒ¹é…
    let msg = Message::Move { x: 5, y: 10 };
    match msg {
        Message::Quit => println!("é€€å‡º"),
        Message::Move { x, y } => println!("ç§»åŠ¨: ({}, {})", x, y),
        Message::Write(s) => println!("å†™å…¥: {}", s),
        Message::ChangeColor(r, g, b) => println!("é¢œè‰²: ({}, {}, {})", r, g, b),
    }
}
```

---

## 3. é«˜çº§æ¨¡å¼

### 3.1 èŒƒå›´æ¨¡å¼

ä½¿ç”¨èŒƒå›´åŒ¹é…å€¼ï¼š

```rust
fn main() {
    let x = 5;
    
    // æ•°å­—èŒƒå›´
    match x {
        1..=5 => println!("1åˆ°5"),
        6..=10 => println!("6åˆ°10"),
        _ => println!("å…¶ä»–"),
    }
    
    // å¼€æ”¾èŒƒå›´
    match x {
        ..=5 => println!("å°äºç­‰äº5"),
        _ => println!("å¤§äº5"),
    }
    
    match x {
        10.. => println!("å¤§äºç­‰äº10"),
        _ => println!("å°äº10"),
    }
    
    // å­—ç¬¦èŒƒå›´
    let ch = 'c';
    match ch {
        'a'..='z' => println!("å°å†™å­—æ¯"),
        'A'..='Z' => println!("å¤§å†™å­—æ¯"),
        '0'..='9' => println!("æ•°å­—"),
        _ => println!("å…¶ä»–å­—ç¬¦"),
    }
    
    // ç»„åˆèŒƒå›´
    let score = 85;
    match score {
        90..=100 => println!("A"),
        80..=89 => println!("B"),
        70..=79 => println!("C"),
        60..=69 => println!("D"),
        0..=59 => println!("F"),
        _ => println!("æ— æ•ˆåˆ†æ•°"),
    }
}
```

### 3.2 ç»‘å®šæ¨¡å¼

ä½¿ç”¨ @ ç»‘å®šå’ŒåŒ¹é…ï¼š

```rust
fn main() {
    let x = 5;
    
    // åŸºæœ¬ @ ç»‘å®š
    match x {
        n @ 1..=5 => println!("{} åœ¨1åˆ°5ä¹‹é—´", n),
        n @ 6..=10 => println!("{} åœ¨6åˆ°10ä¹‹é—´", n),
        n => println!("{} åœ¨å…¶ä»–èŒƒå›´", n),
    }
    
    // ç»“æ„ä½“ä¸­çš„ @ ç»‘å®š
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 3, y: 5 };
    match point {
        p @ Point { x: 0..=5, y: 0..=5 } => {
            println!("ç‚¹ ({}, {}) åœ¨å°æ–¹æ ¼å†…", p.x, p.y);
        },
        Point { x, y } => {
            println!("ç‚¹ ({}, {}) ä¸åœ¨å°æ–¹æ ¼å†…", x, y);
        },
    }
    
    // Option ä¸­çš„ @ ç»‘å®š
    let value = Some(42);
    match value {
        Some(n @ 1..=50) => println!("{} åœ¨èŒƒå›´å†…", n),
        Some(n) => println!("{} è¶…å‡ºèŒƒå›´", n),
        None => println!("æ— å€¼"),
    }
    
    // åµŒå¥— @ ç»‘å®š
    enum Message {
        Hello { id: i32 },
    }
    
    let msg = Message::Hello { id: 5 };
    match msg {
        Message::Hello { id: id_var @ 3..=7 } => {
            println!("ID {} åœ¨èŒƒå›´å†…", id_var);
        },
        Message::Hello { id } => {
            println!("ID {} è¶…å‡ºèŒƒå›´", id);
        },
    }
}
```

### 3.3 å®ˆå«æ¨¡å¼

ä½¿ç”¨ if æ·»åŠ é¢å¤–æ¡ä»¶ï¼š

```rust
fn main() {
    let num = 4;
    
    // åŸºæœ¬å®ˆå«
    match num {
        x if x < 5 => println!("{} å°äº5", x),
        x if x == 5 => println!("ç­‰äº5"),
        x => println!("{} å¤§äº5", x),
    }
    
    // ç»„åˆå®ˆå«
    match num {
        x if x % 2 == 0 && x < 10 => {
            println!("{} æ˜¯å°äº10çš„å¶æ•°", x);
        },
        x if x % 2 == 0 => {
            println!("{} æ˜¯å¶æ•°", x);
        },
        x => println!("{} æ˜¯å¥‡æ•°", x),
    }
    
    // å…ƒç»„å®ˆå«
    let pair = (2, 3);
    match pair {
        (x, y) if x + y == 5 => println!("å’Œä¸º5"),
        (x, y) if x == y => println!("ç›¸ç­‰"),
        (x, y) => println!("å…¶ä»–: ({}, {})", x, y),
    }
    
    // Option å®ˆå«
    let maybe = Some(6);
    match maybe {
        Some(x) if x % 2 == 0 => println!("å¶æ•°: {}", x),
        Some(x) => println!("å¥‡æ•°: {}", x),
        None => println!("æ— å€¼"),
    }
    
    // å¤–éƒ¨å˜é‡å®ˆå«
    let flag = true;
    let value = 10;
    match value {
        x if flag && x > 5 => println!("æ¡ä»¶æ»¡è¶³: {}", x),
        _ => println!("æ¡ä»¶ä¸æ»¡è¶³"),
    }
}
```

### 3.4 æˆ–æ¨¡å¼

ä½¿ç”¨ | åŒ¹é…å¤šä¸ªæ¨¡å¼ï¼š

```rust
fn main() {
    let x = 2;
    
    // åŸºæœ¬æˆ–æ¨¡å¼
    match x {
        1 | 2 | 3 => println!("å°æ•°å­—"),
        4 | 5 | 6 => println!("ä¸­ç­‰æ•°å­—"),
        _ => println!("å…¶ä»–æ•°å­—"),
    }
    
    // æˆ–æ¨¡å¼ä¸èŒƒå›´
    match x {
        1..=3 | 7..=9 => println!("åœ¨èŒƒå›´å†…"),
        _ => println!("ä¸åœ¨èŒƒå›´å†…"),
    }
    
    // æšä¸¾æˆ–æ¨¡å¼
    enum Direction {
        North,
        South,
        East,
        West,
    }
    
    let dir = Direction::North;
    match dir {
        Direction::North | Direction::South => println!("å‚ç›´"),
        Direction::East | Direction::West => println!("æ°´å¹³"),
    }
    
    // ç»“æ„åŒ–æˆ–æ¨¡å¼
    let pair = (1, 2);
    match pair {
        (1, _) | (_, 1) => println!("åŒ…å«1"),
        (2, _) | (_, 2) => println!("åŒ…å«2"),
        _ => println!("å…¶ä»–"),
    }
    
    // å­—ç¬¦æˆ–æ¨¡å¼
    let ch = 'a';
    match ch {
        'a' | 'e' | 'i' | 'o' | 'u' => println!("å…ƒéŸ³"),
        'A' | 'E' | 'I' | 'O' | 'U' => println!("å¤§å†™å…ƒéŸ³"),
        _ => println!("è¾…éŸ³æˆ–å…¶ä»–"),
    }
}
```

---

## 4. å¼•ç”¨å’Œè§£å¼•ç”¨æ¨¡å¼

### 4.1 å¼•ç”¨æ¨¡å¼

åŒ¹é…å¼•ç”¨ï¼š

```rust
fn main() {
    let value = 5;
    let reference = &value;
    
    // åŒ¹é…å¼•ç”¨
    match reference {
        &val => println!("å€¼: {}", val),
    }
    
    // ä¸è§£å¼•ç”¨
    match reference {
        r => println!("å¼•ç”¨: {:p}", r as *const _),
    }
    
    // Vec å¼•ç”¨
    let vec = vec![1, 2, 3];
    match &vec[..] {
        [first, .., last] => {
            println!("é¦–: {}, å°¾: {}", first, last);
        },
        _ => {},
    }
    
    // Option å¼•ç”¨
    let maybe = Some(42);
    match &maybe {
        Some(n) => println!("å¼•ç”¨å€¼: {}", n),
        None => println!("æ— å€¼"),
    }
}
```

### 4.2 è§£å¼•ç”¨æ¨¡å¼

è‡ªåŠ¨è§£å¼•ç”¨ï¼š

```rust
fn main() {
    let x = 5;
    let r = &x;
    
    // æ˜¾å¼è§£å¼•ç”¨
    match r {
        &val => println!("è§£å¼•ç”¨: {}", val),
    }
    
    // éšå¼è§£å¼•ç”¨ï¼ˆåœ¨æŸäº›æƒ…å†µä¸‹ï¼‰
    if let Some(&value) = Some(&10) {
        println!("å€¼: {}", value);
    }
    
    // Box è§£å¼•ç”¨
    let boxed = Box::new(5);
    match boxed {
        b => println!("Boxä¸­çš„å€¼: {}", b),
    }
}
```

### 4.3 å¯å˜æ€§æ¨¡å¼

åŒ¹é…å¯å˜å¼•ç”¨ï¼š

```rust
fn main() {
    let mut x = 5;
    
    // å¯å˜å¼•ç”¨æ¨¡å¼
    let r = &mut x;
    match r {
        value => {
            *value += 1;
            println!("ä¿®æ”¹å: {}", value);
        },
    }
    
    // let mut ç»‘å®š
    let mut v = vec![1, 2, 3];
    for item in &mut v {
        *item *= 2;
    }
    println!("{:?}", v);
}
```

---

## 5. å¿½ç•¥æ¨¡å¼

### 5.1 ä¸‹åˆ’çº¿æ¨¡å¼

å¿½ç•¥å€¼ï¼š

```rust
fn main() {
    // å¿½ç•¥å®Œæ•´å€¼
    let _ = 5;
    
    // å¿½ç•¥å…ƒç»„éƒ¨åˆ†
    let (x, _) = (1, 2);
    println!("x: {}", x);
    
    // å¿½ç•¥å‡½æ•°è¿”å›å€¼
    fn get_value() -> i32 {
        42
    }
    let _ = get_value();
    
    // å¿½ç•¥ Result
    let result: Result<i32, &str> = Ok(10);
    let _ = result;  // ä¸å¤„ç† Result
    
    // éƒ¨åˆ†å¿½ç•¥ç»“æ„ä½“
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }
    
    let p = Point { x: 1, y: 2, z: 3 };
    let Point { x, .. } = p;
    println!("åªå…³å¿ƒx: {}", x);
}
```

### 5.2 åµŒå¥—å¿½ç•¥

åœ¨å¤æ‚ç»“æ„ä¸­å¿½ç•¥éƒ¨åˆ†ï¼š

```rust
fn main() {
    // åµŒå¥—å…ƒç»„å¿½ç•¥
    let nested = ((1, 2), (3, 4));
    let ((a, _), (_, b)) = nested;
    println!("a: {}, b: {}", a, b);
    
    // ç»“æ„ä½“åµŒå¥—å¿½ç•¥
    struct Outer {
        inner: Inner,
        value: i32,
    }
    
    struct Inner {
        x: i32,
        y: i32,
    }
    
    let outer = Outer {
        inner: Inner { x: 1, y: 2 },
        value: 10,
    };
    
    let Outer { inner: Inner { x, .. }, .. } = outer;
    println!("åªå– inner.x: {}", x);
}
```

### 5.3 å‰©ä½™æ¨¡å¼

ä½¿ç”¨ `..` å¿½ç•¥å‰©ä½™éƒ¨åˆ†ï¼š

```rust
fn main() {
    // å…ƒç»„å‰©ä½™
    let tuple = (1, 2, 3, 4, 5);
    let (first, .., last) = tuple;
    println!("é¦–: {}, å°¾: {}", first, last);
    
    // æ•°ç»„å‰©ä½™
    let arr = [1, 2, 3, 4, 5];
    match arr {
        [first, .., last] => {
            println!("é¦–: {}, å°¾: {}", first, last);
        },
    }
    
    // ç»“æ„ä½“å‰©ä½™
    struct Point3D {
        x: i32,
        y: i32,
        z: i32,
    }
    
    let p = Point3D { x: 1, y: 2, z: 3 };
    let Point3D { x, .. } = p;
    println!("x: {}", x);
    
    // åˆ‡ç‰‡æ¨¡å¼
    let slice = &[1, 2, 3, 4, 5][..];
    match slice {
        [first, second, ..] => {
            println!("å‰ä¸¤ä¸ª: {}, {}", first, second);
        },
        _ => {},
    }
}
```

---

## 6. æ¨¡å¼ä½ç½®

### 6.1 letç»‘å®š

åœ¨ let è¯­å¥ä¸­ä½¿ç”¨æ¨¡å¼ï¼š

```rust
fn main() {
    // åŸºæœ¬ç»‘å®š
    let x = 5;
    
    // å…ƒç»„ç»‘å®š
    let (x, y, z) = (1, 2, 3);
    println!("{}, {}, {}", x, y, z);
    
    // ç»“æ„ä½“ç»‘å®š
    struct Point {
        x: i32,
        y: i32,
    }
    
    let p = Point { x: 10, y: 20 };
    let Point { x, y } = p;
    println!("x={}, y={}", x, y);
    
    // æ•°ç»„ç»‘å®š
    let [a, b, c] = [1, 2, 3];
    println!("{}, {}, {}", a, b, c);
    
    // åµŒå¥—ç»‘å®š
    let ((a, b), (c, d)) = ((1, 2), (3, 4));
    println!("{}, {}, {}, {}", a, b, c, d);
}
```

### 6.2 å‡½æ•°å‚æ•°

åœ¨å‡½æ•°å‚æ•°ä¸­ä½¿ç”¨æ¨¡å¼ï¼š

```rust
// å…ƒç»„å‚æ•°
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("åæ ‡: ({}, {})", x, y);
}

// ç»“æ„ä½“å‚æ•°
struct Point {
    x: i32,
    y: i32,
}

fn print_point(Point { x, y }: Point) {
    println!("ç‚¹: ({}, {})", x, y);
}

// å¼•ç”¨å‚æ•°
fn print_ref(&value: &i32) {
    println!("å€¼: {}", value);
}

fn main() {
    let tuple = (3, 5);
    print_coordinates(&tuple);
    
    let point = Point { x: 10, y: 20 };
    print_point(point);
    
    let num = 42;
    print_ref(&num);
}
```

### 6.3 forå¾ªç¯

åœ¨ for å¾ªç¯ä¸­ä½¿ç”¨æ¨¡å¼ï¼š

```rust
fn main() {
    // å…ƒç»„è¿­ä»£
    let v = vec![(1, 2), (3, 4), (5, 6)];
    for (x, y) in v {
        println!("({}, {})", x, y);
    }
    
    // enumerate æ¨¡å¼
    let v = vec!['a', 'b', 'c'];
    for (index, value) in v.iter().enumerate() {
        println!("{}: {}", index, value);
    }
    
    // ç»“æ„ä½“è¿­ä»£
    struct Point {
        x: i32,
        y: i32,
    }
    
    let points = vec![
        Point { x: 0, y: 0 },
        Point { x: 1, y: 1 },
    ];
    
    for Point { x, y } in points {
        println!("ç‚¹: ({}, {})", x, y);
    }
}
```

### 6.4 if letå’Œwhile let

åœ¨æ¡ä»¶è¯­å¥ä¸­ä½¿ç”¨æ¨¡å¼ï¼š

```rust
fn main() {
    // if let
    let maybe = Some(5);
    if let Some(x) = maybe {
        println!("æœ‰å€¼: {}", x);
    }
    
    // if let å¸¦ else
    if let Some(x) = maybe {
        println!("æœ‰å€¼: {}", x);
    } else {
        println!("æ— å€¼");
    }
    
    // while let
    let mut stack = vec![1, 2, 3];
    while let Some(top) = stack.pop() {
        println!("å¼¹å‡º: {}", top);
    }
    
    // let else (Rust 1.65+)
    fn process(value: Option<i32>) {
        let Some(x) = value else {
            println!("æ— å€¼ï¼Œæå‰è¿”å›");
            return;
        };
        println!("å¤„ç†å€¼: {}", x);
    }
    
    process(Some(10));
    process(None);
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: é…ç½®è§£æ

```rust
#[derive(Debug)]
enum ConfigValue {
    String(String),
    Int(i64),
    Bool(bool),
    Array(Vec<ConfigValue>),
    Object(std::collections::HashMap<String, ConfigValue>),
}

fn parse_config(value: &ConfigValue) {
    match value {
        ConfigValue::String(s) => {
            println!("å­—ç¬¦ä¸²é…ç½®: {}", s);
        },
        ConfigValue::Int(n) => {
            println!("æ•´æ•°é…ç½®: {}", n);
        },
        ConfigValue::Bool(b) => {
            println!("å¸ƒå°”é…ç½®: {}", b);
        },
        ConfigValue::Array(arr) => {
            println!("æ•°ç»„é…ç½®:");
            for (i, item) in arr.iter().enumerate() {
                print!("  [{}] ", i);
                parse_config(item);
            }
        },
        ConfigValue::Object(map) => {
            println!("å¯¹è±¡é…ç½®:");
            for (key, val) in map {
                print!("  {}: ", key);
                parse_config(val);
            }
        },
    }
}

fn main() {
    let config = ConfigValue::Object({
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), ConfigValue::String("MyApp".to_string()));
        map.insert("port".to_string(), ConfigValue::Int(8080));
        map.insert("debug".to_string(), ConfigValue::Bool(true));
        map
    });
    
    parse_config(&config);
}
```

### æ¡ˆä¾‹2: JSONå¤„ç†

```rust
#[derive(Debug)]
enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(std::collections::HashMap<String, JsonValue>),
}

fn extract_string(value: &JsonValue) -> Option<&str> {
    match value {
        JsonValue::String(s) => Some(s.as_str()),
        _ => None,
    }
}

fn extract_number(value: &JsonValue) -> Option<f64> {
    match value {
        JsonValue::Number(n) => Some(*n),
        _ => None,
    }
}

fn pretty_print(value: &JsonValue, indent: usize) {
    let spaces = " ".repeat(indent);
    match value {
        JsonValue::Null => print!("null"),
        JsonValue::Bool(b) => print!("{}", b),
        JsonValue::Number(n) => print!("{}", n),
        JsonValue::String(s) => print!("\"{}\"", s),
        JsonValue::Array(arr) => {
            println!("[");
            for (i, item) in arr.iter().enumerate() {
                print!("{}", spaces);
                pretty_print(item, indent + 2);
                if i < arr.len() - 1 {
                    println!(",");
                } else {
                    println!();
                }
            }
            print!("{}]", " ".repeat(indent.saturating_sub(2)));
        },
        JsonValue::Object(map) => {
            println!("{{");
            let items: Vec<_> = map.iter().collect();
            for (i, (key, val)) in items.iter().enumerate() {
                print!("{}\"{}\": ", spaces, key);
                pretty_print(val, indent + 2);
                if i < items.len() - 1 {
                    println!(",");
                } else {
                    println!();
                }
            }
            print!("{}}}", " ".repeat(indent.saturating_sub(2)));
        },
    }
}

fn main() {
    let json = JsonValue::Object({
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), JsonValue::String("Alice".to_string()));
        map.insert("age".to_string(), JsonValue::Number(25.0));
        map.insert("active".to_string(), JsonValue::Bool(true));
        map
    });
    
    pretty_print(&json, 2);
    println!();
}
```

### æ¡ˆä¾‹3: çŠ¶æ€æœº

```rust
#[derive(Debug, PartialEq)]
enum State {
    Idle,
    Running(u32),  // å¸¦æœ‰å‰©ä½™æ—¶é—´
    Paused(u32),   // å¸¦æœ‰æš‚åœæ—¶çš„å‰©ä½™æ—¶é—´
    Completed,
    Failed(String),
}

#[derive(Debug)]
enum Event {
    Start(u32),  // å¯åŠ¨ï¼ŒæŒ‡å®šæ—¶é•¿
    Pause,
    Resume,
    Tick,
    Complete,
    Fail(String),
}

struct StateMachine {
    state: State,
}

impl StateMachine {
    fn new() -> Self {
        StateMachine { state: State::Idle }
    }
    
    fn handle(&mut self, event: Event) -> Result<(), String> {
        let new_state = match (&self.state, event) {
            // Idle çŠ¶æ€
            (State::Idle, Event::Start(duration)) => State::Running(duration),
            
            // Running çŠ¶æ€
            (State::Running(time), Event::Pause) if *time > 0 => State::Paused(*time),
            (State::Running(time), Event::Tick) if *time > 1 => State::Running(time - 1),
            (State::Running(1), Event::Tick) => State::Completed,
            (State::Running(_), Event::Complete) => State::Completed,
            (State::Running(_), Event::Fail(reason)) => State::Failed(reason),
            
            // Paused çŠ¶æ€
            (State::Paused(time), Event::Resume) => State::Running(*time),
            (State::Paused(_), Event::Fail(reason)) => State::Failed(reason),
            
            // Completed/Failed çŠ¶æ€ï¼ˆç»ˆæ­¢çŠ¶æ€ï¼‰
            (State::Completed, Event::Start(duration)) => State::Running(duration),
            (State::Failed(_), Event::Start(duration)) => State::Running(duration),
            
            // æ— æ•ˆè½¬æ¢
            (state, event) => {
                return Err(format!("æ— æ•ˆè½¬æ¢: {:?} + {:?}", state, event));
            },
        };
        
        println!("{:?} -> {:?}", self.state, new_state);
        self.state = new_state;
        Ok(())
    }
    
    fn current_state(&self) -> &State {
        &self.state
    }
}

fn main() {
    let mut machine = StateMachine::new();
    
    machine.handle(Event::Start(5)).unwrap();
    machine.handle(Event::Tick).unwrap();
    machine.handle(Event::Pause).unwrap();
    machine.handle(Event::Resume).unwrap();
    machine.handle(Event::Tick).unwrap();
    machine.handle(Event::Complete).unwrap();
}
```

### æ¡ˆä¾‹4: å‘½ä»¤è§£æå™¨

```rust
#[derive(Debug)]
enum Command {
    Get { key: String },
    Set { key: String, value: String },
    Delete { key: String },
    List,
    Help,
    Exit,
}

fn parse_command(input: &str) -> Result<Command, String> {
    let parts: Vec<&str> = input.trim().split_whitespace().collect();
    
    match parts.as_slice() {
        ["get", key] => Ok(Command::Get {
            key: key.to_string(),
        }),
        ["set", key, value] => Ok(Command::Set {
            key: key.to_string(),
            value: value.to_string(),
        }),
        ["delete", key] | ["del", key] => Ok(Command::Delete {
            key: key.to_string(),
        }),
        ["list"] | ["ls"] => Ok(Command::List),
        ["help"] | ["h"] | ["?"] => Ok(Command::Help),
        ["exit"] | ["quit"] | ["q"] => Ok(Command::Exit),
        [] => Err("ç©ºå‘½ä»¤".to_string()),
        _ => Err(format!("æœªçŸ¥å‘½ä»¤: {}", input)),
    }
}

fn execute_command(cmd: Command) {
    match cmd {
        Command::Get { key } => {
            println!("è·å–é”®: {}", key);
        },
        Command::Set { key, value } => {
            println!("è®¾ç½® {} = {}", key, value);
        },
        Command::Delete { key } => {
            println!("åˆ é™¤é”®: {}", key);
        },
        Command::List => {
            println!("åˆ—å‡ºæ‰€æœ‰é”®");
        },
        Command::Help => {
            println!("å‘½ä»¤å¸®åŠ©:");
            println!("  get <key>         - è·å–å€¼");
            println!("  set <key> <value> - è®¾ç½®å€¼");
            println!("  delete <key>      - åˆ é™¤é”®");
            println!("  list              - åˆ—å‡ºæ‰€æœ‰");
            println!("  help              - æ˜¾ç¤ºå¸®åŠ©");
            println!("  exit              - é€€å‡º");
        },
        Command::Exit => {
            println!("é€€å‡ºç¨‹åº");
        },
    }
}

fn main() {
    let commands = vec![
        "get mykey",
        "set mykey myvalue",
        "list",
        "delete mykey",
        "help",
    ];
    
    for input in commands {
        println!("\n> {}", input);
        match parse_command(input) {
            Ok(cmd) => execute_command(cmd),
            Err(e) => println!("é”™è¯¯: {}", e),
        }
    }
}
```

### æ¡ˆä¾‹5: æ ‘ç»“æ„éå†

```rust
#[derive(Debug)]
enum Tree<T> {
    Empty,
    Node {
        value: T,
        left: Box<Tree<T>>,
        right: Box<Tree<T>>,
    },
}

impl<T> Tree<T> {
    fn leaf(value: T) -> Self {
        Tree::Node {
            value,
            left: Box::new(Tree::Empty),
            right: Box::new(Tree::Empty),
        }
    }
    
    fn node(value: T, left: Tree<T>, right: Tree<T>) -> Self {
        Tree::Node {
            value,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
}

impl<T: std::fmt::Display> Tree<T> {
    fn inorder(&self) {
        match self {
            Tree::Empty => {},
            Tree::Node { value, left, right } => {
                left.inorder();
                print!("{} ", value);
                right.inorder();
            },
        }
    }
    
    fn preorder(&self) {
        match self {
            Tree::Empty => {},
            Tree::Node { value, left, right } => {
                print!("{} ", value);
                left.preorder();
                right.preorder();
            },
        }
    }
    
    fn postorder(&self) {
        match self {
            Tree::Empty => {},
            Tree::Node { value, left, right } => {
                left.postorder();
                right.postorder();
                print!("{} ", value);
            },
        }
    }
    
    fn height(&self) -> usize {
        match self {
            Tree::Empty => 0,
            Tree::Node { left, right, .. } => {
                1 + left.height().max(right.height())
            },
        }
    }
}

fn main() {
    let tree = Tree::node(
        1,
        Tree::node(
            2,
            Tree::leaf(4),
            Tree::leaf(5),
        ),
        Tree::node(
            3,
            Tree::leaf(6),
            Tree::leaf(7),
        ),
    );
    
    print!("ä¸­åº: ");
    tree.inorder();
    println!();
    
    print!("å‰åº: ");
    tree.preorder();
    println!();
    
    print!("ååº: ");
    tree.postorder();
    println!();
    
    println!("é«˜åº¦: {}", tree.height());
}
```

---

## 8. å¸¸è§é™·é˜±

```rust
fn main() {
    // âŒ é”™è¯¯ï¼šä¸å¯è¾¾æ¨¡å¼
    /*
    let x = 5;
    match x {
        _ => println!("ä»»ä½•å€¼"),
        5 => println!("äº”"),  // é”™è¯¯ï¼šæ°¸è¿œä¸ä¼šæ‰§è¡Œ
    }
    */
    
    // âœ… æ­£ç¡®ï¼šç‰¹å®šæ¨¡å¼åœ¨å‰
    let x = 5;
    match x {
        5 => println!("äº”"),
        _ => println!("å…¶ä»–"),
    }
    
    // âŒ é”™è¯¯ï¼šå®ˆå«å½±å“ç©·å°½æ€§æ£€æŸ¥
    /*
    enum Status {
        Active,
        Inactive,
    }
    let status = Status::Active;
    match status {
        Status::Active if true => println!("æ´»è·ƒ"),
        // ç¼ºå°‘ Inactive å’Œ Active(false) çš„æƒ…å†µ
    }
    */
    
    // âœ… æ­£ç¡®ï¼šå®Œæ•´åŒ¹é…
    enum Status {
        Active,
        Inactive,
    }
    let status = Status::Active;
    match status {
        Status::Active => println!("æ´»è·ƒ"),
        Status::Inactive => println!("ä¸æ´»è·ƒ"),
    }
}
```

---

## 9. æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨ç©·å°½æ€§åŒ¹é…**
2. **é¿å…è¿‡åº¦ä½¿ç”¨é€šé…ç¬¦**
3. **åˆç†ä½¿ç”¨å®ˆå«æ¡ä»¶**
4. **ä½¿ç”¨ @ ç»‘å®šé¿å…é‡å¤**
5. **ç»“æ„åŒ–åŒ¹é…ä¼˜äºå¤šå±‚ if**
6. **ä½¿ç”¨ç±»å‹é©±åŠ¨è®¾è®¡**
7. **ä¸ºå¤æ‚æ¨¡å¼æ·»åŠ æ³¨é‡Š**
8. **è€ƒè™‘æ¨¡å¼çš„å¯è¯»æ€§**

---

## 10. å°ç»“

- æ¨¡å¼åŒ¹é…æ˜¯Rustçš„æ ¸å¿ƒç‰¹æ€§
- æ”¯æŒå¤šç§æ¨¡å¼ç±»å‹å’Œç»„åˆ
- æä¾›ç±»å‹å®‰å…¨çš„è§£æ„
- ç¼–è¯‘å™¨ä¿è¯ç©·å°½æ€§
- æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„åŸºç¡€

---

## 11. å»¶ä¼¸é˜…è¯»

**å†…éƒ¨æ–‡æ¡£**:

- [æ¡ä»¶è¯­å¥æŒ‡å—](./01_æ¡ä»¶è¯­å¥æŒ‡å—.md)
- [æšä¸¾ä¸æ¨¡å¼](../../c02_type_system/docs/README.md)
- [é«˜çº§æ¨¡å¼](../tier_04_advanced/01_é«˜çº§æ¨¡å¼.md)

**å¤–éƒ¨èµ„æº**:

- [Rust Book - Patterns](https://doc.rust-lang.org/book/ch18-00-patterns.html)
- [Rust Reference - Patterns](https://doc.rust-lang.org/reference/patterns.html)
- [Rust by Example - Match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html)

---

## 12. ç»ƒä¹ é¢˜

1. å®ç°ä¸€ä¸ªè¡¨è¾¾å¼è§£æå™¨ï¼Œä½¿ç”¨æ¨¡å¼åŒ¹é…
2. ç¼–å†™ä¸€ä¸ªçŠ¶æ€æœºï¼Œä½¿ç”¨æšä¸¾å’Œæ¨¡å¼åŒ¹é…
3. å®ç°æ ‘éå†ç®—æ³•ï¼Œåˆ©ç”¨é€’å½’æ¨¡å¼åŒ¹é…
4. åˆ›å»ºä¸€ä¸ªå‘½ä»¤è¡Œè§£æå™¨ï¼Œæ”¯æŒå¤æ‚å‘½ä»¤
5. è®¾è®¡ä¸€ä¸ªç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ¯ æŒæ¡Rustæ¨¡å¼åŒ¹é…ï¼Œç¼–å†™ç®€æ´ä¼˜é›…çš„ä»£ç ï¼** ğŸ¦€âœ¨
