# 3.1 控制流参考

> **文档类型**: Tier 3 - 参考层
> **文档定位**: Rust控制流完整参考手册
> **适用对象**: 需要查阅详细语法和规则的开发者
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [条件语句指南](../tier_02_guides/01_条件语句指南.md)

**最后更新**: 2025-12-11
**适用版本**: Rust 1.92.0+
**文档版本**: v2025.1.0

---

## 📋 目录

- [3.1 控制流参考](#31-控制流参考)
  - [📋 目录](#-目录)
  - [1. if表达式参考](#1-if表达式参考)
    - [1.1 完整语法](#11-完整语法)
    - [1.2 类型规则](#12-类型规则)
    - [1.3 作用域规则](#13-作用域规则)
    - [1.4 求值顺序](#14-求值顺序)
  - [2. match表达式参考](#2-match表达式参考)
    - [2.1 完整语法](#21-完整语法)
    - [2.2 穷尽性检查](#22-穷尽性检查)
    - [2.3 守卫规则](#23-守卫规则)
    - [2.4 绑定模式](#24-绑定模式)
  - [3. loop表达式参考](#3-loop表达式参考)
    - [3.1 完整语法](#31-完整语法)
    - [3.2 循环标签](#32-循环标签)
    - [3.3 返回值](#33-返回值)
    - [3.4 生命周期](#34-生命周期)
  - [4. while表达式参考](#4-while表达式参考)
    - [4.1 完整语法](#41-完整语法)
    - [4.2 while let](#42-while-let)
    - [4.3 条件求值](#43-条件求值)
  - [5. for表达式参考](#5-for表达式参考)
    - [5.1 完整语法](#51-完整语法)
    - [5.2 IntoIterator](#52-intoiterator)
    - [5.3 模式绑定](#53-模式绑定)
  - [6. break和continue参考](#6-break和continue参考)
    - [6.1 break语法](#61-break语法)
    - [6.2 continue语法](#62-continue语法)
    - [6.3 标签使用](#63-标签使用)
  - [7. 特殊控制流](#7-特殊控制流)
    - [7.1 return语句](#71-return语句)
    - [7.2 发散函数](#72-发散函数)
    - [7.3 never类型](#73-never类型)
  - [8. 性能考虑](#8-性能考虑)
  - [9. 编译器优化](#9-编译器优化)
  - [10. 参考表](#10-参考表)
    - [控制流表达式对比](#控制流表达式对比)
    - [控制流关键字](#控制流关键字)
    - [类型规则总结](#类型规则总结)

---

## 1. if表达式参考

### 1.1 完整语法

```bnf
if_expression :=
    "if" expression_without_block block_expression
    ("else" ("if" expression_without_block block_expression)*
     ("else" block_expression)?)?

expression_without_block :=
    // 任何不以 { 开始的表达式

block_expression :=
    "{" statements? expression? "}"
```

**示例**:

```rust
fn main() {
    // 最简形式
    if true {
        println!("true");
    }

    // 完整形式
    let result = if condition() {
        expression1()
    } else if condition2() {
        expression2()
    } else {
        expression3()
    };

    println!("{}", result);
}

fn condition() -> bool { true }
fn condition2() -> bool { false }
fn expression1() -> i32 { 1 }
fn expression2() -> i32 { 2 }
fn expression3() -> i32 { 3 }
```

### 1.2 类型规则

**规则1**: 条件必须是 `bool` 类型

```rust
fn main() {
    // ✅ 正确
    if true { }
    if false { }
    if 1 == 2 { }

    // ❌ 错误：非bool类型
    // if 1 { }
    // if "hello" { }
    // if Some(5) { }
}
```

**规则2**: 所有分支类型必须相同

```rust
fn main() {
    // ✅ 正确：所有分支返回 i32
    let x: i32 = if true { 1 } else { 2 };

    // ✅ 正确：所有分支返回 ()
    if true {
        println!("a");
    } else {
        println!("b");
    }

    // ❌ 错误：类型不匹配
    // let x = if true { 1 } else { "two" };

    // ❌ 错误：缺少else分支
    // let x = if true { 1 };
}
```

**规则3**: 表达式形式必须有else分支

```rust
fn main() {
    // ✅ 正确：语句形式，不需要else
    if true {
        println!("hello");
    }

    // ✅ 正确：表达式形式，有else
    let x = if true { 1 } else { 2 };

    // ❌ 错误：表达式形式，缺少else
    // let x = if true { 1 };
}
```

### 1.3 作用域规则

```rust
fn main() {
    let x = 10;

    if true {
        let y = 20;  // y只在if块内有效
        println!("{} {}", x, y);
    }

    // println!("{}", y);  // 错误：y不在作用域内

    // if块不创建新的生命周期区域
    let r;
    if true {
        let value = 42;
        // r = &value;  // 错误：value在if块结束时drop
    }

    // 但可以在if中移动值
    let s = String::from("hello");
    if true {
        let _moved = s;  // s被移动
    }
    // println!("{}", s);  // 错误：s已被移动
}
```

### 1.4 求值顺序

```rust
fn main() {
    // 条件表达式首先求值
    if {
        println!("求值条件");
        true
    } {
        println!("执行then分支");
    } else {
        println!("执行else分支");
    }

    // 短路求值
    let mut count = 0;
    let result = if false && { count += 1; true } {
        "then"
    } else {
        "else"
    };
    println!("count: {}", count);  // 0，因为短路了

    // 只求值执行的分支
    let result = if true {
        println!("then分支");
        1
    } else {
        println!("else分支");  // 不执行
        2
    };
}
```

---

## 2. match表达式参考

### 2.1 完整语法

```bnf
match_expression :=
    "match" expression_without_block "{"
    match_arms?
    "}"

match_arms :=
    (match_arm "=>" (block_expression | expression ","))+

match_arm :=
    pattern ("|" pattern)* ("if" expression)?
```

**示例**:

```rust
fn main() {
    let value = 5;

    match value {
        1 => println!("one"),
        2 | 3 => println!("two or three"),
        4..=6 => println!("four to six"),
        n if n > 10 => println!("greater than ten"),
        _ => println!("something else"),
    }
}
```

### 2.2 穷尽性检查

**规则**: match必须穷尽所有可能的值

```rust
fn main() {
    // ✅ 正确：使用_通配符
    match 5 {
        1 => {},
        2 => {},
        _ => {},
    }

    // ✅ 正确：覆盖所有范围
    match 5u8 {
        0..=127 => {},
        128..=255 => {},
    }

    // ✅ 正确：枚举完全匹配
    enum Color {
        Red,
        Green,
        Blue,
    }

    let color = Color::Red;
    match color {
        Color::Red => {},
        Color::Green => {},
        Color::Blue => {},
    }

    // ❌ 错误：未穷尽
    // match 5 {
    //     1 => {},
    //     2 => {},
    // }
}
```

**不可达模式警告**:

```rust
fn main() {
    match 5 {
        1 => {},
        _ => {},
        // 警告：不可达模式
        // 2 => {},
    }

    match Some(5) {
        Some(_) => {},
        None => {},
        // 警告：不可达模式
        // Some(10) => {},
    }
}
```

### 2.3 守卫规则

```rust
fn main() {
    let x = 4;
    let y = false;

    // 守卫可以访问外部变量
    match x {
        n if y => println!("y is true"),
        n if n < 5 => println!("less than 5"),
        _ => println!("other"),
    }

    // 守卫中的变量遮蔽
    match x {
        n if {
            let n = 100;  // 遮蔽外层的n
            n > 50
        } => println!("guard n = 100"),
        n => println!("arm n = {}", n),
    }

    // 守卫影响穷尽性
    enum Status {
        Active,
        Inactive,
    }

    let status = Status::Active;
    // 需要_分支，因为守卫可能失败
    match status {
        Status::Active if y => println!("active and y"),
        _ => println!("other"),
    }
}
```

### 2.4 绑定模式

```rust
fn main() {
    let x = 15;

    // @ 绑定整个值
    match x {
        n @ 1..=10 => println!("n = {}", n),
        n @ 11..=20 => println!("n = {}", n),
        n => println!("n = {}", n),
    }

    // @ 绑定子模式
    struct Point {
        x: i32,
        y: i32,
    }

    let point = Point { x: 5, y: 10 };
    match point {
        p @ Point { x: 0..=5, y: 0..=5 } => {
            println!("small point: ({}, {})", p.x, p.y);
        },
        Point { x, y } => {
            println!("other point: ({}, {})", x, y);
        },
    }

    // @ 与 | 组合
    match x {
        n @ (1 | 2 | 3) => println!("small: {}", n),
        n @ (4 | 5 | 6) => println!("medium: {}", n),
        n => println!("large: {}", n),
    }
}
```

---

## 3. loop表达式参考

### 3.1 完整语法

```bnf
loop_expression :=
    (loop_label ":")? "loop" block_expression

loop_label :=
    "'" IDENTIFIER
```

**示例**:

```rust
fn main() {
    // 基本loop
    let mut count = 0;
    loop {
        count += 1;
        if count == 5 {
            break;
        }
    }

    // 带标签的loop
    'outer: loop {
        'inner: loop {
            break 'outer;
        }
    }
}
```

### 3.2 循环标签

**标签规则**:

```rust
fn main() {
    // 1. 标签以单引号开头
    'label: loop {
        break 'label;
    }

    // 2. 标签必须唯一
    'outer: loop {
        // 'outer: loop { }  // 错误：重复标签
        'inner: loop {
            break 'outer;
        }
        break;
    }

    // 3. 标签作用域
    'label: loop {
        {
            // 可以访问外层标签
            break 'label;
        }
    }

    // 4. 嵌套标签
    'a: loop {
        'b: loop {
            'c: loop {
                break 'a;  // 跳出最外层
            }
        }
    }
}
```

### 3.3 返回值

```rust
fn main() {
    // loop可以返回值
    let result = loop {
        break 42;
    };
    println!("{}", result);

    // 类型推断
    let result: i32 = loop {
        break 42;
    };

    // 不同分支返回相同类型
    let mut count = 0;
    let result = loop {
        count += 1;
        if count == 5 {
            break "five";
        } else if count == 10 {
            break "ten";
        }
    };

    // 带标签的返回值
    let result = 'outer: loop {
        loop {
            break 'outer 42;
        }
    };
    println!("{}", result);

    // 无返回值的loop (返回!)
    // loop { }  // 永不返回，类型是!
}
```

### 3.4 生命周期

```rust
fn main() {
    // loop内的变量生命周期
    let mut x = 0;
    loop {
        x += 1;
        let y = x * 2;  // y在每次迭代创建和销毁
        if x > 5 {
            break;
        }
    }

    // 借用规则
    let mut vec = vec![1, 2, 3];
    let result = loop {
        if let Some(value) = vec.pop() {
            if value == 2 {
                break value;
            }
        } else {
            break 0;
        }
    };
    println!("{}", result);
}
```

---

## 4. while表达式参考

### 4.1 完整语法

```bnf
while_expression :=
    (loop_label ":")? "while" expression_without_block block_expression
```

**示例**:

```rust
fn main() {
    let mut count = 0;

    // 基本while
    while count < 5 {
        count += 1;
    }

    // 带标签的while
    'outer: while true {
        break 'outer;
    }

    // 复杂条件
    let mut x = 0;
    let mut y = 10;
    while x < 5 && y > 0 {
        x += 1;
        y -= 1;
    }
}
```

### 4.2 while let

```bnf
while_let_expression :=
    (loop_label ":")? "while" "let" pattern "=" expression_without_block
    block_expression
```

**示例**:

```rust
fn main() {
    // 基本while let
    let mut stack = vec![1, 2, 3];
    while let Some(value) = stack.pop() {
        println!("{}", value);
    }

    // 复杂模式
    let mut iter = vec![(1, 2), (3, 4)].into_iter();
    while let Some((x, y)) = iter.next() {
        println!("x={}, y={}", x, y);
    }

    // 带标签
    'outer: while let Some(value) = Some(5) {
        break 'outer;
    }
}
```

### 4.3 条件求值

```rust
fn main() {
    let mut count = 0;

    // 条件每次迭代都求值
    while {
        println!("求值条件");
        count += 1;
        count < 3
    } {
        println!("循环体");
    }

    // 短路求值
    let mut x = 0;
    let mut y = 0;
    while x < 5 && { y += 1; true } {
        x += 1;
    }
    println!("x={}, y={}", x, y);
}
```

---

## 5. for表达式参考

### 5.1 完整语法

```bnf
for_expression :=
    (loop_label ":")? "for" pattern "in" expression_without_block
    block_expression
```

**示例**:

```rust
fn main() {
    // 基本for
    for i in 0..5 {
        println!("{}", i);
    }

    // 带标签
    'outer: for i in 0..5 {
        break 'outer;
    }

    // 模式解构
    for (key, value) in vec![("a", 1), ("b", 2)] {
        println!("{}: {}", key, value);
    }
}
```

### 5.2 IntoIterator

**转换规则**:

```rust
fn main() {
    let vec = vec![1, 2, 3];

    // for自动调用into_iter()
    for item in vec {  // 消费vec
        println!("{}", item);
    }
    // vec已被移动

    // 显式调用
    let vec = vec![1, 2, 3];
    for item in vec.into_iter() {  // 等价
        println!("{}", item);
    }

    // 借用迭代
    let vec = vec![1, 2, 3];
    for item in &vec {  // 不消费vec
        println!("{}", item);
    }
    println!("{:?}", vec);  // vec仍可用

    // 可变借用迭代
    let mut vec = vec![1, 2, 3];
    for item in &mut vec {
        *item *= 2;
    }
    println!("{:?}", vec);
}
```

### 5.3 模式绑定

```rust
fn main() {
    // 元组模式
    for (i, value) in vec![1, 2, 3].into_iter().enumerate() {
        println!("{}: {}", i, value);
    }

    // 结构体模式
    struct Point {
        x: i32,
        y: i32,
    }

    let points = vec![
        Point { x: 0, y: 0 },
        Point { x: 1, y: 1 },
    ];

    for Point { x, y } in points {
        println!("({}, {})", x, y);
    }

    // 嵌套模式
    for ((a, b), c) in vec![((1, 2), 3), ((4, 5), 6)] {
        println!("a={}, b={}, c={}", a, b, c);
    }

    // 忽略部分
    for (_, value) in vec![(1, "a"), (2, "b")] {
        println!("{}", value);
    }
}
```

---

## 6. break和continue参考

### 6.1 break语法

```bnf
break_expression :=
    "break" (loop_label)? expression?
```

**示例**:

```rust
fn main() {
    // 基本break
    loop {
        break;
    }

    // 带值的break
    let result = loop {
        break 42;
    };

    // 带标签的break
    'outer: loop {
        loop {
            break 'outer;
        }
    }

    // 带标签和值的break
    let result = 'outer: loop {
        loop {
            break 'outer 42;
        }
    };

    println!("{}", result);
}
```

### 6.2 continue语法

```bnf
continue_expression :=
    "continue" (loop_label)?
```

**示例**:

```rust
fn main() {
    // 基本continue
    for i in 0..5 {
        if i == 2 {
            continue;
        }
        println!("{}", i);
    }

    // 带标签的continue
    'outer: for i in 0..3 {
        for j in 0..3 {
            if j == 1 {
                continue 'outer;
            }
            println!("i={}, j={}", i, j);
        }
    }
}
```

### 6.3 标签使用

```rust
fn main() {
    // 标签规则同loop
    'outer: for i in 0..3 {
        'inner: for j in 0..3 {
            if i == 1 && j == 1 {
                break 'outer;
            }
            if j == 2 {
                continue 'inner;
            }
            println!("i={}, j={}", i, j);
        }
    }

    // 标签与循环类型
    'label: loop {
        break 'label;
    }

    'label: while true {
        break 'label;
    }

    'label: for _ in 0..5 {
        break 'label;
    }
}
```

---

## 7. 特殊控制流

### 7.1 return语句

```rust
fn example() -> i32 {
    // 显式return
    return 42;
}

fn early_return(value: Option<i32>) -> i32 {
    // 提前返回
    let Some(v) = value else {
        return 0;
    };
    v * 2
}

fn main() {
    println!("{}", example());
    println!("{}", early_return(Some(10)));
    println!("{}", early_return(None));
}
```

### 7.2 发散函数

```rust
// 永不返回的函数
fn diverges() -> ! {
    panic!("This function never returns");
}

fn loop_forever() -> ! {
    loop {
        println!("forever");
    }
}

fn main() {
    // 发散函数可以用在任何类型位置
    let x: i32 = if false {
        42
    } else {
        // diverges()  // ! 可以强制转换为任何类型
        panic!("error")
    };
}
```

### 7.3 never类型

```rust
fn main() {
    // ! 是never类型
    let x: ! = loop { };  // 永不返回

    // ! 可以强制转换为任何类型
    let y: i32 = if false {
        42
    } else {
        panic!("error")  // panic!返回!
    };

    // match中的!
    enum Message {
        Quit,
        Value(i32),
    }

    let msg = Message::Value(42);
    let value: i32 = match msg {
        Message::Value(v) => v,
        Message::Quit => panic!("quit"),  // ! -> i32
    };

    println!("{}", value);
}
```

---

## 8. 性能考虑

```rust
fn main() {
    // 1. 范围迭代vs手动循环
    // 性能相同，但范围迭代更安全
    let mut sum = 0;
    for i in 0..100 {
        sum += i;
    }

    let mut sum = 0;
    let mut i = 0;
    while i < 100 {
        sum += i;
        i += 1;
    }

    // 2. 迭代器vs索引访问
    let vec = vec![1, 2, 3, 4, 5];

    // 推荐：迭代器（无边界检查）
    for &item in &vec {
        println!("{}", item);
    }

    // 不推荐：索引访问（有边界检查）
    for i in 0..vec.len() {
        println!("{}", vec[i]);
    }

    // 3. if vs match
    // 性能相同，选择可读性更好的
    let x = 5;

    let result = if x < 10 {
        "small"
    } else {
        "large"
    };

    let result = match x {
        0..=9 => "small",
        _ => "large",
    };

    println!("{}", result);
}
```

---

## 9. 编译器优化

```rust
fn main() {
    // 1. 常量折叠
    let x = if true { 1 } else { 2 };  // 优化为: let x = 1;

    // 2. 死代码消除
    if false {
        println!("dead code");  // 会被删除
    }

    // 3. 循环展开
    for i in 0..4 {
        println!("{}", i);  // 可能被展开
    }

    // 4. 尾递归优化
    fn factorial(n: u64, acc: u64) -> u64 {
        if n == 0 {
            acc
        } else {
            factorial(n - 1, n * acc)  // 可能被优化为循环
        }
    }

    println!("{}", factorial(5, 1));
}
```

---

## 10. 参考表

### 控制流表达式对比

| 表达式 | 条件 | 重复 | 返回值 | 标签 | 穷尽性 |
| --- | --- | --- | --- | --- | --- |
| if | ✅ | ❌ | ✅ | ❌ | ⚠️ |
| match | ✅ | ❌ | ✅ | ❌ | ✅ |
| loop | ❌ | ✅ | ✅ | ✅ | - |
| while | ✅ | ✅ | ❌ | ✅ | - |
| for | ❌ | ✅ | ❌ | ✅ | - |

### 控制流关键字

| 关键字 | 用途 | 适用表达式 | 可带值 | 可带标签 |
| --- | --- | --- | --- | --- |
| if | 条件判断 | if | - | - |
| else | 分支选择 | if | - | - |
| match | 模式匹配 | match | - | - |
| loop | 无限循环 | loop | - | ✅ |
| while | 条件循环 | while | - | ✅ |
| for | 迭代循环 | for | - | ✅ |
| break | 退出循环 | loop/while/for | ✅ | ✅ |
| continue | 跳过当前迭代 | loop/while/for | ❌ | ✅ |
| return | 函数返回 | 任何函数 | ✅ | ❌ |

### 类型规则总结

| 场景 | 规则 | 示例 |
| --- | --- | --- |
| if条件 | 必须是bool | `if true { }` |
| if分支类型 | 所有分支相同 | `if c { 1 } else { 2 }` |
| if作为表达式 | 必须有else | `let x = if c { 1 } else { 2 };` |
| match穷尽性 | 必须覆盖所有情况 | `match x { _ => {} }` |
| match分支类型 | 所有分支相同 | `match x { 1 => 1, _ => 2 }` |
| loop返回值 | break的值 | `loop { break 42; }` |
| for迭代器 | 实现IntoIterator | `for x in vec { }` |

---

**最后更新**: 2025-12-11
**文档版本**: v2025.1.0
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**📚 完整的Rust控制流参考手册** 🦀✨
