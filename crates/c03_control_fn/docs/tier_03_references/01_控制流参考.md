# 3.1 æ§åˆ¶æµå‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: Rustæ§åˆ¶æµå®Œæ•´å‚è€ƒæ‰‹å†Œ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æŸ¥é˜…è¯¦ç»†è¯­æ³•å’Œè§„åˆ™çš„å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [æ¡ä»¶è¯­å¥æŒ‡å—](../tier_02_guides/01_æ¡ä»¶è¯­å¥æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [3.1 æ§åˆ¶æµå‚è€ƒ](#31-æ§åˆ¶æµå‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ifè¡¨è¾¾å¼å‚è€ƒ](#1-ifè¡¨è¾¾å¼å‚è€ƒ)
    - [1.1 å®Œæ•´è¯­æ³•](#11-å®Œæ•´è¯­æ³•)
    - [1.2 ç±»å‹è§„åˆ™](#12-ç±»å‹è§„åˆ™)
    - [1.3 ä½œç”¨åŸŸè§„åˆ™](#13-ä½œç”¨åŸŸè§„åˆ™)
    - [1.4 æ±‚å€¼é¡ºåº](#14-æ±‚å€¼é¡ºåº)
  - [2. matchè¡¨è¾¾å¼å‚è€ƒ](#2-matchè¡¨è¾¾å¼å‚è€ƒ)
    - [2.1 å®Œæ•´è¯­æ³•](#21-å®Œæ•´è¯­æ³•)
    - [2.2 ç©·å°½æ€§æ£€æŸ¥](#22-ç©·å°½æ€§æ£€æŸ¥)
    - [2.3 å®ˆå«è§„åˆ™](#23-å®ˆå«è§„åˆ™)
    - [2.4 ç»‘å®šæ¨¡å¼](#24-ç»‘å®šæ¨¡å¼)
  - [3. loopè¡¨è¾¾å¼å‚è€ƒ](#3-loopè¡¨è¾¾å¼å‚è€ƒ)
    - [3.1 å®Œæ•´è¯­æ³•](#31-å®Œæ•´è¯­æ³•)
    - [3.2 å¾ªç¯æ ‡ç­¾](#32-å¾ªç¯æ ‡ç­¾)
    - [3.3 è¿”å›å€¼](#33-è¿”å›å€¼)
    - [3.4 ç”Ÿå‘½å‘¨æœŸ](#34-ç”Ÿå‘½å‘¨æœŸ)
  - [4. whileè¡¨è¾¾å¼å‚è€ƒ](#4-whileè¡¨è¾¾å¼å‚è€ƒ)
    - [4.1 å®Œæ•´è¯­æ³•](#41-å®Œæ•´è¯­æ³•)
    - [4.2 while let](#42-while-let)
    - [4.3 æ¡ä»¶æ±‚å€¼](#43-æ¡ä»¶æ±‚å€¼)
  - [5. forè¡¨è¾¾å¼å‚è€ƒ](#5-forè¡¨è¾¾å¼å‚è€ƒ)
    - [5.1 å®Œæ•´è¯­æ³•](#51-å®Œæ•´è¯­æ³•)
    - [5.2 IntoIterator](#52-intoiterator)
    - [5.3 æ¨¡å¼ç»‘å®š](#53-æ¨¡å¼ç»‘å®š)
  - [6. breakå’Œcontinueå‚è€ƒ](#6-breakå’Œcontinueå‚è€ƒ)
    - [6.1 breakè¯­æ³•](#61-breakè¯­æ³•)
    - [6.2 continueè¯­æ³•](#62-continueè¯­æ³•)
    - [6.3 æ ‡ç­¾ä½¿ç”¨](#63-æ ‡ç­¾ä½¿ç”¨)
  - [7. ç‰¹æ®Šæ§åˆ¶æµ](#7-ç‰¹æ®Šæ§åˆ¶æµ)
    - [7.1 returnè¯­å¥](#71-returnè¯­å¥)
    - [7.2 å‘æ•£å‡½æ•°](#72-å‘æ•£å‡½æ•°)
    - [7.3 neverç±»å‹](#73-neverç±»å‹)
  - [8. æ€§èƒ½è€ƒè™‘](#8-æ€§èƒ½è€ƒè™‘)
  - [9. ç¼–è¯‘å™¨ä¼˜åŒ–](#9-ç¼–è¯‘å™¨ä¼˜åŒ–)
  - [10. å‚è€ƒè¡¨](#10-å‚è€ƒè¡¨)
    - [æ§åˆ¶æµè¡¨è¾¾å¼å¯¹æ¯”](#æ§åˆ¶æµè¡¨è¾¾å¼å¯¹æ¯”)
    - [æ§åˆ¶æµå…³é”®å­—](#æ§åˆ¶æµå…³é”®å­—)
    - [ç±»å‹è§„åˆ™æ€»ç»“](#ç±»å‹è§„åˆ™æ€»ç»“)

---

## 1. ifè¡¨è¾¾å¼å‚è€ƒ

### 1.1 å®Œæ•´è¯­æ³•

```bnf
if_expression :=
    "if" expression_without_block block_expression
    ("else" ("if" expression_without_block block_expression)* 
     ("else" block_expression)?)?

expression_without_block := 
    // ä»»ä½•ä¸ä»¥ { å¼€å§‹çš„è¡¨è¾¾å¼

block_expression :=
    "{" statements? expression? "}"
```

**ç¤ºä¾‹**:

```rust
fn main() {
    // æœ€ç®€å½¢å¼
    if true {
        println!("true");
    }
    
    // å®Œæ•´å½¢å¼
    let result = if condition() {
        expression1()
    } else if condition2() {
        expression2()
    } else {
        expression3()
    };
    
    println!("{}", result);
}

fn condition() -> bool { true }
fn condition2() -> bool { false }
fn expression1() -> i32 { 1 }
fn expression2() -> i32 { 2 }
fn expression3() -> i32 { 3 }
```

### 1.2 ç±»å‹è§„åˆ™

**è§„åˆ™1**: æ¡ä»¶å¿…é¡»æ˜¯ `bool` ç±»å‹

```rust
fn main() {
    // âœ… æ­£ç¡®
    if true { }
    if false { }
    if 1 == 2 { }
    
    // âŒ é”™è¯¯ï¼šéboolç±»å‹
    // if 1 { }
    // if "hello" { }
    // if Some(5) { }
}
```

**è§„åˆ™2**: æ‰€æœ‰åˆ†æ”¯ç±»å‹å¿…é¡»ç›¸åŒ

```rust
fn main() {
    // âœ… æ­£ç¡®ï¼šæ‰€æœ‰åˆ†æ”¯è¿”å› i32
    let x: i32 = if true { 1 } else { 2 };
    
    // âœ… æ­£ç¡®ï¼šæ‰€æœ‰åˆ†æ”¯è¿”å› ()
    if true { 
        println!("a");
    } else { 
        println!("b");
    }
    
    // âŒ é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // let x = if true { 1 } else { "two" };
    
    // âŒ é”™è¯¯ï¼šç¼ºå°‘elseåˆ†æ”¯
    // let x = if true { 1 };
}
```

**è§„åˆ™3**: è¡¨è¾¾å¼å½¢å¼å¿…é¡»æœ‰elseåˆ†æ”¯

```rust
fn main() {
    // âœ… æ­£ç¡®ï¼šè¯­å¥å½¢å¼ï¼Œä¸éœ€è¦else
    if true {
        println!("hello");
    }
    
    // âœ… æ­£ç¡®ï¼šè¡¨è¾¾å¼å½¢å¼ï¼Œæœ‰else
    let x = if true { 1 } else { 2 };
    
    // âŒ é”™è¯¯ï¼šè¡¨è¾¾å¼å½¢å¼ï¼Œç¼ºå°‘else
    // let x = if true { 1 };
}
```

### 1.3 ä½œç”¨åŸŸè§„åˆ™

```rust
fn main() {
    let x = 10;
    
    if true {
        let y = 20;  // yåªåœ¨ifå—å†…æœ‰æ•ˆ
        println!("{} {}", x, y);
    }
    
    // println!("{}", y);  // é”™è¯¯ï¼šyä¸åœ¨ä½œç”¨åŸŸå†…
    
    // ifå—ä¸åˆ›å»ºæ–°çš„ç”Ÿå‘½å‘¨æœŸåŒºåŸŸ
    let r;
    if true {
        let value = 42;
        // r = &value;  // é”™è¯¯ï¼švalueåœ¨ifå—ç»“æŸæ—¶drop
    }
    
    // ä½†å¯ä»¥åœ¨ifä¸­ç§»åŠ¨å€¼
    let s = String::from("hello");
    if true {
        let _moved = s;  // sè¢«ç§»åŠ¨
    }
    // println!("{}", s);  // é”™è¯¯ï¼šså·²è¢«ç§»åŠ¨
}
```

### 1.4 æ±‚å€¼é¡ºåº

```rust
fn main() {
    // æ¡ä»¶è¡¨è¾¾å¼é¦–å…ˆæ±‚å€¼
    if {
        println!("æ±‚å€¼æ¡ä»¶");
        true
    } {
        println!("æ‰§è¡Œthenåˆ†æ”¯");
    } else {
        println!("æ‰§è¡Œelseåˆ†æ”¯");
    }
    
    // çŸ­è·¯æ±‚å€¼
    let mut count = 0;
    let result = if false && { count += 1; true } {
        "then"
    } else {
        "else"
    };
    println!("count: {}", count);  // 0ï¼Œå› ä¸ºçŸ­è·¯äº†
    
    // åªæ±‚å€¼æ‰§è¡Œçš„åˆ†æ”¯
    let result = if true {
        println!("thenåˆ†æ”¯");
        1
    } else {
        println!("elseåˆ†æ”¯");  // ä¸æ‰§è¡Œ
        2
    };
}
```

---

## 2. matchè¡¨è¾¾å¼å‚è€ƒ

### 2.1 å®Œæ•´è¯­æ³•

```bnf
match_expression :=
    "match" expression_without_block "{" 
    match_arms? 
    "}"

match_arms :=
    (match_arm "=>" (block_expression | expression ","))+

match_arm :=
    pattern ("|" pattern)* ("if" expression)?
```

**ç¤ºä¾‹**:

```rust
fn main() {
    let value = 5;
    
    match value {
        1 => println!("one"),
        2 | 3 => println!("two or three"),
        4..=6 => println!("four to six"),
        n if n > 10 => println!("greater than ten"),
        _ => println!("something else"),
    }
}
```

### 2.2 ç©·å°½æ€§æ£€æŸ¥

**è§„åˆ™**: matchå¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½çš„å€¼

```rust
fn main() {
    // âœ… æ­£ç¡®ï¼šä½¿ç”¨_é€šé…ç¬¦
    match 5 {
        1 => {},
        2 => {},
        _ => {},
    }
    
    // âœ… æ­£ç¡®ï¼šè¦†ç›–æ‰€æœ‰èŒƒå›´
    match 5u8 {
        0..=127 => {},
        128..=255 => {},
    }
    
    // âœ… æ­£ç¡®ï¼šæšä¸¾å®Œå…¨åŒ¹é…
    enum Color {
        Red,
        Green,
        Blue,
    }
    
    let color = Color::Red;
    match color {
        Color::Red => {},
        Color::Green => {},
        Color::Blue => {},
    }
    
    // âŒ é”™è¯¯ï¼šæœªç©·å°½
    // match 5 {
    //     1 => {},
    //     2 => {},
    // }
}
```

**ä¸å¯è¾¾æ¨¡å¼è­¦å‘Š**:

```rust
fn main() {
    match 5 {
        1 => {},
        _ => {},
        // è­¦å‘Šï¼šä¸å¯è¾¾æ¨¡å¼
        // 2 => {},
    }
    
    match Some(5) {
        Some(_) => {},
        None => {},
        // è­¦å‘Šï¼šä¸å¯è¾¾æ¨¡å¼
        // Some(10) => {},
    }
}
```

### 2.3 å®ˆå«è§„åˆ™

```rust
fn main() {
    let x = 4;
    let y = false;
    
    // å®ˆå«å¯ä»¥è®¿é—®å¤–éƒ¨å˜é‡
    match x {
        n if y => println!("y is true"),
        n if n < 5 => println!("less than 5"),
        _ => println!("other"),
    }
    
    // å®ˆå«ä¸­çš„å˜é‡é®è”½
    match x {
        n if {
            let n = 100;  // é®è”½å¤–å±‚çš„n
            n > 50
        } => println!("guard n = 100"),
        n => println!("arm n = {}", n),
    }
    
    // å®ˆå«å½±å“ç©·å°½æ€§
    enum Status {
        Active,
        Inactive,
    }
    
    let status = Status::Active;
    // éœ€è¦_åˆ†æ”¯ï¼Œå› ä¸ºå®ˆå«å¯èƒ½å¤±è´¥
    match status {
        Status::Active if y => println!("active and y"),
        _ => println!("other"),
    }
}
```

### 2.4 ç»‘å®šæ¨¡å¼

```rust
fn main() {
    let x = 15;
    
    // @ ç»‘å®šæ•´ä¸ªå€¼
    match x {
        n @ 1..=10 => println!("n = {}", n),
        n @ 11..=20 => println!("n = {}", n),
        n => println!("n = {}", n),
    }
    
    // @ ç»‘å®šå­æ¨¡å¼
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 5, y: 10 };
    match point {
        p @ Point { x: 0..=5, y: 0..=5 } => {
            println!("small point: ({}, {})", p.x, p.y);
        },
        Point { x, y } => {
            println!("other point: ({}, {})", x, y);
        },
    }
    
    // @ ä¸ | ç»„åˆ
    match x {
        n @ (1 | 2 | 3) => println!("small: {}", n),
        n @ (4 | 5 | 6) => println!("medium: {}", n),
        n => println!("large: {}", n),
    }
}
```

---

## 3. loopè¡¨è¾¾å¼å‚è€ƒ

### 3.1 å®Œæ•´è¯­æ³•

```bnf
loop_expression :=
    (loop_label ":")? "loop" block_expression

loop_label :=
    "'" IDENTIFIER
```

**ç¤ºä¾‹**:

```rust
fn main() {
    // åŸºæœ¬loop
    let mut count = 0;
    loop {
        count += 1;
        if count == 5 {
            break;
        }
    }
    
    // å¸¦æ ‡ç­¾çš„loop
    'outer: loop {
        'inner: loop {
            break 'outer;
        }
    }
}
```

### 3.2 å¾ªç¯æ ‡ç­¾

**æ ‡ç­¾è§„åˆ™**:

```rust
fn main() {
    // 1. æ ‡ç­¾ä»¥å•å¼•å·å¼€å¤´
    'label: loop {
        break 'label;
    }
    
    // 2. æ ‡ç­¾å¿…é¡»å”¯ä¸€
    'outer: loop {
        // 'outer: loop { }  // é”™è¯¯ï¼šé‡å¤æ ‡ç­¾
        'inner: loop {
            break 'outer;
        }
        break;
    }
    
    // 3. æ ‡ç­¾ä½œç”¨åŸŸ
    'label: loop {
        {
            // å¯ä»¥è®¿é—®å¤–å±‚æ ‡ç­¾
            break 'label;
        }
    }
    
    // 4. åµŒå¥—æ ‡ç­¾
    'a: loop {
        'b: loop {
            'c: loop {
                break 'a;  // è·³å‡ºæœ€å¤–å±‚
            }
        }
    }
}
```

### 3.3 è¿”å›å€¼

```rust
fn main() {
    // loopå¯ä»¥è¿”å›å€¼
    let result = loop {
        break 42;
    };
    println!("{}", result);
    
    // ç±»å‹æ¨æ–­
    let result: i32 = loop {
        break 42;
    };
    
    // ä¸åŒåˆ†æ”¯è¿”å›ç›¸åŒç±»å‹
    let mut count = 0;
    let result = loop {
        count += 1;
        if count == 5 {
            break "five";
        } else if count == 10 {
            break "ten";
        }
    };
    
    // å¸¦æ ‡ç­¾çš„è¿”å›å€¼
    let result = 'outer: loop {
        loop {
            break 'outer 42;
        }
    };
    println!("{}", result);
    
    // æ— è¿”å›å€¼çš„loop (è¿”å›!)
    // loop { }  // æ°¸ä¸è¿”å›ï¼Œç±»å‹æ˜¯!
}
```

### 3.4 ç”Ÿå‘½å‘¨æœŸ

```rust
fn main() {
    // loopå†…çš„å˜é‡ç”Ÿå‘½å‘¨æœŸ
    let mut x = 0;
    loop {
        x += 1;
        let y = x * 2;  // yåœ¨æ¯æ¬¡è¿­ä»£åˆ›å»ºå’Œé”€æ¯
        if x > 5 {
            break;
        }
    }
    
    // å€Ÿç”¨è§„åˆ™
    let mut vec = vec![1, 2, 3];
    let result = loop {
        if let Some(value) = vec.pop() {
            if value == 2 {
                break value;
            }
        } else {
            break 0;
        }
    };
    println!("{}", result);
}
```

---

## 4. whileè¡¨è¾¾å¼å‚è€ƒ

### 4.1 å®Œæ•´è¯­æ³•

```bnf
while_expression :=
    (loop_label ":")? "while" expression_without_block block_expression
```

**ç¤ºä¾‹**:

```rust
fn main() {
    let mut count = 0;
    
    // åŸºæœ¬while
    while count < 5 {
        count += 1;
    }
    
    // å¸¦æ ‡ç­¾çš„while
    'outer: while true {
        break 'outer;
    }
    
    // å¤æ‚æ¡ä»¶
    let mut x = 0;
    let mut y = 10;
    while x < 5 && y > 0 {
        x += 1;
        y -= 1;
    }
}
```

### 4.2 while let

```bnf
while_let_expression :=
    (loop_label ":")? "while" "let" pattern "=" expression_without_block 
    block_expression
```

**ç¤ºä¾‹**:

```rust
fn main() {
    // åŸºæœ¬while let
    let mut stack = vec![1, 2, 3];
    while let Some(value) = stack.pop() {
        println!("{}", value);
    }
    
    // å¤æ‚æ¨¡å¼
    let mut iter = vec![(1, 2), (3, 4)].into_iter();
    while let Some((x, y)) = iter.next() {
        println!("x={}, y={}", x, y);
    }
    
    // å¸¦æ ‡ç­¾
    'outer: while let Some(value) = Some(5) {
        break 'outer;
    }
}
```

### 4.3 æ¡ä»¶æ±‚å€¼

```rust
fn main() {
    let mut count = 0;
    
    // æ¡ä»¶æ¯æ¬¡è¿­ä»£éƒ½æ±‚å€¼
    while {
        println!("æ±‚å€¼æ¡ä»¶");
        count += 1;
        count < 3
    } {
        println!("å¾ªç¯ä½“");
    }
    
    // çŸ­è·¯æ±‚å€¼
    let mut x = 0;
    let mut y = 0;
    while x < 5 && { y += 1; true } {
        x += 1;
    }
    println!("x={}, y={}", x, y);
}
```

---

## 5. forè¡¨è¾¾å¼å‚è€ƒ

### 5.1 å®Œæ•´è¯­æ³•

```bnf
for_expression :=
    (loop_label ":")? "for" pattern "in" expression_without_block 
    block_expression
```

**ç¤ºä¾‹**:

```rust
fn main() {
    // åŸºæœ¬for
    for i in 0..5 {
        println!("{}", i);
    }
    
    // å¸¦æ ‡ç­¾
    'outer: for i in 0..5 {
        break 'outer;
    }
    
    // æ¨¡å¼è§£æ„
    for (key, value) in vec![("a", 1), ("b", 2)] {
        println!("{}: {}", key, value);
    }
}
```

### 5.2 IntoIterator

**è½¬æ¢è§„åˆ™**:

```rust
fn main() {
    let vec = vec![1, 2, 3];
    
    // forè‡ªåŠ¨è°ƒç”¨into_iter()
    for item in vec {  // æ¶ˆè´¹vec
        println!("{}", item);
    }
    // vecå·²è¢«ç§»åŠ¨
    
    // æ˜¾å¼è°ƒç”¨
    let vec = vec![1, 2, 3];
    for item in vec.into_iter() {  // ç­‰ä»·
        println!("{}", item);
    }
    
    // å€Ÿç”¨è¿­ä»£
    let vec = vec![1, 2, 3];
    for item in &vec {  // ä¸æ¶ˆè´¹vec
        println!("{}", item);
    }
    println!("{:?}", vec);  // vecä»å¯ç”¨
    
    // å¯å˜å€Ÿç”¨è¿­ä»£
    let mut vec = vec![1, 2, 3];
    for item in &mut vec {
        *item *= 2;
    }
    println!("{:?}", vec);
}
```

### 5.3 æ¨¡å¼ç»‘å®š

```rust
fn main() {
    // å…ƒç»„æ¨¡å¼
    for (i, value) in vec![1, 2, 3].into_iter().enumerate() {
        println!("{}: {}", i, value);
    }
    
    // ç»“æ„ä½“æ¨¡å¼
    struct Point {
        x: i32,
        y: i32,
    }
    
    let points = vec![
        Point { x: 0, y: 0 },
        Point { x: 1, y: 1 },
    ];
    
    for Point { x, y } in points {
        println!("({}, {})", x, y);
    }
    
    // åµŒå¥—æ¨¡å¼
    for ((a, b), c) in vec![((1, 2), 3), ((4, 5), 6)] {
        println!("a={}, b={}, c={}", a, b, c);
    }
    
    // å¿½ç•¥éƒ¨åˆ†
    for (_, value) in vec![(1, "a"), (2, "b")] {
        println!("{}", value);
    }
}
```

---

## 6. breakå’Œcontinueå‚è€ƒ

### 6.1 breakè¯­æ³•

```bnf
break_expression :=
    "break" (loop_label)? expression?
```

**ç¤ºä¾‹**:

```rust
fn main() {
    // åŸºæœ¬break
    loop {
        break;
    }
    
    // å¸¦å€¼çš„break
    let result = loop {
        break 42;
    };
    
    // å¸¦æ ‡ç­¾çš„break
    'outer: loop {
        loop {
            break 'outer;
        }
    }
    
    // å¸¦æ ‡ç­¾å’Œå€¼çš„break
    let result = 'outer: loop {
        loop {
            break 'outer 42;
        }
    };
    
    println!("{}", result);
}
```

### 6.2 continueè¯­æ³•

```bnf
continue_expression :=
    "continue" (loop_label)?
```

**ç¤ºä¾‹**:

```rust
fn main() {
    // åŸºæœ¬continue
    for i in 0..5 {
        if i == 2 {
            continue;
        }
        println!("{}", i);
    }
    
    // å¸¦æ ‡ç­¾çš„continue
    'outer: for i in 0..3 {
        for j in 0..3 {
            if j == 1 {
                continue 'outer;
            }
            println!("i={}, j={}", i, j);
        }
    }
}
```

### 6.3 æ ‡ç­¾ä½¿ç”¨

```rust
fn main() {
    // æ ‡ç­¾è§„åˆ™åŒloop
    'outer: for i in 0..3 {
        'inner: for j in 0..3 {
            if i == 1 && j == 1 {
                break 'outer;
            }
            if j == 2 {
                continue 'inner;
            }
            println!("i={}, j={}", i, j);
        }
    }
    
    // æ ‡ç­¾ä¸å¾ªç¯ç±»å‹
    'label: loop {
        break 'label;
    }
    
    'label: while true {
        break 'label;
    }
    
    'label: for _ in 0..5 {
        break 'label;
    }
}
```

---

## 7. ç‰¹æ®Šæ§åˆ¶æµ

### 7.1 returnè¯­å¥

```rust
fn example() -> i32 {
    // æ˜¾å¼return
    return 42;
}

fn early_return(value: Option<i32>) -> i32 {
    // æå‰è¿”å›
    let Some(v) = value else {
        return 0;
    };
    v * 2
}

fn main() {
    println!("{}", example());
    println!("{}", early_return(Some(10)));
    println!("{}", early_return(None));
}
```

### 7.2 å‘æ•£å‡½æ•°

```rust
// æ°¸ä¸è¿”å›çš„å‡½æ•°
fn diverges() -> ! {
    panic!("This function never returns");
}

fn loop_forever() -> ! {
    loop {
        println!("forever");
    }
}

fn main() {
    // å‘æ•£å‡½æ•°å¯ä»¥ç”¨åœ¨ä»»ä½•ç±»å‹ä½ç½®
    let x: i32 = if false {
        42
    } else {
        // diverges()  // ! å¯ä»¥å¼ºåˆ¶è½¬æ¢ä¸ºä»»ä½•ç±»å‹
        panic!("error")
    };
}
```

### 7.3 neverç±»å‹

```rust
fn main() {
    // ! æ˜¯neverç±»å‹
    let x: ! = loop { };  // æ°¸ä¸è¿”å›
    
    // ! å¯ä»¥å¼ºåˆ¶è½¬æ¢ä¸ºä»»ä½•ç±»å‹
    let y: i32 = if false {
        42
    } else {
        panic!("error")  // panic!è¿”å›!
    };
    
    // matchä¸­çš„!
    enum Message {
        Quit,
        Value(i32),
    }
    
    let msg = Message::Value(42);
    let value: i32 = match msg {
        Message::Value(v) => v,
        Message::Quit => panic!("quit"),  // ! -> i32
    };
    
    println!("{}", value);
}
```

---

## 8. æ€§èƒ½è€ƒè™‘

```rust
fn main() {
    // 1. èŒƒå›´è¿­ä»£vsæ‰‹åŠ¨å¾ªç¯
    // æ€§èƒ½ç›¸åŒï¼Œä½†èŒƒå›´è¿­ä»£æ›´å®‰å…¨
    let mut sum = 0;
    for i in 0..100 {
        sum += i;
    }
    
    let mut sum = 0;
    let mut i = 0;
    while i < 100 {
        sum += i;
        i += 1;
    }
    
    // 2. è¿­ä»£å™¨vsç´¢å¼•è®¿é—®
    let vec = vec![1, 2, 3, 4, 5];
    
    // æ¨èï¼šè¿­ä»£å™¨ï¼ˆæ— è¾¹ç•Œæ£€æŸ¥ï¼‰
    for &item in &vec {
        println!("{}", item);
    }
    
    // ä¸æ¨èï¼šç´¢å¼•è®¿é—®ï¼ˆæœ‰è¾¹ç•Œæ£€æŸ¥ï¼‰
    for i in 0..vec.len() {
        println!("{}", vec[i]);
    }
    
    // 3. if vs match
    // æ€§èƒ½ç›¸åŒï¼Œé€‰æ‹©å¯è¯»æ€§æ›´å¥½çš„
    let x = 5;
    
    let result = if x < 10 {
        "small"
    } else {
        "large"
    };
    
    let result = match x {
        0..=9 => "small",
        _ => "large",
    };
    
    println!("{}", result);
}
```

---

## 9. ç¼–è¯‘å™¨ä¼˜åŒ–

```rust
fn main() {
    // 1. å¸¸é‡æŠ˜å 
    let x = if true { 1 } else { 2 };  // ä¼˜åŒ–ä¸º: let x = 1;
    
    // 2. æ­»ä»£ç æ¶ˆé™¤
    if false {
        println!("dead code");  // ä¼šè¢«åˆ é™¤
    }
    
    // 3. å¾ªç¯å±•å¼€
    for i in 0..4 {
        println!("{}", i);  // å¯èƒ½è¢«å±•å¼€
    }
    
    // 4. å°¾é€’å½’ä¼˜åŒ–
    fn factorial(n: u64, acc: u64) -> u64 {
        if n == 0 {
            acc
        } else {
            factorial(n - 1, n * acc)  // å¯èƒ½è¢«ä¼˜åŒ–ä¸ºå¾ªç¯
        }
    }
    
    println!("{}", factorial(5, 1));
}
```

---

## 10. å‚è€ƒè¡¨

### æ§åˆ¶æµè¡¨è¾¾å¼å¯¹æ¯”

| è¡¨è¾¾å¼ | æ¡ä»¶ | é‡å¤ | è¿”å›å€¼ | æ ‡ç­¾ | ç©·å°½æ€§ |
|--------|------|------|--------|------|--------|
| if | âœ… | âŒ | âœ… | âŒ | âš ï¸ |
| match | âœ… | âŒ | âœ… | âŒ | âœ… |
| loop | âŒ | âœ… | âœ… | âœ… | - |
| while | âœ… | âœ… | âŒ | âœ… | - |
| for | âŒ | âœ… | âŒ | âœ… | - |

### æ§åˆ¶æµå…³é”®å­—

| å…³é”®å­— | ç”¨é€” | é€‚ç”¨è¡¨è¾¾å¼ | å¯å¸¦å€¼ | å¯å¸¦æ ‡ç­¾ |
|--------|------|------------|--------|----------|
| if | æ¡ä»¶åˆ¤æ–­ | if | - | - |
| else | åˆ†æ”¯é€‰æ‹© | if | - | - |
| match | æ¨¡å¼åŒ¹é… | match | - | - |
| loop | æ— é™å¾ªç¯ | loop | - | âœ… |
| while | æ¡ä»¶å¾ªç¯ | while | - | âœ… |
| for | è¿­ä»£å¾ªç¯ | for | - | âœ… |
| break | é€€å‡ºå¾ªç¯ | loop/while/for | âœ… | âœ… |
| continue | è·³è¿‡å½“å‰è¿­ä»£ | loop/while/for | âŒ | âœ… |
| return | å‡½æ•°è¿”å› | ä»»ä½•å‡½æ•° | âœ… | âŒ |

### ç±»å‹è§„åˆ™æ€»ç»“

| åœºæ™¯ | è§„åˆ™ | ç¤ºä¾‹ |
|------|------|------|
| ifæ¡ä»¶ | å¿…é¡»æ˜¯bool | `if true { }` |
| ifåˆ†æ”¯ç±»å‹ | æ‰€æœ‰åˆ†æ”¯ç›¸åŒ | `if c { 1 } else { 2 }` |
| ifä½œä¸ºè¡¨è¾¾å¼ | å¿…é¡»æœ‰else | `let x = if c { 1 } else { 2 };` |
| matchç©·å°½æ€§ | å¿…é¡»è¦†ç›–æ‰€æœ‰æƒ…å†µ | `match x { _ => {} }` |
| matchåˆ†æ”¯ç±»å‹ | æ‰€æœ‰åˆ†æ”¯ç›¸åŒ | `match x { 1 => 1, _ => 2 }` |
| loopè¿”å›å€¼ | breakçš„å€¼ | `loop { break 42; }` |
| forè¿­ä»£å™¨ | å®ç°IntoIterator | `for x in vec { }` |

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ“š å®Œæ•´çš„Rustæ§åˆ¶æµå‚è€ƒæ‰‹å†Œ** ğŸ¦€âœ¨
