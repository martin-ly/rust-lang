# 3.4 闭包参考

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: Rust闭包完整语法和trait参考  
> **适用对象**: 需要深入了解闭包机制的开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [函数系统指南](../tier_02_guides/03_函数系统指南.md)


## 📊 目录

- [3.4 闭包参考](#34-闭包参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 闭包语法](#1-闭包语法)
  - [2. 捕获机制](#2-捕获机制)
  - [3. 闭包trait](#3-闭包trait)
  - [4. move关键字](#4-move关键字)
  - [5. 生命周期](#5-生命周期)
  - [6. 类型推断](#6-类型推断)
  - [7. 异步闭包](#7-异步闭包)
    - [闭包trait对比](#闭包trait对比)
    - [捕获模式](#捕获模式)


**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [3.4 闭包参考](#34-闭包参考)
  - [� 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 闭包语法](#1-闭包语法)
  - [2. 捕获机制](#2-捕获机制)
  - [3. 闭包trait](#3-闭包trait)
  - [4. move关键字](#4-move关键字)
  - [5. 生命周期](#5-生命周期)
  - [6. 类型推断](#6-类型推断)
  - [7. 异步闭包](#7-异步闭包)
    - [闭包trait对比](#闭包trait对比)
    - [捕获模式](#捕获模式)

---

## 1. 闭包语法

**完整语法**:

```bnf
closure_expression :=
    "move"? 
    "|" closure_parameters? "|" 
    (expression | "->" type_no_bounds block_expression)

closure_parameters :=
    closure_param ("," closure_param)* ","?

closure_param :=
    pattern (":" type)?
```

**基本形式**:

```rust
fn main() {
    // 最简形式
    let f1 = || 42;
    
    // 带参数
    let f2 = |x| x + 1;
    
    // 多个参数
    let f3 = |x, y| x + y;
    
    // 指定参数类型
    let f4 = |x: i32| -> i32 { x * 2 };
    
    // 多行闭包
    let f5 = |x: i32| {
        let doubled = x * 2;
        doubled + 1
    };
    
    // move闭包
    let s = String::from("hello");
    let f6 = move || println!("{}", s);
    
    println!("{}", f1());
    println!("{}", f2(5));
    println!("{}", f3(3, 4));
    println!("{}", f4(10));
    println!("{}", f5(5));
    f6();
}
```

---

## 2. 捕获机制

**捕获规则**:

```rust
fn main() {
    let x = 10;
    let mut y = 20;
    let z = String::from("hello");
    
    // 1. 不可变借用捕获
    let c1 = || {
        println!("x = {}", x);  // 借用x
    };
    c1();
    println!("x = {}", x);  // x仍可用
    
    // 2. 可变借用捕获
    let mut c2 = || {
        y += 1;  // 可变借用y
        println!("y = {}", y);
    };
    c2();
    // println!("y = {}", y);  // 错误：可变借用期间不能使用
    drop(c2);  // 结束可变借用
    println!("y = {}", y);  // 现在可以使用
    
    // 3. 所有权转移捕获
    let c3 = || {
        println!("z = {}", z);  // 借用z
    };
    c3();
    println!("z = {}", z);  // z仍可用（因为只是借用）
    
    // 4. move强制所有权转移
    let c4 = move || {
        println!("z = {}", z);  // 获取z的所有权
    };
    c4();
    // println!("z = {}", z);  // 错误：z已被移动
}
```

**捕获环境的最小化原则**:

```rust
fn main() {
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 10, y: 20 };
    
    // 只捕获使用的字段
    let c = || {
        println!("x = {}", point.x);  // 只借用point.x
    };
    c();
    
    // point.y仍可修改
    // 但point.x不可修改（被借用）
    println!("point.y = {}", point.y);
}
```

---

## 3. 闭包trait

**三个闭包trait**:

```rust
// FnOnce: 可以调用一次
pub trait FnOnce<Args> {
    type Output;
    fn call_once(self, args: Args) -> Self::Output;
}

// FnMut: 可以调用多次，可以修改捕获的变量
pub trait FnMut<Args>: FnOnce<Args> {
    fn call_mut(&mut self, args: Args) -> Self::Output;
}

// Fn: 可以调用多次，不修改捕获的变量
pub trait Fn<Args>: FnMut<Args> {
    fn call(&self, args: Args) -> Self::Output;
}
```

**trait继承层次**:

```rust
fn main() {
    // Fn 实现了 FnMut 和 FnOnce
    // FnMut 实现了 FnOnce
    
    let x = 10;
    
    // Fn闭包（不可变借用）
    let fn_closure = || {
        println!("x = {}", x);
    };
    fn_closure();
    fn_closure();  // 可多次调用
    
    // FnMut闭包（可变借用）
    let mut y = 20;
    let mut fnmut_closure = || {
        y += 1;
        println!("y = {}", y);
    };
    fnmut_closure();
    fnmut_closure();  // 可多次调用
    
    // FnOnce闭包（获取所有权）
    let s = String::from("hello");
    let fnonce_closure = || {
        drop(s);  // 消费s
    };
    fnonce_closure();
    // fnonce_closure();  // 错误：只能调用一次
}
```

**作为参数**:

```rust
fn call_fn<F>(f: F) where F: Fn() {
    f();
    f();  // Fn可以多次调用
}

fn call_fn_mut<F>(mut f: F) where F: FnMut() {
    f();
    f();  // FnMut可以多次调用
}

fn call_fn_once<F>(f: F) where F: FnOnce() {
    f();
    // f();  // 错误：FnOnce只能调用一次
}

fn main() {
    let x = 10;
    call_fn(|| println!("{}", x));
    
    let mut y = 20;
    call_fn_mut(|| {
        y += 1;
        println!("{}", y);
    });
    
    let s = String::from("hello");
    call_fn_once(|| drop(s));
}
```

---

## 4. move关键字

**move语义**:

```rust
fn main() {
    // 不使用move
    let x = 10;
    let c1 = || println!("{}", x);  // 借用x
    c1();
    println!("{}", x);  // x仍可用
    
    // 使用move
    let y = 10;
    let c2 = move || println!("{}", y);  // 移动y（但y是Copy）
    c2();
    println!("{}", y);  // y仍可用（因为是Copy）
    
    // 非Copy类型的move
    let s = String::from("hello");
    let c3 = move || println!("{}", s);  // 移动s
    c3();
    // println!("{}", s);  // 错误：s已被移动
}
```

**move与线程**:

```rust
use std::thread;

fn main() {
    let s = String::from("hello");
    
    // 必须使用move将s移动到线程
    let handle = thread::spawn(move || {
        println!("{}", s);
    });
    
    handle.join().unwrap();
    // println!("{}", s);  // 错误：s已被移动
}
```

**move与Clone**:

```rust
fn main() {
    let s = String::from("hello");
    
    // 克隆后移动
    let s_clone = s.clone();
    let c = move || {
        println!("{}", s_clone);  // 移动克隆的值
    };
    c();
    println!("{}", s);  // 原始值仍可用
}
```

---

## 5. 生命周期

**闭包的生命周期**:

```rust
fn main() {
    let x = 10;
    
    // 闭包的生命周期与捕获的引用相关
    let c = || {
        println!("{}", x);
    };
    
    c();  // OK
    
    // 闭包不能比捕获的引用活得更久
    /*
    let c;
    {
        let y = 20;
        c = || println!("{}", y);  // 错误：y的生命周期不够长
    }
    c();
    */
}
```

**返回闭包的生命周期**:

```rust
// 返回闭包需要指定生命周期
fn make_closure<'a>(x: &'a i32) -> impl Fn() + 'a {
    move || println!("{}", x)
}

// 使用Box避免生命周期问题
fn make_boxed_closure<'a>(x: &'a i32) -> Box<dyn Fn() + 'a> {
    Box::new(move || println!("{}", x))
}

fn main() {
    let x = 10;
    let c = make_closure(&x);
    c();
    
    let c2 = make_boxed_closure(&x);
    c2();
}
```

---

## 6. 类型推断

**闭包类型推断**:

```rust
fn main() {
    // 编译器推断参数和返回类型
    let add = |x, y| x + y;
    println!("{}", add(1, 2));      // i32
    println!("{}", add(1.0, 2.0));  // f64
    
    // 显式类型注解
    let add_i32 = |x: i32, y: i32| -> i32 { x + y };
    println!("{}", add_i32(1, 2));
    
    // 一旦推断，类型固定
    let f = |x| x + 1;
    let _: i32 = f(10);  // 推断为i32
    // let _: f64 = f(10.0);  // 错误：已推断为i32
}
```

**trait对象类型**:

```rust
fn main() {
    // Box<dyn Fn>
    let f1: Box<dyn Fn(i32) -> i32> = Box::new(|x| x + 1);
    println!("{}", f1(10));
    
    // &dyn Fn
    let f2: &dyn Fn(i32) -> i32 = &|x| x * 2;
    println!("{}", f2(10));
    
    // impl Fn
    fn return_closure() -> impl Fn(i32) -> i32 {
        |x| x + 1
    }
    
    let f3 = return_closure();
    println!("{}", f3(10));
}
```

---

## 7. 异步闭包

**异步闭包（Rust 1.75+）**:

```rust
// async闭包
fn main() {
    let f = async || {
        println!("async closure");
        42
    };
    
    // 需要运行时执行
    // let result = f().await;
    
    println!("异步闭包需要运行时支持");
}
```

**async move闭包**:

```rust
fn main() {
    let s = String::from("hello");
    
    let f = async move || {
        println!("{}", s);
        42
    };
    
    // s已被移动
    // println!("{}", s);
    
    println!("异步move闭包");
}
```

---

**参考表**:

### 闭包trait对比

| Trait | 调用方式 | self类型 | 可调用次数 | 使用场景 |
|-------|---------|---------|-----------|---------|
| Fn | call(&self, args) | &self | 多次 | 不修改环境 |
| FnMut | call_mut(&mut self, args) | &mut self | 多次 | 修改环境 |
| FnOnce | call_once(self, args) | self | 一次 | 消费环境 |

### 捕获模式

| 模式 | 语法 | 所有权 | 示例 |
|------|------|--------|------|
| 不可变借用 | `\|\| {...}` | 借用 | `\|\| println!("{}", x)` |
| 可变借用 | `\|\| {...}` | 可变借用 | `\|\| x += 1` |
| 所有权转移 | `move \|\| {...}` | 移动 | `move \|\| drop(x)` |

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**📚 完整的Rust闭包参考** 🦀✨
