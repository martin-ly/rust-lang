# 3.5 错误处理参考

> **文档类型**: Tier 3 - 参考层  
> **文档定位**: Rust错误处理完整API参考  
> **适用对象**: 需要查阅错误处理详细规则的开发者  
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [错误处理指南](../tier_02_guides/05_错误处理指南.md)

## 📊 目录

- [3.5 错误处理参考](#35-错误处理参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. Option类型](#1-option类型)
  - [2. Result类型](#2-result类型)
  - [3. Error trait](#3-error-trait)
  - [4. ?操作符](#4-操作符)
  - [5. panic机制](#5-panic机制)
  - [6. From/Into转换](#6-frominto转换)
    - [Option vs Result](#option-vs-result)

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+  
**文档版本**: v2025.1.0

---

## 📋 目录

- [3.5 错误处理参考](#35-错误处理参考)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. Option类型](#1-option类型)
  - [2. Result类型](#2-result类型)
  - [3. Error trait](#3-error-trait)
  - [4. ?操作符](#4-操作符)
  - [5. panic机制](#5-panic机制)
  - [6. From/Into转换](#6-frominto转换)
    - [Option vs Result](#option-vs-result)

---

## 1. Option类型

**定义**:

```rust
pub enum Option<T> {
    None,
    Some(T),
}
```

**核心方法**:

| 方法 | 签名 | 描述 | 示例 |
|------|------|------|------|
| is_some | `is_some(&self) -> bool` | 是否为Some | `opt.is_some()` |
| is_none | `is_none(&self) -> bool` | 是否为None | `opt.is_none()` |
| unwrap | `unwrap(self) -> T` | 解包，None时panic | `opt.unwrap()` |
| unwrap_or | `unwrap_or(self, default: T) -> T` | 提供默认值 | `opt.unwrap_or(0)` |
| unwrap_or_else | `unwrap_or_else<F>(self, f: F) -> T` | 懒惰计算默认值 | `opt.unwrap_or_else(\|\| 0)` |
| unwrap_or_default | `unwrap_or_default(self) -> T` | 使用Default | `opt.unwrap_or_default()` |
| expect | `expect(self, msg: &str) -> T` | 带消息的unwrap | `opt.expect("no value")` |
| map | `map<U, F>(self, f: F) -> Option<U>` | 转换值 | `opt.map(\|x\| x * 2)` |
| map_or | `map_or<U, F>(self, default: U, f: F) -> U` | 转换或默认值 | `opt.map_or(0, \|x\| x * 2)` |
| map_or_else | `map_or_else<U, D, F>(self, default: D, f: F) -> U` | 转换或计算默认值 | `opt.map_or_else(\|\| 0, \|x\| x * 2)` |
| and | `and<U>(self, optb: Option<U>) -> Option<U>` | 逻辑与 | `opt.and(opt2)` |
| and_then | `and_then<U, F>(self, f: F) -> Option<U>` | 链式Option | `opt.and_then(\|x\| Some(x * 2))` |
| or | `or(self, optb: Option<T>) -> Option<T>` | 逻辑或 | `opt.or(opt2)` |
| or_else | `or_else<F>(self, f: F) -> Option<T>` | 懒惰or | `opt.or_else(\|\| Some(0))` |
| xor | `xor(self, optb: Option<T>) -> Option<T>` | 异或 | `opt.xor(opt2)` |
| filter | `filter<P>(self, predicate: P) -> Option<T>` | 过滤 | `opt.filter(\|&x\| x > 0)` |
| take | `take(&mut self) -> Option<T>` | 取出值留None | `opt.take()` |
| replace | `replace(&mut self, value: T) -> Option<T>` | 替换值 | `opt.replace(10)` |
| zip | `zip<U>(self, other: Option<U>) -> Option<(T, U)>` | 组合 | `opt.zip(opt2)` |

**示例**:

```rust
fn main() {
    let some = Some(42);
    let none: Option<i32> = None;
    
    // 检查
    assert!(some.is_some());
    assert!(none.is_none());
    
    // 解包
    assert_eq!(some.unwrap(), 42);
    assert_eq!(none.unwrap_or(0), 0);
    
    // 转换
    let doubled = some.map(|x| x * 2);
    assert_eq!(doubled, Some(84));
    
    // 链式操作
    let result = some
        .filter(|&x| x > 40)
        .map(|x| x * 2)
        .and_then(|x| Some(x + 1));
    assert_eq!(result, Some(85));
}
```

---

## 2. Result类型

**定义**:

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**核心方法**:

| 方法 | 签名 | 描述 | 示例 |
|------|------|------|------|
| is_ok | `is_ok(&self) -> bool` | 是否为Ok | `result.is_ok()` |
| is_err | `is_err(&self) -> bool` | 是否为Err | `result.is_err()` |
| ok | `ok(self) -> Option<T>` | 转为Option | `result.ok()` |
| err | `err(self) -> Option<E>` | 获取错误 | `result.err()` |
| unwrap | `unwrap(self) -> T` | 解包，Err时panic | `result.unwrap()` |
| unwrap_or | `unwrap_or(self, default: T) -> T` | 提供默认值 | `result.unwrap_or(0)` |
| unwrap_or_else | `unwrap_or_else<F>(self, op: F) -> T` | 错误处理函数 | `result.unwrap_or_else(\|e\| 0)` |
| unwrap_err | `unwrap_err(self) -> E` | 解包错误 | `result.unwrap_err()` |
| expect | `expect(self, msg: &str) -> T` | 带消息的unwrap | `result.expect("failed")` |
| expect_err | `expect_err(self, msg: &str) -> E` | 带消息的unwrap_err | `result.expect_err("should fail")` |
| map | `map<U, F>(self, op: F) -> Result<U, E>` | 转换Ok值 | `result.map(\|x\| x * 2)` |
| map_err | `map_err<F, O>(self, op: O) -> Result<T, F>` | 转换Err值 | `result.map_err(\|e\| format!("{}", e))` |
| map_or | `map_or<U, F>(self, default: U, f: F) -> U` | 转换或默认值 | `result.map_or(0, \|x\| x * 2)` |
| map_or_else | `map_or_else<U, D, F>(self, default: D, f: F) -> U` | 转换或错误处理 | `result.map_or_else(\|e\| 0, \|x\| x * 2)` |
| and | `and<U>(self, res: Result<U, E>) -> Result<U, E>` | 逻辑与 | `result.and(result2)` |
| and_then | `and_then<U, F>(self, op: F) -> Result<U, E>` | 链式Result | `result.and_then(\|x\| Ok(x * 2))` |
| or | `or<F>(self, res: Result<T, F>) -> Result<T, F>` | 逻辑或 | `result.or(result2)` |
| or_else | `or_else<F, O>(self, op: O) -> Result<T, F>` | 错误恢复 | `result.or_else(\|e\| Ok(0))` |

**示例**:

```rust
fn main() {
    let ok: Result<i32, &str> = Ok(42);
    let err: Result<i32, &str> = Err("error");
    
    // 检查
    assert!(ok.is_ok());
    assert!(err.is_err());
    
    // 解包
    assert_eq!(ok.unwrap(), 42);
    assert_eq!(err.unwrap_or(0), 0);
    
    // 转换
    let doubled = ok.map(|x| x * 2);
    assert_eq!(doubled, Ok(84));
    
    let formatted = err.map_err(|e| format!("Error: {}", e));
    assert_eq!(formatted, Err("Error: error".to_string()));
    
    // 链式操作
    let result = ok
        .and_then(|x| Ok(x * 2))
        .map(|x| x + 1);
    assert_eq!(result, Ok(85));
}
```

---

## 3. Error trait

**定义**:

```rust
pub trait Error: Debug + Display {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
    
    fn description(&self) -> &str {
        "description() is deprecated; use Display"
    }
    
    fn cause(&self) -> Option<&dyn Error> {
        self.source()
    }
}
```

**实现示例**:

```rust
use std::fmt;
use std::error::Error;

#[derive(Debug)]
struct MyError {
    details: String,
}

impl MyError {
    fn new(msg: &str) -> MyError {
        MyError {
            details: msg.to_string(),
        }
    }
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.details)
    }
}

impl Error for MyError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
}

fn main() {
    let error = MyError::new("something went wrong");
    println!("Error: {}", error);
    println!("Debug: {:?}", error);
}
```

---

## 4. ?操作符

**语法**:

```rust
expression?
```

**等价转换**:

```rust
// Option<T>
match option {
    Some(value) => value,
    None => return None,
}

// Result<T, E>
match result {
    Ok(value) => value,
    Err(err) => return Err(From::from(err)),
}
```

**使用规则**:

```rust
fn main() {
    // 1. 只能在返回Result或Option的函数中使用
    fn process() -> Result<i32, String> {
        let value = Some(42)?;  // 错误：返回类型不匹配
        Ok(value)
    }
    
    // 2. 自动进行From转换
    fn parse_number(s: &str) -> Result<i32, String> {
        let num: i32 = s.parse()?;  // ParseIntError自动转为String
        Ok(num)
    }
    
    // 3. 链式使用
    fn complex_operation() -> Result<i32, String> {
        let result = operation1()?;
        let result = operation2(result)?;
        let result = operation3(result)?;
        Ok(result)
    }
    
    fn operation1() -> Result<i32, String> { Ok(1) }
    fn operation2(x: i32) -> Result<i32, String> { Ok(x * 2) }
    fn operation3(x: i32) -> Result<i32, String> { Ok(x + 1) }
    
    let _ = complex_operation();
}
```

---

## 5. panic机制

**panic!宏**:

```rust
// 基本用法
panic!("crash and burn");

// 格式化消息
panic!("value = {}", 42);

// 条件panic
assert!(condition, "assertion failed");
assert_eq!(left, right, "values not equal");
assert_ne!(left, right, "values equal");
```

**panic钩子**:

```rust
use std::panic;

fn main() {
    // 设置panic hook
    panic::set_hook(Box::new(|panic_info| {
        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            println!("panic occurred: {}", s);
        }
    }));
    
    // 捕获panic
    let result = panic::catch_unwind(|| {
        // 可能panic的代码
        println!("running");
        42
    });
    
    match result {
        Ok(value) => println!("Success: {}", value),
        Err(_) => println!("Panic caught"),
    }
}
```

**unwrap家族**:

| 方法 | 行为 | 使用场景 |
|------|------|---------|
| unwrap() | Err/None时panic | 确信不会失败 |
| expect(msg) | Err/None时panic带消息 | 添加上下文 |
| unwrap_or(default) | 提供默认值 | 有合理默认值 |
| unwrap_or_else(f) | 计算默认值 | 默认值计算昂贵 |
| unwrap_or_default() | 使用Default | 有Default实现 |
| unwrap_err() | Ok时panic | 期望错误 |
| unwrap_unchecked() | 未检查的解包（unsafe） | 性能关键且确信安全 |

---

## 6. From/Into转换

**From trait**:

```rust
pub trait From<T> {
    fn from(T) -> Self;
}
```

**错误转换**:

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

// 自动转换io::Error
impl From<io::Error> for MyError {
    fn from(error: io::Error) -> Self {
        MyError::Io(error)
    }
}

// 自动转换ParseIntError
impl From<ParseIntError> for MyError {
    fn from(error: ParseIntError) -> Self {
        MyError::Parse(error)
    }
}

fn process() -> Result<i32, MyError> {
    let content = std::fs::read_to_string("file.txt")?;  // io::Error -> MyError
    let number = content.trim().parse()?;  // ParseIntError -> MyError
    Ok(number)
}

fn main() {
    match process() {
        Ok(num) => println!("Number: {}", num),
        Err(e) => println!("Error: {:?}", e),
    }
}
```

---

**完整方法对比表**:

### Option vs Result

| 操作 | Option | Result |
|------|--------|--------|
| 成功值 | Some(T) | Ok(T) |
| 失败值 | None | Err(E) |
| 检查成功 | is_some() | is_ok() |
| 检查失败 | is_none() | is_err() |
| 解包 | unwrap() | unwrap() |
| 带消息解包 | expect() | expect() |
| 默认值 | unwrap_or() | unwrap_or() |
| 转换 | map() | map() |
| 错误转换 | - | map_err() |
| 链式操作 | and_then() | and_then() |
| 错误恢复 | or_else() | or_else() |
| 转为Result | ok_or() | - |
| 转为Option | - | ok() |

---

**最后更新**: 2025-10-22  
**文档版本**: v2025.1.0  
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**📚 完整的Rust错误处理参考** 🦀✨
