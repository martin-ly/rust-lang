# 3.5 é”™è¯¯å¤„ç†å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: Rusté”™è¯¯å¤„ç†å®Œæ•´APIå‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æŸ¥é˜…é”™è¯¯å¤„ç†è¯¦ç»†è§„åˆ™çš„å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [é”™è¯¯å¤„ç†æŒ‡å—](../tier_02_guides/05_é”™è¯¯å¤„ç†æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [3.5 é”™è¯¯å¤„ç†å‚è€ƒ](#35-é”™è¯¯å¤„ç†å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Optionç±»å‹](#1-optionç±»å‹)
  - [2. Resultç±»å‹](#2-resultç±»å‹)
  - [3. Error trait](#3-error-trait)
  - [4. ?æ“ä½œç¬¦](#4-æ“ä½œç¬¦)
  - [5. panicæœºåˆ¶](#5-panicæœºåˆ¶)
  - [6. From/Intoè½¬æ¢](#6-fromintoè½¬æ¢)
    - [Option vs Result](#option-vs-result)

---

## 1. Optionç±»å‹

**å®šä¹‰**:

```rust
pub enum Option<T> {
    None,
    Some(T),
}
```

**æ ¸å¿ƒæ–¹æ³•**:

| æ–¹æ³• | ç­¾å | æè¿° | ç¤ºä¾‹ |
|------|------|------|------|
| is_some | `is_some(&self) -> bool` | æ˜¯å¦ä¸ºSome | `opt.is_some()` |
| is_none | `is_none(&self) -> bool` | æ˜¯å¦ä¸ºNone | `opt.is_none()` |
| unwrap | `unwrap(self) -> T` | è§£åŒ…ï¼ŒNoneæ—¶panic | `opt.unwrap()` |
| unwrap_or | `unwrap_or(self, default: T) -> T` | æä¾›é»˜è®¤å€¼ | `opt.unwrap_or(0)` |
| unwrap_or_else | `unwrap_or_else<F>(self, f: F) -> T` | æ‡’æƒ°è®¡ç®—é»˜è®¤å€¼ | `opt.unwrap_or_else(\|\| 0)` |
| unwrap_or_default | `unwrap_or_default(self) -> T` | ä½¿ç”¨Default | `opt.unwrap_or_default()` |
| expect | `expect(self, msg: &str) -> T` | å¸¦æ¶ˆæ¯çš„unwrap | `opt.expect("no value")` |
| map | `map<U, F>(self, f: F) -> Option<U>` | è½¬æ¢å€¼ | `opt.map(\|x\| x * 2)` |
| map_or | `map_or<U, F>(self, default: U, f: F) -> U` | è½¬æ¢æˆ–é»˜è®¤å€¼ | `opt.map_or(0, \|x\| x * 2)` |
| map_or_else | `map_or_else<U, D, F>(self, default: D, f: F) -> U` | è½¬æ¢æˆ–è®¡ç®—é»˜è®¤å€¼ | `opt.map_or_else(\|\| 0, \|x\| x * 2)` |
| and | `and<U>(self, optb: Option<U>) -> Option<U>` | é€»è¾‘ä¸ | `opt.and(opt2)` |
| and_then | `and_then<U, F>(self, f: F) -> Option<U>` | é“¾å¼Option | `opt.and_then(\|x\| Some(x * 2))` |
| or | `or(self, optb: Option<T>) -> Option<T>` | é€»è¾‘æˆ– | `opt.or(opt2)` |
| or_else | `or_else<F>(self, f: F) -> Option<T>` | æ‡’æƒ°or | `opt.or_else(\|\| Some(0))` |
| xor | `xor(self, optb: Option<T>) -> Option<T>` | å¼‚æˆ– | `opt.xor(opt2)` |
| filter | `filter<P>(self, predicate: P) -> Option<T>` | è¿‡æ»¤ | `opt.filter(\|&x\| x > 0)` |
| take | `take(&mut self) -> Option<T>` | å–å‡ºå€¼ç•™None | `opt.take()` |
| replace | `replace(&mut self, value: T) -> Option<T>` | æ›¿æ¢å€¼ | `opt.replace(10)` |
| zip | `zip<U>(self, other: Option<U>) -> Option<(T, U)>` | ç»„åˆ | `opt.zip(opt2)` |

**ç¤ºä¾‹**:

```rust
fn main() {
    let some = Some(42);
    let none: Option<i32> = None;
    
    // æ£€æŸ¥
    assert!(some.is_some());
    assert!(none.is_none());
    
    // è§£åŒ…
    assert_eq!(some.unwrap(), 42);
    assert_eq!(none.unwrap_or(0), 0);
    
    // è½¬æ¢
    let doubled = some.map(|x| x * 2);
    assert_eq!(doubled, Some(84));
    
    // é“¾å¼æ“ä½œ
    let result = some
        .filter(|&x| x > 40)
        .map(|x| x * 2)
        .and_then(|x| Some(x + 1));
    assert_eq!(result, Some(85));
}
```

---

## 2. Resultç±»å‹

**å®šä¹‰**:

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**æ ¸å¿ƒæ–¹æ³•**:

| æ–¹æ³• | ç­¾å | æè¿° | ç¤ºä¾‹ |
|------|------|------|------|
| is_ok | `is_ok(&self) -> bool` | æ˜¯å¦ä¸ºOk | `result.is_ok()` |
| is_err | `is_err(&self) -> bool` | æ˜¯å¦ä¸ºErr | `result.is_err()` |
| ok | `ok(self) -> Option<T>` | è½¬ä¸ºOption | `result.ok()` |
| err | `err(self) -> Option<E>` | è·å–é”™è¯¯ | `result.err()` |
| unwrap | `unwrap(self) -> T` | è§£åŒ…ï¼ŒErræ—¶panic | `result.unwrap()` |
| unwrap_or | `unwrap_or(self, default: T) -> T` | æä¾›é»˜è®¤å€¼ | `result.unwrap_or(0)` |
| unwrap_or_else | `unwrap_or_else<F>(self, op: F) -> T` | é”™è¯¯å¤„ç†å‡½æ•° | `result.unwrap_or_else(\|e\| 0)` |
| unwrap_err | `unwrap_err(self) -> E` | è§£åŒ…é”™è¯¯ | `result.unwrap_err()` |
| expect | `expect(self, msg: &str) -> T` | å¸¦æ¶ˆæ¯çš„unwrap | `result.expect("failed")` |
| expect_err | `expect_err(self, msg: &str) -> E` | å¸¦æ¶ˆæ¯çš„unwrap_err | `result.expect_err("should fail")` |
| map | `map<U, F>(self, op: F) -> Result<U, E>` | è½¬æ¢Okå€¼ | `result.map(\|x\| x * 2)` |
| map_err | `map_err<F, O>(self, op: O) -> Result<T, F>` | è½¬æ¢Errå€¼ | `result.map_err(\|e\| format!("{}", e))` |
| map_or | `map_or<U, F>(self, default: U, f: F) -> U` | è½¬æ¢æˆ–é»˜è®¤å€¼ | `result.map_or(0, \|x\| x * 2)` |
| map_or_else | `map_or_else<U, D, F>(self, default: D, f: F) -> U` | è½¬æ¢æˆ–é”™è¯¯å¤„ç† | `result.map_or_else(\|e\| 0, \|x\| x * 2)` |
| and | `and<U>(self, res: Result<U, E>) -> Result<U, E>` | é€»è¾‘ä¸ | `result.and(result2)` |
| and_then | `and_then<U, F>(self, op: F) -> Result<U, E>` | é“¾å¼Result | `result.and_then(\|x\| Ok(x * 2))` |
| or | `or<F>(self, res: Result<T, F>) -> Result<T, F>` | é€»è¾‘æˆ– | `result.or(result2)` |
| or_else | `or_else<F, O>(self, op: O) -> Result<T, F>` | é”™è¯¯æ¢å¤ | `result.or_else(\|e\| Ok(0))` |

**ç¤ºä¾‹**:

```rust
fn main() {
    let ok: Result<i32, &str> = Ok(42);
    let err: Result<i32, &str> = Err("error");
    
    // æ£€æŸ¥
    assert!(ok.is_ok());
    assert!(err.is_err());
    
    // è§£åŒ…
    assert_eq!(ok.unwrap(), 42);
    assert_eq!(err.unwrap_or(0), 0);
    
    // è½¬æ¢
    let doubled = ok.map(|x| x * 2);
    assert_eq!(doubled, Ok(84));
    
    let formatted = err.map_err(|e| format!("Error: {}", e));
    assert_eq!(formatted, Err("Error: error".to_string()));
    
    // é“¾å¼æ“ä½œ
    let result = ok
        .and_then(|x| Ok(x * 2))
        .map(|x| x + 1);
    assert_eq!(result, Ok(85));
}
```

---

## 3. Error trait

**å®šä¹‰**:

```rust
pub trait Error: Debug + Display {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
    
    fn description(&self) -> &str {
        "description() is deprecated; use Display"
    }
    
    fn cause(&self) -> Option<&dyn Error> {
        self.source()
    }
}
```

**å®ç°ç¤ºä¾‹**:

```rust
use std::fmt;
use std::error::Error;

#[derive(Debug)]
struct MyError {
    details: String,
}

impl MyError {
    fn new(msg: &str) -> MyError {
        MyError {
            details: msg.to_string(),
        }
    }
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.details)
    }
}

impl Error for MyError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
}

fn main() {
    let error = MyError::new("something went wrong");
    println!("Error: {}", error);
    println!("Debug: {:?}", error);
}
```

---

## 4. ?æ“ä½œç¬¦

**è¯­æ³•**:

```rust
expression?
```

**ç­‰ä»·è½¬æ¢**:

```rust
// Option<T>
match option {
    Some(value) => value,
    None => return None,
}

// Result<T, E>
match result {
    Ok(value) => value,
    Err(err) => return Err(From::from(err)),
}
```

**ä½¿ç”¨è§„åˆ™**:

```rust
fn main() {
    // 1. åªèƒ½åœ¨è¿”å›Resultæˆ–Optionçš„å‡½æ•°ä¸­ä½¿ç”¨
    fn process() -> Result<i32, String> {
        let value = Some(42)?;  // é”™è¯¯ï¼šè¿”å›ç±»å‹ä¸åŒ¹é…
        Ok(value)
    }
    
    // 2. è‡ªåŠ¨è¿›è¡ŒFromè½¬æ¢
    fn parse_number(s: &str) -> Result<i32, String> {
        let num: i32 = s.parse()?;  // ParseIntErrorè‡ªåŠ¨è½¬ä¸ºString
        Ok(num)
    }
    
    // 3. é“¾å¼ä½¿ç”¨
    fn complex_operation() -> Result<i32, String> {
        let result = operation1()?;
        let result = operation2(result)?;
        let result = operation3(result)?;
        Ok(result)
    }
    
    fn operation1() -> Result<i32, String> { Ok(1) }
    fn operation2(x: i32) -> Result<i32, String> { Ok(x * 2) }
    fn operation3(x: i32) -> Result<i32, String> { Ok(x + 1) }
    
    let _ = complex_operation();
}
```

---

## 5. panicæœºåˆ¶

**panic!å®**:

```rust
// åŸºæœ¬ç”¨æ³•
panic!("crash and burn");

// æ ¼å¼åŒ–æ¶ˆæ¯
panic!("value = {}", 42);

// æ¡ä»¶panic
assert!(condition, "assertion failed");
assert_eq!(left, right, "values not equal");
assert_ne!(left, right, "values equal");
```

**panicé’©å­**:

```rust
use std::panic;

fn main() {
    // è®¾ç½®panic hook
    panic::set_hook(Box::new(|panic_info| {
        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            println!("panic occurred: {}", s);
        }
    }));
    
    // æ•è·panic
    let result = panic::catch_unwind(|| {
        // å¯èƒ½panicçš„ä»£ç 
        println!("running");
        42
    });
    
    match result {
        Ok(value) => println!("Success: {}", value),
        Err(_) => println!("Panic caught"),
    }
}
```

**unwrapå®¶æ—**:

| æ–¹æ³• | è¡Œä¸º | ä½¿ç”¨åœºæ™¯ |
|------|------|---------|
| unwrap() | Err/Noneæ—¶panic | ç¡®ä¿¡ä¸ä¼šå¤±è´¥ |
| expect(msg) | Err/Noneæ—¶panicå¸¦æ¶ˆæ¯ | æ·»åŠ ä¸Šä¸‹æ–‡ |
| unwrap_or(default) | æä¾›é»˜è®¤å€¼ | æœ‰åˆç†é»˜è®¤å€¼ |
| unwrap_or_else(f) | è®¡ç®—é»˜è®¤å€¼ | é»˜è®¤å€¼è®¡ç®—æ˜‚è´µ |
| unwrap_or_default() | ä½¿ç”¨Default | æœ‰Defaultå®ç° |
| unwrap_err() | Okæ—¶panic | æœŸæœ›é”™è¯¯ |
| unwrap_unchecked() | æœªæ£€æŸ¥çš„è§£åŒ…ï¼ˆunsafeï¼‰ | æ€§èƒ½å…³é”®ä¸”ç¡®ä¿¡å®‰å…¨ |

---

## 6. From/Intoè½¬æ¢

**From trait**:

```rust
pub trait From<T> {
    fn from(T) -> Self;
}
```

**é”™è¯¯è½¬æ¢**:

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

// è‡ªåŠ¨è½¬æ¢io::Error
impl From<io::Error> for MyError {
    fn from(error: io::Error) -> Self {
        MyError::Io(error)
    }
}

// è‡ªåŠ¨è½¬æ¢ParseIntError
impl From<ParseIntError> for MyError {
    fn from(error: ParseIntError) -> Self {
        MyError::Parse(error)
    }
}

fn process() -> Result<i32, MyError> {
    let content = std::fs::read_to_string("file.txt")?;  // io::Error -> MyError
    let number = content.trim().parse()?;  // ParseIntError -> MyError
    Ok(number)
}

fn main() {
    match process() {
        Ok(num) => println!("Number: {}", num),
        Err(e) => println!("Error: {:?}", e),
    }
}
```

---

**å®Œæ•´æ–¹æ³•å¯¹æ¯”è¡¨**:

### Option vs Result

| æ“ä½œ | Option | Result |
|------|--------|--------|
| æˆåŠŸå€¼ | Some(T) | Ok(T) |
| å¤±è´¥å€¼ | None | Err(E) |
| æ£€æŸ¥æˆåŠŸ | is_some() | is_ok() |
| æ£€æŸ¥å¤±è´¥ | is_none() | is_err() |
| è§£åŒ… | unwrap() | unwrap() |
| å¸¦æ¶ˆæ¯è§£åŒ… | expect() | expect() |
| é»˜è®¤å€¼ | unwrap_or() | unwrap_or() |
| è½¬æ¢ | map() | map() |
| é”™è¯¯è½¬æ¢ | - | map_err() |
| é“¾å¼æ“ä½œ | and_then() | and_then() |
| é”™è¯¯æ¢å¤ | or_else() | or_else() |
| è½¬ä¸ºResult | ok_or() | - |
| è½¬ä¸ºOption | - | ok() |

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ“š å®Œæ•´çš„Rusté”™è¯¯å¤„ç†å‚è€ƒ** ğŸ¦€âœ¨
