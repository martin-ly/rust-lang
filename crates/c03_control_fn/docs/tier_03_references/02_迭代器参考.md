# 3.2 è¿­ä»£å™¨å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: Rustè¿­ä»£å™¨å®Œæ•´APIå‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æŸ¥é˜…è¿­ä»£å™¨è¯¦ç»†ç”¨æ³•çš„å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [å¾ªç¯ç»“æ„æŒ‡å—](../tier_02_guides/02_å¾ªç¯ç»“æ„æŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [3.2 è¿­ä»£å™¨å‚è€ƒ](#32-è¿­ä»£å™¨å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Iterator trait](#1-iterator-trait)
  - [2. é€‚é…å™¨æ–¹æ³•](#2-é€‚é…å™¨æ–¹æ³•)
  - [3. æ¶ˆè´¹è€…æ–¹æ³•](#3-æ¶ˆè´¹è€…æ–¹æ³•)
  - [4. IntoIterator trait](#4-intoiterator-trait)
  - [5. è‡ªå®šä¹‰è¿­ä»£å™¨](#5-è‡ªå®šä¹‰è¿­ä»£å™¨)
  - [6. æ€§èƒ½ç‰¹æ€§](#6-æ€§èƒ½ç‰¹æ€§)
  - [7. å®Œæ•´æ–¹æ³•åˆ—è¡¨](#7-å®Œæ•´æ–¹æ³•åˆ—è¡¨)
    - [é€‚é…å™¨æ–¹æ³•ï¼ˆè¿”å›æ–°è¿­ä»£å™¨ï¼‰](#é€‚é…å™¨æ–¹æ³•è¿”å›æ–°è¿­ä»£å™¨)
    - [æ¶ˆè´¹è€…æ–¹æ³•ï¼ˆæ¶ˆè€—è¿­ä»£å™¨ï¼‰](#æ¶ˆè´¹è€…æ–¹æ³•æ¶ˆè€—è¿­ä»£å™¨)

---

## 1. Iterator trait

**å®šä¹‰**:

```rust
pub trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
    
    // æä¾›çš„æ–¹æ³•ï¼ˆçº¦75ä¸ªï¼‰
    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
    fn count(self) -> usize where Self: Sized { ... }
    fn last(self) -> Option<Self::Item> where Self: Sized { ... }
    fn nth(&mut self, n: usize) -> Option<Self::Item> { ... }
    // ... æ›´å¤šæ–¹æ³•
}
```

**æ ¸å¿ƒæ–¹æ³•**:

```rust
fn main() {
    // next: å”¯ä¸€å¿…éœ€å®ç°çš„æ–¹æ³•
    let mut iter = vec![1, 2, 3].into_iter();
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), None);
    
    // size_hint: è¿”å›(ä¸‹ç•Œ, ä¸Šç•Œ)
    let iter = vec![1, 2, 3].into_iter();
    assert_eq!(iter.size_hint(), (3, Some(3)));
}
```

---

## 2. é€‚é…å™¨æ–¹æ³•

**è½¬æ¢é€‚é…å™¨**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // map: è½¬æ¢å…ƒç´ 
    let doubled: Vec<_> = vec.iter().map(|x| x * 2).collect();
    assert_eq!(doubled, vec![2, 4, 6, 8, 10]);
    
    // filter: è¿‡æ»¤å…ƒç´ 
    let even: Vec<_> = vec.iter().filter(|&&x| x % 2 == 0).collect();
    assert_eq!(even, vec![&2, &4]);
    
    // filter_map: ç»„åˆfilterå’Œmap
    let result: Vec<_> = vec.iter()
        .filter_map(|&x| {
            if x % 2 == 0 {
                Some(x * 2)
            } else {
                None
            }
        })
        .collect();
    assert_eq!(result, vec![4, 8]);
    
    // flat_map: å±•å¹³åµŒå¥—
    let result: Vec<_> = vec.iter()
        .flat_map(|&x| vec![x, x * 2])
        .collect();
    assert_eq!(result, vec![1, 2, 2, 4, 3, 6, 4, 8, 5, 10]);
    
    // flatten: å±•å¹³ä¸€å±‚
    let nested = vec![vec![1, 2], vec![3, 4]];
    let flat: Vec<_> = nested.into_iter().flatten().collect();
    assert_eq!(flat, vec![1, 2, 3, 4]);
}
```

**é€‰æ‹©é€‚é…å™¨**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // take: å–å‰nä¸ª
    let first_three: Vec<_> = vec.iter().take(3).collect();
    assert_eq!(first_three, vec![&1, &2, &3]);
    
    // skip: è·³è¿‡å‰nä¸ª
    let skip_two: Vec<_> = vec.iter().skip(2).collect();
    assert_eq!(skip_two, vec![&3, &4, &5]);
    
    // take_while: å–æ»¡è¶³æ¡ä»¶çš„å‰ç¼€
    let result: Vec<_> = vec.iter().take_while(|&&x| x < 4).collect();
    assert_eq!(result, vec![&1, &2, &3]);
    
    // skip_while: è·³è¿‡æ»¡è¶³æ¡ä»¶çš„å‰ç¼€
    let result: Vec<_> = vec.iter().skip_while(|&&x| x < 3).collect();
    assert_eq!(result, vec![&3, &4, &5]);
    
    // step_by: æŒ‰æ­¥é•¿è¿­ä»£
    let result: Vec<_> = vec.iter().step_by(2).collect();
    assert_eq!(result, vec![&1, &3, &5]);
}
```

**ç»„åˆé€‚é…å™¨**:

```rust
fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];
    
    // chain: è¿æ¥è¿­ä»£å™¨
    let result: Vec<_> = vec1.iter().chain(vec2.iter()).collect();
    assert_eq!(result, vec![&1, &2, &3, &4, &5, &6]);
    
    // zip: ç»„åˆä¸¤ä¸ªè¿­ä»£å™¨
    let result: Vec<_> = vec1.iter().zip(vec2.iter()).collect();
    assert_eq!(result, vec![(&1, &4), (&2, &5), (&3, &6)]);
    
    // enumerate: æ·»åŠ ç´¢å¼•
    let result: Vec<_> = vec1.iter().enumerate().collect();
    assert_eq!(result, vec![(0, &1), (1, &2), (2, &3)]);
}
```

**æ£€æŸ¥é€‚é…å™¨**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // inspect: è§‚å¯Ÿå…ƒç´ ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    let result: Vec<_> = vec.iter()
        .inspect(|x| println!("before: {}", x))
        .map(|x| x * 2)
        .inspect(|x| println!("after: {}", x))
        .collect();
    
    // peekable: å…è®¸é¢„è§ˆä¸‹ä¸€ä¸ªå…ƒç´ 
    let mut iter = vec.iter().peekable();
    assert_eq!(iter.peek(), Some(&&1));
    assert_eq!(iter.next(), Some(&1));
    assert_eq!(iter.peek(), Some(&&2));
}
```

---

## 3. æ¶ˆè´¹è€…æ–¹æ³•

**æ”¶é›†æ–¹æ³•**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // collect: æ”¶é›†åˆ°é›†åˆ
    let doubled: Vec<_> = vec.iter().map(|x| x * 2).collect();
    
    // partition: åˆ†ç»„
    let (even, odd): (Vec<_>, Vec<_>) = vec.iter()
        .partition(|&&x| x % 2 == 0);
    assert_eq!(even, vec![&2, &4]);
    assert_eq!(odd, vec![&1, &3, &5]);
    
    // unzip: æ‹†åˆ†å…ƒç»„
    let pairs = vec![(1, 2), (3, 4), (5, 6)];
    let (left, right): (Vec<_>, Vec<_>) = pairs.into_iter().unzip();
    assert_eq!(left, vec![1, 3, 5]);
    assert_eq!(right, vec![2, 4, 6]);
}
```

**èšåˆæ–¹æ³•**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // fold: å·¦æŠ˜å 
    let sum = vec.iter().fold(0, |acc, &x| acc + x);
    assert_eq!(sum, 15);
    
    // reduce: ä¸foldç±»ä¼¼ï¼Œä½†è¿”å›Option
    let sum = vec.iter().copied().reduce(|acc, x| acc + x);
    assert_eq!(sum, Some(15));
    
    // scan: æœ‰çŠ¶æ€çš„map
    let running_sum: Vec<_> = vec.iter()
        .scan(0, |state, &x| {
            *state += x;
            Some(*state)
        })
        .collect();
    assert_eq!(running_sum, vec![1, 3, 6, 10, 15]);
    
    // sum: æ±‚å’Œ
    let sum: i32 = vec.iter().sum();
    assert_eq!(sum, 15);
    
    // product: æ±‚ç§¯
    let product: i32 = vec.iter().product();
    assert_eq!(product, 120);
}
```

**æŸ¥æ‰¾æ–¹æ³•**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // find: æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
    let result = vec.iter().find(|&&x| x > 3);
    assert_eq!(result, Some(&4));
    
    // position: æŸ¥æ‰¾ä½ç½®
    let pos = vec.iter().position(|&x| x == 3);
    assert_eq!(pos, Some(2));
    
    // rposition: ä»å³æŸ¥æ‰¾ä½ç½®
    let pos = vec.iter().rposition(|&x| x % 2 == 0);
    assert_eq!(pos, Some(3));  // æœ€åä¸€ä¸ªå¶æ•°çš„ä½ç½®
    
    // max/min: æœ€å¤§æœ€å°å€¼
    let max = vec.iter().max();
    assert_eq!(max, Some(&5));
    
    let min = vec.iter().min();
    assert_eq!(min, Some(&1));
    
    // max_by/min_by: è‡ªå®šä¹‰æ¯”è¾ƒ
    let max = vec.iter().max_by(|a, b| a.cmp(b));
    assert_eq!(max, Some(&5));
}
```

**å¸ƒå°”æ–¹æ³•**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // all: æ‰€æœ‰å…ƒç´ æ»¡è¶³æ¡ä»¶
    assert!(vec.iter().all(|&x| x > 0));
    assert!(!vec.iter().all(|&x| x > 3));
    
    // any: è‡³å°‘ä¸€ä¸ªå…ƒç´ æ»¡è¶³æ¡ä»¶
    assert!(vec.iter().any(|&x| x > 4));
    assert!(!vec.iter().any(|&x| x > 10));
    
    // none: æ²¡æœ‰å…ƒç´ æ»¡è¶³æ¡ä»¶
    assert!(vec.iter().none(|&x| x > 10));
    assert!(!vec.iter().none(|&x| x > 4));
}
```

**è®¡æ•°æ–¹æ³•**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // count: å…ƒç´ æ•°é‡
    let count = vec.iter().count();
    assert_eq!(count, 5);
    
    // nth: ç¬¬nä¸ªå…ƒç´ 
    let mut iter = vec.iter();
    assert_eq!(iter.nth(2), Some(&3));
    
    // last: æœ€åä¸€ä¸ªå…ƒç´ 
    let last = vec.iter().last();
    assert_eq!(last, Some(&5));
}
```

---

## 4. IntoIterator trait

**å®šä¹‰**:

```rust
pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator<Item = Self::Item>;
    
    fn into_iter(self) -> Self::IntoIter;
}
```

**å®ç°**:

```rust
fn main() {
    let vec = vec![1, 2, 3];
    
    // Vec<T> å®ç°äº†ä¸‰ç§IntoIterator
    
    // 1. into_iter() - è·å–æ‰€æœ‰æƒ
    for item in vec.clone() {
        println!("{}", item);  // item: i32
    }
    
    // 2. &Vec<T>.into_iter() - ä¸å¯å˜å€Ÿç”¨
    for item in &vec {
        println!("{}", item);  // item: &i32
    }
    
    // 3. &mut Vec<T>.into_iter() - å¯å˜å€Ÿç”¨
    let mut vec = vec.clone();
    for item in &mut vec {
        *item *= 2;  // item: &mut i32
    }
    
    println!("{:?}", vec);
}
```

---

## 5. è‡ªå®šä¹‰è¿­ä»£å™¨

**åŸºæœ¬å®ç°**:

```rust
struct Counter {
    count: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Self {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
    
    // å¯é€‰ï¼šæä¾›size_hintæå‡æ€§èƒ½
    fn size_hint(&self) -> (usize, Option<usize>) {
        let remaining = self.max - self.count;
        (remaining, Some(remaining))
    }
}

fn main() {
    let counter = Counter::new(5);
    let result: Vec<_> = counter.collect();
    assert_eq!(result, vec![1, 2, 3, 4, 5]);
}
```

**å®ç°ExactSizeIterator**:

```rust
impl ExactSizeIterator for Counter {
    fn len(&self) -> usize {
        self.max - self.count
    }
}

fn main() {
    let counter = Counter::new(5);
    assert_eq!(counter.len(), 5);
}
```

**å®ç°DoubleEndedIterator**:

```rust
struct Range {
    start: i32,
    end: i32,
}

impl Iterator for Range {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.start < self.end {
            let result = self.start;
            self.start += 1;
            Some(result)
        } else {
            None
        }
    }
}

impl DoubleEndedIterator for Range {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.start < self.end {
            self.end -= 1;
            Some(self.end)
        } else {
            None
        }
    }
}

fn main() {
    let mut range = Range { start: 0, end: 5 };
    assert_eq!(range.next(), Some(0));
    assert_eq!(range.next_back(), Some(4));
    assert_eq!(range.next(), Some(1));
    assert_eq!(range.next_back(), Some(3));
}
```

---

## 6. æ€§èƒ½ç‰¹æ€§

**é›¶æˆæœ¬æŠ½è±¡**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // è¿­ä»£å™¨ç‰ˆæœ¬
    let sum: i32 = vec.iter().map(|x| x * 2).sum();
    
    // æ‰‹å†™å¾ªç¯ç‰ˆæœ¬
    let mut sum2 = 0;
    for &x in &vec {
        sum2 += x * 2;
    }
    
    // ç¼–è¯‘åç”Ÿæˆç›¸åŒçš„æœºå™¨ç 
    assert_eq!(sum, sum2);
}
```

**å»¶è¿Ÿæ±‚å€¼**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // è¿­ä»£å™¨é“¾ä¸ä¼šç«‹å³æ‰§è¡Œ
    let iter = vec.iter()
        .map(|x| {
            println!("map: {}", x);
            x * 2
        })
        .filter(|x| {
            println!("filter: {}", x);
            x > &5
        });
    
    println!("è¿­ä»£å™¨åˆ›å»ºå®Œæˆ");
    
    // åªæœ‰åœ¨collectæ—¶æ‰æ‰§è¡Œ
    let result: Vec<_> = iter.collect();
    
    println!("result: {:?}", result);
}
```

**èåˆä¼˜åŒ–**:

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    
    // å¤šä¸ªé€‚é…å™¨ä¼šè¢«èåˆä¸ºå•æ¬¡è¿­ä»£
    let result: Vec<_> = vec.iter()
        .map(|x| x * 2)      // èåˆ
        .filter(|x| x > &5)  // èåˆ
        .map(|x| x + 1)      // èåˆ
        .collect();          // å•æ¬¡è¿­ä»£å®Œæˆæ‰€æœ‰æ“ä½œ
    
    assert_eq!(result, vec![7, 9, 11]);
}
```

---

## 7. å®Œæ•´æ–¹æ³•åˆ—è¡¨

### é€‚é…å™¨æ–¹æ³•ï¼ˆè¿”å›æ–°è¿­ä»£å™¨ï¼‰

| æ–¹æ³• | ç­¾å | æè¿° | ç¤ºä¾‹ |
|------|------|------|------|
| map | `map<B, F>(self, f: F) -> Map<Self, F>` | è½¬æ¢å…ƒç´  | `iter.map(\|x\| x * 2)` |
| filter | `filter<P>(self, predicate: P) -> Filter<Self, P>` | è¿‡æ»¤å…ƒç´  | `iter.filter(\|x\| x > 0)` |
| filter_map | `filter_map<B, F>(self, f: F) -> FilterMap<Self, F>` | è¿‡æ»¤å¹¶è½¬æ¢ | `iter.filter_map(\|x\| Some(x))` |
| enumerate | `enumerate(self) -> Enumerate<Self>` | æ·»åŠ ç´¢å¼• | `iter.enumerate()` |
| peekable | `peekable(self) -> Peekable<Self>` | å…è®¸é¢„è§ˆ | `iter.peekable()` |
| skip | `skip(self, n: usize) -> Skip<Self>` | è·³è¿‡nä¸ª | `iter.skip(2)` |
| take | `take(self, n: usize) -> Take<Self>` | å–å‰nä¸ª | `iter.take(3)` |
| chain | `chain<U>(self, other: U) -> Chain<Self, U::IntoIter>` | è¿æ¥è¿­ä»£å™¨ | `iter1.chain(iter2)` |
| zip | `zip<U>(self, other: U) -> Zip<Self, U::IntoIter>` | ç»„åˆè¿­ä»£å™¨ | `iter1.zip(iter2)` |
| flat_map | `flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>` | æ˜ å°„å¹¶å±•å¹³ | `iter.flat_map(\|x\| vec[x])` |
| flatten | `flatten(self) -> Flatten<Self>` | å±•å¹³ä¸€å±‚ | `iter.flatten()` |
| fuse | `fuse(self) -> Fuse<Self>` | ç»ˆæ­¢åæ°¸è¿œè¿”å›None | `iter.fuse()` |
| inspect | `inspect<F>(self, f: F) -> Inspect<Self, F>` | è§‚å¯Ÿå…ƒç´  | `iter.inspect(\|x\| println!("{}", x))` |
| by_ref | `by_ref(&mut self) -> &mut Self` | å€Ÿç”¨è¿­ä»£å™¨ | `iter.by_ref()` |
| rev | `rev(self) -> Rev<Self>` | åå‘è¿­ä»£ | `iter.rev()` |
| step_by | `step_by(self, step: usize) -> StepBy<Self>` | æ­¥é•¿è¿­ä»£ | `iter.step_by(2)` |
| take_while | `take_while<P>(self, predicate: P) -> TakeWhile<Self, P>` | å–å‰ç¼€ | `iter.take_while(\|x\| x < 5)` |
| skip_while | `skip_while<P>(self, predicate: P) -> SkipWhile<Self, P>` | è·³è¿‡å‰ç¼€ | `iter.skip_while(\|x\| x < 3)` |
| map_while | `map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>` | æ˜ å°„ç›´åˆ°None | `iter.map_while(\|x\| Some(x))` |
| cycle | `cycle(self) -> Cycle<Self>` | å¾ªç¯è¿­ä»£ | `iter.cycle()` |
| scan | `scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>` | æœ‰çŠ¶æ€æ˜ å°„ | `iter.scan(0, \|st, x\| ...)` |

### æ¶ˆè´¹è€…æ–¹æ³•ï¼ˆæ¶ˆè€—è¿­ä»£å™¨ï¼‰

| æ–¹æ³• | ç­¾å | æè¿° | ç¤ºä¾‹ |
|------|------|------|------|
| collect | `collect<B: FromIterator<Self::Item>>(self) -> B` | æ”¶é›†åˆ°é›†åˆ | `iter.collect::<Vec<_>>()` |
| count | `count(self) -> usize` | è®¡æ•° | `iter.count()` |
| last | `last(self) -> Option<Self::Item>` | æœ€åä¸€ä¸ªå…ƒç´  | `iter.last()` |
| nth | `nth(&mut self, n: usize) -> Option<Self::Item>` | ç¬¬nä¸ªå…ƒç´  | `iter.nth(2)` |
| fold | `fold<B, F>(self, init: B, f: F) -> B` | æŠ˜å  | `iter.fold(0, \|a, x\| a + x)` |
| reduce | `reduce<F>(self, f: F) -> Option<Self::Item>` | å½’çº¦ | `iter.reduce(\|a, x\| a + x)` |
| all | `all<F>(self, f: F) -> bool` | å…¨éƒ¨æ»¡è¶³ | `iter.all(\|x\| x > 0)` |
| any | `any<F>(self, f: F) -> bool` | è‡³å°‘ä¸€ä¸ªæ»¡è¶³ | `iter.any(\|x\| x > 5)` |
| find | `find<P>(self, predicate: P) -> Option<Self::Item>` | æŸ¥æ‰¾å…ƒç´  | `iter.find(\|x\| x > 3)` |
| position | `position<P>(self, predicate: P) -> Option<usize>` | æŸ¥æ‰¾ä½ç½® | `iter.position(\|x\| x == 5)` |
| max | `max(self) -> Option<Self::Item>` | æœ€å¤§å€¼ | `iter.max()` |
| min | `min(self) -> Option<Self::Item>` | æœ€å°å€¼ | `iter.min()` |
| sum | `sum<S>(self) -> S` | æ±‚å’Œ | `iter.sum::<i32>()` |
| product | `product<P>(self) -> P` | æ±‚ç§¯ | `iter.product::<i32>()` |
| partition | `partition<B, F>(self, f: F) -> (B, B)` | åˆ†ç»„ | `iter.partition(\|x\| x % 2 == 0)` |
| for_each | `for_each<F>(self, f: F)` | éå†æ‰§è¡Œ | `iter.for_each(\|x\| println!("{}", x))` |

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ“š å®Œæ•´çš„Rustè¿­ä»£å™¨APIå‚è€ƒ** ğŸ¦€âœ¨
