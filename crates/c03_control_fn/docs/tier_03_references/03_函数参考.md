# 3.3 函数参考

> **文档类型**: Tier 3 - 参考层
> **文档定位**: Rust函数完整语法参考
> **适用对象**: 需要查阅函数详细规则的开发者
> **相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [函数系统指南](../tier_02_guides/03_函数系统指南.md)

**最后更新**: 2025-12-11
**适用版本**: Rust 1.92.0+
**文档版本**: v2025.1.0

---

## 📋 目录

- [3.3 函数参考](#33-函数参考)
  - [📋 目录](#-目录)
  - [📐 知识结构](#-知识结构)
  - [1. 函数语法](#1-函数语法)
  - [2. 参数传递](#2-参数传递)
  - [3. 返回值](#3-返回值)
  - [4. 泛型函数](#4-泛型函数)
  - [5. 异步函数](#5-异步函数)
  - [6. 函数指针](#6-函数指针)
  - [7. 方法语法](#7-方法语法)

---

## 1. 函数语法

**完整语法**:

```bnf
function :=
    function_qualifiers "fn" IDENTIFIER generic_params?
    "(" function_parameters? ")" function_return_type? where_clause?
    block_expression

function_qualifiers :=
    "const"? "async"? "unsafe"? ("extern" abi?)?

generic_params :=
    "<" generic_param ("," generic_param)* ","? ">"

function_parameters :=
    self_parameter ("," parameter)*
    | parameter ("," parameter)*

function_return_type :=
    "->" type
```

**示例**:

```rust
// 基本函数
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// 泛型函数
fn identity<T>(value: T) -> T {
    value
}

// 带约束的泛型
fn print_it<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

// const函数
const fn const_add(a: i32, b: i32) -> i32 {
    a + b
}

// unsafe函数
unsafe fn unsafe_operation() {
    // 不安全操作
}

// extern函数
extern "C" fn c_compatible() {
    // C兼容函数
}

// 异步函数
async fn async_operation() -> i32 {
    42
}

fn main() {
    println!("{}", add(3, 4));
    println!("{}", identity(42));
    print_it("hello");
    const RESULT: i32 = const_add(2, 3);
    println!("{}", RESULT);
}
```

---

## 2. 参数传递

**所有权规则**:

```rust
// 1. 按值传递（获取所有权）
fn take_ownership(s: String) {
    println!("{}", s);
}  // s在此被drop

// 2. 不可变引用
fn borrow(s: &String) {
    println!("{}", s);
}  // s不被drop

// 3. 可变引用
fn borrow_mut(s: &mut String) {
    s.push_str(" world");
}

// 4. Copy类型
fn use_number(n: i32) {
    println!("{}", n);
}  // i32是Copy，不影响原值

fn main() {
    let s1 = String::from("hello");
    take_ownership(s1);
    // s1不可再用

    let s2 = String::from("hello");
    borrow(&s2);
    println!("{}", s2);  // s2仍可用

    let mut s3 = String::from("hello");
    borrow_mut(&mut s3);
    println!("{}", s3);

    let n = 42;
    use_number(n);
    println!("{}", n);  // n仍可用
}
```

**参数模式**:

```rust
// 元组解构
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("x: {}, y: {}", x, y);
}

// 结构体解构
struct Point {
    x: i32,
    y: i32,
}

fn print_point(Point { x, y }: Point) {
    println!("({}, {})", x, y);
}

// 忽略参数
fn ignore_arg(_: i32) {
    // 不使用参数
}

// 可变参数数量（使用切片）
fn sum(numbers: &[i32]) -> i32 {
    numbers.iter().sum()
}

fn main() {
    print_coordinates(&(3, 5));
    print_point(Point { x: 10, y: 20 });
    ignore_arg(42);
    println!("{}", sum(&[1, 2, 3, 4, 5]));
}
```

---

## 3. 返回值

**返回类型**:

```rust
// 1. 具体类型
fn get_number() -> i32 {
    42
}

// 2. 元组
fn get_pair() -> (i32, i32) {
    (1, 2)
}

// 3. Option
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

// 4. Result
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse()
}

// 5. impl Trait
fn get_iterator() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}

// 6. Box<dyn Trait>
fn get_display() -> Box<dyn std::fmt::Display> {
    Box::new(42)
}

// 7. 无返回值（unit类型）
fn print_message(msg: &str) {
    println!("{}", msg);
}  // 隐式返回()

// 8. 永不返回（never类型）
fn diverge() -> ! {
    panic!("This function never returns")
}

fn main() {
    println!("{}", get_number());
    println!("{:?}", get_pair());
    println!("{:?}", divide(10, 2));
    println!("{:?}", parse_number("42"));
    for i in get_iterator() {
        println!("{}", i);
    }
    println!("{}", get_display());
    print_message("hello");
}
```

**提前返回**:

```rust
fn process(value: Option<i32>) -> i32 {
    // 使用return提前返回
    if let None = value {
        return 0;
    }

    value.unwrap() * 2
}

fn validate(n: i32) -> Result<i32, String> {
    // 多个提前返回
    if n < 0 {
        return Err("负数".to_string());
    }

    if n == 0 {
        return Err("零".to_string());
    }

    Ok(n)
}

fn main() {
    println!("{}", process(Some(21)));
    println!("{}", process(None));
    println!("{:?}", validate(5));
}
```

---

## 4. 泛型函数

**类型参数**:

```rust
// 单个类型参数
fn identity<T>(value: T) -> T {
    value
}

// 多个类型参数
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// 类型推断
fn main() {
    let num = identity(42);        // T = i32
    let text = identity("hello");  // T = &str
    let p = pair(1, "one");        // T = i32, U = &str

    println!("{}", num);
    println!("{}", text);
    println!("{:?}", p);
}
```

**trait约束**:

```rust
use std::fmt::Display;

// 单个约束
fn print_it<T: Display>(value: T) {
    println!("{}", value);
}

// 多个约束
fn compare<T: Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} > {}", a, b);
    } else {
        println!("{} <= {}", a, b);
    }
}

// where子句
fn complex<T, U>(t: T, u: U)
where
    T: Display + Clone,
    U: Display + Clone,
{
    println!("t: {}, u: {}", t, u);
}

fn main() {
    print_it(42);
    compare(10, 20);
    complex("hello", 42);
}
```

**关联类型**:

```rust
trait Container {
    type Item;
    fn get(&self) -> Option<&Self::Item>;
}

struct IntContainer {
    value: i32,
}

impl Container for IntContainer {
    type Item = i32;

    fn get(&self) -> Option<&Self::Item> {
        Some(&self.value)
    }
}

fn process_container<C: Container>(container: &C)
where
    C::Item: std::fmt::Display,
{
    if let Some(item) = container.get() {
        println!("Item: {}", item);
    }
}

fn main() {
    let container = IntContainer { value: 42 };
    process_container(&container);
}
```

---

## 5. 异步函数

**基本语法**:

```rust
// 异步函数定义
async fn fetch_data() -> Result<String, String> {
    // 模拟异步操作
    Ok("data".to_string())
}

// 调用异步函数
async fn process() {
    match fetch_data().await {
        Ok(data) => println!("数据: {}", data),
        Err(e) => println!("错误: {}", e),
    }
}

// 异步函数返回Future
fn example() -> impl std::future::Future<Output = i32> {
    async { 42 }
}

fn main() {
    // 需要运行时执行
    println!("异步函数需要运行时支持");
}
```

**异步trait方法**:

```rust
trait AsyncProcessor {
    // 异步方法
    async fn process(&self) -> Result<(), String> {
        Ok(())
    }
}

struct MyProcessor;

impl AsyncProcessor for MyProcessor {
    async fn process(&self) -> Result<(), String> {
        println!("处理中...");
        Ok(())
    }
}

fn main() {
    println!("异步trait方法示例");
}
```

---

## 6. 函数指针

**fn类型**:

```rust
// 函数指针类型
type BinaryOp = fn(i32, i32) -> i32;

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

// 接受函数指针
fn apply_op(a: i32, b: i32, op: BinaryOp) -> i32 {
    op(a, b)
}

// 返回函数指针
fn get_operation(op_type: &str) -> BinaryOp {
    match op_type {
        "add" => add,
        "mul" => multiply,
        _ => add,
    }
}

fn main() {
    println!("{}", apply_op(3, 4, add));
    println!("{}", apply_op(3, 4, multiply));

    let op = get_operation("add");
    println!("{}", op(5, 6));
}
```

**fn vs Fn trait**:

```rust
fn main() {
    // fn类型：只能是函数
    let f1: fn(i32) -> i32 = |x| x * 2;  // OK：无捕获的闭包

    let y = 10;
    // let f2: fn(i32) -> i32 = |x| x + y;  // 错误：捕获了y

    // Fn trait：可以是闭包
    fn call_fn<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {
        f(x)
    }

    println!("{}", call_fn(|x| x * 2, 5));
    println!("{}", call_fn(|x| x + y, 5));  // OK
}
```

---

## 7. 方法语法

**self参数**:

```rust
struct Counter {
    count: u32,
}

impl Counter {
    // 1. 关联函数（无self）
    fn new() -> Self {
        Counter { count: 0 }
    }

    // 2. 不可变引用self
    fn get(&self) -> u32 {
        self.count
    }

    // 3. 可变引用self
    fn increment(&mut self) {
        self.count += 1;
    }

    // 4. 获取所有权self
    fn consume(self) -> u32 {
        self.count
    }

    // 5. Box<Self>
    fn boxed(self: Box<Self>) -> u32 {
        self.count
    }

    // 6. Rc<Self>
    fn rc(self: std::rc::Rc<Self>) -> u32 {
        self.count
    }
}

fn main() {
    let mut counter = Counter::new();
    println!("{}", counter.get());
    counter.increment();
    println!("{}", counter.get());
    let final_count = counter.consume();
    println!("{}", final_count);
}
```

**方法调用语法**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn distance(&self, other: &Point) -> f64 {
        let dx = (self.x - other.x) as f64;
        let dy = (self.y - other.y) as f64;
        (dx * dx + dy * dy).sqrt()
    }
}

fn main() {
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 3, y: 4 };

    // 方法调用语法
    let dist1 = p1.distance(&p2);

    // 函数调用语法
    let dist2 = Point::distance(&p1, &p2);

    assert_eq!(dist1, dist2);
    println!("距离: {}", dist1);
}
```

---

**最后更新**: 2025-12-11
**文档版本**: v2025.1.0
**相关文档**: [主索引](../tier_01_foundations/02_主索引导航.md) | [README](../../README.md)

---

**📚 完整的Rust函数语法参考** 🦀✨
