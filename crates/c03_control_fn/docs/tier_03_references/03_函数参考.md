# 3.3 å‡½æ•°å‚è€ƒ

> **æ–‡æ¡£ç±»å‹**: Tier 3 - å‚è€ƒå±‚  
> **æ–‡æ¡£å®šä½**: Rustå‡½æ•°å®Œæ•´è¯­æ³•å‚è€ƒ  
> **é€‚ç”¨å¯¹è±¡**: éœ€è¦æŸ¥é˜…å‡½æ•°è¯¦ç»†è§„åˆ™çš„å¼€å‘è€…  
> **ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [å‡½æ•°ç³»ç»ŸæŒ‡å—](../tier_02_guides/03_å‡½æ•°ç³»ç»ŸæŒ‡å—.md)

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0

---

## ğŸ“‹ ç›®å½•

- [3.3 å‡½æ•°å‚è€ƒ](#33-å‡½æ•°å‚è€ƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å‡½æ•°è¯­æ³•](#1-å‡½æ•°è¯­æ³•)
  - [2. å‚æ•°ä¼ é€’](#2-å‚æ•°ä¼ é€’)
  - [3. è¿”å›å€¼](#3-è¿”å›å€¼)
  - [4. æ³›å‹å‡½æ•°](#4-æ³›å‹å‡½æ•°)
  - [5. å¼‚æ­¥å‡½æ•°](#5-å¼‚æ­¥å‡½æ•°)
  - [6. å‡½æ•°æŒ‡é’ˆ](#6-å‡½æ•°æŒ‡é’ˆ)
  - [7. æ–¹æ³•è¯­æ³•](#7-æ–¹æ³•è¯­æ³•)

---

## 1. å‡½æ•°è¯­æ³•

**å®Œæ•´è¯­æ³•**:

```bnf
function :=
    function_qualifiers "fn" IDENTIFIER generic_params?
    "(" function_parameters? ")" function_return_type? where_clause?
    block_expression

function_qualifiers :=
    "const"? "async"? "unsafe"? ("extern" abi?)?

generic_params :=
    "<" generic_param ("," generic_param)* ","? ">"

function_parameters :=
    self_parameter ("," parameter)*
    | parameter ("," parameter)*

function_return_type :=
    "->" type
```

**ç¤ºä¾‹**:

```rust
// åŸºæœ¬å‡½æ•°
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// æ³›å‹å‡½æ•°
fn identity<T>(value: T) -> T {
    value
}

// å¸¦çº¦æŸçš„æ³›å‹
fn print_it<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

// constå‡½æ•°
const fn const_add(a: i32, b: i32) -> i32 {
    a + b
}

// unsafeå‡½æ•°
unsafe fn unsafe_operation() {
    // ä¸å®‰å…¨æ“ä½œ
}

// externå‡½æ•°
extern "C" fn c_compatible() {
    // Cå…¼å®¹å‡½æ•°
}

// å¼‚æ­¥å‡½æ•°
async fn async_operation() -> i32 {
    42
}

fn main() {
    println!("{}", add(3, 4));
    println!("{}", identity(42));
    print_it("hello");
    const RESULT: i32 = const_add(2, 3);
    println!("{}", RESULT);
}
```

---

## 2. å‚æ•°ä¼ é€’

**æ‰€æœ‰æƒè§„åˆ™**:

```rust
// 1. æŒ‰å€¼ä¼ é€’ï¼ˆè·å–æ‰€æœ‰æƒï¼‰
fn take_ownership(s: String) {
    println!("{}", s);
}  // såœ¨æ­¤è¢«drop

// 2. ä¸å¯å˜å¼•ç”¨
fn borrow(s: &String) {
    println!("{}", s);
}  // sä¸è¢«drop

// 3. å¯å˜å¼•ç”¨
fn borrow_mut(s: &mut String) {
    s.push_str(" world");
}

// 4. Copyç±»å‹
fn use_number(n: i32) {
    println!("{}", n);
}  // i32æ˜¯Copyï¼Œä¸å½±å“åŸå€¼

fn main() {
    let s1 = String::from("hello");
    take_ownership(s1);
    // s1ä¸å¯å†ç”¨
    
    let s2 = String::from("hello");
    borrow(&s2);
    println!("{}", s2);  // s2ä»å¯ç”¨
    
    let mut s3 = String::from("hello");
    borrow_mut(&mut s3);
    println!("{}", s3);
    
    let n = 42;
    use_number(n);
    println!("{}", n);  // nä»å¯ç”¨
}
```

**å‚æ•°æ¨¡å¼**:

```rust
// å…ƒç»„è§£æ„
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("x: {}, y: {}", x, y);
}

// ç»“æ„ä½“è§£æ„
struct Point {
    x: i32,
    y: i32,
}

fn print_point(Point { x, y }: Point) {
    println!("({}, {})", x, y);
}

// å¿½ç•¥å‚æ•°
fn ignore_arg(_: i32) {
    // ä¸ä½¿ç”¨å‚æ•°
}

// å¯å˜å‚æ•°æ•°é‡ï¼ˆä½¿ç”¨åˆ‡ç‰‡ï¼‰
fn sum(numbers: &[i32]) -> i32 {
    numbers.iter().sum()
}

fn main() {
    print_coordinates(&(3, 5));
    print_point(Point { x: 10, y: 20 });
    ignore_arg(42);
    println!("{}", sum(&[1, 2, 3, 4, 5]));
}
```

---

## 3. è¿”å›å€¼

**è¿”å›ç±»å‹**:

```rust
// 1. å…·ä½“ç±»å‹
fn get_number() -> i32 {
    42
}

// 2. å…ƒç»„
fn get_pair() -> (i32, i32) {
    (1, 2)
}

// 3. Option
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

// 4. Result
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse()
}

// 5. impl Trait
fn get_iterator() -> impl Iterator<Item = i32> {
    vec![1, 2, 3].into_iter()
}

// 6. Box<dyn Trait>
fn get_display() -> Box<dyn std::fmt::Display> {
    Box::new(42)
}

// 7. æ— è¿”å›å€¼ï¼ˆunitç±»å‹ï¼‰
fn print_message(msg: &str) {
    println!("{}", msg);
}  // éšå¼è¿”å›()

// 8. æ°¸ä¸è¿”å›ï¼ˆneverç±»å‹ï¼‰
fn diverge() -> ! {
    panic!("This function never returns")
}

fn main() {
    println!("{}", get_number());
    println!("{:?}", get_pair());
    println!("{:?}", divide(10, 2));
    println!("{:?}", parse_number("42"));
    for i in get_iterator() {
        println!("{}", i);
    }
    println!("{}", get_display());
    print_message("hello");
}
```

**æå‰è¿”å›**:

```rust
fn process(value: Option<i32>) -> i32 {
    // ä½¿ç”¨returnæå‰è¿”å›
    if let None = value {
        return 0;
    }
    
    value.unwrap() * 2
}

fn validate(n: i32) -> Result<i32, String> {
    // å¤šä¸ªæå‰è¿”å›
    if n < 0 {
        return Err("è´Ÿæ•°".to_string());
    }
    
    if n == 0 {
        return Err("é›¶".to_string());
    }
    
    Ok(n)
}

fn main() {
    println!("{}", process(Some(21)));
    println!("{}", process(None));
    println!("{:?}", validate(5));
}
```

---

## 4. æ³›å‹å‡½æ•°

**ç±»å‹å‚æ•°**:

```rust
// å•ä¸ªç±»å‹å‚æ•°
fn identity<T>(value: T) -> T {
    value
}

// å¤šä¸ªç±»å‹å‚æ•°
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

// ç±»å‹æ¨æ–­
fn main() {
    let num = identity(42);        // T = i32
    let text = identity("hello");  // T = &str
    let p = pair(1, "one");        // T = i32, U = &str
    
    println!("{}", num);
    println!("{}", text);
    println!("{:?}", p);
}
```

**traitçº¦æŸ**:

```rust
use std::fmt::Display;

// å•ä¸ªçº¦æŸ
fn print_it<T: Display>(value: T) {
    println!("{}", value);
}

// å¤šä¸ªçº¦æŸ
fn compare<T: Display + PartialOrd>(a: T, b: T) {
    if a > b {
        println!("{} > {}", a, b);
    } else {
        println!("{} <= {}", a, b);
    }
}

// whereå­å¥
fn complex<T, U>(t: T, u: U)
where
    T: Display + Clone,
    U: Display + Clone,
{
    println!("t: {}, u: {}", t, u);
}

fn main() {
    print_it(42);
    compare(10, 20);
    complex("hello", 42);
}
```

**å…³è”ç±»å‹**:

```rust
trait Container {
    type Item;
    fn get(&self) -> Option<&Self::Item>;
}

struct IntContainer {
    value: i32,
}

impl Container for IntContainer {
    type Item = i32;
    
    fn get(&self) -> Option<&Self::Item> {
        Some(&self.value)
    }
}

fn process_container<C: Container>(container: &C) 
where
    C::Item: std::fmt::Display,
{
    if let Some(item) = container.get() {
        println!("Item: {}", item);
    }
}

fn main() {
    let container = IntContainer { value: 42 };
    process_container(&container);
}
```

---

## 5. å¼‚æ­¥å‡½æ•°

**åŸºæœ¬è¯­æ³•**:

```rust
// å¼‚æ­¥å‡½æ•°å®šä¹‰
async fn fetch_data() -> Result<String, String> {
    // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    Ok("data".to_string())
}

// è°ƒç”¨å¼‚æ­¥å‡½æ•°
async fn process() {
    match fetch_data().await {
        Ok(data) => println!("æ•°æ®: {}", data),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}

// å¼‚æ­¥å‡½æ•°è¿”å›Future
fn example() -> impl std::future::Future<Output = i32> {
    async { 42 }
}

fn main() {
    // éœ€è¦è¿è¡Œæ—¶æ‰§è¡Œ
    println!("å¼‚æ­¥å‡½æ•°éœ€è¦è¿è¡Œæ—¶æ”¯æŒ");
}
```

**å¼‚æ­¥traitæ–¹æ³•**:

```rust
trait AsyncProcessor {
    // å¼‚æ­¥æ–¹æ³•
    async fn process(&self) -> Result<(), String> {
        Ok(())
    }
}

struct MyProcessor;

impl AsyncProcessor for MyProcessor {
    async fn process(&self) -> Result<(), String> {
        println!("å¤„ç†ä¸­...");
        Ok(())
    }
}

fn main() {
    println!("å¼‚æ­¥traitæ–¹æ³•ç¤ºä¾‹");
}
```

---

## 6. å‡½æ•°æŒ‡é’ˆ

**fnç±»å‹**:

```rust
// å‡½æ•°æŒ‡é’ˆç±»å‹
type BinaryOp = fn(i32, i32) -> i32;

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

// æ¥å—å‡½æ•°æŒ‡é’ˆ
fn apply_op(a: i32, b: i32, op: BinaryOp) -> i32 {
    op(a, b)
}

// è¿”å›å‡½æ•°æŒ‡é’ˆ
fn get_operation(op_type: &str) -> BinaryOp {
    match op_type {
        "add" => add,
        "mul" => multiply,
        _ => add,
    }
}

fn main() {
    println!("{}", apply_op(3, 4, add));
    println!("{}", apply_op(3, 4, multiply));
    
    let op = get_operation("add");
    println!("{}", op(5, 6));
}
```

**fn vs Fn trait**:

```rust
fn main() {
    // fnç±»å‹ï¼šåªèƒ½æ˜¯å‡½æ•°
    let f1: fn(i32) -> i32 = |x| x * 2;  // OKï¼šæ— æ•è·çš„é—­åŒ…
    
    let y = 10;
    // let f2: fn(i32) -> i32 = |x| x + y;  // é”™è¯¯ï¼šæ•è·äº†y
    
    // Fn traitï¼šå¯ä»¥æ˜¯é—­åŒ…
    fn call_fn<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {
        f(x)
    }
    
    println!("{}", call_fn(|x| x * 2, 5));
    println!("{}", call_fn(|x| x + y, 5));  // OK
}
```

---

## 7. æ–¹æ³•è¯­æ³•

**selfå‚æ•°**:

```rust
struct Counter {
    count: u32,
}

impl Counter {
    // 1. å…³è”å‡½æ•°ï¼ˆæ— selfï¼‰
    fn new() -> Self {
        Counter { count: 0 }
    }
    
    // 2. ä¸å¯å˜å¼•ç”¨self
    fn get(&self) -> u32 {
        self.count
    }
    
    // 3. å¯å˜å¼•ç”¨self
    fn increment(&mut self) {
        self.count += 1;
    }
    
    // 4. è·å–æ‰€æœ‰æƒself
    fn consume(self) -> u32 {
        self.count
    }
    
    // 5. Box<Self>
    fn boxed(self: Box<Self>) -> u32 {
        self.count
    }
    
    // 6. Rc<Self>
    fn rc(self: std::rc::Rc<Self>) -> u32 {
        self.count
    }
}

fn main() {
    let mut counter = Counter::new();
    println!("{}", counter.get());
    counter.increment();
    println!("{}", counter.get());
    let final_count = counter.consume();
    println!("{}", final_count);
}
```

**æ–¹æ³•è°ƒç”¨è¯­æ³•**:

```rust
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn distance(&self, other: &Point) -> f64 {
        let dx = (self.x - other.x) as f64;
        let dy = (self.y - other.y) as f64;
        (dx * dx + dy * dy).sqrt()
    }
}

fn main() {
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 3, y: 4 };
    
    // æ–¹æ³•è°ƒç”¨è¯­æ³•
    let dist1 = p1.distance(&p2);
    
    // å‡½æ•°è°ƒç”¨è¯­æ³•
    let dist2 = Point::distance(&p1, &p2);
    
    assert_eq!(dist1, dist2);
    println!("è·ç¦»: {}", dist1);
}
```

---

**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1.0  
**ç›¸å…³æ–‡æ¡£**: [ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md) | [README](../../README.md)

---

**ğŸ“š å®Œæ•´çš„Rustå‡½æ•°è¯­æ³•å‚è€ƒ** ğŸ¦€âœ¨
