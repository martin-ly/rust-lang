# 01. çº¿ç¨‹ä¸æ‰€æœ‰æƒ (Threads and Ownership)

> **æ–‡æ¡£å®šä½**: ç†è§£çº¿ç¨‹åŸºç¡€å’ŒRustæ‰€æœ‰æƒç³»ç»Ÿå¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨  
> **å…ˆä¿®çŸ¥è¯†**: Rustæ‰€æœ‰æƒåŸºç¡€  
> **ç›¸å…³æ–‡æ¡£**: [01_basic_threading](./01_basic_threading.md) | [02_message_passing](./02_message_passing.md) | [ä¸»ç´¢å¼•](./00_MASTER_INDEX.md)

**æœ€åæ›´æ–°**: 2025-10-19  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.0+  
**éš¾åº¦ç­‰çº§**: â­â­  
**æ–‡æ¡£ç±»å‹**: ğŸ’¡ ç†è®ºåŸºç¡€

---

## ğŸ“‹ æœ¬æ–‡å†…å®¹

å¹¶å‘ (Concurrency) æ˜¯æŒ‡ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†ç‹¬ç«‹ã€æ— åºæ‰§è¡Œçš„èƒ½åŠ›ã€‚
åœ¨ Rust ä¸­ï¼Œå¹¶å‘ç¼–ç¨‹çš„åŸºçŸ³æ˜¯æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œè€Œå…¶å®‰å…¨æ€§çš„æ ¸å¿ƒä¿éšœåˆ™æ¥è‡ªäºæ‰€æœ‰æƒç³»ç»Ÿã€‚
æœ¬æ–‡æ¢è®¨çº¿ç¨‹åˆ›å»ºã€æ‰€æœ‰æƒè½¬ç§»å’ŒRustçš„å¹¶å‘å®‰å…¨ä¿è¯ã€‚

---

## ç›®å½•

- [01. çº¿ç¨‹ä¸æ‰€æœ‰æƒ (Threads and Ownership)](#01-çº¿ç¨‹ä¸æ‰€æœ‰æƒ-threads-and-ownership)
  - [ğŸ“‹ æœ¬æ–‡å†…å®¹](#-æœ¬æ–‡å†…å®¹)
  - [ç›®å½•](#ç›®å½•)
  - [1.1. åˆ›å»ºæ–°çº¿ç¨‹: `thread::spawn`](#11-åˆ›å»ºæ–°çº¿ç¨‹-threadspawn)
  - [1.2. `move` é—­åŒ…ä¸æ‰€æœ‰æƒ](#12-move-é—­åŒ…ä¸æ‰€æœ‰æƒ)

## 1.1. åˆ›å»ºæ–°çº¿ç¨‹: `thread::spawn`

Rust æ ‡å‡†åº“é€šè¿‡ `std::thread::spawn` å‡½æ•°æä¾›äº†åˆ›å»ºæ–°çº¿ç¨‹çš„ APIã€‚`spawn` å‡½æ•°æ¥å—ä¸€ä¸ªé—­åŒ… (closure) ä½œä¸ºå‚æ•°ï¼Œè¿™ä¸ªé—­åŒ…åŒ…å«äº†æ–°çº¿ç¨‹éœ€è¦æ‰§è¡Œçš„ä»£ç ã€‚

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹
    let handle = thread::spawn(|| {
        for i in 1..=5 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    // ä¸»çº¿ç¨‹çš„ä»£ç ä¼šç»§ç»­æ‰§è¡Œ
    for i in 1..=3 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    // ç­‰å¾…æ–°çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    handle.join().unwrap();
}
```

`thread::spawn` ä¼šè¿”å›ä¸€ä¸ª `JoinHandle`ã€‚è¿™ä¸ª `JoinHandle` æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼Œè°ƒç”¨å®ƒçš„ `join()` æ–¹æ³•å¯ä»¥é˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ° `spawn` å‡ºæ¥çš„çº¿ç¨‹æ‰§è¡Œç»“æŸã€‚

## 1.2. `move` é—­åŒ…ä¸æ‰€æœ‰æƒ

åœ¨çº¿ç¨‹ä¹‹é—´ä¼ é€’æ•°æ®æ˜¯å¹¶å‘ç¼–ç¨‹çš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚Rust çš„æ‰€æœ‰æƒç³»ç»Ÿåœ¨è¿™é‡Œå‘æŒ¥äº†è‡³å…³é‡è¦çš„ä½œç”¨ï¼Œå®ƒèƒ½é˜²æ­¢æ•°æ®ç«äº‰ (data races) ç­‰å¸¸è§çš„å¹¶å‘ bugã€‚

å½“ä½ å°è¯•åœ¨çº¿ç¨‹ä¸­ä½¿ç”¨æ¥è‡ªä¸»çº¿ç¨‹ç¯å¢ƒçš„å˜é‡æ—¶ï¼Œå¿…é¡»å°†è¿™äº›å˜é‡çš„æ‰€æœ‰æƒ**ç§»åŠ¨ (move)** åˆ°æ–°çº¿ç¨‹ä¸­ã€‚è¿™æ˜¯é€šè¿‡åœ¨é—­åŒ…å‰ä½¿ç”¨ `move` å…³é”®å­—æ¥å®ç°çš„ã€‚

**ä¸ºä»€ä¹ˆå¿…é¡» `move`ï¼Ÿ**
Rust ç¼–è¯‘å™¨æ— æ³•é¢„çŸ¥æ–°çº¿ç¨‹ä¼šæ‰§è¡Œå¤šä¹…ã€‚å¦‚æœæ–°çº¿ç¨‹åªæ˜¯å€Ÿç”¨ (borrow) æ•°æ®ï¼Œé‚£ä¹ˆåœ¨å®ƒæ‰§è¡ŒæœŸé—´ï¼Œä¸»çº¿ç¨‹å¯èƒ½ä¼šç»“æŸï¼Œå¯¼è‡´è¢«å€Ÿç”¨çš„æ•°æ®è¢«é‡Šæ”¾ï¼Œä»è€Œäº§ç”Ÿæ‚¬å‚å¼•ç”¨ (dangling reference)ã€‚ä¸ºäº†ä¿è¯å†…å­˜å®‰å…¨ï¼Œç¼–è¯‘å™¨å¼ºåˆ¶è¦æ±‚å°†æ‰€æœ‰æƒè½¬ç§»ç»™æ–°çº¿ç¨‹ï¼Œç¡®ä¿æ•°æ®åœ¨æ–°çº¿ç¨‹çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

**ç¤ºä¾‹**:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    // ä½¿ç”¨ `move` å…³é”®å­—å¼ºåˆ¶é—­åŒ…è·å¾— `v` çš„æ‰€æœ‰æƒ
    let handle = thread::spawn(move || {
        // ç°åœ¨é—­åŒ…æ‹¥æœ‰ `v`ï¼Œå¯ä»¥å®‰å…¨åœ°ä½¿ç”¨å®ƒ
        println!("Here's a vector: {:?}", v);
    });

    // æ­¤æ—¶ `v` çš„æ‰€æœ‰æƒå·²ç»è½¬ç§»ï¼Œä¸»çº¿ç¨‹æ— æ³•å†ä½¿ç”¨å®ƒ
    // drop(v); // è¿™è¡Œä»£ç ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯

    handle.join().unwrap();
}
```

`move` å…³é”®å­—ç¡®ä¿äº† `v` ä¸æ–°çº¿ç¨‹ä¸€åŒå­˜æ´»ï¼Œä»è€Œåœ¨ç¼–è¯‘æ—¶å°±æœç»äº†æ½œåœ¨çš„å†…å­˜å®‰å…¨é—®é¢˜ã€‚è¿™ç§å°†æ‰€æœ‰æƒä¸çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç»‘å®šçš„æœºåˆ¶ï¼Œæ˜¯ Rust "æ— ç•å¹¶å‘" (Fearless Concurrency) çš„æ ¸å¿ƒä½“ç°ã€‚

---

**ç« èŠ‚å¯¼èˆª:**

- **ä¸‹ä¸€ç«  ->** `02_message_passing.md`: æ¢è®¨å¦‚ä½•ä½¿ç”¨é€šé“åœ¨çº¿ç¨‹é—´å®‰å…¨åœ°ä¼ é€’æ¶ˆæ¯ã€‚
- **è¿”å›ç›®å½• ->** `_index.md`
