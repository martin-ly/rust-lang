# è·¨å¹³å°å¹¶å‘

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 4 - é«˜çº§ä¸»é¢˜ | **éš¾åº¦**: â­â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [è·¨å¹³å°å¹¶å‘](#è·¨å¹³å°å¹¶å‘)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. å¹³å°å·®å¼‚æ¦‚è§ˆ](#1-å¹³å°å·®å¼‚æ¦‚è§ˆ)
    - [1.1 æ“ä½œç³»ç»Ÿçº¿ç¨‹æ¨¡å‹](#11-æ“ä½œç³»ç»Ÿçº¿ç¨‹æ¨¡å‹)
      - [Windows](#windows)
      - [Linux](#linux)
      - [macOS](#macos)
    - [1.2 åŒæ­¥åŸè¯­å®ç°å·®å¼‚](#12-åŒæ­¥åŸè¯­å®ç°å·®å¼‚)
      - [Mutex å®ç°](#mutex-å®ç°)
      - [å¹³å°å·®å¼‚ç¤ºä¾‹](#å¹³å°å·®å¼‚ç¤ºä¾‹)
    - [1.3 æ€§èƒ½ç‰¹æ€§å¯¹æ¯”](#13-æ€§èƒ½ç‰¹æ€§å¯¹æ¯”)
      - [çº¿ç¨‹åˆ›å»ºå¼€é”€](#çº¿ç¨‹åˆ›å»ºå¼€é”€)
      - [é”æ€§èƒ½å¯¹æ¯”](#é”æ€§èƒ½å¯¹æ¯”)
  - [2. Windows å¹³å°ç‰¹æ€§](#2-windows-å¹³å°ç‰¹æ€§)
    - [2.1 Windows çº¿ç¨‹ API](#21-windows-çº¿ç¨‹-api)
      - [ä½¿ç”¨ winapi crate](#ä½¿ç”¨-winapi-crate)
    - [2.2 Windows åŒæ­¥å¯¹è±¡](#22-windows-åŒæ­¥å¯¹è±¡)
      - [Critical Section](#critical-section)
    - [2.3 Windows ç‰¹å®šä¼˜åŒ–](#23-windows-ç‰¹å®šä¼˜åŒ–)
      - [I/O å®Œæˆç«¯å£ (IOCP)](#io-å®Œæˆç«¯å£-iocp)
  - [3. Linux å¹³å°ç‰¹æ€§](#3-linux-å¹³å°ç‰¹æ€§)
    - [3.1 Linux çº¿ç¨‹ API](#31-linux-çº¿ç¨‹-api)
      - [ä½¿ç”¨ nix crate](#ä½¿ç”¨-nix-crate)
    - [3.2 Linux åŒæ­¥åŸè¯­](#32-linux-åŒæ­¥åŸè¯­)
      - [Futex (Fast Userspace Mutex)](#futex-fast-userspace-mutex)
    - [3.3 Linux ç‰¹å®šä¼˜åŒ–](#33-linux-ç‰¹å®šä¼˜åŒ–)
      - [CPU äº²å’Œæ€§](#cpu-äº²å’Œæ€§)
  - [4. macOS å¹³å°ç‰¹æ€§](#4-macos-å¹³å°ç‰¹æ€§)
    - [4.1 macOS çº¿ç¨‹ API](#41-macos-çº¿ç¨‹-api)
      - [ä½¿ç”¨ dispatch crate](#ä½¿ç”¨-dispatch-crate)
    - [4.2 Grand Central Dispatch](#42-grand-central-dispatch)
      - [GCD å¹¶è¡Œæ‰§è¡Œ](#gcd-å¹¶è¡Œæ‰§è¡Œ)
    - [4.3 macOS ç‰¹å®šä¼˜åŒ–](#43-macos-ç‰¹å®šä¼˜åŒ–)
      - [QoS (Quality of Service)](#qos-quality-of-service)
  - [5. æ¡ä»¶ç¼–è¯‘ç­–ç•¥](#5-æ¡ä»¶ç¼–è¯‘ç­–ç•¥)
    - [5.1 åŸºæœ¬æ¡ä»¶ç¼–è¯‘](#51-åŸºæœ¬æ¡ä»¶ç¼–è¯‘)
      - [ç›®æ ‡æ“ä½œç³»ç»Ÿ](#ç›®æ ‡æ“ä½œç³»ç»Ÿ)
      - [ç›®æ ‡æ¶æ„](#ç›®æ ‡æ¶æ„)
    - [5.2 å¹³å°æŠ½è±¡å±‚](#52-å¹³å°æŠ½è±¡å±‚)
      - [ç»Ÿä¸€æ¥å£](#ç»Ÿä¸€æ¥å£)
    - [5.3 ç‰¹æ€§æ£€æµ‹](#53-ç‰¹æ€§æ£€æµ‹)
      - [è¿è¡Œæ—¶ç‰¹æ€§æ£€æµ‹](#è¿è¡Œæ—¶ç‰¹æ€§æ£€æµ‹)
  - [6. ç§»åŠ¨å¹³å°å¹¶å‘](#6-ç§»åŠ¨å¹³å°å¹¶å‘)
    - [6.1 Android å¹³å°](#61-android-å¹³å°)
      - [JNI é›†æˆ](#jni-é›†æˆ)
      - [Android çº¿ç¨‹ä¼˜å…ˆçº§](#android-çº¿ç¨‹ä¼˜å…ˆçº§)
    - [6.2 iOS å¹³å°](#62-ios-å¹³å°)
      - [iOS çº¿ç¨‹é…ç½®](#ios-çº¿ç¨‹é…ç½®)
      - [iOS åå°æ‰§è¡Œé™åˆ¶](#ios-åå°æ‰§è¡Œé™åˆ¶)
  - [7. è·¨å¹³å°æœ€ä½³å®è·µ](#7-è·¨å¹³å°æœ€ä½³å®è·µ)
    - [å®è·µåŸåˆ™](#å®è·µåŸåˆ™)
    - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
    - [æ ¸å¿ƒæ–‡æ¡£](#æ ¸å¿ƒæ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ğŸ¯ æ¦‚è¿°

è·¨å¹³å°å¹¶å‘ç¼–ç¨‹éœ€è¦ç†è§£ä¸åŒæ“ä½œç³»ç»Ÿçš„çº¿ç¨‹æ¨¡å‹ã€åŒæ­¥åŸè¯­å®ç°å’Œæ€§èƒ½ç‰¹æ€§ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»ï¼š

- **å¹³å°å·®å¼‚**ï¼šWindowsã€Linuxã€macOS çš„çº¿ç¨‹æ¨¡å‹å’Œå®ç°å·®å¼‚
- **æ¡ä»¶ç¼–è¯‘**ï¼šä½¿ç”¨ `#[cfg]` å¤„ç†å¹³å°ç‰¹å®šä»£ç 
- **å¹³å°æŠ½è±¡**ï¼šè®¾è®¡ç»Ÿä¸€çš„è·¨å¹³å°æ¥å£
- **ç§»åŠ¨å¹³å°**ï¼šAndroid å’Œ iOS çš„å¹¶å‘ç‰¹æ€§
- **æœ€ä½³å®è·µ**ï¼šè·¨å¹³å°å…¼å®¹æ€§ç­–ç•¥

---

## 1. å¹³å°å·®å¼‚æ¦‚è§ˆ

### 1.1 æ“ä½œç³»ç»Ÿçº¿ç¨‹æ¨¡å‹

#### Windows

```text
Windows çº¿ç¨‹æ¨¡å‹
â”œâ”€â”€ 1:1 çº¿ç¨‹æ¨¡å‹ (ç”¨æˆ·çº¿ç¨‹:å†…æ ¸çº¿ç¨‹)
â”œâ”€â”€ çº¤ç¨‹ (Fibers) æ”¯æŒ
â”œâ”€â”€ çº¿ç¨‹æ±  API (Thread Pool API)
â””â”€â”€ I/O å®Œæˆç«¯å£ (IOCP)
```

#### Linux

```text
Linux çº¿ç¨‹æ¨¡å‹
â”œâ”€â”€ NPTL (Native POSIX Thread Library)
â”œâ”€â”€ 1:1 çº¿ç¨‹æ¨¡å‹
â”œâ”€â”€ è½»é‡çº§è¿›ç¨‹ (LWP)
â””â”€â”€ epoll/io_uring å¼‚æ­¥ I/O
```

#### macOS

```text
macOS çº¿ç¨‹æ¨¡å‹
â”œâ”€â”€ POSIX çº¿ç¨‹ (pthread)
â”œâ”€â”€ Grand Central Dispatch (GCD)
â”œâ”€â”€ NSOperationQueue
â””â”€â”€ kqueue å¼‚æ­¥ I/O
```

---

### 1.2 åŒæ­¥åŸè¯­å®ç°å·®å¼‚

#### Mutex å®ç°

```rust
use std::sync::Mutex;

// Rust çš„ Mutex åœ¨ä¸åŒå¹³å°æœ‰ä¸åŒå®ç°
fn mutex_example() {
    let m = Mutex::new(0);
    
    // Windows: ä½¿ç”¨ SRWLock (Slim Reader/Writer Lock)
    // Linux: ä½¿ç”¨ pthread_mutex
    // macOS: ä½¿ç”¨ pthread_mutex
    
    *m.lock().unwrap() += 1;
}
```

#### å¹³å°å·®å¼‚ç¤ºä¾‹

```rust
#[cfg(target_os = "windows")]
fn platform_specific_mutex() {
    // Windows: Critical Section æ€§èƒ½æ›´å¥½
    println!("Using Windows SRWLock");
}

#[cfg(target_os = "linux")]
fn platform_specific_mutex() {
    // Linux: futex ç³»ç»Ÿè°ƒç”¨
    println!("Using Linux futex");
}

#[cfg(target_os = "macos")]
fn platform_specific_mutex() {
    // macOS: pthread_mutex_t
    println!("Using macOS pthread_mutex");
}

fn main() {
    platform_specific_mutex();
}
```

---

### 1.3 æ€§èƒ½ç‰¹æ€§å¯¹æ¯”

#### çº¿ç¨‹åˆ›å»ºå¼€é”€

```rust
use std::thread;
use std::time::Instant;

fn benchmark_thread_creation() {
    let iterations = 1000;
    
    let start = Instant::now();
    for _ in 0..iterations {
        let handle = thread::spawn(|| {
            // ç©ºçº¿ç¨‹
        });
        handle.join().unwrap();
    }
    let elapsed = start.elapsed();
    
    println!("Platform: {}", std::env::consts::OS);
    println!("Thread creation: {:?} per thread", elapsed / iterations);
    
    // å…¸å‹ç»“æœ:
    // Windows: ~100-200Î¼s
    // Linux: ~50-100Î¼s
    // macOS: ~80-150Î¼s
}

fn main() {
    benchmark_thread_creation();
}
```

#### é”æ€§èƒ½å¯¹æ¯”

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Instant;

fn benchmark_mutex() {
    let counter = Arc::new(Mutex::new(0u64));
    let iterations = 1000000;
    
    let start = Instant::now();
    
    let handles: Vec<_> = (0..4).map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            for _ in 0..iterations / 4 {
                *counter.lock().unwrap() += 1;
            }
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    let elapsed = start.elapsed();
    println!("Platform: {}", std::env::consts::OS);
    println!("Mutex ops: {:?}", elapsed);
    
    // å…¸å‹ç»“æœ (4çº¿ç¨‹ç«äº‰):
    // Windows: ~50-80ms
    // Linux: ~40-60ms
    // macOS: ~45-70ms
}

fn main() {
    benchmark_mutex();
}
```

---

## 2. Windows å¹³å°ç‰¹æ€§

### 2.1 Windows çº¿ç¨‹ API

#### ä½¿ç”¨ winapi crate

```rust
// Cargo.toml
// [dependencies]
// winapi = { version = "0.3", features = ["processthreadsapi", "synchapi"] }

#[cfg(target_os = "windows")]
mod windows_threads {
    use winapi::um::processthreadsapi::{CreateThread, GetCurrentThreadId};
    use winapi::um::synchapi::WaitForSingleObject;
    use winapi::um::winbase::INFINITE;
    use std::ptr;
    
    pub unsafe fn create_native_thread() {
        extern "system" fn thread_proc(_: *mut winapi::ctypes::c_void) -> u32 {
            println!("Windows native thread: {}", GetCurrentThreadId());
            0
        }
        
        let handle = CreateThread(
            ptr::null_mut(),
            0,
            Some(thread_proc),
            ptr::null_mut(),
            0,
            ptr::null_mut(),
        );
        
        if !handle.is_null() {
            WaitForSingleObject(handle, INFINITE);
        }
    }
}

#[cfg(target_os = "windows")]
fn main() {
    unsafe {
        windows_threads::create_native_thread();
    }
}

#[cfg(not(target_os = "windows"))]
fn main() {
    println!("This example is Windows-only");
}
```

---

### 2.2 Windows åŒæ­¥å¯¹è±¡

#### Critical Section

```rust
#[cfg(target_os = "windows")]
mod windows_sync {
    use winapi::um::synchapi::{
        InitializeCriticalSection, DeleteCriticalSection,
        EnterCriticalSection, LeaveCriticalSection,
    };
    use winapi::um::winnt::CRITICAL_SECTION;
    use std::mem::MaybeUninit;
    
    pub struct CriticalSection {
        inner: CRITICAL_SECTION,
    }
    
    impl CriticalSection {
        pub fn new() -> Self {
            unsafe {
                let mut cs = MaybeUninit::uninit();
                InitializeCriticalSection(cs.as_mut_ptr());
                Self { inner: cs.assume_init() }
            }
        }
        
        pub fn enter(&mut self) {
            unsafe {
                EnterCriticalSection(&mut self.inner);
            }
        }
        
        pub fn leave(&mut self) {
            unsafe {
                LeaveCriticalSection(&mut self.inner);
            }
        }
    }
    
    impl Drop for CriticalSection {
        fn drop(&mut self) {
            unsafe {
                DeleteCriticalSection(&mut self.inner);
            }
        }
    }
}

#[cfg(target_os = "windows")]
fn main() {
    use windows_sync::CriticalSection;
    
    let mut cs = CriticalSection::new();
    cs.enter();
    println!("In critical section");
    cs.leave();
}

#[cfg(not(target_os = "windows"))]
fn main() {
    println!("This example is Windows-only");
}
```

---

### 2.3 Windows ç‰¹å®šä¼˜åŒ–

#### I/O å®Œæˆç«¯å£ (IOCP)

```rust
#[cfg(target_os = "windows")]
mod windows_iocp {
    use winapi::um::ioapiset::CreateIoCompletionPort;
    use winapi::um::handleapi::INVALID_HANDLE_VALUE;
    use std::ptr;
    
    pub struct IoCompletionPort {
        handle: winapi::um::winnt::HANDLE,
    }
    
    impl IoCompletionPort {
        pub fn new(thread_count: u32) -> Option<Self> {
            unsafe {
                let handle = CreateIoCompletionPort(
                    INVALID_HANDLE_VALUE,
                    ptr::null_mut(),
                    0,
                    thread_count,
                );
                
                if handle.is_null() {
                    None
                } else {
                    Some(Self { handle })
                }
            }
        }
    }
    
    // æ³¨: å®Œæ•´å®ç°éœ€è¦æ›´å¤šä»£ç 
}
```

---

## 3. Linux å¹³å°ç‰¹æ€§

### 3.1 Linux çº¿ç¨‹ API

#### ä½¿ç”¨ nix crate

```rust
// Cargo.toml
// [dependencies]
// nix = { version = "0.27", features = ["pthread"] }

#[cfg(target_os = "linux")]
mod linux_threads {
    use nix::unistd::{getpid, gettid};
    use std::thread;
    
    pub fn show_thread_info() {
        println!("Process ID: {}", getpid());
        
        let handles: Vec<_> = (0..4).map(|i| {
            thread::spawn(move || {
                println!("Thread {}: TID = {}", i, gettid());
            })
        }).collect();
        
        for h in handles {
            h.join().unwrap();
        }
    }
}

#[cfg(target_os = "linux")]
fn main() {
    linux_threads::show_thread_info();
}

#[cfg(not(target_os = "linux"))]
fn main() {
    println!("This example is Linux-only");
}
```

---

### 3.2 Linux åŒæ­¥åŸè¯­

#### Futex (Fast Userspace Mutex)

```rust
#[cfg(target_os = "linux")]
mod linux_futex {
    use std::sync::atomic::{AtomicU32, Ordering};
    use std::time::Duration;
    
    pub struct FutexLock {
        state: AtomicU32,
    }
    
    impl FutexLock {
        pub fn new() -> Self {
            Self {
                state: AtomicU32::new(0),
            }
        }
        
        pub fn lock(&self) {
            loop {
                // å°è¯•è·å–é”
                if self.state
                    .compare_exchange(0, 1, Ordering::Acquire, Ordering::Relaxed)
                    .is_ok()
                {
                    return;
                }
                
                // ç­‰å¾…ï¼ˆç®€åŒ–ç‰ˆï¼‰
                std::thread::yield_now();
            }
        }
        
        pub fn unlock(&self) {
            self.state.store(0, Ordering::Release);
        }
    }
}

#[cfg(target_os = "linux")]
fn main() {
    use linux_futex::FutexLock;
    use std::sync::Arc;
    use std::thread;
    
    let lock = Arc::new(FutexLock::new());
    
    let handles: Vec<_> = (0..4).map(|i| {
        let lock = Arc::clone(&lock);
        thread::spawn(move || {
            lock.lock();
            println!("Thread {} acquired lock", i);
            std::thread::sleep(std::time::Duration::from_millis(10));
            lock.unlock();
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
}

#[cfg(not(target_os = "linux"))]
fn main() {
    println!("This example is Linux-only");
}
```

---

### 3.3 Linux ç‰¹å®šä¼˜åŒ–

#### CPU äº²å’Œæ€§

```rust
#[cfg(target_os = "linux")]
mod linux_affinity {
    use nix::sched::{sched_setaffinity, CpuSet};
    use nix::unistd::Pid;
    use std::thread;
    
    pub fn set_thread_affinity(cpu_id: usize) -> nix::Result<()> {
        let mut cpuset = CpuSet::new();
        cpuset.set(cpu_id)?;
        sched_setaffinity(Pid::from_raw(0), &cpuset)
    }
    
    pub fn demo() {
        let handles: Vec<_> = (0..4).map(|i| {
            thread::spawn(move || {
                if let Err(e) = set_thread_affinity(i) {
                    eprintln!("Failed to set affinity: {}", e);
                } else {
                    println!("Thread {} pinned to CPU {}", i, i);
                }
                
                // æ‰§è¡Œä»»åŠ¡
                std::thread::sleep(std::time::Duration::from_secs(1));
            })
        }).collect();
        
        for h in handles {
            h.join().unwrap();
        }
    }
}

#[cfg(target_os = "linux")]
fn main() {
    linux_affinity::demo();
}

#[cfg(not(target_os = "linux"))]
fn main() {
    println!("This example is Linux-only");
}
```

---

## 4. macOS å¹³å°ç‰¹æ€§

### 4.1 macOS çº¿ç¨‹ API

#### ä½¿ç”¨ dispatch crate

```rust
// Cargo.toml
// [dependencies]
// dispatch = "0.2"

#[cfg(target_os = "macos")]
mod macos_threads {
    use dispatch::{Queue, QueueAttribute};
    use std::thread;
    use std::time::Duration;
    
    pub fn demo_dispatch() {
        // åˆ›å»ºä¸²è¡Œé˜Ÿåˆ—
        let serial_queue = Queue::create(
            "com.example.serial",
            QueueAttribute::Serial,
        );
        
        // æäº¤ä»»åŠ¡
        serial_queue.exec_async(|| {
            println!("Task 1 on serial queue");
        });
        
        serial_queue.exec_async(|| {
            println!("Task 2 on serial queue");
        });
        
        // åˆ›å»ºå¹¶å‘é˜Ÿåˆ—
        let concurrent_queue = Queue::create(
            "com.example.concurrent",
            QueueAttribute::Concurrent,
        );
        
        for i in 0..4 {
            concurrent_queue.exec_async(move || {
                println!("Task {} on concurrent queue", i);
                thread::sleep(Duration::from_millis(100));
            });
        }
        
        thread::sleep(Duration::from_secs(1));
    }
}

#[cfg(target_os = "macos")]
fn main() {
    macos_threads::demo_dispatch();
}

#[cfg(not(target_os = "macos"))]
fn main() {
    println!("This example is macOS-only");
}
```

---

### 4.2 Grand Central Dispatch

#### GCD å¹¶è¡Œæ‰§è¡Œ

```rust
#[cfg(target_os = "macos")]
mod macos_gcd {
    use dispatch::{Queue, QueuePriority};
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;
    
    pub fn parallel_computation() {
        let result = Arc::new(Mutex::new(Vec::new()));
        let queue = Queue::global(QueuePriority::Default);
        
        for i in 0..10 {
            let result = Arc::clone(&result);
            queue.exec_async(move || {
                // è®¡ç®—
                let value = i * i;
                thread::sleep(Duration::from_millis(10));
                
                // å­˜å‚¨ç»“æœ
                result.lock().unwrap().push(value);
            });
        }
        
        thread::sleep(Duration::from_secs(1));
        
        let r = result.lock().unwrap();
        println!("Results: {:?}", *r);
    }
}

#[cfg(target_os = "macos")]
fn main() {
    macos_gcd::parallel_computation();
}

#[cfg(not(target_os = "macos"))]
fn main() {
    println!("This example is macOS-only");
}
```

---

### 4.3 macOS ç‰¹å®šä¼˜åŒ–

#### QoS (Quality of Service)

```rust
#[cfg(target_os = "macos")]
mod macos_qos {
    use dispatch::{Queue, QueuePriority};
    
    pub fn demo_qos() {
        // ç”¨æˆ·äº¤äº’ä¼˜å…ˆçº§
        let ui_queue = Queue::global(QueuePriority::High);
        ui_queue.exec_async(|| {
            println!("High priority: UI task");
        });
        
        // åå°ä»»åŠ¡
        let bg_queue = Queue::global(QueuePriority::Low);
        bg_queue.exec_async(|| {
            println!("Low priority: Background task");
        });
    }
}

#[cfg(target_os = "macos")]
fn main() {
    macos_qos::demo_qos();
    std::thread::sleep(std::time::Duration::from_secs(1));
}

#[cfg(not(target_os = "macos"))]
fn main() {
    println!("This example is macOS-only");
}
```

---

## 5. æ¡ä»¶ç¼–è¯‘ç­–ç•¥

### 5.1 åŸºæœ¬æ¡ä»¶ç¼–è¯‘

#### ç›®æ ‡æ“ä½œç³»ç»Ÿ

```rust
#[cfg(target_os = "windows")]
fn get_thread_count() -> usize {
    std::env::var("NUMBER_OF_PROCESSORS")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(4)
}

#[cfg(target_os = "linux")]
fn get_thread_count() -> usize {
    std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4)
}

#[cfg(target_os = "macos")]
fn get_thread_count() -> usize {
    std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4)
}

#[cfg(not(any(target_os = "windows", target_os = "linux", target_os = "macos")))]
fn get_thread_count() -> usize {
    4  // é»˜è®¤å€¼
}

fn main() {
    println!("Thread count: {}", get_thread_count());
}
```

#### ç›®æ ‡æ¶æ„

```rust
#[cfg(target_arch = "x86_64")]
fn arch_specific_optimization() {
    println!("Using x86_64 optimizations");
    // å¯ä»¥ä½¿ç”¨ AVX2/AVX512 ç­‰æŒ‡ä»¤
}

#[cfg(target_arch = "aarch64")]
fn arch_specific_optimization() {
    println!("Using ARM64 optimizations");
    // å¯ä»¥ä½¿ç”¨ NEON ç­‰æŒ‡ä»¤
}

#[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64")))]
fn arch_specific_optimization() {
    println!("Using generic optimizations");
}

fn main() {
    arch_specific_optimization();
}
```

---

### 5.2 å¹³å°æŠ½è±¡å±‚

#### ç»Ÿä¸€æ¥å£

```rust
// å®šä¹‰ç»Ÿä¸€çš„æ¥å£
pub trait PlatformThread {
    fn create<F>(f: F) -> Self
    where
        F: FnOnce() + Send + 'static;
    
    fn join(self);
}

// Windows å®ç°
#[cfg(target_os = "windows")]
pub struct ThreadHandle {
    inner: std::thread::JoinHandle<()>,
}

#[cfg(target_os = "windows")]
impl PlatformThread for ThreadHandle {
    fn create<F>(f: F) -> Self
    where
        F: FnOnce() + Send + 'static
    {
        Self {
            inner: std::thread::spawn(f),
        }
    }
    
    fn join(self) {
        self.inner.join().unwrap();
    }
}

// Linux å®ç°
#[cfg(target_os = "linux")]
pub struct ThreadHandle {
    inner: std::thread::JoinHandle<()>,
}

#[cfg(target_os = "linux")]
impl PlatformThread for ThreadHandle {
    fn create<F>(f: F) -> Self
    where
        F: FnOnce() + Send + 'static
    {
        Self {
            inner: std::thread::spawn(f),
        }
    }
    
    fn join(self) {
        self.inner.join().unwrap();
    }
}

// ä½¿ç”¨ç»Ÿä¸€æ¥å£
fn main() {
    let handle = ThreadHandle::create(|| {
        println!("Platform-agnostic thread");
    });
    
    handle.join();
}
```

---

### 5.3 ç‰¹æ€§æ£€æµ‹

#### è¿è¡Œæ—¶ç‰¹æ€§æ£€æµ‹

```rust
use std::sync::OnceLock;

static CPU_FEATURES: OnceLock<CpuFeatures> = OnceLock::new();

#[derive(Debug)]
struct CpuFeatures {
    has_avx2: bool,
    has_sse4: bool,
    core_count: usize,
}

fn detect_cpu_features() -> CpuFeatures {
    CpuFeatures {
        has_avx2: is_x86_feature_detected!("avx2"),
        has_sse4: is_x86_feature_detected!("sse4.1"),
        core_count: std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(4),
    }
}

fn get_cpu_features() -> &'static CpuFeatures {
    CPU_FEATURES.get_or_init(detect_cpu_features)
}

fn main() {
    let features = get_cpu_features();
    println!("CPU Features: {:?}", features);
    
    if features.has_avx2 {
        println!("Can use AVX2 optimizations");
    }
}
```

---

## 6. ç§»åŠ¨å¹³å°å¹¶å‘

### 6.1 Android å¹³å°

#### JNI é›†æˆ

```rust
// ä½¿ç”¨ jni crate
// [dependencies]
// jni = "0.21"

#[cfg(target_os = "android")]
mod android_threads {
    use jni::JNIEnv;
    use jni::objects::JClass;
    use jni::sys::jint;
    use std::thread;
    
    #[no_mangle]
    pub extern "C" fn Java_com_example_RustLib_startBackgroundTask(
        _env: JNIEnv,
        _class: JClass,
        iterations: jint,
    ) {
        thread::spawn(move || {
            for i in 0..iterations {
                // æ‰§è¡Œåå°ä»»åŠ¡
                println!("Android background task: {}", i);
                thread::sleep(std::time::Duration::from_millis(100));
            }
        });
    }
}
```

#### Android çº¿ç¨‹ä¼˜å…ˆçº§

```rust
#[cfg(target_os = "android")]
mod android_priority {
    use std::thread;
    
    pub fn set_thread_priority(priority: i32) {
        // Android ä½¿ç”¨ setpriority ç³»ç»Ÿè°ƒç”¨
        unsafe {
            libc::setpriority(
                libc::PRIO_PROCESS,
                0,  // å½“å‰çº¿ç¨‹
                priority,
            );
        }
    }
    
    pub fn background_thread() {
        thread::spawn(|| {
            set_thread_priority(10);  // é™ä½ä¼˜å…ˆçº§
            
            // æ‰§è¡Œåå°ä»»åŠ¡
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
            }
        });
    }
}
```

---

### 6.2 iOS å¹³å°

#### iOS çº¿ç¨‹é…ç½®

```rust
#[cfg(target_os = "ios")]
mod ios_threads {
    use std::thread;
    use std::time::Duration;
    
    pub fn configure_ios_thread() {
        // iOS é™åˆ¶åå°çº¿ç¨‹
        thread::spawn(|| {
            // è®¾ç½®çº¿ç¨‹ä¸ºåå° QoS
            unsafe {
                // ä½¿ç”¨ iOS çš„ QoS API
                // pthread_set_qos_class_self_np(...)
            }
            
            // æ‰§è¡Œåå°ä»»åŠ¡
            loop {
                thread::sleep(Duration::from_secs(1));
            }
        });
    }
}
```

#### iOS åå°æ‰§è¡Œé™åˆ¶

```rust
#[cfg(target_os = "ios")]
mod ios_background {
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;
    
    pub struct BackgroundTaskManager {
        tasks: Arc<Mutex<Vec<thread::JoinHandle<()>>>>,
    }
    
    impl BackgroundTaskManager {
        pub fn new() -> Self {
            Self {
                tasks: Arc::new(Mutex::new(Vec::new())),
            }
        }
        
        pub fn start_task<F>(&self, f: F)
        where
            F: FnOnce() + Send + 'static,
        {
            let handle = thread::spawn(f);
            self.tasks.lock().unwrap().push(handle);
        }
        
        pub fn wait_all(&self) {
            let mut tasks = self.tasks.lock().unwrap();
            while let Some(handle) = tasks.pop() {
                handle.join().unwrap();
            }
        }
    }
}
```

---

## 7. è·¨å¹³å°æœ€ä½³å®è·µ

### å®è·µåŸåˆ™

1. **ä¼˜å…ˆä½¿ç”¨ Rust æ ‡å‡†åº“**
   - `std::thread` å·²å¤„ç†å¤§éƒ¨åˆ†å¹³å°å·®å¼‚
   - `std::sync` æä¾›è·¨å¹³å°åŒæ­¥åŸè¯­
   - é¿å…ç›´æ¥ä½¿ç”¨æ“ä½œç³»ç»Ÿ API

2. **ä½¿ç”¨æ¡ä»¶ç¼–è¯‘éš”ç¦»å¹³å°ç‰¹å®šä»£ç **
   - æ¸…æ™°æ ‡è®° `#[cfg(target_os = "...")]`
   - æä¾›é»˜è®¤å®ç°ä½œä¸ºåå¤‡
   - ä¿æŒæ¥å£ç»Ÿä¸€

3. **æµ‹è¯•æ‰€æœ‰ç›®æ ‡å¹³å°**
   - ä½¿ç”¨ CI/CD å¤šå¹³å°æµ‹è¯•
   - æ³¨æ„æ€§èƒ½å·®å¼‚
   - éªŒè¯åŠŸèƒ½æ­£ç¡®æ€§

4. **æ–‡æ¡£åŒ–å¹³å°å·®å¼‚**
   - è¯´æ˜æ¯ä¸ªå¹³å°çš„è¡Œä¸º
   - æ ‡æ³¨æ€§èƒ½ç‰¹æ€§
   - æä¾›å¹³å°ç‰¹å®šçš„ä¼˜åŒ–å»ºè®®

### å®Œæ•´ç¤ºä¾‹

```rust
/// è·¨å¹³å°çº¿ç¨‹æ± 
pub struct CrossPlatformThreadPool {
    workers: Vec<std::thread::JoinHandle<()>>,
}

impl CrossPlatformThreadPool {
    pub fn new() -> Self {
        let thread_count = Self::optimal_thread_count();
        
        let mut workers = Vec::with_capacity(thread_count);
        for i in 0..thread_count {
            let handle = std::thread::spawn(move || {
                Self::configure_worker_thread(i);
                // å·¥ä½œçº¿ç¨‹é€»è¾‘
            });
            workers.push(handle);
        }
        
        Self { workers }
    }
    
    #[cfg(target_os = "windows")]
    fn optimal_thread_count() -> usize {
        std::env::var("NUMBER_OF_PROCESSORS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(4)
    }
    
    #[cfg(not(target_os = "windows"))]
    fn optimal_thread_count() -> usize {
        std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(4)
    }
    
    #[cfg(target_os = "linux")]
    fn configure_worker_thread(id: usize) {
        // Linux: è®¾ç½® CPU äº²å’Œæ€§
        // ... è®¾ç½®ä»£ç  ...
        println!("Linux worker {} configured", id);
    }
    
    #[cfg(target_os = "windows")]
    fn configure_worker_thread(id: usize) {
        // Windows: è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§
        println!("Windows worker {} configured", id);
    }
    
    #[cfg(target_os = "macos")]
    fn configure_worker_thread(id: usize) {
        // macOS: è®¾ç½® QoS
        println!("macOS worker {} configured", id);
    }
    
    #[cfg(not(any(
        target_os = "linux",
        target_os = "windows",
        target_os = "macos"
    )))]
    fn configure_worker_thread(id: usize) {
        println!("Generic worker {} configured", id);
    }
}

impl Drop for CrossPlatformThreadPool {
    fn drop(&mut self) {
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        while let Some(handle) = self.workers.pop() {
            handle.join().unwrap();
        }
    }
}

fn main() {
    println!("Creating cross-platform thread pool...");
    println!("Platform: {}", std::env::consts::OS);
    println!("Architecture: {}", std::env::consts::ARCH);
    
    let _pool = CrossPlatformThreadPool::new();
    
    std::thread::sleep(std::time::Duration::from_secs(1));
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

### æ ¸å¿ƒæ–‡æ¡£

- [ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [é«˜çº§å¹¶å‘æ¨¡å¼](./01_é«˜çº§å¹¶å‘æ¨¡å¼.md)
- [ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–](./02_ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–.md)
- [æ€§èƒ½å·¥ç¨‹å®è·µ](./03_æ€§èƒ½å·¥ç¨‹å®è·µ.md)

### å¤–éƒ¨èµ„æº

- [Rust Platform Support](https://doc.rust-lang.org/nightly/rustc/platform-support.html)
- [std::thread Documentation](https://doc.rust-lang.org/std/thread/)
- [The Rustonomicon - FFI](https://doc.rust-lang.org/nomicon/ffi.html)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **Rust ç‰ˆæœ¬**: 1.90+
