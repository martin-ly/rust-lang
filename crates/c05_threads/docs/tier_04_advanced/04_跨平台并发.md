# 跨平台并发

> **文档版本**: Rust 1.92.0+ | **更新日期**: 2025-12-11
> **文档层级**: Tier 4 - 高级主题 | **难度**: ⭐⭐⭐⭐⭐

---

## 📋 目录

- [跨平台并发](#跨平台并发)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [1. 平台差异概览](#1-平台差异概览)
    - [1.1 操作系统线程模型](#11-操作系统线程模型)
      - [Windows](#windows)
      - [Linux](#linux)
      - [macOS](#macos)
    - [1.2 同步原语实现差异](#12-同步原语实现差异)
      - [Mutex 实现](#mutex-实现)
      - [平台差异示例](#平台差异示例)
    - [1.3 性能特性对比](#13-性能特性对比)
      - [线程创建开销](#线程创建开销)
      - [锁性能对比](#锁性能对比)
  - [2. Windows 平台特性](#2-windows-平台特性)
    - [2.1 Windows 线程 API](#21-windows-线程-api)
      - [使用 winapi crate](#使用-winapi-crate)
    - [2.2 Windows 同步对象](#22-windows-同步对象)
      - [Critical Section](#critical-section)
    - [2.3 Windows 特定优化](#23-windows-特定优化)
      - [I/O 完成端口 (IOCP)](#io-完成端口-iocp)
  - [3. Linux 平台特性](#3-linux-平台特性)
    - [3.1 Linux 线程 API](#31-linux-线程-api)
      - [使用 nix crate](#使用-nix-crate)
    - [3.2 Linux 同步原语](#32-linux-同步原语)
      - [Futex (Fast Userspace Mutex)](#futex-fast-userspace-mutex)
    - [3.3 Linux 特定优化](#33-linux-特定优化)
      - [CPU 亲和性](#cpu-亲和性)
  - [4. macOS 平台特性](#4-macos-平台特性)
    - [4.1 macOS 线程 API](#41-macos-线程-api)
      - [使用 dispatch crate](#使用-dispatch-crate)
    - [4.2 Grand Central Dispatch](#42-grand-central-dispatch)
      - [GCD 并行执行](#gcd-并行执行)
    - [4.3 macOS 特定优化](#43-macos-特定优化)
      - [QoS (Quality of Service)](#qos-quality-of-service)
  - [5. 条件编译策略](#5-条件编译策略)
    - [5.1 基本条件编译](#51-基本条件编译)
      - [目标操作系统](#目标操作系统)
      - [目标架构](#目标架构)
    - [5.2 平台抽象层](#52-平台抽象层)
      - [统一接口](#统一接口)
    - [5.3 特性检测](#53-特性检测)
      - [运行时特性检测](#运行时特性检测)
  - [6. 移动平台并发](#6-移动平台并发)
    - [6.1 Android 平台](#61-android-平台)
      - [JNI 集成](#jni-集成)
      - [Android 线程优先级](#android-线程优先级)
    - [6.2 iOS 平台](#62-ios-平台)
      - [iOS 线程配置](#ios-线程配置)
      - [iOS 后台执行限制](#ios-后台执行限制)
  - [7. 跨平台最佳实践](#7-跨平台最佳实践)
    - [实践原则](#实践原则)
    - [完整示例](#完整示例)
  - [🔗 相关资源](#-相关资源)
    - [核心文档](#核心文档)
    - [外部资源](#外部资源)

---

## 🎯 概述

跨平台并发编程需要理解不同操作系统的线程模型、同步原语实现和性能特性。本文档详细介绍：

- **平台差异**：Windows、Linux、macOS 的线程模型和实现差异
- **条件编译**：使用 `#[cfg]` 处理平台特定代码
- **平台抽象**：设计统一的跨平台接口
- **移动平台**：Android 和 iOS 的并发特性
- **最佳实践**：跨平台兼容性策略

---

## 1. 平台差异概览

### 1.1 操作系统线程模型

#### Windows

```text
Windows 线程模型
├── 1:1 线程模型 (用户线程:内核线程)
├── 纤程 (Fibers) 支持
├── 线程池 API (Thread Pool API)
└── I/O 完成端口 (IOCP)
```

#### Linux

```text
Linux 线程模型
├── NPTL (Native POSIX Thread Library)
├── 1:1 线程模型
├── 轻量级进程 (LWP)
└── epoll/io_uring 异步 I/O
```

#### macOS

```text
macOS 线程模型
├── POSIX 线程 (pthread)
├── Grand Central Dispatch (GCD)
├── NSOperationQueue
└── kqueue 异步 I/O
```

---

### 1.2 同步原语实现差异

#### Mutex 实现

```rust
use std::sync::Mutex;

// Rust 的 Mutex 在不同平台有不同实现
fn mutex_example() {
    let m = Mutex::new(0);

    // Windows: 使用 SRWLock (Slim Reader/Writer Lock)
    // Linux: 使用 pthread_mutex
    // macOS: 使用 pthread_mutex

    *m.lock().unwrap() += 1;
}
```

#### 平台差异示例

```rust
#[cfg(target_os = "windows")]
fn platform_specific_mutex() {
    // Windows: Critical Section 性能更好
    println!("Using Windows SRWLock");
}

#[cfg(target_os = "linux")]
fn platform_specific_mutex() {
    // Linux: futex 系统调用
    println!("Using Linux futex");
}

#[cfg(target_os = "macos")]
fn platform_specific_mutex() {
    // macOS: pthread_mutex_t
    println!("Using macOS pthread_mutex");
}

fn main() {
    platform_specific_mutex();
}
```

---

### 1.3 性能特性对比

#### 线程创建开销

```rust
use std::thread;
use std::time::Instant;

fn benchmark_thread_creation() {
    let iterations = 1000;

    let start = Instant::now();
    for _ in 0..iterations {
        let handle = thread::spawn(|| {
            // 空线程
        });
        handle.join().unwrap();
    }
    let elapsed = start.elapsed();

    println!("Platform: {}", std::env::consts::OS);
    println!("Thread creation: {:?} per thread", elapsed / iterations);

    // 典型结果:
    // Windows: ~100-200μs
    // Linux: ~50-100μs
    // macOS: ~80-150μs
}

fn main() {
    benchmark_thread_creation();
}
```

#### 锁性能对比

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Instant;

fn benchmark_mutex() {
    let counter = Arc::new(Mutex::new(0u64));
    let iterations = 1000000;

    let start = Instant::now();

    let handles: Vec<_> = (0..4).map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            for _ in 0..iterations / 4 {
                *counter.lock().unwrap() += 1;
            }
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }

    let elapsed = start.elapsed();
    println!("Platform: {}", std::env::consts::OS);
    println!("Mutex ops: {:?}", elapsed);

    // 典型结果 (4线程竞争):
    // Windows: ~50-80ms
    // Linux: ~40-60ms
    // macOS: ~45-70ms
}

fn main() {
    benchmark_mutex();
}
```

---

## 2. Windows 平台特性

### 2.1 Windows 线程 API

#### 使用 winapi crate

```rust
// Cargo.toml
// [dependencies]
// winapi = { version = "0.3", features = ["processthreadsapi", "synchapi"] }

#[cfg(target_os = "windows")]
mod windows_threads {
    use winapi::um::processthreadsapi::{CreateThread, GetCurrentThreadId};
    use winapi::um::synchapi::WaitForSingleObject;
    use winapi::um::winbase::INFINITE;
    use std::ptr;

    pub unsafe fn create_native_thread() {
        extern "system" fn thread_proc(_: *mut winapi::ctypes::c_void) -> u32 {
            println!("Windows native thread: {}", GetCurrentThreadId());
            0
        }

        let handle = CreateThread(
            ptr::null_mut(),
            0,
            Some(thread_proc),
            ptr::null_mut(),
            0,
            ptr::null_mut(),
        );

        if !handle.is_null() {
            WaitForSingleObject(handle, INFINITE);
        }
    }
}

#[cfg(target_os = "windows")]
fn main() {
    unsafe {
        windows_threads::create_native_thread();
    }
}

#[cfg(not(target_os = "windows"))]
fn main() {
    println!("This example is Windows-only");
}
```

---

### 2.2 Windows 同步对象

#### Critical Section

```rust
#[cfg(target_os = "windows")]
mod windows_sync {
    use winapi::um::synchapi::{
        InitializeCriticalSection, DeleteCriticalSection,
        EnterCriticalSection, LeaveCriticalSection,
    };
    use winapi::um::winnt::CRITICAL_SECTION;
    use std::mem::MaybeUninit;

    pub struct CriticalSection {
        inner: CRITICAL_SECTION,
    }

    impl CriticalSection {
        pub fn new() -> Self {
            unsafe {
                let mut cs = MaybeUninit::uninit();
                InitializeCriticalSection(cs.as_mut_ptr());
                Self { inner: cs.assume_init() }
            }
        }

        pub fn enter(&mut self) {
            unsafe {
                EnterCriticalSection(&mut self.inner);
            }
        }

        pub fn leave(&mut self) {
            unsafe {
                LeaveCriticalSection(&mut self.inner);
            }
        }
    }

    impl Drop for CriticalSection {
        fn drop(&mut self) {
            unsafe {
                DeleteCriticalSection(&mut self.inner);
            }
        }
    }
}

#[cfg(target_os = "windows")]
fn main() {
    use windows_sync::CriticalSection;

    let mut cs = CriticalSection::new();
    cs.enter();
    println!("In critical section");
    cs.leave();
}

#[cfg(not(target_os = "windows"))]
fn main() {
    println!("This example is Windows-only");
}
```

---

### 2.3 Windows 特定优化

#### I/O 完成端口 (IOCP)

```rust
#[cfg(target_os = "windows")]
mod windows_iocp {
    use winapi::um::ioapiset::CreateIoCompletionPort;
    use winapi::um::handleapi::INVALID_HANDLE_VALUE;
    use std::ptr;

    pub struct IoCompletionPort {
        handle: winapi::um::winnt::HANDLE,
    }

    impl IoCompletionPort {
        pub fn new(thread_count: u32) -> Option<Self> {
            unsafe {
                let handle = CreateIoCompletionPort(
                    INVALID_HANDLE_VALUE,
                    ptr::null_mut(),
                    0,
                    thread_count,
                );

                if handle.is_null() {
                    None
                } else {
                    Some(Self { handle })
                }
            }
        }
    }

    // 注: 完整实现需要更多代码
}
```

---

## 3. Linux 平台特性

### 3.1 Linux 线程 API

#### 使用 nix crate

```rust
// Cargo.toml
// [dependencies]
// nix = { version = "0.27", features = ["pthread"] }

#[cfg(target_os = "linux")]
mod linux_threads {
    use nix::unistd::{getpid, gettid};
    use std::thread;

    pub fn show_thread_info() {
        println!("Process ID: {}", getpid());

        let handles: Vec<_> = (0..4).map(|i| {
            thread::spawn(move || {
                println!("Thread {}: TID = {}", i, gettid());
            })
        }).collect();

        for h in handles {
            h.join().unwrap();
        }
    }
}

#[cfg(target_os = "linux")]
fn main() {
    linux_threads::show_thread_info();
}

#[cfg(not(target_os = "linux"))]
fn main() {
    println!("This example is Linux-only");
}
```

---

### 3.2 Linux 同步原语

#### Futex (Fast Userspace Mutex)

```rust
#[cfg(target_os = "linux")]
mod linux_futex {
    use std::sync::atomic::{AtomicU32, Ordering};
    use std::time::Duration;

    pub struct FutexLock {
        state: AtomicU32,
    }

    impl FutexLock {
        pub fn new() -> Self {
            Self {
                state: AtomicU32::new(0),
            }
        }

        pub fn lock(&self) {
            loop {
                // 尝试获取锁
                if self.state
                    .compare_exchange(0, 1, Ordering::Acquire, Ordering::Relaxed)
                    .is_ok()
                {
                    return;
                }

                // 等待（简化版）
                std::thread::yield_now();
            }
        }

        pub fn unlock(&self) {
            self.state.store(0, Ordering::Release);
        }
    }
}

#[cfg(target_os = "linux")]
fn main() {
    use linux_futex::FutexLock;
    use std::sync::Arc;
    use std::thread;

    let lock = Arc::new(FutexLock::new());

    let handles: Vec<_> = (0..4).map(|i| {
        let lock = Arc::clone(&lock);
        thread::spawn(move || {
            lock.lock();
            println!("Thread {} acquired lock", i);
            std::thread::sleep(std::time::Duration::from_millis(10));
            lock.unlock();
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}

#[cfg(not(target_os = "linux"))]
fn main() {
    println!("This example is Linux-only");
}
```

---

### 3.3 Linux 特定优化

#### CPU 亲和性

```rust
#[cfg(target_os = "linux")]
mod linux_affinity {
    use nix::sched::{sched_setaffinity, CpuSet};
    use nix::unistd::Pid;
    use std::thread;

    pub fn set_thread_affinity(cpu_id: usize) -> nix::Result<()> {
        let mut cpuset = CpuSet::new();
        cpuset.set(cpu_id)?;
        sched_setaffinity(Pid::from_raw(0), &cpuset)
    }

    pub fn demo() {
        let handles: Vec<_> = (0..4).map(|i| {
            thread::spawn(move || {
                if let Err(e) = set_thread_affinity(i) {
                    eprintln!("Failed to set affinity: {}", e);
                } else {
                    println!("Thread {} pinned to CPU {}", i, i);
                }

                // 执行任务
                std::thread::sleep(std::time::Duration::from_secs(1));
            })
        }).collect();

        for h in handles {
            h.join().unwrap();
        }
    }
}

#[cfg(target_os = "linux")]
fn main() {
    linux_affinity::demo();
}

#[cfg(not(target_os = "linux"))]
fn main() {
    println!("This example is Linux-only");
}
```

---

## 4. macOS 平台特性

### 4.1 macOS 线程 API

#### 使用 dispatch crate

```rust
// Cargo.toml
// [dependencies]
// dispatch = "0.2"

#[cfg(target_os = "macos")]
mod macos_threads {
    use dispatch::{Queue, QueueAttribute};
    use std::thread;
    use std::time::Duration;

    pub fn demo_dispatch() {
        // 创建串行队列
        let serial_queue = Queue::create(
            "com.example.serial",
            QueueAttribute::Serial,
        );

        // 提交任务
        serial_queue.exec_async(|| {
            println!("Task 1 on serial queue");
        });

        serial_queue.exec_async(|| {
            println!("Task 2 on serial queue");
        });

        // 创建并发队列
        let concurrent_queue = Queue::create(
            "com.example.concurrent",
            QueueAttribute::Concurrent,
        );

        for i in 0..4 {
            concurrent_queue.exec_async(move || {
                println!("Task {} on concurrent queue", i);
                thread::sleep(Duration::from_millis(100));
            });
        }

        thread::sleep(Duration::from_secs(1));
    }
}

#[cfg(target_os = "macos")]
fn main() {
    macos_threads::demo_dispatch();
}

#[cfg(not(target_os = "macos"))]
fn main() {
    println!("This example is macOS-only");
}
```

---

### 4.2 Grand Central Dispatch

#### GCD 并行执行

```rust
#[cfg(target_os = "macos")]
mod macos_gcd {
    use dispatch::{Queue, QueuePriority};
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;

    pub fn parallel_computation() {
        let result = Arc::new(Mutex::new(Vec::new()));
        let queue = Queue::global(QueuePriority::Default);

        for i in 0..10 {
            let result = Arc::clone(&result);
            queue.exec_async(move || {
                // 计算
                let value = i * i;
                thread::sleep(Duration::from_millis(10));

                // 存储结果
                result.lock().unwrap().push(value);
            });
        }

        thread::sleep(Duration::from_secs(1));

        let r = result.lock().unwrap();
        println!("Results: {:?}", *r);
    }
}

#[cfg(target_os = "macos")]
fn main() {
    macos_gcd::parallel_computation();
}

#[cfg(not(target_os = "macos"))]
fn main() {
    println!("This example is macOS-only");
}
```

---

### 4.3 macOS 特定优化

#### QoS (Quality of Service)

```rust
#[cfg(target_os = "macos")]
mod macos_qos {
    use dispatch::{Queue, QueuePriority};

    pub fn demo_qos() {
        // 用户交互优先级
        let ui_queue = Queue::global(QueuePriority::High);
        ui_queue.exec_async(|| {
            println!("High priority: UI task");
        });

        // 后台任务
        let bg_queue = Queue::global(QueuePriority::Low);
        bg_queue.exec_async(|| {
            println!("Low priority: Background task");
        });
    }
}

#[cfg(target_os = "macos")]
fn main() {
    macos_qos::demo_qos();
    std::thread::sleep(std::time::Duration::from_secs(1));
}

#[cfg(not(target_os = "macos"))]
fn main() {
    println!("This example is macOS-only");
}
```

---

## 5. 条件编译策略

### 5.1 基本条件编译

#### 目标操作系统

```rust
#[cfg(target_os = "windows")]
fn get_thread_count() -> usize {
    std::env::var("NUMBER_OF_PROCESSORS")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(4)
}

#[cfg(target_os = "linux")]
fn get_thread_count() -> usize {
    std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4)
}

#[cfg(target_os = "macos")]
fn get_thread_count() -> usize {
    std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4)
}

#[cfg(not(any(target_os = "windows", target_os = "linux", target_os = "macos")))]
fn get_thread_count() -> usize {
    4  // 默认值
}

fn main() {
    println!("Thread count: {}", get_thread_count());
}
```

#### 目标架构

```rust
#[cfg(target_arch = "x86_64")]
fn arch_specific_optimization() {
    println!("Using x86_64 optimizations");
    // 可以使用 AVX2/AVX512 等指令
}

#[cfg(target_arch = "aarch64")]
fn arch_specific_optimization() {
    println!("Using ARM64 optimizations");
    // 可以使用 NEON 等指令
}

#[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64")))]
fn arch_specific_optimization() {
    println!("Using generic optimizations");
}

fn main() {
    arch_specific_optimization();
}
```

---

### 5.2 平台抽象层

#### 统一接口

```rust
// 定义统一的接口
pub trait PlatformThread {
    fn create<F>(f: F) -> Self
    where
        F: FnOnce() + Send + 'static;

    fn join(self);
}

// Windows 实现
#[cfg(target_os = "windows")]
pub struct ThreadHandle {
    inner: std::thread::JoinHandle<()>,
}

#[cfg(target_os = "windows")]
impl PlatformThread for ThreadHandle {
    fn create<F>(f: F) -> Self
    where
        F: FnOnce() + Send + 'static
    {
        Self {
            inner: std::thread::spawn(f),
        }
    }

    fn join(self) {
        self.inner.join().unwrap();
    }
}

// Linux 实现
#[cfg(target_os = "linux")]
pub struct ThreadHandle {
    inner: std::thread::JoinHandle<()>,
}

#[cfg(target_os = "linux")]
impl PlatformThread for ThreadHandle {
    fn create<F>(f: F) -> Self
    where
        F: FnOnce() + Send + 'static
    {
        Self {
            inner: std::thread::spawn(f),
        }
    }

    fn join(self) {
        self.inner.join().unwrap();
    }
}

// 使用统一接口
fn main() {
    let handle = ThreadHandle::create(|| {
        println!("Platform-agnostic thread");
    });

    handle.join();
}
```

---

### 5.3 特性检测

#### 运行时特性检测

```rust
use std::sync::OnceLock;

static CPU_FEATURES: OnceLock<CpuFeatures> = OnceLock::new();

#[derive(Debug)]
struct CpuFeatures {
    has_avx2: bool,
    has_sse4: bool,
    core_count: usize,
}

fn detect_cpu_features() -> CpuFeatures {
    CpuFeatures {
        has_avx2: is_x86_feature_detected!("avx2"),
        has_sse4: is_x86_feature_detected!("sse4.1"),
        core_count: std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(4),
    }
}

fn get_cpu_features() -> &'static CpuFeatures {
    CPU_FEATURES.get_or_init(detect_cpu_features)
}

fn main() {
    let features = get_cpu_features();
    println!("CPU Features: {:?}", features);

    if features.has_avx2 {
        println!("Can use AVX2 optimizations");
    }
}
```

---

## 6. 移动平台并发

### 6.1 Android 平台

#### JNI 集成

```rust
// 使用 jni crate
// [dependencies]
// jni = "0.21"

#[cfg(target_os = "android")]
mod android_threads {
    use jni::JNIEnv;
    use jni::objects::JClass;
    use jni::sys::jint;
    use std::thread;

    #[no_mangle]
    pub extern "C" fn Java_com_example_RustLib_startBackgroundTask(
        _env: JNIEnv,
        _class: JClass,
        iterations: jint,
    ) {
        thread::spawn(move || {
            for i in 0..iterations {
                // 执行后台任务
                println!("Android background task: {}", i);
                thread::sleep(std::time::Duration::from_millis(100));
            }
        });
    }
}
```

#### Android 线程优先级

```rust
#[cfg(target_os = "android")]
mod android_priority {
    use std::thread;

    pub fn set_thread_priority(priority: i32) {
        // Android 使用 setpriority 系统调用
        unsafe {
            libc::setpriority(
                libc::PRIO_PROCESS,
                0,  // 当前线程
                priority,
            );
        }
    }

    pub fn background_thread() {
        thread::spawn(|| {
            set_thread_priority(10);  // 降低优先级

            // 执行后台任务
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
            }
        });
    }
}
```

---

### 6.2 iOS 平台

#### iOS 线程配置

```rust
#[cfg(target_os = "ios")]
mod ios_threads {
    use std::thread;
    use std::time::Duration;

    pub fn configure_ios_thread() {
        // iOS 限制后台线程
        thread::spawn(|| {
            // 设置线程为后台 QoS
            unsafe {
                // 使用 iOS 的 QoS API
                // pthread_set_qos_class_self_np(...)
            }

            // 执行后台任务
            loop {
                thread::sleep(Duration::from_secs(1));
            }
        });
    }
}
```

#### iOS 后台执行限制

```rust
#[cfg(target_os = "ios")]
mod ios_background {
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;

    pub struct BackgroundTaskManager {
        tasks: Arc<Mutex<Vec<thread::JoinHandle<()>>>>,
    }

    impl BackgroundTaskManager {
        pub fn new() -> Self {
            Self {
                tasks: Arc::new(Mutex::new(Vec::new())),
            }
        }

        pub fn start_task<F>(&self, f: F)
        where
            F: FnOnce() + Send + 'static,
        {
            let handle = thread::spawn(f);
            self.tasks.lock().unwrap().push(handle);
        }

        pub fn wait_all(&self) {
            let mut tasks = self.tasks.lock().unwrap();
            while let Some(handle) = tasks.pop() {
                handle.join().unwrap();
            }
        }
    }
}
```

---

## 7. 跨平台最佳实践

### 实践原则

1. **优先使用 Rust 标准库**
   - `std::thread` 已处理大部分平台差异
   - `std::sync` 提供跨平台同步原语
   - 避免直接使用操作系统 API

2. **使用条件编译隔离平台特定代码**
   - 清晰标记 `#[cfg(target_os = "...")]`
   - 提供默认实现作为后备
   - 保持接口统一

3. **测试所有目标平台**
   - 使用 CI/CD 多平台测试
   - 注意性能差异
   - 验证功能正确性

4. **文档化平台差异**
   - 说明每个平台的行为
   - 标注性能特性
   - 提供平台特定的优化建议

### 完整示例

```rust
/// 跨平台线程池
pub struct CrossPlatformThreadPool {
    workers: Vec<std::thread::JoinHandle<()>>,
}

impl CrossPlatformThreadPool {
    pub fn new() -> Self {
        let thread_count = Self::optimal_thread_count();

        let mut workers = Vec::with_capacity(thread_count);
        for i in 0..thread_count {
            let handle = std::thread::spawn(move || {
                Self::configure_worker_thread(i);
                // 工作线程逻辑
            });
            workers.push(handle);
        }

        Self { workers }
    }

    #[cfg(target_os = "windows")]
    fn optimal_thread_count() -> usize {
        std::env::var("NUMBER_OF_PROCESSORS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(4)
    }

    #[cfg(not(target_os = "windows"))]
    fn optimal_thread_count() -> usize {
        std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(4)
    }

    #[cfg(target_os = "linux")]
    fn configure_worker_thread(id: usize) {
        // Linux: 设置 CPU 亲和性
        // ... 设置代码 ...
        println!("Linux worker {} configured", id);
    }

    #[cfg(target_os = "windows")]
    fn configure_worker_thread(id: usize) {
        // Windows: 设置线程优先级
        println!("Windows worker {} configured", id);
    }

    #[cfg(target_os = "macos")]
    fn configure_worker_thread(id: usize) {
        // macOS: 设置 QoS
        println!("macOS worker {} configured", id);
    }

    #[cfg(not(any(
        target_os = "linux",
        target_os = "windows",
        target_os = "macos"
    )))]
    fn configure_worker_thread(id: usize) {
        println!("Generic worker {} configured", id);
    }
}

impl Drop for CrossPlatformThreadPool {
    fn drop(&mut self) {
        // 等待所有线程完成
        while let Some(handle) = self.workers.pop() {
            handle.join().unwrap();
        }
    }
}

fn main() {
    println!("Creating cross-platform thread pool...");
    println!("Platform: {}", std::env::consts::OS);
    println!("Architecture: {}", std::env::consts::ARCH);

    let _pool = CrossPlatformThreadPool::new();

    std::thread::sleep(std::time::Duration::from_secs(1));
}
```

---

## 🔗 相关资源

### 核心文档

- [主索引导航](../tier_01_foundations/02_主索引导航.md)
- [高级并发模式](./01_高级并发模式.md)
- [系统编程优化](./02_系统编程优化.md)
- [性能工程实践](./03_性能工程实践.md)

### 外部资源

- [Rust Platform Support](https://doc.rust-lang.org/nightly/rustc/platform-support.html)
- [std::thread Documentation](https://doc.rust-lang.org/std/thread/)
- [The Rustonomicon - FFI](https://doc.rust-lang.org/nomicon/ffi.html)

---

**文档维护**: C05 Threads Team | **质量评分**: 95/100
**最后更新**: 2025-12-11 | **Rust 版本**: 1.92.0+
