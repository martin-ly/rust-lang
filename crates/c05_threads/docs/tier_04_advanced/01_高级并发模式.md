# C05 Tier 4 é«˜çº§ä¸»é¢˜ 01ï¼šé«˜çº§å¹¶å‘æ¨¡å¼

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 4 é«˜çº§ä¸»é¢˜ 01ï¼šé«˜çº§å¹¶å‘æ¨¡å¼](#c05-tier-4-é«˜çº§ä¸»é¢˜-01é«˜çº§å¹¶å‘æ¨¡å¼)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
    - [è¯æ˜æ ‘å›¾](#è¯æ˜æ ‘å›¾)
  - [1. å·¥ä½œçªƒå–ï¼ˆWork Stealingï¼‰](#1-å·¥ä½œçªƒå–work-stealing)
    - [1.1 åŸç†](#11-åŸç†)
    - [1.2 ç®€åŒ–å®ç°](#12-ç®€åŒ–å®ç°)
    - [1.3 Rayon çš„å·¥ä½œçªƒå–](#13-rayon-çš„å·¥ä½œçªƒå–)
  - [2. Actor æ¨¡å‹](#2-actor-æ¨¡å‹)
    - [2.1 åŸç†](#21-åŸç†)
    - [2.2 ç®€å•å®ç°](#22-ç®€å•å®ç°)
    - [2.3 ä½¿ç”¨ Actix](#23-ä½¿ç”¨-actix)
  - [3. Fork-Join å¹¶è¡Œ](#3-fork-join-å¹¶è¡Œ)
    - [3.1 åŸç†](#31-åŸç†)
  - [4. Map-Reduce æ¨¡å¼](#4-map-reduce-æ¨¡å¼)
    - [4.1 å¹¶è¡Œ Map-Reduce](#41-å¹¶è¡Œ-map-reduce)
  - [5. æµæ°´çº¿å¹¶è¡Œ](#5-æµæ°´çº¿å¹¶è¡Œ)
    - [5.1 å¤šé˜¶æ®µæµæ°´çº¿](#51-å¤šé˜¶æ®µæµæ°´çº¿)
  - [6. æ•°æ®å¹¶è¡Œ vs ä»»åŠ¡å¹¶è¡Œ](#6-æ•°æ®å¹¶è¡Œ-vs-ä»»åŠ¡å¹¶è¡Œ)
    - [6.1 æ•°æ®å¹¶è¡Œ](#61-æ•°æ®å¹¶è¡Œ)
    - [6.2 ä»»åŠ¡å¹¶è¡Œ](#62-ä»»åŠ¡å¹¶è¡Œ)
  - [7. å“åº”å¼ç¼–ç¨‹](#7-å“åº”å¼ç¼–ç¨‹)
    - [7.1 äº‹ä»¶é©±åŠ¨æ¨¡å¼](#71-äº‹ä»¶é©±åŠ¨æ¨¡å¼)
  - [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
    - [8.1 å¹¶è¡Œ Web çˆ¬è™«](#81-å¹¶è¡Œ-web-çˆ¬è™«)
  - [9. å‚è€ƒèµ„æº](#9-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æ¨èé˜…è¯»](#æ¨èé˜…è¯»)
    - [å†…éƒ¨æ–‡æ¡£](#å†…éƒ¨æ–‡æ¡£)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**é«˜çº§å¹¶å‘æ¨¡å¼ (Advanced Concurrency Patterns)**:

- **å®šä¹‰**: Rust 1.92.0 åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ä½¿ç”¨çš„é«˜çº§æ¨¡å¼å’Œç®—æ³•ï¼Œç”¨äºä¼˜åŒ–æ€§èƒ½å’Œè§£å†³å¤æ‚å¹¶å‘é—®é¢˜
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹ã€é«˜æ€§èƒ½è®¡ç®—
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: å·¥ä½œçªƒå–ã€Actoræ¨¡å‹ã€Fork-Joinã€Map-Reduceã€æµæ°´çº¿å¹¶è¡Œã€å“åº”å¼ç¼–ç¨‹

**å·¥ä½œçªƒå– (Work Stealing)**:

- **å®šä¹‰**: åŠ¨æ€è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œç©ºé—²çº¿ç¨‹ä»ç¹å¿™çº¿ç¨‹çš„é˜Ÿåˆ—ä¸­"çªƒå–"ä»»åŠ¡
- **ç±»å‹**: è°ƒåº¦ç®—æ³•
- **å±æ€§**: åŠ¨æ€è´Ÿè½½å‡è¡¡ã€è‡ªåŠ¨è°ƒåº¦ã€é«˜æ•ˆåˆ©ç”¨
- **å…³ç³»**: ä¸çº¿ç¨‹æ± ã€å¹¶è¡Œè®¡ç®—ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **åŠ¨æ€è´Ÿè½½å‡è¡¡**: è‡ªåŠ¨åˆ†é…ä»»åŠ¡
- **é«˜æ•ˆåˆ©ç”¨**: å……åˆ†åˆ©ç”¨æ‰€æœ‰çº¿ç¨‹
- **ä½å¼€é”€**: çªƒå–æ“ä½œå¼€é”€å°
- **å¯æ‰©å±•æ€§**: æ”¯æŒå¤§é‡çº¿ç¨‹

**æ€§èƒ½ç‰¹å¾**:

- **è´Ÿè½½å‡è¡¡**: è‡ªåŠ¨å¹³è¡¡çº¿ç¨‹è´Ÿè½½
- **é€‚ç”¨åœºæ™¯**: å¹¶è¡Œè®¡ç®—ã€ä»»åŠ¡è°ƒåº¦ã€æ•°æ®å¤„ç†

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- å·¥ä½œçªƒå– --[is-a]--> è°ƒåº¦ç®—æ³•
- Actor æ¨¡å‹ --[is-a]--> å¹¶å‘æ¨¡å¼

**ç»„åˆå…³ç³»**:

- å¹¶è¡Œç¨‹åº --[uses]--> é«˜çº§å¹¶å‘æ¨¡å¼
- Rayon --[uses]--> å·¥ä½œçªƒå–

**ä¾èµ–å…³ç³»**:

- é«˜çº§å¹¶å‘æ¨¡å¼ --[depends-on]--> çº¿ç¨‹æ”¯æŒ
- å·¥ä½œçªƒå– --[depends-on]--> ä»»åŠ¡é˜Ÿåˆ—

### æ€ç»´å¯¼å›¾

```text
é«˜çº§å¹¶å‘æ¨¡å¼
â”‚
â”œâ”€â”€ å·¥ä½œçªƒå–
â”‚   â””â”€â”€ åŠ¨æ€è´Ÿè½½å‡è¡¡
â”œâ”€â”€ Actor æ¨¡å‹
â”‚   â””â”€â”€ æ¶ˆæ¯ä¼ é€’
â”œâ”€â”€ Fork-Join å¹¶è¡Œ
â”‚   â””â”€â”€ åˆ†æ²»å¹¶è¡Œ
â”œâ”€â”€ Map-Reduce æ¨¡å¼
â”‚   â””â”€â”€ æ•°æ®å¹¶è¡Œ
â”œâ”€â”€ æµæ°´çº¿å¹¶è¡Œ
â”‚   â””â”€â”€ å¤šé˜¶æ®µå¤„ç†
â””â”€â”€ å“åº”å¼ç¼–ç¨‹
    â””â”€â”€ äº‹ä»¶é©±åŠ¨
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| å¹¶å‘æ¨¡å¼       | æ€§èƒ½ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯   | çº¿ç¨‹å®‰å…¨ | Rust 1.92.0 |
| -------------- | ---- | ------ | ---------- | -------- | ----------- |
| **å·¥ä½œçªƒå–**   | é«˜   | ä¸­     | å¹¶è¡Œè®¡ç®—   | âœ…       | âœ… æ”¹è¿›     |
| **Actor æ¨¡å‹** | ä¸­   | é«˜     | åˆ†å¸ƒå¼ç³»ç»Ÿ | âœ…       | âœ…          |
| **Fork-Join**  | é«˜   | ä½     | åˆ†æ²»ç®—æ³•   | âœ…       | âœ…          |
| **Map-Reduce** | é«˜   | ä¸­     | å¤§æ•°æ®å¤„ç† | âœ…       | âœ…          |
| **æµæ°´çº¿å¹¶è¡Œ** | ä¸­   | ä¸­     | å¤šé˜¶æ®µå¤„ç† | âœ…       | âœ…          |
| **å“åº”å¼ç¼–ç¨‹** | ä¸­   | é«˜     | äº‹ä»¶é©±åŠ¨   | âœ…       | âœ…          |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©å¹¶å‘æ¨¡å¼
â”‚
â”œâ”€â”€ æ˜¯å¦éœ€è¦åŠ¨æ€è´Ÿè½½å‡è¡¡ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ å·¥ä½œçªƒå–
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­åˆ¤æ–­
â”‚       â”œâ”€â”€ æ˜¯å¦éœ€è¦æ¶ˆæ¯ä¼ é€’ï¼Ÿ
â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ Actor æ¨¡å‹
â”‚       â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­åˆ¤æ–­
â”‚       â”‚       â”œâ”€â”€ æ˜¯å¦éœ€è¦åˆ†æ²»ï¼Ÿ
â”‚       â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ Fork-Join
â”‚       â”‚       â”‚   â””â”€â”€ å¦ â†’ Map-Reduce
â”‚       â”‚       â””â”€â”€ æ˜¯å¦éœ€è¦å¤šé˜¶æ®µå¤„ç†ï¼Ÿ
â”‚       â”‚           â”œâ”€â”€ æ˜¯ â†’ æµæ°´çº¿å¹¶è¡Œ
â”‚       â”‚           â””â”€â”€ å¦ â†’ å“åº”å¼ç¼–ç¨‹
```

### è¯æ˜æ ‘å›¾

```text
å¹¶å‘å®‰å…¨æ€§è¯æ˜
â”‚
â”œâ”€â”€ æ•°æ®ç«äº‰é¢„é˜²
â”‚   â”œâ”€â”€ æ‰€æœ‰æƒç³»ç»Ÿ
â”‚   â””â”€â”€ å€Ÿç”¨æ£€æŸ¥å™¨
â”œâ”€â”€ æ­»é”é¢„é˜²
â”‚   â”œâ”€â”€ é”é¡ºåº
â”‚   â””â”€â”€ æ— é”æ•°æ®ç»“æ„
â””â”€â”€ å†…å­˜å®‰å…¨
    â”œâ”€â”€ ç±»å‹ç³»ç»Ÿ
    â””â”€â”€ ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ
```

---

## 1. å·¥ä½œçªƒå–ï¼ˆWork Stealingï¼‰

### 1.1 åŸç†

å·¥ä½œçªƒå–æ˜¯ä¸€ç§åŠ¨æ€è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œç©ºé—²çº¿ç¨‹å¯ä»¥ä»ç¹å¿™çº¿ç¨‹çš„é˜Ÿåˆ—ä¸­"çªƒå–"ä»»åŠ¡ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å·¥ä½œçªƒå–è°ƒåº¦å™¨                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚  Thread 1: [Task1][Task2][Task3][Task4]         â”‚
â”‚                                      â–²           â”‚
â”‚  Thread 2: []  (ç©ºé—²)                 â”‚           â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€ çªƒå– â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                  â”‚
â”‚  Thread 3: [TaskA][TaskB]                       â”‚
â”‚                         â–²                        â”‚
â”‚  Thread 4: []  (ç©ºé—²)   â”‚                        â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç®€åŒ–å®ç°

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use std::thread;

type Task = Box<dyn FnOnce() + Send>;

struct Worker {
    id: usize,
    queue: Arc<Mutex<VecDeque<Task>>>,
}

impl Worker {
    fn new(id: usize) -> Self {
        Worker {
            id,
            queue: Arc::new(Mutex::new(VecDeque::new())),
        }
    }

    fn push(&self, task: Task) {
        self.queue.lock().unwrap().push_back(task);
    }

    fn pop(&self) -> Option<Task> {
        self.queue.lock().unwrap().pop_front()
    }

    fn steal(&self) -> Option<Task> {
        self.queue.lock().unwrap().pop_back()
    }
}

struct WorkStealingPool {
    workers: Vec<Worker>,
}

impl WorkStealingPool {
    fn new(size: usize) -> Self {
        let workers: Vec<_> = (0..size)
            .map(|id| Worker::new(id))
            .collect();

        WorkStealingPool { workers }
    }

    fn submit(&self, worker_id: usize, task: Task) {
        self.workers[worker_id % self.workers.len()].push(task);
    }

    fn run(&self) {
        let workers_ref: Vec<_> = self.workers.iter()
            .map(|w| (w.id, Arc::clone(&w.queue)))
            .collect();

        let handles: Vec<_> = workers_ref.into_iter()
            .map(|(id, queue)| {
                let all_queues: Vec<_> = self.workers.iter()
                    .map(|w| Arc::clone(&w.queue))
                    .collect();

                thread::spawn(move || {
                    loop {
                        // 1. å°è¯•ä»è‡ªå·±çš„é˜Ÿåˆ—è·å–ä»»åŠ¡
                        if let Some(task) = queue.lock().unwrap().pop_front() {
                            task();
                            continue;
                        }

                        // 2. å°è¯•çªƒå–å…¶ä»–çº¿ç¨‹çš„ä»»åŠ¡
                        let mut found = false;
                        for other_queue in &all_queues {
                            if let Some(task) = other_queue.lock().unwrap().pop_back() {
                                println!("Worker {} stole task", id);
                                task();
                                found = true;
                                break;
                            }
                        }

                        if !found {
                            break; // æ‰€æœ‰é˜Ÿåˆ—éƒ½ç©ºäº†
                        }
                    }
                })
            })
            .collect();

        for handle in handles {
            handle.join().unwrap();
        }
    }
}

fn main() {
    let pool = WorkStealingPool::new(4);

    // æäº¤ä»»åŠ¡åˆ°ä¸åŒçš„worker
    for i in 0..20 {
        pool.submit(i % 2, Box::new(move || {
            println!("Task {} executing", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }));
    }

    pool.run();
}
```

### 1.3 Rayon çš„å·¥ä½œçªƒå–

Rayon å†…éƒ¨ä½¿ç”¨å·¥ä½œçªƒå–ç®—æ³•ï¼š

```rust
use rayon::prelude::*;

fn main() {
    let data: Vec<_> = (0..1000).collect();

    // Rayon è‡ªåŠ¨ä½¿ç”¨å·¥ä½œçªƒå–
    let sum: i32 = data.par_iter()
        .map(|&x| x * x)
        .sum();

    println!("Sum: {}", sum);
}
```

---

## 2. Actor æ¨¡å‹

### 2.1 åŸç†

Actor æ¨¡å‹ä¸­ï¼Œæ¯ä¸ª actor æ˜¯ç‹¬ç«‹çš„è®¡ç®—å•å…ƒï¼Œé€šè¿‡æ¶ˆæ¯ä¼ é€’é€šä¿¡ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Actor ç³»ç»Ÿ                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  msg1  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Actor A  â”‚ â”€â”€â”€â”€â–º â”‚ Actor B  â”‚                 â”‚
â”‚  â”‚          â”‚        â”‚          â”‚                 â”‚
â”‚  â”‚ state    â”‚ â—„â”€â”€â”€â”€ â”‚ state    â”‚                 â”‚
â”‚  â”‚ behavior â”‚  msg2  â”‚ behavior â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚       â”‚                    â”‚                       â”‚
â”‚       â”‚ msg3               â”‚ msg4                  â”‚
â”‚       â–¼                    â–¼                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Actor C  â”‚        â”‚ Actor D  â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ç®€å•å®ç°

```rust
use std::sync::mpsc::{self, Sender, Receiver};
use std::thread;

enum Message {
    Increment(i32),
    GetValue(Sender<i32>),
    Stop,
}

struct CounterActor {
    receiver: Receiver<Message>,
    value: i32,
}

impl CounterActor {
    fn new(receiver: Receiver<Message>) -> Self {
        CounterActor {
            receiver,
            value: 0,
        }
    }

    fn run(&mut self) {
        loop {
            match self.receiver.recv() {
                Ok(Message::Increment(n)) => {
                    self.value += n;
                    println!("Counter value: {}", self.value);
                }
                Ok(Message::GetValue(reply)) => {
                    reply.send(self.value).unwrap();
                }
                Ok(Message::Stop) => {
                    println!("Actor stopping");
                    break;
                }
                Err(_) => break,
            }
        }
    }
}

struct CounterActorHandle {
    sender: Sender<Message>,
}

impl CounterActorHandle {
    fn spawn() -> Self {
        let (tx, rx) = mpsc::channel();

        thread::spawn(move || {
            let mut actor = CounterActor::new(rx);
            actor.run();
        });

        CounterActorHandle { sender: tx }
    }

    fn increment(&self, n: i32) {
        self.sender.send(Message::Increment(n)).unwrap();
    }

    fn get_value(&self) -> i32 {
        let (tx, rx) = mpsc::channel();
        self.sender.send(Message::GetValue(tx)).unwrap();
        rx.recv().unwrap()
    }

    fn stop(&self) {
        self.sender.send(Message::Stop).unwrap();
    }
}

fn main() {
    let actor = CounterActorHandle::spawn();

    actor.increment(5);
    actor.increment(10);

    println!("Value: {}", actor.get_value());

    actor.stop();
    thread::sleep(std::time::Duration::from_millis(100));
}
```

### 2.3 ä½¿ç”¨ Actix

```rust
// ä½¿ç”¨ actix crate
use actix::prelude::*;

#[derive(Message)]
#[rtype(result = "i32")]
struct GetValue;

#[derive(Message)]
#[rtype(result = "()")]
struct Increment(i32);

struct Counter {
    value: i32,
}

impl Actor for Counter {
    type Context = Context<Self>;
}

impl Handler<Increment> for Counter {
    type Result = ();

    fn handle(&mut self, msg: Increment, _ctx: &mut Context<Self>) {
        self.value += msg.0;
    }
}

impl Handler<GetValue> for Counter {
    type Result = i32;

    fn handle(&mut self, _msg: GetValue, _ctx: &mut Context<Self>) -> i32 {
        self.value
    }
}

#[actix::main]
async fn main() {
    let addr = Counter { value: 0 }.start();

    addr.send(Increment(5)).await.unwrap();
    addr.send(Increment(10)).await.unwrap();

    let value = addr.send(GetValue).await.unwrap();
    println!("Value: {}", value);
}
```

---

## 3. Fork-Join å¹¶è¡Œ

### 3.1 åŸç†

å°†å¤§ä»»åŠ¡åˆ†è§£ä¸ºå°ä»»åŠ¡ï¼ˆForkï¼‰ï¼Œå¹¶è¡Œæ‰§è¡Œååˆå¹¶ç»“æœï¼ˆJoinï¼‰ã€‚

```rust
use rayon::prelude::*;

fn parallel_sum(data: &[i32]) -> i32 {
    const THRESHOLD: usize = 1000;

    if data.len() <= THRESHOLD {
        // Base case: ä¸²è¡Œæ±‚å’Œ
        data.iter().sum()
    } else {
        // Recursive case: Fork-Join
        let mid = data.len() / 2;
        let (left, right) = data.split_at(mid);

        let (sum_left, sum_right) = rayon::join(
            || parallel_sum(left),
            || parallel_sum(right)
        );

        sum_left + sum_right
    }
}

fn main() {
    let data: Vec<i32> = (0..10_000_000).collect();

    let start = std::time::Instant::now();
    let sum = parallel_sum(&data);
    println!("Sum: {}, Time: {:?}", sum, start.elapsed());
}
```

---

## 4. Map-Reduce æ¨¡å¼

### 4.1 å¹¶è¡Œ Map-Reduce

```rust
use rayon::prelude::*;
use std::collections::HashMap;

fn word_count(documents: &[String]) -> HashMap<String, usize> {
    documents.par_iter()
        // Map: æ¯ä¸ªæ–‡æ¡£ç”Ÿæˆ (word, 1) å¯¹
        .flat_map(|doc| {
            doc.split_whitespace()
                .map(|word| (word.to_lowercase(), 1))
                .collect::<Vec<_>>()
        })
        // Reduce: åˆå¹¶è®¡æ•°
        .fold(
            || HashMap::new(),
            |mut acc, (word, count)| {
                *acc.entry(word).or_insert(0) += count;
                acc
            }
        )
        .reduce(
            || HashMap::new(),
            |mut acc, map| {
                for (word, count) in map {
                    *acc.entry(word).or_insert(0) += count;
                }
                acc
            }
        )
}

fn main() {
    let documents = vec![
        "hello world".to_string(),
        "hello rust".to_string(),
        "world of rust".to_string(),
    ];

    let counts = word_count(&documents);
    println!("{:?}", counts);
}
```

---

## 5. æµæ°´çº¿å¹¶è¡Œ

### 5.1 å¤šé˜¶æ®µæµæ°´çº¿

```rust
use crossbeam::channel;
use std::thread;

fn pipeline_example() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();
    let (tx3, rx3) = channel::unbounded();

    // Stage 1: ç”Ÿæˆæ•°æ®
    let stage1 = thread::spawn(move || {
        for i in 0..100 {
            tx1.send(i).unwrap();
        }
    });

    // Stage 2: å¤„ç†æ•°æ®ï¼ˆå¹³æ–¹ï¼‰
    let stage2 = thread::spawn(move || {
        for i in rx1 {
            tx2.send(i * i).unwrap();
        }
    });

    // Stage 3: è¿‡æ»¤æ•°æ®ï¼ˆåªä¿ç•™å¶æ•°ï¼‰
    let stage3 = thread::spawn(move || {
        for i in rx2 {
            if i % 2 == 0 {
                tx3.send(i).unwrap();
            }
        }
    });

    // æ”¶é›†ç»“æœ
    let collector = thread::spawn(move || {
        let results: Vec<_> = rx3.iter().collect();
        results
    });

    stage1.join().unwrap();
    stage2.join().unwrap();
    stage3.join().unwrap();

    let results = collector.join().unwrap();
    println!("Results: {:?}", &results[..10]);
}

fn main() {
    pipeline_example();
}
```

---

## 6. æ•°æ®å¹¶è¡Œ vs ä»»åŠ¡å¹¶è¡Œ

### 6.1 æ•°æ®å¹¶è¡Œ

å¯¹ç›¸åŒæ“ä½œåº”ç”¨äºä¸åŒæ•°æ®ï¼š

```rust
use rayon::prelude::*;

fn data_parallelism() {
    let data: Vec<_> = (0..1000).collect();

    // æ•°æ®å¹¶è¡Œï¼šåŒä¸€æ“ä½œåº”ç”¨äºæ‰€æœ‰æ•°æ®
    let results: Vec<_> = data.par_iter()
        .map(|&x| x * x)
        .collect();

    println!("First 10 results: {:?}", &results[..10]);
}
```

### 6.2 ä»»åŠ¡å¹¶è¡Œ

ä¸åŒä»»åŠ¡å¹¶è¡Œæ‰§è¡Œï¼š

```rust
use rayon;

fn task_parallelism() {
    // ä»»åŠ¡å¹¶è¡Œï¼šä¸åŒçš„ä»»åŠ¡åŒæ—¶æ‰§è¡Œ
    let (result1, result2, result3) = rayon::join(
        || expensive_computation_1(),
        || rayon::join(
            || expensive_computation_2(),
            || expensive_computation_3()
        )
    );

    println!("Results: {}, {}, {}", result1, result2.0, result2.1);
}

fn expensive_computation_1() -> i32 {
    std::thread::sleep(std::time::Duration::from_millis(100));
    42
}

fn expensive_computation_2() -> i32 {
    std::thread::sleep(std::time::Duration::from_millis(100));
    100
}

fn expensive_computation_3() -> i32 {
    std::thread::sleep(std::time::Duration::from_millis(100));
    200
}

fn main() {
    task_parallelism();
}
```

---

## 7. å“åº”å¼ç¼–ç¨‹

### 7.1 äº‹ä»¶é©±åŠ¨æ¨¡å¼

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

enum Event {
    UserInput(String),
    TimerTick,
    NetworkData(Vec<u8>),
}

fn event_loop() {
    let (tx, rx) = mpsc::channel();

    // ç”¨æˆ·è¾“å…¥çº¿ç¨‹
    let tx_input = tx.clone();
    thread::spawn(move || {
        for i in 0..5 {
            thread::sleep(Duration::from_millis(500));
            tx_input.send(Event::UserInput(format!("Input {}", i))).unwrap();
        }
    });

    // å®šæ—¶å™¨çº¿ç¨‹
    let tx_timer = tx.clone();
    thread::spawn(move || {
        for _ in 0..10 {
            thread::sleep(Duration::from_millis(200));
            tx_timer.send(Event::TimerTick).unwrap();
        }
    });

    // äº‹ä»¶å¤„ç†å¾ªç¯
    drop(tx);
    for event in rx {
        match event {
            Event::UserInput(input) => println!("Received input: {}", input),
            Event::TimerTick => println!("Timer tick"),
            Event::NetworkData(data) => println!("Network data: {} bytes", data.len()),
        }
    }
}

fn main() {
    event_loop();
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### 8.1 å¹¶è¡Œ Web çˆ¬è™«

```rust
use rayon::prelude::*;
use std::collections::HashSet;
use std::sync::{Arc, Mutex};

struct WebCrawler {
    visited: Arc<Mutex<HashSet<String>>>,
}

impl WebCrawler {
    fn new() -> Self {
        WebCrawler {
            visited: Arc::new(Mutex::new(HashSet::new())),
        }
    }

    fn crawl(&self, urls: Vec<String>) -> Vec<String> {
        urls.par_iter()
            .flat_map(|url| {
                // æ£€æŸ¥æ˜¯å¦å·²è®¿é—®
                {
                    let mut visited = self.visited.lock().unwrap();
                    if visited.contains(url) {
                        return vec![];
                    }
                    visited.insert(url.clone());
                }

                // æ¨¡æ‹Ÿçˆ¬å–é¡µé¢
                println!("Crawling: {}", url);
                std::thread::sleep(std::time::Duration::from_millis(100));

                // è¿”å›å‘ç°çš„æ–°URL
                vec![
                    format!("{}/page1", url),
                    format!("{}/page2", url),
                ]
            })
            .collect()
    }
}

fn main() {
    let crawler = WebCrawler::new();
    let initial_urls = vec!["http://example.com".to_string()];

    let new_urls = crawler.crawl(initial_urls);
    println!("Found {} new URLs", new_urls.len());
}
```

---

## 9. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [Rayon Documentation](https://docs.rs/rayon)
- [Actix Documentation](https://actix.rs/)

### æ¨èé˜…è¯»

- "The Art of Multiprocessor Programming"
- "Parallel Programming Patterns"

### å†…éƒ¨æ–‡æ¡£

- [â† è¿”å› Tier 3ï¼šå‚è€ƒæ–‡æ¡£](../tier_03_references/)
- [â†’ ä¸‹ä¸€ç¯‡ï¼šNUMA æ¶æ„ä¼˜åŒ–](./02_NUMAæ¶æ„ä¼˜åŒ–.md)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
