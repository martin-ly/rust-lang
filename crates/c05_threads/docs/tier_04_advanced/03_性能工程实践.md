# æ€§èƒ½å·¥ç¨‹å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: Rust 1.90+ | **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **æ–‡æ¡£å±‚çº§**: Tier 4 - é«˜çº§ä¸»é¢˜ | **éš¾åº¦**: â­â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [æ€§èƒ½å·¥ç¨‹å®è·µ](#æ€§èƒ½å·¥ç¨‹å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. æ€§èƒ½åˆ†æå·¥å…·é“¾](#1-æ€§èƒ½åˆ†æå·¥å…·é“¾)
    - [1.1 Linux perf å·¥å…·](#11-linux-perf-å·¥å…·)
      - [åŸºæœ¬ç”¨æ³•](#åŸºæœ¬ç”¨æ³•)
      - [Rust ç¨‹åºä¼˜åŒ–](#rust-ç¨‹åºä¼˜åŒ–)
      - [perf åˆ†æè¾“å‡º](#perf-åˆ†æè¾“å‡º)
    - [1.2 Valgrind å¥—ä»¶](#12-valgrind-å¥—ä»¶)
      - [Memcheck (å†…å­˜æ£€æµ‹)](#memcheck-å†…å­˜æ£€æµ‹)
      - [Cachegrind (ç¼“å­˜åˆ†æ)](#cachegrind-ç¼“å­˜åˆ†æ)
      - [Rust ç¤ºä¾‹](#rust-ç¤ºä¾‹)
    - [1.3 flamegraph ç«ç„°å›¾](#13-flamegraph-ç«ç„°å›¾)
      - [å®‰è£…å’Œä½¿ç”¨](#å®‰è£…å’Œä½¿ç”¨)
      - [Rust ç¤ºä¾‹1](#rust-ç¤ºä¾‹1)
      - [ç«ç„°å›¾è§£è¯»](#ç«ç„°å›¾è§£è¯»)
    - [1.4 Rust ä¸“ç”¨å·¥å…·](#14-rust-ä¸“ç”¨å·¥å…·)
      - [cargo-bench](#cargo-bench)
      - [cargo-bloat](#cargo-bloat)
      - [cargo-asm](#cargo-asm)
  - [2. CPU Profiling å®æˆ˜](#2-cpu-profiling-å®æˆ˜)
    - [2.1 é‡‡æ ·å¼ Profiling](#21-é‡‡æ ·å¼-profiling)
      - [ä½¿ç”¨ pprof](#ä½¿ç”¨-pprof)
    - [2.2 æ’æ¡©å¼ Profiling](#22-æ’æ¡©å¼-profiling)
      - [æ‰‹åŠ¨æ’æ¡©](#æ‰‹åŠ¨æ’æ¡©)
    - [2.3 çƒ­ç‚¹åˆ†æ](#23-çƒ­ç‚¹åˆ†æ)
      - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
      - [ä¼˜åŒ–å](#ä¼˜åŒ–å)
  - [3. å†…å­˜ Profiling å®æˆ˜](#3-å†…å­˜-profiling-å®æˆ˜)
    - [3.1 å†…å­˜æ³„æ¼æ£€æµ‹](#31-å†…å­˜æ³„æ¼æ£€æµ‹)
      - [ä½¿ç”¨ Valgrind](#ä½¿ç”¨-valgrind)
    - [3.2 å†…å­˜åˆ†é…åˆ†æ](#32-å†…å­˜åˆ†é…åˆ†æ)
      - [ä½¿ç”¨ jemalloc profiling](#ä½¿ç”¨-jemalloc-profiling)
    - [3.3 å †åˆ†æ](#33-å †åˆ†æ)
      - [è‡ªå®šä¹‰åˆ†é…è¿½è¸ª](#è‡ªå®šä¹‰åˆ†é…è¿½è¸ª)
  - [4. é”ç«äº‰åˆ†æä¸ä¼˜åŒ–](#4-é”ç«äº‰åˆ†æä¸ä¼˜åŒ–)
    - [4.1 é”ç«äº‰æ£€æµ‹](#41-é”ç«äº‰æ£€æµ‹)
      - [ä½¿ç”¨ parking\_lot çš„ç»Ÿè®¡åŠŸèƒ½](#ä½¿ç”¨-parking_lot-çš„ç»Ÿè®¡åŠŸèƒ½)
    - [4.2 é”ç«äº‰å¯è§†åŒ–](#42-é”ç«äº‰å¯è§†åŒ–)
      - [è‡ªå®šä¹‰é”ç›‘æ§](#è‡ªå®šä¹‰é”ç›‘æ§)
    - [4.3 ä¼˜åŒ–ç­–ç•¥](#43-ä¼˜åŒ–ç­–ç•¥)
      - [åˆ†ç‰‡é” (Lock Striping)](#åˆ†ç‰‡é”-lock-striping)
  - [5. æ€§èƒ½å›å½’æµ‹è¯•](#5-æ€§èƒ½å›å½’æµ‹è¯•)
    - [5.1 åŸºå‡†æµ‹è¯•æ¡†æ¶](#51-åŸºå‡†æµ‹è¯•æ¡†æ¶)
      - [ä½¿ç”¨ Criterion.rs](#ä½¿ç”¨-criterionrs)
    - [5.2 CI/CD é›†æˆ](#52-cicd-é›†æˆ)
      - [GitHub Actions é…ç½®](#github-actions-é…ç½®)
    - [5.3 æ€§èƒ½ç›‘æ§](#53-æ€§èƒ½ç›‘æ§)
      - [è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§](#è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§)
  - [6. ä¼˜åŒ–è¿­ä»£æµç¨‹](#6-ä¼˜åŒ–è¿­ä»£æµç¨‹)
    - [6.1 æ€§èƒ½ä¼˜åŒ–æ–¹æ³•è®º](#61-æ€§èƒ½ä¼˜åŒ–æ–¹æ³•è®º)
      - [ä¼˜åŒ–æµç¨‹](#ä¼˜åŒ–æµç¨‹)
      - [å®æˆ˜æ£€æŸ¥æ¸…å•](#å®æˆ˜æ£€æŸ¥æ¸…å•)
    - [6.2 å®Œæ•´ä¼˜åŒ–æ¡ˆä¾‹](#62-å®Œæ•´ä¼˜åŒ–æ¡ˆä¾‹)
      - [åŸå§‹ç‰ˆæœ¬ï¼ˆæ…¢ï¼‰](#åŸå§‹ç‰ˆæœ¬æ…¢)
      - [ä¼˜åŒ–ç‰ˆæœ¬ 1ï¼šæ‰¹é‡æ“ä½œ](#ä¼˜åŒ–ç‰ˆæœ¬-1æ‰¹é‡æ“ä½œ)
      - [ä¼˜åŒ–ç‰ˆæœ¬ 2ï¼šæ— é”è®¾è®¡](#ä¼˜åŒ–ç‰ˆæœ¬-2æ— é”è®¾è®¡)
      - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [æ€§èƒ½å·¥ç¨‹åŸåˆ™](#æ€§èƒ½å·¥ç¨‹åŸåˆ™)
    - [å·¥å…·é€‰æ‹©å»ºè®®](#å·¥å…·é€‰æ‹©å»ºè®®)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
    - [æ ¸å¿ƒæ–‡æ¡£](#æ ¸å¿ƒæ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ğŸ¯ æ¦‚è¿°

æ€§èƒ½å·¥ç¨‹æ˜¯ç³»ç»ŸåŒ–ã€æ•°æ®é©±åŠ¨çš„æ€§èƒ½ä¼˜åŒ–å®è·µã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»ï¼š

- **æ€§èƒ½åˆ†æå·¥å…·é“¾**ï¼šperfã€Valgrindã€flamegraph ç­‰å·¥å…·çš„ä½¿ç”¨
- **CPU/å†…å­˜ Profiling**ï¼šå®šä½æ€§èƒ½ç“¶é¢ˆçš„æ–¹æ³•
- **é”ç«äº‰åˆ†æ**ï¼šæ£€æµ‹å’Œä¼˜åŒ–å¹¶å‘ç“¶é¢ˆ
- **æ€§èƒ½å›å½’æµ‹è¯•**ï¼šç¡®ä¿æ€§èƒ½ä¸é€€åŒ–
- **ä¼˜åŒ–è¿­ä»£æµç¨‹**ï¼šç³»ç»ŸåŒ–çš„æ€§èƒ½å·¥ç¨‹æ–¹æ³•è®º

---

## 1. æ€§èƒ½åˆ†æå·¥å…·é“¾

### 1.1 Linux perf å·¥å…·

**perf** æ˜¯ Linux å†…æ ¸è‡ªå¸¦çš„æ€§èƒ½åˆ†æå·¥å…·ï¼ŒåŠŸèƒ½å¼ºå¤§ã€‚

#### åŸºæœ¬ç”¨æ³•

```bash
# è®°å½•ç¨‹åºæ‰§è¡Œè¿‡ç¨‹
perf record -g ./target/release/my_program

# æŸ¥çœ‹æŠ¥å‘Š
perf report

# å®æ—¶ç›‘æ§
perf top

# ç»Ÿè®¡ä¿¡æ¯
perf stat ./target/release/my_program
```

#### Rust ç¨‹åºä¼˜åŒ–

```rust
// Cargo.toml
[profile.release]
debug = true  // ä¿ç•™è°ƒè¯•ä¿¡æ¯ç”¨äº profiling

// ç¤ºä¾‹ï¼šæ€§èƒ½çƒ­ç‚¹æ£€æµ‹
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![0u64; 1000000]));
    let mut handles = vec![];

    for i in 0..8 {
        let data = Arc::clone(&data);
        handles.push(thread::spawn(move || {
            for _ in 0..10000 {
                let mut v = data.lock().unwrap();
                v[i * 125000] += 1;  // é«˜ç«äº‰ç‚¹
            }
        }));
    }

    for h in handles {
        h.join().unwrap();
    }
}
```

#### perf åˆ†æè¾“å‡º

```text
# perf record -g -F 99 ./target/release/example
# perf report --stdio

# Overhead  Command   Shared Object       Symbol
# ........  ........  ..................  .......................
#
    45.23%  example   example             [.] std::sync::Mutex::lock
    12.45%  example   [kernel]            [k] _raw_spin_lock
     8.76%  example   example             [.] alloc::vec::Vec::push
     3.21%  example   libc.so.6           [.] pthread_mutex_lock
```

---

### 1.2 Valgrind å¥—ä»¶

**Valgrind** æä¾›å†…å­˜æ³„æ¼ã€ç¼“å­˜åˆ†æç­‰å¤šç§å·¥å…·ã€‚

#### Memcheck (å†…å­˜æ£€æµ‹)

```bash
# æ£€æµ‹å†…å­˜æ³„æ¼
valgrind --leak-check=full --show-leak-kinds=all \
  ./target/debug/my_program

# æ£€æµ‹æ•°æ®ç«äº‰
valgrind --tool=helgrind ./target/debug/my_program

# æ£€æµ‹ DRD (æ•°æ®ç«äº‰æ£€æµ‹å™¨)
valgrind --tool=drd ./target/debug/my_program
```

#### Cachegrind (ç¼“å­˜åˆ†æ)

```bash
# åˆ†æç¼“å­˜å‘½ä¸­ç‡
valgrind --tool=cachegrind ./target/release/my_program

# å¯è§†åŒ–ç»“æœ
kcachegrind cachegrind.out.12345
```

#### Rust ç¤ºä¾‹

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let mut data = vec![0u64; 10000];
    
    // æ•…æ„åˆ¶é€ æ•°æ®ç«äº‰ï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼‰
    let ptr = data.as_mut_ptr();
    
    let handles: Vec<_> = (0..4).map(|i| {
        thread::spawn(move || {
            unsafe {
                for j in 0..2500 {
                    *ptr.add(i * 2500 + j) += 1;
                }
            }
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
}
```

---

### 1.3 flamegraph ç«ç„°å›¾

ç«ç„°å›¾ç›´è§‚å±•ç¤ºç¨‹åºçš„æ€§èƒ½çƒ­ç‚¹ã€‚

#### å®‰è£…å’Œä½¿ç”¨

```bash
# å®‰è£… cargo-flamegraph
cargo install flamegraph

# ç”Ÿæˆç«ç„°å›¾
cargo flamegraph --bin my_program

# æŸ¥çœ‹ç«ç„°å›¾ï¼ˆè‡ªåŠ¨åœ¨æµè§ˆå™¨æ‰“å¼€ï¼‰
# flamegraph.svg
```

#### Rust ç¤ºä¾‹1

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn expensive_computation(n: u64) -> u64 {
    (0..n).fold(0, |acc, x| acc + x * x)
}

fn main() {
    let result = Arc::new(Mutex::new(0u64));
    let mut handles = vec![];

    for _ in 0..8 {
        let result = Arc::clone(&result);
        handles.push(thread::spawn(move || {
            let r = expensive_computation(1000000);
            *result.lock().unwrap() += r;
        }));
    }

    for h in handles {
        h.join().unwrap();
    }

    println!("Result: {}", *result.lock().unwrap());
}
```

#### ç«ç„°å›¾è§£è¯»

```text
ç«ç„°å›¾å®½åº¦ = CPU æ—¶é—´å æ¯”
ç«ç„°å›¾é«˜åº¦ = å‡½æ•°è°ƒç”¨æ ˆæ·±åº¦

å®½çš„æ¨ªæ¡ = æ€§èƒ½çƒ­ç‚¹
åº”ä¼˜å…ˆä¼˜åŒ–
```

---

### 1.4 Rust ä¸“ç”¨å·¥å…·

#### cargo-bench

```rust
// benches/my_benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

```bash
# è¿è¡ŒåŸºå‡†æµ‹è¯•
cargo bench
```

#### cargo-bloat

```bash
# åˆ†æäºŒè¿›åˆ¶å¤§å°
cargo install cargo-bloat

# æŸ¥çœ‹æœ€å¤§çš„å‡½æ•°
cargo bloat --release

# æŸ¥çœ‹ crate å¤§å°
cargo bloat --release --crates
```

#### cargo-asm

```bash
# æŸ¥çœ‹æ±‡ç¼–ä»£ç 
cargo install cargo-asm

# æŸ¥çœ‹å‡½æ•°æ±‡ç¼–
cargo asm --release my_crate::my_function
```

---

## 2. CPU Profiling å®æˆ˜

### 2.1 é‡‡æ ·å¼ Profiling

é‡‡æ ·å¼ profiling å®šæœŸé‡‡æ ·ç¨‹åºçŠ¶æ€ï¼Œå¼€é”€è¾ƒå°ã€‚

#### ä½¿ç”¨ pprof

```rust
// Cargo.toml
[dependencies]
pprof = { version = "0.13", features = ["flamegraph"] }

// src/main.rs
use pprof::ProfilerGuard;
use std::fs::File;
use std::io::Write;

fn main() {
    let guard = ProfilerGuard::new(100).unwrap();
    
    // ä½ çš„ä»£ç 
    expensive_work();
    
    // ç”ŸæˆæŠ¥å‘Š
    if let Ok(report) = guard.report().build() {
        let file = File::create("flamegraph.svg").unwrap();
        report.flamegraph(file).unwrap();
    }
}

fn expensive_work() {
    for _ in 0..1000000 {
        let _ = (0..100).sum::<i32>();
    }
}
```

---

### 2.2 æ’æ¡©å¼ Profiling

æ’æ¡©å¼ profiling åœ¨æ¯ä¸ªå‡½æ•°å…¥å£/å‡ºå£æ’å…¥ä»£ç ï¼Œç²¾ç¡®ä½†å¼€é”€å¤§ã€‚

#### æ‰‹åŠ¨æ’æ¡©

```rust
use std::time::Instant;
use std::collections::HashMap;
use std::sync::Mutex;

lazy_static::lazy_static! {
    static ref TIMINGS: Mutex<HashMap<&'static str, Vec<u128>>> = 
        Mutex::new(HashMap::new());
}

macro_rules! profile {
    ($name:expr, $code:block) => {{
        let start = Instant::now();
        let result = $code;
        let elapsed = start.elapsed().as_micros();
        TIMINGS.lock().unwrap()
            .entry($name)
            .or_insert_with(Vec::new)
            .push(elapsed);
        result
    }};
}

fn main() {
    for _ in 0..1000 {
        profile!("task_a", {
            task_a();
        });
        
        profile!("task_b", {
            task_b();
        });
    }
    
    // æ‰“å°ç»Ÿè®¡
    let timings = TIMINGS.lock().unwrap();
    for (name, times) in timings.iter() {
        let avg = times.iter().sum::<u128>() / times.len() as u128;
        println!("{}: avg {}Î¼s", name, avg);
    }
}

fn task_a() {
    std::thread::sleep(std::time::Duration::from_micros(100));
}

fn task_b() {
    std::thread::sleep(std::time::Duration::from_micros(200));
}
```

---

### 2.3 çƒ­ç‚¹åˆ†æ

#### å®Œæ•´ç¤ºä¾‹

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Instant;

fn hot_path_1(data: &mut Vec<u64>) {
    // çƒ­è·¯å¾„ 1ï¼šå¤§é‡è®¡ç®—
    for i in 0..data.len() {
        data[i] = data[i].wrapping_mul(3).wrapping_add(7);
    }
}

fn hot_path_2(data: &mut Vec<u64>) {
    // çƒ­è·¯å¾„ 2ï¼šæ’åº
    data.sort_unstable();
}

fn cold_path(data: &Vec<u64>) {
    // å†·è·¯å¾„ï¼šå¾ˆå°‘æ‰§è¡Œ
    if data.len() > 1000000 {
        println!("Large data: {}", data.len());
    }
}

fn main() {
    let data = Arc::new(Mutex::new(vec![1u64; 100000]));
    
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..8 {
        let data = Arc::clone(&data);
        handles.push(thread::spawn(move || {
            for _ in 0..100 {
                let mut d = data.lock().unwrap();
                hot_path_1(&mut d);
                hot_path_2(&mut d);
                cold_path(&d);
            }
        }));
    }
    
    for h in handles {
        h.join().unwrap();
    }
    
    println!("Elapsed: {:?}", start.elapsed());
}
```

#### ä¼˜åŒ–å

```rust
use rayon::prelude::*;
use std::time::Instant;

fn main() {
    let mut data = vec![1u64; 100000];
    
    let start = Instant::now();
    
    // å¹¶è¡Œå¤„ç†ï¼Œé¿å…é”ç«äº‰
    data.par_iter_mut().for_each(|x| {
        *x = x.wrapping_mul(3).wrapping_add(7);
    });
    
    data.par_sort_unstable();
    
    println!("Elapsed: {:?}", start.elapsed());
}
```

---

## 3. å†…å­˜ Profiling å®æˆ˜

### 3.1 å†…å­˜æ³„æ¼æ£€æµ‹

#### ä½¿ç”¨ Valgrind

```rust
use std::sync::Arc;
use std::thread;

fn leaky_function() {
    let data = Arc::new(vec![0u8; 1024 * 1024]);  // 1MB
    
    // æ•…æ„æ³„æ¼ï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼‰
    std::mem::forget(data);
}

fn main() {
    for _ in 0..10 {
        leaky_function();
    }
    
    // åº”è¯¥é‡Šæ”¾ä½†æ²¡é‡Šæ”¾ 10MB
}
```

```bash
valgrind --leak-check=full ./target/debug/example

# è¾“å‡º:
# ==12345== 10,485,760 bytes in 10 blocks are definitely lost
```

---

### 3.2 å†…å­˜åˆ†é…åˆ†æ

#### ä½¿ç”¨ jemalloc profiling

```rust
// Cargo.toml
[dependencies]
jemallocator = "0.5"

// src/main.rs
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {
    // è®¾ç½® jemalloc profiling
    std::env::set_var("MALLOC_CONF", "prof:true,prof_prefix:jeprof.out");
    
    let mut data = Vec::new();
    for i in 0..1000000 {
        data.push(i);
    }
    
    println!("Data len: {}", data.len());
}
```

```bash
# ç”Ÿæˆå †åˆ†æ
jeprof --show_bytes --pdf target/release/example jeprof.out.* > heap.pdf
```

---

### 3.3 å †åˆ†æ

#### è‡ªå®šä¹‰åˆ†é…è¿½è¸ª

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

struct TrackingAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);
static DEALLOCATED: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for TrackingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ret = System.alloc(layout);
        if !ret.is_null() {
            ALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
        }
        ret
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        DEALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
    }
}

#[global_allocator]
static GLOBAL: TrackingAllocator = TrackingAllocator;

fn main() {
    let data = vec![0u8; 1024 * 1024];  // 1MB
    
    println!("Allocated: {} bytes", ALLOCATED.load(Ordering::SeqCst));
    println!("Deallocated: {} bytes", DEALLOCATED.load(Ordering::SeqCst));
    println!("Current: {} bytes", 
        ALLOCATED.load(Ordering::SeqCst) - DEALLOCATED.load(Ordering::SeqCst));
    
    drop(data);
    
    println!("After drop:");
    println!("Allocated: {} bytes", ALLOCATED.load(Ordering::SeqCst));
    println!("Deallocated: {} bytes", DEALLOCATED.load(Ordering::SeqCst));
    println!("Current: {} bytes", 
        ALLOCATED.load(Ordering::SeqCst) - DEALLOCATED.load(Ordering::SeqCst));
}
```

---

## 4. é”ç«äº‰åˆ†æä¸ä¼˜åŒ–

### 4.1 é”ç«äº‰æ£€æµ‹

#### ä½¿ç”¨ parking_lot çš„ç»Ÿè®¡åŠŸèƒ½

```rust
use parking_lot::{Mutex, MutexGuard};
use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};

fn measure_lock_contention() {
    let counter = Arc::new(Mutex::new(0u64));
    let start = Instant::now();
    
    let handles: Vec<_> = (0..8).map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            for _ in 0..100000 {
                let mut guard = counter.lock();
                *guard += 1;
                // æ¨¡æ‹Ÿä¸´ç•ŒåŒºå·¥ä½œ
                std::thread::sleep(Duration::from_nanos(100));
            }
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    println!("Time with high contention: {:?}", start.elapsed());
}

fn optimized_version() {
    let counter = Arc::new(Mutex::new(0u64));
    let start = Instant::now();
    
    let handles: Vec<_> = (0..8).map(|_| {
        let counter = Arc::clone(&counter);
        thread::spawn(move || {
            let mut local = 0u64;
            for _ in 0..100000 {
                local += 1;
                std::thread::sleep(Duration::from_nanos(100));
            }
            // æ‰¹é‡æ›´æ–°ï¼Œå‡å°‘é”ç«äº‰
            *counter.lock() += local;
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    println!("Time with low contention: {:?}", start.elapsed());
}

fn main() {
    println!("Measuring lock contention...");
    measure_lock_contention();
    
    println!("\nOptimized version:");
    optimized_version();
}
```

---

### 4.2 é”ç«äº‰å¯è§†åŒ–

#### è‡ªå®šä¹‰é”ç›‘æ§

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};
use std::collections::HashMap;

struct MonitoredMutex<T> {
    inner: Mutex<T>,
    lock_times: Mutex<Vec<Duration>>,
    wait_times: Mutex<Vec<Duration>>,
}

impl<T> MonitoredMutex<T> {
    fn new(value: T) -> Self {
        Self {
            inner: Mutex::new(value),
            lock_times: Mutex::new(Vec::new()),
            wait_times: Mutex::new(Vec::new()),
        }
    }
    
    fn lock(&self) -> std::sync::MutexGuard<T> {
        let wait_start = Instant::now();
        let guard = self.inner.lock().unwrap();
        let wait_time = wait_start.elapsed();
        
        self.wait_times.lock().unwrap().push(wait_time);
        guard
    }
    
    fn stats(&self) -> (Duration, Duration) {
        let waits = self.wait_times.lock().unwrap();
        let avg_wait = if !waits.is_empty() {
            waits.iter().sum::<Duration>() / waits.len() as u32
        } else {
            Duration::ZERO
        };
        
        let max_wait = waits.iter().max().copied().unwrap_or(Duration::ZERO);
        
        (avg_wait, max_wait)
    }
}

fn main() {
    let mutex = Arc::new(MonitoredMutex::new(0u64));
    
    let handles: Vec<_> = (0..8).map(|_| {
        let mutex = Arc::clone(&mutex);
        thread::spawn(move || {
            for _ in 0..1000 {
                let mut guard = mutex.lock();
                *guard += 1;
                std::thread::sleep(Duration::from_micros(10));
            }
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    let (avg_wait, max_wait) = mutex.stats();
    println!("Average wait time: {:?}", avg_wait);
    println!("Max wait time: {:?}", max_wait);
}
```

---

### 4.3 ä¼˜åŒ–ç­–ç•¥

#### åˆ†ç‰‡é” (Lock Striping)

```rust
use std::sync::Mutex;
use std::hash::{Hash, Hasher};
use std::collections::hash_map::DefaultHasher;

struct StripedMap<K, V> {
    stripes: Vec<Mutex<std::collections::HashMap<K, V>>>,
}

impl<K: Hash + Eq, V> StripedMap<K, V> {
    fn new(stripe_count: usize) -> Self {
        let mut stripes = Vec::with_capacity(stripe_count);
        for _ in 0..stripe_count {
            stripes.push(Mutex::new(std::collections::HashMap::new()));
        }
        Self { stripes }
    }
    
    fn stripe_index(&self, key: &K) -> usize {
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % self.stripes.len()
    }
    
    fn insert(&self, key: K, value: V) -> Option<V> {
        let idx = self.stripe_index(&key);
        self.stripes[idx].lock().unwrap().insert(key, value)
    }
    
    fn get(&self, key: &K) -> Option<V> where V: Clone {
        let idx = self.stripe_index(key);
        self.stripes[idx].lock().unwrap().get(key).cloned()
    }
}

fn main() {
    use std::sync::Arc;
    use std::thread;
    
    let map = Arc::new(StripedMap::new(16));
    
    let handles: Vec<_> = (0..8).map(|i| {
        let map = Arc::clone(&map);
        thread::spawn(move || {
            for j in 0..10000 {
                map.insert(i * 10000 + j, j);
            }
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    println!("Done");
}
```

---

## 5. æ€§èƒ½å›å½’æµ‹è¯•

### 5.1 åŸºå‡†æµ‹è¯•æ¡†æ¶

#### ä½¿ç”¨ Criterion.rs

```rust
// benches/performance.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("mutex_contention");
    
    for thread_count in [1, 2, 4, 8].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(thread_count),
            thread_count,
            |b, &thread_count| {
                b.iter(|| {
                    let counter = Arc::new(Mutex::new(0u64));
                    let handles: Vec<_> = (0..thread_count).map(|_| {
                        let counter = Arc::clone(&counter);
                        thread::spawn(move || {
                            for _ in 0..1000 {
                                *counter.lock().unwrap() += 1;
                            }
                        })
                    }).collect();
                    
                    for h in handles {
                        h.join().unwrap();
                    }
                });
            },
        );
    }
    
    group.finish();
}

criterion_group!(benches, mutex_benchmark);
criterion_main!(benches);
```

```bash
# è¿è¡ŒåŸºå‡†æµ‹è¯•
cargo bench

# æ¯”è¾ƒä¸¤æ¬¡åŸºå‡†æµ‹è¯•
cargo bench --bench performance -- --save-baseline before
# ... ä¿®æ”¹ä»£ç  ...
cargo bench --bench performance -- --baseline before
```

---

### 5.2 CI/CD é›†æˆ

#### GitHub Actions é…ç½®

```yaml
# .github/workflows/benchmark.yml
name: Performance Benchmarks

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  benchmark:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
    
    - name: Run benchmarks
      run: cargo bench --bench performance -- --save-baseline pr-${{ github.event.pull_request.number }}
    
    - name: Store benchmark result
      uses: benchmark-action/github-action-benchmark@v1
      with:
        tool: 'cargo'
        output-file-path: target/criterion/reports/index.html
        github-token: ${{ secrets.GITHUB_TOKEN }}
        auto-push: true
```

---

### 5.3 æ€§èƒ½ç›‘æ§

#### è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§

```rust
use std::time::{Duration, Instant};
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};

struct PerformanceMonitor {
    name: String,
    samples: Mutex<VecDeque<Duration>>,
    max_samples: usize,
}

impl PerformanceMonitor {
    fn new(name: impl Into<String>, max_samples: usize) -> Self {
        Self {
            name: name.into(),
            samples: Mutex::new(VecDeque::with_capacity(max_samples)),
            max_samples,
        }
    }
    
    fn record(&self, duration: Duration) {
        let mut samples = self.samples.lock().unwrap();
        if samples.len() >= self.max_samples {
            samples.pop_front();
        }
        samples.push_back(duration);
    }
    
    fn stats(&self) -> MonitorStats {
        let samples = self.samples.lock().unwrap();
        if samples.is_empty() {
            return MonitorStats::default();
        }
        
        let sum: Duration = samples.iter().sum();
        let avg = sum / samples.len() as u32;
        let min = samples.iter().min().copied().unwrap();
        let max = samples.iter().max().copied().unwrap();
        
        // è®¡ç®— P95
        let mut sorted: Vec<_> = samples.iter().copied().collect();
        sorted.sort();
        let p95_idx = (sorted.len() as f64 * 0.95) as usize;
        let p95 = sorted[p95_idx.min(sorted.len() - 1)];
        
        MonitorStats { avg, min, max, p95 }
    }
    
    fn report(&self) {
        let stats = self.stats();
        println!("[{}] avg: {:?}, min: {:?}, max: {:?}, p95: {:?}",
            self.name, stats.avg, stats.min, stats.max, stats.p95);
    }
}

#[derive(Default)]
struct MonitorStats {
    avg: Duration,
    min: Duration,
    max: Duration,
    p95: Duration,
}

fn main() {
    let monitor = Arc::new(PerformanceMonitor::new("task_execution", 1000));
    
    for _ in 0..100 {
        let start = Instant::now();
        
        // æ¨¡æ‹Ÿä»»åŠ¡
        std::thread::sleep(Duration::from_millis(10));
        
        monitor.record(start.elapsed());
    }
    
    monitor.report();
}
```

---

## 6. ä¼˜åŒ–è¿­ä»£æµç¨‹

### 6.1 æ€§èƒ½ä¼˜åŒ–æ–¹æ³•è®º

#### ä¼˜åŒ–æµç¨‹

```text
1. æµ‹é‡ (Measure)
   â”œâ”€â”€ å»ºç«‹æ€§èƒ½åŸºçº¿
   â”œâ”€â”€ è¯†åˆ«æ€§èƒ½ç›®æ ‡
   â””â”€â”€ æ”¶é›† profiling æ•°æ®

2. åˆ†æ (Analyze)
   â”œâ”€â”€ è¯†åˆ«çƒ­ç‚¹
   â”œâ”€â”€ åˆ†æç“¶é¢ˆåŸå› 
   â””â”€â”€ æå‡ºä¼˜åŒ–å‡è®¾

3. ä¼˜åŒ– (Optimize)
   â”œâ”€â”€ å®æ–½ä¼˜åŒ–æ–¹æ¡ˆ
   â”œâ”€â”€ å•å…ƒæµ‹è¯•éªŒè¯
   â””â”€â”€ åŸºå‡†æµ‹è¯•å¯¹æ¯”

4. éªŒè¯ (Validate)
   â”œâ”€â”€ æ€§èƒ½æå‡ç¡®è®¤
   â”œâ”€â”€ åŠŸèƒ½æ­£ç¡®æ€§éªŒè¯
   â””â”€â”€ å›å½’æµ‹è¯•

5. è¿­ä»£ (Iterate)
   â””â”€â”€ é‡å¤ 1-4 ç›´åˆ°è¾¾åˆ°ç›®æ ‡
```

#### å®æˆ˜æ£€æŸ¥æ¸…å•

```rust
// æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•
struct OptimizationChecklist {
    items: Vec<(&'static str, bool)>,
}

impl OptimizationChecklist {
    fn new() -> Self {
        Self {
            items: vec![
                ("âœ“ å»ºç«‹æ€§èƒ½åŸºçº¿", false),
                ("âœ“ ä½¿ç”¨ perf/flamegraph åˆ†æ", false),
                ("âœ“ è¯†åˆ«çƒ­ç‚¹å‡½æ•°", false),
                ("âœ“ æ£€æŸ¥é”ç«äº‰", false),
                ("âœ“ æ£€æŸ¥å†…å­˜åˆ†é…", false),
                ("âœ“ å®æ–½ä¼˜åŒ–", false),
                ("âœ“ è¿è¡ŒåŸºå‡†æµ‹è¯•", false),
                ("âœ“ éªŒè¯æ€§èƒ½æå‡ (>10%)", false),
                ("âœ“ éªŒè¯åŠŸèƒ½æ­£ç¡®æ€§", false),
                ("âœ“ æäº¤ä»£ç å®¡æŸ¥", false),
            ],
        }
    }
    
    fn check(&mut self, index: usize) {
        if index < self.items.len() {
            self.items[index].1 = true;
        }
    }
    
    fn report(&self) {
        println!("Optimization Progress:");
        for (item, done) in &self.items {
            println!("{} {}", if *done { "[âœ“]" } else { "[ ]" }, item);
        }
    }
}

fn main() {
    let mut checklist = OptimizationChecklist::new();
    
    // æ¨¡æ‹Ÿä¼˜åŒ–æµç¨‹
    checklist.check(0);  // å»ºç«‹åŸºçº¿
    checklist.check(1);  // åˆ†æ
    checklist.check(2);  // è¯†åˆ«çƒ­ç‚¹
    
    checklist.report();
}
```

---

### 6.2 å®Œæ•´ä¼˜åŒ–æ¡ˆä¾‹

#### åŸå§‹ç‰ˆæœ¬ï¼ˆæ…¢ï¼‰

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Instant;

fn slow_version() -> Duration {
    let data = Arc::new(Mutex::new(Vec::new()));
    let start = Instant::now();
    
    let handles: Vec<_> = (0..8).map(|i| {
        let data = Arc::clone(&data);
        thread::spawn(move || {
            for j in 0..10000 {
                // é—®é¢˜1: é¢‘ç¹åŠ é”
                data.lock().unwrap().push(i * 10000 + j);
            }
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    start.elapsed()
}
```

#### ä¼˜åŒ–ç‰ˆæœ¬ 1ï¼šæ‰¹é‡æ“ä½œ

```rust
fn optimized_v1() -> Duration {
    let data = Arc::new(Mutex::new(Vec::new()));
    let start = Instant::now();
    
    let handles: Vec<_> = (0..8).map(|i| {
        let data = Arc::clone(&data);
        thread::spawn(move || {
            let mut local = Vec::with_capacity(10000);
            for j in 0..10000 {
                local.push(i * 10000 + j);
            }
            // æ‰¹é‡æ“ä½œï¼Œå‡å°‘é”ç«äº‰
            data.lock().unwrap().extend(local);
        })
    }).collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    start.elapsed()
}
```

#### ä¼˜åŒ–ç‰ˆæœ¬ 2ï¼šæ— é”è®¾è®¡

```rust
use crossbeam_channel::unbounded;

fn optimized_v2() -> Duration {
    let (tx, rx) = unbounded();
    let start = Instant::now();
    
    let handles: Vec<_> = (0..8).map(|i| {
        let tx = tx.clone();
        thread::spawn(move || {
            for j in 0..10000 {
                tx.send(i * 10000 + j).unwrap();
            }
        })
    }).collect();
    
    drop(tx);
    
    let collector = thread::spawn(move || {
        let mut data = Vec::new();
        while let Ok(value) = rx.recv() {
            data.push(value);
        }
        data
    });
    
    for h in handles {
        h.join().unwrap();
    }
    
    let _data = collector.join().unwrap();
    start.elapsed()
}
```

#### æ€§èƒ½å¯¹æ¯”

```rust
fn main() {
    println!("Running performance comparison...");
    
    let slow = slow_version();
    println!("Slow version: {:?}", slow);
    
    let opt1 = optimized_v1();
    println!("Optimized v1: {:?} ({}x faster)", 
        opt1, slow.as_micros() / opt1.as_micros());
    
    let opt2 = optimized_v2();
    println!("Optimized v2: {:?} ({}x faster)", 
        opt2, slow.as_micros() / opt2.as_micros());
}
```

---

## 7. æœ€ä½³å®è·µ

### æ€§èƒ½å·¥ç¨‹åŸåˆ™

1. **å…ˆæµ‹é‡ï¼Œåä¼˜åŒ–**
   - ä¸è¦å‡­ç›´è§‰ä¼˜åŒ–
   - å»ºç«‹å¯é çš„æ€§èƒ½åŸºçº¿
   - ä½¿ç”¨æ•°æ®é©±åŠ¨å†³ç­–

2. **ä¼˜å…ˆä¼˜åŒ–çƒ­ç‚¹**
   - 80/20 æ³•åˆ™ï¼š80% æ—¶é—´èŠ±åœ¨ 20% ä»£ç ä¸Š
   - ä½¿ç”¨ flamegraph æ‰¾åˆ°å®½çš„æ¨ªæ¡
   - ä¼˜å…ˆè§£å†³æœ€è€—æ—¶çš„å‡½æ•°

3. **é™ä½é”ç«äº‰**
   - å‡å°‘ä¸´ç•ŒåŒºå¤§å°
   - ä½¿ç”¨æ‰¹é‡æ“ä½œ
   - è€ƒè™‘æ— é”æ•°æ®ç»“æ„

4. **å‡å°‘å†…å­˜åˆ†é…**
   - é¢„åˆ†é…å®¹é‡
   - é‡ç”¨å†…å­˜
   - ä½¿ç”¨å¯¹è±¡æ± 

5. **æ€§èƒ½å›å½’æµ‹è¯•**
   - é›†æˆåˆ° CI/CD
   - è‡ªåŠ¨åŒ–åŸºå‡†æµ‹è¯•
   - ç›‘æ§æ€§èƒ½è¶‹åŠ¿

### å·¥å…·é€‰æ‹©å»ºè®®

| åœºæ™¯ | æ¨èå·¥å…· | å¤‡é€‰å·¥å…· |
|------|---------|---------|
| **CPU çƒ­ç‚¹åˆ†æ** | flamegraph | perf, pprof |
| **å†…å­˜æ³„æ¼æ£€æµ‹** | Valgrind | AddressSanitizer |
| **é”ç«äº‰åˆ†æ** | helgrind | ThreadSanitizer |
| **åŸºå‡†æµ‹è¯•** | Criterion | cargo-bench |
| **ä»£ç å¤§å°åˆ†æ** | cargo-bloat | bloaty |

---

## ğŸ”— ç›¸å…³èµ„æº

### æ ¸å¿ƒæ–‡æ¡£

- [ä¸»ç´¢å¼•å¯¼èˆª](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [é«˜çº§å¹¶å‘æ¨¡å¼](./01_é«˜çº§å¹¶å‘æ¨¡å¼.md)
- [ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–](./02_ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–.md)

### å¤–éƒ¨èµ„æº

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Criterion.rs Documentation](https://bheisler.github.io/criterion.rs/book/)
- [flamegraph.rs](https://github.com/flamegraph-rs/flamegraph)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **è´¨é‡è¯„åˆ†**: 95/100  
**æœ€åæ›´æ–°**: 2025-10-22 | **Rust ç‰ˆæœ¬**: 1.90+
