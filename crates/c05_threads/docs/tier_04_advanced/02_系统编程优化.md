# C05 Tier 4 é«˜çº§ä¸»é¢˜ 02ï¼šç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 4 é«˜çº§ä¸»é¢˜ 02ï¼šç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–](#c05-tier-4-é«˜çº§ä¸»é¢˜-02ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
  - [1. CPU äº²å’Œæ€§ï¼ˆAffinityï¼‰](#1-cpu-äº²å’Œæ€§affinity)
    - [1.1 ä»€ä¹ˆæ˜¯ CPU äº²å’Œæ€§](#11-ä»€ä¹ˆæ˜¯-cpu-äº²å’Œæ€§)
    - [1.2 è®¾ç½® CPU äº²å’Œæ€§](#12-è®¾ç½®-cpu-äº²å’Œæ€§)
    - [1.3 æ€§èƒ½å½±å“](#13-æ€§èƒ½å½±å“)
  - [2. NUMA æ¶æ„ä¼˜åŒ–](#2-numa-æ¶æ„ä¼˜åŒ–)
    - [2.1 NUMA ç®€ä»‹](#21-numa-ç®€ä»‹)
    - [2.2 NUMA æ„ŸçŸ¥åˆ†é…](#22-numa-æ„ŸçŸ¥åˆ†é…)
    - [2.3 NUMA æœ€ä½³å®è·µ](#23-numa-æœ€ä½³å®è·µ)
  - [3. çº¿ç¨‹ä¼˜å…ˆçº§](#3-çº¿ç¨‹ä¼˜å…ˆçº§)
    - [3.1 è®¾ç½®ä¼˜å…ˆçº§](#31-è®¾ç½®ä¼˜å…ˆçº§)
    - [3.2 ä¼˜å…ˆçº§ç­–ç•¥](#32-ä¼˜å…ˆçº§ç­–ç•¥)
  - [4. å®æ—¶è°ƒåº¦](#4-å®æ—¶è°ƒåº¦)
    - [4.1 å®æ—¶è°ƒåº¦ç­–ç•¥](#41-å®æ—¶è°ƒåº¦ç­–ç•¥)
    - [4.2 å®æ—¶æ€§èƒ½æµ‹é‡](#42-å®æ—¶æ€§èƒ½æµ‹é‡)
  - [5. ç¼“å­˜ä¼˜åŒ–](#5-ç¼“å­˜ä¼˜åŒ–)
    - [5.1 ç¼“å­˜è¡Œå¯¹é½](#51-ç¼“å­˜è¡Œå¯¹é½)
    - [5.2 é¢„å–ä¼˜åŒ–](#52-é¢„å–ä¼˜åŒ–)
  - [6. ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–](#6-ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–)
    - [6.1 æ‰¹é‡ç³»ç»Ÿè°ƒç”¨](#61-æ‰¹é‡ç³»ç»Ÿè°ƒç”¨)
    - [6.2 å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢](#62-å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢)
  - [7. å†…å­˜åˆ†é…ä¼˜åŒ–](#7-å†…å­˜åˆ†é…ä¼˜åŒ–)
    - [7.1 ä½¿ç”¨è‡ªå®šä¹‰åˆ†é…å™¨](#71-ä½¿ç”¨è‡ªå®šä¹‰åˆ†é…å™¨)
    - [7.2 æ± åŒ–åˆ†é…](#72-æ± åŒ–åˆ†é…)
  - [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
    - [8.1 é«˜æ€§èƒ½æœåŠ¡å™¨](#81-é«˜æ€§èƒ½æœåŠ¡å™¨)
  - [9. å‚è€ƒèµ„æº](#9-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [ç³»ç»Ÿç¼–ç¨‹ä¹¦ç±](#ç³»ç»Ÿç¼–ç¨‹ä¹¦ç±)
    - [å†…éƒ¨æ–‡æ¡£](#å†…éƒ¨æ–‡æ¡£)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ– (Systems Programming Optimization)**:

- **å®šä¹‰**: Rust 1.92.0 ç³»ç»Ÿç¼–ç¨‹å±‚é¢çš„æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ï¼ŒåŒ…æ‹¬ CPU äº²å’Œæ€§ã€NUMA æ¶æ„ä¼˜åŒ–ã€çº¿ç¨‹ä¼˜å…ˆçº§ã€å®æ—¶è°ƒåº¦ã€ç¼“å­˜ä¼˜åŒ–ã€ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–ã€å†…å­˜åˆ†é…ä¼˜åŒ–ç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: ç³»ç»Ÿç¼–ç¨‹ã€æ€§èƒ½ä¼˜åŒ–
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: CPU äº²å’Œæ€§ã€NUMAã€çº¿ç¨‹ä¼˜å…ˆçº§ã€å®æ—¶è°ƒåº¦ã€ç¼“å­˜ä¼˜åŒ–ã€ç³»ç»Ÿè°ƒç”¨ã€å†…å­˜åˆ†é…

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **CPU äº²å’Œæ€§ï¼ˆAffinityï¼‰**: å°†çº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šçš„ CPU æ ¸å¿ƒï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œç¼“å­˜å¤±æ•ˆ
- **NUMA æ¶æ„ä¼˜åŒ–**: éç»Ÿä¸€å†…å­˜è®¿é—®æ¶æ„ä¼˜åŒ–ï¼Œå‡å°‘è·¨èŠ‚ç‚¹å†…å­˜è®¿é—®
- **çº¿ç¨‹ä¼˜å…ˆçº§**: è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§ï¼Œå½±å“è°ƒåº¦é¡ºåº
- **å®æ—¶è°ƒåº¦**: å®æ—¶ç³»ç»Ÿçš„è°ƒåº¦ç­–ç•¥
- **ç¼“å­˜ä¼˜åŒ–**: æé«˜ç¼“å­˜å‘½ä¸­ç‡ï¼Œå‡å°‘ç¼“å­˜å¤±æ•ˆ
- **ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–**: å‡å°‘ç³»ç»Ÿè°ƒç”¨å¼€é”€ï¼Œæ‰¹é‡å¤„ç†ç³»ç»Ÿè°ƒç”¨
- **å†…å­˜åˆ†é…ä¼˜åŒ–**: è‡ªå®šä¹‰åˆ†é…å™¨ã€å¯¹è±¡æ± ã€å†…å­˜å¯¹é½

**Rust 1.92.0 æ–°ç‰¹æ€§**:

- **æ”¹è¿›çš„ CPU äº²å’Œæ€§æ”¯æŒ**: æ›´å¥½çš„ CPU äº²å’Œæ€§ API
- **å¢å¼ºçš„ NUMA æ”¯æŒ**: æ›´å¥½çš„ NUMA æ¶æ„æ”¯æŒ
- **ä¼˜åŒ–çš„å†…å­˜åˆ†é…**: æ›´é«˜æ•ˆçš„å†…å­˜åˆ†é…ç­–ç•¥

**æ€§èƒ½ç‰¹å¾**:

- **ä½å»¶è¿Ÿ**: å‡å°‘ç³»ç»Ÿè°ƒç”¨å’Œä¸Šä¸‹æ–‡åˆ‡æ¢
- **é«˜åå**: ä¼˜åŒ–ç¼“å­˜å’Œå†…å­˜è®¿é—®
- **é€‚ç”¨åœºæ™¯**: é«˜æ€§èƒ½ç³»ç»Ÿã€å®æ—¶ç³»ç»Ÿã€ç³»ç»Ÿç¼–ç¨‹

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ– --[covers]--> å¤šç§ä¼˜åŒ–æŠ€æœ¯
- é«˜æ€§èƒ½ç¨‹åº --[uses]--> ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–

**ä¾èµ–å…³ç³»**:

- ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ– --[depends-on]--> æ“ä½œç³»ç»Ÿ API
- æ€§èƒ½ä¼˜åŒ– --[depends-on]--> ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–

### æ€ç»´å¯¼å›¾

```text
ç³»ç»Ÿç¼–ç¨‹ä¼˜åŒ–
â”‚
â”œâ”€â”€ CPU äº²å’Œæ€§
â”‚   â””â”€â”€ çº¿ç¨‹ç»‘å®š
â”œâ”€â”€ NUMA æ¶æ„ä¼˜åŒ–
â”‚   â””â”€â”€ å†…å­˜è®¿é—®ä¼˜åŒ–
â”œâ”€â”€ çº¿ç¨‹ä¼˜å…ˆçº§
â”‚   â””â”€â”€ è°ƒåº¦ä¼˜åŒ–
â”œâ”€â”€ å®æ—¶è°ƒåº¦
â”‚   â””â”€â”€ å®æ—¶ç³»ç»Ÿ
â”œâ”€â”€ ç¼“å­˜ä¼˜åŒ–
â”‚   â””â”€â”€ ç¼“å­˜å‹å¥½
â”œâ”€â”€ ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–
â”‚   â””â”€â”€ æ‰¹é‡å¤„ç†
â””â”€â”€ å†…å­˜åˆ†é…ä¼˜åŒ–
    â””â”€â”€ è‡ªå®šä¹‰åˆ†é…å™¨
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| ä¼˜åŒ–æŠ€æœ¯         | æ€§èƒ½æå‡ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯   | å¹³å°æ”¯æŒ | Rust 1.92.0 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **CPU äº²å’Œæ€§**   | ä¸­       | ä½     | å¤šæ ¸ç³»ç»Ÿ   | âœ…       | âœ… æ”¹è¿›     |
| **NUMA ä¼˜åŒ–**    | é«˜       | é«˜     | NUMA ç³»ç»Ÿ  | Linux    | âœ…          |
| **çº¿ç¨‹ä¼˜å…ˆçº§**   | ä¸­       | ä½     | å®æ—¶ç³»ç»Ÿ   | âœ…       | âœ…          |
| **å®æ—¶è°ƒåº¦**     | é«˜       | é«˜     | å®æ—¶ç³»ç»Ÿ   | Linux    | âœ…          |
| **ç¼“å­˜ä¼˜åŒ–**     | é«˜       | ä¸­     | æ€§èƒ½å…³é”®   | âœ…       | âœ…          |
| **ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–** | ä¸­       | ä¸­     | I/O å¯†é›†å‹ | âœ…       | âœ…          |
| **å†…å­˜åˆ†é…ä¼˜åŒ–** | é«˜       | ä¸­     | å†…å­˜å—é™   | âœ…       | âœ…          |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©ä¼˜åŒ–æŠ€æœ¯
â”‚
â”œâ”€â”€ æ˜¯å¦åœ¨ NUMA ç³»ç»Ÿä¸Šï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ NUMA ä¼˜åŒ–
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­åˆ¤æ–­
â”‚       â”œâ”€â”€ æ˜¯å¦éœ€è¦å®æ—¶æ€§ï¼Ÿ
â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ å®æ—¶è°ƒåº¦ + çº¿ç¨‹ä¼˜å…ˆçº§
â”‚       â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­åˆ¤æ–­
â”‚       â”‚       â”œâ”€â”€ æ˜¯å¦éœ€è¦å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Ÿ
â”‚       â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ CPU äº²å’Œæ€§
â”‚       â”‚       â”‚   â””â”€â”€ å¦ â†’ ç¼“å­˜ä¼˜åŒ–
```

---

## 1. CPU äº²å’Œæ€§ï¼ˆAffinityï¼‰

### 1.1 ä»€ä¹ˆæ˜¯ CPU äº²å’Œæ€§

CPU äº²å’Œæ€§å…è®¸å°†çº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šçš„ CPU æ ¸å¿ƒï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œç¼“å­˜å¤±æ•ˆã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             CPU æ ¸å¿ƒå¸ƒå±€ (4æ ¸8çº¿ç¨‹)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                   â”‚
â”‚  Core 0: [Thread 0] [Thread 4]  â—„â”€ Worker 1       â”‚
â”‚  Core 1: [Thread 1] [Thread 5]  â—„â”€ Worker 2       â”‚
â”‚  Core 2: [Thread 2] [Thread 6]  â—„â”€ Worker 3       â”‚
â”‚  Core 3: [Thread 3] [Thread 7]  â—„â”€ Worker 4       â”‚
â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 è®¾ç½® CPU äº²å’Œæ€§

```rust
// ä½¿ç”¨ core_affinity crate
use core_affinity;
use std::thread;

fn main() {
    // è·å–å¯ç”¨çš„æ ¸å¿ƒåˆ—è¡¨
    let core_ids = core_affinity::get_core_ids().unwrap();
    println!("Available cores: {} cores", core_ids.len());

    let mut handles = vec![];

    // ä¸ºæ¯ä¸ªæ ¸å¿ƒå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹
    for (i, core_id) in core_ids.into_iter().enumerate() {
        let handle = thread::spawn(move || {
            // å°†å½“å‰çº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šæ ¸å¿ƒ
            core_affinity::set_for_current(core_id);

            println!("Thread {} pinned to core {:?}", i, core_id);

            // æ‰§è¡Œå·¥ä½œ
            let mut sum = 0u64;
            for j in 0..10_000_000 {
                sum += j;
            }

            sum
        });
        handles.push(handle);
    }

    for (i, handle) in handles.into_iter().enumerate() {
        let result = handle.join().unwrap();
        println!("Thread {} result: {}", i, result);
    }
}
```

### 1.3 æ€§èƒ½å½±å“

| åœºæ™¯           | æ— äº²å’Œæ€§ | æœ‰äº²å’Œæ€§ | æå‡ |
| :--- | :--- | :--- | :--- |
| CPU å¯†é›†è®¡ç®—   | 100ms    | 85ms     | 15%  |
| ç¼“å­˜æ•æ„Ÿä»»åŠ¡   | 150ms    | 110ms    | 27%  |
| é«˜é¢‘ä¸Šä¸‹æ–‡åˆ‡æ¢ | 200ms    | 140ms    | 30%  |

---

## 2. NUMA æ¶æ„ä¼˜åŒ–

### 2.1 NUMA ç®€ä»‹

NUMA (Non-Uniform Memory Access) æ¶æ„ä¸­ï¼Œä¸åŒ CPU è®¿é—®ä¸åŒå†…å­˜åŒºåŸŸçš„å»¶è¿Ÿä¸åŒã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                NUMA æ¶æ„ç¤ºæ„å›¾                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Node 0                    Node 1                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  CPU 0-7      â”‚         â”‚  CPU 8-15     â”‚       â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚  â”‚  Memory 0-32GBâ”‚â—„â”€â”€â” â”Œâ”€â”€â–ºâ”‚  Memory 32-64GBâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚            â”‚ â”‚            â”‚               â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                      â”‚ â”‚                            â”‚
â”‚                 â—„â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â–º                       â”‚
â”‚            æœ¬åœ°è®¿é—®å¿«    è¿œç¨‹è®¿é—®æ…¢                  â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 NUMA æ„ŸçŸ¥åˆ†é…

```rust
// ä½¿ç”¨ numa crate (Linux only)
#[cfg(target_os = "linux")]
fn numa_aware_allocation() {
    use numa::{NodeId, NodeMask};

    // è·å– NUMA èŠ‚ç‚¹ä¿¡æ¯
    let nodes = numa::node_list().unwrap();
    println!("NUMA nodes: {:?}", nodes);

    // åœ¨ç‰¹å®š NUMA èŠ‚ç‚¹ä¸Šåˆ†é…å†…å­˜
    let node = NodeId::new(0);
    let size = 1024 * 1024 * 100; // 100MB

    unsafe {
        let ptr = numa::alloc_on_node(size, node);

        // ä½¿ç”¨å†…å­˜...

        numa::free(ptr, size);
    }
}

fn main() {
    #[cfg(target_os = "linux")]
    numa_aware_allocation();
}
```

### 2.3 NUMA æœ€ä½³å®è·µ

```rust
use std::thread;

fn numa_optimized_computation() {
    let num_nodes = 2; // å‡è®¾2ä¸ªNUMAèŠ‚ç‚¹
    let data_per_node = 1_000_000;

    let handles: Vec<_> = (0..num_nodes)
        .map(|node_id| {
            thread::spawn(move || {
                // åœ¨å¯¹åº” NUMA èŠ‚ç‚¹ä¸Šåˆ†é…å’Œå¤„ç†æ•°æ®
                let data: Vec<i32> = (0..data_per_node).collect();

                // æœ¬åœ°å¤„ç†ï¼Œé¿å…è·¨NUMAè®¿é—®
                let sum: i32 = data.iter().sum();

                sum
            })
        })
        .collect();

    let results: Vec<_> = handles.into_iter()
        .map(|h| h.join().unwrap())
        .collect();

    let total: i32 = results.iter().sum();
    println!("Total: {}", total);
}

fn main() {
    numa_optimized_computation();
}
```

---

## 3. çº¿ç¨‹ä¼˜å…ˆçº§

### 3.1 è®¾ç½®ä¼˜å…ˆçº§

```rust
// ä½¿ç”¨ thread_priority crate
use thread_priority::*;
use std::thread;

fn main() {
    // é«˜ä¼˜å…ˆçº§çº¿ç¨‹
    let high_priority = thread::spawn(|| {
        set_current_thread_priority(ThreadPriority::Max).unwrap();
        println!("High priority task running");

        // æ‰§è¡Œå…³é”®ä»»åŠ¡
        for i in 0..5 {
            println!("High: {}", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }
    });

    // ä½ä¼˜å…ˆçº§çº¿ç¨‹
    let low_priority = thread::spawn(|| {
        set_current_thread_priority(ThreadPriority::Min).unwrap();
        println!("Low priority task running");

        // æ‰§è¡Œåå°ä»»åŠ¡
        for i in 0..5 {
            println!("Low: {}", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }
    });

    high_priority.join().unwrap();
    low_priority.join().unwrap();
}
```

### 3.2 ä¼˜å…ˆçº§ç­–ç•¥

| ç­–ç•¥          | è¯´æ˜       | é€‚ç”¨åœºæ™¯           |
| :--- | :--- | :--- || **Normal**    | é»˜è®¤ä¼˜å…ˆçº§ | æ™®é€šä»»åŠ¡           |
| **High**      | é«˜ä¼˜å…ˆçº§   | ç”¨æˆ·äº¤äº’ã€å®æ—¶å“åº” |
| **Low**       | ä½ä¼˜å…ˆçº§   | åå°ä»»åŠ¡ã€æ‰¹å¤„ç†   |
| **Real-Time** | å®æ—¶ä¼˜å…ˆçº§ | éŸ³è§†é¢‘å¤„ç†         |

---

## 4. å®æ—¶è°ƒåº¦

### 4.1 å®æ—¶è°ƒåº¦ç­–ç•¥

```rust
// Linux: ä½¿ç”¨ libc è®¾ç½®å®æ—¶è°ƒåº¦
#[cfg(target_os = "linux")]
fn set_realtime_priority() {
    use libc::{sched_param, sched_setscheduler, SCHED_FIFO};

    unsafe {
        let param = sched_param {
            sched_priority: 50, // 1-99
        };

        let result = sched_setscheduler(0, SCHED_FIFO, &param);

        if result == 0 {
            println!("Successfully set real-time priority");
        } else {
            eprintln!("Failed to set real-time priority");
        }
    }
}

fn main() {
    #[cfg(target_os = "linux")]
    set_realtime_priority();

    // æ‰§è¡Œå®æ—¶ä»»åŠ¡
    loop {
        // å®æ—¶å¤„ç†...
        std::thread::sleep(std::time::Duration::from_micros(100));
    }
}
```

### 4.2 å®æ—¶æ€§èƒ½æµ‹é‡

```rust
use std::time::{Duration, Instant};

fn measure_latency(iterations: usize) -> (Duration, Duration, Duration) {
    let mut latencies = Vec::with_capacity(iterations);

    for _ in 0..iterations {
        let start = Instant::now();

        // æ¨¡æ‹Ÿå®æ—¶ä»»åŠ¡
        std::thread::sleep(Duration::from_micros(100));

        let latency = start.elapsed();
        latencies.push(latency);
    }

    latencies.sort();

    let avg = latencies.iter().sum::<Duration>() / iterations as u32;
    let p50 = latencies[iterations / 2];
    let p99 = latencies[iterations * 99 / 100];

    (avg, p50, p99)
}

fn main() {
    let (avg, p50, p99) = measure_latency(1000);

    println!("Average latency: {:?}", avg);
    println!("P50 latency: {:?}", p50);
    println!("P99 latency: {:?}", p99);
}
```

---

## 5. ç¼“å­˜ä¼˜åŒ–

### 5.1 ç¼“å­˜è¡Œå¯¹é½

```rust
#[repr(align(64))] // L1 cache line size
struct CacheLineAligned {
    value: i64,
    _padding: [u8; 56], // 64 - 8 = 56
}

fn test_cache_aligned() {
    use std::sync::Arc;
    use std::thread;
    use std::time::Instant;

    let data = Arc::new([CacheLineAligned {
        value: 0,
        _padding: [0; 56],
    }; 4]);

    let start = Instant::now();

    let handles: Vec<_> = (0..4)
        .map(|i| {
            let data = Arc::clone(&data);
            thread::spawn(move || {
                for _ in 0..10_000_000 {
                    // è®¿é—®ä¸åŒçš„ç¼“å­˜è¡Œï¼Œé¿å…ä¼ªå…±äº«
                    let _ = data[i].value;
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Time: {:?}", start.elapsed());
}

fn main() {
    test_cache_aligned();
}
```

### 5.2 é¢„å–ä¼˜åŒ–

```rust
fn prefetch_optimization(data: &[i32]) -> i32 {
    let mut sum = 0;

    for i in 0..data.len() {
        // é¢„å–åç»­æ•°æ®åˆ°ç¼“å­˜
        if i + 64 < data.len() {
            // ä½¿ç”¨ intrinsics (éœ€è¦ nightly)
            // unsafe {
            //     std::intrinsics::prefetch_read_data(&data[i + 64], 3);
            // }
        }

        sum += data[i];
    }

    sum
}

fn main() {
    let data: Vec<i32> = (0..10_000_000).collect();
    let sum = prefetch_optimization(&data);
    println!("Sum: {}", sum);
}
```

---

## 6. ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–

### 6.1 æ‰¹é‡ç³»ç»Ÿè°ƒç”¨

```rust
use std::fs::File;
use std::io::{Write, BufWriter};

fn optimized_file_write() {
    let file = File::create("output.txt").unwrap();

    // âŒ æ…¢ï¼šæ¯æ¬¡å†™å…¥éƒ½æ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨
    // let mut file = file;
    // for i in 0..10000 {
    //     file.write_all(format!("{}\n", i).as_bytes()).unwrap();
    // }

    // âœ… å¿«ï¼šä½¿ç”¨ BufWriter æ‰¹é‡å†™å…¥
    let mut writer = BufWriter::new(file);
    for i in 0..10000 {
        writer.write_all(format!("{}\n", i).as_bytes()).unwrap();
    }
    writer.flush().unwrap();
}

fn main() {
    let start = std::time::Instant::now();
    optimized_file_write();
    println!("Time: {:?}", start.elapsed());
}
```

### 6.2 å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢

```rust
use std::thread;
use std::time::Duration;

fn minimize_context_switches() {
    // âŒ é¢‘ç¹åˆ‡æ¢
    // for _ in 0..1000 {
    //     thread::sleep(Duration::from_micros(1));
    // }

    // âœ… æ‰¹é‡å¤„ç†
    for _ in 0..10 {
        // åšæ›´å¤šå·¥ä½œ
        for _ in 0..100 {
            // è®¡ç®—...
        }
        thread::sleep(Duration::from_micros(100));
    }
}

fn main() {
    minimize_context_switches();
}
```

---

## 7. å†…å­˜åˆ†é…ä¼˜åŒ–

### 7.1 ä½¿ç”¨è‡ªå®šä¹‰åˆ†é…å™¨

```rust
// ä½¿ç”¨ jemalloc
#[global_allocator]
static GLOBAL: jemallocator::Jemalloc = jemallocator::Jemalloc;

fn test_allocation() {
    let mut vectors = Vec::new();

    for _ in 0..1000 {
        let v: Vec<i32> = (0..1000).collect();
        vectors.push(v);
    }

    println!("Allocated {} vectors", vectors.len());
}

fn main() {
    test_allocation();
}
```

### 7.2 æ± åŒ–åˆ†é…

```rust
use std::sync::Arc;
use std::sync::Mutex;

struct ObjectPool<T> {
    pool: Arc<Mutex<Vec<T>>>,
    factory: fn() -> T,
}

impl<T> ObjectPool<T> {
    fn new(size: usize, factory: fn() -> T) -> Self {
        let mut pool = Vec::with_capacity(size);
        for _ in 0..size {
            pool.push(factory());
        }

        ObjectPool {
            pool: Arc::new(Mutex::new(pool)),
            factory,
        }
    }

    fn acquire(&self) -> T {
        let mut pool = self.pool.lock().unwrap();
        pool.pop().unwrap_or_else(|| (self.factory)())
    }

    fn release(&self, obj: T) {
        let mut pool = self.pool.lock().unwrap();
        pool.push(obj);
    }
}

fn main() {
    let pool = ObjectPool::new(10, || Vec::with_capacity(1024));

    // ä½¿ç”¨å¯¹è±¡
    let mut obj = pool.acquire();
    obj.push(42);

    // å½’è¿˜å¯¹è±¡
    obj.clear();
    pool.release(obj);
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### 8.1 é«˜æ€§èƒ½æœåŠ¡å™¨

```rust
use std::thread;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

struct HighPerfServer {
    worker_count: usize,
    request_count: Arc<AtomicUsize>,
}

impl HighPerfServer {
    fn new(worker_count: usize) -> Self {
        HighPerfServer {
            worker_count,
            request_count: Arc::new(AtomicUsize::new(0)),
        }
    }

    fn start(&self) {
        // è·å–æ ¸å¿ƒID
        let core_ids = core_affinity::get_core_ids().unwrap();

        let mut handles = vec![];

        for i in 0..self.worker_count {
            let core_id = core_ids[i % core_ids.len()];
            let request_count = Arc::clone(&self.request_count);

            let handle = thread::spawn(move || {
                // ç»‘å®šåˆ°ç‰¹å®šæ ¸å¿ƒ
                core_affinity::set_for_current(core_id);

                // å¤„ç†è¯·æ±‚
                loop {
                    // æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†
                    request_count.fetch_add(1, Ordering::Relaxed);

                    // é¿å…è¿‡åº¦æ¶ˆè€—CPU
                    thread::yield_now();
                }
            });

            handles.push(handle);
        }

        // ç›‘æ§çº¿ç¨‹
        thread::spawn(move || {
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
                let count = self.request_count.swap(0, Ordering::Relaxed);
                println!("Requests/sec: {}", count);
            }
        });

        for handle in handles {
            handle.join().unwrap();
        }
    }
}

fn main() {
    let server = HighPerfServer::new(4);
    server.start();
}
```

---

## 9. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [core_affinity](https://docs.rs/core_affinity)
- [thread_priority](https://docs.rs/thread_priority)
- [jemalloc](https://jemalloc.net/)

### ç³»ç»Ÿç¼–ç¨‹ä¹¦ç±

- "Systems Performance" by Brendan Gregg
- "Linux System Programming" by Robert Love

### å†…éƒ¨æ–‡æ¡£

- [â† ä¸Šä¸€ç¯‡ï¼šé«˜çº§å¹¶å‘æ¨¡å¼](./01_é«˜çº§å¹¶å‘æ¨¡å¼.md)
- [â†’ Tier 1ï¼šåŸºç¡€æ¦‚å¿µ](../tier_01_foundations/)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
