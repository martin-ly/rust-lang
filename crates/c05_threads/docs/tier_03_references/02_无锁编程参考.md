# C05 Tier 3 å‚è€ƒæ–‡æ¡£ 02ï¼šæ— é”ç¼–ç¨‹å‚è€ƒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 3 å‚è€ƒæ–‡æ¡£ 02ï¼šæ— é”ç¼–ç¨‹å‚è€ƒ](#c05-tier-3-å‚è€ƒæ–‡æ¡£-02æ— é”ç¼–ç¨‹å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. æ— é”ç¼–ç¨‹åŸºç¡€](#1-æ— é”ç¼–ç¨‹åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯æ— é”ç¼–ç¨‹](#11-ä»€ä¹ˆæ˜¯æ— é”ç¼–ç¨‹)
    - [1.2 ä¸ºä»€ä¹ˆéœ€è¦æ— é”ç¼–ç¨‹](#12-ä¸ºä»€ä¹ˆéœ€è¦æ— é”ç¼–ç¨‹)
    - [1.3 æ— é”ç¼–ç¨‹çš„éš¾ç‚¹](#13-æ— é”ç¼–ç¨‹çš„éš¾ç‚¹)
  - [2. å†…å­˜åºè¯¦è§£](#2-å†…å­˜åºè¯¦è§£)
    - [2.1 Relaxed](#21-relaxed)
    - [2.2 Acquire / Release](#22-acquire--release)
    - [2.3 AcqRel](#23-acqrel)
    - [2.4 SeqCst](#24-seqcst)
    - [2.5 å†…å­˜åºé€‰æ‹©æŒ‡å—](#25-å†…å­˜åºé€‰æ‹©æŒ‡å—)
  - [3. åŸå­æ“ä½œæ¨¡å¼](#3-åŸå­æ“ä½œæ¨¡å¼)
    - [3.1 è®¡æ•°å™¨](#31-è®¡æ•°å™¨)
    - [3.2 æ ‡å¿—ä½](#32-æ ‡å¿—ä½)
    - [3.3 Compare-And-Swap (CAS)](#33-compare-and-swap-cas)
    - [3.4 è¯»æ”¹å†™æ“ä½œ](#34-è¯»æ”¹å†™æ“ä½œ)
  - [4. å¸¸è§æ— é”æ•°æ®ç»“æ„](#4-å¸¸è§æ— é”æ•°æ®ç»“æ„)
    - [4.1 æ— é”æ ˆï¼ˆTreiber Stackï¼‰](#41-æ— é”æ ˆtreiber-stack)
    - [4.2 æ— é”é˜Ÿåˆ—ï¼ˆMichael-Scott Queueï¼‰](#42-æ— é”é˜Ÿåˆ—michael-scott-queue)
    - [4.3 æ— é”è®¡æ•°å™¨](#43-æ— é”è®¡æ•°å™¨)
  - [5. ABA é—®é¢˜](#5-aba-é—®é¢˜)
    - [5.1 é—®é¢˜æè¿°](#51-é—®é¢˜æè¿°)
    - [5.2 è§£å†³æ–¹æ¡ˆ](#52-è§£å†³æ–¹æ¡ˆ)
  - [6. Fence æ“ä½œ](#6-fence-æ“ä½œ)
    - [6.1 compiler\_fence](#61-compiler_fence)
    - [6.2 fence](#62-fence)
  - [7. æ€§èƒ½è€ƒè™‘](#7-æ€§èƒ½è€ƒè™‘)
    - [7.1 False Sharingï¼ˆä¼ªå…±äº«ï¼‰](#71-false-sharingä¼ªå…±äº«)
    - [7.2 ç¼“å­˜è¡Œå¡«å……](#72-ç¼“å­˜è¡Œå¡«å……)
  - [8. æ¨è Crates](#8-æ¨è-crates)
    - [8.1 crossbeam](#81-crossbeam)
    - [8.2 parking\_lot](#82-parking_lot)
    - [8.3 atomic](#83-atomic)
  - [9. å‚è€ƒèµ„æº](#9-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æ¨èä¹¦ç±](#æ¨èä¹¦ç±)
    - [å†…éƒ¨æ–‡æ¡£](#å†…éƒ¨æ–‡æ¡£)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ— é”ç¼–ç¨‹ (Lock-Free Programming)**:

- **å®šä¹‰**: ä½¿ç”¨åŸå­æ“ä½œè€Œéäº’æ–¥é”æ¥å®ç°çº¿ç¨‹å®‰å…¨çš„å¹¶å‘ç¼–ç¨‹æŠ€æœ¯
- **ç±»å‹**: å¹¶å‘ç¼–ç¨‹æŠ€æœ¯
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹ã€é«˜æ€§èƒ½è®¡ç®—
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: åŸå­æ“ä½œã€å†…å­˜åºã€CASã€ABAé—®é¢˜

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æ— æ­»é”**: æ²¡æœ‰é”ï¼Œå°±æ²¡æœ‰æ­»é”
- **æ— ä¼˜å…ˆçº§åè½¬**: é«˜ä¼˜å…ˆçº§çº¿ç¨‹ä¸ä¼šè¢«é˜»å¡
- **æ›´å¥½çš„æ‰©å±•æ€§**: åœ¨é«˜ç«äº‰åœºæ™¯ä¸‹æ€§èƒ½æ›´å¥½
- **å®æ—¶æ€§**: æ“ä½œå»¶è¿Ÿæ›´å¯é¢„æµ‹

**æ€§èƒ½ç‰¹å¾**:

- **é«˜å¹¶å‘**: æ”¯æŒé«˜å¹¶å‘è®¿é—®
- **ä½å»¶è¿Ÿ**: æ“ä½œå»¶è¿Ÿå¯é¢„æµ‹
- **é€‚ç”¨åœºæ™¯**: é«˜æ€§èƒ½ç³»ç»Ÿã€å®æ—¶ç³»ç»Ÿã€æ— é”æ•°æ®ç»“æ„

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- æ— é”ç¼–ç¨‹ --[is-a]--> å¹¶å‘ç¼–ç¨‹æŠ€æœ¯
- åŸå­æ“ä½œ --[is-a]--> æ— é”ç¼–ç¨‹æŠ€æœ¯

**ç»„åˆå…³ç³»**:

- æ— é”æ•°æ®ç»“æ„ --[uses]--> æ— é”ç¼–ç¨‹
- é«˜æ€§èƒ½ç³»ç»Ÿ --[uses]--> æ— é”ç¼–ç¨‹

**ä¾èµ–å…³ç³»**:

- æ— é”ç¼–ç¨‹ --[depends-on]--> åŸå­æ“ä½œ
- æ— é”ç¼–ç¨‹ --[depends-on]--> å†…å­˜åº

### æ€ç»´å¯¼å›¾

```text
æ— é”ç¼–ç¨‹å‚è€ƒ
â”‚
â”œâ”€â”€ æ— é”ç¼–ç¨‹åŸºç¡€
â”‚   â”œâ”€â”€ åŸå­æ“ä½œ
â”‚   â””â”€â”€ å†…å­˜åº
â”œâ”€â”€ åŸå­æ“ä½œæ¨¡å¼
â”‚   â”œâ”€â”€ è®¡æ•°å™¨
â”‚   â”œâ”€â”€ æ ‡å¿—ä½
â”‚   â””â”€â”€ CAS
â”œâ”€â”€ æ— é”æ•°æ®ç»“æ„
â”‚   â”œâ”€â”€ æ— é”æ ˆ
â”‚   â””â”€â”€ æ— é”é˜Ÿåˆ—
â”œâ”€â”€ ABA é—®é¢˜
â”‚   â””â”€â”€ è§£å†³æ–¹æ¡ˆ
â””â”€â”€ æ€§èƒ½è€ƒè™‘
    â”œâ”€â”€ False Sharing
    â””â”€â”€ ç¼“å­˜è¡Œå¡«å……
```

---

## 1. æ— é”ç¼–ç¨‹åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯æ— é”ç¼–ç¨‹

æ— é”ç¼–ç¨‹ï¼ˆLock-Free Programmingï¼‰æ˜¯ä¸€ç§å¹¶å‘ç¼–ç¨‹æŠ€æœ¯ï¼Œä½¿ç”¨åŸå­æ“ä½œè€Œéäº’æ–¥é”æ¥å®ç°çº¿ç¨‹å®‰å…¨ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               æœ‰é” vs æ— é”                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  æœ‰é” (Mutex):                                       â”‚
â”‚  Thread 1: lock() -> modify -> unlock()             â”‚
â”‚  Thread 2:   wait... -> lock() -> modify -> unlock()â”‚
â”‚                                                      â”‚
â”‚  æ— é” (Atomic):                                      â”‚
â”‚  Thread 1: atomic_op() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º success         â”‚
â”‚  Thread 2: atomic_op() â”€â”€â”€â”                         â”‚
â”‚                            â””â”€ retry â”€â–º success      â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦æ— é”ç¼–ç¨‹

| ä¼˜åŠ¿             | è¯´æ˜                               |
| :--- | :--- || **æ— æ­»é”**       | æ²¡æœ‰é”ï¼Œå°±æ²¡æœ‰æ­»é”                 |
| **æ— ä¼˜å…ˆçº§åè½¬** | é«˜ä¼˜å…ˆçº§çº¿ç¨‹ä¸ä¼šè¢«ä½ä¼˜å…ˆçº§çº¿ç¨‹é˜»å¡ |
| **æ›´å¥½çš„æ‰©å±•æ€§** | åœ¨é«˜ç«äº‰åœºæ™¯ä¸‹æ€§èƒ½æ›´å¥½             |
| **å®æ—¶æ€§**       | æ“ä½œå»¶è¿Ÿæ›´å¯é¢„æµ‹                   |

| åŠ£åŠ¿           | è¯´æ˜               |
| :--- | :--- || **å¤æ‚æ€§**     | éš¾ä»¥æ­£ç¡®å®ç°       |
| **ABA é—®é¢˜**   | éœ€è¦ç‰¹æ®Šå¤„ç†       |
| **æœ‰é™çš„æ“ä½œ** | åªèƒ½è¿›è¡ŒåŸå­æ“ä½œ   |
| **ä¸æ€»æ˜¯æ›´å¿«** | ä½ç«äº‰æ—¶å¯èƒ½æ¯”é”æ…¢ |

---

### 1.3 æ— é”ç¼–ç¨‹çš„éš¾ç‚¹

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

// âŒ é”™è¯¯ï¼šéåŸå­çš„è¯»-æ”¹-å†™
fn incorrect_increment(counter: &AtomicUsize) {
    let old = counter.load(Ordering::Relaxed);
    counter.store(old + 1, Ordering::Relaxed); // ç«äº‰æ¡ä»¶ï¼
}

// âœ… æ­£ç¡®ï¼šåŸå­çš„è¯»-æ”¹-å†™
fn correct_increment(counter: &AtomicUsize) {
    counter.fetch_add(1, Ordering::Relaxed);
}
```

---

## 2. å†…å­˜åºè¯¦è§£

### 2.1 Relaxed

æœ€å¼±çš„å†…å­˜åºï¼Œåªä¿è¯åŸå­æ€§ï¼Œä¸ä¿è¯é¡ºåºã€‚

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

fn main() {
    // é€‚ç”¨äºç®€å•è®¡æ•°å™¨
    COUNTER.fetch_add(1, Ordering::Relaxed);

    let value = COUNTER.load(Ordering::Relaxed);
    println!("Counter: {}", value);
}
```

**ç‰¹æ€§**:

- âœ… ä¿è¯åŸå­æ€§
- âŒ ä¸ä¿è¯ä¸å…¶ä»–çº¿ç¨‹çš„å¯è§æ€§é¡ºåº
- âœ… æœ€é«˜æ€§èƒ½
- ğŸ¯ **é€‚ç”¨**: ç®€å•è®¡æ•°ã€ç»Ÿè®¡

---

### 2.2 Acquire / Release

å»ºç«‹åŒæ­¥å…³ç³»ï¼šRelease å‘å¸ƒï¼ŒAcquire è·å–ã€‚

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

static DATA: AtomicUsize = AtomicUsize::new(0);
static READY: AtomicBool = AtomicBool::new(false);

fn producer() {
    DATA.store(42, Ordering::Relaxed);
    READY.store(true, Ordering::Release); // ç¡®ä¿ DATA åœ¨ READY ä¹‹å‰å¯è§
}

fn consumer() {
    while !READY.load(Ordering::Acquire) {} // è·å–åŒæ­¥
    assert_eq!(DATA.load(Ordering::Relaxed), 42); // ä¿è¯èƒ½çœ‹åˆ° 42
}
```

**ç‰¹æ€§**:

- `Release`: ç¡®ä¿ä¹‹å‰çš„å†™æ“ä½œå¯¹è·å–è€…å¯è§
- `Acquire`: ç¡®ä¿èƒ½çœ‹åˆ°å‘å¸ƒè€…ä¹‹å‰çš„å†™æ“ä½œ
- ğŸ¯ **é€‚ç”¨**: ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

---

### 2.3 AcqRel

ç»“åˆ Acquire å’Œ Releaseï¼Œç”¨äºè¯»-æ”¹-å†™æ“ä½œã€‚

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let counter = AtomicUsize::new(0);

    // fetch_add æ˜¯è¯»-æ”¹-å†™æ“ä½œ
    let old = counter.fetch_add(1, Ordering::AcqRel);

    println!("Old value: {}", old);
}
```

**ç‰¹æ€§**:

- åŒæ—¶å…·æœ‰ Acquire å’Œ Release è¯­ä¹‰
- ğŸ¯ **é€‚ç”¨**: fetch_add, fetch_sub, compare_exchange ç­‰

---

### 2.4 SeqCst

é¡ºåºä¸€è‡´æ€§ï¼Œæœ€å¼ºçš„å†…å­˜åºã€‚

```rust
use std::sync::atomic::{AtomicBool, Ordering};

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);

fn thread1() {
    X.store(true, Ordering::SeqCst);
    Y.load(Ordering::SeqCst);
}

fn thread2() {
    Y.store(true, Ordering::SeqCst);
    X.load(Ordering::SeqCst);
}

// SeqCst ä¿è¯æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°ä¸€è‡´çš„å…¨å±€é¡ºåº
```

**ç‰¹æ€§**:

- ä¿è¯å…¨å±€é¡ºåºä¸€è‡´æ€§
- æ€§èƒ½å¼€é”€æœ€å¤§
- ğŸ¯ **é€‚ç”¨**: å¤æ‚åŒæ­¥ã€ä¸ç¡®å®šæ—¶çš„é»˜è®¤é€‰æ‹©

---

### 2.5 å†…å­˜åºé€‰æ‹©æŒ‡å—

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          å†…å­˜åºå†³ç­–æ ‘                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  éœ€è¦åŒæ­¥å—ï¼Ÿ                                        â”‚
â”‚    â”‚                                                â”‚
â”‚    â”œâ”€ å¦ â”€â”€â–º Relaxed (æœ€å¿«)                        â”‚
â”‚    â”‚                                                â”‚
â”‚    â””â”€ æ˜¯ â”€â”€â–º æ˜¯ä»€ä¹ˆæ“ä½œï¼Ÿ                           â”‚
â”‚         â”‚                                           â”‚
â”‚         â”œâ”€ å•çº¯è¯» â”€â”€â–º Acquire                       â”‚
â”‚         â”‚                                           â”‚
â”‚         â”œâ”€ å•çº¯å†™ â”€â”€â–º Release                       â”‚
â”‚         â”‚                                           â”‚
â”‚         â”œâ”€ è¯»-æ”¹-å†™ â”€â”€â–º AcqRel                      â”‚
â”‚         â”‚                                           â”‚
â”‚         â””â”€ ä¸ç¡®å®š â”€â”€â–º SeqCst (æœ€å®‰å…¨)               â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ¨èåŸåˆ™**:

1. é»˜è®¤ä½¿ç”¨ `SeqCst`ï¼ˆå®‰å…¨ç¬¬ä¸€ï¼‰
2. æ€§èƒ½å…³é”®æ—¶é™çº§åˆ° `Acquire/Release`
3. ç®€å•è®¡æ•°å™¨ç”¨ `Relaxed`
4. ä¸ç¡®å®šæ—¶ç”¨ `SeqCst`

---

## 3. åŸå­æ“ä½œæ¨¡å¼

### 3.1 è®¡æ•°å™¨

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", counter.load(Ordering::Relaxed));
}
```

---

### 3.2 æ ‡å¿—ä½

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    let flag = Arc::new(AtomicBool::new(false));
    let flag_clone = Arc::clone(&flag);

    // å·¥ä½œçº¿ç¨‹
    let worker = thread::spawn(move || {
        while !flag_clone.load(Ordering::Acquire) {
            println!("Working...");
            thread::sleep(Duration::from_millis(100));
        }
        println!("Stopping...");
    });

    // ä¸»çº¿ç¨‹
    thread::sleep(Duration::from_secs(1));
    flag.store(true, Ordering::Release);

    worker.join().unwrap();
}
```

---

### 3.3 Compare-And-Swap (CAS)

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let value = AtomicUsize::new(0);

    // å°è¯•å°† 0 æ”¹ä¸º 1
    match value.compare_exchange(
        0,                      // æœŸæœ›å€¼
        1,                      // æ–°å€¼
        Ordering::SeqCst,       // æˆåŠŸæ—¶çš„å†…å­˜åº
        Ordering::SeqCst        // å¤±è´¥æ—¶çš„å†…å­˜åº
    ) {
        Ok(old) => println!("Success! Old value: {}", old),
        Err(current) => println!("Failed! Current value: {}", current),
    }

    // ä½¿ç”¨ compare_exchange_weakï¼ˆå¯èƒ½è™šå‡å¤±è´¥ï¼Œä½†æ›´å¿«ï¼‰
    let mut current = value.load(Ordering::Relaxed);
    loop {
        match value.compare_exchange_weak(
            current,
            current + 1,
            Ordering::SeqCst,
            Ordering::Relaxed
        ) {
            Ok(_) => break,
            Err(x) => current = x,
        }
    }
}
```

---

### 3.4 è¯»æ”¹å†™æ“ä½œ

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let value = AtomicUsize::new(10);

    // åŸå­åŠ 
    let old = value.fetch_add(5, Ordering::Relaxed);
    println!("Old: {}, New: {}", old, value.load(Ordering::Relaxed));

    // åŸå­å‡
    value.fetch_sub(3, Ordering::Relaxed);

    // åŸå­ä¸
    value.fetch_and(0b1111, Ordering::Relaxed);

    // åŸå­æˆ–
    value.fetch_or(0b0001, Ordering::Relaxed);

    // åŸå­å¼‚æˆ–
    value.fetch_xor(0b0011, Ordering::Relaxed);

    // åŸå­æœ€å¤§å€¼
    value.fetch_max(20, Ordering::Relaxed);

    // åŸå­æœ€å°å€¼
    value.fetch_min(5, Ordering::Relaxed);
}
```

---

## 4. å¸¸è§æ— é”æ•°æ®ç»“æ„

### 4.1 æ— é”æ ˆï¼ˆTreiber Stackï¼‰

```rust
use std::ptr;
use std::sync::atomic::{AtomicPtr, Ordering};

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

pub struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Stack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    pub fn push(&self, data: T) {
        let node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        let mut head = self.head.load(Ordering::Relaxed);
        loop {
            unsafe {
                (*node).next = head;
            }

            match self.head.compare_exchange_weak(
                head,
                node,
                Ordering::Release,
                Ordering::Relaxed
            ) {
                Ok(_) => break,
                Err(h) => head = h,
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        let mut head = self.head.load(Ordering::Relaxed);
        loop {
            if head.is_null() {
                return None;
            }

            let next = unsafe { (*head).next };

            match self.head.compare_exchange_weak(
                head,
                next,
                Ordering::Acquire,
                Ordering::Relaxed
            ) {
                Ok(_) => {
                    let data = unsafe { Box::from_raw(head).data };
                    return Some(data);
                }
                Err(h) => head = h,
            }
        }
    }
}

fn main() {
    let stack = Stack::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);

    println!("{:?}", stack.pop()); // Some(3)
    println!("{:?}", stack.pop()); // Some(2)
}
```

---

### 4.2 æ— é”é˜Ÿåˆ—ï¼ˆMichael-Scott Queueï¼‰

**ç®€åŒ–ç‰ˆæœ¬**ï¼ˆå®Œæ•´å®ç°æ›´å¤æ‚ï¼‰:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: Option<T>,
    next: AtomicPtr<Node<T>>,
}

pub struct Queue<T> {
    head: AtomicPtr<Node<T>>,
    tail: AtomicPtr<Node<T>>,
}

impl<T> Queue<T> {
    pub fn new() -> Self {
        let dummy = Box::into_raw(Box::new(Node {
            data: None,
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        Queue {
            head: AtomicPtr::new(dummy),
            tail: AtomicPtr::new(dummy),
        }
    }

    pub fn enqueue(&self, data: T) {
        let node = Box::into_raw(Box::new(Node {
            data: Some(data),
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        loop {
            let tail = self.tail.load(Ordering::Acquire);
            let next = unsafe { (*tail).next.load(Ordering::Acquire) };

            if next.is_null() {
                if unsafe {
                    (*tail).next.compare_exchange(
                        next,
                        node,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).is_ok()
                } {
                    let _ = self.tail.compare_exchange(
                        tail,
                        node,
                        Ordering::Release,
                        Ordering::Relaxed
                    );
                    break;
                }
            } else {
                let _ = self.tail.compare_exchange(
                    tail,
                    next,
                    Ordering::Release,
                    Ordering::Relaxed
                );
            }
        }
    }
}

fn main() {
    let queue = Queue::new();
    queue.enqueue(1);
    queue.enqueue(2);
    // dequeue å®ç°ç•¥...
}
```

---

### 4.3 æ— é”è®¡æ•°å™¨

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct Counter {
    count: AtomicUsize,
}

impl Counter {
    pub fn new() -> Self {
        Counter {
            count: AtomicUsize::new(0),
        }
    }

    pub fn increment(&self) -> usize {
        self.count.fetch_add(1, Ordering::Relaxed)
    }

    pub fn decrement(&self) -> usize {
        self.count.fetch_sub(1, Ordering::Relaxed)
    }

    pub fn get(&self) -> usize {
        self.count.load(Ordering::Relaxed)
    }

    pub fn reset(&self) -> usize {
        self.count.swap(0, Ordering::Relaxed)
    }
}

fn main() {
    let counter = Counter::new();
    counter.increment();
    counter.increment();
    println!("Count: {}", counter.get()); // 2
}
```

---

## 5. ABA é—®é¢˜

### 5.1 é—®é¢˜æè¿°

```rust
// âŒ ABA é—®é¢˜ç¤ºä¾‹
// çº¿ç¨‹ 1: è¯»å– A
// çº¿ç¨‹ 2: å°† A æ”¹ä¸º Bï¼Œå†æ”¹å› A
// çº¿ç¨‹ 1: CAS æˆåŠŸï¼ˆä½†ä¸­é—´çŠ¶æ€å·²å˜åŒ–ï¼‰

use std::sync::atomic::{AtomicPtr, Ordering};

fn aba_problem_example() {
    let ptr: AtomicPtr<i32> = AtomicPtr::new(Box::into_raw(Box::new(42)));

    // Thread 1 è¯»å–
    let old_ptr = ptr.load(Ordering::Acquire);

    // Thread 2 ä¿®æ”¹
    let new_ptr = Box::into_raw(Box::new(100));
    ptr.store(new_ptr, Ordering::Release);

    // Thread 2 åˆæ”¹å›å»
    ptr.store(old_ptr, Ordering::Release);

    // Thread 1 çš„ CAS ä¼šæˆåŠŸï¼Œä½†çŠ¶æ€å·²å˜åŒ–ï¼
    let _ = ptr.compare_exchange(
        old_ptr,
        Box::into_raw(Box::new(200)),
        Ordering::AcqRel,
        Ordering::Acquire
    );
}
```

---

### 5.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1: ä½¿ç”¨ç‰ˆæœ¬å·**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

struct Versioned<T> {
    ptr: *mut T,
    version: usize,
}

struct VersionedPtr {
    data: AtomicUsize, // æ‰“åŒ… ptr å’Œ version
}

impl VersionedPtr {
    fn new<T>(ptr: *mut T) -> Self {
        let packed = (ptr as usize) | (0 << 48); // å‡è®¾ version å­˜å‚¨åœ¨é«˜ä½
        VersionedPtr {
            data: AtomicUsize::new(packed),
        }
    }

    fn load(&self) -> (*mut u8, usize) {
        let packed = self.data.load(Ordering::Acquire);
        let ptr = (packed & 0xFFFF_FFFF_FFFF) as *mut u8;
        let version = packed >> 48;
        (ptr, version)
    }

    fn compare_exchange(
        &self,
        current_ptr: *mut u8,
        current_version: usize,
        new_ptr: *mut u8,
        new_version: usize,
    ) -> bool {
        let current_packed = (current_ptr as usize) | (current_version << 48);
        let new_packed = (new_ptr as usize) | (new_version << 48);

        self.data.compare_exchange(
            current_packed,
            new_packed,
            Ordering::AcqRel,
            Ordering::Acquire
        ).is_ok()
    }
}
```

**æ–¹æ¡ˆ 2: ä½¿ç”¨ crossbeam çš„ epoch-based reclamation**:

```rust
use crossbeam_epoch::{self as epoch, Atomic, Owned};
use std::sync::atomic::Ordering;

struct Node<T> {
    data: T,
    next: Atomic<Node<T>>,
}

fn push<T>(head: &Atomic<Node<T>>, data: T) {
    let guard = &epoch::pin();
    let node = Owned::new(Node {
        data,
        next: Atomic::null(),
    });

    loop {
        let head_ptr = head.load(Ordering::Acquire, guard);
        node.next.store(head_ptr, Ordering::Relaxed);

        match head.compare_exchange(
            head_ptr,
            node,
            Ordering::Release,
            Ordering::Acquire,
            guard
        ) {
            Ok(_) => break,
            Err(e) => node = e.new,
        }
    }
}
```

---

## 6. Fence æ“ä½œ

### 6.1 compiler_fence

é˜²æ­¢ç¼–è¯‘å™¨é‡æ’åºï¼Œä½†ä¸å½±å“ CPUã€‚

```rust
use std::sync::atomic::{compiler_fence, Ordering};

fn main() {
    let mut x = 0;
    let mut y = 0;

    x = 1;
    compiler_fence(Ordering::Release); // é˜²æ­¢ç¼–è¯‘å™¨å°† y=1 ç§»åˆ° x=1 ä¹‹å‰
    y = 1;
}
```

---

### 6.2 fence

é˜²æ­¢ CPU é‡æ’åºã€‚

```rust
use std::sync::atomic::{fence, AtomicBool, Ordering};

static FLAG: AtomicBool = AtomicBool::new(false);
static mut DATA: i32 = 0;

fn writer() {
    unsafe {
        DATA = 42;
    }
    fence(Ordering::Release); // ç¡®ä¿ DATA å†™å…¥åœ¨ FLAG ä¹‹å‰å¯è§
    FLAG.store(true, Ordering::Relaxed);
}

fn reader() {
    while !FLAG.load(Ordering::Relaxed) {}
    fence(Ordering::Acquire); // ç¡®ä¿èƒ½çœ‹åˆ° DATA çš„å†™å…¥
    unsafe {
        assert_eq!(DATA, 42);
    }
}
```

---

## 7. æ€§èƒ½è€ƒè™‘

### 7.1 False Sharingï¼ˆä¼ªå…±äº«ï¼‰

```rust
use std::sync::atomic::AtomicUsize;

// âŒ ä¼ªå…±äº«ï¼šä¸¤ä¸ªåŸå­å˜é‡åœ¨åŒä¸€ç¼“å­˜è¡Œ
struct BadCounter {
    counter1: AtomicUsize, // 8 bytes
    counter2: AtomicUsize, // 8 bytes  <- å¯èƒ½ä¸ counter1 åœ¨åŒä¸€ç¼“å­˜è¡Œ
}

// âœ… é¿å…ä¼ªå…±äº«ï¼šå¡«å……åˆ°ä¸åŒç¼“å­˜è¡Œ
#[repr(align(64))]
struct GoodCounter {
    counter1: AtomicUsize,
    _pad1: [u8; 56], // 64 - 8 = 56
    counter2: AtomicUsize,
    _pad2: [u8; 56],
}
```

---

### 7.2 ç¼“å­˜è¡Œå¡«å……

```rust
#[repr(align(64))]
pub struct CacheLinePadded<T> {
    value: T,
    _padding: [u8; 64 - std::mem::size_of::<T>()],
}

use std::sync::atomic::AtomicUsize;

type PaddedCounter = CacheLinePadded<AtomicUsize>;

fn main() {
    let counter = PaddedCounter {
        value: AtomicUsize::new(0),
        _padding: [0; 64 - 8],
    };

    counter.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
}
```

---

## 8. æ¨è Crates

### 8.1 crossbeam

æä¾›é«˜çº§æ— é”æ•°æ®ç»“æ„ã€‚

```rust
use crossbeam::queue::ArrayQueue;

let queue = ArrayQueue::new(100);
queue.push(1).unwrap();
queue.push(2).unwrap();

assert_eq!(queue.pop(), Some(1));
```

---

### 8.2 parking_lot

æ›´å¿«çš„åŒæ­¥åŸè¯­ã€‚

```rust
use parking_lot::Mutex;

let mutex = Mutex::new(0);
*mutex.lock() += 1;
```

---

### 8.3 atomic

æ‰©å±•çš„åŸå­ç±»å‹ã€‚

```rust
use atomic::Atomic;

let value = Atomic::new(0u64);
value.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
```

---

## 9. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [std::sync::atomic](https://doc.rust-lang.org/std/sync/atomic/)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)

### æ¨èä¹¦ç±

- "The Art of Multiprocessor Programming" by Maurice Herlihy
- "C++ Concurrency in Action" by Anthony Williams

### å†…éƒ¨æ–‡æ¡£

- [â† ä¸Šä¸€ç¯‡ï¼šAPI å‚è€ƒæ‰‹å†Œ](./01_APIå‚è€ƒæ‰‹å†Œ.md)
- [â†’ ä¸‹ä¸€ç¯‡ï¼šæ€§èƒ½åŸºå‡†å‚è€ƒ](./03_æ€§èƒ½åŸºå‡†å‚è€ƒ.md)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
