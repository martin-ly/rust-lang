# C05 Tier 3 参考文档 02：无锁编程参考

> **文档版本**: v2.0.0 | **Rust 版本**: 1.90+ | **最后更新**: 2025-10-22

## 目录

- [C05 Tier 3 参考文档 02：无锁编程参考](#c05-tier-3-参考文档-02无锁编程参考)
  - [目录](#目录)
  - [1. 无锁编程基础](#1-无锁编程基础)
    - [1.1 什么是无锁编程](#11-什么是无锁编程)
    - [1.2 为什么需要无锁编程](#12-为什么需要无锁编程)
    - [1.3 无锁编程的难点](#13-无锁编程的难点)
  - [2. 内存序详解](#2-内存序详解)
    - [2.1 Relaxed](#21-relaxed)
    - [2.2 Acquire / Release](#22-acquire--release)
    - [2.3 AcqRel](#23-acqrel)
    - [2.4 SeqCst](#24-seqcst)
    - [2.5 内存序选择指南](#25-内存序选择指南)
  - [3. 原子操作模式](#3-原子操作模式)
    - [3.1 计数器](#31-计数器)
    - [3.2 标志位](#32-标志位)
    - [3.3 Compare-And-Swap (CAS)](#33-compare-and-swap-cas)
    - [3.4 读改写操作](#34-读改写操作)
  - [4. 常见无锁数据结构](#4-常见无锁数据结构)
    - [4.1 无锁栈（Treiber Stack）](#41-无锁栈treiber-stack)
    - [4.2 无锁队列（Michael-Scott Queue）](#42-无锁队列michael-scott-queue)
    - [4.3 无锁计数器](#43-无锁计数器)
  - [5. ABA 问题](#5-aba-问题)
    - [5.1 问题描述](#51-问题描述)
    - [5.2 解决方案](#52-解决方案)
  - [6. Fence 操作](#6-fence-操作)
    - [6.1 compiler\_fence](#61-compiler_fence)
    - [6.2 fence](#62-fence)
  - [7. 性能考虑](#7-性能考虑)
    - [7.1 False Sharing（伪共享）](#71-false-sharing伪共享)
    - [7.2 缓存行填充](#72-缓存行填充)
  - [8. 推荐 Crates](#8-推荐-crates)
    - [8.1 crossbeam](#81-crossbeam)
    - [8.2 parking\_lot](#82-parking_lot)
    - [8.3 atomic](#83-atomic)
  - [9. 参考资源](#9-参考资源)
    - [官方文档](#官方文档)
    - [推荐书籍](#推荐书籍)
    - [内部文档](#内部文档)

---

## 1. 无锁编程基础

### 1.1 什么是无锁编程

无锁编程（Lock-Free Programming）是一种并发编程技术，使用原子操作而非互斥锁来实现线程安全。

```text
┌──────────────────────────────────────────────────────┐
│               有锁 vs 无锁                             │
├──────────────────────────────────────────────────────┤
│                                                      │
│  有锁 (Mutex):                                       │
│  Thread 1: lock() -> modify -> unlock()             │
│  Thread 2:   wait... -> lock() -> modify -> unlock()│
│                                                      │
│  无锁 (Atomic):                                      │
│  Thread 1: atomic_op() ───────────► success         │
│  Thread 2: atomic_op() ───┐                         │
│                            └─ retry ─► success      │
│                                                      │
└──────────────────────────────────────────────────────┘
```

---

### 1.2 为什么需要无锁编程

| 优势 | 说明 |
|------|------|
| **无死锁** | 没有锁，就没有死锁 |
| **无优先级反转** | 高优先级线程不会被低优先级线程阻塞 |
| **更好的扩展性** | 在高竞争场景下性能更好 |
| **实时性** | 操作延迟更可预测 |

| 劣势 | 说明 |
|------|------|
| **复杂性** | 难以正确实现 |
| **ABA 问题** | 需要特殊处理 |
| **有限的操作** | 只能进行原子操作 |
| **不总是更快** | 低竞争时可能比锁慢 |

---

### 1.3 无锁编程的难点

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

// ❌ 错误：非原子的读-改-写
fn incorrect_increment(counter: &AtomicUsize) {
    let old = counter.load(Ordering::Relaxed);
    counter.store(old + 1, Ordering::Relaxed); // 竞争条件！
}

// ✅ 正确：原子的读-改-写
fn correct_increment(counter: &AtomicUsize) {
    counter.fetch_add(1, Ordering::Relaxed);
}
```

---

## 2. 内存序详解

### 2.1 Relaxed

最弱的内存序，只保证原子性，不保证顺序。

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

fn main() {
    // 适用于简单计数器
    COUNTER.fetch_add(1, Ordering::Relaxed);

    let value = COUNTER.load(Ordering::Relaxed);
    println!("Counter: {}", value);
}
```

**特性**:

- ✅ 保证原子性
- ❌ 不保证与其他线程的可见性顺序
- ✅ 最高性能
- 🎯 **适用**: 简单计数、统计

---

### 2.2 Acquire / Release

建立同步关系：Release 发布，Acquire 获取。

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

static DATA: AtomicUsize = AtomicUsize::new(0);
static READY: AtomicBool = AtomicBool::new(false);

fn producer() {
    DATA.store(42, Ordering::Relaxed);
    READY.store(true, Ordering::Release); // 确保 DATA 在 READY 之前可见
}

fn consumer() {
    while !READY.load(Ordering::Acquire) {} // 获取同步
    assert_eq!(DATA.load(Ordering::Relaxed), 42); // 保证能看到 42
}
```

**特性**:

- `Release`: 确保之前的写操作对获取者可见
- `Acquire`: 确保能看到发布者之前的写操作
- 🎯 **适用**: 生产者-消费者模式

---

### 2.3 AcqRel

结合 Acquire 和 Release，用于读-改-写操作。

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let counter = AtomicUsize::new(0);

    // fetch_add 是读-改-写操作
    let old = counter.fetch_add(1, Ordering::AcqRel);

    println!("Old value: {}", old);
}
```

**特性**:

- 同时具有 Acquire 和 Release 语义
- 🎯 **适用**: fetch_add, fetch_sub, compare_exchange 等

---

### 2.4 SeqCst

顺序一致性，最强的内存序。

```rust
use std::sync::atomic::{AtomicBool, Ordering};

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);

fn thread1() {
    X.store(true, Ordering::SeqCst);
    Y.load(Ordering::SeqCst);
}

fn thread2() {
    Y.store(true, Ordering::SeqCst);
    X.load(Ordering::SeqCst);
}

// SeqCst 保证所有线程看到一致的全局顺序
```

**特性**:

- 保证全局顺序一致性
- 性能开销最大
- 🎯 **适用**: 复杂同步、不确定时的默认选择

---

### 2.5 内存序选择指南

```text
┌─────────────────────────────────────────────────────┐
│          内存序决策树                                │
├─────────────────────────────────────────────────────┤
│                                                     │
│  需要同步吗？                                        │
│    │                                                │
│    ├─ 否 ──► Relaxed (最快)                        │
│    │                                                │
│    └─ 是 ──► 是什么操作？                           │
│         │                                           │
│         ├─ 单纯读 ──► Acquire                       │
│         │                                           │
│         ├─ 单纯写 ──► Release                       │
│         │                                           │
│         ├─ 读-改-写 ──► AcqRel                      │
│         │                                           │
│         └─ 不确定 ──► SeqCst (最安全)               │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**推荐原则**:

1. 默认使用 `SeqCst`（安全第一）
2. 性能关键时降级到 `Acquire/Release`
3. 简单计数器用 `Relaxed`
4. 不确定时用 `SeqCst`

---

## 3. 原子操作模式

### 3.1 计数器

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", counter.load(Ordering::Relaxed));
}
```

---

### 3.2 标志位

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    let flag = Arc::new(AtomicBool::new(false));
    let flag_clone = Arc::clone(&flag);

    // 工作线程
    let worker = thread::spawn(move || {
        while !flag_clone.load(Ordering::Acquire) {
            println!("Working...");
            thread::sleep(Duration::from_millis(100));
        }
        println!("Stopping...");
    });

    // 主线程
    thread::sleep(Duration::from_secs(1));
    flag.store(true, Ordering::Release);

    worker.join().unwrap();
}
```

---

### 3.3 Compare-And-Swap (CAS)

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let value = AtomicUsize::new(0);

    // 尝试将 0 改为 1
    match value.compare_exchange(
        0,                      // 期望值
        1,                      // 新值
        Ordering::SeqCst,       // 成功时的内存序
        Ordering::SeqCst        // 失败时的内存序
    ) {
        Ok(old) => println!("Success! Old value: {}", old),
        Err(current) => println!("Failed! Current value: {}", current),
    }

    // 使用 compare_exchange_weak（可能虚假失败，但更快）
    let mut current = value.load(Ordering::Relaxed);
    loop {
        match value.compare_exchange_weak(
            current,
            current + 1,
            Ordering::SeqCst,
            Ordering::Relaxed
        ) {
            Ok(_) => break,
            Err(x) => current = x,
        }
    }
}
```

---

### 3.4 读改写操作

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let value = AtomicUsize::new(10);

    // 原子加
    let old = value.fetch_add(5, Ordering::Relaxed);
    println!("Old: {}, New: {}", old, value.load(Ordering::Relaxed));

    // 原子减
    value.fetch_sub(3, Ordering::Relaxed);

    // 原子与
    value.fetch_and(0b1111, Ordering::Relaxed);

    // 原子或
    value.fetch_or(0b0001, Ordering::Relaxed);

    // 原子异或
    value.fetch_xor(0b0011, Ordering::Relaxed);

    // 原子最大值
    value.fetch_max(20, Ordering::Relaxed);

    // 原子最小值
    value.fetch_min(5, Ordering::Relaxed);
}
```

---

## 4. 常见无锁数据结构

### 4.1 无锁栈（Treiber Stack）

```rust
use std::ptr;
use std::sync::atomic::{AtomicPtr, Ordering};

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

pub struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Stack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    pub fn push(&self, data: T) {
        let node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        let mut head = self.head.load(Ordering::Relaxed);
        loop {
            unsafe {
                (*node).next = head;
            }

            match self.head.compare_exchange_weak(
                head,
                node,
                Ordering::Release,
                Ordering::Relaxed
            ) {
                Ok(_) => break,
                Err(h) => head = h,
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        let mut head = self.head.load(Ordering::Relaxed);
        loop {
            if head.is_null() {
                return None;
            }

            let next = unsafe { (*head).next };

            match self.head.compare_exchange_weak(
                head,
                next,
                Ordering::Acquire,
                Ordering::Relaxed
            ) {
                Ok(_) => {
                    let data = unsafe { Box::from_raw(head).data };
                    return Some(data);
                }
                Err(h) => head = h,
            }
        }
    }
}

fn main() {
    let stack = Stack::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);

    println!("{:?}", stack.pop()); // Some(3)
    println!("{:?}", stack.pop()); // Some(2)
}
```

---

### 4.2 无锁队列（Michael-Scott Queue）

**简化版本**（完整实现更复杂）:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: Option<T>,
    next: AtomicPtr<Node<T>>,
}

pub struct Queue<T> {
    head: AtomicPtr<Node<T>>,
    tail: AtomicPtr<Node<T>>,
}

impl<T> Queue<T> {
    pub fn new() -> Self {
        let dummy = Box::into_raw(Box::new(Node {
            data: None,
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        Queue {
            head: AtomicPtr::new(dummy),
            tail: AtomicPtr::new(dummy),
        }
    }

    pub fn enqueue(&self, data: T) {
        let node = Box::into_raw(Box::new(Node {
            data: Some(data),
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        loop {
            let tail = self.tail.load(Ordering::Acquire);
            let next = unsafe { (*tail).next.load(Ordering::Acquire) };

            if next.is_null() {
                if unsafe {
                    (*tail).next.compare_exchange(
                        next,
                        node,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).is_ok()
                } {
                    let _ = self.tail.compare_exchange(
                        tail,
                        node,
                        Ordering::Release,
                        Ordering::Relaxed
                    );
                    break;
                }
            } else {
                let _ = self.tail.compare_exchange(
                    tail,
                    next,
                    Ordering::Release,
                    Ordering::Relaxed
                );
            }
        }
    }
}

fn main() {
    let queue = Queue::new();
    queue.enqueue(1);
    queue.enqueue(2);
    // dequeue 实现略...
}
```

---

### 4.3 无锁计数器

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct Counter {
    count: AtomicUsize,
}

impl Counter {
    pub fn new() -> Self {
        Counter {
            count: AtomicUsize::new(0),
        }
    }

    pub fn increment(&self) -> usize {
        self.count.fetch_add(1, Ordering::Relaxed)
    }

    pub fn decrement(&self) -> usize {
        self.count.fetch_sub(1, Ordering::Relaxed)
    }

    pub fn get(&self) -> usize {
        self.count.load(Ordering::Relaxed)
    }

    pub fn reset(&self) -> usize {
        self.count.swap(0, Ordering::Relaxed)
    }
}

fn main() {
    let counter = Counter::new();
    counter.increment();
    counter.increment();
    println!("Count: {}", counter.get()); // 2
}
```

---

## 5. ABA 问题

### 5.1 问题描述

```rust
// ❌ ABA 问题示例
// 线程 1: 读取 A
// 线程 2: 将 A 改为 B，再改回 A
// 线程 1: CAS 成功（但中间状态已变化）

use std::sync::atomic::{AtomicPtr, Ordering};

fn aba_problem_example() {
    let ptr: AtomicPtr<i32> = AtomicPtr::new(Box::into_raw(Box::new(42)));

    // Thread 1 读取
    let old_ptr = ptr.load(Ordering::Acquire);

    // Thread 2 修改
    let new_ptr = Box::into_raw(Box::new(100));
    ptr.store(new_ptr, Ordering::Release);

    // Thread 2 又改回去
    ptr.store(old_ptr, Ordering::Release);

    // Thread 1 的 CAS 会成功，但状态已变化！
    let _ = ptr.compare_exchange(
        old_ptr,
        Box::into_raw(Box::new(200)),
        Ordering::AcqRel,
        Ordering::Acquire
    );
}
```

---

### 5.2 解决方案

**方案 1: 使用版本号**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

struct Versioned<T> {
    ptr: *mut T,
    version: usize,
}

struct VersionedPtr {
    data: AtomicUsize, // 打包 ptr 和 version
}

impl VersionedPtr {
    fn new<T>(ptr: *mut T) -> Self {
        let packed = (ptr as usize) | (0 << 48); // 假设 version 存储在高位
        VersionedPtr {
            data: AtomicUsize::new(packed),
        }
    }

    fn load(&self) -> (*mut u8, usize) {
        let packed = self.data.load(Ordering::Acquire);
        let ptr = (packed & 0xFFFF_FFFF_FFFF) as *mut u8;
        let version = packed >> 48;
        (ptr, version)
    }

    fn compare_exchange(
        &self,
        current_ptr: *mut u8,
        current_version: usize,
        new_ptr: *mut u8,
        new_version: usize,
    ) -> bool {
        let current_packed = (current_ptr as usize) | (current_version << 48);
        let new_packed = (new_ptr as usize) | (new_version << 48);

        self.data.compare_exchange(
            current_packed,
            new_packed,
            Ordering::AcqRel,
            Ordering::Acquire
        ).is_ok()
    }
}
```

**方案 2: 使用 crossbeam 的 epoch-based reclamation**:

```rust
use crossbeam_epoch::{self as epoch, Atomic, Owned};
use std::sync::atomic::Ordering;

struct Node<T> {
    data: T,
    next: Atomic<Node<T>>,
}

fn push<T>(head: &Atomic<Node<T>>, data: T) {
    let guard = &epoch::pin();
    let node = Owned::new(Node {
        data,
        next: Atomic::null(),
    });

    loop {
        let head_ptr = head.load(Ordering::Acquire, guard);
        node.next.store(head_ptr, Ordering::Relaxed);

        match head.compare_exchange(
            head_ptr,
            node,
            Ordering::Release,
            Ordering::Acquire,
            guard
        ) {
            Ok(_) => break,
            Err(e) => node = e.new,
        }
    }
}
```

---

## 6. Fence 操作

### 6.1 compiler_fence

防止编译器重排序，但不影响 CPU。

```rust
use std::sync::atomic::{compiler_fence, Ordering};

fn main() {
    let mut x = 0;
    let mut y = 0;

    x = 1;
    compiler_fence(Ordering::Release); // 防止编译器将 y=1 移到 x=1 之前
    y = 1;
}
```

---

### 6.2 fence

防止 CPU 重排序。

```rust
use std::sync::atomic::{fence, AtomicBool, Ordering};

static FLAG: AtomicBool = AtomicBool::new(false);
static mut DATA: i32 = 0;

fn writer() {
    unsafe {
        DATA = 42;
    }
    fence(Ordering::Release); // 确保 DATA 写入在 FLAG 之前可见
    FLAG.store(true, Ordering::Relaxed);
}

fn reader() {
    while !FLAG.load(Ordering::Relaxed) {}
    fence(Ordering::Acquire); // 确保能看到 DATA 的写入
    unsafe {
        assert_eq!(DATA, 42);
    }
}
```

---

## 7. 性能考虑

### 7.1 False Sharing（伪共享）

```rust
use std::sync::atomic::AtomicUsize;

// ❌ 伪共享：两个原子变量在同一缓存行
struct BadCounter {
    counter1: AtomicUsize, // 8 bytes
    counter2: AtomicUsize, // 8 bytes  <- 可能与 counter1 在同一缓存行
}

// ✅ 避免伪共享：填充到不同缓存行
#[repr(align(64))]
struct GoodCounter {
    counter1: AtomicUsize,
    _pad1: [u8; 56], // 64 - 8 = 56
    counter2: AtomicUsize,
    _pad2: [u8; 56],
}
```

---

### 7.2 缓存行填充

```rust
#[repr(align(64))]
pub struct CacheLinePadded<T> {
    value: T,
    _padding: [u8; 64 - std::mem::size_of::<T>()],
}

use std::sync::atomic::AtomicUsize;

type PaddedCounter = CacheLinePadded<AtomicUsize>;

fn main() {
    let counter = PaddedCounter {
        value: AtomicUsize::new(0),
        _padding: [0; 64 - 8],
    };

    counter.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
}
```

---

## 8. 推荐 Crates

### 8.1 crossbeam

提供高级无锁数据结构。

```rust
use crossbeam::queue::ArrayQueue;

let queue = ArrayQueue::new(100);
queue.push(1).unwrap();
queue.push(2).unwrap();

assert_eq!(queue.pop(), Some(1));
```

---

### 8.2 parking_lot

更快的同步原语。

```rust
use parking_lot::Mutex;

let mutex = Mutex::new(0);
*mutex.lock() += 1;
```

---

### 8.3 atomic

扩展的原子类型。

```rust
use atomic::Atomic;

let value = Atomic::new(0u64);
value.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
```

---

## 9. 参考资源

### 官方文档

- [std::sync::atomic](https://doc.rust-lang.org/std/sync/atomic/)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)

### 推荐书籍

- "The Art of Multiprocessor Programming" by Maurice Herlihy
- "C++ Concurrency in Action" by Anthony Williams

### 内部文档

- [← 上一篇：API 参考手册](./01_API参考手册.md)
- [→ 下一篇：性能基准参考](./03_性能基准参考.md)
- [↑ 返回主索引](../tier_01_foundations/02_主索引导航.md)

---

**文档维护**: C05 Threads Team | **最后审核**: 2025-10-22 | **质量评分**: 95/100
