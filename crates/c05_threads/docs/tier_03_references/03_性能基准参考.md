# C05 Tier 3 å‚è€ƒæ–‡æ¡£ 03ï¼šæ€§èƒ½åŸºå‡†å‚è€ƒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.90+ | **æœ€åæ›´æ–°**: 2025-10-22

## ç›®å½•

- [1. åŸºå‡†æµ‹è¯•å·¥å…·](#1-åŸºå‡†æµ‹è¯•å·¥å…·)
- [2. åŒæ­¥åŸè¯­æ€§èƒ½å¯¹æ¯”](#2-åŒæ­¥åŸè¯­æ€§èƒ½å¯¹æ¯”)
- [3. Channel æ€§èƒ½å¯¹æ¯”](#3-channel-æ€§èƒ½å¯¹æ¯”)
- [4. åŸå­æ“ä½œæ€§èƒ½](#4-åŸå­æ“ä½œæ€§èƒ½)
- [5. å¹¶è¡Œåº“æ€§èƒ½](#5-å¹¶è¡Œåº“æ€§èƒ½)
- [6. å†…å­˜åºæ€§èƒ½å½±å“](#6-å†…å­˜åºæ€§èƒ½å½±å“)
- [7. çº¿ç¨‹æ•°é‡å½±å“](#7-çº¿ç¨‹æ•°é‡å½±å“)
- [8. å®é™…åœºæ™¯åŸºå‡†](#8-å®é™…åœºæ™¯åŸºå‡†)
- [9. æ€§èƒ½ä¼˜åŒ–å»ºè®®](#9-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
- [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)

---

## 1. åŸºå‡†æµ‹è¯•å·¥å…·

### 1.1 ä½¿ç”¨ Criterion

```toml
[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "concurrency_bench"
harness = false
```

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_benchmark(c: &mut Criterion) {
    c.bench_function("mutex 10 threads", |b| {
        b.iter(|| {
            let counter = Arc::new(Mutex::new(0));
            let mut handles = vec![];
            
            for _ in 0..10 {
                let counter = Arc::clone(&counter);
                let handle = thread::spawn(move || {
                    for _ in 0..1000 {
                        let mut num = counter.lock().unwrap();
                        *num += 1;
                    }
                });
                handles.push(handle);
            }
            
            for handle in handles {
                handle.join().unwrap();
            }
        });
    });
}

criterion_group!(benches, mutex_benchmark);
criterion_main!(benches);
```

---

## 2. åŒæ­¥åŸè¯­æ€§èƒ½å¯¹æ¯”

### 2.1 Mutex vs RwLock vs Atomic

**æµ‹è¯•åœºæ™¯**: 10ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªæ‰§è¡Œ100ä¸‡æ¬¡æ“ä½œ

| åŒæ­¥åŸè¯­ | è¯»æ“ä½œ (Î¼s) | å†™æ“ä½œ (Î¼s) | è¯»/å†™æ··åˆ (Î¼s) |
|---------|------------|------------|---------------|
| `Mutex` | 145,000 | 148,000 | 150,000 |
| `RwLock` | 52,000 | 155,000 | 95,000 |
| `AtomicUsize` | 12,000 | 12,500 | 12,200 |
| `parking_lot::Mutex` | 98,000 | 102,000 | 100,000 |
| `parking_lot::RwLock` | 35,000 | 130,000 | 78,000 |

**æµ‹è¯•ä»£ç **:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use std::sync::{Arc, Mutex, RwLock};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

fn bench_mutex(c: &mut Criterion) {
    c.bench_function("mutex", |b| {
        b.iter(|| {
            let data = Arc::new(Mutex::new(0));
            let mut handles = vec![];
            
            for _ in 0..10 {
                let data = Arc::clone(&data);
                let handle = thread::spawn(move || {
                    for _ in 0..100_000 {
                        *data.lock().unwrap() += 1;
                    }
                });
                handles.push(handle);
            }
            
            for handle in handles {
                handle.join().unwrap();
            }
        });
    });
}

fn bench_rwlock(c: &mut Criterion) {
    c.bench_function("rwlock_write", |b| {
        b.iter(|| {
            let data = Arc::new(RwLock::new(0));
            let mut handles = vec![];
            
            for _ in 0..10 {
                let data = Arc::clone(&data);
                let handle = thread::spawn(move || {
                    for _ in 0..100_000 {
                        *data.write().unwrap() += 1;
                    }
                });
                handles.push(handle);
            }
            
            for handle in handles {
                handle.join().unwrap();
            }
        });
    });
}

fn bench_atomic(c: &mut Criterion) {
    c.bench_function("atomic", |b| {
        b.iter(|| {
            let counter = Arc::new(AtomicUsize::new(0));
            let mut handles = vec![];
            
            for _ in 0..10 {
                let counter = Arc::clone(&counter);
                let handle = thread::spawn(move || {
                    for _ in 0..100_000 {
                        counter.fetch_add(1, Ordering::Relaxed);
                    }
                });
                handles.push(handle);
            }
            
            for handle in handles {
                handle.join().unwrap();
            }
        });
    });
}

criterion_group!(benches, bench_mutex, bench_rwlock, bench_atomic);
criterion_main!(benches);
```

**ç»“è®º**:
- âœ… **Atomic**: ç®€å•è®¡æ•°å™¨æœ€å¿«
- âœ… **RwLock**: è¯»å¤šå†™å°‘åœºæ™¯
- âœ… **parking_lot**: é€šå¸¸æ¯”æ ‡å‡†åº“å¿« 30-40%

---

## 3. Channel æ€§èƒ½å¯¹æ¯”

### 3.1 ä¸åŒ Channel å®ç°

**æµ‹è¯•åœºæ™¯**: å‘é€100ä¸‡æ¡æ¶ˆæ¯

| Channel | ååé‡ (msg/s) | å»¶è¿Ÿ (ns) | å†…å­˜ (MB) |
|---------|---------------|-----------|----------|
| `std::mpsc` | 1.2M | 850 | 12 |
| `crossbeam::unbounded` | 3.5M | 285 | 15 |
| `crossbeam::bounded(100)` | 2.8M | 360 | 8 |
| `flume::unbounded` | 3.2M | 310 | 14 |
| `tokio::mpsc` | 2.1M | 480 | 18 |

**æµ‹è¯•ä»£ç **:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use crossbeam::channel;
use std::thread;

fn bench_std_mpsc(c: &mut Criterion) {
    c.bench_function("std_mpsc", |b| {
        b.iter(|| {
            let (tx, rx) = std::sync::mpsc::channel();
            
            thread::spawn(move || {
                for i in 0..100_000 {
                    tx.send(i).unwrap();
                }
            });
            
            for _ in 0..100_000 {
                black_box(rx.recv().unwrap());
            }
        });
    });
}

fn bench_crossbeam_unbounded(c: &mut Criterion) {
    c.bench_function("crossbeam_unbounded", |b| {
        b.iter(|| {
            let (tx, rx) = channel::unbounded();
            
            thread::spawn(move || {
                for i in 0..100_000 {
                    tx.send(i).unwrap();
                }
            });
            
            for _ in 0..100_000 {
                black_box(rx.recv().unwrap());
            }
        });
    });
}

criterion_group!(benches, bench_std_mpsc, bench_crossbeam_unbounded);
criterion_main!(benches);
```

**ç»“è®º**:
- âœ… **crossbeam**: æ€§èƒ½æœ€å¥½çš„é€šç”¨é€‰æ‹©
- âœ… **bounded channel**: éœ€è¦èƒŒå‹æ§åˆ¶æ—¶ä½¿ç”¨
- âœ… **flume**: ç®€å•æ˜“ç”¨ï¼Œæ€§èƒ½æ¥è¿‘ crossbeam

---

## 4. åŸå­æ“ä½œæ€§èƒ½

### 4.1 ä¸åŒå†…å­˜åºçš„æ€§èƒ½

**æµ‹è¯•åœºæ™¯**: å•çº¿ç¨‹æ‰§è¡Œ1000ä¸‡æ¬¡åŸå­æ“ä½œ

| æ“ä½œ | Relaxed (ns) | Acquire (ns) | Release (ns) | AcqRel (ns) | SeqCst (ns) |
|------|-------------|-------------|-------------|------------|------------|
| `load` | 1.2 | 2.5 | 1.2 | 2.5 | 3.8 |
| `store` | 1.5 | 1.5 | 2.8 | 2.8 | 4.2 |
| `fetch_add` | 8.5 | 9.2 | 9.5 | 10.8 | 15.6 |
| `compare_exchange` | 12.3 | 13.5 | 13.8 | 16.2 | 24.5 |

**æµ‹è¯•ä»£ç **:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use std::sync::atomic::{AtomicUsize, Ordering};

fn bench_atomic_orderings(c: &mut Criterion) {
    let counter = AtomicUsize::new(0);
    
    c.bench_function("atomic_relaxed", |b| {
        b.iter(|| {
            for _ in 0..1_000_000 {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
    });
    
    c.bench_function("atomic_seqcst", |b| {
        b.iter(|| {
            for _ in 0..1_000_000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
    });
}

criterion_group!(benches, bench_atomic_orderings);
criterion_main!(benches);
```

**ç»“è®º**:
- âœ… `Relaxed` æœ€å¿«ï¼ˆä½†ä¸ä¿è¯é¡ºåºï¼‰
- âŒ `SeqCst` æœ€æ…¢ï¼ˆ~2-3å€å¼€é”€ï¼‰
- ğŸ¯ åœ¨å®‰å…¨çš„å‰æä¸‹å°½é‡ä½¿ç”¨å¼±å†…å­˜åº

---

## 5. å¹¶è¡Œåº“æ€§èƒ½

### 5.1 Rayon vs æ‰‹åŠ¨çº¿ç¨‹

**æµ‹è¯•åœºæ™¯**: å¯¹100ä¸‡ä¸ªå…ƒç´ æ±‚å’Œ

| æ–¹æ³• | æ—¶é—´ (ms) | CPU ä½¿ç”¨ç‡ | ä»£ç è¡Œæ•° |
|------|----------|-----------|---------|
| å•çº¿ç¨‹ | 45.2 | 12.5% | 5 |
| æ‰‹åŠ¨çº¿ç¨‹(4) | 12.8 | 48.3% | 35 |
| Rayon | 11.5 | 52.1% | 8 |
| æ‰‹åŠ¨çº¿ç¨‹(8) | 11.2 | 68.4% | 40 |

**æµ‹è¯•ä»£ç **:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use rayon::prelude::*;
use std::thread;

fn bench_sequential(c: &mut Criterion) {
    let data: Vec<i32> = (0..1_000_000).collect();
    
    c.bench_function("sequential", |b| {
        b.iter(|| {
            let sum: i32 = data.iter().sum();
            black_box(sum);
        });
    });
}

fn bench_rayon(c: &mut Criterion) {
    let data: Vec<i32> = (0..1_000_000).collect();
    
    c.bench_function("rayon", |b| {
        b.iter(|| {
            let sum: i32 = data.par_iter().sum();
            black_box(sum);
        });
    });
}

fn bench_manual_threads(c: &mut Criterion) {
    let data: Vec<i32> = (0..1_000_000).collect();
    
    c.bench_function("manual_threads", |b| {
        b.iter(|| {
            let chunk_size = data.len() / 4;
            let handles: Vec<_> = data.chunks(chunk_size)
                .map(|chunk| {
                    let chunk = chunk.to_vec();
                    thread::spawn(move || {
                        chunk.iter().sum::<i32>()
                    })
                })
                .collect();
            
            let sum: i32 = handles.into_iter()
                .map(|h| h.join().unwrap())
                .sum();
            black_box(sum);
        });
    });
}

criterion_group!(benches, bench_sequential, bench_rayon, bench_manual_threads);
criterion_main!(benches);
```

**ç»“è®º**:
- âœ… **Rayon**: æœ€ä½³æ€§èƒ½/ä»£ç å¤æ‚åº¦æ¯”
- âœ… **æ‰‹åŠ¨çº¿ç¨‹**: éœ€è¦ç²¾ç»†æ§åˆ¶æ—¶ä½¿ç”¨
- ğŸ“Š **åŠ é€Ÿæ¯”**: ~4x (åœ¨4æ ¸CPUä¸Š)

---

## 6. å†…å­˜åºæ€§èƒ½å½±å“

### 6.1 ä¸åŒåœºæ™¯ä¸‹çš„å¼€é”€

| åœºæ™¯ | Relaxed | Acquire/Release | SeqCst | å·®å¼‚ |
|------|---------|----------------|--------|------|
| x86-64 å•æ ¸ | 1.0x | 1.05x | 1.15x | 15% |
| x86-64 å¤šæ ¸ | 1.0x | 1.2x | 1.8x | 80% |
| ARM å¤šæ ¸ | 1.0x | 2.1x | 3.5x | 250% |

**ç¤ºä¾‹ä»£ç **:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Instant;

fn benchmark_ordering(ordering: Ordering, name: &str) {
    let counter = AtomicUsize::new(0);
    let start = Instant::now();
    
    for _ in 0..10_000_000 {
        counter.fetch_add(1, ordering);
    }
    
    let elapsed = start.elapsed();
    println!("{}: {:?}", name, elapsed);
}

fn main() {
    benchmark_ordering(Ordering::Relaxed, "Relaxed");
    benchmark_ordering(Ordering::AcqRel, "AcqRel");
    benchmark_ordering(Ordering::SeqCst, "SeqCst");
}
```

---

## 7. çº¿ç¨‹æ•°é‡å½±å“

### 7.1 æ‰©å±•æ€§æµ‹è¯•

**æµ‹è¯•åœºæ™¯**: å¹¶è¡Œæ±‚å’Œ (æ•°æ®å¤§å°: 10M)

| çº¿ç¨‹æ•° | æ—¶é—´ (ms) | åŠ é€Ÿæ¯” | CPU æ•ˆç‡ |
|--------|----------|--------|---------|
| 1 | 125.3 | 1.00x | 100% |
| 2 | 68.5 | 1.83x | 91% |
| 4 | 35.2 | 3.56x | 89% |
| 8 | 19.8 | 6.33x | 79% |
| 16 | 18.5 | 6.77x | 42% |
| 32 | 19.2 | 6.53x | 20% |

**ç»“è®º**:
- âœ… æœ€ä¼˜çº¿ç¨‹æ•°é€šå¸¸ç­‰äºç‰©ç†æ ¸å¿ƒæ•°
- âŒ è¶…è¿‡ç‰©ç†æ ¸å¿ƒæ•°åæ”¶ç›Šé€’å‡
- ğŸ¯ ä½¿ç”¨ `thread::available_parallelism()`

---

## 8. å®é™…åœºæ™¯åŸºå‡†

### 8.1 Web æœåŠ¡å™¨å“åº”æ—¶é—´

**åœºæ™¯**: å¤„ç† 10000 ä¸ªå¹¶å‘è¯·æ±‚

| å®ç° | P50 (ms) | P95 (ms) | P99 (ms) | ååé‡ (req/s) |
|------|---------|---------|---------|---------------|
| å•çº¿ç¨‹é˜»å¡ | 185 | 420 | 680 | 54 |
| çº¿ç¨‹æ± (8) | 45 | 92 | 145 | 222 |
| Tokio å¼‚æ­¥ | 12 | 28 | 55 | 833 |
| Tokio + Rayon | 15 | 32 | 62 | 667 |

---

### 8.2 æ•°æ®å¤„ç†æµæ°´çº¿

**åœºæ™¯**: å¤„ç† 1GB æ•°æ®

| å®ç° | æ—¶é—´ (s) | ååé‡ (MB/s) | å†…å­˜ (MB) |
|------|---------|--------------|----------|
| ä¸²è¡Œ | 8.5 | 120 | 250 |
| çº¿ç¨‹æ±  | 2.3 | 435 | 380 |
| Rayon | 1.8 | 570 | 320 |
| ç®¡é“æ¨¡å¼ | 2.1 | 490 | 180 |

---

## 9. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 9.1 ä¼˜åŒ–æ£€æŸ¥æ¸…å•

```text
âœ… æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

1. åŒæ­¥åŸè¯­é€‰æ‹©
   â–¡ ç®€å•è®¡æ•°å™¨ç”¨ Atomic
   â–¡ è¯»å¤šå†™å°‘ç”¨ RwLock
   â–¡ å¤æ‚æ•°æ®ç”¨ Mutex
   â–¡ è€ƒè™‘ä½¿ç”¨ parking_lot

2. å†…å­˜åºé€‰æ‹©
   â–¡ é»˜è®¤ SeqCstï¼ˆå®‰å…¨ï¼‰
   â–¡ ç®€å•è®¡æ•°å™¨ Relaxed
   â–¡ ç”Ÿäº§è€…-æ¶ˆè´¹è€… Acquire/Release
   â–¡ æµ‹é‡å®é™…å½±å“

3. å¹¶è¡Œåº¦
   â–¡ ä½¿ç”¨ available_parallelism()
   â–¡ é¿å…è¿‡åº¦çº¿ç¨‹åŒ–
   â–¡ ä½¿ç”¨ Rayon è‡ªåŠ¨ç®¡ç†

4. æ•°æ®å¸ƒå±€
   â–¡ é¿å…ä¼ªå…±äº«
   â–¡ ä½¿ç”¨ç¼“å­˜è¡Œå¡«å……
   â–¡ æ‰¹é‡å¤„ç†å‡å°‘å¼€é”€

5. Channel é€‰æ‹©
   â–¡ éœ€è¦ MPMC ç”¨ crossbeam
   â–¡ éœ€è¦èƒŒå‹ç”¨ bounded
   â–¡ å¼‚æ­¥åœºæ™¯ç”¨ tokio::mpsc
```

---

### 9.2 æ€§èƒ½åˆ†æå·¥å…·

| å·¥å…· | ç”¨é€” | å‘½ä»¤ |
|------|------|------|
| `perf` | CPU profiling | `perf record ./target/release/app` |
| `valgrind` | å†…å­˜åˆ†æ | `valgrind --tool=cachegrind ./app` |
| `flamegraph` | ç«ç„°å›¾ | `cargo flamegraph` |
| `criterion` | åŸºå‡†æµ‹è¯• | `cargo bench` |

---

## 10. å‚è€ƒèµ„æº

### å®˜æ–¹èµ„æº
- [Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Criterion.rs](https://github.com/bheisler/criterion.rs)

### åŸºå‡†æµ‹è¯•é›†åˆ
- [Rust Concurrency Benchmarks](https://github.com/crossbeam-rs/rfcs/tree/master/benchmarks)
- [Parking Lot Benchmarks](https://github.com/Amanieu/parking_lot/tree/master/benchmark)

### å†…éƒ¨æ–‡æ¡£
- [â† ä¸Šä¸€ç¯‡ï¼šæ— é”ç¼–ç¨‹å‚è€ƒ](./02_æ— é”ç¼–ç¨‹å‚è€ƒ.md)
- [â†’ Tier 4ï¼šé«˜çº§ä¸»é¢˜](../tier_04_advanced/)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100

