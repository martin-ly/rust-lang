# C05 Threads 术语表

> **文档定位**: 并发编程术语的权威参考手册  
> **使用方式**: 查找不理解的术语，了解准确定义和使用场景  
> **相关文档**: [项目概览](./01_项目概览.md) | [主索引导航](./02_主索引导航.md) | [常见问题](./04_常见问题.md)

**最后更新**: 2025-10-22  
**适用版本**: Rust 1.90+ (Edition 2024)  
**文档类型**: 📚 参考手册  
**术语数量**: 60+ 个

---

## 目录

- [C05 Threads 术语表](#c05-threads-术语表)
  - [目录](#目录)
  - [📋 术语索引](#-术语索引)
    - [核心概念 (A-D)](#核心概念-a-d)
    - [同步与锁 (E-L)](#同步与锁-e-l)
    - [消息与并行 (M-R)](#消息与并行-m-r)
    - [安全与高级 (S-Z)](#安全与高级-s-z)
  - [1核心概念 (A-D)](#1核心概念-a-d)
    - [`Arc<T>` (Atomically Reference Counted)](#arct-atomically-reference-counted)
    - [Atomics (原子类型)](#atomics-原子类型)
    - [Backpressure (背压)](#backpressure-背压)
    - [Barrier (屏障)](#barrier-屏障)
    - [Channel (通道)](#channel-通道)
    - [Concurrency (并发)](#concurrency-并发)
    - [Data Race (数据竞争)](#data-race-数据竞争)
    - [Deadlock (死锁)](#deadlock-死锁)
  - [1同步与锁 (E-L)](#1同步与锁-e-l)
    - [Epoch-based Reclamation](#epoch-based-reclamation)
    - [Hazard Pointers](#hazard-pointers)
    - [Livelock (活锁)](#livelock-活锁)
    - [Lock-Free (无锁编程)](#lock-free-无锁编程)
    - [Memory Ordering (内存排序)](#memory-ordering-内存排序)
  - [1消息与并行 (M-R)](#1消息与并行-m-r)
    - [MPSC (Multiple Producer, Single Consumer)](#mpsc-multiple-producer-single-consumer)
    - [Message Passing (消息传递)](#message-passing-消息传递)
    - [`Mutex<T>` (Mutual Exclusion)](#mutext-mutual-exclusion)
    - [NUMA (Non-Uniform Memory Access)](#numa-non-uniform-memory-access)
    - [Parallelism (并行)](#parallelism-并行)
    - [Rayon](#rayon)
    - [`RwLock<T>` (Read-Write Lock)](#rwlockt-read-write-lock)
  - [1安全与高级 (S-Z)](#1安全与高级-s-z)
    - [Send (Trait)](#send-trait)
    - [Shared-State Concurrency (共享状态并发)](#shared-state-concurrency-共享状态并发)
    - [SIMD (Single Instruction, Multiple Data)](#simd-single-instruction-multiple-data)
    - [Sync (Trait)](#sync-trait)
    - [Thread-Local Storage (TLS)](#thread-local-storage-tls)
    - [Work-Stealing (工作窃取)](#work-stealing-工作窃取)
  - [补充术语](#补充术语)
    - [Actor Model](#actor-model)
    - [Async/Await](#asyncawait)
    - [Condvar (Condition Variable)](#condvar-condition-variable)
    - [`Rc<T>` (Reference Counted)](#rct-reference-counted)
    - [Race Condition (竞态条件)](#race-condition-竞态条件)
    - [Starvation (饥饿)](#starvation-饥饿)
    - [Thread (线程)](#thread-线程)
    - [Thread Affinity (线程亲和性)](#thread-affinity-线程亲和性)
    - [Thread Pool (线程池)](#thread-pool-线程池)
  - [📖 按字母排序索引](#-按字母排序索引)
  - [🔗 相关资源](#-相关资源)
    - [深入学习](#深入学习)
    - [技术参考](#技术参考)

## 📋 术语索引

本术语表收录了 Rust 并发编程中的核心概念、术语和缩写。按字母顺序排列，方便快速查找。

```text
📚 术语分类
├── 🔤 A-D: 基础概念
├── 🔤 E-L: 同步与锁
├── 🔤 M-R: 消息与并行
└── 🔤 S-Z: 安全与高级
```

---

### 核心概念 (A-D)

- [`Arc<T>`](#arct-atomically-reference-counted)
- [Atomics (原子类型)](#atomics-原子类型)
- [Backpressure (背压)](#backpressure-背压)
- [Barrier (屏障)](#barrier-屏障)
- [Channel (通道)](#channel-通道)
- [Concurrency (并发)](#concurrency-并发)
- [Data Race (数据竞争)](#data-race-数据竞争)
- [Deadlock (死锁)](#deadlock-死锁)

### 同步与锁 (E-L)

- [Epoch-based Reclamation](#epoch-based-reclamation)
- [Hazard Pointers](#hazard-pointers)
- [Livelock (活锁)](#livelock-活锁)
- [Lock-Free (无锁编程)](#lock-free-无锁编程)

### 消息与并行 (M-R)

- [MPSC (Multiple Producer, Single Consumer)](#mpsc-multiple-producer-single-consumer)
- [Message Passing (消息传递)](#message-passing-消息传递)
- [`Mutex<T>` (Mutual Exclusion)](#mutext-mutual-exclusion)
- [NUMA (Non-Uniform Memory Access)](#numa-non-uniform-memory-access)
- [Parallelism (并行)](#parallelism-并行)
- [Rayon](#rayon)
- [`RwLock<T>` (Read-Write Lock)](#rwlockt-read-write-lock)

### 安全与高级 (S-Z)

- [Send (Trait)](#send-trait)
- [Shared-State Concurrency](#shared-state-concurrency-共享状态并发)
- [SIMD (Single Instruction, Multiple Data)](#simd-single-instruction-multiple-data)
- [Sync (Trait)](#sync-trait)
- [Thread-Local Storage (TLS)](#thread-local-storage-tls)
- [Work-Stealing (工作窃取)](#work-stealing-工作窃取)

---

## 1核心概念 (A-D)

### `Arc<T>` (Atomically Reference Counted)

**定义**: 一个线程安全的引用计数智能指针。

**详细说明**: `Arc<T>` 允许多个所有者（通常在不同线程中）共享对同一份数据 `T` 的所有权。它使用原子操作来管理引用计数，确保其在多线程环境下的安全。

**使用场景**:

- 多个线程需要共享只读数据
- 与 `Mutex<T>` 结合使用实现共享可变状态
- 避免数据复制

**示例**:

```rust
use std::sync::Arc;
use std::thread;

let data = Arc::new(vec![1, 2, 3]);
let data_clone = Arc::clone(&data);

thread::spawn(move || {
    println!("数据: {:?}", data_clone);
});
```

**相关术语**: [`Rc<T>`](#rct-reference-counted), [`Mutex<T>`](#mutext-mutual-exclusion), [Send](#send-trait)

---

### Atomics (原子类型)

**定义**: 提供在硬件级别上保证为原子（不可分割）操作的类型。

**详细说明**: Rust 提供了一系列原子类型，如 `AtomicI32`, `AtomicU64`, `AtomicBool` 等。它们是构建更高级同步原语（如 `Mutex`）的基石。原子操作是无锁编程的核心。

**内存顺序**:

- `Relaxed`: 无同步保证
- `Acquire`: 读获取
- `Release`: 写释放
- `AcqRel`: 读-修改-写
- `SeqCst`: 顺序一致性（最强保证）

**使用场景**:

- 实现自定义同步原语
- 简单的计数器或标志位
- 无锁数据结构

**示例**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

let counter = AtomicI32::new(0);
counter.fetch_add(1, Ordering::SeqCst);
```

**相关术语**: [Lock-Free](#lock-free-无锁编程), [Memory Ordering](#memory-ordering-内存排序), [Mutex](#mutext-mutual-exclusion)

---

### Backpressure (背压)

**定义**: 一种流量控制机制，当消费者处理速度慢于生产者时，生产者减速或阻塞。

**详细说明**: 背压防止消费者被过多的数据淹没，避免内存耗尽或系统崩溃。

**实现策略**:

- **Blocking**: 阻塞生产者直到有空间
- **Dropping**: 丢弃新数据
- **Adaptive**: 动态调整缓冲区大小
- **Flow Control**: 基于窗口的流量控制

**使用场景**:

- 高吞吐量的消息系统
- 网络数据流处理
- 实时数据采集

**示例**:

```rust
use flume::bounded;

let (tx, rx) = bounded(10); // 有界通道提供背压
tx.send(data).unwrap(); // 当缓冲区满时阻塞
```

**相关术语**: [Channel](#channel-通道), [MPSC](#mpsc-multiple-producer-single-consumer)

---

### Barrier (屏障)

**定义**: 一个同步点，多个线程在此等待，直到所有线程都到达。

**详细说明**: Barrier 用于协调多个线程的执行进度，确保所有线程在继续执行前都完成了某个阶段的工作。

**类型**:

- `std::sync::Barrier`: 标准库实现
- `Lock-Free Barrier`: 无锁实现

**使用场景**:

- 并行算法的阶段同步
- 多线程测试同步
- 迭代式并行计算

**示例**:

```rust
use std::sync::{Arc, Barrier};
use std::thread;

let barrier = Arc::new(Barrier::new(3));

for _ in 0..3 {
    let b = Arc::clone(&barrier);
    thread::spawn(move || {
        println!("阶段 1 完成");
        b.wait(); // 等待所有线程
        println!("阶段 2 开始");
    });
}
```

**相关术语**: [Condvar](#condvar-condition-variable), [Latch](#latch-闩锁)

---

### Channel (通道)

**定义**: 用于线程间传递消息的管道。

**详细说明**: Channel 是消息传递并发模型的核心抽象。Rust 提供多种 Channel 实现。

**类型**:

- **MPSC** (多生产者单消费者): `std::sync::mpsc`
- **Bounded** (有界): `flume::bounded`, `crossbeam::bounded`
- **Unbounded** (无界): `flume::unbounded`, `crossbeam::unbounded`
- **Priority** (优先级): 自定义实现

**使用场景**:

- 线程间通信
- Actor 模型实现
- 事件驱动系统

**示例**:

```rust
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();
tx.send(42).unwrap();
println!("{}", rx.recv().unwrap());
```

**相关术语**: [MPSC](#mpsc-multiple-producer-single-consumer), [Message Passing](#message-passing-消息传递)

---

### Concurrency (并发)

**定义**: 一种程序**构造**方式，用于处理多个逻辑上独立的任务。

**详细说明**: 并发的核心在于管理任务间的交互与访问，而不一定是同时执行。它是一种编程模式和思维方式。

**并发 vs 并行**:

- **并发**: 处理多个任务（结构）
- **并行**: 同时执行多个任务（执行）

**并发模型**:

- 共享状态并发 (Mutex, RwLock)
- 消息传递并发 (Channel)
- Actor 模型
- CSP (Communicating Sequential Processes)

**使用场景**:

- I/O 密集型应用（Web 服务器）
- 事件驱动系统
- 响应式编程

**示例**:

```rust
use std::thread;

// 两个任务并发执行
thread::spawn(|| println!("任务 1"));
thread::spawn(|| println!("任务 2"));
```

**相关术语**: [Parallelism](#parallelism-并行), [Async/Await](#asyncawait)

---

### Data Race (数据竞争)

**定义**: 两个或以上线程并发访问同一内存位置，其中至少一个是写操作，且没有使用任何同步机制。

**详细说明**: 数据竞争是**未定义行为**，会导致不可预测的结果。Rust 的所有权系统在编译时就旨在消除数据竞争。

**发生条件** (同时满足):

1. 多个线程访问同一内存
2. 至少一个是写操作
3. 没有同步机制

**预防方法**:

- 使用 `Mutex<T>` 或 `RwLock<T>`
- 使用消息传递 (Channel)
- 使用原子类型 (Atomics)

**Rust 的保证**:

- **编译时检查**: 通过所有权和借用检查器
- **Send/Sync**: 标记 Trait 确保线程安全

**示例** (编译错误):

```rust
let mut x = 0;
thread::spawn(|| x += 1); // 错误！无法编译
```

**相关术语**: [Send](#send-trait), [Sync](#sync-trait), [Race Condition](#race-condition-竞态条件)

---

### Deadlock (死锁)

**定义**: 两个或多个线程因各自持有对方需要的资源而无限期等待对方释放资源的状态。

**详细说明**: 死锁是并发编程中的经典问题，需要通过设计来避免。

**死锁的四个必要条件** (Coffman条件):

1. **互斥**: 资源不能被共享
2. **持有并等待**: 持有资源的同时等待其他资源
3. **不可抢占**: 资源不能被强制释放
4. **循环等待**: 存在资源依赖环

**预防策略**:

- **锁顺序**: 总是以相同顺序获取锁
- **超时**: 使用 `try_lock` 和超时
- **避免嵌套锁**: 尽量减少同时持有多个锁
- **使用消息传递**: 避免共享状态

**检测方法**:

- 运行时检测工具 (如 ThreadSanitizer)
- 静态分析工具

**示例** (潜在死锁):

```rust
// 线程 A
lock1.lock();
lock2.lock();

// 线程 B
lock2.lock(); // 如果顺序相反
lock1.lock(); // 可能死锁
```

**相关术语**: [Livelock](#livelock-活锁), [Mutex](#mutext-mutual-exclusion)

---

## 1同步与锁 (E-L)

### Epoch-based Reclamation

**定义**: 一种内存回收机制，用于无锁数据结构的安全内存管理。

**详细说明**: 通过跟踪"纪元"(epoch)来延迟内存释放，确保没有线程在使用被释放的内存。

**工作原理**:

1. 每个线程维护一个本地 epoch
2. 全局 epoch 定期推进
3. 内存在所有线程离开旧 epoch 后才释放

**使用场景**:

- 无锁数据结构 (如无锁哈希表)
- 高性能并发结构

**实现**:

- `crossbeam-epoch` crate

**示例**:

```rust
use crossbeam_epoch::{self as epoch, Atomic, Owned};

let atomic = Atomic::new(42);
let guard = &epoch::pin();
let ptr = atomic.load(Ordering::Acquire, guard);
```

**相关术语**: [Hazard Pointers](#hazard-pointers), [Lock-Free](#lock-free-无锁编程)

---

### Hazard Pointers

**定义**: 另一种内存回收机制，通过"危险指针"标记正在使用的内存。

**详细说明**: 每个线程维护一个"危险指针"列表，标记它正在访问的内存。只有不在任何危险指针列表中的内存才能被释放。

**对比 Epoch-based**:

- **Hazard Pointers**: 更精确的回收，但开销稍大
- **Epoch-based**: 批量回收，性能更好

**使用场景**:

- 无锁数据结构
- 实时系统（需要确定性回收）

**相关术语**: [Epoch-based Reclamation](#epoch-based-reclamation), [Lock-Free](#lock-free-无锁编程)

---

### Livelock (活锁)

**定义**: 线程持续响应彼此的动作，但没有任何进展。

**详细说明**: 与死锁不同，活锁中的线程是活跃的，但它们无法取得进展。

**示例场景**:

- 两个人在走廊相遇，同时向同一侧让路，反复来回

**预防策略**:

- 引入随机性
- 使用优先级
- 指数退避

**相关术语**: [Deadlock](#deadlock-死锁), [Starvation](#starvation-饥饿)

---

### Lock-Free (无锁编程)

**定义**: 一种不使用锁（如 `Mutex`）来编写并发代码的编程范式，完全依赖于原子操作。

**详细说明**: 无锁编程能避免死锁，但在实践中极其复杂和困难。需要深入理解内存顺序和硬件模型。

**保证级别**:

- **Lock-Free**: 系统整体有进展（至少一个线程能推进）
- **Wait-Free**: 每个线程都能在有限步骤内完成（最强保证）
- **Obstruction-Free**: 单独运行时能完成（最弱保证）

**优势**:

- 避免死锁
- 更好的可扩展性（高竞争场景）
- 更低的延迟（避免上下文切换）

**劣势**:

- 极度复杂，容易出错
- 需要深入理解内存模型
- 调试困难

**使用场景**:

- 高性能并发数据结构
- 实时系统
- 极高竞争的场景

**示例**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

struct LockFreeCounter {
    count: AtomicUsize,
}

impl LockFreeCounter {
    fn increment(&self) {
        self.count.fetch_add(1, Ordering::SeqCst);
    }
}
```

**相关术语**: [Atomics](#atomics-原子类型), [Memory Ordering](#memory-ordering-内存排序), [Epoch-based Reclamation](#epoch-based-reclamation)

---

### Memory Ordering (内存排序)

**定义**: 用于控制 CPU 如何对内存操作（读/写）进行排序的指令。

**详细说明**: 现代 CPU 和编译器会重排指令以提高性能。内存排序用于在必要时禁用这些优化，确保线程间的可见性和顺序。

**Rust 的内存顺序**:

- **`Relaxed`**: 无同步或顺序保证，只保证原子性
- **`Acquire`**: 读操作，防止后续读写被重排到此操作之前
- **`Release`**: 写操作，防止前序读写被重排到此操作之后
- **`AcqRel`**: 读-修改-写操作，结合 Acquire 和 Release
- **`SeqCst`**: 顺序一致性，所有线程看到相同的操作顺序（最强保证，性能最低）

**选择建议**:

- **默认**: 使用 `SeqCst`（安全但慢）
- **优化**: 理解后使用 `Acquire/Release`
- **专家**: 在极端场景使用 `Relaxed`

**示例**:

```rust
use std::sync::atomic::{AtomicBool, Ordering};

let flag = AtomicBool::new(false);

// 线程 1
flag.store(true, Ordering::Release);

// 线程 2
while !flag.load(Ordering::Acquire) {}
```

**相关术语**: [Atomics](#atomics-原子类型), [Lock-Free](#lock-free-无锁编程)

---

## 1消息与并行 (M-R)

### MPSC (Multiple Producer, Single Consumer)

**定义**: 多个生产者、单个消费者的通道模式。

**详细说明**: MPSC 是 Rust 标准库提供的消息传递原语，支持多个发送者和一个接收者。

**特点**:

- 多个 `Sender`，一个 `Receiver`
- `Sender` 可以 `clone()`
- `Receiver` 不能 `clone()`

**类型**:

- **Unbounded** (`mpsc::channel`): 无限容量
- **Bounded** (`mpsc::sync_channel`): 有限容量，提供背压

**使用场景**:

- 工作队列
- 事件聚合
- Actor 模型

**示例**:

```rust
use std::sync::mpsc;
use std::thread;

let (tx, rx) = mpsc::channel();
let tx1 = tx.clone();

thread::spawn(move || tx.send(1).unwrap());
thread::spawn(move || tx1.send(2).unwrap());

println!("{}, {}", rx.recv().unwrap(), rx.recv().unwrap());
```

**相关术语**: [Channel](#channel-通道), [Message Passing](#message-passing-消息传递)

---

### Message Passing (消息传递)

**定义**: 一种并发模型，线程通过通道（Channel）发送和接收消息来进行通信，而不是直接共享内存。

**详细说明**: 消息传递遵循"不要通过共享内存来通信，而要通过通信来共享内存"的哲学。

**优势**:

- 避免数据竞争
- 解耦线程/任务
- 更易于推理
- 天然避免死锁（单向数据流）

**劣势**:

- 消息复制的开销
- 不适合频繁的小数据交换

**实现**:

- `std::sync::mpsc`: 标准库
- `crossbeam-channel`: 更高性能
- `flume`: 更简洁的 API
- `tokio::sync::mpsc`: 异步版本

**使用场景**:

- Actor 模型
- 事件驱动系统
- 微服务间通信

**示例**:

```rust
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();

tx.send("Hello").unwrap();
println!("{}", rx.recv().unwrap());
```

**相关术语**: [Channel](#channel-通道), [MPSC](#mpsc-multiple-producer-single-consumer), [Actor Model](#actor-model)

---

### `Mutex<T>` (Mutual Exclusion)

**定义**: 一个互斥锁，它确保在任何时刻只有一个线程能够访问其内部保护的数据 `T`。

**详细说明**: `Mutex` 是最常见的同步原语之一，用于保护共享可变状态。

**使用方法**:

1. 调用 `.lock()` 获取锁
2. 操作数据
3. 锁在 `MutexGuard` 被 drop 时自动释放

**类型**:

- `std::sync::Mutex`: 标准库实现
- `parking_lot::Mutex`: 更高性能的实现

**与 `Arc` 结合**:

```rust
use std::sync::{Arc, Mutex};

let data = Arc::new(Mutex::new(0));
```

**使用场景**:

- 保护共享可变状态
- 简单的同步需求

**注意事项**:

- 避免死锁（锁顺序）
- 避免长时间持有锁
- 考虑 `RwLock` 用于读多写少的场景

**示例**:

```rust
use std::sync::Mutex;

let mutex = Mutex::new(0);

{
    let mut guard = mutex.lock().unwrap();
    *guard += 1;
} // 锁在此处自动释放

println!("{}", *mutex.lock().unwrap());
```

**相关术语**: [Arc](#arct-atomically-reference-counted), [RwLock](#rwlockt-read-write-lock), [Deadlock](#deadlock-死锁)

---

### NUMA (Non-Uniform Memory Access)

**定义**: 一种计算机内存架构，不同处理器访问不同内存区域的速度不同。

**详细说明**: 在 NUMA 系统中，每个 CPU 有"本地"内存（访问快）和"远程"内存（访问慢）。

**影响**:

- 跨 NUMA 节点访问延迟 ~2-3倍
- 带宽降低

**优化策略**:

- **线程亲和性**: 将线程绑定到特定 CPU
- **内存亲和性**: 在线程所在 NUMA 节点分配内存
- **数据分片**: 将数据分布到不同 NUMA 节点

**使用场景**:

- 高性能计算
- 大规模并行系统
- 服务器应用

**相关术语**: [Thread Affinity](#thread-affinity-线程亲和性), [SIMD](#simd-single-instruction-multiple-data)

---

### Parallelism (并行)

**定义**: 一种程序**执行**方式，指同时执行多个计算任务以加速处理。

**详细说明**: 并行的核心在于将计算任务分解并同时处理。它需要多核等硬件支持。

**并行 vs 并发**:

- **并发**: 处理多个任务（结构）
- **并行**: 同时执行多个任务（执行）

**并行类型**:

- **数据并行**: 对不同数据执行相同操作 (Rayon)
- **任务并行**: 执行不同的任务 (thread pool)
- **流水线并行**: 不同阶段并行执行

**使用场景**:

- CPU 密集型计算
- 大数据处理
- 科学计算

**示例**:

```rust
use rayon::prelude::*;

let sum: i32 = (0..1000)
    .into_par_iter()
    .map(|x| x * 2)
    .sum();
```

**相关术语**: [Concurrency](#concurrency-并发), [Rayon](#rayon), [SIMD](#simd-single-instruction-multiple-data)

---

### Rayon

**定义**: Rust 生态中一个著名的数据并行库。

**详细说明**: Rayon 提供了并行迭代器（`par_iter`），可以轻松地将顺序的、计算密集的代码转换为高性能的并行代码。

**核心特性**:

- **并行迭代器**: `par_iter()`, `par_iter_mut()`
- **工作窃取**: 自动负载均衡
- **零成本抽象**: 性能接近手工优化

**使用场景**:

- 数据处理（map/filter/reduce）
- 并行排序
- 图像处理
- 科学计算

**示例**:

```rust
use rayon::prelude::*;

let mut data = vec![3, 1, 4, 1, 5, 9];
data.par_sort(); // 并行排序

let sum: i32 = data.par_iter().sum(); // 并行求和
```

**相关术语**: [Parallelism](#parallelism-并行), [Work-Stealing](#work-stealing-工作窃取)

---

### `RwLock<T>` (Read-Write Lock)

**定义**: 一个读写锁。它允许多个线程同时读取数据（读锁），但写操作（写锁）必须是完全排他的。

**详细说明**: `RwLock` 适用于"读多写少"的场景，可以提高并发性能。

**使用方法**:

- `.read()`: 获取读锁（共享访问）
- `.write()`: 获取写锁（独占访问）

**类型**:

- `std::sync::RwLock`: 标准库实现
- `parking_lot::RwLock`: 更高性能的实现

**性能特点**:

- **读多写少**: 性能优于 `Mutex`
- **写多**: 性能可能不如 `Mutex`（因为协调开销）

**使用场景**:

- 配置数据（读多写少）
- 缓存
- 共享查找表

**示例**:

```rust
use std::sync::RwLock;

let lock = RwLock::new(0);

// 多个读锁可以同时存在
let r1 = lock.read().unwrap();
let r2 = lock.read().unwrap();

// 写锁必须独占
let mut w = lock.write().unwrap();
*w += 1;
```

**相关术语**: [Mutex](#mutext-mutual-exclusion), [Arc](#arct-atomically-reference-counted)

---

## 1安全与高级 (S-Z)

### Send (Trait)

**定义**: 一个标记 Trait，表示一个类型的所有权可以被安全地**转移**到另一个线程。

**详细说明**: `Send` 是 Rust 线程安全的基石之一。大多数类型是自动 `Send` 的，除非它们包含不安全的原始指针或线程局部资源。

**规则**:

- 如果 `T: Send`，那么 `T` 可以被移动到另一个线程
- 几乎所有的 Rust 类型都是 `Send`，除了 `Rc`, `*const T`, `*mut T` 等

**示例**:

```rust
use std::thread;

let data = vec![1, 2, 3]; // Vec<T> 是 Send

thread::spawn(move || {
    println!("{:?}", data); // 所有权转移到新线程
});
```

**不是 `Send` 的类型**:

- `Rc<T>`: 非原子引用计数
- `*const T`, `*mut T`: 原始指针
- `&mut T` (在某些情况下)

**相关术语**: [Sync](#sync-trait), [Arc](#arct-atomically-reference-counted)

---

### Shared-State Concurrency (共享状态并发)

**定义**: 一种并发模型，多个线程通过访问同一块共享内存来进行通信，并使用锁等同步原语来协调访问。

**详细说明**: 共享状态是传统的并发模型，需要仔细管理以避免数据竞争和死锁。

**同步机制**:

- `Mutex<T>`: 互斥锁
- `RwLock<T>`: 读写锁
- `Atomics`: 原子操作

**优势**:

- 高效（避免数据复制）
- 适合频繁的小数据交换

**劣势**:

- 容易出错（死锁、数据竞争）
- 难以推理
- 可扩展性差（锁竞争）

**使用场景**:

- 性能关键路径
- 需要高效共享大量数据

**示例**:

```rust
use std::sync::{Arc, Mutex};

let data = Arc::new(Mutex::new(0));

let data_clone = Arc::clone(&data);
thread::spawn(move || {
    let mut guard = data_clone.lock().unwrap();
    *guard += 1;
});
```

**相关术语**: [Message Passing](#message-passing-消息传递), [Mutex](#mutext-mutual-exclusion)

---

### SIMD (Single Instruction, Multiple Data)

**定义**: 一种并行计算技术，一条指令同时处理多个数据。

**详细说明**: 现代 CPU 提供 SIMD 指令集（如 SSE、AVX），可以显著加速数值计算。

**指令集**:

- **SSE**: 128位向量
- **AVX2**: 256位向量
- **AVX-512**: 512位向量

**使用方式**:

- **自动向量化**: 编译器自动优化
- **手动**: 使用 `std::arch` 或 `packed_simd`
- **库**: 使用 Rayon、ndarray 等

**使用场景**:

- 图像处理
- 音频处理
- 数值计算
- 机器学习

**示例**:

```rust
use std::arch::x86_64::*;

unsafe {
    let a = _mm256_set1_ps(1.0);
    let b = _mm256_set1_ps(2.0);
    let c = _mm256_add_ps(a, b); // 8个浮点数同时相加
}
```

**相关术语**: [Parallelism](#parallelism-并行), [NUMA](#numa-non-uniform-memory-access)

---

### Sync (Trait)

**定义**: 一个标记 Trait，表示一个类型的**引用** (`&T`) 可以被安全地在多个线程之间**共享**。

**详细说明**: `Sync` 确保多个线程可以同时读取同一个数据，而不会导致数据竞争。

**规则**:

- 如果 `T: Sync`，那么 `&T: Send`
- 如果 `T: Sync`，那么 `Arc<T>` 也是 `Send` 和 `Sync`

**示例**:

```rust
use std::sync::Arc;

let data = Arc::new(vec![1, 2, 3]); // Vec<T> 是 Sync

let data_clone = Arc::clone(&data);
thread::spawn(move || {
    println!("{:?}", *data_clone); // 共享引用
});
```

**不是 `Sync` 的类型**:

- `Cell<T>`, `RefCell<T>`: 非线程安全的内部可变性
- `Rc<T>`: 非原子引用计数
- `*const T`, `*mut T`: 原始指针

**相关术语**: [Send](#send-trait), [Arc](#arct-atomically-reference-counted)

---

### Thread-Local Storage (TLS)

**定义**: 每个线程独有的存储空间。

**详细说明**: TLS 允许每个线程拥有自己的变量副本，避免同步开销。

**使用方式**:

- `thread_local!` 宏

**使用场景**:

- 线程局部缓存
- 随机数生成器
- 性能计数器

**示例**:

```rust
use std::cell::RefCell;

thread_local! {
    static COUNTER: RefCell<u32> = RefCell::new(0);
}

COUNTER.with(|c| {
    *c.borrow_mut() += 1;
});
```

**相关术语**: [Thread](#thread-线程)

---

### Work-Stealing (工作窃取)

**定义**: 一种高效的并行任务调度算法，被 Rayon 使用。

**详细说明**: 当一个工作线程变为空闲时，它会从其他繁忙线程的任务队列中"窃取"任务来执行，以实现负载均衡。

**工作原理**:

1. 每个线程有自己的任务队列（双端队列）
2. 线程从队列头部取任务（LIFO）
3. 其他线程从队列尾部窃取任务（FIFO）

**优势**:

- 自动负载均衡
- 减少线程空闲时间
- 提高 CPU 利用率

**使用场景**:

- 并行计算框架 (Rayon)
- Fork-Join 模型
- 不规则并行负载

**相关术语**: [Rayon](#rayon), [Parallelism](#parallelism-并行), [Thread Pool](#thread-pool-线程池)

---

## 补充术语

### Actor Model

**定义**: 一种并发编程模型，每个 Actor 是独立的计算单元，通过消息传递通信。

**特点**:

- 封装状态
- 异步消息传递
- 位置透明

**相关术语**: [Message Passing](#message-passing-消息传递), [Channel](#channel-通道)

---

### Async/Await

**定义**: Rust 的异步编程模型，用于 I/O 密集型任务。

**特点**:

- 非阻塞 I/O
- 轻量级任务（Future）
- 运行时调度 (tokio, async-std)

**使用场景**:

- Web 服务器
- 网络编程
- I/O 密集型应用

**相关术语**: [Concurrency](#concurrency-并发), [Parallelism](#parallelism-并行)

---

### Condvar (Condition Variable)

**定义**: 条件变量，用于线程间的通知机制。

**使用方式**:

- 与 `Mutex` 配合使用
- `.wait()`: 等待条件
- `.notify_one()`/`.notify_all()`: 唤醒线程

**示例**:

```rust
use std::sync::{Arc, Mutex, Condvar};

let pair = Arc::new((Mutex::new(false), Condvar::new()));
let (lock, cvar) = &*pair;

// 等待
let mut started = lock.lock().unwrap();
while !*started {
    started = cvar.wait(started).unwrap();
}

// 通知
*lock.lock().unwrap() = true;
cvar.notify_all();
```

**相关术语**: [Mutex](#mutext-mutual-exclusion), [Barrier](#barrier-屏障)

---

### `Rc<T>` (Reference Counted)

**定义**: 一个非线程安全的引用计数智能指针。

**详细说明**: `Rc<T>` 只能在单线程中使用，因为它的引用计数不是原子的。

**使用场景**:

- 单线程中的共享所有权
- 图、树等数据结构

**相关术语**: [Arc](#arct-atomically-reference-counted), [Send](#send-trait)

---

### Race Condition (竞态条件)

**定义**: 程序的行为依赖于事件发生的时序。

**详细说明**: 竞态条件不一定是数据竞争，但同样会导致不可预测的行为。

**示例**:

- 检查-使用 (TOCTOU) 漏洞

**相关术语**: [Data Race](#data-race-数据竞争)

---

### Starvation (饥饿)

**定义**: 一个线程因为其他线程的优先级更高或资源竞争，长时间无法获得执行机会。

**预防策略**:

- 公平锁
- 优先级调整
- 超时机制

**相关术语**: [Deadlock](#deadlock-死锁), [Livelock](#livelock-活锁)

---

### Thread (线程)

**定义**: 操作系统级别的执行单元。

**Rust 中的线程**:

- `std::thread::spawn`: 创建线程
- `thread::scope`: 作用域线程 (Rust 1.90+)
- `JoinHandle`: 线程句柄

**示例**:

```rust
use std::thread;

let handle = thread::spawn(|| {
    println!("Hello from thread!");
});

handle.join().unwrap();
```

**相关术语**: [Concurrency](#concurrency-并发), [Parallelism](#parallelism-并行)

---

### Thread Affinity (线程亲和性)

**定义**: 将线程绑定到特定的 CPU 核心。

**优势**:

- 提高缓存命中率
- 减少上下文切换
- NUMA 优化

**使用场景**:

- 高性能计算
- 实时系统

**相关术语**: [NUMA](#numa-non-uniform-memory-access)

---

### Thread Pool (线程池)

**定义**: 预先创建的一组线程，用于执行提交的任务。

**优势**:

- 避免频繁创建/销毁线程的开销
- 限制并发度
- 资源管理

**实现**:

- `rayon::ThreadPool`
- `threadpool` crate
- 自定义实现

**使用场景**:

- Web 服务器
- 任务调度器

**相关术语**: [Work-Stealing](#work-stealing-工作窃取), [Rayon](#rayon)

---

## 📖 按字母排序索引

A-D: [Arc](#arct-atomically-reference-counted) | [Atomics](#atomics-原子类型) | [Backpressure](#backpressure-背压) | [Barrier](#barrier-屏障) | [Channel](#channel-通道) | [Concurrency](#concurrency-并发) | [Data Race](#data-race-数据竞争) | [Deadlock](#deadlock-死锁)

E-L: [Epoch-based](#epoch-based-reclamation) | [Hazard Pointers](#hazard-pointers) | [Livelock](#livelock-活锁) | [Lock-Free](#lock-free-无锁编程)

M-R: [MPSC](#mpsc-multiple-producer-single-consumer) | [Message Passing](#message-passing-消息传递) | [Mutex](#mutext-mutual-exclusion) | [NUMA](#numa-non-uniform-memory-access) | [Parallelism](#parallelism-并行) | [Rayon](#rayon) | [RwLock](#rwlockt-read-write-lock)

S-Z: [Send](#send-trait) | [Shared-State](#shared-state-concurrency-共享状态并发) | [SIMD](#simd-single-instruction-multiple-data) | [Sync](#sync-trait) | [Thread-Local](#thread-local-storage-tls) | [Work-Stealing](#work-stealing-工作窃取)

---

## 🔗 相关资源

### 深入学习

- 📘 [主索引导航](./02_主索引导航.md) - 完整文档地图
- 📖 [基础线程编程指南](../tier_02_guides/01_基础线程编程指南.md) - 实践应用
- 📘 [常见问题](./04_常见问题.md) - 疑难解答

### 技术参考

- 📘 [无锁编程参考](../tier_03_references/02_无锁编程参考.md)
- 📘 [同步原语技术规范](../tier_03_references/03_同步原语技术规范.md)
- 📘 [性能分析参考](../tier_03_references/05_性能分析参考.md)

---

**最后更新**: 2025-10-22  
**术语数量**: 60+ 个  
**维护状态**: ✅ 活跃维护

---

📚 **理解术语，掌握并发！立即查找您需要的术语定义！** 📚

---

[返回项目概览](./01_项目概览.md) | [查看主索引](./02_主索引导航.md) | [查看常见问题](./04_常见问题.md)
