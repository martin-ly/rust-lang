# C05 Tier 2 å®è·µæŒ‡å— 04ï¼šå¹¶è¡Œç¼–ç¨‹æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 2 å®è·µæŒ‡å— 04ï¼šå¹¶è¡Œç¼–ç¨‹æŒ‡å—](#c05-tier-2-å®è·µæŒ‡å—-04å¹¶è¡Œç¼–ç¨‹æŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯æ•°æ®å¹¶è¡Œ](#11-ä»€ä¹ˆæ˜¯æ•°æ®å¹¶è¡Œ)
    - [1.2 Rayon æ ¸å¿ƒç‰¹æ€§](#12-rayon-æ ¸å¿ƒç‰¹æ€§)
    - [1.3 å®‰è£… Rayon](#13-å®‰è£…-rayon)
  - [2. Rayon å¹¶è¡Œè¿­ä»£å™¨](#2-rayon-å¹¶è¡Œè¿­ä»£å™¨)
    - [2.1 åŸºç¡€ç”¨æ³•](#21-åŸºç¡€ç”¨æ³•)
    - [2.2 par_iter() å®¶æ—](#22-par_iter-å®¶æ—)
    - [2.3 å¹¶è¡Œ map/filter/reduce](#23-å¹¶è¡Œ-mapfilterreduce)
    - [2.4 é“¾å¼æ“ä½œ](#24-é“¾å¼æ“ä½œ)
  - [3. å¹¶è¡Œé›†åˆæ“ä½œ](#3-å¹¶è¡Œé›†åˆæ“ä½œ)
    - [3.1 å¹¶è¡Œæ’åº](#31-å¹¶è¡Œæ’åº)
    - [3.2 å¹¶è¡Œæœç´¢](#32-å¹¶è¡Œæœç´¢)
    - [3.3 å¹¶è¡Œåˆ†åŒº](#33-å¹¶è¡Œåˆ†åŒº)
  - [4. è‡ªå®šä¹‰å¹¶è¡Œä»»åŠ¡](#4-è‡ªå®šä¹‰å¹¶è¡Œä»»åŠ¡)
    - [4.1 ä½¿ç”¨ join() åˆ†å‰-åˆå¹¶](#41-ä½¿ç”¨-join-åˆ†å‰-åˆå¹¶)
    - [4.2 ä½¿ç”¨ scope() ç”Ÿæˆä»»åŠ¡](#42-ä½¿ç”¨-scope-ç”Ÿæˆä»»åŠ¡)
    - [4.3 ä½¿ç”¨ ThreadPool è‡ªå®šä¹‰çº¿ç¨‹æ± ](#43-ä½¿ç”¨-threadpool-è‡ªå®šä¹‰çº¿ç¨‹æ± )
  - [5. åˆ†æ²»ç®—æ³•](#5-åˆ†æ²»ç®—æ³•)
    - [5.1 å¿«é€Ÿæ’åº](#51-å¿«é€Ÿæ’åº)
    - [5.2 å½’å¹¶æ’åº](#52-å½’å¹¶æ’åº)
  - [6. æ•°æ®å¹¶è¡Œæ¨¡å¼](#6-æ•°æ®å¹¶è¡Œæ¨¡å¼)
    - [6.1 Map-Reduce](#61-map-reduce)
    - [6.2 å¹¶è¡Œèšåˆ](#62-å¹¶è¡Œèšåˆ)
    - [6.3 å¹¶è¡Œåˆ†ç»„](#63-å¹¶è¡Œåˆ†ç»„)
  - [7. æ€§èƒ½è°ƒä¼˜](#7-æ€§èƒ½è°ƒä¼˜)
    - [7.1 é€‰æ‹©åˆé€‚çš„ç²’åº¦](#71-é€‰æ‹©åˆé€‚çš„ç²’åº¦)
    - [7.2 é¿å…è¿‡å°çš„ä»»åŠ¡](#72-é¿å…è¿‡å°çš„ä»»åŠ¡)
    - [7.3 åŸºå‡†æµ‹è¯•](#73-åŸºå‡†æµ‹è¯•)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æµ‹é‡å†ä¼˜åŒ–](#81-æµ‹é‡å†ä¼˜åŒ–)
    - [8.2 é¿å…ä¸å¿…è¦çš„å¹¶è¡Œ](#82-é¿å…ä¸å¿…è¦çš„å¹¶è¡Œ)
    - [8.3 é…ç½®çº¿ç¨‹æ± ](#83-é…ç½®çº¿ç¨‹æ± )
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
    - [9.1 é”™è¯¯çš„å…±äº«çŠ¶æ€](#91-é”™è¯¯çš„å…±äº«çŠ¶æ€)
    - [9.2 éçº¿ç¨‹å®‰å…¨ç±»å‹](#92-éçº¿ç¨‹å®‰å…¨ç±»å‹)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
    - [10.1 å®˜æ–¹æ–‡æ¡£](#101-å®˜æ–¹æ–‡æ¡£)
    - [10.2 æ¨èé˜…è¯»](#102-æ¨èé˜…è¯»)
    - [10.3 å†…éƒ¨æ–‡æ¡£é“¾æ¥](#103-å†…éƒ¨æ–‡æ¡£é“¾æ¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å¹¶è¡Œç¼–ç¨‹ (Parallel Programming)**:

- **å®šä¹‰**: ä½¿ç”¨å¤šä¸ªæ‰§è¡Œå•å…ƒåŒæ—¶æ‰§è¡Œä»»åŠ¡ï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸ CPU çš„è®¡ç®—èƒ½åŠ›
- **ç±»å‹**: ç¼–ç¨‹èŒƒå¼
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹ã€é«˜æ€§èƒ½è®¡ç®—
- **ç‰ˆæœ¬**: Rust 1.0+ (Rayon)
- **ç›¸å…³æ¦‚å¿µ**: æ•°æ®å¹¶è¡Œã€ä»»åŠ¡å¹¶è¡Œã€å·¥ä½œçªƒå–ã€è´Ÿè½½å‡è¡¡

**æ•°æ®å¹¶è¡Œ (Data Parallelism)**:

- **å®šä¹‰**: å°†ç›¸åŒçš„æ“ä½œåº”ç”¨äºä¸åŒçš„æ•°æ®ç‰‡æ®µï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸ CPU
- **ç±»å‹**: å¹¶è¡Œæ¨¡å¼
- **å±æ€§**: æ•°æ®åˆ†ç‰‡ã€å¹¶è¡Œæ‰§è¡Œã€ç»“æœåˆå¹¶
- **å…³ç³»**: ä¸ä»»åŠ¡å¹¶è¡Œã€å¹¶è¡Œç®—æ³•ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å¹¶è¡Œè¿­ä»£å™¨**: `.par_iter()` è‡ªåŠ¨å¹¶è¡ŒåŒ–
- **å·¥ä½œçªƒå–**: è‡ªåŠ¨è´Ÿè½½å‡è¡¡
- **é›¶é…ç½®**: è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çº¿ç¨‹æ•°
- **å®‰å…¨ä¿è¯**: ç¼–è¯‘æœŸé˜²æ­¢æ•°æ®ç«äº‰

**æ€§èƒ½ç‰¹å¾**:

- **åŠ é€Ÿæ¯”**: ç†æƒ³æƒ…å†µä¸‹æ¥è¿‘æ ¸å¿ƒæ•°
- **å¼€é”€**: å¹¶è¡ŒåŒ–æœ‰ä¸€å®šå¼€é”€
- **é€‚ç”¨åœºæ™¯**: CPU å¯†é›†å‹ã€å¤§æ•°æ®å¤„ç†ã€å¹¶è¡Œè®¡ç®—

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- æ•°æ®å¹¶è¡Œ --[is-a]--> å¹¶è¡Œç¼–ç¨‹
- ä»»åŠ¡å¹¶è¡Œ --[is-a]--> å¹¶è¡Œç¼–ç¨‹

**ç»„åˆå…³ç³»**:

- å¹¶è¡Œç¨‹åº --[uses]--> å¹¶è¡Œç¼–ç¨‹æŠ€æœ¯
- Rayon --[provides]--> å¹¶è¡Œè¿­ä»£å™¨

**ä¾èµ–å…³ç³»**:

- å¹¶è¡Œç¼–ç¨‹ --[depends-on]--> å¤šæ ¸ CPU
- Rayon --[depends-on]--> å·¥ä½œçªƒå–è°ƒåº¦å™¨

### æ€ç»´å¯¼å›¾

```text
å¹¶è¡Œç¼–ç¨‹æŒ‡å—
â”‚
â”œâ”€â”€ Rayon å¹¶è¡Œè¿­ä»£å™¨
â”‚   â”œâ”€â”€ par_iter
â”‚   â””â”€â”€ å¹¶è¡Œé›†åˆæ“ä½œ
â”œâ”€â”€ è‡ªå®šä¹‰å¹¶è¡Œä»»åŠ¡
â”‚   â””â”€â”€ scope
â”œâ”€â”€ åˆ†æ²»ç®—æ³•
â”‚   â””â”€â”€ å¹¶è¡Œåˆ†æ²»
â”œâ”€â”€ æ•°æ®å¹¶è¡Œæ¨¡å¼
â”‚   â””â”€â”€ Map-Reduce
â””â”€â”€ æ€§èƒ½è°ƒä¼˜
    â”œâ”€â”€ çº¿ç¨‹æ•°é…ç½®
    â””â”€â”€ ä»»åŠ¡ç²’åº¦
```

---

## 1. æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯æ•°æ®å¹¶è¡Œ

æ•°æ®å¹¶è¡Œï¼ˆData Parallelismï¼‰æ˜¯å°†ç›¸åŒçš„æ“ä½œåº”ç”¨äºä¸åŒçš„æ•°æ®ç‰‡æ®µï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸ CPU çš„å¹¶å‘èƒ½åŠ›ã€‚Rust çš„ **Rayon** åº“æä¾›äº†ç®€å•è€Œå¼ºå¤§çš„æ•°æ®å¹¶è¡ŒæŠ½è±¡ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¸²è¡Œ vs å¹¶è¡Œå¤„ç†                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ä¸²è¡Œå¤„ç†:                                            â”‚
â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”                           â”‚
â”‚  â”‚ A â”‚â†’â”‚ B â”‚â†’â”‚ C â”‚â†’â”‚ D â”‚  (é¡ºåºæ‰§è¡Œ)                â”‚
â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜                           â”‚
â”‚  æ—¶é—´: O(4n)                                         â”‚
â”‚                                                      â”‚
â”‚  å¹¶è¡Œå¤„ç†:                                            â”‚
â”‚  â”Œâ”€â”€â”€â”                                              â”‚
â”‚  â”‚ A â”‚  (åŒæ—¶æ‰§è¡Œ)                                   â”‚
â”‚  â”œâ”€â”€â”€â”¤                                              â”‚
â”‚  â”‚ B â”‚                                              â”‚
â”‚  â”œâ”€â”€â”€â”¤                                              â”‚
â”‚  â”‚ C â”‚                                              â”‚
â”‚  â”œâ”€â”€â”€â”¤                                              â”‚
â”‚  â”‚ D â”‚                                              â”‚
â”‚  â””â”€â”€â”€â”˜                                              â”‚
â”‚  æ—¶é—´: O(n)                                          â”‚
â”‚  åŠ é€Ÿæ¯”: 4x (ç†æƒ³æƒ…å†µ)                                â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Rayon æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§           | è¯´æ˜                         |
| -------------- | ---------------------------- |
| **å¹¶è¡Œè¿­ä»£å™¨** | `.par_iter()` è‡ªåŠ¨å¹¶è¡ŒåŒ–å¾ªç¯ |
| **å·¥ä½œçªƒå–**   | è‡ªåŠ¨è´Ÿè½½å‡è¡¡                 |
| **é›¶é…ç½®**     | è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çº¿ç¨‹æ•°           |
| **å®‰å…¨ä¿è¯**   | ç¼–è¯‘æœŸé˜²æ­¢æ•°æ®ç«äº‰           |
| **ç»†ç²’åº¦æ§åˆ¶** | å¯è‡ªå®šä¹‰çº¿ç¨‹æ± å’Œä»»åŠ¡ç²’åº¦     |

### 1.3 å®‰è£… Rayon

```toml
[dependencies]
rayon = "1.10"
```

---

## 2. Rayon å¹¶è¡Œè¿­ä»£å™¨

### 2.1 åŸºç¡€ç”¨æ³•

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();

    // ä¸²è¡Œæ±‚å’Œ
    let start = std::time::Instant::now();
    let sum_seq: i32 = numbers.iter().sum();
    println!("Sequential sum: {} ({:?})", sum_seq, start.elapsed());

    // å¹¶è¡Œæ±‚å’Œ
    let start = std::time::Instant::now();
    let sum_par: i32 = numbers.par_iter().sum();
    println!("Parallel sum:   {} ({:?})", sum_par, start.elapsed());
}
```

### 2.2 par_iter() å®¶æ—

```rust
use rayon::prelude::*;

fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // par_iter() - ä¸å¯å˜å¹¶è¡Œè¿­ä»£
    numbers.par_iter()
        .for_each(|x| println!("Value: {}", x));

    // par_iter_mut() - å¯å˜å¹¶è¡Œè¿­ä»£
    numbers.par_iter_mut()
        .for_each(|x| *x *= 2);
    println!("After doubling: {:?}", numbers);

    // into_par_iter() - è·å–æ‰€æœ‰æƒ
    let results: Vec<_> = numbers.into_par_iter()
        .map(|x| x + 10)
        .collect();
    println!("Results: {:?}", results);
}
```

### 2.3 å¹¶è¡Œ map/filter/reduce

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=100).collect();

    // å¹¶è¡Œ map
    let squares: Vec<_> = numbers.par_iter()
        .map(|&x| x * x)
        .collect();

    // å¹¶è¡Œ filter
    let evens: Vec<_> = numbers.par_iter()
        .filter(|&&x| x % 2 == 0)
        .copied()
        .collect();

    // å¹¶è¡Œ reduce
    let sum: i32 = numbers.par_iter()
        .cloned()
        .reduce(|| 0, |a, b| a + b);

    println!("Sum of squares of evens: {}",
        evens.par_iter()
            .map(|&x| x * x)
            .sum::<i32>()
    );
}
```

### 2.4 é“¾å¼æ“ä½œ

```rust
use rayon::prelude::*;

fn is_prime(n: u64) -> bool {
    if n < 2 {
        return false;
    }
    (2..=(n as f64).sqrt() as u64 + 1)
        .all(|i| n % i != 0)
}

fn main() {
    let numbers: Vec<u64> = (1..=10000).collect();

    let result: u64 = numbers.par_iter()
        .filter(|&&n| is_prime(n))     // ç­›é€‰è´¨æ•°
        .map(|&n| n * n)                // å¹³æ–¹
        .filter(|&n| n > 100)           // å¤§äº 100
        .sum();                         // æ±‚å’Œ

    println!("Result: {}", result);
}
```

---

## 3. å¹¶è¡Œé›†åˆæ“ä½œ

### 3.1 å¹¶è¡Œæ’åº

```rust
use rayon::prelude::*;

fn main() {
    let mut numbers: Vec<i32> = (1..=1000000).rev().collect();

    // å¹¶è¡Œæ’åº
    let start = std::time::Instant::now();
    numbers.par_sort_unstable();
    println!("Parallel sort: {:?}", start.elapsed());

    // éªŒè¯æ’åº
    assert!(numbers.windows(2).all(|w| w[0] <= w[1]));
}
```

### 3.2 å¹¶è¡Œæœç´¢

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=1000000).collect();
    let target = 789456;

    // å¹¶è¡ŒæŸ¥æ‰¾
    let found = numbers.par_iter()
        .position_any(|&x| x == target);

    match found {
        Some(pos) => println!("Found at position: {}", pos),
        None => println!("Not found"),
    }

    // å¹¶è¡ŒæŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹
    let matches: Vec<_> = numbers.par_iter()
        .enumerate()
        .filter(|(_, &x)| x % 12345 == 0)
        .map(|(i, &x)| (i, x))
        .collect();

    println!("Found {} matches", matches.len());
}
```

### 3.3 å¹¶è¡Œåˆ†åŒº

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=100).collect();

    // æŒ‰æ¡ä»¶åˆ†åŒº
    let (evens, odds): (Vec<_>, Vec<_>) = numbers.par_iter()
        .partition(|&&x| x % 2 == 0);

    println!("Evens: {} numbers", evens.len());
    println!("Odds:  {} numbers", odds.len());
}
```

---

## 4. è‡ªå®šä¹‰å¹¶è¡Œä»»åŠ¡

### 4.1 ä½¿ç”¨ join() åˆ†å‰-åˆå¹¶

```rust
use rayon::join;

fn fibonacci(n: u32) -> u64 {
    if n < 2 {
        return n as u64;
    }

    // å¹¶è¡Œè®¡ç®—ä¸¤ä¸ªå­é—®é¢˜
    let (left, right) = join(
        || fibonacci(n - 1),
        || fibonacci(n - 2),
    );

    left + right
}

fn main() {
    let result = fibonacci(30);
    println!("Fibonacci(30) = {}", result);
}
```

### 4.2 ä½¿ç”¨ scope() ç”Ÿæˆä»»åŠ¡

```rust
use rayon::scope;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let mut results = vec![0; data.len()];

    scope(|s| {
        for (i, &item) in data.iter().enumerate() {
            s.spawn(move |_| {
                results[i] = item * item;
            });
        }
    });

    println!("Results: {:?}", results);
}
```

### 4.3 ä½¿ç”¨ ThreadPool è‡ªå®šä¹‰çº¿ç¨‹æ± 

```rust
use rayon::ThreadPoolBuilder;

fn main() {
    // åˆ›å»º 4 çº¿ç¨‹æ± 
    let pool = ThreadPoolBuilder::new()
        .num_threads(4)
        .build()
        .unwrap();

    pool.install(|| {
        let result: i32 = (1..=1000).into_par_iter().sum();
        println!("Sum: {}", result);
    });
}
```

---

## 5. åˆ†æ²»ç®—æ³•

### 5.1 å¿«é€Ÿæ’åº

```rust
use rayon::join;

fn parallel_quicksort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);

    // å¹¶è¡Œé€’å½’
    join(
        || parallel_quicksort(left),
        || parallel_quicksort(&mut right[1..]),
    );
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot_index = len / 2;
    arr.swap(pivot_index, len - 1);

    let mut i = 0;
    for j in 0..len - 1 {
        if arr[j] <= arr[len - 1] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, len - 1);
    i
}

fn main() {
    let mut numbers: Vec<i32> = (1..=10000).rev().collect();

    let start = std::time::Instant::now();
    parallel_quicksort(&mut numbers);
    println!("Sorted in {:?}", start.elapsed());

    assert!(numbers.windows(2).all(|w| w[0] <= w[1]));
}
```

### 5.2 å½’å¹¶æ’åº

```rust
use rayon::join;

fn parallel_merge_sort<T: Ord + Clone + Send>(arr: &mut [T]) {
    let len = arr.len();
    if len <= 1 {
        return;
    }

    let mid = len / 2;
    let (left, right) = arr.split_at_mut(mid);

    // å¹¶è¡Œæ’åºä¸¤åŠ
    join(
        || parallel_merge_sort(left),
        || parallel_merge_sort(right),
    );

    // åˆå¹¶ç»“æœ
    let mut temp = Vec::with_capacity(len);
    merge(left, right, &mut temp);
    arr.copy_from_slice(&temp);
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T], result: &mut Vec<T>) {
    let (mut i, mut j) = (0, 0);

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }

    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
}

fn main() {
    let mut numbers: Vec<i32> = (1..=10000).rev().collect();
    parallel_merge_sort(&mut numbers);
    println!("Sorted successfully");
}
```

---

## 6. æ•°æ®å¹¶è¡Œæ¨¡å¼

### 6.1 Map-Reduce

```rust
use rayon::prelude::*;

fn word_count(text: &str) -> usize {
    text.split_whitespace().count()
}

fn main() {
    let documents = vec![
        "Hello world from Rust",
        "Parallel programming is fun",
        "Rayon makes it easy",
    ];

    // Map: å¹¶è¡Œè®¡ç®—æ¯ä¸ªæ–‡æ¡£çš„è¯æ•°
    let counts: Vec<_> = documents.par_iter()
        .map(|doc| word_count(doc))
        .collect();

    // Reduce: æ±‡æ€»æ€»è¯æ•°
    let total: usize = counts.iter().sum();

    println!("Total words: {}", total);
}
```

### 6.2 å¹¶è¡Œèšåˆ

```rust
use rayon::prelude::*;
use std::collections::HashMap;

#[derive(Debug)]
struct Stats {
    count: usize,
    sum: i32,
    min: i32,
    max: i32,
}

impl Stats {
    fn new(value: i32) -> Self {
        Stats {
            count: 1,
            sum: value,
            min: value,
            max: value,
        }
    }

    fn merge(self, other: Self) -> Self {
        Stats {
            count: self.count + other.count,
            sum: self.sum + other.sum,
            min: self.min.min(other.min),
            max: self.max.max(other.max),
        }
    }
}

fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();

    let stats = numbers.par_iter()
        .fold(
            || None,
            |acc: Option<Stats>, &x| {
                Some(match acc {
                    None => Stats::new(x),
                    Some(s) => s.merge(Stats::new(x)),
                })
            }
        )
        .reduce(
            || None,
            |a, b| match (a, b) {
                (Some(sa), Some(sb)) => Some(sa.merge(sb)),
                (Some(s), None) | (None, Some(s)) => Some(s),
                _ => None,
            }
        );

    if let Some(s) = stats {
        println!("Stats: {:?}", s);
        println!("Average: {}", s.sum as f64 / s.count as f64);
    }
}
```

### 6.3 å¹¶è¡Œåˆ†ç»„

```rust
use rayon::prelude::*;
use std::collections::HashMap;

fn main() {
    let words = vec![
        "apple", "banana", "apricot", "blueberry",
        "cherry", "avocado", "blackberry", "cranberry",
    ];

    // æŒ‰é¦–å­—æ¯åˆ†ç»„
    let grouped: HashMap<char, Vec<&str>> = words.par_iter()
        .fold(
            HashMap::new,
            |mut acc, &word| {
                acc.entry(word.chars().next().unwrap())
                    .or_insert_with(Vec::new)
                    .push(word);
                acc
            }
        )
        .reduce(
            HashMap::new,
            |mut a, b| {
                for (k, v) in b {
                    a.entry(k).or_insert_with(Vec::new).extend(v);
                }
                a
            }
        );

    for (letter, words) in grouped {
        println!("{}: {:?}", letter, words);
    }
}
```

---

## 7. æ€§èƒ½è°ƒä¼˜

### 7.1 é€‰æ‹©åˆé€‚çš„ç²’åº¦

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=10000000).collect();

    // âŒ å¤ªç»†ï¼šæ¯ä¸ªå…ƒç´ å•ç‹¬å¤„ç†ï¼ˆå¼€é”€å¤§ï¼‰
    // let sum: i32 = numbers.par_iter().sum();

    // âœ… å¥½ï¼šé€‚å½“åˆ†å—
    let chunk_size = 10000;
    let sum: i32 = numbers.par_chunks(chunk_size)
        .map(|chunk| chunk.iter().sum::<i32>())
        .sum();

    println!("Sum: {}", sum);
}
```

### 7.2 é¿å…è¿‡å°çš„ä»»åŠ¡

```rust
use rayon::prelude::*;

fn is_expensive(n: i32) -> bool {
    // æ¨¡æ‹Ÿæ˜‚è´µæ“ä½œ
    (0..1000).map(|x| x * n).sum::<i32>() > 0
}

fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();

    // âŒ ä¸å¥½ï¼šä»»åŠ¡å¤ªå°ï¼Œå¹¶è¡Œå¼€é”€å¤§äºæ”¶ç›Š
    let trivial_count = (0..10).into_par_iter()
        .filter(|&x| x % 2 == 0)
        .count();

    // âœ… å¥½ï¼šä»»åŠ¡è¶³å¤Ÿå¤§
    let expensive_count = numbers.par_iter()
        .filter(|&&x| is_expensive(x))
        .count();

    println!("Expensive count: {}", expensive_count);
}
```

### 7.3 åŸºå‡†æµ‹è¯•

```rust
use rayon::prelude::*;
use std::time::Instant;

fn benchmark<F: Fn()>(name: &str, f: F) {
    let start = Instant::now();
    f();
    println!("{}: {:?}", name, start.elapsed());
}

fn main() {
    let numbers: Vec<i32> = (1..=10000000).collect();

    benchmark("Sequential sum", || {
        let _sum: i32 = numbers.iter().sum();
    });

    benchmark("Parallel sum", || {
        let _sum: i32 = numbers.par_iter().sum();
    });

    benchmark("Sequential map", || {
        let _: Vec<_> = numbers.iter().map(|x| x * x).collect();
    });

    benchmark("Parallel map", || {
        let _: Vec<_> = numbers.par_iter().map(|x| x * x).collect();
    });
}
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 æµ‹é‡å†ä¼˜åŒ–

```rust
use rayon::prelude::*;

fn main() {
    let threshold = 10000;
    let numbers: Vec<i32> = (1..=1000000).collect();

    // æ ¹æ®æ•°æ®è§„æ¨¡é€‰æ‹©ç­–ç•¥
    let sum = if numbers.len() < threshold {
        // å°æ•°æ®é›†ï¼šä¸²è¡Œæ›´å¿«
        numbers.iter().sum()
    } else {
        // å¤§æ•°æ®é›†ï¼šå¹¶è¡Œæ›´å¿«
        numbers.par_iter().sum()
    };

    println!("Sum: {}", sum);
}
```

### 8.2 é¿å…ä¸å¿…è¦çš„å¹¶è¡Œ

```rust
use rayon::prelude::*;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // âŒ ä¸å¿…è¦ï¼šæ•°æ®å¤ªå°‘
    let _: Vec<_> = numbers.par_iter().map(|x| x * 2).collect();

    // âœ… ä¸²è¡Œå³å¯
    let _: Vec<_> = numbers.iter().map(|x| x * 2).collect();
}
```

### 8.3 é…ç½®çº¿ç¨‹æ± 

```rust
use rayon::ThreadPoolBuilder;

fn main() {
    // è‡ªå®šä¹‰çº¿ç¨‹æ± é…ç½®
    let pool = ThreadPoolBuilder::new()
        .num_threads(8)
        .thread_name(|i| format!("worker-{}", i))
        .stack_size(4 * 1024 * 1024)  // 4MB
        .build()
        .unwrap();

    pool.install(|| {
        // åœ¨è‡ªå®šä¹‰çº¿ç¨‹æ± ä¸­æ‰§è¡Œ
        let result: i32 = (1..=1000).into_par_iter().sum();
        println!("Result: {}", result);
    });
}
```

---

## 9. å¸¸è§é™·é˜±

### 9.1 é”™è¯¯çš„å…±äº«çŠ¶æ€

```rust
use rayon::prelude::*;
use std::sync::Mutex;

fn main() {
    let counter = Mutex::new(0);

    // âŒ ä¸å¥½ï¼šMutex æˆä¸ºç“¶é¢ˆ
    (0..1000).into_par_iter().for_each(|_| {
        let mut c = counter.lock().unwrap();
        *c += 1;
    });

    // âœ… å¥½ï¼šä½¿ç”¨ reduce
    let count: i32 = (0..1000).into_par_iter()
        .map(|_| 1)
        .sum();

    println!("Count: {}", count);
}
```

### 9.2 éçº¿ç¨‹å®‰å…¨ç±»å‹

```rust
use rayon::prelude::*;
use std::rc::Rc;

fn main() {
    let data = vec![1, 2, 3];

    // âŒ ç¼–è¯‘é”™è¯¯ï¼šRc ä¸æ˜¯ Send
    // let shared = Rc::new(data);
    // (0..10).into_par_iter().for_each(|_| {
    //     println!("{:?}", shared);
    // });

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ Arc
    let shared = std::sync::Arc::new(data);
    (0..10).into_par_iter().for_each(|_| {
        println!("{:?}", shared);
    });
}
```

---

## 10. å‚è€ƒèµ„æº

### 10.1 å®˜æ–¹æ–‡æ¡£

- [Rayon Documentation](https://docs.rs/rayon)
- [Rayon Book](https://github.com/rayon-rs/rayon/blob/master/FAQ.md)

### 10.2 æ¨èé˜…è¯»

- [Data Parallelism in Rust](https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/)
- [Rayon Performance Tips](https://github.com/rayon-rs/rayon/blob/master/FAQ.md#performance)

### 10.3 å†…éƒ¨æ–‡æ¡£é“¾æ¥

- [â† ä¸Šä¸€ç¯‡ï¼šæ¶ˆæ¯ä¼ é€’æ¨¡å¼](./03_æ¶ˆæ¯ä¼ é€’æ¨¡å¼.md)
- [â†’ ä¸‹ä¸€ç¯‡ï¼šå¼‚æ­¥é›†æˆå®è·µ](./05_å¼‚æ­¥é›†æˆå®è·µ.md)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
