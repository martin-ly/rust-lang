# C05 Tier 2 实践指南 04：并行编程指南

> **文档版本**: v2.0.0 | **Rust 版本**: 1.90+ | **最后更新**: 2025-10-22

## 目录

- [1. 概述](#1-概述)
- [2. Rayon 并行迭代器](#2-rayon-并行迭代器)
- [3. 并行集合操作](#3-并行集合操作)
- [4. 自定义并行任务](#4-自定义并行任务)
- [5. 分治算法](#5-分治算法)
- [6. 数据并行模式](#6-数据并行模式)
- [7. 性能调优](#7-性能调优)
- [8. 最佳实践](#8-最佳实践)
- [9. 常见陷阱](#9-常见陷阱)
- [10. 参考资源](#10-参考资源)

---

## 1. 概述

### 1.1 什么是数据并行

数据并行（Data Parallelism）是将相同的操作应用于不同的数据片段，充分利用多核 CPU 的并发能力。Rust 的 **Rayon** 库提供了简单而强大的数据并行抽象。

```text
┌──────────────────────────────────────────────────────┐
│           串行 vs 并行处理                            │
├──────────────────────────────────────────────────────┤
│                                                      │
│  串行处理:                                            │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐                           │
│  │ A │→│ B │→│ C │→│ D │  (顺序执行)                │
│  └───┘ └───┘ └───┘ └───┘                           │
│  时间: O(4n)                                         │
│                                                      │
│  并行处理:                                            │
│  ┌───┐                                              │
│  │ A │  (同时执行)                                   │
│  ├───┤                                              │
│  │ B │                                              │
│  ├───┤                                              │
│  │ C │                                              │
│  ├───┤                                              │
│  │ D │                                              │
│  └───┘                                              │
│  时间: O(n)                                          │
│  加速比: 4x (理想情况)                                │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### 1.2 Rayon 核心特性

| 特性 | 说明 |
|------|------|
| **并行迭代器** | `.par_iter()` 自动并行化循环 |
| **工作窃取** | 自动负载均衡 |
| **零配置** | 自动选择最优线程数 |
| **安全保证** | 编译期防止数据竞争 |
| **细粒度控制** | 可自定义线程池和任务粒度 |

### 1.3 安装 Rayon

```toml
[dependencies]
rayon = "1.10"
```

---

## 2. Rayon 并行迭代器

### 2.1 基础用法

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();

    // 串行求和
    let start = std::time::Instant::now();
    let sum_seq: i32 = numbers.iter().sum();
    println!("Sequential sum: {} ({:?})", sum_seq, start.elapsed());

    // 并行求和
    let start = std::time::Instant::now();
    let sum_par: i32 = numbers.par_iter().sum();
    println!("Parallel sum:   {} ({:?})", sum_par, start.elapsed());
}
```

### 2.2 par_iter() 家族

```rust
use rayon::prelude::*;

fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // par_iter() - 不可变并行迭代
    numbers.par_iter()
        .for_each(|x| println!("Value: {}", x));

    // par_iter_mut() - 可变并行迭代
    numbers.par_iter_mut()
        .for_each(|x| *x *= 2);
    println!("After doubling: {:?}", numbers);

    // into_par_iter() - 获取所有权
    let results: Vec<_> = numbers.into_par_iter()
        .map(|x| x + 10)
        .collect();
    println!("Results: {:?}", results);
}
```

### 2.3 并行 map/filter/reduce

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=100).collect();

    // 并行 map
    let squares: Vec<_> = numbers.par_iter()
        .map(|&x| x * x)
        .collect();

    // 并行 filter
    let evens: Vec<_> = numbers.par_iter()
        .filter(|&&x| x % 2 == 0)
        .copied()
        .collect();

    // 并行 reduce
    let sum: i32 = numbers.par_iter()
        .cloned()
        .reduce(|| 0, |a, b| a + b);

    println!("Sum of squares of evens: {}",
        evens.par_iter()
            .map(|&x| x * x)
            .sum::<i32>()
    );
}
```

### 2.4 链式操作

```rust
use rayon::prelude::*;

fn is_prime(n: u64) -> bool {
    if n < 2 {
        return false;
    }
    (2..=(n as f64).sqrt() as u64 + 1)
        .all(|i| n % i != 0)
}

fn main() {
    let numbers: Vec<u64> = (1..=10000).collect();

    let result: u64 = numbers.par_iter()
        .filter(|&&n| is_prime(n))     // 筛选质数
        .map(|&n| n * n)                // 平方
        .filter(|&n| n > 100)           // 大于 100
        .sum();                         // 求和

    println!("Result: {}", result);
}
```

---

## 3. 并行集合操作

### 3.1 并行排序

```rust
use rayon::prelude::*;

fn main() {
    let mut numbers: Vec<i32> = (1..=1000000).rev().collect();

    // 并行排序
    let start = std::time::Instant::now();
    numbers.par_sort_unstable();
    println!("Parallel sort: {:?}", start.elapsed());

    // 验证排序
    assert!(numbers.windows(2).all(|w| w[0] <= w[1]));
}
```

### 3.2 并行搜索

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=1000000).collect();
    let target = 789456;

    // 并行查找
    let found = numbers.par_iter()
        .position_any(|&x| x == target);

    match found {
        Some(pos) => println!("Found at position: {}", pos),
        None => println!("Not found"),
    }

    // 并行查找所有匹配项
    let matches: Vec<_> = numbers.par_iter()
        .enumerate()
        .filter(|(_, &x)| x % 12345 == 0)
        .map(|(i, &x)| (i, x))
        .collect();

    println!("Found {} matches", matches.len());
}
```

### 3.3 并行分区

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=100).collect();

    // 按条件分区
    let (evens, odds): (Vec<_>, Vec<_>) = numbers.par_iter()
        .partition(|&&x| x % 2 == 0);

    println!("Evens: {} numbers", evens.len());
    println!("Odds:  {} numbers", odds.len());
}
```

---

## 4. 自定义并行任务

### 4.1 使用 join() 分叉-合并

```rust
use rayon::join;

fn fibonacci(n: u32) -> u64 {
    if n < 2 {
        return n as u64;
    }

    // 并行计算两个子问题
    let (left, right) = join(
        || fibonacci(n - 1),
        || fibonacci(n - 2),
    );

    left + right
}

fn main() {
    let result = fibonacci(30);
    println!("Fibonacci(30) = {}", result);
}
```

### 4.2 使用 scope() 生成任务

```rust
use rayon::scope;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let mut results = vec![0; data.len()];

    scope(|s| {
        for (i, &item) in data.iter().enumerate() {
            s.spawn(move |_| {
                results[i] = item * item;
            });
        }
    });

    println!("Results: {:?}", results);
}
```

### 4.3 使用 ThreadPool 自定义线程池

```rust
use rayon::ThreadPoolBuilder;

fn main() {
    // 创建 4 线程池
    let pool = ThreadPoolBuilder::new()
        .num_threads(4)
        .build()
        .unwrap();

    pool.install(|| {
        let result: i32 = (1..=1000).into_par_iter().sum();
        println!("Sum: {}", result);
    });
}
```

---

## 5. 分治算法

### 5.1 快速排序

```rust
use rayon::join;

fn parallel_quicksort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);

    // 并行递归
    join(
        || parallel_quicksort(left),
        || parallel_quicksort(&mut right[1..]),
    );
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot_index = len / 2;
    arr.swap(pivot_index, len - 1);

    let mut i = 0;
    for j in 0..len - 1 {
        if arr[j] <= arr[len - 1] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, len - 1);
    i
}

fn main() {
    let mut numbers: Vec<i32> = (1..=10000).rev().collect();

    let start = std::time::Instant::now();
    parallel_quicksort(&mut numbers);
    println!("Sorted in {:?}", start.elapsed());

    assert!(numbers.windows(2).all(|w| w[0] <= w[1]));
}
```

### 5.2 归并排序

```rust
use rayon::join;

fn parallel_merge_sort<T: Ord + Clone + Send>(arr: &mut [T]) {
    let len = arr.len();
    if len <= 1 {
        return;
    }

    let mid = len / 2;
    let (left, right) = arr.split_at_mut(mid);

    // 并行排序两半
    join(
        || parallel_merge_sort(left),
        || parallel_merge_sort(right),
    );

    // 合并结果
    let mut temp = Vec::with_capacity(len);
    merge(left, right, &mut temp);
    arr.copy_from_slice(&temp);
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T], result: &mut Vec<T>) {
    let (mut i, mut j) = (0, 0);

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }

    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
}

fn main() {
    let mut numbers: Vec<i32> = (1..=10000).rev().collect();
    parallel_merge_sort(&mut numbers);
    println!("Sorted successfully");
}
```

---

## 6. 数据并行模式

### 6.1 Map-Reduce

```rust
use rayon::prelude::*;

fn word_count(text: &str) -> usize {
    text.split_whitespace().count()
}

fn main() {
    let documents = vec![
        "Hello world from Rust",
        "Parallel programming is fun",
        "Rayon makes it easy",
    ];

    // Map: 并行计算每个文档的词数
    let counts: Vec<_> = documents.par_iter()
        .map(|doc| word_count(doc))
        .collect();

    // Reduce: 汇总总词数
    let total: usize = counts.iter().sum();

    println!("Total words: {}", total);
}
```

### 6.2 并行聚合

```rust
use rayon::prelude::*;
use std::collections::HashMap;

#[derive(Debug)]
struct Stats {
    count: usize,
    sum: i32,
    min: i32,
    max: i32,
}

impl Stats {
    fn new(value: i32) -> Self {
        Stats {
            count: 1,
            sum: value,
            min: value,
            max: value,
        }
    }

    fn merge(self, other: Self) -> Self {
        Stats {
            count: self.count + other.count,
            sum: self.sum + other.sum,
            min: self.min.min(other.min),
            max: self.max.max(other.max),
        }
    }
}

fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();

    let stats = numbers.par_iter()
        .fold(
            || None,
            |acc: Option<Stats>, &x| {
                Some(match acc {
                    None => Stats::new(x),
                    Some(s) => s.merge(Stats::new(x)),
                })
            }
        )
        .reduce(
            || None,
            |a, b| match (a, b) {
                (Some(sa), Some(sb)) => Some(sa.merge(sb)),
                (Some(s), None) | (None, Some(s)) => Some(s),
                _ => None,
            }
        );

    if let Some(s) = stats {
        println!("Stats: {:?}", s);
        println!("Average: {}", s.sum as f64 / s.count as f64);
    }
}
```

### 6.3 并行分组

```rust
use rayon::prelude::*;
use std::collections::HashMap;

fn main() {
    let words = vec![
        "apple", "banana", "apricot", "blueberry",
        "cherry", "avocado", "blackberry", "cranberry",
    ];

    // 按首字母分组
    let grouped: HashMap<char, Vec<&str>> = words.par_iter()
        .fold(
            HashMap::new,
            |mut acc, &word| {
                acc.entry(word.chars().next().unwrap())
                    .or_insert_with(Vec::new)
                    .push(word);
                acc
            }
        )
        .reduce(
            HashMap::new,
            |mut a, b| {
                for (k, v) in b {
                    a.entry(k).or_insert_with(Vec::new).extend(v);
                }
                a
            }
        );

    for (letter, words) in grouped {
        println!("{}: {:?}", letter, words);
    }
}
```

---

## 7. 性能调优

### 7.1 选择合适的粒度

```rust
use rayon::prelude::*;

fn main() {
    let numbers: Vec<i32> = (1..=10000000).collect();

    // ❌ 太细：每个元素单独处理（开销大）
    // let sum: i32 = numbers.par_iter().sum();

    // ✅ 好：适当分块
    let chunk_size = 10000;
    let sum: i32 = numbers.par_chunks(chunk_size)
        .map(|chunk| chunk.iter().sum::<i32>())
        .sum();

    println!("Sum: {}", sum);
}
```

### 7.2 避免过小的任务

```rust
use rayon::prelude::*;

fn is_expensive(n: i32) -> bool {
    // 模拟昂贵操作
    (0..1000).map(|x| x * n).sum::<i32>() > 0
}

fn main() {
    let numbers: Vec<i32> = (1..=1000).collect();

    // ❌ 不好：任务太小，并行开销大于收益
    let trivial_count = (0..10).into_par_iter()
        .filter(|&x| x % 2 == 0)
        .count();

    // ✅ 好：任务足够大
    let expensive_count = numbers.par_iter()
        .filter(|&&x| is_expensive(x))
        .count();

    println!("Expensive count: {}", expensive_count);
}
```

### 7.3 基准测试

```rust
use rayon::prelude::*;
use std::time::Instant;

fn benchmark<F: Fn()>(name: &str, f: F) {
    let start = Instant::now();
    f();
    println!("{}: {:?}", name, start.elapsed());
}

fn main() {
    let numbers: Vec<i32> = (1..=10000000).collect();

    benchmark("Sequential sum", || {
        let _sum: i32 = numbers.iter().sum();
    });

    benchmark("Parallel sum", || {
        let _sum: i32 = numbers.par_iter().sum();
    });

    benchmark("Sequential map", || {
        let _: Vec<_> = numbers.iter().map(|x| x * x).collect();
    });

    benchmark("Parallel map", || {
        let _: Vec<_> = numbers.par_iter().map(|x| x * x).collect();
    });
}
```

---

## 8. 最佳实践

### 8.1 测量再优化

```rust
use rayon::prelude::*;

fn main() {
    let threshold = 10000;
    let numbers: Vec<i32> = (1..=1000000).collect();

    // 根据数据规模选择策略
    let sum = if numbers.len() < threshold {
        // 小数据集：串行更快
        numbers.iter().sum()
    } else {
        // 大数据集：并行更快
        numbers.par_iter().sum()
    };

    println!("Sum: {}", sum);
}
```

### 8.2 避免不必要的并行

```rust
use rayon::prelude::*;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // ❌ 不必要：数据太少
    let _: Vec<_> = numbers.par_iter().map(|x| x * 2).collect();

    // ✅ 串行即可
    let _: Vec<_> = numbers.iter().map(|x| x * 2).collect();
}
```

### 8.3 配置线程池

```rust
use rayon::ThreadPoolBuilder;

fn main() {
    // 自定义线程池配置
    let pool = ThreadPoolBuilder::new()
        .num_threads(8)
        .thread_name(|i| format!("worker-{}", i))
        .stack_size(4 * 1024 * 1024)  // 4MB
        .build()
        .unwrap();

    pool.install(|| {
        // 在自定义线程池中执行
        let result: i32 = (1..=1000).into_par_iter().sum();
        println!("Result: {}", result);
    });
}
```

---

## 9. 常见陷阱

### 9.1 错误的共享状态

```rust
use rayon::prelude::*;
use std::sync::Mutex;

fn main() {
    let counter = Mutex::new(0);

    // ❌ 不好：Mutex 成为瓶颈
    (0..1000).into_par_iter().for_each(|_| {
        let mut c = counter.lock().unwrap();
        *c += 1;
    });

    // ✅ 好：使用 reduce
    let count: i32 = (0..1000).into_par_iter()
        .map(|_| 1)
        .sum();

    println!("Count: {}", count);
}
```

### 9.2 非线程安全类型

```rust
use rayon::prelude::*;
use std::rc::Rc;

fn main() {
    let data = vec![1, 2, 3];

    // ❌ 编译错误：Rc 不是 Send
    // let shared = Rc::new(data);
    // (0..10).into_par_iter().for_each(|_| {
    //     println!("{:?}", shared);
    // });

    // ✅ 正确：使用 Arc
    let shared = std::sync::Arc::new(data);
    (0..10).into_par_iter().for_each(|_| {
        println!("{:?}", shared);
    });
}
```

---

## 10. 参考资源

### 10.1 官方文档

- [Rayon Documentation](https://docs.rs/rayon)
- [Rayon Book](https://github.com/rayon-rs/rayon/blob/master/FAQ.md)

### 10.2 推荐阅读

- [Data Parallelism in Rust](https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/)
- [Rayon Performance Tips](https://github.com/rayon-rs/rayon/blob/master/FAQ.md#performance)

### 10.3 内部文档链接

- [← 上一篇：消息传递模式](./03_消息传递模式.md)
- [→ 下一篇：异步集成实践](./05_异步集成实践.md)
- [↑ 返回主索引](../tier_01_foundations/02_主索引导航.md)

---

**文档维护**: C05 Threads Team | **最后审核**: 2025-10-22 | **质量评分**: 95/100
