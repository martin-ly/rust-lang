# 🧵 C05: 线程编程 - 代码示例集合

> **创建日期**: 2025-10-25  
> **文档版本**: v1.0  
> **适用模块**: C05 线程编程  
> **目标**: 通过丰富的代码示例，帮助学习者深入理解 Rust 并发编程和线程安全。

---

## 目录

- [🧵 C05: 线程编程 - 代码示例集合](#-c05-线程编程---代码示例集合)
  - [目录](#目录)
  - [📋 文档概述](#-文档概述)
  - [🎯 示例导航](#-示例导航)
  - [🎓 Tier 1: 基础层示例](#-tier-1-基础层示例)
    - [示例1.1: 线程创建和join](#示例11-线程创建和join)
    - [示例1.2: 线程闭包和move](#示例12-线程闭包和move)
    - [示例1.3: 线程panic处理](#示例13-线程panic处理)
    - [示例1.4: 线程休眠和yield](#示例14-线程休眠和yield)
    - [示例1.5: Send和Sync trait](#示例15-send和sync-trait)
    - [示例1.6: 线程局部存储](#示例16-线程局部存储)
  - [🎓 Tier 2: 实践层示例](#-tier-2-实践层示例)
    - [示例2.1: Arc共享所有权](#示例21-arc共享所有权)
    - [示例2.2: Mutex互斥锁](#示例22-mutex互斥锁)
    - [示例2.3: RwLock读写锁](#示例23-rwlock读写锁)
    - [示例2.4: Condvar条件变量](#示例24-condvar条件变量)
    - [示例2.5: Channel通道](#示例25-channel通道)
    - [示例2.6: Atomic原子操作](#示例26-atomic原子操作)
  - [🚀 Tier 3: 高级层示例](#-tier-3-高级层示例)
    - [示例3.1: 线程池实现](#示例31-线程池实现)
    - [示例3.2: 工作窃取](#示例32-工作窃取)
    - [示例3.3: 并发数据结构](#示例33-并发数据结构)
    - [示例3.4: 无锁编程](#示例34-无锁编程)
    - [示例3.5: 内存顺序](#示例35-内存顺序)
    - [示例3.6: 性能分析](#示例36-性能分析)
  - [📝 总结](#-总结)
    - [学习路径建议](#学习路径建议)
    - [核心概念总结](#核心概念总结)
    - [最佳实践](#最佳实践)
    - [下一步](#下一步)

## 📋 文档概述

本文档提供了 **18个精心设计的代码示例**，覆盖了 C05 模块的核心概念，从基础到高级，每个示例都配有详细的解释和运行结果。

---

## 🎯 示例导航

| # | 示例名称 | 核心概念 | 难度 | 预计学习时间 |
|---|----------|----------|------|--------------|
| **Tier 1: 基础层** |||||
| 1.1 | [线程创建和join](#示例11-线程创建和join) | thread::spawn | ⭐ | 15分钟 |
| 1.2 | [线程闭包和move](#示例12-线程闭包和move) | move语义 | ⭐ | 20分钟 |
| 1.3 | [线程panic处理](#示例13-线程panic处理) | panic恢复 | ⭐⭐ | 25分钟 |
| 1.4 | [线程休眠和yield](#示例14-线程休眠和yield) | sleep/yield_now | ⭐ | 15分钟 |
| 1.5 | [Send和Sync trait](#示例15-send和sync-trait) | 线程安全 | ⭐⭐ | 30分钟 |
| 1.6 | [线程局部存储](#示例16-线程局部存储) | thread_local! | ⭐⭐ | 25分钟 |
| **Tier 2: 实践层** |||||
| 2.1 | [Arc共享所有权](#示例21-arc共享所有权) | Arc | ⭐⭐ | 30分钟 |
| 2.2 | [Mutex互斥锁](#示例22-mutex互斥锁) | Mutex | ⭐⭐ | 35分钟 |
| 2.3 | [RwLock读写锁](#示例23-rwlock读写锁) | RwLock | ⭐⭐⭐ | 40分钟 |
| 2.4 | [Condvar条件变量](#示例24-condvar条件变量) | Condvar | ⭐⭐⭐ | 40分钟 |
| 2.5 | [Channel通道](#示例25-channel通道) | mpsc | ⭐⭐ | 35分钟 |
| 2.6 | [Atomic原子操作](#示例26-atomic原子操作) | Atomic | ⭐⭐⭐ | 40分钟 |
| **Tier 3: 高级层** |||||
| 3.1 | [线程池实现](#示例31-线程池实现) | 线程池 | ⭐⭐⭐⭐ | 50分钟 |
| 3.2 | [工作窃取](#示例32-工作窃取) | 工作窃取 | ⭐⭐⭐⭐⭐ | 60分钟 |
| 3.3 | [并发数据结构](#示例33-并发数据结构) | 并发数据结构 | ⭐⭐⭐⭐ | 50分钟 |
| 3.4 | [无锁编程](#示例34-无锁编程) | 无锁栈/ABA | ⭐⭐⭐⭐⭐ | 60分钟 |
| 3.5 | [内存顺序](#示例35-内存顺序) | Ordering | ⭐⭐⭐⭐⭐ | 60分钟 |
| 3.6 | [性能分析](#示例36-性能分析) | 性能对比 | ⭐⭐⭐⭐ | 50分钟 |

---

## 🎓 Tier 1: 基础层示例

### 示例1.1: 线程创建和join

**目标**: 理解线程的创建和等待

**难度**: ⭐

**代码**:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== 基础线程创建 =====\n");
    
    // 创建一个新线程
    let handle = thread::spawn(|| {
        println!("Hello from thread!");
        42
    });
    
    // 等待线程完成
    let result = handle.join().unwrap();
    println!("线程返回值: {}\n", result);
    
    println!("===== 多个线程 =====\n");
    
    let mut handles = vec![];
    
    // 创建 5 个线程
    for i in 0..5 {
        let handle = thread::spawn(move || {
            println!("线程 {} 启动", i);
            thread::sleep(Duration::from_millis(100));
            println!("线程 {} 完成", i);
            i * 2
        });
        handles.push(handle);
    }
    
    // 等待所有线程完成
    for handle in handles {
        let result = handle.join().unwrap();
        println!("收到结果: {}", result);
    }
    
    println!("\n===== 线程执行顺序 =====\n");
    
    // 线程执行顺序不确定
    for i in 0..3 {
        thread::spawn(move || {
            println!("线程 {}", i);
        });
    }
    
    // 主线程等待，让子线程有时间执行
    thread::sleep(Duration::from_millis(100));
    
    println!("\n===== 获取线程ID =====\n");
    
    let handle = thread::spawn(|| {
        let id = thread::current().id();
        println!("子线程 ID: {:?}", id);
    });
    
    let main_id = thread::current().id();
    println!("主线程 ID: {:?}", main_id);
    
    handle.join().unwrap();
}
```

**说明**:

- **thread::spawn**: 创建新线程
- **join**: 等待线程完成并获取返回值
- **执行顺序**: 线程执行顺序不确定
- **线程ID**: 可以获取线程的唯一标识符

**输出**:

```text
===== 基础线程创建 =====

Hello from thread!
线程返回值: 42

===== 多个线程 =====

线程 0 启动
线程 1 启动
线程 2 启动
线程 3 启动
线程 4 启动
线程 0 完成
线程 1 完成
线程 2 完成
线程 3 完成
线程 4 完成
收到结果: 0
收到结果: 2
收到结果: 4
收到结果: 6
收到结果: 8

===== 线程执行顺序 =====

线程 0
线程 2
线程 1

===== 获取线程ID =====

主线程 ID: ThreadId(1)
子线程 ID: ThreadId(2)
```

---

### 示例1.2: 线程闭包和move

**目标**: 理解线程闭包的所有权转移

**难度**: ⭐

**代码**:

```rust
use std::thread;

fn main() {
    println!("===== 捕获环境变量 =====\n");
    
    let data = vec![1, 2, 3, 4, 5];
    
    // ❌ 错误：闭包可能比数据活得更久
    // let handle = thread::spawn(|| {
    //     println!("Data: {:?}", data);
    // });
    
    // ✅ 使用 move 转移所有权
    let handle = thread::spawn(move || {
        println!("Data: {:?}", data);
        data.len()
    });
    
    let len = handle.join().unwrap();
    println!("长度: {}\n", len);
    
    // println!("{:?}", data);  // ❌ data 已被移动
    
    println!("===== Copy 类型 =====\n");
    
    let x = 42;  // i32 实现了 Copy
    
    let handle = thread::spawn(move || {
        println!("x = {}", x);
    });
    
    handle.join().unwrap();
    println!("主线程中 x = {}", x);  // ✅ Copy 类型可以继续使用
    
    println!("\n===== Clone 解决方案 =====\n");
    
    let data = vec![1, 2, 3];
    let data_clone = data.clone();  // 克隆数据
    
    let handle = thread::spawn(move || {
        println!("线程中: {:?}", data_clone);
    });
    
    println!("主线程中: {:?}", data);  // ✅ 原始数据仍可用
    handle.join().unwrap();
    
    println!("\n===== 多个线程共享数据 =====\n");
    
    use std::sync::Arc;
    
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("线程 {} 看到: {:?}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("主线程仍可访问: {:?}", data);
}
```

**说明**:

- **move关键字**: 强制闭包获取捕获变量的所有权
- **Copy类型**: Copy 类型在 move 后仍可使用
- **Clone**: 克隆数据以在多处使用
- **Arc**: 用于多线程共享只读数据

**输出**:

```text
===== 捕获环境变量 =====

Data: [1, 2, 3, 4, 5]
长度: 5

===== Copy 类型 =====

x = 42
主线程中 x = 42

===== Clone 解决方案 =====

主线程中: [1, 2, 3]
线程中: [1, 2, 3]

===== 多个线程共享数据 =====

线程 0 看到: [1, 2, 3, 4, 5]
线程 1 看到: [1, 2, 3, 4, 5]
线程 2 看到: [1, 2, 3, 4, 5]
主线程仍可访问: [1, 2, 3, 4, 5]
```

---

### 示例1.3: 线程panic处理

**目标**: 理解线程 panic 的处理

**难度**: ⭐⭐

**代码**:

```rust
use std::thread;
use std::panic;

fn main() {
    println!("===== 线程 panic =====\n");
    
    let handle = thread::spawn(|| {
        println!("线程开始");
        panic!("线程 panic!");
    });
    
    // join 返回 Result
    match handle.join() {
        Ok(_) => println!("线程正常完成"),
        Err(e) => println!("线程 panic: {:?}\n", e),
    }
    
    println!("主线程继续运行\n");
    
    println!("===== 捕获 panic 信息 =====\n");
    
    let handle = thread::spawn(|| {
        panic!("错误消息");
    });
    
    match handle.join() {
        Ok(_) => {},
        Err(e) => {
            if let Some(s) = e.downcast_ref::<&str>() {
                println!("捕获到字符串 panic: {}", s);
            } else if let Some(s) = e.downcast_ref::<String>() {
                println!("捕获到 String panic: {}", s);
            } else {
                println!("捕获到未知类型 panic");
            }
        }
    }
    
    println!("\n===== 设置 panic hook =====\n");
    
    panic::set_hook(Box::new(|panic_info| {
        println!("自定义 panic 处理器被调用");
        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            println!("panic 消息: {}", s);
        }
        if let Some(location) = panic_info.location() {
            println!("panic 位置: {}:{}", location.file(), location.line());
        }
    }));
    
    let handle = thread::spawn(|| {
        panic!("带 hook 的 panic");
    });
    
    let _ = handle.join();
    
    // 恢复默认 hook
    let _ = panic::take_hook();
    
    println!("\n===== 防御性编程 =====\n");
    
    fn safe_operation(x: i32) -> Result<i32, String> {
        if x < 0 {
            Err("负数不允许".to_string())
        } else {
            Ok(x * 2)
        }
    }
    
    let handle = thread::spawn(|| {
        match safe_operation(-5) {
            Ok(result) => println!("结果: {}", result),
            Err(e) => println!("错误: {}", e),
        }
    });
    
    handle.join().unwrap();
    
    println!("\n===== 多线程 panic 隔离 =====\n");
    
    let mut handles = vec![];
    
    for i in 0..5 {
        let handle = thread::spawn(move || {
            if i == 2 {
                panic!("线程 {} panic!", i);
            }
            println!("线程 {} 正常完成", i);
        });
        handles.push(handle);
    }
    
    for (i, handle) in handles.into_iter().enumerate() {
        match handle.join() {
            Ok(_) => println!("线程 {} join 成功", i),
            Err(_) => println!("线程 {} join 失败", i),
        }
    }
}
```

**说明**:

- **join返回Result**: Err 表示线程 panic
- **downcast**: 获取 panic 的具体类型
- **panic hook**: 自定义 panic 处理
- **隔离**: 一个线程 panic 不影响其他线程

**输出**:

```text
===== 线程 panic =====

线程开始
线程 panic: Any { .. }

主线程继续运行

===== 捕获 panic 信息 =====

捕获到字符串 panic: 错误消息

===== 设置 panic hook =====

自定义 panic 处理器被调用
panic 消息: 带 hook 的 panic
panic 位置: src/main.rs:XX

===== 防御性编程 =====

错误: 负数不允许

===== 多线程 panic 隔离 =====

线程 0 正常完成
线程 1 正常完成
线程 3 正常完成
线程 4 正常完成
线程 0 join 成功
线程 1 join 成功
线程 2 join 失败
线程 3 join 成功
线程 4 join 成功
```

---

### 示例1.4: 线程休眠和yield

**目标**: 理解线程调度和协作

**难度**: ⭐

**代码**:

```rust
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    println!("===== 线程休眠 =====\n");
    
    let start = Instant::now();
    
    thread::sleep(Duration::from_millis(100));
    
    println!("休眠 100ms 后唤醒");
    println!("实际耗时: {:?}\n", start.elapsed());
    
    println!("===== 多个线程休眠 =====\n");
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let handle = thread::spawn(move || {
            println!("线程 {} 开始", i);
            thread::sleep(Duration::from_millis(i * 100));
            println!("线程 {} 完成", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n===== thread::yield_now =====\n");
    
    // yield_now 让出 CPU 时间片
    let handle1 = thread::spawn(|| {
        for i in 0..5 {
            println!("线程1: {}", i);
            thread::yield_now();  // 主动让出 CPU
        }
    });
    
    let handle2 = thread::spawn(|| {
        for i in 0..5 {
            println!("线程2: {}", i);
            thread::yield_now();
        }
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    println!("\n===== 自旋 vs 休眠 =====\n");
    
    // 自旋锁（占用 CPU）
    let start = Instant::now();
    let mut counter = 0;
    while start.elapsed() < Duration::from_millis(10) {
        counter += 1;
    }
    println!("自旋计数: {}", counter);
    
    // 休眠（释放 CPU）
    let start = Instant::now();
    thread::sleep(Duration::from_millis(10));
    println!("休眠耗时: {:?}", start.elapsed());
    
    println!("\n===== park 和 unpark =====\n");
    
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    
    let ready = Arc::new(AtomicBool::new(false));
    let ready_clone = Arc::clone(&ready);
    
    let handle = thread::spawn(move || {
        println!("子线程: 准备 park");
        
        while !ready_clone.load(Ordering::SeqCst) {
            thread::park();  // 暂停线程
        }
        
        println!("子线程: 被 unpark，继续执行");
    });
    
    thread::sleep(Duration::from_millis(100));
    println!("主线程: 设置 ready = true");
    ready.store(true, Ordering::SeqCst);
    
    handle.thread().unpark();  // 唤醒线程
    
    handle.join().unwrap();
    
    println!("\n===== 定时器模拟 =====\n");
    
    fn timer(duration: Duration, message: &str) {
        let message = message.to_string();
        thread::spawn(move || {
            thread::sleep(duration);
            println!("⏰ {}", message);
        });
    }
    
    timer(Duration::from_millis(100), "100ms 定时器");
    timer(Duration::from_millis(200), "200ms 定时器");
    timer(Duration::from_millis(300), "300ms 定时器");
    
    thread::sleep(Duration::from_millis(350));
}
```

**说明**:

- **sleep**: 线程休眠，释放 CPU
- **yield_now**: 主动让出 CPU 时间片
- **park/unpark**: 线程暂停和唤醒机制
- **自旋 vs 休眠**: 自旋占用 CPU，休眠释放 CPU

**输出**:

```text
===== 线程休眠 =====

休眠 100ms 后唤醒
实际耗时: 100.xxms

===== 多个线程休眠 =====

线程 0 开始
线程 1 开始
线程 2 开始
线程 0 完成
线程 1 完成
线程 2 完成

===== thread::yield_now =====

线程1: 0
线程2: 0
线程1: 1
线程2: 1
线程1: 2
线程2: 2
线程1: 3
线程2: 3
线程1: 4
线程2: 4

===== 自旋 vs 休眠 =====

自旋计数: 1234567
休眠耗时: 10.xxms

===== park 和 unpark =====

子线程: 准备 park
主线程: 设置 ready = true
子线程: 被 unpark，继续执行

===== 定时器模拟 =====

⏰ 100ms 定时器
⏰ 200ms 定时器
⏰ 300ms 定时器
```

---

### 示例1.5: Send和Sync trait

**目标**: 理解线程安全的类型系统保证

**难度**: ⭐⭐

**代码**:

```rust
use std::thread;
use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell;
use std::sync::Mutex;

fn main() {
    println!("===== Send trait =====\n");
    
    // Send: 可以安全地在线程间转移所有权
    
    // ✅ i32 实现了 Send
    let x = 42;
    thread::spawn(move || {
        println!("i32 是 Send: {}", x);
    }).join().unwrap();
    
    // ✅ String 实现了 Send
    let s = String::from("hello");
    thread::spawn(move || {
        println!("String 是 Send: {}", s);
    }).join().unwrap();
    
    // ❌ Rc<T> 没有实现 Send
    let rc = Rc::new(vec![1, 2, 3]);
    // thread::spawn(move || {  // 编译错误！
    //     println!("{:?}", rc);
    // });
    
    println!("Rc<T> 不是 Send（单线程引用计数）\n");
    
    // ✅ Arc<T> 实现了 Send
    let arc = Arc::new(vec![1, 2, 3]);
    thread::spawn(move || {
        println!("Arc<T> 是 Send: {:?}", arc);
    }).join().unwrap();
    
    println!("\n===== Sync trait =====\n");
    
    // Sync: 可以安全地在线程间共享不可变引用
    // &T 是 Send 当且仅当 T 是 Sync
    
    // ✅ i32 实现了 Sync
    let x = 42;
    let x_ref = &x;
    // 不能直接在闭包中使用引用，需要作用域线程
    
    // ❌ RefCell<T> 没有实现 Sync
    let cell = RefCell::new(5);
    // let cell_ref = &cell;
    // thread::spawn(move || {  // 编译错误！
    //     cell_ref.borrow_mut();
    // });
    
    println!("RefCell<T> 不是 Sync（运行时借用检查）");
    
    // ✅ Mutex<T> 实现了 Sync
    let mutex = Arc::new(Mutex::new(5));
    let mutex_clone = Arc::clone(&mutex);
    
    thread::spawn(move || {
        let mut data = mutex_clone.lock().unwrap();
        *data += 1;
        println!("Mutex<T> 是 Sync: {}", data);
    }).join().unwrap();
    
    println!("\n===== 自动派生 =====\n");
    
    // 结构体自动实现 Send/Sync（如果所有字段都实现）
    #[derive(Debug)]
    struct Data {
        value: i32,
        text: String,
    }
    
    let data = Data {
        value: 42,
        text: "hello".to_string(),
    };
    
    thread::spawn(move || {
        println!("Data 自动实现 Send: {:?}", data);
    }).join().unwrap();
    
    println!("\n===== 手动实现(unsafe) =====\n");
    
    struct MyType {
        value: i32,
    }
    
    // 通常不需要手动实现，编译器自动推导
    // 只有在特殊情况下才需要 unsafe impl
    
    // unsafe impl Send for MyType {}
    // unsafe impl Sync for MyType {}
    
    println!("⚠️  手动实现 Send/Sync 需要 unsafe");
    println!("⚠️  必须确保真的是线程安全的");
    
    println!("\n===== Send + Sync 总结 =====\n");
    
    println!("Send: 可以在线程间转移所有权");
    println!("  ✅ 大部分类型 (i32, String, Vec<T>, Box<T>)");
    println!("  ❌ Rc<T> (单线程引用计数)");
    println!("  ✅ Arc<T> (原子引用计数)");
    
    println!("\nSync: 可以在线程间共享引用");
    println!("  ✅ 大部分类型 (i32, String, Vec<T>)");
    println!("  ❌ RefCell<T>, Cell<T> (运行时借用)");
    println!("  ✅ Mutex<T>, RwLock<T> (同步原语)");
    
    println!("\n关系:");
    println!("  T: Send ⇒ &T 可以在线程间传递");
    println!("  T: Sync ⇒ &T 是 Send");
    println!("  T: Send + Sync ⇒ Arc<T> 是 Send + Sync");
}
```

**说明**:

- **Send**: 类型可以安全地在线程间转移所有权
- **Sync**: 类型可以安全地在线程间共享不可变引用
- **自动派生**: 编译器自动为满足条件的类型实现
- **Rc vs Arc**: Rc 不是线程安全的，Arc 是

**输出**:

```text
===== Send trait =====

i32 是 Send: 42
String 是 Send: hello
Rc<T> 不是 Send（单线程引用计数）
Arc<T> 是 Send: [1, 2, 3]

===== Sync trait =====

RefCell<T> 不是 Sync（运行时借用检查）
Mutex<T> 是 Sync: 6

===== 自动派生 =====

Data 自动实现 Send: Data { value: 42, text: "hello" }

===== 手动实现(unsafe) =====

⚠️  手动实现 Send/Sync 需要 unsafe
⚠️  必须确保真的是线程安全的

===== Send + Sync 总结 =====

Send: 可以在线程间转移所有权
  ✅ 大部分类型 (i32, String, Vec<T>, Box<T>)
  ❌ Rc<T> (单线程引用计数)
  ✅ Arc<T> (原子引用计数)

Sync: 可以在线程间共享引用
  ✅ 大部分类型 (i32, String, Vec<T>)
  ❌ RefCell<T>, Cell<T> (运行时借用)
  ✅ Mutex<T>, RwLock<T> (同步原语)

关系:
  T: Send ⇒ &T 可以在线程间传递
  T: Sync ⇒ &T 是 Send
  T: Send + Sync ⇒ Arc<T> 是 Send + Sync
```

---

### 示例1.6: 线程局部存储

**目标**: 理解线程局部变量

**难度**: ⭐⭐

**代码**:

```rust
use std::thread;
use std::cell::RefCell;

fn main() {
    println!("===== thread_local! 基础 =====\n");
    
    thread_local! {
        static COUNTER: RefCell<u32> = RefCell::new(0);
    }
    
    // 主线程
    COUNTER.with(|c| {
        *c.borrow_mut() += 1;
        println!("主线程 counter: {}", c.borrow());
    });
    
    // 子线程 1
    let handle1 = thread::spawn(|| {
        COUNTER.with(|c| {
            *c.borrow_mut() += 10;
            println!("线程1 counter: {}", c.borrow());
        });
    });
    
    // 子线程 2
    let handle2 = thread::spawn(|| {
        COUNTER.with(|c| {
            *c.borrow_mut() += 100;
            println!("线程2 counter: {}", c.borrow());
        });
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // 主线程的值不受影响
    COUNTER.with(|c| {
        println!("主线程 counter (最终): {}", c.borrow());
    });
    
    println!("\n===== 线程ID存储 =====\n");
    
    thread_local! {
        static THREAD_NAME: RefCell<String> = RefCell::new(String::from("未命名"));
    }
    
    fn set_thread_name(name: &str) {
        THREAD_NAME.with(|n| {
            *n.borrow_mut() = name.to_string();
        });
    }
    
    fn get_thread_name() -> String {
        THREAD_NAME.with(|n| n.borrow().clone())
    }
    
    set_thread_name("MainThread");
    println!("当前线程: {}", get_thread_name());
    
    let handle = thread::spawn(|| {
        set_thread_name("WorkerThread");
        println!("当前线程: {}", get_thread_name());
    });
    
    handle.join().unwrap();
    println!("主线程: {}", get_thread_name());
    
    println!("\n===== 性能计数器 =====\n");
    
    thread_local! {
        static PERF_COUNTER: RefCell<u64> = RefCell::new(0);
    }
    
    fn inc_counter() {
        PERF_COUNTER.with(|c| {
            *c.borrow_mut() += 1;
        });
    }
    
    fn get_counter() -> u64 {
        PERF_COUNTER.with(|c| *c.borrow())
    }
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                inc_counter();
            }
            println!("线程{} 计数: {}", i, get_counter());
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n===== 缓存示例 =====\n");
    
    use std::collections::HashMap;
    
    thread_local! {
        static CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
    }
    
    fn cache_get(key: &str) -> Option<i32> {
        CACHE.with(|c| c.borrow().get(key).copied())
    }
    
    fn cache_set(key: String, value: i32) {
        CACHE.with(|c| {
            c.borrow_mut().insert(key, value);
        });
    }
    
    cache_set("answer".to_string(), 42);
    println!("缓存读取: {:?}", cache_get("answer"));
    
    let handle = thread::spawn(|| {
        // 每个线程有独立的缓存
        cache_set("local".to_string(), 100);
        println!("线程缓存: {:?}", cache_get("local"));
        println!("线程缓存: {:?}", cache_get("answer"));  // None
    });
    
    handle.join().unwrap();
    
    println!("主线程缓存: {:?}", cache_get("answer"));  // Some(42)
    println!("主线程缓存: {:?}", cache_get("local"));   // None
}
```

**说明**:

- **thread_local!**: 定义线程局部变量
- **RefCell**: 允许内部可变性
- **独立性**: 每个线程有独立的变量副本
- **用途**: 线程ID、性能计数、缓存等

**输出**:

```text
===== thread_local! 基础 =====

主线程 counter: 1
线程1 counter: 10
线程2 counter: 100
主线程 counter (最终): 1

===== 线程ID存储 =====

当前线程: MainThread
当前线程: WorkerThread
主线程: MainThread

===== 性能计数器 =====

线程0 计数: 100
线程1 计数: 100
线程2 计数: 100

===== 缓存示例 =====

缓存读取: Some(42)
线程缓存: Some(100)
线程缓存: None
主线程缓存: Some(42)
主线程缓存: None
```

---

## 🎓 Tier 2: 实践层示例

### 示例2.1: Arc共享所有权

**目标**: 理解原子引用计数的使用

**难度**: ⭐⭐

**代码**:

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    println!("===== Arc 基础 =====\n");
    
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    
    println!("初始引用计数: {}", Arc::strong_count(&data));
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        println!("克隆后引用计数: {}", Arc::strong_count(&data_clone));
        
        let handle = thread::spawn(move || {
            println!("线程 {} 访问数据: {:?}", i, data_clone);
            println!("线程 {} 中引用计数: {}", i, Arc::strong_count(&data_clone));
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终引用计数: {}", Arc::strong_count(&data));
    
    println!("\n===== Arc + Mutex 模式 =====\n");
    
    use std::sync::Mutex;
    
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
            println!("线程 {} 增加计数", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", *counter.lock().unwrap());
    
    println!("\n===== 共享配置 =====\n");
    
    #[derive(Debug)]
    struct Config {
        host: String,
        port: u16,
        timeout: u64,
    }
    
    let config = Arc::new(Config {
        host: "localhost".to_string(),
        port: 8080,
        timeout: 30,
    });
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let config_clone = Arc::clone(&config);
        let handle = thread::spawn(move || {
            println!("线程 {} 使用配置: {:?}", i, config_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n===== Weak 弱引用 =====\n");
    
    let strong = Arc::new(42);
    let weak = Arc::downgrade(&strong);
    
    println!("强引用计数: {}", Arc::strong_count(&strong));
    println!("弱引用计数: {}", Arc::weak_count(&strong));
    
    // 尝试升级弱引用
    if let Some(strong_ref) = weak.upgrade() {
        println!("升级成功: {}", strong_ref);
    }
    
    drop(strong);  // 释放强引用
    
    // 再次尝试升级
    if let Some(_) = weak.upgrade() {
        println!("升级成功");
    } else {
        println!("升级失败：强引用已释放");
    }
    
    println!("\n===== 循环引用解决 =====\n");
    
    use std::sync::Weak;
    
    struct Node {
        value: i32,
        parent: Mutex<Weak<Node>>,
        children: Mutex<Vec<Arc<Node>>>,
    }
    
    let parent = Arc::new(Node {
        value: 1,
        parent: Mutex::new(Weak::new()),
        children: Mutex::new(vec![]),
    });
    
    let child = Arc::new(Node {
        value: 2,
        parent: Mutex::new(Arc::downgrade(&parent)),
        children: Mutex::new(vec![]),
    });
    
    parent.children.lock().unwrap().push(Arc::clone(&child));
    
    println!("节点树创建成功（避免循环引用）");
    println!("父节点引用计数: {}", Arc::strong_count(&parent));
    println!("子节点引用计数: {}", Arc::strong_count(&child));
}
```

**说明**:

- **Arc::clone**: 增加引用计数（廉价操作）
- **Arc + Mutex**: 多线程可变共享数据的标准模式
- **Weak**: 弱引用，不增加强引用计数
- **避免循环**: 使用 Weak 避免循环引用导致的内存泄漏

**输出**:

```text
===== Arc 基础 =====

初始引用计数: 1
克隆后引用计数: 2
克隆后引用计数: 3
克隆后引用计数: 4
线程 0 访问数据: [1, 2, 3, 4, 5]
线程 0 中引用计数: 4
线程 1 访问数据: [1, 2, 3, 4, 5]
线程 1 中引用计数: 3
线程 2 访问数据: [1, 2, 3, 4, 5]
线程 2 中引用计数: 2
最终引用计数: 1

===== Arc + Mutex 模式 =====

线程 0 增加计数
线程 1 增加计数
线程 2 增加计数
线程 3 增加计数
线程 4 增加计数
线程 5 增加计数
线程 6 增加计数
线程 7 增加计数
线程 8 增加计数
线程 9 增加计数
最终计数: 10

===== 共享配置 =====

线程 0 使用配置: Config { host: "localhost", port: 8080, timeout: 30 }
线程 1 使用配置: Config { host: "localhost", port: 8080, timeout: 30 }
线程 2 使用配置: Config { host: "localhost", port: 8080, timeout: 30 }

===== Weak 弱引用 =====

强引用计数: 1
弱引用计数: 1
升级成功: 42
升级失败：强引用已释放

===== 循环引用解决 =====

节点树创建成功（避免循环引用）
父节点引用计数: 1
子节点引用计数: 2
```

---

### 示例2.2: Mutex互斥锁

**目标**: 掌握互斥锁的使用

**难度**: ⭐⭐

**代码**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Mutex 基础 =====\n");
    
    let counter = Mutex::new(0);
    
    {
        let mut num = counter.lock().unwrap();
        *num += 1;
        println!("计数器: {}", num);
        // 锁在作用域结束时自动释放
    }
    
    println!("最终值: {}", *counter.lock().unwrap());
    
    println!("\n===== 多线程竞争 =====\n");
    
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                let mut num = counter_clone.lock().unwrap();
                *num += 1;
            }
            println!("线程 {} 完成", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", *counter.lock().unwrap());
    println!("预期: 1000");
    
    println!("\n===== try_lock 非阻塞 =====\n");
    
    let data = Arc::new(Mutex::new(0));
    let data_clone = Arc::clone(&data);
    
    let handle = thread::spawn(move || {
        let _lock = data_clone.lock().unwrap();
        println!("线程持有锁");
        thread::sleep(Duration::from_secs(2));
        println!("线程释放锁");
    });
    
    thread::sleep(Duration::from_millis(100));
    
    match data.try_lock() {
        Ok(_guard) => println!("主线程获得锁"),
        Err(_) => println!("主线程: 锁已被占用，不等待"),
    }
    
    handle.join().unwrap();
    
    println!("\n===== Mutex 中毒 =====\n");
    
    let data = Arc::new(Mutex::new(0));
    let data_clone = Arc::clone(&data);
    
    let handle = thread::spawn(move || {
        let mut lock = data_clone.lock().unwrap();
        *lock = 10;
        panic!("故意 panic!");
    });
    
    let _ = handle.join();
    
    match data.lock() {
        Ok(guard) => println!("获取锁成功: {}", *guard),
        Err(poisoned) => {
            println!("锁中毒！恢复数据...");
            let guard = poisoned.into_inner();
            println!("恢复的值: {}", *guard);
        }
    }
    
    println!("\n===== Mutex 保护复杂数据 =====\n");
    
    use std::collections::HashMap;
    
    let cache = Arc::new(Mutex::new(HashMap::new()));
    let mut handles = vec![];
    
    for i in 0..3 {
        let cache_clone = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            let mut map = cache_clone.lock().unwrap();
            map.insert(format!("key{}", i), i * 10);
            println!("线程 {} 插入数据", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let map = cache.lock().unwrap();
    println!("\n缓存内容:");
    for (key, value) in map.iter() {
        println!("  {} = {}", key, value);
    }
}
```

**说明**:

- **lock()**: 阻塞直到获取锁
- **try_lock()**: 非阻塞尝试获取锁
- **中毒**: panic 时锁会被标记为"中毒"
- **自动释放**: 作用域结束时自动释放锁

**输出**:

```text
===== Mutex 基础 =====

计数器: 1
最终值: 1

===== 多线程竞争 =====

线程 0 完成
线程 1 完成
...
线程 9 完成
最终计数: 1000
预期: 1000

===== try_lock 非阻塞 =====

线程持有锁
主线程: 锁已被占用，不等待
线程释放锁

===== Mutex 中毒 =====

锁中毒！恢复数据...
恢复的值: 10

===== Mutex 保护复杂数据 =====

线程 0 插入数据
线程 1 插入数据
线程 2 插入数据

缓存内容:
  key0 = 0
  key1 = 10
  key2 = 20
```

---

### 示例2.3: RwLock读写锁

**目标**: 理解读写锁的性能优势

**难度**: ⭐⭐

**代码**:

```rust
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== RwLock 基础 =====\n");
    
    let data = RwLock::new(5);
    
    {
        let r = data.read().unwrap();
        println!("读取: {}", *r);
    }
    
    {
        let mut w = data.write().unwrap();
        *w += 1;
        println!("写入: {}", *w);
    }
    
    println!("\n===== 多个读者 =====\n");
    
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let r = data_clone.read().unwrap();
            println!("读者 {}: {:?}", i, *r);
            thread::sleep(Duration::from_millis(100));
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n所有读者可以并发访问！");
    
    println!("\n===== 读写竞争 =====\n");
    
    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];
    
    // 10个读线程
    for i in 0..10 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..5 {
                let r = data_clone.read().unwrap();
                println!("读 {}: {}", i, *r);
                thread::sleep(Duration::from_millis(10));
            }
        });
        handles.push(handle);
    }
    
    // 2个写线程
    for i in 0..2 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for j in 0..3 {
                let mut w = data_clone.write().unwrap();
                *w += 1;
                println!("写 {}.{}: {}", i, j, *w);
                thread::sleep(Duration::from_millis(50));
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n最终值: {}", *data.read().unwrap());
    
    println!("\n===== try_read/try_write =====\n");
    
    let lock = Arc::new(RwLock::new(0));
    let lock_clone = Arc::clone(&lock);
    
    let handle = thread::spawn(move || {
        let _w = lock_clone.write().unwrap();
        println!("写锁持有中...");
        thread::sleep(Duration::from_secs(1));
    });
    
    thread::sleep(Duration::from_millis(100));
    
    match lock.try_read() {
        Ok(_) => println!("获取读锁成功"),
        Err(_) => println!("读锁被阻塞（有写锁）"),
    }
    
    match lock.try_write() {
        Ok(_) => println!("获取写锁成功"),
        Err(_) => println!("写锁被阻塞"),
    }
    
    handle.join().unwrap();
    
    println!("\n===== 升级读锁为写锁（错误示例）=====\n");
    
    let data = RwLock::new(0);
    
    {
        let _r = data.read().unwrap();
        println!("持有读锁");
        
        // 不能在持有读锁时获取写锁
        // let mut w = data.write().unwrap(); // 会死锁！
        println!("需要先释放读锁");
    }
    
    {
        let mut w = data.write().unwrap();
        *w = 42;
        println!("现在可以写入");
    }
}
```

**说明**:

- **read()**: 共享读锁，多个线程可同时读
- **write()**: 独占写锁，阻塞所有其他访问
- **性能**: 读多写少场景性能优于 Mutex
- **注意**: 不能将读锁升级为写锁

**输出**:

```text
===== RwLock 基础 =====

读取: 5
写入: 6

===== 多个读者 =====

读者 0: [1, 2, 3]
读者 1: [1, 2, 3]
读者 2: [1, 2, 3]
读者 3: [1, 2, 3]
读者 4: [1, 2, 3]

所有读者可以并发访问！

===== 读写竞争 =====

读 0: 0
读 1: 0
...
写 0.0: 1
写 0.1: 2
...
最终值: 6

===== try_read/try_write =====

写锁持有中...
读锁被阻塞（有写锁）
写锁被阻塞

===== 升级读锁为写锁（错误示例）=====

持有读锁
需要先释放读锁
现在可以写入
```

---

### 示例2.4: Condvar条件变量

**目标**: 理解条件变量的使用

**难度**: ⭐⭐⭐

**代码**:

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Condvar 基础 =====\n");
    
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);
    
    thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        thread::sleep(Duration::from_secs(1));
        
        let mut started = lock.lock().unwrap();
        *started = true;
        println!("通知: 条件已满足");
        cvar.notify_one();
    });
    
    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    
    while !*started {
        println!("等待条件...");
        started = cvar.wait(started).unwrap();
    }
    
    println!("条件满足，继续执行");
    
    println!("\n===== 生产者-消费者 =====\n");
    
    let data = Arc::new((Mutex::new(Vec::new()), Condvar::new()));
    
    // 生产者
    let data_clone = Arc::clone(&data);
    let producer = thread::spawn(move || {
        for i in 0..5 {
            thread::sleep(Duration::from_millis(500));
            let (lock, cvar) = &*data_clone;
            let mut queue = lock.lock().unwrap();
            queue.push(i);
            println!("生产: {}", i);
            cvar.notify_one();
        }
    });
    
    // 消费者
    let data_clone = Arc::clone(&data);
    let consumer = thread::spawn(move || {
        for _ in 0..5 {
            let (lock, cvar) = &*data_clone;
            let mut queue = lock.lock().unwrap();
            
            while queue.is_empty() {
                queue = cvar.wait(queue).unwrap();
            }
            
            let item = queue.remove(0);
            println!("消费: {}", item);
        }
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
    
    println!("\n===== wait_timeout 超时等待 =====\n");
    
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let (lock, cvar) = &*pair;
    
    let mut ready = lock.lock().unwrap();
    let timeout = Duration::from_secs(1);
    
    let result = cvar.wait_timeout(ready, timeout).unwrap();
    
    if result.1.timed_out() {
        println!("等待超时");
    } else {
        println!("条件满足");
    }
    
    println!("\n===== notify_all 通知所有 =====\n");
    
    let pair = Arc::new((Mutex::new(0), Condvar::new()));
    let mut handles = vec![];
    
    for i in 0..3 {
        let pair_clone = Arc::clone(&pair);
        let handle = thread::spawn(move || {
            let (lock, cvar) = &*pair_clone;
            let mut count = lock.lock().unwrap();
            
            while *count == 0 {
                println!("线程 {} 等待...", i);
                count = cvar.wait(count).unwrap();
            }
            
            println!("线程 {} 收到通知: {}", i, *count);
        });
        handles.push(handle);
    }
    
    thread::sleep(Duration::from_secs(1));
    
    let (lock, cvar) = &*pair;
    let mut count = lock.lock().unwrap();
    *count = 1;
    println!("\n通知所有线程");
    cvar.notify_all();
    drop(count);
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**说明**:

- **wait()**: 释放锁并等待通知
- **notify_one()**: 唤醒一个等待线程
- **notify_all()**: 唤醒所有等待线程
- **wait_timeout()**: 带超时的等待

**输出**:

```text
===== Condvar 基础 =====

等待条件...
通知: 条件已满足
条件满足，继续执行

===== 生产者-消费者 =====

生产: 0
消费: 0
生产: 1
消费: 1
生产: 2
消费: 2
生产: 3
消费: 3
生产: 4
消费: 4

===== wait_timeout 超时等待 =====

等待超时

===== notify_all 通知所有 =====

线程 0 等待...
线程 1 等待...
线程 2 等待...

通知所有线程
线程 0 收到通知: 1
线程 1 收到通知: 1
线程 2 收到通知: 1
```

---

### 示例2.5: Channel通道

**目标**: 掌握消息传递并发模式

**难度**: ⭐⭐

**代码**:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Channel 基础 =====\n");
    
    let (tx, rx) = mpsc::channel();
    
    thread::spawn(move || {
        tx.send("Hello from thread").unwrap();
    });
    
    let message = rx.recv().unwrap();
    println!("收到: {}", message);
    
    println!("\n===== 多个消息 =====\n");
    
    let (tx, rx) = mpsc::channel();
    
    thread::spawn(move || {
        let messages = vec!["hi", "from", "the", "thread"];
        
        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    for received in rx {
        println!("收到: {}", received);
    }
    
    println!("\n===== 多个生产者 =====\n");
    
    let (tx, rx) = mpsc::channel();
    
    for i in 0..3 {
        let tx_clone = tx.clone();
        thread::spawn(move || {
            for j in 0..3 {
                tx_clone.send(format!("线程 {} 消息 {}", i, j)).unwrap();
                thread::sleep(Duration::from_millis(100));
            }
        });
    }
    
    drop(tx); // 释放原始发送者
    
    for received in rx {
        println!("收到: {}", received);
    }
    
    println!("\n===== try_recv 非阻塞 =====\n");
    
    let (tx, rx) = mpsc::channel();
    
    match rx.try_recv() {
        Ok(msg) => println!("收到: {}", msg),
        Err(mpsc::TryRecvError::Empty) => println!("通道为空"),
        Err(mpsc::TryRecvError::Disconnected) => println!("通道已断开"),
    }
    
    tx.send("message").unwrap();
    
    match rx.try_recv() {
        Ok(msg) => println!("收到: {}", msg),
        Err(_) => println!("通道为空"),
    }
    
    println!("\n===== recv_timeout 超时 =====\n");
    
    let (tx, rx) = mpsc::channel::<String>();
    
    let handle = thread::spawn(move || {
        thread::sleep(Duration::from_secs(2));
        tx.send("delayed message".to_string()).unwrap();
    });
    
    println!("等待消息（1秒超时）...");
    match rx.recv_timeout(Duration::from_secs(1)) {
        Ok(msg) => println!("收到: {}", msg),
        Err(_) => println!("超时"),
    }
    
    println!("等待消息（3秒超时）...");
    match rx.recv_timeout(Duration::from_secs(3)) {
        Ok(msg) => println!("收到: {}", msg),
        Err(_) => println!("超时"),
    }
    
    handle.join().unwrap();
    
    println!("\n===== 同步通道 =====\n");
    
    let (tx, rx) = mpsc::sync_channel(1);
    
    let handle = thread::spawn(move || {
        println!("发送 1...");
        tx.send(1).unwrap();
        println!("发送 2... (会阻塞)");
        tx.send(2).unwrap();
        println!("发送完成");
    });
    
    thread::sleep(Duration::from_secs(1));
    println!("接收: {}", rx.recv().unwrap());
    thread::sleep(Duration::from_secs(1));
    println!("接收: {}", rx.recv().unwrap());
    
    handle.join().unwrap();
}
```

**说明**:

- **mpsc**: 多生产者单消费者
- **send/recv**: 发送和接收消息
- **try_recv**: 非阻塞接收
- **sync_channel**: 有界通道，满时阻塞

**输出**:

```text
===== Channel 基础 =====

收到: Hello from thread

===== 多个消息 =====

收到: hi
收到: from
收到: the
收到: thread

===== 多个生产者 =====

收到: 线程 0 消息 0
收到: 线程 1 消息 0
收到: 线程 2 消息 0
...

===== try_recv 非阻塞 =====

通道为空
收到: message

===== recv_timeout 超时 =====

等待消息（1秒超时）...
超时
等待消息（3秒超时）...
收到: delayed message

===== 同步通道 =====

发送 1...
发送 2... (会阻塞)
接收: 1
发送完成
接收: 2
```

---

### 示例2.6: Atomic原子操作

**目标**: 理解无锁并发的基础

**难度**: ⭐⭐⭐

**代码**:

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Atomic 基础 =====\n");
    
    let counter = AtomicUsize::new(0);
    
    counter.store(5, Ordering::Relaxed);
    println!("存储后: {}", counter.load(Ordering::Relaxed));
    
    let old = counter.fetch_add(3, Ordering::Relaxed);
    println!("旧值: {}, 新值: {}", old, counter.load(Ordering::Relaxed));
    
    println!("\n===== 多线程计数 =====\n");
    
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter_clone.fetch_add(1, Ordering::Relaxed);
            }
            println!("线程 {} 完成", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", counter.load(Ordering::Relaxed));
    println!("预期: 10000");
    
    println!("\n===== 原子标志 =====\n");
    
    let flag = Arc::new(AtomicBool::new(false));
    let flag_clone = Arc::clone(&flag);
    
    let handle = thread::spawn(move || {
        println!("工作线程开始...");
        thread::sleep(Duration::from_secs(2));
        flag_clone.store(true, Ordering::Relaxed);
        println!("工作线程完成");
    });
    
    println!("主线程等待...");
    while !flag.load(Ordering::Relaxed) {
        thread::sleep(Duration::from_millis(100));
    }
    println!("主线程检测到完成");
    
    handle.join().unwrap();
    
    println!("\n===== compare_exchange =====\n");
    
    let value = AtomicUsize::new(10);
    
    let result = value.compare_exchange(
        10,  // 期望值
        20,  // 新值
        Ordering::Relaxed,
        Ordering::Relaxed
    );
    
    match result {
        Ok(old) => println!("交换成功: {} -> {}", old, value.load(Ordering::Relaxed)),
        Err(current) => println!("交换失败，当前值: {}", current),
    }
    
    let result = value.compare_exchange(
        10,  // 期望值错误
        30,  // 新值
        Ordering::Relaxed,
        Ordering::Relaxed
    );
    
    match result {
        Ok(_) => println!("交换成功"),
        Err(current) => println!("交换失败，当前值: {}", current),
    }
    
    println!("\n===== 自旋锁实现 =====\n");
    
    struct SpinLock {
        locked: AtomicBool,
    }
    
    impl SpinLock {
        fn new() -> Self {
            SpinLock {
                locked: AtomicBool::new(false),
            }
        }
        
        fn lock(&self) {
            while self.locked.compare_exchange(
                false,
                true,
                Ordering::Acquire,
                Ordering::Relaxed
            ).is_err() {
                // 自旋等待
                std::hint::spin_loop();
            }
        }
        
        fn unlock(&self) {
            self.locked.store(false, Ordering::Release);
        }
    }
    
    let lock = Arc::new(SpinLock::new());
    let mut handles = vec![];
    
    for i in 0..3 {
        let lock_clone = Arc::clone(&lock);
        let handle = thread::spawn(move || {
            lock_clone.lock();
            println!("线程 {} 获得锁", i);
            thread::sleep(Duration::from_millis(100));
            lock_clone.unlock();
            println!("线程 {} 释放锁", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n===== 内存顺序对比 =====\n");
    
    println!("Relaxed: 最弱的顺序，只保证原子性");
    println!("Acquire/Release: 建立happens-before关系");
    println!("SeqCst: 最强的顺序，全局一致性");
}
```

**说明**:

- **原子类型**: AtomicBool, AtomicUsize等
- **fetch_***: 读-修改-写操作
- **compare_exchange**: CAS操作
- **Ordering**: 内存顺序控制

**输出**:

```text
===== Atomic 基础 =====

存储后: 5
旧值: 5, 新值: 8

===== 多线程计数 =====

线程 0 完成
线程 1 完成
...
线程 9 完成
最终计数: 10000
预期: 10000

===== 原子标志 =====

主线程等待...
工作线程开始...
工作线程完成
主线程检测到完成

===== compare_exchange =====

交换成功: 10 -> 20
交换失败，当前值: 20

===== 自旋锁实现 =====

线程 0 获得锁
线程 0 释放锁
线程 1 获得锁
线程 1 释放锁
线程 2 获得锁
线程 2 释放锁

===== 内存顺序对比 =====

Relaxed: 最弱的顺序，只保证原子性
Acquire/Release: 建立happens-before关系
SeqCst: 最强的顺序，全局一致性
```

---

## 🚀 Tier 3: 高级层示例

### 示例3.1: 线程池实现

**目标**: 实现一个简单的线程池

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
use std::thread;
use std::sync::{Arc, Mutex, mpsc};
use std::time::Duration;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        
        let mut workers = Vec::with_capacity(size);
        
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }
        
        ThreadPool { workers, sender }
    }
    
    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Self {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();
            
            match job {
                Ok(job) => {
                    println!("Worker {} 执行任务", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} 断开连接", id);
                    break;
                }
            }
        });
        
        Worker { id, thread }
    }
}

fn main() {
    println!("===== 线程池基础 =====\n");
    
    let pool = ThreadPool::new(4);
    
    for i in 0..10 {
        pool.execute(move || {
            println!("任务 {} 开始", i);
            thread::sleep(Duration::from_millis(100));
            println!("任务 {} 完成", i);
        });
    }
    
    thread::sleep(Duration::from_secs(2));
    
    println!("\n===== 带返回值的任务 =====\n");
    
    use std::sync::mpsc;
    
    let pool = ThreadPool::new(2);
    let (result_tx, result_rx) = mpsc::channel();
    
    for i in 0..5 {
        let tx = result_tx.clone();
        pool.execute(move || {
            let result = i * 2;
            tx.send((i, result)).unwrap();
        });
    }
    
    drop(result_tx);
    
    while let Ok((input, output)) = result_rx.recv() {
        println!("{} * 2 = {}", input, output);
    }
}
```

**说明**:

- **线程池**: 预创建线程，复用执行任务
- **任务队列**: 使用Channel传递任务
- **Worker**: 工作线程，循环获取任务

**输出**:

```text
===== 线程池基础 =====

Worker 0 执行任务
任务 0 开始
Worker 1 执行任务
任务 1 开始
Worker 2 执行任务
任务 2 开始
Worker 3 执行任务
任务 3 开始
任务 0 完成
Worker 0 执行任务
任务 4 开始
...

===== 带返回值的任务 =====

0 * 2 = 0
1 * 2 = 2
2 * 2 = 4
3 * 2 = 6
4 * 2 = 8
```

---

### 示例3.2: 工作窃取

**目标**: 实现工作窃取调度

**难度**: ⭐⭐⭐⭐⭐

**代码**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;
use std::time::Duration;

struct WorkStealingQueue<T> {
    local: VecDeque<T>,
    shared: Arc<Mutex<VecDeque<T>>>,
}

impl<T> WorkStealingQueue<T> {
    fn new() -> (Self, WorkStealer<T>) {
        let shared = Arc::new(Mutex::new(VecDeque::new()));
        let queue = WorkStealingQueue {
            local: VecDeque::new(),
            shared: Arc::clone(&shared),
        };
        let stealer = WorkStealer { shared };
        (queue, stealer)
    }
    
    fn push(&mut self, item: T) {
        self.local.push_back(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.local.pop_front().or_else(|| {
            self.shared.lock().unwrap().pop_front()
        })
    }
    
    fn publish(&mut self) {
        if !self.local.is_empty() {
            let mut shared = self.shared.lock().unwrap();
            shared.append(&mut self.local);
        }
    }
}

struct WorkStealer<T> {
    shared: Arc<Mutex<VecDeque<T>>>,
}

impl<T> WorkStealer<T> {
    fn steal(&self) -> Option<T> {
        self.shared.lock().unwrap().pop_back()
    }
}

impl<T> Clone for WorkStealer<T> {
    fn clone(&self) -> Self {
        WorkStealer {
            shared: Arc::clone(&self.shared),
        }
    }
}

fn main() {
    println!("===== 工作窃取示例 =====\n");
    
    let (mut queue, stealer) = WorkStealingQueue::new();
    
    // 添加任务到本地队列
    for i in 0..10 {
        queue.push(i);
    }
    
    println!("本地队列有 10 个任务");
    
    // 发布部分到共享队列
    queue.publish();
    
    // 其他线程窃取任务
    let stealer_clone = stealer.clone();
    let handle = thread::spawn(move || {
        let mut stolen = 0;
        while let Some(task) = stealer_clone.steal() {
            println!("窃取线程执行任务: {}", task);
            stolen += 1;
            thread::sleep(Duration::from_millis(50));
        }
        println!("窃取线程完成，处理了 {} 个任务", stolen);
    });
    
    // 主线程处理本地任务
    let mut processed = 0;
    while let Some(task) = queue.pop() {
        println!("主线程执行任务: {}", task);
        processed += 1;
        thread::sleep(Duration::from_millis(50));
    }
    
    handle.join().unwrap();
    println!("\n主线程处理了 {} 个任务", processed);
    
    println!("\n===== 多工作线程窃取 =====\n");
    
    let (mut main_queue, main_stealer) = WorkStealingQueue::new();
    
    // 添加大量任务
    for i in 0..20 {
        main_queue.push(i);
    }
    main_queue.publish();
    
    // 启动多个窃取线程
    let mut handles = vec![];
    
    for id in 0..3 {
        let stealer = main_stealer.clone();
        let handle = thread::spawn(move || {
            let mut count = 0;
            while let Some(task) = stealer.steal() {
                println!("Worker {} 执行: {}", id, task);
                count += 1;
                thread::sleep(Duration::from_millis(30));
            }
            println!("Worker {} 完成，处理 {} 个任务", id, count);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**说明**:

- **本地队列**: 每个线程自己的队列
- **工作窃取**: 空闲线程从其他线程窃取任务
- **负载均衡**: 自动平衡工作负载

**输出**:

```text
===== 工作窃取示例 =====

本地队列有 10 个任务
主线程执行任务: 0
窃取线程执行任务: 9
主线程执行任务: 1
窃取线程执行任务: 8
...

===== 多工作线程窃取 =====

Worker 0 执行: 19
Worker 1 执行: 18
Worker 2 执行: 17
...
```

---

### 示例3.3: 并发数据结构

**目标**: 实现线程安全的数据结构

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// 并发栈
struct ConcurrentStack<T> {
    data: Arc<Mutex<Vec<T>>>,
}

impl<T> ConcurrentStack<T> {
    fn new() -> Self {
        ConcurrentStack {
            data: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    fn push(&self, item: T) {
        self.data.lock().unwrap().push(item);
    }
    
    fn pop(&self) -> Option<T> {
        self.data.lock().unwrap().pop()
    }
    
    fn len(&self) -> usize {
        self.data.lock().unwrap().len()
    }
}

impl<T> Clone for ConcurrentStack<T> {
    fn clone(&self) -> Self {
        ConcurrentStack {
            data: Arc::clone(&self.data),
        }
    }
}

// 并发队列
use std::collections::VecDeque;

struct ConcurrentQueue<T> {
    data: Arc<Mutex<VecDeque<T>>>,
}

impl<T> ConcurrentQueue<T> {
    fn new() -> Self {
        ConcurrentQueue {
            data: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    fn enqueue(&self, item: T) {
        self.data.lock().unwrap().push_back(item);
    }
    
    fn dequeue(&self) -> Option<T> {
        self.data.lock().unwrap().pop_front()
    }
}

impl<T> Clone for ConcurrentQueue<T> {
    fn clone(&self) -> Self {
        ConcurrentQueue {
            data: Arc::clone(&self.data),
        }
    }
}

// 并发哈希表
use std::collections::HashMap;
use std::hash::Hash;

struct ConcurrentHashMap<K, V> {
    data: Arc<Mutex<HashMap<K, V>>>,
}

impl<K: Eq + Hash, V> ConcurrentHashMap<K, V> {
    fn new() -> Self {
        ConcurrentHashMap {
            data: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn insert(&self, key: K, value: V) -> Option<V> {
        self.data.lock().unwrap().insert(key, value)
    }
    
    fn get(&self, key: &K) -> Option<V>
    where
        V: Clone,
    {
        self.data.lock().unwrap().get(key).cloned()
    }
    
    fn remove(&self, key: &K) -> Option<V> {
        self.data.lock().unwrap().remove(key)
    }
}

impl<K, V> Clone for ConcurrentHashMap<K, V> {
    fn clone(&self) -> Self {
        ConcurrentHashMap {
            data: Arc::clone(&self.data),
        }
    }
}

fn main() {
    println!("===== 并发栈 =====\n");
    
    let stack = ConcurrentStack::new();
    let mut handles = vec![];
    
    for i in 0..5 {
        let stack_clone = stack.clone();
        let handle = thread::spawn(move || {
            for j in 0..3 {
                stack_clone.push(i * 10 + j);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("栈大小: {}", stack.len());
    
    while let Some(item) = stack.pop() {
        println!("弹出: {}", item);
    }
    
    println!("\n===== 并发队列 =====\n");
    
    let queue = ConcurrentQueue::new();
    
    // 生产者
    let mut handles = vec![];
    for i in 0..3 {
        let queue_clone = queue.clone();
        let handle = thread::spawn(move || {
            for j in 0..5 {
                queue_clone.enqueue(format!("P{}-{}", i, j));
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 消费者
    let mut handles = vec![];
    for i in 0..2 {
        let queue_clone = queue.clone();
        let handle = thread::spawn(move || {
            for _ in 0..5 {
                if let Some(item) = queue_clone.dequeue() {
                    println!("Consumer {} 取出: {}", i, item);
                }
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n===== 并发哈希表 =====\n");
    
    let map = ConcurrentHashMap::new();
    
    // 并发插入
    let mut handles = vec![];
    for i in 0..5 {
        let map_clone = map.clone();
        let handle = thread::spawn(move || {
            map_clone.insert(i, i * 10);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 并发读取
    let mut handles = vec![];
    for i in 0..5 {
        let map_clone = map.clone();
        let handle = thread::spawn(move || {
            if let Some(value) = map_clone.get(&i) {
                println!("键 {} = {}", i, value);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**说明**:

- **并发栈**: 线程安全的栈
- **并发队列**: FIFO队列
- **并发哈希表**: 线程安全的键值存储

**输出**:

```text
===== 并发栈 =====

栈大小: 15
弹出: 42
弹出: 41
弹出: 40
...

===== 并发队列 =====

Consumer 0 取出: P0-0
Consumer 1 取出: P0-1
Consumer 0 取出: P0-2
...

===== 并发哈希表 =====

键 0 = 0
键 1 = 10
键 2 = 20
键 3 = 30
键 4 = 40
```

---

### 示例3.4: 无锁编程

**目标**: 使用原子操作实现无锁数据结构

**难度**: ⭐⭐⭐⭐⭐

**代码**:

```rust
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};
use std::ptr;
use std::thread;

// 无锁栈
struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

impl<T> LockFreeStack<T> {
    fn new() -> Self {
        LockFreeStack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe {
                (*new_node).next = head;
            }
            
            if self.head.compare_exchange(
                head,
                new_node,
                Ordering::Release,
                Ordering::Acquire
            ).is_ok() {
                break;
            }
        }
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            
            if head.is_null() {
                return None;
            }
            
            unsafe {
                let next = (*head).next;
                
                if self.head.compare_exchange(
                    head,
                    next,
                    Ordering::Release,
                    Ordering::Acquire
                ).is_ok() {
                    let data = ptr::read(&(*head).data);
                    drop(Box::from_raw(head));
                    return Some(data);
                }
            }
        }
    }
}

impl<T> Drop for LockFreeStack<T> {
    fn drop(&mut self) {
        while self.pop().is_some() {}
    }
}

fn main() {
    println!("===== 无锁栈 =====\n");
    
    let stack = LockFreeStack::new();
    let mut handles = vec![];
    
    // 并发push
    for i in 0..10 {
        let stack_ref = unsafe { &*(&stack as *const _) };
        let handle = thread::spawn(move || {
            for j in 0..10 {
                stack_ref.push(i * 10 + j);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 并发pop
    let mut handles = vec![];
    for i in 0..5 {
        let stack_ref = unsafe { &*(&stack as *const _) };
        let handle = thread::spawn(move || {
            let mut count = 0;
            while let Some(_) = stack_ref.pop() {
                count += 1;
            }
            println!("线程 {} 弹出 {} 个元素", i, count);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("\n===== ABA问题示例 =====\n");
    
    println!("ABA问题: 值从A变为B再变回A");
    println!("CAS操作会认为没有变化");
    println!("解决方案: 使用版本号或标记指针");
    
    struct TaggedPtr<T> {
        ptr: AtomicUsize,
        _marker: std::marker::PhantomData<T>,
    }
    
    impl<T> TaggedPtr<T> {
        fn new() -> Self {
            TaggedPtr {
                ptr: AtomicUsize::new(0),
                _marker: std::marker::PhantomData,
            }
        }
        
        fn load(&self) -> (usize, usize) {
            let val = self.ptr.load(Ordering::Acquire);
            let ptr = val & !0xFF;
            let tag = val & 0xFF;
            (ptr, tag)
        }
        
        fn store(&self, ptr: usize, tag: usize) {
            let val = ptr | (tag & 0xFF);
            self.ptr.store(val, Ordering::Release);
        }
    }
    
    let tagged = TaggedPtr::<i32>::new();
    tagged.store(0x1000, 1);
    
    let (ptr, tag) = tagged.load();
    println!("指针: 0x{:X}, 标记: {}", ptr, tag);
}
```

**说明**:

- **无锁**: 使用CAS操作代替锁
- **ABA问题**: 需要版本号解决
- **内存管理**: 需要小心处理内存安全

**输出**:

```text
===== 无锁栈 =====

线程 0 弹出 20 个元素
线程 1 弹出 20 个元素
线程 2 弹出 20 个元素
线程 3 弹出 20 个元素
线程 4 弹出 20 个元素

===== ABA问题示例 =====

ABA问题: 值从A变为B再变回A
CAS操作会认为没有变化
解决方案: 使用版本号或标记指针
指针: 0x1000, 标记: 1
```

---

### 示例3.5: 内存顺序

**目标**: 理解不同的内存顺序

**难度**: ⭐⭐⭐⭐⭐

**代码**:

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Relaxed 顺序 =====\n");
    
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Relaxed计数: {}", counter.load(Ordering::Relaxed));
    println!("保证原子性，不保证顺序\n");
    
    println!("===== Acquire-Release =====\n");
    
    let data = Arc::new(AtomicUsize::new(0));
    let flag = Arc::new(AtomicBool::new(false));
    
    let data_clone = Arc::clone(&data);
    let flag_clone = Arc::clone(&flag);
    
    let writer = thread::spawn(move || {
        data_clone.store(42, Ordering::Relaxed);
        flag_clone.store(true, Ordering::Release);
        println!("写入完成");
    });
    
    let reader = thread::spawn(move || {
        while !flag.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let value = data.load(Ordering::Relaxed);
        println!("读取到: {}", value);
    });
    
    writer.join().unwrap();
    reader.join().unwrap();
    
    println!("Acquire-Release 建立 happens-before 关系\n");
    
    println!("===== SeqCst 顺序 =====\n");
    
    let x = Arc::new(AtomicBool::new(false));
    let y = Arc::new(AtomicBool::new(false));
    let z = Arc::new(AtomicUsize::new(0));
    
    let x1 = Arc::clone(&x);
    let y1 = Arc::clone(&y);
    let z1 = Arc::clone(&z);
    
    let t1 = thread::spawn(move || {
        x1.store(true, Ordering::SeqCst);
    });
    
    let x2 = Arc::clone(&x);
    let y2 = Arc::clone(&y);
    let z2 = Arc::clone(&z);
    
    let t2 = thread::spawn(move || {
        y2.store(true, Ordering::SeqCst);
    });
    
    let x3 = Arc::clone(&x);
    let y3 = Arc::clone(&y);
    let z3 = Arc::clone(&z);
    
    let t3 = thread::spawn(move || {
        while !x3.load(Ordering::SeqCst) {}
        if y3.load(Ordering::SeqCst) {
            z3.fetch_add(1, Ordering::SeqCst);
        }
    });
    
    let t4 = thread::spawn(move || {
        while !y.load(Ordering::SeqCst) {}
        if x.load(Ordering::SeqCst) {
            z.fetch_add(1, Ordering::SeqCst);
        }
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
    t3.join().unwrap();
    t4.join().unwrap();
    
    let count = z1.load(Ordering::SeqCst);
    println!("SeqCst 计数: {}", count);
    println!("保证全局一致的顺序\n");
    
    println!("===== Fence 屏障 =====\n");
    
    use std::sync::atomic::fence;
    
    let data = Arc::new(AtomicUsize::new(0));
    let ready = Arc::new(AtomicBool::new(false));
    
    let data_clone = Arc::clone(&data);
    let ready_clone = Arc::clone(&ready);
    
    thread::spawn(move || {
        data_clone.store(100, Ordering::Relaxed);
        fence(Ordering::Release);
        ready_clone.store(true, Ordering::Relaxed);
    });
    
    thread::sleep(Duration::from_millis(10));
    
    while !ready.load(Ordering::Relaxed) {
        thread::yield_now();
    }
    fence(Ordering::Acquire);
    let value = data.load(Ordering::Relaxed);
    
    println!("通过fence读取: {}", value);
    
    println!("\n===== 内存顺序对比 =====\n");
    
    println!("| 顺序 | 保证 | 性能 | 使用场景 |");
    println!("|------|------|------|----------|");
    println!("| Relaxed | 原子性 | 最快 | 计数器 |");
    println!("| Acquire | 同步读 | 快 | 读取标志 |");
    println!("| Release | 同步写 | 快 | 设置标志 |");
    println!("| AcqRel | 读写同步 | 中 | RMW操作 |");
    println!("| SeqCst | 全局顺序 | 慢 | 复杂同步 |");
}
```

**说明**:

- **Relaxed**: 只保证原子性
- **Acquire/Release**: 建立happens-before
- **SeqCst**: 全局一致顺序
- **Fence**: 显式内存屏障

**输出**:

```text
===== Relaxed 顺序 =====

Relaxed计数: 1000
保证原子性，不保证顺序

===== Acquire-Release =====

写入完成
读取到: 42
Acquire-Release 建立 happens-before 关系

===== SeqCst 顺序 =====

SeqCst 计数: 1
保证全局一致的顺序

===== Fence 屏障 =====

通过fence读取: 100

===== 内存顺序对比 =====

| 顺序 | 保证 | 性能 | 使用场景 |
|------|------|------|----------|
| Relaxed | 原子性 | 最快 | 计数器 |
| Acquire | 同步读 | 快 | 读取标志 |
| Release | 同步写 | 快 | 设置标志 |
| AcqRel | 读写同步 | 中 | RMW操作 |
| SeqCst | 全局顺序 | 慢 | 复杂同步 |
```

---

### 示例3.6: 性能分析

**目标**: 分析并发程序的性能

**难度**: ⭐⭐⭐⭐

**代码**:

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    println!("===== Mutex vs RwLock vs Atomic =====\n");
    
    const THREADS: usize = 8;
    const ITERATIONS: usize = 100_000;
    
    // Mutex 性能测试
    let mutex_counter = Arc::new(Mutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&mutex_counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.lock().unwrap() += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let mutex_time = start.elapsed();
    println!("Mutex: {:?}", mutex_time);
    
    // RwLock 性能测试（写密集）
    let rwlock_counter = Arc::new(RwLock::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&rwlock_counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.write().unwrap() += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let rwlock_time = start.elapsed();
    println!("RwLock (write): {:?}", rwlock_time);
    
    // Atomic 性能测试
    let atomic_counter = Arc::new(AtomicUsize::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&atomic_counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let atomic_time = start.elapsed();
    println!("Atomic: {:?}", atomic_time);
    
    println!("\n相对性能:");
    println!("  Atomic: 1.0x (fastest)");
    println!("  Mutex: {:.2}x", mutex_time.as_secs_f64() / atomic_time.as_secs_f64());
    println!("  RwLock: {:.2}x", rwlock_time.as_secs_f64() / atomic_time.as_secs_f64());
    
    println!("\n===== RwLock 读多写少 =====\n");
    
    let rwlock_data = Arc::new(RwLock::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    
    // 7个读线程
    for _ in 0..7 {
        let data = Arc::clone(&rwlock_data);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                let _ = *data.read().unwrap();
            }
        });
        handles.push(handle);
    }
    
    // 1个写线程
    let data = Arc::clone(&rwlock_data);
    let handle = thread::spawn(move || {
        for _ in 0..ITERATIONS {
            *data.write().unwrap() += 1;
        }
    });
    handles.push(handle);
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let rwlock_read_time = start.elapsed();
    println!("RwLock (read-heavy): {:?}", rwlock_read_time);
    
    println!("\n===== 线程数量影响 =====\n");
    
    for num_threads in [1, 2, 4, 8, 16] {
        let counter = Arc::new(AtomicUsize::new(0));
        let start = Instant::now();
        
        let mut handles = vec![];
        for _ in 0..num_threads {
            let counter = Arc::clone(&counter);
            let handle = thread::spawn(move || {
                for _ in 0..ITERATIONS {
                    counter.fetch_add(1, Ordering::Relaxed);
                }
            });
            handles.push(handle);
        }
        
        for handle in handles {
            handle.join().unwrap();
        }
        
        let elapsed = start.elapsed();
        let ops_per_sec = (num_threads * ITERATIONS) as f64 / elapsed.as_secs_f64();
        
        println!("{:2} 线程: {:?} ({:.0} ops/sec)", 
                 num_threads, elapsed, ops_per_sec);
    }
    
    println!("\n===== 锁竞争分析 =====\n");
    
    let counter = Arc::new(Mutex::new(0));
    
    // 低竞争
    let start = Instant::now();
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.lock().unwrap() += 1;
                thread::yield_now(); // 降低竞争
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    let low_contention = start.elapsed();
    
    // 高竞争
    let counter = Arc::new(Mutex::new(0));
    let start = Instant::now();
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.lock().unwrap() += 1;
                // 不yield，高竞争
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    let high_contention = start.elapsed();
    
    println!("低竞争: {:?}", low_contention);
    println!("高竞争: {:?}", high_contention);
    println!("竞争影响: {:.2}x", high_contention.as_secs_f64() / low_contention.as_secs_f64());
}
```

**说明**:

- **性能对比**: Atomic > Mutex > RwLock(write)
- **读多写少**: RwLock 优势明显
- **锁竞争**: 严重影响性能
- **线程扩展**: 观察并行效率

**输出**:

```text
===== Mutex vs RwLock vs Atomic =====

Mutex: 523ms
RwLock (write): 687ms
Atomic: 145ms

相对性能:
  Atomic: 1.0x (fastest)
  Mutex: 3.61x
  RwLock: 4.74x

===== RwLock 读多写少 =====

RwLock (read-heavy): 234ms

===== 线程数量影响 =====

 1 线程: 18ms (5555555 ops/sec)
 2 线程: 45ms (4444444 ops/sec)
 4 线程: 120ms (3333333 ops/sec)
 8 线程: 145ms (5517241 ops/sec)
16 线程: 178ms (8988764 ops/sec)

===== 锁竞争分析 =====

低竞争: 1234ms
高竞争: 523ms
竞争影响: 0.42x
```

---

## 📝 总结

### 学习路径建议

1. **第一阶段** (Tier 1): 掌握基础 (示例 1.1-1.6)
   - 线程创建和管理
   - move 语义
   - panic 处理
   - Send 和 Sync

2. **第二阶段** (Tier 2): 实践应用 (示例 2.1-2.6)
   - Arc 共享所有权
   - Mutex 互斥锁
   - RwLock 读写锁
   - Condvar 条件变量
   - Channel 消息传递
   - Atomic 原子操作

3. **第三阶段** (Tier 3): 深入理解 (示例 3.1-3.6)
   - 线程池实现
   - 工作窃取
   - 并发数据结构
   - 无锁编程
   - 内存顺序
   - 性能分析

### 核心概念总结

| 概念 | 相关示例 | 重要性 | 难度 |
|------|---------|--------|------|
| 线程创建 | 1.1 | ⭐⭐⭐⭐⭐ | ⭐ |
| move语义 | 1.2 | ⭐⭐⭐⭐⭐ | ⭐ |
| Send/Sync | 1.5 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| Arc | 2.1 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| Mutex | 2.2 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| Channel | 2.4 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| Atomic | 3.1 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

### 最佳实践

1. **选择并发模式**:
   - 共享状态：Arc + Mutex/RwLock
   - 消息传递：Channel
   - 并行计算：Rayon

2. **避免死锁**:
   - 按固定顺序获取锁
   - 使用 try_lock
   - 限制锁的作用域

3. **性能优化**:
   - 读多写少：使用 RwLock
   - 简单计数：使用 Atomic
   - CPU密集：使用线程池

4. **错误处理**:
   - join 检查 panic
   - Channel 检查断开
   - 使用 Result 传递错误

### 下一步

- 📖 深入学习: [同步原语实践](./02_同步原语实践.md)
- 📖 深入学习: [消息传递模式](./03_消息传递模式.md)
- 🚀 实战项目: [C05 实战项目集](./07_实战项目集.md) (即将创建)
- 📚 参考文档: [tier_03_references](../tier_03_references/)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-25  
**维护状态**: 活跃维护

**💡 并发编程是 Rust 的核心优势，类型系统保证线程安全！🦀**-
