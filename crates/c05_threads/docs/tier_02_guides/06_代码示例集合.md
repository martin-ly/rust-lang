# ğŸ§µ C05: çº¿ç¨‹ç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C05 çº¿ç¨‹ç¼–ç¨‹
> **ç›®æ ‡**: é€šè¿‡ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å­¦ä¹ è€…æ·±å…¥ç†è§£ Rust å¹¶å‘ç¼–ç¨‹å’Œçº¿ç¨‹å®‰å…¨ã€‚

---

## ç›®å½•

- [ğŸ§µ C05: çº¿ç¨‹ç¼–ç¨‹ - ä»£ç ç¤ºä¾‹é›†åˆ](#-c05-çº¿ç¨‹ç¼–ç¨‹---ä»£ç ç¤ºä¾‹é›†åˆ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
  - [ğŸ¯ ç¤ºä¾‹å¯¼èˆª](#-ç¤ºä¾‹å¯¼èˆª)
  - [ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹](#-tier-1-åŸºç¡€å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹1.1: çº¿ç¨‹åˆ›å»ºå’Œjoin](#ç¤ºä¾‹11-çº¿ç¨‹åˆ›å»ºå’Œjoin)
    - [ç¤ºä¾‹1.2: çº¿ç¨‹é—­åŒ…å’Œmove](#ç¤ºä¾‹12-çº¿ç¨‹é—­åŒ…å’Œmove)
    - [ç¤ºä¾‹1.3: çº¿ç¨‹panicå¤„ç†](#ç¤ºä¾‹13-çº¿ç¨‹panicå¤„ç†)
    - [ç¤ºä¾‹1.4: çº¿ç¨‹ä¼‘çœ å’Œyield](#ç¤ºä¾‹14-çº¿ç¨‹ä¼‘çœ å’Œyield)
    - [ç¤ºä¾‹1.5: Sendå’ŒSync trait](#ç¤ºä¾‹15-sendå’Œsync-trait)
    - [ç¤ºä¾‹1.6: çº¿ç¨‹å±€éƒ¨å­˜å‚¨](#ç¤ºä¾‹16-çº¿ç¨‹å±€éƒ¨å­˜å‚¨)
  - [ğŸ“ Tier 2: å®è·µå±‚ç¤ºä¾‹](#-tier-2-å®è·µå±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹2.1: Arcå…±äº«æ‰€æœ‰æƒ](#ç¤ºä¾‹21-arcå…±äº«æ‰€æœ‰æƒ)
    - [ç¤ºä¾‹2.2: Mutexäº’æ–¥é”](#ç¤ºä¾‹22-mutexäº’æ–¥é”)
    - [ç¤ºä¾‹2.3: RwLockè¯»å†™é”](#ç¤ºä¾‹23-rwlockè¯»å†™é”)
    - [ç¤ºä¾‹2.4: Condvaræ¡ä»¶å˜é‡](#ç¤ºä¾‹24-condvaræ¡ä»¶å˜é‡)
    - [ç¤ºä¾‹2.5: Channelé€šé“](#ç¤ºä¾‹25-channelé€šé“)
    - [ç¤ºä¾‹2.6: AtomicåŸå­æ“ä½œ](#ç¤ºä¾‹26-atomicåŸå­æ“ä½œ)
  - [ğŸš€ Tier 3: é«˜çº§å±‚ç¤ºä¾‹](#-tier-3-é«˜çº§å±‚ç¤ºä¾‹)
    - [ç¤ºä¾‹3.1: çº¿ç¨‹æ± å®ç°](#ç¤ºä¾‹31-çº¿ç¨‹æ± å®ç°)
    - [ç¤ºä¾‹3.2: å·¥ä½œçªƒå–](#ç¤ºä¾‹32-å·¥ä½œçªƒå–)
    - [ç¤ºä¾‹3.3: å¹¶å‘æ•°æ®ç»“æ„](#ç¤ºä¾‹33-å¹¶å‘æ•°æ®ç»“æ„)
    - [ç¤ºä¾‹3.4: æ— é”ç¼–ç¨‹](#ç¤ºä¾‹34-æ— é”ç¼–ç¨‹)
    - [ç¤ºä¾‹3.5: å†…å­˜é¡ºåº](#ç¤ºä¾‹35-å†…å­˜é¡ºåº)
    - [ç¤ºä¾‹3.6: æ€§èƒ½åˆ†æ](#ç¤ºä¾‹36-æ€§èƒ½åˆ†æ)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [å­¦ä¹ è·¯å¾„å»ºè®®](#å­¦ä¹ è·¯å¾„å»ºè®®)
    - [æ ¸å¿ƒæ¦‚å¿µæ€»ç»“](#æ ¸å¿ƒæ¦‚å¿µæ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº† **18ä¸ªç²¾å¿ƒè®¾è®¡çš„ä»£ç ç¤ºä¾‹**ï¼Œè¦†ç›–äº† C05 æ¨¡å—çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä»åŸºç¡€åˆ°é«˜çº§ï¼Œæ¯ä¸ªç¤ºä¾‹éƒ½é…æœ‰è¯¦ç»†çš„è§£é‡Šå’Œè¿è¡Œç»“æœã€‚

---

## ğŸ¯ ç¤ºä¾‹å¯¼èˆª

| #                  | ç¤ºä¾‹åç§°                                     | æ ¸å¿ƒæ¦‚å¿µ        | éš¾åº¦       | é¢„è®¡å­¦ä¹ æ—¶é—´ |
| ------------------ | -------------------------------------------- | --------------- | ---------- | ------------ |
| **Tier 1: åŸºç¡€å±‚** |                                              |                 |            |              |
| 1.1                | [çº¿ç¨‹åˆ›å»ºå’Œjoin](#ç¤ºä¾‹11-çº¿ç¨‹åˆ›å»ºå’Œjoin)     | thread::spawn   | â­         | 15åˆ†é’Ÿ       |
| 1.2                | [çº¿ç¨‹é—­åŒ…å’Œmove](#ç¤ºä¾‹12-çº¿ç¨‹é—­åŒ…å’Œmove)     | moveè¯­ä¹‰        | â­         | 20åˆ†é’Ÿ       |
| 1.3                | [çº¿ç¨‹panicå¤„ç†](#ç¤ºä¾‹13-çº¿ç¨‹panicå¤„ç†)       | panicæ¢å¤       | â­â­       | 25åˆ†é’Ÿ       |
| 1.4                | [çº¿ç¨‹ä¼‘çœ å’Œyield](#ç¤ºä¾‹14-çº¿ç¨‹ä¼‘çœ å’Œyield)   | sleep/yield_now | â­         | 15åˆ†é’Ÿ       |
| 1.5                | [Sendå’ŒSync trait](#ç¤ºä¾‹15-sendå’Œsync-trait) | çº¿ç¨‹å®‰å…¨        | â­â­       | 30åˆ†é’Ÿ       |
| 1.6                | [çº¿ç¨‹å±€éƒ¨å­˜å‚¨](#ç¤ºä¾‹16-çº¿ç¨‹å±€éƒ¨å­˜å‚¨)         | thread_local!   | â­â­       | 25åˆ†é’Ÿ       |
| **Tier 2: å®è·µå±‚** |                                              |                 |            |              |
| 2.1                | [Arcå…±äº«æ‰€æœ‰æƒ](#ç¤ºä¾‹21-arcå…±äº«æ‰€æœ‰æƒ)       | Arc             | â­â­       | 30åˆ†é’Ÿ       |
| 2.2                | [Mutexäº’æ–¥é”](#ç¤ºä¾‹22-mutexäº’æ–¥é”)           | Mutex           | â­â­       | 35åˆ†é’Ÿ       |
| 2.3                | [RwLockè¯»å†™é”](#ç¤ºä¾‹23-rwlockè¯»å†™é”)         | RwLock          | â­â­â­     | 40åˆ†é’Ÿ       |
| 2.4                | [Condvaræ¡ä»¶å˜é‡](#ç¤ºä¾‹24-condvaræ¡ä»¶å˜é‡)   | Condvar         | â­â­â­     | 40åˆ†é’Ÿ       |
| 2.5                | [Channelé€šé“](#ç¤ºä¾‹25-channelé€šé“)           | mpsc            | â­â­       | 35åˆ†é’Ÿ       |
| 2.6                | [AtomicåŸå­æ“ä½œ](#ç¤ºä¾‹26-atomicåŸå­æ“ä½œ)     | Atomic          | â­â­â­     | 40åˆ†é’Ÿ       |
| **Tier 3: é«˜çº§å±‚** |                                              |                 |            |              |
| 3.1                | [çº¿ç¨‹æ± å®ç°](#ç¤ºä¾‹31-çº¿ç¨‹æ± å®ç°)             | çº¿ç¨‹æ±           | â­â­â­â­   | 50åˆ†é’Ÿ       |
| 3.2                | [å·¥ä½œçªƒå–](#ç¤ºä¾‹32-å·¥ä½œçªƒå–)                 | å·¥ä½œçªƒå–        | â­â­â­â­â­ | 60åˆ†é’Ÿ       |
| 3.3                | [å¹¶å‘æ•°æ®ç»“æ„](#ç¤ºä¾‹33-å¹¶å‘æ•°æ®ç»“æ„)         | å¹¶å‘æ•°æ®ç»“æ„    | â­â­â­â­   | 50åˆ†é’Ÿ       |
| 3.4                | [æ— é”ç¼–ç¨‹](#ç¤ºä¾‹34-æ— é”ç¼–ç¨‹)                 | æ— é”æ ˆ/ABA      | â­â­â­â­â­ | 60åˆ†é’Ÿ       |
| 3.5                | [å†…å­˜é¡ºåº](#ç¤ºä¾‹35-å†…å­˜é¡ºåº)                 | Ordering        | â­â­â­â­â­ | 60åˆ†é’Ÿ       |
| 3.6                | [æ€§èƒ½åˆ†æ](#ç¤ºä¾‹36-æ€§èƒ½åˆ†æ)                 | æ€§èƒ½å¯¹æ¯”        | â­â­â­â­   | 50åˆ†é’Ÿ       |

---

## ğŸ“ Tier 1: åŸºç¡€å±‚ç¤ºä¾‹

### ç¤ºä¾‹1.1: çº¿ç¨‹åˆ›å»ºå’Œjoin

**ç›®æ ‡**: ç†è§£çº¿ç¨‹çš„åˆ›å»ºå’Œç­‰å¾…

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== åŸºç¡€çº¿ç¨‹åˆ›å»º =====\n");

    // åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹
    let handle = thread::spawn(|| {
        println!("Hello from thread!");
        42
    });

    // ç­‰å¾…çº¿ç¨‹å®Œæˆ
    let result = handle.join().unwrap();
    println!("çº¿ç¨‹è¿”å›å€¼: {}\n", result);

    println!("===== å¤šä¸ªçº¿ç¨‹ =====\n");

    let mut handles = vec![];

    // åˆ›å»º 5 ä¸ªçº¿ç¨‹
    for i in 0..5 {
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} å¯åŠ¨", i);
            thread::sleep(Duration::from_millis(100));
            println!("çº¿ç¨‹ {} å®Œæˆ", i);
            i * 2
        });
        handles.push(handle);
    }

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for handle in handles {
        let result = handle.join().unwrap();
        println!("æ”¶åˆ°ç»“æœ: {}", result);
    }

    println!("\n===== çº¿ç¨‹æ‰§è¡Œé¡ºåº =====\n");

    // çº¿ç¨‹æ‰§è¡Œé¡ºåºä¸ç¡®å®š
    for i in 0..3 {
        thread::spawn(move || {
            println!("çº¿ç¨‹ {}", i);
        });
    }

    // ä¸»çº¿ç¨‹ç­‰å¾…ï¼Œè®©å­çº¿ç¨‹æœ‰æ—¶é—´æ‰§è¡Œ
    thread::sleep(Duration::from_millis(100));

    println!("\n===== è·å–çº¿ç¨‹ID =====\n");

    let handle = thread::spawn(|| {
        let id = thread::current().id();
        println!("å­çº¿ç¨‹ ID: {:?}", id);
    });

    let main_id = thread::current().id();
    println!("ä¸»çº¿ç¨‹ ID: {:?}", main_id);

    handle.join().unwrap();
}
```

**è¯´æ˜**:

- **thread::spawn**: åˆ›å»ºæ–°çº¿ç¨‹
- **join**: ç­‰å¾…çº¿ç¨‹å®Œæˆå¹¶è·å–è¿”å›å€¼
- **æ‰§è¡Œé¡ºåº**: çº¿ç¨‹æ‰§è¡Œé¡ºåºä¸ç¡®å®š
- **çº¿ç¨‹ID**: å¯ä»¥è·å–çº¿ç¨‹çš„å”¯ä¸€æ ‡è¯†ç¬¦

**è¾“å‡º**:

```text
===== åŸºç¡€çº¿ç¨‹åˆ›å»º =====

Hello from thread!
çº¿ç¨‹è¿”å›å€¼: 42

===== å¤šä¸ªçº¿ç¨‹ =====

çº¿ç¨‹ 0 å¯åŠ¨
çº¿ç¨‹ 1 å¯åŠ¨
çº¿ç¨‹ 2 å¯åŠ¨
çº¿ç¨‹ 3 å¯åŠ¨
çº¿ç¨‹ 4 å¯åŠ¨
çº¿ç¨‹ 0 å®Œæˆ
çº¿ç¨‹ 1 å®Œæˆ
çº¿ç¨‹ 2 å®Œæˆ
çº¿ç¨‹ 3 å®Œæˆ
çº¿ç¨‹ 4 å®Œæˆ
æ”¶åˆ°ç»“æœ: 0
æ”¶åˆ°ç»“æœ: 2
æ”¶åˆ°ç»“æœ: 4
æ”¶åˆ°ç»“æœ: 6
æ”¶åˆ°ç»“æœ: 8

===== çº¿ç¨‹æ‰§è¡Œé¡ºåº =====

çº¿ç¨‹ 0
çº¿ç¨‹ 2
çº¿ç¨‹ 1

===== è·å–çº¿ç¨‹ID =====

ä¸»çº¿ç¨‹ ID: ThreadId(1)
å­çº¿ç¨‹ ID: ThreadId(2)
```

---

### ç¤ºä¾‹1.2: çº¿ç¨‹é—­åŒ…å’Œmove

**ç›®æ ‡**: ç†è§£çº¿ç¨‹é—­åŒ…çš„æ‰€æœ‰æƒè½¬ç§»

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use std::thread;

fn main() {
    println!("===== æ•è·ç¯å¢ƒå˜é‡ =====\n");

    let data = vec![1, 2, 3, 4, 5];

    // âŒ é”™è¯¯ï¼šé—­åŒ…å¯èƒ½æ¯”æ•°æ®æ´»å¾—æ›´ä¹…
    // let handle = thread::spawn(|| {
    //     println!("Data: {:?}", data);
    // });

    // âœ… ä½¿ç”¨ move è½¬ç§»æ‰€æœ‰æƒ
    let handle = thread::spawn(move || {
        println!("Data: {:?}", data);
        data.len()
    });

    let len = handle.join().unwrap();
    println!("é•¿åº¦: {}\n", len);

    // println!("{:?}", data);  // âŒ data å·²è¢«ç§»åŠ¨

    println!("===== Copy ç±»å‹ =====\n");

    let x = 42;  // i32 å®ç°äº† Copy

    let handle = thread::spawn(move || {
        println!("x = {}", x);
    });

    handle.join().unwrap();
    println!("ä¸»çº¿ç¨‹ä¸­ x = {}", x);  // âœ… Copy ç±»å‹å¯ä»¥ç»§ç»­ä½¿ç”¨

    println!("\n===== Clone è§£å†³æ–¹æ¡ˆ =====\n");

    let data = vec![1, 2, 3];
    let data_clone = data.clone();  // å…‹éš†æ•°æ®

    let handle = thread::spawn(move || {
        println!("çº¿ç¨‹ä¸­: {:?}", data_clone);
    });

    println!("ä¸»çº¿ç¨‹ä¸­: {:?}", data);  // âœ… åŸå§‹æ•°æ®ä»å¯ç”¨
    handle.join().unwrap();

    println!("\n===== å¤šä¸ªçº¿ç¨‹å…±äº«æ•°æ® =====\n");

    use std::sync::Arc;

    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];

    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} çœ‹åˆ°: {:?}", i, data_clone);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("ä¸»çº¿ç¨‹ä»å¯è®¿é—®: {:?}", data);
}
```

**è¯´æ˜**:

- **moveå…³é”®å­—**: å¼ºåˆ¶é—­åŒ…è·å–æ•è·å˜é‡çš„æ‰€æœ‰æƒ
- **Copyç±»å‹**: Copy ç±»å‹åœ¨ move åä»å¯ä½¿ç”¨
- **Clone**: å…‹éš†æ•°æ®ä»¥åœ¨å¤šå¤„ä½¿ç”¨
- **Arc**: ç”¨äºå¤šçº¿ç¨‹å…±äº«åªè¯»æ•°æ®

**è¾“å‡º**:

```text
===== æ•è·ç¯å¢ƒå˜é‡ =====

Data: [1, 2, 3, 4, 5]
é•¿åº¦: 5

===== Copy ç±»å‹ =====

x = 42
ä¸»çº¿ç¨‹ä¸­ x = 42

===== Clone è§£å†³æ–¹æ¡ˆ =====

ä¸»çº¿ç¨‹ä¸­: [1, 2, 3]
çº¿ç¨‹ä¸­: [1, 2, 3]

===== å¤šä¸ªçº¿ç¨‹å…±äº«æ•°æ® =====

çº¿ç¨‹ 0 çœ‹åˆ°: [1, 2, 3, 4, 5]
çº¿ç¨‹ 1 çœ‹åˆ°: [1, 2, 3, 4, 5]
çº¿ç¨‹ 2 çœ‹åˆ°: [1, 2, 3, 4, 5]
ä¸»çº¿ç¨‹ä»å¯è®¿é—®: [1, 2, 3, 4, 5]
```

---

### ç¤ºä¾‹1.3: çº¿ç¨‹panicå¤„ç†

**ç›®æ ‡**: ç†è§£çº¿ç¨‹ panic çš„å¤„ç†

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::thread;
use std::panic;

fn main() {
    println!("===== çº¿ç¨‹ panic =====\n");

    let handle = thread::spawn(|| {
        println!("çº¿ç¨‹å¼€å§‹");
        panic!("çº¿ç¨‹ panic!");
    });

    // join è¿”å› Result
    match handle.join() {
        Ok(_) => println!("çº¿ç¨‹æ­£å¸¸å®Œæˆ"),
        Err(e) => println!("çº¿ç¨‹ panic: {:?}\n", e),
    }

    println!("ä¸»çº¿ç¨‹ç»§ç»­è¿è¡Œ\n");

    println!("===== æ•è· panic ä¿¡æ¯ =====\n");

    let handle = thread::spawn(|| {
        panic!("é”™è¯¯æ¶ˆæ¯");
    });

    match handle.join() {
        Ok(_) => {},
        Err(e) => {
            if let Some(s) = e.downcast_ref::<&str>() {
                println!("æ•è·åˆ°å­—ç¬¦ä¸² panic: {}", s);
            } else if let Some(s) = e.downcast_ref::<String>() {
                println!("æ•è·åˆ° String panic: {}", s);
            } else {
                println!("æ•è·åˆ°æœªçŸ¥ç±»å‹ panic");
            }
        }
    }

    println!("\n===== è®¾ç½® panic hook =====\n");

    panic::set_hook(Box::new(|panic_info| {
        println!("è‡ªå®šä¹‰ panic å¤„ç†å™¨è¢«è°ƒç”¨");
        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            println!("panic æ¶ˆæ¯: {}", s);
        }
        if let Some(location) = panic_info.location() {
            println!("panic ä½ç½®: {}:{}", location.file(), location.line());
        }
    }));

    let handle = thread::spawn(|| {
        panic!("å¸¦ hook çš„ panic");
    });

    let _ = handle.join();

    // æ¢å¤é»˜è®¤ hook
    let _ = panic::take_hook();

    println!("\n===== é˜²å¾¡æ€§ç¼–ç¨‹ =====\n");

    fn safe_operation(x: i32) -> Result<i32, String> {
        if x < 0 {
            Err("è´Ÿæ•°ä¸å…è®¸".to_string())
        } else {
            Ok(x * 2)
        }
    }

    let handle = thread::spawn(|| {
        match safe_operation(-5) {
            Ok(result) => println!("ç»“æœ: {}", result),
            Err(e) => println!("é”™è¯¯: {}", e),
        }
    });

    handle.join().unwrap();

    println!("\n===== å¤šçº¿ç¨‹ panic éš”ç¦» =====\n");

    let mut handles = vec![];

    for i in 0..5 {
        let handle = thread::spawn(move || {
            if i == 2 {
                panic!("çº¿ç¨‹ {} panic!", i);
            }
            println!("çº¿ç¨‹ {} æ­£å¸¸å®Œæˆ", i);
        });
        handles.push(handle);
    }

    for (i, handle) in handles.into_iter().enumerate() {
        match handle.join() {
            Ok(_) => println!("çº¿ç¨‹ {} join æˆåŠŸ", i),
            Err(_) => println!("çº¿ç¨‹ {} join å¤±è´¥", i),
        }
    }
}
```

**è¯´æ˜**:

- **joinè¿”å›Result**: Err è¡¨ç¤ºçº¿ç¨‹ panic
- **downcast**: è·å– panic çš„å…·ä½“ç±»å‹
- **panic hook**: è‡ªå®šä¹‰ panic å¤„ç†
- **éš”ç¦»**: ä¸€ä¸ªçº¿ç¨‹ panic ä¸å½±å“å…¶ä»–çº¿ç¨‹

**è¾“å‡º**:

```text
===== çº¿ç¨‹ panic =====

çº¿ç¨‹å¼€å§‹
çº¿ç¨‹ panic: Any { .. }

ä¸»çº¿ç¨‹ç»§ç»­è¿è¡Œ

===== æ•è· panic ä¿¡æ¯ =====

æ•è·åˆ°å­—ç¬¦ä¸² panic: é”™è¯¯æ¶ˆæ¯

===== è®¾ç½® panic hook =====

è‡ªå®šä¹‰ panic å¤„ç†å™¨è¢«è°ƒç”¨
panic æ¶ˆæ¯: å¸¦ hook çš„ panic
panic ä½ç½®: src/main.rs:XX

===== é˜²å¾¡æ€§ç¼–ç¨‹ =====

é”™è¯¯: è´Ÿæ•°ä¸å…è®¸

===== å¤šçº¿ç¨‹ panic éš”ç¦» =====

çº¿ç¨‹ 0 æ­£å¸¸å®Œæˆ
çº¿ç¨‹ 1 æ­£å¸¸å®Œæˆ
çº¿ç¨‹ 3 æ­£å¸¸å®Œæˆ
çº¿ç¨‹ 4 æ­£å¸¸å®Œæˆ
çº¿ç¨‹ 0 join æˆåŠŸ
çº¿ç¨‹ 1 join æˆåŠŸ
çº¿ç¨‹ 2 join å¤±è´¥
çº¿ç¨‹ 3 join æˆåŠŸ
çº¿ç¨‹ 4 join æˆåŠŸ
```

---

### ç¤ºä¾‹1.4: çº¿ç¨‹ä¼‘çœ å’Œyield

**ç›®æ ‡**: ç†è§£çº¿ç¨‹è°ƒåº¦å’Œåä½œ

**éš¾åº¦**: â­

**ä»£ç **:

```rust
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    println!("===== çº¿ç¨‹ä¼‘çœ  =====\n");

    let start = Instant::now();

    thread::sleep(Duration::from_millis(100));

    println!("ä¼‘çœ  100ms åå”¤é†’");
    println!("å®é™…è€—æ—¶: {:?}\n", start.elapsed());

    println!("===== å¤šä¸ªçº¿ç¨‹ä¼‘çœ  =====\n");

    let mut handles = vec![];

    for i in 0..3 {
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} å¼€å§‹", i);
            thread::sleep(Duration::from_millis(i * 100));
            println!("çº¿ç¨‹ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\n===== thread::yield_now =====\n");

    // yield_now è®©å‡º CPU æ—¶é—´ç‰‡
    let handle1 = thread::spawn(|| {
        for i in 0..5 {
            println!("çº¿ç¨‹1: {}", i);
            thread::yield_now();  // ä¸»åŠ¨è®©å‡º CPU
        }
    });

    let handle2 = thread::spawn(|| {
        for i in 0..5 {
            println!("çº¿ç¨‹2: {}", i);
            thread::yield_now();
        }
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!("\n===== è‡ªæ—‹ vs ä¼‘çœ  =====\n");

    // è‡ªæ—‹é”ï¼ˆå ç”¨ CPUï¼‰
    let start = Instant::now();
    let mut counter = 0;
    while start.elapsed() < Duration::from_millis(10) {
        counter += 1;
    }
    println!("è‡ªæ—‹è®¡æ•°: {}", counter);

    // ä¼‘çœ ï¼ˆé‡Šæ”¾ CPUï¼‰
    let start = Instant::now();
    thread::sleep(Duration::from_millis(10));
    println!("ä¼‘çœ è€—æ—¶: {:?}", start.elapsed());

    println!("\n===== park å’Œ unpark =====\n");

    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};

    let ready = Arc::new(AtomicBool::new(false));
    let ready_clone = Arc::clone(&ready);

    let handle = thread::spawn(move || {
        println!("å­çº¿ç¨‹: å‡†å¤‡ park");

        while !ready_clone.load(Ordering::SeqCst) {
            thread::park();  // æš‚åœçº¿ç¨‹
        }

        println!("å­çº¿ç¨‹: è¢« unparkï¼Œç»§ç»­æ‰§è¡Œ");
    });

    thread::sleep(Duration::from_millis(100));
    println!("ä¸»çº¿ç¨‹: è®¾ç½® ready = true");
    ready.store(true, Ordering::SeqCst);

    handle.thread().unpark();  // å”¤é†’çº¿ç¨‹

    handle.join().unwrap();

    println!("\n===== å®šæ—¶å™¨æ¨¡æ‹Ÿ =====\n");

    fn timer(duration: Duration, message: &str) {
        let message = message.to_string();
        thread::spawn(move || {
            thread::sleep(duration);
            println!("â° {}", message);
        });
    }

    timer(Duration::from_millis(100), "100ms å®šæ—¶å™¨");
    timer(Duration::from_millis(200), "200ms å®šæ—¶å™¨");
    timer(Duration::from_millis(300), "300ms å®šæ—¶å™¨");

    thread::sleep(Duration::from_millis(350));
}
```

**è¯´æ˜**:

- **sleep**: çº¿ç¨‹ä¼‘çœ ï¼Œé‡Šæ”¾ CPU
- **yield_now**: ä¸»åŠ¨è®©å‡º CPU æ—¶é—´ç‰‡
- **park/unpark**: çº¿ç¨‹æš‚åœå’Œå”¤é†’æœºåˆ¶
- **è‡ªæ—‹ vs ä¼‘çœ **: è‡ªæ—‹å ç”¨ CPUï¼Œä¼‘çœ é‡Šæ”¾ CPU

**è¾“å‡º**:

```text
===== çº¿ç¨‹ä¼‘çœ  =====

ä¼‘çœ  100ms åå”¤é†’
å®é™…è€—æ—¶: 100.xxms

===== å¤šä¸ªçº¿ç¨‹ä¼‘çœ  =====

çº¿ç¨‹ 0 å¼€å§‹
çº¿ç¨‹ 1 å¼€å§‹
çº¿ç¨‹ 2 å¼€å§‹
çº¿ç¨‹ 0 å®Œæˆ
çº¿ç¨‹ 1 å®Œæˆ
çº¿ç¨‹ 2 å®Œæˆ

===== thread::yield_now =====

çº¿ç¨‹1: 0
çº¿ç¨‹2: 0
çº¿ç¨‹1: 1
çº¿ç¨‹2: 1
çº¿ç¨‹1: 2
çº¿ç¨‹2: 2
çº¿ç¨‹1: 3
çº¿ç¨‹2: 3
çº¿ç¨‹1: 4
çº¿ç¨‹2: 4

===== è‡ªæ—‹ vs ä¼‘çœ  =====

è‡ªæ—‹è®¡æ•°: 1234567
ä¼‘çœ è€—æ—¶: 10.xxms

===== park å’Œ unpark =====

å­çº¿ç¨‹: å‡†å¤‡ park
ä¸»çº¿ç¨‹: è®¾ç½® ready = true
å­çº¿ç¨‹: è¢« unparkï¼Œç»§ç»­æ‰§è¡Œ

===== å®šæ—¶å™¨æ¨¡æ‹Ÿ =====

â° 100ms å®šæ—¶å™¨
â° 200ms å®šæ—¶å™¨
â° 300ms å®šæ—¶å™¨
```

---

### ç¤ºä¾‹1.5: Sendå’ŒSync trait

**ç›®æ ‡**: ç†è§£çº¿ç¨‹å®‰å…¨çš„ç±»å‹ç³»ç»Ÿä¿è¯

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::thread;
use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell;
use std::sync::Mutex;

fn main() {
    println!("===== Send trait =====\n");

    // Send: å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ

    // âœ… i32 å®ç°äº† Send
    let x = 42;
    thread::spawn(move || {
        println!("i32 æ˜¯ Send: {}", x);
    }).join().unwrap();

    // âœ… String å®ç°äº† Send
    let s = String::from("hello");
    thread::spawn(move || {
        println!("String æ˜¯ Send: {}", s);
    }).join().unwrap();

    // âŒ Rc<T> æ²¡æœ‰å®ç° Send
    let rc = Rc::new(vec![1, 2, 3]);
    // thread::spawn(move || {  // ç¼–è¯‘é”™è¯¯ï¼
    //     println!("{:?}", rc);
    // });

    println!("Rc<T> ä¸æ˜¯ Sendï¼ˆå•çº¿ç¨‹å¼•ç”¨è®¡æ•°ï¼‰\n");

    // âœ… Arc<T> å®ç°äº† Send
    let arc = Arc::new(vec![1, 2, 3]);
    thread::spawn(move || {
        println!("Arc<T> æ˜¯ Send: {:?}", arc);
    }).join().unwrap();

    println!("\n===== Sync trait =====\n");

    // Sync: å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´å…±äº«ä¸å¯å˜å¼•ç”¨
    // &T æ˜¯ Send å½“ä¸”ä»…å½“ T æ˜¯ Sync

    // âœ… i32 å®ç°äº† Sync
    let x = 42;
    let x_ref = &x;
    // ä¸èƒ½ç›´æ¥åœ¨é—­åŒ…ä¸­ä½¿ç”¨å¼•ç”¨ï¼Œéœ€è¦ä½œç”¨åŸŸçº¿ç¨‹

    // âŒ RefCell<T> æ²¡æœ‰å®ç° Sync
    let cell = RefCell::new(5);
    // let cell_ref = &cell;
    // thread::spawn(move || {  // ç¼–è¯‘é”™è¯¯ï¼
    //     cell_ref.borrow_mut();
    // });

    println!("RefCell<T> ä¸æ˜¯ Syncï¼ˆè¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥ï¼‰");

    // âœ… Mutex<T> å®ç°äº† Sync
    let mutex = Arc::new(Mutex::new(5));
    let mutex_clone = Arc::clone(&mutex);

    thread::spawn(move || {
        let mut data = mutex_clone.lock().unwrap();
        *data += 1;
        println!("Mutex<T> æ˜¯ Sync: {}", data);
    }).join().unwrap();

    println!("\n===== è‡ªåŠ¨æ´¾ç”Ÿ =====\n");

    // ç»“æ„ä½“è‡ªåŠ¨å®ç° Send/Syncï¼ˆå¦‚æœæ‰€æœ‰å­—æ®µéƒ½å®ç°ï¼‰
    #[derive(Debug)]
    struct Data {
        value: i32,
        text: String,
    }

    let data = Data {
        value: 42,
        text: "hello".to_string(),
    };

    thread::spawn(move || {
        println!("Data è‡ªåŠ¨å®ç° Send: {:?}", data);
    }).join().unwrap();

    println!("\n===== æ‰‹åŠ¨å®ç°(unsafe) =====\n");

    struct MyType {
        value: i32,
    }

    // é€šå¸¸ä¸éœ€è¦æ‰‹åŠ¨å®ç°ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼
    // åªæœ‰åœ¨ç‰¹æ®Šæƒ…å†µä¸‹æ‰éœ€è¦ unsafe impl

    // unsafe impl Send for MyType {}
    // unsafe impl Sync for MyType {}

    println!("âš ï¸  æ‰‹åŠ¨å®ç° Send/Sync éœ€è¦ unsafe");
    println!("âš ï¸  å¿…é¡»ç¡®ä¿çœŸçš„æ˜¯çº¿ç¨‹å®‰å…¨çš„");

    println!("\n===== Send + Sync æ€»ç»“ =====\n");

    println!("Send: å¯ä»¥åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ");
    println!("  âœ… å¤§éƒ¨åˆ†ç±»å‹ (i32, String, Vec<T>, Box<T>)");
    println!("  âŒ Rc<T> (å•çº¿ç¨‹å¼•ç”¨è®¡æ•°)");
    println!("  âœ… Arc<T> (åŸå­å¼•ç”¨è®¡æ•°)");

    println!("\nSync: å¯ä»¥åœ¨çº¿ç¨‹é—´å…±äº«å¼•ç”¨");
    println!("  âœ… å¤§éƒ¨åˆ†ç±»å‹ (i32, String, Vec<T>)");
    println!("  âŒ RefCell<T>, Cell<T> (è¿è¡Œæ—¶å€Ÿç”¨)");
    println!("  âœ… Mutex<T>, RwLock<T> (åŒæ­¥åŸè¯­)");

    println!("\nå…³ç³»:");
    println!("  T: Send â‡’ &T å¯ä»¥åœ¨çº¿ç¨‹é—´ä¼ é€’");
    println!("  T: Sync â‡’ &T æ˜¯ Send");
    println!("  T: Send + Sync â‡’ Arc<T> æ˜¯ Send + Sync");
}
```

**è¯´æ˜**:

- **Send**: ç±»å‹å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ
- **Sync**: ç±»å‹å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´å…±äº«ä¸å¯å˜å¼•ç”¨
- **è‡ªåŠ¨æ´¾ç”Ÿ**: ç¼–è¯‘å™¨è‡ªåŠ¨ä¸ºæ»¡è¶³æ¡ä»¶çš„ç±»å‹å®ç°
- **Rc vs Arc**: Rc ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ŒArc æ˜¯

**è¾“å‡º**:

```text
===== Send trait =====

i32 æ˜¯ Send: 42
String æ˜¯ Send: hello
Rc<T> ä¸æ˜¯ Sendï¼ˆå•çº¿ç¨‹å¼•ç”¨è®¡æ•°ï¼‰
Arc<T> æ˜¯ Send: [1, 2, 3]

===== Sync trait =====

RefCell<T> ä¸æ˜¯ Syncï¼ˆè¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥ï¼‰
Mutex<T> æ˜¯ Sync: 6

===== è‡ªåŠ¨æ´¾ç”Ÿ =====

Data è‡ªåŠ¨å®ç° Send: Data { value: 42, text: "hello" }

===== æ‰‹åŠ¨å®ç°(unsafe) =====

âš ï¸  æ‰‹åŠ¨å®ç° Send/Sync éœ€è¦ unsafe
âš ï¸  å¿…é¡»ç¡®ä¿çœŸçš„æ˜¯çº¿ç¨‹å®‰å…¨çš„

===== Send + Sync æ€»ç»“ =====

Send: å¯ä»¥åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ
  âœ… å¤§éƒ¨åˆ†ç±»å‹ (i32, String, Vec<T>, Box<T>)
  âŒ Rc<T> (å•çº¿ç¨‹å¼•ç”¨è®¡æ•°)
  âœ… Arc<T> (åŸå­å¼•ç”¨è®¡æ•°)

Sync: å¯ä»¥åœ¨çº¿ç¨‹é—´å…±äº«å¼•ç”¨
  âœ… å¤§éƒ¨åˆ†ç±»å‹ (i32, String, Vec<T>)
  âŒ RefCell<T>, Cell<T> (è¿è¡Œæ—¶å€Ÿç”¨)
  âœ… Mutex<T>, RwLock<T> (åŒæ­¥åŸè¯­)

å…³ç³»:
  T: Send â‡’ &T å¯ä»¥åœ¨çº¿ç¨‹é—´ä¼ é€’
  T: Sync â‡’ &T æ˜¯ Send
  T: Send + Sync â‡’ Arc<T> æ˜¯ Send + Sync
```

---

### ç¤ºä¾‹1.6: çº¿ç¨‹å±€éƒ¨å­˜å‚¨

**ç›®æ ‡**: ç†è§£çº¿ç¨‹å±€éƒ¨å˜é‡

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::thread;
use std::cell::RefCell;

fn main() {
    println!("===== thread_local! åŸºç¡€ =====\n");

    thread_local! {
        static COUNTER: RefCell<u32> = RefCell::new(0);
    }

    // ä¸»çº¿ç¨‹
    COUNTER.with(|c| {
        *c.borrow_mut() += 1;
        println!("ä¸»çº¿ç¨‹ counter: {}", c.borrow());
    });

    // å­çº¿ç¨‹ 1
    let handle1 = thread::spawn(|| {
        COUNTER.with(|c| {
            *c.borrow_mut() += 10;
            println!("çº¿ç¨‹1 counter: {}", c.borrow());
        });
    });

    // å­çº¿ç¨‹ 2
    let handle2 = thread::spawn(|| {
        COUNTER.with(|c| {
            *c.borrow_mut() += 100;
            println!("çº¿ç¨‹2 counter: {}", c.borrow());
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    // ä¸»çº¿ç¨‹çš„å€¼ä¸å—å½±å“
    COUNTER.with(|c| {
        println!("ä¸»çº¿ç¨‹ counter (æœ€ç»ˆ): {}", c.borrow());
    });

    println!("\n===== çº¿ç¨‹IDå­˜å‚¨ =====\n");

    thread_local! {
        static THREAD_NAME: RefCell<String> = RefCell::new(String::from("æœªå‘½å"));
    }

    fn set_thread_name(name: &str) {
        THREAD_NAME.with(|n| {
            *n.borrow_mut() = name.to_string();
        });
    }

    fn get_thread_name() -> String {
        THREAD_NAME.with(|n| n.borrow().clone())
    }

    set_thread_name("MainThread");
    println!("å½“å‰çº¿ç¨‹: {}", get_thread_name());

    let handle = thread::spawn(|| {
        set_thread_name("WorkerThread");
        println!("å½“å‰çº¿ç¨‹: {}", get_thread_name());
    });

    handle.join().unwrap();
    println!("ä¸»çº¿ç¨‹: {}", get_thread_name());

    println!("\n===== æ€§èƒ½è®¡æ•°å™¨ =====\n");

    thread_local! {
        static PERF_COUNTER: RefCell<u64> = RefCell::new(0);
    }

    fn inc_counter() {
        PERF_COUNTER.with(|c| {
            *c.borrow_mut() += 1;
        });
    }

    fn get_counter() -> u64 {
        PERF_COUNTER.with(|c| *c.borrow())
    }

    let mut handles = vec![];

    for i in 0..3 {
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                inc_counter();
            }
            println!("çº¿ç¨‹{} è®¡æ•°: {}", i, get_counter());
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\n===== ç¼“å­˜ç¤ºä¾‹ =====\n");

    use std::collections::HashMap;

    thread_local! {
        static CACHE: RefCell<HashMap<String, i32>> = RefCell::new(HashMap::new());
    }

    fn cache_get(key: &str) -> Option<i32> {
        CACHE.with(|c| c.borrow().get(key).copied())
    }

    fn cache_set(key: String, value: i32) {
        CACHE.with(|c| {
            c.borrow_mut().insert(key, value);
        });
    }

    cache_set("answer".to_string(), 42);
    println!("ç¼“å­˜è¯»å–: {:?}", cache_get("answer"));

    let handle = thread::spawn(|| {
        // æ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹çš„ç¼“å­˜
        cache_set("local".to_string(), 100);
        println!("çº¿ç¨‹ç¼“å­˜: {:?}", cache_get("local"));
        println!("çº¿ç¨‹ç¼“å­˜: {:?}", cache_get("answer"));  // None
    });

    handle.join().unwrap();

    println!("ä¸»çº¿ç¨‹ç¼“å­˜: {:?}", cache_get("answer"));  // Some(42)
    println!("ä¸»çº¿ç¨‹ç¼“å­˜: {:?}", cache_get("local"));   // None
}
```

**è¯´æ˜**:

- **thread_local!**: å®šä¹‰çº¿ç¨‹å±€éƒ¨å˜é‡
- **RefCell**: å…è®¸å†…éƒ¨å¯å˜æ€§
- **ç‹¬ç«‹æ€§**: æ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬
- **ç”¨é€”**: çº¿ç¨‹IDã€æ€§èƒ½è®¡æ•°ã€ç¼“å­˜ç­‰

**è¾“å‡º**:

```text
===== thread_local! åŸºç¡€ =====

ä¸»çº¿ç¨‹ counter: 1
çº¿ç¨‹1 counter: 10
çº¿ç¨‹2 counter: 100
ä¸»çº¿ç¨‹ counter (æœ€ç»ˆ): 1

===== çº¿ç¨‹IDå­˜å‚¨ =====

å½“å‰çº¿ç¨‹: MainThread
å½“å‰çº¿ç¨‹: WorkerThread
ä¸»çº¿ç¨‹: MainThread

===== æ€§èƒ½è®¡æ•°å™¨ =====

çº¿ç¨‹0 è®¡æ•°: 100
çº¿ç¨‹1 è®¡æ•°: 100
çº¿ç¨‹2 è®¡æ•°: 100

===== ç¼“å­˜ç¤ºä¾‹ =====

ç¼“å­˜è¯»å–: Some(42)
çº¿ç¨‹ç¼“å­˜: Some(100)
çº¿ç¨‹ç¼“å­˜: None
ä¸»çº¿ç¨‹ç¼“å­˜: Some(42)
ä¸»çº¿ç¨‹ç¼“å­˜: None
```

---

## ğŸ“ Tier 2: å®è·µå±‚ç¤ºä¾‹

### ç¤ºä¾‹2.1: Arcå…±äº«æ‰€æœ‰æƒ

**ç›®æ ‡**: ç†è§£åŸå­å¼•ç”¨è®¡æ•°çš„ä½¿ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    println!("===== Arc åŸºç¡€ =====\n");

    let data = Arc::new(vec![1, 2, 3, 4, 5]);

    println!("åˆå§‹å¼•ç”¨è®¡æ•°: {}", Arc::strong_count(&data));

    let mut handles = vec![];

    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        println!("å…‹éš†åå¼•ç”¨è®¡æ•°: {}", Arc::strong_count(&data_clone));

        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} è®¿é—®æ•°æ®: {:?}", i, data_clone);
            println!("çº¿ç¨‹ {} ä¸­å¼•ç”¨è®¡æ•°: {}", i, Arc::strong_count(&data_clone));
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆå¼•ç”¨è®¡æ•°: {}", Arc::strong_count(&data));

    println!("\n===== Arc + Mutex æ¨¡å¼ =====\n");

    use std::sync::Mutex;

    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
            println!("çº¿ç¨‹ {} å¢åŠ è®¡æ•°", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().unwrap());

    println!("\n===== å…±äº«é…ç½® =====\n");

    #[derive(Debug)]
    struct Config {
        host: String,
        port: u16,
        timeout: u64,
    }

    let config = Arc::new(Config {
        host: "localhost".to_string(),
        port: 8080,
        timeout: 30,
    });

    let mut handles = vec![];

    for i in 0..3 {
        let config_clone = Arc::clone(&config);
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} ä½¿ç”¨é…ç½®: {:?}", i, config_clone);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\n===== Weak å¼±å¼•ç”¨ =====\n");

    let strong = Arc::new(42);
    let weak = Arc::downgrade(&strong);

    println!("å¼ºå¼•ç”¨è®¡æ•°: {}", Arc::strong_count(&strong));
    println!("å¼±å¼•ç”¨è®¡æ•°: {}", Arc::weak_count(&strong));

    // å°è¯•å‡çº§å¼±å¼•ç”¨
    if let Some(strong_ref) = weak.upgrade() {
        println!("å‡çº§æˆåŠŸ: {}", strong_ref);
    }

    drop(strong);  // é‡Šæ”¾å¼ºå¼•ç”¨

    // å†æ¬¡å°è¯•å‡çº§
    if let Some(_) = weak.upgrade() {
        println!("å‡çº§æˆåŠŸ");
    } else {
        println!("å‡çº§å¤±è´¥ï¼šå¼ºå¼•ç”¨å·²é‡Šæ”¾");
    }

    println!("\n===== å¾ªç¯å¼•ç”¨è§£å†³ =====\n");

    use std::sync::Weak;

    struct Node {
        value: i32,
        parent: Mutex<Weak<Node>>,
        children: Mutex<Vec<Arc<Node>>>,
    }

    let parent = Arc::new(Node {
        value: 1,
        parent: Mutex::new(Weak::new()),
        children: Mutex::new(vec![]),
    });

    let child = Arc::new(Node {
        value: 2,
        parent: Mutex::new(Arc::downgrade(&parent)),
        children: Mutex::new(vec![]),
    });

    parent.children.lock().unwrap().push(Arc::clone(&child));

    println!("èŠ‚ç‚¹æ ‘åˆ›å»ºæˆåŠŸï¼ˆé¿å…å¾ªç¯å¼•ç”¨ï¼‰");
    println!("çˆ¶èŠ‚ç‚¹å¼•ç”¨è®¡æ•°: {}", Arc::strong_count(&parent));
    println!("å­èŠ‚ç‚¹å¼•ç”¨è®¡æ•°: {}", Arc::strong_count(&child));
}
```

**è¯´æ˜**:

- **Arc::clone**: å¢åŠ å¼•ç”¨è®¡æ•°ï¼ˆå»‰ä»·æ“ä½œï¼‰
- **Arc + Mutex**: å¤šçº¿ç¨‹å¯å˜å…±äº«æ•°æ®çš„æ ‡å‡†æ¨¡å¼
- **Weak**: å¼±å¼•ç”¨ï¼Œä¸å¢åŠ å¼ºå¼•ç”¨è®¡æ•°
- **é¿å…å¾ªç¯**: ä½¿ç”¨ Weak é¿å…å¾ªç¯å¼•ç”¨å¯¼è‡´çš„å†…å­˜æ³„æ¼

**è¾“å‡º**:

```text
===== Arc åŸºç¡€ =====

åˆå§‹å¼•ç”¨è®¡æ•°: 1
å…‹éš†åå¼•ç”¨è®¡æ•°: 2
å…‹éš†åå¼•ç”¨è®¡æ•°: 3
å…‹éš†åå¼•ç”¨è®¡æ•°: 4
çº¿ç¨‹ 0 è®¿é—®æ•°æ®: [1, 2, 3, 4, 5]
çº¿ç¨‹ 0 ä¸­å¼•ç”¨è®¡æ•°: 4
çº¿ç¨‹ 1 è®¿é—®æ•°æ®: [1, 2, 3, 4, 5]
çº¿ç¨‹ 1 ä¸­å¼•ç”¨è®¡æ•°: 3
çº¿ç¨‹ 2 è®¿é—®æ•°æ®: [1, 2, 3, 4, 5]
çº¿ç¨‹ 2 ä¸­å¼•ç”¨è®¡æ•°: 2
æœ€ç»ˆå¼•ç”¨è®¡æ•°: 1

===== Arc + Mutex æ¨¡å¼ =====

çº¿ç¨‹ 0 å¢åŠ è®¡æ•°
çº¿ç¨‹ 1 å¢åŠ è®¡æ•°
çº¿ç¨‹ 2 å¢åŠ è®¡æ•°
çº¿ç¨‹ 3 å¢åŠ è®¡æ•°
çº¿ç¨‹ 4 å¢åŠ è®¡æ•°
çº¿ç¨‹ 5 å¢åŠ è®¡æ•°
çº¿ç¨‹ 6 å¢åŠ è®¡æ•°
çº¿ç¨‹ 7 å¢åŠ è®¡æ•°
çº¿ç¨‹ 8 å¢åŠ è®¡æ•°
çº¿ç¨‹ 9 å¢åŠ è®¡æ•°
æœ€ç»ˆè®¡æ•°: 10

===== å…±äº«é…ç½® =====

çº¿ç¨‹ 0 ä½¿ç”¨é…ç½®: Config { host: "localhost", port: 8080, timeout: 30 }
çº¿ç¨‹ 1 ä½¿ç”¨é…ç½®: Config { host: "localhost", port: 8080, timeout: 30 }
çº¿ç¨‹ 2 ä½¿ç”¨é…ç½®: Config { host: "localhost", port: 8080, timeout: 30 }

===== Weak å¼±å¼•ç”¨ =====

å¼ºå¼•ç”¨è®¡æ•°: 1
å¼±å¼•ç”¨è®¡æ•°: 1
å‡çº§æˆåŠŸ: 42
å‡çº§å¤±è´¥ï¼šå¼ºå¼•ç”¨å·²é‡Šæ”¾

===== å¾ªç¯å¼•ç”¨è§£å†³ =====

èŠ‚ç‚¹æ ‘åˆ›å»ºæˆåŠŸï¼ˆé¿å…å¾ªç¯å¼•ç”¨ï¼‰
çˆ¶èŠ‚ç‚¹å¼•ç”¨è®¡æ•°: 1
å­èŠ‚ç‚¹å¼•ç”¨è®¡æ•°: 2
```

---

### ç¤ºä¾‹2.2: Mutexäº’æ–¥é”

**ç›®æ ‡**: æŒæ¡äº’æ–¥é”çš„ä½¿ç”¨

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Mutex åŸºç¡€ =====\n");

    let counter = Mutex::new(0);

    {
        let mut num = counter.lock().unwrap();
        *num += 1;
        println!("è®¡æ•°å™¨: {}", num);
        // é”åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
    }

    println!("æœ€ç»ˆå€¼: {}", *counter.lock().unwrap());

    println!("\n===== å¤šçº¿ç¨‹ç«äº‰ =====\n");

    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                let mut num = counter_clone.lock().unwrap();
                *num += 1;
            }
            println!("çº¿ç¨‹ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().unwrap());
    println!("é¢„æœŸ: 1000");

    println!("\n===== try_lock éé˜»å¡ =====\n");

    let data = Arc::new(Mutex::new(0));
    let data_clone = Arc::clone(&data);

    let handle = thread::spawn(move || {
        let _lock = data_clone.lock().unwrap();
        println!("çº¿ç¨‹æŒæœ‰é”");
        thread::sleep(Duration::from_secs(2));
        println!("çº¿ç¨‹é‡Šæ”¾é”");
    });

    thread::sleep(Duration::from_millis(100));

    match data.try_lock() {
        Ok(_guard) => println!("ä¸»çº¿ç¨‹è·å¾—é”"),
        Err(_) => println!("ä¸»çº¿ç¨‹: é”å·²è¢«å ç”¨ï¼Œä¸ç­‰å¾…"),
    }

    handle.join().unwrap();

    println!("\n===== Mutex ä¸­æ¯’ =====\n");

    let data = Arc::new(Mutex::new(0));
    let data_clone = Arc::clone(&data);

    let handle = thread::spawn(move || {
        let mut lock = data_clone.lock().unwrap();
        *lock = 10;
        panic!("æ•…æ„ panic!");
    });

    let _ = handle.join();

    match data.lock() {
        Ok(guard) => println!("è·å–é”æˆåŠŸ: {}", *guard),
        Err(poisoned) => {
            println!("é”ä¸­æ¯’ï¼æ¢å¤æ•°æ®...");
            let guard = poisoned.into_inner();
            println!("æ¢å¤çš„å€¼: {}", *guard);
        }
    }

    println!("\n===== Mutex ä¿æŠ¤å¤æ‚æ•°æ® =====\n");

    use std::collections::HashMap;

    let cache = Arc::new(Mutex::new(HashMap::new()));
    let mut handles = vec![];

    for i in 0..3 {
        let cache_clone = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            let mut map = cache_clone.lock().unwrap();
            map.insert(format!("key{}", i), i * 10);
            println!("çº¿ç¨‹ {} æ’å…¥æ•°æ®", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let map = cache.lock().unwrap();
    println!("\nç¼“å­˜å†…å®¹:");
    for (key, value) in map.iter() {
        println!("  {} = {}", key, value);
    }
}
```

**è¯´æ˜**:

- **lock()**: é˜»å¡ç›´åˆ°è·å–é”
- **try_lock()**: éé˜»å¡å°è¯•è·å–é”
- **ä¸­æ¯’**: panic æ—¶é”ä¼šè¢«æ ‡è®°ä¸º"ä¸­æ¯’"
- **è‡ªåŠ¨é‡Šæ”¾**: ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾é”

**è¾“å‡º**:

```text
===== Mutex åŸºç¡€ =====

è®¡æ•°å™¨: 1
æœ€ç»ˆå€¼: 1

===== å¤šçº¿ç¨‹ç«äº‰ =====

çº¿ç¨‹ 0 å®Œæˆ
çº¿ç¨‹ 1 å®Œæˆ
...
çº¿ç¨‹ 9 å®Œæˆ
æœ€ç»ˆè®¡æ•°: 1000
é¢„æœŸ: 1000

===== try_lock éé˜»å¡ =====

çº¿ç¨‹æŒæœ‰é”
ä¸»çº¿ç¨‹: é”å·²è¢«å ç”¨ï¼Œä¸ç­‰å¾…
çº¿ç¨‹é‡Šæ”¾é”

===== Mutex ä¸­æ¯’ =====

é”ä¸­æ¯’ï¼æ¢å¤æ•°æ®...
æ¢å¤çš„å€¼: 10

===== Mutex ä¿æŠ¤å¤æ‚æ•°æ® =====

çº¿ç¨‹ 0 æ’å…¥æ•°æ®
çº¿ç¨‹ 1 æ’å…¥æ•°æ®
çº¿ç¨‹ 2 æ’å…¥æ•°æ®

ç¼“å­˜å†…å®¹:
  key0 = 0
  key1 = 10
  key2 = 20
```

---

### ç¤ºä¾‹2.3: RwLockè¯»å†™é”

**ç›®æ ‡**: ç†è§£è¯»å†™é”çš„æ€§èƒ½ä¼˜åŠ¿

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== RwLock åŸºç¡€ =====\n");

    let data = RwLock::new(5);

    {
        let r = data.read().unwrap();
        println!("è¯»å–: {}", *r);
    }

    {
        let mut w = data.write().unwrap();
        *w += 1;
        println!("å†™å…¥: {}", *w);
    }

    println!("\n===== å¤šä¸ªè¯»è€… =====\n");

    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..5 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let r = data_clone.read().unwrap();
            println!("è¯»è€… {}: {:?}", i, *r);
            thread::sleep(Duration::from_millis(100));
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\næ‰€æœ‰è¯»è€…å¯ä»¥å¹¶å‘è®¿é—®ï¼");

    println!("\n===== è¯»å†™ç«äº‰ =====\n");

    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];

    // 10ä¸ªè¯»çº¿ç¨‹
    for i in 0..10 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..5 {
                let r = data_clone.read().unwrap();
                println!("è¯» {}: {}", i, *r);
                thread::sleep(Duration::from_millis(10));
            }
        });
        handles.push(handle);
    }

    // 2ä¸ªå†™çº¿ç¨‹
    for i in 0..2 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for j in 0..3 {
                let mut w = data_clone.write().unwrap();
                *w += 1;
                println!("å†™ {}.{}: {}", i, j, *w);
                thread::sleep(Duration::from_millis(50));
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\næœ€ç»ˆå€¼: {}", *data.read().unwrap());

    println!("\n===== try_read/try_write =====\n");

    let lock = Arc::new(RwLock::new(0));
    let lock_clone = Arc::clone(&lock);

    let handle = thread::spawn(move || {
        let _w = lock_clone.write().unwrap();
        println!("å†™é”æŒæœ‰ä¸­...");
        thread::sleep(Duration::from_secs(1));
    });

    thread::sleep(Duration::from_millis(100));

    match lock.try_read() {
        Ok(_) => println!("è·å–è¯»é”æˆåŠŸ"),
        Err(_) => println!("è¯»é”è¢«é˜»å¡ï¼ˆæœ‰å†™é”ï¼‰"),
    }

    match lock.try_write() {
        Ok(_) => println!("è·å–å†™é”æˆåŠŸ"),
        Err(_) => println!("å†™é”è¢«é˜»å¡"),
    }

    handle.join().unwrap();

    println!("\n===== å‡çº§è¯»é”ä¸ºå†™é”ï¼ˆé”™è¯¯ç¤ºä¾‹ï¼‰=====\n");

    let data = RwLock::new(0);

    {
        let _r = data.read().unwrap();
        println!("æŒæœ‰è¯»é”");

        // ä¸èƒ½åœ¨æŒæœ‰è¯»é”æ—¶è·å–å†™é”
        // let mut w = data.write().unwrap(); // ä¼šæ­»é”ï¼
        println!("éœ€è¦å…ˆé‡Šæ”¾è¯»é”");
    }

    {
        let mut w = data.write().unwrap();
        *w = 42;
        println!("ç°åœ¨å¯ä»¥å†™å…¥");
    }
}
```

**è¯´æ˜**:

- **read()**: å…±äº«è¯»é”ï¼Œå¤šä¸ªçº¿ç¨‹å¯åŒæ—¶è¯»
- **write()**: ç‹¬å å†™é”ï¼Œé˜»å¡æ‰€æœ‰å…¶ä»–è®¿é—®
- **æ€§èƒ½**: è¯»å¤šå†™å°‘åœºæ™¯æ€§èƒ½ä¼˜äº Mutex
- **æ³¨æ„**: ä¸èƒ½å°†è¯»é”å‡çº§ä¸ºå†™é”

**è¾“å‡º**:

```text
===== RwLock åŸºç¡€ =====

è¯»å–: 5
å†™å…¥: 6

===== å¤šä¸ªè¯»è€… =====

è¯»è€… 0: [1, 2, 3]
è¯»è€… 1: [1, 2, 3]
è¯»è€… 2: [1, 2, 3]
è¯»è€… 3: [1, 2, 3]
è¯»è€… 4: [1, 2, 3]

æ‰€æœ‰è¯»è€…å¯ä»¥å¹¶å‘è®¿é—®ï¼

===== è¯»å†™ç«äº‰ =====

è¯» 0: 0
è¯» 1: 0
...
å†™ 0.0: 1
å†™ 0.1: 2
...
æœ€ç»ˆå€¼: 6

===== try_read/try_write =====

å†™é”æŒæœ‰ä¸­...
è¯»é”è¢«é˜»å¡ï¼ˆæœ‰å†™é”ï¼‰
å†™é”è¢«é˜»å¡

===== å‡çº§è¯»é”ä¸ºå†™é”ï¼ˆé”™è¯¯ç¤ºä¾‹ï¼‰=====

æŒæœ‰è¯»é”
éœ€è¦å…ˆé‡Šæ”¾è¯»é”
ç°åœ¨å¯ä»¥å†™å…¥
```

---

### ç¤ºä¾‹2.4: Condvaræ¡ä»¶å˜é‡

**ç›®æ ‡**: ç†è§£æ¡ä»¶å˜é‡çš„ä½¿ç”¨

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Condvar åŸºç¡€ =====\n");

    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);

    thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        thread::sleep(Duration::from_secs(1));

        let mut started = lock.lock().unwrap();
        *started = true;
        println!("é€šçŸ¥: æ¡ä»¶å·²æ»¡è¶³");
        cvar.notify_one();
    });

    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();

    while !*started {
        println!("ç­‰å¾…æ¡ä»¶...");
        started = cvar.wait(started).unwrap();
    }

    println!("æ¡ä»¶æ»¡è¶³ï¼Œç»§ç»­æ‰§è¡Œ");

    println!("\n===== ç”Ÿäº§è€…-æ¶ˆè´¹è€… =====\n");

    let data = Arc::new((Mutex::new(Vec::new()), Condvar::new()));

    // ç”Ÿäº§è€…
    let data_clone = Arc::clone(&data);
    let producer = thread::spawn(move || {
        for i in 0..5 {
            thread::sleep(Duration::from_millis(500));
            let (lock, cvar) = &*data_clone;
            let mut queue = lock.lock().unwrap();
            queue.push(i);
            println!("ç”Ÿäº§: {}", i);
            cvar.notify_one();
        }
    });

    // æ¶ˆè´¹è€…
    let data_clone = Arc::clone(&data);
    let consumer = thread::spawn(move || {
        for _ in 0..5 {
            let (lock, cvar) = &*data_clone;
            let mut queue = lock.lock().unwrap();

            while queue.is_empty() {
                queue = cvar.wait(queue).unwrap();
            }

            let item = queue.remove(0);
            println!("æ¶ˆè´¹: {}", item);
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();

    println!("\n===== wait_timeout è¶…æ—¶ç­‰å¾… =====\n");

    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let (lock, cvar) = &*pair;

    let mut ready = lock.lock().unwrap();
    let timeout = Duration::from_secs(1);

    let result = cvar.wait_timeout(ready, timeout).unwrap();

    if result.1.timed_out() {
        println!("ç­‰å¾…è¶…æ—¶");
    } else {
        println!("æ¡ä»¶æ»¡è¶³");
    }

    println!("\n===== notify_all é€šçŸ¥æ‰€æœ‰ =====\n");

    let pair = Arc::new((Mutex::new(0), Condvar::new()));
    let mut handles = vec![];

    for i in 0..3 {
        let pair_clone = Arc::clone(&pair);
        let handle = thread::spawn(move || {
            let (lock, cvar) = &*pair_clone;
            let mut count = lock.lock().unwrap();

            while *count == 0 {
                println!("çº¿ç¨‹ {} ç­‰å¾…...", i);
                count = cvar.wait(count).unwrap();
            }

            println!("çº¿ç¨‹ {} æ”¶åˆ°é€šçŸ¥: {}", i, *count);
        });
        handles.push(handle);
    }

    thread::sleep(Duration::from_secs(1));

    let (lock, cvar) = &*pair;
    let mut count = lock.lock().unwrap();
    *count = 1;
    println!("\né€šçŸ¥æ‰€æœ‰çº¿ç¨‹");
    cvar.notify_all();
    drop(count);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

**è¯´æ˜**:

- **wait()**: é‡Šæ”¾é”å¹¶ç­‰å¾…é€šçŸ¥
- **notify_one()**: å”¤é†’ä¸€ä¸ªç­‰å¾…çº¿ç¨‹
- **notify_all()**: å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
- **wait_timeout()**: å¸¦è¶…æ—¶çš„ç­‰å¾…

**è¾“å‡º**:

```text
===== Condvar åŸºç¡€ =====

ç­‰å¾…æ¡ä»¶...
é€šçŸ¥: æ¡ä»¶å·²æ»¡è¶³
æ¡ä»¶æ»¡è¶³ï¼Œç»§ç»­æ‰§è¡Œ

===== ç”Ÿäº§è€…-æ¶ˆè´¹è€… =====

ç”Ÿäº§: 0
æ¶ˆè´¹: 0
ç”Ÿäº§: 1
æ¶ˆè´¹: 1
ç”Ÿäº§: 2
æ¶ˆè´¹: 2
ç”Ÿäº§: 3
æ¶ˆè´¹: 3
ç”Ÿäº§: 4
æ¶ˆè´¹: 4

===== wait_timeout è¶…æ—¶ç­‰å¾… =====

ç­‰å¾…è¶…æ—¶

===== notify_all é€šçŸ¥æ‰€æœ‰ =====

çº¿ç¨‹ 0 ç­‰å¾…...
çº¿ç¨‹ 1 ç­‰å¾…...
çº¿ç¨‹ 2 ç­‰å¾…...

é€šçŸ¥æ‰€æœ‰çº¿ç¨‹
çº¿ç¨‹ 0 æ”¶åˆ°é€šçŸ¥: 1
çº¿ç¨‹ 1 æ”¶åˆ°é€šçŸ¥: 1
çº¿ç¨‹ 2 æ”¶åˆ°é€šçŸ¥: 1
```

---

### ç¤ºä¾‹2.5: Channelé€šé“

**ç›®æ ‡**: æŒæ¡æ¶ˆæ¯ä¼ é€’å¹¶å‘æ¨¡å¼

**éš¾åº¦**: â­â­

**ä»£ç **:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Channel åŸºç¡€ =====\n");

    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send("Hello from thread").unwrap();
    });

    let message = rx.recv().unwrap();
    println!("æ”¶åˆ°: {}", message);

    println!("\n===== å¤šä¸ªæ¶ˆæ¯ =====\n");

    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let messages = vec!["hi", "from", "the", "thread"];

        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    for received in rx {
        println!("æ”¶åˆ°: {}", received);
    }

    println!("\n===== å¤šä¸ªç”Ÿäº§è€… =====\n");

    let (tx, rx) = mpsc::channel();

    for i in 0..3 {
        let tx_clone = tx.clone();
        thread::spawn(move || {
            for j in 0..3 {
                tx_clone.send(format!("çº¿ç¨‹ {} æ¶ˆæ¯ {}", i, j)).unwrap();
                thread::sleep(Duration::from_millis(100));
            }
        });
    }

    drop(tx); // é‡Šæ”¾åŸå§‹å‘é€è€…

    for received in rx {
        println!("æ”¶åˆ°: {}", received);
    }

    println!("\n===== try_recv éé˜»å¡ =====\n");

    let (tx, rx) = mpsc::channel();

    match rx.try_recv() {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(mpsc::TryRecvError::Empty) => println!("é€šé“ä¸ºç©º"),
        Err(mpsc::TryRecvError::Disconnected) => println!("é€šé“å·²æ–­å¼€"),
    }

    tx.send("message").unwrap();

    match rx.try_recv() {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(_) => println!("é€šé“ä¸ºç©º"),
    }

    println!("\n===== recv_timeout è¶…æ—¶ =====\n");

    let (tx, rx) = mpsc::channel::<String>();

    let handle = thread::spawn(move || {
        thread::sleep(Duration::from_secs(2));
        tx.send("delayed message".to_string()).unwrap();
    });

    println!("ç­‰å¾…æ¶ˆæ¯ï¼ˆ1ç§’è¶…æ—¶ï¼‰...");
    match rx.recv_timeout(Duration::from_secs(1)) {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(_) => println!("è¶…æ—¶"),
    }

    println!("ç­‰å¾…æ¶ˆæ¯ï¼ˆ3ç§’è¶…æ—¶ï¼‰...");
    match rx.recv_timeout(Duration::from_secs(3)) {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(_) => println!("è¶…æ—¶"),
    }

    handle.join().unwrap();

    println!("\n===== åŒæ­¥é€šé“ =====\n");

    let (tx, rx) = mpsc::sync_channel(1);

    let handle = thread::spawn(move || {
        println!("å‘é€ 1...");
        tx.send(1).unwrap();
        println!("å‘é€ 2... (ä¼šé˜»å¡)");
        tx.send(2).unwrap();
        println!("å‘é€å®Œæˆ");
    });

    thread::sleep(Duration::from_secs(1));
    println!("æ¥æ”¶: {}", rx.recv().unwrap());
    thread::sleep(Duration::from_secs(1));
    println!("æ¥æ”¶: {}", rx.recv().unwrap());

    handle.join().unwrap();
}
```

**è¯´æ˜**:

- **mpsc**: å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…
- **send/recv**: å‘é€å’Œæ¥æ”¶æ¶ˆæ¯
- **try_recv**: éé˜»å¡æ¥æ”¶
- **sync_channel**: æœ‰ç•Œé€šé“ï¼Œæ»¡æ—¶é˜»å¡

**è¾“å‡º**:

```text
===== Channel åŸºç¡€ =====

æ”¶åˆ°: Hello from thread

===== å¤šä¸ªæ¶ˆæ¯ =====

æ”¶åˆ°: hi
æ”¶åˆ°: from
æ”¶åˆ°: the
æ”¶åˆ°: thread

===== å¤šä¸ªç”Ÿäº§è€… =====

æ”¶åˆ°: çº¿ç¨‹ 0 æ¶ˆæ¯ 0
æ”¶åˆ°: çº¿ç¨‹ 1 æ¶ˆæ¯ 0
æ”¶åˆ°: çº¿ç¨‹ 2 æ¶ˆæ¯ 0
...

===== try_recv éé˜»å¡ =====

é€šé“ä¸ºç©º
æ”¶åˆ°: message

===== recv_timeout è¶…æ—¶ =====

ç­‰å¾…æ¶ˆæ¯ï¼ˆ1ç§’è¶…æ—¶ï¼‰...
è¶…æ—¶
ç­‰å¾…æ¶ˆæ¯ï¼ˆ3ç§’è¶…æ—¶ï¼‰...
æ”¶åˆ°: delayed message

===== åŒæ­¥é€šé“ =====

å‘é€ 1...
å‘é€ 2... (ä¼šé˜»å¡)
æ¥æ”¶: 1
å‘é€å®Œæˆ
æ¥æ”¶: 2
```

---

### ç¤ºä¾‹2.6: AtomicåŸå­æ“ä½œ

**ç›®æ ‡**: ç†è§£æ— é”å¹¶å‘çš„åŸºç¡€

**éš¾åº¦**: â­â­â­

**ä»£ç **:

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Atomic åŸºç¡€ =====\n");

    let counter = AtomicUsize::new(0);

    counter.store(5, Ordering::Relaxed);
    println!("å­˜å‚¨å: {}", counter.load(Ordering::Relaxed));

    let old = counter.fetch_add(3, Ordering::Relaxed);
    println!("æ—§å€¼: {}, æ–°å€¼: {}", old, counter.load(Ordering::Relaxed));

    println!("\n===== å¤šçº¿ç¨‹è®¡æ•° =====\n");

    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter_clone.fetch_add(1, Ordering::Relaxed);
            }
            println!("çº¿ç¨‹ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", counter.load(Ordering::Relaxed));
    println!("é¢„æœŸ: 10000");

    println!("\n===== åŸå­æ ‡å¿— =====\n");

    let flag = Arc::new(AtomicBool::new(false));
    let flag_clone = Arc::clone(&flag);

    let handle = thread::spawn(move || {
        println!("å·¥ä½œçº¿ç¨‹å¼€å§‹...");
        thread::sleep(Duration::from_secs(2));
        flag_clone.store(true, Ordering::Relaxed);
        println!("å·¥ä½œçº¿ç¨‹å®Œæˆ");
    });

    println!("ä¸»çº¿ç¨‹ç­‰å¾…...");
    while !flag.load(Ordering::Relaxed) {
        thread::sleep(Duration::from_millis(100));
    }
    println!("ä¸»çº¿ç¨‹æ£€æµ‹åˆ°å®Œæˆ");

    handle.join().unwrap();

    println!("\n===== compare_exchange =====\n");

    let value = AtomicUsize::new(10);

    let result = value.compare_exchange(
        10,  // æœŸæœ›å€¼
        20,  // æ–°å€¼
        Ordering::Relaxed,
        Ordering::Relaxed
    );

    match result {
        Ok(old) => println!("äº¤æ¢æˆåŠŸ: {} -> {}", old, value.load(Ordering::Relaxed)),
        Err(current) => println!("äº¤æ¢å¤±è´¥ï¼Œå½“å‰å€¼: {}", current),
    }

    let result = value.compare_exchange(
        10,  // æœŸæœ›å€¼é”™è¯¯
        30,  // æ–°å€¼
        Ordering::Relaxed,
        Ordering::Relaxed
    );

    match result {
        Ok(_) => println!("äº¤æ¢æˆåŠŸ"),
        Err(current) => println!("äº¤æ¢å¤±è´¥ï¼Œå½“å‰å€¼: {}", current),
    }

    println!("\n===== è‡ªæ—‹é”å®ç° =====\n");

    struct SpinLock {
        locked: AtomicBool,
    }

    impl SpinLock {
        fn new() -> Self {
            SpinLock {
                locked: AtomicBool::new(false),
            }
        }

        fn lock(&self) {
            while self.locked.compare_exchange(
                false,
                true,
                Ordering::Acquire,
                Ordering::Relaxed
            ).is_err() {
                // è‡ªæ—‹ç­‰å¾…
                std::hint::spin_loop();
            }
        }

        fn unlock(&self) {
            self.locked.store(false, Ordering::Release);
        }
    }

    let lock = Arc::new(SpinLock::new());
    let mut handles = vec![];

    for i in 0..3 {
        let lock_clone = Arc::clone(&lock);
        let handle = thread::spawn(move || {
            lock_clone.lock();
            println!("çº¿ç¨‹ {} è·å¾—é”", i);
            thread::sleep(Duration::from_millis(100));
            lock_clone.unlock();
            println!("çº¿ç¨‹ {} é‡Šæ”¾é”", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\n===== å†…å­˜é¡ºåºå¯¹æ¯” =====\n");

    println!("Relaxed: æœ€å¼±çš„é¡ºåºï¼Œåªä¿è¯åŸå­æ€§");
    println!("Acquire/Release: å»ºç«‹happens-beforeå…³ç³»");
    println!("SeqCst: æœ€å¼ºçš„é¡ºåºï¼Œå…¨å±€ä¸€è‡´æ€§");
}
```

**è¯´æ˜**:

- **åŸå­ç±»å‹**: AtomicBool, AtomicUsizeç­‰
- **fetch\_\***: è¯»-ä¿®æ”¹-å†™æ“ä½œ
- **compare_exchange**: CASæ“ä½œ
- **Ordering**: å†…å­˜é¡ºåºæ§åˆ¶

**è¾“å‡º**:

```text
===== Atomic åŸºç¡€ =====

å­˜å‚¨å: 5
æ—§å€¼: 5, æ–°å€¼: 8

===== å¤šçº¿ç¨‹è®¡æ•° =====

çº¿ç¨‹ 0 å®Œæˆ
çº¿ç¨‹ 1 å®Œæˆ
...
çº¿ç¨‹ 9 å®Œæˆ
æœ€ç»ˆè®¡æ•°: 10000
é¢„æœŸ: 10000

===== åŸå­æ ‡å¿— =====

ä¸»çº¿ç¨‹ç­‰å¾…...
å·¥ä½œçº¿ç¨‹å¼€å§‹...
å·¥ä½œçº¿ç¨‹å®Œæˆ
ä¸»çº¿ç¨‹æ£€æµ‹åˆ°å®Œæˆ

===== compare_exchange =====

äº¤æ¢æˆåŠŸ: 10 -> 20
äº¤æ¢å¤±è´¥ï¼Œå½“å‰å€¼: 20

===== è‡ªæ—‹é”å®ç° =====

çº¿ç¨‹ 0 è·å¾—é”
çº¿ç¨‹ 0 é‡Šæ”¾é”
çº¿ç¨‹ 1 è·å¾—é”
çº¿ç¨‹ 1 é‡Šæ”¾é”
çº¿ç¨‹ 2 è·å¾—é”
çº¿ç¨‹ 2 é‡Šæ”¾é”

===== å†…å­˜é¡ºåºå¯¹æ¯” =====

Relaxed: æœ€å¼±çš„é¡ºåºï¼Œåªä¿è¯åŸå­æ€§
Acquire/Release: å»ºç«‹happens-beforeå…³ç³»
SeqCst: æœ€å¼ºçš„é¡ºåºï¼Œå…¨å±€ä¸€è‡´æ€§
```

---

## ğŸš€ Tier 3: é«˜çº§å±‚ç¤ºä¾‹

### ç¤ºä¾‹3.1: çº¿ç¨‹æ± å®ç°

**ç›®æ ‡**: å®ç°ä¸€ä¸ªç®€å•çš„çº¿ç¨‹æ± 

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
use std::thread;
use std::sync::{Arc, Mutex, mpsc};
use std::time::Duration;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Self {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();

            match job {
                Ok(job) => {
                    println!("Worker {} æ‰§è¡Œä»»åŠ¡", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} æ–­å¼€è¿æ¥", id);
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}

fn main() {
    println!("===== çº¿ç¨‹æ± åŸºç¡€ =====\n");

    let pool = ThreadPool::new(4);

    for i in 0..10 {
        pool.execute(move || {
            println!("ä»»åŠ¡ {} å¼€å§‹", i);
            thread::sleep(Duration::from_millis(100));
            println!("ä»»åŠ¡ {} å®Œæˆ", i);
        });
    }

    thread::sleep(Duration::from_secs(2));

    println!("\n===== å¸¦è¿”å›å€¼çš„ä»»åŠ¡ =====\n");

    use std::sync::mpsc;

    let pool = ThreadPool::new(2);
    let (result_tx, result_rx) = mpsc::channel();

    for i in 0..5 {
        let tx = result_tx.clone();
        pool.execute(move || {
            let result = i * 2;
            tx.send((i, result)).unwrap();
        });
    }

    drop(result_tx);

    while let Ok((input, output)) = result_rx.recv() {
        println!("{} * 2 = {}", input, output);
    }
}
```

**è¯´æ˜**:

- **çº¿ç¨‹æ± **: é¢„åˆ›å»ºçº¿ç¨‹ï¼Œå¤ç”¨æ‰§è¡Œä»»åŠ¡
- **ä»»åŠ¡é˜Ÿåˆ—**: ä½¿ç”¨Channelä¼ é€’ä»»åŠ¡
- **Worker**: å·¥ä½œçº¿ç¨‹ï¼Œå¾ªç¯è·å–ä»»åŠ¡

**è¾“å‡º**:

```text
===== çº¿ç¨‹æ± åŸºç¡€ =====

Worker 0 æ‰§è¡Œä»»åŠ¡
ä»»åŠ¡ 0 å¼€å§‹
Worker 1 æ‰§è¡Œä»»åŠ¡
ä»»åŠ¡ 1 å¼€å§‹
Worker 2 æ‰§è¡Œä»»åŠ¡
ä»»åŠ¡ 2 å¼€å§‹
Worker 3 æ‰§è¡Œä»»åŠ¡
ä»»åŠ¡ 3 å¼€å§‹
ä»»åŠ¡ 0 å®Œæˆ
Worker 0 æ‰§è¡Œä»»åŠ¡
ä»»åŠ¡ 4 å¼€å§‹
...

===== å¸¦è¿”å›å€¼çš„ä»»åŠ¡ =====

0 * 2 = 0
1 * 2 = 2
2 * 2 = 4
3 * 2 = 6
4 * 2 = 8
```

---

### ç¤ºä¾‹3.2: å·¥ä½œçªƒå–

**ç›®æ ‡**: å®ç°å·¥ä½œçªƒå–è°ƒåº¦

**éš¾åº¦**: â­â­â­â­â­

**ä»£ç **:

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;
use std::time::Duration;

struct WorkStealingQueue<T> {
    local: VecDeque<T>,
    shared: Arc<Mutex<VecDeque<T>>>,
}

impl<T> WorkStealingQueue<T> {
    fn new() -> (Self, WorkStealer<T>) {
        let shared = Arc::new(Mutex::new(VecDeque::new()));
        let queue = WorkStealingQueue {
            local: VecDeque::new(),
            shared: Arc::clone(&shared),
        };
        let stealer = WorkStealer { shared };
        (queue, stealer)
    }

    fn push(&mut self, item: T) {
        self.local.push_back(item);
    }

    fn pop(&mut self) -> Option<T> {
        self.local.pop_front().or_else(|| {
            self.shared.lock().unwrap().pop_front()
        })
    }

    fn publish(&mut self) {
        if !self.local.is_empty() {
            let mut shared = self.shared.lock().unwrap();
            shared.append(&mut self.local);
        }
    }
}

struct WorkStealer<T> {
    shared: Arc<Mutex<VecDeque<T>>>,
}

impl<T> WorkStealer<T> {
    fn steal(&self) -> Option<T> {
        self.shared.lock().unwrap().pop_back()
    }
}

impl<T> Clone for WorkStealer<T> {
    fn clone(&self) -> Self {
        WorkStealer {
            shared: Arc::clone(&self.shared),
        }
    }
}

fn main() {
    println!("===== å·¥ä½œçªƒå–ç¤ºä¾‹ =====\n");

    let (mut queue, stealer) = WorkStealingQueue::new();

    // æ·»åŠ ä»»åŠ¡åˆ°æœ¬åœ°é˜Ÿåˆ—
    for i in 0..10 {
        queue.push(i);
    }

    println!("æœ¬åœ°é˜Ÿåˆ—æœ‰ 10 ä¸ªä»»åŠ¡");

    // å‘å¸ƒéƒ¨åˆ†åˆ°å…±äº«é˜Ÿåˆ—
    queue.publish();

    // å…¶ä»–çº¿ç¨‹çªƒå–ä»»åŠ¡
    let stealer_clone = stealer.clone();
    let handle = thread::spawn(move || {
        let mut stolen = 0;
        while let Some(task) = stealer_clone.steal() {
            println!("çªƒå–çº¿ç¨‹æ‰§è¡Œä»»åŠ¡: {}", task);
            stolen += 1;
            thread::sleep(Duration::from_millis(50));
        }
        println!("çªƒå–çº¿ç¨‹å®Œæˆï¼Œå¤„ç†äº† {} ä¸ªä»»åŠ¡", stolen);
    });

    // ä¸»çº¿ç¨‹å¤„ç†æœ¬åœ°ä»»åŠ¡
    let mut processed = 0;
    while let Some(task) = queue.pop() {
        println!("ä¸»çº¿ç¨‹æ‰§è¡Œä»»åŠ¡: {}", task);
        processed += 1;
        thread::sleep(Duration::from_millis(50));
    }

    handle.join().unwrap();
    println!("\nä¸»çº¿ç¨‹å¤„ç†äº† {} ä¸ªä»»åŠ¡", processed);

    println!("\n===== å¤šå·¥ä½œçº¿ç¨‹çªƒå– =====\n");

    let (mut main_queue, main_stealer) = WorkStealingQueue::new();

    // æ·»åŠ å¤§é‡ä»»åŠ¡
    for i in 0..20 {
        main_queue.push(i);
    }
    main_queue.publish();

    // å¯åŠ¨å¤šä¸ªçªƒå–çº¿ç¨‹
    let mut handles = vec![];

    for id in 0..3 {
        let stealer = main_stealer.clone();
        let handle = thread::spawn(move || {
            let mut count = 0;
            while let Some(task) = stealer.steal() {
                println!("Worker {} æ‰§è¡Œ: {}", id, task);
                count += 1;
                thread::sleep(Duration::from_millis(30));
            }
            println!("Worker {} å®Œæˆï¼Œå¤„ç† {} ä¸ªä»»åŠ¡", id, count);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

**è¯´æ˜**:

- **æœ¬åœ°é˜Ÿåˆ—**: æ¯ä¸ªçº¿ç¨‹è‡ªå·±çš„é˜Ÿåˆ—
- **å·¥ä½œçªƒå–**: ç©ºé—²çº¿ç¨‹ä»å…¶ä»–çº¿ç¨‹çªƒå–ä»»åŠ¡
- **è´Ÿè½½å‡è¡¡**: è‡ªåŠ¨å¹³è¡¡å·¥ä½œè´Ÿè½½

**è¾“å‡º**:

```text
===== å·¥ä½œçªƒå–ç¤ºä¾‹ =====

æœ¬åœ°é˜Ÿåˆ—æœ‰ 10 ä¸ªä»»åŠ¡
ä¸»çº¿ç¨‹æ‰§è¡Œä»»åŠ¡: 0
çªƒå–çº¿ç¨‹æ‰§è¡Œä»»åŠ¡: 9
ä¸»çº¿ç¨‹æ‰§è¡Œä»»åŠ¡: 1
çªƒå–çº¿ç¨‹æ‰§è¡Œä»»åŠ¡: 8
...

===== å¤šå·¥ä½œçº¿ç¨‹çªƒå– =====

Worker 0 æ‰§è¡Œ: 19
Worker 1 æ‰§è¡Œ: 18
Worker 2 æ‰§è¡Œ: 17
...
```

---

### ç¤ºä¾‹3.3: å¹¶å‘æ•°æ®ç»“æ„

**ç›®æ ‡**: å®ç°çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// å¹¶å‘æ ˆ
struct ConcurrentStack<T> {
    data: Arc<Mutex<Vec<T>>>,
}

impl<T> ConcurrentStack<T> {
    fn new() -> Self {
        ConcurrentStack {
            data: Arc::new(Mutex::new(Vec::new())),
        }
    }

    fn push(&self, item: T) {
        self.data.lock().unwrap().push(item);
    }

    fn pop(&self) -> Option<T> {
        self.data.lock().unwrap().pop()
    }

    fn len(&self) -> usize {
        self.data.lock().unwrap().len()
    }
}

impl<T> Clone for ConcurrentStack<T> {
    fn clone(&self) -> Self {
        ConcurrentStack {
            data: Arc::clone(&self.data),
        }
    }
}

// å¹¶å‘é˜Ÿåˆ—
use std::collections::VecDeque;

struct ConcurrentQueue<T> {
    data: Arc<Mutex<VecDeque<T>>>,
}

impl<T> ConcurrentQueue<T> {
    fn new() -> Self {
        ConcurrentQueue {
            data: Arc::new(Mutex::new(VecDeque::new())),
        }
    }

    fn enqueue(&self, item: T) {
        self.data.lock().unwrap().push_back(item);
    }

    fn dequeue(&self) -> Option<T> {
        self.data.lock().unwrap().pop_front()
    }
}

impl<T> Clone for ConcurrentQueue<T> {
    fn clone(&self) -> Self {
        ConcurrentQueue {
            data: Arc::clone(&self.data),
        }
    }
}

// å¹¶å‘å“ˆå¸Œè¡¨
use std::collections::HashMap;
use std::hash::Hash;

struct ConcurrentHashMap<K, V> {
    data: Arc<Mutex<HashMap<K, V>>>,
}

impl<K: Eq + Hash, V> ConcurrentHashMap<K, V> {
    fn new() -> Self {
        ConcurrentHashMap {
            data: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    fn insert(&self, key: K, value: V) -> Option<V> {
        self.data.lock().unwrap().insert(key, value)
    }

    fn get(&self, key: &K) -> Option<V>
    where
        V: Clone,
    {
        self.data.lock().unwrap().get(key).cloned()
    }

    fn remove(&self, key: &K) -> Option<V> {
        self.data.lock().unwrap().remove(key)
    }
}

impl<K, V> Clone for ConcurrentHashMap<K, V> {
    fn clone(&self) -> Self {
        ConcurrentHashMap {
            data: Arc::clone(&self.data),
        }
    }
}

fn main() {
    println!("===== å¹¶å‘æ ˆ =====\n");

    let stack = ConcurrentStack::new();
    let mut handles = vec![];

    for i in 0..5 {
        let stack_clone = stack.clone();
        let handle = thread::spawn(move || {
            for j in 0..3 {
                stack_clone.push(i * 10 + j);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æ ˆå¤§å°: {}", stack.len());

    while let Some(item) = stack.pop() {
        println!("å¼¹å‡º: {}", item);
    }

    println!("\n===== å¹¶å‘é˜Ÿåˆ— =====\n");

    let queue = ConcurrentQueue::new();

    // ç”Ÿäº§è€…
    let mut handles = vec![];
    for i in 0..3 {
        let queue_clone = queue.clone();
        let handle = thread::spawn(move || {
            for j in 0..5 {
                queue_clone.enqueue(format!("P{}-{}", i, j));
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    // æ¶ˆè´¹è€…
    let mut handles = vec![];
    for i in 0..2 {
        let queue_clone = queue.clone();
        let handle = thread::spawn(move || {
            for _ in 0..5 {
                if let Some(item) = queue_clone.dequeue() {
                    println!("Consumer {} å–å‡º: {}", i, item);
                }
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\n===== å¹¶å‘å“ˆå¸Œè¡¨ =====\n");

    let map = ConcurrentHashMap::new();

    // å¹¶å‘æ’å…¥
    let mut handles = vec![];
    for i in 0..5 {
        let map_clone = map.clone();
        let handle = thread::spawn(move || {
            map_clone.insert(i, i * 10);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    // å¹¶å‘è¯»å–
    let mut handles = vec![];
    for i in 0..5 {
        let map_clone = map.clone();
        let handle = thread::spawn(move || {
            if let Some(value) = map_clone.get(&i) {
                println!("é”® {} = {}", i, value);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

**è¯´æ˜**:

- **å¹¶å‘æ ˆ**: çº¿ç¨‹å®‰å…¨çš„æ ˆ
- **å¹¶å‘é˜Ÿåˆ—**: FIFOé˜Ÿåˆ—
- **å¹¶å‘å“ˆå¸Œè¡¨**: çº¿ç¨‹å®‰å…¨çš„é”®å€¼å­˜å‚¨

**è¾“å‡º**:

```text
===== å¹¶å‘æ ˆ =====

æ ˆå¤§å°: 15
å¼¹å‡º: 42
å¼¹å‡º: 41
å¼¹å‡º: 40
...

===== å¹¶å‘é˜Ÿåˆ— =====

Consumer 0 å–å‡º: P0-0
Consumer 1 å–å‡º: P0-1
Consumer 0 å–å‡º: P0-2
...

===== å¹¶å‘å“ˆå¸Œè¡¨ =====

é”® 0 = 0
é”® 1 = 10
é”® 2 = 20
é”® 3 = 30
é”® 4 = 40
```

---

### ç¤ºä¾‹3.4: æ— é”ç¼–ç¨‹

**ç›®æ ‡**: ä½¿ç”¨åŸå­æ“ä½œå®ç°æ— é”æ•°æ®ç»“æ„

**éš¾åº¦**: â­â­â­â­â­

**ä»£ç **:

```rust
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};
use std::ptr;
use std::thread;

// æ— é”æ ˆ
struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

impl<T> LockFreeStack<T> {
    fn new() -> Self {
        LockFreeStack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe {
                (*new_node).next = head;
            }

            if self.head.compare_exchange(
                head,
                new_node,
                Ordering::Release,
                Ordering::Acquire
            ).is_ok() {
                break;
            }
        }
    }

    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);

            if head.is_null() {
                return None;
            }

            unsafe {
                let next = (*head).next;

                if self.head.compare_exchange(
                    head,
                    next,
                    Ordering::Release,
                    Ordering::Acquire
                ).is_ok() {
                    let data = ptr::read(&(*head).data);
                    drop(Box::from_raw(head));
                    return Some(data);
                }
            }
        }
    }
}

impl<T> Drop for LockFreeStack<T> {
    fn drop(&mut self) {
        while self.pop().is_some() {}
    }
}

fn main() {
    println!("===== æ— é”æ ˆ =====\n");

    let stack = LockFreeStack::new();
    let mut handles = vec![];

    // å¹¶å‘push
    for i in 0..10 {
        let stack_ref = unsafe { &*(&stack as *const _) };
        let handle = thread::spawn(move || {
            for j in 0..10 {
                stack_ref.push(i * 10 + j);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    // å¹¶å‘pop
    let mut handles = vec![];
    for i in 0..5 {
        let stack_ref = unsafe { &*(&stack as *const _) };
        let handle = thread::spawn(move || {
            let mut count = 0;
            while let Some(_) = stack_ref.pop() {
                count += 1;
            }
            println!("çº¿ç¨‹ {} å¼¹å‡º {} ä¸ªå…ƒç´ ", i, count);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("\n===== ABAé—®é¢˜ç¤ºä¾‹ =====\n");

    println!("ABAé—®é¢˜: å€¼ä»Aå˜ä¸ºBå†å˜å›A");
    println!("CASæ“ä½œä¼šè®¤ä¸ºæ²¡æœ‰å˜åŒ–");
    println!("è§£å†³æ–¹æ¡ˆ: ä½¿ç”¨ç‰ˆæœ¬å·æˆ–æ ‡è®°æŒ‡é’ˆ");

    struct TaggedPtr<T> {
        ptr: AtomicUsize,
        _marker: std::marker::PhantomData<T>,
    }

    impl<T> TaggedPtr<T> {
        fn new() -> Self {
            TaggedPtr {
                ptr: AtomicUsize::new(0),
                _marker: std::marker::PhantomData,
            }
        }

        fn load(&self) -> (usize, usize) {
            let val = self.ptr.load(Ordering::Acquire);
            let ptr = val & !0xFF;
            let tag = val & 0xFF;
            (ptr, tag)
        }

        fn store(&self, ptr: usize, tag: usize) {
            let val = ptr | (tag & 0xFF);
            self.ptr.store(val, Ordering::Release);
        }
    }

    let tagged = TaggedPtr::<i32>::new();
    tagged.store(0x1000, 1);

    let (ptr, tag) = tagged.load();
    println!("æŒ‡é’ˆ: 0x{:X}, æ ‡è®°: {}", ptr, tag);
}
```

**è¯´æ˜**:

- **æ— é”**: ä½¿ç”¨CASæ“ä½œä»£æ›¿é”
- **ABAé—®é¢˜**: éœ€è¦ç‰ˆæœ¬å·è§£å†³
- **å†…å­˜ç®¡ç†**: éœ€è¦å°å¿ƒå¤„ç†å†…å­˜å®‰å…¨

**è¾“å‡º**:

```text
===== æ— é”æ ˆ =====

çº¿ç¨‹ 0 å¼¹å‡º 20 ä¸ªå…ƒç´ 
çº¿ç¨‹ 1 å¼¹å‡º 20 ä¸ªå…ƒç´ 
çº¿ç¨‹ 2 å¼¹å‡º 20 ä¸ªå…ƒç´ 
çº¿ç¨‹ 3 å¼¹å‡º 20 ä¸ªå…ƒç´ 
çº¿ç¨‹ 4 å¼¹å‡º 20 ä¸ªå…ƒç´ 

===== ABAé—®é¢˜ç¤ºä¾‹ =====

ABAé—®é¢˜: å€¼ä»Aå˜ä¸ºBå†å˜å›A
CASæ“ä½œä¼šè®¤ä¸ºæ²¡æœ‰å˜åŒ–
è§£å†³æ–¹æ¡ˆ: ä½¿ç”¨ç‰ˆæœ¬å·æˆ–æ ‡è®°æŒ‡é’ˆ
æŒ‡é’ˆ: 0x1000, æ ‡è®°: 1
```

---

### ç¤ºä¾‹3.5: å†…å­˜é¡ºåº

**ç›®æ ‡**: ç†è§£ä¸åŒçš„å†…å­˜é¡ºåº

**éš¾åº¦**: â­â­â­â­â­

**ä»£ç **:

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    println!("===== Relaxed é¡ºåº =====\n");

    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Relaxedè®¡æ•°: {}", counter.load(Ordering::Relaxed));
    println!("ä¿è¯åŸå­æ€§ï¼Œä¸ä¿è¯é¡ºåº\n");

    println!("===== Acquire-Release =====\n");

    let data = Arc::new(AtomicUsize::new(0));
    let flag = Arc::new(AtomicBool::new(false));

    let data_clone = Arc::clone(&data);
    let flag_clone = Arc::clone(&flag);

    let writer = thread::spawn(move || {
        data_clone.store(42, Ordering::Relaxed);
        flag_clone.store(true, Ordering::Release);
        println!("å†™å…¥å®Œæˆ");
    });

    let reader = thread::spawn(move || {
        while !flag.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let value = data.load(Ordering::Relaxed);
        println!("è¯»å–åˆ°: {}", value);
    });

    writer.join().unwrap();
    reader.join().unwrap();

    println!("Acquire-Release å»ºç«‹ happens-before å…³ç³»\n");

    println!("===== SeqCst é¡ºåº =====\n");

    let x = Arc::new(AtomicBool::new(false));
    let y = Arc::new(AtomicBool::new(false));
    let z = Arc::new(AtomicUsize::new(0));

    let x1 = Arc::clone(&x);
    let y1 = Arc::clone(&y);
    let z1 = Arc::clone(&z);

    let t1 = thread::spawn(move || {
        x1.store(true, Ordering::SeqCst);
    });

    let x2 = Arc::clone(&x);
    let y2 = Arc::clone(&y);
    let z2 = Arc::clone(&z);

    let t2 = thread::spawn(move || {
        y2.store(true, Ordering::SeqCst);
    });

    let x3 = Arc::clone(&x);
    let y3 = Arc::clone(&y);
    let z3 = Arc::clone(&z);

    let t3 = thread::spawn(move || {
        while !x3.load(Ordering::SeqCst) {}
        if y3.load(Ordering::SeqCst) {
            z3.fetch_add(1, Ordering::SeqCst);
        }
    });

    let t4 = thread::spawn(move || {
        while !y.load(Ordering::SeqCst) {}
        if x.load(Ordering::SeqCst) {
            z.fetch_add(1, Ordering::SeqCst);
        }
    });

    t1.join().unwrap();
    t2.join().unwrap();
    t3.join().unwrap();
    t4.join().unwrap();

    let count = z1.load(Ordering::SeqCst);
    println!("SeqCst è®¡æ•°: {}", count);
    println!("ä¿è¯å…¨å±€ä¸€è‡´çš„é¡ºåº\n");

    println!("===== Fence å±éšœ =====\n");

    use std::sync::atomic::fence;

    let data = Arc::new(AtomicUsize::new(0));
    let ready = Arc::new(AtomicBool::new(false));

    let data_clone = Arc::clone(&data);
    let ready_clone = Arc::clone(&ready);

    thread::spawn(move || {
        data_clone.store(100, Ordering::Relaxed);
        fence(Ordering::Release);
        ready_clone.store(true, Ordering::Relaxed);
    });

    thread::sleep(Duration::from_millis(10));

    while !ready.load(Ordering::Relaxed) {
        thread::yield_now();
    }
    fence(Ordering::Acquire);
    let value = data.load(Ordering::Relaxed);

    println!("é€šè¿‡fenceè¯»å–: {}", value);

    println!("\n===== å†…å­˜é¡ºåºå¯¹æ¯” =====\n");

    println!("| é¡ºåº | ä¿è¯ | æ€§èƒ½ | ä½¿ç”¨åœºæ™¯ |");
    println!("|------|------|------|----------|");
    println!("| Relaxed | åŸå­æ€§ | æœ€å¿« | è®¡æ•°å™¨ |");
    println!("| Acquire | åŒæ­¥è¯» | å¿« | è¯»å–æ ‡å¿— |");
    println!("| Release | åŒæ­¥å†™ | å¿« | è®¾ç½®æ ‡å¿— |");
    println!("| AcqRel | è¯»å†™åŒæ­¥ | ä¸­ | RMWæ“ä½œ |");
    println!("| SeqCst | å…¨å±€é¡ºåº | æ…¢ | å¤æ‚åŒæ­¥ |");
}
```

**è¯´æ˜**:

- **Relaxed**: åªä¿è¯åŸå­æ€§
- **Acquire/Release**: å»ºç«‹happens-before
- **SeqCst**: å…¨å±€ä¸€è‡´é¡ºåº
- **Fence**: æ˜¾å¼å†…å­˜å±éšœ

**è¾“å‡º**:

```text
===== Relaxed é¡ºåº =====

Relaxedè®¡æ•°: 1000
ä¿è¯åŸå­æ€§ï¼Œä¸ä¿è¯é¡ºåº

===== Acquire-Release =====

å†™å…¥å®Œæˆ
è¯»å–åˆ°: 42
Acquire-Release å»ºç«‹ happens-before å…³ç³»

===== SeqCst é¡ºåº =====

SeqCst è®¡æ•°: 1
ä¿è¯å…¨å±€ä¸€è‡´çš„é¡ºåº

===== Fence å±éšœ =====

é€šè¿‡fenceè¯»å–: 100

===== å†…å­˜é¡ºåºå¯¹æ¯” =====

| é¡ºåº | ä¿è¯ | æ€§èƒ½ | ä½¿ç”¨åœºæ™¯ |
| --- | --- | --- | --- |
| Relaxed | åŸå­æ€§ | æœ€å¿« | è®¡æ•°å™¨ |
| Acquire | åŒæ­¥è¯» | å¿« | è¯»å–æ ‡å¿— |
| Release | åŒæ­¥å†™ | å¿« | è®¾ç½®æ ‡å¿— |
| AcqRel | è¯»å†™åŒæ­¥ | ä¸­ | RMWæ“ä½œ |
| SeqCst | å…¨å±€é¡ºåº | æ…¢ | å¤æ‚åŒæ­¥ |
```

---

### ç¤ºä¾‹3.6: æ€§èƒ½åˆ†æ

**ç›®æ ‡**: åˆ†æå¹¶å‘ç¨‹åºçš„æ€§èƒ½

**éš¾åº¦**: â­â­â­â­

**ä»£ç **:

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
use std::time::{Duration, Instant};

fn main() {
    println!("===== Mutex vs RwLock vs Atomic =====\n");

    const THREADS: usize = 8;
    const ITERATIONS: usize = 100_000;

    // Mutex æ€§èƒ½æµ‹è¯•
    let mutex_counter = Arc::new(Mutex::new(0));
    let start = Instant::now();

    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&mutex_counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.lock().unwrap() += 1;
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let mutex_time = start.elapsed();
    println!("Mutex: {:?}", mutex_time);

    // RwLock æ€§èƒ½æµ‹è¯•ï¼ˆå†™å¯†é›†ï¼‰
    let rwlock_counter = Arc::new(RwLock::new(0));
    let start = Instant::now();

    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&rwlock_counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.write().unwrap() += 1;
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let rwlock_time = start.elapsed();
    println!("RwLock (write): {:?}", rwlock_time);

    // Atomic æ€§èƒ½æµ‹è¯•
    let atomic_counter = Arc::new(AtomicUsize::new(0));
    let start = Instant::now();

    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&atomic_counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                counter.fetch_add(1, Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let atomic_time = start.elapsed();
    println!("Atomic: {:?}", atomic_time);

    println!("\nç›¸å¯¹æ€§èƒ½:");
    println!("  Atomic: 1.0x (fastest)");
    println!("  Mutex: {:.2}x", mutex_time.as_secs_f64() / atomic_time.as_secs_f64());
    println!("  RwLock: {:.2}x", rwlock_time.as_secs_f64() / atomic_time.as_secs_f64());

    println!("\n===== RwLock è¯»å¤šå†™å°‘ =====\n");

    let rwlock_data = Arc::new(RwLock::new(0));
    let start = Instant::now();

    let mut handles = vec![];

    // 7ä¸ªè¯»çº¿ç¨‹
    for _ in 0..7 {
        let data = Arc::clone(&rwlock_data);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                let _ = *data.read().unwrap();
            }
        });
        handles.push(handle);
    }

    // 1ä¸ªå†™çº¿ç¨‹
    let data = Arc::clone(&rwlock_data);
    let handle = thread::spawn(move || {
        for _ in 0..ITERATIONS {
            *data.write().unwrap() += 1;
        }
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }

    let rwlock_read_time = start.elapsed();
    println!("RwLock (read-heavy): {:?}", rwlock_read_time);

    println!("\n===== çº¿ç¨‹æ•°é‡å½±å“ =====\n");

    for num_threads in [1, 2, 4, 8, 16] {
        let counter = Arc::new(AtomicUsize::new(0));
        let start = Instant::now();

        let mut handles = vec![];
        for _ in 0..num_threads {
            let counter = Arc::clone(&counter);
            let handle = thread::spawn(move || {
                for _ in 0..ITERATIONS {
                    counter.fetch_add(1, Ordering::Relaxed);
                }
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.join().unwrap();
        }

        let elapsed = start.elapsed();
        let ops_per_sec = (num_threads * ITERATIONS) as f64 / elapsed.as_secs_f64();

        println!("{:2} çº¿ç¨‹: {:?} ({:.0} ops/sec)",
                 num_threads, elapsed, ops_per_sec);
    }

    println!("\n===== é”ç«äº‰åˆ†æ =====\n");

    let counter = Arc::new(Mutex::new(0));

    // ä½ç«äº‰
    let start = Instant::now();
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.lock().unwrap() += 1;
                thread::yield_now(); // é™ä½ç«äº‰
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    let low_contention = start.elapsed();

    // é«˜ç«äº‰
    let counter = Arc::new(Mutex::new(0));
    let start = Instant::now();
    let mut handles = vec![];
    for _ in 0..THREADS {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..ITERATIONS {
                *counter.lock().unwrap() += 1;
                // ä¸yieldï¼Œé«˜ç«äº‰
            }
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    let high_contention = start.elapsed();

    println!("ä½ç«äº‰: {:?}", low_contention);
    println!("é«˜ç«äº‰: {:?}", high_contention);
    println!("ç«äº‰å½±å“: {:.2}x", high_contention.as_secs_f64() / low_contention.as_secs_f64());
}
```

**è¯´æ˜**:

- **æ€§èƒ½å¯¹æ¯”**: Atomic > Mutex > RwLock(write)
- **è¯»å¤šå†™å°‘**: RwLock ä¼˜åŠ¿æ˜æ˜¾
- **é”ç«äº‰**: ä¸¥é‡å½±å“æ€§èƒ½
- **çº¿ç¨‹æ‰©å±•**: è§‚å¯Ÿå¹¶è¡Œæ•ˆç‡

**è¾“å‡º**:

```text
===== Mutex vs RwLock vs Atomic =====

Mutex: 523ms
RwLock (write): 687ms
Atomic: 145ms

ç›¸å¯¹æ€§èƒ½:
  Atomic: 1.0x (fastest)
  Mutex: 3.61x
  RwLock: 4.74x

===== RwLock è¯»å¤šå†™å°‘ =====

RwLock (read-heavy): 234ms

===== çº¿ç¨‹æ•°é‡å½±å“ =====

 1 çº¿ç¨‹: 18ms (5555555 ops/sec)
 2 çº¿ç¨‹: 45ms (4444444 ops/sec)
 4 çº¿ç¨‹: 120ms (3333333 ops/sec)
 8 çº¿ç¨‹: 145ms (5517241 ops/sec)
16 çº¿ç¨‹: 178ms (8988764 ops/sec)

===== é”ç«äº‰åˆ†æ =====

ä½ç«äº‰: 1234ms
é«˜ç«äº‰: 523ms
ç«äº‰å½±å“: 0.42x
```

---

## ğŸ“ æ€»ç»“

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **ç¬¬ä¸€é˜¶æ®µ** (Tier 1): æŒæ¡åŸºç¡€ (ç¤ºä¾‹ 1.1-1.6)
   - çº¿ç¨‹åˆ›å»ºå’Œç®¡ç†
   - move è¯­ä¹‰
   - panic å¤„ç†
   - Send å’Œ Sync

2. **ç¬¬äºŒé˜¶æ®µ** (Tier 2): å®è·µåº”ç”¨ (ç¤ºä¾‹ 2.1-2.6)
   - Arc å…±äº«æ‰€æœ‰æƒ
   - Mutex äº’æ–¥é”
   - RwLock è¯»å†™é”
   - Condvar æ¡ä»¶å˜é‡
   - Channel æ¶ˆæ¯ä¼ é€’
   - Atomic åŸå­æ“ä½œ

3. **ç¬¬ä¸‰é˜¶æ®µ** (Tier 3): æ·±å…¥ç†è§£ (ç¤ºä¾‹ 3.1-3.6)
   - çº¿ç¨‹æ± å®ç°
   - å·¥ä½œçªƒå–
   - å¹¶å‘æ•°æ®ç»“æ„
   - æ— é”ç¼–ç¨‹
   - å†…å­˜é¡ºåº
   - æ€§èƒ½åˆ†æ

### æ ¸å¿ƒæ¦‚å¿µæ€»ç»“

| æ¦‚å¿µ      | ç›¸å…³ç¤ºä¾‹ | é‡è¦æ€§     | éš¾åº¦     |
| --------- | -------- | ---------- | -------- |
| çº¿ç¨‹åˆ›å»º  | 1.1      | â­â­â­â­â­ | â­       |
| moveè¯­ä¹‰  | 1.2      | â­â­â­â­â­ | â­       |
| Send/Sync | 1.5      | â­â­â­â­â­ | â­â­     |
| Arc       | 2.1      | â­â­â­â­â­ | â­â­     |
| Mutex     | 2.2      | â­â­â­â­â­ | â­â­     |
| Channel   | 2.4      | â­â­â­â­   | â­â­â­   |
| Atomic    | 3.1      | â­â­â­â­   | â­â­â­â­ |

### æœ€ä½³å®è·µ

1. **é€‰æ‹©å¹¶å‘æ¨¡å¼**:
   - å…±äº«çŠ¶æ€ï¼šArc + Mutex/RwLock
   - æ¶ˆæ¯ä¼ é€’ï¼šChannel
   - å¹¶è¡Œè®¡ç®—ï¼šRayon

2. **é¿å…æ­»é”**:
   - æŒ‰å›ºå®šé¡ºåºè·å–é”
   - ä½¿ç”¨ try_lock
   - é™åˆ¶é”çš„ä½œç”¨åŸŸ

3. **æ€§èƒ½ä¼˜åŒ–**:
   - è¯»å¤šå†™å°‘ï¼šä½¿ç”¨ RwLock
   - ç®€å•è®¡æ•°ï¼šä½¿ç”¨ Atomic
   - CPUå¯†é›†ï¼šä½¿ç”¨çº¿ç¨‹æ± 

4. **é”™è¯¯å¤„ç†**:
   - join æ£€æŸ¥ panic
   - Channel æ£€æŸ¥æ–­å¼€
   - ä½¿ç”¨ Result ä¼ é€’é”™è¯¯

### ä¸‹ä¸€æ­¥

- ğŸ“– æ·±å…¥å­¦ä¹ : [åŒæ­¥åŸè¯­å®è·µ](./02_åŒæ­¥åŸè¯­å®è·µ.md)
- ğŸ“– æ·±å…¥å­¦ä¹ : [æ¶ˆæ¯ä¼ é€’æ¨¡å¼](./03_æ¶ˆæ¯ä¼ é€’æ¨¡å¼.md)
- ğŸš€ å®æˆ˜é¡¹ç›®: [C05 å®æˆ˜é¡¹ç›®é›†](./07_å®æˆ˜é¡¹ç›®é›†.md) (å³å°†åˆ›å»º)
- ğŸ“š å‚è€ƒæ–‡æ¡£: [tier_03_references](../tier_03_references/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤

**ğŸ’¡ å¹¶å‘ç¼–ç¨‹æ˜¯ Rust çš„æ ¸å¿ƒä¼˜åŠ¿ï¼Œç±»å‹ç³»ç»Ÿä¿è¯çº¿ç¨‹å®‰å…¨ï¼ğŸ¦€**-
