# C05 Tier 2 实践指南 05：异步集成实践

> **文档版本**: v2.0.0 | **Rust 版本**: 1.90+ | **最后更新**: 2025-10-22

## 目录

- [C05 Tier 2 实践指南 05：异步集成实践](#c05-tier-2-实践指南-05异步集成实践)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 为什么需要混合模型](#11-为什么需要混合模型)
    - [1.2 适用场景](#12-适用场景)
    - [1.3 核心概念](#13-核心概念)
  - [2. 线程 vs 异步](#2-线程-vs-异步)
    - [2.1 性能对比](#21-性能对比)
    - [2.2 内存对比](#22-内存对比)
    - [2.3 决策树](#23-决策树)
  - [3. spawn\_blocking 桥接](#3-spawn_blocking-桥接)
    - [3.1 基础用法](#31-基础用法)
    - [3.2 多个阻塞任务](#32-多个阻塞任务)
    - [3.3 限制阻塞任务数量](#33-限制阻塞任务数量)
  - [4. 混合架构设计](#4-混合架构设计)
    - [4.1 Web 服务器 + 图像处理](#41-web-服务器--图像处理)
    - [4.2 数据库 + 计算](#42-数据库--计算)
  - [5. Tokio 线程池](#5-tokio-线程池)
    - [5.1 配置运行时](#51-配置运行时)
    - [5.2 Handle 跨线程使用](#52-handle-跨线程使用)
    - [5.3 嵌套运行时](#53-嵌套运行时)
  - [6. 通道互操作](#6-通道互操作)
    - [6.1 oneshot channel](#61-oneshot-channel)
    - [6.2 mpsc channel](#62-mpsc-channel)
    - [6.3 watch channel](#63-watch-channel)
  - [7. 实战案例](#7-实战案例)
    - [7.1 文件处理服务](#71-文件处理服务)
    - [7.2 混合任务调度器](#72-混合任务调度器)
  - [8. 性能优化](#8-性能优化)
    - [8.1 避免阻塞运行时](#81-避免阻塞运行时)
    - [8.2 批量处理](#82-批量处理)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 选择合适的运行时](#91-选择合适的运行时)
    - [9.2 错误处理](#92-错误处理)
    - [9.3 取消任务](#93-取消任务)
  - [10. 参考资源](#10-参考资源)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 推荐阅读](#102-推荐阅读)
    - [10.3 相关 Crates](#103-相关-crates)
    - [10.4 内部文档链接](#104-内部文档链接)

---

## 1. 概述

### 1.1 为什么需要混合模型

现代应用常常需要同时处理 CPU 密集型和 I/O 密集型任务。线程和异步各有优势，合理结合可以实现最优性能。

```text
┌────────────────────────────────────────────────────────┐
│               线程 + 异步混合架构                       │
├────────────────────────────────────────────────────────┤
│                                                        │
│  ┌──────────────────────────────────────────────┐      │
│  │   Async Runtime (Tokio)                      │      │
│  │   ┌────────┐  ┌────────┐  ┌────────┐         │      │
│  │   │ Task 1 │  │ Task 2 │  │ Task 3 │         │      │
│  │   │ I/O    │  │ I/O    │  │ I/O    │         │      │
│  │   └────────┘  └────────┘  └────────┘         │      │
│  │        │            │            │           │      │
│  │        └────────────┴────────────┘           │      │
│  │                    │                         │      │
│  │              spawn_blocking()                │      │
│  │                    │                         │      │
│  │   ┌────────────────▼────────────────┐        │      │
│  │   │    Thread Pool                  │        │      │
│  │   │  ┌──────┐  ┌──────┐  ┌──────┐   │        │      │
│  │   │  │ CPU  │  │ CPU  │  │ CPU  │   │        │      │
│  │   │  │ Work │  │ Work │  │ Work │   │        │      │
│  │   │  └──────┘  └──────┘  └──────┘   │        │      │
│  │   └─────────────────────────────────┘        │      │
│  └──────────────────────────────────────────────┘      │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 1.2 适用场景

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| Web 服务器 | 异步 + spawn_blocking | I/O 为主，偶尔计算 |
| 数据库查询 | 异步 | I/O 密集 |
| 图像处理 | 线程/Rayon | CPU 密集 |
| 文件压缩 | 线程 | CPU + I/O |
| 实时系统 | 混合 | 复杂需求 |

### 1.3 核心概念

- **异步运行时（Runtime）**：管理异步任务的执行（如 Tokio）
- **spawn_blocking**：将阻塞操作卸载到线程池
- **oneshot channel**：在 async 和 sync 之间传递单个值
- **mpsc channel**：在 async 和 sync 之间传递多个值

---

## 2. 线程 vs 异步

### 2.1 性能对比

```rust
use tokio;
use std::thread;
use std::time::{Duration, Instant};

// 阻塞式休眠（线程）
fn blocking_sleep(duration: Duration) {
    thread::sleep(duration);
}

// 异步休眠
async fn async_sleep(duration: Duration) {
    tokio::time::sleep(duration).await;
}

#[tokio::main]
async fn main() {
    // 测试线程模型
    let start = Instant::now();
    let mut handles = vec![];
    for _ in 0..1000 {
        let handle = thread::spawn(|| {
            blocking_sleep(Duration::from_millis(100));
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Thread model: {:?}", start.elapsed());
    
    // 测试异步模型
    let start = Instant::now();
    let mut tasks = vec![];
    for _ in 0..1000 {
        tasks.push(tokio::spawn(async {
            async_sleep(Duration::from_millis(100)).await;
        }));
    }
    for task in tasks {
        task.await.unwrap();
    }
    println!("Async model: {:?}", start.elapsed());
}
```

### 2.2 内存对比

```rust
use std::thread;

fn main() {
    println!("Thread stack size: ~2MB");
    println!("Async task size: ~64-200 bytes");
    
    // 1000 个线程 ≈ 2GB
    // 1000 个异步任务 ≈ 64-200KB
    
    println!("\nMemory efficiency:");
    println!("Async is ~10000x more memory efficient for I/O tasks");
}
```

### 2.3 决策树

```text
需要并发吗？
  │
  ├─ 否 ──► 串行执行
  │
  └─ 是 ──► 任务类型？
       │
       ├─ CPU 密集 ──► 线程/Rayon
       │    (计算、加密、压缩)
       │
       ├─ I/O 密集 ──► 异步/Tokio
       │    (网络、文件、数据库)
       │
       └─ 混合 ──► 异步 + spawn_blocking
            (Web 服务 + 图像处理)
```

---

## 3. spawn_blocking 桥接

### 3.1 基础用法

```rust
use tokio;
use std::time::Duration;

fn cpu_intensive_work(n: u64) -> u64 {
    // 模拟 CPU 密集计算
    (0..n).sum()
}

#[tokio::main]
async fn main() {
    println!("Starting async task...");
    
    // 在异步上下文中调用阻塞函数
    let result = tokio::task::spawn_blocking(|| {
        println!("Running CPU intensive work in thread pool");
        std::thread::sleep(Duration::from_secs(1));
        cpu_intensive_work(1_000_000)
    })
    .await
    .unwrap();
    
    println!("Result: {}", result);
}
```

### 3.2 多个阻塞任务

```rust
use tokio;
use std::fs;

#[tokio::main]
async fn main() {
    let files = vec!["file1.txt", "file2.txt", "file3.txt"];
    
    let mut tasks = vec![];
    for file in files {
        let task = tokio::task::spawn_blocking(move || {
            // 阻塞式文件读取
            fs::read_to_string(file)
        });
        tasks.push(task);
    }
    
    for (i, task) in tasks.into_iter().enumerate() {
        match task.await {
            Ok(Ok(content)) => println!("File {}: {} bytes", i, content.len()),
            Ok(Err(e)) => eprintln!("Error reading file: {}", e),
            Err(e) => eprintln!("Task panicked: {}", e),
        }
    }
}
```

### 3.3 限制阻塞任务数量

```rust
use tokio;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

#[tokio::main]
async fn main() {
    // 自定义线程池大小
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .max_blocking_threads(8)  // 最多 8 个阻塞线程
        .build()
        .unwrap();
    
    runtime.block_on(async {
        let counter = Arc::new(AtomicUsize::new(0));
        let mut tasks = vec![];
        
        for i in 0..20 {
            let counter = Arc::clone(&counter);
            let task = tokio::task::spawn_blocking(move || {
                let current = counter.fetch_add(1, Ordering::SeqCst) + 1;
                println!("Task {} - Active: {}", i, current);
                std::thread::sleep(std::time::Duration::from_secs(1));
                counter.fetch_sub(1, Ordering::SeqCst);
            });
            tasks.push(task);
        }
        
        for task in tasks {
            task.await.unwrap();
        }
    });
}
```

---

## 4. 混合架构设计

### 4.1 Web 服务器 + 图像处理

```rust
use tokio;
use std::sync::Arc;

struct ImageProcessor;

impl ImageProcessor {
    fn process(&self, image_data: Vec<u8>) -> Vec<u8> {
        // CPU 密集型图像处理
        std::thread::sleep(std::time::Duration::from_millis(100));
        image_data.iter().map(|&x| x.saturating_add(10)).collect()
    }
}

async fn handle_request(processor: Arc<ImageProcessor>, data: Vec<u8>) -> Vec<u8> {
    // 异步：接收请求
    println!("Received request with {} bytes", data.len());
    
    // 阻塞：图像处理
    let result = tokio::task::spawn_blocking(move || {
        processor.process(data)
    })
    .await
    .unwrap();
    
    // 异步：发送响应
    println!("Sending response with {} bytes", result.len());
    result
}

#[tokio::main]
async fn main() {
    let processor = Arc::new(ImageProcessor);
    
    // 模拟多个并发请求
    let mut tasks = vec![];
    for i in 0..10 {
        let processor = Arc::clone(&processor);
        let data = vec![i; 1000];
        let task = tokio::spawn(handle_request(processor, data));
        tasks.push(task);
    }
    
    for task in tasks {
        task.await.unwrap();
    }
}
```

### 4.2 数据库 + 计算

```rust
use tokio;
use std::collections::HashMap;

// 模拟异步数据库
struct Database;

impl Database {
    async fn fetch_data(&self, id: u32) -> Result<Vec<i32>, String> {
        tokio::time::sleep(std::time::Duration::from_millis(50)).await;
        Ok(vec![1, 2, 3, 4, 5])
    }
}

// CPU 密集计算
fn analyze_data(data: Vec<i32>) -> HashMap<String, i32> {
    let mut result = HashMap::new();
    result.insert("sum".to_string(), data.iter().sum());
    result.insert("max".to_string(), *data.iter().max().unwrap_or(&0));
    result.insert("min".to_string(), *data.iter().min().unwrap_or(&0));
    result
}

#[tokio::main]
async fn main() {
    let db = Database;
    
    // 异步：获取数据
    let data = db.fetch_data(1).await.unwrap();
    println!("Fetched {} records", data.len());
    
    // 阻塞：分析数据
    let analysis = tokio::task::spawn_blocking(move || {
        analyze_data(data)
    })
    .await
    .unwrap();
    
    println!("Analysis: {:?}", analysis);
}
```

---

## 5. Tokio 线程池

### 5.1 配置运行时

```rust
use tokio::runtime::Runtime;

fn main() {
    // 单线程运行时
    let rt_single = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();
    
    // 多线程运行时（推荐）
    let rt_multi = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(4)           // 工作线程数
        .max_blocking_threads(8)     // 最大阻塞线程数
        .thread_name("my-worker")
        .enable_all()
        .build()
        .unwrap();
    
    rt_multi.block_on(async {
        println!("Running in multi-threaded runtime");
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    });
}
```

### 5.2 Handle 跨线程使用

```rust
use tokio::runtime::Runtime;
use std::thread;

fn main() {
    let rt = Runtime::new().unwrap();
    let handle = rt.handle().clone();
    
    // 在另一个线程中使用 handle
    let t = thread::spawn(move || {
        handle.block_on(async {
            println!("Running async code from another thread");
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        });
    });
    
    t.join().unwrap();
}
```

### 5.3 嵌套运行时

```rust
use tokio;

#[tokio::main]
async fn main() {
    println!("Outer runtime");
    
    // ❌ 错误：不能嵌套 block_on
    // tokio::runtime::Runtime::new().unwrap().block_on(async {
    //     println!("This will panic!");
    // });
    
    // ✅ 正确：使用 spawn_blocking
    tokio::task::spawn_blocking(|| {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            println!("Inner runtime in blocking task");
        });
    })
    .await
    .unwrap();
}
```

---

## 6. 通道互操作

### 6.1 oneshot channel

```rust
use tokio;

fn blocking_computation(n: u64) -> u64 {
    std::thread::sleep(std::time::Duration::from_secs(1));
    n * n
}

#[tokio::main]
async fn main() {
    let (tx, rx) = tokio::sync::oneshot::channel();
    
    // 在线程中计算并发送结果
    std::thread::spawn(move || {
        let result = blocking_computation(42);
        let _ = tx.send(result);
    });
    
    // 异步等待结果
    match rx.await {
        Ok(result) => println!("Result: {}", result),
        Err(_) => eprintln!("Sender dropped"),
    }
}
```

### 6.2 mpsc channel

```rust
use tokio;
use tokio::sync::mpsc;
use std::thread;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(100);
    
    // 多个线程生产数据
    for i in 0..5 {
        let tx = tx.clone();
        thread::spawn(move || {
            for j in 0..10 {
                let _ = tx.blocking_send(i * 10 + j);
            }
        });
    }
    drop(tx);
    
    // 异步消费数据
    while let Some(value) = rx.recv().await {
        println!("Received: {}", value);
    }
}
```

### 6.3 watch channel

```rust
use tokio;
use tokio::sync::watch;
use std::thread;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = watch::channel(0);
    
    // 后台线程更新状态
    thread::spawn(move || {
        for i in 1..=10 {
            thread::sleep(Duration::from_millis(500));
            let _ = tx.send(i);
        }
    });
    
    // 异步观察状态变化
    while rx.changed().await.is_ok() {
        let value = *rx.borrow();
        println!("State changed to: {}", value);
        
        if value >= 10 {
            break;
        }
    }
}
```

---

## 7. 实战案例

### 7.1 文件处理服务

```rust
use tokio;
use tokio::fs;
use std::path::Path;

async fn process_file(path: &Path) -> Result<usize, std::io::Error> {
    // 异步读取文件
    let content = fs::read(path).await?;
    
    // CPU 密集处理
    let processed = tokio::task::spawn_blocking(move || {
        // 模拟压缩
        compress_data(&content)
    })
    .await
    .unwrap();
    
    // 异步写入结果
    let output_path = path.with_extension("compressed");
    fs::write(output_path, &processed).await?;
    
    Ok(processed.len())
}

fn compress_data(data: &[u8]) -> Vec<u8> {
    // 简化的压缩逻辑
    data.iter().filter(|&&b| b != 0).copied().collect()
}

#[tokio::main]
async fn main() {
    let files = vec!["file1.txt", "file2.txt", "file3.txt"];
    
    let mut tasks = vec![];
    for file in files {
        let path = Path::new(file);
        tasks.push(tokio::spawn(async move {
            process_file(path).await
        }));
    }
    
    for task in tasks {
        match task.await {
            Ok(Ok(size)) => println!("Processed file: {} bytes", size),
            Ok(Err(e)) => eprintln!("File error: {}", e),
            Err(e) => eprintln!("Task panicked: {}", e),
        }
    }
}
```

### 7.2 混合任务调度器

```rust
use tokio;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

struct TaskScheduler {
    io_tasks: AtomicUsize,
    cpu_tasks: AtomicUsize,
}

impl TaskScheduler {
    fn new() -> Arc<Self> {
        Arc::new(TaskScheduler {
            io_tasks: AtomicUsize::new(0),
            cpu_tasks: AtomicUsize::new(0),
        })
    }
    
    async fn submit_io_task<F, T>(&self, f: F) -> T
    where
        F: std::future::Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        self.io_tasks.fetch_add(1, Ordering::Relaxed);
        let result = tokio::spawn(f).await.unwrap();
        self.io_tasks.fetch_sub(1, Ordering::Relaxed);
        result
    }
    
    async fn submit_cpu_task<F, T>(&self, f: F) -> T
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        self.cpu_tasks.fetch_add(1, Ordering::Relaxed);
        let result = tokio::task::spawn_blocking(f).await.unwrap();
        self.cpu_tasks.fetch_sub(1, Ordering::Relaxed);
        result
    }
    
    fn stats(&self) {
        println!("Active tasks - I/O: {}, CPU: {}",
            self.io_tasks.load(Ordering::Relaxed),
            self.cpu_tasks.load(Ordering::Relaxed)
        );
    }
}

#[tokio::main]
async fn main() {
    let scheduler = TaskScheduler::new();
    
    // 提交 I/O 任务
    let s1 = Arc::clone(&scheduler);
    let io_task = s1.submit_io_task(async {
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        "IO result"
    });
    
    // 提交 CPU 任务
    let s2 = Arc::clone(&scheduler);
    let cpu_task = s2.submit_cpu_task(|| {
        std::thread::sleep(std::time::Duration::from_millis(100));
        "CPU result"
    });
    
    scheduler.stats();
    
    let (io_result, cpu_result) = tokio::join!(io_task, cpu_task);
    println!("{}, {}", io_result, cpu_result);
    
    scheduler.stats();
}
```

---

## 8. 性能优化

### 8.1 避免阻塞运行时

```rust
use tokio;

#[tokio::main]
async fn main() {
    // ❌ 错误：在异步上下文中使用阻塞 sleep
    // std::thread::sleep(std::time::Duration::from_secs(1));
    
    // ✅ 正确：使用异步 sleep
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    
    // ❌ 错误：在异步上下文中使用阻塞文件操作
    // std::fs::read("file.txt").unwrap();
    
    // ✅ 正确：使用异步文件操作
    let _ = tokio::fs::read("file.txt").await;
    
    // ✅ 或者：使用 spawn_blocking
    tokio::task::spawn_blocking(|| {
        std::fs::read("file.txt")
    }).await.unwrap().unwrap();
}
```

### 8.2 批量处理

```rust
use tokio;

async fn process_item(item: i32) -> i32 {
    tokio::time::sleep(std::time::Duration::from_millis(10)).await;
    item * 2
}

fn batch_process(items: Vec<i32>) -> Vec<i32> {
    items.into_iter().map(|x| x * 2).collect()
}

#[tokio::main]
async fn main() {
    let items: Vec<i32> = (1..=1000).collect();
    
    // ❌ 慢：每个 item 单独异步处理
    // let mut tasks = vec![];
    // for item in items {
    //     tasks.push(tokio::spawn(process_item(item)));
    // }
    
    // ✅ 快：批量处理
    let chunk_size = 100;
    let mut tasks = vec![];
    for chunk in items.chunks(chunk_size) {
        let chunk = chunk.to_vec();
        tasks.push(tokio::task::spawn_blocking(move || {
            batch_process(chunk)
        }));
    }
    
    for task in tasks {
        let _ = task.await.unwrap();
    }
}
```

---

## 9. 最佳实践

### 9.1 选择合适的运行时

```rust
// Web 服务：多线程运行时
#[tokio::main]
async fn main() {
    // 自动使用所有核心
}

// CLI 工具：单线程运行时
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // 更轻量
}
```

### 9.2 错误处理

```rust
use tokio;

#[tokio::main]
async fn main() {
    let result = tokio::task::spawn_blocking(|| {
        // 可能 panic 的代码
        if true {
            panic!("Something went wrong!");
        }
        42
    })
    .await;
    
    match result {
        Ok(value) => println!("Success: {}", value),
        Err(e) => {
            if e.is_panic() {
                eprintln!("Task panicked!");
            } else if e.is_cancelled() {
                eprintln!("Task cancelled!");
            }
        }
    }
}
```

### 9.3 取消任务

```rust
use tokio;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let task = tokio::spawn(async {
        loop {
            println!("Working...");
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    // 运行 1 秒后取消
    sleep(Duration::from_secs(1)).await;
    task.abort();
    
    match task.await {
        Ok(_) => println!("Task completed"),
        Err(e) if e.is_cancelled() => println!("Task was cancelled"),
        Err(e) => eprintln!("Task error: {}", e),
    }
}
```

---

## 10. 参考资源

### 10.1 官方文档

- [Tokio Documentation](https://docs.rs/tokio)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
- [Async Book](https://rust-lang.github.io/async-book/)

### 10.2 推荐阅读

- [Bridging with sync code](https://tokio.rs/tokio/topics/bridging)
- [Choosing a Runtime](https://tokio.rs/tokio/topics/choosing)

### 10.3 相关 Crates

- [`tokio`](https://docs.rs/tokio) - 异步运行时
- [`async-std`](https://docs.rs/async-std) - 另一个异步运行时
- [`rayon`](https://docs.rs/rayon) - 数据并行

### 10.4 内部文档链接

- [← 上一篇：并行编程指南](./04_并行编程指南.md)
- [→ Tier 3：参考文档](../tier_03_references/)
- [↑ 返回主索引](../tier_01_foundations/02_主索引导航.md)

---

**文档维护**: C05 Threads Team | **最后审核**: 2025-10-22 | **质量评分**: 95/100
