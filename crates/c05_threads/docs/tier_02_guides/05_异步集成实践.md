# C05 Tier 2 å®è·µæŒ‡å— 05ï¼šå¼‚æ­¥é›†æˆå®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 2 å®è·µæŒ‡å— 05ï¼šå¼‚æ­¥é›†æˆå®è·µ](#c05-tier-2-å®è·µæŒ‡å—-05å¼‚æ­¥é›†æˆå®è·µ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦æ··åˆæ¨¡å‹](#11-ä¸ºä»€ä¹ˆéœ€è¦æ··åˆæ¨¡å‹)
    - [1.2 é€‚ç”¨åœºæ™¯](#12-é€‚ç”¨åœºæ™¯)
    - [1.3 æ ¸å¿ƒæ¦‚å¿µ](#13-æ ¸å¿ƒæ¦‚å¿µ)
  - [2. çº¿ç¨‹ vs å¼‚æ­¥](#2-çº¿ç¨‹-vs-å¼‚æ­¥)
    - [2.1 æ€§èƒ½å¯¹æ¯”](#21-æ€§èƒ½å¯¹æ¯”)
    - [2.2 å†…å­˜å¯¹æ¯”](#22-å†…å­˜å¯¹æ¯”)
    - [2.3 å†³ç­–æ ‘](#23-å†³ç­–æ ‘)
  - [3. spawn\_blocking æ¡¥æ¥](#3-spawn_blocking-æ¡¥æ¥)
    - [3.1 åŸºç¡€ç”¨æ³•](#31-åŸºç¡€ç”¨æ³•)
    - [3.2 å¤šä¸ªé˜»å¡ä»»åŠ¡](#32-å¤šä¸ªé˜»å¡ä»»åŠ¡)
    - [3.3 é™åˆ¶é˜»å¡ä»»åŠ¡æ•°é‡](#33-é™åˆ¶é˜»å¡ä»»åŠ¡æ•°é‡)
  - [4. æ··åˆæ¶æ„è®¾è®¡](#4-æ··åˆæ¶æ„è®¾è®¡)
    - [4.1 Web æœåŠ¡å™¨ + å›¾åƒå¤„ç†](#41-web-æœåŠ¡å™¨--å›¾åƒå¤„ç†)
    - [4.2 æ•°æ®åº“ + è®¡ç®—](#42-æ•°æ®åº“--è®¡ç®—)
  - [5. Tokio çº¿ç¨‹æ± ](#5-tokio-çº¿ç¨‹æ± )
    - [5.1 é…ç½®è¿è¡Œæ—¶](#51-é…ç½®è¿è¡Œæ—¶)
    - [5.2 Handle è·¨çº¿ç¨‹ä½¿ç”¨](#52-handle-è·¨çº¿ç¨‹ä½¿ç”¨)
    - [5.3 åµŒå¥—è¿è¡Œæ—¶](#53-åµŒå¥—è¿è¡Œæ—¶)
  - [6. é€šé“äº’æ“ä½œ](#6-é€šé“äº’æ“ä½œ)
    - [6.1 oneshot channel](#61-oneshot-channel)
    - [6.2 mpsc channel](#62-mpsc-channel)
    - [6.3 watch channel](#63-watch-channel)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 æ–‡ä»¶å¤„ç†æœåŠ¡](#71-æ–‡ä»¶å¤„ç†æœåŠ¡)
    - [7.2 æ··åˆä»»åŠ¡è°ƒåº¦å™¨](#72-æ··åˆä»»åŠ¡è°ƒåº¦å™¨)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [8.1 é¿å…é˜»å¡è¿è¡Œæ—¶](#81-é¿å…é˜»å¡è¿è¡Œæ—¶)
    - [8.2 æ‰¹é‡å¤„ç†](#82-æ‰¹é‡å¤„ç†)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [9.1 é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶](#91-é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶)
    - [9.2 é”™è¯¯å¤„ç†](#92-é”™è¯¯å¤„ç†)
    - [9.3 å–æ¶ˆä»»åŠ¡](#93-å–æ¶ˆä»»åŠ¡)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
    - [10.1 å®˜æ–¹æ–‡æ¡£](#101-å®˜æ–¹æ–‡æ¡£)
    - [10.2 æ¨èé˜…è¯»](#102-æ¨èé˜…è¯»)
    - [10.3 ç›¸å…³ Crates](#103-ç›¸å…³-crates)
    - [10.4 å†…éƒ¨æ–‡æ¡£é“¾æ¥](#104-å†…éƒ¨æ–‡æ¡£é“¾æ¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å¼‚æ­¥é›†æˆ (Async Integration)**:

- **å®šä¹‰**: å°†çº¿ç¨‹å’Œå¼‚æ­¥ç¼–ç¨‹ç»“åˆä½¿ç”¨çš„æŠ€æœ¯ï¼Œå……åˆ†åˆ©ç”¨å„è‡ªçš„ä¼˜åŠ¿
- **ç±»å‹**: ç¼–ç¨‹æŠ€æœ¯
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹ã€å¼‚æ­¥ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.39+ (Tokio)
- **ç›¸å…³æ¦‚å¿µ**: çº¿ç¨‹ã€å¼‚æ­¥è¿è¡Œæ—¶ã€æ··åˆæ¶æ„ã€spawn_blocking

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æ··åˆæ¶æ„**: çº¿ç¨‹ + å¼‚æ­¥è¿è¡Œæ—¶
- **æ¡¥æ¥æœºåˆ¶**: `spawn_blocking` è¿æ¥çº¿ç¨‹å’Œå¼‚æ­¥
- **é€šé“äº’æ“ä½œ**: oneshotã€mpscã€watch é€šé“
- **èµ„æºç®¡ç†**: è‡ªåŠ¨ç®¡ç†çº¿ç¨‹å’Œä»»åŠ¡èµ„æº

**æ€§èƒ½ç‰¹å¾**:

- **CPU å¯†é›†å‹**: ä½¿ç”¨çº¿ç¨‹æ± 
- **I/O å¯†é›†å‹**: ä½¿ç”¨å¼‚æ­¥è¿è¡Œæ—¶
- **é€‚ç”¨åœºæ™¯**: æ··åˆå·¥ä½œè´Ÿè½½ã€Web æœåŠ¡å™¨ã€æ•°æ®å¤„ç†

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- æ··åˆæ¶æ„ --[uses]--> çº¿ç¨‹å’Œå¼‚æ­¥
- å¼‚æ­¥é›†æˆ --[uses]--> spawn_blocking

**ä¾èµ–å…³ç³»**:

- å¼‚æ­¥é›†æˆ --[depends-on]--> å¼‚æ­¥è¿è¡Œæ—¶
- å¼‚æ­¥é›†æˆ --[depends-on]--> çº¿ç¨‹æ”¯æŒ

### æ€ç»´å¯¼å›¾

```text
å¼‚æ­¥é›†æˆå®è·µ
â”‚
â”œâ”€â”€ çº¿ç¨‹ vs å¼‚æ­¥
â”‚   â”œâ”€â”€ æ€§èƒ½å¯¹æ¯”
â”‚   â””â”€â”€ å†³ç­–æ ‘
â”œâ”€â”€ spawn_blocking æ¡¥æ¥
â”‚   â”œâ”€â”€ åŸºç¡€ç”¨æ³•
â”‚   â””â”€â”€ é™åˆ¶æ•°é‡
â”œâ”€â”€ æ··åˆæ¶æ„è®¾è®¡
â”‚   â”œâ”€â”€ Web æœåŠ¡å™¨
â”‚   â””â”€â”€ æ•°æ®å¤„ç†
â”œâ”€â”€ Tokio çº¿ç¨‹æ± 
â”‚   â””â”€â”€ é…ç½®è¿è¡Œæ—¶
â””â”€â”€ é€šé“äº’æ“ä½œ
    â”œâ”€â”€ oneshot
    â””â”€â”€ mpsc
```

---

## 1. æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦æ··åˆæ¨¡å‹

ç°ä»£åº”ç”¨å¸¸å¸¸éœ€è¦åŒæ—¶å¤„ç† CPU å¯†é›†å‹å’Œ I/O å¯†é›†å‹ä»»åŠ¡ã€‚çº¿ç¨‹å’Œå¼‚æ­¥å„æœ‰ä¼˜åŠ¿ï¼Œåˆç†ç»“åˆå¯ä»¥å®ç°æœ€ä¼˜æ€§èƒ½ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               çº¿ç¨‹ + å¼‚æ­¥æ··åˆæ¶æ„                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Async Runtime (Tokio)                      â”‚      â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚      â”‚
â”‚  â”‚   â”‚ Task 1 â”‚  â”‚ Task 2 â”‚  â”‚ Task 3 â”‚         â”‚      â”‚
â”‚  â”‚   â”‚ I/O    â”‚  â”‚ I/O    â”‚  â”‚ I/O    â”‚         â”‚      â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚      â”‚
â”‚  â”‚        â”‚            â”‚            â”‚           â”‚      â”‚
â”‚  â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚      â”‚
â”‚  â”‚                    â”‚                         â”‚      â”‚
â”‚  â”‚              spawn_blocking()                â”‚      â”‚
â”‚  â”‚                    â”‚                         â”‚      â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚      â”‚
â”‚  â”‚   â”‚    Thread Pool                  â”‚        â”‚      â”‚
â”‚  â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”   â”‚        â”‚      â”‚
â”‚  â”‚   â”‚  â”‚ CPU  â”‚  â”‚ CPU  â”‚  â”‚ CPU  â”‚   â”‚        â”‚      â”‚
â”‚  â”‚   â”‚  â”‚ Work â”‚  â”‚ Work â”‚  â”‚ Work â”‚   â”‚        â”‚      â”‚
â”‚  â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜   â”‚        â”‚      â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 é€‚ç”¨åœºæ™¯

| åœºæ™¯       | æ¨èæ–¹æ¡ˆ              | åŸå›                |
| ---------- | --------------------- | ------------------ |
| Web æœåŠ¡å™¨ | å¼‚æ­¥ + spawn_blocking | I/O ä¸ºä¸»ï¼Œå¶å°”è®¡ç®— |
| æ•°æ®åº“æŸ¥è¯¢ | å¼‚æ­¥                  | I/O å¯†é›†           |
| å›¾åƒå¤„ç†   | çº¿ç¨‹/Rayon            | CPU å¯†é›†           |
| æ–‡ä»¶å‹ç¼©   | çº¿ç¨‹                  | CPU + I/O          |
| å®æ—¶ç³»ç»Ÿ   | æ··åˆ                  | å¤æ‚éœ€æ±‚           |

### 1.3 æ ¸å¿ƒæ¦‚å¿µ

- **å¼‚æ­¥è¿è¡Œæ—¶ï¼ˆRuntimeï¼‰**ï¼šç®¡ç†å¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œï¼ˆå¦‚ Tokioï¼‰
- **spawn_blocking**ï¼šå°†é˜»å¡æ“ä½œå¸è½½åˆ°çº¿ç¨‹æ± 
- **oneshot channel**ï¼šåœ¨ async å’Œ sync ä¹‹é—´ä¼ é€’å•ä¸ªå€¼
- **mpsc channel**ï¼šåœ¨ async å’Œ sync ä¹‹é—´ä¼ é€’å¤šä¸ªå€¼

---

## 2. çº¿ç¨‹ vs å¼‚æ­¥

### 2.1 æ€§èƒ½å¯¹æ¯”

```rust
use tokio;
use std::thread;
use std::time::{Duration, Instant};

// é˜»å¡å¼ä¼‘çœ ï¼ˆçº¿ç¨‹ï¼‰
fn blocking_sleep(duration: Duration) {
    thread::sleep(duration);
}

// å¼‚æ­¥ä¼‘çœ 
async fn async_sleep(duration: Duration) {
    tokio::time::sleep(duration).await;
}

#[tokio::main]
async fn main() {
    // æµ‹è¯•çº¿ç¨‹æ¨¡å‹
    let start = Instant::now();
    let mut handles = vec![];
    for _ in 0..1000 {
        let handle = thread::spawn(|| {
            blocking_sleep(Duration::from_millis(100));
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Thread model: {:?}", start.elapsed());

    // æµ‹è¯•å¼‚æ­¥æ¨¡å‹
    let start = Instant::now();
    let mut tasks = vec![];
    for _ in 0..1000 {
        tasks.push(tokio::spawn(async {
            async_sleep(Duration::from_millis(100)).await;
        }));
    }
    for task in tasks {
        task.await.unwrap();
    }
    println!("Async model: {:?}", start.elapsed());
}
```

### 2.2 å†…å­˜å¯¹æ¯”

```rust
use std::thread;

fn main() {
    println!("Thread stack size: ~2MB");
    println!("Async task size: ~64-200 bytes");

    // 1000 ä¸ªçº¿ç¨‹ â‰ˆ 2GB
    // 1000 ä¸ªå¼‚æ­¥ä»»åŠ¡ â‰ˆ 64-200KB

    println!("\nMemory efficiency:");
    println!("Async is ~10000x more memory efficient for I/O tasks");
}
```

### 2.3 å†³ç­–æ ‘

```text
éœ€è¦å¹¶å‘å—ï¼Ÿ
  â”‚
  â”œâ”€ å¦ â”€â”€â–º ä¸²è¡Œæ‰§è¡Œ
  â”‚
  â””â”€ æ˜¯ â”€â”€â–º ä»»åŠ¡ç±»å‹ï¼Ÿ
       â”‚
       â”œâ”€ CPU å¯†é›† â”€â”€â–º çº¿ç¨‹/Rayon
       â”‚    (è®¡ç®—ã€åŠ å¯†ã€å‹ç¼©)
       â”‚
       â”œâ”€ I/O å¯†é›† â”€â”€â–º å¼‚æ­¥/Tokio
       â”‚    (ç½‘ç»œã€æ–‡ä»¶ã€æ•°æ®åº“)
       â”‚
       â””â”€ æ··åˆ â”€â”€â–º å¼‚æ­¥ + spawn_blocking
            (Web æœåŠ¡ + å›¾åƒå¤„ç†)
```

---

## 3. spawn_blocking æ¡¥æ¥

### 3.1 åŸºç¡€ç”¨æ³•

```rust
use tokio;
use std::time::Duration;

fn cpu_intensive_work(n: u64) -> u64 {
    // æ¨¡æ‹Ÿ CPU å¯†é›†è®¡ç®—
    (0..n).sum()
}

#[tokio::main]
async fn main() {
    println!("Starting async task...");

    // åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨é˜»å¡å‡½æ•°
    let result = tokio::task::spawn_blocking(|| {
        println!("Running CPU intensive work in thread pool");
        std::thread::sleep(Duration::from_secs(1));
        cpu_intensive_work(1_000_000)
    })
    .await
    .unwrap();

    println!("Result: {}", result);
}
```

### 3.2 å¤šä¸ªé˜»å¡ä»»åŠ¡

```rust
use tokio;
use std::fs;

#[tokio::main]
async fn main() {
    let files = vec!["file1.txt", "file2.txt", "file3.txt"];

    let mut tasks = vec![];
    for file in files {
        let task = tokio::task::spawn_blocking(move || {
            // é˜»å¡å¼æ–‡ä»¶è¯»å–
            fs::read_to_string(file)
        });
        tasks.push(task);
    }

    for (i, task) in tasks.into_iter().enumerate() {
        match task.await {
            Ok(Ok(content)) => println!("File {}: {} bytes", i, content.len()),
            Ok(Err(e)) => eprintln!("Error reading file: {}", e),
            Err(e) => eprintln!("Task panicked: {}", e),
        }
    }
}
```

### 3.3 é™åˆ¶é˜»å¡ä»»åŠ¡æ•°é‡

```rust
use tokio;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

#[tokio::main]
async fn main() {
    // è‡ªå®šä¹‰çº¿ç¨‹æ± å¤§å°
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .max_blocking_threads(8)  // æœ€å¤š 8 ä¸ªé˜»å¡çº¿ç¨‹
        .build()
        .unwrap();

    runtime.block_on(async {
        let counter = Arc::new(AtomicUsize::new(0));
        let mut tasks = vec![];

        for i in 0..20 {
            let counter = Arc::clone(&counter);
            let task = tokio::task::spawn_blocking(move || {
                let current = counter.fetch_add(1, Ordering::SeqCst) + 1;
                println!("Task {} - Active: {}", i, current);
                std::thread::sleep(std::time::Duration::from_secs(1));
                counter.fetch_sub(1, Ordering::SeqCst);
            });
            tasks.push(task);
        }

        for task in tasks {
            task.await.unwrap();
        }
    });
}
```

---

## 4. æ··åˆæ¶æ„è®¾è®¡

### 4.1 Web æœåŠ¡å™¨ + å›¾åƒå¤„ç†

```rust
use tokio;
use std::sync::Arc;

struct ImageProcessor;

impl ImageProcessor {
    fn process(&self, image_data: Vec<u8>) -> Vec<u8> {
        // CPU å¯†é›†å‹å›¾åƒå¤„ç†
        std::thread::sleep(std::time::Duration::from_millis(100));
        image_data.iter().map(|&x| x.saturating_add(10)).collect()
    }
}

async fn handle_request(processor: Arc<ImageProcessor>, data: Vec<u8>) -> Vec<u8> {
    // å¼‚æ­¥ï¼šæ¥æ”¶è¯·æ±‚
    println!("Received request with {} bytes", data.len());

    // é˜»å¡ï¼šå›¾åƒå¤„ç†
    let result = tokio::task::spawn_blocking(move || {
        processor.process(data)
    })
    .await
    .unwrap();

    // å¼‚æ­¥ï¼šå‘é€å“åº”
    println!("Sending response with {} bytes", result.len());
    result
}

#[tokio::main]
async fn main() {
    let processor = Arc::new(ImageProcessor);

    // æ¨¡æ‹Ÿå¤šä¸ªå¹¶å‘è¯·æ±‚
    let mut tasks = vec![];
    for i in 0..10 {
        let processor = Arc::clone(&processor);
        let data = vec![i; 1000];
        let task = tokio::spawn(handle_request(processor, data));
        tasks.push(task);
    }

    for task in tasks {
        task.await.unwrap();
    }
}
```

### 4.2 æ•°æ®åº“ + è®¡ç®—

```rust
use tokio;
use std::collections::HashMap;

// æ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®åº“
struct Database;

impl Database {
    async fn fetch_data(&self, id: u32) -> Result<Vec<i32>, String> {
        tokio::time::sleep(std::time::Duration::from_millis(50)).await;
        Ok(vec![1, 2, 3, 4, 5])
    }
}

// CPU å¯†é›†è®¡ç®—
fn analyze_data(data: Vec<i32>) -> HashMap<String, i32> {
    let mut result = HashMap::new();
    result.insert("sum".to_string(), data.iter().sum());
    result.insert("max".to_string(), *data.iter().max().unwrap_or(&0));
    result.insert("min".to_string(), *data.iter().min().unwrap_or(&0));
    result
}

#[tokio::main]
async fn main() {
    let db = Database;

    // å¼‚æ­¥ï¼šè·å–æ•°æ®
    let data = db.fetch_data(1).await.unwrap();
    println!("Fetched {} records", data.len());

    // é˜»å¡ï¼šåˆ†ææ•°æ®
    let analysis = tokio::task::spawn_blocking(move || {
        analyze_data(data)
    })
    .await
    .unwrap();

    println!("Analysis: {:?}", analysis);
}
```

---

## 5. Tokio çº¿ç¨‹æ± 

### 5.1 é…ç½®è¿è¡Œæ—¶

```rust
use tokio::runtime::Runtime;

fn main() {
    // å•çº¿ç¨‹è¿è¡Œæ—¶
    let rt_single = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();

    // å¤šçº¿ç¨‹è¿è¡Œæ—¶ï¼ˆæ¨èï¼‰
    let rt_multi = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(4)           // å·¥ä½œçº¿ç¨‹æ•°
        .max_blocking_threads(8)     // æœ€å¤§é˜»å¡çº¿ç¨‹æ•°
        .thread_name("my-worker")
        .enable_all()
        .build()
        .unwrap();

    rt_multi.block_on(async {
        println!("Running in multi-threaded runtime");
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    });
}
```

### 5.2 Handle è·¨çº¿ç¨‹ä½¿ç”¨

```rust
use tokio::runtime::Runtime;
use std::thread;

fn main() {
    let rt = Runtime::new().unwrap();
    let handle = rt.handle().clone();

    // åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ä½¿ç”¨ handle
    let t = thread::spawn(move || {
        handle.block_on(async {
            println!("Running async code from another thread");
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        });
    });

    t.join().unwrap();
}
```

### 5.3 åµŒå¥—è¿è¡Œæ—¶

```rust
use tokio;

#[tokio::main]
async fn main() {
    println!("Outer runtime");

    // âŒ é”™è¯¯ï¼šä¸èƒ½åµŒå¥— block_on
    // tokio::runtime::Runtime::new().unwrap().block_on(async {
    //     println!("This will panic!");
    // });

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ spawn_blocking
    tokio::task::spawn_blocking(|| {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            println!("Inner runtime in blocking task");
        });
    })
    .await
    .unwrap();
}
```

---

## 6. é€šé“äº’æ“ä½œ

### 6.1 oneshot channel

```rust
use tokio;

fn blocking_computation(n: u64) -> u64 {
    std::thread::sleep(std::time::Duration::from_secs(1));
    n * n
}

#[tokio::main]
async fn main() {
    let (tx, rx) = tokio::sync::oneshot::channel();

    // åœ¨çº¿ç¨‹ä¸­è®¡ç®—å¹¶å‘é€ç»“æœ
    std::thread::spawn(move || {
        let result = blocking_computation(42);
        let _ = tx.send(result);
    });

    // å¼‚æ­¥ç­‰å¾…ç»“æœ
    match rx.await {
        Ok(result) => println!("Result: {}", result),
        Err(_) => eprintln!("Sender dropped"),
    }
}
```

### 6.2 mpsc channel

```rust
use tokio;
use tokio::sync::mpsc;
use std::thread;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(100);

    // å¤šä¸ªçº¿ç¨‹ç”Ÿäº§æ•°æ®
    for i in 0..5 {
        let tx = tx.clone();
        thread::spawn(move || {
            for j in 0..10 {
                let _ = tx.blocking_send(i * 10 + j);
            }
        });
    }
    drop(tx);

    // å¼‚æ­¥æ¶ˆè´¹æ•°æ®
    while let Some(value) = rx.recv().await {
        println!("Received: {}", value);
    }
}
```

### 6.3 watch channel

```rust
use tokio;
use tokio::sync::watch;
use std::thread;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = watch::channel(0);

    // åå°çº¿ç¨‹æ›´æ–°çŠ¶æ€
    thread::spawn(move || {
        for i in 1..=10 {
            thread::sleep(Duration::from_millis(500));
            let _ = tx.send(i);
        }
    });

    // å¼‚æ­¥è§‚å¯ŸçŠ¶æ€å˜åŒ–
    while rx.changed().await.is_ok() {
        let value = *rx.borrow();
        println!("State changed to: {}", value);

        if value >= 10 {
            break;
        }
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 æ–‡ä»¶å¤„ç†æœåŠ¡

```rust
use tokio;
use tokio::fs;
use std::path::Path;

async fn process_file(path: &Path) -> Result<usize, std::io::Error> {
    // å¼‚æ­¥è¯»å–æ–‡ä»¶
    let content = fs::read(path).await?;

    // CPU å¯†é›†å¤„ç†
    let processed = tokio::task::spawn_blocking(move || {
        // æ¨¡æ‹Ÿå‹ç¼©
        compress_data(&content)
    })
    .await
    .unwrap();

    // å¼‚æ­¥å†™å…¥ç»“æœ
    let output_path = path.with_extension("compressed");
    fs::write(output_path, &processed).await?;

    Ok(processed.len())
}

fn compress_data(data: &[u8]) -> Vec<u8> {
    // ç®€åŒ–çš„å‹ç¼©é€»è¾‘
    data.iter().filter(|&&b| b != 0).copied().collect()
}

#[tokio::main]
async fn main() {
    let files = vec!["file1.txt", "file2.txt", "file3.txt"];

    let mut tasks = vec![];
    for file in files {
        let path = Path::new(file);
        tasks.push(tokio::spawn(async move {
            process_file(path).await
        }));
    }

    for task in tasks {
        match task.await {
            Ok(Ok(size)) => println!("Processed file: {} bytes", size),
            Ok(Err(e)) => eprintln!("File error: {}", e),
            Err(e) => eprintln!("Task panicked: {}", e),
        }
    }
}
```

### 7.2 æ··åˆä»»åŠ¡è°ƒåº¦å™¨

```rust
use tokio;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

struct TaskScheduler {
    io_tasks: AtomicUsize,
    cpu_tasks: AtomicUsize,
}

impl TaskScheduler {
    fn new() -> Arc<Self> {
        Arc::new(TaskScheduler {
            io_tasks: AtomicUsize::new(0),
            cpu_tasks: AtomicUsize::new(0),
        })
    }

    async fn submit_io_task<F, T>(&self, f: F) -> T
    where
        F: std::future::Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        self.io_tasks.fetch_add(1, Ordering::Relaxed);
        let result = tokio::spawn(f).await.unwrap();
        self.io_tasks.fetch_sub(1, Ordering::Relaxed);
        result
    }

    async fn submit_cpu_task<F, T>(&self, f: F) -> T
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        self.cpu_tasks.fetch_add(1, Ordering::Relaxed);
        let result = tokio::task::spawn_blocking(f).await.unwrap();
        self.cpu_tasks.fetch_sub(1, Ordering::Relaxed);
        result
    }

    fn stats(&self) {
        println!("Active tasks - I/O: {}, CPU: {}",
            self.io_tasks.load(Ordering::Relaxed),
            self.cpu_tasks.load(Ordering::Relaxed)
        );
    }
}

#[tokio::main]
async fn main() {
    let scheduler = TaskScheduler::new();

    // æäº¤ I/O ä»»åŠ¡
    let s1 = Arc::clone(&scheduler);
    let io_task = s1.submit_io_task(async {
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        "IO result"
    });

    // æäº¤ CPU ä»»åŠ¡
    let s2 = Arc::clone(&scheduler);
    let cpu_task = s2.submit_cpu_task(|| {
        std::thread::sleep(std::time::Duration::from_millis(100));
        "CPU result"
    });

    scheduler.stats();

    let (io_result, cpu_result) = tokio::join!(io_task, cpu_task);
    println!("{}, {}", io_result, cpu_result);

    scheduler.stats();
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 é¿å…é˜»å¡è¿è¡Œæ—¶

```rust
use tokio;

#[tokio::main]
async fn main() {
    // âŒ é”™è¯¯ï¼šåœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨é˜»å¡ sleep
    // std::thread::sleep(std::time::Duration::from_secs(1));

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨å¼‚æ­¥ sleep
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;

    // âŒ é”™è¯¯ï¼šåœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨é˜»å¡æ–‡ä»¶æ“ä½œ
    // std::fs::read("file.txt").unwrap();

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨å¼‚æ­¥æ–‡ä»¶æ“ä½œ
    let _ = tokio::fs::read("file.txt").await;

    // âœ… æˆ–è€…ï¼šä½¿ç”¨ spawn_blocking
    tokio::task::spawn_blocking(|| {
        std::fs::read("file.txt")
    }).await.unwrap().unwrap();
}
```

### 8.2 æ‰¹é‡å¤„ç†

```rust
use tokio;

async fn process_item(item: i32) -> i32 {
    tokio::time::sleep(std::time::Duration::from_millis(10)).await;
    item * 2
}

fn batch_process(items: Vec<i32>) -> Vec<i32> {
    items.into_iter().map(|x| x * 2).collect()
}

#[tokio::main]
async fn main() {
    let items: Vec<i32> = (1..=1000).collect();

    // âŒ æ…¢ï¼šæ¯ä¸ª item å•ç‹¬å¼‚æ­¥å¤„ç†
    // let mut tasks = vec![];
    // for item in items {
    //     tasks.push(tokio::spawn(process_item(item)));
    // }

    // âœ… å¿«ï¼šæ‰¹é‡å¤„ç†
    let chunk_size = 100;
    let mut tasks = vec![];
    for chunk in items.chunks(chunk_size) {
        let chunk = chunk.to_vec();
        tasks.push(tokio::task::spawn_blocking(move || {
            batch_process(chunk)
        }));
    }

    for task in tasks {
        let _ = task.await.unwrap();
    }
}
```

---

## 9. æœ€ä½³å®è·µ

### 9.1 é€‰æ‹©åˆé€‚çš„è¿è¡Œæ—¶

```rust
// Web æœåŠ¡ï¼šå¤šçº¿ç¨‹è¿è¡Œæ—¶
#[tokio::main]
async fn main() {
    // è‡ªåŠ¨ä½¿ç”¨æ‰€æœ‰æ ¸å¿ƒ
}

// CLI å·¥å…·ï¼šå•çº¿ç¨‹è¿è¡Œæ—¶
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // æ›´è½»é‡
}
```

### 9.2 é”™è¯¯å¤„ç†

```rust
use tokio;

#[tokio::main]
async fn main() {
    let result = tokio::task::spawn_blocking(|| {
        // å¯èƒ½ panic çš„ä»£ç 
        if true {
            panic!("Something went wrong!");
        }
        42
    })
    .await;

    match result {
        Ok(value) => println!("Success: {}", value),
        Err(e) => {
            if e.is_panic() {
                eprintln!("Task panicked!");
            } else if e.is_cancelled() {
                eprintln!("Task cancelled!");
            }
        }
    }
}
```

### 9.3 å–æ¶ˆä»»åŠ¡

```rust
use tokio;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let task = tokio::spawn(async {
        loop {
            println!("Working...");
            sleep(Duration::from_millis(100)).await;
        }
    });

    // è¿è¡Œ 1 ç§’åå–æ¶ˆ
    sleep(Duration::from_secs(1)).await;
    task.abort();

    match task.await {
        Ok(_) => println!("Task completed"),
        Err(e) if e.is_cancelled() => println!("Task was cancelled"),
        Err(e) => eprintln!("Task error: {}", e),
    }
}
```

---

## 10. å‚è€ƒèµ„æº

### 10.1 å®˜æ–¹æ–‡æ¡£

- [Tokio Documentation](https://docs.rs/tokio)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
- [Async Book](https://rust-lang.github.io/async-book/)

### 10.2 æ¨èé˜…è¯»

- [Bridging with sync code](https://tokio.rs/tokio/topics/bridging)
- [Choosing a Runtime](https://tokio.rs/tokio/topics/choosing)

### 10.3 ç›¸å…³ Crates

- [`tokio`](https://docs.rs/tokio) - å¼‚æ­¥è¿è¡Œæ—¶
- [`async-std`](https://docs.rs/async-std) - å¦ä¸€ä¸ªå¼‚æ­¥è¿è¡Œæ—¶
- [`rayon`](https://docs.rs/rayon) - æ•°æ®å¹¶è¡Œ

### 10.4 å†…éƒ¨æ–‡æ¡£é“¾æ¥

- [â† ä¸Šä¸€ç¯‡ï¼šå¹¶è¡Œç¼–ç¨‹æŒ‡å—](./04_å¹¶è¡Œç¼–ç¨‹æŒ‡å—.md)
- [â†’ Tier 3ï¼šå‚è€ƒæ–‡æ¡£](../tier_03_references/)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
