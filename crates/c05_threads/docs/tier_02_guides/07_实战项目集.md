# ğŸ§µ C05: Threads - å®æˆ˜é¡¹ç›®é›†

> **åˆ›å»ºæ—¥æœŸ**: 2025-10-25
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **é€‚ç”¨æ¨¡å—**: C05 çº¿ç¨‹å’Œå¹¶å‘
> **ç›®æ ‡**: é€šè¿‡å®æˆ˜é¡¹ç›®æŒæ¡çº¿ç¨‹ç¼–ç¨‹å’Œå¹¶å‘æ§åˆ¶

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å®æˆ˜é¡¹ç›®é›† (Practical Projects Collection)**:

- **å®šä¹‰**: æ”¶é›†å’Œç»„ç»‡çš„å®æˆ˜é¡¹ç›®é›†åˆï¼Œç”¨äºæ¼”ç¤ºçº¿ç¨‹ç¼–ç¨‹å’Œå¹¶å‘æ§åˆ¶çš„å®é™…åº”ç”¨
- **ç±»å‹**: é¡¹ç›®é›†åˆæ–‡æ¡£
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹ã€é¡¹ç›®å®è·µ
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: çº¿ç¨‹ã€å¹¶å‘ã€åŒæ­¥åŸè¯­ã€é¡¹ç›®å®è·µ

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å±‚æ¬¡æ€§**: ä»ç®€å•åˆ°å¤æ‚çš„é¡¹ç›®
- **å®ç”¨æ€§**: è§£å†³å®é™…é—®é¢˜
- **å®Œæ•´æ€§**: æ¯ä¸ªé¡¹ç›®éƒ½æœ‰å®Œæ•´å®ç°
- **å¯è¿è¡Œæ€§**: æ‰€æœ‰é¡¹ç›®éƒ½å¯ä»¥è¿è¡Œ

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- å®æˆ˜é¡¹ç›®é›† --[contains]--> å¤šä¸ªå®æˆ˜é¡¹ç›®
- å­¦ä¹ è·¯å¾„ --[uses]--> å®æˆ˜é¡¹ç›®é›†

**ä¾èµ–å…³ç³»**:

- å®æˆ˜é¡¹ç›®é›† --[depends-on]--> çº¿ç¨‹ç¼–ç¨‹çŸ¥è¯†
- é¡¹ç›®å®è·µ --[depends-on]--> å®æˆ˜é¡¹ç›®é›†

### æ€ç»´å¯¼å›¾

```text
å®æˆ˜é¡¹ç›®é›†
â”‚
â”œâ”€â”€ ç®€å•çº¿ç¨‹æ± 
â”‚   â””â”€â”€ thread::spawn
â”œâ”€â”€ å¹¶å‘é˜Ÿåˆ—
â”‚   â””â”€â”€ Arc/Mutex
â””â”€â”€ ç”Ÿäº§è€…-æ¶ˆè´¹è€…
    â””â”€â”€ mpsc
```

---

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ

| #   | é¡¹ç›®åç§°                                  | éš¾åº¦   | é¢„è®¡æ—¶é—´ | æ ¸å¿ƒæ¦‚å¿µ                  |
| --- | ----------------------------------------- | ------ | -------- | ------------------------- |
| 1   | [ç®€å•çº¿ç¨‹æ± ](#é¡¹ç›®1-ç®€å•çº¿ç¨‹æ± )           | â­     | 1-2å°æ—¶  | thread::spawnã€JoinHandle |
| 2   | [å¹¶å‘é˜Ÿåˆ—](#é¡¹ç›®2-å¹¶å‘é˜Ÿåˆ—)               | â­â­   | 2-3å°æ—¶  | Arcã€Mutexã€Channel       |
| 3   | [ç”Ÿäº§è€…-æ¶ˆè´¹è€…](#é¡¹ç›®3-ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼) | â­â­â­ | 3-4å°æ—¶  | mpscã€åŒæ­¥åŸè¯­            |

---

## é¡¹ç›®1: ç®€å•çº¿ç¨‹æ± 

### ğŸ“– é¡¹ç›®è¯´æ˜

**éš¾åº¦**: â­
**é¢„è®¡æ—¶é—´**: 1-2å°æ—¶

### æ ¸å¿ƒä»£ç 

```rust
use std::thread;
use std::sync::{Arc, Mutex, mpsc};
use std::time::Duration;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Self {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();

            match job {
                Ok(job) => {
                    println!("Worker {} got a job", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} shutting down", id);
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}

fn main() {
    println!("===== çº¿ç¨‹æ± æµ‹è¯• =====\n");

    let pool = ThreadPool::new(4);

    for i in 0..8 {
        pool.execute(move || {
            println!("Task {} starting", i);
            thread::sleep(Duration::from_millis(100));
            println!("Task {} completed", i);
        });
    }

    thread::sleep(Duration::from_secs(2));
}
```

---

## é¡¹ç›®2: å¹¶å‘é˜Ÿåˆ—

### ğŸ“– é¡¹ç›®è¯´æ˜2

**éš¾åº¦**: â­â­
**é¢„è®¡æ—¶é—´**: 2-3å°æ—¶

### æ ¸å¿ƒä»£ç 2

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;

struct BoundedQueue<T> {
    queue: Mutex<VecDeque<T>>,
    not_full: Condvar,
    not_empty: Condvar,
    capacity: usize,
}

impl<T> BoundedQueue<T> {
    fn new(capacity: usize) -> Self {
        BoundedQueue {
            queue: Mutex::new(VecDeque::with_capacity(capacity)),
            not_full: Condvar::new(),
            not_empty: Condvar::new(),
            capacity,
        }
    }

    fn push(&self, item: T) {
        let mut queue = self.queue.lock().unwrap();

        while queue.len() == self.capacity {
            queue = self.not_full.wait(queue).unwrap();
        }

        queue.push_back(item);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut queue = self.queue.lock().unwrap();

        while queue.is_empty() {
            queue = self.not_empty.wait(queue).unwrap();
        }

        let item = queue.pop_front().unwrap();
        self.not_full.notify_one();
        item
    }
}

fn main() {
    use std::thread;
    use std::time::Duration;

    println!("===== å¹¶å‘é˜Ÿåˆ—æµ‹è¯• =====\n");

    let queue = Arc::new(BoundedQueue::new(5));

    // ç”Ÿäº§è€…
    let producer = {
        let queue = Arc::clone(&queue);
        thread::spawn(move || {
            for i in 0..10 {
                println!("ç”Ÿäº§: {}", i);
                queue.push(i);
                thread::sleep(Duration::from_millis(100));
            }
        })
    };

    // æ¶ˆè´¹è€…
    let consumer = {
        let queue = Arc::clone(&queue);
        thread::spawn(move || {
            for _ in 0..10 {
                let item = queue.pop();
                println!("  æ¶ˆè´¹: {}", item);
                thread::sleep(Duration::from_millis(150));
            }
        })
    };

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

---

## é¡¹ç›®3: ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

### ğŸ“– é¡¹ç›®è¯´æ˜3

**éš¾åº¦**: â­â­â­
**é¢„è®¡æ—¶é—´**: 3-4å°æ—¶

### æ ¸å¿ƒä»£ç 3

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

enum Message {
    Task(String),
    Shutdown,
}

fn main() {
    println!("===== ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ =====\n");

    let (tx, rx) = mpsc::channel();

    // å¤šä¸ªç”Ÿäº§è€…
    let producers: Vec<_> = (0..3).map(|id| {
        let tx = tx.clone();
        thread::spawn(move || {
            for i in 0..5 {
                let task = format!("Producer{}-Task{}", id, i);
                println!("ğŸ“¦ {} ç”Ÿäº§ä»»åŠ¡", task);
                tx.send(Message::Task(task)).unwrap();
                thread::sleep(Duration::from_millis(100));
            }
        })
    }).collect();

    drop(tx);

    // å•ä¸ªæ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        for msg in rx {
            match msg {
                Message::Task(task) => {
                    println!("  âœ… å¤„ç†ä»»åŠ¡: {}", task);
                    thread::sleep(Duration::from_millis(50));
                }
                Message::Shutdown => break,
            }
        }
    });

    for producer in producers {
        producer.join().unwrap();
    }

    consumer.join().unwrap();

    println!("\næ‰€æœ‰ä»»åŠ¡å®Œæˆï¼");
}
```

---

## ğŸ“ æ€»ç»“

### å…³é”®æ¦‚å¿µ

| æ¦‚å¿µ          | é¡¹ç›®1  | é¡¹ç›®2  | é¡¹ç›®3  |
| ------------- | ------ | ------ | ------ |
| thread::spawn | âœ…âœ…âœ… | âœ…âœ…   | âœ…âœ…   |
| Arc/Mutex     | âœ…âœ…âœ… | âœ…âœ…âœ… | âœ…     |
| Channel       | âœ…âœ…   | âŒ     | âœ…âœ…âœ… |
| Condvar       | âŒ     | âœ…âœ…âœ… | âŒ     |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-25

**ğŸ¯ æŒæ¡çº¿ç¨‹ç¼–ç¨‹ï¼Œæ„å»ºé«˜æ€§èƒ½å¹¶å‘åº”ç”¨ï¼ğŸ¦€**:
