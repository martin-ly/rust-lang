# 🧵 C05: Threads - 实战项目集

> **创建日期**: 2025-10-25
> **文档版本**: v1.0
> **适用模块**: C05 线程和并发
> **目标**: 通过实战项目掌握线程编程和并发控制

---

## 📋 项目概览

| # | 项目名称 | 难度 | 预计时间 | 核心概念 |
|---|----------|------|---------|---------|
| 1 | [简单线程池](#项目1-简单线程池) | ⭐ | 1-2小时 | thread::spawn、JoinHandle |
| 2 | [并发队列](#项目2-并发队列) | ⭐⭐ | 2-3小时 | Arc、Mutex、Channel |
| 3 | [生产者-消费者](#项目3-生产者-消费者模式) | ⭐⭐⭐ | 3-4小时 | mpsc、同步原语 |

---

## 项目1: 简单线程池

### 📖 项目说明

**难度**: ⭐
**预计时间**: 1-2小时

### 核心代码

```rust
use std::thread;
use std::sync::{Arc, Mutex, mpsc};
use std::time::Duration;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Self {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();

            match job {
                Ok(job) => {
                    println!("Worker {} got a job", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} shutting down", id);
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}

fn main() {
    println!("===== 线程池测试 =====\n");

    let pool = ThreadPool::new(4);

    for i in 0..8 {
        pool.execute(move || {
            println!("Task {} starting", i);
            thread::sleep(Duration::from_millis(100));
            println!("Task {} completed", i);
        });
    }

    thread::sleep(Duration::from_secs(2));
}
```

---

## 项目2: 并发队列

### 📖 项目说明2

**难度**: ⭐⭐
**预计时间**: 2-3小时

### 核心代码2

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::collections::VecDeque;

struct BoundedQueue<T> {
    queue: Mutex<VecDeque<T>>,
    not_full: Condvar,
    not_empty: Condvar,
    capacity: usize,
}

impl<T> BoundedQueue<T> {
    fn new(capacity: usize) -> Self {
        BoundedQueue {
            queue: Mutex::new(VecDeque::with_capacity(capacity)),
            not_full: Condvar::new(),
            not_empty: Condvar::new(),
            capacity,
        }
    }

    fn push(&self, item: T) {
        let mut queue = self.queue.lock().unwrap();

        while queue.len() == self.capacity {
            queue = self.not_full.wait(queue).unwrap();
        }

        queue.push_back(item);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut queue = self.queue.lock().unwrap();

        while queue.is_empty() {
            queue = self.not_empty.wait(queue).unwrap();
        }

        let item = queue.pop_front().unwrap();
        self.not_full.notify_one();
        item
    }
}

fn main() {
    use std::thread;
    use std::time::Duration;

    println!("===== 并发队列测试 =====\n");

    let queue = Arc::new(BoundedQueue::new(5));

    // 生产者
    let producer = {
        let queue = Arc::clone(&queue);
        thread::spawn(move || {
            for i in 0..10 {
                println!("生产: {}", i);
                queue.push(i);
                thread::sleep(Duration::from_millis(100));
            }
        })
    };

    // 消费者
    let consumer = {
        let queue = Arc::clone(&queue);
        thread::spawn(move || {
            for _ in 0..10 {
                let item = queue.pop();
                println!("  消费: {}", item);
                thread::sleep(Duration::from_millis(150));
            }
        })
    };

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

---

## 项目3: 生产者-消费者模式

### 📖 项目说明3

**难度**: ⭐⭐⭐
**预计时间**: 3-4小时

### 核心代码3

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

enum Message {
    Task(String),
    Shutdown,
}

fn main() {
    println!("===== 生产者-消费者模式 =====\n");

    let (tx, rx) = mpsc::channel();

    // 多个生产者
    let producers: Vec<_> = (0..3).map(|id| {
        let tx = tx.clone();
        thread::spawn(move || {
            for i in 0..5 {
                let task = format!("Producer{}-Task{}", id, i);
                println!("📦 {} 生产任务", task);
                tx.send(Message::Task(task)).unwrap();
                thread::sleep(Duration::from_millis(100));
            }
        })
    }).collect();

    drop(tx);

    // 单个消费者
    let consumer = thread::spawn(move || {
        for msg in rx {
            match msg {
                Message::Task(task) => {
                    println!("  ✅ 处理任务: {}", task);
                    thread::sleep(Duration::from_millis(50));
                }
                Message::Shutdown => break,
            }
        }
    });

    for producer in producers {
        producer.join().unwrap();
    }

    consumer.join().unwrap();

    println!("\n所有任务完成！");
}
```

---

## 📝 总结

### 关键概念

| 概念 | 项目1 | 项目2 | 项目3 |
|------|-------|-------|-------|
| thread::spawn | ✅✅✅ | ✅✅ | ✅✅ |
| Arc/Mutex | ✅✅✅ | ✅✅✅ | ✅ |
| Channel | ✅✅ | ❌ | ✅✅✅ |
| Condvar | ❌ | ✅✅✅ | ❌ |

---

**文档版本**: v1.0
**创建日期**: 2025-10-25

**🎯 掌握线程编程，构建高性能并发应用！🦀**:
