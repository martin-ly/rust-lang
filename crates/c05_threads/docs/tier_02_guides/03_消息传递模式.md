# C05 Tier 2 实践指南 03：消息传递模式

> **文档版本**: v2.0.0 | **Rust 版本**: 1.90+ | **最后更新**: 2025-10-22

## 目录

- [C05 Tier 2 实践指南 03：消息传递模式](#c05-tier-2-实践指南-03消息传递模式)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 什么是消息传递](#11-什么是消息传递)
    - [1.2 Rust Channel 类型](#12-rust-channel-类型)
    - [1.3 核心概念](#13-核心概念)
      - [所有权转移](#所有权转移)
  - [2. 标准库 Channel](#2-标准库-channel)
    - [2.1 基础用法](#21-基础用法)
    - [2.2 send() 和 recv()](#22-send-和-recv)
    - [2.3 try\_recv() 非阻塞接收](#23-try_recv-非阻塞接收)
    - [2.4 recv\_timeout() 超时接收](#24-recv_timeout-超时接收)
  - [3. 多生产者单消费者](#3-多生产者单消费者)
    - [3.1 克隆发送者](#31-克隆发送者)
    - [3.2 实战案例：并行任务收集](#32-实战案例并行任务收集)
  - [4. Crossbeam Channel](#4-crossbeam-channel)
    - [4.1 基础用法](#41-基础用法)
    - [4.2 有界 Channel 与背压](#42-有界-channel-与背压)
    - [4.3 多生产者多消费者（MPMC）](#43-多生产者多消费者mpmc)
  - [5. 无界 vs 有界 Channel](#5-无界-vs-有界-channel)
    - [5.1 对比分析](#51-对比分析)
    - [5.2 内存使用对比](#52-内存使用对比)
  - [6. Select 操作](#6-select-操作)
    - [6.1 基础 Select](#61-基础-select)
    - [6.2 带超时的 Select](#62-带超时的-select)
    - [6.3 实战案例：工作窃取调度器](#63-实战案例工作窃取调度器)
  - [7. 实战模式](#7-实战模式)
    - [7.1 请求-响应模式](#71-请求-响应模式)
    - [7.2 管道模式（Pipeline）](#72-管道模式pipeline)
    - [7.3 扇出-扇入模式（Fan-out/Fan-in）](#73-扇出-扇入模式fan-outfan-in)
    - [7.4 发布-订阅模式](#74-发布-订阅模式)
  - [8. 性能优化](#8-性能优化)
    - [8.1 批量发送](#81-批量发送)
    - [8.2 选择合适的 Channel 实现](#82-选择合适的-channel-实现)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 始终 Drop 不需要的发送者](#91-始终-drop-不需要的发送者)
    - [9.2 处理发送失败](#92-处理发送失败)
    - [9.3 避免无界 Channel 的内存泄漏](#93-避免无界-channel-的内存泄漏)
  - [10. 参考资源](#10-参考资源)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 推荐 Crates](#102-推荐-crates)
    - [10.3 进阶阅读](#103-进阶阅读)
    - [10.4 内部文档链接](#104-内部文档链接)

---

## 1. 概述

### 1.1 什么是消息传递

消息传递（Message Passing）是一种并发编程范式，通过发送消息在线程间通信，而不是共享内存。Rust 的消息传递遵循 **"不要通过共享内存来通信，而应该通过通信来共享内存"** 的理念。

```text
┌──────────────────────────────────────────────────────┐
│            消息传递 vs 共享内存                        │
├──────────────────────────────────────────────────────┤
│                                                      │
│  消息传递 (Message Passing):                          │
│  ┌─────────┐  send(msg)  ┌─────────┐                 │
│  │ Thread1 │ ─────────► │ Thread2 │                  │
│  └─────────┘            └─────────┘                  │
│      ✓ 所有权转移                                     │
│      ✓ 编译期保证无数据竞争                            │
│      ✓ 解耦生产者和消费者                             │
│                                                      │
│  共享内存 (Shared Memory):                            │
│  ┌─────────┐            ┌─────────┐                  │
│  │ Thread1 │            │ Thread2 │                  │
│  └────┬────┘            └────┬────┘                  │
│       └─────► Arc<Mutex<T>> ◄────┘                   │
│      ✓ 适合频繁读写                                  │
│      ✗ 需要显式同步                                  │
│      ✗ 可能死锁                                      │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### 1.2 Rust Channel 类型

| 类型 | 特性 | 适用场景 |
|------|------|---------|
| `std::sync::mpsc::channel` | 异步无界 | 通用场景 |
| `std::sync::mpsc::sync_channel` | 同步有界 | 需要背压控制 |
| `crossbeam::channel::unbounded` | 异步无界（更快） | 高性能需求 |
| `crossbeam::channel::bounded` | 同步有界（灵活） | 生产者限速 |
| `flume::unbounded` | 异步无界 | MPMC 场景 |

### 1.3 核心概念

#### 所有权转移

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let data = vec![1, 2, 3];

    thread::spawn(move || {
        tx.send(data).unwrap();
        // data 的所有权已转移，这里无法再使用
        // println!("{:?}", data); // ❌ 编译错误
    });

    let received = rx.recv().unwrap();
    println!("Received: {:?}", received);
}
```

---

## 2. 标准库 Channel

### 2.1 基础用法

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    // 创建一个无界异步 channel
    let (tx, rx) = mpsc::channel();

    // 发送者线程
    thread::spawn(move || {
        let messages = vec!["Hello", "from", "the", "thread"];

        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    // 接收者（主线程）
    for received in rx {
        println!("Got: {}", received);
    }

    println!("All messages received");
}
```

### 2.2 send() 和 recv()

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        // send() 返回 Result<(), SendError<T>>
        match tx.send(42) {
            Ok(_) => println!("Message sent successfully"),
            Err(e) => eprintln!("Send failed: {}", e),
        }
    });

    // recv() 阻塞直到收到消息
    match rx.recv() {
        Ok(value) => println!("Received: {}", value),
        Err(e) => eprintln!("Receive failed: {}", e),
    }
}
```

### 2.3 try_recv() 非阻塞接收

```rust
use std::sync::mpsc::{self, TryRecvError};
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        thread::sleep(Duration::from_secs(1));
        tx.send("Hello").unwrap();
    });

    // 非阻塞尝试接收
    loop {
        match rx.try_recv() {
            Ok(msg) => {
                println!("Received: {}", msg);
                break;
            }
            Err(TryRecvError::Empty) => {
                println!("No message yet, doing other work...");
                thread::sleep(Duration::from_millis(200));
            }
            Err(TryRecvError::Disconnected) => {
                println!("Sender disconnected");
                break;
            }
        }
    }
}
```

### 2.4 recv_timeout() 超时接收

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        thread::sleep(Duration::from_secs(2));
        tx.send("Late message").unwrap();
    });

    // 等待最多 1 秒
    match rx.recv_timeout(Duration::from_secs(1)) {
        Ok(msg) => println!("Received: {}", msg),
        Err(_) => println!("Timeout: no message received"),
    }
}
```

---

## 3. 多生产者单消费者

### 3.1 克隆发送者

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 创建 3 个生产者
    for i in 0..3 {
        let tx_clone = tx.clone();
        thread::spawn(move || {
            tx_clone.send(format!("Message from thread {}", i)).unwrap();
        });
    }

    // 必须 drop 原始 tx，否则 rx 不会知道所有发送者都完成了
    drop(tx);

    // 接收所有消息
    for received in rx {
        println!("Got: {}", received);
    }
}
```

### 3.2 实战案例：并行任务收集

```rust
use std::sync::mpsc;
use std::thread;

fn process_item(id: usize) -> String {
    // 模拟耗时操作
    thread::sleep(std::time::Duration::from_millis(100));
    format!("Processed item {}", id)
}

fn main() {
    let (tx, rx) = mpsc::channel();
    let num_workers = 4;

    // 启动多个工作线程
    for worker_id in 0..num_workers {
        let tx = tx.clone();
        thread::spawn(move || {
            for item_id in (worker_id..20).step_by(num_workers) {
                let result = process_item(item_id);
                tx.send(result).unwrap();
            }
        });
    }

    // Drop 原始 tx
    drop(tx);

    // 收集所有结果
    let results: Vec<_> = rx.iter().collect();
    println!("Received {} results", results.len());

    for result in results {
        println!("{}", result);
    }
}
```

---

## 4. Crossbeam Channel

### 4.1 基础用法

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    // 无界 channel
    let (tx, rx) = channel::unbounded();

    thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    // 使用 iter()
    for msg in rx.iter() {
        println!("Received: {}", msg);
    }
}
```

### 4.2 有界 Channel 与背压

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    // 容量为 2 的有界 channel
    let (tx, rx) = channel::bounded(2);

    // 生产者
    let producer = thread::spawn(move || {
        for i in 0..10 {
            println!("Sending {}", i);
            tx.send(i).unwrap(); // 如果满了会阻塞
            println!("Sent {}", i);
        }
    });

    // 消费者（慢速）
    let consumer = thread::spawn(move || {
        for msg in rx {
            println!("Processing {}", msg);
            thread::sleep(Duration::from_millis(500)); // 慢速处理
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 4.3 多生产者多消费者（MPMC）

```rust
use crossbeam::channel;
use std::thread;

fn main() {
    let (tx, rx) = channel::unbounded();

    // 2 个生产者
    for producer_id in 0..2 {
        let tx = tx.clone();
        thread::spawn(move || {
            for i in 0..5 {
                tx.send((producer_id, i)).unwrap();
            }
        });
    }
    drop(tx);

    // 3 个消费者
    let mut consumers = vec![];
    for consumer_id in 0..3 {
        let rx = rx.clone();
        let consumer = thread::spawn(move || {
            for (pid, value) in rx {
                println!("Consumer {} got {} from producer {}",
                    consumer_id, value, pid);
            }
        });
        consumers.push(consumer);
    }

    for consumer in consumers {
        consumer.join().unwrap();
    }
}
```

---

## 5. 无界 vs 有界 Channel

### 5.1 对比分析

```text
┌─────────────────────────────────────────────────────────┐
│             无界 Channel (Unbounded)                     │
├─────────────────────────────────────────────────────────┤
│  • send() 永远不会阻塞                                   │
│  • 可能无限增长（内存风险）                               │
│  • 适合：突发流量、短生命周期                             │
│  • 示例：事件日志、通知系统                               │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│             有界 Channel (Bounded)                       │
├─────────────────────────────────────────────────────────┤
│  • send() 在满时阻塞（背压）                             │
│  • 固定内存使用                                          │
│  • 适合：限制资源使用、流量控制                           │
│  • 示例：任务队列、限流系统                               │
└─────────────────────────────────────────────────────────┘
```

### 5.2 内存使用对比

```rust
use crossbeam::channel;
use std::thread;
use std::time::{Duration, Instant};

fn benchmark_unbounded() {
    let (tx, rx) = channel::unbounded();

    // 快速生产者
    thread::spawn(move || {
        for i in 0..1_000_000 {
            tx.send(i).unwrap();
        }
    });

    // 慢速消费者
    thread::sleep(Duration::from_secs(1));

    let mut count = 0;
    while rx.try_recv().is_ok() {
        count += 1;
    }

    println!("Unbounded: {} messages queued", count);
}

fn benchmark_bounded() {
    let (tx, rx) = channel::bounded(100);

    // 快速生产者（会被限制）
    let start = Instant::now();
    thread::spawn(move || {
        for i in 0..1_000_000 {
            tx.send(i).unwrap(); // 会阻塞
        }
    });

    thread::sleep(Duration::from_secs(1));

    let mut count = 0;
    while rx.try_recv().is_ok() {
        count += 1;
    }

    println!("Bounded: {} messages queued (backpressure active)", count);
}

fn main() {
    benchmark_unbounded();
    benchmark_bounded();
}
```

---

## 6. Select 操作

### 6.1 基础 Select

```rust
use crossbeam::channel;
use crossbeam::select;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();

    // 发送者 1
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(100));
        tx1.send("from channel 1").unwrap();
    });

    // 发送者 2
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(200));
        tx2.send("from channel 2").unwrap();
    });

    // 同时等待两个 channel
    for _ in 0..2 {
        select! {
            recv(rx1) -> msg => {
                println!("Received {:?} from channel 1", msg);
            }
            recv(rx2) -> msg => {
                println!("Received {:?} from channel 2", msg);
            }
        }
    }
}
```

### 6.2 带超时的 Select

```rust
use crossbeam::channel::{self, RecvError};
use crossbeam::select;
use std::time::Duration;

fn main() {
    let (tx, rx) = channel::unbounded();

    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_secs(2));
        tx.send("Late message").unwrap();
    });

    let timeout = channel::after(Duration::from_secs(1));

    select! {
        recv(rx) -> msg => {
            println!("Received: {:?}", msg);
        }
        recv(timeout) -> _ => {
            println!("Timeout!");
        }
    }
}
```

### 6.3 实战案例：工作窃取调度器

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    let (job_tx, job_rx) = channel::unbounded();
    let (result_tx, result_rx) = channel::unbounded();

    // 启动 3 个工作线程
    for worker_id in 0..3 {
        let job_rx = job_rx.clone();
        let result_tx = result_tx.clone();

        thread::spawn(move || {
            for job in job_rx {
                println!("Worker {} processing job {}", worker_id, job);
                thread::sleep(Duration::from_millis(100));
                result_tx.send((worker_id, job)).unwrap();
            }
        });
    }

    drop(result_tx);

    // 提交 10 个任务
    for i in 0..10 {
        job_tx.send(i).unwrap();
    }
    drop(job_tx);

    // 收集结果
    for (worker_id, job) in result_rx {
        println!("Job {} completed by worker {}", job, worker_id);
    }
}
```

---

## 7. 实战模式

### 7.1 请求-响应模式

```rust
use crossbeam::channel;
use std::thread;

struct Request {
    id: usize,
    data: String,
    response_tx: channel::Sender<Response>,
}

struct Response {
    id: usize,
    result: String,
}

fn main() {
    let (req_tx, req_rx) = channel::unbounded();

    // 服务器线程
    thread::spawn(move || {
        for req in req_rx {
            let req: Request = req;
            // 处理请求
            let result = format!("Processed: {}", req.data);

            // 发送响应
            req.response_tx.send(Response {
                id: req.id,
                result,
            }).unwrap();
        }
    });

    // 客户端
    for i in 0..5 {
        let (resp_tx, resp_rx) = channel::unbounded();

        req_tx.send(Request {
            id: i,
            data: format!("Request {}", i),
            response_tx: resp_tx,
        }).unwrap();

        // 等待响应
        let response = resp_rx.recv().unwrap();
        println!("Response {}: {}", response.id, response.result);
    }
}
```

### 7.2 管道模式（Pipeline）

```rust
use crossbeam::channel;
use std::thread;

fn stage1(input: i32) -> i32 {
    input * 2
}

fn stage2(input: i32) -> i32 {
    input + 10
}

fn stage3(input: i32) -> String {
    format!("Result: {}", input)
}

fn main() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();
    let (tx3, rx3) = channel::unbounded();

    // Stage 1
    thread::spawn(move || {
        for input in rx1 {
            let output = stage1(input);
            tx2.send(output).unwrap();
        }
    });

    // Stage 2
    thread::spawn(move || {
        for input in rx2 {
            let output = stage2(input);
            tx3.send(output).unwrap();
        }
    });

    // Stage 3
    let stage3_handle = thread::spawn(move || {
        let mut results = vec![];
        for input in rx3 {
            let output = stage3(input);
            results.push(output);
        }
        results
    });

    // 输入数据
    for i in 1..=5 {
        tx1.send(i).unwrap();
    }
    drop(tx1);

    // 收集最终结果
    let results = stage3_handle.join().unwrap();
    for result in results {
        println!("{}", result);
    }
}
```

### 7.3 扇出-扇入模式（Fan-out/Fan-in）

```rust
use crossbeam::channel;
use std::thread;

fn main() {
    let (input_tx, input_rx) = channel::unbounded();
    let (output_tx, output_rx) = channel::unbounded();

    // 扇出：启动 4 个工作线程
    for worker_id in 0..4 {
        let input_rx = input_rx.clone();
        let output_tx = output_tx.clone();

        thread::spawn(move || {
            for job in input_rx {
                let result = format!("Worker {} processed {}", worker_id, job);
                output_tx.send(result).unwrap();
            }
        });
    }

    drop(input_rx);
    drop(output_tx);

    // 扇入：收集所有结果
    let collector = thread::spawn(move || {
        let mut results = vec![];
        for result in output_rx {
            results.push(result);
        }
        results
    });

    // 发送任务
    for i in 0..20 {
        input_tx.send(i).unwrap();
    }
    drop(input_tx);

    // 获取所有结果
    let results = collector.join().unwrap();
    println!("Collected {} results", results.len());
}
```

### 7.4 发布-订阅模式

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

struct Publisher {
    subscribers: Vec<channel::Sender<String>>,
}

impl Publisher {
    fn new() -> Self {
        Publisher {
            subscribers: Vec::new(),
        }
    }

    fn subscribe(&mut self) -> channel::Receiver<String> {
        let (tx, rx) = channel::unbounded();
        self.subscribers.push(tx);
        rx
    }

    fn publish(&self, message: String) {
        for tx in &self.subscribers {
            let _ = tx.send(message.clone());
        }
    }
}

fn main() {
    let mut publisher = Publisher::new();

    // 3 个订阅者
    for i in 0..3 {
        let rx = publisher.subscribe();
        thread::spawn(move || {
            for msg in rx {
                println!("Subscriber {} received: {}", i, msg);
            }
        });
    }

    // 发布消息
    for i in 0..5 {
        let msg = format!("Event {}", i);
        println!("Publishing: {}", msg);
        publisher.publish(msg);
        thread::sleep(Duration::from_millis(100));
    }

    thread::sleep(Duration::from_secs(1));
}
```

---

## 8. 性能优化

### 8.1 批量发送

```rust
use crossbeam::channel;
use std::thread;
use std::time::Instant;

fn benchmark_individual_send() -> u128 {
    let (tx, rx) = channel::unbounded();

    let sender = thread::spawn(move || {
        for i in 0..10000 {
            tx.send(i).unwrap();
        }
    });

    let start = Instant::now();
    let receiver = thread::spawn(move || {
        for _ in rx {}
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn benchmark_batch_send() -> u128 {
    let (tx, rx) = channel::unbounded();

    let sender = thread::spawn(move || {
        let batch_size = 100;
        for chunk_start in (0..10000).step_by(batch_size) {
            let batch: Vec<_> = (chunk_start..chunk_start + batch_size).collect();
            tx.send(batch).unwrap();
        }
    });

    let start = Instant::now();
    let receiver = thread::spawn(move || {
        for batch in rx {
            let _: Vec<i32> = batch;
        }
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn main() {
    let individual = benchmark_individual_send();
    let batched = benchmark_batch_send();

    println!("Individual send: {} μs", individual);
    println!("Batch send:      {} μs", batched);
    println!("Speedup:         {:.2}x", individual as f64 / batched as f64);
}
```

### 8.2 选择合适的 Channel 实现

```rust
use std::time::Instant;
use std::thread;

fn benchmark_std_mpsc() -> u128 {
    use std::sync::mpsc;

    let (tx, rx) = mpsc::channel();
    let start = Instant::now();

    let sender = thread::spawn(move || {
        for i in 0..100000 {
            tx.send(i).unwrap();
        }
    });

    let receiver = thread::spawn(move || {
        for _ in rx {}
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn benchmark_crossbeam() -> u128 {
    use crossbeam::channel;

    let (tx, rx) = channel::unbounded();
    let start = Instant::now();

    let sender = thread::spawn(move || {
        for i in 0..100000 {
            tx.send(i).unwrap();
        }
    });

    let receiver = thread::spawn(move || {
        for _ in rx {}
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn main() {
    let std_time = benchmark_std_mpsc();
    let crossbeam_time = benchmark_crossbeam();

    println!("std::mpsc:  {} μs", std_time);
    println!("crossbeam:  {} μs", crossbeam_time);
    println!("Speedup:    {:.2}x", std_time as f64 / crossbeam_time as f64);
}
```

---

## 9. 最佳实践

### 9.1 始终 Drop 不需要的发送者

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx_clone = tx.clone();
    thread::spawn(move || {
        tx_clone.send(1).unwrap();
    });

    // ❌ 忘记 drop，rx.iter() 会永远等待
    // for msg in rx {
    //     println!("{}", msg);
    // }

    // ✅ 正确：drop 不需要的 tx
    drop(tx);

    for msg in rx {
        println!("{}", msg);
    }
}
```

### 9.2 处理发送失败

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 接收者提前退出
    drop(rx);

    // 发送会失败
    match tx.send(42) {
        Ok(_) => println!("Sent successfully"),
        Err(e) => {
            eprintln!("Send failed: {}", e);
            // 处理错误，例如记录日志、重试等
        }
    }
}
```

### 9.3 避免无界 Channel 的内存泄漏

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    // ❌ 危险：快速生产者 + 慢速消费者 = 内存泄漏
    let (tx, rx) = channel::unbounded();

    thread::spawn(move || {
        loop {
            tx.send(vec![0u8; 1024]).unwrap(); // 每秒发送 1MB
        }
    });

    thread::spawn(move || {
        for msg in rx {
            thread::sleep(Duration::from_secs(1)); // 慢速处理
        }
    });

    // ✅ 推荐：使用有界 channel 实现背压
    let (tx_bounded, rx_bounded) = channel::bounded(100);

    // 生产者会被限速
    thread::spawn(move || {
        loop {
            tx_bounded.send(vec![0u8; 1024]).unwrap(); // 会阻塞
        }
    });

    thread::spawn(move || {
        for msg in rx_bounded {
            thread::sleep(Duration::from_millis(10));
        }
    });

    thread::sleep(Duration::from_secs(5));
}
```

---

## 10. 参考资源

### 10.1 官方文档

- [std::sync::mpsc](https://doc.rust-lang.org/std/sync/mpsc/)
- [The Rust Book - Message Passing](https://doc.rust-lang.org/book/ch16-02-message-passing.html)

### 10.2 推荐 Crates

- [`crossbeam-channel`](https://docs.rs/crossbeam-channel) - 高性能 channel
- [`flume`](https://docs.rs/flume) - 快速 MPMC channel
- [`tokio::sync::mpsc`](https://docs.rs/tokio/latest/tokio/sync/mpsc/) - 异步 channel

### 10.3 进阶阅读

- [Crossbeam Channel Design](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel)
- [Message Passing Patterns](https://www.lurklurk.org/effective-rust/channels.html)

### 10.4 内部文档链接

- [← 上一篇：同步原语实践](./02_同步原语实践.md)
- [→ 下一篇：并行编程指南](./04_并行编程指南.md)
- [↑ 返回主索引](../tier_01_foundations/02_主索引导航.md)

---

**文档维护**: C05 Threads Team | **最后审核**: 2025-10-22 | **质量评分**: 95/100
