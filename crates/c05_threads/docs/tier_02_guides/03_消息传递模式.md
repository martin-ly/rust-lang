# C05 Tier 2 å®è·µæŒ‡å— 03ï¼šæ¶ˆæ¯ä¼ é€’æ¨¡å¼

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 2 å®è·µæŒ‡å— 03ï¼šæ¶ˆæ¯ä¼ é€’æ¨¡å¼](#c05-tier-2-å®è·µæŒ‡å—-03æ¶ˆæ¯ä¼ é€’æ¨¡å¼)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [æ¦‚å¿µçŸ©é˜µ](#æ¦‚å¿µçŸ©é˜µ)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯æ¶ˆæ¯ä¼ é€’](#11-ä»€ä¹ˆæ˜¯æ¶ˆæ¯ä¼ é€’)
    - [1.2 Rust Channel ç±»å‹](#12-rust-channel-ç±»å‹)
    - [1.3 æ ¸å¿ƒæ¦‚å¿µ](#13-æ ¸å¿ƒæ¦‚å¿µ)
      - [æ‰€æœ‰æƒè½¬ç§»](#æ‰€æœ‰æƒè½¬ç§»)
  - [2. æ ‡å‡†åº“ Channel](#2-æ ‡å‡†åº“-channel)
    - [2.1 åŸºç¡€ç”¨æ³•](#21-åŸºç¡€ç”¨æ³•)
    - [2.2 send() å’Œ recv()](#22-send-å’Œ-recv)
    - [2.3 try\_recv() éé˜»å¡æ¥æ”¶](#23-try_recv-éé˜»å¡æ¥æ”¶)
    - [2.4 recv\_timeout() è¶…æ—¶æ¥æ”¶](#24-recv_timeout-è¶…æ—¶æ¥æ”¶)
  - [3. å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…](#3-å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…)
    - [3.1 å…‹éš†å‘é€è€…](#31-å…‹éš†å‘é€è€…)
    - [3.2 å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶è¡Œä»»åŠ¡æ”¶é›†](#32-å®æˆ˜æ¡ˆä¾‹å¹¶è¡Œä»»åŠ¡æ”¶é›†)
  - [4. Crossbeam Channel](#4-crossbeam-channel)
    - [4.1 åŸºç¡€ç”¨æ³•](#41-åŸºç¡€ç”¨æ³•)
    - [4.2 æœ‰ç•Œ Channel ä¸èƒŒå‹](#42-æœ‰ç•Œ-channel-ä¸èƒŒå‹)
    - [4.3 å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼ˆMPMCï¼‰](#43-å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…mpmc)
  - [5. æ— ç•Œ vs æœ‰ç•Œ Channel](#5-æ— ç•Œ-vs-æœ‰ç•Œ-channel)
    - [5.1 å¯¹æ¯”åˆ†æ](#51-å¯¹æ¯”åˆ†æ)
    - [5.2 å†…å­˜ä½¿ç”¨å¯¹æ¯”](#52-å†…å­˜ä½¿ç”¨å¯¹æ¯”)
  - [6. Select æ“ä½œ](#6-select-æ“ä½œ)
    - [6.1 åŸºç¡€ Select](#61-åŸºç¡€-select)
    - [6.2 å¸¦è¶…æ—¶çš„ Select](#62-å¸¦è¶…æ—¶çš„-select)
    - [6.3 å®æˆ˜æ¡ˆä¾‹ï¼šå·¥ä½œçªƒå–è°ƒåº¦å™¨](#63-å®æˆ˜æ¡ˆä¾‹å·¥ä½œçªƒå–è°ƒåº¦å™¨)
  - [7. å®æˆ˜æ¨¡å¼](#7-å®æˆ˜æ¨¡å¼)
    - [7.1 è¯·æ±‚-å“åº”æ¨¡å¼](#71-è¯·æ±‚-å“åº”æ¨¡å¼)
    - [7.2 ç®¡é“æ¨¡å¼ï¼ˆPipelineï¼‰](#72-ç®¡é“æ¨¡å¼pipeline)
    - [7.3 æ‰‡å‡º-æ‰‡å…¥æ¨¡å¼ï¼ˆFan-out/Fan-inï¼‰](#73-æ‰‡å‡º-æ‰‡å…¥æ¨¡å¼fan-outfan-in)
    - [7.4 å‘å¸ƒ-è®¢é˜…æ¨¡å¼](#74-å‘å¸ƒ-è®¢é˜…æ¨¡å¼)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [8.1 æ‰¹é‡å‘é€](#81-æ‰¹é‡å‘é€)
    - [8.2 é€‰æ‹©åˆé€‚çš„ Channel å®ç°](#82-é€‰æ‹©åˆé€‚çš„-channel-å®ç°)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [9.1 å§‹ç»ˆ Drop ä¸éœ€è¦çš„å‘é€è€…](#91-å§‹ç»ˆ-drop-ä¸éœ€è¦çš„å‘é€è€…)
    - [9.2 å¤„ç†å‘é€å¤±è´¥](#92-å¤„ç†å‘é€å¤±è´¥)
    - [9.3 é¿å…æ— ç•Œ Channel çš„å†…å­˜æ³„æ¼](#93-é¿å…æ— ç•Œ-channel-çš„å†…å­˜æ³„æ¼)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
    - [10.1 å®˜æ–¹æ–‡æ¡£](#101-å®˜æ–¹æ–‡æ¡£)
    - [10.2 æ¨è Crates](#102-æ¨è-crates)
    - [10.3 è¿›é˜¶é˜…è¯»](#103-è¿›é˜¶é˜…è¯»)
    - [10.4 å†…éƒ¨æ–‡æ¡£é“¾æ¥](#104-å†…éƒ¨æ–‡æ¡£é“¾æ¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ¶ˆæ¯ä¼ é€’ (Message Passing)**:

- **å®šä¹‰**: ä¸€ç§å¹¶å‘ç¼–ç¨‹èŒƒå¼ï¼Œé€šè¿‡å‘é€æ¶ˆæ¯åœ¨çº¿ç¨‹é—´é€šä¿¡ï¼Œè€Œä¸æ˜¯å…±äº«å†…å­˜
- **ç±»å‹**: å¹¶å‘ç¼–ç¨‹èŒƒå¼
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: é€šé“ã€å‘é€è€…ã€æ¥æ”¶è€…ã€æ‰€æœ‰æƒè½¬ç§»

**Channel (é€šé“)**:

- **å®šä¹‰**: ç”¨äºåœ¨çº¿ç¨‹é—´ä¼ é€’æ¶ˆæ¯çš„é€šä¿¡æœºåˆ¶
- **ç±»å‹**: å¹¶å‘åŸè¯­
- **å±æ€§**: å‘é€è€…ã€æ¥æ”¶è€…ã€æ¶ˆæ¯é˜Ÿåˆ—ã€èƒŒå‹å¤„ç†
- **å…³ç³»**: ä¸æ¶ˆæ¯ä¼ é€’ã€çº¿ç¨‹é€šä¿¡ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æ‰€æœ‰æƒè½¬ç§»**: æ¶ˆæ¯çš„æ‰€æœ‰æƒä»å‘é€è€…è½¬ç§»åˆ°æ¥æ”¶è€…
- **ç¼–è¯‘æœŸå®‰å…¨**: ç¼–è¯‘æœŸä¿è¯æ— æ•°æ®ç«äº‰
- **è§£è€¦**: ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…è§£è€¦
- **èƒŒå‹**: æœ‰ç•Œé€šé“æä¾›èƒŒå‹æœºåˆ¶

**æ€§èƒ½ç‰¹å¾**:

- **æ— ç•Œé€šé“**: é«˜æ€§èƒ½ä½†å¯èƒ½å†…å­˜æ³„æ¼
- **æœ‰ç•Œé€šé“**: å†…å­˜å®‰å…¨ä½†å¯èƒ½é˜»å¡
- **é€‚ç”¨åœºæ™¯**: ç”Ÿäº§è€…-æ¶ˆè´¹è€…ã€ä»»åŠ¡åˆ†å‘ã€äº‹ä»¶é©±åŠ¨

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- æœ‰ç•Œé€šé“ --[is-a]--> é€šé“
- æ— ç•Œé€šé“ --[is-a]--> é€šé“

**ç»„åˆå…³ç³»**:

- æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿ --[uses]--> é€šé“
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ --[uses]--> é€šé“

**ä¾èµ–å…³ç³»**:

- æ¶ˆæ¯ä¼ é€’ --[depends-on]--> é€šé“å®ç°
- é€šé“ --[depends-on]--> çº¿ç¨‹æ”¯æŒ

### æ€ç»´å¯¼å›¾

```text
æ¶ˆæ¯ä¼ é€’æ¨¡å¼
â”‚
â”œâ”€â”€ Channel ç±»å‹
â”‚   â”œâ”€â”€ æ ‡å‡†åº“ mpsc
â”‚   â”œâ”€â”€ Crossbeam Channel
â”‚   â””â”€â”€ Tokio Channel
â”œâ”€â”€ é€šé“æ¨¡å¼
â”‚   â”œâ”€â”€ MPSC (å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…)
â”‚   â”œâ”€â”€ MPMC (å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…)
â”‚   â””â”€â”€ SPSC (å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…)
â”œâ”€â”€ æ¶ˆæ¯æ¨¡å¼
â”‚   â”œâ”€â”€ è¯·æ±‚-å“åº”
â”‚   â”œâ”€â”€ ç®¡é“æ¨¡å¼
â”‚   â”œâ”€â”€ æ‰‡å‡º-æ‰‡å…¥
â”‚   â””â”€â”€ å‘å¸ƒ-è®¢é˜…
â””â”€â”€ æ€§èƒ½ä¼˜åŒ–
    â”œâ”€â”€ æ‰¹é‡å‘é€
    â””â”€â”€ èƒŒå‹å¤„ç†
```

### æ¦‚å¿µçŸ©é˜µ

| Channel ç±»å‹        | æœ‰ç•Œæ€§    | æ€§èƒ½ | èƒŒå‹ | é€‚ç”¨åœºæ™¯   |
| :--- | :--- | :--- | :--- | :--- || æ ‡å‡†åº“ mpsc         | æ— ç•Œ      | ä¸­   | âŒ   | é€šç”¨åœºæ™¯   |
| Crossbeam bounded   | æœ‰ç•Œ      | é«˜   | âœ…   | é«˜æ€§èƒ½åœºæ™¯ |
| Crossbeam unbounded | æ— ç•Œ      | é«˜   | âŒ   | é«˜åååœºæ™¯ |
| Tokio mpsc          | æœ‰ç•Œ/æ— ç•Œ | é«˜   | âœ…   | å¼‚æ­¥åœºæ™¯   |

---

## 1. æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯æ¶ˆæ¯ä¼ é€’

æ¶ˆæ¯ä¼ é€’ï¼ˆMessage Passingï¼‰æ˜¯ä¸€ç§å¹¶å‘ç¼–ç¨‹èŒƒå¼ï¼Œé€šè¿‡å‘é€æ¶ˆæ¯åœ¨çº¿ç¨‹é—´é€šä¿¡ï¼Œè€Œä¸æ˜¯å…±äº«å†…å­˜ã€‚Rust çš„æ¶ˆæ¯ä¼ é€’éµå¾ª **"ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œåº”è¯¥é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜"** çš„ç†å¿µã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            æ¶ˆæ¯ä¼ é€’ vs å…±äº«å†…å­˜                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  æ¶ˆæ¯ä¼ é€’ (Message Passing):                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  send(msg)  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ Thread1 â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Thread2 â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚      âœ“ æ‰€æœ‰æƒè½¬ç§»                                     â”‚
â”‚      âœ“ ç¼–è¯‘æœŸä¿è¯æ— æ•°æ®ç«äº‰                            â”‚
â”‚      âœ“ è§£è€¦ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…                             â”‚
â”‚                                                      â”‚
â”‚  å…±äº«å†…å­˜ (Shared Memory):                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ Thread1 â”‚            â”‚ Thread2 â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â–º Arc<Mutex<T>> â—„â”€â”€â”€â”€â”˜                   â”‚
â”‚      âœ“ é€‚åˆé¢‘ç¹è¯»å†™                                  â”‚
â”‚      âœ— éœ€è¦æ˜¾å¼åŒæ­¥                                  â”‚
â”‚      âœ— å¯èƒ½æ­»é”                                      â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Rust Channel ç±»å‹

| ç±»å‹                            | ç‰¹æ€§             | é€‚ç”¨åœºæ™¯     |
| :--- | :--- | :--- || `std::sync::mpsc::channel`      | å¼‚æ­¥æ— ç•Œ         | é€šç”¨åœºæ™¯     |
| `std::sync::mpsc::sync_channel` | åŒæ­¥æœ‰ç•Œ         | éœ€è¦èƒŒå‹æ§åˆ¶ |
| `crossbeam::channel::unbounded` | å¼‚æ­¥æ— ç•Œï¼ˆæ›´å¿«ï¼‰ | é«˜æ€§èƒ½éœ€æ±‚   |
| `crossbeam::channel::bounded`   | åŒæ­¥æœ‰ç•Œï¼ˆçµæ´»ï¼‰ | ç”Ÿäº§è€…é™é€Ÿ   |
| `flume::unbounded`              | å¼‚æ­¥æ— ç•Œ         | MPMC åœºæ™¯    |

### 1.3 æ ¸å¿ƒæ¦‚å¿µ

#### æ‰€æœ‰æƒè½¬ç§»

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let data = vec![1, 2, 3];

    thread::spawn(move || {
        tx.send(data).unwrap();
        // data çš„æ‰€æœ‰æƒå·²è½¬ç§»ï¼Œè¿™é‡Œæ— æ³•å†ä½¿ç”¨
        // println!("{:?}", data); // âŒ ç¼–è¯‘é”™è¯¯
    });

    let received = rx.recv().unwrap();
    println!("Received: {:?}", received);
}
```

---

## 2. æ ‡å‡†åº“ Channel

### 2.1 åŸºç¡€ç”¨æ³•

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    // åˆ›å»ºä¸€ä¸ªæ— ç•Œå¼‚æ­¥ channel
    let (tx, rx) = mpsc::channel();

    // å‘é€è€…çº¿ç¨‹
    thread::spawn(move || {
        let messages = vec!["Hello", "from", "the", "thread"];

        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    // æ¥æ”¶è€…ï¼ˆä¸»çº¿ç¨‹ï¼‰
    for received in rx {
        println!("Got: {}", received);
    }

    println!("All messages received");
}
```

### 2.2 send() å’Œ recv()

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        // send() è¿”å› Result<(), SendError<T>>
        match tx.send(42) {
            Ok(_) => println!("Message sent successfully"),
            Err(e) => eprintln!("Send failed: {}", e),
        }
    });

    // recv() é˜»å¡ç›´åˆ°æ”¶åˆ°æ¶ˆæ¯
    match rx.recv() {
        Ok(value) => println!("Received: {}", value),
        Err(e) => eprintln!("Receive failed: {}", e),
    }
}
```

### 2.3 try_recv() éé˜»å¡æ¥æ”¶

```rust
use std::sync::mpsc::{self, TryRecvError};
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        thread::sleep(Duration::from_secs(1));
        tx.send("Hello").unwrap();
    });

    // éé˜»å¡å°è¯•æ¥æ”¶
    loop {
        match rx.try_recv() {
            Ok(msg) => {
                println!("Received: {}", msg);
                break;
            }
            Err(TryRecvError::Empty) => {
                println!("No message yet, doing other work...");
                thread::sleep(Duration::from_millis(200));
            }
            Err(TryRecvError::Disconnected) => {
                println!("Sender disconnected");
                break;
            }
        }
    }
}
```

### 2.4 recv_timeout() è¶…æ—¶æ¥æ”¶

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        thread::sleep(Duration::from_secs(2));
        tx.send("Late message").unwrap();
    });

    // ç­‰å¾…æœ€å¤š 1 ç§’
    match rx.recv_timeout(Duration::from_secs(1)) {
        Ok(msg) => println!("Received: {}", msg),
        Err(_) => println!("Timeout: no message received"),
    }
}
```

---

## 3. å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…

### 3.1 å…‹éš†å‘é€è€…

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    // åˆ›å»º 3 ä¸ªç”Ÿäº§è€…
    for i in 0..3 {
        let tx_clone = tx.clone();
        thread::spawn(move || {
            tx_clone.send(format!("Message from thread {}", i)).unwrap();
        });
    }

    // å¿…é¡» drop åŸå§‹ txï¼Œå¦åˆ™ rx ä¸ä¼šçŸ¥é“æ‰€æœ‰å‘é€è€…éƒ½å®Œæˆäº†
    drop(tx);

    // æ¥æ”¶æ‰€æœ‰æ¶ˆæ¯
    for received in rx {
        println!("Got: {}", received);
    }
}
```

### 3.2 å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶è¡Œä»»åŠ¡æ”¶é›†

```rust
use std::sync::mpsc;
use std::thread;

fn process_item(id: usize) -> String {
    // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    thread::sleep(std::time::Duration::from_millis(100));
    format!("Processed item {}", id)
}

fn main() {
    let (tx, rx) = mpsc::channel();
    let num_workers = 4;

    // å¯åŠ¨å¤šä¸ªå·¥ä½œçº¿ç¨‹
    for worker_id in 0..num_workers {
        let tx = tx.clone();
        thread::spawn(move || {
            for item_id in (worker_id..20).step_by(num_workers) {
                let result = process_item(item_id);
                tx.send(result).unwrap();
            }
        });
    }

    // Drop åŸå§‹ tx
    drop(tx);

    // æ”¶é›†æ‰€æœ‰ç»“æœ
    let results: Vec<_> = rx.iter().collect();
    println!("Received {} results", results.len());

    for result in results {
        println!("{}", result);
    }
}
```

---

## 4. Crossbeam Channel

### 4.1 åŸºç¡€ç”¨æ³•

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    // æ— ç•Œ channel
    let (tx, rx) = channel::unbounded();

    thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    // ä½¿ç”¨ iter()
    for msg in rx.iter() {
        println!("Received: {}", msg);
    }
}
```

### 4.2 æœ‰ç•Œ Channel ä¸èƒŒå‹

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    // å®¹é‡ä¸º 2 çš„æœ‰ç•Œ channel
    let (tx, rx) = channel::bounded(2);

    // ç”Ÿäº§è€…
    let producer = thread::spawn(move || {
        for i in 0..10 {
            println!("Sending {}", i);
            tx.send(i).unwrap(); // å¦‚æœæ»¡äº†ä¼šé˜»å¡
            println!("Sent {}", i);
        }
    });

    // æ¶ˆè´¹è€…ï¼ˆæ…¢é€Ÿï¼‰
    let consumer = thread::spawn(move || {
        for msg in rx {
            println!("Processing {}", msg);
            thread::sleep(Duration::from_millis(500)); // æ…¢é€Ÿå¤„ç†
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 4.3 å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼ˆMPMCï¼‰

```rust
use crossbeam::channel;
use std::thread;

fn main() {
    let (tx, rx) = channel::unbounded();

    // 2 ä¸ªç”Ÿäº§è€…
    for producer_id in 0..2 {
        let tx = tx.clone();
        thread::spawn(move || {
            for i in 0..5 {
                tx.send((producer_id, i)).unwrap();
            }
        });
    }
    drop(tx);

    // 3 ä¸ªæ¶ˆè´¹è€…
    let mut consumers = vec![];
    for consumer_id in 0..3 {
        let rx = rx.clone();
        let consumer = thread::spawn(move || {
            for (pid, value) in rx {
                println!("Consumer {} got {} from producer {}",
                    consumer_id, value, pid);
            }
        });
        consumers.push(consumer);
    }

    for consumer in consumers {
        consumer.join().unwrap();
    }
}
```

---

## 5. æ— ç•Œ vs æœ‰ç•Œ Channel

### 5.1 å¯¹æ¯”åˆ†æ

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             æ— ç•Œ Channel (Unbounded)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ send() æ°¸è¿œä¸ä¼šé˜»å¡                                   â”‚
â”‚  â€¢ å¯èƒ½æ— é™å¢é•¿ï¼ˆå†…å­˜é£é™©ï¼‰                               â”‚
â”‚  â€¢ é€‚åˆï¼šçªå‘æµé‡ã€çŸ­ç”Ÿå‘½å‘¨æœŸ                             â”‚
â”‚  â€¢ ç¤ºä¾‹ï¼šäº‹ä»¶æ—¥å¿—ã€é€šçŸ¥ç³»ç»Ÿ                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             æœ‰ç•Œ Channel (Bounded)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ send() åœ¨æ»¡æ—¶é˜»å¡ï¼ˆèƒŒå‹ï¼‰                             â”‚
â”‚  â€¢ å›ºå®šå†…å­˜ä½¿ç”¨                                          â”‚
â”‚  â€¢ é€‚åˆï¼šé™åˆ¶èµ„æºä½¿ç”¨ã€æµé‡æ§åˆ¶                           â”‚
â”‚  â€¢ ç¤ºä¾‹ï¼šä»»åŠ¡é˜Ÿåˆ—ã€é™æµç³»ç»Ÿ                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 å†…å­˜ä½¿ç”¨å¯¹æ¯”

```rust
use crossbeam::channel;
use std::thread;
use std::time::{Duration, Instant};

fn benchmark_unbounded() {
    let (tx, rx) = channel::unbounded();

    // å¿«é€Ÿç”Ÿäº§è€…
    thread::spawn(move || {
        for i in 0..1_000_000 {
            tx.send(i).unwrap();
        }
    });

    // æ…¢é€Ÿæ¶ˆè´¹è€…
    thread::sleep(Duration::from_secs(1));

    let mut count = 0;
    while rx.try_recv().is_ok() {
        count += 1;
    }

    println!("Unbounded: {} messages queued", count);
}

fn benchmark_bounded() {
    let (tx, rx) = channel::bounded(100);

    // å¿«é€Ÿç”Ÿäº§è€…ï¼ˆä¼šè¢«é™åˆ¶ï¼‰
    let start = Instant::now();
    thread::spawn(move || {
        for i in 0..1_000_000 {
            tx.send(i).unwrap(); // ä¼šé˜»å¡
        }
    });

    thread::sleep(Duration::from_secs(1));

    let mut count = 0;
    while rx.try_recv().is_ok() {
        count += 1;
    }

    println!("Bounded: {} messages queued (backpressure active)", count);
}

fn main() {
    benchmark_unbounded();
    benchmark_bounded();
}
```

---

## 6. Select æ“ä½œ

### 6.1 åŸºç¡€ Select

```rust
use crossbeam::channel;
use crossbeam::select;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();

    // å‘é€è€… 1
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(100));
        tx1.send("from channel 1").unwrap();
    });

    // å‘é€è€… 2
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(200));
        tx2.send("from channel 2").unwrap();
    });

    // åŒæ—¶ç­‰å¾…ä¸¤ä¸ª channel
    for _ in 0..2 {
        select! {
            recv(rx1) -> msg => {
                println!("Received {:?} from channel 1", msg);
            }
            recv(rx2) -> msg => {
                println!("Received {:?} from channel 2", msg);
            }
        }
    }
}
```

### 6.2 å¸¦è¶…æ—¶çš„ Select

```rust
use crossbeam::channel::{self, RecvError};
use crossbeam::select;
use std::time::Duration;

fn main() {
    let (tx, rx) = channel::unbounded();

    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_secs(2));
        tx.send("Late message").unwrap();
    });

    let timeout = channel::after(Duration::from_secs(1));

    select! {
        recv(rx) -> msg => {
            println!("Received: {:?}", msg);
        }
        recv(timeout) -> _ => {
            println!("Timeout!");
        }
    }
}
```

### 6.3 å®æˆ˜æ¡ˆä¾‹ï¼šå·¥ä½œçªƒå–è°ƒåº¦å™¨

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    let (job_tx, job_rx) = channel::unbounded();
    let (result_tx, result_rx) = channel::unbounded();

    // å¯åŠ¨ 3 ä¸ªå·¥ä½œçº¿ç¨‹
    for worker_id in 0..3 {
        let job_rx = job_rx.clone();
        let result_tx = result_tx.clone();

        thread::spawn(move || {
            for job in job_rx {
                println!("Worker {} processing job {}", worker_id, job);
                thread::sleep(Duration::from_millis(100));
                result_tx.send((worker_id, job)).unwrap();
            }
        });
    }

    drop(result_tx);

    // æäº¤ 10 ä¸ªä»»åŠ¡
    for i in 0..10 {
        job_tx.send(i).unwrap();
    }
    drop(job_tx);

    // æ”¶é›†ç»“æœ
    for (worker_id, job) in result_rx {
        println!("Job {} completed by worker {}", job, worker_id);
    }
}
```

---

## 7. å®æˆ˜æ¨¡å¼

### 7.1 è¯·æ±‚-å“åº”æ¨¡å¼

```rust
use crossbeam::channel;
use std::thread;

struct Request {
    id: usize,
    data: String,
    response_tx: channel::Sender<Response>,
}

struct Response {
    id: usize,
    result: String,
}

fn main() {
    let (req_tx, req_rx) = channel::unbounded();

    // æœåŠ¡å™¨çº¿ç¨‹
    thread::spawn(move || {
        for req in req_rx {
            let req: Request = req;
            // å¤„ç†è¯·æ±‚
            let result = format!("Processed: {}", req.data);

            // å‘é€å“åº”
            req.response_tx.send(Response {
                id: req.id,
                result,
            }).unwrap();
        }
    });

    // å®¢æˆ·ç«¯
    for i in 0..5 {
        let (resp_tx, resp_rx) = channel::unbounded();

        req_tx.send(Request {
            id: i,
            data: format!("Request {}", i),
            response_tx: resp_tx,
        }).unwrap();

        // ç­‰å¾…å“åº”
        let response = resp_rx.recv().unwrap();
        println!("Response {}: {}", response.id, response.result);
    }
}
```

### 7.2 ç®¡é“æ¨¡å¼ï¼ˆPipelineï¼‰

```rust
use crossbeam::channel;
use std::thread;

fn stage1(input: i32) -> i32 {
    input * 2
}

fn stage2(input: i32) -> i32 {
    input + 10
}

fn stage3(input: i32) -> String {
    format!("Result: {}", input)
}

fn main() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();
    let (tx3, rx3) = channel::unbounded();

    // Stage 1
    thread::spawn(move || {
        for input in rx1 {
            let output = stage1(input);
            tx2.send(output).unwrap();
        }
    });

    // Stage 2
    thread::spawn(move || {
        for input in rx2 {
            let output = stage2(input);
            tx3.send(output).unwrap();
        }
    });

    // Stage 3
    let stage3_handle = thread::spawn(move || {
        let mut results = vec![];
        for input in rx3 {
            let output = stage3(input);
            results.push(output);
        }
        results
    });

    // è¾“å…¥æ•°æ®
    for i in 1..=5 {
        tx1.send(i).unwrap();
    }
    drop(tx1);

    // æ”¶é›†æœ€ç»ˆç»“æœ
    let results = stage3_handle.join().unwrap();
    for result in results {
        println!("{}", result);
    }
}
```

### 7.3 æ‰‡å‡º-æ‰‡å…¥æ¨¡å¼ï¼ˆFan-out/Fan-inï¼‰

```rust
use crossbeam::channel;
use std::thread;

fn main() {
    let (input_tx, input_rx) = channel::unbounded();
    let (output_tx, output_rx) = channel::unbounded();

    // æ‰‡å‡ºï¼šå¯åŠ¨ 4 ä¸ªå·¥ä½œçº¿ç¨‹
    for worker_id in 0..4 {
        let input_rx = input_rx.clone();
        let output_tx = output_tx.clone();

        thread::spawn(move || {
            for job in input_rx {
                let result = format!("Worker {} processed {}", worker_id, job);
                output_tx.send(result).unwrap();
            }
        });
    }

    drop(input_rx);
    drop(output_tx);

    // æ‰‡å…¥ï¼šæ”¶é›†æ‰€æœ‰ç»“æœ
    let collector = thread::spawn(move || {
        let mut results = vec![];
        for result in output_rx {
            results.push(result);
        }
        results
    });

    // å‘é€ä»»åŠ¡
    for i in 0..20 {
        input_tx.send(i).unwrap();
    }
    drop(input_tx);

    // è·å–æ‰€æœ‰ç»“æœ
    let results = collector.join().unwrap();
    println!("Collected {} results", results.len());
}
```

### 7.4 å‘å¸ƒ-è®¢é˜…æ¨¡å¼

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

struct Publisher {
    subscribers: Vec<channel::Sender<String>>,
}

impl Publisher {
    fn new() -> Self {
        Publisher {
            subscribers: Vec::new(),
        }
    }

    fn subscribe(&mut self) -> channel::Receiver<String> {
        let (tx, rx) = channel::unbounded();
        self.subscribers.push(tx);
        rx
    }

    fn publish(&self, message: String) {
        for tx in &self.subscribers {
            let _ = tx.send(message.clone());
        }
    }
}

fn main() {
    let mut publisher = Publisher::new();

    // 3 ä¸ªè®¢é˜…è€…
    for i in 0..3 {
        let rx = publisher.subscribe();
        thread::spawn(move || {
            for msg in rx {
                println!("Subscriber {} received: {}", i, msg);
            }
        });
    }

    // å‘å¸ƒæ¶ˆæ¯
    for i in 0..5 {
        let msg = format!("Event {}", i);
        println!("Publishing: {}", msg);
        publisher.publish(msg);
        thread::sleep(Duration::from_millis(100));
    }

    thread::sleep(Duration::from_secs(1));
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 æ‰¹é‡å‘é€

```rust
use crossbeam::channel;
use std::thread;
use std::time::Instant;

fn benchmark_individual_send() -> u128 {
    let (tx, rx) = channel::unbounded();

    let sender = thread::spawn(move || {
        for i in 0..10000 {
            tx.send(i).unwrap();
        }
    });

    let start = Instant::now();
    let receiver = thread::spawn(move || {
        for _ in rx {}
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn benchmark_batch_send() -> u128 {
    let (tx, rx) = channel::unbounded();

    let sender = thread::spawn(move || {
        let batch_size = 100;
        for chunk_start in (0..10000).step_by(batch_size) {
            let batch: Vec<_> = (chunk_start..chunk_start + batch_size).collect();
            tx.send(batch).unwrap();
        }
    });

    let start = Instant::now();
    let receiver = thread::spawn(move || {
        for batch in rx {
            let _: Vec<i32> = batch;
        }
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn main() {
    let individual = benchmark_individual_send();
    let batched = benchmark_batch_send();

    println!("Individual send: {} Î¼s", individual);
    println!("Batch send:      {} Î¼s", batched);
    println!("Speedup:         {:.2}x", individual as f64 / batched as f64);
}
```

### 8.2 é€‰æ‹©åˆé€‚çš„ Channel å®ç°

```rust
use std::time::Instant;
use std::thread;

fn benchmark_std_mpsc() -> u128 {
    use std::sync::mpsc;

    let (tx, rx) = mpsc::channel();
    let start = Instant::now();

    let sender = thread::spawn(move || {
        for i in 0..100000 {
            tx.send(i).unwrap();
        }
    });

    let receiver = thread::spawn(move || {
        for _ in rx {}
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn benchmark_crossbeam() -> u128 {
    use crossbeam::channel;

    let (tx, rx) = channel::unbounded();
    let start = Instant::now();

    let sender = thread::spawn(move || {
        for i in 0..100000 {
            tx.send(i).unwrap();
        }
    });

    let receiver = thread::spawn(move || {
        for _ in rx {}
    });

    sender.join().unwrap();
    receiver.join().unwrap();

    start.elapsed().as_micros()
}

fn main() {
    let std_time = benchmark_std_mpsc();
    let crossbeam_time = benchmark_crossbeam();

    println!("std::mpsc:  {} Î¼s", std_time);
    println!("crossbeam:  {} Î¼s", crossbeam_time);
    println!("Speedup:    {:.2}x", std_time as f64 / crossbeam_time as f64);
}
```

---

## 9. æœ€ä½³å®è·µ

### 9.1 å§‹ç»ˆ Drop ä¸éœ€è¦çš„å‘é€è€…

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx_clone = tx.clone();
    thread::spawn(move || {
        tx_clone.send(1).unwrap();
    });

    // âŒ å¿˜è®° dropï¼Œrx.iter() ä¼šæ°¸è¿œç­‰å¾…
    // for msg in rx {
    //     println!("{}", msg);
    // }

    // âœ… æ­£ç¡®ï¼šdrop ä¸éœ€è¦çš„ tx
    drop(tx);

    for msg in rx {
        println!("{}", msg);
    }
}
```

### 9.2 å¤„ç†å‘é€å¤±è´¥

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    // æ¥æ”¶è€…æå‰é€€å‡º
    drop(rx);

    // å‘é€ä¼šå¤±è´¥
    match tx.send(42) {
        Ok(_) => println!("Sent successfully"),
        Err(e) => {
            eprintln!("Send failed: {}", e);
            // å¤„ç†é”™è¯¯ï¼Œä¾‹å¦‚è®°å½•æ—¥å¿—ã€é‡è¯•ç­‰
        }
    }
}
```

### 9.3 é¿å…æ— ç•Œ Channel çš„å†…å­˜æ³„æ¼

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn main() {
    // âŒ å±é™©ï¼šå¿«é€Ÿç”Ÿäº§è€… + æ…¢é€Ÿæ¶ˆè´¹è€… = å†…å­˜æ³„æ¼
    let (tx, rx) = channel::unbounded();

    thread::spawn(move || {
        loop {
            tx.send(vec![0u8; 1024]).unwrap(); // æ¯ç§’å‘é€ 1MB
        }
    });

    thread::spawn(move || {
        for msg in rx {
            thread::sleep(Duration::from_secs(1)); // æ…¢é€Ÿå¤„ç†
        }
    });

    // âœ… æ¨èï¼šä½¿ç”¨æœ‰ç•Œ channel å®ç°èƒŒå‹
    let (tx_bounded, rx_bounded) = channel::bounded(100);

    // ç”Ÿäº§è€…ä¼šè¢«é™é€Ÿ
    thread::spawn(move || {
        loop {
            tx_bounded.send(vec![0u8; 1024]).unwrap(); // ä¼šé˜»å¡
        }
    });

    thread::spawn(move || {
        for msg in rx_bounded {
            thread::sleep(Duration::from_millis(10));
        }
    });

    thread::sleep(Duration::from_secs(5));
}
```

---

## 10. å‚è€ƒèµ„æº

### 10.1 å®˜æ–¹æ–‡æ¡£

- [std::sync::mpsc](https://doc.rust-lang.org/std/sync/mpsc/)
- [The Rust Book - Message Passing](https://doc.rust-lang.org/book/ch16-02-message-passing.html)

### 10.2 æ¨è Crates

- [`crossbeam-channel`](https://docs.rs/crossbeam-channel) - é«˜æ€§èƒ½ channel
- [`flume`](https://docs.rs/flume) - å¿«é€Ÿ MPMC channel
- [`tokio::sync::mpsc`](https://docs.rs/tokio/latest/tokio/sync/mpsc/) - å¼‚æ­¥ channel

### 10.3 è¿›é˜¶é˜…è¯»

- [Crossbeam Channel Design](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel)
- [Message Passing Patterns](https://www.lurklurk.org/effective-rust/channels.html)

### 10.4 å†…éƒ¨æ–‡æ¡£é“¾æ¥

- [â† ä¸Šä¸€ç¯‡ï¼šåŒæ­¥åŸè¯­å®è·µ](./02_åŒæ­¥åŸè¯­å®è·µ.md)
- [â†’ ä¸‹ä¸€ç¯‡ï¼šå¹¶è¡Œç¼–ç¨‹æŒ‡å—](./04_å¹¶è¡Œç¼–ç¨‹æŒ‡å—.md)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
