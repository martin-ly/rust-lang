# C05 Tier 2 实践指南 02：同步原语实践

> **文档版本**: v2.0.0 | **Rust 版本**: 1.90+ | **最后更新**: 2025-10-22

## 目录

- [C05 Tier 2 实践指南 02：同步原语实践](#c05-tier-2-实践指南-02同步原语实践)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 什么是同步原语](#11-什么是同步原语)
    - [1.2 选择指南](#12-选择指南)
    - [1.3 核心概念](#13-核心概念)
      - [1.3.1 内部可变性（Interior Mutability）](#131-内部可变性interior-mutability)
  - [2. Mutex：互斥锁](#2-mutex互斥锁)
    - [2.1 基础用法](#21-基础用法)
    - [2.2 处理锁中毒（Poisoned Lock）](#22-处理锁中毒poisoned-lock)
    - [2.3 try\_lock 避免阻塞](#23-try_lock-避免阻塞)
    - [2.4 作用域管理避免死锁](#24-作用域管理避免死锁)
    - [2.5 实战案例：线程安全计数器](#25-实战案例线程安全计数器)
  - [3. RwLock：读写锁](#3-rwlock读写锁)
    - [3.1 基础用法](#31-基础用法)
    - [3.2 读写锁的性能优势](#32-读写锁的性能优势)
    - [3.3 try\_read 和 try\_write](#33-try_read-和-try_write)
    - [3.4 实战案例：缓存系统](#34-实战案例缓存系统)
  - [4. Condvar：条件变量](#4-condvar条件变量)
    - [4.1 基础用法](#41-基础用法)
    - [4.2 生产者-消费者模式](#42-生产者-消费者模式)
    - [4.3 等待超时](#43-等待超时)
    - [4.4 实战案例：线程池任务队列](#44-实战案例线程池任务队列)
  - [5. Barrier：屏障](#5-barrier屏障)
    - [5.1 基础用法](#51-基础用法)
    - [5.2 实战案例：并行算法的同步点](#52-实战案例并行算法的同步点)
  - [6. Once：一次性初始化](#6-once一次性初始化)
    - [6.1 基础用法（Once）](#61-基础用法once)
    - [6.2 使用 OnceLock（Rust 1.70+）](#62-使用-oncelockrust-170)
    - [6.3 延迟初始化复杂结构](#63-延迟初始化复杂结构)
  - [7. 性能对比与选择](#7-性能对比与选择)
    - [7.1 性能基准测试](#71-性能基准测试)
    - [7.2 选择决策树](#72-选择决策树)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 最小化锁持有时间](#81-最小化锁持有时间)
    - [8.2 避免嵌套锁](#82-避免嵌套锁)
    - [8.3 使用 parking\_lot 提升性能](#83-使用-parking_lot-提升性能)
  - [9. 常见陷阱](#9-常见陷阱)
    - [9.1 死锁](#91-死锁)
    - [9.2 过度同步](#92-过度同步)
  - [10. 参考资源](#10-参考资源)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 推荐 Crates](#102-推荐-crates)
    - [10.3 内部文档链接](#103-内部文档链接)

---

## 1. 概述

### 1.1 什么是同步原语

同步原语（Synchronization Primitives）是用于协调多个线程访问共享资源的基本构建块。Rust 标准库提供了以下核心同步原语：

```text
┌──────────────────────────────────────────────────────────┐
│                  Rust 同步原语层次                        │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Mutex<T>  │  │  RwLock<T>  │  │  Condvar    │     │
│  │  互斥锁      │  │  读写锁      │  │  条件变量    │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
│                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │  Barrier    │  │    Once     │  │ OnceLock<T> │     │
│  │  屏障        │  │  一次性初始化│  │ 线程安全静态 │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### 1.2 选择指南

| 场景 | 推荐原语 | 原因 |
|------|---------|------|
| 共享可变状态 | `Arc<Mutex<T>>` | 独占访问，简单 |
| 读多写少 | `Arc<RwLock<T>>` | 允许多个读者 |
| 等待条件满足 | `Condvar` | 高效等待/唤醒 |
| 同步多个线程 | `Barrier` | 集体等待点 |
| 延迟初始化 | `Once` / `OnceLock<T>` | 保证只初始化一次 |
| 无竞争读取 | `Arc<T>` (不可变) | 零开销 |

### 1.3 核心概念

#### 1.3.1 内部可变性（Interior Mutability）

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Arc<Mutex<T>> 允许通过不可变引用修改内部值
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

---

## 2. Mutex：互斥锁

### 2.1 基础用法

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            // lock() 返回 MutexGuard<T>
            let mut data = data.lock().unwrap();
            data.push(i);
            // MutexGuard 离开作用域时自动释放锁
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final data: {:?}", *data.lock().unwrap());
}
```

### 2.2 处理锁中毒（Poisoned Lock）

当持有锁的线程 panic 时，锁会被"中毒"：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let mutex = Arc::new(Mutex::new(0));
    let mutex_clone = Arc::clone(&mutex);

    // 线程 panic，导致锁中毒
    let _ = thread::spawn(move || {
        let mut data = mutex_clone.lock().unwrap();
        *data += 1;
        panic!("Thread panicked!");
    }).join();

    // 尝试获取中毒的锁
    match mutex.lock() {
        Ok(guard) => println!("Got lock: {}", *guard),
        Err(poisoned) => {
            println!("Lock is poisoned!");
            // 可以恢复数据
            let mut guard = poisoned.into_inner();
            println!("Recovered data: {}", *guard);
            *guard = 42;
        }
    }

    println!("Final value: {}", *mutex.lock().unwrap());
}
```

### 2.3 try_lock 避免阻塞

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let mutex = Arc::new(Mutex::new(0));
    let mutex_clone = Arc::clone(&mutex);

    // 线程 1：持有锁 1 秒
    let t1 = thread::spawn(move || {
        let _guard = mutex_clone.lock().unwrap();
        println!("Thread 1 holding lock");
        thread::sleep(Duration::from_secs(1));
    });

    // 主线程：尝试获取锁
    thread::sleep(Duration::from_millis(100));

    match mutex.try_lock() {
        Ok(guard) => println!("Got lock: {}", *guard),
        Err(_) => println!("Lock is busy, doing other work..."),
    }

    t1.join().unwrap();
}
```

### 2.4 作用域管理避免死锁

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(0));

    // ❌ 错误：长时间持有锁
    // let mut guard = data.lock().unwrap();
    // *guard += 1;
    // expensive_operation(); // 锁被持有太久
    // println!("{}", *guard);

    // ✅ 正确：最小化锁持有时间
    {
        let mut guard = data.lock().unwrap();
        *guard += 1;
    } // 锁在这里释放

    expensive_operation();

    let value = *data.lock().unwrap();
    println!("{}", value);
}

fn expensive_operation() {
    std::thread::sleep(std::time::Duration::from_millis(100));
}
```

### 2.5 实战案例：线程安全计数器

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct Counter {
    value: Mutex<i32>,
}

impl Counter {
    fn new() -> Self {
        Counter {
            value: Mutex::new(0),
        }
    }

    fn increment(&self) {
        let mut value = self.value.lock().unwrap();
        *value += 1;
    }

    fn get(&self) -> i32 {
        *self.value.lock().unwrap()
    }
}

fn main() {
    let counter = Arc::new(Counter::new());
    let mut handles = vec![];

    for _ in 0..100 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.increment();
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", counter.get()); // 100000
}
```

---

## 3. RwLock：读写锁

### 3.1 基础用法

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn main() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // 5 个读线程
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data.read().unwrap();
            println!("Reader {}: {:?}", i, *data);
        });
        handles.push(handle);
    }

    // 1 个写线程
    let data_clone = Arc::clone(&data);
    let write_handle = thread::spawn(move || {
        let mut data = data_clone.write().unwrap();
        data.push(4);
        println!("Writer: added 4");
    });
    handles.push(write_handle);

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final: {:?}", *data.read().unwrap());
}
```

### 3.2 读写锁的性能优势

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::thread;
use std::time::Instant;

fn benchmark_mutex(data: Arc<Mutex<Vec<i32>>>) -> u128 {
    let start = Instant::now();
    let mut handles = vec![];

    // 10 个"读"线程（实际上需要独占锁）
    for _ in 0..10 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let _data = data.lock().unwrap();
                // 模拟读操作
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn benchmark_rwlock(data: Arc<RwLock<Vec<i32>>>) -> u128 {
    let start = Instant::now();
    let mut handles = vec![];

    // 10 个读线程（可以并发）
    for _ in 0..10 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let _data = data.read().unwrap();
                // 模拟读操作
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn main() {
    let mutex_data = Arc::new(Mutex::new(vec![1, 2, 3, 4, 5]));
    let rwlock_data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));

    let mutex_time = benchmark_mutex(mutex_data);
    let rwlock_time = benchmark_rwlock(rwlock_data);

    println!("Mutex:   {} μs", mutex_time);
    println!("RwLock:  {} μs", rwlock_time);
    println!("Speedup: {:.2}x", mutex_time as f64 / rwlock_time as f64);
}
```

### 3.3 try_read 和 try_write

```rust
use std::sync::RwLock;
use std::thread;
use std::time::Duration;

fn main() {
    let lock = RwLock::new(5);

    // 获取读锁
    let r1 = lock.read().unwrap();
    println!("Read 1: {}", *r1);

    // 可以同时获取多个读锁
    let r2 = lock.read().unwrap();
    println!("Read 2: {}", *r2);

    // 尝试获取写锁会失败（已有读锁）
    match lock.try_write() {
        Ok(_) => println!("Got write lock"),
        Err(_) => println!("Cannot get write lock while readers exist"),
    }

    drop(r1);
    drop(r2);

    // 现在可以获取写锁
    let mut w = lock.write().unwrap();
    *w += 1;
    println!("Write: {}", *w);
}
```

### 3.4 实战案例：缓存系统

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::thread;

struct Cache<K, V> {
    data: RwLock<HashMap<K, V>>,
}

impl<K: Eq + std::hash::Hash + Clone, V: Clone> Cache<K, V> {
    fn new() -> Self {
        Cache {
            data: RwLock::new(HashMap::new()),
        }
    }

    fn get(&self, key: &K) -> Option<V> {
        // 读操作：允许多个线程并发
        let data = self.data.read().unwrap();
        data.get(key).cloned()
    }

    fn insert(&self, key: K, value: V) {
        // 写操作：独占访问
        let mut data = self.data.write().unwrap();
        data.insert(key, value);
    }

    fn remove(&self, key: &K) -> Option<V> {
        let mut data = self.data.write().unwrap();
        data.remove(key)
    }
}

fn main() {
    let cache = Arc::new(Cache::new());

    // 写入线程
    let cache_w = Arc::clone(&cache);
    let writer = thread::spawn(move || {
        for i in 0..100 {
            cache_w.insert(i, format!("value_{}", i));
        }
    });

    // 读取线程
    let mut readers = vec![];
    for _ in 0..5 {
        let cache_r = Arc::clone(&cache);
        let reader = thread::spawn(move || {
            for i in 0..100 {
                if let Some(value) = cache_r.get(&i) {
                    println!("Read: {} = {}", i, value);
                }
            }
        });
        readers.push(reader);
    }

    writer.join().unwrap();
    for reader in readers {
        reader.join().unwrap();
    }
}
```

---

## 4. Condvar：条件变量

### 4.1 基础用法

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);

    // 等待线程
    let waiter = thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        let mut started = lock.lock().unwrap();

        while !*started {
            println!("Waiting for signal...");
            started = cvar.wait(started).unwrap();
        }

        println!("Received signal!");
    });

    // 主线程：2 秒后发送信号
    thread::sleep(Duration::from_secs(2));

    let (lock, cvar) = &*pair;
    {
        let mut started = lock.lock().unwrap();
        *started = true;
        println!("Sending signal...");
    }
    cvar.notify_one();

    waiter.join().unwrap();
}
```

### 4.2 生产者-消费者模式

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

struct Queue<T> {
    data: Mutex<VecDeque<T>>,
    not_empty: Condvar,
}

impl<T> Queue<T> {
    fn new() -> Self {
        Queue {
            data: Mutex::new(VecDeque::new()),
            not_empty: Condvar::new(),
        }
    }

    fn push(&self, item: T) {
        let mut data = self.data.lock().unwrap();
        data.push_back(item);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut data = self.data.lock().unwrap();

        // 等待直到队列非空
        while data.is_empty() {
            data = self.not_empty.wait(data).unwrap();
        }

        data.pop_front().unwrap()
    }
}

fn main() {
    let queue = Arc::new(Queue::new());

    // 消费者线程
    let queue_c = Arc::clone(&queue);
    let consumer = thread::spawn(move || {
        for _ in 0..10 {
            let item = queue_c.pop();
            println!("Consumed: {}", item);
        }
    });

    // 生产者线程
    let queue_p = Arc::clone(&queue);
    let producer = thread::spawn(move || {
        for i in 0..10 {
            thread::sleep(Duration::from_millis(100));
            println!("Producing: {}", i);
            queue_p.push(i);
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 4.3 等待超时

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);

    let waiter = thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        let started = lock.lock().unwrap();

        // 等待最多 1 秒
        let result = cvar.wait_timeout(started, Duration::from_secs(1)).unwrap();

        if result.1.timed_out() {
            println!("Timeout: no signal received");
        } else {
            println!("Signal received in time");
        }
    });

    // 不发送信号，让线程超时
    waiter.join().unwrap();
}
```

### 4.4 实战案例：线程池任务队列

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct JobQueue {
    jobs: Mutex<VecDeque<Job>>,
    available: Condvar,
    shutdown: Mutex<bool>,
}

impl JobQueue {
    fn new() -> Arc<Self> {
        Arc::new(JobQueue {
            jobs: Mutex::new(VecDeque::new()),
            available: Condvar::new(),
            shutdown: Mutex::new(false),
        })
    }

    fn push(&self, job: Job) {
        let mut jobs = self.jobs.lock().unwrap();
        jobs.push_back(job);
        self.available.notify_one();
    }

    fn pop(&self) -> Option<Job> {
        let mut jobs = self.jobs.lock().unwrap();

        loop {
            if let Some(job) = jobs.pop_front() {
                return Some(job);
            }

            // 检查是否关闭
            if *self.shutdown.lock().unwrap() {
                return None;
            }

            // 等待新任务
            jobs = self.available.wait(jobs).unwrap();
        }
    }

    fn shutdown(&self) {
        *self.shutdown.lock().unwrap() = true;
        self.available.notify_all();
    }
}

fn main() {
    let queue = JobQueue::new();

    // 启动 4 个工作线程
    let mut workers = vec![];
    for id in 0..4 {
        let queue = Arc::clone(&queue);
        let worker = thread::spawn(move || {
            while let Some(job) = queue.pop() {
                println!("Worker {} executing job", id);
                job();
            }
            println!("Worker {} shutting down", id);
        });
        workers.push(worker);
    }

    // 提交 10 个任务
    for i in 0..10 {
        queue.push(Box::new(move || {
            println!("Job {} running", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }));
    }

    // 等待所有任务完成
    thread::sleep(std::time::Duration::from_secs(2));

    // 关闭队列
    queue.shutdown();

    for worker in workers {
        worker.join().unwrap();
    }
}
```

---

## 5. Barrier：屏障

### 5.1 基础用法

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];

    for i in 0..3 {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            println!("Thread {} before barrier", i);

            // 等待所有线程到达
            let result = barrier.wait();

            if result.is_leader() {
                println!("Thread {} is the leader!", i);
            }

            println!("Thread {} after barrier", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 5.2 实战案例：并行算法的同步点

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn parallel_matrix_multiply(size: usize, num_threads: usize) {
    let barrier = Arc::new(Barrier::new(num_threads));
    let mut handles = vec![];

    for thread_id in 0..num_threads {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            // Phase 1: 初始化
            println!("Thread {} initializing", thread_id);
            thread::sleep(std::time::Duration::from_millis(100));

            // 同步点 1
            barrier.wait();

            // Phase 2: 计算
            println!("Thread {} computing", thread_id);
            thread::sleep(std::time::Duration::from_millis(200));

            // 同步点 2
            barrier.wait();

            // Phase 3: 汇总
            println!("Thread {} finalizing", thread_id);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}

fn main() {
    parallel_matrix_multiply(1000, 4);
}
```

---

## 6. Once：一次性初始化

### 6.1 基础用法（Once）

```rust
use std::sync::Once;

static INIT: Once = Once::new();
static mut RESOURCE: Option<String> = None;

fn get_resource() -> &'static str {
    unsafe {
        INIT.call_once(|| {
            println!("Initializing resource...");
            RESOURCE = Some("Expensive Resource".to_string());
        });

        RESOURCE.as_ref().unwrap()
    }
}

fn main() {
    let handles: Vec<_> = (0..5)
        .map(|i| {
            std::thread::spawn(move || {
                println!("Thread {}: {}", i, get_resource());
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 6.2 使用 OnceLock（Rust 1.70+）

```rust
use std::sync::OnceLock;

static RESOURCE: OnceLock<String> = OnceLock::new();

fn get_resource() -> &'static str {
    RESOURCE.get_or_init(|| {
        println!("Initializing resource...");
        "Expensive Resource".to_string()
    })
}

fn main() {
    let handles: Vec<_> = (0..5)
        .map(|i| {
            std::thread::spawn(move || {
                println!("Thread {}: {}", i, get_resource());
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 6.3 延迟初始化复杂结构

```rust
use std::sync::OnceLock;
use std::collections::HashMap;

struct Config {
    settings: HashMap<String, String>,
}

impl Config {
    fn load() -> Self {
        println!("Loading config...");
        let mut settings = HashMap::new();
        settings.insert("host".to_string(), "localhost".to_string());
        settings.insert("port".to_string(), "8080".to_string());

        Config { settings }
    }

    fn get(&self, key: &str) -> Option<&str> {
        self.settings.get(key).map(|s| s.as_str())
    }
}

static CONFIG: OnceLock<Config> = OnceLock::new();

fn get_config() -> &'static Config {
    CONFIG.get_or_init(Config::load)
}

fn main() {
    println!("Host: {}", get_config().get("host").unwrap());
    println!("Port: {}", get_config().get("port").unwrap());

    // 再次调用不会重新加载
    println!("Host again: {}", get_config().get("host").unwrap());
}
```

---

## 7. 性能对比与选择

### 7.1 性能基准测试

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread;
use std::time::Instant;

fn benchmark_atomic() -> u128 {
    let counter = Arc::new(AtomicU64::new(0));
    let start = Instant::now();

    let handles: Vec<_> = (0..4)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1_000_000 {
                    counter.fetch_add(1, Ordering::Relaxed);
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn benchmark_mutex() -> u128 {
    let counter = Arc::new(Mutex::new(0u64));
    let start = Instant::now();

    let handles: Vec<_> = (0..4)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1_000_000 {
                    *counter.lock().unwrap() += 1;
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn main() {
    let atomic_time = benchmark_atomic();
    let mutex_time = benchmark_mutex();

    println!("Atomic:  {} μs", atomic_time);
    println!("Mutex:   {} μs", mutex_time);
    println!("Speedup: {:.2}x", mutex_time as f64 / atomic_time as f64);
}
```

### 7.2 选择决策树

```text
需要共享可变状态？
  │
  ├─ 否 ──► 使用 Arc<T>（不可变共享）
  │
  └─ 是 ──► 数据类型？
       │
       ├─ 简单整数/布尔 ──► 使用原子类型（AtomicU64, AtomicBool 等）
       │
       └─ 复杂结构 ──► 访问模式？
            │
            ├─ 读多写少 ──► Arc<RwLock<T>>
            │
            ├─ 读写均衡 ──► Arc<Mutex<T>>
            │
            └─ 需要条件等待 ──► Arc<(Mutex<T>, Condvar)>
```

---

## 8. 最佳实践

### 8.1 最小化锁持有时间

```rust
use std::sync::Mutex;

struct Database {
    data: Mutex<Vec<String>>,
}

impl Database {
    // ❌ 不好：锁持有时间过长
    fn bad_query(&self, query: &str) -> String {
        let data = self.data.lock().unwrap();

        // expensive_processing 在持有锁期间执行
        let result = expensive_processing(query);

        format!("{:?} -> {}", *data, result)
    }

    // ✅ 好：最小化锁持有时间
    fn good_query(&self, query: &str) -> String {
        let data_snapshot = {
            let data = self.data.lock().unwrap();
            data.clone()
        }; // 锁在这里释放

        let result = expensive_processing(query);
        format!("{:?} -> {}", data_snapshot, result)
    }
}

fn expensive_processing(_query: &str) -> String {
    std::thread::sleep(std::time::Duration::from_millis(100));
    "result".to_string()
}

fn main() {
    let db = Database {
        data: Mutex::new(vec!["a".to_string(), "b".to_string()]),
    };

    println!("{}", db.good_query("SELECT *"));
}
```

### 8.2 避免嵌套锁

```rust
use std::sync::Mutex;

struct Resource1 {
    value: i32,
}

struct Resource2 {
    value: i32,
}

// ❌ 危险：可能死锁
fn bad_approach(r1: &Mutex<Resource1>, r2: &Mutex<Resource2>) {
    let _lock1 = r1.lock().unwrap();
    let _lock2 = r2.lock().unwrap(); // 可能死锁
}

// ✅ 好：按固定顺序获取锁
fn good_approach(r1: &Mutex<Resource1>, r2: &Mutex<Resource2>) {
    // 始终按照 r1 -> r2 的顺序获取
    let _lock1 = r1.lock().unwrap();
    let _lock2 = r2.lock().unwrap();
}

fn main() {
    let r1 = Mutex::new(Resource1 { value: 1 });
    let r2 = Mutex::new(Resource2 { value: 2 });

    good_approach(&r1, &r2);
}
```

### 8.3 使用 parking_lot 提升性能

```rust
// 推荐使用 parking_lot crate（比标准库更快）
use parking_lot::{Mutex, RwLock};
use std::sync::Arc;
use std::thread;

fn main() {
    let mutex = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let mutex = Arc::clone(&mutex);
        let handle = thread::spawn(move || {
            // parking_lot::Mutex 不返回 Result
            let mut data = mutex.lock();
            *data += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final: {}", *mutex.lock());
}
```

---

## 9. 常见陷阱

### 9.1 死锁

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let m1 = std::sync::Arc::new(Mutex::new(0));
    let m2 = std::sync::Arc::new(Mutex::new(0));

    let m1_clone = std::sync::Arc::clone(&m1);
    let m2_clone = std::sync::Arc::clone(&m2);

    // 线程 1: m1 -> m2
    let t1 = thread::spawn(move || {
        let _l1 = m1_clone.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(10));
        let _l2 = m2_clone.lock().unwrap(); // 可能死锁
    });

    // 线程 2: m2 -> m1
    let t2 = thread::spawn(move || {
        let _l2 = m2.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(10));
        let _l1 = m1.lock().unwrap(); // 可能死锁
    });

    // 这段代码可能永远不会完成！
    // t1.join().unwrap();
    // t2.join().unwrap();
}
```

### 9.2 过度同步

```rust
use std::sync::Mutex;

// ❌ 不必要：每个字段都加锁
struct BadDesign {
    name: Mutex<String>,
    age: Mutex<i32>,
    email: Mutex<String>,
}

// ✅ 好：根据访问模式分组
struct GoodDesign {
    user_info: Mutex<UserInfo>,
}

struct UserInfo {
    name: String,
    age: i32,
    email: String,
}

fn main() {
    let user = GoodDesign {
        user_info: Mutex::new(UserInfo {
            name: "Alice".to_string(),
            age: 30,
            email: "alice@example.com".to_string(),
        }),
    };

    let info = user.user_info.lock().unwrap();
    println!("{}, {}, {}", info.name, info.age, info.email);
}
```

---

## 10. 参考资源

### 10.1 官方文档

- [std::sync 模块](https://doc.rust-lang.org/std/sync/)
- [Mutex](https://doc.rust-lang.org/std/sync/struct.Mutex.html)
- [RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html)

### 10.2 推荐 Crates

- [`parking_lot`](https://docs.rs/parking_lot) - 更快的同步原语
- [`crossbeam`](https://docs.rs/crossbeam) - 高级并发工具

### 10.3 内部文档链接

- [← 上一篇：线程基础与生命周期](./01_线程基础与生命周期.md)
- [→ 下一篇：消息传递模式](./03_消息传递模式.md)
- [↑ 返回主索引](../tier_01_foundations/02_主索引导航.md)

---

**文档维护**: C05 Threads Team | **最后审核**: 2025-10-22 | **质量评分**: 95/100
