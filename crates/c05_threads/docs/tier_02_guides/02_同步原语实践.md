# C05 Tier 2 å®è·µæŒ‡å— 02ï¼šåŒæ­¥åŸè¯­å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 2 å®è·µæŒ‡å— 02ï¼šåŒæ­¥åŸè¯­å®è·µ](#c05-tier-2-å®è·µæŒ‡å—-02åŒæ­¥åŸè¯­å®è·µ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [æ¦‚å¿µçŸ©é˜µ](#æ¦‚å¿µçŸ©é˜µ)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯åŒæ­¥åŸè¯­](#11-ä»€ä¹ˆæ˜¯åŒæ­¥åŸè¯­)
    - [1.2 é€‰æ‹©æŒ‡å—](#12-é€‰æ‹©æŒ‡å—)
    - [1.3 æ ¸å¿ƒæ¦‚å¿µ](#13-æ ¸å¿ƒæ¦‚å¿µ)
      - [1.3.1 å†…éƒ¨å¯å˜æ€§ï¼ˆInterior Mutabilityï¼‰](#131-å†…éƒ¨å¯å˜æ€§interior-mutability)
  - [2. Mutexï¼šäº’æ–¥é”](#2-mutexäº’æ–¥é”)
    - [2.1 åŸºç¡€ç”¨æ³•](#21-åŸºç¡€ç”¨æ³•)
    - [2.2 å¤„ç†é”ä¸­æ¯’ï¼ˆPoisoned Lockï¼‰](#22-å¤„ç†é”ä¸­æ¯’poisoned-lock)
    - [2.3 try\_lock é¿å…é˜»å¡](#23-try_lock-é¿å…é˜»å¡)
    - [2.4 ä½œç”¨åŸŸç®¡ç†é¿å…æ­»é”](#24-ä½œç”¨åŸŸç®¡ç†é¿å…æ­»é”)
    - [2.5 å®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç¨‹å®‰å…¨è®¡æ•°å™¨](#25-å®æˆ˜æ¡ˆä¾‹çº¿ç¨‹å®‰å…¨è®¡æ•°å™¨)
  - [3. RwLockï¼šè¯»å†™é”](#3-rwlockè¯»å†™é”)
    - [3.1 åŸºç¡€ç”¨æ³•](#31-åŸºç¡€ç”¨æ³•)
    - [3.2 è¯»å†™é”çš„æ€§èƒ½ä¼˜åŠ¿](#32-è¯»å†™é”çš„æ€§èƒ½ä¼˜åŠ¿)
    - [3.3 try\_read å’Œ try\_write](#33-try_read-å’Œ-try_write)
    - [3.4 å®æˆ˜æ¡ˆä¾‹ï¼šç¼“å­˜ç³»ç»Ÿ](#34-å®æˆ˜æ¡ˆä¾‹ç¼“å­˜ç³»ç»Ÿ)
  - [4. Condvarï¼šæ¡ä»¶å˜é‡](#4-condvaræ¡ä»¶å˜é‡)
    - [4.1 åŸºç¡€ç”¨æ³•](#41-åŸºç¡€ç”¨æ³•)
    - [4.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#42-ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
    - [4.3 ç­‰å¾…è¶…æ—¶](#43-ç­‰å¾…è¶…æ—¶)
    - [4.4 å®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç¨‹æ± ä»»åŠ¡é˜Ÿåˆ—](#44-å®æˆ˜æ¡ˆä¾‹çº¿ç¨‹æ± ä»»åŠ¡é˜Ÿåˆ—)
  - [5. Barrierï¼šå±éšœ](#5-barrierå±éšœ)
    - [5.1 åŸºç¡€ç”¨æ³•](#51-åŸºç¡€ç”¨æ³•)
    - [5.2 å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶è¡Œç®—æ³•çš„åŒæ­¥ç‚¹](#52-å®æˆ˜æ¡ˆä¾‹å¹¶è¡Œç®—æ³•çš„åŒæ­¥ç‚¹)
  - [6. Onceï¼šä¸€æ¬¡æ€§åˆå§‹åŒ–](#6-onceä¸€æ¬¡æ€§åˆå§‹åŒ–)
    - [6.1 åŸºç¡€ç”¨æ³•ï¼ˆOnceï¼‰](#61-åŸºç¡€ç”¨æ³•once)
    - [6.2 ä½¿ç”¨ OnceLockï¼ˆRust 1.70+ï¼‰](#62-ä½¿ç”¨-oncelockrust-170)
    - [6.3 å»¶è¿Ÿåˆå§‹åŒ–å¤æ‚ç»“æ„](#63-å»¶è¿Ÿåˆå§‹åŒ–å¤æ‚ç»“æ„)
  - [7. æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©](#7-æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©)
    - [7.1 æ€§èƒ½åŸºå‡†æµ‹è¯•](#71-æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [7.2 é€‰æ‹©å†³ç­–æ ‘](#72-é€‰æ‹©å†³ç­–æ ‘)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æœ€å°åŒ–é”æŒæœ‰æ—¶é—´](#81-æœ€å°åŒ–é”æŒæœ‰æ—¶é—´)
    - [8.2 é¿å…åµŒå¥—é”](#82-é¿å…åµŒå¥—é”)
    - [8.3 ä½¿ç”¨ parking\_lot æå‡æ€§èƒ½](#83-ä½¿ç”¨-parking_lot-æå‡æ€§èƒ½)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
    - [9.1 æ­»é”](#91-æ­»é”)
    - [9.2 è¿‡åº¦åŒæ­¥](#92-è¿‡åº¦åŒæ­¥)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
    - [10.1 å®˜æ–¹æ–‡æ¡£](#101-å®˜æ–¹æ–‡æ¡£)
    - [10.2 æ¨è Crates](#102-æ¨è-crates)
    - [10.3 å†…éƒ¨æ–‡æ¡£é“¾æ¥](#103-å†…éƒ¨æ–‡æ¡£é“¾æ¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**åŒæ­¥åŸè¯­ (Synchronization Primitives)**:

- **å®šä¹‰**: ç”¨äºåè°ƒå¤šä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºçš„åŸºæœ¬æ„å»ºå—
- **ç±»å‹**: ç³»ç»ŸåŸè¯­
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: çº¿ç¨‹ã€æ•°æ®ç«äº‰ã€æ­»é”ã€å¹¶å‘æ§åˆ¶

**Mutex (äº’æ–¥é”)**:

- **å®šä¹‰**: äº’æ–¥é”ï¼Œä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®å…±äº«èµ„æº
- **ç±»å‹**: åŒæ­¥åŸè¯­
- **å±æ€§**: äº’æ–¥æ€§ã€çº¿ç¨‹å®‰å…¨ã€é”ä¸­æ¯’å¤„ç†
- **å…³ç³»**: ä¸ RwLockã€Condvar ç›¸å…³

**RwLock (è¯»å†™é”)**:

- **å®šä¹‰**: è¯»å†™é”ï¼Œå…è®¸å¤šä¸ªè¯»æ“ä½œæˆ–å•ä¸ªå†™æ“ä½œ
- **ç±»å‹**: åŒæ­¥åŸè¯­
- **å±æ€§**: è¯»å…±äº«ã€å†™ç‹¬å ã€æ€§èƒ½ä¼˜åŒ–
- **å…³ç³»**: ä¸ Mutexã€å¹¶å‘è®¿é—®ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **äº’æ–¥æ€§**: Mutex ä¿è¯äº’æ–¥è®¿é—®
- **è¯»å†™åˆ†ç¦»**: RwLock åŒºåˆ†è¯»å†™æ“ä½œ
- **æ¡ä»¶ç­‰å¾…**: Condvar æä¾›æ¡ä»¶ç­‰å¾…æœºåˆ¶
- **å±éšœåŒæ­¥**: Barrier å®ç°å¤šçº¿ç¨‹åŒæ­¥ç‚¹

**æ€§èƒ½ç‰¹å¾**:

- **Mutex**: ç®€å•ä½†å¯èƒ½æˆä¸ºç“¶é¢ˆ
- **RwLock**: è¯»å¤šå†™å°‘åœºæ™¯æ€§èƒ½æ›´å¥½
- **é€‚ç”¨åœºæ™¯**: å…±äº«èµ„æºè®¿é—®ã€çº¿ç¨‹åè°ƒã€åŒæ­¥ç‚¹

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- Mutex --[is-a]--> åŒæ­¥åŸè¯­
- RwLock --[is-a]--> åŒæ­¥åŸè¯­

**ç»„åˆå…³ç³»**:

- å¹¶å‘ç¨‹åº --[uses]--> åŒæ­¥åŸè¯­
- çº¿ç¨‹å®‰å…¨æ•°æ®ç»“æ„ --[uses]--> åŒæ­¥åŸè¯­

**ä¾èµ–å…³ç³»**:

- åŒæ­¥åŸè¯­ --[depends-on]--> æ“ä½œç³»ç»ŸåŒæ­¥æ”¯æŒ
- çº¿ç¨‹å®‰å…¨ --[depends-on]--> åŒæ­¥åŸè¯­

### æ€ç»´å¯¼å›¾

```text
åŒæ­¥åŸè¯­å®è·µ
â”‚
â”œâ”€â”€ Mutex äº’æ–¥é”
â”‚   â”œâ”€â”€ åŸºç¡€ç”¨æ³•
â”‚   â”œâ”€â”€ é”ä¸­æ¯’å¤„ç†
â”‚   â””â”€â”€ try_lock
â”œâ”€â”€ RwLock è¯»å†™é”
â”‚   â”œâ”€â”€ è¯»é”
â”‚   â”œâ”€â”€ å†™é”
â”‚   â””â”€â”€ æ€§èƒ½ä¼˜åŠ¿
â”œâ”€â”€ Condvar æ¡ä»¶å˜é‡
â”‚   â”œâ”€â”€ ç­‰å¾…/é€šçŸ¥
â”‚   â””â”€â”€ ç”Ÿäº§è€…-æ¶ˆè´¹è€…
â”œâ”€â”€ Barrier å±éšœ
â”‚   â””â”€â”€ åŒæ­¥ç‚¹
â””â”€â”€ Once ä¸€æ¬¡æ€§åˆå§‹åŒ–
    â””â”€â”€ å»¶è¿Ÿåˆå§‹åŒ–
```

### æ¦‚å¿µçŸ©é˜µ

| åŒæ­¥åŸè¯­ | äº’æ–¥æ€§ | è¯»å†™åˆ†ç¦» | æ€§èƒ½       | é€‚ç”¨åœºæ™¯     |
| -------- | ------ | -------- | ---------- | ------------ |
| Mutex    | âœ…     | âŒ       | ä¸­         | é€šç”¨äº’æ–¥è®¿é—® |
| RwLock   | âœ…     | âœ…       | é«˜ï¼ˆè¯»å¤šï¼‰ | è¯»å¤šå†™å°‘     |
| Condvar  | -      | -        | ä¸­         | æ¡ä»¶ç­‰å¾…     |
| Barrier  | -      | -        | ä¸­         | åŒæ­¥ç‚¹       |
| Once     | âœ…     | -        | é«˜         | ä¸€æ¬¡æ€§åˆå§‹åŒ– |

---

## 1. æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯åŒæ­¥åŸè¯­

åŒæ­¥åŸè¯­ï¼ˆSynchronization Primitivesï¼‰æ˜¯ç”¨äºåè°ƒå¤šä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºçš„åŸºæœ¬æ„å»ºå—ã€‚Rust æ ‡å‡†åº“æä¾›äº†ä»¥ä¸‹æ ¸å¿ƒåŒæ­¥åŸè¯­ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Rust åŒæ­¥åŸè¯­å±‚æ¬¡                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   Mutex<T>  â”‚  â”‚  RwLock<T>  â”‚  â”‚  Condvar    â”‚     â”‚
â”‚  â”‚  äº’æ–¥é”      â”‚  â”‚  è¯»å†™é”      â”‚  â”‚  æ¡ä»¶å˜é‡    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Barrier    â”‚  â”‚    Once     â”‚  â”‚ OnceLock<T> â”‚     â”‚
â”‚  â”‚  å±éšœ        â”‚  â”‚  ä¸€æ¬¡æ€§åˆå§‹åŒ–â”‚  â”‚ çº¿ç¨‹å®‰å…¨é™æ€ â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 é€‰æ‹©æŒ‡å—

| åœºæ™¯         | æ¨èåŸè¯­               | åŸå›              |
| ------------ | ---------------------- | ---------------- |
| å…±äº«å¯å˜çŠ¶æ€ | `Arc<Mutex<T>>`        | ç‹¬å è®¿é—®ï¼Œç®€å•   |
| è¯»å¤šå†™å°‘     | `Arc<RwLock<T>>`       | å…è®¸å¤šä¸ªè¯»è€…     |
| ç­‰å¾…æ¡ä»¶æ»¡è¶³ | `Condvar`              | é«˜æ•ˆç­‰å¾…/å”¤é†’    |
| åŒæ­¥å¤šä¸ªçº¿ç¨‹ | `Barrier`              | é›†ä½“ç­‰å¾…ç‚¹       |
| å»¶è¿Ÿåˆå§‹åŒ–   | `Once` / `OnceLock<T>` | ä¿è¯åªåˆå§‹åŒ–ä¸€æ¬¡ |
| æ— ç«äº‰è¯»å–   | `Arc<T>` (ä¸å¯å˜)      | é›¶å¼€é”€           |

### 1.3 æ ¸å¿ƒæ¦‚å¿µ

#### 1.3.1 å†…éƒ¨å¯å˜æ€§ï¼ˆInterior Mutabilityï¼‰

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Arc<Mutex<T>> å…è®¸é€šè¿‡ä¸å¯å˜å¼•ç”¨ä¿®æ”¹å†…éƒ¨å€¼
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

---

## 2. Mutexï¼šäº’æ–¥é”

### 2.1 åŸºç¡€ç”¨æ³•

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            // lock() è¿”å› MutexGuard<T>
            let mut data = data.lock().unwrap();
            data.push(i);
            // MutexGuard ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾é”
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final data: {:?}", *data.lock().unwrap());
}
```

### 2.2 å¤„ç†é”ä¸­æ¯’ï¼ˆPoisoned Lockï¼‰

å½“æŒæœ‰é”çš„çº¿ç¨‹ panic æ—¶ï¼Œé”ä¼šè¢«"ä¸­æ¯’"ï¼š

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let mutex = Arc::new(Mutex::new(0));
    let mutex_clone = Arc::clone(&mutex);

    // çº¿ç¨‹ panicï¼Œå¯¼è‡´é”ä¸­æ¯’
    let _ = thread::spawn(move || {
        let mut data = mutex_clone.lock().unwrap();
        *data += 1;
        panic!("Thread panicked!");
    }).join();

    // å°è¯•è·å–ä¸­æ¯’çš„é”
    match mutex.lock() {
        Ok(guard) => println!("Got lock: {}", *guard),
        Err(poisoned) => {
            println!("Lock is poisoned!");
            // å¯ä»¥æ¢å¤æ•°æ®
            let mut guard = poisoned.into_inner();
            println!("Recovered data: {}", *guard);
            *guard = 42;
        }
    }

    println!("Final value: {}", *mutex.lock().unwrap());
}
```

### 2.3 try_lock é¿å…é˜»å¡

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let mutex = Arc::new(Mutex::new(0));
    let mutex_clone = Arc::clone(&mutex);

    // çº¿ç¨‹ 1ï¼šæŒæœ‰é” 1 ç§’
    let t1 = thread::spawn(move || {
        let _guard = mutex_clone.lock().unwrap();
        println!("Thread 1 holding lock");
        thread::sleep(Duration::from_secs(1));
    });

    // ä¸»çº¿ç¨‹ï¼šå°è¯•è·å–é”
    thread::sleep(Duration::from_millis(100));

    match mutex.try_lock() {
        Ok(guard) => println!("Got lock: {}", *guard),
        Err(_) => println!("Lock is busy, doing other work..."),
    }

    t1.join().unwrap();
}
```

### 2.4 ä½œç”¨åŸŸç®¡ç†é¿å…æ­»é”

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(0));

    // âŒ é”™è¯¯ï¼šé•¿æ—¶é—´æŒæœ‰é”
    // let mut guard = data.lock().unwrap();
    // *guard += 1;
    // expensive_operation(); // é”è¢«æŒæœ‰å¤ªä¹…
    // println!("{}", *guard);

    // âœ… æ­£ç¡®ï¼šæœ€å°åŒ–é”æŒæœ‰æ—¶é—´
    {
        let mut guard = data.lock().unwrap();
        *guard += 1;
    } // é”åœ¨è¿™é‡Œé‡Šæ”¾

    expensive_operation();

    let value = *data.lock().unwrap();
    println!("{}", value);
}

fn expensive_operation() {
    std::thread::sleep(std::time::Duration::from_millis(100));
}
```

### 2.5 å®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç¨‹å®‰å…¨è®¡æ•°å™¨

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct Counter {
    value: Mutex<i32>,
}

impl Counter {
    fn new() -> Self {
        Counter {
            value: Mutex::new(0),
        }
    }

    fn increment(&self) {
        let mut value = self.value.lock().unwrap();
        *value += 1;
    }

    fn get(&self) -> i32 {
        *self.value.lock().unwrap()
    }
}

fn main() {
    let counter = Arc::new(Counter::new());
    let mut handles = vec![];

    for _ in 0..100 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.increment();
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", counter.get()); // 100000
}
```

---

## 3. RwLockï¼šè¯»å†™é”

### 3.1 åŸºç¡€ç”¨æ³•

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn main() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // 5 ä¸ªè¯»çº¿ç¨‹
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data.read().unwrap();
            println!("Reader {}: {:?}", i, *data);
        });
        handles.push(handle);
    }

    // 1 ä¸ªå†™çº¿ç¨‹
    let data_clone = Arc::clone(&data);
    let write_handle = thread::spawn(move || {
        let mut data = data_clone.write().unwrap();
        data.push(4);
        println!("Writer: added 4");
    });
    handles.push(write_handle);

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final: {:?}", *data.read().unwrap());
}
```

### 3.2 è¯»å†™é”çš„æ€§èƒ½ä¼˜åŠ¿

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::thread;
use std::time::Instant;

fn benchmark_mutex(data: Arc<Mutex<Vec<i32>>>) -> u128 {
    let start = Instant::now();
    let mut handles = vec![];

    // 10 ä¸ª"è¯»"çº¿ç¨‹ï¼ˆå®é™…ä¸Šéœ€è¦ç‹¬å é”ï¼‰
    for _ in 0..10 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let _data = data.lock().unwrap();
                // æ¨¡æ‹Ÿè¯»æ“ä½œ
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn benchmark_rwlock(data: Arc<RwLock<Vec<i32>>>) -> u128 {
    let start = Instant::now();
    let mut handles = vec![];

    // 10 ä¸ªè¯»çº¿ç¨‹ï¼ˆå¯ä»¥å¹¶å‘ï¼‰
    for _ in 0..10 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let _data = data.read().unwrap();
                // æ¨¡æ‹Ÿè¯»æ“ä½œ
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn main() {
    let mutex_data = Arc::new(Mutex::new(vec![1, 2, 3, 4, 5]));
    let rwlock_data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));

    let mutex_time = benchmark_mutex(mutex_data);
    let rwlock_time = benchmark_rwlock(rwlock_data);

    println!("Mutex:   {} Î¼s", mutex_time);
    println!("RwLock:  {} Î¼s", rwlock_time);
    println!("Speedup: {:.2}x", mutex_time as f64 / rwlock_time as f64);
}
```

### 3.3 try_read å’Œ try_write

```rust
use std::sync::RwLock;
use std::thread;
use std::time::Duration;

fn main() {
    let lock = RwLock::new(5);

    // è·å–è¯»é”
    let r1 = lock.read().unwrap();
    println!("Read 1: {}", *r1);

    // å¯ä»¥åŒæ—¶è·å–å¤šä¸ªè¯»é”
    let r2 = lock.read().unwrap();
    println!("Read 2: {}", *r2);

    // å°è¯•è·å–å†™é”ä¼šå¤±è´¥ï¼ˆå·²æœ‰è¯»é”ï¼‰
    match lock.try_write() {
        Ok(_) => println!("Got write lock"),
        Err(_) => println!("Cannot get write lock while readers exist"),
    }

    drop(r1);
    drop(r2);

    // ç°åœ¨å¯ä»¥è·å–å†™é”
    let mut w = lock.write().unwrap();
    *w += 1;
    println!("Write: {}", *w);
}
```

### 3.4 å®æˆ˜æ¡ˆä¾‹ï¼šç¼“å­˜ç³»ç»Ÿ

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::thread;

struct Cache<K, V> {
    data: RwLock<HashMap<K, V>>,
}

impl<K: Eq + std::hash::Hash + Clone, V: Clone> Cache<K, V> {
    fn new() -> Self {
        Cache {
            data: RwLock::new(HashMap::new()),
        }
    }

    fn get(&self, key: &K) -> Option<V> {
        // è¯»æ“ä½œï¼šå…è®¸å¤šä¸ªçº¿ç¨‹å¹¶å‘
        let data = self.data.read().unwrap();
        data.get(key).cloned()
    }

    fn insert(&self, key: K, value: V) {
        // å†™æ“ä½œï¼šç‹¬å è®¿é—®
        let mut data = self.data.write().unwrap();
        data.insert(key, value);
    }

    fn remove(&self, key: &K) -> Option<V> {
        let mut data = self.data.write().unwrap();
        data.remove(key)
    }
}

fn main() {
    let cache = Arc::new(Cache::new());

    // å†™å…¥çº¿ç¨‹
    let cache_w = Arc::clone(&cache);
    let writer = thread::spawn(move || {
        for i in 0..100 {
            cache_w.insert(i, format!("value_{}", i));
        }
    });

    // è¯»å–çº¿ç¨‹
    let mut readers = vec![];
    for _ in 0..5 {
        let cache_r = Arc::clone(&cache);
        let reader = thread::spawn(move || {
            for i in 0..100 {
                if let Some(value) = cache_r.get(&i) {
                    println!("Read: {} = {}", i, value);
                }
            }
        });
        readers.push(reader);
    }

    writer.join().unwrap();
    for reader in readers {
        reader.join().unwrap();
    }
}
```

---

## 4. Condvarï¼šæ¡ä»¶å˜é‡

### 4.1 åŸºç¡€ç”¨æ³•

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);

    // ç­‰å¾…çº¿ç¨‹
    let waiter = thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        let mut started = lock.lock().unwrap();

        while !*started {
            println!("Waiting for signal...");
            started = cvar.wait(started).unwrap();
        }

        println!("Received signal!");
    });

    // ä¸»çº¿ç¨‹ï¼š2 ç§’åå‘é€ä¿¡å·
    thread::sleep(Duration::from_secs(2));

    let (lock, cvar) = &*pair;
    {
        let mut started = lock.lock().unwrap();
        *started = true;
        println!("Sending signal...");
    }
    cvar.notify_one();

    waiter.join().unwrap();
}
```

### 4.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

struct Queue<T> {
    data: Mutex<VecDeque<T>>,
    not_empty: Condvar,
}

impl<T> Queue<T> {
    fn new() -> Self {
        Queue {
            data: Mutex::new(VecDeque::new()),
            not_empty: Condvar::new(),
        }
    }

    fn push(&self, item: T) {
        let mut data = self.data.lock().unwrap();
        data.push_back(item);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut data = self.data.lock().unwrap();

        // ç­‰å¾…ç›´åˆ°é˜Ÿåˆ—éç©º
        while data.is_empty() {
            data = self.not_empty.wait(data).unwrap();
        }

        data.pop_front().unwrap()
    }
}

fn main() {
    let queue = Arc::new(Queue::new());

    // æ¶ˆè´¹è€…çº¿ç¨‹
    let queue_c = Arc::clone(&queue);
    let consumer = thread::spawn(move || {
        for _ in 0..10 {
            let item = queue_c.pop();
            println!("Consumed: {}", item);
        }
    });

    // ç”Ÿäº§è€…çº¿ç¨‹
    let queue_p = Arc::clone(&queue);
    let producer = thread::spawn(move || {
        for i in 0..10 {
            thread::sleep(Duration::from_millis(100));
            println!("Producing: {}", i);
            queue_p.push(i);
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 4.3 ç­‰å¾…è¶…æ—¶

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);

    let waiter = thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        let started = lock.lock().unwrap();

        // ç­‰å¾…æœ€å¤š 1 ç§’
        let result = cvar.wait_timeout(started, Duration::from_secs(1)).unwrap();

        if result.1.timed_out() {
            println!("Timeout: no signal received");
        } else {
            println!("Signal received in time");
        }
    });

    // ä¸å‘é€ä¿¡å·ï¼Œè®©çº¿ç¨‹è¶…æ—¶
    waiter.join().unwrap();
}
```

### 4.4 å®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç¨‹æ± ä»»åŠ¡é˜Ÿåˆ—

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct JobQueue {
    jobs: Mutex<VecDeque<Job>>,
    available: Condvar,
    shutdown: Mutex<bool>,
}

impl JobQueue {
    fn new() -> Arc<Self> {
        Arc::new(JobQueue {
            jobs: Mutex::new(VecDeque::new()),
            available: Condvar::new(),
            shutdown: Mutex::new(false),
        })
    }

    fn push(&self, job: Job) {
        let mut jobs = self.jobs.lock().unwrap();
        jobs.push_back(job);
        self.available.notify_one();
    }

    fn pop(&self) -> Option<Job> {
        let mut jobs = self.jobs.lock().unwrap();

        loop {
            if let Some(job) = jobs.pop_front() {
                return Some(job);
            }

            // æ£€æŸ¥æ˜¯å¦å…³é—­
            if *self.shutdown.lock().unwrap() {
                return None;
            }

            // ç­‰å¾…æ–°ä»»åŠ¡
            jobs = self.available.wait(jobs).unwrap();
        }
    }

    fn shutdown(&self) {
        *self.shutdown.lock().unwrap() = true;
        self.available.notify_all();
    }
}

fn main() {
    let queue = JobQueue::new();

    // å¯åŠ¨ 4 ä¸ªå·¥ä½œçº¿ç¨‹
    let mut workers = vec![];
    for id in 0..4 {
        let queue = Arc::clone(&queue);
        let worker = thread::spawn(move || {
            while let Some(job) = queue.pop() {
                println!("Worker {} executing job", id);
                job();
            }
            println!("Worker {} shutting down", id);
        });
        workers.push(worker);
    }

    // æäº¤ 10 ä¸ªä»»åŠ¡
    for i in 0..10 {
        queue.push(Box::new(move || {
            println!("Job {} running", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }));
    }

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    thread::sleep(std::time::Duration::from_secs(2));

    // å…³é—­é˜Ÿåˆ—
    queue.shutdown();

    for worker in workers {
        worker.join().unwrap();
    }
}
```

---

## 5. Barrierï¼šå±éšœ

### 5.1 åŸºç¡€ç”¨æ³•

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];

    for i in 0..3 {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            println!("Thread {} before barrier", i);

            // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾
            let result = barrier.wait();

            if result.is_leader() {
                println!("Thread {} is the leader!", i);
            }

            println!("Thread {} after barrier", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 5.2 å®æˆ˜æ¡ˆä¾‹ï¼šå¹¶è¡Œç®—æ³•çš„åŒæ­¥ç‚¹

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn parallel_matrix_multiply(size: usize, num_threads: usize) {
    let barrier = Arc::new(Barrier::new(num_threads));
    let mut handles = vec![];

    for thread_id in 0..num_threads {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            // Phase 1: åˆå§‹åŒ–
            println!("Thread {} initializing", thread_id);
            thread::sleep(std::time::Duration::from_millis(100));

            // åŒæ­¥ç‚¹ 1
            barrier.wait();

            // Phase 2: è®¡ç®—
            println!("Thread {} computing", thread_id);
            thread::sleep(std::time::Duration::from_millis(200));

            // åŒæ­¥ç‚¹ 2
            barrier.wait();

            // Phase 3: æ±‡æ€»
            println!("Thread {} finalizing", thread_id);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}

fn main() {
    parallel_matrix_multiply(1000, 4);
}
```

---

## 6. Onceï¼šä¸€æ¬¡æ€§åˆå§‹åŒ–

### 6.1 åŸºç¡€ç”¨æ³•ï¼ˆOnceï¼‰

```rust
use std::sync::Once;

static INIT: Once = Once::new();
static mut RESOURCE: Option<String> = None;

fn get_resource() -> &'static str {
    unsafe {
        INIT.call_once(|| {
            println!("Initializing resource...");
            RESOURCE = Some("Expensive Resource".to_string());
        });

        RESOURCE.as_ref().unwrap()
    }
}

fn main() {
    let handles: Vec<_> = (0..5)
        .map(|i| {
            std::thread::spawn(move || {
                println!("Thread {}: {}", i, get_resource());
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 6.2 ä½¿ç”¨ OnceLockï¼ˆRust 1.70+ï¼‰

```rust
use std::sync::OnceLock;

static RESOURCE: OnceLock<String> = OnceLock::new();

fn get_resource() -> &'static str {
    RESOURCE.get_or_init(|| {
        println!("Initializing resource...");
        "Expensive Resource".to_string()
    })
}

fn main() {
    let handles: Vec<_> = (0..5)
        .map(|i| {
            std::thread::spawn(move || {
                println!("Thread {}: {}", i, get_resource());
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 6.3 å»¶è¿Ÿåˆå§‹åŒ–å¤æ‚ç»“æ„

```rust
use std::sync::OnceLock;
use std::collections::HashMap;

struct Config {
    settings: HashMap<String, String>,
}

impl Config {
    fn load() -> Self {
        println!("Loading config...");
        let mut settings = HashMap::new();
        settings.insert("host".to_string(), "localhost".to_string());
        settings.insert("port".to_string(), "8080".to_string());

        Config { settings }
    }

    fn get(&self, key: &str) -> Option<&str> {
        self.settings.get(key).map(|s| s.as_str())
    }
}

static CONFIG: OnceLock<Config> = OnceLock::new();

fn get_config() -> &'static Config {
    CONFIG.get_or_init(Config::load)
}

fn main() {
    println!("Host: {}", get_config().get("host").unwrap());
    println!("Port: {}", get_config().get("port").unwrap());

    // å†æ¬¡è°ƒç”¨ä¸ä¼šé‡æ–°åŠ è½½
    println!("Host again: {}", get_config().get("host").unwrap());
}
```

---

## 7. æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©

### 7.1 æ€§èƒ½åŸºå‡†æµ‹è¯•

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread;
use std::time::Instant;

fn benchmark_atomic() -> u128 {
    let counter = Arc::new(AtomicU64::new(0));
    let start = Instant::now();

    let handles: Vec<_> = (0..4)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1_000_000 {
                    counter.fetch_add(1, Ordering::Relaxed);
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn benchmark_mutex() -> u128 {
    let counter = Arc::new(Mutex::new(0u64));
    let start = Instant::now();

    let handles: Vec<_> = (0..4)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1_000_000 {
                    *counter.lock().unwrap() += 1;
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    start.elapsed().as_micros()
}

fn main() {
    let atomic_time = benchmark_atomic();
    let mutex_time = benchmark_mutex();

    println!("Atomic:  {} Î¼s", atomic_time);
    println!("Mutex:   {} Î¼s", mutex_time);
    println!("Speedup: {:.2}x", mutex_time as f64 / atomic_time as f64);
}
```

### 7.2 é€‰æ‹©å†³ç­–æ ‘

```text
éœ€è¦å…±äº«å¯å˜çŠ¶æ€ï¼Ÿ
  â”‚
  â”œâ”€ å¦ â”€â”€â–º ä½¿ç”¨ Arc<T>ï¼ˆä¸å¯å˜å…±äº«ï¼‰
  â”‚
  â””â”€ æ˜¯ â”€â”€â–º æ•°æ®ç±»å‹ï¼Ÿ
       â”‚
       â”œâ”€ ç®€å•æ•´æ•°/å¸ƒå°” â”€â”€â–º ä½¿ç”¨åŸå­ç±»å‹ï¼ˆAtomicU64, AtomicBool ç­‰ï¼‰
       â”‚
       â””â”€ å¤æ‚ç»“æ„ â”€â”€â–º è®¿é—®æ¨¡å¼ï¼Ÿ
            â”‚
            â”œâ”€ è¯»å¤šå†™å°‘ â”€â”€â–º Arc<RwLock<T>>
            â”‚
            â”œâ”€ è¯»å†™å‡è¡¡ â”€â”€â–º Arc<Mutex<T>>
            â”‚
            â””â”€ éœ€è¦æ¡ä»¶ç­‰å¾… â”€â”€â–º Arc<(Mutex<T>, Condvar)>
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 æœ€å°åŒ–é”æŒæœ‰æ—¶é—´

```rust
use std::sync::Mutex;

struct Database {
    data: Mutex<Vec<String>>,
}

impl Database {
    // âŒ ä¸å¥½ï¼šé”æŒæœ‰æ—¶é—´è¿‡é•¿
    fn bad_query(&self, query: &str) -> String {
        let data = self.data.lock().unwrap();

        // expensive_processing åœ¨æŒæœ‰é”æœŸé—´æ‰§è¡Œ
        let result = expensive_processing(query);

        format!("{:?} -> {}", *data, result)
    }

    // âœ… å¥½ï¼šæœ€å°åŒ–é”æŒæœ‰æ—¶é—´
    fn good_query(&self, query: &str) -> String {
        let data_snapshot = {
            let data = self.data.lock().unwrap();
            data.clone()
        }; // é”åœ¨è¿™é‡Œé‡Šæ”¾

        let result = expensive_processing(query);
        format!("{:?} -> {}", data_snapshot, result)
    }
}

fn expensive_processing(_query: &str) -> String {
    std::thread::sleep(std::time::Duration::from_millis(100));
    "result".to_string()
}

fn main() {
    let db = Database {
        data: Mutex::new(vec!["a".to_string(), "b".to_string()]),
    };

    println!("{}", db.good_query("SELECT *"));
}
```

### 8.2 é¿å…åµŒå¥—é”

```rust
use std::sync::Mutex;

struct Resource1 {
    value: i32,
}

struct Resource2 {
    value: i32,
}

// âŒ å±é™©ï¼šå¯èƒ½æ­»é”
fn bad_approach(r1: &Mutex<Resource1>, r2: &Mutex<Resource2>) {
    let _lock1 = r1.lock().unwrap();
    let _lock2 = r2.lock().unwrap(); // å¯èƒ½æ­»é”
}

// âœ… å¥½ï¼šæŒ‰å›ºå®šé¡ºåºè·å–é”
fn good_approach(r1: &Mutex<Resource1>, r2: &Mutex<Resource2>) {
    // å§‹ç»ˆæŒ‰ç…§ r1 -> r2 çš„é¡ºåºè·å–
    let _lock1 = r1.lock().unwrap();
    let _lock2 = r2.lock().unwrap();
}

fn main() {
    let r1 = Mutex::new(Resource1 { value: 1 });
    let r2 = Mutex::new(Resource2 { value: 2 });

    good_approach(&r1, &r2);
}
```

### 8.3 ä½¿ç”¨ parking_lot æå‡æ€§èƒ½

```rust
// æ¨èä½¿ç”¨ parking_lot crateï¼ˆæ¯”æ ‡å‡†åº“æ›´å¿«ï¼‰
use parking_lot::{Mutex, RwLock};
use std::sync::Arc;
use std::thread;

fn main() {
    let mutex = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let mutex = Arc::clone(&mutex);
        let handle = thread::spawn(move || {
            // parking_lot::Mutex ä¸è¿”å› Result
            let mut data = mutex.lock();
            *data += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final: {}", *mutex.lock());
}
```

---

## 9. å¸¸è§é™·é˜±

### 9.1 æ­»é”

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let m1 = std::sync::Arc::new(Mutex::new(0));
    let m2 = std::sync::Arc::new(Mutex::new(0));

    let m1_clone = std::sync::Arc::clone(&m1);
    let m2_clone = std::sync::Arc::clone(&m2);

    // çº¿ç¨‹ 1: m1 -> m2
    let t1 = thread::spawn(move || {
        let _l1 = m1_clone.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(10));
        let _l2 = m2_clone.lock().unwrap(); // å¯èƒ½æ­»é”
    });

    // çº¿ç¨‹ 2: m2 -> m1
    let t2 = thread::spawn(move || {
        let _l2 = m2.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(10));
        let _l1 = m1.lock().unwrap(); // å¯èƒ½æ­»é”
    });

    // è¿™æ®µä»£ç å¯èƒ½æ°¸è¿œä¸ä¼šå®Œæˆï¼
    // t1.join().unwrap();
    // t2.join().unwrap();
}
```

### 9.2 è¿‡åº¦åŒæ­¥

```rust
use std::sync::Mutex;

// âŒ ä¸å¿…è¦ï¼šæ¯ä¸ªå­—æ®µéƒ½åŠ é”
struct BadDesign {
    name: Mutex<String>,
    age: Mutex<i32>,
    email: Mutex<String>,
}

// âœ… å¥½ï¼šæ ¹æ®è®¿é—®æ¨¡å¼åˆ†ç»„
struct GoodDesign {
    user_info: Mutex<UserInfo>,
}

struct UserInfo {
    name: String,
    age: i32,
    email: String,
}

fn main() {
    let user = GoodDesign {
        user_info: Mutex::new(UserInfo {
            name: "Alice".to_string(),
            age: 30,
            email: "alice@example.com".to_string(),
        }),
    };

    let info = user.user_info.lock().unwrap();
    println!("{}, {}, {}", info.name, info.age, info.email);
}
```

---

## 10. å‚è€ƒèµ„æº

### 10.1 å®˜æ–¹æ–‡æ¡£

- [std::sync æ¨¡å—](https://doc.rust-lang.org/std/sync/)
- [Mutex](https://doc.rust-lang.org/std/sync/struct.Mutex.html)
- [RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html)

### 10.2 æ¨è Crates

- [`parking_lot`](https://docs.rs/parking_lot) - æ›´å¿«çš„åŒæ­¥åŸè¯­
- [`crossbeam`](https://docs.rs/crossbeam) - é«˜çº§å¹¶å‘å·¥å…·

### 10.3 å†…éƒ¨æ–‡æ¡£é“¾æ¥

- [â† ä¸Šä¸€ç¯‡ï¼šçº¿ç¨‹åŸºç¡€ä¸ç”Ÿå‘½å‘¨æœŸ](./01_çº¿ç¨‹åŸºç¡€ä¸ç”Ÿå‘½å‘¨æœŸ.md)
- [â†’ ä¸‹ä¸€ç¯‡ï¼šæ¶ˆæ¯ä¼ é€’æ¨¡å¼](./03_æ¶ˆæ¯ä¼ é€’æ¨¡å¼.md)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
