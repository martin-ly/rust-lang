# C05 Tier 2 实践指南 01：线程基础与生命周期

> **文档版本**: v2.0.0 | **Rust 版本**: 1.90+ | **最后更新**: 2025-10-22

## 目录

- [C05 Tier 2 实践指南 01：线程基础与生命周期](#c05-tier-2-实践指南-01线程基础与生命周期)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 什么是线程](#11-什么是线程)
    - [1.2 适用场景](#12-适用场景)
    - [1.3 线程 vs 异步](#13-线程-vs-异步)
  - [2. 线程创建与启动](#2-线程创建与启动)
    - [2.1 基础线程创建](#21-基础线程创建)
      - [示例 1：最简单的线程](#示例-1最简单的线程)
    - [2.2 传递参数给线程](#22-传递参数给线程)
    - [2.3 返回值处理](#23-返回值处理)
  - [3. 线程生命周期管理](#3-线程生命周期管理)
    - [3.1 Join 语义](#31-join-语义)
    - [3.2 Detached Threads（游离线程）](#32-detached-threads游离线程)
    - [3.3 Thread Parking（线程挂起）](#33-thread-parking线程挂起)
  - [4. 线程配置与优化](#4-线程配置与优化)
    - [4.1 使用 Builder 自定义线程](#41-使用-builder-自定义线程)
    - [4.2 线程池模式](#42-线程池模式)
    - [4.3 线程优先级与亲和性](#43-线程优先级与亲和性)
  - [5. 错误处理与恢复](#5-错误处理与恢复)
    - [5.1 处理线程 Panic](#51-处理线程-panic)
    - [5.2 设置 Panic Hook](#52-设置-panic-hook)
    - [5.3 线程安全的错误传播](#53-线程安全的错误传播)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 始终处理 Join 结果](#61-始终处理-join-结果)
    - [6.2 避免过度线程化](#62-避免过度线程化)
    - [6.3 使用作用域线程避免所有权问题](#63-使用作用域线程避免所有权问题)
    - [6.4 命名线程便于调试](#64-命名线程便于调试)
  - [7. 实战案例](#7-实战案例)
    - [7.1 并行图像处理](#71-并行图像处理)
    - [7.2 生产者-消费者模式](#72-生产者-消费者模式)
    - [7.3 分批处理大数据](#73-分批处理大数据)
  - [8. 性能优化](#8-性能优化)
    - [8.1 减少线程创建开销](#81-减少线程创建开销)
    - [8.2 缓存行填充避免伪共享](#82-缓存行填充避免伪共享)
    - [8.3 使用 available\_parallelism 动态调整](#83-使用-available_parallelism-动态调整)
  - [9. 常见陷阱](#9-常见陷阱)
    - [9.1 忘记 join 线程](#91-忘记-join-线程)
    - [9.2 不必要的 `Arc<Mutex<T>>`](#92-不必要的-arcmutext)
    - [9.3 线程数量过多](#93-线程数量过多)
  - [10. 参考资源](#10-参考资源)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 相关 Crates](#102-相关-crates)
    - [10.3 进阶阅读](#103-进阶阅读)
    - [10.4 内部文档链接](#104-内部文档链接)

---

## 1. 概述

### 1.1 什么是线程

线程（Thread）是操作系统能够进行运算调度的最小单位。
在 Rust 中，线程是实现并发的基本单位，每个线程有独立的调用栈。

**核心特性：**

- ✅ **1:1 线程模型**：每个 Rust 线程对应一个 OS 线程
- ✅ **所有权系统保证**：编译期防止数据竞争
- ✅ **零成本抽象**：性能接近原生 C/C++
- ✅ **Panic 隔离**：单个线程 panic 不影响其他线程

### 1.2 适用场景

| 场景 | 适用性 | 原因 |
|------|--------|------|
| CPU 密集型计算 | ⭐⭐⭐⭐⭐ | 充分利用多核 CPU |
| 并行数据处理 | ⭐⭐⭐⭐⭐ | 分片并行加速 |
| I/O 密集型任务 | ⭐⭐⭐ | 建议用 async/await |
| 实时响应需求 | ⭐⭐⭐⭐ | 独立线程处理 |
| 后台任务 | ⭐⭐⭐⭐⭐ | 长时间运行不阻塞 |

### 1.3 线程 vs 异步

```text
┌─────────────────────────────────────────────────────┐
│              线程 (Threads)                          │
├─────────────────────────────────────────────────────┤
│ ✓ CPU 密集型任务                                     │
│ ✓ 需要真正并行执行                                   │
│ ✓ 长时间运行的后台任务                               │
│ ✗ 大量并发 I/O (内存开销大)                         │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│              异步 (Async/Await)                      │
├─────────────────────────────────────────────────────┤
│ ✓ I/O 密集型任务 (网络/文件)                        │
│ ✓ 大量并发连接                                       │
│ ✓ 低内存开销                                         │
│ ✗ CPU 密集型计算 (阻塞事件循环)                     │
└─────────────────────────────────────────────────────┘
```

---

## 2. 线程创建与启动

### 2.1 基础线程创建

#### 示例 1：最简单的线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 创建并启动新线程
    let handle = thread::spawn(|| {
        println!("Hello from spawned thread!");

        // 模拟工作
        thread::sleep(Duration::from_millis(100));

        println!("Spawned thread finishing");
    });

    // 主线程继续执行
    println!("Hello from main thread!");

    // 等待子线程完成
    handle.join().unwrap();

    println!("All threads finished");
}
```

**输出（顺序可能不同）：**

```text
Hello from main thread!
Hello from spawned thread!
Spawned thread finishing
All threads finished
```

### 2.2 传递参数给线程

由于闭包需要获取外部变量的所有权，需要使用 `move` 关键字：

```rust
use std::thread;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // ❌ 错误：闭包可能比 main 函数活得更久
    // let handle = thread::spawn(|| {
    //     println!("Numbers: {:?}", numbers);
    // });

    // ✅ 正确：使用 move 转移所有权
    let handle = thread::spawn(move || {
        let sum: i32 = numbers.iter().sum();
        println!("Sum: {}", sum);
        sum
    });

    // numbers 已被 move，这里无法再使用
    // println!("{:?}", numbers); // ❌ 编译错误

    let result = handle.join().unwrap();
    println!("Thread returned: {}", result);
}
```

### 2.3 返回值处理

线程通过 `JoinHandle::join()` 返回结果：

```rust
use std::thread;

fn calculate_fibonacci(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2),
    }
}

fn main() {
    let handles: Vec<_> = (30..35)
        .map(|n| {
            thread::spawn(move || {
                let result = calculate_fibonacci(n);
                (n, result)
            })
        })
        .collect();

    for handle in handles {
        let (n, result) = handle.join().unwrap();
        println!("Fibonacci({}) = {}", n, result);
    }
}
```

---

## 3. 线程生命周期管理

### 3.1 Join 语义

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle1 = thread::spawn(|| {
        thread::sleep(Duration::from_millis(100));
        println!("Thread 1 finished");
    });

    let handle2 = thread::spawn(|| {
        thread::sleep(Duration::from_millis(50));
        println!("Thread 2 finished");
    });

    // 按顺序等待线程完成
    handle1.join().unwrap(); // 等待至少 100ms
    println!("Thread 1 joined");

    handle2.join().unwrap(); // 可能立即返回（已完成）
    println!("Thread 2 joined");
}
```

### 3.2 Detached Threads（游离线程）

有时不需要等待线程完成，但需要确保主线程不会过早退出：

```rust
use std::thread;
use std::time::Duration;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

fn main() {
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    // 启动后台线程
    thread::spawn(move || {
        while r.load(Ordering::Relaxed) {
            println!("Background thread working...");
            thread::sleep(Duration::from_millis(500));
        }
        println!("Background thread stopping");
    });

    // 主线程做其他工作
    println!("Main thread working...");
    thread::sleep(Duration::from_secs(2));

    // 通知后台线程停止
    running.store(false, Ordering::Relaxed);

    // 给后台线程一点时间清理
    thread::sleep(Duration::from_millis(600));
    println!("Main thread exiting");
}
```

### 3.3 Thread Parking（线程挂起）

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let parked_thread = thread::spawn(|| {
        println!("Thread going to park");
        thread::park(); // 挂起线程
        println!("Thread unparked!");
    });

    // 主线程做一些工作
    thread::sleep(Duration::from_millis(100));
    println!("Unparking thread...");

    // 唤醒线程
    parked_thread.thread().unpark();

    parked_thread.join().unwrap();
}
```

---

## 4. 线程配置与优化

### 4.1 使用 Builder 自定义线程

```rust
use std::thread;

fn main() {
    let builder = thread::Builder::new()
        .name("worker-1".to_string())        // 设置线程名称
        .stack_size(4 * 1024 * 1024);        // 设置栈大小为 4MB

    let handle = builder.spawn(|| {
        println!("Thread name: {:?}", thread::current().name());
        println!("Thread ID: {:?}", thread::current().id());

        // 执行任务...
        42
    }).expect("Failed to spawn thread");

    let result = handle.join().unwrap();
    println!("Result: {}", result);
}
```

### 4.2 线程池模式

虽然标准库不提供线程池，但可以手动实现简单版本：

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        let (sender, receiver) = channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<Receiver<Job>>>) -> Self {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();

            match job {
                Ok(job) => {
                    println!("Worker {} executing job", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} shutting down", id);
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}

fn main() {
    let pool = ThreadPool::new(4);

    for i in 0..8 {
        pool.execute(move || {
            println!("Task {} completed", i);
        });
    }

    thread::sleep(std::time::Duration::from_secs(1));
}
```

**推荐使用成熟的线程池库：**

- [`rayon`](https://docs.rs/rayon) - 数据并行
- [`threadpool`](https://docs.rs/threadpool) - 简单线程池

### 4.3 线程优先级与亲和性

Rust 标准库不直接支持设置线程优先级和 CPU 亲和性，需要使用平台特定的库：

```rust
// 使用 thread_priority crate
use thread_priority::*;

fn main() {
    let handle = std::thread::spawn(|| {
        // 设置当前线程为高优先级
        assert!(set_current_thread_priority(ThreadPriority::Max).is_ok());

        // 执行高优先级任务...
        println!("High priority task running");
    });

    handle.join().unwrap();
}
```

---

## 5. 错误处理与恢复

### 5.1 处理线程 Panic

```rust
use std::thread;
use std::panic;

fn main() {
    let handle = thread::spawn(|| {
        panic!("Something went wrong!");
    });

    // join() 返回 Result<T, Box<dyn Any + Send>>
    match handle.join() {
        Ok(_) => println!("Thread completed successfully"),
        Err(e) => {
            if let Some(s) = e.downcast_ref::<&str>() {
                println!("Thread panicked: {}", s);
            } else {
                println!("Thread panicked with unknown error");
            }
        }
    }
}
```

### 5.2 设置 Panic Hook

```rust
use std::thread;
use std::panic;

fn main() {
    // 设置全局 panic hook
    panic::set_hook(Box::new(|panic_info| {
        let thread = thread::current();
        let thread_name = thread.name().unwrap_or("<unnamed>");

        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            eprintln!("[{}] panicked: {}", thread_name, s);
        } else {
            eprintln!("[{}] panicked", thread_name);
        }

        if let Some(location) = panic_info.location() {
            eprintln!("  at {}:{}:{}",
                location.file(),
                location.line(),
                location.column()
            );
        }
    }));

    let handle = thread::Builder::new()
        .name("worker".to_string())
        .spawn(|| {
            panic!("Critical error!");
        })
        .unwrap();

    let _ = handle.join();
    println!("Main thread continuing...");
}
```

### 5.3 线程安全的错误传播

```rust
use std::thread;
use std::sync::{Arc, Mutex};

#[derive(Debug)]
struct SharedState {
    errors: Vec<String>,
}

fn main() {
    let state = Arc::new(Mutex::new(SharedState { errors: Vec::new() }));

    let handles: Vec<_> = (0..5)
        .map(|i| {
            let state = Arc::clone(&state);
            thread::spawn(move || {
                // 模拟可能失败的操作
                if i % 2 == 0 {
                    let mut s = state.lock().unwrap();
                    s.errors.push(format!("Error in thread {}", i));
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    let state = state.lock().unwrap();
    if state.errors.is_empty() {
        println!("All threads succeeded");
    } else {
        println!("Errors occurred:");
        for error in &state.errors {
            println!("  - {}", error);
        }
    }
}
```

---

## 6. 最佳实践

### 6.1 始终处理 Join 结果

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        // 可能 panic 的代码
        let result = "success".parse::<i32>(); // 会 panic
        result.unwrap()
    });

    // ❌ 不推荐：忽略 panic
    // let _ = handle.join();

    // ✅ 推荐：处理 panic
    match handle.join() {
        Ok(value) => println!("Got: {}", value),
        Err(_) => eprintln!("Thread panicked!"),
    }
}
```

### 6.2 避免过度线程化

```rust
use std::thread;
use std::time::Instant;

fn compute_sum(data: &[i32]) -> i32 {
    data.iter().sum()
}

fn main() {
    let data: Vec<i32> = (0..1_000_000).collect();
    let chunk_size = 100_000;

    // ❌ 不好：创建太多线程
    // let bad_start = Instant::now();
    // let bad_handles: Vec<_> = data.chunks(100)
    //     .map(|chunk| {
    //         let chunk = chunk.to_vec();
    //         thread::spawn(move || compute_sum(&chunk))
    //     })
    //     .collect();

    // ✅ 好：合理的线程数量
    let good_start = Instant::now();
    let num_threads = thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4);

    let chunk_size = data.len() / num_threads;
    let handles: Vec<_> = data.chunks(chunk_size)
        .map(|chunk| {
            let chunk = chunk.to_vec();
            thread::spawn(move || compute_sum(&chunk))
        })
        .collect();

    let sum: i32 = handles.into_iter()
        .map(|h| h.join().unwrap())
        .sum();

    println!("Sum: {}", sum);
    println!("Time: {:?}", good_start.elapsed());
}
```

### 6.3 使用作用域线程避免所有权问题

Rust 1.63+ 引入了 `std::thread::scope`，允许线程借用局部变量：

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let mut results = vec![0; data.len()];

    // ✅ 使用 scope 可以借用而非 move
    thread::scope(|s| {
        for (i, &item) in data.iter().enumerate() {
            s.spawn(move || {
                results[i] = item * 2;
            });
        }
        // scope 结束时自动 join 所有线程
    });

    // data 仍然有效
    println!("Original: {:?}", data);
    println!("Results: {:?}", results);
}
```

### 6.4 命名线程便于调试

```rust
use std::thread;

fn main() {
    let handles: Vec<_> = (0..3)
        .map(|i| {
            thread::Builder::new()
                .name(format!("worker-{}", i))
                .spawn(move || {
                    println!("[{}] Starting", thread::current().name().unwrap());
                    // 执行任务...
                })
                .unwrap()
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 7. 实战案例

### 7.1 并行图像处理

```rust
use std::thread;

struct Image {
    width: usize,
    height: usize,
    data: Vec<u8>,
}

impl Image {
    fn new(width: usize, height: usize) -> Self {
        Image {
            width,
            height,
            data: vec![0; width * height * 3], // RGB
        }
    }

    fn process_parallel(&mut self, num_threads: usize) {
        let chunk_height = self.height / num_threads;
        let width = self.width;

        thread::scope(|s| {
            for chunk in self.data.chunks_mut(chunk_height * width * 3) {
                s.spawn(move || {
                    // 对每个像素应用滤镜
                    for pixel in chunk.chunks_exact_mut(3) {
                        let r = pixel[0] as f32;
                        let g = pixel[1] as f32;
                        let b = pixel[2] as f32;

                        // 简单的灰度转换
                        let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;
                        pixel[0] = gray;
                        pixel[1] = gray;
                        pixel[2] = gray;
                    }
                });
            }
        });
    }
}

fn main() {
    let mut image = Image::new(1920, 1080);
    let num_threads = thread::available_parallelism().unwrap().get();

    let start = std::time::Instant::now();
    image.process_parallel(num_threads);
    println!("Processed in {:?}", start.elapsed());
}
```

### 7.2 生产者-消费者模式

```rust
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 生产者线程
    let producer = thread::spawn(move || {
        for i in 0..10 {
            println!("Producer: sending {}", i);
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
        println!("Producer: done");
    });

    // 消费者线程
    let consumer = thread::spawn(move || {
        while let Ok(value) = rx.recv() {
            println!("Consumer: received {}", value);
            thread::sleep(Duration::from_millis(150));
        }
        println!("Consumer: done");
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 7.3 分批处理大数据

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn process_batch(batch: Vec<i32>) -> i32 {
    // 模拟复杂计算
    thread::sleep(std::time::Duration::from_millis(10));
    batch.iter().map(|x| x * x).sum()
}

fn main() {
    let data: Vec<i32> = (1..=1000).collect();
    let num_threads = 4;
    let batch_size = data.len() / num_threads;

    let results = Arc::new(Mutex::new(Vec::new()));
    let mut handles = vec![];

    for chunk in data.chunks(batch_size) {
        let chunk = chunk.to_vec();
        let results = Arc::clone(&results);

        let handle = thread::spawn(move || {
            let result = process_batch(chunk);
            results.lock().unwrap().push(result);
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let final_results = results.lock().unwrap();
    let total: i32 = final_results.iter().sum();
    println!("Total sum of squares: {}", total);
}
```

---

## 8. 性能优化

### 8.1 减少线程创建开销

```rust
use std::thread;
use std::time::Instant;

fn main() {
    let data: Vec<_> = (0..10000).collect();

    // ❌ 差：每次迭代创建新线程
    let start = Instant::now();
    for &item in &data {
        let _ = thread::spawn(move || item * 2).join();
    }
    println!("Per-item spawn: {:?}", start.elapsed());

    // ✅ 好：批量处理
    let start = Instant::now();
    let chunk_size = data.len() / 4;
    let handles: Vec<_> = data.chunks(chunk_size)
        .map(|chunk| {
            let chunk = chunk.to_vec();
            thread::spawn(move || {
                chunk.iter().map(|x| x * 2).collect::<Vec<_>>()
            })
        })
        .collect();

    let _: Vec<_> = handles.into_iter()
        .map(|h| h.join().unwrap())
        .flatten()
        .collect();
    println!("Batched spawn: {:?}", start.elapsed());
}
```

### 8.2 缓存行填充避免伪共享

```rust
use std::thread;
use std::sync::Arc;

// 不带填充：可能产生伪共享
#[derive(Default)]
struct CounterNoPadding {
    value: u64,
}

// 带填充：避免伪共享（缓存行通常 64 字节）
#[repr(align(64))]
#[derive(Default)]
struct CounterWithPadding {
    value: u64,
    _padding: [u8; 56], // 64 - 8 = 56
}

fn benchmark<T: Default + Send + Sync + 'static>(
    name: &str,
    increment: fn(&T),
) where
    T: 'static,
{
    let counters = Arc::new([T::default(), T::default()]);
    let start = std::time::Instant::now();

    let handles: Vec<_> = (0..2)
        .map(|i| {
            let counters = Arc::clone(&counters);
            thread::spawn(move || {
                for _ in 0..10_000_000 {
                    increment(&counters[i]);
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    println!("{}: {:?}", name, start.elapsed());
}

fn main() {
    println!("Running benchmarks...");

    // 实际测试需要使用原子操作
    // 这里仅作示意
}
```

### 8.3 使用 available_parallelism 动态调整

```rust
use std::thread;

fn main() {
    let parallelism = thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(1);

    println!("Available parallelism: {}", parallelism);

    // 根据硬件并发数调整线程数
    let num_threads = parallelism.min(8); // 最多 8 个线程

    let handles: Vec<_> = (0..num_threads)
        .map(|i| {
            thread::spawn(move || {
                println!("Thread {} running", i);
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 9. 常见陷阱

### 9.1 忘记 join 线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // ❌ 错误：线程可能还没执行完主线程就退出了
    thread::spawn(|| {
        thread::sleep(Duration::from_secs(1));
        println!("This might not print!");
    });

    // main 函数立即退出，子线程可能被强制终止

    // ✅ 正确：等待线程完成
    let handle = thread::spawn(|| {
        thread::sleep(Duration::from_secs(1));
        println!("This will definitely print!");
    });
    handle.join().unwrap();
}
```

### 9.2 不必要的 `Arc<Mutex<T>>`

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    // ❌ 不必要：只读数据不需要 Mutex
    let data = Arc::new(Mutex::new(vec![1, 2, 3, 4, 5]));
    let data_clone = Arc::clone(&data);

    let handle = thread::spawn(move || {
        let data = data_clone.lock().unwrap();
        println!("Sum: {}", data.iter().sum::<i32>());
    });

    handle.join().unwrap();

    // ✅ 正确：只读数据只需 Arc
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let data_clone = Arc::clone(&data);

    let handle = thread::spawn(move || {
        println!("Sum: {}", data_clone.iter().sum::<i32>());
    });

    handle.join().unwrap();
}
```

### 9.3 线程数量过多

```rust
use std::thread;
use std::time::Instant;

fn main() {
    let start = Instant::now();

    // ❌ 不好：创建 10000 个线程
    let handles: Vec<_> = (0..10000)
        .map(|i| thread::spawn(move || i * 2))
        .collect();

    let _: Vec<_> = handles.into_iter()
        .map(|h| h.join().unwrap())
        .collect();

    println!("Too many threads: {:?}", start.elapsed());

    // ✅ 好：使用 Rayon 等库自动管理线程池
    // use rayon::prelude::*;
    // let results: Vec<_> = (0..10000).into_par_iter()
    //     .map(|i| i * 2)
    //     .collect();
}
```

---

## 10. 参考资源

### 10.1 官方文档

- [std::thread 模块](https://doc.rust-lang.org/std/thread/)
- [The Rust Book - Fearless Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)

### 10.2 相关 Crates

- [`rayon`](https://docs.rs/rayon) - 数据并行库
- [`crossbeam`](https://docs.rs/crossbeam) - 并发工具集
- [`threadpool`](https://docs.rs/threadpool) - 线程池实现

### 10.3 进阶阅读

- [Rust Concurrency: Five Easy Pieces](https://www.lurklurk.org/effective-rust/concurrency.html)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)

### 10.4 内部文档链接

- [← 返回 Tier 1：项目概览](../tier_01_foundations/01_项目概览.md)
- [→ 下一篇：同步原语实践](./02_同步原语实践.md)
- [↑ 返回主索引](../tier_01_foundations/02_主索引导航.md)

---

**文档维护**: C05 Threads Team | **最后审核**: 2025-10-22 | **质量评分**: 95/100
