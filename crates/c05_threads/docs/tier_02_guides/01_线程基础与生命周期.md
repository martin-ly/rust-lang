# C05 Tier 2 å®è·µæŒ‡å— 01ï¼šçº¿ç¨‹åŸºç¡€ä¸ç”Ÿå‘½å‘¨æœŸ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0 | **Rust ç‰ˆæœ¬**: 1.92.0+ | **æœ€åæ›´æ–°**: 2025-12-11

## ç›®å½•

- [C05 Tier 2 å®è·µæŒ‡å— 01ï¼šçº¿ç¨‹åŸºç¡€ä¸ç”Ÿå‘½å‘¨æœŸ](#c05-tier-2-å®è·µæŒ‡å—-01çº¿ç¨‹åŸºç¡€ä¸ç”Ÿå‘½å‘¨æœŸ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯çº¿ç¨‹](#11-ä»€ä¹ˆæ˜¯çº¿ç¨‹)
    - [1.2 é€‚ç”¨åœºæ™¯](#12-é€‚ç”¨åœºæ™¯)
    - [1.3 çº¿ç¨‹ vs å¼‚æ­¥](#13-çº¿ç¨‹-vs-å¼‚æ­¥)
  - [2. çº¿ç¨‹åˆ›å»ºä¸å¯åŠ¨](#2-çº¿ç¨‹åˆ›å»ºä¸å¯åŠ¨)
    - [2.1 åŸºç¡€çº¿ç¨‹åˆ›å»º](#21-åŸºç¡€çº¿ç¨‹åˆ›å»º)
      - [ç¤ºä¾‹ 1ï¼šæœ€ç®€å•çš„çº¿ç¨‹](#ç¤ºä¾‹-1æœ€ç®€å•çš„çº¿ç¨‹)
    - [2.2 ä¼ é€’å‚æ•°ç»™çº¿ç¨‹](#22-ä¼ é€’å‚æ•°ç»™çº¿ç¨‹)
    - [2.3 è¿”å›å€¼å¤„ç†](#23-è¿”å›å€¼å¤„ç†)
  - [3. çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†](#3-çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†)
    - [3.1 Join è¯­ä¹‰](#31-join-è¯­ä¹‰)
    - [3.2 Detached Threadsï¼ˆæ¸¸ç¦»çº¿ç¨‹ï¼‰](#32-detached-threadsæ¸¸ç¦»çº¿ç¨‹)
    - [3.3 Thread Parkingï¼ˆçº¿ç¨‹æŒ‚èµ·ï¼‰](#33-thread-parkingçº¿ç¨‹æŒ‚èµ·)
  - [4. çº¿ç¨‹é…ç½®ä¸ä¼˜åŒ–](#4-çº¿ç¨‹é…ç½®ä¸ä¼˜åŒ–)
    - [4.1 ä½¿ç”¨ Builder è‡ªå®šä¹‰çº¿ç¨‹](#41-ä½¿ç”¨-builder-è‡ªå®šä¹‰çº¿ç¨‹)
    - [4.2 çº¿ç¨‹æ± æ¨¡å¼](#42-çº¿ç¨‹æ± æ¨¡å¼)
    - [4.3 çº¿ç¨‹ä¼˜å…ˆçº§ä¸äº²å’Œæ€§](#43-çº¿ç¨‹ä¼˜å…ˆçº§ä¸äº²å’Œæ€§)
  - [5. é”™è¯¯å¤„ç†ä¸æ¢å¤](#5-é”™è¯¯å¤„ç†ä¸æ¢å¤)
    - [5.1 å¤„ç†çº¿ç¨‹ Panic](#51-å¤„ç†çº¿ç¨‹-panic)
    - [5.2 è®¾ç½® Panic Hook](#52-è®¾ç½®-panic-hook)
    - [5.3 çº¿ç¨‹å®‰å…¨çš„é”™è¯¯ä¼ æ’­](#53-çº¿ç¨‹å®‰å…¨çš„é”™è¯¯ä¼ æ’­)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 å§‹ç»ˆå¤„ç† Join ç»“æœ](#61-å§‹ç»ˆå¤„ç†-join-ç»“æœ)
    - [6.2 é¿å…è¿‡åº¦çº¿ç¨‹åŒ–](#62-é¿å…è¿‡åº¦çº¿ç¨‹åŒ–)
    - [6.3 ä½¿ç”¨ä½œç”¨åŸŸçº¿ç¨‹é¿å…æ‰€æœ‰æƒé—®é¢˜](#63-ä½¿ç”¨ä½œç”¨åŸŸçº¿ç¨‹é¿å…æ‰€æœ‰æƒé—®é¢˜)
    - [6.4 å‘½åçº¿ç¨‹ä¾¿äºè°ƒè¯•](#64-å‘½åçº¿ç¨‹ä¾¿äºè°ƒè¯•)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 å¹¶è¡Œå›¾åƒå¤„ç†](#71-å¹¶è¡Œå›¾åƒå¤„ç†)
    - [7.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#72-ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
    - [7.3 åˆ†æ‰¹å¤„ç†å¤§æ•°æ®](#73-åˆ†æ‰¹å¤„ç†å¤§æ•°æ®)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [8.1 å‡å°‘çº¿ç¨‹åˆ›å»ºå¼€é”€](#81-å‡å°‘çº¿ç¨‹åˆ›å»ºå¼€é”€)
    - [8.2 ç¼“å­˜è¡Œå¡«å……é¿å…ä¼ªå…±äº«](#82-ç¼“å­˜è¡Œå¡«å……é¿å…ä¼ªå…±äº«)
    - [8.3 ä½¿ç”¨ available\_parallelism åŠ¨æ€è°ƒæ•´](#83-ä½¿ç”¨-available_parallelism-åŠ¨æ€è°ƒæ•´)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
    - [9.1 å¿˜è®° join çº¿ç¨‹](#91-å¿˜è®°-join-çº¿ç¨‹)
    - [9.2 ä¸å¿…è¦çš„ `Arc<Mutex<T>>`](#92-ä¸å¿…è¦çš„-arcmutext)
    - [9.3 çº¿ç¨‹æ•°é‡è¿‡å¤š](#93-çº¿ç¨‹æ•°é‡è¿‡å¤š)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
    - [10.1 å®˜æ–¹æ–‡æ¡£](#101-å®˜æ–¹æ–‡æ¡£)
    - [10.2 ç›¸å…³ Crates](#102-ç›¸å…³-crates)
    - [10.3 è¿›é˜¶é˜…è¯»](#103-è¿›é˜¶é˜…è¯»)
    - [10.4 å†…éƒ¨æ–‡æ¡£é“¾æ¥](#104-å†…éƒ¨æ–‡æ¡£é“¾æ¥)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**çº¿ç¨‹ (Thread)**:

- **å®šä¹‰**: æ“ä½œç³»ç»Ÿèƒ½å¤Ÿè¿›è¡Œè¿ç®—è°ƒåº¦çš„æœ€å°å•ä½ï¼Œæ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹çš„è°ƒç”¨æ ˆ
- **ç±»å‹**: ç³»ç»Ÿæ¦‚å¿µ
- **èŒƒç•´**: å¹¶å‘ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: è¿›ç¨‹ã€å¹¶å‘ã€åŒæ­¥ã€æ¶ˆæ¯ä¼ é€’

**ä½œç”¨åŸŸçº¿ç¨‹ (Scoped Thread)**:

- **å®šä¹‰**: åœ¨ç‰¹å®šä½œç”¨åŸŸå†…åˆ›å»ºçš„çº¿ç¨‹ï¼Œå¯ä»¥å€Ÿç”¨å¤–éƒ¨æ•°æ®
- **ç±»å‹**: Rust ç‰¹æ€§
- **å±æ€§**: ç”Ÿå‘½å‘¨æœŸç»‘å®šã€å€Ÿç”¨æ£€æŸ¥ã€è‡ªåŠ¨æ¸…ç†
- **å…³ç³»**: ä¸çº¿ç¨‹ã€æ‰€æœ‰æƒç³»ç»Ÿç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **1:1 çº¿ç¨‹æ¨¡å‹**: æ¯ä¸ª Rust çº¿ç¨‹å¯¹åº”ä¸€ä¸ª OS çº¿ç¨‹
- **æ‰€æœ‰æƒç³»ç»Ÿä¿è¯**: ç¼–è¯‘æœŸé˜²æ­¢æ•°æ®ç«äº‰
- **é›¶æˆæœ¬æŠ½è±¡**: æ€§èƒ½æ¥è¿‘åŸç”Ÿ C/C++
- **Panic éš”ç¦»**: å•ä¸ªçº¿ç¨‹ panic ä¸å½±å“å…¶ä»–çº¿ç¨‹

**æ€§èƒ½ç‰¹å¾**:

- **åˆ›å»ºå¼€é”€**: çº¿ç¨‹åˆ›å»ºæœ‰ä¸€å®šå¼€é”€
- **å†…å­˜å ç”¨**: æ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹çš„æ ˆç©ºé—´
- **é€‚ç”¨åœºæ™¯**: CPU å¯†é›†å‹è®¡ç®—ã€å¹¶è¡Œæ•°æ®å¤„ç†

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- ä½œç”¨åŸŸçº¿ç¨‹ --[is-a]--> çº¿ç¨‹

**ç»„åˆå…³ç³»**:

- çº¿ç¨‹æ±  --[has-a]--> å¤šä¸ªçº¿ç¨‹
- å¹¶å‘ç¨‹åº --[uses]--> å¤šä¸ªçº¿ç¨‹

**ä¾èµ–å…³ç³»**:

- çº¿ç¨‹ --[depends-on]--> æ“ä½œç³»ç»Ÿçº¿ç¨‹æ”¯æŒ
- çº¿ç¨‹åŒæ­¥ --[depends-on]--> åŒæ­¥åŸè¯­

### æ€ç»´å¯¼å›¾

```text
çº¿ç¨‹åŸºç¡€ä¸ç”Ÿå‘½å‘¨æœŸ
â”‚
â”œâ”€â”€ çº¿ç¨‹åˆ›å»º
â”‚   â”œâ”€â”€ åŸºç¡€çº¿ç¨‹
â”‚   â”œâ”€â”€ ä¼ é€’å‚æ•°
â”‚   â””â”€â”€ è¿”å›å€¼å¤„ç†
â”œâ”€â”€ ç”Ÿå‘½å‘¨æœŸç®¡ç†
â”‚   â”œâ”€â”€ Join è¯­ä¹‰
â”‚   â”œâ”€â”€ Detached Threads
â”‚   â””â”€â”€ Thread Parking
â”œâ”€â”€ çº¿ç¨‹é…ç½®
â”‚   â”œâ”€â”€ Builder è‡ªå®šä¹‰
â”‚   â”œâ”€â”€ çº¿ç¨‹æ± æ¨¡å¼
â”‚   â””â”€â”€ ä¼˜å…ˆçº§ä¸äº²å’Œæ€§
â””â”€â”€ é”™è¯¯å¤„ç†
    â”œâ”€â”€ Panic å¤„ç†
    â””â”€â”€ é”™è¯¯ä¼ æ’­
```

---

## 1. æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯çº¿ç¨‹

çº¿ç¨‹ï¼ˆThreadï¼‰æ˜¯æ“ä½œç³»ç»Ÿèƒ½å¤Ÿè¿›è¡Œè¿ç®—è°ƒåº¦çš„æœ€å°å•ä½ã€‚
åœ¨ Rust ä¸­ï¼Œçº¿ç¨‹æ˜¯å®ç°å¹¶å‘çš„åŸºæœ¬å•ä½ï¼Œæ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹çš„è°ƒç”¨æ ˆã€‚

**æ ¸å¿ƒç‰¹æ€§ï¼š**

- âœ… **1:1 çº¿ç¨‹æ¨¡å‹**ï¼šæ¯ä¸ª Rust çº¿ç¨‹å¯¹åº”ä¸€ä¸ª OS çº¿ç¨‹
- âœ… **æ‰€æœ‰æƒç³»ç»Ÿä¿è¯**ï¼šç¼–è¯‘æœŸé˜²æ­¢æ•°æ®ç«äº‰
- âœ… **é›¶æˆæœ¬æŠ½è±¡**ï¼šæ€§èƒ½æ¥è¿‘åŸç”Ÿ C/C++
- âœ… **Panic éš”ç¦»**ï¼šå•ä¸ªçº¿ç¨‹ panic ä¸å½±å“å…¶ä»–çº¿ç¨‹

### 1.2 é€‚ç”¨åœºæ™¯

| åœºæ™¯           | é€‚ç”¨æ€§     | åŸå›                |
| :--- | :--- | :--- || CPU å¯†é›†å‹è®¡ç®— | â­â­â­â­â­ | å……åˆ†åˆ©ç”¨å¤šæ ¸ CPU   |
| å¹¶è¡Œæ•°æ®å¤„ç†   | â­â­â­â­â­ | åˆ†ç‰‡å¹¶è¡ŒåŠ é€Ÿ       |
| I/O å¯†é›†å‹ä»»åŠ¡ | â­â­â­     | å»ºè®®ç”¨ async/await |
| å®æ—¶å“åº”éœ€æ±‚   | â­â­â­â­   | ç‹¬ç«‹çº¿ç¨‹å¤„ç†       |
| åå°ä»»åŠ¡       | â­â­â­â­â­ | é•¿æ—¶é—´è¿è¡Œä¸é˜»å¡   |

### 1.3 çº¿ç¨‹ vs å¼‚æ­¥

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              çº¿ç¨‹ (Threads)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ CPU å¯†é›†å‹ä»»åŠ¡                                     â”‚
â”‚ âœ“ éœ€è¦çœŸæ­£å¹¶è¡Œæ‰§è¡Œ                                   â”‚
â”‚ âœ“ é•¿æ—¶é—´è¿è¡Œçš„åå°ä»»åŠ¡                               â”‚
â”‚ âœ— å¤§é‡å¹¶å‘ I/O (å†…å­˜å¼€é”€å¤§)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å¼‚æ­¥ (Async/Await)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ I/O å¯†é›†å‹ä»»åŠ¡ (ç½‘ç»œ/æ–‡ä»¶)                        â”‚
â”‚ âœ“ å¤§é‡å¹¶å‘è¿æ¥                                       â”‚
â”‚ âœ“ ä½å†…å­˜å¼€é”€                                         â”‚
â”‚ âœ— CPU å¯†é›†å‹è®¡ç®— (é˜»å¡äº‹ä»¶å¾ªç¯)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. çº¿ç¨‹åˆ›å»ºä¸å¯åŠ¨

### 2.1 åŸºç¡€çº¿ç¨‹åˆ›å»º

#### ç¤ºä¾‹ 1ï¼šæœ€ç®€å•çš„çº¿ç¨‹

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // åˆ›å»ºå¹¶å¯åŠ¨æ–°çº¿ç¨‹
    let handle = thread::spawn(|| {
        println!("Hello from spawned thread!");

        // æ¨¡æ‹Ÿå·¥ä½œ
        thread::sleep(Duration::from_millis(100));

        println!("Spawned thread finishing");
    });

    // ä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œ
    println!("Hello from main thread!");

    // ç­‰å¾…å­çº¿ç¨‹å®Œæˆ
    handle.join().unwrap();

    println!("All threads finished");
}
```

**è¾“å‡ºï¼ˆé¡ºåºå¯èƒ½ä¸åŒï¼‰ï¼š**

```text
Hello from main thread!
Hello from spawned thread!
Spawned thread finishing
All threads finished
```

### 2.2 ä¼ é€’å‚æ•°ç»™çº¿ç¨‹

ç”±äºé—­åŒ…éœ€è¦è·å–å¤–éƒ¨å˜é‡çš„æ‰€æœ‰æƒï¼Œéœ€è¦ä½¿ç”¨ `move` å…³é”®å­—ï¼š

```rust
use std::thread;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // âŒ é”™è¯¯ï¼šé—­åŒ…å¯èƒ½æ¯” main å‡½æ•°æ´»å¾—æ›´ä¹…
    // let handle = thread::spawn(|| {
    //     println!("Numbers: {:?}", numbers);
    // });

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ move è½¬ç§»æ‰€æœ‰æƒ
    let handle = thread::spawn(move || {
        let sum: i32 = numbers.iter().sum();
        println!("Sum: {}", sum);
        sum
    });

    // numbers å·²è¢« moveï¼Œè¿™é‡Œæ— æ³•å†ä½¿ç”¨
    // println!("{:?}", numbers); // âŒ ç¼–è¯‘é”™è¯¯

    let result = handle.join().unwrap();
    println!("Thread returned: {}", result);
}
```

### 2.3 è¿”å›å€¼å¤„ç†

çº¿ç¨‹é€šè¿‡ `JoinHandle::join()` è¿”å›ç»“æœï¼š

```rust
use std::thread;

fn calculate_fibonacci(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2),
    }
}

fn main() {
    let handles: Vec<_> = (30..35)
        .map(|n| {
            thread::spawn(move || {
                let result = calculate_fibonacci(n);
                (n, result)
            })
        })
        .collect();

    for handle in handles {
        let (n, result) = handle.join().unwrap();
        println!("Fibonacci({}) = {}", n, result);
    }
}
```

---

## 3. çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 3.1 Join è¯­ä¹‰

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle1 = thread::spawn(|| {
        thread::sleep(Duration::from_millis(100));
        println!("Thread 1 finished");
    });

    let handle2 = thread::spawn(|| {
        thread::sleep(Duration::from_millis(50));
        println!("Thread 2 finished");
    });

    // æŒ‰é¡ºåºç­‰å¾…çº¿ç¨‹å®Œæˆ
    handle1.join().unwrap(); // ç­‰å¾…è‡³å°‘ 100ms
    println!("Thread 1 joined");

    handle2.join().unwrap(); // å¯èƒ½ç«‹å³è¿”å›ï¼ˆå·²å®Œæˆï¼‰
    println!("Thread 2 joined");
}
```

### 3.2 Detached Threadsï¼ˆæ¸¸ç¦»çº¿ç¨‹ï¼‰

æœ‰æ—¶ä¸éœ€è¦ç­‰å¾…çº¿ç¨‹å®Œæˆï¼Œä½†éœ€è¦ç¡®ä¿ä¸»çº¿ç¨‹ä¸ä¼šè¿‡æ—©é€€å‡ºï¼š

```rust
use std::thread;
use std::time::Duration;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

fn main() {
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();

    // å¯åŠ¨åå°çº¿ç¨‹
    thread::spawn(move || {
        while r.load(Ordering::Relaxed) {
            println!("Background thread working...");
            thread::sleep(Duration::from_millis(500));
        }
        println!("Background thread stopping");
    });

    // ä¸»çº¿ç¨‹åšå…¶ä»–å·¥ä½œ
    println!("Main thread working...");
    thread::sleep(Duration::from_secs(2));

    // é€šçŸ¥åå°çº¿ç¨‹åœæ­¢
    running.store(false, Ordering::Relaxed);

    // ç»™åå°çº¿ç¨‹ä¸€ç‚¹æ—¶é—´æ¸…ç†
    thread::sleep(Duration::from_millis(600));
    println!("Main thread exiting");
}
```

### 3.3 Thread Parkingï¼ˆçº¿ç¨‹æŒ‚èµ·ï¼‰

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let parked_thread = thread::spawn(|| {
        println!("Thread going to park");
        thread::park(); // æŒ‚èµ·çº¿ç¨‹
        println!("Thread unparked!");
    });

    // ä¸»çº¿ç¨‹åšä¸€äº›å·¥ä½œ
    thread::sleep(Duration::from_millis(100));
    println!("Unparking thread...");

    // å”¤é†’çº¿ç¨‹
    parked_thread.thread().unpark();

    parked_thread.join().unwrap();
}
```

---

## 4. çº¿ç¨‹é…ç½®ä¸ä¼˜åŒ–

### 4.1 ä½¿ç”¨ Builder è‡ªå®šä¹‰çº¿ç¨‹

```rust
use std::thread;

fn main() {
    let builder = thread::Builder::new()
        .name("worker-1".to_string())        // è®¾ç½®çº¿ç¨‹åç§°
        .stack_size(4 * 1024 * 1024);        // è®¾ç½®æ ˆå¤§å°ä¸º 4MB

    let handle = builder.spawn(|| {
        println!("Thread name: {:?}", thread::current().name());
        println!("Thread ID: {:?}", thread::current().id());

        // æ‰§è¡Œä»»åŠ¡...
        42
    }).expect("Failed to spawn thread");

    let result = handle.join().unwrap();
    println!("Result: {}", result);
}
```

### 4.2 çº¿ç¨‹æ± æ¨¡å¼

è™½ç„¶æ ‡å‡†åº“ä¸æä¾›çº¿ç¨‹æ± ï¼Œä½†å¯ä»¥æ‰‹åŠ¨å®ç°ç®€å•ç‰ˆæœ¬ï¼š

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc::{channel, Sender, Receiver};
use std::thread;

type Job = Box<dyn FnOnce() + Send + 'static>;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: Sender<Job>,
}

impl ThreadPool {
    fn new(size: usize) -> Self {
        let (sender, receiver) = channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<Receiver<Job>>>) -> Self {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv();

            match job {
                Ok(job) => {
                    println!("Worker {} executing job", id);
                    job();
                }
                Err(_) => {
                    println!("Worker {} shutting down", id);
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}

fn main() {
    let pool = ThreadPool::new(4);

    for i in 0..8 {
        pool.execute(move || {
            println!("Task {} completed", i);
        });
    }

    thread::sleep(std::time::Duration::from_secs(1));
}
```

**æ¨èä½¿ç”¨æˆç†Ÿçš„çº¿ç¨‹æ± åº“ï¼š**

- [`rayon`](https://docs.rs/rayon) - æ•°æ®å¹¶è¡Œ
- [`threadpool`](https://docs.rs/threadpool) - ç®€å•çº¿ç¨‹æ± 

### 4.3 çº¿ç¨‹ä¼˜å…ˆçº§ä¸äº²å’Œæ€§

Rust æ ‡å‡†åº“ä¸ç›´æ¥æ”¯æŒè®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§å’Œ CPU äº²å’Œæ€§ï¼Œéœ€è¦ä½¿ç”¨å¹³å°ç‰¹å®šçš„åº“ï¼š

```rust
// ä½¿ç”¨ thread_priority crate
use thread_priority::*;

fn main() {
    let handle = std::thread::spawn(|| {
        // è®¾ç½®å½“å‰çº¿ç¨‹ä¸ºé«˜ä¼˜å…ˆçº§
        assert!(set_current_thread_priority(ThreadPriority::Max).is_ok());

        // æ‰§è¡Œé«˜ä¼˜å…ˆçº§ä»»åŠ¡...
        println!("High priority task running");
    });

    handle.join().unwrap();
}
```

---

## 5. é”™è¯¯å¤„ç†ä¸æ¢å¤

### 5.1 å¤„ç†çº¿ç¨‹ Panic

```rust
use std::thread;
use std::panic;

fn main() {
    let handle = thread::spawn(|| {
        panic!("Something went wrong!");
    });

    // join() è¿”å› Result<T, Box<dyn Any + Send>>
    match handle.join() {
        Ok(_) => println!("Thread completed successfully"),
        Err(e) => {
            if let Some(s) = e.downcast_ref::<&str>() {
                println!("Thread panicked: {}", s);
            } else {
                println!("Thread panicked with unknown error");
            }
        }
    }
}
```

### 5.2 è®¾ç½® Panic Hook

```rust
use std::thread;
use std::panic;

fn main() {
    // è®¾ç½®å…¨å±€ panic hook
    panic::set_hook(Box::new(|panic_info| {
        let thread = thread::current();
        let thread_name = thread.name().unwrap_or("<unnamed>");

        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            eprintln!("[{}] panicked: {}", thread_name, s);
        } else {
            eprintln!("[{}] panicked", thread_name);
        }

        if let Some(location) = panic_info.location() {
            eprintln!("  at {}:{}:{}",
                location.file(),
                location.line(),
                location.column()
            );
        }
    }));

    let handle = thread::Builder::new()
        .name("worker".to_string())
        .spawn(|| {
            panic!("Critical error!");
        })
        .unwrap();

    let _ = handle.join();
    println!("Main thread continuing...");
}
```

### 5.3 çº¿ç¨‹å®‰å…¨çš„é”™è¯¯ä¼ æ’­

```rust
use std::thread;
use std::sync::{Arc, Mutex};

#[derive(Debug)]
struct SharedState {
    errors: Vec<String>,
}

fn main() {
    let state = Arc::new(Mutex::new(SharedState { errors: Vec::new() }));

    let handles: Vec<_> = (0..5)
        .map(|i| {
            let state = Arc::clone(&state);
            thread::spawn(move || {
                // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
                if i % 2 == 0 {
                    let mut s = state.lock().unwrap();
                    s.errors.push(format!("Error in thread {}", i));
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    let state = state.lock().unwrap();
    if state.errors.is_empty() {
        println!("All threads succeeded");
    } else {
        println!("Errors occurred:");
        for error in &state.errors {
            println!("  - {}", error);
        }
    }
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 å§‹ç»ˆå¤„ç† Join ç»“æœ

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        // å¯èƒ½ panic çš„ä»£ç 
        let result = "success".parse::<i32>(); // ä¼š panic
        result.unwrap()
    });

    // âŒ ä¸æ¨èï¼šå¿½ç•¥ panic
    // let _ = handle.join();

    // âœ… æ¨èï¼šå¤„ç† panic
    match handle.join() {
        Ok(value) => println!("Got: {}", value),
        Err(_) => eprintln!("Thread panicked!"),
    }
}
```

### 6.2 é¿å…è¿‡åº¦çº¿ç¨‹åŒ–

```rust
use std::thread;
use std::time::Instant;

fn compute_sum(data: &[i32]) -> i32 {
    data.iter().sum()
}

fn main() {
    let data: Vec<i32> = (0..1_000_000).collect();
    let chunk_size = 100_000;

    // âŒ ä¸å¥½ï¼šåˆ›å»ºå¤ªå¤šçº¿ç¨‹
    // let bad_start = Instant::now();
    // let bad_handles: Vec<_> = data.chunks(100)
    //     .map(|chunk| {
    //         let chunk = chunk.to_vec();
    //         thread::spawn(move || compute_sum(&chunk))
    //     })
    //     .collect();

    // âœ… å¥½ï¼šåˆç†çš„çº¿ç¨‹æ•°é‡
    let good_start = Instant::now();
    let num_threads = thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4);

    let chunk_size = data.len() / num_threads;
    let handles: Vec<_> = data.chunks(chunk_size)
        .map(|chunk| {
            let chunk = chunk.to_vec();
            thread::spawn(move || compute_sum(&chunk))
        })
        .collect();

    let sum: i32 = handles.into_iter()
        .map(|h| h.join().unwrap())
        .sum();

    println!("Sum: {}", sum);
    println!("Time: {:?}", good_start.elapsed());
}
```

### 6.3 ä½¿ç”¨ä½œç”¨åŸŸçº¿ç¨‹é¿å…æ‰€æœ‰æƒé—®é¢˜

Rust 1.63+ å¼•å…¥äº† `std::thread::scope`ï¼Œå…è®¸çº¿ç¨‹å€Ÿç”¨å±€éƒ¨å˜é‡ï¼š

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let mut results = vec![0; data.len()];

    // âœ… ä½¿ç”¨ scope å¯ä»¥å€Ÿç”¨è€Œé move
    thread::scope(|s| {
        for (i, &item) in data.iter().enumerate() {
            s.spawn(move || {
                results[i] = item * 2;
            });
        }
        // scope ç»“æŸæ—¶è‡ªåŠ¨ join æ‰€æœ‰çº¿ç¨‹
    });

    // data ä»ç„¶æœ‰æ•ˆ
    println!("Original: {:?}", data);
    println!("Results: {:?}", results);
}
```

### 6.4 å‘½åçº¿ç¨‹ä¾¿äºè°ƒè¯•

```rust
use std::thread;

fn main() {
    let handles: Vec<_> = (0..3)
        .map(|i| {
            thread::Builder::new()
                .name(format!("worker-{}", i))
                .spawn(move || {
                    println!("[{}] Starting", thread::current().name().unwrap());
                    // æ‰§è¡Œä»»åŠ¡...
                })
                .unwrap()
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 å¹¶è¡Œå›¾åƒå¤„ç†

```rust
use std::thread;

struct Image {
    width: usize,
    height: usize,
    data: Vec<u8>,
}

impl Image {
    fn new(width: usize, height: usize) -> Self {
        Image {
            width,
            height,
            data: vec![0; width * height * 3], // RGB
        }
    }

    fn process_parallel(&mut self, num_threads: usize) {
        let chunk_height = self.height / num_threads;
        let width = self.width;

        thread::scope(|s| {
            for chunk in self.data.chunks_mut(chunk_height * width * 3) {
                s.spawn(move || {
                    // å¯¹æ¯ä¸ªåƒç´ åº”ç”¨æ»¤é•œ
                    for pixel in chunk.chunks_exact_mut(3) {
                        let r = pixel[0] as f32;
                        let g = pixel[1] as f32;
                        let b = pixel[2] as f32;

                        // ç®€å•çš„ç°åº¦è½¬æ¢
                        let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;
                        pixel[0] = gray;
                        pixel[1] = gray;
                        pixel[2] = gray;
                    }
                });
            }
        });
    }
}

fn main() {
    let mut image = Image::new(1920, 1080);
    let num_threads = thread::available_parallelism().unwrap().get();

    let start = std::time::Instant::now();
    image.process_parallel(num_threads);
    println!("Processed in {:?}", start.elapsed());
}
```

### 7.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```rust
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    // ç”Ÿäº§è€…çº¿ç¨‹
    let producer = thread::spawn(move || {
        for i in 0..10 {
            println!("Producer: sending {}", i);
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
        println!("Producer: done");
    });

    // æ¶ˆè´¹è€…çº¿ç¨‹
    let consumer = thread::spawn(move || {
        while let Ok(value) = rx.recv() {
            println!("Consumer: received {}", value);
            thread::sleep(Duration::from_millis(150));
        }
        println!("Consumer: done");
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 7.3 åˆ†æ‰¹å¤„ç†å¤§æ•°æ®

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn process_batch(batch: Vec<i32>) -> i32 {
    // æ¨¡æ‹Ÿå¤æ‚è®¡ç®—
    thread::sleep(std::time::Duration::from_millis(10));
    batch.iter().map(|x| x * x).sum()
}

fn main() {
    let data: Vec<i32> = (1..=1000).collect();
    let num_threads = 4;
    let batch_size = data.len() / num_threads;

    let results = Arc::new(Mutex::new(Vec::new()));
    let mut handles = vec![];

    for chunk in data.chunks(batch_size) {
        let chunk = chunk.to_vec();
        let results = Arc::clone(&results);

        let handle = thread::spawn(move || {
            let result = process_batch(chunk);
            results.lock().unwrap().push(result);
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let final_results = results.lock().unwrap();
    let total: i32 = final_results.iter().sum();
    println!("Total sum of squares: {}", total);
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 å‡å°‘çº¿ç¨‹åˆ›å»ºå¼€é”€

```rust
use std::thread;
use std::time::Instant;

fn main() {
    let data: Vec<_> = (0..10000).collect();

    // âŒ å·®ï¼šæ¯æ¬¡è¿­ä»£åˆ›å»ºæ–°çº¿ç¨‹
    let start = Instant::now();
    for &item in &data {
        let _ = thread::spawn(move || item * 2).join();
    }
    println!("Per-item spawn: {:?}", start.elapsed());

    // âœ… å¥½ï¼šæ‰¹é‡å¤„ç†
    let start = Instant::now();
    let chunk_size = data.len() / 4;
    let handles: Vec<_> = data.chunks(chunk_size)
        .map(|chunk| {
            let chunk = chunk.to_vec();
            thread::spawn(move || {
                chunk.iter().map(|x| x * 2).collect::<Vec<_>>()
            })
        })
        .collect();

    let _: Vec<_> = handles.into_iter()
        .map(|h| h.join().unwrap())
        .flatten()
        .collect();
    println!("Batched spawn: {:?}", start.elapsed());
}
```

### 8.2 ç¼“å­˜è¡Œå¡«å……é¿å…ä¼ªå…±äº«

```rust
use std::thread;
use std::sync::Arc;

// ä¸å¸¦å¡«å……ï¼šå¯èƒ½äº§ç”Ÿä¼ªå…±äº«
#[derive(Default)]
struct CounterNoPadding {
    value: u64,
}

// å¸¦å¡«å……ï¼šé¿å…ä¼ªå…±äº«ï¼ˆç¼“å­˜è¡Œé€šå¸¸ 64 å­—èŠ‚ï¼‰
#[repr(align(64))]
#[derive(Default)]
struct CounterWithPadding {
    value: u64,
    _padding: [u8; 56], // 64 - 8 = 56
}

fn benchmark<T: Default + Send + Sync + 'static>(
    name: &str,
    increment: fn(&T),
) where
    T: 'static,
{
    let counters = Arc::new([T::default(), T::default()]);
    let start = std::time::Instant::now();

    let handles: Vec<_> = (0..2)
        .map(|i| {
            let counters = Arc::clone(&counters);
            thread::spawn(move || {
                for _ in 0..10_000_000 {
                    increment(&counters[i]);
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    println!("{}: {:?}", name, start.elapsed());
}

fn main() {
    println!("Running benchmarks...");

    // å®é™…æµ‹è¯•éœ€è¦ä½¿ç”¨åŸå­æ“ä½œ
    // è¿™é‡Œä»…ä½œç¤ºæ„
}
```

### 8.3 ä½¿ç”¨ available_parallelism åŠ¨æ€è°ƒæ•´

```rust
use std::thread;

fn main() {
    let parallelism = thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(1);

    println!("Available parallelism: {}", parallelism);

    // æ ¹æ®ç¡¬ä»¶å¹¶å‘æ•°è°ƒæ•´çº¿ç¨‹æ•°
    let num_threads = parallelism.min(8); // æœ€å¤š 8 ä¸ªçº¿ç¨‹

    let handles: Vec<_> = (0..num_threads)
        .map(|i| {
            thread::spawn(move || {
                println!("Thread {} running", i);
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 9. å¸¸è§é™·é˜±

### 9.1 å¿˜è®° join çº¿ç¨‹

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // âŒ é”™è¯¯ï¼šçº¿ç¨‹å¯èƒ½è¿˜æ²¡æ‰§è¡Œå®Œä¸»çº¿ç¨‹å°±é€€å‡ºäº†
    thread::spawn(|| {
        thread::sleep(Duration::from_secs(1));
        println!("This might not print!");
    });

    // main å‡½æ•°ç«‹å³é€€å‡ºï¼Œå­çº¿ç¨‹å¯èƒ½è¢«å¼ºåˆ¶ç»ˆæ­¢

    // âœ… æ­£ç¡®ï¼šç­‰å¾…çº¿ç¨‹å®Œæˆ
    let handle = thread::spawn(|| {
        thread::sleep(Duration::from_secs(1));
        println!("This will definitely print!");
    });
    handle.join().unwrap();
}
```

### 9.2 ä¸å¿…è¦çš„ `Arc<Mutex<T>>`

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    // âŒ ä¸å¿…è¦ï¼šåªè¯»æ•°æ®ä¸éœ€è¦ Mutex
    let data = Arc::new(Mutex::new(vec![1, 2, 3, 4, 5]));
    let data_clone = Arc::clone(&data);

    let handle = thread::spawn(move || {
        let data = data_clone.lock().unwrap();
        println!("Sum: {}", data.iter().sum::<i32>());
    });

    handle.join().unwrap();

    // âœ… æ­£ç¡®ï¼šåªè¯»æ•°æ®åªéœ€ Arc
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let data_clone = Arc::clone(&data);

    let handle = thread::spawn(move || {
        println!("Sum: {}", data_clone.iter().sum::<i32>());
    });

    handle.join().unwrap();
}
```

### 9.3 çº¿ç¨‹æ•°é‡è¿‡å¤š

```rust
use std::thread;
use std::time::Instant;

fn main() {
    let start = Instant::now();

    // âŒ ä¸å¥½ï¼šåˆ›å»º 10000 ä¸ªçº¿ç¨‹
    let handles: Vec<_> = (0..10000)
        .map(|i| thread::spawn(move || i * 2))
        .collect();

    let _: Vec<_> = handles.into_iter()
        .map(|h| h.join().unwrap())
        .collect();

    println!("Too many threads: {:?}", start.elapsed());

    // âœ… å¥½ï¼šä½¿ç”¨ Rayon ç­‰åº“è‡ªåŠ¨ç®¡ç†çº¿ç¨‹æ± 
    // use rayon::prelude::*;
    // let results: Vec<_> = (0..10000).into_par_iter()
    //     .map(|i| i * 2)
    //     .collect();
}
```

---

## 10. å‚è€ƒèµ„æº

### 10.1 å®˜æ–¹æ–‡æ¡£

- [std::thread æ¨¡å—](https://doc.rust-lang.org/std/thread/)
- [The Rust Book - Fearless Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)

### 10.2 ç›¸å…³ Crates

- [`rayon`](https://docs.rs/rayon) - æ•°æ®å¹¶è¡Œåº“
- [`crossbeam`](https://docs.rs/crossbeam) - å¹¶å‘å·¥å…·é›†
- [`threadpool`](https://docs.rs/threadpool) - çº¿ç¨‹æ± å®ç°

### 10.3 è¿›é˜¶é˜…è¯»

- [Rust Concurrency: Five Easy Pieces](https://www.lurklurk.org/effective-rust/concurrency.html)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)

### 10.4 å†…éƒ¨æ–‡æ¡£é“¾æ¥

- [â† è¿”å› Tier 1ï¼šé¡¹ç›®æ¦‚è§ˆ](../tier_01_foundations/01_é¡¹ç›®æ¦‚è§ˆ.md)
- [â†’ ä¸‹ä¸€ç¯‡ï¼šåŒæ­¥åŸè¯­å®è·µ](./02_åŒæ­¥åŸè¯­å®è·µ.md)
- [â†‘ è¿”å›ä¸»ç´¢å¼•](../tier_01_foundations/02_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æ–‡æ¡£ç»´æŠ¤**: C05 Threads Team | **æœ€åå®¡æ ¸**: 2025-10-22 | **è´¨é‡è¯„åˆ†**: 95/100
