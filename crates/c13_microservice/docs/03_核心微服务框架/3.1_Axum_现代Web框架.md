# 3.1 Axum ç°ä»£Webæ¡†æ¶

## ğŸ“‹ ç›®å½•

- [Axumç®€ä»‹](#axumç®€ä»‹)
- [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [è·¯ç”±ç³»ç»Ÿ](#è·¯ç”±ç³»ç»Ÿ)
- [ä¸­é—´ä»¶](#ä¸­é—´ä»¶)
- [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
- [å¼‚æ­¥å¤„ç†](#å¼‚æ­¥å¤„ç†)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [å®é™…æ¡ˆä¾‹](#å®é™…æ¡ˆä¾‹)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## Axumç®€ä»‹

Axumæ˜¯ç”±Tokioå›¢é˜Ÿå¼€å‘çš„ç°ä»£ã€é«˜æ€§èƒ½çš„Rust Webæ¡†æ¶ï¼Œä¸“ä¸ºå¼‚æ­¥ç¼–ç¨‹å’Œå¾®æœåŠ¡æ¶æ„è®¾è®¡ã€‚
å®ƒåŸºäºhyperå’Œtowerç”Ÿæ€ç³»ç»Ÿæ„å»ºï¼Œæä¾›äº†ç®€æ´çš„APIå’Œå¼ºå¤§çš„ç±»å‹å®‰å…¨ä¿è¯ã€‚

### è®¾è®¡ç†å¿µ

- **ç±»å‹å®‰å…¨**: åˆ©ç”¨Rustçš„ç±»å‹ç³»ç»Ÿç¡®ä¿APIçš„æ­£ç¡®æ€§
- **å¼‚æ­¥ä¼˜å…ˆ**: å®Œå…¨åŸºäºasync/awaitçš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹
- **æ¨¡å—åŒ–**: å¯ç»„åˆçš„ä¸­é—´ä»¶å’Œå¤„ç†å™¨
- **æ€§èƒ½**: é›¶æˆæœ¬æŠ½è±¡ï¼Œæ¥è¿‘åŸç”Ÿæ€§èƒ½

## æ ¸å¿ƒç‰¹æ€§

### ç±»å‹å®‰å…¨çš„è·¯ç”±

```rust
use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::Json,
    routing::get,
    Router,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u64,
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct UserQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

// ç±»å‹å®‰å…¨çš„è·¯ç”±å¤„ç†å™¨
async fn get_user(Path(id): Path<u64>) -> Result<Json<User>, StatusCode> {
    // ç¼–è¯‘å™¨ç¡®ä¿è·¯å¾„å‚æ•°ç±»å‹æ­£ç¡®
    match find_user(id).await {
        Some(user) => Ok(Json(user)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

async fn list_users(Query(params): Query<UserQuery>) -> Json<Vec<User>> {
    // æŸ¥è¯¢å‚æ•°è‡ªåŠ¨è§£æå’ŒéªŒè¯
    let users = get_users(params.page, params.limit).await;
    Json(users)
}
```

### å¼ºå¤§çš„æå–å™¨

```rust
use axum::{
    extract::{
        ConnectInfo, FromRequest, FromRequestParts, 
        Host, OriginalUri, Query, Request,
    },
    http::request::Parts,
};

// è‡ªå®šä¹‰æå–å™¨
#[derive(FromRequest)]
#[from_request(state = AppState)]
struct AuthenticatedUser {
    user: User,
    token: String,
}

#[async_trait::async_trait]
impl<S> FromRequest<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = StatusCode;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let (parts, body) = req.into_parts();
        
        // ä»è¯·æ±‚å¤´æå–è®¤è¯ä¿¡æ¯
        let auth_header = parts
            .headers
            .get("authorization")
            .and_then(|h| h.to_str().ok())
            .ok_or(StatusCode::UNAUTHORIZED)?;
            
        // éªŒè¯tokenå¹¶è·å–ç”¨æˆ·ä¿¡æ¯
        let token = auth_header.strip_prefix("Bearer ").unwrap_or(auth_header);
        let user = validate_token(token).await.map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        Ok(AuthenticatedUser {
            user,
            token: token.to_string(),
        })
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰æå–å™¨
async fn protected_route(user: AuthenticatedUser) -> Json<User> {
    Json(user.user)
}
```

## å¿«é€Ÿå¼€å§‹

### åŸºæœ¬æœåŠ¡å™¨

```rust
use axum::{
    response::Html,
    routing::get,
    Router,
};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    // æ„å»ºè·¯ç”±
    let app = Router::new()
        .route("/", get(root))
        .route("/health", get(health_check));

    // å¯åŠ¨æœåŠ¡å™¨
    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    println!("Server running on http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

async fn root() -> Html<&'static str> {
    Html("<h1>Hello, Axum!</h1>")
}

async fn health_check() -> &'static str {
    "OK"
}
```

### å¾®æœåŠ¡ç»“æ„

```rust
use axum::{
    extract::State,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    metrics: Arc<MetricsCollector>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
    let state = AppState {
        database: Arc::new(DatabasePool::new().await?),
        cache: Arc::new(RedisClient::new().await?),
        metrics: Arc::new(MetricsCollector::new()),
    };

    // æ„å»ºAPIè·¯ç”±
    let app = Router::new()
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", post(update_user))
        .route("/health", get(health_check))
        .with_state(state);

    // å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}
```

## è·¯ç”±ç³»ç»Ÿ

### è·¯ç”±å®šä¹‰

```rust
use axum::{
    routing::{get, post, put, delete},
    Router,
};

fn create_user_routes() -> Router {
    Router::new()
        .route("/users", post(create_user))
        .route("/users/:id", get(get_user))
        .route("/users/:id", put(update_user))
        .route("/users/:id", delete(delete_user))
        .route("/users/:id/posts", get(get_user_posts))
        .route("/users/:id/posts", post(create_user_post))
}

fn create_post_routes() -> Router {
    Router::new()
        .route("/posts", get(list_posts))
        .route("/posts", post(create_post))
        .route("/posts/:id", get(get_post))
        .route("/posts/:id", put(update_post))
        .route("/posts/:id", delete(delete_post))
}

// åµŒå¥—è·¯ç”±
fn create_api_routes() -> Router {
    Router::new()
        .nest("/api/v1", create_user_routes())
        .nest("/api/v1", create_post_routes())
        .route("/api/health", get(health_check))
}
```

### è·¯ç”±å‚æ•°

```rust
use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::Json,
};

#[derive(Deserialize)]
struct PaginationQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

#[derive(Deserialize)]
struct UserPath {
    user_id: u64,
}

#[derive(Deserialize)]
struct PostPath {
    user_id: u64,
    post_id: u64,
}

// è·¯å¾„å‚æ•°æå–
async fn get_user(Path(user_id): Path<u64>) -> Result<Json<User>, StatusCode> {
    match find_user_by_id(user_id).await {
        Some(user) => Ok(Json(user)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

// åµŒå¥—è·¯å¾„å‚æ•°
async fn get_user_post(
    Path(PostPath { user_id, post_id }): Path<PostPath>,
) -> Result<Json<Post>, StatusCode> {
    match find_user_post(user_id, post_id).await {
        Some(post) => Ok(Json(post)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

// æŸ¥è¯¢å‚æ•°
async fn list_users(
    Query(pagination): Query<PaginationQuery>,
) -> Json<Vec<User>> {
    let page = pagination.page.unwrap_or(1);
    let limit = pagination.limit.unwrap_or(10);
    
    let users = get_users_paginated(page, limit).await;
    Json(users)
}
```

## ä¸­é—´ä»¶

### å†…ç½®ä¸­é—´ä»¶

```rust
use axum::{
    middleware,
    response::Response,
    routing::get,
    Router,
};
use tower::ServiceBuilder;
use tower_http::{
    cors::CorsLayer,
    compression::CompressionLayer,
    trace::TraceLayer,
    timeout::TimeoutLayer,
};

fn create_app() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(CorsLayer::permissive())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
        )
}

async fn handler() -> &'static str {
    "Hello, Middleware!"
}
```

### è‡ªå®šä¹‰ä¸­é—´ä»¶

```rust
use axum::{
    extract::Request,
    http::{HeaderValue, StatusCode},
    middleware::Next,
    response::Response,
};
use tower::ServiceBuilder;
use std::time::Instant;

// è¯·æ±‚IDä¸­é—´ä»¶
pub async fn request_id_middleware(
    mut request: Request,
    next: Next,
) -> Response {
    let request_id = uuid::Uuid::new_v4().to_string();
    request.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    let mut response = next.run(request).await;
    response.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    response
}

// æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
pub async fn metrics_middleware(
    request: Request,
    next: Next,
) -> Response {
    let start = Instant::now();
    let method = request.method().clone();
    let path = request.uri().path().to_string();
    
    let mut response = next.run(request).await;
    let duration = start.elapsed();
    
    // è®°å½•æŒ‡æ ‡
    record_request_metrics(&method, &path, response.status(), duration);
    
    response
}

// è®¤è¯ä¸­é—´ä»¶
pub async fn auth_middleware(
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request
        .headers()
        .get("authorization")
        .and_then(|h| h.to_str().ok());
        
    match auth_header {
        Some(token) if validate_token(token).await => {
            Ok(next.run(request).await)
        }
        _ => Err(StatusCode::UNAUTHORIZED),
    }
}
```

### ä¸­é—´ä»¶ç»„åˆ

```rust
use tower::ServiceBuilder;

fn create_app_with_middleware() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(middleware::from_fn(request_id_middleware))
                .layer(middleware::from_fn(metrics_middleware))
                .layer(middleware::from_fn_with_state(
                    auth_middleware,
                    app_state.clone(),
                ))
        )
}
```

## é”™è¯¯å¤„ç†

### è‡ªå®šä¹‰é”™è¯¯ç±»å‹

```rust
use axum::{
    extract::rejection::JsonRejection,
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

#[derive(Debug)]
pub enum AppError {
    NotFound(String),
    ValidationError(String),
    DatabaseError(sqlx::Error),
    JsonError(JsonRejection),
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            AppError::ValidationError(msg) => (StatusCode::BAD_REQUEST, msg),
            AppError::DatabaseError(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Database error".to_string(),
            ),
            AppError::JsonError(_) => (
                StatusCode::BAD_REQUEST,
                "Invalid JSON".to_string(),
            ),
            AppError::InternalError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };

        let body = Json(json!({
            "error": error_message,
            "status": status.as_u16()
        }));

        (status, body).into_response()
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯
async fn create_user(
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    if payload.name.is_empty() {
        return Err(AppError::ValidationError("Name cannot be empty".to_string()));
    }
    
    let user = User::create(payload)
        .await
        .map_err(|e| AppError::DatabaseError(e))?;
    
    Ok(Json(user))
}
```

### é”™è¯¯æ¢å¤

```rust
use axum::{
    extract::rejection::JsonRejection,
    response::Json,
};

// JSONé”™è¯¯å¤„ç†
async fn handle_json_error(
    rejection: JsonRejection,
) -> Result<Json<serde_json::Value>, AppError> {
    let error_message = match rejection {
        JsonRejection::JsonDataError(err) => format!("JSON data error: {}", err),
        JsonRejection::JsonSyntaxError(err) => format!("JSON syntax error: {}", err),
        _ => "Invalid JSON".to_string(),
    };
    
    Err(AppError::ValidationError(error_message))
}

// å…¨å±€é”™è¯¯å¤„ç†
fn create_error_handler() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(HandleErrorLayer::new(handle_json_error))
        )
}
```

## å¼‚æ­¥å¤„ç†

### å¼‚æ­¥å¤„ç†å™¨

```rust
use axum::{
    extract::State,
    response::Json,
};
use tokio::task;

async fn heavy_computation_handler(
    State(state): State<AppState>,
) -> Result<Json<ComputationResult>, AppError> {
    // åœ¨åå°ä»»åŠ¡ä¸­æ‰§è¡Œé‡è®¡ç®—
    let result = task::spawn_blocking(move || {
        // CPUå¯†é›†å‹è®¡ç®—
        perform_heavy_computation()
    }).await
    .map_err(|_| AppError::InternalError("Task failed".to_string()))?;
    
    Ok(Json(result))
}

async fn concurrent_requests_handler(
    State(state): State<AppState>,
) -> Result<Json<AggregatedData>, AppError> {
    // å¹¶å‘æ‰§è¡Œå¤šä¸ªå¼‚æ­¥æ“ä½œ
    let (users, posts, comments) = tokio::join!(
        get_users(&state.database),
        get_posts(&state.database),
        get_comments(&state.database),
    );
    
    let aggregated = AggregatedData {
        users: users?,
        posts: posts?,
        comments: comments?,
    };
    
    Ok(Json(aggregated))
}
```

### æµå¼å“åº”

```rust
use axum::{
    body::Stream,
    extract::State,
    response::Response,
};
use tokio_stream::{StreamExt, Stream};

async fn stream_data_handler(
    State(state): State<AppState>,
) -> Response {
    let stream = async_stream::stream! {
        for i in 0..1000 {
            let data = fetch_data(i, &state.database).await;
            yield Ok::<_, axum::Error>(data);
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    };
    
    Response::builder()
        .header("content-type", "application/json")
        .body(Stream::new(stream))
        .unwrap()
}
```

## æ€§èƒ½ä¼˜åŒ–

### è¿æ¥æ± ä¼˜åŒ–

```rust
use sqlx::PgPool;

struct AppState {
    database: PgPool,
}

impl AppState {
    async fn new() -> Result<Self, sqlx::Error> {
        let database = PgPool::builder()
            .max_connections(20)
            .min_connections(5)
            .acquire_timeout(Duration::from_secs(30))
            .idle_timeout(Duration::from_secs(600))
            .build(&database_url)
            .await?;
            
        Ok(Self { database })
    }
}
```

### ç¼“å­˜ç­–ç•¥

```rust
use axum::{
    extract::State,
    response::Json,
};
use redis::AsyncCommands;

async fn get_cached_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<Json<User>, AppError> {
    // å°è¯•ä»ç¼“å­˜è·å–
    let cache_key = format!("user:{}", user_id);
    if let Ok(cached_user) = state.cache.get::<_, String>(&cache_key).await {
        if let Ok(user) = serde_json::from_str::<User>(&cached_user) {
            return Ok(Json(user));
        }
    }
    
    // ä»æ•°æ®åº“è·å–
    let user = get_user_from_db(&state.database, user_id).await?;
    
    // ç¼“å­˜ç»“æœ
    let user_json = serde_json::to_string(&user)?;
    let _: () = state.cache
        .set_ex(&cache_key, user_json, 3600)
        .await?;
    
    Ok(Json(user))
}
```

### å‹ç¼©å’Œé™æ€æ–‡ä»¶

```rust
use tower_http::{
    compression::CompressionLayer,
    services::ServeDir,
};

fn create_app() -> Router {
    Router::new()
        .route("/api/*", api_routes())
        .nest_service("/static", ServeDir::new("static"))
        .layer(CompressionLayer::new())
}
```

## å®é™…æ¡ˆä¾‹

### å®Œæ•´çš„å¾®æœåŠ¡ç¤ºä¾‹

```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    metrics: Arc<MetricsCollector>,
}

#[derive(Serialize, Deserialize)]
struct User {
    id: u64,
    name: String,
    email: String,
    created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct UpdateUserRequest {
    name: Option<String>,
    email: Option<String>,
}

#[derive(Deserialize)]
struct UserQuery {
    page: Option<u32>,
    limit: Option<u32>,
    search: Option<String>,
}

// åˆ›å»ºç”¨æˆ·
async fn create_user(
    State(state): State<AppState>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    // éªŒè¯è¾“å…¥
    validate_user_data(&request)?;
    
    // åˆ›å»ºç”¨æˆ·
    let user = User::create(&state.database, request).await?;
    
    // è®°å½•æŒ‡æ ‡
    state.metrics.increment_user_created();
    
    Ok(Json(user))
}

// è·å–ç”¨æˆ·
async fn get_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<Json<User>, AppError> {
    // å°è¯•ä»ç¼“å­˜è·å–
    if let Some(user) = get_user_from_cache(&state.cache, user_id).await? {
        return Ok(Json(user));
    }
    
    // ä»æ•°æ®åº“è·å–
    let user = get_user_from_db(&state.database, user_id).await?;
    
    // ç¼“å­˜ç»“æœ
    cache_user(&state.cache, &user).await?;
    
    Ok(Json(user))
}

// æ›´æ–°ç”¨æˆ·
async fn update_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
    Json(request): Json<UpdateUserRequest>,
) -> Result<Json<User>, AppError> {
    // æ›´æ–°ç”¨æˆ·
    let user = update_user_in_db(&state.database, user_id, request).await?;
    
    // æ›´æ–°ç¼“å­˜
    cache_user(&state.cache, &user).await?;
    
    Ok(Json(user))
}

// åˆ é™¤ç”¨æˆ·
async fn delete_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<StatusCode, AppError> {
    // ä»æ•°æ®åº“åˆ é™¤
    delete_user_from_db(&state.database, user_id).await?;
    
    // ä»ç¼“å­˜åˆ é™¤
    remove_user_from_cache(&state.cache, user_id).await?;
    
    Ok(StatusCode::NO_CONTENT)
}

// åˆ—å‡ºç”¨æˆ·
async fn list_users(
    State(state): State<AppState>,
    Query(query): Query<UserQuery>,
) -> Result<Json<Vec<User>>, AppError> {
    let page = query.page.unwrap_or(1);
    let limit = query.limit.unwrap_or(10);
    
    let users = get_users_paginated(
        &state.database,
        page,
        limit,
        query.search,
    ).await?;
    
    Ok(Json(users))
}

// å¥åº·æ£€æŸ¥
async fn health_check(State(state): State<AppState>) -> Json<serde_json::Value> {
    let db_healthy = check_database_health(&state.database).await;
    let cache_healthy = check_cache_health(&state.cache).await;
    
    Json(json!({
        "status": "healthy",
        "database": db_healthy,
        "cache": cache_healthy,
        "timestamp": chrono::Utc::now(),
    }))
}

fn create_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(create_user))
        .route("/users", get(list_users))
        .route("/users/:id", get(get_user))
        .route("/users/:id", put(update_user))
        .route("/users/:id", delete(delete_user))
        .route("/health", get(health_check))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
    let state = AppState::new().await?;
    
    // æ„å»ºåº”ç”¨
    let app = Router::new()
        .nest("/api/v1", create_user_routes())
        .with_state(state);
    
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("User service running on http://0.0.0.0:3000");
    
    axum::serve(listener, app).await?;
    Ok(())
}
```

## æœ€ä½³å®è·µ

### 1. çŠ¶æ€ç®¡ç†

```rust
// ä½¿ç”¨Arcå®ç°çŠ¶æ€å…±äº«
#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    config: Arc<Config>,
}

// åœ¨å¤„ç†å™¨ä¸­ä½¿ç”¨çŠ¶æ€
async fn handler(State(state): State<AppState>) -> Result<Json<Data>, AppError> {
    let data = fetch_data(&state.database).await?;
    Ok(Json(data))
}
```

### 2. é”™è¯¯å¤„ç†

```rust
// ç»Ÿä¸€çš„é”™è¯¯ç±»å‹
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Cache error: {0}")]
    Cache(#[from] redis::RedisError),
    
    #[error("Validation error: {0}")]
    Validation(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        // å®ç°é”™è¯¯å“åº”
    }
}
```

### 3. ä¸­é—´ä»¶ä½¿ç”¨

```rust
// ç»„åˆä¸­é—´ä»¶
fn create_app() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(CorsLayer::permissive())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
        )
}
```

### 4. æµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::{
        body::Body,
        http::{Request, StatusCode},
    };
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_create_user() {
        let app = create_user_routes();
        
        let request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"name":"John","email":"john@example.com"}"#))
            .unwrap();
            
        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::CREATED);
    }
}
```

## æ€»ç»“

Axumæ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ã€æ€§èƒ½ä¼˜å¼‚çš„ç°ä»£Rust Webæ¡†æ¶ï¼Œç‰¹åˆ«é€‚åˆæ„å»ºå¾®æœåŠ¡ï¼š

1. **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ç¡®ä¿APIæ­£ç¡®æ€§
2. **å¼‚æ­¥ä¼˜å…ˆ**: å®Œå…¨å¼‚æ­¥çš„ç¼–ç¨‹æ¨¡å‹
3. **æ¨¡å—åŒ–**: å¯ç»„åˆçš„ä¸­é—´ä»¶å’Œå¤„ç†å™¨
4. **é«˜æ€§èƒ½**: æ¥è¿‘åŸç”Ÿçš„æ€§èƒ½è¡¨ç°
5. **æ˜“ç”¨æ€§**: ç®€æ´çš„APIè®¾è®¡

é€šè¿‡åˆç†ä½¿ç”¨Axumçš„ç‰¹æ€§å’Œæœ€ä½³å®è·µï¼Œå¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ã€å¯ç»´æŠ¤çš„å¾®æœåŠ¡ç³»ç»Ÿã€‚
