# 3.1 Axum 现代Web框架

## 📋 目录

- [Axum简介](#axum简介)
- [核心特性](#核心特性)
- [快速开始](#快速开始)
- [路由系统](#路由系统)
- [中间件](#中间件)
- [错误处理](#错误处理)
- [异步处理](#异步处理)
- [性能优化](#性能优化)
- [实际案例](#实际案例)
- [最佳实践](#最佳实践)

## Axum简介

Axum是由Tokio团队开发的现代、高性能的Rust Web框架，专为异步编程和微服务架构设计。
它基于hyper和tower生态系统构建，提供了简洁的API和强大的类型安全保证。

### 设计理念

- **类型安全**: 利用Rust的类型系统确保API的正确性
- **异步优先**: 完全基于async/await的异步编程模型
- **模块化**: 可组合的中间件和处理器
- **性能**: 零成本抽象，接近原生性能

## 核心特性

### 类型安全的路由

```rust
use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::Json,
    routing::get,
    Router,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u64,
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct UserQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

// 类型安全的路由处理器
async fn get_user(Path(id): Path<u64>) -> Result<Json<User>, StatusCode> {
    // 编译器确保路径参数类型正确
    match find_user(id).await {
        Some(user) => Ok(Json(user)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

async fn list_users(Query(params): Query<UserQuery>) -> Json<Vec<User>> {
    // 查询参数自动解析和验证
    let users = get_users(params.page, params.limit).await;
    Json(users)
}
```

### 强大的提取器

```rust
use axum::{
    extract::{
        ConnectInfo, FromRequest, FromRequestParts, 
        Host, OriginalUri, Query, Request,
    },
    http::request::Parts,
};

// 自定义提取器
#[derive(FromRequest)]
#[from_request(state = AppState)]
struct AuthenticatedUser {
    user: User,
    token: String,
}

#[async_trait::async_trait]
impl<S> FromRequest<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = StatusCode;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let (parts, body) = req.into_parts();
        
        // 从请求头提取认证信息
        let auth_header = parts
            .headers
            .get("authorization")
            .and_then(|h| h.to_str().ok())
            .ok_or(StatusCode::UNAUTHORIZED)?;
            
        // 验证token并获取用户信息
        let token = auth_header.strip_prefix("Bearer ").unwrap_or(auth_header);
        let user = validate_token(token).await.map_err(|_| StatusCode::UNAUTHORIZED)?;
        
        Ok(AuthenticatedUser {
            user,
            token: token.to_string(),
        })
    }
}

// 使用自定义提取器
async fn protected_route(user: AuthenticatedUser) -> Json<User> {
    Json(user.user)
}
```

## 快速开始

### 基本服务器

```rust
use axum::{
    response::Html,
    routing::get,
    Router,
};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    // 构建路由
    let app = Router::new()
        .route("/", get(root))
        .route("/health", get(health_check));

    // 启动服务器
    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    println!("Server running on http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

async fn root() -> Html<&'static str> {
    Html("<h1>Hello, Axum!</h1>")
}

async fn health_check() -> &'static str {
    "OK"
}
```

### 微服务结构

```rust
use axum::{
    extract::State,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    metrics: Arc<MetricsCollector>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化应用状态
    let state = AppState {
        database: Arc::new(DatabasePool::new().await?),
        cache: Arc::new(RedisClient::new().await?),
        metrics: Arc::new(MetricsCollector::new()),
    };

    // 构建API路由
    let app = Router::new()
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", post(update_user))
        .route("/health", get(health_check))
        .with_state(state);

    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}
```

## 路由系统

### 路由定义

```rust
use axum::{
    routing::{get, post, put, delete},
    Router,
};

fn create_user_routes() -> Router {
    Router::new()
        .route("/users", post(create_user))
        .route("/users/:id", get(get_user))
        .route("/users/:id", put(update_user))
        .route("/users/:id", delete(delete_user))
        .route("/users/:id/posts", get(get_user_posts))
        .route("/users/:id/posts", post(create_user_post))
}

fn create_post_routes() -> Router {
    Router::new()
        .route("/posts", get(list_posts))
        .route("/posts", post(create_post))
        .route("/posts/:id", get(get_post))
        .route("/posts/:id", put(update_post))
        .route("/posts/:id", delete(delete_post))
}

// 嵌套路由
fn create_api_routes() -> Router {
    Router::new()
        .nest("/api/v1", create_user_routes())
        .nest("/api/v1", create_post_routes())
        .route("/api/health", get(health_check))
}
```

### 路由参数

```rust
use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::Json,
};

#[derive(Deserialize)]
struct PaginationQuery {
    page: Option<u32>,
    limit: Option<u32>,
}

#[derive(Deserialize)]
struct UserPath {
    user_id: u64,
}

#[derive(Deserialize)]
struct PostPath {
    user_id: u64,
    post_id: u64,
}

// 路径参数提取
async fn get_user(Path(user_id): Path<u64>) -> Result<Json<User>, StatusCode> {
    match find_user_by_id(user_id).await {
        Some(user) => Ok(Json(user)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

// 嵌套路径参数
async fn get_user_post(
    Path(PostPath { user_id, post_id }): Path<PostPath>,
) -> Result<Json<Post>, StatusCode> {
    match find_user_post(user_id, post_id).await {
        Some(post) => Ok(Json(post)),
        None => Err(StatusCode::NOT_FOUND),
    }
}

// 查询参数
async fn list_users(
    Query(pagination): Query<PaginationQuery>,
) -> Json<Vec<User>> {
    let page = pagination.page.unwrap_or(1);
    let limit = pagination.limit.unwrap_or(10);
    
    let users = get_users_paginated(page, limit).await;
    Json(users)
}
```

## 中间件

### 内置中间件

```rust
use axum::{
    middleware,
    response::Response,
    routing::get,
    Router,
};
use tower::ServiceBuilder;
use tower_http::{
    cors::CorsLayer,
    compression::CompressionLayer,
    trace::TraceLayer,
    timeout::TimeoutLayer,
};

fn create_app() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(CorsLayer::permissive())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
        )
}

async fn handler() -> &'static str {
    "Hello, Middleware!"
}
```

### 自定义中间件

```rust
use axum::{
    extract::Request,
    http::{HeaderValue, StatusCode},
    middleware::Next,
    response::Response,
};
use tower::ServiceBuilder;
use std::time::Instant;

// 请求ID中间件
pub async fn request_id_middleware(
    mut request: Request,
    next: Next,
) -> Response {
    let request_id = uuid::Uuid::new_v4().to_string();
    request.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    let mut response = next.run(request).await;
    response.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    response
}

// 性能监控中间件
pub async fn metrics_middleware(
    request: Request,
    next: Next,
) -> Response {
    let start = Instant::now();
    let method = request.method().clone();
    let path = request.uri().path().to_string();
    
    let mut response = next.run(request).await;
    let duration = start.elapsed();
    
    // 记录指标
    record_request_metrics(&method, &path, response.status(), duration);
    
    response
}

// 认证中间件
pub async fn auth_middleware(
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request
        .headers()
        .get("authorization")
        .and_then(|h| h.to_str().ok());
        
    match auth_header {
        Some(token) if validate_token(token).await => {
            Ok(next.run(request).await)
        }
        _ => Err(StatusCode::UNAUTHORIZED),
    }
}
```

### 中间件组合

```rust
use tower::ServiceBuilder;

fn create_app_with_middleware() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(middleware::from_fn(request_id_middleware))
                .layer(middleware::from_fn(metrics_middleware))
                .layer(middleware::from_fn_with_state(
                    auth_middleware,
                    app_state.clone(),
                ))
        )
}
```

## 错误处理

### 自定义错误类型

```rust
use axum::{
    extract::rejection::JsonRejection,
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

#[derive(Debug)]
pub enum AppError {
    NotFound(String),
    ValidationError(String),
    DatabaseError(sqlx::Error),
    JsonError(JsonRejection),
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            AppError::ValidationError(msg) => (StatusCode::BAD_REQUEST, msg),
            AppError::DatabaseError(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Database error".to_string(),
            ),
            AppError::JsonError(_) => (
                StatusCode::BAD_REQUEST,
                "Invalid JSON".to_string(),
            ),
            AppError::InternalError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };

        let body = Json(json!({
            "error": error_message,
            "status": status.as_u16()
        }));

        (status, body).into_response()
    }
}

// 使用自定义错误
async fn create_user(
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    if payload.name.is_empty() {
        return Err(AppError::ValidationError("Name cannot be empty".to_string()));
    }
    
    let user = User::create(payload)
        .await
        .map_err(|e| AppError::DatabaseError(e))?;
    
    Ok(Json(user))
}
```

### 错误恢复

```rust
use axum::{
    extract::rejection::JsonRejection,
    response::Json,
};

// JSON错误处理
async fn handle_json_error(
    rejection: JsonRejection,
) -> Result<Json<serde_json::Value>, AppError> {
    let error_message = match rejection {
        JsonRejection::JsonDataError(err) => format!("JSON data error: {}", err),
        JsonRejection::JsonSyntaxError(err) => format!("JSON syntax error: {}", err),
        _ => "Invalid JSON".to_string(),
    };
    
    Err(AppError::ValidationError(error_message))
}

// 全局错误处理
fn create_error_handler() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(HandleErrorLayer::new(handle_json_error))
        )
}
```

## 异步处理

### 异步处理器

```rust
use axum::{
    extract::State,
    response::Json,
};
use tokio::task;

async fn heavy_computation_handler(
    State(state): State<AppState>,
) -> Result<Json<ComputationResult>, AppError> {
    // 在后台任务中执行重计算
    let result = task::spawn_blocking(move || {
        // CPU密集型计算
        perform_heavy_computation()
    }).await
    .map_err(|_| AppError::InternalError("Task failed".to_string()))?;
    
    Ok(Json(result))
}

async fn concurrent_requests_handler(
    State(state): State<AppState>,
) -> Result<Json<AggregatedData>, AppError> {
    // 并发执行多个异步操作
    let (users, posts, comments) = tokio::join!(
        get_users(&state.database),
        get_posts(&state.database),
        get_comments(&state.database),
    );
    
    let aggregated = AggregatedData {
        users: users?,
        posts: posts?,
        comments: comments?,
    };
    
    Ok(Json(aggregated))
}
```

### 流式响应

```rust
use axum::{
    body::Stream,
    extract::State,
    response::Response,
};
use tokio_stream::{StreamExt, Stream};

async fn stream_data_handler(
    State(state): State<AppState>,
) -> Response {
    let stream = async_stream::stream! {
        for i in 0..1000 {
            let data = fetch_data(i, &state.database).await;
            yield Ok::<_, axum::Error>(data);
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    };
    
    Response::builder()
        .header("content-type", "application/json")
        .body(Stream::new(stream))
        .unwrap()
}
```

## 性能优化

### 连接池优化

```rust
use sqlx::PgPool;

struct AppState {
    database: PgPool,
}

impl AppState {
    async fn new() -> Result<Self, sqlx::Error> {
        let database = PgPool::builder()
            .max_connections(20)
            .min_connections(5)
            .acquire_timeout(Duration::from_secs(30))
            .idle_timeout(Duration::from_secs(600))
            .build(&database_url)
            .await?;
            
        Ok(Self { database })
    }
}
```

### 缓存策略

```rust
use axum::{
    extract::State,
    response::Json,
};
use redis::AsyncCommands;

async fn get_cached_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<Json<User>, AppError> {
    // 尝试从缓存获取
    let cache_key = format!("user:{}", user_id);
    if let Ok(cached_user) = state.cache.get::<_, String>(&cache_key).await {
        if let Ok(user) = serde_json::from_str::<User>(&cached_user) {
            return Ok(Json(user));
        }
    }
    
    // 从数据库获取
    let user = get_user_from_db(&state.database, user_id).await?;
    
    // 缓存结果
    let user_json = serde_json::to_string(&user)?;
    let _: () = state.cache
        .set_ex(&cache_key, user_json, 3600)
        .await?;
    
    Ok(Json(user))
}
```

### 压缩和静态文件

```rust
use tower_http::{
    compression::CompressionLayer,
    services::ServeDir,
};

fn create_app() -> Router {
    Router::new()
        .route("/api/*", api_routes())
        .nest_service("/static", ServeDir::new("static"))
        .layer(CompressionLayer::new())
}
```

## 实际案例

### 完整的微服务示例

```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    metrics: Arc<MetricsCollector>,
}

#[derive(Serialize, Deserialize)]
struct User {
    id: u64,
    name: String,
    email: String,
    created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct UpdateUserRequest {
    name: Option<String>,
    email: Option<String>,
}

#[derive(Deserialize)]
struct UserQuery {
    page: Option<u32>,
    limit: Option<u32>,
    search: Option<String>,
}

// 创建用户
async fn create_user(
    State(state): State<AppState>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    // 验证输入
    validate_user_data(&request)?;
    
    // 创建用户
    let user = User::create(&state.database, request).await?;
    
    // 记录指标
    state.metrics.increment_user_created();
    
    Ok(Json(user))
}

// 获取用户
async fn get_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<Json<User>, AppError> {
    // 尝试从缓存获取
    if let Some(user) = get_user_from_cache(&state.cache, user_id).await? {
        return Ok(Json(user));
    }
    
    // 从数据库获取
    let user = get_user_from_db(&state.database, user_id).await?;
    
    // 缓存结果
    cache_user(&state.cache, &user).await?;
    
    Ok(Json(user))
}

// 更新用户
async fn update_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
    Json(request): Json<UpdateUserRequest>,
) -> Result<Json<User>, AppError> {
    // 更新用户
    let user = update_user_in_db(&state.database, user_id, request).await?;
    
    // 更新缓存
    cache_user(&state.cache, &user).await?;
    
    Ok(Json(user))
}

// 删除用户
async fn delete_user(
    State(state): State<AppState>,
    Path(user_id): Path<u64>,
) -> Result<StatusCode, AppError> {
    // 从数据库删除
    delete_user_from_db(&state.database, user_id).await?;
    
    // 从缓存删除
    remove_user_from_cache(&state.cache, user_id).await?;
    
    Ok(StatusCode::NO_CONTENT)
}

// 列出用户
async fn list_users(
    State(state): State<AppState>,
    Query(query): Query<UserQuery>,
) -> Result<Json<Vec<User>>, AppError> {
    let page = query.page.unwrap_or(1);
    let limit = query.limit.unwrap_or(10);
    
    let users = get_users_paginated(
        &state.database,
        page,
        limit,
        query.search,
    ).await?;
    
    Ok(Json(users))
}

// 健康检查
async fn health_check(State(state): State<AppState>) -> Json<serde_json::Value> {
    let db_healthy = check_database_health(&state.database).await;
    let cache_healthy = check_cache_health(&state.cache).await;
    
    Json(json!({
        "status": "healthy",
        "database": db_healthy,
        "cache": cache_healthy,
        "timestamp": chrono::Utc::now(),
    }))
}

fn create_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(create_user))
        .route("/users", get(list_users))
        .route("/users/:id", get(get_user))
        .route("/users/:id", put(update_user))
        .route("/users/:id", delete(delete_user))
        .route("/health", get(health_check))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化应用状态
    let state = AppState::new().await?;
    
    // 构建应用
    let app = Router::new()
        .nest("/api/v1", create_user_routes())
        .with_state(state);
    
    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("User service running on http://0.0.0.0:3000");
    
    axum::serve(listener, app).await?;
    Ok(())
}
```

## 最佳实践

### 1. 状态管理

```rust
// 使用Arc实现状态共享
#[derive(Clone)]
struct AppState {
    database: Arc<DatabasePool>,
    cache: Arc<RedisClient>,
    config: Arc<Config>,
}

// 在处理器中使用状态
async fn handler(State(state): State<AppState>) -> Result<Json<Data>, AppError> {
    let data = fetch_data(&state.database).await?;
    Ok(Json(data))
}
```

### 2. 错误处理

```rust
// 统一的错误类型
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Cache error: {0}")]
    Cache(#[from] redis::RedisError),
    
    #[error("Validation error: {0}")]
    Validation(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        // 实现错误响应
    }
}
```

### 3. 中间件使用

```rust
// 组合中间件
fn create_app() -> Router {
    Router::new()
        .route("/", get(handler))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(CorsLayer::permissive())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
        )
}
```

### 4. 测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::{
        body::Body,
        http::{Request, StatusCode},
    };
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_create_user() {
        let app = create_user_routes();
        
        let request = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"name":"John","email":"john@example.com"}"#))
            .unwrap();
            
        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::CREATED);
    }
}
```

## 总结

Axum是一个功能强大、性能优异的现代Rust Web框架，特别适合构建微服务：

1. **类型安全**: 编译时确保API正确性
2. **异步优先**: 完全异步的编程模型
3. **模块化**: 可组合的中间件和处理器
4. **高性能**: 接近原生的性能表现
5. **易用性**: 简洁的API设计

通过合理使用Axum的特性和最佳实践，可以构建出高性能、可维护的微服务系统。
