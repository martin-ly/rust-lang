# 3.5 fusen-rs æ–°å…´å¾®æœåŠ¡æ¡†æ¶

## ğŸ“‹ ç›®å½•

- [fusen-rs æ¦‚è¿°](#fusen-rs-æ¦‚è¿°)
- [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [é«˜çº§ç‰¹æ€§](#é«˜çº§ç‰¹æ€§)
- [ä¸Spring Booté›†æˆ](#ä¸spring-booté›†æˆ)
- [æ€§èƒ½ä¼˜åŠ¿](#æ€§èƒ½ä¼˜åŠ¿)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#å®é™…åº”ç”¨æ¡ˆä¾‹)

## fusen-rs æ¦‚è¿°

fusen-rs æ˜¯ä¸€ä¸ªåŸºäºRustçš„é«˜æ€§èƒ½å¾®æœåŠ¡æ¡†æ¶ï¼Œç”±å­—èŠ‚è·³åŠ¨å¼€æºã€‚
å®ƒé€šè¿‡Rustå®å®ç°ç¼–è¯‘å™¨åå°„ï¼Œæ”¯æŒé«˜æ€§èƒ½çš„RPCè°ƒç”¨ï¼Œå…¼å®¹Spring Bootå’ŒDubbo3åè®®ï¼Œæ”¯æŒä¸Javaé¡¹ç›®äº’æ“ä½œï¼Œå¹¶æä¾›HTTPå’ŒHTTP/2åè®®è°ƒç”¨ç­‰åŠŸèƒ½ã€‚

### ä¸»è¦ç‰¹ç‚¹

- **æ— IDLæ–‡ä»¶**: æ— éœ€å®šä¹‰IDLæ–‡ä»¶ï¼Œé€šè¿‡Rustå®å®ç°ç¼–è¯‘å™¨åå°„
- **é«˜æ€§èƒ½RPC**: åŸºäºRustçš„é«˜æ€§èƒ½RPCè°ƒç”¨
- **è·¨è¯­è¨€å…¼å®¹**: å…¼å®¹Spring Bootå’ŒDubbo3åè®®
- **Javaäº’æ“ä½œ**: æ”¯æŒä¸Javaé¡¹ç›®æ— ç¼é›†æˆ
- **å¤šåè®®æ”¯æŒ**: æ”¯æŒHTTPã€HTTP/2ã€gRPCç­‰åè®®
- **æœåŠ¡æ²»ç†**: æä¾›æœåŠ¡æ³¨å†Œå‘ç°ã€è´Ÿè½½å‡è¡¡ç­‰åŠŸèƒ½

## æ ¸å¿ƒç‰¹æ€§

### 1. ç¼–è¯‘å™¨åå°„

#### è‡ªåŠ¨ä»£ç ç”Ÿæˆ

```rust
use fusen_rs::service;
use fusen_rs::rpc;

// å®šä¹‰æœåŠ¡æ¥å£
#[service]
pub trait UserService {
    async fn get_user(&self, id: u64) -> Result<User, Error>;
    async fn create_user(&self, user: CreateUserRequest) -> Result<User, Error>;
    async fn update_user(&self, id: u64, user: UpdateUserRequest) -> Result<User, Error>;
    async fn delete_user(&self, id: u64) -> Result<(), Error>;
}

// å®ç°æœåŠ¡
#[service_impl]
pub struct UserServiceImpl {
    db: Arc<Database>,
}

#[async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(&self, id: u64) -> Result<User, Error> {
        self.db.get_user(id).await
    }
    
    async fn create_user(&self, request: CreateUserRequest) -> Result<User, Error> {
        let user = User::from(request);
        self.db.create_user(user).await
    }
    
    async fn update_user(&self, id: u64, request: UpdateUserRequest) -> Result<User, Error> {
        let user = User::from(request);
        self.db.update_user(id, user).await
    }
    
    async fn delete_user(&self, id: u64) -> Result<(), Error> {
        self.db.delete_user(id).await
    }
}
```

### 2. é«˜æ€§èƒ½RPC

#### å¼‚æ­¥RPCè°ƒç”¨

```rust
use fusen_rs::client::RpcClient;
use fusen_rs::server::RpcServer;

// åˆ›å»ºRPCå®¢æˆ·ç«¯
let client = RpcClient::new("http://localhost:8080").await?;

// å¼‚æ­¥RPCè°ƒç”¨
async fn call_user_service() -> Result<(), Error> {
    let user_service = client.get_service::<UserService>().await?;
    
    // é«˜æ€§èƒ½å¼‚æ­¥è°ƒç”¨
    let user = user_service.get_user(123).await?;
    println!("User: {:?}", user);
    
    // æ‰¹é‡è°ƒç”¨
    let futures: Vec<_> = (1..100)
        .map(|id| user_service.get_user(id))
        .collect();
    
    let users = futures::future::join_all(futures).await;
    println!("Users: {:?}", users);
    
    Ok(())
}
```

### 3. æœåŠ¡æ³¨å†Œå‘ç°

#### è‡ªåŠ¨æœåŠ¡æ³¨å†Œ

```rust
use fusen_rs::registry::{Registry, ConsulRegistry};
use fusen_rs::server::RpcServer;

// é…ç½®æœåŠ¡æ³¨å†Œ
let registry = ConsulRegistry::new("http://localhost:8500").await?;

// åˆ›å»ºRPCæœåŠ¡å™¨
let server = RpcServer::new()
    .with_registry(registry)
    .with_port(8080)
    .with_service(UserServiceImpl::new(db))
    .build();

// è‡ªåŠ¨æ³¨å†ŒæœåŠ¡
server.start().await?;
```

#### æœåŠ¡å‘ç°

```rust
use fusen_rs::discovery::{ServiceDiscovery, ConsulDiscovery};

// é…ç½®æœåŠ¡å‘ç°
let discovery = ConsulDiscovery::new("http://localhost:8500").await?;

// å‘ç°æœåŠ¡
async fn discover_services() -> Result<(), Error> {
    let services = discovery.discover_services("user-service").await?;
    
    for service in services {
        println!("Service: {} at {}", service.name, service.address);
        
        // åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥
        let client = RpcClient::new(&service.address).await?;
        let user_service = client.get_service::<UserService>().await?;
        
        // è°ƒç”¨æœåŠ¡
        let user = user_service.get_user(123).await?;
        println!("User from {}: {:?}", service.address, user);
    }
    
    Ok(())
}
```

## æ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client App    â”‚    â”‚   Client App    â”‚    â”‚   Client App    â”‚
â”‚   (Rust/Java)   â”‚    â”‚   (Rust/Java)   â”‚    â”‚   (Rust/Java)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Load Balancer        â”‚
                    â”‚    (Round Robin/Least     â”‚
                    â”‚     Connection/Weight)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Service Registry     â”‚
                    â”‚      (Consul/etcd)        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Service   â”‚    â”‚  Order Service  â”‚    â”‚  Payment Serviceâ”‚
â”‚   (Rust)        â”‚    â”‚   (Rust)        â”‚    â”‚   (Rust)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Database Cluster     â”‚
                    â”‚   (PostgreSQL/MySQL)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒç»„ä»¶

#### æœåŠ¡ä»£ç†

```rust
use fusen_rs::proxy::ServiceProxy;
use fusen_rs::load_balancer::{LoadBalancer, RoundRobin};

// æœåŠ¡ä»£ç†é…ç½®
pub struct ServiceProxyConfig {
    pub service_name: String,
    pub load_balancer: Box<dyn LoadBalancer>,
    pub timeout: Duration,
    pub retry_count: u32,
}

impl ServiceProxyConfig {
    pub fn new(service_name: String) -> Self {
        Self {
            service_name,
            load_balancer: Box::new(RoundRobin::new()),
            timeout: Duration::from_secs(30),
            retry_count: 3,
        }
    }
}
```

#### è´Ÿè½½å‡è¡¡å™¨

```rust
use fusen_rs::load_balancer::{LoadBalancer, ServiceInstance};

// è½®è¯¢è´Ÿè½½å‡è¡¡
pub struct RoundRobin {
    current: AtomicUsize,
}

impl LoadBalancer for RoundRobin {
    fn select(&self, instances: &[ServiceInstance]) -> Option<&ServiceInstance> {
        if instances.is_empty() {
            return None;
        }
        
        let index = self.current.fetch_add(1, Ordering::Relaxed) % instances.len();
        instances.get(index)
    }
}

// æœ€å°‘è¿æ¥è´Ÿè½½å‡è¡¡
pub struct LeastConnection {
    connections: Arc<Mutex<HashMap<String, usize>>>,
}

impl LoadBalancer for LeastConnection {
    fn select(&self, instances: &[ServiceInstance]) -> Option<&ServiceInstance> {
        if instances.is_empty() {
            return None;
        }
        
        let mut connections = self.connections.lock().unwrap();
        let mut min_connections = usize::MAX;
        let mut selected = None;
        
        for instance in instances {
            let conn_count = connections.get(&instance.id).unwrap_or(&0);
            if *conn_count < min_connections {
                min_connections = *conn_count;
                selected = Some(instance);
            }
        }
        
        if let Some(instance) = selected {
            *connections.entry(instance.id.clone()).or_insert(0) += 1;
        }
        
        selected
    }
}
```

## å¿«é€Ÿå¼€å§‹

### 1. é¡¹ç›®è®¾ç½®

#### Cargo.tomlé…ç½®

```toml
[package]
name = "fusen-microservice"
version = "0.1.0"
edition = "2021"

[dependencies]
fusen-rs = "0.1.0"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"

[build-dependencies]
fusen-rs-build = "0.1.0"
```

#### æ„å»ºè„šæœ¬

```rust
// build.rs
fn main() {
    fusen_rs_build::compile_protos("proto/");
}
```

### 2. å®šä¹‰æœåŠ¡

#### æœåŠ¡æ¥å£å®šä¹‰

```rust
// src/services/user_service.rs
use fusen_rs::service;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserRequest {
    pub name: Option<String>,
    pub email: Option<String>,
}

#[service]
pub trait UserService {
    async fn get_user(&self, id: u64) -> Result<User, Error>;
    async fn create_user(&self, request: CreateUserRequest) -> Result<User, Error>;
    async fn update_user(&self, id: u64, request: UpdateUserRequest) -> Result<User, Error>;
    async fn delete_user(&self, id: u64) -> Result<(), Error>;
    async fn list_users(&self, page: u32, size: u32) -> Result<Vec<User>, Error>;
}
```

#### æœåŠ¡å®ç°

```rust
// src/services/user_service_impl.rs
use fusen_rs::service_impl;
use crate::services::user_service::{UserService, User, CreateUserRequest, UpdateUserRequest};
use crate::database::Database;

#[service_impl]
pub struct UserServiceImpl {
    db: Arc<Database>,
}

impl UserServiceImpl {
    pub fn new(db: Arc<Database>) -> Self {
        Self { db }
    }
}

#[async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(&self, id: u64) -> Result<User, Error> {
        self.db.get_user(id).await
    }
    
    async fn create_user(&self, request: CreateUserRequest) -> Result<User, Error> {
        let user = User {
            id: 0, // æ•°æ®åº“è‡ªåŠ¨ç”Ÿæˆ
            name: request.name,
            email: request.email,
            created_at: chrono::Utc::now(),
        };
        
        self.db.create_user(user).await
    }
    
    async fn update_user(&self, id: u64, request: UpdateUserRequest) -> Result<User, Error> {
        let mut user = self.db.get_user(id).await?;
        
        if let Some(name) = request.name {
            user.name = name;
        }
        
        if let Some(email) = request.email {
            user.email = email;
        }
        
        self.db.update_user(id, user).await
    }
    
    async fn delete_user(&self, id: u64) -> Result<(), Error> {
        self.db.delete_user(id).await
    }
    
    async fn list_users(&self, page: u32, size: u32) -> Result<Vec<User>, Error> {
        self.db.list_users(page, size).await
    }
}
```

### 3. å¯åŠ¨æœåŠ¡å™¨

#### æœåŠ¡å™¨é…ç½®

```rust
// src/main.rs
use fusen_rs::server::RpcServer;
use fusen_rs::registry::ConsulRegistry;
use crate::services::user_service_impl::UserServiceImpl;
use crate::database::Database;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // è¿æ¥æ•°æ®åº“
    let db = Arc::new(Database::new("postgresql://localhost/microservice").await?);
    
    // é…ç½®æœåŠ¡æ³¨å†Œ
    let registry = ConsulRegistry::new("http://localhost:8500").await?;
    
    // åˆ›å»ºæœåŠ¡å®ä¾‹
    let user_service = UserServiceImpl::new(db);
    
    // å¯åŠ¨RPCæœåŠ¡å™¨
    let server = RpcServer::new()
        .with_registry(registry)
        .with_port(8080)
        .with_service(user_service)
        .build();
    
    println!("Starting fusen-rs server on port 8080...");
    server.start().await?;
    
    Ok(())
}
```

### 4. åˆ›å»ºå®¢æˆ·ç«¯

#### å®¢æˆ·ç«¯ä»£ç 

```rust
// src/client.rs
use fusen_rs::client::RpcClient;
use crate::services::user_service::{UserService, CreateUserRequest};

pub struct UserServiceClient {
    client: RpcClient,
}

impl UserServiceClient {
    pub async fn new(server_url: &str) -> Result<Self, Error> {
        let client = RpcClient::new(server_url).await?;
        Ok(Self { client })
    }
    
    pub async fn get_user(&self, id: u64) -> Result<User, Error> {
        let service = self.client.get_service::<UserService>().await?;
        service.get_user(id).await
    }
    
    pub async fn create_user(&self, name: String, email: String) -> Result<User, Error> {
        let service = self.client.get_service::<UserService>().await?;
        let request = CreateUserRequest { name, email };
        service.create_user(request).await
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = UserServiceClient::new("http://localhost:8080").await?;
    
    // åˆ›å»ºç”¨æˆ·
    let user = client.create_user("å¼ ä¸‰".to_string(), "zhangsan@example.com".to_string()).await?;
    println!("Created user: {:?}", user);
    
    // è·å–ç”¨æˆ·
    let retrieved_user = client.get_user(user.id).await?;
    println!("Retrieved user: {:?}", retrieved_user);
    
    Ok(())
}
```

## é«˜çº§ç‰¹æ€§

### 1. ä¸­é—´ä»¶æ”¯æŒ

#### è‡ªå®šä¹‰ä¸­é—´ä»¶

```rust
use fusen_rs::middleware::{Middleware, MiddlewareChain};
use fusen_rs::context::RpcContext;

// æ—¥å¿—ä¸­é—´ä»¶
pub struct LoggingMiddleware;

#[async_trait]
impl Middleware for LoggingMiddleware {
    async fn handle(&self, ctx: &mut RpcContext, chain: &mut MiddlewareChain) -> Result<(), Error> {
        let start = std::time::Instant::now();
        let service_name = ctx.service_name();
        let method_name = ctx.method_name();
        
        tracing::info!("Calling {}.{}", service_name, method_name);
        
        let result = chain.next(ctx).await;
        
        let duration = start.elapsed();
        match &result {
            Ok(_) => tracing::info!("{}.{} completed in {:?}", service_name, method_name, duration),
            Err(e) => tracing::error!("{}.{} failed in {:?}: {}", service_name, method_name, duration, e),
        }
        
        result
    }
}

// è®¤è¯ä¸­é—´ä»¶
pub struct AuthMiddleware {
    jwt_secret: String,
}

#[async_trait]
impl Middleware for AuthMiddleware {
    async fn handle(&self, ctx: &mut RpcContext, chain: &mut MiddlewareChain) -> Result<(), Error> {
        let token = ctx.get_header("Authorization")
            .ok_or_else(|| Error::Unauthorized("Missing authorization header".to_string()))?;
        
        // éªŒè¯JWT token
        self.validate_token(token)?;
        
        chain.next(ctx).await
    }
    
    fn validate_token(&self, token: &str) -> Result<(), Error> {
        // JWTéªŒè¯é€»è¾‘
        todo!()
    }
}
```

### 2. ç†”æ–­å™¨æ¨¡å¼

#### ç†”æ–­å™¨å®ç°

```rust
use fusen_rs::circuit_breaker::{CircuitBreaker, CircuitBreakerState};

pub struct ServiceCircuitBreaker {
    state: Arc<Mutex<CircuitBreakerState>>,
    failure_threshold: u32,
    timeout: Duration,
}

impl ServiceCircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            state: Arc::new(Mutex::new(CircuitBreakerState::Closed)),
            failure_threshold,
            timeout,
        }
    }
    
    pub async fn call<T, F, Fut>(&self, f: F) -> Result<T, Error>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = Result<T, Error>>,
    {
        let mut state = self.state.lock().unwrap();
        
        match *state {
            CircuitBreakerState::Open => {
                return Err(Error::CircuitBreakerOpen);
            }
            CircuitBreakerState::HalfOpen => {
                // å…è®¸ä¸€ä¸ªè¯·æ±‚é€šè¿‡
            }
            CircuitBreakerState::Closed => {
                // æ­£å¸¸çŠ¶æ€
            }
        }
        
        drop(state);
        
        let result = f().await;
        
        let mut state = self.state.lock().unwrap();
        match result {
            Ok(_) => {
                *state = CircuitBreakerState::Closed;
            }
            Err(_) => {
                // å¢åŠ å¤±è´¥è®¡æ•°
                // å¦‚æœè¾¾åˆ°é˜ˆå€¼ï¼Œæ‰“å¼€ç†”æ–­å™¨
            }
        }
        
        result
    }
}
```

### 3. é™æµå™¨

#### ä»¤ç‰Œæ¡¶é™æµ

```rust
use fusen_rs::rate_limiter::{RateLimiter, TokenBucket};

pub struct TokenBucketRateLimiter {
    bucket: Arc<Mutex<TokenBucket>>,
}

impl TokenBucketRateLimiter {
    pub fn new(capacity: u32, refill_rate: u32) -> Self {
        Self {
            bucket: Arc::new(Mutex::new(TokenBucket::new(capacity, refill_rate))),
        }
    }
    
    pub async fn acquire(&self, tokens: u32) -> Result<(), Error> {
        let mut bucket = self.bucket.lock().unwrap();
        
        if bucket.try_acquire(tokens) {
            Ok(())
        } else {
            Err(Error::RateLimitExceeded)
        }
    }
}

impl RateLimiter for TokenBucketRateLimiter {
    fn is_allowed(&self) -> bool {
        let mut bucket = self.bucket.lock().unwrap();
        bucket.try_acquire(1)
    }
}
```

## ä¸Spring Booté›†æˆ

### 1. Javaå®¢æˆ·ç«¯

#### Spring Booté…ç½®

```java
// application.yml
fusen:
  registry:
    type: consul
    address: http://localhost:8500
  client:
    timeout: 30000
    retry-count: 3
```

#### JavaæœåŠ¡æ¥å£

```java
// UserService.java
@FusenService
public interface UserService {
    CompletableFuture<User> getUser(Long id);
    CompletableFuture<User> createUser(CreateUserRequest request);
    CompletableFuture<User> updateUser(Long id, UpdateUserRequest request);
    CompletableFuture<Void> deleteUser(Long id);
    CompletableFuture<List<User>> listUsers(Integer page, Integer size);
}
```

#### JavaæœåŠ¡è°ƒç”¨

```java
// UserController.java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public CompletableFuture<ResponseEntity<User>> getUser(@PathVariable Long id) {
        return userService.getUser(id)
            .thenApply(user -> ResponseEntity.ok(user))
            .exceptionally(throwable -> ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public CompletableFuture<ResponseEntity<User>> createUser(@RequestBody CreateUserRequest request) {
        return userService.createUser(request)
            .thenApply(user -> ResponseEntity.ok(user))
            .exceptionally(throwable -> ResponseEntity.badRequest().build());
    }
}
```

### 2. åè®®å…¼å®¹

#### Dubbo3åè®®æ”¯æŒ

```rust
use fusen_rs::protocol::{Protocol, Dubbo3Protocol};

// é…ç½®Dubbo3åè®®
let protocol = Dubbo3Protocol::new()
    .with_serialization("hessian2")
    .with_compression("gzip")
    .build();

// åœ¨æœåŠ¡å™¨ä¸­ä½¿ç”¨
let server = RpcServer::new()
    .with_protocol(protocol)
    .with_service(user_service)
    .build();
```

## æ€§èƒ½ä¼˜åŠ¿

### 1. åŸºå‡†æµ‹è¯•

#### æ€§èƒ½å¯¹æ¯”

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use fusen_rs::client::RpcClient;
use fusen_rs::server::RpcServer;

fn benchmark_rpc_call(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    c.bench_function("fusen-rs rpc call", |b| {
        b.to_async(&rt).iter(|| async {
            let client = RpcClient::new("http://localhost:8080").await.unwrap();
            let service = client.get_service::<UserService>().await.unwrap();
            let result = service.get_user(black_box(123)).await.unwrap();
            result
        })
    });
}

criterion_group!(benches, benchmark_rpc_call);
criterion_main!(benches);
```

### 2. å†…å­˜ä½¿ç”¨

#### å†…å­˜ä¼˜åŒ–

```rust
use fusen_rs::memory::{MemoryPool, PooledBuffer};

// å†…å­˜æ± ç®¡ç†
pub struct OptimizedService {
    memory_pool: Arc<MemoryPool>,
}

impl OptimizedService {
    pub fn new() -> Self {
        Self {
            memory_pool: Arc::new(MemoryPool::new(1024 * 1024)), // 1MBæ± 
        }
    }
    
    pub async fn process_request(&self, data: &[u8]) -> Result<Vec<u8>, Error> {
        // ä»å†…å­˜æ± è·å–ç¼“å†²åŒº
        let mut buffer = self.memory_pool.get_buffer(data.len());
        buffer.copy_from_slice(data);
        
        // å¤„ç†æ•°æ®
        let result = self.process_data(&buffer).await?;
        
        // ç¼“å†²åŒºä¼šè‡ªåŠ¨è¿”å›åˆ°æ± ä¸­
        Ok(result)
    }
}
```

## æœ€ä½³å®è·µ

### 1. æœåŠ¡è®¾è®¡

#### æœåŠ¡è¾¹ç•Œåˆ’åˆ†

```rust
// æŒ‰ä¸šåŠ¡èƒ½åŠ›åˆ’åˆ†æœåŠ¡
pub mod user_service {
    // ç”¨æˆ·ç®¡ç†ç›¸å…³åŠŸèƒ½
}

pub mod order_service {
    // è®¢å•ç®¡ç†ç›¸å…³åŠŸèƒ½
}

pub mod payment_service {
    // æ”¯ä»˜å¤„ç†ç›¸å…³åŠŸèƒ½
}

// é¿å…è·¨æœåŠ¡çš„æ•°æ®ä¾èµ–
pub struct UserService {
    // åªåŒ…å«ç”¨æˆ·ç›¸å…³çš„æ•°æ®è®¿é—®
    user_repo: Arc<UserRepository>,
}

pub struct OrderService {
    // åªåŒ…å«è®¢å•ç›¸å…³çš„æ•°æ®è®¿é—®
    order_repo: Arc<OrderRepository>,
    // é€šè¿‡RPCè°ƒç”¨ç”¨æˆ·æœåŠ¡ï¼Œè€Œä¸æ˜¯ç›´æ¥è®¿é—®ç”¨æˆ·æ•°æ®
    user_service_client: Arc<UserServiceClient>,
}
```

### 2. é”™è¯¯å¤„ç†

#### ç»Ÿä¸€é”™è¯¯å¤„ç†

```rust
use fusen_rs::error::{Error, ErrorCode};

#[derive(Debug, thiserror::Error)]
pub enum ServiceError {
    #[error("User not found: {id}")]
    UserNotFound { id: u64 },
    
    #[error("Invalid request: {message}")]
    InvalidRequest { message: String },
    
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
    
    #[error("Network error: {0}")]
    NetworkError(#[from] reqwest::Error),
}

impl From<ServiceError> for Error {
    fn from(err: ServiceError) -> Self {
        match err {
            ServiceError::UserNotFound { .. } => Error::new(ErrorCode::NotFound, err.to_string()),
            ServiceError::InvalidRequest { .. } => Error::new(ErrorCode::BadRequest, err.to_string()),
            ServiceError::DatabaseError(_) => Error::new(ErrorCode::InternalError, err.to_string()),
            ServiceError::NetworkError(_) => Error::new(ErrorCode::NetworkError, err.to_string()),
        }
    }
}
```

### 3. é…ç½®ç®¡ç†

#### ç¯å¢ƒé…ç½®

```rust
use fusen_rs::config::{Config, Environment};

#[derive(Debug, Deserialize)]
pub struct ServiceConfig {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub registry: RegistryConfig,
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub port: u16,
    pub host: String,
    pub workers: usize,
}

impl ServiceConfig {
    pub fn from_env() -> Result<Self, Error> {
        let config = Config::builder()
            .add_source(Environment::default())
            .build()?;
        
        config.try_deserialize()
    }
}
```

## å®é™…åº”ç”¨æ¡ˆä¾‹

### 1. ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ

#### ç³»ç»Ÿæ¶æ„

```rust
// ç”¨æˆ·æœåŠ¡
pub struct UserService {
    user_repo: Arc<UserRepository>,
    cache: Arc<RedisCache>,
}

// å•†å“æœåŠ¡
pub struct ProductService {
    product_repo: Arc<ProductRepository>,
    search_engine: Arc<ElasticsearchClient>,
}

// è®¢å•æœåŠ¡
pub struct OrderService {
    order_repo: Arc<OrderRepository>,
    user_client: Arc<UserServiceClient>,
    product_client: Arc<ProductServiceClient>,
    payment_client: Arc<PaymentServiceClient>,
}

// æ”¯ä»˜æœåŠ¡
pub struct PaymentService {
    payment_repo: Arc<PaymentRepository>,
    payment_gateway: Arc<PaymentGateway>,
}
```

### 2. å®æ—¶é€šä¿¡ç³»ç»Ÿ

#### WebSocketæœåŠ¡

```rust
use fusen_rs::websocket::{WebSocketServer, WebSocketHandler};

pub struct ChatService {
    rooms: Arc<RwLock<HashMap<String, ChatRoom>>>,
}

impl WebSocketHandler for ChatService {
    async fn on_connect(&self, connection: WebSocketConnection) -> Result<(), Error> {
        // å¤„ç†è¿æ¥
        Ok(())
    }
    
    async fn on_message(&self, connection: WebSocketConnection, message: String) -> Result<(), Error> {
        // å¤„ç†æ¶ˆæ¯
        let chat_message: ChatMessage = serde_json::from_str(&message)?;
        self.broadcast_message(chat_message).await?;
        Ok(())
    }
    
    async fn on_disconnect(&self, connection: WebSocketConnection) -> Result<(), Error> {
        // å¤„ç†æ–­å¼€è¿æ¥
        Ok(())
    }
}
```

## æ€»ç»“

fusen-rs ä½œä¸ºä¸€ä¸ªæ–°å…´çš„Rustå¾®æœåŠ¡æ¡†æ¶ï¼Œå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

1. **é«˜æ€§èƒ½**: åŸºäºRustçš„é«˜æ€§èƒ½RPCè°ƒç”¨
2. **æ˜“ç”¨æ€§**: æ— éœ€IDLæ–‡ä»¶ï¼Œé€šè¿‡å®è‡ªåŠ¨ç”Ÿæˆä»£ç 
3. **è·¨è¯­è¨€**: ä¸Java/Spring Bootæ— ç¼é›†æˆ
4. **æœåŠ¡æ²»ç†**: å®Œæ•´çš„æœåŠ¡æ³¨å†Œå‘ç°å’Œè´Ÿè½½å‡è¡¡
5. **å¯æ‰©å±•**: æ”¯æŒä¸­é—´ä»¶ã€ç†”æ–­å™¨ã€é™æµå™¨ç­‰é«˜çº§ç‰¹æ€§

åœ¨2025å¹´çš„å¾®æœåŠ¡ç”Ÿæ€ä¸­ï¼Œfusen-rs ä¸ºRustå¼€å‘è€…æä¾›äº†ä¸€ä¸ªå¼ºå¤§è€Œçµæ´»çš„é€‰æ‹©ï¼Œç‰¹åˆ«é€‚åˆéœ€è¦é«˜æ€§èƒ½å’Œè·¨è¯­è¨€é›†æˆçš„åœºæ™¯ã€‚
