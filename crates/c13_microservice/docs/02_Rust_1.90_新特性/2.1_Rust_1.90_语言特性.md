# 2.1 Rust 1.90 è¯­è¨€ç‰¹æ€§

## ğŸ“‹ ç›®å½•

- [Rust 1.90 å‘å¸ƒæ¦‚è¿°](#rust-190-å‘å¸ƒæ¦‚è¿°)
- [æ ¸å¿ƒè¯­è¨€ç‰¹æ€§](#æ ¸å¿ƒè¯­è¨€ç‰¹æ€§)
- [ç¼–è¯‘å™¨æ”¹è¿›](#ç¼–è¯‘å™¨æ”¹è¿›)
- [æ ‡å‡†åº“å¢å¼º](#æ ‡å‡†åº“å¢å¼º)
- [å·¥å…·é“¾æ›´æ–°](#å·¥å…·é“¾æ›´æ–°)
- [å¾®æœåŠ¡ç›¸å…³æ”¹è¿›](#å¾®æœåŠ¡ç›¸å…³æ”¹è¿›)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [å‘åå…¼å®¹æ€§](#å‘åå…¼å®¹æ€§)

## Rust 1.90 å‘å¸ƒæ¦‚è¿°

Rust 1.90 äº2025å¹´9æœˆå‘å¸ƒï¼Œå¸¦æ¥äº†å¤šé¡¹é‡è¦çš„è¯­è¨€ç‰¹æ€§æ”¹è¿›ã€æ€§èƒ½ä¼˜åŒ–å’Œå·¥å…·é“¾å¢å¼ºã€‚
è¿™ä¸ªç‰ˆæœ¬ç‰¹åˆ«å…³æ³¨äº†å¼‚æ­¥ç¼–ç¨‹ã€å†…å­˜å®‰å…¨å’Œå¼€å‘ä½“éªŒçš„æå‡ï¼Œä¸ºå¾®æœåŠ¡å¼€å‘æä¾›äº†æ›´å¥½çš„æ”¯æŒã€‚

### ä¸»è¦äº®ç‚¹

- **å¼‚æ­¥ç¼–ç¨‹å¢å¼º**: æ”¹è¿›çš„async/awaitè¯­æ³•å’Œæ€§èƒ½
- **å†…å­˜å®‰å…¨æ”¹è¿›**: æ›´ä¸¥æ ¼çš„å€Ÿç”¨æ£€æŸ¥å™¨
- **ç¼–è¯‘å™¨ä¼˜åŒ–**: æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦å’Œæ›´å¥½çš„é”™è¯¯ä¿¡æ¯
- **æ ‡å‡†åº“æ‰©å±•**: æ–°çš„å®ç”¨å·¥å…·å’Œæ•°æ®ç»“æ„
- **å·¥å…·é“¾æ”¹è¿›**: æ›´å¥½çš„IDEæ”¯æŒå’Œè°ƒè¯•ä½“éªŒ

## æ ¸å¿ƒè¯­è¨€ç‰¹æ€§

### 1. æ”¹è¿›çš„å¼‚æ­¥ç¼–ç¨‹

#### æ–°çš„asyncè¯­æ³•ç³–

```rust
// Rust 1.90 ä¹‹å‰
async fn process_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}

// Rust 1.90 æ–°è¯­æ³•
async fn process_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}
```

#### å¼‚æ­¥è¿­ä»£å™¨æ”¹è¿›

```rust
use std::future::Future;
use std::pin::Pin;

// æ–°çš„å¼‚æ­¥è¿­ä»£å™¨trait
trait AsyncIterator {
    type Item;
    type Future: Future<Output = Option<Self::Item>>;
    
    fn next(&mut self) -> Self::Future;
}

// å¼‚æ­¥æµå¤„ç†
async fn process_stream<T: AsyncIterator>(mut stream: T) 
where 
    T::Item: Send,
{
    while let Some(item) = stream.next().await {
        process_item(item).await;
    }
}
```

### 2. å¢å¼ºçš„æ¨¡å¼åŒ¹é…

#### æ–°çš„åŒ¹é…è¯­æ³•

```rust
// æ”¹è¿›çš„æ¨¡å¼åŒ¹é…
match response {
    Response::Success { data, .. } if data.len() > 0 => {
        process_data(data).await
    }
    Response::Error { code, message } => {
        handle_error(code, message).await
    }
    Response::Success { data } => {
        // å¤„ç†ç©ºæ•°æ®
        Ok(())
    }
}
```

#### å®ˆå«è¡¨è¾¾å¼å¢å¼º

```rust
// æ›´å¤æ‚çš„å®ˆå«æ¡ä»¶
match request {
    Request::Api { endpoint, params } 
        if endpoint.starts_with("/api/v2/") && params.len() > 0 => {
        handle_v2_api(endpoint, params).await
    }
    Request::Api { endpoint, .. } => {
        handle_legacy_api(endpoint).await
    }
    _ => Err(Error::InvalidRequest),
}
```

### 3. æ”¹è¿›çš„é”™è¯¯å¤„ç†

#### æ–°çš„é”™è¯¯ç±»å‹

```rust
use std::error::Error;
use std::fmt;

// æ”¹è¿›çš„é”™è¯¯trait
#[derive(Debug)]
pub struct MicroserviceError {
    pub kind: ErrorKind,
    pub message: String,
    pub source: Option<Box<dyn Error + Send + Sync>>,
}

#[derive(Debug)]
pub enum ErrorKind {
    Network,
    Database,
    Authentication,
    Validation,
    Internal,
}

impl fmt::Display for MicroserviceError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}: {}", self.kind, self.message)
    }
}

impl Error for MicroserviceError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        self.source.as_ref().map(|e| e.as_ref())
    }
}
```

## ç¼–è¯‘å™¨æ”¹è¿›

### 1. æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦

#### å¢é‡ç¼–è¯‘ä¼˜åŒ–

```rust
// ç¼–è¯‘å™¨ç°åœ¨æ›´å¥½åœ°å¤„ç†å¢é‡ç¼–è¯‘
// ç‰¹åˆ«æ˜¯åœ¨å¤§å‹å¾®æœåŠ¡é¡¹ç›®ä¸­

// Cargo.toml é…ç½®ä¼˜åŒ–
[profile.dev]
incremental = true
debug = 1  # å‡å°‘è°ƒè¯•ä¿¡æ¯ä»¥åŠ å¿«ç¼–è¯‘

[profile.release]
lto = "thin"  # é“¾æ¥æ—¶ä¼˜åŒ–
codegen-units = 1
```

#### å¹¶è¡Œç¼–è¯‘æ”¹è¿›

```rust
// æ›´å¥½çš„å¹¶è¡Œç¼–è¯‘æ”¯æŒ
// ç‰¹åˆ«æ˜¯åœ¨å¤šcrateå·¥ä½œåŒºä¸­

# åœ¨ .cargo/config.toml ä¸­é…ç½®
[build]
jobs = 0  # ä½¿ç”¨æ‰€æœ‰å¯ç”¨CPUæ ¸å¿ƒ
rustc-wrapper = "sccache"  # ä½¿ç”¨ç¼–è¯‘ç¼“å­˜
```

### 2. æ›´å¥½çš„é”™è¯¯ä¿¡æ¯

#### æ”¹è¿›çš„é”™è¯¯è¯Šæ–­

```rust
// Rust 1.90 æä¾›æ›´æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
async fn handle_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;  // æ›´æ¸…æ™°çš„é”™è¯¯æç¤º
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}

// é”™è¯¯ä¿¡æ¯ç¤ºä¾‹ï¼š
// error[E0277]: `?` operator can only be used in a function that returns `Result` or `Option`
//   --> src/handler.rs:15:5
//    |
// 15 |     let data = fetch_data().await?;
//    |               ^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
//    |
//    = help: the trait `FromResidual<Result<Infallible, NetworkError>>` is not implemented for `()`
```

### 3. æ”¹è¿›çš„ç±»å‹æ¨æ–­

#### æ›´å¥½çš„ç±»å‹æ¨æ–­

```rust
// ç¼–è¯‘å™¨ç°åœ¨èƒ½æ›´å¥½åœ°æ¨æ–­å¤æ‚ç±»å‹
use std::collections::HashMap;
use std::sync::Arc;

// ç±»å‹æ¨æ–­æ”¹è¿›
let mut services: HashMap<String, Arc<dyn Service>> = HashMap::new();
services.insert("user".to_string(), Arc::new(UserService::new()));
services.insert("order".to_string(), Arc::new(OrderService::new()));

// ç¼–è¯‘å™¨èƒ½æ­£ç¡®æ¨æ–­ Arc<dyn Service> ç±»å‹
```

## æ ‡å‡†åº“å¢å¼º

### 1. æ–°çš„æ•°æ®ç»“æ„

#### æ”¹è¿›çš„é›†åˆç±»å‹

```rust
use std::collections::{HashMap, BTreeMap, VecDeque};

// æ–°çš„é›†åˆæ–¹æ³•
let mut cache = HashMap::new();
cache.insert("key1", "value1");
cache.insert("key2", "value2");

// æ–°çš„æ‰¹é‡æ“ä½œæ–¹æ³•
let keys: Vec<_> = cache.keys().cloned().collect();
let values: Vec<_> = cache.values().cloned().collect();

// æ”¹è¿›çš„è¿­ä»£å™¨
let pairs: Vec<_> = cache.iter()
    .filter(|(k, _)| k.starts_with("key"))
    .map(|(k, v)| (k.clone(), v.clone()))
    .collect();
```

#### æ–°çš„å¼‚æ­¥å·¥å…·

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// æ–°çš„å¼‚æ­¥å·¥å…·ç±»å‹
pub struct Timeout<T> {
    future: T,
    timeout: Duration,
}

impl<T: Future> Future for Timeout<T> {
    type Output = Result<T::Output, TimeoutError>;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // å®ç°è¶…æ—¶é€»è¾‘
        todo!()
    }
}
```

### 2. æ”¹è¿›çš„å­—ç¬¦ä¸²å¤„ç†

#### æ–°çš„å­—ç¬¦ä¸²æ–¹æ³•

```rust
// æ”¹è¿›çš„å­—ç¬¦ä¸²å¤„ç†
let url = "https://api.example.com/v1/users/123";

// æ–°çš„å­—ç¬¦ä¸²æ–¹æ³•
if url.starts_with("https://") {
    let path = url.strip_prefix("https://").unwrap();
    let parts: Vec<&str> = path.split('/').collect();
    
    // æ›´å¥½çš„å­—ç¬¦ä¸²åˆ†å‰²å’Œè§£æ
    if parts.len() >= 3 {
        let api_version = parts[1];
        let resource = parts[2];
        let id = parts.get(3);
        
        println!("API Version: {}", api_version);
        println!("Resource: {}", resource);
        if let Some(id) = id {
            println!("ID: {}", id);
        }
    }
}
```

## å·¥å…·é“¾æ›´æ–°

### 1. Cargoæ”¹è¿›

#### æ–°çš„Cargoç‰¹æ€§

```toml
# Cargo.toml æ–°ç‰¹æ€§
[package]
name = "microservice"
version = "0.1.0"
edition = "2021"
rust-version = "1.90"  # æŒ‡å®šæœ€ä½Rustç‰ˆæœ¬

[dependencies]
tokio = { version = "1.0", features = ["full"] }
axum = "0.7"
serde = { version = "1.0", features = ["derive"] }

# æ–°çš„ä¾èµ–è§£æå™¨
[package]
resolver = "2"  # ä½¿ç”¨æ–°çš„ä¾èµ–è§£æå™¨

# æ–°çš„å·¥ä½œåŒºé…ç½®
[workspace]
members = ["services/*", "shared/*"]
resolver = "2"
```

#### æ”¹è¿›çš„æ„å»ºè„šæœ¬

```rust
// build.rs æ”¹è¿›
fn main() {
    // æ–°çš„æ„å»ºè„šæœ¬ç‰¹æ€§
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=config/");
    
    // è‡ªåŠ¨ç”Ÿæˆä»£ç 
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile(&["proto/service.proto"], &["proto/"])
        .unwrap();
}
```

### 2. æ”¹è¿›çš„IDEæ”¯æŒ

#### æ›´å¥½çš„è¯­è¨€æœåŠ¡å™¨

```rust
// Rust Analyzer æ”¹è¿›
// æ›´å¥½çš„ä»£ç è¡¥å…¨å’Œé”™è¯¯æ£€æµ‹

use crate::services::{UserService, OrderService};

// æ›´å¥½çš„ç±»å‹æç¤ºå’Œè‡ªåŠ¨è¡¥å…¨
let user_service = UserService::new();
let order_service = OrderService::new();

// IDEç°åœ¨èƒ½æ›´å¥½åœ°ç†è§£å¼‚æ­¥ä»£ç 
async fn process_user_order(user_id: u64, order_id: u64) -> Result<(), Error> {
    let user = user_service.get_user(user_id).await?;
    let order = order_service.get_order(order_id).await?;
    
    // æ›´å¥½çš„ç±»å‹æ¨æ–­å’Œé”™è¯¯æ£€æµ‹
    validate_user_order(&user, &order)?;
    
    Ok(())
}
```

## å¾®æœåŠ¡ç›¸å…³æ”¹è¿›

### 1. å¼‚æ­¥è¿è¡Œæ—¶ä¼˜åŒ–

#### Tokioè¿è¡Œæ—¶æ”¹è¿›

```rust
use tokio::runtime::Runtime;
use tokio::task;

// æ”¹è¿›çš„è¿è¡Œæ—¶é…ç½®
let rt = Runtime::new()?;

// æ›´å¥½çš„ä»»åŠ¡è°ƒåº¦
rt.spawn(async {
    // å¼‚æ­¥ä»»åŠ¡
    process_requests().await;
});

// æ”¹è¿›çš„å¹¶å‘æ§åˆ¶
let handles: Vec<_> = (0..10)
    .map(|i| {
        rt.spawn(async move {
            process_worker(i).await;
        })
    })
    .collect();

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
for handle in handles {
    handle.await?;
}
```

### 2. ç½‘ç»œç¼–ç¨‹æ”¹è¿›

#### æ”¹è¿›çš„HTTPå®¢æˆ·ç«¯

```rust
use reqwest::Client;
use serde_json::json;

// æ”¹è¿›çš„HTTPå®¢æˆ·ç«¯
let client = Client::new();

// æ›´å¥½çš„é”™è¯¯å¤„ç†
async fn call_api(url: &str, data: &serde_json::Value) -> Result<Response, Error> {
    let response = client
        .post(url)
        .json(data)
        .send()
        .await?;
    
    if response.status().is_success() {
        let result: Response = response.json().await?;
        Ok(result)
    } else {
        Err(Error::ApiError(response.status()))
    }
}
```

### 3. åºåˆ—åŒ–æ”¹è¿›

#### æ›´å¥½çš„JSONå¤„ç†

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

#[derive(Serialize, Deserialize)]
struct ApiResponse<T> {
    success: bool,
    data: Option<T>,
    error: Option<String>,
}

// æ”¹è¿›çš„åºåˆ—åŒ–
impl<T> ApiResponse<T> {
    fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
        }
    }
    
    fn error(message: String) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(message),
        }
    }
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å†…å­˜åˆ†é…ä¼˜åŒ–

#### æ”¹è¿›çš„å†…å­˜ç®¡ç†

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

// è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨ï¼ˆç¤ºä¾‹ï¼‰
struct MicroserviceAllocator {
    allocated: AtomicUsize,
}

unsafe impl GlobalAlloc for MicroserviceAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        self.allocated.fetch_add(size, Ordering::Relaxed);
        System.alloc(layout)
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        let size = layout.size();
        self.allocated.fetch_sub(size, Ordering::Relaxed);
        System.dealloc(ptr, layout);
    }
}

#[global_allocator]
static ALLOCATOR: MicroserviceAllocator = MicroserviceAllocator {
    allocated: AtomicUsize::new(0),
};
```

### 2. å¹¶å‘æ€§èƒ½æ”¹è¿›

#### æ”¹è¿›çš„å¹¶å‘åŸè¯­

```rust
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock, Semaphore};

// æ”¹è¿›çš„å¹¶å‘æ§åˆ¶
pub struct ServiceManager {
    services: Arc<RwLock<HashMap<String, Box<dyn Service>>>>,
    semaphore: Arc<Semaphore>,
}

impl ServiceManager {
    pub async fn register_service(&self, name: String, service: Box<dyn Service>) {
        let _permit = self.semaphore.acquire().await.unwrap();
        let mut services = self.services.write().await;
        services.insert(name, service);
    }
    
    pub async fn get_service(&self, name: &str) -> Option<Box<dyn Service>> {
        let services = self.services.read().await;
        services.get(name).cloned()
    }
}
```

## å‘åå…¼å®¹æ€§

### 1. è¿ç§»æŒ‡å—

#### ä»Rust 1.89è¿ç§»

```rust
// Rust 1.89 ä»£ç 
use std::future::Future;

async fn old_style() -> Result<String, Error> {
    let result = some_async_function().await?;
    Ok(result)
}

// Rust 1.90 æ”¹è¿›ï¼ˆå‘åå…¼å®¹ï¼‰
use std::future::Future;

async fn new_style() -> Result<String, Error> {
    let result = some_async_function().await?;
    Ok(result)
}
```

### 2. åºŸå¼ƒè­¦å‘Š

#### å¤„ç†åºŸå¼ƒè­¦å‘Š

```rust
// å¤„ç†æ–°çš„åºŸå¼ƒè­¦å‘Š
#[allow(deprecated)]
fn use_deprecated_function() {
    // ä½¿ç”¨å³å°†åºŸå¼ƒçš„å‡½æ•°
    deprecated_function();
}

// ä½¿ç”¨æ–°çš„æ›¿ä»£æ–¹æ¡ˆ
fn use_new_function() {
    new_function();
}
```

## æ€»ç»“

Rust 1.90 ä¸ºå¾®æœåŠ¡å¼€å‘å¸¦æ¥äº†å¤šé¡¹é‡è¦æ”¹è¿›ï¼š

1. **å¼‚æ­¥ç¼–ç¨‹å¢å¼º**: æ›´å¥½çš„async/awaitæ”¯æŒå’Œæ€§èƒ½
2. **ç¼–è¯‘å™¨ä¼˜åŒ–**: æ›´å¿«çš„ç¼–è¯‘é€Ÿåº¦å’Œæ›´å¥½çš„é”™è¯¯ä¿¡æ¯
3. **æ ‡å‡†åº“æ‰©å±•**: æ–°çš„å®ç”¨å·¥å…·å’Œæ•°æ®ç»“æ„
4. **å·¥å…·é“¾æ”¹è¿›**: æ›´å¥½çš„IDEæ”¯æŒå’Œå¼€å‘ä½“éªŒ
5. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜ç®¡ç†å’Œå¹¶å‘æ€§èƒ½æ”¹è¿›

è¿™äº›æ”¹è¿›ä½¿å¾—Ruståœ¨å¾®æœåŠ¡å¼€å‘ä¸­æ›´åŠ é«˜æ•ˆå’Œå¯é ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½ã€å®‰å…¨çš„å¾®æœåŠ¡ç³»ç»Ÿæä¾›äº†æ›´å¥½çš„åŸºç¡€ã€‚
