# 2.1 Rust 1.90 语言特性

## 📋 目录

- [Rust 1.90 发布概述](#rust-190-发布概述)
- [核心语言特性](#核心语言特性)
- [编译器改进](#编译器改进)
- [标准库增强](#标准库增强)
- [工具链更新](#工具链更新)
- [微服务相关改进](#微服务相关改进)
- [性能优化](#性能优化)
- [向后兼容性](#向后兼容性)

## Rust 1.90 发布概述

Rust 1.90 于2025年9月发布，带来了多项重要的语言特性改进、性能优化和工具链增强。
这个版本特别关注了异步编程、内存安全和开发体验的提升，为微服务开发提供了更好的支持。

### 主要亮点

- **异步编程增强**: 改进的async/await语法和性能
- **内存安全改进**: 更严格的借用检查器
- **编译器优化**: 更快的编译速度和更好的错误信息
- **标准库扩展**: 新的实用工具和数据结构
- **工具链改进**: 更好的IDE支持和调试体验

## 核心语言特性

### 1. 改进的异步编程

#### 新的async语法糖

```rust
// Rust 1.90 之前
async fn process_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}

// Rust 1.90 新语法
async fn process_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}
```

#### 异步迭代器改进

```rust
use std::future::Future;
use std::pin::Pin;

// 新的异步迭代器trait
trait AsyncIterator {
    type Item;
    type Future: Future<Output = Option<Self::Item>>;
    
    fn next(&mut self) -> Self::Future;
}

// 异步流处理
async fn process_stream<T: AsyncIterator>(mut stream: T) 
where 
    T::Item: Send,
{
    while let Some(item) = stream.next().await {
        process_item(item).await;
    }
}
```

### 2. 增强的模式匹配

#### 新的匹配语法

```rust
// 改进的模式匹配
match response {
    Response::Success { data, .. } if data.len() > 0 => {
        process_data(data).await
    }
    Response::Error { code, message } => {
        handle_error(code, message).await
    }
    Response::Success { data } => {
        // 处理空数据
        Ok(())
    }
}
```

#### 守卫表达式增强

```rust
// 更复杂的守卫条件
match request {
    Request::Api { endpoint, params } 
        if endpoint.starts_with("/api/v2/") && params.len() > 0 => {
        handle_v2_api(endpoint, params).await
    }
    Request::Api { endpoint, .. } => {
        handle_legacy_api(endpoint).await
    }
    _ => Err(Error::InvalidRequest),
}
```

### 3. 改进的错误处理

#### 新的错误类型

```rust
use std::error::Error;
use std::fmt;

// 改进的错误trait
#[derive(Debug)]
pub struct MicroserviceError {
    pub kind: ErrorKind,
    pub message: String,
    pub source: Option<Box<dyn Error + Send + Sync>>,
}

#[derive(Debug)]
pub enum ErrorKind {
    Network,
    Database,
    Authentication,
    Validation,
    Internal,
}

impl fmt::Display for MicroserviceError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}: {}", self.kind, self.message)
    }
}

impl Error for MicroserviceError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        self.source.as_ref().map(|e| e.as_ref())
    }
}
```

## 编译器改进

### 1. 更快的编译速度

#### 增量编译优化

```rust
// 编译器现在更好地处理增量编译
// 特别是在大型微服务项目中

// Cargo.toml 配置优化
[profile.dev]
incremental = true
debug = 1  # 减少调试信息以加快编译

[profile.release]
lto = "thin"  # 链接时优化
codegen-units = 1
```

#### 并行编译改进

```rust
// 更好的并行编译支持
// 特别是在多crate工作区中

# 在 .cargo/config.toml 中配置
[build]
jobs = 0  # 使用所有可用CPU核心
rustc-wrapper = "sccache"  # 使用编译缓存
```

### 2. 更好的错误信息

#### 改进的错误诊断

```rust
// Rust 1.90 提供更清晰的错误信息
async fn handle_request(req: Request) -> Result<Response, Error> {
    let data = fetch_data().await?;  // 更清晰的错误提示
    let processed = process_data(data).await?;
    Ok(Response::new(processed))
}

// 错误信息示例：
// error[E0277]: `?` operator can only be used in a function that returns `Result` or `Option`
//   --> src/handler.rs:15:5
//    |
// 15 |     let data = fetch_data().await?;
//    |               ^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
//    |
//    = help: the trait `FromResidual<Result<Infallible, NetworkError>>` is not implemented for `()`
```

### 3. 改进的类型推断

#### 更好的类型推断

```rust
// 编译器现在能更好地推断复杂类型
use std::collections::HashMap;
use std::sync::Arc;

// 类型推断改进
let mut services: HashMap<String, Arc<dyn Service>> = HashMap::new();
services.insert("user".to_string(), Arc::new(UserService::new()));
services.insert("order".to_string(), Arc::new(OrderService::new()));

// 编译器能正确推断 Arc<dyn Service> 类型
```

## 标准库增强

### 1. 新的数据结构

#### 改进的集合类型

```rust
use std::collections::{HashMap, BTreeMap, VecDeque};

// 新的集合方法
let mut cache = HashMap::new();
cache.insert("key1", "value1");
cache.insert("key2", "value2");

// 新的批量操作方法
let keys: Vec<_> = cache.keys().cloned().collect();
let values: Vec<_> = cache.values().cloned().collect();

// 改进的迭代器
let pairs: Vec<_> = cache.iter()
    .filter(|(k, _)| k.starts_with("key"))
    .map(|(k, v)| (k.clone(), v.clone()))
    .collect();
```

#### 新的异步工具

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// 新的异步工具类型
pub struct Timeout<T> {
    future: T,
    timeout: Duration,
}

impl<T: Future> Future for Timeout<T> {
    type Output = Result<T::Output, TimeoutError>;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // 实现超时逻辑
        todo!()
    }
}
```

### 2. 改进的字符串处理

#### 新的字符串方法

```rust
// 改进的字符串处理
let url = "https://api.example.com/v1/users/123";

// 新的字符串方法
if url.starts_with("https://") {
    let path = url.strip_prefix("https://").unwrap();
    let parts: Vec<&str> = path.split('/').collect();
    
    // 更好的字符串分割和解析
    if parts.len() >= 3 {
        let api_version = parts[1];
        let resource = parts[2];
        let id = parts.get(3);
        
        println!("API Version: {}", api_version);
        println!("Resource: {}", resource);
        if let Some(id) = id {
            println!("ID: {}", id);
        }
    }
}
```

## 工具链更新

### 1. Cargo改进

#### 新的Cargo特性

```toml
# Cargo.toml 新特性
[package]
name = "microservice"
version = "0.1.0"
edition = "2021"
rust-version = "1.90"  # 指定最低Rust版本

[dependencies]
tokio = { version = "1.0", features = ["full"] }
axum = "0.7"
serde = { version = "1.0", features = ["derive"] }

# 新的依赖解析器
[package]
resolver = "2"  # 使用新的依赖解析器

# 新的工作区配置
[workspace]
members = ["services/*", "shared/*"]
resolver = "2"
```

#### 改进的构建脚本

```rust
// build.rs 改进
fn main() {
    // 新的构建脚本特性
    println!("cargo:rerun-if-changed=proto/");
    println!("cargo:rerun-if-changed=config/");
    
    // 自动生成代码
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile(&["proto/service.proto"], &["proto/"])
        .unwrap();
}
```

### 2. 改进的IDE支持

#### 更好的语言服务器

```rust
// Rust Analyzer 改进
// 更好的代码补全和错误检测

use crate::services::{UserService, OrderService};

// 更好的类型提示和自动补全
let user_service = UserService::new();
let order_service = OrderService::new();

// IDE现在能更好地理解异步代码
async fn process_user_order(user_id: u64, order_id: u64) -> Result<(), Error> {
    let user = user_service.get_user(user_id).await?;
    let order = order_service.get_order(order_id).await?;
    
    // 更好的类型推断和错误检测
    validate_user_order(&user, &order)?;
    
    Ok(())
}
```

## 微服务相关改进

### 1. 异步运行时优化

#### Tokio运行时改进

```rust
use tokio::runtime::Runtime;
use tokio::task;

// 改进的运行时配置
let rt = Runtime::new()?;

// 更好的任务调度
rt.spawn(async {
    // 异步任务
    process_requests().await;
});

// 改进的并发控制
let handles: Vec<_> = (0..10)
    .map(|i| {
        rt.spawn(async move {
            process_worker(i).await;
        })
    })
    .collect();

// 等待所有任务完成
for handle in handles {
    handle.await?;
}
```

### 2. 网络编程改进

#### 改进的HTTP客户端

```rust
use reqwest::Client;
use serde_json::json;

// 改进的HTTP客户端
let client = Client::new();

// 更好的错误处理
async fn call_api(url: &str, data: &serde_json::Value) -> Result<Response, Error> {
    let response = client
        .post(url)
        .json(data)
        .send()
        .await?;
    
    if response.status().is_success() {
        let result: Response = response.json().await?;
        Ok(result)
    } else {
        Err(Error::ApiError(response.status()))
    }
}
```

### 3. 序列化改进

#### 更好的JSON处理

```rust
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

#[derive(Serialize, Deserialize)]
struct ApiResponse<T> {
    success: bool,
    data: Option<T>,
    error: Option<String>,
}

// 改进的序列化
impl<T> ApiResponse<T> {
    fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
        }
    }
    
    fn error(message: String) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(message),
        }
    }
}
```

## 性能优化

### 1. 内存分配优化

#### 改进的内存管理

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

// 自定义内存分配器（示例）
struct MicroserviceAllocator {
    allocated: AtomicUsize,
}

unsafe impl GlobalAlloc for MicroserviceAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        self.allocated.fetch_add(size, Ordering::Relaxed);
        System.alloc(layout)
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        let size = layout.size();
        self.allocated.fetch_sub(size, Ordering::Relaxed);
        System.dealloc(ptr, layout);
    }
}

#[global_allocator]
static ALLOCATOR: MicroserviceAllocator = MicroserviceAllocator {
    allocated: AtomicUsize::new(0),
};
```

### 2. 并发性能改进

#### 改进的并发原语

```rust
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock, Semaphore};

// 改进的并发控制
pub struct ServiceManager {
    services: Arc<RwLock<HashMap<String, Box<dyn Service>>>>,
    semaphore: Arc<Semaphore>,
}

impl ServiceManager {
    pub async fn register_service(&self, name: String, service: Box<dyn Service>) {
        let _permit = self.semaphore.acquire().await.unwrap();
        let mut services = self.services.write().await;
        services.insert(name, service);
    }
    
    pub async fn get_service(&self, name: &str) -> Option<Box<dyn Service>> {
        let services = self.services.read().await;
        services.get(name).cloned()
    }
}
```

## 向后兼容性

### 1. 迁移指南

#### 从Rust 1.89迁移

```rust
// Rust 1.89 代码
use std::future::Future;

async fn old_style() -> Result<String, Error> {
    let result = some_async_function().await?;
    Ok(result)
}

// Rust 1.90 改进（向后兼容）
use std::future::Future;

async fn new_style() -> Result<String, Error> {
    let result = some_async_function().await?;
    Ok(result)
}
```

### 2. 废弃警告

#### 处理废弃警告

```rust
// 处理新的废弃警告
#[allow(deprecated)]
fn use_deprecated_function() {
    // 使用即将废弃的函数
    deprecated_function();
}

// 使用新的替代方案
fn use_new_function() {
    new_function();
}
```

## 总结

Rust 1.90 为微服务开发带来了多项重要改进：

1. **异步编程增强**: 更好的async/await支持和性能
2. **编译器优化**: 更快的编译速度和更好的错误信息
3. **标准库扩展**: 新的实用工具和数据结构
4. **工具链改进**: 更好的IDE支持和开发体验
5. **性能优化**: 内存管理和并发性能改进

这些改进使得Rust在微服务开发中更加高效和可靠，为构建高性能、安全的微服务系统提供了更好的基础。
