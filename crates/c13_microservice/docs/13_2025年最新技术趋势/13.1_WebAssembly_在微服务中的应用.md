# 13.1 WebAssembly åœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨

## ğŸ“‹ ç›®å½•

- [WebAssembly æ¦‚è¿°](#webassembly-æ¦‚è¿°)
- [WASM åœ¨å¾®æœåŠ¡ä¸­çš„ä¼˜åŠ¿](#wasm-åœ¨å¾®æœåŠ¡ä¸­çš„ä¼˜åŠ¿)
- [Rust ä¸ WebAssembly](#rust-ä¸-webassembly)
- [å¾®æœåŠ¡ä¸­çš„ WASM åº”ç”¨åœºæ™¯](#å¾®æœåŠ¡ä¸­çš„-wasm-åº”ç”¨åœºæ™¯)
- [æŠ€æœ¯å®ç°](#æŠ€æœ¯å®ç°)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [éƒ¨ç½²ç­–ç•¥](#éƒ¨ç½²ç­–ç•¥)
- [å®é™…æ¡ˆä¾‹](#å®é™…æ¡ˆä¾‹)
- [æœªæ¥å‘å±•è¶‹åŠ¿](#æœªæ¥å‘å±•è¶‹åŠ¿)

## WebAssembly æ¦‚è¿°

WebAssembly (WASM) æ˜¯ä¸€ç§ä½çº§çš„äºŒè¿›åˆ¶æŒ‡ä»¤æ ¼å¼ï¼Œè®¾è®¡ç”¨äºåœ¨Webæµè§ˆå™¨ä¸­é«˜æ•ˆæ‰§è¡Œä»£ç ã€‚
è¿‘å¹´æ¥ï¼ŒWASM å·²ç»æ‰©å±•åˆ°æµè§ˆå™¨ä¹‹å¤–ï¼Œæˆä¸ºäº‘åŸç”Ÿåº”ç”¨ã€è¾¹ç¼˜è®¡ç®—å’Œå¾®æœåŠ¡æ¶æ„ä¸­çš„é‡è¦æŠ€æœ¯ã€‚

### æ ¸å¿ƒç‰¹æ€§

- **é«˜æ€§èƒ½**: æ¥è¿‘åŸç”Ÿä»£ç çš„æ‰§è¡Œé€Ÿåº¦
- **å®‰å…¨æ€§**: æ²™ç®±æ‰§è¡Œç¯å¢ƒï¼Œå†…å­˜å®‰å…¨
- **è·¨å¹³å°**: ä¸€æ¬¡ç¼–è¯‘ï¼Œåˆ°å¤„è¿è¡Œ
- **è¯­è¨€æ— å…³**: æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€
- **è½»é‡çº§**: å°çš„äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°
- **å¿«é€Ÿå¯åŠ¨**: æ¯«ç§’çº§å¯åŠ¨æ—¶é—´

### WASM è¿è¡Œæ—¶

#### ä¸»æµè¿è¡Œæ—¶å¯¹æ¯”

| è¿è¡Œæ—¶ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|--------|------|----------|
| Wasmtime | é«˜æ€§èƒ½ï¼Œæ ‡å‡†å…¼å®¹ | ç”Ÿäº§ç¯å¢ƒ |
| Wasmer | å¤šè¯­è¨€æ”¯æŒï¼Œæ’ä»¶ç³»ç»Ÿ | å¼€å‘ç¯å¢ƒ |
| WasmEdge | è¾¹ç¼˜è®¡ç®—ä¼˜åŒ– | è¾¹ç¼˜æœåŠ¡ |
| WAMR | è½»é‡çº§ï¼ŒåµŒå…¥å¼ | IoTè®¾å¤‡ |

## WASM åœ¨å¾®æœåŠ¡ä¸­çš„ä¼˜åŠ¿

### 1. æ€§èƒ½ä¼˜åŠ¿

#### å¯åŠ¨æ—¶é—´å¯¹æ¯”

```rust
// ä¼ ç»Ÿå¾®æœåŠ¡å¯åŠ¨æ—¶é—´: 2-5ç§’
// WASMå¾®æœåŠ¡å¯åŠ¨æ—¶é—´: 10-50æ¯«ç§’

use wasmtime::*;

// WASMæ¨¡å—åŠ è½½å’Œå®ä¾‹åŒ–
async fn load_wasm_service(wasm_bytes: &[u8]) -> Result<Instance, Error> {
    let engine = Engine::default();
    let module = Module::from_binary(&engine, wasm_bytes)?;
    let store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[])?;
    Ok(instance)
}

// å¿«é€Ÿå¯åŠ¨ç¤ºä¾‹
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let wasm_bytes = include_bytes!("service.wasm");
    let instance = load_wasm_service(wasm_bytes).await?;
    
    // æ¯«ç§’çº§å¯åŠ¨å®Œæˆ
    println!("WASM service started in {:?}", start.elapsed());
    Ok(())
}
```

### 2. èµ„æºæ•ˆç‡

#### å†…å­˜ä½¿ç”¨å¯¹æ¯”

```rust
// ä¼ ç»ŸRustå¾®æœåŠ¡: 10-50MB å†…å­˜
// WASMå¾®æœåŠ¡: 1-5MB å†…å­˜

use wasmtime::*;

pub struct WasmMicroservice {
    instance: Instance,
    store: Store<()>,
}

impl WasmMicroservice {
    pub fn new(wasm_bytes: &[u8]) -> Result<Self, Error> {
        let engine = Engine::default();
        let module = Module::from_binary(&engine, wasm_bytes)?;
        let store = Store::new(&engine, ());
        let instance = Instance::new(&mut store, &module, &[])?;
        
        Ok(Self { instance, store })
    }
    
    pub async fn handle_request(&mut self, request: &[u8]) -> Result<Vec<u8>, Error> {
        // ä½å†…å­˜å ç”¨çš„è¯·æ±‚å¤„ç†
        let func = self.instance
            .get_typed_func::<i32, i32>(&mut self.store, "handle_request")?;
        
        let result = func.call(&mut self.store, request.as_ptr() as i32)?;
        Ok(vec![result as u8])
    }
}
```

### 3. å®‰å…¨æ€§

#### æ²™ç®±æ‰§è¡Œç¯å¢ƒ

```rust
use wasmtime::*;

// é…ç½®WASMå®‰å…¨ç­–ç•¥
pub fn create_secure_wasm_engine() -> Engine {
    let mut config = Config::new();
    
    // å¯ç”¨å†…å­˜é™åˆ¶
    config.max_memory_size(16 * 1024 * 1024); // 16MBé™åˆ¶
    
    // å¯ç”¨ç‡ƒæ–™é™åˆ¶ï¼ˆé˜²æ­¢æ— é™å¾ªç¯ï¼‰
    config.consume_fuel(true);
    
    // ç¦ç”¨æ–‡ä»¶ç³»ç»Ÿè®¿é—®
    config.wasm_component_model(false);
    
    Engine::new(&config).unwrap()
}

// å®‰å…¨çš„WASMæœåŠ¡æ‰§è¡Œ
pub struct SecureWasmService {
    engine: Engine,
    store: Store<()>,
}

impl SecureWasmService {
    pub fn new() -> Self {
        let engine = create_secure_wasm_engine();
        let store = Store::new(&engine, ());
        
        Self { engine, store }
    }
    
    pub async fn execute_wasm(&mut self, wasm_bytes: &[u8], fuel: u64) -> Result<(), Error> {
        // è®¾ç½®ç‡ƒæ–™é™åˆ¶
        self.store.add_fuel(fuel)?;
        
        let module = Module::from_binary(&self.engine, wasm_bytes)?;
        let instance = Instance::new(&mut self.store, &module, &[])?;
        
        // åœ¨å®‰å…¨ç¯å¢ƒä¸­æ‰§è¡Œ
        let func = instance.get_typed_func::<(), ()>(&mut self.store, "main")?;
        func.call(&mut self.store, ())?;
        
        Ok(())
    }
}
```

## Rust ä¸ WebAssembly

### 1. ç¼–è¯‘åˆ° WASM

#### é¡¹ç›®é…ç½®

```toml
# Cargo.toml
[package]
name = "wasm-microservice"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
serde = { version = "1.0", features = ["derive"] }
serde-wasm-bindgen = "0.6"

[dependencies.web-sys]
version = "0.3"
features = [
  "console",
  "Request",
  "Response",
  "Headers",
]
```

#### Rust ä»£ç ç¼–è¯‘åˆ° WASM

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct Request {
    pub method: String,
    pub path: String,
    pub body: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct Response {
    pub status: u16,
    pub body: String,
    pub headers: std::collections::HashMap<String, String>,
}

#[wasm_bindgen]
pub struct WasmMicroservice {
    config: ServiceConfig,
}

#[wasm_bindgen]
impl WasmMicroservice {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        Self {
            config: ServiceConfig::default(),
        }
    }
    
    #[wasm_bindgen]
    pub fn handle_request(&self, request_json: &str) -> String {
        let request: Request = serde_json::from_str(request_json)
            .expect("Failed to parse request");
        
        let response = self.process_request(request);
        serde_json::to_string(&response)
            .expect("Failed to serialize response")
    }
    
    fn process_request(&self, request: Request) -> Response {
        match request.path.as_str() {
            "/health" => Response {
                status: 200,
                body: "OK".to_string(),
                headers: std::collections::HashMap::new(),
            },
            "/api/users" => {
                // å¤„ç†ç”¨æˆ·APIè¯·æ±‚
                Response {
                    status: 200,
                    body: r#"{"users": []}"#.to_string(),
                    headers: std::collections::HashMap::new(),
                }
            }
            _ => Response {
                status: 404,
                body: "Not Found".to_string(),
                headers: std::collections::HashMap::new(),
            }
        }
    }
}

#[derive(Default)]
struct ServiceConfig {
    timeout: u64,
    max_connections: u32,
}
```

### 2. WASM ä¸ä¸»æœºäº¤äº’

#### ä¸»æœºå‡½æ•°å¯¼å…¥

```rust
// å®šä¹‰ä¸»æœºå‡½æ•°æ¥å£
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
    
    #[wasm_bindgen(js_name = fetch)]
    async fn fetch_request(url: &str, options: &str) -> JsValue;
}

// åœ¨WASMä¸­ä½¿ç”¨ä¸»æœºå‡½æ•°
impl WasmMicroservice {
    pub async fn call_external_api(&self, url: &str) -> Result<String, JsValue> {
        let options = r#"{"method": "GET"}"#;
        let response = fetch_request(url, options).await?;
        
        // å¤„ç†å“åº”
        Ok("External API response".to_string())
    }
    
    pub fn log_message(&self, message: &str) {
        log(&format!("WASM Service: {}", message));
    }
}
```

## å¾®æœåŠ¡ä¸­çš„ WASM åº”ç”¨åœºæ™¯

### 1. è¾¹ç¼˜è®¡ç®—æœåŠ¡

#### è¾¹ç¼˜WASMæœåŠ¡

```rust
use wasmtime::*;

pub struct EdgeWasmService {
    instances: std::collections::HashMap<String, Instance>,
    store: Store<()>,
}

impl EdgeWasmService {
    pub fn new() -> Self {
        let engine = Engine::default();
        let store = Store::new(&engine, ());
        
        Self {
            instances: std::collections::HashMap::new(),
            store,
        }
    }
    
    pub async fn deploy_service(&mut self, service_id: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let module = Module::from_binary(&self.store.engine(), wasm_bytes)?;
        let instance = Instance::new(&mut self.store, &module, &[])?;
        
        self.instances.insert(service_id.to_string(), instance);
        Ok(())
    }
    
    pub async fn handle_edge_request(&mut self, service_id: &str, request: &[u8]) -> Result<Vec<u8>, Error> {
        if let Some(instance) = self.instances.get(&service_id.to_string()) {
            let func = instance.get_typed_func::<i32, i32>(&mut self.store, "handle_request")?;
            let result = func.call(&mut self.store, request.as_ptr() as i32)?;
            Ok(vec![result as u8])
        } else {
            Err(Error::msg("Service not found"))
        }
    }
}
```

### 2. æ’ä»¶ç³»ç»Ÿ

#### åŠ¨æ€æ’ä»¶åŠ è½½

```rust
use wasmtime::*;

pub struct PluginManager {
    plugins: std::collections::HashMap<String, Plugin>,
    engine: Engine,
}

pub struct Plugin {
    instance: Instance,
    store: Store<()>,
}

impl PluginManager {
    pub fn new() -> Self {
        Self {
            plugins: std::collections::HashMap::new(),
            engine: Engine::default(),
        }
    }
    
    pub async fn load_plugin(&mut self, name: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let module = Module::from_binary(&self.engine, wasm_bytes)?;
        let store = Store::new(&self.engine, ());
        let instance = Instance::new(&mut store, &module, &[])?;
        
        let plugin = Plugin { instance, store };
        self.plugins.insert(name.to_string(), plugin);
        
        Ok(())
    }
    
    pub async fn execute_plugin(&mut self, name: &str, input: &[u8]) -> Result<Vec<u8>, Error> {
        if let Some(plugin) = self.plugins.get_mut(name) {
            let func = plugin.instance.get_typed_func::<i32, i32>(&mut plugin.store, "process")?;
            let result = func.call(&mut plugin.store, input.as_ptr() as i32)?;
            Ok(vec![result as u8])
        } else {
            Err(Error::msg("Plugin not found"))
        }
    }
}
```

### 3. æ•°æ®å¤„ç†ç®¡é“

#### WASMæ•°æ®å¤„ç†

```rust
use wasmtime::*;

pub struct DataProcessor {
    processors: std::collections::HashMap<String, Instance>,
    store: Store<()>,
}

impl DataProcessor {
    pub fn new() -> Self {
        let engine = Engine::default();
        let store = Store::new(&engine, ());
        
        Self {
            processors: std::collections::HashMap::new(),
            store,
        }
    }
    
    pub async fn add_processor(&mut self, name: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let module = Module::from_binary(&self.store.engine(), wasm_bytes)?;
        let instance = Instance::new(&mut self.store, &module, &[])?;
        
        self.processors.insert(name.to_string(), instance);
        Ok(())
    }
    
    pub async fn process_data(&mut self, processor_name: &str, data: &[u8]) -> Result<Vec<u8>, Error> {
        if let Some(processor) = self.processors.get(&processor_name.to_string()) {
            let func = processor.get_typed_func::<i32, i32>(&mut self.store, "process")?;
            let result = func.call(&mut self.store, data.as_ptr() as i32)?;
            Ok(vec![result as u8])
        } else {
            Err(Error::msg("Processor not found"))
        }
    }
    
    pub async fn process_pipeline(&mut self, pipeline: &[String], data: &[u8]) -> Result<Vec<u8>, Error> {
        let mut current_data = data.to_vec();
        
        for processor_name in pipeline {
            current_data = self.process_data(processor_name, &current_data).await?;
        }
        
        Ok(current_data)
    }
}
```

## æŠ€æœ¯å®ç°

### 1. WASM è¿è¡Œæ—¶é›†æˆ

#### é›†æˆåˆ°å¾®æœåŠ¡æ¡†æ¶

```rust
use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::post,
    Router,
};
use wasmtime::*;

pub struct WasmMicroserviceState {
    wasm_engine: Engine,
    wasm_instances: std::collections::HashMap<String, Instance>,
    store: Store<()>,
}

#[derive(serde::Deserialize)]
pub struct WasmRequest {
    pub service_id: String,
    pub data: String,
}

#[derive(serde::Serialize)]
pub struct WasmResponse {
    pub result: String,
    pub execution_time: u64,
}

// WASMæœåŠ¡ç«¯ç‚¹
async fn handle_wasm_request(
    State(state): State<WasmMicroserviceState>,
    Json(request): Json<WasmRequest>,
) -> Result<Json<WasmResponse>, StatusCode> {
    let start = std::time::Instant::now();
    
    if let Some(instance) = state.wasm_instances.get(&request.service_id) {
        // æ‰§è¡ŒWASMå‡½æ•°
        let func = instance.get_typed_func::<i32, i32>(&mut state.store, "handle_request")
            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        
        let result = func.call(&mut state.store, request.data.as_ptr() as i32)
            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        
        let execution_time = start.elapsed().as_millis() as u64;
        
        Ok(Json(WasmResponse {
            result: format!("Result: {}", result),
            execution_time,
        }))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

// åˆ›å»ºWASMå¾®æœåŠ¡è·¯ç”±
pub fn create_wasm_router() -> Router<WasmMicroserviceState> {
    Router::new()
        .route("/wasm/execute", post(handle_wasm_request))
}
```

### 2. åŠ¨æ€WASMåŠ è½½

#### è¿è¡Œæ—¶WASMéƒ¨ç½²

```rust
use wasmtime::*;

pub struct DynamicWasmLoader {
    engine: Engine,
    modules: std::collections::HashMap<String, Module>,
    instances: std::collections::HashMap<String, Instance>,
    store: Store<()>,
}

impl DynamicWasmLoader {
    pub fn new() -> Self {
        let engine = Engine::default();
        let store = Store::new(&engine, ());
        
        Self {
            engine,
            modules: std::collections::HashMap::new(),
            instances: std::collections::HashMap::new(),
            store,
        }
    }
    
    pub async fn deploy_wasm_service(&mut self, service_id: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        // ç¼–è¯‘WASMæ¨¡å—
        let module = Module::from_binary(&self.engine, wasm_bytes)?;
        self.modules.insert(service_id.to_string(), module);
        
        // åˆ›å»ºå®ä¾‹
        let module = self.modules.get(service_id).unwrap();
        let instance = Instance::new(&mut self.store, module, &[])?;
        self.instances.insert(service_id.to_string(), instance);
        
        Ok(())
    }
    
    pub async fn update_wasm_service(&mut self, service_id: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        // çƒ­æ›´æ–°WASMæœåŠ¡
        self.deploy_wasm_service(service_id, wasm_bytes).await
    }
    
    pub async fn remove_wasm_service(&mut self, service_id: &str) -> Result<(), Error> {
        self.modules.remove(service_id);
        self.instances.remove(service_id);
        Ok(())
    }
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. WASM ä¼˜åŒ–ç­–ç•¥

#### ç¼–è¯‘ä¼˜åŒ–

```rust
// ä¼˜åŒ–WASMç¼–è¯‘é…ç½®
pub fn create_optimized_engine() -> Engine {
    let mut config = Config::new();
    
    // å¯ç”¨ä¼˜åŒ–
    config.cranelift_opt_level(OptLevel::Speed);
    
    // å¯ç”¨å¹¶è¡Œç¼–è¯‘
    config.parallel_compilation(true);
    
    // å¯ç”¨ç¼“å­˜
    config.cache_config_load_default()?;
    
    Engine::new(&config).unwrap()
}

// é¢„ç¼–è¯‘WASMæ¨¡å—
pub struct PrecompiledWasmService {
    engine: Engine,
    compiled_modules: std::collections::HashMap<String, Module>,
}

impl PrecompiledWasmService {
    pub fn new() -> Self {
        Self {
            engine: create_optimized_engine(),
            compiled_modules: std::collections::HashMap::new(),
        }
    }
    
    pub async fn precompile_module(&mut self, name: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let module = Module::from_binary(&self.engine, wasm_bytes)?;
        self.compiled_modules.insert(name.to_string(), module);
        Ok(())
    }
    
    pub async fn get_fast_instance(&mut self, name: &str) -> Result<Instance, Error> {
        if let Some(module) = self.compiled_modules.get(name) {
            let store = Store::new(&self.engine, ());
            let instance = Instance::new(&mut store, module, &[])?;
            Ok(instance)
        } else {
            Err(Error::msg("Module not found"))
        }
    }
}
```

### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–

#### WASMå†…å­˜æ± 

```rust
use wasmtime::*;

pub struct WasmMemoryPool {
    pools: std::collections::HashMap<usize, Vec<Memory>>,
    engine: Engine,
}

impl WasmMemoryPool {
    pub fn new() -> Self {
        Self {
            pools: std::collections::HashMap::new(),
            engine: Engine::default(),
        }
    }
    
    pub fn get_memory(&mut self, size: usize) -> Memory {
        if let Some(pool) = self.pools.get_mut(&size) {
            if let Some(memory) = pool.pop() {
                return memory;
            }
        }
        
        // åˆ›å»ºæ–°çš„å†…å­˜å®ä¾‹
        let store = Store::new(&self.engine, ());
        let memory_type = MemoryType::new(1, Some(size as u32));
        Memory::new(&mut store, memory_type).unwrap()
    }
    
    pub fn return_memory(&mut self, size: usize, memory: Memory) {
        self.pools.entry(size).or_insert_with(Vec::new).push(memory);
    }
}
```

## éƒ¨ç½²ç­–ç•¥

### 1. å®¹å™¨åŒ–éƒ¨ç½²

#### Dockerfile for WASM

```dockerfile
# å¤šé˜¶æ®µæ„å»ºWASMå¾®æœåŠ¡
FROM rust:1.90-slim as builder

# å®‰è£…WASMå·¥å…·é“¾
RUN rustup target add wasm32-unknown-unknown
RUN cargo install wasm-pack

WORKDIR /app
COPY . .

# ç¼–è¯‘WASMæ¨¡å—
RUN wasm-pack build --target web --out-dir pkg

# è¿è¡Œæ—¶é•œåƒ
FROM wasmtime/wasmtime:latest

COPY --from=builder /app/pkg/*.wasm /app/
COPY --from=builder /app/target/release/wasm-microservice /app/

EXPOSE 8080
CMD ["/app/wasm-microservice"]
```

### 2. Kuberneteséƒ¨ç½²

#### WASMæœåŠ¡éƒ¨ç½²é…ç½®

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wasm-microservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: wasm-microservice
  template:
    metadata:
      labels:
        app: wasm-microservice
    spec:
      containers:
      - name: wasm-microservice
        image: wasm-microservice:latest
        ports:
        - containerPort: 8080
        env:
        - name: WASM_CACHE_SIZE
          value: "100"
        - name: WASM_TIMEOUT
          value: "30"
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: wasm-microservice-service
spec:
  selector:
    app: wasm-microservice
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
```

### 3. è¾¹ç¼˜éƒ¨ç½²

#### è¾¹ç¼˜WASMæœåŠ¡é…ç½®

```rust
use wasmtime::*;

pub struct EdgeWasmDeployment {
    wasm_services: std::collections::HashMap<String, WasmService>,
    edge_config: EdgeConfig,
}

pub struct EdgeConfig {
    pub max_memory: usize,
    pub max_execution_time: Duration,
    pub auto_scaling: bool,
}

impl EdgeWasmDeployment {
    pub fn new() -> Self {
        Self {
            wasm_services: std::collections::HashMap::new(),
            edge_config: EdgeConfig {
                max_memory: 16 * 1024 * 1024, // 16MB
                max_execution_time: Duration::from_secs(30),
                auto_scaling: true,
            },
        }
    }
    
    pub async fn deploy_to_edge(&mut self, service_id: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let wasm_service = WasmService::new(wasm_bytes, &self.edge_config)?;
        self.wasm_services.insert(service_id.to_string(), wasm_service);
        Ok(())
    }
}
```

## å®é™…æ¡ˆä¾‹

### 1. å®æ—¶æ•°æ®å¤„ç†æœåŠ¡

#### æµæ•°æ®å¤„ç†WASM

```rust
use wasmtime::*;

pub struct StreamProcessor {
    wasm_engine: Engine,
    processors: std::collections::HashMap<String, Instance>,
    store: Store<()>,
}

impl StreamProcessor {
    pub fn new() -> Self {
        let engine = Engine::default();
        let store = Store::new(&engine, ());
        
        Self {
            wasm_engine: engine,
            processors: std::collections::HashMap::new(),
            store,
        }
    }
    
    pub async fn process_stream(&mut self, processor_id: &str, data_stream: &[u8]) -> Result<Vec<u8>, Error> {
        if let Some(processor) = self.processors.get(&processor_id.to_string()) {
            let func = processor.get_typed_func::<i32, i32>(&mut self.store, "process_stream")?;
            let result = func.call(&mut self.store, data_stream.as_ptr() as i32)?;
            Ok(vec![result as u8])
        } else {
            Err(Error::msg("Processor not found"))
        }
    }
}
```

### 2. æœºå™¨å­¦ä¹ æ¨ç†æœåŠ¡

#### WASM MLæ¨ç†

```rust
use wasmtime::*;

pub struct MLInferenceService {
    models: std::collections::HashMap<String, Instance>,
    store: Store<()>,
}

impl MLInferenceService {
    pub fn new() -> Self {
        let engine = Engine::default();
        let store = Store::new(&engine, ());
        
        Self {
            models: std::collections::HashMap::new(),
            store,
        }
    }
    
    pub async fn load_model(&mut self, model_id: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let module = Module::from_binary(&self.store.engine(), wasm_bytes)?;
        let instance = Instance::new(&mut self.store, &module, &[])?;
        
        self.models.insert(model_id.to_string(), instance);
        Ok(())
    }
    
    pub async fn predict(&mut self, model_id: &str, input: &[f32]) -> Result<Vec<f32>, Error> {
        if let Some(model) = self.models.get(&model_id.to_string()) {
            let func = model.get_typed_func::<i32, i32>(&mut self.store, "predict")?;
            let result = func.call(&mut self.store, input.as_ptr() as i32)?;
            
            // è½¬æ¢ç»“æœ
            Ok(vec![result as f32])
        } else {
            Err(Error::msg("Model not found"))
        }
    }
}
```

## æœªæ¥å‘å±•è¶‹åŠ¿

### 1. WASI (WebAssembly System Interface)

#### ç³»ç»Ÿæ¥å£æ ‡å‡†åŒ–

```rust
use wasmtime_wasi::*;

pub struct WasiMicroservice {
    wasi_ctx: WasiCtx,
    store: Store<WasiCtx>,
}

impl WasiMicroservice {
    pub fn new() -> Self {
        let wasi_ctx = WasiCtx::new();
        let engine = Engine::default();
        let store = Store::new(&engine, wasi_ctx);
        
        Self { wasi_ctx, store }
    }
    
    pub async fn run_wasi_service(&mut self, wasm_bytes: &[u8]) -> Result<(), Error> {
        let module = Module::from_binary(&self.store.engine(), wasm_bytes)?;
        let instance = Instance::new(&mut self.store, &module, &[])?;
        
        // è¿è¡ŒWASIç¨‹åº
        let func = instance.get_typed_func::<(), ()>(&mut self.store, "_start")?;
        func.call(&mut self.store, ())?;
        
        Ok(())
    }
}
```

### 2. ç»„ä»¶æ¨¡å‹

#### WASMç»„ä»¶ç³»ç»Ÿ

```rust
use wasmtime::component::*;

pub struct ComponentMicroservice {
    engine: Engine,
    components: std::collections::HashMap<String, Component>,
}

impl ComponentMicroservice {
    pub fn new() -> Self {
        Self {
            engine: Engine::default(),
            components: std::collections::HashMap::new(),
        }
    }
    
    pub async fn load_component(&mut self, name: &str, wasm_bytes: &[u8]) -> Result<(), Error> {
        let component = Component::from_binary(&self.engine, wasm_bytes)?;
        self.components.insert(name.to_string(), component);
        Ok(())
    }
    
    pub async fn call_component(&mut self, name: &str, function: &str, args: &[u8]) -> Result<Vec<u8>, Error> {
        if let Some(component) = self.components.get(&name.to_string()) {
            // è°ƒç”¨ç»„ä»¶å‡½æ•°
            // å®ç°ç»„ä»¶è°ƒç”¨é€»è¾‘
            Ok(vec![])
        } else {
            Err(Error::msg("Component not found"))
        }
    }
}
```

### 3. å¤šè¯­è¨€äº’æ“ä½œ

#### è·¨è¯­è¨€WASMæœåŠ¡

```rust
// RustæœåŠ¡è°ƒç”¨JavaScript WASM
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_name = callJSFunction)]
    fn call_js_function(data: &str) -> String;
}

pub struct CrossLanguageService;

impl CrossLanguageService {
    pub fn call_javascript_from_rust(&self, data: &str) -> String {
        call_js_function(data)
    }
}

// JavaScriptæœåŠ¡è°ƒç”¨Rust WASM
#[wasm_bindgen]
pub fn rust_function(data: &str) -> String {
    format!("Rust processed: {}", data)
}
```

## æ€»ç»“

WebAssemblyåœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨ä»£è¡¨äº†äº‘åŸç”Ÿè®¡ç®—çš„é‡è¦å‘å±•æ–¹å‘ï¼š

### ä¸»è¦ä¼˜åŠ¿

1. **æè‡´æ€§èƒ½**: æ¥è¿‘åŸç”Ÿä»£ç çš„æ‰§è¡Œé€Ÿåº¦
2. **å¿«é€Ÿå¯åŠ¨**: æ¯«ç§’çº§å¯åŠ¨æ—¶é—´
3. **èµ„æºæ•ˆç‡**: ä½å†…å­˜å ç”¨å’ŒCPUä½¿ç”¨
4. **å®‰å…¨éš”ç¦»**: æ²™ç®±æ‰§è¡Œç¯å¢ƒ
5. **è·¨å¹³å°**: ä¸€æ¬¡ç¼–è¯‘ï¼Œåˆ°å¤„è¿è¡Œ

### åº”ç”¨åœºæ™¯

1. **è¾¹ç¼˜è®¡ç®—**: åœ¨è¾¹ç¼˜èŠ‚ç‚¹éƒ¨ç½²è½»é‡çº§æœåŠ¡
2. **æ’ä»¶ç³»ç»Ÿ**: åŠ¨æ€åŠ è½½å’Œå¸è½½åŠŸèƒ½æ¨¡å—
3. **æ•°æ®å¤„ç†**: é«˜æ€§èƒ½çš„æ•°æ®å¤„ç†ç®¡é“
4. **æœºå™¨å­¦ä¹ **: è½»é‡çº§MLæ¨ç†æœåŠ¡
5. **å®‰å…¨æ²™ç®±**: æ‰§è¡Œä¸å¯ä¿¡ä»£ç 

### æŠ€æœ¯è¶‹åŠ¿

1. **WASIæ ‡å‡†åŒ–**: ç³»ç»Ÿæ¥å£çš„æ ‡å‡†åŒ–
2. **ç»„ä»¶æ¨¡å‹**: æ›´æ¨¡å—åŒ–çš„WASMç»„ä»¶
3. **å¤šè¯­è¨€æ”¯æŒ**: æ›´å¥½çš„è·¨è¯­è¨€äº’æ“ä½œ
4. **å·¥å…·é“¾å®Œå–„**: æ›´æˆç†Ÿçš„å¼€å‘å·¥å…·
5. **ç”Ÿæ€æ‰©å±•**: æ›´ä¸°å¯Œçš„WASMç”Ÿæ€ç³»ç»Ÿ

åœ¨2025å¹´ï¼ŒWebAssemblyå°†æˆä¸ºå¾®æœåŠ¡æ¶æ„ä¸­çš„é‡è¦æŠ€æœ¯ï¼Œç‰¹åˆ«æ˜¯åœ¨è¾¹ç¼˜è®¡ç®—ã€å®æ—¶å¤„ç†å’Œèµ„æºå—é™ç¯å¢ƒä¸­å‘æŒ¥é‡è¦ä½œç”¨ã€‚Rustä½œä¸ºWASMçš„ä¼˜ç§€å®¿ä¸»è¯­è¨€ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½ã€å®‰å…¨çš„WASMå¾®æœåŠ¡æä¾›äº†å¼ºå¤§çš„æ”¯æŒã€‚
