# 1.3 微服务设计原则

## 目录

- [1.3 微服务设计原则](#13-微服务设计原则)
  - [目录](#目录)
  - [单一职责原则](#单一职责原则)
    - [定义](#定义)

## 单一职责原则

### 定义

每个微服务应该专注于单一的业务功能或业务域，具有清晰的边界和职责。

### 业务域划分

```rust
// 用户服务 - 专注于用户管理
pub struct UserService {
    user_repository: UserRepository,
    auth_service: AuthService,
}

impl UserService {
    pub async fn create_user(&self, request: CreateUserRequest) -> Result<User, ServiceError> {
        // 专注于用户创建逻辑
        self.validate_user_data(&request)?;
        let user = self.user_repository.create(request.into()).await?;
        Ok(user)
    }
    
    pub async fn get_user(&self, id: UserId) -> Result<User, ServiceError> {
        // 专注于用户查询逻辑
        self.user_repository.find_by_id(id).await?
            .ok_or(ServiceError::UserNotFound)
    }
}

// 订单服务 - 专注于订单管理
pub struct OrderService {
    order_repository: OrderRepository,
    payment_service: PaymentService,
}

impl OrderService {
    pub async fn create_order(&self, request: CreateOrderRequest) -> Result<Order, ServiceError> {
        // 专注于订单创建逻辑
        self.validate_order_data(&request)?;
        let order = self.order_repository.create(request.into()).await?;
        Ok(order)
    }
}
```

### 技术边界

```rust
// 每个服务独立的技术栈
pub mod user_service {
    use sqlx::PgPool;
    use redis::Client;
    
    pub struct UserServiceConfig {
        pub database: PgPool,
        pub cache: Client,
        pub port: u16,
    }
}

pub mod order_service {
    use mongodb::Database;
    use kafka::Producer;
    
    pub struct OrderServiceConfig {
        pub database: Database,
        pub message_queue: Producer,
        pub port: u16,
    }
}
```

## 服务自治原则

### 独立部署

```rust
// 每个服务独立的部署配置
// user-service/Cargo.toml
[package]
name = "user-service"
version = "1.0.0"

[dependencies]
sqlx = "0.7"
tokio = "1.0"

// order-service/Cargo.toml  
[package]
name = "order-service"
version = "1.0.0"

[dependencies]
mongodb = "2.0"
kafka = "0.9"
tokio = "1.0"
```

### 独立开发

```rust
// 独立的API版本管理
pub mod user_api {
    #[derive(Serialize, Deserialize)]
    pub struct UserV1 {
        pub id: u64,
        pub name: String,
        pub email: String,
    }
    
    #[derive(Serialize, Deserialize)]
    pub struct UserV2 {
        pub id: u64,
        pub name: String,
        pub email: String,
        pub profile: UserProfile,
    }
}

// 版本兼容性处理
pub enum UserResponse {
    V1(user_api::UserV1),
    V2(user_api::UserV2),
}
```

### 独立扩展

```rust
// 基于负载的独立扩展
pub struct ServiceMetrics {
    pub cpu_usage: f64,
    pub memory_usage: f64,
    pub request_rate: u64,
    pub error_rate: f64,
}

impl ServiceMetrics {
    pub fn should_scale_up(&self) -> bool {
        self.cpu_usage > 70.0 || self.request_rate > 1000
    }
    
    pub fn should_scale_down(&self) -> bool {
        self.cpu_usage < 30.0 && self.request_rate < 100
    }
}
```

## 数据隔离原则

### 数据库分离

```rust
// 每个服务拥有独立的数据存储
pub struct UserRepository {
    pool: PgPool, // 用户服务的PostgreSQL数据库
}

pub struct OrderRepository {
    database: Database, // 订单服务的MongoDB数据库
}

pub struct PaymentRepository {
    connection: SqliteConnection, // 支付服务的SQLite数据库
}
```

### 数据所有权

```rust
// 数据访问边界
pub struct UserData {
    pub id: UserId,
    pub name: String,
    pub email: String,
    // 用户服务拥有完整控制权
}

pub struct OrderData {
    pub id: OrderId,
    pub user_id: UserId, // 只引用用户ID，不包含用户详细信息
    pub items: Vec<OrderItem>,
    pub total: Decimal,
    // 订单服务拥有订单数据
}
```

### 数据一致性

```rust
// 最终一致性模式
pub struct EventSourcing {
    events: Vec<DomainEvent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DomainEvent {
    UserCreated { user_id: UserId, name: String },
    OrderCreated { order_id: OrderId, user_id: UserId },
    PaymentProcessed { order_id: OrderId, amount: Decimal },
}

// 事件发布
pub async fn publish_event(&self, event: DomainEvent) -> Result<(), EventError> {
    self.event_store.append(event.clone()).await?;
    self.event_bus.publish(event).await?;
    Ok(())
}
```

## 故障隔离原则

### 熔断器模式

```rust
use std::time::{Duration, Instant};

pub struct CircuitBreaker {
    failure_count: u32,
    last_failure: Option<Instant>,
    state: CircuitState,
    failure_threshold: u32,
    timeout: Duration,
}

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,   // 正常状态
    Open,     // 熔断状态
    HalfOpen, // 半开状态
}

impl CircuitBreaker {
    pub async fn call<T, F, Fut>(&mut self, f: F) -> Result<T, CircuitError>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<T, ServiceError>>,
    {
        match self.state {
            CircuitState::Open => {
                if self.should_attempt_reset() {
                    self.state = CircuitState::HalfOpen;
                } else {
                    return Err(CircuitError::CircuitOpen);
                }
            }
            CircuitState::HalfOpen => {
                // 尝试恢复
            }
            CircuitState::Closed => {
                // 正常处理
            }
        }
        
        let result = f().await;
        self.update_state(result.is_ok());
        result.map_err(|e| CircuitError::ServiceError(e))
    }
}
```

### 重试机制

```rust
use tokio::time::{sleep, Duration};

pub struct RetryConfig {
    pub max_attempts: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub backoff_multiplier: f64,
}

pub async fn with_retry<T, F, Fut>(
    config: &RetryConfig,
    mut operation: F,
) -> Result<T, ServiceError>
where
    F: FnMut() -> Fut,
    Fut: std::future::Future<Output = Result<T, ServiceError>>,
{
    let mut delay = config.initial_delay;
    
    for attempt in 1..=config.max_attempts {
        match operation().await {
            Ok(result) => return Ok(result),
            Err(error) if attempt == config.max_attempts => return Err(error),
            Err(error) => {
                log::warn!("Attempt {} failed: {}, retrying in {:?}", attempt, error, delay);
                sleep(delay).await;
                delay = std::cmp::min(
                    Duration::from_millis((delay.as_millis() as f64 * config.backoff_multiplier) as u64),
                    config.max_delay,
                );
            }
        }
    }
    
    unreachable!()
}
```

### 超时处理

```rust
use tokio::time::timeout;

pub async fn call_service_with_timeout<T>(
    duration: Duration,
    operation: impl std::future::Future<Output = Result<T, ServiceError>>,
) -> Result<T, ServiceError> {
    match timeout(duration, operation).await {
        Ok(result) => result,
        Err(_) => Err(ServiceError::Timeout),
    }
}

// 使用示例
pub async fn get_user_with_timeout(&self, user_id: UserId) -> Result<User, ServiceError> {
    call_service_with_timeout(
        Duration::from_secs(5),
        self.user_service.get_user(user_id),
    ).await
}
```

## 可观测性原则

### 分布式追踪

```rust
use tracing::{info_span, instrument};

#[instrument(skip(self), fields(user_id = %user_id))]
pub async fn get_user(&self, user_id: UserId) -> Result<User, ServiceError> {
    info_span!("user_service.get_user").in_scope(|| async {
        // 自动记录请求参数和响应
        let user = self.user_repository.find_by_id(user_id).await?;
        Ok(user)
    }).await
}
```

### 指标收集

```rust
use metrics::{counter, histogram, gauge};

pub struct ServiceMetrics {
    request_counter: Counter,
    response_time: Histogram,
    active_connections: Gauge,
}

impl ServiceMetrics {
    pub fn record_request(&self, endpoint: &str) {
        counter!("requests_total", "endpoint" => endpoint).increment(1);
    }
    
    pub fn record_response_time(&self, endpoint: &str, duration: Duration) {
        histogram!("request_duration_seconds", "endpoint" => endpoint)
            .record(duration.as_secs_f64());
    }
    
    pub fn update_active_connections(&self, count: u64) {
        gauge!("active_connections").set(count as f64);
    }
}
```

### 健康检查

```rust
pub struct HealthChecker {
    dependencies: Vec<Box<dyn HealthCheckable>>,
}

pub trait HealthCheckable {
    async fn health_check(&self) -> HealthStatus;
}

pub enum HealthStatus {
    Healthy,
    Unhealthy(String),
    Degraded(String),
}

impl HealthChecker {
    pub async fn check_all(&self) -> HealthReport {
        let mut report = HealthReport::new();
        
        for dependency in &self.dependencies {
            let status = dependency.health_check().await;
            report.add_dependency(dependency.name(), status);
        }
        
        report
    }
}
```

## 版本兼容原则

### API版本管理

```rust
// 版本化API设计
pub mod api {
    pub mod v1 {
        use serde::{Deserialize, Serialize};
        
        #[derive(Serialize, Deserialize)]
        pub struct UserResponse {
            pub id: u64,
            pub name: String,
            pub email: String,
        }
        
        #[derive(Serialize, Deserialize)]
        pub struct CreateUserRequest {
            pub name: String,
            pub email: String,
        }
    }
    
    pub mod v2 {
        use serde::{Deserialize, Serialize};
        
        #[derive(Serialize, Deserialize)]
        pub struct UserResponse {
            pub id: u64,
            pub name: String,
            pub email: String,
            pub profile: UserProfile,
            pub created_at: chrono::DateTime<chrono::Utc>,
        }
        
        #[derive(Serialize, Deserialize)]
        pub struct CreateUserRequest {
            pub name: String,
            pub email: String,
            pub profile: Option<UserProfile>,
        }
    }
}
```

### 向后兼容

```rust
// 兼容性适配器
pub struct ApiAdapter;

impl ApiAdapter {
    pub fn adapt_v1_to_v2(v1_user: api::v1::UserResponse) -> api::v2::UserResponse {
        api::v2::UserResponse {
            id: v1_user.id,
            name: v1_user.name,
            email: v1_user.email,
            profile: UserProfile::default(),
            created_at: chrono::Utc::now(),
        }
    }
    
    pub fn adapt_v2_to_v1(v2_user: api::v2::UserResponse) -> api::v1::UserResponse {
        api::v1::UserResponse {
            id: v2_user.id,
            name: v2_user.name,
            email: v2_user.email,
        }
    }
}
```

## 安全设计原则

### 零信任架构

```rust
// 每个请求都需要验证
pub struct SecurityMiddleware {
    jwt_validator: JwtValidator,
    rate_limiter: RateLimiter,
}

impl SecurityMiddleware {
    pub async fn validate_request(&self, request: &Request) -> Result<(), SecurityError> {
        // 验证JWT令牌
        self.jwt_validator.validate(&request.token)?;
        
        // 检查速率限制
        self.rate_limiter.check_limit(&request.client_id)?;
        
        // 验证请求签名
        self.verify_signature(request)?;
        
        Ok(())
    }
}
```

### 最小权限原则

```rust
// 基于角色的访问控制
pub enum Role {
    Admin,
    User,
    Guest,
}

pub struct Permission {
    pub resource: String,
    pub action: String,
}

impl Role {
    pub fn permissions(&self) -> Vec<Permission> {
        match self {
            Role::Admin => vec![
                Permission { resource: "users".to_string(), action: "read".to_string() },
                Permission { resource: "users".to_string(), action: "write".to_string() },
                Permission { resource: "orders".to_string(), action: "read".to_string() },
                Permission { resource: "orders".to_string(), action: "write".to_string() },
            ],
            Role::User => vec![
                Permission { resource: "users".to_string(), action: "read".to_string() },
                Permission { resource: "orders".to_string(), action: "read".to_string() },
            ],
            Role::Guest => vec![
                Permission { resource: "public".to_string(), action: "read".to_string() },
            ],
        }
    }
}
```

## 性能设计原则

### 缓存策略

```rust
use std::time::{Duration, Instant};

pub struct Cache<T> {
    data: std::collections::HashMap<String, CacheEntry<T>>,
    ttl: Duration,
}

struct CacheEntry<T> {
    value: T,
    expires_at: Instant,
}

impl<T> Cache<T> {
    pub fn get(&mut self, key: &str) -> Option<&T> {
        if let Some(entry) = self.data.get(key) {
            if entry.expires_at > Instant::now() {
                Some(&entry.value)
            } else {
                self.data.remove(key);
                None
            }
        } else {
            None
        }
    }
    
    pub fn set(&mut self, key: String, value: T) {
        let entry = CacheEntry {
            value,
            expires_at: Instant::now() + self.ttl,
        };
        self.data.insert(key, entry);
    }
}
```

### 连接池

```rust
// 数据库连接池
pub struct DatabasePool {
    pool: sqlx::PgPool,
    max_connections: u32,
}

impl DatabasePool {
    pub async fn new(database_url: &str, max_connections: u32) -> Result<Self, sqlx::Error> {
        let pool = sqlx::PgPool::builder()
            .max_connections(max_connections)
            .build(database_url)
            .await?;
            
        Ok(Self {
            pool,
            max_connections,
        })
    }
    
    pub async fn acquire(&self) -> Result<sqlx::PgConnection, sqlx::Error> {
        self.pool.acquire().await
    }
}
```

## 实践指导

### 服务拆分策略

1. **按业务域拆分**: 用户管理、订单处理、支付处理
2. **按数据模型拆分**: 用户数据、产品数据、订单数据
3. **按团队结构拆分**: 前端团队、后端团队、数据团队
4. **按技术需求拆分**: 高并发服务、计算密集型服务

### 通信模式选择

```rust
// 同步通信 - HTTP/gRPC
pub async fn get_user_from_service(&self, user_id: UserId) -> Result<User, ServiceError> {
    let response = self.http_client
        .get(&format!("http://user-service/users/{}", user_id))
        .send()
        .await?;
    
    let user: User = response.json().await?;
    Ok(user)
}

// 异步通信 - 消息队列
pub async fn publish_user_event(&self, event: UserEvent) -> Result<(), ServiceError> {
    let message = serde_json::to_string(&event)?;
    self.message_producer
        .send("user-events", message)
        .await?;
    Ok(())
}
```

### 监控和告警

```rust
// 关键指标监控
pub struct ServiceMonitor {
    metrics: ServiceMetrics,
    alert_manager: AlertManager,
}

impl ServiceMonitor {
    pub async fn check_health(&self) -> Result<(), MonitoringError> {
        let health = self.metrics.get_health_status().await?;
        
        if health.error_rate > 0.05 {
            self.alert_manager.send_alert(
                AlertLevel::Critical,
                "High error rate detected",
                format!("Error rate: {:.2}%", health.error_rate * 100.0),
            ).await?;
        }
        
        if health.response_time > Duration::from_millis(1000) {
            self.alert_manager.send_alert(
                AlertLevel::Warning,
                "High response time detected",
                format!("Response time: {:?}", health.response_time),
            ).await?;
        }
        
        Ok(())
    }
}
```

## 总结

微服务设计原则是构建可靠、可扩展微服务架构的基础：

1. **单一职责**: 每个服务专注单一业务功能
2. **服务自治**: 独立开发、部署、扩展
3. **数据隔离**: 每个服务拥有独立的数据存储
4. **故障隔离**: 防止级联故障
5. **可观测性**: 全面的监控和追踪
6. **版本兼容**: 平滑的API演进
7. **安全设计**: 零信任和最小权限
8. **性能优化**: 缓存和连接池

遵循这些原则可以构建出高性能、高可用的微服务系统。
