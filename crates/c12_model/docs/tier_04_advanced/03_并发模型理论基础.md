# 并发模型理论基础

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **难度等级**: ⭐⭐⭐⭐⭐  
> **预计阅读**: 70分钟

## 目录

- [并发模型理论基础](#并发模型理论基础)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [并发模型分类](#并发模型分类)
  - [2. 进程演算](#2-进程演算)
    - [2.1 CSP (Communicating Sequential Processes)](#21-csp-communicating-sequential-processes)
    - [2.2 π-演算 (π-calculus)](#22-π-演算-π-calculus)
  - [3. Petri网理论](#3-petri网理论)
    - [3.1 基本定义](#31-基本定义)
  - [4. Session Types深度解析](#4-session-types深度解析)
    - [4.1 Binary Session Types](#41-binary-session-types)
    - [4.2 Multiparty Session Types](#42-multiparty-session-types)
  - [5. 内存模型理论](#5-内存模型理论)
    - [5.1 Sequential Consistency (SC)](#51-sequential-consistency-sc)
    - [5.2 Total Store Order (TSO)](#52-total-store-order-tso)
  - [6. 无锁数据结构](#6-无锁数据结构)
    - [6.1 Treiber Stack (无锁栈)](#61-treiber-stack-无锁栈)
  - [7. Rust并发模型](#7-rust并发模型)
    - [7.1 所有权与并发](#71-所有权与并发)
    - [7.2 生命周期与并发](#72-生命周期与并发)
  - [8. 形式化验证](#8-形式化验证)
    - [8.1 Loom (并发测试)](#81-loom-并发测试)
  - [9. 前沿研究](#9-前沿研究)
    - [9.1 Rely-Guarantee推理](#91-rely-guarantee推理)
    - [9.2 Separation Logic](#92-separation-logic)
    - [9.3 Iris (高阶并发分离逻辑)](#93-iris-高阶并发分离逻辑)
  - [10. 总结](#10-总结)

---

## 1. 概述

并发模型理论为并发系统提供形式化基础，包括进程演算、Petri网、Session Types等。

### 并发模型分类

```text
┌────────────────────────────────────────────────────┐
│           并发模型理论体系                           │
├────────────────────────────────────────────────────┤
│                                                    │
│  进程演算        Petri网        Session Types       │
│  (π-calculus)   (Place-Trans)  (Type System)       │
│      ↓              ↓                ↓             │
│  ┌─────────┐  ┌─────────┐    ┌─────────┐           │
│  │ CSP     │  │ 状态空间│    │ 协议验证│            │
│  │ CCS     │  │ 可达性  │    │ 死锁检测│            │
│  │ π-calc  │  │ 活性    │    │ 进度保证│            │
│  └─────────┘  └─────────┘    └─────────┘           │
│                                                    │
│  共享内存模型                                       │
│  (Memory Models)                                   │
│      ↓                                             │
│  ┌─────────┐  ┌─────────┐    ┌─────────┐           │
│  │ SC      │  │ TSO     │    │ PSO     │           │
│  │ Relax   │  │ x86-TSO │    │ ARM     │           │
│  └─────────┘  └─────────┘    └─────────┘           │
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## 2. 进程演算

### 2.1 CSP (Communicating Sequential Processes)

**语法**:

```text
P ::= STOP              (终止)
    | a → P             (前缀)
    | P □ Q             (外部选择)
    | P ⊓ Q             (内部选择)
    | P ||| Q           (交织)
    | P || Q            (并行)
    | P \ A             (隐藏)
```

**语义**:

- **Trace语义**: 进程的执行序列
- **Failure语义**: (trace, refusal set)
- **Divergence语义**: 无限内部动作

**Rust CSP实现**:

```rust
use c12_model::concurrent::csp::*;

// CSP进程定义
pub enum CSPProcess {
    Stop,
    Prefix(Event, Box<CSPProcess>),
    ExternalChoice(Box<CSPProcess>, Box<CSPProcess>),
    InternalChoice(Box<CSPProcess>, Box<CSPProcess>),
    Parallel(Box<CSPProcess>, Box<CSPProcess>),
}

// CSP语义
pub struct CSPSemantics {
    traces: Vec<Vec<Event>>,
}

impl CSPSemantics {
    pub fn compute_traces(&self, process: &CSPProcess) -> Vec<Vec<Event>> {
        match process {
            CSPProcess::Stop => vec![vec![]],
            CSPProcess::Prefix(event, next) => {
                let next_traces = self.compute_traces(next);
                next_traces.into_iter()
                    .map(|mut trace| {
                        trace.insert(0, event.clone());
                        trace
                    })
                    .collect()
            }
            CSPProcess::ExternalChoice(p, q) => {
                let mut traces = self.compute_traces(p);
                traces.extend(self.compute_traces(q));
                traces
            }
            CSPProcess::InternalChoice(p, q) => {
                // 非确定性选择
                let mut traces = self.compute_traces(p);
                traces.extend(self.compute_traces(q));
                traces
            }
            CSPProcess::Parallel(p, q) => {
                // 交织所有可能的执行
                self.interleave_traces(
                    &self.compute_traces(p),
                    &self.compute_traces(q)
                )
            }
        }
    }
}
```

### 2.2 π-演算 (π-calculus)

**特点**: 支持通道名的传递（移动性）。

**语法**:

```text
P ::= 0                 (空进程)
    | x(y).P            (输入)
    | x̄⟨y⟩.P            (输出)
    | P | Q             (并行)
    | νx.P              (限制)
    | !P                (复制)
```

**Rust实现**:

```rust
// π-演算进程
pub enum PiProcess {
    Nil,
    Input(Channel, String, Box<PiProcess>),
    Output(Channel, Channel, Box<PiProcess>),
    Parallel(Box<PiProcess>, Box<PiProcess>),
    Restriction(Channel, Box<PiProcess>),
    Replication(Box<PiProcess>),
}

// 示例：移动通道
pub fn mobile_channel_example() {
    // P = a(x).x̄⟨b⟩
    let p = PiProcess::Input(
        Channel::new("a"),
        "x".to_string(),
        Box::new(PiProcess::Output(
            Channel::var("x"),
            Channel::new("b"),
            Box::new(PiProcess::Nil),
        )),
    );
    
    // Q = ā⟨c⟩.c̄⟨d⟩
    let q = PiProcess::Output(
        Channel::new("a"),
        Channel::new("c"),
        Box::new(PiProcess::Output(
            Channel::new("c"),
            Channel::new("d"),
            Box::new(PiProcess::Nil),
        )),
    );
    
    // P | Q 将导致：c̄⟨b⟩ | c̄⟨d⟩
}
```

---

## 3. Petri网理论

### 3.1 基本定义

**Petri网** N = (P, T, F):

- P: 位置 (Places)
- T: 变迁 (Transitions)
- F: 流关系 (Flow) ⊆ (P×T) ∪ (T×P)

**标识** M: P → ℕ (Token分布)

**触发规则**:

```text
变迁t可触发当且仅当：
  ∀p ∈ •t, M(p) ≥ F(p,t)

触发后:
  M'(p) = M(p) - F(p,t) + F(t,p)
```

**Rust实现**:

```rust
use std::collections::{HashMap, HashSet};

// Petri网结构
pub struct PetriNet {
    places: HashSet<Place>,
    transitions: HashSet<Transition>,
    input_arcs: HashMap<(Place, Transition), usize>,
    output_arcs: HashMap<(Transition, Place), usize>,
}

// 标识
pub struct Marking {
    tokens: HashMap<Place, usize>,
}

impl PetriNet {
    // 检查变迁是否可触发
    pub fn is_enabled(&self, transition: &Transition, marking: &Marking) -> bool {
        for (place, &weight) in self.get_input_places(transition) {
            if marking.tokens.get(place).unwrap_or(&0) < &weight {
                return false;
            }
        }
        true
    }
    
    // 触发变迁
    pub fn fire(&self, transition: &Transition, marking: &mut Marking) -> Result<(), String> {
        if !self.is_enabled(transition, marking) {
            return Err("Transition not enabled".to_string());
        }
        
        // 消耗输入Token
        for (place, &weight) in self.get_input_places(transition) {
            *marking.tokens.entry(place.clone()).or_insert(0) -= weight;
        }
        
        // 产生输出Token
        for (place, &weight) in self.get_output_places(transition) {
            *marking.tokens.entry(place.clone()).or_insert(0) += weight;
        }
        
        Ok(())
    }
    
    // 可达性分析
    pub fn reachability_graph(&self, initial: &Marking) -> HashSet<Marking> {
        let mut reachable = HashSet::new();
        let mut to_explore = vec![initial.clone()];
        reachable.insert(initial.clone());
        
        while let Some(current) = to_explore.pop() {
            for transition in &self.transitions {
                if self.is_enabled(transition, &current) {
                    let mut next = current.clone();
                    self.fire(transition, &mut next).unwrap();
                    
                    if !reachable.contains(&next) {
                        reachable.insert(next.clone());
                        to_explore.push(next);
                    }
                }
            }
        }
        
        reachable
    }
}

// 示例：生产者-消费者
pub fn producer_consumer_petri_net() -> PetriNet {
    let mut net = PetriNet::new();
    
    // Places
    let buffer_empty = Place::new("buffer_empty");
    let buffer_full = Place::new("buffer_full");
    
    // Transitions
    let produce = Transition::new("produce");
    let consume = Transition::new("consume");
    
    // Arcs
    net.add_input_arc(buffer_empty.clone(), produce.clone(), 1);
    net.add_output_arc(produce.clone(), buffer_full.clone(), 1);
    net.add_input_arc(buffer_full.clone(), consume.clone(), 1);
    net.add_output_arc(consume.clone(), buffer_empty.clone(), 1);
    
    net
}
```

---

## 4. Session Types深度解析

### 4.1 Binary Session Types

**类型语法**:

```text
T ::= !T₁.T₂    (发送T₁，继续T₂)
    | ?T₁.T₂    (接收T₁，继续T₂)
    | ⊕{lᵢ:Tᵢ}  (选择)
    | &{lᵢ:Tᵢ}  (分支)
    | end       (终止)
    | μX.T      (递归)
```

**对偶性**:

```text
dual(!T₁.T₂) = ?T₁.dual(T₂)
dual(?T₁.T₂) = !T₁.dual(T₂)
dual(⊕{lᵢ:Tᵢ}) = &{lᵢ:dual(Tᵢ)}
dual(end) = end
```

**Rust实现**:

```rust
use std::marker::PhantomData;

// Session Type标记
pub struct Send<T, S> {
    _phantom: PhantomData<(T, S)>,
}

pub struct Recv<T, S> {
    _phantom: PhantomData<(T, S)>,
}

pub struct Choose<L, R> {
    _phantom: PhantomData<(L, R)>,
}

pub struct Offer<L, R> {
    _phantom: PhantomData<(L, R)>,
}

pub struct End;

// Session Channel
pub struct Chan<S, E> {
    _session: PhantomData<S>,
    _endpoint: PhantomData<E>,
}

// 端点标记
pub struct Here;
pub struct There<E> {
    _phantom: PhantomData<E>,
}

// 发送操作
impl<T, S, E> Chan<Send<T, S>, E> {
    pub fn send(self, value: T) -> Chan<S, E> {
        // 发送value到对端
        Chan {
            _session: PhantomData,
            _endpoint: PhantomData,
        }
    }
}

// 接收操作
impl<T, S, E> Chan<Recv<T, S>, E> {
    pub fn recv(self) -> (T, Chan<S, E>) {
        // 从对端接收
        todo!()
    }
}

// 选择操作
impl<L, R, E> Chan<Choose<L, R>, E> {
    pub fn sel_left(self) -> Chan<L, E> {
        Chan {
            _session: PhantomData,
            _endpoint: PhantomData,
        }
    }
    
    pub fn sel_right(self) -> Chan<R, E> {
        Chan {
            _session: PhantomData,
            _endpoint: PhantomData,
        }
    }
}

// 分支操作
impl<L, R, E> Chan<Offer<L, R>, E> {
    pub fn offer<F, G, T>(self, left: F, right: G) -> T
    where
        F: FnOnce(Chan<L, E>) -> T,
        G: FnOnce(Chan<R, E>) -> T,
    {
        // 根据对端选择执行相应分支
        todo!()
    }
}

// 示例：二进制搜索协议
type BinarySearchClient = Send<i32, Recv<Ordering, Choose<
    Recv<i32, End>,           // 找到：接收值
    Choose<                   // 未找到：继续搜索
        Send<(), End>,        // 左子树
        Send<(), End>,        // 右子树
    >
>>>;

type BinarySearchServer = Recv<i32, Send<Ordering, Offer<
    Send<i32, End>,           // 找到：发送值
    Offer<                    // 未找到：等待选择
        Recv<(), End>,        // 左子树
        Recv<(), End>,        // 右子树
    >
>>>;
```

### 4.2 Multiparty Session Types

**全局类型**:

```text
G ::= p→q:⟨U⟩.G      (通信)
    | p→{qᵢ:Gᵢ}       (分支)
    | μX.G            (递归)
    | end             (终止)
```

**投影** G↾p (全局类型投影到角色p的局部类型)

---

## 5. 内存模型理论

### 5.1 Sequential Consistency (SC)

**定义**: 所有操作按某个全局顺序执行，且每个线程的操作按程序顺序执行。

**Rust实现**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct SCRegister {
    value: AtomicI32,
}

impl SCRegister {
    pub fn write(&self, value: i32) {
        self.value.store(value, Ordering::SeqCst);
    }
    
    pub fn read(&self) -> i32 {
        self.value.load(Ordering::SeqCst)
    }
}
```

### 5.2 Total Store Order (TSO)

**特点**: 写操作可以延迟到Store Buffer，但按FIFO顺序完成。

**x86-TSO模型**:

```text
每个线程有一个Store Buffer
写操作先进入Store Buffer
读操作先检查Store Buffer，再检查内存
Store Buffer异步刷新到内存
```

**Rust实现**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct TSORegister {
    value: AtomicI32,
}

impl TSORegister {
    pub fn write(&self, value: i32) {
        // Release语义：之前的写可见
        self.value.store(value, Ordering::Release);
    }
    
    pub fn read(&self) -> i32 {
        // Acquire语义：之后的读看到之前的写
        self.value.load(Ordering::Acquire)
    }
}
```

---

## 6. 无锁数据结构

### 6.1 Treiber Stack (无锁栈)

**算法**:

```text
push(x):
  loop:
    top = head.load()
    x.next = top
    if CAS(head, top, x):
      return

pop():
  loop:
    top = head.load()
    if top == null:
      return None
    next = top.next
    if CAS(head, top, next):
      return Some(top.value)
```

**Rust实现**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

pub struct TreiberStack<T> {
    head: AtomicPtr<Node<T>>,
}

struct Node<T> {
    value: T,
    next: *mut Node<T>,
}

impl<T> TreiberStack<T> {
    pub fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    pub fn push(&self, value: T) {
        let new_node = Box::into_raw(Box::new(Node {
            value,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head.compare_exchange(
                head,
                new_node,
                Ordering::Release,
                Ordering::Acquire,
            ).is_ok() {
                break;
            }
        }
    }
    
    pub fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            if self.head.compare_exchange(
                head,
                next,
                Ordering::Release,
                Ordering::Acquire,
            ).is_ok() {
                let value = unsafe { Box::from_raw(head).value };
                return Some(value);
            }
        }
    }
}
```

---

## 7. Rust并发模型

### 7.1 所有权与并发

**Send trait**: 类型可以安全地在线程间传递
**Sync trait**: 类型可以安全地被多线程共享

**规则**:

```text
T: Send  ⟺  可以move到其他线程
T: Sync  ⟺  &T: Send
Arc<T>: Send + Sync  ⟺  T: Send + Sync
```

### 7.2 生命周期与并发

```rust
use std::thread;

pub fn scoped_threads_example() {
    let data = vec![1, 2, 3, 4, 5];
    
    thread::scope(|s| {
        s.spawn(|| {
            // 可以借用data（生命周期保证）
            println!("Sum: {}", data.iter().sum::<i32>());
        });
    });
}
```

---

## 8. 形式化验证

### 8.1 Loom (并发测试)

**示例**:

```rust
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
#[should_panic]
fn buggy_concurrent_increment() {
    loom::model(|| {
        let counter = AtomicUsize::new(0);
        
        let t1 = thread::spawn(|| {
            let val = counter.load(Ordering::Relaxed);
            counter.store(val + 1, Ordering::Relaxed);
        });
        
        let t2 = thread::spawn(|| {
            let val = counter.load(Ordering::Relaxed);
            counter.store(val + 1, Ordering::Relaxed);
        });
        
        t1.join().unwrap();
        t2.join().unwrap();
        
        // 可能结果: 1 或 2（竞争条件）
        assert_eq!(counter.load(Ordering::Relaxed), 2);
    });
}
```

---

## 9. 前沿研究

### 9.1 Rely-Guarantee推理

**概念**: 为并发程序提供模块化推理。

### 9.2 Separation Logic

**概念**: 推理指针和堆的逻辑。

### 9.3 Iris (高阶并发分离逻辑)

**特点**: 支持高阶推理和不变量。

---

## 10. 总结

并发模型理论为并发系统提供形式化基础：

1. **进程演算** - CSP, π-calculus
2. **Petri网** - 状态空间分析
3. **Session Types** - 协议类型化
4. **内存模型** - SC, TSO, ARM
5. **无锁数据结构** - CAS, ABA问题
6. **Rust并发** - Send, Sync, 生命周期

**Rust优势**:

- 所有权系统
- 类型安全
- 形式化工具 (Loom, Kani)

**实践建议**:

- 优先使用高级抽象 (Tokio, Rayon)
- 必要时使用无锁结构
- 使用Loom测试并发代码

---

**参考文献**:

- [Communicating Sequential Processes](https://www.cs.ox.ac.uk/people/bill.roscoe/publications/68b.pdf)
- [The Pi Calculus](https://mitpress.mit.edu/9780262360517/the-pi-calculus/)
- [Session Types](https://www.di.fc.ul.pt/~vv/papers/vasconcelos_gay_ravara.session-types.pdf)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)

---

**最后更新**: 2025-10-23  
**维护者**: C12 Model Team  
**许可证**: MIT
