# 语言语义模型与 Rust 1.90 特性映射


## 📊 目录

- [📋 目录](#目录)
- [语义三分法](#语义三分法)
- [Rust 特性映射](#rust-特性映射)
- [并发内存模型](#并发内存模型)
- [与本库的连接](#与本库的连接)
- [小步语义片段（Send/Sync/Pin）](#小步语义片段sendsyncpin)
- [Rust 1.90 语义与并发映射（补充）](#rust-190-语义与并发映射补充)
  - [等价与验证](#等价与验证)


## 📋 目录

- [语言语义模型与 Rust 1.90 特性映射](#语言语义模型与-rust-190-特性映射)
  - [📋 目录](#-目录)
  - [语义三分法](#语义三分法)
  - [Rust 特性映射](#rust-特性映射)
  - [并发内存模型](#并发内存模型)
  - [与本库的连接](#与本库的连接)
  - [小步语义片段（Send/Sync/Pin）](#小步语义片段sendsyncpin)
  - [Rust 1.90 语义与并发映射（补充）](#rust-190-语义与并发映射补充)
    - [等价与验证](#等价与验证)

---

## 语义三分法

- 操作语义：以转移规则给出执行步骤（小步/大步）。
- 指称语义：将程序映射为数学对象（函数、域）。
- 公理语义：以断言与推理规则给出正确性证明（Hoare Logic）。

## Rust 特性映射

- 所有权/借用：以公理语义表达别名约束；以操作语义描述移动/借用转移。
- 生命周期：以参数化型系统刻画，防止悬垂引用；在指称层保证不变式。
- `Send`/`Sync`：跨线程移动/共享的代数性质；与内存模型（SeqCst/Relaxed）相关。
- `Pin`：禁止对象移动的指称约束，服务于自引用与 FFI。

## 并发内存模型

- 原子序（Relaxed/Acquire/Release/AcqRel/SeqCst）与数据竞争定义。
- `loom` 可在小状态空间内捕获弱序导致的竞态。

## 与本库的连接

- 形式化章节的 FSM/CTL/LTL 可对并发协议与取消/超时策略进行性质验证。
- 算法章节可用指称视角刻画复杂度与资源上界。

## 小步语义片段（Send/Sync/Pin）

- Send 传递：`⟨t, σ⟩ → ⟨spawn(move t), σ⟩`，要求 `t: Send`，状态 `σ` 中不产生别名冲突。
- Sync 共享：读操作满足一致性序；写操作需原子或互斥保护，不违反 `Sync` 不变式。
- Pin 固定：禁止 `move` 影响已固定内存位置；仅允许通过 `UnsafeCell` 与特定 API 改变内部可变性。

## Rust 1.90 语义与并发映射（补充）

- `async/await`：编译为状态机；每个 `await` 是状态转移点，由 `Waker` 驱动进展。
- `Pin`/`Unpin`：保障自引用 Future 的内存稳定；在 I/O 驱动型状态机中避免移动破坏引用。
- `Send`/`Sync`：跨线程移动与共享的边界；`!Send` Future 需 `spawn_local` 或单线程运行时。
- 常量泛型 `_` 推断：以类型承载不变式（例如队列容量、并发上限、批大小），便于静态检查。
- 取消与结构化并发：`JoinSet`/`task::scope` 明确父子关系，取消向下传播，资源可回收。

### 等价与验证

- 可观测等价：以 trace 或 bisimulation 比较同步/异步实现是否对外行为一致。
- 时序逻辑：以 LTL/CTL 表述活性与安全性质（例如 AF(resp) 表示必将响应）。
- 模型检查：将接口抽象为 Kripke 结构，验证顺序性、无饥饿、有界等待等不变式。
