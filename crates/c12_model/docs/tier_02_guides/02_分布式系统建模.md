# C12 Model - Tier 2: 分布式系统建模

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 40 分钟

---


## 📊 目录

- [📋 目录](#目录)
- [1. 分布式系统基础](#1-分布式系统基础)
  - [1.1 CAP 定理](#11-cap-定理)
  - [1.2 分布式系统挑战](#12-分布式系统挑战)
- [2. Raft 共识算法](#2-raft-共识算法)
  - [2.1 Raft 核心概念](#21-raft-核心概念)
  - [2.2 日志复制](#22-日志复制)
- [3. 向量时钟与因果关系](#3-向量时钟与因果关系)
  - [3.1 Lamport 时钟](#31-lamport-时钟)
  - [3.2 向量时钟](#32-向量时钟)
- [4. 分布式快照](#4-分布式快照)
  - [4.1 Chandy-Lamport 算法](#41-chandy-lamport-算法)
- [5. 一致性模型](#5-一致性模型)
  - [5.1 强一致性](#51-强一致性)
  - [5.2 最终一致性](#52-最终一致性)
- [6. 实战案例](#6-实战案例)
  - [6.1 简化的 Paxos](#61-简化的-paxos)
- [7. 总结](#7-总结)
  - [核心要点](#核心要点)
  - [最佳实践](#最佳实践)
- [📚 参考资源](#参考资源)


## 📋 目录

- [C12 Model - Tier 2: 分布式系统建模](#c12-model---tier-2-分布式系统建模)
  - [📋 目录](#-目录)
  - [1. 分布式系统基础](#1-分布式系统基础)
    - [1.1 CAP 定理](#11-cap-定理)
    - [1.2 分布式系统挑战](#12-分布式系统挑战)
  - [2. Raft 共识算法](#2-raft-共识算法)
    - [2.1 Raft 核心概念](#21-raft-核心概念)
    - [2.2 日志复制](#22-日志复制)
  - [3. 向量时钟与因果关系](#3-向量时钟与因果关系)
    - [3.1 Lamport 时钟](#31-lamport-时钟)
    - [3.2 向量时钟](#32-向量时钟)
  - [4. 分布式快照](#4-分布式快照)
    - [4.1 Chandy-Lamport 算法](#41-chandy-lamport-算法)
  - [5. 一致性模型](#5-一致性模型)
    - [5.1 强一致性](#51-强一致性)
    - [5.2 最终一致性](#52-最终一致性)
  - [6. 实战案例](#6-实战案例)
    - [6.1 简化的 Paxos](#61-简化的-paxos)
  - [7. 总结](#7-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 分布式系统基础

### 1.1 CAP 定理

**CAP 三要素**：

- **C (Consistency)**: 一致性 - 所有节点看到相同数据
- **A (Availability)**: 可用性 - 系统总是响应请求
- **P (Partition Tolerance)**: 分区容错性 - 系统在网络分区时继续工作

**定理**：分布式系统最多同时满足两个。

```rust
#[derive(Debug, Clone)]
enum ConsistencyModel {
    StrongConsistency,   // CP: 强一致性
    EventualConsistency, // AP: 最终一致性
    CAP,                 // 理论上不可能
}

struct DistributedSystem {
    consistency: ConsistencyModel,
    available: bool,
    partition_tolerant: bool,
}

impl DistributedSystem {
    fn validate_cap(&self) -> bool {
        match (&self.consistency, self.available, self.partition_tolerant) {
            (ConsistencyModel::StrongConsistency, _, true) => !self.available, // CP
            (ConsistencyModel::EventualConsistency, true, _) => self.partition_tolerant, // AP
            _ => false,
        }
    }
}

fn main() {
    let cp_system = DistributedSystem {
        consistency: ConsistencyModel::StrongConsistency,
        available: false,
        partition_tolerant: true,
    };
    
    println!("CP 系统合法: {}", cp_system.validate_cap());
}
```

### 1.2 分布式系统挑战

```rust
use std::time::{Duration, Instant};

// 时钟偏差
struct Clock {
    offset: Duration,
}

impl Clock {
    fn now(&self) -> Instant {
        Instant::now() + self.offset
    }
}

// 网络延迟
struct Network {
    latency: Duration,
}

impl Network {
    fn send(&self, message: String) -> Duration {
        println!("发送消息: {}", message);
        self.latency
    }
}

fn main() {
    let clock1 = Clock { offset: Duration::from_millis(0) };
    let clock2 = Clock { offset: Duration::from_millis(100) }; // 100ms 偏差
    
    println!("时钟1: {:?}", clock1.now());
    println!("时钟2: {:?}", clock2.now());
    
    let network = Network { latency: Duration::from_millis(50) };
    let delay = network.send("Hello".to_string());
    println!("网络延迟: {:?}", delay);
}
```

---

## 2. Raft 共识算法

### 2.1 Raft 核心概念

**三种角色**：

- **Leader**: 领导者，处理所有客户端请求
- **Follower**: 跟随者，被动接收日志
- **Candidate**: 候选人，选举期间的角色

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

#[derive(Debug, Clone, PartialEq)]
enum NodeState {
    Follower,
    Candidate,
    Leader,
}

#[derive(Debug, Clone)]
struct LogEntry {
    term: u64,
    command: String,
}

struct RaftNode {
    id: usize,
    state: NodeState,
    current_term: u64,
    voted_for: Option<usize>,
    log: Vec<LogEntry>,
    commit_index: usize,
    peers: Vec<usize>,
}

impl RaftNode {
    fn new(id: usize, peers: Vec<usize>) -> Self {
        Self {
            id,
            state: NodeState::Follower,
            current_term: 0,
            voted_for: None,
            log: Vec::new(),
            commit_index: 0,
            peers,
        }
    }
    
    // 选举超时
    fn start_election(&mut self) {
        self.state = NodeState::Candidate;
        self.current_term += 1;
        self.voted_for = Some(self.id);
        
        println!("节点 {} 发起选举，任期 {}", self.id, self.current_term);
    }
    
    // 请求投票
    fn request_vote(&self, term: u64, candidate_id: usize) -> bool {
        if term < self.current_term {
            return false; // 拒绝旧任期
        }
        
        if self.voted_for.is_none() || self.voted_for == Some(candidate_id) {
            println!("节点 {} 投票给 {}", self.id, candidate_id);
            return true;
        }
        
        false
    }
    
    // 成为领导者
    fn become_leader(&mut self) {
        self.state = NodeState::Leader;
        println!("节点 {} 成为领导者", self.id);
    }
    
    // 追加日志
    fn append_entries(&mut self, term: u64, leader_id: usize, entries: Vec<LogEntry>) -> bool {
        if term < self.current_term {
            return false; // 拒绝旧任期
        }
        
        // 更新状态
        if self.state != NodeState::Follower {
            self.state = NodeState::Follower;
        }
        self.current_term = term;
        
        // 追加日志
        self.log.extend(entries);
        
        println!("节点 {} 追加日志，当前日志长度: {}", self.id, self.log.len());
        true
    }
}

fn main() {
    let mut node1 = RaftNode::new(1, vec![2, 3]);
    let mut node2 = RaftNode::new(2, vec![1, 3]);
    let mut node3 = RaftNode::new(3, vec![1, 2]);
    
    // 模拟选举
    node1.start_election();
    let vote1 = node2.request_vote(node1.current_term, node1.id);
    let vote2 = node3.request_vote(node1.current_term, node1.id);
    
    if vote1 && vote2 {
        node1.become_leader();
    }
    
    // 模拟日志复制
    let entry = LogEntry {
        term: node1.current_term,
        command: "SET x = 10".to_string(),
    };
    
    node2.append_entries(node1.current_term, node1.id, vec![entry.clone()]);
    node3.append_entries(node1.current_term, node1.id, vec![entry]);
}
```

### 2.2 日志复制

```rust
#[derive(Debug, Clone)]
struct ReplicationState {
    next_index: HashMap<usize, usize>,  // 下一个要发送的日志索引
    match_index: HashMap<usize, usize>, // 已复制的日志索引
}

impl RaftNode {
    fn replicate_log(&mut self, repl_state: &mut ReplicationState) {
        if self.state != NodeState::Leader {
            return;
        }
        
        for &peer_id in &self.peers {
            let next_idx = *repl_state.next_index.get(&peer_id).unwrap_or(&0);
            
            if next_idx < self.log.len() {
                // 发送日志条目
                let entries = self.log[next_idx..].to_vec();
                println!("向节点 {} 复制 {} 条日志", peer_id, entries.len());
                
                // 假设成功
                repl_state.match_index.insert(peer_id, self.log.len() - 1);
                repl_state.next_index.insert(peer_id, self.log.len());
            }
        }
        
        // 更新 commit_index
        self.update_commit_index(repl_state);
    }
    
    fn update_commit_index(&mut self, repl_state: &ReplicationState) {
        // 找到大多数节点已复制的最大索引
        let mut indices: Vec<usize> = repl_state.match_index.values().copied().collect();
        indices.push(self.log.len() - 1); // 包含自己
        indices.sort();
        
        let majority_index = indices[indices.len() / 2];
        if majority_index > self.commit_index {
            self.commit_index = majority_index;
            println!("提交索引更新: {}", self.commit_index);
        }
    }
}

fn main() {
    let mut leader = RaftNode::new(1, vec![2, 3]);
    leader.become_leader();
    leader.log.push(LogEntry { term: 1, command: "CMD1".to_string() });
    leader.log.push(LogEntry { term: 1, command: "CMD2".to_string() });
    
    let mut repl_state = ReplicationState {
        next_index: HashMap::from([(2, 0), (3, 0)]),
        match_index: HashMap::new(),
    };
    
    leader.replicate_log(&mut repl_state);
}
```

---

## 3. 向量时钟与因果关系

### 3.1 Lamport 时钟

```rust
use std::cmp;

struct LamportClock {
    time: u64,
}

impl LamportClock {
    fn new() -> Self {
        Self { time: 0 }
    }
    
    // 本地事件
    fn tick(&mut self) {
        self.time += 1;
    }
    
    // 发送消息
    fn send(&mut self) -> u64 {
        self.tick();
        self.time
    }
    
    // 接收消息
    fn receive(&mut self, received_time: u64) {
        self.time = cmp::max(self.time, received_time) + 1;
    }
}

fn main() {
    let mut clock_a = LamportClock::new();
    let mut clock_b = LamportClock::new();
    
    // A 发送消息
    let msg_time = clock_a.send();
    println!("A 发送消息，时间: {}", msg_time);
    
    // B 接收消息
    clock_b.receive(msg_time);
    println!("B 接收消息，时间: {}", clock_b.time);
    
    // B 本地事件
    clock_b.tick();
    println!("B 本地事件，时间: {}", clock_b.time);
}
```

### 3.2 向量时钟

```rust
use std::collections::HashMap;

#[derive(Clone, Debug)]
struct VectorClock {
    clock: HashMap<usize, u64>,
    node_id: usize,
}

impl VectorClock {
    fn new(node_id: usize, num_nodes: usize) -> Self {
        let mut clock = HashMap::new();
        for i in 0..num_nodes {
            clock.insert(i, 0);
        }
        Self { clock, node_id }
    }
    
    // 本地事件
    fn tick(&mut self) {
        *self.clock.get_mut(&self.node_id).unwrap() += 1;
    }
    
    // 发送消息
    fn send(&mut self) -> HashMap<usize, u64> {
        self.tick();
        self.clock.clone()
    }
    
    // 接收消息
    fn receive(&mut self, received_clock: &HashMap<usize, u64>) {
        for (node, &time) in received_clock {
            let current = self.clock.get(node).copied().unwrap_or(0);
            self.clock.insert(*node, time.max(current));
        }
        self.tick();
    }
    
    // 判断因果关系
    fn happens_before(&self, other: &VectorClock) -> bool {
        let mut at_least_one_less = false;
        
        for (node, &time) in &self.clock {
            let other_time = other.clock.get(node).copied().unwrap_or(0);
            if time > other_time {
                return false; // 不满足 happens-before
            }
            if time < other_time {
                at_least_one_less = true;
            }
        }
        
        at_least_one_less
    }
    
    fn concurrent(&self, other: &VectorClock) -> bool {
        !self.happens_before(other) && !other.happens_before(self)
    }
}

fn main() {
    let mut clock_a = VectorClock::new(0, 3);
    let mut clock_b = VectorClock::new(1, 3);
    
    // A: 本地事件
    clock_a.tick();
    println!("A 本地事件: {:?}", clock_a.clock);
    
    // A -> B: 发送消息
    let msg = clock_a.send();
    println!("A 发送消息: {:?}", msg);
    
    clock_b.receive(&msg);
    println!("B 接收消息: {:?}", clock_b.clock);
    
    // 检查因果关系
    println!("A happens-before B: {}", clock_a.happens_before(&clock_b));
}
```

---

## 4. 分布式快照

### 4.1 Chandy-Lamport 算法

```rust
use std::collections::{HashMap, VecDeque};

#[derive(Clone, Debug)]
struct Message {
    from: usize,
    to: usize,
    content: String,
}

#[derive(Clone, Debug)]
struct Channel {
    messages: VecDeque<Message>,
}

impl Channel {
    fn new() -> Self {
        Self { messages: VecDeque::new() }
    }
    
    fn send(&mut self, msg: Message) {
        self.messages.push_back(msg);
    }
    
    fn receive(&mut self) -> Option<Message> {
        self.messages.pop_front()
    }
}

#[derive(Clone, Debug)]
struct Node {
    id: usize,
    state: String,
    recorded_state: Option<String>,
    recorded_channels: HashMap<usize, Vec<Message>>,
    marker_received: HashMap<usize, bool>,
}

impl Node {
    fn new(id: usize) -> Self {
        Self {
            id,
            state: format!("State_{}", id),
            recorded_state: None,
            recorded_channels: HashMap::new(),
            marker_received: HashMap::new(),
        }
    }
    
    // 收到 Marker
    fn receive_marker(&mut self, from: usize, channels: &mut HashMap<(usize, usize), Channel>) {
        if self.recorded_state.is_none() {
            // 第一次收到 Marker
            self.recorded_state = Some(self.state.clone());
            println!("节点 {} 记录状态: {}", self.id, self.state);
            
            // 向所有邻居发送 Marker
            self.send_markers(channels);
            
            // 标记通道为空
            self.recorded_channels.insert(from, Vec::new());
        } else {
            // 非第一次收到 Marker
            self.marker_received.insert(from, true);
        }
    }
    
    fn send_markers(&self, channels: &mut HashMap<(usize, usize), Channel>) {
        // 假设邻居是 [0, 1, 2] \ {self.id}
        for neighbor in 0..3 {
            if neighbor != self.id {
                let key = (self.id, neighbor);
                if let Some(channel) = channels.get_mut(&key) {
                    channel.send(Message {
                        from: self.id,
                        to: neighbor,
                        content: "MARKER".to_string(),
                    });
                }
            }
        }
    }
}

fn main() {
    let mut node0 = Node::new(0);
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    
    let mut channels: HashMap<(usize, usize), Channel> = HashMap::new();
    for i in 0..3 {
        for j in 0..3 {
            if i != j {
                channels.insert((i, j), Channel::new());
            }
        }
    }
    
    // 节点 0 发起快照
    node0.receive_marker(0, &mut channels);
    
    // 节点 1 收到 Marker
    node1.receive_marker(0, &mut channels);
    
    // 节点 2 收到 Marker
    node2.receive_marker(0, &mut channels);
    
    println!("快照完成");
}
```

---

## 5. 一致性模型

### 5.1 强一致性

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct StronglyConsistentStore {
    data: Arc<Mutex<HashMap<String, i32>>>,
}

impl StronglyConsistentStore {
    fn new() -> Self {
        Self {
            data: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn write(&self, key: String, value: i32) {
        let mut data = self.data.lock().unwrap();
        data.insert(key, value);
    }
    
    fn read(&self, key: &str) -> Option<i32> {
        let data = self.data.lock().unwrap();
        data.get(key).copied()
    }
}

fn main() {
    let store = StronglyConsistentStore::new();
    
    // 写入
    store.write("x".to_string(), 10);
    
    // 读取（总是看到最新值）
    let value = store.read("x");
    println!("读取: {:?}", value); // Some(10)
}
```

### 5.2 最终一致性

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[derive(Clone, Debug)]
struct VersionedValue {
    value: i32,
    version: u64,
    timestamp: Instant,
}

struct EventuallyConsistentStore {
    local_data: HashMap<String, VersionedValue>,
    replicas: Vec<HashMap<String, VersionedValue>>,
}

impl EventuallyConsistentStore {
    fn new(num_replicas: usize) -> Self {
        Self {
            local_data: HashMap::new(),
            replicas: vec![HashMap::new(); num_replicas],
        }
    }
    
    fn write(&mut self, key: String, value: i32) {
        let versioned_value = VersionedValue {
            value,
            version: 1,
            timestamp: Instant::now(),
        };
        
        self.local_data.insert(key.clone(), versioned_value.clone());
        
        // 异步复制到副本（简化：立即复制）
        for replica in &mut self.replicas {
            replica.insert(key.clone(), versioned_value.clone());
        }
    }
    
    fn read(&self, key: &str) -> Option<i32> {
        self.local_data.get(key).map(|v| v.value)
    }
    
    fn sync_replicas(&mut self) {
        // 解决冲突：选择版本号最大的
        for replica in &self.replicas {
            for (key, replica_value) in replica {
                if let Some(local_value) = self.local_data.get_mut(key) {
                    if replica_value.version > local_value.version {
                        *local_value = replica_value.clone();
                    }
                } else {
                    self.local_data.insert(key.clone(), replica_value.clone());
                }
            }
        }
    }
}

fn main() {
    let mut store = EventuallyConsistentStore::new(2);
    
    store.write("x".to_string(), 10);
    println!("写入后立即读取: {:?}", store.read("x"));
    
    store.sync_replicas();
    println!("同步后读取: {:?}", store.read("x"));
}
```

---

## 6. 实战案例

### 6.1 简化的 Paxos

```rust
#[derive(Clone, Debug)]
struct Proposal {
    id: u64,
    value: String,
}

struct Acceptor {
    promised_id: Option<u64>,
    accepted_proposal: Option<Proposal>,
}

impl Acceptor {
    fn new() -> Self {
        Self {
            promised_id: None,
            accepted_proposal: None,
        }
    }
    
    // Phase 1a: Prepare
    fn prepare(&mut self, proposal_id: u64) -> Result<Option<Proposal>, String> {
        if self.promised_id.is_none() || proposal_id > self.promised_id.unwrap() {
            self.promised_id = Some(proposal_id);
            Ok(self.accepted_proposal.clone())
        } else {
            Err("承诺了更高的提案 ID".to_string())
        }
    }
    
    // Phase 2a: Accept
    fn accept(&mut self, proposal: Proposal) -> Result<(), String> {
        if self.promised_id.is_none() || proposal.id >= self.promised_id.unwrap() {
            self.accepted_proposal = Some(proposal);
            Ok(())
        } else {
            Err("违反承诺".to_string())
        }
    }
}

fn main() {
    let mut acceptor1 = Acceptor::new();
    let mut acceptor2 = Acceptor::new();
    let mut acceptor3 = Acceptor::new();
    
    // Phase 1: Prepare
    let proposal_id = 1;
    let _ = acceptor1.prepare(proposal_id);
    let _ = acceptor2.prepare(proposal_id);
    let _ = acceptor3.prepare(proposal_id);
    
    println!("Prepare 阶段完成");
    
    // Phase 2: Accept
    let proposal = Proposal {
        id: proposal_id,
        value: "Value A".to_string(),
    };
    
    let _ = acceptor1.accept(proposal.clone());
    let _ = acceptor2.accept(proposal.clone());
    
    println!("Accept 阶段完成：{:?}", proposal);
}
```

---

## 7. 总结

### 核心要点

| 概念 | 用途 | Rust 实现 |
|-----|------|----------|
| **Raft** | 强一致性共识 | 状态机 + 日志复制 |
| **向量时钟** | 因果关系追踪 | HashMap |
| **分布式快照** | 全局状态捕获 | Chandy-Lamport |
| **Paxos** | 共识算法 | 两阶段协议 |

### 最佳实践

1. **容错设计**: 假设网络和节点会失败
2. **幂等性**: 操作可重复执行
3. **因果一致性**: 使用向量时钟
4. **最终一致性**: 异步复制 + 冲突解决
5. **测试**: 使用混沌工程测试

---

## 📚 参考资源

- [Raft Consensus Algorithm](https://raft.github.io/)
- [Distributed Systems for Fun and Profit](http://book.mixu.net/distsys/)
- [Time, Clocks, and the Ordering of Events](https://lamport.azurewebsites.net/pubs/time-clocks.pdf)

---

**下一步**: 学习 [并发模型实践](03_并发模型实践.md)，掌握 Rust 并发编程模型。
