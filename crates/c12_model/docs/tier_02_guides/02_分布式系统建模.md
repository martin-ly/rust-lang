# C12 Model - Tier 2: åˆ†å¸ƒå¼ç³»ç»Ÿå»ºæ¨¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 40 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C12 Model - Tier 2: åˆ†å¸ƒå¼ç³»ç»Ÿå»ºæ¨¡](#c12-model---tier-2-åˆ†å¸ƒå¼ç³»ç»Ÿå»ºæ¨¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](#1-åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€)
    - [1.1 CAP å®šç†](#11-cap-å®šç†)
    - [1.2 åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜](#12-åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜)
  - [2. Raft å…±è¯†ç®—æ³•](#2-raft-å…±è¯†ç®—æ³•)
    - [2.1 Raft æ ¸å¿ƒæ¦‚å¿µ](#21-raft-æ ¸å¿ƒæ¦‚å¿µ)
    - [2.2 æ—¥å¿—å¤åˆ¶](#22-æ—¥å¿—å¤åˆ¶)
  - [3. å‘é‡æ—¶é’Ÿä¸å› æœå…³ç³»](#3-å‘é‡æ—¶é’Ÿä¸å› æœå…³ç³»)
    - [3.1 Lamport æ—¶é’Ÿ](#31-lamport-æ—¶é’Ÿ)
    - [3.2 å‘é‡æ—¶é’Ÿ](#32-å‘é‡æ—¶é’Ÿ)
  - [4. åˆ†å¸ƒå¼å¿«ç…§](#4-åˆ†å¸ƒå¼å¿«ç…§)
    - [4.1 Chandy-Lamport ç®—æ³•](#41-chandy-lamport-ç®—æ³•)
  - [5. ä¸€è‡´æ€§æ¨¡å‹](#5-ä¸€è‡´æ€§æ¨¡å‹)
    - [5.1 å¼ºä¸€è‡´æ€§](#51-å¼ºä¸€è‡´æ€§)
    - [5.2 æœ€ç»ˆä¸€è‡´æ€§](#52-æœ€ç»ˆä¸€è‡´æ€§)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [6.1 ç®€åŒ–çš„ Paxos](#61-ç®€åŒ–çš„-paxos)
  - [7. æ€»ç»“](#7-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

### 1.1 CAP å®šç†

**CAP ä¸‰è¦ç´ **ï¼š

- **C (Consistency)**: ä¸€è‡´æ€§ - æ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒæ•°æ®
- **A (Availability)**: å¯ç”¨æ€§ - ç³»ç»Ÿæ€»æ˜¯å“åº”è¯·æ±‚
- **P (Partition Tolerance)**: åˆ†åŒºå®¹é”™æ€§ - ç³»ç»Ÿåœ¨ç½‘ç»œåˆ†åŒºæ—¶ç»§ç»­å·¥ä½œ

**å®šç†**ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿæœ€å¤šåŒæ—¶æ»¡è¶³ä¸¤ä¸ªã€‚

```rust
#[derive(Debug, Clone)]
enum ConsistencyModel {
    StrongConsistency,   // CP: å¼ºä¸€è‡´æ€§
    EventualConsistency, // AP: æœ€ç»ˆä¸€è‡´æ€§
    CAP,                 // ç†è®ºä¸Šä¸å¯èƒ½
}

struct DistributedSystem {
    consistency: ConsistencyModel,
    available: bool,
    partition_tolerant: bool,
}

impl DistributedSystem {
    fn validate_cap(&self) -> bool {
        match (&self.consistency, self.available, self.partition_tolerant) {
            (ConsistencyModel::StrongConsistency, _, true) => !self.available, // CP
            (ConsistencyModel::EventualConsistency, true, _) => self.partition_tolerant, // AP
            _ => false,
        }
    }
}

fn main() {
    let cp_system = DistributedSystem {
        consistency: ConsistencyModel::StrongConsistency,
        available: false,
        partition_tolerant: true,
    };
    
    println!("CP ç³»ç»Ÿåˆæ³•: {}", cp_system.validate_cap());
}
```

### 1.2 åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜

```rust
use std::time::{Duration, Instant};

// æ—¶é’Ÿåå·®
struct Clock {
    offset: Duration,
}

impl Clock {
    fn now(&self) -> Instant {
        Instant::now() + self.offset
    }
}

// ç½‘ç»œå»¶è¿Ÿ
struct Network {
    latency: Duration,
}

impl Network {
    fn send(&self, message: String) -> Duration {
        println!("å‘é€æ¶ˆæ¯: {}", message);
        self.latency
    }
}

fn main() {
    let clock1 = Clock { offset: Duration::from_millis(0) };
    let clock2 = Clock { offset: Duration::from_millis(100) }; // 100ms åå·®
    
    println!("æ—¶é’Ÿ1: {:?}", clock1.now());
    println!("æ—¶é’Ÿ2: {:?}", clock2.now());
    
    let network = Network { latency: Duration::from_millis(50) };
    let delay = network.send("Hello".to_string());
    println!("ç½‘ç»œå»¶è¿Ÿ: {:?}", delay);
}
```

---

## 2. Raft å…±è¯†ç®—æ³•

### 2.1 Raft æ ¸å¿ƒæ¦‚å¿µ

**ä¸‰ç§è§’è‰²**ï¼š

- **Leader**: é¢†å¯¼è€…ï¼Œå¤„ç†æ‰€æœ‰å®¢æˆ·ç«¯è¯·æ±‚
- **Follower**: è·Ÿéšè€…ï¼Œè¢«åŠ¨æ¥æ”¶æ—¥å¿—
- **Candidate**: å€™é€‰äººï¼Œé€‰ä¸¾æœŸé—´çš„è§’è‰²

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

#[derive(Debug, Clone, PartialEq)]
enum NodeState {
    Follower,
    Candidate,
    Leader,
}

#[derive(Debug, Clone)]
struct LogEntry {
    term: u64,
    command: String,
}

struct RaftNode {
    id: usize,
    state: NodeState,
    current_term: u64,
    voted_for: Option<usize>,
    log: Vec<LogEntry>,
    commit_index: usize,
    peers: Vec<usize>,
}

impl RaftNode {
    fn new(id: usize, peers: Vec<usize>) -> Self {
        Self {
            id,
            state: NodeState::Follower,
            current_term: 0,
            voted_for: None,
            log: Vec::new(),
            commit_index: 0,
            peers,
        }
    }
    
    // é€‰ä¸¾è¶…æ—¶
    fn start_election(&mut self) {
        self.state = NodeState::Candidate;
        self.current_term += 1;
        self.voted_for = Some(self.id);
        
        println!("èŠ‚ç‚¹ {} å‘èµ·é€‰ä¸¾ï¼Œä»»æœŸ {}", self.id, self.current_term);
    }
    
    // è¯·æ±‚æŠ•ç¥¨
    fn request_vote(&self, term: u64, candidate_id: usize) -> bool {
        if term < self.current_term {
            return false; // æ‹’ç»æ—§ä»»æœŸ
        }
        
        if self.voted_for.is_none() || self.voted_for == Some(candidate_id) {
            println!("èŠ‚ç‚¹ {} æŠ•ç¥¨ç»™ {}", self.id, candidate_id);
            return true;
        }
        
        false
    }
    
    // æˆä¸ºé¢†å¯¼è€…
    fn become_leader(&mut self) {
        self.state = NodeState::Leader;
        println!("èŠ‚ç‚¹ {} æˆä¸ºé¢†å¯¼è€…", self.id);
    }
    
    // è¿½åŠ æ—¥å¿—
    fn append_entries(&mut self, term: u64, leader_id: usize, entries: Vec<LogEntry>) -> bool {
        if term < self.current_term {
            return false; // æ‹’ç»æ—§ä»»æœŸ
        }
        
        // æ›´æ–°çŠ¶æ€
        if self.state != NodeState::Follower {
            self.state = NodeState::Follower;
        }
        self.current_term = term;
        
        // è¿½åŠ æ—¥å¿—
        self.log.extend(entries);
        
        println!("èŠ‚ç‚¹ {} è¿½åŠ æ—¥å¿—ï¼Œå½“å‰æ—¥å¿—é•¿åº¦: {}", self.id, self.log.len());
        true
    }
}

fn main() {
    let mut node1 = RaftNode::new(1, vec![2, 3]);
    let mut node2 = RaftNode::new(2, vec![1, 3]);
    let mut node3 = RaftNode::new(3, vec![1, 2]);
    
    // æ¨¡æ‹Ÿé€‰ä¸¾
    node1.start_election();
    let vote1 = node2.request_vote(node1.current_term, node1.id);
    let vote2 = node3.request_vote(node1.current_term, node1.id);
    
    if vote1 && vote2 {
        node1.become_leader();
    }
    
    // æ¨¡æ‹Ÿæ—¥å¿—å¤åˆ¶
    let entry = LogEntry {
        term: node1.current_term,
        command: "SET x = 10".to_string(),
    };
    
    node2.append_entries(node1.current_term, node1.id, vec![entry.clone()]);
    node3.append_entries(node1.current_term, node1.id, vec![entry]);
}
```

### 2.2 æ—¥å¿—å¤åˆ¶

```rust
#[derive(Debug, Clone)]
struct ReplicationState {
    next_index: HashMap<usize, usize>,  // ä¸‹ä¸€ä¸ªè¦å‘é€çš„æ—¥å¿—ç´¢å¼•
    match_index: HashMap<usize, usize>, // å·²å¤åˆ¶çš„æ—¥å¿—ç´¢å¼•
}

impl RaftNode {
    fn replicate_log(&mut self, repl_state: &mut ReplicationState) {
        if self.state != NodeState::Leader {
            return;
        }
        
        for &peer_id in &self.peers {
            let next_idx = *repl_state.next_index.get(&peer_id).unwrap_or(&0);
            
            if next_idx < self.log.len() {
                // å‘é€æ—¥å¿—æ¡ç›®
                let entries = self.log[next_idx..].to_vec();
                println!("å‘èŠ‚ç‚¹ {} å¤åˆ¶ {} æ¡æ—¥å¿—", peer_id, entries.len());
                
                // å‡è®¾æˆåŠŸ
                repl_state.match_index.insert(peer_id, self.log.len() - 1);
                repl_state.next_index.insert(peer_id, self.log.len());
            }
        }
        
        // æ›´æ–° commit_index
        self.update_commit_index(repl_state);
    }
    
    fn update_commit_index(&mut self, repl_state: &ReplicationState) {
        // æ‰¾åˆ°å¤§å¤šæ•°èŠ‚ç‚¹å·²å¤åˆ¶çš„æœ€å¤§ç´¢å¼•
        let mut indices: Vec<usize> = repl_state.match_index.values().copied().collect();
        indices.push(self.log.len() - 1); // åŒ…å«è‡ªå·±
        indices.sort();
        
        let majority_index = indices[indices.len() / 2];
        if majority_index > self.commit_index {
            self.commit_index = majority_index;
            println!("æäº¤ç´¢å¼•æ›´æ–°: {}", self.commit_index);
        }
    }
}

fn main() {
    let mut leader = RaftNode::new(1, vec![2, 3]);
    leader.become_leader();
    leader.log.push(LogEntry { term: 1, command: "CMD1".to_string() });
    leader.log.push(LogEntry { term: 1, command: "CMD2".to_string() });
    
    let mut repl_state = ReplicationState {
        next_index: HashMap::from([(2, 0), (3, 0)]),
        match_index: HashMap::new(),
    };
    
    leader.replicate_log(&mut repl_state);
}
```

---

## 3. å‘é‡æ—¶é’Ÿä¸å› æœå…³ç³»

### 3.1 Lamport æ—¶é’Ÿ

```rust
use std::cmp;

struct LamportClock {
    time: u64,
}

impl LamportClock {
    fn new() -> Self {
        Self { time: 0 }
    }
    
    // æœ¬åœ°äº‹ä»¶
    fn tick(&mut self) {
        self.time += 1;
    }
    
    // å‘é€æ¶ˆæ¯
    fn send(&mut self) -> u64 {
        self.tick();
        self.time
    }
    
    // æ¥æ”¶æ¶ˆæ¯
    fn receive(&mut self, received_time: u64) {
        self.time = cmp::max(self.time, received_time) + 1;
    }
}

fn main() {
    let mut clock_a = LamportClock::new();
    let mut clock_b = LamportClock::new();
    
    // A å‘é€æ¶ˆæ¯
    let msg_time = clock_a.send();
    println!("A å‘é€æ¶ˆæ¯ï¼Œæ—¶é—´: {}", msg_time);
    
    // B æ¥æ”¶æ¶ˆæ¯
    clock_b.receive(msg_time);
    println!("B æ¥æ”¶æ¶ˆæ¯ï¼Œæ—¶é—´: {}", clock_b.time);
    
    // B æœ¬åœ°äº‹ä»¶
    clock_b.tick();
    println!("B æœ¬åœ°äº‹ä»¶ï¼Œæ—¶é—´: {}", clock_b.time);
}
```

### 3.2 å‘é‡æ—¶é’Ÿ

```rust
use std::collections::HashMap;

#[derive(Clone, Debug)]
struct VectorClock {
    clock: HashMap<usize, u64>,
    node_id: usize,
}

impl VectorClock {
    fn new(node_id: usize, num_nodes: usize) -> Self {
        let mut clock = HashMap::new();
        for i in 0..num_nodes {
            clock.insert(i, 0);
        }
        Self { clock, node_id }
    }
    
    // æœ¬åœ°äº‹ä»¶
    fn tick(&mut self) {
        *self.clock.get_mut(&self.node_id).unwrap() += 1;
    }
    
    // å‘é€æ¶ˆæ¯
    fn send(&mut self) -> HashMap<usize, u64> {
        self.tick();
        self.clock.clone()
    }
    
    // æ¥æ”¶æ¶ˆæ¯
    fn receive(&mut self, received_clock: &HashMap<usize, u64>) {
        for (node, &time) in received_clock {
            let current = self.clock.get(node).copied().unwrap_or(0);
            self.clock.insert(*node, time.max(current));
        }
        self.tick();
    }
    
    // åˆ¤æ–­å› æœå…³ç³»
    fn happens_before(&self, other: &VectorClock) -> bool {
        let mut at_least_one_less = false;
        
        for (node, &time) in &self.clock {
            let other_time = other.clock.get(node).copied().unwrap_or(0);
            if time > other_time {
                return false; // ä¸æ»¡è¶³ happens-before
            }
            if time < other_time {
                at_least_one_less = true;
            }
        }
        
        at_least_one_less
    }
    
    fn concurrent(&self, other: &VectorClock) -> bool {
        !self.happens_before(other) && !other.happens_before(self)
    }
}

fn main() {
    let mut clock_a = VectorClock::new(0, 3);
    let mut clock_b = VectorClock::new(1, 3);
    
    // A: æœ¬åœ°äº‹ä»¶
    clock_a.tick();
    println!("A æœ¬åœ°äº‹ä»¶: {:?}", clock_a.clock);
    
    // A -> B: å‘é€æ¶ˆæ¯
    let msg = clock_a.send();
    println!("A å‘é€æ¶ˆæ¯: {:?}", msg);
    
    clock_b.receive(&msg);
    println!("B æ¥æ”¶æ¶ˆæ¯: {:?}", clock_b.clock);
    
    // æ£€æŸ¥å› æœå…³ç³»
    println!("A happens-before B: {}", clock_a.happens_before(&clock_b));
}
```

---

## 4. åˆ†å¸ƒå¼å¿«ç…§

### 4.1 Chandy-Lamport ç®—æ³•

```rust
use std::collections::{HashMap, VecDeque};

#[derive(Clone, Debug)]
struct Message {
    from: usize,
    to: usize,
    content: String,
}

#[derive(Clone, Debug)]
struct Channel {
    messages: VecDeque<Message>,
}

impl Channel {
    fn new() -> Self {
        Self { messages: VecDeque::new() }
    }
    
    fn send(&mut self, msg: Message) {
        self.messages.push_back(msg);
    }
    
    fn receive(&mut self) -> Option<Message> {
        self.messages.pop_front()
    }
}

#[derive(Clone, Debug)]
struct Node {
    id: usize,
    state: String,
    recorded_state: Option<String>,
    recorded_channels: HashMap<usize, Vec<Message>>,
    marker_received: HashMap<usize, bool>,
}

impl Node {
    fn new(id: usize) -> Self {
        Self {
            id,
            state: format!("State_{}", id),
            recorded_state: None,
            recorded_channels: HashMap::new(),
            marker_received: HashMap::new(),
        }
    }
    
    // æ”¶åˆ° Marker
    fn receive_marker(&mut self, from: usize, channels: &mut HashMap<(usize, usize), Channel>) {
        if self.recorded_state.is_none() {
            // ç¬¬ä¸€æ¬¡æ”¶åˆ° Marker
            self.recorded_state = Some(self.state.clone());
            println!("èŠ‚ç‚¹ {} è®°å½•çŠ¶æ€: {}", self.id, self.state);
            
            // å‘æ‰€æœ‰é‚»å±…å‘é€ Marker
            self.send_markers(channels);
            
            // æ ‡è®°é€šé“ä¸ºç©º
            self.recorded_channels.insert(from, Vec::new());
        } else {
            // éç¬¬ä¸€æ¬¡æ”¶åˆ° Marker
            self.marker_received.insert(from, true);
        }
    }
    
    fn send_markers(&self, channels: &mut HashMap<(usize, usize), Channel>) {
        // å‡è®¾é‚»å±…æ˜¯ [0, 1, 2] \ {self.id}
        for neighbor in 0..3 {
            if neighbor != self.id {
                let key = (self.id, neighbor);
                if let Some(channel) = channels.get_mut(&key) {
                    channel.send(Message {
                        from: self.id,
                        to: neighbor,
                        content: "MARKER".to_string(),
                    });
                }
            }
        }
    }
}

fn main() {
    let mut node0 = Node::new(0);
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    
    let mut channels: HashMap<(usize, usize), Channel> = HashMap::new();
    for i in 0..3 {
        for j in 0..3 {
            if i != j {
                channels.insert((i, j), Channel::new());
            }
        }
    }
    
    // èŠ‚ç‚¹ 0 å‘èµ·å¿«ç…§
    node0.receive_marker(0, &mut channels);
    
    // èŠ‚ç‚¹ 1 æ”¶åˆ° Marker
    node1.receive_marker(0, &mut channels);
    
    // èŠ‚ç‚¹ 2 æ”¶åˆ° Marker
    node2.receive_marker(0, &mut channels);
    
    println!("å¿«ç…§å®Œæˆ");
}
```

---

## 5. ä¸€è‡´æ€§æ¨¡å‹

### 5.1 å¼ºä¸€è‡´æ€§

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct StronglyConsistentStore {
    data: Arc<Mutex<HashMap<String, i32>>>,
}

impl StronglyConsistentStore {
    fn new() -> Self {
        Self {
            data: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn write(&self, key: String, value: i32) {
        let mut data = self.data.lock().unwrap();
        data.insert(key, value);
    }
    
    fn read(&self, key: &str) -> Option<i32> {
        let data = self.data.lock().unwrap();
        data.get(key).copied()
    }
}

fn main() {
    let store = StronglyConsistentStore::new();
    
    // å†™å…¥
    store.write("x".to_string(), 10);
    
    // è¯»å–ï¼ˆæ€»æ˜¯çœ‹åˆ°æœ€æ–°å€¼ï¼‰
    let value = store.read("x");
    println!("è¯»å–: {:?}", value); // Some(10)
}
```

### 5.2 æœ€ç»ˆä¸€è‡´æ€§

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[derive(Clone, Debug)]
struct VersionedValue {
    value: i32,
    version: u64,
    timestamp: Instant,
}

struct EventuallyConsistentStore {
    local_data: HashMap<String, VersionedValue>,
    replicas: Vec<HashMap<String, VersionedValue>>,
}

impl EventuallyConsistentStore {
    fn new(num_replicas: usize) -> Self {
        Self {
            local_data: HashMap::new(),
            replicas: vec![HashMap::new(); num_replicas],
        }
    }
    
    fn write(&mut self, key: String, value: i32) {
        let versioned_value = VersionedValue {
            value,
            version: 1,
            timestamp: Instant::now(),
        };
        
        self.local_data.insert(key.clone(), versioned_value.clone());
        
        // å¼‚æ­¥å¤åˆ¶åˆ°å‰¯æœ¬ï¼ˆç®€åŒ–ï¼šç«‹å³å¤åˆ¶ï¼‰
        for replica in &mut self.replicas {
            replica.insert(key.clone(), versioned_value.clone());
        }
    }
    
    fn read(&self, key: &str) -> Option<i32> {
        self.local_data.get(key).map(|v| v.value)
    }
    
    fn sync_replicas(&mut self) {
        // è§£å†³å†²çªï¼šé€‰æ‹©ç‰ˆæœ¬å·æœ€å¤§çš„
        for replica in &self.replicas {
            for (key, replica_value) in replica {
                if let Some(local_value) = self.local_data.get_mut(key) {
                    if replica_value.version > local_value.version {
                        *local_value = replica_value.clone();
                    }
                } else {
                    self.local_data.insert(key.clone(), replica_value.clone());
                }
            }
        }
    }
}

fn main() {
    let mut store = EventuallyConsistentStore::new(2);
    
    store.write("x".to_string(), 10);
    println!("å†™å…¥åç«‹å³è¯»å–: {:?}", store.read("x"));
    
    store.sync_replicas();
    println!("åŒæ­¥åè¯»å–: {:?}", store.read("x"));
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### 6.1 ç®€åŒ–çš„ Paxos

```rust
#[derive(Clone, Debug)]
struct Proposal {
    id: u64,
    value: String,
}

struct Acceptor {
    promised_id: Option<u64>,
    accepted_proposal: Option<Proposal>,
}

impl Acceptor {
    fn new() -> Self {
        Self {
            promised_id: None,
            accepted_proposal: None,
        }
    }
    
    // Phase 1a: Prepare
    fn prepare(&mut self, proposal_id: u64) -> Result<Option<Proposal>, String> {
        if self.promised_id.is_none() || proposal_id > self.promised_id.unwrap() {
            self.promised_id = Some(proposal_id);
            Ok(self.accepted_proposal.clone())
        } else {
            Err("æ‰¿è¯ºäº†æ›´é«˜çš„ææ¡ˆ ID".to_string())
        }
    }
    
    // Phase 2a: Accept
    fn accept(&mut self, proposal: Proposal) -> Result<(), String> {
        if self.promised_id.is_none() || proposal.id >= self.promised_id.unwrap() {
            self.accepted_proposal = Some(proposal);
            Ok(())
        } else {
            Err("è¿åæ‰¿è¯º".to_string())
        }
    }
}

fn main() {
    let mut acceptor1 = Acceptor::new();
    let mut acceptor2 = Acceptor::new();
    let mut acceptor3 = Acceptor::new();
    
    // Phase 1: Prepare
    let proposal_id = 1;
    let _ = acceptor1.prepare(proposal_id);
    let _ = acceptor2.prepare(proposal_id);
    let _ = acceptor3.prepare(proposal_id);
    
    println!("Prepare é˜¶æ®µå®Œæˆ");
    
    // Phase 2: Accept
    let proposal = Proposal {
        id: proposal_id,
        value: "Value A".to_string(),
    };
    
    let _ = acceptor1.accept(proposal.clone());
    let _ = acceptor2.accept(proposal.clone());
    
    println!("Accept é˜¶æ®µå®Œæˆï¼š{:?}", proposal);
}
```

---

## 7. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

| æ¦‚å¿µ | ç”¨é€” | Rust å®ç° |
|-----|------|----------|
| **Raft** | å¼ºä¸€è‡´æ€§å…±è¯† | çŠ¶æ€æœº + æ—¥å¿—å¤åˆ¶ |
| **å‘é‡æ—¶é’Ÿ** | å› æœå…³ç³»è¿½è¸ª | HashMap |
| **åˆ†å¸ƒå¼å¿«ç…§** | å…¨å±€çŠ¶æ€æ•è· | Chandy-Lamport |
| **Paxos** | å…±è¯†ç®—æ³• | ä¸¤é˜¶æ®µåè®® |

### æœ€ä½³å®è·µ

1. **å®¹é”™è®¾è®¡**: å‡è®¾ç½‘ç»œå’ŒèŠ‚ç‚¹ä¼šå¤±è´¥
2. **å¹‚ç­‰æ€§**: æ“ä½œå¯é‡å¤æ‰§è¡Œ
3. **å› æœä¸€è‡´æ€§**: ä½¿ç”¨å‘é‡æ—¶é’Ÿ
4. **æœ€ç»ˆä¸€è‡´æ€§**: å¼‚æ­¥å¤åˆ¶ + å†²çªè§£å†³
5. **æµ‹è¯•**: ä½¿ç”¨æ··æ²Œå·¥ç¨‹æµ‹è¯•

---

## ğŸ“š å‚è€ƒèµ„æº

- [Raft Consensus Algorithm](https://raft.github.io/)
- [Distributed Systems for Fun and Profit](http://book.mixu.net/distsys/)
- [Time, Clocks, and the Ordering of Events](https://lamport.azurewebsites.net/pubs/time-clocks.pdf)

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [å¹¶å‘æ¨¡å‹å®è·µ](03_å¹¶å‘æ¨¡å‹å®è·µ.md)ï¼ŒæŒæ¡ Rust å¹¶å‘ç¼–ç¨‹æ¨¡å‹ã€‚
