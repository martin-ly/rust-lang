# C12 Model - Tier 2: 并发模型实践

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 35 分钟

---

## 📊 目录

- [C12 Model - Tier 2: 并发模型实践](#c12-model---tier-2-并发模型实践)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 并发模型概述](#1-并发模型概述)
    - [1.1 并发 vs 并行](#11-并发-vs-并行)
    - [1.2 并发模型分类](#12-并发模型分类)
  - [2. CSP 模型](#2-csp-模型)
    - [2.1 通道通信](#21-通道通信)
    - [2.2 多生产者多消费者](#22-多生产者多消费者)
    - [2.3 Select 模式](#23-select-模式)
  - [3. Actor 模型](#3-actor-模型)
    - [3.1 基础 Actor](#31-基础-actor)
    - [3.2 Actor 层次结构](#32-actor-层次结构)
  - [4. 共享内存模型](#4-共享内存模型)
    - [4.1 互斥锁](#41-互斥锁)
    - [4.2 读写锁](#42-读写锁)
    - [4.3 原子操作](#43-原子操作)
  - [5. 并发模式](#5-并发模式)
    - [5.1 生产者-消费者](#51-生产者-消费者)
    - [5.2 工作窃取](#52-工作窃取)
    - [5.3 屏障同步](#53-屏障同步)
  - [6. 实战案例](#6-实战案例)
    - [6.1 并发 Web 爬虫](#61-并发-web-爬虫)
    - [6.2 并行数据处理](#62-并行数据处理)
    - [6.3 任务调度器](#63-任务调度器)
  - [7. 总结](#7-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

## 📋 目录

- [C12 Model - Tier 2: 并发模型实践](#c12-model---tier-2-并发模型实践)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1. 并发模型概述](#1-并发模型概述)
    - [1.1 并发 vs 并行](#11-并发-vs-并行)
    - [1.2 并发模型分类](#12-并发模型分类)
  - [2. CSP 模型](#2-csp-模型)
    - [2.1 通道通信](#21-通道通信)
    - [2.2 多生产者多消费者](#22-多生产者多消费者)
    - [2.3 Select 模式](#23-select-模式)
  - [3. Actor 模型](#3-actor-模型)
    - [3.1 基础 Actor](#31-基础-actor)
    - [3.2 Actor 层次结构](#32-actor-层次结构)
  - [4. 共享内存模型](#4-共享内存模型)
    - [4.1 互斥锁](#41-互斥锁)
    - [4.2 读写锁](#42-读写锁)
    - [4.3 原子操作](#43-原子操作)
  - [5. 并发模式](#5-并发模式)
    - [5.1 生产者-消费者](#51-生产者-消费者)
    - [5.2 工作窃取](#52-工作窃取)
    - [5.3 屏障同步](#53-屏障同步)
  - [6. 实战案例](#6-实战案例)
    - [6.1 并发 Web 爬虫](#61-并发-web-爬虫)
    - [6.2 并行数据处理](#62-并行数据处理)
    - [6.3 任务调度器](#63-任务调度器)
  - [7. 总结](#7-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 并发模型概述

### 1.1 并发 vs 并行

```rust
use std::thread;
use std::time::Duration;

// 并发：任务交替执行
fn concurrent_tasks() {
    let handle1 = thread::spawn(|| {
        for i in 0..5 {
            println!("任务1: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    let handle2 = thread::spawn(|| {
        for i in 0..5 {
            println!("任务2: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
}

// 并行：任务同时执行
fn parallel_tasks() {
    use rayon::prelude::*;
    
    let numbers: Vec<i32> = (0..100).collect();
    let sum: i32 = numbers.par_iter().sum();
    println!("并行求和: {}", sum);
}

fn main() {
    println!("=== 并发示例 ===");
    concurrent_tasks();
    
    println!("\n=== 并行示例 ===");
    parallel_tasks();
}
```

### 1.2 并发模型分类

| 模型 | 通信方式 | 代表语言 | Rust 实现 |
|-----|---------|---------|----------|
| **CSP** | 通道通信 | Go | `std::sync::mpsc` |
| **Actor** | 消息传递 | Erlang | Actix, Tokio |
| **共享内存** | 锁与原子操作 | C++, Java | `Mutex`, `Arc` |

---

## 2. CSP 模型

### 2.1 通道通信

```rust
use std::sync::mpsc;
use std::thread;

fn csp_example() {
    let (tx, rx) = mpsc::channel();
    
    // 生产者
    let producer = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
            println!("生产: {}", i);
        }
    });
    
    // 消费者
    let consumer = thread::spawn(move || {
        for received in rx {
            println!("消费: {}", received);
        }
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}

fn main() {
    csp_example();
}
```

### 2.2 多生产者多消费者

```rust
use crossbeam::channel;
use std::thread;

fn mpmc_example() {
    let (tx, rx) = channel::unbounded();
    
    // 3 个生产者
    let mut producers = vec![];
    for id in 0..3 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            for i in 0..3 {
                tx.send(format!("P{}-{}", id, i)).unwrap();
            }
        });
        producers.push(handle);
    }
    drop(tx); // 关闭发送端
    
    // 2 个消费者
    let mut consumers = vec![];
    for id in 0..2 {
        let rx = rx.clone();
        let handle = thread::spawn(move || {
            while let Ok(msg) = rx.recv() {
                println!("C{} 消费: {}", id, msg);
            }
        });
        consumers.push(handle);
    }
    
    for h in producers { h.join().unwrap(); }
    for h in consumers { h.join().unwrap(); }
}

fn main() {
    mpmc_example();
}
```

### 2.3 Select 模式

```rust
use crossbeam::channel;
use crossbeam::select;
use std::thread;
use std::time::Duration;

fn select_example() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();
    
    // 发送者 1
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(100));
        tx1.send("Message 1").unwrap();
    });
    
    // 发送者 2
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(200));
        tx2.send("Message 2").unwrap();
    });
    
    // 接收者（选择第一个到达的消息）
    loop {
        select! {
            recv(rx1) -> msg => {
                if let Ok(m) = msg {
                    println!("收到来自通道1: {}", m);
                }
                break;
            }
            recv(rx2) -> msg => {
                if let Ok(m) = msg {
                    println!("收到来自通道2: {}", m);
                }
                break;
            }
        }
    }
}

fn main() {
    select_example();
}
```

---

## 3. Actor 模型

### 3.1 基础 Actor

```rust
use tokio::sync::mpsc;

enum ActorMessage {
    Increment,
    Decrement,
    GetValue(mpsc::Sender<i32>),
}

struct CounterActor {
    receiver: mpsc::Receiver<ActorMessage>,
    value: i32,
}

impl CounterActor {
    fn new(receiver: mpsc::Receiver<ActorMessage>) -> Self {
        Self { receiver, value: 0 }
    }
    
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                ActorMessage::Increment => {
                    self.value += 1;
                    println!("值: {}", self.value);
                }
                ActorMessage::Decrement => {
                    self.value -= 1;
                    println!("值: {}", self.value);
                }
                ActorMessage::GetValue(reply) => {
                    let _ = reply.send(self.value).await;
                }
            }
        }
    }
}

#[derive(Clone)]
struct CounterHandle {
    sender: mpsc::Sender<ActorMessage>,
}

impl CounterHandle {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel(32);
        let actor = CounterActor::new(receiver);
        tokio::spawn(actor.run());
        Self { sender }
    }
    
    async fn increment(&self) {
        let _ = self.sender.send(ActorMessage::Increment).await;
    }
    
    async fn get_value(&self) -> i32 {
        let (tx, mut rx) = mpsc::channel(1);
        let _ = self.sender.send(ActorMessage::GetValue(tx)).await;
        rx.recv().await.unwrap_or(0)
    }
}

#[tokio::main]
async fn main() {
    let counter = CounterHandle::new();
    
    counter.increment().await;
    counter.increment().await;
    
    let value = counter.get_value().await;
    println!("最终值: {}", value);
}
```

### 3.2 Actor 层次结构

```rust
use tokio::sync::mpsc;

enum SupervisorMessage {
    CreateWorker(String),
    SendToWorker(String, String),
}

enum WorkerMessage {
    Process(String),
}

struct WorkerActor {
    id: String,
    receiver: mpsc::Receiver<WorkerMessage>,
}

impl WorkerActor {
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                WorkerMessage::Process(data) => {
                    println!("Worker {} 处理: {}", self.id, data);
                }
            }
        }
    }
}

struct SupervisorActor {
    receiver: mpsc::Receiver<SupervisorMessage>,
    workers: std::collections::HashMap<String, mpsc::Sender<WorkerMessage>>,
}

impl SupervisorActor {
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                SupervisorMessage::CreateWorker(id) => {
                    let (tx, rx) = mpsc::channel(32);
                    self.workers.insert(id.clone(), tx);
                    
                    let worker = WorkerActor { id, receiver: rx };
                    tokio::spawn(worker.run());
                }
                SupervisorMessage::SendToWorker(worker_id, data) => {
                    if let Some(tx) = self.workers.get(&worker_id) {
                        let _ = tx.send(WorkerMessage::Process(data)).await;
                    }
                }
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(32);
    let supervisor = SupervisorActor {
        receiver: rx,
        workers: std::collections::HashMap::new(),
    };
    
    tokio::spawn(supervisor.run());
    
    // 创建 Worker
    tx.send(SupervisorMessage::CreateWorker("worker1".to_string())).await.unwrap();
    
    // 发送消息
    tx.send(SupervisorMessage::SendToWorker("worker1".to_string(), "Hello".to_string())).await.unwrap();
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

---

## 4. 共享内存模型

### 4.1 互斥锁

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", *counter.lock().unwrap());
}

fn main() {
    mutex_example();
}
```

### 4.2 读写锁

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // 多个读者
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let d = data.read().unwrap();
            println!("读者 {} 读取: {:?}", i, *d);
        });
        handles.push(handle);
    }
    
    // 一个写者
    let data_clone = Arc::clone(&data);
    let writer = thread::spawn(move || {
        let mut d = data_clone.write().unwrap();
        d.push(4);
        println!("写者添加元素");
    });
    
    for handle in handles {
        handle.join().unwrap();
    }
    writer.join().unwrap();
    
    println!("最终数据: {:?}", *data.read().unwrap());
}

fn main() {
    rwlock_example();
}
```

### 4.3 原子操作

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn atomic_example() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("原子计数: {}", counter.load(Ordering::SeqCst));
}

fn main() {
    atomic_example();
}
```

---

## 5. 并发模式

### 5.1 生产者-消费者

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn producer_consumer() {
    let (tx, rx) = channel::bounded(10);
    
    // 生产者
    let producer = thread::spawn(move || {
        for i in 0..20 {
            tx.send(i).unwrap();
            println!("生产: {}", i);
            thread::sleep(Duration::from_millis(50));
        }
    });
    
    // 消费者
    let consumer = thread::spawn(move || {
        while let Ok(item) = rx.recv() {
            println!("消费: {}", item);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}

fn main() {
    producer_consumer();
}
```

### 5.2 工作窃取

```rust
use rayon::prelude::*;

fn work_stealing_example() {
    let numbers: Vec<i32> = (1..=100).collect();
    
    // Rayon 自动使用工作窃取调度
    let sum: i32 = numbers.par_iter()
        .map(|&x| {
            // 模拟耗时操作
            std::thread::sleep(std::time::Duration::from_millis(10));
            x * 2
        })
        .sum();
    
    println!("总和: {}", sum);
}

fn main() {
    work_stealing_example();
}
```

### 5.3 屏障同步

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn barrier_example() {
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];
    
    for i in 0..3 {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            println!("线程 {} 到达屏障前", i);
            barrier.wait();
            println!("线程 {} 通过屏障", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}

fn main() {
    barrier_example();
}
```

---

## 6. 实战案例

### 6.1 并发 Web 爬虫

```rust
use tokio::task::JoinSet;
use std::collections::HashSet;

async fn fetch_url(url: &str) -> Result<String, Box<dyn std::error::Error>> {
    // 模拟 HTTP 请求
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    Ok(format!("Content from {}", url))
}

async fn concurrent_crawler(urls: Vec<String>) {
    let mut tasks = JoinSet::new();
    
    for url in urls {
        tasks.spawn(async move {
            match fetch_url(&url).await {
                Ok(content) => {
                    println!("✅ {}: {} 字节", url, content.len());
                }
                Err(e) => {
                    eprintln!("❌ {}: {}", url, e);
                }
            }
        });
    }
    
    while let Some(_) = tasks.join_next().await {}
}

#[tokio::main]
async fn main() {
    let urls = vec![
        "https://example1.com".to_string(),
        "https://example2.com".to_string(),
        "https://example3.com".to_string(),
    ];
    
    concurrent_crawler(urls).await;
}
```

### 6.2 并行数据处理

```rust
use rayon::prelude::*;

#[derive(Debug)]
struct Record {
    id: usize,
    value: i32,
}

fn parallel_data_processing() {
    let records: Vec<Record> = (0..1000)
        .map(|i| Record { id: i, value: i as i32 * 2 })
        .collect();
    
    // 并行过滤与映射
    let filtered: Vec<_> = records
        .par_iter()
        .filter(|r| r.value % 2 == 0)
        .map(|r| Record { id: r.id, value: r.value * 2 })
        .collect();
    
    println!("处理后记录数: {}", filtered.len());
    
    // 并行聚合
    let sum: i32 = filtered.par_iter().map(|r| r.value).sum();
    println!("总和: {}", sum);
}

fn main() {
    parallel_data_processing();
}
```

### 6.3 任务调度器

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

async fn rate_limited_tasks() {
    let semaphore = Arc::new(Semaphore::new(3)); // 最多 3 个并发任务
    let mut tasks = vec![];
    
    for i in 0..10 {
        let permit = Arc::clone(&semaphore);
        let task = tokio::spawn(async move {
            let _permit = permit.acquire().await.unwrap();
            println!("任务 {} 开始", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            println!("任务 {} 完成", i);
        });
        tasks.push(task);
    }
    
    for task in tasks {
        task.await.unwrap();
    }
}

#[tokio::main]
async fn main() {
    rate_limited_tasks().await;
}
```

---

## 7. 总结

### 核心要点

| 模型 | 优势 | 劣势 | 适用场景 |
|-----|------|------|---------|
| **CSP** | 解耦、易测试 | 通道开销 | 管道处理 |
| **Actor** | 容错、扩展性 | 调试困难 | 分布式系统 |
| **共享内存** | 性能高 | 竞态风险 | 紧密耦合 |

### 最佳实践

1. **优先消息传递**: 避免共享状态
2. **最小化锁作用域**: 尽早释放锁
3. **使用原子操作**: 简单计数器
4. **工作窃取**: CPU 密集型任务
5. **异步 I/O**: 网络与文件操作

---

## 📚 参考资源

- [CSP: Communicating Sequential Processes](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)
- [Actor Model](https://en.wikipedia.org/wiki/Actor_model)
- [Rust Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)

---

**下一步**: 学习 [机器学习建模](04_机器学习建模.md)，探索 Rust 机器学习生态。
