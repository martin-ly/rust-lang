# C12 Model - Tier 2: å¹¶å‘æ¨¡å‹å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 35 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C12 Model - Tier 2: å¹¶å‘æ¨¡å‹å®è·µ](#c12-model---tier-2-å¹¶å‘æ¨¡å‹å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¹¶å‘æ¨¡å‹æ¦‚è¿°](#1-å¹¶å‘æ¨¡å‹æ¦‚è¿°)
    - [1.1 å¹¶å‘ vs å¹¶è¡Œ](#11-å¹¶å‘-vs-å¹¶è¡Œ)
    - [1.2 å¹¶å‘æ¨¡å‹åˆ†ç±»](#12-å¹¶å‘æ¨¡å‹åˆ†ç±»)
  - [2. CSP æ¨¡å‹](#2-csp-æ¨¡å‹)
    - [2.1 é€šé“é€šä¿¡](#21-é€šé“é€šä¿¡)
    - [2.2 å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…](#22-å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…)
    - [2.3 Select æ¨¡å¼](#23-select-æ¨¡å¼)
  - [3. Actor æ¨¡å‹](#3-actor-æ¨¡å‹)
    - [3.1 åŸºç¡€ Actor](#31-åŸºç¡€-actor)
    - [3.2 Actor å±‚æ¬¡ç»“æ„](#32-actor-å±‚æ¬¡ç»“æ„)
  - [4. å…±äº«å†…å­˜æ¨¡å‹](#4-å…±äº«å†…å­˜æ¨¡å‹)
    - [4.1 äº’æ–¥é”](#41-äº’æ–¥é”)
    - [4.2 è¯»å†™é”](#42-è¯»å†™é”)
    - [4.3 åŸå­æ“ä½œ](#43-åŸå­æ“ä½œ)
  - [5. å¹¶å‘æ¨¡å¼](#5-å¹¶å‘æ¨¡å¼)
    - [5.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…](#51-ç”Ÿäº§è€…-æ¶ˆè´¹è€…)
    - [5.2 å·¥ä½œçªƒå–](#52-å·¥ä½œçªƒå–)
    - [5.3 å±éšœåŒæ­¥](#53-å±éšœåŒæ­¥)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [6.1 å¹¶å‘ Web çˆ¬è™«](#61-å¹¶å‘-web-çˆ¬è™«)
    - [6.2 å¹¶è¡Œæ•°æ®å¤„ç†](#62-å¹¶è¡Œæ•°æ®å¤„ç†)
    - [6.3 ä»»åŠ¡è°ƒåº¦å™¨](#63-ä»»åŠ¡è°ƒåº¦å™¨)
  - [7. æ€»ç»“](#7-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. å¹¶å‘æ¨¡å‹æ¦‚è¿°

### 1.1 å¹¶å‘ vs å¹¶è¡Œ

```rust
use std::thread;
use std::time::Duration;

// å¹¶å‘ï¼šä»»åŠ¡äº¤æ›¿æ‰§è¡Œ
fn concurrent_tasks() {
    let handle1 = thread::spawn(|| {
        for i in 0..5 {
            println!("ä»»åŠ¡1: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    let handle2 = thread::spawn(|| {
        for i in 0..5 {
            println!("ä»»åŠ¡2: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
}

// å¹¶è¡Œï¼šä»»åŠ¡åŒæ—¶æ‰§è¡Œ
fn parallel_tasks() {
    use rayon::prelude::*;
    
    let numbers: Vec<i32> = (0..100).collect();
    let sum: i32 = numbers.par_iter().sum();
    println!("å¹¶è¡Œæ±‚å’Œ: {}", sum);
}

fn main() {
    println!("=== å¹¶å‘ç¤ºä¾‹ ===");
    concurrent_tasks();
    
    println!("\n=== å¹¶è¡Œç¤ºä¾‹ ===");
    parallel_tasks();
}
```

### 1.2 å¹¶å‘æ¨¡å‹åˆ†ç±»

| æ¨¡å‹ | é€šä¿¡æ–¹å¼ | ä»£è¡¨è¯­è¨€ | Rust å®ç° |
|-----|---------|---------|----------|
| **CSP** | é€šé“é€šä¿¡ | Go | `std::sync::mpsc` |
| **Actor** | æ¶ˆæ¯ä¼ é€’ | Erlang | Actix, Tokio |
| **å…±äº«å†…å­˜** | é”ä¸åŸå­æ“ä½œ | C++, Java | `Mutex`, `Arc` |

---

## 2. CSP æ¨¡å‹

### 2.1 é€šé“é€šä¿¡

```rust
use std::sync::mpsc;
use std::thread;

fn csp_example() {
    let (tx, rx) = mpsc::channel();
    
    // ç”Ÿäº§è€…
    let producer = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
            println!("ç”Ÿäº§: {}", i);
        }
    });
    
    // æ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        for received in rx {
            println!("æ¶ˆè´¹: {}", received);
        }
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}

fn main() {
    csp_example();
}
```

### 2.2 å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…

```rust
use crossbeam::channel;
use std::thread;

fn mpmc_example() {
    let (tx, rx) = channel::unbounded();
    
    // 3 ä¸ªç”Ÿäº§è€…
    let mut producers = vec![];
    for id in 0..3 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            for i in 0..3 {
                tx.send(format!("P{}-{}", id, i)).unwrap();
            }
        });
        producers.push(handle);
    }
    drop(tx); // å…³é—­å‘é€ç«¯
    
    // 2 ä¸ªæ¶ˆè´¹è€…
    let mut consumers = vec![];
    for id in 0..2 {
        let rx = rx.clone();
        let handle = thread::spawn(move || {
            while let Ok(msg) = rx.recv() {
                println!("C{} æ¶ˆè´¹: {}", id, msg);
            }
        });
        consumers.push(handle);
    }
    
    for h in producers { h.join().unwrap(); }
    for h in consumers { h.join().unwrap(); }
}

fn main() {
    mpmc_example();
}
```

### 2.3 Select æ¨¡å¼

```rust
use crossbeam::channel;
use crossbeam::select;
use std::thread;
use std::time::Duration;

fn select_example() {
    let (tx1, rx1) = channel::unbounded();
    let (tx2, rx2) = channel::unbounded();
    
    // å‘é€è€… 1
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(100));
        tx1.send("Message 1").unwrap();
    });
    
    // å‘é€è€… 2
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(200));
        tx2.send("Message 2").unwrap();
    });
    
    // æ¥æ”¶è€…ï¼ˆé€‰æ‹©ç¬¬ä¸€ä¸ªåˆ°è¾¾çš„æ¶ˆæ¯ï¼‰
    loop {
        select! {
            recv(rx1) -> msg => {
                if let Ok(m) = msg {
                    println!("æ”¶åˆ°æ¥è‡ªé€šé“1: {}", m);
                }
                break;
            }
            recv(rx2) -> msg => {
                if let Ok(m) = msg {
                    println!("æ”¶åˆ°æ¥è‡ªé€šé“2: {}", m);
                }
                break;
            }
        }
    }
}

fn main() {
    select_example();
}
```

---

## 3. Actor æ¨¡å‹

### 3.1 åŸºç¡€ Actor

```rust
use tokio::sync::mpsc;

enum ActorMessage {
    Increment,
    Decrement,
    GetValue(mpsc::Sender<i32>),
}

struct CounterActor {
    receiver: mpsc::Receiver<ActorMessage>,
    value: i32,
}

impl CounterActor {
    fn new(receiver: mpsc::Receiver<ActorMessage>) -> Self {
        Self { receiver, value: 0 }
    }
    
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                ActorMessage::Increment => {
                    self.value += 1;
                    println!("å€¼: {}", self.value);
                }
                ActorMessage::Decrement => {
                    self.value -= 1;
                    println!("å€¼: {}", self.value);
                }
                ActorMessage::GetValue(reply) => {
                    let _ = reply.send(self.value).await;
                }
            }
        }
    }
}

#[derive(Clone)]
struct CounterHandle {
    sender: mpsc::Sender<ActorMessage>,
}

impl CounterHandle {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel(32);
        let actor = CounterActor::new(receiver);
        tokio::spawn(actor.run());
        Self { sender }
    }
    
    async fn increment(&self) {
        let _ = self.sender.send(ActorMessage::Increment).await;
    }
    
    async fn get_value(&self) -> i32 {
        let (tx, mut rx) = mpsc::channel(1);
        let _ = self.sender.send(ActorMessage::GetValue(tx)).await;
        rx.recv().await.unwrap_or(0)
    }
}

#[tokio::main]
async fn main() {
    let counter = CounterHandle::new();
    
    counter.increment().await;
    counter.increment().await;
    
    let value = counter.get_value().await;
    println!("æœ€ç»ˆå€¼: {}", value);
}
```

### 3.2 Actor å±‚æ¬¡ç»“æ„

```rust
use tokio::sync::mpsc;

enum SupervisorMessage {
    CreateWorker(String),
    SendToWorker(String, String),
}

enum WorkerMessage {
    Process(String),
}

struct WorkerActor {
    id: String,
    receiver: mpsc::Receiver<WorkerMessage>,
}

impl WorkerActor {
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                WorkerMessage::Process(data) => {
                    println!("Worker {} å¤„ç†: {}", self.id, data);
                }
            }
        }
    }
}

struct SupervisorActor {
    receiver: mpsc::Receiver<SupervisorMessage>,
    workers: std::collections::HashMap<String, mpsc::Sender<WorkerMessage>>,
}

impl SupervisorActor {
    async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            match msg {
                SupervisorMessage::CreateWorker(id) => {
                    let (tx, rx) = mpsc::channel(32);
                    self.workers.insert(id.clone(), tx);
                    
                    let worker = WorkerActor { id, receiver: rx };
                    tokio::spawn(worker.run());
                }
                SupervisorMessage::SendToWorker(worker_id, data) => {
                    if let Some(tx) = self.workers.get(&worker_id) {
                        let _ = tx.send(WorkerMessage::Process(data)).await;
                    }
                }
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(32);
    let supervisor = SupervisorActor {
        receiver: rx,
        workers: std::collections::HashMap::new(),
    };
    
    tokio::spawn(supervisor.run());
    
    // åˆ›å»º Worker
    tx.send(SupervisorMessage::CreateWorker("worker1".to_string())).await.unwrap();
    
    // å‘é€æ¶ˆæ¯
    tx.send(SupervisorMessage::SendToWorker("worker1".to_string(), "Hello".to_string())).await.unwrap();
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

---

## 4. å…±äº«å†…å­˜æ¨¡å‹

### 4.1 äº’æ–¥é”

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().unwrap());
}

fn main() {
    mutex_example();
}
```

### 4.2 è¯»å†™é”

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // å¤šä¸ªè¯»è€…
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let d = data.read().unwrap();
            println!("è¯»è€… {} è¯»å–: {:?}", i, *d);
        });
        handles.push(handle);
    }
    
    // ä¸€ä¸ªå†™è€…
    let data_clone = Arc::clone(&data);
    let writer = thread::spawn(move || {
        let mut d = data_clone.write().unwrap();
        d.push(4);
        println!("å†™è€…æ·»åŠ å…ƒç´ ");
    });
    
    for handle in handles {
        handle.join().unwrap();
    }
    writer.join().unwrap();
    
    println!("æœ€ç»ˆæ•°æ®: {:?}", *data.read().unwrap());
}

fn main() {
    rwlock_example();
}
```

### 4.3 åŸå­æ“ä½œ

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn atomic_example() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("åŸå­è®¡æ•°: {}", counter.load(Ordering::SeqCst));
}

fn main() {
    atomic_example();
}
```

---

## 5. å¹¶å‘æ¨¡å¼

### 5.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…

```rust
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn producer_consumer() {
    let (tx, rx) = channel::bounded(10);
    
    // ç”Ÿäº§è€…
    let producer = thread::spawn(move || {
        for i in 0..20 {
            tx.send(i).unwrap();
            println!("ç”Ÿäº§: {}", i);
            thread::sleep(Duration::from_millis(50));
        }
    });
    
    // æ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        while let Ok(item) = rx.recv() {
            println!("æ¶ˆè´¹: {}", item);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}

fn main() {
    producer_consumer();
}
```

### 5.2 å·¥ä½œçªƒå–

```rust
use rayon::prelude::*;

fn work_stealing_example() {
    let numbers: Vec<i32> = (1..=100).collect();
    
    // Rayon è‡ªåŠ¨ä½¿ç”¨å·¥ä½œçªƒå–è°ƒåº¦
    let sum: i32 = numbers.par_iter()
        .map(|&x| {
            // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
            std::thread::sleep(std::time::Duration::from_millis(10));
            x * 2
        })
        .sum();
    
    println!("æ€»å’Œ: {}", sum);
}

fn main() {
    work_stealing_example();
}
```

### 5.3 å±éšœåŒæ­¥

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn barrier_example() {
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];
    
    for i in 0..3 {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} åˆ°è¾¾å±éšœå‰", i);
            barrier.wait();
            println!("çº¿ç¨‹ {} é€šè¿‡å±éšœ", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}

fn main() {
    barrier_example();
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### 6.1 å¹¶å‘ Web çˆ¬è™«

```rust
use tokio::task::JoinSet;
use std::collections::HashSet;

async fn fetch_url(url: &str) -> Result<String, Box<dyn std::error::Error>> {
    // æ¨¡æ‹Ÿ HTTP è¯·æ±‚
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    Ok(format!("Content from {}", url))
}

async fn concurrent_crawler(urls: Vec<String>) {
    let mut tasks = JoinSet::new();
    
    for url in urls {
        tasks.spawn(async move {
            match fetch_url(&url).await {
                Ok(content) => {
                    println!("âœ… {}: {} å­—èŠ‚", url, content.len());
                }
                Err(e) => {
                    eprintln!("âŒ {}: {}", url, e);
                }
            }
        });
    }
    
    while let Some(_) = tasks.join_next().await {}
}

#[tokio::main]
async fn main() {
    let urls = vec![
        "https://example1.com".to_string(),
        "https://example2.com".to_string(),
        "https://example3.com".to_string(),
    ];
    
    concurrent_crawler(urls).await;
}
```

### 6.2 å¹¶è¡Œæ•°æ®å¤„ç†

```rust
use rayon::prelude::*;

#[derive(Debug)]
struct Record {
    id: usize,
    value: i32,
}

fn parallel_data_processing() {
    let records: Vec<Record> = (0..1000)
        .map(|i| Record { id: i, value: i as i32 * 2 })
        .collect();
    
    // å¹¶è¡Œè¿‡æ»¤ä¸æ˜ å°„
    let filtered: Vec<_> = records
        .par_iter()
        .filter(|r| r.value % 2 == 0)
        .map(|r| Record { id: r.id, value: r.value * 2 })
        .collect();
    
    println!("å¤„ç†åè®°å½•æ•°: {}", filtered.len());
    
    // å¹¶è¡Œèšåˆ
    let sum: i32 = filtered.par_iter().map(|r| r.value).sum();
    println!("æ€»å’Œ: {}", sum);
}

fn main() {
    parallel_data_processing();
}
```

### 6.3 ä»»åŠ¡è°ƒåº¦å™¨

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

async fn rate_limited_tasks() {
    let semaphore = Arc::new(Semaphore::new(3)); // æœ€å¤š 3 ä¸ªå¹¶å‘ä»»åŠ¡
    let mut tasks = vec![];
    
    for i in 0..10 {
        let permit = Arc::clone(&semaphore);
        let task = tokio::spawn(async move {
            let _permit = permit.acquire().await.unwrap();
            println!("ä»»åŠ¡ {} å¼€å§‹", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            println!("ä»»åŠ¡ {} å®Œæˆ", i);
        });
        tasks.push(task);
    }
    
    for task in tasks {
        task.await.unwrap();
    }
}

#[tokio::main]
async fn main() {
    rate_limited_tasks().await;
}
```

---

## 7. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

| æ¨¡å‹ | ä¼˜åŠ¿ | åŠ£åŠ¿ | é€‚ç”¨åœºæ™¯ |
|-----|------|------|---------|
| **CSP** | è§£è€¦ã€æ˜“æµ‹è¯• | é€šé“å¼€é”€ | ç®¡é“å¤„ç† |
| **Actor** | å®¹é”™ã€æ‰©å±•æ€§ | è°ƒè¯•å›°éš¾ | åˆ†å¸ƒå¼ç³»ç»Ÿ |
| **å…±äº«å†…å­˜** | æ€§èƒ½é«˜ | ç«æ€é£é™© | ç´§å¯†è€¦åˆ |

### æœ€ä½³å®è·µ

1. **ä¼˜å…ˆæ¶ˆæ¯ä¼ é€’**: é¿å…å…±äº«çŠ¶æ€
2. **æœ€å°åŒ–é”ä½œç”¨åŸŸ**: å°½æ—©é‡Šæ”¾é”
3. **ä½¿ç”¨åŸå­æ“ä½œ**: ç®€å•è®¡æ•°å™¨
4. **å·¥ä½œçªƒå–**: CPU å¯†é›†å‹ä»»åŠ¡
5. **å¼‚æ­¥ I/O**: ç½‘ç»œä¸æ–‡ä»¶æ“ä½œ

---

## ğŸ“š å‚è€ƒèµ„æº

- [CSP: Communicating Sequential Processes](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)
- [Actor Model](https://en.wikipedia.org/wiki/Actor_model)
- [Rust Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [æœºå™¨å­¦ä¹ å»ºæ¨¡](04_æœºå™¨å­¦ä¹ å»ºæ¨¡.md)ï¼Œæ¢ç´¢ Rust æœºå™¨å­¦ä¹ ç”Ÿæ€ã€‚
