# C12 Model - Tier 2: å½¢å¼åŒ–å»ºæ¨¡å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 45 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C12 Model - Tier 2: å½¢å¼åŒ–å»ºæ¨¡å®è·µ](#c12-model---tier-2-å½¢å¼åŒ–å»ºæ¨¡å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å½¢å¼åŒ–æ–¹æ³•æ¦‚è¿°](#1-å½¢å¼åŒ–æ–¹æ³•æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–æ–¹æ³•ï¼Ÿ](#11-ä»€ä¹ˆæ˜¯å½¢å¼åŒ–æ–¹æ³•)
    - [1.2 å½¢å¼åŒ–è¯­ä¹‰åˆ†ç±»](#12-å½¢å¼åŒ–è¯­ä¹‰åˆ†ç±»)
  - [2. æ“ä½œè¯­ä¹‰](#2-æ“ä½œè¯­ä¹‰)
    - [2.1 å°æ­¥è¯­ä¹‰ (Small-Step Semantics)](#21-å°æ­¥è¯­ä¹‰-small-step-semantics)
    - [2.2 å¤§æ­¥è¯­ä¹‰ (Big-Step Semantics)](#22-å¤§æ­¥è¯­ä¹‰-big-step-semantics)
  - [3. æŒ‡ç§°è¯­ä¹‰](#3-æŒ‡ç§°è¯­ä¹‰)
    - [3.1 æ•°å­¦å‡½æ•°æ˜ å°„](#31-æ•°å­¦å‡½æ•°æ˜ å°„)
  - [4. å…¬ç†è¯­ä¹‰](#4-å…¬ç†è¯­ä¹‰)
    - [4.1 Hoare é€»è¾‘](#41-hoare-é€»è¾‘)
    - [4.2 æœ€å¼±å‰ç½®æ¡ä»¶ (Weakest Precondition)](#42-æœ€å¼±å‰ç½®æ¡ä»¶-weakest-precondition)
  - [5. æ¨¡å‹æ£€éªŒ](#5-æ¨¡å‹æ£€éªŒ)
    - [5.1 çŠ¶æ€ç©ºé—´æ¢ç´¢](#51-çŠ¶æ€ç©ºé—´æ¢ç´¢)
    - [5.2 æ—¶åºé€»è¾‘ (ç®€åŒ–å®ç°)](#52-æ—¶åºé€»è¾‘-ç®€åŒ–å®ç°)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [6.1 å¹¶å‘ç¨‹åºéªŒè¯](#61-å¹¶å‘ç¨‹åºéªŒè¯)
  - [7. æ€»ç»“](#7-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. å½¢å¼åŒ–æ–¹æ³•æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–æ–¹æ³•ï¼Ÿ

å½¢å¼åŒ–æ–¹æ³•ä½¿ç”¨æ•°å­¦æŠ€æœ¯ç²¾ç¡®æè¿°å’ŒéªŒè¯è½¯ä»¶ç³»ç»Ÿçš„è¡Œä¸ºã€‚

**æ ¸å¿ƒç›®æ ‡**ï¼š

- **ç²¾ç¡®æ€§**ï¼šæ¶ˆé™¤è‡ªç„¶è¯­è¨€çš„æ­§ä¹‰
- **å¯éªŒè¯æ€§**ï¼šè¯æ˜ç¨‹åºæ­£ç¡®æ€§
- **å¯é æ€§**ï¼šæå‰å‘ç°è®¾è®¡ç¼ºé™·

### 1.2 å½¢å¼åŒ–è¯­ä¹‰åˆ†ç±»

```rust
// ç¤ºä¾‹ï¼šç®€å•ç®—æœ¯è¡¨è¾¾å¼
enum Expr {
    Const(i32),
    Add(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
}

// è¯„ä¼°è¡¨è¾¾å¼ï¼ˆæŒ‡ç§°è¯­ä¹‰ï¼‰
fn eval(expr: &Expr) -> i32 {
    match expr {
        Expr::Const(n) => *n,
        Expr::Add(e1, e2) => eval(e1) + eval(e2),
        Expr::Mul(e1, e2) => eval(e1) * eval(e2),
    }
}

fn main() {
    // 2 + 3 * 4
    let expr = Expr::Add(
        Box::new(Expr::Const(2)),
        Box::new(Expr::Mul(
            Box::new(Expr::Const(3)),
            Box::new(Expr::Const(4)),
        )),
    );
    
    println!("ç»“æœ: {}", eval(&expr)); // 14
}
```

---

## 2. æ“ä½œè¯­ä¹‰

### 2.1 å°æ­¥è¯­ä¹‰ (Small-Step Semantics)

**æ ¸å¿ƒæ€æƒ³**ï¼šæè¿°ç¨‹åºæ¯ä¸€æ­¥çš„æ‰§è¡Œã€‚

```rust
#[derive(Clone, Debug, PartialEq)]
enum State {
    Expr(Expr),
    Value(i32),
}

impl State {
    // å°æ­¥å½’çº¦
    fn step(&self) -> Option<State> {
        match self {
            State::Expr(Expr::Const(n)) => Some(State::Value(*n)),
            State::Expr(Expr::Add(e1, e2)) => {
                match (e1.as_ref(), e2.as_ref()) {
                    (Expr::Const(v1), Expr::Const(v2)) => {
                        Some(State::Value(v1 + v2))
                    }
                    (_, Expr::Const(_)) => {
                        // å…ˆå½’çº¦å·¦è¡¨è¾¾å¼
                        let e1_state = State::Expr(e1.as_ref().clone());
                        e1_state.step().map(|s| match s {
                            State::Value(v) => State::Expr(Expr::Add(
                                Box::new(Expr::Const(v)),
                                e2.clone(),
                            )),
                            State::Expr(e) => State::Expr(Expr::Add(Box::new(e), e2.clone())),
                        })
                    }
                    _ => {
                        // å…ˆå½’çº¦å³è¡¨è¾¾å¼
                        let e2_state = State::Expr(e2.as_ref().clone());
                        e2_state.step().map(|s| match s {
                            State::Value(v) => State::Expr(Expr::Add(
                                e1.clone(),
                                Box::new(Expr::Const(v)),
                            )),
                            State::Expr(e) => State::Expr(Expr::Add(e1.clone(), Box::new(e))),
                        })
                    }
                }
            }
            State::Value(_) => None, // å·²åˆ°è¾¾æœ€ç»ˆçŠ¶æ€
            _ => None,
        }
    }
    
    // æ‰§è¡Œåˆ°æœ€ç»ˆçŠ¶æ€
    fn eval(&self) -> i32 {
        let mut current = self.clone();
        while let Some(next) = current.step() {
            current = next;
        }
        match current {
            State::Value(v) => v,
            _ => panic!("æ— æ³•å½’çº¦åˆ°å€¼"),
        }
    }
}

fn main() {
    let expr = State::Expr(Expr::Add(
        Box::new(Expr::Const(2)),
        Box::new(Expr::Const(3)),
    ));
    
    println!("å°æ­¥è¯­ä¹‰ç»“æœ: {}", expr.eval());
}
```

### 2.2 å¤§æ­¥è¯­ä¹‰ (Big-Step Semantics)

**æ ¸å¿ƒæ€æƒ³**ï¼šç›´æ¥æè¿°ç¨‹åºçš„æœ€ç»ˆç»“æœã€‚

```rust
// å¤§æ­¥æ±‚å€¼ï¼ˆä¸ä¹‹å‰çš„ eval å‡½æ•°ç›¸åŒï¼‰
fn big_step_eval(expr: &Expr) -> i32 {
    match expr {
        Expr::Const(n) => *n,
        Expr::Add(e1, e2) => big_step_eval(e1) + big_step_eval(e2),
        Expr::Mul(e1, e2) => big_step_eval(e1) * big_step_eval(e2),
    }
}

fn main() {
    let expr = Expr::Add(
        Box::new(Expr::Const(10)),
        Box::new(Expr::Mul(
            Box::new(Expr::Const(2)),
            Box::new(Expr::Const(5)),
        )),
    );
    
    println!("å¤§æ­¥è¯­ä¹‰ç»“æœ: {}", big_step_eval(&expr)); // 20
}
```

---

## 3. æŒ‡ç§°è¯­ä¹‰

### 3.1 æ•°å­¦å‡½æ•°æ˜ å°„

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†ç¨‹åºæ˜ å°„ä¸ºæ•°å­¦å‡½æ•°ã€‚

```rust
use std::collections::HashMap;

type Env = HashMap<String, i32>;

#[derive(Clone, Debug)]
enum BoolExpr {
    True,
    False,
    LessThan(Box<Expr>, Box<Expr>),
    GreaterThan(Box<Expr>, Box<Expr>),
    Not(Box<BoolExpr>),
}

#[derive(Clone, Debug)]
enum Stmt {
    Skip,
    Assign(String, Expr),
    Seq(Box<Stmt>, Box<Stmt>),
    IfThenElse(BoolExpr, Box<Stmt>, Box<Stmt>),
    While(BoolExpr, Box<Stmt>),
}

// è¡¨è¾¾å¼çš„æŒ‡ç§°
fn denote_expr(expr: &Expr, env: &Env) -> i32 {
    match expr {
        Expr::Const(n) => *n,
        Expr::Add(e1, e2) => denote_expr(e1, env) + denote_expr(e2, env),
        Expr::Mul(e1, e2) => denote_expr(e1, env) * denote_expr(e2, env),
    }
}

// å¸ƒå°”è¡¨è¾¾å¼çš„æŒ‡ç§°
fn denote_bool(expr: &BoolExpr, env: &Env) -> bool {
    match expr {
        BoolExpr::True => true,
        BoolExpr::False => false,
        BoolExpr::LessThan(e1, e2) => denote_expr(e1, env) < denote_expr(e2, env),
        BoolExpr::GreaterThan(e1, e2) => denote_expr(e1, env) > denote_expr(e2, env),
        BoolExpr::Not(b) => !denote_bool(b, env),
    }
}

// è¯­å¥çš„æŒ‡ç§°ï¼ˆç¯å¢ƒè½¬æ¢å‡½æ•°ï¼‰
fn denote_stmt(stmt: &Stmt, env: Env) -> Env {
    match stmt {
        Stmt::Skip => env,
        Stmt::Assign(var, expr) => {
            let mut new_env = env.clone();
            new_env.insert(var.clone(), denote_expr(expr, &env));
            new_env
        }
        Stmt::Seq(s1, s2) => {
            let env1 = denote_stmt(s1, env);
            denote_stmt(s2, env1)
        }
        Stmt::IfThenElse(cond, s1, s2) => {
            if denote_bool(cond, &env) {
                denote_stmt(s1, env)
            } else {
                denote_stmt(s2, env)
            }
        }
        Stmt::While(cond, body) => {
            if denote_bool(cond, &env) {
                let env1 = denote_stmt(body, env);
                denote_stmt(stmt, env1)
            } else {
                env
            }
        }
    }
}

fn main() {
    // ç¨‹åº: x = 5; y = x + 3
    let program = Stmt::Seq(
        Box::new(Stmt::Assign("x".to_string(), Expr::Const(5))),
        Box::new(Stmt::Assign(
            "y".to_string(),
            Expr::Add(Box::new(Expr::Const(0)), Box::new(Expr::Const(3))),
        )),
    );
    
    let env = HashMap::new();
    let final_env = denote_stmt(&program, env);
    
    println!("æœ€ç»ˆç¯å¢ƒ: {:?}", final_env);
}
```

---

## 4. å…¬ç†è¯­ä¹‰

### 4.1 Hoare é€»è¾‘

**Hoare ä¸‰å…ƒç»„**: `{P} S {Q}`

- `P`: å‰ç½®æ¡ä»¶
- `S`: è¯­å¥
- `Q`: åç½®æ¡ä»¶

```rust
// æ–­è¨€ç±»å‹
#[derive(Clone, Debug)]
enum Assertion {
    True,
    False,
    Eq(String, i32),
    LessThan(String, i32),
    And(Box<Assertion>, Box<Assertion>),
}

impl Assertion {
    fn check(&self, env: &Env) -> bool {
        match self {
            Assertion::True => true,
            Assertion::False => false,
            Assertion::Eq(var, val) => env.get(var).copied() == Some(*val),
            Assertion::LessThan(var, val) => env.get(var).copied().map_or(false, |v| v < *val),
            Assertion::And(a1, a2) => a1.check(env) && a2.check(env),
        }
    }
}

// Hoare ä¸‰å…ƒç»„
struct HoareTriple {
    pre: Assertion,
    stmt: Stmt,
    post: Assertion,
}

impl HoareTriple {
    fn verify(&self, env: &Env) -> bool {
        // æ£€æŸ¥å‰ç½®æ¡ä»¶
        if !self.pre.check(env) {
            return true; // å‰ç½®æ¡ä»¶ä¸æ»¡è¶³æ—¶ï¼Œä¸‰å…ƒç»„å¹³å‡¡æˆç«‹
        }
        
        // æ‰§è¡Œè¯­å¥
        let final_env = denote_stmt(&self.stmt, env.clone());
        
        // æ£€æŸ¥åç½®æ¡ä»¶
        self.post.check(&final_env)
    }
}

fn main() {
    // {x = 5} y := x + 3 {y = 8}
    let mut env = HashMap::new();
    env.insert("x".to_string(), 5);
    
    let triple = HoareTriple {
        pre: Assertion::Eq("x".to_string(), 5),
        stmt: Stmt::Assign(
            "y".to_string(),
            Expr::Add(Box::new(Expr::Const(0)), Box::new(Expr::Const(3))),
        ),
        post: Assertion::Eq("y".to_string(), 8),
    };
    
    println!("Hoare ä¸‰å…ƒç»„éªŒè¯: {}", triple.verify(&env));
}
```

### 4.2 æœ€å¼±å‰ç½®æ¡ä»¶ (Weakest Precondition)

```rust
fn weakest_precondition(stmt: &Stmt, post: &Assertion) -> Assertion {
    match stmt {
        Stmt::Skip => post.clone(),
        Stmt::Assign(var, expr) => {
            // WP(x := e, Q) = Q[e/x]
            // ç®€åŒ–å®ç°ï¼šå‡è®¾ Q æ˜¯å…³äº var çš„æ–­è¨€
            match post {
                Assertion::Eq(v, val) if v == var => {
                    // å°† var æ›¿æ¢ä¸º expr
                    Assertion::True // ç®€åŒ–
                }
                _ => post.clone(),
            }
        }
        Stmt::Seq(s1, s2) => {
            // WP(S1; S2, Q) = WP(S1, WP(S2, Q))
            let wp2 = weakest_precondition(s2, post);
            weakest_precondition(s1, &wp2)
        }
        Stmt::IfThenElse(cond, s1, s2) => {
            // WP(if B then S1 else S2, Q) = (B âˆ§ WP(S1, Q)) âˆ¨ (Â¬B âˆ§ WP(S2, Q))
            let wp1 = weakest_precondition(s1, post);
            let wp2 = weakest_precondition(s2, post);
            Assertion::And(Box::new(wp1), Box::new(wp2)) // ç®€åŒ–
        }
        Stmt::While(_, _) => {
            // While éœ€è¦å¾ªç¯ä¸å˜å¼
            Assertion::True // ç®€åŒ–
        }
    }
}

fn main() {
    // è¯­å¥: x := 5
    // åç½®æ¡ä»¶: {x = 5}
    let stmt = Stmt::Assign("x".to_string(), Expr::Const(5));
    let post = Assertion::Eq("x".to_string(), 5);
    
    let wp = weakest_precondition(&stmt, &post);
    println!("æœ€å¼±å‰ç½®æ¡ä»¶: {:?}", wp);
}
```

---

## 5. æ¨¡å‹æ£€éªŒ

### 5.1 çŠ¶æ€ç©ºé—´æ¢ç´¢

```rust
use std::collections::{HashSet, VecDeque};

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct SystemState {
    x: i32,
    y: i32,
}

impl SystemState {
    fn transitions(&self) -> Vec<SystemState> {
        vec![
            SystemState { x: self.x + 1, y: self.y },
            SystemState { x: self.x, y: self.y + 1 },
        ]
    }
    
    fn satisfies(&self, property: &dyn Fn(&SystemState) -> bool) -> bool {
        property(self)
    }
}

fn model_check(initial: SystemState, property: impl Fn(&SystemState) -> bool) -> bool {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    
    queue.push_back(initial.clone());
    visited.insert(initial);
    
    while let Some(state) = queue.pop_front() {
        // æ£€æŸ¥å±æ€§
        if !state.satisfies(&property) {
            return false; // å‘ç°åä¾‹
        }
        
        // æ¢ç´¢åç»§çŠ¶æ€
        for next in state.transitions() {
            if !visited.contains(&next) && next.x < 10 && next.y < 10 {
                visited.insert(next.clone());
                queue.push_back(next);
            }
        }
    }
    
    true // æ‰€æœ‰å¯è¾¾çŠ¶æ€éƒ½æ»¡è¶³å±æ€§
}

fn main() {
    let initial = SystemState { x: 0, y: 0 };
    
    // å±æ€§: x + y < 20
    let property = |state: &SystemState| state.x + state.y < 20;
    
    let result = model_check(initial, property);
    println!("æ¨¡å‹æ£€éªŒç»“æœ: {}", result);
}
```

### 5.2 æ—¶åºé€»è¾‘ (ç®€åŒ–å®ç°)

```rust
#[derive(Clone, Debug)]
enum TemporalFormula {
    Always(Box<dyn Fn(&SystemState) -> bool>),
    Eventually(Box<dyn Fn(&SystemState) -> bool>),
}

fn check_always(
    states: &[SystemState],
    property: &dyn Fn(&SystemState) -> bool,
) -> bool {
    states.iter().all(property)
}

fn check_eventually(
    states: &[SystemState],
    property: &dyn Fn(&SystemState) -> bool,
) -> bool {
    states.iter().any(property)
}

fn main() {
    let states = vec![
        SystemState { x: 0, y: 0 },
        SystemState { x: 1, y: 0 },
        SystemState { x: 2, y: 0 },
    ];
    
    // G(x >= 0) - Always x >= 0
    let always_nonnegative = |state: &SystemState| state.x >= 0;
    println!("Always x >= 0: {}", check_always(&states, &always_nonnegative));
    
    // F(x == 2) - Eventually x == 2
    let eventually_two = |state: &SystemState| state.x == 2;
    println!("Eventually x == 2: {}", check_eventually(&states, &eventually_two));
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### 6.1 å¹¶å‘ç¨‹åºéªŒè¯

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// é“¶è¡Œè´¦æˆ·è½¬è´¦
struct Account {
    balance: Mutex<i32>,
}

impl Account {
    fn new(balance: i32) -> Arc<Self> {
        Arc::new(Self {
            balance: Mutex::new(balance),
        })
    }
    
    fn transfer(from: &Account, to: &Account, amount: i32) -> Result<(), String> {
        // ä¸å˜å¼: æ€»é‡‘é¢å®ˆæ’
        let mut from_balance = from.balance.lock().unwrap();
        let mut to_balance = to.balance.lock().unwrap();
        
        if *from_balance < amount {
            return Err("ä½™é¢ä¸è¶³".to_string());
        }
        
        *from_balance -= amount;
        *to_balance += amount;
        
        Ok(())
    }
}

fn main() {
    let account1 = Account::new(100);
    let account2 = Account::new(50);
    
    // å‰ç½®æ¡ä»¶: {balance1 = 100, balance2 = 50}
    let total_before = *account1.balance.lock().unwrap() + *account2.balance.lock().unwrap();
    
    // è½¬è´¦
    let a1 = Arc::clone(&account1);
    let a2 = Arc::clone(&account2);
    let handle = thread::spawn(move || {
        Account::transfer(&a1, &a2, 30).unwrap();
    });
    
    handle.join().unwrap();
    
    // åç½®æ¡ä»¶: æ€»é‡‘é¢ä¸å˜
    let total_after = *account1.balance.lock().unwrap() + *account2.balance.lock().unwrap();
    
    assert_eq!(total_before, total_after, "æ€»é‡‘é¢å®ˆæ’");
    println!("éªŒè¯æˆåŠŸ: æ€»é‡‘é¢å®ˆæ’");
}
```

---

## 7. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

| è¯­ä¹‰ç±»å‹ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|------|---------|
| **æ“ä½œè¯­ä¹‰** | æè¿°æ‰§è¡Œæ­¥éª¤ | ç¨‹åºç†è§£ã€è°ƒè¯•å™¨ |
| **æŒ‡ç§°è¯­ä¹‰** | æ•°å­¦å‡½æ•°æ˜ å°„ | ç¼–è¯‘å™¨ä¼˜åŒ–ã€ç¨‹åºåˆ†æ |
| **å…¬ç†è¯­ä¹‰** | åŸºäºé€»è¾‘æ¨ç† | ç¨‹åºéªŒè¯ã€æ­£ç¡®æ€§è¯æ˜ |

### æœ€ä½³å®è·µ

1. **ç±»å‹ç³»ç»Ÿ**: åˆ©ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿç¼–ç ä¸å˜å¼
2. **æ‰€æœ‰æƒ**: åˆ©ç”¨æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨
3. **çŠ¶æ€æœº**: ä½¿ç”¨ç±»å‹çŠ¶æ€æ¨¡å¼ç¼–ç çŠ¶æ€è½¬æ¢
4. **æ–­è¨€**: åœ¨å…³é”®ç‚¹æ·»åŠ æ–­è¨€éªŒè¯ä¸å˜å¼
5. **å±æ€§æµ‹è¯•**: ä½¿ç”¨ proptest ç­‰åº“è¿›è¡Œå±æ€§æµ‹è¯•

---

## ğŸ“š å‚è€ƒèµ„æº

- [Formal Semantics of Programming Languages](https://mitpress.mit.edu/books/formal-semantics-programming-languages)
- [Hoare Logic](https://en.wikipedia.org/wiki/Hoare_logic)
- [Model Checking](http://spinroot.com/spin/whatispin.html)

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [åˆ†å¸ƒå¼ç³»ç»Ÿå»ºæ¨¡](02_åˆ†å¸ƒå¼ç³»ç»Ÿå»ºæ¨¡.md)ï¼ŒæŒæ¡åˆ†å¸ƒå¼ä¸€è‡´æ€§å»ºæ¨¡ã€‚
