# C12 Model - Tier 2: 形式化建模实践

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 45 分钟

---


## 📊 目录

- [📋 目录](#目录)
- [1. 形式化方法概述](#1-形式化方法概述)
  - [1.1 什么是形式化方法？](#11-什么是形式化方法)
  - [1.2 形式化语义分类](#12-形式化语义分类)
- [2. 操作语义](#2-操作语义)
  - [2.1 小步语义 (Small-Step Semantics)](#21-小步语义-small-step-semantics)
  - [2.2 大步语义 (Big-Step Semantics)](#22-大步语义-big-step-semantics)
- [3. 指称语义](#3-指称语义)
  - [3.1 数学函数映射](#31-数学函数映射)
- [4. 公理语义](#4-公理语义)
  - [4.1 Hoare 逻辑](#41-hoare-逻辑)
  - [4.2 最弱前置条件 (Weakest Precondition)](#42-最弱前置条件-weakest-precondition)
- [5. 模型检验](#5-模型检验)
  - [5.1 状态空间探索](#51-状态空间探索)
  - [5.2 时序逻辑 (简化实现)](#52-时序逻辑-简化实现)
- [6. 实战案例](#6-实战案例)
  - [6.1 并发程序验证](#61-并发程序验证)
- [7. 总结](#7-总结)
  - [核心要点](#核心要点)
  - [最佳实践](#最佳实践)
- [📚 参考资源](#参考资源)


## 📋 目录

- [C12 Model - Tier 2: 形式化建模实践](#c12-model---tier-2-形式化建模实践)
  - [📋 目录](#-目录)
  - [1. 形式化方法概述](#1-形式化方法概述)
    - [1.1 什么是形式化方法？](#11-什么是形式化方法)
    - [1.2 形式化语义分类](#12-形式化语义分类)
  - [2. 操作语义](#2-操作语义)
    - [2.1 小步语义 (Small-Step Semantics)](#21-小步语义-small-step-semantics)
    - [2.2 大步语义 (Big-Step Semantics)](#22-大步语义-big-step-semantics)
  - [3. 指称语义](#3-指称语义)
    - [3.1 数学函数映射](#31-数学函数映射)
  - [4. 公理语义](#4-公理语义)
    - [4.1 Hoare 逻辑](#41-hoare-逻辑)
    - [4.2 最弱前置条件 (Weakest Precondition)](#42-最弱前置条件-weakest-precondition)
  - [5. 模型检验](#5-模型检验)
    - [5.1 状态空间探索](#51-状态空间探索)
    - [5.2 时序逻辑 (简化实现)](#52-时序逻辑-简化实现)
  - [6. 实战案例](#6-实战案例)
    - [6.1 并发程序验证](#61-并发程序验证)
  - [7. 总结](#7-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 形式化方法概述

### 1.1 什么是形式化方法？

形式化方法使用数学技术精确描述和验证软件系统的行为。

**核心目标**：

- **精确性**：消除自然语言的歧义
- **可验证性**：证明程序正确性
- **可靠性**：提前发现设计缺陷

### 1.2 形式化语义分类

```rust
// 示例：简单算术表达式
enum Expr {
    Const(i32),
    Add(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
}

// 评估表达式（指称语义）
fn eval(expr: &Expr) -> i32 {
    match expr {
        Expr::Const(n) => *n,
        Expr::Add(e1, e2) => eval(e1) + eval(e2),
        Expr::Mul(e1, e2) => eval(e1) * eval(e2),
    }
}

fn main() {
    // 2 + 3 * 4
    let expr = Expr::Add(
        Box::new(Expr::Const(2)),
        Box::new(Expr::Mul(
            Box::new(Expr::Const(3)),
            Box::new(Expr::Const(4)),
        )),
    );
    
    println!("结果: {}", eval(&expr)); // 14
}
```

---

## 2. 操作语义

### 2.1 小步语义 (Small-Step Semantics)

**核心思想**：描述程序每一步的执行。

```rust
#[derive(Clone, Debug, PartialEq)]
enum State {
    Expr(Expr),
    Value(i32),
}

impl State {
    // 小步归约
    fn step(&self) -> Option<State> {
        match self {
            State::Expr(Expr::Const(n)) => Some(State::Value(*n)),
            State::Expr(Expr::Add(e1, e2)) => {
                match (e1.as_ref(), e2.as_ref()) {
                    (Expr::Const(v1), Expr::Const(v2)) => {
                        Some(State::Value(v1 + v2))
                    }
                    (_, Expr::Const(_)) => {
                        // 先归约左表达式
                        let e1_state = State::Expr(e1.as_ref().clone());
                        e1_state.step().map(|s| match s {
                            State::Value(v) => State::Expr(Expr::Add(
                                Box::new(Expr::Const(v)),
                                e2.clone(),
                            )),
                            State::Expr(e) => State::Expr(Expr::Add(Box::new(e), e2.clone())),
                        })
                    }
                    _ => {
                        // 先归约右表达式
                        let e2_state = State::Expr(e2.as_ref().clone());
                        e2_state.step().map(|s| match s {
                            State::Value(v) => State::Expr(Expr::Add(
                                e1.clone(),
                                Box::new(Expr::Const(v)),
                            )),
                            State::Expr(e) => State::Expr(Expr::Add(e1.clone(), Box::new(e))),
                        })
                    }
                }
            }
            State::Value(_) => None, // 已到达最终状态
            _ => None,
        }
    }
    
    // 执行到最终状态
    fn eval(&self) -> i32 {
        let mut current = self.clone();
        while let Some(next) = current.step() {
            current = next;
        }
        match current {
            State::Value(v) => v,
            _ => panic!("无法归约到值"),
        }
    }
}

fn main() {
    let expr = State::Expr(Expr::Add(
        Box::new(Expr::Const(2)),
        Box::new(Expr::Const(3)),
    ));
    
    println!("小步语义结果: {}", expr.eval());
}
```

### 2.2 大步语义 (Big-Step Semantics)

**核心思想**：直接描述程序的最终结果。

```rust
// 大步求值（与之前的 eval 函数相同）
fn big_step_eval(expr: &Expr) -> i32 {
    match expr {
        Expr::Const(n) => *n,
        Expr::Add(e1, e2) => big_step_eval(e1) + big_step_eval(e2),
        Expr::Mul(e1, e2) => big_step_eval(e1) * big_step_eval(e2),
    }
}

fn main() {
    let expr = Expr::Add(
        Box::new(Expr::Const(10)),
        Box::new(Expr::Mul(
            Box::new(Expr::Const(2)),
            Box::new(Expr::Const(5)),
        )),
    );
    
    println!("大步语义结果: {}", big_step_eval(&expr)); // 20
}
```

---

## 3. 指称语义

### 3.1 数学函数映射

**核心思想**：将程序映射为数学函数。

```rust
use std::collections::HashMap;

type Env = HashMap<String, i32>;

#[derive(Clone, Debug)]
enum BoolExpr {
    True,
    False,
    LessThan(Box<Expr>, Box<Expr>),
    GreaterThan(Box<Expr>, Box<Expr>),
    Not(Box<BoolExpr>),
}

#[derive(Clone, Debug)]
enum Stmt {
    Skip,
    Assign(String, Expr),
    Seq(Box<Stmt>, Box<Stmt>),
    IfThenElse(BoolExpr, Box<Stmt>, Box<Stmt>),
    While(BoolExpr, Box<Stmt>),
}

// 表达式的指称
fn denote_expr(expr: &Expr, env: &Env) -> i32 {
    match expr {
        Expr::Const(n) => *n,
        Expr::Add(e1, e2) => denote_expr(e1, env) + denote_expr(e2, env),
        Expr::Mul(e1, e2) => denote_expr(e1, env) * denote_expr(e2, env),
    }
}

// 布尔表达式的指称
fn denote_bool(expr: &BoolExpr, env: &Env) -> bool {
    match expr {
        BoolExpr::True => true,
        BoolExpr::False => false,
        BoolExpr::LessThan(e1, e2) => denote_expr(e1, env) < denote_expr(e2, env),
        BoolExpr::GreaterThan(e1, e2) => denote_expr(e1, env) > denote_expr(e2, env),
        BoolExpr::Not(b) => !denote_bool(b, env),
    }
}

// 语句的指称（环境转换函数）
fn denote_stmt(stmt: &Stmt, env: Env) -> Env {
    match stmt {
        Stmt::Skip => env,
        Stmt::Assign(var, expr) => {
            let mut new_env = env.clone();
            new_env.insert(var.clone(), denote_expr(expr, &env));
            new_env
        }
        Stmt::Seq(s1, s2) => {
            let env1 = denote_stmt(s1, env);
            denote_stmt(s2, env1)
        }
        Stmt::IfThenElse(cond, s1, s2) => {
            if denote_bool(cond, &env) {
                denote_stmt(s1, env)
            } else {
                denote_stmt(s2, env)
            }
        }
        Stmt::While(cond, body) => {
            if denote_bool(cond, &env) {
                let env1 = denote_stmt(body, env);
                denote_stmt(stmt, env1)
            } else {
                env
            }
        }
    }
}

fn main() {
    // 程序: x = 5; y = x + 3
    let program = Stmt::Seq(
        Box::new(Stmt::Assign("x".to_string(), Expr::Const(5))),
        Box::new(Stmt::Assign(
            "y".to_string(),
            Expr::Add(Box::new(Expr::Const(0)), Box::new(Expr::Const(3))),
        )),
    );
    
    let env = HashMap::new();
    let final_env = denote_stmt(&program, env);
    
    println!("最终环境: {:?}", final_env);
}
```

---

## 4. 公理语义

### 4.1 Hoare 逻辑

**Hoare 三元组**: `{P} S {Q}`

- `P`: 前置条件
- `S`: 语句
- `Q`: 后置条件

```rust
// 断言类型
#[derive(Clone, Debug)]
enum Assertion {
    True,
    False,
    Eq(String, i32),
    LessThan(String, i32),
    And(Box<Assertion>, Box<Assertion>),
}

impl Assertion {
    fn check(&self, env: &Env) -> bool {
        match self {
            Assertion::True => true,
            Assertion::False => false,
            Assertion::Eq(var, val) => env.get(var).copied() == Some(*val),
            Assertion::LessThan(var, val) => env.get(var).copied().map_or(false, |v| v < *val),
            Assertion::And(a1, a2) => a1.check(env) && a2.check(env),
        }
    }
}

// Hoare 三元组
struct HoareTriple {
    pre: Assertion,
    stmt: Stmt,
    post: Assertion,
}

impl HoareTriple {
    fn verify(&self, env: &Env) -> bool {
        // 检查前置条件
        if !self.pre.check(env) {
            return true; // 前置条件不满足时，三元组平凡成立
        }
        
        // 执行语句
        let final_env = denote_stmt(&self.stmt, env.clone());
        
        // 检查后置条件
        self.post.check(&final_env)
    }
}

fn main() {
    // {x = 5} y := x + 3 {y = 8}
    let mut env = HashMap::new();
    env.insert("x".to_string(), 5);
    
    let triple = HoareTriple {
        pre: Assertion::Eq("x".to_string(), 5),
        stmt: Stmt::Assign(
            "y".to_string(),
            Expr::Add(Box::new(Expr::Const(0)), Box::new(Expr::Const(3))),
        ),
        post: Assertion::Eq("y".to_string(), 8),
    };
    
    println!("Hoare 三元组验证: {}", triple.verify(&env));
}
```

### 4.2 最弱前置条件 (Weakest Precondition)

```rust
fn weakest_precondition(stmt: &Stmt, post: &Assertion) -> Assertion {
    match stmt {
        Stmt::Skip => post.clone(),
        Stmt::Assign(var, expr) => {
            // WP(x := e, Q) = Q[e/x]
            // 简化实现：假设 Q 是关于 var 的断言
            match post {
                Assertion::Eq(v, val) if v == var => {
                    // 将 var 替换为 expr
                    Assertion::True // 简化
                }
                _ => post.clone(),
            }
        }
        Stmt::Seq(s1, s2) => {
            // WP(S1; S2, Q) = WP(S1, WP(S2, Q))
            let wp2 = weakest_precondition(s2, post);
            weakest_precondition(s1, &wp2)
        }
        Stmt::IfThenElse(cond, s1, s2) => {
            // WP(if B then S1 else S2, Q) = (B ∧ WP(S1, Q)) ∨ (¬B ∧ WP(S2, Q))
            let wp1 = weakest_precondition(s1, post);
            let wp2 = weakest_precondition(s2, post);
            Assertion::And(Box::new(wp1), Box::new(wp2)) // 简化
        }
        Stmt::While(_, _) => {
            // While 需要循环不变式
            Assertion::True // 简化
        }
    }
}

fn main() {
    // 语句: x := 5
    // 后置条件: {x = 5}
    let stmt = Stmt::Assign("x".to_string(), Expr::Const(5));
    let post = Assertion::Eq("x".to_string(), 5);
    
    let wp = weakest_precondition(&stmt, &post);
    println!("最弱前置条件: {:?}", wp);
}
```

---

## 5. 模型检验

### 5.1 状态空间探索

```rust
use std::collections::{HashSet, VecDeque};

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct SystemState {
    x: i32,
    y: i32,
}

impl SystemState {
    fn transitions(&self) -> Vec<SystemState> {
        vec![
            SystemState { x: self.x + 1, y: self.y },
            SystemState { x: self.x, y: self.y + 1 },
        ]
    }
    
    fn satisfies(&self, property: &dyn Fn(&SystemState) -> bool) -> bool {
        property(self)
    }
}

fn model_check(initial: SystemState, property: impl Fn(&SystemState) -> bool) -> bool {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    
    queue.push_back(initial.clone());
    visited.insert(initial);
    
    while let Some(state) = queue.pop_front() {
        // 检查属性
        if !state.satisfies(&property) {
            return false; // 发现反例
        }
        
        // 探索后继状态
        for next in state.transitions() {
            if !visited.contains(&next) && next.x < 10 && next.y < 10 {
                visited.insert(next.clone());
                queue.push_back(next);
            }
        }
    }
    
    true // 所有可达状态都满足属性
}

fn main() {
    let initial = SystemState { x: 0, y: 0 };
    
    // 属性: x + y < 20
    let property = |state: &SystemState| state.x + state.y < 20;
    
    let result = model_check(initial, property);
    println!("模型检验结果: {}", result);
}
```

### 5.2 时序逻辑 (简化实现)

```rust
#[derive(Clone, Debug)]
enum TemporalFormula {
    Always(Box<dyn Fn(&SystemState) -> bool>),
    Eventually(Box<dyn Fn(&SystemState) -> bool>),
}

fn check_always(
    states: &[SystemState],
    property: &dyn Fn(&SystemState) -> bool,
) -> bool {
    states.iter().all(property)
}

fn check_eventually(
    states: &[SystemState],
    property: &dyn Fn(&SystemState) -> bool,
) -> bool {
    states.iter().any(property)
}

fn main() {
    let states = vec![
        SystemState { x: 0, y: 0 },
        SystemState { x: 1, y: 0 },
        SystemState { x: 2, y: 0 },
    ];
    
    // G(x >= 0) - Always x >= 0
    let always_nonnegative = |state: &SystemState| state.x >= 0;
    println!("Always x >= 0: {}", check_always(&states, &always_nonnegative));
    
    // F(x == 2) - Eventually x == 2
    let eventually_two = |state: &SystemState| state.x == 2;
    println!("Eventually x == 2: {}", check_eventually(&states, &eventually_two));
}
```

---

## 6. 实战案例

### 6.1 并发程序验证

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// 银行账户转账
struct Account {
    balance: Mutex<i32>,
}

impl Account {
    fn new(balance: i32) -> Arc<Self> {
        Arc::new(Self {
            balance: Mutex::new(balance),
        })
    }
    
    fn transfer(from: &Account, to: &Account, amount: i32) -> Result<(), String> {
        // 不变式: 总金额守恒
        let mut from_balance = from.balance.lock().unwrap();
        let mut to_balance = to.balance.lock().unwrap();
        
        if *from_balance < amount {
            return Err("余额不足".to_string());
        }
        
        *from_balance -= amount;
        *to_balance += amount;
        
        Ok(())
    }
}

fn main() {
    let account1 = Account::new(100);
    let account2 = Account::new(50);
    
    // 前置条件: {balance1 = 100, balance2 = 50}
    let total_before = *account1.balance.lock().unwrap() + *account2.balance.lock().unwrap();
    
    // 转账
    let a1 = Arc::clone(&account1);
    let a2 = Arc::clone(&account2);
    let handle = thread::spawn(move || {
        Account::transfer(&a1, &a2, 30).unwrap();
    });
    
    handle.join().unwrap();
    
    // 后置条件: 总金额不变
    let total_after = *account1.balance.lock().unwrap() + *account2.balance.lock().unwrap();
    
    assert_eq!(total_before, total_after, "总金额守恒");
    println!("验证成功: 总金额守恒");
}
```

---

## 7. 总结

### 核心要点

| 语义类型 | 特点 | 适用场景 |
|---------|------|---------|
| **操作语义** | 描述执行步骤 | 程序理解、调试器 |
| **指称语义** | 数学函数映射 | 编译器优化、程序分析 |
| **公理语义** | 基于逻辑推理 | 程序验证、正确性证明 |

### 最佳实践

1. **类型系统**: 利用 Rust 的类型系统编码不变式
2. **所有权**: 利用所有权系统保证内存安全
3. **状态机**: 使用类型状态模式编码状态转换
4. **断言**: 在关键点添加断言验证不变式
5. **属性测试**: 使用 proptest 等库进行属性测试

---

## 📚 参考资源

- [Formal Semantics of Programming Languages](https://mitpress.mit.edu/books/formal-semantics-programming-languages)
- [Hoare Logic](https://en.wikipedia.org/wiki/Hoare_logic)
- [Model Checking](http://spinroot.com/spin/whatispin.html)

---

**下一步**: 学习 [分布式系统建模](02_分布式系统建模.md)，掌握分布式一致性建模。
