# C10 Networks - Tier 2: 网络基础实践

> **文档版本**: v1.0.0
> **最后更新**: 2025-10-23
> **Rust 版本**: 1.90+
> **预计阅读**: 45 分钟

---

## 📊 目录

- [C10 Networks - Tier 2: 网络基础实践](#c10-networks---tier-2-网络基础实践)
  - [📊 目录](#-目录)
  - [1. 网络编程基础](#1-网络编程基础)
    - [1.1 OSI 模型与 TCP/IP](#11-osi-模型与-tcpip)
    - [1.2 地址与端口](#12-地址与端口)
  - [2. TCP 连接管理](#2-tcp-连接管理)
    - [2.1 TCP 服务器](#21-tcp-服务器)
    - [2.2 TCP 客户端](#22-tcp-客户端)
    - [2.3 连接池](#23-连接池)
  - [3. UDP 数据报通信](#3-udp-数据报通信)
    - [3.1 UDP 基础](#31-udp-基础)
    - [3.2 UDP 多播](#32-udp-多播)
  - [4. DNS 解析](#4-dns-解析)
    - [4.1 标准库 DNS 解析](#41-标准库-dns-解析)
    - [4.2 使用 trust-dns (hickory-dns)](#42-使用-trust-dns-hickory-dns)
  - [5. 错误处理与超时](#5-错误处理与超时)
    - [5.1 超时设置](#51-超时设置)
    - [5.2 重试策略](#52-重试策略)
  - [6. 异步 vs 同步](#6-异步-vs-同步)
    - [6.1 同步网络编程](#61-同步网络编程)
    - [6.2 异步网络编程](#62-异步网络编程)
    - [6.3 选择指南](#63-选择指南)
  - [7. 实战案例](#7-实战案例)
    - [7.1 简单 HTTP 服务器](#71-简单-http-服务器)
    - [7.2 端口扫描器](#72-端口扫描器)
  - [8. 总结](#8-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

## 1. 网络编程基础

### 1.1 OSI 模型与 TCP/IP

**OSI 七层模型**：

- **应用层** (HTTP, FTP, DNS)
- **传输层** (TCP, UDP)
- **网络层** (IP)
- **链路层** (Ethernet)

**Rust 网络编程层次**：

```rust
use std::net::{TcpStream, UdpSocket, IpAddr, SocketAddr};
use std::io::{Read, Write};

// 基础示例：TCP 客户端
fn simple_tcp_client() -> std::io::Result<()> {
    // 连接到服务器
    let mut stream = TcpStream::connect("127.0.0.1:8080")?;

    // 发送数据
    stream.write_all(b"Hello, Server!")?;

    // 接收响应
    let mut buffer = [0; 512];
    let n = stream.read(&mut buffer)?;
    println!("收到响应: {}", String::from_utf8_lossy(&buffer[..n]));

    Ok(())
}

fn main() -> std::io::Result<()> {
    simple_tcp_client()
}
```

### 1.2 地址与端口

**IPv4 vs IPv6**：

```rust
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};

fn address_examples() {
    // IPv4 地址
    let ipv4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));
    let ipv4_loopback = IpAddr::V4(Ipv4Addr::LOCALHOST);

    // IPv6 地址
    let ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));
    let ipv6_loopback = IpAddr::V6(Ipv6Addr::LOCALHOST);

    // Socket 地址 (IP + 端口)
    let socket_addr = SocketAddr::new(ipv4, 8080);
    println!("Socket 地址: {}", socket_addr);

    // 字符串解析
    let parsed: SocketAddr = "192.168.1.1:8080".parse().unwrap();
    println!("解析地址: {}", parsed);
}

fn main() {
    address_examples();
}
```

**端口范围**：

- **0-1023**: 系统保留端口 (HTTP:80, HTTPS:443)
- **1024-49151**: 注册端口 (应用程序)
- **49152-65535**: 动态/私有端口

---

## 2. TCP 连接管理

### 2.1 TCP 服务器

```rust
use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};
use std::thread;

fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {
    let peer_addr = stream.peer_addr()?;
    println!("新连接: {}", peer_addr);

    let mut buffer = [0; 1024];
    loop {
        let n = stream.read(&mut buffer)?;
        if n == 0 {
            println!("客户端 {} 断开连接", peer_addr);
            break;
        }

        println!("收到 {} 字节: {}", n, String::from_utf8_lossy(&buffer[..n]));

        // 回显数据
        stream.write_all(&buffer[..n])?;
    }

    Ok(())
}

fn tcp_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080")?;
    println!("服务器监听: {}", listener.local_addr()?);

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                // 为每个连接创建线程
                thread::spawn(|| {
                    if let Err(e) = handle_client(stream) {
                        eprintln!("处理客户端错误: {}", e);
                    }
                });
            }
            Err(e) => {
                eprintln!("连接失败: {}", e);
            }
        }
    }

    Ok(())
}

fn main() -> std::io::Result<()> {
    tcp_server()
}
```

### 2.2 TCP 客户端

```rust
use std::net::TcpStream;
use std::io::{Read, Write, BufRead, BufReader};

fn tcp_client() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080")?;
    println!("已连接到服务器");

    // 设置超时
    use std::time::Duration;
    stream.set_read_timeout(Some(Duration::from_secs(5)))?;
    stream.set_write_timeout(Some(Duration::from_secs(5)))?;

    // 发送消息
    let messages = ["Hello", "World", "From Rust"];
    for msg in &messages {
        stream.write_all(msg.as_bytes())?;
        stream.write_all(b"\n")?; // 添加换行符

        // 读取响应
        let mut reader = BufReader::new(&stream);
        let mut response = String::new();
        reader.read_line(&mut response)?;
        println!("收到响应: {}", response.trim());
    }

    Ok(())
}

fn main() -> std::io::Result<()> {
    tcp_client()
}
```

### 2.3 连接池

```rust
use std::sync::{Arc, Mutex};
use std::net::TcpStream;
use std::collections::VecDeque;

struct ConnectionPool {
    connections: Arc<Mutex<VecDeque<TcpStream>>>,
    max_size: usize,
    address: String,
}

impl ConnectionPool {
    fn new(address: String, max_size: usize) -> Self {
        Self {
            connections: Arc::new(Mutex::new(VecDeque::new())),
            max_size,
            address,
        }
    }

    fn get_connection(&self) -> std::io::Result<TcpStream> {
        let mut pool = self.connections.lock().unwrap();

        if let Some(conn) = pool.pop_front() {
            Ok(conn)
        } else {
            TcpStream::connect(&self.address)
        }
    }

    fn return_connection(&self, conn: TcpStream) {
        let mut pool = self.connections.lock().unwrap();
        if pool.len() < self.max_size {
            pool.push_back(conn);
        }
        // 超过最大值时丢弃连接
    }
}

fn main() -> std::io::Result<()> {
    let pool = ConnectionPool::new("127.0.0.1:8080".to_string(), 10);

    let conn = pool.get_connection()?;
    // 使用连接...
    pool.return_connection(conn);

    Ok(())
}
```

---

## 3. UDP 数据报通信

### 3.1 UDP 基础

**UDP 特点**：

- **无连接**：不建立连接
- **不可靠**：不保证送达
- **低延迟**：适合实时应用
- **无序传输**：数据报可能乱序

```rust
use std::net::UdpSocket;

// UDP 服务器
fn udp_server() -> std::io::Result<()> {
    let socket = UdpSocket::bind("127.0.0.1:8080")?;
    println!("UDP 服务器监听: {}", socket.local_addr()?);

    let mut buf = [0; 1024];
    loop {
        let (n, src) = socket.recv_from(&mut buf)?;
        println!("收到 {} 字节来自 {}: {}", n, src, String::from_utf8_lossy(&buf[..n]));

        // 回显数据
        socket.send_to(&buf[..n], src)?;
    }
}

// UDP 客户端
fn udp_client() -> std::io::Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:0")?; // 绑定到任意端口
    socket.connect("127.0.0.1:8080")?; // 可选：连接到目标

    // 发送数据
    socket.send(b"Hello UDP")?;

    // 接收响应
    let mut buf = [0; 1024];
    let n = socket.recv(&mut buf)?;
    println!("收到响应: {}", String::from_utf8_lossy(&buf[..n]));

    Ok(())
}

fn main() -> std::io::Result<()> {
    // 选择运行服务器或客户端
    // udp_server()
    udp_client()
}
```

### 3.2 UDP 多播

```rust
use std::net::{UdpSocket, Ipv4Addr};

fn udp_multicast_sender() -> std::io::Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:0")?;
    let multicast_addr = "239.255.0.1:8080";

    let message = b"Multicast message";
    socket.send_to(message, multicast_addr)?;
    println!("发送多播消息");

    Ok(())
}

fn udp_multicast_receiver() -> std::io::Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:8080")?;
    let multicast_addr = Ipv4Addr::new(239, 255, 0, 1);
    let interface = Ipv4Addr::new(0, 0, 0, 0);

    // 加入多播组
    socket.join_multicast_v4(&multicast_addr, &interface)?;
    println!("加入多播组: {}", multicast_addr);

    let mut buf = [0; 1024];
    loop {
        let (n, src) = socket.recv_from(&mut buf)?;
        println!("收到多播消息来自 {}: {}", src, String::from_utf8_lossy(&buf[..n]));
    }
}

fn main() -> std::io::Result<()> {
    // udp_multicast_sender()
    udp_multicast_receiver()
}
```

---

## 4. DNS 解析

### 4.1 标准库 DNS 解析

```rust
use std::net::{ToSocketAddrs, IpAddr};

fn dns_resolution() -> std::io::Result<()> {
    // 解析域名
    let addresses: Vec<_> = "www.rust-lang.org:443"
        .to_socket_addrs()?
        .collect();

    println!("解析到 {} 个地址:", addresses.len());
    for addr in addresses {
        println!("  - {}", addr);
    }

    Ok(())
}

fn main() -> std::io::Result<()> {
    dns_resolution()
}
```

### 4.2 使用 trust-dns (hickory-dns)

```rust
use hickory_resolver::TokioResolver;
use hickory_resolver::config::*;

#[tokio::main]
async fn advanced_dns_resolution() -> Result<(), Box<dyn std::error::Error>> {
    // 创建异步 DNS 解析器
    let resolver = TokioResolver::tokio(
        ResolverConfig::default(),
        ResolverOpts::default(),
    );

    // 查询 A 记录
    let response = resolver.lookup_ip("www.rust-lang.org").await?;
    println!("A 记录:");
    for ip in response.iter() {
        println!("  - {}", ip);
    }

    // 查询 MX 记录
    let mx_response = resolver.mx_lookup("rust-lang.org").await?;
    println!("\nMX 记录:");
    for mx in mx_response.iter() {
        println!("  - 优先级: {}, 主机: {}", mx.preference(), mx.exchange());
    }

    Ok(())
}

fn main() {
    if let Err(e) = advanced_dns_resolution() {
        eprintln!("DNS 解析错误: {}", e);
    }
}
```

---

## 5. 错误处理与超时

### 5.1 超时设置

```rust
use std::net::TcpStream;
use std::time::Duration;
use std::io::{Read, Write};

fn timeout_handling() -> std::io::Result<()> {
    let mut stream = TcpStream::connect_timeout(
        &"127.0.0.1:8080".parse().unwrap(),
        Duration::from_secs(5),
    )?;

    // 设置读写超时
    stream.set_read_timeout(Some(Duration::from_secs(10)))?;
    stream.set_write_timeout(Some(Duration::from_secs(5)))?;

    // 发送数据
    stream.write_all(b"Hello")?;

    // 读取响应（带超时）
    let mut buffer = [0; 1024];
    match stream.read(&mut buffer) {
        Ok(n) => println!("读取 {} 字节", n),
        Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
            println!("读取超时");
        }
        Err(e) => return Err(e),
    }

    Ok(())
}

fn main() {
    if let Err(e) = timeout_handling() {
        eprintln!("错误: {}", e);
    }
}
```

### 5.2 重试策略

```rust
use std::net::TcpStream;
use std::time::Duration;
use std::thread;

fn connect_with_retry(address: &str, max_retries: u32) -> Result<TcpStream, std::io::Error> {
    let mut attempts = 0;
    let mut delay = Duration::from_millis(100);

    loop {
        match TcpStream::connect(address) {
            Ok(stream) => {
                println!("连接成功（尝试 {}）", attempts + 1);
                return Ok(stream);
            }
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("连接失败，{}ms 后重试（尝试 {}）", delay.as_millis(), attempts);
                thread::sleep(delay);
                delay *= 2; // 指数退避
            }
            Err(e) => {
                return Err(e);
            }
        }
    }
}

fn main() {
    match connect_with_retry("127.0.0.1:8080", 5) {
        Ok(_) => println!("连接成功"),
        Err(e) => eprintln!("连接失败: {}", e),
    }
}
```

---

## 6. 异步 vs 同步

### 6.1 同步网络编程

**优点**：

- 简单直观
- 易于调试
- 适合低并发

**缺点**：

- 阻塞 I/O
- 线程开销大
- 扩展性差

```rust
use std::net::TcpListener;
use std::thread;

fn sync_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080")?;

    for stream in listener.incoming() {
        let stream = stream?;
        // 每个连接一个线程
        thread::spawn(move || {
            // 处理连接...
        });
    }

    Ok(())
}
```

### 6.2 异步网络编程

**优点**：

- 非阻塞 I/O
- 高并发
- 资源高效

**缺点**：

- 复杂性高
- 学习曲线陡峭

```rust
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn async_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("异步服务器监听: 127.0.0.1:8080");

    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!("新连接: {}", addr);

        // 为每个连接创建任务
        tokio::spawn(async move {
            let mut buffer = [0; 1024];

            loop {
                match socket.read(&mut buffer).await {
                    Ok(0) => break, // 连接关闭
                    Ok(n) => {
                        // 回显数据
                        if socket.write_all(&buffer[..n]).await.is_err() {
                            break;
                        }
                    }
                    Err(_) => break,
                }
            }
        });
    }
}

fn main() {
    if let Err(e) = async_server() {
        eprintln!("服务器错误: {}", e);
    }
}
```

### 6.3 选择指南

| 场景 | 推荐 | 理由 |
|-----|------|------|
| **简单脚本** | 同步 | 代码简单 |
| **高并发服务器** | 异步 | 资源高效 |
| **阻塞操作多** | 异步 + blocking | 混合使用 |
| **实时性要求** | 异步 | 低延迟 |

---

## 7. 实战案例

### 7.1 简单 HTTP 服务器

```rust
use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};

fn handle_http_request(mut stream: TcpStream) -> std::io::Result<()> {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer)?;

    let request = String::from_utf8_lossy(&buffer);
    println!("收到请求:\n{}", request);

    // 构造 HTTP 响应
    let response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<h1>Hello from Rust!</h1>";
    stream.write_all(response.as_bytes())?;
    stream.flush()?;

    Ok(())
}

fn http_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080")?;
    println!("HTTP 服务器运行在 http://127.0.0.1:8080");

    for stream in listener.incoming() {
        let stream = stream?;
        std::thread::spawn(|| {
            if let Err(e) = handle_http_request(stream) {
                eprintln!("处理请求错误: {}", e);
            }
        });
    }

    Ok(())
}

fn main() -> std::io::Result<()> {
    http_server()
}
```

### 7.2 端口扫描器

```rust
use std::net::{TcpStream, SocketAddr};
use std::time::Duration;
use std::str::FromStr;

fn scan_port(host: &str, port: u16) -> bool {
    let address = format!("{}:{}", host, port);
    if let Ok(addr) = SocketAddr::from_str(&address) {
        TcpStream::connect_timeout(&addr, Duration::from_millis(500)).is_ok()
    } else {
        false
    }
}

fn port_scanner() {
    let host = "127.0.0.1";
    let start_port = 1;
    let end_port = 1024;

    println!("扫描 {} 的端口 {}-{}", host, start_port, end_port);

    for port in start_port..=end_port {
        if scan_port(host, port) {
            println!("端口 {} 开放", port);
        }
    }

    println!("扫描完成");
}

fn main() {
    port_scanner();
}
```

---

## 8. 总结

### 核心要点

| 协议 | 特点 | 适用场景 |
|-----|------|---------|
| **TCP** | 可靠、有序、面向连接 | HTTP, SSH, 文件传输 |
| **UDP** | 不可靠、无连接、低延迟 | 视频流、游戏、DNS |

### 最佳实践

1. **超时设置**: 总是设置超时避免无限等待
2. **错误处理**: 使用 `Result` 类型妥善处理错误
3. **资源释放**: 利用 RAII 自动释放连接
4. **异步优先**: 高并发场景使用异步
5. **连接池**: 复用连接减少开销

---

## 📚 参考资源

- [Rust std::net](https://doc.rust-lang.org/std/net/)
- [Tokio 异步网络](https://tokio.rs/)
- [Hickory DNS](https://github.com/hickory-dns/hickory-dns)

---

**下一步**: 学习 [HTTP 客户端开发](02_HTTP客户端开发.md)，深入 HTTP 协议实践。
