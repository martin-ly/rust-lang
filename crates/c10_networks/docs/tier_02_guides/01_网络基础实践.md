# C10 Networks - Tier 2: ç½‘ç»œåŸºç¡€å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 45 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C10 Networks - Tier 2: ç½‘ç»œåŸºç¡€å®è·µ](#c10-networks---tier-2-ç½‘ç»œåŸºç¡€å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç½‘ç»œç¼–ç¨‹åŸºç¡€](#1-ç½‘ç»œç¼–ç¨‹åŸºç¡€)
    - [1.1 OSI æ¨¡å‹ä¸ TCP/IP](#11-osi-æ¨¡å‹ä¸-tcpip)
    - [1.2 åœ°å€ä¸ç«¯å£](#12-åœ°å€ä¸ç«¯å£)
  - [2. TCP è¿æ¥ç®¡ç†](#2-tcp-è¿æ¥ç®¡ç†)
    - [2.1 TCP æœåŠ¡å™¨](#21-tcp-æœåŠ¡å™¨)
    - [2.2 TCP å®¢æˆ·ç«¯](#22-tcp-å®¢æˆ·ç«¯)
    - [2.3 è¿æ¥æ± ](#23-è¿æ¥æ± )
  - [3. UDP æ•°æ®æŠ¥é€šä¿¡](#3-udp-æ•°æ®æŠ¥é€šä¿¡)
    - [3.1 UDP åŸºç¡€](#31-udp-åŸºç¡€)
    - [3.2 UDP å¤šæ’­](#32-udp-å¤šæ’­)
  - [4. DNS è§£æ](#4-dns-è§£æ)
    - [4.1 æ ‡å‡†åº“ DNS è§£æ](#41-æ ‡å‡†åº“-dns-è§£æ)
    - [4.2 ä½¿ç”¨ trust-dns (hickory-dns)](#42-ä½¿ç”¨-trust-dns-hickory-dns)
  - [5. é”™è¯¯å¤„ç†ä¸è¶…æ—¶](#5-é”™è¯¯å¤„ç†ä¸è¶…æ—¶)
    - [5.1 è¶…æ—¶è®¾ç½®](#51-è¶…æ—¶è®¾ç½®)
    - [5.2 é‡è¯•ç­–ç•¥](#52-é‡è¯•ç­–ç•¥)
  - [6. å¼‚æ­¥ vs åŒæ­¥](#6-å¼‚æ­¥-vs-åŒæ­¥)
    - [6.1 åŒæ­¥ç½‘ç»œç¼–ç¨‹](#61-åŒæ­¥ç½‘ç»œç¼–ç¨‹)
    - [6.2 å¼‚æ­¥ç½‘ç»œç¼–ç¨‹](#62-å¼‚æ­¥ç½‘ç»œç¼–ç¨‹)
    - [6.3 é€‰æ‹©æŒ‡å—](#63-é€‰æ‹©æŒ‡å—)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 ç®€å• HTTP æœåŠ¡å™¨](#71-ç®€å•-http-æœåŠ¡å™¨)
    - [7.2 ç«¯å£æ‰«æå™¨](#72-ç«¯å£æ‰«æå™¨)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. ç½‘ç»œç¼–ç¨‹åŸºç¡€

### 1.1 OSI æ¨¡å‹ä¸ TCP/IP

**OSI ä¸ƒå±‚æ¨¡å‹**ï¼š

- **åº”ç”¨å±‚** (HTTP, FTP, DNS)
- **ä¼ è¾“å±‚** (TCP, UDP)
- **ç½‘ç»œå±‚** (IP)
- **é“¾è·¯å±‚** (Ethernet)

**Rust ç½‘ç»œç¼–ç¨‹å±‚æ¬¡**ï¼š

```rust
use std::net::{TcpStream, UdpSocket, IpAddr, SocketAddr};
use std::io::{Read, Write};

// åŸºç¡€ç¤ºä¾‹ï¼šTCP å®¢æˆ·ç«¯
fn simple_tcp_client() -> std::io::Result<()> {
    // è¿æ¥åˆ°æœåŠ¡å™¨
    let mut stream = TcpStream::connect("127.0.0.1:8080")?;
    
    // å‘é€æ•°æ®
    stream.write_all(b"Hello, Server!")?;
    
    // æ¥æ”¶å“åº”
    let mut buffer = [0; 512];
    let n = stream.read(&mut buffer)?;
    println!("æ”¶åˆ°å“åº”: {}", String::from_utf8_lossy(&buffer[..n]));
    
    Ok(())
}

fn main() -> std::io::Result<()> {
    simple_tcp_client()
}
```

### 1.2 åœ°å€ä¸ç«¯å£

**IPv4 vs IPv6**ï¼š

```rust
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};

fn address_examples() {
    // IPv4 åœ°å€
    let ipv4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));
    let ipv4_loopback = IpAddr::V4(Ipv4Addr::LOCALHOST);
    
    // IPv6 åœ°å€
    let ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));
    let ipv6_loopback = IpAddr::V6(Ipv6Addr::LOCALHOST);
    
    // Socket åœ°å€ (IP + ç«¯å£)
    let socket_addr = SocketAddr::new(ipv4, 8080);
    println!("Socket åœ°å€: {}", socket_addr);
    
    // å­—ç¬¦ä¸²è§£æ
    let parsed: SocketAddr = "192.168.1.1:8080".parse().unwrap();
    println!("è§£æåœ°å€: {}", parsed);
}

fn main() {
    address_examples();
}
```

**ç«¯å£èŒƒå›´**ï¼š

- **0-1023**: ç³»ç»Ÿä¿ç•™ç«¯å£ (HTTP:80, HTTPS:443)
- **1024-49151**: æ³¨å†Œç«¯å£ (åº”ç”¨ç¨‹åº)
- **49152-65535**: åŠ¨æ€/ç§æœ‰ç«¯å£

---

## 2. TCP è¿æ¥ç®¡ç†

### 2.1 TCP æœåŠ¡å™¨

```rust
use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};
use std::thread;

fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {
    let peer_addr = stream.peer_addr()?;
    println!("æ–°è¿æ¥: {}", peer_addr);
    
    let mut buffer = [0; 1024];
    loop {
        let n = stream.read(&mut buffer)?;
        if n == 0 {
            println!("å®¢æˆ·ç«¯ {} æ–­å¼€è¿æ¥", peer_addr);
            break;
        }
        
        println!("æ”¶åˆ° {} å­—èŠ‚: {}", n, String::from_utf8_lossy(&buffer[..n]));
        
        // å›æ˜¾æ•°æ®
        stream.write_all(&buffer[..n])?;
    }
    
    Ok(())
}

fn tcp_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080")?;
    println!("æœåŠ¡å™¨ç›‘å¬: {}", listener.local_addr()?);
    
    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                // ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»ºçº¿ç¨‹
                thread::spawn(|| {
                    if let Err(e) = handle_client(stream) {
                        eprintln!("å¤„ç†å®¢æˆ·ç«¯é”™è¯¯: {}", e);
                    }
                });
            }
            Err(e) => {
                eprintln!("è¿æ¥å¤±è´¥: {}", e);
            }
        }
    }
    
    Ok(())
}

fn main() -> std::io::Result<()> {
    tcp_server()
}
```

### 2.2 TCP å®¢æˆ·ç«¯

```rust
use std::net::TcpStream;
use std::io::{Read, Write, BufRead, BufReader};

fn tcp_client() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080")?;
    println!("å·²è¿æ¥åˆ°æœåŠ¡å™¨");
    
    // è®¾ç½®è¶…æ—¶
    use std::time::Duration;
    stream.set_read_timeout(Some(Duration::from_secs(5)))?;
    stream.set_write_timeout(Some(Duration::from_secs(5)))?;
    
    // å‘é€æ¶ˆæ¯
    let messages = ["Hello", "World", "From Rust"];
    for msg in &messages {
        stream.write_all(msg.as_bytes())?;
        stream.write_all(b"\n")?; // æ·»åŠ æ¢è¡Œç¬¦
        
        // è¯»å–å“åº”
        let mut reader = BufReader::new(&stream);
        let mut response = String::new();
        reader.read_line(&mut response)?;
        println!("æ”¶åˆ°å“åº”: {}", response.trim());
    }
    
    Ok(())
}

fn main() -> std::io::Result<()> {
    tcp_client()
}
```

### 2.3 è¿æ¥æ± 

```rust
use std::sync::{Arc, Mutex};
use std::net::TcpStream;
use std::collections::VecDeque;

struct ConnectionPool {
    connections: Arc<Mutex<VecDeque<TcpStream>>>,
    max_size: usize,
    address: String,
}

impl ConnectionPool {
    fn new(address: String, max_size: usize) -> Self {
        Self {
            connections: Arc::new(Mutex::new(VecDeque::new())),
            max_size,
            address,
        }
    }
    
    fn get_connection(&self) -> std::io::Result<TcpStream> {
        let mut pool = self.connections.lock().unwrap();
        
        if let Some(conn) = pool.pop_front() {
            Ok(conn)
        } else {
            TcpStream::connect(&self.address)
        }
    }
    
    fn return_connection(&self, conn: TcpStream) {
        let mut pool = self.connections.lock().unwrap();
        if pool.len() < self.max_size {
            pool.push_back(conn);
        }
        // è¶…è¿‡æœ€å¤§å€¼æ—¶ä¸¢å¼ƒè¿æ¥
    }
}

fn main() -> std::io::Result<()> {
    let pool = ConnectionPool::new("127.0.0.1:8080".to_string(), 10);
    
    let conn = pool.get_connection()?;
    // ä½¿ç”¨è¿æ¥...
    pool.return_connection(conn);
    
    Ok(())
}
```

---

## 3. UDP æ•°æ®æŠ¥é€šä¿¡

### 3.1 UDP åŸºç¡€

**UDP ç‰¹ç‚¹**ï¼š

- **æ— è¿æ¥**ï¼šä¸å»ºç«‹è¿æ¥
- **ä¸å¯é **ï¼šä¸ä¿è¯é€è¾¾
- **ä½å»¶è¿Ÿ**ï¼šé€‚åˆå®æ—¶åº”ç”¨
- **æ— åºä¼ è¾“**ï¼šæ•°æ®æŠ¥å¯èƒ½ä¹±åº

```rust
use std::net::UdpSocket;

// UDP æœåŠ¡å™¨
fn udp_server() -> std::io::Result<()> {
    let socket = UdpSocket::bind("127.0.0.1:8080")?;
    println!("UDP æœåŠ¡å™¨ç›‘å¬: {}", socket.local_addr()?);
    
    let mut buf = [0; 1024];
    loop {
        let (n, src) = socket.recv_from(&mut buf)?;
        println!("æ”¶åˆ° {} å­—èŠ‚æ¥è‡ª {}: {}", n, src, String::from_utf8_lossy(&buf[..n]));
        
        // å›æ˜¾æ•°æ®
        socket.send_to(&buf[..n], src)?;
    }
}

// UDP å®¢æˆ·ç«¯
fn udp_client() -> std::io::Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:0")?; // ç»‘å®šåˆ°ä»»æ„ç«¯å£
    socket.connect("127.0.0.1:8080")?; // å¯é€‰ï¼šè¿æ¥åˆ°ç›®æ ‡
    
    // å‘é€æ•°æ®
    socket.send(b"Hello UDP")?;
    
    // æ¥æ”¶å“åº”
    let mut buf = [0; 1024];
    let n = socket.recv(&mut buf)?;
    println!("æ”¶åˆ°å“åº”: {}", String::from_utf8_lossy(&buf[..n]));
    
    Ok(())
}

fn main() -> std::io::Result<()> {
    // é€‰æ‹©è¿è¡ŒæœåŠ¡å™¨æˆ–å®¢æˆ·ç«¯
    // udp_server()
    udp_client()
}
```

### 3.2 UDP å¤šæ’­

```rust
use std::net::{UdpSocket, Ipv4Addr};

fn udp_multicast_sender() -> std::io::Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:0")?;
    let multicast_addr = "239.255.0.1:8080";
    
    let message = b"Multicast message";
    socket.send_to(message, multicast_addr)?;
    println!("å‘é€å¤šæ’­æ¶ˆæ¯");
    
    Ok(())
}

fn udp_multicast_receiver() -> std::io::Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:8080")?;
    let multicast_addr = Ipv4Addr::new(239, 255, 0, 1);
    let interface = Ipv4Addr::new(0, 0, 0, 0);
    
    // åŠ å…¥å¤šæ’­ç»„
    socket.join_multicast_v4(&multicast_addr, &interface)?;
    println!("åŠ å…¥å¤šæ’­ç»„: {}", multicast_addr);
    
    let mut buf = [0; 1024];
    loop {
        let (n, src) = socket.recv_from(&mut buf)?;
        println!("æ”¶åˆ°å¤šæ’­æ¶ˆæ¯æ¥è‡ª {}: {}", src, String::from_utf8_lossy(&buf[..n]));
    }
}

fn main() -> std::io::Result<()> {
    // udp_multicast_sender()
    udp_multicast_receiver()
}
```

---

## 4. DNS è§£æ

### 4.1 æ ‡å‡†åº“ DNS è§£æ

```rust
use std::net::{ToSocketAddrs, IpAddr};

fn dns_resolution() -> std::io::Result<()> {
    // è§£æåŸŸå
    let addresses: Vec<_> = "www.rust-lang.org:443"
        .to_socket_addrs()?
        .collect();
    
    println!("è§£æåˆ° {} ä¸ªåœ°å€:", addresses.len());
    for addr in addresses {
        println!("  - {}", addr);
    }
    
    Ok(())
}

fn main() -> std::io::Result<()> {
    dns_resolution()
}
```

### 4.2 ä½¿ç”¨ trust-dns (hickory-dns)

```rust
use hickory_resolver::TokioResolver;
use hickory_resolver::config::*;

#[tokio::main]
async fn advanced_dns_resolution() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºå¼‚æ­¥ DNS è§£æå™¨
    let resolver = TokioResolver::tokio(
        ResolverConfig::default(),
        ResolverOpts::default(),
    );
    
    // æŸ¥è¯¢ A è®°å½•
    let response = resolver.lookup_ip("www.rust-lang.org").await?;
    println!("A è®°å½•:");
    for ip in response.iter() {
        println!("  - {}", ip);
    }
    
    // æŸ¥è¯¢ MX è®°å½•
    let mx_response = resolver.mx_lookup("rust-lang.org").await?;
    println!("\nMX è®°å½•:");
    for mx in mx_response.iter() {
        println!("  - ä¼˜å…ˆçº§: {}, ä¸»æœº: {}", mx.preference(), mx.exchange());
    }
    
    Ok(())
}

fn main() {
    if let Err(e) = advanced_dns_resolution() {
        eprintln!("DNS è§£æé”™è¯¯: {}", e);
    }
}
```

---

## 5. é”™è¯¯å¤„ç†ä¸è¶…æ—¶

### 5.1 è¶…æ—¶è®¾ç½®

```rust
use std::net::TcpStream;
use std::time::Duration;
use std::io::{Read, Write};

fn timeout_handling() -> std::io::Result<()> {
    let mut stream = TcpStream::connect_timeout(
        &"127.0.0.1:8080".parse().unwrap(),
        Duration::from_secs(5),
    )?;
    
    // è®¾ç½®è¯»å†™è¶…æ—¶
    stream.set_read_timeout(Some(Duration::from_secs(10)))?;
    stream.set_write_timeout(Some(Duration::from_secs(5)))?;
    
    // å‘é€æ•°æ®
    stream.write_all(b"Hello")?;
    
    // è¯»å–å“åº”ï¼ˆå¸¦è¶…æ—¶ï¼‰
    let mut buffer = [0; 1024];
    match stream.read(&mut buffer) {
        Ok(n) => println!("è¯»å– {} å­—èŠ‚", n),
        Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
            println!("è¯»å–è¶…æ—¶");
        }
        Err(e) => return Err(e),
    }
    
    Ok(())
}

fn main() {
    if let Err(e) = timeout_handling() {
        eprintln!("é”™è¯¯: {}", e);
    }
}
```

### 5.2 é‡è¯•ç­–ç•¥

```rust
use std::net::TcpStream;
use std::time::Duration;
use std::thread;

fn connect_with_retry(address: &str, max_retries: u32) -> Result<TcpStream, std::io::Error> {
    let mut attempts = 0;
    let mut delay = Duration::from_millis(100);
    
    loop {
        match TcpStream::connect(address) {
            Ok(stream) => {
                println!("è¿æ¥æˆåŠŸï¼ˆå°è¯• {}ï¼‰", attempts + 1);
                return Ok(stream);
            }
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("è¿æ¥å¤±è´¥ï¼Œ{}ms åé‡è¯•ï¼ˆå°è¯• {}ï¼‰", delay.as_millis(), attempts);
                thread::sleep(delay);
                delay *= 2; // æŒ‡æ•°é€€é¿
            }
            Err(e) => {
                return Err(e);
            }
        }
    }
}

fn main() {
    match connect_with_retry("127.0.0.1:8080", 5) {
        Ok(_) => println!("è¿æ¥æˆåŠŸ"),
        Err(e) => eprintln!("è¿æ¥å¤±è´¥: {}", e),
    }
}
```

---

## 6. å¼‚æ­¥ vs åŒæ­¥

### 6.1 åŒæ­¥ç½‘ç»œç¼–ç¨‹

**ä¼˜ç‚¹**ï¼š

- ç®€å•ç›´è§‚
- æ˜“äºè°ƒè¯•
- é€‚åˆä½å¹¶å‘

**ç¼ºç‚¹**ï¼š

- é˜»å¡ I/O
- çº¿ç¨‹å¼€é”€å¤§
- æ‰©å±•æ€§å·®

```rust
use std::net::TcpListener;
use std::thread;

fn sync_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080")?;
    
    for stream in listener.incoming() {
        let stream = stream?;
        // æ¯ä¸ªè¿æ¥ä¸€ä¸ªçº¿ç¨‹
        thread::spawn(move || {
            // å¤„ç†è¿æ¥...
        });
    }
    
    Ok(())
}
```

### 6.2 å¼‚æ­¥ç½‘ç»œç¼–ç¨‹

**ä¼˜ç‚¹**ï¼š

- éé˜»å¡ I/O
- é«˜å¹¶å‘
- èµ„æºé«˜æ•ˆ

**ç¼ºç‚¹**ï¼š

- å¤æ‚æ€§é«˜
- å­¦ä¹ æ›²çº¿é™¡å³­

```rust
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn async_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("å¼‚æ­¥æœåŠ¡å™¨ç›‘å¬: 127.0.0.1:8080");
    
    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!("æ–°è¿æ¥: {}", addr);
        
        // ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»ºä»»åŠ¡
        tokio::spawn(async move {
            let mut buffer = [0; 1024];
            
            loop {
                match socket.read(&mut buffer).await {
                    Ok(0) => break, // è¿æ¥å…³é—­
                    Ok(n) => {
                        // å›æ˜¾æ•°æ®
                        if socket.write_all(&buffer[..n]).await.is_err() {
                            break;
                        }
                    }
                    Err(_) => break,
                }
            }
        });
    }
}

fn main() {
    if let Err(e) = async_server() {
        eprintln!("æœåŠ¡å™¨é”™è¯¯: {}", e);
    }
}
```

### 6.3 é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨è | ç†ç”± |
|-----|------|------|
| **ç®€å•è„šæœ¬** | åŒæ­¥ | ä»£ç ç®€å• |
| **é«˜å¹¶å‘æœåŠ¡å™¨** | å¼‚æ­¥ | èµ„æºé«˜æ•ˆ |
| **é˜»å¡æ“ä½œå¤š** | å¼‚æ­¥ + blocking | æ··åˆä½¿ç”¨ |
| **å®æ—¶æ€§è¦æ±‚** | å¼‚æ­¥ | ä½å»¶è¿Ÿ |

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 ç®€å• HTTP æœåŠ¡å™¨

```rust
use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};

fn handle_http_request(mut stream: TcpStream) -> std::io::Result<()> {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer)?;
    
    let request = String::from_utf8_lossy(&buffer);
    println!("æ”¶åˆ°è¯·æ±‚:\n{}", request);
    
    // æ„é€  HTTP å“åº”
    let response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<h1>Hello from Rust!</h1>";
    stream.write_all(response.as_bytes())?;
    stream.flush()?;
    
    Ok(())
}

fn http_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080")?;
    println!("HTTP æœåŠ¡å™¨è¿è¡Œåœ¨ http://127.0.0.1:8080");
    
    for stream in listener.incoming() {
        let stream = stream?;
        std::thread::spawn(|| {
            if let Err(e) = handle_http_request(stream) {
                eprintln!("å¤„ç†è¯·æ±‚é”™è¯¯: {}", e);
            }
        });
    }
    
    Ok(())
}

fn main() -> std::io::Result<()> {
    http_server()
}
```

### 7.2 ç«¯å£æ‰«æå™¨

```rust
use std::net::{TcpStream, SocketAddr};
use std::time::Duration;
use std::str::FromStr;

fn scan_port(host: &str, port: u16) -> bool {
    let address = format!("{}:{}", host, port);
    if let Ok(addr) = SocketAddr::from_str(&address) {
        TcpStream::connect_timeout(&addr, Duration::from_millis(500)).is_ok()
    } else {
        false
    }
}

fn port_scanner() {
    let host = "127.0.0.1";
    let start_port = 1;
    let end_port = 1024;
    
    println!("æ‰«æ {} çš„ç«¯å£ {}-{}", host, start_port, end_port);
    
    for port in start_port..=end_port {
        if scan_port(host, port) {
            println!("ç«¯å£ {} å¼€æ”¾", port);
        }
    }
    
    println!("æ‰«æå®Œæˆ");
}

fn main() {
    port_scanner();
}
```

---

## 8. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

| åè®® | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|-----|------|---------|
| **TCP** | å¯é ã€æœ‰åºã€é¢å‘è¿æ¥ | HTTP, SSH, æ–‡ä»¶ä¼ è¾“ |
| **UDP** | ä¸å¯é ã€æ— è¿æ¥ã€ä½å»¶è¿Ÿ | è§†é¢‘æµã€æ¸¸æˆã€DNS |

### æœ€ä½³å®è·µ

1. **è¶…æ—¶è®¾ç½®**: æ€»æ˜¯è®¾ç½®è¶…æ—¶é¿å…æ— é™ç­‰å¾…
2. **é”™è¯¯å¤„ç†**: ä½¿ç”¨ `Result` ç±»å‹å¦¥å–„å¤„ç†é”™è¯¯
3. **èµ„æºé‡Šæ”¾**: åˆ©ç”¨ RAII è‡ªåŠ¨é‡Šæ”¾è¿æ¥
4. **å¼‚æ­¥ä¼˜å…ˆ**: é«˜å¹¶å‘åœºæ™¯ä½¿ç”¨å¼‚æ­¥
5. **è¿æ¥æ± **: å¤ç”¨è¿æ¥å‡å°‘å¼€é”€

---

## ğŸ“š å‚è€ƒèµ„æº

- [Rust std::net](https://doc.rust-lang.org/std/net/)
- [Tokio å¼‚æ­¥ç½‘ç»œ](https://tokio.rs/)
- [Hickory DNS](https://github.com/hickory-dns/hickory-dns)

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [HTTP å®¢æˆ·ç«¯å¼€å‘](02_HTTPå®¢æˆ·ç«¯å¼€å‘.md)ï¼Œæ·±å…¥ HTTP åè®®å®è·µã€‚
