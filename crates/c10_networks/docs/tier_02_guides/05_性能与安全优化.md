# C10 Networks - Tier 2: æ€§èƒ½ä¸å®‰å…¨ä¼˜åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 40 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C10 Networks - Tier 2: æ€§èƒ½ä¸å®‰å…¨ä¼˜åŒ–](#c10-networks---tier-2-æ€§èƒ½ä¸å®‰å…¨ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ€§èƒ½ä¼˜åŒ–](#1-æ€§èƒ½ä¼˜åŒ–)
    - [1.1 ç¼“å†²åŒºä¼˜åŒ–](#11-ç¼“å†²åŒºä¼˜åŒ–)
    - [1.2 æ‰¹é‡æ“ä½œ](#12-æ‰¹é‡æ“ä½œ)
    - [1.3 å¹¶å‘è¿æ¥é™åˆ¶](#13-å¹¶å‘è¿æ¥é™åˆ¶)
    - [1.4 é›¶æ‹·è´å‘é€æ–‡ä»¶](#14-é›¶æ‹·è´å‘é€æ–‡ä»¶)
  - [2. ç½‘ç»œå®‰å…¨åŸºç¡€](#2-ç½‘ç»œå®‰å…¨åŸºç¡€)
    - [2.1 è¾“å…¥éªŒè¯](#21-è¾“å…¥éªŒè¯)
    - [2.2 IP ç™½åå•/é»‘åå•](#22-ip-ç™½åå•é»‘åå•)
    - [2.3 é™æµä¿æŠ¤](#23-é™æµä¿æŠ¤)
  - [3. TLS/SSL å®è·µ](#3-tlsssl-å®è·µ)
    - [3.1 TLS å®¢æˆ·ç«¯](#31-tls-å®¢æˆ·ç«¯)
    - [3.2 TLS æœåŠ¡å™¨](#32-tls-æœåŠ¡å™¨)
  - [4. æ”»å‡»é˜²æŠ¤](#4-æ”»å‡»é˜²æŠ¤)
    - [4.1 DDoS é˜²æŠ¤](#41-ddos-é˜²æŠ¤)
    - [4.2 æ…¢é€Ÿæ”»å‡»é˜²æŠ¤](#42-æ…¢é€Ÿæ”»å‡»é˜²æŠ¤)
  - [5. ç›‘æ§ä¸è¯Šæ–­](#5-ç›‘æ§ä¸è¯Šæ–­)
    - [5.1 è¿æ¥ç»Ÿè®¡](#51-è¿æ¥ç»Ÿè®¡)
    - [5.2 æ€§èƒ½åˆ†æ](#52-æ€§èƒ½åˆ†æ)
  - [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
    - [6.1 å®‰å…¨çš„ HTTP ä»£ç†](#61-å®‰å…¨çš„-http-ä»£ç†)
  - [7. æ€»ç»“](#7-æ€»ç»“)
    - [æ€§èƒ½ä¼˜åŒ–æ¸…å•](#æ€§èƒ½ä¼˜åŒ–æ¸…å•)
    - [å®‰å…¨æ£€æŸ¥æ¸…å•](#å®‰å…¨æ£€æŸ¥æ¸…å•)
    - [ç›‘æ§æŒ‡æ ‡](#ç›‘æ§æŒ‡æ ‡)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. æ€§èƒ½ä¼˜åŒ–

### 1.1 ç¼“å†²åŒºä¼˜åŒ–

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader, BufWriter};

async fn buffered_io_example(stream: TcpStream) -> std::io::Result<()> {
    // âŒ æœªç¼“å†²ï¼šæ¯æ¬¡éƒ½ç³»ç»Ÿè°ƒç”¨
    // let mut stream = stream;
    // stream.write_all(b"data").await?;
    
    // âœ… ä½¿ç”¨ç¼“å†²ï¼šå‡å°‘ç³»ç»Ÿè°ƒç”¨
    let (read_half, write_half) = tokio::io::split(stream);
    let mut reader = BufReader::with_capacity(8192, read_half);
    let mut writer = BufWriter::with_capacity(8192, write_half);
    
    // å†™å…¥æ•°æ®ï¼ˆå…ˆç¼“å­˜ï¼‰
    writer.write_all(b"Hello").await?;
    writer.write_all(b" World").await?;
    writer.flush().await?; // å¼ºåˆ¶åˆ·æ–°
    
    // è¯»å–æ•°æ®
    let mut buffer = String::new();
    let n = reader.read_to_string(&mut buffer).await?;
    println!("è¯»å– {} å­—èŠ‚: {}", n, buffer);
    
    Ok(())
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let stream = TcpStream::connect("127.0.0.1:8080").await?;
    buffered_io_example(stream).await
}
```

### 1.2 æ‰¹é‡æ“ä½œ

```rust
use tokio::net::TcpStream;
use tokio::io::AsyncWriteExt;

// âŒ ä½æ•ˆï¼šå¤šæ¬¡å°å†™å…¥
async fn write_inefficient(stream: &mut TcpStream) -> std::io::Result<()> {
    for i in 0..100 {
        stream.write_all(format!("item{}\n", i).as_bytes()).await?;
    }
    Ok(())
}

// âœ… é«˜æ•ˆï¼šæ‰¹é‡å†™å…¥
async fn write_efficient(stream: &mut TcpStream) -> std::io::Result<()> {
    let mut buffer = String::new();
    for i in 0..100 {
        buffer.push_str(&format!("item{}\n", i));
    }
    stream.write_all(buffer.as_bytes()).await?;
    Ok(())
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    write_efficient(&mut stream).await
}
```

### 1.3 å¹¶å‘è¿æ¥é™åˆ¶

```rust
use tokio::net::TcpListener;
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    let semaphore = Arc::new(Semaphore::new(100)); // é™åˆ¶æœ€å¤š 100 ä¸ªå¹¶å‘è¿æ¥
    
    println!("æœåŠ¡å™¨å¯åŠ¨ï¼Œæœ€å¤§å¹¶å‘: 100");
    
    loop {
        let (stream, addr) = listener.accept().await?;
        let semaphore = Arc::clone(&semaphore);
        
        tokio::spawn(async move {
            // è·å–è®¸å¯
            let _permit = semaphore.acquire().await.unwrap();
            println!("å¤„ç†è¿æ¥: {}", addr);
            
            // å¤„ç†è¿æ¥...
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            
            println!("è¿æ¥ {} å¤„ç†å®Œæˆ", addr);
            // permit åœ¨æ­¤è‡ªåŠ¨é‡Šæ”¾
        });
    }
}
```

### 1.4 é›¶æ‹·è´å‘é€æ–‡ä»¶

```rust
use tokio::net::TcpStream;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;

async fn send_file(stream: &mut TcpStream, path: &str) -> std::io::Result<()> {
    let mut file = File::open(path).await?;
    
    // ä½¿ç”¨ tokio::io::copy å®ç°é›¶æ‹·è´
    let bytes_copied = tokio::io::copy(&mut file, stream).await?;
    println!("å‘é€ {} å­—èŠ‚", bytes_copied);
    
    Ok(())
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    send_file(&mut stream, "large_file.dat").await
}
```

---

## 2. ç½‘ç»œå®‰å…¨åŸºç¡€

### 2.1 è¾“å…¥éªŒè¯

```rust
use std::net::IpAddr;

fn validate_input(input: &str) -> Result<(), String> {
    // é•¿åº¦æ£€æŸ¥
    if input.len() > 1024 {
        return Err("è¾“å…¥è¿‡é•¿".to_string());
    }
    
    // å­—ç¬¦ç™½åå•
    if !input.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_') {
        return Err("åŒ…å«éæ³•å­—ç¬¦".to_string());
    }
    
    Ok(())
}

fn validate_ip(ip_str: &str) -> Result<IpAddr, String> {
    ip_str.parse::<IpAddr>()
        .map_err(|_| "æ— æ•ˆçš„ IP åœ°å€".to_string())
}

fn main() {
    assert!(validate_input("valid_input").is_ok());
    assert!(validate_input("invalid;input").is_err());
    
    assert!(validate_ip("192.168.1.1").is_ok());
    assert!(validate_ip("invalid").is_err());
}
```

### 2.2 IP ç™½åå•/é»‘åå•

```rust
use std::net::IpAddr;
use std::collections::HashSet;

struct IpFilter {
    whitelist: HashSet<IpAddr>,
    blacklist: HashSet<IpAddr>,
}

impl IpFilter {
    fn new() -> Self {
        Self {
            whitelist: HashSet::new(),
            blacklist: HashSet::new(),
        }
    }
    
    fn add_to_whitelist(&mut self, ip: IpAddr) {
        self.whitelist.insert(ip);
    }
    
    fn add_to_blacklist(&mut self, ip: IpAddr) {
        self.blacklist.insert(ip);
    }
    
    fn is_allowed(&self, ip: &IpAddr) -> bool {
        // é»‘åå•ä¼˜å…ˆ
        if self.blacklist.contains(ip) {
            return false;
        }
        
        // å¦‚æœæœ‰ç™½åå•ï¼Œå¿…é¡»åœ¨ç™½åå•ä¸­
        if !self.whitelist.is_empty() {
            return self.whitelist.contains(ip);
        }
        
        // é»˜è®¤å…è®¸
        true
    }
}

fn main() {
    let mut filter = IpFilter::new();
    let ip1: IpAddr = "192.168.1.1".parse().unwrap();
    let ip2: IpAddr = "10.0.0.1".parse().unwrap();
    
    filter.add_to_blacklist(ip2);
    
    assert!(filter.is_allowed(&ip1));
    assert!(!filter.is_allowed(&ip2));
}
```

### 2.3 é™æµä¿æŠ¤

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::time::{Instant, Duration};
use tokio::sync::RwLock;
use std::sync::Arc;

struct RateLimiter {
    requests: Arc<RwLock<HashMap<IpAddr, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(RwLock::new(HashMap::new())),
            max_requests,
            window,
        }
    }
    
    async fn check_limit(&self, ip: IpAddr) -> bool {
        let mut requests = self.requests.write().await;
        let now = Instant::now();
        
        let entry = requests.entry(ip).or_insert_with(Vec::new);
        
        // æ¸…ç†è¿‡æœŸè®°å½•
        entry.retain(|&t| now.duration_since(t) < self.window);
        
        // æ£€æŸ¥é™åˆ¶
        if entry.len() < self.max_requests {
            entry.push(now);
            true
        } else {
            false
        }
    }
}

#[tokio::main]
async fn main() {
    let limiter = RateLimiter::new(5, Duration::from_secs(60));
    let ip: IpAddr = "192.168.1.1".parse().unwrap();
    
    for i in 0..10 {
        if limiter.check_limit(ip).await {
            println!("è¯·æ±‚ {} å…è®¸", i);
        } else {
            println!("è¯·æ±‚ {} è¢«é™æµ", i);
        }
    }
}
```

---

## 3. TLS/SSL å®è·µ

### 3.1 TLS å®¢æˆ·ç«¯

```rust
use tokio::net::TcpStream;
use tokio_rustls::{TlsConnector, rustls};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»º TLS é…ç½®
    let mut root_store = rustls::RootCertStore::empty();
    root_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());
    
    let config = rustls::ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();
    
    let connector = TlsConnector::from(Arc::new(config));
    
    // è¿æ¥æœåŠ¡å™¨
    let stream = TcpStream::connect("www.rust-lang.org:443").await?;
    let domain = rustls::pki_types::ServerName::try_from("www.rust-lang.org")?;
    
    let mut tls_stream = connector.connect(domain, stream).await?;
    
    // å‘é€ HTTP è¯·æ±‚
    tls_stream.write_all(b"GET / HTTP/1.1\r\nHost: www.rust-lang.org\r\n\r\n").await?;
    
    // è¯»å–å“åº”
    let mut buffer = Vec::new();
    tls_stream.read_to_end(&mut buffer).await?;
    println!("å“åº”: {} å­—èŠ‚", buffer.len());
    
    Ok(())
}
```

### 3.2 TLS æœåŠ¡å™¨

```rust
use tokio::net::TcpListener;
use tokio_rustls::{TlsAcceptor, rustls};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::sync::Arc;
use std::fs::File;
use std::io::BufReader;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åŠ è½½è¯ä¹¦å’Œç§é’¥
    let certs = rustls_pemfile::certs(&mut BufReader::new(File::open("cert.pem")?))
        .collect::<Result<Vec<_>, _>>()?;
    
    let key = rustls_pemfile::private_key(&mut BufReader::new(File::open("key.pem")?))
        .unwrap()
        .unwrap();
    
    // åˆ›å»º TLS é…ç½®
    let config = rustls::ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    
    let acceptor = TlsAcceptor::from(Arc::new(config));
    
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = TcpListener::bind("127.0.0.1:8443").await?;
    println!("TLS æœåŠ¡å™¨è¿è¡Œåœ¨ 127.0.0.1:8443");
    
    loop {
        let (stream, addr) = listener.accept().await?;
        let acceptor = acceptor.clone();
        
        tokio::spawn(async move {
            match acceptor.accept(stream).await {
                Ok(mut tls_stream) => {
                    println!("TLS è¿æ¥æ¥è‡ª: {}", addr);
                    
                    let mut buffer = [0u8; 1024];
                    if let Ok(n) = tls_stream.read(&mut buffer).await {
                        println!("æ”¶åˆ°: {}", String::from_utf8_lossy(&buffer[..n]));
                        let _ = tls_stream.write_all(b"HTTP/1.1 200 OK\r\n\r\nHello TLS").await;
                    }
                }
                Err(e) => eprintln!("TLS æ¡æ‰‹å¤±è´¥: {}", e),
            }
        });
    }
}
```

---

## 4. æ”»å‡»é˜²æŠ¤

### 4.1 DDoS é˜²æŠ¤

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::time::{Instant, Duration};
use tokio::sync::RwLock;
use std::sync::Arc;

struct DDoSProtector {
    connection_count: Arc<RwLock<HashMap<IpAddr, usize>>>,
    connection_times: Arc<RwLock<HashMap<IpAddr, Vec<Instant>>>>,
    max_connections_per_ip: usize,
    max_rate: usize, // æ¯ç§’æœ€å¤§è¿æ¥æ•°
}

impl DDoSProtector {
    fn new(max_connections_per_ip: usize, max_rate: usize) -> Self {
        Self {
            connection_count: Arc::new(RwLock::new(HashMap::new())),
            connection_times: Arc::new(RwLock::new(HashMap::new())),
            max_connections_per_ip,
            max_rate,
        }
    }
    
    async fn should_accept(&self, ip: IpAddr) -> bool {
        // æ£€æŸ¥å¹¶å‘è¿æ¥æ•°
        let conn_count = self.connection_count.read().await;
        if let Some(&count) = conn_count.get(&ip) {
            if count >= self.max_connections_per_ip {
                return false;
            }
        }
        drop(conn_count);
        
        // æ£€æŸ¥è¿æ¥é€Ÿç‡
        let mut times = self.connection_times.write().await;
        let entry = times.entry(ip).or_insert_with(Vec::new);
        
        let now = Instant::now();
        entry.retain(|&t| now.duration_since(t) < Duration::from_secs(1));
        
        if entry.len() >= self.max_rate {
            return false;
        }
        
        entry.push(now);
        true
    }
    
    async fn on_connect(&self, ip: IpAddr) {
        let mut count = self.connection_count.write().await;
        *count.entry(ip).or_insert(0) += 1;
    }
    
    async fn on_disconnect(&self, ip: IpAddr) {
        let mut count = self.connection_count.write().await;
        if let Some(c) = count.get_mut(&ip) {
            *c = c.saturating_sub(1);
            if *c == 0 {
                count.remove(&ip);
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let protector = DDoSProtector::new(10, 5);
    let ip: IpAddr = "192.168.1.1".parse().unwrap();
    
    for i in 0..20 {
        if protector.should_accept(ip).await {
            println!("è¿æ¥ {} æ¥å—", i);
            protector.on_connect(ip).await;
        } else {
            println!("è¿æ¥ {} æ‹’ç»ï¼ˆDDoS é˜²æŠ¤ï¼‰", i);
        }
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }
}
```

### 4.2 æ…¢é€Ÿæ”»å‡»é˜²æŠ¤

```rust
use tokio::net::TcpStream;
use tokio::time::{timeout, Duration};
use tokio::io::AsyncReadExt;

async fn handle_with_timeout(mut stream: TcpStream) -> std::io::Result<()> {
    let mut buffer = [0u8; 1024];
    
    // è®¾ç½®è¯»å–è¶…æ—¶ï¼ˆé˜²æ…¢é€Ÿæ”»å‡»ï¼‰
    match timeout(Duration::from_secs(30), stream.read(&mut buffer)).await {
        Ok(Ok(n)) => {
            println!("æ”¶åˆ° {} å­—èŠ‚", n);
            Ok(())
        }
        Ok(Err(e)) => {
            eprintln!("è¯»å–é”™è¯¯: {}", e);
            Err(e)
        }
        Err(_) => {
            eprintln!("è¯»å–è¶…æ—¶ï¼Œç–‘ä¼¼æ…¢é€Ÿæ”»å‡»");
            Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "æ…¢é€Ÿæ”»å‡»"))
        }
    }
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let stream = TcpStream::connect("127.0.0.1:8080").await?;
    handle_with_timeout(stream).await
}
```

---

## 5. ç›‘æ§ä¸è¯Šæ–­

### 5.1 è¿æ¥ç»Ÿè®¡

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use tokio::time::{interval, Duration};

struct ConnectionStats {
    total_connections: AtomicUsize,
    active_connections: AtomicUsize,
    total_bytes_sent: AtomicUsize,
    total_bytes_received: AtomicUsize,
}

impl ConnectionStats {
    fn new() -> Arc<Self> {
        Arc::new(Self {
            total_connections: AtomicUsize::new(0),
            active_connections: AtomicUsize::new(0),
            total_bytes_sent: AtomicUsize::new(0),
            total_bytes_received: AtomicUsize::new(0),
        })
    }
    
    fn on_connect(&self) {
        self.total_connections.fetch_add(1, Ordering::Relaxed);
        self.active_connections.fetch_add(1, Ordering::Relaxed);
    }
    
    fn on_disconnect(&self) {
        self.active_connections.fetch_sub(1, Ordering::Relaxed);
    }
    
    fn on_send(&self, bytes: usize) {
        self.total_bytes_sent.fetch_add(bytes, Ordering::Relaxed);
    }
    
    fn on_receive(&self, bytes: usize) {
        self.total_bytes_received.fetch_add(bytes, Ordering::Relaxed);
    }
    
    fn print_stats(&self) {
        println!("=== è¿æ¥ç»Ÿè®¡ ===");
        println!("æ€»è¿æ¥æ•°: {}", self.total_connections.load(Ordering::Relaxed));
        println!("æ´»è·ƒè¿æ¥: {}", self.active_connections.load(Ordering::Relaxed));
        println!("å‘é€å­—èŠ‚: {}", self.total_bytes_sent.load(Ordering::Relaxed));
        println!("æ¥æ”¶å­—èŠ‚: {}", self.total_bytes_received.load(Ordering::Relaxed));
    }
}

#[tokio::main]
async fn main() {
    let stats = ConnectionStats::new();
    let stats_clone = Arc::clone(&stats);
    
    // å®šæœŸæ‰“å°ç»Ÿè®¡
    tokio::spawn(async move {
        let mut ticker = interval(Duration::from_secs(10));
        loop {
            ticker.tick().await;
            stats_clone.print_stats();
        }
    });
    
    // æ¨¡æ‹Ÿè¿æ¥
    stats.on_connect();
    stats.on_send(1024);
    stats.on_receive(2048);
    stats.on_disconnect();
    
    tokio::time::sleep(Duration::from_secs(11)).await;
}
```

### 5.2 æ€§èƒ½åˆ†æ

```rust
use std::time::{Instant, Duration};

struct RequestTimer {
    start: Instant,
    operation: String,
}

impl RequestTimer {
    fn new(operation: impl Into<String>) -> Self {
        Self {
            start: Instant::now(),
            operation: operation.into(),
        }
    }
}

impl Drop for RequestTimer {
    fn drop(&mut self) {
        let duration = self.start.elapsed();
        println!("æ“ä½œ '{}' è€—æ—¶: {:?}", self.operation, duration);
        
        // æ…¢æ“ä½œè­¦å‘Š
        if duration > Duration::from_millis(100) {
            eprintln!("âš ï¸  æ…¢æ“ä½œ: {} è€—æ—¶ {:?}", self.operation, duration);
        }
    }
}

async fn slow_operation() {
    let _timer = RequestTimer::new("æ•°æ®åº“æŸ¥è¯¢");
    tokio::time::sleep(Duration::from_millis(150)).await;
}

#[tokio::main]
async fn main() {
    slow_operation().await;
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹

### 6.1 å®‰å…¨çš„ HTTP ä»£ç†

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::sync::Arc;

struct SecureProxy {
    rate_limiter: Arc<RateLimiter>,
    ip_filter: Arc<IpFilter>,
}

impl SecureProxy {
    fn new() -> Self {
        use std::time::Duration;
        Self {
            rate_limiter: Arc::new(RateLimiter::new(100, Duration::from_secs(60))),
            ip_filter: Arc::new(IpFilter::new()),
        }
    }
    
    async fn handle_client(&self, mut client: TcpStream, client_ip: std::net::IpAddr) -> std::io::Result<()> {
        // IP è¿‡æ»¤
        if !self.ip_filter.is_allowed(&client_ip) {
            println!("IP {} è¢«é˜»æ­¢", client_ip);
            return Ok(());
        }
        
        // é™æµæ£€æŸ¥
        if !self.rate_limiter.check_limit(client_ip).await {
            println!("IP {} è¶…è¿‡é™æµ", client_ip);
            return Ok(());
        }
        
        // è¯»å–è¯·æ±‚
        let mut buffer = vec![0u8; 1024];
        let n = client.read(&mut buffer).await?;
        
        // è½¬å‘åˆ°ç›®æ ‡æœåŠ¡å™¨
        let mut server = TcpStream::connect("target-server.com:80").await?;
        server.write_all(&buffer[..n]).await?;
        
        // è½¬å‘å“åº”
        let n = server.read(&mut buffer).await?;
        client.write_all(&buffer[..n]).await?;
        
        Ok(())
    }
}

use std::time::Duration;
use std::collections::HashSet;

struct IpFilter {
    whitelist: HashSet<std::net::IpAddr>,
}

impl IpFilter {
    fn new() -> Self {
        Self { whitelist: HashSet::new() }
    }
    fn is_allowed(&self, _ip: &std::net::IpAddr) -> bool { true }
}

struct RateLimiter;
impl RateLimiter {
    fn new(_max: usize, _dur: Duration) -> Self { Self }
    async fn check_limit(&self, _ip: std::net::IpAddr) -> bool { true }
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let proxy = Arc::new(SecureProxy::new());
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    
    println!("å®‰å…¨ä»£ç†æœåŠ¡å™¨è¿è¡Œåœ¨ 127.0.0.1:8080");
    
    loop {
        let (stream, addr) = listener.accept().await?;
        let proxy = Arc::clone(&proxy);
        
        tokio::spawn(async move {
            if let Err(e) = proxy.handle_client(stream, addr.ip()).await {
                eprintln!("å¤„ç†é”™è¯¯: {}", e);
            }
        });
    }
}
```

---

## 7. æ€»ç»“

### æ€§èƒ½ä¼˜åŒ–æ¸…å•

- [ ] ä½¿ç”¨ç¼“å†² I/O
- [ ] æ‰¹é‡æ“ä½œå‡å°‘ç³»ç»Ÿè°ƒç”¨
- [ ] é™åˆ¶å¹¶å‘è¿æ¥æ•°
- [ ] é›¶æ‹·è´æŠ€æœ¯
- [ ] è¿æ¥æ± å¤ç”¨

### å®‰å…¨æ£€æŸ¥æ¸…å•

- [ ] è¾“å…¥éªŒè¯
- [ ] IP ç™½åå•/é»‘åå•
- [ ] é™æµä¿æŠ¤
- [ ] TLS/SSL åŠ å¯†
- [ ] DDoS é˜²æŠ¤
- [ ] è¶…æ—¶è®¾ç½®

### ç›‘æ§æŒ‡æ ‡

| æŒ‡æ ‡ | æè¿° | å‘Šè­¦é˜ˆå€¼ |
|-----|------|---------|
| **æ´»è·ƒè¿æ¥æ•°** | å½“å‰å¹¶å‘è¿æ¥ | > 80% å®¹é‡ |
| **è¯·æ±‚é€Ÿç‡** | æ¯ç§’è¯·æ±‚æ•° | å¼‚å¸¸æ³¢åŠ¨ |
| **å“åº”æ—¶é—´** | è¯·æ±‚å¤„ç†å»¶è¿Ÿ | > 1 ç§’ |
| **é”™è¯¯ç‡** | å¤±è´¥è¯·æ±‚æ¯”ä¾‹ | > 1% |

---

## ğŸ“š å‚è€ƒèµ„æº

- [OWASP ç½‘ç»œå®‰å…¨](https://owasp.org/)
- [Rust TLS æœ€ä½³å®è·µ](https://docs.rs/tokio-rustls/)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](https://tokio.rs/tokio/topics/performance)

---

**ğŸ‰ æ­å–œï¼** ä½ å·²å®Œæˆ C10 Networks Tier 2 å…¨éƒ¨å®è·µæŒ‡å—çš„å­¦ä¹ ã€‚

**ä¸‹ä¸€æ­¥å»ºè®®**ï¼š

- æ·±å…¥å­¦ä¹  [Tier 3: æŠ€æœ¯å‚è€ƒ](../tier_03_references/README.md)
- æ¢ç´¢ [Tier 4: é«˜çº§ä¸»é¢˜](../tier_04_advanced/README.md)
- å®è·µåº”ç”¨åˆ°å®é™…é¡¹ç›®ä¸­
