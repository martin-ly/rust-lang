# ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
> **æ›´æ–°æ—¥æœŸ**: 2025-10-23
> **Rust ç‰ˆæœ¬**: 1.90+
> **æ–‡æ¡£å±‚çº§**: Tier 3 - æŠ€æœ¯å‚è€ƒ

---

## ç›®å½•

- [ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ](#ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. æ€§èƒ½æŒ‡æ ‡ä½“ç³»](#1-æ€§èƒ½æŒ‡æ ‡ä½“ç³»)
    - [æ ¸å¿ƒæŒ‡æ ‡](#æ ¸å¿ƒæŒ‡æ ‡)
    - [æ€§èƒ½æµ‹è¯•æ¡†æ¶](#æ€§èƒ½æµ‹è¯•æ¡†æ¶)
  - [2. HTTPæœåŠ¡å™¨åŸºå‡†](#2-httpæœåŠ¡å™¨åŸºå‡†)
    - [æ¡†æ¶å¯¹æ¯”ï¼ˆ12çº¿ç¨‹ï¼Œ64å­—èŠ‚å“åº”ï¼‰](#æ¡†æ¶å¯¹æ¯”12çº¿ç¨‹64å­—èŠ‚å“åº”)
    - [åŸºå‡†æµ‹è¯•è„šæœ¬](#åŸºå‡†æµ‹è¯•è„šæœ¬)
    - [axumæ€§èƒ½ä¼˜åŒ–](#axumæ€§èƒ½ä¼˜åŒ–)
  - [3. å¼‚æ­¥è¿è¡Œæ—¶æ€§èƒ½](#3-å¼‚æ­¥è¿è¡Œæ—¶æ€§èƒ½)
    - [Tokio vs async-std vs smol](#tokio-vs-async-std-vs-smol)
  - [4. WebSocketæ€§èƒ½](#4-websocketæ€§èƒ½)
    - [è¿æ¥æ•°ä¸ååé‡](#è¿æ¥æ•°ä¸ååé‡)
    - [WebSocketå‹æµ‹](#websocketå‹æµ‹)
  - [5. gRPCæ€§èƒ½åŸºå‡†](#5-grpcæ€§èƒ½åŸºå‡†)
    - [tonicæ€§èƒ½](#tonicæ€§èƒ½)
    - [gRPCå‹æµ‹å·¥å…·](#grpcå‹æµ‹å·¥å…·)
  - [6. DNSè§£ææ€§èƒ½](#6-dnsè§£ææ€§èƒ½)
    - [hickory-dns vs c-ares](#hickory-dns-vs-c-ares)
  - [7. TLSæ¡æ‰‹æ€§èƒ½](#7-tlsæ¡æ‰‹æ€§èƒ½)
    - [rustls vs native-tls vs openssl](#rustls-vs-native-tls-vs-openssl)
  - [8. åºåˆ—åŒ–æ€§èƒ½](#8-åºåˆ—åŒ–æ€§èƒ½)
    - [æ ¼å¼å¯¹æ¯”ï¼ˆ10,000æ¬¡åºåˆ—åŒ–ï¼‰](#æ ¼å¼å¯¹æ¯”10000æ¬¡åºåˆ—åŒ–)
  - [9. ç½‘ç»œI/Oæ¨¡å¼å¯¹æ¯”](#9-ç½‘ç»œioæ¨¡å¼å¯¹æ¯”)
    - [é˜»å¡ vs éé˜»å¡ vs io_uring](#é˜»å¡-vs-éé˜»å¡-vs-io_uring)
    - [io_uringç¤ºä¾‹](#io_uringç¤ºä¾‹)
  - [10. å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹](#10-å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: HTTPæœåŠ¡å™¨ä¼˜åŒ–](#æ¡ˆä¾‹1-httpæœåŠ¡å™¨ä¼˜åŒ–)
    - [æ¡ˆä¾‹2: WebSocketæ‰¹é‡å‘é€](#æ¡ˆä¾‹2-websocketæ‰¹é‡å‘é€)
    - [æ¡ˆä¾‹3: DNSç¼“å­˜](#æ¡ˆä¾‹3-dnsç¼“å­˜)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ (Network Performance Benchmark Reference)**:

- **å®šä¹‰**: ç½‘ç»œç¼–ç¨‹æ€§èƒ½åŸºå‡†æ•°æ®çš„æŠ€æœ¯å‚è€ƒï¼ŒåŒ…æ‹¬ HTTP æœåŠ¡å™¨ã€WebSocketã€gRPC ç­‰
- **ç±»å‹**: æ€§èƒ½åŸºå‡†æ–‡æ¡£
- **èŒƒç•´**: ç½‘ç»œç¼–ç¨‹ã€æ€§èƒ½åˆ†æ
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: æ€§èƒ½åŸºå‡†ã€åŸºå‡†æµ‹è¯•ã€æ€§èƒ½å¯¹æ¯”ã€ç½‘ç»œæ€§èƒ½

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å…¨é¢æ€§**: æ¶µç›–ä¸»è¦ç½‘ç»œåº“å’Œæ¡†æ¶
- **å‡†ç¡®æ€§**: å‡†ç¡®çš„æ€§èƒ½æ•°æ®
- **å¯å¯¹æ¯”æ€§**: æä¾›å¯¹æ¯”æ•°æ®
- **å®ç”¨æ€§**: æä¾›ä¼˜åŒ–å»ºè®®

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ --[contains]--> å¤šä¸ªç½‘ç»œæ€§èƒ½åŸºå‡†
- æ€§èƒ½è¯„ä¼° --[uses]--> ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ

**ä¾èµ–å…³ç³»**:

- ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ --[depends-on]--> åŸºå‡†æµ‹è¯•å·¥å…·
- ç½‘ç»œåº“é€‰æ‹© --[depends-on]--> ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ

### æ€ç»´å¯¼å›¾

```text
ç½‘ç»œæ€§èƒ½åŸºå‡†å‚è€ƒ
â”‚
â”œâ”€â”€ HTTP æœåŠ¡å™¨åŸºå‡†
â”‚   â””â”€â”€ æ¡†æ¶å¯¹æ¯”
â”œâ”€â”€ å¼‚æ­¥è¿è¡Œæ—¶æ€§èƒ½
â”‚   â””â”€â”€ Tokio vs async-std
â”œâ”€â”€ WebSocket æ€§èƒ½
â”‚   â””â”€â”€ è¿æ¥æ•°ä¸ååé‡
â”œâ”€â”€ gRPC æ€§èƒ½åŸºå‡†
â”‚   â””â”€â”€ tonic æ€§èƒ½
â”œâ”€â”€ DNS è§£ææ€§èƒ½
â”‚   â””â”€â”€ hickory-dns
â””â”€â”€ TLS æ¡æ‰‹æ€§èƒ½
    â””â”€â”€ rustls
```

---

## 1. æ€§èƒ½æŒ‡æ ‡ä½“ç³»

### æ ¸å¿ƒæŒ‡æ ‡

| æŒ‡æ ‡          | è¯´æ˜         | ç›®æ ‡å€¼      | æµ‹é‡å·¥å…·     |
| ------------- | ------------ | ----------- | ------------ |
| **ååé‡**    | è¯·æ±‚/ç§’      | >100k req/s | wrk, ab, oha |
| **å»¶è¿ŸP50**   | ä¸­ä½æ•°å»¶è¿Ÿ   | <5ms        | criterion    |
| **å»¶è¿ŸP99**   | 99åˆ†ä½å»¶è¿Ÿ   | <50ms       | criterion    |
| **å»¶è¿ŸP99.9** | 99.9åˆ†ä½å»¶è¿Ÿ | <200ms      | criterion    |
| **å¹¶å‘è¿æ¥**  | åŒæ—¶è¿æ¥æ•°   | >10k        | è‡ªå®šä¹‰       |
| **å†…å­˜å ç”¨**  | RSS          | <500MB      | heaptrack    |
| **CPUåˆ©ç”¨ç‡** | å¤šæ ¸åˆ©ç”¨ç‡   | >80%        | perf         |

### æ€§èƒ½æµ‹è¯•æ¡†æ¶

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::time::Duration;

/// ç½‘ç»œå»¶è¿ŸåŸºå‡†æµ‹è¯•
pub fn network_latency_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("network_latency");

    for size in [64, 512, 1024, 4096, 8192].iter() {
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            let data = vec![0u8; size];
            b.iter(|| {
                // æ¨¡æ‹Ÿç½‘ç»œå‘é€
                black_box(&data);
            });
        });
    }

    group.finish();
}

/// ååé‡åŸºå‡†æµ‹è¯•
pub fn throughput_benchmark(c: &mut Criterion) {
    c.bench_function("http_throughput", |b| {
        b.iter(|| {
            // æ¨¡æ‹ŸHTTPå¤„ç†
            black_box(process_http_request());
        });
    });
}

fn process_http_request() -> Vec<u8> {
    b"HTTP/1.1 200 OK\r\n\r\nHello, World!".to_vec()
}

criterion_group!(benches, network_latency_benchmark, throughput_benchmark);
criterion_main!(benches);
```

---

## 2. HTTPæœåŠ¡å™¨åŸºå‡†

### æ¡†æ¶å¯¹æ¯”ï¼ˆ12çº¿ç¨‹ï¼Œ64å­—èŠ‚å“åº”ï¼‰

| æ¡†æ¶          | ååé‡ (req/s) | P50å»¶è¿Ÿ | P99å»¶è¿Ÿ | å†…å­˜ (MB) |
| ------------- | -------------- | ------- | ------- | --------- |
| **axum**      | 520,000        | 0.8ms   | 3.2ms   | 45        |
| **actix-web** | 550,000        | 0.7ms   | 2.9ms   | 50        |
| **warp**      | 480,000        | 0.9ms   | 3.5ms   | 42        |
| **rocket**    | 380,000        | 1.2ms   | 5.1ms   | 55        |
| **hyper**     | 540,000        | 0.75ms  | 3.0ms   | 40        |

### åŸºå‡†æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash
# HTTPæœåŠ¡å™¨å‹æµ‹

# wrkæµ‹è¯•
wrk -t12 -c400 -d30s --latency http://localhost:3000/

# ohaæµ‹è¯•ï¼ˆRustå®ç°çš„HTTPè´Ÿè½½å·¥å…·ï¼‰
oha -z 30s -c 400 --latency-correction http://localhost:3000/

# abæµ‹è¯•
ab -n 100000 -c 100 -k http://localhost:3000/
```

### axumæ€§èƒ½ä¼˜åŒ–

```rust
use axum::{
    Router,
    routing::get,
    extract::State,
    response::{IntoResponse, Response},
    http::StatusCode,
};
use std::sync::Arc;

/// é«˜æ€§èƒ½axumæœåŠ¡å™¨é…ç½®
#[tokio::main]
async fn main() {
    let state = Arc::new(AppState::new());

    let app = Router::new()
        .route("/", get(handler))
        .with_state(state)
        .layer(
            tower::ServiceBuilder::new()
                .layer(tower_http::compression::CompressionLayer::new())
                .layer(tower_http::trace::TraceLayer::new_for_http())
        );

    // ä¼˜åŒ–TCPå‚æ•°
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();

    // è®¾ç½®SO_REUSEADDRå’ŒSO_REUSEPORT
    use socket2::{Socket, Domain, Type};
    let socket = Socket::new(Domain::IPV4, Type::STREAM, None).unwrap();
    socket.set_reuse_address(true).unwrap();
    socket.set_reuse_port(true).unwrap();

    axum::serve(listener, app).await.unwrap();
}

struct AppState;

impl AppState {
    fn new() -> Self {
        Self
    }
}

async fn handler() -> &'static str {
    "Hello, World!"
}
```

---

## 3. å¼‚æ­¥è¿è¡Œæ—¶æ€§èƒ½

### Tokio vs async-std vs smol

```rust
use std::time::{Duration, Instant};

/// Tokioæ€§èƒ½æµ‹è¯•
#[tokio::test]
async fn tokio_spawn_benchmark() {
    let start = Instant::now();
    let mut handles = Vec::new();

    for i in 0..10000 {
        handles.push(tokio::spawn(async move {
            tokio::time::sleep(Duration::from_micros(100)).await;
            i
        }));
    }

    for handle in handles {
        let _ = handle.await;
    }

    println!("Tokio: {:?}", start.elapsed());
}

/// async-stdæ€§èƒ½æµ‹è¯•
#[async_std::test]
async fn async_std_spawn_benchmark() {
    let start = Instant::now();
    let mut handles = Vec::new();

    for i in 0..10000 {
        handles.push(async_std::task::spawn(async move {
            async_std::task::sleep(Duration::from_micros(100)).await;
            i
        }));
    }

    for handle in handles {
        let _ = handle.await;
    }

    println!("async-std: {:?}", start.elapsed());
}
```

**åŸºå‡†ç»“æœ**ï¼š

- **Tokio**: 150ms (10,000 tasks)
- **async-std**: 170ms
- **smol**: 155ms

---

## 4. WebSocketæ€§èƒ½

### è¿æ¥æ•°ä¸ååé‡

| æŒ‡æ ‡             | tokio-tungstenite | ws-rs      |
| ---------------- | ----------------- | ---------- |
| **æœ€å¤§å¹¶å‘è¿æ¥** | 100,000+          | 50,000+    |
| **æ¶ˆæ¯ååé‡**   | 1.5M msg/s        | 800k msg/s |
| **å»¶è¿ŸP50**      | 0.5ms             | 0.8ms      |
| **å»¶è¿ŸP99**      | 2.1ms             | 3.5ms      |
| **å†…å­˜/è¿æ¥**    | ~8KB              | ~12KB      |

### WebSocketå‹æµ‹

```rust
use tokio_tungstenite::connect_async;
use futures_util::{StreamExt, SinkExt};
use std::time::Instant;

/// WebSocketååé‡æµ‹è¯•
pub async fn websocket_throughput_test(
    url: &str,
    num_messages: usize,
) -> Result<Duration, Box<dyn std::error::Error>> {
    let (mut ws_stream, _) = connect_async(url).await?;

    let start = Instant::now();

    for i in 0..num_messages {
        ws_stream.send(tokio_tungstenite::tungstenite::Message::Text(
            format!("Message {}", i)
        )).await?;

        if let Some(msg) = ws_stream.next().await {
            let _ = msg?;
        }
    }

    let elapsed = start.elapsed();

    println!(
        "ååé‡: {:.2} msg/s",
        num_messages as f64 / elapsed.as_secs_f64()
    );

    Ok(elapsed)
}
```

---

## 5. gRPCæ€§èƒ½åŸºå‡†

### tonicæ€§èƒ½

| è´Ÿè½½              | ååé‡ (req/s) | P50å»¶è¿Ÿ | P99å»¶è¿Ÿ | è´Ÿè½½å¤§å° |
| ----------------- | -------------- | ------- | ------- | -------- |
| **Unary**         | 120,000        | 1.2ms   | 4.5ms   | 100B     |
| **Server Stream** | 95,000         | 1.5ms   | 5.2ms   | 100B     |
| **Client Stream** | 90,000         | 1.6ms   | 5.8ms   | 100B     |
| **Bidirectional** | 85,000         | 1.8ms   | 6.1ms   | 100B     |

### gRPCå‹æµ‹å·¥å…·

```bash
# ghz - gRPCå‹æµ‹å·¥å…·
ghz --insecure \
  --proto ./proto/service.proto \
  --call myservice.Greeter/SayHello \
  -d '{"name":"test"}' \
  -c 50 \
  -n 10000 \
  localhost:50051
```

---

## 6. DNSè§£ææ€§èƒ½

### hickory-dns vs c-ares

```rust
use hickory_resolver::TokioAsyncResolver;
use std::time::Instant;

/// DNSè§£ææ€§èƒ½æµ‹è¯•
pub async fn dns_resolution_benchmark(domains: &[&str]) -> Duration {
    let resolver = TokioAsyncResolver::tokio_from_system_conf().unwrap();

    let start = Instant::now();

    for &domain in domains {
        let _ = resolver.lookup_ip(domain).await;
    }

    let elapsed = start.elapsed();

    println!(
        "DNSè§£æ: {} åŸŸå in {:?} ({:.2} queries/s)",
        domains.len(),
        elapsed,
        domains.len() as f64 / elapsed.as_secs_f64()
    );

    elapsed
}
```

**åŸºå‡†ç»“æœ**ï¼ˆ1000æ¬¡æŸ¥è¯¢ï¼‰ï¼š

- **hickory-dns**: 450ms
- **c-ares**: 420ms
- **system resolver**: 1200ms

---

## 7. TLSæ¡æ‰‹æ€§èƒ½

### rustls vs native-tls vs openssl

| åº“             | æ¡æ‰‹æ—¶é—´ (ms) | CPU (%) | å†…å­˜ (KB) |
| -------------- | ------------- | ------- | --------- |
| **rustls**     | 2.1           | 15%     | 120       |
| **native-tls** | 2.4           | 18%     | 150       |
| **openssl**    | 2.3           | 17%     | 140       |

```rust
use tokio_rustls::{TlsConnector, rustls};
use std::time::Instant;

/// TLSæ¡æ‰‹æ€§èƒ½æµ‹è¯•
pub async fn tls_handshake_benchmark(iterations: usize) -> Duration {
    let mut root_store = rustls::RootCertStore::empty();
    root_store.add_trust_anchors(
        webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
            rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
                ta.subject,
                ta.spki,
                ta.name_constraints,
            )
        })
    );

    let config = rustls::ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    let connector = TlsConnector::from(std::sync::Arc::new(config));

    let start = Instant::now();

    for _ in 0..iterations {
        let stream = tokio::net::TcpStream::connect("example.com:443").await.unwrap();
        let domain = rustls::ServerName::try_from("example.com").unwrap();
        let _ = connector.connect(domain, stream).await;
    }

    start.elapsed()
}
```

---

## 8. åºåˆ—åŒ–æ€§èƒ½

### æ ¼å¼å¯¹æ¯”ï¼ˆ10,000æ¬¡åºåˆ—åŒ–ï¼‰

| æ ¼å¼            | åºåˆ—åŒ– (ms) | ååºåˆ—åŒ– (ms) | å¤§å° (bytes) |
| --------------- | ----------- | ------------- | ------------ |
| **JSON**        | 180         | 220           | 87           |
| **MessagePack** | 90          | 110           | 58           |
| **Bincode**     | 45          | 55            | 53           |
| **Protobuf**    | 60          | 75            | 45           |
| **CBOR**        | 100         | 120           | 62           |

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
struct Person {
    id: u64,
    name: String,
    email: String,
    age: u32,
}

pub fn serialization_benchmark(c: &mut Criterion) {
    let person = Person {
        id: 12345,
        name: "Alice".into(),
        email: "alice@example.com".into(),
        age: 30,
    };

    c.bench_function("json_serialize", |b| {
        b.iter(|| black_box(serde_json::to_vec(&person).unwrap()));
    });

    c.bench_function("msgpack_serialize", |b| {
        b.iter(|| black_box(rmp_serde::to_vec(&person).unwrap()));
    });

    c.bench_function("bincode_serialize", |b| {
        b.iter(|| black_box(bincode::serialize(&person).unwrap()));
    });
}

criterion_group!(benches, serialization_benchmark);
criterion_main!(benches);
```

---

## 9. ç½‘ç»œI/Oæ¨¡å¼å¯¹æ¯”

### é˜»å¡ vs éé˜»å¡ vs io_uring

| æ¨¡å¼              | ååé‡ (req/s) | å»¶è¿ŸP50 | CPU (%) | é€‚ç”¨åœºæ™¯ |
| ----------------- | -------------- | ------- | ------- | -------- |
| **é˜»å¡I/O**       | 50,000         | 5ms     | 60%     | ç®€å•åº”ç”¨ |
| **éé˜»å¡(epoll)** | 500,000        | 0.8ms   | 80%     | é«˜å¹¶å‘   |
| **io_uring**      | 800,000        | 0.5ms   | 70%     | æè‡´æ€§èƒ½ |

### io_uringç¤ºä¾‹

```rust
// éœ€è¦tokio-uring
use tokio_uring::net::TcpListener;

/// io_uringé«˜æ€§èƒ½æœåŠ¡å™¨
#[tokio_uring::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080".parse().unwrap())?;

    loop {
        let (stream, _) = listener.accept().await?;

        tokio_uring::spawn(async move {
            let mut buf = vec![0u8; 4096];

            loop {
                let (res, buf_) = stream.read(buf).await;
                buf = buf_;

                let n = match res {
                    Ok(n) if n == 0 => break,
                    Ok(n) => n,
                    Err(_) => break,
                };

                let (res, buf_) = stream.write_all(buf[..n].to_vec()).await;
                buf = buf_;

                if res.is_err() {
                    break;
                }
            }
        });
    }
}
```

---

## 10. å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹

### æ¡ˆä¾‹1: HTTPæœåŠ¡å™¨ä¼˜åŒ–

**Before**:

```rust
// æ€§èƒ½: 50,000 req/s
async fn handler() -> String {
    format!("Hello, {}!", "World")
}
```

**After**:

```rust
// æ€§èƒ½: 520,000 req/s
async fn handler() -> &'static str {
    "Hello, World!" // é¿å…åˆ†é…
}
```

### æ¡ˆä¾‹2: WebSocketæ‰¹é‡å‘é€

**Before**:

```rust
// é€æ¡å‘é€
for msg in messages {
    ws.send(msg).await?;
}
```

**After**:

```rust
// æ‰¹é‡å‘é€
use futures_util::stream::{StreamExt, iter};
let stream = iter(messages).map(Ok);
ws.send_all(&mut stream.boxed()).await?;
```

### æ¡ˆä¾‹3: DNSç¼“å­˜

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct DnsCache {
    cache: Arc<RwLock<HashMap<String, std::net::IpAddr>>>,
    resolver: hickory_resolver::TokioAsyncResolver,
}

impl DnsCache {
    pub async fn lookup(&self, domain: &str) -> Result<std::net::IpAddr, Box<dyn std::error::Error>> {
        // æ£€æŸ¥ç¼“å­˜
        {
            let cache = self.cache.read().await;
            if let Some(&ip) = cache.get(domain) {
                return Ok(ip);
            }
        }

        // è§£æå¹¶ç¼“å­˜
        let lookup = self.resolver.lookup_ip(domain).await?;
        let ip = lookup.iter().next().ok_or("No IP found")?;

        {
            let mut cache = self.cache.write().await;
            cache.insert(domain.to_string(), ip);
        }

        Ok(ip)
    }
}
```

**æ€§èƒ½æå‡**: ä» 450ms/1000æ¬¡æŸ¥è¯¢ â†’ 5ms/1000æ¬¡æŸ¥è¯¢ï¼ˆç¼“å­˜å‘½ä¸­ï¼‰

---

**æ–‡æ¡£å®Œæˆ**: æœ¬å‚è€ƒæä¾›äº†å…¨é¢çš„ç½‘ç»œæ€§èƒ½åŸºå‡†æ•°æ®å’Œä¼˜åŒ–ç­–ç•¥ã€‚

**ä¸‹ä¸€æ­¥**: [05\_ç½‘ç»œå®‰å…¨å‚è€ƒ.md](./05_ç½‘ç»œå®‰å…¨å‚è€ƒ.md)
