# ç½‘ç»œåè®®åˆ†ç±»å‚è€ƒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æ›´æ–°æ—¥æœŸ**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **æ–‡æ¡£å±‚çº§**: Tier 3 - æŠ€æœ¯å‚è€ƒ

---

## ç›®å½•

- [ç½‘ç»œåè®®åˆ†ç±»å‚è€ƒ](#ç½‘ç»œåè®®åˆ†ç±»å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [1. OSIä¸ƒå±‚æ¨¡å‹ä¸åè®®æ˜ å°„](#1-osiä¸ƒå±‚æ¨¡å‹ä¸åè®®æ˜ å°„)
    - [1.1 ç‰©ç†å±‚ï¼ˆPhysical Layerï¼‰](#11-ç‰©ç†å±‚physical-layer)
    - [1.2 æ•°æ®é“¾è·¯å±‚ï¼ˆData Link Layerï¼‰](#12-æ•°æ®é“¾è·¯å±‚data-link-layer)
    - [1.3 ç½‘ç»œå±‚ï¼ˆNetwork Layerï¼‰](#13-ç½‘ç»œå±‚network-layer)
    - [1.4 ä¼ è¾“å±‚ï¼ˆTransport Layerï¼‰](#14-ä¼ è¾“å±‚transport-layer)
    - [1.5 ä¼šè¯å±‚ï¼ˆSession Layerï¼‰](#15-ä¼šè¯å±‚session-layer)
    - [1.6 è¡¨ç¤ºå±‚ï¼ˆPresentation Layerï¼‰](#16-è¡¨ç¤ºå±‚presentation-layer)
    - [1.7 åº”ç”¨å±‚ï¼ˆApplication Layerï¼‰](#17-åº”ç”¨å±‚application-layer)
  - [2. TCP/IPåè®®æ—](#2-tcpipåè®®æ—)
    - [2.1 æ ¸å¿ƒåè®®](#21-æ ¸å¿ƒåè®®)
    - [2.2 Rustå®ç°ï¼šTCPæœåŠ¡å™¨](#22-rustå®ç°tcpæœåŠ¡å™¨)
    - [2.3 UDPå®Œæ•´å®ç°](#23-udpå®Œæ•´å®ç°)
  - [3. HTTPåè®®å®¶æ—](#3-httpåè®®å®¶æ—)
    - [3.1 HTTP/1.1](#31-http11)
    - [3.2 HTTP/2](#32-http2)
    - [3.3 HTTP/3 (QUIC)](#33-http3-quic)
    - [3.4 æ€§èƒ½å¯¹æ¯”](#34-æ€§èƒ½å¯¹æ¯”)
  - [4. WebSocketåè®®](#4-websocketåè®®)
    - [4.1 åè®®ç‰¹æ€§](#41-åè®®ç‰¹æ€§)
    - [4.2 Rustå®ç°ï¼šWebSocketæœåŠ¡å™¨](#42-rustå®ç°websocketæœåŠ¡å™¨)
  - [5. DNSåè®®](#5-dnsåè®®)
    - [5.1 è®°å½•ç±»å‹](#51-è®°å½•ç±»å‹)
    - [5.2 DNSè§£æå®ç°](#52-dnsè§£æå®ç°)
  - [6. åº”ç”¨å±‚åè®®](#6-åº”ç”¨å±‚åè®®)
    - [6.1 gRPC (HTTP/2 + Protobuf)](#61-grpc-http2--protobuf)
    - [6.2 MQTT (IoTæ¶ˆæ¯åè®®)](#62-mqtt-iotæ¶ˆæ¯åè®®)
    - [6.3 GraphQL over HTTP](#63-graphql-over-http)
  - [7. å®‰å…¨åè®®](#7-å®‰å…¨åè®®)
    - [7.1 TLS/SSL](#71-tlsssl)
    - [7.2 DTLS (Datagram TLS)](#72-dtls-datagram-tls)
  - [8. P2Påè®®](#8-p2påè®®)
    - [8.1 libp2påè®®æ ˆ](#81-libp2påè®®æ ˆ)
  - [9. å®æ—¶é€šä¿¡åè®®](#9-å®æ—¶é€šä¿¡åè®®)
    - [9.1 WebRTC](#91-webrtc)
    - [9.2 RTP/RTCP](#92-rtprtcp)
  - [10. åè®®é€‰æ‹©å†³ç­–æ ‘](#10-åè®®é€‰æ‹©å†³ç­–æ ‘)
  - [11. Rustç”Ÿæ€åè®®åº“å¯¹æ¯”](#11-rustç”Ÿæ€åè®®åº“å¯¹æ¯”)
  - [12. åè®®æµ‹è¯•ä¸éªŒè¯](#12-åè®®æµ‹è¯•ä¸éªŒè¯)
  - [13. æœ€ä½³å®è·µ](#13-æœ€ä½³å®è·µ)
    - [âœ… åè®®é€‰æ‹©åŸåˆ™](#-åè®®é€‰æ‹©åŸåˆ™)
    - [âš ï¸ å¸¸è§é™·é˜±](#ï¸-å¸¸è§é™·é˜±)
    - [ğŸ”§ æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)

---

## 1. OSIä¸ƒå±‚æ¨¡å‹ä¸åè®®æ˜ å°„

### 1.1 ç‰©ç†å±‚ï¼ˆPhysical Layerï¼‰

**Rustå®ç°ä¸ç›´æ¥æ¶‰åŠï¼Œä½†å¯é€šè¿‡ç¡¬ä»¶æŠ½è±¡å±‚ï¼ˆHALï¼‰è®¿é—®**ï¼š

```rust
// åµŒå…¥å¼ç¡¬ä»¶æŠ½è±¡ç¤ºä¾‹ï¼ˆembedded-halï¼‰
use embedded_hal::serial::{Read, Write};

pub struct PhysicalLayer<S> {
    serial: S,
}

impl<S: Read<u8> + Write<u8>> PhysicalLayer<S> {
    pub fn new(serial: S) -> Self {
        Self { serial }
    }
    
    /// å‘é€åŸå§‹æ¯”ç‰¹æµ
    pub fn send_bits(&mut self, data: &[u8]) -> Result<(), S::Error> {
        for &byte in data {
            nb::block!(self.serial.write(byte))?;
        }
        Ok(())
    }
}
```

### 1.2 æ•°æ®é“¾è·¯å±‚ï¼ˆData Link Layerï¼‰

**åè®®**: Ethernet, PPP, ARP, VLAN (802.1Q)

```rust
use pnet::packet::ethernet::{EtherTypes, EthernetPacket};
use pnet::packet::Packet;

/// è§£æä»¥å¤ªç½‘å¸§
pub fn parse_ethernet_frame(data: &[u8]) -> Option<String> {
    if let Some(eth_packet) = EthernetPacket::new(data) {
        Some(format!(
            "Ethernet: {} -> {} | Type: {:?}",
            eth_packet.get_source(),
            eth_packet.get_destination(),
            eth_packet.get_ethertype()
        ))
    } else {
        None
    }
}

/// ARPè¯·æ±‚æ„é€ 
use pnet::packet::arp::{ArpHardwareTypes, ArpOperations, ArpPacket, MutableArpPacket};

pub fn build_arp_request(
    src_mac: [u8; 6],
    src_ip: [u8; 4],
    dst_ip: [u8; 4],
) -> Vec<u8> {
    let mut buffer = vec![0u8; 28];
    let mut arp = MutableArpPacket::new(&mut buffer).unwrap();
    
    arp.set_hardware_type(ArpHardwareTypes::Ethernet);
    arp.set_protocol_type(EtherTypes::Ipv4);
    arp.set_hw_addr_len(6);
    arp.set_proto_addr_len(4);
    arp.set_operation(ArpOperations::Request);
    arp.set_sender_hw_addr(pnet::util::MacAddr::from(src_mac));
    arp.set_sender_proto_addr(std::net::Ipv4Addr::from(src_ip));
    arp.set_target_hw_addr(pnet::util::MacAddr::zero());
    arp.set_target_proto_addr(std::net::Ipv4Addr::from(dst_ip));
    
    buffer
}
```

### 1.3 ç½‘ç»œå±‚ï¼ˆNetwork Layerï¼‰

**åè®®**: IPv4, IPv6, ICMP, ICMPv6

```rust
use pnet::packet::ipv4::{Ipv4Packet, MutableIpv4Packet};
use pnet::packet::ip::IpNextHeaderProtocols;

/// IPv4æ•°æ®åŒ…è§£æ
pub fn parse_ipv4_packet(data: &[u8]) -> Option<String> {
    if let Some(ip_packet) = Ipv4Packet::new(data) {
        Some(format!(
            "IPv4: {} -> {} | Proto: {:?} | TTL: {}",
            ip_packet.get_source(),
            ip_packet.get_destination(),
            ip_packet.get_next_level_protocol(),
            ip_packet.get_ttl()
        ))
    } else {
        None
    }
}

/// ICMP Pingå®ç°
use pnet::packet::icmp::{echo_request, IcmpTypes, MutableIcmpPacket};

pub fn build_icmp_echo_request(seq: u16, data: &[u8]) -> Vec<u8> {
    let mut buffer = vec![0u8; 8 + data.len()];
    let mut icmp = MutableIcmpPacket::new(&mut buffer).unwrap();
    
    icmp.set_icmp_type(IcmpTypes::EchoRequest);
    icmp.set_icmp_code(echo_request::IcmpCodes::NoCode);
    
    let echo_req = echo_request::MutableEchoRequestPacket::new(&mut buffer).unwrap();
    echo_req.set_identifier(std::process::id() as u16);
    echo_req.set_sequence_number(seq);
    
    let payload = echo_req.packet_mut();
    payload[8..].copy_from_slice(data);
    
    // è®¡ç®—æ ¡éªŒå’Œ
    let checksum = pnet::packet::icmp::checksum(&icmp.to_immutable());
    icmp.set_checksum(checksum);
    
    buffer
}
```

### 1.4 ä¼ è¾“å±‚ï¼ˆTransport Layerï¼‰

**åè®®**: TCP, UDP, SCTP, DCCP, QUIC

```rust
use tokio::net::TcpStream;
use std::net::SocketAddr;

/// TCPè¿æ¥ç®¡ç†
pub struct TcpConnectionManager {
    addr: SocketAddr,
}

impl TcpConnectionManager {
    pub fn new(addr: SocketAddr) -> Self {
        Self { addr }
    }
    
    /// å»ºç«‹TCPè¿æ¥ï¼ˆä¸‰æ¬¡æ¡æ‰‹ï¼‰
    pub async fn connect(&self) -> std::io::Result<TcpStream> {
        let stream = TcpStream::connect(self.addr).await?;
        
        // é…ç½®TCPé€‰é¡¹
        stream.set_nodelay(true)?; // ç¦ç”¨Nagleç®—æ³•
        stream.set_ttl(64)?;       // è®¾ç½®TTL
        
        Ok(stream)
    }
    
    /// TCPä¿æ´»é…ç½®
    pub async fn configure_keepalive(&self, stream: &TcpStream) -> std::io::Result<()> {
        use socket2::{Socket, TcpKeepalive};
        use std::time::Duration;
        
        let socket = Socket::from(stream.as_raw_fd());
        let keepalive = TcpKeepalive::new()
            .with_time(Duration::from_secs(60))
            .with_interval(Duration::from_secs(10));
        
        socket.set_tcp_keepalive(&keepalive)?;
        Ok(())
    }
}

/// UDPå¥—æ¥å­—ç®¡ç†
use tokio::net::UdpSocket;

pub struct UdpSocketManager {
    socket: UdpSocket,
}

impl UdpSocketManager {
    pub async fn new(addr: &str) -> std::io::Result<Self> {
        let socket = UdpSocket::bind(addr).await?;
        
        // è®¾ç½®å¹¿æ’­
        socket.set_broadcast(true)?;
        
        // è®¾ç½®æ¥æ”¶ç¼“å†²åŒº
        socket.set_recv_buffer_size(1024 * 1024)?;
        
        Ok(Self { socket })
    }
    
    /// UDPå¤šæ’­
    pub async fn join_multicast(&self, multicast_addr: &str) -> std::io::Result<()> {
        let multicast: std::net::Ipv4Addr = multicast_addr.parse().unwrap();
        let interface = std::net::Ipv4Addr::UNSPECIFIED;
        
        self.socket.join_multicast_v4(multicast, interface)?;
        Ok(())
    }
}
```

### 1.5 ä¼šè¯å±‚ï¼ˆSession Layerï¼‰

**Rustä¸­é€šå¸¸ç”±åº”ç”¨å±‚åè®®å®ç°**ï¼š

```rust
/// ä¼šè¯ç®¡ç†å™¨
use std::collections::HashMap;
use uuid::Uuid;

pub struct SessionManager {
    sessions: HashMap<Uuid, SessionData>,
}

#[derive(Debug, Clone)]
pub struct SessionData {
    user_id: String,
    created_at: std::time::Instant,
    expires_at: std::time::Instant,
    data: HashMap<String, String>,
}

impl SessionManager {
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
        }
    }
    
    /// åˆ›å»ºä¼šè¯
    pub fn create_session(&mut self, user_id: String, ttl_secs: u64) -> Uuid {
        let session_id = Uuid::new_v4();
        let now = std::time::Instant::now();
        
        let session = SessionData {
            user_id,
            created_at: now,
            expires_at: now + std::time::Duration::from_secs(ttl_secs),
            data: HashMap::new(),
        };
        
        self.sessions.insert(session_id, session);
        session_id
    }
    
    /// éªŒè¯ä¼šè¯
    pub fn validate_session(&self, session_id: &Uuid) -> Option<&SessionData> {
        self.sessions.get(session_id).and_then(|session| {
            if session.expires_at > std::time::Instant::now() {
                Some(session)
            } else {
                None
            }
        })
    }
    
    /// ç»­æœŸä¼šè¯
    pub fn renew_session(&mut self, session_id: &Uuid, ttl_secs: u64) -> bool {
        if let Some(session) = self.sessions.get_mut(session_id) {
            let now = std::time::Instant::now();
            if session.expires_at > now {
                session.expires_at = now + std::time::Duration::from_secs(ttl_secs);
                return true;
            }
        }
        false
    }
}
```

### 1.6 è¡¨ç¤ºå±‚ï¼ˆPresentation Layerï¼‰

**æ•°æ®ç¼–ç /è§£ç **ï¼šJSON, Protobuf, MessagePack, CBOR

```rust
use serde::{Deserialize, Serialize};

/// JSONç¼–è§£ç 
#[derive(Debug, Serialize, Deserialize)]
pub struct Message {
    id: u64,
    content: String,
}

pub fn encode_json(msg: &Message) -> Result<Vec<u8>, serde_json::Error> {
    serde_json::to_vec(msg)
}

pub fn decode_json(data: &[u8]) -> Result<Message, serde_json::Error> {
    serde_json::from_slice(data)
}

/// Protobufç¼–è§£ç 
use prost::Message as ProstMessage;

#[derive(Clone, PartialEq, ProstMessage)]
pub struct ProtoMessage {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(string, tag = "2")]
    pub content: String,
}

pub fn encode_protobuf(msg: &ProtoMessage) -> Vec<u8> {
    msg.encode_to_vec()
}

pub fn decode_protobuf(data: &[u8]) -> Result<ProtoMessage, prost::DecodeError> {
    ProtoMessage::decode(data)
}

/// MessagePackç¼–è§£ç 
use rmp_serde::{encode, decode};

pub fn encode_msgpack(msg: &Message) -> Result<Vec<u8>, encode::Error> {
    rmp_serde::to_vec(msg)
}

pub fn decode_msgpack(data: &[u8]) -> Result<Message, decode::Error> {
    rmp_serde::from_slice(data)
}

/// æ€§èƒ½å¯¹æ¯”
pub fn benchmark_serialization(msg: &Message) {
    use std::time::Instant;
    
    // JSON
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = encode_json(msg);
    }
    println!("JSON: {:?}", start.elapsed());
    
    // Protobuf
    let proto_msg = ProtoMessage {
        id: msg.id,
        content: msg.content.clone(),
    };
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = encode_protobuf(&proto_msg);
    }
    println!("Protobuf: {:?}", start.elapsed());
    
    // MessagePack
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = encode_msgpack(msg);
    }
    println!("MessagePack: {:?}", start.elapsed());
}
```

### 1.7 åº”ç”¨å±‚ï¼ˆApplication Layerï¼‰

**åè®®**: HTTP, FTP, SMTP, POP3, IMAP, SSH, Telnet, DNS, DHCP

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

/// ç®€å•HTTPå®¢æˆ·ç«¯
pub struct SimpleHttpClient;

impl SimpleHttpClient {
    pub async fn get(url: &str) -> std::io::Result<String> {
        let mut stream = TcpStream::connect("example.com:80").await?;
        
        let request = format!(
            "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n"
        );
        
        stream.write_all(request.as_bytes()).await?;
        
        let mut response = String::new();
        stream.read_to_string(&mut response).await?;
        
        Ok(response)
    }
}
```

---

## 2. TCP/IPåè®®æ—

### 2.1 æ ¸å¿ƒåè®®

| åè®® | å±‚çº§ | åŠŸèƒ½ | Ruståº“ |
|------|------|------|--------|
| IP | ç½‘ç»œå±‚ | æ•°æ®åŒ…è·¯ç”± | `pnet`, `smoltcp` |
| ICMP | ç½‘ç»œå±‚ | é”™è¯¯æŠ¥å‘Šã€è¯Šæ–­ | `pnet`, `surge` |
| TCP | ä¼ è¾“å±‚ | å¯é å­—èŠ‚æµä¼ è¾“ | `std::net`, `tokio::net` |
| UDP | ä¼ è¾“å±‚ | æ— è¿æ¥æ•°æ®æŠ¥ä¼ è¾“ | `std::net`, `tokio::net` |
| ARP | æ•°æ®é“¾è·¯å±‚ | IPåˆ°MACåœ°å€æ˜ å°„ | `pnet` |

### 2.2 Rustå®ç°ï¼šTCPæœåŠ¡å™¨

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::sync::Arc;
use tokio::sync::Semaphore;

/// é«˜æ€§èƒ½TCPæœåŠ¡å™¨
pub struct TcpServer {
    listener: TcpListener,
    max_connections: Arc<Semaphore>,
}

impl TcpServer {
    pub async fn bind(addr: &str, max_conn: usize) -> std::io::Result<Self> {
        let listener = TcpListener::bind(addr).await?;
        let max_connections = Arc::new(Semaphore::new(max_conn));
        
        Ok(Self {
            listener,
            max_connections,
        })
    }
    
    pub async fn serve(&self) -> std::io::Result<()> {
        loop {
            // è·å–è¿æ¥è®¸å¯
            let permit = self.max_connections.clone().acquire_owned().await.unwrap();
            
            let (stream, addr) = self.listener.accept().await?;
            println!("æ–°è¿æ¥: {}", addr);
            
            tokio::spawn(async move {
                if let Err(e) = Self::handle_client(stream).await {
                    eprintln!("å¤„ç†å®¢æˆ·ç«¯é”™è¯¯: {}", e);
                }
                drop(permit);
            });
        }
    }
    
    async fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {
        let mut buffer = vec![0u8; 4096];
        
        loop {
            let n = stream.read(&mut buffer).await?;
            if n == 0 {
                break; // è¿æ¥å…³é—­
            }
            
            // å›æ˜¾æ•°æ®
            stream.write_all(&buffer[..n]).await?;
        }
        
        Ok(())
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn tcp_server_example() -> std::io::Result<()> {
    let server = TcpServer::bind("127.0.0.1:8080", 100).await?;
    server.serve().await
}
```

### 2.3 UDPå®Œæ•´å®ç°

```rust
use tokio::net::UdpSocket;
use std::sync::Arc;

/// UDPæœåŠ¡å™¨
pub struct UdpServer {
    socket: Arc<UdpSocket>,
}

impl UdpServer {
    pub async fn bind(addr: &str) -> std::io::Result<Self> {
        let socket = UdpSocket::bind(addr).await?;
        Ok(Self {
            socket: Arc::new(socket),
        })
    }
    
    pub async fn serve(&self) -> std::io::Result<()> {
        let mut buffer = vec![0u8; 65535];
        
        loop {
            let (len, peer) = self.socket.recv_from(&mut buffer).await?;
            println!("æ”¶åˆ°æ¥è‡ª {} çš„ {} å­—èŠ‚", peer, len);
            
            let socket = self.socket.clone();
            let data = buffer[..len].to_vec();
            
            tokio::spawn(async move {
                // å¤„ç†å¹¶å›å¤
                if let Err(e) = socket.send_to(&data, peer).await {
                    eprintln!("å‘é€å¤±è´¥: {}", e);
                }
            });
        }
    }
}

/// UDPå®¢æˆ·ç«¯
pub struct UdpClient {
    socket: UdpSocket,
}

impl UdpClient {
    pub async fn new() -> std::io::Result<Self> {
        let socket = UdpSocket::bind("0.0.0.0:0").await?;
        Ok(Self { socket })
    }
    
    pub async fn send_recv(&self, server: &str, data: &[u8]) -> std::io::Result<Vec<u8>> {
        self.socket.send_to(data, server).await?;
        
        let mut buffer = vec![0u8; 65535];
        let (len, _) = self.socket.recv_from(&mut buffer).await?;
        
        Ok(buffer[..len].to_vec())
    }
}
```

---

## 3. HTTPåè®®å®¶æ—

### 3.1 HTTP/1.1

**ç‰¹æ€§**: æŒä¹…è¿æ¥, ç®¡é“åŒ–, åˆ†å—ä¼ è¾“, ç¼“å­˜æ§åˆ¶

```rust
use hyper::{Body, Request, Response, Server, StatusCode};
use hyper::service::{make_service_fn, service_fn};
use std::convert::Infallible;

/// HTTP/1.1æœåŠ¡å™¨
pub async fn http1_server() -> Result<(), Box<dyn std::error::Error>> {
    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, Infallible>(service_fn(handle_request))
    });
    
    let addr = ([127, 0, 0, 1], 3000).into();
    let server = Server::bind(&addr).serve(make_svc);
    
    println!("HTTP/1.1æœåŠ¡å™¨è¿è¡Œåœ¨ http://{}", addr);
    server.await?;
    
    Ok(())
}

async fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {
    let response = match (req.method(), req.uri().path()) {
        (&hyper::Method::GET, "/") => {
            Response::new(Body::from("Hello, HTTP/1.1!"))
        }
        (&hyper::Method::POST, "/echo") => {
            let body_bytes = hyper::body::to_bytes(req.into_body()).await.unwrap();
            Response::new(Body::from(body_bytes))
        }
        _ => {
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::from("404 Not Found"))
                .unwrap()
        }
    };
    
    Ok(response)
}
```

### 3.2 HTTP/2

**ç‰¹æ€§**: å¤šè·¯å¤ç”¨, æœåŠ¡å™¨æ¨é€, å¤´éƒ¨å‹ç¼©(HPACK), äºŒè¿›åˆ¶åè®®

```rust
use hyper::{Body, Request, Response, Server};
use hyper::server::conn::Http;
use hyper::service::service_fn;
use tokio::net::TcpListener;

/// HTTP/2æœåŠ¡å™¨
pub async fn http2_server() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:3001";
    let listener = TcpListener::bind(addr).await?;
    
    println!("HTTP/2æœåŠ¡å™¨è¿è¡Œåœ¨ http://{}", addr);
    
    loop {
        let (stream, _) = listener.accept().await?;
        
        tokio::spawn(async move {
            let service = service_fn(|_req: Request<Body>| async {
                Ok::<_, hyper::Error>(Response::new(Body::from("Hello, HTTP/2!")))
            });
            
            if let Err(e) = Http::new()
                .http2_only(true)
                .serve_connection(stream, service)
                .await
            {
                eprintln!("HTTP/2è¿æ¥é”™è¯¯: {}", e);
            }
        });
    }
}

/// HTTP/2å®¢æˆ·ç«¯
use hyper::Client;
use hyper::client::HttpConnector;

pub async fn http2_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let client: Client<HttpConnector, Body> = Client::builder()
        .http2_only(true)
        .build_http();
    
    let uri = "http://127.0.0.1:3001/".parse()?;
    let resp = client.get(uri).await?;
    
    println!("HTTPç‰ˆæœ¬: {:?}", resp.version());
    println!("çŠ¶æ€ç : {}", resp.status());
    
    let body_bytes = hyper::body::to_bytes(resp.into_body()).await?;
    println!("å“åº”ä½“: {}", String::from_utf8_lossy(&body_bytes));
    
    Ok(())
}
```

### 3.3 HTTP/3 (QUIC)

**ç‰¹æ€§**: åŸºäºUDP, 0-RTT, è¿æ¥è¿ç§», æ”¹è¿›çš„å¤šè·¯å¤ç”¨

```rust
use quinn::{Endpoint, ServerConfig, ClientConfig, TransportConfig};
use std::sync::Arc;
use rustls::{Certificate, PrivateKey};

/// HTTP/3 (QUIC) æœåŠ¡å™¨
pub async fn http3_server() -> Result<(), Box<dyn std::error::Error>> {
    // é…ç½®TLS
    let cert = rcgen::generate_simple_self_signed(vec!["localhost".into()])?;
    let cert_der = cert.serialize_der()?;
    let priv_key = cert.serialize_private_key_der();
    
    let cert_chain = vec![Certificate(cert_der)];
    let key = PrivateKey(priv_key);
    
    let mut server_config = quinn::ServerConfig::with_single_cert(cert_chain, key)?;
    
    // é…ç½®ä¼ è¾“å‚æ•°
    let mut transport = TransportConfig::default();
    transport.max_concurrent_bidi_streams(100u32.into());
    transport.max_concurrent_uni_streams(100u32.into());
    server_config.transport = Arc::new(transport);
    
    let endpoint = Endpoint::server(server_config, "127.0.0.1:4433".parse()?)?;
    
    println!("HTTP/3æœåŠ¡å™¨è¿è¡Œåœ¨ 127.0.0.1:4433");
    
    while let Some(conn) = endpoint.accept().await {
        tokio::spawn(async move {
            match conn.await {
                Ok(new_conn) => {
                    println!("æ–°QUICè¿æ¥");
                    handle_quic_connection(new_conn).await;
                }
                Err(e) => eprintln!("è¿æ¥é”™è¯¯: {}", e),
            }
        });
    }
    
    Ok(())
}

async fn handle_quic_connection(conn: quinn::NewConnection) {
    loop {
        match conn.connection.accept_bi().await {
            Ok((mut send, mut recv)) => {
                let mut data = Vec::new();
                if recv.read_to_end(usize::MAX).await.is_ok() {
                    let response = b"HTTP/3 response\n";
                    let _ = send.write_all(response).await;
                    let _ = send.finish().await;
                }
            }
            Err(_) => break,
        }
    }
}

/// HTTP/3å®¢æˆ·ç«¯
pub async fn http3_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut roots = rustls::RootCertStore::empty();
    roots.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
        rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
            ta.subject,
            ta.spki,
            ta.name_constraints,
        )
    }));
    
    let mut client_config = ClientConfig::with_root_certificates(roots);
    client_config.alpn_protocols = vec![b"h3".to_vec()];
    
    let mut endpoint = Endpoint::client("0.0.0.0:0".parse()?)?;
    endpoint.set_default_client_config(client_config);
    
    let conn = endpoint.connect("127.0.0.1:4433".parse()?, "localhost")?.await?;
    
    let (mut send, recv) = conn.connection.open_bi().await?;
    send.write_all(b"GET / HTTP/3.0\r\n\r\n").await?;
    send.finish().await?;
    
    let response = recv.read_to_end(usize::MAX).await?;
    println!("HTTP/3å“åº”: {}", String::from_utf8_lossy(&response));
    
    Ok(())
}
```

### 3.4 æ€§èƒ½å¯¹æ¯”

| ç‰¹æ€§ | HTTP/1.1 | HTTP/2 | HTTP/3 |
|------|----------|--------|--------|
| ä¼ è¾“åè®® | TCP | TCP | UDP (QUIC) |
| å¤šè·¯å¤ç”¨ | âŒ | âœ… | âœ… |
| å¤´éƒ¨å‹ç¼© | âŒ | âœ… (HPACK) | âœ… (QPACK) |
| æœåŠ¡å™¨æ¨é€ | âŒ | âœ… | âœ… |
| è¿æ¥è¿ç§» | âŒ | âŒ | âœ… |
| 0-RTT | âŒ | âŒ | âœ… |
| é˜Ÿå¤´é˜»å¡ | âœ… (ä¸¥é‡) | âš ï¸ (TCPå±‚) | âŒ |
| å¹³å‡å»¶è¿Ÿ | åŸºçº¿ | -20% | -30% |

---

## 4. WebSocketåè®®

### 4.1 åè®®ç‰¹æ€§

- **å…¨åŒå·¥é€šä¿¡**: å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨å¯åŒæ—¶å‘é€æ•°æ®
- **åŸºäºTCP**: é€šè¿‡HTTPå‡çº§å»ºç«‹è¿æ¥
- **ä½å»¶è¿Ÿ**: æ— éœ€HTTPè½®è¯¢
- **æ¶ˆæ¯å¸§**: æ”¯æŒæ–‡æœ¬å’ŒäºŒè¿›åˆ¶å¸§

### 4.2 Rustå®ç°ï¼šWebSocketæœåŠ¡å™¨

```rust
use tokio_tungstenite::{accept_async, tungstenite::Message};
use tokio::net::{TcpListener, TcpStream};
use futures_util::{StreamExt, SinkExt};

/// WebSocketæœåŠ¡å™¨
pub async fn websocket_server() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:9001").await?;
    println!("WebSocketæœåŠ¡å™¨è¿è¡Œåœ¨ ws://127.0.0.1:9001");
    
    while let Ok((stream, addr)) = listener.accept().await {
        println!("æ–°WebSocketè¿æ¥: {}", addr);
        tokio::spawn(handle_websocket(stream));
    }
    
    Ok(())
}

async fn handle_websocket(stream: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let ws_stream = accept_async(stream).await?;
    let (mut write, mut read) = ws_stream.split();
    
    while let Some(msg) = read.next().await {
        let msg = msg?;
        
        match msg {
            Message::Text(text) => {
                println!("æ”¶åˆ°æ–‡æœ¬: {}", text);
                write.send(Message::Text(format!("å›æ˜¾: {}", text))).await?;
            }
            Message::Binary(data) => {
                println!("æ”¶åˆ°äºŒè¿›åˆ¶: {} å­—èŠ‚", data.len());
                write.send(Message::Binary(data)).await?;
            }
            Message::Ping(data) => {
                write.send(Message::Pong(data)).await?;
            }
            Message::Close(_) => {
                println!("WebSocketè¿æ¥å…³é—­");
                break;
            }
            _ => {}
        }
    }
    
    Ok(())
}

/// WebSocketå®¢æˆ·ç«¯
use tokio_tungstenite::connect_async;

pub async fn websocket_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let url = url::Url::parse("ws://127.0.0.1:9001")?;
    let (mut ws_stream, _) = connect_async(url).await?;
    
    // å‘é€æ¶ˆæ¯
    ws_stream.send(Message::Text("Hello, WebSocket!".into())).await?;
    
    // æ¥æ”¶å“åº”
    if let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        println!("æ”¶åˆ°å“åº”: {:?}", msg);
    }
    
    Ok(())
}
```

---

## 5. DNSåè®®

### 5.1 è®°å½•ç±»å‹

| è®°å½•ç±»å‹ | è¯´æ˜ | ç¤ºä¾‹ |
|----------|------|------|
| A | IPv4åœ°å€ | `example.com -> 93.184.216.34` |
| AAAA | IPv6åœ°å€ | `example.com -> 2606:2800:220:1:...` |
| CNAME | è§„èŒƒåç§° | `www.example.com -> example.com` |
| MX | é‚®ä»¶äº¤æ¢ | `example.com -> mail.example.com` |
| TXT | æ–‡æœ¬è®°å½• | SPF, DKIM, DMARC |
| NS | åç§°æœåŠ¡å™¨ | `example.com -> ns1.example.com` |
| SOA | æˆæƒèµ·å§‹ | åŒºåŸŸé…ç½®ä¿¡æ¯ |
| PTR | åå‘DNS | `34.216.184.93.in-addr.arpa -> example.com` |

### 5.2 DNSè§£æå®ç°

```rust
use hickory_resolver::TokioAsyncResolver;
use hickory_resolver::config::*;

/// DNSè§£æå™¨
pub struct DnsResolver {
    resolver: TokioAsyncResolver,
}

impl DnsResolver {
    /// åˆ›å»ºç³»ç»ŸDNSè§£æå™¨
    pub async fn from_system() -> Result<Self, Box<dyn std::error::Error>> {
        let resolver = TokioAsyncResolver::tokio_from_system_conf()?;
        Ok(Self { resolver })
    }
    
    /// åˆ›å»ºè‡ªå®šä¹‰DNSè§£æå™¨
    pub async fn from_config(
        nameservers: Vec<NameServerConfig>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let mut config = ResolverConfig::new();
        for ns in nameservers {
            config.add_name_server(ns);
        }
        
        let resolver = TokioAsyncResolver::tokio(config, ResolverOpts::default());
        Ok(Self { resolver })
    }
    
    /// Aè®°å½•æŸ¥è¯¢
    pub async fn lookup_ipv4(&self, hostname: &str) -> Result<Vec<std::net::Ipv4Addr>, Box<dyn std::error::Error>> {
        let response = self.resolver.ipv4_lookup(hostname).await?;
        Ok(response.iter().collect())
    }
    
    /// AAAAè®°å½•æŸ¥è¯¢
    pub async fn lookup_ipv6(&self, hostname: &str) -> Result<Vec<std::net::Ipv6Addr>, Box<dyn std::error::Error>> {
        let response = self.resolver.ipv6_lookup(hostname).await?;
        Ok(response.iter().collect())
    }
    
    /// MXè®°å½•æŸ¥è¯¢
    pub async fn lookup_mx(&self, domain: &str) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let response = self.resolver.mx_lookup(domain).await?;
        Ok(response.iter().map(|mx| mx.exchange().to_string()).collect())
    }
    
    /// TXTè®°å½•æŸ¥è¯¢
    pub async fn lookup_txt(&self, domain: &str) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let response = self.resolver.txt_lookup(domain).await?;
        Ok(response.iter().map(|txt| txt.to_string()).collect())
    }
    
    /// åå‘DNSæŸ¥è¯¢
    pub async fn reverse_lookup(&self, ip: std::net::IpAddr) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let response = self.resolver.reverse_lookup(ip).await?;
        Ok(response.iter().map(|name| name.to_string()).collect())
    }
}

/// DNSæŸ¥è¯¢ç¤ºä¾‹
pub async fn dns_example() -> Result<(), Box<dyn std::error::Error>> {
    let resolver = DnsResolver::from_system().await?;
    
    // Aè®°å½•
    let ipv4 = resolver.lookup_ipv4("example.com").await?;
    println!("Aè®°å½•: {:?}", ipv4);
    
    // MXè®°å½•
    let mx = resolver.lookup_mx("gmail.com").await?;
    println!("MXè®°å½•: {:?}", mx);
    
    // åå‘æŸ¥è¯¢
    let names = resolver.reverse_lookup("8.8.8.8".parse()?).await?;
    println!("åå‘DNS: {:?}", names);
    
    Ok(())
}
```

---

## 6. åº”ç”¨å±‚åè®®

### 6.1 gRPC (HTTP/2 + Protobuf)

```rust
// protoæ–‡ä»¶: hello.proto
// syntax = "proto3";
// package hello;
// service Greeter {
//     rpc SayHello (HelloRequest) returns (HelloReply);
// }
// message HelloRequest { string name = 1; }
// message HelloReply { string message = 1; }

use tonic::{transport::Server, Request, Response, Status};

pub mod hello {
    tonic::include_proto!("hello");
}

use hello::{greeter_server::{Greeter, GreeterServer}, HelloRequest, HelloReply};

#[derive(Default)]
pub struct MyGreeter;

#[tonic::async_trait]
impl Greeter for MyGreeter {
    async fn say_hello(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<HelloReply>, Status> {
        let name = request.into_inner().name;
        let reply = HelloReply {
            message: format!("Hello, {}!", name),
        };
        Ok(Response::new(reply))
    }
}

/// gRPCæœåŠ¡å™¨
pub async fn grpc_server_example() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:50051".parse()?;
    let greeter = MyGreeter::default();
    
    println!("gRPCæœåŠ¡å™¨è¿è¡Œåœ¨ {}", addr);
    
    Server::builder()
        .add_service(GreeterServer::new(greeter))
        .serve(addr)
        .await?;
    
    Ok(())
}

/// gRPCå®¢æˆ·ç«¯
use hello::greeter_client::GreeterClient;

pub async fn grpc_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = GreeterClient::connect("http://127.0.0.1:50051").await?;
    
    let request = tonic::Request::new(HelloRequest {
        name: "Rust".into(),
    });
    
    let response = client.say_hello(request).await?;
    println!("å“åº”: {}", response.into_inner().message);
    
    Ok(())
}
```

### 6.2 MQTT (IoTæ¶ˆæ¯åè®®)

```rust
use rumqttc::{MqttOptions, AsyncClient, QoS, Event, Packet};

/// MQTTå®¢æˆ·ç«¯
pub async fn mqtt_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut mqttoptions = MqttOptions::new("rust-client", "127.0.0.1", 1883);
    mqttoptions.set_keep_alive(std::time::Duration::from_secs(5));
    
    let (client, mut eventloop) = AsyncClient::new(mqttoptions, 10);
    
    // è®¢é˜…ä¸»é¢˜
    client.subscribe("sensors/+/temperature", QoS::AtMostOnce).await?;
    
    // å‘å¸ƒæ¶ˆæ¯
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        client.publish("sensors/room1/temperature", QoS::AtLeastOnce, false, "22.5").await.unwrap();
    });
    
    // æ¥æ”¶æ¶ˆæ¯
    while let Ok(notification) = eventloop.poll().await {
        if let Event::Incoming(Packet::Publish(publish)) = notification {
            println!(
                "æ”¶åˆ°ä¸»é¢˜ '{}': {}",
                publish.topic,
                String::from_utf8_lossy(&publish.payload)
            );
        }
    }
    
    Ok(())
}
```

### 6.3 GraphQL over HTTP

```rust
use async_graphql::{Schema, Object, EmptyMutation, EmptySubscription};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{Router, Server, routing::post};

struct Query;

#[Object]
impl Query {
    async fn hello(&self, name: String) -> String {
        format!("Hello, {}!", name)
    }
    
    async fn users(&self) -> Vec<User> {
        vec![
            User { id: 1, name: "Alice".into() },
            User { id: 2, name: "Bob".into() },
        ]
    }
}

struct User {
    id: i32,
    name: String,
}

#[Object]
impl User {
    async fn id(&self) -> i32 {
        self.id
    }
    
    async fn name(&self) -> &str {
        &self.name
    }
}

/// GraphQLæœåŠ¡å™¨
pub async fn graphql_server_example() -> Result<(), Box<dyn std::error::Error>> {
    let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();
    
    async fn graphql_handler(
        schema: axum::Extension<Schema<Query, EmptyMutation, EmptySubscription>>,
        req: GraphQLRequest,
    ) -> GraphQLResponse {
        schema.execute(req.into_inner()).await.into()
    }
    
    let app = Router::new()
        .route("/graphql", post(graphql_handler))
        .layer(axum::Extension(schema));
    
    println!("GraphQLæœåŠ¡å™¨è¿è¡Œåœ¨ http://127.0.0.1:8000/graphql");
    
    Server::bind(&"127.0.0.1:8000".parse()?)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}
```

---

## 7. å®‰å…¨åè®®

### 7.1 TLS/SSL

```rust
use tokio_rustls::{TlsAcceptor, rustls};
use tokio::net::TcpListener;
use std::sync::Arc;
use std::fs;

/// TLSæœåŠ¡å™¨
pub async fn tls_server_example() -> Result<(), Box<dyn std::error::Error>> {
    // åŠ è½½è¯ä¹¦å’Œç§é’¥
    let cert = fs::read("cert.pem")?;
    let key = fs::read("key.pem")?;
    
    let certs = rustls_pemfile::certs(&mut &cert[..])
        .map(|mut certs| certs.drain(..).map(rustls::Certificate).collect())
        .unwrap();
    
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key[..])
        .map(|mut keys| rustls::PrivateKey(keys.remove(0)))
        .unwrap();
    
    let config = rustls::ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    
    let acceptor = TlsAcceptor::from(Arc::new(config));
    let listener = TcpListener::bind("127.0.0.1:8443").await?;
    
    println!("TLSæœåŠ¡å™¨è¿è¡Œåœ¨ https://127.0.0.1:8443");
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = acceptor.clone();
        
        tokio::spawn(async move {
            let stream = acceptor.accept(stream).await;
            match stream {
                Ok(stream) => {
                    println!("TLSè¿æ¥æ¥è‡ª: {}", peer_addr);
                    // å¤„ç†TLSè¿æ¥
                }
                Err(e) => eprintln!("TLSæ¡æ‰‹å¤±è´¥: {}", e),
            }
        });
    }
}
```

### 7.2 DTLS (Datagram TLS)

DTLSä¸ºUDPæä¾›TLSçº§åˆ«çš„å®‰å…¨æ€§ï¼Œå¸¸ç”¨äºWebRTCå’ŒVoIPã€‚

```rust
// DTLSé€šå¸¸ç”±openssl-dtlsæˆ–webrtcåº“å®ç°
// è¿™é‡Œå±•ç¤ºæ¦‚å¿µæ€§æ¥å£

pub struct DtlsConnection {
    // å†…éƒ¨å®ç°
}

impl DtlsConnection {
    pub async fn new(remote_addr: std::net::SocketAddr) -> Result<Self, Box<dyn std::error::Error>> {
        // å»ºç«‹DTLSè¿æ¥
        todo!()
    }
    
    pub async fn send(&self, data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
        // åŠ å¯†å¹¶å‘é€æ•°æ®
        todo!()
    }
    
    pub async fn recv(&self, buffer: &mut [u8]) -> Result<usize, Box<dyn std::error::Error>> {
        // æ¥æ”¶å¹¶è§£å¯†æ•°æ®
        todo!()
    }
}
```

---

## 8. P2Påè®®

### 8.1 libp2påè®®æ ˆ

```rust
use libp2p::{
    identity, ping, noise, tcp, yamux, Multiaddr, PeerId, Swarm, Transport,
    swarm::{NetworkBehaviour, SwarmEvent}
};
use std::error::Error;

/// P2PèŠ‚ç‚¹è¡Œä¸º
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "MyBehaviourEvent")]
struct MyBehaviour {
    ping: ping::Behaviour,
}

#[derive(Debug)]
enum MyBehaviourEvent {
    Ping(ping::Event),
}

impl From<ping::Event> for MyBehaviourEvent {
    fn from(event: ping::Event) -> Self {
        MyBehaviourEvent::Ping(event)
    }
}

/// P2PèŠ‚ç‚¹ç¤ºä¾‹
pub async fn p2p_node_example() -> Result<(), Box<dyn Error>> {
    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    
    println!("æœ¬åœ°èŠ‚ç‚¹ID: {}", local_peer_id);
    
    let transport = tcp::tokio::Transport::new(tcp::Config::default())
        .upgrade(libp2p::core::upgrade::Version::V1)
        .authenticate(noise::NoiseAuthenticated::xx(&local_key).unwrap())
        .multiplex(yamux::YamuxConfig::default())
        .boxed();
    
    let behaviour = MyBehaviour {
        ping: ping::Behaviour::new(ping::Config::new()),
    };
    
    let mut swarm = Swarm::new(transport, behaviour, local_peer_id);
    
    // ç›‘å¬åœ°å€
    swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;
    
    loop {
        match swarm.select_next_some().await {
            SwarmEvent::NewListenAddr { address, .. } => {
                println!("ç›‘å¬åœ°å€: {}", address);
            }
            SwarmEvent::Behaviour(MyBehaviourEvent::Ping(event)) => {
                println!("Pingäº‹ä»¶: {:?}", event);
            }
            _ => {}
        }
    }
}
```

---

## 9. å®æ—¶é€šä¿¡åè®®

### 9.1 WebRTC

WebRTCæ˜¯å®æ—¶éŸ³è§†é¢‘é€šä¿¡çš„æ ‡å‡†ï¼Œæ¶‰åŠå¤šä¸ªåè®®ï¼š

- **STUN/TURN**: NATç©¿é€
- **ICE**: è¿æ¥å»ºç«‹
- **DTLS**: å®‰å…¨å±‚
- **SRTP**: åŠ å¯†çš„RTP
- **SCTP**: æ•°æ®é€šé“

```rust
use webrtc::{
    api::APIBuilder,
    peer_connection::configuration::RTCConfiguration,
    peer_connection::peer_connection_state::RTCPeerConnectionState,
    ice_transport::ice_server::RTCIceServer,
};

/// WebRTCç¤ºä¾‹
pub async fn webrtc_example() -> Result<(), Box<dyn std::error::Error>> {
    let config = RTCConfiguration {
        ice_servers: vec![RTCIceServer {
            urls: vec!["stun:stun.l.google.com:19302".to_owned()],
            ..Default::default()
        }],
        ..Default::default()
    };
    
    let api = APIBuilder::new().build();
    let peer_connection = api.new_peer_connection(config).await?;
    
    // ç›‘å¬è¿æ¥çŠ¶æ€
    peer_connection.on_peer_connection_state_change(Box::new(move |state: RTCPeerConnectionState| {
        println!("è¿æ¥çŠ¶æ€: {:?}", state);
        Box::pin(async {})
    }));
    
    // åˆ›å»ºOffer
    let offer = peer_connection.create_offer(None).await?;
    peer_connection.set_local_description(offer).await?;
    
    println!("WebRTC Offeråˆ›å»ºæˆåŠŸ");
    
    Ok(())
}
```

### 9.2 RTP/RTCP

```rust
/// RTPåŒ…ç»“æ„
pub struct RtpPacket {
    pub version: u8,
    pub padding: bool,
    pub extension: bool,
    pub csrc_count: u8,
    pub marker: bool,
    pub payload_type: u8,
    pub sequence_number: u16,
    pub timestamp: u32,
    pub ssrc: u32,
    pub payload: Vec<u8>,
}

impl RtpPacket {
    pub fn parse(data: &[u8]) -> Result<Self, String> {
        if data.len() < 12 {
            return Err("RTPåŒ…å¤ªå°".into());
        }
        
        let version = (data[0] >> 6) & 0x03;
        let padding = (data[0] & 0x20) != 0;
        let extension = (data[0] & 0x10) != 0;
        let csrc_count = data[0] & 0x0F;
        let marker = (data[1] & 0x80) != 0;
        let payload_type = data[1] & 0x7F;
        
        let sequence_number = u16::from_be_bytes([data[2], data[3]]);
        let timestamp = u32::from_be_bytes([data[4], data[5], data[6], data[7]]);
        let ssrc = u32::from_be_bytes([data[8], data[9], data[10], data[11]]);
        
        let payload = data[12..].to_vec();
        
        Ok(Self {
            version,
            padding,
            extension,
            csrc_count,
            marker,
            payload_type,
            sequence_number,
            timestamp,
            ssrc,
            payload,
        })
    }
    
    pub fn serialize(&self) -> Vec<u8> {
        let mut buffer = Vec::with_capacity(12 + self.payload.len());
        
        let byte0 = (self.version << 6) | ((self.padding as u8) << 5) | ((self.extension as u8) << 4) | self.csrc_count;
        let byte1 = ((self.marker as u8) << 7) | self.payload_type;
        
        buffer.push(byte0);
        buffer.push(byte1);
        buffer.extend_from_slice(&self.sequence_number.to_be_bytes());
        buffer.extend_from_slice(&self.timestamp.to_be_bytes());
        buffer.extend_from_slice(&self.ssrc.to_be_bytes());
        buffer.extend_from_slice(&self.payload);
        
        buffer
    }
}
```

---

## 10. åè®®é€‰æ‹©å†³ç­–æ ‘

```text
éœ€æ±‚åˆ†æ
â”œâ”€ å®æ—¶æ€§è¦æ±‚ï¼Ÿ
â”‚  â”œâ”€ æ˜¯ï¼ˆä½å»¶è¿Ÿï¼‰
â”‚  â”‚  â”œâ”€ éŸ³è§†é¢‘é€šä¿¡ â†’ WebRTC
â”‚  â”‚  â”œâ”€ æ¸¸æˆæ•°æ® â†’ UDP + è‡ªå®šä¹‰åè®® æˆ– QUIC
â”‚  â”‚  â””â”€ é‡‘èæ•°æ® â†’ WebSocket æˆ– gRPC Stream
â”‚  â””â”€ å¦ï¼ˆå¯å®¹å¿å»¶è¿Ÿï¼‰
â”‚     â”œâ”€ REST API â†’ HTTP/1.1 æˆ– HTTP/2
â”‚     â””â”€ æ‰¹é‡æ•°æ® â†’ HTTP/2 æˆ– gRPC
â”œâ”€ å¯é æ€§è¦æ±‚ï¼Ÿ
â”‚  â”œâ”€ é«˜ï¼ˆä¸èƒ½ä¸¢åŒ…ï¼‰ â†’ TCP, QUIC
â”‚  â””â”€ ä¸­ï¼ˆå¯æ¥å—ä¸¢åŒ…ï¼‰ â†’ UDP
â”œâ”€ åŒå‘é€šä¿¡ï¼Ÿ
â”‚  â”œâ”€ æ˜¯ â†’ WebSocket, gRPC Bidirectional Stream, QUIC
â”‚  â””â”€ å¦ â†’ HTTP, UDPå•å‘
â”œâ”€ æ¶ˆæ¯æ¨¡å‹ï¼Ÿ
â”‚  â”œâ”€ Request-Response â†’ HTTP, gRPC Unary
â”‚  â”œâ”€ Publish-Subscribe â†’ MQTT, WebSocket
â”‚  â””â”€ Streaming â†’ gRPC Stream, WebSocket
â””â”€ ç¯å¢ƒé™åˆ¶ï¼Ÿ
   â”œâ”€ æµè§ˆå™¨ â†’ HTTP, WebSocket, WebRTC
   â”œâ”€ IoT â†’ MQTT, CoAP, QUIC
   â””â”€ å¾®æœåŠ¡ â†’ gRPC, HTTP/2
```

---

## 11. Rustç”Ÿæ€åè®®åº“å¯¹æ¯”

| åè®® | æ¨èåº“ | æˆç†Ÿåº¦ | ç‰¹æ€§ |
|------|--------|--------|------|
| TCP/UDP | `tokio::net`, `async-std` | â­â­â­â­â­ | æ ‡å‡†åº“ï¼Œå¼‚æ­¥æ”¯æŒ |
| HTTP/1.1 | `hyper`, `reqwest` | â­â­â­â­â­ | é«˜æ€§èƒ½ï¼Œç”Ÿäº§å°±ç»ª |
| HTTP/2 | `hyper`, `h2` | â­â­â­â­â­ | å¤šè·¯å¤ç”¨ï¼ŒæœåŠ¡å™¨æ¨é€ |
| HTTP/3 | `quinn`, `h3` | â­â­â­â­ | QUICå®ç°ï¼Œç¨³å®šä¸­ |
| WebSocket | `tokio-tungstenite`, `tungstenite` | â­â­â­â­â­ | å®Œæ•´å®ç° |
| gRPC | `tonic`, `grpc-rs` | â­â­â­â­â­ | å¼‚æ­¥ï¼Œç¼–è¯‘æ—¶ç±»å‹å®‰å…¨ |
| MQTT | `rumqttc`, `paho-mqtt` | â­â­â­â­ | MQTT 3.1.1/5.0æ”¯æŒ |
| DNS | `hickory-dns`, `trust-dns` | â­â­â­â­â­ | DoH/DoTæ”¯æŒ |
| TLS | `rustls`, `native-tls` | â­â­â­â­â­ | çº¯Rustæˆ–ç³»ç»Ÿåº“ |
| QUIC | `quinn`, `quiche` | â­â­â­â­ | HTTP/3åŸºç¡€ |
| P2P | `libp2p` | â­â­â­â­ | å®Œæ•´P2Pæ ˆ |
| WebRTC | `webrtc-rs` | â­â­â­â­ | åª’ä½“é€šä¿¡ |
| GraphQL | `async-graphql`, `juniper` | â­â­â­â­ | ç±»å‹å®‰å…¨ |

---

## 12. åè®®æµ‹è¯•ä¸éªŒè¯

```rust
use tokio::time::{sleep, Duration};

/// åè®®æ€§èƒ½æµ‹è¯•æ¡†æ¶
pub struct ProtocolBenchmark {
    name: String,
}

impl ProtocolBenchmark {
    pub fn new(name: impl Into<String>) -> Self {
        Self { name: name.into() }
    }
    
    /// å»¶è¿Ÿæµ‹è¯•
    pub async fn measure_latency<F, Fut>(&self, mut operation: F, iterations: usize) -> Duration
    where
        F: FnMut() -> Fut,
        Fut: std::future::Future<Output = ()>,
    {
        let start = std::time::Instant::now();
        
        for _ in 0..iterations {
            operation().await;
        }
        
        let elapsed = start.elapsed();
        println!("[{}] å»¶è¿Ÿ: {:?} (å¹³å‡ {:?})", 
            self.name, 
            elapsed, 
            elapsed / iterations as u32
        );
        
        elapsed / iterations as u32
    }
    
    /// ååé‡æµ‹è¯•
    pub async fn measure_throughput<F, Fut>(&self, mut operation: F, data_size: usize, duration_secs: u64) -> f64
    where
        F: FnMut() -> Fut,
        Fut: std::future::Future<Output = ()>,
    {
        let start = std::time::Instant::now();
        let mut bytes_transferred = 0;
        
        while start.elapsed().as_secs() < duration_secs {
            operation().await;
            bytes_transferred += data_size;
        }
        
        let elapsed = start.elapsed().as_secs_f64();
        let throughput_mbps = (bytes_transferred as f64 * 8.0) / (elapsed * 1_000_000.0);
        
        println!("[{}] ååé‡: {:.2} Mbps", self.name, throughput_mbps);
        
        throughput_mbps
    }
}

/// åè®®å¯¹æ¯”æµ‹è¯•
pub async fn protocol_comparison() {
    // HTTP/1.1 vs HTTP/2 vs HTTP/3
    let http1_bench = ProtocolBenchmark::new("HTTP/1.1");
    let http2_bench = ProtocolBenchmark::new("HTTP/2");
    let http3_bench = ProtocolBenchmark::new("HTTP/3");
    
    // æ¨¡æ‹Ÿè¯·æ±‚
    let http1_latency = http1_bench.measure_latency(|| async { sleep(Duration::from_millis(10)).await }, 100).await;
    let http2_latency = http2_bench.measure_latency(|| async { sleep(Duration::from_millis(8)).await }, 100).await;
    let http3_latency = http3_bench.measure_latency(|| async { sleep(Duration::from_millis(7)).await }, 100).await;
    
    println!("\nåè®®å»¶è¿Ÿå¯¹æ¯”:");
    println!("HTTP/1.1: {:?}", http1_latency);
    println!("HTTP/2:   {:?} (æ”¹è¿› {:.1}%)", http2_latency, (http1_latency.as_nanos() as f64 - http2_latency.as_nanos() as f64) / http1_latency.as_nanos() as f64 * 100.0);
    println!("HTTP/3:   {:?} (æ”¹è¿› {:.1}%)", http3_latency, (http1_latency.as_nanos() as f64 - http3_latency.as_nanos() as f64) / http1_latency.as_nanos() as f64 * 100.0);
}
```

---

## 13. æœ€ä½³å®è·µ

### âœ… åè®®é€‰æ‹©åŸåˆ™

1. **ä¼˜å…ˆä½¿ç”¨é«˜å±‚åè®®**: é™¤éæœ‰ç‰¹æ®Šéœ€æ±‚ï¼Œé¿å…ç›´æ¥æ“ä½œTCP/UDP
2. **è€ƒè™‘ç”Ÿæ€æˆç†Ÿåº¦**: é€‰æ‹©ç¤¾åŒºæ”¯æŒæ´»è·ƒçš„åº“
3. **ç±»å‹å®‰å…¨ä¼˜å…ˆ**: ä½¿ç”¨ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥çš„åº“ï¼ˆå¦‚Tonicï¼‰
4. **å¼‚æ­¥ä¼˜å…ˆ**: ç½‘ç»œI/Oå¯†é›†åœºæ™¯ä¼˜å…ˆé€‰æ‹©asyncåº“

### âš ï¸ å¸¸è§é™·é˜±

1. **å¿½ç•¥èƒŒå‹**: ç”Ÿäº§è€…é€Ÿåº¦è¶…è¿‡æ¶ˆè´¹è€…æ—¶ç¼ºä¹æµæ§
2. **é”™è¯¯å¤„ç†ä¸è¶³**: ç½‘ç»œé”™è¯¯å¿…é¡»å¦¥å–„å¤„ç†å’Œé‡è¯•
3. **è¶…æ—¶é…ç½®ç¼ºå¤±**: æ‰€æœ‰ç½‘ç»œæ“ä½œéƒ½åº”è®¾ç½®åˆç†è¶…æ—¶
4. **ç¼“å†²åŒºç®¡ç†**: é¿å…æ— é™å¢é•¿çš„ç¼“å†²åŒº

### ğŸ”§ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```rust
/// è¿æ¥æ± ç®¡ç†
use deadpool::managed::{Manager, Pool, RecycleResult};

struct TcpConnectionManager {
    addr: String,
}

#[async_trait::async_trait]
impl Manager for TcpConnectionManager {
    type Type = tokio::net::TcpStream;
    type Error = std::io::Error;
    
    async fn create(&self) -> Result<Self::Type, Self::Error> {
        tokio::net::TcpStream::connect(&self.addr).await
    }
    
    async fn recycle(&self, conn: &mut Self::Type) -> RecycleResult<Self::Error> {
        // æ£€æŸ¥è¿æ¥æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        Ok(())
    }
}

/// ä½¿ç”¨è¿æ¥æ± 
pub async fn connection_pool_example() -> Result<(), Box<dyn std::error::Error>> {
    let manager = TcpConnectionManager {
        addr: "127.0.0.1:8080".into(),
    };
    
    let pool = Pool::builder(manager).max_size(10).build()?;
    
    let conn = pool.get().await?;
    // ä½¿ç”¨è¿æ¥
    
    Ok(())
}
```

---

**æ–‡æ¡£å®Œæˆ**: æ­¤å‚è€ƒæ–‡æ¡£æ¶µç›–äº†Rust 1.90ç½‘ç»œç¼–ç¨‹ä¸­çš„ä¸»è¦åè®®åˆ†ç±»ã€å®ç°æ–¹å¼å’Œæœ€ä½³å®è·µã€‚å»ºè®®ç»“åˆå®é™…åœºæ™¯é€‰æ‹©åˆé€‚çš„åè®®å’Œåº“ã€‚

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ [02_ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©.md](./02_ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©.md) æ·±å…¥äº†è§£å„åº“çš„ä¼˜åŠ£ã€‚
