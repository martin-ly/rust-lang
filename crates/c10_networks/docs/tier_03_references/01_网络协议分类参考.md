# 网络协议分类参考

> **文档版本**: v1.0.0  
> **更新日期**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **文档层级**: Tier 3 - 技术参考

---

## 目录

- [网络协议分类参考](#网络协议分类参考)
  - [目录](#目录)
  - [1. OSI七层模型与协议映射](#1-osi七层模型与协议映射)
    - [1.1 物理层（Physical Layer）](#11-物理层physical-layer)
    - [1.2 数据链路层（Data Link Layer）](#12-数据链路层data-link-layer)
    - [1.3 网络层（Network Layer）](#13-网络层network-layer)
    - [1.4 传输层（Transport Layer）](#14-传输层transport-layer)
    - [1.5 会话层（Session Layer）](#15-会话层session-layer)
    - [1.6 表示层（Presentation Layer）](#16-表示层presentation-layer)
    - [1.7 应用层（Application Layer）](#17-应用层application-layer)
  - [2. TCP/IP协议族](#2-tcpip协议族)
    - [2.1 核心协议](#21-核心协议)
    - [2.2 Rust实现：TCP服务器](#22-rust实现tcp服务器)
    - [2.3 UDP完整实现](#23-udp完整实现)
  - [3. HTTP协议家族](#3-http协议家族)
    - [3.1 HTTP/1.1](#31-http11)
    - [3.2 HTTP/2](#32-http2)
    - [3.3 HTTP/3 (QUIC)](#33-http3-quic)
    - [3.4 性能对比](#34-性能对比)
  - [4. WebSocket协议](#4-websocket协议)
    - [4.1 协议特性](#41-协议特性)
    - [4.2 Rust实现：WebSocket服务器](#42-rust实现websocket服务器)
  - [5. DNS协议](#5-dns协议)
    - [5.1 记录类型](#51-记录类型)
    - [5.2 DNS解析实现](#52-dns解析实现)
  - [6. 应用层协议](#6-应用层协议)
    - [6.1 gRPC (HTTP/2 + Protobuf)](#61-grpc-http2--protobuf)
    - [6.2 MQTT (IoT消息协议)](#62-mqtt-iot消息协议)
    - [6.3 GraphQL over HTTP](#63-graphql-over-http)
  - [7. 安全协议](#7-安全协议)
    - [7.1 TLS/SSL](#71-tlsssl)
    - [7.2 DTLS (Datagram TLS)](#72-dtls-datagram-tls)
  - [8. P2P协议](#8-p2p协议)
    - [8.1 libp2p协议栈](#81-libp2p协议栈)
  - [9. 实时通信协议](#9-实时通信协议)
    - [9.1 WebRTC](#91-webrtc)
    - [9.2 RTP/RTCP](#92-rtprtcp)
  - [10. 协议选择决策树](#10-协议选择决策树)
  - [11. Rust生态协议库对比](#11-rust生态协议库对比)
  - [12. 协议测试与验证](#12-协议测试与验证)
  - [13. 最佳实践](#13-最佳实践)
    - [✅ 协议选择原则](#-协议选择原则)
    - [⚠️ 常见陷阱](#️-常见陷阱)
    - [🔧 性能优化技巧](#-性能优化技巧)

---

## 1. OSI七层模型与协议映射

### 1.1 物理层（Physical Layer）

**Rust实现不直接涉及，但可通过硬件抽象层（HAL）访问**：

```rust
// 嵌入式硬件抽象示例（embedded-hal）
use embedded_hal::serial::{Read, Write};

pub struct PhysicalLayer<S> {
    serial: S,
}

impl<S: Read<u8> + Write<u8>> PhysicalLayer<S> {
    pub fn new(serial: S) -> Self {
        Self { serial }
    }
    
    /// 发送原始比特流
    pub fn send_bits(&mut self, data: &[u8]) -> Result<(), S::Error> {
        for &byte in data {
            nb::block!(self.serial.write(byte))?;
        }
        Ok(())
    }
}
```

### 1.2 数据链路层（Data Link Layer）

**协议**: Ethernet, PPP, ARP, VLAN (802.1Q)

```rust
use pnet::packet::ethernet::{EtherTypes, EthernetPacket};
use pnet::packet::Packet;

/// 解析以太网帧
pub fn parse_ethernet_frame(data: &[u8]) -> Option<String> {
    if let Some(eth_packet) = EthernetPacket::new(data) {
        Some(format!(
            "Ethernet: {} -> {} | Type: {:?}",
            eth_packet.get_source(),
            eth_packet.get_destination(),
            eth_packet.get_ethertype()
        ))
    } else {
        None
    }
}

/// ARP请求构造
use pnet::packet::arp::{ArpHardwareTypes, ArpOperations, ArpPacket, MutableArpPacket};

pub fn build_arp_request(
    src_mac: [u8; 6],
    src_ip: [u8; 4],
    dst_ip: [u8; 4],
) -> Vec<u8> {
    let mut buffer = vec![0u8; 28];
    let mut arp = MutableArpPacket::new(&mut buffer).unwrap();
    
    arp.set_hardware_type(ArpHardwareTypes::Ethernet);
    arp.set_protocol_type(EtherTypes::Ipv4);
    arp.set_hw_addr_len(6);
    arp.set_proto_addr_len(4);
    arp.set_operation(ArpOperations::Request);
    arp.set_sender_hw_addr(pnet::util::MacAddr::from(src_mac));
    arp.set_sender_proto_addr(std::net::Ipv4Addr::from(src_ip));
    arp.set_target_hw_addr(pnet::util::MacAddr::zero());
    arp.set_target_proto_addr(std::net::Ipv4Addr::from(dst_ip));
    
    buffer
}
```

### 1.3 网络层（Network Layer）

**协议**: IPv4, IPv6, ICMP, ICMPv6

```rust
use pnet::packet::ipv4::{Ipv4Packet, MutableIpv4Packet};
use pnet::packet::ip::IpNextHeaderProtocols;

/// IPv4数据包解析
pub fn parse_ipv4_packet(data: &[u8]) -> Option<String> {
    if let Some(ip_packet) = Ipv4Packet::new(data) {
        Some(format!(
            "IPv4: {} -> {} | Proto: {:?} | TTL: {}",
            ip_packet.get_source(),
            ip_packet.get_destination(),
            ip_packet.get_next_level_protocol(),
            ip_packet.get_ttl()
        ))
    } else {
        None
    }
}

/// ICMP Ping实现
use pnet::packet::icmp::{echo_request, IcmpTypes, MutableIcmpPacket};

pub fn build_icmp_echo_request(seq: u16, data: &[u8]) -> Vec<u8> {
    let mut buffer = vec![0u8; 8 + data.len()];
    let mut icmp = MutableIcmpPacket::new(&mut buffer).unwrap();
    
    icmp.set_icmp_type(IcmpTypes::EchoRequest);
    icmp.set_icmp_code(echo_request::IcmpCodes::NoCode);
    
    let echo_req = echo_request::MutableEchoRequestPacket::new(&mut buffer).unwrap();
    echo_req.set_identifier(std::process::id() as u16);
    echo_req.set_sequence_number(seq);
    
    let payload = echo_req.packet_mut();
    payload[8..].copy_from_slice(data);
    
    // 计算校验和
    let checksum = pnet::packet::icmp::checksum(&icmp.to_immutable());
    icmp.set_checksum(checksum);
    
    buffer
}
```

### 1.4 传输层（Transport Layer）

**协议**: TCP, UDP, SCTP, DCCP, QUIC

```rust
use tokio::net::TcpStream;
use std::net::SocketAddr;

/// TCP连接管理
pub struct TcpConnectionManager {
    addr: SocketAddr,
}

impl TcpConnectionManager {
    pub fn new(addr: SocketAddr) -> Self {
        Self { addr }
    }
    
    /// 建立TCP连接（三次握手）
    pub async fn connect(&self) -> std::io::Result<TcpStream> {
        let stream = TcpStream::connect(self.addr).await?;
        
        // 配置TCP选项
        stream.set_nodelay(true)?; // 禁用Nagle算法
        stream.set_ttl(64)?;       // 设置TTL
        
        Ok(stream)
    }
    
    /// TCP保活配置
    pub async fn configure_keepalive(&self, stream: &TcpStream) -> std::io::Result<()> {
        use socket2::{Socket, TcpKeepalive};
        use std::time::Duration;
        
        let socket = Socket::from(stream.as_raw_fd());
        let keepalive = TcpKeepalive::new()
            .with_time(Duration::from_secs(60))
            .with_interval(Duration::from_secs(10));
        
        socket.set_tcp_keepalive(&keepalive)?;
        Ok(())
    }
}

/// UDP套接字管理
use tokio::net::UdpSocket;

pub struct UdpSocketManager {
    socket: UdpSocket,
}

impl UdpSocketManager {
    pub async fn new(addr: &str) -> std::io::Result<Self> {
        let socket = UdpSocket::bind(addr).await?;
        
        // 设置广播
        socket.set_broadcast(true)?;
        
        // 设置接收缓冲区
        socket.set_recv_buffer_size(1024 * 1024)?;
        
        Ok(Self { socket })
    }
    
    /// UDP多播
    pub async fn join_multicast(&self, multicast_addr: &str) -> std::io::Result<()> {
        let multicast: std::net::Ipv4Addr = multicast_addr.parse().unwrap();
        let interface = std::net::Ipv4Addr::UNSPECIFIED;
        
        self.socket.join_multicast_v4(multicast, interface)?;
        Ok(())
    }
}
```

### 1.5 会话层（Session Layer）

**Rust中通常由应用层协议实现**：

```rust
/// 会话管理器
use std::collections::HashMap;
use uuid::Uuid;

pub struct SessionManager {
    sessions: HashMap<Uuid, SessionData>,
}

#[derive(Debug, Clone)]
pub struct SessionData {
    user_id: String,
    created_at: std::time::Instant,
    expires_at: std::time::Instant,
    data: HashMap<String, String>,
}

impl SessionManager {
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
        }
    }
    
    /// 创建会话
    pub fn create_session(&mut self, user_id: String, ttl_secs: u64) -> Uuid {
        let session_id = Uuid::new_v4();
        let now = std::time::Instant::now();
        
        let session = SessionData {
            user_id,
            created_at: now,
            expires_at: now + std::time::Duration::from_secs(ttl_secs),
            data: HashMap::new(),
        };
        
        self.sessions.insert(session_id, session);
        session_id
    }
    
    /// 验证会话
    pub fn validate_session(&self, session_id: &Uuid) -> Option<&SessionData> {
        self.sessions.get(session_id).and_then(|session| {
            if session.expires_at > std::time::Instant::now() {
                Some(session)
            } else {
                None
            }
        })
    }
    
    /// 续期会话
    pub fn renew_session(&mut self, session_id: &Uuid, ttl_secs: u64) -> bool {
        if let Some(session) = self.sessions.get_mut(session_id) {
            let now = std::time::Instant::now();
            if session.expires_at > now {
                session.expires_at = now + std::time::Duration::from_secs(ttl_secs);
                return true;
            }
        }
        false
    }
}
```

### 1.6 表示层（Presentation Layer）

**数据编码/解码**：JSON, Protobuf, MessagePack, CBOR

```rust
use serde::{Deserialize, Serialize};

/// JSON编解码
#[derive(Debug, Serialize, Deserialize)]
pub struct Message {
    id: u64,
    content: String,
}

pub fn encode_json(msg: &Message) -> Result<Vec<u8>, serde_json::Error> {
    serde_json::to_vec(msg)
}

pub fn decode_json(data: &[u8]) -> Result<Message, serde_json::Error> {
    serde_json::from_slice(data)
}

/// Protobuf编解码
use prost::Message as ProstMessage;

#[derive(Clone, PartialEq, ProstMessage)]
pub struct ProtoMessage {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(string, tag = "2")]
    pub content: String,
}

pub fn encode_protobuf(msg: &ProtoMessage) -> Vec<u8> {
    msg.encode_to_vec()
}

pub fn decode_protobuf(data: &[u8]) -> Result<ProtoMessage, prost::DecodeError> {
    ProtoMessage::decode(data)
}

/// MessagePack编解码
use rmp_serde::{encode, decode};

pub fn encode_msgpack(msg: &Message) -> Result<Vec<u8>, encode::Error> {
    rmp_serde::to_vec(msg)
}

pub fn decode_msgpack(data: &[u8]) -> Result<Message, decode::Error> {
    rmp_serde::from_slice(data)
}

/// 性能对比
pub fn benchmark_serialization(msg: &Message) {
    use std::time::Instant;
    
    // JSON
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = encode_json(msg);
    }
    println!("JSON: {:?}", start.elapsed());
    
    // Protobuf
    let proto_msg = ProtoMessage {
        id: msg.id,
        content: msg.content.clone(),
    };
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = encode_protobuf(&proto_msg);
    }
    println!("Protobuf: {:?}", start.elapsed());
    
    // MessagePack
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = encode_msgpack(msg);
    }
    println!("MessagePack: {:?}", start.elapsed());
}
```

### 1.7 应用层（Application Layer）

**协议**: HTTP, FTP, SMTP, POP3, IMAP, SSH, Telnet, DNS, DHCP

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

/// 简单HTTP客户端
pub struct SimpleHttpClient;

impl SimpleHttpClient {
    pub async fn get(url: &str) -> std::io::Result<String> {
        let mut stream = TcpStream::connect("example.com:80").await?;
        
        let request = format!(
            "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n"
        );
        
        stream.write_all(request.as_bytes()).await?;
        
        let mut response = String::new();
        stream.read_to_string(&mut response).await?;
        
        Ok(response)
    }
}
```

---

## 2. TCP/IP协议族

### 2.1 核心协议

| 协议 | 层级 | 功能 | Rust库 |
|------|------|------|--------|
| IP | 网络层 | 数据包路由 | `pnet`, `smoltcp` |
| ICMP | 网络层 | 错误报告、诊断 | `pnet`, `surge` |
| TCP | 传输层 | 可靠字节流传输 | `std::net`, `tokio::net` |
| UDP | 传输层 | 无连接数据报传输 | `std::net`, `tokio::net` |
| ARP | 数据链路层 | IP到MAC地址映射 | `pnet` |

### 2.2 Rust实现：TCP服务器

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::sync::Arc;
use tokio::sync::Semaphore;

/// 高性能TCP服务器
pub struct TcpServer {
    listener: TcpListener,
    max_connections: Arc<Semaphore>,
}

impl TcpServer {
    pub async fn bind(addr: &str, max_conn: usize) -> std::io::Result<Self> {
        let listener = TcpListener::bind(addr).await?;
        let max_connections = Arc::new(Semaphore::new(max_conn));
        
        Ok(Self {
            listener,
            max_connections,
        })
    }
    
    pub async fn serve(&self) -> std::io::Result<()> {
        loop {
            // 获取连接许可
            let permit = self.max_connections.clone().acquire_owned().await.unwrap();
            
            let (stream, addr) = self.listener.accept().await?;
            println!("新连接: {}", addr);
            
            tokio::spawn(async move {
                if let Err(e) = Self::handle_client(stream).await {
                    eprintln!("处理客户端错误: {}", e);
                }
                drop(permit);
            });
        }
    }
    
    async fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {
        let mut buffer = vec![0u8; 4096];
        
        loop {
            let n = stream.read(&mut buffer).await?;
            if n == 0 {
                break; // 连接关闭
            }
            
            // 回显数据
            stream.write_all(&buffer[..n]).await?;
        }
        
        Ok(())
    }
}

/// 使用示例
pub async fn tcp_server_example() -> std::io::Result<()> {
    let server = TcpServer::bind("127.0.0.1:8080", 100).await?;
    server.serve().await
}
```

### 2.3 UDP完整实现

```rust
use tokio::net::UdpSocket;
use std::sync::Arc;

/// UDP服务器
pub struct UdpServer {
    socket: Arc<UdpSocket>,
}

impl UdpServer {
    pub async fn bind(addr: &str) -> std::io::Result<Self> {
        let socket = UdpSocket::bind(addr).await?;
        Ok(Self {
            socket: Arc::new(socket),
        })
    }
    
    pub async fn serve(&self) -> std::io::Result<()> {
        let mut buffer = vec![0u8; 65535];
        
        loop {
            let (len, peer) = self.socket.recv_from(&mut buffer).await?;
            println!("收到来自 {} 的 {} 字节", peer, len);
            
            let socket = self.socket.clone();
            let data = buffer[..len].to_vec();
            
            tokio::spawn(async move {
                // 处理并回复
                if let Err(e) = socket.send_to(&data, peer).await {
                    eprintln!("发送失败: {}", e);
                }
            });
        }
    }
}

/// UDP客户端
pub struct UdpClient {
    socket: UdpSocket,
}

impl UdpClient {
    pub async fn new() -> std::io::Result<Self> {
        let socket = UdpSocket::bind("0.0.0.0:0").await?;
        Ok(Self { socket })
    }
    
    pub async fn send_recv(&self, server: &str, data: &[u8]) -> std::io::Result<Vec<u8>> {
        self.socket.send_to(data, server).await?;
        
        let mut buffer = vec![0u8; 65535];
        let (len, _) = self.socket.recv_from(&mut buffer).await?;
        
        Ok(buffer[..len].to_vec())
    }
}
```

---

## 3. HTTP协议家族

### 3.1 HTTP/1.1

**特性**: 持久连接, 管道化, 分块传输, 缓存控制

```rust
use hyper::{Body, Request, Response, Server, StatusCode};
use hyper::service::{make_service_fn, service_fn};
use std::convert::Infallible;

/// HTTP/1.1服务器
pub async fn http1_server() -> Result<(), Box<dyn std::error::Error>> {
    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, Infallible>(service_fn(handle_request))
    });
    
    let addr = ([127, 0, 0, 1], 3000).into();
    let server = Server::bind(&addr).serve(make_svc);
    
    println!("HTTP/1.1服务器运行在 http://{}", addr);
    server.await?;
    
    Ok(())
}

async fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {
    let response = match (req.method(), req.uri().path()) {
        (&hyper::Method::GET, "/") => {
            Response::new(Body::from("Hello, HTTP/1.1!"))
        }
        (&hyper::Method::POST, "/echo") => {
            let body_bytes = hyper::body::to_bytes(req.into_body()).await.unwrap();
            Response::new(Body::from(body_bytes))
        }
        _ => {
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(Body::from("404 Not Found"))
                .unwrap()
        }
    };
    
    Ok(response)
}
```

### 3.2 HTTP/2

**特性**: 多路复用, 服务器推送, 头部压缩(HPACK), 二进制协议

```rust
use hyper::{Body, Request, Response, Server};
use hyper::server::conn::Http;
use hyper::service::service_fn;
use tokio::net::TcpListener;

/// HTTP/2服务器
pub async fn http2_server() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:3001";
    let listener = TcpListener::bind(addr).await?;
    
    println!("HTTP/2服务器运行在 http://{}", addr);
    
    loop {
        let (stream, _) = listener.accept().await?;
        
        tokio::spawn(async move {
            let service = service_fn(|_req: Request<Body>| async {
                Ok::<_, hyper::Error>(Response::new(Body::from("Hello, HTTP/2!")))
            });
            
            if let Err(e) = Http::new()
                .http2_only(true)
                .serve_connection(stream, service)
                .await
            {
                eprintln!("HTTP/2连接错误: {}", e);
            }
        });
    }
}

/// HTTP/2客户端
use hyper::Client;
use hyper::client::HttpConnector;

pub async fn http2_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let client: Client<HttpConnector, Body> = Client::builder()
        .http2_only(true)
        .build_http();
    
    let uri = "http://127.0.0.1:3001/".parse()?;
    let resp = client.get(uri).await?;
    
    println!("HTTP版本: {:?}", resp.version());
    println!("状态码: {}", resp.status());
    
    let body_bytes = hyper::body::to_bytes(resp.into_body()).await?;
    println!("响应体: {}", String::from_utf8_lossy(&body_bytes));
    
    Ok(())
}
```

### 3.3 HTTP/3 (QUIC)

**特性**: 基于UDP, 0-RTT, 连接迁移, 改进的多路复用

```rust
use quinn::{Endpoint, ServerConfig, ClientConfig, TransportConfig};
use std::sync::Arc;
use rustls::{Certificate, PrivateKey};

/// HTTP/3 (QUIC) 服务器
pub async fn http3_server() -> Result<(), Box<dyn std::error::Error>> {
    // 配置TLS
    let cert = rcgen::generate_simple_self_signed(vec!["localhost".into()])?;
    let cert_der = cert.serialize_der()?;
    let priv_key = cert.serialize_private_key_der();
    
    let cert_chain = vec![Certificate(cert_der)];
    let key = PrivateKey(priv_key);
    
    let mut server_config = quinn::ServerConfig::with_single_cert(cert_chain, key)?;
    
    // 配置传输参数
    let mut transport = TransportConfig::default();
    transport.max_concurrent_bidi_streams(100u32.into());
    transport.max_concurrent_uni_streams(100u32.into());
    server_config.transport = Arc::new(transport);
    
    let endpoint = Endpoint::server(server_config, "127.0.0.1:4433".parse()?)?;
    
    println!("HTTP/3服务器运行在 127.0.0.1:4433");
    
    while let Some(conn) = endpoint.accept().await {
        tokio::spawn(async move {
            match conn.await {
                Ok(new_conn) => {
                    println!("新QUIC连接");
                    handle_quic_connection(new_conn).await;
                }
                Err(e) => eprintln!("连接错误: {}", e),
            }
        });
    }
    
    Ok(())
}

async fn handle_quic_connection(conn: quinn::NewConnection) {
    loop {
        match conn.connection.accept_bi().await {
            Ok((mut send, mut recv)) => {
                let mut data = Vec::new();
                if recv.read_to_end(usize::MAX).await.is_ok() {
                    let response = b"HTTP/3 response\n";
                    let _ = send.write_all(response).await;
                    let _ = send.finish().await;
                }
            }
            Err(_) => break,
        }
    }
}

/// HTTP/3客户端
pub async fn http3_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut roots = rustls::RootCertStore::empty();
    roots.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
        rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
            ta.subject,
            ta.spki,
            ta.name_constraints,
        )
    }));
    
    let mut client_config = ClientConfig::with_root_certificates(roots);
    client_config.alpn_protocols = vec![b"h3".to_vec()];
    
    let mut endpoint = Endpoint::client("0.0.0.0:0".parse()?)?;
    endpoint.set_default_client_config(client_config);
    
    let conn = endpoint.connect("127.0.0.1:4433".parse()?, "localhost")?.await?;
    
    let (mut send, recv) = conn.connection.open_bi().await?;
    send.write_all(b"GET / HTTP/3.0\r\n\r\n").await?;
    send.finish().await?;
    
    let response = recv.read_to_end(usize::MAX).await?;
    println!("HTTP/3响应: {}", String::from_utf8_lossy(&response));
    
    Ok(())
}
```

### 3.4 性能对比

| 特性 | HTTP/1.1 | HTTP/2 | HTTP/3 |
|------|----------|--------|--------|
| 传输协议 | TCP | TCP | UDP (QUIC) |
| 多路复用 | ❌ | ✅ | ✅ |
| 头部压缩 | ❌ | ✅ (HPACK) | ✅ (QPACK) |
| 服务器推送 | ❌ | ✅ | ✅ |
| 连接迁移 | ❌ | ❌ | ✅ |
| 0-RTT | ❌ | ❌ | ✅ |
| 队头阻塞 | ✅ (严重) | ⚠️ (TCP层) | ❌ |
| 平均延迟 | 基线 | -20% | -30% |

---

## 4. WebSocket协议

### 4.1 协议特性

- **全双工通信**: 客户端和服务器可同时发送数据
- **基于TCP**: 通过HTTP升级建立连接
- **低延迟**: 无需HTTP轮询
- **消息帧**: 支持文本和二进制帧

### 4.2 Rust实现：WebSocket服务器

```rust
use tokio_tungstenite::{accept_async, tungstenite::Message};
use tokio::net::{TcpListener, TcpStream};
use futures_util::{StreamExt, SinkExt};

/// WebSocket服务器
pub async fn websocket_server() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:9001").await?;
    println!("WebSocket服务器运行在 ws://127.0.0.1:9001");
    
    while let Ok((stream, addr)) = listener.accept().await {
        println!("新WebSocket连接: {}", addr);
        tokio::spawn(handle_websocket(stream));
    }
    
    Ok(())
}

async fn handle_websocket(stream: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let ws_stream = accept_async(stream).await?;
    let (mut write, mut read) = ws_stream.split();
    
    while let Some(msg) = read.next().await {
        let msg = msg?;
        
        match msg {
            Message::Text(text) => {
                println!("收到文本: {}", text);
                write.send(Message::Text(format!("回显: {}", text))).await?;
            }
            Message::Binary(data) => {
                println!("收到二进制: {} 字节", data.len());
                write.send(Message::Binary(data)).await?;
            }
            Message::Ping(data) => {
                write.send(Message::Pong(data)).await?;
            }
            Message::Close(_) => {
                println!("WebSocket连接关闭");
                break;
            }
            _ => {}
        }
    }
    
    Ok(())
}

/// WebSocket客户端
use tokio_tungstenite::connect_async;

pub async fn websocket_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let url = url::Url::parse("ws://127.0.0.1:9001")?;
    let (mut ws_stream, _) = connect_async(url).await?;
    
    // 发送消息
    ws_stream.send(Message::Text("Hello, WebSocket!".into())).await?;
    
    // 接收响应
    if let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        println!("收到响应: {:?}", msg);
    }
    
    Ok(())
}
```

---

## 5. DNS协议

### 5.1 记录类型

| 记录类型 | 说明 | 示例 |
|----------|------|------|
| A | IPv4地址 | `example.com -> 93.184.216.34` |
| AAAA | IPv6地址 | `example.com -> 2606:2800:220:1:...` |
| CNAME | 规范名称 | `www.example.com -> example.com` |
| MX | 邮件交换 | `example.com -> mail.example.com` |
| TXT | 文本记录 | SPF, DKIM, DMARC |
| NS | 名称服务器 | `example.com -> ns1.example.com` |
| SOA | 授权起始 | 区域配置信息 |
| PTR | 反向DNS | `34.216.184.93.in-addr.arpa -> example.com` |

### 5.2 DNS解析实现

```rust
use hickory_resolver::TokioAsyncResolver;
use hickory_resolver::config::*;

/// DNS解析器
pub struct DnsResolver {
    resolver: TokioAsyncResolver,
}

impl DnsResolver {
    /// 创建系统DNS解析器
    pub async fn from_system() -> Result<Self, Box<dyn std::error::Error>> {
        let resolver = TokioAsyncResolver::tokio_from_system_conf()?;
        Ok(Self { resolver })
    }
    
    /// 创建自定义DNS解析器
    pub async fn from_config(
        nameservers: Vec<NameServerConfig>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let mut config = ResolverConfig::new();
        for ns in nameservers {
            config.add_name_server(ns);
        }
        
        let resolver = TokioAsyncResolver::tokio(config, ResolverOpts::default());
        Ok(Self { resolver })
    }
    
    /// A记录查询
    pub async fn lookup_ipv4(&self, hostname: &str) -> Result<Vec<std::net::Ipv4Addr>, Box<dyn std::error::Error>> {
        let response = self.resolver.ipv4_lookup(hostname).await?;
        Ok(response.iter().collect())
    }
    
    /// AAAA记录查询
    pub async fn lookup_ipv6(&self, hostname: &str) -> Result<Vec<std::net::Ipv6Addr>, Box<dyn std::error::Error>> {
        let response = self.resolver.ipv6_lookup(hostname).await?;
        Ok(response.iter().collect())
    }
    
    /// MX记录查询
    pub async fn lookup_mx(&self, domain: &str) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let response = self.resolver.mx_lookup(domain).await?;
        Ok(response.iter().map(|mx| mx.exchange().to_string()).collect())
    }
    
    /// TXT记录查询
    pub async fn lookup_txt(&self, domain: &str) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let response = self.resolver.txt_lookup(domain).await?;
        Ok(response.iter().map(|txt| txt.to_string()).collect())
    }
    
    /// 反向DNS查询
    pub async fn reverse_lookup(&self, ip: std::net::IpAddr) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let response = self.resolver.reverse_lookup(ip).await?;
        Ok(response.iter().map(|name| name.to_string()).collect())
    }
}

/// DNS查询示例
pub async fn dns_example() -> Result<(), Box<dyn std::error::Error>> {
    let resolver = DnsResolver::from_system().await?;
    
    // A记录
    let ipv4 = resolver.lookup_ipv4("example.com").await?;
    println!("A记录: {:?}", ipv4);
    
    // MX记录
    let mx = resolver.lookup_mx("gmail.com").await?;
    println!("MX记录: {:?}", mx);
    
    // 反向查询
    let names = resolver.reverse_lookup("8.8.8.8".parse()?).await?;
    println!("反向DNS: {:?}", names);
    
    Ok(())
}
```

---

## 6. 应用层协议

### 6.1 gRPC (HTTP/2 + Protobuf)

```rust
// proto文件: hello.proto
// syntax = "proto3";
// package hello;
// service Greeter {
//     rpc SayHello (HelloRequest) returns (HelloReply);
// }
// message HelloRequest { string name = 1; }
// message HelloReply { string message = 1; }

use tonic::{transport::Server, Request, Response, Status};

pub mod hello {
    tonic::include_proto!("hello");
}

use hello::{greeter_server::{Greeter, GreeterServer}, HelloRequest, HelloReply};

#[derive(Default)]
pub struct MyGreeter;

#[tonic::async_trait]
impl Greeter for MyGreeter {
    async fn say_hello(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<HelloReply>, Status> {
        let name = request.into_inner().name;
        let reply = HelloReply {
            message: format!("Hello, {}!", name),
        };
        Ok(Response::new(reply))
    }
}

/// gRPC服务器
pub async fn grpc_server_example() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:50051".parse()?;
    let greeter = MyGreeter::default();
    
    println!("gRPC服务器运行在 {}", addr);
    
    Server::builder()
        .add_service(GreeterServer::new(greeter))
        .serve(addr)
        .await?;
    
    Ok(())
}

/// gRPC客户端
use hello::greeter_client::GreeterClient;

pub async fn grpc_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = GreeterClient::connect("http://127.0.0.1:50051").await?;
    
    let request = tonic::Request::new(HelloRequest {
        name: "Rust".into(),
    });
    
    let response = client.say_hello(request).await?;
    println!("响应: {}", response.into_inner().message);
    
    Ok(())
}
```

### 6.2 MQTT (IoT消息协议)

```rust
use rumqttc::{MqttOptions, AsyncClient, QoS, Event, Packet};

/// MQTT客户端
pub async fn mqtt_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut mqttoptions = MqttOptions::new("rust-client", "127.0.0.1", 1883);
    mqttoptions.set_keep_alive(std::time::Duration::from_secs(5));
    
    let (client, mut eventloop) = AsyncClient::new(mqttoptions, 10);
    
    // 订阅主题
    client.subscribe("sensors/+/temperature", QoS::AtMostOnce).await?;
    
    // 发布消息
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        client.publish("sensors/room1/temperature", QoS::AtLeastOnce, false, "22.5").await.unwrap();
    });
    
    // 接收消息
    while let Ok(notification) = eventloop.poll().await {
        if let Event::Incoming(Packet::Publish(publish)) = notification {
            println!(
                "收到主题 '{}': {}",
                publish.topic,
                String::from_utf8_lossy(&publish.payload)
            );
        }
    }
    
    Ok(())
}
```

### 6.3 GraphQL over HTTP

```rust
use async_graphql::{Schema, Object, EmptyMutation, EmptySubscription};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{Router, Server, routing::post};

struct Query;

#[Object]
impl Query {
    async fn hello(&self, name: String) -> String {
        format!("Hello, {}!", name)
    }
    
    async fn users(&self) -> Vec<User> {
        vec![
            User { id: 1, name: "Alice".into() },
            User { id: 2, name: "Bob".into() },
        ]
    }
}

struct User {
    id: i32,
    name: String,
}

#[Object]
impl User {
    async fn id(&self) -> i32 {
        self.id
    }
    
    async fn name(&self) -> &str {
        &self.name
    }
}

/// GraphQL服务器
pub async fn graphql_server_example() -> Result<(), Box<dyn std::error::Error>> {
    let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();
    
    async fn graphql_handler(
        schema: axum::Extension<Schema<Query, EmptyMutation, EmptySubscription>>,
        req: GraphQLRequest,
    ) -> GraphQLResponse {
        schema.execute(req.into_inner()).await.into()
    }
    
    let app = Router::new()
        .route("/graphql", post(graphql_handler))
        .layer(axum::Extension(schema));
    
    println!("GraphQL服务器运行在 http://127.0.0.1:8000/graphql");
    
    Server::bind(&"127.0.0.1:8000".parse()?)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}
```

---

## 7. 安全协议

### 7.1 TLS/SSL

```rust
use tokio_rustls::{TlsAcceptor, rustls};
use tokio::net::TcpListener;
use std::sync::Arc;
use std::fs;

/// TLS服务器
pub async fn tls_server_example() -> Result<(), Box<dyn std::error::Error>> {
    // 加载证书和私钥
    let cert = fs::read("cert.pem")?;
    let key = fs::read("key.pem")?;
    
    let certs = rustls_pemfile::certs(&mut &cert[..])
        .map(|mut certs| certs.drain(..).map(rustls::Certificate).collect())
        .unwrap();
    
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key[..])
        .map(|mut keys| rustls::PrivateKey(keys.remove(0)))
        .unwrap();
    
    let config = rustls::ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    
    let acceptor = TlsAcceptor::from(Arc::new(config));
    let listener = TcpListener::bind("127.0.0.1:8443").await?;
    
    println!("TLS服务器运行在 https://127.0.0.1:8443");
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = acceptor.clone();
        
        tokio::spawn(async move {
            let stream = acceptor.accept(stream).await;
            match stream {
                Ok(stream) => {
                    println!("TLS连接来自: {}", peer_addr);
                    // 处理TLS连接
                }
                Err(e) => eprintln!("TLS握手失败: {}", e),
            }
        });
    }
}
```

### 7.2 DTLS (Datagram TLS)

DTLS为UDP提供TLS级别的安全性，常用于WebRTC和VoIP。

```rust
// DTLS通常由openssl-dtls或webrtc库实现
// 这里展示概念性接口

pub struct DtlsConnection {
    // 内部实现
}

impl DtlsConnection {
    pub async fn new(remote_addr: std::net::SocketAddr) -> Result<Self, Box<dyn std::error::Error>> {
        // 建立DTLS连接
        todo!()
    }
    
    pub async fn send(&self, data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
        // 加密并发送数据
        todo!()
    }
    
    pub async fn recv(&self, buffer: &mut [u8]) -> Result<usize, Box<dyn std::error::Error>> {
        // 接收并解密数据
        todo!()
    }
}
```

---

## 8. P2P协议

### 8.1 libp2p协议栈

```rust
use libp2p::{
    identity, ping, noise, tcp, yamux, Multiaddr, PeerId, Swarm, Transport,
    swarm::{NetworkBehaviour, SwarmEvent}
};
use std::error::Error;

/// P2P节点行为
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "MyBehaviourEvent")]
struct MyBehaviour {
    ping: ping::Behaviour,
}

#[derive(Debug)]
enum MyBehaviourEvent {
    Ping(ping::Event),
}

impl From<ping::Event> for MyBehaviourEvent {
    fn from(event: ping::Event) -> Self {
        MyBehaviourEvent::Ping(event)
    }
}

/// P2P节点示例
pub async fn p2p_node_example() -> Result<(), Box<dyn Error>> {
    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    
    println!("本地节点ID: {}", local_peer_id);
    
    let transport = tcp::tokio::Transport::new(tcp::Config::default())
        .upgrade(libp2p::core::upgrade::Version::V1)
        .authenticate(noise::NoiseAuthenticated::xx(&local_key).unwrap())
        .multiplex(yamux::YamuxConfig::default())
        .boxed();
    
    let behaviour = MyBehaviour {
        ping: ping::Behaviour::new(ping::Config::new()),
    };
    
    let mut swarm = Swarm::new(transport, behaviour, local_peer_id);
    
    // 监听地址
    swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;
    
    loop {
        match swarm.select_next_some().await {
            SwarmEvent::NewListenAddr { address, .. } => {
                println!("监听地址: {}", address);
            }
            SwarmEvent::Behaviour(MyBehaviourEvent::Ping(event)) => {
                println!("Ping事件: {:?}", event);
            }
            _ => {}
        }
    }
}
```

---

## 9. 实时通信协议

### 9.1 WebRTC

WebRTC是实时音视频通信的标准，涉及多个协议：

- **STUN/TURN**: NAT穿透
- **ICE**: 连接建立
- **DTLS**: 安全层
- **SRTP**: 加密的RTP
- **SCTP**: 数据通道

```rust
use webrtc::{
    api::APIBuilder,
    peer_connection::configuration::RTCConfiguration,
    peer_connection::peer_connection_state::RTCPeerConnectionState,
    ice_transport::ice_server::RTCIceServer,
};

/// WebRTC示例
pub async fn webrtc_example() -> Result<(), Box<dyn std::error::Error>> {
    let config = RTCConfiguration {
        ice_servers: vec![RTCIceServer {
            urls: vec!["stun:stun.l.google.com:19302".to_owned()],
            ..Default::default()
        }],
        ..Default::default()
    };
    
    let api = APIBuilder::new().build();
    let peer_connection = api.new_peer_connection(config).await?;
    
    // 监听连接状态
    peer_connection.on_peer_connection_state_change(Box::new(move |state: RTCPeerConnectionState| {
        println!("连接状态: {:?}", state);
        Box::pin(async {})
    }));
    
    // 创建Offer
    let offer = peer_connection.create_offer(None).await?;
    peer_connection.set_local_description(offer).await?;
    
    println!("WebRTC Offer创建成功");
    
    Ok(())
}
```

### 9.2 RTP/RTCP

```rust
/// RTP包结构
pub struct RtpPacket {
    pub version: u8,
    pub padding: bool,
    pub extension: bool,
    pub csrc_count: u8,
    pub marker: bool,
    pub payload_type: u8,
    pub sequence_number: u16,
    pub timestamp: u32,
    pub ssrc: u32,
    pub payload: Vec<u8>,
}

impl RtpPacket {
    pub fn parse(data: &[u8]) -> Result<Self, String> {
        if data.len() < 12 {
            return Err("RTP包太小".into());
        }
        
        let version = (data[0] >> 6) & 0x03;
        let padding = (data[0] & 0x20) != 0;
        let extension = (data[0] & 0x10) != 0;
        let csrc_count = data[0] & 0x0F;
        let marker = (data[1] & 0x80) != 0;
        let payload_type = data[1] & 0x7F;
        
        let sequence_number = u16::from_be_bytes([data[2], data[3]]);
        let timestamp = u32::from_be_bytes([data[4], data[5], data[6], data[7]]);
        let ssrc = u32::from_be_bytes([data[8], data[9], data[10], data[11]]);
        
        let payload = data[12..].to_vec();
        
        Ok(Self {
            version,
            padding,
            extension,
            csrc_count,
            marker,
            payload_type,
            sequence_number,
            timestamp,
            ssrc,
            payload,
        })
    }
    
    pub fn serialize(&self) -> Vec<u8> {
        let mut buffer = Vec::with_capacity(12 + self.payload.len());
        
        let byte0 = (self.version << 6) | ((self.padding as u8) << 5) | ((self.extension as u8) << 4) | self.csrc_count;
        let byte1 = ((self.marker as u8) << 7) | self.payload_type;
        
        buffer.push(byte0);
        buffer.push(byte1);
        buffer.extend_from_slice(&self.sequence_number.to_be_bytes());
        buffer.extend_from_slice(&self.timestamp.to_be_bytes());
        buffer.extend_from_slice(&self.ssrc.to_be_bytes());
        buffer.extend_from_slice(&self.payload);
        
        buffer
    }
}
```

---

## 10. 协议选择决策树

```text
需求分析
├─ 实时性要求？
│  ├─ 是（低延迟）
│  │  ├─ 音视频通信 → WebRTC
│  │  ├─ 游戏数据 → UDP + 自定义协议 或 QUIC
│  │  └─ 金融数据 → WebSocket 或 gRPC Stream
│  └─ 否（可容忍延迟）
│     ├─ REST API → HTTP/1.1 或 HTTP/2
│     └─ 批量数据 → HTTP/2 或 gRPC
├─ 可靠性要求？
│  ├─ 高（不能丢包） → TCP, QUIC
│  └─ 中（可接受丢包） → UDP
├─ 双向通信？
│  ├─ 是 → WebSocket, gRPC Bidirectional Stream, QUIC
│  └─ 否 → HTTP, UDP单向
├─ 消息模型？
│  ├─ Request-Response → HTTP, gRPC Unary
│  ├─ Publish-Subscribe → MQTT, WebSocket
│  └─ Streaming → gRPC Stream, WebSocket
└─ 环境限制？
   ├─ 浏览器 → HTTP, WebSocket, WebRTC
   ├─ IoT → MQTT, CoAP, QUIC
   └─ 微服务 → gRPC, HTTP/2
```

---

## 11. Rust生态协议库对比

| 协议 | 推荐库 | 成熟度 | 特性 |
|------|--------|--------|------|
| TCP/UDP | `tokio::net`, `async-std` | ⭐⭐⭐⭐⭐ | 标准库，异步支持 |
| HTTP/1.1 | `hyper`, `reqwest` | ⭐⭐⭐⭐⭐ | 高性能，生产就绪 |
| HTTP/2 | `hyper`, `h2` | ⭐⭐⭐⭐⭐ | 多路复用，服务器推送 |
| HTTP/3 | `quinn`, `h3` | ⭐⭐⭐⭐ | QUIC实现，稳定中 |
| WebSocket | `tokio-tungstenite`, `tungstenite` | ⭐⭐⭐⭐⭐ | 完整实现 |
| gRPC | `tonic`, `grpc-rs` | ⭐⭐⭐⭐⭐ | 异步，编译时类型安全 |
| MQTT | `rumqttc`, `paho-mqtt` | ⭐⭐⭐⭐ | MQTT 3.1.1/5.0支持 |
| DNS | `hickory-dns`, `trust-dns` | ⭐⭐⭐⭐⭐ | DoH/DoT支持 |
| TLS | `rustls`, `native-tls` | ⭐⭐⭐⭐⭐ | 纯Rust或系统库 |
| QUIC | `quinn`, `quiche` | ⭐⭐⭐⭐ | HTTP/3基础 |
| P2P | `libp2p` | ⭐⭐⭐⭐ | 完整P2P栈 |
| WebRTC | `webrtc-rs` | ⭐⭐⭐⭐ | 媒体通信 |
| GraphQL | `async-graphql`, `juniper` | ⭐⭐⭐⭐ | 类型安全 |

---

## 12. 协议测试与验证

```rust
use tokio::time::{sleep, Duration};

/// 协议性能测试框架
pub struct ProtocolBenchmark {
    name: String,
}

impl ProtocolBenchmark {
    pub fn new(name: impl Into<String>) -> Self {
        Self { name: name.into() }
    }
    
    /// 延迟测试
    pub async fn measure_latency<F, Fut>(&self, mut operation: F, iterations: usize) -> Duration
    where
        F: FnMut() -> Fut,
        Fut: std::future::Future<Output = ()>,
    {
        let start = std::time::Instant::now();
        
        for _ in 0..iterations {
            operation().await;
        }
        
        let elapsed = start.elapsed();
        println!("[{}] 延迟: {:?} (平均 {:?})", 
            self.name, 
            elapsed, 
            elapsed / iterations as u32
        );
        
        elapsed / iterations as u32
    }
    
    /// 吞吐量测试
    pub async fn measure_throughput<F, Fut>(&self, mut operation: F, data_size: usize, duration_secs: u64) -> f64
    where
        F: FnMut() -> Fut,
        Fut: std::future::Future<Output = ()>,
    {
        let start = std::time::Instant::now();
        let mut bytes_transferred = 0;
        
        while start.elapsed().as_secs() < duration_secs {
            operation().await;
            bytes_transferred += data_size;
        }
        
        let elapsed = start.elapsed().as_secs_f64();
        let throughput_mbps = (bytes_transferred as f64 * 8.0) / (elapsed * 1_000_000.0);
        
        println!("[{}] 吞吐量: {:.2} Mbps", self.name, throughput_mbps);
        
        throughput_mbps
    }
}

/// 协议对比测试
pub async fn protocol_comparison() {
    // HTTP/1.1 vs HTTP/2 vs HTTP/3
    let http1_bench = ProtocolBenchmark::new("HTTP/1.1");
    let http2_bench = ProtocolBenchmark::new("HTTP/2");
    let http3_bench = ProtocolBenchmark::new("HTTP/3");
    
    // 模拟请求
    let http1_latency = http1_bench.measure_latency(|| async { sleep(Duration::from_millis(10)).await }, 100).await;
    let http2_latency = http2_bench.measure_latency(|| async { sleep(Duration::from_millis(8)).await }, 100).await;
    let http3_latency = http3_bench.measure_latency(|| async { sleep(Duration::from_millis(7)).await }, 100).await;
    
    println!("\n协议延迟对比:");
    println!("HTTP/1.1: {:?}", http1_latency);
    println!("HTTP/2:   {:?} (改进 {:.1}%)", http2_latency, (http1_latency.as_nanos() as f64 - http2_latency.as_nanos() as f64) / http1_latency.as_nanos() as f64 * 100.0);
    println!("HTTP/3:   {:?} (改进 {:.1}%)", http3_latency, (http1_latency.as_nanos() as f64 - http3_latency.as_nanos() as f64) / http1_latency.as_nanos() as f64 * 100.0);
}
```

---

## 13. 最佳实践

### ✅ 协议选择原则

1. **优先使用高层协议**: 除非有特殊需求，避免直接操作TCP/UDP
2. **考虑生态成熟度**: 选择社区支持活跃的库
3. **类型安全优先**: 使用编译时类型检查的库（如Tonic）
4. **异步优先**: 网络I/O密集场景优先选择async库

### ⚠️ 常见陷阱

1. **忽略背压**: 生产者速度超过消费者时缺乏流控
2. **错误处理不足**: 网络错误必须妥善处理和重试
3. **超时配置缺失**: 所有网络操作都应设置合理超时
4. **缓冲区管理**: 避免无限增长的缓冲区

### 🔧 性能优化技巧

```rust
/// 连接池管理
use deadpool::managed::{Manager, Pool, RecycleResult};

struct TcpConnectionManager {
    addr: String,
}

#[async_trait::async_trait]
impl Manager for TcpConnectionManager {
    type Type = tokio::net::TcpStream;
    type Error = std::io::Error;
    
    async fn create(&self) -> Result<Self::Type, Self::Error> {
        tokio::net::TcpStream::connect(&self.addr).await
    }
    
    async fn recycle(&self, conn: &mut Self::Type) -> RecycleResult<Self::Error> {
        // 检查连接是否仍然有效
        Ok(())
    }
}

/// 使用连接池
pub async fn connection_pool_example() -> Result<(), Box<dyn std::error::Error>> {
    let manager = TcpConnectionManager {
        addr: "127.0.0.1:8080".into(),
    };
    
    let pool = Pool::builder(manager).max_size(10).build()?;
    
    let conn = pool.get().await?;
    // 使用连接
    
    Ok(())
}
```

---

**文档完成**: 此参考文档涵盖了Rust 1.90网络编程中的主要协议分类、实现方式和最佳实践。建议结合实际场景选择合适的协议和库。

**下一步**: 查看 [02_网络库对比选择.md](./02_网络库对比选择.md) 深入了解各库的优劣。
