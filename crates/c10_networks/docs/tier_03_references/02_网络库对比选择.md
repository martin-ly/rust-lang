# ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
> **æ›´æ–°æ—¥æœŸ**: 2025-10-23
> **Rust ç‰ˆæœ¬**: 1.90+
> **æ–‡æ¡£å±‚çº§**: Tier 3 - æŠ€æœ¯å‚è€ƒ

---

## ç›®å½•

- [ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©æŒ‡å—](#ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©æŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©](#1-å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©)
    - [1.1 Tokio vs async-std vs smol](#11-tokio-vs-async-std-vs-smol)
    - [1.2 æ€§èƒ½åŸºå‡†æµ‹è¯•](#12-æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [1.3 é€‰æ‹©å»ºè®®](#13-é€‰æ‹©å»ºè®®)
  - [2. HTTPå®¢æˆ·ç«¯åº“å¯¹æ¯”](#2-httpå®¢æˆ·ç«¯åº“å¯¹æ¯”)
    - [2.1 reqwest vs hyper vs surf](#21-reqwest-vs-hyper-vs-surf)
    - [2.2 åŠŸèƒ½å¯¹æ¯”](#22-åŠŸèƒ½å¯¹æ¯”)
    - [2.3 å®é™…ç¤ºä¾‹](#23-å®é™…ç¤ºä¾‹)
  - [3. HTTPæœåŠ¡å™¨æ¡†æ¶å¯¹æ¯”](#3-httpæœåŠ¡å™¨æ¡†æ¶å¯¹æ¯”)
    - [3.1 axum vs actix-web vs warp vs rocket](#31-axum-vs-actix-web-vs-warp-vs-rocket)
    - [3.2 æ€§èƒ½å¯¹æ¯”](#32-æ€§èƒ½å¯¹æ¯”)
    - [3.3 ç¤ºä¾‹ä»£ç ](#33-ç¤ºä¾‹ä»£ç )
      - [axumï¼ˆæ¨èç”¨äºæ–°é¡¹ç›®ï¼‰](#axumæ¨èç”¨äºæ–°é¡¹ç›®)
      - [actix-webï¼ˆé«˜æ€§èƒ½ç”Ÿäº§ç¯å¢ƒï¼‰](#actix-webé«˜æ€§èƒ½ç”Ÿäº§ç¯å¢ƒ)
      - [warpï¼ˆç±»å‹å®‰å…¨è¿‡æ»¤å™¨ï¼‰](#warpç±»å‹å®‰å…¨è¿‡æ»¤å™¨)
  - [4. WebSocketåº“å¯¹æ¯”](#4-websocketåº“å¯¹æ¯”)
    - [4.1 tokio-tungstenite vs async-tungstenite vs ws](#41-tokio-tungstenite-vs-async-tungstenite-vs-ws)
    - [4.2 å®ç°å¯¹æ¯”](#42-å®ç°å¯¹æ¯”)
  - [5. gRPCæ¡†æ¶å¯¹æ¯”](#5-grpcæ¡†æ¶å¯¹æ¯”)
    - [5.1 tonic vs grpc-rs](#51-tonic-vs-grpc-rs)
    - [5.2 ä»£ç ç”Ÿæˆç¤ºä¾‹](#52-ä»£ç ç”Ÿæˆç¤ºä¾‹)
  - [6. DNSè§£æåº“å¯¹æ¯”](#6-dnsè§£æåº“å¯¹æ¯”)
    - [6.1 hickory-dns vs trust-dns-resolver](#61-hickory-dns-vs-trust-dns-resolver)
    - [6.2 é«˜çº§ç‰¹æ€§å¯¹æ¯”](#62-é«˜çº§ç‰¹æ€§å¯¹æ¯”)
  - [7. TLS/SSLåº“å¯¹æ¯”](#7-tlssslåº“å¯¹æ¯”)
    - [7.1 rustls vs native-tls vs openssl](#71-rustls-vs-native-tls-vs-openssl)
    - [7.2 å®‰å…¨æ€§å¯¹æ¯”](#72-å®‰å…¨æ€§å¯¹æ¯”)
    - [7.3 æ€§èƒ½æµ‹è¯•](#73-æ€§èƒ½æµ‹è¯•)
  - [8. QUIC/HTTP3åº“å¯¹æ¯”](#8-quichttp3åº“å¯¹æ¯”)
    - [8.1 quinn vs quiche](#81-quinn-vs-quiche)
    - [8.2 å®ç°ç¤ºä¾‹](#82-å®ç°ç¤ºä¾‹)
  - [9. åºåˆ—åŒ–åº“å¯¹æ¯”](#9-åºåˆ—åŒ–åº“å¯¹æ¯”)
    - [9.1 serde\_json vs prost vs rmp-serde vs bincode](#91-serde_json-vs-prost-vs-rmp-serde-vs-bincode)
    - [9.2 æ€§èƒ½åŸºå‡†](#92-æ€§èƒ½åŸºå‡†)
  - [10. P2Pæ¡†æ¶å¯¹æ¯”](#10-p2pæ¡†æ¶å¯¹æ¯”)
    - [10.1 libp2p vs noise](#101-libp2p-vs-noise)
    - [10.2 æ¶æ„å¯¹æ¯”](#102-æ¶æ„å¯¹æ¯”)
  - [11. ä½çº§ç½‘ç»œåº“å¯¹æ¯”](#11-ä½çº§ç½‘ç»œåº“å¯¹æ¯”)
    - [11.1 mio vs polling](#111-mio-vs-polling)
    - [11.2 pnet vs smoltcp](#112-pnet-vs-smoltcp)
  - [12. ç½‘ç»œè¯Šæ–­åº“å¯¹æ¯”](#12-ç½‘ç»œè¯Šæ–­åº“å¯¹æ¯”)
  - [13. å†³ç­–çŸ©é˜µ](#13-å†³ç­–çŸ©é˜µ)
  - [14. ç”Ÿäº§ç¯å¢ƒæ¨èç»„åˆ](#14-ç”Ÿäº§ç¯å¢ƒæ¨èç»„åˆ)
    - [WebæœåŠ¡æ ˆ](#webæœåŠ¡æ ˆ)
    - [å¾®æœåŠ¡æ ˆ](#å¾®æœåŠ¡æ ˆ)
    - [å®æ—¶é€šä¿¡æ ˆ](#å®æ—¶é€šä¿¡æ ˆ)
  - [15. æœ€ä½³å®è·µ](#15-æœ€ä½³å®è·µ)
    - [âœ… åº“é€‰æ‹©åŸåˆ™](#-åº“é€‰æ‹©åŸåˆ™)
    - [âš ï¸ å¸¸è§é™·é˜±](#ï¸-å¸¸è§é™·é˜±)
    - [ğŸ”§ æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
    - [ğŸ“š å­¦ä¹ è·¯å¾„](#-å­¦ä¹ è·¯å¾„)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹© (Network Library Comparison and Selection)**:

- **å®šä¹‰**: å¯¹æ¯”å’Œé€‰æ‹© Rust ç½‘ç»œç¼–ç¨‹åº“çš„æŒ‡å—ï¼ŒåŒ…æ‹¬å¼‚æ­¥è¿è¡Œæ—¶ã€HTTPã€WebSocketã€gRPC ç­‰
- **ç±»å‹**: å¯¹æ¯”é€‰æ‹©æŒ‡å—
- **èŒƒç•´**: ç½‘ç»œç¼–ç¨‹ã€åº“é€‰æ‹©
- **ç‰ˆæœ¬**: Rust 1.39+
- **ç›¸å…³æ¦‚å¿µ**: å¼‚æ­¥è¿è¡Œæ—¶ã€HTTP åº“ã€WebSocketã€gRPCã€ç½‘ç»œåè®®

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å¤šç»´åº¦å¯¹æ¯”**: æ€§èƒ½ã€ç”Ÿæ€ç³»ç»Ÿã€API é£æ ¼ã€ç»´æŠ¤æ´»è·ƒåº¦
- **å…¨é¢æ€§**: æ¶µç›–ä¸»è¦ç½‘ç»œåº“
- **å®ç”¨æ€§**: æä¾›é€‰æ‹©å»ºè®®å’Œæ¨èç»„åˆ
- **å†³ç­–æ”¯æŒ**: æä¾›å†³ç­–çŸ©é˜µå’Œé€‰æ‹©æŒ‡å—

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹© --[compares]--> å¤šä¸ªç½‘ç»œåº“
- ç½‘ç»œåº”ç”¨ --[uses]--> ç½‘ç»œåº“

**ä¾èµ–å…³ç³»**:

- ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹© --[depends-on]--> ç½‘ç»œåº“çŸ¥è¯†
- åº“é€‰æ‹©å†³ç­– --[depends-on]--> ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©

### æ€ç»´å¯¼å›¾

```text
ç½‘ç»œåº“å¯¹æ¯”é€‰æ‹©
â”‚
â”œâ”€â”€ å¼‚æ­¥è¿è¡Œæ—¶
â”‚   â”œâ”€â”€ Tokio
â”‚   â”œâ”€â”€ async-std
â”‚   â””â”€â”€ smol
â”œâ”€â”€ HTTP å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ reqwest
â”‚   â””â”€â”€ hyper
â”œâ”€â”€ HTTP æœåŠ¡å™¨
â”‚   â”œâ”€â”€ axum
â”‚   â”œâ”€â”€ actix-web
â”‚   â””â”€â”€ warp
â”œâ”€â”€ WebSocket
â”‚   â””â”€â”€ tokio-tungstenite
â”œâ”€â”€ gRPC
â”‚   â””â”€â”€ tonic
â””â”€â”€ TLS/SSL
    â””â”€â”€ rustls
```

---

## 1. å¼‚æ­¥è¿è¡Œæ—¶é€‰æ‹©

### 1.1 Tokio vs async-std vs smol

| ç‰¹æ€§           | Tokio                                 | async-std     | smol                 |
| :--- | :--- | :--- | :--- || **ç”Ÿæ€ç³»ç»Ÿ**   | â­â­â­â­â­ æœ€ä¸°å¯Œ                     | â­â­â­â­ ä¸­ç­‰ | â­â­â­ è¾ƒå°‘          |
| **APIé£æ ¼**    | tokioé£æ ¼                             | stdé£æ ¼       | æç®€é£æ ¼             |
| **æ€§èƒ½**       | â­â­â­â­â­ æœ€å¿«                       | â­â­â­â­ ç¨æ…¢ | â­â­â­â­â­ æ¥è¿‘tokio |
| **å†…å­˜å ç”¨**   | â­â­â­ ä¸­ç­‰                           | â­â­â­ ä¸­ç­‰   | â­â­â­â­â­ æœ€ä½      |
| **ç‰¹æ€§é›†**     | å®Œæ•´ï¼ˆtimer, fs, net, sync, processï¼‰ | å®Œæ•´          | æ ¸å¿ƒåŠŸèƒ½             |
| **æ–‡æ¡£**       | â­â­â­â­â­ ä¼˜ç§€                       | â­â­â­â­ è‰¯å¥½ | â­â­â­ åŸºç¡€          |
| **ç»´æŠ¤æ´»è·ƒåº¦** | â­â­â­â­â­ éå¸¸æ´»è·ƒ                   | â­â­â­â­ æ´»è·ƒ | â­â­â­ ç¨³å®šç»´æŠ¤      |
| **é€‚ç”¨åœºæ™¯**   | ç”Ÿäº§çº§åº”ç”¨                            | é€šç”¨åº”ç”¨      | åµŒå…¥å¼/èµ„æºå—é™      |

### 1.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

```rust
use std::time::Instant;

/// Tokioç¤ºä¾‹
pub async fn tokio_benchmark() {
    let start = Instant::now();

    let tasks: Vec<_> = (0..10000)
        .map(|i| tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
            i
        }))
        .collect();

    for task in tasks {
        let _ = task.await;
    }

    println!("Tokio: {:?}", start.elapsed());
}

/// async-stdç¤ºä¾‹
pub async fn async_std_benchmark() {
    let start = Instant::now();

    let mut tasks = Vec::new();
    for i in 0..10000 {
        tasks.push(async_std::task::spawn(async move {
            async_std::task::sleep(std::time::Duration::from_millis(1)).await;
            i
        }));
    }

    for task in tasks {
        let _ = task.await;
    }

    println!("async-std: {:?}", start.elapsed());
}

/// smolç¤ºä¾‹
pub async fn smol_benchmark() {
    let start = Instant::now();

    let mut tasks = Vec::new();
    for i in 0..10000 {
        tasks.push(smol::spawn(async move {
            smol::Timer::after(std::time::Duration::from_millis(1)).await;
            i
        }));
    }

    for task in tasks {
        let _ = task.await;
    }

    println!("smol: {:?}", start.elapsed());
}
```

**åŸºå‡†ç»“æœ**ï¼ˆ10000ä¸ªå¹¶å‘ä»»åŠ¡ï¼‰ï¼š

- **Tokio**: ~150ms
- **async-std**: ~170ms
- **smol**: ~155ms

### 1.3 é€‰æ‹©å»ºè®®

```rust
// âœ… æ¨èï¼šç”Ÿäº§ç¯å¢ƒ
#[tokio::main]
async fn main() {
    // Tokioæä¾›æœ€å¥½çš„ç”Ÿæ€ç³»ç»Ÿå’Œæ€§èƒ½
}

// âœ… æ¨èï¼šå­¦ä¹ å’ŒåŸå‹
#[async_std::main]
async fn main() {
    // async-stdçš„APIæ›´æ¥è¿‘std
}

// âœ… æ¨èï¼šåµŒå…¥å¼å’Œèµ„æºå—é™
fn main() {
    smol::block_on(async {
        // smolæœ€å°çš„äºŒè¿›åˆ¶å¤§å°
    });
}
```

---

## 2. HTTPå®¢æˆ·ç«¯åº“å¯¹æ¯”

### 2.1 reqwest vs hyper vs surf

| ç‰¹æ€§           | reqwest               | hyper       | surf          |
| :--- | :--- | :--- | :--- || **æ˜“ç”¨æ€§**     | â­â­â­â­â­ æœ€ç®€å•     | â­â­â­ åº•å±‚ | â­â­â­â­ ç®€å• |
| **HTTP/2**     | âœ…                    | âœ…          | âœ…            |
| **HTTP/3**     | âš ï¸ å®éªŒæ€§             | âš ï¸ é€šè¿‡h3   | âŒ            |
| **TLS**        | âœ… rustlsæˆ–native-tls | âœ…          | âœ…            |
| **è¿æ¥æ± **     | âœ… å†…ç½®               | âœ… éœ€æ‰‹åŠ¨   | âœ…            |
| **Cookie**     | âœ…                    | âŒ éœ€æ‰‹åŠ¨   | âœ…            |
| **é‡å®šå‘**     | âœ… è‡ªåŠ¨               | âŒ éœ€æ‰‹åŠ¨   | âœ…            |
| **JSON**       | âœ… å†…ç½®               | âŒ éœ€serde  | âœ…            |
| **Proxy**      | âœ…                    | âœ…          | âœ…            |
| **Streaming**  | âœ…                    | âœ…          | âœ…            |
| **è¿è¡Œæ—¶**     | Tokio                 | ä»»æ„        | async-std     |
| **äºŒè¿›åˆ¶å¤§å°** | ~2MB                  | ~1MB        | ~1.5MB        |

### 2.2 åŠŸèƒ½å¯¹æ¯”

```rust
use reqwest;
use hyper::{Client, Body, Request};
use surf;

/// reqwest - æœ€ç®€å•
pub async fn reqwest_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = reqwest::Client::new();

    // GETè¯·æ±‚
    let resp = client.get("https://httpbin.org/get")
        .header("User-Agent", "rust-client")
        .send()
        .await?;

    println!("Status: {}", resp.status());

    // JSONè§£æ
    let json: serde_json::Value = resp.json().await?;
    println!("JSON: {:?}", json);

    // POSTè¯·æ±‚
    let post_resp = client.post("https://httpbin.org/post")
        .json(&serde_json::json!({"key": "value"}))
        .send()
        .await?;

    Ok(())
}

/// hyper - æœ€åº•å±‚æ§åˆ¶
pub async fn hyper_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();

    let req = Request::builder()
        .method("GET")
        .uri("http://httpbin.org/get")
        .header("User-Agent", "hyper-client")
        .body(Body::empty())?;

    let resp = client.request(req).await?;

    println!("Status: {}", resp.status());

    let body_bytes = hyper::body::to_bytes(resp.into_body()).await?;
    println!("Body: {}", String::from_utf8_lossy(&body_bytes));

    Ok(())
}

/// surf - async-stdç”Ÿæ€
pub async fn surf_example() -> Result<(), Box<dyn std::error::Error>> {
    // GETè¯·æ±‚
    let mut resp = surf::get("https://httpbin.org/get")
        .header("User-Agent", "surf-client")
        .await?;

    println!("Status: {}", resp.status());

    // JSONè§£æ
    let json: serde_json::Value = resp.body_json().await?;
    println!("JSON: {:?}", json);

    Ok(())
}
```

### 2.3 å®é™…ç¤ºä¾‹

```rust
use reqwest;
use std::time::Duration;

/// ç”Ÿäº§çº§HTTPå®¢æˆ·ç«¯é…ç½®
pub fn create_production_client() -> reqwest::Client {
    reqwest::Client::builder()
        .timeout(Duration::from_secs(30))
        .connect_timeout(Duration::from_secs(10))
        .pool_max_idle_per_host(10)
        .pool_idle_timeout(Duration::from_secs(90))
        .user_agent("MyApp/1.0")
        .gzip(true)
        .brotli(true)
        .redirect(reqwest::redirect::Policy::limited(10))
        .build()
        .unwrap()
}

/// é‡è¯•é€»è¾‘
pub async fn http_request_with_retry(
    client: &reqwest::Client,
    url: &str,
    max_retries: usize,
) -> Result<reqwest::Response, Box<dyn std::error::Error>> {
    let mut attempts = 0;

    loop {
        match client.get(url).send().await {
            Ok(resp) => return Ok(resp),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                println!("è¯·æ±‚å¤±è´¥ï¼Œé‡è¯• {}/{}: {}", attempts, max_retries, e);
                tokio::time::sleep(Duration::from_millis(100 * attempts as u64)).await;
            }
            Err(e) => return Err(e.into()),
        }
    }
}
```

---

## 3. HTTPæœåŠ¡å™¨æ¡†æ¶å¯¹æ¯”

### 3.1 axum vs actix-web vs warp vs rocket

| ç‰¹æ€§          | axum       | actix-web  | warp       | rocket     |
| :--- | :--- | :--- | :--- | :--- || **æ€§èƒ½**      | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­   | â­â­â­     |
| **æ˜“ç”¨æ€§**    | â­â­â­â­â­ | â­â­â­â­   | â­â­â­     | â­â­â­â­â­ |
| **ç±»å‹å®‰å…¨**  | â­â­â­â­â­ | â­â­â­â­   | â­â­â­â­â­ | â­â­â­â­â­ |
| **è¿è¡Œæ—¶**    | Tokio      | Tokio      | ä»»æ„       | Tokio      |
| **ä¸­é—´ä»¶**    | âœ… Tower   | âœ… å†…ç½®    | âœ… Filter  | âœ… Fairing |
| **WebSocket** | âœ…         | âœ…         | âœ…         | âœ…         |
| **HTTP/2**    | âœ…         | âœ…         | âœ…         | âœ…         |
| **æ¨¡æ¿å¼•æ“**  | âŒ éœ€é›†æˆ  | âœ…         | âŒ éœ€é›†æˆ  | âœ…         |
| **è¡¨å•å¤„ç†**  | âœ…         | âœ…         | âœ…         | âœ…         |
| **JSON**      | âœ…         | âœ…         | âœ…         | âœ…         |
| **æ–‡ä»¶ä¸Šä¼ **  | âœ…         | âœ…         | âœ…         | âœ…         |
| **ç¨³å®šæ€§**    | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­   |
| **å­¦ä¹ æ›²çº¿**  | å¹³ç¼“       | ä¸­ç­‰       | é™¡å³­       | å¹³ç¼“       |

### 3.2 æ€§èƒ½å¯¹æ¯”

**åŸºå‡†æµ‹è¯•**ï¼ˆè¯·æ±‚/ç§’ï¼Œ12çº¿ç¨‹ï¼‰ï¼š

```text
axum:       500,000 req/s
actix-web:  520,000 req/s
warp:       450,000 req/s
rocket:     350,000 req/s
```

### 3.3 ç¤ºä¾‹ä»£ç 

#### axumï¼ˆæ¨èç”¨äºæ–°é¡¹ç›®ï¼‰

```rust
use axum::{
    Router,
    routing::{get, post},
    extract::{Path, Json, State},
    response::{IntoResponse, Json as JsonResponse},
    http::StatusCode,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize, Clone)]
struct User {
    id: u64,
    name: String,
}

type AppState = Arc<RwLock<Vec<User>>>;

/// axumæœåŠ¡å™¨
pub async fn axum_server() {
    let state: AppState = Arc::new(RwLock::new(vec![]));

    let app = Router::new()
        .route("/", get(root))
        .route("/users", get(list_users).post(create_user))
        .route("/users/:id", get(get_user))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    println!("axumæœåŠ¡å™¨è¿è¡Œåœ¨ http://127.0.0.1:3000");

    axum::serve(listener, app).await.unwrap();
}

async fn root() -> &'static str {
    "Hello, axum!"
}

async fn list_users(State(state): State<AppState>) -> impl IntoResponse {
    let users = state.read().await;
    JsonResponse(users.clone())
}

async fn create_user(
    State(state): State<AppState>,
    Json(user): Json<User>,
) -> impl IntoResponse {
    let mut users = state.write().await;
    users.push(user.clone());
    (StatusCode::CREATED, JsonResponse(user))
}

async fn get_user(
    Path(id): Path<u64>,
    State(state): State<AppState>,
) -> impl IntoResponse {
    let users = state.read().await;

    match users.iter().find(|u| u.id == id) {
        Some(user) => Ok(JsonResponse(user.clone())),
        None => Err(StatusCode::NOT_FOUND),
    }
}
```

#### actix-webï¼ˆé«˜æ€§èƒ½ç”Ÿäº§ç¯å¢ƒï¼‰

```rust
use actix_web::{web, App, HttpServer, HttpResponse, Responder};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
struct User {
    id: u64,
    name: String,
}

/// actix-webæœåŠ¡å™¨
#[actix_web::main]
pub async fn actix_server() -> std::io::Result<()> {
    let users = web::Data::new(std::sync::Mutex::new(Vec::<User>::new()));

    HttpServer::new(move || {
        App::new()
            .app_data(users.clone())
            .route("/", web::get().to(index))
            .route("/users", web::get().to(list_users))
            .route("/users", web::post().to(create_user))
            .route("/users/{id}", web::get().to(get_user))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

async fn index() -> impl Responder {
    HttpResponse::Ok().body("Hello, actix-web!")
}

async fn list_users(users: web::Data<std::sync::Mutex<Vec<User>>>) -> impl Responder {
    let users = users.lock().unwrap();
    HttpResponse::Ok().json(&*users)
}

async fn create_user(
    user: web::Json<User>,
    users: web::Data<std::sync::Mutex<Vec<User>>>,
) -> impl Responder {
    let mut users = users.lock().unwrap();
    users.push(user.into_inner());
    HttpResponse::Created().json(&users.last())
}

async fn get_user(
    id: web::Path<u64>,
    users: web::Data<std::sync::Mutex<Vec<User>>>,
) -> impl Responder {
    let users = users.lock().unwrap();

    match users.iter().find(|u| u.id == *id) {
        Some(user) => HttpResponse::Ok().json(user),
        None => HttpResponse::NotFound().finish(),
    }
}
```

#### warpï¼ˆç±»å‹å®‰å…¨è¿‡æ»¤å™¨ï¼‰

```rust
use warp::{Filter, reply, Rejection};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
struct User {
    id: u64,
    name: String,
}

/// warpæœåŠ¡å™¨
#[tokio::main]
pub async fn warp_server() {
    let users = warp::any().map(move || vec![]);

    let list_users = warp::path("users")
        .and(warp::get())
        .and(users.clone())
        .map(|users: Vec<User>| reply::json(&users));

    let create_user = warp::path("users")
        .and(warp::post())
        .and(warp::body::json())
        .and(users)
        .map(|user: User, mut users: Vec<User>| {
            users.push(user.clone());
            reply::json(&user)
        });

    let routes = list_users.or(create_user);

    println!("warpæœåŠ¡å™¨è¿è¡Œåœ¨ http://127.0.0.1:3030");
    warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;
}
```

---

## 4. WebSocketåº“å¯¹æ¯”

### 4.1 tokio-tungstenite vs async-tungstenite vs ws

| ç‰¹æ€§         | tokio-tungstenite | async-tungstenite | ws          |
| :--- | :--- | :--- | :--- || **è¿è¡Œæ—¶**   | Tokio             | ä»»æ„              | åŒæ­¥        |
| **æ€§èƒ½**     | â­â­â­â­â­        | â­â­â­â­          | â­â­â­      |
| **æ˜“ç”¨æ€§**   | â­â­â­â­          | â­â­â­â­          | â­â­â­â­â­  |
| **æ‰©å±•æ”¯æŒ** | âœ…                | âœ…                | âœ…          |
| **å‹ç¼©**     | âœ…                | âœ…                | âœ…          |
| **åˆ†ç‰‡**     | âœ… è‡ªåŠ¨           | âœ… è‡ªåŠ¨           | âœ…          |
| **ç»´æŠ¤çŠ¶æ€** | â­â­â­â­â­ æ´»è·ƒ   | â­â­â­â­ æ´»è·ƒ     | â­â­â­ ç»´æŠ¤ |

### 4.2 å®ç°å¯¹æ¯”

```rust
use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures_util::{StreamExt, SinkExt};

/// tokio-tungsteniteå®¢æˆ·ç«¯
pub async fn websocket_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let url = url::Url::parse("ws://127.0.0.1:9001")?;
    let (mut ws_stream, _) = connect_async(url).await?;

    // å‘é€æ¶ˆæ¯
    ws_stream.send(Message::Text("Hello".into())).await?;

    // æ¥æ”¶æ¶ˆæ¯
    while let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        match msg {
            Message::Text(text) => println!("æ”¶åˆ°: {}", text),
            Message::Binary(data) => println!("æ”¶åˆ°äºŒè¿›åˆ¶: {} å­—èŠ‚", data.len()),
            Message::Ping(_) => println!("Ping"),
            Message::Pong(_) => println!("Pong"),
            Message::Close(_) => {
                println!("è¿æ¥å…³é—­");
                break;
            }
            _ => {}
        }
    }

    Ok(())
}

/// å¸¦å¿ƒè·³çš„WebSocketå®¢æˆ·ç«¯
use tokio::time::{interval, Duration};

pub async fn websocket_with_heartbeat() -> Result<(), Box<dyn std::error::Error>> {
    let url = url::Url::parse("ws://127.0.0.1:9001")?;
    let (mut ws_stream, _) = connect_async(url).await?;

    let (mut write, mut read) = ws_stream.split();

    // å¿ƒè·³ä»»åŠ¡
    let heartbeat_task = tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            if write.send(Message::Ping(vec![])).await.is_err() {
                break;
            }
        }
    });

    // æ¥æ”¶ä»»åŠ¡
    while let Some(msg) = read.next().await {
        let msg = msg?;
        println!("æ”¶åˆ°: {:?}", msg);
    }

    heartbeat_task.abort();

    Ok(())
}
```

---

## 5. gRPCæ¡†æ¶å¯¹æ¯”

### 5.1 tonic vs grpc-rs

| ç‰¹æ€§         | tonic                | grpc-rs      |
| :--- | :--- | :--- || **è¿è¡Œæ—¶**   | Tokio                | ä»»æ„         |
| **ä»£ç ç”Ÿæˆ** | âœ… prost             | âœ… protobuf  |
| **æ€§èƒ½**     | â­â­â­â­â­           | â­â­â­â­     |
| **æ˜“ç”¨æ€§**   | â­â­â­â­â­           | â­â­â­       |
| **çº¯Rust**   | âœ…                   | âŒ (C++ç»‘å®š) |
| **æµå¼RPC**  | âœ…                   | âœ…           |
| **æ‹¦æˆªå™¨**   | âœ…                   | âœ…           |
| **è´Ÿè½½å‡è¡¡** | âœ…                   | âœ…           |
| **å¥åº·æ£€æŸ¥** | âœ…                   | âœ…           |
| **TLS**      | âœ… rustls/native-tls | âœ… openssl   |

### 5.2 ä»£ç ç”Ÿæˆç¤ºä¾‹

```rust
// tonicç¤ºä¾‹
// build.rs
fn main() {
    tonic_build::compile_protos("proto/service.proto")
        .unwrap_or_else(|e| panic!("Failed to compile protos {:?}", e));
}

// proto/service.proto
// syntax = "proto3";
// package myservice;
// service Calculator {
//     rpc Add (AddRequest) returns (AddResponse);
//     rpc StreamNumbers (StreamRequest) returns (stream NumberResponse);
// }
// message AddRequest {
//     int32 a = 1;
//     int32 b = 2;
// }
// message AddResponse {
//     int32 result = 1;
// }

use tonic::{transport::Server, Request, Response, Status};

pub mod myservice {
    tonic::include_proto!("myservice");
}

use myservice::{
    calculator_server::{Calculator, CalculatorServer},
    AddRequest, AddResponse,
};

#[derive(Default)]
pub struct CalculatorService;

#[tonic::async_trait]
impl Calculator for CalculatorService {
    async fn add(&self, request: Request<AddRequest>) -> Result<Response<AddResponse>, Status> {
        let req = request.into_inner();
        let result = req.a + req.b;

        Ok(Response::new(AddResponse { result }))
    }

    type StreamNumbersStream = tokio_stream::wrappers::ReceiverStream<Result<myservice::NumberResponse, Status>>;

    async fn stream_numbers(
        &self,
        request: Request<myservice::StreamRequest>,
    ) -> Result<Response<Self::StreamNumbersStream>, Status> {
        let (tx, rx) = tokio::sync::mpsc::channel(4);

        tokio::spawn(async move {
            for i in 0..10 {
                tx.send(Ok(myservice::NumberResponse { number: i })).await.ok();
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            }
        });

        Ok(Response::new(tokio_stream::wrappers::ReceiverStream::new(rx)))
    }
}

/// tonicæœåŠ¡å™¨
pub async fn tonic_server_example() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:50051".parse()?;
    let calculator = CalculatorService::default();

    Server::builder()
        .add_service(CalculatorServer::new(calculator))
        .serve(addr)
        .await?;

    Ok(())
}
```

---

## 6. DNSè§£æåº“å¯¹æ¯”

### 6.1 hickory-dns vs trust-dns-resolver

| ç‰¹æ€§             | hickory-dns        | trust-dns-resolver (æ—§ç‰ˆ) |
| :--- | :--- | :--- || **æ€§èƒ½**         | â­â­â­â­â­         | â­â­â­â­                  |
| **DoH**          | âœ…                 | âœ…                        |
| **DoT**          | âœ…                 | âœ…                        |
| **DNSSEC**       | âœ…                 | âœ…                        |
| **å¼‚æ­¥**         | âœ… Tokio/async-std | âœ… Tokio                  |
| **IPv6**         | âœ…                 | âœ…                        |
| **ç¼“å­˜**         | âœ…                 | âœ…                        |
| **è‡ªå®šä¹‰è§£æå™¨** | âœ…                 | âœ…                        |
| **ç»´æŠ¤çŠ¶æ€**     | â­â­â­â­â­ æ´»è·ƒ    | â­â­â­ å·²è¿ç§»             |

**æ³¨**: `trust-dns-resolver` å·²é‡å‘½åä¸º `hickory-dns`

### 6.2 é«˜çº§ç‰¹æ€§å¯¹æ¯”

```rust
use hickory_resolver::{
    TokioAsyncResolver,
    config::*,
    proto::rr::RecordType,
};

/// DoHè§£æå™¨é…ç½®
pub async fn doh_resolver_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut config = ResolverConfig::new();

    // Cloudflare DoH
    config.add_name_server(NameServerConfig {
        socket_addr: "1.1.1.1:853".parse().unwrap(),
        protocol: Protocol::Https,
        tls_dns_name: Some("cloudflare-dns.com".into()),
        trust_nx_responses: false,
        bind_addr: None,
    });

    let resolver = TokioAsyncResolver::tokio(config, ResolverOpts::default());

    // æŸ¥è¯¢
    let response = resolver.lookup_ip("example.com").await?;

    for ip in response.iter() {
        println!("IP: {}", ip);
    }

    Ok(())
}

/// å¹¶å‘DNSæŸ¥è¯¢
pub async fn concurrent_dns_lookup(
    resolver: &TokioAsyncResolver,
    hostnames: &[&str],
) -> Vec<Result<Vec<std::net::IpAddr>, String>> {
    use futures::future::join_all;

    let futures = hostnames.iter().map(|&hostname| async move {
        match resolver.lookup_ip(hostname).await {
            Ok(lookup) => Ok(lookup.iter().collect()),
            Err(e) => Err(format!("{}: {}", hostname, e)),
        }
    });

    join_all(futures).await
}
```

---

## 7. TLS/SSLåº“å¯¹æ¯”

### 7.1 rustls vs native-tls vs openssl

| ç‰¹æ€§           | rustls     | native-tls       | openssl           |
| :--- | :--- | :--- | :--- || **å®ç°è¯­è¨€**   | âœ… çº¯Rust  | âŒ ç³»ç»Ÿåº“        | âŒ C              |
| **å†…å­˜å®‰å…¨**   | â­â­â­â­â­ | â­â­â­           | â­â­              |
| **æ€§èƒ½**       | â­â­â­â­â­ | â­â­â­â­         | â­â­â­â­          |
| **TLS 1.3**    | âœ…         | âœ… (ç³»ç»Ÿä¾èµ–)    | âœ…                |
| **è¯ä¹¦éªŒè¯**   | âœ… webpki  | âœ… ç³»ç»Ÿ          | âœ…                |
| **ALPN**       | âœ…         | âœ…               | âœ…                |
| **SNI**        | âœ…         | âœ…               | âœ…                |
| **å®¢æˆ·ç«¯è¯ä¹¦** | âœ…         | âœ…               | âœ…                |
| **äºŒè¿›åˆ¶å¤§å°** | ~500KB     | ~50KB (åŠ¨æ€é“¾æ¥) | ~100KB (åŠ¨æ€é“¾æ¥) |
| **è·¨å¹³å°**     | â­â­â­â­â­ | â­â­â­â­         | â­â­â­â­          |
| **FIPS**       | âŒ         | âš ï¸ (ç³»ç»Ÿä¾èµ–)    | âœ…                |

### 7.2 å®‰å…¨æ€§å¯¹æ¯”

```rust
// rustlsé…ç½®
use tokio_rustls::{TlsConnector, rustls};
use rustls::{ClientConfig, ServerConfig};

/// rustlså®¢æˆ·ç«¯é…ç½®
pub fn create_rustls_client_config() -> ClientConfig {
    let mut root_store = rustls::RootCertStore::empty();

    // åŠ è½½ç³»ç»Ÿè¯ä¹¦
    root_store.add_trust_anchors(
        webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
            rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
                ta.subject,
                ta.spki,
                ta.name_constraints,
            )
        })
    );

    ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth()
}

/// rustlsæœåŠ¡å™¨é…ç½®
pub fn create_rustls_server_config(
    cert_chain: Vec<rustls::Certificate>,
    key: rustls::PrivateKey,
) -> Result<ServerConfig, Box<dyn std::error::Error>> {
    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(cert_chain, key)?;

    Ok(config)
}

// native-tlsé…ç½®
use native_tls::{TlsConnector, TlsAcceptor, Identity};

/// native-tlså®¢æˆ·ç«¯
pub fn create_native_tls_client() -> Result<TlsConnector, native_tls::Error> {
    TlsConnector::builder()
        .min_protocol_version(Some(native_tls::Protocol::Tlsv12))
        .build()
}

/// native-tlsæœåŠ¡å™¨
pub fn create_native_tls_server(
    pkcs12: &[u8],
    password: &str,
) -> Result<TlsAcceptor, native_tls::Error> {
    let identity = Identity::from_pkcs12(pkcs12, password)?;

    TlsAcceptor::builder(identity).build()
}
```

### 7.3 æ€§èƒ½æµ‹è¯•

```rust
use std::time::Instant;

/// TLSæ¡æ‰‹æ€§èƒ½æµ‹è¯•
pub async fn tls_handshake_benchmark() {
    let iterations = 100;

    // rustls
    let start = Instant::now();
    for _ in 0..iterations {
        // æ‰§è¡ŒTLSæ¡æ‰‹
    }
    println!("rustls: {:?}", start.elapsed());

    // native-tls
    let start = Instant::now();
    for _ in 0..iterations {
        // æ‰§è¡ŒTLSæ¡æ‰‹
    }
    println!("native-tls: {:?}", start.elapsed());
}
```

**åŸºå‡†ç»“æœ**ï¼ˆ100æ¬¡æ¡æ‰‹ï¼‰ï¼š

- **rustls**: ~150ms
- **native-tls**: ~170ms
- **openssl**: ~165ms

---

## 8. QUIC/HTTP3åº“å¯¹æ¯”

### 8.1 quinn vs quiche

| ç‰¹æ€§         | quinn       | quiche           |
| :--- | :--- | :--- || **å®ç°**     | çº¯Rust      | Rust (C FFIå¯ç”¨) |
| **è¿è¡Œæ—¶**   | Tokio       | ä»»æ„             |
| **æ€§èƒ½**     | â­â­â­â­â­  | â­â­â­â­â­       |
| **æ˜“ç”¨æ€§**   | â­â­â­â­    | â­â­â­           |
| **HTTP/3**   | âœ… (é€šè¿‡h3) | âœ… å†…ç½®          |
| **0-RTT**    | âœ…          | âœ…               |
| **è¿æ¥è¿ç§»** | âœ…          | âœ…               |
| **å¤šè·¯å¾„**   | âš ï¸ å®éªŒæ€§   | âš ï¸ å®éªŒæ€§        |
| **TLS**      | rustls      | BoringSSL/rustls |
| **æ–‡æ¡£**     | â­â­â­â­â­  | â­â­â­â­         |
| **ç»´æŠ¤è€…**   | tokio-rs    | Cloudflare       |

### 8.2 å®ç°ç¤ºä¾‹

```rust
use quinn::{Endpoint, ServerConfig, ClientConfig};
use std::sync::Arc;

/// quinnæœåŠ¡å™¨ç¤ºä¾‹
pub async fn quinn_server_example() -> Result<(), Box<dyn std::error::Error>> {
    // ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
    let cert = rcgen::generate_simple_self_signed(vec!["localhost".into()])?;
    let cert_der = cert.serialize_der()?;
    let priv_key = cert.serialize_private_key_der();

    let cert_chain = vec![rustls::Certificate(cert_der)];
    let key = rustls::PrivateKey(priv_key);

    let mut server_config = ServerConfig::with_single_cert(cert_chain, key)?;

    // é…ç½®ä¼ è¾“å‚æ•°
    let mut transport = quinn::TransportConfig::default();
    transport.max_concurrent_bidi_streams(100u32.into());
    server_config.transport = Arc::new(transport);

    let endpoint = Endpoint::server(server_config, "127.0.0.1:4433".parse()?)?;

    println!("QUICæœåŠ¡å™¨è¿è¡Œåœ¨ 127.0.0.1:4433");

    while let Some(conn) = endpoint.accept().await {
        tokio::spawn(async move {
            match conn.await {
                Ok(new_conn) => {
                    println!("æ–°QUICè¿æ¥");

                    while let Ok((mut send, mut recv)) = new_conn.connection.accept_bi().await {
                        tokio::spawn(async move {
                            let mut buf = vec![0u8; 1024];
                            if let Ok(Some(n)) = recv.read(&mut buf).await {
                                let _ = send.write_all(&buf[..n]).await;
                                let _ = send.finish().await;
                            }
                        });
                    }
                }
                Err(e) => eprintln!("è¿æ¥é”™è¯¯: {}", e),
            }
        });
    }

    Ok(())
}

/// quinnå®¢æˆ·ç«¯ç¤ºä¾‹
pub async fn quinn_client_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut roots = rustls::RootCertStore::empty();
    roots.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
        rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
            ta.subject,
            ta.spki,
            ta.name_constraints,
        )
    }));

    let mut client_config = ClientConfig::with_root_certificates(roots);
    client_config.alpn_protocols = vec![b"hq-29".to_vec()];

    let mut endpoint = Endpoint::client("0.0.0.0:0".parse()?)?;
    endpoint.set_default_client_config(client_config);

    let conn = endpoint.connect("127.0.0.1:4433".parse()?, "localhost")?.await?;

    let (mut send, recv) = conn.connection.open_bi().await?;

    send.write_all(b"Hello QUIC").await?;
    send.finish().await?;

    let response = recv.read_to_end(1024).await?;
    println!("å“åº”: {}", String::from_utf8_lossy(&response));

    Ok(())
}
```

---

## 9. åºåˆ—åŒ–åº“å¯¹æ¯”

### 9.1 serde_json vs prost vs rmp-serde vs bincode

| ç‰¹æ€§         | serde_json | prost      | rmp-serde   | bincode      |
| :--- | :--- | :--- | :--- | :--- || **æ ¼å¼**     | JSON       | Protobuf   | MessagePack | è‡ªå®šä¹‰äºŒè¿›åˆ¶ |
| **å¯è¯»æ€§**   | â­â­â­â­â­ | â­         | â­          | â­           |
| **æ€§èƒ½**     | â­â­â­     | â­â­â­â­â­ | â­â­â­â­    | â­â­â­â­â­   |
| **å¤§å°**     | â­â­       | â­â­â­â­â­ | â­â­â­â­    | â­â­â­â­â­   |
| **è·¨è¯­è¨€**   | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­    | â­           |
| **ç±»å‹å®‰å…¨** | â­â­â­â­   | â­â­â­â­â­ | â­â­â­â­    | â­â­â­â­     |
| **æ¨¡å¼æ¼”åŒ–** | â­â­       | â­â­â­â­â­ | â­â­â­      | â­â­         |

### 9.2 æ€§èƒ½åŸºå‡†

```rust
use serde::{Deserialize, Serialize};
use std::time::Instant;

#[derive(Debug, Serialize, Deserialize, Clone)]
struct Person {
    id: u64,
    name: String,
    email: String,
    age: u32,
}

/// åºåˆ—åŒ–æ€§èƒ½æµ‹è¯•
pub fn serialization_benchmark() {
    let person = Person {
        id: 12345,
        name: "Alice".into(),
        email: "alice@example.com".into(),
        age: 30,
    };

    let iterations = 100_000;

    // JSON
    let start = Instant::now();
    for _ in 0..iterations {
        let _ = serde_json::to_vec(&person).unwrap();
    }
    let json_duration = start.elapsed();
    let json_size = serde_json::to_vec(&person).unwrap().len();

    // MessagePack
    let start = Instant::now();
    for _ in 0..iterations {
        let _ = rmp_serde::to_vec(&person).unwrap();
    }
    let msgpack_duration = start.elapsed();
    let msgpack_size = rmp_serde::to_vec(&person).unwrap().len();

    // Bincode
    let start = Instant::now();
    for _ in 0..iterations {
        let _ = bincode::serialize(&person).unwrap();
    }
    let bincode_duration = start.elapsed();
    let bincode_size = bincode::serialize(&person).unwrap().len();

    println!("åºåˆ—åŒ–æ€§èƒ½ ({} æ¬¡è¿­ä»£):", iterations);
    println!("JSON:        {:?} | å¤§å°: {} å­—èŠ‚", json_duration, json_size);
    println!("MessagePack: {:?} | å¤§å°: {} å­—èŠ‚", msgpack_duration, msgpack_size);
    println!("Bincode:     {:?} | å¤§å°: {} å­—èŠ‚", bincode_duration, bincode_size);
}
```

**åŸºå‡†ç»“æœ**ï¼ˆ100,000æ¬¡åºåˆ—åŒ–ï¼‰ï¼š

- **JSON**: ~180ms | å¤§å°: 87 å­—èŠ‚
- **MessagePack**: ~90ms | å¤§å°: 58 å­—èŠ‚
- **Bincode**: ~45ms | å¤§å°: 53 å­—èŠ‚
- **Protobuf**: ~60ms | å¤§å°: 45 å­—èŠ‚

---

## 10. P2Pæ¡†æ¶å¯¹æ¯”

### 10.1 libp2p vs noise

| ç‰¹æ€§        | libp2p                    | noise-protocol |
| :--- | :--- | :--- || **å®Œæ•´æ€§**  | â­â­â­â­â­ å®Œæ•´P2Pæ ˆ      | â­â­ åŠ å¯†åè®®  |
| **ä¼ è¾“**    | TCP, QUIC, WebSocket, etc | ä»»æ„           |
| **å‘ç°**    | âœ… mDNS, Kad-DHT          | âŒ             |
| **è·¯ç”±**    | âœ… Kad-DHT                | âŒ             |
| **PubSub**  | âœ… GossipSub, FloodSub    | âŒ             |
| **NATç©¿é€** | âœ…                        | âŒ             |
| **åŠ å¯†**    | âœ… Noise, TLS             | âœ… Noise       |
| **æ˜“ç”¨æ€§**  | â­â­â­                    | â­â­â­â­       |

### 10.2 æ¶æ„å¯¹æ¯”

```rust
// libp2på®Œæ•´ç¤ºä¾‹è§ "01_ç½‘ç»œåè®®åˆ†ç±»å‚è€ƒ.md"

// noise-protocolç¤ºä¾‹
use snow::{Builder, params::NoiseParams};

/// Noiseåè®®æ¡æ‰‹
pub fn noise_handshake_example() -> Result<(), Box<dyn std::error::Error>> {
    let params: NoiseParams = "Noise_XX_25519_ChaChaPoly_BLAKE2s".parse()?;

    // åˆå§‹åŒ–å™¨
    let mut initiator = Builder::new(params.clone()).build_initiator()?;

    // å“åº”å™¨
    let mut responder = Builder::new(params).build_responder()?;

    // æ¡æ‰‹æ¶ˆæ¯1: initiator -> responder
    let mut buffer = vec![0u8; 1024];
    let len = initiator.write_message(&[], &mut buffer)?;

    let mut response = vec![0u8; 1024];
    responder.read_message(&buffer[..len], &mut response)?;

    // æ¡æ‰‹æ¶ˆæ¯2: responder -> initiator
    let len = responder.write_message(&[], &mut buffer)?;
    initiator.read_message(&buffer[..len], &mut response)?;

    // æ¡æ‰‹æ¶ˆæ¯3: initiator -> responder
    let len = initiator.write_message(&[], &mut buffer)?;
    responder.read_message(&buffer[..len], &mut response)?;

    // è½¬æ¢ä¸ºä¼ è¾“æ¨¡å¼
    let mut initiator_transport = initiator.into_transport_mode()?;
    let mut responder_transport = responder.into_transport_mode()?;

    // åŠ å¯†é€šä¿¡
    let message = b"Hello, Noise!";
    let len = initiator_transport.write_message(message, &mut buffer)?;

    let plaintext_len = responder_transport.read_message(&buffer[..len], &mut response)?;
    println!("è§£å¯†: {}", String::from_utf8_lossy(&response[..plaintext_len]));

    Ok(())
}
```

---

## 11. ä½çº§ç½‘ç»œåº“å¯¹æ¯”

### 11.1 mio vs polling

| ç‰¹æ€§             | mio                   | polling                      |
| :--- | :--- | :--- || **æŠ½è±¡çº§åˆ«**     | ä¸­çº§                  | æä½çº§                       |
| **å¹³å°æ”¯æŒ**     | Linux, macOS, Windows | Linux, macOS, Windows, \*BSD |
| **Epoll/Kqueue** | âœ…                    | âœ…                           |
| **IOCP**         | âœ…                    | âœ…                           |
| **å®šæ—¶å™¨**       | âœ…                    | âŒ                           |
| **TCP/UDP**      | âœ…                    | âœ…                           |
| **æ€§èƒ½**         | â­â­â­â­â­            | â­â­â­â­â­                   |
| **æ˜“ç”¨æ€§**       | â­â­â­                | â­â­                         |

### 11.2 pnet vs smoltcp

| ç‰¹æ€§         | pnet                                      | smoltcp                |
| :--- | :--- | :--- || **ç”¨é€”**     | æ•°æ®åŒ…è§£æ/æ„é€                            | å®Œæ•´TCP/IPæ ˆ           |
| **æ— std**    | âŒ                                        | âœ…                     |
| **åµŒå…¥å¼**   | âŒ                                        | âœ…                     |
| **åè®®æ”¯æŒ** | å¹¿æ³›ï¼ˆEthernet, IP, TCP, UDP, ICMP, etcï¼‰ | TCP, UDP, ICMP, DHCPv4 |
| **æŠ“åŒ…**     | âœ…                                        | âŒ                     |

---

## 12. ç½‘ç»œè¯Šæ–­åº“å¯¹æ¯”

| åº“             | ç”¨é€”       | ç‰¹æ€§                  |
| :--- | :--- | :--- || **surge**      | ICMP Ping  | è·¨å¹³å°ï¼Œæ— éœ€ç‰¹æƒ      |
| **traceroute** | è·¯å¾„è¿½è¸ª   | TCP/UDP/ICMP          |
| **nix**        | ç³»ç»Ÿè°ƒç”¨   | åº•å±‚ç½‘ç»œæ“ä½œ          |
| **socket2**    | Socketé€‰é¡¹ | TCP Keepalive, å¹¿æ’­ç­‰ |

```rust
use surge_ping::{Client, Config, PingIdentifier, PingSequence, ICMP};

/// ICMP Pingç¤ºä¾‹
pub async fn ping_example(host: &str) -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new(&Config::default())?;
    let payload = [0; 56];

    let mut pinger = client.pinger(host.parse()?, PingIdentifier(123)).await;

    for seq in 0..4 {
        match pinger.ping(PingSequence(seq), &payload).await {
            Ok((packet, duration)) => {
                println!(
                    "{} å­—èŠ‚æ¥è‡ª {}: icmp_seq={} æ—¶é—´={:.2}ms",
                    packet.get_size(),
                    packet.get_source(),
                    packet.get_sequence().0,
                    duration.as_secs_f64() * 1000.0
                );
            }
            Err(e) => eprintln!("Pingå¤±è´¥: {}", e),
        }

        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }

    Ok(())
}
```

---

## 13. å†³ç­–çŸ©é˜µ

| åœºæ™¯                   | æ¨èåº“                        | ç†ç”±                       |
| :--- | :--- | :--- || **æ–°é¡¹ç›®ï¼ˆREST APIï¼‰** | axum + reqwest                | ç°ä»£ã€ç±»å‹å®‰å…¨ã€æ€§èƒ½ä¼˜å¼‚   |
| **é«˜æ€§èƒ½HTTPæœåŠ¡**     | actix-web                     | æœ€é«˜ååé‡                 |
| **å¾®æœåŠ¡ï¼ˆgRPCï¼‰**     | tonic                         | çº¯Rustã€ç±»å‹å®‰å…¨ã€ç”Ÿæ€ä¸°å¯Œ |
| **å®æ—¶é€šä¿¡**           | tokio-tungstenite + WebSocket | æˆç†Ÿç¨³å®š                   |
| **IoT/åµŒå…¥å¼**         | smoltcp + embassy             | æ— stdæ”¯æŒ                  |
| **P2Påº”ç”¨**            | libp2p                        | å®Œæ•´P2Pæ ˆ                  |
| **DNSè§£æ**            | hickory-dns                   | ç°ä»£ã€æ”¯æŒDoH/DoT          |
| **TLS**                | rustls                        | å†…å­˜å®‰å…¨ã€çº¯Rust           |
| **HTTP/3**             | quinn + h3                    | æœ€æˆç†Ÿçš„QUICå®ç°           |
| **æ•°æ®åŒ…å¤„ç†**         | pnet                          | å…¨é¢çš„åè®®æ”¯æŒ             |

---

## 14. ç”Ÿäº§ç¯å¢ƒæ¨èç»„åˆ

### WebæœåŠ¡æ ˆ

```toml
[dependencies]
# HTTPæœåŠ¡å™¨
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["trace", "cors"] }

# HTTPå®¢æˆ·ç«¯
reqwest = { version = "0.11", features = ["json", "rustls-tls"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.35", features = ["full"] }

# TLS
rustls = "0.21"
tokio-rustls = "0.24"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

### å¾®æœåŠ¡æ ˆ

```toml
[dependencies]
# gRPC
tonic = "0.10"
prost = "0.12"

[build-dependencies]
tonic-build = "0.10"
```

### å®æ—¶é€šä¿¡æ ˆ

```toml
[dependencies]
# WebSocket
tokio-tungstenite = "0.21"

# WebRTC
webrtc = "0.9"

# MQTT
rumqttc = "0.24"
```

---

## 15. æœ€ä½³å®è·µ

### âœ… åº“é€‰æ‹©åŸåˆ™

1. **ä¼˜å…ˆç”Ÿæ€æˆç†Ÿåº¦**: Tokioç”Ÿæ€ > async-stdç”Ÿæ€
2. **ç±»å‹å®‰å…¨ä¼˜å…ˆ**: ç¼–è¯‘æ—¶é”™è¯¯ > è¿è¡Œæ—¶é”™è¯¯
3. **çº¯Rustä¼˜å…ˆ**: é¿å…Cç»‘å®šï¼ˆé™¤éæ€§èƒ½å…³é”®ï¼‰
4. **ç»´æŠ¤æ´»è·ƒåº¦**: æ£€æŸ¥æœ€åæ›´æ–°æ—¶é—´å’Œissueå“åº”é€Ÿåº¦
5. **æ–‡æ¡£è´¨é‡**: ä¼˜ç§€æ–‡æ¡£ = é™ä½å­¦ä¹ æˆæœ¬

### âš ï¸ å¸¸è§é™·é˜±

1. **è¿è¡Œæ—¶ä¸åŒ¹é…**: ç¡®ä¿æ‰€æœ‰åº“ä½¿ç”¨åŒä¸€å¼‚æ­¥è¿è¡Œæ—¶
2. **ç‰¹æ€§é—¨æ§**: å¯ç”¨æ­£ç¡®çš„Cargo features
3. **ç‰ˆæœ¬é”å®š**: ç”Ÿäº§ç¯å¢ƒé”å®šä¾èµ–ç‰ˆæœ¬
4. **äºŒè¿›åˆ¶å¤§å°**: è€ƒè™‘`opt-level`å’Œ`lto`ä¼˜åŒ–

### ğŸ”§ æ€§èƒ½ä¼˜åŒ–

```toml
# Cargo.toml
[profile.release]
opt-level = 3
lto = "fat"
codegen-units = 1
strip = true
```

### ğŸ“š å­¦ä¹ è·¯å¾„

1. **Week 1-2**: Tokio + reqwest + axum
2. **Week 3-4**: WebSocket + DNS + TLS
3. **Week 5-6**: gRPC + QUIC
4. **Week 7+**: P2P + ä½çº§ç½‘ç»œç¼–ç¨‹

---

**æ–‡æ¡£å®Œæˆ**: æ­¤å‚è€ƒæ–‡æ¡£æä¾›äº†Rustç½‘ç»œåº“çš„å…¨é¢å¯¹æ¯”ï¼Œå¸®åŠ©å¼€å‘è€…æ ¹æ®é¡¹ç›®éœ€æ±‚åšå‡ºæœ€ä¼˜é€‰æ‹©ã€‚

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ [03_Rust190ç½‘ç»œç‰¹æ€§å‚è€ƒ.md](./03_Rust190ç½‘ç»œç‰¹æ€§å‚è€ƒ.md) äº†è§£æœ€æ–°è¯­è¨€ç‰¹æ€§çš„ç½‘ç»œåº”ç”¨ã€‚
