# 网络安全参考

> **文档版本**: v1.0.0  
> **更新日期**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **文档层级**: Tier 3 - 技术参考

---

## 目录

- [网络安全参考](#网络安全参考)
  - [目录](#目录)
  - [1. TLS/SSL安全配置](#1-tlsssl安全配置)
    - [rustls生产配置](#rustls生产配置)
    - [加密套件配置](#加密套件配置)
  - [2. 证书管理](#2-证书管理)
    - [自签名证书生成](#自签名证书生成)
    - [证书验证](#证书验证)
  - [3. 认证与授权](#3-认证与授权)
    - [JWT认证](#jwt认证)
    - [OAuth2实现](#oauth2实现)
  - [4. 输入验证与过滤](#4-输入验证与过滤)
    - [SQL注入防护](#sql注入防护)
    - [XSS防护](#xss防护)
    - [路径遍历防护](#路径遍历防护)
  - [5. DoS防护](#5-dos防护)
    - [速率限制](#速率限制)
    - [连接限制](#连接限制)
    - [请求大小限制](#请求大小限制)
  - [6. 加密通信](#6-加密通信)
    - [对称加密（AES-GCM）](#对称加密aes-gcm)
    - [非对称加密（RSA）](#非对称加密rsa)
    - [哈希与HMAC](#哈希与hmac)
  - [7. 安全审计](#7-安全审计)
    - [日志与监控](#日志与监控)
  - [8. 常见漏洞防护](#8-常见漏洞防护)
    - [CSRF防护](#csrf防护)
    - [CORS配置](#cors配置)
  - [9. 安全最佳实践](#9-安全最佳实践)
    - [密钥管理](#密钥管理)
    - [安全响应头](#安全响应头)
  - [10. 安全测试](#10-安全测试)
    - [模糊测试](#模糊测试)
    - [渗透测试](#渗透测试)

---

## 1. TLS/SSL安全配置

### rustls生产配置

```rust
use tokio_rustls::{TlsAcceptor, rustls};
use std::sync::Arc;
use std::fs;

/// 创建安全的TLS配置
pub fn create_secure_tls_config() -> Result<rustls::ServerConfig, Box<dyn std::error::Error>> {
    // 加载证书和私钥
    let cert = fs::read("cert.pem")?;
    let key = fs::read("key.pem")?;
    
    let certs = rustls_pemfile::certs(&mut &cert[..])
        .map(|mut certs| certs.drain(..).map(rustls::Certificate).collect())
        .unwrap();
    
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key[..])
        .map(|mut keys| rustls::PrivateKey(keys.remove(0)))
        .unwrap();
    
    let mut config = rustls::ServerConfig::builder()
        .with_safe_default_cipher_suites() // 安全的加密套件
        .with_safe_default_kx_groups()     // 安全的密钥交换
        .with_protocol_versions(&[&rustls::version::TLS13])? // 仅TLS 1.3
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    
    // ALPN协议
    config.alpn_protocols = vec![b"h2".to_vec(), b"http/1.1".to_vec()];
    
    Ok(config)
}

/// TLS服务器
pub async fn secure_tls_server() -> Result<(), Box<dyn std::error::Error>> {
    let config = create_secure_tls_config()?;
    let acceptor = TlsAcceptor::from(Arc::new(config));
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:443").await?;
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = acceptor.clone();
        
        tokio::spawn(async move {
            match acceptor.accept(stream).await {
                Ok(tls_stream) => {
                    println!("安全连接来自: {}", peer_addr);
                    // 处理TLS流
                }
                Err(e) => eprintln!("TLS握手失败: {}", e),
            }
        });
    }
}
```

### 加密套件配置

```rust
/// 自定义加密套件（仅推荐的）
pub fn create_custom_cipher_suites() -> Vec<rustls::SupportedCipherSuite> {
    use rustls::cipher_suite;
    
    vec![
        cipher_suite::TLS13_AES_256_GCM_SHA384,      // AEAD
        cipher_suite::TLS13_AES_128_GCM_SHA256,      // AEAD
        cipher_suite::TLS13_CHACHA20_POLY1305_SHA256, // AEAD
    ]
}
```

---

## 2. 证书管理

### 自签名证书生成

```rust
use rcgen::{Certificate, CertificateParams, DistinguishedName};
use std::fs;

/// 生成自签名证书
pub fn generate_self_signed_cert() -> Result<Certificate, Box<dyn std::error::Error>> {
    let mut params = CertificateParams::new(vec!["localhost".to_string()]);
    
    params.distinguished_name = DistinguishedName::new();
    params.distinguished_name.push(rcgen::DnType::CommonName, "My Server");
    params.distinguished_name.push(rcgen::DnType::OrganizationName, "My Company");
    
    let cert = Certificate::from_params(params)?;
    
    // 保存证书和私钥
    fs::write("cert.pem", cert.serialize_pem()?)?;
    fs::write("key.pem", cert.serialize_private_key_pem())?;
    
    Ok(cert)
}
```

### 证书验证

```rust
use rustls::client::ServerCertVerifier;
use rustls::Certificate;

/// 自定义证书验证器
pub struct CustomCertVerifier;

impl ServerCertVerifier for CustomCertVerifier {
    fn verify_server_cert(
        &self,
        end_entity: &Certificate,
        intermediates: &[Certificate],
        server_name: &rustls::ServerName,
        scts: &mut dyn Iterator<Item = &[u8]>,
        ocsp_response: &[u8],
        now: std::time::SystemTime,
    ) -> Result<rustls::client::ServerCertVerified, rustls::Error> {
        // 自定义验证逻辑
        println!("验证证书: {:?}", server_name);
        
        // 验证证书链、吊销状态等
        
        Ok(rustls::client::ServerCertVerified::assertion())
    }
}
```

---

## 3. 认证与授权

### JWT认证

```rust
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Deserialize, Serialize};
use chrono::{Utc, Duration};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String, // 用户ID
    exp: usize,  // 过期时间
    iat: usize,  // 签发时间
    role: String,
}

/// 生成JWT令牌
pub fn generate_jwt(user_id: &str, role: &str, secret: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::hours(24))
        .unwrap()
        .timestamp() as usize;
    
    let claims = Claims {
        sub: user_id.to_owned(),
        exp: expiration,
        iat: Utc::now().timestamp() as usize,
        role: role.to_owned(),
    };
    
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))
}

/// 验证JWT令牌
pub fn verify_jwt(token: &str, secret: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_ref()),
        &Validation::default(),
    ).map(|data| data.claims)
}

/// axum中间件
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn jwt_auth_middleware<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    let token = auth_header
        .strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    verify_jwt(token, "your-secret-key")
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    Ok(next.run(req).await)
}
```

### OAuth2实现

```rust
use oauth2::{
    AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl,
    basic::BasicClient,
    reqwest::async_http_client,
    AuthorizationCode, CsrfToken, PkceCodeChallenge, Scope,
};

/// OAuth2客户端配置
pub fn create_oauth2_client() -> BasicClient {
    BasicClient::new(
        ClientId::new("client_id".to_string()),
        Some(ClientSecret::new("client_secret".to_string())),
        AuthUrl::new("https://auth.example.com/oauth/authorize".to_string()).unwrap(),
        Some(TokenUrl::new("https://auth.example.com/oauth/token".to_string()).unwrap()),
    )
    .set_redirect_uri(RedirectUrl::new("http://localhost:8080/callback".to_string()).unwrap())
}

/// OAuth2授权流程
pub async fn oauth2_flow() -> Result<(), Box<dyn std::error::Error>> {
    let client = create_oauth2_client();
    
    // 生成PKCE挑战
    let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
    
    // 生成授权URL
    let (auth_url, csrf_token) = client
        .authorize_url(CsrfToken::new_random)
        .add_scope(Scope::new("read".to_string()))
        .add_scope(Scope::new("write".to_string()))
        .set_pkce_challenge(pkce_challenge)
        .url();
    
    println!("访问: {}", auth_url);
    
    // 用户授权后，使用code换取token
    let code = AuthorizationCode::new("auth_code_from_callback".to_string());
    
    let token_result = client
        .exchange_code(code)
        .set_pkce_verifier(pkce_verifier)
        .request_async(async_http_client)
        .await?;
    
    println!("Access Token: {}", token_result.access_token().secret());
    
    Ok(())
}
```

---

## 4. 输入验证与过滤

### SQL注入防护

```rust
use sqlx::{PgPool, FromRow};

#[derive(Debug, FromRow)]
struct User {
    id: i32,
    username: String,
}

/// ✅ 使用参数化查询
pub async fn safe_query(pool: &PgPool, username: &str) -> Result<Vec<User>, sqlx::Error> {
    sqlx::query_as::<_, User>("SELECT id, username FROM users WHERE username = $1")
        .bind(username) // 参数化，防止SQL注入
        .fetch_all(pool)
        .await
}

/// ❌ 不安全的查询（拼接SQL）
pub async fn unsafe_query(pool: &PgPool, username: &str) -> Result<Vec<User>, sqlx::Error> {
    let sql = format!("SELECT id, username FROM users WHERE username = '{}'", username);
    sqlx::query_as::<_, User>(&sql) // 易受SQL注入攻击
        .fetch_all(pool)
        .await
}
```

### XSS防护

```rust
use ammonia::clean;

/// XSS过滤
pub fn sanitize_html(input: &str) -> String {
    clean(input)
}

/// 示例
pub fn xss_protection_example() {
    let malicious_input = r#"<script>alert('XSS')</script>Hello"#;
    let safe_output = sanitize_html(malicious_input);
    
    println!("原始: {}", malicious_input);
    println!("过滤后: {}", safe_output); // "Hello"
}
```

### 路径遍历防护

```rust
use std::path::{Path, PathBuf};

/// 安全的文件路径验证
pub fn validate_file_path(base_dir: &Path, requested_path: &str) -> Result<PathBuf, String> {
    let requested = Path::new(requested_path);
    
    // 拒绝绝对路径
    if requested.is_absolute() {
        return Err("不允许绝对路径".into());
    }
    
    // 拒绝".."
    if requested.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
        return Err("不允许路径遍历".into());
    }
    
    let full_path = base_dir.join(requested);
    
    // 确保路径在基础目录内
    if !full_path.starts_with(base_dir) {
        return Err("路径超出基础目录".into());
    }
    
    Ok(full_path)
}
```

---

## 5. DoS防护

### 速率限制

```rust
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};

/// 简单的速率限制器
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }
    
    /// 检查是否允许请求
    pub async fn check(&self, client_id: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        let client_requests = requests.entry(client_id.to_string()).or_insert_with(Vec::new);
        
        // 移除过期请求
        client_requests.retain(|&t| now.duration_since(t) < self.window);
        
        if client_requests.len() >= self.max_requests {
            return false; // 超过限制
        }
        
        client_requests.push(now);
        true
    }
}

/// axum中间件
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
    extract::ConnectInfo,
};
use std::net::SocketAddr;

pub async fn rate_limit_middleware<B>(
    ConnectInfo(addr): ConnectInfo<SocketAddr>,
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let limiter = RateLimiter::new(100, Duration::from_secs(60)); // 每分钟100次
    
    let client_id = addr.ip().to_string();
    
    if !limiter.check(&client_id).await {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    
    Ok(next.run(req).await)
}
```

### 连接限制

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

/// 最大并发连接限制
pub struct ConnectionLimiter {
    semaphore: Arc<Semaphore>,
}

impl ConnectionLimiter {
    pub fn new(max_connections: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_connections)),
        }
    }
    
    /// 获取连接许可
    pub async fn acquire(&self) -> tokio::sync::SemaphorePermit<'_> {
        self.semaphore.acquire().await.unwrap()
    }
}

/// 使用示例
pub async fn limited_tcp_server() -> std::io::Result<()> {
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    let limiter = ConnectionLimiter::new(1000); // 最多1000个连接
    
    loop {
        let (stream, _) = listener.accept().await?;
        let permit = limiter.acquire().await;
        
        tokio::spawn(async move {
            // 处理连接
            drop(permit); // 释放许可
        });
    }
}
```

### 请求大小限制

```rust
use axum::{
    body::Body,
    extract::Request,
    middleware::Next,
    response::Response,
    http::StatusCode,
};

/// 限制请求体大小
pub async fn limit_request_size(
    req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    const MAX_SIZE: u64 = 10 * 1024 * 1024; // 10MB
    
    if let Some(content_length) = req.headers().get("content-length") {
        if let Ok(length_str) = content_length.to_str() {
            if let Ok(length) = length_str.parse::<u64>() {
                if length > MAX_SIZE {
                    return Err(StatusCode::PAYLOAD_TOO_LARGE);
                }
            }
        }
    }
    
    Ok(next.run(req).await)
}
```

---

## 6. 加密通信

### 对称加密（AES-GCM）

```rust
use aes_gcm::{Aes256Gcm, KeyInit};
use aes_gcm::aead::{Aead, Nonce};
use rand::RngCore;

/// AES-256-GCM加密
pub fn encrypt_aes_gcm(plaintext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, aes_gcm::Error> {
    let cipher = Aes256Gcm::new(key.into());
    
    // 生成随机nonce
    let mut nonce_bytes = [0u8; 12];
    rand::thread_rng().fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::<typenum::U12>::from_slice(&nonce_bytes);
    
    let ciphertext = cipher.encrypt(nonce, plaintext)?;
    
    // 拼接nonce和密文
    let mut result = nonce_bytes.to_vec();
    result.extend_from_slice(&ciphertext);
    
    Ok(result)
}

/// AES-256-GCM解密
pub fn decrypt_aes_gcm(ciphertext_with_nonce: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, aes_gcm::Error> {
    if ciphertext_with_nonce.len() < 12 {
        return Err(aes_gcm::Error);
    }
    
    let cipher = Aes256Gcm::new(key.into());
    
    let (nonce_bytes, ciphertext) = ciphertext_with_nonce.split_at(12);
    let nonce = Nonce::<typenum::U12>::from_slice(nonce_bytes);
    
    cipher.decrypt(nonce, ciphertext)
}
```

### 非对称加密（RSA）

```rust
use rsa::{RsaPrivateKey, RsaPublicKey, Pkcs1v15Encrypt};
use rand::rngs::OsRng;

/// 生成RSA密钥对
pub fn generate_rsa_keypair() -> Result<(RsaPrivateKey, RsaPublicKey), rsa::Error> {
    let mut rng = OsRng;
    let bits = 2048;
    
    let private_key = RsaPrivateKey::new(&mut rng, bits)?;
    let public_key = RsaPublicKey::from(&private_key);
    
    Ok((private_key, public_key))
}

/// RSA加密
pub fn rsa_encrypt(public_key: &RsaPublicKey, plaintext: &[u8]) -> Result<Vec<u8>, rsa::Error> {
    let mut rng = OsRng;
    public_key.encrypt(&mut rng, Pkcs1v15Encrypt, plaintext)
}

/// RSA解密
pub fn rsa_decrypt(private_key: &RsaPrivateKey, ciphertext: &[u8]) -> Result<Vec<u8>, rsa::Error> {
    private_key.decrypt(Pkcs1v15Encrypt, ciphertext)
}
```

### 哈希与HMAC

```rust
use sha2::{Sha256, Digest};
use hmac::{Hmac, Mac};

/// SHA-256哈希
pub fn hash_sha256(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

/// HMAC-SHA256
pub fn hmac_sha256(key: &[u8], message: &[u8]) -> Result<Vec<u8>, hmac::digest::InvalidLength> {
    type HmacSha256 = Hmac<Sha256>;
    
    let mut mac = HmacSha256::new_from_slice(key)?;
    mac.update(message);
    
    Ok(mac.finalize().into_bytes().to_vec())
}

/// 验证HMAC
pub fn verify_hmac_sha256(key: &[u8], message: &[u8], expected: &[u8]) -> bool {
    match hmac_sha256(key, message) {
        Ok(computed) => computed == expected,
        Err(_) => false,
    }
}
```

---

## 7. 安全审计

### 日志与监控

```rust
use tracing::{info, warn, error};

/// 审计日志
pub fn audit_log(user_id: &str, action: &str, resource: &str, result: &str) {
    info!(
        target: "security_audit",
        user_id = user_id,
        action = action,
        resource = resource,
        result = result,
        "安全审计"
    );
}

/// 使用示例
pub async fn sensitive_operation(user_id: &str) -> Result<(), String> {
    audit_log(user_id, "DELETE", "/api/users/123", "ATTEMPT");
    
    // 执行操作
    let result = perform_deletion().await;
    
    match result {
        Ok(_) => {
            audit_log(user_id, "DELETE", "/api/users/123", "SUCCESS");
            Ok(())
        }
        Err(e) => {
            audit_log(user_id, "DELETE", "/api/users/123", "FAILURE");
            Err(e)
        }
    }
}

async fn perform_deletion() -> Result<(), String> {
    Ok(())
}
```

---

## 8. 常见漏洞防护

### CSRF防护

```rust
use axum::{
    extract::{State, Form},
    response::{IntoResponse, Redirect},
    http::{StatusCode, HeaderMap},
};
use serde::Deserialize;

/// CSRF令牌验证
pub fn verify_csrf_token(headers: &HeaderMap, form_token: &str) -> bool {
    if let Some(cookie_token) = headers.get("X-CSRF-Token") {
        if let Ok(token_str) = cookie_token.to_str() {
            return token_str == form_token;
        }
    }
    false
}

#[derive(Deserialize)]
pub struct FormData {
    csrf_token: String,
    data: String,
}

pub async fn submit_form(
    headers: HeaderMap,
    Form(form): Form<FormData>,
) -> Result<String, StatusCode> {
    if !verify_csrf_token(&headers, &form.csrf_token) {
        return Err(StatusCode::FORBIDDEN);
    }
    
    Ok("表单提交成功".into())
}
```

### CORS配置

```rust
use tower_http::cors::{CorsLayer, Any};

/// 安全的CORS配置
pub fn create_cors_layer() -> CorsLayer {
    CorsLayer::new()
        .allow_origin(["https://example.com".parse().unwrap()])
        .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
        .allow_headers([axum::http::header::CONTENT_TYPE])
        .max_age(std::time::Duration::from_secs(3600))
}
```

---

## 9. 安全最佳实践

### 密钥管理

```rust
use std::env;

/// 从环境变量加载密钥
pub fn load_secret_key() -> Result<String, String> {
    env::var("SECRET_KEY").map_err(|_| "SECRET_KEY未设置".into())
}

/// ❌ 不要硬编码密钥
const BAD_SECRET: &str = "my-secret-key"; // 不安全！

/// ✅ 使用环境变量或密钥管理服务
pub fn good_secret() -> String {
    env::var("SECRET_KEY").expect("SECRET_KEY必须设置")
}
```

### 安全响应头

```rust
use axum::{
    http::header,
    middleware::Next,
    response::Response,
    extract::Request,
};

/// 添加安全响应头
pub async fn security_headers_middleware(
    req: Request,
    next: Next,
) -> Response {
    let mut response = next.run(req).await;
    
    let headers = response.headers_mut();
    
    headers.insert(
        header::STRICT_TRANSPORT_SECURITY,
        "max-age=31536000; includeSubDomains".parse().unwrap(),
    );
    
    headers.insert(
        header::X_CONTENT_TYPE_OPTIONS,
        "nosniff".parse().unwrap(),
    );
    
    headers.insert(
        header::X_FRAME_OPTIONS,
        "DENY".parse().unwrap(),
    );
    
    headers.insert(
        "X-XSS-Protection",
        "1; mode=block".parse().unwrap(),
    );
    
    headers.insert(
        header::CONTENT_SECURITY_POLICY,
        "default-src 'self'".parse().unwrap(),
    );
    
    response
}
```

---

## 10. 安全测试

### 模糊测试

```rust
#[cfg(test)]
mod fuzz_tests {
    use super::*;
    
    #[test]
    fn fuzz_input_validation() {
        use arbitrary::Arbitrary;
        use arbitrary::Unstructured;
        
        let data = vec![0u8; 1024];
        let mut unstructured = Unstructured::new(&data);
        
        for _ in 0..1000 {
            if let Ok(input) = String::arbitrary(&mut unstructured) {
                let _ = validate_input(&input);
            }
        }
    }
}

fn validate_input(input: &str) -> Result<(), String> {
    if input.len() > 1000 {
        return Err("输入太长".into());
    }
    Ok(())
}
```

### 渗透测试

```bash
#!/bin/bash
# 安全测试脚本

# SQL注入测试
curl "http://localhost:8080/api/users?id=1'OR'1'='1"

# XSS测试
curl -X POST -d "data=<script>alert('XSS')</script>" http://localhost:8080/api/submit

# CSRF测试
curl -X POST -H "Content-Type: application/json" \
  -d '{"action":"delete"}' \
  http://localhost:8080/api/sensitive

# DoS测试
ab -n 100000 -c 1000 http://localhost:8080/
```

---

**文档完成**: 本参考涵盖了Rust网络编程的关键安全实践。

**下一步**: 查看 [Tier 4高级主题](../tier_04_advanced/) 深入学习网络安全理论。
