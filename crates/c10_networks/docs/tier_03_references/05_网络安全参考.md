# ç½‘ç»œå®‰å…¨å‚è€ƒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
> **æ›´æ–°æ—¥æœŸ**: 2025-10-23
> **Rust ç‰ˆæœ¬**: 1.90+
> **æ–‡æ¡£å±‚çº§**: Tier 3 - æŠ€æœ¯å‚è€ƒ

---

## ç›®å½•

- [ç½‘ç»œå®‰å…¨å‚è€ƒ](#ç½‘ç»œå®‰å…¨å‚è€ƒ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. TLS/SSLå®‰å…¨é…ç½®](#1-tlssslå®‰å…¨é…ç½®)
    - [rustlsç”Ÿäº§é…ç½®](#rustlsç”Ÿäº§é…ç½®)
    - [åŠ å¯†å¥—ä»¶é…ç½®](#åŠ å¯†å¥—ä»¶é…ç½®)
  - [2. è¯ä¹¦ç®¡ç†](#2-è¯ä¹¦ç®¡ç†)
    - [è‡ªç­¾åè¯ä¹¦ç”Ÿæˆ](#è‡ªç­¾åè¯ä¹¦ç”Ÿæˆ)
    - [è¯ä¹¦éªŒè¯](#è¯ä¹¦éªŒè¯)
  - [3. è®¤è¯ä¸æˆæƒ](#3-è®¤è¯ä¸æˆæƒ)
    - [JWTè®¤è¯](#jwtè®¤è¯)
    - [OAuth2å®ç°](#oauth2å®ç°)
  - [4. è¾“å…¥éªŒè¯ä¸è¿‡æ»¤](#4-è¾“å…¥éªŒè¯ä¸è¿‡æ»¤)
    - [SQLæ³¨å…¥é˜²æŠ¤](#sqlæ³¨å…¥é˜²æŠ¤)
    - [XSSé˜²æŠ¤](#xssé˜²æŠ¤)
    - [è·¯å¾„éå†é˜²æŠ¤](#è·¯å¾„éå†é˜²æŠ¤)
  - [5. DoSé˜²æŠ¤](#5-dosé˜²æŠ¤)
    - [é€Ÿç‡é™åˆ¶](#é€Ÿç‡é™åˆ¶)
    - [è¿æ¥é™åˆ¶](#è¿æ¥é™åˆ¶)
    - [è¯·æ±‚å¤§å°é™åˆ¶](#è¯·æ±‚å¤§å°é™åˆ¶)
  - [6. åŠ å¯†é€šä¿¡](#6-åŠ å¯†é€šä¿¡)
    - [å¯¹ç§°åŠ å¯†ï¼ˆAES-GCMï¼‰](#å¯¹ç§°åŠ å¯†aes-gcm)
    - [éå¯¹ç§°åŠ å¯†ï¼ˆRSAï¼‰](#éå¯¹ç§°åŠ å¯†rsa)
    - [å“ˆå¸Œä¸HMAC](#å“ˆå¸Œä¸hmac)
  - [7. å®‰å…¨å®¡è®¡](#7-å®‰å…¨å®¡è®¡)
    - [æ—¥å¿—ä¸ç›‘æ§](#æ—¥å¿—ä¸ç›‘æ§)
  - [8. å¸¸è§æ¼æ´é˜²æŠ¤](#8-å¸¸è§æ¼æ´é˜²æŠ¤)
    - [CSRFé˜²æŠ¤](#csrfé˜²æŠ¤)
    - [CORSé…ç½®](#corsé…ç½®)
  - [9. å®‰å…¨æœ€ä½³å®è·µ](#9-å®‰å…¨æœ€ä½³å®è·µ)
    - [å¯†é’¥ç®¡ç†](#å¯†é’¥ç®¡ç†)
    - [å®‰å…¨å“åº”å¤´](#å®‰å…¨å“åº”å¤´)
  - [10. å®‰å…¨æµ‹è¯•](#10-å®‰å…¨æµ‹è¯•)
    - [æ¨¡ç³Šæµ‹è¯•](#æ¨¡ç³Šæµ‹è¯•)
    - [æ¸—é€æµ‹è¯•](#æ¸—é€æµ‹è¯•)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç½‘ç»œå®‰å…¨å‚è€ƒ (Network Security Reference)**:

- **å®šä¹‰**: ç½‘ç»œç¼–ç¨‹å®‰å…¨é…ç½®å’Œå®è·µçš„æŠ€æœ¯å‚è€ƒ
- **ç±»å‹**: å®‰å…¨å‚è€ƒæ–‡æ¡£
- **èŒƒç•´**: ç½‘ç»œå®‰å…¨ã€å®‰å…¨ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: TLS/SSLã€è®¤è¯æˆæƒã€åŠ å¯†é€šä¿¡ã€å®‰å…¨é˜²æŠ¤

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **TLS/SSL**: åŠ å¯†é€šä¿¡é…ç½®
- **è®¤è¯æˆæƒ**: JWTã€OAuth2
- **è¾“å…¥éªŒè¯**: SQLæ³¨å…¥é˜²æŠ¤ã€XSSé˜²æŠ¤
- **DoS é˜²æŠ¤**: é€Ÿç‡é™åˆ¶ã€è¿æ¥é™åˆ¶

**å®‰å…¨ç‰¹å¾**:

- **åŠ å¯†é€šä¿¡**: ä½¿ç”¨ TLS/SSL
- **è®¤è¯æœºåˆ¶**: JWTã€OAuth2
- **é˜²æŠ¤æœºåˆ¶**: è¾“å…¥éªŒè¯ã€DoS é˜²æŠ¤
- **é€‚ç”¨åœºæ™¯**: ç”Ÿäº§ç¯å¢ƒã€å®‰å…¨å…³é”®åº”ç”¨

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ç½‘ç»œå®‰å…¨å‚è€ƒ --[uses]--> å¤šç§å®‰å…¨æŠ€æœ¯
- å®‰å…¨åº”ç”¨ --[uses]--> ç½‘ç»œå®‰å…¨å‚è€ƒ

**ä¾èµ–å…³ç³»**:

- ç½‘ç»œå®‰å…¨å‚è€ƒ --[depends-on]--> åŠ å¯†åº“
- å®‰å…¨é…ç½® --[depends-on]--> ç½‘ç»œå®‰å…¨å‚è€ƒ

### æ€ç»´å¯¼å›¾

```text
ç½‘ç»œå®‰å…¨å‚è€ƒ
â”‚
â”œâ”€â”€ TLS/SSL å®‰å…¨é…ç½®
â”‚   â””â”€â”€ rustls é…ç½®
â”œâ”€â”€ è¯ä¹¦ç®¡ç†
â”‚   â”œâ”€â”€ è¯ä¹¦ç”Ÿæˆ
â”‚   â””â”€â”€ è¯ä¹¦éªŒè¯
â”œâ”€â”€ è®¤è¯ä¸æˆæƒ
â”‚   â”œâ”€â”€ JWT
â”‚   â””â”€â”€ OAuth2
â”œâ”€â”€ è¾“å…¥éªŒè¯ä¸è¿‡æ»¤
â”‚   â”œâ”€â”€ SQLæ³¨å…¥é˜²æŠ¤
â”‚   â””â”€â”€ XSSé˜²æŠ¤
â”œâ”€â”€ DoS é˜²æŠ¤
â”‚   â”œâ”€â”€ é€Ÿç‡é™åˆ¶
â”‚   â””â”€â”€ è¿æ¥é™åˆ¶
â””â”€â”€ åŠ å¯†é€šä¿¡
    â”œâ”€â”€ å¯¹ç§°åŠ å¯†
    â””â”€â”€ éå¯¹ç§°åŠ å¯†
```

---

## 1. TLS/SSLå®‰å…¨é…ç½®

### rustlsç”Ÿäº§é…ç½®

```rust
use tokio_rustls::{TlsAcceptor, rustls};
use std::sync::Arc;
use std::fs;

/// åˆ›å»ºå®‰å…¨çš„TLSé…ç½®
pub fn create_secure_tls_config() -> Result<rustls::ServerConfig, Box<dyn std::error::Error>> {
    // åŠ è½½è¯ä¹¦å’Œç§é’¥
    let cert = fs::read("cert.pem")?;
    let key = fs::read("key.pem")?;

    let certs = rustls_pemfile::certs(&mut &cert[..])
        .map(|mut certs| certs.drain(..).map(rustls::Certificate).collect())
        .unwrap();

    let key = rustls_pemfile::pkcs8_private_keys(&mut &key[..])
        .map(|mut keys| rustls::PrivateKey(keys.remove(0)))
        .unwrap();

    let mut config = rustls::ServerConfig::builder()
        .with_safe_default_cipher_suites() // å®‰å…¨çš„åŠ å¯†å¥—ä»¶
        .with_safe_default_kx_groups()     // å®‰å…¨çš„å¯†é’¥äº¤æ¢
        .with_protocol_versions(&[&rustls::version::TLS13])? // ä»…TLS 1.3
        .with_no_client_auth()
        .with_single_cert(certs, key)?;

    // ALPNåè®®
    config.alpn_protocols = vec![b"h2".to_vec(), b"http/1.1".to_vec()];

    Ok(config)
}

/// TLSæœåŠ¡å™¨
pub async fn secure_tls_server() -> Result<(), Box<dyn std::error::Error>> {
    let config = create_secure_tls_config()?;
    let acceptor = TlsAcceptor::from(Arc::new(config));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:443").await?;

    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = acceptor.clone();

        tokio::spawn(async move {
            match acceptor.accept(stream).await {
                Ok(tls_stream) => {
                    println!("å®‰å…¨è¿æ¥æ¥è‡ª: {}", peer_addr);
                    // å¤„ç†TLSæµ
                }
                Err(e) => eprintln!("TLSæ¡æ‰‹å¤±è´¥: {}", e),
            }
        });
    }
}
```

### åŠ å¯†å¥—ä»¶é…ç½®

```rust
/// è‡ªå®šä¹‰åŠ å¯†å¥—ä»¶ï¼ˆä»…æ¨èçš„ï¼‰
pub fn create_custom_cipher_suites() -> Vec<rustls::SupportedCipherSuite> {
    use rustls::cipher_suite;

    vec![
        cipher_suite::TLS13_AES_256_GCM_SHA384,      // AEAD
        cipher_suite::TLS13_AES_128_GCM_SHA256,      // AEAD
        cipher_suite::TLS13_CHACHA20_POLY1305_SHA256, // AEAD
    ]
}
```

---

## 2. è¯ä¹¦ç®¡ç†

### è‡ªç­¾åè¯ä¹¦ç”Ÿæˆ

```rust
use rcgen::{Certificate, CertificateParams, DistinguishedName};
use std::fs;

/// ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
pub fn generate_self_signed_cert() -> Result<Certificate, Box<dyn std::error::Error>> {
    let mut params = CertificateParams::new(vec!["localhost".to_string()]);

    params.distinguished_name = DistinguishedName::new();
    params.distinguished_name.push(rcgen::DnType::CommonName, "My Server");
    params.distinguished_name.push(rcgen::DnType::OrganizationName, "My Company");

    let cert = Certificate::from_params(params)?;

    // ä¿å­˜è¯ä¹¦å’Œç§é’¥
    fs::write("cert.pem", cert.serialize_pem()?)?;
    fs::write("key.pem", cert.serialize_private_key_pem())?;

    Ok(cert)
}
```

### è¯ä¹¦éªŒè¯

```rust
use rustls::client::ServerCertVerifier;
use rustls::Certificate;

/// è‡ªå®šä¹‰è¯ä¹¦éªŒè¯å™¨
pub struct CustomCertVerifier;

impl ServerCertVerifier for CustomCertVerifier {
    fn verify_server_cert(
        &self,
        end_entity: &Certificate,
        intermediates: &[Certificate],
        server_name: &rustls::ServerName,
        scts: &mut dyn Iterator<Item = &[u8]>,
        ocsp_response: &[u8],
        now: std::time::SystemTime,
    ) -> Result<rustls::client::ServerCertVerified, rustls::Error> {
        // è‡ªå®šä¹‰éªŒè¯é€»è¾‘
        println!("éªŒè¯è¯ä¹¦: {:?}", server_name);

        // éªŒè¯è¯ä¹¦é“¾ã€åŠé”€çŠ¶æ€ç­‰

        Ok(rustls::client::ServerCertVerified::assertion())
    }
}
```

---

## 3. è®¤è¯ä¸æˆæƒ

### JWTè®¤è¯

```rust
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Deserialize, Serialize};
use chrono::{Utc, Duration};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String, // ç”¨æˆ·ID
    exp: usize,  // è¿‡æœŸæ—¶é—´
    iat: usize,  // ç­¾å‘æ—¶é—´
    role: String,
}

/// ç”ŸæˆJWTä»¤ç‰Œ
pub fn generate_jwt(user_id: &str, role: &str, secret: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::hours(24))
        .unwrap()
        .timestamp() as usize;

    let claims = Claims {
        sub: user_id.to_owned(),
        exp: expiration,
        iat: Utc::now().timestamp() as usize,
        role: role.to_owned(),
    };

    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))
}

/// éªŒè¯JWTä»¤ç‰Œ
pub fn verify_jwt(token: &str, secret: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_ref()),
        &Validation::default(),
    ).map(|data| data.claims)
}

/// axumä¸­é—´ä»¶
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn jwt_auth_middleware<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    let token = auth_header
        .strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;

    verify_jwt(token, "your-secret-key")
        .map_err(|_| StatusCode::UNAUTHORIZED)?;

    Ok(next.run(req).await)
}
```

### OAuth2å®ç°

```rust
use oauth2::{
    AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl,
    basic::BasicClient,
    reqwest::async_http_client,
    AuthorizationCode, CsrfToken, PkceCodeChallenge, Scope,
};

/// OAuth2å®¢æˆ·ç«¯é…ç½®
pub fn create_oauth2_client() -> BasicClient {
    BasicClient::new(
        ClientId::new("client_id".to_string()),
        Some(ClientSecret::new("client_secret".to_string())),
        AuthUrl::new("https://auth.example.com/oauth/authorize".to_string()).unwrap(),
        Some(TokenUrl::new("https://auth.example.com/oauth/token".to_string()).unwrap()),
    )
    .set_redirect_uri(RedirectUrl::new("http://localhost:8080/callback".to_string()).unwrap())
}

/// OAuth2æˆæƒæµç¨‹
pub async fn oauth2_flow() -> Result<(), Box<dyn std::error::Error>> {
    let client = create_oauth2_client();

    // ç”ŸæˆPKCEæŒ‘æˆ˜
    let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

    // ç”ŸæˆæˆæƒURL
    let (auth_url, csrf_token) = client
        .authorize_url(CsrfToken::new_random)
        .add_scope(Scope::new("read".to_string()))
        .add_scope(Scope::new("write".to_string()))
        .set_pkce_challenge(pkce_challenge)
        .url();

    println!("è®¿é—®: {}", auth_url);

    // ç”¨æˆ·æˆæƒåï¼Œä½¿ç”¨codeæ¢å–token
    let code = AuthorizationCode::new("auth_code_from_callback".to_string());

    let token_result = client
        .exchange_code(code)
        .set_pkce_verifier(pkce_verifier)
        .request_async(async_http_client)
        .await?;

    println!("Access Token: {}", token_result.access_token().secret());

    Ok(())
}
```

---

## 4. è¾“å…¥éªŒè¯ä¸è¿‡æ»¤

### SQLæ³¨å…¥é˜²æŠ¤

```rust
use sqlx::{PgPool, FromRow};

#[derive(Debug, FromRow)]
struct User {
    id: i32,
    username: String,
}

/// âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
pub async fn safe_query(pool: &PgPool, username: &str) -> Result<Vec<User>, sqlx::Error> {
    sqlx::query_as::<_, User>("SELECT id, username FROM users WHERE username = $1")
        .bind(username) // å‚æ•°åŒ–ï¼Œé˜²æ­¢SQLæ³¨å…¥
        .fetch_all(pool)
        .await
}

/// âŒ ä¸å®‰å…¨çš„æŸ¥è¯¢ï¼ˆæ‹¼æ¥SQLï¼‰
pub async fn unsafe_query(pool: &PgPool, username: &str) -> Result<Vec<User>, sqlx::Error> {
    let sql = format!("SELECT id, username FROM users WHERE username = '{}'", username);
    sqlx::query_as::<_, User>(&sql) // æ˜“å—SQLæ³¨å…¥æ”»å‡»
        .fetch_all(pool)
        .await
}
```

### XSSé˜²æŠ¤

```rust
use ammonia::clean;

/// XSSè¿‡æ»¤
pub fn sanitize_html(input: &str) -> String {
    clean(input)
}

/// ç¤ºä¾‹
pub fn xss_protection_example() {
    let malicious_input = r#"<script>alert('XSS')</script>Hello"#;
    let safe_output = sanitize_html(malicious_input);

    println!("åŸå§‹: {}", malicious_input);
    println!("è¿‡æ»¤å: {}", safe_output); // "Hello"
}
```

### è·¯å¾„éå†é˜²æŠ¤

```rust
use std::path::{Path, PathBuf};

/// å®‰å…¨çš„æ–‡ä»¶è·¯å¾„éªŒè¯
pub fn validate_file_path(base_dir: &Path, requested_path: &str) -> Result<PathBuf, String> {
    let requested = Path::new(requested_path);

    // æ‹’ç»ç»å¯¹è·¯å¾„
    if requested.is_absolute() {
        return Err("ä¸å…è®¸ç»å¯¹è·¯å¾„".into());
    }

    // æ‹’ç»".."
    if requested.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
        return Err("ä¸å…è®¸è·¯å¾„éå†".into());
    }

    let full_path = base_dir.join(requested);

    // ç¡®ä¿è·¯å¾„åœ¨åŸºç¡€ç›®å½•å†…
    if !full_path.starts_with(base_dir) {
        return Err("è·¯å¾„è¶…å‡ºåŸºç¡€ç›®å½•".into());
    }

    Ok(full_path)
}
```

---

## 5. DoSé˜²æŠ¤

### é€Ÿç‡é™åˆ¶

```rust
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};

/// ç®€å•çš„é€Ÿç‡é™åˆ¶å™¨
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }

    /// æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚
    pub async fn check(&self, client_id: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();

        let client_requests = requests.entry(client_id.to_string()).or_insert_with(Vec::new);

        // ç§»é™¤è¿‡æœŸè¯·æ±‚
        client_requests.retain(|&t| now.duration_since(t) < self.window);

        if client_requests.len() >= self.max_requests {
            return false; // è¶…è¿‡é™åˆ¶
        }

        client_requests.push(now);
        true
    }
}

/// axumä¸­é—´ä»¶
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
    extract::ConnectInfo,
};
use std::net::SocketAddr;

pub async fn rate_limit_middleware<B>(
    ConnectInfo(addr): ConnectInfo<SocketAddr>,
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let limiter = RateLimiter::new(100, Duration::from_secs(60)); // æ¯åˆ†é’Ÿ100æ¬¡

    let client_id = addr.ip().to_string();

    if !limiter.check(&client_id).await {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }

    Ok(next.run(req).await)
}
```

### è¿æ¥é™åˆ¶

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

/// æœ€å¤§å¹¶å‘è¿æ¥é™åˆ¶
pub struct ConnectionLimiter {
    semaphore: Arc<Semaphore>,
}

impl ConnectionLimiter {
    pub fn new(max_connections: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_connections)),
        }
    }

    /// è·å–è¿æ¥è®¸å¯
    pub async fn acquire(&self) -> tokio::sync::SemaphorePermit<'_> {
        self.semaphore.acquire().await.unwrap()
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn limited_tcp_server() -> std::io::Result<()> {
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    let limiter = ConnectionLimiter::new(1000); // æœ€å¤š1000ä¸ªè¿æ¥

    loop {
        let (stream, _) = listener.accept().await?;
        let permit = limiter.acquire().await;

        tokio::spawn(async move {
            // å¤„ç†è¿æ¥
            drop(permit); // é‡Šæ”¾è®¸å¯
        });
    }
}
```

### è¯·æ±‚å¤§å°é™åˆ¶

```rust
use axum::{
    body::Body,
    extract::Request,
    middleware::Next,
    response::Response,
    http::StatusCode,
};

/// é™åˆ¶è¯·æ±‚ä½“å¤§å°
pub async fn limit_request_size(
    req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    const MAX_SIZE: u64 = 10 * 1024 * 1024; // 10MB

    if let Some(content_length) = req.headers().get("content-length") {
        if let Ok(length_str) = content_length.to_str() {
            if let Ok(length) = length_str.parse::<u64>() {
                if length > MAX_SIZE {
                    return Err(StatusCode::PAYLOAD_TOO_LARGE);
                }
            }
        }
    }

    Ok(next.run(req).await)
}
```

---

## 6. åŠ å¯†é€šä¿¡

### å¯¹ç§°åŠ å¯†ï¼ˆAES-GCMï¼‰

```rust
use aes_gcm::{Aes256Gcm, KeyInit};
use aes_gcm::aead::{Aead, Nonce};
use rand::RngCore;

/// AES-256-GCMåŠ å¯†
pub fn encrypt_aes_gcm(plaintext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, aes_gcm::Error> {
    let cipher = Aes256Gcm::new(key.into());

    // ç”Ÿæˆéšæœºnonce
    let mut nonce_bytes = [0u8; 12];
    rand::thread_rng().fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::<typenum::U12>::from_slice(&nonce_bytes);

    let ciphertext = cipher.encrypt(nonce, plaintext)?;

    // æ‹¼æ¥nonceå’Œå¯†æ–‡
    let mut result = nonce_bytes.to_vec();
    result.extend_from_slice(&ciphertext);

    Ok(result)
}

/// AES-256-GCMè§£å¯†
pub fn decrypt_aes_gcm(ciphertext_with_nonce: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, aes_gcm::Error> {
    if ciphertext_with_nonce.len() < 12 {
        return Err(aes_gcm::Error);
    }

    let cipher = Aes256Gcm::new(key.into());

    let (nonce_bytes, ciphertext) = ciphertext_with_nonce.split_at(12);
    let nonce = Nonce::<typenum::U12>::from_slice(nonce_bytes);

    cipher.decrypt(nonce, ciphertext)
}
```

### éå¯¹ç§°åŠ å¯†ï¼ˆRSAï¼‰

```rust
use rsa::{RsaPrivateKey, RsaPublicKey, Pkcs1v15Encrypt};
use rand::rngs::OsRng;

/// ç”ŸæˆRSAå¯†é’¥å¯¹
pub fn generate_rsa_keypair() -> Result<(RsaPrivateKey, RsaPublicKey), rsa::Error> {
    let mut rng = OsRng;
    let bits = 2048;

    let private_key = RsaPrivateKey::new(&mut rng, bits)?;
    let public_key = RsaPublicKey::from(&private_key);

    Ok((private_key, public_key))
}

/// RSAåŠ å¯†
pub fn rsa_encrypt(public_key: &RsaPublicKey, plaintext: &[u8]) -> Result<Vec<u8>, rsa::Error> {
    let mut rng = OsRng;
    public_key.encrypt(&mut rng, Pkcs1v15Encrypt, plaintext)
}

/// RSAè§£å¯†
pub fn rsa_decrypt(private_key: &RsaPrivateKey, ciphertext: &[u8]) -> Result<Vec<u8>, rsa::Error> {
    private_key.decrypt(Pkcs1v15Encrypt, ciphertext)
}
```

### å“ˆå¸Œä¸HMAC

```rust
use sha2::{Sha256, Digest};
use hmac::{Hmac, Mac};

/// SHA-256å“ˆå¸Œ
pub fn hash_sha256(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

/// HMAC-SHA256
pub fn hmac_sha256(key: &[u8], message: &[u8]) -> Result<Vec<u8>, hmac::digest::InvalidLength> {
    type HmacSha256 = Hmac<Sha256>;

    let mut mac = HmacSha256::new_from_slice(key)?;
    mac.update(message);

    Ok(mac.finalize().into_bytes().to_vec())
}

/// éªŒè¯HMAC
pub fn verify_hmac_sha256(key: &[u8], message: &[u8], expected: &[u8]) -> bool {
    match hmac_sha256(key, message) {
        Ok(computed) => computed == expected,
        Err(_) => false,
    }
}
```

---

## 7. å®‰å…¨å®¡è®¡

### æ—¥å¿—ä¸ç›‘æ§

```rust
use tracing::{info, warn, error};

/// å®¡è®¡æ—¥å¿—
pub fn audit_log(user_id: &str, action: &str, resource: &str, result: &str) {
    info!(
        target: "security_audit",
        user_id = user_id,
        action = action,
        resource = resource,
        result = result,
        "å®‰å…¨å®¡è®¡"
    );
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn sensitive_operation(user_id: &str) -> Result<(), String> {
    audit_log(user_id, "DELETE", "/api/users/123", "ATTEMPT");

    // æ‰§è¡Œæ“ä½œ
    let result = perform_deletion().await;

    match result {
        Ok(_) => {
            audit_log(user_id, "DELETE", "/api/users/123", "SUCCESS");
            Ok(())
        }
        Err(e) => {
            audit_log(user_id, "DELETE", "/api/users/123", "FAILURE");
            Err(e)
        }
    }
}

async fn perform_deletion() -> Result<(), String> {
    Ok(())
}
```

---

## 8. å¸¸è§æ¼æ´é˜²æŠ¤

### CSRFé˜²æŠ¤

```rust
use axum::{
    extract::{State, Form},
    response::{IntoResponse, Redirect},
    http::{StatusCode, HeaderMap},
};
use serde::Deserialize;

/// CSRFä»¤ç‰ŒéªŒè¯
pub fn verify_csrf_token(headers: &HeaderMap, form_token: &str) -> bool {
    if let Some(cookie_token) = headers.get("X-CSRF-Token") {
        if let Ok(token_str) = cookie_token.to_str() {
            return token_str == form_token;
        }
    }
    false
}

#[derive(Deserialize)]
pub struct FormData {
    csrf_token: String,
    data: String,
}

pub async fn submit_form(
    headers: HeaderMap,
    Form(form): Form<FormData>,
) -> Result<String, StatusCode> {
    if !verify_csrf_token(&headers, &form.csrf_token) {
        return Err(StatusCode::FORBIDDEN);
    }

    Ok("è¡¨å•æäº¤æˆåŠŸ".into())
}
```

### CORSé…ç½®

```rust
use tower_http::cors::{CorsLayer, Any};

/// å®‰å…¨çš„CORSé…ç½®
pub fn create_cors_layer() -> CorsLayer {
    CorsLayer::new()
        .allow_origin(["https://example.com".parse().unwrap()])
        .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
        .allow_headers([axum::http::header::CONTENT_TYPE])
        .max_age(std::time::Duration::from_secs(3600))
}
```

---

## 9. å®‰å…¨æœ€ä½³å®è·µ

### å¯†é’¥ç®¡ç†

```rust
use std::env;

/// ä»ç¯å¢ƒå˜é‡åŠ è½½å¯†é’¥
pub fn load_secret_key() -> Result<String, String> {
    env::var("SECRET_KEY").map_err(|_| "SECRET_KEYæœªè®¾ç½®".into())
}

/// âŒ ä¸è¦ç¡¬ç¼–ç å¯†é’¥
const BAD_SECRET: &str = "my-secret-key"; // ä¸å®‰å…¨ï¼

/// âœ… ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡
pub fn good_secret() -> String {
    env::var("SECRET_KEY").expect("SECRET_KEYå¿…é¡»è®¾ç½®")
}
```

### å®‰å…¨å“åº”å¤´

```rust
use axum::{
    http::header,
    middleware::Next,
    response::Response,
    extract::Request,
};

/// æ·»åŠ å®‰å…¨å“åº”å¤´
pub async fn security_headers_middleware(
    req: Request,
    next: Next,
) -> Response {
    let mut response = next.run(req).await;

    let headers = response.headers_mut();

    headers.insert(
        header::STRICT_TRANSPORT_SECURITY,
        "max-age=31536000; includeSubDomains".parse().unwrap(),
    );

    headers.insert(
        header::X_CONTENT_TYPE_OPTIONS,
        "nosniff".parse().unwrap(),
    );

    headers.insert(
        header::X_FRAME_OPTIONS,
        "DENY".parse().unwrap(),
    );

    headers.insert(
        "X-XSS-Protection",
        "1; mode=block".parse().unwrap(),
    );

    headers.insert(
        header::CONTENT_SECURITY_POLICY,
        "default-src 'self'".parse().unwrap(),
    );

    response
}
```

---

## 10. å®‰å…¨æµ‹è¯•

### æ¨¡ç³Šæµ‹è¯•

```rust
#[cfg(test)]
mod fuzz_tests {
    use super::*;

    #[test]
    fn fuzz_input_validation() {
        use arbitrary::Arbitrary;
        use arbitrary::Unstructured;

        let data = vec![0u8; 1024];
        let mut unstructured = Unstructured::new(&data);

        for _ in 0..1000 {
            if let Ok(input) = String::arbitrary(&mut unstructured) {
                let _ = validate_input(&input);
            }
        }
    }
}

fn validate_input(input: &str) -> Result<(), String> {
    if input.len() > 1000 {
        return Err("è¾“å…¥å¤ªé•¿".into());
    }
    Ok(())
}
```

### æ¸—é€æµ‹è¯•

```bash
#!/bin/bash
# å®‰å…¨æµ‹è¯•è„šæœ¬

# SQLæ³¨å…¥æµ‹è¯•
curl "http://localhost:8080/api/users?id=1'OR'1'='1"

# XSSæµ‹è¯•
curl -X POST -d "data=<script>alert('XSS')</script>" http://localhost:8080/api/submit

# CSRFæµ‹è¯•
curl -X POST -H "Content-Type: application/json" \
  -d '{"action":"delete"}' \
  http://localhost:8080/api/sensitive

# DoSæµ‹è¯•
ab -n 100000 -c 1000 http://localhost:8080/
```

---

**æ–‡æ¡£å®Œæˆ**: æœ¬å‚è€ƒæ¶µç›–äº†Rustç½‘ç»œç¼–ç¨‹çš„å…³é”®å®‰å…¨å®è·µã€‚

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ [Tier 4é«˜çº§ä¸»é¢˜](../tier_04_advanced/) æ·±å…¥å­¦ä¹ ç½‘ç»œå®‰å…¨ç†è®ºã€‚
