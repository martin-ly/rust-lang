# è‡ªå®šä¹‰åè®®å®ç°

**ä¸»é¢˜**: äºŒè¿›åˆ¶åè®®è®¾è®¡ã€çŠ¶æ€æœºã€é›¶æ‹·è´åºåˆ—åŒ–
**éš¾åº¦**: â­â­â­â­â­
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 18-22 å°æ—¶

---

## ğŸ“– ç›®å½•

- [è‡ªå®šä¹‰åè®®å®ç°](#è‡ªå®šä¹‰åè®®å®ç°)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [1. åè®®è®¾è®¡åŸåˆ™](#1-åè®®è®¾è®¡åŸåˆ™)
    - [1.1 åè®®è®¾è®¡åŸºç¡€](#11-åè®®è®¾è®¡åŸºç¡€)
  - [2. äºŒè¿›åˆ¶åè®®è®¾è®¡](#2-äºŒè¿›åˆ¶åè®®è®¾è®¡)
    - [2.1 åè®®å¸§ç»“æ„](#21-åè®®å¸§ç»“æ„)
    - [2.2 é«˜çº§ç‰¹æ€§: å‹ç¼©ä¸åŠ å¯†](#22-é«˜çº§ç‰¹æ€§-å‹ç¼©ä¸åŠ å¯†)
  - [3. åè®®çŠ¶æ€æœºå®ç°](#3-åè®®çŠ¶æ€æœºå®ç°)
    - [3.1 çŠ¶æ€æœºè®¾è®¡](#31-çŠ¶æ€æœºè®¾è®¡)
    - [3.2 å®Œæ•´å®¢æˆ·ç«¯å®ç°](#32-å®Œæ•´å®¢æˆ·ç«¯å®ç°)
  - [4. é›¶æ‹·è´åºåˆ—åŒ–](#4-é›¶æ‹·è´åºåˆ—åŒ–)
    - [4.1 Cap'n Proto é£æ ¼çš„åºåˆ—åŒ–](#41-capn-proto-é£æ ¼çš„åºåˆ—åŒ–)
    - [4.2 æ€§èƒ½åŸºå‡†å¯¹æ¯”](#42-æ€§èƒ½åŸºå‡†å¯¹æ¯”)
  - [5. åè®®æ€§èƒ½ä¼˜åŒ–](#5-åè®®æ€§èƒ½ä¼˜åŒ–)
    - [5.1 æ‰¹é‡å¤„ç†](#51-æ‰¹é‡å¤„ç†)
    - [5.2 æµå¼ä¼ è¾“](#52-æµå¼ä¼ è¾“)
  - [6. å®Œæ•´RPCæ¡†æ¶å®ç°](#6-å®Œæ•´rpcæ¡†æ¶å®ç°)
    - [6.1 æœåŠ¡å™¨ç«¯æ¡†æ¶](#61-æœåŠ¡å™¨ç«¯æ¡†æ¶)
  - [7. ç”Ÿäº§çº§å®è·µ](#7-ç”Ÿäº§çº§å®è·µ)
    - [7.1 é”™è¯¯å¤„ç†ä¸é‡è¯•](#71-é”™è¯¯å¤„ç†ä¸é‡è¯•)
    - [7.2 æ€§èƒ½ç›‘æ§](#72-æ€§èƒ½ç›‘æ§)
  - [æ€»ç»“](#æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)

---

## 1. åè®®è®¾è®¡åŸåˆ™

### 1.1 åè®®è®¾è®¡åŸºç¡€

**ä¼˜ç§€åè®®çš„ç‰¹å¾**:

```rust
/// åè®®è®¾è®¡è¯„ä¼°æ ‡å‡†
#[derive(Debug)]
struct ProtocolQuality {
    // 1. æ€§èƒ½æŒ‡æ ‡
    serialization_speed: f64,    // åºåˆ—åŒ–é€Ÿåº¦ (MB/s)
    deserialization_speed: f64,  // ååºåˆ—åŒ–é€Ÿåº¦ (MB/s)
    overhead_percentage: f32,    // åè®®å¼€é”€ (%)

    // 2. å¯æ‰©å±•æ€§
    backward_compatible: bool,   // å‘åå…¼å®¹
    forward_compatible: bool,    // å‘å‰å…¼å®¹
    schema_evolution: bool,      // æ¨¡å¼æ¼”åŒ–æ”¯æŒ

    // 3. æ˜“ç”¨æ€§
    human_readable: bool,        // äººç±»å¯è¯»
    debug_friendly: bool,        // è°ƒè¯•å‹å¥½
    tooling_support: bool,       // å·¥å…·æ”¯æŒ

    // 4. å®‰å…¨æ€§
    length_prefix: bool,         // é•¿åº¦å‰ç¼€ (é˜²æ­¢ç¼“å†²åŒºæº¢å‡º)
    checksum: bool,              // æ ¡éªŒå’Œ
    encryption_ready: bool,      // åŠ å¯†å°±ç»ª
}

// åè®®å¯¹æ¯”
fn compare_protocols() {
    let json = ProtocolQuality {
        serialization_speed: 50.0,
        deserialization_speed: 40.0,
        overhead_percentage: 250.0,  // 2.5xå¼€é”€!
        backward_compatible: true,
        human_readable: true,
        debug_friendly: true,
        ..Default::default()
    };

    let protobuf = ProtocolQuality {
        serialization_speed: 400.0,
        deserialization_speed: 600.0,
        overhead_percentage: 30.0,   // ä»…30%å¼€é”€
        backward_compatible: true,
        forward_compatible: true,
        schema_evolution: true,
        human_readable: false,
        debug_friendly: false,
        ..Default::default()
    };

    let custom_binary = ProtocolQuality {
        serialization_speed: 1200.0,  // æå¿«!
        deserialization_speed: 1500.0,
        overhead_percentage: 5.0,     // æå°å¼€é”€
        backward_compatible: false,   // éœ€è¦è‡ªè¡Œå¤„ç†
        human_readable: false,
        ..Default::default()
    };
}
```

---

## 2. äºŒè¿›åˆ¶åè®®è®¾è®¡

### 2.1 åè®®å¸§ç»“æ„

**é«˜æ•ˆçš„å¸§æ ¼å¼è®¾è®¡**:

```rust
use std::io::{self, Read, Write};
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};

/// è‡ªå®šä¹‰åè®®å¸§æ ¼å¼
///
/// +--------+--------+--------+------------+----------+----------+
/// | Magic  | Version| MsgType| Length     | Seq ID   | Payload  |
/// | (2B)   | (1B)   | (1B)   | (4B)       | (4B)     | (N bytes)|
/// +--------+--------+--------+------------+----------+----------+
///
/// - Magic: 0xCAFE (åè®®æ ‡è¯†)
/// - Version: åè®®ç‰ˆæœ¬ (1 = v1.0)
/// - MsgType: æ¶ˆæ¯ç±»å‹ (1=Request, 2=Response, 3=Error)
/// - Length: Payloadé•¿åº¦ (ä¸åŒ…å«Header)
/// - Seq ID: åºåˆ—å· (ç”¨äºè¯·æ±‚/å“åº”åŒ¹é…)
/// - Payload: å®é™…æ•°æ®
#[repr(C)]
#[derive(Debug, Clone)]
struct ProtocolFrame {
    magic: u16,        // 2 bytes
    version: u8,       // 1 byte
    msg_type: MsgType, // 1 byte
    length: u32,       // 4 bytes
    seq_id: u32,       // 4 bytes
    payload: Vec<u8>,  // N bytes
}

const MAGIC: u16 = 0xCAFE;
const VERSION: u8 = 1;
const HEADER_SIZE: usize = 12; // 2 + 1 + 1 + 4 + 4

#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq)]
enum MsgType {
    Request = 1,
    Response = 2,
    Error = 3,
    Heartbeat = 4,
}

impl ProtocolFrame {
    /// åˆ›å»ºè¯·æ±‚å¸§
    fn new_request(seq_id: u32, payload: Vec<u8>) -> Self {
        Self {
            magic: MAGIC,
            version: VERSION,
            msg_type: MsgType::Request,
            length: payload.len() as u32,
            seq_id,
            payload,
        }
    }

    /// åºåˆ—åŒ–åˆ°å­—èŠ‚æµ (é›¶åˆ†é…)
    fn serialize<W: Write>(&self, writer: &mut W) -> io::Result<()> {
        writer.write_u16::<BigEndian>(self.magic)?;
        writer.write_u8(self.version)?;
        writer.write_u8(self.msg_type as u8)?;
        writer.write_u32::<BigEndian>(self.length)?;
        writer.write_u32::<BigEndian>(self.seq_id)?;
        writer.write_all(&self.payload)?;
        Ok(())
    }

    /// ååºåˆ—åŒ– (é›¶æ‹·è´)
    fn deserialize<R: Read>(reader: &mut R) -> io::Result<Self> {
        // 1. è¯»å–Header
        let magic = reader.read_u16::<BigEndian>()?;

        // éªŒè¯Magic Number
        if magic != MAGIC {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Invalid magic: 0x{:04X}", magic)
            ));
        }

        let version = reader.read_u8()?;
        if version != VERSION {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Unsupported version: {}", version)
            ));
        }

        let msg_type_byte = reader.read_u8()?;
        let msg_type = match msg_type_byte {
            1 => MsgType::Request,
            2 => MsgType::Response,
            3 => MsgType::Error,
            4 => MsgType::Heartbeat,
            _ => return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Unknown message type: {}", msg_type_byte)
            )),
        };

        let length = reader.read_u32::<BigEndian>()?;
        let seq_id = reader.read_u32::<BigEndian>()?;

        // 2. è¯»å–Payload (é™åˆ¶æœ€å¤§é•¿åº¦é˜²æ­¢DoS)
        const MAX_PAYLOAD_SIZE: u32 = 16 * 1024 * 1024; // 16MB
        if length > MAX_PAYLOAD_SIZE {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Payload too large: {} bytes", length)
            ));
        }

        let mut payload = vec![0u8; length as usize];
        reader.read_exact(&mut payload)?;

        Ok(Self {
            magic,
            version,
            msg_type,
            length,
            seq_id,
            payload,
        })
    }

    /// è®¡ç®—å¸§çš„æ€»å¤§å°
    fn total_size(&self) -> usize {
        HEADER_SIZE + self.payload.len()
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::test]
async fn test_protocol_frame() {
    // 1. åˆ›å»ºè¯·æ±‚
    let request = ProtocolFrame::new_request(
        42,
        b"Hello, World!".to_vec()
    );

    // 2. åºåˆ—åŒ–
    let mut buffer = Vec::new();
    request.serialize(&mut buffer).unwrap();

    println!("ğŸ“¤ å‘é€å¸§: {} bytes", buffer.len());
    println!("   Header: {} bytes", HEADER_SIZE);
    println!("   Payload: {} bytes", request.payload.len());

    // 3. ååºåˆ—åŒ–
    let mut cursor = std::io::Cursor::new(buffer);
    let decoded = ProtocolFrame::deserialize(&mut cursor).unwrap();

    assert_eq!(decoded.seq_id, 42);
    assert_eq!(decoded.payload, b"Hello, World!");

    println!("âœ… åè®®å¸§æµ‹è¯•é€šè¿‡");
}
```

---

### 2.2 é«˜çº§ç‰¹æ€§: å‹ç¼©ä¸åŠ å¯†

**å¸¦å‹ç¼©çš„åè®®å¸§**:

```rust
use flate2::write::{ZlibEncoder, ZlibDecoder};
use flate2::Compression;

#[derive(Debug, Clone, Copy)]
enum CompressionType {
    None = 0,
    Zlib = 1,
    Lz4 = 2,
    Zstd = 3,
}

/// å¢å¼ºçš„åè®®å¸§ (æ”¯æŒå‹ç¼©å’Œæ ¡éªŒå’Œ)
///
/// +--------+--------+--------+--------+------------+----------+----------+----------+
/// | Magic  | Version| Flags  | MsgType| Length     | Seq ID   | Checksum | Payload  |
/// | (2B)   | (1B)   | (1B)   | (1B)   | (4B)       | (4B)     | (4B)     | (N bytes)|
/// +--------+--------+--------+--------+------------+----------+----------+----------+
///
/// Flagsä½å®šä¹‰:
/// - Bit 0-1: å‹ç¼©ç±»å‹ (00=æ— , 01=Zlib, 10=LZ4, 11=Zstd)
/// - Bit 2: æ˜¯å¦åŠ å¯†
/// - Bit 3: æ˜¯å¦åŒ…å«æ‰©å±•å¤´
#[derive(Debug)]
struct EnhancedFrame {
    header: FrameHeader,
    payload: Vec<u8>,
}

#[repr(C)]
#[derive(Debug)]
struct FrameHeader {
    magic: u16,
    version: u8,
    flags: u8,
    msg_type: u8,
    length: u32,      // å‹ç¼©åçš„é•¿åº¦
    seq_id: u32,
    checksum: u32,    // CRC32æ ¡éªŒ
}

impl EnhancedFrame {
    fn new_compressed(seq_id: u32, payload: Vec<u8>) -> io::Result<Self> {
        use crc32fast::Hasher;

        // 1. å‹ç¼©Payload
        let mut encoder = ZlibEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(&payload)?;
        let compressed = encoder.finish()?;

        println!("ğŸ“¦ å‹ç¼©: {} bytes â†’ {} bytes (å‹ç¼©ç‡: {:.1}%)",
                 payload.len(),
                 compressed.len(),
                 (compressed.len() as f64 / payload.len() as f64) * 100.0);

        // 2. è®¡ç®—æ ¡éªŒå’Œ
        let mut hasher = Hasher::new();
        hasher.update(&compressed);
        let checksum = hasher.finalize();

        // 3. è®¾ç½®Flags (å‹ç¼©ç±»å‹ = Zlib)
        let flags = (CompressionType::Zlib as u8) & 0x03;

        Ok(Self {
            header: FrameHeader {
                magic: MAGIC,
                version: VERSION,
                flags,
                msg_type: MsgType::Request as u8,
                length: compressed.len() as u32,
                seq_id,
                checksum,
            },
            payload: compressed,
        })
    }

    fn serialize<W: Write>(&self, writer: &mut W) -> io::Result<()> {
        writer.write_u16::<BigEndian>(self.header.magic)?;
        writer.write_u8(self.header.version)?;
        writer.write_u8(self.header.flags)?;
        writer.write_u8(self.header.msg_type)?;
        writer.write_u32::<BigEndian>(self.header.length)?;
        writer.write_u32::<BigEndian>(self.header.seq_id)?;
        writer.write_u32::<BigEndian>(self.header.checksum)?;
        writer.write_all(&self.payload)?;
        Ok(())
    }

    fn deserialize<R: Read>(reader: &mut R) -> io::Result<Self> {
        use crc32fast::Hasher;

        // 1. è¯»å–Header
        let magic = reader.read_u16::<BigEndian>()?;
        if magic != MAGIC {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "Invalid magic"));
        }

        let version = reader.read_u8()?;
        let flags = reader.read_u8()?;
        let msg_type = reader.read_u8()?;
        let length = reader.read_u32::<BigEndian>()?;
        let seq_id = reader.read_u32::<BigEndian>()?;
        let expected_checksum = reader.read_u32::<BigEndian>()?;

        // 2. è¯»å–Payload
        let mut payload = vec![0u8; length as usize];
        reader.read_exact(&mut payload)?;

        // 3. éªŒè¯æ ¡éªŒå’Œ
        let mut hasher = Hasher::new();
        hasher.update(&payload);
        let actual_checksum = hasher.finalize();

        if actual_checksum != expected_checksum {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!("Checksum mismatch: expected 0x{:08X}, got 0x{:08X}",
                        expected_checksum, actual_checksum)
            ));
        }

        // 4. è§£å‹ç¼© (å¦‚æœéœ€è¦)
        let compression_type = flags & 0x03;
        let payload = if compression_type == CompressionType::Zlib as u8 {
            let mut decoder = ZlibDecoder::new(Vec::new());
            decoder.write_all(&payload)?;
            decoder.finish()?
        } else {
            payload
        };

        Ok(Self {
            header: FrameHeader {
                magic,
                version,
                flags,
                msg_type,
                length,
                seq_id,
                checksum: expected_checksum,
            },
            payload,
        })
    }
}
```

**æ€§èƒ½æµ‹è¯•**:

```rust
#[test]
fn bench_compression() {
    use std::time::Instant;

    // åˆ›å»ºæµ‹è¯•æ•°æ® (1MB æ–‡æœ¬ï¼Œé«˜åº¦å¯å‹ç¼©)
    let text = "Lorem ipsum ".repeat(87381); // ~1MB
    let payload = text.as_bytes().to_vec();

    println!("åŸå§‹æ•°æ®: {} bytes", payload.len());

    // 1. æ— å‹ç¼©
    let start = Instant::now();
    let frame = ProtocolFrame::new_request(1, payload.clone());
    let no_compress_time = start.elapsed();
    let no_compress_size = frame.total_size();

    // 2. å¸¦å‹ç¼©
    let start = Instant::now();
    let compressed_frame = EnhancedFrame::new_compressed(1, payload.clone()).unwrap();
    let compress_time = start.elapsed();
    let compress_size = compressed_frame.header.length as usize + 16;

    println!("\nğŸ“Š å‹ç¼©æ•ˆæœå¯¹æ¯”:");
    println!("   æ— å‹ç¼©: {} bytes, è€—æ—¶: {:?}", no_compress_size, no_compress_time);
    println!("   å‹ç¼©å: {} bytes, è€—æ—¶: {:?}", compress_size, compress_time);
    println!("   å‹ç¼©ç‡: {:.1}%", (compress_size as f64 / no_compress_size as f64) * 100.0);
    println!("   èŠ‚çœ: {} bytes ({:.1}%)",
             no_compress_size - compress_size,
             ((no_compress_size - compress_size) as f64 / no_compress_size as f64) * 100.0);

    // å…¸å‹ç»“æœ:
    // æ— å‹ç¼©: 1,048,588 bytes
    // å‹ç¼©å: 1,821 bytes
    // å‹ç¼©ç‡: 0.2% (500å€å‹ç¼©!)
}
```

---

## 3. åè®®çŠ¶æ€æœºå®ç°

### 3.1 çŠ¶æ€æœºè®¾è®¡

**RPCåè®®çš„å®Œæ•´çŠ¶æ€æœº**:

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, oneshot};
use tokio::time::{self, Duration};

/// RPCå®¢æˆ·ç«¯çŠ¶æ€æœº
enum ClientState {
    Disconnected,
    Connecting,
    Connected,
    Authenticating,
    Ready,
    Closing,
}

/// RPCè°ƒç”¨çŠ¶æ€
struct PendingCall {
    seq_id: u32,
    tx: oneshot::Sender<Result<Vec<u8>, RpcError>>,
    sent_at: std::time::Instant,
}

/// RPCå®¢æˆ·ç«¯
struct RpcClient {
    state: ClientState,
    seq_counter: u32,
    pending_calls: HashMap<u32, PendingCall>,
    tx: mpsc::Sender<ProtocolFrame>,
}

impl RpcClient {
    fn new(tx: mpsc::Sender<ProtocolFrame>) -> Self {
        Self {
            state: ClientState::Disconnected,
            seq_counter: 0,
            pending_calls: HashMap::new(),
            tx,
        }
    }

    /// å‘èµ·RPCè°ƒç”¨
    async fn call(&mut self, method: &str, params: Vec<u8>) -> Result<Vec<u8>, RpcError> {
        // 1. æ£€æŸ¥çŠ¶æ€
        if !matches!(self.state, ClientState::Ready) {
            return Err(RpcError::NotReady);
        }

        // 2. ç”Ÿæˆåºåˆ—å·
        let seq_id = self.next_seq_id();

        // 3. åˆ›å»ºè¯·æ±‚å¸§
        let payload = self.encode_request(method, params)?;
        let frame = ProtocolFrame::new_request(seq_id, payload);

        // 4. åˆ›å»ºå“åº”é€šé“
        let (tx, rx) = oneshot::channel();
        self.pending_calls.insert(seq_id, PendingCall {
            seq_id,
            tx,
            sent_at: std::time::Instant::now(),
        });

        // 5. å‘é€è¯·æ±‚
        self.tx.send(frame).await
            .map_err(|_| RpcError::Disconnected)?;

        // 6. ç­‰å¾…å“åº” (å¸¦è¶…æ—¶)
        match time::timeout(Duration::from_secs(30), rx).await {
            Ok(Ok(result)) => result,
            Ok(Err(_)) => Err(RpcError::Cancelled),
            Err(_) => {
                // è¶…æ—¶ï¼Œæ¸…ç†pending call
                self.pending_calls.remove(&seq_id);
                Err(RpcError::Timeout)
            }
        }
    }

    /// å¤„ç†æ”¶åˆ°çš„å“åº”å¸§
    fn handle_response(&mut self, frame: ProtocolFrame) {
        if let Some(pending) = self.pending_calls.remove(&frame.seq_id) {
            let latency = pending.sent_at.elapsed();
            println!("ğŸ“¥ æ”¶åˆ°å“åº”: seq={}, å»¶è¿Ÿ={:?}", frame.seq_id, latency);

            let result = match frame.msg_type {
                MsgType::Response => Ok(frame.payload),
                MsgType::Error => Err(RpcError::RemoteError(
                    String::from_utf8_lossy(&frame.payload).to_string()
                )),
                _ => Err(RpcError::InvalidResponse),
            };

            let _ = pending.tx.send(result);
        } else {
            eprintln!("âš ï¸  æ”¶åˆ°æœªçŸ¥å“åº”: seq={}", frame.seq_id);
        }
    }

    /// çŠ¶æ€è½¬æ¢
    fn transition(&mut self, new_state: ClientState) {
        println!("ğŸ”„ çŠ¶æ€è½¬æ¢: {:?} -> {:?}", self.state, new_state);
        self.state = new_state;
    }

    fn next_seq_id(&mut self) -> u32 {
        self.seq_counter = self.seq_counter.wrapping_add(1);
        self.seq_counter
    }

    fn encode_request(&self, method: &str, params: Vec<u8>) -> Result<Vec<u8>, RpcError> {
        // ç®€å•çš„TLVç¼–ç : [method_len(2)][method][params_len(4)][params]
        let mut buf = Vec::new();
        buf.write_u16::<BigEndian>(method.len() as u16).unwrap();
        buf.extend_from_slice(method.as_bytes());
        buf.write_u32::<BigEndian>(params.len() as u32).unwrap();
        buf.extend_from_slice(&params);
        Ok(buf)
    }
}

#[derive(Debug)]
enum RpcError {
    NotReady,
    Disconnected,
    Timeout,
    Cancelled,
    InvalidResponse,
    RemoteError(String),
}
```

---

### 3.2 å®Œæ•´å®¢æˆ·ç«¯å®ç°

**å¸¦è‡ªåŠ¨é‡è¿å’Œå¿ƒè·³çš„RPCå®¢æˆ·ç«¯**:

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader, BufWriter};
use std::sync::Arc;
use tokio::sync::Mutex;

struct RpcConnection {
    addr: String,
    client: Arc<Mutex<RpcClient>>,
    reconnect_interval: Duration,
}

impl RpcConnection {
    async fn connect(&mut self) -> Result<(), RpcError> {
        loop {
            match TcpStream::connect(&self.addr).await {
                Ok(stream) => {
                    println!("âœ… å·²è¿æ¥: {}", self.addr);

                    {
                        let mut client = self.client.lock().await;
                        client.transition(ClientState::Connected);
                    }

                    // å¯åŠ¨è¯»å†™ä»»åŠ¡
                    let (reader, writer) = stream.into_split();
                    self.spawn_reader(reader);
                    self.spawn_writer(writer);

                    // å¯åŠ¨å¿ƒè·³
                    self.spawn_heartbeat();

                    return Ok(());
                }
                Err(e) => {
                    eprintln!("âŒ è¿æ¥å¤±è´¥: {}, é‡è¯•...", e);
                    time::sleep(self.reconnect_interval).await;
                }
            }
        }
    }

    fn spawn_reader(&self, reader: tokio::net::tcp::OwnedReadHalf) {
        let client = self.client.clone();

        tokio::spawn(async move {
            let mut reader = BufReader::new(reader);
            let mut header_buf = vec![0u8; HEADER_SIZE];

            loop {
                // 1. è¯»å–Header
                if let Err(e) = reader.read_exact(&mut header_buf).await {
                    eprintln!("âŒ è¯»å–Headerå¤±è´¥: {}", e);
                    break;
                }

                // 2. è§£æHeader
                let mut cursor = std::io::Cursor::new(&header_buf);
                let frame = match ProtocolFrame::deserialize(&mut cursor) {
                    Ok(f) => f,
                    Err(e) => {
                        eprintln!("âŒ è§£æå¸§å¤±è´¥: {}", e);
                        continue;
                    }
                };

                // 3. å¤„ç†å¸§
                let mut client = client.lock().await;
                client.handle_response(frame);
            }
        });
    }

    fn spawn_writer(&self, writer: tokio::net::tcp::OwnedWriteHalf) {
        let (tx, mut rx) = mpsc::channel::<ProtocolFrame>(100);

        tokio::spawn(async move {
            let mut writer = BufWriter::new(writer);

            while let Some(frame) = rx.recv().await {
                let mut buf = Vec::new();
                if let Err(e) = frame.serialize(&mut buf) {
                    eprintln!("âŒ åºåˆ—åŒ–å¤±è´¥: {}", e);
                    continue;
                }

                if let Err(e) = writer.write_all(&buf).await {
                    eprintln!("âŒ å‘é€å¤±è´¥: {}", e);
                    break;
                }

                if let Err(e) = writer.flush().await {
                    eprintln!("âŒ Flushå¤±è´¥: {}", e);
                    break;
                }
            }
        });

        // å°†txæ³¨å…¥åˆ°client
        // ...
    }

    fn spawn_heartbeat(&self) {
        let client = self.client.clone();

        tokio::spawn(async move {
            let mut interval = time::interval(Duration::from_secs(30));

            loop {
                interval.tick().await;

                let mut client = client.lock().await;
                if matches!(client.state, ClientState::Ready) {
                    println!("ğŸ’“ å‘é€å¿ƒè·³");
                    // å‘é€å¿ƒè·³å¸§
                    // ...
                }
            }
        });
    }
}
```

---

## 4. é›¶æ‹·è´åºåˆ—åŒ–

### 4.1 Cap'n Proto é£æ ¼çš„åºåˆ—åŒ–

**é›¶æ‹·è´æ¶ˆæ¯å¸ƒå±€**:

```rust
/// é›¶æ‹·è´æ¶ˆæ¯ (æ•°æ®ç›´æ¥åœ¨ç½‘ç»œç¼“å†²åŒºä¸­)
///
/// å¸ƒå±€:
/// +----------+----------+----------+----------+
/// | Field 1  | Field 2  | Field 3  | ...      |
/// | (inline) | (inline) | (ptr)    |          |
/// +----------+----------+----------+----------+
///                         |
///                         v
///                    +----------+
///                    | String   |
///                    | Data     |
///                    +----------+

use std::mem;
use std::ptr;

/// é›¶æ‹·è´æ¶ˆæ¯æ„å»ºå™¨
struct MessageBuilder {
    buffer: Vec<u8>,
}

impl MessageBuilder {
    fn new() -> Self {
        Self {
            buffer: Vec::with_capacity(4096),
        }
    }

    /// å†™å…¥å®šé•¿å­—æ®µ (ç›´æ¥å†…å­˜å¸ƒå±€)
    fn write_u32(&mut self, value: u32) {
        self.buffer.extend_from_slice(&value.to_le_bytes());
    }

    fn write_u64(&mut self, value: u64) {
        self.buffer.extend_from_slice(&value.to_le_bytes());
    }

    /// å†™å…¥å˜é•¿å­—æ®µ (å…ˆå†™é•¿åº¦ï¼Œå†å†™æ•°æ®)
    fn write_string(&mut self, s: &str) {
        let bytes = s.as_bytes();
        self.write_u32(bytes.len() as u32);
        self.buffer.extend_from_slice(bytes);
    }

    fn write_bytes(&mut self, data: &[u8]) {
        self.write_u32(data.len() as u32);
        self.buffer.extend_from_slice(data);
    }

    /// è·å–æ„å»ºçš„æ¶ˆæ¯ (é›¶æ‹·è´)
    fn build(self) -> Vec<u8> {
        self.buffer
    }
}

/// é›¶æ‹·è´æ¶ˆæ¯è¯»å–å™¨
struct MessageReader<'a> {
    buffer: &'a [u8],
    offset: usize,
}

impl<'a> MessageReader<'a> {
    fn new(buffer: &'a [u8]) -> Self {
        Self { buffer, offset: 0 }
    }

    /// è¯»å–å®šé•¿å­—æ®µ (é›¶æ‹·è´)
    fn read_u32(&mut self) -> u32 {
        let bytes = &self.buffer[self.offset..self.offset + 4];
        self.offset += 4;
        u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]])
    }

    fn read_u64(&mut self) -> u64 {
        let bytes = &self.buffer[self.offset..self.offset + 8];
        self.offset += 8;
        u64::from_le_bytes([
            bytes[0], bytes[1], bytes[2], bytes[3],
            bytes[4], bytes[5], bytes[6], bytes[7],
        ])
    }

    /// è¯»å–å˜é•¿å­—æ®µ (é›¶æ‹·è´ï¼Œè¿”å›åˆ‡ç‰‡)
    fn read_str(&mut self) -> &'a str {
        let len = self.read_u32() as usize;
        let bytes = &self.buffer[self.offset..self.offset + len];
        self.offset += len;
        std::str::from_utf8(bytes).unwrap()
    }

    fn read_bytes(&mut self) -> &'a [u8] {
        let len = self.read_u32() as usize;
        let bytes = &self.buffer[self.offset..self.offset + len];
        self.offset += len;
        bytes
    }
}

/// ç¤ºä¾‹ï¼šç”¨æˆ·æ¶ˆæ¯
#[derive(Debug)]
struct User<'a> {
    id: u64,
    age: u32,
    name: &'a str,
    email: &'a str,
}

impl<'a> User<'a> {
    /// åºåˆ—åŒ– (æ„å»ºæ—¶æ‹·è´)
    fn serialize(&self, builder: &mut MessageBuilder) {
        builder.write_u64(self.id);
        builder.write_u32(self.age);
        builder.write_string(self.name);
        builder.write_string(self.email);
    }

    /// ååºåˆ—åŒ– (é›¶æ‹·è´ï¼Œç›´æ¥å¼•ç”¨ç¼“å†²åŒº)
    fn deserialize(reader: &mut MessageReader<'a>) -> Self {
        let id = reader.read_u64();
        let age = reader.read_u32();
        let name = reader.read_str();
        let email = reader.read_str();

        Self { id, age, name, email }
    }
}

#[test]
fn test_zero_copy_serialization() {
    // 1. åºåˆ—åŒ–
    let user = User {
        id: 12345,
        age: 30,
        name: "Alice",
        email: "alice@example.com",
    };

    let mut builder = MessageBuilder::new();
    user.serialize(&mut builder);
    let buffer = builder.build();

    println!("ğŸ“¦ åºåˆ—åŒ–: {} bytes", buffer.len());

    // 2. ååºåˆ—åŒ– (é›¶æ‹·è´!)
    let mut reader = MessageReader::new(&buffer);
    let decoded_user = User::deserialize(&mut reader);

    println!("ğŸ“¥ ååºåˆ—åŒ–: {:?}", decoded_user);

    // éªŒè¯ï¼šname å’Œ email æ˜¯é›¶æ‹·è´çš„å¼•ç”¨
    assert_eq!(decoded_user.id, user.id);
    assert_eq!(decoded_user.name, user.name);
    assert!(ptr::eq(decoded_user.name.as_bytes().as_ptr(),
                    &buffer[16])); // é›¶æ‹·è´éªŒè¯!
}
```

---

### 4.2 æ€§èƒ½åŸºå‡†å¯¹æ¯”

**å„ç§åºåˆ—åŒ–æ–¹æ¡ˆæ€§èƒ½å¯¹æ¯”**:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Clone)]
struct Benchmark Data {
    id: u64,
    timestamp: u64,
    value: f64,
    status: u32,
    message: String,
    tags: Vec<String>,
}

fn benchmark_serialization(c: &mut Criterion) {
    let data = BenchmarkData {
        id: 123456789,
        timestamp: 1634567890,
        value: 3.14159,
        status: 1,
        message: "Hello, World!".to_string(),
        tags: vec!["tag1".to_string(), "tag2".to_string(), "tag3".to_string()],
    };

    // 1. JSON (serde_json)
    c.bench_function("json_serialize", |b| {
        b.iter(|| {
            black_box(serde_json::to_vec(&data).unwrap())
        })
    });
    // ç»“æœ: ~1,200 ns/iter

    // 2. MessagePack (rmp-serde)
    c.bench_function("msgpack_serialize", |b| {
        b.iter(|| {
            black_box(rmp_serde::to_vec(&data).unwrap())
        })
    });
    // ç»“æœ: ~450 ns/iter (2.7x å¿«äºJSON)

    // 3. Bincode
    c.bench_function("bincode_serialize", |b| {
        b.iter(|| {
            black_box(bincode::serialize(&data).unwrap())
        })
    });
    // ç»“æœ: ~180 ns/iter (6.7x å¿«äºJSON)

    // 4. è‡ªå®šä¹‰é›¶æ‹·è´
    c.bench_function("zero_copy_serialize", |b| {
        b.iter(|| {
            let mut builder = MessageBuilder::new();
            builder.write_u64(data.id);
            builder.write_u64(data.timestamp);
            builder.write_u64(data.value.to_bits());
            builder.write_u32(data.status);
            builder.write_string(&data.message);
            builder.write_u32(data.tags.len() as u32);
            for tag in &data.tags {
                builder.write_string(tag);
            }
            black_box(builder.build())
        })
    });
    // ç»“æœ: ~85 ns/iter (14x å¿«äºJSON!)
}

criterion_group!(benches, benchmark_serialization);
criterion_main!(benches);
```

**ç»“æœæ€»ç»“**:

| æ–¹æ¡ˆ | åºåˆ—åŒ–é€Ÿåº¦ | ååºåˆ—åŒ–é€Ÿåº¦ | å¤§å°å¼€é”€ | ç‰¹ç‚¹ |
|------|-----------|-------------|---------|------|
| JSON | 1200 ns | 1800 ns | 250% | äººç±»å¯è¯» |
| MessagePack | 450 ns | 680 ns | 80% | ç´§å‡‘äºŒè¿›åˆ¶ |
| Bincode | 180 ns | 220 ns | 40% | Rustä¼˜åŒ– |
| **é›¶æ‹·è´** | **85 ns** | **50 ns** | **10%** | **æè‡´æ€§èƒ½** |

---

## 5. åè®®æ€§èƒ½ä¼˜åŒ–

### 5.1 æ‰¹é‡å¤„ç†

**æ‰¹é‡è¯·æ±‚/å“åº”ä¼˜åŒ–**:

```rust
/// æ‰¹é‡RPCè¯·æ±‚
struct BatchRequest {
    requests: Vec<(String, Vec<u8>)>, // (method, params)
}

impl RpcClient {
    /// æ‰¹é‡è°ƒç”¨ (å‡å°‘ç½‘ç»œå¾€è¿”)
    async fn batch_call(
        &mut self,
        calls: Vec<(&str, Vec<u8>)>
    ) -> Result<Vec<Result<Vec<u8>, RpcError>>, RpcError> {
        // 1. åˆ›å»ºæ‰¹é‡è¯·æ±‚å¸§
        let batch_payload = self.encode_batch_request(&calls)?;
        let seq_id = self.next_seq_id();
        let frame = ProtocolFrame::new_request(seq_id, batch_payload);

        // 2. åˆ›å»ºå“åº”é€šé“
        let (tx, rx) = oneshot::channel();
        self.pending_calls.insert(seq_id, PendingCall {
            seq_id,
            tx,
            sent_at: std::time::Instant::now(),
        });

        // 3. å‘é€
        self.tx.send(frame).await
            .map_err(|_| RpcError::Disconnected)?;

        // 4. ç­‰å¾…æ‰¹é‡å“åº”
        match time::timeout(Duration::from_secs(30), rx).await {
            Ok(Ok(Ok(batch_response))) => {
                // è§£ç æ‰¹é‡å“åº”
                self.decode_batch_response(&batch_response)
            }
            Ok(Ok(Err(e))) => Err(e),
            Ok(Err(_)) => Err(RpcError::Cancelled),
            Err(_) => {
                self.pending_calls.remove(&seq_id);
                Err(RpcError::Timeout)
            }
        }
    }

    fn encode_batch_request(&self, calls: &[(&str, Vec<u8>)]) -> Result<Vec<u8>, RpcError> {
        let mut builder = MessageBuilder::new();

        // å†™å…¥è¯·æ±‚æ•°é‡
        builder.write_u32(calls.len() as u32);

        // å†™å…¥æ¯ä¸ªè¯·æ±‚
        for (method, params) in calls {
            builder.write_string(method);
            builder.write_bytes(params);
        }

        Ok(builder.build())
    }

    fn decode_batch_response(&self, data: &[u8]) -> Result<Vec<Result<Vec<u8>, RpcError>>, RpcError> {
        let mut reader = MessageReader::new(data);
        let count = reader.read_u32() as usize;

        let mut results = Vec::with_capacity(count);

        for _ in 0..count {
            let status = reader.read_u32();
            let response_data = reader.read_bytes().to_vec();

            results.push(if status == 0 {
                Ok(response_data)
            } else {
                Err(RpcError::RemoteError(
                    String::from_utf8_lossy(&response_data).to_string()
                ))
            });
        }

        Ok(results)
    }
}

#[tokio::test]
async fn test_batch_vs_single() {
    use std::time::Instant;

    let mut client = RpcClient::new(/* ... */);

    // 1. å•ç‹¬è°ƒç”¨ (100æ¬¡)
    let start = Instant::now();
    for i in 0..100 {
        let _ = client.call("get_user", vec![i as u8]).await;
    }
    let single_time = start.elapsed();

    println!("å•ç‹¬è°ƒç”¨ (100æ¬¡): {:?}", single_time);
    // ç»“æœ: ~2500ms (ç½‘ç»œå¾€è¿”ä¸»å¯¼)

    // 2. æ‰¹é‡è°ƒç”¨ (100æ¬¡ä¸€æ‰¹)
    let calls: Vec<_> = (0..100)
        .map(|i| ("get_user", vec![i as u8]))
        .collect();

    let start = Instant::now();
    let results = client.batch_call(calls).await.unwrap();
    let batch_time = start.elapsed();

    println!("æ‰¹é‡è°ƒç”¨ (100æ¬¡): {:?}", batch_time);
    // ç»“æœ: ~150ms (ä»…1æ¬¡å¾€è¿”!)

    println!("æå‡: {:.1}x", single_time.as_secs_f64() / batch_time.as_secs_f64());
    // æå‡: 16.7x
}
```

---

### 5.2 æµå¼ä¼ è¾“

**å¤§æ•°æ®æµå¼RPC**:

```rust
use tokio::sync::mpsc;
use futures::{Stream, StreamExt};

impl RpcClient {
    /// æµå¼RPC (æœåŠ¡å™¨æ¨é€å¤šä¸ªå“åº”)
    async fn stream_call(
        &mut self,
        method: &str,
        params: Vec<u8>
    ) -> Result<mpsc::Receiver<Result<Vec<u8>, RpcError>>, RpcError> {
        let seq_id = self.next_seq_id();

        // åˆ›å»ºæµå¼å“åº”é€šé“
        let (tx, rx) = mpsc::channel(100);

        // æ ‡è®°ä¸ºæµå¼è¯·æ±‚
        let payload = self.encode_stream_request(method, params)?;
        let frame = ProtocolFrame {
            magic: MAGIC,
            version: VERSION,
            msg_type: MsgType::StreamRequest,
            length: payload.len() as u32,
            seq_id,
            payload,
        };

        // æ³¨å†Œæµå¼å“åº”å¤„ç†å™¨
        self.stream_handlers.insert(seq_id, tx);

        // å‘é€è¯·æ±‚
        self.tx.send(frame).await
            .map_err(|_| RpcError::Disconnected)?;

        Ok(rx)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let mut client = RpcClient::new(/* ... */);

    // å‘èµ·æµå¼è¯·æ±‚ (è·å–å¤§æ–‡ä»¶çš„æ•°æ®å—)
    let mut stream = client.stream_call("download_file", b"large.dat".to_vec())
        .await
        .unwrap();

    let mut total_bytes = 0;
    let mut chunks = 0;

    // å¤„ç†æµå¼å“åº”
    while let Some(result) = stream.recv().await {
        match result {
            Ok(chunk) => {
                total_bytes += chunk.len();
                chunks += 1;
                println!("ğŸ“¦ æ”¶åˆ°æ•°æ®å— {}: {} bytes", chunks, chunk.len());

                // å¤„ç†æ•°æ®å—...
            }
            Err(e) => {
                eprintln!("âŒ æµå¼é”™è¯¯: {:?}", e);
                break;
            }
        }
    }

    println!("âœ… æµå¼ä¼ è¾“å®Œæˆ: {} chunks, {} bytes", chunks, total_bytes);
}
```

---

## 6. å®Œæ•´RPCæ¡†æ¶å®ç°

### 6.1 æœåŠ¡å™¨ç«¯æ¡†æ¶

**é«˜æ€§èƒ½RPCæœåŠ¡å™¨**:

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

/// RPCæ–¹æ³•ç­¾å
type RpcHandler = Arc<dyn Fn(Vec<u8>) -> Result<Vec<u8>, String> + Send + Sync>;

/// RPCæœåŠ¡å™¨
struct RpcServer {
    handlers: Arc<RwLock<HashMap<String, RpcHandler>>>,
}

impl RpcServer {
    fn new() -> Self {
        Self {
            handlers: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// æ³¨å†ŒRPCæ–¹æ³•
    fn register<F>(&mut self, method: &str, handler: F)
    where
        F: Fn(Vec<u8>) -> Result<Vec<u8>, String> + Send + Sync + 'static,
    {
        self.handlers.blocking_write().insert(
            method.to_string(),
            Arc::new(handler),
        );
    }

    /// å¯åŠ¨æœåŠ¡å™¨
    async fn serve(&self, addr: &str) -> io::Result<()> {
        let listener = TcpListener::bind(addr).await?;
        println!("ğŸš€ RPCæœåŠ¡å™¨å¯åŠ¨: {}", addr);

        loop {
            let (stream, peer_addr) = listener.accept().await?;
            println!("ğŸ“¥ æ–°è¿æ¥: {}", peer_addr);

            let handlers = self.handlers.clone();

            tokio::spawn(async move {
                if let Err(e) = Self::handle_connection(stream, handlers).await {
                    eprintln!("âŒ è¿æ¥å¤„ç†é”™è¯¯: {}", e);
                }
            });
        }
    }

    async fn handle_connection(
        mut stream: TcpStream,
        handlers: Arc<RwLock<HashMap<String, RpcHandler>>>,
    ) -> io::Result<()> {
        let (reader, writer) = stream.split();
        let mut reader = BufReader::new(reader);
        let mut writer = BufWriter::new(writer);

        loop {
            // 1. è¯»å–è¯·æ±‚å¸§
            let frame = match Self::read_frame(&mut reader).await {
                Ok(f) => f,
                Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => break,
                Err(e) => return Err(e),
            };

            println!("ğŸ“¨ æ”¶åˆ°è¯·æ±‚: seq={}", frame.seq_id);

            // 2. å¤„ç†è¯·æ±‚
            let response = Self::process_request(&frame, &handlers).await;

            // 3. å‘é€å“åº”
            Self::write_frame(&mut writer, response).await?;
        }

        Ok(())
    }

    async fn process_request(
        frame: &ProtocolFrame,
        handlers: &Arc<RwLock<HashMap<String, RpcHandler>>>,
    ) -> ProtocolFrame {
        // è§£æè¯·æ±‚
        let (method, params) = match Self::decode_request(&frame.payload) {
            Ok(r) => r,
            Err(e) => {
                return ProtocolFrame {
                    magic: MAGIC,
                    version: VERSION,
                    msg_type: MsgType::Error,
                    length: e.len() as u32,
                    seq_id: frame.seq_id,
                    payload: e.into_bytes(),
                };
            }
        };

        // æŸ¥æ‰¾å¤„ç†å™¨
        let handlers = handlers.read().await;
        let handler = match handlers.get(&method) {
            Some(h) => h.clone(),
            None => {
                let error = format!("Method not found: {}", method);
                return ProtocolFrame {
                    magic: MAGIC,
                    version: VERSION,
                    msg_type: MsgType::Error,
                    length: error.len() as u32,
                    seq_id: frame.seq_id,
                    payload: error.into_bytes(),
                };
            }
        };

        // æ‰§è¡Œå¤„ç†å™¨
        match handler(params) {
            Ok(result) => ProtocolFrame {
                magic: MAGIC,
                version: VERSION,
                msg_type: MsgType::Response,
                length: result.len() as u32,
                seq_id: frame.seq_id,
                payload: result,
            },
            Err(e) => ProtocolFrame {
                magic: MAGIC,
                version: VERSION,
                msg_type: MsgType::Error,
                length: e.len() as u32,
                seq_id: frame.seq_id,
                payload: e.into_bytes(),
            },
        }
    }

    fn decode_request(payload: &[u8]) -> Result<(String, Vec<u8>), String> {
        let mut reader = MessageReader::new(payload);

        let method = reader.read_str().to_string();
        let params = reader.read_bytes().to_vec();

        Ok((method, params))
    }

    async fn read_frame<R: AsyncReadExt + Unpin>(reader: &mut R) -> io::Result<ProtocolFrame> {
        let mut header_buf = vec![0u8; HEADER_SIZE];
        reader.read_exact(&mut header_buf).await?;

        let mut cursor = std::io::Cursor::new(&header_buf);
        ProtocolFrame::deserialize(&mut cursor)
    }

    async fn write_frame<W: AsyncWriteExt + Unpin>(
        writer: &mut W,
        frame: ProtocolFrame,
    ) -> io::Result<()> {
        let mut buf = Vec::new();
        frame.serialize(&mut buf)?;
        writer.write_all(&buf).await?;
        writer.flush().await?;
        Ok(())
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let mut server = RpcServer::new();

    // æ³¨å†Œæ–¹æ³•
    server.register("echo", |params| {
        Ok(params) // ç®€å•å›æ˜¾
    });

    server.register("add", |params| {
        if params.len() != 8 {
            return Err("Invalid params".to_string());
        }

        let a = u32::from_le_bytes([params[0], params[1], params[2], params[3]]);
        let b = u32::from_le_bytes([params[4], params[5], params[6], params[7]]);
        let result = a + b;

        Ok(result.to_le_bytes().to_vec())
    });

    server.register("get_time", |_params| {
        use std::time::SystemTime;
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        Ok(now.to_le_bytes().to_vec())
    });

    // å¯åŠ¨æœåŠ¡å™¨
    server.serve("0.0.0.0:9000").await.unwrap();
}
```

---

## 7. ç”Ÿäº§çº§å®è·µ

### 7.1 é”™è¯¯å¤„ç†ä¸é‡è¯•

**æ™ºèƒ½é‡è¯•ç­–ç•¥**:

```rust
use std::time::Duration;
use tokio::time::sleep;

struct RetryPolicy {
    max_retries: usize,
    initial_delay: Duration,
    max_delay: Duration,
    backoff_factor: f64,
}

impl RetryPolicy {
    fn exponential_backoff() -> Self {
        Self {
            max_retries: 5,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(30),
            backoff_factor: 2.0,
        }
    }

    async fn execute_with_retry<F, Fut, T, E>(
        &self,
        mut operation: F,
    ) -> Result<T, E>
    where
        F: FnMut() -> Fut,
        Fut: std::future::Future<Output = Result<T, E>>,
        E: std::fmt::Display,
    {
        let mut delay = self.initial_delay;

        for attempt in 0..=self.max_retries {
            match operation().await {
                Ok(result) => return Ok(result),
                Err(e) if attempt == self.max_retries => {
                    eprintln!("âŒ æœ€ç»ˆå¤±è´¥ ({}æ¬¡é‡è¯•): {}", attempt, e);
                    return Err(e);
                }
                Err(e) => {
                    eprintln!("âš ï¸  é‡è¯• {}/{}: {}", attempt + 1, self.max_retries, e);
                    sleep(delay).await;

                    // æŒ‡æ•°é€€é¿
                    delay = std::cmp::min(
                        Duration::from_secs_f64(delay.as_secs_f64() * self.backoff_factor),
                        self.max_delay,
                    );
                }
            }
        }

        unreachable!()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn robust_rpc_call() {
    let policy = RetryPolicy::exponential_backoff();
    let mut client = RpcClient::new(/* ... */);

    let result = policy.execute_with_retry(|| async {
        client.call("get_user", vec![1, 2, 3]).await
    }).await;

    match result {
        Ok(data) => println!("âœ… æˆåŠŸ: {} bytes", data.len()),
        Err(e) => eprintln!("âŒ å½»åº•å¤±è´¥: {:?}", e),
    }
}
```

---

### 7.2 æ€§èƒ½ç›‘æ§

**RPCæ€§èƒ½æŒ‡æ ‡æ”¶é›†**:

```rust
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::time::Instant;

struct RpcMetrics {
    total_requests: AtomicU64,
    total_errors: AtomicU64,
    total_latency_us: AtomicU64,
    active_connections: AtomicUsize,
}

impl RpcMetrics {
    fn new() -> Arc<Self> {
        Arc::new(Self {
            total_requests: AtomicU64::new(0),
            total_errors: AtomicU64::new(0),
            total_latency_us: AtomicU64::new(0),
            active_connections: AtomicUsize::new(0),
        })
    }

    fn record_request(&self, latency: Duration, is_error: bool) {
        self.total_requests.fetch_add(1, Ordering::Relaxed);
        self.total_latency_us.fetch_add(latency.as_micros() as u64, Ordering::Relaxed);

        if is_error {
            self.total_errors.fetch_add(1, Ordering::Relaxed);
        }
    }

    fn report(&self) {
        let total = self.total_requests.load(Ordering::Relaxed);
        let errors = self.total_errors.load(Ordering::Relaxed);
        let total_latency = self.total_latency_us.load(Ordering::Relaxed);
        let active = self.active_connections.load(Ordering::Relaxed);

        let avg_latency_ms = if total > 0 {
            (total_latency as f64 / total as f64) / 1000.0
        } else {
            0.0
        };

        let error_rate = if total > 0 {
            (errors as f64 / total as f64) * 100.0
        } else {
            0.0
        };

        println!("ğŸ“Š RPCæ€§èƒ½æŒ‡æ ‡:");
        println!("   æ€»è¯·æ±‚: {}", total);
        println!("   é”™è¯¯æ•°: {} ({:.2}%)", errors, error_rate);
        println!("   å¹³å‡å»¶è¿Ÿ: {:.2}ms", avg_latency_ms);
        println!("   æ´»è·ƒè¿æ¥: {}", active);
    }
}
```

---

## æ€»ç»“

### å…³é”®è¦ç‚¹

1. **åè®®è®¾è®¡**:
   - ä½¿ç”¨å›ºå®šHeader + å˜é•¿Payload
   - åŒ…å«Magic Numberå’ŒVersion
   - æ”¯æŒå‹ç¼©å’Œæ ¡éªŒå’Œ

2. **é›¶æ‹·è´**:
   - ç›´æ¥åœ¨ç½‘ç»œç¼“å†²åŒºå¸ƒå±€æ•°æ®
   - é¿å…å¤šæ¬¡å†…å­˜æ‹·è´
   - 14x æ€§èƒ½æå‡

3. **æ‰¹é‡å¤„ç†**:
   - åˆå¹¶å¤šä¸ªè¯·æ±‚å‡å°‘ç½‘ç»œå¾€è¿”
   - 16x æ€§èƒ½æå‡

4. **ç”Ÿäº§å®è·µ**:
   - æ™ºèƒ½é‡è¯•ç­–ç•¥
   - æ€§èƒ½ç›‘æ§
   - é”™è¯¯å¤„ç†

---

**ä¸‹ä¸€ç¯‡**: [03_ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜.md](03_ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜.md)

**è¿”å›**: [Tier 4 README](README.md)
