# 形式化网络协议理论

> **文档版本**: v1.0.0  
> **更新日期**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **文档层级**: Tier 4 - 高级主题

---

## 目录

- [形式化网络协议理论](#形式化网络协议理论)
  - [目录](#目录)
  - [1. 协议形式化定义](#1-协议形式化定义)
    - [协议三元组定义](#协议三元组定义)
    - [协议不变式（Invariants）](#协议不变式invariants)
  - [2. 协议状态机模型](#2-协议状态机模型)
    - [扩展有限状态机（EFSM）](#扩展有限状态机efsm)
  - [3. 协议验证与证明](#3-协议验证与证明)
    - [模型检验（Model Checking）](#模型检验model-checking)
    - [Kani形式化验证](#kani形式化验证)
  - [4. 网络演算理论](#4-网络演算理论)
    - [时间Petri网（Timed Petri Net）](#时间petri网timed-petri-net)
    - [进程演算（Process Calculus）](#进程演算process-calculus)
  - [5. 形式化TCP/IP](#5-形式化tcpip)
    - [TCP Reno拥塞控制算法形式化](#tcp-reno拥塞控制算法形式化)
    - [IP分片与重组形式化](#ip分片与重组形式化)
  - [6. HTTP协议语义](#6-http协议语义)
    - [HTTP请求语义分析](#http请求语义分析)
  - [7. 协议组合与接口](#7-协议组合与接口)
    - [协议栈的形式化组合](#协议栈的形式化组合)
  - [8. Rust类型系统验证](#8-rust类型系统验证)
    - [幽灵类型（Phantom Types）协议状态](#幽灵类型phantom-types协议状态)

---

## 1. 协议形式化定义

### 协议三元组定义

协议 $P$ 可以形式化为三元组 $(S, M, T)$:
- $S$: 状态空间 (State Space)
- $M$: 消息空间 (Message Space)
- $T$: 转换函数 (Transition Function) $T: S \times M \rightarrow S$

```rust
/// 形式化协议定义
pub trait FormalProtocol {
    /// 状态类型
    type State: Clone + PartialEq;
    
    /// 消息类型
    type Message;
    
    /// 错误类型
    type Error;
    
    /// 状态转换函数
    fn transition(&self, state: Self::State, message: Self::Message) -> Result<Self::State, Self::Error>;
    
    /// 初始状态
    fn initial_state(&self) -> Self::State;
    
    /// 终止状态判定
    fn is_terminal(&self, state: &Self::State) -> bool;
}

/// TCP协议形式化
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TcpState {
    Closed,
    Listen,
    SynSent,
    SynReceived,
    Established,
    FinWait1,
    FinWait2,
    CloseWait,
    Closing,
    LastAck,
    TimeWait,
}

#[derive(Debug, Clone, Copy)]
pub enum TcpMessage {
    Syn,
    SynAck,
    Ack,
    Fin,
    FinAck,
    Data,
    Rst,
}

pub struct TcpProtocol;

impl FormalProtocol for TcpProtocol {
    type State = TcpState;
    type Message = TcpMessage;
    type Error = String;
    
    fn transition(&self, state: Self::State, msg: Self::Message) -> Result<Self::State, Self::Error> {
        use TcpState::*;
        use TcpMessage::*;
        
        match (state, msg) {
            (Closed, Syn) => Ok(SynSent),
            (Listen, Syn) => Ok(SynReceived),
            (SynSent, SynAck) => Ok(Established),
            (SynReceived, Ack) => Ok(Established),
            (Established, Fin) => Ok(CloseWait),
            (Established, Data) => Ok(Established),
            (FinWait1, Ack) => Ok(FinWait2),
            (FinWait2, Fin) => Ok(TimeWait),
            (CloseWait, Fin) => Ok(LastAck),
            (LastAck, Ack) => Ok(Closed),
            _ => Err(format!("非法转换: {:?} -> {:?}", state, msg)),
        }
    }
    
    fn initial_state(&self) -> Self::State {
        TcpState::Closed
    }
    
    fn is_terminal(&self, state: &Self::State) -> bool {
        matches!(state, TcpState::Closed)
    }
}
```

### 协议不变式（Invariants）

**定义**: 协议不变式是在所有合法状态转换中保持不变的性质。

```rust
/// 协议不变式特征
pub trait ProtocolInvariant<P: FormalProtocol> {
    /// 检查不变式
    fn check(&self, state: &P::State) -> bool;
    
    /// 不变式描述
    fn description(&self) -> &str;
}

/// TCP序列号单调性不变式
pub struct TcpSeqMonotonic {
    last_seq: u32,
}

impl TcpSeqMonotonic {
    pub fn new(initial_seq: u32) -> Self {
        Self { last_seq: initial_seq }
    }
    
    pub fn update(&mut self, seq: u32) -> bool {
        if seq >= self.last_seq {
            self.last_seq = seq;
            true
        } else {
            false // 违反单调性
        }
    }
}

/// 使用LTL (Linear Temporal Logic) 表达协议性质
pub trait LtlProperty<P: FormalProtocol> {
    /// Always: □φ (G φ in LTL)
    fn always(&self, state: &P::State) -> bool;
    
    /// Eventually: ◇φ (F φ in LTL)
    fn eventually(&self, states: &[P::State]) -> bool;
    
    /// Until: φ U ψ
    fn until(&self, states: &[P::State], predicate: impl Fn(&P::State) -> bool) -> bool;
}
```

---

## 2. 协议状态机模型

### 扩展有限状态机（EFSM）

```rust
/// 扩展有限状态机
pub struct ExtendedFsm<S, M, C> {
    states: Vec<S>,
    messages: Vec<M>,
    transitions: Vec<Transition<S, M, C>>,
    context: C,
}

pub struct Transition<S, M, C> {
    from: S,
    to: S,
    message: M,
    guard: fn(&C) -> bool,
    action: fn(&mut C),
}

impl<S: Clone + PartialEq, M: Clone, C> ExtendedFsm<S, M, C> {
    pub fn transition(&mut self, current: S, message: M) -> Option<S> {
        for trans in &self.transitions {
            if trans.from == current && trans.message == message {
                if (trans.guard)(&self.context) {
                    (trans.action)(&mut self.context);
                    return Some(trans.to.clone());
                }
            }
        }
        None
    }
}

/// HTTP请求处理EFSM
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HttpState {
    Idle,
    ReadingRequest,
    ProcessingRequest,
    SendingResponse,
    Closed,
}

#[derive(Debug, Clone)]
pub enum HttpMessage {
    RequestLine(String),
    Header(String, String),
    Body(Vec<u8>),
    EndOfRequest,
}

#[derive(Default)]
pub struct HttpContext {
    method: Option<String>,
    path: Option<String>,
    headers: std::collections::HashMap<String, String>,
    body: Vec<u8>,
}

impl HttpContext {
    fn is_valid_request(&self) -> bool {
        self.method.is_some() && self.path.is_some()
    }
}
```

---

## 3. 协议验证与证明

### 模型检验（Model Checking）

```rust
/// 状态空间探索
pub struct StateExplorer<P: FormalProtocol> {
    protocol: P,
    visited: std::collections::HashSet<String>,
}

impl<P: FormalProtocol> StateExplorer<P>
where
    P::State: std::fmt::Debug,
{
    pub fn new(protocol: P) -> Self {
        Self {
            protocol,
            visited: std::collections::HashSet::new(),
        }
    }
    
    /// BFS状态空间探索
    pub fn explore(&mut self, messages: &[P::Message]) -> Vec<P::State>
    where
        P::Message: Clone,
        P::State: std::hash::Hash,
    {
        let mut queue = std::collections::VecDeque::new();
        let mut all_states = Vec::new();
        
        let initial = self.protocol.initial_state();
        queue.push_back(initial.clone());
        all_states.push(initial);
        
        while let Some(state) = queue.pop_front() {
            for msg in messages {
                if let Ok(next_state) = self.protocol.transition(state.clone(), msg.clone()) {
                    let state_key = format!("{:?}", next_state);
                    
                    if self.visited.insert(state_key) {
                        all_states.push(next_state.clone());
                        queue.push_back(next_state);
                    }
                }
            }
        }
        
        all_states
    }
    
    /// 验证安全性质（Safety Property）
    pub fn verify_safety<F>(&mut self, messages: &[P::Message], property: F) -> bool
    where
        P::Message: Clone,
        P::State: std::hash::Hash,
        F: Fn(&P::State) -> bool,
    {
        let states = self.explore(messages);
        states.iter().all(|state| property(state))
    }
    
    /// 验证活性质（Liveness Property）
    pub fn verify_liveness<F>(&mut self, messages: &[P::Message], property: F) -> bool
    where
        P::Message: Clone,
        P::State: std::hash::Hash,
        F: Fn(&[P::State]) -> bool,
    {
        let states = self.explore(messages);
        property(&states)
    }
}

/// 验证TCP协议不会进入非法状态
pub fn verify_tcp_safety() {
    let protocol = TcpProtocol;
    let mut explorer = StateExplorer::new(protocol);
    
    let messages = vec![
        TcpMessage::Syn,
        TcpMessage::SynAck,
        TcpMessage::Ack,
        TcpMessage::Fin,
        TcpMessage::FinAck,
    ];
    
    let safety = explorer.verify_safety(&messages, |state| {
        // 安全性：不应该从Closed直接到Established
        !matches!(state, TcpState::Established)
        || explorer.visited.contains(&format!("{:?}", TcpState::SynSent))
        || explorer.visited.contains(&format!("{:?}", TcpState::SynReceived))
    });
    
    println!("TCP安全性验证: {}", if safety { "通过" } else { "失败" });
}
```

### Kani形式化验证

```rust
/// Kani验证示例
#[cfg(kani)]
#[kani::proof]
fn verify_tcp_state_transitions() {
    let protocol = TcpProtocol;
    let state = kani::any(); // 任意初始状态
    let msg = kani::any();   // 任意消息
    
    match protocol.transition(state, msg) {
        Ok(next_state) => {
            // 验证状态转换的合法性
            assert!(is_valid_transition(state, next_state));
        }
        Err(_) => {
            // 验证错误情况
        }
    }
}

fn is_valid_transition(from: TcpState, to: TcpState) -> bool {
    // 定义合法的状态转换
    matches!(
        (from, to),
        (TcpState::Closed, TcpState::SynSent)
        | (TcpState::Listen, TcpState::SynReceived)
        | (TcpState::SynSent, TcpState::Established)
        | // ... 其他合法转换
    )
}
```

---

## 4. 网络演算理论

### 时间Petri网（Timed Petri Net）

```rust
/// Petri网节点
#[derive(Debug, Clone)]
pub struct PetriNet {
    places: Vec<Place>,
    transitions: Vec<NetTransition>,
}

#[derive(Debug, Clone)]
pub struct Place {
    id: usize,
    tokens: usize,
}

#[derive(Debug, Clone)]
pub struct NetTransition {
    id: usize,
    input_places: Vec<(usize, usize)>,  // (place_id, tokens_required)
    output_places: Vec<(usize, usize)>, // (place_id, tokens_produced)
    min_delay: std::time::Duration,
    max_delay: std::time::Duration,
}

impl PetriNet {
    pub fn fire(&mut self, transition_id: usize) -> bool {
        let trans = &self.transitions[transition_id];
        
        // 检查是否可以触发
        for &(place_id, required) in &trans.input_places {
            if self.places[place_id].tokens < required {
                return false; // 令牌不足
            }
        }
        
        // 消耗输入令牌
        for &(place_id, required) in &trans.input_places {
            self.places[place_id].tokens -= required;
        }
        
        // 生产输出令牌
        for &(place_id, produced) in &trans.output_places {
            self.places[place_id].tokens += produced;
        }
        
        true
    }
    
    /// 验证死锁
    pub fn check_deadlock(&self) -> bool {
        for trans in &self.transitions {
            let can_fire = trans.input_places.iter().all(|&(place_id, required)| {
                self.places[place_id].tokens >= required
            });
            
            if can_fire {
                return false; // 至少有一个转换可以触发，无死锁
            }
        }
        
        true // 死锁
    }
}
```

### 进程演算（Process Calculus）

```rust
/// π-演算进程
#[derive(Debug, Clone)]
pub enum PiProcess {
    Nil,                                // 空进程
    Send(String, String, Box<PiProcess>), // 发送: channel!data.P
    Recv(String, Box<PiProcess>),       // 接收: channel?x.P
    Par(Box<PiProcess>, Box<PiProcess>), // 并行: P | Q
    New(String, Box<PiProcess>),        // 新建通道: (νchannel)P
    Repl(Box<PiProcess>),               // 复制: !P
}

impl PiProcess {
    /// 通信语义
    pub fn reduce(&self) -> Option<Self> {
        match self {
            PiProcess::Par(p, q) => {
                if let (
                    PiProcess::Send(ch1, data, cont1),
                    PiProcess::Recv(ch2, cont2),
                ) = (p.as_ref(), q.as_ref())
                {
                    if ch1 == ch2 {
                        // 通信发生
                        return Some(PiProcess::Par(cont1.clone(), cont2.clone()));
                    }
                }
                None
            }
            _ => None,
        }
    }
}

/// 使用π-演算建模TCP握手
pub fn tcp_handshake_pi_calculus() -> PiProcess {
    use PiProcess::*;
    
    // Client: SYN!data | SYNACK?x | ACK!data
    let client = Par(
        Box::new(Send("SYN".into(), "client_data".into(), Box::new(
            Recv("SYNACK".into(), Box::new(
                Send("ACK".into(), "ack_data".into(), Box::new(Nil))
            ))
        ))),
        Box::new(Nil),
    );
    
    // Server: SYN?x | SYNACK!data | ACK?x
    let server = Par(
        Box::new(Recv("SYN".into(), Box::new(
            Send("SYNACK".into(), "server_data".into(), Box::new(
                Recv("ACK".into(), Box::new(Nil))
            ))
        ))),
        Box::new(Nil),
    );
    
    Par(Box::new(client), Box::new(server))
}
```

---

## 5. 形式化TCP/IP

### TCP Reno拥塞控制算法形式化

```rust
/// TCP Reno拥塞控制状态
#[derive(Debug, Clone, Copy)]
pub enum CongestionState {
    SlowStart,
    CongestionAvoidance,
    FastRecovery,
}

pub struct TcpReno {
    cwnd: f64,            // 拥塞窗口
    ssthresh: f64,        // 慢启动阈值
    state: CongestionState,
    dup_acks: u32,
}

impl TcpReno {
    pub fn new(initial_cwnd: f64, initial_ssthresh: f64) -> Self {
        Self {
            cwnd: initial_cwnd,
            ssthresh: initial_ssthresh,
            state: CongestionState::SlowStart,
            dup_acks: 0,
        }
    }
    
    /// ACK到达
    pub fn on_ack(&mut self, is_dup: bool) {
        if is_dup {
            self.dup_acks += 1;
            
            if self.dup_acks == 3 {
                // Fast Retransmit & Fast Recovery
                self.ssthresh = self.cwnd / 2.0;
                self.cwnd = self.ssthresh + 3.0;
                self.state = CongestionState::FastRecovery;
            } else if matches!(self.state, CongestionState::FastRecovery) {
                self.cwnd += 1.0; // 每个重复ACK增加1 MSS
            }
        } else {
            // 新ACK
            self.dup_acks = 0;
            
            match self.state {
                CongestionState::SlowStart => {
                    self.cwnd += 1.0; // 指数增长
                    if self.cwnd >= self.ssthresh {
                        self.state = CongestionState::CongestionAvoidance;
                    }
                }
                CongestionState::CongestionAvoidance => {
                    self.cwnd += 1.0 / self.cwnd; // 线性增长
                }
                CongestionState::FastRecovery => {
                    self.cwnd = self.ssthresh;
                    self.state = CongestionState::CongestionAvoidance;
                }
            }
        }
    }
    
    /// 超时
    pub fn on_timeout(&mut self) {
        self.ssthresh = self.cwnd / 2.0;
        self.cwnd = 1.0;
        self.state = CongestionState::SlowStart;
        self.dup_acks = 0;
    }
    
    /// 形式化不变式验证
    pub fn verify_invariants(&self) -> bool {
        // 不变式1: cwnd > 0
        if self.cwnd <= 0.0 {
            return false;
        }
        
        // 不变式2: ssthresh >= 1
        if self.ssthresh < 1.0 {
            return false;
        }
        
        // 不变式3: 在FastRecovery时，cwnd >= ssthresh
        if matches!(self.state, CongestionState::FastRecovery) && self.cwnd < self.ssthresh {
            return false;
        }
        
        true
    }
}
```

### IP分片与重组形式化

```rust
/// IP分片算法
pub struct IpFragmentation {
    mtu: usize, // 最大传输单元
}

impl IpFragmentation {
    /// 分片：Packet → [Fragment]
    pub fn fragment(&self, payload: &[u8], id: u16) -> Vec<Fragment> {
        let header_size = 20; // IP头部大小
        let max_fragment_size = self.mtu - header_size;
        let aligned_size = (max_fragment_size / 8) * 8; // 8字节对齐
        
        payload
            .chunks(aligned_size)
            .enumerate()
            .map(|(i, chunk)| {
                let offset = (i * aligned_size) / 8;
                let more_fragments = (i + 1) * aligned_size < payload.len();
                
                Fragment {
                    id,
                    offset: offset as u16,
                    more_fragments,
                    data: chunk.to_vec(),
                }
            })
            .collect()
    }
    
    /// 重组：[Fragment] → Packet
    pub fn reassemble(&self, fragments: &mut [Fragment]) -> Option<Vec<u8>> {
        if fragments.is_empty() {
            return None;
        }
        
        // 按offset排序
        fragments.sort_by_key(|f| f.offset);
        
        // 验证连续性
        for window in fragments.windows(2) {
            let expected_offset = window[0].offset + (window[0].data.len() / 8) as u16;
            if window[1].offset != expected_offset {
                return None; // 分片不连续
            }
        }
        
        // 重组
        let mut result = Vec::new();
        for fragment in fragments {
            result.extend_from_slice(&fragment.data);
        }
        
        Some(result)
    }
}

#[derive(Debug, Clone)]
pub struct Fragment {
    id: u16,
    offset: u16,
    more_fragments: bool,
    data: Vec<u8>,
}
```

---

## 6. HTTP协议语义

### HTTP请求语义分析

```rust
/// HTTP请求的操作语义
pub trait HttpSemantics {
    type Request;
    type Response;
    type State;
    
    /// 小步语义：(Request, State) → (Response, State)
    fn eval(&self, req: Self::Request, state: Self::State) -> (Self::Response, Self::State);
    
    /// 幂等性检查
    fn is_idempotent(&self, req: &Self::Request) -> bool;
    
    /// 安全性检查（不修改状态）
    fn is_safe(&self, req: &Self::Request) -> bool;
}

#[derive(Debug, Clone)]
pub struct HttpRequest {
    method: String,
    path: String,
    headers: std::collections::HashMap<String, String>,
    body: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct HttpResponse {
    status: u16,
    headers: std::collections::HashMap<String, String>,
    body: Vec<u8>,
}

#[derive(Debug, Clone, Default)]
pub struct ServerState {
    resources: std::collections::HashMap<String, Vec<u8>>,
}

pub struct SimpleHttpSemantics;

impl HttpSemantics for SimpleHttpSemantics {
    type Request = HttpRequest;
    type Response = HttpResponse;
    type State = ServerState;
    
    fn eval(&self, req: Self::Request, mut state: Self::State) -> (Self::Response, Self::State) {
        match req.method.as_str() {
            "GET" => {
                let body = state.resources.get(&req.path).cloned().unwrap_or_default();
                (HttpResponse {
                    status: if body.is_empty() { 404 } else { 200 },
                    headers: Default::default(),
                    body,
                }, state)
            }
            "POST" => {
                state.resources.insert(req.path.clone(), req.body.clone());
                (HttpResponse {
                    status: 201,
                    headers: Default::default(),
                    body: Vec::new(),
                }, state)
            }
            "PUT" => {
                state.resources.insert(req.path.clone(), req.body.clone());
                (HttpResponse {
                    status: 200,
                    headers: Default::default(),
                    body: Vec::new(),
                }, state)
            }
            "DELETE" => {
                state.resources.remove(&req.path);
                (HttpResponse {
                    status: 204,
                    headers: Default::default(),
                    body: Vec::new(),
                }, state)
            }
            _ => (HttpResponse {
                status: 405,
                headers: Default::default(),
                body: Vec::new(),
            }, state),
        }
    }
    
    fn is_idempotent(&self, req: &Self::Request) -> bool {
        matches!(req.method.as_str(), "GET" | "PUT" | "DELETE" | "HEAD" | "OPTIONS")
    }
    
    fn is_safe(&self, req: &Self::Request) -> bool {
        matches!(req.method.as_str(), "GET" | "HEAD" | "OPTIONS")
    }
}
```

---

## 7. 协议组合与接口

### 协议栈的形式化组合

```rust
/// 协议层接口
pub trait ProtocolLayer {
    type UpperData;
    type LowerData;
    type Error;
    
    /// 向下封装
    fn encapsulate(&self, upper_data: Self::UpperData) -> Result<Self::LowerData, Self::Error>;
    
    /// 向上解封装
    fn decapsulate(&self, lower_data: Self::LowerData) -> Result<Self::UpperData, Self::Error>;
}

/// IP层
pub struct IpLayer;

impl ProtocolLayer for IpLayer {
    type UpperData = Vec<u8>; // TCP/UDP段
    type LowerData = Vec<u8>; // IP数据包
    type Error = String;
    
    fn encapsulate(&self, upper_data: Self::UpperData) -> Result<Self::LowerData, Self::Error> {
        let mut packet = vec![0x45, 0x00]; // IPv4, IHL=5
        packet.extend_from_slice(&(upper_data.len() as u16 + 20).to_be_bytes()); // Total Length
        packet.extend_from_slice(&[0, 0, 0, 0, 64, 6]); // ID, Flags, TTL, Protocol(TCP)
        packet.extend_from_slice(&[0, 0]); // Checksum (简化)
        packet.extend_from_slice(&[127, 0, 0, 1]); // Source IP
        packet.extend_from_slice(&[127, 0, 0, 1]); // Dest IP
        packet.extend_from_slice(&upper_data);
        
        Ok(packet)
    }
    
    fn decapsulate(&self, lower_data: Self::LowerData) -> Result<Self::UpperData, Self::Error> {
        if lower_data.len() < 20 {
            return Err("IP数据包太小".into());
        }
        
        Ok(lower_data[20..].to_vec())
    }
}

/// 协议栈组合
pub struct ProtocolStack<L1, L2>
where
    L1: ProtocolLayer,
    L2: ProtocolLayer<UpperData = L1::LowerData>,
{
    upper: L1,
    lower: L2,
}

impl<L1, L2> ProtocolStack<L1, L2>
where
    L1: ProtocolLayer,
    L2: ProtocolLayer<UpperData = L1::LowerData>,
{
    pub fn new(upper: L1, lower: L2) -> Self {
        Self { upper, lower }
    }
    
    /// 端到端封装
    pub fn send(&self, data: L1::UpperData) -> Result<L2::LowerData, String> {
        let intermediate = self.upper.encapsulate(data)
            .map_err(|_| "上层封装失败")?;
        
        self.lower.encapsulate(intermediate)
            .map_err(|_| "下层封装失败")
    }
    
    /// 端到端解封装
    pub fn receive(&self, data: L2::LowerData) -> Result<L1::UpperData, String> {
        let intermediate = self.lower.decapsulate(data)
            .map_err(|_| "下层解封装失败")?;
        
        self.upper.decapsulate(intermediate)
            .map_err(|_| "上层解封装失败")
    }
}
```

---

## 8. Rust类型系统验证

### 幽灵类型（Phantom Types）协议状态

```rust
use std::marker::PhantomData;

/// 协议状态标记
pub mod state {
    pub struct Closed;
    pub struct Connecting;
    pub struct Connected;
}

/// 类型状态的TCP连接
pub struct TypedTcpConnection<S> {
    socket: tokio::net::TcpStream,
    _state: PhantomData<S>,
}

impl TypedTcpConnection<state::Closed> {
    /// 只有在Closed状态才能连接
    pub async fn connect(addr: &str) -> std::io::Result<TypedTcpConnection<state::Connected>> {
        let socket = tokio::net::TcpStream::connect(addr).await?;
        
        Ok(TypedTcpConnection {
            socket,
            _state: PhantomData,
        })
    }
}

impl TypedTcpConnection<state::Connected> {
    /// 只有在Connected状态才能发送数据
    pub async fn send(&mut self, data: &[u8]) -> std::io::Result<()> {
        use tokio::io::AsyncWriteExt;
        self.socket.write_all(data).await
    }
    
    /// 只有在Connected状态才能关闭
    pub async fn close(self) -> std::io::Result<TypedTcpConnection<state::Closed>> {
        drop(self.socket);
        
        // 无法构造，因为TcpStream已被drop
        unimplemented!("关闭连接")
    }
}

/// 编译时保证状态转换的正确性
pub async fn typed_connection_example() {
    let conn = TypedTcpConnection::<state::Closed>::connect("127.0.0.1:8080")
        .await
        .unwrap();
    
    let mut conn = conn; // 类型: TypedTcpConnection<Connected>
    conn.send(b"Hello").await.unwrap();
    
    // ❌ 编译错误：Closed状态不能send
    // let closed = TypedTcpConnection::<state::Closed> { ... };
    // closed.send(b"Hello").await; // 编译失败
}
```

---

**文档完成**: 本文档涵盖了网络协议的形式化理论基础，包括状态机、验证、演算和类型系统验证。

**下一步**: [02_异步网络编程模式.md](./02_异步网络编程模式.md)

