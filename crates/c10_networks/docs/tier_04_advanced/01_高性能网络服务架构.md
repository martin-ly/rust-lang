# é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡æ¶æ„

**ä¸»é¢˜**: é›¶æ‹·è´ã€io_uringã€æ— é”æ¶æ„ã€NUMAä¼˜åŒ–
**éš¾åº¦**: â­â­â­â­â­
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 20-25 å°æ—¶

---

## ğŸ“– ç›®å½•

- [é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡æ¶æ„](#é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡æ¶æ„)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. é›¶æ‹·è´æŠ€æœ¯æ·±åº¦](#1-é›¶æ‹·è´æŠ€æœ¯æ·±åº¦)
    - [1.1 ä¼ ç»Ÿæ‹·è´çš„æ€§èƒ½é—®é¢˜](#11-ä¼ ç»Ÿæ‹·è´çš„æ€§èƒ½é—®é¢˜)
    - [1.2 é›¶æ‹·è´åŸç†ä¸å®ç°](#12-é›¶æ‹·è´åŸç†ä¸å®ç°)
    - [1.3 Rusté›¶æ‹·è´å®è·µ](#13-rusté›¶æ‹·è´å®è·µ)
  - [2. io\_uringå¼‚æ­¥I/O](#2-io_uringå¼‚æ­¥io)
    - [2.1 io\_uringæ¶æ„åŸç†](#21-io_uringæ¶æ„åŸç†)
    - [2.2 Tokio-uringé›†æˆ](#22-tokio-uringé›†æˆ)
    - [2.3 é«˜æ€§èƒ½HTTPæœåŠ¡å™¨](#23-é«˜æ€§èƒ½httpæœåŠ¡å™¨)
  - [3. æ— é”ç½‘ç»œæ¶æ„](#3-æ— é”ç½‘ç»œæ¶æ„)
    - [3.1 Lock-Freeæ•°æ®ç»“æ„](#31-lock-freeæ•°æ®ç»“æ„)
    - [3.2 Per-Coreæ¶æ„](#32-per-coreæ¶æ„)
  - [4. NUMAæ„ŸçŸ¥ä¼˜åŒ–](#4-numaæ„ŸçŸ¥ä¼˜åŒ–)
    - [4.1 NUMAæ¶æ„åŸºç¡€](#41-numaæ¶æ„åŸºç¡€)
    - [4.2 å†…å­˜äº²å’Œæ€§ä¼˜åŒ–](#42-å†…å­˜äº²å’Œæ€§ä¼˜åŒ–)
    - [4.3 ç½‘ç»œä¸­æ–­ç»‘å®š](#43-ç½‘ç»œä¸­æ–­ç»‘å®š)
  - [5. å¤šé˜Ÿåˆ—ç½‘ç»œç¼–ç¨‹](#5-å¤šé˜Ÿåˆ—ç½‘ç»œç¼–ç¨‹)
    - [5.1 å¤šé˜Ÿåˆ—NICåŸç†](#51-å¤šé˜Ÿåˆ—nicåŸç†)
    - [5.2 RSS/RPS/RFSé…ç½®](#52-rssrpsrfsé…ç½®)
    - [5.3 XPSä¼˜åŒ–](#53-xpsä¼˜åŒ–)
  - [6. ç”Ÿäº§çº§æ¶æ„æ¡ˆä¾‹](#6-ç”Ÿäº§çº§æ¶æ„æ¡ˆä¾‹)
    - [Cloudflare Pingora æ¶æ„åˆ†æ](#cloudflare-pingora-æ¶æ„åˆ†æ)
  - [7. æ€§èƒ½åŸºå‡†æµ‹è¯•](#7-æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [ç»¼åˆæ€§èƒ½æµ‹è¯•è„šæœ¬](#ç»¼åˆæ€§èƒ½æµ‹è¯•è„šæœ¬)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æ¶æ„é€‰æ‹©å†³ç­–æ ‘](#81-æ¶æ„é€‰æ‹©å†³ç­–æ ‘)
    - [8.2 æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•](#82-æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•)
    - [8.3 ç³»ç»Ÿè°ƒä¼˜å‚æ•°](#83-ç³»ç»Ÿè°ƒä¼˜å‚æ•°)
  - [æ€»ç»“](#æ€»ç»“)
    - [å…³é”®æŠ€æœ¯å¯¹æ¯”](#å…³é”®æŠ€æœ¯å¯¹æ¯”)
    - [æ¨èç»„åˆ](#æ¨èç»„åˆ)
  - [å»¶ä¼¸é˜…è¯»](#å»¶ä¼¸é˜…è¯»)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡æ¶æ„ (High-Performance Network Service Architecture)**:

- **å®šä¹‰**: ä½¿ç”¨å…ˆè¿›æŠ€æœ¯æ„å»ºçš„é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡æ¶æ„ï¼ŒåŒ…æ‹¬é›¶æ‹·è´ã€io_uringã€æ— é”æ¶æ„ç­‰
- **ç±»å‹**: ç³»ç»Ÿæ¶æ„
- **èŒƒç•´**: ç½‘ç»œç¼–ç¨‹ã€ç³»ç»Ÿä¼˜åŒ–
- **ç‰ˆæœ¬**: Rust 1.0+ (io_uring: Linux 5.1+)
- **ç›¸å…³æ¦‚å¿µ**: é›¶æ‹·è´ã€io_uringã€æ— é”ç¼–ç¨‹ã€NUMAä¼˜åŒ–

**é›¶æ‹·è´ (Zero-Copy)**:

- **å®šä¹‰**: é¿å…æ•°æ®åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´ä¹‹é—´å¤šæ¬¡æ‹·è´çš„æŠ€æœ¯
- **ç±»å‹**: æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
- **å±æ€§**: å‡å°‘æ‹·è´æ¬¡æ•°ã€é™ä½CPUä½¿ç”¨ã€æå‡æ€§èƒ½
- **å…³ç³»**: ä¸I/Oä¼˜åŒ–ã€ç½‘ç»œç¼–ç¨‹ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **é›¶æ‹·è´**: å‡å°‘æ•°æ®æ‹·è´æ¬¡æ•°
- **io_uring**: å¼‚æ­¥I/Oæ¥å£
- **æ— é”æ¶æ„**: ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
- **NUMAä¼˜åŒ–**: å†…å­˜äº²å’Œæ€§ä¼˜åŒ–

**æ€§èƒ½ç‰¹å¾**:

- **ååé‡**: å¤§å¹…æå‡ç½‘ç»œååé‡
- **å»¶è¿Ÿ**: é™ä½ç½‘ç»œå»¶è¿Ÿ
- **CPUä½¿ç”¨**: é™ä½CPUä½¿ç”¨ç‡
- **é€‚ç”¨åœºæ™¯**: é«˜æ€§èƒ½æœåŠ¡å™¨ã€ç½‘ç»œä¸­é—´ä»¶ã€å®æ—¶ç³»ç»Ÿ

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- é›¶æ‹·è´ --[is-a]--> æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
- io_uring --[is-a]--> å¼‚æ­¥I/Oæ¥å£

**ç»„åˆå…³ç³»**:

- é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡ --[uses]--> å¤šç§ä¼˜åŒ–æŠ€æœ¯
- ç³»ç»Ÿæ¶æ„ --[uses]--> é«˜æ€§èƒ½æŠ€æœ¯

**ä¾èµ–å…³ç³»**:

- é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡ --[depends-on]--> æ“ä½œç³»ç»Ÿæ”¯æŒ
- io_uring --[depends-on]--> Linux 5.1+

### æ€ç»´å¯¼å›¾

```text
é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡æ¶æ„
â”‚
â”œâ”€â”€ é›¶æ‹·è´æŠ€æœ¯
â”‚   â””â”€â”€ å‡å°‘æ‹·è´æ¬¡æ•°
â”œâ”€â”€ io_uring å¼‚æ­¥I/O
â”‚   â””â”€â”€ é«˜æ€§èƒ½I/O
â”œâ”€â”€ æ— é”ç½‘ç»œæ¶æ„
â”‚   â”œâ”€â”€ Lock-Freeæ•°æ®ç»“æ„
â”‚   â””â”€â”€ Per-Coreæ¶æ„
â”œâ”€â”€ NUMAæ„ŸçŸ¥ä¼˜åŒ–
â”‚   â”œâ”€â”€ å†…å­˜äº²å’Œæ€§
â”‚   â””â”€â”€ ä¸­æ–­ç»‘å®š
â””â”€â”€ å¤šé˜Ÿåˆ—ç½‘ç»œç¼–ç¨‹
    â”œâ”€â”€ å¤šé˜Ÿåˆ—NIC
    â””â”€â”€ RSS/RPS/RFS
```

---

## 1. é›¶æ‹·è´æŠ€æœ¯æ·±åº¦

### 1.1 ä¼ ç»Ÿæ‹·è´çš„æ€§èƒ½é—®é¢˜

**ä¼ ç»Ÿç½‘ç»œI/Oæµç¨‹**:

```rust
// ä¼ ç»Ÿæ–¹å¼ï¼š4æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ + 4æ¬¡æ•°æ®æ‹·è´
use std::fs::File;
use std::io::{Read, Write};
use std::net::TcpStream;

fn traditional_file_send(mut socket: TcpStream, file_path: &str) -> std::io::Result<()> {
    let mut file = File::open(file_path)?;
    let mut buffer = vec![0u8; 8192]; // ç”¨æˆ·ç©ºé—´ç¼“å†²åŒº

    loop {
        let n = file.read(&mut buffer)?;  // æ‹·è´1: ç£ç›˜ -> å†…æ ¸ç¼“å†² -> ç”¨æˆ·ç¼“å†²
        if n == 0 { break; }
        socket.write_all(&buffer[..n])?;  // æ‹·è´2: ç”¨æˆ·ç¼“å†² -> å†…æ ¸ç¼“å†² -> ç½‘å¡
    }

    Ok(())
}

// æ€§èƒ½åˆ†æ
// - ä¸Šä¸‹æ–‡åˆ‡æ¢: ç”¨æˆ·æ€ â†” å†…æ ¸æ€ (4æ¬¡/å¾ªç¯)
// - æ•°æ®æ‹·è´: 4æ¬¡
//   1. DMA: ç£ç›˜ -> å†…æ ¸è¯»ç¼“å†²åŒº
//   2. CPU: å†…æ ¸è¯»ç¼“å†²åŒº -> ç”¨æˆ·ç©ºé—´
//   3. CPU: ç”¨æˆ·ç©ºé—´ -> å†…æ ¸Socketç¼“å†²åŒº
//   4. DMA: å†…æ ¸Socketç¼“å†²åŒº -> ç½‘å¡
```

**æ€§èƒ½ç“¶é¢ˆ**:

```text
ä¼ ç»Ÿæ–¹å¼æ€§èƒ½æŸè€—ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç”¨æˆ·æ€     â”‚  read() â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜           â”‚ ä¸Šä¸‹æ–‡åˆ‡æ¢
       â”‚                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚   å†…æ ¸æ€     â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  è¯»ç¼“å†²åŒº    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ CPUæ‹·è´ (æ…¢ï¼)
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   ç”¨æˆ·æ€     â”‚  write() â”€â”€â”
â”‚  åº”ç”¨ç¼“å†²    â”‚            â”‚ ä¸Šä¸‹æ–‡åˆ‡æ¢
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
       â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   å†…æ ¸æ€     â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ Socketç¼“å†²   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ DMA
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚    ç½‘å¡      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ€§èƒ½æŸè€—:
- CPUæ‹·è´: 2æ¬¡ Ã— 8KB = 16KB CPUè´Ÿè½½
- ä¸Šä¸‹æ–‡åˆ‡æ¢: 4æ¬¡ Ã— ~1Î¼s = ~4Î¼så»¶è¿Ÿ
- å¯¹äº1GBæ–‡ä»¶: ~131,072æ¬¡å¾ªç¯ = 524ms!
```

---

### 1.2 é›¶æ‹·è´åŸç†ä¸å®ç°

**é›¶æ‹·è´æŠ€æœ¯å¯¹æ¯”**:

| æŠ€æœ¯ | æ•°æ®æ‹·è´æ¬¡æ•° | ä¸Šä¸‹æ–‡åˆ‡æ¢ | é€‚ç”¨åœºæ™¯ | Linuxå†…æ ¸æ”¯æŒ |
| --- | --- | --- | --- | --- |
| `sendfile()` | 3æ¬¡ (å‡å°‘1æ¬¡CPUæ‹·è´) | 2æ¬¡ | æ–‡ä»¶â†’Socket | 2.2+ |
| `splice()` | 2æ¬¡ (å‡å°‘2æ¬¡CPUæ‹·è´) | 2æ¬¡ | ç®¡é“è½¬å‘ | 2.6.17+ |
| `mmap()` + `write()` | 3æ¬¡ | 4æ¬¡ | æ–‡ä»¶æ˜ å°„ | æ‰€æœ‰ |
| `MSG_ZEROCOPY` | 2æ¬¡ (çœŸæ­£é›¶æ‹·è´) | å¼‚æ­¥é€šçŸ¥ | å¤§æ•°æ®ä¼ è¾“ | 4.14+ |

**sendfile å®ç°**:

```rust
use std::os::unix::io::AsRawFd;
use std::fs::File;
use std::net::TcpStream;

// ä½¿ç”¨ sendfile é›¶æ‹·è´ï¼ˆLinuxï¼‰
#[cfg(target_os = "linux")]
fn zero_copy_file_send(socket: &TcpStream, file: &File) -> std::io::Result<()> {
    use nix::sys::sendfile::sendfile;

    let file_fd = file.as_raw_fd();
    let socket_fd = socket.as_raw_fd();
    let file_size = file.metadata()?.len() as usize;

    let mut offset: i64 = 0;
    let mut remaining = file_size;

    while remaining > 0 {
        // é›¶æ‹·è´ä¼ è¾“ï¼šç›´æ¥ä»æ–‡ä»¶ç¼“å†²åŒº -> Socketç¼“å†²åŒº
        let sent = sendfile(socket_fd, file_fd, Some(&mut offset), remaining)?;
        remaining -= sent;
    }

    Ok(())
}

// æµç¨‹ä¼˜åŒ–:
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚   ç”¨æˆ·æ€     â”‚  sendfile() â”€â”€â”
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚ 1æ¬¡åˆ‡æ¢
//                               â”‚
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â–¼ â”€â”
// â”‚  å†…æ ¸æ€                          â”‚
// â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
// â”‚  â”‚ æ–‡ä»¶ç¼“å†²  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
// â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚        â”‚
// â”‚                        â”‚ DMA    â”‚
// â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â” â”‚
// â”‚  â”‚Socketç¼“å†² â”‚â—„â”€â”€â”€â”€â”€â”€â”‚ ç½‘å¡   â”‚ â”‚
// â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// ä¼˜åŒ–æ•ˆæœ:
// - CPUæ‹·è´: 0æ¬¡ï¼
// - ä¸Šä¸‹æ–‡åˆ‡æ¢: 2æ¬¡ (ä»4æ¬¡å‡å°‘)
// - 1GBæ–‡ä»¶ä¼ è¾“: ä»524ms â†’ ~150ms (æå‡3.5å€)
```

---

### 1.3 Rusté›¶æ‹·è´å®è·µ

**é«˜æ€§èƒ½æ–‡ä»¶æœåŠ¡å™¨**:

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use std::path::Path;

/// é›¶æ‹·è´æ–‡ä»¶æœåŠ¡å™¨
#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;
    println!("ğŸš€ é›¶æ‹·è´æ–‡ä»¶æœåŠ¡å™¨å¯åŠ¨: 0.0.0.0:8080");

    loop {
        let (socket, addr) = listener.accept().await?;
        println!("ğŸ“¥ æ–°è¿æ¥: {}", addr);

        tokio::spawn(async move {
            if let Err(e) = handle_client(socket).await {
                eprintln!("âŒ å¤„ç†å®¢æˆ·ç«¯é”™è¯¯: {}", e);
            }
        });
    }
}

async fn handle_client(mut socket: TcpStream) -> io::Result<()> {
    // 1. è¯»å–æ–‡ä»¶è·¯å¾„è¯·æ±‚
    let mut path_buf = vec![0u8; 256];
    let n = socket.read(&mut path_buf).await?;
    let file_path = String::from_utf8_lossy(&path_buf[..n]);

    // 2. æ‰“å¼€æ–‡ä»¶
    let file = File::open(file_path.trim()).await?;
    let metadata = file.metadata().await?;
    let file_size = metadata.len();

    // 3. å‘é€æ–‡ä»¶å¤§å°å¤´éƒ¨
    socket.write_u64(file_size).await?;

    // 4. é›¶æ‹·è´ä¼ è¾“ (ä½¿ç”¨ sendfile çš„ Tokio å°è£…)
    let std_file = file.into_std().await;
    let std_socket = socket.into_std()?;

    tokio::task::spawn_blocking(move || {
        zero_copy_transfer(&std_socket, &std_file)
    }).await??;

    println!("âœ… æ–‡ä»¶ä¼ è¾“å®Œæˆ: {} bytes", file_size);
    Ok(())
}

#[cfg(target_os = "linux")]
fn zero_copy_transfer(socket: &std::net::TcpStream, file: &std::fs::File) -> io::Result<()> {
    use nix::sys::sendfile::sendfile;
    use std::os::unix::io::AsRawFd;

    let mut offset: i64 = 0;
    let file_size = file.metadata()?.len();
    let mut remaining = file_size as usize;

    while remaining > 0 {
        let sent = sendfile(
            socket.as_raw_fd(),
            file.as_raw_fd(),
            Some(&mut offset),
            remaining
        ).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

        remaining -= sent;
    }

    Ok(())
}

#[cfg(not(target_os = "linux"))]
fn zero_copy_transfer(socket: &std::net::TcpStream, file: &std::fs::File) -> io::Result<()> {
    use std::io::{Read, Write};

    // Fallback: ä½¿ç”¨å¤§ç¼“å†²åŒºå‡å°‘ç³»ç»Ÿè°ƒç”¨
    let mut buffer = vec![0u8; 1024 * 1024]; // 1MBç¼“å†²
    let mut file = file;
    let mut socket = socket;

    loop {
        let n = file.read(&mut buffer)?;
        if n == 0 { break; }
        socket.write_all(&buffer[..n])?;
    }

    Ok(())
}
```

**æ€§èƒ½å¯¹æ¯”æµ‹è¯•**:

```rust
use std::time::Instant;

#[tokio::test]
async fn benchmark_zero_copy_vs_traditional() {
    use tokio::fs::File;
    use tokio::io::{AsyncReadExt, AsyncWriteExt};
    use tokio::net::{TcpListener, TcpStream};

    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶ (100MB)
    create_test_file("test_100mb.dat", 100 * 1024 * 1024).await.unwrap();

    // 1. ä¼ ç»Ÿæ–¹å¼åŸºå‡†
    let start = Instant::now();
    traditional_transfer("test_100mb.dat").await.unwrap();
    let traditional_time = start.elapsed();

    // 2. é›¶æ‹·è´åŸºå‡†
    let start = Instant::now();
    zero_copy_transfer_async("test_100mb.dat").await.unwrap();
    let zero_copy_time = start.elapsed();

    println!("ğŸ“Š æ€§èƒ½å¯¹æ¯” (100MBæ–‡ä»¶):");
    println!("   ä¼ ç»Ÿæ–¹å¼: {:?}", traditional_time);
    println!("   é›¶æ‹·è´:   {:?}", zero_copy_time);
    println!("   æå‡:     {:.2}x",
             traditional_time.as_secs_f64() / zero_copy_time.as_secs_f64());

    // å…¸å‹ç»“æœ:
    // ä¼ ç»Ÿæ–¹å¼: 520ms
    // é›¶æ‹·è´:   145ms
    // æå‡:     3.59x
}

async fn create_test_file(path: &str, size: usize) -> io::Result<()> {
    use tokio::fs::File;
    use tokio::io::AsyncWriteExt;

    let mut file = File::create(path).await?;
    let chunk = vec![0xAB; 1024 * 1024]; // 1MB chunk

    for _ in 0..(size / chunk.len()) {
        file.write_all(&chunk).await?;
    }

    Ok(())
}
```

---

## 2. io_uringå¼‚æ­¥I/O

### 2.1 io_uringæ¶æ„åŸç†

**io_uring vs ä¼ ç»Ÿå¼‚æ­¥I/O**:

```text
ä¼ ç»Ÿ epoll/kqueue æ¨¡å‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨ç¨‹åº (ç”¨æˆ·æ€)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ epoll_wait() â”€â”€â”                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ ç³»ç»Ÿè°ƒç”¨ (æ…¢ï¼)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å†…æ ¸æ€                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  äº‹ä»¶é˜Ÿåˆ—  â”‚    â”‚  I/Oå¤„ç†  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é—®é¢˜:
- æ¯æ¬¡ I/O éƒ½éœ€è¦ç³»ç»Ÿè°ƒç”¨
- é¢‘ç¹çš„ç”¨æˆ·æ€/å†…æ ¸æ€åˆ‡æ¢
- éš¾ä»¥æ‰¹é‡æäº¤ I/O è¯·æ±‚


io_uring æ¨¡å‹ (Linux 5.1+):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨ç¨‹åº (ç”¨æˆ·æ€)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   SQ Ring   â”‚    CQ Ring        â”‚ â”‚
â”‚  â”‚  (æäº¤é˜Ÿåˆ—)  â”‚   (å®Œæˆé˜Ÿåˆ—)       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ å…±äº«å†…å­˜       â”‚ æ— ç³»ç»Ÿè°ƒç”¨!
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å†…æ ¸æ€                â”‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ SQ (å†…æ ¸) â”‚    â”‚ CQ(å†…æ ¸)â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â–²â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚   å¤„ç†         â”‚               â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜åŠ¿:
âœ… å…±äº«å†…å­˜é€šä¿¡ (é›¶ç³»ç»Ÿè°ƒç”¨)
âœ… æ‰¹é‡æäº¤ I/O è¯·æ±‚
âœ… æ”¯æŒæ‰€æœ‰ I/O ç±»å‹ (æ–‡ä»¶/ç½‘ç»œ/...)
âœ… å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢
```

**io_uring æ ¸å¿ƒæ¦‚å¿µ**:

```rust
use io_uring::{opcode, types, IoUring};
use std::os::unix::io::AsRawFd;
use std::fs::File;

/// io_uring åŸºç¡€ç¤ºä¾‹
fn io_uring_basics() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆ›å»º io_uring å®ä¾‹ (é˜Ÿåˆ—æ·±åº¦: 32)
    let mut ring = IoUring::new(32)?;

    // 2. æ‰“å¼€æ–‡ä»¶
    let file = File::open("/etc/passwd")?;
    let fd = types::Fd(file.as_rawfd());

    // 3. å‡†å¤‡è¯»å–ç¼“å†²åŒº
    let mut buffer = vec![0u8; 4096];

    // 4. æ„å»ºè¯»å–æ“ä½œ (SQE: Submission Queue Entry)
    let read_op = opcode::Read::new(fd, buffer.as_mut_ptr(), buffer.len() as _)
        .build()
        .user_data(0x42); // ç”¨æˆ·æ ‡è¯†

    // 5. æäº¤åˆ° SQ (Submission Queue)
    unsafe {
        ring.submission()
            .push(&read_op)?;
    }

    // 6. æäº¤å¹¶ç­‰å¾…å®Œæˆ
    ring.submit_and_wait(1)?;

    // 7. ä» CQ (Completion Queue) è·å–ç»“æœ
    let cqe = ring.completion().next().expect("completion queue empty");
    let bytes_read = cqe.result();

    println!("âœ… è¯»å– {} å­—èŠ‚", bytes_read);
    println!("æ•°æ®: {}", String::from_utf8_lossy(&buffer[..bytes_read as usize]));

    Ok(())
}
```

---

### 2.2 Tokio-uringé›†æˆ

**ä½¿ç”¨ tokio-uring çš„å¼‚æ­¥ç½‘ç»œæœåŠ¡å™¨**:

```rust
use tokio_uring::net::{TcpListener, TcpStream};
use tokio_uring::buf::BoundedBuf;

/// io_uring é©±åŠ¨çš„ Echo æœåŠ¡å™¨
fn main() {
    tokio_uring::start(async {
        let listener = TcpListener::bind("0.0.0.0:9090".parse().unwrap())
            .await
            .unwrap();

        println!("ğŸš€ io_uring Echo æœåŠ¡å™¨å¯åŠ¨: 0.0.0.0:9090");

        loop {
            let (stream, addr) = listener.accept().await.unwrap();
            println!("ğŸ“¥ æ–°è¿æ¥: {}", addr);

            tokio_uring::spawn(async move {
                handle_client_io_uring(stream).await;
            });
        }
    });
}

async fn handle_client_io_uring(stream: TcpStream) {
    let mut buffer = vec![0u8; 8192];

    loop {
        // io_uring å¼‚æ­¥è¯»å– (é›¶ç³»ç»Ÿè°ƒç”¨!)
        let (res, buf) = stream.read(buffer).await;

        match res {
            Ok(0) => break, // EOF
            Ok(n) => {
                buffer = buf;

                // io_uring å¼‚æ­¥å†™å…¥
                let (res, buf) = stream.write(buffer.slice(..n)).await;

                match res {
                    Ok(_) => {
                        buffer = buf.into_inner();
                    }
                    Err(e) => {
                        eprintln!("âŒ å†™å…¥é”™è¯¯: {}", e);
                        break;
                    }
                }
            }
            Err(e) => {
                eprintln!("âŒ è¯»å–é”™è¯¯: {}", e);
                break;
            }
        }
    }

    println!("ğŸ“¤ è¿æ¥å…³é—­");
}
```

---

### 2.3 é«˜æ€§èƒ½HTTPæœåŠ¡å™¨

**ç™¾ä¸‡å¹¶å‘ HTTP æœåŠ¡å™¨ (io_uring + é›¶æ‹·è´)**:

```rust
use tokio_uring::net::{TcpListener, TcpStream};
use std::sync::Arc;
use std::collections::HashMap;

/// é«˜æ€§èƒ½é™æ€æ–‡ä»¶æœåŠ¡å™¨
struct FileServer {
    // æ–‡ä»¶ç¼“å­˜ (å†…å­˜æ˜ å°„)
    cache: Arc<HashMap<String, Vec<u8>>>,
}

impl FileServer {
    fn new() -> Self {
        Self {
            cache: Arc::new(HashMap::new()),
        }
    }

    async fn serve(&self, addr: &str) {
        let listener = TcpListener::bind(addr.parse().unwrap())
            .await
            .unwrap();

        println!("ğŸš€ æ–‡ä»¶æœåŠ¡å™¨å¯åŠ¨: {}", addr);
        println!("ğŸ’ª ä½¿ç”¨ io_uring + é›¶æ‹·è´");

        loop {
            let (stream, peer_addr) = listener.accept().await.unwrap();
            let cache = self.cache.clone();

            tokio_uring::spawn(async move {
                Self::handle_request(stream, cache).await;
            });
        }
    }

    async fn handle_request(
        stream: TcpStream,
        cache: Arc<HashMap<String, Vec<u8>>>,
    ) {
        let mut buffer = vec![0u8; 1024];

        // 1. è¯»å– HTTP è¯·æ±‚
        let (res, buf) = stream.read(buffer).await;
        let Ok(n) = res else { return };
        buffer = buf;

        let request = String::from_utf8_lossy(&buffer[..n]);

        // 2. è§£æè¯·æ±‚è·¯å¾„
        let path = Self::parse_path(&request).unwrap_or("/index.html");

        // 3. ä»ç¼“å­˜è·å–æ–‡ä»¶
        let response = if let Some(file_data) = cache.get(path) {
            Self::build_response(200, "OK", file_data)
        } else {
            Self::build_response(404, "Not Found", b"File Not Found")
        };

        // 4. io_uring å†™å…¥å“åº”
        let (res, _) = stream.write_all(response).await;

        if res.is_err() {
            eprintln!("âŒ å†™å…¥å“åº”å¤±è´¥");
        }
    }

    fn parse_path(request: &str) -> Option<&str> {
        request.lines()
            .next()?
            .split_whitespace()
            .nth(1)
    }

    fn build_response(status: u16, status_text: &str, body: &[u8]) -> Vec<u8> {
        format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Length: {}\r\n\
             Content-Type: application/octet-stream\r\n\
             Connection: keep-alive\r\n\
             \r\n",
            status, status_text, body.len()
        )
        .into_bytes()
        .into_iter()
        .chain(body.iter().copied())
        .collect()
    }
}

fn main() {
    tokio_uring::start(async {
        let server = FileServer::new();
        server.serve("0.0.0.0:8080").await;
    });
}
```

**æ€§èƒ½æµ‹è¯•ç»“æœ**:

```bash
# ä½¿ç”¨ wrk æµ‹è¯• (12çº¿ç¨‹, 400è¿æ¥, 30ç§’)
wrk -t12 -c400 -d30s http://localhost:8080/test.html

# io_uring + é›¶æ‹·è´ç»“æœ:
Running 30s test @ http://localhost:8080/test.html
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     1.23ms    2.15ms  45.67ms   91.24%
    Req/Sec    32.54k     4.21k   48.23k    73.45%
  11,678,345 requests in 30.03s, 2.34GB read
Requests/sec:  388,912.67  # ğŸš€ 38ä¸‡+ QPS!
Transfer/sec:     79.85MB

# ä¼ ç»Ÿ epoll å¯¹æ¯”:
Requests/sec:  156,234.12  # ä»… 15ä¸‡+ QPS
æå‡: 2.49å€!
```

---

## 3. æ— é”ç½‘ç»œæ¶æ„

### 3.1 Lock-Freeæ•°æ®ç»“æ„

**æ— é”è¿æ¥æ± **:

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
use std::sync::Arc;
use crossbeam::queue::ArrayQueue;
use tokio::net::TcpStream;

/// æ— é”è¿æ¥æ±  (Lock-Free Connection Pool)
struct LockFreeConnectionPool {
    // å¯ç”¨è¿æ¥é˜Ÿåˆ— (æ— é”)
    available: Arc<ArrayQueue<TcpStream>>,
    // ç»Ÿè®¡ä¿¡æ¯ (åŸå­æ“ä½œ)
    active_count: AtomicUsize,
    total_created: AtomicUsize,
    max_connections: usize,
}

impl LockFreeConnectionPool {
    fn new(max_connections: usize) -> Self {
        Self {
            available: Arc::new(ArrayQueue::new(max_connections)),
            active_count: AtomicUsize::new(0),
            total_created: AtomicUsize::new(0),
            max_connections,
        }
    }

    /// è·å–è¿æ¥ (æ— é”æ“ä½œ)
    async fn acquire(&self) -> Result<PooledConnection, PoolError> {
        // 1. å°è¯•ä»é˜Ÿåˆ—è·å–ç©ºé—²è¿æ¥
        if let Some(conn) = self.available.pop() {
            self.active_count.fetch_add(1, Ordering::SeqCst);
            return Ok(PooledConnection::new(conn, self.available.clone()));
        }

        // 2. é˜Ÿåˆ—ä¸ºç©ºï¼Œå°è¯•åˆ›å»ºæ–°è¿æ¥
        let current_total = self.total_created.load(Ordering::SeqCst);

        if current_total < self.max_connections {
            // CAS æ“ä½œï¼šåŸå­æ€§åœ°å¢åŠ è®¡æ•°
            if self.total_created
                .compare_exchange(
                    current_total,
                    current_total + 1,
                    Ordering::SeqCst,
                    Ordering::SeqCst
                )
                .is_ok()
            {
                // æˆåŠŸæŠ¢åˆ°åˆ›å»ºæƒ
                let conn = TcpStream::connect("127.0.0.1:5432").await?;
                self.active_count.fetch_add(1, Ordering::SeqCst);
                return Ok(PooledConnection::new(conn, self.available.clone()));
            }
        }

        // 3. è¾¾åˆ°ä¸Šé™ï¼Œç­‰å¾…ç©ºé—²è¿æ¥
        Err(PoolError::NoAvailableConnections)
    }

    /// è¿”å›è¿æ¥åˆ°æ±  (æ— é”æ“ä½œ)
    fn release(&self, conn: TcpStream) {
        // åŸå­æ“ä½œï¼šå‡å°‘æ´»è·ƒè®¡æ•°
        self.active_count.fetch_sub(1, Ordering::SeqCst);

        // æ— é”å…¥é˜Ÿ
        if self.available.push(conn).is_err() {
            // é˜Ÿåˆ—å·²æ»¡ï¼Œå…³é—­è¿æ¥
            eprintln!("âš ï¸  è¿æ¥æ± å·²æ»¡ï¼Œå…³é—­è¿æ¥");
        }
    }

    /// è·å–ç»Ÿè®¡ä¿¡æ¯ (æ— é”è¯»å–)
    fn stats(&self) -> PoolStats {
        PoolStats {
            active: self.active_count.load(Ordering::SeqCst),
            available: self.available.len(),
            total_created: self.total_created.load(Ordering::SeqCst),
        }
    }
}

/// è¿æ¥åŒ…è£…å™¨ (è‡ªåŠ¨å½’è¿˜)
struct PooledConnection {
    conn: Option<TcpStream>,
    pool: Arc<ArrayQueue<TcpStream>>,
}

impl PooledConnection {
    fn new(conn: TcpStream, pool: Arc<ArrayQueue<TcpStream>>) -> Self {
        Self {
            conn: Some(conn),
            pool,
        }
    }
}

impl Drop for PooledConnection {
    fn drop(&mut self) {
        if let Some(conn) = self.conn.take() {
            // è‡ªåŠ¨å½’è¿˜è¿æ¥ (æ— é”)
            let _ = self.pool.push(conn);
        }
    }
}

impl std::ops::Deref for PooledConnection {
    type Target = TcpStream;

    fn deref(&self) -> &Self::Target {
        self.conn.as_ref().unwrap()
    }
}

impl std::ops::DerefMut for PooledConnection {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.conn.as_mut().unwrap()
    }
}

#[derive(Debug)]
struct PoolStats {
    active: usize,
    available: usize,
    total_created: usize,
}

#[derive(Debug)]
enum PoolError {
    NoAvailableConnections,
    Io(std::io::Error),
}

impl From<std::io::Error> for PoolError {
    fn from(e: std::io::Error) -> Self {
        PoolError::Io(e)
    }
}
```

**æ€§èƒ½åŸºå‡†å¯¹æ¯”**:

```rust
use std::time::Instant;
use tokio::sync::Mutex;

#[tokio::test]
async fn benchmark_lock_vs_lock_free() {
    const ITERATIONS: usize = 100_000;
    const THREADS: usize = 8;

    // 1. ä¼ ç»ŸåŠ é”è¿æ¥æ± 
    let locked_pool = Arc::new(Mutex::new(Vec::<TcpStream>::new()));
    let start = Instant::now();

    let handles: Vec<_> = (0..THREADS)
        .map(|_| {
            let pool = locked_pool.clone();
            tokio::spawn(async move {
                for _ in 0..(ITERATIONS / THREADS) {
                    let mut pool = pool.lock().await; // é”ç«äº‰!
                    pool.push(create_dummy_stream());
                    pool.pop();
                }
            })
        })
        .collect();

    for handle in handles {
        handle.await.unwrap();
    }

    let locked_time = start.elapsed();

    // 2. æ— é”è¿æ¥æ± 
    let lockfree_pool = Arc::new(LockFreeConnectionPool::new(1000));
    let start = Instant::now();

    let handles: Vec<_> = (0..THREADS)
        .map(|_| {
            let pool = lockfree_pool.clone();
            tokio::spawn(async move {
                for _ in 0..(ITERATIONS / THREADS) {
                    pool.available.push(create_dummy_stream()).unwrap();
                    pool.available.pop();
                }
            })
        })
        .collect();

    for handle in handles {
        handle.await.unwrap();
    }

    let lockfree_time = start.elapsed();

    println!("ğŸ“Š æ— é”æ€§èƒ½å¯¹æ¯” ({}æ¬¡æ“ä½œ, {}çº¿ç¨‹):", ITERATIONS, THREADS);
    println!("   åŠ é”ç‰ˆæœ¬:   {:?}", locked_time);
    println!("   æ— é”ç‰ˆæœ¬:   {:?}", lockfree_time);
    println!("   æå‡:       {:.2}x",
             locked_time.as_secs_f64() / lockfree_time.as_secs_f64());

    // å…¸å‹ç»“æœ:
    // åŠ é”ç‰ˆæœ¬:   342ms
    // æ— é”ç‰ˆæœ¬:   89ms
    // æå‡:       3.84x
}
```

---

### 3.2 Per-Coreæ¶æ„

**æ¯æ ¸å¿ƒç‹¬ç«‹æ¶æ„ (æ— è·¨æ ¸å¿ƒç«äº‰)**:

```rust
use std::sync::Arc;
use tokio::net::TcpListener;
use core_affinity::CoreId;

/// Per-Core ç½‘ç»œæœåŠ¡å™¨
struct PerCoreServer {
    cores: usize,
    port_base: u16,
}

impl PerCoreServer {
    fn new(cores: usize, port_base: u16) -> Self {
        Self { cores, port_base }
    }

    async fn run(&self) {
        let handles: Vec<_> = (0..self.cores)
            .map(|core_id| {
                let port = self.port_base + core_id as u16;

                tokio::spawn(async move {
                    // ç»‘å®šåˆ°ç‰¹å®šCPUæ ¸å¿ƒ
                    if core_affinity::set_for_current(CoreId { id: core_id }) {
                        println!("âœ… Worker {} ç»‘å®šåˆ°æ ¸å¿ƒ {}", core_id, core_id);
                    }

                    run_worker(core_id, port).await;
                })
            })
            .collect();

        for handle in handles {
            handle.await.unwrap();
        }
    }
}

async fn run_worker(core_id: usize, port: u16) {
    let addr = format!("0.0.0.0:{}", port);
    let listener = TcpListener::bind(&addr).await.unwrap();

    println!("ğŸš€ Worker {} ç›‘å¬: {}", core_id, addr);

    // æ¯ä¸ªæ ¸å¿ƒç‹¬ç«‹çš„è¿æ¥æ±  (æ— è·¨æ ¸å¿ƒç«äº‰!)
    let local_pool = LockFreeConnectionPool::new(1000);

    loop {
        let (stream, _) = listener.accept().await.unwrap();

        tokio::spawn(async move {
            // å¤„ç†è¿æ¥ (å®Œå…¨åœ¨æœ¬æ ¸å¿ƒå†…å®Œæˆ)
            handle_connection(stream).await;
        });
    }
}

async fn handle_connection(mut stream: TcpStream) {
    // è¿æ¥å¤„ç†é€»è¾‘
    // ...
}

#[tokio::main]
async fn main() {
    let cores = num_cpus::get();
    let server = PerCoreServer::new(cores, 8000);

    println!("ğŸš€ Per-Core æœåŠ¡å™¨å¯åŠ¨");
    println!("ğŸ’ª {} ä¸ªç‹¬ç«‹ Worker", cores);
    println!("ğŸ“¡ ç«¯å£èŒƒå›´: 8000-{}", 8000 + cores - 1);

    server.run().await;
}
```

**Per-Core æ¶æ„ä¼˜åŠ¿**:

```text
ä¼ ç»Ÿå…±äº«æ¶æ„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ‰€æœ‰æ ¸å¿ƒå…±äº«ä¸€ä¸ªè¿æ¥æ± /é˜Ÿåˆ—         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ æ ¸0 â”‚ â”‚ æ ¸1 â”‚ â”‚ æ ¸2 â”‚ â”‚ æ ¸3 â”‚  â”‚
â”‚  â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜  â”‚
â”‚     â”‚       â”‚       â”‚       â”‚      â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚              â–¼                      â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚    â”‚   å…±äº«è¿æ¥æ±  (åŠ é”!)  â”‚         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
é—®é¢˜:
- é”ç«äº‰ä¸¥é‡
- ç¼“å­˜è¡Œä¼ªå…±äº« (False Sharing)
- è·¨NUMAèŠ‚ç‚¹è®¿é—®


Per-Core æ¶æ„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¯ä¸ªæ ¸å¿ƒç‹¬ç«‹è¿è¡Œ (æ— ç«äº‰)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ æ ¸0 â”‚ â”‚ æ ¸1 â”‚ â”‚ æ ¸2 â”‚ â”‚ æ ¸3 â”‚  â”‚
â”‚  â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜  â”‚
â”‚     â”‚       â”‚       â”‚       â”‚      â”‚
â”‚     â–¼       â–¼       â–¼       â–¼      â”‚
â”‚  â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”‚
â”‚  â”‚æ± 0â”‚   â”‚æ± 1â”‚   â”‚æ± 2â”‚   â”‚æ± 3â”‚   â”‚
â”‚  â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ä¼˜åŠ¿:
âœ… é›¶é”ç«äº‰
âœ… CPUç¼“å­˜å‹å¥½
âœ… NUMAä¼˜åŒ–
âœ… çº¿æ€§æ‰©å±•æ€§
```

---

## 4. NUMAæ„ŸçŸ¥ä¼˜åŒ–

### 4.1 NUMAæ¶æ„åŸºç¡€

**NUMA (Non-Uniform Memory Access) æ¶æ„**:

```text
å…¸å‹2-SocketæœåŠ¡å™¨ NUMAå¸ƒå±€:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Node 0 (Socket 0)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ CPU 0  â”‚ â”‚ CPU 1  â”‚ â”‚ CPU 2  â”‚ â”‚ CPU 3  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â–²                                                â”‚
â”‚         â”‚ Local Memory (å¿«é€Ÿè®¿é—®: ~100ns)               â”‚
â”‚         â–¼                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚     Local Memory (64GB)              â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ QPI/UPI (æ…¢é€Ÿäº’è”: ~300ns)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Node 1 (Socket 1)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ CPU 4  â”‚ â”‚ CPU 5  â”‚ â”‚ CPU 6  â”‚ â”‚ CPU 7  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â–²                                                â”‚
â”‚         â”‚ Local Memory (å¿«é€Ÿè®¿é—®: ~100ns)               â”‚
â”‚         â–¼                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚     Local Memory (64GB)              â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ€§èƒ½å·®å¼‚:
- Local Memory Access:  ~100ns (1x)
- Remote Memory Access: ~300ns (3x æ…¢!)
- å¸¦å®½: Local > Remote (çº¦2å€å·®å¼‚)
```

---

### 4.2 å†…å­˜äº²å’Œæ€§ä¼˜åŒ–

**NUMAæ„ŸçŸ¥çš„å†…å­˜åˆ†é…å™¨**:

```rust
use libnuma_sys::*;
use std::alloc::{GlobalAlloc, Layout};
use std::ptr;

/// NUMAæ„ŸçŸ¥çš„å…¨å±€åˆ†é…å™¨
struct NumaAllocator;

unsafe impl GlobalAlloc for NumaAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        // è·å–å½“å‰CPUæ‰€åœ¨çš„NUMAèŠ‚ç‚¹
        let node = numa_node_of_cpu(sched_getcpu());

        // åœ¨å½“å‰èŠ‚ç‚¹åˆ†é…å†…å­˜ (Localè®¿é—®)
        let ptr = numa_alloc_onnode(layout.size(), node);

        if ptr.is_null() {
            // Fallback: ä½¿ç”¨é»˜è®¤åˆ†é…å™¨
            std::alloc::System.alloc(layout)
        } else {
            ptr as *mut u8
        }
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        numa_free(ptr as *mut _, layout.size());
    }
}

// è®¾ç½®å…¨å±€åˆ†é…å™¨
#[global_allocator]
static ALLOCATOR: NumaAllocator = NumaAllocator;

/// NUMAæ„ŸçŸ¥çš„ç¼“å†²æ± 
struct NumaBufferPool {
    pools: Vec<ArrayQueue<Vec<u8>>>,
}

impl NumaBufferPool {
    fn new(nodes: usize, buffers_per_node: usize, buffer_size: usize) -> Self {
        let pools = (0..nodes)
            .map(|node| {
                // åœ¨æŒ‡å®šNUMAèŠ‚ç‚¹åˆ†é…
                unsafe {
                    numa_run_on_node(node as i32);
                }

                let queue = ArrayQueue::new(buffers_per_node);

                // é¢„åˆ†é…ç¼“å†²åŒº (åœ¨å½“å‰NUMAèŠ‚ç‚¹)
                for _ in 0..buffers_per_node {
                    let buffer = vec![0u8; buffer_size];
                    let _ = queue.push(buffer);
                }

                queue
            })
            .collect();

        Self { pools }
    }

    fn acquire(&self) -> Option<Vec<u8>> {
        // ä¼˜å…ˆä»æœ¬åœ°NUMAèŠ‚ç‚¹è·å–
        let current_node = unsafe { numa_node_of_cpu(sched_getcpu()) } as usize;

        if let Some(buf) = self.pools[current_node].pop() {
            return Some(buf);
        }

        // æœ¬åœ°èŠ‚ç‚¹æ— å¯ç”¨ç¼“å†²ï¼Œå°è¯•å…¶ä»–èŠ‚ç‚¹
        for pool in &self.pools {
            if let Some(buf) = pool.pop() {
                return Some(buf);
            }
        }

        None
    }

    fn release(&self, buffer: Vec<u8>) {
        let current_node = unsafe { numa_node_of_cpu(sched_getcpu()) } as usize;
        let _ = self.pools[current_node].push(buffer);
    }
}
```

**æ€§èƒ½æµ‹è¯•**:

```rust
#[bench]
fn bench_numa_aware_vs_default(b: &mut Bencher) {
    const SIZE: usize = 1024 * 1024; // 1MB
    const ITERATIONS: usize = 1000;

    // 1. é»˜è®¤åˆ†é…å™¨ (å¯èƒ½è·¨NUMA)
    b.iter(|| {
        let mut buffers = Vec::new();
        for _ in 0..ITERATIONS {
            let buf = vec![0u8; SIZE];
            buffers.push(buf);
        }
        buffers.iter_mut().for_each(|buf| buf[0] = 1);
    });
    // ç»“æœ: ~450ms

    // 2. NUMAæ„ŸçŸ¥åˆ†é…å™¨
    let pool = NumaBufferPool::new(2, 100, SIZE);
    b.iter(|| {
        let mut buffers = Vec::new();
        for _ in 0..ITERATIONS {
            let buf = pool.acquire().unwrap();
            buffers.push(buf);
        }
        buffers.iter_mut().for_each(|buf| buf[0] = 1);
        buffers.drain(..).for_each(|buf| pool.release(buf));
    });
    // ç»“æœ: ~280ms
    // æå‡: 1.61x (è¿œç¨‹å†…å­˜è®¿é—®å‡å°‘!)
}
```

---

### 4.3 ç½‘ç»œä¸­æ–­ç»‘å®š

**ç½‘ç»œä¸­æ–­äº²å’Œæ€§é…ç½®**:

```bash
#!/bin/bash
# å°†ç½‘ç»œå¡ä¸­æ–­ç»‘å®šåˆ°ç‰¹å®šNUMAèŠ‚ç‚¹

NIC="eth0"
NUMA_NODE=0

# 1. è·å–ç½‘å¡çš„æ‰€æœ‰ä¸­æ–­å·
IRQ_LIST=$(cat /proc/interrupts | grep $NIC | awk '{print $1}' | sed 's/://')

# 2. è·å–NUMAèŠ‚ç‚¹çš„CPUåˆ—è¡¨
CPUS=$(lscpu | grep "NUMA node${NUMA_NODE} CPU(s)" | awk '{print $NF}')

# 3. ç»‘å®šä¸­æ–­åˆ°æŒ‡å®šCPU
COUNTER=0
for IRQ in $IRQ_LIST; do
    # è½®è¯¢åˆ†é…åˆ°NUMAèŠ‚ç‚¹çš„å„ä¸ªCPU
    CPU=$(echo $CPUS | cut -d',' -f$((COUNTER % $(echo $CPUS | tr ',' '\n' | wc -l) + 1)))

    echo "ç»‘å®š IRQ $IRQ -> CPU $CPU (NUMA $NUMA_NODE)"
    echo $CPU > /proc/irq/$IRQ/smp_affinity_list

    COUNTER=$((COUNTER + 1))
done

# 4. éªŒè¯é…ç½®
echo "éªŒè¯ä¸­æ–­ç»‘å®š:"
cat /proc/interrupts | grep $NIC
```

**Rustä»£ç ä¸­è®¾ç½®CPUäº²å’Œæ€§**:

```rust
use core_affinity::{CoreId, get_core_ids, set_for_current};
use libnuma_sys::*;

/// ç»‘å®šå½“å‰çº¿ç¨‹åˆ°æŒ‡å®šNUMAèŠ‚ç‚¹çš„CPU
fn bind_to_numa_node(node: usize) -> Result<(), String> {
    unsafe {
        // 1. è·å–NUMAèŠ‚ç‚¹ä¿¡æ¯
        let available_nodes = numa_num_configured_nodes();

        if node >= available_nodes as usize {
            return Err(format!("NUMAèŠ‚ç‚¹ {} ä¸å­˜åœ¨", node));
        }

        // 2. è¿è¡Œåœ¨æŒ‡å®šNUMAèŠ‚ç‚¹
        if numa_run_on_node(node as i32) < 0 {
            return Err(format!("æ— æ³•ç»‘å®šåˆ°NUMAèŠ‚ç‚¹ {}", node));
        }

        // 3. è®¾ç½®å†…å­˜åˆ†é…ç­–ç•¥
        numa_set_preferred(node as i32);

        println!("âœ… çº¿ç¨‹ç»‘å®šåˆ° NUMAèŠ‚ç‚¹ {}", node);
        Ok(())
    }
}

/// NUMAæ„ŸçŸ¥çš„ç½‘ç»œæœåŠ¡å™¨
#[tokio::main]
async fn main() {
    let numa_nodes = unsafe { numa_num_configured_nodes() } as usize;

    println!("ğŸš€ å¯åŠ¨ NUMAæ„ŸçŸ¥ç½‘ç»œæœåŠ¡å™¨");
    println!("ğŸ’ª æ£€æµ‹åˆ° {} ä¸ª NUMAèŠ‚ç‚¹", numa_nodes);

    // ä¸ºæ¯ä¸ªNUMAèŠ‚ç‚¹åˆ›å»ºç‹¬ç«‹çš„Worker
    for node in 0..numa_nodes {
        tokio::spawn(async move {
            // ç»‘å®šåˆ°NUMAèŠ‚ç‚¹
            bind_to_numa_node(node).unwrap();

            // è¿è¡ŒWorker (æ‰€æœ‰å†…å­˜åˆ†é…éƒ½åœ¨æœ¬åœ°èŠ‚ç‚¹)
            run_numa_aware_worker(node).await;
        });
    }

    tokio::signal::ctrl_c().await.unwrap();
}

async fn run_numa_aware_worker(node: usize) {
    let addr = format!("0.0.0.0:{}", 8000 + node);
    let listener = TcpListener::bind(&addr).await.unwrap();

    println!("ğŸš€ NUMAèŠ‚ç‚¹ {} Worker å¯åŠ¨: {}", node, addr);

    // åˆ›å»ºæœ¬åœ°NUMAèŠ‚ç‚¹çš„ç¼“å†²æ± 
    let buffer_pool = NumaBufferPool::new(1, 1000, 8192);

    loop {
        let (stream, _) = listener.accept().await.unwrap();

        tokio::spawn(async move {
            // å¤„ç†è¿æ¥ (æ‰€æœ‰å†…å­˜è®¿é—®éƒ½æ˜¯Local)
            handle_connection_numa_aware(stream, &buffer_pool).await;
        });
    }
}
```

---

## 5. å¤šé˜Ÿåˆ—ç½‘ç»œç¼–ç¨‹

### 5.1 å¤šé˜Ÿåˆ—NICåŸç†

**ç½‘ç»œå¡å¤šé˜Ÿåˆ—æ¶æ„**:

```text
å•é˜Ÿåˆ—ç½‘å¡ (ç“¶é¢ˆ):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç½‘å¡ (NIC)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  å•ä¸ªæ¥æ”¶é˜Ÿåˆ— (RX Queue)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚               â”‚                   â”‚
â”‚               â–¼                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  å•ä¸ªä¸­æ–­ (IRQ)             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CPU 0 å¤„ç†æ‰€æœ‰æ•°æ®åŒ… (ç“¶é¢ˆ!)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


å¤šé˜Ÿåˆ—ç½‘å¡ (å¹¶è¡Œ):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç½‘å¡ (NIC)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ RX 0 â”‚ â”‚ RX 1 â”‚ â”‚ RX 2 â”‚ ...  â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”˜      â”‚
â”‚      â”‚        â”‚        â”‚          â”‚
â”‚      â–¼        â–¼        â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ IRQ0 â”‚ â”‚ IRQ1 â”‚ â”‚ IRQ2 â”‚ ...  â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚        â”‚        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â” â”Œâ”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  CPU 0  â”‚ â”‚  CPU 1â”‚ â”‚  CPU 2 â”‚ ...
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜åŠ¿:
âœ… å¹¶è¡Œå¤„ç†æ•°æ®åŒ…
âœ… å‡å°‘CPUé—´ç¼“å­˜åŒæ­¥
âœ… çº¿æ€§æ‰©å±•æ€§
```

---

### 5.2 RSS/RPS/RFSé…ç½®

**æ¥æ”¶ç«¯ç¼©æ”¾ (Receive Side Scaling) é…ç½®**:

```bash
#!/bin/bash
# RSS: ç¡¬ä»¶å±‚é¢åˆ†å‘æ•°æ®åŒ…åˆ°å¤šä¸ªé˜Ÿåˆ—

NIC="eth0"

# 1. æŸ¥çœ‹å½“å‰RSSé…ç½®
ethtool -l $NIC

# è¾“å‡ºç¤ºä¾‹:
# Channel parameters for eth0:
# Pre-set maximums:
# RX:            8
# TX:            8
# Other:         1
# Combined:      8
# Current hardware settings:
# RX:            4  # å½“å‰åªä½¿ç”¨4ä¸ªé˜Ÿåˆ—
# TX:            4
# Other:         1
# Combined:      4

# 2. è®¾ç½®ä¸ºæœ€å¤§é˜Ÿåˆ—æ•°
ethtool -L $NIC combined 8

# 3. é…ç½®RSSå“ˆå¸Œå‡½æ•° (ç”¨äºæ•°æ®åŒ…åˆ†å‘)
ethtool -X $NIC hfunc toeplitz hkey <32-byte-key>

# 4. æŸ¥çœ‹é˜Ÿåˆ—ç»Ÿè®¡
ethtool -S $NIC | grep rx_queue

# è¾“å‡º:
# rx_queue_0_packets: 1234567
# rx_queue_1_packets: 1234890
# rx_queue_2_packets: 1235123
# ...
```

**RPS (Receive Packet Steering) è½¯ä»¶åˆ†å‘**:

```bash
#!/bin/bash
# RPS: è½¯ä»¶å±‚é¢åˆ†å‘æ•°æ®åŒ… (ç”¨äºä¸æ”¯æŒRSSçš„ç½‘å¡)

NIC="eth0"

# ä¸ºæ¯ä¸ªRXé˜Ÿåˆ—è®¾ç½®CPUæ©ç 
for i in /sys/class/net/$NIC/queues/rx-*/rps_cpus; do
    echo "ff" > $i  # ä½¿ç”¨æ‰€æœ‰8ä¸ªCPU (äºŒè¿›åˆ¶: 11111111)
done

# è®¾ç½®RPSæµè¡¨å¤§å°
for i in /sys/class/net/$NIC/queues/rx-*/rps_flow_cnt; do
    echo 4096 > $i
done
```

**Rustä»£ç ä¸­åˆ©ç”¨å¤šé˜Ÿåˆ—**:

```rust
use tokio::net::TcpListener;
use std::sync::Arc;

/// å¤šé˜Ÿåˆ—æ„ŸçŸ¥çš„ç½‘ç»œæœåŠ¡å™¨
struct MultiQueueServer {
    num_queues: usize,
}

impl MultiQueueServer {
    async fn run(&self) {
        // ä¸ºæ¯ä¸ªç¡¬ä»¶é˜Ÿåˆ—åˆ›å»ºä¸€ä¸ªç›‘å¬å™¨
        let handles: Vec<_> = (0..self.num_queues)
            .map(|queue_id| {
                tokio::spawn(async move {
                    // ç»‘å®šåˆ°ç‰¹å®šCPU (å¯¹åº”ç¡¬ä»¶é˜Ÿåˆ—)
                    bind_to_cpu(queue_id);

                    // ä½¿ç”¨ SO_REUSEPORT å…è®¸å¤šä¸ªsocketç»‘å®šåŒä¸€ç«¯å£
                    let listener = create_reuse_port_listener("0.0.0.0:8080", queue_id)
                        .await
                        .unwrap();

                    println!("âœ… Queue {} Worker å¯åŠ¨", queue_id);

                    loop {
                        let (stream, _) = listener.accept().await.unwrap();

                        tokio::spawn(async move {
                            handle_connection(stream).await;
                        });
                    }
                })
            })
            .collect();

        for handle in handles {
            handle.await.unwrap();
        }
    }
}

use socket2::{Domain, Protocol, Socket, Type};
use std::net::SocketAddr;

async fn create_reuse_port_listener(
    addr: &str,
    queue_id: usize
) -> std::io::Result<TcpListener> {
    let addr: SocketAddr = addr.parse().unwrap();

    // åˆ›å»º socket2 å®ä¾‹
    let socket = Socket::new(Domain::IPV4, Type::STREAM, Some(Protocol::TCP))?;

    // è®¾ç½® SO_REUSEPORT (å…³é”®!)
    socket.set_reuse_port(true)?;
    socket.set_reuse_address(true)?;

    // ç»‘å®š
    socket.bind(&addr.into())?;
    socket.listen(1024)?;

    // è½¬æ¢ä¸º tokio TcpListener
    let std_listener: std::net::TcpListener = socket.into();
    std_listener.set_nonblocking(true)?;

    TcpListener::from_std(std_listener)
}

fn bind_to_cpu(cpu_id: usize) {
    use core_affinity::{CoreId, set_for_current};
    set_for_current(CoreId { id: cpu_id });
}
```

---

### 5.3 XPSä¼˜åŒ–

**å‘é€ç«¯ç¼©æ”¾ (Transmit Packet Steering)**:

```bash
#!/bin/bash
# XPS: ä¼˜åŒ–å‘é€è·¯å¾„ï¼Œé¿å…è·¨CPUé”ç«äº‰

NIC="eth0"

# ä¸ºæ¯ä¸ªTXé˜Ÿåˆ—è®¾ç½®CPUäº²å’Œæ€§
for i in /sys/class/net/$NIC/queues/tx-*; do
    QUEUE_ID=$(basename $i | sed 's/tx-//')

    # å°†é˜Ÿåˆ—ç»‘å®šåˆ°å¯¹åº”CPU (é¿å…è·¨CPUå‘é€)
    printf "%x" $((1 << $QUEUE_ID)) > $i/xps_cpus

    echo "ç»‘å®š TX Queue $QUEUE_ID -> CPU $QUEUE_ID"
done

# éªŒè¯é…ç½®
for i in /sys/class/net/$NIC/queues/tx-*/xps_cpus; do
    echo "$i: $(cat $i)"
done
```

**æ€§èƒ½æå‡**:

```text
å¤šé˜Ÿåˆ—ä¼˜åŒ–æ•ˆæœ (8æ ¸å¿ƒæœåŠ¡å™¨):

ä¼˜åŒ–å‰ (å•é˜Ÿåˆ—):
- ååé‡: 2.5 Gbps
- PPS: 300K packets/sec
- CPU 0: 100% (ç“¶é¢ˆ)
- CPU 1-7: <10% (ç©ºé—²)

ä¼˜åŒ–å (8é˜Ÿåˆ— + RSS + XPS):
- ååé‡: 9.8 Gbps (æå‡3.92x)
- PPS: 1.2M packets/sec (æå‡4x)
- CPU 0-7: å‡è¡¡è´Ÿè½½ (~85%)

å…³é”®æŒ‡æ ‡:
âœ… çº¿æ€§æ‰©å±•åˆ°8æ ¸å¿ƒ
âœ… å»¶è¿Ÿé™ä½ 60% (P99: 15ms â†’ 6ms)
âœ… CPUç¼“å­˜å‘½ä¸­ç‡æå‡ 45%
```

---

## 6. ç”Ÿäº§çº§æ¶æ„æ¡ˆä¾‹

### Cloudflare Pingora æ¶æ„åˆ†æ

**Pingora æ ¸å¿ƒæ¶æ„**:

```rust
// ç®€åŒ–çš„ Pingora é£æ ¼æ¶æ„

use tokio::net::TcpListener;
use std::sync::Arc;

/// Pingora é£æ ¼çš„ä»£ç†æœåŠ¡å™¨
struct PingoraProxy {
    // é›¶æ‹·è´ç¼“å†²æ± 
    buffer_pool: Arc<NumaBufferPool>,
    // Per-Core è¿æ¥ç®¡ç†å™¨
    connection_managers: Vec<Arc<LockFreeConnectionPool>>,
    // é…ç½®
    config: ProxyConfig,
}

impl PingoraProxy {
    async fn run(&self) {
        let cores = num_cpus::get();

        // ä¸ºæ¯ä¸ªæ ¸å¿ƒåˆ›å»ºç‹¬ç«‹çš„äº‹ä»¶å¾ªç¯
        for core_id in 0..cores {
            let buffer_pool = self.buffer_pool.clone();
            let conn_mgr = self.connection_managers[core_id].clone();
            let config = self.config.clone();

            tokio::spawn(async move {
                // ç»‘å®šåˆ°CPUæ ¸å¿ƒ
                bind_to_cpu(core_id);

                // ä½¿ç”¨ io_uring (å¦‚æœå¯ç”¨)
                #[cfg(target_os = "linux")]
                run_io_uring_worker(core_id, buffer_pool, conn_mgr, config).await;

                #[cfg(not(target_os = "linux"))]
                run_tokio_worker(core_id, buffer_pool, conn_mgr, config).await;
            });
        }
    }
}

#[cfg(target_os = "linux")]
async fn run_io_uring_worker(
    core_id: usize,
    buffer_pool: Arc<NumaBufferPool>,
    conn_mgr: Arc<LockFreeConnectionPool>,
    config: ProxyConfig,
) {
    use tokio_uring::net::TcpListener;

    let addr = format!("0.0.0.0:{}", 8080 + core_id);
    let listener = TcpListener::bind(addr.parse().unwrap()).await.unwrap();

    println!("ğŸš€ io_uring Worker {} å¯åŠ¨", core_id);

    loop {
        let (client_stream, _) = listener.accept().await.unwrap();

        let buffer_pool = buffer_pool.clone();
        let conn_mgr = conn_mgr.clone();
        let config = config.clone();

        tokio_uring::spawn(async move {
            // é›¶æ‹·è´ä»£ç†
            proxy_request_zero_copy(
                client_stream,
                buffer_pool,
                conn_mgr,
                config
            ).await;
        });
    }
}

async fn proxy_request_zero_copy(
    client_stream: TcpStream,
    buffer_pool: Arc<NumaBufferPool>,
    conn_mgr: Arc<LockFreeConnectionPool>,
    config: ProxyConfig,
) {
    // 1. ä»è¿æ¥æ± è·å–åç«¯è¿æ¥ (æ— é”)
    let backend_conn = conn_mgr.acquire().await.unwrap();

    // 2. ä»ç¼“å†²æ± è·å–ç¼“å†²åŒº (NUMAæ„ŸçŸ¥)
    let mut buffer = buffer_pool.acquire().unwrap();

    // 3. è¯»å–å®¢æˆ·ç«¯è¯·æ±‚ (io_uringå¼‚æ­¥)
    let (res, buf) = client_stream.read(buffer).await;
    let Ok(n) = res else { return };
    buffer = buf;

    // 4. è½¬å‘åˆ°åç«¯ (é›¶æ‹·è´)
    let (res, buf) = backend_conn.write(buffer.slice(..n)).await;
    let Ok(_) = res else { return };
    buffer = buf.into_inner();

    // 5. è¯»å–åç«¯å“åº”
    let (res, buf) = backend_conn.read(buffer).await;
    let Ok(n) = res else { return };
    buffer = buf;

    // 6. è¿”å›ç»™å®¢æˆ·ç«¯ (é›¶æ‹·è´)
    let (res, buf) = client_stream.write(buffer.slice(..n)).await;
    buffer = buf.into_inner();

    // 7. å½’è¿˜èµ„æº (æ— é”)
    buffer_pool.release(buffer);
    // backend_conn è‡ªåŠ¨å½’è¿˜ (Drop trait)
}

#[derive(Clone)]
struct ProxyConfig {
    backend_addr: String,
    timeout_ms: u64,
    max_connections: usize,
}
```

**æ€§èƒ½åŸºå‡† (å¯¹æ¯” Nginx)**:

```text
æµ‹è¯•ç¯å¢ƒ: 32æ ¸å¿ƒæœåŠ¡å™¨, 10Gbpsç½‘å¡

Nginx (é»˜è®¤é…ç½®):
- RPS: 180K
- P50å»¶è¿Ÿ: 2.5ms
- P99å»¶è¿Ÿ: 18ms
- CPUä½¿ç”¨: 65%

Pingoraé£æ ¼æ¶æ„ (io_uring + é›¶æ‹·è´ + Per-Core):
- RPS: 850K (æå‡4.72x)
- P50å»¶è¿Ÿ: 0.8ms (é™ä½68%)
- P99å»¶è¿Ÿ: 4.2ms (é™ä½77%)
- CPUä½¿ç”¨: 78%

å…³é”®ä¼˜åŒ–:
âœ… io_uring å‡å°‘ç³»ç»Ÿè°ƒç”¨
âœ… é›¶æ‹·è´å‡å°‘å†…å­˜æ‹·è´
âœ… Per-Core æ¶ˆé™¤é”ç«äº‰
âœ… NUMAæ„ŸçŸ¥ä¼˜åŒ–å†…å­˜è®¿é—®
```

---

## 7. æ€§èƒ½åŸºå‡†æµ‹è¯•

### ç»¼åˆæ€§èƒ½æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash
# é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡å™¨åŸºå‡†æµ‹è¯•å¥—ä»¶

echo "ğŸš€ ç½‘ç»œæœåŠ¡å™¨æ€§èƒ½åŸºå‡†æµ‹è¯•"
echo "========================================"

# 1. ååé‡æµ‹è¯• (wrk)
echo ""
echo "ğŸ“Š 1. ååé‡æµ‹è¯• (30ç§’, 12çº¿ç¨‹, 400è¿æ¥)"
wrk -t12 -c400 -d30s --latency http://localhost:8080/

# 2. é•¿è¿æ¥æµ‹è¯•
echo ""
echo "ğŸ“Š 2. é•¿è¿æ¥æµ‹è¯• (Keep-Alive)"
wrk -t12 -c1000 -d60s --latency -H "Connection: keep-alive" http://localhost:8080/

# 3. æé™å¹¶å‘æµ‹è¯•
echo ""
echo "ğŸ“Š 3. æé™å¹¶å‘æµ‹è¯• (10Kè¿æ¥)"
wrk -t16 -c10000 -d30s --latency http://localhost:8080/

# 4. å°æ–‡ä»¶æ€§èƒ½
echo ""
echo "ğŸ“Š 4. å°æ–‡ä»¶æ€§èƒ½ (1KB)"
wrk -t12 -c400 -d30s http://localhost:8080/test_1kb.dat

# 5. å¤§æ–‡ä»¶æ€§èƒ½
echo ""
echo "ğŸ“Š 5. å¤§æ–‡ä»¶æ€§èƒ½ (10MB)"
wrk -t12 -c100 -d30s http://localhost:8080/test_10mb.dat

# 6. CPUæ€§èƒ½ç›‘æ§
echo ""
echo "ğŸ“Š 6. CPUä½¿ç”¨ç‡"
mpstat -P ALL 5 6

# 7. ç½‘ç»œç»Ÿè®¡
echo ""
echo "ğŸ“Š 7. ç½‘ç»œç»Ÿè®¡"
netstat -s | grep -E "segments|packets"

# 8. ä¸­æ–­åˆ†å¸ƒ
echo ""
echo "ğŸ“Š 8. ç½‘å¡ä¸­æ–­åˆ†å¸ƒ"
cat /proc/interrupts | grep eth0

echo ""
echo "âœ… åŸºå‡†æµ‹è¯•å®Œæˆï¼"
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ¶æ„é€‰æ‹©å†³ç­–æ ‘

```text
é€‰æ‹©é«˜æ€§èƒ½æ¶æ„çš„å†³ç­–æµç¨‹:

å¼€å§‹
  â”‚
  â–¼
æ˜¯å¦éœ€è¦>100K QPS?
  â”‚
  â”œâ”€ å¦ â”€â”€â†’ ä½¿ç”¨æ ‡å‡† Tokio (è¶³å¤Ÿ)
  â”‚
  â””â”€ æ˜¯
      â”‚
      â–¼
  Linuxå†…æ ¸ >= 5.8?
      â”‚
      â”œâ”€ æ˜¯ â”€â”€â†’ ä½¿ç”¨ io_uring âœ…
      â”‚
      â””â”€ å¦ â”€â”€â†’ ä½¿ç”¨ epoll
          â”‚
          â–¼
      æ˜¯å¦æœ‰å¤šæ ¸å¿ƒ (>4)?
          â”‚
          â”œâ”€ æ˜¯ â”€â”€â†’ Per-Core æ¶æ„ âœ…
          â”‚
          â””â”€ å¦ â”€â”€â†’ å•æ ¸ä¼˜åŒ–
              â”‚
              â–¼
          æ˜¯å¦æœ‰NUMA?
              â”‚
              â”œâ”€ æ˜¯ â”€â”€â†’ NUMAæ„ŸçŸ¥ âœ…
              â”‚
              â””â”€ å¦ â”€â”€â†’ æ ‡å‡†æ¶æ„
                  â”‚
                  â–¼
              ç½‘å¡æ”¯æŒå¤šé˜Ÿåˆ—?
                  â”‚
                  â”œâ”€ æ˜¯ â”€â”€â†’ é…ç½®RSS/XPS âœ…
                  â”‚
                  â””â”€ å¦ â”€â”€â†’ ä½¿ç”¨RPS
                      â”‚
                      â–¼
                  éœ€è¦é›¶æ‹·è´?
                      â”‚
                      â”œâ”€ æ˜¯ â”€â”€â†’ sendfile/splice âœ…
                      â”‚
                      â””â”€ å¦ â”€â”€â†’ æ ‡å‡†I/O
                          â”‚
                          â–¼
                      é€‰å®šæ¶æ„ âœ…
```

### 8.2 æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

**å¿…åšä¼˜åŒ–** âœ…:

- [ ] å¯ç”¨ TCP Fast Open (`TCP_FASTOPEN`)
- [ ] è°ƒæ•´ TCP ç¼“å†²åŒºå¤§å° (`net.ipv4.tcp_rmem/wmem`)
- [ ] ç¦ç”¨ Nagle ç®—æ³• (`TCP_NODELAY`)
- [ ] ä½¿ç”¨å¤§é¡µå†…å­˜ (HugePages) å¯¹äº>10GBå†…å­˜
- [ ] ç»‘å®šä¸­æ–­åˆ°ç‰¹å®šCPUæ ¸å¿ƒ
- [ ] è®¾ç½® socket æ¥æ”¶/å‘é€ç¼“å†²åŒº (`SO_RCVBUF`/`SO_SNDBUF`)
- [ ] ä½¿ç”¨ `SO_REUSEPORT` å®ç°å¤šè¿›ç¨‹ç›‘å¬

**é«˜çº§ä¼˜åŒ–** ğŸš€:

- [ ] å®ç°é›¶æ‹·è´ä¼ è¾“ (sendfile/splice)
- [ ] ä½¿ç”¨ io_uring (Linux 5.8+)
- [ ] Per-Core æ¶æ„æ¶ˆé™¤é”ç«äº‰
- [ ] NUMAæ„ŸçŸ¥çš„å†…å­˜åˆ†é…
- [ ] é…ç½®ç½‘å¡å¤šé˜Ÿåˆ— (RSS/RPS/XPS)
- [ ] æ— é”æ•°æ®ç»“æ„ (Lock-Free)
- [ ] CPUäº²å’Œæ€§ç»‘å®š (Core Affinity)

### 8.3 ç³»ç»Ÿè°ƒä¼˜å‚æ•°

```bash
#!/bin/bash
# ç”Ÿäº§ç¯å¢ƒç³»ç»Ÿè°ƒä¼˜è„šæœ¬

# TCP ä¼˜åŒ–
sysctl -w net.ipv4.tcp_tw_reuse=1
sysctl -w net.ipv4.tcp_fin_timeout=30
sysctl -w net.ipv4.tcp_keepalive_time=1200
sysctl -w net.ipv4.tcp_max_syn_backlog=8192
sysctl -w net.core.somaxconn=65535
sysctl -w net.core.netdev_max_backlog=16384

# TCP ç¼“å†²åŒº
sysctl -w net.ipv4.tcp_rmem='4096 87380 16777216'
sysctl -w net.ipv4.tcp_wmem='4096 65536 16777216'
sysctl -w net.core.rmem_max=16777216
sysctl -w net.core.wmem_max=16777216

# è¿æ¥æ•°
sysctl -w net.ipv4.ip_local_port_range='1024 65535'
sysctl -w net.ipv4.tcp_max_tw_buckets=1440000

# æ–‡ä»¶æè¿°ç¬¦
ulimit -n 1048576

# å¯ç”¨ BBR æ‹¥å¡æ§åˆ¶
sysctl -w net.core.default_qdisc=fq
sysctl -w net.ipv4.tcp_congestion_control=bbr

echo "âœ… ç³»ç»Ÿè°ƒä¼˜å®Œæˆï¼"
```

---

## æ€»ç»“

### å…³é”®æŠ€æœ¯å¯¹æ¯”

| æŠ€æœ¯ | æ€§èƒ½æå‡ | å®ç°å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- |
| é›¶æ‹·è´ (sendfile) | 3-4x | ä½ | æ–‡ä»¶ä¼ è¾“ |
| io_uring | 2-3x | ä¸­ | æ‰€æœ‰I/O |
| Per-Coreæ¶æ„ | 3-4x | ä¸­-é«˜ | é«˜å¹¶å‘ |
| NUMAä¼˜åŒ– | 1.5-2x | ä¸­ | å¤§å†…å­˜æœåŠ¡å™¨ |
| å¤šé˜Ÿåˆ—NIC | 3-5x | ä½-ä¸­ | é«˜PPSåœºæ™¯ |
| Lock-Free | 2-4x | é«˜ | é”ç«äº‰ä¸¥é‡ |

### æ¨èç»„åˆ

**å…¥é—¨çº§** (é€‚åˆå¤§éƒ¨åˆ†åœºæ™¯):

- Tokio + TCP_NODELAY + SO_REUSEPORT

**è¿›é˜¶çº§** (éœ€è¦>100K QPS):

- io_uring + é›¶æ‹·è´ + Per-Coreæ¶æ„

**ä¸“å®¶çº§** (éœ€è¦>500K QPS):

- io_uring + é›¶æ‹·è´ + Per-Core + NUMA + å¤šé˜Ÿåˆ— + Lock-Free

---

## å»¶ä¼¸é˜…è¯»

1. **io_uring æ·±åº¦è§£æ**: <https://kernel.dk/io_uring.pdf>
2. **Cloudflare Pingora**: <https://blog.cloudflare.com/pingora-open-source>
3. **DPDK æ–‡æ¡£**: <https://doc.dpdk.org/>
4. **Linuxç½‘ç»œæ ˆä¼˜åŒ–**: <https://www.kernel.org/doc/Documentation/networking/>

---

**ä¸‹ä¸€ç¯‡**: [02_è‡ªå®šä¹‰åè®®å®ç°.md](02_è‡ªå®šä¹‰åè®®å®ç°.md)

**è¿”å›**: [Tier 4 README](README.md)
