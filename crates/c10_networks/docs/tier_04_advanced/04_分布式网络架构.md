# åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„

**ä¸»é¢˜**: æœåŠ¡ç½‘æ ¼ã€è´Ÿè½½å‡è¡¡ã€åˆ†å¸ƒå¼è¿½è¸ª  
**éš¾åº¦**: â­â­â­â­â­  
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 20-24 å°æ—¶

---

## ğŸ“– å†…å®¹æ¦‚è§ˆ

æœ¬æ–‡æ¡£æ¶µç›–åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„çš„æ ¸å¿ƒæŠ€æœ¯ï¼š

1. æœåŠ¡ç½‘æ ¼ (Service Mesh) å®ç°
2. è´Ÿè½½å‡è¡¡ç®—æ³•
3. åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ
4. æ•…éšœæ³¨å…¥ä¸æ··æ²Œå·¥ç¨‹
5. é«˜å¯ç”¨æ¶æ„è®¾è®¡

---

## 1. æœåŠ¡ç½‘æ ¼å®ç°

### 1.1 Sidecar Proxyæ¨¡å¼

```rust
use tokio::net::{TcpListener, TcpStream};
use std::sync::Arc;

/// Sidecarä»£ç†
struct SidecarProxy {
    upstream_addr: String,
    metrics: Arc<NetworkMetrics>,
}

impl SidecarProxy {
    async fn run(&self, listen_addr: &str) -> io::Result<()> {
        let listener = TcpListener::bind(listen_addr).await?;
        println!("ğŸ”„ Sidecarä»£ç†å¯åŠ¨: {}", listen_addr);
        println!("   ä¸Šæ¸¸æœåŠ¡: {}", self.upstream_addr);
        
        loop {
            let (client_stream, client_addr) = listener.accept().await?;
            println!("ğŸ“¥ æ–°è¿æ¥: {}", client_addr);
            
            let upstream_addr = self.upstream_addr.clone();
            let metrics = self.metrics.clone();
            
            tokio::spawn(async move {
                if let Err(e) = Self::proxy_connection(
                    client_stream,
                    &upstream_addr,
                    metrics,
                ).await {
                    eprintln!("âŒ ä»£ç†é”™è¯¯: {}", e);
                }
            });
        }
    }
    
    async fn proxy_connection(
        mut client: TcpStream,
        upstream_addr: &str,
        metrics: Arc<NetworkMetrics>,
    ) -> io::Result<()> {
        // 1. è¿æ¥ä¸Šæ¸¸æœåŠ¡
        let mut upstream = TcpStream::connect(upstream_addr).await?;
        println!("âœ… å·²è¿æ¥ä¸Šæ¸¸: {}", upstream_addr);
        
        // 2. åŒå‘æ•°æ®è½¬å‘
        let (mut client_read, mut client_write) = client.split();
        let (mut upstream_read, mut upstream_write) = upstream.split();
        
        let client_to_upstream = async {
            let mut buffer = [0u8; 8192];
            loop {
                let n = client_read.read(&mut buffer).await?;
                if n == 0 { break; }
                
                upstream_write.write_all(&buffer[..n]).await?;
                metrics.record_sent(n as u64);
            }
            Ok::<_, io::Error>(())
        };
        
        let upstream_to_client = async {
            let mut buffer = [0u8; 8192];
            loop {
                let n = upstream_read.read(&mut buffer).await?;
                if n == 0 { break; }
                
                client_write.write_all(&buffer[..n]).await?;
                metrics.record_received(n as u64);
            }
            Ok::<_, io::Error>(())
        };
        
        // å¹¶å‘æ‰§è¡ŒåŒå‘è½¬å‘
        tokio::try_join!(client_to_upstream, upstream_to_client)?;
        
        println!("âœ… è¿æ¥å…³é—­");
        Ok(())
    }
}

#[tokio::main]
async fn main() -> io::Result<()> {
    let metrics = NetworkMetrics::new();
    let proxy = SidecarProxy {
        upstream_addr: "localhost:8080".to_string(),
        metrics: metrics.clone(),
    };
    
    // å¯åŠ¨ä»£ç†
    tokio::spawn(async move {
        proxy.run("0.0.0.0:7000").await.ok();
    });
    
    // å®šæœŸæŠ¥å‘ŠæŒ‡æ ‡
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(10));
        loop {
            interval.tick().await;
            metrics.report();
        }
    });
    
    tokio::signal::ctrl_c().await?;
    Ok(())
}
```

---

## 2. è´Ÿè½½å‡è¡¡ç®—æ³•

### 2.1 å¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

/// è´Ÿè½½å‡è¡¡å™¨
struct LoadBalancer {
    backends: Vec<String>,
    strategy: BalancingStrategy,
    counter: AtomicUsize,
}

#[derive(Debug, Clone)]
enum BalancingStrategy {
    RoundRobin,
    LeastConnections,
    Random,
    WeightedRoundRobin(Vec<u32>),
}

impl LoadBalancer {
    fn new(backends: Vec<String>, strategy: BalancingStrategy) -> Self {
        Self {
            backends,
            strategy,
            counter: AtomicUsize::new(0),
        }
    }
    
    /// é€‰æ‹©åç«¯æœåŠ¡å™¨
    fn select_backend(&self) -> &str {
        match &self.strategy {
            BalancingStrategy::RoundRobin => {
                let index = self.counter.fetch_add(1, Ordering::Relaxed) 
                    % self.backends.len();
                &self.backends[index]
            }
            BalancingStrategy::Random => {
                use rand::Rng;
                let index = rand::thread_rng().gen_range(0..self.backends.len());
                &self.backends[index]
            }
            BalancingStrategy::WeightedRoundRobin(weights) => {
                // åŠ æƒè½®è¯¢å®ç°
                let total_weight: u32 = weights.iter().sum();
                let mut cumulative = 0u32;
                let target = (self.counter.fetch_add(1, Ordering::Relaxed) as u32) 
                    % total_weight;
                
                for (i, &weight) in weights.iter().enumerate() {
                    cumulative += weight;
                    if target < cumulative {
                        return &self.backends[i];
                    }
                }
                
                &self.backends[0]
            }
            BalancingStrategy::LeastConnections => {
                // ç®€åŒ–ç‰ˆï¼šéšæœºé€‰æ‹©ï¼ˆå®é™…éœ€è¦è¿½è¸ªè¿æ¥æ•°ï¼‰
                let index = rand::thread_rng().gen_range(0..self.backends.len());
                &self.backends[index]
            }
        }
    }
}

/// è´Ÿè½½å‡è¡¡ä»£ç†æœåŠ¡å™¨
async fn run_load_balancer(listen_addr: &str, balancer: Arc<LoadBalancer>) -> io::Result<()> {
    let listener = TcpListener::bind(listen_addr).await?;
    println!("âš–ï¸  è´Ÿè½½å‡è¡¡å™¨å¯åŠ¨: {}", listen_addr);
    println!("   åç«¯: {:?}", balancer.backends);
    println!("   ç­–ç•¥: {:?}", balancer.strategy);
    
    loop {
        let (client_stream, _) = listener.accept().await?;
        let balancer = balancer.clone();
        
        tokio::spawn(async move {
            let backend = balancer.select_backend();
            println!("ğŸ¯ è·¯ç”±åˆ°åç«¯: {}", backend);
            
            if let Err(e) = proxy_to_backend(client_stream, backend).await {
                eprintln!("âŒ ä»£ç†é”™è¯¯: {}", e);
            }
        });
    }
}

async fn proxy_to_backend(mut client: TcpStream, backend: &str) -> io::Result<()> {
    let mut upstream = TcpStream::connect(backend).await?;
    
    tokio::io::copy_bidirectional(&mut client, &mut upstream).await?;
    Ok(())
}
```

### 2.2 å¥åº·æ£€æŸ¥

```rust
use tokio::time::{interval, Duration};

struct HealthChecker {
    backends: Vec<String>,
    healthy: Arc<Mutex<HashSet<String>>>,
}

impl HealthChecker {
    async fn run(&self) {
        let mut check_interval = interval(Duration::from_secs(5));
        
        loop {
            check_interval.tick().await;
            
            for backend in &self.backends {
                let healthy = self.healthy.clone();
                let backend = backend.clone();
                
                tokio::spawn(async move {
                    match TcpStream::connect(&backend).await {
                        Ok(_) => {
                            healthy.lock().await.insert(backend.clone());
                            println!("âœ… å¥åº·: {}", backend);
                        }
                        Err(_) => {
                            healthy.lock().await.remove(&backend);
                            println!("âŒ ä¸å¥åº·: {}", backend);
                        }
                    }
                });
            }
        }
    }
}
```

---

## 3. åˆ†å¸ƒå¼è¿½è¸ª

### 3.1 OpenTelemetryé›†æˆ

```rust
use opentelemetry::{global, trace::{Tracer, Span, SpanKind}, KeyValue};
use opentelemetry_sdk::trace as sdktrace;

/// åˆå§‹åŒ–è¿½è¸ª
fn init_tracer() -> sdktrace::Tracer {
    opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_simple()
        .expect("Failed to install tracer")
}

/// è¿½è¸ªHTTPè¯·æ±‚
async fn handle_request_with_tracing(req: HttpRequest) -> HttpResponse {
    let tracer = global::tracer("http-server");
    
    // åˆ›å»ºSpan
    let mut span = tracer
        .span_builder("handle_request")
        .with_kind(SpanKind::Server)
        .with_attributes(vec![
            KeyValue::new("http.method", req.method.to_string()),
            KeyValue::new("http.url", req.url.clone()),
        ])
        .start(&tracer);
    
    // è®°å½•äº‹ä»¶
    span.add_event("Processing request", vec![]);
    
    // å®é™…å¤„ç†
    let response = process_request(req).await;
    
    // è®°å½•ç»“æœ
    span.set_attribute(KeyValue::new("http.status_code", response.status));
    span.end();
    
    response
}
```

---

## 4. æ•…éšœæ³¨å…¥ä¸æ··æ²Œå·¥ç¨‹

### 4.1 ç½‘ç»œæ•…éšœæ³¨å…¥

```rust
use rand::Rng;

/// æ•…éšœæ³¨å…¥å™¨
struct ChaosInjector {
    latency_ms: Option<u64>,
    packet_loss_rate: f64,
    error_rate: f64,
}

impl ChaosInjector {
    async fn inject_chaos<F, Fut, T>(&self, operation: F) -> io::Result<T>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = io::Result<T>>,
    {
        let mut rng = rand::thread_rng();
        
        // 1. æ³¨å…¥å»¶è¿Ÿ
        if let Some(latency) = self.latency_ms {
            tokio::time::sleep(Duration::from_millis(latency)).await;
            println!("â±ï¸  æ³¨å…¥å»¶è¿Ÿ: {}ms", latency);
        }
        
        // 2. æ¨¡æ‹Ÿä¸¢åŒ…
        if rng.gen::<f64>() < self.packet_loss_rate {
            println!("ğŸ“¦ æ¨¡æ‹Ÿä¸¢åŒ…");
            return Err(io::Error::new(io::ErrorKind::TimedOut, "Packet lost"));
        }
        
        // 3. æ¨¡æ‹Ÿé”™è¯¯
        if rng.gen::<f64>() < self.error_rate {
            println!("âŒ æ¨¡æ‹Ÿé”™è¯¯");
            return Err(io::Error::new(io::ErrorKind::Other, "Injected error"));
        }
        
        // æ­£å¸¸æ‰§è¡Œ
        operation().await
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let injector = ChaosInjector {
        latency_ms: Some(100),
        packet_loss_rate: 0.05,  // 5% ä¸¢åŒ…ç‡
        error_rate: 0.02,         // 2% é”™è¯¯ç‡
    };
    
    for i in 0..10 {
        let result = injector.inject_chaos(|| async {
            // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
            Ok(format!("Response {}", i))
        }).await;
        
        match result {
            Ok(data) => println!("âœ… æˆåŠŸ: {}", data),
            Err(e) => println!("âŒ å¤±è´¥: {}", e),
        }
    }
}
```

---

## 5. é«˜å¯ç”¨æ¶æ„

### 5.1 æ•…éšœè½¬ç§»

```rust
/// å¸¦æ•…éšœè½¬ç§»çš„å®¢æˆ·ç«¯
struct FailoverClient {
    primary: String,
    fallback: Vec<String>,
    max_retries: usize,
}

impl FailoverClient {
    async fn call_with_failover(&self, request: Vec<u8>) -> io::Result<Vec<u8>> {
        // 1. å°è¯•ä¸»èŠ‚ç‚¹
        match self.try_connect(&self.primary, &request).await {
            Ok(response) => return Ok(response),
            Err(e) => println!("âš ï¸  ä¸»èŠ‚ç‚¹å¤±è´¥: {}", e),
        }
        
        // 2. æ•…éšœè½¬ç§»åˆ°å¤‡ç”¨èŠ‚ç‚¹
        for (i, fallback) in self.fallback.iter().enumerate() {
            println!("ğŸ”„ æ•…éšœè½¬ç§»åˆ°å¤‡ç”¨èŠ‚ç‚¹ {}: {}", i + 1, fallback);
            
            match self.try_connect(fallback, &request).await {
                Ok(response) => return Ok(response),
                Err(e) => println!("âš ï¸  å¤‡ç”¨èŠ‚ç‚¹ {} å¤±è´¥: {}", i + 1, e),
            }
        }
        
        Err(io::Error::new(io::ErrorKind::Other, "All nodes failed"))
    }
    
    async fn try_connect(&self, addr: &str, request: &[u8]) -> io::Result<Vec<u8>> {
        let mut stream = TcpStream::connect(addr).await?;
        stream.write_all(request).await?;
        
        let mut response = Vec::new();
        stream.read_to_end(&mut response).await?;
        
        Ok(response)
    }
}
```

---

## æ€»ç»“

åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„çš„æ ¸å¿ƒè¦ç´ ï¼š

1. **æœåŠ¡ç½‘æ ¼**: Sidecarä»£ç† + æµé‡ç®¡ç†
2. **è´Ÿè½½å‡è¡¡**: å¤šç§ç­–ç•¥ + å¥åº·æ£€æŸ¥
3. **å¯è§‚æµ‹æ€§**: åˆ†å¸ƒå¼è¿½è¸ª + æŒ‡æ ‡æ”¶é›†
4. **éŸ§æ€§**: æ•…éšœè½¬ç§» + æ··æ²Œå·¥ç¨‹

---

**ä¸‹ä¸€ç¯‡**: [05_ç½‘ç»œç¼–ç¨‹å‰æ²¿æŠ€æœ¯.md](05_ç½‘ç»œç¼–ç¨‹å‰æ²¿æŠ€æœ¯.md)

**è¿”å›**: [Tier 4 README](README.md)
