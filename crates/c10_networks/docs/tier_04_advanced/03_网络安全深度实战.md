# ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜

**ä¸»é¢˜**: TLS 1.3ã€é›¶ä¿¡ä»»æ¶æ„ã€DDoSé˜²æŠ¤
**éš¾åº¦**: â­â­â­â­â­
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 16-20 å°æ—¶

---

## ğŸ“– ç›®å½•

- [ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜](#ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
  - [ğŸ“– å†…å®¹æ¦‚è§ˆ](#-å†…å®¹æ¦‚è§ˆ)
  - [1. TLS 1.3 æ·±åº¦å®ç°](#1-tls-13-æ·±åº¦å®ç°)
    - [1.1 TLS 1.3 æ¡æ‰‹æµç¨‹](#11-tls-13-æ¡æ‰‹æµç¨‹)
    - [1.2 å®Œæ•´çš„HTTPSæœåŠ¡å™¨](#12-å®Œæ•´çš„httpsæœåŠ¡å™¨)
  - [2. é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„](#2-é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„)
    - [2.1 mTLS (åŒå‘TLSè®¤è¯)](#21-mtls-åŒå‘tlsè®¤è¯)
  - [3. DDoS é˜²æŠ¤ç­–ç•¥](#3-ddos-é˜²æŠ¤ç­–ç•¥)
    - [3.1 è¿æ¥é€Ÿç‡é™åˆ¶](#31-è¿æ¥é€Ÿç‡é™åˆ¶)
    - [3.2 SYN Flood é˜²æŠ¤](#32-syn-flood-é˜²æŠ¤)
  - [4. ç½‘ç»œæµé‡åˆ†æ](#4-ç½‘ç»œæµé‡åˆ†æ)
    - [4.1 å®æ—¶æµé‡ç›‘æ§](#41-å®æ—¶æµé‡ç›‘æ§)
  - [5. å®‰å…¨æœ€ä½³å®è·µ](#5-å®‰å…¨æœ€ä½³å®è·µ)
    - [5.1 å®‰å…¨æ£€æŸ¥æ¸…å•](#51-å®‰å…¨æ£€æŸ¥æ¸…å•)
  - [æ€»ç»“](#æ€»ç»“)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜ (Network Security Deep Practice)**:

- **å®šä¹‰**: Rust 1.92.0 ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜ï¼ŒåŒ…æ‹¬ TLS 1.3 å®Œæ•´å®ç°ã€é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„ã€DDoS é˜²æŠ¤ç­–ç•¥ã€ç½‘ç»œæµé‡åˆ†æã€å®‰å…¨åè®®æœ€ä½³å®è·µç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: ç½‘ç»œç¼–ç¨‹ã€å®‰å…¨
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: TLS 1.3ã€é›¶ä¿¡ä»»ã€DDoS é˜²æŠ¤ã€ç½‘ç»œæµé‡åˆ†æã€å®‰å…¨åè®®

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **TLS 1.3 å®Œæ•´å®ç°**: TLS 1.3 æ¡æ‰‹æµç¨‹ã€TLS 1.3 é…ç½®
- **é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„**: é›¶ä¿¡ä»»åŸåˆ™ã€é›¶ä¿¡ä»»å®ç°
- **DDoS é˜²æŠ¤ç­–ç•¥**: DDoS æ”»å‡»ç±»å‹ã€é˜²æŠ¤ç­–ç•¥
- **ç½‘ç»œæµé‡åˆ†æ**: æµé‡ç›‘æ§ã€æµé‡åˆ†æ
- **å®‰å…¨åè®®æœ€ä½³å®è·µ**: å®‰å…¨é…ç½®ã€å®‰å…¨å®è·µ

**Rust 1.92.0 æ–°ç‰¹æ€§**:

- **æ”¹è¿›çš„ TLS**: æ›´å¥½çš„ TLS 1.3 æ”¯æŒ
- **å¢å¼ºçš„å®‰å…¨**: æ›´å¥½çš„å®‰å…¨æœºåˆ¶æ”¯æŒ
- **ä¼˜åŒ–çš„æ€§èƒ½**: æ›´é«˜æ•ˆçš„å®‰å…¨æ€§èƒ½

**æ€§èƒ½ç‰¹å¾**:

- **å®‰å…¨æ€§**: å¼ºå¤§çš„å®‰å…¨ä¿è¯
- **é«˜æ€§èƒ½**: é«˜æ•ˆçš„å®‰å…¨æ€§èƒ½
- **é€‚ç”¨åœºæ™¯**: å®‰å…¨å…³é”®ç³»ç»Ÿã€ç”Ÿäº§ç¯å¢ƒã€ä¼ä¸šåº”ç”¨

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜ --[covers]--> ç½‘ç»œå®‰å…¨å®Œæ•´å†…å®¹
- å®‰å…¨ç½‘ç»œåº”ç”¨ --[uses]--> ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜

**ä¾èµ–å…³ç³»**:

- ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜ --[depends-on]--> ç½‘ç»œç¼–ç¨‹
- å®‰å…¨ç³»ç»Ÿ --[depends-on]--> ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜

### æ€ç»´å¯¼å›¾

```text
ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜
â”‚
â”œâ”€â”€ TLS 1.3 å®Œæ•´å®ç°
â”‚   â”œâ”€â”€ TLS 1.3 æ¡æ‰‹æµç¨‹
â”‚   â””â”€â”€ TLS 1.3 é…ç½®
â”œâ”€â”€ é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„
â”‚   â”œâ”€â”€ é›¶ä¿¡ä»»åŸåˆ™
â”‚   â””â”€â”€ é›¶ä¿¡ä»»å®ç°
â”œâ”€â”€ DDoS é˜²æŠ¤ç­–ç•¥
â”‚   â”œâ”€â”€ DDoS æ”»å‡»ç±»å‹
â”‚   â””â”€â”€ é˜²æŠ¤ç­–ç•¥
â”œâ”€â”€ ç½‘ç»œæµé‡åˆ†æ
â”‚   â”œâ”€â”€ æµé‡ç›‘æ§
â”‚   â””â”€â”€ æµé‡åˆ†æ
â””â”€â”€ å®‰å…¨åè®®æœ€ä½³å®è·µ
    â”œâ”€â”€ å®‰å…¨é…ç½®
    â””â”€â”€ å®‰å…¨å®è·µ
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| å®‰å…¨æŠ€æœ¯      | å®‰å…¨æ€§ | æ€§èƒ½ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯  | Rust 1.92.0 |
| :--- | :--- | :--- | :--- | :--- | :--- || **TLS 1.3**   | æœ€é«˜   | é«˜   | ä¸­     | å®‰å…¨é€šä¿¡  | âœ…          |
| **é›¶ä¿¡ä»»**    | æœ€é«˜   | ä¸­   | é«˜     | å®‰å…¨æ¶æ„  | âœ…          |
| **DDoS é˜²æŠ¤** | é«˜     | ä¸­   | ä¸­     | DDoS é˜²æŠ¤ | âœ…          |
| **æµé‡åˆ†æ**  | ä¸­     | ä¸­   | ä¸­     | æµé‡ç›‘æ§  | âœ…          |
| **å®‰å…¨åè®®**  | é«˜     | ä¸­   | ä¸­     | å®‰å…¨é€šä¿¡  | âœ…          |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©å®‰å…¨æŠ€æœ¯
â”‚
â”œâ”€â”€ éœ€è¦ä»€ä¹ˆå®‰å…¨çº§åˆ«ï¼Ÿ
â”‚   â”œâ”€â”€ å®‰å…¨é€šä¿¡ â†’ TLS 1.3
â”‚   â”œâ”€â”€ å®‰å…¨æ¶æ„ â†’ é›¶ä¿¡ä»»
â”‚   â”œâ”€â”€ DDoS é˜²æŠ¤ â†’ DDoS é˜²æŠ¤ç­–ç•¥
â”‚   â”œâ”€â”€ æµé‡ç›‘æ§ â†’ ç½‘ç»œæµé‡åˆ†æ
â”‚   â””â”€â”€ å®‰å…¨å®è·µ â†’ å®‰å…¨åè®®æœ€ä½³å®è·µ
```

---

## ğŸ“– å†…å®¹æ¦‚è§ˆ

æœ¬æ–‡æ¡£æ¶µç›–ç½‘ç»œå®‰å…¨çš„æ·±åº¦å®æˆ˜ï¼ŒåŒ…æ‹¬ï¼š

1. TLS 1.3 å®Œæ•´å®ç°
2. é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„
3. DDoS é˜²æŠ¤ç­–ç•¥
4. ç½‘ç»œæµé‡åˆ†æ
5. å®‰å…¨åè®®æœ€ä½³å®è·µ

---

## 1. TLS 1.3 æ·±åº¦å®ç°

### 1.1 TLS 1.3 æ¡æ‰‹æµç¨‹

```rust
use rustls::{ClientConfig, ServerConfig, RootCertStore};
use tokio_rustls::{TlsConnector, TlsAcceptor};

/// TLS 1.3 å®¢æˆ·ç«¯é…ç½®
fn create_tls_client() -> ClientConfig {
    let mut root_store = RootCertStore::empty();
    root_store.add_trust_anchors(
        webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
            rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
                ta.subject,
                ta.spki,
                ta.name_constraints,
            )
        })
    );

    ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth()
}

/// TLS 1.3 æœåŠ¡å™¨é…ç½®
fn create_tls_server(cert_path: &str, key_path: &str) -> io::Result<ServerConfig> {
    let certs = load_certs(cert_path)?;
    let key = load_private_key(key_path)?;

    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;

    Ok(config)
}
```

### 1.2 å®Œæ•´çš„HTTPSæœåŠ¡å™¨

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio_rustls::TlsAcceptor;

#[tokio::main]
async fn main() -> io::Result<()> {
    // 1. åˆ›å»ºTLSé…ç½®
    let tls_config = create_tls_server("cert.pem", "key.pem")?;
    let tls_acceptor = TlsAcceptor::from(Arc::new(tls_config));

    // 2. ç›‘å¬ç«¯å£
    let listener = TcpListener::bind("0.0.0.0:8443").await?;
    println!("ğŸ”’ HTTPSæœåŠ¡å™¨å¯åŠ¨: https://0.0.0.0:8443");

    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = tls_acceptor.clone();

        tokio::spawn(async move {
            match acceptor.accept(stream).await {
                Ok(tls_stream) => {
                    println!("âœ… TLSè¿æ¥å»ºç«‹: {}", peer_addr);
                    handle_https_request(tls_stream).await;
                }
                Err(e) => {
                    eprintln!("âŒ TLSæ¡æ‰‹å¤±è´¥: {}", e);
                }
            }
        });
    }
}

async fn handle_https_request<S>(mut stream: tokio_rustls::server::TlsStream<S>)
where
    S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin,
{
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    let mut buffer = [0u8; 4096];
    match stream.read(&mut buffer).await {
        Ok(n) => {
            let request = String::from_utf8_lossy(&buffer[..n]);
            println!("ğŸ“¨ æ”¶åˆ°HTTPSè¯·æ±‚:\n{}", request);

            let response = "HTTP/1.1 200 OK\r\n\
                          Content-Type: text/html\r\n\
                          Content-Length: 27\r\n\
                          \r\n\
                          <h1>Secure Connection!</h1>";

            stream.write_all(response.as_bytes()).await.ok();
        }
        Err(e) => eprintln!("âŒ è¯»å–é”™è¯¯: {}", e),
    }
}
```

---

## 2. é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„

### 2.1 mTLS (åŒå‘TLSè®¤è¯)

```rust
/// åŒå‘TLSè®¤è¯é…ç½®
fn create_mtls_server(
    cert_path: &str,
    key_path: &str,
    client_ca_path: &str,
) -> io::Result<ServerConfig> {
    use rustls::server::AllowAnyAuthenticatedClient;

    let certs = load_certs(cert_path)?;
    let key = load_private_key(key_path)?;

    // åŠ è½½å®¢æˆ·ç«¯CAè¯ä¹¦
    let mut client_auth_roots = RootCertStore::empty();
    let client_ca_certs = load_certs(client_ca_path)?;
    for cert in client_ca_certs {
        client_auth_roots.add(&cert).ok();
    }

    let client_auth = AllowAnyAuthenticatedClient::new(client_auth_roots);

    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_client_cert_verifier(Arc::new(client_auth))
        .with_single_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;

    Ok(config)
}

/// å®¢æˆ·ç«¯mTLSé…ç½®
fn create_mtls_client(
    client_cert_path: &str,
    client_key_path: &str,
    server_ca_path: &str,
) -> io::Result<ClientConfig> {
    let certs = load_certs(client_cert_path)?;
    let key = load_private_key(client_key_path)?;

    let mut root_store = RootCertStore::empty();
    let server_ca_certs = load_certs(server_ca_path)?;
    for cert in server_ca_certs {
        root_store.add(&cert).ok();
    }

    let config = ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_client_auth_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;

    Ok(config)
}
```

---

## 3. DDoS é˜²æŠ¤ç­–ç•¥

### 3.1 è¿æ¥é€Ÿç‡é™åˆ¶

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::sync::Arc;
use tokio::sync::Mutex;
use std::time::{Duration, Instant};

/// è¿æ¥é€Ÿç‡é™åˆ¶å™¨
struct RateLimiter {
    // IP -> (è¿æ¥è®¡æ•°, æœ€åé‡ç½®æ—¶é—´)
    connections: Arc<Mutex<HashMap<IpAddr, (usize, Instant)>>>,
    max_connections_per_second: usize,
    window: Duration,
}

impl RateLimiter {
    fn new(max_per_second: usize) -> Self {
        Self {
            connections: Arc::new(Mutex::new(HashMap::new())),
            max_connections_per_second: max_per_second,
            window: Duration::from_secs(1),
        }
    }

    async fn check_rate_limit(&self, ip: IpAddr) -> bool {
        let mut connections = self.connections.lock().await;
        let now = Instant::now();

        let (count, last_reset) = connections
            .entry(ip)
            .or_insert((0, now));

        // é‡ç½®çª—å£
        if now.duration_since(*last_reset) >= self.window {
            *count = 0;
            *last_reset = now;
        }

        *count += 1;

        if *count > self.max_connections_per_second {
            println!("âš ï¸  é€Ÿç‡é™åˆ¶: {} ({} è¿æ¥/ç§’)", ip, *count);
            false
        } else {
            true
        }
    }
}

/// ä½¿ç”¨é€Ÿç‡é™åˆ¶çš„æœåŠ¡å™¨
#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;
    let rate_limiter = Arc::new(RateLimiter::new(10)); // æ¯ç§’æœ€å¤š10ä¸ªè¿æ¥

    println!("ğŸ›¡ï¸  å¯åŠ¨DDoSé˜²æŠ¤æœåŠ¡å™¨ (é€Ÿç‡é™åˆ¶: 10è¿æ¥/ç§’)");

    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let limiter = rate_limiter.clone();

        tokio::spawn(async move {
            let ip = peer_addr.ip();

            if !limiter.check_rate_limit(ip).await {
                println!("ğŸš« æ‹’ç»è¿æ¥: {} (è¶…è¿‡é€Ÿç‡é™åˆ¶)", ip);
                return;
            }

            println!("âœ… æ¥å—è¿æ¥: {}", peer_addr);
            handle_connection(stream).await;
        });
    }
}
```

### 3.2 SYN Flood é˜²æŠ¤

```bash
#!/bin/bash
# Linuxå†…æ ¸çº§SYN Floodé˜²æŠ¤

# 1. å¯ç”¨SYN Cookies
sysctl -w net.ipv4.tcp_syncookies=1

# 2. å¢åŠ SYNé˜Ÿåˆ—å¤§å°
sysctl -w net.ipv4.tcp_max_syn_backlog=8192

# 3. å‡å°‘SYN-ACKé‡è¯•æ¬¡æ•°
sysctl -w net.ipv4.tcp_synack_retries=2

# 4. å‡å°‘SYNè¶…æ—¶æ—¶é—´
sysctl -w net.ipv4.tcp_syn_retries=3

echo "âœ… SYN Flood é˜²æŠ¤å·²å¯ç”¨"
```

---

## 4. ç½‘ç»œæµé‡åˆ†æ

### 4.1 å®æ—¶æµé‡ç›‘æ§

```rust
use std::sync::atomic::{AtomicU64, Ordering};

struct NetworkMetrics {
    bytes_sent: AtomicU64,
    bytes_received: AtomicU64,
    packets_sent: AtomicU64,
    packets_received: AtomicU64,
}

impl NetworkMetrics {
    fn new() -> Arc<Self> {
        Arc::new(Self {
            bytes_sent: AtomicU64::new(0),
            bytes_received: AtomicU64::new(0),
            packets_sent: AtomicU64::new(0),
            packets_received: AtomicU64::new(0),
        })
    }

    fn record_sent(&self, bytes: u64) {
        self.bytes_sent.fetch_add(bytes, Ordering::Relaxed);
        self.packets_sent.fetch_add(1, Ordering::Relaxed);
    }

    fn record_received(&self, bytes: u64) {
        self.bytes_received.fetch_add(bytes, Ordering::Relaxed);
        self.packets_received.fetch_add(1, Ordering::Relaxed);
    }

    fn report(&self) {
        let sent = self.bytes_sent.load(Ordering::Relaxed);
        let received = self.bytes_received.load(Ordering::Relaxed);
        let pkt_sent = self.packets_sent.load(Ordering::Relaxed);
        let pkt_received = self.packets_received.load(Ordering::Relaxed);

        println!("ğŸ“Š ç½‘ç»œæµé‡ç»Ÿè®¡:");
        println!("   å‘é€: {} MB ({} æ•°æ®åŒ…)", sent / 1_000_000, pkt_sent);
        println!("   æ¥æ”¶: {} MB ({} æ•°æ®åŒ…)", received / 1_000_000, pkt_received);
        println!("   æ€»è®¡: {} MB", (sent + received) / 1_000_000);
    }
}
```

---

## 5. å®‰å…¨æœ€ä½³å®è·µ

### 5.1 å®‰å…¨æ£€æŸ¥æ¸…å•

**åè®®å®‰å…¨** âœ…:

- [ ] ä½¿ç”¨TLS 1.3æˆ–æ›´é«˜ç‰ˆæœ¬
- [ ] ç¦ç”¨å¼±å¯†ç å¥—ä»¶
- [ ] å¯ç”¨å®Œç¾å‰å‘ä¿å¯† (PFS)
- [ ] å®æ–½è¯ä¹¦é’‰æ‰ (Certificate Pinning)
- [ ] ä½¿ç”¨HSTSå¼ºåˆ¶HTTPS

**è¾“å…¥éªŒè¯** âœ…:

- [ ] éªŒè¯æ‰€æœ‰å¤–éƒ¨è¾“å…¥
- [ ] é™åˆ¶è¯·æ±‚å¤§å°
- [ ] é˜²æ­¢ç¼“å†²åŒºæº¢å‡º
- [ ] æ£€æŸ¥åè®®æ ¼å¼

**è®¿é—®æ§åˆ¶** âœ…:

- [ ] å®æ–½æœ€å°æƒé™åŸåˆ™
- [ ] ä½¿ç”¨mTLSè¿›è¡ŒåŒå‘è®¤è¯
- [ ] å®æ–½é›¶ä¿¡ä»»æ¶æ„
- [ ] å®šæœŸå®¡è®¡è®¿é—®æ—¥å¿—

**DDoSé˜²æŠ¤** âœ…:

- [ ] å®æ–½é€Ÿç‡é™åˆ¶
- [ ] å¯ç”¨SYN Cookies
- [ ] ä½¿ç”¨CDN/DDoSé˜²æŠ¤æœåŠ¡
- [ ] ç›‘æ§å¼‚å¸¸æµé‡

---

## æ€»ç»“

ç½‘ç»œå®‰å…¨æ˜¯å¤šå±‚é˜²å¾¡çš„ç»¼åˆç­–ç•¥ï¼š

1. **ä¼ è¾“å±‚å®‰å…¨**: TLS 1.3 + mTLS
2. **åº”ç”¨å±‚é˜²æŠ¤**: é€Ÿç‡é™åˆ¶ + è¾“å…¥éªŒè¯
3. **ç›‘æ§ä¸å“åº”**: å®æ—¶æµé‡åˆ†æ + å¼‚å¸¸æ£€æµ‹

---

**ä¸‹ä¸€ç¯‡**: [04\_åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„.md](04_åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„.md)

**è¿”å›**: [Tier 4 README](README.md)
