# 网络安全深度实战

**主题**: TLS 1.3、零信任架构、DDoS防护  
**难度**: ⭐⭐⭐⭐⭐  
**预计学习时间**: 16-20 小时

---

## 📖 内容概览

本文档涵盖网络安全的深度实战，包括：

1. TLS 1.3 完整实现
2. 零信任网络架构
3. DDoS 防护策略
4. 网络流量分析
5. 安全协议最佳实践

---

## 1. TLS 1.3 深度实现

### 1.1 TLS 1.3 握手流程

```rust
use rustls::{ClientConfig, ServerConfig, RootCertStore};
use tokio_rustls::{TlsConnector, TlsAcceptor};

/// TLS 1.3 客户端配置
fn create_tls_client() -> ClientConfig {
    let mut root_store = RootCertStore::empty();
    root_store.add_trust_anchors(
        webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
            rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
                ta.subject,
                ta.spki,
                ta.name_constraints,
            )
        })
    );
    
    ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth()
}

/// TLS 1.3 服务器配置
fn create_tls_server(cert_path: &str, key_path: &str) -> io::Result<ServerConfig> {
    let certs = load_certs(cert_path)?;
    let key = load_private_key(key_path)?;
    
    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
    
    Ok(config)
}
```

### 1.2 完整的HTTPS服务器

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio_rustls::TlsAcceptor;

#[tokio::main]
async fn main() -> io::Result<()> {
    // 1. 创建TLS配置
    let tls_config = create_tls_server("cert.pem", "key.pem")?;
    let tls_acceptor = TlsAcceptor::from(Arc::new(tls_config));
    
    // 2. 监听端口
    let listener = TcpListener::bind("0.0.0.0:8443").await?;
    println!("🔒 HTTPS服务器启动: https://0.0.0.0:8443");
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = tls_acceptor.clone();
        
        tokio::spawn(async move {
            match acceptor.accept(stream).await {
                Ok(tls_stream) => {
                    println!("✅ TLS连接建立: {}", peer_addr);
                    handle_https_request(tls_stream).await;
                }
                Err(e) => {
                    eprintln!("❌ TLS握手失败: {}", e);
                }
            }
        });
    }
}

async fn handle_https_request<S>(mut stream: tokio_rustls::server::TlsStream<S>) 
where
    S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin,
{
    use tokio::io::{AsyncReadExt, AsyncWriteExt};
    
    let mut buffer = [0u8; 4096];
    match stream.read(&mut buffer).await {
        Ok(n) => {
            let request = String::from_utf8_lossy(&buffer[..n]);
            println!("📨 收到HTTPS请求:\n{}", request);
            
            let response = "HTTP/1.1 200 OK\r\n\
                          Content-Type: text/html\r\n\
                          Content-Length: 27\r\n\
                          \r\n\
                          <h1>Secure Connection!</h1>";
            
            stream.write_all(response.as_bytes()).await.ok();
        }
        Err(e) => eprintln!("❌ 读取错误: {}", e),
    }
}
```

---

## 2. 零信任网络架构

### 2.1 mTLS (双向TLS认证)

```rust
/// 双向TLS认证配置
fn create_mtls_server(
    cert_path: &str,
    key_path: &str,
    client_ca_path: &str,
) -> io::Result<ServerConfig> {
    use rustls::server::AllowAnyAuthenticatedClient;
    
    let certs = load_certs(cert_path)?;
    let key = load_private_key(key_path)?;
    
    // 加载客户端CA证书
    let mut client_auth_roots = RootCertStore::empty();
    let client_ca_certs = load_certs(client_ca_path)?;
    for cert in client_ca_certs {
        client_auth_roots.add(&cert).ok();
    }
    
    let client_auth = AllowAnyAuthenticatedClient::new(client_auth_roots);
    
    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_client_cert_verifier(Arc::new(client_auth))
        .with_single_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
    
    Ok(config)
}

/// 客户端mTLS配置
fn create_mtls_client(
    client_cert_path: &str,
    client_key_path: &str,
    server_ca_path: &str,
) -> io::Result<ClientConfig> {
    let certs = load_certs(client_cert_path)?;
    let key = load_private_key(client_key_path)?;
    
    let mut root_store = RootCertStore::empty();
    let server_ca_certs = load_certs(server_ca_path)?;
    for cert in server_ca_certs {
        root_store.add(&cert).ok();
    }
    
    let config = ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_client_auth_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
    
    Ok(config)
}
```

---

## 3. DDoS 防护策略

### 3.1 连接速率限制

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::sync::Arc;
use tokio::sync::Mutex;
use std::time::{Duration, Instant};

/// 连接速率限制器
struct RateLimiter {
    // IP -> (连接计数, 最后重置时间)
    connections: Arc<Mutex<HashMap<IpAddr, (usize, Instant)>>>,
    max_connections_per_second: usize,
    window: Duration,
}

impl RateLimiter {
    fn new(max_per_second: usize) -> Self {
        Self {
            connections: Arc::new(Mutex::new(HashMap::new())),
            max_connections_per_second: max_per_second,
            window: Duration::from_secs(1),
        }
    }
    
    async fn check_rate_limit(&self, ip: IpAddr) -> bool {
        let mut connections = self.connections.lock().await;
        let now = Instant::now();
        
        let (count, last_reset) = connections
            .entry(ip)
            .or_insert((0, now));
        
        // 重置窗口
        if now.duration_since(*last_reset) >= self.window {
            *count = 0;
            *last_reset = now;
        }
        
        *count += 1;
        
        if *count > self.max_connections_per_second {
            println!("⚠️  速率限制: {} ({} 连接/秒)", ip, *count);
            false
        } else {
            true
        }
    }
}

/// 使用速率限制的服务器
#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;
    let rate_limiter = Arc::new(RateLimiter::new(10)); // 每秒最多10个连接
    
    println!("🛡️  启动DDoS防护服务器 (速率限制: 10连接/秒)");
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let limiter = rate_limiter.clone();
        
        tokio::spawn(async move {
            let ip = peer_addr.ip();
            
            if !limiter.check_rate_limit(ip).await {
                println!("🚫 拒绝连接: {} (超过速率限制)", ip);
                return;
            }
            
            println!("✅ 接受连接: {}", peer_addr);
            handle_connection(stream).await;
        });
    }
}
```

### 3.2 SYN Flood 防护

```bash
#!/bin/bash
# Linux内核级SYN Flood防护

# 1. 启用SYN Cookies
sysctl -w net.ipv4.tcp_syncookies=1

# 2. 增加SYN队列大小
sysctl -w net.ipv4.tcp_max_syn_backlog=8192

# 3. 减少SYN-ACK重试次数
sysctl -w net.ipv4.tcp_synack_retries=2

# 4. 减少SYN超时时间
sysctl -w net.ipv4.tcp_syn_retries=3

echo "✅ SYN Flood 防护已启用"
```

---

## 4. 网络流量分析

### 4.1 实时流量监控

```rust
use std::sync::atomic::{AtomicU64, Ordering};

struct NetworkMetrics {
    bytes_sent: AtomicU64,
    bytes_received: AtomicU64,
    packets_sent: AtomicU64,
    packets_received: AtomicU64,
}

impl NetworkMetrics {
    fn new() -> Arc<Self> {
        Arc::new(Self {
            bytes_sent: AtomicU64::new(0),
            bytes_received: AtomicU64::new(0),
            packets_sent: AtomicU64::new(0),
            packets_received: AtomicU64::new(0),
        })
    }
    
    fn record_sent(&self, bytes: u64) {
        self.bytes_sent.fetch_add(bytes, Ordering::Relaxed);
        self.packets_sent.fetch_add(1, Ordering::Relaxed);
    }
    
    fn record_received(&self, bytes: u64) {
        self.bytes_received.fetch_add(bytes, Ordering::Relaxed);
        self.packets_received.fetch_add(1, Ordering::Relaxed);
    }
    
    fn report(&self) {
        let sent = self.bytes_sent.load(Ordering::Relaxed);
        let received = self.bytes_received.load(Ordering::Relaxed);
        let pkt_sent = self.packets_sent.load(Ordering::Relaxed);
        let pkt_received = self.packets_received.load(Ordering::Relaxed);
        
        println!("📊 网络流量统计:");
        println!("   发送: {} MB ({} 数据包)", sent / 1_000_000, pkt_sent);
        println!("   接收: {} MB ({} 数据包)", received / 1_000_000, pkt_received);
        println!("   总计: {} MB", (sent + received) / 1_000_000);
    }
}
```

---

## 5. 安全最佳实践

### 5.1 安全检查清单

**协议安全** ✅:

- [ ] 使用TLS 1.3或更高版本
- [ ] 禁用弱密码套件
- [ ] 启用完美前向保密 (PFS)
- [ ] 实施证书钉扎 (Certificate Pinning)
- [ ] 使用HSTS强制HTTPS

**输入验证** ✅:

- [ ] 验证所有外部输入
- [ ] 限制请求大小
- [ ] 防止缓冲区溢出
- [ ] 检查协议格式

**访问控制** ✅:

- [ ] 实施最小权限原则
- [ ] 使用mTLS进行双向认证
- [ ] 实施零信任架构
- [ ] 定期审计访问日志

**DDoS防护** ✅:

- [ ] 实施速率限制
- [ ] 启用SYN Cookies
- [ ] 使用CDN/DDoS防护服务
- [ ] 监控异常流量

---

## 总结

网络安全是多层防御的综合策略：

1. **传输层安全**: TLS 1.3 + mTLS
2. **应用层防护**: 速率限制 + 输入验证
3. **监控与响应**: 实时流量分析 + 异常检测

---

**下一篇**: [04_分布式网络架构.md](04_分布式网络架构.md)

**返回**: [Tier 4 README](README.md)
