# ç½‘ç»œå®‰å…¨æ·±åº¦å®æˆ˜

**ä¸»é¢˜**: TLS 1.3ã€é›¶ä¿¡ä»»æ¶æ„ã€DDoSé˜²æŠ¤  
**éš¾åº¦**: â­â­â­â­â­  
**é¢„è®¡å­¦ä¹ æ—¶é—´**: 16-20 å°æ—¶

---

## ğŸ“– å†…å®¹æ¦‚è§ˆ

æœ¬æ–‡æ¡£æ¶µç›–ç½‘ç»œå®‰å…¨çš„æ·±åº¦å®æˆ˜ï¼ŒåŒ…æ‹¬ï¼š

1. TLS 1.3 å®Œæ•´å®ç°
2. é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„
3. DDoS é˜²æŠ¤ç­–ç•¥
4. ç½‘ç»œæµé‡åˆ†æ
5. å®‰å…¨åè®®æœ€ä½³å®è·µ

---

## 1. TLS 1.3 æ·±åº¦å®ç°

### 1.1 TLS 1.3 æ¡æ‰‹æµç¨‹

```rust
use rustls::{ClientConfig, ServerConfig, RootCertStore};
use tokio_rustls::{TlsConnector, TlsAcceptor};

/// TLS 1.3 å®¢æˆ·ç«¯é…ç½®
fn create_tls_client() -> ClientConfig {
    let mut root_store = RootCertStore::empty();
    root_store.add_trust_anchors(
        webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
            rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
                ta.subject,
                ta.spki,
                ta.name_constraints,
            )
        })
    );
    
    ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth()
}

/// TLS 1.3 æœåŠ¡å™¨é…ç½®
fn create_tls_server(cert_path: &str, key_path: &str) -> io::Result<ServerConfig> {
    let certs = load_certs(cert_path)?;
    let key = load_private_key(key_path)?;
    
    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
    
    Ok(config)
}
```

### 1.2 å®Œæ•´çš„HTTPSæœåŠ¡å™¨

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio_rustls::TlsAcceptor;

#[tokio::main]
async fn main() -> io::Result<()> {
    // 1. åˆ›å»ºTLSé…ç½®
    let tls_config = create_tls_server("cert.pem", "key.pem")?;
    let tls_acceptor = TlsAcceptor::from(Arc::new(tls_config));
    
    // 2. ç›‘å¬ç«¯å£
    let listener = TcpListener::bind("0.0.0.0:8443").await?;
    println!("ğŸ”’ HTTPSæœåŠ¡å™¨å¯åŠ¨: https://0.0.0.0:8443");
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = tls_acceptor.clone();
        
        tokio::spawn(async move {
            match acceptor.accept(stream).await {
                Ok(tls_stream) => {
                    println!("âœ… TLSè¿æ¥å»ºç«‹: {}", peer_addr);
                    handle_https_request(tls_stream).await;
                }
                Err(e) => {
                    eprintln!("âŒ TLSæ¡æ‰‹å¤±è´¥: {}", e);
                }
            }
        });
    }
}

async fn handle_https_request<S>(mut stream: tokio_rustls::server::TlsStream<S>) 
where
    S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin,
{
    use tokio::io::{AsyncReadExt, AsyncWriteExt};
    
    let mut buffer = [0u8; 4096];
    match stream.read(&mut buffer).await {
        Ok(n) => {
            let request = String::from_utf8_lossy(&buffer[..n]);
            println!("ğŸ“¨ æ”¶åˆ°HTTPSè¯·æ±‚:\n{}", request);
            
            let response = "HTTP/1.1 200 OK\r\n\
                          Content-Type: text/html\r\n\
                          Content-Length: 27\r\n\
                          \r\n\
                          <h1>Secure Connection!</h1>";
            
            stream.write_all(response.as_bytes()).await.ok();
        }
        Err(e) => eprintln!("âŒ è¯»å–é”™è¯¯: {}", e),
    }
}
```

---

## 2. é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„

### 2.1 mTLS (åŒå‘TLSè®¤è¯)

```rust
/// åŒå‘TLSè®¤è¯é…ç½®
fn create_mtls_server(
    cert_path: &str,
    key_path: &str,
    client_ca_path: &str,
) -> io::Result<ServerConfig> {
    use rustls::server::AllowAnyAuthenticatedClient;
    
    let certs = load_certs(cert_path)?;
    let key = load_private_key(key_path)?;
    
    // åŠ è½½å®¢æˆ·ç«¯CAè¯ä¹¦
    let mut client_auth_roots = RootCertStore::empty();
    let client_ca_certs = load_certs(client_ca_path)?;
    for cert in client_ca_certs {
        client_auth_roots.add(&cert).ok();
    }
    
    let client_auth = AllowAnyAuthenticatedClient::new(client_auth_roots);
    
    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_client_cert_verifier(Arc::new(client_auth))
        .with_single_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
    
    Ok(config)
}

/// å®¢æˆ·ç«¯mTLSé…ç½®
fn create_mtls_client(
    client_cert_path: &str,
    client_key_path: &str,
    server_ca_path: &str,
) -> io::Result<ClientConfig> {
    let certs = load_certs(client_cert_path)?;
    let key = load_private_key(client_key_path)?;
    
    let mut root_store = RootCertStore::empty();
    let server_ca_certs = load_certs(server_ca_path)?;
    for cert in server_ca_certs {
        root_store.add(&cert).ok();
    }
    
    let config = ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_client_auth_cert(certs, key)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
    
    Ok(config)
}
```

---

## 3. DDoS é˜²æŠ¤ç­–ç•¥

### 3.1 è¿æ¥é€Ÿç‡é™åˆ¶

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::sync::Arc;
use tokio::sync::Mutex;
use std::time::{Duration, Instant};

/// è¿æ¥é€Ÿç‡é™åˆ¶å™¨
struct RateLimiter {
    // IP -> (è¿æ¥è®¡æ•°, æœ€åé‡ç½®æ—¶é—´)
    connections: Arc<Mutex<HashMap<IpAddr, (usize, Instant)>>>,
    max_connections_per_second: usize,
    window: Duration,
}

impl RateLimiter {
    fn new(max_per_second: usize) -> Self {
        Self {
            connections: Arc::new(Mutex::new(HashMap::new())),
            max_connections_per_second: max_per_second,
            window: Duration::from_secs(1),
        }
    }
    
    async fn check_rate_limit(&self, ip: IpAddr) -> bool {
        let mut connections = self.connections.lock().await;
        let now = Instant::now();
        
        let (count, last_reset) = connections
            .entry(ip)
            .or_insert((0, now));
        
        // é‡ç½®çª—å£
        if now.duration_since(*last_reset) >= self.window {
            *count = 0;
            *last_reset = now;
        }
        
        *count += 1;
        
        if *count > self.max_connections_per_second {
            println!("âš ï¸  é€Ÿç‡é™åˆ¶: {} ({} è¿æ¥/ç§’)", ip, *count);
            false
        } else {
            true
        }
    }
}

/// ä½¿ç”¨é€Ÿç‡é™åˆ¶çš„æœåŠ¡å™¨
#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("0.0.0.0:8080").await?;
    let rate_limiter = Arc::new(RateLimiter::new(10)); // æ¯ç§’æœ€å¤š10ä¸ªè¿æ¥
    
    println!("ğŸ›¡ï¸  å¯åŠ¨DDoSé˜²æŠ¤æœåŠ¡å™¨ (é€Ÿç‡é™åˆ¶: 10è¿æ¥/ç§’)");
    
    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let limiter = rate_limiter.clone();
        
        tokio::spawn(async move {
            let ip = peer_addr.ip();
            
            if !limiter.check_rate_limit(ip).await {
                println!("ğŸš« æ‹’ç»è¿æ¥: {} (è¶…è¿‡é€Ÿç‡é™åˆ¶)", ip);
                return;
            }
            
            println!("âœ… æ¥å—è¿æ¥: {}", peer_addr);
            handle_connection(stream).await;
        });
    }
}
```

### 3.2 SYN Flood é˜²æŠ¤

```bash
#!/bin/bash
# Linuxå†…æ ¸çº§SYN Floodé˜²æŠ¤

# 1. å¯ç”¨SYN Cookies
sysctl -w net.ipv4.tcp_syncookies=1

# 2. å¢åŠ SYNé˜Ÿåˆ—å¤§å°
sysctl -w net.ipv4.tcp_max_syn_backlog=8192

# 3. å‡å°‘SYN-ACKé‡è¯•æ¬¡æ•°
sysctl -w net.ipv4.tcp_synack_retries=2

# 4. å‡å°‘SYNè¶…æ—¶æ—¶é—´
sysctl -w net.ipv4.tcp_syn_retries=3

echo "âœ… SYN Flood é˜²æŠ¤å·²å¯ç”¨"
```

---

## 4. ç½‘ç»œæµé‡åˆ†æ

### 4.1 å®æ—¶æµé‡ç›‘æ§

```rust
use std::sync::atomic::{AtomicU64, Ordering};

struct NetworkMetrics {
    bytes_sent: AtomicU64,
    bytes_received: AtomicU64,
    packets_sent: AtomicU64,
    packets_received: AtomicU64,
}

impl NetworkMetrics {
    fn new() -> Arc<Self> {
        Arc::new(Self {
            bytes_sent: AtomicU64::new(0),
            bytes_received: AtomicU64::new(0),
            packets_sent: AtomicU64::new(0),
            packets_received: AtomicU64::new(0),
        })
    }
    
    fn record_sent(&self, bytes: u64) {
        self.bytes_sent.fetch_add(bytes, Ordering::Relaxed);
        self.packets_sent.fetch_add(1, Ordering::Relaxed);
    }
    
    fn record_received(&self, bytes: u64) {
        self.bytes_received.fetch_add(bytes, Ordering::Relaxed);
        self.packets_received.fetch_add(1, Ordering::Relaxed);
    }
    
    fn report(&self) {
        let sent = self.bytes_sent.load(Ordering::Relaxed);
        let received = self.bytes_received.load(Ordering::Relaxed);
        let pkt_sent = self.packets_sent.load(Ordering::Relaxed);
        let pkt_received = self.packets_received.load(Ordering::Relaxed);
        
        println!("ğŸ“Š ç½‘ç»œæµé‡ç»Ÿè®¡:");
        println!("   å‘é€: {} MB ({} æ•°æ®åŒ…)", sent / 1_000_000, pkt_sent);
        println!("   æ¥æ”¶: {} MB ({} æ•°æ®åŒ…)", received / 1_000_000, pkt_received);
        println!("   æ€»è®¡: {} MB", (sent + received) / 1_000_000);
    }
}
```

---

## 5. å®‰å…¨æœ€ä½³å®è·µ

### 5.1 å®‰å…¨æ£€æŸ¥æ¸…å•

**åè®®å®‰å…¨** âœ…:

- [ ] ä½¿ç”¨TLS 1.3æˆ–æ›´é«˜ç‰ˆæœ¬
- [ ] ç¦ç”¨å¼±å¯†ç å¥—ä»¶
- [ ] å¯ç”¨å®Œç¾å‰å‘ä¿å¯† (PFS)
- [ ] å®æ–½è¯ä¹¦é’‰æ‰ (Certificate Pinning)
- [ ] ä½¿ç”¨HSTSå¼ºåˆ¶HTTPS

**è¾“å…¥éªŒè¯** âœ…:

- [ ] éªŒè¯æ‰€æœ‰å¤–éƒ¨è¾“å…¥
- [ ] é™åˆ¶è¯·æ±‚å¤§å°
- [ ] é˜²æ­¢ç¼“å†²åŒºæº¢å‡º
- [ ] æ£€æŸ¥åè®®æ ¼å¼

**è®¿é—®æ§åˆ¶** âœ…:

- [ ] å®æ–½æœ€å°æƒé™åŸåˆ™
- [ ] ä½¿ç”¨mTLSè¿›è¡ŒåŒå‘è®¤è¯
- [ ] å®æ–½é›¶ä¿¡ä»»æ¶æ„
- [ ] å®šæœŸå®¡è®¡è®¿é—®æ—¥å¿—

**DDoSé˜²æŠ¤** âœ…:

- [ ] å®æ–½é€Ÿç‡é™åˆ¶
- [ ] å¯ç”¨SYN Cookies
- [ ] ä½¿ç”¨CDN/DDoSé˜²æŠ¤æœåŠ¡
- [ ] ç›‘æ§å¼‚å¸¸æµé‡

---

## æ€»ç»“

ç½‘ç»œå®‰å…¨æ˜¯å¤šå±‚é˜²å¾¡çš„ç»¼åˆç­–ç•¥ï¼š

1. **ä¼ è¾“å±‚å®‰å…¨**: TLS 1.3 + mTLS
2. **åº”ç”¨å±‚é˜²æŠ¤**: é€Ÿç‡é™åˆ¶ + è¾“å…¥éªŒè¯
3. **ç›‘æ§ä¸å“åº”**: å®æ—¶æµé‡åˆ†æ + å¼‚å¸¸æ£€æµ‹

---

**ä¸‹ä¸€ç¯‡**: [04_åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„.md](04_åˆ†å¸ƒå¼ç½‘ç»œæ¶æ„.md)

**è¿”å›**: [Tier 4 README](README.md)
