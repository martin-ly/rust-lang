# 03 ç®—æ³•å¤æ‚åº¦åˆ†æ

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—
> **ç›®æ ‡è¯»è€…**: éœ€è¦æ·±å…¥ç†è§£ç®—æ³•æ€§èƒ½çš„å¼€å‘è€…
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 2-3å°æ—¶
> **å‰ç½®çŸ¥è¯†**: [ç®—æ³•å¿«é€Ÿå…¥é—¨](./01_ç®—æ³•å¿«é€Ÿå…¥é—¨.md)

## ğŸ“‹ ç›®å½•

- [03 ç®—æ³•å¤æ‚åº¦åˆ†æ](#03-ç®—æ³•å¤æ‚åº¦åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [æ¦‚å¿µçŸ©é˜µ](#æ¦‚å¿µçŸ©é˜µ)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. æ—¶é—´å¤æ‚åº¦åŸºç¡€](#1-æ—¶é—´å¤æ‚åº¦åŸºç¡€)
    - [1.1 åŸºæœ¬æ¦‚å¿µ](#11-åŸºæœ¬æ¦‚å¿µ)
    - [1.2 å¤æ‚åº¦å¯¹æ¯”](#12-å¤æ‚åº¦å¯¹æ¯”)
  - [2. ç©ºé—´å¤æ‚åº¦åˆ†æ](#2-ç©ºé—´å¤æ‚åº¦åˆ†æ)
    - [ç©ºé—´-æ—¶é—´æƒè¡¡](#ç©ºé—´-æ—¶é—´æƒè¡¡)
  - [3. å¸¸è§å¤æ‚åº¦ç±»å‹](#3-å¸¸è§å¤æ‚åº¦ç±»å‹)
    - [å¤æ‚åº¦å¢é•¿é€Ÿåº¦å¯¹æ¯”](#å¤æ‚åº¦å¢é•¿é€Ÿåº¦å¯¹æ¯”)
    - [å®é™…ç¤ºä¾‹](#å®é™…ç¤ºä¾‹)
  - [4. æ¸è¿›ç¬¦å·è¯¦è§£](#4-æ¸è¿›ç¬¦å·è¯¦è§£)
    - [Big O (ä¸Šç•Œ)](#big-o-ä¸Šç•Œ)
    - [Big Omega (ä¸‹ç•Œ)](#big-omega-ä¸‹ç•Œ)
    - [Big Theta (ç´§ç¡®ç•Œ)](#big-theta-ç´§ç¡®ç•Œ)
  - [5. é€’å½’ç®—æ³•åˆ†æ](#5-é€’å½’ç®—æ³•åˆ†æ)
    - [ä¸»å®šç†](#ä¸»å®šç†)
    - [é€’å½’æ ‘åˆ†æ](#é€’å½’æ ‘åˆ†æ)
  - [6. æ‘Šé”€åˆ†æ](#6-æ‘Šé”€åˆ†æ)
  - [7. å®æˆ˜åˆ†ææ¡ˆä¾‹](#7-å®æˆ˜åˆ†ææ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: ç»Ÿè®¡å•è¯é¢‘ç‡](#æ¡ˆä¾‹-1-ç»Ÿè®¡å•è¯é¢‘ç‡)
    - [æ¡ˆä¾‹ 2: æŸ¥æ‰¾é‡å¤å…ƒç´ ](#æ¡ˆä¾‹-2-æŸ¥æ‰¾é‡å¤å…ƒç´ )
  - [8. Rust æ€§èƒ½æµ‹è¯•](#8-rust-æ€§èƒ½æµ‹è¯•)
    - [ä½¿ç”¨ Criterion](#ä½¿ç”¨-criterion)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç®—æ³•å¤æ‚åº¦åˆ†æ (Algorithm Complexity Analysis)**:

- **å®šä¹‰**: åˆ†æç®—æ³•æ‰§è¡Œæ—¶é—´å’Œç©ºé—´éœ€æ±‚éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å˜åŒ–è¶‹åŠ¿
- **ç±»å‹**: ç®—æ³•åˆ†ææ–¹æ³•
- **èŒƒç•´**: ç®—æ³•å­¦ã€æ€§èƒ½åˆ†æ
- **ç›¸å…³æ¦‚å¿µ**: æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ã€æ¸è¿›ç¬¦å·ã€ä¸»å®šç†

**æ—¶é—´å¤æ‚åº¦ (Time Complexity)**:

- **å®šä¹‰**: ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å˜åŒ–è¶‹åŠ¿
- **ç±»å‹**: å¤æ‚åº¦åº¦é‡
- **å±æ€§**: æœ€å¥½æƒ…å†µã€å¹³å‡æƒ…å†µã€æœ€åæƒ…å†µ
- **å…³ç³»**: ä¸ç©ºé—´å¤æ‚åº¦ã€ç®—æ³•æ€§èƒ½ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **æ¸è¿›ç¬¦å·**: Big Oã€Big Omegaã€Big Theta
- **å¤æ‚åº¦ç±»å‹**: O(1)ã€O(log n)ã€O(n)ã€O(n log n)ã€O(nÂ²) ç­‰
- **é€’å½’åˆ†æ**: ä¸»å®šç†ã€é€’å½’æ ‘
- **æ‘Šé”€åˆ†æ**: å¹³å‡å¤æ‚åº¦åˆ†æ

**æ€§èƒ½ç‰¹å¾**:

- **å¸¸æ•°æ—¶é—´**: O(1) - æœ€ä¼˜
- **å¯¹æ•°æ—¶é—´**: O(log n) - ä¼˜ç§€
- **çº¿æ€§æ—¶é—´**: O(n) - è‰¯å¥½
- **å¹³æ–¹æ—¶é—´**: O(nÂ²) - è¾ƒå·®

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- æ—¶é—´å¤æ‚åº¦ --[is-a]--> ç®—æ³•å¤æ‚åº¦
- ç©ºé—´å¤æ‚åº¦ --[is-a]--> ç®—æ³•å¤æ‚åº¦

**ç»„åˆå…³ç³»**:

- ç®—æ³•åˆ†æ --[uses]--> å¤æ‚åº¦åˆ†æ
- æ€§èƒ½ä¼˜åŒ– --[uses]--> å¤æ‚åº¦åˆ†æ

**ä¾èµ–å…³ç³»**:

- å¤æ‚åº¦åˆ†æ --[depends-on]--> ç®—æ³•å®ç°
- æ€§èƒ½è¯„ä¼° --[depends-on]--> å¤æ‚åº¦åˆ†æ

### æ€ç»´å¯¼å›¾

```text
ç®—æ³•å¤æ‚åº¦åˆ†æ
â”‚
â”œâ”€â”€ æ—¶é—´å¤æ‚åº¦
â”‚   â”œâ”€â”€ O(1)
â”‚   â”œâ”€â”€ O(log n)
â”‚   â”œâ”€â”€ O(n)
â”‚   â””â”€â”€ O(nÂ²)
â”œâ”€â”€ ç©ºé—´å¤æ‚åº¦
â”‚   â””â”€â”€ ç©ºé—´-æ—¶é—´æƒè¡¡
â”œâ”€â”€ æ¸è¿›ç¬¦å·
â”‚   â”œâ”€â”€ Big O
â”‚   â”œâ”€â”€ Big Omega
â”‚   â””â”€â”€ Big Theta
â”œâ”€â”€ é€’å½’åˆ†æ
â”‚   â”œâ”€â”€ ä¸»å®šç†
â”‚   â””â”€â”€ é€’å½’æ ‘
â””â”€â”€ æ‘Šé”€åˆ†æ
```

### æ¦‚å¿µçŸ©é˜µ

| å¤æ‚åº¦     | å¢é•¿é€Ÿåº¦ | ç¤ºä¾‹ç®—æ³•     | é€‚ç”¨åœºæ™¯ |
| :--- | :--- | :--- | :--- || O(1)       | å¸¸æ•°     | æ•°ç»„è®¿é—®     | æœ€ä¼˜     |
| O(log n)   | å¯¹æ•°     | äºŒåˆ†æœç´¢     | ä¼˜ç§€     |
| O(n)       | çº¿æ€§     | çº¿æ€§æœç´¢     | è‰¯å¥½     |
| O(n log n) | çº¿æ€§å¯¹æ•° | å½’å¹¶æ’åº     | å¯æ¥å—   |
| O(nÂ²)      | å¹³æ–¹     | å†’æ³¡æ’åº     | è¾ƒå·®     |
| O(2â¿)      | æŒ‡æ•°     | é€’å½’æ–æ³¢é‚£å¥‘ | é¿å…     |

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- âœ… æŒæ¡å¤§Oã€Î˜ã€Î©ç¬¦å·çš„å«ä¹‰å’Œä½¿ç”¨
- âœ… åˆ†æå¸¸è§ç®—æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- âœ… ç†è§£æœ€å¥½ã€å¹³å‡ã€æœ€åæƒ…å†µå¤æ‚åº¦
- âœ… ä½¿ç”¨ Rust å·¥å…·è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
- âœ… ä¼˜åŒ–ç®—æ³•é™ä½å¤æ‚åº¦

---

## 1. æ—¶é—´å¤æ‚åº¦åŸºç¡€

### 1.1 åŸºæœ¬æ¦‚å¿µ

æ—¶é—´å¤æ‚åº¦æè¿°ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å˜åŒ–è¶‹åŠ¿ï¼š

```rust
// O(1) - å¸¸æ•°æ—¶é—´
fn constant_time(arr: &[i32]) -> Option<i32> {
    arr.first().copied()  // æ— è®ºæ•°ç»„å¤šå¤§ï¼Œè®¿é—®ç¬¬ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯å›ºå®šæ—¶é—´
}

// O(n) - çº¿æ€§æ—¶é—´
fn linear_time(arr: &[i32]) -> i32 {
    arr.iter().sum()  // éå†æ‰€æœ‰å…ƒç´ ä¸€æ¬¡
}

// O(nÂ²) - å¹³æ–¹æ—¶é—´
fn quadratic_time(arr: &[i32]) -> Vec<(i32, i32)> {
    let mut pairs = Vec::new();
    for &a in arr {
        for &b in arr {  // åµŒå¥—å¾ªç¯
            pairs.push((a, b));
        }
    }
    pairs
}

// O(log n) - å¯¹æ•°æ—¶é—´
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;  // æ¯æ¬¡å‡åŠ

        match arr[mid].cmp(&target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }

    None
}

// O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´
fn merge_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }

    let mid = arr.len() / 2;
    let left = merge_sort(&arr[..mid]);  // O(log n) å±‚
    let right = merge_sort(&arr[mid..]);

    merge(&left, &right)  // æ¯å±‚ O(n) åˆå¹¶
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let (mut i, mut j) = (0, 0);

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }

    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

### 1.2 å¤æ‚åº¦å¯¹æ¯”

```rust
use std::time::Instant;

fn complexity_comparison() {
    let sizes = [100, 1000, 10000];

    for &n in &sizes {
        let data: Vec<i32> = (0..n).collect();

        // O(1)
        let start = Instant::now();
        let _ = constant_time(&data);
        println!("O(1) n={}: {:?}", n, start.elapsed());

        // O(n)
        let start = Instant::now();
        let _ = linear_time(&data);
        println!("O(n) n={}: {:?}", n, start.elapsed());

        // O(log n)
        let start = Instant::now();
        let _ = binary_search(&data, n / 2);
        println!("O(log n) n={}: {:?}", n, start.elapsed());

        println!("---");
    }
}
```

---

## 2. ç©ºé—´å¤æ‚åº¦åˆ†æ

ç©ºé—´å¤æ‚åº¦æè¿°ç®—æ³•æ‰€éœ€çš„é¢å¤–å†…å­˜ç©ºé—´ï¼š

```rust
// O(1) ç©ºé—´ - åŸåœ°æ“ä½œ
fn bubble_sort_inplace<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);  // åªä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´
            }
        }
    }
}

// O(n) ç©ºé—´ - éœ€è¦é¢å¤–æ•°ç»„
fn merge_sort_extra<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }

    let mid = arr.len() / 2;
    let left = merge_sort_extra(&arr[..mid]);
    let right = merge_sort_extra(&arr[mid..]);

    merge(&left, &right)  // éœ€è¦ O(n) é¢å¤–ç©ºé—´
}

// O(log n) ç©ºé—´ - é€’å½’è°ƒç”¨æ ˆ
fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot = partition(arr);
    quick_sort(&mut arr[..pivot]);  // é€’å½’æ·±åº¦ O(log n)
    quick_sort(&mut arr[pivot + 1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;

    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }

    arr.swap(i, pivot);
    i
}
```

### ç©ºé—´-æ—¶é—´æƒè¡¡

```rust
use std::collections::HashMap;

// æ–¹æ¡ˆ 1: O(n) æ—¶é—´, O(1) ç©ºé—´
fn two_sum_slow(nums: &[i32], target: i32) -> Option<(usize, usize)> {
    for i in 0..nums.len() {
        for j in i + 1..nums.len() {
            if nums[i] + nums[j] == target {
                return Some((i, j));
            }
        }
    }
    None
}

// æ–¹æ¡ˆ 2: O(n) æ—¶é—´, O(n) ç©ºé—´ - ç”¨ç©ºé—´æ¢æ—¶é—´
fn two_sum_fast(nums: &[i32], target: i32) -> Option<(usize, usize)> {
    let mut map = HashMap::new();

    for (i, &num) in nums.iter().enumerate() {
        let complement = target - num;
        if let Some(&j) = map.get(&complement) {
            return Some((j, i));
        }
        map.insert(num, i);
    }

    None
}

fn main() {
    let nums = vec![2, 7, 11, 15];
    let target = 9;

    assert_eq!(two_sum_slow(&nums, target), Some((0, 1)));
    assert_eq!(two_sum_fast(&nums, target), Some((0, 1)));
}
```

---

## 3. å¸¸è§å¤æ‚åº¦ç±»å‹

### å¤æ‚åº¦å¢é•¿é€Ÿåº¦å¯¹æ¯”

| å¤æ‚åº¦     | n=10 | n=100 | n=1000  | åç§°     | ç¤ºä¾‹         |
| :--- | :--- | :--- | :--- | :--- | :--- || O(1)       | 1    | 1     | 1       | å¸¸æ•°     | æ•°ç»„è®¿é—®     |
| O(log n)   | 3    | 7     | 10      | å¯¹æ•°     | äºŒåˆ†æœç´¢     |
| O(n)       | 10   | 100   | 1000    | çº¿æ€§     | æ•°ç»„éå†     |
| O(n log n) | 30   | 700   | 10000   | çº¿æ€§å¯¹æ•° | å½’å¹¶æ’åº     |
| O(nÂ²)      | 100  | 10000 | 1000000 | å¹³æ–¹     | å†’æ³¡æ’åº     |
| O(2â¿)      | 1024 | 10Â³â°  | 10Â³â°â°   | æŒ‡æ•°     | æ–æ³¢é‚£å¥‘é€’å½’ |

### å®é™…ç¤ºä¾‹

```rust
// O(1)
fn get_first<T>(arr: &[T]) -> Option<&T> {
    arr.first()
}

// O(log n) - äºŒåˆ†æŸ¥æ‰¾
fn binary_search_recursive<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    fn search<T: Ord>(arr: &[T], target: &T, offset: usize) -> Option<usize> {
        if arr.is_empty() {
            return None;
        }

        let mid = arr.len() / 2;
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => Some(mid + offset),
            std::cmp::Ordering::Greater => search(&arr[..mid], target, offset),
            std::cmp::Ordering::Less => search(&arr[mid + 1..], target, offset + mid + 1),
        }
    }

    search(arr, target, 0)
}

// O(n) - çº¿æ€§æŸ¥æ‰¾
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
    arr.iter().position(|x| x == target)
}

// O(n log n) - å¿«é€Ÿæ’åºå¹³å‡æƒ…å†µ
// ï¼ˆæœ€å O(nÂ²)ï¼Œä½†å®è·µä¸­å¾ˆå°‘é‡åˆ°ï¼‰

// O(nÂ²) - é€‰æ‹©æ’åº
fn selection_sort<T: Ord>(arr: &mut [T]) {
    for i in 0..arr.len() {
        let mut min_idx = i;
        for j in i + 1..arr.len() {
            if arr[j] < arr[min_idx] {
                min_idx = j;
            }
        }
        arr.swap(i, min_idx);
    }
}

// O(2â¿) - é€’å½’æ–æ³¢é‚£å¥‘ï¼ˆä½æ•ˆï¼‰
fn fibonacci_recursive(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2),
    }
}

// ä¼˜åŒ–ä¸º O(n)
fn fibonacci_iterative(n: u32) -> u64 {
    let (mut a, mut b) = (0, 1);
    for _ in 0..n {
        let temp = a;
        a = b;
        b = temp + b;
    }
    a
}
```

---

## 4. æ¸è¿›ç¬¦å·è¯¦è§£

### Big O (ä¸Šç•Œ)

è¡¨ç¤ºç®—æ³•çš„æœ€åæƒ…å†µï¼š

```rust
// å¿«é€Ÿæ’åº: O(nÂ²) æœ€åï¼ŒO(n log n) å¹³å‡
// ä½†æˆ‘ä»¬è¯´å¿«é€Ÿæ’åºæ˜¯ O(nÂ²)ï¼Œå› ä¸º Big O æ˜¯ä¸Šç•Œ
```

### Big Omega (ä¸‹ç•Œ)

è¡¨ç¤ºç®—æ³•çš„æœ€å¥½æƒ…å†µï¼š

```rust
// å†’æ³¡æ’åº: Î©(n) æœ€å¥½ï¼ˆå·²æ’åºï¼‰ï¼ŒO(nÂ²) æœ€å
fn bubble_sort_optimized<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        let mut swapped = false;
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
                swapped = true;
            }
        }
        if !swapped {
            break;  // å·²æ’åºï¼Œæå‰é€€å‡º - Î©(n)
        }
    }
}
```

### Big Theta (ç´§ç¡®ç•Œ)

è¡¨ç¤ºç®—æ³•çš„å¹³å‡æƒ…å†µï¼š

```rust
// å½’å¹¶æ’åº: Î˜(n log n) æ‰€æœ‰æƒ…å†µ
// æœ€å¥½ã€å¹³å‡ã€æœ€åéƒ½æ˜¯ n log n
```

---

## 5. é€’å½’ç®—æ³•åˆ†æ

### ä¸»å®šç†

ç”¨äºåˆ†æé€’å½’ç®—æ³•çš„å¤æ‚åº¦ï¼š

```text
T(n) = aT(n/b) + f(n)

å…¶ä¸­ï¼š
- a: å­é—®é¢˜æ•°é‡
- n/b: å­é—®é¢˜è§„æ¨¡
- f(n): åˆå¹¶ä»£ä»·
```

**ç¤ºä¾‹**ï¼š

```rust
// å½’å¹¶æ’åº: T(n) = 2T(n/2) + O(n)
// a=2, b=2, f(n)=O(n)
// ç»“æœ: O(n log n)

// äºŒåˆ†æœç´¢: T(n) = T(n/2) + O(1)
// a=1, b=2, f(n)=O(1)
// ç»“æœ: O(log n)

// æ–æ³¢é‚£å¥‘é€’å½’: T(n) = T(n-1) + T(n-2) + O(1)
// ç»“æœ: O(2â¿)
```

### é€’å½’æ ‘åˆ†æ

```rust
// æ±‰è¯ºå¡”é—®é¢˜: T(n) = 2T(n-1) + O(1)
fn hanoi(n: u32, from: char, to: char, aux: char) {
    if n == 1 {
        println!("ç§»åŠ¨ç›˜å­ 1 ä» {} åˆ° {}", from, to);
        return;
    }

    hanoi(n - 1, from, aux, to);
    println!("ç§»åŠ¨ç›˜å­ {} ä» {} åˆ° {}", n, from, to);
    hanoi(n - 1, aux, to, from);
}

// å¤æ‚åº¦: O(2â¿)
// ç§»åŠ¨æ¬¡æ•°: 2â¿ - 1
```

---

## 6. æ‘Šé”€åˆ†æ

åŠ¨æ€æ•°ç»„çš„æ‘Šé”€å¤æ‚åº¦ï¼š

```rust
fn analyze_vector_push() {
    let mut v = Vec::with_capacity(1);

    for i in 0..16 {
        println!("æ’å…¥å‰ - é•¿åº¦: {}, å®¹é‡: {}", v.len(), v.capacity());
        v.push(i);
        println!("æ’å…¥å - é•¿åº¦: {}, å®¹é‡: {}", v.len(), v.capacity());
    }
}

// è¾“å‡ºç¤ºä¾‹:
// æ’å…¥å‰ - é•¿åº¦: 0, å®¹é‡: 1
// æ’å…¥å - é•¿åº¦: 1, å®¹é‡: 1
// æ’å…¥å‰ - é•¿åº¦: 1, å®¹é‡: 1
// æ’å…¥å - é•¿åº¦: 2, å®¹é‡: 2  // æ‰©å®¹
// æ’å…¥å‰ - é•¿åº¦: 2, å®¹é‡: 2
// æ’å…¥å - é•¿åº¦: 3, å®¹é‡: 4  // æ‰©å®¹
// ...

// è™½ç„¶ä¸ªåˆ«æ’å…¥æ˜¯ O(n)ï¼Œä½†æ‘Šé”€åæ¯æ¬¡æ’å…¥æ˜¯ O(1)
```

**æ‘Šé”€åˆ†æ**ï¼š

- å¤§éƒ¨åˆ†æ’å…¥: O(1)
- å¶å°”æ‰©å®¹: O(n)
- æ‘Šé”€å¤æ‚åº¦: O(1)

---

## 7. å®æˆ˜åˆ†ææ¡ˆä¾‹

### æ¡ˆä¾‹ 1: ç»Ÿè®¡å•è¯é¢‘ç‡

```rust
use std::collections::HashMap;

// æ–¹æ¡ˆ 1: O(nÂ²) - æœ´ç´ æ–¹æ³•
fn count_words_slow(words: &[String]) -> Vec<(String, usize)> {
    let mut result = Vec::new();

    for word in words {
        let mut found = false;
        for (w, count) in &mut result {
            if w == word {
                *count += 1;
                found = true;
                break;
            }
        }
        if !found {
            result.push((word.clone(), 1));
        }
    }

    result
}

// æ–¹æ¡ˆ 2: O(n) - å“ˆå¸Œè¡¨
fn count_words_fast(words: &[String]) -> HashMap<String, usize> {
    let mut counts = HashMap::new();

    for word in words {
        *counts.entry(word.clone()).or_insert(0) += 1;
    }

    counts
}

// æ€§èƒ½å¯¹æ¯”
fn benchmark_word_count() {
    let words: Vec<String> = (0..1000).map(|i| format!("word{}", i % 100)).collect();

    let start = std::time::Instant::now();
    let _ = count_words_slow(&words);
    println!("O(nÂ²): {:?}", start.elapsed());

    let start = std::time::Instant::now();
    let _ = count_words_fast(&words);
    println!("O(n): {:?}", start.elapsed());
}
```

### æ¡ˆä¾‹ 2: æŸ¥æ‰¾é‡å¤å…ƒç´ 

```rust
use std::collections::HashSet;

// O(nÂ²) æ—¶é—´, O(1) ç©ºé—´
fn has_duplicate_slow(nums: &[i32]) -> bool {
    for i in 0..nums.len() {
        for j in i + 1..nums.len() {
            if nums[i] == nums[j] {
                return true;
            }
        }
    }
    false
}

// O(n log n) æ—¶é—´, O(1) ç©ºé—´
fn has_duplicate_sort(nums: &mut [i32]) -> bool {
    nums.sort_unstable();

    for i in 0..nums.len() - 1 {
        if nums[i] == nums[i + 1] {
            return true;
        }
    }
    false
}

// O(n) æ—¶é—´, O(n) ç©ºé—´
fn has_duplicate_fast(nums: &[i32]) -> bool {
    let mut set = HashSet::new();

    for &num in nums {
        if !set.insert(num) {
            return true;
        }
    }
    false
}
```

---

## 8. Rust æ€§èƒ½æµ‹è¯•

### ä½¿ç”¨ Criterion

`Cargo.toml`:

```toml
[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "algorithms"
harness = false
```

`benches/algorithms.rs`:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn linear_search(arr: &[i32], target: i32) -> Option<usize> {
    arr.iter().position(|&x| x == target)
}

fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    arr.binary_search(&target).ok()
}

fn benchmark_search(c: &mut Criterion) {
    let data: Vec<i32> = (0..10000).collect();

    c.bench_function("linear_search", |b| {
        b.iter(|| linear_search(black_box(&data), black_box(5000)))
    });

    c.bench_function("binary_search", |b| {
        b.iter(|| binary_search(black_box(&data), black_box(5000)))
    });
}

criterion_group!(benches, benchmark_search);
criterion_main!(benches);
```

è¿è¡Œï¼š

```bash
cargo bench
```

---

## 9. æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„**:
   - éœ€è¦å¿«é€ŸæŸ¥æ‰¾ â†’ HashMap (O(1))
   - éœ€è¦æœ‰åºéå† â†’ BTreeMap (O(log n))
   - éœ€è¦éšæœºè®¿é—® â†’ Vec (O(1))

2. **é¿å…ä¸å¿…è¦çš„åµŒå¥—å¾ªç¯**:

   ```rust
   // âŒ O(nÂ²)
   for i in 0..n {
       for j in 0..n {
           // ...
       }
   }

   // âœ… O(n) - ä½¿ç”¨å“ˆå¸Œè¡¨
   let mut map = HashMap::new();
   for item in items {
       map.entry(item).or_insert(Vec::new()).push(item);
   }
   ```

3. **é¢„åˆ†é…å®¹é‡**:

   ```rust
   // âŒ å¤šæ¬¡æ‰©å®¹
   let mut v = Vec::new();
   for i in 0..1000 {
       v.push(i);
   }

   // âœ… ä¸€æ¬¡åˆ†é…
   let mut v = Vec::with_capacity(1000);
   for i in 0..1000 {
       v.push(i);
   }
   ```

4. **ä½¿ç”¨è¿­ä»£å™¨é¿å…ä¸­é—´åˆ†é…**:

   ```rust
   // âŒ å¤šæ¬¡åˆ†é…
   let v: Vec<i32> = vec![1, 2, 3, 4, 5];
   let filtered: Vec<i32> = v.iter().filter(|&&x| x % 2 == 0).copied().collect();
   let doubled: Vec<i32> = filtered.iter().map(|&x| x * 2).collect();

   // âœ… é“¾å¼æ“ä½œï¼Œä¸€æ¬¡åˆ†é…
   let result: Vec<i32> = vec![1, 2, 3, 4, 5]
       .iter()
       .filter(|&&x| x % 2 == 0)
       .map(|&x| x * 2)
       .collect();
   ```

---

## ğŸ”— ç›¸å…³èµ„æº

**å†…éƒ¨æ–‡æ¡£**:

- [æ•°æ®ç»“æ„å®è·µ](./02_æ•°æ®ç»“æ„å®è·µ.md) - æ•°æ®ç»“æ„é€‰æ‹©
- [æ€§èƒ½ä¼˜åŒ–å®è·µ](./04_æ€§èƒ½ä¼˜åŒ–å®è·µ.md) - ä¼˜åŒ–æŠ€å·§
- [ç®—æ³•æ€§èƒ½å‚è€ƒ](../tier_03_references/04_ç®—æ³•æ€§èƒ½å‚è€ƒ.md) - åŸºå‡†ä¸ Criterion

**å¤–éƒ¨èµ„æº**:

- ğŸŒ [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
- ğŸ“˜ [ç®—æ³•å¯¼è®º](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- ğŸ¦€ [Rust Performance Book](https://nnethercote.github.io/perf-book/)

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [æ€§èƒ½ä¼˜åŒ–å®è·µ](./04_æ€§èƒ½ä¼˜åŒ–å®è·µ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
