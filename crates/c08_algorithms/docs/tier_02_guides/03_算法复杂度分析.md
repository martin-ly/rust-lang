# 03 算法复杂度分析

> **文档类型**: Tier 2 - 实践指南
> **目标读者**: 需要深入理解算法性能的开发者
> **预计学习时间**: 2-3小时
> **前置知识**: [算法快速入门](./01_算法快速入门.md)

## 📋 目录

- [03 算法复杂度分析](#03-算法复杂度分析)
  - [📋 目录](#-目录)
  - [🎯 学习目标](#-学习目标)
  - [1. 时间复杂度基础](#1-时间复杂度基础)
    - [1.1 基本概念](#11-基本概念)
    - [1.2 复杂度对比](#12-复杂度对比)
  - [2. 空间复杂度分析](#2-空间复杂度分析)
    - [空间-时间权衡](#空间-时间权衡)
  - [3. 常见复杂度类型](#3-常见复杂度类型)
    - [复杂度增长速度对比](#复杂度增长速度对比)
    - [实际示例](#实际示例)
  - [4. 渐进符号详解](#4-渐进符号详解)
    - [Big O (上界)](#big-o-上界)
    - [Big Omega (下界)](#big-omega-下界)
    - [Big Theta (紧确界)](#big-theta-紧确界)
  - [5. 递归算法分析](#5-递归算法分析)
    - [主定理](#主定理)
    - [递归树分析](#递归树分析)
  - [6. 摊销分析](#6-摊销分析)
  - [7. 实战分析案例](#7-实战分析案例)
    - [案例 1: 统计单词频率](#案例-1-统计单词频率)
    - [案例 2: 查找重复元素](#案例-2-查找重复元素)
  - [8. Rust 性能测试](#8-rust-性能测试)
    - [使用 Criterion](#使用-criterion)
  - [9. 最佳实践](#9-最佳实践)
  - [🔗 相关资源](#-相关资源)

---

## 🎯 学习目标

- ✅ 掌握大O、Θ、Ω符号的含义和使用
- ✅ 分析常见算法的时间和空间复杂度
- ✅ 理解最好、平均、最坏情况复杂度
- ✅ 使用 Rust 工具进行性能基准测试
- ✅ 优化算法降低复杂度

---

## 1. 时间复杂度基础

### 1.1 基本概念

时间复杂度描述算法执行时间随输入规模增长的变化趋势：

```rust
// O(1) - 常数时间
fn constant_time(arr: &[i32]) -> Option<i32> {
    arr.first().copied()  // 无论数组多大，访问第一个元素都是固定时间
}

// O(n) - 线性时间
fn linear_time(arr: &[i32]) -> i32 {
    arr.iter().sum()  // 遍历所有元素一次
}

// O(n²) - 平方时间
fn quadratic_time(arr: &[i32]) -> Vec<(i32, i32)> {
    let mut pairs = Vec::new();
    for &a in arr {
        for &b in arr {  // 嵌套循环
            pairs.push((a, b));
        }
    }
    pairs
}

// O(log n) - 对数时间
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;  // 每次减半

        match arr[mid].cmp(&target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }

    None
}

// O(n log n) - 线性对数时间
fn merge_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }

    let mid = arr.len() / 2;
    let left = merge_sort(&arr[..mid]);  // O(log n) 层
    let right = merge_sort(&arr[mid..]);

    merge(&left, &right)  // 每层 O(n) 合并
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let (mut i, mut j) = (0, 0);

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }

    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

### 1.2 复杂度对比

```rust
use std::time::Instant;

fn complexity_comparison() {
    let sizes = [100, 1000, 10000];

    for &n in &sizes {
        let data: Vec<i32> = (0..n).collect();

        // O(1)
        let start = Instant::now();
        let _ = constant_time(&data);
        println!("O(1) n={}: {:?}", n, start.elapsed());

        // O(n)
        let start = Instant::now();
        let _ = linear_time(&data);
        println!("O(n) n={}: {:?}", n, start.elapsed());

        // O(log n)
        let start = Instant::now();
        let _ = binary_search(&data, n / 2);
        println!("O(log n) n={}: {:?}", n, start.elapsed());

        println!("---");
    }
}
```

---

## 2. 空间复杂度分析

空间复杂度描述算法所需的额外内存空间：

```rust
// O(1) 空间 - 原地操作
fn bubble_sort_inplace<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);  // 只使用常量额外空间
            }
        }
    }
}

// O(n) 空间 - 需要额外数组
fn merge_sort_extra<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }

    let mid = arr.len() / 2;
    let left = merge_sort_extra(&arr[..mid]);
    let right = merge_sort_extra(&arr[mid..]);

    merge(&left, &right)  // 需要 O(n) 额外空间
}

// O(log n) 空间 - 递归调用栈
fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot = partition(arr);
    quick_sort(&mut arr[..pivot]);  // 递归深度 O(log n)
    quick_sort(&mut arr[pivot + 1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;

    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }

    arr.swap(i, pivot);
    i
}
```

### 空间-时间权衡

```rust
use std::collections::HashMap;

// 方案 1: O(n) 时间, O(1) 空间
fn two_sum_slow(nums: &[i32], target: i32) -> Option<(usize, usize)> {
    for i in 0..nums.len() {
        for j in i + 1..nums.len() {
            if nums[i] + nums[j] == target {
                return Some((i, j));
            }
        }
    }
    None
}

// 方案 2: O(n) 时间, O(n) 空间 - 用空间换时间
fn two_sum_fast(nums: &[i32], target: i32) -> Option<(usize, usize)> {
    let mut map = HashMap::new();

    for (i, &num) in nums.iter().enumerate() {
        let complement = target - num;
        if let Some(&j) = map.get(&complement) {
            return Some((j, i));
        }
        map.insert(num, i);
    }

    None
}

fn main() {
    let nums = vec![2, 7, 11, 15];
    let target = 9;

    assert_eq!(two_sum_slow(&nums, target), Some((0, 1)));
    assert_eq!(two_sum_fast(&nums, target), Some((0, 1)));
}
```

---

## 3. 常见复杂度类型

### 复杂度增长速度对比

| 复杂度 | n=10 | n=100 | n=1000 | 名称 | 示例 |
| --- | --- | --- | --- | --- | --- |
| O(1) | 1 | 1 | 1 | 常数 | 数组访问 |
| O(log n) | 3 | 7 | 10 | 对数 | 二分搜索 |
| O(n) | 10 | 100 | 1000 | 线性 | 数组遍历 |
| O(n log n) | 30 | 700 | 10000 | 线性对数 | 归并排序 |
| O(n²) | 100 | 10000 | 1000000 | 平方 | 冒泡排序 |
| O(2ⁿ) | 1024 | 10³⁰ | 10³⁰⁰ | 指数 | 斐波那契递归 |

### 实际示例

```rust
// O(1)
fn get_first<T>(arr: &[T]) -> Option<&T> {
    arr.first()
}

// O(log n) - 二分查找
fn binary_search_recursive<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    fn search<T: Ord>(arr: &[T], target: &T, offset: usize) -> Option<usize> {
        if arr.is_empty() {
            return None;
        }

        let mid = arr.len() / 2;
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => Some(mid + offset),
            std::cmp::Ordering::Greater => search(&arr[..mid], target, offset),
            std::cmp::Ordering::Less => search(&arr[mid + 1..], target, offset + mid + 1),
        }
    }

    search(arr, target, 0)
}

// O(n) - 线性查找
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
    arr.iter().position(|x| x == target)
}

// O(n log n) - 快速排序平均情况
// （最坏 O(n²)，但实践中很少遇到）

// O(n²) - 选择排序
fn selection_sort<T: Ord>(arr: &mut [T]) {
    for i in 0..arr.len() {
        let mut min_idx = i;
        for j in i + 1..arr.len() {
            if arr[j] < arr[min_idx] {
                min_idx = j;
            }
        }
        arr.swap(i, min_idx);
    }
}

// O(2ⁿ) - 递归斐波那契（低效）
fn fibonacci_recursive(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2),
    }
}

// 优化为 O(n)
fn fibonacci_iterative(n: u32) -> u64 {
    let (mut a, mut b) = (0, 1);
    for _ in 0..n {
        let temp = a;
        a = b;
        b = temp + b;
    }
    a
}
```

---

## 4. 渐进符号详解

### Big O (上界)

表示算法的最坏情况：

```rust
// 快速排序: O(n²) 最坏，O(n log n) 平均
// 但我们说快速排序是 O(n²)，因为 Big O 是上界
```

### Big Omega (下界)

表示算法的最好情况：

```rust
// 冒泡排序: Ω(n) 最好（已排序），O(n²) 最坏
fn bubble_sort_optimized<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        let mut swapped = false;
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
                swapped = true;
            }
        }
        if !swapped {
            break;  // 已排序，提前退出 - Ω(n)
        }
    }
}
```

### Big Theta (紧确界)

表示算法的平均情况：

```rust
// 归并排序: Θ(n log n) 所有情况
// 最好、平均、最坏都是 n log n
```

---

## 5. 递归算法分析

### 主定理

用于分析递归算法的复杂度：

```text
T(n) = aT(n/b) + f(n)

其中：
- a: 子问题数量
- n/b: 子问题规模
- f(n): 合并代价
```

**示例**：

```rust
// 归并排序: T(n) = 2T(n/2) + O(n)
// a=2, b=2, f(n)=O(n)
// 结果: O(n log n)

// 二分搜索: T(n) = T(n/2) + O(1)
// a=1, b=2, f(n)=O(1)
// 结果: O(log n)

// 斐波那契递归: T(n) = T(n-1) + T(n-2) + O(1)
// 结果: O(2ⁿ)
```

### 递归树分析

```rust
// 汉诺塔问题: T(n) = 2T(n-1) + O(1)
fn hanoi(n: u32, from: char, to: char, aux: char) {
    if n == 1 {
        println!("移动盘子 1 从 {} 到 {}", from, to);
        return;
    }

    hanoi(n - 1, from, aux, to);
    println!("移动盘子 {} 从 {} 到 {}", n, from, to);
    hanoi(n - 1, aux, to, from);
}

// 复杂度: O(2ⁿ)
// 移动次数: 2ⁿ - 1
```

---

## 6. 摊销分析

动态数组的摊销复杂度：

```rust
fn analyze_vector_push() {
    let mut v = Vec::with_capacity(1);

    for i in 0..16 {
        println!("插入前 - 长度: {}, 容量: {}", v.len(), v.capacity());
        v.push(i);
        println!("插入后 - 长度: {}, 容量: {}", v.len(), v.capacity());
    }
}

// 输出示例:
// 插入前 - 长度: 0, 容量: 1
// 插入后 - 长度: 1, 容量: 1
// 插入前 - 长度: 1, 容量: 1
// 插入后 - 长度: 2, 容量: 2  // 扩容
// 插入前 - 长度: 2, 容量: 2
// 插入后 - 长度: 3, 容量: 4  // 扩容
// ...

// 虽然个别插入是 O(n)，但摊销后每次插入是 O(1)
```

**摊销分析**：

- 大部分插入: O(1)
- 偶尔扩容: O(n)
- 摊销复杂度: O(1)

---

## 7. 实战分析案例

### 案例 1: 统计单词频率

```rust
use std::collections::HashMap;

// 方案 1: O(n²) - 朴素方法
fn count_words_slow(words: &[String]) -> Vec<(String, usize)> {
    let mut result = Vec::new();

    for word in words {
        let mut found = false;
        for (w, count) in &mut result {
            if w == word {
                *count += 1;
                found = true;
                break;
            }
        }
        if !found {
            result.push((word.clone(), 1));
        }
    }

    result
}

// 方案 2: O(n) - 哈希表
fn count_words_fast(words: &[String]) -> HashMap<String, usize> {
    let mut counts = HashMap::new();

    for word in words {
        *counts.entry(word.clone()).or_insert(0) += 1;
    }

    counts
}

// 性能对比
fn benchmark_word_count() {
    let words: Vec<String> = (0..1000).map(|i| format!("word{}", i % 100)).collect();

    let start = std::time::Instant::now();
    let _ = count_words_slow(&words);
    println!("O(n²): {:?}", start.elapsed());

    let start = std::time::Instant::now();
    let _ = count_words_fast(&words);
    println!("O(n): {:?}", start.elapsed());
}
```

### 案例 2: 查找重复元素

```rust
use std::collections::HashSet;

// O(n²) 时间, O(1) 空间
fn has_duplicate_slow(nums: &[i32]) -> bool {
    for i in 0..nums.len() {
        for j in i + 1..nums.len() {
            if nums[i] == nums[j] {
                return true;
            }
        }
    }
    false
}

// O(n log n) 时间, O(1) 空间
fn has_duplicate_sort(nums: &mut [i32]) -> bool {
    nums.sort_unstable();

    for i in 0..nums.len() - 1 {
        if nums[i] == nums[i + 1] {
            return true;
        }
    }
    false
}

// O(n) 时间, O(n) 空间
fn has_duplicate_fast(nums: &[i32]) -> bool {
    let mut set = HashSet::new();

    for &num in nums {
        if !set.insert(num) {
            return true;
        }
    }
    false
}
```

---

## 8. Rust 性能测试

### 使用 Criterion

`Cargo.toml`:

```toml
[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "algorithms"
harness = false
```

`benches/algorithms.rs`:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn linear_search(arr: &[i32], target: i32) -> Option<usize> {
    arr.iter().position(|&x| x == target)
}

fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    arr.binary_search(&target).ok()
}

fn benchmark_search(c: &mut Criterion) {
    let data: Vec<i32> = (0..10000).collect();

    c.bench_function("linear_search", |b| {
        b.iter(|| linear_search(black_box(&data), black_box(5000)))
    });

    c.bench_function("binary_search", |b| {
        b.iter(|| binary_search(black_box(&data), black_box(5000)))
    });
}

criterion_group!(benches, benchmark_search);
criterion_main!(benches);
```

运行：

```bash
cargo bench
```

---

## 9. 最佳实践

1. **选择合适的数据结构**:
   - 需要快速查找 → HashMap (O(1))
   - 需要有序遍历 → BTreeMap (O(log n))
   - 需要随机访问 → Vec (O(1))

2. **避免不必要的嵌套循环**:

   ```rust
   // ❌ O(n²)
   for i in 0..n {
       for j in 0..n {
           // ...
       }
   }

   // ✅ O(n) - 使用哈希表
   let mut map = HashMap::new();
   for item in items {
       map.entry(item).or_insert(Vec::new()).push(item);
   }
   ```

3. **预分配容量**:

   ```rust
   // ❌ 多次扩容
   let mut v = Vec::new();
   for i in 0..1000 {
       v.push(i);
   }

   // ✅ 一次分配
   let mut v = Vec::with_capacity(1000);
   for i in 0..1000 {
       v.push(i);
   }
   ```

4. **使用迭代器避免中间分配**:

   ```rust
   // ❌ 多次分配
   let v: Vec<i32> = vec![1, 2, 3, 4, 5];
   let filtered: Vec<i32> = v.iter().filter(|&&x| x % 2 == 0).copied().collect();
   let doubled: Vec<i32> = filtered.iter().map(|&x| x * 2).collect();

   // ✅ 链式操作，一次分配
   let result: Vec<i32> = vec![1, 2, 3, 4, 5]
       .iter()
       .filter(|&&x| x % 2 == 0)
       .map(|&x| x * 2)
       .collect();
   ```

---

## 🔗 相关资源

**内部文档**:

- [数据结构实践](./02_数据结构实践.md) - 数据结构选择
- [性能优化实践](./04_性能优化实践.md) - 优化技巧
- [详细指南](../guides/algorithm_complexity.md) - 完整参考

**外部资源**:

- 🌐 [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
- 📘 [算法导论](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- 🦀 [Rust Performance Book](https://nnethercote.github.io/perf-book/)

---

**返回**: [Tier 2 索引](./README.md) | **下一步**: [性能优化实践](./04_性能优化实践.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-23
**文档状态**: ✅ 完成
