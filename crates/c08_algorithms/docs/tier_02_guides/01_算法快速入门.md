# 01 算法快速入门

> **文档类型**: Tier 2 - 实践指南
> **目标读者**: 算法初学者
> **预计学习时间**: 2-3小时
> **前置知识**: 基础 Rust 语法

## 📋 目录

- [01 算法快速入门](#01-算法快速入门)
  - [📋 目录](#-目录)
  - [📋 学习目标](#-学习目标)
  - [🚀 核心算法速览](#-核心算法速览)
    - [1. 排序算法](#1-排序算法)
    - [2. 搜索算法](#2-搜索算法)
    - [3. Rust 迭代器算法](#3-rust-迭代器算法)
  - [📐 知识结构](#-知识结构)
    - [概念定义](#概念定义)
    - [属性特征](#属性特征)
    - [关系连接](#关系连接)
    - [思维导图](#思维导图)
    - [概念矩阵](#概念矩阵)
  - [📊 算法复杂度对比](#-算法复杂度对比)
  - [🎯 实战练习](#-实战练习)
    - [练习 1: 实现选择排序](#练习-1-实现选择排序)
    - [练习 2: 插值搜索](#练习-2-插值搜索)
    - [练习 3: 使用迭代器优化](#练习-3-使用迭代器优化)
  - [🔗 相关资源](#-相关资源)
  - [📞 获取帮助](#-获取帮助)

## 📋 学习目标

完成本指南后，你将能够：

- ✅ 实现常见排序算法（冒泡、快排、归并）
- ✅ 掌握二分搜索和线性搜索
- ✅ 理解算法时间复杂度
- ✅ 使用 Rust 特性优化算法
- ✅ 编写高效的迭代器算法

---

## 🚀 核心算法速览

### 1. 排序算法

**冒泡排序** - O(n²):

```rust
fn bubble_sort<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
            }
        }
    }
}
```

**快速排序** - O(n log n):

```rust
fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot = partition(arr);
    let (left, right) = arr.split_at_mut(pivot);

    quick_sort(left);
    quick_sort(&mut right[1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;

    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }

    arr.swap(i, pivot);
    i
}
```

**归并排序** - O(n log n):

```rust
fn merge_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }

    let mid = arr.len() / 2;
    let left = merge_sort(&arr[..mid]);
    let right = merge_sort(&arr[mid..]);

    merge(&left, &right)
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let (mut i, mut j) = (0, 0);

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }

    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

---

### 2. 搜索算法

**线性搜索** - O(n):

```rust
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
    arr.iter().position(|x| x == target)
}
```

**二分搜索** - O(log n):

```rust
fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;

        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }

    None
}
```

---

### 3. Rust 迭代器算法

**使用标准库**:

```rust
// 排序
let mut nums = vec![3, 1, 4, 1, 5, 9, 2, 6];
nums.sort();  // 或 nums.sort_unstable() 更快

// 搜索
let pos = nums.binary_search(&4);  // Ok(2)

// 过滤和映射
let even_squares: Vec<_> = nums.iter()
    .filter(|&&x| x % 2 == 0)
    .map(|&x| x * x)
    .collect();

// 折叠（reduce）
let sum: i32 = nums.iter().sum();
let product: i32 = nums.iter().product();
```

---

## 📐 知识结构

### 概念定义

**算法 (Algorithm)**:

- **定义**: 解决问题的步骤序列，将输入转换为输出
- **类型**: 抽象概念
- **范畴**: 计算机科学
- **相关概念**: 数据结构、复杂度分析、算法设计

**排序算法 (Sorting Algorithm)**:

- **定义**: 将数据按特定顺序排列的算法
- **属性**: 时间复杂度、空间复杂度、稳定性
- **关系**: 与数据结构、搜索算法相关

**搜索算法 (Search Algorithm)**:

- **定义**: 在数据集中查找特定元素的算法
- **属性**: 时间复杂度、空间复杂度、前提条件
- **关系**: 与排序算法、数据结构相关

### 属性特征

**核心属性**:

- **时间复杂度**: 算法执行时间随输入规模增长的趋势
- **空间复杂度**: 算法所需内存空间随输入规模增长的趋势
- **稳定性**: 相等元素的相对顺序是否保持不变
- **适用场景**: 不同算法适用于不同的数据特征和场景

**性能特征**:

- **最好情况**: 最优输入下的性能
- **平均情况**: 随机输入下的平均性能
- **最坏情况**: 最差输入下的性能

### 关系连接

**继承关系**:

- 快速排序 --[is-a]--> 分治算法
- 归并排序 --[is-a]--> 分治算法

**组合关系**:

- 排序算法 --[uses]--> 比较操作
- 搜索算法 --[requires]--> 数据结构

**依赖关系**:

- 二分搜索 --[depends-on]--> 已排序数组
- 插值搜索 --[depends-on]--> 均匀分布数据

### 思维导图

```text
算法快速入门
│
├── 排序算法
│   ├── O(n²) 算法
│   │   ├── 冒泡排序
│   │   ├── 选择排序
│   │   └── 插入排序
│   └── O(n log n) 算法
│       ├── 快速排序
│       ├── 归并排序
│       └── 堆排序
├── 搜索算法
│   ├── 线性搜索
│   ├── 二分搜索
│   └── 插值搜索
└── Rust 特性
    ├── 迭代器
    ├── 泛型
    └── 所有权
```

### 概念矩阵

| 算法类型 | 时间复杂度   | 空间复杂度 | 稳定性    | 适用场景           |
| :--- | :--- | :--- | :--- | :--- |
| 冒泡排序 | O(n²)        | O(1)       | ✅ 稳定   | 小规模数据         |
| 选择排序 | O(n²)        | O(1)       | ❌ 不稳定 | 小规模数据         |
| 插入排序 | O(n²)        | O(1)       | ✅ 稳定   | 部分有序数据       |
| 快速排序 | O(n log n)   | O(log n)   | ❌ 不稳定 | 通用排序           |
| 归并排序 | O(n log n)   | O(n)       | ✅ 稳定   | 需要稳定性         |
| 堆排序   | O(n log n)   | O(1)       | ❌ 不稳定 | 内存受限           |
| 线性搜索 | O(n)         | O(1)       | -         | 未排序数组         |
| 二分搜索 | O(log n)     | O(1)       | -         | 已排序数组         |
| 插值搜索 | O(log log n) | O(1)       | -         | 均匀分布已排序数组 |

---

## 📊 算法复杂度对比

| 算法     | 最好       | 平均       | 最坏       | 空间     | 稳定性    |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 冒泡排序 | O(n)       | O(n²)      | O(n²)      | O(1)     | ✅ 稳定   |
| 选择排序 | O(n²)      | O(n²)      | O(n²)      | O(1)     | ❌ 不稳定 |
| 插入排序 | O(n)       | O(n²)      | O(n²)      | O(1)     | ✅ 稳定   |
| 快速排序 | O(n log n) | O(n log n) | O(n²)      | O(log n) | ❌ 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n)     | ✅ 稳定   |
| 堆排序   | O(n log n) | O(n log n) | O(n log n) | O(1)     | ❌ 不稳定 |

---

## 🎯 实战练习

### 练习 1: 实现选择排序

```rust
fn selection_sort<T: Ord>(arr: &mut [T]) {
    // 实现选择排序
    // 提示：每次找到最小元素并放到已排序部分末尾
    let len = arr.len();
    for i in 0..len {
        let mut min_idx = i;
        // 在未排序部分找到最小元素
        for j in (i + 1)..len {
            if arr[j] < arr[min_idx] {
                min_idx = j;
            }
        }
        // 将最小元素放到已排序部分末尾
        arr.swap(i, min_idx);
    }
}
```

### 练习 2: 插值搜索

```rust
fn interpolation_search(arr: &[i32], target: i32) -> Option<usize> {
    // 实现插值搜索（比二分搜索更快的均匀分布数据）
    if arr.is_empty() {
        return None;
    }

    let mut left = 0;
    let mut right = arr.len() - 1;

    while left <= right && target >= arr[left] && target <= arr[right] {
        if left == right {
            return if arr[left] == target { Some(left) } else { None };
        }

        // 使用插值公式计算位置
        let pos = left + ((target - arr[left]) as usize * (right - left))
            / (arr[right] - arr[left]) as usize;

        if arr[pos] == target {
            return Some(pos);
        } else if arr[pos] < target {
            left = pos + 1;
        } else {
            right = pos - 1;
        }
    }

    None
}
```

### 练习 3: 使用迭代器优化

```rust
// 找出数组中所有大于平均值的元素
fn above_average(nums: &[i32]) -> Vec<i32> {
    // 使用迭代器链实现
    if nums.is_empty() {
        return Vec::new();
    }

    let sum: i32 = nums.iter().sum();
    let avg = sum as f64 / nums.len() as f64;

    nums.iter()
        .filter(|&&x| x as f64 > avg)
        .copied()
        .collect()
}
```

---

## 🔗 相关资源

**内部文档**:

- [数据结构实践](./02_数据结构实践.md) - 下一步学习
- [算法复杂度分析](./03_算法复杂度分析.md) - 深入理解
- [算法复杂度分析](./03_算法复杂度分析.md) - 完整参考

**外部资源**:

- 🌐 [LeetCode](https://leetcode.com/) - 算法练习
- 📘 [算法导论](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- 🦀 [Rust 算法库](https://github.com/TheAlgorithms/Rust)

---

## 📞 获取帮助

- 查阅 [FAQ](../tier_01_foundations/04_常见问题.md)
- 查看 [术语表](../tier_01_foundations/03_术语表.md)

---

**返回**: [Tier 2 索引](./README.md) | **下一步**: [数据结构实践](./02_数据结构实践.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-22
**最后更新**: 2025-10-22
**文档状态**: ✅ 完成
