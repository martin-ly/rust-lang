# 01 ç®—æ³•å¿«é€Ÿå…¥é—¨

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—  
> **ç›®æ ‡è¯»è€…**: ç®—æ³•åˆå­¦è€…  
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 2-3å°æ—¶  
> **å‰ç½®çŸ¥è¯†**: åŸºç¡€ Rust è¯­æ³•

**æœ€åæ›´æ–°**: 2025-10-22  
**é€‚ç”¨ç‰ˆæœ¬**: Rust 1.90+

---

## ğŸ“‹ ç›®å½•

- [01 ç®—æ³•å¿«é€Ÿå…¥é—¨](#01-ç®—æ³•å¿«é€Ÿå…¥é—¨)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“‹ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸš€ æ ¸å¿ƒç®—æ³•é€Ÿè§ˆ](#-æ ¸å¿ƒç®—æ³•é€Ÿè§ˆ)
    - [1. æ’åºç®—æ³•](#1-æ’åºç®—æ³•)
    - [2. æœç´¢ç®—æ³•](#2-æœç´¢ç®—æ³•)
    - [3. Rust è¿­ä»£å™¨ç®—æ³•](#3-rust-è¿­ä»£å™¨ç®—æ³•)
  - [ğŸ“Š ç®—æ³•å¤æ‚åº¦å¯¹æ¯”](#-ç®—æ³•å¤æ‚åº¦å¯¹æ¯”)
  - [ğŸ¯ å®æˆ˜ç»ƒä¹ ](#-å®æˆ˜ç»ƒä¹ )
    - [ç»ƒä¹  1: å®ç°é€‰æ‹©æ’åº](#ç»ƒä¹ -1-å®ç°é€‰æ‹©æ’åº)
    - [ç»ƒä¹  2: æ’å€¼æœç´¢](#ç»ƒä¹ -2-æ’å€¼æœç´¢)
    - [ç»ƒä¹  3: ä½¿ç”¨è¿­ä»£å™¨ä¼˜åŒ–](#ç»ƒä¹ -3-ä½¿ç”¨è¿­ä»£å™¨ä¼˜åŒ–)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
  - [ğŸ“ è·å–å¸®åŠ©](#-è·å–å¸®åŠ©)

## ğŸ“‹ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… å®ç°å¸¸è§æ’åºç®—æ³•ï¼ˆå†’æ³¡ã€å¿«æ’ã€å½’å¹¶ï¼‰
- âœ… æŒæ¡äºŒåˆ†æœç´¢å’Œçº¿æ€§æœç´¢
- âœ… ç†è§£ç®—æ³•æ—¶é—´å¤æ‚åº¦
- âœ… ä½¿ç”¨ Rust ç‰¹æ€§ä¼˜åŒ–ç®—æ³•
- âœ… ç¼–å†™é«˜æ•ˆçš„è¿­ä»£å™¨ç®—æ³•

---

## ğŸš€ æ ¸å¿ƒç®—æ³•é€Ÿè§ˆ

### 1. æ’åºç®—æ³•

**å†’æ³¡æ’åº** - O(nÂ²):

```rust
fn bubble_sort<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
            }
        }
    }
}
```

**å¿«é€Ÿæ’åº** - O(n log n):

```rust
fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    
    let pivot = partition(arr);
    let (left, right) = arr.split_at_mut(pivot);
    
    quick_sort(left);
    quick_sort(&mut right[1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;
    
    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, pivot);
    i
}
```

**å½’å¹¶æ’åº** - O(n log n):

```rust
fn merge_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }
    
    let mid = arr.len() / 2;
    let left = merge_sort(&arr[..mid]);
    let right = merge_sort(&arr[mid..]);
    
    merge(&left, &right)
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let (mut i, mut j) = (0, 0);
    
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }
    
    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

---

### 2. æœç´¢ç®—æ³•

**çº¿æ€§æœç´¢** - O(n):

```rust
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
    arr.iter().position(|x| x == target)
}
```

**äºŒåˆ†æœç´¢** - O(log n):

```rust
fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    
    None
}
```

---

### 3. Rust è¿­ä»£å™¨ç®—æ³•

**ä½¿ç”¨æ ‡å‡†åº“**:

```rust
// æ’åº
let mut nums = vec![3, 1, 4, 1, 5, 9, 2, 6];
nums.sort();  // æˆ– nums.sort_unstable() æ›´å¿«

// æœç´¢
let pos = nums.binary_search(&4);  // Ok(2)

// è¿‡æ»¤å’Œæ˜ å°„
let even_squares: Vec<_> = nums.iter()
    .filter(|&&x| x % 2 == 0)
    .map(|&x| x * x)
    .collect();

// æŠ˜å ï¼ˆreduceï¼‰
let sum: i32 = nums.iter().sum();
let product: i32 = nums.iter().product();
```

---

## ğŸ“Š ç®—æ³•å¤æ‚åº¦å¯¹æ¯”

| ç®—æ³• | æœ€å¥½ | å¹³å‡ | æœ€å | ç©ºé—´ | ç¨³å®šæ€§ |
|------|------|------|------|------|--------|
| å†’æ³¡æ’åº | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… ç¨³å®š |
| é€‰æ‹©æ’åº | O(nÂ²) | O(nÂ²) | O(nÂ²) | O(1) | âŒ ä¸ç¨³å®š |
| æ’å…¥æ’åº | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… ç¨³å®š |
| å¿«é€Ÿæ’åº | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | âŒ ä¸ç¨³å®š |
| å½’å¹¶æ’åº | O(n log n) | O(n log n) | O(n log n) | O(n) | âœ… ç¨³å®š |
| å †æ’åº | O(n log n) | O(n log n) | O(n log n) | O(1) | âŒ ä¸ç¨³å®š |

---

## ğŸ¯ å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹  1: å®ç°é€‰æ‹©æ’åº

```rust
fn selection_sort<T: Ord>(arr: &mut [T]) {
    // TODO: å®ç°é€‰æ‹©æ’åº
    // æç¤ºï¼šæ¯æ¬¡æ‰¾åˆ°æœ€å°å…ƒç´ å¹¶æ”¾åˆ°å·²æ’åºéƒ¨åˆ†æœ«å°¾
}
```

### ç»ƒä¹  2: æ’å€¼æœç´¢

```rust
fn interpolation_search(arr: &[i32], target: i32) -> Option<usize> {
    // TODO: å®ç°æ’å€¼æœç´¢ï¼ˆæ¯”äºŒåˆ†æœç´¢æ›´å¿«çš„å‡åŒ€åˆ†å¸ƒæ•°æ®ï¼‰
}
```

### ç»ƒä¹  3: ä½¿ç”¨è¿­ä»£å™¨ä¼˜åŒ–

```rust
// æ‰¾å‡ºæ•°ç»„ä¸­æ‰€æœ‰å¤§äºå¹³å‡å€¼çš„å…ƒç´ 
fn above_average(nums: &[i32]) -> Vec<i32> {
    // TODO: ä½¿ç”¨è¿­ä»£å™¨é“¾å®ç°
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

**å†…éƒ¨æ–‡æ¡£**:

- [æ•°æ®ç»“æ„å®è·µ](./02_æ•°æ®ç»“æ„å®è·µ.md) - ä¸‹ä¸€æ­¥å­¦ä¹ 
- [ç®—æ³•å¤æ‚åº¦åˆ†æ](./03_ç®—æ³•å¤æ‚åº¦åˆ†æ.md) - æ·±å…¥ç†è§£
- [ç°æœ‰è¯¦ç»†æŒ‡å—](../guides/algorithm_complexity.md) - å®Œæ•´å‚è€ƒ

**å¤–éƒ¨èµ„æº**:

- ğŸŒ [LeetCode](https://leetcode.com/) - ç®—æ³•ç»ƒä¹ 
- ğŸ“˜ [ç®—æ³•å¯¼è®º](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- ğŸ¦€ [Rust ç®—æ³•åº“](https://github.com/TheAlgorithms/Rust)

---

## ğŸ“ è·å–å¸®åŠ©

- æŸ¥é˜… [FAQ](../tier_01_foundations/04_å¸¸è§é—®é¢˜.md)
- æŸ¥çœ‹ [æœ¯è¯­è¡¨](../tier_01_foundations/03_æœ¯è¯­è¡¨.md)

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [æ•°æ®ç»“æ„å®è·µ](./02_æ•°æ®ç»“æ„å®è·µ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
