# 01 算法快速入门

> **文档类型**: Tier 2 - 实践指南  
> **目标读者**: 算法初学者  
> **预计学习时间**: 2-3小时  
> **前置知识**: 基础 Rust 语法

## 📋 目录

- [01 算法快速入门](#01-算法快速入门)
  - [📋 目录](#-目录)
  - [📋 学习目标](#-学习目标)
  - [🚀 核心算法速览](#-核心算法速览)
    - [1. 排序算法](#1-排序算法)
    - [2. 搜索算法](#2-搜索算法)
    - [3. Rust 迭代器算法](#3-rust-迭代器算法)
  - [📊 算法复杂度对比](#-算法复杂度对比)
  - [🎯 实战练习](#-实战练习)
    - [练习 1: 实现选择排序](#练习-1-实现选择排序)
    - [练习 2: 插值搜索](#练习-2-插值搜索)
    - [练习 3: 使用迭代器优化](#练习-3-使用迭代器优化)
  - [🔗 相关资源](#-相关资源)
  - [📞 获取帮助](#-获取帮助)

## 📋 学习目标

完成本指南后，你将能够：

- ✅ 实现常见排序算法（冒泡、快排、归并）
- ✅ 掌握二分搜索和线性搜索
- ✅ 理解算法时间复杂度
- ✅ 使用 Rust 特性优化算法
- ✅ 编写高效的迭代器算法

---

## 🚀 核心算法速览

### 1. 排序算法

**冒泡排序** - O(n²):

```rust
fn bubble_sort<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
            }
        }
    }
}
```

**快速排序** - O(n log n):

```rust
fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    
    let pivot = partition(arr);
    let (left, right) = arr.split_at_mut(pivot);
    
    quick_sort(left);
    quick_sort(&mut right[1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;
    
    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, pivot);
    i
}
```

**归并排序** - O(n log n):

```rust
fn merge_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }
    
    let mid = arr.len() / 2;
    let left = merge_sort(&arr[..mid]);
    let right = merge_sort(&arr[mid..]);
    
    merge(&left, &right)
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let (mut i, mut j) = (0, 0);
    
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }
    
    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

---

### 2. 搜索算法

**线性搜索** - O(n):

```rust
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
    arr.iter().position(|x| x == target)
}
```

**二分搜索** - O(log n):

```rust
fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    
    None
}
```

---

### 3. Rust 迭代器算法

**使用标准库**:

```rust
// 排序
let mut nums = vec![3, 1, 4, 1, 5, 9, 2, 6];
nums.sort();  // 或 nums.sort_unstable() 更快

// 搜索
let pos = nums.binary_search(&4);  // Ok(2)

// 过滤和映射
let even_squares: Vec<_> = nums.iter()
    .filter(|&&x| x % 2 == 0)
    .map(|&x| x * x)
    .collect();

// 折叠（reduce）
let sum: i32 = nums.iter().sum();
let product: i32 = nums.iter().product();
```

---

## 📊 算法复杂度对比

| 算法 | 最好 | 平均 | 最坏 | 空间 | 稳定性 |
|------|------|------|------|------|--------|
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) | ✅ 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | ❌ 不稳定 |
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | ✅ 稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ 稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ 不稳定 |

---

## 🎯 实战练习

### 练习 1: 实现选择排序

```rust
fn selection_sort<T: Ord>(arr: &mut [T]) {
    // TODO: 实现选择排序
    // 提示：每次找到最小元素并放到已排序部分末尾
}
```

### 练习 2: 插值搜索

```rust
fn interpolation_search(arr: &[i32], target: i32) -> Option<usize> {
    // TODO: 实现插值搜索（比二分搜索更快的均匀分布数据）
}
```

### 练习 3: 使用迭代器优化

```rust
// 找出数组中所有大于平均值的元素
fn above_average(nums: &[i32]) -> Vec<i32> {
    // TODO: 使用迭代器链实现
}
```

---

## 🔗 相关资源

**内部文档**:

- [数据结构实践](./02_数据结构实践.md) - 下一步学习
- [算法复杂度分析](./03_算法复杂度分析.md) - 深入理解
- [现有详细指南](../guides/algorithm_complexity.md) - 完整参考

**外部资源**:

- 🌐 [LeetCode](https://leetcode.com/) - 算法练习
- 📘 [算法导论](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- 🦀 [Rust 算法库](https://github.com/TheAlgorithms/Rust)

---

## 📞 获取帮助

- 查阅 [FAQ](../tier_01_foundations/04_常见问题.md)
- 查看 [术语表](../tier_01_foundations/03_术语表.md)

---

**返回**: [Tier 2 索引](./README.md) | **下一步**: [数据结构实践](./02_数据结构实践.md)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-22  
**文档状态**: ✅ 完成
