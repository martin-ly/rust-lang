# 02 æ•°æ®ç»“æ„å®è·µ

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—
> **ç›®æ ‡è¯»è€…**: æ•°æ®ç»“æ„åˆå­¦è€… â†’ è¿›é˜¶è€…
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4å°æ—¶
> **å‰ç½®çŸ¥è¯†**: [ç®—æ³•å¿«é€Ÿå…¥é—¨](./01_ç®—æ³•å¿«é€Ÿå…¥é—¨.md)

## ğŸ“‹ ç›®å½•

- [02 æ•°æ®ç»“æ„å®è·µ](#02-æ•°æ®ç»“æ„å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [æ¦‚å¿µçŸ©é˜µ](#æ¦‚å¿µçŸ©é˜µ)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. çº¿æ€§æ•°æ®ç»“æ„](#1-çº¿æ€§æ•°æ®ç»“æ„)
    - [1.1 Vectorï¼ˆåŠ¨æ€æ•°ç»„ï¼‰](#11-vectoråŠ¨æ€æ•°ç»„)
    - [1.2 VecDequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰](#12-vecdequeåŒç«¯é˜Ÿåˆ—)
    - [1.3 LinkedListï¼ˆé“¾è¡¨ï¼‰](#13-linkedlisté“¾è¡¨)
  - [2. æ ˆä¸é˜Ÿåˆ—](#2-æ ˆä¸é˜Ÿåˆ—)
    - [2.1 æ ˆçš„å®ç°](#21-æ ˆçš„å®ç°)
    - [2.2 é˜Ÿåˆ—çš„å®ç°](#22-é˜Ÿåˆ—çš„å®ç°)
    - [2.3 ä¼˜å…ˆé˜Ÿåˆ—](#23-ä¼˜å…ˆé˜Ÿåˆ—)
  - [3. æ ‘ç»“æ„](#3-æ ‘ç»“æ„)
    - [3.1 äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰](#31-äºŒå‰æœç´¢æ ‘bst)
    - [3.2 å¹³è¡¡æ ‘ï¼ˆAVLï¼‰](#32-å¹³è¡¡æ ‘avl)
    - [3.3 Bæ ‘](#33-bæ ‘)
  - [4. å“ˆå¸Œè¡¨](#4-å“ˆå¸Œè¡¨)
    - [4.1 HashMap åŸç†](#41-hashmap-åŸç†)
    - [4.2 HashSet åº”ç”¨](#42-hashset-åº”ç”¨)
    - [4.3 è‡ªå®šä¹‰å“ˆå¸Œ](#43-è‡ªå®šä¹‰å“ˆå¸Œ)
  - [5. å›¾ç»“æ„](#5-å›¾ç»“æ„)
    - [5.1 å›¾çš„è¡¨ç¤º](#51-å›¾çš„è¡¨ç¤º)
    - [5.2 å›¾çš„éå†](#52-å›¾çš„éå†)
    - [5.3 æœ€çŸ­è·¯å¾„](#53-æœ€çŸ­è·¯å¾„)
  - [6. é«˜çº§æ•°æ®ç»“æ„](#6-é«˜çº§æ•°æ®ç»“æ„)
    - [6.1 è·³è¡¨ï¼ˆSkip Listï¼‰](#61-è·³è¡¨skip-list)
    - [6.2 å¸ƒéš†è¿‡æ»¤å™¨](#62-å¸ƒéš†è¿‡æ»¤å™¨)
    - [6.3 å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰](#63-å¹¶æŸ¥é›†union-find)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: LRU ç¼“å­˜](#æ¡ˆä¾‹-1-lru-ç¼“å­˜)
    - [æ¡ˆä¾‹ 2: å‰ç¼€æ ‘ï¼ˆTrieï¼‰](#æ¡ˆä¾‹-2-å‰ç¼€æ ‘trie)
    - [æ¡ˆä¾‹ 3: æœ€å°å †å®ç°ä»»åŠ¡è°ƒåº¦](#æ¡ˆä¾‹-3-æœ€å°å †å®ç°ä»»åŠ¡è°ƒåº¦)
  - [8. æ€§èƒ½å¯¹æ¯”](#8-æ€§èƒ½å¯¹æ¯”)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ•°æ®ç»“æ„ (Data Structure)**:

- **å®šä¹‰**: æ•°æ®çš„ç»„ç»‡ã€ç®¡ç†å’Œå­˜å‚¨æ ¼å¼ï¼Œç”¨äºé«˜æ•ˆè®¿é—®å’Œä¿®æ”¹æ•°æ®
- **ç±»å‹**: æŠ½è±¡æ¦‚å¿µ
- **èŒƒç•´**: è®¡ç®—æœºç§‘å­¦
- **ç›¸å…³æ¦‚å¿µ**: ç®—æ³•ã€å¤æ‚åº¦åˆ†æã€å†…å­˜å¸ƒå±€

**çº¿æ€§æ•°æ®ç»“æ„**:

- **å®šä¹‰**: æ•°æ®å…ƒç´ æŒ‰çº¿æ€§é¡ºåºæ’åˆ—çš„æ•°æ®ç»“æ„
- **ç±»å‹**: æ•°æ®ç»“æ„ç±»åˆ«
- **å±æ€§**: é¡ºåºè®¿é—®ã€ç´¢å¼•è®¿é—®ã€åŠ¨æ€å¤§å°
- **å…³ç³»**: ä¸æ•°ç»„ã€é“¾è¡¨ã€é˜Ÿåˆ—ç›¸å…³

**æ ‘ç»“æ„**:

- **å®šä¹‰**: å±‚æ¬¡åŒ–çš„æ•°æ®ç»“æ„ï¼Œç”±èŠ‚ç‚¹å’Œè¾¹ç»„æˆ
- **ç±»å‹**: æ•°æ®ç»“æ„ç±»åˆ«
- **å±æ€§**: å±‚æ¬¡å…³ç³»ã€é€’å½’ç»“æ„ã€æœç´¢æ•ˆç‡
- **å…³ç³»**: ä¸å›¾ã€æœç´¢ç®—æ³•ç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **è®¿é—®æ¨¡å¼**: é¡ºåºè®¿é—®ã€éšæœºè®¿é—®ã€å±‚æ¬¡è®¿é—®
- **å­˜å‚¨æ–¹å¼**: è¿ç»­å­˜å‚¨ã€é“¾å¼å­˜å‚¨ã€æ ‘å½¢å­˜å‚¨
- **æ“ä½œå¤æ‚åº¦**: æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦
- **å†…å­˜æ•ˆç‡**: ç©ºé—´å¤æ‚åº¦å’Œå†…å­˜å¸ƒå±€

**æ€§èƒ½ç‰¹å¾**:

- **Vector**: O(1) éšæœºè®¿é—®ï¼ŒO(1) å°¾éƒ¨æ’å…¥
- **HashMap**: O(1) å¹³å‡æŸ¥æ‰¾ï¼ŒO(n) æœ€åæƒ…å†µ
- **Tree**: O(log n) æŸ¥æ‰¾ï¼ŒO(log n) æ’å…¥
- **é€‚ç”¨åœºæ™¯**: ä¸åŒæ•°æ®ç»“æ„é€‚ç”¨äºä¸åŒåœºæ™¯

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- VecDeque --[is-a]--> çº¿æ€§æ•°æ®ç»“æ„
- äºŒå‰æœç´¢æ ‘ --[is-a]--> æ ‘ç»“æ„

**ç»„åˆå…³ç³»**:

- æ•°æ®ç»“æ„ --[uses]--> å†…å­˜åˆ†é…
- ç®—æ³• --[uses]--> æ•°æ®ç»“æ„

**ä¾èµ–å…³ç³»**:

- æ•°æ®ç»“æ„ --[depends-on]--> å†…å­˜ç®¡ç†
- é«˜æ•ˆç®—æ³• --[depends-on]--> åˆé€‚çš„æ•°æ®ç»“æ„

### æ€ç»´å¯¼å›¾

```text
æ•°æ®ç»“æ„å®è·µ
â”‚
â”œâ”€â”€ çº¿æ€§æ•°æ®ç»“æ„
â”‚   â”œâ”€â”€ Vector
â”‚   â”œâ”€â”€ VecDeque
â”‚   â””â”€â”€ LinkedList
â”œâ”€â”€ æ ˆä¸é˜Ÿåˆ—
â”‚   â”œâ”€â”€ æ ˆ
â”‚   â”œâ”€â”€ é˜Ÿåˆ—
â”‚   â””â”€â”€ ä¼˜å…ˆé˜Ÿåˆ—
â”œâ”€â”€ æ ‘ç»“æ„
â”‚   â”œâ”€â”€ äºŒå‰æœç´¢æ ‘
â”‚   â”œâ”€â”€ AVL æ ‘
â”‚   â””â”€â”€ B æ ‘
â”œâ”€â”€ å“ˆå¸Œè¡¨
â”‚   â”œâ”€â”€ HashMap
â”‚   â””â”€â”€ HashSet
â”œâ”€â”€ å›¾ç»“æ„
â”‚   â”œâ”€â”€ é‚»æ¥è¡¨
â”‚   â””â”€â”€ é‚»æ¥çŸ©é˜µ
â””â”€â”€ é«˜çº§æ•°æ®ç»“æ„
    â”œâ”€â”€ è·³è¡¨
    â”œâ”€â”€ å¸ƒéš†è¿‡æ»¤å™¨
    â””â”€â”€ å¹¶æŸ¥é›†
```

### æ¦‚å¿µçŸ©é˜µ

| æ•°æ®ç»“æ„   | è®¿é—®å¤æ‚åº¦ | æ’å…¥å¤æ‚åº¦ | åˆ é™¤å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯     |
| :--- | :--- | :--- | :--- | :--- |
| Vector     | O(1)       | O(1) å°¾éƒ¨  | O(n)       | éšæœºè®¿é—®     |
| VecDeque   | O(1)       | O(1) ä¸¤ç«¯  | O(1) ä¸¤ç«¯  | åŒç«¯æ“ä½œ     |
| LinkedList | O(n)       | O(1)       | O(1)       | é¢‘ç¹æ’å…¥åˆ é™¤ |
| HashMap    | O(1) å¹³å‡  | O(1) å¹³å‡  | O(1) å¹³å‡  | é”®å€¼æŸ¥æ‰¾     |
| äºŒå‰æœç´¢æ ‘ | O(log n)   | O(log n)   | O(log n)   | æœ‰åºæ•°æ®     |
| æ ˆ         | O(1)       | O(1)       | O(1)       | LIFO æ“ä½œ    |
| é˜Ÿåˆ—       | O(1)       | O(1)       | O(1)       | FIFO æ“ä½œ    |

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æŒ‡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… æŒæ¡ Rust æ ‡å‡†åº“ä¸­çš„æ ¸å¿ƒæ•°æ®ç»“æ„
- âœ… å®ç°è‡ªå®šä¹‰æ•°æ®ç»“æ„ï¼ˆæ ˆã€é˜Ÿåˆ—ã€æ ‘ã€å›¾ï¼‰
- âœ… ç†è§£ä¸åŒæ•°æ®ç»“æ„çš„æ—¶é—´ç©ºé—´å¤æ‚åº¦
- âœ… é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„è§£å†³å®é™…é—®é¢˜
- âœ… ä½¿ç”¨ Rust ç‰¹æ€§ä¼˜åŒ–æ•°æ®ç»“æ„æ€§èƒ½

---

## 1. çº¿æ€§æ•°æ®ç»“æ„

### 1.1 Vectorï¼ˆåŠ¨æ€æ•°ç»„ï¼‰

`Vec<T>` æ˜¯ Rust ä¸­æœ€å¸¸ç”¨çš„åŠ¨æ€æ•°ç»„ï¼š

```rust
fn main() {
    // åˆ›å»º
    let mut v: Vec<i32> = Vec::new();
    let v2 = vec![1, 2, 3];  // å®åˆ›å»º

    // æ·»åŠ å…ƒç´ 
    v.push(1);
    v.push(2);
    v.push(3);

    // è®¿é—®
    let first = v[0];  // ç›´æ¥ç´¢å¼•
    let second = v.get(1);  // å®‰å…¨è®¿é—®ï¼Œè¿”å› Option<&T>

    // è¿­ä»£
    for item in &v {
        println!("{}", item);
    }

    // å®¹é‡ç®¡ç†
    let mut v3 = Vec::with_capacity(10);  // é¢„åˆ†é…å®¹é‡
    println!("å®¹é‡: {}", v3.capacity());
    println!("é•¿åº¦: {}", v3.len());
}
```

**æ€§èƒ½ç‰¹æ€§**ï¼š

- ç´¢å¼•è®¿é—®: O(1)
- å°¾éƒ¨æ’å…¥: O(1) æ‘Šé”€
- ä¸­é—´æ’å…¥: O(n)
- æŸ¥æ‰¾: O(n)

### 1.2 VecDequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰

é«˜æ•ˆçš„é¦–å°¾æ“ä½œï¼š

```rust
use std::collections::VecDeque;

fn main() {
    let mut deque = VecDeque::new();

    // ä¸¤ç«¯æ·»åŠ 
    deque.push_back(1);   // å°¾éƒ¨æ·»åŠ 
    deque.push_front(2);  // å¤´éƒ¨æ·»åŠ 

    // ä¸¤ç«¯åˆ é™¤
    let back = deque.pop_back();   // Some(1)
    let front = deque.pop_front(); // Some(2)

    // å®ç°å¾ªç¯ç¼“å†²åŒº
    let mut buffer = VecDeque::with_capacity(5);
    for i in 0..10 {
        buffer.push_back(i);
        if buffer.len() > 5 {
            buffer.pop_front();
        }
    }
    println!("æœ€è¿‘5ä¸ªå…ƒç´ : {:?}", buffer);
}
```

**æ€§èƒ½ç‰¹æ€§**ï¼š

- é¦–å°¾æ’å…¥/åˆ é™¤: O(1)
- ä¸­é—´æ’å…¥/åˆ é™¤: O(n)
- ç´¢å¼•è®¿é—®: O(1)

### 1.3 LinkedListï¼ˆé“¾è¡¨ï¼‰

åŒå‘é“¾è¡¨å®ç°ï¼š

```rust
use std::collections::LinkedList;

fn main() {
    let mut list = LinkedList::new();

    list.push_back(1);
    list.push_back(2);
    list.push_front(0);

    // è¿­ä»£
    for item in &list {
        println!("{}", item);
    }

    // åˆ†å‰²å’Œåˆå¹¶
    let mut list2 = list.split_off(2);  // ä»ç¬¬2ä¸ªä½ç½®åˆ†å‰²
    list.append(&mut list2);  // åˆå¹¶
}
```

**ä½•æ—¶ä½¿ç”¨**ï¼š

- âœ… éœ€è¦é¢‘ç¹åœ¨ä¸­é—´æ’å…¥/åˆ é™¤
- âŒ éœ€è¦éšæœºè®¿é—®ï¼ˆæ”¹ç”¨ Vecï¼‰
- âŒ å…³æ³¨ç¼“å­˜å±€éƒ¨æ€§ï¼ˆæ”¹ç”¨ Vecï¼‰

---

## 2. æ ˆä¸é˜Ÿåˆ—

### 2.1 æ ˆçš„å®ç°

ä½¿ç”¨ Vec å®ç°æ ˆï¼š

```rust
struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { items: Vec::new() }
    }

    fn push(&mut self, item: T) {
        self.items.push(item);
    }

    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }

    fn peek(&self) -> Option<&T> {
        self.items.last()
    }

    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }

    fn len(&self) -> usize {
        self.items.len()
    }
}

fn main() {
    let mut stack = Stack::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(item) = stack.pop() {
        println!("{}", item);  // 3, 2, 1
    }
}
```

**ç»å…¸åº”ç”¨ - æ‹¬å·åŒ¹é…**ï¼š

```rust
fn is_valid_parentheses(s: &str) -> bool {
    let mut stack = Vec::new();

    for ch in s.chars() {
        match ch {
            '(' | '[' | '{' => stack.push(ch),
            ')' => if stack.pop() != Some('(') { return false; },
            ']' => if stack.pop() != Some('[') { return false; },
            '}' => if stack.pop() != Some('{') { return false; },
            _ => {}
        }
    }

    stack.is_empty()
}

fn main() {
    assert!(is_valid_parentheses("()[]{}"));
    assert!(!is_valid_parentheses("([)]"));
}
```

### 2.2 é˜Ÿåˆ—çš„å®ç°

ä½¿ç”¨ VecDeque å®ç°é˜Ÿåˆ—ï¼š

```rust
use std::collections::VecDeque;

struct Queue<T> {
    items: VecDeque<T>,
}

impl<T> Queue<T> {
    fn new() -> Self {
        Queue { items: VecDeque::new() }
    }

    fn enqueue(&mut self, item: T) {
        self.items.push_back(item);
    }

    fn dequeue(&mut self) -> Option<T> {
        self.items.pop_front()
    }

    fn peek(&self) -> Option<&T> {
        self.items.front()
    }

    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
}

fn main() {
    let mut queue = Queue::new();

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    while let Some(item) = queue.dequeue() {
        println!("{}", item);  // 1, 2, 3
    }
}
```

### 2.3 ä¼˜å…ˆé˜Ÿåˆ—

ä½¿ç”¨ BinaryHeapï¼š

```rust
use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn main() {
    // æœ€å¤§å †ï¼ˆé»˜è®¤ï¼‰
    let mut max_heap = BinaryHeap::new();
    max_heap.push(3);
    max_heap.push(1);
    max_heap.push(4);

    while let Some(item) = max_heap.pop() {
        println!("{}", item);  // 4, 3, 1
    }

    // æœ€å°å †
    let mut min_heap = BinaryHeap::new();
    min_heap.push(Reverse(3));
    min_heap.push(Reverse(1));
    min_heap.push(Reverse(4));

    while let Some(Reverse(item)) = min_heap.pop() {
        println!("{}", item);  // 1, 3, 4
    }
}
```

---

## 3. æ ‘ç»“æ„

### 3.1 äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰

åŸºæœ¬å®ç°ï¼š

```rust
#[derive(Debug)]
struct TreeNode {
    val: i32,
    left: Option<Box<TreeNode>>,
    right: Option<Box<TreeNode>>,
}

impl TreeNode {
    fn new(val: i32) -> Self {
        TreeNode {
            val,
            left: None,
            right: None,
        }
    }
}

struct BST {
    root: Option<Box<TreeNode>>,
}

impl BST {
    fn new() -> Self {
        BST { root: None }
    }

    fn insert(&mut self, val: i32) {
        self.root = Self::insert_recursive(self.root.take(), val);
    }

    fn insert_recursive(node: Option<Box<TreeNode>>, val: i32) -> Option<Box<TreeNode>> {
        match node {
            None => Some(Box::new(TreeNode::new(val))),
            Some(mut node) => {
                if val < node.val {
                    node.left = Self::insert_recursive(node.left.take(), val);
                } else if val > node.val {
                    node.right = Self::insert_recursive(node.right.take(), val);
                }
                Some(node)
            }
        }
    }

    fn search(&self, val: i32) -> bool {
        Self::search_recursive(&self.root, val)
    }

    fn search_recursive(node: &Option<Box<TreeNode>>, val: i32) -> bool {
        match node {
            None => false,
            Some(node) => {
                if val == node.val {
                    true
                } else if val < node.val {
                    Self::search_recursive(&node.left, val)
                } else {
                    Self::search_recursive(&node.right, val)
                }
            }
        }
    }

    fn inorder_traversal(&self) -> Vec<i32> {
        let mut result = Vec::new();
        Self::inorder(&self.root, &mut result);
        result
    }

    fn inorder(node: &Option<Box<TreeNode>>, result: &mut Vec<i32>) {
        if let Some(node) = node {
            Self::inorder(&node.left, result);
            result.push(node.val);
            Self::inorder(&node.right, result);
        }
    }
}

fn main() {
    let mut bst = BST::new();

    bst.insert(5);
    bst.insert(3);
    bst.insert(7);
    bst.insert(1);
    bst.insert(9);

    assert!(bst.search(7));
    assert!(!bst.search(4));

    println!("ä¸­åºéå†: {:?}", bst.inorder_traversal());  // [1, 3, 5, 7, 9]
}
```

### 3.2 å¹³è¡¡æ ‘ï¼ˆAVLï¼‰

AVL æ ‘çš„é«˜åº¦å¹³è¡¡ï¼š

```rust
#[derive(Debug)]
struct AVLNode {
    val: i32,
    height: i32,
    left: Option<Box<AVLNode>>,
    right: Option<Box<AVLNode>>,
}

impl AVLNode {
    fn new(val: i32) -> Self {
        AVLNode {
            val,
            height: 1,
            left: None,
            right: None,
        }
    }

    fn height(node: &Option<Box<AVLNode>>) -> i32 {
        node.as_ref().map_or(0, |n| n.height)
    }

    fn update_height(node: &mut AVLNode) {
        node.height = 1 + Self::height(&node.left).max(Self::height(&node.right));
    }

    fn balance_factor(node: &AVLNode) -> i32 {
        Self::height(&node.left) - Self::height(&node.right)
    }

    fn rotate_left(mut node: Box<AVLNode>) -> Box<AVLNode> {
        let mut new_root = node.right.take().unwrap();
        node.right = new_root.left.take();
        Self::update_height(&mut node);
        new_root.left = Some(node);
        Self::update_height(&mut new_root);
        new_root
    }

    fn rotate_right(mut node: Box<AVLNode>) -> Box<AVLNode> {
        let mut new_root = node.left.take().unwrap();
        node.left = new_root.right.take();
        Self::update_height(&mut node);
        new_root.right = Some(node);
        Self::update_height(&mut new_root);
        new_root
    }
}
```

### 3.3 Bæ ‘

ä½¿ç”¨æ ‡å‡†åº“ BTreeMap/BTreeSetï¼š

```rust
use std::collections::BTreeMap;

fn main() {
    let mut btree = BTreeMap::new();

    btree.insert(5, "five");
    btree.insert(2, "two");
    btree.insert(8, "eight");
    btree.insert(1, "one");

    // æœ‰åºè¿­ä»£
    for (key, value) in &btree {
        println!("{}: {}", key, value);
    }

    // èŒƒå›´æŸ¥è¯¢
    for (key, value) in btree.range(2..=5) {
        println!("èŒƒå›´å†…: {}: {}", key, value);
    }
}
```

---

## 4. å“ˆå¸Œè¡¨

### 4.1 HashMap åŸç†

åŸºæœ¬æ“ä½œï¼š

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();

    // æ’å…¥
    map.insert("apple", 3);
    map.insert("banana", 2);

    // è®¿é—®
    if let Some(&count) = map.get("apple") {
        println!("apples: {}", count);
    }

    // æ›´æ–°
    *map.entry("apple").or_insert(0) += 1;

    // åˆ é™¤
    map.remove("banana");

    // è¿­ä»£
    for (key, value) in &map {
        println!("{}: {}", key, value);
    }
}
```

**åº”ç”¨ - è®¡æ•°å™¨**ï¼š

```rust
use std::collections::HashMap;

fn count_words(text: &str) -> HashMap<String, usize> {
    let mut counts = HashMap::new();

    for word in text.split_whitespace() {
        *counts.entry(word.to_string()).or_insert(0) += 1;
    }

    counts
}

fn main() {
    let text = "hello world hello rust world";
    let counts = count_words(text);

    for (word, count) in counts {
        println!("{}: {}", word, count);
    }
}
```

### 4.2 HashSet åº”ç”¨

å»é‡å’ŒæŸ¥æ‰¾ï¼š

```rust
use std::collections::HashSet;

fn main() {
    let mut set = HashSet::new();

    set.insert(1);
    set.insert(2);
    set.insert(1);  // é‡å¤å…ƒç´ ä¸ä¼šè¢«æ·»åŠ 

    assert!(set.contains(&1));
    assert_eq!(set.len(), 2);

    // é›†åˆæ“ä½œ
    let set1: HashSet<_> = [1, 2, 3].iter().collect();
    let set2: HashSet<_> = [2, 3, 4].iter().collect();

    let union: HashSet<_> = set1.union(&set2).collect();
    let intersection: HashSet<_> = set1.intersection(&set2).collect();
    let difference: HashSet<_> = set1.difference(&set2).collect();

    println!("å¹¶é›†: {:?}", union);
    println!("äº¤é›†: {:?}", intersection);
    println!("å·®é›†: {:?}", difference);
}
```

### 4.3 è‡ªå®šä¹‰å“ˆå¸Œ

å®ç°è‡ªå®šä¹‰ Hashï¼š

```rust
use std::collections::HashMap;
use std::hash::{Hash, Hasher};

#[derive(Debug, Eq)]
struct Point {
    x: i32,
    y: i32,
}

impl PartialEq for Point {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

impl Hash for Point {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.x.hash(state);
        self.y.hash(state);
    }
}

fn main() {
    let mut map = HashMap::new();
    map.insert(Point { x: 1, y: 2 }, "A");
    map.insert(Point { x: 3, y: 4 }, "B");

    if let Some(value) = map.get(&Point { x: 1, y: 2 }) {
        println!("Found: {}", value);
    }
}
```

---

## 5. å›¾ç»“æ„

### 5.1 å›¾çš„è¡¨ç¤º

é‚»æ¥è¡¨è¡¨ç¤ºï¼š

```rust
use std::collections::{HashMap, HashSet};

struct Graph {
    adj_list: HashMap<i32, Vec<i32>>,
}

impl Graph {
    fn new() -> Self {
        Graph {
            adj_list: HashMap::new(),
        }
    }

    fn add_edge(&mut self, u: i32, v: i32) {
        self.adj_list.entry(u).or_insert(Vec::new()).push(v);
        self.adj_list.entry(v).or_insert(Vec::new()).push(u);  // æ— å‘å›¾
    }

    fn neighbors(&self, node: i32) -> &[i32] {
        self.adj_list.get(&node).map_or(&[], |v| v.as_slice())
    }
}

fn main() {
    let mut graph = Graph::new();

    graph.add_edge(1, 2);
    graph.add_edge(1, 3);
    graph.add_edge(2, 3);

    println!("èŠ‚ç‚¹1çš„é‚»å±…: {:?}", graph.neighbors(1));
}
```

### 5.2 å›¾çš„éå†

**æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰**ï¼š

```rust
use std::collections::{HashMap, HashSet};

fn dfs(
    graph: &HashMap<i32, Vec<i32>>,
    node: i32,
    visited: &mut HashSet<i32>,
    result: &mut Vec<i32>,
) {
    if visited.contains(&node) {
        return;
    }

    visited.insert(node);
    result.push(node);

    if let Some(neighbors) = graph.get(&node) {
        for &neighbor in neighbors {
            dfs(graph, neighbor, visited, result);
        }
    }
}

fn main() {
    let mut graph = HashMap::new();
    graph.insert(1, vec![2, 3]);
    graph.insert(2, vec![4]);
    graph.insert(3, vec![4]);
    graph.insert(4, vec![]);

    let mut visited = HashSet::new();
    let mut result = Vec::new();

    dfs(&graph, 1, &mut visited, &mut result);
    println!("DFS éå†: {:?}", result);
}
```

**å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**ï¼š

```rust
use std::collections::{HashMap, HashSet, VecDeque};

fn bfs(graph: &HashMap<i32, Vec<i32>>, start: i32) -> Vec<i32> {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    let mut result = Vec::new();

    queue.push_back(start);
    visited.insert(start);

    while let Some(node) = queue.pop_front() {
        result.push(node);

        if let Some(neighbors) = graph.get(&node) {
            for &neighbor in neighbors {
                if !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    queue.push_back(neighbor);
                }
            }
        }
    }

    result
}

fn main() {
    let mut graph = HashMap::new();
    graph.insert(1, vec![2, 3]);
    graph.insert(2, vec![4]);
    graph.insert(3, vec![4]);
    graph.insert(4, vec![]);

    let result = bfs(&graph, 1);
    println!("BFS éå†: {:?}", result);
}
```

### 5.3 æœ€çŸ­è·¯å¾„

Dijkstra ç®—æ³•ï¼š

```rust
use std::collections::{BinaryHeap, HashMap};
use std::cmp::Reverse;

fn dijkstra(graph: &HashMap<i32, Vec<(i32, usize)>>, start: i32) -> HashMap<i32, usize> {
    let mut dist = HashMap::new();
    let mut heap = BinaryHeap::new();

    dist.insert(start, 0);
    heap.push(Reverse((0, start)));

    while let Some(Reverse((cost, node))) = heap.pop() {
        if cost > *dist.get(&node).unwrap_or(&usize::MAX) {
            continue;
        }

        if let Some(neighbors) = graph.get(&node) {
            for &(next, weight) in neighbors {
                let new_cost = cost + weight;
                if new_cost < *dist.get(&next).unwrap_or(&usize::MAX) {
                    dist.insert(next, new_cost);
                    heap.push(Reverse((new_cost, next)));
                }
            }
        }
    }

    dist
}

fn main() {
    let mut graph = HashMap::new();
    graph.insert(1, vec![(2, 4), (3, 2)]);
    graph.insert(2, vec![(4, 5)]);
    graph.insert(3, vec![(2, 1), (4, 8)]);
    graph.insert(4, vec![]);

    let distances = dijkstra(&graph, 1);

    for (node, dist) in distances {
        println!("åˆ°èŠ‚ç‚¹ {} çš„æœ€çŸ­è·ç¦»: {}", node, dist);
    }
}
```

---

## 6. é«˜çº§æ•°æ®ç»“æ„

### 6.1 è·³è¡¨ï¼ˆSkip Listï¼‰

ç®€åŒ–å®ç°ï¼š

```rust
struct SkipNode {
    value: i32,
    next: Vec<Option<Box<SkipNode>>>,
}

struct SkipList {
    head: SkipNode,
    max_level: usize,
}

impl SkipList {
    fn new(max_level: usize) -> Self {
        SkipList {
            head: SkipNode {
                value: i32::MIN,
                next: vec![None; max_level],
            },
            max_level,
        }
    }

    fn search(&self, target: i32) -> bool {
        let mut current = &self.head;

        for level in (0..self.max_level).rev() {
            while let Some(ref next_node) = current.next[level] {
                if next_node.value < target {
                    current = next_node;
                } else {
                    break;
                }
            }
        }

        current.next[0]
            .as_ref()
            .map_or(false, |node| node.value == target)
    }
}
```

### 6.2 å¸ƒéš†è¿‡æ»¤å™¨

æ¦‚ç‡æ•°æ®ç»“æ„ï¼š

```rust
use std::hash::{Hash, Hasher};
use std::collections::hash_map::DefaultHasher;

struct BloomFilter {
    bits: Vec<bool>,
    hash_count: usize,
}

impl BloomFilter {
    fn new(size: usize, hash_count: usize) -> Self {
        BloomFilter {
            bits: vec![false; size],
            hash_count,
        }
    }

    fn insert<T: Hash>(&mut self, item: &T) {
        for i in 0..self.hash_count {
            let hash = self.hash(item, i);
            let index = hash % self.bits.len();
            self.bits[index] = true;
        }
    }

    fn might_contain<T: Hash>(&self, item: &T) -> bool {
        for i in 0..self.hash_count {
            let hash = self.hash(item, i);
            let index = hash % self.bits.len();
            if !self.bits[index] {
                return false;
            }
        }
        true
    }

    fn hash<T: Hash>(&self, item: &T, seed: usize) -> usize {
        let mut hasher = DefaultHasher::new();
        item.hash(&mut hasher);
        seed.hash(&mut hasher);
        hasher.finish() as usize
    }
}

fn main() {
    let mut filter = BloomFilter::new(1000, 3);

    filter.insert(&"hello");
    filter.insert(&"world");

    assert!(filter.might_contain(&"hello"));
    assert!(!filter.might_contain(&"foo"));  // å¯èƒ½å‡é˜³æ€§
}
```

### 6.3 å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰

ç”¨äºåŠ¨æ€è¿é€šæ€§ï¼š

```rust
struct UnionFind {
    parent: Vec<usize>,
    rank: Vec<usize>,
}

impl UnionFind {
    fn new(size: usize) -> Self {
        UnionFind {
            parent: (0..size).collect(),
            rank: vec![0; size],
        }
    }

    fn find(&mut self, x: usize) -> usize {
        if self.parent[x] != x {
            self.parent[x] = self.find(self.parent[x]);  // è·¯å¾„å‹ç¼©
        }
        self.parent[x]
    }

    fn union(&mut self, x: usize, y: usize) -> bool {
        let root_x = self.find(x);
        let root_y = self.find(y);

        if root_x == root_y {
            return false;  // å·²ç»åœ¨åŒä¸€é›†åˆ
        }

        // æŒ‰ç§©åˆå¹¶
        if self.rank[root_x] < self.rank[root_y] {
            self.parent[root_x] = root_y;
        } else if self.rank[root_x] > self.rank[root_y] {
            self.parent[root_y] = root_x;
        } else {
            self.parent[root_y] = root_x;
            self.rank[root_x] += 1;
        }

        true
    }

    fn connected(&mut self, x: usize, y: usize) -> bool {
        self.find(x) == self.find(y)
    }
}

fn main() {
    let mut uf = UnionFind::new(5);

    uf.union(0, 1);
    uf.union(1, 2);
    uf.union(3, 4);

    assert!(uf.connected(0, 2));
    assert!(!uf.connected(0, 3));
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: LRU ç¼“å­˜

ä½¿ç”¨ HashMap + VecDequeï¼š

```rust
use std::collections::{HashMap, VecDeque};

struct LRUCache {
    capacity: usize,
    cache: HashMap<i32, i32>,
    order: VecDeque<i32>,
}

impl LRUCache {
    fn new(capacity: usize) -> Self {
        LRUCache {
            capacity,
            cache: HashMap::new(),
            order: VecDeque::new(),
        }
    }

    fn get(&mut self, key: i32) -> Option<i32> {
        if let Some(&value) = self.cache.get(&key) {
            // ç§»åŠ¨åˆ°æœ€å‰é¢
            self.order.retain(|&k| k != key);
            self.order.push_front(key);
            Some(value)
        } else {
            None
        }
    }

    fn put(&mut self, key: i32, value: i32) {
        if self.cache.contains_key(&key) {
            self.cache.insert(key, value);
            self.order.retain(|&k| k != key);
            self.order.push_front(key);
        } else {
            if self.cache.len() >= self.capacity {
                if let Some(oldest) = self.order.pop_back() {
                    self.cache.remove(&oldest);
                }
            }
            self.cache.insert(key, value);
            self.order.push_front(key);
        }
    }
}

fn main() {
    let mut cache = LRUCache::new(2);

    cache.put(1, 1);
    cache.put(2, 2);
    assert_eq!(cache.get(1), Some(1));
    cache.put(3, 3);  // æ·˜æ±°é”® 2
    assert_eq!(cache.get(2), None);
}
```

### æ¡ˆä¾‹ 2: å‰ç¼€æ ‘ï¼ˆTrieï¼‰

å­—ç¬¦ä¸²å¿«é€ŸæŸ¥æ‰¾ï¼š

```rust
use std::collections::HashMap;

#[derive(Default)]
struct TrieNode {
    children: HashMap<char, Box<TrieNode>>,
    is_end: bool,
}

struct Trie {
    root: TrieNode,
}

impl Trie {
    fn new() -> Self {
        Trie {
            root: TrieNode::default(),
        }
    }

    fn insert(&mut self, word: &str) {
        let mut node = &mut self.root;

        for ch in word.chars() {
            node = node.children
                .entry(ch)
                .or_insert_with(|| Box::new(TrieNode::default()));
        }

        node.is_end = true;
    }

    fn search(&self, word: &str) -> bool {
        let mut node = &self.root;

        for ch in word.chars() {
            match node.children.get(&ch) {
                Some(next_node) => node = next_node,
                None => return false,
            }
        }

        node.is_end
    }

    fn starts_with(&self, prefix: &str) -> bool {
        let mut node = &self.root;

        for ch in prefix.chars() {
            match node.children.get(&ch) {
                Some(next_node) => node = next_node,
                None => return false,
            }
        }

        true
    }
}

fn main() {
    let mut trie = Trie::new();

    trie.insert("apple");
    trie.insert("app");

    assert!(trie.search("apple"));
    assert!(!trie.search("appl"));
    assert!(trie.starts_with("app"));
}
```

### æ¡ˆä¾‹ 3: æœ€å°å †å®ç°ä»»åŠ¡è°ƒåº¦

```rust
use std::collections::BinaryHeap;
use std::cmp::Reverse;

#[derive(Eq, PartialEq, Debug)]
struct Task {
    priority: i32,
    id: usize,
}

impl Ord for Task {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.priority.cmp(&other.priority)
    }
}

impl PartialOrd for Task {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

struct TaskScheduler {
    tasks: BinaryHeap<Reverse<Task>>,
}

impl TaskScheduler {
    fn new() -> Self {
        TaskScheduler {
            tasks: BinaryHeap::new(),
        }
    }

    fn add_task(&mut self, priority: i32, id: usize) {
        self.tasks.push(Reverse(Task { priority, id }));
    }

    fn execute_next(&mut self) -> Option<usize> {
        self.tasks.pop().map(|Reverse(task)| task.id)
    }
}

fn main() {
    let mut scheduler = TaskScheduler::new();

    scheduler.add_task(3, 1);
    scheduler.add_task(1, 2);
    scheduler.add_task(2, 3);

    // æŒ‰ä¼˜å…ˆçº§æ‰§è¡Œ
    while let Some(task_id) = scheduler.execute_next() {
        println!("æ‰§è¡Œä»»åŠ¡: {}", task_id);
    }
}
```

---

## 8. æ€§èƒ½å¯¹æ¯”

| æ•°æ®ç»“æ„   | è®¿é—®       | æœç´¢     | æ’å…¥     | åˆ é™¤     | ç©ºé—´ |
| :--- | :--- | :--- | :--- | :--- | :--- |
| Vec        | O(1)       | O(n)     | O(n)     | O(n)     | O(n) |
| VecDeque   | O(1)       | O(n)     | O(1)\*   | O(1)\*   | O(n) |
| LinkedList | O(n)       | O(n)     | O(1)\*   | O(1)\*   | O(n) |
| HashMap    | -          | O(1)\*\* | O(1)\*\* | O(1)\*\* | O(n) |
| BTreeMap   | -          | O(log n) | O(log n) | O(log n) | O(n) |
| BinaryHeap | O(1)\*\*\* | O(n)     | O(log n) | O(log n) | O(n) |

\* é¦–å°¾æ“ä½œ
\*\* å¹³å‡æƒ…å†µ
\*\*\* ä»…æœ€å¤§/æœ€å°å…ƒç´ 

---

## 9. æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„**:
   - âœ… é»˜è®¤ä½¿ç”¨ `Vec`ï¼ˆç¼“å­˜å‹å¥½ï¼‰
   - âœ… éœ€è¦åŒç«¯æ“ä½œç”¨ `VecDeque`
   - âœ… éœ€è¦å¿«é€ŸæŸ¥æ‰¾ç”¨ `HashMap`
   - âœ… éœ€è¦æœ‰åºè¿­ä»£ç”¨ `BTreeMap`

2. **æ€§èƒ½ä¼˜åŒ–**:
   - âœ… ä½¿ç”¨ `with_capacity` é¢„åˆ†é…
   - âœ… é¿å…ä¸å¿…è¦çš„å…‹éš†
   - âœ… ä½¿ç”¨ `entry` API é¿å…åŒé‡æŸ¥æ‰¾

3. **å†…å­˜ç®¡ç†**:
   - âœ… åŠæ—¶æ¸…ç†ä¸ç”¨çš„æ•°æ®
   - âœ… ä½¿ç”¨ `shrink_to_fit` é‡Šæ”¾å¤šä½™å®¹é‡

4. **é¿å…å¸¸è§é™·é˜±**:
   - âŒ ä¸è¦åœ¨ HashMap ä¸­ä½¿ç”¨æµ®ç‚¹æ•°ä½œä¸ºé”®
   - âŒ é¿å…åœ¨ Vec ä¸­é—´é¢‘ç¹æ’å…¥åˆ é™¤
   - âŒ æ³¨æ„é“¾è¡¨çš„ç¼“å­˜å±€éƒ¨æ€§é—®é¢˜

---

## ğŸ”— ç›¸å…³èµ„æº

**å†…éƒ¨æ–‡æ¡£**:

- [ç®—æ³•å¿«é€Ÿå…¥é—¨](./01_ç®—æ³•å¿«é€Ÿå…¥é—¨.md) - å‰ç½®å†…å®¹
- [ç®—æ³•å¤æ‚åº¦åˆ†æ](./03_ç®—æ³•å¤æ‚åº¦åˆ†æ.md) - æ·±å…¥ç†è§£
- [æ€§èƒ½ä¼˜åŒ–å®è·µ](./04_æ€§èƒ½ä¼˜åŒ–å®è·µ.md) - ä¼˜åŒ–æŠ€å·§

**å¤–éƒ¨èµ„æº**:

- ğŸ¦€ [Rust æ ‡å‡†åº“æ–‡æ¡£](https://doc.rust-lang.org/std/collections/)
- ğŸ“˜ [æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ](https://www.coursera.org/specializations/data-structures-algorithms)
- ğŸŒ [VisuAlgo](https://visualgo.net/) - æ•°æ®ç»“æ„å¯è§†åŒ–

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [ç®—æ³•å¤æ‚åº¦åˆ†æ](./03_ç®—æ³•å¤æ‚åº¦åˆ†æ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23
**æœ€åæ›´æ–°**: 2025-10-23
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
