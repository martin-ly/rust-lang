# 05 并行与异步算法

> **文档类型**: Tier 2 - 实践指南  
> **目标读者**: 需要提升算法性能的开发者  
> **预计学习时间**: 3-4小时  
> **前置知识**: [性能优化实践](./04_性能优化实践.md)

## 📋 目录

- [05 并行与异步算法](#05-并行与异步算法)
  - [📋 目录](#-目录)
  - [🎯 学习目标](#-学习目标)
  - [1. Rayon 数据并行](#1-rayon-数据并行)
    - [1.1 基本并行迭代器](#11-基本并行迭代器)
    - [1.2 并行排序](#12-并行排序)
    - [1.3 并行搜索](#13-并行搜索)
  - [2. 任务并行模式](#2-任务并行模式)
    - [2.1 fork-join 模式](#21-fork-join-模式)
    - [2.2 分治算法](#22-分治算法)
    - [2.3 并行管道](#23-并行管道)
  - [3. 异步算法基础](#3-异步算法基础)
    - [3.1 Tokio 异步运行时](#31-tokio-异步运行时)
    - [3.2 异步流处理](#32-异步流处理)
    - [3.3 并发控制](#33-并发控制)
  - [4. 并发数据结构](#4-并发数据结构)
    - [4.1 原子操作](#41-原子操作)
    - [4.2 并发 HashMap](#42-并发-hashmap)
    - [4.3 无锁队列](#43-无锁队列)
  - [5. 并行算法模式](#5-并行算法模式)
    - [5.1 Map-Reduce](#51-map-reduce)
    - [5.2 分区并行](#52-分区并行)
  - [6. 异步 IO 算法](#6-异步-io-算法)
    - [6.1 并发文件读取](#61-并发文件读取)
    - [6.2 异步网络请求](#62-异步网络请求)
  - [7. 性能权衡](#7-性能权衡)
    - [7.1 串行 vs 并行阈值](#71-串行-vs-并行阈值)
    - [7.2 开销测量](#72-开销测量)
  - [8. 实战案例](#8-实战案例)
    - [案例 1: 并行图像处理](#案例-1-并行图像处理)
    - [案例 2: 并行矩阵乘法](#案例-2-并行矩阵乘法)
    - [案例 3: 并行 Web 爬虫](#案例-3-并行-web-爬虫)
  - [🔗 相关资源](#-相关资源)

---

## 🎯 学习目标

- ✅ 掌握 Rayon 数据并行编程
- ✅ 理解任务并行 vs 数据并行
- ✅ 使用 Tokio 实现异步算法
- ✅ 选择合适的并发数据结构
- ✅ 避免常见并行编程陷阱
- ✅ 测量并行算法的加速比

---

## 1. Rayon 数据并行

### 1.1 基本并行迭代器

```rust
use rayon::prelude::*;

// 串行求和
fn sum_serial(data: &[i32]) -> i32 {
    data.iter().sum()
}

// 并行求和
fn sum_parallel(data: &[i32]) -> i32 {
    data.par_iter().sum()
}

// 并行 map
fn square_all_parallel(data: &[i32]) -> Vec<i32> {
    data.par_iter()
        .map(|&x| x * x)
        .collect()
}

// 并行 filter
fn filter_even_parallel(data: &[i32]) -> Vec<i32> {
    data.par_iter()
        .filter(|&&x| x % 2 == 0)
        .copied()
        .collect()
}
```

### 1.2 并行排序

```rust
use rayon::prelude::*;

fn parallel_sort_example() {
    let mut data = vec![5, 3, 8, 1, 9, 2, 7, 4, 6];
    
    // 并行排序
    data.par_sort_unstable();
    
    println!("{:?}", data);
}

// 自定义并行排序
fn parallel_quicksort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    
    let pivot = partition(arr);
    let (left, right) = arr.split_at_mut(pivot);
    
    // 并行处理左右两部分
    rayon::join(
        || parallel_quicksort(left),
        || parallel_quicksort(&mut right[1..]),
    );
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;
    
    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, pivot);
    i
}
```

### 1.3 并行搜索

```rust
use rayon::prelude::*;

// 并行查找
fn parallel_find(data: &[i32], target: i32) -> Option<usize> {
    data.par_iter()
        .position_any(|&x| x == target)
}

// 并行最大值
fn parallel_max(data: &[i32]) -> Option<i32> {
    data.par_iter()
        .copied()
        .max()
}

// 并行归约
fn parallel_reduce(data: &[i32]) -> i32 {
    data.par_iter()
        .copied()
        .reduce(|| 0, |a, b| a + b)
}
```

---

## 2. 任务并行模式

### 2.1 fork-join 模式

```rust
use rayon::prelude::*;

// 计算斐波那契数（任务并行）
fn fibonacci_parallel(n: u32) -> u64 {
    if n <= 1 {
        return n as u64;
    }
    
    if n < 20 {  // 小问题直接计算
        return fibonacci_serial(n);
    }
    
    // 大问题并行分解
    let (a, b) = rayon::join(
        || fibonacci_parallel(n - 1),
        || fibonacci_parallel(n - 2),
    );
    
    a + b
}

fn fibonacci_serial(n: u32) -> u64 {
    let (mut a, mut b) = (0, 1);
    for _ in 0..n {
        let temp = a;
        a = b;
        b = temp + b;
    }
    a
}
```

### 2.2 分治算法

```rust
// 并行归并排序
fn parallel_merge_sort<T: Ord + Clone + Send>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1000 {
        // 小数组串行处理
        let mut result = arr.to_vec();
        result.sort_unstable();
        return result;
    }
    
    let mid = arr.len() / 2;
    let (left, right) = arr.split_at(mid);
    
    // 并行处理两部分
    let (left_sorted, right_sorted) = rayon::join(
        || parallel_merge_sort(left),
        || parallel_merge_sort(right),
    );
    
    merge(&left_sorted, &right_sorted)
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let (mut i, mut j) = (0, 0);
    
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }
    
    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

### 2.3 并行管道

```rust
use rayon::prelude::*;

// 多阶段并行处理
fn parallel_pipeline(data: Vec<String>) -> Vec<String> {
    data.into_par_iter()
        .map(|s| stage1_parse(&s))  // 阶段1：解析
        .map(|d| stage2_validate(d))  // 阶段2：验证
        .filter_map(|d| d.ok())  // 过滤错误
        .map(|d| stage3_transform(d))  // 阶段3：转换
        .collect()
}

fn stage1_parse(s: &str) -> ParsedData {
    // 解析逻辑
    ParsedData { value: s.to_string() }
}

fn stage2_validate(data: ParsedData) -> Result<ParsedData, String> {
    // 验证逻辑
    if data.value.is_empty() {
        Err("Empty data".to_string())
    } else {
        Ok(data)
    }
}

fn stage3_transform(data: ParsedData) -> String {
    // 转换逻辑
    data.value.to_uppercase()
}

#[derive(Clone)]
struct ParsedData {
    value: String,
}
```

---

## 3. 异步算法基础

### 3.1 Tokio 异步运行时

```rust
use tokio;

#[tokio::main]
async fn main() {
    // 并发执行多个异步任务
    let task1 = async_computation(1);
    let task2 = async_computation(2);
    let task3 = async_computation(3);
    
    let (result1, result2, result3) = tokio::join!(task1, task2, task3);
    
    println!("结果: {}, {}, {}", result1, result2, result3);
}

async fn async_computation(id: i32) -> i32 {
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    id * 2
}
```

### 3.2 异步流处理

```rust
use tokio_stream::{self as stream, StreamExt};

async fn process_stream() {
    let mut stream = stream::iter(0..100);
    
    while let Some(item) = stream.next().await {
        let processed = process_item(item).await;
        println!("处理结果: {}", processed);
    }
}

async fn process_item(item: i32) -> i32 {
    // 模拟异步处理
    tokio::time::sleep(tokio::time::Duration::from_micros(10)).await;
    item * 2
}
```

### 3.3 并发控制

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

async fn controlled_concurrency(items: Vec<i32>, max_concurrent: usize) {
    let semaphore = Arc::new(Semaphore::new(max_concurrent));
    let mut tasks = Vec::new();
    
    for item in items {
        let permit = semaphore.clone();
        let task = tokio::spawn(async move {
            let _permit = permit.acquire().await.unwrap();
            process_with_limit(item).await
        });
        tasks.push(task);
    }
    
    for task in tasks {
        let _ = task.await;
    }
}

async fn process_with_limit(item: i32) -> i32 {
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    item * 2
}
```

---

## 4. 并发数据结构

### 4.1 原子操作

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use rayon::prelude::*;

// 并行计数器
fn parallel_count(data: &[i32]) -> usize {
    let counter = AtomicUsize::new(0);
    
    data.par_iter().for_each(|&x| {
        if x % 2 == 0 {
            counter.fetch_add(1, Ordering::Relaxed);
        }
    });
    
    counter.load(Ordering::Relaxed)
}
```

### 4.2 并发 HashMap

```rust
use dashmap::DashMap;
use rayon::prelude::*;

// 并行统计词频
fn parallel_word_count(words: &[String]) -> DashMap<String, usize> {
    let counts = DashMap::new();
    
    words.par_iter().for_each(|word| {
        *counts.entry(word.clone()).or_insert(0) += 1;
    });
    
    counts
}
```

### 4.3 无锁队列

```rust
use crossbeam::queue::SegQueue;
use rayon::prelude::*;

// 生产者-消费者模式
fn producer_consumer_example() {
    let queue = SegQueue::new();
    
    // 生产者
    rayon::scope(|s| {
        for i in 0..100 {
            let q = &queue;
            s.spawn(move |_| {
                q.push(i);
            });
        }
    });
    
    // 消费者
    let mut results = Vec::new();
    while let Some(item) = queue.pop() {
        results.push(item);
    }
    
    println!("处理了 {} 个项目", results.len());
}
```

---

## 5. 并行算法模式

### 5.1 Map-Reduce

```rust
use rayon::prelude::*;

// 并行 Map-Reduce
fn parallel_map_reduce(data: &[i32]) -> i32 {
    data.par_iter()
        .map(|&x| x * x)  // Map: 平方
        .sum()  // Reduce: 求和
}

// 复杂的 Map-Reduce
fn word_frequency_parallel(texts: &[String]) -> std::collections::HashMap<String, usize> {
    use std::collections::HashMap;
    
    texts.par_iter()
        .flat_map(|text| {
            // Map: 分词并计数
            let mut local_counts = HashMap::new();
            for word in text.split_whitespace() {
                *local_counts.entry(word.to_string()).or_insert(0) += 1;
            }
            local_counts
        })
        .fold(HashMap::new, |mut acc, (word, count)| {
            // Reduce: 合并计数
            *acc.entry(word).or_insert(0) += count;
            acc
        })
        .reduce(HashMap::new, |mut acc, map| {
            // 最终合并
            for (word, count) in map {
                *acc.entry(word).or_insert(0) += count;
            }
            acc
        })
}
```

### 5.2 分区并行

```rust
use rayon::prelude::*;

// 并行快速排序（分区并行）
fn parallel_partition_sort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 10000 {
        arr.sort_unstable();
        return;
    }
    
    let pivot_index = partition_inplace(arr);
    let (left, right) = arr.split_at_mut(pivot_index);
    
    rayon::join(
        || parallel_partition_sort(left),
        || parallel_partition_sort(&mut right[1..]),
    );
}

fn partition_inplace<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    let pivot = len - 1;
    let mut i = 0;
    
    for j in 0..len - 1 {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, pivot);
    i
}
```

---

## 6. 异步 IO 算法

### 6.1 并发文件读取

```rust
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn parallel_file_read(paths: Vec<String>) -> Vec<String> {
    let tasks: Vec<_> = paths.into_iter()
        .map(|path| tokio::spawn(async move {
            read_file(&path).await
        }))
        .collect();
    
    let mut results = Vec::new();
    for task in tasks {
        if let Ok(Ok(content)) = task.await {
            results.push(content);
        }
    }
    
    results
}

async fn read_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}
```

### 6.2 异步网络请求

```rust
use reqwest;

async fn parallel_http_requests(urls: Vec<String>) -> Vec<String> {
    let tasks: Vec<_> = urls.into_iter()
        .map(|url| tokio::spawn(async move {
            fetch_url(&url).await
        }))
        .collect();
    
    let mut results = Vec::new();
    for task in tasks {
        if let Ok(Ok(response)) = task.await {
            results.push(response);
        }
    }
    
    results
}

async fn fetch_url(url: &str) -> Result<String, reqwest::Error> {
    let response = reqwest::get(url).await?;
    response.text().await
}
```

---

## 7. 性能权衡

### 7.1 串行 vs 并行阈值

```rust
use rayon::prelude::*;

// 自适应并行
fn adaptive_sum(data: &[i32]) -> i32 {
    const PARALLEL_THRESHOLD: usize = 10000;
    
    if data.len() < PARALLEL_THRESHOLD {
        // 小数据串行处理
        data.iter().sum()
    } else {
        // 大数据并行处理
        data.par_iter().sum()
    }
}
```

### 7.2 开销测量

```rust
use std::time::Instant;
use rayon::prelude::*;

fn benchmark_parallel_overhead() {
    for size in [100, 1000, 10000, 100000] {
        let data: Vec<i32> = (0..size).collect();
        
        // 串行
        let start = Instant::now();
        let sum1: i32 = data.iter().sum();
        let serial_time = start.elapsed();
        
        // 并行
        let start = Instant::now();
        let sum2: i32 = data.par_iter().sum();
        let parallel_time = start.elapsed();
        
        println!("n={}: 串行={:?}, 并行={:?}, 加速比={:.2}x", 
            size, serial_time, parallel_time,
            serial_time.as_nanos() as f64 / parallel_time.as_nanos() as f64
        );
        
        assert_eq!(sum1, sum2);
    }
}
```

---

## 8. 实战案例

### 案例 1: 并行图像处理

```rust
use rayon::prelude::*;

struct Image {
    data: Vec<u8>,
    width: usize,
    height: usize,
}

impl Image {
    fn parallel_blur(&mut self, radius: usize) {
        let old_data = self.data.clone();
        
        self.data.par_iter_mut()
            .enumerate()
            .for_each(|(i, pixel)| {
                let x = i % self.width;
                let y = i / self.width;
                *pixel = self.compute_blur(&old_data, x, y, radius);
            });
    }
    
    fn compute_blur(&self, data: &[u8], x: usize, y: usize, radius: usize) -> u8 {
        let mut sum = 0u32;
        let mut count = 0u32;
        
        for dy in -(radius as isize)..=(radius as isize) {
            for dx in -(radius as isize)..=(radius as isize) {
                let nx = (x as isize + dx).max(0).min(self.width as isize - 1) as usize;
                let ny = (y as isize + dy).max(0).min(self.height as isize - 1) as usize;
                
                sum += data[ny * self.width + nx] as u32;
                count += 1;
            }
        }
        
        (sum / count) as u8
    }
}
```

### 案例 2: 并行矩阵乘法

```rust
use rayon::prelude::*;

fn parallel_matrix_multiply(a: &[Vec<f32>], b: &[Vec<f32>]) -> Vec<Vec<f32>> {
    let n = a.len();
    let m = b[0].len();
    
    (0..n).into_par_iter()
        .map(|i| {
            (0..m).map(|j| {
                (0..b.len())
                    .map(|k| a[i][k] * b[k][j])
                    .sum()
            }).collect()
        })
        .collect()
}
```

### 案例 3: 并行 Web 爬虫

```rust
use tokio;
use reqwest;
use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let urls = vec![
        "https://example.com/page1",
        "https://example.com/page2",
        "https://example.com/page3",
    ];
    
    let results = crawl_concurrent(urls, 2).await;
    
    for (url, content) in results {
        println!("抓取 {}: {} 字节", url, content.len());
    }
}

async fn crawl_concurrent(urls: Vec<&str>, max_concurrent: usize) -> Vec<(String, String)> {
    let semaphore = Arc::new(Semaphore::new(max_concurrent));
    let tasks: Vec<_> = urls.into_iter()
        .map(|url| {
            let url = url.to_string();
            let sem = semaphore.clone();
            tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                let content = fetch_page(&url).await.unwrap_or_default();
                (url, content)
            })
        })
        .collect();
    
    let mut results = Vec::new();
    for task in tasks {
        if let Ok(result) = task.await {
            results.push(result);
        }
    }
    
    results
}

async fn fetch_page(url: &str) -> Result<String, reqwest::Error> {
    let response = reqwest::get(url).await?;
    response.text().await
}
```

---

## 🔗 相关资源

**内部文档**:

- [性能优化实践](./04_性能优化实践.md) - 基础优化
- [算法复杂度分析](./03_算法复杂度分析.md) - 理论基础
- [详细指南](../guides/async_algorithms.md) - 完整参考

**外部资源**:

- 🦀 [Rayon 文档](https://docs.rs/rayon/)
- 📘 [Tokio 教程](https://tokio.rs/tokio/tutorial)
- 🌐 [Async Book](https://rust-lang.github.io/async-book/)

**并发库**:

- [rayon](https://github.com/rayon-rs/rayon) - 数据并行
- [tokio](https://tokio.rs/) - 异步运行时
- [crossbeam](https://github.com/crossbeam-rs/crossbeam) - 并发工具
- [dashmap](https://github.com/xacrimon/dashmap) - 并发 HashMap

---

**返回**: [Tier 2 索引](./README.md) | **完成**: ✅ C08 Tier 2 全部完成！

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-23  
**文档状态**: ✅ 完成
