# 04 æ€§èƒ½ä¼˜åŒ–å®è·µ

> **æ–‡æ¡£ç±»å‹**: Tier 2 - å®è·µæŒ‡å—
> **ç›®æ ‡è¯»è€…**: å…³æ³¨ç®—æ³•æ€§èƒ½ä¼˜åŒ–çš„å¼€å‘è€…
> **é¢„è®¡å­¦ä¹ æ—¶é—´**: 3-4å°æ—¶
> **å‰ç½®çŸ¥è¯†**: [ç®—æ³•å¤æ‚åº¦åˆ†æ](./03_ç®—æ³•å¤æ‚åº¦åˆ†æ.md)

## ğŸ“‹ ç›®å½•

- [04 æ€§èƒ½ä¼˜åŒ–å®è·µ](#04-æ€§èƒ½ä¼˜åŒ–å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [1. è¿­ä»£å™¨ä¼˜åŒ–](#1-è¿­ä»£å™¨ä¼˜åŒ–)
    - [1.1 é›¶æˆæœ¬æŠ½è±¡](#11-é›¶æˆæœ¬æŠ½è±¡)
    - [1.2 é¿å…ä¸­é—´åˆ†é…](#12-é¿å…ä¸­é—´åˆ†é…)
    - [1.3 æå‰ç»ˆæ­¢](#13-æå‰ç»ˆæ­¢)
  - [2. å†…å­˜åˆ†é…ä¼˜åŒ–](#2-å†…å­˜åˆ†é…ä¼˜åŒ–)
    - [2.1 é¢„åˆ†é…å®¹é‡](#21-é¢„åˆ†é…å®¹é‡)
    - [2.2 ä½¿ç”¨ Arena åˆ†é…å™¨](#22-ä½¿ç”¨-arena-åˆ†é…å™¨)
    - [2.3 é¿å…ä¸å¿…è¦çš„å…‹éš†](#23-é¿å…ä¸å¿…è¦çš„å…‹éš†)
  - [3. ç¼“å­˜å±€éƒ¨æ€§](#3-ç¼“å­˜å±€éƒ¨æ€§)
    - [3.1 æ•°ç»„ vs é“¾è¡¨](#31-æ•°ç»„-vs-é“¾è¡¨)
    - [3.2 ç»“æ„ä½“æ•°ç»„ vs æ•°ç»„ç»“æ„ä½“](#32-ç»“æ„ä½“æ•°ç»„-vs-æ•°ç»„ç»“æ„ä½“)
    - [3.3 çŸ©é˜µè®¿é—®æ¨¡å¼](#33-çŸ©é˜µè®¿é—®æ¨¡å¼)
  - [4. SIMD å‘é‡åŒ–](#4-simd-å‘é‡åŒ–)
    - [4.1 ä½¿ç”¨ packed\_simd](#41-ä½¿ç”¨-packed_simd)
    - [4.2 è‡ªåŠ¨å‘é‡åŒ–](#42-è‡ªåŠ¨å‘é‡åŒ–)
  - [5. å¹¶è¡Œä¼˜åŒ–](#5-å¹¶è¡Œä¼˜åŒ–)
    - [5.1 ä½¿ç”¨ Rayon](#51-ä½¿ç”¨-rayon)
    - [5.2 ä»»åŠ¡å¹¶è¡Œ](#52-ä»»åŠ¡å¹¶è¡Œ)
  - [6. åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–](#6-åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–)
    - [6.1 å‡å°‘åˆ†æ”¯](#61-å‡å°‘åˆ†æ”¯)
    - [6.2 åˆ†æ”¯é¢„æµ‹æç¤º](#62-åˆ†æ”¯é¢„æµ‹æç¤º)
  - [7. æ€§èƒ½æµ‹è¯•ä¸åˆ†æ](#7-æ€§èƒ½æµ‹è¯•ä¸åˆ†æ)
    - [7.1 Criterion åŸºå‡†æµ‹è¯•](#71-criterion-åŸºå‡†æµ‹è¯•)
    - [7.2 ä½¿ç”¨ flamegraph](#72-ä½¿ç”¨-flamegraph)
    - [7.3 ä½¿ç”¨ perf](#73-ä½¿ç”¨-perf)
  - [8. å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹](#8-å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: å¤§æ•°ç»„æ±‚å’Œä¼˜åŒ–](#æ¡ˆä¾‹-1-å¤§æ•°ç»„æ±‚å’Œä¼˜åŒ–)
    - [æ¡ˆä¾‹ 2: å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–](#æ¡ˆä¾‹-2-å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–)
    - [æ¡ˆä¾‹ 3: å›¾éå†ä¼˜åŒ–](#æ¡ˆä¾‹-3-å›¾éå†ä¼˜åŒ–)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**æ€§èƒ½ä¼˜åŒ–å®è·µ (Performance Optimization Practice)**:

- **å®šä¹‰**: ä¼˜åŒ–ç®—æ³•æ€§èƒ½çš„æŠ€æœ¯å’Œå®è·µï¼ŒåŒ…æ‹¬è¿­ä»£å™¨ä¼˜åŒ–ã€å†…å­˜ä¼˜åŒ–ã€ç¼“å­˜ä¼˜åŒ–ç­‰
- **ç±»å‹**: æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
- **èŒƒç•´**: ç®—æ³•å­¦ã€æ€§èƒ½å·¥ç¨‹
- **ç‰ˆæœ¬**: Rust 1.0+
- **ç›¸å…³æ¦‚å¿µ**: æ€§èƒ½ä¼˜åŒ–ã€å†…å­˜ç®¡ç†ã€SIMDã€å¹¶è¡Œè®¡ç®—

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **è¿­ä»£å™¨ä¼˜åŒ–**: é›¶æˆæœ¬æŠ½è±¡ã€é¿å…ä¸­é—´åˆ†é…
- **å†…å­˜ä¼˜åŒ–**: é¢„åˆ†é…å®¹é‡ã€Arena åˆ†é…å™¨
- **ç¼“å­˜å±€éƒ¨æ€§**: æ•°ç»„ vs é“¾è¡¨ã€ç»“æ„ä½“å¸ƒå±€
- **SIMD å‘é‡åŒ–**: ä½¿ç”¨ SIMD åŠ é€Ÿè®¡ç®—

**æ€§èƒ½ç‰¹å¾**:

- **é›¶æˆæœ¬æŠ½è±¡**: è¿­ä»£å™¨æ€§èƒ½ç­‰åŒäºæ‰‹å†™å¾ªç¯
- **å†…å­˜æ•ˆç‡**: å‡å°‘å†…å­˜åˆ†é…å’Œæ‹·è´
- **é€‚ç”¨åœºæ™¯**: é«˜æ€§èƒ½ç®—æ³•ã€æ•°å€¼è®¡ç®—ã€æ•°æ®å¤„ç†

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- æ€§èƒ½ä¼˜åŒ–å®è·µ --[uses]--> å¤šç§ä¼˜åŒ–æŠ€æœ¯
- ç®—æ³•å®ç° --[benefits-from]--> æ€§èƒ½ä¼˜åŒ–å®è·µ

**ä¾èµ–å…³ç³»**:

- æ€§èƒ½ä¼˜åŒ–å®è·µ --[depends-on]--> æ€§èƒ½åˆ†æå·¥å…·
- ç®—æ³•ä¼˜åŒ– --[depends-on]--> æ€§èƒ½ä¼˜åŒ–å®è·µ

### æ€ç»´å¯¼å›¾

```text
æ€§èƒ½ä¼˜åŒ–å®è·µ
â”‚
â”œâ”€â”€ è¿­ä»£å™¨ä¼˜åŒ–
â”‚   â”œâ”€â”€ é›¶æˆæœ¬æŠ½è±¡
â”‚   â””â”€â”€ é¿å…ä¸­é—´åˆ†é…
â”œâ”€â”€ å†…å­˜åˆ†é…ä¼˜åŒ–
â”‚   â”œâ”€â”€ é¢„åˆ†é…å®¹é‡
â”‚   â””â”€â”€ Arena åˆ†é…å™¨
â”œâ”€â”€ ç¼“å­˜å±€éƒ¨æ€§
â”‚   â”œâ”€â”€ æ•°ç»„ vs é“¾è¡¨
â”‚   â””â”€â”€ ç»“æ„ä½“å¸ƒå±€
â”œâ”€â”€ SIMD å‘é‡åŒ–
â”‚   â””â”€â”€ è‡ªåŠ¨å‘é‡åŒ–
â”œâ”€â”€ å¹¶è¡Œä¼˜åŒ–
â”‚   â””â”€â”€ Rayon
â””â”€â”€ æ€§èƒ½æµ‹è¯•ä¸åˆ†æ
    â”œâ”€â”€ Criterion
    â””â”€â”€ flamegraph
```

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- âœ… æŒæ¡ Rust è¿­ä»£å™¨çš„é›¶æˆæœ¬æŠ½è±¡
- âœ… ä¼˜åŒ–å†…å­˜åˆ†é…å‡å°‘æ€§èƒ½å¼€é”€
- âœ… åˆ©ç”¨ç¼“å­˜å±€éƒ¨æ€§æå‡æ€§èƒ½
- âœ… ä½¿ç”¨ SIMD åŠ é€Ÿæ•°å€¼è®¡ç®—
- âœ… åº”ç”¨å¹¶è¡ŒåŒ–æå‡å¤šæ ¸æ€§èƒ½
- âœ… ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·å®šä½ç“¶é¢ˆ

---

## 1. è¿­ä»£å™¨ä¼˜åŒ–

### 1.1 é›¶æˆæœ¬æŠ½è±¡

Rust è¿­ä»£å™¨ç»è¿‡ç¼–è¯‘å™¨ä¼˜åŒ–åæ€§èƒ½ç­‰åŒäºæ‰‹å†™å¾ªç¯ï¼š

```rust
// æ–¹æ¡ˆ 1: æ‰‹å†™å¾ªç¯
fn sum_manual(data: &[i32]) -> i32 {
    let mut sum = 0;
    for &item in data {
        sum += item;
    }
    sum
}

// æ–¹æ¡ˆ 2: è¿­ä»£å™¨
fn sum_iterator(data: &[i32]) -> i32 {
    data.iter().sum()  // ç¼–è¯‘åç­‰ä»·äºæ–¹æ¡ˆ1
}

// æ–¹æ¡ˆ 3: é“¾å¼æ“ä½œ
fn sum_filtered(data: &[i32]) -> i32 {
    data.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .sum()
}
```

### 1.2 é¿å…ä¸­é—´åˆ†é…

```rust
// âŒ ä¸ä¼˜ï¼šå¤šæ¬¡åˆ†é…
fn process_data_slow(data: &[i32]) -> Vec<i32> {
    let filtered: Vec<i32> = data.iter()
        .filter(|&&x| x % 2 == 0)
        .copied()
        .collect();

    let mapped: Vec<i32> = filtered.iter()
        .map(|&x| x * 2)
        .collect();

    mapped
}

// âœ… ä¼˜åŒ–ï¼šé“¾å¼æ“ä½œï¼Œä¸€æ¬¡åˆ†é…
fn process_data_fast(data: &[i32]) -> Vec<i32> {
    data.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2)
        .collect()
}
```

### 1.3 æå‰ç»ˆæ­¢

```rust
// âœ… ä½¿ç”¨ any/all æå‰ç»ˆæ­¢
fn has_negative(data: &[i32]) -> bool {
    data.iter().any(|&x| x < 0)  // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°±è¿”å›
}

// âŒ ä¸ä¼˜ï¼šéå†æ‰€æœ‰å…ƒç´ 
fn has_negative_slow(data: &[i32]) -> bool {
    data.iter().filter(|&&x| x < 0).count() > 0
}
```

---

## 2. å†…å­˜åˆ†é…ä¼˜åŒ–

### 2.1 é¢„åˆ†é…å®¹é‡

```rust
use std::time::Instant;

fn benchmark_allocation() {
    let n = 100_000;

    // âŒ ä¸ä¼˜ï¼šå¤šæ¬¡æ‰©å®¹
    let start = Instant::now();
    let mut v1 = Vec::new();
    for i in 0..n {
        v1.push(i);
    }
    println!("æœªé¢„åˆ†é…: {:?}", start.elapsed());

    // âœ… ä¼˜åŒ–ï¼šé¢„åˆ†é…
    let start = Instant::now();
    let mut v2 = Vec::with_capacity(n);
    for i in 0..n {
        v2.push(i);
    }
    println!("é¢„åˆ†é…: {:?}", start.elapsed());
}
```

### 2.2 ä½¿ç”¨ Arena åˆ†é…å™¨

```rust
// ä½¿ç”¨ bumpalo crate
use bumpalo::Bump;

fn allocate_many() {
    let arena = Bump::new();

    // æ‰€æœ‰åˆ†é…æ¥è‡ªåŒä¸€å—å†…å­˜
    for _ in 0..1000 {
        let _ = arena.alloc(42);
    }

    // arena dropæ—¶ä¸€æ¬¡æ€§é‡Šæ”¾æ‰€æœ‰å†…å­˜
}
```

### 2.3 é¿å…ä¸å¿…è¦çš„å…‹éš†

```rust
#[derive(Clone)]
struct Data {
    values: Vec<i32>,
}

// âŒ ä¸ä¼˜ï¼šä¸å¿…è¦çš„å…‹éš†
fn process_slow(data: &Data) -> i32 {
    let cloned = data.clone();  // æ˜‚è´µçš„å…‹éš†
    cloned.values.iter().sum()
}

// âœ… ä¼˜åŒ–ï¼šç›´æ¥ä½¿ç”¨å¼•ç”¨
fn process_fast(data: &Data) -> i32 {
    data.values.iter().sum()
}
```

---

## 3. ç¼“å­˜å±€éƒ¨æ€§

### 3.1 æ•°ç»„ vs é“¾è¡¨

```rust
use std::collections::LinkedList;
use std::time::Instant;

fn benchmark_cache_locality() {
    let n = 100_000;

    // Vec: ç¼“å­˜å‹å¥½
    let vec: Vec<i32> = (0..n).collect();
    let start = Instant::now();
    let sum1: i32 = vec.iter().sum();
    println!("Vecéå†: {:?}", start.elapsed());

    // LinkedList: ç¼“å­˜ä¸å‹å¥½
    let list: LinkedList<i32> = (0..n).collect();
    let start = Instant::now();
    let sum2: i32 = list.iter().sum();
    println!("LinkedListéå†: {:?}", start.elapsed());

    assert_eq!(sum1, sum2);
}
```

### 3.2 ç»“æ„ä½“æ•°ç»„ vs æ•°ç»„ç»“æ„ä½“

```rust
// SOA (Structure of Arrays) - ç¼“å­˜å‹å¥½
struct ParticlesSOA {
    x: Vec<f32>,
    y: Vec<f32>,
    vx: Vec<f32>,
    vy: Vec<f32>,
}

impl ParticlesSOA {
    fn update(&mut self, dt: f32) {
        // è¿ç»­è®¿é—®åŒç±»å‹æ•°æ®ï¼Œç¼“å­˜å‹å¥½
        for vx in &mut self.vx {
            *vx *= dt;
        }
        for i in 0..self.x.len() {
            self.x[i] += self.vx[i];
        }
    }
}

// AOS (Array of Structures) - å¯èƒ½ç¼“å­˜ä¸å‹å¥½
struct Particle {
    x: f32,
    y: f32,
    vx: f32,
    vy: f32,
}

struct ParticlesAOS {
    particles: Vec<Particle>,
}

impl ParticlesAOS {
    fn update(&mut self, dt: f32) {
        for p in &mut self.particles {
            p.vx *= dt;
            p.x += p.vx;
        }
    }
}
```

### 3.3 çŸ©é˜µè®¿é—®æ¨¡å¼

```rust
fn matrix_multiply_slow(a: &[Vec<f32>], b: &[Vec<f32>]) -> Vec<Vec<f32>> {
    let n = a.len();
    let mut c = vec![vec![0.0; n]; n];

    // âŒ ä¸ä¼˜ï¼šåˆ—è®¿é—® b[k][j] ç¼“å­˜ä¸å‹å¥½
    for i in 0..n {
        for j in 0..n {
            for k in 0..n {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }

    c
}

fn matrix_multiply_fast(a: &[Vec<f32>], b: &[Vec<f32>]) -> Vec<Vec<f32>> {
    let n = a.len();
    let mut c = vec![vec![0.0; n]; n];

    // âœ… ä¼˜åŒ–ï¼šè°ƒæ•´å¾ªç¯é¡ºåºï¼Œæ”¹å–„ç¼“å­˜å±€éƒ¨æ€§
    for i in 0..n {
        for k in 0..n {
            for j in 0..n {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }

    c
}
```

---

## 4. SIMD å‘é‡åŒ–

### 4.1 ä½¿ç”¨ packed_simd

```rust
// Cargo.toml: packed_simd = "0.3"
use packed_simd::*;

// æ ‡é‡ç‰ˆæœ¬
fn sum_scalar(data: &[f32]) -> f32 {
    data.iter().sum()
}

// SIMD ç‰ˆæœ¬
fn sum_simd(data: &[f32]) -> f32 {
    let chunks = data.chunks_exact(f32x4::lanes());
    let remainder = chunks.remainder();

    let mut sum = f32x4::splat(0.0);
    for chunk in chunks {
        let v = f32x4::from_slice_unaligned(chunk);
        sum += v;
    }

    sum.sum() + remainder.iter().sum::<f32>()
}
```

### 4.2 è‡ªåŠ¨å‘é‡åŒ–

```rust
// ç¼–è¯‘å™¨è‡ªåŠ¨å‘é‡åŒ–ï¼ˆéœ€è¦ä¼˜åŒ–æ ‡å¿—ï¼‰
#[inline(never)]
fn add_arrays(a: &[f32], b: &[f32], c: &mut [f32]) {
    for i in 0..a.len() {
        c[i] = a[i] + b[i];  // ç¼–è¯‘å™¨å¯èƒ½è‡ªåŠ¨å‘é‡åŒ–
    }
}

// ç¼–è¯‘: cargo build --release
// RUSTFLAGS="-C target-cpu=native"
```

---

## 5. å¹¶è¡Œä¼˜åŒ–

### 5.1 ä½¿ç”¨ Rayon

```rust
use rayon::prelude::*;

// ä¸²è¡Œ
fn sum_serial(data: &[i32]) -> i32 {
    data.iter().sum()
}

// å¹¶è¡Œ
fn sum_parallel(data: &[i32]) -> i32 {
    data.par_iter().sum()
}

// å¹¶è¡Œ map-reduce
fn parallel_process(data: &[i32]) -> Vec<i32> {
    data.par_iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * 2)
        .collect()
}
```

### 5.2 ä»»åŠ¡å¹¶è¡Œ

```rust
use rayon::prelude::*;

fn parallel_tasks() {
    let (result1, result2) = rayon::join(
        || expensive_computation_1(),
        || expensive_computation_2(),
    );

    println!("ç»“æœ: {}, {}", result1, result2);
}

fn expensive_computation_1() -> i32 {
    (0..10_000_000).sum()
}

fn expensive_computation_2() -> i32 {
    (0..10_000_000).product::<i32>().wrapping_rem(1_000_000)
}
```

---

## 6. åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–

### 6.1 å‡å°‘åˆ†æ”¯

```rust
// âŒ ä¸ä¼˜ï¼šé¢‘ç¹åˆ†æ”¯
fn count_positives_branchy(data: &[i32]) -> usize {
    let mut count = 0;
    for &x in data {
        if x > 0 {
            count += 1;
        }
    }
    count
}

// âœ… ä¼˜åŒ–ï¼šæ— åˆ†æ”¯
fn count_positives_branchless(data: &[i32]) -> usize {
    data.iter().filter(|&&x| x > 0).count()
}
```

### 6.2 åˆ†æ”¯é¢„æµ‹æç¤º

```rust
// ä½¿ç”¨ likely/unlikely å®ï¼ˆéœ€è¦ nightlyï¼‰
#[cfg(feature = "nightly")]
fn with_branch_hint(x: i32) -> i32 {
    if std::intrinsics::likely(x > 0) {
        x * 2
    } else {
        x
    }
}
```

---

## 7. æ€§èƒ½æµ‹è¯•ä¸åˆ†æ

### 7.1 Criterion åŸºå‡†æµ‹è¯•

```rust
// benches/my_benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn fibonacci_iterative(n: u32) -> u64 {
    let (mut a, mut b) = (0, 1);
    for _ in 0..n {
        let temp = a;
        a = b;
        b = temp + b;
    }
    a
}

fn fibonacci_recursive(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2),
    }
}

fn bench_fibonacci(c: &mut Criterion) {
    let mut group = c.benchmark_group("fibonacci");

    for n in [10, 20, 30].iter() {
        group.bench_with_input(BenchmarkId::new("iterative", n), n, |b, &n| {
            b.iter(|| fibonacci_iterative(black_box(n)))
        });

        if *n <= 20 {  // é€’å½’ç‰ˆæœ¬å¤ªæ…¢
            group.bench_with_input(BenchmarkId::new("recursive", n), n, |b, &n| {
                b.iter(|| fibonacci_recursive(black_box(n)))
            });
        }
    }

    group.finish();
}

criterion_group!(benches, bench_fibonacci);
criterion_main!(benches);
```

### 7.2 ä½¿ç”¨ flamegraph

```bash
# å®‰è£…
cargo install flamegraph

# ç”Ÿæˆç«ç„°å›¾
cargo flamegraph --bin myapp

# æŸ¥çœ‹ flamegraph.svg
```

### 7.3 ä½¿ç”¨ perf

```bash
# Linux æ€§èƒ½åˆ†æ
cargo build --release
perf record --call-graph=dwarf ./target/release/myapp
perf report
```

---

## 8. å®æˆ˜ä¼˜åŒ–æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: å¤§æ•°ç»„æ±‚å’Œä¼˜åŒ–

```rust
use std::time::Instant;

// ç‰ˆæœ¬1: æœ´ç´ å®ç°
fn sum_v1(data: &[i32]) -> i64 {
    let mut sum = 0i64;
    for &x in data {
        sum += x as i64;
    }
    sum
}

// ç‰ˆæœ¬2: è¿­ä»£å™¨
fn sum_v2(data: &[i32]) -> i64 {
    data.iter().map(|&x| x as i64).sum()
}

// ç‰ˆæœ¬3: å¹¶è¡Œ
fn sum_v3(data: &[i32]) -> i64 {
    use rayon::prelude::*;
    data.par_iter().map(|&x| x as i64).sum()
}

// ç‰ˆæœ¬4: SIMD (ç¤ºä¾‹)
fn sum_v4(data: &[i32]) -> i64 {
    // ä½¿ç”¨ SIMD æŒ‡ä»¤åŠ é€Ÿ
    // å®é™…å®ç°éœ€è¦ packed_simd æˆ– std::simd
    data.iter().map(|&x| x as i64).sum()
}

fn benchmark_sum() {
    let data: Vec<i32> = (0..10_000_000).collect();

    let start = Instant::now();
    let _ = sum_v1(&data);
    println!("v1 æœ´ç´ : {:?}", start.elapsed());

    let start = Instant::now();
    let _ = sum_v2(&data);
    println!("v2 è¿­ä»£å™¨: {:?}", start.elapsed());

    let start = Instant::now();
    let _ = sum_v3(&data);
    println!("v3 å¹¶è¡Œ: {:?}", start.elapsed());
}
```

### æ¡ˆä¾‹ 2: å­—ç¬¦ä¸²å¤„ç†ä¼˜åŒ–

```rust
// âŒ ä¸ä¼˜ï¼šå¤šæ¬¡åˆ†é…
fn process_strings_slow(lines: &[String]) -> Vec<String> {
    lines.iter()
        .map(|s| s.to_lowercase())
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect()
}

// âœ… ä¼˜åŒ–ï¼šå‡å°‘åˆ†é…
fn process_strings_fast(lines: &[String]) -> Vec<String> {
    lines.iter()
        .filter_map(|s| {
            let trimmed = s.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_lowercase())
            }
        })
        .collect()
}

// âœ… è¿›ä¸€æ­¥ä¼˜åŒ–ï¼šå¤ç”¨å†…å­˜
fn process_strings_inplace(lines: &mut [String]) {
    for s in lines.iter_mut() {
        s.make_ascii_lowercase();
        let trimmed = s.trim();
        if s != trimmed {
            *s = trimmed.to_string();
        }
    }
    lines.retain(|s| !s.is_empty());
}
```

### æ¡ˆä¾‹ 3: å›¾éå†ä¼˜åŒ–

```rust
use std::collections::{HashMap, HashSet, VecDeque};

// æ–¹æ¡ˆ1: ä½¿ç”¨ HashSet å»é‡
fn bfs_v1(graph: &HashMap<i32, Vec<i32>>, start: i32) -> Vec<i32> {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    let mut result = Vec::new();

    queue.push_back(start);
    visited.insert(start);

    while let Some(node) = queue.pop_front() {
        result.push(node);

        if let Some(neighbors) = graph.get(&node) {
            for &neighbor in neighbors {
                if visited.insert(neighbor) {
                    queue.push_back(neighbor);
                }
            }
        }
    }

    result
}

// æ–¹æ¡ˆ2: ä½¿ç”¨ä½å‘é‡ï¼ˆé€‚ç”¨äºèŠ‚ç‚¹IDè¿ç»­ï¼‰
fn bfs_v2(graph: &HashMap<i32, Vec<i32>>, start: i32, max_node: usize) -> Vec<i32> {
    let mut visited = vec![false; max_node + 1];
    let mut queue = VecDeque::new();
    let mut result = Vec::new();

    queue.push_back(start);
    visited[start as usize] = true;

    while let Some(node) = queue.pop_front() {
        result.push(node);

        if let Some(neighbors) = graph.get(&node) {
            for &neighbor in neighbors {
                if !visited[neighbor as usize] {
                    visited[neighbor as usize] = true;
                    queue.push_back(neighbor);
                }
            }
        }
    }

    result
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

**å†…éƒ¨æ–‡æ¡£**:

- [ç®—æ³•å¤æ‚åº¦åˆ†æ](./03_ç®—æ³•å¤æ‚åº¦åˆ†æ.md) - ç†è®ºåŸºç¡€
- [å¹¶è¡Œä¸å¼‚æ­¥ç®—æ³•](./05_å¹¶è¡Œä¸å¼‚æ­¥ç®—æ³•.md) - å¹¶è¡Œä¼˜åŒ–
- [ç®—æ³•å·¥ç¨‹å®è·µ](../tier_04_advanced/04_ç®—æ³•å·¥ç¨‹å®è·µ.md) - å·¥ç¨‹å®è·µ

**å¤–éƒ¨èµ„æº**:

- ğŸ¦€ [Rust Performance Book](https://nnethercote.github.io/perf-book/)
- ğŸ“˜ [Criterion.rs](https://bheisler.github.io/criterion.rs/book/)
- ğŸŒ [Rayon æ–‡æ¡£](https://docs.rs/rayon/)

**å·¥å…·**:

- [cargo-flamegraph](https://github.com/flamegraph-rs/flamegraph)
- [perf](https://perf.wiki.kernel.org/)
- [valgrind/callgrind](https://valgrind.org/)

---

**è¿”å›**: [Tier 2 ç´¢å¼•](./README.md) | **ä¸‹ä¸€æ­¥**: [å¹¶è¡Œä¸å¼‚æ­¥ç®—æ³•](./05_å¹¶è¡Œä¸å¼‚æ­¥ç®—æ³•.md)

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
