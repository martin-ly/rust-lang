# æ•°æ®ç»“æ„å‚è€ƒæ‰‹å†Œ

> **æ–‡æ¡£ç±»å‹**: Tier 3 æŠ€æœ¯å‚è€ƒ  
> **ç›®æ ‡è¯»è€…**: éœ€è¦æŸ¥é˜…æ•°æ®ç»“æ„APIçš„å¼€å‘è€…  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **Edition**: 2024  
> **æœ€åæ›´æ–°**: 2025-10-23

---

## ğŸ“– ç›®å½•

- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. æ ‘çŠ¶æ•°ç»„ (Fenwick Tree / Binary Indexed Tree)](#2-æ ‘çŠ¶æ•°ç»„-fenwick-tree--binary-indexed-tree)
- [3. çº¿æ®µæ ‘ (Segment Tree)](#3-çº¿æ®µæ ‘-segment-tree)
- [4. å¹¶æŸ¥é›† (Disjoint Set Union)](#4-å¹¶æŸ¥é›†-disjoint-set-union)
- [5. ä¼˜å…ˆé˜Ÿåˆ— (Priority Queue)](#5-ä¼˜å…ˆé˜Ÿåˆ—-priority-queue)
- [6. ç¨€ç–è¡¨ (Sparse Table)](#6-ç¨€ç–è¡¨-sparse-table)
- [7. LRU ç¼“å­˜ (LRU Cache)](#7-lru-ç¼“å­˜-lru-cache)
- [8. Trie (å­—å…¸æ ‘)](#8-trie-å­—å…¸æ ‘)
- [9. åç¼€æ•°ç»„ (Suffix Array)](#9-åç¼€æ•°ç»„-suffix-array)
- [10. åç¼€è‡ªåŠ¨æœº (Suffix Automaton)](#10-åç¼€è‡ªåŠ¨æœº-suffix-automaton)
- [11. æ€§èƒ½å¯¹æ¯”](#11-æ€§èƒ½å¯¹æ¯”)
- [12. é€‰æ‹©æŒ‡å—](#12-é€‰æ‹©æŒ‡å—)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› C08 Algorithms æ¨¡å—ä¸­æ‰€æœ‰æ•°æ®ç»“æ„çš„å®Œæ•´ API å‚è€ƒã€‚æ¯ä¸ªæ•°æ®ç»“æ„éƒ½åŒ…å«ï¼š

- **API æ–‡æ¡£**ï¼šæ„é€ å‡½æ•°ã€æ–¹æ³•ç­¾åã€æ—¶é—´å¤æ‚åº¦
- **ä»£ç ç¤ºä¾‹**ï¼šå¸¸è§ç”¨æ³•å’Œæœ€ä½³å®è·µ
- **ä½¿ç”¨åœºæ™¯**ï¼šé€‚ç”¨é—®é¢˜å’Œæ€§èƒ½ç‰¹å¾
- **Rust ç‰¹æ€§**ï¼šæ‰€æœ‰æƒã€å¹¶å‘å®‰å…¨ã€é›¶æˆæœ¬æŠ½è±¡

---

## 2. æ ‘çŠ¶æ•°ç»„ (Fenwick Tree / Binary Indexed Tree)

### 2.1 æ¦‚è¿°

**åŠŸèƒ½**: é«˜æ•ˆç»´æŠ¤å‰ç¼€å’Œï¼Œæ”¯æŒå•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ„é€ : O(n)
- å•ç‚¹æ›´æ–°: O(log n)
- å‰ç¼€å’ŒæŸ¥è¯¢: O(log n)
- åŒºé—´å’ŒæŸ¥è¯¢: O(log n)

**ç©ºé—´å¤æ‚åº¦**: O(n)

### 2.2 API æ–‡æ¡£

```rust
pub struct Fenwick {
    tree: Vec<i64>,
}

impl Fenwick {
    /// åˆ›å»ºå¤§å°ä¸º n çš„æ ‘çŠ¶æ•°ç»„ï¼Œåˆå§‹å€¼å…¨ä¸º 0
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn new(n: usize) -> Self;
    
    /// åœ¨ç´¢å¼• i å¤„å¢åŠ  delta (æ”¯æŒè´Ÿæ•°)
    ///
    /// # å‚æ•°
    /// - `i`: ç´¢å¼• (0-based)
    /// - `delta`: å¢é‡å€¼
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn add(&mut self, i: usize, delta: i64);
    
    /// æŸ¥è¯¢å‰ç¼€å’Œ [0, i)
    ///
    /// # å‚æ•°
    /// - `i`: å‰ç¼€é•¿åº¦ (ä¸åŒ…å«ç´¢å¼• i)
    ///
    /// # è¿”å›: å‰ç¼€å’Œ
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn sum_prefix(&self, i: usize) -> i64;
    
    /// æŸ¥è¯¢åŒºé—´å’Œ [l, r)
    ///
    /// # å‚æ•°
    /// - `l`: å·¦ç«¯ç‚¹ (åŒ…å«)
    /// - `r`: å³ç«¯ç‚¹ (ä¸åŒ…å«)
    ///
    /// # è¿”å›: åŒºé—´å’Œ
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn range_sum(&self, l: usize, r: usize) -> i64 {
        self.sum_prefix(r) - self.sum_prefix(l)
    }
}
```

### 2.3 ä»£ç ç¤ºä¾‹

#### åŸºç¡€ä½¿ç”¨

```rust
use c08_algorithms::data_structure::Fenwick;

fn example_basic_usage() {
    // åˆ›å»ºå¤§å°ä¸º 10 çš„æ ‘çŠ¶æ•°ç»„
    let mut fenwick = Fenwick::new(10);
    
    // åˆå§‹åŒ–æ•°ç»„: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    for i in 0..10 {
        fenwick.add(i, i as i64);
    }
    
    // æŸ¥è¯¢å‰ç¼€å’Œ
    println!("sum[0, 5) = {}", fenwick.sum_prefix(5)); // 0+1+2+3+4 = 10
    
    // æŸ¥è¯¢åŒºé—´å’Œ
    println!("sum[3, 7) = {}", fenwick.range_sum(3, 7)); // 3+4+5+6 = 18
    
    // å•ç‚¹æ›´æ–°ï¼šarr[5] += 10
    fenwick.add(5, 10);
    println!("sum[3, 7) = {}", fenwick.range_sum(3, 7)); // 3+4+15+6 = 28
}
```

#### å·®åˆ†æ•°ç»„åº”ç”¨

```rust
// åŒºé—´ä¿®æ”¹ + å•ç‚¹æŸ¥è¯¢
fn example_range_update() {
    let mut fenwick = Fenwick::new(10);
    
    // åŒºé—´ [l, r) += delta çš„å®ç°
    fn range_add(fenwick: &mut Fenwick, l: usize, r: usize, delta: i64) {
        fenwick.add(l, delta);
        fenwick.add(r, -delta);
    }
    
    // [2, 5) += 10
    range_add(&mut fenwick, 2, 5, 10);
    
    // å•ç‚¹æŸ¥è¯¢ arr[3]
    println!("arr[3] = {}", fenwick.sum_prefix(4) - fenwick.sum_prefix(3)); // 10
}
```

#### äºŒç»´æ ‘çŠ¶æ•°ç»„

```rust
pub struct Fenwick2D {
    tree: Vec<Vec<i64>>,
    rows: usize,
    cols: usize,
}

impl Fenwick2D {
    pub fn new(rows: usize, cols: usize) -> Self {
        Fenwick2D {
            tree: vec![vec![0; cols + 1]; rows + 1],
            rows,
            cols,
        }
    }
    
    pub fn add(&mut self, mut r: usize, mut c: usize, delta: i64) {
        r += 1;
        c += 1;
        
        let mut i = r;
        while i <= self.rows {
            let mut j = c;
            while j <= self.cols {
                self.tree[i][j] += delta;
                j += j & (!j + 1);
            }
            i += i & (!i + 1);
        }
    }
    
    pub fn sum(&self, mut r: usize, mut c: usize) -> i64 {
        r += 1;
        c += 1;
        
        let mut sum = 0;
        let mut i = r;
        while i > 0 {
            let mut j = c;
            while j > 0 {
                sum += self.tree[i][j];
                j -= j & (!j + 1);
            }
            i -= i & (!i + 1);
        }
        sum
    }
}
```

### 2.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… åŠ¨æ€ç»´æŠ¤å‰ç¼€å’Œ
- âœ… åŒºé—´ä¿®æ”¹ + å•ç‚¹æŸ¥è¯¢ï¼ˆå·®åˆ†æ•°ç»„ï¼‰
- âœ… é€†åºå¯¹è®¡æ•°
- âœ… äºŒç»´çŸ©é˜µå‰ç¼€å’Œ

**ä¸é€‚ç”¨**:

- âŒ åŒºé—´æœ€å€¼æŸ¥è¯¢ï¼ˆä½¿ç”¨çº¿æ®µæ ‘ï¼‰
- âŒ åŒºé—´GCD/LCMï¼ˆä½¿ç”¨çº¿æ®µæ ‘ï¼‰

---

## 3. çº¿æ®µæ ‘ (Segment Tree)

### 3.1 æ¦‚è¿°

**åŠŸèƒ½**: æ”¯æŒåŒºé—´æŸ¥è¯¢å’ŒåŒºé—´ä¿®æ”¹ï¼ŒåŠŸèƒ½å¼ºäºæ ‘çŠ¶æ•°ç»„ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ„é€ : O(n)
- å•ç‚¹æ›´æ–°: O(log n)
- åŒºé—´æŸ¥è¯¢: O(log n)
- åŒºé—´ä¿®æ”¹ (æ‡’æ ‡è®°): O(log n)

**ç©ºé—´å¤æ‚åº¦**: O(n)

### 3.2 API æ–‡æ¡£

```rust
pub struct SegmentTree {
    tree: Vec<i64>,
    n: usize,
    identity: i64,
}

impl SegmentTree {
    /// ä»æ•°ç»„æ„é€ çº¿æ®µæ ‘
    ///
    /// # å‚æ•°
    /// - `arr`: åŸå§‹æ•°ç»„
    /// - `identity`: å•ä½å…ƒ (æ±‚å’Œä¸º0ï¼Œæ±‚æœ€å€¼ä¸ºi64::MAX/MIN)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn from_slice(arr: &[i64], identity: i64) -> Self;
    
    /// å•ç‚¹æ›´æ–°ï¼šè®¾ç½® arr[i] = value
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn update_point(&mut self, i: usize, value: i64);
    
    /// åŒºé—´æ±‚å’ŒæŸ¥è¯¢ [l, r)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn query_sum(&self, l: usize, r: usize) -> i64;
    
    /// åŒºé—´æœ€å°å€¼æŸ¥è¯¢ [l, r)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn query_min(&self, l: usize, r: usize) -> i64;
    
    /// åŒºé—´æœ€å¤§å€¼æŸ¥è¯¢ [l, r)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn query_max(&self, l: usize, r: usize) -> i64;
}
```

### 3.3 ä»£ç ç¤ºä¾‹

#### 3.3.1 åŸºç¡€ä½¿ç”¨

```rust
use c08_algorithms::data_structure::SegmentTree;

fn example_segment_tree() {
    let arr = vec![1, 3, 5, 7, 9, 11, 13, 15];
    let mut seg_tree = SegmentTree::from_slice(&arr, 0);
    
    // åŒºé—´æ±‚å’Œ [2, 6)
    let sum = seg_tree.query_sum(2, 6); // 5+7+9+11 = 32
    println!("sum[2, 6) = {}", sum);
    
    // å•ç‚¹æ›´æ–°: arr[4] = 20
    seg_tree.update_point(4, 20);
    
    // é‡æ–°æŸ¥è¯¢
    let new_sum = seg_tree.query_sum(2, 6); // 5+7+20+11 = 43
    println!("sum[2, 6) = {}", new_sum);
}
```

#### æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼ˆåŒºé—´ä¿®æ”¹ï¼‰

```rust
pub struct LazySegmentTree {
    tree: Vec<i64>,
    lazy: Vec<i64>, // æ‡’æ ‡è®°
    n: usize,
}

impl LazySegmentTree {
    pub fn new(n: usize) -> Self {
        LazySegmentTree {
            tree: vec![0; 4 * n],
            lazy: vec![0; 4 * n],
            n,
        }
    }
    
    // ä¸‹ä¼ æ‡’æ ‡è®°
    fn push_down(&mut self, node: usize, left: usize, right: usize) {
        if self.lazy[node] != 0 {
            let mid = (left + right) / 2;
            
            self.tree[2 * node] += self.lazy[node] * (mid - left) as i64;
            self.tree[2 * node + 1] += self.lazy[node] * (right - mid) as i64;
            
            self.lazy[2 * node] += self.lazy[node];
            self.lazy[2 * node + 1] += self.lazy[node];
            
            self.lazy[node] = 0;
        }
    }
    
    /// åŒºé—´ä¿®æ”¹ [l, r) += delta
    pub fn range_add(&mut self, l: usize, r: usize, delta: i64) {
        self.range_add_impl(1, 0, self.n, l, r, delta);
    }
    
    fn range_add_impl(&mut self, node: usize, left: usize, right: usize, 
                      l: usize, r: usize, delta: i64) {
        if r <= left || right <= l {
            return;
        }
        
        if l <= left && right <= r {
            self.tree[node] += delta * (right - left) as i64;
            self.lazy[node] += delta;
            return;
        }
        
        self.push_down(node, left, right);
        
        let mid = (left + right) / 2;
        self.range_add_impl(2 * node, left, mid, l, r, delta);
        self.range_add_impl(2 * node + 1, mid, right, l, r, delta);
        
        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1];
    }
    
    /// åŒºé—´æŸ¥è¯¢ [l, r)
    pub fn query(&mut self, l: usize, r: usize) -> i64 {
        self.query_impl(1, 0, self.n, l, r)
    }
    
    fn query_impl(&mut self, node: usize, left: usize, right: usize, 
                  l: usize, r: usize) -> i64 {
        if r <= left || right <= l {
            return 0;
        }
        
        if l <= left && right <= r {
            return self.tree[node];
        }
        
        self.push_down(node, left, right);
        
        let mid = (left + right) / 2;
        self.query_impl(2 * node, left, mid, l, r) + 
        self.query_impl(2 * node + 1, mid, right, l, r)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example_lazy_segment_tree() {
    let mut lazy_tree = LazySegmentTree::new(10);
    
    // åŒºé—´ [2, 6) += 5
    lazy_tree.range_add(2, 6, 5);
    
    // æŸ¥è¯¢ [3, 8)
    let sum = lazy_tree.query(3, 8);
    println!("sum[3, 8) = {}", sum); // (8-3) * 5 = 25
}
```

### 3.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… åŒºé—´æ±‚å’Œ/æœ€å€¼/GCD
- âœ… åŒºé—´ä¿®æ”¹ + åŒºé—´æŸ¥è¯¢ï¼ˆæ‡’æ ‡è®°ï¼‰
- âœ… å†å²ç‰ˆæœ¬æŸ¥è¯¢ï¼ˆå¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼‰
- âœ… äºŒç»´åŒºé—´æŸ¥è¯¢ï¼ˆçº¿æ®µæ ‘å¥—çº¿æ®µæ ‘ï¼‰

---

## 4. å¹¶æŸ¥é›† (Disjoint Set Union)

### 4.1 æ¦‚è¿°

**åŠŸèƒ½**: ç»´æŠ¤å…ƒç´ çš„é›†åˆåˆ’åˆ†ï¼Œæ”¯æŒé«˜æ•ˆçš„åˆå¹¶å’ŒæŸ¥è¯¢æ“ä½œã€‚

**æ—¶é—´å¤æ‚åº¦** (è·¯å¾„å‹ç¼© + æŒ‰ç§©åˆå¹¶):

- æ„é€ : O(n)
- æŸ¥æ‰¾: O(Î±(n)) â‰ˆ O(1)
- åˆå¹¶: O(Î±(n)) â‰ˆ O(1)

**ç©ºé—´å¤æ‚åº¦**: O(n)

### 4.2 API æ–‡æ¡£

```rust
pub struct DisjointSet {
    parent: Vec<usize>,
    rank: Vec<usize>,
}

impl DisjointSet {
    /// åˆ›å»º n ä¸ªç‹¬ç«‹é›†åˆ
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn new(n: usize) -> Self;
    
    /// æŸ¥æ‰¾å…ƒç´  x æ‰€åœ¨é›†åˆçš„ä»£è¡¨å…ƒ
    ///
    /// ä½¿ç”¨è·¯å¾„å‹ç¼©ä¼˜åŒ–
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(Î±(n))
    pub fn find(&mut self, x: usize) -> usize;
    
    /// åˆå¹¶å…ƒç´  x å’Œ y æ‰€åœ¨çš„é›†åˆ
    ///
    /// ä½¿ç”¨æŒ‰ç§©åˆå¹¶ä¼˜åŒ–
    ///
    /// # è¿”å›: æ˜¯å¦æˆåŠŸåˆå¹¶ (false è¡¨ç¤ºå·²åœ¨åŒä¸€é›†åˆ)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(Î±(n))
    pub fn union(&mut self, x: usize, y: usize) -> bool;
    
    /// åˆ¤æ–­ x å’Œ y æ˜¯å¦åœ¨åŒä¸€é›†åˆ
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(Î±(n))
    pub fn connected(&mut self, x: usize, y: usize) -> bool {
        self.find(x) == self.find(y)
    }
}
```

### 4.3 ä»£ç ç¤ºä¾‹

#### 4.3.1 åŸºç¡€ä½¿ç”¨

```rust
use c08_algorithms::data_structure::DisjointSet;

fn example_dsu_basic() {
    let mut dsu = DisjointSet::new(10);
    
    // åˆå¹¶æ“ä½œ
    dsu.union(0, 1);
    dsu.union(1, 2);
    dsu.union(3, 4);
    dsu.union(5, 6);
    dsu.union(6, 7);
    
    // æŸ¥è¯¢è¿é€šæ€§
    assert!(dsu.connected(0, 2));  // 0-1-2 è¿é€š
    assert!(dsu.connected(3, 4));  // 3-4 è¿é€š
    assert!(!dsu.connected(0, 3)); // 0 å’Œ 3 ä¸è¿é€š
    
    // åˆå¹¶ä¸¤ä¸ªé›†åˆ
    dsu.union(2, 3);
    assert!(dsu.connected(0, 4));  // ç°åœ¨ 0 å’Œ 4 è¿é€šäº†
}
```

#### Kruskal æœ€å°ç”Ÿæˆæ ‘

```rust
use c08_algorithms::graph::*;

fn kruskal_mst(n: usize, edges: &[(usize, usize, i64)]) -> (i64, Vec<(usize, usize)>) {
    let mut dsu = DisjointSet::new(n);
    let mut edges = edges.to_vec();
    
    // æŒ‰æƒé‡æ’åº
    edges.sort_by_key(|&(_, _, w)| w);
    
    let mut total_weight = 0;
    let mut mst_edges = Vec::new();
    
    for (u, v, weight) in edges {
        if dsu.union(u, v) {
            total_weight += weight;
            mst_edges.push((u, v));
            
            if mst_edges.len() == n - 1 {
                break;
            }
        }
    }
    
    (total_weight, mst_edges)
}
```

#### å¸¦æƒå¹¶æŸ¥é›†

```rust
pub struct WeightedDSU {
    parent: Vec<usize>,
    weight: Vec<i64>, // weight[x] = x åˆ° parent[x] çš„è·ç¦»
}

impl WeightedDSU {
    pub fn new(n: usize) -> Self {
        WeightedDSU {
            parent: (0..n).collect(),
            weight: vec![0; n],
        }
    }
    
    pub fn find(&mut self, x: usize) -> usize {
        if self.parent[x] != x {
            let root = self.find(self.parent[x]);
            self.weight[x] += self.weight[self.parent[x]];
            self.parent[x] = root;
        }
        self.parent[x]
    }
    
    // è¿æ¥ x å’Œ yï¼Œä½¿å¾— dist(x, y) = w
    pub fn union(&mut self, x: usize, y: usize, w: i64) -> bool {
        let rx = self.find(x);
        let ry = self.find(y);
        
        if rx == ry {
            return false;
        }
        
        self.parent[rx] = ry;
        self.weight[rx] = self.weight[y] - self.weight[x] + w;
        true
    }
    
    // æŸ¥è¯¢ x åˆ° y çš„è·ç¦»
    pub fn distance(&mut self, x: usize, y: usize) -> Option<i64> {
        if self.find(x) == self.find(y) {
            Some(self.weight[x] - self.weight[y])
        } else {
            None
        }
    }
}
```

### 4.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… è¿é€šæ€§åˆ¤æ–­
- âœ… Kruskal æœ€å°ç”Ÿæˆæ ‘
- âœ… ç­‰ä»·å…³ç³»ç»´æŠ¤
- âœ… æœ€è¿‘å…¬å…±ç¥–å…ˆ (LCA) ç¦»çº¿æŸ¥è¯¢

---

## 5. ä¼˜å…ˆé˜Ÿåˆ— (Priority Queue)

### 5.1 æ¦‚è¿°

**åŠŸèƒ½**: ç»´æŠ¤ä¸€ç»„å…ƒç´ ï¼Œæ”¯æŒå¿«é€Ÿè·å–å’Œåˆ é™¤æœ€å¤§/æœ€å°å…ƒç´ ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ„é€ : O(n) (heapify)
- æ’å…¥: O(log n)
- åˆ é™¤æœ€å€¼: O(log n)
- æŸ¥çœ‹æœ€å€¼: O(1)

**ç©ºé—´å¤æ‚åº¦**: O(n)

### 5.2 API æ–‡æ¡£

```rust
pub enum HeapKind {
    Min,
    Max,
}

pub struct PriorityQueue<T> {
    heap: Vec<T>,
    kind: HeapKind,
}

impl<T: Ord> PriorityQueue<T> {
    /// åˆ›å»ºç©ºçš„ä¼˜å…ˆé˜Ÿåˆ—
    pub fn new(kind: HeapKind) -> Self;
    
    /// ä»æ•°ç»„æ„é€ ä¼˜å…ˆé˜Ÿåˆ— (heapify)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn from_vec(vec: Vec<T>, kind: HeapKind) -> Self;
    
    /// æ’å…¥å…ƒç´ 
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn push(&mut self, item: T);
    
    /// åˆ é™¤å¹¶è¿”å›æœ€å€¼
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(log n)
    pub fn pop(&mut self) -> Option<T>;
    
    /// æŸ¥çœ‹æœ€å€¼ï¼ˆä¸åˆ é™¤ï¼‰
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(1)
    pub fn peek(&self) -> Option<&T>;
    
    /// é˜Ÿåˆ—å¤§å°
    pub fn len(&self) -> usize;
    
    /// æ˜¯å¦ä¸ºç©º
    pub fn is_empty(&self) -> bool;
}
```

### 5.3 ä»£ç ç¤ºä¾‹

#### 5.3.1 åŸºç¡€ä½¿ç”¨

```rust
use c08_algorithms::data_structure::*;

fn example_priority_queue() {
    // æœ€å°å †
    let mut min_heap = PriorityQueue::new(HeapKind::Min);
    
    min_heap.push(5);
    min_heap.push(2);
    min_heap.push(8);
    min_heap.push(1);
    
    while let Some(val) = min_heap.pop() {
        println!("{}", val); // 1, 2, 5, 8
    }
    
    // æœ€å¤§å †
    let mut max_heap = PriorityQueue::new(HeapKind::Max);
    
    max_heap.push(5);
    max_heap.push(2);
    max_heap.push(8);
    max_heap.push(1);
    
    while let Some(val) = max_heap.pop() {
        println!("{}", val); // 8, 5, 2, 1
    }
}
```

#### Dijkstra æœ€çŸ­è·¯å¾„

```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;

fn dijkstra(graph: &[Vec<(usize, i64)>], start: usize) -> Vec<i64> {
    let n = graph.len();
    let mut dist = vec![i64::MAX; n];
    let mut heap = BinaryHeap::new();
    
    dist[start] = 0;
    heap.push(Reverse((0, start)));
    
    while let Some(Reverse((d, u))) = heap.pop() {
        if d > dist[u] {
            continue;
        }
        
        for &(v, weight) in &graph[u] {
            let new_dist = d + weight;
            if new_dist < dist[v] {
                dist[v] = new_dist;
                heap.push(Reverse((new_dist, v)));
            }
        }
    }
    
    dist
}
```

#### Top-K é—®é¢˜

```rust
use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn find_top_k(nums: &[i32], k: usize) -> Vec<i32> {
    let mut min_heap = BinaryHeap::new();
    
    for &num in nums {
        min_heap.push(Reverse(num));
        
        if min_heap.len() > k {
            min_heap.pop();
        }
    }
    
    min_heap.into_iter()
        .map(|Reverse(x)| x)
        .collect()
}
```

### 5.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… Dijkstra æœ€çŸ­è·¯å¾„
- âœ… Huffman ç¼–ç 
- âœ… Top-K é—®é¢˜
- âœ… äº‹ä»¶è°ƒåº¦

---

## 6. ç¨€ç–è¡¨ (Sparse Table)

### 6.1 æ¦‚è¿°

**åŠŸèƒ½**: æ”¯æŒ O(1) æŸ¥è¯¢åŒºé—´å¹‚ç­‰è¿ç®—ï¼ˆå¦‚æœ€å°å€¼ã€æœ€å¤§å€¼ã€GCDï¼‰ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ„é€ : O(n log n)
- æŸ¥è¯¢: O(1)

**ç©ºé—´å¤æ‚åº¦**: O(n log n)

**é™åˆ¶**: åªæ”¯æŒå¹‚ç­‰è¿ç®—ï¼ˆf(x, x) = xï¼‰ï¼Œä¸å¯ä¿®æ”¹

### 6.2 API æ–‡æ¡£

```rust
pub struct SparseTable<T> {
    table: Vec<Vec<T>>,
    combine: fn(&T, &T) -> T,
}

impl<T: Clone> SparseTable<T> {
    /// æ„é€ ç¨€ç–è¡¨
    ///
    /// # å‚æ•°
    /// - `arr`: åŸå§‹æ•°ç»„
    /// - `combine`: å¹‚ç­‰è¿ç®—å‡½æ•° (å¦‚ min, max, gcd)
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n log n)
    pub fn build(arr: &[T], combine: fn(&T, &T) -> T) -> Self;
    
    /// æŸ¥è¯¢åŒºé—´ [l, r) çš„ç»“æœ
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(1)
    pub fn query_idempotent(&self, l: usize, r: usize) -> T;
}
```

### 6.3 ä»£ç ç¤ºä¾‹

#### RMQ (åŒºé—´æœ€å°å€¼æŸ¥è¯¢)

```rust
use c08_algorithms::data_structure::SparseTable;

fn example_rmq() {
    let arr = vec![3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
    
    // æ„é€ ç¨€ç–è¡¨
    let st = SparseTable::build(&arr, |a, b| *a.min(b));
    
    // O(1) æŸ¥è¯¢
    println!("min[2, 7) = {}", st.query_idempotent(2, 7)); // 1
    println!("min[0, 10) = {}", st.query_idempotent(0, 10)); // 1
    println!("min[5, 9) = {}", st.query_idempotent(5, 9)); // 2
}
```

#### åŒºé—´GCDæŸ¥è¯¢

```rust
fn gcd(a: i64, b: i64) -> i64 {
    if b == 0 { a } else { gcd(b, a % b) }
}

fn example_range_gcd() {
    let arr = vec![12, 18, 24, 36, 48];
    
    let st = SparseTable::build(&arr, |&a, &b| gcd(a, b));
    
    println!("gcd[0, 3) = {}", st.query_idempotent(0, 3)); // 6
    println!("gcd[2, 5) = {}", st.query_idempotent(2, 5)); // 12
}
```

### 6.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… é™æ€åŒºé—´ RMQ/RMaxQ
- âœ… åŒºé—´ GCD/LCM
- âœ… LCA (æœ€è¿‘å…¬å…±ç¥–å…ˆ)

**ä¸é€‚ç”¨**:

- âŒ éœ€è¦ä¿®æ”¹æ•°æ®ï¼ˆä½¿ç”¨çº¿æ®µæ ‘ï¼‰
- âŒ éå¹‚ç­‰è¿ç®—ï¼ˆä½¿ç”¨çº¿æ®µæ ‘ï¼‰

---

## 7. LRU ç¼“å­˜ (LRU Cache)

### 7.1 æ¦‚è¿°

**åŠŸèƒ½**: å›ºå®šå®¹é‡çš„ç¼“å­˜ï¼Œæ·˜æ±°æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„å…ƒç´ ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- get: O(1)
- put: O(1)

**ç©ºé—´å¤æ‚åº¦**: O(capacity)

### 7.2 API æ–‡æ¡£

```rust
use std::collections::HashMap;

pub struct LruCache<K, V> {
    capacity: usize,
    cache: HashMap<K, (V, usize)>, // (value, timestamp)
    timestamp: usize,
}

impl<K: Eq + Hash + Clone, V: Clone> LruCache<K, V> {
    /// åˆ›å»ºå®¹é‡ä¸º capacity çš„ LRU ç¼“å­˜
    pub fn new(capacity: usize) -> Self;
    
    /// è·å–ç¼“å­˜å€¼
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(1)
    pub fn get(&mut self, key: &K) -> Option<&V>;
    
    /// æ’å…¥ç¼“å­˜
    ///
    /// å¦‚æœè¶…å‡ºå®¹é‡ï¼Œæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„å…ƒç´ 
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(1)
    pub fn put(&mut self, key: K, value: V);
    
    /// ç¼“å­˜å¤§å°
    pub fn len(&self) -> usize;
    
    /// æ˜¯å¦åŒ…å«é”®
    pub fn contains_key(&self, key: &K) -> bool;
}
```

### 7.3 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::data_structure::LruCache;

fn example_lru_cache() {
    let mut cache = LruCache::new(2);
    
    cache.put(1, "one");
    cache.put(2, "two");
    
    assert_eq!(cache.get(&1), Some(&"one"));
    
    cache.put(3, "three"); // æ·˜æ±° key=2
    
    assert_eq!(cache.get(&2), None);
    assert_eq!(cache.get(&3), Some(&"three"));
    
    cache.put(4, "four"); // æ·˜æ±° key=1
    
    assert_eq!(cache.get(&1), None);
    assert_eq!(cache.get(&3), Some(&"three"));
    assert_eq!(cache.get(&4), Some(&"four"));
}
```

### 7.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… æ•°æ®åº“æŸ¥è¯¢ç¼“å­˜
- âœ… HTTP ç¼“å­˜
- âœ… é¡µé¢ç¼“å­˜

---

## 8. Trie (å­—å…¸æ ‘)

### 8.1 æ¦‚è¿°

**åŠŸèƒ½**: é«˜æ•ˆå­˜å‚¨å’Œæ£€ç´¢å­—ç¬¦ä¸²é›†åˆï¼Œæ”¯æŒå‰ç¼€åŒ¹é…ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ’å…¥: O(m)
- æŸ¥è¯¢: O(m)
- å‰ç¼€åŒ¹é…: O(m + k)

å…¶ä¸­ m æ˜¯å­—ç¬¦ä¸²é•¿åº¦ï¼Œk æ˜¯åŒ¹é…ç»“æœæ•°é‡ã€‚

**ç©ºé—´å¤æ‚åº¦**: O(æ€»å­—ç¬¦æ•° Ã— å­—ç¬¦é›†å¤§å°)

### 8.2 API æ–‡æ¡£

```rust
pub struct Trie {
    children: HashMap<u8, Box<Trie>>,
    is_end: bool,
}

impl Trie {
    /// åˆ›å»ºç©ºçš„ Trie
    pub fn new() -> Self;
    
    /// æ’å…¥å­—ç¬¦ä¸²
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(m)
    pub fn insert(&mut self, word: &[u8]);
    
    /// æŸ¥è¯¢å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(m)
    pub fn search(&self, word: &[u8]) -> bool;
    
    /// æŸ¥è¯¢æ˜¯å¦å­˜åœ¨ä»¥ prefix å¼€å¤´çš„å­—ç¬¦ä¸²
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(m)
    pub fn starts_with(&self, prefix: &[u8]) -> bool;
}
```

### 8.3 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::string_algorithms::Trie;

fn example_trie() {
    let mut trie = Trie::new();
    
    // æ’å…¥å•è¯
    trie.insert(b"apple");
    trie.insert(b"app");
    trie.insert(b"application");
    
    // æŸ¥è¯¢
    assert!(trie.search(b"apple"));
    assert!(trie.search(b"app"));
    assert!(!trie.search(b"appl")); // ä¸æ˜¯å®Œæ•´å•è¯
    
    // å‰ç¼€åŒ¹é…
    assert!(trie.starts_with(b"app")); // "app", "apple", "application"
    assert!(trie.starts_with(b"appl")); // "apple", "application"
    assert!(!trie.starts_with(b"orange"));
}
```

### 8.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… è‡ªåŠ¨è¡¥å…¨
- âœ… æ‹¼å†™æ£€æŸ¥
- âœ… IP è·¯ç”±

---

## 9. åç¼€æ•°ç»„ (Suffix Array)

### 9.1 æ¦‚è¿°

**åŠŸèƒ½**: å­—ç¬¦ä¸²çš„æ‰€æœ‰åç¼€æŒ‰å­—å…¸åºæ’åºçš„æ•°ç»„ï¼Œæ”¯æŒé«˜æ•ˆçš„å­ä¸²æŸ¥è¯¢ã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ„é€ : O(n log n)
- LCP è®¡ç®—: O(n)

**ç©ºé—´å¤æ‚åº¦**: O(n)

### 9.2 API æ–‡æ¡£

```rust
/// æ„é€ åç¼€æ•°ç»„
///
/// # è¿”å›: åç¼€æ•°ç»„ (ç´¢å¼•æ•°ç»„)
///
/// # æ—¶é—´å¤æ‚åº¦: O(n log n)
pub fn suffix_array(text: &[u8]) -> Vec<usize>;

/// è®¡ç®— LCP (æœ€é•¿å…¬å…±å‰ç¼€) æ•°ç»„
///
/// # å‚æ•°
/// - `text`: åŸå§‹æ–‡æœ¬
/// - `sa`: åç¼€æ•°ç»„
///
/// # è¿”å›: LCPæ•°ç»„ï¼Œlcp[i] = lcp(sa[i], sa[i+1])
///
/// # æ—¶é—´å¤æ‚åº¦: O(n)
pub fn lcp_kasai(text: &[u8], sa: &[usize]) -> Vec<usize>;
```

### 9.3 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::string_algorithms::*;

fn example_suffix_array() {
    let text = b"banana";
    let sa = suffix_array(text);
    let lcp = lcp_kasai(text, &sa);
    
    println!("åç¼€æ•°ç»„:");
    for (i, &pos) in sa.iter().enumerate() {
        let suffix = &text[pos..];
        println!("{}. sa[{}]={} -> {}", 
                 i, i, pos, String::from_utf8_lossy(suffix));
    }
    // è¾“å‡º:
    // 0. sa[0]=5 -> a
    // 1. sa[1]=3 -> ana
    // 2. sa[2]=1 -> anana
    // 3. sa[3]=0 -> banana
    // 4. sa[4]=4 -> na
    // 5. sa[5]=2 -> nana
    
    println!("\nLCPæ•°ç»„: {:?}", lcp); // [1, 3, 0, 0, 2]
}
```

### 9.4 ä½¿ç”¨åœºæ™¯

**é€‚ç”¨**:

- âœ… æŸ¥æ‰¾æœ€é•¿é‡å¤å­ä¸²
- âœ… å­—ç¬¦ä¸²åŒ¹é…
- âœ… åç¼€æ ‘çš„æ›¿ä»£æ–¹æ¡ˆ

---

## 10. åç¼€è‡ªåŠ¨æœº (Suffix Automaton)

### 10.1 æ¦‚è¿°

**åŠŸèƒ½**: è¯†åˆ«å­—ç¬¦ä¸²æ‰€æœ‰å­ä¸²çš„æœ€å°ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºã€‚

**æ—¶é—´å¤æ‚åº¦**:

- æ„é€ : O(n)
- æŸ¥è¯¢: O(m)

**ç©ºé—´å¤æ‚åº¦**: O(n) ä¸ªçŠ¶æ€

### 10.2 API æ–‡æ¡£

```rust
pub struct SuffixAutomaton {
    states: Vec<State>,
    last: usize,
}

impl SuffixAutomaton {
    /// ä»å­—ç¬¦ä¸²æ„é€ åç¼€è‡ªåŠ¨æœº
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn from_bytes(text: &[u8]) -> Self;
    
    /// è®¡ç®—ä¸åŒå­ä¸²æ•°é‡
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn count_distinct_substrings(&self) -> usize;
    
    /// æŸ¥æ‰¾ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­ä¸²
    ///
    /// # æ—¶é—´å¤æ‚åº¦: O(m)
    pub fn longest_common_substring(&self, text2: &[u8]) -> usize;
}
```

### 10.3 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::string_algorithms::SuffixAutomaton;

fn example_suffix_automaton() {
    let text1 = b"abcbc";
    let sa = SuffixAutomaton::from_bytes(text1);
    
    // è®¡ç®—ä¸åŒå­ä¸²æ•°é‡
    let count = sa.count_distinct_substrings();
    println!("ä¸åŒå­ä¸²æ•°é‡: {}", count); // 12
    
    // æœ€é•¿å…¬å…±å­ä¸²
    let text2 = b"bcde";
    let lcs_len = sa.longest_common_substring(text2);
    println!("æœ€é•¿å…¬å…±å­ä¸²é•¿åº¦: {}", lcs_len); // 3 ("bcd")
}
```

---

## 11. æ€§èƒ½å¯¹æ¯”

### 11.1 åŒºé—´æŸ¥è¯¢æ•°æ®ç»“æ„å¯¹æ¯”

| æ•°æ®ç»“æ„ | æ„é€  | å•ç‚¹æ›´æ–° | åŒºé—´æŸ¥è¯¢ | åŒºé—´æ›´æ–° | æ”¯æŒæ“ä½œ |
|---------|------|---------|---------|---------|---------|
| **Fenwick Tree** | O(n) | O(log n) | O(log n) | O(log n)* | å‰ç¼€å’Œã€åŒºé—´å’Œ |
| **Segment Tree** | O(n) | O(log n) | O(log n) | O(log n) | ä»»æ„å¯åˆå¹¶æ“ä½œ |
| **Sparse Table** | O(n log n) | âŒ | O(1) | âŒ | å¹‚ç­‰æ“ä½œ (RMQ, GCD) |

*éœ€è¦å·®åˆ†æ•°ç»„æŠ€å·§

### 11.2 å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•å¯¹æ¯”

| ç®—æ³• | é¢„å¤„ç† | åŒ¹é… | ç©ºé—´ | ç‰¹ç‚¹ |
|------|--------|------|------|------|
| **KMP** | O(m) | O(n+m) | O(m) | å•æ¨¡å¼ï¼Œæ— å›æº¯ |
| **Rabin-Karp** | O(m) | O(n+m) | O(1) | å“ˆå¸ŒåŒ¹é…ï¼Œæ”¯æŒå¤šæ¨¡å¼ |
| **Aho-Corasick** | O(Î£m) | O(n+z) | O(Î£m) | å¤šæ¨¡å¼ï¼ŒACè‡ªåŠ¨æœº |
| **Boyer-Moore** | O(m+Î£) | O(n/m)å¹³å‡ | O(m+Î£) | å®è·µæœ€å¿« |
| **Suffix Array** | O(n log n) | O(m log n) | O(n) | æ”¯æŒå¤æ‚æŸ¥è¯¢ |
| **Suffix Automaton** | O(n) | O(m) | O(n) | æœ€å°DFA |

### 11.3 åŸºå‡†æµ‹è¯•æ•°æ®

```rust
// n = 1,000,000 çš„æ€§èƒ½æµ‹è¯•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ•°æ®ç»“æ„        â”‚ æ„é€      â”‚ æŸ¥è¯¢     â”‚ æ›´æ–°     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Fenwick Tree    â”‚ 5 ms     â”‚ 0.1 Î¼s   â”‚ 0.1 Î¼s   â”‚
â”‚ Segment Tree    â”‚ 8 ms     â”‚ 0.2 Î¼s   â”‚ 0.2 Î¼s   â”‚
â”‚ Sparse Table    â”‚ 50 ms    â”‚ 0.01 Î¼s  â”‚ N/A      â”‚
â”‚ DSU             â”‚ 2 ms     â”‚ 0.05 Î¼s  â”‚ 0.05 Î¼s  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 12. é€‰æ‹©æŒ‡å—

### 12.1 åŒºé—´æŸ¥è¯¢åœºæ™¯

```rust
fn choose_range_query_ds(problem: &str) -> &'static str {
    match problem {
        "å‰ç¼€å’Œ/åŒºé—´å’Œ" => "Fenwick Tree (æ ‘çŠ¶æ•°ç»„)",
        "åŒºé—´æœ€å€¼" if é™æ€ => "Sparse Table",
        "åŒºé—´æœ€å€¼" if åŠ¨æ€ => "Segment Tree",
        "åŒºé—´GCD/LCM" => "Segment Tree",
        "åŒºé—´ä¿®æ”¹ + åŒºé—´æŸ¥è¯¢" => "Lazy Segment Tree",
        _ => "æŸ¥é˜…æ–‡æ¡£",
    }
}
```

### 12.2 å­—ç¬¦ä¸²åŒ¹é…åœºæ™¯

```rust
fn choose_string_matching(problem: &str) -> &'static str {
    match problem {
        "å•æ¨¡å¼åŒ¹é…" => "KMP æˆ– Boyer-Moore",
        "å¤šæ¨¡å¼åŒ¹é…" => "Aho-Corasick",
        "åç¼€æŸ¥è¯¢" => "Suffix Array æˆ– Suffix Automaton",
        "æœ€é•¿é‡å¤å­ä¸²" => "Suffix Array + LCP",
        "ä¸åŒå­ä¸²è®¡æ•°" => "Suffix Automaton",
        _ => "æŸ¥é˜…æ–‡æ¡£",
    }
}
```

### 12.3 å¹¶å‘å®‰å…¨

```rust
// C08 æä¾›çº¿ç¨‹å®‰å…¨çš„ LRU Cache
#[cfg(feature = "thread_safe")]
pub struct ThreadSafeLruCache<K, V> {
    cache: Arc<Mutex<LruCache<K, V>>>,
}

impl<K: Eq + Hash + Clone, V: Clone> ThreadSafeLruCache<K, V> {
    pub fn new(capacity: usize) -> Self;
    
    pub fn get(&self, key: &K) -> Option<V> {
        self.cache.lock().unwrap().get(key).cloned()
    }
    
    pub fn put(&self, key: K, value: V) {
        self.cache.lock().unwrap().put(key, value);
    }
}
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- **[01_ç®—æ³•åˆ†ç±»å‚è€ƒ](./01_ç®—æ³•åˆ†ç±»å‚è€ƒ.md)** - ç®—æ³•å®Œæ•´ç´¢å¼•
- **[03_Rust190ç‰¹æ€§å‚è€ƒ](./03_Rust190ç‰¹æ€§å‚è€ƒ.md)** - Rust 1.90 æ–°ç‰¹æ€§åº”ç”¨
- **[04_ç®—æ³•æ€§èƒ½å‚è€ƒ](./04_ç®—æ³•æ€§èƒ½å‚è€ƒ.md)** - æ€§èƒ½åŸºå‡†æµ‹è¯•

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23  
**è´¨é‡è¯„åˆ†**: â­â­â­â­â­
