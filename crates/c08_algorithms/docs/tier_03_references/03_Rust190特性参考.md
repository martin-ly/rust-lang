# Rust 1.90 ç‰¹æ€§åœ¨ç®—æ³•ä¸­çš„åº”ç”¨

> **æ–‡æ¡£ç±»å‹**: Tier 3 æŠ€æœ¯å‚è€ƒ
> **ç›®æ ‡è¯»è€…**: éœ€è¦äº†è§£ Rust æœ€æ–°ç‰¹æ€§çš„å¼€å‘è€…
> **Rust ç‰ˆæœ¬**: 1.90+
> **Edition**: 2024
> **æœ€åæ›´æ–°**: 2025-10-23

---

## ğŸ“– ç›®å½•

- [Rust 1.90 ç‰¹æ€§åœ¨ç®—æ³•ä¸­çš„åº”ç”¨](#rust-190-ç‰¹æ€§åœ¨ç®—æ³•ä¸­çš„åº”ç”¨)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸»è¦æ–°ç‰¹æ€§](#11-ä¸»è¦æ–°ç‰¹æ€§)
  - [2. Edition 2024 æ ¸å¿ƒç‰¹æ€§](#2-edition-2024-æ ¸å¿ƒç‰¹æ€§)
    - [2.1 let-else è¯­æ³•](#21-let-else-è¯­æ³•)
      - [ä¼ ç»Ÿå†™æ³• vs Edition 2024](#ä¼ ç»Ÿå†™æ³•-vs-edition-2024)
      - [å®é™…åº”ç”¨ï¼šå›¾ç®—æ³•](#å®é™…åº”ç”¨å›¾ç®—æ³•)
  - [3. å¼‚æ­¥ç‰¹æ€§å¢å¼º](#3-å¼‚æ­¥ç‰¹æ€§å¢å¼º)
    - [3.1 å¼‚æ­¥é—­åŒ… (Async Closures)](#31-å¼‚æ­¥é—­åŒ…-async-closures)
      - [ä¼ ç»Ÿå†™æ³• vs Rust 1.90](#ä¼ ç»Ÿå†™æ³•-vs-rust-190)
      - [å®é™…åº”ç”¨ï¼šå¼‚æ­¥å›¾éå†](#å®é™…åº”ç”¨å¼‚æ­¥å›¾éå†)
  - [4. ç±»å‹ç³»ç»Ÿå¢å¼º](#4-ç±»å‹ç³»ç»Ÿå¢å¼º)
    - [4.1 GAT (Generic Associated Types) ç¨³å®š](#41-gat-generic-associated-types-ç¨³å®š)
      - [é›¶æ‹·è´å¼‚æ­¥è¿­ä»£å™¨](#é›¶æ‹·è´å¼‚æ­¥è¿­ä»£å™¨)
      - [å®é™…åº”ç”¨ï¼šå¼‚æ­¥å›¾è¿­ä»£å™¨](#å®é™…åº”ç”¨å¼‚æ­¥å›¾è¿­ä»£å™¨)
    - [4.2 RPITIT (Return Position Impl Trait in Traits)](#42-rpitit-return-position-impl-trait-in-traits)
  - [5. æ¨¡å¼åŒ¹é…å¢å¼º](#5-æ¨¡å¼åŒ¹é…å¢å¼º)
    - [5.1 if-let é“¾å¼åŒ¹é…](#51-if-let-é“¾å¼åŒ¹é…)
  - [6. è¿­ä»£å™¨å¢å¼º](#6-è¿­ä»£å™¨å¢å¼º)
    - [6.1 å†…è” const è¡¨è¾¾å¼](#61-å†…è”-const-è¡¨è¾¾å¼)
    - [6.2 æ”¹è¿›çš„è¿­ä»£å™¨ç»„åˆå­](#62-æ”¹è¿›çš„è¿­ä»£å™¨ç»„åˆå­)
  - [7. é”™è¯¯å¤„ç†å¢å¼º](#7-é”™è¯¯å¤„ç†å¢å¼º)
    - [7.1 Result ç»„åˆå­å¢å¼º](#71-result-ç»„åˆå­å¢å¼º)
  - [8. æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§](#8-æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§)
    - [8.1 const fn å¢å¼º](#81-const-fn-å¢å¼º)
    - [8.2 å†…è”ä¼˜åŒ–](#82-å†…è”ä¼˜åŒ–)
  - [9. ç®—æ³•å®è·µæ¡ˆä¾‹](#9-ç®—æ³•å®è·µæ¡ˆä¾‹)
    - [9.1 å®Œæ•´æ¡ˆä¾‹ï¼šå¼‚æ­¥å¹¶è¡Œå¿«é€Ÿæ’åº](#91-å®Œæ•´æ¡ˆä¾‹å¼‚æ­¥å¹¶è¡Œå¿«é€Ÿæ’åº)
    - [9.2 å®Œæ•´æ¡ˆä¾‹ï¼šGAT å®ç°é›¶æ‹·è´æµå¼ç®—æ³•](#92-å®Œæ•´æ¡ˆä¾‹gat-å®ç°é›¶æ‹·è´æµå¼ç®—æ³•)
  - [10. è¿ç§»æŒ‡å—](#10-è¿ç§»æŒ‡å—)
    - [10.1 ä» Rust 1.75 è¿ç§»åˆ° 1.90](#101-ä»-rust-175-è¿ç§»åˆ°-190)
    - [10.2 Edition 2021 â†’ 2024 è¿ç§»](#102-edition-2021--2024-è¿ç§»)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

Rust 1.90 å’Œ Edition 2024 å¸¦æ¥äº†ä¸€ç³»åˆ—é‡è¦ç‰¹æ€§ï¼Œæ˜¾è‘—æå‡äº†ç®—æ³•å®ç°çš„è¡¨è¾¾åŠ›ã€æ€§èƒ½å’Œå®‰å…¨æ€§ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»è¿™äº›æ–°ç‰¹æ€§åœ¨ C08 Algorithms æ¨¡å—ä¸­çš„åº”ç”¨ã€‚

### 1.1 ä¸»è¦æ–°ç‰¹æ€§

| ç‰¹æ€§ | Rust ç‰ˆæœ¬ | å½±å“ |
 param($match) $match.Value -replace '[-:]+', ' --- ' ----------- param($match) $match.Value -replace '[-:]+', ' --- ' 
| **å¼‚æ­¥é—­åŒ… (Async Closures)** | 1.90+ | â­â­â­â­â­ å¼‚æ­¥ç®—æ³•ç®€åŒ– |
| **let-else è¯­æ³•** | 1.65+ (2024 Edition) | â­â­â­â­ é”™è¯¯å¤„ç†ç®€åŒ– |
| **RPITIT (è¿”å›ä½ç½® impl Trait)** | 1.75+ | â­â­â­â­ Trait è®¾è®¡ç®€åŒ– |
| **GAT (æ³›å‹å…³è”ç±»å‹) ç¨³å®š** | 1.65+ | â­â­â­â­ é›¶æ‹·è´è¿­ä»£å™¨ |
| **å†…è” const è¡¨è¾¾å¼** | 1.79+ | â­â­â­ ç¼–è¯‘æ—¶è®¡ç®— |
| **æ”¹è¿›çš„ç±»å‹æ¨æ–­** | 1.90 | â­â­â­ å‡å°‘ç±»å‹æ ‡æ³¨ |

---

## 2. Edition 2024 æ ¸å¿ƒç‰¹æ€§

### 2.1 let-else è¯­æ³•

**åŠŸèƒ½**: æå‰è¿”å› + æ¨¡å¼åŒ¹é…çš„ç®€æ´è¯­æ³•ã€‚

#### ä¼ ç»Ÿå†™æ³• vs Edition 2024

```rust
// âŒ ä¼ ç»Ÿå†™æ³•ï¼šåµŒå¥— if-let
pub fn binary_search_sync<T: Ord>(arr: &[T], target: T) -> Option<usize> {
    if arr.is_empty() {
        return None;
    }

    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;

        match arr[mid].cmp(&target) {
            Ordering::Equal => return Some(mid),
            Ordering::Less => left = mid + 1,
            Ordering::Greater => right = mid,
        }
    }

    None
}

// âœ… Edition 2024ï¼šlet-else ç®€åŒ–
pub fn binary_search_sync<T: Ord>(arr: &[T], target: T) -> Option<usize> {
    let Some(first) = arr.first() else {
        return None;
    };

    // æå‰æ£€æŸ¥è¾¹ç•Œ
    let Some(last) = arr.last() else {
        return None;
    };

    if target < *first || target > *last {
        return None;
    }

    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;

        match arr[mid].cmp(&target) {
            Ordering::Equal => return Some(mid),
            Ordering::Less => left = mid + 1,
            Ordering::Greater => right = mid,
        }
    }

    None
}
```

#### å®é™…åº”ç”¨ï¼šå›¾ç®—æ³•

```rust
use std::collections::VecDeque;

// Dijkstra æœ€çŸ­è·¯å¾„ï¼šEdition 2024 ç‰ˆæœ¬
pub fn dijkstra_sync(graph: &[Vec<(usize, i64)>], start: usize) -> Vec<i64> {
    let n = graph.len();

    // let-else éªŒè¯èµ·ç‚¹
    let Some(start_edges) = graph.get(start) else {
        return vec![i64::MAX; n];
    };

    let mut dist = vec![i64::MAX; n];
    dist[start] = 0;

    let mut visited = vec![false; n];

    for _ in 0..n {
        // æ‰¾åˆ°æœªè®¿é—®çš„æœ€å°è·ç¦»èŠ‚ç‚¹
        let Some((u, min_dist)) = (0..n)
            .filter(|&i| !visited[i] && dist[i] != i64::MAX)
            .map(|i| (i, dist[i]))
            .min_by_key(|&(_, d)| d)
        else {
            break; // æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹å·²è®¿é—®
        };

        visited[u] = true;

        // æ¾å¼›é‚»è¾¹
        for &(v, weight) in &graph[u] {
            let new_dist = min_dist.saturating_add(weight);
            if new_dist < dist[v] {
                dist[v] = new_dist;
            }
        }
    }

    dist
}
```

---

## 3. å¼‚æ­¥ç‰¹æ€§å¢å¼º

### 3.1 å¼‚æ­¥é—­åŒ… (Async Closures)

**åŠŸèƒ½**: Rust 1.90+ æ”¯æŒåŸç”Ÿå¼‚æ­¥é—­åŒ…ï¼Œæ— éœ€æ‰‹åŠ¨å®ç° `Future`ã€‚

#### ä¼ ç»Ÿå†™æ³• vs Rust 1.90

```rust
use tokio::task;

// âŒ Rust 1.75-1.89ï¼šæ‰‹åŠ¨åŒ…è£…å¼‚æ­¥é—­åŒ…
pub async fn parallel_map_async<T, U, F>(
    items: Vec<T>,
    mut f: F,
) -> Vec<U>
where
    T: Send + 'static,
    U: Send + 'static,
    F: FnMut(T) -> Pin<Box<dyn Future<Output = U> + Send>> + Send + 'static,
{
    let tasks: Vec<_> = items
        .into_iter()
        .map(|item| task::spawn(f(item)))
        .collect();

    let mut results = Vec::new();
    for task in tasks {
        results.push(task.await.unwrap());
    }
    results
}

// âœ… Rust 1.90+ï¼šåŸç”Ÿå¼‚æ­¥é—­åŒ…
pub async fn parallel_map_async<T, U, F, Fut>(
    items: Vec<T>,
    f: F,
) -> Vec<U>
where
    T: Send + 'static,
    U: Send + 'static,
    F: Fn(T) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = U> + Send,
{
    let tasks: Vec<_> = items
        .into_iter()
        .map(|item| task::spawn(f(item)))
        .collect();

    futures::future::join_all(tasks)
        .await
        .into_iter()
        .map(|r| r.unwrap())
        .collect()
}

// ä½¿ç”¨ç¤ºä¾‹
async fn example_async_closures() {
    let nums = vec![1, 2, 3, 4, 5];

    // å¼‚æ­¥é—­åŒ…ç›´æ¥ä½¿ç”¨
    let results = parallel_map_async(nums, async |x| {
        tokio::time::sleep(Duration::from_millis(100)).await;
        x * x
    }).await;

    println!("ç»“æœ: {:?}", results); // [1, 4, 9, 16, 25]
}
```

#### å®é™…åº”ç”¨ï¼šå¼‚æ­¥å›¾éå†

```rust
use tokio::task;
use std::collections::HashSet;

// å¼‚æ­¥ DFSï¼šä½¿ç”¨å¼‚æ­¥é—­åŒ…è¿›è¡ŒèŠ‚ç‚¹å¤„ç†
pub async fn dfs_async_with_processor<F, Fut>(
    graph: &[Vec<usize>],
    start: usize,
    process_node: F,
) -> HashSet<usize>
where
    F: Fn(usize) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = ()> + Send,
{
    let mut visited = HashSet::new();
    let mut stack = vec![start];

    while let Some(node) = stack.pop() {
        if visited.insert(node) {
            // å¼‚æ­¥å¤„ç†èŠ‚ç‚¹
            process_node(node).await;

            // æ·»åŠ é‚»å±…åˆ°æ ˆ
            for &neighbor in &graph[node] {
                if !visited.contains(&neighbor) {
                    stack.push(neighbor);
                }
            }
        }
    }

    visited
}

// ä½¿ç”¨ç¤ºä¾‹
async fn example_async_dfs() {
    let graph = vec![
        vec![1, 2],    // 0 -> 1, 2
        vec![3],       // 1 -> 3
        vec![3, 4],    // 2 -> 3, 4
        vec![],        // 3 -> æ— 
        vec![],        // 4 -> æ— 
    ];

    let visited = dfs_async_with_processor(&graph, 0, async |node| {
        // æ¨¡æ‹Ÿå¼‚æ­¥I/Oæ“ä½œ
        println!("è®¿é—®èŠ‚ç‚¹: {}", node);
        tokio::time::sleep(Duration::from_millis(10)).await;
    }).await;

    println!("è®¿é—®çš„èŠ‚ç‚¹: {:?}", visited);
}
```

---

## 4. ç±»å‹ç³»ç»Ÿå¢å¼º

### 4.1 GAT (Generic Associated Types) ç¨³å®š

**åŠŸèƒ½**: æ”¯æŒå…³è”ç±»å‹çš„æ³›å‹å‚æ•°ï¼Œå®ç°é›¶æ‹·è´è¿­ä»£å™¨ã€‚

#### é›¶æ‹·è´å¼‚æ­¥è¿­ä»£å™¨

```rust
use std::pin::Pin;
use std::future::Future;

// GAT å®šä¹‰å¼‚æ­¥è¿­ä»£å™¨ Trait
pub trait AsyncIterator {
    type Item;

    // GAT: å…³è”ç±»å‹å¸¦ç”Ÿå‘½å‘¨æœŸå‚æ•°
    fn next<'a>(&'a mut self) -> Pin<Box<dyn Future<Output = Option<Self::Item>> + 'a>>;
}

// å®ç°å¼‚æ­¥èŒƒå›´è¿­ä»£å™¨
pub struct AsyncRange {
    current: i32,
    end: i32,
}

impl AsyncRange {
    pub fn new(start: i32, end: i32) -> Self {
        AsyncRange {
            current: start,
            end,
        }
    }
}

impl AsyncIterator for AsyncRange {
    type Item = i32;

    fn next<'a>(&'a mut self) -> Pin<Box<dyn Future<Output = Option<Self::Item>> + 'a>> {
        Box::pin(async move {
            if self.current < self.end {
                let value = self.current;
                self.current += 1;

                // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
                tokio::time::sleep(Duration::from_millis(10)).await;

                Some(value)
            } else {
                None
            }
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn example_gat_async_iterator() {
    let mut iter = AsyncRange::new(1, 6);

    while let Some(value) = iter.next().await {
        println!("å¼‚æ­¥è¿­ä»£å€¼: {}", value);
    }
}
```

#### å®é™…åº”ç”¨ï¼šå¼‚æ­¥å›¾è¿­ä»£å™¨

```rust
pub struct AsyncGraphIterator<'a> {
    graph: &'a [Vec<usize>],
    visited: HashSet<usize>,
    queue: VecDeque<usize>,
}

impl<'a> AsyncGraphIterator<'a> {
    pub fn new(graph: &'a [Vec<usize>], start: usize) -> Self {
        let mut queue = VecDeque::new();
        queue.push_back(start);

        AsyncGraphIterator {
            graph,
            visited: HashSet::new(),
            queue,
        }
    }
}

impl<'a> AsyncIterator for AsyncGraphIterator<'a> {
    type Item = usize;

    fn next<'b>(&'b mut self) -> Pin<Box<dyn Future<Output = Option<Self::Item>> + 'b>> {
        Box::pin(async move {
            while let Some(node) = self.queue.pop_front() {
                if self.visited.insert(node) {
                    // æ·»åŠ é‚»å±…
                    for &neighbor in &self.graph[node] {
                        if !self.visited.contains(&neighbor) {
                            self.queue.push_back(neighbor);
                        }
                    }

                    // æ¨¡æ‹Ÿå¼‚æ­¥èŠ‚ç‚¹å¤„ç†
                    tokio::time::sleep(Duration::from_millis(5)).await;

                    return Some(node);
                }
            }

            None
        })
    }
}
```

### 4.2 RPITIT (Return Position Impl Trait in Traits)

**åŠŸèƒ½**: å…è®¸ Trait æ–¹æ³•è¿”å› `impl Trait`ï¼Œæ— éœ€æ‰‹åŠ¨å®šä¹‰å…³è”ç±»å‹ã€‚

```rust
// âŒ Rust 1.70 ä¹‹å‰ï¼šéœ€è¦å…³è”ç±»å‹
pub trait AlgorithmOld {
    type Output;
    fn compute(&self, input: &[i32]) -> Self::Output;
}

// âœ… Rust 1.75+ï¼šç›´æ¥è¿”å› impl Trait
pub trait Algorithm {
    fn compute(&self, input: &[i32]) -> impl Iterator<Item = i32>;
}

// å®ç°æ’åºç®—æ³•
pub struct QuickSort;

impl Algorithm for QuickSort {
    fn compute(&self, input: &[i32]) -> impl Iterator<Item = i32> {
        let mut sorted = input.to_vec();
        sorted.sort_unstable();
        sorted.into_iter()
    }
}

// å®ç°è¿‡æ»¤ç®—æ³•
pub struct Filter {
    threshold: i32,
}

impl Algorithm for Filter {
    fn compute(&self, input: &[i32]) -> impl Iterator<Item = i32> {
        let threshold = self.threshold;
        input.iter().copied().filter(move |&x| x > threshold)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example_rpitit() {
    let data = vec![3, 1, 4, 1, 5, 9, 2, 6];

    let sorter = QuickSort;
    let sorted: Vec<_> = sorter.compute(&data).collect();
    println!("æ’åºç»“æœ: {:?}", sorted); // [1, 1, 2, 3, 4, 5, 6, 9]

    let filter = Filter { threshold: 4 };
    let filtered: Vec<_> = filter.compute(&data).collect();
    println!("è¿‡æ»¤ç»“æœ: {:?}", filtered); // [5, 9, 6]
}
```

---

## 5. æ¨¡å¼åŒ¹é…å¢å¼º

### 5.1 if-let é“¾å¼åŒ¹é…

**åŠŸèƒ½**: Edition 2024 å…è®¸ `if let` å’Œ `let else` ç»„åˆä½¿ç”¨ã€‚

```rust
// å¤æ‚çš„å›¾æœç´¢ç¤ºä¾‹
pub fn find_path(
    graph: &[Vec<usize>],
    start: usize,
    end: usize,
) -> Option<Vec<usize>> {
    let Some(start_neighbors) = graph.get(start) else {
        return None;
    };

    if start == end {
        return Some(vec![start]);
    }

    let mut queue = VecDeque::new();
    let mut parent = vec![None; graph.len()];
    let mut visited = vec![false; graph.len()];

    queue.push_back(start);
    visited[start] = true;

    while let Some(node) = queue.pop_front() {
        let Some(neighbors) = graph.get(node) else {
            continue;
        };

        for &neighbor in neighbors {
            if visited[neighbor] {
                continue;
            }

            visited[neighbor] = true;
            parent[neighbor] = Some(node);
            queue.push_back(neighbor);

            // Edition 2024: if let é“¾å¼
            if neighbor == end {
                // é‡å»ºè·¯å¾„
                let mut path = vec![];
                let mut current = Some(end);

                while let Some(node) = current {
                    path.push(node);
                    current = parent[node];
                }

                path.reverse();
                return Some(path);
            }
        }
    }

    None
}
```

---

## 6. è¿­ä»£å™¨å¢å¼º

### 6.1 å†…è” const è¡¨è¾¾å¼

**åŠŸèƒ½**: åœ¨è¿­ä»£å™¨é“¾ä¸­ä½¿ç”¨ç¼–è¯‘æ—¶è®¡ç®—ã€‚

```rust
// å†…è” constï¼šç¼–è¯‘æ—¶ç”Ÿæˆç´ æ•°è¡¨
pub fn sieve_of_eratosthenes_const() -> Vec<bool> {
    const N: usize = 1000;
    let mut is_prime = vec![true; N];
    is_prime[0] = false;
    is_prime[1] = false;

    // å†…è” const è¡¨è¾¾å¼
    for i in 2..const { (N as f64).sqrt() as usize + 1 } {
        if is_prime[i] {
            for j in (i * i..N).step_by(i) {
                is_prime[j] = false;
            }
        }
    }

    is_prime
}

// ä½¿ç”¨ç¤ºä¾‹
fn example_inline_const() {
    let is_prime = sieve_of_eratosthenes_const();

    let primes: Vec<_> = is_prime
        .iter()
        .enumerate()
        .filter(|&(_, &p)| p)
        .map(|(i, _)| i)
        .take(10)
        .collect();

    println!("å‰10ä¸ªç´ æ•°: {:?}", primes); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
}
```

### 6.2 æ”¹è¿›çš„è¿­ä»£å™¨ç»„åˆå­

```rust
use std::iter;

// é«˜çº§è¿­ä»£å™¨ç»„åˆ
pub fn fibonacci_iter(n: usize) -> impl Iterator<Item = u64> {
    iter::successors(Some((0u64, 1u64)), |(a, b)| {
        let next = a.checked_add(*b)?;
        Some((*b, next))
    })
    .map(|(a, _)| a)
    .take(n)
}

// ç¬›å¡å°”ç§¯è¿­ä»£å™¨
pub fn cartesian_product<T: Clone>(
    a: Vec<T>,
    b: Vec<T>,
) -> impl Iterator<Item = (T, T)> {
    a.into_iter()
        .flat_map(move |x| {
            b.clone().into_iter().map(move |y| (x.clone(), y))
        })
}

// ä½¿ç”¨ç¤ºä¾‹
fn example_advanced_iterators() {
    // Fibonacci æ•°åˆ—
    let fibs: Vec<_> = fibonacci_iter(10).collect();
    println!("Fibonacci: {:?}", fibs); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

    // ç¬›å¡å°”ç§¯
    let product: Vec<_> = cartesian_product(vec![1, 2], vec![3, 4]).collect();
    println!("ç¬›å¡å°”ç§¯: {:?}", product); // [(1, 3), (1, 4), (2, 3), (2, 4)]
}
```

---

## 7. é”™è¯¯å¤„ç†å¢å¼º

### 7.1 Result ç»„åˆå­å¢å¼º

```rust
// Edition 2024: æ”¹è¿›çš„é”™è¯¯å¤„ç†
pub fn parse_and_compute(input: &str) -> Result<i32, Box<dyn std::error::Error>> {
    // let-else ç®€åŒ–é”™è¯¯å¤„ç†
    let Some(parts) = input.split_once(',') else {
        return Err("Invalid format: missing comma".into());
    };

    let (left, right) = parts;

    // ? æ“ä½œç¬¦è‡ªåŠ¨è½¬æ¢é”™è¯¯ç±»å‹
    let left_num: i32 = left.trim().parse()?;
    let right_num: i32 = right.trim().parse()?;

    // æ£€æŸ¥æº¢å‡º
    left_num
        .checked_add(right_num)
        .ok_or_else(|| "Overflow".into())
}

// ä½¿ç”¨ç¤ºä¾‹
fn example_error_handling() {
    match parse_and_compute("123, 456") {
        Ok(result) => println!("ç»“æœ: {}", result),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§

### 8.1 const fn å¢å¼º

```rust
// const fn: ç¼–è¯‘æ—¶è®¡ç®—
pub const fn factorial(n: u64) -> u64 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

// const fn: ç¼–è¯‘æ—¶å¿«é€Ÿå¹‚
pub const fn pow_mod(mut base: u64, mut exp: u64, modulo: u64) -> u64 {
    let mut result = 1;
    base %= modulo;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulo;
        }
        exp /= 2;
        base = (base * base) % modulo;
    }

    result
}

// ç¼–è¯‘æ—¶å¸¸é‡
const FAC_10: u64 = factorial(10);
const POW_2_20_MOD_1000: u64 = pow_mod(2, 20, 1000);

fn example_const_fn() {
    println!("10! = {}", FAC_10); // 3628800
    println!("2^20 mod 1000 = {}", POW_2_20_MOD_1000); // 576
}
```

### 8.2 å†…è”ä¼˜åŒ–

```rust
// å¼ºåˆ¶å†…è”ï¼šå…³é”®è·¯å¾„ä¼˜åŒ–
#[inline(always)]
pub fn quick_sort_partition<T: Ord>(arr: &mut [T], low: usize, high: usize) -> usize {
    let pivot_index = high;
    let mut i = low;

    for j in low..high {
        if arr[j] < arr[pivot_index] {
            arr.swap(i, j);
            i += 1;
        }
    }

    arr.swap(i, pivot_index);
    i
}

// ç¼–è¯‘å™¨æç¤ºå†…è”
#[inline]
pub fn binary_search_core<T: Ord>(arr: &[T], target: &T, mut left: usize, mut right: usize) -> Option<usize> {
    while left < right {
        let mid = left + (right - left) / 2;

        match arr[mid].cmp(target) {
            Ordering::Equal => return Some(mid),
            Ordering::Less => left = mid + 1,
            Ordering::Greater => right = mid,
        }
    }

    None
}
```

---

## 9. ç®—æ³•å®è·µæ¡ˆä¾‹

### 9.1 å®Œæ•´æ¡ˆä¾‹ï¼šå¼‚æ­¥å¹¶è¡Œå¿«é€Ÿæ’åº

```rust
use tokio::task;
use std::future::Future;

// Rust 1.90+ å¼‚æ­¥å¹¶è¡Œå¿«é€Ÿæ’åº
pub async fn quick_sort_parallel_async<T>(arr: &mut [T])
where
    T: Ord + Send + 'static,
{
    if arr.len() <= 1 {
        return;
    }

    // Edition 2024: let-else æ£€æŸ¥
    let Some((pivot, rest)) = arr.split_first_mut() else {
        return;
    };

    let pivot_val = std::mem::replace(pivot, unsafe { std::mem::zeroed() });

    // åˆ†åŒº
    let mut left = Vec::new();
    let mut right = Vec::new();

    for item in rest.iter_mut() {
        let item_val = std::mem::replace(item, unsafe { std::mem::zeroed() });

        if item_val < pivot_val {
            left.push(item_val);
        } else {
            right.push(item_val);
        }
    }

    // å¼‚æ­¥å¹¶è¡Œæ’åº
    let (mut sorted_left, mut sorted_right) = tokio::join!(
        async {
            let mut left = left;
            quick_sort_parallel_async(&mut left).await;
            left
        },
        async {
            let mut right = right;
            quick_sort_parallel_async(&mut right).await;
            right
        }
    );

    // åˆå¹¶ç»“æœ
    let mut index = 0;
    for item in sorted_left {
        arr[index] = item;
        index += 1;
    }

    arr[index] = pivot_val;
    index += 1;

    for item in sorted_right {
        arr[index] = item;
        index += 1;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let mut arr = vec![64, 34, 25, 12, 22, 11, 90, 88, 45, 50];

    quick_sort_parallel_async(&mut arr).await;

    println!("æ’åºç»“æœ: {:?}", arr);
}
```

### 9.2 å®Œæ•´æ¡ˆä¾‹ï¼šGAT å®ç°é›¶æ‹·è´æµå¼ç®—æ³•

```rust
// é›¶æ‹·è´æµå¼å¤„ç† Trait
pub trait StreamProcessor {
    type Item;
    type Output;

    // GAT: æµå¼å¤„ç†æ–¹æ³•
    fn process<'a>(&'a mut self, item: &'a Self::Item) -> Option<&'a Self::Output>;
}

// æ»‘åŠ¨çª—å£æœ€å¤§å€¼å¤„ç†å™¨
pub struct SlidingMaxProcessor {
    window: VecDeque<i32>,
    size: usize,
    max: Option<i32>,
}

impl SlidingMaxProcessor {
    pub fn new(size: usize) -> Self {
        SlidingMaxProcessor {
            window: VecDeque::with_capacity(size),
            size,
            max: None,
        }
    }
}

impl StreamProcessor for SlidingMaxProcessor {
    type Item = i32;
    type Output = i32;

    fn process<'a>(&'a mut self, item: &'a Self::Item) -> Option<&'a Self::Output> {
        self.window.push_back(*item);

        if self.window.len() > self.size {
            self.window.pop_front();
        }

        // è®¡ç®—å½“å‰çª—å£æœ€å¤§å€¼
        if let Some(&max) = self.window.iter().max() {
            self.max = Some(max);
            self.max.as_ref()
        } else {
            None
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn example_stream_processor() {
    let data = vec![1, 3, -1, -3, 5, 3, 6, 7];
    let mut processor = SlidingMaxProcessor::new(3);

    for value in &data {
        if let Some(&max) = processor.process(value) {
            println!("å½“å‰çª—å£æœ€å¤§å€¼: {}", max);
        }
    }
}
```

---

## 10. è¿ç§»æŒ‡å—

### 10.1 ä» Rust 1.75 è¿ç§»åˆ° 1.90

| å˜åŒ– | å½±å“ | è¿ç§»å»ºè®® |
 param($match) $match.Value -replace '[-:]+', ' --- ' ------ param($match) $match.Value -replace '[-:]+', ' --- ' 
| **å¼‚æ­¥é—­åŒ…æ”¯æŒ** | ç®€åŒ–å¼‚æ­¥ä»£ç  | æ›¿æ¢æ‰‹åŠ¨ `Pin<Box<dyn Future>>` |
| **let-else ç¨³å®š** | æå‰è¿”å›æ¨¡å¼ | æ›¿æ¢åµŒå¥— `if let` |
| **GAT å®Œå…¨ç¨³å®š** | é›¶æ‹·è´è¿­ä»£å™¨ | å®ç°è‡ªå®šä¹‰å¼‚æ­¥è¿­ä»£å™¨ |
| **RPITIT ç¨³å®š** | Trait è¿”å›ç®€åŒ– | ç§»é™¤ä¸å¿…è¦çš„å…³è”ç±»å‹ |

### 10.2 Edition 2021 â†’ 2024 è¿ç§»

```rust
// Edition 2021
fn old_style(input: Option<i32>) -> Result<i32, &'static str> {
    if let Some(value) = input {
        Ok(value * 2)
    } else {
        Err("No input")
    }
}

// Edition 2024
fn new_style(input: Option<i32>) -> Result<i32, &'static str> {
    let Some(value) = input else {
        return Err("No input");
    };

    Ok(value * 2)
}
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- **[01_ç®—æ³•åˆ†ç±»å‚è€ƒ](./01_ç®—æ³•åˆ†ç±»å‚è€ƒ.md)** - ç®—æ³•å®Œæ•´ç´¢å¼•
- **[02_æ•°æ®ç»“æ„å‚è€ƒ](./02_æ•°æ®ç»“æ„å‚è€ƒ.md)** - æ•°æ®ç»“æ„ API æ–‡æ¡£
- **[04_ç®—æ³•æ€§èƒ½å‚è€ƒ](./04_ç®—æ³•æ€§èƒ½å‚è€ƒ.md)** - æ€§èƒ½åŸºå‡†æµ‹è¯•
- **[../rust-features/RUST_190_FEATURES_APPLICATION.md](../rust-features/RUST_190_FEATURES_APPLICATION.md)** - Rust 1.90 è¯¦ç»†ç‰¹æ€§

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23
**è´¨é‡è¯„åˆ†**: â­â­â­â­â­
