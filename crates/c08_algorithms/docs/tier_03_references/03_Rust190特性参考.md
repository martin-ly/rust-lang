# Rust 1.90 特性在算法中的应用

> **文档类型**: Tier 3 技术参考  
> **目标读者**: 需要了解 Rust 最新特性的开发者  
> **Rust 版本**: 1.90+  
> **Edition**: 2024  
> **最后更新**: 2025-10-23

---


## 📊 目录

- [📖 目录](#目录)
- [1. 概述](#1-概述)
  - [1.1 主要新特性](#11-主要新特性)
- [2. Edition 2024 核心特性](#2-edition-2024-核心特性)
  - [2.1 let-else 语法](#21-let-else-语法)
    - [传统写法 vs Edition 2024](#传统写法-vs-edition-2024)
    - [实际应用：图算法](#实际应用图算法)
- [3. 异步特性增强](#3-异步特性增强)
  - [3.1 异步闭包 (Async Closures)](#31-异步闭包-async-closures)
    - [传统写法 vs Rust 1.90](#传统写法-vs-rust-190)
    - [实际应用：异步图遍历](#实际应用异步图遍历)
- [4. 类型系统增强](#4-类型系统增强)
  - [4.1 GAT (Generic Associated Types) 稳定](#41-gat-generic-associated-types-稳定)
    - [零拷贝异步迭代器](#零拷贝异步迭代器)
    - [实际应用：异步图迭代器](#实际应用异步图迭代器)
  - [4.2 RPITIT (Return Position Impl Trait in Traits)](#42-rpitit-return-position-impl-trait-in-traits)
- [5. 模式匹配增强](#5-模式匹配增强)
  - [5.1 if-let 链式匹配](#51-if-let-链式匹配)
- [6. 迭代器增强](#6-迭代器增强)
  - [6.1 内联 const 表达式](#61-内联-const-表达式)
  - [6.2 改进的迭代器组合子](#62-改进的迭代器组合子)
- [7. 错误处理增强](#7-错误处理增强)
  - [7.1 Result 组合子增强](#71-result-组合子增强)
- [8. 性能优化特性](#8-性能优化特性)
  - [8.1 const fn 增强](#81-const-fn-增强)
  - [8.2 内联优化](#82-内联优化)
- [9. 算法实践案例](#9-算法实践案例)
  - [9.1 完整案例：异步并行快速排序](#91-完整案例异步并行快速排序)
  - [9.2 完整案例：GAT 实现零拷贝流式算法](#92-完整案例gat-实现零拷贝流式算法)
- [10. 迁移指南](#10-迁移指南)
  - [10.1 从 Rust 1.75 迁移到 1.90](#101-从-rust-175-迁移到-190)
  - [10.2 Edition 2021 → 2024 迁移](#102-edition-2021-2024-迁移)
- [📚 相关文档](#相关文档)


## 📖 目录

- [Rust 1.90 特性在算法中的应用](#rust-190-特性在算法中的应用)
  - [📖 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 主要新特性](#11-主要新特性)
  - [2. Edition 2024 核心特性](#2-edition-2024-核心特性)
    - [2.1 let-else 语法](#21-let-else-语法)
      - [传统写法 vs Edition 2024](#传统写法-vs-edition-2024)
      - [实际应用：图算法](#实际应用图算法)
  - [3. 异步特性增强](#3-异步特性增强)
    - [3.1 异步闭包 (Async Closures)](#31-异步闭包-async-closures)
      - [传统写法 vs Rust 1.90](#传统写法-vs-rust-190)
      - [实际应用：异步图遍历](#实际应用异步图遍历)
  - [4. 类型系统增强](#4-类型系统增强)
    - [4.1 GAT (Generic Associated Types) 稳定](#41-gat-generic-associated-types-稳定)
      - [零拷贝异步迭代器](#零拷贝异步迭代器)
      - [实际应用：异步图迭代器](#实际应用异步图迭代器)
    - [4.2 RPITIT (Return Position Impl Trait in Traits)](#42-rpitit-return-position-impl-trait-in-traits)
  - [5. 模式匹配增强](#5-模式匹配增强)
    - [5.1 if-let 链式匹配](#51-if-let-链式匹配)
  - [6. 迭代器增强](#6-迭代器增强)
    - [6.1 内联 const 表达式](#61-内联-const-表达式)
    - [6.2 改进的迭代器组合子](#62-改进的迭代器组合子)
  - [7. 错误处理增强](#7-错误处理增强)
    - [7.1 Result 组合子增强](#71-result-组合子增强)
  - [8. 性能优化特性](#8-性能优化特性)
    - [8.1 const fn 增强](#81-const-fn-增强)
    - [8.2 内联优化](#82-内联优化)
  - [9. 算法实践案例](#9-算法实践案例)
    - [9.1 完整案例：异步并行快速排序](#91-完整案例异步并行快速排序)
    - [9.2 完整案例：GAT 实现零拷贝流式算法](#92-完整案例gat-实现零拷贝流式算法)
  - [10. 迁移指南](#10-迁移指南)
    - [10.1 从 Rust 1.75 迁移到 1.90](#101-从-rust-175-迁移到-190)
    - [10.2 Edition 2021 → 2024 迁移](#102-edition-2021--2024-迁移)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

Rust 1.90 和 Edition 2024 带来了一系列重要特性，显著提升了算法实现的表达力、性能和安全性。本文档详细介绍这些新特性在 C08 Algorithms 模块中的应用。

### 1.1 主要新特性

| 特性 | Rust 版本 | 影响 |
|------|-----------|------|
| **异步闭包 (Async Closures)** | 1.90+ | ⭐⭐⭐⭐⭐ 异步算法简化 |
| **let-else 语法** | 1.65+ (2024 Edition) | ⭐⭐⭐⭐ 错误处理简化 |
| **RPITIT (返回位置 impl Trait)** | 1.75+ | ⭐⭐⭐⭐ Trait 设计简化 |
| **GAT (泛型关联类型) 稳定** | 1.65+ | ⭐⭐⭐⭐ 零拷贝迭代器 |
| **内联 const 表达式** | 1.79+ | ⭐⭐⭐ 编译时计算 |
| **改进的类型推断** | 1.90 | ⭐⭐⭐ 减少类型标注 |

---

## 2. Edition 2024 核心特性

### 2.1 let-else 语法

**功能**: 提前返回 + 模式匹配的简洁语法。

#### 传统写法 vs Edition 2024

```rust
// ❌ 传统写法：嵌套 if-let
pub fn binary_search_sync<T: Ord>(arr: &[T], target: T) -> Option<usize> {
    if arr.is_empty() {
        return None;
    }
    
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(&target) {
            Ordering::Equal => return Some(mid),
            Ordering::Less => left = mid + 1,
            Ordering::Greater => right = mid,
        }
    }
    
    None
}

// ✅ Edition 2024：let-else 简化
pub fn binary_search_sync<T: Ord>(arr: &[T], target: T) -> Option<usize> {
    let Some(first) = arr.first() else {
        return None;
    };
    
    // 提前检查边界
    let Some(last) = arr.last() else {
        return None;
    };
    
    if target < *first || target > *last {
        return None;
    }
    
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(&target) {
            Ordering::Equal => return Some(mid),
            Ordering::Less => left = mid + 1,
            Ordering::Greater => right = mid,
        }
    }
    
    None
}
```

#### 实际应用：图算法

```rust
use std::collections::VecDeque;

// Dijkstra 最短路径：Edition 2024 版本
pub fn dijkstra_sync(graph: &[Vec<(usize, i64)>], start: usize) -> Vec<i64> {
    let n = graph.len();
    
    // let-else 验证起点
    let Some(start_edges) = graph.get(start) else {
        return vec![i64::MAX; n];
    };
    
    let mut dist = vec![i64::MAX; n];
    dist[start] = 0;
    
    let mut visited = vec![false; n];
    
    for _ in 0..n {
        // 找到未访问的最小距离节点
        let Some((u, min_dist)) = (0..n)
            .filter(|&i| !visited[i] && dist[i] != i64::MAX)
            .map(|i| (i, dist[i]))
            .min_by_key(|&(_, d)| d)
        else {
            break; // 所有可达节点已访问
        };
        
        visited[u] = true;
        
        // 松弛邻边
        for &(v, weight) in &graph[u] {
            let new_dist = min_dist.saturating_add(weight);
            if new_dist < dist[v] {
                dist[v] = new_dist;
            }
        }
    }
    
    dist
}
```

---

## 3. 异步特性增强

### 3.1 异步闭包 (Async Closures)

**功能**: Rust 1.90+ 支持原生异步闭包，无需手动实现 `Future`。

#### 传统写法 vs Rust 1.90

```rust
use tokio::task;

// ❌ Rust 1.75-1.89：手动包装异步闭包
pub async fn parallel_map_async<T, U, F>(
    items: Vec<T>,
    mut f: F,
) -> Vec<U>
where
    T: Send + 'static,
    U: Send + 'static,
    F: FnMut(T) -> Pin<Box<dyn Future<Output = U> + Send>> + Send + 'static,
{
    let tasks: Vec<_> = items
        .into_iter()
        .map(|item| task::spawn(f(item)))
        .collect();
    
    let mut results = Vec::new();
    for task in tasks {
        results.push(task.await.unwrap());
    }
    results
}

// ✅ Rust 1.90+：原生异步闭包
pub async fn parallel_map_async<T, U, F, Fut>(
    items: Vec<T>,
    f: F,
) -> Vec<U>
where
    T: Send + 'static,
    U: Send + 'static,
    F: Fn(T) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = U> + Send,
{
    let tasks: Vec<_> = items
        .into_iter()
        .map(|item| task::spawn(f(item)))
        .collect();
    
    futures::future::join_all(tasks)
        .await
        .into_iter()
        .map(|r| r.unwrap())
        .collect()
}

// 使用示例
async fn example_async_closures() {
    let nums = vec![1, 2, 3, 4, 5];
    
    // 异步闭包直接使用
    let results = parallel_map_async(nums, async |x| {
        tokio::time::sleep(Duration::from_millis(100)).await;
        x * x
    }).await;
    
    println!("结果: {:?}", results); // [1, 4, 9, 16, 25]
}
```

#### 实际应用：异步图遍历

```rust
use tokio::task;
use std::collections::HashSet;

// 异步 DFS：使用异步闭包进行节点处理
pub async fn dfs_async_with_processor<F, Fut>(
    graph: &[Vec<usize>],
    start: usize,
    process_node: F,
) -> HashSet<usize>
where
    F: Fn(usize) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = ()> + Send,
{
    let mut visited = HashSet::new();
    let mut stack = vec![start];
    
    while let Some(node) = stack.pop() {
        if visited.insert(node) {
            // 异步处理节点
            process_node(node).await;
            
            // 添加邻居到栈
            for &neighbor in &graph[node] {
                if !visited.contains(&neighbor) {
                    stack.push(neighbor);
                }
            }
        }
    }
    
    visited
}

// 使用示例
async fn example_async_dfs() {
    let graph = vec![
        vec![1, 2],    // 0 -> 1, 2
        vec![3],       // 1 -> 3
        vec![3, 4],    // 2 -> 3, 4
        vec![],        // 3 -> 无
        vec![],        // 4 -> 无
    ];
    
    let visited = dfs_async_with_processor(&graph, 0, async |node| {
        // 模拟异步I/O操作
        println!("访问节点: {}", node);
        tokio::time::sleep(Duration::from_millis(10)).await;
    }).await;
    
    println!("访问的节点: {:?}", visited);
}
```

---

## 4. 类型系统增强

### 4.1 GAT (Generic Associated Types) 稳定

**功能**: 支持关联类型的泛型参数，实现零拷贝迭代器。

#### 零拷贝异步迭代器

```rust
use std::pin::Pin;
use std::future::Future;

// GAT 定义异步迭代器 Trait
pub trait AsyncIterator {
    type Item;
    
    // GAT: 关联类型带生命周期参数
    fn next<'a>(&'a mut self) -> Pin<Box<dyn Future<Output = Option<Self::Item>> + 'a>>;
}

// 实现异步范围迭代器
pub struct AsyncRange {
    current: i32,
    end: i32,
}

impl AsyncRange {
    pub fn new(start: i32, end: i32) -> Self {
        AsyncRange {
            current: start,
            end,
        }
    }
}

impl AsyncIterator for AsyncRange {
    type Item = i32;
    
    fn next<'a>(&'a mut self) -> Pin<Box<dyn Future<Output = Option<Self::Item>> + 'a>> {
        Box::pin(async move {
            if self.current < self.end {
                let value = self.current;
                self.current += 1;
                
                // 模拟异步操作
                tokio::time::sleep(Duration::from_millis(10)).await;
                
                Some(value)
            } else {
                None
            }
        })
    }
}

// 使用示例
async fn example_gat_async_iterator() {
    let mut iter = AsyncRange::new(1, 6);
    
    while let Some(value) = iter.next().await {
        println!("异步迭代值: {}", value);
    }
}
```

#### 实际应用：异步图迭代器

```rust
pub struct AsyncGraphIterator<'a> {
    graph: &'a [Vec<usize>],
    visited: HashSet<usize>,
    queue: VecDeque<usize>,
}

impl<'a> AsyncGraphIterator<'a> {
    pub fn new(graph: &'a [Vec<usize>], start: usize) -> Self {
        let mut queue = VecDeque::new();
        queue.push_back(start);
        
        AsyncGraphIterator {
            graph,
            visited: HashSet::new(),
            queue,
        }
    }
}

impl<'a> AsyncIterator for AsyncGraphIterator<'a> {
    type Item = usize;
    
    fn next<'b>(&'b mut self) -> Pin<Box<dyn Future<Output = Option<Self::Item>> + 'b>> {
        Box::pin(async move {
            while let Some(node) = self.queue.pop_front() {
                if self.visited.insert(node) {
                    // 添加邻居
                    for &neighbor in &self.graph[node] {
                        if !self.visited.contains(&neighbor) {
                            self.queue.push_back(neighbor);
                        }
                    }
                    
                    // 模拟异步节点处理
                    tokio::time::sleep(Duration::from_millis(5)).await;
                    
                    return Some(node);
                }
            }
            
            None
        })
    }
}
```

### 4.2 RPITIT (Return Position Impl Trait in Traits)

**功能**: 允许 Trait 方法返回 `impl Trait`，无需手动定义关联类型。

```rust
// ❌ Rust 1.70 之前：需要关联类型
pub trait AlgorithmOld {
    type Output;
    fn compute(&self, input: &[i32]) -> Self::Output;
}

// ✅ Rust 1.75+：直接返回 impl Trait
pub trait Algorithm {
    fn compute(&self, input: &[i32]) -> impl Iterator<Item = i32>;
}

// 实现排序算法
pub struct QuickSort;

impl Algorithm for QuickSort {
    fn compute(&self, input: &[i32]) -> impl Iterator<Item = i32> {
        let mut sorted = input.to_vec();
        sorted.sort_unstable();
        sorted.into_iter()
    }
}

// 实现过滤算法
pub struct Filter {
    threshold: i32,
}

impl Algorithm for Filter {
    fn compute(&self, input: &[i32]) -> impl Iterator<Item = i32> {
        let threshold = self.threshold;
        input.iter().copied().filter(move |&x| x > threshold)
    }
}

// 使用示例
fn example_rpitit() {
    let data = vec![3, 1, 4, 1, 5, 9, 2, 6];
    
    let sorter = QuickSort;
    let sorted: Vec<_> = sorter.compute(&data).collect();
    println!("排序结果: {:?}", sorted); // [1, 1, 2, 3, 4, 5, 6, 9]
    
    let filter = Filter { threshold: 4 };
    let filtered: Vec<_> = filter.compute(&data).collect();
    println!("过滤结果: {:?}", filtered); // [5, 9, 6]
}
```

---

## 5. 模式匹配增强

### 5.1 if-let 链式匹配

**功能**: Edition 2024 允许 `if let` 和 `let else` 组合使用。

```rust
// 复杂的图搜索示例
pub fn find_path(
    graph: &[Vec<usize>],
    start: usize,
    end: usize,
) -> Option<Vec<usize>> {
    let Some(start_neighbors) = graph.get(start) else {
        return None;
    };
    
    if start == end {
        return Some(vec![start]);
    }
    
    let mut queue = VecDeque::new();
    let mut parent = vec![None; graph.len()];
    let mut visited = vec![false; graph.len()];
    
    queue.push_back(start);
    visited[start] = true;
    
    while let Some(node) = queue.pop_front() {
        let Some(neighbors) = graph.get(node) else {
            continue;
        };
        
        for &neighbor in neighbors {
            if visited[neighbor] {
                continue;
            }
            
            visited[neighbor] = true;
            parent[neighbor] = Some(node);
            queue.push_back(neighbor);
            
            // Edition 2024: if let 链式
            if neighbor == end {
                // 重建路径
                let mut path = vec![];
                let mut current = Some(end);
                
                while let Some(node) = current {
                    path.push(node);
                    current = parent[node];
                }
                
                path.reverse();
                return Some(path);
            }
        }
    }
    
    None
}
```

---

## 6. 迭代器增强

### 6.1 内联 const 表达式

**功能**: 在迭代器链中使用编译时计算。

```rust
// 内联 const：编译时生成素数表
pub fn sieve_of_eratosthenes_const() -> Vec<bool> {
    const N: usize = 1000;
    let mut is_prime = vec![true; N];
    is_prime[0] = false;
    is_prime[1] = false;
    
    // 内联 const 表达式
    for i in 2..const { (N as f64).sqrt() as usize + 1 } {
        if is_prime[i] {
            for j in (i * i..N).step_by(i) {
                is_prime[j] = false;
            }
        }
    }
    
    is_prime
}

// 使用示例
fn example_inline_const() {
    let is_prime = sieve_of_eratosthenes_const();
    
    let primes: Vec<_> = is_prime
        .iter()
        .enumerate()
        .filter(|&(_, &p)| p)
        .map(|(i, _)| i)
        .take(10)
        .collect();
    
    println!("前10个素数: {:?}", primes); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
}
```

### 6.2 改进的迭代器组合子

```rust
use std::iter;

// 高级迭代器组合
pub fn fibonacci_iter(n: usize) -> impl Iterator<Item = u64> {
    iter::successors(Some((0u64, 1u64)), |(a, b)| {
        let next = a.checked_add(*b)?;
        Some((*b, next))
    })
    .map(|(a, _)| a)
    .take(n)
}

// 笛卡尔积迭代器
pub fn cartesian_product<T: Clone>(
    a: Vec<T>,
    b: Vec<T>,
) -> impl Iterator<Item = (T, T)> {
    a.into_iter()
        .flat_map(move |x| {
            b.clone().into_iter().map(move |y| (x.clone(), y))
        })
}

// 使用示例
fn example_advanced_iterators() {
    // Fibonacci 数列
    let fibs: Vec<_> = fibonacci_iter(10).collect();
    println!("Fibonacci: {:?}", fibs); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    
    // 笛卡尔积
    let product: Vec<_> = cartesian_product(vec![1, 2], vec![3, 4]).collect();
    println!("笛卡尔积: {:?}", product); // [(1, 3), (1, 4), (2, 3), (2, 4)]
}
```

---

## 7. 错误处理增强

### 7.1 Result 组合子增强

```rust
// Edition 2024: 改进的错误处理
pub fn parse_and_compute(input: &str) -> Result<i32, Box<dyn std::error::Error>> {
    // let-else 简化错误处理
    let Some(parts) = input.split_once(',') else {
        return Err("Invalid format: missing comma".into());
    };
    
    let (left, right) = parts;
    
    // ? 操作符自动转换错误类型
    let left_num: i32 = left.trim().parse()?;
    let right_num: i32 = right.trim().parse()?;
    
    // 检查溢出
    left_num
        .checked_add(right_num)
        .ok_or_else(|| "Overflow".into())
}

// 使用示例
fn example_error_handling() {
    match parse_and_compute("123, 456") {
        Ok(result) => println!("结果: {}", result),
        Err(e) => println!("错误: {}", e),
    }
}
```

---

## 8. 性能优化特性

### 8.1 const fn 增强

```rust
// const fn: 编译时计算
pub const fn factorial(n: u64) -> u64 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

// const fn: 编译时快速幂
pub const fn pow_mod(mut base: u64, mut exp: u64, modulo: u64) -> u64 {
    let mut result = 1;
    base %= modulo;
    
    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulo;
        }
        exp /= 2;
        base = (base * base) % modulo;
    }
    
    result
}

// 编译时常量
const FAC_10: u64 = factorial(10);
const POW_2_20_MOD_1000: u64 = pow_mod(2, 20, 1000);

fn example_const_fn() {
    println!("10! = {}", FAC_10); // 3628800
    println!("2^20 mod 1000 = {}", POW_2_20_MOD_1000); // 576
}
```

### 8.2 内联优化

```rust
// 强制内联：关键路径优化
#[inline(always)]
pub fn quick_sort_partition<T: Ord>(arr: &mut [T], low: usize, high: usize) -> usize {
    let pivot_index = high;
    let mut i = low;
    
    for j in low..high {
        if arr[j] < arr[pivot_index] {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, pivot_index);
    i
}

// 编译器提示内联
#[inline]
pub fn binary_search_core<T: Ord>(arr: &[T], target: &T, mut left: usize, mut right: usize) -> Option<usize> {
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(target) {
            Ordering::Equal => return Some(mid),
            Ordering::Less => left = mid + 1,
            Ordering::Greater => right = mid,
        }
    }
    
    None
}
```

---

## 9. 算法实践案例

### 9.1 完整案例：异步并行快速排序

```rust
use tokio::task;
use std::future::Future;

// Rust 1.90+ 异步并行快速排序
pub async fn quick_sort_parallel_async<T>(arr: &mut [T])
where
    T: Ord + Send + 'static,
{
    if arr.len() <= 1 {
        return;
    }
    
    // Edition 2024: let-else 检查
    let Some((pivot, rest)) = arr.split_first_mut() else {
        return;
    };
    
    let pivot_val = std::mem::replace(pivot, unsafe { std::mem::zeroed() });
    
    // 分区
    let mut left = Vec::new();
    let mut right = Vec::new();
    
    for item in rest.iter_mut() {
        let item_val = std::mem::replace(item, unsafe { std::mem::zeroed() });
        
        if item_val < pivot_val {
            left.push(item_val);
        } else {
            right.push(item_val);
        }
    }
    
    // 异步并行排序
    let (mut sorted_left, mut sorted_right) = tokio::join!(
        async {
            let mut left = left;
            quick_sort_parallel_async(&mut left).await;
            left
        },
        async {
            let mut right = right;
            quick_sort_parallel_async(&mut right).await;
            right
        }
    );
    
    // 合并结果
    let mut index = 0;
    for item in sorted_left {
        arr[index] = item;
        index += 1;
    }
    
    arr[index] = pivot_val;
    index += 1;
    
    for item in sorted_right {
        arr[index] = item;
        index += 1;
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let mut arr = vec![64, 34, 25, 12, 22, 11, 90, 88, 45, 50];
    
    quick_sort_parallel_async(&mut arr).await;
    
    println!("排序结果: {:?}", arr);
}
```

### 9.2 完整案例：GAT 实现零拷贝流式算法

```rust
// 零拷贝流式处理 Trait
pub trait StreamProcessor {
    type Item;
    type Output;
    
    // GAT: 流式处理方法
    fn process<'a>(&'a mut self, item: &'a Self::Item) -> Option<&'a Self::Output>;
}

// 滑动窗口最大值处理器
pub struct SlidingMaxProcessor {
    window: VecDeque<i32>,
    size: usize,
    max: Option<i32>,
}

impl SlidingMaxProcessor {
    pub fn new(size: usize) -> Self {
        SlidingMaxProcessor {
            window: VecDeque::with_capacity(size),
            size,
            max: None,
        }
    }
}

impl StreamProcessor for SlidingMaxProcessor {
    type Item = i32;
    type Output = i32;
    
    fn process<'a>(&'a mut self, item: &'a Self::Item) -> Option<&'a Self::Output> {
        self.window.push_back(*item);
        
        if self.window.len() > self.size {
            self.window.pop_front();
        }
        
        // 计算当前窗口最大值
        if let Some(&max) = self.window.iter().max() {
            self.max = Some(max);
            self.max.as_ref()
        } else {
            None
        }
    }
}

// 使用示例
fn example_stream_processor() {
    let data = vec![1, 3, -1, -3, 5, 3, 6, 7];
    let mut processor = SlidingMaxProcessor::new(3);
    
    for value in &data {
        if let Some(&max) = processor.process(value) {
            println!("当前窗口最大值: {}", max);
        }
    }
}
```

---

## 10. 迁移指南

### 10.1 从 Rust 1.75 迁移到 1.90

| 变化 | 影响 | 迁移建议 |
|------|------|---------|
| **异步闭包支持** | 简化异步代码 | 替换手动 `Pin<Box<dyn Future>>` |
| **let-else 稳定** | 提前返回模式 | 替换嵌套 `if let` |
| **GAT 完全稳定** | 零拷贝迭代器 | 实现自定义异步迭代器 |
| **RPITIT 稳定** | Trait 返回简化 | 移除不必要的关联类型 |

### 10.2 Edition 2021 → 2024 迁移

```rust
// Edition 2021
fn old_style(input: Option<i32>) -> Result<i32, &'static str> {
    if let Some(value) = input {
        Ok(value * 2)
    } else {
        Err("No input")
    }
}

// Edition 2024
fn new_style(input: Option<i32>) -> Result<i32, &'static str> {
    let Some(value) = input else {
        return Err("No input");
    };
    
    Ok(value * 2)
}
```

---

## 📚 相关文档

- **[01_算法分类参考](./01_算法分类参考.md)** - 算法完整索引
- **[02_数据结构参考](./02_数据结构参考.md)** - 数据结构 API 文档
- **[04_算法性能参考](./04_算法性能参考.md)** - 性能基准测试
- **[../rust-features/RUST_190_FEATURES_APPLICATION.md](../rust-features/RUST_190_FEATURES_APPLICATION.md)** - Rust 1.90 详细特性

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-23  
**质量评分**: ⭐⭐⭐⭐⭐
