# ç®—æ³•åˆ†ç±»å‚è€ƒæ‰‹å†Œ

> **æ–‡æ¡£ç±»å‹**: Tier 3 æŠ€æœ¯å‚è€ƒ
> **ç›®æ ‡è¯»è€…**: éœ€è¦æŸ¥é˜…ç®—æ³•åˆ†ç±»å’ŒAPIçš„å¼€å‘è€…
> **Rust ç‰ˆæœ¬**: 1.93.1+
> **Edition**: 2024
> **æœ€åæ›´æ–°**: 2025-10-23

---

## ğŸ“– ç›®å½•

- [ç®—æ³•åˆ†ç±»å‚è€ƒæ‰‹å†Œ](#ç®—æ³•åˆ†ç±»å‚è€ƒæ‰‹å†Œ)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. æŒ‰è®¾è®¡èŒƒå¼åˆ†ç±»](#2-æŒ‰è®¾è®¡èŒƒå¼åˆ†ç±»)
    - [2.1 åˆ†æ²»ç®—æ³•](#21-åˆ†æ²»ç®—æ³•)
      - [API ç´¢å¼•](#api-ç´¢å¼•)
      - [ä»£ç ç¤ºä¾‹](#ä»£ç ç¤ºä¾‹)
      - [ä½¿ç”¨åœºæ™¯](#ä½¿ç”¨åœºæ™¯)
    - [2.2 åŠ¨æ€è§„åˆ’](#22-åŠ¨æ€è§„åˆ’)
      - [2.2.1 API ç´¢å¼•](#221-api-ç´¢å¼•)
      - [2.2.2 ä»£ç ç¤ºä¾‹](#222-ä»£ç ç¤ºä¾‹)
      - [2.2.3 ä½¿ç”¨åœºæ™¯](#223-ä½¿ç”¨åœºæ™¯)
    - [2.3 è´ªå¿ƒç®—æ³•](#23-è´ªå¿ƒç®—æ³•)
      - [2.3.1 API ç´¢å¼•](#231-api-ç´¢å¼•)
      - [2.3.2 ä»£ç ç¤ºä¾‹](#232-ä»£ç ç¤ºä¾‹)
      - [2.3.4 ä½¿ç”¨åœºæ™¯](#234-ä½¿ç”¨åœºæ™¯)
    - [2.4 å›æº¯ç®—æ³•](#24-å›æº¯ç®—æ³•)
      - [2.4.1. API ç´¢å¼•](#241-api-ç´¢å¼•)
      - [2.4.2 ä»£ç ç¤ºä¾‹](#242-ä»£ç ç¤ºä¾‹)
      - [2.4.3 ä½¿ç”¨åœºæ™¯](#243-ä½¿ç”¨åœºæ™¯)
  - [3. æŒ‰é—®é¢˜åŸŸåˆ†ç±»](#3-æŒ‰é—®é¢˜åŸŸåˆ†ç±»)
    - [3.1 æ’åºç®—æ³•](#31-æ’åºç®—æ³•)
      - [3.2 ä»£ç ç¤ºä¾‹](#32-ä»£ç ç¤ºä¾‹)
    - [3.2 æœç´¢ç®—æ³•](#32-æœç´¢ç®—æ³•)
      - [3.2.1 ä»£ç ç¤ºä¾‹](#321-ä»£ç ç¤ºä¾‹)
    - [3.3 å›¾è®ºç®—æ³•](#33-å›¾è®ºç®—æ³•)
      - [æœ€çŸ­è·¯å¾„](#æœ€çŸ­è·¯å¾„)
      - [æœ€å°ç”Ÿæˆæ ‘](#æœ€å°ç”Ÿæˆæ ‘)
      - [æ‹“æ‰‘æ’åºä¸è¿é€šæ€§](#æ‹“æ‰‘æ’åºä¸è¿é€šæ€§)
      - [ç½‘ç»œæµ](#ç½‘ç»œæµ)
      - [å…¶ä»–](#å…¶ä»–)
      - [ä»£ç ç¤ºä¾‹1](#ä»£ç ç¤ºä¾‹1)
    - [3.4 å­—ç¬¦ä¸²ç®—æ³•](#34-å­—ç¬¦ä¸²ç®—æ³•)
      - [ä»£ç ç¤ºä¾‹2](#ä»£ç ç¤ºä¾‹2)
    - [3.5 æ•°å€¼ç®—æ³•](#35-æ•°å€¼ç®—æ³•)
      - [ä»£ç ç¤ºä¾‹3](#ä»£ç ç¤ºä¾‹3)
  - [4. æŒ‰æ‰§è¡Œæ¨¡å‹åˆ†ç±»](#4-æŒ‰æ‰§è¡Œæ¨¡å‹åˆ†ç±»)
    - [4.1 åŒæ­¥ç®—æ³•](#41-åŒæ­¥ç®—æ³•)
    - [4.2 å¹¶è¡Œç®—æ³•](#42-å¹¶è¡Œç®—æ³•)
      - [ä»£ç ç¤ºä¾‹4](#ä»£ç ç¤ºä¾‹4)
    - [4.3 å¼‚æ­¥ç®—æ³•](#43-å¼‚æ­¥ç®—æ³•)
      - [ä»£ç ç¤ºä¾‹5](#ä»£ç ç¤ºä¾‹5)
  - [5. æ•°æ®ç»“æ„åˆ†ç±»](#5-æ•°æ®ç»“æ„åˆ†ç±»)
    - [5.1 ä»£ç ç¤ºä¾‹](#51-ä»£ç ç¤ºä¾‹)
  - [6. ç®—æ³•å¤æ‚åº¦å¿«é€ŸæŸ¥è¯¢](#6-ç®—æ³•å¤æ‚åº¦å¿«é€ŸæŸ¥è¯¢)
    - [æ’åºç®—æ³•](#æ’åºç®—æ³•)
    - [å›¾ç®—æ³•](#å›¾ç®—æ³•)
    - [å­—ç¬¦ä¸²ç®—æ³•](#å­—ç¬¦ä¸²ç®—æ³•)
    - [åŠ¨æ€è§„åˆ’](#åŠ¨æ€è§„åˆ’)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)
  - [ğŸ¯ ä½¿ç”¨å»ºè®®](#-ä½¿ç”¨å»ºè®®)
    - [1. å¦‚ä½•é€‰æ‹©ç®—æ³•](#1-å¦‚ä½•é€‰æ‹©ç®—æ³•)
    - [2. æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#2-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
    - [3. å¸¸è§é™·é˜±](#3-å¸¸è§é™·é˜±)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**ç®—æ³•åˆ†ç±» (Algorithm Classification)**:

- **å®šä¹‰**: æŒ‰ç…§ä¸åŒç»´åº¦å¯¹ç®—æ³•è¿›è¡Œåˆ†ç±»å’Œç»„ç»‡çš„å‚è€ƒä½“ç³»
- **ç±»å‹**: åˆ†ç±»ä½“ç³»
- **èŒƒç•´**: ç®—æ³•å­¦ã€çŸ¥è¯†ç®¡ç†
- **ç›¸å…³æ¦‚å¿µ**: ç®—æ³•ã€æ•°æ®ç»“æ„ã€å¤æ‚åº¦åˆ†æ

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å¤šç»´åº¦åˆ†ç±»**: è®¾è®¡èŒƒå¼ã€é—®é¢˜åŸŸã€æ‰§è¡Œæ¨¡å‹
- **å®Œæ•´æ€§**: æ¶µç›–æ‰€æœ‰ç®—æ³•ç±»å‹
- **å¯æŸ¥æ‰¾æ€§**: ä¾¿äºå¿«é€Ÿå®šä½ç®—æ³•
- **å…³è”æ€§**: ç®—æ³•ä¹‹é—´çš„å…³è”å…³ç³»

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- ç®—æ³•åˆ†ç±» --[contains]--> å¤šä¸ªç®—æ³•ç±»åˆ«
- çŸ¥è¯†ä½“ç³» --[uses]--> ç®—æ³•åˆ†ç±»

**ä¾èµ–å…³ç³»**:

- ç®—æ³•åˆ†ç±» --[depends-on]--> ç®—æ³•çŸ¥è¯†
- ç®—æ³•é€‰æ‹© --[depends-on]--> ç®—æ³•åˆ†ç±»

### æ€ç»´å¯¼å›¾

```text
ç®—æ³•åˆ†ç±»å‚è€ƒ
â”‚
â”œâ”€â”€ æŒ‰è®¾è®¡èŒƒå¼
â”‚   â”œâ”€â”€ åˆ†æ²»ç®—æ³•
â”‚   â”œâ”€â”€ åŠ¨æ€è§„åˆ’
â”‚   â”œâ”€â”€ è´ªå¿ƒç®—æ³•
â”‚   â””â”€â”€ å›æº¯ç®—æ³•
â”œâ”€â”€ æŒ‰é—®é¢˜åŸŸ
â”‚   â”œâ”€â”€ æ’åºç®—æ³•
â”‚   â”œâ”€â”€ æœç´¢ç®—æ³•
â”‚   â”œâ”€â”€ å›¾è®ºç®—æ³•
â”‚   â””â”€â”€ å­—ç¬¦ä¸²ç®—æ³•
â””â”€â”€ æŒ‰æ‰§è¡Œæ¨¡å‹
    â”œâ”€â”€ åŒæ­¥ç®—æ³•
    â”œâ”€â”€ å¹¶è¡Œç®—æ³•
    â””â”€â”€ å¼‚æ­¥ç®—æ³•
```

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº† C08 Algorithms æ¨¡å—ä¸­æ‰€æœ‰ç®—æ³•çš„å®Œæ•´åˆ†ç±»å‚è€ƒï¼ŒæŒ‰ç…§**è®¾è®¡èŒƒå¼**ã€**é—®é¢˜åŸŸ**å’Œ**æ‰§è¡Œæ¨¡å‹**ä¸‰ä¸ªç»´åº¦è¿›è¡Œåˆ†ç±»ï¼Œä¾¿äºå¿«é€ŸæŸ¥æ‰¾å’Œé€‰æ‹©åˆé€‚çš„ç®—æ³•ã€‚

---

## 2. æŒ‰è®¾è®¡èŒƒå¼åˆ†ç±»

### 2.1 åˆ†æ²»ç®—æ³•

**æ ¸å¿ƒæ€æƒ³**: å°†é—®é¢˜åˆ†è§£ä¸ºè§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œé€’å½’æ±‚è§£ååˆå¹¶ç»“æœã€‚

#### API ç´¢å¼•

| ç®—æ³• | åŒæ­¥æ¥å£  | å¹¶è¡Œæ¥å£ | å¼‚æ­¥æ¥å£ | æ—¶é—´å¤æ‚åº¦  |
| :--- | :--- | :--- | :--- | :--- |
| **å¿«é€Ÿæ’åº** | `sort_sync` | `sort_parallel` | `sort_async` | O(n log n)  |
| **å½’å¹¶æ’åº** | `merge_sort_sync` | `merge_sort_parallel` | `merge_sort_async` | O(n log n)  |
| **æœ€å¤§å­æ•°ç»„å’Œ** | `max_subarray_sum_sync` | `max_subarray_sum_parallel` | `max_subarray_sum_async` | O(n) |
| **æœ€è¿‘ç‚¹å¯¹** | `closest_pair_sync` | `closest_pair_parallel` | `closest_pair_async` | O(n log n)  |
| **å¿«é€Ÿå¹‚**  | `fast_pow_mod`  | -  | `fast_pow_mod_async` | O(log n) |
| **çŸ©é˜µå¿«é€Ÿå¹‚** | `Matrix::pow_mod` | - | `matrix_pow_mod_async` | O(dÂ³ log n) |
| **Quickselect (ç¬¬kå°)** | `quickselect_kth` | -  | -  | O(n) å¹³å‡   |
| **Karatsuba å¤§æ•°ä¹˜æ³•**  | `karatsuba_mul` | - | - | O(n^1.585)  |

#### ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::divide_and_conquer::*;

// åŒæ­¥ç‰ˆæœ¬ï¼šæœ€å¤§å­æ•°ç»„å’Œ
fn example_max_subarray_sum() {
    let arr = vec![-2, 1, -3, 4, -1, 2, 1, -5, 4];
    let (start, end, sum) = max_subarray_sum_sync(&arr);
    println!("æœ€å¤§å­æ•°ç»„: [{}, {}), å’Œ = {}", start, end, sum); // [3, 7), å’Œ = 6
}

// å¹¶è¡Œç‰ˆæœ¬ï¼šæœ€è¿‘ç‚¹å¯¹
async fn example_closest_pair() {
    let points = vec![
        Point { x: 0.0, y: 0.0 },
        Point { x: 1.0, y: 1.0 },
        Point { x: 5.0, y: 5.0 },
    ];

    let distance = closest_pair_parallel(&points).await;
    println!("æœ€è¿‘ç‚¹å¯¹è·ç¦»: {:.2}", distance);
}

// å¿«é€Ÿå¹‚æ¨¡è¿ç®—
fn example_fast_pow() {
    let result = fast_pow_mod(2, 10, 1000); // 2^10 mod 1000
    println!("2^10 mod 1000 = {}", result); // 24
}
```

#### ä½¿ç”¨åœºæ™¯

- **å¿«é€Ÿæ’åº**: é€šç”¨æ’åºï¼Œå¹³å‡æ€§èƒ½æœ€ä¼˜
- **å½’å¹¶æ’åº**: ç¨³å®šæ’åºï¼Œå¤–éƒ¨æ’åº
- **æœ€å¤§å­æ•°ç»„**: è‚¡ç¥¨ä¹°å–ã€ä¿¡å·å¤„ç†
- **æœ€è¿‘ç‚¹å¯¹**: è®¡ç®—å‡ ä½•ã€èšç±»åˆ†æ
- **å¿«é€Ÿå¹‚**: RSAåŠ å¯†ã€æ•°è®ºè®¡ç®—

---

### 2.2 åŠ¨æ€è§„åˆ’

**æ ¸å¿ƒæ€æƒ³**: å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºé‡å å­é—®é¢˜ï¼Œå­˜å‚¨å­é—®é¢˜çš„è§£ä»¥é¿å…é‡å¤è®¡ç®—ã€‚

#### 2.2.1 API ç´¢å¼•

| ç®—æ³•  | åŒæ­¥æ¥å£ | å¹¶è¡Œæ¥å£ | å¼‚æ­¥æ¥å£  | æ—¶é—´å¤æ‚åº¦ |
| :--- | :--- | :--- | :--- | :--- |
| **æœ€é•¿å…¬å…±å­åºåˆ— (LCS)** | `lcs_sync` | `lcs_parallel` | `lcs_async` | O(mn)      |
| **0-1èƒŒåŒ…** | `knapsack_01_sync` | `knapsack_01_parallel` | `knapsack_01_async`   | O(nW)      |
| **æœ€é•¿ä¸Šå‡å­åºåˆ— (LIS)** | `lis_length_sync`              | -                      | `lis_length_async`    | O(n log n) |
| **ç¼–è¾‘è·ç¦»**             | `edit_distance_sync`           | -                      | `edit_distance_async` | O(mn)      |
| **åŠ æƒåŒºé—´è°ƒåº¦**         | `weighted_interval_scheduling` | -                      | -                     | O(n log n) |
| **çŸ©é˜µé“¾ä¹˜**             | `matrix_chain_order`           | -                      | -                     | O(nÂ³)      |
| **çŸ³å­åˆå¹¶**             | `stone_merge_min_cost`         | -                      | -                     | O(nÂ³)      |

#### 2.2.2 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::dynamic_programming::*;

// LCS: æœ€é•¿å…¬å…±å­åºåˆ—
fn example_lcs() {
    let s1 = "ABCDGH".as_bytes();
    let s2 = "AEDFHR".as_bytes();

    let (length, sequence) = lcs_sync(s1, s2);
    println!("LCS é•¿åº¦: {}", length); // 3
    println!("LCS åºåˆ—: {}", String::from_utf8_lossy(&sequence)); // "ADH"
}

// 0-1 èƒŒåŒ…é—®é¢˜
fn example_knapsack() {
    let weights = vec![2, 3, 4, 5];
    let values = vec![3, 4, 5, 6];
    let capacity = 8;

    let (max_value, selected) = knapsack_01_sync(&weights, &values, capacity);
    println!("æœ€å¤§ä»·å€¼: {}", max_value); // 9
    println!("é€‰ä¸­ç‰©å“: {:?}", selected); // [1, 3]
}

// ç¼–è¾‘è·ç¦» (Levenshtein)
async fn example_edit_distance() {
    let s1 = "kitten".as_bytes();
    let s2 = "sitting".as_bytes();

    let distance = edit_distance_async(s1, s2).await;
    println!("ç¼–è¾‘è·ç¦»: {}", distance); // 3
}

// çŸ©é˜µé“¾ä¹˜æœ€ä¼˜è§£
fn example_matrix_chain() {
    let dims = vec![10, 20, 30, 40, 30]; // 4ä¸ªçŸ©é˜µ
    let (min_ops, order) = matrix_chain_order(&dims);

    println!("æœ€å°‘ä¹˜æ³•æ¬¡æ•°: {}", min_ops); // 30000
    println!("æœ€ä¼˜æ‹¬å·åŒ–: {:?}", order);
}
```

#### 2.2.3 ä½¿ç”¨åœºæ™¯

- **LCS**: æ–‡æœ¬diffã€DNAåºåˆ—æ¯”å¯¹
- **0-1èƒŒåŒ…**: èµ„æºåˆ†é…ã€æŠ•èµ„å†³ç­–
- **LIS**: è‚¡ç¥¨äº¤æ˜“ã€ç‰ˆæœ¬æ§åˆ¶
- **ç¼–è¾‘è·ç¦»**: æ‹¼å†™æ£€æŸ¥ã€æ–‡æœ¬ç›¸ä¼¼åº¦
- **çŸ©é˜µé“¾ä¹˜**: å›¾å½¢å­¦ã€æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

---

### 2.3 è´ªå¿ƒç®—æ³•

**æ ¸å¿ƒæ€æƒ³**: æ¯æ­¥é€‰æ‹©å½“å‰æœ€ä¼˜è§£ï¼Œæ— éœ€å›æº¯ã€‚

#### 2.3.1 API ç´¢å¼•

| ç®—æ³•                    | æ¥å£                                    | æ—¶é—´å¤æ‚åº¦     | é€‚ç”¨æ¡ä»¶     |
| :--- | :--- | :--- | :--- |
| **ä½œä¸šæ’åº (æœ€å¤§æ”¶ç›Š)** | `job_sequencing_max_profit`             | O(nÂ²)          | æˆªæ­¢æ—¶é—´çº¦æŸ |
| **Dijkstra æœ€çŸ­è·¯**     | `dijkstra_sync/async`                   | O((V+E) log V) | éè´Ÿæƒé‡     |
| **Prim æœ€å°ç”Ÿæˆæ ‘**     | `mst_prim_sync/parallel/async`          | O((V+E) log V) | è¿é€šå›¾       |
| **Kruskal æœ€å°ç”Ÿæˆæ ‘**  | `mst_kruskal_sync/parallel/async`       | O(E log V)     | è¿é€šå›¾       |
| **Huffman ç¼–ç **        | (æ ‡å‡†åº“ `std::collections::BinaryHeap`) | O(n log n)     | æ•°æ®å‹ç¼©     |

#### 2.3.2 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::greedy::*;

// ä½œä¸šæ’åºï¼šæœ€å¤§æ”¶ç›Š
fn example_job_sequencing() {
    let jobs = vec![
        Job { id: 1, deadline: 4, profit: 20 },
        Job { id: 2, deadline: 1, profit: 10 },
        Job { id: 3, deadline: 1, profit: 40 },
        Job { id: 4, deadline: 1, profit: 30 },
    ];

    let (max_profit, schedule) = job_sequencing_max_profit(&jobs);
    println!("æœ€å¤§æ”¶ç›Š: {}", max_profit); // 60
    println!("è°ƒåº¦é¡ºåº: {:?}", schedule); // [3, 1]
}

// Dijkstra æœ€çŸ­è·¯å¾„
fn example_dijkstra() {
    let graph = vec![
        vec![(1, 4), (2, 1)],      // èŠ‚ç‚¹0çš„é‚»æ¥è¡¨
        vec![(2, 2), (3, 5)],      // èŠ‚ç‚¹1
        vec![(3, 1)],              // èŠ‚ç‚¹2
        vec![],                    // èŠ‚ç‚¹3
    ];

    let distances = dijkstra_sync(&graph, 0);
    println!("ä»èŠ‚ç‚¹0åˆ°å„èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»: {:?}", distances); // [0, 4, 1, 2]
}
```

#### 2.3.4 ä½¿ç”¨åœºæ™¯

- **Dijkstra**: GPSå¯¼èˆªã€ç½‘ç»œè·¯ç”±
- **Prim/Kruskal**: ç½‘ç»œè®¾è®¡ã€ç”µè·¯å¸ƒçº¿
- **ä½œä¸šæ’åº**: ä»»åŠ¡è°ƒåº¦ã€é¡¹ç›®ç®¡ç†

---

### 2.4 å›æº¯ç®—æ³•

**æ ¸å¿ƒæ€æƒ³**: ç³»ç»ŸåŒ–åœ°æœç´¢æ‰€æœ‰å¯èƒ½çš„è§£ï¼Œé€šè¿‡å‰ªææé«˜æ•ˆç‡ã€‚

#### 2.4.1. API ç´¢å¼•

| ç®—æ³•          | åŒæ­¥æ¥å£                 | å¹¶è¡Œæ¥å£                     | å¼‚æ­¥æ¥å£                  | æ—¶é—´å¤æ‚åº¦ |
| :--- | :--- | :--- | :--- | :--- |
| **Nçš‡åé—®é¢˜** | `nqueens_solutions_sync` | `nqueens_solutions_parallel` | `nqueens_solutions_async` | O(n!)      |
| **Nçš‡åè®¡æ•°** | `nqueens_count_sync`     | `nqueens_count_parallel`     | -                         | O(n!)      |
| **å…¨æ’åˆ—**    | `permutations_sync`      | `permutations_parallel`      | `permutations_async`      | O(n!)      |
| **å­é›†ç”Ÿæˆ**  | `subsets_sync`           | `subsets_parallel`           | `subsets_async`           | O(2^n)     |

#### 2.4.2 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::backtracking::*;

// Nçš‡åé—®é¢˜ï¼šæ‰¾åˆ°æ‰€æœ‰è§£
fn example_nqueens() {
    let n = 8;
    let solutions = nqueens_solutions_sync(n);

    println!("8çš‡åé—®é¢˜å…±æœ‰ {} ä¸ªè§£", solutions.len()); // 92

    // æ‰“å°ç¬¬ä¸€ä¸ªè§£
    if let Some(first_solution) = solutions.first() {
        println!("ç¬¬ä¸€ä¸ªè§£:");
        for (row, &col) in first_solution.iter().enumerate() {
            let mut line = vec!['.'; n];
            line[col] = 'Q';
            println!("{}", line.iter().collect::<String>());
        }
    }
}

// å¹¶è¡ŒNçš‡åè®¡æ•°
async fn example_nqueens_parallel() {
    let n = 12;
    let count = nqueens_count_parallel(n).await;
    println!("{}çš‡åé—®é¢˜å…±æœ‰ {} ä¸ªè§£", n, count); // 14200
}

// ç”Ÿæˆæ‰€æœ‰å­é›†
fn example_subsets() {
    let nums = vec![1, 2, 3];
    let subsets = subsets_sync(&nums);

    println!("é›†åˆ {:?} çš„æ‰€æœ‰å­é›†:", nums);
    for subset in subsets {
        println!("{:?}", subset);
    }
    // è¾“å‡º: [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]
}
```

#### 2.4.3 ä½¿ç”¨åœºæ™¯

- **Nçš‡å**: ç»„åˆä¼˜åŒ–ã€çº¦æŸæ»¡è¶³é—®é¢˜
- **å…¨æ’åˆ—**: æ—…è¡Œå•†é—®é¢˜ã€ä»»åŠ¡åˆ†é…
- **å­é›†ç”Ÿæˆ**: èƒŒåŒ…å˜ç§ã€ç»„åˆé€‰æ‹©

---

## 3. æŒ‰é—®é¢˜åŸŸåˆ†ç±»

### 3.1 æ’åºç®—æ³•

| ç®—æ³•         | æ¥å£                             | æ—¶é—´å¤æ‚åº¦      | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ |
| :--- | :--- | :--- | :--- | :--- |
| **å¿«é€Ÿæ’åº** | `sort_sync/parallel/async`       | O(n log n) å¹³å‡ | O(log n)   | âŒ     |
| **å½’å¹¶æ’åº** | `merge_sort_sync/parallel/async` | O(n log n)      | O(n)       | âœ…     |
| **å †æ’åº**   | `SortingAlgo::Heap`              | O(n log n)      | O(1)       | âŒ     |
| **å¸Œå°”æ’åº** | `SortingAlgo::Shell`             | O(n^1.3)        | O(1)       | âŒ     |
| **æ¡¶æ’åº**   | `bucket_sort_unit_f64`           | O(n+k)          | O(n+k)     | âœ…     |

#### 3.2 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::sorting::*;

// åŒæ­¥å¿«é€Ÿæ’åº
fn example_quicksort() {
    let mut arr = vec![64, 34, 25, 12, 22, 11, 90];
    sort_sync(&mut arr);
    println!("æ’åºç»“æœ: {:?}", arr);
}

// å¹¶è¡Œå½’å¹¶æ’åºï¼ˆå¤§æ•°æ®é›†ï¼‰
async fn example_merge_sort_parallel() {
    let mut arr: Vec<i32> = (0..1_000_000).rev().collect();

    let start = std::time::Instant::now();
    merge_sort_parallel(&mut arr).await;
    println!("å¹¶è¡Œå½’å¹¶æ’åºç”¨æ—¶: {:?}", start.elapsed());
}

// æ¡¶æ’åºï¼ˆæµ®ç‚¹æ•°ï¼‰
fn example_bucket_sort() {
    let mut arr = vec![0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51];
    bucket_sort_unit_f64(&mut arr);
    println!("æ¡¶æ’åºç»“æœ: {:?}", arr);
}
```

---

### 3.2 æœç´¢ç®—æ³•

| ç®—æ³•         | æ¥å£                              | æ—¶é—´å¤æ‚åº¦   | é€‚ç”¨åœºæ™¯           |
| :--- | :--- | :--- | :--- |
| **çº¿æ€§æœç´¢** | `linear_search_sync/async`        | O(n)         | æ— åºæ•°ç»„           |
| **äºŒåˆ†æœç´¢** | `binary_search_sync/async`        | O(log n)     | æœ‰åºæ•°ç»„           |
| **æŒ‡æ•°æœç´¢** | `exponential_search_sync/async`   | O(log n)     | æœ‰åºæ•°ç»„ï¼Œä½ç½®æœªçŸ¥ |
| **ä¸‰åˆ†æœç´¢** | `ternary_search_max/async`        | O(log n)     | å•å³°å‡½æ•°           |
| **æ’å€¼æœç´¢** | `interpolation_search_sync/async` | O(log log n) | å‡åŒ€åˆ†å¸ƒæ•°æ®       |
| **è·³è·ƒæœç´¢** | `jump_search_sync/async`          | O(âˆšn)        | æœ‰åºæ•°ç»„ï¼Œé¡ºåºè®¿é—® |

#### 3.2.1 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::searching::*;

// äºŒåˆ†æœç´¢
fn example_binary_search() {
    let arr = vec![1, 3, 5, 7, 9, 11, 13];
    let target = 7;

    match binary_search_sync(&arr, target) {
        Some(index) => println!("æ‰¾åˆ° {} åœ¨ç´¢å¼• {}", target, index),
        None => println!("æœªæ‰¾åˆ° {}", target),
    }
}

// ä¸‰åˆ†æœç´¢ï¼šæ‰¾åˆ°å•å³°å‡½æ•°çš„æœ€å¤§å€¼
async fn example_ternary_search() {
    // f(x) = -(x-5)^2 + 25ï¼Œæœ€å¤§å€¼åœ¨ x=5
    let f = |x: f64| -(x - 5.0).powi(2) + 25.0;

    let (max_x, max_val) = ternary_search_max_async(f, 0.0, 10.0, 1e-6).await;
    println!("æœ€å¤§å€¼ç‚¹: x = {:.2}, f(x) = {:.2}", max_x, max_val);
}
```

---

### 3.3 å›¾è®ºç®—æ³•

#### æœ€çŸ­è·¯å¾„

| ç®—æ³•               | æ¥å£                                    | æ—¶é—´å¤æ‚åº¦     | é€‚ç”¨åœºæ™¯         |
| :--- | :--- | :--- | :--- |
| **Dijkstra**       | `dijkstra_sync/async`                   | O((V+E) log V) | éè´Ÿæƒé‡         |
| **Bellman-Ford**   | `bellman_ford_sync/async`               | O(VE)          | è´Ÿæƒé‡ï¼Œæ£€æµ‹è´Ÿç¯ |
| **Floyd-Warshall** | `floyd_warshall_sync/async`             | O(VÂ³)          | å…¨æºæœ€çŸ­è·¯å¾„     |
| **BFS æœ€çŸ­è·¯**     | `bfs_shortest_path_sync/parallel/async` | O(V+E)         | æ— æƒå›¾           |

#### æœ€å°ç”Ÿæˆæ ‘

| ç®—æ³•        | æ¥å£                              | æ—¶é—´å¤æ‚åº¦     |
| :--- | :--- | :--- |
| **Kruskal** | `mst_kruskal_sync/parallel/async` | O(E log V)     |
| **Prim**    | `mst_prim_sync/parallel/async`    | O((V+E) log V) |

#### æ‹“æ‰‘æ’åºä¸è¿é€šæ€§

| ç®—æ³•                  | æ¥å£                            | æ—¶é—´å¤æ‚åº¦ |
| :--- | :--- | :--- |
| **æ‹“æ‰‘æ’åº**          | `topo_sort_sync/parallel/async` | O(V+E)     |
| **Tarjan å¼ºè¿é€šåˆ†é‡** | `tarjan_scc_sync/async`         | O(V+E)     |

#### ç½‘ç»œæµ

| ç®—æ³•                    | æ¥å£                          | æ—¶é—´å¤æ‚åº¦ |
| :--- | :--- | :--- |
| **Dinic æœ€å¤§æµ**        | `max_flow_dinic_sync/async`   | O(VÂ²E)     |
| **Edmonds-Karp æœ€å¤§æµ** | `max_flow_edmonds_karp/async` | O(VEÂ²)     |
| **æœ€å°å‰²**              | `min_cut_from_residual`       | O(VÂ²E)     |

#### å…¶ä»–

| ç®—æ³•               | æ¥å£                       | æ—¶é—´å¤æ‚åº¦    | åŠŸèƒ½           |
| :--- | :--- | :--- | :--- |
| **Hopcroft-Karp**  | `hopcroft_karp_sync/async` | O(EâˆšV)        | äºŒåˆ†å›¾æœ€å¤§åŒ¹é… |
| **LCA (äºŒå‰æå‡)** | `LcaBinaryLift::new/lca`   | O(log n) æŸ¥è¯¢ | æœ€è¿‘å…¬å…±ç¥–å…ˆ   |
| **æ ‘ç›´å¾„**         | `tree_diameter_undirected` | O(V)          | æ— å‘æ ‘æœ€é•¿è·¯å¾„ |

#### ä»£ç ç¤ºä¾‹1

```rust
use c08_algorithms::graph::*;

// Dijkstra æœ€çŸ­è·¯å¾„
fn example_dijkstra() {
    let graph = vec![
        vec![(1, 4), (2, 1)],
        vec![(2, 2), (3, 5)],
        vec![(3, 1)],
        vec![],
    ];

    let distances = dijkstra_sync(&graph, 0);
    println!("æœ€çŸ­è·ç¦»: {:?}", distances);
}

// Dinic æœ€å¤§æµ
async fn example_max_flow() {
    let n = 6; // 6ä¸ªèŠ‚ç‚¹
    let edges = vec![
        (0, 1, 16), (0, 2, 13),
        (1, 2, 10), (1, 3, 12),
        (2, 1, 4), (2, 4, 14),
        (3, 2, 9), (3, 5, 20),
        (4, 3, 7), (4, 5, 4),
    ];

    let max_flow = max_flow_dinic_async(n, &edges, 0, 5).await;
    println!("æœ€å¤§æµ: {}", max_flow); // 23
}

// Tarjan å¼ºè¿é€šåˆ†é‡
fn example_tarjan_scc() {
    let graph = vec![
        vec![1],        // 0 -> 1
        vec![2],        // 1 -> 2
        vec![0, 3],     // 2 -> 0, 3
        vec![4],        // 3 -> 4
        vec![3],        // 4 -> 3
    ];

    let sccs = tarjan_scc_sync(&graph);
    println!("å¼ºè¿é€šåˆ†é‡: {:?}", sccs); // [[3, 4], [0, 1, 2]]
}
```

---

### 3.4 å­—ç¬¦ä¸²ç®—æ³•

| ç®—æ³•                     | æ¥å£                                | æ—¶é—´å¤æ‚åº¦  | åŠŸèƒ½         |
| :--- | :--- | :--- | :--- |
| **KMP**                  | `kmp_search/async`                  | O(n+m)      | æ¨¡å¼åŒ¹é…     |
| **Rabin-Karp**           | `rabin_karp_search/async`           | O(n+m)      | å¤šæ¨¡å¼åŒ¹é…   |
| **Aho-Corasick**         | `build_trie` + `ac_search/async`    | O(n+m+z)    | å¤šæ¨¡å¼åŒ¹é…   |
| **Z-Algorithm**          | `z_algorithm` / `z_search/async`    | O(n)        | æ¨¡å¼åŒ¹é…     |
| **Boyer-Moore-Horspool** | `bmh_search/async`                  | O(n/m) å¹³å‡ | å®ç”¨å¿«é€ŸåŒ¹é… |
| **Manacher**             | `manacher_longest_palindrome/async` | O(n)        | æœ€é•¿å›æ–‡å­ä¸² |
| **Suffix Array**         | `suffix_array`                      | O(n log n)  | åç¼€æ•°ç»„     |
| **LCP (Kasai)**          | `lcp_kasai`                         | O(n)        | æœ€é•¿å…¬å…±å‰ç¼€ |
| **Suffix Automaton**     | `SuffixAutomaton`                   | O(n)        | ä¸åŒå­ä¸²è®¡æ•° |

#### ä»£ç ç¤ºä¾‹2

```rust
use c08_algorithms::string_algorithms::*;

// KMP æ¨¡å¼åŒ¹é…
async fn example_kmp() {
    let text = b"ABABDABACDABABCABAB";
    let pattern = b"ABABCABAB";

    let positions = kmp_search_async(text, pattern).await;
    println!("æ‰¾åˆ°æ¨¡å¼åœ¨ä½ç½®: {:?}", positions); // [10]
}

// Aho-Corasick å¤šæ¨¡å¼åŒ¹é…
fn example_aho_corasick() {
    let patterns = vec![b"he".to_vec(), b"she".to_vec(), b"his".to_vec(), b"hers".to_vec()];
    let trie = build_trie(&patterns);

    let text = b"ushers";
    let matches = trie.ac_search(text);

    for (pos, pattern_id) in matches {
        println!("åœ¨ä½ç½® {} æ‰¾åˆ°æ¨¡å¼ {}", pos, pattern_id);
    }
}

// Manacher æœ€é•¿å›æ–‡å­ä¸²
async fn example_manacher() {
    let text = b"babad";
    let (start, length) = manacher_longest_palindrome_async(text).await;

    let palindrome = &text[start..start+length];
    println!("æœ€é•¿å›æ–‡: {}", String::from_utf8_lossy(palindrome)); // "bab" æˆ– "aba"
}

// Suffix Automaton: ä¸åŒå­ä¸²è®¡æ•°
fn example_suffix_automaton() {
    let text = b"abcbc";
    let sa = SuffixAutomaton::from_bytes(text);

    let count = sa.count_distinct_substrings();
    println!("ä¸åŒå­ä¸²æ•°é‡: {}", count); // 12
}
```

---

### 3.5 æ•°å€¼ç®—æ³•

| ç®—æ³•             | æ¥å£                 | æ—¶é—´å¤æ‚åº¦ | åŠŸèƒ½        |
| :--- | :--- | :--- | :--- |
| **å¿«é€Ÿå¹‚**       | `fast_pow_mod/async` | O(log n)   | æ¨¡å¹‚è¿ç®—    |
| **æ‰©å±•æ¬§å‡ é‡Œå¾—** | `egcd`               | O(log n)   | æ±‚GCDå’Œç³»æ•° |
| **æ¨¡é€†**         | `mod_inv`            | O(log n)   | æ¨¡é€†å…ƒ      |
| **Miller-Rabin** | `is_prime`           | O(k log n) | ç´ æ€§æµ‹è¯•    |
| **Pollard Rho**  | `pollard_rho`        | O(n^1/4)   | å¤§æ•°åˆ†è§£    |

#### ä»£ç ç¤ºä¾‹3

```rust
use c08_algorithms::number_theory::*;

// æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•
fn example_egcd() {
    let (gcd, x, y) = egcd(240, 46);
    println!("gcd(240, 46) = {}", gcd); // 2
    println!("240*{} + 46*{} = {}", x, y, gcd); // 240*(-9) + 46*(47) = 2
}

// æ¨¡é€†å…ƒ
fn example_mod_inv() {
    let a = 3;
    let m = 11;

    match mod_inv(a, m) {
        Some(inv) => {
            println!("{} * {} â‰¡ 1 (mod {})", a, inv, m); // 3 * 4 â‰¡ 1 (mod 11)
        },
        None => println!("{} åœ¨æ¨¡ {} ä¸‹æ— é€†å…ƒ", a, m),
    }
}

// Miller-Rabin ç´ æ€§æµ‹è¯•
fn example_is_prime() {
    let candidates = vec![2, 17, 221, 561, 1000000007];

    for &n in &candidates {
        if is_prime(n, 20) {
            println!("{} æ˜¯ç´ æ•°", n);
        } else {
            println!("{} æ˜¯åˆæ•°", n);
        }
    }
}

// Pollard Rho å¤§æ•°åˆ†è§£
fn example_pollard_rho() {
    let n = 8051; // = 83 * 97

    if let Some(factor) = pollard_rho(n) {
        println!("{} çš„ä¸€ä¸ªå› å­: {}", n, factor); // 83 æˆ– 97
        println!("å¦ä¸€ä¸ªå› å­: {}", n / factor);
    }
}
```

---

## 4. æŒ‰æ‰§è¡Œæ¨¡å‹åˆ†ç±»

### 4.1 åŒæ­¥ç®—æ³•

**ç‰¹ç‚¹**: å•çº¿ç¨‹æ‰§è¡Œï¼Œé€‚åˆ CPU å¯†é›†å‹è®¡ç®—ã€‚

**å‘½åçº¦å®š**: `*_sync`

**ä½¿ç”¨åœºæ™¯**:

- æ•°æ®è§„æ¨¡å°ï¼ˆ< 10,000ï¼‰
- CPU å¯†é›†å‹è®¡ç®—
- æ— å¹¶å‘éœ€æ±‚

### 4.2 å¹¶è¡Œç®—æ³•

**ç‰¹ç‚¹**: åˆ©ç”¨å¤šæ ¸ CPUï¼Œä½¿ç”¨ `rayon` è¿›è¡Œæ•°æ®å¹¶è¡Œã€‚

**å‘½åçº¦å®š**: `*_parallel`

**ä½¿ç”¨åœºæ™¯**:

- æ•°æ®è§„æ¨¡å¤§ï¼ˆ> 100,000ï¼‰
- å¯åˆ†è§£çš„ç‹¬ç«‹ä»»åŠ¡
- CPU å¯†é›†å‹è®¡ç®—

#### ä»£ç ç¤ºä¾‹4

```rust
use c08_algorithms::sorting::*;

async fn compare_sync_vs_parallel() {
    let size = 10_000_000;
    let mut arr1: Vec<i32> = (0..size).rev().collect();
    let mut arr2 = arr1.clone();

    // åŒæ­¥ç‰ˆæœ¬
    let start = std::time::Instant::now();
    sort_sync(&mut arr1);
    let sync_time = start.elapsed();

    // å¹¶è¡Œç‰ˆæœ¬
    let start = std::time::Instant::now();
    sort_parallel(&mut arr2).await;
    let parallel_time = start.elapsed();

    println!("åŒæ­¥è€—æ—¶: {:?}", sync_time);
    println!("å¹¶è¡Œè€—æ—¶: {:?}", parallel_time);
    println!("åŠ é€Ÿæ¯”: {:.2}x", sync_time.as_secs_f64() / parallel_time.as_secs_f64());
}
```

### 4.3 å¼‚æ­¥ç®—æ³•

**ç‰¹ç‚¹**: ä½¿ç”¨ Tokio è¿è¡Œæ—¶ï¼Œé€‚åˆ I/O å¯†é›†å‹æˆ–éœ€è¦å¹¶å‘çš„åœºæ™¯ã€‚

**å‘½åçº¦å®š**: `*_async`

**ä½¿ç”¨åœºæ™¯**:

- I/O å¯†é›†å‹æ“ä½œ
- éœ€è¦è¶…æ—¶æ§åˆ¶
- å¼‚æ­¥ç”Ÿæ€é›†æˆ

#### ä»£ç ç¤ºä¾‹5

```rust
use c08_algorithms::graph::*;
use tokio::time::{timeout, Duration};

async fn async_with_timeout() {
    let graph = build_large_graph();

    // å¸¦è¶…æ—¶çš„å¼‚æ­¥è®¡ç®—
    match timeout(Duration::from_secs(5), dijkstra_async(&graph, 0)).await {
        Ok(result) => println!("è®¡ç®—å®Œæˆ: {:?}", result),
        Err(_) => println!("è®¡ç®—è¶…æ—¶"),
    }
}
```

---

## 5. æ•°æ®ç»“æ„åˆ†ç±»

| æ•°æ®ç»“æ„                      | æ¥å£                                             | æ“ä½œå¤æ‚åº¦ | åŠŸèƒ½               |
| :--- | :--- | :--- | :--- |
| **Fenwick Tree (æ ‘çŠ¶æ•°ç»„)**   | `Fenwick::new/add/sum_prefix/range_sum`          | O(log n)   | å‰ç¼€å’Œã€åŒºé—´å’Œ     |
| **Segment Tree (çº¿æ®µæ ‘)**     | `SegmentTree::from_slice/update_point/query_sum` | O(log n)   | åŒºé—´æŸ¥è¯¢ã€å•ç‚¹æ›´æ–° |
| **Disjoint Set (å¹¶æŸ¥é›†)**     | `DisjointSet::new/find/union`                    | O(Î±(n))    | è¿é€šæ€§æŸ¥è¯¢ã€åˆå¹¶   |
| **Priority Queue (ä¼˜å…ˆé˜Ÿåˆ—)** | `PriorityQueue`                                  | O(log n)   | å †æ’åºã€ä¼˜å…ˆçº§è°ƒåº¦ |
| **Sparse Table (ç¨€ç–è¡¨)**     | `SparseTable::build/query_idempotent`            | O(1) æŸ¥è¯¢  | RMQã€LCA           |
| **LRU Cache**                 | `LruCache`                                       | O(1)       | ç¼“å­˜æ·˜æ±°           |

### 5.1 ä»£ç ç¤ºä¾‹

```rust
use c08_algorithms::data_structure::*;

// Fenwick Tree: åŒºé—´å’ŒæŸ¥è¯¢
fn example_fenwick() {
    let mut fenwick = Fenwick::new(10);

    fenwick.add(0, 3);
    fenwick.add(1, 2);
    fenwick.add(2, -1);
    fenwick.add(3, 6);

    println!("å‰ç¼€å’Œ [0, 3): {}", fenwick.sum_prefix(3)); // 4
    println!("åŒºé—´å’Œ [1, 4): {}", fenwick.range_sum(1, 4)); // 7
}

// Segment Tree: åŒºé—´æŸ¥è¯¢
fn example_segment_tree() {
    let arr = vec![1, 3, 5, 7, 9, 11];
    let mut seg_tree = SegmentTree::from_slice(&arr, 0);

    println!("åŒºé—´å’Œ [1, 4): {}", seg_tree.query_sum(1, 4)); // 15

    seg_tree.update_point(2, 10); // arr[2] = 5 -> 10
    println!("æ›´æ–°ååŒºé—´å’Œ [1, 4): {}", seg_tree.query_sum(1, 4)); // 20
}

// Disjoint Set: è¿é€šæ€§
fn example_dsu() {
    let mut dsu = DisjointSet::new(5);

    dsu.union(0, 1);
    dsu.union(1, 2);
    dsu.union(3, 4);

    println!("0 å’Œ 2 è¿é€š: {}", dsu.find(0) == dsu.find(2)); // true
    println!("0 å’Œ 3 è¿é€š: {}", dsu.find(0) == dsu.find(3)); // false
}

// Sparse Table: RMQ (åŒºé—´æœ€å°å€¼æŸ¥è¯¢)
fn example_sparse_table() {
    let arr = vec![3, 1, 4, 1, 5, 9, 2, 6];
    let st = SparseTable::build(&arr, |a, b| *a.min(b));

    println!("åŒºé—´ [2, 6) æœ€å°å€¼: {}", st.query_idempotent(2, 6)); // 1
}
```

---

## 6. ç®—æ³•å¤æ‚åº¦å¿«é€ŸæŸ¥è¯¢

### æ’åºç®—æ³•

| ç®—æ³•     | æœ€å¥½       | å¹³å‡       | æœ€å       | ç©ºé—´     | ç¨³å®šæ€§ |
| :--- | :--- | :--- | :--- | :--- | :--- |
| å¿«é€Ÿæ’åº | O(n log n) | O(n log n) | O(nÂ²)      | O(log n) | âŒ     |
| å½’å¹¶æ’åº | O(n log n) | O(n log n) | O(n log n) | O(n)     | âœ…     |
| å †æ’åº   | O(n log n) | O(n log n) | O(n log n) | O(1)     | âŒ     |
| æ¡¶æ’åº   | O(n+k)     | O(n+k)     | O(nÂ²)      | O(n+k)   | âœ…     |

### å›¾ç®—æ³•

| ç®—æ³•           | æ—¶é—´å¤æ‚åº¦     | ç©ºé—´å¤æ‚åº¦ |
| :--- | :--- | :--- |
| BFS/DFS        | O(V+E)         | O(V)       |
| Dijkstra       | O((V+E) log V) | O(V)       |
| Bellman-Ford   | O(VE)          | O(V)       |
| Floyd-Warshall | O(VÂ³)          | O(VÂ²)      |
| Kruskal MST    | O(E log V)     | O(V)       |
| Prim MST       | O((V+E) log V) | O(V)       |
| Tarjan SCC     | O(V+E)         | O(V)       |
| Dinic æœ€å¤§æµ   | O(VÂ²E)         | O(V+E)     |

### å­—ç¬¦ä¸²ç®—æ³•

| ç®—æ³•         | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é¢„å¤„ç†     |
| :--- | :--- | :--- | :--- |
| KMP          | O(n+m)     | O(m)       | O(m)       |
| Rabin-Karp   | O(n+m)     | O(1)       | O(m)       |
| Aho-Corasick | O(n+m+z)   | O(mÃ—Î£)     | O(mÃ—Î£)     |
| Manacher     | O(n)       | O(n)       | -          |
| Suffix Array | O(n log n) | O(n)       | O(n log n) |

### åŠ¨æ€è§„åˆ’

| é—®é¢˜     | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜åŒ–ç©ºé—´    |
| :--- | :--- | :--- | :--- |
| LCS      | O(mn)      | O(mn)      | O(min(m,n)) |
| 0-1èƒŒåŒ…  | O(nW)      | O(nW)      | O(W)        |
| LIS      | O(n log n) | O(n)       | -           |
| ç¼–è¾‘è·ç¦» | O(mn)      | O(mn)      | O(min(m,n)) |
| çŸ©é˜µé“¾ä¹˜ | O(nÂ³)      | O(nÂ²)      | -           |

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- **[02\_æ•°æ®ç»“æ„å‚è€ƒ](./02_æ•°æ®ç»“æ„å‚è€ƒ.md)** - æ•°æ®ç»“æ„è¯¦ç»†API
- **[03_Rust190ç‰¹æ€§å‚è€ƒ](./03_Rust190ç‰¹æ€§å‚è€ƒ.md)** - Rust 1.90+ ç‰¹æ€§å‚è€ƒï¼›ç®—æ³•æ–°ç‰¹æ€§è§ [RUST_192_ALGORITHMS_IMPROVEMENTS](../RUST_192_ALGORITHMS_IMPROVEMENTS.md)
- **[04\_ç®—æ³•æ€§èƒ½å‚è€ƒ](./04_ç®—æ³•æ€§èƒ½å‚è€ƒ.md)** - æ€§èƒ½åŸºå‡†æµ‹è¯•æ•°æ®
- **[05\_æ ‡å‡†åº“ç®—æ³•å‚è€ƒ](./05_æ ‡å‡†åº“ç®—æ³•å‚è€ƒ.md)** - æ ‡å‡†åº“ç®—æ³•å¯¹æ¯”

---

## ğŸ¯ ä½¿ç”¨å»ºè®®

### 1. å¦‚ä½•é€‰æ‹©ç®—æ³•

```rust
// å†³ç­–æ ‘
fn choose_algorithm(problem: &str, data_size: usize) -> &'static str {
    match problem {
        "æ’åº" => {
            if data_size < 50 {
                "æ’å…¥æ’åº"
            } else if needs_stability() {
                "å½’å¹¶æ’åº"
            } else {
                "å¿«é€Ÿæ’åº"
            }
        },
        "æœç´¢" => {
            if is_sorted() {
                "äºŒåˆ†æœç´¢"
            } else {
                "çº¿æ€§æœç´¢"
            }
        },
        "æœ€çŸ­è·¯å¾„" => {
            if has_negative_weight() {
                "Bellman-Ford"
            } else if single_source() {
                "Dijkstra"
            } else {
                "Floyd-Warshall"
            }
        },
        _ => "æŸ¥é˜…æ–‡æ¡£",
    }
}
```

### 2. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```rust
// æŠ€å·§1: å°æ•°æ®é›†ä½¿ç”¨åŒæ­¥ç‰ˆæœ¬
if data.len() < 10_000 {
    sort_sync(&mut data);
} else {
    sort_parallel(&mut data).await;
}

// æŠ€å·§2: ä½¿ç”¨ Rayon å¹¶è¡Œè¿­ä»£å™¨
use rayon::prelude::*;
let results: Vec<_> = data.par_iter()
    .map(|x| expensive_computation(x))
    .collect();

// æŠ€å·§3: é¢„åˆ†é…ç©ºé—´
let mut result = Vec::with_capacity(expected_size);
```

### 3. å¸¸è§é™·é˜±

```rust
// âŒ é”™è¯¯ï¼šé‡å¤è®¡ç®—
fn fibonacci_naive(n: u64) -> u64 {
    if n <= 1 { n } else { fibonacci_naive(n-1) + fibonacci_naive(n-2) }
}

// âœ… æ­£ç¡®ï¼šåŠ¨æ€è§„åˆ’
fn fibonacci_dp(n: usize) -> u64 {
    if n <= 1 { return n as u64; }

    let mut dp = vec![0; n+1];
    dp[1] = 1;

    for i in 2..=n {
        dp[i] = dp[i-1] + dp[i-2];
    }

    dp[n]
}
```

---

**æ–‡æ¡£ç»´æŠ¤**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-23
**è´¨é‡è¯„åˆ†**: â­â­â­â­â­
