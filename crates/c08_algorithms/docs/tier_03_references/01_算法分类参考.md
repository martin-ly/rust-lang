# 算法分类参考手册

> **文档类型**: Tier 3 技术参考
> **目标读者**: 需要查阅算法分类和API的开发者
> **Rust 版本**: 1.90+
> **Edition**: 2024
> **最后更新**: 2025-10-23

---

## 📖 目录

- [算法分类参考手册](#算法分类参考手册)
  - [📖 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 按设计范式分类](#2-按设计范式分类)
    - [2.1 分治算法](#21-分治算法)
      - [API 索引](#api-索引)
      - [代码示例](#代码示例)
      - [使用场景](#使用场景)
    - [2.2 动态规划](#22-动态规划)
      - [2.2.1 API 索引](#221-api-索引)
      - [2.2.2 代码示例](#222-代码示例)
      - [2.2.3 使用场景](#223-使用场景)
    - [2.3 贪心算法](#23-贪心算法)
      - [2.3.1 API 索引](#231-api-索引)
      - [2.3.2 代码示例](#232-代码示例)
      - [2.3.4 使用场景](#234-使用场景)
    - [2.4 回溯算法](#24-回溯算法)
      - [2.4.1. API 索引](#241-api-索引)
      - [2.4.2 代码示例](#242-代码示例)
      - [2.4.3 使用场景](#243-使用场景)
  - [3. 按问题域分类](#3-按问题域分类)
    - [3.1 排序算法](#31-排序算法)
      - [3.2 代码示例](#32-代码示例)
    - [3.2 搜索算法](#32-搜索算法)
      - [3.2.1 代码示例](#321-代码示例)
    - [3.3 图论算法](#33-图论算法)
      - [最短路径](#最短路径)
      - [最小生成树](#最小生成树)
      - [拓扑排序与连通性](#拓扑排序与连通性)
      - [网络流](#网络流)
      - [其他](#其他)
      - [代码示例1](#代码示例1)
    - [3.4 字符串算法](#34-字符串算法)
      - [代码示例2](#代码示例2)
    - [3.5 数值算法](#35-数值算法)
      - [代码示例3](#代码示例3)
  - [4. 按执行模型分类](#4-按执行模型分类)
    - [4.1 同步算法](#41-同步算法)
    - [4.2 并行算法](#42-并行算法)
      - [代码示例4](#代码示例4)
    - [4.3 异步算法](#43-异步算法)
      - [代码示例5](#代码示例5)
  - [5. 数据结构分类](#5-数据结构分类)
    - [5.1 代码示例](#51-代码示例)
  - [6. 算法复杂度快速查询](#6-算法复杂度快速查询)
    - [排序算法](#排序算法)
    - [图算法](#图算法)
    - [字符串算法](#字符串算法)
    - [动态规划](#动态规划)
  - [📚 相关文档](#-相关文档)
  - [🎯 使用建议](#-使用建议)
    - [1. 如何选择算法](#1-如何选择算法)
    - [2. 性能优化技巧](#2-性能优化技巧)
    - [3. 常见陷阱](#3-常见陷阱)

---

## 1. 概述

本文档提供了 C08 Algorithms 模块中所有算法的完整分类参考，按照**设计范式**、**问题域**和**执行模型**三个维度进行分类，便于快速查找和选择合适的算法。

---

## 2. 按设计范式分类

### 2.1 分治算法

**核心思想**: 将问题分解为规模更小的子问题，递归求解后合并结果。

#### API 索引

| 算法 | 同步接口 | 并行接口 | 异步接口 | 时间复杂度 |
| --- | --- | --- | --- | --- |
| **快速排序** | `sort_sync` | `sort_parallel` | `sort_async` | O(n log n) |
| **归并排序** | `merge_sort_sync` | `merge_sort_parallel` | `merge_sort_async` | O(n log n) |
| **最大子数组和** | `max_subarray_sum_sync` | `max_subarray_sum_parallel` | `max_subarray_sum_async` | O(n) |
| **最近点对** | `closest_pair_sync` | `closest_pair_parallel` | `closest_pair_async` | O(n log n) |
| **快速幂** | `fast_pow_mod` | - | `fast_pow_mod_async` | O(log n) |
| **矩阵快速幂** | `Matrix::pow_mod` | - | `matrix_pow_mod_async` | O(d³ log n) |
| **Quickselect (第k小)** | `quickselect_kth` | - | - | O(n) 平均 |
| **Karatsuba 大数乘法** | `karatsuba_mul` | - | - | O(n^1.585) |

#### 代码示例

```rust
use c08_algorithms::divide_and_conquer::*;

// 同步版本：最大子数组和
fn example_max_subarray_sum() {
    let arr = vec![-2, 1, -3, 4, -1, 2, 1, -5, 4];
    let (start, end, sum) = max_subarray_sum_sync(&arr);
    println!("最大子数组: [{}, {}), 和 = {}", start, end, sum); // [3, 7), 和 = 6
}

// 并行版本：最近点对
async fn example_closest_pair() {
    let points = vec![
        Point { x: 0.0, y: 0.0 },
        Point { x: 1.0, y: 1.0 },
        Point { x: 5.0, y: 5.0 },
    ];

    let distance = closest_pair_parallel(&points).await;
    println!("最近点对距离: {:.2}", distance);
}

// 快速幂模运算
fn example_fast_pow() {
    let result = fast_pow_mod(2, 10, 1000); // 2^10 mod 1000
    println!("2^10 mod 1000 = {}", result); // 24
}
```

#### 使用场景

- **快速排序**: 通用排序，平均性能最优
- **归并排序**: 稳定排序，外部排序
- **最大子数组**: 股票买卖、信号处理
- **最近点对**: 计算几何、聚类分析
- **快速幂**: RSA加密、数论计算

---

### 2.2 动态规划

**核心思想**: 将复杂问题分解为重叠子问题，存储子问题的解以避免重复计算。

#### 2.2.1 API 索引

| 算法 | 同步接口 | 并行接口 | 异步接口 | 时间复杂度 |
| --- | --- | --- | --- | --- |
| **最长公共子序列 (LCS)** | `lcs_sync` | `lcs_parallel` | `lcs_async` | O(mn) |
| **0-1背包** | `knapsack_01_sync` | `knapsack_01_parallel` | `knapsack_01_async` | O(nW) |
| **最长上升子序列 (LIS)** | `lis_length_sync` | - | `lis_length_async` | O(n log n) |
| **编辑距离** | `edit_distance_sync` | - | `edit_distance_async` | O(mn) |
| **加权区间调度** | `weighted_interval_scheduling` | - | - | O(n log n) |
| **矩阵链乘** | `matrix_chain_order` | - | - | O(n³) |
| **石子合并** | `stone_merge_min_cost` | - | - | O(n³) |

#### 2.2.2 代码示例

```rust
use c08_algorithms::dynamic_programming::*;

// LCS: 最长公共子序列
fn example_lcs() {
    let s1 = "ABCDGH".as_bytes();
    let s2 = "AEDFHR".as_bytes();

    let (length, sequence) = lcs_sync(s1, s2);
    println!("LCS 长度: {}", length); // 3
    println!("LCS 序列: {}", String::from_utf8_lossy(&sequence)); // "ADH"
}

// 0-1 背包问题
fn example_knapsack() {
    let weights = vec![2, 3, 4, 5];
    let values = vec![3, 4, 5, 6];
    let capacity = 8;

    let (max_value, selected) = knapsack_01_sync(&weights, &values, capacity);
    println!("最大价值: {}", max_value); // 9
    println!("选中物品: {:?}", selected); // [1, 3]
}

// 编辑距离 (Levenshtein)
async fn example_edit_distance() {
    let s1 = "kitten".as_bytes();
    let s2 = "sitting".as_bytes();

    let distance = edit_distance_async(s1, s2).await;
    println!("编辑距离: {}", distance); // 3
}

// 矩阵链乘最优解
fn example_matrix_chain() {
    let dims = vec![10, 20, 30, 40, 30]; // 4个矩阵
    let (min_ops, order) = matrix_chain_order(&dims);

    println!("最少乘法次数: {}", min_ops); // 30000
    println!("最优括号化: {:?}", order);
}
```

#### 2.2.3 使用场景

- **LCS**: 文本diff、DNA序列比对
- **0-1背包**: 资源分配、投资决策
- **LIS**: 股票交易、版本控制
- **编辑距离**: 拼写检查、文本相似度
- **矩阵链乘**: 图形学、数据库查询优化

---

### 2.3 贪心算法

**核心思想**: 每步选择当前最优解，无需回溯。

#### 2.3.1 API 索引

| 算法 | 接口 | 时间复杂度 | 适用条件 |
|------|------|-----------|---------|
| **作业排序 (最大收益)** | `job_sequencing_max_profit` | O(n²) | 截止时间约束 |
| **Dijkstra 最短路** | `dijkstra_sync/async` | O((V+E) log V) | 非负权重 |
| **Prim 最小生成树** | `mst_prim_sync/parallel/async` | O((V+E) log V) | 连通图 |
| **Kruskal 最小生成树** | `mst_kruskal_sync/parallel/async` | O(E log V) | 连通图 |
| **Huffman 编码** | (标准库 `std::collections::BinaryHeap`) | O(n log n) | 数据压缩 |

#### 2.3.2 代码示例

```rust
use c08_algorithms::greedy::*;

// 作业排序：最大收益
fn example_job_sequencing() {
    let jobs = vec![
        Job { id: 1, deadline: 4, profit: 20 },
        Job { id: 2, deadline: 1, profit: 10 },
        Job { id: 3, deadline: 1, profit: 40 },
        Job { id: 4, deadline: 1, profit: 30 },
    ];

    let (max_profit, schedule) = job_sequencing_max_profit(&jobs);
    println!("最大收益: {}", max_profit); // 60
    println!("调度顺序: {:?}", schedule); // [3, 1]
}

// Dijkstra 最短路径
fn example_dijkstra() {
    let graph = vec![
        vec![(1, 4), (2, 1)],      // 节点0的邻接表
        vec![(2, 2), (3, 5)],      // 节点1
        vec![(3, 1)],              // 节点2
        vec![],                    // 节点3
    ];

    let distances = dijkstra_sync(&graph, 0);
    println!("从节点0到各节点的最短距离: {:?}", distances); // [0, 4, 1, 2]
}
```

#### 2.3.4 使用场景

- **Dijkstra**: GPS导航、网络路由
- **Prim/Kruskal**: 网络设计、电路布线
- **作业排序**: 任务调度、项目管理

---

### 2.4 回溯算法

**核心思想**: 系统化地搜索所有可能的解，通过剪枝提高效率。

#### 2.4.1. API 索引

| 算法 | 同步接口 | 并行接口 | 异步接口 | 时间复杂度 |
| --- | --- | --- | --- | --- |
| **N皇后问题** | `nqueens_solutions_sync` | `nqueens_solutions_parallel` | `nqueens_solutions_async` | O(n!) |
| **N皇后计数** | `nqueens_count_sync` | `nqueens_count_parallel` | - | O(n!) |
| **全排列** | `permutations_sync` | `permutations_parallel` | `permutations_async` | O(n!) |
| **子集生成** | `subsets_sync` | `subsets_parallel` | `subsets_async` | O(2^n) |

#### 2.4.2 代码示例

```rust
use c08_algorithms::backtracking::*;

// N皇后问题：找到所有解
fn example_nqueens() {
    let n = 8;
    let solutions = nqueens_solutions_sync(n);

    println!("8皇后问题共有 {} 个解", solutions.len()); // 92

    // 打印第一个解
    if let Some(first_solution) = solutions.first() {
        println!("第一个解:");
        for (row, &col) in first_solution.iter().enumerate() {
            let mut line = vec!['.'; n];
            line[col] = 'Q';
            println!("{}", line.iter().collect::<String>());
        }
    }
}

// 并行N皇后计数
async fn example_nqueens_parallel() {
    let n = 12;
    let count = nqueens_count_parallel(n).await;
    println!("{}皇后问题共有 {} 个解", n, count); // 14200
}

// 生成所有子集
fn example_subsets() {
    let nums = vec![1, 2, 3];
    let subsets = subsets_sync(&nums);

    println!("集合 {:?} 的所有子集:", nums);
    for subset in subsets {
        println!("{:?}", subset);
    }
    // 输出: [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]
}
```

#### 2.4.3 使用场景

- **N皇后**: 组合优化、约束满足问题
- **全排列**: 旅行商问题、任务分配
- **子集生成**: 背包变种、组合选择

---

## 3. 按问题域分类

### 3.1 排序算法

| 算法 | 接口 | 时间复杂度 | 空间复杂度 | 稳定性 |
|------|------|-----------|-----------|--------|
| **快速排序** | `sort_sync/parallel/async` | O(n log n) 平均 | O(log n) | ❌ |
| **归并排序** | `merge_sort_sync/parallel/async` | O(n log n) | O(n) | ✅ |
| **堆排序** | `SortingAlgo::Heap` | O(n log n) | O(1) | ❌ |
| **希尔排序** | `SortingAlgo::Shell` | O(n^1.3) | O(1) | ❌ |
| **桶排序** | `bucket_sort_unit_f64` | O(n+k) | O(n+k) | ✅ |

#### 3.2 代码示例

```rust
use c08_algorithms::sorting::*;

// 同步快速排序
fn example_quicksort() {
    let mut arr = vec![64, 34, 25, 12, 22, 11, 90];
    sort_sync(&mut arr);
    println!("排序结果: {:?}", arr);
}

// 并行归并排序（大数据集）
async fn example_merge_sort_parallel() {
    let mut arr: Vec<i32> = (0..1_000_000).rev().collect();

    let start = std::time::Instant::now();
    merge_sort_parallel(&mut arr).await;
    println!("并行归并排序用时: {:?}", start.elapsed());
}

// 桶排序（浮点数）
fn example_bucket_sort() {
    let mut arr = vec![0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51];
    bucket_sort_unit_f64(&mut arr);
    println!("桶排序结果: {:?}", arr);
}
```

---

### 3.2 搜索算法

| 算法 | 接口 | 时间复杂度 | 适用场景 |
|------|------|-----------|---------|
| **线性搜索** | `linear_search_sync/async` | O(n) | 无序数组 |
| **二分搜索** | `binary_search_sync/async` | O(log n) | 有序数组 |
| **指数搜索** | `exponential_search_sync/async` | O(log n) | 有序数组，位置未知 |
| **三分搜索** | `ternary_search_max/async` | O(log n) | 单峰函数 |
| **插值搜索** | `interpolation_search_sync/async` | O(log log n) | 均匀分布数据 |
| **跳跃搜索** | `jump_search_sync/async` | O(√n) | 有序数组，顺序访问 |

#### 3.2.1 代码示例

```rust
use c08_algorithms::searching::*;

// 二分搜索
fn example_binary_search() {
    let arr = vec![1, 3, 5, 7, 9, 11, 13];
    let target = 7;

    match binary_search_sync(&arr, target) {
        Some(index) => println!("找到 {} 在索引 {}", target, index),
        None => println!("未找到 {}", target),
    }
}

// 三分搜索：找到单峰函数的最大值
async fn example_ternary_search() {
    // f(x) = -(x-5)^2 + 25，最大值在 x=5
    let f = |x: f64| -(x - 5.0).powi(2) + 25.0;

    let (max_x, max_val) = ternary_search_max_async(f, 0.0, 10.0, 1e-6).await;
    println!("最大值点: x = {:.2}, f(x) = {:.2}", max_x, max_val);
}
```

---

### 3.3 图论算法

#### 最短路径

| 算法 | 接口 | 时间复杂度 | 适用场景 |
|------|------|-----------|---------|
| **Dijkstra** | `dijkstra_sync/async` | O((V+E) log V) | 非负权重 |
| **Bellman-Ford** | `bellman_ford_sync/async` | O(VE) | 负权重，检测负环 |
| **Floyd-Warshall** | `floyd_warshall_sync/async` | O(V³) | 全源最短路径 |
| **BFS 最短路** | `bfs_shortest_path_sync/parallel/async` | O(V+E) | 无权图 |

#### 最小生成树

| 算法 | 接口 | 时间复杂度 |
|------|------|-----------|
| **Kruskal** | `mst_kruskal_sync/parallel/async` | O(E log V) |
| **Prim** | `mst_prim_sync/parallel/async` | O((V+E) log V) |

#### 拓扑排序与连通性

| 算法 | 接口 | 时间复杂度 |
|------|------|-----------|
| **拓扑排序** | `topo_sort_sync/parallel/async` | O(V+E) |
| **Tarjan 强连通分量** | `tarjan_scc_sync/async` | O(V+E) |

#### 网络流

| 算法 | 接口 | 时间复杂度 |
|------|------|-----------|
| **Dinic 最大流** | `max_flow_dinic_sync/async` | O(V²E) |
| **Edmonds-Karp 最大流** | `max_flow_edmonds_karp/async` | O(VE²) |
| **最小割** | `min_cut_from_residual` | O(V²E) |

#### 其他

| 算法 | 接口 | 时间复杂度 | 功能 |
|------|------|-----------|------|
| **Hopcroft-Karp** | `hopcroft_karp_sync/async` | O(E√V) | 二分图最大匹配 |
| **LCA (二叉提升)** | `LcaBinaryLift::new/lca` | O(log n) 查询 | 最近公共祖先 |
| **树直径** | `tree_diameter_undirected` | O(V) | 无向树最长路径 |

#### 代码示例1

```rust
use c08_algorithms::graph::*;

// Dijkstra 最短路径
fn example_dijkstra() {
    let graph = vec![
        vec![(1, 4), (2, 1)],
        vec![(2, 2), (3, 5)],
        vec![(3, 1)],
        vec![],
    ];

    let distances = dijkstra_sync(&graph, 0);
    println!("最短距离: {:?}", distances);
}

// Dinic 最大流
async fn example_max_flow() {
    let n = 6; // 6个节点
    let edges = vec![
        (0, 1, 16), (0, 2, 13),
        (1, 2, 10), (1, 3, 12),
        (2, 1, 4), (2, 4, 14),
        (3, 2, 9), (3, 5, 20),
        (4, 3, 7), (4, 5, 4),
    ];

    let max_flow = max_flow_dinic_async(n, &edges, 0, 5).await;
    println!("最大流: {}", max_flow); // 23
}

// Tarjan 强连通分量
fn example_tarjan_scc() {
    let graph = vec![
        vec![1],        // 0 -> 1
        vec![2],        // 1 -> 2
        vec![0, 3],     // 2 -> 0, 3
        vec![4],        // 3 -> 4
        vec![3],        // 4 -> 3
    ];

    let sccs = tarjan_scc_sync(&graph);
    println!("强连通分量: {:?}", sccs); // [[3, 4], [0, 1, 2]]
}
```

---

### 3.4 字符串算法

| 算法 | 接口 | 时间复杂度 | 功能 |
|------|------|-----------|------|
| **KMP** | `kmp_search/async` | O(n+m) | 模式匹配 |
| **Rabin-Karp** | `rabin_karp_search/async` | O(n+m) | 多模式匹配 |
| **Aho-Corasick** | `build_trie` + `ac_search/async` | O(n+m+z) | 多模式匹配 |
| **Z-Algorithm** | `z_algorithm` / `z_search/async` | O(n) | 模式匹配 |
| **Boyer-Moore-Horspool** | `bmh_search/async` | O(n/m) 平均 | 实用快速匹配 |
| **Manacher** | `manacher_longest_palindrome/async` | O(n) | 最长回文子串 |
| **Suffix Array** | `suffix_array` | O(n log n) | 后缀数组 |
| **LCP (Kasai)** | `lcp_kasai` | O(n) | 最长公共前缀 |
| **Suffix Automaton** | `SuffixAutomaton` | O(n) | 不同子串计数 |

#### 代码示例2

```rust
use c08_algorithms::string_algorithms::*;

// KMP 模式匹配
async fn example_kmp() {
    let text = b"ABABDABACDABABCABAB";
    let pattern = b"ABABCABAB";

    let positions = kmp_search_async(text, pattern).await;
    println!("找到模式在位置: {:?}", positions); // [10]
}

// Aho-Corasick 多模式匹配
fn example_aho_corasick() {
    let patterns = vec![b"he".to_vec(), b"she".to_vec(), b"his".to_vec(), b"hers".to_vec()];
    let trie = build_trie(&patterns);

    let text = b"ushers";
    let matches = trie.ac_search(text);

    for (pos, pattern_id) in matches {
        println!("在位置 {} 找到模式 {}", pos, pattern_id);
    }
}

// Manacher 最长回文子串
async fn example_manacher() {
    let text = b"babad";
    let (start, length) = manacher_longest_palindrome_async(text).await;

    let palindrome = &text[start..start+length];
    println!("最长回文: {}", String::from_utf8_lossy(palindrome)); // "bab" 或 "aba"
}

// Suffix Automaton: 不同子串计数
fn example_suffix_automaton() {
    let text = b"abcbc";
    let sa = SuffixAutomaton::from_bytes(text);

    let count = sa.count_distinct_substrings();
    println!("不同子串数量: {}", count); // 12
}
```

---

### 3.5 数值算法

| 算法 | 接口 | 时间复杂度 | 功能 |
|------|------|-----------|------|
| **快速幂** | `fast_pow_mod/async` | O(log n) | 模幂运算 |
| **扩展欧几里得** | `egcd` | O(log n) | 求GCD和系数 |
| **模逆** | `mod_inv` | O(log n) | 模逆元 |
| **Miller-Rabin** | `is_prime` | O(k log n) | 素性测试 |
| **Pollard Rho** | `pollard_rho` | O(n^1/4) | 大数分解 |

#### 代码示例3

```rust
use c08_algorithms::number_theory::*;

// 扩展欧几里得算法
fn example_egcd() {
    let (gcd, x, y) = egcd(240, 46);
    println!("gcd(240, 46) = {}", gcd); // 2
    println!("240*{} + 46*{} = {}", x, y, gcd); // 240*(-9) + 46*(47) = 2
}

// 模逆元
fn example_mod_inv() {
    let a = 3;
    let m = 11;

    match mod_inv(a, m) {
        Some(inv) => {
            println!("{} * {} ≡ 1 (mod {})", a, inv, m); // 3 * 4 ≡ 1 (mod 11)
        },
        None => println!("{} 在模 {} 下无逆元", a, m),
    }
}

// Miller-Rabin 素性测试
fn example_is_prime() {
    let candidates = vec![2, 17, 221, 561, 1000000007];

    for &n in &candidates {
        if is_prime(n, 20) {
            println!("{} 是素数", n);
        } else {
            println!("{} 是合数", n);
        }
    }
}

// Pollard Rho 大数分解
fn example_pollard_rho() {
    let n = 8051; // = 83 * 97

    if let Some(factor) = pollard_rho(n) {
        println!("{} 的一个因子: {}", n, factor); // 83 或 97
        println!("另一个因子: {}", n / factor);
    }
}
```

---

## 4. 按执行模型分类

### 4.1 同步算法

**特点**: 单线程执行，适合 CPU 密集型计算。

**命名约定**: `*_sync`

**使用场景**:

- 数据规模小（< 10,000）
- CPU 密集型计算
- 无并发需求

### 4.2 并行算法

**特点**: 利用多核 CPU，使用 `rayon` 进行数据并行。

**命名约定**: `*_parallel`

**使用场景**:

- 数据规模大（> 100,000）
- 可分解的独立任务
- CPU 密集型计算

#### 代码示例4

```rust
use c08_algorithms::sorting::*;

async fn compare_sync_vs_parallel() {
    let size = 10_000_000;
    let mut arr1: Vec<i32> = (0..size).rev().collect();
    let mut arr2 = arr1.clone();

    // 同步版本
    let start = std::time::Instant::now();
    sort_sync(&mut arr1);
    let sync_time = start.elapsed();

    // 并行版本
    let start = std::time::Instant::now();
    sort_parallel(&mut arr2).await;
    let parallel_time = start.elapsed();

    println!("同步耗时: {:?}", sync_time);
    println!("并行耗时: {:?}", parallel_time);
    println!("加速比: {:.2}x", sync_time.as_secs_f64() / parallel_time.as_secs_f64());
}
```

### 4.3 异步算法

**特点**: 使用 Tokio 运行时，适合 I/O 密集型或需要并发的场景。

**命名约定**: `*_async`

**使用场景**:

- I/O 密集型操作
- 需要超时控制
- 异步生态集成

#### 代码示例5

```rust
use c08_algorithms::graph::*;
use tokio::time::{timeout, Duration};

async fn async_with_timeout() {
    let graph = build_large_graph();

    // 带超时的异步计算
    match timeout(Duration::from_secs(5), dijkstra_async(&graph, 0)).await {
        Ok(result) => println!("计算完成: {:?}", result),
        Err(_) => println!("计算超时"),
    }
}
```

---

## 5. 数据结构分类

| 数据结构 | 接口 | 操作复杂度 | 功能 |
|---------|------|-----------|------|
| **Fenwick Tree (树状数组)** | `Fenwick::new/add/sum_prefix/range_sum` | O(log n) | 前缀和、区间和 |
| **Segment Tree (线段树)** | `SegmentTree::from_slice/update_point/query_sum` | O(log n) | 区间查询、单点更新 |
| **Disjoint Set (并查集)** | `DisjointSet::new/find/union` | O(α(n)) | 连通性查询、合并 |
| **Priority Queue (优先队列)** | `PriorityQueue` | O(log n) | 堆排序、优先级调度 |
| **Sparse Table (稀疏表)** | `SparseTable::build/query_idempotent` | O(1) 查询 | RMQ、LCA |
| **LRU Cache** | `LruCache` | O(1) | 缓存淘汰 |

### 5.1 代码示例

```rust
use c08_algorithms::data_structure::*;

// Fenwick Tree: 区间和查询
fn example_fenwick() {
    let mut fenwick = Fenwick::new(10);

    fenwick.add(0, 3);
    fenwick.add(1, 2);
    fenwick.add(2, -1);
    fenwick.add(3, 6);

    println!("前缀和 [0, 3): {}", fenwick.sum_prefix(3)); // 4
    println!("区间和 [1, 4): {}", fenwick.range_sum(1, 4)); // 7
}

// Segment Tree: 区间查询
fn example_segment_tree() {
    let arr = vec![1, 3, 5, 7, 9, 11];
    let mut seg_tree = SegmentTree::from_slice(&arr, 0);

    println!("区间和 [1, 4): {}", seg_tree.query_sum(1, 4)); // 15

    seg_tree.update_point(2, 10); // arr[2] = 5 -> 10
    println!("更新后区间和 [1, 4): {}", seg_tree.query_sum(1, 4)); // 20
}

// Disjoint Set: 连通性
fn example_dsu() {
    let mut dsu = DisjointSet::new(5);

    dsu.union(0, 1);
    dsu.union(1, 2);
    dsu.union(3, 4);

    println!("0 和 2 连通: {}", dsu.find(0) == dsu.find(2)); // true
    println!("0 和 3 连通: {}", dsu.find(0) == dsu.find(3)); // false
}

// Sparse Table: RMQ (区间最小值查询)
fn example_sparse_table() {
    let arr = vec![3, 1, 4, 1, 5, 9, 2, 6];
    let st = SparseTable::build(&arr, |a, b| *a.min(b));

    println!("区间 [2, 6) 最小值: {}", st.query_idempotent(2, 6)); // 1
}
```

---

## 6. 算法复杂度快速查询

### 排序算法

| 算法 | 最好 | 平均 | 最坏 | 空间 | 稳定性 |
|------|------|------|------|------|--------|
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ |
| 桶排序 | O(n+k) | O(n+k) | O(n²) | O(n+k) | ✅ |

### 图算法

| 算法 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| BFS/DFS | O(V+E) | O(V) |
| Dijkstra | O((V+E) log V) | O(V) |
| Bellman-Ford | O(VE) | O(V) |
| Floyd-Warshall | O(V³) | O(V²) |
| Kruskal MST | O(E log V) | O(V) |
| Prim MST | O((V+E) log V) | O(V) |
| Tarjan SCC | O(V+E) | O(V) |
| Dinic 最大流 | O(V²E) | O(V+E) |

### 字符串算法

| 算法 | 时间复杂度 | 空间复杂度 | 预处理 |
|------|-----------|-----------|--------|
| KMP | O(n+m) | O(m) | O(m) |
| Rabin-Karp | O(n+m) | O(1) | O(m) |
| Aho-Corasick | O(n+m+z) | O(m×Σ) | O(m×Σ) |
| Manacher | O(n) | O(n) | - |
| Suffix Array | O(n log n) | O(n) | O(n log n) |

### 动态规划

| 问题 | 时间复杂度 | 空间复杂度 | 优化空间 |
|------|-----------|-----------|---------|
| LCS | O(mn) | O(mn) | O(min(m,n)) |
| 0-1背包 | O(nW) | O(nW) | O(W) |
| LIS | O(n log n) | O(n) | - |
| 编辑距离 | O(mn) | O(mn) | O(min(m,n)) |
| 矩阵链乘 | O(n³) | O(n²) | - |

---

## 📚 相关文档

- **[02_数据结构参考](./02_数据结构参考.md)** - 数据结构详细API
- **[03_Rust190特性参考](./03_Rust190特性参考.md)** - Rust 1.90 新特性应用
- **[04_算法性能参考](./04_算法性能参考.md)** - 性能基准测试数据
- **[05_标准库算法参考](./05_标准库算法参考.md)** - 标准库算法对比

---

## 🎯 使用建议

### 1. 如何选择算法

```rust
// 决策树
fn choose_algorithm(problem: &str, data_size: usize) -> &'static str {
    match problem {
        "排序" => {
            if data_size < 50 {
                "插入排序"
            } else if needs_stability() {
                "归并排序"
            } else {
                "快速排序"
            }
        },
        "搜索" => {
            if is_sorted() {
                "二分搜索"
            } else {
                "线性搜索"
            }
        },
        "最短路径" => {
            if has_negative_weight() {
                "Bellman-Ford"
            } else if single_source() {
                "Dijkstra"
            } else {
                "Floyd-Warshall"
            }
        },
        _ => "查阅文档",
    }
}
```

### 2. 性能优化技巧

```rust
// 技巧1: 小数据集使用同步版本
if data.len() < 10_000 {
    sort_sync(&mut data);
} else {
    sort_parallel(&mut data).await;
}

// 技巧2: 使用 Rayon 并行迭代器
use rayon::prelude::*;
let results: Vec<_> = data.par_iter()
    .map(|x| expensive_computation(x))
    .collect();

// 技巧3: 预分配空间
let mut result = Vec::with_capacity(expected_size);
```

### 3. 常见陷阱

```rust
// ❌ 错误：重复计算
fn fibonacci_naive(n: u64) -> u64 {
    if n <= 1 { n } else { fibonacci_naive(n-1) + fibonacci_naive(n-2) }
}

// ✅ 正确：动态规划
fn fibonacci_dp(n: usize) -> u64 {
    if n <= 1 { return n as u64; }

    let mut dp = vec![0; n+1];
    dp[1] = 1;

    for i in 2..=n {
        dp[i] = dp[i-1] + dp[i-2];
    }

    dp[n]
}
```

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-23
**质量评分**: ⭐⭐⭐⭐⭐
