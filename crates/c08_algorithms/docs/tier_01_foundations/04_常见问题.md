# Tier 1: C08 算法与数据结构 - 常见问题

> **文档类型**: FAQ  
> **适用版本**: Rust 1.90+ / Edition 2024  
> **最后更新**: 2025-10-22

---

## 📋 目录

- [Tier 1: C08 算法与数据结构 - 常见问题](#tier-1-c08-算法与数据结构---常见问题)
  - [📋 目录](#-目录)
  - [📋 问题索引](#-问题索引)
  - [入门问题](#入门问题)
    - [Q1: 如何开始学习算法？](#q1-如何开始学习算法)
    - [Q2: 需要什么Rust基础？](#q2-需要什么rust基础)
  - [算法选择](#算法选择)
    - [Q3: 如何选择合适的排序算法？](#q3-如何选择合适的排序算法)
    - [Q4: 什么时候用BFS，什么时候用DFS？](#q4-什么时候用bfs什么时候用dfs)
  - [性能优化](#性能优化)
    - [Q5: 如何优化算法性能？](#q5-如何优化算法性能)
    - [Q6: 如何进行性能基准测试？](#q6-如何进行性能基准测试)
  - [Rust特性](#rust特性)
    - [Q7: Rust中如何实现异步算法？](#q7-rust中如何实现异步算法)
    - [Q8: 如何处理所有权和借用问题？](#q8-如何处理所有权和借用问题)
  - [数据结构](#数据结构)
    - [Q9: 如何选择合适的数据结构？](#q9-如何选择合适的数据结构)
  - [学习资源](#学习资源)
    - [Q10: 有哪些推荐的学习资源？](#q10-有哪些推荐的学习资源)
  - [📚 更多问题](#-更多问题)

## 📋 问题索引

**快速跳转**: [入门](#入门问题) | [算法选择](#算法选择) | [性能优化](#性能优化) | [Rust特性](#rust特性)

---

## 入门问题

### Q1: 如何开始学习算法？

**A**: 建议按以下顺序学习：

**第1阶段: 基础算法 (2周)**:

```text
1. 排序算法 (冒泡、选择、插入、快排、归并)
2. 搜索算法 (线性、二分)
3. 时间复杂度分析
```

**第2阶段: 数据结构 (2周)**:

```text
1. 线性结构 (数组、链表、栈、队列)
2. 树结构 (二叉树、BST)
3. 图基础 (BFS、DFS)
```

**第3阶段: 进阶算法 (2周)**:

```text
1. 动态规划入门
2. 贪心算法
3. 回溯算法
```

**实践建议**:

- ✅ 每天写代码 (1-2小时)
- ✅ 做LeetCode简单题 (每天3-5题)
- ✅ 理解原理，不只背代码

---

### Q2: 需要什么Rust基础？

**A**: 建议掌握以下知识：

**必备基础**:

```rust
// 1. 基础语法
let mut v = vec![1, 2, 3];
for x in &v { println!("{}", x); }

// 2. 所有权和借用
fn process(v: &Vec<i32>) -> i32 {
    v.iter().sum()
}

// 3. 泛型
fn max<T: Ord>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// 4. Trait
trait Sortable {
    fn sort(&mut self);
}
```

**推荐学习**:

- 《Rust程序设计语言》前10章
- 理解所有权、借用、生命周期
- 掌握Vec、HashMap等集合

---

## 算法选择

### Q3: 如何选择合适的排序算法？

**A**: 根据场景选择：

| 场景 | 推荐算法 | 原因 |
|------|---------|------|
| **通用排序** | 快速排序 | 平均O(n log n)，原地 |
| **需要稳定性** | 归并排序 | 稳定，O(n log n) |
| **小规模数据** | 插入排序 | 简单，n<20时快 |
| **几乎有序** | 插入排序 | 接近O(n) |
| **空间受限** | 堆排序 | O(1)空间 |
| **整数范围小** | 计数排序 | O(n+k)线性时间 |

**Rust标准库**:

```rust
let mut v = vec![3, 1, 4, 1, 5];

// 不稳定排序 (通常更快)
v.sort_unstable();

// 稳定排序
v.sort();

// 自定义排序
v.sort_by(|a, b| a.cmp(b));
```

---

### Q4: 什么时候用BFS，什么时候用DFS？

**A**: 根据问题特点选择：

**使用BFS**:

- ✅ 求最短路径
- ✅ 层序遍历
- ✅ 求最小步数

```rust
use std::collections::VecDeque;

fn bfs(start: i32, graph: &HashMap<i32, Vec<i32>>) {
    let mut queue = VecDeque::new();
    let mut visited = HashSet::new();
    
    queue.push_back(start);
    visited.insert(start);
    
    while let Some(node) = queue.pop_front() {
        // 处理节点
        for &neighbor in &graph[&node] {
            if !visited.contains(&neighbor) {
                visited.insert(neighbor);
                queue.push_back(neighbor);
            }
        }
    }
}
```

**使用DFS**:

- ✅ 遍历所有路径
- ✅ 拓扑排序
- ✅ 检测环

```rust
fn dfs(node: i32, graph: &HashMap<i32, Vec<i32>>, visited: &mut HashSet<i32>) {
    visited.insert(node);
    
    if let Some(neighbors) = graph.get(&node) {
        for &neighbor in neighbors {
            if !visited.contains(&neighbor) {
                dfs(neighbor, graph, visited);
            }
        }
    }
}
```

---

## 性能优化

### Q5: 如何优化算法性能？

**A**: 采用多层次优化策略：

**1. 算法层面**:

```rust
// ❌ O(n²) - 低效
fn has_duplicate_slow(arr: &[i32]) -> bool {
    for i in 0..arr.len() {
        for j in (i+1)..arr.len() {
            if arr[i] == arr[j] { return true; }
        }
    }
    false
}

// ✅ O(n) - 高效
use std::collections::HashSet;
fn has_duplicate_fast(arr: &[i32]) -> bool {
    let mut seen = HashSet::new();
    arr.iter().any(|&x| !seen.insert(x))
}
```

**2. 数据结构选择**:

```rust
// ❌ Vec查找 O(n)
let v = vec![1, 2, 3, 4, 5];
v.contains(&3);

// ✅ HashSet查找 O(1)
let set: HashSet<_> = v.into_iter().collect();
set.contains(&3);
```

**3. 并行化**:

```rust
use rayon::prelude::*;

// 串行
let sum: i32 = v.iter().sum();

// 并行
let sum: i32 = v.par_iter().sum();
```

---

### Q6: 如何进行性能基准测试？

**A**: 使用Criterion进行基准测试：

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci_bench(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });
}

criterion_group!(benches, fibonacci_bench);
criterion_main!(benches);
```

**运行基准**:

```bash
cargo bench
```

**参考**: [基准测试指南](../guides/benchmarking_guide.md)

---

## Rust特性

### Q7: Rust中如何实现异步算法？

**A**: 使用Tokio异步运行时：

```rust
use tokio;

#[tokio::main]
async fn main() {
    let result = async_sort(vec![3, 1, 4, 1, 5]).await;
    println!("{:?}", result);
}

async fn async_sort<T: Ord + Send + 'static>(
    mut v: Vec<T>
) -> Vec<T> {
    tokio::task::spawn_blocking(move || {
        v.sort();
        v
    }).await.unwrap()
}
```

**适用场景**:

- ✅ I/O密集型操作
- ✅ 并发任务编排
- ❌ CPU密集型算法（考虑Rayon并行）

---

### Q8: 如何处理所有权和借用问题？

**A**: 常用策略：

**1. 使用引用**:

```rust
fn process(arr: &[i32]) -> i32 {
    arr.iter().sum()  // 只读访问
}
```

**2. 可变引用**:

```rust
fn sort(arr: &mut [i32]) {
    arr.sort();  // 修改原数据
}
```

**3. 转移所有权**:

```rust
fn consume(arr: Vec<i32>) -> Vec<i32> {
    // 获取所有权，可自由修改
    arr.into_iter().map(|x| x * 2).collect()
}
```

**4. 克隆数据**:

```rust
fn clone_and_process(arr: &[i32]) -> Vec<i32> {
    let mut v = arr.to_vec();  // 克隆
    v.sort();
    v
}
```

---

## 数据结构

### Q9: 如何选择合适的数据结构？

**A**: 根据操作特点选择：

| 需求 | 推荐结构 | 时间复杂度 |
|------|---------|-----------|
| **快速访问** | Vec | O(1) |
| **快速查找** | HashSet/HashMap | O(1)平均 |
| **有序数据** | BTreeSet/BTreeMap | O(log n) |
| **优先级** | BinaryHeap | O(log n) |
| **FIFO队列** | VecDeque | O(1) |
| **LIFO栈** | Vec | O(1) |

**示例**:

```rust
use std::collections::{HashMap, HashSet, BinaryHeap, VecDeque};

// 计数
let mut count: HashMap<char, usize> = HashMap::new();

// 去重
let unique: HashSet<_> = vec![1, 2, 2, 3].into_iter().collect();

// 优先队列
let mut pq = BinaryHeap::new();
pq.push(3); pq.push(1); pq.push(4);

// 队列
let mut queue = VecDeque::new();
queue.push_back(1);
```

---

## 学习资源

### Q10: 有哪些推荐的学习资源？

**A**:

**书籍**:

- 《算法导论》(CLRS) - 理论基础
- 《算法》(第4版) - 实用算法
- 《Rust程序设计语言》- Rust基础

**在线资源**:

- [LeetCode](https://leetcode.com/) - 算法练习
- [Rust Algorithm Club](https://github.com/TheAlgorithms/Rust)
- [本模块文档](../README.md)

**实践项目**:

1. 实现常用数据结构
2. 完成LeetCode前100题
3. 参与开源项目

---

## 📚 更多问题

**完整FAQ**: 详见 [完整FAQ](../FAQ.md) (20+问题)

---

**返回**: [术语表](./03_术语表.md) | **下一步**: [Tier 2 实践指南](../tier_02_guides/)

---

**文档维护**: Documentation Team  
**创建日期**: 2025-10-22  
**适用版本**: Rust 1.90+
