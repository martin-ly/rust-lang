# Tier 1: C08 算法与数据结构 - 术语表

> **文档类型**: 术语参考
> **适用版本**: Rust 1.92.0+ / Edition 2024
> **最后更新**: 2025-12-11

---

## 📋 目录

- [Tier 1: C08 算法与数据结构 - 术语表](#tier-1-c08-算法与数据结构---术语表)
  - [📋 目录](#-目录)
  - [📋 术语索引](#-术语索引)
  - [核心术语](#核心术语)
    - [算法 (Algorithm)](#算法-algorithm)
  - [复杂度 (Complexity)](#复杂度-complexity)
    - [时间复杂度 (Time Complexity)](#时间复杂度-time-complexity)
    - [空间复杂度 (Space Complexity)](#空间复杂度-space-complexity)
  - [数据结构 (Data Structure)](#数据结构-data-structure)
    - [线性结构](#线性结构)
    - [树结构](#树结构)
    - [图结构](#图结构)
  - [算法策略 (Algorithm Strategy)](#算法策略-algorithm-strategy)
    - [分治法 (Divide and Conquer)](#分治法-divide-and-conquer)
    - [动态规划 (Dynamic Programming)](#动态规划-dynamic-programming)
    - [贪心算法 (Greedy Algorithm)](#贪心算法-greedy-algorithm)
    - [回溯法 (Backtracking)](#回溯法-backtracking)
  - [性能术语](#性能术语)
    - [稳定性 (Stability)](#稳定性-stability)
    - [原地算法 (In-Place Algorithm)](#原地算法-in-place-algorithm)
  - [Rust特定术语](#rust特定术语)
    - [迭代器 (Iterator)](#迭代器-iterator)
    - [所有权 (Ownership)](#所有权-ownership)
    - [并行 (Parallel)](#并行-parallel)
    - [异步 (Async)](#异步-async)
  - [📚 完整术语表](#-完整术语表)

## 📋 术语索引

**快速跳转**: [算法](#算法-algorithm) | [复杂度](#复杂度-complexity) | [数据结构](#数据结构-data-structure) | [算法策略](#算法策略-algorithm-strategy)

---

## 核心术语

### 算法 (Algorithm)

**定义**: 解决特定问题的一系列明确指令或步骤。

**特征**:

- ✅ 输入: 零个或多个输入
- ✅ 输出: 至少一个输出
- ✅ 明确性: 每步清晰无歧义
- ✅ 有限性: 有限步骤内终止
- ✅ 有效性: 每步可执行

**Rust示例**:

```rust
// 欧几里得算法求最大公约数
fn gcd(mut a: u64, mut b: u64) -> u64 {
    while b != 0 {
        (a, b) = (b, a % b);
    }
    a
}
```

---

## 复杂度 (Complexity)

### 时间复杂度 (Time Complexity)

**定义**: 算法执行所需的计算次数随输入规模增长的趋势。

**常见复杂度**:

| 复杂度 | 名称 | 示例 |
|--------|------|------|
| O(1) | 常数时间 | 数组访问 |
| O(log n) | 对数时间 | 二分搜索 |
| O(n) | 线性时间 | 遍历数组 |
| O(n log n) | 线性对数 | 归并排序 |
| O(n²) | 平方时间 | 冒泡排序 |
| O(2ⁿ) | 指数时间 | 斐波那契递归 |

### 空间复杂度 (Space Complexity)

**定义**: 算法执行所需的额外内存空间随输入规模增长的趋势。

---

## 数据结构 (Data Structure)

### 线性结构

**数组 (Array)**:

- 固定大小的连续内存块
- O(1) 访问，O(n) 插入/删除

**链表 (Linked List)**:

- 动态大小的节点链接
- O(n) 访问，O(1) 头部操作

**栈 (Stack)**:

- LIFO (后进先出)
- 用途: 函数调用栈、表达式求值

**队列 (Queue)**:

- FIFO (先进先出)
- 用途: BFS、任务调度

### 树结构

**二叉树 (Binary Tree)**:

- 每个节点最多两个子节点
- 用途: 表达式树、决策树

**二叉搜索树 (BST)**:

- 左子树 < 根节点 < 右子树
- 平均 O(log n) 操作

**堆 (Heap)**:

- 完全二叉树
- 用途: 优先队列、堆排序

### 图结构

**图 (Graph)**:

- 顶点 (Vertex) 和边 (Edge)
- 表示: 邻接表、邻接矩阵

---

## 算法策略 (Algorithm Strategy)

### 分治法 (Divide and Conquer)

**定义**: 将问题分解为子问题，递归解决，合并结果。

**示例**: 归并排序、快速排序

```rust
fn merge_sort<T: Ord + Clone>(arr: &mut [T]) {
    if arr.len() <= 1 { return; }

    let mid = arr.len() / 2;
    merge_sort(&mut arr[..mid]);
    merge_sort(&mut arr[mid..]);
    // ... 合并
}
```

### 动态规划 (Dynamic Programming)

**定义**: 将问题分解为子问题，存储子问题结果避免重复计算。

**示例**: 斐波那契、背包问题

```rust
fn fib_dp(n: usize) -> u64 {
    let mut dp = vec![0; n + 1];
    dp[1] = 1;
    for i in 2..=n {
        dp[i] = dp[i-1] + dp[i-2];
    }
    dp[n]
}
```

### 贪心算法 (Greedy Algorithm)

**定义**: 每步选择当前最优解。

**示例**: 活动选择、霍夫曼编码

### 回溯法 (Backtracking)

**定义**: 试探所有可能解，回溯不可行路径。

**示例**: N皇后、全排列

---

## 性能术语

### 稳定性 (Stability)

**定义**: 相等元素的相对顺序是否保持不变。

**稳定排序**: 归并排序、插入排序
**不稳定排序**: 快速排序、堆排序

### 原地算法 (In-Place Algorithm)

**定义**: 只使用常数额外空间的算法。

**示例**: 快速排序 (O(log n) 栈空间)

---

## Rust特定术语

### 迭代器 (Iterator)

```rust
let sum: i32 = vec![1, 2, 3]
    .iter()
    .map(|x| x * 2)
    .sum();
```

### 所有权 (Ownership)

算法实现需考虑所有权转移和借用。

### 并行 (Parallel)

```rust
use rayon::prelude::*;

let sum: i32 = vec.par_iter().sum();
```

### 异步 (Async)

```rust
async fn sort_async<T: Ord>(mut v: Vec<T>) -> Vec<T> {
    tokio::task::spawn_blocking(move || {
        v.sort();
        v
    }).await.unwrap()
}
```

---

## 📚 完整术语表

**更多术语**: 详见 [完整术语表](../Glossary.md) (100+术语)

---

**返回**: [主索引](./02_主索引导航.md) | **下一步**: [常见问题](./04_常见问题.md)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-22
**适用版本**: Rust 1.92.0+
