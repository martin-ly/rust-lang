# 🗺️ Rust 1.90 算法与数据结构 - 综合思维导图

> **版本**: Rust 1.90 Edition 2024
> **创建日期**: 2025-10-20
> **适用人群**: 初级到高级开发者

---

## 📋 目录

- [🗺️ Rust 1.90 算法与数据结构 - 综合思维导图](#️-rust-190-算法与数据结构---综合思维导图)
  - [� 目录](#-目录)
  - [🌳 整体架构](#-整体架构)
  - [📊 数据结构体系](#-数据结构体系)
  - [🔍 算法分类](#-算法分类)
  - [⚡ 并发算法](#-并发算法)
  - [📚 学习路径](#-学习路径)
    - [🌱 初学者路径 (2-3周)](#-初学者路径-2-3周)
    - [⚡ 进阶路径 (3-4周)](#-进阶路径-3-4周)
    - [🎓 专家路径 (4-6周)](#-专家路径-4-6周)
  - [🔍 问题诊断树](#-问题诊断树)
  - [⚖️ 算法选择决策树](#️-算法选择决策树)

---

## 🌳 整体架构

```text
        Rust 算法与数据结构体系
                   │
        ┌──────────┼──────────┐
        │          │          │
    数据结构    算法设计   并发算法
        │          │          │
    ┌───┴───┐  ┌───┴───┐  ┌───┴───┐
    │       │  │       │  │       │
  线性   非线性 排序  搜索 并行  异步
  Array  Tree  Sort  BFS  Rayon  Stream
   Vec   Graph Quick DFS  par_iter async
    │       │      │    │       │      │
  Stack  Heap  Merge Dijkstra  join  select

       ┌──────────────────────────┐
       │   Rust特性优势           │
       │                          │
       │ • 零成本抽象             │
       │ • 所有权保证正确性       │
       │ • 泛型无运行时开销       │
       │ • 并发安全               │
       └──────────────────────────┘
```

---

## 📊 数据结构体系

```text
数据结构分类
│
├─ 📐 线性数据结构
│  ├─ 数组 (Array/Vec)
│  │  ├─ 固定大小: [T; N]
│  │  ├─ 动态大小: Vec<T>
│  │  ├─ 特点
│  │  │  ├─ O(1)随机访问
│  │  │  ├─ 连续内存
│  │  │  └─ 缓存友好
│  │  └─ 操作
│  │     ├─ push/pop: O(1)*
│  │     ├─ insert/remove: O(n)
│  │     └─ sort: O(n log n)
│  │
│  ├─ 链表 (LinkedList)
│  │  ├─ std::collections::LinkedList
│  │  ├─ 双向链表
│  │  ├─ 特点
│  │  │  ├─ O(1)头尾插入删除
│  │  │  ├─ O(n)随机访问
│  │  │  └─ 非连续内存
│  │  └─ 适用场景
│  │     ├─ 频繁插入删除
│  │     └─ 队列实现
│  │
│  ├─ 栈 (Stack)
│  │  ├─ Vec<T>实现
│  │  ├─ LIFO (后进先出)
│  │  ├─ push/pop: O(1)
│  │  └─ 应用
│  │     ├─ 函数调用栈
│  │     ├─ 表达式求值
│  │     └─ 括号匹配
│  │
│  └─ 队列 (Queue)
│     ├─ VecDeque<T>
│     ├─ FIFO (先进先出)
│     ├─ push_back/pop_front: O(1)
│     └─ 应用
│        ├─ BFS
│        ├─ 任务调度
│        └─ 缓冲区
│
├─ 🌲 树形数据结构
│  ├─ 二叉树 (Binary Tree)
│  │  ├─ 结构
│  │  │  └─ struct Node { val, left, right }
│  │  ├─ 遍历
│  │  │  ├─ 前序: root → left → right
│  │  │  ├─ 中序: left → root → right
│  │  │  └─ 后序: left → right → root
│  │  └─ 特例
│  │     ├─ 完全二叉树
│  │     ├─ 满二叉树
│  │     └─ 平衡二叉树
│  │
│  ├─ 二叉搜索树 (BST)
│  │  ├─ 性质: left < root < right
│  │  ├─ 操作: O(h) (h=高度)
│  │  │  ├─ search
│  │  │  ├─ insert
│  │  │  └─ delete
│  │  └─ 平衡版本
│  │     ├─ AVL树: 严格平衡
│  │     └─ 红黑树: 宽松平衡
│  │
│  ├─ 堆 (Heap)
│  │  ├─ BinaryHeap<T> (std)
│  │  ├─ 完全二叉树
│  │  ├─ 最大堆/最小堆
│  │  ├─ 操作
│  │  │  ├─ push: O(log n)
│  │  │  ├─ pop: O(log n)
│  │  │  └─ peek: O(1)
│  │  └─ 应用
│  │     ├─ 优先队列
│  │     ├─ 堆排序
│  │     └─ Top-K问题
│  │
│  └─ Trie (前缀树)
│     ├─ 字符串专用
│     ├─ 前缀搜索: O(m) (m=字符串长度)
│     └─ 应用
│        ├─ 自动补全
│        └─ 字典查找
│
├─ 🕸️ 图形数据结构
│  ├─ 图表示
│  │  ├─ 邻接矩阵
│  │  │  ├─ Vec<Vec<bool>>
│  │  │  ├─ 空间: O(V²)
│  │  │  └─ 边查询: O(1)
│  │  │
│  │  └─ 邻接表
│  │     ├─ HashMap<Node, Vec<Node>>
│  │     ├─ 空间: O(V + E)
│  │     └─ 边查询: O(degree)
│  │
│  ├─ 图类型
│  │  ├─ 有向图/无向图
│  │  ├─ 加权图/无权图
│  │  └─ 连通图/非连通图
│  │
│  └─ 特殊图
│     ├─ DAG (有向无环图)
│     └─ 树 (特殊图)
│
└─ 🗂️ 哈希数据结构
   ├─ HashMap<K, V>
   │  ├─ 插入/查询/删除: O(1)*
   │  ├─ SipHash (默认)
   │  └─ 无序
   │
   ├─ HashSet<T>
   │  ├─ 基于HashMap
   │  └─ 去重、存在性检查
   │
   ├─ BTreeMap<K, V>
   │  ├─ 有序
   │  ├─ O(log n)操作
   │  └─ 范围查询
   │
   └─ BTreeSet<T>
      └─ 基于BTreeMap
```

---

## 🔍 算法分类

```text
算法体系
│
├─ 🔄 排序算法
│  ├─ 比较排序
│  │  ├─ 快速排序 (QuickSort)
│  │  │  ├─ 平均: O(n log n)
│  │  │  ├─ 最坏: O(n²)
│  │  │  ├─ 不稳定
│  │  │  └─ slice.sort_unstable()
│  │  │
│  │  ├─ 归并排序 (MergeSort)
│  │  │  ├─ 时间: O(n log n)
│  │  │  ├─ 空间: O(n)
│  │  │  ├─ 稳定
│  │  │  └─ slice.sort() (timsort变体)
│  │  │
│  │  ├─ 堆排序 (HeapSort)
│  │  │  ├─ 时间: O(n log n)
│  │  │  ├─ 空间: O(1)
│  │  │  └─ 不稳定
│  │  │
│  │  └─ 插入排序 (InsertionSort)
│  │     ├─ 平均: O(n²)
│  │     ├─ 最好: O(n)
│  │     └─ 稳定、小数据集高效
│  │
│  └─ 非比较排序
│     ├─ 计数排序: O(n + k)
│     ├─ 基数排序: O(d(n + k))
│     └─ 桶排序: O(n + k)
│
├─ 🔎 搜索算法
│  ├─ 线性搜索
│  │  ├─ 顺序查找: O(n)
│  │  └─ 适用无序数据
│  │
│  ├─ 二分搜索
│  │  ├─ slice.binary_search()
│  │  ├─ O(log n)
│  │  └─ 需要有序
│  │
│  ├─ 深度优先搜索 (DFS)
│  │  ├─ 递归/栈实现
│  │  ├─ 时间: O(V + E)
│  │  └─ 应用
│  │     ├─ 连通性
│  │     ├─ 拓扑排序
│  │     └─ 路径查找
│  │
│  └─ 广度优先搜索 (BFS)
│     ├─ 队列实现
│     ├─ 时间: O(V + E)
│     └─ 应用
│        ├─ 最短路径
│        └─ 层次遍历
│
├─ 🗺️ 图算法
│  ├─ 最短路径
│  │  ├─ Dijkstra
│  │  │  ├─ 非负权重
│  │  │  ├─ O((V + E) log V)
│  │  │  └─ 优先队列优化
│  │  │
│  │  ├─ Bellman-Ford
│  │  │  ├─ 支持负权重
│  │  │  └─ O(VE)
│  │  │
│  │  └─ Floyd-Warshall
│  │     ├─ 全源最短路径
│  │     └─ O(V³)
│  │
│  ├─ 最小生成树
│  │  ├─ Prim算法
│  │  │  └─ O(E log V)
│  │  │
│  │  └─ Kruskal算法
│  │     └─ O(E log E)
│  │
│  └─ 拓扑排序
│     ├─ DFS实现
│     ├─ Kahn算法
│     └─ O(V + E)
│
├─ 🎯 动态规划
│  ├─ 特征
│  │  ├─ 最优子结构
│  │  ├─ 重叠子问题
│  │  └─ 状态转移方程
│  │
│  ├─ 经典问题
│  │  ├─ 背包问题
│  │  ├─ 最长公共子序列
│  │  ├─ 最长递增子序列
│  │  └─ 编辑距离
│  │
│  └─ 优化技巧
│     ├─ 记忆化搜索
│     ├─ 滚动数组
│     └─ 状态压缩
│
└─ 🪓 分治算法
   ├─ 策略
   │  ├─ 分解子问题
   │  ├─ 递归求解
   │  └─ 合并结果
   │
   └─ 应用
      ├─ 归并排序
      ├─ 快速排序
      └─ 二分搜索
```

---

## ⚡ 并发算法

```text
并发与并行算法
│
├─ 📦 Rayon 并行迭代器
│  ├─ par_iter()
│  │  ├─ 并行遍历
│  │  ├─ 工作窃取调度
│  │  └─ 自动负载均衡
│  │
│  ├─ 并行操作
│  │  ├─ par_sort()
│  │  │  └─ 并行快速排序
│  │  │
│  │  ├─ par_chunks()
│  │  │  └─ 分块并行处理
│  │  │
│  │  └─ par_fold() / reduce()
│  │     └─ 并行规约
│  │
│  └─ 示例
│     ```rust
│     use rayon::prelude::*;
│     let sum: i32 = data.par_iter().sum();
│     ```
│
├─ 🎯 并行算法模式
│  ├─ Map-Reduce
│  │  ├─ map(): 并行映射
│  │  └─ reduce(): 规约合并
│  │
│  ├─ Fork-Join
│  │  ├─ rayon::join()
│  │  └─ 递归分治
│  │
│  └─ Pipeline
│     └─ 流水线并行
│
├─ 🔄 异步算法
│  ├─ Stream (异步迭代器)
│  │  ├─ tokio_stream::Stream
│  │  ├─ stream.next().await
│  │  └─ 适用I/O密集型
│  │
│  ├─ 并发搜索
│  │  ├─ tokio::select!
│  │  └─ 多路径并发探索
│  │
│  └─ 批量操作
│     ├─ futures::future::join_all
│     └─ 并发执行多个future
│
└─ 🔒 无锁数据结构
   ├─ 原子操作
   │  ├─ AtomicU64
   │  ├─ AtomicBool
   │  └─ compare_exchange
   │
   ├─ crossbeam
   │  ├─ 无锁队列
   │  ├─ 无锁栈
   │  └─ epoch-based回收
   │
   └─ 适用场景
      ├─ 高并发
      ├─ 低延迟
      └─ 避免锁竞争
```

---

## 📚 学习路径

### 🌱 初学者路径 (2-3周)

```text
Week 1: 基础数据结构
│
├─ Day 1-3: 线性结构
│  ├─ Vec/Array
│  ├─ Stack/Queue
│  └─ 实践: 括号匹配、LRU缓存
│
└─ Day 4-7: 哈希表与集合
   ├─ HashMap/HashSet
   ├─ BTreeMap/BTreeSet
   └─ 实践: 词频统计、去重

Week 2: 基础算法
│
├─ Day 1-4: 排序与搜索
│  ├─ QuickSort/MergeSort
│  ├─ BinarySearch
│  └─ 实践: 排序算法实现
│
└─ Day 5-7: 递归与分治
   ├─ 递归基础
   ├─ 分治思想
   └─ 实践: 汉诺塔、归并排序

Week 3: 树与图入门
│
└─ 树的遍历
   ├─ 二叉树前中后序
   ├─ BFS/DFS
   └─ 实践: 路径和、层序遍历
```

### ⚡ 进阶路径 (3-4周)

```text
Week 1: 高级数据结构
│
├─ 堆
├─ Trie
├─ 并查集
└─ 实践: Top-K、字符串匹配

Week 2: 图算法
│
├─ Dijkstra
├─ 拓扑排序
├─ 最小生成树
└─ 实践: 最短路径、任务调度

Week 3-4: 动态规划
│
├─ 背包问题
├─ LCS/LIS
├─ 状态机DP
└─ 实践: 股票买卖、编辑距离
```

### 🎓 专家路径 (4-6周)

```text
Week 1-2: 并发算法
│
├─ Rayon并行迭代
├─ 无锁数据结构
├─ 工作窃取
└─ 并行排序/搜索

Week 3-4: 异步算法
│
├─ Stream处理
├─ 异步图遍历
└─ 并发限流

Week 5-6: 高级主题
│
├─ 算法优化技巧
├─ 缓存优化
├─ SIMD加速
└─ 项目: 高性能算法库
```

---

## 🔍 问题诊断树

```text
遇到算法问题？
│
├─ 性能问题
│  ├─ 时间复杂度过高
│  │  ├─ 检查: 是否有更优算法
│  │  └─ 解决: 优化算法、使用哈希表、二分搜索
│  │
│  ├─ 空间复杂度过高
│  │  └─ 解决: 原地算法、滚动数组、状态压缩
│  │
│  └─ 缓存miss率高
│     └─ 解决: 改善数据局部性、使用Vec代替LinkedList
│
├─ 正确性问题
│  ├─ 边界条件
│  │  └─ 检查: 空数组、单元素、负数
│  │
│  ├─ 溢出
│  │  └─ 解决: 使用checked_add、u128
│  │
│  └─ 浮点精度
│     └─ 解决: 使用有序分数、BigDecimal
│
├─ 并发问题
│  ├─ 数据竞争
│  │  └─ 解决: 使用Arc<Mutex>、原子操作
│  │
│  └─ 死锁
│     └─ 解决: 避免嵌套锁、使用RwLock
│
└─ Rust特定
   ├─ 所有权错误
   │  └─ 解决: 使用引用、clone、Arc
   │
   └─ 生命周期错误
      └─ 解决: 明确生命周期标注
```

---

## ⚖️ 算法选择决策树

```text
选择排序算法？
│
├─ 数据量小(<50) → 插入排序
├─ 需要稳定 → slice.sort()
├─ 不需要稳定 → slice.sort_unstable()
└─ 特定范围 → 计数排序/基数排序

选择搜索算法？
│
├─ 数据无序 → 线性搜索 / HashMap
├─ 数据有序 → 二分搜索
└─ 图/树结构 → DFS/BFS

选择数据结构？
│
├─ 需要快速随机访问 → Vec
├─ 频繁头尾操作 → VecDeque
├─ 频繁中间插入删除 → LinkedList
├─ 需要O(1)查找 → HashMap
├─ 需要有序 → BTreeMap
├─ 优先级队列 → BinaryHeap
└─ 前缀匹配 → Trie

图算法选择？
│
├─ 最短路径
│  ├─ 单源、非负权重 → Dijkstra
│  ├─ 单源、负权重 → Bellman-Ford
│  └─ 全源 → Floyd-Warshall
│
├─ 最小生成树
│  ├─ 稠密图 → Prim
│  └─ 稀疏图 → Kruskal
│
└─ 连通性 → DFS/BFS/并查集

并发还是串行？
│
├─ CPU密集型、大数据 → Rayon并行
├─ I/O密集型 → 异步(tokio)
├─ 小数据量 → 串行(避免开销)
└─ 共享状态少 → 并行更优
```

---

**文档版本**: v1.0
**最后更新**: 2025-10-20
**维护者**: Rust Learning Community

---

🗺️ **掌握算法与数据结构，提升编程核心竞争力！** 🚀✨
