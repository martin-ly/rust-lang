# å½¢å¼åŒ–ç®—æ³•ç†è®º

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§ä¸»é¢˜
> **æœ€åæ›´æ–°**: 2025-10-23
> **çŠ¶æ€**: âœ… å®Œæˆ

---

## ç›®å½•

- [å½¢å¼åŒ–ç®—æ³•ç†è®º](#å½¢å¼åŒ–ç®—æ³•ç†è®º)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
    - [è¯æ˜æ ‘å›¾](#è¯æ˜æ ‘å›¾)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1 ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰](#11-ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰)
      - [å›¾çµæœºå®šä¹‰](#å›¾çµæœºå®šä¹‰)
      - [Church-Turing è®ºé¢˜](#church-turing-è®ºé¢˜)
    - [1.2 è®¡ç®—æ¨¡å‹](#12-è®¡ç®—æ¨¡å‹)
      - [RAM (Random Access Machine) æ¨¡å‹](#ram-random-access-machine-æ¨¡å‹)
      - [å¹¶è¡Œè®¡ç®—æ¨¡å‹](#å¹¶è¡Œè®¡ç®—æ¨¡å‹)
    - [1.3 å¯è®¡ç®—æ€§ç†è®º](#13-å¯è®¡ç®—æ€§ç†è®º)
      - [å¯åˆ¤å®šæ€§ä¸ä¸å¯åˆ¤å®šæ€§](#å¯åˆ¤å®šæ€§ä¸ä¸å¯åˆ¤å®šæ€§)
  - [2. å¤æ‚åº¦ç†è®º](#2-å¤æ‚åº¦ç†è®º)
    - [2.1 æ—¶é—´å¤æ‚åº¦åˆ†æ](#21-æ—¶é—´å¤æ‚åº¦åˆ†æ)
      - [ä¸»å®šç† (Master Theorem)](#ä¸»å®šç†-master-theorem)
      - [æ‘Šè¿˜åˆ†æ](#æ‘Šè¿˜åˆ†æ)
    - [2.2 ç©ºé—´å¤æ‚åº¦åˆ†æ](#22-ç©ºé—´å¤æ‚åº¦åˆ†æ)
      - [Savitch å®šç†](#savitch-å®šç†)
    - [2.3 å¤æ‚åº¦ç±»](#23-å¤æ‚åº¦ç±»)
      - [P vs NP](#p-vs-np)
  - [3. ç®—æ³•æ­£ç¡®æ€§è¯æ˜](#3-ç®—æ³•æ­£ç¡®æ€§è¯æ˜)
    - [3.1 å½’çº³æ³•è¯æ˜](#31-å½’çº³æ³•è¯æ˜)
      - [æ•°å­¦å½’çº³æ³•](#æ•°å­¦å½’çº³æ³•)
    - [3.2 å¾ªç¯ä¸å˜å¼](#32-å¾ªç¯ä¸å˜å¼)
      - [å¾ªç¯ä¸å˜å¼è¯æ˜ä¸‰è¦ç´ ](#å¾ªç¯ä¸å˜å¼è¯æ˜ä¸‰è¦ç´ )
    - [3.3 Hoare é€»è¾‘](#33-hoare-é€»è¾‘)
      - [Hoare ä¸‰å…ƒç»„ {P} S {Q}](#hoare-ä¸‰å…ƒç»„-p-s-q)
  - [4. å½¢å¼åŒ–éªŒè¯å·¥å…·](#4-å½¢å¼åŒ–éªŒè¯å·¥å…·)
    - [4.1 Kani éªŒè¯å™¨](#41-kani-éªŒè¯å™¨)
    - [4.2 Prusti éªŒè¯å™¨](#42-prusti-éªŒè¯å™¨)
    - [4.3 å½¢å¼åŒ–è§„çº¦](#43-å½¢å¼åŒ–è§„çº¦)
  - [5. é«˜çº§ç®—æ³•ç†è®º](#5-é«˜çº§ç®—æ³•ç†è®º)
    - [5.1 è¿‘ä¼¼ç®—æ³•](#51-è¿‘ä¼¼ç®—æ³•)
    - [5.2 éšæœºç®—æ³•](#52-éšæœºç®—æ³•)
    - [5.3 åœ¨çº¿ç®—æ³•](#53-åœ¨çº¿ç®—æ³•)
  - [6. å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 äºŒåˆ†æœç´¢æ­£ç¡®æ€§è¯æ˜](#61-äºŒåˆ†æœç´¢æ­£ç¡®æ€§è¯æ˜)
    - [6.2 å¿«é€Ÿæ’åºå¤æ‚åº¦åˆ†æ](#62-å¿«é€Ÿæ’åºå¤æ‚åº¦åˆ†æ)
    - [6.3 Dijkstra ç®—æ³•éªŒè¯](#63-dijkstra-ç®—æ³•éªŒè¯)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)
    - [æ•™æ](#æ•™æ)
    - [å½¢å¼åŒ–éªŒè¯](#å½¢å¼åŒ–éªŒè¯)
    - [å¤æ‚åº¦ç†è®º](#å¤æ‚åº¦ç†è®º)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å½¢å¼åŒ–ç®—æ³•ç†è®º (Formal Algorithm Theory)**:

- **å®šä¹‰**: Rust 1.92.0 ä½¿ç”¨æ•°å­¦æ–¹æ³•ä¸¥æ ¼å®šä¹‰å’Œåˆ†æç®—æ³•çš„ç†è®ºä½“ç³»ï¼ŒåŒ…æ‹¬å›¾çµæœºã€è®¡ç®—æ¨¡å‹ã€å¯è®¡ç®—æ€§ç†è®ºã€å¤æ‚åº¦ç†è®ºã€ç®—æ³•æ­£ç¡®æ€§è¯æ˜ã€å½¢å¼åŒ–éªŒè¯å·¥å…·ç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: ç®—æ³•å­¦ã€ç†è®ºè®¡ç®—æœºç§‘å­¦
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: å›¾çµæœºã€å¤æ‚åº¦ç†è®ºã€å½¢å¼åŒ–éªŒè¯ã€å¯è®¡ç®—æ€§ç†è®ºã€Kaniã€Prusti

**å›¾çµæœº (Turing Machine)**:

- **å®šä¹‰**: æœ€åŸºæœ¬çš„è®¡ç®—æ¨¡å‹ï¼Œç”¨äºå®šä¹‰ç®—æ³•çš„å¯è®¡ç®—æ€§
- **ç±»å‹**: è®¡ç®—æ¨¡å‹
- **å±æ€§**: çŠ¶æ€é›†åˆã€è½¬ç§»å‡½æ•°ã€å¸¦å­—æ¯è¡¨
- **å…³ç³»**: ä¸ç®—æ³•ã€å¯è®¡ç®—æ€§ç†è®ºç›¸å…³

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å½¢å¼åŒ–å®šä¹‰**: ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰
- **å¯è®¡ç®—æ€§**: åˆ¤å®šé—®é¢˜æ˜¯å¦å¯è®¡ç®—
- **å¤æ‚åº¦åˆ†æ**: æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- **æ­£ç¡®æ€§è¯æ˜**: æ•°å­¦è¯æ˜ç®—æ³•æ­£ç¡®æ€§

**ç†è®ºç‰¹å¾**:

- **å›¾çµæœº**: åŸºæœ¬è®¡ç®—æ¨¡å‹
- **å¤æ‚åº¦ç±»**: Pã€NPã€PSPACE ç­‰
- **é€‚ç”¨åœºæ™¯**: ç®—æ³•è®¾è®¡ã€å¤æ‚åº¦åˆ†æã€å½¢å¼åŒ–éªŒè¯

### å…³ç³»è¿æ¥

**ç»§æ‰¿å…³ç³»**:

- å›¾çµæœº --[is-a]--> è®¡ç®—æ¨¡å‹
- å¤æ‚åº¦ç±» --[is-a]--> å¤æ‚åº¦ç†è®º

**ç»„åˆå…³ç³»**:

- ç®—æ³•ç†è®º --[uses]--> å½¢å¼åŒ–æ–¹æ³•
- ç®—æ³•åˆ†æ --[uses]--> å¤æ‚åº¦ç†è®º

**ä¾èµ–å…³ç³»**:

- å½¢å¼åŒ–ç®—æ³•ç†è®º --[depends-on]--> æ•°å­¦åŸºç¡€
- ç®—æ³•æ­£ç¡®æ€§ --[depends-on]--> å½¢å¼åŒ–è¯æ˜

### æ€ç»´å¯¼å›¾

```text
å½¢å¼åŒ–ç®—æ³•ç†è®º
â”‚
â”œâ”€â”€ ç†è®ºåŸºç¡€
â”‚   â”œâ”€â”€ å›¾çµæœº
â”‚   â”œâ”€â”€ è®¡ç®—æ¨¡å‹
â”‚   â””â”€â”€ å¯è®¡ç®—æ€§ç†è®º
â”œâ”€â”€ å¤æ‚åº¦ç†è®º
â”‚   â”œâ”€â”€ æ—¶é—´å¤æ‚åº¦
â”‚   â”œâ”€â”€ ç©ºé—´å¤æ‚åº¦
â”‚   â””â”€â”€ å¤æ‚åº¦ç±»
â”œâ”€â”€ ç®—æ³•æ­£ç¡®æ€§è¯æ˜
â”‚   â”œâ”€â”€ å½’çº³æ³•
â”‚   â”œâ”€â”€ å¾ªç¯ä¸å˜å¼
â”‚   â””â”€â”€ Hoare é€»è¾‘
â””â”€â”€ å½¢å¼åŒ–éªŒè¯å·¥å…·
    â”œâ”€â”€ Kani
    â””â”€â”€ Prusti
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| å½¢å¼åŒ–æ–¹æ³•      | ç²¾åº¦ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯      | Rust 1.92.0 |
| :--- | :--- | :--- | :--- | :--- || **å›¾çµæœº**      | æœ€é«˜ | é«˜     | ç†è®ºåˆ†æ      | âœ…          |
| **å¤æ‚åº¦åˆ†æ**  | é«˜   | ä¸­     | ç®—æ³•åˆ†æ      | âœ…          |
| **å½’çº³æ³•è¯æ˜**  | é«˜   | ä¸­     | ç®—æ³•æ­£ç¡®æ€§    | âœ…          |
| **å¾ªç¯ä¸å˜å¼**  | é«˜   | ä¸­     | å¾ªç¯ç®—æ³•      | âœ…          |
| **Hoare é€»è¾‘**  | æœ€é«˜ | é«˜     | ç¨‹åºéªŒè¯      | âœ…          |
| **Kani éªŒè¯**   | é«˜   | ä¸­     | Rust ç¨‹åºéªŒè¯ | âœ… æ”¹è¿›     |
| **Prusti éªŒè¯** | æœ€é«˜ | é«˜     | å½¢å¼åŒ–è§„çº¦    | âœ…          |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©å½¢å¼åŒ–æ–¹æ³•
â”‚
â”œâ”€â”€ éœ€è¦éªŒè¯ä»€ä¹ˆï¼Ÿ
â”‚   â”œâ”€â”€ å¯è®¡ç®—æ€§ â†’ å›¾çµæœº
â”‚   â”œâ”€â”€ å¤æ‚åº¦ â†’ å¤æ‚åº¦åˆ†æ
â”‚   â”œâ”€â”€ æ­£ç¡®æ€§ â†’ å½’çº³æ³• / å¾ªç¯ä¸å˜å¼ / Hoare é€»è¾‘
â”‚   â””â”€â”€ Rust ç¨‹åº â†’ Kani / Prusti
```

### è¯æ˜æ ‘å›¾

```text
ç®—æ³•æ­£ç¡®æ€§è¯æ˜
â”‚
â”œâ”€â”€ å½’çº³æ³•è¯æ˜
â”‚   â”œâ”€â”€ åŸºç¡€æ­¥éª¤
â”‚   â””â”€â”€ å½’çº³æ­¥éª¤
â”œâ”€â”€ å¾ªç¯ä¸å˜å¼è¯æ˜
â”‚   â”œâ”€â”€ åˆå§‹åŒ–
â”‚   â”œâ”€â”€ ä¿æŒæ€§
â”‚   â””â”€â”€ ç»ˆæ­¢æ€§
â””â”€â”€ Hoare é€»è¾‘è¯æ˜
    â”œâ”€â”€ å‰ç½®æ¡ä»¶
    â””â”€â”€ åç½®æ¡ä»¶
```

---

## 1. ç†è®ºåŸºç¡€

### 1.1 ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰

#### å›¾çµæœºå®šä¹‰

**å›¾çµæœº (Turing Machine)** æ˜¯æœ€åŸºæœ¬çš„è®¡ç®—æ¨¡å‹ï¼Œç”±ä»¥ä¸‹ç»„æˆï¼š

- **çŠ¶æ€é›†åˆ** Q = {qâ‚€, qâ‚, ..., qâ‚™, qâ‚, qáµ£}
- **è¾“å…¥å­—æ¯è¡¨** Î£
- **å¸¦å­—æ¯è¡¨** Î“ âŠ‡ Î£
- **è½¬ç§»å‡½æ•°** Î´: Q Ã— Î“ â†’ Q Ã— Î“ Ã— {L, R}
- **åˆå§‹çŠ¶æ€** qâ‚€
- **æ¥å—çŠ¶æ€** qâ‚
- **æ‹’ç»çŠ¶æ€** qáµ£

```rust
/// å›¾çµæœºæ¨¡æ‹Ÿå™¨ï¼ˆæ•™å­¦ç”¨é€”ï¼‰
pub struct TuringMachine {
    states: Vec<String>,
    alphabet: Vec<char>,
    tape_alphabet: Vec<char>,
    transitions: HashMap<(usize, char), (usize, char, Direction)>,
    initial_state: usize,
    accept_state: usize,
    reject_state: usize,
}

#[derive(Debug, Clone, Copy)]
enum Direction {
    Left,
    Right,
}

impl TuringMachine {
    /// æ‰§è¡Œå›¾çµæœº
    pub fn run(&self, input: &str) -> Result<bool, String> {
        let mut tape: Vec<char> = input.chars().collect();
        tape.push('_'); // ç©ºç™½ç¬¦
        let mut head = 0;
        let mut state = self.initial_state;

        loop {
            if state == self.accept_state {
                return Ok(true);
            }
            if state == self.reject_state {
                return Ok(false);
            }

            let current_symbol = tape[head];
            let key = (state, current_symbol);

            match self.transitions.get(&key) {
                Some(&(next_state, write_symbol, direction)) => {
                    tape[head] = write_symbol;
                    state = next_state;

                    match direction {
                        Direction::Left => {
                            if head == 0 {
                                tape.insert(0, '_');
                            } else {
                                head -= 1;
                            }
                        }
                        Direction::Right => {
                            head += 1;
                            if head >= tape.len() {
                                tape.push('_');
                            }
                        }
                    }
                }
                None => return Err(format!("No transition for state {} symbol {}", state, current_symbol)),
            }
        }
    }
}
```

#### Church-Turing è®ºé¢˜

**è®ºé¢˜**: ä¸€åˆ‡æœ‰æ•ˆè®¡ç®—è¿‡ç¨‹éƒ½å¯ä»¥ç”¨å›¾çµæœºè¡¨ç¤ºã€‚

**æ¨è®º**:

- æ‰€æœ‰åˆç†çš„è®¡ç®—æ¨¡å‹ï¼ˆÎ»æ¼”ç®—ã€é€’å½’å‡½æ•°ã€RAMæ¨¡å‹ï¼‰éƒ½ç­‰ä»·
- Rust ç¼–å†™çš„ç®—æ³•æœ¬è´¨ä¸Šéƒ½æ˜¯å›¾çµæœºçš„å®ç°

```rust
// Î»æ¼”ç®—è¡¨ç¤ºï¼ˆRust ä¸­ä½¿ç”¨é—­åŒ…æ¨¡æ‹Ÿï¼‰
type Lambda<T> = Box<dyn Fn(T) -> T>;

/// Yç»„åˆå­ï¼ˆä¸åŠ¨ç‚¹ç»„åˆå­ï¼‰
fn y_combinator<T, F>(f: F) -> impl Fn(T) -> T
where
    T: 'static,
    F: Fn(Box<dyn Fn(T) -> T>) -> Box<dyn Fn(T) -> T> + 'static,
{
    move |x| f(Box::new(y_combinator(|g| f(g))))(x)
}

// ç¤ºä¾‹ï¼šä½¿ç”¨ Y ç»„åˆå­å®šä¹‰é˜¶ä¹˜
fn factorial_lambda() -> impl Fn(i32) -> i32 {
    y_combinator(|fact: Box<dyn Fn(i32) -> i32>| {
        Box::new(move |n| {
            if n <= 1 {
                1
            } else {
                n * fact(n - 1)
            }
        })
    })
}
```

### 1.2 è®¡ç®—æ¨¡å‹

#### RAM (Random Access Machine) æ¨¡å‹

**ç‰¹ç‚¹**:

- æœ‰é™å¤§å°çš„å¯„å­˜å™¨
- éšæœºè®¿é—®å†…å­˜ (O(1) æ—¶é—´)
- åŸºæœ¬æ“ä½œï¼šç®—æœ¯è¿ç®—ã€æ¯”è¾ƒã€è·³è½¬

```rust
/// RAM æ¨¡å‹ä¸­çš„åŸºæœ¬æ“ä½œè®¡æ•°
pub struct OperationCounter {
    arithmetic_ops: u64,  // +, -, *, /, %
    comparison_ops: u64,  // <, >, ==, !=
    memory_access: u64,   // è¯»å†™æ“ä½œ
    branch_ops: u64,      // if, match, loop
}

impl OperationCounter {
    /// è®¡æ•°ç‰ˆæœ¬çš„äºŒåˆ†æœç´¢
    pub fn binary_search_counted(&mut self, arr: &[i32], target: i32) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();

        while left < right {
            self.comparison_ops += 1; // while æ¡ä»¶

            let mid = left + (right - left) / 2;
            self.arithmetic_ops += 3; // ä¸¤æ¬¡åŠ æ³•ï¼Œä¸€æ¬¡é™¤æ³•
            self.memory_access += 1;  // arr[mid]

            self.comparison_ops += 1;
            if arr[mid] == target {
                return Some(mid);
            }

            self.comparison_ops += 1;
            if arr[mid] < target {
                left = mid + 1;
                self.arithmetic_ops += 1;
            } else {
                right = mid;
            }
        }

        None
    }

    /// è¾“å‡ºæ“ä½œç»Ÿè®¡
    pub fn report(&self) -> String {
        format!(
            "ç®—æœ¯è¿ç®—: {}\næ¯”è¾ƒæ“ä½œ: {}\nå†…å­˜è®¿é—®: {}\nåˆ†æ”¯è·³è½¬: {}",
            self.arithmetic_ops,
            self.comparison_ops,
            self.memory_access,
            self.branch_ops
        )
    }
}
```

#### å¹¶è¡Œè®¡ç®—æ¨¡å‹

**PRAM (Parallel RAM)** æ¨¡å‹:

```rust
use rayon::prelude::*;

/// PRAM EREW (Exclusive Read Exclusive Write)
pub fn pram_erew_sum(arr: &[i32]) -> i32 {
    if arr.is_empty() {
        return 0;
    }

    // EREW: æ¯ä¸ªå¤„ç†å™¨ç‹¬å è¯»å†™
    let n = arr.len();
    let mut temp = arr.to_vec();

    // å½’çº¦æ±‚å’Œ (O(log n) æ·±åº¦)
    let mut stride = 1;
    while stride < n {
        temp.par_chunks_mut(stride * 2)
            .for_each(|chunk| {
                if chunk.len() > stride {
                    chunk[0] += chunk[stride];
                }
            });
        stride *= 2;
    }

    temp[0]
}

/// PRAM CRCW (Concurrent Read Concurrent Write)
pub fn pram_crcw_max(arr: &[i32]) -> Option<i32> {
    arr.par_iter().copied().max()
}
```

### 1.3 å¯è®¡ç®—æ€§ç†è®º

#### å¯åˆ¤å®šæ€§ä¸ä¸å¯åˆ¤å®šæ€§

```rust
/// åœæœºé—®é¢˜ï¼ˆç†è®ºä¸Šä¸å¯åˆ¤å®šï¼‰
///
/// å®šç†ï¼šä¸å­˜åœ¨ç®—æ³•H(P, I)èƒ½åˆ¤å®šç¨‹åºPåœ¨è¾“å…¥Iä¸Šæ˜¯å¦åœæœº
///
/// è¯æ˜ï¼ˆåè¯æ³•ï¼‰ï¼š
/// å‡è®¾å­˜åœ¨H(P, I)ï¼Œåˆ™å¯æ„é€ ï¼š
/// fn D(P):
///     if H(P, P):
///         loop {}  // ä¸åœæœº
///     else:
///         return   // åœæœº
///
/// é—®ï¼šD(D) æ˜¯å¦åœæœºï¼Ÿ
/// - è‹¥ H(D, D) = trueï¼Œåˆ™ D(D) è¿›å…¥æ— é™å¾ªç¯ï¼ˆä¸åœæœºï¼‰â€”â€” çŸ›ç›¾ï¼
/// - è‹¥ H(D, D) = falseï¼Œåˆ™ D(D) è¿”å›ï¼ˆåœæœºï¼‰â€”â€” çŸ›ç›¾ï¼
///
/// å› æ­¤ H ä¸å­˜åœ¨ã€‚
pub fn halting_problem_proof() {
    // æ­¤å‡½æ•°ä»…ä¸ºæ–‡æ¡£è¯´æ˜ï¼Œæ— æ³•å®ç°
    panic!("åœæœºé—®é¢˜ä¸å¯åˆ¤å®š");
}

/// å¯åˆ¤å®šé—®é¢˜ç¤ºä¾‹ï¼šæ­£åˆ™è¯­è¨€åŒ¹é…
pub fn is_regular_language_match(pattern: &str, text: &str) -> bool {
    // æ­£åˆ™è¯­è¨€å¯åˆ¤å®š
    regex::Regex::new(pattern)
        .map(|re| re.is_match(text))
        .unwrap_or(false)
}

/// åŠå¯åˆ¤å®šé—®é¢˜ç¤ºä¾‹ï¼šä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
pub fn is_context_free_language(grammar: &str, text: &str) -> Option<bool> {
    // CFL åŠå¯åˆ¤å®šï¼ˆå¯æšä¸¾ï¼‰
    // å®é™…å®ç°çœç•¥
    Some(true)
}
```

---

## 2. å¤æ‚åº¦ç†è®º

### 2.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

#### ä¸»å®šç† (Master Theorem)

å¯¹äºé€’å½’å…³ç³» T(n) = aT(n/b) + f(n)ï¼Œå…¶ä¸­ a â‰¥ 1, b > 1ï¼š

```rust
/// ä¸»å®šç†åº”ç”¨ç¤ºä¾‹
pub mod master_theorem {
    /// Case 1: f(n) = O(n^(log_b(a) - Îµ))
    /// ç»“è®º: T(n) = Î˜(n^(log_b(a)))
    ///
    /// ç¤ºä¾‹: äºŒåˆ†æœç´¢ T(n) = T(n/2) + O(1)
    /// a=1, b=2, f(n)=O(1), log_2(1)=0
    /// 1 < n^0, Case 1, T(n) = Î˜(1) âŒ
    /// å®é™…: T(n) = Î˜(log n) (Case 2)
    pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        if arr.is_empty() {
            return None;
        }

        let mut left = 0;
        let mut right = arr.len();

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => return Some(mid),
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        None
    }

    /// Case 2: f(n) = Î˜(n^(log_b(a)))
    /// ç»“è®º: T(n) = Î˜(n^(log_b(a)) log n)
    ///
    /// ç¤ºä¾‹: å½’å¹¶æ’åº T(n) = 2T(n/2) + Î˜(n)
    /// a=2, b=2, f(n)=Î˜(n), log_2(2)=1
    /// n = n^1, Case 2, T(n) = Î˜(n log n) âœ…
    pub fn merge_sort<T: Ord + Clone>(arr: &mut [T]) {
        let len = arr.len();
        if len <= 1 {
            return;
        }

        let mid = len / 2;
        merge_sort(&mut arr[..mid]);
        merge_sort(&mut arr[mid..]);

        let mut temp = arr.to_vec();
        let (left, right) = temp.split_at(mid);

        let mut i = 0;
        let mut j = 0;
        let mut k = 0;

        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                arr[k] = left[i].clone();
                i += 1;
            } else {
                arr[k] = right[j].clone();
                j += 1;
            }
            k += 1;
        }

        while i < left.len() {
            arr[k] = left[i].clone();
            i += 1;
            k += 1;
        }

        while j < right.len() {
            arr[k] = right[j].clone();
            j += 1;
            k += 1;
        }
    }

    /// Case 3: f(n) = Î©(n^(log_b(a) + Îµ))
    /// ä¸” af(n/b) â‰¤ cf(n) (æ­£åˆ™æ¡ä»¶)
    /// ç»“è®º: T(n) = Î˜(f(n))
    ///
    /// ç¤ºä¾‹: Strassen çŸ©é˜µä¹˜æ³• T(n) = 7T(n/2) + Î˜(nÂ²)
    /// a=7, b=2, f(n)=Î˜(nÂ²), log_2(7)â‰ˆ2.807
    /// nÂ² < n^2.807, ä¸æ»¡è¶³ Case 3
    /// å®é™…: T(n) = Î˜(n^2.807)
    pub fn strassen_matrix_multiply(a: &[Vec<i64>], b: &[Vec<i64>]) -> Vec<Vec<i64>> {
        // ç®€åŒ–å®ç°çœç•¥
        vec![vec![0; a.len()]; a.len()]
    }
}
```

#### æ‘Šè¿˜åˆ†æ

```rust
/// åŠ¨æ€æ•°ç»„çš„æ‘Šè¿˜åˆ†æ
pub struct DynamicArray<T> {
    data: Vec<T>,
    capacity: usize,
    size: usize,
    total_cost: usize,  // ç”¨äºæ‘Šè¿˜åˆ†æ
}

impl<T: Clone> DynamicArray<T> {
    pub fn new() -> Self {
        Self {
            data: Vec::new(),
            capacity: 0,
            size: 0,
            total_cost: 0,
        }
    }

    /// æ’å…¥æ“ä½œçš„æ‘Šè¿˜åˆ†æ
    ///
    /// åŠ¿å‡½æ•°: Î¦(i) = 2Â·size(i) - capacity(i)
    ///
    /// ä¸æ‰©å®¹æ—¶:
    ///   å®é™…ä»£ä»·: c_i = 1
    ///   æ‘Šè¿˜ä»£ä»·: Ä‰_i = c_i + Î¦(i) - Î¦(i-1) = 1 + 2 = 3
    ///
    /// æ‰©å®¹æ—¶ (size = capacity):
    ///   å®é™…ä»£ä»·: c_i = size + 1 (å¤åˆ¶æ—§å…ƒç´  + æ’å…¥)
    ///   Î¦(i) = 2(size+1) - 2Â·size = 2
    ///   Î¦(i-1) = 2Â·size - size = size
    ///   æ‘Šè¿˜ä»£ä»·: Ä‰_i = (size+1) + 2 - size = 3
    ///
    /// ç»“è®º: æ¯æ¬¡æ’å…¥çš„æ‘Šè¿˜ä»£ä»·ä¸º O(1)
    pub fn push(&mut self, value: T) {
        if self.size == self.capacity {
            // æ‰©å®¹ï¼šå®é™…ä»£ä»· = size + 1
            let new_capacity = if self.capacity == 0 { 1 } else { self.capacity * 2 };
            self.data.reserve(new_capacity - self.capacity);
            self.capacity = new_capacity;
            self.total_cost += self.size + 1;
        } else {
            // ä¸æ‰©å®¹ï¼šå®é™…ä»£ä»· = 1
            self.total_cost += 1;
        }

        self.data.push(value);
        self.size += 1;
    }

    /// è·å–å¹³å‡æ‘Šè¿˜ä»£ä»·
    pub fn amortized_cost(&self) -> f64 {
        if self.size == 0 {
            0.0
        } else {
            self.total_cost as f64 / self.size as f64
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_amortized_analysis() {
        let mut arr = DynamicArray::new();

        for i in 0..1000 {
            arr.push(i);
        }

        // æ‘Šè¿˜ä»£ä»·åº”æ¥è¿‘ 3
        let avg_cost = arr.amortized_cost();
        assert!(avg_cost < 3.5);
        println!("å¹³å‡æ‘Šè¿˜ä»£ä»·: {:.2}", avg_cost);
    }
}
```

### 2.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

#### Savitch å®šç†

**å®šç†**: NSPACE(f(n)) âŠ† DSPACE(fÂ²(n))

```rust
/// å¯è¾¾æ€§é—®é¢˜çš„ Savitch ç®—æ³•
/// ç©ºé—´å¤æ‚åº¦: O(logÂ² n)
pub fn reachability_savitch(
    graph: &[Vec<usize>],
    start: usize,
    end: usize,
    steps: usize,
) -> bool {
    if steps == 0 {
        return start == end;
    }

    if steps == 1 {
        return start == end || graph[start].contains(&end);
    }

    // åˆ†æ²»ï¼šæ˜¯å¦å­˜åœ¨ä¸­é—´èŠ‚ç‚¹ midï¼Œä½¿å¾—
    // start èƒ½åœ¨ steps/2 æ­¥åˆ°è¾¾ midï¼Œä¸” mid èƒ½åœ¨ steps/2 æ­¥åˆ°è¾¾ end
    for mid in 0..graph.len() {
        if reachability_savitch(graph, start, mid, steps / 2)
            && reachability_savitch(graph, mid, end, steps / 2)
        {
            return true;
        }
    }

    false
}
```

### 2.3 å¤æ‚åº¦ç±»

#### P vs NP

```rust
/// P ç±»é—®é¢˜ç¤ºä¾‹ï¼šæœ€çŸ­è·¯å¾„
pub fn shortest_path_dijkstra(
    graph: &[Vec<(usize, i64)>],
    start: usize,
) -> Vec<i64> {
    use std::collections::BinaryHeap;
    use std::cmp::Reverse;

    let n = graph.len();
    let mut dist = vec![i64::MAX; n];
    let mut heap = BinaryHeap::new();

    dist[start] = 0;
    heap.push(Reverse((0, start)));

    while let Some(Reverse((d, u))) = heap.pop() {
        if d > dist[u] {
            continue;
        }

        for &(v, w) in &graph[u] {
            if dist[u] + w < dist[v] {
                dist[v] = dist[u] + w;
                heap.push(Reverse((dist[v], v)));
            }
        }
    }

    dist
}

/// NP å®Œå…¨é—®é¢˜ç¤ºä¾‹ï¼š3-SAT (æš´åŠ›æ±‚è§£)
pub fn three_sat_brute_force(clauses: &[Vec<i32>]) -> Option<Vec<bool>> {
    let num_vars = clauses.iter()
        .flat_map(|c| c.iter())
        .map(|&lit| lit.abs() as usize)
        .max()
        .unwrap_or(0);

    // å°è¯•æ‰€æœ‰ 2^n ç§èµ‹å€¼
    for assignment in 0..(1 << num_vars) {
        let mut vars = vec![false; num_vars + 1];
        for i in 0..num_vars {
            vars[i + 1] = (assignment & (1 << i)) != 0;
        }

        // æ£€æŸ¥æ‰€æœ‰å­å¥æ˜¯å¦æ»¡è¶³
        if clauses.iter().all(|clause| {
            clause.iter().any(|&lit| {
                let var = lit.abs() as usize;
                let value = vars[var];
                if lit > 0 { value } else { !value }
            })
        }) {
            return Some(vars[1..].to_vec());
        }
    }

    None
}
```

---

## 3. ç®—æ³•æ­£ç¡®æ€§è¯æ˜

### 3.1 å½’çº³æ³•è¯æ˜

#### æ•°å­¦å½’çº³æ³•

**è¯æ˜æ¨¡æ¿**:

1. **åŸºç¡€æ­¥éª¤**: è¯æ˜ P(0) æˆ– P(1) æˆç«‹
2. **å½’çº³å‡è®¾**: å‡è®¾ P(k) æˆç«‹
3. **å½’çº³æ­¥éª¤**: è¯æ˜ P(k+1) æˆç«‹

```rust
/// ç¤ºä¾‹ï¼šå¿«é€Ÿå¹‚ç®—æ³•æ­£ç¡®æ€§è¯æ˜
///
/// **å‘½é¢˜**: fast_pow(x, n) è®¡ç®— x^n
///
/// **è¯æ˜**:
/// åŸºç¡€: n=0, è¿”å› 1 = x^0 âœ…
/// å½’çº³: å‡è®¾å¯¹æ‰€æœ‰ k < n, fast_pow(x, k) = x^k
///       å½“ n ä¸ºå¶æ•°: fast_pow(x, n) = fast_pow(x, n/2)Â²
///                                   = (x^(n/2))Â² (å½’çº³å‡è®¾)
///                                   = x^n âœ…
///       å½“ n ä¸ºå¥‡æ•°: fast_pow(x, n) = x Â· fast_pow(x, n-1)
///                                   = x Â· x^(n-1) (å½’çº³å‡è®¾)
///                                   = x^n âœ…
pub fn fast_pow(base: i64, exp: u32) -> i64 {
    match exp {
        0 => 1,
        n if n % 2 == 0 => {
            let half = fast_pow(base, n / 2);
            half * half
        }
        n => base * fast_pow(base, n - 1),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fast_pow_correctness() {
        // éªŒè¯åŸºç¡€æƒ…å†µ
        assert_eq!(fast_pow(2, 0), 1);

        // éªŒè¯å½’çº³æ­¥éª¤ï¼ˆå¶æ•°ï¼‰
        assert_eq!(fast_pow(2, 10), 1024);

        // éªŒè¯å½’çº³æ­¥éª¤ï¼ˆå¥‡æ•°ï¼‰
        assert_eq!(fast_pow(3, 5), 243);
    }
}
```

### 3.2 å¾ªç¯ä¸å˜å¼

#### å¾ªç¯ä¸å˜å¼è¯æ˜ä¸‰è¦ç´ 

1. **åˆå§‹åŒ–**: å¾ªç¯å¼€å§‹å‰ä¸å˜å¼ä¸ºçœŸ
2. **ä¿æŒæ€§**: å¦‚æœå¾ªç¯å¼€å§‹æ—¶ä¸å˜å¼ä¸ºçœŸï¼Œä¸‹ä¸€æ¬¡è¿­ä»£åä»ä¸ºçœŸ
3. **ç»ˆæ­¢æ€§**: å¾ªç¯ç»“æŸæ—¶ï¼Œä¸å˜å¼ + ç»ˆæ­¢æ¡ä»¶ â†’ ç®—æ³•æ­£ç¡®æ€§

```rust
/// æ’å…¥æ’åºçš„å¾ªç¯ä¸å˜å¼è¯æ˜
///
/// **ä¸å˜å¼**: åœ¨ç¬¬ i æ¬¡è¿­ä»£å¼€å§‹æ—¶ï¼Œå­æ•°ç»„ arr[0..i] å·²æ’åº
///
/// **è¯æ˜**:
/// 1. åˆå§‹åŒ–: i=1, arr[0..1] åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œå·²æ’åº âœ…
/// 2. ä¿æŒæ€§: å‡è®¾ arr[0..i] å·²æ’åºï¼Œæ’å…¥ arr[i] åï¼Œarr[0..i+1] ä»æ’åº âœ…
/// 3. ç»ˆæ­¢æ€§: i=n æ—¶ï¼Œarr[0..n] å·²æ’åºï¼Œç®—æ³•æ­£ç¡® âœ…
pub fn insertion_sort<T: Ord>(arr: &mut [T]) {
    for i in 1..arr.len() {
        let mut j = i;
        // ä¸å˜å¼: arr[0..i] å·²æ’åº
        while j > 0 && arr[j - 1] > arr[j] {
            arr.swap(j - 1, j);
            j -= 1;
        }
        // ç°åœ¨ arr[0..i+1] å·²æ’åº
    }
}

/// äºŒåˆ†æœç´¢çš„å¾ªç¯ä¸å˜å¼
///
/// **ä¸å˜å¼**: å¦‚æœ target å­˜åœ¨äº arr ä¸­ï¼Œåˆ™å¿…åœ¨ arr[left..right] ä¸­
///
/// **è¯æ˜**:
/// 1. åˆå§‹åŒ–: left=0, right=n, target è‹¥å­˜åœ¨å¿…åœ¨ arr[0..n] âœ…
/// 2. ä¿æŒæ€§:
///    - è‹¥ arr[mid] < target, target åœ¨ [mid+1, right), æ›´æ–° left=mid+1 âœ…
///    - è‹¥ arr[mid] > target, target åœ¨ [left, mid), æ›´æ–° right=mid âœ…
///    - è‹¥ arr[mid] == target, æ‰¾åˆ°ï¼Œè¿”å› âœ…
/// 3. ç»ˆæ­¢æ€§: left >= right, åŒºé—´ä¸ºç©ºï¼Œtarget ä¸å­˜åœ¨ âœ…
pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();

    // ä¸å˜å¼: target è‹¥å­˜åœ¨ï¼Œå¿…åœ¨ arr[left..right]
    while left < right {
        let mid = left + (right - left) / 2;

        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }

    None
}
```

### 3.3 Hoare é€»è¾‘

#### Hoare ä¸‰å…ƒç»„ {P} S {Q}

- **P**: å‰ç½®æ¡ä»¶ (Precondition)
- **S**: ç¨‹åºè¯­å¥ (Statement)
- **Q**: åç½®æ¡ä»¶ (Postcondition)

```rust
/// Hoare é€»è¾‘ç¤ºä¾‹ï¼šæœ€å¤§å€¼æŸ¥æ‰¾
///
/// **è§„çº¦**:
/// {arr.len() > 0}  // å‰ç½®æ¡ä»¶
/// max = find_max(arr)
/// {âˆ€i âˆˆ [0, arr.len()): arr[i] <= max âˆ§ âˆƒj: arr[j] == max}  // åç½®æ¡ä»¶
pub fn find_max(arr: &[i32]) -> i32 {
    assert!(!arr.is_empty(), "å‰ç½®æ¡ä»¶: arr éç©º");

    let mut max = arr[0];

    // ä¸å˜å¼: max = max(arr[0..i])
    for &x in &arr[1..] {
        if x > max {
            max = x;
        }
    }

    // åç½®æ¡ä»¶éªŒè¯
    debug_assert!(arr.iter().all(|&x| x <= max), "max æ˜¯æœ€å¤§å€¼");
    debug_assert!(arr.iter().any(|&x| x == max), "max å­˜åœ¨äºæ•°ç»„ä¸­");

    max
}

/// Hoare é€»è¾‘ï¼šé™¤æ³•è§„çº¦
///
/// {b â‰  0}
/// q, r = divide(a, b)
/// {a = bÂ·q + r âˆ§ 0 <= r < |b|}
pub fn divide(a: i32, b: i32) -> (i32, i32) {
    assert!(b != 0, "å‰ç½®æ¡ä»¶: é™¤æ•°éé›¶");

    let q = a / b;
    let r = a % b;

    // åç½®æ¡ä»¶éªŒè¯
    debug_assert_eq!(a, b * q + r, "å•†å’Œä½™æ•°å…³ç³»");
    debug_assert!(r >= 0 && r < b.abs(), "ä½™æ•°èŒƒå›´");

    (q, r)
}
```

---

## 4. å½¢å¼åŒ–éªŒè¯å·¥å…·

### 4.1 Kani éªŒè¯å™¨

```rust
/// ä½¿ç”¨ Kani éªŒè¯äºŒåˆ†æœç´¢
#[cfg(kani)]
mod kani_proofs {
    use super::*;

    #[kani::proof]
    fn verify_binary_search() {
        let arr: [i32; 5] = kani::any();
        let target: i32 = kani::any();

        // å‡è®¾æ•°ç»„å·²æ’åº
        kani::assume(arr.windows(2).all(|w| w[0] <= w[1]));

        match binary_search(&arr, &target) {
            Some(idx) => {
                // éªŒè¯æ‰¾åˆ°çš„ç´¢å¼•æ­£ç¡®
                kani::assert(arr[idx] == target, "æ‰¾åˆ°çš„å…ƒç´ æ­£ç¡®");
            }
            None => {
                // éªŒè¯ target ç¡®å®ä¸åœ¨æ•°ç»„ä¸­
                kani::assert(!arr.contains(&target), "target ä¸å­˜åœ¨");
            }
        }
    }

    #[kani::proof]
    fn verify_fast_pow_no_overflow() {
        let base: i32 = kani::any();
        let exp: u32 = kani::any();

        // é™åˆ¶è¾“å…¥èŒƒå›´ä»¥é¿å…æº¢å‡º
        kani::assume(base >= -100 && base <= 100);
        kani::assume(exp <= 10);

        let result = fast_pow(base as i64, exp);

        // éªŒè¯ç»“æœç¬¦åˆæ•°å­¦å®šä¹‰
        if exp == 0 {
            kani::assert(result == 1, "x^0 = 1");
        }
    }
}
```

### 4.2 Prusti éªŒè¯å™¨

```rust
/// ä½¿ç”¨ Prusti è§„çº¦çš„ GCD ç®—æ³•
#[requires(a > 0 && b > 0)]
#[ensures(result > 0)]
#[ensures(a % result == 0 && b % result == 0)]
#[ensures(forall(|d: i32| (d > result && a % d == 0 && b % d == 0) ==> false))]
pub fn gcd(mut a: i32, mut b: i32) -> i32 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}
```

### 4.3 å½¢å¼åŒ–è§„çº¦

```rust
/// å½¢å¼åŒ–è§„çº¦ï¼šæ’åºç®—æ³•
pub trait SortSpec {
    /// æ’åºåæ•°ç»„æ˜¯æœ‰åºçš„
    fn is_sorted<T: Ord>(arr: &[T]) -> bool {
        arr.windows(2).all(|w| w[0] <= w[1])
    }

    /// æ’åºåæ•°ç»„æ˜¯åŸæ•°ç»„çš„æ’åˆ—
    fn is_permutation<T: Eq>(original: &[T], sorted: &[T]) -> bool {
        if original.len() != sorted.len() {
            return false;
        }

        let mut orig = original.to_vec();
        let mut sort = sorted.to_vec();
        orig.sort_by_key(|x| x as *const T as usize);
        sort.sort_by_key(|x| x as *const T as usize);

        orig == sort
    }

    /// æ’åºè§„çº¦
    fn sort<T: Ord + Clone>(&self, arr: &[T]) -> Vec<T>;
}

/// å¸¦è§„çº¦æ£€æŸ¥çš„æ’åºå®ç°
pub struct VerifiedSort;

impl SortSpec for VerifiedSort {
    fn sort<T: Ord + Clone>(&self, arr: &[T]) -> Vec<T> {
        let original = arr.to_vec();
        let mut sorted = arr.to_vec();
        sorted.sort();

        // éªŒè¯åç½®æ¡ä»¶
        assert!(Self::is_sorted(&sorted), "æ’åºåæ•°ç»„æœ‰åº");
        assert!(Self::is_permutation(&original, &sorted), "æ’åºåæ˜¯åŸæ•°ç»„çš„æ’åˆ—");

        sorted
    }
}
```

---

## 5. é«˜çº§ç®—æ³•ç†è®º

### 5.1 è¿‘ä¼¼ç®—æ³•

```rust
/// é¡¶ç‚¹è¦†ç›–è¿‘ä¼¼ç®—æ³• (2-approximation)
///
/// **é—®é¢˜**: æ‰¾æœ€å°é¡¶ç‚¹é›† Cï¼Œä½¿å¾—æ¯æ¡è¾¹è‡³å°‘æœ‰ä¸€ä¸ªç«¯ç‚¹åœ¨ C ä¸­
/// **è¿‘ä¼¼æ¯”**: 2 (ç®—æ³•è¾“å‡º â‰¤ 2 Ã— æœ€ä¼˜è§£)
pub fn vertex_cover_approx(edges: &[(usize, usize)], n: usize) -> Vec<usize> {
    let mut cover = Vec::new();
    let mut edge_covered = vec![false; edges.len()];

    for (i, &(u, v)) in edges.iter().enumerate() {
        if !edge_covered[i] {
            cover.push(u);
            cover.push(v);

            // æ ‡è®°æ‰€æœ‰ä¸ u, v ç›¸å…³çš„è¾¹
            for (j, &(x, y)) in edges.iter().enumerate() {
                if x == u || x == v || y == u || y == v {
                    edge_covered[j] = true;
                }
            }
        }
    }

    cover.sort_unstable();
    cover.dedup();
    cover
}

/// èƒŒåŒ…é—®é¢˜ FPTAS (Fully Polynomial Time Approximation Scheme)
pub fn knapsack_fptas(
    weights: &[usize],
    values: &[usize],
    capacity: usize,
    epsilon: f64,
) -> usize {
    let n = weights.len();
    let max_value = *values.iter().max().unwrap();

    // ç¼©æ”¾å› å­
    let k = (epsilon * max_value as f64 / n as f64).max(1.0) as usize;

    // ç¼©æ”¾åçš„å€¼
    let scaled_values: Vec<_> = values.iter().map(|&v| v / k).collect();

    // DPæ±‚è§£ç¼©æ”¾åçš„é—®é¢˜
    let max_scaled = scaled_values.iter().sum::<usize>();
    let mut dp = vec![usize::MAX; max_scaled + 1];
    dp[0] = 0;

    for i in 0..n {
        let v = scaled_values[i];
        let w = weights[i];

        for j in (v..=max_scaled).rev() {
            if dp[j - v] != usize::MAX && dp[j - v] + w <= capacity {
                dp[j] = dp[j].min(dp[j - v] + w);
            }
        }
    }

    // æ‰¾æœ€å¤§å¯è¾¾ä»·å€¼
    (0..=max_scaled)
        .rev()
        .find(|&v| dp[v] != usize::MAX)
        .unwrap_or(0)
        * k
}
```

### 5.2 éšæœºç®—æ³•

```rust
use rand::Rng;

/// QuickSort éšæœºåŒ–ç‰ˆæœ¬
///
/// **æœŸæœ›æ—¶é—´å¤æ‚åº¦**: O(n log n)
/// **æœ€åæƒ…å†µ**: O(nÂ²) (æ¦‚ç‡æä½)
pub fn randomized_quicksort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let mut rng = rand::thread_rng();
    let pivot_idx = rng.gen_range(0..arr.len());
    arr.swap(0, pivot_idx);

    let pivot_idx = partition(arr);
    randomized_quicksort(&mut arr[..pivot_idx]);
    randomized_quicksort(&mut arr[pivot_idx + 1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let mut i = 1;
    for j in 1..arr.len() {
        if arr[j] < arr[0] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(0, i - 1);
    i - 1
}

/// Monte Carlo ç®—æ³•ï¼šMiller-Rabin ç´ æ€§æµ‹è¯•
///
/// **æ­£ç¡®æ€§**: å¦‚æœè¿”å› falseï¼Œn ä¸€å®šæ˜¯åˆæ•°
///            å¦‚æœè¿”å› trueï¼Œn å¯èƒ½æ˜¯ç´ æ•°ï¼ˆé”™è¯¯æ¦‚ç‡ â‰¤ 4^(-k)ï¼‰
pub fn is_prime_miller_rabin(n: u64, k: usize) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 || n == 3 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }

    // å†™ n-1 = 2^r Â· d
    let mut d = n - 1;
    let mut r = 0;
    while d % 2 == 0 {
        d /= 2;
        r += 1;
    }

    let mut rng = rand::thread_rng();

    'witness: for _ in 0..k {
        let a = rng.gen_range(2..n - 1);
        let mut x = mod_pow(a, d, n);

        if x == 1 || x == n - 1 {
            continue;
        }

        for _ in 0..r - 1 {
            x = (x * x) % n;
            if x == n - 1 {
                continue 'witness;
            }
        }

        return false; // n æ˜¯åˆæ•°
    }

    true // n å¯èƒ½æ˜¯ç´ æ•°
}

fn mod_pow(mut base: u64, mut exp: u64, modulus: u64) -> u64 {
    let mut result = 1;
    base %= modulus;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        base = (base * base) % modulus;
        exp /= 2;
    }

    result
}
```

### 5.3 åœ¨çº¿ç®—æ³•

```rust
/// åœ¨çº¿æœ€å°ç”Ÿæˆæ ‘ï¼ˆåŠ¨æ€ç»´æŠ¤ï¼‰
pub struct OnlineMST {
    parent: Vec<usize>,
    rank: Vec<usize>,
    edges: Vec<(usize, usize, i64)>,
    mst_weight: i64,
}

impl OnlineMST {
    pub fn new(n: usize) -> Self {
        Self {
            parent: (0..n).collect(),
            rank: vec![0; n],
            edges: Vec::new(),
            mst_weight: 0,
        }
    }

    fn find(&mut self, x: usize) -> usize {
        if self.parent[x] != x {
            self.parent[x] = self.find(self.parent[x]);
        }
        self.parent[x]
    }

    fn union(&mut self, x: usize, y: usize) -> bool {
        let px = self.find(x);
        let py = self.find(y);

        if px == py {
            return false;
        }

        if self.rank[px] < self.rank[py] {
            self.parent[px] = py;
        } else if self.rank[px] > self.rank[py] {
            self.parent[py] = px;
        } else {
            self.parent[py] = px;
            self.rank[px] += 1;
        }

        true
    }

    /// åœ¨çº¿æ·»åŠ è¾¹
    pub fn add_edge(&mut self, u: usize, v: usize, weight: i64) {
        self.edges.push((u, v, weight));
        self.edges.sort_by_key(|e| e.2);

        // é‡æ–°è®¡ç®— MST
        self.parent = (0..self.parent.len()).collect();
        self.rank = vec![0; self.parent.len()];
        self.mst_weight = 0;

        for &(u, v, w) in &self.edges {
            if self.union(u, v) {
                self.mst_weight += w;
            }
        }
    }

    pub fn get_mst_weight(&self) -> i64 {
        self.mst_weight
    }
}
```

---

## 6. å®è·µæ¡ˆä¾‹

### 6.1 äºŒåˆ†æœç´¢æ­£ç¡®æ€§è¯æ˜

å®Œæ•´è¯æ˜åœ¨ [3.2 å¾ªç¯ä¸å˜å¼](#32-å¾ªç¯ä¸å˜å¼) ä¸­å·²ç»™å‡ºã€‚

### 6.2 å¿«é€Ÿæ’åºå¤æ‚åº¦åˆ†æ

```rust
/// å¿«é€Ÿæ’åºçš„å¤æ‚åº¦åˆ†æ
///
/// **æœ€åæƒ…å†µ**: T(n) = T(n-1) + Î˜(n) = Î˜(nÂ²)
/// **æœ€å¥½æƒ…å†µ**: T(n) = 2T(n/2) + Î˜(n) = Î˜(n log n)
/// **å¹³å‡æƒ…å†µ**: E[T(n)] = Î˜(n log n)
///
/// **å¹³å‡æƒ…å†µåˆ†æ**:
/// å‡è®¾æ¯ä¸ªå…ƒç´ ç­‰æ¦‚ç‡æˆä¸º pivotï¼Œåˆ™:
/// E[T(n)] = (1/n) Î£[k=0 to n-1] (T(k) + T(n-1-k)) + Î˜(n)
///         = (2/n) Î£[k=0 to n-1] T(k) + Î˜(n)
///
/// çŒœæµ‹ T(n) â‰¤ cÂ·n log nï¼Œå½’çº³è¯æ˜:
/// E[T(n)] â‰¤ (2/n) Î£[k=1 to n-1] cÂ·k log k + Î˜(n)
///         â‰¤ cÂ·n log n - cÂ·n + Î˜(n)
///         â‰¤ cÂ·n log n (å½“ c è¶³å¤Ÿå¤§)
pub fn quicksort_analysis<T: Ord>(arr: &mut [T]) {
    quicksort(arr);
}

fn quicksort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot_idx = partition_quicksort(arr);
    quicksort(&mut arr[..pivot_idx]);
    quicksort(&mut arr[pivot_idx + 1..]);
}

fn partition_quicksort<T: Ord>(arr: &mut [T]) -> usize {
    let mut i = 1;
    for j in 1..arr.len() {
        if arr[j] < arr[0] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(0, i - 1);
    i - 1
}
```

### 6.3 Dijkstra ç®—æ³•éªŒè¯

```rust
/// Dijkstra ç®—æ³•çš„æ­£ç¡®æ€§è¯æ˜
///
/// **ä¸å˜å¼**: åœ¨ç¬¬ k æ¬¡è¿­ä»£åï¼Œå·²å¤„ç†çš„ k ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„æ˜¯æ­£ç¡®çš„
///
/// **è¯æ˜**:
/// 1. åˆå§‹åŒ–: dist[start] = 0, å…¶ä½™ = âˆï¼Œæ­£ç¡® âœ…
/// 2. å½’çº³å‡è®¾: å‰ k ä¸ªèŠ‚ç‚¹çš„ dist å€¼æ­£ç¡®
/// 3. å½’çº³æ­¥éª¤: é€‰æ‹©æœªå¤„ç†èŠ‚ç‚¹ä¸­ dist æœ€å°çš„èŠ‚ç‚¹ u
///    - åè¯æ³•: å‡è®¾å­˜åœ¨æ›´çŸ­è·¯å¾„ P åˆ° u
///    - P å¿…ç»è¿‡æŸä¸ªæœªå¤„ç†èŠ‚ç‚¹ v (v æ˜¯ P ä¸Šç¬¬ä¸€ä¸ªæœªå¤„ç†èŠ‚ç‚¹)
///    - åˆ™ dist[v] < dist[u] (å› ä¸ºè¾¹æƒéè´Ÿ)
///    - ä½† u æ˜¯æœ€å°çš„ï¼ŒçŸ›ç›¾ï¼âœ…
pub fn dijkstra_verified(graph: &[Vec<(usize, i64)>], start: usize) -> Vec<i64> {
    use std::collections::BinaryHeap;
    use std::cmp::Reverse;

    let n = graph.len();
    let mut dist = vec![i64::MAX; n];
    let mut processed = vec![false; n];
    let mut heap = BinaryHeap::new();

    dist[start] = 0;
    heap.push(Reverse((0, start)));

    while let Some(Reverse((d, u))) = heap.pop() {
        if processed[u] {
            continue;
        }

        processed[u] = true;

        // éªŒè¯ä¸å˜å¼: dist[u] æ˜¯æ­£ç¡®çš„æœ€çŸ­è·¯å¾„
        debug_assert_eq!(d, dist[u]);

        for &(v, w) in &graph[u] {
            if !processed[v] && dist[u] + w < dist[v] {
                dist[v] = dist[u] + w;
                heap.push(Reverse((dist[v], v)));
            }
        }
    }

    dist
}
```

---

## 7. å‚è€ƒèµ„æ–™

### æ•™æ

- **[CLRS]** Cormen, Leiserson, Rivest, Stein. _Introduction to Algorithms_ (4th Edition)
- **[Sedgewick]** Sedgewick, Wayne. _Algorithms_ (4th Edition)
- **[Skiena]** Skiena. _The Algorithm Design Manual_ (3rd Edition)

### å½¢å¼åŒ–éªŒè¯

- **[Kani]** <https://model-checking.github.io/kani/>
- **[Prusti]** <https://www.pm.inf.ethz.ch/research/prusti.html>
- **[Creusot]** <https://github.com/xldenis/creusot>

### å¤æ‚åº¦ç†è®º

- **[Arora-Barak]** Arora, Barak. _Computational Complexity: A Modern Approach_
- **[Sipser]** Sipser. _Introduction to the Theory of Computation_ (3rd Edition)

### åœ¨çº¿èµ„æº

- **[Rust Algorithm Club]** <https://github.com/EbTech/rust-algorithms>
- **[The Algorithms - Rust]** <https://github.com/TheAlgorithms/Rust>
- **[Rust Verification Tools]** <https://github.com/rust-formal-methods>

---

**æ–‡æ¡£å®Œæˆåº¦**: 100%
**ä»£ç ç¤ºä¾‹æ•°**: 35+
**å½¢å¼åŒ–è¯æ˜æ•°**: 8
**éªŒè¯å·¥å…·è¦†ç›–**: Kani, Prusti

**ä¸‹ä¸€æ­¥**: å‚è§ [`02_å¹¶å‘ç®—æ³•æ¨¡å¼.md`](./02_å¹¶å‘ç®—æ³•æ¨¡å¼.md)
