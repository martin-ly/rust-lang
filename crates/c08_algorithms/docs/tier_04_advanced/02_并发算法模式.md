# å¹¶å‘ç®—æ³•æ¨¡å¼

> **æ–‡æ¡£ç±»å‹**: Tier 4 - é«˜çº§ä¸»é¢˜
> **æœ€åæ›´æ–°**: 2025-10-23
> **çŠ¶æ€**: âœ… å®Œæˆ

---

## ç›®å½•

- [å¹¶å‘ç®—æ³•æ¨¡å¼](#å¹¶å‘ç®—æ³•æ¨¡å¼)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“ çŸ¥è¯†ç»“æ„](#-çŸ¥è¯†ç»“æ„)
    - [æ¦‚å¿µå®šä¹‰](#æ¦‚å¿µå®šä¹‰)
    - [å±æ€§ç‰¹å¾](#å±æ€§ç‰¹å¾)
    - [å…³ç³»è¿æ¥](#å…³ç³»è¿æ¥)
    - [æ€ç»´å¯¼å›¾](#æ€ç»´å¯¼å›¾)
    - [å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ](#å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ)
    - [å†³ç­–æ ‘å›¾](#å†³ç­–æ ‘å›¾)
  - [1. å¹¶å‘è®¡ç®—æ¨¡å‹](#1-å¹¶å‘è®¡ç®—æ¨¡å‹)
    - [1.1 Actor æ¨¡å‹](#11-actor-æ¨¡å‹)
    - [1.2 CSP (Communicating Sequential Processes)](#12-csp-communicating-sequential-processes)
    - [1.3 Reactor æ¨¡å¼](#13-reactor-æ¨¡å¼)
  - [2. æ— é”æ•°æ®ç»“æ„](#2-æ— é”æ•°æ®ç»“æ„)
    - [2.1 æ— é”é˜Ÿåˆ—](#21-æ— é”é˜Ÿåˆ—)
    - [2.2 æ— é”æ ˆ](#22-æ— é”æ ˆ)
    - [2.3 CAS æ“ä½œä¸ ABA é—®é¢˜](#23-cas-æ“ä½œä¸-aba-é—®é¢˜)
  - [3. å¹¶å‘ç®—æ³•è®¾è®¡](#3-å¹¶å‘ç®—æ³•è®¾è®¡)
    - [3.1 æ•°æ®å¹¶è¡Œ](#31-æ•°æ®å¹¶è¡Œ)
    - [3.2 ä»»åŠ¡å¹¶è¡Œ](#32-ä»»åŠ¡å¹¶è¡Œ)
    - [3.3 æµæ°´çº¿å¹¶è¡Œ](#33-æµæ°´çº¿å¹¶è¡Œ)
  - [4. åŒæ­¥åŸè¯­](#4-åŒæ­¥åŸè¯­)
    - [4.1 å±éšœ (Barrier)](#41-å±éšœ-barrier)
    - [4.2 ä¿¡å·é‡ (Semaphore)](#42-ä¿¡å·é‡-semaphore)
    - [4.3 è¯»å†™é” (RwLock)](#43-è¯»å†™é”-rwlock)
  - [5. å¹¶å‘ç®—æ³•åˆ†æ](#5-å¹¶å‘ç®—æ³•åˆ†æ)
    - [5.1 åŠ é€Ÿæ¯”ä¸æ•ˆç‡](#51-åŠ é€Ÿæ¯”ä¸æ•ˆç‡)
    - [5.2 å·¥ä½œæ·±åº¦æ¨¡å‹](#52-å·¥ä½œæ·±åº¦æ¨¡å‹)
    - [5.3 è´Ÿè½½å‡è¡¡](#53-è´Ÿè½½å‡è¡¡)
  - [6. å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 å¹¶å‘å½’å¹¶æ’åº](#61-å¹¶å‘å½’å¹¶æ’åº)
    - [6.2 å¹¶å‘å›¾ç®—æ³•](#62-å¹¶å‘å›¾ç®—æ³•)
    - [6.3 å¹¶å‘å“ˆå¸Œè¡¨](#63-å¹¶å‘å“ˆå¸Œè¡¨)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)
    - [æ•™æ](#æ•™æ)
    - [Rust å¹¶å‘åº“](#rust-å¹¶å‘åº“)
    - [å½¢å¼åŒ–éªŒè¯](#å½¢å¼åŒ–éªŒè¯)

---

## ğŸ“ çŸ¥è¯†ç»“æ„

### æ¦‚å¿µå®šä¹‰

**å¹¶å‘ç®—æ³•æ¨¡å¼ (Concurrent Algorithm Patterns)**:

- **å®šä¹‰**: Rust 1.92.0 å¹¶å‘ç®—æ³•æ¨¡å¼ï¼ŒåŒ…æ‹¬å¹¶å‘è®¡ç®—æ¨¡å‹ã€æ— é”æ•°æ®ç»“æ„ã€å¹¶å‘ç®—æ³•è®¾è®¡ã€åŒæ­¥åŸè¯­ã€å¹¶å‘ç®—æ³•åˆ†æã€å®è·µæ¡ˆä¾‹ç­‰
- **ç±»å‹**: é«˜çº§ä¸»é¢˜æ–‡æ¡£
- **èŒƒç•´**: ç®—æ³•ã€å¹¶å‘ç¼–ç¨‹
- **ç‰ˆæœ¬**: Rust 1.92.0+ (Edition 2024)
- **ç›¸å…³æ¦‚å¿µ**: Actor æ¨¡å‹ã€CSPã€Reactor æ¨¡å¼ã€æ— é”æ•°æ®ç»“æ„ã€æ•°æ®å¹¶è¡Œã€ä»»åŠ¡å¹¶è¡Œã€æµæ°´çº¿å¹¶è¡Œ

### å±æ€§ç‰¹å¾

**æ ¸å¿ƒå±æ€§**:

- **å¹¶å‘è®¡ç®—æ¨¡å‹**: Actor æ¨¡å‹ã€CSP (Communicating Sequential Processes)ã€Reactor æ¨¡å¼
- **æ— é”æ•°æ®ç»“æ„**: æ— é”é˜Ÿåˆ—ã€æ— é”æ ˆã€CAS æ“ä½œä¸ ABA é—®é¢˜
- **å¹¶å‘ç®—æ³•è®¾è®¡**: æ•°æ®å¹¶è¡Œã€ä»»åŠ¡å¹¶è¡Œã€æµæ°´çº¿å¹¶è¡Œ
- **åŒæ­¥åŸè¯­**: å±éšœ (Barrier)ã€ä¿¡å·é‡ (Semaphore)ã€è¯»å†™é” (RwLock)
- **å¹¶å‘ç®—æ³•åˆ†æ**: åŠ é€Ÿæ¯”ä¸æ•ˆç‡ã€å·¥ä½œæ·±åº¦æ¨¡å‹ã€è´Ÿè½½å‡è¡¡

**Rust 1.92.0 æ–°ç‰¹æ€§**:

- **æ”¹è¿›çš„å¹¶å‘åŸè¯­**: æ›´é«˜æ•ˆçš„å¹¶å‘åŸè¯­
- **å¢å¼ºçš„æ— é”æ•°æ®ç»“æ„**: æ›´å¥½çš„æ— é”ç¼–ç¨‹æ”¯æŒ
- **ä¼˜åŒ–çš„å¹¶å‘ç®—æ³•**: æ›´é«˜æ•ˆçš„å¹¶å‘ç®—æ³•

**æ€§èƒ½ç‰¹å¾**:

- **é«˜å¹¶å‘**: æ”¯æŒå¤§è§„æ¨¡å¹¶å‘
- **é«˜æ€§èƒ½**: é«˜æ•ˆçš„å¹¶å‘ç®—æ³•
- **é€‚ç”¨åœºæ™¯**: å¹¶è¡Œè®¡ç®—ã€é«˜æ€§èƒ½è®¡ç®—ã€åˆ†å¸ƒå¼ç³»ç»Ÿ

### å…³ç³»è¿æ¥

**ç»„åˆå…³ç³»**:

- å¹¶å‘ç®—æ³•æ¨¡å¼ --[covers]--> å¹¶å‘ç®—æ³•å®Œæ•´å†…å®¹
- å¹¶è¡Œç¨‹åº --[uses]--> å¹¶å‘ç®—æ³•æ¨¡å¼

**ä¾èµ–å…³ç³»**:

- å¹¶å‘ç®—æ³•æ¨¡å¼ --[depends-on]--> å¹¶å‘åŸè¯­
- å¹¶è¡Œè®¡ç®— --[depends-on]--> å¹¶å‘ç®—æ³•æ¨¡å¼

### æ€ç»´å¯¼å›¾

```text
å¹¶å‘ç®—æ³•æ¨¡å¼
â”‚
â”œâ”€â”€ å¹¶å‘è®¡ç®—æ¨¡å‹
â”‚   â”œâ”€â”€ Actor æ¨¡å‹
â”‚   â”œâ”€â”€ CSP
â”‚   â””â”€â”€ Reactor æ¨¡å¼
â”œâ”€â”€ æ— é”æ•°æ®ç»“æ„
â”‚   â”œâ”€â”€ æ— é”é˜Ÿåˆ—
â”‚   â””â”€â”€ æ— é”æ ˆ
â”œâ”€â”€ å¹¶å‘ç®—æ³•è®¾è®¡
â”‚   â”œâ”€â”€ æ•°æ®å¹¶è¡Œ
â”‚   â””â”€â”€ ä»»åŠ¡å¹¶è¡Œ
â”œâ”€â”€ åŒæ­¥åŸè¯­
â”‚   â”œâ”€â”€ å±éšœ
â”‚   â””â”€â”€ ä¿¡å·é‡
â””â”€â”€ å¹¶å‘ç®—æ³•åˆ†æ
    â””â”€â”€ åŠ é€Ÿæ¯”ä¸æ•ˆç‡
```

### å¤šç»´æ¦‚å¿µå¯¹æ¯”çŸ©é˜µ

| å¹¶å‘æ¨¡å¼ | æ€§èƒ½ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ç±»å‹å®‰å…¨ | Rust 1.92.0 |
| --- | --- | --- | --- | --- | --- |
| **Actor æ¨¡å‹** | ä¸­ | é«˜ | åˆ†å¸ƒå¼ç³»ç»Ÿ | âœ… | âœ… |
| **CSP** | ä¸­ | ä½ | é€šé“é€šä¿¡ | âœ… | âœ… |
| **Reactor æ¨¡å¼** | é«˜ | ä¸­ | é«˜å¹¶å‘ I/O | âœ… | âœ… |
| **æ— é”æ•°æ®ç»“æ„** | æœ€é«˜ | é«˜ | é«˜å¹¶å‘ | âœ… | âœ… |
| **æ•°æ®å¹¶è¡Œ** | é«˜ | ä¸­ | æ•°æ®å¯†é›†å‹ | âœ… | âœ… |
| **ä»»åŠ¡å¹¶è¡Œ** | é«˜ | ä¸­ | ä»»åŠ¡å¯†é›†å‹ | âœ… | âœ… |

### å†³ç­–æ ‘å›¾

```text
é€‰æ‹©å¹¶å‘ç®—æ³•æ¨¡å¼
â”‚
â”œâ”€â”€ æ˜¯å¦éœ€è¦æ¶ˆæ¯ä¼ é€’ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ Actor æ¨¡å‹ / CSP
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­åˆ¤æ–­
â”‚       â”œâ”€â”€ æ˜¯å¦éœ€è¦é«˜å¹¶å‘ I/Oï¼Ÿ
â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ Reactor æ¨¡å¼
â”‚       â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­åˆ¤æ–­
â”‚       â”‚       â”œâ”€â”€ æ˜¯å¦éœ€è¦æè‡´æ€§èƒ½ï¼Ÿ
â”‚       â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ æ— é”æ•°æ®ç»“æ„
â”‚       â”‚       â”‚   â””â”€â”€ å¦ â†’ æ•°æ®å¹¶è¡Œ / ä»»åŠ¡å¹¶è¡Œ
```

---

## 1. å¹¶å‘è®¡ç®—æ¨¡å‹

### 1.1 Actor æ¨¡å‹

**æ ¸å¿ƒæ€æƒ³**: æ¯ä¸ª Actor æ˜¯ç‹¬ç«‹çš„è®¡ç®—å•å…ƒï¼Œé€šè¿‡æ¶ˆæ¯ä¼ é€’é€šä¿¡ã€‚

```rust
use tokio::sync::mpsc;
use tokio::task;

/// Actor ç‰¹å¾
#[async_trait::async_trait]
pub trait Actor: Send + 'static {
    type Message: Send;

    async fn handle(&mut self, msg: Self::Message);
}

/// Actor ç³»ç»Ÿ
pub struct ActorSystem<A: Actor> {
    sender: mpsc::Sender<A::Message>,
}

impl<A: Actor> ActorSystem<A> {
    /// åˆ›å»º Actor ç³»ç»Ÿ
    pub fn spawn(mut actor: A) -> Self {
        let (tx, mut rx) = mpsc::channel(100);

        task::spawn(async move {
            while let Some(msg) = rx.recv().await {
                actor.handle(msg).await;
            }
        });

        Self { sender: tx }
    }

    /// å‘é€æ¶ˆæ¯
    pub async fn send(&self, msg: A::Message) -> Result<(), mpsc::error::SendError<A::Message>> {
        self.sender.send(msg).await
    }
}

/// ç¤ºä¾‹ï¼šè®¡æ•°å™¨ Actor
pub struct Counter {
    count: i32,
}

pub enum CounterMsg {
    Increment,
    Decrement,
    Get(tokio::sync::oneshot::Sender<i32>),
}

#[async_trait::async_trait]
impl Actor for Counter {
    type Message = CounterMsg;

    async fn handle(&mut self, msg: Self::Message) {
        match msg {
            CounterMsg::Increment => self.count += 1,
            CounterMsg::Decrement => self.count -= 1,
            CounterMsg::Get(reply) => {
                let _ = reply.send(self.count);
            }
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub async fn actor_example() {
    let counter = Counter { count: 0 };
    let system = ActorSystem::spawn(counter);

    // å¹¶å‘å‘é€æ¶ˆæ¯
    for _ in 0..100 {
        let sys = system.clone();
        task::spawn(async move {
            let _ = sys.send(CounterMsg::Increment).await;
        });
    }

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let (tx, rx) = tokio::sync::oneshot::channel();
    system.send(CounterMsg::Get(tx)).await.unwrap();
    let count = rx.await.unwrap();
    println!("æœ€ç»ˆè®¡æ•°: {}", count);
}
```

### 1.2 CSP (Communicating Sequential Processes)

**æ ¸å¿ƒæ€æƒ³**: é€šè¿‡ channel è¿›è¡ŒåŒæ­¥é€šä¿¡ã€‚

```rust
use std::sync::mpsc;
use std::thread;

/// CSP é£æ ¼çš„å¹¶å‘ç´ æ•°ç­›
pub fn prime_sieve_csp(n: usize) -> Vec<usize> {
    let (mut sender, mut receiver) = mpsc::channel();

    // ç”Ÿæˆå™¨ï¼šå‘é€ 2..n
    thread::spawn(move || {
        for i in 2..=n {
            if sender.send(i).is_err() {
                break;
            }
        }
    });

    let mut primes = Vec::new();

    while let Ok(prime) = receiver.recv() {
        primes.push(prime);

        // åˆ›å»ºæ–°çš„ç­›é€‰å™¨
        let (new_sender, new_receiver) = mpsc::channel();

        thread::spawn(move || {
            while let Ok(num) = receiver.recv() {
                if num % prime != 0 {
                    if new_sender.send(num).is_err() {
                        break;
                    }
                }
            }
        });

        receiver = new_receiver;
    }

    primes
}

/// CSP é£æ ¼çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…
pub fn producer_consumer_csp() {
    let (tx, rx) = mpsc::sync_channel(10); // æœ‰ç•Œ channel

    // ç”Ÿäº§è€…
    let producer = thread::spawn(move || {
        for i in 0..100 {
            tx.send(i).unwrap();
            println!("ç”Ÿäº§: {}", i);
        }
    });

    // æ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        while let Ok(item) = rx.recv() {
            println!("æ¶ˆè´¹: {}", item);
            thread::sleep(std::time::Duration::from_millis(10));
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 1.3 Reactor æ¨¡å¼

**æ ¸å¿ƒæ€æƒ³**: äº‹ä»¶é©±åŠ¨çš„å¼‚æ­¥ I/O å¤„ç†ã€‚

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};

/// Reactor æ¨¡å¼ç¤ºä¾‹ï¼šEcho æœåŠ¡å™¨
pub async fn reactor_echo_server(addr: &str) -> std::io::Result<()> {
    let listener = TcpListener::bind(addr).await?;
    println!("æœåŠ¡å™¨ç›‘å¬: {}", addr);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!("æ–°è¿æ¥: {}", addr);

        // ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        tokio::spawn(async move {
            handle_client(socket).await;
        });
    }
}

async fn handle_client(mut socket: TcpStream) {
    let mut buf = vec![0u8; 1024];

    loop {
        match socket.read(&mut buf).await {
            Ok(0) => break, // è¿æ¥å…³é—­
            Ok(n) => {
                if socket.write_all(&buf[..n]).await.is_err() {
                    break;
                }
            }
            Err(_) => break,
        }
    }
}

/// Reactor æ¨¡å¼ï¼šå¤šè·¯å¤ç”¨ HTTP è¯·æ±‚
pub async fn reactor_http_requests(urls: Vec<String>) -> Vec<String> {
    use tokio::time::{timeout, Duration};

    let tasks: Vec<_> = urls
        .into_iter()
        .map(|url| {
            tokio::spawn(async move {
                let client = reqwest::Client::new();
                match timeout(Duration::from_secs(5), client.get(&url).send()).await {
                    Ok(Ok(response)) => response.text().await.unwrap_or_default(),
                    _ => String::from("è¯·æ±‚å¤±è´¥"),
                }
            })
        })
        .collect();

    let results = futures::future::join_all(tasks).await;
    results.into_iter().map(|r| r.unwrap_or_default()).collect()
}
```

---

## 2. æ— é”æ•°æ®ç»“æ„

### 2.1 æ— é”é˜Ÿåˆ—

```rust
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};
use std::ptr;

/// Michael-Scott æ— é”é˜Ÿåˆ—
pub struct LockFreeQueue<T> {
    head: AtomicPtr<Node<T>>,
    tail: AtomicPtr<Node<T>>,
    size: AtomicUsize,
}

struct Node<T> {
    data: Option<T>,
    next: AtomicPtr<Node<T>>,
}

impl<T> LockFreeQueue<T> {
    pub fn new() -> Self {
        let dummy = Box::into_raw(Box::new(Node {
            data: None,
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        Self {
            head: AtomicPtr::new(dummy),
            tail: AtomicPtr::new(dummy),
            size: AtomicUsize::new(0),
        }
    }

    /// å…¥é˜Ÿï¼ˆæ— é”ï¼‰
    pub fn enqueue(&self, value: T) {
        let node = Box::into_raw(Box::new(Node {
            data: Some(value),
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        loop {
            let tail = self.tail.load(Ordering::Acquire);
            let next = unsafe { (*tail).next.load(Ordering::Acquire) };

            if tail == self.tail.load(Ordering::Acquire) {
                if next.is_null() {
                    // å°è¯•é“¾æ¥æ–°èŠ‚ç‚¹
                    if unsafe {
                        (*tail).next.compare_exchange(
                            next,
                            node,
                            Ordering::Release,
                            Ordering::Relaxed,
                        ).is_ok()
                    } {
                        // æˆåŠŸï¼Œæ›´æ–° tail
                        let _ = self.tail.compare_exchange(
                            tail,
                            node,
                            Ordering::Release,
                            Ordering::Relaxed,
                        );
                        self.size.fetch_add(1, Ordering::Relaxed);
                        return;
                    }
                } else {
                    // å¸®åŠ©å…¶ä»–çº¿ç¨‹æ›´æ–° tail
                    let _ = self.tail.compare_exchange(
                        tail,
                        next,
                        Ordering::Release,
                        Ordering::Relaxed,
                    );
                }
            }
        }
    }

    /// å‡ºé˜Ÿï¼ˆæ— é”ï¼‰
    pub fn dequeue(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            let tail = self.tail.load(Ordering::Acquire);
            let next = unsafe { (*head).next.load(Ordering::Acquire) };

            if head == self.head.load(Ordering::Acquire) {
                if head == tail {
                    if next.is_null() {
                        return None; // é˜Ÿåˆ—ä¸ºç©º
                    }
                    // å¸®åŠ©æ›´æ–° tail
                    let _ = self.tail.compare_exchange(
                        tail,
                        next,
                        Ordering::Release,
                        Ordering::Relaxed,
                    );
                } else {
                    // è¯»å–æ•°æ®
                    let data = unsafe { (*next).data.take() };

                    // å°è¯•æ›´æ–° head
                    if self.head.compare_exchange(
                        head,
                        next,
                        Ordering::Release,
                        Ordering::Relaxed,
                    ).is_ok() {
                        self.size.fetch_sub(1, Ordering::Relaxed);
                        // é‡Šæ”¾æ—§ headï¼ˆdummy èŠ‚ç‚¹ï¼‰
                        unsafe { Box::from_raw(head) };
                        return data;
                    }
                }
            }
        }
    }

    pub fn len(&self) -> usize {
        self.size.load(Ordering::Relaxed)
    }
}

impl<T> Drop for LockFreeQueue<T> {
    fn drop(&mut self) {
        while self.dequeue().is_some() {}
        unsafe {
            Box::from_raw(self.head.load(Ordering::Relaxed));
        }
    }
}
```

### 2.2 æ— é”æ ˆ

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

/// Treiber æ— é”æ ˆ
pub struct LockFreeStack<T> {
    head: AtomicPtr<StackNode<T>>,
}

struct StackNode<T> {
    data: T,
    next: *mut StackNode<T>,
}

impl<T> LockFreeStack<T> {
    pub fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    /// å…¥æ ˆï¼ˆæ— é”ï¼‰
    pub fn push(&self, value: T) {
        let node = Box::into_raw(Box::new(StackNode {
            data: value,
            next: ptr::null_mut(),
        }));

        loop {
            let old_head = self.head.load(Ordering::Relaxed);
            unsafe { (*node).next = old_head };

            if self.head.compare_exchange(
                old_head,
                node,
                Ordering::Release,
                Ordering::Relaxed,
            ).is_ok() {
                return;
            }
        }
    }

    /// å‡ºæ ˆï¼ˆæ— é”ï¼‰
    pub fn pop(&self) -> Option<T> {
        loop {
            let old_head = self.head.load(Ordering::Acquire);

            if old_head.is_null() {
                return None;
            }

            let next = unsafe { (*old_head).next };

            if self.head.compare_exchange(
                old_head,
                next,
                Ordering::Release,
                Ordering::Relaxed,
            ).is_ok() {
                let node = unsafe { Box::from_raw(old_head) };
                return Some(node.data);
            }
        }
    }
}

impl<T> Drop for LockFreeStack<T> {
    fn drop(&mut self) {
        while self.pop().is_some() {}
    }
}
```

### 2.3 CAS æ“ä½œä¸ ABA é—®é¢˜

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

/// ABA é—®é¢˜æ¼”ç¤º
pub fn aba_problem_demo() {
    let shared = AtomicUsize::new(100);

    // çº¿ç¨‹ 1: è¯»å– A
    let a = shared.load(Ordering::Relaxed);
    assert_eq!(a, 100);

    // çº¿ç¨‹ 2: A -> B -> A
    shared.store(200, Ordering::Relaxed);
    shared.store(100, Ordering::Relaxed);

    // çº¿ç¨‹ 1: CAS æˆåŠŸï¼Œä½†ä¸­é—´çŠ¶æ€è¢«æ”¹å˜
    let success = shared.compare_exchange(
        a,
        300,
        Ordering::Release,
        Ordering::Relaxed,
    ).is_ok();

    assert!(success); // CAS æˆåŠŸï¼Œä½†æ²¡æœ‰æ£€æµ‹åˆ°ä¸­é—´å˜åŒ–
    println!("ABA é—®é¢˜ï¼šCAS æˆåŠŸä½†çŠ¶æ€å·²æ”¹å˜");
}

/// è§£å†³ ABA é—®é¢˜ï¼šç‰ˆæœ¬å·æ ‡è®°
pub struct VersionedPointer<T> {
    ptr: AtomicUsize, // é«˜ä½ï¼šç‰ˆæœ¬å·ï¼Œä½ä½ï¼šæŒ‡é’ˆ
}

impl<T> VersionedPointer<T> {
    const VERSION_BITS: usize = 16;
    const PTR_MASK: usize = (1 << (usize::BITS - Self::VERSION_BITS as u32)) - 1;
    const VERSION_MASK: usize = !Self::PTR_MASK;

    pub fn new(ptr: *mut T) -> Self {
        Self {
            ptr: AtomicUsize::new(ptr as usize),
        }
    }

    pub fn load(&self) -> (*mut T, usize) {
        let val = self.ptr.load(Ordering::Acquire);
        let ptr = (val & Self::PTR_MASK) as *mut T;
        let version = (val & Self::VERSION_MASK) >> (usize::BITS as usize - Self::VERSION_BITS);
        (ptr, version)
    }

    pub fn compare_exchange(
        &self,
        old_ptr: *mut T,
        old_version: usize,
        new_ptr: *mut T,
        new_version: usize,
    ) -> Result<(*mut T, usize), (*mut T, usize)> {
        let old_val = (old_ptr as usize & Self::PTR_MASK)
            | ((old_version << (usize::BITS as usize - Self::VERSION_BITS)) & Self::VERSION_MASK);
        let new_val = (new_ptr as usize & Self::PTR_MASK)
            | ((new_version << (usize::BITS as usize - Self::VERSION_BITS)) & Self::VERSION_MASK);

        self.ptr.compare_exchange(
            old_val,
            new_val,
            Ordering::Release,
            Ordering::Acquire,
        ).map(|_| self.load())
        .map_err(|_| self.load())
    }
}
```

---

## 3. å¹¶å‘ç®—æ³•è®¾è®¡

### 3.1 æ•°æ®å¹¶è¡Œ

```rust
use rayon::prelude::*;

/// å¹¶å‘çŸ©é˜µä¹˜æ³•ï¼ˆæ•°æ®å¹¶è¡Œï¼‰
pub fn parallel_matrix_multiply(
    a: &[Vec<f64>],
    b: &[Vec<f64>],
) -> Vec<Vec<f64>> {
    let n = a.len();
    let m = b[0].len();
    let k = b.len();

    // è½¬ç½® B ä»¥æé«˜ç¼“å­˜å±€éƒ¨æ€§
    let b_t: Vec<Vec<f64>> = (0..m)
        .map(|j| (0..k).map(|i| b[i][j]).collect())
        .collect();

    // å¹¶è¡Œè®¡ç®—æ¯ä¸€è¡Œ
    a.par_iter()
        .map(|row| {
            b_t.iter()
                .map(|col| {
                    row.iter().zip(col.iter()).map(|(x, y)| x * y).sum()
                })
                .collect()
        })
        .collect()
}

/// å¹¶å‘å½’çº¦ï¼ˆæ•°æ®å¹¶è¡Œï¼‰
pub fn parallel_reduce<T, F>(arr: &[T], init: T, op: F) -> T
where
    T: Send + Sync + Clone,
    F: Fn(T, T) -> T + Send + Sync,
{
    arr.par_iter()
        .cloned()
        .reduce(|| init.clone(), |a, b| op(a, b))
}

/// ç¤ºä¾‹ï¼šå¹¶å‘æ±‚å’Œ
pub fn parallel_sum(arr: &[i64]) -> i64 {
    parallel_reduce(arr, 0, |a, b| a + b)
}
```

### 3.2 ä»»åŠ¡å¹¶è¡Œ

```rust
use std::thread;

/// ä»»åŠ¡å¹¶è¡Œï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—
pub fn fibonacci_task_parallel(n: u32) -> u64 {
    if n <= 1 {
        return n as u64;
    }

    if n < 30 {
        // å°é—®é¢˜ç›´æ¥è®¡ç®—
        return fibonacci_sequential(n);
    }

    // å¹¶è¡Œè®¡ç®— fib(n-1) å’Œ fib(n-2)
    let handle = thread::spawn(move || fibonacci_task_parallel(n - 1));
    let right = fibonacci_task_parallel(n - 2);
    let left = handle.join().unwrap();

    left + right
}

fn fibonacci_sequential(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        n => fibonacci_sequential(n - 1) + fibonacci_sequential(n - 2),
    }
}

/// ä»»åŠ¡å¹¶è¡Œï¼šå¿«é€Ÿæ’åº
pub fn quicksort_task_parallel<T: Ord + Send>(arr: &mut [T], threshold: usize) {
    if arr.len() <= threshold {
        arr.sort_unstable();
        return;
    }

    let pivot_idx = partition_qs(arr);

    let (left, right) = arr.split_at_mut(pivot_idx);

    thread::scope(|s| {
        s.spawn(|| quicksort_task_parallel(left, threshold));
        s.spawn(|| quicksort_task_parallel(&mut right[1..], threshold));
    });
}

fn partition_qs<T: Ord>(arr: &mut [T]) -> usize {
    let mut i = 1;
    for j in 1..arr.len() {
        if arr[j] < arr[0] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(0, i - 1);
    i - 1
}
```

### 3.3 æµæ°´çº¿å¹¶è¡Œ

```rust
use std::sync::mpsc;
use std::thread;

/// æµæ°´çº¿å¹¶è¡Œï¼šå›¾åƒå¤„ç†
pub fn pipeline_image_processing(images: Vec<Vec<u8>>) -> Vec<Vec<u8>> {
    let (tx1, rx1) = mpsc::channel();
    let (tx2, rx2) = mpsc::channel();
    let (tx3, rx3) = mpsc::channel();

    // é˜¶æ®µ 1: ç°åº¦åŒ–
    let stage1 = thread::spawn(move || {
        while let Ok(img) = rx1.recv() {
            let gray = to_grayscale(img);
            if tx2.send(gray).is_err() {
                break;
            }
        }
    });

    // é˜¶æ®µ 2: æ¨¡ç³Š
    let stage2 = thread::spawn(move || {
        while let Ok(img) = rx2.recv() {
            let blurred = blur(img);
            if tx3.send(blurred).is_err() {
                break;
            }
        }
    });

    // é˜¶æ®µ 3: è¾¹ç¼˜æ£€æµ‹
    let stage3 = thread::spawn(move || {
        let mut results = Vec::new();
        while let Ok(img) = rx3.recv() {
            let edges = edge_detection(img);
            results.push(edges);
        }
        results
    });

    // è¾“å…¥æ•°æ®
    for img in images {
        tx1.send(img).unwrap();
    }
    drop(tx1);

    stage1.join().unwrap();
    stage2.join().unwrap();
    stage3.join().unwrap()
}

fn to_grayscale(img: Vec<u8>) -> Vec<u8> {
    img // ç®€åŒ–å®ç°
}

fn blur(img: Vec<u8>) -> Vec<u8> {
    img // ç®€åŒ–å®ç°
}

fn edge_detection(img: Vec<u8>) -> Vec<u8> {
    img // ç®€åŒ–å®ç°
}
```

---

## 4. åŒæ­¥åŸè¯­

### 4.1 å±éšœ (Barrier)

```rust
use std::sync::{Arc, Barrier};
use std::thread;

/// å¹¶å‘å±éšœç¤ºä¾‹ï¼šçŸ©é˜µè¿­ä»£è®¡ç®—
pub fn matrix_iteration_with_barrier(matrix: Vec<Vec<f64>>, iterations: usize) -> Vec<Vec<f64>> {
    let n = matrix.len();
    let m = matrix[0].len();

    let shared_matrix = Arc::new(std::sync::RwLock::new(matrix));
    let barrier = Arc::new(Barrier::new(4)); // 4 ä¸ªå·¥ä½œçº¿ç¨‹

    let handles: Vec<_> = (0..4)
        .map(|id| {
            let matrix = Arc::clone(&shared_matrix);
            let barrier = Arc::clone(&barrier);

            thread::spawn(move || {
                for _ in 0..iterations {
                    // æ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸€éƒ¨åˆ†è¡Œ
                    let start = id * n / 4;
                    let end = (id + 1) * n / 4;

                    {
                        let mut mat = matrix.write().unwrap();
                        for i in start..end {
                            for j in 1..m - 1 {
                                mat[i][j] = (mat[i][j - 1] + mat[i][j + 1]) / 2.0;
                            }
                        }
                    }

                    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆæœ¬è½®è¿­ä»£
                    barrier.wait();
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    Arc::try_unwrap(shared_matrix).unwrap().into_inner().unwrap()
}
```

### 4.2 ä¿¡å·é‡ (Semaphore)

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

/// å¹¶å‘é™æµï¼šé™åˆ¶å¹¶å‘æ•°
pub async fn rate_limited_tasks(tasks: Vec<String>, max_concurrent: usize) {
    let semaphore = Arc::new(Semaphore::new(max_concurrent));

    let handles: Vec<_> = tasks
        .into_iter()
        .map(|task| {
            let sem = Arc::clone(&semaphore);
            tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                // æ‰§è¡Œä»»åŠ¡
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                println!("å®Œæˆä»»åŠ¡: {}", task);
            })
        })
        .collect();

    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 4.3 è¯»å†™é” (RwLock)

```rust
use std::sync::{Arc, RwLock};
use std::thread;

/// å¹¶å‘è¯»å†™é”ï¼šå…±äº«è®¡æ•°å™¨
pub fn concurrent_counter() -> i32 {
    let counter = Arc::new(RwLock::new(0));

    let mut handles = vec![];

    // 10 ä¸ªè¯»çº¿ç¨‹
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        handles.push(thread::spawn(move || {
            let val = counter.read().unwrap();
            println!("è¯»å–: {}", *val);
        }));
    }

    // 2 ä¸ªå†™çº¿ç¨‹
    for _ in 0..2 {
        let counter = Arc::clone(&counter);
        handles.push(thread::spawn(move || {
            let mut val = counter.write().unwrap();
            *val += 1;
            println!("å†™å…¥: {}", *val);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }

    *counter.read().unwrap()
}
```

---

## 5. å¹¶å‘ç®—æ³•åˆ†æ

### 5.1 åŠ é€Ÿæ¯”ä¸æ•ˆç‡

```rust
use std::time::Instant;

/// æµ‹é‡åŠ é€Ÿæ¯”
pub fn measure_speedup<F1, F2>(sequential: F1, parallel: F2) -> f64
where
    F1: Fn(),
    F2: Fn(),
{
    let start = Instant::now();
    sequential();
    let t_seq = start.elapsed().as_secs_f64();

    let start = Instant::now();
    parallel();
    let t_par = start.elapsed().as_secs_f64();

    let speedup = t_seq / t_par;
    let num_threads = num_cpus::get();
    let efficiency = speedup / num_threads as f64;

    println!("é¡ºåºæ—¶é—´: {:.3}s", t_seq);
    println!("å¹¶è¡Œæ—¶é—´: {:.3}s", t_par);
    println!("åŠ é€Ÿæ¯”: {:.2}x", speedup);
    println!("æ•ˆç‡: {:.2}%", efficiency * 100.0);

    speedup
}

/// Amdahl å®šå¾‹
/// S(p) = 1 / (f + (1-f)/p)
/// å…¶ä¸­ f æ˜¯ä¸²è¡Œéƒ¨åˆ†æ¯”ä¾‹ï¼Œp æ˜¯å¤„ç†å™¨æ•°é‡
pub fn amdahl_law(serial_fraction: f64, num_processors: usize) -> f64 {
    1.0 / (serial_fraction + (1.0 - serial_fraction) / num_processors as f64)
}

/// Gustafson å®šå¾‹
/// S(p) = p - Î±(p-1)
/// å…¶ä¸­ Î± æ˜¯ä¸²è¡Œéƒ¨åˆ†æ¯”ä¾‹ï¼Œp æ˜¯å¤„ç†å™¨æ•°é‡
pub fn gustafson_law(serial_fraction: f64, num_processors: usize) -> f64 {
    num_processors as f64 - serial_fraction * (num_processors as f64 - 1.0)
}
```

### 5.2 å·¥ä½œæ·±åº¦æ¨¡å‹

```rust
/// å·¥ä½œæ·±åº¦åˆ†æ
pub struct WorkDepthAnalysis {
    work: usize,   // æ€»æ“ä½œæ•°
    depth: usize,  // å…³é”®è·¯å¾„é•¿åº¦
}

impl WorkDepthAnalysis {
    /// è®¡ç®—å¹¶è¡Œåº¦
    pub fn parallelism(&self) -> f64 {
        self.work as f64 / self.depth as f64
    }

    /// è®¡ç®—ç†è®ºåŠ é€Ÿæ¯”ï¼ˆp ä¸ªå¤„ç†å™¨ï¼‰
    pub fn speedup(&self, num_processors: usize) -> f64 {
        let t_sequential = self.work as f64;
        let t_parallel = (self.work as f64 / num_processors as f64).max(self.depth as f64);
        t_sequential / t_parallel
    }
}

/// å½’å¹¶æ’åºçš„å·¥ä½œæ·±åº¦åˆ†æ
/// Work: W(n) = O(n log n)
/// Depth: D(n) = O(logÂ² n)
/// Parallelism: P(n) = O(n log n / logÂ² n) = O(n / log n)
pub fn merge_sort_work_depth(n: usize) -> WorkDepthAnalysis {
    let work = n * (n as f64).log2().ceil() as usize;
    let depth = ((n as f64).log2().ceil() as usize).pow(2);

    WorkDepthAnalysis { work, depth }
}
```

### 5.3 è´Ÿè½½å‡è¡¡

```rust
use rayon::prelude::*;

/// åŠ¨æ€è´Ÿè½½å‡è¡¡ï¼šå·¥ä½œçªƒå–
pub fn work_stealing_example(tasks: Vec<usize>) -> Vec<usize> {
    tasks
        .par_iter()
        .map(|&task_size| {
            // æ¨¡æ‹Ÿä¸å‡åŒ€çš„å·¥ä½œè´Ÿè½½
            let work = (0..task_size).map(|i| i * i).sum();
            work
        })
        .collect()
}

/// é™æ€è´Ÿè½½å‡è¡¡ï¼šå—åˆ†é…
pub fn static_block_scheduling<T, F>(data: &[T], num_threads: usize, f: F) -> Vec<T>
where
    T: Clone + Send + Sync,
    F: Fn(&T) -> T + Send + Sync,
{
    let chunk_size = (data.len() + num_threads - 1) / num_threads;

    data.par_chunks(chunk_size)
        .flat_map(|chunk| chunk.iter().map(&f).collect::<Vec<_>>())
        .collect()
}

/// åŠ¨æ€è´Ÿè½½å‡è¡¡ï¼šä»»åŠ¡é˜Ÿåˆ—
pub fn dynamic_task_queue(tasks: Vec<Box<dyn Fn() -> i32 + Send>>) -> Vec<i32> {
    use std::sync::{Arc, Mutex};
    use std::thread;

    let tasks = Arc::new(Mutex::new(tasks));
    let results = Arc::new(Mutex::new(Vec::new()));

    let handles: Vec<_> = (0..num_cpus::get())
        .map(|_| {
            let tasks = Arc::clone(&tasks);
            let results = Arc::clone(&results);

            thread::spawn(move || {
                loop {
                    let task = {
                        let mut task_queue = tasks.lock().unwrap();
                        task_queue.pop()
                    };

                    match task {
                        Some(task) => {
                            let result = task();
                            results.lock().unwrap().push(result);
                        }
                        None => break,
                    }
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    Arc::try_unwrap(results).unwrap().into_inner().unwrap()
}
```

---

## 6. å®è·µæ¡ˆä¾‹

### 6.1 å¹¶å‘å½’å¹¶æ’åº

```rust
use rayon::prelude::*;

/// Rayon å¹¶å‘å½’å¹¶æ’åº
pub fn parallel_merge_sort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let mid = arr.len() / 2;
    let (left, right) = arr.split_at_mut(mid);

    rayon::join(
        || parallel_merge_sort(left),
        || parallel_merge_sort(right),
    );

    merge_parallel(arr, mid);
}

fn merge_parallel<T: Ord + Clone>(arr: &mut [T], mid: usize) {
    let left = arr[..mid].to_vec();
    let right = arr[mid..].to_vec();

    let mut i = 0;
    let mut j = 0;
    let mut k = 0;

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            arr[k] = left[i].clone();
            i += 1;
        } else {
            arr[k] = right[j].clone();
            j += 1;
        }
        k += 1;
    }

    while i < left.len() {
        arr[k] = left[i].clone();
        i += 1;
        k += 1;
    }

    while j < right.len() {
        arr[k] = right[j].clone();
        j += 1;
        k += 1;
    }
}
```

### 6.2 å¹¶å‘å›¾ç®—æ³•

```rust
/// å¹¶å‘ Bellman-Ford ç®—æ³•
pub fn parallel_bellman_ford(
    graph: &[Vec<(usize, i64)>],
    start: usize,
) -> Vec<i64> {
    use std::sync::Arc;
    use parking_lot::RwLock;

    let n = graph.len();
    let dist = Arc::new(RwLock::new(vec![i64::MAX; n]));
    dist.write()[start] = 0;

    for _ in 0..n - 1 {
        let updated = Arc::new(std::sync::atomic::AtomicBool::new(false));

        (0..n).into_par_iter().for_each(|u| {
            let d_u = dist.read()[u];
            if d_u == i64::MAX {
                return;
            }

            for &(v, w) in &graph[u] {
                let new_dist = d_u + w;
                let mut dist_write = dist.write();
                if new_dist < dist_write[v] {
                    dist_write[v] = new_dist;
                    updated.store(true, std::sync::atomic::Ordering::Relaxed);
                }
            }
        });

        if !updated.load(std::sync::atomic::Ordering::Relaxed) {
            break;
        }
    }

    Arc::try_unwrap(dist).unwrap().into_inner()
}
```

### 6.3 å¹¶å‘å“ˆå¸Œè¡¨

```rust
use dashmap::DashMap;

/// å¹¶å‘å“ˆå¸Œè¡¨ç¤ºä¾‹
pub fn concurrent_word_count(texts: Vec<String>) -> DashMap<String, usize> {
    let word_count = DashMap::new();

    texts.par_iter().for_each(|text| {
        for word in text.split_whitespace() {
            *word_count.entry(word.to_string()).or_insert(0) += 1;
        }
    });

    word_count
}
```

---

## 7. å‚è€ƒèµ„æ–™

### æ•™æ

- **[Herlihy-Shavit]** Herlihy, Shavit. *The Art of Multiprocessor Programming*
- **[McCool et al.]** McCool, Reinders, Robison. *Structured Parallel Programming*
- **[Mattson et al.]** Mattson, Sanders, Massingill. *Patterns for Parallel Programming*

### Rust å¹¶å‘åº“

- **[Rayon]** <https://github.com/rayon-rs/rayon>
- **[Crossbeam]** <https://github.com/crossbeam-rs/crossbeam>
- **[DashMap]** <https://github.com/xacrimon/dashmap>
- **[Tokio]** <https://tokio.rs/>

### å½¢å¼åŒ–éªŒè¯

- **[Loom]** <https://github.com/tokio-rs/loom> (å¹¶å‘æµ‹è¯•)
- **[Shuttle]** <https://github.com/awslabs/shuttle> (ç¡®å®šæ€§å¹¶å‘æµ‹è¯•)

---

**æ–‡æ¡£å®Œæˆåº¦**: 100%
**ä»£ç ç¤ºä¾‹æ•°**: 30+
**å¹¶å‘æ¨¡å¼æ•°**: 10+
**æ— é”æ•°æ®ç»“æ„æ•°**: 2

**ä¸‹ä¸€æ­¥**: å‚è§ [`03_åˆ†å¸ƒå¼ç®—æ³•.md`](./03_åˆ†å¸ƒå¼ç®—æ³•.md)
