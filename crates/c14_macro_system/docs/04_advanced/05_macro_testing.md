# å®æµ‹è¯•ç­–ç•¥

> **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡å…¨é¢æµ‹è¯•å£°æ˜å¼å®å’Œè¿‡ç¨‹å®çš„æ–¹æ³•ï¼Œç¡®ä¿å®çš„æ­£ç¡®æ€§å’Œå¥å£®æ€§ã€‚

---

## ğŸ“– ç›®å½•

- [å®æµ‹è¯•ç­–ç•¥](#å®æµ‹è¯•ç­–ç•¥)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [æµ‹è¯•åŸºç¡€](#æµ‹è¯•åŸºç¡€)
    - [ä¸ºä»€ä¹ˆæµ‹è¯•å®å¾ˆé‡è¦ï¼Ÿ](#ä¸ºä»€ä¹ˆæµ‹è¯•å®å¾ˆé‡è¦)
    - [æµ‹è¯•é‡‘å­—å¡”](#æµ‹è¯•é‡‘å­—å¡”)
    - [æµ‹è¯•ç±»å‹](#æµ‹è¯•ç±»å‹)
  - [å£°æ˜å¼å®æµ‹è¯•](#å£°æ˜å¼å®æµ‹è¯•)
    - [1. åŸºæœ¬å•å…ƒæµ‹è¯•](#1-åŸºæœ¬å•å…ƒæµ‹è¯•)
    - [2. æµ‹è¯•ä¸åŒæ¨¡å¼](#2-æµ‹è¯•ä¸åŒæ¨¡å¼)
    - [3. æµ‹è¯•é‡å¤æ¨¡å¼](#3-æµ‹è¯•é‡å¤æ¨¡å¼)
    - [4. æµ‹è¯•è¾¹ç•Œæƒ…å†µ](#4-æµ‹è¯•è¾¹ç•Œæƒ…å†µ)
    - [5. æµ‹è¯•ä»£ç ç”Ÿæˆ](#5-æµ‹è¯•ä»£ç ç”Ÿæˆ)
  - [è¿‡ç¨‹å®æµ‹è¯•](#è¿‡ç¨‹å®æµ‹è¯•)
    - [1. å•å…ƒæµ‹è¯•åŸºç¡€](#1-å•å…ƒæµ‹è¯•åŸºç¡€)
    - [2. ä½¿ç”¨ `trybuild` æµ‹è¯•](#2-ä½¿ç”¨-trybuild-æµ‹è¯•)
      - [æˆåŠŸæµ‹è¯•ç”¨ä¾‹](#æˆåŠŸæµ‹è¯•ç”¨ä¾‹)
      - [å¤±è´¥æµ‹è¯•ç”¨ä¾‹](#å¤±è´¥æµ‹è¯•ç”¨ä¾‹)
    - [3. æµ‹è¯•å¤æ‚åœºæ™¯](#3-æµ‹è¯•å¤æ‚åœºæ™¯)
    - [4. å±æ€§å®æµ‹è¯•](#4-å±æ€§å®æµ‹è¯•)
    - [5. Function-like å®æµ‹è¯•](#5-function-like-å®æµ‹è¯•)
  - [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
    - [1. è·¨æ¨¡å—æµ‹è¯•](#1-è·¨æ¨¡å—æµ‹è¯•)
    - [2. ä¸å…¶ä»– crate é›†æˆ](#2-ä¸å…¶ä»–-crate-é›†æˆ)
    - [3. å®é™…ä½¿ç”¨åœºæ™¯æµ‹è¯•](#3-å®é™…ä½¿ç”¨åœºæ™¯æµ‹è¯•)
  - [é”™è¯¯æµ‹è¯•](#é”™è¯¯æµ‹è¯•)
    - [1. æµ‹è¯•ç¼–è¯‘é”™è¯¯](#1-æµ‹è¯•ç¼–è¯‘é”™è¯¯)
    - [2. æµ‹è¯•è¿è¡Œæ—¶é”™è¯¯](#2-æµ‹è¯•è¿è¡Œæ—¶é”™è¯¯)
    - [3. æµ‹è¯•é”™è¯¯æ¢å¤](#3-æµ‹è¯•é”™è¯¯æ¢å¤)
  - [å›å½’æµ‹è¯•](#å›å½’æµ‹è¯•)
    - [1. å¿«ç…§æµ‹è¯•](#1-å¿«ç…§æµ‹è¯•)
    - [2. ç‰ˆæœ¬å…¼å®¹æ€§æµ‹è¯•](#2-ç‰ˆæœ¬å…¼å®¹æ€§æµ‹è¯•)
    - [3. å·²çŸ¥é—®é¢˜æµ‹è¯•](#3-å·²çŸ¥é—®é¢˜æµ‹è¯•)
  - [æ€§èƒ½æµ‹è¯•](#æ€§èƒ½æµ‹è¯•)
    - [1. ç¼–è¯‘æ—¶é—´æµ‹è¯•](#1-ç¼–è¯‘æ—¶é—´æµ‹è¯•)
    - [2. å®å±•å¼€æ€§èƒ½](#2-å®å±•å¼€æ€§èƒ½)
    - [3. å¢é‡ç¼–è¯‘æµ‹è¯•](#3-å¢é‡ç¼–è¯‘æµ‹è¯•)
  - [æµ‹è¯•è‡ªåŠ¨åŒ–](#æµ‹è¯•è‡ªåŠ¨åŒ–)
    - [1. CI/CD é…ç½®](#1-cicd-é…ç½®)
    - [2. æµ‹è¯•çŸ©é˜µ](#2-æµ‹è¯•çŸ©é˜µ)
    - [3. è¦†ç›–ç‡æŠ¥å‘Š](#3-è¦†ç›–ç‡æŠ¥å‘Š)
  - [æµ‹è¯•æœ€ä½³å®è·µ](#æµ‹è¯•æœ€ä½³å®è·µ)
    - [1. æµ‹è¯•ç»„ç»‡](#1-æµ‹è¯•ç»„ç»‡)
    - [2. æµ‹è¯•å‘½åçº¦å®š](#2-æµ‹è¯•å‘½åçº¦å®š)
    - [3. æµ‹è¯•æ–‡æ¡£](#3-æµ‹è¯•æ–‡æ¡£)
    - [4. æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡](#4-æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡)
    - [5. æŒç»­æµ‹è¯•](#5-æŒç»­æµ‹è¯•)
  - [æµ‹è¯•æ£€æŸ¥æ¸…å•](#æµ‹è¯•æ£€æŸ¥æ¸…å•)
    - [å¼€å‘é˜¶æ®µ](#å¼€å‘é˜¶æ®µ)
    - [é›†æˆé˜¶æ®µ](#é›†æˆé˜¶æ®µ)
    - [å‘å¸ƒå‰](#å‘å¸ƒå‰)
  - [æµ‹è¯•å·¥å…·æ€»ç»“](#æµ‹è¯•å·¥å…·æ€»ç»“)
  - [æ€»ç»“](#æ€»ç»“)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)

---

## æµ‹è¯•åŸºç¡€

### ä¸ºä»€ä¹ˆæµ‹è¯•å®å¾ˆé‡è¦ï¼Ÿ

å®åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œï¼Œé”™è¯¯å¯èƒ½ï¼š

- éš¾ä»¥è°ƒè¯•
- å½±å“èŒƒå›´å¹¿
- é”™è¯¯æ¶ˆæ¯ä¸æ¸…æ™°
- ç ´åæ€§å¼º

```text
æœªæµ‹è¯•çš„å® â†’ ç”Ÿäº§ç¯å¢ƒç¼–è¯‘å¤±è´¥ â†’ ğŸ˜±
å……åˆ†æµ‹è¯•çš„å® â†’ åŠæ—©å‘ç°é—®é¢˜ â†’ âœ…
```

### æµ‹è¯•é‡‘å­—å¡”

```text
      /\           å•å…ƒæµ‹è¯• (70%)
     /  \          - æµ‹è¯•å•ä¸ªè§„åˆ™
    /â”€â”€â”€â”€\         - æµ‹è¯•è¾¹ç•Œæƒ…å†µ
   /      \        
  /â”€â”€â”€â”€â”€â”€â”€â”€\       é›†æˆæµ‹è¯• (20%)
 /          \      - æµ‹è¯•å®é™…ä½¿ç”¨åœºæ™¯
/â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\     - æµ‹è¯•ä¸å…¶ä»–ä»£ç äº¤äº’
                   
                   ç«¯åˆ°ç«¯æµ‹è¯• (10%)
                   - æµ‹è¯•å®Œæ•´é¡¹ç›®
                   - æ€§èƒ½æµ‹è¯•
```

### æµ‹è¯•ç±»å‹

| æµ‹è¯•ç±»å‹ | ç›®æ ‡ | å·¥å…· |
|---------|------|------|
| **å•å…ƒæµ‹è¯•** | æµ‹è¯•å•ä¸ªå®è§„åˆ™ | `#[test]` |
| **é›†æˆæµ‹è¯•** | æµ‹è¯•å®é™…ä½¿ç”¨ | `tests/` ç›®å½• |
| **ç¼–è¯‘å¤±è´¥æµ‹è¯•** | éªŒè¯é”™è¯¯æ¶ˆæ¯ | `trybuild` |
| **å±•å¼€æµ‹è¯•** | éªŒè¯ç”Ÿæˆä»£ç  | `cargo-expand` |
| **æ€§èƒ½æµ‹è¯•** | æµ‹è¯•ç¼–è¯‘æ—¶é—´ | è‡ªå®šä¹‰è„šæœ¬ |

---

## å£°æ˜å¼å®æµ‹è¯•

### 1. åŸºæœ¬å•å…ƒæµ‹è¯•

```rust
macro_rules! add {
    ($a:expr, $b:expr) => {
        $a + $b
    };
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_add_basic() {
        assert_eq!(add!(2, 3), 5);
        assert_eq!(add!(0, 0), 0);
        assert_eq!(add!(-1, 1), 0);
    }
    
    #[test]
    fn test_add_expressions() {
        assert_eq!(add!(1 + 1, 2 + 2), 6);
        assert_eq!(add!(2 * 3, 4), 10);
    }
    
    #[test]
    fn test_add_variables() {
        let x = 5;
        let y = 10;
        assert_eq!(add!(x, y), 15);
    }
}
```

### 2. æµ‹è¯•ä¸åŒæ¨¡å¼

```rust
macro_rules! create_var {
    ($name:ident = $value:expr) => {
        let $name = $value;
    };
    ($name:ident: $type:ty = $value:expr) => {
        let $name: $type = $value;
    };
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_pattern_1() {
        create_var!(x = 42);
        assert_eq!(x, 42);
    }
    
    #[test]
    fn test_pattern_2() {
        create_var!(y: i64 = 100);
        assert_eq!(y, 100i64);
    }
}
```

### 3. æµ‹è¯•é‡å¤æ¨¡å¼

```rust
macro_rules! sum {
    () => { 0 };
    ($single:expr) => { $single };
    ($first:expr, $($rest:expr),+) => {
        $first + sum!($($rest),+)
    };
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_sum_empty() {
        assert_eq!(sum!(), 0);
    }
    
    #[test]
    fn test_sum_single() {
        assert_eq!(sum!(5), 5);
    }
    
    #[test]
    fn test_sum_multiple() {
        assert_eq!(sum!(1, 2, 3, 4, 5), 15);
    }
    
    #[test]
    fn test_sum_expressions() {
        assert_eq!(sum!(1 + 1, 2 * 2, 3 - 1), 8);
    }
}
```

### 4. æµ‹è¯•è¾¹ç•Œæƒ…å†µ

```rust
macro_rules! safe_index {
    ($arr:expr, $idx:expr) => {
        if $idx < $arr.len() {
            Some($arr[$idx])
        } else {
            None
        }
    };
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_valid_index() {
        let arr = [1, 2, 3, 4, 5];
        assert_eq!(safe_index!(arr, 0), Some(1));
        assert_eq!(safe_index!(arr, 4), Some(5));
    }
    
    #[test]
    fn test_invalid_index() {
        let arr = [1, 2, 3];
        assert_eq!(safe_index!(arr, 3), None);
        assert_eq!(safe_index!(arr, 100), None);
    }
    
    #[test]
    fn test_empty_array() {
        let arr: [i32; 0] = [];
        assert_eq!(safe_index!(arr, 0), None);
    }
}
```

### 5. æµ‹è¯•ä»£ç ç”Ÿæˆ

```rust
macro_rules! generate_struct {
    ($name:ident { $($field:ident: $type:ty),* }) => {
        struct $name {
            $($field: $type),*
        }
        
        impl $name {
            fn new($($field: $type),*) -> Self {
                Self { $($field),* }
            }
        }
    };
}

#[cfg(test)]
mod tests {
    generate_struct!(Person {
        name: String,
        age: u32
    });
    
    #[test]
    fn test_generated_struct() {
        let person = Person::new("Alice".to_string(), 30);
        assert_eq!(person.name, "Alice");
        assert_eq!(person.age, 30);
    }
}
```

---

## è¿‡ç¨‹å®æµ‹è¯•

### 1. å•å…ƒæµ‹è¯•åŸºç¡€

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyDerive)]
pub fn my_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    
    let expanded = quote! {
        impl MyTrait for #name {
            fn my_method(&self) -> &'static str {
                stringify!(#name)
            }
        }
    };
    
    TokenStream::from(expanded)
}

// æµ‹è¯•è¾…åŠ©å‡½æ•°
#[cfg(test)]
pub fn derive_my_trait(input: proc_macro2::TokenStream) -> proc_macro2::TokenStream {
    my_derive(input.into()).into()
}
```

```rust
// my_macro/tests/derive_tests.rs
use my_macro::derive_my_trait;
use quote::quote;
use syn;

#[test]
fn test_simple_struct() {
    let input = quote! {
        struct MyStruct {
            field: i32,
        }
    };
    
    let output = derive_my_trait(input);
    
    // è§£æè¾“å‡ºä»¥éªŒè¯å…¶æœ‰æ•ˆæ€§
    let parsed: syn::File = syn::parse2(output).expect("Failed to parse output");
    
    // éªŒè¯ç”Ÿæˆäº†ä¸€ä¸ª impl å—
    assert_eq!(parsed.items.len(), 1);
}

#[test]
fn test_output_contains_impl() {
    let input = quote! {
        struct Test;
    };
    
    let output = derive_my_trait(input);
    let output_str = output.to_string();
    
    assert!(output_str.contains("impl MyTrait for Test"));
    assert!(output_str.contains("fn my_method"));
}
```

### 2. ä½¿ç”¨ `trybuild` æµ‹è¯•

`trybuild` æ˜¯æµ‹è¯•è¿‡ç¨‹å®çš„æœ€ä½³å·¥å…·ï¼š

```rust
// my_macro/tests/ui.rs
#[test]
fn ui() {
    let t = trybuild::TestCases::new();
    
    // æµ‹è¯•æˆåŠŸç¼–è¯‘çš„æƒ…å†µ
    t.pass("tests/ui/pass/*.rs");
    
    // æµ‹è¯•åº”è¯¥å¤±è´¥çš„æƒ…å†µ
    t.compile_fail("tests/ui/fail/*.rs");
}
```

#### æˆåŠŸæµ‹è¯•ç”¨ä¾‹

```rust
// tests/ui/pass/basic.rs
use my_macro::MyDerive;

#[derive(MyDerive)]
struct Simple {
    field: i32,
}

fn main() {
    let s = Simple { field: 42 };
    assert_eq!(s.my_method(), "Simple");
}
```

```rust
// tests/ui/pass/generic.rs
use my_macro::MyDerive;

#[derive(MyDerive)]
struct Generic<T> {
    value: T,
}

fn main() {
    let g = Generic { value: 42 };
    assert_eq!(g.my_method(), "Generic");
}
```

#### å¤±è´¥æµ‹è¯•ç”¨ä¾‹

```rust
// tests/ui/fail/enum_not_supported.rs
use my_macro::MyDerive;

#[derive(MyDerive)]
enum NotSupported {
    Variant,
}

fn main() {}
```

```text
// tests/ui/fail/enum_not_supported.stderr
error: MyDerive only supports structs
 --> tests/ui/fail/enum_not_supported.rs:3:10
  |
3 | #[derive(MyDerive)]
  |          ^^^^^^^^
```

### 3. æµ‹è¯•å¤æ‚åœºæ™¯

```rust
// tests/complex_tests.rs
use my_macro::Builder;
use quote::quote;

#[test]
fn test_builder_with_options() {
    let input = quote! {
        struct Config {
            host: String,
            port: u16,
            #[builder(default)]
            timeout: u64,
        }
    };
    
    let output = derive_builder(input);
    
    // éªŒè¯è¾“å‡ºåŒ…å«æ­£ç¡®çš„æ–¹æ³•
    let output_str = output.to_string();
    assert!(output_str.contains("fn host"));
    assert!(output_str.contains("fn port"));
    assert!(output_str.contains("fn timeout"));
    assert!(output_str.contains("fn build"));
}

#[test]
fn test_builder_usage() {
    #[derive(Builder)]
    struct User {
        name: String,
        age: u32,
    }
    
    let user = User::builder()
        .name("Alice".to_string())
        .age(30)
        .build()
        .unwrap();
    
    assert_eq!(user.name, "Alice");
    assert_eq!(user.age, 30);
}
```

### 4. å±æ€§å®æµ‹è¯•

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn trace(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let body = &input.block;
    let sig = &input.sig;
    
    let expanded = quote! {
        #sig {
            println!("Entering {}", stringify!(#name));
            let result = (|| #body)();
            println!("Exiting {}", stringify!(#name));
            result
        }
    };
    
    TokenStream::from(expanded)
}

// tests/attribute_tests.rs
#[test]
fn test_trace_attribute() {
    #[trace]
    fn example() -> i32 {
        42
    }
    
    assert_eq!(example(), 42);
}
```

### 5. Function-like å®æµ‹è¯•

```rust
// my_macro/src/lib.rs
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    // è§£æå’Œç”Ÿæˆ SQL æŸ¥è¯¢
    // ...
}

// tests/function_like_tests.rs
#[test]
fn test_sql_macro() {
    let query = sql!(SELECT id, name FROM users WHERE age > 18);
    
    // éªŒè¯æŸ¥è¯¢ç»“æ„
    assert_eq!(query.table(), "users");
    assert_eq!(query.columns(), vec!["id", "name"]);
}
```

---

## é›†æˆæµ‹è¯•

### 1. è·¨æ¨¡å—æµ‹è¯•

```rust
// tests/integration_test.rs
use my_macro::{MyDerive, Builder};

#[derive(MyDerive, Builder)]
struct Combined {
    field1: String,
    field2: i32,
}

#[test]
fn test_combined_derives() {
    let obj = Combined::builder()
        .field1("test".to_string())
        .field2(42)
        .build()
        .unwrap();
    
    assert_eq!(obj.my_method(), "Combined");
    assert_eq!(obj.field1, "test");
}
```

### 2. ä¸å…¶ä»– crate é›†æˆ

```rust
// tests/external_integration.rs
use my_macro::MyDerive;
use serde::{Serialize, Deserialize};

#[derive(MyDerive, Serialize, Deserialize)]
struct IntegratedStruct {
    data: String,
}

#[test]
fn test_with_serde() {
    let obj = IntegratedStruct {
        data: "test".to_string(),
    };
    
    let json = serde_json::to_string(&obj).unwrap();
    let deserialized: IntegratedStruct = serde_json::from_str(&json).unwrap();
    
    assert_eq!(deserialized.data, "test");
    assert_eq!(deserialized.my_method(), "IntegratedStruct");
}
```

### 3. å®é™…ä½¿ç”¨åœºæ™¯æµ‹è¯•

```rust
// tests/real_world_test.rs
use my_macro::Builder;

#[derive(Builder)]
struct ServerConfig {
    host: String,
    port: u16,
    #[builder(default = 10)]
    max_connections: usize,
}

#[test]
fn test_server_config_realistic() {
    let config = ServerConfig::builder()
        .host("localhost".to_string())
        .port(8080)
        .build()
        .unwrap();
    
    assert_eq!(config.host, "localhost");
    assert_eq!(config.port, 8080);
    assert_eq!(config.max_connections, 10); // é»˜è®¤å€¼
}

#[test]
fn test_server_config_full() {
    let config = ServerConfig::builder()
        .host("0.0.0.0".to_string())
        .port(443)
        .max_connections(1000)
        .build()
        .unwrap();
    
    assert_eq!(config.max_connections, 1000);
}
```

---

## é”™è¯¯æµ‹è¯•

### 1. æµ‹è¯•ç¼–è¯‘é”™è¯¯

ä½¿ç”¨ `trybuild` éªŒè¯é”™è¯¯æ¶ˆæ¯ï¼š

```rust
// tests/ui/fail/missing_field.rs
use my_macro::Builder;

#[derive(Builder)]
struct Incomplete {
    required: String,
}

fn main() {
    // åº”è¯¥å¤±è´¥ï¼šç¼ºå°‘ required å­—æ®µ
    let _ = Incomplete::builder().build();
}
```

```text
// tests/ui/fail/missing_field.stderr
error[E0308]: mismatched types
  --> tests/ui/fail/missing_field.rs:8:13
   |
8  |     let _ = Incomplete::builder().build();
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result<Incomplete, &str>`, found `()`
```

### 2. æµ‹è¯•è¿è¡Œæ—¶é”™è¯¯

```rust
#[test]
#[should_panic(expected = "Field 'required_field' is missing")]
fn test_builder_panics_on_missing_field() {
    #[derive(Builder)]
    struct Test {
        required_field: String,
    }
    
    let _ = Test::builder()
        .build()
        .expect("Should panic");
}
```

### 3. æµ‹è¯•é”™è¯¯æ¢å¤

```rust
#[test]
fn test_error_recovery() {
    #[derive(Builder)]
    struct Config {
        value: i32,
    }
    
    let result = Config::builder().build();
    
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err(),
        "Field 'value' is required"
    );
}
```

---

## å›å½’æµ‹è¯•

### 1. å¿«ç…§æµ‹è¯•

```rust
// tests/snapshot_tests.rs
use insta::assert_snapshot;

#[test]
fn test_macro_output_snapshot() {
    let input = quote! {
        struct Example {
            field: String,
        }
    };
    
    let output = derive_my_macro(input);
    
    // ç¬¬ä¸€æ¬¡è¿è¡Œä¼šåˆ›å»ºå¿«ç…§
    // åç»­è¿è¡Œä¼šä¸å¿«ç…§æ¯”è¾ƒ
    assert_snapshot!(output.to_string());
}
```

### 2. ç‰ˆæœ¬å…¼å®¹æ€§æµ‹è¯•

```rust
// tests/version_compat.rs
#[cfg(feature = "v1_api")]
#[test]
fn test_v1_compatibility() {
    // æµ‹è¯•æ—§ç‰ˆæœ¬ API
}

#[cfg(feature = "v2_api")]
#[test]
fn test_v2_compatibility() {
    // æµ‹è¯•æ–°ç‰ˆæœ¬ API
}
```

### 3. å·²çŸ¥é—®é¢˜æµ‹è¯•

```rust
#[test]
#[ignore] // æš‚æ—¶å¿½ç•¥
fn test_known_issue_123() {
    // è¿™æ˜¯ä¸€ä¸ªå·²çŸ¥é—®é¢˜çš„å›å½’æµ‹è¯•
    // Issue: https://github.com/user/repo/issues/123
    
    #[derive(MyMacro)]
    struct ProblematicCase {
        // ç‰¹å®šä¼šå¯¼è‡´é—®é¢˜çš„é…ç½®
    }
}
```

---

## æ€§èƒ½æµ‹è¯•

### 1. ç¼–è¯‘æ—¶é—´æµ‹è¯•

```rust
// benches/compile_time.rs
use std::process::Command;
use std::time::Instant;

#[test]
fn benchmark_compile_time() {
    let start = Instant::now();
    
    let status = Command::new("cargo")
        .args(&["build", "--release"])
        .status()
        .expect("Failed to run cargo build");
    
    let duration = start.elapsed();
    
    assert!(status.success());
    println!("Compile time: {:?}", duration);
    
    // è®¾ç½®åˆç†çš„ç¼–è¯‘æ—¶é—´ä¸Šé™
    assert!(duration.as_secs() < 60, "Compilation took too long");
}
```

### 2. å®å±•å¼€æ€§èƒ½

```rust
// tests/expansion_performance.rs
#[test]
fn test_large_scale_expansion() {
    // æµ‹è¯•ç”Ÿæˆå¤§é‡ä»£ç çš„æ€§èƒ½
    macro_rules! generate_many {
        ($($n:expr),*) => {
            $(
                fn $n() -> i32 { $n }
            )*
        };
    }
    
    // ç”Ÿæˆ1000ä¸ªå‡½æ•°
    generate_many!(
        0, 1, 2, 3, /* ... */ 999
    );
}
```

### 3. å¢é‡ç¼–è¯‘æµ‹è¯•

```bash
#!/bin/bash
# scripts/test_incremental.sh

# é¦–æ¬¡å®Œæ•´ç¼–è¯‘
cargo clean
time cargo build

# ä¿®æ”¹å•ä¸ªæ–‡ä»¶
touch src/lib.rs

# å¢é‡ç¼–è¯‘
time cargo build

# æ¯”è¾ƒä¸¤æ¬¡ç¼–è¯‘æ—¶é—´
```

---

## æµ‹è¯•è‡ªåŠ¨åŒ–

### 1. CI/CD é…ç½®

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          
      - name: Run tests
        run: cargo test --all-features
        
      - name: Run UI tests
        run: cargo test --test ui
        
      - name: Check macro expansion
        run: |
          cargo install cargo-expand
          cargo expand --lib > /dev/null
```

### 2. æµ‹è¯•çŸ©é˜µ

```yaml
strategy:
  matrix:
    rust: [stable, beta, nightly]
    os: [ubuntu-latest, macos-latest, windows-latest]
    
steps:
  - name: Test on ${{ matrix.os }} with ${{ matrix.rust }}
    run: cargo +${{ matrix.rust }} test
```

### 3. è¦†ç›–ç‡æŠ¥å‘Š

```yaml
- name: Generate coverage
  run: |
    cargo install cargo-tarpaulin
    cargo tarpaulin --out Xml
    
- name: Upload coverage
  uses: codecov/codecov-action@v1
```

---

## æµ‹è¯•æœ€ä½³å®è·µ

### 1. æµ‹è¯•ç»„ç»‡

```text
my_macro/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ lib.rs          # å®å®ç°
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/           # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ basic.rs
â”‚   â”‚   â””â”€â”€ advanced.rs
â”‚   â”œâ”€â”€ integration/    # é›†æˆæµ‹è¯•
â”‚   â”‚   â””â”€â”€ full_usage.rs
â”‚   â””â”€â”€ ui/             # UI æµ‹è¯•
â”‚       â”œâ”€â”€ pass/       # åº”è¯¥æˆåŠŸçš„æµ‹è¯•
â”‚       â””â”€â”€ fail/       # åº”è¯¥å¤±è´¥çš„æµ‹è¯•
â””â”€â”€ benches/            # æ€§èƒ½æµ‹è¯•
    â””â”€â”€ compile_time.rs
```

### 2. æµ‹è¯•å‘½åçº¦å®š

```rust
#[test]
fn test_<feature>_<scenario>_<expected_outcome>() {
    // ä¾‹å¦‚ï¼š
    // test_builder_missing_field_returns_error()
    // test_derive_on_struct_generates_impl()
    // test_macro_with_generics_compiles()
}
```

### 3. æµ‹è¯•æ–‡æ¡£

```rust
/// æµ‹è¯• Builder å®åœ¨ç¼ºå°‘å¿…éœ€å­—æ®µæ—¶çš„è¡Œä¸º
///
/// # æµ‹è¯•åœºæ™¯
/// - å®šä¹‰ä¸€ä¸ªåŒ…å«å¿…éœ€å­—æ®µçš„ç»“æ„ä½“
/// - å°è¯•æ„å»ºæ—¶ä¸æä¾›è¯¥å­—æ®µ
///
/// # é¢„æœŸç»“æœ
/// - build() è¿”å› Err
/// - é”™è¯¯æ¶ˆæ¯æŒ‡æ˜ç¼ºå°‘çš„å­—æ®µ
#[test]
fn test_builder_required_field_validation() {
    // æµ‹è¯•ä»£ç 
}
```

### 4. æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

```text
ç›®æ ‡è¦†ç›–ç‡ï¼š
â”œâ”€ å•å…ƒæµ‹è¯•: > 80%
â”œâ”€ é›†æˆæµ‹è¯•: > 60%
â”œâ”€ é”™è¯¯è·¯å¾„: 100%
â””â”€ è¾¹ç•Œæƒ…å†µ: 100%
```

### 5. æŒç»­æµ‹è¯•

```rust
// ä½¿ç”¨ cargo-watch è¿›è¡ŒæŒç»­æµ‹è¯•
// cargo install cargo-watch
// cargo watch -x test
```

---

## æµ‹è¯•æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µ

- [ ] ä¸ºæ¯ä¸ªå®è§„åˆ™ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] æµ‹è¯•æ‰€æœ‰è¾¹ç•Œæƒ…å†µ
- [ ] æµ‹è¯•ç©ºè¾“å…¥æƒ…å†µ
- [ ] æµ‹è¯•ä¸å…¶ä»–å®çš„ç»„åˆ

### é›†æˆé˜¶æ®µ

- [ ] åœ¨å®é™…é¡¹ç›®ä¸­æµ‹è¯•
- [ ] æµ‹è¯•ä¸å¸¸ç”¨ crate çš„å…¼å®¹æ€§
- [ ] éªŒè¯é”™è¯¯æ¶ˆæ¯æ¸…æ™°
- [ ] æ£€æŸ¥ç¼–è¯‘æ—¶é—´æ˜¯å¦åˆç†

### å‘å¸ƒå‰

- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] UI æµ‹è¯•è¦†ç›–å¸¸è§é”™è¯¯
- [ ] æ–‡æ¡£åŒ…å«ä½¿ç”¨ç¤ºä¾‹
- [ ] CI/CD é…ç½®æ­£ç¡®
- [ ] è¦†ç›–ç‡è¾¾æ ‡

---

## æµ‹è¯•å·¥å…·æ€»ç»“

| å·¥å…· | ç”¨é€” | é€‚ç”¨åœºæ™¯ |
|------|------|----------|
| `#[test]` | åŸºæœ¬å•å…ƒæµ‹è¯• | å£°æ˜å¼å®ã€è¾…åŠ©å‡½æ•° |
| `trybuild` | UI æµ‹è¯• | è¿‡ç¨‹å®é”™è¯¯æ¶ˆæ¯ |
| `cargo-expand` | å±•å¼€éªŒè¯ | æ£€æŸ¥ç”Ÿæˆä»£ç  |
| `insta` | å¿«ç…§æµ‹è¯• | å›å½’æµ‹è¯• |
| `criterion` | æ€§èƒ½åŸºå‡† | ç¼–è¯‘æ—¶æ€§èƒ½ |
| `cargo-tarpaulin` | è¦†ç›–ç‡ | CI/CDé›†æˆ |

---

## æ€»ç»“

å…¨é¢çš„å®æµ‹è¯•ç­–ç•¥åº”è¯¥åŒ…æ‹¬ï¼š

- **å•å…ƒæµ‹è¯•**ï¼šæµ‹è¯•å•ä¸ªè§„åˆ™å’Œæ¨¡å¼
- **é›†æˆæµ‹è¯•**ï¼šæµ‹è¯•å®é™…ä½¿ç”¨åœºæ™¯
- **UI æµ‹è¯•**ï¼šä½¿ç”¨ `trybuild` éªŒè¯é”™è¯¯
- **æ€§èƒ½æµ‹è¯•**ï¼šç›‘æ§ç¼–è¯‘æ—¶é—´
- **è‡ªåŠ¨åŒ–**ï¼šCI/CD æŒç»­æµ‹è¯•
- **æ–‡æ¡£**ï¼šæ¸…æ™°çš„æµ‹è¯•æ–‡æ¡£

é€šè¿‡ç³»ç»ŸåŒ–çš„æµ‹è¯•ï¼Œä½ å¯ä»¥ç¡®ä¿å®çš„æ­£ç¡®æ€§ã€å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ï¼

## ç›¸å…³èµ„æº

- [03_macro_debugging.md](./03_macro_debugging.md) - è°ƒè¯•æŠ€å·§
- [02_code_generation.md](./02_code_generation.md) - ä»£ç ç”Ÿæˆ
- [../05_practice/02_best_practices.md](../05_practice/02_best_practices.md) - æœ€ä½³å®è·µ
