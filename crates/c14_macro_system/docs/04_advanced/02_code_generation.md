# ä»£ç ç”Ÿæˆé«˜çº§æŠ€æœ¯

> **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡ä½¿ç”¨å®è¿›è¡Œé«˜çº§ä»£ç ç”Ÿæˆçš„æŠ€æœ¯ï¼ŒåŒ…æ‹¬æ¨¡å¼ã€ç­–ç•¥å’Œæœ€ä½³å®è·µã€‚

---

## ğŸ“– ç›®å½•

- [ä»£ç ç”Ÿæˆé«˜çº§æŠ€æœ¯](#ä»£ç ç”Ÿæˆé«˜çº§æŠ€æœ¯)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [ä»£ç ç”ŸæˆåŸºç¡€](#ä»£ç ç”ŸæˆåŸºç¡€)
    - [ä»€ä¹ˆæ˜¯ä»£ç ç”Ÿæˆï¼Ÿ](#ä»€ä¹ˆæ˜¯ä»£ç ç”Ÿæˆ)
    - [ä»£ç ç”Ÿæˆçš„å±‚æ¬¡](#ä»£ç ç”Ÿæˆçš„å±‚æ¬¡)
    - [ä»£ç ç”Ÿæˆçš„ä¼˜åŠ¿](#ä»£ç ç”Ÿæˆçš„ä¼˜åŠ¿)
  - [å£°æ˜å¼ä»£ç ç”Ÿæˆ](#å£°æ˜å¼ä»£ç ç”Ÿæˆ)
    - [åŸºæœ¬æ¨¡å¼](#åŸºæœ¬æ¨¡å¼)
      - [1. é‡å¤å±•å¼€æ¨¡å¼](#1-é‡å¤å±•å¼€æ¨¡å¼)
      - [2. ç±»å‹æ´¾ç”Ÿæ¨¡å¼](#2-ç±»å‹æ´¾ç”Ÿæ¨¡å¼)
      - [3. ä»£ç å—ç”Ÿæˆ](#3-ä»£ç å—ç”Ÿæˆ)
    - [é«˜çº§æ¨¡å¼](#é«˜çº§æ¨¡å¼)
      - [1. åµŒå¥—ä»£ç ç”Ÿæˆ](#1-åµŒå¥—ä»£ç ç”Ÿæˆ)
      - [2. æ¡ä»¶ä»£ç ç”Ÿæˆ](#2-æ¡ä»¶ä»£ç ç”Ÿæˆ)
  - [è¿‡ç¨‹å®ä»£ç ç”Ÿæˆ](#è¿‡ç¨‹å®ä»£ç ç”Ÿæˆ)
    - [Derive å®ç”Ÿæˆ](#derive-å®ç”Ÿæˆ)
      - [å®Œæ•´çš„ Builder ç”Ÿæˆå™¨](#å®Œæ•´çš„-builder-ç”Ÿæˆå™¨)
      - [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
    - [Attribute å®ç”Ÿæˆ](#attribute-å®ç”Ÿæˆ)
      - [æ€§èƒ½ç›‘æ§å®](#æ€§èƒ½ç›‘æ§å®)
      - [ä½¿ç”¨ç¤ºä¾‹1](#ä½¿ç”¨ç¤ºä¾‹1)
    - [Function-like å®ç”Ÿæˆ](#function-like-å®ç”Ÿæˆ)
      - [SQL æŸ¥è¯¢ç”Ÿæˆå™¨](#sql-æŸ¥è¯¢ç”Ÿæˆå™¨)
  - [ä»£ç æ¨¡æ¿ç³»ç»Ÿ](#ä»£ç æ¨¡æ¿ç³»ç»Ÿ)
    - [æ¨¡æ¿å¼•æ“è®¾è®¡](#æ¨¡æ¿å¼•æ“è®¾è®¡)
    - [æ¨¡æ¿ç»„åˆ](#æ¨¡æ¿ç»„åˆ)
  - [ç±»å‹é©±åŠ¨ç”Ÿæˆ](#ç±»å‹é©±åŠ¨ç”Ÿæˆ)
    - [åŸºäºç±»å‹ä¿¡æ¯çš„ä»£ç ç”Ÿæˆ](#åŸºäºç±»å‹ä¿¡æ¯çš„ä»£ç ç”Ÿæˆ)
    - [æ³›å‹ä»£ç ç”Ÿæˆ](#æ³›å‹ä»£ç ç”Ÿæˆ)
  - [å…ƒæ•°æ®é©±åŠ¨ç”Ÿæˆ](#å…ƒæ•°æ®é©±åŠ¨ç”Ÿæˆ)
    - [å±æ€§è§£æ](#å±æ€§è§£æ)
    - [é…ç½®é©±åŠ¨ç”Ÿæˆ](#é…ç½®é©±åŠ¨ç”Ÿæˆ)
  - [å¢é‡ä»£ç ç”Ÿæˆ](#å¢é‡ä»£ç ç”Ÿæˆ)
    - [æ¡ä»¶ç¼–è¯‘](#æ¡ä»¶ç¼–è¯‘)
    - [ç‰¹æ€§é—¨æ§](#ç‰¹æ€§é—¨æ§)
  - [ä»£ç ç”Ÿæˆä¼˜åŒ–](#ä»£ç ç”Ÿæˆä¼˜åŒ–)
    - [1. å‡å°‘ç”Ÿæˆä»£ç é‡](#1-å‡å°‘ç”Ÿæˆä»£ç é‡)
    - [2. é¿å…é‡å¤ç”Ÿæˆ](#2-é¿å…é‡å¤ç”Ÿæˆ)
    - [3. å»¶è¿Ÿç”Ÿæˆ](#3-å»¶è¿Ÿç”Ÿæˆ)
  - [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šORM ä»£ç ç”Ÿæˆ](#æ¡ˆä¾‹1orm-ä»£ç ç”Ÿæˆ)
    - [æ¡ˆä¾‹2ï¼šAPI è·¯ç”±ç”Ÿæˆ](#æ¡ˆä¾‹2api-è·¯ç”±ç”Ÿæˆ)
    - [æ¡ˆä¾‹3ï¼šçŠ¶æ€æœºç”Ÿæˆ](#æ¡ˆä¾‹3çŠ¶æ€æœºç”Ÿæˆ)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. ä¿æŒç”Ÿæˆä»£ç çš„å¯è¯»æ€§](#1-ä¿æŒç”Ÿæˆä»£ç çš„å¯è¯»æ€§)
    - [2. æä¾›æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯](#2-æä¾›æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯)
    - [3. æ–‡æ¡£åŒ–ç”Ÿæˆçš„ä»£ç ](#3-æ–‡æ¡£åŒ–ç”Ÿæˆçš„ä»£ç )
    - [4. æµ‹è¯•ç”Ÿæˆå™¨](#4-æµ‹è¯•ç”Ÿæˆå™¨)
  - [æ€»ç»“](#æ€»ç»“)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)

---

## ä»£ç ç”ŸæˆåŸºç¡€

### ä»€ä¹ˆæ˜¯ä»£ç ç”Ÿæˆï¼Ÿ

ä»£ç ç”Ÿæˆæ˜¯åœ¨ç¼–è¯‘æ—¶è‡ªåŠ¨åˆ›å»º Rust ä»£ç çš„è¿‡ç¨‹ï¼š

```rust
// è¾“å…¥ï¼šé«˜å±‚æ¬¡æŠ½è±¡
#[derive(Builder)]
struct Config {
    host: String,
    port: u16,
}

// è¾“å‡ºï¼šç”Ÿæˆçš„ä»£ç 
impl Config {
    fn builder() -> ConfigBuilder { /* ... */ }
}

struct ConfigBuilder { /* ... */ }
impl ConfigBuilder {
    fn host(mut self, host: String) -> Self { /* ... */ }
    fn port(mut self, port: u16) -> Self { /* ... */ }
    fn build(self) -> Config { /* ... */ }
}
```

### ä»£ç ç”Ÿæˆçš„å±‚æ¬¡

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é«˜å±‚æŠ½è±¡ï¼ˆç”¨æˆ·è¾“å…¥ï¼‰             â”‚
â”‚  - ç®€æ´çš„è¯­æ³•                    â”‚
â”‚  - å£°æ˜å¼è¡¨è¾¾                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä»£ç ç”Ÿæˆå™¨ï¼ˆå®ï¼‰                 â”‚
â”‚  - è§£æè¾“å…¥                      â”‚
â”‚  - åº”ç”¨è§„åˆ™                      â”‚
â”‚  - ç”Ÿæˆä»£ç                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä½å±‚å®ç°ï¼ˆç”Ÿæˆçš„ä»£ç ï¼‰           â”‚
â”‚  - å®Œæ•´çš„å®ç°                    â”‚
â”‚  - ç±»å‹å®‰å…¨                      â”‚
â”‚  - æ€§èƒ½ä¼˜åŒ–                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä»£ç ç”Ÿæˆçš„ä¼˜åŠ¿

1. **å‡å°‘æ ·æ¿ä»£ç **ï¼šè‡ªåŠ¨ç”Ÿæˆé‡å¤æ€§ä»£ç 
2. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶ä¿è¯ç±»å‹æ­£ç¡®æ€§
3. **ä¸€è‡´æ€§**ï¼šç»Ÿä¸€çš„ä»£ç é£æ ¼å’Œæ¨¡å¼
4. **å¯ç»´æŠ¤æ€§**ï¼šå•ç‚¹ä¿®æ”¹ï¼Œå…¨å±€ç”Ÿæ•ˆ
5. **æ€§èƒ½**ï¼šç¼–è¯‘æ—¶å¤„ç†ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€

---

## å£°æ˜å¼ä»£ç ç”Ÿæˆ

### åŸºæœ¬æ¨¡å¼

#### 1. é‡å¤å±•å¼€æ¨¡å¼

```rust
macro_rules! repeat_n {
    ($n:expr, $code:expr) => {{
        let mut result = Vec::new();
        for _ in 0..$n {
            result.push($code);
        }
        result
    }};
}

// ä½¿ç”¨
let values = repeat_n!(5, rand::random::<i32>());
```

#### 2. ç±»å‹æ´¾ç”Ÿæ¨¡å¼

```rust
macro_rules! impl_display {
    ($type:ty) => {
        impl std::fmt::Display for $type {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "{:?}", self)
            }
        }
    };
}

impl_display!(MyStruct);
```

#### 3. ä»£ç å—ç”Ÿæˆ

```rust
macro_rules! generate_accessor {
    ($struct_name:ident, $($field:ident: $type:ty),*) => {
        impl $struct_name {
            $(
                pub fn $field(&self) -> &$type {
                    &self.$field
                }
                
                paste::paste! {
                    pub fn [<set_ $field>](&mut self, value: $type) {
                        self.$field = value;
                    }
                }
            )*
        }
    };
}

// ä½¿ç”¨
struct User {
    name: String,
    age: u32,
}

generate_accessor!(User, name: String, age: u32);
```

### é«˜çº§æ¨¡å¼

#### 1. åµŒå¥—ä»£ç ç”Ÿæˆ

```rust
macro_rules! generate_nested {
    (
        struct $name:ident {
            $($field:ident: $type:ty),* $(,)?
        }
    ) => {
        // ç”Ÿæˆç»“æ„ä½“
        struct $name {
            $($field: $type),*
        }
        
        // ç”Ÿæˆæ„é€ å™¨
        impl $name {
            pub fn new($($field: $type),*) -> Self {
                Self { $($field),* }
            }
        }
        
        // ç”Ÿæˆè®¿é—®å™¨
        impl $name {
            $(
                paste::paste! {
                    pub fn $field(&self) -> &$type {
                        &self.$field
                    }
                    
                    pub fn [<$field _mut>](&mut self) -> &mut $type {
                        &mut self.$field
                    }
                }
            )*
        }
    };
}

// ä½¿ç”¨
generate_nested! {
    struct Point {
        x: f64,
        y: f64,
    }
}
```

#### 2. æ¡ä»¶ä»£ç ç”Ÿæˆ

```rust
macro_rules! conditional_impl {
    (
        $(#[$attr:meta])*
        $vis:vis struct $name:ident {
            $($field:ident: $type:ty),* $(,)?
        }
        
        $(impl $trait:ident)?
    ) => {
        $(#[$attr])*
        $vis struct $name {
            $($field: $type),*
        }
        
        $(
            impl $trait for $name {
                // æ ¹æ®traitç”Ÿæˆä¸åŒå®ç°
            }
        )?
    };
}
```

---

## è¿‡ç¨‹å®ä»£ç ç”Ÿæˆ

### Derive å®ç”Ÿæˆ

#### å®Œæ•´çš„ Builder ç”Ÿæˆå™¨

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Data, DeriveInput, Fields};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let builder_name = format_ident!("{}Builder", name);
    
    // æå–å­—æ®µä¿¡æ¯
    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => panic!("Builder only supports named fields"),
        },
        _ => panic!("Builder only supports structs"),
    };
    
    // ç”Ÿæˆ Builder ç»“æ„ä½“å­—æ®µï¼ˆæ‰€æœ‰å­—æ®µéƒ½æ˜¯ Optionï¼‰
    let builder_fields = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! { #name: Option<#ty> }
    });
    
    // ç”Ÿæˆ setter æ–¹æ³•
    let setters = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! {
            pub fn #name(mut self, #name: #ty) -> Self {
                self.#name = Some(#name);
                self
            }
        }
    });
    
    // ç”Ÿæˆ build æ–¹æ³•
    let build_fields = fields.iter().map(|f| {
        let name = &f.ident;
        quote! {
            #name: self.#name.ok_or(concat!(
                "Field '",
                stringify!(#name),
                "' is required"
            ))?
        }
    });
    
    // ç”Ÿæˆå®Œæ•´ä»£ç 
    let expanded = quote! {
        pub struct #builder_name {
            #(#builder_fields),*
        }
        
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name {
                    #(#fields: None),*
                }
            }
        }
        
        impl #builder_name {
            #(#setters)*
            
            pub fn build(self) -> Result<#name, &'static str> {
                Ok(#name {
                    #(#build_fields),*
                })
            }
        }
    };
    
    TokenStream::from(expanded)
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```rust
#[derive(Builder)]
struct ServerConfig {
    host: String,
    port: u16,
    ssl_enabled: bool,
    max_connections: usize,
}

// ç”Ÿæˆçš„ä»£ç å¯ä»¥è¿™æ ·ä½¿ç”¨ï¼š
let config = ServerConfig::builder()
    .host("localhost".to_string())
    .port(8080)
    .ssl_enabled(true)
    .max_connections(1000)
    .build()
    .expect("Failed to build config");
```

### Attribute å®ç”Ÿæˆ

#### æ€§èƒ½ç›‘æ§å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn timed(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let body = &input.block;
    let sig = &input.sig;
    let vis = &input.vis;
    let attrs = &input.attrs;
    
    let expanded = quote! {
        #(#attrs)*
        #vis #sig {
            let _timer = {
                let start = std::time::Instant::now();
                struct Timer<'a> {
                    name: &'a str,
                    start: std::time::Instant,
                }
                impl<'a> Drop for Timer<'a> {
                    fn drop(&mut self) {
                        let duration = self.start.elapsed();
                        eprintln!(
                            "[TIMING] {} took {:.2?}",
                            self.name,
                            duration
                        );
                    }
                }
                Timer {
                    name: stringify!(#name),
                    start,
                }
            };
            
            #body
        }
    };
    
    TokenStream::from(expanded)
}
```

#### ä½¿ç”¨ç¤ºä¾‹1

```rust
#[timed]
fn expensive_computation(n: usize) -> u64 {
    (0..n).map(|x| x as u64).sum()
}

// è°ƒç”¨æ—¶ä¼šè‡ªåŠ¨æ‰“å°æ‰§è¡Œæ—¶é—´
expensive_computation(1_000_000);
// è¾“å‡º: [TIMING] expensive_computation took 2.34ms
```

### Function-like å®ç”Ÿæˆ

#### SQL æŸ¥è¯¢ç”Ÿæˆå™¨

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, parse::Parse, parse::ParseStream, Ident, Token};

struct SqlQuery {
    table: Ident,
    fields: Vec<Ident>,
}

impl Parse for SqlQuery {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        input.parse::<Token![SELECT]>()?;
        
        let mut fields = Vec::new();
        loop {
            fields.push(input.parse::<Ident>()?);
            if input.parse::<Token![,]>().is_err() {
                break;
            }
        }
        
        input.parse::<Token![FROM]>()?;
        let table = input.parse::<Ident>()?;
        
        Ok(SqlQuery { table, fields })
    }
}

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let query = parse_macro_input!(input as SqlQuery);
    let table = &query.table;
    let fields = &query.fields;
    
    let field_names = fields.iter()
        .map(|f| f.to_string())
        .collect::<Vec<_>>()
        .join(", ");
    
    let expanded = quote! {
        {
            let query = format!(
                "SELECT {} FROM {}",
                #field_names,
                stringify!(#table)
            );
            
            // ç”Ÿæˆç±»å‹å®‰å…¨çš„æŸ¥è¯¢ç»“æ„
            struct Query;
            impl Query {
                fn execute(&self) -> Result<Vec<Row>, Error> {
                    // æ‰§è¡ŒæŸ¥è¯¢é€»è¾‘
                    todo!()
                }
            }
            
            Query
        }
    };
    
    TokenStream::from(expanded)
}
```

---

## ä»£ç æ¨¡æ¿ç³»ç»Ÿ

### æ¨¡æ¿å¼•æ“è®¾è®¡

```rust
use quote::quote;

pub struct CodeTemplate {
    name: String,
    params: Vec<(String, String)>, // (name, type)
    body: String,
}

impl CodeTemplate {
    pub fn generate(&self) -> proc_macro2::TokenStream {
        let name = format_ident!("{}", self.name);
        
        let params = self.params.iter().map(|(n, t)| {
            let param_name = format_ident!("{}", n);
            let param_type = format_ident!("{}", t);
            quote! { #param_name: #param_type }
        });
        
        quote! {
            pub fn #name(#(#params),*) -> Result<(), Error> {
                // æ¨¡æ¿ä½“
            }
        }
    }
}
```

### æ¨¡æ¿ç»„åˆ

```rust
pub struct CompositeTemplate {
    templates: Vec<CodeTemplate>,
}

impl CompositeTemplate {
    pub fn add_template(&mut self, template: CodeTemplate) {
        self.templates.push(template);
    }
    
    pub fn generate_all(&self) -> proc_macro2::TokenStream {
        let generated = self.templates
            .iter()
            .map(|t| t.generate());
        
        quote! {
            #(#generated)*
        }
    }
}
```

---

## ç±»å‹é©±åŠ¨ç”Ÿæˆ

### åŸºäºç±»å‹ä¿¡æ¯çš„ä»£ç ç”Ÿæˆ

```rust
use syn::{Type, TypePath};

fn generate_serializer(ty: &Type) -> proc_macro2::TokenStream {
    match ty {
        Type::Path(TypePath { path, .. }) => {
            let ident = &path.segments.last().unwrap().ident;
            
            match ident.to_string().as_str() {
                "String" => quote! {
                    fn serialize(&self) -> Vec<u8> {
                        self.as_bytes().to_vec()
                    }
                },
                "i32" | "u32" | "i64" | "u64" => quote! {
                    fn serialize(&self) -> Vec<u8> {
                        self.to_le_bytes().to_vec()
                    }
                },
                _ => quote! {
                    fn serialize(&self) -> Vec<u8> {
                        bincode::serialize(self).unwrap()
                    }
                },
            }
        }
        _ => panic!("Unsupported type"),
    }
}
```

### æ³›å‹ä»£ç ç”Ÿæˆ

```rust
fn generate_generic_impl(
    name: &Ident,
    generics: &syn::Generics,
) -> proc_macro2::TokenStream {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    
    quote! {
        impl #impl_generics MyTrait for #name #ty_generics #where_clause {
            fn process(&self) -> String {
                format!("{:?}", self)
            }
        }
    }
}
```

---

## å…ƒæ•°æ®é©±åŠ¨ç”Ÿæˆ

### å±æ€§è§£æ

```rust
use syn::{Attribute, Meta, NestedMeta};

fn parse_attributes(attrs: &[Attribute]) -> HashMap<String, String> {
    let mut config = HashMap::new();
    
    for attr in attrs {
        if attr.path.is_ident("config") {
            if let Ok(Meta::List(meta_list)) = attr.parse_meta() {
                for nested in meta_list.nested {
                    if let NestedMeta::Meta(Meta::NameValue(nv)) = nested {
                        if let Some(ident) = nv.path.get_ident() {
                            if let syn::Lit::Str(lit) = &nv.lit {
                                config.insert(
                                    ident.to_string(),
                                    lit.value()
                                );
                            }
                        }
                    }
                }
            }
        }
    }
    
    config
}

// ä½¿ç”¨
#[config(db = "postgres", cache = "redis")]
struct AppConfig;
```

### é…ç½®é©±åŠ¨ç”Ÿæˆ

```rust
fn generate_from_config(config: &HashMap<String, String>) -> TokenStream {
    let db_type = config.get("db").unwrap();
    let cache_type = config.get("cache").unwrap();
    
    let db_impl = match db_type.as_str() {
        "postgres" => quote! {
            use sqlx::PgPool;
            type DbPool = PgPool;
        },
        "mysql" => quote! {
            use sqlx::MySqlPool;
            type DbPool = MySqlPool;
        },
        _ => panic!("Unsupported database"),
    };
    
    let cache_impl = match cache_type.as_str() {
        "redis" => quote! {
            use redis::Client as CacheClient;
        },
        "memcached" => quote! {
            use memcache::Client as CacheClient;
        },
        _ => panic!("Unsupported cache"),
    };
    
    quote! {
        #db_impl
        #cache_impl
        
        pub struct App {
            db: DbPool,
            cache: CacheClient,
        }
    }
    .into()
}
```

---

## å¢é‡ä»£ç ç”Ÿæˆ

### æ¡ä»¶ç¼–è¯‘

```rust
#[proc_macro_attribute]
pub fn conditional_generate(attr: TokenStream, item: TokenStream) -> TokenStream {
    let condition = attr.to_string();
    let input = parse_macro_input!(item as ItemStruct);
    
    let expanded = if condition == "debug" {
        quote! {
            #[cfg(debug_assertions)]
            #input
        }
    } else {
        quote! {
            #[cfg(not(debug_assertions))]
            #input
        }
    };
    
    TokenStream::from(expanded)
}
```

### ç‰¹æ€§é—¨æ§

```rust
fn generate_with_features(features: &[String]) -> TokenStream {
    let impls = features.iter().map(|feature| {
        let feature_ident = format_ident!("{}", feature);
        quote! {
            #[cfg(feature = #feature)]
            impl MyTrait for #feature_ident {
                fn process(&self) { /* ... */ }
            }
        }
    });
    
    quote! {
        #(#impls)*
    }
    .into()
}
```

---

## ä»£ç ç”Ÿæˆä¼˜åŒ–

### 1. å‡å°‘ç”Ÿæˆä»£ç é‡

```rust
// âŒ ä¸ºæ¯ä¸ªå­—æ®µç”Ÿæˆç‹¬ç«‹æ–¹æ³•
macro_rules! bad_accessors {
    ($($field:ident),*) => {
        $(
            fn $field(&self) -> &String {
                &self.$field
            }
        )*
    };
}

// âœ… ä½¿ç”¨æ³›å‹å‡å°‘ä»£ç 
macro_rules! good_accessors {
    ($($field:ident: $ty:ty),*) => {
        fn get<T>(&self, name: &str) -> Option<&T> {
            match name {
                $(stringify!($field) => Some(&self.$field as &T),)*
                _ => None,
            }
        }
    };
}
```

### 2. é¿å…é‡å¤ç”Ÿæˆ

```rust
// ä½¿ç”¨ç¼“å­˜æœºåˆ¶
static GENERATED_CODE: Lazy<HashMap<String, TokenStream>> = 
    Lazy::new(HashMap::new);

#[proc_macro_derive(Cached)]
pub fn cached_derive(input: TokenStream) -> TokenStream {
    let input_str = input.to_string();
    
    if let Some(cached) = GENERATED_CODE.get(&input_str) {
        return cached.clone();
    }
    
    let generated = generate_code(&input);
    GENERATED_CODE.insert(input_str, generated.clone());
    generated
}
```

### 3. å»¶è¿Ÿç”Ÿæˆ

```rust
// åªåœ¨éœ€è¦æ—¶ç”Ÿæˆä»£ç 
macro_rules! lazy_generate {
    ($name:ident) => {
        mod $name {
            // ä½¿ç”¨ include! å»¶è¿ŸåŠ è½½ç”Ÿæˆçš„ä»£ç 
            include!(concat!(env!("OUT_DIR"), "/", stringify!($name), ".rs"));
        }
    };
}
```

---

## å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šORM ä»£ç ç”Ÿæˆ

```rust
#[derive(Table)]
#[table(name = "users")]
struct User {
    #[column(primary_key)]
    id: i32,
    
    #[column(unique)]
    email: String,
    
    name: String,
    
    #[column(default = "now()")]
    created_at: DateTime,
}

// ç”Ÿæˆçš„ä»£ç ï¼š
impl User {
    pub async fn find(id: i32) -> Result<Self, Error> {
        sqlx::query_as!(
            User,
            "SELECT id, email, name, created_at FROM users WHERE id = $1",
            id
        )
        .fetch_one(&pool)
        .await
    }
    
    pub async fn create(&self) -> Result<(), Error> {
        sqlx::query!(
            "INSERT INTO users (email, name) VALUES ($1, $2)",
            self.email,
            self.name
        )
        .execute(&pool)
        .await?;
        Ok(())
    }
}
```

### æ¡ˆä¾‹2ï¼šAPI è·¯ç”±ç”Ÿæˆ

```rust
#[api_routes]
mod user_api {
    #[get("/users/:id")]
    async fn get_user(id: i32) -> Result<Json<User>, Error> {
        // å¤„ç†é€»è¾‘
    }
    
    #[post("/users")]
    async fn create_user(body: Json<CreateUser>) -> Result<Json<User>, Error> {
        // å¤„ç†é€»è¾‘
    }
}

// ç”Ÿæˆçš„ä»£ç ï¼š
pub fn configure_routes(app: &mut App) {
    app.route("/users/:id", get(get_user))
       .route("/users", post(create_user));
}
```

### æ¡ˆä¾‹3ï¼šçŠ¶æ€æœºç”Ÿæˆ

```rust
state_machine! {
    enum OrderState {
        Pending => Processing | Cancelled,
        Processing => Shipped | Cancelled,
        Shipped => Delivered,
        Delivered => {},
        Cancelled => {},
    }
}

// ç”Ÿæˆçš„ä»£ç ï¼š
impl OrderState {
    pub fn transition(&mut self, event: Event) -> Result<(), Error> {
        *self = match (&self, event) {
            (Self::Pending, Event::StartProcessing) => Self::Processing,
            (Self::Pending, Event::Cancel) => Self::Cancelled,
            (Self::Processing, Event::Ship) => Self::Shipped,
            // ... å…¶ä»–è½¬æ¢
            _ => return Err(Error::InvalidTransition),
        };
        Ok(())
    }
}
```

---

## æœ€ä½³å®è·µ

### 1. ä¿æŒç”Ÿæˆä»£ç çš„å¯è¯»æ€§

```rust
// âœ… å¥½çš„å®è·µï¼šæ ¼å¼åŒ–ç”Ÿæˆçš„ä»£ç 
let expanded = quote! {
    impl MyStruct {
        pub fn method(&self) -> Result<(), Error> {
            // æ¸…æ™°çš„ç¼©è¿›
            if self.check() {
                Ok(())
            } else {
                Err(Error::CheckFailed)
            }
        }
    }
};
```

### 2. æä¾›æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯

```rust
if fields.is_empty() {
    return syn::Error::new(
        input.span(),
        "Struct must have at least one field"
    )
    .to_compile_error()
    .into();
}
```

### 3. æ–‡æ¡£åŒ–ç”Ÿæˆçš„ä»£ç 

```rust
let expanded = quote! {
    #[doc = "Auto-generated builder for `Config`"]
    pub struct ConfigBuilder {
        // ...
    }
};
```

### 4. æµ‹è¯•ç”Ÿæˆå™¨

```rust
#[test]
fn test_builder_generation() {
    let input = quote! {
        struct User {
            name: String,
            age: u32,
        }
    };
    
    let output = derive_builder(input.into());
    // éªŒè¯ç”Ÿæˆçš„ä»£ç 
}
```

---

## æ€»ç»“

ä»£ç ç”Ÿæˆæ˜¯ Rust å®ç³»ç»Ÿæœ€å¼ºå¤§çš„åº”ç”¨ä¹‹ä¸€ï¼š

- **å£°æ˜å¼ç”Ÿæˆ**ï¼šé€‚åˆç®€å•çš„æ¨¡å¼å’Œé‡å¤
- **è¿‡ç¨‹å®ç”Ÿæˆ**ï¼šæä¾›æœ€å¤§çš„çµæ´»æ€§å’Œæ§åˆ¶
- **æ¨¡æ¿ç³»ç»Ÿ**ï¼šæœ‰åŠ©äºç»„ç»‡å¤æ‚çš„ç”Ÿæˆé€»è¾‘
- **ç±»å‹é©±åŠ¨**ï¼šåˆ©ç”¨ç±»å‹ä¿¡æ¯ç”Ÿæˆç²¾ç¡®çš„ä»£ç 
- **å…ƒæ•°æ®é©±åŠ¨**ï¼šé€šè¿‡é…ç½®æ§åˆ¶ç”Ÿæˆè¡Œä¸º
- **å¢é‡ç”Ÿæˆ**ï¼šä¼˜åŒ–ç¼–è¯‘æ—¶é—´å’Œä»£ç å¤§å°

æŒæ¡è¿™äº›æŠ€æœ¯ï¼Œä½ å¯ä»¥æ„å»ºå¼ºå¤§çš„ä»£ç ç”Ÿæˆå·¥å…·ï¼Œå¤§å¹…æå‡å¼€å‘æ•ˆç‡ï¼

## ç›¸å…³èµ„æº

- [macro_metaprogramming.md](./macro_metaprogramming.md) - å…ƒç¼–ç¨‹åŸºç¡€
- [dsl_construction.md](./dsl_construction.md) - DSL æ„å»ºæŠ€æœ¯
- [macro_optimization.md](./macro_optimization.md) - æ€§èƒ½ä¼˜åŒ–
