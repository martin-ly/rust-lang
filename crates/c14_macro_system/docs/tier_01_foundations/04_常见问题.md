# å¸¸è§é—®é¢˜ (FAQ) - C14 Macro System

**æœ€åæ›´æ–°**: 2025-10-24

æœ¬æ–‡æ¡£æ±‡æ€»äº† Rust å®ç³»ç»Ÿä¸­çš„å¸¸è§é—®é¢˜å’Œè§£ç­”ã€‚

---

## ğŸ“‹ ç›®å½•

- [å¸¸è§é—®é¢˜ (FAQ) - C14 Macro System](#å¸¸è§é—®é¢˜-faq---c14-macro-system)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¨ å®åŸºç¡€é—®é¢˜](#-å®åŸºç¡€é—®é¢˜)
    - [Q1: å£°æ˜å® vs. è¿‡ç¨‹å®ï¼Œä½•æ—¶ä½¿ç”¨å“ªä¸ªï¼Ÿ](#q1-å£°æ˜å®-vs-è¿‡ç¨‹å®ä½•æ—¶ä½¿ç”¨å“ªä¸ª)
    - [Q2: å®ä¸å‡½æ•°çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ](#q2-å®ä¸å‡½æ•°çš„åŒºåˆ«æ˜¯ä»€ä¹ˆ)
    - [Q3: å®ä¼šå½±å“æ€§èƒ½å—ï¼Ÿ](#q3-å®ä¼šå½±å“æ€§èƒ½å—)
  - [ğŸ”§ å£°æ˜å®é—®é¢˜](#-å£°æ˜å®é—®é¢˜)
    - [Q4: å¦‚ä½•è°ƒè¯•å£°æ˜å®ï¼Ÿ](#q4-å¦‚ä½•è°ƒè¯•å£°æ˜å®)
    - [Q5: å£°æ˜å®çš„å«ç”Ÿæ€§å¦‚ä½•å·¥ä½œï¼Ÿ](#q5-å£°æ˜å®çš„å«ç”Ÿæ€§å¦‚ä½•å·¥ä½œ)
    - [Q6: å¦‚ä½•å¤„ç†å®çš„å¤šä¸ªåˆ†æ”¯ï¼Ÿ](#q6-å¦‚ä½•å¤„ç†å®çš„å¤šä¸ªåˆ†æ”¯)
  - [âš™ï¸ è¿‡ç¨‹å®é—®é¢˜](#ï¸-è¿‡ç¨‹å®é—®é¢˜)
    - [Q7: å¦‚ä½•å¼€å§‹å†™ç¬¬ä¸€ä¸ªè¿‡ç¨‹å®ï¼Ÿ](#q7-å¦‚ä½•å¼€å§‹å†™ç¬¬ä¸€ä¸ªè¿‡ç¨‹å®)
    - [Q8: syn å’Œ quote æ˜¯å¿…é¡»çš„å—ï¼Ÿ](#q8-syn-å’Œ-quote-æ˜¯å¿…é¡»çš„å—)
    - [Q9: å¦‚ä½•æµ‹è¯•è¿‡ç¨‹å®ï¼Ÿ](#q9-å¦‚ä½•æµ‹è¯•è¿‡ç¨‹å®)
    - [Q10: è¿‡ç¨‹å®å¯ä»¥è¯»å–æ–‡ä»¶å—ï¼Ÿ](#q10-è¿‡ç¨‹å®å¯ä»¥è¯»å–æ–‡ä»¶å—)
  - [ğŸ› ï¸ å·¥ç¨‹å®è·µé—®é¢˜](#ï¸-å·¥ç¨‹å®è·µé—®é¢˜)
    - [Q11: å¦‚ä½•ç»„ç»‡å®é¡¹ç›®ç»“æ„ï¼Ÿ](#q11-å¦‚ä½•ç»„ç»‡å®é¡¹ç›®ç»“æ„)
    - [Q12: å®çš„é”™è¯¯æ¶ˆæ¯å¦‚ä½•ä¼˜åŒ–ï¼Ÿ](#q12-å®çš„é”™è¯¯æ¶ˆæ¯å¦‚ä½•ä¼˜åŒ–)
    - [Q13: å¦‚ä½•å‘å¸ƒå®åº“ï¼Ÿ](#q13-å¦‚ä½•å‘å¸ƒå®åº“)
  - [ğŸ› æ•…éšœæ’æŸ¥é—®é¢˜](#-æ•…éšœæ’æŸ¥é—®é¢˜)
    - [Q14: "recursion limit reached" é”™è¯¯å¦‚ä½•è§£å†³ï¼Ÿ](#q14-recursion-limit-reached-é”™è¯¯å¦‚ä½•è§£å†³)
    - [Q15: "cannot find macro" é”™è¯¯å¦‚ä½•è§£å†³ï¼Ÿ](#q15-cannot-find-macro-é”™è¯¯å¦‚ä½•è§£å†³)
    - [Q16: ä¸ºä»€ä¹ˆå®å±•å¼€åæœ‰ç¼–è¯‘é”™è¯¯ï¼Ÿ](#q16-ä¸ºä»€ä¹ˆå®å±•å¼€åæœ‰ç¼–è¯‘é”™è¯¯)
  - [ğŸ’¡ é«˜çº§è¯é¢˜](#-é«˜çº§è¯é¢˜)
    - [Q17: å¦‚ä½•æ„å»º DSLï¼Ÿ](#q17-å¦‚ä½•æ„å»º-dsl)
    - [Q18: å®å¯ä»¥ç”Ÿæˆå®å—ï¼Ÿ](#q18-å®å¯ä»¥ç”Ÿæˆå®å—)
    - [Q19: å¦‚ä½•å®ç°é›¶æˆæœ¬æŠ½è±¡ï¼Ÿ](#q19-å¦‚ä½•å®ç°é›¶æˆæœ¬æŠ½è±¡)

---

## ğŸ¨ å®åŸºç¡€é—®é¢˜

### Q1: å£°æ˜å® vs. è¿‡ç¨‹å®ï¼Œä½•æ—¶ä½¿ç”¨å“ªä¸ªï¼Ÿ

**å£°æ˜å®** (`macro_rules!`) é€‚ç”¨äºï¼š

- ç®€å•çš„ä»£ç æ¨¡å¼
- å¿«é€ŸåŸå‹
- ä¸éœ€è¦å¤æ‚è§£æ

```rust
macro_rules! vec_of_strings {
    ($($element:expr),*) => {
        vec![$(String::from($element)),*]
    };
}
```

**è¿‡ç¨‹å®** é€‚ç”¨äºï¼š

- å¤æ‚çš„ä»£ç ç”Ÿæˆ
- Derive å®ç°
- éœ€è¦ç²¾ç¡®æ§åˆ¶

```rust
#[derive(MyTrait)]
struct MyStruct { }
```

**å»ºè®®**: ä¼˜å…ˆå°è¯•å£°æ˜å®ï¼Œå¤æ‚éœ€æ±‚å†ç”¨è¿‡ç¨‹å®ã€‚

---

### Q2: å®ä¸å‡½æ•°çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

| ç‰¹æ€§ | å® | å‡½æ•° |
|------|---|------|
| æ‰§è¡Œæ—¶æœº | ç¼–è¯‘æ—¶ | è¿è¡Œæ—¶ |
| è¾“å…¥ | TokenStream/è¯­æ³•æ ‘ | å€¼ |
| è¾“å‡º | ä»£ç  | å€¼ |
| ç±»å‹æ£€æŸ¥ | å±•å¼€å | è°ƒç”¨æ—¶ |
| æ€§èƒ½ | é›¶æˆæœ¬ | æœ‰è°ƒç”¨å¼€é”€ |
| è°ƒè¯• | å›°éš¾ | å®¹æ˜“ |

**ç¤ºä¾‹**:

```rust
// å®ï¼šç¼–è¯‘æ—¶å±•å¼€
macro_rules! five {
    () => { 5 };
}
let x = five!(); // å±•å¼€ä¸º let x = 5;

// å‡½æ•°ï¼šè¿è¡Œæ—¶è°ƒç”¨
fn five() -> i32 { 5 }
let x = five(); // è¿è¡Œæ—¶è°ƒç”¨å‡½æ•°
```

---

### Q3: å®ä¼šå½±å“æ€§èƒ½å—ï¼Ÿ

**ç¼–è¯‘æ—¶**: ä¼šå¢åŠ ç¼–è¯‘æ—¶é—´

- å®å±•å¼€éœ€è¦æ—¶é—´
- å¤æ‚å®å½±å“æ›´å¤§

**è¿è¡Œæ—¶**: é›¶æ€§èƒ½å¼€é”€

- å®å®Œå…¨å±•å¼€ä¸ºä»£ç 
- ä¸æ‰‹å†™ä»£ç ç›¸åŒ

```rust
// å®ç‰ˆæœ¬
let v = vec![1, 2, 3];

// æ‰‹å†™ç­‰ä»·ä»£ç 
let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
let v = temp_vec;

// æ€§èƒ½å®Œå…¨ç›¸åŒï¼
```

**å»ºè®®**: åˆç†ä½¿ç”¨å®ï¼Œé¿å…è¿‡åº¦åµŒå¥—ã€‚

---

## ğŸ”§ å£°æ˜å®é—®é¢˜

### Q4: å¦‚ä½•è°ƒè¯•å£°æ˜å®ï¼Ÿ

**æ–¹æ³• 1**: ä½¿ç”¨ `cargo expand`

```bash
cargo install cargo-expand
cargo expand my_module
```

**æ–¹æ³• 2**: ä½¿ç”¨ `dbg!` å’Œ `stringify!`

```rust
macro_rules! debug_macro {
    ($($tt:tt)*) => {
        {
            println!("Expanded: {}", stringify!($($tt)*));
            $($tt)*
        }
    };
}
```

**æ–¹æ³• 3**: é€æ­¥ç®€åŒ–

```rust
// 1. å…ˆç”¨ç®€å•è¾“å…¥æµ‹è¯•
my_macro!(x);

// 2. é€æ­¥å¢åŠ å¤æ‚åº¦
my_macro!(x, y);
my_macro!(x, y, z);
```

---

### Q5: å£°æ˜å®çš„å«ç”Ÿæ€§å¦‚ä½•å·¥ä½œï¼Ÿ

**å«ç”Ÿæ€§è§„åˆ™**:

1. å®å†…å®šä¹‰çš„å˜é‡ä¸æ³„éœ²åˆ°å¤–éƒ¨
2. å®å¤–çš„å˜é‡åœ¨å®å†…å¯è§ï¼ˆå¦‚æœæ˜¾å¼å¼•ç”¨ï¼‰

```rust
macro_rules! using_a {
    ($e:expr) => {
        {
            let a = 42; // å±€éƒ¨å˜é‡ï¼Œä¸å½±å“å¤–éƒ¨
            $e
        }
    }
}

let a = 13;
let result = using_a!(a + a); // 26ï¼Œä½¿ç”¨å¤–éƒ¨ a
println!("a = {}", a); // 13ï¼Œå¤–éƒ¨ a æœªå˜
```

**æ‰“ç ´å«ç”Ÿæ€§** (ä¸æ¨è):

```rust
macro_rules! break_hygiene {
    () => {
        let __internal_var = 42; // å¯èƒ½å†²çª
    };
}
```

---

### Q6: å¦‚ä½•å¤„ç†å®çš„å¤šä¸ªåˆ†æ”¯ï¼Ÿ

ä½¿ç”¨æ¨¡å¼åŒ¹é…çš„å¤šä¸ªåˆ†æ”¯ï¼š

```rust
macro_rules! calculate {
    // åŠ æ³•
    ($a:expr + $b:expr) => {
        $a + $b
    };
    
    // ä¹˜æ³•
    ($a:expr * $b:expr) => {
        $a * $b
    };
    
    // å•ä¸ªå€¼
    ($e:expr) => {
        $e
    };
}

let x = calculate!(2 + 3);  // 5
let y = calculate!(2 * 3);  // 6
let z = calculate!(42);     // 42
```

**æ³¨æ„**: æ›´å…·ä½“çš„æ¨¡å¼æ”¾åœ¨å‰é¢ã€‚

---

## âš™ï¸ è¿‡ç¨‹å®é—®é¢˜

### Q7: å¦‚ä½•å¼€å§‹å†™ç¬¬ä¸€ä¸ªè¿‡ç¨‹å®ï¼Ÿ

**æ­¥éª¤ 1**: åˆ›å»ºåº“é¡¹ç›®

```bash
cargo new my_macro --lib
```

**æ­¥éª¤ 2**: é…ç½® `Cargo.toml`

```toml
[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
```

**æ­¥éª¤ 3**: ç¼–å†™å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    
    let expanded = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    
    TokenStream::from(expanded)
}
```

---

### Q8: syn å’Œ quote æ˜¯å¿…é¡»çš„å—ï¼Ÿ

**ä¸æ˜¯å¿…é¡»**ï¼Œä½†å¼ºçƒˆæ¨èï¼š

**ä¸ä½¿ç”¨ syn/quote** (å›°éš¾):

```rust
#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // æ‰‹åŠ¨è§£æ TokenStreamï¼Œéå¸¸ç¹ç
    let tokens: Vec<_> = input.into_iter().collect();
    // ... å¤æ‚çš„è§£æé€»è¾‘
}
```

**ä½¿ç”¨ syn/quote** (ç®€å•):

```rust
#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let expanded = quote! { /* ä»£ç  */ };
    TokenStream::from(expanded)
}
```

**å»ºè®®**: é™¤éç‰¹æ®Šéœ€æ±‚ï¼Œå¦åˆ™ä½¿ç”¨ syn/quoteã€‚

---

### Q9: å¦‚ä½•æµ‹è¯•è¿‡ç¨‹å®ï¼Ÿ

**æ–¹æ³• 1**: é›†æˆæµ‹è¯•

```rust
// tests/integration.rs
use my_macro::MyMacro;

#[derive(MyMacro)]
struct TestStruct;

#[test]
fn test_macro() {
    // éªŒè¯å®ç”Ÿæˆçš„ä»£ç 
}
```

**æ–¹æ³• 2**: trybuild (æµ‹è¯•ç¼–è¯‘é”™è¯¯)

```rust
#[test]
fn ui_tests() {
    let t = trybuild::TestCases::new();
    t.pass("tests/ui/pass/*.rs");
    t.compile_fail("tests/ui/fail/*.rs");
}
```

**æ–¹æ³• 3**: macrotest (å¿«ç…§æµ‹è¯•)

```rust
#[test]
fn test_macro_expansion() {
    macrotest::expand("tests/expand/*.rs");
}
```

---

### Q10: è¿‡ç¨‹å®å¯ä»¥è¯»å–æ–‡ä»¶å—ï¼Ÿ

**å¯ä»¥ï¼Œä½†éœ€è°¨æ…**:

```rust
use std::fs;

#[proc_macro]
pub fn include_config(_item: TokenStream) -> TokenStream {
    let config = fs::read_to_string("config.toml")
        .expect("Failed to read config");
    
    // å¤„ç†é…ç½®...
}
```

**æ³¨æ„äº‹é¡¹**:

1. **è·¯å¾„é—®é¢˜**: ä½¿ç”¨ `CARGO_MANIFEST_DIR` ç¯å¢ƒå˜é‡
2. **ç¼“å­˜é—®é¢˜**: cargo å¯èƒ½ä¸ä¼šé‡æ–°ç¼–è¯‘
3. **å¯ç§»æ¤æ€§**: æ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨

**æ›´å¥½çš„æ–¹æ¡ˆ**: ä½¿ç”¨ `include_str!` æˆ– build scriptã€‚

---

## ğŸ› ï¸ å·¥ç¨‹å®è·µé—®é¢˜

### Q11: å¦‚ä½•ç»„ç»‡å®é¡¹ç›®ç»“æ„ï¼Ÿ

**æ¨èç»“æ„**:

```text
my_project/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ my_macro/           # å®åº“
â”‚   â”œâ”€â”€ Cargo.toml      # proc-macro = true
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ my_macro_derive/    # Derive å®
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â””â”€â”€ src/                # ä¸»åº“
    â””â”€â”€ lib.rs          # é‡å¯¼å‡ºå®
```

**ä¸»åº“é‡å¯¼å‡º**:

```rust
// src/lib.rs
pub use my_macro_derive::MyDerive;

// ç”¨æˆ·åªéœ€
use my_project::MyDerive;
```

---

### Q12: å®çš„é”™è¯¯æ¶ˆæ¯å¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**æŠ€å·§ 1**: ä½¿ç”¨ `compile_error!`

```rust
macro_rules! only_two_args {
    ($a:expr, $b:expr) => { /* OK */ };
    ($($args:tt)*) => {
        compile_error!("This macro accepts exactly 2 arguments")
    };
}
```

**æŠ€å·§ 2**: ä½¿ç”¨ Span

```rust
use syn::spanned::Spanned;

let span = field.span();
return syn::Error::new(span, "Field must be public")
    .to_compile_error()
    .into();
```

**æŠ€å·§ 3**: æä¾›å»ºè®®

```rust
return syn::Error::new(
    span,
    "Missing #[id] attribute. Try: #[derive(MyTrait)] #[id(1)]"
).to_compile_error().into();
```

---

### Q13: å¦‚ä½•å‘å¸ƒå®åº“ï¼Ÿ

**æ­¥éª¤ 1**: å®Œå–„æ–‡æ¡£

```rust
//! # My Macro
//! 
//! This macro does...
//!
//! ## Example
//! 
//! ```
//! use my_macro::MyMacro;
//! 
//! #[derive(MyMacro)]
//! struct Example;
//! ```

#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // ...
}
```

**æ­¥éª¤ 2**: æ·»åŠ æµ‹è¯•

```rust
// tests/integration.rs
#[test]
fn test_basic() { /* ... */ }

#[test]
fn test_edge_cases() { /* ... */ }
```

**æ­¥éª¤ 3**: å‘å¸ƒ

```bash
cargo publish --dry-run
cargo publish
```

**å»ºè®®**:

- æä¾›ä¸°å¯Œç¤ºä¾‹
- æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯
- å®Œæ•´çš„ CI/CD

---

## ğŸ› æ•…éšœæ’æŸ¥é—®é¢˜

### Q14: "recursion limit reached" é”™è¯¯å¦‚ä½•è§£å†³ï¼Ÿ

**åŸå› **: å®é€’å½’å±•å¼€æ¬¡æ•°è¶…è¿‡é™åˆ¶ï¼ˆé»˜è®¤128ï¼‰ã€‚

**è§£å†³æ–¹æ¡ˆ 1**: å¢åŠ é€’å½’é™åˆ¶

```rust
#![recursion_limit = "256"]
```

**è§£å†³æ–¹æ¡ˆ 2**: é‡æ„å®ï¼Œå‡å°‘é€’å½’

```rust
// âŒ ä¸å¥½ï¼šæ·±åº¦é€’å½’
macro_rules! recursive {
    () => { 0 };
    ($x:tt $($rest:tt)*) => {
        1 + recursive!($($rest)*)
    };
}

// âœ… å¥½ï¼šè¿­ä»£
macro_rules! count {
    ($($x:tt)*) => {
        <[()]>::len(&[$(replace_expr!($x ())),*])
    };
}
```

---

### Q15: "cannot find macro" é”™è¯¯å¦‚ä½•è§£å†³ï¼Ÿ

**åŸå› **: å®æœªæ­£ç¡®å¯¼å…¥æˆ–å®šä¹‰ã€‚

**è§£å†³æ–¹æ¡ˆ 1**: ç¡®è®¤å®å·²å¯¼å‡º

```rust
// åº“ä¸­
#[macro_export]
macro_rules! my_macro {
    // ...
}
```

**è§£å†³æ–¹æ¡ˆ 2**: æ­£ç¡®å¯¼å…¥

```rust
// ä½¿ç”¨æ–¹
use my_crate::my_macro;

// æˆ–
#[macro_use]
extern crate my_crate;
```

**è§£å†³æ–¹æ¡ˆ 3**: æ£€æŸ¥ Cargo.toml

```toml
[dependencies]
my_crate = "1.0"
```

---

### Q16: ä¸ºä»€ä¹ˆå®å±•å¼€åæœ‰ç¼–è¯‘é”™è¯¯ï¼Ÿ

**è°ƒè¯•æ­¥éª¤**:

1. **æŸ¥çœ‹å±•å¼€ç»“æœ**

    ```bash
    cargo expand
    ```

2. **æ£€æŸ¥ç”Ÿæˆçš„ä»£ç **

    ```rust
    // ç¡®ä¿ç”Ÿæˆçš„ä»£ç æ˜¯æœ‰æ•ˆçš„ Rust ä»£ç 
    ```

3. **éªŒè¯ä½œç”¨åŸŸ**

    ```rust
    // ç¡®ä¿ä½¿ç”¨çš„ç±»å‹/trait åœ¨ä½œç”¨åŸŸå†…
    use std::fmt::Display; // å¦‚æœç”Ÿæˆçš„ä»£ç éœ€è¦
    ```

4. **æ£€æŸ¥å«ç”Ÿæ€§é—®é¢˜**

    ```rust
    // ä½¿ç”¨å®Œæ•´è·¯å¾„
    ::std::vec::Vec::new()
    ```

---

## ğŸ’¡ é«˜çº§è¯é¢˜

### Q17: å¦‚ä½•æ„å»º DSLï¼Ÿ

**æ­¥éª¤ 1**: è®¾è®¡è¯­æ³•

```rust
// ç›®æ ‡è¯­æ³•
html! {
    <div class="container">
        <h1>"Hello"</h1>
    </div>
}
```

**æ­¥éª¤ 2**: å®šä¹‰å‡½æ•°å¼å®

```rust
#[proc_macro]
pub fn html(input: TokenStream) -> TokenStream {
    // è§£æè‡ªå®šä¹‰è¯­æ³•
    // ç”Ÿæˆ Rust ä»£ç 
}
```

**æ­¥éª¤ 3**: è‡ªå®šä¹‰è§£æå™¨

```rust
struct HtmlParser {
    input: ParseStream,
}

impl HtmlParser {
    fn parse_element(&mut self) -> Element {
        // è§£æ <tag>...</tag>
    }
}
```

---

### Q18: å®å¯ä»¥ç”Ÿæˆå®å—ï¼Ÿ

**å¯ä»¥ï¼Œä½†æœ‰é™åˆ¶**:

```rust
macro_rules! make_macro {
    ($name:ident) => {
        macro_rules! $name {
            () => { println!("Hello from {}!", stringify!($name)); };
        }
    };
}

make_macro!(greet);
greet!(); // Hello from greet!
```

**é™åˆ¶**:

- åªèƒ½åœ¨åŒä¸€ä½œç”¨åŸŸ
- ä¸èƒ½è·¨ crate å¯¼å‡º

---

### Q19: å¦‚ä½•å®ç°é›¶æˆæœ¬æŠ½è±¡ï¼Ÿ

**åŸåˆ™**: å®å±•å¼€çš„ä»£ç åº”ä¸æ‰‹å†™ä»£ç ç›¸åŒã€‚

**éªŒè¯æ–¹æ³• 1**: cargo expand

```bash
cargo expand my_module
```

**éªŒè¯æ–¹æ³• 2**: LLVM IR æ¯”è¾ƒ

```bash
cargo rustc --release -- --emit llvm-ir
```

**éªŒè¯æ–¹æ³• 3**: åŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_macro(c: &mut Criterion) {
    c.bench_function("with_macro", |b| {
        b.iter(|| my_macro!(black_box(data)))
    });
    
    c.bench_function("hand_written", |b| {
        b.iter(|| hand_written(black_box(data)))
    });
}
```

**ç¤ºä¾‹**: vec! å®çš„é›¶æˆæœ¬

```rust
// å®
let v = vec![1, 2, 3];

// æ‰‹å†™
let mut temp = Vec::new();
temp.push(1);
temp.push(2);
temp.push(3);
let v = temp;

// ç”Ÿæˆå®Œå…¨ç›¸åŒçš„æœºå™¨ç ï¼
```

---

**ä¸Šä¸€æ­¥**: [æœ¯è¯­è¡¨](./03_æœ¯è¯­è¡¨.md)  
**ä¸‹ä¸€æ­¥**: [è¿›å…¥ Tier 2 å®è·µå±‚](../tier_02_guides/)
