# æœ¯è¯­è¡¨ - C14 Macro System

**æœ€åæ›´æ–°**: 2025-10-24

æœ¬æ–‡æ¡£æ±‡æ€»äº† Rust å®ç³»ç»Ÿä¸­çš„æ ¸å¿ƒæœ¯è¯­å’Œæ¦‚å¿µã€‚

---

## ğŸ“‹ ç›®å½•

- [æœ¯è¯­è¡¨ - C14 Macro System](#æœ¯è¯­è¡¨---c14-macro-system)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¨ å®ç±»å‹æœ¯è¯­](#-å®ç±»å‹æœ¯è¯­)
    - [Macro (å®)](#macro-å®)
    - [Declarative Macro (å£°æ˜å®)](#declarative-macro-å£°æ˜å®)
    - [Procedural Macro (è¿‡ç¨‹å®)](#procedural-macro-è¿‡ç¨‹å®)
  - [ğŸ”§ å£°æ˜å®æœ¯è¯­](#-å£°æ˜å®æœ¯è¯­)
    - [macro\_rules](#macro_rules)
    - [Pattern Matching (æ¨¡å¼åŒ¹é…)](#pattern-matching-æ¨¡å¼åŒ¹é…)
    - [Repetition (é‡å¤)](#repetition-é‡å¤)
    - [Metavariable (å…ƒå˜é‡)](#metavariable-å…ƒå˜é‡)
  - [âš™ï¸ è¿‡ç¨‹å®æœ¯è¯­](#ï¸-è¿‡ç¨‹å®æœ¯è¯­)
    - [TokenStream](#tokenstream)
    - [Derive Macro (æ´¾ç”Ÿå®)](#derive-macro-æ´¾ç”Ÿå®)
    - [Attribute Macro (å±æ€§å®)](#attribute-macro-å±æ€§å®)
    - [Function-like Macro (å‡½æ•°å¼å®)](#function-like-macro-å‡½æ•°å¼å®)
    - [syn Crate](#syn-crate)
    - [quote Crate](#quote-crate)
    - [Span](#span)
  - [ğŸ§¹ å«ç”Ÿæ€§ä¸ä½œç”¨åŸŸ](#-å«ç”Ÿæ€§ä¸ä½œç”¨åŸŸ)
    - [Hygiene (å«ç”Ÿæ€§)](#hygiene-å«ç”Ÿæ€§)
    - [Call Site (è°ƒç”¨ç‚¹)](#call-site-è°ƒç”¨ç‚¹)
    - [Definition Site (å®šä¹‰ç‚¹)](#definition-site-å®šä¹‰ç‚¹)
    - [Mixed Site (æ··åˆç‚¹)](#mixed-site-æ··åˆç‚¹)
  - [ğŸ› ï¸ å·¥å…·ä¸åº“](#ï¸-å·¥å…·ä¸åº“)
    - [cargo-expand](#cargo-expand)
    - [proc-macro2](#proc-macro2)
    - [trybuild](#trybuild)
  - [ğŸ“š å…ƒç¼–ç¨‹æ¦‚å¿µ](#-å…ƒç¼–ç¨‹æ¦‚å¿µ)
    - [Metaprogramming (å…ƒç¼–ç¨‹)](#metaprogramming-å…ƒç¼–ç¨‹)
    - [AST (æŠ½è±¡è¯­æ³•æ ‘)](#ast-æŠ½è±¡è¯­æ³•æ ‘)
    - [DSL (é¢†åŸŸç‰¹å®šè¯­è¨€)](#dsl-é¢†åŸŸç‰¹å®šè¯­è¨€)
    - [Code Generation (ä»£ç ç”Ÿæˆ)](#code-generation-ä»£ç ç”Ÿæˆ)
    - [Zero-Cost Abstraction (é›¶æˆæœ¬æŠ½è±¡)](#zero-cost-abstraction-é›¶æˆæœ¬æŠ½è±¡)
    - [Compile-time Computation (ç¼–è¯‘æ—¶è®¡ç®—)](#compile-time-computation-ç¼–è¯‘æ—¶è®¡ç®—)

---

## ğŸ¨ å®ç±»å‹æœ¯è¯­

### Macro (å®)

ç¼–è¯‘æ—¶æ‰§è¡Œçš„ä»£ç ç”Ÿæˆæœºåˆ¶ï¼Œåœ¨ç¼–è¯‘å‰å±•å¼€ä¸º Rust ä»£ç ã€‚

**åˆ†ç±»**:

- **å£°æ˜å®** (Declarative Macros): `macro_rules!`
- **è¿‡ç¨‹å®** (Procedural Macros): è‡ªå®šä¹‰ deriveã€å±æ€§å®ã€å‡½æ•°å¼å®

**ç‰¹ç‚¹**:

- ç¼–è¯‘æ—¶å±•å¼€
- é›¶è¿è¡Œæ—¶å¼€é”€
- ç±»å‹å®‰å…¨

---

### Declarative Macro (å£°æ˜å®)

ä½¿ç”¨ `macro_rules!` å®šä¹‰çš„æ¨¡å¼åŒ¹é…å®ã€‚

```rust
macro_rules! vec_of_strings {
    ($($element:expr),*) => {
        vec![$(String::from($element)),*]
    };
}
```

**ç‰¹ç‚¹**:

- è¯­æ³•ç®€æ´
- æ¨¡å¼åŒ¹é…
- å«ç”Ÿæ€§ä¿è¯

---

### Procedural Macro (è¿‡ç¨‹å®)

ä½¿ç”¨ Rust ä»£ç å¤„ç† TokenStream çš„å®ã€‚

**ä¸‰ç§ç±»å‹**:

1. **Derive å®**: `#[derive(MyTrait)]`
2. **å±æ€§å®**: `#[my_attribute]`
3. **å‡½æ•°å¼å®**: `my_macro!(input)`

```rust
#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    // å¤„ç† TokenStream
}
```

---

## ğŸ”§ å£°æ˜å®æœ¯è¯­

### macro_rules

å®šä¹‰å£°æ˜å®çš„å…³é”®å­—ã€‚

```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}
```

---

### Pattern Matching (æ¨¡å¼åŒ¹é…)

å®çš„å‚æ•°åŒ¹é…è§„åˆ™ã€‚

**ç‰‡æ®µè¯´æ˜ç¬¦** (Fragment Specifiers):

- `$name:expr` - è¡¨è¾¾å¼
- `$name:ident` - æ ‡è¯†ç¬¦
- `$name:ty` - ç±»å‹
- `$name:pat` - æ¨¡å¼
- `$name:stmt` - è¯­å¥
- `$name:block` - ä»£ç å—
- `$name:item` - é¡¹ï¼ˆå‡½æ•°ã€ç»“æ„ä½“ç­‰ï¼‰
- `$name:tt` - å•ä¸ª token æ ‘

```rust
macro_rules! create_function {
    ($func_name:ident) => {
        fn $func_name() {
            println!("Called {}", stringify!($func_name));
        }
    };
}
```

---

### Repetition (é‡å¤)

å®å‚æ•°çš„é‡å¤æ¨¡å¼ã€‚

**è¯­æ³•**: `$(...)*` æˆ– `$(...)+` æˆ– `$(...)?`

```rust
macro_rules! sum {
    ($($num:expr),*) => {
        0 $(+ $num)*
    };
}

let result = sum!(1, 2, 3, 4); // 10
```

**ç¬¦å·å«ä¹‰**:

- `*` - é›¶æ¬¡æˆ–å¤šæ¬¡
- `+` - ä¸€æ¬¡æˆ–å¤šæ¬¡
- `?` - é›¶æ¬¡æˆ–ä¸€æ¬¡

---

### Metavariable (å…ƒå˜é‡)

å®æ¨¡å¼ä¸­æ•è·çš„å˜é‡ï¼Œå¦‚ `$name`ã€‚

```rust
macro_rules! create_var {
    ($var_name:ident, $var_value:expr) => {
        let $var_name = $var_value;
    };
}

create_var!(x, 42); // let x = 42;
```

---

## âš™ï¸ è¿‡ç¨‹å®æœ¯è¯­

### TokenStream

å®è¾“å…¥å’Œè¾“å‡ºçš„ token æµã€‚

```rust
use proc_macro::TokenStream;

#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // å¤„ç† inputï¼Œè¿”å›æ–°çš„ TokenStream
    input
}
```

**ç‰¹ç‚¹**:

- è¡¨ç¤ºä»£ç çš„ token åºåˆ—
- å¯è§£æã€ä¿®æ”¹ã€ç”Ÿæˆ

---

### Derive Macro (æ´¾ç”Ÿå®)

è‡ªåŠ¨ä¸ºç±»å‹å®ç° trait çš„å®ã€‚

```rust
#[derive(Debug, Clone, MyTrait)]
struct MyStruct {
    field: i32,
}
```

**å®šä¹‰**:

```rust
#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    // ç”Ÿæˆ impl MyTrait for T {}
}
```

---

### Attribute Macro (å±æ€§å®)

ä¸ºä»£ç æ·»åŠ å…ƒæ•°æ®æˆ–ä¿®æ”¹ä»£ç çš„å®ã€‚

```rust
#[route(GET, "/")]
fn index() -> String {
    "Hello!".to_string()
}
```

**å®šä¹‰**:

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    // attr: GET, "/"
    // item: fn index() { ... }
    // è¿”å›ä¿®æ”¹åçš„å‡½æ•°
}
```

---

### Function-like Macro (å‡½æ•°å¼å®)

çœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨çš„å®ã€‚

```rust
let sql = sql!(SELECT * FROM users WHERE id = 1);
```

**å®šä¹‰**:

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    // è§£æ SQLï¼Œç”Ÿæˆä»£ç 
}
```

---

### syn Crate

è§£æ TokenStream çš„åº“ã€‚

```rust
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    // ...
}
```

**åŠŸèƒ½**:

- è§£æ Rust è¯­æ³•
- æä¾› AST æ•°æ®ç»“æ„
- é”™è¯¯å¤„ç†

---

### quote Crate

ç”Ÿæˆ TokenStream çš„åº“ã€‚

```rust
use quote::quote;

let name = &input.ident;
let expanded = quote! {
    impl MyTrait for #name {
        fn my_method(&self) {
            println!("Hello from {}", stringify!(#name));
        }
    }
};
```

**åŠŸèƒ½**:

- ä½¿ç”¨ç±» Rust è¯­æ³•ç”Ÿæˆä»£ç 
- æ’å€¼å˜é‡ `#var`
- é‡å¤ `#(...)*`

---

### Span

ä»£ç ä½ç½®ä¿¡æ¯ï¼Œç”¨äºé”™è¯¯æ¶ˆæ¯ã€‚

```rust
use proc_macro::Span;

let span = Span::call_site(); // å®è°ƒç”¨ä½ç½®
let span = ident.span();       // æ ‡è¯†ç¬¦ä½ç½®
```

**ç”¨é€”**:

- ç²¾ç¡®çš„é”™è¯¯æç¤º
- ä¿ç•™æºä»£ç ä½ç½®
- è°ƒè¯•ä¿¡æ¯

---

## ğŸ§¹ å«ç”Ÿæ€§ä¸ä½œç”¨åŸŸ

### Hygiene (å«ç”Ÿæ€§)

å®å†…å¤–æ ‡è¯†ç¬¦ä¸å†²çªçš„æœºåˆ¶ã€‚

```rust
macro_rules! using_a {
    ($e:expr) => {
        {
            let a = 42; // ä¸ä¼šä¸å¤–éƒ¨ a å†²çª
            $e
        }
    }
}

let a = 13;
let result = using_a!(a + a); // 26ï¼Œä½¿ç”¨å¤–éƒ¨ a
```

**ä¿è¯**:

- å®å†…å®šä¹‰çš„æ ‡è¯†ç¬¦ä¸æ³„éœ²
- å®å¤–æ ‡è¯†ç¬¦ä¸è¢«æ•è·ï¼ˆé™¤éæ˜¾å¼å¼•ç”¨ï¼‰

---

### Call Site (è°ƒç”¨ç‚¹)

å®è¢«è°ƒç”¨çš„ä½ç½®ã€‚

```rust
// è¿™é‡Œæ˜¯ call site
my_macro!(some_input);
```

**å½±å“**:

- Span ä¿¡æ¯
- ä½œç”¨åŸŸè§£æ
- å«ç”Ÿæ€§è§„åˆ™

---

### Definition Site (å®šä¹‰ç‚¹)

å®è¢«å®šä¹‰çš„ä½ç½®ã€‚

```rust
// è¿™é‡Œæ˜¯ definition site
macro_rules! my_macro {
    // ...
}
```

---

### Mixed Site (æ··åˆç‚¹)

syn 2.0+ å¼•å…¥çš„æ¦‚å¿µï¼Œç”¨äºæ›´ç²¾ç»†çš„å«ç”Ÿæ€§æ§åˆ¶ã€‚

```rust
use proc_macro2::Span;

let span = Span::mixed_site();
```

---

## ğŸ› ï¸ å·¥å…·ä¸åº“

### cargo-expand

æŸ¥çœ‹å®å±•å¼€ç»“æœçš„å·¥å…·ã€‚

```bash
cargo install cargo-expand
cargo expand
cargo expand my_module::my_function
```

**ç”¨é€”**:

- è°ƒè¯•å®
- ç†è§£å®å±•å¼€
- å­¦ä¹ å®å®ç°

---

### proc-macro2

`proc_macro` çš„ç‹¬ç«‹ç‰ˆæœ¬ï¼Œæ”¯æŒå•å…ƒæµ‹è¯•ã€‚

```rust
use proc_macro2::TokenStream;

fn my_helper(input: TokenStream) -> TokenStream {
    // å¯ä»¥åœ¨å•å…ƒæµ‹è¯•ä¸­è°ƒç”¨
}
```

**ä¼˜åŠ¿**:

- å¯æµ‹è¯•
- è·¨å¹³å°
- åŠŸèƒ½å®Œæ•´

---

### trybuild

æµ‹è¯•ç¼–è¯‘é”™è¯¯çš„å·¥å…·ã€‚

```rust
#[test]
fn ui_tests() {
    let t = trybuild::TestCases::new();
    t.compile_fail("tests/ui/*.rs");
}
```

**ç”¨é€”**:

- æµ‹è¯•å®çš„é”™è¯¯æ¶ˆæ¯
- ç¡®ä¿é”™è¯¯æç¤ºå‡†ç¡®

---

## ğŸ“š å…ƒç¼–ç¨‹æ¦‚å¿µ

### Metaprogramming (å…ƒç¼–ç¨‹)

ç¼–å†™ç”Ÿæˆæˆ–æ“ä½œç¨‹åºçš„ç¨‹åºã€‚

**Rust å®çš„å…ƒç¼–ç¨‹èƒ½åŠ›**:

- ä»£ç ç”Ÿæˆ
- ç¼–è¯‘æ—¶è®¡ç®—
- é›¶æˆæœ¬æŠ½è±¡

---

### AST (æŠ½è±¡è¯­æ³•æ ‘)

ä»£ç çš„æ ‘çŠ¶è¡¨ç¤ºã€‚

```rust
// ä»£ç 
let x = 1 + 2;

// AST (ç®€åŒ–è¡¨ç¤º)
LetStmt {
    pat: Ident("x"),
    init: BinaryOp {
        op: Add,
        left: Lit(1),
        right: Lit(2),
    }
}
```

**åœ¨å®ä¸­**:

- syn è§£æä¸º AST
- æ“ä½œ AST
- quote ç”Ÿæˆä»£ç 

---

### DSL (é¢†åŸŸç‰¹å®šè¯­è¨€)

é’ˆå¯¹ç‰¹å®šé¢†åŸŸçš„å°è¯­è¨€ã€‚

**ç¤ºä¾‹**:

```rust
html! {
    <div class="container">
        <h1>"Hello, World!"</h1>
    </div>
}
```

**å®ç°æ–¹å¼**:

- å‡½æ•°å¼å®
- è‡ªå®šä¹‰è§£æ
- ä»£ç ç”Ÿæˆ

---

### Code Generation (ä»£ç ç”Ÿæˆ)

å®çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œåœ¨ç¼–è¯‘æ—¶ç”Ÿæˆä»£ç ã€‚

```rust
#[derive(Builder)]
struct User {
    name: String,
    age: u32,
}

// è‡ªåŠ¨ç”Ÿæˆ UserBuilder
let user = User::builder()
    .name("Alice".to_string())
    .age(30)
    .build();
```

---

### Zero-Cost Abstraction (é›¶æˆæœ¬æŠ½è±¡)

å®å±•å¼€åçš„ä»£ç æ€§èƒ½ä¸æ‰‹å†™ä»£ç ç›¸åŒã€‚

```rust
// å®å®šä¹‰çš„é«˜å±‚æŠ½è±¡
for_each!(vec, |x| println!("{}", x));

// å±•å¼€åç­‰ä»·äº
for x in vec {
    println!("{}", x);
}
```

**éªŒè¯æ–¹å¼**:

- æŸ¥çœ‹å®å±•å¼€
- åˆ†æ LLVM IR
- æ€§èƒ½åŸºå‡†æµ‹è¯•

---

### Compile-time Computation (ç¼–è¯‘æ—¶è®¡ç®—)

åœ¨ç¼–è¯‘æœŸå®Œæˆè®¡ç®—ï¼Œè¿è¡Œæ—¶é›¶å¼€é”€ã€‚

```rust
const SIZE: usize = compute_size!(some_input);
```

---

**ä¸Šä¸€æ­¥**: [ä¸»ç´¢å¼•å¯¼èˆª](./02_ä¸»ç´¢å¼•å¯¼èˆª.md)  
**ä¸‹ä¸€æ­¥**: [å¸¸è§é—®é¢˜](./04_å¸¸è§é—®é¢˜.md)
