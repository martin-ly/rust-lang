# ğŸ“– C14å®ç³»ç»Ÿ - æœ¯è¯­è¡¨

> **æ–‡æ¡£å®šä½**: Rustå®ç³»ç»Ÿæ ¸å¿ƒæ¦‚å¿µå’Œæœ¯è¯­å®šä¹‰  
> **æœ€åæ›´æ–°**: 2025-10-20

---

## A

### AST (Abstract Syntax Tree)

**æŠ½è±¡è¯­æ³•æ ‘** - æºä»£ç çš„æ ‘çŠ¶è¡¨ç¤ºï¼Œè¿‡ç¨‹å®é€šè¿‡æ“ä½œASTæ¥ç”Ÿæˆä»£ç ã€‚

---

## C

### Crate

**åŒ…** - å®å¯ä»¥åœ¨åŒä¸€crateå†…ä½¿ç”¨ï¼Œæˆ–é€šè¿‡`#[macro_export]`å¯¼å‡ºç»™å…¶ä»–crateä½¿ç”¨ã€‚

---

## D

### Declarative Macro

**å£°æ˜å®** - ä½¿ç”¨`macro_rules!`å®šä¹‰çš„æ¨¡å¼åŒ¹é…å®ï¼Œä¹Ÿç§°ä¸º"macro by example"ã€‚

```rust
macro_rules! vec_of_strings {
    ($($x:expr),*) => { vec![$($x.to_string()),*] };
}
```

### Derive Macro

**æ´¾ç”Ÿå®** - è¿‡ç¨‹å®çš„ä¸€ç§ï¼Œç”¨äºè‡ªåŠ¨å®ç°traitã€‚

```rust
#[derive(Debug, Clone)]
struct Point { x: i32, y: i32 }
```

### DSL (Domain Specific Language)

**é¢†åŸŸç‰¹å®šè¯­è¨€** - é’ˆå¯¹ç‰¹å®šé—®é¢˜åŸŸè®¾è®¡çš„è¯­è¨€ï¼Œå¯ä»¥ä½¿ç”¨å®å®ç°ã€‚

---

## E

### Expansion

**å®å±•å¼€** - ç¼–è¯‘å™¨å°†å®è°ƒç”¨æ›¿æ¢ä¸ºå®é™…ä»£ç çš„è¿‡ç¨‹ã€‚

### `expr`

**è¡¨è¾¾å¼ç‰‡æ®µæŒ‡å®šç¬¦** - åœ¨å®æ¨¡å¼ä¸­åŒ¹é…ä»»æ„Rustè¡¨è¾¾å¼ã€‚

```rust
macro_rules! double {
    ($x:expr) => { $x * 2 };
}
```

---

## F

### Fragment Specifier

**ç‰‡æ®µæŒ‡å®šç¬¦** - åœ¨å®æ¨¡å¼ä¸­æŒ‡å®šå¯ä»¥åŒ¹é…çš„è¯­æ³•ç±»å‹ï¼Œå¦‚`expr`ã€`ident`ã€`ty`ç­‰ã€‚

### Function-like Macro

**å‡½æ•°å¼å®** - è¿‡ç¨‹å®çš„ä¸€ç§ï¼Œçœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ã€‚

```rust
let query = sql!("SELECT * FROM users");
```

---

## H

### Hygiene

**å«ç”Ÿæ€§** - å®çš„ä¸€ä¸ªç‰¹æ€§ï¼Œç¡®ä¿å®å†…éƒ¨å®šä¹‰çš„æ ‡è¯†ç¬¦ä¸ä¼šä¸å¤–éƒ¨å†²çªã€‚

```rust
macro_rules! define_x {
    () => { let x = 42; };  // è¿™ä¸ªxä¸å½±å“å¤–éƒ¨
}
```

---

## I

### `ident`

**æ ‡è¯†ç¬¦ç‰‡æ®µæŒ‡å®šç¬¦** - åŒ¹é…Rustæ ‡è¯†ç¬¦ï¼ˆå˜é‡åã€å‡½æ•°åç­‰ï¼‰ã€‚

```rust
macro_rules! create_fn {
    ($name:ident) => {
        fn $name() { }
    };
}
```

---

## M

### `macro_rules!`

**å£°æ˜å®å®šä¹‰** - å®šä¹‰å£°æ˜å®çš„å…³é”®å­—ã€‚

```rust
macro_rules! my_macro {
    () => { ... };
}
```

### `#[macro_export]`

**å®å¯¼å‡ºå±æ€§** - ä½¿å®å¯ä»¥è¢«å…¶ä»–crateä½¿ç”¨ã€‚

```rust
#[macro_export]
macro_rules! public_macro {
    () => { ... };
}
```

### Metaprogramming

**å…ƒç¼–ç¨‹** - ç¼–å†™èƒ½å¤Ÿç”Ÿæˆæˆ–æ“ä½œå…¶ä»–ç¨‹åºçš„ç¨‹åºï¼Œå®æ˜¯Rustçš„å…ƒç¼–ç¨‹å·¥å…·ã€‚

---

## P

### Pattern Matching

**æ¨¡å¼åŒ¹é…** - å£°æ˜å®é€šè¿‡æ¨¡å¼åŒ¹é…æ¥é€‰æ‹©ä¸åŒçš„å±•å¼€è§„åˆ™ã€‚

```rust
macro_rules! calc {
    (add $a:expr, $b:expr) => { $a + $b };
    (sub $a:expr, $b:expr) => { $a - $b };
}
```

### Procedural Macro

**è¿‡ç¨‹å®** - ä½¿ç”¨Rustä»£ç ç¼–å†™çš„å®ï¼Œæœ‰ä¸‰ç§ç±»å‹ï¼šæ´¾ç”Ÿå®ã€å±æ€§å®ã€å‡½æ•°å¼å®ã€‚

### `proc-macro`

**è¿‡ç¨‹å®crateç±»å‹** - ä¸“é—¨ç”¨äºå®šä¹‰è¿‡ç¨‹å®çš„crateç±»å‹ã€‚

```toml
[lib]
proc-macro = true
```

---

## Q

### `quote`

**ä»£ç ç”Ÿæˆåº“** - ç”¨äºåœ¨è¿‡ç¨‹å®ä¸­ç”ŸæˆRustä»£ç çš„åº“ã€‚

```rust
use quote::quote;
let code = quote! {
    fn hello() { println!("Hello"); }
};
```

---

## R

### Recursion

**é€’å½’** - å®å¯ä»¥é€’å½’è°ƒç”¨è‡ªå·±æ¥å¤„ç†é‡å¤çš„æ¨¡å¼ã€‚

```rust
macro_rules! count {
    () => { 0 };
    ($x:expr, $($rest:expr),*) => {
        1 + count!($($rest),*)
    };
}
```

### Repetition

**é‡å¤** - ä½¿ç”¨`$(...)*`æˆ–`$(...)+`è¯­æ³•æ¥å¤„ç†å¯å˜æ•°é‡çš„è¾“å…¥ã€‚

```rust
macro_rules! vec_of_strings {
    ($($x:expr),*) => {  // 0ä¸ªæˆ–å¤šä¸ª
        vec![$($x.to_string()),*]
    };
}
```

---

## S

### `syn`

**è¯­æ³•è§£æåº“** - ç”¨äºåœ¨è¿‡ç¨‹å®ä¸­è§£æRustè¯­æ³•çš„åº“ã€‚

```rust
use syn::{parse_macro_input, DeriveInput};
let ast = parse_macro_input!(input as DeriveInput);
```

---

## T

### Token

**è¯æ³•å•å…ƒ** - Rustä»£ç çš„æœ€å°è¯­æ³•å•ä½ï¼Œå¦‚æ ‡è¯†ç¬¦ã€å…³é”®å­—ã€ç¬¦å·ç­‰ã€‚

### TokenStream

**Tokenæµ** - Tokençš„åºåˆ—ï¼Œæ˜¯è¿‡ç¨‹å®çš„è¾“å…¥å’Œè¾“å‡ºç±»å‹ã€‚

```rust
use proc_macro::TokenStream;

#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // ...
}
```

### `tt` (Token Tree)

**Tokenæ ‘ç‰‡æ®µæŒ‡å®šç¬¦** - å¯ä»¥åŒ¹é…ä»»æ„å•ä¸ªtokenæˆ–ç”¨æ‹¬å·æ‹¬èµ·æ¥çš„tokenåºåˆ—ã€‚

```rust
macro_rules! accept_anything {
    ($($tt:tt)*) => { };  // æ¥å—ä»»æ„token
}
```

### `ty`

**ç±»å‹ç‰‡æ®µæŒ‡å®šç¬¦** - åŒ¹é…Rustç±»å‹ã€‚

```rust
macro_rules! make_struct {
    ($name:ident, $ty:ty) => {
        struct $name { value: $ty }
    };
}
```

---

## ç¬¦å·

### `$`

**å˜é‡å‰ç¼€** - åœ¨å®ä¸­æ ‡è®°å˜é‡å’Œé‡å¤æ¨¡å¼ã€‚

### `$(...)*`

**é›¶ä¸ªæˆ–å¤šä¸ªé‡å¤** - åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªé‡å¤çš„æ¨¡å¼ã€‚

### `$(...)+`

**ä¸€ä¸ªæˆ–å¤šä¸ªé‡å¤** - åŒ¹é…è‡³å°‘ä¸€ä¸ªé‡å¤çš„æ¨¡å¼ã€‚

### `$(...)?`

**é›¶ä¸ªæˆ–ä¸€ä¸ª** - åŒ¹é…å¯é€‰çš„æ¨¡å¼ã€‚

### `$(,)?`

**å¯é€‰çš„å°¾éšé€—å·** - å…è®¸ä½†ä¸è¦æ±‚å°¾éšé€—å·ã€‚

```rust
macro_rules! vec_of_strings {
    ($($x:expr),* $(,)?) => {  // å…è®¸å°¾éšé€—å·
        vec![$($x.to_string()),*]
    };
}
```

---

## ç›¸å…³å·¥å…·

### cargo-expand

**å®å±•å¼€å·¥å…·** - æŸ¥çœ‹å®å±•å¼€åçš„ä»£ç ã€‚

```bash
cargo install cargo-expand
cargo expand
```

### rust-analyzer

**Rustè¯­è¨€æœåŠ¡å™¨** - æä¾›IDEåŠŸèƒ½ï¼ŒåŒ…æ‹¬å®å±•å¼€æç¤ºã€‚

### trybuild

**ç¼–è¯‘æµ‹è¯•æ¡†æ¶** - ç”¨äºæµ‹è¯•è¿‡ç¨‹å®çš„ç¼–è¯‘è¡Œä¸ºã€‚

```rust
#[test]
fn test_proc_macro() {
    let t = trybuild::TestCases::new();
    t.pass("tests/pass/*.rs");
}
```

---

## ç‰‡æ®µæŒ‡å®šç¬¦å®Œæ•´åˆ—è¡¨

| æŒ‡å®šç¬¦ | åŒ¹é…å†…å®¹ | ç¤ºä¾‹ |
|--------|---------|------|
| `item` | é¡¹ï¼ˆå‡½æ•°ã€ç»“æ„ä½“ç­‰ï¼‰ | `fn foo() {}` |
| `block` | ä»£ç å— | `{ let x = 1; }` |
| `stmt` | è¯­å¥ | `let x = 1;` |
| `pat` | æ¨¡å¼ | `Some(x)` |
| `expr` | è¡¨è¾¾å¼ | `1 + 2` |
| `ty` | ç±»å‹ | `Vec<i32>` |
| `ident` | æ ‡è¯†ç¬¦ | `foo` |
| `path` | è·¯å¾„ | `std::vec::Vec` |
| `tt` | Tokenæ ‘ | `(a b c)` |
| `meta` | å±æ€§å†…å®¹ | `derive(Debug)` |
| `lifetime` | ç”Ÿå‘½å‘¨æœŸ | `'a` |
| `vis` | å¯è§æ€§ | `pub` |
| `literal` | å­—é¢é‡ | `42`, `"text"` |

---

## ç›¸å…³æ–‡æ¡£

- [ä¸»ç´¢å¼•](./00_MASTER_INDEX.md) - å®Œæ•´å­¦ä¹ å¯¼èˆª
- [FAQ](./FAQ.md) - å¸¸è§é—®é¢˜è§£ç­”
- [README](../README.md) - æ¨¡å—æ¦‚è¿°

---

**æœ€åæ›´æ–°**: 2025-10-20  
**ç»´æŠ¤è€…**: Rustå­¦ä¹ ç¤¾åŒº

æœ‰æœ¯è¯­è¡¥å……æˆ–ä¿®æ­£ï¼Ÿæ¬¢è¿è´¡çŒ®ï¼
