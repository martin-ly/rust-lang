# C14 Macro System - Tier 2: å±æ€§å®å¼€å‘æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **æœ€åæ›´æ–°**: 2025-10-23  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **é¢„è®¡é˜…è¯»**: 30 åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [C14 Macro System - Tier 2: å±æ€§å®å¼€å‘æŒ‡å—](#c14-macro-system---tier-2-å±æ€§å®å¼€å‘æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å±æ€§å®æ¦‚è¿°](#1-å±æ€§å®æ¦‚è¿°)
  - [2. åŸºç¡€è¯­æ³•](#2-åŸºç¡€è¯­æ³•)
    - [2.1 å®šä¹‰å±æ€§å®](#21-å®šä¹‰å±æ€§å®)
    - [2.2 ä½¿ç”¨å±æ€§å®](#22-ä½¿ç”¨å±æ€§å®)
  - [3. è§£æå±æ€§](#3-è§£æå±æ€§)
    - [3.1 è§£æå‚æ•°](#31-è§£æå‚æ•°)
    - [3.2 è‡ªå®šä¹‰è§£æ](#32-è‡ªå®šä¹‰è§£æ)
  - [4. ä¿®æ”¹ä»£ç ](#4-ä¿®æ”¹ä»£ç )
    - [4.1 åŒ…è£…å‡½æ•°](#41-åŒ…è£…å‡½æ•°)
    - [4.2 æ·»åŠ ä»£ç ](#42-æ·»åŠ ä»£ç )
  - [5. å®æˆ˜æ¡ˆä¾‹](#5-å®æˆ˜æ¡ˆä¾‹)
    - [5.1 HTTP è·¯ç”±å®](#51-http-è·¯ç”±å®)
    - [5.2 å¼‚æ­¥é‡è¯•å®](#52-å¼‚æ­¥é‡è¯•å®)
    - [5.3 æ€§èƒ½è®¡æ—¶å®](#53-æ€§èƒ½è®¡æ—¶å®)
    - [5.4 æ•°æ®éªŒè¯å®](#54-æ•°æ®éªŒè¯å®)
  - [6. æ€»ç»“](#6-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. å±æ€§å®æ¦‚è¿°

**å±æ€§å®** å¯ä»¥ä½œç”¨äºä»»ä½• Rust é¡¹ï¼ˆå‡½æ•°ã€ç»“æ„ä½“ã€æ¨¡å—ç­‰ï¼‰ï¼Œç”¨äºä¿®æ”¹æˆ–å¢å¼ºä»£ç ã€‚

**ç‰¹ç‚¹**:

- âœ… ä½œç”¨äºä»»ä½•é¡¹
- âœ… å¯æ¥å—å‚æ•°
- âœ… å¯ä¿®æ”¹åŸå§‹ä»£ç 
- âœ… ç”¨äºæ¡†æ¶å’Œåº“é›†æˆ

---

## 2. åŸºç¡€è¯­æ³•

### 2.1 å®šä¹‰å±æ€§å®

```rust
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn my_attribute(attr: TokenStream, item: TokenStream) -> TokenStream {
    // attr: å±æ€§å‚æ•° #[my_attribute(arg1, arg2)]
    // item: è¢«ä¿®é¥°çš„é¡¹
    
    item  // è¿”å›åŸæ ·
}
```

### 2.2 ä½¿ç”¨å±æ€§å®

```rust
#[my_attribute]
fn my_function() {
    println!("Hello");
}

#[my_attribute(arg1, arg2)]
struct MyStruct {
    field: i32,
}
```

---

## 3. è§£æå±æ€§

### 3.1 è§£æå‚æ•°

```rust
use syn::{parse_macro_input, AttributeArgs, ItemFn};

#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as AttributeArgs);
    let input = parse_macro_input!(item as ItemFn);
    
    // è§£æå±æ€§å‚æ•°
    for arg in args {
        // å¤„ç†æ¯ä¸ªå‚æ•°
    }
    
    TokenStream::from(quote! { #input })
}
```

### 3.2 è‡ªå®šä¹‰è§£æ

```rust
use syn::parse::{Parse, ParseStream};
use syn::{LitStr, Token};

struct RouteArgs {
    method: LitStr,
    path: LitStr,
}

impl Parse for RouteArgs {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let method: LitStr = input.parse()?;
        input.parse::<Token![,]>()?;
        let path: LitStr = input.parse()?;
        
        Ok(RouteArgs { method, path })
    }
}

#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as RouteArgs);
    let input = parse_macro_input!(item as ItemFn);
    
    let method = args.method.value();
    let path = args.path.value();
    
    // ä½¿ç”¨ method å’Œ path
    TokenStream::new()
}

// ä½¿ç”¨:
// #[route("GET", "/users")]
// fn get_users() { }
```

---

## 4. ä¿®æ”¹ä»£ç 

### 4.1 åŒ…è£…å‡½æ•°

```rust
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn trace(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_sig = &input.sig;
    
    let expanded = quote! {
        #fn_sig {
            println!("Entering {}", stringify!(#fn_name));
            let result = (|| #fn_block)();
            println!("Exiting {}", stringify!(#fn_name));
            result
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// #[trace]
// fn my_function() {
//     println!("Inside");
// }
```

### 4.2 æ·»åŠ ä»£ç 

```rust
#[proc_macro_attribute]
pub fn cached(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_sig = &input.sig;
    let fn_block = &input.block;
    
    let cache_name = syn::Ident::new(
        &format!("{}_CACHE", fn_name.to_string().to_uppercase()),
        fn_name.span()
    );
    
    let expanded = quote! {
        static #cache_name: once_cell::sync::Lazy<std::sync::Mutex<std::collections::HashMap<String, String>>> =
            once_cell::sync::Lazy::new(|| std::sync::Mutex::new(std::collections::HashMap::new()));
        
        #fn_sig {
            let key = format!("{:?}", (/* å‚æ•° */));
            
            // æ£€æŸ¥ç¼“å­˜
            if let Some(cached) = #cache_name.lock().unwrap().get(&key) {
                return cached.clone();
            }
            
            // æ‰§è¡Œå‡½æ•°
            let result = (|| #fn_block)();
            
            // å­˜å…¥ç¼“å­˜
            #cache_name.lock().unwrap().insert(key, result.clone());
            
            result
        }
    };
    
    TokenStream::from(expanded)
}
```

---

## 5. å®æˆ˜æ¡ˆä¾‹

### 5.1 HTTP è·¯ç”±å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn, LitStr};

#[proc_macro_attribute]
pub fn get(attr: TokenStream, item: TokenStream) -> TokenStream {
    let path = parse_macro_input!(attr as LitStr);
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    
    let expanded = quote! {
        pub fn #fn_name() -> impl axum::response::IntoResponse {
            #fn_block
        }
        
        // æ³¨å†Œè·¯ç”±
        inventory::submit! {
            Route {
                method: "GET",
                path: #path,
                handler: #fn_name,
            }
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// #[get("/users")]
// fn get_users() -> String {
//     "User list".to_string()
// }
```

### 5.2 å¼‚æ­¥é‡è¯•å®

```rust
#[proc_macro_attribute]
pub fn retry(attr: TokenStream, item: TokenStream) -> TokenStream {
    let max_retries = parse_macro_input!(attr as syn::LitInt).base10_parse::<u32>().unwrap();
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_sig = &input.sig;
    let fn_block = &input.block;
    
    let expanded = quote! {
        #fn_sig {
            let mut attempts = 0;
            loop {
                match (async #fn_block).await {
                    Ok(result) => return Ok(result),
                    Err(e) if attempts < #max_retries => {
                        attempts += 1;
                        println!("Retry {} of {}", attempts, #max_retries);
                        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                    }
                    Err(e) => return Err(e),
                }
            }
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// #[retry(3)]
// async fn fetch_data() -> Result<String, Error> {
//     Ok("data".to_string())
// }
```

### 5.3 æ€§èƒ½è®¡æ—¶å®

```rust
#[proc_macro_attribute]
pub fn timed(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_sig = &input.sig;
    let fn_block = &input.block;
    
    let expanded = quote! {
        #fn_sig {
            let start = std::time::Instant::now();
            let result = (|| #fn_block)();
            let duration = start.elapsed();
            println!("{} took {:?}", stringify!(#fn_name), duration);
            result
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// #[timed]
// fn expensive_operation() {
//     std::thread::sleep(std::time::Duration::from_secs(1));
// }
```

### 5.4 æ•°æ®éªŒè¯å®

```rust
#[proc_macro_attribute]
pub fn validate(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    
    let struct_name = &input.ident;
    let fields = match &input.fields {
        syn::Fields::Named(fields) => &fields.named,
        _ => panic!("Only named fields supported"),
    };
    
    let validations = fields.iter().map(|f| {
        let field_name = &f.ident;
        quote! {
            // æ·»åŠ éªŒè¯é€»è¾‘
            if self.#field_name.is_empty() {
                return Err(format!("Field {} is empty", stringify!(#field_name)));
            }
        }
    });
    
    let expanded = quote! {
        #input
        
        impl #struct_name {
            pub fn validate(&self) -> Result<(), String> {
                #(#validations)*
                Ok(())
            }
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨:
// #[validate]
// struct User {
//     name: String,
//     email: String,
// }
```

---

## 6. æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å®šä¹‰**: `#[proc_macro_attribute]`
2. **å‚æ•°**: `attr` (å±æ€§å‚æ•°), `item` (è¢«ä¿®é¥°é¡¹)
3. **è§£æ**: ä½¿ç”¨ `syn` è§£æ
4. **ç”Ÿæˆ**: ä½¿ç”¨ `quote!` ç”Ÿæˆä»£ç 
5. **ç”¨é€”**: è·¯ç”±ã€æ—¥å¿—ã€éªŒè¯ã€ç¼“å­˜

### æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èåšæ³• |
|------|---------|
| **HTTP è·¯ç”±** | æ³¨å†Œè·¯ç”±åˆ°å…¨å±€æ³¨å†Œè¡¨ |
| **æ—¥å¿—è¿½è¸ª** | åŒ…è£…åŸå‡½æ•°ï¼Œæ·»åŠ æ—¥å¿— |
| **ç¼“å­˜** | æ·»åŠ é™æ€ç¼“å­˜å˜é‡ |
| **éªŒè¯** | ç”Ÿæˆ `validate()` æ–¹æ³• |
| **å¼‚æ­¥** | å¤„ç† `async` å‡½æ•°ç­¾å |

**å¸¸è§é™·é˜±**:

- âŒ ä¿®æ”¹åŸå‡½æ•°å¯¼è‡´é”™è¯¯
- âŒ å¿½ç•¥ `async` å‡½æ•°
- âŒ å±æ€§å‚æ•°è§£æé”™è¯¯
- âŒ ç¼ºå°‘é”™è¯¯å¤„ç†
- âœ… ä¿ç•™åŸå‡½æ•°ç­¾å
- âœ… æ­£ç¡®å¤„ç†å¼‚æ­¥å‡½æ•°
- âœ… ä½¿ç”¨è‡ªå®šä¹‰è§£æå™¨
- âœ… æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯

---

## ğŸ“š å‚è€ƒèµ„æº

**ç›¸å…³æ–‡æ¡£**:

- [Tier 2: Derive å®å¼€å‘æŒ‡å—](./02_Deriveå®å¼€å‘æŒ‡å—.md)
- [Tier 2: å‡½æ•°å®å¼€å‘æŒ‡å—](./04_å‡½æ•°å®å¼€å‘æŒ‡å—.md)
- [Tier 3: ç†è®ºå‚è€ƒ](../tier_03_references/)

---

**æ–‡æ¡£ç»´æŠ¤**: C14 Macro System Team  
**æœ€åå®¡æ ¸**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-23
