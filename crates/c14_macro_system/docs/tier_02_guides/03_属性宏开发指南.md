# C14 Macro System - Tier 2: 属性宏开发指南

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-23  
> **Rust 版本**: 1.90+  
> **预计阅读**: 30 分钟

---

## 📋 目录

- [C14 Macro System - Tier 2: 属性宏开发指南](#c14-macro-system---tier-2-属性宏开发指南)
  - [📋 目录](#-目录)
  - [1. 属性宏概述](#1-属性宏概述)
  - [2. 基础语法](#2-基础语法)
    - [2.1 定义属性宏](#21-定义属性宏)
    - [2.2 使用属性宏](#22-使用属性宏)
  - [3. 解析属性](#3-解析属性)
    - [3.1 解析参数](#31-解析参数)
    - [3.2 自定义解析](#32-自定义解析)
  - [4. 修改代码](#4-修改代码)
    - [4.1 包装函数](#41-包装函数)
    - [4.2 添加代码](#42-添加代码)
  - [5. 实战案例](#5-实战案例)
    - [5.1 HTTP 路由宏](#51-http-路由宏)
    - [5.2 异步重试宏](#52-异步重试宏)
    - [5.3 性能计时宏](#53-性能计时宏)
    - [5.4 数据验证宏](#54-数据验证宏)
  - [6. 总结](#6-总结)
    - [核心要点](#核心要点)
    - [最佳实践](#最佳实践)
  - [📚 参考资源](#-参考资源)

---

## 1. 属性宏概述

**属性宏** 可以作用于任何 Rust 项（函数、结构体、模块等），用于修改或增强代码。

**特点**:

- ✅ 作用于任何项
- ✅ 可接受参数
- ✅ 可修改原始代码
- ✅ 用于框架和库集成

---

## 2. 基础语法

### 2.1 定义属性宏

```rust
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn my_attribute(attr: TokenStream, item: TokenStream) -> TokenStream {
    // attr: 属性参数 #[my_attribute(arg1, arg2)]
    // item: 被修饰的项
    
    item  // 返回原样
}
```

### 2.2 使用属性宏

```rust
#[my_attribute]
fn my_function() {
    println!("Hello");
}

#[my_attribute(arg1, arg2)]
struct MyStruct {
    field: i32,
}
```

---

## 3. 解析属性

### 3.1 解析参数

```rust
use syn::{parse_macro_input, AttributeArgs, ItemFn};

#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as AttributeArgs);
    let input = parse_macro_input!(item as ItemFn);
    
    // 解析属性参数
    for arg in args {
        // 处理每个参数
    }
    
    TokenStream::from(quote! { #input })
}
```

### 3.2 自定义解析

```rust
use syn::parse::{Parse, ParseStream};
use syn::{LitStr, Token};

struct RouteArgs {
    method: LitStr,
    path: LitStr,
}

impl Parse for RouteArgs {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let method: LitStr = input.parse()?;
        input.parse::<Token![,]>()?;
        let path: LitStr = input.parse()?;
        
        Ok(RouteArgs { method, path })
    }
}

#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as RouteArgs);
    let input = parse_macro_input!(item as ItemFn);
    
    let method = args.method.value();
    let path = args.path.value();
    
    // 使用 method 和 path
    TokenStream::new()
}

// 使用:
// #[route("GET", "/users")]
// fn get_users() { }
```

---

## 4. 修改代码

### 4.1 包装函数

```rust
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn trace(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_sig = &input.sig;
    
    let expanded = quote! {
        #fn_sig {
            println!("Entering {}", stringify!(#fn_name));
            let result = (|| #fn_block)();
            println!("Exiting {}", stringify!(#fn_name));
            result
        }
    };
    
    TokenStream::from(expanded)
}

// 使用:
// #[trace]
// fn my_function() {
//     println!("Inside");
// }
```

### 4.2 添加代码

```rust
#[proc_macro_attribute]
pub fn cached(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_sig = &input.sig;
    let fn_block = &input.block;
    
    let cache_name = syn::Ident::new(
        &format!("{}_CACHE", fn_name.to_string().to_uppercase()),
        fn_name.span()
    );
    
    let expanded = quote! {
        static #cache_name: once_cell::sync::Lazy<std::sync::Mutex<std::collections::HashMap<String, String>>> =
            once_cell::sync::Lazy::new(|| std::sync::Mutex::new(std::collections::HashMap::new()));
        
        #fn_sig {
            let key = format!("{:?}", (/* 参数 */));
            
            // 检查缓存
            if let Some(cached) = #cache_name.lock().unwrap().get(&key) {
                return cached.clone();
            }
            
            // 执行函数
            let result = (|| #fn_block)();
            
            // 存入缓存
            #cache_name.lock().unwrap().insert(key, result.clone());
            
            result
        }
    };
    
    TokenStream::from(expanded)
}
```

---

## 5. 实战案例

### 5.1 HTTP 路由宏

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn, LitStr};

#[proc_macro_attribute]
pub fn get(attr: TokenStream, item: TokenStream) -> TokenStream {
    let path = parse_macro_input!(attr as LitStr);
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    
    let expanded = quote! {
        pub fn #fn_name() -> impl axum::response::IntoResponse {
            #fn_block
        }
        
        // 注册路由
        inventory::submit! {
            Route {
                method: "GET",
                path: #path,
                handler: #fn_name,
            }
        }
    };
    
    TokenStream::from(expanded)
}

// 使用:
// #[get("/users")]
// fn get_users() -> String {
//     "User list".to_string()
// }
```

### 5.2 异步重试宏

```rust
#[proc_macro_attribute]
pub fn retry(attr: TokenStream, item: TokenStream) -> TokenStream {
    let max_retries = parse_macro_input!(attr as syn::LitInt).base10_parse::<u32>().unwrap();
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_sig = &input.sig;
    let fn_block = &input.block;
    
    let expanded = quote! {
        #fn_sig {
            let mut attempts = 0;
            loop {
                match (async #fn_block).await {
                    Ok(result) => return Ok(result),
                    Err(e) if attempts < #max_retries => {
                        attempts += 1;
                        println!("Retry {} of {}", attempts, #max_retries);
                        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                    }
                    Err(e) => return Err(e),
                }
            }
        }
    };
    
    TokenStream::from(expanded)
}

// 使用:
// #[retry(3)]
// async fn fetch_data() -> Result<String, Error> {
//     Ok("data".to_string())
// }
```

### 5.3 性能计时宏

```rust
#[proc_macro_attribute]
pub fn timed(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    
    let fn_name = &input.sig.ident;
    let fn_sig = &input.sig;
    let fn_block = &input.block;
    
    let expanded = quote! {
        #fn_sig {
            let start = std::time::Instant::now();
            let result = (|| #fn_block)();
            let duration = start.elapsed();
            println!("{} took {:?}", stringify!(#fn_name), duration);
            result
        }
    };
    
    TokenStream::from(expanded)
}

// 使用:
// #[timed]
// fn expensive_operation() {
//     std::thread::sleep(std::time::Duration::from_secs(1));
// }
```

### 5.4 数据验证宏

```rust
#[proc_macro_attribute]
pub fn validate(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    
    let struct_name = &input.ident;
    let fields = match &input.fields {
        syn::Fields::Named(fields) => &fields.named,
        _ => panic!("Only named fields supported"),
    };
    
    let validations = fields.iter().map(|f| {
        let field_name = &f.ident;
        quote! {
            // 添加验证逻辑
            if self.#field_name.is_empty() {
                return Err(format!("Field {} is empty", stringify!(#field_name)));
            }
        }
    });
    
    let expanded = quote! {
        #input
        
        impl #struct_name {
            pub fn validate(&self) -> Result<(), String> {
                #(#validations)*
                Ok(())
            }
        }
    };
    
    TokenStream::from(expanded)
}

// 使用:
// #[validate]
// struct User {
//     name: String,
//     email: String,
// }
```

---

## 6. 总结

### 核心要点

1. **定义**: `#[proc_macro_attribute]`
2. **参数**: `attr` (属性参数), `item` (被修饰项)
3. **解析**: 使用 `syn` 解析
4. **生成**: 使用 `quote!` 生成代码
5. **用途**: 路由、日志、验证、缓存

### 最佳实践

| 场景 | 推荐做法 |
|------|---------|
| **HTTP 路由** | 注册路由到全局注册表 |
| **日志追踪** | 包装原函数，添加日志 |
| **缓存** | 添加静态缓存变量 |
| **验证** | 生成 `validate()` 方法 |
| **异步** | 处理 `async` 函数签名 |

**常见陷阱**:

- ❌ 修改原函数导致错误
- ❌ 忽略 `async` 函数
- ❌ 属性参数解析错误
- ❌ 缺少错误处理
- ✅ 保留原函数签名
- ✅ 正确处理异步函数
- ✅ 使用自定义解析器
- ✅ 提供清晰的错误信息

---

## 📚 参考资源

**相关文档**:

- [Tier 2: Derive 宏开发指南](./02_Derive宏开发指南.md)
- [Tier 2: 函数宏开发指南](./04_函数宏开发指南.md)
- [Tier 3: 理论参考](../tier_03_references/)

---

**文档维护**: C14 Macro System Team  
**最后审核**: 2025-10-23  
**下次更新**: 2026-01-23
