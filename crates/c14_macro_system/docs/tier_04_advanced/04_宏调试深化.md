# 04 宏调试深化

## 目录

- [04 宏调试深化](#04-宏调试深化)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 高级 cargo expand 用法](#2-高级-cargo-expand-用法)
    - [2.1 基础展开](#21-基础展开)
      - [2.1.1 安装和基础使用](#211-安装和基础使用)
      - [2.1.2 输出格式化](#212-输出格式化)
    - [2.2 过滤和聚焦](#22-过滤和聚焦)
      - [2.2.1 按测试展开](#221-按测试展开)
      - [2.2.2 按示例展开](#222-按示例展开)
      - [2.2.3 按 Feature 展开](#223-按-feature-展开)
    - [2.3 比较差异](#23-比较差异)
      - [2.3.1 Git 差异比较](#231-git-差异比较)
      - [2.3.2 自动化比较脚本](#232-自动化比较脚本)
    - [2.4 集成到工作流](#24-集成到工作流)
      - [2.4.1 CI 集成](#241-ci-集成)
      - [2.4.2 Pre-commit Hook](#242-pre-commit-hook)
  - [3. 编译器插件开发](#3-编译器插件开发)
    - [3.1 rustc 驱动器](#31-rustc-驱动器)
      - [3.1.1 自定义驱动器](#311-自定义驱动器)
    - [3.2 自定义 Lint](#32-自定义-lint)
      - [3.2.1 声明宏 Lint](#321-声明宏-lint)
    - [3.3 编译器回调](#33-编译器回调)
      - [3.3.1 监听编译事件](#331-监听编译事件)
  - [4. 宏展开追踪](#4-宏展开追踪)
    - [4.1 日志追踪](#41-日志追踪)
      - [4.1.1 添加调试输出](#411-添加调试输出)
      - [4.1.2 使用 tracing](#412-使用-tracing)
    - [4.2 断点调试](#42-断点调试)
      - [4.2.1 使用 lldb/gdb](#421-使用-lldbgdb)
      - [4.2.2 VS Code 集成](#422-vs-code-集成)
    - [4.3 可视化工具](#43-可视化工具)
      - [4.3.1 syn-browser](#431-syn-browser)
  - [5. 性能分析](#5-性能分析)
    - [5.1 编译时性能](#51-编译时性能)
      - [5.1.1 cargo build --timings](#511-cargo-build---timings)
      - [5.1.2 RUSTC\_LOG](#512-rustc_log)
    - [5.2 宏展开开销](#52-宏展开开销)
      - [5.2.1 测量展开时间](#521-测量展开时间)
      - [5.1.2 基准测试](#512-基准测试)
    - [5.3 优化瓶颈识别](#53-优化瓶颈识别)
      - [5.3.1 火焰图](#531-火焰图)
      - [5.3.2 perf 分析](#532-perf-分析)
  - [6. 错误诊断](#6-错误诊断)
    - [6.1 错误消息改进](#61-错误消息改进)
      - [6.1.1 使用 Span](#611-使用-span)
      - [6.1.2 多错误报告](#612-多错误报告)
    - [6.2 Span 管理](#62-span-管理)
      - [6.2.1 保留原始 Span](#621-保留原始-span)
      - [6.2.2 Span 组合](#622-span-组合)
    - [6.3 诊断工具](#63-诊断工具)
      - [6.3.1 proc-macro-error](#631-proc-macro-error)
  - [7. 实战案例](#7-实战案例)
    - [7.1 调试复杂宏展开](#71-调试复杂宏展开)
      - [7.1.1 问题场景](#711-问题场景)
      - [7.1.2 调试步骤](#712-调试步骤)
    - [7.2 性能瓶颈定位](#72-性能瓶颈定位)
      - [7.2.1 问题场景](#721-问题场景)
      - [7.2.2 分析步骤](#722-分析步骤)
  - [8. 相关资源](#8-相关资源)
    - [8.1 工具](#81-工具)
    - [8.2 学习资源](#82-学习资源)

---

## 1. 概述

**宏调试**是宏开发中最具挑战性的环节之一。由于宏在编译期展开，传统的运行时调试工具无法直接使用。本文档介绍高级调试技术和工具，帮助开发者高效诊断和优化宏代码。

**本文档涵盖**：

- **高级 cargo expand**：展开、过滤、比较宏输出
- **编译器插件开发**：自定义 Lint、rustc 驱动器
- **宏展开追踪**：日志、断点、可视化
- **性能分析**：编译时性能、展开开销
- **错误诊断**：改进错误消息、Span 管理

**适用场景**：

- ✅ 调试复杂的过程宏
- ✅ 优化宏的编译时性能
- ✅ 改进宏的错误消息
- ✅ 开发自定义编译器工具

**学习路径**：

1. 掌握 cargo expand 高级用法
2. 学习编译器插件开发
3. 实践宏展开追踪
4. 分析宏性能
5. 优化错误诊断

---

## 2. 高级 cargo expand 用法

### 2.1 基础展开

#### 2.1.1 安装和基础使用

```bash
# 安装 cargo-expand
cargo install cargo-expand

# 展开当前 crate 的所有宏
cargo expand

# 展开特定模块
cargo expand my_module

# 展开特定项
cargo expand my_module::my_function
```

#### 2.1.2 输出格式化

```bash
# 使用 rustfmt 格式化输出
cargo expand | rustfmt

# 保存到文件
cargo expand > expanded.rs

# 彩色输出（默认）
cargo expand --color=always
```

---

### 2.2 过滤和聚焦

#### 2.2.1 按测试展开

```bash
# 展开特定测试
cargo expand --test my_test

# 展开所有测试
cargo expand --tests
```

#### 2.2.2 按示例展开

```bash
# 展开特定示例
cargo expand --example my_example
```

#### 2.2.3 按 Feature 展开

```bash
# 启用特定 feature
cargo expand --features my_feature

# 禁用默认 features
cargo expand --no-default-features --features minimal
```

---

### 2.3 比较差异

#### 2.3.1 Git 差异比较

```bash
# 保存当前展开结果
cargo expand > expanded_before.rs

# 修改宏代码...

# 保存新的展开结果
cargo expand > expanded_after.rs

# 比较差异
diff -u expanded_before.rs expanded_after.rs
```

#### 2.3.2 自动化比较脚本

```bash
#!/bin/bash
# expand_diff.sh

BEFORE=$(mktemp)
AFTER=$(mktemp)

# 展开修改前的代码
git stash
cargo expand > "$BEFORE"
git stash pop

# 展开修改后的代码
cargo expand > "$AFTER"

# 显示差异
diff -u "$BEFORE" "$AFTER" | bat --language diff

# 清理临时文件
rm "$BEFORE" "$AFTER"
```

---

### 2.4 集成到工作流

#### 2.4.1 CI 集成

```yaml
# .github/workflows/expand.yml
name: Macro Expansion Check

on: [push, pull_request]

jobs:
  expand:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: nightly
      - run: cargo install cargo-expand
      - run: cargo expand > expanded.rs
      - uses: actions/upload-artifact@v3
        with:
          name: expanded-code
          path: expanded.rs
```

#### 2.4.2 Pre-commit Hook

```bash
# .git/hooks/pre-commit

#!/bin/bash
cargo expand > /dev/null 2>&1

if [ $? -ne 0 ]; then
    echo "❌ Macro expansion failed!"
    exit 1
fi

echo "✅ Macro expansion successful"
```

---

## 3. 编译器插件开发

### 3.1 rustc 驱动器

#### 3.1.1 自定义驱动器

```rust
// rustc_driver.rs
#![feature(rustc_private)]

extern crate rustc_driver;
extern crate rustc_interface;
extern crate rustc_session;

use rustc_interface::interface::Compiler;
use rustc_interface::Queries;

struct MyCallbacks;

impl rustc_driver::Callbacks for MyCallbacks {
    fn after_parsing<'tcx>(
        &mut self,
        _compiler: &Compiler,
        queries: &'tcx Queries<'tcx>,
    ) -> rustc_driver::Compilation {
        queries.global_ctxt().unwrap().enter(|tcx| {
            // 访问 HIR
            for item in tcx.hir().items() {
                println!("Item: {:?}", item);
            }
        });
        
        rustc_driver::Compilation::Continue
    }
}

fn main() {
    let mut args: Vec<String> = std::env::args().collect();
    args.push("--sysroot".to_string());
    args.push(sysroot_path());
    
    rustc_driver::RunCompiler::new(&args, &mut MyCallbacks).run().unwrap();
}

fn sysroot_path() -> String {
    std::process::Command::new("rustc")
        .arg("--print=sysroot")
        .output()
        .ok()
        .and_then(|out| String::from_utf8(out.stdout).ok())
        .map(|s| s.trim().to_owned())
        .unwrap()
}
```

---

### 3.2 自定义 Lint

#### 3.2.1 声明宏 Lint

```rust
#![feature(rustc_private)]

extern crate rustc_lint;
extern crate rustc_span;
extern crate rustc_ast;

use rustc_lint::{EarlyLintPass, EarlyContext, LintContext};
use rustc_ast::ast;

declare_lint! {
    pub MY_MACRO_LINT,
    Warn,
    "检测宏使用中的潜在问题"
}

struct MyMacroLint;

impl EarlyLintPass for MyMacroLint {
    fn check_mac(&mut self, cx: &EarlyContext, mac: &ast::MacCall) {
        if mac.path.segments[0].ident.name.as_str() == "dangerous_macro" {
            cx.lint(MY_MACRO_LINT, "使用 dangerous_macro 可能导致性能问题", |lint| {
                lint.set_span(mac.span());
                lint.emit();
            });
        }
    }
}
```

---

### 3.3 编译器回调

#### 3.3.1 监听编译事件

```rust
use rustc_interface::interface::Compiler;
use rustc_driver::Callbacks;

struct DebugCallbacks;

impl Callbacks for DebugCallbacks {
    // 1. 解析完成后
    fn after_parsing<'tcx>(
        &mut self,
        _compiler: &Compiler,
        _queries: &'tcx Queries<'tcx>,
    ) -> rustc_driver::Compilation {
        println!("✅ Parsing completed");
        rustc_driver::Compilation::Continue
    }
    
    // 2. 宏展开完成后
    fn after_expansion<'tcx>(
        &mut self,
        _compiler: &Compiler,
        _queries: &'tcx Queries<'tcx>,
    ) -> rustc_driver::Compilation {
        println!("✅ Macro expansion completed");
        rustc_driver::Compilation::Continue
    }
    
    // 3. 类型检查完成后
    fn after_analysis<'tcx>(
        &mut self,
        _compiler: &Compiler,
        _queries: &'tcx Queries<'tcx>,
    ) -> rustc_driver::Compilation {
        println!("✅ Type checking completed");
        rustc_driver::Compilation::Continue
    }
}
```

---

## 4. 宏展开追踪

### 4.1 日志追踪

#### 4.1.1 添加调试输出

```rust
// 声明宏中的调试
macro_rules! debug_macro {
    ($($arg:tt)*) => {{
        #[cfg(feature = "macro-debug")]
        {
            eprintln!("[MACRO DEBUG] Expanding with: {}", stringify!($($arg)*));
        }
        
        // 实际宏逻辑...
    }};
}

// 过程宏中的调试
use proc_macro::TokenStream;

#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    eprintln!("[MACRO DEBUG] Input: {}", input);
    
    let output = quote! {
        // 生成的代码...
    };
    
    eprintln!("[MACRO DEBUG] Output: {}", output);
    
    output.into()
}
```

#### 4.1.2 使用 tracing

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
```

```rust
use tracing::{info, debug, span, Level};

#[proc_macro]
pub fn traced_macro(input: TokenStream) -> TokenStream {
    tracing_subscriber::fmt::init();
    
    let _span = span!(Level::INFO, "traced_macro").entered();
    
    info!("Starting macro expansion");
    debug!("Input tokens: {}", input);
    
    // 宏逻辑...
    
    info!("Macro expansion completed");
    
    output.into()
}
```

---

### 4.2 断点调试

#### 4.2.1 使用 lldb/gdb

```bash
# 启动调试会话
lldb -- cargo build

# 设置断点（在过程宏代码中）
(lldb) breakpoint set --file my_macro.rs --line 42

# 运行
(lldb) run

# 查看变量
(lldb) frame variable
(lldb) print input

# 单步执行
(lldb) step
(lldb) next
```

#### 4.2.2 VS Code 集成

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug Proc Macro",
      "cargo": {
        "args": [
          "build",
          "--package",
          "my_macro"
        ]
      },
      "cwd": "${workspaceFolder}"
    }
  ]
}
```

---

### 4.3 可视化工具

#### 4.3.1 syn-browser

```bash
# 安装
cargo install syn-browser

# 启动 Web 界面
syn-browser

# 访问 http://localhost:8000
```

**功能**：

- 可视化 syn AST
- 交互式探索 token 树
- 高亮显示语法节点

---

## 5. 性能分析

### 5.1 编译时性能

#### 5.1.1 cargo build --timings

```bash
# 生成编译时间报告
cargo build --release --timings

# 查看 HTML 报告
open target/cargo-timings/cargo-timing.html
```

**报告内容**：

- 各 crate 编译时间
- 依赖关系图
- 并行度分析

#### 5.1.2 RUSTC_LOG

```bash
# 启用编译器日志
RUSTC_LOG=rustc_expand::trace_macros cargo build 2>&1 | tee expand.log

# 过滤宏展开信息
grep "trace_macros" expand.log
```

---

### 5.2 宏展开开销

#### 5.2.1 测量展开时间

```rust
use std::time::Instant;

#[proc_macro]
pub fn timed_macro(input: TokenStream) -> TokenStream {
    let start = Instant::now();
    
    // 宏逻辑...
    let output = quote! { /* ... */ };
    
    let duration = start.elapsed();
    eprintln!("[TIMING] Macro expansion took: {:?}", duration);
    
    output.into()
}
```

#### 5.1.2 基准测试

```bash
# 创建测试项目
cargo new --lib macro_benchmark
cd macro_benchmark

# 添加宏依赖
# Cargo.toml
[dev-dependencies]
my_macro = { path = "../my_macro" }

# 编写测试
# src/lib.rs
#[cfg(test)]
mod tests {
    #[test]
    fn benchmark_macro_expansion() {
        // 使用宏...
    }
}

# 测量编译时间
hyperfine "cargo clean && cargo test --no-run"
```

---

### 5.3 优化瓶颈识别

#### 5.3.1 火焰图

```bash
# 安装 cargo-flamegraph
cargo install flamegraph

# 生成火焰图
cargo flamegraph --bin my_app

# 查看 flamegraph.svg
```

#### 5.3.2 perf 分析

```bash
# Linux 下使用 perf
perf record -g cargo build
perf report
```

---

## 6. 错误诊断

### 6.1 错误消息改进

#### 6.1.1 使用 Span

```rust
use proc_macro2::Span;
use syn::Error;

fn validate_input(input: &syn::DeriveInput) -> Result<(), Error> {
    if input.generics.params.is_empty() {
        return Err(Error::new(
            input.ident.span(),
            "expected at least one generic parameter"
        ));
    }
    
    Ok(())
}

// 错误会精确指向问题位置
// error: expected at least one generic parameter
//   --> src/lib.rs:5:8
//    |
// 5  | struct MyStruct;
//    |        ^^^^^^^^
```

#### 6.1.2 多错误报告

```rust
fn validate_all(input: &syn::DeriveInput) -> Result<(), Vec<Error>> {
    let mut errors = Vec::new();
    
    // 检查 1
    if let Err(e) = check_generics(input) {
        errors.push(e);
    }
    
    // 检查 2
    if let Err(e) = check_attributes(input) {
        errors.push(e);
    }
    
    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors)
    }
}

// 使用
match validate_all(&input) {
    Ok(_) => { /* 生成代码 */ }
    Err(errors) => {
        // 一次性报告所有错误
        return errors.into_iter()
            .map(|e| e.to_compile_error())
            .collect::<proc_macro2::TokenStream>()
            .into();
    }
}
```

---

### 6.2 Span 管理

#### 6.2.1 保留原始 Span

```rust
use quote::quote_spanned;

fn generate_with_span(field: &syn::Field) -> proc_macro2::TokenStream {
    let field_name = &field.ident;
    let field_type = &field.ty;
    let span = field.span();
    
    // ✅ 使用原始字段的 Span
    quote_spanned! {span=>
        pub fn get_#field_name(&self) -> &#field_type {
            &self.#field_name
        }
    }
}
```

#### 6.2.2 Span 组合

```rust
use proc_macro2::Span;

fn combine_spans(span1: Span, span2: Span) -> Span {
    span1.join(span2).unwrap_or(span1)
}

// 使用示例
let combined = combine_spans(ident_span, type_span);
let error = Error::new(combined, "type mismatch");
```

---

### 6.3 诊断工具

#### 6.3.1 proc-macro-error

```toml
[dependencies]
proc-macro-error = "1.0"
```

```rust
use proc_macro_error::{abort, proc_macro_error};

#[proc_macro_derive(MyMacro)]
#[proc_macro_error]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(input as syn::DeriveInput);
    
    // ✅ 使用 abort! 提供友好错误
    if input.generics.params.is_empty() {
        abort!(
            input.ident.span(),
            "expected at least one generic parameter";
            help = "try: struct MyStruct<T> {{ ... }}"
        );
    }
    
    // 生成代码...
}
```

---

## 7. 实战案例

### 7.1 调试复杂宏展开

#### 7.1.1 问题场景

```rust
// 宏调用
my_complex_macro! {
    struct User {
        id: u64,
        name: String,
    }
}

// 展开失败：trait bound `String: Copy` is not satisfied
```

#### 7.1.2 调试步骤

**步骤 1：展开宏**:

```bash
cargo expand my_module::my_struct
```

**步骤 2：定位问题**:

```rust
// 展开后的代码
impl Clone for User {
    fn clone(&self) -> Self {
        Self {
            id: self.id, // ✅ u64 实现 Copy
            name: self.name, // ❌ String 不实现 Copy
        }
    }
}
```

**步骤 3：修复宏**:

```rust
// 修改宏生成逻辑
quote! {
    impl Clone for #name {
        fn clone(&self) -> Self {
            Self {
                #(
                    #field_names: self.#field_names.clone(), // ✅ 使用 clone()
                )*
            }
        }
    }
}
```

---

### 7.2 性能瓶颈定位

#### 7.2.1 问题场景

编译时间从 30 秒增加到 5 分钟。

#### 7.2.2 分析步骤

**步骤 1：识别慢速 crate**:

```bash
cargo build --timings
# 查看 HTML 报告，发现 `my_macro_derive` 耗时 2 分钟
```

**步骤 2：分析单态化**:

```bash
cargo llvm-lines | grep my_macro_derive
# 输出：
# 50000 (49.3%)  1000 (40.3%)  my_macro_derive::generate<...>
```

**步骤 3：优化宏**:

```rust
// ❌ 原始：为每个类型生成独立实现
macro_rules! generate_impl {
    ($ty:ty) => {
        impl MyTrait for $ty {
            fn process(&self) {
                // 大量代码（单态化）...
            }
        }
    };
}

// ✅ 优化：共享非泛型代码
fn shared_process(value: &dyn std::any::Any) {
    // 共享实现（无单态化）
}

macro_rules! generate_impl {
    ($ty:ty) => {
        impl MyTrait for $ty {
            fn process(&self) {
                shared_process(self);
            }
        }
    };
}
```

**结果**：编译时间降至 45 秒。

---

## 8. 相关资源

### 8.1 工具

- **cargo-expand**: 宏展开工具
- **syn-browser**: AST 可视化
- **proc-macro-error**: 错误处理库
- **tracing**: 日志追踪

### 8.2 学习资源

- [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
- [Rustc Dev Guide - Macro Expansion](https://rustc-dev-guide.rust-lang.org/macro-expansion.html)
- [proc-macro-workshop](https://github.com/dtolnay/proc-macro-workshop)

---

**下一步**：

- → 阅读 [05_生产级宏开发.md](./05_生产级宏开发.md) 学习发布策略
- → 参考 [C14 主索引](../../02_主索引导航.md) 探索其他主题
- → 实践 [Tier 2 宏开发指南](../../tier_02_guides/README.md) 巩固知识

---

*最后更新: 2025-10-23*
*版本: 1.0.0*
*作者: Rust 学习系统团队*
