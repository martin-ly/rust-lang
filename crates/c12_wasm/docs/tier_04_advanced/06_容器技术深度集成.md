# WasmEdge 容器技术深度集成指南

> **文档类型**: Tier 4 - 高级层
> **创建日期**: 2025-10-30
> **适用版本**: WasmEdge 0.13+, Docker 24.0+, Kubernetes 1.28+
> **技术前沿**: 对标 2025 年容器技术最新发展

---

## 📋 目录

- [WasmEdge 容器技术深度集成指南](#wasmedge-容器技术深度集成指南)
  - [📋 目录](#-目录)
  - [🎯 概述](#-概述)
  - [🐳 Docker 集成](#-docker-集成)
    - [Docker Desktop 集成](#docker-desktop-集成)
      - [1. 启用 WasmEdge 支持](#1-启用-wasmedge-支持)
      - [2. 构建 Wasm 容器镜像](#2-构建-wasm-容器镜像)
    - [Docker CLI 与 WasmEdge](#docker-cli-与-wasmedge)
      - [运行选项详解](#运行选项详解)
    - [多架构镜像构建](#多架构镜像构建)
  - [☸️ Kubernetes 深度集成](#️-kubernetes-深度集成)
    - [RuntimeClass 配置](#runtimeclass-配置)
      - [1. 安装 containerd-shim-wasmedge](#1-安装-containerd-shim-wasmedge)
      - [2. 配置 containerd](#2-配置-containerd)
      - [3. 创建 RuntimeClass](#3-创建-runtimeclass)
    - [CRI 插件集成](#cri-插件集成)
    - [Workload 部署策略](#workload-部署策略)
      - [Deployment 示例](#deployment-示例)
      - [Service 配置](#service-配置)
      - [HorizontalPodAutoscaler (HPA)](#horizontalpodautoscaler-hpa)
      - [Ingress 配置](#ingress-配置)
  - [🔧 containerd 集成](#-containerd-集成)
    - [containerd shim 机制](#containerd-shim-机制)
    - [runwasi 项目](#runwasi-项目)
  - [📝 容器编排最佳实践](#-容器编排最佳实践)
    - [1. 资源配额设置](#1-资源配额设置)
    - [2. 节点亲和性与污点](#2-节点亲和性与污点)
    - [3. 配置管理](#3-配置管理)
    - [4. 秘密管理](#4-秘密管理)
  - [🚀 生产环境部署](#-生产环境部署)
    - [完整部署流程](#完整部署流程)
    - [滚动更新策略](#滚动更新策略)
  - [📊 监控与可观测性](#-监控与可观测性)
    - [Prometheus 集成](#prometheus-集成)
    - [Grafana 仪表板](#grafana-仪表板)
    - [日志聚合](#日志聚合)
  - [🔒 安全与隔离](#-安全与隔离)
    - [1. Pod Security Standards](#1-pod-security-standards)
    - [2. NetworkPolicy](#2-networkpolicy)
    - [3. SecurityContext](#3-securitycontext)
  - [⚡ 性能调优](#-性能调优)
    - [1. 资源请求和限制优化](#1-资源请求和限制优化)
    - [2. 亲和性调优](#2-亲和性调优)
    - [3. HPA 调优](#3-hpa-调优)
  - [🎯 实战案例](#-实战案例)
    - [案例 1: 微服务 API Gateway (Wasm)](#案例-1-微服务-api-gateway-wasm)
    - [案例 2: 边缘 AI 推理服务](#案例-2-边缘-ai-推理服务)
    - [案例 3: Serverless 函数平台](#案例-3-serverless-函数平台)
  - [📚 总结](#-总结)
    - [关键优势](#关键优势)
    - [最佳实践清单](#最佳实践清单)
    - [参考资源](#参考资源)

---

## 🎯 概述

WebAssembly 容器化是 2025 年云原生领域的重要趋势。相比传统 Linux 容器：

| 特性 | Linux 容器 | Wasm 容器 (WasmEdge) | 优势 |
| --- | --- | --- | --- |
| **启动时间** | 100-1000ms | 1-10ms | **100倍提升** ✨ |
| **内存占用** | 100MB-1GB | 5-50MB | **20倍减少** ✨ |
| **镜像大小** | 50MB-500MB | 1-10MB | **50倍缩小** ✨ |
| **安全性** | Namespace/cgroup | Wasm 沙箱 | **更强隔离** ✨ |
| **可移植性** | 依赖 OS | 完全跨平台 | **真正可移植** ✨ |
| **性能** | 原生 | 95-100% 原生 | **接近原生** ✨ |

---

## 🐳 Docker 集成

### Docker Desktop 集成

**支持平台**: macOS (Intel/Apple Silicon), Windows (WSL2), Linux

#### 1. 启用 WasmEdge 支持

**Docker Desktop 设置**:

```bash
# 检查 Docker Desktop 版本 (需要 24.0+)
docker version

# 在 Docker Desktop 设置中启用 containerd 和 Wasm
# Settings → Features in Development →
#   ✅ Use containerd for pulling and storing images
#   ✅ Enable Wasm
```

**或通过命令行配置** (`~/.docker/daemon.json`):

```json
{
  "features": {
    "containerd-snapshotter": true
  },
  "runtimes": {
    "wasmedge": {
      "path": "/usr/local/bin/containerd-shim-wasmedge-v1"
    }
  }
}
```

#### 2. 构建 Wasm 容器镜像

**项目结构**:

```text
wasm-app/
├── Cargo.toml
├── src/
│   └── main.rs
└── Dockerfile
```

**Dockerfile**:

```dockerfile
# 多阶段构建 - Stage 1: 构建 Wasm
FROM rust:1.90-slim AS builder

# 安装 wasm32-wasi 目标
RUN rustup target add wasm32-wasi

WORKDIR /app
COPY . .

# 编译为 wasm32-wasi
RUN cargo build --target wasm32-wasi --release

# Stage 2: 运行时镜像
FROM scratch

# 从 builder 复制 wasm 文件
COPY --from=builder /app/target/wasm32-wasi/release/app.wasm /app.wasm

# 指定 wasm 运行时
LABEL "module.wasm.image/variant" = "compat-smart"

# 入口点
ENTRYPOINT [ "/app.wasm" ]
```

**构建和运行**:

```bash
# 构建镜像
docker build --platform wasi/wasm -t my-wasm-app:latest .

# 运行容器（使用 WasmEdge）
docker run --rm \
  --runtime=io.containerd.wasmedge.v1 \
  --platform=wasi/wasm \
  my-wasm-app:latest

# 查看容器信息
docker inspect my-wasm-app | grep -A 5 "Runtime"
```

### Docker CLI 与 WasmEdge

#### 运行选项详解

```bash
# 基本运行
docker run --runtime=io.containerd.wasmedge.v1 \
  --platform=wasi/wasm \
  my-app:latest

# 挂载卷（访问主机文件）
docker run --runtime=io.containerd.wasmedge.v1 \
  --platform=wasi/wasm \
  -v $(pwd)/data:/data:ro \
  my-app:latest /data/input.txt

# 端口映射（HTTP 服务）
docker run --runtime=io.containerd.wasmedge.v1 \
  --platform=wasi/wasm \
  -p 8080:8080 \
  my-http-server:latest

# 环境变量
docker run --runtime=io.containerd.wasmedge.v1 \
  --platform=wasi/wasm \
  -e LOG_LEVEL=debug \
  -e DATABASE_URL=postgres://... \
  my-app:latest

# 资源限制
docker run --runtime=io.containerd.wasmedge.v1 \
  --platform=wasi/wasm \
  --memory=64m \
  --cpus=0.5 \
  my-app:latest
```

### 多架构镜像构建

**使用 Docker Buildx 构建多平台镜像**:

```bash
# 创建 buildx builder
docker buildx create --name wasm-builder --use

# 构建多架构镜像
docker buildx build \
  --platform linux/amd64,linux/arm64,wasi/wasm \
  -t my-registry/my-app:latest \
  --push \
  .

# 查看镜像清单
docker buildx imagetools inspect my-registry/my-app:latest
```

**Dockerfile 多平台优化**:

```dockerfile
# 使用构建参数支持多平台
ARG TARGETPLATFORM
ARG BUILDPLATFORM

FROM --platform=$BUILDPLATFORM rust:1.90-slim AS builder

# 根据目标平台选择编译目标
RUN case "$TARGETPLATFORM" in \
      "linux/amd64") RUST_TARGET=x86_64-unknown-linux-musl ;; \
      "linux/arm64") RUST_TARGET=aarch64-unknown-linux-musl ;; \
      "wasi/wasm") RUST_TARGET=wasm32-wasi ;; \
      *) echo "Unsupported platform: $TARGETPLATFORM" && exit 1 ;; \
    esac && \
    rustup target add $RUST_TARGET && \
    echo "RUST_TARGET=$RUST_TARGET" > /tmp/target

WORKDIR /app
COPY . .

RUN . /tmp/target && \
    cargo build --target $RUST_TARGET --release

# 运行时阶段
FROM scratch
COPY --from=builder /app/target/*/release/app* /app
ENTRYPOINT ["/app"]
```

---

## ☸️ Kubernetes 深度集成

### RuntimeClass 配置

**为什么使用 RuntimeClass？**

- 同一集群支持多种运行时（Linux 容器、Wasm 容器）
- Pod 级别的运行时选择
- 透明的资源调度

#### 1. 安装 containerd-shim-wasmedge

**在每个 Kubernetes 节点上安装**:

```bash
# 下载 containerd-shim-wasmedge
curl -LO https://github.com/containerd/runwasi/releases/download/containerd-shim-wasmedge/v0.3.0/containerd-shim-wasmedge-v1-linux-x86_64.tar.gz

# 解压并安装
sudo tar -C /usr/local/bin -xzf containerd-shim-wasmedge-v1-linux-x86_64.tar.gz

# 验证安装
containerd-shim-wasmedge-v1 --version
```

#### 2. 配置 containerd

**编辑 `/etc/containerd/config.toml`**:

```toml
version = 2

[plugins."io.containerd.grpc.v1.cri"]
  [plugins."io.containerd.grpc.v1.cri".containerd]
    default_runtime_name = "runc"

    [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
      # 标准 runc 运行时
      [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
        runtime_type = "io.containerd.runc.v2"

      # WasmEdge 运行时
      [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.wasmedge]
        runtime_type = "io.containerd.wasmedge.v1"

        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.wasmedge.options]
          BinaryName = "/usr/local/bin/containerd-shim-wasmedge-v1"
```

**重启 containerd**:

```bash
sudo systemctl restart containerd
sudo systemctl status containerd
```

#### 3. 创建 RuntimeClass

**runtimeclass.yaml**:

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: wasmedge
handler: wasmedge  # 对应 containerd 配置中的运行时名称

---
# 可选：为特定场景创建多个 RuntimeClass
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: wasmedge-ai  # AI 推理专用
handler: wasmedge
scheduling:
  nodeSelector:
    wasm.capable: "true"
    gpu.available: "true"
  tolerations:
  - key: "workload"
    operator: "Equal"
    value: "ai-inference"
    effect: "NoSchedule"
```

**应用配置**:

```bash
kubectl apply -f runtimeclass.yaml

# 验证
kubectl get runtimeclass
```

### CRI 插件集成

**containerd 与 kubelet 的集成架构**:

```text
┌───────────────────────────────────────┐
│           kubelet                     │
└───────────────┬───────────────────────┘
                │ CRI gRPC
┌───────────────▼───────────────────────┐
│        containerd (CRI Plugin)        │
│  ┌─────────────────────────────────┐  │
│  │  Runtime Manager                │  │
│  │  ├─ runc (Linux containers)     │  │
│  │  └─ wasmedge (Wasm containers)  │  │
│  └─────────────────────────────────┘  │
└───────────────────────────────────────┘
                │
        ┌───────┴────────┐
        ▼                ▼
┌───────────────┐  ┌──────────────────┐
│ containerd-   │  │ containerd-shim- │
│ shim-runc-v2  │  │ wasmedge-v1      │
└───────────────┘  └──────────────────┘
        │                │
        ▼                ▼
┌───────────────┐  ┌──────────────────┐
│ Linux Process │  │ WasmEdge Runtime │
└───────────────┘  └──────────────────┘
```

### Workload 部署策略

#### Deployment 示例

**wasm-deployment.yaml**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wasm-http-server
  labels:
    app: wasm-server
    runtime: wasmedge
spec:
  replicas: 5
  selector:
    matchLabels:
      app: wasm-server
  template:
    metadata:
      labels:
        app: wasm-server
        runtime: wasmedge
      annotations:
        # 可选：注入性能指标
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
    spec:
      # 指定使用 WasmEdge 运行时
      runtimeClassName: wasmedge

      containers:
      - name: wasm-server
        image: my-registry/wasm-http-server:latest

        ports:
        - name: http
          containerPort: 8080
          protocol: TCP

        # Wasm 容器的资源限制通常很小
        resources:
          requests:
            memory: "16Mi"
            cpu: "50m"
          limits:
            memory: "64Mi"
            cpu: "200m"

        # 健康检查
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 1
          periodSeconds: 10
          timeoutSeconds: 2

        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 1
          periodSeconds: 5

        # 环境变量
        env:
        - name: LOG_LEVEL
          value: "info"
        - name: PORT
          value: "8080"

        # 挂载配置
        volumeMounts:
        - name: config
          mountPath: /etc/config
          readOnly: true

      volumes:
      - name: config
        configMap:
          name: wasm-server-config

      # 节点选择（可选）
      nodeSelector:
        wasm.capable: "true"

      # 容忍度（可选）
      tolerations:
      - key: "workload"
        operator: "Equal"
        value: "wasm"
        effect: "NoSchedule"
```

#### Service 配置

**wasm-service.yaml**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wasm-http-server
  labels:
    app: wasm-server
spec:
  type: ClusterIP
  selector:
    app: wasm-server
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP

  # 会话亲和性（可选）
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 3600

---
# Headless Service（用于 StatefulSet）
apiVersion: v1
kind: Service
metadata:
  name: wasm-server-headless
spec:
  clusterIP: None
  selector:
    app: wasm-server
  ports:
  - port: 8080
```

#### HorizontalPodAutoscaler (HPA)

**wasm-hpa.yaml**:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: wasm-server-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wasm-http-server

  minReplicas: 2
  maxReplicas: 50  # Wasm 容器轻量，可以大规模扩展

  metrics:
  # CPU 利用率
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

  # 内存利用率
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

  # 自定义指标（需要 Prometheus Adapter）
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"

  # 扩缩容行为
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 15
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 10
        periodSeconds: 15
      selectPolicy: Max
```

#### Ingress 配置

**wasm-ingress.yaml**:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: wasm-server-ingress
  annotations:
    # NGINX Ingress Controller 配置
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rate-limit: "100"

    # 连接超时（Wasm 响应快）
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "5"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "10"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "10"
spec:
  ingressClassName: nginx
  rules:
  - host: wasm-app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: wasm-http-server
            port:
              number: 80

  tls:
  - hosts:
    - wasm-app.example.com
    secretName: wasm-app-tls
```

---

## 🔧 containerd 集成

### containerd shim 机制

**shim 的作用**:

1. 作为 containerd 和容器运行时之间的桥梁
2. 管理容器生命周期（启动、停止、删除）
3. 处理 stdio 流
4. 报告容器状态

**WasmEdge shim 架构**:

```text
containerd
    ↓ (create container)
containerd-shim-wasmedge-v1
    ↓ (load and execute)
WasmEdge Runtime
    ↓ (run)
WebAssembly Module
```

### runwasi 项目

**runwasi** 是一个通用的 WASM 运行时容器化框架，支持多种 WASM 运行时。

**支持的运行时**:

- ✅ WasmEdge
- ✅ wasmtime
- ✅ wasmer

**从源码构建 shim**:

```bash
# 克隆 runwasi 仓库
git clone https://github.com/containerd/runwasi.git
cd runwasi

# 构建 WasmEdge shim
cargo build --release -p containerd-shim-wasmedge

# 安装
sudo install -D -m 755 target/release/containerd-shim-wasmedge-v1 \
  /usr/local/bin/containerd-shim-wasmedge-v1

# 验证
containerd-shim-wasmedge-v1 --version
```

**自定义 shim 配置**:

```rust
// 示例：自定义 WasmEdge 配置
use containerd_shim_wasm::sandbox::ShimCli;

fn main() {
    // 自定义 WasmEdge 启动参数
    let options = wasmedge::WasmEdgeOptions {
        enable_wasi: true,
        enable_nn: true,
        enable_crypto: true,
        max_memory_pages: 256, // 16MB
    };

    ShimCli::run("containerd-shim-wasmedge-v1", options);
}
```

---

## 📝 容器编排最佳实践

### 1. 资源配额设置

**为 Wasm workload 创建专用 Namespace 和 ResourceQuota**:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wasm-workloads
  labels:
    runtime: wasmedge

---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: wasm-quota
  namespace: wasm-workloads
spec:
  hard:
    # Wasm 容器资源占用小，可以运行更多实例
    requests.cpu: "10"
    requests.memory: 2Gi
    limits.cpu: "20"
    limits.memory: 4Gi
    pods: "200"  # 允许大量 Pod
```

### 2. 节点亲和性与污点

**标记支持 Wasm 的节点**:

```bash
# 添加标签
kubectl label nodes node-1 node-2 node-3 \
  wasm.capable=true \
  wasm.runtime=wasmedge

# 添加污点（可选，确保只有 Wasm workload 调度到这些节点）
kubectl taint nodes node-1 node-2 node-3 \
  workload=wasm:NoSchedule
```

**Pod 配置示例**:

```yaml
spec:
  # 亲和性
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: wasm.capable
            operator: In
            values:
            - "true"

    # Pod 反亲和性（分散部署）
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - wasm-server
          topologyKey: kubernetes.io/hostname

  # 容忍度
  tolerations:
  - key: "workload"
    operator: "Equal"
    value: "wasm"
    effect: "NoSchedule"
```

### 3. 配置管理

**ConfigMap 示例**:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wasm-server-config
  namespace: wasm-workloads
data:
  config.toml: |
    [server]
    host = "0.0.0.0"
    port = 8080
    workers = 4

    [logging]
    level = "info"
    format = "json"

  app.json: |
    {
      "features": {
        "ai_enabled": true,
        "cache_enabled": true
      }
    }
```

### 4. 秘密管理

**Secret 示例**:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: wasm-app-secrets
  namespace: wasm-workloads
type: Opaque
stringData:
  DATABASE_URL: "postgres://user:pass@db:5432/mydb"
  API_KEY: "your-secret-api-key"

---
# 在 Pod 中使用
spec:
  containers:
  - name: wasm-app
    envFrom:
    - secretRef:
        name: wasm-app-secrets
```

---

## 🚀 生产环境部署

### 完整部署流程

**1. 准备集群**:

```bash
# 检查节点是否支持 Wasm
kubectl get nodes -o wide

# 安装 containerd-shim-wasmedge
# (在每个节点上执行，可以使用 DaemonSet 自动化)
```

**2. 部署 DaemonSet 安装 shim**:

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: wasmedge-installer
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: wasmedge-installer
  template:
    metadata:
      labels:
        name: wasmedge-installer
    spec:
      hostPID: true
      hostNetwork: true
      initContainers:
      - name: install-shim
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          apk add --no-cache curl tar
          cd /host/usr/local/bin
          curl -LO https://github.com/containerd/runwasi/releases/download/containerd-shim-wasmedge/v0.3.0/containerd-shim-wasmedge-v1-linux-x86_64.tar.gz
          tar -xzf containerd-shim-wasmedge-v1-linux-x86_64.tar.gz
          chmod +x containerd-shim-wasmedge-v1
          echo "WasmEdge shim installed successfully"
        volumeMounts:
        - name: host-bin
          mountPath: /host/usr/local/bin
        securityContext:
          privileged: true

      containers:
      - name: pause
        image: gcr.io/google_containers/pause:3.9

      volumes:
      - name: host-bin
        hostPath:
          path: /usr/local/bin
          type: Directory
```

**3. 应用完整配置**:

```bash
# 创建 namespace
kubectl create namespace wasm-prod

# 应用 RuntimeClass
kubectl apply -f runtimeclass.yaml

# 应用应用配置
kubectl apply -f wasm-deployment.yaml -n wasm-prod
kubectl apply -f wasm-service.yaml -n wasm-prod
kubectl apply -f wasm-hpa.yaml -n wasm-prod
kubectl apply -f wasm-ingress.yaml -n wasm-prod

# 检查状态
kubectl get all -n wasm-prod
kubectl get runtimeclass
```

### 滚动更新策略

**wasm-deployment.yaml** (更新策略部分):

```yaml
spec:
  replicas: 10

  # 滚动更新策略
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 5        # Wasm 启动快，可以更激进
      maxUnavailable: 2

  # 修订历史限制
  revisionHistoryLimit: 5
```

**执行滚动更新**:

```bash
# 更新镜像
kubectl set image deployment/wasm-http-server \
  wasm-server=my-registry/wasm-http-server:v2.0 \
  -n wasm-prod

# 监控更新进度
kubectl rollout status deployment/wasm-http-server -n wasm-prod

# 如果出现问题，回滚
kubectl rollout undo deployment/wasm-http-server -n wasm-prod
```

---

## 📊 监控与可观测性

### Prometheus 集成

**ServiceMonitor 配置**:

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: wasm-server-monitor
  namespace: wasm-prod
  labels:
    app: wasm-server
spec:
  selector:
    matchLabels:
      app: wasm-server
  endpoints:
  - port: metrics
    interval: 15s
    path: /metrics
```

**在 Wasm 应用中暴露 Prometheus 指标** (Rust 示例):

```rust
// Cargo.toml 添加依赖
// prometheus = "0.13"
// lazy_static = "1.4"

use prometheus::{Encoder, TextEncoder, Counter, Histogram, Registry};
use lazy_static::lazy_static;

lazy_static! {
    static ref REGISTRY: Registry = Registry::new();

    static ref HTTP_REQUESTS: Counter = Counter::new(
        "http_requests_total",
        "Total HTTP requests"
    ).unwrap();

    static ref HTTP_DURATION: Histogram = Histogram::new(
        "http_request_duration_seconds",
        "HTTP request duration"
    ).unwrap();
}

// 初始化指标
pub fn init_metrics() {
    REGISTRY.register(Box::new(HTTP_REQUESTS.clone())).unwrap();
    REGISTRY.register(Box::new(HTTP_DURATION.clone())).unwrap();
}

// 暴露 /metrics 端点
pub fn metrics_handler() -> String {
    let encoder = TextEncoder::new();
    let metric_families = REGISTRY.gather();
    let mut buffer = vec![];
    encoder.encode(&metric_families, &mut buffer).unwrap();
    String::from_utf8(buffer).unwrap()
}
```

### Grafana 仪表板

**示例指标查询**:

```promql
# Wasm 容器数量
count(kube_pod_info{runtime="wasmedge"})

# 平均启动时间
histogram_quantile(0.99,
  rate(container_start_duration_seconds_bucket{runtime="wasmedge"}[5m])
)

# 内存使用率
sum(container_memory_usage_bytes{runtime="wasmedge"}) /
sum(container_spec_memory_limit_bytes{runtime="wasmedge"}) * 100

# 每秒请求数
rate(http_requests_total{app="wasm-server"}[1m])

# P99 延迟
histogram_quantile(0.99,
  rate(http_request_duration_seconds_bucket{app="wasm-server"}[5m])
)
```

### 日志聚合

**Fluent Bit 配置** (采集 Wasm 容器日志):

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: logging
data:
  fluent-bit.conf: |
    [INPUT]
        Name              tail
        Tag               kube.*
        Path              /var/log/containers/*wasm*.log
        Parser            docker
        DB                /var/log/flb_kube.db
        Mem_Buf_Limit     5MB
        Skip_Long_Lines   On
        Refresh_Interval  10

    [FILTER]
        Name                kubernetes
        Match               kube.*
        Kube_URL            https://kubernetes.default.svc:443
        Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token
        Labels              On
        Annotations         On

    [FILTER]
        Name                grep
        Match               kube.*
        Regex               kubernetes_labels_runtime wasmedge

    [OUTPUT]
        Name                elasticsearch
        Match               kube.*
        Host                elasticsearch.logging.svc
        Port                9200
        Index               wasm-logs
        Type                _doc
```

---

## 🔒 安全与隔离

### 1. Pod Security Standards

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wasm-prod
  labels:
    # 应用 restricted 安全标准
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

### 2. NetworkPolicy

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: wasm-server-netpol
  namespace: wasm-prod
spec:
  podSelector:
    matchLabels:
      app: wasm-server
  policyTypes:
  - Ingress
  - Egress

  # 入站规则
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    - podSelector:
        matchLabels:
          app: monitoring
    ports:
    - protocol: TCP
      port: 8080
    - protocol: TCP
      port: 9090  # Prometheus metrics

  # 出站规则
  egress:
  # 允许访问 DNS
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53

  # 允许访问外部 API
  - to:
    - podSelector: {}
    ports:
    - protocol: TCP
      port: 443
```

### 3. SecurityContext

```yaml
spec:
  securityContext:
    # Pod 级别安全上下文
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  containers:
  - name: wasm-server
    securityContext:
      # 容器级别安全上下文
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
```

---

## ⚡ 性能调优

### 1. 资源请求和限制优化

**针对不同负载的建议**:

```yaml
# 轻量级 API 服务
resources:
  requests:
    memory: "8Mi"
    cpu: "25m"
  limits:
    memory: "32Mi"
    cpu: "100m"

---
# 数据处理服务
resources:
  requests:
    memory: "32Mi"
    cpu: "100m"
  limits:
    memory: "128Mi"
    cpu: "500m"

---
# AI 推理服务
resources:
  requests:
    memory: "128Mi"
    cpu: "500m"
  limits:
    memory: "512Mi"
    cpu: "2000m"
```

### 2. 亲和性调优

```yaml
spec:
  # 拓扑分布约束（确保均匀分布）
  topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        app: wasm-server
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
    labelSelector:
      matchLabels:
        app: wasm-server
```

### 3. HPA 调优

```yaml
spec:
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60  # Wasm 效率高，降低阈值

  # 行为调优
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 10  # 快速扩容
      policies:
      - type: Percent
        value: 200
        periodSeconds: 15
    scaleDown:
      stabilizationWindowSeconds: 120  # 保守缩容
```

---

## 🎯 实战案例

### 案例 1: 微服务 API Gateway (Wasm)

**架构**:

```text
Internet → Ingress → Wasm API Gateway → Backend Services
                          ↓
                    (AI 推理、鉴权、限流)
```

**完整部署**:

```yaml
# 1. Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wasm-api-gateway
spec:
  replicas: 10
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      runtimeClassName: wasmedge
      containers:
      - name: gateway
        image: my-registry/wasm-api-gateway:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "16Mi"
            cpu: "50m"
          limits:
            memory: "64Mi"
            cpu: "200m"
        env:
        - name: BACKEND_URLS
          value: "http://service-a:8080,http://service-b:8080"
        - name: RATE_LIMIT
          value: "1000"

---
# 2. Service
apiVersion: v1
kind: Service
metadata:
  name: api-gateway
spec:
  selector:
    app: api-gateway
  ports:
  - port: 80
    targetPort: 8080

---
# 3. HPA
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-gateway-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wasm-api-gateway
  minReplicas: 5
  maxReplicas: 100
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

### 案例 2: 边缘 AI 推理服务

**场景**: 在边缘节点运行 AI 模型推理

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: edge-ai-inference
spec:
  selector:
    matchLabels:
      app: edge-ai
  template:
    metadata:
      labels:
        app: edge-ai
    spec:
      runtimeClassName: wasmedge
      nodeSelector:
        node-role.kubernetes.io/edge: "true"

      containers:
      - name: ai-inference
        image: my-registry/wasm-ai-inference:latest
        command:
        - /ai-inference.wasm
        args:
        - --model=/models/model.tflite

        resources:
          requests:
            memory: "128Mi"
            cpu: "500m"
          limits:
            memory: "512Mi"
            cpu: "2000m"

        volumeMounts:
        - name: models
          mountPath: /models
          readOnly: true

        env:
        - name: WASM_ENABLE_NN
          value: "true"

      volumes:
      - name: models
        hostPath:
          path: /opt/ai-models
          type: Directory
```

### 案例 3: Serverless 函数平台

**使用 Knative + WasmEdge 构建 Serverless**:

```yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: wasm-function
spec:
  template:
    metadata:
      annotations:
        # 指定运行时
        run.googleapis.com/execution-environment: wasm
    spec:
      runtimeClassName: wasmedge

      containers:
      - image: my-registry/wasm-function:latest
        ports:
        - containerPort: 8080

        # Wasm 冷启动极快，可以设置更激进的缩容
        resources:
          requests:
            memory: "8Mi"
            cpu: "25m"
          limits:
            memory: "32Mi"
            cpu: "100m"

      # 缩容到 0
      containerConcurrency: 100
      timeoutSeconds: 60

  traffic:
  - percent: 100
    latestRevision: true
```

---

## 📚 总结

### 关键优势

| 方面 | 优势 | 量化指标 |
| --- | --- | --- |
| **启动速度** | 冷启动极快 | 1-10ms (vs 100-1000ms) |
| **资源占用** | 内存/CPU 占用小 | 5-50MB (vs 100MB-1GB) |
| **密度** | 更高的容器密度 | 10-50倍 |
| **安全性** | Wasm 沙箱隔离 | 更强的隔离保证 |
| **可移植性** | 真正的跨平台 | 一次构建，到处运行 |

### 最佳实践清单

- ✅ 使用 RuntimeClass 管理多运行时
- ✅ 为 Wasm 工作负载创建专用节点池
- ✅ 设置合理的资源请求和限制
- ✅ 利用 HPA 实现自动扩缩容
- ✅ 配置监控和日志聚合
- ✅ 应用网络策略和安全上下文
- ✅ 使用拓扑分布约束确保高可用
- ✅ 定期更新 WasmEdge 运行时和 shim

### 参考资源

- [WasmEdge 官方文档](https://wasmedge.org/docs/)
- [containerd runwasi 项目](https://github.com/containerd/runwasi)
- [Kubernetes RuntimeClass 文档](https://kubernetes.io/docs/concepts/containers/runtime-class/)
- [Docker + Wasm 技术预览](https://www.docker.com/blog/docker-wasm-technical-preview/)
- [CNCF Wasm 工作组](https://github.com/cncf/tag-runtime/blob/main/wasm/README.md)

---

**文档维护**: Documentation Team
**最后更新**: 2025-12-11
**适用版本**: WasmEdge 0.13+, Docker 24.0+, Kubernetes 1.28+
