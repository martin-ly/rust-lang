# C12 WASM - 性能优化指南

> **文档类型**: Tier 2 - 实践层
> **文档定位**: WASM 性能优化技术和最佳实践
> **项目状态**: ✅ 完整完成
> **相关文档**: [JavaScript 互操作](./03_javascript_互操作.md) | [性能分析与优化](../tier_04_advanced/02_性能分析与优化.md)

**最后更新**: 2025-10-30
**适用版本**: Rust 1.90+ / Edition 2024, WASM 2.0 + WASI 0.2

---

## 📋 目录

- [C12 WASM - 性能优化指南](#c12-wasm---性能优化指南)
  - [📊 目录](#-目录)
  - [🎯 概述](#-概述)
  - [📦 二进制大小优化](#-二进制大小优化)
  - [⚡ 运行时性能优化](#-运行时性能优化)
  - [🧠 内存优化](#-内存优化)
  - [🚀 加载优化](#-加载优化)
  - [🔧 工具推荐](#-工具推荐)
  - [📚 相关资源](#-相关资源)

---

## 🎯 概述

本指南介绍 WASM 性能优化的各个方面：

- 二进制大小优化
- 运行时性能优化
- 内存使用优化
- 加载时间优化

---

## 📦 二进制大小优化

### 编译选项优化

```toml
[profile.release]
opt-level = "z"      # 优化大小（最小）
# opt-level = "s"   # 优化大小（平衡）
lto = true           # 链接时优化
codegen-units = 1    # 单一代码生成单元
strip = true         # 去除调试符号
```

### 使用 wasm-opt

```bash
# 安装 wasm-opt
npm install -g wasm-opt

# 优化二进制大小
wasm-opt -Oz -o output.wasm input.wasm

# 优化执行性能
wasm-opt -O3 -o output.wasm input.wasm

# 同时优化大小和性能
wasm-opt -O3 --strip-debug -o output.wasm input.wasm
```

### 减少依赖

```toml
# 只引入需要的特性
[dependencies]
some-crate = { version = "1.0", default-features = false, features = ["needed"] }
```

---

## ⚡ 运行时性能优化

### 减少内存分配

```rust
// ❌ 不好：每次都分配新 Vec
pub fn process_bad(data: &[i32]) -> Vec<i32> {
    let mut result = Vec::new();
    for &item in data {
        result.push(item * 2);
    }
    result
}

// ✅ 好：预分配容量
pub fn process_good(data: &[i32]) -> Vec<i32> {
    let mut result = Vec::with_capacity(data.len());
    for &item in data {
        result.push(item * 2);
    }
    result
}
```

### 重用缓冲区

```rust
// 重用 Vec 而不是重新分配
thread_local! {
    static BUFFER: RefCell<Vec<u8>> = RefCell::new(Vec::new());
}

pub fn process_with_reuse(data: &[u8]) -> Vec<u8> {
    BUFFER.with(|buf| {
        let mut buffer = buf.borrow_mut();
        buffer.clear();
        buffer.extend_from_slice(data);
        // ... 处理
        buffer.clone()
    })
}
```

### 避免不必要的复制

```rust
// ❌ 不好：不必要的克隆
pub fn bad_example(s: String) -> String {
    s.clone()
}

// ✅ 好：使用引用或移动
pub fn good_example(s: &str) -> &str {
    s
}
```

---

## 🧠 内存优化

### 使用栈分配

```rust
// 小数据使用栈分配
const SMALL_SIZE: usize = 100;
let mut buffer: [u8; SMALL_SIZE] = [0; SMALL_SIZE];
```

### 避免内存泄漏

```rust
// 及时释放不需要的资源
{
    let data = expensive_operation();
    // 使用 data
} // data 在这里自动释放
```

### 使用对象池

```rust
use std::collections::VecDeque;

pub struct ObjectPool<T> {
    pool: VecDeque<T>,
}

impl<T> ObjectPool<T> {
    pub fn new() -> Self {
        Self { pool: VecDeque::new() }
    }

    pub fn get(&mut self) -> Option<T> {
        self.pool.pop_front()
    }

    pub fn return_obj(&mut self, obj: T) {
        self.pool.push_back(obj);
    }
}
```

---

## 🚀 加载优化

### 压缩传输

```bash
# 使用 gzip 压缩
gzip -9 module.wasm

# 使用 brotli 压缩（更好的压缩率）
brotli -9 module.wasm
```

### 延迟加载

```javascript
// 按需加载 WASM 模块
async function loadWasmWhenNeeded() {
  const wasm = await import('./pkg/hello_wasm');
  await wasm.default();
  return wasm;
}

// 使用
const wasm = await loadWasmWhenNeeded();
wasm.greet("World");
```

### 预加载

```html
<!-- 预加载 WASM 模块 -->
<link rel="preload" href="module.wasm" as="fetch" crossorigin>
```

---

## 🔧 工具推荐

### 分析工具

- **wasm-pack**: 构建和优化工具
- **wasm-opt**: Binaryen 优化工具
- **cargo-bloat**: 分析二进制大小
- **wasm-bindgen**: 生成绑定代码

### 性能分析

```bash
# 分析二进制大小
cargo bloat --release --target wasm32-unknown-unknown

# 使用 wasm-opt 分析
wasm-opt --print-function-sizes module.wasm
```

---

## 📚 相关资源

- [Rust 编译 WASM](./02_rust_编译_wasm.md) - 学习编译流程
- [性能分析与优化](../tier_04_advanced/02_性能分析与优化.md) - 高级优化
- [最佳实践](../tier_03_references/03_最佳实践.md) - 开发规范

**外部资源**:

- [wasm-opt 文档](https://github.com/WebAssembly/binaryen)
- [WASM 性能指南](https://web.dev/webassembly/)

---

**文档维护**: Documentation Team
**创建日期**: 2025-10-30
**适用版本**: Rust 1.90+ / Edition 2024, WASM 2.0 + WASI 0.2
