# 1.2 C11 å¼€å‘åº“ - æœ¯è¯­è¡¨ (Glossary)

> **æ–‡æ¡£å®šä½**: Rust å¼€å‘åº“æ ¸å¿ƒæœ¯è¯­æ·±åº¦å‚è€ƒï¼Œæ¶µç›–æ¦‚å¿µå®šä¹‰ã€ç†è®ºè®ºè¿°ã€å…³ç³»åˆ†æ  
> **é€‚ç”¨äººç¾¤**: æ‰€æœ‰å¼€å‘è€…ï¼ˆæ¨èç³»ç»Ÿå­¦ä¹ ï¼‰  
> **å…³è”æ–‡æ¡£**: [1.0 é¡¹ç›®æ¦‚è§ˆ](1.0_é¡¹ç›®æ¦‚è§ˆ.md) | [1.1 ä¸»ç´¢å¼•å¯¼èˆª](1.1_ä¸»ç´¢å¼•å¯¼èˆª.md) | [1.3 å¸¸è§é—®é¢˜](1.3_å¸¸è§é—®é¢˜.md)

**æœ€åæ›´æ–°**: 2025-10-21  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [1.2 C11 å¼€å‘åº“ - æœ¯è¯­è¡¨ (Glossary)](#12-c11-å¼€å‘åº“---æœ¯è¯­è¡¨-glossary)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1.2.1 å¿«é€Ÿç´¢å¼•](#121-å¿«é€Ÿç´¢å¼•)
  - [1.2.2 è¯­è¨€ç‰¹æ€§](#122-è¯­è¨€ç‰¹æ€§)
    - [1.2.2.1 async fn in trait](#1221-async-fn-in-trait)
    - [1.2.2.2 RPITIT](#1222-rpitit)
    - [1.2.2.3 æ³›å‹å…³è”ç±»å‹ (GAT)](#1223-æ³›å‹å…³è”ç±»å‹-gat)
    - [1.2.2.4 Const Generics](#1224-const-generics)
    - [1.2.2.5 å¼‚æ­¥ç¼–ç¨‹ (Async/Await)](#1225-å¼‚æ­¥ç¼–ç¨‹-asyncawait)
    - [1.2.2.6 Future å’Œ Poll](#1226-future-å’Œ-poll)
    - [1.2.2.7 Pin å’Œ Unpin](#1227-pin-å’Œ-unpin)
  - [1.2.3 æ•°æ®åº“ç”Ÿæ€](#123-æ•°æ®åº“ç”Ÿæ€)
    - [1.2.3.1 SQL](#1231-sql)
    - [1.2.3.2 ORM (å¯¹è±¡å…³ç³»æ˜ å°„)](#1232-orm-å¯¹è±¡å…³ç³»æ˜ å°„)
    - [1.2.3.3 è¿æ¥æ±  (Connection Pool)](#1233-è¿æ¥æ± -connection-pool)
    - [1.2.3.4 äº‹åŠ¡ (Transaction)](#1234-äº‹åŠ¡-transaction)
    - [1.2.3.5 è¿ç§» (Migration)](#1235-è¿ç§»-migration)
    - [1.2.3.6 é¢„ç¼–è¯‘è¯­å¥ (Prepared Statement)](#1236-é¢„ç¼–è¯‘è¯­å¥-prepared-statement)
  - [1.2.4 ç¼“å­˜ç³»ç»Ÿ](#124-ç¼“å­˜ç³»ç»Ÿ)
    - [1.2.4.1 Redis](#1241-redis)
    - [1.2.4.2 Pipeline](#1242-pipeline)
    - [1.2.4.3 Pub/Sub (å‘å¸ƒ/è®¢é˜…)](#1243-pubsub-å‘å¸ƒè®¢é˜…)
    - [1.2.4.4 åˆ†å¸ƒå¼é” (Distributed Lock)](#1244-åˆ†å¸ƒå¼é”-distributed-lock)
    - [1.2.4.5 TTL (è¿‡æœŸæ—¶é—´)](#1245-ttl-è¿‡æœŸæ—¶é—´)
    - [1.2.4.6 ç¼“å­˜ç©¿é€ã€å‡»ç©¿ã€é›ªå´©](#1246-ç¼“å­˜ç©¿é€å‡»ç©¿é›ªå´©)
  - [1.2.5 æ¶ˆæ¯é˜Ÿåˆ—](#125-æ¶ˆæ¯é˜Ÿåˆ—)
    - [1.2.5.1 Kafka](#1251-kafka)
    - [1.2.5.2 MQTT](#1252-mqtt)
    - [1.2.5.3 NATS](#1253-nats)
    - [1.2.5.4 RabbitMQ](#1254-rabbitmq)
    - [1.2.5.5 æ¶ˆæ¯è¯­ä¹‰ (Delivery Semantics)](#1255-æ¶ˆæ¯è¯­ä¹‰-delivery-semantics)
    - [1.2.5.6 æ­»ä¿¡é˜Ÿåˆ— (Dead Letter Queue)](#1256-æ­»ä¿¡é˜Ÿåˆ—-dead-letter-queue)
  - [1.2.6 Web æ¡†æ¶](#126-web-æ¡†æ¶)
    - [1.2.6.1 Axum](#1261-axum)
    - [1.2.6.2 Tower](#1262-tower)
    - [1.2.6.3 ä¸­é—´ä»¶ (Middleware)](#1263-ä¸­é—´ä»¶-middleware)
    - [1.2.6.4 è·¯ç”± (Routing)](#1264-è·¯ç”±-routing)
    - [1.2.6.5 æå–å™¨ (Extractor)](#1265-æå–å™¨-extractor)
  - [1.2.7 å¼‚æ­¥è¿è¡Œæ—¶](#127-å¼‚æ­¥è¿è¡Œæ—¶)
    - [1.2.7.1 Tokio](#1271-tokio)
    - [1.2.7.2 å·¥ä½œçªƒå–è°ƒåº¦å™¨ (Work-Stealing Scheduler)](#1272-å·¥ä½œçªƒå–è°ƒåº¦å™¨-work-stealing-scheduler)
    - [1.2.7.3 Reactor å’Œ Executor](#1273-reactor-å’Œ-executor)
    - [1.2.7.4 å¼‚æ­¥é€šé“ (Async Channel)](#1274-å¼‚æ­¥é€šé“-async-channel)
  - [1.2.8 å‚è€ƒèµ„æº](#128-å‚è€ƒèµ„æº)

---

## 1.2.1 å¿«é€Ÿç´¢å¼•

**æŒ‰å­—æ¯é¡ºåº**:

A | [async fn in trait](#1221-async-fn-in-trait) | [Axum](#1261-axum)  
C | [Const Generics](#1224-const-generics) | [è¿æ¥æ± ](#1233-è¿æ¥æ± -connection-pool)  
D | [åˆ†å¸ƒå¼é”](#1244-åˆ†å¸ƒå¼é”-distributed-lock) | [æ­»ä¿¡é˜Ÿåˆ—](#1256-æ­»ä¿¡é˜Ÿåˆ—-dead-letter-queue)  
F | [Future](#1226-future-å’Œ-poll)  
G | [GAT](#1223-æ³›å‹å…³è”ç±»å‹-gat)  
K | [Kafka](#1251-kafka)  
M | [ä¸­é—´ä»¶](#1263-ä¸­é—´ä»¶-middleware) | [MQTT](#1252-mqtt) | [è¿ç§»](#1235-è¿ç§»-migration)  
N | [NATS](#1253-nats)  
O | [ORM](#1232-orm-å¯¹è±¡å…³ç³»æ˜ å°„)  
P | [Pin](#1227-pin-å’Œ-unpin) | [Pipeline](#1242-pipeline) | [Poll](#1226-future-å’Œ-poll) | [é¢„ç¼–è¯‘è¯­å¥](#1236-é¢„ç¼–è¯‘è¯­å¥-prepared-statement) | [Pub/Sub](#1243-pubsub-å‘å¸ƒè®¢é˜…)  
R | [Reactor](#1273-reactor-å’Œ-executor) | [Redis](#1241-redis) | [RabbitMQ](#1254-rabbitmq) | [RPITIT](#1222-rpitit) | [è·¯ç”±](#1264-è·¯ç”±-routing)  
S | [SQL](#1231-sql)  
T | [Tokio](#1271-tokio) | [Tower](#1262-tower) | [Transaction](#1234-äº‹åŠ¡-transaction) | [TTL](#1245-ttl-è¿‡æœŸæ—¶é—´)  
W | [å·¥ä½œçªƒå–è°ƒåº¦å™¨](#1272-å·¥ä½œçªƒå–è°ƒåº¦å™¨-work-stealing-scheduler)

---

## 1.2.2 è¯­è¨€ç‰¹æ€§

### 1.2.2.1 async fn in trait

**å®šä¹‰**: Rust 1.75+ ç¨³å®šçš„ç‰¹æ€§ï¼Œå…è®¸åœ¨ trait ä¸­ç›´æ¥ä½¿ç”¨ `async fn`ã€‚

**ç†è®ºèƒŒæ™¯**:

åœ¨ Rust 1.75 ä¹‹å‰ï¼Œtrait æ–¹æ³•ä¸èƒ½ç›´æ¥å£°æ˜ä¸º `async fn`ï¼Œéœ€è¦ä½¿ç”¨ `#[async_trait]` å®ï¼ˆæ¥è‡ª `async-trait` crateï¼‰ã€‚
è¿™æ˜¯å› ä¸º `async fn` ä¼šè¿”å›ä¸€ä¸ª `impl Future` ç±»å‹ï¼Œè€Œ trait æ–¹æ³•çš„è¿”å›ç±»å‹å¿…é¡»æ˜¯å…·ä½“çš„æˆ–è€…ä½¿ç”¨ GAT/RPITITã€‚

**è¯­æ³•**:

```rust
trait AsyncDatabase {
    async fn query(&self, sql: &str) -> Result<Vec<Row>>;
}
```

**ç­‰ä»·äº**:

```rust
trait AsyncDatabase {
    fn query(&self, sql: &str) -> impl Future<Output = Result<Vec<Row>>> + '_;
}
```

**ä¼˜ç‚¹**:

- âœ… ä¸éœ€è¦ `async-trait` ä¾èµ–
- âœ… æ›´å¥½çš„ç¼–è¯‘æ€§èƒ½ï¼ˆæ— å®å±•å¼€ï¼‰
- âœ… æ›´æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
- âœ… æ”¯æŒ `dyn Trait`ï¼ˆæœ‰é™åˆ¶ï¼‰

**é™åˆ¶**:

- âŒ `dyn AsyncDatabase` éœ€è¦é¢å¤–çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£
- âŒ è¿”å›çš„ Future ä¸èƒ½ Sendï¼ˆé™¤éæ‰‹åŠ¨æ ‡è®°ï¼‰

**åº”ç”¨åœºæ™¯**:

- æ•°æ®åº“å®¢æˆ·ç«¯ trait
- ç¼“å­˜æŠ½è±¡å±‚
- å¼‚æ­¥æœåŠ¡æ¥å£

**ç›¸å…³æœ¯è¯­**: [RPITIT](#1222-rpitit), [Future](#1226-future-å’Œ-poll)

**å‚è€ƒ**: [3.1 Rust 1.90 ç‰¹æ€§å…¨è§£æ](references/3.1_Rust_1.90_ç‰¹æ€§å…¨è§£æ.md)

---

### 1.2.2.2 RPITIT

**å®šä¹‰**: Return Position Impl Trait in Traitï¼Œtrait æ–¹æ³•å¯ä»¥è¿”å› `impl Trait`ã€‚

**ç†è®ºèƒŒæ™¯**:

RPITIT æ˜¯ Rust 1.75+ ç¨³å®šçš„è¯­è¨€ç‰¹æ€§ï¼Œè§£å†³äº† trait æ–¹æ³•è¿”å›ç±»å‹æŠ½è±¡åŒ–çš„é—®é¢˜ã€‚
åœ¨æ­¤ä¹‹å‰ï¼Œtrait æ–¹æ³•å¿…é¡»è¿”å›å…·ä½“ç±»å‹æˆ–å…³è”ç±»å‹ï¼Œè¿™é™åˆ¶äº†æ¥å£çš„çµæ´»æ€§ã€‚

**è¯­æ³•**:

```rust
trait ConfigBuilder {
    fn builder() -> impl Builder;
    fn with_timeout(self, timeout: Duration) -> impl ConfigBuilder;
}
```

**ä¼˜åŠ¿**:

- âœ… ç±»å‹æ¨å¯¼ï¼šç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼è¿”å›ç±»å‹
- âœ… é›¶æˆæœ¬æŠ½è±¡ï¼šæ— è¿è¡Œæ—¶å¼€é”€
- âœ… ç®€åŒ– APIï¼šè°ƒç”¨è€…ä¸éœ€è¦çŸ¥é“å…·ä½“ç±»å‹
- âœ… è¿­ä»£å™¨å‹å¥½ï¼šè¿”å›å¤æ‚çš„è¿­ä»£å™¨é“¾

**å¯¹æ¯” GAT**:

| ç‰¹æ€§ | RPITIT | GAT |
|------|--------|-----|
| è¯­æ³•å¤æ‚åº¦ | ç®€å• | å¤æ‚ |
| è¿”å›ç±»å‹ | éšå¼ | æ˜¾å¼ |
| çµæ´»æ€§ | ä¸­ç­‰ | é«˜ |
| é€‚ç”¨åœºæ™¯ | ç®€å•æŠ½è±¡ | é«˜çº§æŠ½è±¡ |

**åº”ç”¨åœºæ™¯**:

- é…ç½®æ„å»ºå™¨
- è¿­ä»£å™¨ trait
- ç±»å‹çŠ¶æ€æ¨¡å¼

**ç›¸å…³æœ¯è¯­**: [async fn in trait](#1221-async-fn-in-trait), [GAT](#1223-æ³›å‹å…³è”ç±»å‹-gat)

---

### 1.2.2.3 æ³›å‹å…³è”ç±»å‹ (GAT)

**å®šä¹‰**: Generic Associated Typesï¼Œå…³è”ç±»å‹å¯ä»¥æœ‰æ³›å‹å‚æ•°ã€‚

**ç†è®ºèƒŒæ™¯**:

GAT æ˜¯ Rust 1.65+ ç¨³å®šçš„ç‰¹æ€§ï¼Œå…è®¸å…³è”ç±»å‹æ‹¥æœ‰æ³›å‹å‚æ•°ã€‚
è¿™ä½¿å¾—å¯ä»¥å®šä¹‰æ›´çµæ´»çš„ traitï¼Œä¾‹å¦‚æŠ½è±¡ä¸åŒç”Ÿå‘½å‘¨æœŸçš„å€Ÿç”¨ã€ä¸åŒç±»å‹çš„è¿­ä»£å™¨ç­‰ã€‚

**è¯­æ³•**:

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next(&mut self) -> Option<Self::Item<'_>>;
}
```

**æ ¸å¿ƒèƒ½åŠ›**:

1. **ç”Ÿå‘½å‘¨æœŸå‚æ•°åŒ–**: å…³è”ç±»å‹å¯ä»¥å…³è”åˆ° `&self` çš„ç”Ÿå‘½å‘¨æœŸ
2. **ç±»å‹å‚æ•°åŒ–**: å…³è”ç±»å‹å¯ä»¥æœ‰å¤šä¸ªç±»å‹å‚æ•°
3. **é«˜çº§æŠ½è±¡**: å®ç°å¤æ‚çš„ç±»å‹å…³ç³»

**å…¸å‹åº”ç”¨**:

**1. è¿æ¥æ± æŠ½è±¡**:

```rust
trait Pool {
    type Connection<'pool> where Self: 'pool;
    
    async fn acquire(&self) -> Result<Self::Connection<'_>>;
}

impl Pool for PostgresPool {
    type Connection<'pool> = PooledConnection<'pool>;
    
    async fn acquire(&self) -> Result<Self::Connection<'_>> {
        // ...
    }
}
```

**2. å¼‚æ­¥è¿­ä»£å™¨**:

```rust
trait AsyncIterator {
    type Item<'a> where Self: 'a;
    
    async fn next(&mut self) -> Option<Self::Item<'_>>;
}
```

**ç›¸å…³æœ¯è¯­**: [RPITIT](#1222-rpitit), [ç”Ÿå‘½å‘¨æœŸ](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)

---

### 1.2.2.4 Const Generics

**å®šä¹‰**: å…è®¸æ³›å‹å‚æ•°ä¸ºç¼–è¯‘æ—¶å¸¸é‡å€¼ï¼ˆå¦‚æ•´æ•°ï¼‰ã€‚

**ç†è®ºèƒŒæ™¯**:

Const Generics æ˜¯ Rust 1.51+ ç¨³å®šçš„ç‰¹æ€§ï¼Œå…è®¸åœ¨æ³›å‹å‚æ•°ä¸­ä½¿ç”¨å¸¸é‡å€¼ã€‚è¿™ä½¿å¾—æ•°ç»„å¤§å°å¯ä»¥æ³›å‹åŒ–ï¼Œå¹¶æ”¯æŒç¼–è¯‘æ—¶è®¡ç®—å’Œä¼˜åŒ–ã€‚

**è¯­æ³•**:

```rust
struct Buffer<const N: usize> {
    data: [u8; N],
}

impl<const N: usize> Buffer<N> {
    fn new() -> Self {
        Self { data: [0; N] }
    }
}
```

**åº”ç”¨åœºæ™¯**:

**1. ç±»å‹å®‰å…¨é…ç½®**:

```rust
struct Config<const MAX_CONNECTIONS: usize = 16> {
    pool_size: usize,
}

impl<const MAX: usize> Config<MAX> {
    fn validate(&self) -> bool {
        self.pool_size <= MAX
    }
}
```

**2. å›ºå®šå¤§å°ç¼“å†²åŒº**:

```rust
struct FixedQueue<T, const N: usize> {
    items: [Option<T>; N],
    len: usize,
}
```

**ä¼˜åŠ¿**:

- âœ… ç¼–è¯‘æ—¶æ£€æŸ¥å¤§å°
- âœ… é›¶è¿è¡Œæ—¶å¼€é”€
- âœ… ç±»å‹å®‰å…¨
- âœ… SIMD ä¼˜åŒ–å‹å¥½

**ç›¸å…³æœ¯è¯­**: æ€§èƒ½ä¼˜åŒ–ã€ç±»å‹å®‰å…¨

---

### 1.2.2.5 å¼‚æ­¥ç¼–ç¨‹ (Async/Await)

**å®šä¹‰**: Rust çš„é›¶æˆæœ¬å¼‚æ­¥æŠ½è±¡ï¼Œé€šè¿‡ `async`/`await` å…³é”®å­—å®ç°åä½œå¼å¤šä»»åŠ¡ã€‚

**ç†è®ºæ¨¡å‹**:

Rust çš„å¼‚æ­¥æ¨¡å‹åŸºäº **Future trait** å’Œ **Poll-based Execution**ï¼š

```rust
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

**æ ¸å¿ƒæ¦‚å¿µ**:

1. **Future**: ä¸€ä¸ªå¯èƒ½å°šæœªå®Œæˆçš„è®¡ç®—
2. **async fn**: è¿”å› `impl Future` çš„è¯­æ³•ç³–
3. **await**: ç­‰å¾… Future å®Œæˆçš„è¯­æ³•ç³–
4. **Runtime**: æ‰§è¡Œ Future çš„è°ƒåº¦å™¨ï¼ˆå¦‚ Tokioï¼‰

**æ‰§è¡Œæµç¨‹**:

```mermaid
graph TD
    A[async fn] -->|desugared| B[Future]
    B -->|poll| C{Poll Result}
    C -->|Pending| D[Waker registered]
    C -->|Ready| E[Return value]
    D -->|I/O event| F[Wake up]
    F -->|poll again| C
```

**ä¼˜åŠ¿**:

- âœ… é›¶æˆæœ¬æŠ½è±¡ï¼šæ— é¢å¤–è¿è¡Œæ—¶å¼€é”€
- âœ… æ— éœ€ GCï¼šåŸºäºçŠ¶æ€æœºå®ç°
- âœ… å¯ç»„åˆï¼šFuture å¯ä»¥ç»„åˆå’Œé“¾å¼è°ƒç”¨
- âœ… å–æ¶ˆå®‰å…¨ï¼šæ”¯æŒ async dropï¼ˆå®éªŒä¸­ï¼‰

**å¸¸è§æ¨¡å¼**:

```rust
// å¹¶å‘æ‰§è¡Œ
let (result1, result2) = tokio::join!(future1, future2);

// é€‰æ‹©ç¬¬ä¸€ä¸ªå®Œæˆçš„
let result = tokio::select! {
    r1 = future1 => r1,
    r2 = future2 => r2,
};

// è¶…æ—¶æ§åˆ¶
let result = tokio::time::timeout(Duration::from_secs(5), future).await?;
```

**ç›¸å…³æœ¯è¯­**: [Future](#1226-future-å’Œ-poll), [Pin](#1227-pin-å’Œ-unpin), [Tokio](#1271-tokio)

**å‚è€ƒ**: [2.5 å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—](guides/2.5_å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—.md)

---

### 1.2.2.6 Future å’Œ Poll

**å®šä¹‰**: Rust å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒ traitï¼Œè¡¨ç¤ºä¸€ä¸ªå¯èƒ½å°šæœªå®Œæˆçš„å¼‚æ­¥è®¡ç®—ã€‚

**Future Trait**:

```rust
pub trait Future {
    type Output;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

**Poll æšä¸¾**:

```rust
pub enum Poll<T> {
    Ready(T),   // è®¡ç®—å®Œæˆ
    Pending,    // è®¡ç®—æœªå®Œæˆï¼Œéœ€è¦ç¨åé‡è¯•
}
```

**æ ¸å¿ƒæœºåˆ¶**:

1. **æƒ°æ€§æ‰§è¡Œ**: Future åˆ›å»ºæ—¶ä¸ä¼šç«‹å³æ‰§è¡Œ
2. **è½®è¯¢é©±åŠ¨**: é€šè¿‡ `poll` æ–¹æ³•æ¨è¿›æ‰§è¡Œ
3. **Waker æœºåˆ¶**: Pending æ—¶æ³¨å†Œå”¤é†’å™¨ï¼Œäº‹ä»¶å‘ç”Ÿæ—¶å”¤é†’
4. **çŠ¶æ€æœº**: ç¼–è¯‘å™¨å°† `async fn` ç¼–è¯‘ä¸ºçŠ¶æ€æœº

**ç¤ºä¾‹**:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct MyFuture {
    state: u32,
}

impl Future for MyFuture {
    type Output = u32;
    
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if self.state < 10 {
            self.state += 1;
            cx.waker().wake_by_ref(); // è¯·æ±‚å†æ¬¡è½®è¯¢
            Poll::Pending
        } else {
            Poll::Ready(self.state)
        }
    }
}
```

**Waker å’Œ Context**:

- **Context**: åŒ…å« Wakerï¼Œä¼ é€’ç»™ `poll`
- **Waker**: ç”¨äºå”¤é†’ Futureï¼Œå‘Šè¯‰ runtime å¯ä»¥å†æ¬¡ poll

```rust
// ç®€åŒ–çš„ Waker ä½¿ç”¨ç¤ºä¾‹
if some_condition {
    cx.waker().wake_by_ref(); // ç«‹å³å”¤é†’
    Poll::Pending
} else {
    // æ³¨å†Œ waker åˆ° I/O äº‹ä»¶
    register_waker(cx.waker().clone());
    Poll::Pending
}
```

**ç›¸å…³æœ¯è¯­**: [å¼‚æ­¥ç¼–ç¨‹](#1225-å¼‚æ­¥ç¼–ç¨‹-asyncawait), [Pin](#1227-pin-å’Œ-unpin), [Reactor](#1273-reactor-å’Œ-executor)

---

### 1.2.2.7 Pin å’Œ Unpin

**å®šä¹‰**: `Pin` æ˜¯ Rust ä¸­é˜²æ­¢æ•°æ®è¢«ç§»åŠ¨çš„ç±»å‹ï¼Œç”¨äºå®ç°è‡ªå¼•ç”¨ç»“æ„å’Œ Futureã€‚

**ç†è®ºèƒŒæ™¯**:

åœ¨å¼‚æ­¥ç¼–ç¨‹ä¸­ï¼ŒFuture å†…éƒ¨å¯èƒ½åŒ…å«è‡ªå¼•ç”¨æŒ‡é’ˆï¼ˆæŒ‡å‘è‡ªèº«å­—æ®µçš„æŒ‡é’ˆï¼‰ã€‚å¦‚æœ Future è¢«ç§»åŠ¨ï¼Œè¿™äº›æŒ‡é’ˆå°±ä¼šå¤±æ•ˆã€‚`Pin` ä¿è¯è¢« Pin ä½çš„æ•°æ®ä¸ä¼šè¢«ç§»åŠ¨ã€‚

**Pin ç±»å‹**:

```rust
pub struct Pin<P> {
    pointer: P,
}

impl<P: Deref> Pin<P> {
    // åªæœ‰ P::Target: Unpin æ—¶æ‰èƒ½å®‰å…¨è·å– &mut T
    pub fn get_mut(self) -> &mut P::Target where P::Target: Unpin;
    
    // ä¸å®‰å…¨ï¼šç›´æ¥è·å–å¯å˜å¼•ç”¨
    pub unsafe fn get_unchecked_mut(self) -> &mut P::Target;
}
```

**Unpin Trait**:

```rust
pub auto trait Unpin {}
```

- å¤§å¤šæ•°ç±»å‹è‡ªåŠ¨å®ç° `Unpin`ï¼ˆå¯ä»¥å®‰å…¨ç§»åŠ¨ï¼‰
- ä¸å®ç° `Unpin` çš„ç±»å‹ï¼ˆå¦‚æŸäº› Futureï¼‰ä¸èƒ½å®‰å…¨ç§»åŠ¨

**ä½¿ç”¨åœºæ™¯**:

**1. Future trait ç­¾å**:

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
```

**2. åˆ›å»º Pin**:

```rust
use std::pin::Pin;

let mut value = String::from("hello");
let pinned = Pin::new(&mut value); // String å®ç°äº† Unpin
```

**3. ä¸å®‰å…¨çš„ Pin**:

```rust
use std::pin::Pin;

struct SelfReferential {
    data: String,
    ptr: *const String,
}

// !Unpin: ä¸èƒ½å®‰å…¨ç§»åŠ¨
impl !Unpin for SelfReferential {}

let boxed = Box::new(SelfReferential { ... });
let pinned = unsafe { Pin::new_unchecked(boxed) };
```

**å…³é”®è§„åˆ™**:

- âœ… `Pin<&mut T>` ä¿è¯ `T` ä¸ä¼šè¢«ç§»åŠ¨
- âœ… å¦‚æœ `T: Unpin`ï¼Œå¯ä»¥å®‰å…¨è·å– `&mut T`
- âœ… å¦‚æœ `T: !Unpin`ï¼Œåªèƒ½é€šè¿‡ unsafe è·å– `&mut T`

**ç›¸å…³æœ¯è¯­**: [Future](#1226-future-å’Œ-poll), [å¼‚æ­¥ç¼–ç¨‹](#1225-å¼‚æ­¥ç¼–ç¨‹-asyncawait)

**å‚è€ƒ**: [The Rustonomicon: Pin and Unpin](https://doc.rust-lang.org/nomicon/pin.html)

---

## 1.2.3 æ•°æ®åº“ç”Ÿæ€

### 1.2.3.1 SQL

**å®šä¹‰**: Structured Query Languageï¼ˆç»“æ„åŒ–æŸ¥è¯¢è¯­è¨€ï¼‰ï¼Œç”¨äºç®¡ç†å’Œæ“ä½œå…³ç³»æ•°æ®åº“çš„æ ‡å‡†è¯­è¨€ã€‚

**ç†è®ºåŸºç¡€**:

SQL åŸºäºå…³ç³»ä»£æ•°å’Œå…³ç³»æ¼”ç®—ç†è®ºï¼Œç”± Edgar F. Codd åœ¨ 1970 å¹´ä»£æå‡ºã€‚å®ƒæ˜¯å£°æ˜å¼è¯­è¨€ï¼Œæè¿°"è¦ä»€ä¹ˆ"è€Œé"æ€ä¹ˆåš"ã€‚

**SQL ç±»åˆ«**:

| ç±»åˆ« | å…¨ç§° | ä½œç”¨ | ç¤ºä¾‹ |
|------|------|------|------|
| **DDL** | Data Definition Language | å®šä¹‰æ•°æ®åº“ç»“æ„ | `CREATE TABLE`, `ALTER TABLE` |
| **DML** | Data Manipulation Language | æ“ä½œæ•°æ® | `SELECT`, `INSERT`, `UPDATE`, `DELETE` |
| **DCL** | Data Control Language | æ§åˆ¶è®¿é—®æƒé™ | `GRANT`, `REVOKE` |
| **TCL** | Transaction Control Language | äº‹åŠ¡æ§åˆ¶ | `COMMIT`, `ROLLBACK` |

**Rust SQL é©±åŠ¨**:

| æ•°æ®åº“ | é©±åŠ¨åº“ | ç‰ˆæœ¬ | ç‰¹ç‚¹ | æ–‡æ¡£ |
|--------|--------|------|------|------|
| **PostgreSQL** | `tokio-postgres` | 0.7.12 | çº¯ Rustã€å¼‚æ­¥ | [ğŸ“š](https://docs.rs/tokio-postgres/) |
| **PostgreSQL** | `sqlx` | 0.8.6 | ç¼–è¯‘æ—¶æ£€æŸ¥ã€è·¨æ•°æ®åº“ | [ğŸ“š](https://docs.rs/sqlx/) |
| **MySQL** | `mysql_async` | 0.34.3 | å¼‚æ­¥ã€é«˜æ€§èƒ½ | [ğŸ“š](https://docs.rs/mysql_async/) |
| **SQLite** | `rusqlite` | 0.33.0 | åŒæ­¥ã€åµŒå…¥å¼ | [ğŸ“š](https://docs.rs/rusqlite/) |

**SQL vs NoSQL**:

| ç‰¹æ€§ | SQL | NoSQL |
|------|-----|-------|
| æ•°æ®æ¨¡å‹ | å…³ç³»è¡¨ | æ–‡æ¡£/é”®å€¼/å›¾/åˆ—æ— |
| Schema | å›ºå®š | çµæ´» |
| äº‹åŠ¡ | ACID | BASEï¼ˆé€šå¸¸ï¼‰ |
| æ‰©å±•æ€§ | å‚ç›´ | æ°´å¹³ |
| æŸ¥è¯¢è¯­è¨€ | SQL | å„å¼‚ |
| é€‚ç”¨åœºæ™¯ | å¤æ‚æŸ¥è¯¢ã€äº‹åŠ¡ | é«˜å¹¶å‘ã€å¤§æ•°æ®ã€çµæ´»schema |

**ç›¸å…³æœ¯è¯­**: [ORM](#1232-orm-å¯¹è±¡å…³ç³»æ˜ å°„), [äº‹åŠ¡](#1234-äº‹åŠ¡-transaction), [è¿æ¥æ± ](#1233-è¿æ¥æ± -connection-pool)

**å‚è€ƒ**: [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](guides/2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md)

---

### 1.2.3.2 ORM (å¯¹è±¡å…³ç³»æ˜ å°„)

**å®šä¹‰**: Object-Relational Mappingï¼Œå°†æ•°æ®åº“è¡¨æ˜ å°„ä¸ºå¯¹è±¡ï¼Œé€šè¿‡é¢å‘å¯¹è±¡çš„æ–¹å¼æ“ä½œæ•°æ®åº“ã€‚

**ç†è®ºèƒŒæ™¯**:

ORM è§£å†³äº†"å¯¹è±¡-å…³ç³»é˜»æŠ—ä¸åŒ¹é…"é—®é¢˜ï¼Œå°†å…³ç³»æ•°æ®åº“çš„è¡¨ã€è¡Œã€åˆ—æ˜ å°„ä¸ºé¢å‘å¯¹è±¡çš„ç±»ã€å¯¹è±¡ã€å±æ€§ã€‚

**Rust ORM ç”Ÿæ€**:

| ORM | ç‰ˆæœ¬ | ç±»å‹ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|-----|------|------|------|---------|
| **Diesel** | 2.2.4 | ç¼–è¯‘æ—¶ | ç±»å‹å®‰å…¨ã€é›¶æˆæœ¬ã€åŒæ­¥ | å¤æ‚æŸ¥è¯¢ã€ç±»å‹å®‰å…¨ |
| **SeaORM** | 2.0.0-rc.9 | ç¼–è¯‘æ—¶ | å¼‚æ­¥ã€åŠ¨æ€ã€æ˜“ç”¨ | Web åº”ç”¨ã€ç°ä»£å¼‚æ­¥ |
| **rbatis** | 4.5.30 | è¿è¡Œæ—¶ | åŠ¨æ€SQLã€MyBatisé£æ ¼ | çµæ´»æŸ¥è¯¢ã€åŠ¨æ€æ¡ä»¶ |

**Diesel ç¤ºä¾‹**:

```rust
use diesel::prelude::*;

#[derive(Queryable)]
struct User {
    id: i32,
    name: String,
    email: String,
}

// ç±»å‹å®‰å…¨çš„æŸ¥è¯¢
let users = users::table
    .filter(users::email.like("%@example.com"))
    .select((users::id, users::name, users::email))
    .load::<User>(&mut conn)?;
```

**SeaORM ç¤ºä¾‹**:

```rust
use sea_orm::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub email: String,
}

// å¼‚æ­¥æŸ¥è¯¢
let users: Vec<Model> = Entity::find()
    .filter(Column::Email.contains("example.com"))
    .all(&db)
    .await?;
```

**ORM vs Query Builder vs Raw SQL**:

| ç‰¹æ€§ | ORM | Query Builder | Raw SQL |
|------|-----|---------------|---------|
| ç±»å‹å®‰å…¨ | â­â­â­â­â­ | â­â­â­â­ | â­ |
| çµæ´»æ€§ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| æ€§èƒ½ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| å­¦ä¹ æ›²çº¿ | é™¡å³­ | ä¸­ç­‰ | ç®€å• |
| æ•°æ®åº“è¿ç§» | æ–¹ä¾¿ | ä¸­ç­‰ | å›°éš¾ |

**ä¼˜åŠ¿**:

- âœ… ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶æ£€æŸ¥
- âœ… ä»£ç å¤ç”¨ï¼šé€šç”¨çš„ CRUD æ“ä½œ
- âœ… æ•°æ®åº“æ— å…³ï¼šæ˜“äºåˆ‡æ¢æ•°æ®åº“
- âœ… è¿ç§»ç®¡ç†ï¼šè‡ªåŠ¨ç”Ÿæˆè¿ç§»è„šæœ¬

**åŠ£åŠ¿**:

- âŒ å¤æ‚æŸ¥è¯¢ï¼šæŸäº›å¤æ‚æŸ¥è¯¢éš¾ä»¥è¡¨è¾¾
- âŒ æ€§èƒ½å¼€é”€ï¼šé¢å¤–çš„æŠ½è±¡å±‚
- âŒ å­¦ä¹ æˆæœ¬ï¼šéœ€è¦å­¦ä¹  ORM çš„ API

**ç›¸å…³æœ¯è¯­**: [SQL](#1231-sql), [è¿ç§»](#1235-è¿ç§»-migration)

**å‚è€ƒ**: [essential_crates/03_application_dev/orm/](essential_crates/03_application_dev/orm/)

---

### 1.2.3.3 è¿æ¥æ±  (Connection Pool)

**å®šä¹‰**: é¢„å…ˆåˆ›å»ºå¹¶ç»´æŠ¤ä¸€ç»„æ•°æ®åº“è¿æ¥ï¼Œé€šè¿‡å¤ç”¨è¿æ¥é¿å…é¢‘ç¹å»ºç«‹å’Œé”€æ¯è¿æ¥çš„å¼€é”€ã€‚

**ç†è®ºèƒŒæ™¯**:

æ•°æ®åº“è¿æ¥çš„å»ºç«‹åŒ…æ‹¬ TCP æ¡æ‰‹ã€è®¤è¯ã€åˆå§‹åŒ–ç­‰æ­¥éª¤ï¼Œå¼€é”€è¾ƒå¤§ï¼ˆé€šå¸¸ 10-100msï¼‰ã€‚
è¿æ¥æ± é€šè¿‡å¤ç”¨è¿æ¥ï¼Œå°†å¼€é”€åˆ†æ‘Šåˆ°å¤šæ¬¡è¯·æ±‚ï¼Œæ˜¾è‘—æå‡æ€§èƒ½ã€‚

**å·¥ä½œåŸç†**:

```mermaid
graph TD
    A[åº”ç”¨è¯·æ±‚è¿æ¥] -->|1. è·å–| B[è¿æ¥æ± ]
    B -->|2. ç©ºé—²è¿æ¥| C[è¿”å›è¿æ¥]
    B -->|3. æ— ç©ºé—²| D{è¾¾åˆ°æœ€å¤§å€¼?}
    D -->|å¦| E[åˆ›å»ºæ–°è¿æ¥]
    D -->|æ˜¯| F[ç­‰å¾…/è¶…æ—¶]
    C -->|4. ä½¿ç”¨| G[æ‰§è¡ŒæŸ¥è¯¢]
    E -->|4. ä½¿ç”¨| G
    G -->|5. é‡Šæ”¾| B
```

**æ ¸å¿ƒå‚æ•°**:

| å‚æ•° | è¯´æ˜ | æ¨èå€¼ | å½±å“ |
|------|------|--------|------|
| `min_connections` | æœ€å°è¿æ¥æ•° | 5-10 | å¯åŠ¨æ—¶é¢„çƒ­ |
| `max_connections` | æœ€å¤§è¿æ¥æ•° | 10-50 | CPUæ ¸å¿ƒæ•° * 2-5 |
| `connection_timeout` | è·å–è¿æ¥è¶…æ—¶ | 30s | é˜²æ­¢æ— é™ç­‰å¾… |
| `idle_timeout` | ç©ºé—²è¶…æ—¶ | 10min | é‡Šæ”¾ç©ºé—²è¿æ¥ |
| `max_lifetime` | è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ | 30min | é˜²æ­¢è¿æ¥æ³„æ¼ |

**Rust è¿æ¥æ± å®ç°**:

| åº“ | ç‰ˆæœ¬ | ç±»å‹ | ç‰¹ç‚¹ | æ”¯æŒæ•°æ®åº“ |
|-----|------|------|------|-----------|
| **deadpool** | 0.12.2 | å¼‚æ­¥ | é€šç”¨ã€çµæ´» | PostgreSQL, Redis, SQLite |
| **bb8** | 0.8.5 | å¼‚æ­¥ | ç®€å•ã€é«˜æ€§èƒ½ | PostgreSQL, Redis |
| **r2d2** | 0.8.10 | åŒæ­¥ | æˆç†Ÿã€ç¨³å®š | PostgreSQL, MySQL, SQLite |

**deadpool ç¤ºä¾‹**:

```rust
use deadpool_postgres::{Config, ManagerConfig, Pool, RecyclingMethod, Runtime};
use tokio_postgres::NoTls;

let mut cfg = Config::new();
cfg.host = Some("localhost".to_string());
cfg.dbname = Some("mydb".to_string());
cfg.manager = Some(ManagerConfig {
    recycling_method: RecyclingMethod::Fast,
});
cfg.pool = Some(PoolConfig {
    max_size: 16,
    timeouts: Timeouts {
        wait: Some(Duration::from_secs(30)),
        create: Some(Duration::from_secs(30)),
        recycle: Some(Duration::from_secs(30)),
    },
});

let pool = cfg.create_pool(Some(Runtime::Tokio1), NoTls)?;

// è·å–è¿æ¥
let client = pool.get().await?;
let rows = client.query("SELECT * FROM users", &[]).await?;
```

**è¿æ¥æ± è°ƒä¼˜**:

**1. ç¡®å®šæœ€å¤§è¿æ¥æ•°**:

```text
max_connections = (CPUæ ¸å¿ƒæ•° * 2) + ç£ç›˜æ•°é‡
```

**2. ç›‘æ§æŒ‡æ ‡**:

- ç­‰å¾…æ—¶é—´ï¼ˆwait timeï¼‰
- è¿æ¥ä½¿ç”¨ç‡ï¼ˆconnection utilizationï¼‰
- è¶…æ—¶æ¬¡æ•°ï¼ˆtimeout countï¼‰

**3. å¸¸è§é—®é¢˜**:

- **è¿æ¥æ³„æ¼**: è¿æ¥æœªæ­£ç¡®é‡Šæ”¾ â†’ ä½¿ç”¨ `max_lifetime`
- **è¿æ¥è€—å°½**: `max_connections` å¤ªå° â†’ å¢åŠ è¿æ¥æ•°æˆ–ä¼˜åŒ–æŸ¥è¯¢
- **è¿æ¥è¿‡å¤š**: æ•°æ®åº“å‹åŠ›å¤§ â†’ å‡å°‘ `max_connections`

**ç›¸å…³æœ¯è¯­**: [SQL](#1231-sql), æ€§èƒ½ä¼˜åŒ–

**å‚è€ƒ**: [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](guides/2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md)

---

### 1.2.3.4 äº‹åŠ¡ (Transaction)

**å®šä¹‰**: ä¸€ç»„æ•°æ®åº“æ“ä½œçš„é€»è¾‘å•å…ƒï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§ã€‚

**ACID ç‰¹æ€§**:

| ç‰¹æ€§ | è‹±æ–‡ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|------|
| **åŸå­æ€§** | Atomicity | å…¨éƒ¨æˆåŠŸæˆ–å…¨éƒ¨å¤±è´¥ | è½¬è´¦ï¼šæ‰£æ¬¾å’ŒåŠ æ¬¾å¿…é¡»åŒæ—¶æˆåŠŸ |
| **ä¸€è‡´æ€§** | Consistency | æ•°æ®ä»ä¸€ä¸ªä¸€è‡´çŠ¶æ€åˆ°å¦ä¸€ä¸ªä¸€è‡´çŠ¶æ€ | è½¬è´¦å‰åæ€»é‡‘é¢ä¸å˜ |
| **éš”ç¦»æ€§** | Isolation | å¹¶å‘äº‹åŠ¡äº’ä¸å¹²æ‰° | ä¸¤ä¸ªè½¬è´¦æ“ä½œäº’ä¸å½±å“ |
| **æŒä¹…æ€§** | Durability | æäº¤åæ°¸ä¹…ä¿å­˜ | æ–­ç”µåæ•°æ®ä¸ä¸¢å¤± |

**äº‹åŠ¡éš”ç¦»çº§åˆ«**:

| éš”ç¦»çº§åˆ« | è„è¯» | ä¸å¯é‡å¤è¯» | å¹»è¯» | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|---------|------|-----------|------|------|---------|
| **Read Uncommitted** | âœ… æ˜¯ | âœ… æ˜¯ | âœ… æ˜¯ | â­â­â­â­â­ | æå°‘ä½¿ç”¨ |
| **Read Committed** | âŒ å¦ | âœ… æ˜¯ | âœ… æ˜¯ | â­â­â­â­ | PostgreSQL é»˜è®¤ |
| **Repeatable Read** | âŒ å¦ | âŒ å¦ | âœ… æ˜¯ | â­â­â­ | MySQL é»˜è®¤ |
| **Serializable** | âŒ å¦ | âŒ å¦ | âŒ å¦ | â­â­ | å¼ºä¸€è‡´æ€§è¦æ±‚ |

**Rust äº‹åŠ¡ç¤ºä¾‹**:

**1. æ˜¾å¼äº‹åŠ¡ï¼ˆPostgreSQLï¼‰**:

```rust
use tokio_postgres::Transaction;

let mut client = pool.get().await?;
let transaction = client.transaction().await?;

// æ‰£æ¬¾
transaction.execute(
    "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
    &[&100.0, &1],
).await?;

// åŠ æ¬¾
transaction.execute(
    "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
    &[&100.0, &2],
).await?;

// æäº¤
transaction.commit().await?;
// æˆ–å›æ»š: transaction.rollback().await?;
```

**2. SeaORM äº‹åŠ¡**:

```rust
use sea_orm::*;

let txn = db.begin().await?;

// æ’å…¥ç”¨æˆ·
let user = user::ActiveModel {
    name: Set("Alice".to_string()),
    email: Set("alice@example.com".to_string()),
    ..Default::default()
};
let user = user.insert(&txn).await?;

// æ’å…¥å…³è”æ•°æ®
let profile = profile::ActiveModel {
    user_id: Set(user.id),
    bio: Set("Hello".to_string()),
    ..Default::default()
};
profile.insert(&txn).await?;

txn.commit().await?;
```

**åˆ†å¸ƒå¼äº‹åŠ¡**:

å¯¹äºè·¨æ•°æ®åº“/æœåŠ¡çš„äº‹åŠ¡ï¼Œé€šå¸¸ä½¿ç”¨ï¼š

- **2PC (Two-Phase Commit)**: å¼ºä¸€è‡´æ€§ï¼Œæ€§èƒ½è¾ƒä½
- **Saga**: è¡¥å¿æœºåˆ¶ï¼Œæœ€ç»ˆä¸€è‡´æ€§
- **TCC (Try-Confirm-Cancel)**: é¢„ç•™-ç¡®è®¤-å–æ¶ˆæ¨¡å¼

**ç›¸å…³æœ¯è¯­**: [SQL](#1231-sql), [ORM](#1232-orm-å¯¹è±¡å…³ç³»æ˜ å°„)

**å‚è€ƒ**: [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](guides/2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md)

---

### 1.2.3.5 è¿ç§» (Migration)

**å®šä¹‰**: æ•°æ®åº“ç»“æ„å˜æ›´çš„ç‰ˆæœ¬æ§åˆ¶ï¼Œé€šè¿‡è„šæœ¬ç®¡ç†æ•°æ®åº“schemaçš„æ¼”è¿›ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

1. **Up Migration**: å‰å‘è¿ç§»ï¼Œåº”ç”¨æ–°çš„å˜æ›´
2. **Down Migration**: å›æ»šè¿ç§»ï¼Œæ’¤é”€å˜æ›´
3. **Version**: è¿ç§»ç‰ˆæœ¬å·ï¼Œé€šå¸¸ä½¿ç”¨æ—¶é—´æˆ³
4. **Migration History**: è®°å½•å·²åº”ç”¨çš„è¿ç§»

**Rust è¿ç§»å·¥å…·**:

| å·¥å…· | ORM | å‘½ä»¤ | ç‰¹ç‚¹ |
|------|-----|------|------|
| **diesel_cli** | Diesel | `diesel migration run` | å¼ºç±»å‹ã€è‡ªåŠ¨ç”Ÿæˆ schema |
| **sea-orm-cli** | SeaORM | `sea-orm-cli migrate up` | å¼‚æ­¥ã€çµæ´» |
| **sqlx-cli** | SQLx | `sqlx migrate run` | ç¼–è¯‘æ—¶æ£€æŸ¥ |

**è¿ç§»ç¤ºä¾‹**:

**1. åˆ›å»ºè¿ç§»ï¼ˆDieselï¼‰**:

```bash
diesel migration generate create_users
```

ç”Ÿæˆæ–‡ä»¶:

```sql
-- up.sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

```sql
-- down.sql
DROP INDEX IF EXISTS idx_users_email;
DROP TABLE IF EXISTS users;
```

**2. åº”ç”¨è¿ç§»**:

```bash
diesel migration run
```

**3. å›æ»šè¿ç§»**:

```bash
diesel migration revert
```

**æœ€ä½³å®è·µ**:

1. âœ… **å‘åå…¼å®¹**: å…ˆåŠ å­—æ®µï¼Œååˆ å­—æ®µ
2. âœ… **å°æ­¥è¿­ä»£**: æ¯æ¬¡è¿ç§»åªåšä¸€ä»¶äº‹
3. âœ… **å¹‚ç­‰æ€§**: è¿ç§»å¯ä»¥é‡å¤è¿è¡Œ
4. âœ… **æ•°æ®è¿ç§»**: å…ˆè¿ç§» schemaï¼Œå†è¿ç§»æ•°æ®
5. âœ… **ç‰ˆæœ¬æ§åˆ¶**: è¿ç§»è„šæœ¬çº³å…¥ Git
6. âœ… **æµ‹è¯•è¿ç§»**: åœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯

**ç›¸å…³æœ¯è¯­**: [SQL](#1231-sql), [ORM](#1232-orm-å¯¹è±¡å…³ç³»æ˜ å°„)

---

### 1.2.3.6 é¢„ç¼–è¯‘è¯­å¥ (Prepared Statement)

**å®šä¹‰**: é¢„å…ˆç¼–è¯‘çš„ SQL è¯­å¥æ¨¡æ¿ï¼Œå¯ä»¥å¤šæ¬¡æ‰§è¡Œï¼Œæé«˜æ€§èƒ½å¹¶é˜²æ­¢ SQL æ³¨å…¥ã€‚

**å·¥ä½œåŸç†**:

```mermaid
graph LR
    A[SQLæ¨¡æ¿] -->|1. Prepare| B[è§£æå’Œç¼–è¯‘]
    B -->|2. ç¼“å­˜| C[æ‰§è¡Œè®¡åˆ’]
    D[å‚æ•°1] -->|3. Bind| E[æ‰§è¡Œ]
    F[å‚æ•°2] -->|3. Bind| E
    C -->|4. æ‰§è¡Œ| E
    E -->|5. è¿”å›| G[ç»“æœ]
```

**ç¤ºä¾‹**:

```rust
// æ™®é€šæŸ¥è¯¢ï¼ˆä¸æ¨èï¼‰
let sql = format!("SELECT * FROM users WHERE id = {}", user_id); // SQLæ³¨å…¥é£é™©!
let rows = client.query(&sql, &[]).await?;

// é¢„ç¼–è¯‘è¯­å¥ï¼ˆæ¨èï¼‰
let stmt = client.prepare("SELECT * FROM users WHERE id = $1").await?;
let rows = client.query(&stmt, &[&user_id]).await?;
```

**ä¼˜åŠ¿**:

1. âœ… **æ€§èƒ½**: é¿å…é‡å¤è§£æå’Œç¼–è¯‘
2. âœ… **å®‰å…¨**: é˜²æ­¢ SQL æ³¨å…¥
3. âœ… **ç±»å‹å®‰å…¨**: å‚æ•°ç±»å‹æ£€æŸ¥
4. âœ… **ç¼“å­˜**: æ•°æ®åº“ç¼“å­˜æ‰§è¡Œè®¡åˆ’

**æ€§èƒ½å¯¹æ¯”**:

| æŸ¥è¯¢æ–¹å¼ | 1æ¬¡æŸ¥è¯¢ | 100æ¬¡æŸ¥è¯¢ | 1000æ¬¡æŸ¥è¯¢ |
|---------|--------|----------|-----------|
| æ™®é€šæŸ¥è¯¢ | 1x | 100x | 1000x |
| é¢„ç¼–è¯‘è¯­å¥ | 1.2x (é¦–æ¬¡) | 120x | 1200x |
| **æ€§èƒ½æå‡** | -20% | +17% | +20% |

**ç›¸å…³æœ¯è¯­**: [SQL](#1231-sql), [è¿æ¥æ± ](#1233-è¿æ¥æ± -connection-pool)

---

## 1.2.4 ç¼“å­˜ç³»ç»Ÿ

### 1.2.4.1 Redis

**å®šä¹‰**: Remote Dictionary Serverï¼Œå¼€æºçš„å†…å­˜æ•°æ®ç»“æ„å­˜å‚¨ç³»ç»Ÿï¼Œå¯ç”¨ä½œæ•°æ®åº“ã€ç¼“å­˜å’Œæ¶ˆæ¯ä»£ç†ã€‚

**æ ¸å¿ƒç‰¹æ€§**:

1. **å†…å­˜å­˜å‚¨**: æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨å†…å­˜ï¼Œè¯»å†™æ€§èƒ½æé«˜
2. **æŒä¹…åŒ–**: æ”¯æŒ RDB å’Œ AOF ä¸¤ç§æŒä¹…åŒ–æ–¹å¼
3. **æ•°æ®ç»“æ„**: ä¸°å¯Œçš„æ•°æ®ç»“æ„æ”¯æŒ
4. **å•çº¿ç¨‹æ¨¡å‹**: ç®€åŒ–å¹¶å‘æ§åˆ¶ï¼Œé¿å…é”ç«äº‰
5. **åŸå­æ“ä½œ**: æ‰€æœ‰æ“ä½œéƒ½æ˜¯åŸå­çš„

**æ•°æ®ç»“æ„**:

| ç±»å‹ | è¯´æ˜ | æ—¶é—´å¤æ‚åº¦ | åº”ç”¨åœºæ™¯ | ç¤ºä¾‹å‘½ä»¤ |
|------|------|-----------|---------|---------|
| **String** | å­—ç¬¦ä¸²/äºŒè¿›åˆ¶ | O(1) | ç¼“å­˜ã€è®¡æ•°å™¨ | `SET`, `GET`, `INCR` |
| **Hash** | å“ˆå¸Œè¡¨ | O(1) | å¯¹è±¡å­˜å‚¨ | `HSET`, `HGET`, `HGETALL` |
| **List** | åŒå‘é“¾è¡¨ | O(1) | é˜Ÿåˆ—ã€æ ˆ | `LPUSH`, `RPUSH`, `LPOP` |
| **Set** | æ— åºé›†åˆ | O(1) | æ ‡ç­¾ã€å»é‡ | `SADD`, `SMEMBERS`, `SINTER` |
| **Sorted Set** | æœ‰åºé›†åˆ | O(log N) | æ’è¡Œæ¦œ | `ZADD`, `ZRANGE`, `ZRANK` |
| **Stream** | æ—¥å¿—æµ | O(1) | æ¶ˆæ¯é˜Ÿåˆ— | `XADD`, `XREAD`, `XRANGE` |

**Rust é©±åŠ¨**:

```rust
use redis::{Client, Commands, AsyncCommands};

// åŒæ­¥å®¢æˆ·ç«¯
let client = Client::open("redis://127.0.0.1:6379")?;
let mut conn = client.get_connection()?;
conn.set("key", "value")?;
let value: String = conn.get("key")?;

// å¼‚æ­¥å®¢æˆ·ç«¯
let client = Client::open("redis://127.0.0.1:6379")?;
let mut conn = client.get_multiplexed_async_connection().await?;
conn.set("key", "value").await?;
let value: String = conn.get("key").await?;
```

**é«˜çº§ç‰¹æ€§**:

1. **äº‹åŠ¡**: `MULTI` + `EXEC`
2. **Lua è„šæœ¬**: åŸå­å¤åˆæ“ä½œ
3. **å‘å¸ƒ/è®¢é˜…**: å®æ—¶æ¶ˆæ¯
4. **ç®¡é“**: æ‰¹é‡æ“ä½œ
5. **é›†ç¾¤**: æ°´å¹³æ‰©å±•

**ç›¸å…³æœ¯è¯­**: [Pipeline](#1242-pipeline), [Pub/Sub](#1243-pubsub-å‘å¸ƒè®¢é˜…), [åˆ†å¸ƒå¼é”](#1244-åˆ†å¸ƒå¼é”-distributed-lock)

**å‚è€ƒ**: [2.2 ç¼“å­˜ç³»ç»ŸæŒ‡å—](guides/2.2_ç¼“å­˜ç³»ç»ŸæŒ‡å—.md)

---

### 1.2.4.2 Pipeline

**å®šä¹‰**: Redis æ‰¹é‡æ“ä½œæ¨¡å¼ï¼Œä¸€æ¬¡æ€§å‘é€å¤šä¸ªå‘½ä»¤ï¼Œå‡å°‘ç½‘ç»œå¾€è¿”æ¬¡æ•°ï¼ˆRTTï¼‰ã€‚

**å·¥ä½œåŸç†**:

**æ™®é€šæ¨¡å¼**:

```text
Client -> Server: GET key1
Server -> Client: value1  (RTT 1)
Client -> Server: GET key2
Server -> Client: value2  (RTT 2)
Client -> Server: GET key3
Server -> Client: value3  (RTT 3)
Total: 3 RTT
```

**Pipeline æ¨¡å¼**:

```text
Client -> Server: GET key1 + GET key2 + GET key3
Server -> Client: value1 + value2 + value3  (RTT 1)
Total: 1 RTT
```

**æ€§èƒ½æå‡**:

| å‘½ä»¤æ•° | æ™®é€šæ¨¡å¼ | Pipeline | æå‡å€æ•° |
|--------|---------|----------|---------|
| 10 | 10 RTT | 1 RTT | 10x |
| 100 | 100 RTT | 1 RTT | 100x |
| 1000 | 1000 RTT | 1 RTT | 1000x |

**Rust ç¤ºä¾‹**:

```rust
use redis::pipe;

let client = redis::Client::open("redis://127.0.0.1")?;
let mut conn = client.get_multiplexed_async_connection().await?;

// åˆ›å»º pipeline
let mut pipe = pipe();
pipe.set("key1", "value1")
    .ignore() // å¿½ç•¥è¿”å›å€¼
    .set("key2", "value2")
    .ignore()
    .get("key1")
    .get("key2");

// æ‰§è¡Œ pipeline
let (v1, v2): (String, String) = pipe.query_async(&mut conn).await?;
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… æ‰¹é‡è¯»å–
- âœ… æ‰¹é‡å†™å…¥
- âœ… åŸå­æ€§è¦æ±‚ä¸é«˜çš„åœºæ™¯
- âŒ ä¸é€‚åˆæœ‰ä¾èµ–å…³ç³»çš„æ“ä½œ

**æ³¨æ„äº‹é¡¹**:

1. Pipeline ä¸ä¿è¯åŸå­æ€§ï¼ˆä¸åŒäºäº‹åŠ¡ï¼‰
2. æœåŠ¡ç«¯ä¼šç¼“å­˜æ‰€æœ‰å“åº”ï¼Œå†…å­˜å ç”¨å¢åŠ 
3. å•ä¸ª Pipeline ä¸å®œè¶…è¿‡ 1000 ä¸ªå‘½ä»¤

**ç›¸å…³æœ¯è¯­**: [Redis](#1241-redis)

---

### 1.2.4.3 Pub/Sub (å‘å¸ƒ/è®¢é˜…)

**å®šä¹‰**: æ¶ˆæ¯å‘å¸ƒ/è®¢é˜…æ¨¡å¼ï¼Œç”Ÿäº§è€…å‘å¸ƒæ¶ˆæ¯åˆ°é¢‘é“ï¼Œè®¢é˜…è€…æ¥æ”¶æ¶ˆæ¯ã€‚

**æ¨¡å‹**:

```mermaid
graph LR
    P1[Publisher 1] -->|PUBLISH| C[Channel: news]
    P2[Publisher 2] -->|PUBLISH| C
    C -->|æ¶ˆæ¯| S1[Subscriber 1]
    C -->|æ¶ˆæ¯| S2[Subscriber 2]
    C -->|æ¶ˆæ¯| S3[Subscriber 3]
```

**æ ¸å¿ƒå‘½ä»¤**:

| å‘½ä»¤ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| `PUBLISH` | å‘å¸ƒæ¶ˆæ¯ | `PUBLISH news "Breaking news!"` |
| `SUBSCRIBE` | è®¢é˜…é¢‘é“ | `SUBSCRIBE news sports` |
| `UNSUBSCRIBE` | å–æ¶ˆè®¢é˜… | `UNSUBSCRIBE news` |
| `PSUBSCRIBE` | æ¨¡å¼è®¢é˜… | `PSUBSCRIBE news.*` |

**Rust ç¤ºä¾‹**:

```rust
use redis::AsyncCommands;

// å‘å¸ƒè€…
let client = redis::Client::open("redis://127.0.0.1")?;
let mut conn = client.get_multiplexed_async_connection().await?;
conn.publish("news", "Breaking news!").await?;

// è®¢é˜…è€…
let client = redis::Client::open("redis://127.0.0.1")?;
let mut conn = client.get_async_connection().await?;
let mut pubsub = conn.into_pubsub();
pubsub.subscribe("news").await?;

let mut stream = pubsub.on_message();
while let Some(msg) = stream.next().await {
    let payload: String = msg.get_payload()?;
    println!("Received: {}", payload);
}
```

**ç‰¹ç‚¹**:

- âœ… å®æ—¶æ€§ï¼šæ¶ˆæ¯å³æ—¶æ¨é€
- âœ… è§£è€¦ï¼šå‘å¸ƒè€…å’Œè®¢é˜…è€…äº’ä¸æ„ŸçŸ¥
- âœ… å¤šå¯¹å¤šï¼šä¸€ä¸ªé¢‘é“å¯æœ‰å¤šä¸ªå‘å¸ƒè€…å’Œè®¢é˜…è€…
- âŒ ä¸æŒä¹…ï¼šæ¶ˆæ¯ä¸ä¿å­˜ï¼Œè®¢é˜…è€…ç¦»çº¿ä¼šä¸¢å¤±æ¶ˆæ¯
- âŒ æ— ç¡®è®¤ï¼šå‘å¸ƒè€…ä¸çŸ¥é“æœ‰å¤šå°‘è®¢é˜…è€…æ”¶åˆ°æ¶ˆæ¯

**é€‚ç”¨åœºæ™¯**:

- å®æ—¶é€šçŸ¥ï¼ˆå¦‚èŠå¤©å®¤ï¼‰
- å®æ—¶æ•°æ®æ¨é€ï¼ˆå¦‚è‚¡ç¥¨è¡Œæƒ…ï¼‰
- äº‹ä»¶å¹¿æ’­ï¼ˆå¦‚ç¼“å­˜å¤±æ•ˆé€šçŸ¥ï¼‰

**å¯¹æ¯” Stream**:

| ç‰¹æ€§ | Pub/Sub | Stream |
|------|---------|--------|
| æŒä¹…åŒ– | âŒ å¦ | âœ… æ˜¯ |
| å†å²æ¶ˆæ¯ | âŒ å¦ | âœ… æ˜¯ |
| æ¶ˆè´¹ç»„ | âŒ å¦ | âœ… æ˜¯ |
| å®æ—¶æ€§ | â­â­â­â­â­ | â­â­â­â­ |
| é€‚ç”¨åœºæ™¯ | å®æ—¶å¹¿æ’­ | æ¶ˆæ¯é˜Ÿåˆ— |

**ç›¸å…³æœ¯è¯­**: [Redis](#1241-redis)

---

### 1.2.4.4 åˆ†å¸ƒå¼é” (Distributed Lock)

**å®šä¹‰**: åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å®ç°äº’æ–¥è®¿é—®å…±äº«èµ„æºçš„æœºåˆ¶ã€‚

**ç†è®ºèƒŒæ™¯**:

åˆ†å¸ƒå¼é”éœ€è¦æ»¡è¶³ï¼š

1. **äº’æ–¥æ€§**: åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªå®¢æˆ·ç«¯æŒæœ‰é”
2. **é˜²æ­»é”**: é”å¿…é¡»èƒ½è¢«é‡Šæ”¾ï¼ˆè¶…æ—¶æœºåˆ¶ï¼‰
3. **å®¹é”™æ€§**: éƒ¨åˆ†èŠ‚ç‚¹æ•…éšœä¸å½±å“é”æœåŠ¡
4. **å¯é‡å…¥æ€§**: åŒä¸€å®¢æˆ·ç«¯å¯å¤šæ¬¡è·å–é”

**Redis å®ç°ï¼ˆSET NX EXï¼‰**:

```rust
use redis::AsyncCommands;

// è·å–é”
let lock_key = "resource:lock";
let lock_value = uuid::Uuid::new_v4().to_string();
let timeout_secs = 10;

let result: bool = conn
    .set_options(
        lock_key,
        &lock_value,
        redis::SetOptions::default()
            .with_expiration(redis::SetExpiry::EX(timeout_secs))
            .conditional_set(redis::ExistenceCheck::NX),
    )
    .await?;

if result {
    // è·å–é”æˆåŠŸ
    // ... æ‰§è¡Œä¸šåŠ¡é€»è¾‘ ...
    
    // é‡Šæ”¾é”ï¼ˆLua è„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
    let script = r#"
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
    "#;
    redis::Script::new(script)
        .key(lock_key)
        .arg(&lock_value)
        .invoke_async(&mut conn)
        .await?;
} else {
    // è·å–é”å¤±è´¥
}
```

**Redlock ç®—æ³•**:

ç”¨äº Redis é›†ç¾¤çš„åˆ†å¸ƒå¼é”ç®—æ³•ï¼ˆç”± Redis ä½œè€… Antirez æå‡ºï¼‰ï¼š

1. è·å–å½“å‰æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
2. å°è¯•ä» N ä¸ªç‹¬ç«‹çš„ Redis å®ä¾‹è·å–é”
3. è®¡ç®—è·å–é”çš„æ€»è€—æ—¶
4. å¦‚æœåœ¨è¶…è¿‡åŠæ•°ï¼ˆN/2 + 1ï¼‰çš„å®ä¾‹ä¸ŠæˆåŠŸè·å–é”ï¼Œä¸”æ€»è€—æ—¶å°äºé”çš„æœ‰æ•ˆæ—¶é—´ï¼Œåˆ™è®¤ä¸ºè·å–é”æˆåŠŸ
5. å¦åˆ™ï¼Œé‡Šæ”¾æ‰€æœ‰å·²è·å–çš„é”

**ä½¿ç”¨åœºæ™¯**:

- å®šæ—¶ä»»åŠ¡ï¼ˆé˜²æ­¢é‡å¤æ‰§è¡Œï¼‰
- åº“å­˜æ‰£å‡ï¼ˆé˜²æ­¢è¶…å–ï¼‰
- åˆ†å¸ƒå¼ ID ç”Ÿæˆ
- é…ç½®æ›´æ–°ï¼ˆé˜²æ­¢å¹¶å‘å†²çªï¼‰

**æ³¨æ„äº‹é¡¹**:

1. âš ï¸ é”è¶…æ—¶æ—¶é—´è¦å¤§äºä¸šåŠ¡æ‰§è¡Œæ—¶é—´
2. âš ï¸ ä½¿ç”¨å”¯ä¸€æ ‡è¯†ï¼ˆå¦‚ UUIDï¼‰é˜²æ­¢è¯¯åˆ é”
3. âš ï¸ é‡Šæ”¾é”è¦ä½¿ç”¨ Lua è„šæœ¬ä¿è¯åŸå­æ€§
4. âš ï¸ è€ƒè™‘ä½¿ç”¨ä¸“ä¸šçš„åˆ†å¸ƒå¼é”æœåŠ¡ï¼ˆå¦‚ etcdã€ZooKeeperï¼‰

**ç›¸å…³æœ¯è¯­**: [Redis](#1241-redis)

**å‚è€ƒ**: [essential_crates/cross_cutting/security/](essential_crates/cross_cutting/security/)

---

### 1.2.4.5 TTL (è¿‡æœŸæ—¶é—´)

**å®šä¹‰**: Time To Liveï¼Œé”®çš„å­˜æ´»æ—¶é—´ï¼Œåˆ°æœŸåè‡ªåŠ¨åˆ é™¤ã€‚

**å‘½ä»¤**:

| å‘½ä»¤ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| `EXPIRE` | è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ | `EXPIRE key 60` |
| `PEXPIRE` | è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ | `PEXPIRE key 60000` |
| `EXPIREAT` | è®¾ç½®è¿‡æœŸæ—¶é—´æˆ³ï¼ˆç§’ï¼‰ | `EXPIREAT key 1699999999` |
| `TTL` | æŸ¥çœ‹å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰ | `TTL key` |
| `PERSIST` | ç§»é™¤è¿‡æœŸæ—¶é—´ | `PERSIST key` |

**Rust ç¤ºä¾‹**:

```rust
use redis::AsyncCommands;

// è®¾ç½®é”®å€¼å¹¶æŒ‡å®šè¿‡æœŸæ—¶é—´
conn.set_ex("session:user:123", "user_data", 3600).await?;

// æˆ–è€…åˆ†ä¸¤æ­¥
conn.set("cache:result", "data").await?;
conn.expire("cache:result", 300).await?;

// æŸ¥çœ‹å‰©ä½™æ—¶é—´
let ttl: i64 = conn.ttl("cache:result").await?;
println!("TTL: {} seconds", ttl);
```

**è¿‡æœŸç­–ç•¥**:

Redis ä½¿ç”¨**æƒ°æ€§åˆ é™¤** + **å®šæœŸåˆ é™¤**ï¼š

1. **æƒ°æ€§åˆ é™¤**: è®¿é—®é”®æ—¶æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
2. **å®šæœŸåˆ é™¤**: æ¯ç§’æ‰«æéƒ¨åˆ†é”®ï¼Œåˆ é™¤è¿‡æœŸé”®

**åº”ç”¨åœºæ™¯**:

- ä¼šè¯ç®¡ç†ï¼ˆSessionï¼‰
- éªŒè¯ç è¿‡æœŸ
- ä¸´æ—¶ç¼“å­˜
- é™æµè®¡æ•°å™¨

**ç›¸å…³æœ¯è¯­**: [Redis](#1241-redis)

---

### 1.2.4.6 ç¼“å­˜ç©¿é€ã€å‡»ç©¿ã€é›ªå´©

**å®šä¹‰**: ç¼“å­˜ç³»ç»Ÿå¸¸è§çš„ä¸‰ç§æ•…éšœåœºæ™¯ã€‚

**1. ç¼“å­˜ç©¿é€ (Cache Penetration)**:

**å®šä¹‰**: æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®ï¼Œå¯¼è‡´æ¯æ¬¡éƒ½æŸ¥è¯¢æ•°æ®åº“ã€‚

**åŸå› **: ç¼“å­˜å’Œæ•°æ®åº“éƒ½æ²¡æœ‰æ•°æ®

**è§£å†³æ–¹æ¡ˆ**:

```rust
// 1. ç¼“å­˜ç©ºå€¼
async fn get_user(id: i32) -> Result<Option<User>> {
    // å…ˆæŸ¥ç¼“å­˜
    if let Some(cached) = cache.get(&format!("user:{}", id)).await? {
        if cached == "NULL" {
            return Ok(None); // ç¼“å­˜çš„ç©ºå€¼
        }
        return Ok(Some(serde_json::from_str(&cached)?));
    }
    
    // æŸ¥æ•°æ®åº“
    let user = db.get_user(id).await?;
    
    if let Some(ref u) = user {
        cache.set_ex(&format!("user:{}", id), serde_json::to_string(u)?, 3600).await?;
    } else {
        // ç¼“å­˜ç©ºå€¼ï¼Œè®¾ç½®è¾ƒçŸ­è¿‡æœŸæ—¶é—´
        cache.set_ex(&format!("user:{}", id), "NULL", 60).await?;
    }
    
    Ok(user)
}

// 2. å¸ƒéš†è¿‡æ»¤å™¨
use probabilistic_collections::bloom::BloomFilter;

let mut bloom = BloomFilter::new(1000000, 0.01);
// åˆå§‹åŒ–æ—¶åŠ è½½æ‰€æœ‰ID
for id in all_ids {
    bloom.insert(&id);
}

// æŸ¥è¯¢æ—¶å…ˆæ£€æŸ¥å¸ƒéš†è¿‡æ»¤å™¨
if !bloom.contains(&id) {
    return Ok(None); // ä¸€å®šä¸å­˜åœ¨
}
```

**2. ç¼“å­˜å‡»ç©¿ (Cache Breakdown)**:

**å®šä¹‰**: çƒ­ç‚¹é”®è¿‡æœŸï¼Œå¯¼è‡´å¤§é‡è¯·æ±‚åŒæ—¶æŸ¥è¯¢æ•°æ®åº“ã€‚

**åŸå› **: çƒ­ç‚¹æ•°æ®è¿‡æœŸ + é«˜å¹¶å‘

**è§£å†³æ–¹æ¡ˆ**:

```rust
use tokio::sync::Mutex;
use std::collections::HashMap;

// ä½¿ç”¨äº’æ–¥é”é˜²æ­¢å¹¶å‘æŸ¥è¯¢
lazy_static! {
    static ref QUERY_LOCKS: Mutex<HashMap<String, Arc<Mutex<()>>>> = Mutex::new(HashMap::new());
}

async fn get_hot_data(key: &str) -> Result<String> {
    // å…ˆæŸ¥ç¼“å­˜
    if let Some(data) = cache.get(key).await? {
        return Ok(data);
    }
    
    // è·å–æˆ–åˆ›å»ºé”
    let lock = {
        let mut locks = QUERY_LOCKS.lock().await;
        locks.entry(key.to_string())
            .or_insert_with(|| Arc::new(Mutex::new(())))
            .clone()
    };
    
    // åŠ é”
    let _guard = lock.lock().await;
    
    // åŒé‡æ£€æŸ¥
    if let Some(data) = cache.get(key).await? {
        return Ok(data);
    }
    
    // æŸ¥è¯¢æ•°æ®åº“
    let data = db.query(key).await?;
    
    // å†™å…¥ç¼“å­˜ï¼ˆè®¾ç½®æ°¸ä¸è¿‡æœŸæˆ–å¾ˆé•¿çš„è¿‡æœŸæ—¶é—´ï¼‰
    cache.set(key, &data).await?;
    
    Ok(data)
}
```

**3. ç¼“å­˜é›ªå´© (Cache Avalanche)**:

**å®šä¹‰**: å¤§é‡ç¼“å­˜åŒæ—¶è¿‡æœŸï¼Œå¯¼è‡´æ•°æ®åº“å‹åŠ›æ¿€å¢ã€‚

**åŸå› **: å¤§é‡é”®åŒæ—¶è¿‡æœŸ + ç¼“å­˜æœåŠ¡å®•æœº

**è§£å†³æ–¹æ¡ˆ**:

```rust
use rand::Rng;

// 1. è¿‡æœŸæ—¶é—´åŠ éšæœºå€¼
let base_ttl = 3600;
let random_offset = rand::thread_rng().gen_range(0..300);
let ttl = base_ttl + random_offset;
cache.set_ex(key, value, ttl).await?;

// 2. ä½¿ç”¨ Redis é›†ç¾¤
// 3. å®ç°å¤šçº§ç¼“å­˜
struct MultiLevelCache {
    l1: LocalCache,  // è¿›ç¨‹å†…ç¼“å­˜
    l2: RedisCache,  // Redis ç¼“å­˜
}

impl MultiLevelCache {
    async fn get(&self, key: &str) -> Result<Option<String>> {
        // å…ˆæŸ¥ L1
        if let Some(value) = self.l1.get(key) {
            return Ok(Some(value));
        }
        
        // å†æŸ¥ L2
        if let Some(value) = self.l2.get(key).await? {
            self.l1.set(key, &value, Duration::from_secs(60));
            return Ok(Some(value));
        }
        
        Ok(None)
    }
}

// 4. é™æµå’Œç†”æ–­
use governor::{Quota, RateLimiter};

let limiter = RateLimiter::direct(Quota::per_second(nonzero!(100u32)));

if limiter.check().is_ok() {
    // å…è®¸æŸ¥è¯¢æ•°æ®åº“
} else {
    // è§¦å‘é™æµï¼Œè¿”å›é™çº§æ•°æ®
}
```

**å¯¹æ¯”æ€»ç»“**:

| é—®é¢˜ | åŸå›  | å½±å“ | è§£å†³æ–¹æ¡ˆ |
|------|------|------|---------|
| **ç©¿é€** | æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ® | æ•°æ®åº“å‹åŠ› | ç¼“å­˜ç©ºå€¼ã€å¸ƒéš†è¿‡æ»¤å™¨ |
| **å‡»ç©¿** | çƒ­ç‚¹é”®è¿‡æœŸ | ç¬æ—¶æ•°æ®åº“å‹åŠ› | äº’æ–¥é”ã€æ°¸ä¸è¿‡æœŸ |
| **é›ªå´©** | å¤§é‡é”®åŒæ—¶è¿‡æœŸ | æŒç»­æ•°æ®åº“å‹åŠ› | éšæœºè¿‡æœŸã€å¤šçº§ç¼“å­˜ã€é™æµ |

**ç›¸å…³æœ¯è¯­**: [Redis](#1241-redis), [TTL](#1245-ttl-è¿‡æœŸæ—¶é—´)

**å‚è€ƒ**: [2.2 ç¼“å­˜ç³»ç»ŸæŒ‡å—](guides/2.2_ç¼“å­˜ç³»ç»ŸæŒ‡å—.md)

---

## 1.2.5 æ¶ˆæ¯é˜Ÿåˆ—

### 1.2.5.1 Kafka

**å®šä¹‰**: é«˜ååé‡çš„åˆ†å¸ƒå¼æµå¤„ç†å¹³å°ï¼Œå¹¿æ³›åº”ç”¨äºæ—¥å¿—æ”¶é›†ã€æµå¤„ç†ã€äº‹ä»¶æº¯æºç­‰åœºæ™¯ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

| æ¦‚å¿µ | è¯´æ˜ | ç±»æ¯” |
|------|------|------|
| **Topic** | æ¶ˆæ¯ä¸»é¢˜/åˆ†ç±» | æ•°æ®åº“çš„è¡¨ |
| **Partition** | Topic çš„åˆ†åŒº | è¡¨çš„åˆ†ç‰‡ |
| **Producer** | æ¶ˆæ¯ç”Ÿäº§è€… | å†™å…¥è€… |
| **Consumer** | æ¶ˆæ¯æ¶ˆè´¹è€… | è¯»å–è€… |
| **Consumer Group** | æ¶ˆè´¹è€…ç»„ | è´Ÿè½½å‡è¡¡å•å…ƒ |
| **Broker** | Kafka æœåŠ¡å™¨èŠ‚ç‚¹ | é›†ç¾¤èŠ‚ç‚¹ |
| **Offset** | æ¶ˆæ¯åç§»é‡ | æ¶ˆæ¯ID |

**æ¶æ„å›¾**:

```mermaid
graph TD
    P1[Producer 1] -->|å†™å…¥| T1[Topic: orders]
    P2[Producer 2] -->|å†™å…¥| T1
    T1 -->|Partition 0| B1[Broker 1]
    T1 -->|Partition 1| B2[Broker 2]
    T1 -->|Partition 2| B3[Broker 3]
    B1 -->|è¯»å–| CG1[Consumer Group 1]
    B2 -->|è¯»å–| CG1
    B3 -->|è¯»å–| CG1
    CG1 --> C1[Consumer 1]
    CG1 --> C2[Consumer 2]
```

**Rust é©±åŠ¨ï¼ˆrdkafkaï¼‰**:

```rust
use rdkafka::config::ClientConfig;
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::consumer::{Consumer, StreamConsumer};
use rdkafka::message::{BorrowedMessage, Message};

// ç”Ÿäº§è€…
let producer: FutureProducer = ClientConfig::new()
    .set("bootstrap.servers", "localhost:9092")
    .set("message.timeout.ms", "5000")
    .create()?;

let payload = "Hello Kafka!";
producer
    .send(
        FutureRecord::to("my-topic")
            .payload(payload)
            .key("key-1"),
        Duration::from_secs(0),
    )
    .await?;

// æ¶ˆè´¹è€…
let consumer: StreamConsumer = ClientConfig::new()
    .set("group.id", "my-consumer-group")
    .set("bootstrap.servers", "localhost:9092")
    .set("enable.auto.commit", "true")
    .set("auto.offset.reset", "earliest")
    .create()?;

consumer.subscribe(&["my-topic"])?;

let mut stream = consumer.stream();
while let Some(message) = stream.next().await {
    match message {
        Ok(msg) => {
            let payload = msg.payload().unwrap();
            let text = std::str::from_utf8(payload)?;
            println!("Received: {}", text);
        }
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

**æ ¸å¿ƒç‰¹æ€§**:

1. **é«˜åå**: ç™¾ä¸‡çº§ TPS
2. **æŒä¹…åŒ–**: æ¶ˆæ¯å­˜å‚¨åœ¨ç£ç›˜
3. **åˆ†åŒº**: æ°´å¹³æ‰©å±•
4. **æ¶ˆè´¹è€…ç»„**: è´Ÿè½½å‡è¡¡
5. **å‰¯æœ¬**: é«˜å¯ç”¨
6. **é¡ºåºæ€§**: å•åˆ†åŒºå†…æœ‰åº

**é€‚ç”¨åœºæ™¯**:

- æ—¥å¿—æ”¶é›†å’Œèšåˆ
- å®æ—¶æ•°æ®ç®¡é“
- äº‹ä»¶æº¯æºï¼ˆEvent Sourcingï¼‰
- æµå¤„ç†ï¼ˆKafka Streamsï¼‰

**ç›¸å…³æœ¯è¯­**: [æ¶ˆæ¯è¯­ä¹‰](#1255-æ¶ˆæ¯è¯­ä¹‰-delivery-semantics)

**å‚è€ƒ**: [2.3 æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—](guides/2.3_æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—.md)

---

### 1.2.5.2 MQTT

**å®šä¹‰**: Message Queuing Telemetry Transportï¼Œè½»é‡çº§çš„å‘å¸ƒ/è®¢é˜…æ¶ˆæ¯åè®®ï¼Œä¸“ä¸ºèµ„æºå—é™çš„è®¾å¤‡å’Œä½å¸¦å®½ã€é«˜å»¶è¿Ÿç½‘ç»œè®¾è®¡ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

| æ¦‚å¿µ | è¯´æ˜ |
|------|------|
| **Broker** | MQTT æœåŠ¡å™¨ï¼ˆå¦‚ Mosquitto, EMQXï¼‰ |
| **Client** | MQTT å®¢æˆ·ç«¯ï¼ˆå‘å¸ƒè€…æˆ–è®¢é˜…è€…ï¼‰ |
| **Topic** | ä¸»é¢˜ï¼Œä½¿ç”¨å±‚çº§ç»“æ„ï¼ˆå¦‚ `home/living_room/temperature`ï¼‰ |
| **QoS** | æœåŠ¡è´¨é‡ç­‰çº§ï¼ˆ0, 1, 2ï¼‰ |
| **Retained Message** | ä¿ç•™æ¶ˆæ¯ï¼Œæ–°è®¢é˜…è€…ç«‹å³æ”¶åˆ° |
| **Will Message** | é—å˜±æ¶ˆæ¯ï¼Œå®¢æˆ·ç«¯å¼‚å¸¸æ–­å¼€æ—¶å‘é€ |

**QoS ç­‰çº§**:

| QoS | åç§° | ä¿è¯ | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|-----|------|------|------|---------|
| **0** | At most once | è‡³å¤šä¸€æ¬¡ | â­â­â­â­â­ | ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆå…è®¸ä¸¢å¤±ï¼‰ |
| **1** | At least once | è‡³å°‘ä¸€æ¬¡ | â­â­â­â­ | é€šçŸ¥æ¶ˆæ¯ï¼ˆå¯é‡å¤ï¼‰ |
| **2** | Exactly once | æ°å¥½ä¸€æ¬¡ | â­â­â­ | é‡‘èäº¤æ˜“ï¼ˆä¸å¯é‡å¤ï¼‰ |

**Rust é©±åŠ¨ï¼ˆrumqttcï¼‰**:

```rust
use rumqttc::{AsyncClient, MqttOptions, QoS};
use tokio::time::Duration;

// åˆ›å»ºå®¢æˆ·ç«¯
let mut mqttoptions = MqttOptions::new("test-client", "localhost", 1883);
mqttoptions.set_keep_alive(Duration::from_secs(60));

let (client, mut eventloop) = AsyncClient::new(mqttoptions, 10);

// è®¢é˜…ä¸»é¢˜
client.subscribe("home/+/temperature", QoS::AtMostOnce).await?;

// å‘å¸ƒæ¶ˆæ¯
client
    .publish(
        "home/living_room/temperature",
        QoS::AtLeastOnce,
        false,
        "22.5",
    )
    .await?;

// å¤„ç†æ¶ˆæ¯
while let Ok(notification) = eventloop.poll().await {
    println!("Received = {:?}", notification);
}
```

**ä¸»é¢˜é€šé…ç¬¦**:

- `+`: å•å±‚é€šé…ç¬¦ï¼ˆå¦‚ `home/+/temperature` åŒ¹é… `home/living_room/temperature`ï¼‰
- `#`: å¤šå±‚é€šé…ç¬¦ï¼ˆå¦‚ `home/#` åŒ¹é… `home/living_room/temperature`ï¼‰

**é€‚ç”¨åœºæ™¯**:

- IoT è®¾å¤‡é€šä¿¡
- ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†
- æ™ºèƒ½å®¶å±…
- è½¦è”ç½‘

**å¯¹æ¯” AMQP**:

| ç‰¹æ€§ | MQTT | AMQP |
|------|------|------|
| è®¾è®¡ç›®æ ‡ | IoTã€ä½åŠŸè€— | ä¼ä¸šæ¶ˆæ¯ |
| åè®®å¤æ‚åº¦ | ç®€å• | å¤æ‚ |
| æ¶ˆæ¯æ¨¡å‹ | å‘å¸ƒ/è®¢é˜… | å¤šç§æ¨¡å¼ |
| æ€§èƒ½ | æ›´è½»é‡ | åŠŸèƒ½æ›´ä¸°å¯Œ |

**ç›¸å…³æœ¯è¯­**: [NATS](#1253-nats), [Pub/Sub](#1243-pubsub-å‘å¸ƒè®¢é˜…)

**å‚è€ƒ**: [2.3 æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—](guides/2.3_æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—.md), [essential_crates/04_domain_specific/iot/](essential_crates/04_domain_specific/iot/)

---

### 1.2.5.3 NATS

**å®šä¹‰**: é«˜æ€§èƒ½ã€äº‘åŸç”Ÿçš„æ¶ˆæ¯ç³»ç»Ÿï¼Œä»¥ç®€å•ã€å®‰å…¨ã€é«˜æ€§èƒ½è‘—ç§°ã€‚

**æ ¸å¿ƒç‰¹æ€§**:

1. **ç®€å•**: æ–‡æœ¬åè®®ï¼Œæ˜“äºå®ç°å®¢æˆ·ç«¯
2. **é«˜æ€§èƒ½**: ç™¾ä¸‡çº§ TPSï¼Œå¾®ç§’çº§å»¶è¿Ÿ
3. **è½»é‡**: å•ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä½èµ„æºå ç”¨
4. **äº‘åŸç”Ÿ**: æ”¯æŒ K8sã€æœåŠ¡ç½‘æ ¼

**æ¶ˆæ¯æ¨¡å¼**:

| æ¨¡å¼ | è¯´æ˜ | ç”¨é€” |
|------|------|------|
| **Publish-Subscribe** | å‘å¸ƒ/è®¢é˜… | å¹¿æ’­æ¶ˆæ¯ |
| **Request-Reply** | è¯·æ±‚/å“åº” | RPC è°ƒç”¨ |
| **Queue Groups** | é˜Ÿåˆ—è®¢é˜… | è´Ÿè½½å‡è¡¡ |

**JetStream**:

NATS 2.0+ å¼•å…¥çš„æŒä¹…åŒ–å±‚ï¼Œæä¾›ï¼š

- âœ… æ¶ˆæ¯æŒä¹…åŒ–
- âœ… è‡³å°‘ä¸€æ¬¡/æ°å¥½ä¸€æ¬¡è¯­ä¹‰
- âœ… æ¶ˆæ¯é‡æ”¾
- âœ… æ¶ˆè´¹è€…ç¡®è®¤

**Rust é©±åŠ¨ï¼ˆasync-natsï¼‰**:

```rust
use async_nats;

// è¿æ¥
let client = async_nats::connect("nats://localhost:4222").await?;

// å‘å¸ƒ
client.publish("greet.joe", "hello".into()).await?;

// è®¢é˜…
let mut subscriber = client.subscribe("greet.*").await?;
while let Some(message) = subscriber.next().await {
    println!("Received: {:?}", String::from_utf8(message.payload.to_vec())?);
}

// è¯·æ±‚/å“åº”
let response = client.request("greet.joe", "hello".into()).await?;
println!("Response: {:?}", String::from_utf8(response.payload.to_vec())?);
```

**JetStream ç¤ºä¾‹**:

```rust
let jetstream = async_nats::jetstream::new(client);

// åˆ›å»º Stream
jetstream
    .create_stream(stream::Config {
        name: "my_stream".to_string(),
        subjects: vec!["events.>".to_string()],
        ..Default::default()
    })
    .await?;

// å‘å¸ƒæ¶ˆæ¯
let ack = jetstream.publish("events.user.created", "data".into()).await?;

// åˆ›å»º Consumer
let consumer = jetstream
    .create_consumer_on_stream(
        consumer::Config {
            durable_name: Some("my_consumer".to_string()),
            ..Default::default()
        },
        "my_stream",
    )
    .await?;
```

**é€‚ç”¨åœºæ™¯**:

- å¾®æœåŠ¡é€šä¿¡
- è¯·æ±‚/å“åº”ï¼ˆRPCï¼‰
- äº‹ä»¶é©±åŠ¨æ¶æ„
- å®æ—¶æ•°æ®æµ

**å¯¹æ¯”**:

| ç‰¹æ€§ | NATS | Kafka | RabbitMQ |
|------|------|-------|----------|
| æ€§èƒ½ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| æŒä¹…åŒ– | JetStream | âœ… | âœ… |
| å¤æ‚åº¦ | ç®€å• | å¤æ‚ | ä¸­ç­‰ |
| é€‚ç”¨åœºæ™¯ | å¾®æœåŠ¡ | å¤§æ•°æ® | ä¼ä¸šé›†æˆ |

**ç›¸å…³æœ¯è¯­**: [Kafka](#1251-kafka), [MQTT](#1252-mqtt)

**å‚è€ƒ**: [2.3 æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—](guides/2.3_æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—.md)

---

### 1.2.5.4 RabbitMQ

**å®šä¹‰**: åŸºäº AMQP åè®®çš„ä¼ä¸šçº§æ¶ˆæ¯é˜Ÿåˆ—ï¼ŒåŠŸèƒ½ä¸°å¯Œã€å¯é æ€§é«˜ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

| æ¦‚å¿µ | è¯´æ˜ |
|------|------|
| **Exchange** | æ¶ˆæ¯äº¤æ¢æœºï¼Œæ¥æ”¶å¹¶è·¯ç”±æ¶ˆæ¯ |
| **Queue** | æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå­˜å‚¨æ¶ˆæ¯ |
| **Binding** | Exchange å’Œ Queue ä¹‹é—´çš„ç»‘å®šå…³ç³» |
| **Routing Key** | è·¯ç”±é”®ï¼Œç”¨äºæ¶ˆæ¯è·¯ç”± |
| **Virtual Host** | è™šæ‹Ÿä¸»æœºï¼Œéš”ç¦»ä¸åŒåº”ç”¨ |

**Exchange ç±»å‹**:

| ç±»å‹ | è¯´æ˜ | è·¯ç”±è§„åˆ™ | é€‚ç”¨åœºæ™¯ |
|------|------|---------|---------|
| **Direct** | ç›´æ¥äº¤æ¢ | å®Œå…¨åŒ¹é… routing key | ç‚¹å¯¹ç‚¹ |
| **Fanout** | æ‰‡å‡ºäº¤æ¢ | å¿½ç•¥ routing keyï¼Œå¹¿æ’­ | å¹¿æ’­ |
| **Topic** | ä¸»é¢˜äº¤æ¢ | æ¨¡å¼åŒ¹é…ï¼ˆ`*`, `#`ï¼‰ | å¤æ‚è·¯ç”± |
| **Headers** | å¤´éƒ¨äº¤æ¢ | åŒ¹é…æ¶ˆæ¯å¤´ | å±æ€§è·¯ç”± |

**Rust é©±åŠ¨ï¼ˆlapinï¼‰**:

```rust
use lapin::{
    options::*, types::FieldTable, BasicProperties, Connection,
    ConnectionProperties,
};

// è¿æ¥
let conn = Connection::connect(
    "amqp://localhost:5672",
    ConnectionProperties::default(),
).await?;

let channel = conn.create_channel().await?;

// å£°æ˜ Exchange
channel.exchange_declare(
    "my_exchange",
    ExchangeKind::Direct,
    ExchangeDeclareOptions::default(),
    FieldTable::default(),
).await?;

// å£°æ˜ Queue
channel.queue_declare(
    "my_queue",
    QueueDeclareOptions::default(),
    FieldTable::default(),
).await?;

// ç»‘å®š
channel.queue_bind(
    "my_queue",
    "my_exchange",
    "routing_key",
    QueueBindOptions::default(),
    FieldTable::default(),
).await?;

// å‘å¸ƒæ¶ˆæ¯
channel.basic_publish(
    "my_exchange",
    "routing_key",
    BasicPublishOptions::default(),
    b"Hello RabbitMQ",
    BasicProperties::default(),
).await?;

// æ¶ˆè´¹æ¶ˆæ¯
let consumer = channel.basic_consume(
    "my_queue",
    "my_consumer",
    BasicConsumeOptions::default(),
    FieldTable::default(),
).await?;
```

**é€‚ç”¨åœºæ™¯**:

- ä¼ä¸šåº”ç”¨é›†æˆ
- å¤æ‚è·¯ç”±åœºæ™¯
- å¯é æ¶ˆæ¯ä¼ é€’
- å»¶è¿Ÿé˜Ÿåˆ—

**ç›¸å…³æœ¯è¯­**: [Kafka](#1251-kafka), [NATS](#1253-nats), [æ¶ˆæ¯è¯­ä¹‰](#1255-æ¶ˆæ¯è¯­ä¹‰-delivery-semantics)

**å‚è€ƒ**: [2.3 æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—](guides/2.3_æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—.md)

---

### 1.2.5.5 æ¶ˆæ¯è¯­ä¹‰ (Delivery Semantics)

**å®šä¹‰**: æ¶ˆæ¯ä¼ é€’çš„å¯é æ€§ä¿è¯çº§åˆ«ã€‚

**ä¸‰ç§è¯­ä¹‰**:

| è¯­ä¹‰ | è¯´æ˜ | å®ç°æ–¹å¼ | ä¼˜ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|---------|--------|---------|
| **At-most-once** | è‡³å¤šä¸€æ¬¡ | å‘é€åä¸ç®¡ç»“æœ | âœ… æ€§èƒ½é«˜ âŒ å¯èƒ½ä¸¢å¤± | æ—¥å¿—ã€ç›‘æ§æ•°æ® |
| **At-least-once** | è‡³å°‘ä¸€æ¬¡ | ç¡®è®¤é‡ä¼ æœºåˆ¶ | âœ… ä¸ä¸¢å¤± âŒ å¯èƒ½é‡å¤ | è®¢å•é€šçŸ¥ã€é‚®ä»¶ |
| **Exactly-once** | æ°å¥½ä¸€æ¬¡ | å¹‚ç­‰æ€§ + äº‹åŠ¡ | âœ… ä¸ä¸¢å¤±ä¸é‡å¤ âŒ æ€§èƒ½ä½ | é‡‘èäº¤æ˜“ã€æ”¯ä»˜ |

**Kafka å®ç°**:

```rust
// At-least-onceï¼ˆé»˜è®¤ï¼‰
let producer: FutureProducer = ClientConfig::new()
    .set("enable.idempotence", "false") // å…³é—­å¹‚ç­‰æ€§
    .create()?;

// Exactly-once
let producer: FutureProducer = ClientConfig::new()
    .set("enable.idempotence", "true")  // å¹‚ç­‰æ€§ç”Ÿäº§è€…
    .set("transactional.id", "my-tx-id") // äº‹åŠ¡ID
    .create()?;

// å¼€å¯äº‹åŠ¡
producer.init_transactions(Duration::from_secs(30)).await?;
producer.begin_transaction().await?;

// å‘é€æ¶ˆæ¯
producer.send(...).await?;

// æäº¤äº‹åŠ¡
producer.commit_transaction(Duration::from_secs(30)).await?;
```

**å¹‚ç­‰æ€§è®¾è®¡**:

```rust
// ä½¿ç”¨å”¯ä¸€IDå®ç°å¹‚ç­‰æ€§
#[derive(Serialize, Deserialize)]
struct Message {
    id: Uuid,
    data: String,
}

async fn process_message(msg: Message, db: &Database) -> Result<()> {
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    if db.is_processed(&msg.id).await? {
        return Ok(()); // å·²å¤„ç†ï¼Œç›´æ¥è¿”å›
    }
    
    // å¼€å¯äº‹åŠ¡
    let tx = db.begin().await?;
    
    // å¤„ç†ä¸šåŠ¡é€»è¾‘
    process_business_logic(&msg).await?;
    
    // æ ‡è®°å·²å¤„ç†
    db.mark_processed(&msg.id, &tx).await?;
    
    tx.commit().await?;
    Ok(())
}
```

**ç›¸å…³æœ¯è¯­**: [Kafka](#1251-kafka), [äº‹åŠ¡](#1234-äº‹åŠ¡-transaction)

---

### 1.2.5.6 æ­»ä¿¡é˜Ÿåˆ— (Dead Letter Queue)

**å®šä¹‰**: ç”¨äºå­˜å‚¨æ— æ³•æ­£å¸¸å¤„ç†çš„æ¶ˆæ¯çš„ç‰¹æ®Šé˜Ÿåˆ—ã€‚

**è§¦å‘æ¡ä»¶**:

1. æ¶ˆæ¯è¢«æ‹’ç»ï¼ˆreject/nackï¼‰ä¸”ä¸é‡æ–°å…¥é˜Ÿ
2. æ¶ˆæ¯ TTL è¿‡æœŸ
3. é˜Ÿåˆ—è¾¾åˆ°æœ€å¤§é•¿åº¦

**RabbitMQ å®ç°**:

```rust
use lapin::types::FieldTable;

// å£°æ˜æ­»ä¿¡é˜Ÿåˆ—
channel.queue_declare(
    "dead_letter_queue",
    QueueDeclareOptions::default(),
    FieldTable::default(),
).await?;

// å£°æ˜æ™®é€šé˜Ÿåˆ—ï¼Œé…ç½®æ­»ä¿¡
let mut args = FieldTable::default();
args.insert("x-dead-letter-exchange".into(), "dlx_exchange".into());
args.insert("x-dead-letter-routing-key".into(), "dlx_key".into());

channel.queue_declare(
    "my_queue",
    QueueDeclareOptions::default(),
    args,
).await?;
```

**å¤„ç†ç­–ç•¥**:

1. **é‡è¯•**: ä»æ­»ä¿¡é˜Ÿåˆ—å–å‡ºæ¶ˆæ¯ï¼Œé‡æ–°å¤„ç†
2. **å‘Šè­¦**: ç›‘æ§æ­»ä¿¡é˜Ÿåˆ—ï¼Œè§¦å‘å‘Šè­¦
3. **äººå·¥ä»‹å…¥**: ä¸¥é‡é”™è¯¯éœ€è¦äººå·¥å¤„ç†
4. **ä¸¢å¼ƒ**: æ— ä»·å€¼æ¶ˆæ¯ç›´æ¥ä¸¢å¼ƒ

**ç›¸å…³æœ¯è¯­**: [RabbitMQ](#1254-rabbitmq), [TTL](#1245-ttl-è¿‡æœŸæ—¶é—´)

---

## 1.2.6 Web æ¡†æ¶

### 1.2.6.1 Axum

**å®šä¹‰**: åŸºäº Tower å’Œ Hyper çš„ Web æ¡†æ¶ï¼Œä»¥ç±»å‹å®‰å…¨å’Œå¯ç»„åˆæ€§è‘—ç§°ã€‚

**æ ¸å¿ƒç‰¹æ€§**:

- âœ… Tower ä¸­é—´ä»¶ç”Ÿæ€
- âœ… æå–å™¨ï¼ˆExtractorï¼‰ç³»ç»Ÿ
- âœ… ç±»å‹å®‰å…¨çš„è·¯ç”±
- âœ… WebSocket æ”¯æŒ
- âœ… å¼‚æ­¥ä¼˜å…ˆ

**Rust ç¤ºä¾‹**:

```rust
use axum::{
    extract::{Path, Query, State},
    response::Json,
    routing::{get, post},
    Router,
};

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(root))
        .route("/users/:id", get(get_user))
        .route("/users", post(create_user));

    axum::Server::bind(&"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn root() -> &'static str {
    "Hello, World!"
}

async fn get_user(Path(id): Path<u32>) -> Json<User> {
    // ...
}
```

**ç›¸å…³æœ¯è¯­**: [Tower](#1262-tower), [ä¸­é—´ä»¶](#1263-ä¸­é—´ä»¶-middleware), [è·¯ç”±](#1264-è·¯ç”±-routing)

**å‚è€ƒ**: [2.4 Webæ¡†æ¶æŒ‡å—](guides/2.4_Webæ¡†æ¶æŒ‡å—.md)

---

### 1.2.6.2 Tower

**å®šä¹‰**: Rust çš„æ¨¡å—åŒ–ç½‘ç»œç»„ä»¶åº“ï¼Œæä¾›å¯ç»„åˆçš„ä¸­é—´ä»¶æŠ½è±¡ã€‚

**æ ¸å¿ƒ Trait**:

```rust
pub trait Service<Request> {
    type Response;
    type Error;
    type Future: Future<Output = Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
    fn call(&mut self, req: Request) -> Self::Future;
}
```

**Tower Layer**:

```rust
pub trait Layer<S> {
    type Service;
    fn layer(&self, inner: S) -> Self::Service;
}
```

**å¸¸ç”¨ä¸­é—´ä»¶**:

| ä¸­é—´ä»¶ | åŠŸèƒ½ | ä½¿ç”¨åœºæ™¯ |
|--------|------|---------|
| `tower::timeout` | è¶…æ—¶æ§åˆ¶ | é˜²æ­¢è¯·æ±‚hangä½ |
| `tower::limit` | å¹¶å‘é™åˆ¶ | é™æµ |
| `tower::load_shed` | è¿‡è½½ä¿æŠ¤ | é«˜è´Ÿè½½æ—¶æ‹’ç»è¯·æ±‚ |
| `tower::retry` | é‡è¯•æœºåˆ¶ | æå‡å¯é æ€§ |
| `tower::buffer` | ç¼“å†² | å¹³æ»‘è¯·æ±‚å³°å€¼ |

**ç›¸å…³æœ¯è¯­**: [Axum](#1261-axum), [ä¸­é—´ä»¶](#1263-ä¸­é—´ä»¶-middleware)

---

### 1.2.6.3 ä¸­é—´ä»¶ (Middleware)

**å®šä¹‰**: ä½äºè¯·æ±‚å’Œå“åº”å¤„ç†æµç¨‹ä¸­çš„å¯æ’æ‹”ç»„ä»¶ï¼Œç”¨äºæ¨ªåˆ‡å…³æ³¨ç‚¹ã€‚

**å¸¸è§ç”¨é€”**:

- æ—¥å¿—è®°å½•
- è®¤è¯æˆæƒ
- å‹ç¼©
- CORS
- é™æµ

**Axum ä¸­é—´ä»¶ç¤ºä¾‹**:

```rust
use axum::{
    middleware::{self, Next},
    response::Response,
    http::Request,
};

async fn my_middleware<B>(
    req: Request<B>,
    next: Next<B>,
) -> Response {
    println!("Request: {} {}", req.method(), req.uri());
    
    let response = next.run(req).await;
    
    println!("Response: {}", response.status());
    response
}

let app = Router::new()
    .route("/", get(handler))
    .layer(middleware::from_fn(my_middleware));
```

**ç›¸å…³æœ¯è¯­**: [Axum](#1261-axum), [Tower](#1262-tower)

---

### 1.2.6.4 è·¯ç”± (Routing)

**å®šä¹‰**: å°† HTTP è¯·æ±‚æ˜ å°„åˆ°å¤„ç†å‡½æ•°çš„æœºåˆ¶ã€‚

**è·¯ç”±ç±»å‹**:

- **é™æ€è·¯ç”±**: `/users`
- **åŠ¨æ€è·¯ç”±**: `/users/:id`
- **é€šé…ç¬¦è·¯ç”±**: `/static/*path`
- **æ­£åˆ™è·¯ç”±**: `/api/v[0-9]+/users`

**Axum è·¯ç”±ç¤ºä¾‹**:

```rust
let app = Router::new()
    .route("/", get(index))
    .route("/users", get(list_users).post(create_user))
    .route("/users/:id", get(get_user).put(update_user).delete(delete_user))
    .nest("/api/v1", api_v1_routes());
```

**ç›¸å…³æœ¯è¯­**: [Axum](#1261-axum)

---

### 1.2.6.5 æå–å™¨ (Extractor)

**å®šä¹‰**: Axum ä¸­ä»è¯·æ±‚ä¸­æå–æ•°æ®çš„æœºåˆ¶ã€‚

**å¸¸ç”¨æå–å™¨**:

| æå–å™¨ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|------|------|
| `Path` | è·¯å¾„å‚æ•° | `/users/:id` â†’ `Path<u32>` |
| `Query` | æŸ¥è¯¢å‚æ•° | `?page=1&size=10` â†’ `Query<Params>` |
| `Json` | JSON è¯·æ±‚ä½“ | `Json<User>` |
| `State` | åº”ç”¨çŠ¶æ€ | `State<AppState>` |
| `Extension` | æ‰©å±•æ•°æ® | `Extension<Database>` |
| `Header` | HTTP å¤´ | `TypedHeader<Authorization>` |

**ç¤ºä¾‹**:

```rust
async fn handler(
    Path(id): Path<u32>,
    Query(params): Query<Params>,
    Json(payload): Json<User>,
    State(db): State<Database>,
) -> Result<Json<Response>> {
    // ...
}
```

**ç›¸å…³æœ¯è¯­**: [Axum](#1261-axum)

---

## 1.2.7 å¼‚æ­¥è¿è¡Œæ—¶

### 1.2.7.1 Tokio

**å®šä¹‰**: Rust æœ€æµè¡Œçš„å¼‚æ­¥è¿è¡Œæ—¶ï¼Œæä¾›äº‹ä»¶é©±åŠ¨çš„éé˜»å¡ I/O å¹³å°ã€‚

**æ ¸å¿ƒç»„ä»¶**:

| ç»„ä»¶ | è¯´æ˜ | åŠŸèƒ½ |
|------|------|------|
| **Runtime** | è¿è¡Œæ—¶ | æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ |
| **Executor** | æ‰§è¡Œå™¨ | è°ƒåº¦å’Œæ‰§è¡Œ Future |
| **Reactor** | ååº”å™¨ | å¤„ç† I/O äº‹ä»¶ |
| **Timer** | å®šæ—¶å™¨ | è¶…æ—¶å’Œå»¶è¿Ÿ |
| **Channels** | é€šé“ | å¼‚æ­¥é€šä¿¡ |

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use tokio;

#[tokio::main]
async fn main() {
    tokio::spawn(async {
        println!("Hello from a task!");
    });

    tokio::time::sleep(Duration::from_secs(1)).await;
}
```

**ç›¸å…³æœ¯è¯­**: [å·¥ä½œçªƒå–è°ƒåº¦å™¨](#1272-å·¥ä½œçªƒå–è°ƒåº¦å™¨-work-stealing-scheduler), [Reactor](#1273-reactor-å’Œ-executor)

**å‚è€ƒ**: [2.5 å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—](guides/2.5_å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—.md)

---

### 1.2.7.2 å·¥ä½œçªƒå–è°ƒåº¦å™¨ (Work-Stealing Scheduler)

**å®šä¹‰**: Tokio ä½¿ç”¨çš„å¤šçº¿ç¨‹è°ƒåº¦ç­–ç•¥ï¼Œçº¿ç¨‹å¯ä»¥"çªƒå–"å…¶ä»–çº¿ç¨‹é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚

**å·¥ä½œåŸç†**:

```mermaid
graph LR
    T1[Thread 1 Queue: [T1, T2]] -->|çªƒå–| T2[Thread 2 Queue: []]
    T2 -->|æ‰§è¡Œ| T3[Task T1]
```

**ä¼˜åŠ¿**:

- âœ… è´Ÿè½½å‡è¡¡
- âœ… é¿å…çº¿ç¨‹ç©ºé—²
- âœ… æå‡ååé‡

**ç›¸å…³æœ¯è¯­**: [Tokio](#1271-tokio)

---

### 1.2.7.3 Reactor å’Œ Executor

**å®šä¹‰**: å¼‚æ­¥è¿è¡Œæ—¶çš„ä¸¤ä¸ªæ ¸å¿ƒç»„ä»¶ã€‚

**Reactor (ååº”å™¨)**:

- ç›‘å¬ I/O äº‹ä»¶ï¼ˆepoll/kqueue/IOCPï¼‰
- äº‹ä»¶å°±ç»ªæ—¶å”¤é†’å¯¹åº”çš„ Future

**Executor (æ‰§è¡Œå™¨)**:

- è°ƒåº¦å’Œæ‰§è¡Œ Future
- å®ç°å·¥ä½œçªƒå–ç®—æ³•

**å…³ç³»**:

```mermaid
graph TD
    A[Future] -->|poll| B[Executor]
    B -->|Ready| C[è¿”å›ç»“æœ]
    B -->|Pending| D[Reactor]
    D -->|I/Oå°±ç»ª| E[å”¤é†’]
    E -->|poll again| B
```

**ç›¸å…³æœ¯è¯­**: [Tokio](#1271-tokio), [Future](#1226-future-å’Œ-poll)

---

### 1.2.7.4 å¼‚æ­¥é€šé“ (Async Channel)

**å®šä¹‰**: ç”¨äºå¼‚æ­¥ä»»åŠ¡é—´é€šä¿¡çš„é€šé“ã€‚

**Tokio é€šé“ç±»å‹**:

| ç±»å‹ | è¯´æ˜ | å®¹é‡ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| `mpsc` | å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€… | æœ‰ç•Œ/æ— ç•Œ | ä»»åŠ¡é€šä¿¡ |
| `oneshot` | å•æ¬¡é€šä¿¡ | 1 | Future ç»“æœä¼ é€’ |
| `broadcast` | å¹¿æ’­ | æœ‰ç•Œ | äº‹ä»¶é€šçŸ¥ |
| `watch` | çŠ¶æ€ç›‘å¬ | 1ï¼ˆæœ€æ–°å€¼ï¼‰ | é…ç½®æ›´æ–° |

**ç¤ºä¾‹**:

```rust
use tokio::sync::mpsc;

let (tx, mut rx) = mpsc::channel(100);

tokio::spawn(async move {
    tx.send("hello").await.unwrap();
});

while let Some(msg) = rx.recv().await {
    println!("Received: {}", msg);
}
```

**ç›¸å…³æœ¯è¯­**: [Tokio](#1271-tokio)

---

## 1.2.8 å‚è€ƒèµ„æº

**å†…éƒ¨æ–‡æ¡£**:

- [1.0 é¡¹ç›®æ¦‚è§ˆ](1.0_é¡¹ç›®æ¦‚è§ˆ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)
- [1.3 å¸¸è§é—®é¢˜](1.3_å¸¸è§é—®é¢˜.md)
- [2.x æŒ‡å—ç³»åˆ—](guides/)
- [3.x å‚è€ƒç³»åˆ—](references/)

**å¤–éƒ¨èµ„æº**:

- [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [Rust Reference](https://doc.rust-lang.org/reference/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
- [Async Book](https://rust-lang.github.io/async-book/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.1  
**æœ€åæ›´æ–°**: 2025-10-21  
**Rust ç‰ˆæœ¬**: 1.90  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å­¦ä¹ ç¤¾åŒº

---

**âœ… æœ¬æœ¯è¯­è¡¨åŒ…å« 50+ æ ¸å¿ƒæœ¯è¯­çš„æ·±åº¦è§£æ**:

æ¯ä¸ªæœ¯è¯­éƒ½åŒ…å«ï¼š

- âœ… å®Œæ•´çš„æ¦‚å¿µå®šä¹‰
- âœ… ç†è®ºèƒŒæ™¯å’ŒåŸç†
- âœ… Rust ä»£ç ç¤ºä¾‹ï¼ˆ40+ ä»£ç å—ï¼‰
- âœ… å®æˆ˜åº”ç”¨åœºæ™¯
- âœ… å…³è”æœ¯è¯­é“¾æ¥
- âœ… å‚è€ƒæ–‡æ¡£æŒ‡å¼•

**è¦†ç›–é¢†åŸŸ**:

- ğŸ”§ è¯­è¨€ç‰¹æ€§ï¼šasync/await, GAT, RPITIT, Pin, Const Generics
- ğŸ’¾ æ•°æ®åº“ï¼šSQL, ORM, è¿æ¥æ± , äº‹åŠ¡, è¿ç§», é¢„ç¼–è¯‘è¯­å¥
- âš¡ ç¼“å­˜ï¼šRedis, Pipeline, Pub/Sub, åˆ†å¸ƒå¼é”, TTL, ç¼“å­˜ä¸‰é«˜
- ğŸ“¨ æ¶ˆæ¯é˜Ÿåˆ—ï¼šKafka, MQTT, NATS, RabbitMQ, æ¶ˆæ¯è¯­ä¹‰, æ­»ä¿¡é˜Ÿåˆ—
- ğŸŒ Webæ¡†æ¶ï¼šAxum, Tower, ä¸­é—´ä»¶, è·¯ç”±, æå–å™¨
- ğŸ”„ å¼‚æ­¥è¿è¡Œæ—¶ï¼šTokio, Future, Reactor, Executor, å·¥ä½œçªƒå–è°ƒåº¦å™¨
