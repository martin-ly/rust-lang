# 4.1 Rust è¿›é˜¶ä¸»é¢˜é›† (2025-10-21)

> **æ–‡æ¡£å®šä½**: Rust é«˜çº§ç‰¹æ€§æ·±åº¦è§£æä¸å®æˆ˜åº”ç”¨  
> **é€‚ç”¨äººç¾¤**: æœ‰ Rust åŸºç¡€çš„å¼€å‘è€…ã€è¿½æ±‚æ·±åº¦ç†è§£çš„å·¥ç¨‹å¸ˆ  
> **å…³è”æ–‡æ¡£**: [3.5 æ¶æ„æ¨¡å¼](../references/3.5_æ¶æ„è®¾è®¡æ¨¡å¼é›†.md) | [3.4 æ€§èƒ½æŠ¥å‘Š](../references/3.4_æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š.md) | [1.1 ä¸»ç´¢å¼•](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æœ€åæ›´æ–°**: 2025-10-21  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [4.1 Rust è¿›é˜¶ä¸»é¢˜é›† (2025-10-21)](#41-rust-è¿›é˜¶ä¸»é¢˜é›†-2025-10-21)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [4.1.1 é«˜çº§ç±»å‹ç³»ç»Ÿ](#411-é«˜çº§ç±»å‹ç³»ç»Ÿ)
    - [4.1.1.1 æ³›å‹å…³è”ç±»å‹ (GAT)](#4111-æ³›å‹å…³è”ç±»å‹-gat)
    - [4.1.1.2 é«˜é˜¶traitè¾¹ç•Œ (HRTB)](#4112-é«˜é˜¶traitè¾¹ç•Œ-hrtb)
    - [4.1.1.3 ç±»å‹çº§ç¼–ç¨‹](#4113-ç±»å‹çº§ç¼–ç¨‹)
    - [4.1.1.4 å¹»åƒç±»å‹ (PhantomData)](#4114-å¹»åƒç±»å‹-phantomdata)
  - [4.1.2 å¼‚æ­¥ç¼–ç¨‹æ·±å…¥](#412-å¼‚æ­¥ç¼–ç¨‹æ·±å…¥)
    - [4.1.2.1 async trait å®æˆ˜](#4121-async-trait-å®æˆ˜)
    - [4.1.2.2 Future åº•å±‚æœºåˆ¶](#4122-future-åº•å±‚æœºåˆ¶)
    - [4.1.2.3 Pin å’Œ Unpin](#4123-pin-å’Œ-unpin)
    - [4.1.2.4 è‡ªå®šä¹‰å¼‚æ­¥è¿è¡Œæ—¶](#4124-è‡ªå®šä¹‰å¼‚æ­¥è¿è¡Œæ—¶)
  - [4.1.3 é›¶æˆæœ¬æŠ½è±¡å®æˆ˜](#413-é›¶æˆæœ¬æŠ½è±¡å®æˆ˜)
    - [4.1.3.1 è¿­ä»£å™¨ä¼˜åŒ–](#4131-è¿­ä»£å™¨ä¼˜åŒ–)
    - [4.1.3.2 å†…è”å’Œå•æ€åŒ–](#4132-å†…è”å’Œå•æ€åŒ–)
    - [4.1.3.3 ç¼–è¯‘æ—¶è®¡ç®— (const fn)](#4133-ç¼–è¯‘æ—¶è®¡ç®—-const-fn)
    - [4.1.3.4 è¿‡ç¨‹å®æ€§èƒ½ä¼˜åŒ–](#4134-è¿‡ç¨‹å®æ€§èƒ½ä¼˜åŒ–)
  - [4.1.4 å†…å­˜ç®¡ç†é«˜çº§æŠ€å·§](#414-å†…å­˜ç®¡ç†é«˜çº§æŠ€å·§)
    - [4.1.4.1 è‡ªå®šä¹‰åˆ†é…å™¨](#4141-è‡ªå®šä¹‰åˆ†é…å™¨)
    - [4.1.4.2 å†…å­˜æ± è®¾è®¡](#4142-å†…å­˜æ± è®¾è®¡)
    - [4.1.4.3 arena åˆ†é…å™¨](#4143-arena-åˆ†é…å™¨)
    - [4.1.4.4 å†…å­˜å¯¹é½å’Œå¸ƒå±€](#4144-å†…å­˜å¯¹é½å’Œå¸ƒå±€)
  - [4.1.5 å¹¶å‘åŸè¯­æ·±å…¥](#415-å¹¶å‘åŸè¯­æ·±å…¥)
    - [4.1.5.1 åŸå­æ“ä½œå’Œå†…å­˜é¡ºåº](#4151-åŸå­æ“ä½œå’Œå†…å­˜é¡ºåº)
    - [4.1.5.2 æ— é”æ•°æ®ç»“æ„å®ç°](#4152-æ— é”æ•°æ®ç»“æ„å®ç°)
    - [4.1.5.3 RwLock vs Mutex æ€§èƒ½åˆ†æ](#4153-rwlock-vs-mutex-æ€§èƒ½åˆ†æ)
    - [4.1.5.4 çº¿ç¨‹æœ¬åœ°å­˜å‚¨ (TLS)](#4154-çº¿ç¨‹æœ¬åœ°å­˜å‚¨-tls)
  - [4.1.6 ç¼–è¯‘å™¨å†…éƒ¨æœºåˆ¶](#416-ç¼–è¯‘å™¨å†…éƒ¨æœºåˆ¶)
    - [4.1.6.1 MIR (ä¸­é—´è¡¨ç¤º) è§£æ](#4161-mir-ä¸­é—´è¡¨ç¤º-è§£æ)
    - [4.1.6.2 å€Ÿç”¨æ£€æŸ¥å™¨åŸç†](#4162-å€Ÿç”¨æ£€æŸ¥å™¨åŸç†)
    - [4.1.6.3 trait è§£æå’Œå•æ€åŒ–](#4163-trait-è§£æå’Œå•æ€åŒ–)
    - [4.1.6.4 LLVM åç«¯ä¼˜åŒ–](#4164-llvm-åç«¯ä¼˜åŒ–)
  - [4.1.7 é«˜æ€§èƒ½ç¼–ç¨‹æŠ€å·§](#417-é«˜æ€§èƒ½ç¼–ç¨‹æŠ€å·§)
    - [4.1.7.1 SIMD å‘é‡åŒ–](#4171-simd-å‘é‡åŒ–)
    - [4.1.7.2 åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–](#4172-åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–)
    - [4.1.7.3 ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„](#4173-ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„)
    - [4.1.7.4 CPU profiling å’Œç«ç„°å›¾](#4174-cpu-profiling-å’Œç«ç„°å›¾)
  - [4.1.8 unsafe Rust æœ€ä½³å®è·µ](#418-unsafe-rust-æœ€ä½³å®è·µ)
    - [4.1.8.1 unsafe çš„æ­£ç¡®ä½¿ç”¨åœºæ™¯](#4181-unsafe-çš„æ­£ç¡®ä½¿ç”¨åœºæ™¯)
    - [4.1.8.2 å®‰å…¨æŠ½è±¡å°è£…](#4182-å®‰å…¨æŠ½è±¡å°è£…)
    - [4.1.8.3 æœªå®šä¹‰è¡Œä¸º (UB) è§„é¿](#4183-æœªå®šä¹‰è¡Œä¸º-ub-è§„é¿)
    - [4.1.8.4 Miri å·¥å…·éªŒè¯](#4184-miri-å·¥å…·éªŒè¯)
  - [4.1.9 å®æˆ˜æ¡ˆä¾‹](#419-å®æˆ˜æ¡ˆä¾‹)
    - [4.1.9.1 é«˜æ€§èƒ½JSONè§£æå™¨](#4191-é«˜æ€§èƒ½jsonè§£æå™¨)
    - [4.1.9.2 é›¶æ‹·è´åºåˆ—åŒ–åº“](#4192-é›¶æ‹·è´åºåˆ—åŒ–åº“)
    - [4.1.9.3 è‡ªå®šä¹‰å¼‚æ­¥HTTPå®¢æˆ·ç«¯](#4193-è‡ªå®šä¹‰å¼‚æ­¥httpå®¢æˆ·ç«¯)
  - [4.1.10 å‚è€ƒèµ„æº](#4110-å‚è€ƒèµ„æº)

---

## 4.1.1 é«˜çº§ç±»å‹ç³»ç»Ÿ

### 4.1.1.1 æ³›å‹å…³è”ç±»å‹ (GAT)

**GAT ç®€ä»‹**:

æ³›å‹å…³è”ç±»å‹ (Generic Associated Types) æ˜¯ Rust 1.65 ç¨³å®šçš„ç‰¹æ€§ï¼Œå…è®¸åœ¨ trait ä¸­å®šä¹‰å¸¦æ³›å‹å‚æ•°çš„å…³è”ç±»å‹ã€‚

**åŸºç¡€ç¤ºä¾‹**:

```rust
// æ²¡æœ‰ GAT çš„é™åˆ¶
trait Container {
    type Item;
    fn get(&self) -> &Self::Item;
}

// æœ‰ GAT çš„çµæ´»æ€§
trait StreamingIterator {
    type Item<'a> where Self: 'a;
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}
```

**å®æˆ˜: é›¶æ‹·è´è¿­ä»£å™¨**:

```rust
use std::marker::PhantomData;

// ä¼ ç»Ÿè¿­ä»£å™¨éœ€è¦æ‹·è´
struct WindowsOld {
    data: Vec<u8>,
    window_size: usize,
}

impl Iterator for WindowsOld {
    type Item = Vec<u8>; // å¿…é¡»æ‹·è´æ•°æ®
    
    fn next(&mut self) -> Option<Self::Item> {
        // ... éœ€è¦ clone
    }
}

// GAT å®ç°é›¶æ‹·è´
trait LendingIterator {
    type Item<'a> where Self: 'a;
    fn next(&mut self) -> Option<Self::Item<'_>>;
}

struct Windows<'data> {
    data: &'data [u8],
    window_size: usize,
    pos: usize,
}

impl<'data> LendingIterator for Windows<'data> {
    type Item<'a> = &'a [u8] where Self: 'a;
    
    fn next(&mut self) -> Option<Self::Item<'_>> {
        if self.pos + self.window_size > self.data.len() {
            return None;
        }
        
        let window = &self.data[self.pos..self.pos + self.window_size];
        self.pos += 1;
        Some(window)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn process_windows() {
    let data = b"Hello, World!";
    let mut windows = Windows {
        data,
        window_size: 5,
        pos: 0,
    };
    
    while let Some(window) = windows.next() {
        println!("{:?}", std::str::from_utf8(window));
    }
}
```

**é«˜çº§åº”ç”¨: æ•°æ®åº“è¿æ¥æ± **:

```rust
trait ConnectionPool {
    type Connection<'a> where Self: 'a;
    
    async fn acquire<'a>(&'a self) -> Result<Self::Connection<'a>, Error>;
}

struct PostgresPool {
    pool: sqlx::PgPool,
}

impl ConnectionPool for PostgresPool {
    type Connection<'a> = sqlx::pool::PoolConnection<sqlx::Postgres> where Self: 'a;
    
    async fn acquire<'a>(&'a self) -> Result<Self::Connection<'a>, Error> {
        self.pool.acquire().await.map_err(Into::into)
    }
}

// é€šç”¨çš„æ•°æ®åº“æ“ä½œå‡½æ•°
async fn execute_query<P: ConnectionPool>(
    pool: &P,
    query: &str,
) -> Result<i64, Error> {
    let mut conn = pool.acquire().await?;
    // ä½¿ç”¨è¿æ¥æ‰§è¡ŒæŸ¥è¯¢
    Ok(0)
}
```

### 4.1.1.2 é«˜é˜¶traitè¾¹ç•Œ (HRTB)

**HRTB è§£å†³çš„é—®é¢˜**:

é«˜é˜¶ trait è¾¹ç•Œ (Higher-Rank Trait Bounds) ç”¨äºå¤„ç†"å¯¹æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ"çš„ trait çº¦æŸã€‚

**è¯­æ³•**:

```rust
// æ™®é€š trait è¾¹ç•Œ
fn foo<'a, T: Trait<'a>>(x: T) { }

// HRTB - "å¯¹æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸ 'a"
fn foo<T: for<'a> Trait<'a>>(x: T) { }
```

**å®æˆ˜: é€šç”¨çš„é—­åŒ…æ¥å£**:

```rust
// åœºæ™¯: éœ€è¦ä¸€ä¸ªå¯ä»¥æ¥å—ä»»æ„ç”Ÿå‘½å‘¨æœŸå¼•ç”¨çš„é—­åŒ…
trait Processor {
    fn process<'a>(&self, data: &'a str) -> &'a str;
}

// ä½¿ç”¨ HRTB
fn apply_processor<P>(data: &str, processor: P) -> String
where
    P: for<'a> Fn(&'a str) -> &'a str,
{
    processor(data).to_string()
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let result = apply_processor("hello", |s| {
        &s[..2] // è¿”å› "he"
    });
    
    println!("{}", result);
}
```

**å¤æ‚ç¤ºä¾‹: å¼‚æ­¥traitè¾¹ç•Œ**:

```rust
use std::future::Future;

// HRTB with Future
trait AsyncHandler {
    fn handle<'a>(&'a self, request: &'a str) -> impl Future<Output = String> + 'a;
}

fn process_request<H>(handler: H, request: &str) -> impl Future<Output = String>
where
    H: for<'a> AsyncHandler,
{
    async move {
        handler.handle(request).await
    }
}
```

### 4.1.1.3 ç±»å‹çº§ç¼–ç¨‹

**ç±»å‹çº§ç¼–ç¨‹** åˆ©ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶è¿›è¡Œè®¡ç®—å’ŒéªŒè¯ã€‚

**ç±»å‹çº§è‡ªç„¶æ•°**:

```rust
// ç±»å‹çº§ Peano æ•°
struct Zero;
struct Succ<N>(PhantomData<N>);

// ç±»å‹çº§åŠ æ³•
trait Add<Rhs> {
    type Output;
}

impl<N> Add<Zero> for N {
    type Output = N;
}

impl<N, M> Add<Succ<M>> for N
where
    N: Add<M>,
{
    type Output = Succ<<N as Add<M>>::Output>;
}

// ç±»å‹çº§æ¯”è¾ƒ
trait Compare<Rhs> {
    type Output;
}

struct Less;
struct Equal;
struct Greater;

// ä½¿ç”¨ç¤ºä¾‹: ç¼–è¯‘æ—¶ç¡®ä¿æ•°ç»„é•¿åº¦
struct Array<T, N> {
    data: Vec<T>,
    _marker: PhantomData<N>,
}

impl<T> Array<T, Zero> {
    fn new() -> Self {
        Self {
            data: Vec::new(),
            _marker: PhantomData,
        }
    }
}

impl<T, N> Array<T, Succ<N>> {
    fn push(mut self, value: T) -> Array<T, Succ<Succ<N>>> {
        self.data.push(value);
        Array {
            data: self.data,
            _marker: PhantomData,
        }
    }
}
```

**å®æˆ˜: ç±»å‹å®‰å…¨çš„çŠ¶æ€æœº**:

```rust
use std::marker::PhantomData;

// çŠ¶æ€å®šä¹‰
struct Locked;
struct Unlocked;

// çŠ¶æ€æœº
struct Door<State> {
    _state: PhantomData<State>,
}

impl Door<Locked> {
    fn new() -> Self {
        println!("Door created (locked)");
        Self { _state: PhantomData }
    }
    
    fn unlock(self) -> Door<Unlocked> {
        println!("Door unlocked");
        Door { _state: PhantomData }
    }
}

impl Door<Unlocked> {
    fn open(self) {
        println!("Door opened");
    }
    
    fn lock(self) -> Door<Locked> {
        println!("Door locked");
        Door { _state: PhantomData }
    }
}

// ä½¿ç”¨ - ç¼–è¯‘æ—¶ä¿è¯çŠ¶æ€è½¬æ¢æ­£ç¡®
fn main() {
    let door = Door::<Locked>::new();
    let door = door.unlock();
    door.open();
    
    // é”™è¯¯: æ— æ³•ç›´æ¥æ‰“å¼€é”å®šçš„é—¨
    // let door = Door::<Locked>::new();
    // door.open(); // ç¼–è¯‘é”™è¯¯!
}
```

### 4.1.1.4 å¹»åƒç±»å‹ (PhantomData)

**PhantomData çš„ä½œç”¨**:

- åœ¨ç»“æ„ä½“ä¸­æ ‡è®°æœªä½¿ç”¨çš„ç±»å‹å‚æ•°
- å®ç°ç±»å‹çº§æ ‡è®°å’Œçº¦æŸ
- ç®¡ç†ç”Ÿå‘½å‘¨æœŸå’Œæ‰€æœ‰æƒ

**åŸºç¡€ä½¿ç”¨**:

```rust
use std::marker::PhantomData;

// æ²¡æœ‰ PhantomData - ç¼–è¯‘é”™è¯¯
struct Foo<T> {
    data: *const u8, // ä¸ä½¿ç”¨ T
}

// ä½¿ç”¨ PhantomData
struct Foo<T> {
    data: *const u8,
    _marker: PhantomData<T>,
}
```

**å®æˆ˜: ç±»å‹å®‰å…¨çš„å•ä½ç³»ç»Ÿ**:

```rust
use std::marker::PhantomData;
use std::ops::{Add, Mul};

// å•ä½æ ‡è®°
struct Meter;
struct Second;
struct MeterPerSecond;

// æ•°é‡ç±»å‹
struct Quantity<Unit> {
    value: f64,
    _unit: PhantomData<Unit>,
}

impl<U> Quantity<U> {
    fn new(value: f64) -> Self {
        Self {
            value,
            _unit: PhantomData,
        }
    }
}

// åŒå•ä½å¯ä»¥ç›¸åŠ 
impl<U> Add for Quantity<U> {
    type Output = Quantity<U>;
    
    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// è·ç¦» / æ—¶é—´ = é€Ÿåº¦
impl Mul<Quantity<Second>> for Quantity<Meter> {
    type Output = Quantity<MeterPerSecond>;
    
    fn mul(self, rhs: Quantity<Second>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn physics_calculation() {
    let distance = Quantity::<Meter>::new(100.0);
    let time = Quantity::<Second>::new(10.0);
    
    let speed = distance * time; // Quantity<MeterPerSecond>
    
    // ç¼–è¯‘é”™è¯¯: ä¸åŒå•ä½ä¸èƒ½ç›¸åŠ 
    // let invalid = distance + time; // âŒ ç¼–è¯‘é”™è¯¯
}
```

---

## 4.1.2 å¼‚æ­¥ç¼–ç¨‹æ·±å…¥

### 4.1.2.1 async trait å®æˆ˜

**async trait çš„æŒ‘æˆ˜**:

Rust çš„ trait æ–¹æ³•ä¸­ä½¿ç”¨ `async` åœ¨ 1.75 ç‰ˆæœ¬ä¹‹å‰éœ€è¦é¢å¤–çš„åº“æ”¯æŒã€‚

**ä½¿ç”¨ async-trait**:

```rust
use async_trait::async_trait;

#[async_trait]
trait Repository {
    async fn find_by_id(&self, id: i64) -> Result<User, Error>;
    async fn save(&self, user: &User) -> Result<(), Error>;
}

struct PostgresRepository {
    pool: sqlx::PgPool,
}

#[async_trait]
impl Repository for PostgresRepository {
    async fn find_by_id(&self, id: i64) -> Result<User, Error> {
        sqlx::query_as!(
            User,
            "SELECT * FROM users WHERE id = $1",
            id
        )
        .fetch_one(&self.pool)
        .await
        .map_err(Into::into)
    }
    
    async fn save(&self, user: &User) -> Result<(), Error> {
        sqlx::query!(
            "INSERT INTO users (name, email) VALUES ($1, $2)",
            user.name,
            user.email
        )
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
}
```

**Rust 1.75+ åŸç”Ÿ async trait**:

```rust
// Rust 1.75+ ä¸å†éœ€è¦ async-trait å®
trait Repository {
    async fn find_by_id(&self, id: i64) -> Result<User, Error>;
}

struct PostgresRepository {
    pool: sqlx::PgPool,
}

impl Repository for PostgresRepository {
    async fn find_by_id(&self, id: i64) -> Result<User, Error> {
        sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", id)
            .fetch_one(&self.pool)
            .await
            .map_err(Into::into)
    }
}
```

**åŠ¨æ€åˆ†å‘ async trait**:

```rust
use std::future::Future;
use std::pin::Pin;

trait AsyncHandler: Send + Sync {
    fn handle(&self, request: String) 
        -> Pin<Box<dyn Future<Output = String> + Send + '_>>;
}

struct MyHandler;

impl AsyncHandler for MyHandler {
    fn handle(&self, request: String) 
        -> Pin<Box<dyn Future<Output = String> + Send + '_>> 
    {
        Box::pin(async move {
            // å¼‚æ­¥å¤„ç†é€»è¾‘
            format!("Processed: {}", request)
        })
    }
}

// ä½¿ç”¨ trait object
async fn process_with_handler(handler: &dyn AsyncHandler, request: String) -> String {
    handler.handle(request).await
}
```

### 4.1.2.2 Future åº•å±‚æœºåˆ¶

**Future trait å®šä¹‰**:

```rust
pub trait Future {
    type Output;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

**æ‰‹åŠ¨å®ç° Future**:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
}

impl Future for Delay {
    type Output = ();
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if Instant::now() >= self.when {
            Poll::Ready(())
        } else {
            // æ³¨å†Œ wakerï¼Œç¨åå”¤é†’
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn example() {
    let delay = Delay {
        when: Instant::now() + Duration::from_secs(1),
    };
    
    delay.await;
    println!("1 second elapsed");
}
```

**å®æˆ˜: è¶…æ—¶ Future**:

```rust
use tokio::time::{sleep, Duration};
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct Timeout<F> {
    future: F,
    deadline: Pin<Box<tokio::time::Sleep>>,
}

impl<F> Future for Timeout<F>
where
    F: Future,
{
    type Output = Result<F::Output, TimeoutError>;
    
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // å…ˆæ£€æŸ¥è¶…æ—¶
        if let Poll::Ready(_) = self.deadline.as_mut().poll(cx) {
            return Poll::Ready(Err(TimeoutError));
        }
        
        // å† poll å†…éƒ¨ future
        match unsafe { self.map_unchecked_mut(|s| &mut s.future) }.poll(cx) {
            Poll::Ready(output) => Poll::Ready(Ok(output)),
            Poll::Pending => Poll::Pending,
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn fetch_with_timeout() -> Result<String, TimeoutError> {
    let future = reqwest::get("https://example.com").await?.text();
    let timeout_future = Timeout {
        future,
        deadline: Box::pin(sleep(Duration::from_secs(5))),
    };
    
    timeout_future.await
}
```

### 4.1.2.3 Pin å’Œ Unpin

**Pin çš„å¿…è¦æ€§**:

è‡ªå¼•ç”¨ç»“æ„ä½“åœ¨å¼‚æ­¥ç¼–ç¨‹ä¸­å¾ˆå¸¸è§ï¼Œä½†ç§»åŠ¨å®ƒä»¬ä¼šå¯¼è‡´æ‚¬å‚æŒ‡é’ˆã€‚`Pin` ä¿è¯æ•°æ®ä¸ä¼šè¢«ç§»åŠ¨ã€‚

**åŸºç¡€ç¤ºä¾‹**:

```rust
use std::pin::Pin;

struct SelfReferential {
    data: String,
    pointer: *const String, // æŒ‡å‘ self.data
}

impl SelfReferential {
    fn new(s: String) -> Pin<Box<Self>> {
        let mut boxed = Box::new(Self {
            data: s,
            pointer: std::ptr::null(),
        });
        
        let ptr = &boxed.data as *const String;
        unsafe {
            let mut_ref = Pin::as_mut(&mut Pin::new_unchecked(&mut *boxed));
            Pin::get_unchecked_mut(mut_ref).pointer = ptr;
        }
        
        unsafe { Pin::new_unchecked(boxed) }
    }
    
    fn data(&self) -> &str {
        &self.data
    }
    
    fn pointer_data(&self) -> &str {
        unsafe { &*self.pointer }
    }
}
```

**Unpin æ ‡è®°**:

```rust
// å¤§å¤šæ•°ç±»å‹è‡ªåŠ¨å®ç° Unpin
struct MyStruct {
    data: i32,
}

// Unpin æ„å‘³ç€å¯ä»¥å®‰å…¨åœ°ç§»åŠ¨
fn can_move<T: Unpin>(value: T) -> T {
    value
}

// PhantomPinned æ ‡è®°ä¸å¯ç§»åŠ¨
use std::marker::PhantomPinned;

struct NotUnpin {
    data: i32,
    _pin: PhantomPinned,
}

// ç¼–è¯‘é”™è¯¯
// fn cannot_move(value: NotUnpin) -> NotUnpin {
//     value
// }
```

### 4.1.2.4 è‡ªå®šä¹‰å¼‚æ­¥è¿è¡Œæ—¶

**ç®€å•çš„å¼‚æ­¥è¿è¡Œæ—¶**:

```rust
use std::collections::VecDeque;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};
use std::sync::{Arc, Mutex};

type Task = Pin<Box<dyn Future<Output = ()>>>;

struct SimpleExecutor {
    tasks: Arc<Mutex<VecDeque<Task>>>,
}

impl SimpleExecutor {
    fn new() -> Self {
        Self {
            tasks: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    fn spawn(&self, task: impl Future<Output = ()> + 'static) {
        self.tasks.lock().unwrap().push_back(Box::pin(task));
    }
    
    fn run(&self) {
        loop {
            let task = {
                let mut tasks = self.tasks.lock().unwrap();
                tasks.pop_front()
            };
            
            if let Some(mut task) = task {
                let waker = self.create_waker();
                let mut context = Context::from_waker(&waker);
                
                match task.as_mut().poll(&mut context) {
                    Poll::Ready(_) => {
                        // ä»»åŠ¡å®Œæˆ
                    }
                    Poll::Pending => {
                        // é‡æ–°åŠ å…¥é˜Ÿåˆ—
                        self.tasks.lock().unwrap().push_back(task);
                    }
                }
            } else {
                // æ²¡æœ‰ä»»åŠ¡ï¼Œé€€å‡º
                break;
            }
        }
    }
    
    fn create_waker(&self) -> Waker {
        // ç®€åŒ–çš„ waker å®ç°
        unsafe fn clone(ptr: *const ()) -> RawWaker {
            RawWaker::new(ptr, &VTABLE)
        }
        
        unsafe fn wake(_: *const ()) {}
        unsafe fn wake_by_ref(_: *const ()) {}
        unsafe fn drop(_: *const ()) {}
        
        static VTABLE: RawWakerVTable = RawWakerVTable::new(clone, wake, wake_by_ref, drop);
        
        let raw_waker = RawWaker::new(std::ptr::null(), &VTABLE);
        unsafe { Waker::from_raw(raw_waker) }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let executor = SimpleExecutor::new();
    
    executor.spawn(async {
        println!("Task 1");
    });
    
    executor.spawn(async {
        println!("Task 2");
    });
    
    executor.run();
}
```

---

## 4.1.3 é›¶æˆæœ¬æŠ½è±¡å®æˆ˜

### 4.1.3.1 è¿­ä»£å™¨ä¼˜åŒ–

**è¿­ä»£å™¨ç»„åˆçš„é›¶æˆæœ¬**:

```rust
// å‡½æ•°å¼é£æ ¼
fn sum_of_squares_imperative(data: &[i32]) -> i32 {
    let mut sum = 0;
    for &x in data {
        if x % 2 == 0 {
            sum += x * x;
        }
    }
    sum
}

// è¿­ä»£å™¨é£æ ¼ - ç¼–è¯‘åæ€§èƒ½ç›¸åŒ
fn sum_of_squares_functional(data: &[i32]) -> i32 {
    data.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * x)
        .sum()
}
```

**æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–ä»£ç **:

```bash
# ä½¿ç”¨ cargo-asm æŸ¥çœ‹æ±‡ç¼–
cargo asm --release my_crate::sum_of_squares_functional

# ä½¿ç”¨ cargo-llvm-lines æŸ¥çœ‹ LLVM IR
cargo install cargo-llvm-lines
cargo llvm-lines --release
```

**è‡ªå®šä¹‰è¿­ä»£å™¨ä¼˜åŒ–**:

```rust
// æƒ°æ€§æ±‚å€¼çš„è¿­ä»£å™¨
struct FlattenIter<I, U>
where
    I: Iterator<Item = U>,
    U: IntoIterator,
{
    inner: I,
    current: Option<U::IntoIter>,
}

impl<I, U> Iterator for FlattenIter<I, U>
where
    I: Iterator<Item = U>,
    U: IntoIterator,
{
    type Item = U::Item;
    
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            if let Some(ref mut inner) = self.current {
                if let Some(item) = inner.next() {
                    return Some(item);
                }
                self.current = None;
            }
            
            self.current = self.inner.next().map(|u| u.into_iter());
            if self.current.is_none() {
                return None;
            }
        }
    }
}

// ç¼–è¯‘å™¨ä¼˜åŒ–æç¤º
#[inline(always)]
fn hot_path_function() {
    // å…³é”®è·¯å¾„ä»£ç 
}

#[cold]
fn error_handler() {
    // é”™è¯¯å¤„ç†ä»£ç ï¼Œæç¤ºç¼–è¯‘å™¨è¿™æ˜¯å†·è·¯å¾„
}
```

### 4.1.3.2 å†…è”å’Œå•æ€åŒ–

**å†…è”ç­–ç•¥**:

```rust
// æ€»æ˜¯å†…è”
#[inline(always)]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// æ°¸ä¸å†…è” (ç”¨äºè°ƒè¯•)
#[inline(never)]
fn debug_print(s: &str) {
    println!("{}", s);
}

// ç¼–è¯‘å™¨è‡ªåŠ¨å†³å®š (é»˜è®¤)
#[inline]
fn might_inline(x: i32) -> i32 {
    x * x
}
```

**å•æ€åŒ–ç¤ºä¾‹**:

```rust
// æ³›å‹å‡½æ•°
fn process<T: Display>(value: T) {
    println!("{}", value);
}

// ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆç‹¬ç«‹ä»£ç 
fn main() {
    process(42);        // ç”Ÿæˆ process::<i32>
    process("hello");   // ç”Ÿæˆ process::<&str>
    process(3.14);      // ç”Ÿæˆ process::<f64>
}

// æŸ¥çœ‹å•æ€åŒ–åçš„ä»£ç å¤§å°
// cargo bloat --release
```

**é¿å…è¿‡åº¦å•æ€åŒ–**:

```rust
// âŒ è¿‡åº¦å•æ€åŒ–
fn bad_design<T: Display, U: Debug, V: Clone>(t: T, u: U, v: V) {
    // å¤§é‡ä»£ç ...
    // æ¯ä¸ª (T, U, V) ç»„åˆéƒ½ä¼šç”Ÿæˆç‹¬ç«‹ä»£ç 
}

// âœ… ä½¿ç”¨ trait object å‡å°‘ä»£ç è†¨èƒ€
fn good_design(t: &dyn Display, u: &dyn Debug) {
    // åªæœ‰ä¸€ä»½ä»£ç 
}
```

### 4.1.3.3 ç¼–è¯‘æ—¶è®¡ç®— (const fn)

**const fn åŸºç¡€**:

```rust
// ç¼–è¯‘æ—¶è®¡ç®—
const fn factorial(n: u64) -> u64 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

// ç¼–è¯‘æ—¶å¸¸é‡
const FACTORIAL_10: u64 = factorial(10);

// æ•°ç»„é•¿åº¦å¿…é¡»æ˜¯ç¼–è¯‘æ—¶å¸¸é‡
const ARRAY_SIZE: usize = factorial(5) as usize;
let array: [i32; ARRAY_SIZE] = [0; ARRAY_SIZE];
```

**const fn é«˜çº§åº”ç”¨**:

```rust
// ç¼–è¯‘æ—¶ CRC32 æŸ¥æ‰¾è¡¨
const fn generate_crc32_table() -> [u32; 256] {
    let mut table = [0u32; 256];
    let mut i = 0;
    
    while i < 256 {
        let mut crc = i as u32;
        let mut j = 0;
        
        while j < 8 {
            if crc & 1 == 1 {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
            j += 1;
        }
        
        table[i] = crc;
        i += 1;
    }
    
    table
}

const CRC32_TABLE: [u32; 256] = generate_crc32_table();

fn crc32(data: &[u8]) -> u32 {
    let mut crc = 0xFFFFFFFF;
    for &byte in data {
        let index = ((crc ^ byte as u32) & 0xFF) as usize;
        crc = (crc >> 8) ^ CRC32_TABLE[index];
    }
    !crc
}
```

**constæ³›å‹**:

```rust
// ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„æ•°ç»„
struct Buffer<const N: usize> {
    data: [u8; N],
}

impl<const N: usize> Buffer<N> {
    const fn new() -> Self {
        Self { data: [0; N] }
    }
    
    const fn len(&self) -> usize {
        N
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const SMALL_BUFFER: Buffer<64> = Buffer::new();
const LARGE_BUFFER: Buffer<4096> = Buffer::new();
```

### 4.1.3.4 è¿‡ç¨‹å®æ€§èƒ½ä¼˜åŒ–

**è¿‡ç¨‹å®ç¼–è¯‘æ—¶å¼€é”€**:

```rust
// derive å®ç¤ºä¾‹
#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: i64,
    name: String,
    email: String,
}

// æŸ¥çœ‹å®å±•å¼€åçš„ä»£ç 
// cargo expand
```

**ä¼˜åŒ–ç­–ç•¥**:

```rust
// âœ… ä½¿ç”¨ serde çš„ derive å® (é«˜åº¦ä¼˜åŒ–)
#[derive(Serialize, Deserialize)]
struct Data {
    field: String,
}

// âŒ æ‰‹åŠ¨å®ç° (ä¸æ¨è)
impl Serialize for Data {
    // æ‰‹åŠ¨å®ç°é€šå¸¸æ€§èƒ½è¾ƒå·®
}
```

---

## 4.1.4 å†…å­˜ç®¡ç†é«˜çº§æŠ€å·§

### 4.1.4.1 è‡ªå®šä¹‰åˆ†é…å™¨

**å…¨å±€åˆ†é…å™¨**:

```rust
use std::alloc::{GlobalAlloc, System, Layout};
use std::sync::atomic::{AtomicUsize, Ordering};

struct CountingAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);
static DEALLOCATED: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for CountingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ptr = System.alloc(layout);
        if !ptr.is_null() {
            ALLOCATED.fetch_add(layout.size(), Ordering::Relaxed);
        }
        ptr
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        DEALLOCATED.fetch_add(layout.size(), Ordering::Relaxed);
        System.dealloc(ptr, layout);
    }
}

#[global_allocator]
static GLOBAL: CountingAllocator = CountingAllocator;

fn print_memory_stats() {
    let allocated = ALLOCATED.load(Ordering::Relaxed);
    let deallocated = DEALLOCATED.load(Ordering::Relaxed);
    println!("Allocated: {} bytes", allocated);
    println!("Deallocated: {} bytes", deallocated);
    println!("Current usage: {} bytes", allocated - deallocated);
}
```

### 4.1.4.2 å†…å­˜æ± è®¾è®¡

**ç®€å•å¯¹è±¡æ± **:

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Pool<T> {
    objects: RefCell<Vec<T>>,
    factory: Box<dyn Fn() -> T>,
}

impl<T> Pool<T> {
    fn new<F: Fn() -> T + 'static>(factory: F) -> Self {
        Self {
            objects: RefCell::new(Vec::new()),
            factory: Box::new(factory),
        }
    }
    
    fn acquire(&self) -> T {
        self.objects
            .borrow_mut()
            .pop()
            .unwrap_or_else(|| (self.factory)())
    }
    
    fn release(&self, object: T) {
        self.objects.borrow_mut().push(object);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn use_pool() {
    let pool = Rc::new(Pool::new(|| Vec::<u8>::with_capacity(1024)));
    
    let mut buffer = pool.acquire();
    buffer.extend_from_slice(b"Hello");
    pool.release(buffer);
}
```

### 4.1.4.3 arena åˆ†é…å™¨

**ä½¿ç”¨ typed-arena**:

```rust
use typed_arena::Arena;

struct Node<'a> {
    value: i32,
    children: Vec<&'a Node<'a>>,
}

fn build_tree() {
    let arena = Arena::new();
    
    let root = arena.alloc(Node {
        value: 1,
        children: vec![],
    });
    
    let child1 = arena.alloc(Node {
        value: 2,
        children: vec![],
    });
    
    let child2 = arena.alloc(Node {
        value: 3,
        children: vec![],
    });
    
    // ä¿®æ”¹ root çš„ children
    unsafe {
        let root_mut = &mut *(root as *const Node as *mut Node);
        root_mut.children.push(child1);
        root_mut.children.push(child2);
    }
}
```

### 4.1.4.4 å†…å­˜å¯¹é½å’Œå¸ƒå±€

**æ‰‹åŠ¨æ§åˆ¶å†…å­˜å¸ƒå±€**:

```rust
use std::alloc::{alloc, dealloc, Layout};

#[repr(C)]
struct Aligned {
    x: u8,
    y: u32,
    z: u16,
}

fn manual_allocation() {
    // åˆ›å»ºå¯¹é½çš„å†…å­˜å¸ƒå±€
    let layout = Layout::from_size_align(64, 64).unwrap();
    
    unsafe {
        let ptr = alloc(layout);
        if ptr.is_null() {
            panic!("Allocation failed");
        }
        
        // ä½¿ç”¨å†…å­˜
        *(ptr as *mut u64) = 0x1234567890ABCDEF;
        
        // é‡Šæ”¾å†…å­˜
        dealloc(ptr, layout);
    }
}

// SIMD å¯¹é½
#[repr(align(32))]
struct SimdData {
    data: [f32; 8],
}
```

---

## 4.1.5 å¹¶å‘åŸè¯­æ·±å…¥

### 4.1.5.1 åŸå­æ“ä½œå’Œå†…å­˜é¡ºåº

**å†…å­˜é¡ºåºè¯¦è§£**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

// Relaxed: æœ€å¼±ä¿è¯ï¼Œåªä¿è¯åŸå­æ€§
fn increment_relaxed() {
    COUNTER.fetch_add(1, Ordering::Relaxed);
}

// Acquire: è¯»å–æ—¶åŒæ­¥
fn read_acquire() -> usize {
    COUNTER.load(Ordering::Acquire)
}

// Release: å†™å…¥æ—¶åŒæ­¥
fn write_release(value: usize) {
    COUNTER.store(value, Ordering::Release);
}

// AcqRel: è¯»å†™éƒ½åŒæ­¥
fn swap_acqrel(value: usize) -> usize {
    COUNTER.swap(value, Ordering::AcqRel)
}

// SeqCst: æœ€å¼ºä¿è¯ï¼Œå…¨å±€é¡ºåºä¸€è‡´
fn increment_seqcst() {
    COUNTER.fetch_add(1, Ordering::SeqCst);
}
```

**å®æˆ˜: æ— é”è®¡æ•°å™¨**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::thread;

struct LockFreeCounter {
    value: AtomicU64,
}

impl LockFreeCounter {
    fn new() -> Self {
        Self {
            value: AtomicU64::new(0),
        }
    }
    
    fn increment(&self) -> u64 {
        self.value.fetch_add(1, Ordering::Relaxed)
    }
    
    fn get(&self) -> u64 {
        self.value.load(Ordering::Acquire)
    }
}

fn benchmark_lock_free() {
    let counter = Arc::new(LockFreeCounter::new());
    let mut handles = vec![];
    
    for _ in 0..8 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1_000_000 {
                counter.increment();
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final count: {}", counter.get());
}
```

### 4.1.5.2 æ— é”æ•°æ®ç»“æ„å®ç°

**æ— é”æ ˆ**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeStack<T> {
    fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head
                .compare_exchange(head, new_node, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                break;
            }
        }
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            if self.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}
```

### 4.1.5.3 RwLock vs Mutex æ€§èƒ½åˆ†æ

**æ€§èƒ½å¯¹æ¯”**:

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::thread;
use std::time::Instant;

fn benchmark_mutex() {
    let data = Arc::new(Mutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..8 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..100_000 {
                let mut value = data.lock().unwrap();
                *value += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Mutex: {:?}", start.elapsed());
}

fn benchmark_rwlock() {
    let data = Arc::new(RwLock::new(0));
    let start = Instant::now();
    
    // 7 ä¸ªè¯»çº¿ç¨‹
    let mut handles = vec![];
    for _ in 0..7 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..100_000 {
                let _value = data.read().unwrap();
            }
        });
        handles.push(handle);
    }
    
    // 1 ä¸ªå†™çº¿ç¨‹
    let data_write = Arc::clone(&data);
    let write_handle = thread::spawn(move || {
        for _ in 0..100_000 {
            let mut value = data_write.write().unwrap();
            *value += 1;
        }
    });
    handles.push(write_handle);
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("RwLock: {:?}", start.elapsed());
}
```

### 4.1.5.4 çº¿ç¨‹æœ¬åœ°å­˜å‚¨ (TLS)

**thread_local! å®**:

```rust
use std::cell::RefCell;

thread_local! {
    static COUNTER: RefCell<u32> = RefCell::new(0);
}

fn increment_thread_local() {
    COUNTER.with(|c| {
        *c.borrow_mut() += 1;
    });
}

fn get_thread_local() -> u32 {
    COUNTER.with(|c| *c.borrow())
}

// ä½¿ç”¨ç¤ºä¾‹
fn thread_local_example() {
    let handles: Vec<_> = (0..4)
        .map(|i| {
            std::thread::spawn(move || {
                for _ in 0..10 {
                    increment_thread_local();
                }
                println!("Thread {}: count = {}", i, get_thread_local());
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 4.1.6 ç¼–è¯‘å™¨å†…éƒ¨æœºåˆ¶

### 4.1.6.1 MIR (ä¸­é—´è¡¨ç¤º) è§£æ

**æŸ¥çœ‹ MIR**:

```bash
# æŸ¥çœ‹ MIR
rustc --emit=mir my_file.rs

# æŸ¥çœ‹ä¼˜åŒ–åçš„ MIR
rustc --emit=mir -C opt-level=3 my_file.rs
```

**MIR ç¤ºä¾‹**:

```rust
// æºä»£ç 
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// MIR (ç®€åŒ–):
// fn add(_1: i32, _2: i32) -> i32 {
//     bb0: {
//         _0 = Add(move _1, move _2);
//         return;
//     }
// }
```

### 4.1.6.2 å€Ÿç”¨æ£€æŸ¥å™¨åŸç†

**å€Ÿç”¨è§„åˆ™**:

```rust
// âœ… å¤šä¸ªä¸å¯å˜å€Ÿç”¨
fn multiple_immutable() {
    let data = vec![1, 2, 3];
    let r1 = &data;
    let r2 = &data;
    println!("{:?} {:?}", r1, r2);
}

// âŒ å¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨åŒæ—¶å­˜åœ¨
fn conflicting_borrows() {
    let mut data = vec![1, 2, 3];
    let r1 = &data;
    // let r2 = &mut data; // ç¼–è¯‘é”™è¯¯!
    // println!("{:?}", r1);
}

// âœ… NLL (Non-Lexical Lifetimes)
fn nll_example() {
    let mut data = vec![1, 2, 3];
    let r1 = &data;
    println!("{:?}", r1); // r1 çš„ç”Ÿå‘½å‘¨æœŸåœ¨è¿™é‡Œç»“æŸ
    
    let r2 = &mut data; // ç°åœ¨å¯ä»¥åˆ›å»ºå¯å˜å€Ÿç”¨
    r2.push(4);
}
```

### 4.1.6.3 trait è§£æå’Œå•æ€åŒ–

**trait è§£æ**:

```rust
trait Display {
    fn display(&self) -> String;
}

impl Display for i32 {
    fn display(&self) -> String {
        self.to_string()
    }
}

// ç¼–è¯‘å™¨è§£æä¸º: <i32 as Display>::display(&value)
fn main() {
    let value = 42;
    println!("{}", value.display());
}
```

### 4.1.6.4 LLVM åç«¯ä¼˜åŒ–

**æŸ¥çœ‹ LLVM IR**:

```bash
# ç”Ÿæˆ LLVM IR
rustc --emit=llvm-ir my_file.rs

# ç”Ÿæˆä¼˜åŒ–çš„ LLVM IR
rustc --emit=llvm-ir -C opt-level=3 my_file.rs
```

---

## 4.1.7 é«˜æ€§èƒ½ç¼–ç¨‹æŠ€å·§

### 4.1.7.1 SIMD å‘é‡åŒ–

**ä½¿ç”¨ std::simd**:

```rust
#![feature(portable_simd)]
use std::simd::prelude::*;

fn sum_simd(data: &[f32]) -> f32 {
    let lanes = f32x8::LEN;
    let mut sum = f32x8::splat(0.0);
    
    let chunks = data.chunks_exact(lanes);
    let remainder = chunks.remainder();
    
    for chunk in chunks {
        sum += f32x8::from_slice(chunk);
    }
    
    sum.reduce_sum() + remainder.iter().sum::<f32>()
}

// æ‰‹åŠ¨å‘é‡åŒ– (ä¸ä½¿ç”¨ std::simd)
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

#[target_feature(enable = "avx2")]
unsafe fn sum_avx2(data: &[f32]) -> f32 {
    // AVX2 å®ç°
    let mut sum = _mm256_setzero_ps();
    
    for chunk in data.chunks_exact(8) {
        let values = _mm256_loadu_ps(chunk.as_ptr());
        sum = _mm256_add_ps(sum, values);
    }
    
    // æ°´å¹³æ±‚å’Œ
    let mut result = [0f32; 8];
    _mm256_storeu_ps(result.as_mut_ptr(), sum);
    result.iter().sum()
}
```

### 4.1.7.2 åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–

**likely/unlikely**:

```rust
#[inline(always)]
fn likely(b: bool) -> bool {
    #[cold]
    fn cold() {}
    
    if !b {
        cold();
    }
    b
}

#[inline(always)]
fn unlikely(b: bool) -> bool {
    #[cold]
    fn cold() {}
    
    if b {
        cold();
    }
    b
}

// ä½¿ç”¨ç¤ºä¾‹
fn process(data: Option<i32>) -> i32 {
    if unlikely(data.is_none()) {
        return 0;
    }
    
    data.unwrap() * 2
}
```

### 4.1.7.3 ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„

**SoA vs AoS**:

```rust
// AoS (Array of Structures) - ç¼“å­˜ä¸å‹å¥½
struct PointAoS {
    x: f32,
    y: f32,
    z: f32,
}

// SoA (Structure of Arrays) - ç¼“å­˜å‹å¥½
struct PointsSoA {
    x: Vec<f32>,
    y: Vec<f32>,
    z: Vec<f32>,
}

// æ‰¹é‡å¤„ç†æ—¶ SoA æ€§èƒ½æ›´å¥½
fn process_points_soa(points: &mut PointsSoA) {
    for x in &mut points.x {
        *x *= 2.0; // é¡ºåºè®¿é—®ï¼Œç¼“å­˜å‘½ä¸­ç‡é«˜
    }
}
```

### 4.1.7.4 CPU profiling å’Œç«ç„°å›¾

**ä½¿ç”¨ perf**:

```bash
# æ€§èƒ½åˆ†æ
cargo build --release
perf record --call-graph=dwarf ./target/release/my_app

# ç”Ÿæˆç«ç„°å›¾
perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg
```

**ä½¿ç”¨ cargo-flamegraph**:

```bash
cargo install flamegraph
cargo flamegraph --bin my_app
```

---

## 4.1.8 unsafe Rust æœ€ä½³å®è·µ

### 4.1.8.1 unsafe çš„æ­£ç¡®ä½¿ç”¨åœºæ™¯

**åˆç†çš„ unsafe ä½¿ç”¨**:

```rust
// âœ… FFI è°ƒç”¨
extern "C" {
    fn malloc(size: usize) -> *mut u8;
}

unsafe fn allocate(size: usize) -> *mut u8 {
    malloc(size)
}

// âœ… æ€§èƒ½å…³é”®è·¯å¾„
fn fast_get<T>(slice: &[T], index: usize) -> &T {
    unsafe {
        slice.get_unchecked(index)
    }
}

// âœ… å®ç°å®‰å…¨æŠ½è±¡
pub struct SafeWrapper {
    ptr: *mut i32,
}

impl SafeWrapper {
    pub fn new(value: i32) -> Self {
        let ptr = Box::into_raw(Box::new(value));
        Self { ptr }
    }
    
    pub fn get(&self) -> i32 {
        unsafe { *self.ptr }
    }
}

impl Drop for SafeWrapper {
    fn drop(&mut self) {
        unsafe {
            drop(Box::from_raw(self.ptr));
        }
    }
}
```

### 4.1.8.2 å®‰å…¨æŠ½è±¡å°è£…

**Vec çš„ç®€åŒ–å®ç°**:

```rust
use std::alloc::{alloc, dealloc, Layout};
use std::ptr;

pub struct SimpleVec<T> {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

impl<T> SimpleVec<T> {
    pub fn new() -> Self {
        Self {
            ptr: ptr::NonNull::dangling().as_ptr(),
            len: 0,
            cap: 0,
        }
    }
    
    pub fn push(&mut self, value: T) {
        if self.len == self.cap {
            self.grow();
        }
        
        unsafe {
            ptr::write(self.ptr.add(self.len), value);
        }
        self.len += 1;
    }
    
    fn grow(&mut self) {
        let new_cap = if self.cap == 0 { 1 } else { self.cap * 2 };
        let new_layout = Layout::array::<T>(new_cap).unwrap();
        
        let new_ptr = if self.cap == 0 {
            unsafe { alloc(new_layout) as *mut T }
        } else {
            let old_layout = Layout::array::<T>(self.cap).unwrap();
            unsafe {
                let ptr = alloc(new_layout) as *mut T;
                ptr::copy_nonoverlapping(self.ptr, ptr, self.len);
                dealloc(self.ptr as *mut u8, old_layout);
                ptr
            }
        };
        
        self.ptr = new_ptr;
        self.cap = new_cap;
    }
}
```

### 4.1.8.3 æœªå®šä¹‰è¡Œä¸º (UB) è§„é¿

**å¸¸è§ UB**:

```rust
// âŒ æ‚¬å‚æŒ‡é’ˆ
fn dangling_pointer() -> &'static i32 {
    let x = 42;
    &x // UB!
}

// âŒ æ•°æ®ç«äº‰
fn data_race() {
    let mut data = 0;
    let ptr = &mut data as *mut i32;
    
    std::thread::spawn(move || unsafe {
        *ptr += 1; // UB! æ— åŒæ­¥
    });
    
    data += 1; // UB! æ•°æ®ç«äº‰
}

// âŒ æœªåˆå§‹åŒ–å†…å­˜è¯»å–
fn uninitialized_read() {
    let x: i32;
    println!("{}", x); // UB!
}
```

### 4.1.8.4 Miri å·¥å…·éªŒè¯

**ä½¿ç”¨ Miri**:

```bash
# å®‰è£… Miri
rustup +nightly component add miri

# è¿è¡Œ Miri
cargo +nightly miri test
```

**Miri å¯æ£€æµ‹çš„ UB**:

- è¶Šç•Œè®¿é—®
- ä½¿ç”¨æœªåˆå§‹åŒ–å†…å­˜
- æ‚¬å‚æŒ‡é’ˆ
- æ•°æ®ç«äº‰
- è¿å Stacked Borrows è§„åˆ™

---

## 4.1.9 å®æˆ˜æ¡ˆä¾‹

### 4.1.9.1 é«˜æ€§èƒ½JSONè§£æå™¨

**simd-json ä½¿ç”¨**:

```rust
use simd_json;

fn parse_json_fast(input: &mut [u8]) -> Result<simd_json::Value, Error> {
    simd_json::to_borrowed_value(input).map_err(Into::into)
}

// å¯¹æ¯” serde_json
use serde_json;

fn parse_json_standard(input: &str) -> Result<serde_json::Value, Error> {
    serde_json::from_str(input).map_err(Into::into)
}

// æ€§èƒ½å¯¹æ¯”
// simd-json: ~2x faster than serde_json
```

### 4.1.9.2 é›¶æ‹·è´åºåˆ—åŒ–åº“

**ä½¿ç”¨ rkyv**:

```rust
use rkyv::{Archive, Deserialize, Serialize};

#[derive(Archive, Deserialize, Serialize)]
struct User {
    id: u64,
    name: String,
    email: String,
}

fn serialize_zero_copy(user: &User) -> Vec<u8> {
    rkyv::to_bytes::<_, 256>(user).unwrap().to_vec()
}

fn deserialize_zero_copy(bytes: &[u8]) -> &ArchivedUser {
    unsafe { rkyv::archived_root::<User>(bytes) }
}

// æ€§èƒ½ä¼˜åŠ¿: ååºåˆ—åŒ–å‡ ä¹é›¶å¼€é”€
```

### 4.1.9.3 è‡ªå®šä¹‰å¼‚æ­¥HTTPå®¢æˆ·ç«¯

**(ç¤ºä¾‹å®ç°æ¡†æ¶)**:

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

pub struct HttpClient {
    // ...
}

impl HttpClient {
    pub async fn get(&self, url: &str) -> Result<String, Error> {
        let mut stream = TcpStream::connect("example.com:80").await?;
        
        let request = format!(
            "GET {} HTTP/1.1\r\nHost: example.com\r\n\r\n",
            url
        );
        
        stream.write_all(request.as_bytes()).await?;
        
        let mut response = String::new();
        stream.read_to_string(&mut response).await?;
        
        Ok(response)
    }
}
```

---

## 4.1.10 å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Rust Reference](https://doc.rust-lang.org/reference/)
- [Rustonomicon (Unsafe Rust)](https://doc.rust-lang.org/nomicon/)
- [Rust Performance Book](https://nnethercote.github.io/perf-book/)

**ç›¸å…³æ–‡æ¡£**:

- [3.5 æ¶æ„è®¾è®¡æ¨¡å¼é›†](../references/3.5_æ¶æ„è®¾è®¡æ¨¡å¼é›†.md)
- [3.4 æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š](../references/3.4_æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æŠ¥å‘Šå®Œæˆæ—¶é—´**: 2025-10-21  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust é«˜çº§ç‰¹æ€§ç ”ç©¶ç»„

---

**ğŸ¯ æ·±å…¥ Rust é«˜çº§ç‰¹æ€§ï¼ŒæŒæ¡æ€§èƒ½ä¼˜åŒ–ç²¾é«“ï¼**
