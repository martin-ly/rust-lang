# 4.5 Rust å®‰å…¨ç»¼åˆåˆ†æ

> **æ–‡æ¡£å®šä½**: Rust ç”Ÿäº§ç¯å¢ƒå®‰å…¨å®æˆ˜æŒ‡å—  
> **ç›®æ ‡è¯»è€…**: å®‰å…¨å·¥ç¨‹å¸ˆã€æ¶æ„å¸ˆã€é«˜çº§å¼€å‘è€…  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **æœ€åæ›´æ–°**: 2025-10-22

---

## ğŸ“‹ ç›®å½•

- [4.5 Rust å®‰å…¨ç»¼åˆåˆ†æ](#45-rust-å®‰å…¨ç»¼åˆåˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
    - [æ ¸å¿ƒå†…å®¹](#æ ¸å¿ƒå†…å®¹)
    - [ç›®æ ‡ä¸ä»·å€¼](#ç›®æ ‡ä¸ä»·å€¼)
  - [1. å†…å­˜å®‰å…¨ï¼šRust çš„æ ¸å¿ƒä¼˜åŠ¿](#1-å†…å­˜å®‰å…¨rust-çš„æ ¸å¿ƒä¼˜åŠ¿)
    - [1.1 æ‰€æœ‰æƒç³»ç»Ÿå®‰å…¨ä¿éšœ](#11-æ‰€æœ‰æƒç³»ç»Ÿå®‰å…¨ä¿éšœ)
      - [é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ](#é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ)
      - [é˜²æ­¢äºŒæ¬¡é‡Šæ”¾](#é˜²æ­¢äºŒæ¬¡é‡Šæ”¾)
      - [RAII èµ„æºç®¡ç†](#raii-èµ„æºç®¡ç†)
    - [1.2 ç¼“å†²åŒºæº¢å‡ºé˜²æŠ¤](#12-ç¼“å†²åŒºæº¢å‡ºé˜²æŠ¤)
      - [è¾¹ç•Œæ£€æŸ¥](#è¾¹ç•Œæ£€æŸ¥)
      - [å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ](#å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ)
    - [1.3 ç©ºæŒ‡é’ˆä¸æ‚¬å‚æŒ‡é’ˆé˜²æŠ¤](#13-ç©ºæŒ‡é’ˆä¸æ‚¬å‚æŒ‡é’ˆé˜²æŠ¤)
      - [Option ç±»å‹æ›¿ä»£ç©ºæŒ‡é’ˆ](#option-ç±»å‹æ›¿ä»£ç©ºæŒ‡é’ˆ)
      - [Result ç±»å‹é”™è¯¯å¤„ç†](#result-ç±»å‹é”™è¯¯å¤„ç†)
    - [1.4 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ](#14-å†…å­˜å®‰å…¨æœ€ä½³å®è·µ)
  - [2. å¹¶å‘å®‰å…¨ï¼šæ— æ•°æ®ç«äº‰ä¿è¯](#2-å¹¶å‘å®‰å…¨æ— æ•°æ®ç«äº‰ä¿è¯)
    - [2.1 Send + Sync ç±»å‹çº¦æŸ](#21-send--sync-ç±»å‹çº¦æŸ)
      - [çº¿ç¨‹å®‰å…¨çš„ç±»å‹ç³»ç»Ÿ](#çº¿ç¨‹å®‰å…¨çš„ç±»å‹ç³»ç»Ÿ)
      - [ä½¿ç”¨é€šé“å®‰å…¨é€šä¿¡](#ä½¿ç”¨é€šé“å®‰å…¨é€šä¿¡)
    - [2.2 åŸå­æ“ä½œä¸æ— é”ç¼–ç¨‹](#22-åŸå­æ“ä½œä¸æ— é”ç¼–ç¨‹)
    - [2.3 æ­»é”é˜²æŠ¤ç­–ç•¥](#23-æ­»é”é˜²æŠ¤ç­–ç•¥)
    - [2.4 å¼‚æ­¥å®‰å…¨ç¼–ç¨‹](#24-å¼‚æ­¥å®‰å…¨ç¼–ç¨‹)
  - [3. å¯†ç å­¦å®‰å…¨å®è·µ](#3-å¯†ç å­¦å®‰å…¨å®è·µ)
    - [3.1 åŠ å¯†ç®—æ³•é€‰æ‹©](#31-åŠ å¯†ç®—æ³•é€‰æ‹©)
      - [å¯¹ç§°åŠ å¯†ï¼šAES-GCM](#å¯¹ç§°åŠ å¯†aes-gcm)
      - [éå¯¹ç§°åŠ å¯†ï¼šRSA](#éå¯¹ç§°åŠ å¯†rsa)
    - [3.2 å¯†é’¥ç®¡ç†](#32-å¯†é’¥ç®¡ç†)
    - [3.3 å®‰å…¨å“ˆå¸Œä¸ç­¾å](#33-å®‰å…¨å“ˆå¸Œä¸ç­¾å)
    - [3.4 å¯†ç å­¦åº“æ¨è](#34-å¯†ç å­¦åº“æ¨è)
  - [4. ç½‘ç»œå®‰å…¨é˜²æŠ¤](#4-ç½‘ç»œå®‰å…¨é˜²æŠ¤)
    - [4.1 TLS/SSL å®‰å…¨é…ç½®](#41-tlsssl-å®‰å…¨é…ç½®)
    - [4.2 HTTP å®‰å…¨å¤´](#42-http-å®‰å…¨å¤´)
    - [4.3 CSRF é˜²æŠ¤](#43-csrf-é˜²æŠ¤)
    - [4.4 DDoS é˜²æŠ¤](#44-ddos-é˜²æŠ¤)
  - [5. è¾“å…¥éªŒè¯ä¸è¿‡æ»¤](#5-è¾“å…¥éªŒè¯ä¸è¿‡æ»¤)
    - [5.1 è¾“å…¥éªŒè¯ç­–ç•¥](#51-è¾“å…¥éªŒè¯ç­–ç•¥)
    - [5.2 SQL æ³¨å…¥é˜²æŠ¤](#52-sql-æ³¨å…¥é˜²æŠ¤)
    - [5.3 XSS é˜²æŠ¤](#53-xss-é˜²æŠ¤)
    - [5.4 å‘½ä»¤æ³¨å…¥é˜²æŠ¤](#54-å‘½ä»¤æ³¨å…¥é˜²æŠ¤)
  - [6. å®‰å…¨é…ç½®ç®¡ç†](#6-å®‰å…¨é…ç½®ç®¡ç†)
    - [6.1 é…ç½®æ–‡ä»¶å®‰å…¨](#61-é…ç½®æ–‡ä»¶å®‰å…¨)
    - [6.2 ç¯å¢ƒå˜é‡ç®¡ç†](#62-ç¯å¢ƒå˜é‡ç®¡ç†)
    - [6.3 å¯†é’¥ä¸å‡­è¯ç®¡ç†](#63-å¯†é’¥ä¸å‡­è¯ç®¡ç†)
  - [7. å®‰å…¨å®¡è®¡ä¸ç›‘æ§](#7-å®‰å…¨å®¡è®¡ä¸ç›‘æ§)
    - [7.1 æ—¥å¿—å®¡è®¡](#71-æ—¥å¿—å®¡è®¡)
    - [7.2 å®‰å…¨ç›‘æ§æŒ‡æ ‡](#72-å®‰å…¨ç›‘æ§æŒ‡æ ‡)
    - [7.3 å…¥ä¾µæ£€æµ‹](#73-å…¥ä¾µæ£€æµ‹)
  - [8. å®‰å…¨å·¥å…·é›†æˆ](#8-å®‰å…¨å·¥å…·é›†æˆ)
    - [8.1 é™æ€åˆ†æå·¥å…·](#81-é™æ€åˆ†æå·¥å…·)
      - [Clippy](#clippy)
      - [RustSec Cargo Audit](#rustsec-cargo-audit)
    - [8.2 åŠ¨æ€åˆ†æå·¥å…·](#82-åŠ¨æ€åˆ†æå·¥å…·)
      - [Miri (unsafe ä»£ç æ£€æŸ¥)](#miri-unsafe-ä»£ç æ£€æŸ¥)
      - [AddressSanitizer](#addresssanitizer)
      - [ThreadSanitizer](#threadsanitizer)
    - [8.3 ä¾èµ–æ‰«æ](#83-ä¾èµ–æ‰«æ)
  - [9. å®‰å…¨å¨èƒæ¨¡å‹](#9-å®‰å…¨å¨èƒæ¨¡å‹)
    - [9.1 å¸¸è§å¨èƒç±»å‹](#91-å¸¸è§å¨èƒç±»å‹)
    - [9.2 å¨èƒåˆ†ææ–¹æ³•](#92-å¨èƒåˆ†ææ–¹æ³•)
    - [9.3 å¨èƒåº”å¯¹ç­–ç•¥](#93-å¨èƒåº”å¯¹ç­–ç•¥)
  - [10. ç”Ÿäº§ç¯å¢ƒå®‰å…¨æ¸…å•](#10-ç”Ÿäº§ç¯å¢ƒå®‰å…¨æ¸…å•)
    - [10.1 å¼€å‘é˜¶æ®µ](#101-å¼€å‘é˜¶æ®µ)
    - [10.2 éƒ¨ç½²é˜¶æ®µ](#102-éƒ¨ç½²é˜¶æ®µ)
    - [10.3 è¿è¡Œé˜¶æ®µ](#103-è¿è¡Œé˜¶æ®µ)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
  - [ğŸ“– å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ–‡æ¡£æ¦‚è¿°

### æ ¸å¿ƒå†…å®¹

æœ¬æ–‡æ¡£æä¾› Rust åœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„**å…¨æ–¹ä½å®‰å…¨å®æˆ˜æŒ‡å—**ï¼Œæ¶µç›–ï¼š

- ğŸ”’ **å†…å­˜å®‰å…¨**: åˆ©ç”¨ Rust æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢å†…å­˜æ¼æ´
- ğŸ” **å¹¶å‘å®‰å…¨**: Send + Sync ä¿è¯æ— æ•°æ®ç«äº‰
- ğŸ”‘ **å¯†ç å­¦å®‰å…¨**: å®‰å…¨çš„åŠ å¯†ç®—æ³•å’Œå¯†é’¥ç®¡ç†
- ğŸŒ **ç½‘ç»œå®‰å…¨**: TLS/SSLã€HTTP å®‰å…¨å¤´ã€CSRF é˜²æŠ¤
- ğŸ›¡ï¸ **è¾“å…¥éªŒè¯**: SQL æ³¨å…¥ã€XSSã€å‘½ä»¤æ³¨å…¥é˜²æŠ¤
- âš™ï¸ **é…ç½®å®‰å…¨**: å¯†é’¥ç®¡ç†ã€ç¯å¢ƒå˜é‡ã€é…ç½®æ–‡ä»¶
- ğŸ“Š **å®¡è®¡ç›‘æ§**: æ—¥å¿—ã€æŒ‡æ ‡ã€å…¥ä¾µæ£€æµ‹
- ğŸ”§ **å·¥å…·é›†æˆ**: Clippyã€Cargo Auditã€Fuzzing

### ç›®æ ‡ä¸ä»·å€¼

**å­¦ä¹ ç›®æ ‡**:

- âœ… æŒæ¡ Rust å†…å­˜å®‰å…¨å’Œå¹¶å‘å®‰å…¨æœºåˆ¶
- âœ… å­¦ä¼šä½¿ç”¨å¯†ç å­¦åº“æ„å»ºå®‰å…¨ç³»ç»Ÿ
- âœ… å®æ–½ç½‘ç»œå®‰å…¨å’Œè¾“å…¥éªŒè¯æœ€ä½³å®è·µ
- âœ… å»ºç«‹å®Œæ•´çš„å®‰å…¨å®¡è®¡å’Œç›‘æ§ä½“ç³»
- âœ… äº†è§£å¸¸è§å¨èƒæ¨¡å‹å’Œåº”å¯¹ç­–ç•¥

**æ ¸å¿ƒä»·å€¼**:

- ğŸ“ˆ **é™ä½å®‰å…¨é£é™©**: ä»è®¾è®¡é˜¶æ®µé¿å… 70% ä»¥ä¸Šçš„å¸¸è§æ¼æ´
- ğŸš€ **æå‡ä»£ç è´¨é‡**: å¼ºç±»å‹ç³»ç»Ÿ + å®‰å…¨æœ€ä½³å®è·µ
- ğŸ’° **å‡å°‘ç»´æŠ¤æˆæœ¬**: ç¼–è¯‘æ—¶æ•è·å®‰å…¨é—®é¢˜ï¼Œé™ä½è¿è¡Œæ—¶é£é™©
- ğŸ† **è¡Œä¸šè®¤å¯**: Rust åœ¨å®‰å…¨å…³é”®ç³»ç»Ÿä¸­çš„åº”ç”¨æ¡ˆä¾‹

---

## 1. å†…å­˜å®‰å…¨ï¼šRust çš„æ ¸å¿ƒä¼˜åŠ¿

> **æ ¸å¿ƒä¼˜åŠ¿**: Rust é€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿåœ¨**ç¼–è¯‘æ—¶**ä¿è¯å†…å­˜å®‰å…¨ï¼Œæ— éœ€ GC

### 1.1 æ‰€æœ‰æƒç³»ç»Ÿå®‰å…¨ä¿éšœ

#### é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ

```rust
// âœ… ç¼–è¯‘æ—¶é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ
pub fn safe_reference_usage() {
    let s = String::from("hello");
    let r = &s; // å®‰å…¨çš„å¼•ç”¨
    println!("{}", r);
    // s åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾ï¼Œr çš„ç”Ÿå‘½å‘¨æœŸå°äº s
}

// âŒ ä»¥ä¸‹ä»£ç æ— æ³•ç¼–è¯‘ï¼ˆæ‚¬å‚å¼•ç”¨ï¼‰
/*
fn dangling_reference() -> &String {
    let s = String::from("hello");
    &s // ç¼–è¯‘é”™è¯¯ï¼šs åœ¨å‡½æ•°ç»“æŸæ—¶è¢«é”€æ¯
}
*/
```

#### é˜²æ­¢äºŒæ¬¡é‡Šæ”¾

```rust
use std::sync::Arc;

// âœ… Arc ä¿è¯å®‰å…¨çš„å…±äº«æ‰€æœ‰æƒ
pub fn safe_shared_ownership() {
    let data = Arc::new(vec![1, 2, 3]);
    let data_clone = Arc::clone(&data);
    
    std::thread::spawn(move || {
        println!("Thread: {:?}", data_clone);
        // data_clone åœ¨çº¿ç¨‹ç»“æŸæ—¶è‡ªåŠ¨å‡å°‘å¼•ç”¨è®¡æ•°
    });
    
    println!("Main: {:?}", data);
    // data åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨å‡å°‘å¼•ç”¨è®¡æ•°
    // åªæœ‰å½“å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶æ‰é‡Šæ”¾å†…å­˜
}
```

#### RAII èµ„æºç®¡ç†

```rust
use std::fs::File;
use std::io::{self, Write};

// âœ… RAII ç¡®ä¿èµ„æºè‡ªåŠ¨æ¸…ç†
pub struct SecureFile {
    file: File,
}

impl SecureFile {
    pub fn create(path: &str) -> io::Result<Self> {
        let file = File::create(path)?;
        Ok(Self { file })
    }
    
    pub fn write_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.file.write_all(data)?;
        self.file.sync_all() // ç¡®ä¿æ•°æ®è½ç›˜
    }
}

impl Drop for SecureFile {
    fn drop(&mut self) {
        // è‡ªåŠ¨æ¸…ç†ï¼šåˆ·æ–°ç¼“å†²åŒºï¼Œå…³é—­æ–‡ä»¶
        let _ = self.file.sync_all();
        // File çš„ Drop ä¼šè‡ªåŠ¨å…³é—­æ–‡ä»¶æè¿°ç¬¦
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn use_secure_file() -> io::Result<()> {
    let mut file = SecureFile::create("secure.txt")?;
    file.write_data(b"sensitive data")?;
    // å‡½æ•°ç»“æŸæ—¶ï¼Œfile è‡ªåŠ¨è°ƒç”¨ Dropï¼Œç¡®ä¿èµ„æºé‡Šæ”¾
    Ok(())
}
```

### 1.2 ç¼“å†²åŒºæº¢å‡ºé˜²æŠ¤

#### è¾¹ç•Œæ£€æŸ¥

```rust
// âœ… è¿è¡Œæ—¶è¾¹ç•Œæ£€æŸ¥
pub fn safe_array_access(arr: &[i32], index: usize) -> Option<i32> {
    // get() æä¾›å®‰å…¨çš„è®¿é—®ï¼Œä¸ä¼šé€ æˆç¼“å†²åŒºæº¢å‡º
    arr.get(index).copied()
}

// âœ… ä½¿ç”¨ match å¤„ç†è¾¹ç•Œæƒ…å†µ
pub fn safe_string_slice(s: &str, start: usize, end: usize) -> Option<&str> {
    if end <= s.len() && start <= end {
        Some(&s[start..end])
    } else {
        None
    }
}

// âŒ ç›´æ¥ç´¢å¼•å¯èƒ½panicï¼ˆå¼€å‘ç¯å¢ƒï¼‰æˆ–æœªå®šä¹‰è¡Œä¸ºï¼ˆunsafeï¼‰
/*
pub fn unsafe_access(arr: &[i32], index: usize) -> i32 {
    arr[index] // å¦‚æœ index >= arr.len()ï¼Œä¼š panic
}
*/
```

#### å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ

```rust
use std::fmt;

// âœ… ç±»å‹å®‰å…¨çš„å­—ç¬¦ä¸²æ ¼å¼åŒ–
pub fn safe_format(name: &str, age: u32) -> String {
    format!("User: {}, Age: {}", name, age)
    // ç¼–è¯‘æ—¶æ£€æŸ¥å‚æ•°ç±»å‹ï¼Œé˜²æ­¢æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´
}

// âœ… é˜²æ­¢ç¼“å†²åŒºæº¢å‡ºçš„å­—ç¬¦ä¸²æ‹¼æ¥
pub fn safe_string_concatenation(parts: &[&str]) -> String {
    let total_len: usize = parts.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(total_len); // é¢„åˆ†é…ç©ºé—´
    
    for part in parts {
        result.push_str(part);
    }
    
    result
}

// âœ… å®‰å…¨çš„å­—ç¬¦ä¸²æ¸…ç†
pub fn sanitize_string(input: &str) -> String {
    input
        .chars()
        .filter(|c| c.is_alphanumeric() || c.is_whitespace())
        .collect()
}
```

### 1.3 ç©ºæŒ‡é’ˆä¸æ‚¬å‚æŒ‡é’ˆé˜²æŠ¤

#### Option ç±»å‹æ›¿ä»£ç©ºæŒ‡é’ˆ

```rust
// âœ… ä½¿ç”¨ Option ç±»å‹ï¼Œç¼–è¯‘æ—¶å¼ºåˆ¶å¤„ç†ç©ºå€¼
pub fn find_user(id: u64) -> Option<User> {
    DATABASE.get(&id).cloned()
}

pub fn process_user(id: u64) -> Result<(), String> {
    match find_user(id) {
        Some(user) => {
            println!("Found user: {}", user.name);
            Ok(())
        }
        None => Err(format!("User {} not found", id)),
    }
}

// âœ… é“¾å¼è°ƒç”¨å¤„ç† Option
pub fn get_user_email(id: u64) -> Option<String> {
    find_user(id)?
        .contact
        .email
        .map(|e| e.to_lowercase())
}
```

#### Result ç±»å‹é”™è¯¯å¤„ç†

```rust
use std::fs;
use std::io;

// âœ… Result ç±»å‹å¼ºåˆ¶é”™è¯¯å¤„ç†
pub fn read_config(path: &str) -> Result<Config, io::Error> {
    let content = fs::read_to_string(path)?;
    let config = parse_config(&content)
        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "Parse error"))?;
    Ok(config)
}

// âœ… è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
pub enum SecurityError {
    Unauthorized,
    InvalidToken,
    RateLimited,
    IoError(io::Error),
}

impl From<io::Error> for SecurityError {
    fn from(err: io::Error) -> Self {
        SecurityError::IoError(err)
    }
}

pub fn authenticate_user(token: &str) -> Result<User, SecurityError> {
    if token.is_empty() {
        return Err(SecurityError::InvalidToken);
    }
    
    let user = verify_token(token)?;
    
    if !user.is_active {
        return Err(SecurityError::Unauthorized);
    }
    
    Ok(user)
}
```

### 1.4 å†…å­˜å®‰å…¨æœ€ä½³å®è·µ

```rust
use zeroize::Zeroize;

// âœ… æ•æ„Ÿæ•°æ®æ¸…é›¶
pub struct SecretKey {
    data: Vec<u8>,
}

impl SecretKey {
    pub fn new(data: Vec<u8>) -> Self {
        Self { data }
    }
}

impl Drop for SecretKey {
    fn drop(&mut self) {
        // ç¡®ä¿å¯†é’¥åœ¨å†…å­˜ä¸­è¢«æ¸…é›¶
        self.data.zeroize();
    }
}

// âœ… ä½¿ç”¨å®‰å…¨çš„å†…å­˜åˆ†é…å™¨
// Cargo.toml:
// [dependencies]
// jemallocator = "0.5"

#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;

// âœ… é¿å…å†…å­˜æ³„æ¼
pub fn avoid_memory_leaks() {
    // ä½¿ç”¨ RAII è€Œä¸æ˜¯æ‰‹åŠ¨ç®¡ç†å†…å­˜
    let _guard = MutexGuard::new(); // è‡ªåŠ¨é‡Šæ”¾
    
    // é¿å…å¾ªç¯å¼•ç”¨
    use std::rc::{Rc, Weak};
    
    struct Node {
        parent: Option<Weak<Node>>, // ä½¿ç”¨ Weak æ‰“ç ´å¾ªç¯
        children: Vec<Rc<Node>>,
    }
}
```

**å†…å­˜å®‰å…¨å…³é”®ç‚¹**:

- âœ… ä½¿ç”¨æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢å†…å­˜é”™è¯¯
- âœ… ä½¿ç”¨ Option/Result æ›¿ä»£ç©ºæŒ‡é’ˆ
- âœ… åˆ©ç”¨ RAII è‡ªåŠ¨ç®¡ç†èµ„æº
- âœ… æ•æ„Ÿæ•°æ®åŠæ—¶æ¸…é›¶
- âœ… é¿å… unsafe ä»£ç ï¼Œå¿…è¦æ—¶è¿›è¡Œä¸¥æ ¼å®¡æŸ¥

---

## 2. å¹¶å‘å®‰å…¨ï¼šæ— æ•°æ®ç«äº‰ä¿è¯

> **æ ¸å¿ƒä¿è¯**: Rust é€šè¿‡ Send + Sync åœ¨ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰

### 2.1 Send + Sync ç±»å‹çº¦æŸ

#### çº¿ç¨‹å®‰å…¨çš„ç±»å‹ç³»ç»Ÿ

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// âœ… Send: å¯ä»¥å®‰å…¨åœ°è½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹
// âœ… Sync: å¯ä»¥å®‰å…¨åœ°è¢«å¤šä¸ªçº¿ç¨‹å¼•ç”¨

pub fn thread_safe_counter() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}

// âŒ ä¸å®‰å…¨çš„ç±»å‹æ— æ³•è·¨çº¿ç¨‹ä½¿ç”¨
/*
use std::rc::Rc;

fn unsafe_shared_state() {
    let counter = Rc::new(RefCell::new(0)); // Rc ä¸æ˜¯ Send
    thread::spawn(move || {
        // ç¼–è¯‘é”™è¯¯ï¼šRc<RefCell<i32>> cannot be sent between threads safely
    });
}
*/
```

#### ä½¿ç”¨é€šé“å®‰å…¨é€šä¿¡

```rust
use std::sync::mpsc;
use std::thread;

// âœ… ä½¿ç”¨é€šé“æ›¿ä»£å…±äº«å†…å­˜
pub fn channel_communication() {
    let (tx, rx) = mpsc::channel();
    
    // ç”Ÿäº§è€…çº¿ç¨‹
    thread::spawn(move || {
        for i in 0..10 {
            tx.send(i).unwrap();
        }
    });
    
    // æ¶ˆè´¹è€…çº¿ç¨‹
    for received in rx {
        println!("Got: {}", received);
    }
}

// âœ… å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…
pub fn mpsc_example() {
    let (tx, rx) = mpsc::channel();
    
    for i in 0..5 {
        let tx = tx.clone();
        thread::spawn(move || {
            tx.send(format!("Message {}", i)).unwrap();
        });
    }
    
    drop(tx); // å…³é—­å‘é€ç«¯
    
    for msg in rx {
        println!("{}", msg);
    }
}
```

### 2.2 åŸå­æ“ä½œä¸æ— é”ç¼–ç¨‹

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

// âœ… åŸå­è®¡æ•°å™¨ï¼ˆæ— é”ï¼‰
pub struct LockFreeCounter {
    count: AtomicUsize,
}

impl LockFreeCounter {
    pub fn new() -> Self {
        Self {
            count: AtomicUsize::new(0),
        }
    }
    
    pub fn increment(&self) -> usize {
        self.count.fetch_add(1, Ordering::SeqCst)
    }
    
    pub fn get(&self) -> usize {
        self.count.load(Ordering::SeqCst)
    }
}

// âœ… åŸå­æ ‡å¿—
pub struct ShutdownSignal {
    shutdown: AtomicBool,
}

impl ShutdownSignal {
    pub fn new() -> Self {
        Self {
            shutdown: AtomicBool::new(false),
        }
    }
    
    pub fn trigger(&self) {
        self.shutdown.store(true, Ordering::SeqCst);
    }
    
    pub fn is_shutdown(&self) -> bool {
        self.shutdown.load(Ordering::SeqCst)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn lockfree_example() {
    let counter = Arc::new(LockFreeCounter::new());
    let signal = Arc::new(ShutdownSignal::new());
    
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let signal = Arc::clone(&signal);
        
        let handle = thread::spawn(move || {
            while !signal.is_shutdown() {
                counter.increment();
                thread::sleep(std::time::Duration::from_millis(10));
            }
        });
        
        handles.push(handle);
    }
    
    thread::sleep(std::time::Duration::from_secs(1));
    signal.trigger();
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Total count: {}", counter.get());
}
```

### 2.3 æ­»é”é˜²æŠ¤ç­–ç•¥

```rust
use std::sync::{Mutex, Arc};
use std::thread;
use std::time::Duration;

// âœ… ç­–ç•¥ 1: å›ºå®šé”é¡ºåº
pub struct DeadlockFreeSystem {
    resource_a: Mutex<ResourceA>,
    resource_b: Mutex<ResourceB>,
}

impl DeadlockFreeSystem {
    pub fn safe_operation(&self) {
        // å§‹ç»ˆæŒ‰ç›¸åŒé¡ºåºè·å–é”
        let _guard_a = self.resource_a.lock().unwrap();
        let _guard_b = self.resource_b.lock().unwrap();
        
        // æ‰§è¡Œéœ€è¦ä¸¤ä¸ªèµ„æºçš„æ“ä½œ
    }
}

// âœ… ç­–ç•¥ 2: ä½¿ç”¨ try_lock é¿å…æ­»é”
pub fn try_lock_approach(system: &DeadlockFreeSystem) -> Result<(), &'static str> {
    let guard_a = system.resource_a.try_lock()
        .map_err(|_| "Failed to acquire lock A")?;
    
    let guard_b = system.resource_b.try_lock()
        .map_err(|_| "Failed to acquire lock B")?;
    
    // æ‰§è¡Œæ“ä½œ
    Ok(())
}

// âœ… ç­–ç•¥ 3: ä½¿ç”¨è¶…æ—¶
pub fn timeout_lock(mutex: &Mutex<i32>) -> Option<i32> {
    let start = std::time::Instant::now();
    
    loop {
        if let Ok(guard) = mutex.try_lock() {
            return Some(*guard);
        }
        
        if start.elapsed() > Duration::from_secs(5) {
            return None; // è¶…æ—¶
        }
        
        thread::sleep(Duration::from_millis(10));
    }
}
```

### 2.4 å¼‚æ­¥å®‰å…¨ç¼–ç¨‹

```rust
use tokio::sync::{RwLock, Semaphore};
use std::sync::Arc;

// âœ… å¼‚æ­¥è¯»å†™é”
pub struct AsyncDataStore {
    data: Arc<RwLock<HashMap<String, String>>>,
}

impl AsyncDataStore {
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn read(&self, key: &str) -> Option<String> {
        let data = self.data.read().await;
        data.get(key).cloned()
    }
    
    pub async fn write(&self, key: String, value: String) {
        let mut data = self.data.write().await;
        data.insert(key, value);
    }
}

// âœ… ä½¿ç”¨ä¿¡å·é‡é™åˆ¶å¹¶å‘
pub struct RateLimiter {
    semaphore: Arc<Semaphore>,
}

impl RateLimiter {
    pub fn new(max_concurrent: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }
    
    pub async fn execute<F, T>(&self, f: F) -> T
    where
        F: FnOnce() -> T,
    {
        let _permit = self.semaphore.acquire().await.unwrap();
        f()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn rate_limited_requests() {
    let limiter = Arc::new(RateLimiter::new(10)); // æœ€å¤š 10 ä¸ªå¹¶å‘è¯·æ±‚
    
    let mut handles = vec![];
    
    for i in 0..100 {
        let limiter = Arc::clone(&limiter);
        let handle = tokio::spawn(async move {
            limiter.execute(|| {
                println!("Processing request {}", i);
                std::thread::sleep(std::time::Duration::from_millis(100));
            }).await
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

**å¹¶å‘å®‰å…¨å…³é”®ç‚¹**:

- âœ… åˆ©ç”¨ Send + Sync ç¼–è¯‘æ—¶æ£€æŸ¥
- âœ… ä½¿ç”¨é€šé“æ›¿ä»£å…±äº«å†…å­˜
- âœ… åŸå­æ“ä½œå®ç°æ— é”å¹¶å‘
- âœ… å›ºå®šé”é¡ºåºé˜²æ­¢æ­»é”
- âœ… å¼‚æ­¥ç¼–ç¨‹é¿å…é˜»å¡

---

## 3. å¯†ç å­¦å®‰å…¨å®è·µ

> **åŸåˆ™**: æ°¸è¿œä¸è¦å®ç°è‡ªå·±çš„åŠ å¯†ç®—æ³•ï¼Œä½¿ç”¨ç»è¿‡å®¡è®¡çš„åº“

### 3.1 åŠ å¯†ç®—æ³•é€‰æ‹©

#### å¯¹ç§°åŠ å¯†ï¼šAES-GCM

```rust
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};

// âœ… AES-256-GCM (æ¨è)
pub struct SecureEncryption {
    cipher: Aes256Gcm,
}

impl SecureEncryption {
    pub fn new(key: &[u8; 32]) -> Self {
        let cipher = Aes256Gcm::new(key.into());
        Self { cipher }
    }
    
    pub fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>, String> {
        let nonce = Nonce::from_slice(b"unique nonce"); // å®é™…ä½¿ç”¨æ—¶åº”éšæœºç”Ÿæˆ
        
        self.cipher
            .encrypt(nonce, plaintext)
            .map_err(|e| format!("Encryption failed: {}", e))
    }
    
    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, String> {
        let nonce = Nonce::from_slice(b"unique nonce");
        
        self.cipher
            .decrypt(nonce, ciphertext)
            .map_err(|e| format!("Decryption failed: {}", e))
    }
}

// âœ… å®‰å…¨çš„å¯†é’¥ç”Ÿæˆ
pub fn generate_key() -> [u8; 32] {
    let mut key = [0u8; 32];
    OsRng.fill_bytes(&mut key);
    key
}
```

#### éå¯¹ç§°åŠ å¯†ï¼šRSA

```rust
use rsa::{RsaPrivateKey, RsaPublicKey, Pkcs1v15Encrypt};
use rsa::pkcs8::{EncodePrivateKey, EncodePublicKey};
use rand::rngs::OsRng;

// âœ… RSA åŠ å¯†/è§£å¯†
pub struct RsaCrypto {
    private_key: RsaPrivateKey,
    public_key: RsaPublicKey,
}

impl RsaCrypto {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let mut rng = OsRng;
        let bits = 2048;
        let private_key = RsaPrivateKey::new(&mut rng, bits)?;
        let public_key = RsaPublicKey::from(&private_key);
        
        Ok(Self {
            private_key,
            public_key,
        })
    }
    
    pub fn encrypt(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let mut rng = OsRng;
        let enc_data = self.public_key.encrypt(&mut rng, Pkcs1v15Encrypt, data)?;
        Ok(enc_data)
    }
    
    pub fn decrypt(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let dec_data = self.private_key.decrypt(Pkcs1v15Encrypt, data)?;
        Ok(dec_data)
    }
}
```

### 3.2 å¯†é’¥ç®¡ç†

```rust
use secrecy::{Secret, ExposeSecret};
use zeroize::Zeroizing;

// âœ… å®‰å…¨çš„å¯†é’¥å­˜å‚¨
pub struct KeyStore {
    master_key: Secret<Vec<u8>>,
}

impl KeyStore {
    pub fn new(master_key: Vec<u8>) -> Self {
        Self {
            master_key: Secret::new(master_key),
        }
    }
    
    pub fn derive_key(&self, salt: &[u8]) -> Zeroizing<Vec<u8>> {
        use argon2::{Argon2, password_hash::{PasswordHasher, SaltString}};
        
        let salt_string = SaltString::encode_b64(salt).unwrap();
        let argon2 = Argon2::default();
        
        let password_hash = argon2
            .hash_password(self.master_key.expose_secret(), &salt_string)
            .unwrap();
        
        Zeroizing::new(password_hash.hash.unwrap().as_bytes().to_vec())
    }
}

// âœ… å¯†é’¥è½®æ¢
pub struct KeyRotation {
    current_key: Secret<Vec<u8>>,
    previous_key: Option<Secret<Vec<u8>>>,
}

impl KeyRotation {
    pub fn rotate(&mut self, new_key: Vec<u8>) {
        self.previous_key = Some(self.current_key.clone());
        self.current_key = Secret::new(new_key);
    }
    
    pub fn try_decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, String> {
        // å…ˆå°è¯•å½“å‰å¯†é’¥
        if let Ok(plaintext) = decrypt_with_key(&self.current_key, ciphertext) {
            return Ok(plaintext);
        }
        
        // å›é€€åˆ°æ—§å¯†é’¥
        if let Some(ref old_key) = self.previous_key {
            decrypt_with_key(old_key, ciphertext)
        } else {
            Err("Decryption failed".to_string())
        }
    }
}

fn decrypt_with_key(key: &Secret<Vec<u8>>, ciphertext: &[u8]) -> Result<Vec<u8>, String> {
    // å®é™…è§£å¯†é€»è¾‘
    Ok(vec![])
}
```

### 3.3 å®‰å…¨å“ˆå¸Œä¸ç­¾å

```rust
use sha2::{Sha256, Digest};
use hmac::{Hmac, Mac};

type HmacSha256 = Hmac<Sha256>;

// âœ… SHA-256 å“ˆå¸Œ
pub fn secure_hash(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

// âœ… HMAC ç­¾åéªŒè¯
pub fn create_hmac(key: &[u8], message: &[u8]) -> Vec<u8> {
    let mut mac = HmacSha256::new_from_slice(key).unwrap();
    mac.update(message);
    mac.finalize().into_bytes().to_vec()
}

pub fn verify_hmac(key: &[u8], message: &[u8], signature: &[u8]) -> bool {
    let mut mac = HmacSha256::new_from_slice(key).unwrap();
    mac.update(message);
    mac.verify_slice(signature).is_ok()
}

// âœ… å¯†ç å“ˆå¸Œï¼ˆä½¿ç”¨ Argon2ï¼‰
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use argon2::password_hash::SaltString;

pub fn hash_password(password: &[u8]) -> Result<String, Box<dyn std::error::Error>> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    
    let password_hash = argon2
        .hash_password(password, &salt)?
        .to_string();
    
    Ok(password_hash)
}

pub fn verify_password(password: &[u8], hash: &str) -> Result<bool, Box<dyn std::error::Error>> {
    let parsed_hash = PasswordHash::new(hash)?;
    let argon2 = Argon2::default();
    
    Ok(argon2.verify_password(password, &parsed_hash).is_ok())
}
```

### 3.4 å¯†ç å­¦åº“æ¨è

| ç”¨é€” | æ¨èåº“ | ç‰¹ç‚¹ |
|------|--------|------|
| **å¯¹ç§°åŠ å¯†** | `aes-gcm`, `chacha20poly1305` | è®¤è¯åŠ å¯†ï¼Œé˜²ç¯¡æ”¹ |
| **éå¯¹ç§°åŠ å¯†** | `rsa`, `ed25519-dalek` | RSA / Ed25519 |
| **å“ˆå¸Œ** | `sha2`, `sha3`, `blake3` | SHA-256 / SHA-3 / BLAKE3 |
| **å¯†é’¥æ´¾ç”Ÿ** | `argon2`, `pbkdf2` | å¯†ç å“ˆå¸Œï¼Œå¯†é’¥æ´¾ç”Ÿ |
| **éšæœºæ•°** | `rand`, `getrandom` | å¯†ç å­¦å®‰å…¨éšæœºæ•° |
| **å®‰å…¨æ¯”è¾ƒ** | `subtle` | å¸¸é‡æ—¶é—´æ¯”è¾ƒ |
| **å¯†é’¥ç®¡ç†** | `secrecy`, `zeroize` | å¯†é’¥æ¸…é›¶ï¼Œå®‰å…¨å­˜å‚¨ |

**å¯†ç å­¦å®‰å…¨åŸåˆ™**:

- âœ… ä½¿ç”¨ç»è¿‡å®¡è®¡çš„å¯†ç å­¦åº“
- âœ… AES-256-GCM ç”¨äºå¯¹ç§°åŠ å¯†
- âœ… RSA-2048+ æˆ– Ed25519 ç”¨äºéå¯¹ç§°
- âœ… Argon2 ç”¨äºå¯†ç å“ˆå¸Œ
- âœ… å¯†é’¥åŠæ—¶æ¸…é›¶ï¼ˆzeroizeï¼‰
- âœ… ä½¿ç”¨å¯†ç å­¦å®‰å…¨éšæœºæ•°ç”Ÿæˆå™¨

---

## 4. ç½‘ç»œå®‰å…¨é˜²æŠ¤

> **åŸåˆ™**: é»˜è®¤å®‰å…¨ï¼Œæœ€å°æƒé™ï¼Œçºµæ·±é˜²å¾¡

### 4.1 TLS/SSL å®‰å…¨é…ç½®

```rust
use tokio_rustls::{TlsAcceptor, rustls};
use std::sync::Arc;
use std::fs::File;
use std::io::BufReader;

// âœ… å®‰å…¨çš„ TLS æœåŠ¡å™¨é…ç½®
pub fn create_tls_acceptor() -> Result<TlsAcceptor, Box<dyn std::error::Error>> {
    // åŠ è½½è¯ä¹¦
    let cert_file = &mut BufReader::new(File::open("cert.pem")?);
    let key_file = &mut BufReader::new(File::open("key.pem")?);
    
    let cert_chain = rustls_pemfile::certs(cert_file)?
        .into_iter()
        .map(rustls::Certificate)
        .collect();
    
    let keys = rustls_pemfile::pkcs8_private_keys(key_file)?;
    let key = rustls::PrivateKey(keys[0].clone());
    
    // åˆ›å»º TLS é…ç½®
    let config = rustls::ServerConfig::builder()
        .with_safe_default_cipher_suites()
        .with_safe_default_kx_groups()
        .with_safe_default_protocol_versions()?
        .with_no_client_auth()
        .with_single_cert(cert_chain, key)?;
    
    Ok(TlsAcceptor::from(Arc::new(config)))
}

// âœ… TLS å®¢æˆ·ç«¯é…ç½®
pub fn create_tls_connector() -> Result<tokio_rustls::TlsConnector, Box<dyn std::error::Error>> {
    let root_store = rustls::RootCertStore::empty();
    // æ·»åŠ ç³»ç»Ÿæ ¹è¯ä¹¦
    
    let config = rustls::ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth();
    
    Ok(tokio_rustls::TlsConnector::from(Arc::new(config)))
}
```

### 4.2 HTTP å®‰å…¨å¤´

```rust
use axum::{
    http::{header, HeaderMap, StatusCode},
    response::{IntoResponse, Response},
};

// âœ… æ·»åŠ å®‰å…¨å¤´
pub fn add_security_headers(mut headers: HeaderMap) -> HeaderMap {
    // HSTS: å¼ºåˆ¶ HTTPS
    headers.insert(
        header::STRICT_TRANSPORT_SECURITY,
        "max-age=31536000; includeSubDomains".parse().unwrap(),
    );
    
    // CSP: å†…å®¹å®‰å…¨ç­–ç•¥
    headers.insert(
        header::CONTENT_SECURITY_POLICY,
        "default-src 'self'; script-src 'self' 'unsafe-inline'".parse().unwrap(),
    );
    
    // X-Frame-Options: é˜²æ­¢ç‚¹å‡»åŠ«æŒ
    headers.insert(
        header::HeaderName::from_static("x-frame-options"),
        "DENY".parse().unwrap(),
    );
    
    // X-Content-Type-Options: é˜²æ­¢ MIME å—…æ¢
    headers.insert(
        header::HeaderName::from_static("x-content-type-options"),
        "nosniff".parse().unwrap(),
    );
    
    // X-XSS-Protection
    headers.insert(
        header::HeaderName::from_static("x-xss-protection"),
        "1; mode=block".parse().unwrap(),
    );
    
    // Referrer-Policy
    headers.insert(
        header::REFERER,
        "strict-origin-when-cross-origin".parse().unwrap(),
    );
    
    headers
}

// ä½¿ç”¨ä¸­é—´ä»¶è‡ªåŠ¨æ·»åŠ å®‰å…¨å¤´
pub async fn security_headers_middleware(
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> Response {
    let mut response = next.run(req).await;
    
    let headers = response.headers_mut();
    *headers = add_security_headers(std::mem::take(headers));
    
    response
}
```

### 4.3 CSRF é˜²æŠ¤

```rust
use axum::{
    extract::{State, Form},
    http::StatusCode,
    response::Html,
};
use rand::{thread_rng, Rng};
use std::sync::Arc;
use tokio::sync::RwLock;

// âœ… CSRF Token ç®¡ç†
pub struct CsrfProtection {
    tokens: Arc<RwLock<HashMap<String, String>>>,
}

impl CsrfProtection {
    pub fn new() -> Self {
        Self {
            tokens: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn generate_token(&self, session_id: &str) -> String {
        let token: String = thread_rng()
            .sample_iter(&rand::distributions::Alphanumeric)
            .take(32)
            .map(char::from)
            .collect();
        
        let mut tokens = self.tokens.write().await;
        tokens.insert(session_id.to_string(), token.clone());
        
        token
    }
    
    pub async fn verify_token(&self, session_id: &str, token: &str) -> bool {
        let tokens = self.tokens.read().await;
        tokens.get(session_id) == Some(&token.to_string())
    }
    
    pub async fn remove_token(&self, session_id: &str) {
        let mut tokens = self.tokens.write().await;
        tokens.remove(session_id);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[derive(serde::Deserialize)]
pub struct FormData {
    csrf_token: String,
    data: String,
}

pub async fn handle_form_submission(
    State(csrf): State<Arc<CsrfProtection>>,
    Form(form): Form<FormData>,
) -> Result<String, StatusCode> {
    let session_id = "user_session_id"; // ä»ä¼šè¯ä¸­è·å–
    
    if !csrf.verify_token(session_id, &form.csrf_token).await {
        return Err(StatusCode::FORBIDDEN);
    }
    
    csrf.remove_token(session_id).await;
    
    // å¤„ç†è¡¨å•æ•°æ®
    Ok("Success".to_string())
}
```

### 4.4 DDoS é˜²æŠ¤

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::time::{Duration, Instant};
use tokio::sync::Mutex;

// âœ… é€Ÿç‡é™åˆ¶
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<IpAddr, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }
    
    pub async fn check_rate_limit(&self, ip: IpAddr) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        let ip_requests = requests.entry(ip).or_insert_with(Vec::new);
        
        // æ¸…ç†è¿‡æœŸçš„è¯·æ±‚
        ip_requests.retain(|&time| now.duration_since(time) < self.window);
        
        if ip_requests.len() >= self.max_requests {
            return false; // è¶…è¿‡é€Ÿç‡é™åˆ¶
        }
        
        ip_requests.push(now);
        true
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn rate_limit_middleware(
    State(limiter): State<Arc<RateLimiter>>,
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> Result<Response, StatusCode> {
    let ip = extract_ip(&req);
    
    if !limiter.check_rate_limit(ip).await {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    
    Ok(next.run(req).await)
}

fn extract_ip(req: &axum::extract::Request) -> IpAddr {
    // ä»è¯·æ±‚ä¸­æå– IP åœ°å€
    // æ³¨æ„ï¼šç”Ÿäº§ç¯å¢ƒéœ€è¦å¤„ç†ä»£ç†å¤´ï¼ˆX-Forwarded-Forï¼‰
    "127.0.0.1".parse().unwrap()
}
```

**ç½‘ç»œå®‰å…¨å…³é”®ç‚¹**:

- âœ… å¼ºåˆ¶ä½¿ç”¨ HTTPS (HSTS)
- âœ… é…ç½®å®‰å…¨çš„ TLS å‚æ•°
- âœ… æ·»åŠ å…¨å¥— HTTP å®‰å…¨å¤´
- âœ… å®æ–½ CSRF é˜²æŠ¤
- âœ… å®æ–½é€Ÿç‡é™åˆ¶é˜²æ­¢ DDoS
- âœ… è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç 

---

## 5. è¾“å…¥éªŒè¯ä¸è¿‡æ»¤

> **åŸåˆ™**: æ°¸è¿œä¸è¦ä¿¡ä»»ç”¨æˆ·è¾“å…¥

### 5.1 è¾“å…¥éªŒè¯ç­–ç•¥

```rust
use validator::{Validate, ValidationError};
use regex::Regex;

// âœ… ä½¿ç”¨ validator åº“è¿›è¡ŒéªŒè¯
#[derive(Debug, Validate, serde::Deserialize)]
pub struct UserInput {
    #[validate(length(min = 3, max = 20))]
    pub username: String,
    
    #[validate(email)]
    pub email: String,
    
    #[validate(range(min = 18, max = 120))]
    pub age: u8,
    
    #[validate(custom = "validate_password")]
    pub password: String,
}

fn validate_password(password: &str) -> Result<(), ValidationError> {
    let has_uppercase = password.chars().any(|c| c.is_uppercase());
    let has_lowercase = password.chars().any(|c| c.is_lowercase());
    let has_digit = password.chars().any(|c| c.is_ascii_digit());
    let has_special = password.chars().any(|c| "!@#$%^&*".contains(c));
    
    if password.len() < 8 {
        return Err(ValidationError::new("password_too_short"));
    }
    
    if !(has_uppercase && has_lowercase && has_digit && has_special) {
        return Err(ValidationError::new("password_too_weak"));
    }
    
    Ok(())
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn validate_user_input(input: &UserInput) -> Result<(), String> {
    input.validate()
        .map_err(|e| format!("Validation error: {:?}", e))
}
```

### 5.2 SQL æ³¨å…¥é˜²æŠ¤

```rust
use sqlx::{PgPool, query, query_as};

// âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢ï¼ˆæ°¸è¿œä¸è¦æ‹¼æ¥ SQLï¼‰
pub async fn safe_query(pool: &PgPool, user_id: i64) -> Result<User, sqlx::Error> {
    let user = query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id)
        .fetch_one(pool)
        .await?;
    
    Ok(user)
}

// âœ… ä½¿ç”¨ ORMï¼ˆå¦‚ dieselï¼‰
use diesel::prelude::*;
use diesel::pg::PgConnection;

pub fn diesel_safe_query(conn: &mut PgConnection, user_id: i64) -> Result<User, diesel::result::Error> {
    use crate::schema::users::dsl::*;
    
    users
        .filter(id.eq(user_id))
        .first::<User>(conn)
}

// âŒ æ°¸è¿œä¸è¦è¿™æ ·åšï¼ˆSQL æ³¨å…¥æ¼æ´ï¼‰
/*
pub async fn unsafe_query(pool: &PgPool, user_input: &str) -> Result<Vec<User>, sqlx::Error> {
    let sql = format!("SELECT * FROM users WHERE name = '{}'", user_input);
    // å¦‚æœ user_input = "' OR '1'='1"ï¼Œå°†è¿”å›æ‰€æœ‰ç”¨æˆ·ï¼
    let users = sqlx::query_as(&sql).fetch_all(pool).await?;
    Ok(users)
}
*/
```

### 5.3 XSS é˜²æŠ¤

```rust
use ammonia::clean;
use html_escape::encode_text;

// âœ… HTML å®ä½“ç¼–ç 
pub fn escape_html(input: &str) -> String {
    encode_text(input).to_string()
}

// âœ… ä½¿ç”¨ç™½åå•è¿‡æ»¤ HTML
pub fn sanitize_html(input: &str) -> String {
    clean(input)
}

// âœ… å®‰å…¨çš„æ¨¡æ¿å¼•æ“ï¼ˆè‡ªåŠ¨è½¬ä¹‰ï¼‰
use askama::Template;

#[derive(Template)]
#[template(path = "user.html")]
pub struct UserTemplate {
    pub name: String, // è‡ªåŠ¨è½¬ä¹‰
}

// user.html:
// <h1>Hello, {{ name }}!</h1>
// å³ä½¿ name = "<script>alert('XSS')</script>"
// ä¹Ÿä¼šè¢«è½¬ä¹‰ä¸º &lt;script&gt;alert('XSS')&lt;/script&gt;
```

### 5.4 å‘½ä»¤æ³¨å…¥é˜²æŠ¤

```rust
use std::process::Command;

// âœ… ä½¿ç”¨å‚æ•°æ•°ç»„ï¼Œé¿å… shell è§£é‡Š
pub fn safe_command_execution(filename: &str) -> Result<String, std::io::Error> {
    // éªŒè¯è¾“å…¥
    if !filename.chars().all(|c| c.is_alphanumeric() || c == '.' || c == '-') {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Invalid filename",
        ));
    }
    
    // ä½¿ç”¨å‚æ•°æ•°ç»„ï¼Œä¸é€šè¿‡ shell
    let output = Command::new("cat")
        .arg(filename)
        .output()?;
    
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

// âŒ æ°¸è¿œä¸è¦è¿™æ ·åšï¼ˆå‘½ä»¤æ³¨å…¥æ¼æ´ï¼‰
/*
pub fn unsafe_command(user_input: &str) -> Result<String, std::io::Error> {
    let command = format!("cat {}", user_input);
    // å¦‚æœ user_input = "file.txt; rm -rf /", å°†æ‰§è¡Œåˆ é™¤å‘½ä»¤ï¼
    let output = Command::new("sh")
        .arg("-c")
        .arg(&command)
        .output()?;
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
*/
```

**è¾“å…¥éªŒè¯åŸåˆ™**:

- âœ… ç™½åå•éªŒè¯ä¼˜äºé»‘åå•
- âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢ SQL æ³¨å…¥
- âœ… HTML å®ä½“ç¼–ç é˜²æ­¢ XSS
- âœ… é¿å… shell è§£é‡Šé˜²æ­¢å‘½ä»¤æ³¨å…¥
- âœ… éªŒè¯æ–‡ä»¶è·¯å¾„é˜²æ­¢è·¯å¾„éå†
- âœ… é™åˆ¶è¾“å…¥é•¿åº¦é˜²æ­¢ DoS

---

## 6. å®‰å…¨é…ç½®ç®¡ç†

> **åŸåˆ™**: é…ç½®ä¸ä»£ç åˆ†ç¦»ï¼Œå¯†é’¥åŠ å¯†å­˜å‚¨

### 6.1 é…ç½®æ–‡ä»¶å®‰å…¨

```rust
use serde::{Deserialize, Serialize};
use std::fs;

// âœ… åˆ†ç¦»æ•æ„Ÿé…ç½®
#[derive(Debug, Deserialize)]
pub struct Config {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    #[serde(skip_serializing)] // é˜²æ­¢æ„å¤–åºåˆ—åŒ–
    pub secrets: Secrets,
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub database: String,
}

#[derive(Debug, Deserialize)]
pub struct Secrets {
    pub database_password: String,
    pub jwt_secret: String,
    pub api_key: String,
}

impl Config {
    pub fn load() -> Result<Self, Box<dyn std::error::Error>> {
        // ä»ç¯å¢ƒæˆ–é…ç½®æ–‡ä»¶åŠ è½½
        let config_file = fs::read_to_string("config.toml")?;
        let config: Config = toml::from_str(&config_file)?;
        
        Ok(config)
    }
}
```

### 6.2 ç¯å¢ƒå˜é‡ç®¡ç†

```rust
use dotenv::dotenv;
use std::env;

// âœ… ä½¿ç”¨ dotenv ç®¡ç†ç¯å¢ƒå˜é‡
pub struct Environment {
    pub database_url: String,
    pub jwt_secret: String,
    pub redis_url: String,
}

impl Environment {
    pub fn load() -> Result<Self, String> {
        dotenv().ok(); // åŠ è½½ .env æ–‡ä»¶
        
        Ok(Self {
            database_url: env::var("DATABASE_URL")
                .map_err(|_| "DATABASE_URL not set")?,
            jwt_secret: env::var("JWT_SECRET")
                .map_err(|_| "JWT_SECRET not set")?,
            redis_url: env::var("REDIS_URL")
                .map_err(|_| "REDIS_URL not set")?,
        })
    }
}

// .env æ–‡ä»¶ï¼ˆä¸è¦æäº¤åˆ°ç‰ˆæœ¬æ§åˆ¶ï¼‰
// DATABASE_URL=postgres://user:pass@localhost/db
// JWT_SECRET=your_secret_key_here
// REDIS_URL=redis://localhost:6379
```

### 6.3 å¯†é’¥ä¸å‡­è¯ç®¡ç†

```rust
use aws_sdk_secretsmanager::Client;
use tokio;

// âœ… ä½¿ç”¨ AWS Secrets Manager
pub async fn load_secret_from_aws(secret_name: &str) -> Result<String, Box<dyn std::error::Error>> {
    let config = aws_config::load_from_env().await;
    let client = Client::new(&config);
    
    let response = client
        .get_secret_value()
        .secret_id(secret_name)
        .send()
        .await?;
    
    let secret = response.secret_string()
        .ok_or("Secret not found")?;
    
    Ok(secret.to_string())
}

// âœ… ä½¿ç”¨ HashiCorp Vault
use vaultrs::client::{VaultClient, VaultClientSettingsBuilder};

pub async fn load_secret_from_vault(
    path: &str,
    key: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = VaultClient::new(
        VaultClientSettingsBuilder::default()
            .address("http://localhost:8200")
            .token("vault_token")
            .build()?,
    )?;
    
    let secret: HashMap<String, String> = vaultrs::kv2::read(&client, "secret", path).await?;
    
    secret.get(key)
        .cloned()
        .ok_or_else(|| "Key not found".into())
}
```

**é…ç½®å®‰å…¨åŸåˆ™**:

- âœ… é…ç½®ä¸ä»£ç åˆ†ç¦»
- âœ… æ•æ„Ÿé…ç½®ä½¿ç”¨ç¯å¢ƒå˜é‡
- âœ… å¯†é’¥ä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡
- âœ… .env æ–‡ä»¶ä¸æäº¤åˆ°ç‰ˆæœ¬æ§åˆ¶
- âœ… ç”Ÿäº§ç¯å¢ƒé…ç½®åŠ å¯†å­˜å‚¨
- âœ… å®šæœŸè½®æ¢å¯†é’¥

---

## 7. å®‰å…¨å®¡è®¡ä¸ç›‘æ§

> **åŸåˆ™**: è®°å½•ä¸€åˆ‡ï¼Œç›‘æ§å…³é”®æŒ‡æ ‡ï¼Œå¿«é€Ÿå“åº”

### 7.1 æ—¥å¿—å®¡è®¡

```rust
use tracing::{info, warn, error, instrument};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// âœ… ç»“æ„åŒ–æ—¥å¿—
pub fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

// âœ… å®¡è®¡æ—¥å¿—
#[instrument]
pub async fn audit_user_action(user_id: u64, action: &str, result: &str) {
    info!(
        user_id = user_id,
        action = action,
        result = result,
        timestamp = chrono::Utc::now().to_rfc3339(),
        "User action audit"
    );
}

// âœ… å®‰å…¨äº‹ä»¶æ—¥å¿—
pub fn log_security_event(event_type: &str, details: serde_json::Value) {
    warn!(
        event_type = event_type,
        details = ?details,
        "Security event detected"
    );
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn login_attempt(username: &str, success: bool) {
    let event_type = if success { "login_success" } else { "login_failure" };
    
    audit_user_action(0, "login", event_type).await;
    
    if !success {
        log_security_event(
            "failed_login",
            serde_json::json!({
                "username": username,
                "ip": "127.0.0.1",
                "timestamp": chrono::Utc::now(),
            }),
        );
    }
}
```

### 7.2 å®‰å…¨ç›‘æ§æŒ‡æ ‡

```rust
use prometheus::{Counter, Histogram, Registry};
use lazy_static::lazy_static;

lazy_static! {
    // âœ… è®¤è¯å¤±è´¥è®¡æ•°
    pub static ref AUTH_FAILURES: Counter = Counter::new(
        "auth_failures_total",
        "Total number of authentication failures"
    ).unwrap();
    
    // âœ… API è¯·æ±‚å»¶è¿Ÿ
    pub static ref REQUEST_DURATION: Histogram = Histogram::with_opts(
        prometheus::HistogramOpts::new(
            "request_duration_seconds",
            "Request duration in seconds"
        )
    ).unwrap();
    
    // âœ… é€Ÿç‡é™åˆ¶è§¦å‘
    pub static ref RATE_LIMIT_HITS: Counter = Counter::new(
        "rate_limit_hits_total",
        "Total number of rate limit hits"
    ).unwrap();
}

pub fn register_metrics(registry: &Registry) -> Result<(), Box<dyn std::error::Error>> {
    registry.register(Box::new(AUTH_FAILURES.clone()))?;
    registry.register(Box::new(REQUEST_DURATION.clone()))?;
    registry.register(Box::new(RATE_LIMIT_HITS.clone()))?;
    Ok(())
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn handle_auth(username: &str, password: &str) -> Result<(), String> {
    let timer = REQUEST_DURATION.start_timer();
    
    match authenticate(username, password).await {
        Ok(_) => {
            timer.observe_duration();
            Ok(())
        }
        Err(e) => {
            AUTH_FAILURES.inc();
            timer.observe_duration();
            Err(e)
        }
    }
}
```

### 7.3 å…¥ä¾µæ£€æµ‹

```rust
use std::collections::HashMap;
use std::net::IpAddr;

// âœ… å¼‚å¸¸æ£€æµ‹
pub struct AnomalyDetector {
    failed_attempts: HashMap<IpAddr, u32>,
    threshold: u32,
}

impl AnomalyDetector {
    pub fn new(threshold: u32) -> Self {
        Self {
            failed_attempts: HashMap::new(),
            threshold,
        }
    }
    
    pub fn record_failed_attempt(&mut self, ip: IpAddr) -> bool {
        let count = self.failed_attempts.entry(ip).or_insert(0);
        *count += 1;
        
        if *count >= self.threshold {
            self.trigger_alert(ip, *count);
            true // è§¦å‘è­¦æŠ¥
        } else {
            false
        }
    }
    
    pub fn reset_attempts(&mut self, ip: IpAddr) {
        self.failed_attempts.remove(&ip);
    }
    
    fn trigger_alert(&self, ip: IpAddr, count: u32) {
        error!(
            "SECURITY ALERT: IP {} has {} failed login attempts",
            ip, count
        );
        
        // å‘é€å‘Šè­¦åˆ°ç›‘æ§ç³»ç»Ÿ
        // send_alert_to_slack(&format!("Potential brute force attack from {}", ip));
    }
}

// âœ… IP å°ç¦
pub struct IpBlocklist {
    blocked_ips: HashMap<IpAddr, Instant>,
    block_duration: Duration,
}

impl IpBlocklist {
    pub fn block_ip(&mut self, ip: IpAddr) {
        self.blocked_ips.insert(ip, Instant::now());
        info!("IP {} has been blocked", ip);
    }
    
    pub fn is_blocked(&mut self, ip: IpAddr) -> bool {
        if let Some(&blocked_time) = self.blocked_ips.get(&ip) {
            if Instant::now().duration_since(blocked_time) < self.block_duration {
                return true;
            } else {
                self.blocked_ips.remove(&ip); // è§£é™¤å°ç¦
            }
        }
        false
    }
}
```

**å®¡è®¡ç›‘æ§åŸåˆ™**:

- âœ… è®°å½•æ‰€æœ‰è®¤è¯å’Œæˆæƒäº‹ä»¶
- âœ… è®°å½•æ‰€æœ‰æ•æ„Ÿæ“ä½œ
- âœ… ç›‘æ§å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
- âœ… è®¾ç½®å‘Šè­¦é˜ˆå€¼
- âœ… å®šæœŸå®¡æŸ¥æ—¥å¿—
- âœ… æ—¥å¿—å®‰å…¨å­˜å‚¨ï¼ˆé˜²ç¯¡æ”¹ï¼‰

---

## 8. å®‰å…¨å·¥å…·é›†æˆ

> **åŸåˆ™**: è‡ªåŠ¨åŒ–å®‰å…¨æ£€æŸ¥ï¼ŒCI/CD é›†æˆ

### 8.1 é™æ€åˆ†æå·¥å…·

#### Clippy

```bash
# å¯ç”¨æ‰€æœ‰å®‰å…¨ç›¸å…³çš„ lint
cargo clippy -- \
  -W clippy::all \
  -W clippy::pedantic \
  -W clippy::nursery \
  -W clippy::cargo
```

```toml
# clippy.toml
disallowed-methods = [
    # ç¦æ­¢ä¸å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ
    { path = "std::str::from_utf8_unchecked", reason = "use from_utf8 instead" },
    # ç¦æ­¢ä¸å®‰å…¨çš„ unwrap
    { path = "std::option::Option::unwrap", reason = "use ? or unwrap_or instead" },
    { path = "std::result::Result::unwrap", reason = "use ? or unwrap_or instead" },
]
```

#### RustSec Cargo Audit

```bash
# æ£€æŸ¥å·²çŸ¥æ¼æ´
cargo install cargo-audit
cargo audit

# è‡ªåŠ¨ä¿®å¤
cargo audit fix
```

```toml
# .cargo/audit.toml
[advisories]
unmaintained = "deny"
unsound = "deny"
yanked = "deny"
```

### 8.2 åŠ¨æ€åˆ†æå·¥å…·

#### Miri (unsafe ä»£ç æ£€æŸ¥)

```bash
# å®‰è£… Miri
rustup +nightly component add miri

# è¿è¡Œ Miri
cargo +nightly miri test
```

#### AddressSanitizer

```bash
# æ£€æµ‹å†…å­˜é”™è¯¯
RUSTFLAGS="-Z sanitizer=address" cargo +nightly run
```

#### ThreadSanitizer

```bash
# æ£€æµ‹æ•°æ®ç«äº‰
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly run
```

### 8.3 ä¾èµ–æ‰«æ

```bash
# cargo-deny: ä¾èµ–å®‰å…¨æ£€æŸ¥
cargo install cargo-deny

# æ£€æŸ¥ä¾èµ–
cargo deny check

# cargo-outdated: æ£€æŸ¥è¿‡æ—¶ä¾èµ–
cargo install cargo-outdated
cargo outdated
```

```toml
# deny.toml
[advisories]
db-path = "~/.cargo/advisory-db"
db-urls = ["https://github.com/rustsec/advisory-db"]
vulnerability = "deny"
unmaintained = "warn"
unsound = "warn"
yanked = "deny"

[licenses]
unlicensed = "deny"
allow = [
    "MIT",
    "Apache-2.0",
    "BSD-3-Clause",
]
deny = [
    "GPL-3.0",
]
```

**CI/CD é›†æˆ**:

```yaml
# .github/workflows/security.yml
name: Security Audit
on: [push, pull_request]

jobs:
  security_audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          
      - name: Run Cargo Audit
        uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Run Cargo Deny
        uses: EmbarkStudios/cargo-deny-action@v1
        
      - name: Run Clippy
        run: cargo clippy -- -W clippy::all -W clippy::pedantic
```

---

## 9. å®‰å…¨å¨èƒæ¨¡å‹

> **æ–¹æ³•**: STRIDE å¨èƒæ¨¡å‹

### 9.1 å¸¸è§å¨èƒç±»å‹

| å¨èƒ | æè¿° | Rust é˜²æŠ¤ |
|------|------|----------|
| **S**poofing (æ¬ºéª—) | ä¼ªé€ èº«ä»½ | JWTã€OAuth2 |
| **T**ampering (ç¯¡æ”¹) | ä¿®æ”¹æ•°æ® | HMACã€æ•°å­—ç­¾å |
| **R**epudiation (å¦è®¤) | å¦è®¤æ“ä½œ | å®¡è®¡æ—¥å¿— |
| **I**nformation Disclosure (ä¿¡æ¯æ³„éœ²) | æ•æ„Ÿæ•°æ®æ³„éœ² | åŠ å¯†ã€è®¿é—®æ§åˆ¶ |
| **D**enial of Service (æ‹’ç»æœåŠ¡) | ç³»ç»Ÿä¸å¯ç”¨ | é€Ÿç‡é™åˆ¶ã€èµ„æºé™åˆ¶ |
| **E**levation of Privilege (æƒé™æå‡) | éæ³•ææƒ | RBACã€æœ€å°æƒé™ |

### 9.2 å¨èƒåˆ†ææ–¹æ³•

```rust
// âœ… å¨èƒå»ºæ¨¡ç¤ºä¾‹
pub struct ThreatModel {
    pub asset: String,          // èµ„äº§ï¼šç”¨æˆ·æ•°æ®
    pub threat: String,         // å¨èƒï¼šSQL æ³¨å…¥
    pub vulnerability: String,  // æ¼æ´ï¼šå­—ç¬¦ä¸²æ‹¼æ¥ SQL
    pub impact: String,         // å½±å“ï¼šæ•°æ®æ³„éœ²
    pub likelihood: u8,         // å¯èƒ½æ€§ï¼š1-10
    pub severity: u8,           // ä¸¥é‡æ€§ï¼š1-10
    pub mitigation: String,     // ç¼“è§£ï¼šå‚æ•°åŒ–æŸ¥è¯¢
}

impl ThreatModel {
    pub fn risk_score(&self) -> u8 {
        (self.likelihood * self.severity) / 10
    }
}
```

### 9.3 å¨èƒåº”å¯¹ç­–ç•¥

**é˜²å¾¡å±‚çº§**:

```text
1. é¢„é˜² (Prevention)
   â”œâ”€â”€ è¾“å…¥éªŒè¯
   â”œâ”€â”€ è¾“å‡ºç¼–ç 
   â””â”€â”€ å®‰å…¨é…ç½®

2. æ£€æµ‹ (Detection)
   â”œâ”€â”€ æ—¥å¿—å®¡è®¡
   â”œâ”€â”€ å¼‚å¸¸æ£€æµ‹
   â””â”€â”€ å…¥ä¾µæ£€æµ‹

3. å“åº” (Response)
   â”œâ”€â”€ å‘Šè­¦æœºåˆ¶
   â”œâ”€â”€ è‡ªåŠ¨å°ç¦
   â””â”€â”€ åº”æ€¥é¢„æ¡ˆ

4. æ¢å¤ (Recovery)
   â”œâ”€â”€ å¤‡ä»½æ¢å¤
   â”œâ”€â”€ ç¾éš¾æ¢å¤
   â””â”€â”€ äº‹ååˆ†æ
```

---

## 10. ç”Ÿäº§ç¯å¢ƒå®‰å…¨æ¸…å•

### 10.1 å¼€å‘é˜¶æ®µ

- [ ] âœ… ä½¿ç”¨æœ€æ–°ç¨³å®šç‰ˆ Rust (1.90+)
- [ ] âœ… å¯ç”¨æ‰€æœ‰å®‰å…¨ Clippy lint
- [ ] âœ… è¿è¡Œ cargo audit æ£€æŸ¥ä¾èµ–æ¼æ´
- [ ] âœ… ä½¿ç”¨ cargo deny æ£€æŸ¥è®¸å¯è¯å’Œä¾èµ–
- [ ] âœ… ç¼–å†™å®‰å…¨æµ‹è¯•ç”¨ä¾‹
- [ ] âœ… ä»£ç å®¡æŸ¥å…³æ³¨å®‰å…¨é—®é¢˜
- [ ] âœ… æœ€å°åŒ– unsafe ä»£ç ä½¿ç”¨
- [ ] âœ… ä½¿ç”¨ cargo-fuzz è¿›è¡Œæ¨¡ç³Šæµ‹è¯•

### 10.2 éƒ¨ç½²é˜¶æ®µ

- [ ] âœ… ä½¿ç”¨ TLS 1.3 åŠ å¯†ä¼ è¾“
- [ ] âœ… é…ç½® HTTP å®‰å…¨å¤´
- [ ] âœ… å®æ–½é€Ÿç‡é™åˆ¶å’Œ CSRF é˜²æŠ¤
- [ ] âœ… å¯†é’¥å’Œå‡­è¯ä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡
- [ ] âœ… æœ€å°åŒ–å®¹å™¨é•œåƒï¼ˆdistrolessï¼‰
- [ ] âœ… ä½¿ç”¨é root ç”¨æˆ·è¿è¡Œ
- [ ] âœ… é…ç½®é˜²ç«å¢™è§„åˆ™
- [ ] âœ… å¯ç”¨ SELinux/AppArmor

### 10.3 è¿è¡Œé˜¶æ®µ

- [ ] âœ… å¯ç”¨ç»“æ„åŒ–æ—¥å¿—å’Œå®¡è®¡
- [ ] âœ… é…ç½®ç›‘æ§å‘Šè­¦ï¼ˆPrometheus/Grafanaï¼‰
- [ ] âœ… å®šæœŸå¤‡ä»½å’Œç¾éš¾æ¢å¤æ¼”ç»ƒ
- [ ] âœ… å®šæœŸæ›´æ–°ä¾èµ–å’Œå®‰å…¨è¡¥ä¸
- [ ] âœ… å®šæœŸè½®æ¢å¯†é’¥å’Œè¯ä¹¦
- [ ] âœ… å®šæœŸå®‰å…¨å®¡è®¡å’Œæ¸—é€æµ‹è¯•
- [ ] âœ… å»ºç«‹å®‰å…¨äº‹ä»¶å“åº”æµç¨‹
- [ ] âœ… åŸ¹è®­å›¢é˜Ÿå®‰å…¨æ„è¯†

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

**æ·±åº¦åˆ†æ**:

- [analysis/04_security_comprehensive_analysis.md](../analysis/rust190_ecosystem/04_security_analysis/security_comprehensive_analysis.md) - å®‰å…¨å¨èƒæ¨¡å‹å’Œè¯¦ç»†åˆ†æ

**ç›¸å…³æ–‡æ¡£**:

- [4.3 å½¢å¼åŒ–éªŒè¯æ–¹æ³•](4.3_å½¢å¼åŒ–éªŒè¯æ–¹æ³•.md) - ä½¿ç”¨ Kaniã€Prusti è¿›è¡Œå®‰å…¨éªŒè¯
- [3.4 æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š](../references/3.4_æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š.md) - å®‰å…¨æªæ–½çš„æ€§èƒ½å½±å“
- [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](../guides/2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md) - æ•°æ®åº“å®‰å…¨å®è·µ

---

## ğŸ“– å‚è€ƒèµ„æº

**å®˜æ–¹èµ„æº**:

- [Rust Security Guidelines](https://rust-lang.github.io/api-guidelines/safety.html)
- [Rust Secure Code Working Group](https://github.com/rust-secure-code)
- [RustSec Advisory Database](https://rustsec.org/)

**æ¨èä¹¦ç±**:

- "Rust Security Programming" - å®æˆ˜å®‰å…¨ç¼–ç¨‹
- "The Rust Programming Language (TRPL)" - Chapter 19: Unsafe Rust

**å®‰å…¨åº“**:

- [secrecy](https://crates.io/crates/secrecy) - å¯†é’¥å®‰å…¨ç®¡ç†
- [zeroize](https://crates.io/crates/zeroize) - å†…å­˜æ¸…é›¶
- [subtle](https://crates.io/crates/subtle) - å¸¸é‡æ—¶é—´æ¯”è¾ƒ
- [ring](https://crates.io/crates/ring) - å¯†ç å­¦åº“

**å·¥å…·**:

- [cargo-audit](https://crates.io/crates/cargo-audit) - æ¼æ´æ‰«æ
- [cargo-deny](https://crates.io/crates/cargo-deny) - ä¾èµ–æ£€æŸ¥
- [cargo-fuzz](https://crates.io/crates/cargo-fuzz) - æ¨¡ç³Šæµ‹è¯•

---

**æ–‡æ¡£åˆ›å»º**: 2025-10-22  
**Rust ç‰ˆæœ¬**: 1.90+  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ç»´æŠ¤**: Rust å®‰å…¨å·¥ä½œç»„

**ğŸ”’ è®°ä½ï¼šå®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡æ€§çš„ä»»åŠ¡ï¼**
