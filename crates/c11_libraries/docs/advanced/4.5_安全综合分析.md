# 4.5 Rust 安全综合分析

> **文档定位**: Rust 生产环境安全实战指南  
> **目标读者**: 安全工程师、架构师、高级开发者  
> **Rust 版本**: 1.90+  
> **最后更新**: 2025-10-22

---


## 📊 目录

- [📋 目录](#目录)
- [🎯 文档概述](#文档概述)
  - [核心内容](#核心内容)
  - [目标与价值](#目标与价值)
- [1. 内存安全：Rust 的核心优势](#1-内存安全rust-的核心优势)
  - [1.1 所有权系统安全保障](#11-所有权系统安全保障)
    - [防止悬垂指针](#防止悬垂指针)
    - [防止二次释放](#防止二次释放)
    - [RAII 资源管理](#raii-资源管理)
  - [1.2 缓冲区溢出防护](#12-缓冲区溢出防护)
    - [边界检查](#边界检查)
    - [安全的字符串操作](#安全的字符串操作)
  - [1.3 空指针与悬垂指针防护](#13-空指针与悬垂指针防护)
    - [Option 类型替代空指针](#option-类型替代空指针)
    - [Result 类型错误处理](#result-类型错误处理)
  - [1.4 内存安全最佳实践](#14-内存安全最佳实践)
- [2. 并发安全：无数据竞争保证](#2-并发安全无数据竞争保证)
  - [2.1 Send + Sync 类型约束](#21-send-sync-类型约束)
    - [线程安全的类型系统](#线程安全的类型系统)
    - [使用通道安全通信](#使用通道安全通信)
  - [2.2 原子操作与无锁编程](#22-原子操作与无锁编程)
  - [2.3 死锁防护策略](#23-死锁防护策略)
  - [2.4 异步安全编程](#24-异步安全编程)
- [3. 密码学安全实践](#3-密码学安全实践)
  - [3.1 加密算法选择](#31-加密算法选择)
    - [对称加密：AES-GCM](#对称加密aes-gcm)
    - [非对称加密：RSA](#非对称加密rsa)
  - [3.2 密钥管理](#32-密钥管理)
  - [3.3 安全哈希与签名](#33-安全哈希与签名)
  - [3.4 密码学库推荐](#34-密码学库推荐)
- [4. 网络安全防护](#4-网络安全防护)
  - [4.1 TLS/SSL 安全配置](#41-tlsssl-安全配置)
  - [4.2 HTTP 安全头](#42-http-安全头)
  - [4.3 CSRF 防护](#43-csrf-防护)
  - [4.4 DDoS 防护](#44-ddos-防护)
- [5. 输入验证与过滤](#5-输入验证与过滤)
  - [5.1 输入验证策略](#51-输入验证策略)
  - [5.2 SQL 注入防护](#52-sql-注入防护)
  - [5.3 XSS 防护](#53-xss-防护)
  - [5.4 命令注入防护](#54-命令注入防护)
- [6. 安全配置管理](#6-安全配置管理)
  - [6.1 配置文件安全](#61-配置文件安全)
  - [6.2 环境变量管理](#62-环境变量管理)
  - [6.3 密钥与凭证管理](#63-密钥与凭证管理)
- [7. 安全审计与监控](#7-安全审计与监控)
  - [7.1 日志审计](#71-日志审计)
  - [7.2 安全监控指标](#72-安全监控指标)
  - [7.3 入侵检测](#73-入侵检测)
- [8. 安全工具集成](#8-安全工具集成)
  - [8.1 静态分析工具](#81-静态分析工具)
    - [Clippy](#clippy)
    - [RustSec Cargo Audit](#rustsec-cargo-audit)
  - [8.2 动态分析工具](#82-动态分析工具)
    - [Miri (unsafe 代码检查)](#miri-unsafe-代码检查)
    - [AddressSanitizer](#addresssanitizer)
    - [ThreadSanitizer](#threadsanitizer)
  - [8.3 依赖扫描](#83-依赖扫描)
- [9. 安全威胁模型](#9-安全威胁模型)
  - [9.1 常见威胁类型](#91-常见威胁类型)
  - [9.2 威胁分析方法](#92-威胁分析方法)
  - [9.3 威胁应对策略](#93-威胁应对策略)
- [10. 生产环境安全清单](#10-生产环境安全清单)
  - [10.1 开发阶段](#101-开发阶段)
  - [10.2 部署阶段](#102-部署阶段)
  - [10.3 运行阶段](#103-运行阶段)
- [📚 延伸阅读](#延伸阅读)
- [📖 参考资源](#参考资源)


## 📋 目录

- [4.5 Rust 安全综合分析](#45-rust-安全综合分析)
  - [📋 目录](#-目录)
  - [🎯 文档概述](#-文档概述)
    - [核心内容](#核心内容)
    - [目标与价值](#目标与价值)
  - [1. 内存安全：Rust 的核心优势](#1-内存安全rust-的核心优势)
    - [1.1 所有权系统安全保障](#11-所有权系统安全保障)
      - [防止悬垂指针](#防止悬垂指针)
      - [防止二次释放](#防止二次释放)
      - [RAII 资源管理](#raii-资源管理)
    - [1.2 缓冲区溢出防护](#12-缓冲区溢出防护)
      - [边界检查](#边界检查)
      - [安全的字符串操作](#安全的字符串操作)
    - [1.3 空指针与悬垂指针防护](#13-空指针与悬垂指针防护)
      - [Option 类型替代空指针](#option-类型替代空指针)
      - [Result 类型错误处理](#result-类型错误处理)
    - [1.4 内存安全最佳实践](#14-内存安全最佳实践)
  - [2. 并发安全：无数据竞争保证](#2-并发安全无数据竞争保证)
    - [2.1 Send + Sync 类型约束](#21-send--sync-类型约束)
      - [线程安全的类型系统](#线程安全的类型系统)
      - [使用通道安全通信](#使用通道安全通信)
    - [2.2 原子操作与无锁编程](#22-原子操作与无锁编程)
    - [2.3 死锁防护策略](#23-死锁防护策略)
    - [2.4 异步安全编程](#24-异步安全编程)
  - [3. 密码学安全实践](#3-密码学安全实践)
    - [3.1 加密算法选择](#31-加密算法选择)
      - [对称加密：AES-GCM](#对称加密aes-gcm)
      - [非对称加密：RSA](#非对称加密rsa)
    - [3.2 密钥管理](#32-密钥管理)
    - [3.3 安全哈希与签名](#33-安全哈希与签名)
    - [3.4 密码学库推荐](#34-密码学库推荐)
  - [4. 网络安全防护](#4-网络安全防护)
    - [4.1 TLS/SSL 安全配置](#41-tlsssl-安全配置)
    - [4.2 HTTP 安全头](#42-http-安全头)
    - [4.3 CSRF 防护](#43-csrf-防护)
    - [4.4 DDoS 防护](#44-ddos-防护)
  - [5. 输入验证与过滤](#5-输入验证与过滤)
    - [5.1 输入验证策略](#51-输入验证策略)
    - [5.2 SQL 注入防护](#52-sql-注入防护)
    - [5.3 XSS 防护](#53-xss-防护)
    - [5.4 命令注入防护](#54-命令注入防护)
  - [6. 安全配置管理](#6-安全配置管理)
    - [6.1 配置文件安全](#61-配置文件安全)
    - [6.2 环境变量管理](#62-环境变量管理)
    - [6.3 密钥与凭证管理](#63-密钥与凭证管理)
  - [7. 安全审计与监控](#7-安全审计与监控)
    - [7.1 日志审计](#71-日志审计)
    - [7.2 安全监控指标](#72-安全监控指标)
    - [7.3 入侵检测](#73-入侵检测)
  - [8. 安全工具集成](#8-安全工具集成)
    - [8.1 静态分析工具](#81-静态分析工具)
      - [Clippy](#clippy)
      - [RustSec Cargo Audit](#rustsec-cargo-audit)
    - [8.2 动态分析工具](#82-动态分析工具)
      - [Miri (unsafe 代码检查)](#miri-unsafe-代码检查)
      - [AddressSanitizer](#addresssanitizer)
      - [ThreadSanitizer](#threadsanitizer)
    - [8.3 依赖扫描](#83-依赖扫描)
  - [9. 安全威胁模型](#9-安全威胁模型)
    - [9.1 常见威胁类型](#91-常见威胁类型)
    - [9.2 威胁分析方法](#92-威胁分析方法)
    - [9.3 威胁应对策略](#93-威胁应对策略)
  - [10. 生产环境安全清单](#10-生产环境安全清单)
    - [10.1 开发阶段](#101-开发阶段)
    - [10.2 部署阶段](#102-部署阶段)
    - [10.3 运行阶段](#103-运行阶段)
  - [📚 延伸阅读](#-延伸阅读)
  - [📖 参考资源](#-参考资源)

---

## 🎯 文档概述

### 核心内容

本文档提供 Rust 在生产环境中的**全方位安全实战指南**，涵盖：

- 🔒 **内存安全**: 利用 Rust 所有权系统防止内存漏洞
- 🔐 **并发安全**: Send + Sync 保证无数据竞争
- 🔑 **密码学安全**: 安全的加密算法和密钥管理
- 🌐 **网络安全**: TLS/SSL、HTTP 安全头、CSRF 防护
- 🛡️ **输入验证**: SQL 注入、XSS、命令注入防护
- ⚙️ **配置安全**: 密钥管理、环境变量、配置文件
- 📊 **审计监控**: 日志、指标、入侵检测
- 🔧 **工具集成**: Clippy、Cargo Audit、Fuzzing

### 目标与价值

**学习目标**:

- ✅ 掌握 Rust 内存安全和并发安全机制
- ✅ 学会使用密码学库构建安全系统
- ✅ 实施网络安全和输入验证最佳实践
- ✅ 建立完整的安全审计和监控体系
- ✅ 了解常见威胁模型和应对策略

**核心价值**:

- 📈 **降低安全风险**: 从设计阶段避免 70% 以上的常见漏洞
- 🚀 **提升代码质量**: 强类型系统 + 安全最佳实践
- 💰 **减少维护成本**: 编译时捕获安全问题，降低运行时风险
- 🏆 **行业认可**: Rust 在安全关键系统中的应用案例

---

## 1. 内存安全：Rust 的核心优势

> **核心优势**: Rust 通过所有权系统在**编译时**保证内存安全，无需 GC

### 1.1 所有权系统安全保障

#### 防止悬垂指针

```rust
// ✅ 编译时防止悬垂指针
pub fn safe_reference_usage() {
    let s = String::from("hello");
    let r = &s; // 安全的引用
    println!("{}", r);
    // s 在作用域结束时自动释放，r 的生命周期小于 s
}

// ❌ 以下代码无法编译（悬垂引用）
/*
fn dangling_reference() -> &String {
    let s = String::from("hello");
    &s // 编译错误：s 在函数结束时被销毁
}
*/
```

#### 防止二次释放

```rust
use std::sync::Arc;

// ✅ Arc 保证安全的共享所有权
pub fn safe_shared_ownership() {
    let data = Arc::new(vec![1, 2, 3]);
    let data_clone = Arc::clone(&data);
    
    std::thread::spawn(move || {
        println!("Thread: {:?}", data_clone);
        // data_clone 在线程结束时自动减少引用计数
    });
    
    println!("Main: {:?}", data);
    // data 在作用域结束时自动减少引用计数
    // 只有当引用计数为 0 时才释放内存
}
```

#### RAII 资源管理

```rust
use std::fs::File;
use std::io::{self, Write};

// ✅ RAII 确保资源自动清理
pub struct SecureFile {
    file: File,
}

impl SecureFile {
    pub fn create(path: &str) -> io::Result<Self> {
        let file = File::create(path)?;
        Ok(Self { file })
    }
    
    pub fn write_data(&mut self, data: &[u8]) -> io::Result<()> {
        self.file.write_all(data)?;
        self.file.sync_all() // 确保数据落盘
    }
}

impl Drop for SecureFile {
    fn drop(&mut self) {
        // 自动清理：刷新缓冲区，关闭文件
        let _ = self.file.sync_all();
        // File 的 Drop 会自动关闭文件描述符
    }
}

// 使用示例
pub fn use_secure_file() -> io::Result<()> {
    let mut file = SecureFile::create("secure.txt")?;
    file.write_data(b"sensitive data")?;
    // 函数结束时，file 自动调用 Drop，确保资源释放
    Ok(())
}
```

### 1.2 缓冲区溢出防护

#### 边界检查

```rust
// ✅ 运行时边界检查
pub fn safe_array_access(arr: &[i32], index: usize) -> Option<i32> {
    // get() 提供安全的访问，不会造成缓冲区溢出
    arr.get(index).copied()
}

// ✅ 使用 match 处理边界情况
pub fn safe_string_slice(s: &str, start: usize, end: usize) -> Option<&str> {
    if end <= s.len() && start <= end {
        Some(&s[start..end])
    } else {
        None
    }
}

// ❌ 直接索引可能panic（开发环境）或未定义行为（unsafe）
/*
pub fn unsafe_access(arr: &[i32], index: usize) -> i32 {
    arr[index] // 如果 index >= arr.len()，会 panic
}
*/
```

#### 安全的字符串操作

```rust
use std::fmt;

// ✅ 类型安全的字符串格式化
pub fn safe_format(name: &str, age: u32) -> String {
    format!("User: {}, Age: {}", name, age)
    // 编译时检查参数类型，防止格式化字符串漏洞
}

// ✅ 防止缓冲区溢出的字符串拼接
pub fn safe_string_concatenation(parts: &[&str]) -> String {
    let total_len: usize = parts.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(total_len); // 预分配空间
    
    for part in parts {
        result.push_str(part);
    }
    
    result
}

// ✅ 安全的字符串清理
pub fn sanitize_string(input: &str) -> String {
    input
        .chars()
        .filter(|c| c.is_alphanumeric() || c.is_whitespace())
        .collect()
}
```

### 1.3 空指针与悬垂指针防护

#### Option 类型替代空指针

```rust
// ✅ 使用 Option 类型，编译时强制处理空值
pub fn find_user(id: u64) -> Option<User> {
    DATABASE.get(&id).cloned()
}

pub fn process_user(id: u64) -> Result<(), String> {
    match find_user(id) {
        Some(user) => {
            println!("Found user: {}", user.name);
            Ok(())
        }
        None => Err(format!("User {} not found", id)),
    }
}

// ✅ 链式调用处理 Option
pub fn get_user_email(id: u64) -> Option<String> {
    find_user(id)?
        .contact
        .email
        .map(|e| e.to_lowercase())
}
```

#### Result 类型错误处理

```rust
use std::fs;
use std::io;

// ✅ Result 类型强制错误处理
pub fn read_config(path: &str) -> Result<Config, io::Error> {
    let content = fs::read_to_string(path)?;
    let config = parse_config(&content)
        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "Parse error"))?;
    Ok(config)
}

// ✅ 自定义错误类型
#[derive(Debug)]
pub enum SecurityError {
    Unauthorized,
    InvalidToken,
    RateLimited,
    IoError(io::Error),
}

impl From<io::Error> for SecurityError {
    fn from(err: io::Error) -> Self {
        SecurityError::IoError(err)
    }
}

pub fn authenticate_user(token: &str) -> Result<User, SecurityError> {
    if token.is_empty() {
        return Err(SecurityError::InvalidToken);
    }
    
    let user = verify_token(token)?;
    
    if !user.is_active {
        return Err(SecurityError::Unauthorized);
    }
    
    Ok(user)
}
```

### 1.4 内存安全最佳实践

```rust
use zeroize::Zeroize;

// ✅ 敏感数据清零
pub struct SecretKey {
    data: Vec<u8>,
}

impl SecretKey {
    pub fn new(data: Vec<u8>) -> Self {
        Self { data }
    }
}

impl Drop for SecretKey {
    fn drop(&mut self) {
        // 确保密钥在内存中被清零
        self.data.zeroize();
    }
}

// ✅ 使用安全的内存分配器
// Cargo.toml:
// [dependencies]
// jemallocator = "0.5"

#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;

// ✅ 避免内存泄漏
pub fn avoid_memory_leaks() {
    // 使用 RAII 而不是手动管理内存
    let _guard = MutexGuard::new(); // 自动释放
    
    // 避免循环引用
    use std::rc::{Rc, Weak};
    
    struct Node {
        parent: Option<Weak<Node>>, // 使用 Weak 打破循环
        children: Vec<Rc<Node>>,
    }
}
```

**内存安全关键点**:

- ✅ 使用所有权系统防止内存错误
- ✅ 使用 Option/Result 替代空指针
- ✅ 利用 RAII 自动管理资源
- ✅ 敏感数据及时清零
- ✅ 避免 unsafe 代码，必要时进行严格审查

---

## 2. 并发安全：无数据竞争保证

> **核心保证**: Rust 通过 Send + Sync 在编译时防止数据竞争

### 2.1 Send + Sync 类型约束

#### 线程安全的类型系统

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// ✅ Send: 可以安全地转移到另一个线程
// ✅ Sync: 可以安全地被多个线程引用

pub fn thread_safe_counter() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}

// ❌ 不安全的类型无法跨线程使用
/*
use std::rc::Rc;

fn unsafe_shared_state() {
    let counter = Rc::new(RefCell::new(0)); // Rc 不是 Send
    thread::spawn(move || {
        // 编译错误：Rc<RefCell<i32>> cannot be sent between threads safely
    });
}
*/
```

#### 使用通道安全通信

```rust
use std::sync::mpsc;
use std::thread;

// ✅ 使用通道替代共享内存
pub fn channel_communication() {
    let (tx, rx) = mpsc::channel();
    
    // 生产者线程
    thread::spawn(move || {
        for i in 0..10 {
            tx.send(i).unwrap();
        }
    });
    
    // 消费者线程
    for received in rx {
        println!("Got: {}", received);
    }
}

// ✅ 多生产者单消费者
pub fn mpsc_example() {
    let (tx, rx) = mpsc::channel();
    
    for i in 0..5 {
        let tx = tx.clone();
        thread::spawn(move || {
            tx.send(format!("Message {}", i)).unwrap();
        });
    }
    
    drop(tx); // 关闭发送端
    
    for msg in rx {
        println!("{}", msg);
    }
}
```

### 2.2 原子操作与无锁编程

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

// ✅ 原子计数器（无锁）
pub struct LockFreeCounter {
    count: AtomicUsize,
}

impl LockFreeCounter {
    pub fn new() -> Self {
        Self {
            count: AtomicUsize::new(0),
        }
    }
    
    pub fn increment(&self) -> usize {
        self.count.fetch_add(1, Ordering::SeqCst)
    }
    
    pub fn get(&self) -> usize {
        self.count.load(Ordering::SeqCst)
    }
}

// ✅ 原子标志
pub struct ShutdownSignal {
    shutdown: AtomicBool,
}

impl ShutdownSignal {
    pub fn new() -> Self {
        Self {
            shutdown: AtomicBool::new(false),
        }
    }
    
    pub fn trigger(&self) {
        self.shutdown.store(true, Ordering::SeqCst);
    }
    
    pub fn is_shutdown(&self) -> bool {
        self.shutdown.load(Ordering::SeqCst)
    }
}

// 使用示例
pub fn lockfree_example() {
    let counter = Arc::new(LockFreeCounter::new());
    let signal = Arc::new(ShutdownSignal::new());
    
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let signal = Arc::clone(&signal);
        
        let handle = thread::spawn(move || {
            while !signal.is_shutdown() {
                counter.increment();
                thread::sleep(std::time::Duration::from_millis(10));
            }
        });
        
        handles.push(handle);
    }
    
    thread::sleep(std::time::Duration::from_secs(1));
    signal.trigger();
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Total count: {}", counter.get());
}
```

### 2.3 死锁防护策略

```rust
use std::sync::{Mutex, Arc};
use std::thread;
use std::time::Duration;

// ✅ 策略 1: 固定锁顺序
pub struct DeadlockFreeSystem {
    resource_a: Mutex<ResourceA>,
    resource_b: Mutex<ResourceB>,
}

impl DeadlockFreeSystem {
    pub fn safe_operation(&self) {
        // 始终按相同顺序获取锁
        let _guard_a = self.resource_a.lock().unwrap();
        let _guard_b = self.resource_b.lock().unwrap();
        
        // 执行需要两个资源的操作
    }
}

// ✅ 策略 2: 使用 try_lock 避免死锁
pub fn try_lock_approach(system: &DeadlockFreeSystem) -> Result<(), &'static str> {
    let guard_a = system.resource_a.try_lock()
        .map_err(|_| "Failed to acquire lock A")?;
    
    let guard_b = system.resource_b.try_lock()
        .map_err(|_| "Failed to acquire lock B")?;
    
    // 执行操作
    Ok(())
}

// ✅ 策略 3: 使用超时
pub fn timeout_lock(mutex: &Mutex<i32>) -> Option<i32> {
    let start = std::time::Instant::now();
    
    loop {
        if let Ok(guard) = mutex.try_lock() {
            return Some(*guard);
        }
        
        if start.elapsed() > Duration::from_secs(5) {
            return None; // 超时
        }
        
        thread::sleep(Duration::from_millis(10));
    }
}
```

### 2.4 异步安全编程

```rust
use tokio::sync::{RwLock, Semaphore};
use std::sync::Arc;

// ✅ 异步读写锁
pub struct AsyncDataStore {
    data: Arc<RwLock<HashMap<String, String>>>,
}

impl AsyncDataStore {
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn read(&self, key: &str) -> Option<String> {
        let data = self.data.read().await;
        data.get(key).cloned()
    }
    
    pub async fn write(&self, key: String, value: String) {
        let mut data = self.data.write().await;
        data.insert(key, value);
    }
}

// ✅ 使用信号量限制并发
pub struct RateLimiter {
    semaphore: Arc<Semaphore>,
}

impl RateLimiter {
    pub fn new(max_concurrent: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }
    
    pub async fn execute<F, T>(&self, f: F) -> T
    where
        F: FnOnce() -> T,
    {
        let _permit = self.semaphore.acquire().await.unwrap();
        f()
    }
}

// 使用示例
pub async fn rate_limited_requests() {
    let limiter = Arc::new(RateLimiter::new(10)); // 最多 10 个并发请求
    
    let mut handles = vec![];
    
    for i in 0..100 {
        let limiter = Arc::clone(&limiter);
        let handle = tokio::spawn(async move {
            limiter.execute(|| {
                println!("Processing request {}", i);
                std::thread::sleep(std::time::Duration::from_millis(100));
            }).await
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

**并发安全关键点**:

- ✅ 利用 Send + Sync 编译时检查
- ✅ 使用通道替代共享内存
- ✅ 原子操作实现无锁并发
- ✅ 固定锁顺序防止死锁
- ✅ 异步编程避免阻塞

---

## 3. 密码学安全实践

> **原则**: 永远不要实现自己的加密算法，使用经过审计的库

### 3.1 加密算法选择

#### 对称加密：AES-GCM

```rust
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};

// ✅ AES-256-GCM (推荐)
pub struct SecureEncryption {
    cipher: Aes256Gcm,
}

impl SecureEncryption {
    pub fn new(key: &[u8; 32]) -> Self {
        let cipher = Aes256Gcm::new(key.into());
        Self { cipher }
    }
    
    pub fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>, String> {
        let nonce = Nonce::from_slice(b"unique nonce"); // 实际使用时应随机生成
        
        self.cipher
            .encrypt(nonce, plaintext)
            .map_err(|e| format!("Encryption failed: {}", e))
    }
    
    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, String> {
        let nonce = Nonce::from_slice(b"unique nonce");
        
        self.cipher
            .decrypt(nonce, ciphertext)
            .map_err(|e| format!("Decryption failed: {}", e))
    }
}

// ✅ 安全的密钥生成
pub fn generate_key() -> [u8; 32] {
    let mut key = [0u8; 32];
    OsRng.fill_bytes(&mut key);
    key
}
```

#### 非对称加密：RSA

```rust
use rsa::{RsaPrivateKey, RsaPublicKey, Pkcs1v15Encrypt};
use rsa::pkcs8::{EncodePrivateKey, EncodePublicKey};
use rand::rngs::OsRng;

// ✅ RSA 加密/解密
pub struct RsaCrypto {
    private_key: RsaPrivateKey,
    public_key: RsaPublicKey,
}

impl RsaCrypto {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let mut rng = OsRng;
        let bits = 2048;
        let private_key = RsaPrivateKey::new(&mut rng, bits)?;
        let public_key = RsaPublicKey::from(&private_key);
        
        Ok(Self {
            private_key,
            public_key,
        })
    }
    
    pub fn encrypt(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let mut rng = OsRng;
        let enc_data = self.public_key.encrypt(&mut rng, Pkcs1v15Encrypt, data)?;
        Ok(enc_data)
    }
    
    pub fn decrypt(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let dec_data = self.private_key.decrypt(Pkcs1v15Encrypt, data)?;
        Ok(dec_data)
    }
}
```

### 3.2 密钥管理

```rust
use secrecy::{Secret, ExposeSecret};
use zeroize::Zeroizing;

// ✅ 安全的密钥存储
pub struct KeyStore {
    master_key: Secret<Vec<u8>>,
}

impl KeyStore {
    pub fn new(master_key: Vec<u8>) -> Self {
        Self {
            master_key: Secret::new(master_key),
        }
    }
    
    pub fn derive_key(&self, salt: &[u8]) -> Zeroizing<Vec<u8>> {
        use argon2::{Argon2, password_hash::{PasswordHasher, SaltString}};
        
        let salt_string = SaltString::encode_b64(salt).unwrap();
        let argon2 = Argon2::default();
        
        let password_hash = argon2
            .hash_password(self.master_key.expose_secret(), &salt_string)
            .unwrap();
        
        Zeroizing::new(password_hash.hash.unwrap().as_bytes().to_vec())
    }
}

// ✅ 密钥轮换
pub struct KeyRotation {
    current_key: Secret<Vec<u8>>,
    previous_key: Option<Secret<Vec<u8>>>,
}

impl KeyRotation {
    pub fn rotate(&mut self, new_key: Vec<u8>) {
        self.previous_key = Some(self.current_key.clone());
        self.current_key = Secret::new(new_key);
    }
    
    pub fn try_decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, String> {
        // 先尝试当前密钥
        if let Ok(plaintext) = decrypt_with_key(&self.current_key, ciphertext) {
            return Ok(plaintext);
        }
        
        // 回退到旧密钥
        if let Some(ref old_key) = self.previous_key {
            decrypt_with_key(old_key, ciphertext)
        } else {
            Err("Decryption failed".to_string())
        }
    }
}

fn decrypt_with_key(key: &Secret<Vec<u8>>, ciphertext: &[u8]) -> Result<Vec<u8>, String> {
    // 实际解密逻辑
    Ok(vec![])
}
```

### 3.3 安全哈希与签名

```rust
use sha2::{Sha256, Digest};
use hmac::{Hmac, Mac};

type HmacSha256 = Hmac<Sha256>;

// ✅ SHA-256 哈希
pub fn secure_hash(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

// ✅ HMAC 签名验证
pub fn create_hmac(key: &[u8], message: &[u8]) -> Vec<u8> {
    let mut mac = HmacSha256::new_from_slice(key).unwrap();
    mac.update(message);
    mac.finalize().into_bytes().to_vec()
}

pub fn verify_hmac(key: &[u8], message: &[u8], signature: &[u8]) -> bool {
    let mut mac = HmacSha256::new_from_slice(key).unwrap();
    mac.update(message);
    mac.verify_slice(signature).is_ok()
}

// ✅ 密码哈希（使用 Argon2）
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use argon2::password_hash::SaltString;

pub fn hash_password(password: &[u8]) -> Result<String, Box<dyn std::error::Error>> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    
    let password_hash = argon2
        .hash_password(password, &salt)?
        .to_string();
    
    Ok(password_hash)
}

pub fn verify_password(password: &[u8], hash: &str) -> Result<bool, Box<dyn std::error::Error>> {
    let parsed_hash = PasswordHash::new(hash)?;
    let argon2 = Argon2::default();
    
    Ok(argon2.verify_password(password, &parsed_hash).is_ok())
}
```

### 3.4 密码学库推荐

| 用途 | 推荐库 | 特点 |
|------|--------|------|
| **对称加密** | `aes-gcm`, `chacha20poly1305` | 认证加密，防篡改 |
| **非对称加密** | `rsa`, `ed25519-dalek` | RSA / Ed25519 |
| **哈希** | `sha2`, `sha3`, `blake3` | SHA-256 / SHA-3 / BLAKE3 |
| **密钥派生** | `argon2`, `pbkdf2` | 密码哈希，密钥派生 |
| **随机数** | `rand`, `getrandom` | 密码学安全随机数 |
| **安全比较** | `subtle` | 常量时间比较 |
| **密钥管理** | `secrecy`, `zeroize` | 密钥清零，安全存储 |

**密码学安全原则**:

- ✅ 使用经过审计的密码学库
- ✅ AES-256-GCM 用于对称加密
- ✅ RSA-2048+ 或 Ed25519 用于非对称
- ✅ Argon2 用于密码哈希
- ✅ 密钥及时清零（zeroize）
- ✅ 使用密码学安全随机数生成器

---

## 4. 网络安全防护

> **原则**: 默认安全，最小权限，纵深防御

### 4.1 TLS/SSL 安全配置

```rust
use tokio_rustls::{TlsAcceptor, rustls};
use std::sync::Arc;
use std::fs::File;
use std::io::BufReader;

// ✅ 安全的 TLS 服务器配置
pub fn create_tls_acceptor() -> Result<TlsAcceptor, Box<dyn std::error::Error>> {
    // 加载证书
    let cert_file = &mut BufReader::new(File::open("cert.pem")?);
    let key_file = &mut BufReader::new(File::open("key.pem")?);
    
    let cert_chain = rustls_pemfile::certs(cert_file)?
        .into_iter()
        .map(rustls::Certificate)
        .collect();
    
    let keys = rustls_pemfile::pkcs8_private_keys(key_file)?;
    let key = rustls::PrivateKey(keys[0].clone());
    
    // 创建 TLS 配置
    let config = rustls::ServerConfig::builder()
        .with_safe_default_cipher_suites()
        .with_safe_default_kx_groups()
        .with_safe_default_protocol_versions()?
        .with_no_client_auth()
        .with_single_cert(cert_chain, key)?;
    
    Ok(TlsAcceptor::from(Arc::new(config)))
}

// ✅ TLS 客户端配置
pub fn create_tls_connector() -> Result<tokio_rustls::TlsConnector, Box<dyn std::error::Error>> {
    let root_store = rustls::RootCertStore::empty();
    // 添加系统根证书
    
    let config = rustls::ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth();
    
    Ok(tokio_rustls::TlsConnector::from(Arc::new(config)))
}
```

### 4.2 HTTP 安全头

```rust
use axum::{
    http::{header, HeaderMap, StatusCode},
    response::{IntoResponse, Response},
};

// ✅ 添加安全头
pub fn add_security_headers(mut headers: HeaderMap) -> HeaderMap {
    // HSTS: 强制 HTTPS
    headers.insert(
        header::STRICT_TRANSPORT_SECURITY,
        "max-age=31536000; includeSubDomains".parse().unwrap(),
    );
    
    // CSP: 内容安全策略
    headers.insert(
        header::CONTENT_SECURITY_POLICY,
        "default-src 'self'; script-src 'self' 'unsafe-inline'".parse().unwrap(),
    );
    
    // X-Frame-Options: 防止点击劫持
    headers.insert(
        header::HeaderName::from_static("x-frame-options"),
        "DENY".parse().unwrap(),
    );
    
    // X-Content-Type-Options: 防止 MIME 嗅探
    headers.insert(
        header::HeaderName::from_static("x-content-type-options"),
        "nosniff".parse().unwrap(),
    );
    
    // X-XSS-Protection
    headers.insert(
        header::HeaderName::from_static("x-xss-protection"),
        "1; mode=block".parse().unwrap(),
    );
    
    // Referrer-Policy
    headers.insert(
        header::REFERER,
        "strict-origin-when-cross-origin".parse().unwrap(),
    );
    
    headers
}

// 使用中间件自动添加安全头
pub async fn security_headers_middleware(
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> Response {
    let mut response = next.run(req).await;
    
    let headers = response.headers_mut();
    *headers = add_security_headers(std::mem::take(headers));
    
    response
}
```

### 4.3 CSRF 防护

```rust
use axum::{
    extract::{State, Form},
    http::StatusCode,
    response::Html,
};
use rand::{thread_rng, Rng};
use std::sync::Arc;
use tokio::sync::RwLock;

// ✅ CSRF Token 管理
pub struct CsrfProtection {
    tokens: Arc<RwLock<HashMap<String, String>>>,
}

impl CsrfProtection {
    pub fn new() -> Self {
        Self {
            tokens: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn generate_token(&self, session_id: &str) -> String {
        let token: String = thread_rng()
            .sample_iter(&rand::distributions::Alphanumeric)
            .take(32)
            .map(char::from)
            .collect();
        
        let mut tokens = self.tokens.write().await;
        tokens.insert(session_id.to_string(), token.clone());
        
        token
    }
    
    pub async fn verify_token(&self, session_id: &str, token: &str) -> bool {
        let tokens = self.tokens.read().await;
        tokens.get(session_id) == Some(&token.to_string())
    }
    
    pub async fn remove_token(&self, session_id: &str) {
        let mut tokens = self.tokens.write().await;
        tokens.remove(session_id);
    }
}

// 使用示例
#[derive(serde::Deserialize)]
pub struct FormData {
    csrf_token: String,
    data: String,
}

pub async fn handle_form_submission(
    State(csrf): State<Arc<CsrfProtection>>,
    Form(form): Form<FormData>,
) -> Result<String, StatusCode> {
    let session_id = "user_session_id"; // 从会话中获取
    
    if !csrf.verify_token(session_id, &form.csrf_token).await {
        return Err(StatusCode::FORBIDDEN);
    }
    
    csrf.remove_token(session_id).await;
    
    // 处理表单数据
    Ok("Success".to_string())
}
```

### 4.4 DDoS 防护

```rust
use std::collections::HashMap;
use std::net::IpAddr;
use std::time::{Duration, Instant};
use tokio::sync::Mutex;

// ✅ 速率限制
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<IpAddr, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }
    
    pub async fn check_rate_limit(&self, ip: IpAddr) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        let ip_requests = requests.entry(ip).or_insert_with(Vec::new);
        
        // 清理过期的请求
        ip_requests.retain(|&time| now.duration_since(time) < self.window);
        
        if ip_requests.len() >= self.max_requests {
            return false; // 超过速率限制
        }
        
        ip_requests.push(now);
        true
    }
}

// 使用示例
pub async fn rate_limit_middleware(
    State(limiter): State<Arc<RateLimiter>>,
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> Result<Response, StatusCode> {
    let ip = extract_ip(&req);
    
    if !limiter.check_rate_limit(ip).await {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    
    Ok(next.run(req).await)
}

fn extract_ip(req: &axum::extract::Request) -> IpAddr {
    // 从请求中提取 IP 地址
    // 注意：生产环境需要处理代理头（X-Forwarded-For）
    "127.0.0.1".parse().unwrap()
}
```

**网络安全关键点**:

- ✅ 强制使用 HTTPS (HSTS)
- ✅ 配置安全的 TLS 参数
- ✅ 添加全套 HTTP 安全头
- ✅ 实施 CSRF 防护
- ✅ 实施速率限制防止 DDoS
- ✅ 输入验证和输出编码

---

## 5. 输入验证与过滤

> **原则**: 永远不要信任用户输入

### 5.1 输入验证策略

```rust
use validator::{Validate, ValidationError};
use regex::Regex;

// ✅ 使用 validator 库进行验证
#[derive(Debug, Validate, serde::Deserialize)]
pub struct UserInput {
    #[validate(length(min = 3, max = 20))]
    pub username: String,
    
    #[validate(email)]
    pub email: String,
    
    #[validate(range(min = 18, max = 120))]
    pub age: u8,
    
    #[validate(custom = "validate_password")]
    pub password: String,
}

fn validate_password(password: &str) -> Result<(), ValidationError> {
    let has_uppercase = password.chars().any(|c| c.is_uppercase());
    let has_lowercase = password.chars().any(|c| c.is_lowercase());
    let has_digit = password.chars().any(|c| c.is_ascii_digit());
    let has_special = password.chars().any(|c| "!@#$%^&*".contains(c));
    
    if password.len() < 8 {
        return Err(ValidationError::new("password_too_short"));
    }
    
    if !(has_uppercase && has_lowercase && has_digit && has_special) {
        return Err(ValidationError::new("password_too_weak"));
    }
    
    Ok(())
}

// 使用示例
pub fn validate_user_input(input: &UserInput) -> Result<(), String> {
    input.validate()
        .map_err(|e| format!("Validation error: {:?}", e))
}
```

### 5.2 SQL 注入防护

```rust
use sqlx::{PgPool, query, query_as};

// ✅ 使用参数化查询（永远不要拼接 SQL）
pub async fn safe_query(pool: &PgPool, user_id: i64) -> Result<User, sqlx::Error> {
    let user = query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id)
        .fetch_one(pool)
        .await?;
    
    Ok(user)
}

// ✅ 使用 ORM（如 diesel）
use diesel::prelude::*;
use diesel::pg::PgConnection;

pub fn diesel_safe_query(conn: &mut PgConnection, user_id: i64) -> Result<User, diesel::result::Error> {
    use crate::schema::users::dsl::*;
    
    users
        .filter(id.eq(user_id))
        .first::<User>(conn)
}

// ❌ 永远不要这样做（SQL 注入漏洞）
/*
pub async fn unsafe_query(pool: &PgPool, user_input: &str) -> Result<Vec<User>, sqlx::Error> {
    let sql = format!("SELECT * FROM users WHERE name = '{}'", user_input);
    // 如果 user_input = "' OR '1'='1"，将返回所有用户！
    let users = sqlx::query_as(&sql).fetch_all(pool).await?;
    Ok(users)
}
*/
```

### 5.3 XSS 防护

```rust
use ammonia::clean;
use html_escape::encode_text;

// ✅ HTML 实体编码
pub fn escape_html(input: &str) -> String {
    encode_text(input).to_string()
}

// ✅ 使用白名单过滤 HTML
pub fn sanitize_html(input: &str) -> String {
    clean(input)
}

// ✅ 安全的模板引擎（自动转义）
use askama::Template;

#[derive(Template)]
#[template(path = "user.html")]
pub struct UserTemplate {
    pub name: String, // 自动转义
}

// user.html:
// <h1>Hello, {{ name }}!</h1>
// 即使 name = "<script>alert('XSS')</script>"
// 也会被转义为 &lt;script&gt;alert('XSS')&lt;/script&gt;
```

### 5.4 命令注入防护

```rust
use std::process::Command;

// ✅ 使用参数数组，避免 shell 解释
pub fn safe_command_execution(filename: &str) -> Result<String, std::io::Error> {
    // 验证输入
    if !filename.chars().all(|c| c.is_alphanumeric() || c == '.' || c == '-') {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Invalid filename",
        ));
    }
    
    // 使用参数数组，不通过 shell
    let output = Command::new("cat")
        .arg(filename)
        .output()?;
    
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

// ❌ 永远不要这样做（命令注入漏洞）
/*
pub fn unsafe_command(user_input: &str) -> Result<String, std::io::Error> {
    let command = format!("cat {}", user_input);
    // 如果 user_input = "file.txt; rm -rf /", 将执行删除命令！
    let output = Command::new("sh")
        .arg("-c")
        .arg(&command)
        .output()?;
    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
*/
```

**输入验证原则**:

- ✅ 白名单验证优于黑名单
- ✅ 使用参数化查询防止 SQL 注入
- ✅ HTML 实体编码防止 XSS
- ✅ 避免 shell 解释防止命令注入
- ✅ 验证文件路径防止路径遍历
- ✅ 限制输入长度防止 DoS

---

## 6. 安全配置管理

> **原则**: 配置与代码分离，密钥加密存储

### 6.1 配置文件安全

```rust
use serde::{Deserialize, Serialize};
use std::fs;

// ✅ 分离敏感配置
#[derive(Debug, Deserialize)]
pub struct Config {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    #[serde(skip_serializing)] // 防止意外序列化
    pub secrets: Secrets,
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub database: String,
}

#[derive(Debug, Deserialize)]
pub struct Secrets {
    pub database_password: String,
    pub jwt_secret: String,
    pub api_key: String,
}

impl Config {
    pub fn load() -> Result<Self, Box<dyn std::error::Error>> {
        // 从环境或配置文件加载
        let config_file = fs::read_to_string("config.toml")?;
        let config: Config = toml::from_str(&config_file)?;
        
        Ok(config)
    }
}
```

### 6.2 环境变量管理

```rust
use dotenv::dotenv;
use std::env;

// ✅ 使用 dotenv 管理环境变量
pub struct Environment {
    pub database_url: String,
    pub jwt_secret: String,
    pub redis_url: String,
}

impl Environment {
    pub fn load() -> Result<Self, String> {
        dotenv().ok(); // 加载 .env 文件
        
        Ok(Self {
            database_url: env::var("DATABASE_URL")
                .map_err(|_| "DATABASE_URL not set")?,
            jwt_secret: env::var("JWT_SECRET")
                .map_err(|_| "JWT_SECRET not set")?,
            redis_url: env::var("REDIS_URL")
                .map_err(|_| "REDIS_URL not set")?,
        })
    }
}

// .env 文件（不要提交到版本控制）
// DATABASE_URL=postgres://user:pass@localhost/db
// JWT_SECRET=your_secret_key_here
// REDIS_URL=redis://localhost:6379
```

### 6.3 密钥与凭证管理

```rust
use aws_sdk_secretsmanager::Client;
use tokio;

// ✅ 使用 AWS Secrets Manager
pub async fn load_secret_from_aws(secret_name: &str) -> Result<String, Box<dyn std::error::Error>> {
    let config = aws_config::load_from_env().await;
    let client = Client::new(&config);
    
    let response = client
        .get_secret_value()
        .secret_id(secret_name)
        .send()
        .await?;
    
    let secret = response.secret_string()
        .ok_or("Secret not found")?;
    
    Ok(secret.to_string())
}

// ✅ 使用 HashiCorp Vault
use vaultrs::client::{VaultClient, VaultClientSettingsBuilder};

pub async fn load_secret_from_vault(
    path: &str,
    key: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = VaultClient::new(
        VaultClientSettingsBuilder::default()
            .address("http://localhost:8200")
            .token("vault_token")
            .build()?,
    )?;
    
    let secret: HashMap<String, String> = vaultrs::kv2::read(&client, "secret", path).await?;
    
    secret.get(key)
        .cloned()
        .ok_or_else(|| "Key not found".into())
}
```

**配置安全原则**:

- ✅ 配置与代码分离
- ✅ 敏感配置使用环境变量
- ✅ 密钥使用密钥管理服务
- ✅ .env 文件不提交到版本控制
- ✅ 生产环境配置加密存储
- ✅ 定期轮换密钥

---

## 7. 安全审计与监控

> **原则**: 记录一切，监控关键指标，快速响应

### 7.1 日志审计

```rust
use tracing::{info, warn, error, instrument};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// ✅ 结构化日志
pub fn init_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

// ✅ 审计日志
#[instrument]
pub async fn audit_user_action(user_id: u64, action: &str, result: &str) {
    info!(
        user_id = user_id,
        action = action,
        result = result,
        timestamp = chrono::Utc::now().to_rfc3339(),
        "User action audit"
    );
}

// ✅ 安全事件日志
pub fn log_security_event(event_type: &str, details: serde_json::Value) {
    warn!(
        event_type = event_type,
        details = ?details,
        "Security event detected"
    );
}

// 使用示例
pub async fn login_attempt(username: &str, success: bool) {
    let event_type = if success { "login_success" } else { "login_failure" };
    
    audit_user_action(0, "login", event_type).await;
    
    if !success {
        log_security_event(
            "failed_login",
            serde_json::json!({
                "username": username,
                "ip": "127.0.0.1",
                "timestamp": chrono::Utc::now(),
            }),
        );
    }
}
```

### 7.2 安全监控指标

```rust
use prometheus::{Counter, Histogram, Registry};
use lazy_static::lazy_static;

lazy_static! {
    // ✅ 认证失败计数
    pub static ref AUTH_FAILURES: Counter = Counter::new(
        "auth_failures_total",
        "Total number of authentication failures"
    ).unwrap();
    
    // ✅ API 请求延迟
    pub static ref REQUEST_DURATION: Histogram = Histogram::with_opts(
        prometheus::HistogramOpts::new(
            "request_duration_seconds",
            "Request duration in seconds"
        )
    ).unwrap();
    
    // ✅ 速率限制触发
    pub static ref RATE_LIMIT_HITS: Counter = Counter::new(
        "rate_limit_hits_total",
        "Total number of rate limit hits"
    ).unwrap();
}

pub fn register_metrics(registry: &Registry) -> Result<(), Box<dyn std::error::Error>> {
    registry.register(Box::new(AUTH_FAILURES.clone()))?;
    registry.register(Box::new(REQUEST_DURATION.clone()))?;
    registry.register(Box::new(RATE_LIMIT_HITS.clone()))?;
    Ok(())
}

// 使用示例
pub async fn handle_auth(username: &str, password: &str) -> Result<(), String> {
    let timer = REQUEST_DURATION.start_timer();
    
    match authenticate(username, password).await {
        Ok(_) => {
            timer.observe_duration();
            Ok(())
        }
        Err(e) => {
            AUTH_FAILURES.inc();
            timer.observe_duration();
            Err(e)
        }
    }
}
```

### 7.3 入侵检测

```rust
use std::collections::HashMap;
use std::net::IpAddr;

// ✅ 异常检测
pub struct AnomalyDetector {
    failed_attempts: HashMap<IpAddr, u32>,
    threshold: u32,
}

impl AnomalyDetector {
    pub fn new(threshold: u32) -> Self {
        Self {
            failed_attempts: HashMap::new(),
            threshold,
        }
    }
    
    pub fn record_failed_attempt(&mut self, ip: IpAddr) -> bool {
        let count = self.failed_attempts.entry(ip).or_insert(0);
        *count += 1;
        
        if *count >= self.threshold {
            self.trigger_alert(ip, *count);
            true // 触发警报
        } else {
            false
        }
    }
    
    pub fn reset_attempts(&mut self, ip: IpAddr) {
        self.failed_attempts.remove(&ip);
    }
    
    fn trigger_alert(&self, ip: IpAddr, count: u32) {
        error!(
            "SECURITY ALERT: IP {} has {} failed login attempts",
            ip, count
        );
        
        // 发送告警到监控系统
        // send_alert_to_slack(&format!("Potential brute force attack from {}", ip));
    }
}

// ✅ IP 封禁
pub struct IpBlocklist {
    blocked_ips: HashMap<IpAddr, Instant>,
    block_duration: Duration,
}

impl IpBlocklist {
    pub fn block_ip(&mut self, ip: IpAddr) {
        self.blocked_ips.insert(ip, Instant::now());
        info!("IP {} has been blocked", ip);
    }
    
    pub fn is_blocked(&mut self, ip: IpAddr) -> bool {
        if let Some(&blocked_time) = self.blocked_ips.get(&ip) {
            if Instant::now().duration_since(blocked_time) < self.block_duration {
                return true;
            } else {
                self.blocked_ips.remove(&ip); // 解除封禁
            }
        }
        false
    }
}
```

**审计监控原则**:

- ✅ 记录所有认证和授权事件
- ✅ 记录所有敏感操作
- ✅ 监控异常行为模式
- ✅ 设置告警阈值
- ✅ 定期审查日志
- ✅ 日志安全存储（防篡改）

---

## 8. 安全工具集成

> **原则**: 自动化安全检查，CI/CD 集成

### 8.1 静态分析工具

#### Clippy

```bash
# 启用所有安全相关的 lint
cargo clippy -- \
  -W clippy::all \
  -W clippy::pedantic \
  -W clippy::nursery \
  -W clippy::cargo
```

```toml
# clippy.toml
disallowed-methods = [
    # 禁止不安全的字符串操作
    { path = "std::str::from_utf8_unchecked", reason = "use from_utf8 instead" },
    # 禁止不安全的 unwrap
    { path = "std::option::Option::unwrap", reason = "use ? or unwrap_or instead" },
    { path = "std::result::Result::unwrap", reason = "use ? or unwrap_or instead" },
]
```

#### RustSec Cargo Audit

```bash
# 检查已知漏洞
cargo install cargo-audit
cargo audit

# 自动修复
cargo audit fix
```

```toml
# .cargo/audit.toml
[advisories]
unmaintained = "deny"
unsound = "deny"
yanked = "deny"
```

### 8.2 动态分析工具

#### Miri (unsafe 代码检查)

```bash
# 安装 Miri
rustup +nightly component add miri

# 运行 Miri
cargo +nightly miri test
```

#### AddressSanitizer

```bash
# 检测内存错误
RUSTFLAGS="-Z sanitizer=address" cargo +nightly run
```

#### ThreadSanitizer

```bash
# 检测数据竞争
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly run
```

### 8.3 依赖扫描

```bash
# cargo-deny: 依赖安全检查
cargo install cargo-deny

# 检查依赖
cargo deny check

# cargo-outdated: 检查过时依赖
cargo install cargo-outdated
cargo outdated
```

```toml
# deny.toml
[advisories]
db-path = "~/.cargo/advisory-db"
db-urls = ["https://github.com/rustsec/advisory-db"]
vulnerability = "deny"
unmaintained = "warn"
unsound = "warn"
yanked = "deny"

[licenses]
unlicensed = "deny"
allow = [
    "MIT",
    "Apache-2.0",
    "BSD-3-Clause",
]
deny = [
    "GPL-3.0",
]
```

**CI/CD 集成**:

```yaml
# .github/workflows/security.yml
name: Security Audit
on: [push, pull_request]

jobs:
  security_audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          
      - name: Run Cargo Audit
        uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Run Cargo Deny
        uses: EmbarkStudios/cargo-deny-action@v1
        
      - name: Run Clippy
        run: cargo clippy -- -W clippy::all -W clippy::pedantic
```

---

## 9. 安全威胁模型

> **方法**: STRIDE 威胁模型

### 9.1 常见威胁类型

| 威胁 | 描述 | Rust 防护 |
|------|------|----------|
| **S**poofing (欺骗) | 伪造身份 | JWT、OAuth2 |
| **T**ampering (篡改) | 修改数据 | HMAC、数字签名 |
| **R**epudiation (否认) | 否认操作 | 审计日志 |
| **I**nformation Disclosure (信息泄露) | 敏感数据泄露 | 加密、访问控制 |
| **D**enial of Service (拒绝服务) | 系统不可用 | 速率限制、资源限制 |
| **E**levation of Privilege (权限提升) | 非法提权 | RBAC、最小权限 |

### 9.2 威胁分析方法

```rust
// ✅ 威胁建模示例
pub struct ThreatModel {
    pub asset: String,          // 资产：用户数据
    pub threat: String,         // 威胁：SQL 注入
    pub vulnerability: String,  // 漏洞：字符串拼接 SQL
    pub impact: String,         // 影响：数据泄露
    pub likelihood: u8,         // 可能性：1-10
    pub severity: u8,           // 严重性：1-10
    pub mitigation: String,     // 缓解：参数化查询
}

impl ThreatModel {
    pub fn risk_score(&self) -> u8 {
        (self.likelihood * self.severity) / 10
    }
}
```

### 9.3 威胁应对策略

**防御层级**:

```text
1. 预防 (Prevention)
   ├── 输入验证
   ├── 输出编码
   └── 安全配置

2. 检测 (Detection)
   ├── 日志审计
   ├── 异常检测
   └── 入侵检测

3. 响应 (Response)
   ├── 告警机制
   ├── 自动封禁
   └── 应急预案

4. 恢复 (Recovery)
   ├── 备份恢复
   ├── 灾难恢复
   └── 事后分析
```

---

## 10. 生产环境安全清单

### 10.1 开发阶段

- [ ] ✅ 使用最新稳定版 Rust (1.90+)
- [ ] ✅ 启用所有安全 Clippy lint
- [ ] ✅ 运行 cargo audit 检查依赖漏洞
- [ ] ✅ 使用 cargo deny 检查许可证和依赖
- [ ] ✅ 编写安全测试用例
- [ ] ✅ 代码审查关注安全问题
- [ ] ✅ 最小化 unsafe 代码使用
- [ ] ✅ 使用 cargo-fuzz 进行模糊测试

### 10.2 部署阶段

- [ ] ✅ 使用 TLS 1.3 加密传输
- [ ] ✅ 配置 HTTP 安全头
- [ ] ✅ 实施速率限制和 CSRF 防护
- [ ] ✅ 密钥和凭证使用密钥管理服务
- [ ] ✅ 最小化容器镜像（distroless）
- [ ] ✅ 使用非 root 用户运行
- [ ] ✅ 配置防火墙规则
- [ ] ✅ 启用 SELinux/AppArmor

### 10.3 运行阶段

- [ ] ✅ 启用结构化日志和审计
- [ ] ✅ 配置监控告警（Prometheus/Grafana）
- [ ] ✅ 定期备份和灾难恢复演练
- [ ] ✅ 定期更新依赖和安全补丁
- [ ] ✅ 定期轮换密钥和证书
- [ ] ✅ 定期安全审计和渗透测试
- [ ] ✅ 建立安全事件响应流程
- [ ] ✅ 培训团队安全意识

---

## 📚 延伸阅读

**深度分析**:

- [analysis/04_security_comprehensive_analysis.md](../analysis/rust190_ecosystem/04_security_analysis/security_comprehensive_analysis.md) - 安全威胁模型和详细分析

**相关文档**:

- [4.3 形式化验证方法](4.3_形式化验证方法.md) - 使用 Kani、Prusti 进行安全验证
- [3.4 性能基准测试报告](../references/3.4_性能基准测试报告.md) - 安全措施的性能影响
- [2.1 数据库集成指南](../guides/2.1_数据库集成指南.md) - 数据库安全实践

---

## 📖 参考资源

**官方资源**:

- [Rust Security Guidelines](https://rust-lang.github.io/api-guidelines/safety.html)
- [Rust Secure Code Working Group](https://github.com/rust-secure-code)
- [RustSec Advisory Database](https://rustsec.org/)

**推荐书籍**:

- "Rust Security Programming" - 实战安全编程
- "The Rust Programming Language (TRPL)" - Chapter 19: Unsafe Rust

**安全库**:

- [secrecy](https://crates.io/crates/secrecy) - 密钥安全管理
- [zeroize](https://crates.io/crates/zeroize) - 内存清零
- [subtle](https://crates.io/crates/subtle) - 常量时间比较
- [ring](https://crates.io/crates/ring) - 密码学库

**工具**:

- [cargo-audit](https://crates.io/crates/cargo-audit) - 漏洞扫描
- [cargo-deny](https://crates.io/crates/cargo-deny) - 依赖检查
- [cargo-fuzz](https://crates.io/crates/cargo-fuzz) - 模糊测试

---

**文档创建**: 2025-10-22  
**Rust 版本**: 1.90+  
**文档版本**: v1.0  
**维护**: Rust 安全工作组

**🔒 记住：安全是一个持续的过程，而不是一次性的任务！**
