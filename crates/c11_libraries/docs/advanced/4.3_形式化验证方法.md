# 4.3 Rust 形式化验证方法 (2025-10-21)

> **文档定位**: Rust 形式化验证工具链与最佳实践  
> **适用人群**: 安全关键系统开发者、形式化方法研究者  
> **关联文档**: [4.1 进阶主题集](4.1_进阶主题集.md) | [4.2 行业应用](4.2_跨行业应用分析.md) | [1.1 主索引](../1.1_主索引导航.md)

## 📊 目录

- [4.3 Rust 形式化验证方法 (2025-10-21)](#43-rust-形式化验证方法-2025-10-21)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [4.3.1 形式化验证概述](#431-形式化验证概述)
    - [4.3.1.1 什么是形式化验证](#4311-什么是形式化验证)
    - [4.3.1.2 为什么需要形式化验证](#4312-为什么需要形式化验证)
    - [4.3.1.3 形式化验证方法分类](#4313-形式化验证方法分类)
    - [4.3.1.4 Rust 与形式化验证](#4314-rust-与形式化验证)
  - [4.3.2 Kani 验证器](#432-kani-验证器)
    - [4.3.2.1 Kani 简介](#4321-kani-简介)
    - [4.3.2.2 安装与配置](#4322-安装与配置)
    - [4.3.2.3 基础验证示例](#4323-基础验证示例)
    - [4.3.2.4 高级验证技术](#4324-高级验证技术)
  - [4.3.3 Prusti 验证工具](#433-prusti-验证工具)
    - [4.3.3.1 Prusti 架构](#4331-prusti-架构)
    - [4.3.3.2 规格说明语言](#4332-规格说明语言)
    - [4.3.3.3 不变量与断言](#4333-不变量与断言)
    - [4.3.3.4 函数契约](#4334-函数契约)
  - [4.3.4 MIRAI 抽象解释](#434-mirai-抽象解释)
    - [4.3.4.1 MIRAI 原理](#4341-mirai-原理)
    - [4.3.4.2 使用 MIRAI](#4342-使用-mirai)
    - [4.3.4.3 标签传播](#4343-标签传播)
    - [4.3.4.4 数据流分析](#4344-数据流分析)
  - [4.3.5 Creusot 演绎验证](#435-creusot-演绎验证)
    - [4.3.5.1 Creusot 简介](#4351-creusot-简介)
    - [4.3.5.2 Why3 集成](#4352-why3-集成)
    - [4.3.5.3 证明策略](#4353-证明策略)
    - [4.3.5.4 复杂数据结构验证](#4354-复杂数据结构验证)
  - [4.3.6 模型检测方法](#436-模型检测方法)
    - [4.3.6.1 TLA+ 与 Rust](#4361-tla-与-rust)
    - [4.3.6.2 并发协议验证](#4362-并发协议验证)
    - [4.3.6.3 分布式系统验证](#4363-分布式系统验证)
    - [4.3.6.4 Loom 并发测试](#4364-loom-并发测试)
  - [4.3.7 符号执行](#437-符号执行)
    - [4.3.7.1 符号执行原理](#4371-符号执行原理)
    - [4.3.7.2 KLEE 与 Rust](#4372-klee-与-rust)
    - [4.3.7.3 路径爆炸问题](#4373-路径爆炸问题)
    - [4.3.7.4 约束求解](#4374-约束求解)
  - [4.3.8 安全关键系统实践](#438-安全关键系统实践)
    - [4.3.8.1 航空航天应用](#4381-航空航天应用)
    - [4.3.8.2 医疗设备](#4382-医疗设备)
    - [4.3.8.3 金融系统](#4383-金融系统)
    - [4.3.8.4 工业控制](#4384-工业控制)
  - [4.3.9 验证最佳实践](#439-验证最佳实践)
    - [4.3.9.1 验证策略](#4391-验证策略)
    - [4.3.9.2 性能优化](#4392-性能优化)
    - [4.3.9.3 可维护性](#4393-可维护性)
    - [4.3.9.4 持续集成](#4394-持续集成)
  - [4.3.10 形式化验证理论基础](#4310-形式化验证理论基础)
    - [4.3.10.1 类型系统的形式化](#43101-类型系统的形式化)
      - [Rust 类型系统的数学模型](#rust-类型系统的数学模型)
      - [生命周期的形式化](#生命周期的形式化)
    - [4.3.10.2 霍尔逻辑与程序验证](#43102-霍尔逻辑与程序验证)
      - [霍尔三元组 (Hoare Triple)](#霍尔三元组-hoare-triple)
      - [Rust 中的霍尔逻辑应用](#rust-中的霍尔逻辑应用)
      - [循环不变量 (Loop Invariant)](#循环不变量-loop-invariant)
    - [4.3.10.3 分离逻辑 (Separation Logic)](#43103-分离逻辑-separation-logic)
      - [分离逻辑基本概念](#分离逻辑基本概念)
      - [Rust 中的分离逻辑应用](#rust-中的分离逻辑应用)
      - [所有权转移的分离逻辑证明](#所有权转移的分离逻辑证明)
    - [4.3.10.4 RustBelt：Rust 安全性的形式化证明](#43104-rustbeltrust-安全性的形式化证明)
      - [RustBelt 核心定理](#rustbelt-核心定理)
      - [所有权的形式化证明](#所有权的形式化证明)
    - [4.3.10.5 模型检查理论](#43105-模型检查理论)
      - [状态空间探索](#状态空间探索)
      - [Rust 程序的状态空间](#rust-程序的状态空间)
    - [4.3.10.6 时序逻辑 (Temporal Logic)](#43106-时序逻辑-temporal-logic)
      - [线性时序逻辑 (LTL)](#线性时序逻辑-ltl)
    - [4.3.10.7 可达性分析](#43107-可达性分析)
      - [不变量推导](#不变量推导)
    - [4.3.10.8 形式化方法的局限性与实践建议](#43108-形式化方法的局限性与实践建议)
      - [理论局限](#理论局限)
      - [实践建议](#实践建议)
  - [4.3.11 参考资源](#4311-参考资源)

**最后更新**: 2025-10-21  
**Rust 版本**: 1.90  
**文档状态**: ✅ 生产就绪

---

## 📋 目录

- [4.3 Rust 形式化验证方法 (2025-10-21)](#43-rust-形式化验证方法-2025-10-21)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [4.3.1 形式化验证概述](#431-形式化验证概述)
    - [4.3.1.1 什么是形式化验证](#4311-什么是形式化验证)
    - [4.3.1.2 为什么需要形式化验证](#4312-为什么需要形式化验证)
    - [4.3.1.3 形式化验证方法分类](#4313-形式化验证方法分类)
    - [4.3.1.4 Rust 与形式化验证](#4314-rust-与形式化验证)
  - [4.3.2 Kani 验证器](#432-kani-验证器)
    - [4.3.2.1 Kani 简介](#4321-kani-简介)
    - [4.3.2.2 安装与配置](#4322-安装与配置)
    - [4.3.2.3 基础验证示例](#4323-基础验证示例)
    - [4.3.2.4 高级验证技术](#4324-高级验证技术)
  - [4.3.3 Prusti 验证工具](#433-prusti-验证工具)
    - [4.3.3.1 Prusti 架构](#4331-prusti-架构)
    - [4.3.3.2 规格说明语言](#4332-规格说明语言)
    - [4.3.3.3 不变量与断言](#4333-不变量与断言)
    - [4.3.3.4 函数契约](#4334-函数契约)
  - [4.3.4 MIRAI 抽象解释](#434-mirai-抽象解释)
    - [4.3.4.1 MIRAI 原理](#4341-mirai-原理)
    - [4.3.4.2 使用 MIRAI](#4342-使用-mirai)
    - [4.3.4.3 标签传播](#4343-标签传播)
    - [4.3.4.4 数据流分析](#4344-数据流分析)
  - [4.3.5 Creusot 演绎验证](#435-creusot-演绎验证)
    - [4.3.5.1 Creusot 简介](#4351-creusot-简介)
    - [4.3.5.2 Why3 集成](#4352-why3-集成)
    - [4.3.5.3 证明策略](#4353-证明策略)
    - [4.3.5.4 复杂数据结构验证](#4354-复杂数据结构验证)
  - [4.3.6 模型检测方法](#436-模型检测方法)
    - [4.3.6.1 TLA+ 与 Rust](#4361-tla-与-rust)
    - [4.3.6.2 并发协议验证](#4362-并发协议验证)
    - [4.3.6.3 分布式系统验证](#4363-分布式系统验证)
    - [4.3.6.4 Loom 并发测试](#4364-loom-并发测试)
  - [4.3.7 符号执行](#437-符号执行)
    - [4.3.7.1 符号执行原理](#4371-符号执行原理)
    - [4.3.7.2 KLEE 与 Rust](#4372-klee-与-rust)
    - [4.3.7.3 路径爆炸问题](#4373-路径爆炸问题)
    - [4.3.7.4 约束求解](#4374-约束求解)
  - [4.3.8 安全关键系统实践](#438-安全关键系统实践)
    - [4.3.8.1 航空航天应用](#4381-航空航天应用)
    - [4.3.8.2 医疗设备](#4382-医疗设备)
    - [4.3.8.3 金融系统](#4383-金融系统)
    - [4.3.8.4 工业控制](#4384-工业控制)
  - [4.3.9 验证最佳实践](#439-验证最佳实践)
    - [4.3.9.1 验证策略](#4391-验证策略)
    - [4.3.9.2 性能优化](#4392-性能优化)
    - [4.3.9.3 可维护性](#4393-可维护性)
    - [4.3.9.4 持续集成](#4394-持续集成)
  - [4.3.10 形式化验证理论基础](#4310-形式化验证理论基础)
    - [4.3.10.1 类型系统的形式化](#43101-类型系统的形式化)
      - [Rust 类型系统的数学模型](#rust-类型系统的数学模型)
      - [生命周期的形式化](#生命周期的形式化)
    - [4.3.10.2 霍尔逻辑与程序验证](#43102-霍尔逻辑与程序验证)
      - [霍尔三元组 (Hoare Triple)](#霍尔三元组-hoare-triple)
      - [Rust 中的霍尔逻辑应用](#rust-中的霍尔逻辑应用)
      - [循环不变量 (Loop Invariant)](#循环不变量-loop-invariant)
    - [4.3.10.3 分离逻辑 (Separation Logic)](#43103-分离逻辑-separation-logic)
      - [分离逻辑基本概念](#分离逻辑基本概念)
      - [Rust 中的分离逻辑应用](#rust-中的分离逻辑应用)
      - [所有权转移的分离逻辑证明](#所有权转移的分离逻辑证明)
    - [4.3.10.4 RustBelt：Rust 安全性的形式化证明](#43104-rustbeltrust-安全性的形式化证明)
      - [RustBelt 核心定理](#rustbelt-核心定理)
      - [所有权的形式化证明](#所有权的形式化证明)
    - [4.3.10.5 模型检查理论](#43105-模型检查理论)
      - [状态空间探索](#状态空间探索)
      - [Rust 程序的状态空间](#rust-程序的状态空间)
    - [4.3.10.6 时序逻辑 (Temporal Logic)](#43106-时序逻辑-temporal-logic)
      - [线性时序逻辑 (LTL)](#线性时序逻辑-ltl)
    - [4.3.10.7 可达性分析](#43107-可达性分析)
      - [不变量推导](#不变量推导)
    - [4.3.10.8 形式化方法的局限性与实践建议](#43108-形式化方法的局限性与实践建议)
      - [理论局限](#理论局限)
      - [实践建议](#实践建议)
  - [4.3.11 参考资源](#4311-参考资源)

---

## 4.3.1 形式化验证概述

### 4.3.1.1 什么是形式化验证

**定义**:

形式化验证是使用数学方法证明程序正确性的技术，不同于传统测试只能验证特定输入，形式化验证能够证明程序对所有可能输入都满足规格说明。

**核心概念**:

1. **规格说明 (Specification)**: 用形式化语言描述程序应该做什么
2. **证明 (Proof)**: 数学证明程序实现满足规格
3. **完全性 (Soundness)**: 如果证明通过，程序一定正确
4. **完备性 (Completeness)**: 如果程序正确，证明一定能通过

### 4.3.1.2 为什么需要形式化验证

**传统测试的局限性**:

```rust
// 测试只能覆盖有限案例
#[cfg(test)]
mod tests {
    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
        assert_eq!(add(0, 0), 0);
        assert_eq!(add(-1, 1), 0);
        // 无法测试所有可能的 i32 组合
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b // 可能溢出！
}
```

**形式化验证的优势**:

```rust
// 使用 Kani 验证所有可能的输入
#[cfg(kani)]
#[kani::proof]
fn verify_add() {
    let a: i32 = kani::any();
    let b: i32 = kani::any();
    
    if let Some(result) = a.checked_add(b) {
        assert!(result >= a || b < 0);
        assert!(result >= b || a < 0);
    }
}
```

**适用场景**:

1. ✅ **安全关键系统**: 航空、医疗、金融
2. ✅ **密码学**: 加密算法正确性
3. ✅ **并发系统**: 无数据竞争、死锁
4. ✅ **内存安全**: 无越界、无悬垂指针

### 4.3.1.3 形式化验证方法分类

**1. 模型检测 (Model Checking)**:

- 穷举所有可能状态
- 适用于有限状态系统
- 工具: TLA+, SPIN

**2. 定理证明 (Theorem Proving)**:

- 交互式证明
- 适用于复杂数学证明
- 工具: Coq, Isabelle/HOL

**3. 符号执行 (Symbolic Execution)**:

- 符号化执行路径
- 发现程序错误
- 工具: KLEE, angr

**4. 抽象解释 (Abstract Interpretation)**:

- 静态分析
- 快速但不完全
- 工具: MIRAI

**5. 有界模型检测 (Bounded Model Checking)**:

- SAT/SMT 求解器
- 平衡完全性和性能
- 工具: Kani, CBMC

### 4.3.1.4 Rust 与形式化验证

**Rust 的优势**:

1. **类型安全**: 类型系统已经是一种轻量级验证
2. **所有权模型**: 自动防止内存错误
3. **无空指针**: 消除一大类错误
4. **显式错误处理**: `Result` 和 `Option`

**仍需验证的**:

1. **算术溢出**: `i32::MAX + 1` 会 panic
2. **逻辑错误**: 算法实现错误
3. **并发错误**: 数据竞争、死锁
4. **unsafe 代码**: 绕过类型系统

---

## 4.3.2 Kani 验证器

### 4.3.2.1 Kani 简介

**Kani** 是 AWS 开发的 Rust 有界模型检测工具，基于 CBMC (C Bounded Model Checker)。

**特点**:

- ✅ 完全自动化
- ✅ 无需标注
- ✅ 支持标准库
- ✅ 快速反馈

**架构**:

```text
[Rust 源码] → [rustc + Kani] → [MIR] → [CBMC] → [SMT Solver] → [验证结果]
```

### 4.3.2.2 安装与配置

**安装 Kani**:

```bash
cargo install --locked kani-verifier
cargo kani setup
```

**项目配置**:

```toml
# Cargo.toml
[package]
name = "my-verified-crate"
version = "0.1.0"

[dev-dependencies]
kani-verifier = "0.34"
```

### 4.3.2.3 基础验证示例

**示例 1: 验证除法**:

```rust
// src/lib.rs

/// 安全除法
pub fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        a.checked_div(b)
    }
}

#[cfg(kani)]
mod verification {
    use super::*;
    
    #[kani::proof]
    fn verify_safe_divide() {
        let a: i32 = kani::any();
        let b: i32 = kani::any();
        
        match safe_divide(a, b) {
            Some(result) => {
                // 如果返回结果，验证正确性
                if b != 0 {
                    assert!(result * b == a || (a == i32::MIN && b == -1));
                }
            }
            None => {
                // 如果返回 None，b 必须为 0
                assert!(b == 0);
            }
        }
    }
}
```

**运行验证**:

```bash
cargo kani --harness verify_safe_divide
```

**示例 2: 验证数组边界**:

```rust
pub fn get_element(arr: &[i32], index: usize) -> Option<i32> {
    if index < arr.len() {
        Some(arr[index])
    } else {
        None
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // 限制循环展开次数
fn verify_get_element() {
    let arr: [i32; 5] = kani::any();
    let index: usize = kani::any();
    
    match get_element(&arr, index) {
        Some(value) => {
            assert!(index < 5);
            assert!(value == arr[index]);
        }
        None => {
            assert!(index >= 5);
        }
    }
}
```

### 4.3.2.4 高级验证技术

**验证数据结构不变量**:

```rust
pub struct BoundedStack {
    data: Vec<i32>,
    capacity: usize,
}

impl BoundedStack {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    pub fn push(&mut self, value: i32) -> Result<(), &'static str> {
        if self.data.len() < self.capacity {
            self.data.push(value);
            Ok(())
        } else {
            Err("Stack full")
        }
    }
    
    pub fn pop(&mut self) -> Option<i32> {
        self.data.pop()
    }
    
    // 不变量: len() <= capacity
    fn check_invariant(&self) -> bool {
        self.data.len() <= self.capacity
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_bounded_stack() {
    let capacity = 3;
    let mut stack = BoundedStack::new(capacity);
    
    // 验证初始状态
    assert!(stack.check_invariant());
    
    // 验证 push 操作
    for _ in 0..3 {
        let value: i32 = kani::any();
        if stack.push(value).is_ok() {
            assert!(stack.check_invariant());
        }
    }
    
    // 验证 pop 操作
    while let Some(_) = stack.pop() {
        assert!(stack.check_invariant());
    }
}
```

**验证并发代码**:

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

#[cfg(kani)]
#[kani::proof]
fn verify_atomic_counter() {
    let counter = Arc::new(AtomicUsize::new(0));
    
    let c1 = counter.clone();
    let c2 = counter.clone();
    
    // Kani 会探索所有可能的交错执行
    kani::concurrency::thread_spawn(move || {
        c1.fetch_add(1, Ordering::SeqCst);
    });
    
    kani::concurrency::thread_spawn(move || {
        c2.fetch_add(1, Ordering::SeqCst);
    });
    
    // 最终值应该是 2
    let final_value = counter.load(Ordering::SeqCst);
    assert!(final_value <= 2);
}
```

---

## 4.3.3 Prusti 验证工具

### 4.3.3.1 Prusti 架构

**Prusti** 是基于 Viper 验证基础设施的 Rust 验证工具。

**架构**:

```text
[Rust 源码 + 规格] → [Prusti] → [Viper IL] → [SMT Solver] → [验证结果]
```

**特点**:

- ✅ 演绎验证
- ✅ 函数契约
- ✅ 不变量表达
- ✅ 完全自动化证明

### 4.3.3.2 规格说明语言

**安装 Prusti**:

```bash
cargo install prusti-rustc prusti-server
```

**基础规格**:

```rust
use prusti_contracts::*;

#[requires(x >= 0)]
#[ensures(result >= x)]
fn increment(x: i32) -> i32 {
    x + 1
}

#[requires(a > 0 && b > 0)]
#[ensures(result > 0)]
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

**验证运行**:

```bash
cargo-prusti
```

### 4.3.3.3 不变量与断言

**循环不变量**:

```rust
use prusti_contracts::*;

#[requires(arr.len() > 0)]
#[ensures(result >= 0 && result < arr.len())]
#[ensures(forall(|i: usize| (i < arr.len()) ==> arr[result] >= arr[i]))]
fn find_max_index(arr: &[i32]) -> usize {
    let mut max_idx = 0;
    let mut i = 1;
    
    #[invariant(max_idx < arr.len())]
    #[invariant(i <= arr.len())]
    #[invariant(forall(|j: usize| (j < i) ==> arr[max_idx] >= arr[j]))]
    while i < arr.len() {
        if arr[i] > arr[max_idx] {
            max_idx = i;
        }
        i += 1;
    }
    
    max_idx
}
```

**数据结构不变量**:

```rust
use prusti_contracts::*;

struct Counter {
    value: u32,
}

#[invariant(self.value < 100)]
impl Counter {
    #[ensures(result.value == 0)]
    fn new() -> Self {
        Self { value: 0 }
    }
    
    #[requires(self.value < 99)]
    #[ensures(self.value == old(self.value) + 1)]
    fn increment(&mut self) {
        self.value += 1;
    }
    
    #[pure]
    fn get(&self) -> u32 {
        self.value
    }
}
```

### 4.3.3.4 函数契约

**前置条件与后置条件**:

```rust
use prusti_contracts::*;

#[requires(n > 0)]
#[ensures(result > 0)]
#[ensures(result == n * factorial(n - 1))] // 递归规格
fn factorial(n: u64) -> u64 {
    if n == 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

#[requires(arr.len() > 0)]
#[requires(target >= arr[0] && target <= arr[arr.len() - 1])]
#[ensures(result.is_some() ==> arr[result.unwrap()] == target)]
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut low = 0;
    let mut high = arr.len();
    
    #[invariant(low <= high)]
    #[invariant(high <= arr.len())]
    while low < high {
        let mid = low + (high - low) / 2;
        
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    None
}
```

**纯函数标记**:

```rust
use prusti_contracts::*;

#[pure]
#[requires(arr.len() > 0)]
fn sum(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

#[requires(arr.len() > 0)]
#[ensures(result == sum(arr))]
fn compute_total(arr: &[i32]) -> i32 {
    let mut total = 0;
    let mut i = 0;
    
    #[invariant(i <= arr.len())]
    #[invariant(total == sum(&arr[0..i]))]
    while i < arr.len() {
        total += arr[i];
        i += 1;
    }
    
    total
}
```

---

## 4.3.4 MIRAI 抽象解释

### 4.3.4.1 MIRAI 原理

**MIRAI** (Mid-level Intermediate Representation Abstract Interpreter) 是 Facebook 开发的静态分析工具。

**特点**:

- ✅ 快速分析
- ✅ 可扩展
- ✅ 无需标注
- ⚠️ 可能误报

### 4.3.4.2 使用 MIRAI

**安装**:

```bash
cargo install mirai
```

**基础使用**:

```rust
// src/lib.rs

pub fn divide(a: i32, b: i32) -> i32 {
    // MIRAI 会检测潜在的除零错误
    a / b
}

pub fn access_array(arr: &[i32], index: usize) -> i32 {
    // MIRAI 会检测潜在的越界访问
    arr[index]
}

pub fn dereference_option(opt: Option<&i32>) -> i32 {
    // MIRAI 会检测潜在的 panic
    *opt.unwrap()
}
```

**运行 MIRAI**:

```bash
cargo mirai
```

### 4.3.4.3 标签传播

**污点分析**:

```rust
use mirai_annotations::*;

pub fn process_user_input(input: String) -> String {
    // 标记为不受信任的输入
    add_tag!(&input, TagPropagationSet::tainted());
    
    // MIRAI 会追踪污点传播
    let processed = sanitize(input);
    
    // 验证已清理
    verify_tag!(&processed, TagPropagationSet::sanitized());
    
    processed
}

fn sanitize(input: String) -> String {
    // 清理逻辑
    input.replace("<", "&lt;").replace(">", "&gt;")
}
```

### 4.3.4.4 数据流分析

**空指针检测**:

```rust
pub fn safe_access(opt: Option<&i32>) -> i32 {
    match opt {
        Some(value) => *value,
        None => 0,
    }
}

pub fn unsafe_access(opt: Option<&i32>) -> i32 {
    // MIRAI 警告: 潜在的 panic
    *opt.unwrap()
}
```

---

## 4.3.5 Creusot 演绎验证

### 4.3.5.1 Creusot 简介

**Creusot** 是一个将 Rust 程序转换为 Why3 逻辑的工具，支持演绎验证。

**特点**:

- ✅ 强大的证明能力
- ✅ 支持复杂数据结构
- ✅ 可交互证明
- ⚠️ 学习曲线陡峭

### 4.3.5.2 Why3 集成

**安装**:

```bash
# 安装 Why3
opam install why3

# 安装 Creusot
cargo install creusot
```

**基础验证**:

```rust
use creusot_contracts::*;

#[requires(x < 100)]
#[ensures(result == x + 1)]
fn increment(x: u32) -> u32 {
    x + 1
}

#[requires(a.len() > 0)]
#[ensures(result.is_some() ==> exists(|i: usize| i < a.len() && a[i] == x))]
fn find(a: &[i32], x: i32) -> Option<usize> {
    for i in 0..a.len() {
        if a[i] == x {
            return Some(i);
        }
    }
    None
}
```

### 4.3.5.3 证明策略

**手动证明提示**:

```rust
use creusot_contracts::*;

#[logic]
fn sum_range(a: Seq<i32>, l: Int, r: Int) -> Int {
    if l >= r {
        0
    } else {
        a[l] + sum_range(a, l + 1, r)
    }
}

#[requires(v.len() > 0)]
#[ensures(result == sum_range(v@, 0, v.len()@))]
fn sum(v: &Vec<i32>) -> i32 {
    let mut s = 0;
    let mut i = 0;
    
    #[invariant(inv, i@<= v.len()@)]
    #[invariant(sum_inv, s@ == sum_range(v@, 0, i@))]
    while i < v.len() {
        s += v[i];
        i += 1;
        
        // 证明提示
        proof_assert!(s@ == sum_range(v@, 0, i@));
    }
    
    s
}
```

### 4.3.5.4 复杂数据结构验证

**链表验证**:

```rust
use creusot_contracts::*;

struct Node {
    value: i32,
    next: Option<Box<Node>>,
}

#[logic]
fn list_len(node: Option<&Node>) -> Int {
    match node {
        None => 0,
        Some(n) => 1 + list_len(n.next.as_deref()),
    }
}

impl Node {
    #[ensures(list_len(Some(&result)) == 1)]
    fn new(value: i32) -> Self {
        Self {
            value,
            next: None,
        }
    }
    
    #[ensures(list_len(Some(self)) == old(list_len(Some(self))) + 1)]
    fn append(&mut self, value: i32) {
        let mut current = self;
        
        #[invariant(len_inv, list_len(Some(current)) >= 1)]
        loop {
            match current.next {
                Some(ref mut next) => {
                    current = next;
                }
                None => {
                    current.next = Some(Box::new(Node::new(value)));
                    break;
                }
            }
        }
    }
}
```

---

## 4.3.6 模型检测方法

### 4.3.6.1 TLA+ 与 Rust

**TLA+ 规格说明**:

```tla
---- MODULE Counter ----
EXTENDS Integers

VARIABLE counter

Init == counter = 0

Increment == counter' = counter + 1

Decrement == counter' = counter - 1

Next == Increment \/ Decrement

Spec == Init /\ [][Next]_counter

TypeInv == counter \in Int

====
```

**Rust 实现**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct Counter {
    value: AtomicI32,
}

impl Counter {
    pub fn new() -> Self {
        Self {
            value: AtomicI32::new(0),
        }
    }
    
    pub fn increment(&self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }
    
    pub fn decrement(&self) {
        self.value.fetch_sub(1, Ordering::SeqCst);
    }
    
    pub fn get(&self) -> i32 {
        self.value.load(Ordering::SeqCst)
    }
}
```

### 4.3.6.2 并发协议验证

**使用 Loom 验证并发代码**:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_increment() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));
        
        let threads: Vec<_> = (0..2)
            .map(|_| {
                let counter = counter.clone();
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::SeqCst);
                })
            })
            .collect();
        
        for t in threads {
            t.join().unwrap();
        }
        
        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

### 4.3.6.3 分布式系统验证

**Raft 共识算法验证** (简化):

```rust
#[derive(Debug, Clone, PartialEq)]
enum ServerState {
    Follower,
    Candidate,
    Leader,
}

struct RaftServer {
    state: ServerState,
    term: u64,
    voted_for: Option<u64>,
}

impl RaftServer {
    // 规格: 在同一 term 内只能投票一次
    fn request_vote(&mut self, candidate_id: u64, term: u64) -> bool {
        if term > self.term {
            self.term = term;
            self.voted_for = None;
        }
        
        if term == self.term && self.voted_for.is_none() {
            self.voted_for = Some(candidate_id);
            true
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn verify_single_vote_per_term() {
        let mut server = RaftServer {
            state: ServerState::Follower,
            term: 1,
            voted_for: None,
        };
        
        // 第一次投票应该成功
        assert!(server.request_vote(1, 1));
        
        // 同一 term 内的第二次投票应该失败
        assert!(!server.request_vote(2, 1));
    }
}
```

### 4.3.6.4 Loom 并发测试

**测试无锁栈**:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head
                .compare_exchange(head, new_node, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                break;
            }
        }
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            if self.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}

#[cfg(test)]
mod loom_tests {
    use super::*;
    use loom::thread;
    
    #[test]
    fn test_concurrent_push_pop() {
        loom::model(|| {
            let stack = Arc::new(Stack::new());
            
            let s1 = stack.clone();
            let t1 = thread::spawn(move || {
                s1.push(1);
                s1.push(2);
            });
            
            let s2 = stack.clone();
            let t2 = thread::spawn(move || {
                let _ = s2.pop();
                let _ = s2.pop();
            });
            
            t1.join().unwrap();
            t2.join().unwrap();
        });
    }
}
```

---

## 4.3.7 符号执行

### 4.3.7.1 符号执行原理

**符号执行** 使用符号值而非具体值执行程序，探索所有可能的执行路径。

**示例**:

```rust
fn example(x: i32) -> i32 {
    if x > 10 {
        x * 2
    } else {
        x + 5
    }
}

// 符号执行会探索两条路径:
// 路径 1: x > 10  → 返回 x * 2
// 路径 2: x <= 10 → 返回 x + 5
```

### 4.3.7.2 KLEE 与 Rust

**使用 KLEE** (通过 LLVM IR):

```rust
// 生成 LLVM IR
// rustc --emit=llvm-ir example.rs

#[no_mangle]
pub extern "C" fn test_function(x: i32, y: i32) -> i32 {
    if x > 0 && y > 0 {
        x + y
    } else if x < 0 && y < 0 {
        x * y
    } else {
        0
    }
}
```

**KLEE 命令**:

```bash
# 编译为 LLVM IR
rustc --emit=llvm-ir test.rs

# 运行 KLEE
klee test.ll
```

### 4.3.7.3 路径爆炸问题

**问题示例**:

```rust
fn path_explosion(arr: &[i32]) -> i32 {
    let mut sum = 0;
    
    // 10 个 if 语句 → 2^10 = 1024 条路径
    if arr[0] > 0 { sum += arr[0]; }
    if arr[1] > 0 { sum += arr[1]; }
    if arr[2] > 0 { sum += arr[2]; }
    // ... 更多条件
    
    sum
}
```

**缓解策略**:

1. **路径剪枝**: 合并相似路径
2. **启发式搜索**: 优先探索重要路径
3. **约束缓存**: 重用求解结果
4. **抽象**: 简化路径条件

### 4.3.7.4 约束求解

**SMT 求解器使用** (使用 Z3):

```rust
use z3::*;

fn solve_constraints() {
    let cfg = Config::new();
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);
    
    // 创建变量
    let x = Int::new_const(&ctx, "x");
    let y = Int::new_const(&ctx, "y");
    
    // 添加约束
    solver.assert(&x.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&y.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&x._eq(&y.mul(&Int::from_i64(&ctx, 2))));
    
    // 求解
    match solver.check() {
        SatResult::Sat => {
            let model = solver.get_model().unwrap();
            println!("x = {}", model.eval(&x, true).unwrap());
            println!("y = {}", model.eval(&y, true).unwrap());
        }
        _ => println!("No solution"),
    }
}
```

---

## 4.3.8 安全关键系统实践

### 4.3.8.1 航空航天应用

**DO-178C 认证**:

```rust
// 关键飞行控制代码
#[cfg(kani)]
#[kani::proof]
fn verify_altitude_control() {
    let current_altitude: f64 = kani::any();
    let target_altitude: f64 = kani::any();
    
    kani::assume(current_altitude >= 0.0 && current_altitude <= 50000.0);
    kani::assume(target_altitude >= 0.0 && target_altitude <= 50000.0);
    
    let control_signal = compute_control_signal(current_altitude, target_altitude);
    
    // 验证控制信号在安全范围内
    assert!(control_signal.abs() <= MAX_CONTROL_SIGNAL);
}

fn compute_control_signal(current: f64, target: f64) -> f64 {
    const KP: f64 = 0.1;
    let error = target - current;
    KP * error
}

const MAX_CONTROL_SIGNAL: f64 = 10.0;
```

### 4.3.8.2 医疗设备

**IEC 62304 标准**:

```rust
use prusti_contracts::*;

struct InsulinPump {
    dose_rate: f64, // 单位: units/hour
    max_rate: f64,
    min_rate: f64,
}

#[invariant(self.dose_rate >= self.min_rate && self.dose_rate <= self.max_rate)]
impl InsulinPump {
    #[ensures(result.dose_rate == 0.0)]
    #[ensures(result.max_rate == 10.0)]
    #[ensures(result.min_rate == 0.0)]
    fn new() -> Self {
        Self {
            dose_rate: 0.0,
            max_rate: 10.0,
            min_rate: 0.0,
        }
    }
    
    #[requires(new_rate >= self.min_rate && new_rate <= self.max_rate)]
    #[ensures(self.dose_rate == new_rate)]
    fn set_dose_rate(&mut self, new_rate: f64) {
        self.dose_rate = new_rate;
    }
    
    #[pure]
    fn get_dose_rate(&self) -> f64 {
        self.dose_rate
    }
}
```

### 4.3.8.3 金融系统

**交易系统验证**:

```rust
#[cfg(kani)]
#[kani::proof]
fn verify_trade_settlement() {
    let account_balance: i64 = kani::any();
    let trade_amount: i64 = kani::any();
    
    kani::assume(account_balance >= 0);
    kani::assume(trade_amount >= 0);
    
    match settle_trade(account_balance, trade_amount) {
        Some(new_balance) => {
            // 验证余额正确更新
            assert!(new_balance == account_balance - trade_amount);
            assert!(new_balance >= 0);
        }
        None => {
            // 验证余额不足时拒绝交易
            assert!(account_balance < trade_amount);
        }
    }
}

fn settle_trade(balance: i64, amount: i64) -> Option<i64> {
    balance.checked_sub(amount)
}
```

### 4.3.8.4 工业控制

**PLC 控制逻辑**:

```rust
struct PLCController {
    temperature: f32,
    pressure: f32,
    valve_open: bool,
}

impl PLCController {
    fn control_loop(&mut self) {
        // 安全规则: 如果温度或压力超限，关闭阀门
        if self.temperature > 100.0 || self.pressure > 10.0 {
            self.valve_open = false;
        }
    }
}

#[cfg(kani)]
#[kani::proof]
fn verify_safety_shutdown() {
    let mut controller = PLCController {
        temperature: kani::any(),
        pressure: kani::any(),
        valve_open: true,
    };
    
    kani::assume(controller.temperature >= 0.0 && controller.temperature <= 200.0);
    kani::assume(controller.pressure >= 0.0 && controller.pressure <= 20.0);
    
    controller.control_loop();
    
    // 验证安全属性
    if controller.temperature > 100.0 || controller.pressure > 10.0 {
        assert!(!controller.valve_open);
    }
}
```

---

## 4.3.9 验证最佳实践

### 4.3.9.1 验证策略

**1. 分层验证**:

```text
Layer 1: 单元函数验证 (Kani)
Layer 2: 模块不变量验证 (Prusti)
Layer 3: 系统级属性验证 (TLA+)
```

**2. 增量验证**:

```rust
// 先验证核心不变量
#[cfg(kani)]
#[kani::proof]
fn verify_core_invariant() {
    // 最重要的属性
}

// 再验证边界情况
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_edge_cases() {
    // 边界条件
}
```

### 4.3.9.2 性能优化

**限制搜索空间**:

```rust
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // 限制循环展开
fn verify_bounded() {
    let n: u32 = kani::any();
    kani::assume(n < 100); // 限制输入范围
    
    let result = expensive_function(n);
    assert!(result >= 0);
}
```

**使用抽象**:

```rust
// 抽象复杂数据结构
#[cfg(kani)]
struct AbstractVec {
    len: usize,
    capacity: usize,
}

#[cfg(not(kani))]
type AbstractVec = Vec<i32>;
```

### 4.3.9.3 可维护性

**文档化验证意图**:

```rust
/// 验证目标: 证明数组访问永不越界
/// 前置条件: index < arr.len()
/// 后置条件: 返回 arr[index]
#[cfg(kani)]
#[kani::proof]
fn verify_safe_access() {
    // ...
}
```

**模块化验证**:

```rust
mod verified_core {
    // 核心逻辑,已验证
}

mod unverified_wrapper {
    // 外层封装,可能未验证
    use super::verified_core;
}
```

### 4.3.9.4 持续集成

**GitHub Actions 集成**:

```yaml
name: Formal Verification

on: [push, pull_request]

jobs:
  kani:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Kani
        run: cargo install --locked kani-verifier
      - name: Run Kani
        run: cargo kani --harness verify_all

  prusti:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Prusti
        run: cargo install prusti-rustc
      - name: Run Prusti
        run: cargo-prusti
```

---

## 4.3.10 形式化验证理论基础

> **章节定位**: 深入理解形式化验证的数学基础和理论框架  
> **目标读者**: 研究者、高级工程师、需要理论支撑的架构师  
> **建议阅读顺序**: 先掌握工具实战（4.3.1-4.3.9），再深入理论框架

### 4.3.10.1 类型系统的形式化

#### Rust 类型系统的数学模型

Rust 的类型系统可以用**线性类型理论** (Linear Type Theory) 和**仿射类型** (Affine Types) 来形式化描述。

**核心概念**:

```text
类型判断规则 (Typing Rules):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Γ ⊢ e : T    (在上下文 Γ 中，表达式 e 的类型为 T)

所有权转移规则:
Γ ⊢ x : T    x ∈ dom(Γ)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Γ \ {x} ⊢ move x : T    (x 从 Γ 中移除)

借用规则:
Γ ⊢ x : T    x ∈ dom(Γ)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Γ ⊢ &x : &T    (x 仍保留在 Γ 中)
```

**实例化**:

```rust
// 类型理论视角下的所有权转移
fn transfer_ownership() {
    let s = String::from("hello"); // Γ₁ = {s: String}
    let t = s;                      // Γ₂ = {t: String}  (s 已从 Γ 中移除)
    // println!("{}", s);           // ❌ s ∉ Γ₂，类型检查失败
    println!("{}", t);              // ✅ t ∈ Γ₂，类型检查通过
}

// 借用的形式化
fn borrow_semantics() {
    let s = String::from("hello"); // Γ = {s: String}
    let r = &s;                     // Γ = {s: String, r: &String}
    println!("{} {}", r, s);        // ✅ 两者都在 Γ 中
}
```

#### 生命周期的形式化

生命周期可以用**区域类型系统** (Region Type System) 表示：

```text
生命周期约束:
'a: 'b  表示 'a 的生命周期至少和 'b 一样长

借用检查规则:
Γ ⊢ x : T    'a: 'b
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Γ ⊢ &'a x : &'a T

生命周期推导:
如果 &'a T 被用作 &'b T，则必须 'a: 'b
```

**实例**:

```rust
// 生命周期约束的形式化
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // 返回值的生命周期 'a 必须满足:
    // 'a ≤ 'x ∧ 'a ≤ 'y (其中 'x 和 'y 是 x 和 y 的实际生命周期)
    if x.len() > y.len() { x } else { y }
}

// 生命周期推导示例
fn lifetime_inference() {
    let s1 = String::from("long string");
    {
        let s2 = String::from("short");
        // 'a 被推导为 min('s1, 's2) = 's2
        let result = longest(&s1, &s2);
        println!("{}", result); // ✅ result 在 's2 范围内
    }
    // result 在这里不可用，因为 's2 已结束
}
```

### 4.3.10.2 霍尔逻辑与程序验证

#### 霍尔三元组 (Hoare Triple)

形式化验证的核心是**霍尔三元组**: `{P} S {Q}`

- `P`: 前置条件 (Precondition)
- `S`: 程序语句 (Statement)
- `Q`: 后置条件 (Postcondition)

**含义**: 如果 P 在执行 S 前成立，那么 Q 在执行 S 后成立。

#### Rust 中的霍尔逻辑应用

```rust
// 示例：数组求和
#[requires(arr.len() > 0)]  // 前置条件
#[ensures(result == arr.iter().sum())]  // 后置条件
fn array_sum(arr: &[i32]) -> i32 {
    let mut sum = 0;
    // 循环不变量: sum == arr[0..i].iter().sum()
    for &x in arr {
        sum += x;
    }
    sum
}
```

**形式化表示**:

```text
{arr.len() > 0}
    let mut sum = 0;
    for &x in arr {
        sum += x;
    }
{sum == arr.iter().sum()}
```

#### 循环不变量 (Loop Invariant)

循环不变量是证明循环正确性的关键：

```rust
#[flux::sig(fn(n: i32{n >= 0}) -> i32{v: v == n * (n + 1) / 2})]
fn triangle_number(n: i32) -> i32 {
    let mut i = 0;
    let mut sum = 0;
    
    // 循环不变量: sum == i * (i + 1) / 2 ∧ i ≤ n
    while i < n {
        i += 1;
        sum += i;
    }
    
    // 后置条件: sum == n * (n + 1) / 2
    sum
}
```

**不变量证明**:

```text
初始化: i = 0, sum = 0 ⟹ sum == i * (i + 1) / 2  ✅

维持: 假设 sum == i * (i + 1) / 2
      执行 i += 1; sum += i;
      ⟹ sum_new = sum_old + i_new
                = i_old * (i_old + 1) / 2 + (i_old + 1)
                = (i_old + 1) * (i_old + 2) / 2
                = i_new * (i_new + 1) / 2  ✅

终止: i >= n ∧ sum == i * (i + 1) / 2
      ⟹ sum == n * (n + 1) / 2  ✅
```

### 4.3.10.3 分离逻辑 (Separation Logic)

分离逻辑是验证指针和堆内存的强大工具。

#### 分离逻辑基本概念

**核心运算符**:

- `P * Q`: 分离合取 (Separating Conjunction) - P 和 Q 在不相交的内存区域中成立
- `P --* Q`: 分离蕴含 (Separating Implication) - 魔杖操作符
- `emp`: 空堆
- `x ↦ v`: x 指向的内存单元包含值 v

#### Rust 中的分离逻辑应用

```rust
// 分离逻辑视角下的借用
fn separation_logic_example() {
    let mut x = 5;
    let mut y = 10;
    
    // 堆状态: x ↦ 5 * y ↦ 10  (分离的内存区域)
    
    let r1 = &mut x;
    let r2 = &mut y;
    
    // 新堆状态: r1 ↦ x * r2 ↦ y * x ↦ 5 * y ↦ 10
    // 且 r1 和 r2 指向不相交的内存，满足分离逻辑
    
    *r1 += 1;  // x ↦ 6
    *r2 += 1;  // y ↦ 11
}
```

#### 所有权转移的分离逻辑证明

```text
所有权转移规则:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{x ↦ v} let y = x; {y ↦ v}

分离合取规则:
{P * Q} S₁ {P' * Q}    {P' * Q} S₂ {P' * Q'}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{P * Q} S₁; S₂ {P' * Q'}
```

### 4.3.10.4 RustBelt：Rust 安全性的形式化证明

RustBelt 是 Rust 类型系统的形式化安全性证明项目。

#### RustBelt 核心定理

**类型安全性 (Type Safety)**:

```text
定理 (Progress): 
如果 ⊢ e : T 且 e 不是值 (value)，
则存在 e' 使得 e → e' (可以继续执行)

定理 (Preservation):
如果 ⊢ e : T 且 e → e'，
则 ⊢ e' : T (类型保持不变)
```

**内存安全性**:

```text
定理 (Memory Safety):
对于所有类型良好的程序 e (⊢ e : T)，
在执行过程中不会发生:
1. 悬垂指针解引用
2. 二次释放 (double-free)
3. 数据竞争 (data race)
```

#### 所有权的形式化证明

RustBelt 使用 **Iris** (并发分离逻辑框架) 证明了以下关键性质：

```text
所有权转移的正确性:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
∀ x, T. {own(x, T)} move x {⊥}
(拥有 x 后转移，x 变为不可访问)

借用的正确性:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
∀ x, T. {own(x, T)} &x {own(x, T) * borrow(x, T)}
(借用创建临时的借用令牌，原所有权保留)

可变借用的独占性:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
∀ x, T. {own(x, T)} &mut x {mut_borrow(x, T)}
(可变借用转移完全控制权，直到借用结束)
```

### 4.3.10.5 模型检查理论

#### 状态空间探索

模型检查通过探索程序的所有可能状态来验证性质。

**状态转移系统 (Transition System)**:

```text
TS = (S, S₀, →, AP, L)
其中:
- S: 状态集合
- S₀ ⊆ S: 初始状态集
- →: 转移关系 (S × S)
- AP: 原子命题集
- L: 状态标记函数 (S → 2^AP)
```

#### Rust 程序的状态空间

```rust
// 状态空间示例
fn state_space_example() {
    let mut x = 0;  // 初始状态 S₀: {x=0}
    
    if condition() {
        x = 1;      // 状态 S₁: {x=1}
    } else {
        x = 2;      // 状态 S₂: {x=2}
    }
    
    // 最终状态: S₁ ∪ S₂ = {x=1} ∪ {x=2}
}
```

**有界模型检查 (Bounded Model Checking)**:

Kani 使用 BMC 方法，在有限深度 k 内探索状态空间：

```text
BMC(φ, k) ≡ Init(s₀) ∧ ⋀ᵢ₌₀ᵏ⁻¹ Trans(sᵢ, sᵢ₊₁) ∧ ⋁ᵢ₌₀ᵏ ¬φ(sᵢ)

如果 BMC(φ, k) 不可满足，则 φ 在深度 k 内成立
```

### 4.3.10.6 时序逻辑 (Temporal Logic)

#### 线性时序逻辑 (LTL)

LTL 用于描述程序执行路径上的性质。

**LTL 基本操作符**:

- `◯ φ`: Next (下一个状态 φ 成立)
- `◇ φ`: Eventually (最终 φ 会成立)
- `□ φ`: Always (φ 始终成立)
- `φ U ψ`: Until (φ 一直成立直到 ψ 成立)

**Rust 并发性质的 LTL 表示**:

```rust
// LTL 性质示例
#[kani::proof]
fn ltl_property() {
    let mutex = Arc::new(Mutex::new(0));
    
    // 性质: □ (locked → ◇ unlocked)
    // (如果锁被持有，最终会被释放)
    {
        let _guard = mutex.lock().unwrap();
        // locked 状态
    } // ◇ unlocked (guard 被释放)
    
    // 验证属性：无死锁
    // □ ◇ (∀ threads. can_proceed)
}
```

### 4.3.10.7 可达性分析

#### 不变量推导

自动推导程序不变量是验证的关键。

**抽象解释 (Abstract Interpretation)**:

```text
具体域 (Concrete Domain):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
x ∈ ℤ (所有整数)

抽象域 (Abstract Domain):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
x ∈ {⊤, [a,b], ⊥}
(区间抽象)

抽象函数 α: 2^ℤ → Intervals
具体化函数 γ: Intervals → 2^ℤ
```

**Rust 中的应用**:

```rust
#[flux::sig(fn(x: i32{0 <= x && x <= 100}) -> i32{v: 0 <= v && v <= 200})]
fn double_in_range(x: i32) -> i32 {
    // 抽象解释:
    // x ∈ [0, 100]
    // 2 * x ∈ [0, 200]  (区间运算)
    2 * x
}
```

### 4.3.10.8 形式化方法的局限性与实践建议

#### 理论局限

| 局限 | 描述 | 缓解策略 |
|------|------|---------|
| **不完备性** | 无法验证所有性质 (哥德尔不完备定理) | 聚焦关键性质 |
| **状态爆炸** | 状态空间指数增长 | 抽象简化、符号执行 |
| **规约困难** | 正确编写规约需要专业知识 | 模板库、工具辅助 |
| **性能开销** | 验证时间可能很长 | 增量验证、模块化 |

#### 实践建议

**层次化验证策略**:

```text
Level 1: 类型系统 (100% 覆盖)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 编译器自动检查
✅ 零运行时开销
✅ 捕获大多数内存安全问题

Level 2: Loom 并发测试 (关键路径)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 并发行为验证
✅ 快速反馈
⚠️  需要手动编写测试

Level 3: Kani 有界模型检查 (核心算法)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 深度验证
✅ 找到边界情况
⚠️  验证时间较长

Level 4: Prusti 演绎验证 (安全关键)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 完整正确性证明
✅ 最高保证
⚠️  需要专业知识
```

**ROI 评估**:

| 项目类型 | 推荐验证级别 | ROI |
|---------|------------|-----|
| **Web 应用** | Level 1 | 最高 |
| **游戏引擎** | Level 1-2 | 高 |
| **金融系统** | Level 1-3 | 中高 |
| **医疗设备** | Level 1-4 | 中 (必要成本) |
| **航空航天** | Level 1-4 | 低 (但必须) |

---

## 4.3.11 参考资源

**官方文档**:

- [Kani Rust Verifier](https://model-checking.github.io/kani/)
- [Prusti](https://www.pm.inf.ethz.ch/research/prusti.html)
- [Creusot](https://github.com/xldenis/creusot)
- [MIRAI](https://github.com/facebookexperimental/MIRAI)

**学术论文**:

- "RustBelt: Securing the Foundations of the Rust Programming Language"
- "Prusti: Deductive Verification for Rust"
- "Leveraging Rust Types for Modular Specification and Verification"

**形式化理论**:

- "Separation Logic: A Logic for Shared Mutable Data Structures"
- "The Iris Project: Higher-Order Concurrent Separation Logic"
- "Abstract Interpretation: A Unified Lattice Model"

**相关文档**:

- [analysis/01_formal_verification_framework.md](../analysis/rust190_ecosystem/01_formal_verification/formal_verification_framework.md) - 深度理论分析
- [4.1 进阶主题集](4.1_进阶主题集.md)
- [4.2 跨行业应用分析](4.2_跨行业应用分析.md)
- [1.1 主索引导航](../1.1_主索引导航.md)

---

**报告完成时间**: 2025-10-21  
**文档版本**: v1.0  
**下次更新**: 2026-01-21  
**维护团队**: Rust 形式化验证研究组

---

**🎯 形式化验证，保障Rust代码绝对正确！**
