# 4.3 Rust å½¢å¼åŒ–éªŒè¯æ–¹æ³• (2025-10-21)

> **æ–‡æ¡£å®šä½**: Rust å½¢å¼åŒ–éªŒè¯å·¥å…·é“¾ä¸æœ€ä½³å®è·µ  
> **é€‚ç”¨äººç¾¤**: å®‰å…¨å…³é”®ç³»ç»Ÿå¼€å‘è€…ã€å½¢å¼åŒ–æ–¹æ³•ç ”ç©¶è€…  
> **å…³è”æ–‡æ¡£**: [4.1 è¿›é˜¶ä¸»é¢˜é›†](4.1_è¿›é˜¶ä¸»é¢˜é›†.md) | [4.2 è¡Œä¸šåº”ç”¨](4.2_è·¨è¡Œä¸šåº”ç”¨åˆ†æ.md) | [1.1 ä¸»ç´¢å¼•](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æœ€åæ›´æ–°**: 2025-10-21  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [4.3 Rust å½¢å¼åŒ–éªŒè¯æ–¹æ³• (2025-10-21)](#43-rust-å½¢å¼åŒ–éªŒè¯æ–¹æ³•-2025-10-21)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [4.3.1 å½¢å¼åŒ–éªŒè¯æ¦‚è¿°](#431-å½¢å¼åŒ–éªŒè¯æ¦‚è¿°)
    - [4.3.1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯](#4311-ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯)
    - [4.3.1.2 ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯](#4312-ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯)
    - [4.3.1.3 å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»](#4313-å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»)
    - [4.3.1.4 Rust ä¸å½¢å¼åŒ–éªŒè¯](#4314-rust-ä¸å½¢å¼åŒ–éªŒè¯)
  - [4.3.2 Kani éªŒè¯å™¨](#432-kani-éªŒè¯å™¨)
    - [4.3.2.1 Kani ç®€ä»‹](#4321-kani-ç®€ä»‹)
    - [4.3.2.2 å®‰è£…ä¸é…ç½®](#4322-å®‰è£…ä¸é…ç½®)
    - [4.3.2.3 åŸºç¡€éªŒè¯ç¤ºä¾‹](#4323-åŸºç¡€éªŒè¯ç¤ºä¾‹)
    - [4.3.2.4 é«˜çº§éªŒè¯æŠ€æœ¯](#4324-é«˜çº§éªŒè¯æŠ€æœ¯)
  - [4.3.3 Prusti éªŒè¯å·¥å…·](#433-prusti-éªŒè¯å·¥å…·)
    - [4.3.3.1 Prusti æ¶æ„](#4331-prusti-æ¶æ„)
    - [4.3.3.2 è§„æ ¼è¯´æ˜è¯­è¨€](#4332-è§„æ ¼è¯´æ˜è¯­è¨€)
    - [4.3.3.3 ä¸å˜é‡ä¸æ–­è¨€](#4333-ä¸å˜é‡ä¸æ–­è¨€)
    - [4.3.3.4 å‡½æ•°å¥‘çº¦](#4334-å‡½æ•°å¥‘çº¦)
  - [4.3.4 MIRAI æŠ½è±¡è§£é‡Š](#434-mirai-æŠ½è±¡è§£é‡Š)
    - [4.3.4.1 MIRAI åŸç†](#4341-mirai-åŸç†)
    - [4.3.4.2 ä½¿ç”¨ MIRAI](#4342-ä½¿ç”¨-mirai)
    - [4.3.4.3 æ ‡ç­¾ä¼ æ’­](#4343-æ ‡ç­¾ä¼ æ’­)
    - [4.3.4.4 æ•°æ®æµåˆ†æ](#4344-æ•°æ®æµåˆ†æ)
  - [4.3.5 Creusot æ¼”ç»éªŒè¯](#435-creusot-æ¼”ç»éªŒè¯)
    - [4.3.5.1 Creusot ç®€ä»‹](#4351-creusot-ç®€ä»‹)
    - [4.3.5.2 Why3 é›†æˆ](#4352-why3-é›†æˆ)
    - [4.3.5.3 è¯æ˜ç­–ç•¥](#4353-è¯æ˜ç­–ç•¥)
    - [4.3.5.4 å¤æ‚æ•°æ®ç»“æ„éªŒè¯](#4354-å¤æ‚æ•°æ®ç»“æ„éªŒè¯)
  - [4.3.6 æ¨¡å‹æ£€æµ‹æ–¹æ³•](#436-æ¨¡å‹æ£€æµ‹æ–¹æ³•)
    - [4.3.6.1 TLA+ ä¸ Rust](#4361-tla-ä¸-rust)
    - [4.3.6.2 å¹¶å‘åè®®éªŒè¯](#4362-å¹¶å‘åè®®éªŒè¯)
    - [4.3.6.3 åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯](#4363-åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯)
    - [4.3.6.4 Loom å¹¶å‘æµ‹è¯•](#4364-loom-å¹¶å‘æµ‹è¯•)
  - [4.3.7 ç¬¦å·æ‰§è¡Œ](#437-ç¬¦å·æ‰§è¡Œ)
    - [4.3.7.1 ç¬¦å·æ‰§è¡ŒåŸç†](#4371-ç¬¦å·æ‰§è¡ŒåŸç†)
    - [4.3.7.2 KLEE ä¸ Rust](#4372-klee-ä¸-rust)
    - [4.3.7.3 è·¯å¾„çˆ†ç‚¸é—®é¢˜](#4373-è·¯å¾„çˆ†ç‚¸é—®é¢˜)
    - [4.3.7.4 çº¦æŸæ±‚è§£](#4374-çº¦æŸæ±‚è§£)
  - [4.3.8 å®‰å…¨å…³é”®ç³»ç»Ÿå®è·µ](#438-å®‰å…¨å…³é”®ç³»ç»Ÿå®è·µ)
    - [4.3.8.1 èˆªç©ºèˆªå¤©åº”ç”¨](#4381-èˆªç©ºèˆªå¤©åº”ç”¨)
    - [4.3.8.2 åŒ»ç–—è®¾å¤‡](#4382-åŒ»ç–—è®¾å¤‡)
    - [4.3.8.3 é‡‘èç³»ç»Ÿ](#4383-é‡‘èç³»ç»Ÿ)
    - [4.3.8.4 å·¥ä¸šæ§åˆ¶](#4384-å·¥ä¸šæ§åˆ¶)
  - [4.3.9 éªŒè¯æœ€ä½³å®è·µ](#439-éªŒè¯æœ€ä½³å®è·µ)
    - [4.3.9.1 éªŒè¯ç­–ç•¥](#4391-éªŒè¯ç­–ç•¥)
    - [4.3.9.2 æ€§èƒ½ä¼˜åŒ–](#4392-æ€§èƒ½ä¼˜åŒ–)
    - [4.3.9.3 å¯ç»´æŠ¤æ€§](#4393-å¯ç»´æŠ¤æ€§)
    - [4.3.9.4 æŒç»­é›†æˆ](#4394-æŒç»­é›†æˆ)
  - [4.3.10 å½¢å¼åŒ–éªŒè¯ç†è®ºåŸºç¡€](#4310-å½¢å¼åŒ–éªŒè¯ç†è®ºåŸºç¡€)
    - [4.3.10.1 ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–](#43101-ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–)
      - [Rust ç±»å‹ç³»ç»Ÿçš„æ•°å­¦æ¨¡å‹](#rust-ç±»å‹ç³»ç»Ÿçš„æ•°å­¦æ¨¡å‹)
      - [ç”Ÿå‘½å‘¨æœŸçš„å½¢å¼åŒ–](#ç”Ÿå‘½å‘¨æœŸçš„å½¢å¼åŒ–)
    - [4.3.10.2 éœå°”é€»è¾‘ä¸ç¨‹åºéªŒè¯](#43102-éœå°”é€»è¾‘ä¸ç¨‹åºéªŒè¯)
      - [éœå°”ä¸‰å…ƒç»„ (Hoare Triple)](#éœå°”ä¸‰å…ƒç»„-hoare-triple)
      - [Rust ä¸­çš„éœå°”é€»è¾‘åº”ç”¨](#rust-ä¸­çš„éœå°”é€»è¾‘åº”ç”¨)
      - [å¾ªç¯ä¸å˜é‡ (Loop Invariant)](#å¾ªç¯ä¸å˜é‡-loop-invariant)
    - [4.3.10.3 åˆ†ç¦»é€»è¾‘ (Separation Logic)](#43103-åˆ†ç¦»é€»è¾‘-separation-logic)
      - [åˆ†ç¦»é€»è¾‘åŸºæœ¬æ¦‚å¿µ](#åˆ†ç¦»é€»è¾‘åŸºæœ¬æ¦‚å¿µ)
      - [Rust ä¸­çš„åˆ†ç¦»é€»è¾‘åº”ç”¨](#rust-ä¸­çš„åˆ†ç¦»é€»è¾‘åº”ç”¨)
      - [æ‰€æœ‰æƒè½¬ç§»çš„åˆ†ç¦»é€»è¾‘è¯æ˜](#æ‰€æœ‰æƒè½¬ç§»çš„åˆ†ç¦»é€»è¾‘è¯æ˜)
    - [4.3.10.4 RustBeltï¼šRust å®‰å…¨æ€§çš„å½¢å¼åŒ–è¯æ˜](#43104-rustbeltrust-å®‰å…¨æ€§çš„å½¢å¼åŒ–è¯æ˜)
      - [RustBelt æ ¸å¿ƒå®šç†](#rustbelt-æ ¸å¿ƒå®šç†)
      - [æ‰€æœ‰æƒçš„å½¢å¼åŒ–è¯æ˜](#æ‰€æœ‰æƒçš„å½¢å¼åŒ–è¯æ˜)
    - [4.3.10.5 æ¨¡å‹æ£€æŸ¥ç†è®º](#43105-æ¨¡å‹æ£€æŸ¥ç†è®º)
      - [çŠ¶æ€ç©ºé—´æ¢ç´¢](#çŠ¶æ€ç©ºé—´æ¢ç´¢)
      - [Rust ç¨‹åºçš„çŠ¶æ€ç©ºé—´](#rust-ç¨‹åºçš„çŠ¶æ€ç©ºé—´)
    - [4.3.10.6 æ—¶åºé€»è¾‘ (Temporal Logic)](#43106-æ—¶åºé€»è¾‘-temporal-logic)
      - [çº¿æ€§æ—¶åºé€»è¾‘ (LTL)](#çº¿æ€§æ—¶åºé€»è¾‘-ltl)
    - [4.3.10.7 å¯è¾¾æ€§åˆ†æ](#43107-å¯è¾¾æ€§åˆ†æ)
      - [ä¸å˜é‡æ¨å¯¼](#ä¸å˜é‡æ¨å¯¼)
    - [4.3.10.8 å½¢å¼åŒ–æ–¹æ³•çš„å±€é™æ€§ä¸å®è·µå»ºè®®](#43108-å½¢å¼åŒ–æ–¹æ³•çš„å±€é™æ€§ä¸å®è·µå»ºè®®)
      - [ç†è®ºå±€é™](#ç†è®ºå±€é™)
      - [å®è·µå»ºè®®](#å®è·µå»ºè®®)
  - [4.3.11 å‚è€ƒèµ„æº](#4311-å‚è€ƒèµ„æº)

---

## 4.3.1 å½¢å¼åŒ–éªŒè¯æ¦‚è¿°

### 4.3.1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯

**å®šä¹‰**:

å½¢å¼åŒ–éªŒè¯æ˜¯ä½¿ç”¨æ•°å­¦æ–¹æ³•è¯æ˜ç¨‹åºæ­£ç¡®æ€§çš„æŠ€æœ¯ï¼Œä¸åŒäºä¼ ç»Ÿæµ‹è¯•åªèƒ½éªŒè¯ç‰¹å®šè¾“å…¥ï¼Œå½¢å¼åŒ–éªŒè¯èƒ½å¤Ÿè¯æ˜ç¨‹åºå¯¹æ‰€æœ‰å¯èƒ½è¾“å…¥éƒ½æ»¡è¶³è§„æ ¼è¯´æ˜ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

1. **è§„æ ¼è¯´æ˜ (Specification)**: ç”¨å½¢å¼åŒ–è¯­è¨€æè¿°ç¨‹åºåº”è¯¥åšä»€ä¹ˆ
2. **è¯æ˜ (Proof)**: æ•°å­¦è¯æ˜ç¨‹åºå®ç°æ»¡è¶³è§„æ ¼
3. **å®Œå…¨æ€§ (Soundness)**: å¦‚æœè¯æ˜é€šè¿‡ï¼Œç¨‹åºä¸€å®šæ­£ç¡®
4. **å®Œå¤‡æ€§ (Completeness)**: å¦‚æœç¨‹åºæ­£ç¡®ï¼Œè¯æ˜ä¸€å®šèƒ½é€šè¿‡

### 4.3.1.2 ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯

**ä¼ ç»Ÿæµ‹è¯•çš„å±€é™æ€§**:

```rust
// æµ‹è¯•åªèƒ½è¦†ç›–æœ‰é™æ¡ˆä¾‹
#[cfg(test)]
mod tests {
    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
        assert_eq!(add(0, 0), 0);
        assert_eq!(add(-1, 1), 0);
        // æ— æ³•æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„ i32 ç»„åˆ
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b // å¯èƒ½æº¢å‡ºï¼
}
```

**å½¢å¼åŒ–éªŒè¯çš„ä¼˜åŠ¿**:

```rust
// ä½¿ç”¨ Kani éªŒè¯æ‰€æœ‰å¯èƒ½çš„è¾“å…¥
#[cfg(kani)]
#[kani::proof]
fn verify_add() {
    let a: i32 = kani::any();
    let b: i32 = kani::any();
    
    if let Some(result) = a.checked_add(b) {
        assert!(result >= a || b < 0);
        assert!(result >= b || a < 0);
    }
}
```

**é€‚ç”¨åœºæ™¯**:

1. âœ… **å®‰å…¨å…³é”®ç³»ç»Ÿ**: èˆªç©ºã€åŒ»ç–—ã€é‡‘è
2. âœ… **å¯†ç å­¦**: åŠ å¯†ç®—æ³•æ­£ç¡®æ€§
3. âœ… **å¹¶å‘ç³»ç»Ÿ**: æ— æ•°æ®ç«äº‰ã€æ­»é”
4. âœ… **å†…å­˜å®‰å…¨**: æ— è¶Šç•Œã€æ— æ‚¬å‚æŒ‡é’ˆ

### 4.3.1.3 å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»

**1. æ¨¡å‹æ£€æµ‹ (Model Checking)**:

- ç©·ä¸¾æ‰€æœ‰å¯èƒ½çŠ¶æ€
- é€‚ç”¨äºæœ‰é™çŠ¶æ€ç³»ç»Ÿ
- å·¥å…·: TLA+, SPIN

**2. å®šç†è¯æ˜ (Theorem Proving)**:

- äº¤äº’å¼è¯æ˜
- é€‚ç”¨äºå¤æ‚æ•°å­¦è¯æ˜
- å·¥å…·: Coq, Isabelle/HOL

**3. ç¬¦å·æ‰§è¡Œ (Symbolic Execution)**:

- ç¬¦å·åŒ–æ‰§è¡Œè·¯å¾„
- å‘ç°ç¨‹åºé”™è¯¯
- å·¥å…·: KLEE, angr

**4. æŠ½è±¡è§£é‡Š (Abstract Interpretation)**:

- é™æ€åˆ†æ
- å¿«é€Ÿä½†ä¸å®Œå…¨
- å·¥å…·: MIRAI

**5. æœ‰ç•Œæ¨¡å‹æ£€æµ‹ (Bounded Model Checking)**:

- SAT/SMT æ±‚è§£å™¨
- å¹³è¡¡å®Œå…¨æ€§å’Œæ€§èƒ½
- å·¥å…·: Kani, CBMC

### 4.3.1.4 Rust ä¸å½¢å¼åŒ–éªŒè¯

**Rust çš„ä¼˜åŠ¿**:

1. **ç±»å‹å®‰å…¨**: ç±»å‹ç³»ç»Ÿå·²ç»æ˜¯ä¸€ç§è½»é‡çº§éªŒè¯
2. **æ‰€æœ‰æƒæ¨¡å‹**: è‡ªåŠ¨é˜²æ­¢å†…å­˜é”™è¯¯
3. **æ— ç©ºæŒ‡é’ˆ**: æ¶ˆé™¤ä¸€å¤§ç±»é”™è¯¯
4. **æ˜¾å¼é”™è¯¯å¤„ç†**: `Result` å’Œ `Option`

**ä»éœ€éªŒè¯çš„**:

1. **ç®—æœ¯æº¢å‡º**: `i32::MAX + 1` ä¼š panic
2. **é€»è¾‘é”™è¯¯**: ç®—æ³•å®ç°é”™è¯¯
3. **å¹¶å‘é”™è¯¯**: æ•°æ®ç«äº‰ã€æ­»é”
4. **unsafe ä»£ç **: ç»•è¿‡ç±»å‹ç³»ç»Ÿ

---

## 4.3.2 Kani éªŒè¯å™¨

### 4.3.2.1 Kani ç®€ä»‹

**Kani** æ˜¯ AWS å¼€å‘çš„ Rust æœ‰ç•Œæ¨¡å‹æ£€æµ‹å·¥å…·ï¼ŒåŸºäº CBMC (C Bounded Model Checker)ã€‚

**ç‰¹ç‚¹**:

- âœ… å®Œå…¨è‡ªåŠ¨åŒ–
- âœ… æ— éœ€æ ‡æ³¨
- âœ… æ”¯æŒæ ‡å‡†åº“
- âœ… å¿«é€Ÿåé¦ˆ

**æ¶æ„**:

```text
[Rust æºç ] â†’ [rustc + Kani] â†’ [MIR] â†’ [CBMC] â†’ [SMT Solver] â†’ [éªŒè¯ç»“æœ]
```

### 4.3.2.2 å®‰è£…ä¸é…ç½®

**å®‰è£… Kani**:

```bash
cargo install --locked kani-verifier
cargo kani setup
```

**é¡¹ç›®é…ç½®**:

```toml
# Cargo.toml
[package]
name = "my-verified-crate"
version = "0.1.0"

[dev-dependencies]
kani-verifier = "0.34"
```

### 4.3.2.3 åŸºç¡€éªŒè¯ç¤ºä¾‹

**ç¤ºä¾‹ 1: éªŒè¯é™¤æ³•**:

```rust
// src/lib.rs

/// å®‰å…¨é™¤æ³•
pub fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        a.checked_div(b)
    }
}

#[cfg(kani)]
mod verification {
    use super::*;
    
    #[kani::proof]
    fn verify_safe_divide() {
        let a: i32 = kani::any();
        let b: i32 = kani::any();
        
        match safe_divide(a, b) {
            Some(result) => {
                // å¦‚æœè¿”å›ç»“æœï¼ŒéªŒè¯æ­£ç¡®æ€§
                if b != 0 {
                    assert!(result * b == a || (a == i32::MIN && b == -1));
                }
            }
            None => {
                // å¦‚æœè¿”å› Noneï¼Œb å¿…é¡»ä¸º 0
                assert!(b == 0);
            }
        }
    }
}
```

**è¿è¡ŒéªŒè¯**:

```bash
cargo kani --harness verify_safe_divide
```

**ç¤ºä¾‹ 2: éªŒè¯æ•°ç»„è¾¹ç•Œ**:

```rust
pub fn get_element(arr: &[i32], index: usize) -> Option<i32> {
    if index < arr.len() {
        Some(arr[index])
    } else {
        None
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // é™åˆ¶å¾ªç¯å±•å¼€æ¬¡æ•°
fn verify_get_element() {
    let arr: [i32; 5] = kani::any();
    let index: usize = kani::any();
    
    match get_element(&arr, index) {
        Some(value) => {
            assert!(index < 5);
            assert!(value == arr[index]);
        }
        None => {
            assert!(index >= 5);
        }
    }
}
```

### 4.3.2.4 é«˜çº§éªŒè¯æŠ€æœ¯

**éªŒè¯æ•°æ®ç»“æ„ä¸å˜é‡**:

```rust
pub struct BoundedStack {
    data: Vec<i32>,
    capacity: usize,
}

impl BoundedStack {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    pub fn push(&mut self, value: i32) -> Result<(), &'static str> {
        if self.data.len() < self.capacity {
            self.data.push(value);
            Ok(())
        } else {
            Err("Stack full")
        }
    }
    
    pub fn pop(&mut self) -> Option<i32> {
        self.data.pop()
    }
    
    // ä¸å˜é‡: len() <= capacity
    fn check_invariant(&self) -> bool {
        self.data.len() <= self.capacity
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_bounded_stack() {
    let capacity = 3;
    let mut stack = BoundedStack::new(capacity);
    
    // éªŒè¯åˆå§‹çŠ¶æ€
    assert!(stack.check_invariant());
    
    // éªŒè¯ push æ“ä½œ
    for _ in 0..3 {
        let value: i32 = kani::any();
        if stack.push(value).is_ok() {
            assert!(stack.check_invariant());
        }
    }
    
    // éªŒè¯ pop æ“ä½œ
    while let Some(_) = stack.pop() {
        assert!(stack.check_invariant());
    }
}
```

**éªŒè¯å¹¶å‘ä»£ç **:

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

#[cfg(kani)]
#[kani::proof]
fn verify_atomic_counter() {
    let counter = Arc::new(AtomicUsize::new(0));
    
    let c1 = counter.clone();
    let c2 = counter.clone();
    
    // Kani ä¼šæ¢ç´¢æ‰€æœ‰å¯èƒ½çš„äº¤é”™æ‰§è¡Œ
    kani::concurrency::thread_spawn(move || {
        c1.fetch_add(1, Ordering::SeqCst);
    });
    
    kani::concurrency::thread_spawn(move || {
        c2.fetch_add(1, Ordering::SeqCst);
    });
    
    // æœ€ç»ˆå€¼åº”è¯¥æ˜¯ 2
    let final_value = counter.load(Ordering::SeqCst);
    assert!(final_value <= 2);
}
```

---

## 4.3.3 Prusti éªŒè¯å·¥å…·

### 4.3.3.1 Prusti æ¶æ„

**Prusti** æ˜¯åŸºäº Viper éªŒè¯åŸºç¡€è®¾æ–½çš„ Rust éªŒè¯å·¥å…·ã€‚

**æ¶æ„**:

```text
[Rust æºç  + è§„æ ¼] â†’ [Prusti] â†’ [Viper IL] â†’ [SMT Solver] â†’ [éªŒè¯ç»“æœ]
```

**ç‰¹ç‚¹**:

- âœ… æ¼”ç»éªŒè¯
- âœ… å‡½æ•°å¥‘çº¦
- âœ… ä¸å˜é‡è¡¨è¾¾
- âœ… å®Œå…¨è‡ªåŠ¨åŒ–è¯æ˜

### 4.3.3.2 è§„æ ¼è¯´æ˜è¯­è¨€

**å®‰è£… Prusti**:

```bash
cargo install prusti-rustc prusti-server
```

**åŸºç¡€è§„æ ¼**:

```rust
use prusti_contracts::*;

#[requires(x >= 0)]
#[ensures(result >= x)]
fn increment(x: i32) -> i32 {
    x + 1
}

#[requires(a > 0 && b > 0)]
#[ensures(result > 0)]
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

**éªŒè¯è¿è¡Œ**:

```bash
cargo-prusti
```

### 4.3.3.3 ä¸å˜é‡ä¸æ–­è¨€

**å¾ªç¯ä¸å˜é‡**:

```rust
use prusti_contracts::*;

#[requires(arr.len() > 0)]
#[ensures(result >= 0 && result < arr.len())]
#[ensures(forall(|i: usize| (i < arr.len()) ==> arr[result] >= arr[i]))]
fn find_max_index(arr: &[i32]) -> usize {
    let mut max_idx = 0;
    let mut i = 1;
    
    #[invariant(max_idx < arr.len())]
    #[invariant(i <= arr.len())]
    #[invariant(forall(|j: usize| (j < i) ==> arr[max_idx] >= arr[j]))]
    while i < arr.len() {
        if arr[i] > arr[max_idx] {
            max_idx = i;
        }
        i += 1;
    }
    
    max_idx
}
```

**æ•°æ®ç»“æ„ä¸å˜é‡**:

```rust
use prusti_contracts::*;

struct Counter {
    value: u32,
}

#[invariant(self.value < 100)]
impl Counter {
    #[ensures(result.value == 0)]
    fn new() -> Self {
        Self { value: 0 }
    }
    
    #[requires(self.value < 99)]
    #[ensures(self.value == old(self.value) + 1)]
    fn increment(&mut self) {
        self.value += 1;
    }
    
    #[pure]
    fn get(&self) -> u32 {
        self.value
    }
}
```

### 4.3.3.4 å‡½æ•°å¥‘çº¦

**å‰ç½®æ¡ä»¶ä¸åç½®æ¡ä»¶**:

```rust
use prusti_contracts::*;

#[requires(n > 0)]
#[ensures(result > 0)]
#[ensures(result == n * factorial(n - 1))] // é€’å½’è§„æ ¼
fn factorial(n: u64) -> u64 {
    if n == 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

#[requires(arr.len() > 0)]
#[requires(target >= arr[0] && target <= arr[arr.len() - 1])]
#[ensures(result.is_some() ==> arr[result.unwrap()] == target)]
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut low = 0;
    let mut high = arr.len();
    
    #[invariant(low <= high)]
    #[invariant(high <= arr.len())]
    while low < high {
        let mid = low + (high - low) / 2;
        
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    None
}
```

**çº¯å‡½æ•°æ ‡è®°**:

```rust
use prusti_contracts::*;

#[pure]
#[requires(arr.len() > 0)]
fn sum(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

#[requires(arr.len() > 0)]
#[ensures(result == sum(arr))]
fn compute_total(arr: &[i32]) -> i32 {
    let mut total = 0;
    let mut i = 0;
    
    #[invariant(i <= arr.len())]
    #[invariant(total == sum(&arr[0..i]))]
    while i < arr.len() {
        total += arr[i];
        i += 1;
    }
    
    total
}
```

---

## 4.3.4 MIRAI æŠ½è±¡è§£é‡Š

### 4.3.4.1 MIRAI åŸç†

**MIRAI** (Mid-level Intermediate Representation Abstract Interpreter) æ˜¯ Facebook å¼€å‘çš„é™æ€åˆ†æå·¥å…·ã€‚

**ç‰¹ç‚¹**:

- âœ… å¿«é€Ÿåˆ†æ
- âœ… å¯æ‰©å±•
- âœ… æ— éœ€æ ‡æ³¨
- âš ï¸ å¯èƒ½è¯¯æŠ¥

### 4.3.4.2 ä½¿ç”¨ MIRAI

**å®‰è£…**:

```bash
cargo install mirai
```

**åŸºç¡€ä½¿ç”¨**:

```rust
// src/lib.rs

pub fn divide(a: i32, b: i32) -> i32 {
    // MIRAI ä¼šæ£€æµ‹æ½œåœ¨çš„é™¤é›¶é”™è¯¯
    a / b
}

pub fn access_array(arr: &[i32], index: usize) -> i32 {
    // MIRAI ä¼šæ£€æµ‹æ½œåœ¨çš„è¶Šç•Œè®¿é—®
    arr[index]
}

pub fn dereference_option(opt: Option<&i32>) -> i32 {
    // MIRAI ä¼šæ£€æµ‹æ½œåœ¨çš„ panic
    *opt.unwrap()
}
```

**è¿è¡Œ MIRAI**:

```bash
cargo mirai
```

### 4.3.4.3 æ ‡ç­¾ä¼ æ’­

**æ±¡ç‚¹åˆ†æ**:

```rust
use mirai_annotations::*;

pub fn process_user_input(input: String) -> String {
    // æ ‡è®°ä¸ºä¸å—ä¿¡ä»»çš„è¾“å…¥
    add_tag!(&input, TagPropagationSet::tainted());
    
    // MIRAI ä¼šè¿½è¸ªæ±¡ç‚¹ä¼ æ’­
    let processed = sanitize(input);
    
    // éªŒè¯å·²æ¸…ç†
    verify_tag!(&processed, TagPropagationSet::sanitized());
    
    processed
}

fn sanitize(input: String) -> String {
    // æ¸…ç†é€»è¾‘
    input.replace("<", "&lt;").replace(">", "&gt;")
}
```

### 4.3.4.4 æ•°æ®æµåˆ†æ

**ç©ºæŒ‡é’ˆæ£€æµ‹**:

```rust
pub fn safe_access(opt: Option<&i32>) -> i32 {
    match opt {
        Some(value) => *value,
        None => 0,
    }
}

pub fn unsafe_access(opt: Option<&i32>) -> i32 {
    // MIRAI è­¦å‘Š: æ½œåœ¨çš„ panic
    *opt.unwrap()
}
```

---

## 4.3.5 Creusot æ¼”ç»éªŒè¯

### 4.3.5.1 Creusot ç®€ä»‹

**Creusot** æ˜¯ä¸€ä¸ªå°† Rust ç¨‹åºè½¬æ¢ä¸º Why3 é€»è¾‘çš„å·¥å…·ï¼Œæ”¯æŒæ¼”ç»éªŒè¯ã€‚

**ç‰¹ç‚¹**:

- âœ… å¼ºå¤§çš„è¯æ˜èƒ½åŠ›
- âœ… æ”¯æŒå¤æ‚æ•°æ®ç»“æ„
- âœ… å¯äº¤äº’è¯æ˜
- âš ï¸ å­¦ä¹ æ›²çº¿é™¡å³­

### 4.3.5.2 Why3 é›†æˆ

**å®‰è£…**:

```bash
# å®‰è£… Why3
opam install why3

# å®‰è£… Creusot
cargo install creusot
```

**åŸºç¡€éªŒè¯**:

```rust
use creusot_contracts::*;

#[requires(x < 100)]
#[ensures(result == x + 1)]
fn increment(x: u32) -> u32 {
    x + 1
}

#[requires(a.len() > 0)]
#[ensures(result.is_some() ==> exists(|i: usize| i < a.len() && a[i] == x))]
fn find(a: &[i32], x: i32) -> Option<usize> {
    for i in 0..a.len() {
        if a[i] == x {
            return Some(i);
        }
    }
    None
}
```

### 4.3.5.3 è¯æ˜ç­–ç•¥

**æ‰‹åŠ¨è¯æ˜æç¤º**:

```rust
use creusot_contracts::*;

#[logic]
fn sum_range(a: Seq<i32>, l: Int, r: Int) -> Int {
    if l >= r {
        0
    } else {
        a[l] + sum_range(a, l + 1, r)
    }
}

#[requires(v.len() > 0)]
#[ensures(result == sum_range(v@, 0, v.len()@))]
fn sum(v: &Vec<i32>) -> i32 {
    let mut s = 0;
    let mut i = 0;
    
    #[invariant(inv, i@<= v.len()@)]
    #[invariant(sum_inv, s@ == sum_range(v@, 0, i@))]
    while i < v.len() {
        s += v[i];
        i += 1;
        
        // è¯æ˜æç¤º
        proof_assert!(s@ == sum_range(v@, 0, i@));
    }
    
    s
}
```

### 4.3.5.4 å¤æ‚æ•°æ®ç»“æ„éªŒè¯

**é“¾è¡¨éªŒè¯**:

```rust
use creusot_contracts::*;

struct Node {
    value: i32,
    next: Option<Box<Node>>,
}

#[logic]
fn list_len(node: Option<&Node>) -> Int {
    match node {
        None => 0,
        Some(n) => 1 + list_len(n.next.as_deref()),
    }
}

impl Node {
    #[ensures(list_len(Some(&result)) == 1)]
    fn new(value: i32) -> Self {
        Self {
            value,
            next: None,
        }
    }
    
    #[ensures(list_len(Some(self)) == old(list_len(Some(self))) + 1)]
    fn append(&mut self, value: i32) {
        let mut current = self;
        
        #[invariant(len_inv, list_len(Some(current)) >= 1)]
        loop {
            match current.next {
                Some(ref mut next) => {
                    current = next;
                }
                None => {
                    current.next = Some(Box::new(Node::new(value)));
                    break;
                }
            }
        }
    }
}
```

---

## 4.3.6 æ¨¡å‹æ£€æµ‹æ–¹æ³•

### 4.3.6.1 TLA+ ä¸ Rust

**TLA+ è§„æ ¼è¯´æ˜**:

```tla
---- MODULE Counter ----
EXTENDS Integers

VARIABLE counter

Init == counter = 0

Increment == counter' = counter + 1

Decrement == counter' = counter - 1

Next == Increment \/ Decrement

Spec == Init /\ [][Next]_counter

TypeInv == counter \in Int

====
```

**Rust å®ç°**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct Counter {
    value: AtomicI32,
}

impl Counter {
    pub fn new() -> Self {
        Self {
            value: AtomicI32::new(0),
        }
    }
    
    pub fn increment(&self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }
    
    pub fn decrement(&self) {
        self.value.fetch_sub(1, Ordering::SeqCst);
    }
    
    pub fn get(&self) -> i32 {
        self.value.load(Ordering::SeqCst)
    }
}
```

### 4.3.6.2 å¹¶å‘åè®®éªŒè¯

**ä½¿ç”¨ Loom éªŒè¯å¹¶å‘ä»£ç **:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_increment() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));
        
        let threads: Vec<_> = (0..2)
            .map(|_| {
                let counter = counter.clone();
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::SeqCst);
                })
            })
            .collect();
        
        for t in threads {
            t.join().unwrap();
        }
        
        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

### 4.3.6.3 åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯

**Raft å…±è¯†ç®—æ³•éªŒè¯** (ç®€åŒ–):

```rust
#[derive(Debug, Clone, PartialEq)]
enum ServerState {
    Follower,
    Candidate,
    Leader,
}

struct RaftServer {
    state: ServerState,
    term: u64,
    voted_for: Option<u64>,
}

impl RaftServer {
    // è§„æ ¼: åœ¨åŒä¸€ term å†…åªèƒ½æŠ•ç¥¨ä¸€æ¬¡
    fn request_vote(&mut self, candidate_id: u64, term: u64) -> bool {
        if term > self.term {
            self.term = term;
            self.voted_for = None;
        }
        
        if term == self.term && self.voted_for.is_none() {
            self.voted_for = Some(candidate_id);
            true
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn verify_single_vote_per_term() {
        let mut server = RaftServer {
            state: ServerState::Follower,
            term: 1,
            voted_for: None,
        };
        
        // ç¬¬ä¸€æ¬¡æŠ•ç¥¨åº”è¯¥æˆåŠŸ
        assert!(server.request_vote(1, 1));
        
        // åŒä¸€ term å†…çš„ç¬¬äºŒæ¬¡æŠ•ç¥¨åº”è¯¥å¤±è´¥
        assert!(!server.request_vote(2, 1));
    }
}
```

### 4.3.6.4 Loom å¹¶å‘æµ‹è¯•

**æµ‹è¯•æ— é”æ ˆ**:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head
                .compare_exchange(head, new_node, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                break;
            }
        }
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            if self.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}

#[cfg(test)]
mod loom_tests {
    use super::*;
    use loom::thread;
    
    #[test]
    fn test_concurrent_push_pop() {
        loom::model(|| {
            let stack = Arc::new(Stack::new());
            
            let s1 = stack.clone();
            let t1 = thread::spawn(move || {
                s1.push(1);
                s1.push(2);
            });
            
            let s2 = stack.clone();
            let t2 = thread::spawn(move || {
                let _ = s2.pop();
                let _ = s2.pop();
            });
            
            t1.join().unwrap();
            t2.join().unwrap();
        });
    }
}
```

---

## 4.3.7 ç¬¦å·æ‰§è¡Œ

### 4.3.7.1 ç¬¦å·æ‰§è¡ŒåŸç†

**ç¬¦å·æ‰§è¡Œ** ä½¿ç”¨ç¬¦å·å€¼è€Œéå…·ä½“å€¼æ‰§è¡Œç¨‹åºï¼Œæ¢ç´¢æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè·¯å¾„ã€‚

**ç¤ºä¾‹**:

```rust
fn example(x: i32) -> i32 {
    if x > 10 {
        x * 2
    } else {
        x + 5
    }
}

// ç¬¦å·æ‰§è¡Œä¼šæ¢ç´¢ä¸¤æ¡è·¯å¾„:
// è·¯å¾„ 1: x > 10  â†’ è¿”å› x * 2
// è·¯å¾„ 2: x <= 10 â†’ è¿”å› x + 5
```

### 4.3.7.2 KLEE ä¸ Rust

**ä½¿ç”¨ KLEE** (é€šè¿‡ LLVM IR):

```rust
// ç”Ÿæˆ LLVM IR
// rustc --emit=llvm-ir example.rs

#[no_mangle]
pub extern "C" fn test_function(x: i32, y: i32) -> i32 {
    if x > 0 && y > 0 {
        x + y
    } else if x < 0 && y < 0 {
        x * y
    } else {
        0
    }
}
```

**KLEE å‘½ä»¤**:

```bash
# ç¼–è¯‘ä¸º LLVM IR
rustc --emit=llvm-ir test.rs

# è¿è¡Œ KLEE
klee test.ll
```

### 4.3.7.3 è·¯å¾„çˆ†ç‚¸é—®é¢˜

**é—®é¢˜ç¤ºä¾‹**:

```rust
fn path_explosion(arr: &[i32]) -> i32 {
    let mut sum = 0;
    
    // 10 ä¸ª if è¯­å¥ â†’ 2^10 = 1024 æ¡è·¯å¾„
    if arr[0] > 0 { sum += arr[0]; }
    if arr[1] > 0 { sum += arr[1]; }
    if arr[2] > 0 { sum += arr[2]; }
    // ... æ›´å¤šæ¡ä»¶
    
    sum
}
```

**ç¼“è§£ç­–ç•¥**:

1. **è·¯å¾„å‰ªæ**: åˆå¹¶ç›¸ä¼¼è·¯å¾„
2. **å¯å‘å¼æœç´¢**: ä¼˜å…ˆæ¢ç´¢é‡è¦è·¯å¾„
3. **çº¦æŸç¼“å­˜**: é‡ç”¨æ±‚è§£ç»“æœ
4. **æŠ½è±¡**: ç®€åŒ–è·¯å¾„æ¡ä»¶

### 4.3.7.4 çº¦æŸæ±‚è§£

**SMT æ±‚è§£å™¨ä½¿ç”¨** (ä½¿ç”¨ Z3):

```rust
use z3::*;

fn solve_constraints() {
    let cfg = Config::new();
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);
    
    // åˆ›å»ºå˜é‡
    let x = Int::new_const(&ctx, "x");
    let y = Int::new_const(&ctx, "y");
    
    // æ·»åŠ çº¦æŸ
    solver.assert(&x.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&y.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&x._eq(&y.mul(&Int::from_i64(&ctx, 2))));
    
    // æ±‚è§£
    match solver.check() {
        SatResult::Sat => {
            let model = solver.get_model().unwrap();
            println!("x = {}", model.eval(&x, true).unwrap());
            println!("y = {}", model.eval(&y, true).unwrap());
        }
        _ => println!("No solution"),
    }
}
```

---

## 4.3.8 å®‰å…¨å…³é”®ç³»ç»Ÿå®è·µ

### 4.3.8.1 èˆªç©ºèˆªå¤©åº”ç”¨

**DO-178C è®¤è¯**:

```rust
// å…³é”®é£è¡Œæ§åˆ¶ä»£ç 
#[cfg(kani)]
#[kani::proof]
fn verify_altitude_control() {
    let current_altitude: f64 = kani::any();
    let target_altitude: f64 = kani::any();
    
    kani::assume(current_altitude >= 0.0 && current_altitude <= 50000.0);
    kani::assume(target_altitude >= 0.0 && target_altitude <= 50000.0);
    
    let control_signal = compute_control_signal(current_altitude, target_altitude);
    
    // éªŒè¯æ§åˆ¶ä¿¡å·åœ¨å®‰å…¨èŒƒå›´å†…
    assert!(control_signal.abs() <= MAX_CONTROL_SIGNAL);
}

fn compute_control_signal(current: f64, target: f64) -> f64 {
    const KP: f64 = 0.1;
    let error = target - current;
    KP * error
}

const MAX_CONTROL_SIGNAL: f64 = 10.0;
```

### 4.3.8.2 åŒ»ç–—è®¾å¤‡

**IEC 62304 æ ‡å‡†**:

```rust
use prusti_contracts::*;

struct InsulinPump {
    dose_rate: f64, // å•ä½: units/hour
    max_rate: f64,
    min_rate: f64,
}

#[invariant(self.dose_rate >= self.min_rate && self.dose_rate <= self.max_rate)]
impl InsulinPump {
    #[ensures(result.dose_rate == 0.0)]
    #[ensures(result.max_rate == 10.0)]
    #[ensures(result.min_rate == 0.0)]
    fn new() -> Self {
        Self {
            dose_rate: 0.0,
            max_rate: 10.0,
            min_rate: 0.0,
        }
    }
    
    #[requires(new_rate >= self.min_rate && new_rate <= self.max_rate)]
    #[ensures(self.dose_rate == new_rate)]
    fn set_dose_rate(&mut self, new_rate: f64) {
        self.dose_rate = new_rate;
    }
    
    #[pure]
    fn get_dose_rate(&self) -> f64 {
        self.dose_rate
    }
}
```

### 4.3.8.3 é‡‘èç³»ç»Ÿ

**äº¤æ˜“ç³»ç»ŸéªŒè¯**:

```rust
#[cfg(kani)]
#[kani::proof]
fn verify_trade_settlement() {
    let account_balance: i64 = kani::any();
    let trade_amount: i64 = kani::any();
    
    kani::assume(account_balance >= 0);
    kani::assume(trade_amount >= 0);
    
    match settle_trade(account_balance, trade_amount) {
        Some(new_balance) => {
            // éªŒè¯ä½™é¢æ­£ç¡®æ›´æ–°
            assert!(new_balance == account_balance - trade_amount);
            assert!(new_balance >= 0);
        }
        None => {
            // éªŒè¯ä½™é¢ä¸è¶³æ—¶æ‹’ç»äº¤æ˜“
            assert!(account_balance < trade_amount);
        }
    }
}

fn settle_trade(balance: i64, amount: i64) -> Option<i64> {
    balance.checked_sub(amount)
}
```

### 4.3.8.4 å·¥ä¸šæ§åˆ¶

**PLC æ§åˆ¶é€»è¾‘**:

```rust
struct PLCController {
    temperature: f32,
    pressure: f32,
    valve_open: bool,
}

impl PLCController {
    fn control_loop(&mut self) {
        // å®‰å…¨è§„åˆ™: å¦‚æœæ¸©åº¦æˆ–å‹åŠ›è¶…é™ï¼Œå…³é—­é˜€é—¨
        if self.temperature > 100.0 || self.pressure > 10.0 {
            self.valve_open = false;
        }
    }
}

#[cfg(kani)]
#[kani::proof]
fn verify_safety_shutdown() {
    let mut controller = PLCController {
        temperature: kani::any(),
        pressure: kani::any(),
        valve_open: true,
    };
    
    kani::assume(controller.temperature >= 0.0 && controller.temperature <= 200.0);
    kani::assume(controller.pressure >= 0.0 && controller.pressure <= 20.0);
    
    controller.control_loop();
    
    // éªŒè¯å®‰å…¨å±æ€§
    if controller.temperature > 100.0 || controller.pressure > 10.0 {
        assert!(!controller.valve_open);
    }
}
```

---

## 4.3.9 éªŒè¯æœ€ä½³å®è·µ

### 4.3.9.1 éªŒè¯ç­–ç•¥

**1. åˆ†å±‚éªŒè¯**:

```text
Layer 1: å•å…ƒå‡½æ•°éªŒè¯ (Kani)
Layer 2: æ¨¡å—ä¸å˜é‡éªŒè¯ (Prusti)
Layer 3: ç³»ç»Ÿçº§å±æ€§éªŒè¯ (TLA+)
```

**2. å¢é‡éªŒè¯**:

```rust
// å…ˆéªŒè¯æ ¸å¿ƒä¸å˜é‡
#[cfg(kani)]
#[kani::proof]
fn verify_core_invariant() {
    // æœ€é‡è¦çš„å±æ€§
}

// å†éªŒè¯è¾¹ç•Œæƒ…å†µ
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_edge_cases() {
    // è¾¹ç•Œæ¡ä»¶
}
```

### 4.3.9.2 æ€§èƒ½ä¼˜åŒ–

**é™åˆ¶æœç´¢ç©ºé—´**:

```rust
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // é™åˆ¶å¾ªç¯å±•å¼€
fn verify_bounded() {
    let n: u32 = kani::any();
    kani::assume(n < 100); // é™åˆ¶è¾“å…¥èŒƒå›´
    
    let result = expensive_function(n);
    assert!(result >= 0);
}
```

**ä½¿ç”¨æŠ½è±¡**:

```rust
// æŠ½è±¡å¤æ‚æ•°æ®ç»“æ„
#[cfg(kani)]
struct AbstractVec {
    len: usize,
    capacity: usize,
}

#[cfg(not(kani))]
type AbstractVec = Vec<i32>;
```

### 4.3.9.3 å¯ç»´æŠ¤æ€§

**æ–‡æ¡£åŒ–éªŒè¯æ„å›¾**:

```rust
/// éªŒè¯ç›®æ ‡: è¯æ˜æ•°ç»„è®¿é—®æ°¸ä¸è¶Šç•Œ
/// å‰ç½®æ¡ä»¶: index < arr.len()
/// åç½®æ¡ä»¶: è¿”å› arr[index]
#[cfg(kani)]
#[kani::proof]
fn verify_safe_access() {
    // ...
}
```

**æ¨¡å—åŒ–éªŒè¯**:

```rust
mod verified_core {
    // æ ¸å¿ƒé€»è¾‘,å·²éªŒè¯
}

mod unverified_wrapper {
    // å¤–å±‚å°è£…,å¯èƒ½æœªéªŒè¯
    use super::verified_core;
}
```

### 4.3.9.4 æŒç»­é›†æˆ

**GitHub Actions é›†æˆ**:

```yaml
name: Formal Verification

on: [push, pull_request]

jobs:
  kani:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Kani
        run: cargo install --locked kani-verifier
      - name: Run Kani
        run: cargo kani --harness verify_all

  prusti:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Prusti
        run: cargo install prusti-rustc
      - name: Run Prusti
        run: cargo-prusti
```

---

## 4.3.10 å½¢å¼åŒ–éªŒè¯ç†è®ºåŸºç¡€

> **ç« èŠ‚å®šä½**: æ·±å…¥ç†è§£å½¢å¼åŒ–éªŒè¯çš„æ•°å­¦åŸºç¡€å’Œç†è®ºæ¡†æ¶  
> **ç›®æ ‡è¯»è€…**: ç ”ç©¶è€…ã€é«˜çº§å·¥ç¨‹å¸ˆã€éœ€è¦ç†è®ºæ”¯æ’‘çš„æ¶æ„å¸ˆ  
> **å»ºè®®é˜…è¯»é¡ºåº**: å…ˆæŒæ¡å·¥å…·å®æˆ˜ï¼ˆ4.3.1-4.3.9ï¼‰ï¼Œå†æ·±å…¥ç†è®ºæ¡†æ¶

### 4.3.10.1 ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–

#### Rust ç±»å‹ç³»ç»Ÿçš„æ•°å­¦æ¨¡å‹

Rust çš„ç±»å‹ç³»ç»Ÿå¯ä»¥ç”¨**çº¿æ€§ç±»å‹ç†è®º** (Linear Type Theory) å’Œ**ä»¿å°„ç±»å‹** (Affine Types) æ¥å½¢å¼åŒ–æè¿°ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

```text
ç±»å‹åˆ¤æ–­è§„åˆ™ (Typing Rules):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Î“ âŠ¢ e : T    (åœ¨ä¸Šä¸‹æ–‡ Î“ ä¸­ï¼Œè¡¨è¾¾å¼ e çš„ç±»å‹ä¸º T)

æ‰€æœ‰æƒè½¬ç§»è§„åˆ™:
Î“ âŠ¢ x : T    x âˆˆ dom(Î“)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Î“ \ {x} âŠ¢ move x : T    (x ä» Î“ ä¸­ç§»é™¤)

å€Ÿç”¨è§„åˆ™:
Î“ âŠ¢ x : T    x âˆˆ dom(Î“)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Î“ âŠ¢ &x : &T    (x ä»ä¿ç•™åœ¨ Î“ ä¸­)
```

**å®ä¾‹åŒ–**:

```rust
// ç±»å‹ç†è®ºè§†è§’ä¸‹çš„æ‰€æœ‰æƒè½¬ç§»
fn transfer_ownership() {
    let s = String::from("hello"); // Î“â‚ = {s: String}
    let t = s;                      // Î“â‚‚ = {t: String}  (s å·²ä» Î“ ä¸­ç§»é™¤)
    // println!("{}", s);           // âŒ s âˆ‰ Î“â‚‚ï¼Œç±»å‹æ£€æŸ¥å¤±è´¥
    println!("{}", t);              // âœ… t âˆˆ Î“â‚‚ï¼Œç±»å‹æ£€æŸ¥é€šè¿‡
}

// å€Ÿç”¨çš„å½¢å¼åŒ–
fn borrow_semantics() {
    let s = String::from("hello"); // Î“ = {s: String}
    let r = &s;                     // Î“ = {s: String, r: &String}
    println!("{} {}", r, s);        // âœ… ä¸¤è€…éƒ½åœ¨ Î“ ä¸­
}
```

#### ç”Ÿå‘½å‘¨æœŸçš„å½¢å¼åŒ–

ç”Ÿå‘½å‘¨æœŸå¯ä»¥ç”¨**åŒºåŸŸç±»å‹ç³»ç»Ÿ** (Region Type System) è¡¨ç¤ºï¼š

```text
ç”Ÿå‘½å‘¨æœŸçº¦æŸ:
'a: 'b  è¡¨ç¤º 'a çš„ç”Ÿå‘½å‘¨æœŸè‡³å°‘å’Œ 'b ä¸€æ ·é•¿

å€Ÿç”¨æ£€æŸ¥è§„åˆ™:
Î“ âŠ¢ x : T    'a: 'b
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Î“ âŠ¢ &'a x : &'a T

ç”Ÿå‘½å‘¨æœŸæ¨å¯¼:
å¦‚æœ &'a T è¢«ç”¨ä½œ &'b Tï¼Œåˆ™å¿…é¡» 'a: 'b
```

**å®ä¾‹**:

```rust
// ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„å½¢å¼åŒ–
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ 'a å¿…é¡»æ»¡è¶³:
    // 'a â‰¤ 'x âˆ§ 'a â‰¤ 'y (å…¶ä¸­ 'x å’Œ 'y æ˜¯ x å’Œ y çš„å®é™…ç”Ÿå‘½å‘¨æœŸ)
    if x.len() > y.len() { x } else { y }
}

// ç”Ÿå‘½å‘¨æœŸæ¨å¯¼ç¤ºä¾‹
fn lifetime_inference() {
    let s1 = String::from("long string");
    {
        let s2 = String::from("short");
        // 'a è¢«æ¨å¯¼ä¸º min('s1, 's2) = 's2
        let result = longest(&s1, &s2);
        println!("{}", result); // âœ… result åœ¨ 's2 èŒƒå›´å†…
    }
    // result åœ¨è¿™é‡Œä¸å¯ç”¨ï¼Œå› ä¸º 's2 å·²ç»“æŸ
}
```

### 4.3.10.2 éœå°”é€»è¾‘ä¸ç¨‹åºéªŒè¯

#### éœå°”ä¸‰å…ƒç»„ (Hoare Triple)

å½¢å¼åŒ–éªŒè¯çš„æ ¸å¿ƒæ˜¯**éœå°”ä¸‰å…ƒç»„**: `{P} S {Q}`

- `P`: å‰ç½®æ¡ä»¶ (Precondition)
- `S`: ç¨‹åºè¯­å¥ (Statement)
- `Q`: åç½®æ¡ä»¶ (Postcondition)

**å«ä¹‰**: å¦‚æœ P åœ¨æ‰§è¡Œ S å‰æˆç«‹ï¼Œé‚£ä¹ˆ Q åœ¨æ‰§è¡Œ S åæˆç«‹ã€‚

#### Rust ä¸­çš„éœå°”é€»è¾‘åº”ç”¨

```rust
// ç¤ºä¾‹ï¼šæ•°ç»„æ±‚å’Œ
#[requires(arr.len() > 0)]  // å‰ç½®æ¡ä»¶
#[ensures(result == arr.iter().sum())]  // åç½®æ¡ä»¶
fn array_sum(arr: &[i32]) -> i32 {
    let mut sum = 0;
    // å¾ªç¯ä¸å˜é‡: sum == arr[0..i].iter().sum()
    for &x in arr {
        sum += x;
    }
    sum
}
```

**å½¢å¼åŒ–è¡¨ç¤º**:

```text
{arr.len() > 0}
    let mut sum = 0;
    for &x in arr {
        sum += x;
    }
{sum == arr.iter().sum()}
```

#### å¾ªç¯ä¸å˜é‡ (Loop Invariant)

å¾ªç¯ä¸å˜é‡æ˜¯è¯æ˜å¾ªç¯æ­£ç¡®æ€§çš„å…³é”®ï¼š

```rust
#[flux::sig(fn(n: i32{n >= 0}) -> i32{v: v == n * (n + 1) / 2})]
fn triangle_number(n: i32) -> i32 {
    let mut i = 0;
    let mut sum = 0;
    
    // å¾ªç¯ä¸å˜é‡: sum == i * (i + 1) / 2 âˆ§ i â‰¤ n
    while i < n {
        i += 1;
        sum += i;
    }
    
    // åç½®æ¡ä»¶: sum == n * (n + 1) / 2
    sum
}
```

**ä¸å˜é‡è¯æ˜**:

```text
åˆå§‹åŒ–: i = 0, sum = 0 âŸ¹ sum == i * (i + 1) / 2  âœ…

ç»´æŒ: å‡è®¾ sum == i * (i + 1) / 2
      æ‰§è¡Œ i += 1; sum += i;
      âŸ¹ sum_new = sum_old + i_new
                = i_old * (i_old + 1) / 2 + (i_old + 1)
                = (i_old + 1) * (i_old + 2) / 2
                = i_new * (i_new + 1) / 2  âœ…

ç»ˆæ­¢: i >= n âˆ§ sum == i * (i + 1) / 2
      âŸ¹ sum == n * (n + 1) / 2  âœ…
```

### 4.3.10.3 åˆ†ç¦»é€»è¾‘ (Separation Logic)

åˆ†ç¦»é€»è¾‘æ˜¯éªŒè¯æŒ‡é’ˆå’Œå †å†…å­˜çš„å¼ºå¤§å·¥å…·ã€‚

#### åˆ†ç¦»é€»è¾‘åŸºæœ¬æ¦‚å¿µ

**æ ¸å¿ƒè¿ç®—ç¬¦**:

- `P * Q`: åˆ†ç¦»åˆå– (Separating Conjunction) - P å’Œ Q åœ¨ä¸ç›¸äº¤çš„å†…å­˜åŒºåŸŸä¸­æˆç«‹
- `P --* Q`: åˆ†ç¦»è•´å« (Separating Implication) - é­”æ–æ“ä½œç¬¦
- `emp`: ç©ºå †
- `x â†¦ v`: x æŒ‡å‘çš„å†…å­˜å•å…ƒåŒ…å«å€¼ v

#### Rust ä¸­çš„åˆ†ç¦»é€»è¾‘åº”ç”¨

```rust
// åˆ†ç¦»é€»è¾‘è§†è§’ä¸‹çš„å€Ÿç”¨
fn separation_logic_example() {
    let mut x = 5;
    let mut y = 10;
    
    // å †çŠ¶æ€: x â†¦ 5 * y â†¦ 10  (åˆ†ç¦»çš„å†…å­˜åŒºåŸŸ)
    
    let r1 = &mut x;
    let r2 = &mut y;
    
    // æ–°å †çŠ¶æ€: r1 â†¦ x * r2 â†¦ y * x â†¦ 5 * y â†¦ 10
    // ä¸” r1 å’Œ r2 æŒ‡å‘ä¸ç›¸äº¤çš„å†…å­˜ï¼Œæ»¡è¶³åˆ†ç¦»é€»è¾‘
    
    *r1 += 1;  // x â†¦ 6
    *r2 += 1;  // y â†¦ 11
}
```

#### æ‰€æœ‰æƒè½¬ç§»çš„åˆ†ç¦»é€»è¾‘è¯æ˜

```text
æ‰€æœ‰æƒè½¬ç§»è§„åˆ™:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{x â†¦ v} let y = x; {y â†¦ v}

åˆ†ç¦»åˆå–è§„åˆ™:
{P * Q} Sâ‚ {P' * Q}    {P' * Q} Sâ‚‚ {P' * Q'}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{P * Q} Sâ‚; Sâ‚‚ {P' * Q'}
```

### 4.3.10.4 RustBeltï¼šRust å®‰å…¨æ€§çš„å½¢å¼åŒ–è¯æ˜

RustBelt æ˜¯ Rust ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–å®‰å…¨æ€§è¯æ˜é¡¹ç›®ã€‚

#### RustBelt æ ¸å¿ƒå®šç†

**ç±»å‹å®‰å…¨æ€§ (Type Safety)**:

```text
å®šç† (Progress): 
å¦‚æœ âŠ¢ e : T ä¸” e ä¸æ˜¯å€¼ (value)ï¼Œ
åˆ™å­˜åœ¨ e' ä½¿å¾— e â†’ e' (å¯ä»¥ç»§ç»­æ‰§è¡Œ)

å®šç† (Preservation):
å¦‚æœ âŠ¢ e : T ä¸” e â†’ e'ï¼Œ
åˆ™ âŠ¢ e' : T (ç±»å‹ä¿æŒä¸å˜)
```

**å†…å­˜å®‰å…¨æ€§**:

```text
å®šç† (Memory Safety):
å¯¹äºæ‰€æœ‰ç±»å‹è‰¯å¥½çš„ç¨‹åº e (âŠ¢ e : T)ï¼Œ
åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šå‘ç”Ÿ:
1. æ‚¬å‚æŒ‡é’ˆè§£å¼•ç”¨
2. äºŒæ¬¡é‡Šæ”¾ (double-free)
3. æ•°æ®ç«äº‰ (data race)
```

#### æ‰€æœ‰æƒçš„å½¢å¼åŒ–è¯æ˜

RustBelt ä½¿ç”¨ **Iris** (å¹¶å‘åˆ†ç¦»é€»è¾‘æ¡†æ¶) è¯æ˜äº†ä»¥ä¸‹å…³é”®æ€§è´¨ï¼š

```text
æ‰€æœ‰æƒè½¬ç§»çš„æ­£ç¡®æ€§:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âˆ€ x, T. {own(x, T)} move x {âŠ¥}
(æ‹¥æœ‰ x åè½¬ç§»ï¼Œx å˜ä¸ºä¸å¯è®¿é—®)

å€Ÿç”¨çš„æ­£ç¡®æ€§:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âˆ€ x, T. {own(x, T)} &x {own(x, T) * borrow(x, T)}
(å€Ÿç”¨åˆ›å»ºä¸´æ—¶çš„å€Ÿç”¨ä»¤ç‰Œï¼ŒåŸæ‰€æœ‰æƒä¿ç•™)

å¯å˜å€Ÿç”¨çš„ç‹¬å æ€§:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âˆ€ x, T. {own(x, T)} &mut x {mut_borrow(x, T)}
(å¯å˜å€Ÿç”¨è½¬ç§»å®Œå…¨æ§åˆ¶æƒï¼Œç›´åˆ°å€Ÿç”¨ç»“æŸ)
```

### 4.3.10.5 æ¨¡å‹æ£€æŸ¥ç†è®º

#### çŠ¶æ€ç©ºé—´æ¢ç´¢

æ¨¡å‹æ£€æŸ¥é€šè¿‡æ¢ç´¢ç¨‹åºçš„æ‰€æœ‰å¯èƒ½çŠ¶æ€æ¥éªŒè¯æ€§è´¨ã€‚

**çŠ¶æ€è½¬ç§»ç³»ç»Ÿ (Transition System)**:

```text
TS = (S, Sâ‚€, â†’, AP, L)
å…¶ä¸­:
- S: çŠ¶æ€é›†åˆ
- Sâ‚€ âŠ† S: åˆå§‹çŠ¶æ€é›†
- â†’: è½¬ç§»å…³ç³» (S Ã— S)
- AP: åŸå­å‘½é¢˜é›†
- L: çŠ¶æ€æ ‡è®°å‡½æ•° (S â†’ 2^AP)
```

#### Rust ç¨‹åºçš„çŠ¶æ€ç©ºé—´

```rust
// çŠ¶æ€ç©ºé—´ç¤ºä¾‹
fn state_space_example() {
    let mut x = 0;  // åˆå§‹çŠ¶æ€ Sâ‚€: {x=0}
    
    if condition() {
        x = 1;      // çŠ¶æ€ Sâ‚: {x=1}
    } else {
        x = 2;      // çŠ¶æ€ Sâ‚‚: {x=2}
    }
    
    // æœ€ç»ˆçŠ¶æ€: Sâ‚ âˆª Sâ‚‚ = {x=1} âˆª {x=2}
}
```

**æœ‰ç•Œæ¨¡å‹æ£€æŸ¥ (Bounded Model Checking)**:

Kani ä½¿ç”¨ BMC æ–¹æ³•ï¼Œåœ¨æœ‰é™æ·±åº¦ k å†…æ¢ç´¢çŠ¶æ€ç©ºé—´ï¼š

```text
BMC(Ï†, k) â‰¡ Init(sâ‚€) âˆ§ â‹€áµ¢â‚Œâ‚€áµâ»Â¹ Trans(sáµ¢, sáµ¢â‚Šâ‚) âˆ§ â‹áµ¢â‚Œâ‚€áµ Â¬Ï†(sáµ¢)

å¦‚æœ BMC(Ï†, k) ä¸å¯æ»¡è¶³ï¼Œåˆ™ Ï† åœ¨æ·±åº¦ k å†…æˆç«‹
```

### 4.3.10.6 æ—¶åºé€»è¾‘ (Temporal Logic)

#### çº¿æ€§æ—¶åºé€»è¾‘ (LTL)

LTL ç”¨äºæè¿°ç¨‹åºæ‰§è¡Œè·¯å¾„ä¸Šçš„æ€§è´¨ã€‚

**LTL åŸºæœ¬æ“ä½œç¬¦**:

- `â—¯ Ï†`: Next (ä¸‹ä¸€ä¸ªçŠ¶æ€ Ï† æˆç«‹)
- `â—‡ Ï†`: Eventually (æœ€ç»ˆ Ï† ä¼šæˆç«‹)
- `â–¡ Ï†`: Always (Ï† å§‹ç»ˆæˆç«‹)
- `Ï† U Ïˆ`: Until (Ï† ä¸€ç›´æˆç«‹ç›´åˆ° Ïˆ æˆç«‹)

**Rust å¹¶å‘æ€§è´¨çš„ LTL è¡¨ç¤º**:

```rust
// LTL æ€§è´¨ç¤ºä¾‹
#[kani::proof]
fn ltl_property() {
    let mutex = Arc::new(Mutex::new(0));
    
    // æ€§è´¨: â–¡ (locked â†’ â—‡ unlocked)
    // (å¦‚æœé”è¢«æŒæœ‰ï¼Œæœ€ç»ˆä¼šè¢«é‡Šæ”¾)
    {
        let _guard = mutex.lock().unwrap();
        // locked çŠ¶æ€
    } // â—‡ unlocked (guard è¢«é‡Šæ”¾)
    
    // éªŒè¯å±æ€§ï¼šæ— æ­»é”
    // â–¡ â—‡ (âˆ€ threads. can_proceed)
}
```

### 4.3.10.7 å¯è¾¾æ€§åˆ†æ

#### ä¸å˜é‡æ¨å¯¼

è‡ªåŠ¨æ¨å¯¼ç¨‹åºä¸å˜é‡æ˜¯éªŒè¯çš„å…³é”®ã€‚

**æŠ½è±¡è§£é‡Š (Abstract Interpretation)**:

```text
å…·ä½“åŸŸ (Concrete Domain):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
x âˆˆ â„¤ (æ‰€æœ‰æ•´æ•°)

æŠ½è±¡åŸŸ (Abstract Domain):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
x âˆˆ {âŠ¤, [a,b], âŠ¥}
(åŒºé—´æŠ½è±¡)

æŠ½è±¡å‡½æ•° Î±: 2^â„¤ â†’ Intervals
å…·ä½“åŒ–å‡½æ•° Î³: Intervals â†’ 2^â„¤
```

**Rust ä¸­çš„åº”ç”¨**:

```rust
#[flux::sig(fn(x: i32{0 <= x && x <= 100}) -> i32{v: 0 <= v && v <= 200})]
fn double_in_range(x: i32) -> i32 {
    // æŠ½è±¡è§£é‡Š:
    // x âˆˆ [0, 100]
    // 2 * x âˆˆ [0, 200]  (åŒºé—´è¿ç®—)
    2 * x
}
```

### 4.3.10.8 å½¢å¼åŒ–æ–¹æ³•çš„å±€é™æ€§ä¸å®è·µå»ºè®®

#### ç†è®ºå±€é™

| å±€é™ | æè¿° | ç¼“è§£ç­–ç•¥ |
|------|------|---------|
| **ä¸å®Œå¤‡æ€§** | æ— æ³•éªŒè¯æ‰€æœ‰æ€§è´¨ (å“¥å¾·å°”ä¸å®Œå¤‡å®šç†) | èšç„¦å…³é”®æ€§è´¨ |
| **çŠ¶æ€çˆ†ç‚¸** | çŠ¶æ€ç©ºé—´æŒ‡æ•°å¢é•¿ | æŠ½è±¡ç®€åŒ–ã€ç¬¦å·æ‰§è¡Œ |
| **è§„çº¦å›°éš¾** | æ­£ç¡®ç¼–å†™è§„çº¦éœ€è¦ä¸“ä¸šçŸ¥è¯† | æ¨¡æ¿åº“ã€å·¥å…·è¾…åŠ© |
| **æ€§èƒ½å¼€é”€** | éªŒè¯æ—¶é—´å¯èƒ½å¾ˆé•¿ | å¢é‡éªŒè¯ã€æ¨¡å—åŒ– |

#### å®è·µå»ºè®®

**å±‚æ¬¡åŒ–éªŒè¯ç­–ç•¥**:

```text
Level 1: ç±»å‹ç³»ç»Ÿ (100% è¦†ç›–)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… ç¼–è¯‘å™¨è‡ªåŠ¨æ£€æŸ¥
âœ… é›¶è¿è¡Œæ—¶å¼€é”€
âœ… æ•è·å¤§å¤šæ•°å†…å­˜å®‰å…¨é—®é¢˜

Level 2: Loom å¹¶å‘æµ‹è¯• (å…³é”®è·¯å¾„)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… å¹¶å‘è¡Œä¸ºéªŒè¯
âœ… å¿«é€Ÿåé¦ˆ
âš ï¸  éœ€è¦æ‰‹åŠ¨ç¼–å†™æµ‹è¯•

Level 3: Kani æœ‰ç•Œæ¨¡å‹æ£€æŸ¥ (æ ¸å¿ƒç®—æ³•)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… æ·±åº¦éªŒè¯
âœ… æ‰¾åˆ°è¾¹ç•Œæƒ…å†µ
âš ï¸  éªŒè¯æ—¶é—´è¾ƒé•¿

Level 4: Prusti æ¼”ç»éªŒè¯ (å®‰å…¨å…³é”®)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… å®Œæ•´æ­£ç¡®æ€§è¯æ˜
âœ… æœ€é«˜ä¿è¯
âš ï¸  éœ€è¦ä¸“ä¸šçŸ¥è¯†
```

**ROI è¯„ä¼°**:

| é¡¹ç›®ç±»å‹ | æ¨èéªŒè¯çº§åˆ« | ROI |
|---------|------------|-----|
| **Web åº”ç”¨** | Level 1 | æœ€é«˜ |
| **æ¸¸æˆå¼•æ“** | Level 1-2 | é«˜ |
| **é‡‘èç³»ç»Ÿ** | Level 1-3 | ä¸­é«˜ |
| **åŒ»ç–—è®¾å¤‡** | Level 1-4 | ä¸­ (å¿…è¦æˆæœ¬) |
| **èˆªç©ºèˆªå¤©** | Level 1-4 | ä½ (ä½†å¿…é¡») |

---

## 4.3.11 å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Kani Rust Verifier](https://model-checking.github.io/kani/)
- [Prusti](https://www.pm.inf.ethz.ch/research/prusti.html)
- [Creusot](https://github.com/xldenis/creusot)
- [MIRAI](https://github.com/facebookexperimental/MIRAI)

**å­¦æœ¯è®ºæ–‡**:

- "RustBelt: Securing the Foundations of the Rust Programming Language"
- "Prusti: Deductive Verification for Rust"
- "Leveraging Rust Types for Modular Specification and Verification"

**å½¢å¼åŒ–ç†è®º**:

- "Separation Logic: A Logic for Shared Mutable Data Structures"
- "The Iris Project: Higher-Order Concurrent Separation Logic"
- "Abstract Interpretation: A Unified Lattice Model"

**ç›¸å…³æ–‡æ¡£**:

- [analysis/01_formal_verification_framework.md](../analysis/rust190_ecosystem/01_formal_verification/formal_verification_framework.md) - æ·±åº¦ç†è®ºåˆ†æ
- [4.1 è¿›é˜¶ä¸»é¢˜é›†](4.1_è¿›é˜¶ä¸»é¢˜é›†.md)
- [4.2 è·¨è¡Œä¸šåº”ç”¨åˆ†æ](4.2_è·¨è¡Œä¸šåº”ç”¨åˆ†æ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æŠ¥å‘Šå®Œæˆæ—¶é—´**: 2025-10-21  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å½¢å¼åŒ–éªŒè¯ç ”ç©¶ç»„

---

**ğŸ¯ å½¢å¼åŒ–éªŒè¯ï¼Œä¿éšœRustä»£ç ç»å¯¹æ­£ç¡®ï¼**
