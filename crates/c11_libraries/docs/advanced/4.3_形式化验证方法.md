# 4.3 Rust 形式化验证方法 (2025-10-21)

> **文档定位**: Rust 形式化验证工具链与最佳实践  
> **适用人群**: 安全关键系统开发者、形式化方法研究者  
> **关联文档**: [4.1 进阶主题集](4.1_进阶主题集.md) | [4.2 行业应用](4.2_跨行业应用分析.md) | [1.1 主索引](../1.1_主索引导航.md)

**最后更新**: 2025-10-21  
**Rust 版本**: 1.90  
**文档状态**: ✅ 生产就绪

---

## 📋 目录

- [4.3 Rust 形式化验证方法 (2025-10-21)](#43-rust-形式化验证方法-2025-10-21)
  - [📋 目录](#-目录)
  - [4.3.1 形式化验证概述](#431-形式化验证概述)
    - [4.3.1.1 什么是形式化验证](#4311-什么是形式化验证)
    - [4.3.1.2 为什么需要形式化验证](#4312-为什么需要形式化验证)
    - [4.3.1.3 形式化验证方法分类](#4313-形式化验证方法分类)
    - [4.3.1.4 Rust 与形式化验证](#4314-rust-与形式化验证)
  - [4.3.2 Kani 验证器](#432-kani-验证器)
    - [4.3.2.1 Kani 简介](#4321-kani-简介)
    - [4.3.2.2 安装与配置](#4322-安装与配置)
    - [4.3.2.3 基础验证示例](#4323-基础验证示例)
    - [4.3.2.4 高级验证技术](#4324-高级验证技术)
  - [4.3.3 Prusti 验证工具](#433-prusti-验证工具)
    - [4.3.3.1 Prusti 架构](#4331-prusti-架构)
    - [4.3.3.2 规格说明语言](#4332-规格说明语言)
    - [4.3.3.3 不变量与断言](#4333-不变量与断言)
    - [4.3.3.4 函数契约](#4334-函数契约)
  - [4.3.4 MIRAI 抽象解释](#434-mirai-抽象解释)
    - [4.3.4.1 MIRAI 原理](#4341-mirai-原理)
    - [4.3.4.2 使用 MIRAI](#4342-使用-mirai)
    - [4.3.4.3 标签传播](#4343-标签传播)
    - [4.3.4.4 数据流分析](#4344-数据流分析)
  - [4.3.5 Creusot 演绎验证](#435-creusot-演绎验证)
    - [4.3.5.1 Creusot 简介](#4351-creusot-简介)
    - [4.3.5.2 Why3 集成](#4352-why3-集成)
    - [4.3.5.3 证明策略](#4353-证明策略)
    - [4.3.5.4 复杂数据结构验证](#4354-复杂数据结构验证)
  - [4.3.6 模型检测方法](#436-模型检测方法)
    - [4.3.6.1 TLA+ 与 Rust](#4361-tla-与-rust)
    - [4.3.6.2 并发协议验证](#4362-并发协议验证)
    - [4.3.6.3 分布式系统验证](#4363-分布式系统验证)
    - [4.3.6.4 Loom 并发测试](#4364-loom-并发测试)
  - [4.3.7 符号执行](#437-符号执行)
    - [4.3.7.1 符号执行原理](#4371-符号执行原理)
    - [4.3.7.2 KLEE 与 Rust](#4372-klee-与-rust)
    - [4.3.7.3 路径爆炸问题](#4373-路径爆炸问题)
    - [4.3.7.4 约束求解](#4374-约束求解)
  - [4.3.8 安全关键系统实践](#438-安全关键系统实践)
    - [4.3.8.1 航空航天应用](#4381-航空航天应用)
    - [4.3.8.2 医疗设备](#4382-医疗设备)
    - [4.3.8.3 金融系统](#4383-金融系统)
    - [4.3.8.4 工业控制](#4384-工业控制)
  - [4.3.9 验证最佳实践](#439-验证最佳实践)
    - [4.3.9.1 验证策略](#4391-验证策略)
    - [4.3.9.2 性能优化](#4392-性能优化)
    - [4.3.9.3 可维护性](#4393-可维护性)
    - [4.3.9.4 持续集成](#4394-持续集成)
  - [4.3.10 参考资源](#4310-参考资源)

---

## 4.3.1 形式化验证概述

### 4.3.1.1 什么是形式化验证

**定义**:

形式化验证是使用数学方法证明程序正确性的技术，不同于传统测试只能验证特定输入，形式化验证能够证明程序对所有可能输入都满足规格说明。

**核心概念**:

1. **规格说明 (Specification)**: 用形式化语言描述程序应该做什么
2. **证明 (Proof)**: 数学证明程序实现满足规格
3. **完全性 (Soundness)**: 如果证明通过，程序一定正确
4. **完备性 (Completeness)**: 如果程序正确，证明一定能通过

### 4.3.1.2 为什么需要形式化验证

**传统测试的局限性**:

```rust
// 测试只能覆盖有限案例
#[cfg(test)]
mod tests {
    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
        assert_eq!(add(0, 0), 0);
        assert_eq!(add(-1, 1), 0);
        // 无法测试所有可能的 i32 组合
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b // 可能溢出！
}
```

**形式化验证的优势**:

```rust
// 使用 Kani 验证所有可能的输入
#[cfg(kani)]
#[kani::proof]
fn verify_add() {
    let a: i32 = kani::any();
    let b: i32 = kani::any();
    
    if let Some(result) = a.checked_add(b) {
        assert!(result >= a || b < 0);
        assert!(result >= b || a < 0);
    }
}
```

**适用场景**:

1. ✅ **安全关键系统**: 航空、医疗、金融
2. ✅ **密码学**: 加密算法正确性
3. ✅ **并发系统**: 无数据竞争、死锁
4. ✅ **内存安全**: 无越界、无悬垂指针

### 4.3.1.3 形式化验证方法分类

**1. 模型检测 (Model Checking)**:

- 穷举所有可能状态
- 适用于有限状态系统
- 工具: TLA+, SPIN

**2. 定理证明 (Theorem Proving)**:

- 交互式证明
- 适用于复杂数学证明
- 工具: Coq, Isabelle/HOL

**3. 符号执行 (Symbolic Execution)**:

- 符号化执行路径
- 发现程序错误
- 工具: KLEE, angr

**4. 抽象解释 (Abstract Interpretation)**:

- 静态分析
- 快速但不完全
- 工具: MIRAI

**5. 有界模型检测 (Bounded Model Checking)**:

- SAT/SMT 求解器
- 平衡完全性和性能
- 工具: Kani, CBMC

### 4.3.1.4 Rust 与形式化验证

**Rust 的优势**:

1. **类型安全**: 类型系统已经是一种轻量级验证
2. **所有权模型**: 自动防止内存错误
3. **无空指针**: 消除一大类错误
4. **显式错误处理**: `Result` 和 `Option`

**仍需验证的**:

1. **算术溢出**: `i32::MAX + 1` 会 panic
2. **逻辑错误**: 算法实现错误
3. **并发错误**: 数据竞争、死锁
4. **unsafe 代码**: 绕过类型系统

---

## 4.3.2 Kani 验证器

### 4.3.2.1 Kani 简介

**Kani** 是 AWS 开发的 Rust 有界模型检测工具，基于 CBMC (C Bounded Model Checker)。

**特点**:

- ✅ 完全自动化
- ✅ 无需标注
- ✅ 支持标准库
- ✅ 快速反馈

**架构**:

```text
[Rust 源码] → [rustc + Kani] → [MIR] → [CBMC] → [SMT Solver] → [验证结果]
```

### 4.3.2.2 安装与配置

**安装 Kani**:

```bash
cargo install --locked kani-verifier
cargo kani setup
```

**项目配置**:

```toml
# Cargo.toml
[package]
name = "my-verified-crate"
version = "0.1.0"

[dev-dependencies]
kani-verifier = "0.34"
```

### 4.3.2.3 基础验证示例

**示例 1: 验证除法**:

```rust
// src/lib.rs

/// 安全除法
pub fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        a.checked_div(b)
    }
}

#[cfg(kani)]
mod verification {
    use super::*;
    
    #[kani::proof]
    fn verify_safe_divide() {
        let a: i32 = kani::any();
        let b: i32 = kani::any();
        
        match safe_divide(a, b) {
            Some(result) => {
                // 如果返回结果，验证正确性
                if b != 0 {
                    assert!(result * b == a || (a == i32::MIN && b == -1));
                }
            }
            None => {
                // 如果返回 None，b 必须为 0
                assert!(b == 0);
            }
        }
    }
}
```

**运行验证**:

```bash
cargo kani --harness verify_safe_divide
```

**示例 2: 验证数组边界**:

```rust
pub fn get_element(arr: &[i32], index: usize) -> Option<i32> {
    if index < arr.len() {
        Some(arr[index])
    } else {
        None
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // 限制循环展开次数
fn verify_get_element() {
    let arr: [i32; 5] = kani::any();
    let index: usize = kani::any();
    
    match get_element(&arr, index) {
        Some(value) => {
            assert!(index < 5);
            assert!(value == arr[index]);
        }
        None => {
            assert!(index >= 5);
        }
    }
}
```

### 4.3.2.4 高级验证技术

**验证数据结构不变量**:

```rust
pub struct BoundedStack {
    data: Vec<i32>,
    capacity: usize,
}

impl BoundedStack {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    pub fn push(&mut self, value: i32) -> Result<(), &'static str> {
        if self.data.len() < self.capacity {
            self.data.push(value);
            Ok(())
        } else {
            Err("Stack full")
        }
    }
    
    pub fn pop(&mut self) -> Option<i32> {
        self.data.pop()
    }
    
    // 不变量: len() <= capacity
    fn check_invariant(&self) -> bool {
        self.data.len() <= self.capacity
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_bounded_stack() {
    let capacity = 3;
    let mut stack = BoundedStack::new(capacity);
    
    // 验证初始状态
    assert!(stack.check_invariant());
    
    // 验证 push 操作
    for _ in 0..3 {
        let value: i32 = kani::any();
        if stack.push(value).is_ok() {
            assert!(stack.check_invariant());
        }
    }
    
    // 验证 pop 操作
    while let Some(_) = stack.pop() {
        assert!(stack.check_invariant());
    }
}
```

**验证并发代码**:

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

#[cfg(kani)]
#[kani::proof]
fn verify_atomic_counter() {
    let counter = Arc::new(AtomicUsize::new(0));
    
    let c1 = counter.clone();
    let c2 = counter.clone();
    
    // Kani 会探索所有可能的交错执行
    kani::concurrency::thread_spawn(move || {
        c1.fetch_add(1, Ordering::SeqCst);
    });
    
    kani::concurrency::thread_spawn(move || {
        c2.fetch_add(1, Ordering::SeqCst);
    });
    
    // 最终值应该是 2
    let final_value = counter.load(Ordering::SeqCst);
    assert!(final_value <= 2);
}
```

---

## 4.3.3 Prusti 验证工具

### 4.3.3.1 Prusti 架构

**Prusti** 是基于 Viper 验证基础设施的 Rust 验证工具。

**架构**:

```text
[Rust 源码 + 规格] → [Prusti] → [Viper IL] → [SMT Solver] → [验证结果]
```

**特点**:

- ✅ 演绎验证
- ✅ 函数契约
- ✅ 不变量表达
- ✅ 完全自动化证明

### 4.3.3.2 规格说明语言

**安装 Prusti**:

```bash
cargo install prusti-rustc prusti-server
```

**基础规格**:

```rust
use prusti_contracts::*;

#[requires(x >= 0)]
#[ensures(result >= x)]
fn increment(x: i32) -> i32 {
    x + 1
}

#[requires(a > 0 && b > 0)]
#[ensures(result > 0)]
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

**验证运行**:

```bash
cargo-prusti
```

### 4.3.3.3 不变量与断言

**循环不变量**:

```rust
use prusti_contracts::*;

#[requires(arr.len() > 0)]
#[ensures(result >= 0 && result < arr.len())]
#[ensures(forall(|i: usize| (i < arr.len()) ==> arr[result] >= arr[i]))]
fn find_max_index(arr: &[i32]) -> usize {
    let mut max_idx = 0;
    let mut i = 1;
    
    #[invariant(max_idx < arr.len())]
    #[invariant(i <= arr.len())]
    #[invariant(forall(|j: usize| (j < i) ==> arr[max_idx] >= arr[j]))]
    while i < arr.len() {
        if arr[i] > arr[max_idx] {
            max_idx = i;
        }
        i += 1;
    }
    
    max_idx
}
```

**数据结构不变量**:

```rust
use prusti_contracts::*;

struct Counter {
    value: u32,
}

#[invariant(self.value < 100)]
impl Counter {
    #[ensures(result.value == 0)]
    fn new() -> Self {
        Self { value: 0 }
    }
    
    #[requires(self.value < 99)]
    #[ensures(self.value == old(self.value) + 1)]
    fn increment(&mut self) {
        self.value += 1;
    }
    
    #[pure]
    fn get(&self) -> u32 {
        self.value
    }
}
```

### 4.3.3.4 函数契约

**前置条件与后置条件**:

```rust
use prusti_contracts::*;

#[requires(n > 0)]
#[ensures(result > 0)]
#[ensures(result == n * factorial(n - 1))] // 递归规格
fn factorial(n: u64) -> u64 {
    if n == 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

#[requires(arr.len() > 0)]
#[requires(target >= arr[0] && target <= arr[arr.len() - 1])]
#[ensures(result.is_some() ==> arr[result.unwrap()] == target)]
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut low = 0;
    let mut high = arr.len();
    
    #[invariant(low <= high)]
    #[invariant(high <= arr.len())]
    while low < high {
        let mid = low + (high - low) / 2;
        
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    None
}
```

**纯函数标记**:

```rust
use prusti_contracts::*;

#[pure]
#[requires(arr.len() > 0)]
fn sum(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

#[requires(arr.len() > 0)]
#[ensures(result == sum(arr))]
fn compute_total(arr: &[i32]) -> i32 {
    let mut total = 0;
    let mut i = 0;
    
    #[invariant(i <= arr.len())]
    #[invariant(total == sum(&arr[0..i]))]
    while i < arr.len() {
        total += arr[i];
        i += 1;
    }
    
    total
}
```

---

## 4.3.4 MIRAI 抽象解释

### 4.3.4.1 MIRAI 原理

**MIRAI** (Mid-level Intermediate Representation Abstract Interpreter) 是 Facebook 开发的静态分析工具。

**特点**:

- ✅ 快速分析
- ✅ 可扩展
- ✅ 无需标注
- ⚠️ 可能误报

### 4.3.4.2 使用 MIRAI

**安装**:

```bash
cargo install mirai
```

**基础使用**:

```rust
// src/lib.rs

pub fn divide(a: i32, b: i32) -> i32 {
    // MIRAI 会检测潜在的除零错误
    a / b
}

pub fn access_array(arr: &[i32], index: usize) -> i32 {
    // MIRAI 会检测潜在的越界访问
    arr[index]
}

pub fn dereference_option(opt: Option<&i32>) -> i32 {
    // MIRAI 会检测潜在的 panic
    *opt.unwrap()
}
```

**运行 MIRAI**:

```bash
cargo mirai
```

### 4.3.4.3 标签传播

**污点分析**:

```rust
use mirai_annotations::*;

pub fn process_user_input(input: String) -> String {
    // 标记为不受信任的输入
    add_tag!(&input, TagPropagationSet::tainted());
    
    // MIRAI 会追踪污点传播
    let processed = sanitize(input);
    
    // 验证已清理
    verify_tag!(&processed, TagPropagationSet::sanitized());
    
    processed
}

fn sanitize(input: String) -> String {
    // 清理逻辑
    input.replace("<", "&lt;").replace(">", "&gt;")
}
```

### 4.3.4.4 数据流分析

**空指针检测**:

```rust
pub fn safe_access(opt: Option<&i32>) -> i32 {
    match opt {
        Some(value) => *value,
        None => 0,
    }
}

pub fn unsafe_access(opt: Option<&i32>) -> i32 {
    // MIRAI 警告: 潜在的 panic
    *opt.unwrap()
}
```

---

## 4.3.5 Creusot 演绎验证

### 4.3.5.1 Creusot 简介

**Creusot** 是一个将 Rust 程序转换为 Why3 逻辑的工具，支持演绎验证。

**特点**:

- ✅ 强大的证明能力
- ✅ 支持复杂数据结构
- ✅ 可交互证明
- ⚠️ 学习曲线陡峭

### 4.3.5.2 Why3 集成

**安装**:

```bash
# 安装 Why3
opam install why3

# 安装 Creusot
cargo install creusot
```

**基础验证**:

```rust
use creusot_contracts::*;

#[requires(x < 100)]
#[ensures(result == x + 1)]
fn increment(x: u32) -> u32 {
    x + 1
}

#[requires(a.len() > 0)]
#[ensures(result.is_some() ==> exists(|i: usize| i < a.len() && a[i] == x))]
fn find(a: &[i32], x: i32) -> Option<usize> {
    for i in 0..a.len() {
        if a[i] == x {
            return Some(i);
        }
    }
    None
}
```

### 4.3.5.3 证明策略

**手动证明提示**:

```rust
use creusot_contracts::*;

#[logic]
fn sum_range(a: Seq<i32>, l: Int, r: Int) -> Int {
    if l >= r {
        0
    } else {
        a[l] + sum_range(a, l + 1, r)
    }
}

#[requires(v.len() > 0)]
#[ensures(result == sum_range(v@, 0, v.len()@))]
fn sum(v: &Vec<i32>) -> i32 {
    let mut s = 0;
    let mut i = 0;
    
    #[invariant(inv, i@<= v.len()@)]
    #[invariant(sum_inv, s@ == sum_range(v@, 0, i@))]
    while i < v.len() {
        s += v[i];
        i += 1;
        
        // 证明提示
        proof_assert!(s@ == sum_range(v@, 0, i@));
    }
    
    s
}
```

### 4.3.5.4 复杂数据结构验证

**链表验证**:

```rust
use creusot_contracts::*;

struct Node {
    value: i32,
    next: Option<Box<Node>>,
}

#[logic]
fn list_len(node: Option<&Node>) -> Int {
    match node {
        None => 0,
        Some(n) => 1 + list_len(n.next.as_deref()),
    }
}

impl Node {
    #[ensures(list_len(Some(&result)) == 1)]
    fn new(value: i32) -> Self {
        Self {
            value,
            next: None,
        }
    }
    
    #[ensures(list_len(Some(self)) == old(list_len(Some(self))) + 1)]
    fn append(&mut self, value: i32) {
        let mut current = self;
        
        #[invariant(len_inv, list_len(Some(current)) >= 1)]
        loop {
            match current.next {
                Some(ref mut next) => {
                    current = next;
                }
                None => {
                    current.next = Some(Box::new(Node::new(value)));
                    break;
                }
            }
        }
    }
}
```

---

## 4.3.6 模型检测方法

### 4.3.6.1 TLA+ 与 Rust

**TLA+ 规格说明**:

```tla
---- MODULE Counter ----
EXTENDS Integers

VARIABLE counter

Init == counter = 0

Increment == counter' = counter + 1

Decrement == counter' = counter - 1

Next == Increment \/ Decrement

Spec == Init /\ [][Next]_counter

TypeInv == counter \in Int

====
```

**Rust 实现**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct Counter {
    value: AtomicI32,
}

impl Counter {
    pub fn new() -> Self {
        Self {
            value: AtomicI32::new(0),
        }
    }
    
    pub fn increment(&self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }
    
    pub fn decrement(&self) {
        self.value.fetch_sub(1, Ordering::SeqCst);
    }
    
    pub fn get(&self) -> i32 {
        self.value.load(Ordering::SeqCst)
    }
}
```

### 4.3.6.2 并发协议验证

**使用 Loom 验证并发代码**:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_increment() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));
        
        let threads: Vec<_> = (0..2)
            .map(|_| {
                let counter = counter.clone();
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::SeqCst);
                })
            })
            .collect();
        
        for t in threads {
            t.join().unwrap();
        }
        
        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

### 4.3.6.3 分布式系统验证

**Raft 共识算法验证** (简化):

```rust
#[derive(Debug, Clone, PartialEq)]
enum ServerState {
    Follower,
    Candidate,
    Leader,
}

struct RaftServer {
    state: ServerState,
    term: u64,
    voted_for: Option<u64>,
}

impl RaftServer {
    // 规格: 在同一 term 内只能投票一次
    fn request_vote(&mut self, candidate_id: u64, term: u64) -> bool {
        if term > self.term {
            self.term = term;
            self.voted_for = None;
        }
        
        if term == self.term && self.voted_for.is_none() {
            self.voted_for = Some(candidate_id);
            true
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn verify_single_vote_per_term() {
        let mut server = RaftServer {
            state: ServerState::Follower,
            term: 1,
            voted_for: None,
        };
        
        // 第一次投票应该成功
        assert!(server.request_vote(1, 1));
        
        // 同一 term 内的第二次投票应该失败
        assert!(!server.request_vote(2, 1));
    }
}
```

### 4.3.6.4 Loom 并发测试

**测试无锁栈**:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head
                .compare_exchange(head, new_node, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                break;
            }
        }
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            if self.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}

#[cfg(test)]
mod loom_tests {
    use super::*;
    use loom::thread;
    
    #[test]
    fn test_concurrent_push_pop() {
        loom::model(|| {
            let stack = Arc::new(Stack::new());
            
            let s1 = stack.clone();
            let t1 = thread::spawn(move || {
                s1.push(1);
                s1.push(2);
            });
            
            let s2 = stack.clone();
            let t2 = thread::spawn(move || {
                let _ = s2.pop();
                let _ = s2.pop();
            });
            
            t1.join().unwrap();
            t2.join().unwrap();
        });
    }
}
```

---

## 4.3.7 符号执行

### 4.3.7.1 符号执行原理

**符号执行** 使用符号值而非具体值执行程序，探索所有可能的执行路径。

**示例**:

```rust
fn example(x: i32) -> i32 {
    if x > 10 {
        x * 2
    } else {
        x + 5
    }
}

// 符号执行会探索两条路径:
// 路径 1: x > 10  → 返回 x * 2
// 路径 2: x <= 10 → 返回 x + 5
```

### 4.3.7.2 KLEE 与 Rust

**使用 KLEE** (通过 LLVM IR):

```rust
// 生成 LLVM IR
// rustc --emit=llvm-ir example.rs

#[no_mangle]
pub extern "C" fn test_function(x: i32, y: i32) -> i32 {
    if x > 0 && y > 0 {
        x + y
    } else if x < 0 && y < 0 {
        x * y
    } else {
        0
    }
}
```

**KLEE 命令**:

```bash
# 编译为 LLVM IR
rustc --emit=llvm-ir test.rs

# 运行 KLEE
klee test.ll
```

### 4.3.7.3 路径爆炸问题

**问题示例**:

```rust
fn path_explosion(arr: &[i32]) -> i32 {
    let mut sum = 0;
    
    // 10 个 if 语句 → 2^10 = 1024 条路径
    if arr[0] > 0 { sum += arr[0]; }
    if arr[1] > 0 { sum += arr[1]; }
    if arr[2] > 0 { sum += arr[2]; }
    // ... 更多条件
    
    sum
}
```

**缓解策略**:

1. **路径剪枝**: 合并相似路径
2. **启发式搜索**: 优先探索重要路径
3. **约束缓存**: 重用求解结果
4. **抽象**: 简化路径条件

### 4.3.7.4 约束求解

**SMT 求解器使用** (使用 Z3):

```rust
use z3::*;

fn solve_constraints() {
    let cfg = Config::new();
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);
    
    // 创建变量
    let x = Int::new_const(&ctx, "x");
    let y = Int::new_const(&ctx, "y");
    
    // 添加约束
    solver.assert(&x.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&y.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&x._eq(&y.mul(&Int::from_i64(&ctx, 2))));
    
    // 求解
    match solver.check() {
        SatResult::Sat => {
            let model = solver.get_model().unwrap();
            println!("x = {}", model.eval(&x, true).unwrap());
            println!("y = {}", model.eval(&y, true).unwrap());
        }
        _ => println!("No solution"),
    }
}
```

---

## 4.3.8 安全关键系统实践

### 4.3.8.1 航空航天应用

**DO-178C 认证**:

```rust
// 关键飞行控制代码
#[cfg(kani)]
#[kani::proof]
fn verify_altitude_control() {
    let current_altitude: f64 = kani::any();
    let target_altitude: f64 = kani::any();
    
    kani::assume(current_altitude >= 0.0 && current_altitude <= 50000.0);
    kani::assume(target_altitude >= 0.0 && target_altitude <= 50000.0);
    
    let control_signal = compute_control_signal(current_altitude, target_altitude);
    
    // 验证控制信号在安全范围内
    assert!(control_signal.abs() <= MAX_CONTROL_SIGNAL);
}

fn compute_control_signal(current: f64, target: f64) -> f64 {
    const KP: f64 = 0.1;
    let error = target - current;
    KP * error
}

const MAX_CONTROL_SIGNAL: f64 = 10.0;
```

### 4.3.8.2 医疗设备

**IEC 62304 标准**:

```rust
use prusti_contracts::*;

struct InsulinPump {
    dose_rate: f64, // 单位: units/hour
    max_rate: f64,
    min_rate: f64,
}

#[invariant(self.dose_rate >= self.min_rate && self.dose_rate <= self.max_rate)]
impl InsulinPump {
    #[ensures(result.dose_rate == 0.0)]
    #[ensures(result.max_rate == 10.0)]
    #[ensures(result.min_rate == 0.0)]
    fn new() -> Self {
        Self {
            dose_rate: 0.0,
            max_rate: 10.0,
            min_rate: 0.0,
        }
    }
    
    #[requires(new_rate >= self.min_rate && new_rate <= self.max_rate)]
    #[ensures(self.dose_rate == new_rate)]
    fn set_dose_rate(&mut self, new_rate: f64) {
        self.dose_rate = new_rate;
    }
    
    #[pure]
    fn get_dose_rate(&self) -> f64 {
        self.dose_rate
    }
}
```

### 4.3.8.3 金融系统

**交易系统验证**:

```rust
#[cfg(kani)]
#[kani::proof]
fn verify_trade_settlement() {
    let account_balance: i64 = kani::any();
    let trade_amount: i64 = kani::any();
    
    kani::assume(account_balance >= 0);
    kani::assume(trade_amount >= 0);
    
    match settle_trade(account_balance, trade_amount) {
        Some(new_balance) => {
            // 验证余额正确更新
            assert!(new_balance == account_balance - trade_amount);
            assert!(new_balance >= 0);
        }
        None => {
            // 验证余额不足时拒绝交易
            assert!(account_balance < trade_amount);
        }
    }
}

fn settle_trade(balance: i64, amount: i64) -> Option<i64> {
    balance.checked_sub(amount)
}
```

### 4.3.8.4 工业控制

**PLC 控制逻辑**:

```rust
struct PLCController {
    temperature: f32,
    pressure: f32,
    valve_open: bool,
}

impl PLCController {
    fn control_loop(&mut self) {
        // 安全规则: 如果温度或压力超限，关闭阀门
        if self.temperature > 100.0 || self.pressure > 10.0 {
            self.valve_open = false;
        }
    }
}

#[cfg(kani)]
#[kani::proof]
fn verify_safety_shutdown() {
    let mut controller = PLCController {
        temperature: kani::any(),
        pressure: kani::any(),
        valve_open: true,
    };
    
    kani::assume(controller.temperature >= 0.0 && controller.temperature <= 200.0);
    kani::assume(controller.pressure >= 0.0 && controller.pressure <= 20.0);
    
    controller.control_loop();
    
    // 验证安全属性
    if controller.temperature > 100.0 || controller.pressure > 10.0 {
        assert!(!controller.valve_open);
    }
}
```

---

## 4.3.9 验证最佳实践

### 4.3.9.1 验证策略

**1. 分层验证**:

```text
Layer 1: 单元函数验证 (Kani)
Layer 2: 模块不变量验证 (Prusti)
Layer 3: 系统级属性验证 (TLA+)
```

**2. 增量验证**:

```rust
// 先验证核心不变量
#[cfg(kani)]
#[kani::proof]
fn verify_core_invariant() {
    // 最重要的属性
}

// 再验证边界情况
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_edge_cases() {
    // 边界条件
}
```

### 4.3.9.2 性能优化

**限制搜索空间**:

```rust
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // 限制循环展开
fn verify_bounded() {
    let n: u32 = kani::any();
    kani::assume(n < 100); // 限制输入范围
    
    let result = expensive_function(n);
    assert!(result >= 0);
}
```

**使用抽象**:

```rust
// 抽象复杂数据结构
#[cfg(kani)]
struct AbstractVec {
    len: usize,
    capacity: usize,
}

#[cfg(not(kani))]
type AbstractVec = Vec<i32>;
```

### 4.3.9.3 可维护性

**文档化验证意图**:

```rust
/// 验证目标: 证明数组访问永不越界
/// 前置条件: index < arr.len()
/// 后置条件: 返回 arr[index]
#[cfg(kani)]
#[kani::proof]
fn verify_safe_access() {
    // ...
}
```

**模块化验证**:

```rust
mod verified_core {
    // 核心逻辑,已验证
}

mod unverified_wrapper {
    // 外层封装,可能未验证
    use super::verified_core;
}
```

### 4.3.9.4 持续集成

**GitHub Actions 集成**:

```yaml
name: Formal Verification

on: [push, pull_request]

jobs:
  kani:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Kani
        run: cargo install --locked kani-verifier
      - name: Run Kani
        run: cargo kani --harness verify_all

  prusti:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Prusti
        run: cargo install prusti-rustc
      - name: Run Prusti
        run: cargo-prusti
```

---

## 4.3.10 参考资源

**官方文档**:

- [Kani Rust Verifier](https://model-checking.github.io/kani/)
- [Prusti](https://www.pm.inf.ethz.ch/research/prusti.html)
- [Creusot](https://github.com/xldenis/creusot)
- [MIRAI](https://github.com/facebookexperimental/MIRAI)

**学术论文**:

- "RustBelt: Securing the Foundations of the Rust Programming Language"
- "Prusti: Deductive Verification for Rust"
- "Leveraging Rust Types for Modular Specification and Verification"

**相关文档**:

- [4.1 进阶主题集](4.1_进阶主题集.md)
- [4.2 跨行业应用分析](4.2_跨行业应用分析.md)
- [1.1 主索引导航](../1.1_主索引导航.md)

---

**报告完成时间**: 2025-10-21  
**文档版本**: v1.0  
**下次更新**: 2026-01-21  
**维护团队**: Rust 形式化验证研究组

---

**🎯 形式化验证，保障Rust代码绝对正确！**
