# 4.3 Rust å½¢å¼åŒ–éªŒè¯æ–¹æ³• (2025-10-21)

> **æ–‡æ¡£å®šä½**: Rust å½¢å¼åŒ–éªŒè¯å·¥å…·é“¾ä¸æœ€ä½³å®è·µ  
> **é€‚ç”¨äººç¾¤**: å®‰å…¨å…³é”®ç³»ç»Ÿå¼€å‘è€…ã€å½¢å¼åŒ–æ–¹æ³•ç ”ç©¶è€…  
> **å…³è”æ–‡æ¡£**: [4.1 è¿›é˜¶ä¸»é¢˜é›†](4.1_è¿›é˜¶ä¸»é¢˜é›†.md) | [4.2 è¡Œä¸šåº”ç”¨](4.2_è·¨è¡Œä¸šåº”ç”¨åˆ†æ.md) | [1.1 ä¸»ç´¢å¼•](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æœ€åæ›´æ–°**: 2025-10-21  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [4.3 Rust å½¢å¼åŒ–éªŒè¯æ–¹æ³• (2025-10-21)](#43-rust-å½¢å¼åŒ–éªŒè¯æ–¹æ³•-2025-10-21)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [4.3.1 å½¢å¼åŒ–éªŒè¯æ¦‚è¿°](#431-å½¢å¼åŒ–éªŒè¯æ¦‚è¿°)
    - [4.3.1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯](#4311-ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯)
    - [4.3.1.2 ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯](#4312-ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯)
    - [4.3.1.3 å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»](#4313-å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»)
    - [4.3.1.4 Rust ä¸å½¢å¼åŒ–éªŒè¯](#4314-rust-ä¸å½¢å¼åŒ–éªŒè¯)
  - [4.3.2 Kani éªŒè¯å™¨](#432-kani-éªŒè¯å™¨)
    - [4.3.2.1 Kani ç®€ä»‹](#4321-kani-ç®€ä»‹)
    - [4.3.2.2 å®‰è£…ä¸é…ç½®](#4322-å®‰è£…ä¸é…ç½®)
    - [4.3.2.3 åŸºç¡€éªŒè¯ç¤ºä¾‹](#4323-åŸºç¡€éªŒè¯ç¤ºä¾‹)
    - [4.3.2.4 é«˜çº§éªŒè¯æŠ€æœ¯](#4324-é«˜çº§éªŒè¯æŠ€æœ¯)
  - [4.3.3 Prusti éªŒè¯å·¥å…·](#433-prusti-éªŒè¯å·¥å…·)
    - [4.3.3.1 Prusti æ¶æ„](#4331-prusti-æ¶æ„)
    - [4.3.3.2 è§„æ ¼è¯´æ˜è¯­è¨€](#4332-è§„æ ¼è¯´æ˜è¯­è¨€)
    - [4.3.3.3 ä¸å˜é‡ä¸æ–­è¨€](#4333-ä¸å˜é‡ä¸æ–­è¨€)
    - [4.3.3.4 å‡½æ•°å¥‘çº¦](#4334-å‡½æ•°å¥‘çº¦)
  - [4.3.4 MIRAI æŠ½è±¡è§£é‡Š](#434-mirai-æŠ½è±¡è§£é‡Š)
    - [4.3.4.1 MIRAI åŸç†](#4341-mirai-åŸç†)
    - [4.3.4.2 ä½¿ç”¨ MIRAI](#4342-ä½¿ç”¨-mirai)
    - [4.3.4.3 æ ‡ç­¾ä¼ æ’­](#4343-æ ‡ç­¾ä¼ æ’­)
    - [4.3.4.4 æ•°æ®æµåˆ†æ](#4344-æ•°æ®æµåˆ†æ)
  - [4.3.5 Creusot æ¼”ç»éªŒè¯](#435-creusot-æ¼”ç»éªŒè¯)
    - [4.3.5.1 Creusot ç®€ä»‹](#4351-creusot-ç®€ä»‹)
    - [4.3.5.2 Why3 é›†æˆ](#4352-why3-é›†æˆ)
    - [4.3.5.3 è¯æ˜ç­–ç•¥](#4353-è¯æ˜ç­–ç•¥)
    - [4.3.5.4 å¤æ‚æ•°æ®ç»“æ„éªŒè¯](#4354-å¤æ‚æ•°æ®ç»“æ„éªŒè¯)
  - [4.3.6 æ¨¡å‹æ£€æµ‹æ–¹æ³•](#436-æ¨¡å‹æ£€æµ‹æ–¹æ³•)
    - [4.3.6.1 TLA+ ä¸ Rust](#4361-tla-ä¸-rust)
    - [4.3.6.2 å¹¶å‘åè®®éªŒè¯](#4362-å¹¶å‘åè®®éªŒè¯)
    - [4.3.6.3 åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯](#4363-åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯)
    - [4.3.6.4 Loom å¹¶å‘æµ‹è¯•](#4364-loom-å¹¶å‘æµ‹è¯•)
  - [4.3.7 ç¬¦å·æ‰§è¡Œ](#437-ç¬¦å·æ‰§è¡Œ)
    - [4.3.7.1 ç¬¦å·æ‰§è¡ŒåŸç†](#4371-ç¬¦å·æ‰§è¡ŒåŸç†)
    - [4.3.7.2 KLEE ä¸ Rust](#4372-klee-ä¸-rust)
    - [4.3.7.3 è·¯å¾„çˆ†ç‚¸é—®é¢˜](#4373-è·¯å¾„çˆ†ç‚¸é—®é¢˜)
    - [4.3.7.4 çº¦æŸæ±‚è§£](#4374-çº¦æŸæ±‚è§£)
  - [4.3.8 å®‰å…¨å…³é”®ç³»ç»Ÿå®è·µ](#438-å®‰å…¨å…³é”®ç³»ç»Ÿå®è·µ)
    - [4.3.8.1 èˆªç©ºèˆªå¤©åº”ç”¨](#4381-èˆªç©ºèˆªå¤©åº”ç”¨)
    - [4.3.8.2 åŒ»ç–—è®¾å¤‡](#4382-åŒ»ç–—è®¾å¤‡)
    - [4.3.8.3 é‡‘èç³»ç»Ÿ](#4383-é‡‘èç³»ç»Ÿ)
    - [4.3.8.4 å·¥ä¸šæ§åˆ¶](#4384-å·¥ä¸šæ§åˆ¶)
  - [4.3.9 éªŒè¯æœ€ä½³å®è·µ](#439-éªŒè¯æœ€ä½³å®è·µ)
    - [4.3.9.1 éªŒè¯ç­–ç•¥](#4391-éªŒè¯ç­–ç•¥)
    - [4.3.9.2 æ€§èƒ½ä¼˜åŒ–](#4392-æ€§èƒ½ä¼˜åŒ–)
    - [4.3.9.3 å¯ç»´æŠ¤æ€§](#4393-å¯ç»´æŠ¤æ€§)
    - [4.3.9.4 æŒç»­é›†æˆ](#4394-æŒç»­é›†æˆ)
  - [4.3.10 å‚è€ƒèµ„æº](#4310-å‚è€ƒèµ„æº)

---

## 4.3.1 å½¢å¼åŒ–éªŒè¯æ¦‚è¿°

### 4.3.1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯

**å®šä¹‰**:

å½¢å¼åŒ–éªŒè¯æ˜¯ä½¿ç”¨æ•°å­¦æ–¹æ³•è¯æ˜ç¨‹åºæ­£ç¡®æ€§çš„æŠ€æœ¯ï¼Œä¸åŒäºä¼ ç»Ÿæµ‹è¯•åªèƒ½éªŒè¯ç‰¹å®šè¾“å…¥ï¼Œå½¢å¼åŒ–éªŒè¯èƒ½å¤Ÿè¯æ˜ç¨‹åºå¯¹æ‰€æœ‰å¯èƒ½è¾“å…¥éƒ½æ»¡è¶³è§„æ ¼è¯´æ˜ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

1. **è§„æ ¼è¯´æ˜ (Specification)**: ç”¨å½¢å¼åŒ–è¯­è¨€æè¿°ç¨‹åºåº”è¯¥åšä»€ä¹ˆ
2. **è¯æ˜ (Proof)**: æ•°å­¦è¯æ˜ç¨‹åºå®ç°æ»¡è¶³è§„æ ¼
3. **å®Œå…¨æ€§ (Soundness)**: å¦‚æœè¯æ˜é€šè¿‡ï¼Œç¨‹åºä¸€å®šæ­£ç¡®
4. **å®Œå¤‡æ€§ (Completeness)**: å¦‚æœç¨‹åºæ­£ç¡®ï¼Œè¯æ˜ä¸€å®šèƒ½é€šè¿‡

### 4.3.1.2 ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯

**ä¼ ç»Ÿæµ‹è¯•çš„å±€é™æ€§**:

```rust
// æµ‹è¯•åªèƒ½è¦†ç›–æœ‰é™æ¡ˆä¾‹
#[cfg(test)]
mod tests {
    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
        assert_eq!(add(0, 0), 0);
        assert_eq!(add(-1, 1), 0);
        // æ— æ³•æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„ i32 ç»„åˆ
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b // å¯èƒ½æº¢å‡ºï¼
}
```

**å½¢å¼åŒ–éªŒè¯çš„ä¼˜åŠ¿**:

```rust
// ä½¿ç”¨ Kani éªŒè¯æ‰€æœ‰å¯èƒ½çš„è¾“å…¥
#[cfg(kani)]
#[kani::proof]
fn verify_add() {
    let a: i32 = kani::any();
    let b: i32 = kani::any();
    
    if let Some(result) = a.checked_add(b) {
        assert!(result >= a || b < 0);
        assert!(result >= b || a < 0);
    }
}
```

**é€‚ç”¨åœºæ™¯**:

1. âœ… **å®‰å…¨å…³é”®ç³»ç»Ÿ**: èˆªç©ºã€åŒ»ç–—ã€é‡‘è
2. âœ… **å¯†ç å­¦**: åŠ å¯†ç®—æ³•æ­£ç¡®æ€§
3. âœ… **å¹¶å‘ç³»ç»Ÿ**: æ— æ•°æ®ç«äº‰ã€æ­»é”
4. âœ… **å†…å­˜å®‰å…¨**: æ— è¶Šç•Œã€æ— æ‚¬å‚æŒ‡é’ˆ

### 4.3.1.3 å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»

**1. æ¨¡å‹æ£€æµ‹ (Model Checking)**:

- ç©·ä¸¾æ‰€æœ‰å¯èƒ½çŠ¶æ€
- é€‚ç”¨äºæœ‰é™çŠ¶æ€ç³»ç»Ÿ
- å·¥å…·: TLA+, SPIN

**2. å®šç†è¯æ˜ (Theorem Proving)**:

- äº¤äº’å¼è¯æ˜
- é€‚ç”¨äºå¤æ‚æ•°å­¦è¯æ˜
- å·¥å…·: Coq, Isabelle/HOL

**3. ç¬¦å·æ‰§è¡Œ (Symbolic Execution)**:

- ç¬¦å·åŒ–æ‰§è¡Œè·¯å¾„
- å‘ç°ç¨‹åºé”™è¯¯
- å·¥å…·: KLEE, angr

**4. æŠ½è±¡è§£é‡Š (Abstract Interpretation)**:

- é™æ€åˆ†æ
- å¿«é€Ÿä½†ä¸å®Œå…¨
- å·¥å…·: MIRAI

**5. æœ‰ç•Œæ¨¡å‹æ£€æµ‹ (Bounded Model Checking)**:

- SAT/SMT æ±‚è§£å™¨
- å¹³è¡¡å®Œå…¨æ€§å’Œæ€§èƒ½
- å·¥å…·: Kani, CBMC

### 4.3.1.4 Rust ä¸å½¢å¼åŒ–éªŒè¯

**Rust çš„ä¼˜åŠ¿**:

1. **ç±»å‹å®‰å…¨**: ç±»å‹ç³»ç»Ÿå·²ç»æ˜¯ä¸€ç§è½»é‡çº§éªŒè¯
2. **æ‰€æœ‰æƒæ¨¡å‹**: è‡ªåŠ¨é˜²æ­¢å†…å­˜é”™è¯¯
3. **æ— ç©ºæŒ‡é’ˆ**: æ¶ˆé™¤ä¸€å¤§ç±»é”™è¯¯
4. **æ˜¾å¼é”™è¯¯å¤„ç†**: `Result` å’Œ `Option`

**ä»éœ€éªŒè¯çš„**:

1. **ç®—æœ¯æº¢å‡º**: `i32::MAX + 1` ä¼š panic
2. **é€»è¾‘é”™è¯¯**: ç®—æ³•å®ç°é”™è¯¯
3. **å¹¶å‘é”™è¯¯**: æ•°æ®ç«äº‰ã€æ­»é”
4. **unsafe ä»£ç **: ç»•è¿‡ç±»å‹ç³»ç»Ÿ

---

## 4.3.2 Kani éªŒè¯å™¨

### 4.3.2.1 Kani ç®€ä»‹

**Kani** æ˜¯ AWS å¼€å‘çš„ Rust æœ‰ç•Œæ¨¡å‹æ£€æµ‹å·¥å…·ï¼ŒåŸºäº CBMC (C Bounded Model Checker)ã€‚

**ç‰¹ç‚¹**:

- âœ… å®Œå…¨è‡ªåŠ¨åŒ–
- âœ… æ— éœ€æ ‡æ³¨
- âœ… æ”¯æŒæ ‡å‡†åº“
- âœ… å¿«é€Ÿåé¦ˆ

**æ¶æ„**:

```text
[Rust æºç ] â†’ [rustc + Kani] â†’ [MIR] â†’ [CBMC] â†’ [SMT Solver] â†’ [éªŒè¯ç»“æœ]
```

### 4.3.2.2 å®‰è£…ä¸é…ç½®

**å®‰è£… Kani**:

```bash
cargo install --locked kani-verifier
cargo kani setup
```

**é¡¹ç›®é…ç½®**:

```toml
# Cargo.toml
[package]
name = "my-verified-crate"
version = "0.1.0"

[dev-dependencies]
kani-verifier = "0.34"
```

### 4.3.2.3 åŸºç¡€éªŒè¯ç¤ºä¾‹

**ç¤ºä¾‹ 1: éªŒè¯é™¤æ³•**:

```rust
// src/lib.rs

/// å®‰å…¨é™¤æ³•
pub fn safe_divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        a.checked_div(b)
    }
}

#[cfg(kani)]
mod verification {
    use super::*;
    
    #[kani::proof]
    fn verify_safe_divide() {
        let a: i32 = kani::any();
        let b: i32 = kani::any();
        
        match safe_divide(a, b) {
            Some(result) => {
                // å¦‚æœè¿”å›ç»“æœï¼ŒéªŒè¯æ­£ç¡®æ€§
                if b != 0 {
                    assert!(result * b == a || (a == i32::MIN && b == -1));
                }
            }
            None => {
                // å¦‚æœè¿”å› Noneï¼Œb å¿…é¡»ä¸º 0
                assert!(b == 0);
            }
        }
    }
}
```

**è¿è¡ŒéªŒè¯**:

```bash
cargo kani --harness verify_safe_divide
```

**ç¤ºä¾‹ 2: éªŒè¯æ•°ç»„è¾¹ç•Œ**:

```rust
pub fn get_element(arr: &[i32], index: usize) -> Option<i32> {
    if index < arr.len() {
        Some(arr[index])
    } else {
        None
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // é™åˆ¶å¾ªç¯å±•å¼€æ¬¡æ•°
fn verify_get_element() {
    let arr: [i32; 5] = kani::any();
    let index: usize = kani::any();
    
    match get_element(&arr, index) {
        Some(value) => {
            assert!(index < 5);
            assert!(value == arr[index]);
        }
        None => {
            assert!(index >= 5);
        }
    }
}
```

### 4.3.2.4 é«˜çº§éªŒè¯æŠ€æœ¯

**éªŒè¯æ•°æ®ç»“æ„ä¸å˜é‡**:

```rust
pub struct BoundedStack {
    data: Vec<i32>,
    capacity: usize,
}

impl BoundedStack {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    pub fn push(&mut self, value: i32) -> Result<(), &'static str> {
        if self.data.len() < self.capacity {
            self.data.push(value);
            Ok(())
        } else {
            Err("Stack full")
        }
    }
    
    pub fn pop(&mut self) -> Option<i32> {
        self.data.pop()
    }
    
    // ä¸å˜é‡: len() <= capacity
    fn check_invariant(&self) -> bool {
        self.data.len() <= self.capacity
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_bounded_stack() {
    let capacity = 3;
    let mut stack = BoundedStack::new(capacity);
    
    // éªŒè¯åˆå§‹çŠ¶æ€
    assert!(stack.check_invariant());
    
    // éªŒè¯ push æ“ä½œ
    for _ in 0..3 {
        let value: i32 = kani::any();
        if stack.push(value).is_ok() {
            assert!(stack.check_invariant());
        }
    }
    
    // éªŒè¯ pop æ“ä½œ
    while let Some(_) = stack.pop() {
        assert!(stack.check_invariant());
    }
}
```

**éªŒè¯å¹¶å‘ä»£ç **:

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

#[cfg(kani)]
#[kani::proof]
fn verify_atomic_counter() {
    let counter = Arc::new(AtomicUsize::new(0));
    
    let c1 = counter.clone();
    let c2 = counter.clone();
    
    // Kani ä¼šæ¢ç´¢æ‰€æœ‰å¯èƒ½çš„äº¤é”™æ‰§è¡Œ
    kani::concurrency::thread_spawn(move || {
        c1.fetch_add(1, Ordering::SeqCst);
    });
    
    kani::concurrency::thread_spawn(move || {
        c2.fetch_add(1, Ordering::SeqCst);
    });
    
    // æœ€ç»ˆå€¼åº”è¯¥æ˜¯ 2
    let final_value = counter.load(Ordering::SeqCst);
    assert!(final_value <= 2);
}
```

---

## 4.3.3 Prusti éªŒè¯å·¥å…·

### 4.3.3.1 Prusti æ¶æ„

**Prusti** æ˜¯åŸºäº Viper éªŒè¯åŸºç¡€è®¾æ–½çš„ Rust éªŒè¯å·¥å…·ã€‚

**æ¶æ„**:

```text
[Rust æºç  + è§„æ ¼] â†’ [Prusti] â†’ [Viper IL] â†’ [SMT Solver] â†’ [éªŒè¯ç»“æœ]
```

**ç‰¹ç‚¹**:

- âœ… æ¼”ç»éªŒè¯
- âœ… å‡½æ•°å¥‘çº¦
- âœ… ä¸å˜é‡è¡¨è¾¾
- âœ… å®Œå…¨è‡ªåŠ¨åŒ–è¯æ˜

### 4.3.3.2 è§„æ ¼è¯´æ˜è¯­è¨€

**å®‰è£… Prusti**:

```bash
cargo install prusti-rustc prusti-server
```

**åŸºç¡€è§„æ ¼**:

```rust
use prusti_contracts::*;

#[requires(x >= 0)]
#[ensures(result >= x)]
fn increment(x: i32) -> i32 {
    x + 1
}

#[requires(a > 0 && b > 0)]
#[ensures(result > 0)]
fn multiply(a: i32, b: i32) -> i32 {
    a * b
}
```

**éªŒè¯è¿è¡Œ**:

```bash
cargo-prusti
```

### 4.3.3.3 ä¸å˜é‡ä¸æ–­è¨€

**å¾ªç¯ä¸å˜é‡**:

```rust
use prusti_contracts::*;

#[requires(arr.len() > 0)]
#[ensures(result >= 0 && result < arr.len())]
#[ensures(forall(|i: usize| (i < arr.len()) ==> arr[result] >= arr[i]))]
fn find_max_index(arr: &[i32]) -> usize {
    let mut max_idx = 0;
    let mut i = 1;
    
    #[invariant(max_idx < arr.len())]
    #[invariant(i <= arr.len())]
    #[invariant(forall(|j: usize| (j < i) ==> arr[max_idx] >= arr[j]))]
    while i < arr.len() {
        if arr[i] > arr[max_idx] {
            max_idx = i;
        }
        i += 1;
    }
    
    max_idx
}
```

**æ•°æ®ç»“æ„ä¸å˜é‡**:

```rust
use prusti_contracts::*;

struct Counter {
    value: u32,
}

#[invariant(self.value < 100)]
impl Counter {
    #[ensures(result.value == 0)]
    fn new() -> Self {
        Self { value: 0 }
    }
    
    #[requires(self.value < 99)]
    #[ensures(self.value == old(self.value) + 1)]
    fn increment(&mut self) {
        self.value += 1;
    }
    
    #[pure]
    fn get(&self) -> u32 {
        self.value
    }
}
```

### 4.3.3.4 å‡½æ•°å¥‘çº¦

**å‰ç½®æ¡ä»¶ä¸åç½®æ¡ä»¶**:

```rust
use prusti_contracts::*;

#[requires(n > 0)]
#[ensures(result > 0)]
#[ensures(result == n * factorial(n - 1))] // é€’å½’è§„æ ¼
fn factorial(n: u64) -> u64 {
    if n == 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

#[requires(arr.len() > 0)]
#[requires(target >= arr[0] && target <= arr[arr.len() - 1])]
#[ensures(result.is_some() ==> arr[result.unwrap()] == target)]
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut low = 0;
    let mut high = arr.len();
    
    #[invariant(low <= high)]
    #[invariant(high <= arr.len())]
    while low < high {
        let mid = low + (high - low) / 2;
        
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    None
}
```

**çº¯å‡½æ•°æ ‡è®°**:

```rust
use prusti_contracts::*;

#[pure]
#[requires(arr.len() > 0)]
fn sum(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

#[requires(arr.len() > 0)]
#[ensures(result == sum(arr))]
fn compute_total(arr: &[i32]) -> i32 {
    let mut total = 0;
    let mut i = 0;
    
    #[invariant(i <= arr.len())]
    #[invariant(total == sum(&arr[0..i]))]
    while i < arr.len() {
        total += arr[i];
        i += 1;
    }
    
    total
}
```

---

## 4.3.4 MIRAI æŠ½è±¡è§£é‡Š

### 4.3.4.1 MIRAI åŸç†

**MIRAI** (Mid-level Intermediate Representation Abstract Interpreter) æ˜¯ Facebook å¼€å‘çš„é™æ€åˆ†æå·¥å…·ã€‚

**ç‰¹ç‚¹**:

- âœ… å¿«é€Ÿåˆ†æ
- âœ… å¯æ‰©å±•
- âœ… æ— éœ€æ ‡æ³¨
- âš ï¸ å¯èƒ½è¯¯æŠ¥

### 4.3.4.2 ä½¿ç”¨ MIRAI

**å®‰è£…**:

```bash
cargo install mirai
```

**åŸºç¡€ä½¿ç”¨**:

```rust
// src/lib.rs

pub fn divide(a: i32, b: i32) -> i32 {
    // MIRAI ä¼šæ£€æµ‹æ½œåœ¨çš„é™¤é›¶é”™è¯¯
    a / b
}

pub fn access_array(arr: &[i32], index: usize) -> i32 {
    // MIRAI ä¼šæ£€æµ‹æ½œåœ¨çš„è¶Šç•Œè®¿é—®
    arr[index]
}

pub fn dereference_option(opt: Option<&i32>) -> i32 {
    // MIRAI ä¼šæ£€æµ‹æ½œåœ¨çš„ panic
    *opt.unwrap()
}
```

**è¿è¡Œ MIRAI**:

```bash
cargo mirai
```

### 4.3.4.3 æ ‡ç­¾ä¼ æ’­

**æ±¡ç‚¹åˆ†æ**:

```rust
use mirai_annotations::*;

pub fn process_user_input(input: String) -> String {
    // æ ‡è®°ä¸ºä¸å—ä¿¡ä»»çš„è¾“å…¥
    add_tag!(&input, TagPropagationSet::tainted());
    
    // MIRAI ä¼šè¿½è¸ªæ±¡ç‚¹ä¼ æ’­
    let processed = sanitize(input);
    
    // éªŒè¯å·²æ¸…ç†
    verify_tag!(&processed, TagPropagationSet::sanitized());
    
    processed
}

fn sanitize(input: String) -> String {
    // æ¸…ç†é€»è¾‘
    input.replace("<", "&lt;").replace(">", "&gt;")
}
```

### 4.3.4.4 æ•°æ®æµåˆ†æ

**ç©ºæŒ‡é’ˆæ£€æµ‹**:

```rust
pub fn safe_access(opt: Option<&i32>) -> i32 {
    match opt {
        Some(value) => *value,
        None => 0,
    }
}

pub fn unsafe_access(opt: Option<&i32>) -> i32 {
    // MIRAI è­¦å‘Š: æ½œåœ¨çš„ panic
    *opt.unwrap()
}
```

---

## 4.3.5 Creusot æ¼”ç»éªŒè¯

### 4.3.5.1 Creusot ç®€ä»‹

**Creusot** æ˜¯ä¸€ä¸ªå°† Rust ç¨‹åºè½¬æ¢ä¸º Why3 é€»è¾‘çš„å·¥å…·ï¼Œæ”¯æŒæ¼”ç»éªŒè¯ã€‚

**ç‰¹ç‚¹**:

- âœ… å¼ºå¤§çš„è¯æ˜èƒ½åŠ›
- âœ… æ”¯æŒå¤æ‚æ•°æ®ç»“æ„
- âœ… å¯äº¤äº’è¯æ˜
- âš ï¸ å­¦ä¹ æ›²çº¿é™¡å³­

### 4.3.5.2 Why3 é›†æˆ

**å®‰è£…**:

```bash
# å®‰è£… Why3
opam install why3

# å®‰è£… Creusot
cargo install creusot
```

**åŸºç¡€éªŒè¯**:

```rust
use creusot_contracts::*;

#[requires(x < 100)]
#[ensures(result == x + 1)]
fn increment(x: u32) -> u32 {
    x + 1
}

#[requires(a.len() > 0)]
#[ensures(result.is_some() ==> exists(|i: usize| i < a.len() && a[i] == x))]
fn find(a: &[i32], x: i32) -> Option<usize> {
    for i in 0..a.len() {
        if a[i] == x {
            return Some(i);
        }
    }
    None
}
```

### 4.3.5.3 è¯æ˜ç­–ç•¥

**æ‰‹åŠ¨è¯æ˜æç¤º**:

```rust
use creusot_contracts::*;

#[logic]
fn sum_range(a: Seq<i32>, l: Int, r: Int) -> Int {
    if l >= r {
        0
    } else {
        a[l] + sum_range(a, l + 1, r)
    }
}

#[requires(v.len() > 0)]
#[ensures(result == sum_range(v@, 0, v.len()@))]
fn sum(v: &Vec<i32>) -> i32 {
    let mut s = 0;
    let mut i = 0;
    
    #[invariant(inv, i@<= v.len()@)]
    #[invariant(sum_inv, s@ == sum_range(v@, 0, i@))]
    while i < v.len() {
        s += v[i];
        i += 1;
        
        // è¯æ˜æç¤º
        proof_assert!(s@ == sum_range(v@, 0, i@));
    }
    
    s
}
```

### 4.3.5.4 å¤æ‚æ•°æ®ç»“æ„éªŒè¯

**é“¾è¡¨éªŒè¯**:

```rust
use creusot_contracts::*;

struct Node {
    value: i32,
    next: Option<Box<Node>>,
}

#[logic]
fn list_len(node: Option<&Node>) -> Int {
    match node {
        None => 0,
        Some(n) => 1 + list_len(n.next.as_deref()),
    }
}

impl Node {
    #[ensures(list_len(Some(&result)) == 1)]
    fn new(value: i32) -> Self {
        Self {
            value,
            next: None,
        }
    }
    
    #[ensures(list_len(Some(self)) == old(list_len(Some(self))) + 1)]
    fn append(&mut self, value: i32) {
        let mut current = self;
        
        #[invariant(len_inv, list_len(Some(current)) >= 1)]
        loop {
            match current.next {
                Some(ref mut next) => {
                    current = next;
                }
                None => {
                    current.next = Some(Box::new(Node::new(value)));
                    break;
                }
            }
        }
    }
}
```

---

## 4.3.6 æ¨¡å‹æ£€æµ‹æ–¹æ³•

### 4.3.6.1 TLA+ ä¸ Rust

**TLA+ è§„æ ¼è¯´æ˜**:

```tla
---- MODULE Counter ----
EXTENDS Integers

VARIABLE counter

Init == counter = 0

Increment == counter' = counter + 1

Decrement == counter' = counter - 1

Next == Increment \/ Decrement

Spec == Init /\ [][Next]_counter

TypeInv == counter \in Int

====
```

**Rust å®ç°**:

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct Counter {
    value: AtomicI32,
}

impl Counter {
    pub fn new() -> Self {
        Self {
            value: AtomicI32::new(0),
        }
    }
    
    pub fn increment(&self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }
    
    pub fn decrement(&self) {
        self.value.fetch_sub(1, Ordering::SeqCst);
    }
    
    pub fn get(&self) -> i32 {
        self.value.load(Ordering::SeqCst)
    }
}
```

### 4.3.6.2 å¹¶å‘åè®®éªŒè¯

**ä½¿ç”¨ Loom éªŒè¯å¹¶å‘ä»£ç **:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_increment() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));
        
        let threads: Vec<_> = (0..2)
            .map(|_| {
                let counter = counter.clone();
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::SeqCst);
                })
            })
            .collect();
        
        for t in threads {
            t.join().unwrap();
        }
        
        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

### 4.3.6.3 åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯

**Raft å…±è¯†ç®—æ³•éªŒè¯** (ç®€åŒ–):

```rust
#[derive(Debug, Clone, PartialEq)]
enum ServerState {
    Follower,
    Candidate,
    Leader,
}

struct RaftServer {
    state: ServerState,
    term: u64,
    voted_for: Option<u64>,
}

impl RaftServer {
    // è§„æ ¼: åœ¨åŒä¸€ term å†…åªèƒ½æŠ•ç¥¨ä¸€æ¬¡
    fn request_vote(&mut self, candidate_id: u64, term: u64) -> bool {
        if term > self.term {
            self.term = term;
            self.voted_for = None;
        }
        
        if term == self.term && self.voted_for.is_none() {
            self.voted_for = Some(candidate_id);
            true
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn verify_single_vote_per_term() {
        let mut server = RaftServer {
            state: ServerState::Follower,
            term: 1,
            voted_for: None,
        };
        
        // ç¬¬ä¸€æ¬¡æŠ•ç¥¨åº”è¯¥æˆåŠŸ
        assert!(server.request_vote(1, 1));
        
        // åŒä¸€ term å†…çš„ç¬¬äºŒæ¬¡æŠ•ç¥¨åº”è¯¥å¤±è´¥
        assert!(!server.request_vote(2, 1));
    }
}
```

### 4.3.6.4 Loom å¹¶å‘æµ‹è¯•

**æµ‹è¯•æ— é”æ ˆ**:

```rust
use loom::sync::Arc;
use loom::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

struct Stack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }
            
            if self.head
                .compare_exchange(head, new_node, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                break;
            }
        }
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            if self.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}

#[cfg(test)]
mod loom_tests {
    use super::*;
    use loom::thread;
    
    #[test]
    fn test_concurrent_push_pop() {
        loom::model(|| {
            let stack = Arc::new(Stack::new());
            
            let s1 = stack.clone();
            let t1 = thread::spawn(move || {
                s1.push(1);
                s1.push(2);
            });
            
            let s2 = stack.clone();
            let t2 = thread::spawn(move || {
                let _ = s2.pop();
                let _ = s2.pop();
            });
            
            t1.join().unwrap();
            t2.join().unwrap();
        });
    }
}
```

---

## 4.3.7 ç¬¦å·æ‰§è¡Œ

### 4.3.7.1 ç¬¦å·æ‰§è¡ŒåŸç†

**ç¬¦å·æ‰§è¡Œ** ä½¿ç”¨ç¬¦å·å€¼è€Œéå…·ä½“å€¼æ‰§è¡Œç¨‹åºï¼Œæ¢ç´¢æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè·¯å¾„ã€‚

**ç¤ºä¾‹**:

```rust
fn example(x: i32) -> i32 {
    if x > 10 {
        x * 2
    } else {
        x + 5
    }
}

// ç¬¦å·æ‰§è¡Œä¼šæ¢ç´¢ä¸¤æ¡è·¯å¾„:
// è·¯å¾„ 1: x > 10  â†’ è¿”å› x * 2
// è·¯å¾„ 2: x <= 10 â†’ è¿”å› x + 5
```

### 4.3.7.2 KLEE ä¸ Rust

**ä½¿ç”¨ KLEE** (é€šè¿‡ LLVM IR):

```rust
// ç”Ÿæˆ LLVM IR
// rustc --emit=llvm-ir example.rs

#[no_mangle]
pub extern "C" fn test_function(x: i32, y: i32) -> i32 {
    if x > 0 && y > 0 {
        x + y
    } else if x < 0 && y < 0 {
        x * y
    } else {
        0
    }
}
```

**KLEE å‘½ä»¤**:

```bash
# ç¼–è¯‘ä¸º LLVM IR
rustc --emit=llvm-ir test.rs

# è¿è¡Œ KLEE
klee test.ll
```

### 4.3.7.3 è·¯å¾„çˆ†ç‚¸é—®é¢˜

**é—®é¢˜ç¤ºä¾‹**:

```rust
fn path_explosion(arr: &[i32]) -> i32 {
    let mut sum = 0;
    
    // 10 ä¸ª if è¯­å¥ â†’ 2^10 = 1024 æ¡è·¯å¾„
    if arr[0] > 0 { sum += arr[0]; }
    if arr[1] > 0 { sum += arr[1]; }
    if arr[2] > 0 { sum += arr[2]; }
    // ... æ›´å¤šæ¡ä»¶
    
    sum
}
```

**ç¼“è§£ç­–ç•¥**:

1. **è·¯å¾„å‰ªæ**: åˆå¹¶ç›¸ä¼¼è·¯å¾„
2. **å¯å‘å¼æœç´¢**: ä¼˜å…ˆæ¢ç´¢é‡è¦è·¯å¾„
3. **çº¦æŸç¼“å­˜**: é‡ç”¨æ±‚è§£ç»“æœ
4. **æŠ½è±¡**: ç®€åŒ–è·¯å¾„æ¡ä»¶

### 4.3.7.4 çº¦æŸæ±‚è§£

**SMT æ±‚è§£å™¨ä½¿ç”¨** (ä½¿ç”¨ Z3):

```rust
use z3::*;

fn solve_constraints() {
    let cfg = Config::new();
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);
    
    // åˆ›å»ºå˜é‡
    let x = Int::new_const(&ctx, "x");
    let y = Int::new_const(&ctx, "y");
    
    // æ·»åŠ çº¦æŸ
    solver.assert(&x.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&y.gt(&Int::from_i64(&ctx, 0)));
    solver.assert(&x._eq(&y.mul(&Int::from_i64(&ctx, 2))));
    
    // æ±‚è§£
    match solver.check() {
        SatResult::Sat => {
            let model = solver.get_model().unwrap();
            println!("x = {}", model.eval(&x, true).unwrap());
            println!("y = {}", model.eval(&y, true).unwrap());
        }
        _ => println!("No solution"),
    }
}
```

---

## 4.3.8 å®‰å…¨å…³é”®ç³»ç»Ÿå®è·µ

### 4.3.8.1 èˆªç©ºèˆªå¤©åº”ç”¨

**DO-178C è®¤è¯**:

```rust
// å…³é”®é£è¡Œæ§åˆ¶ä»£ç 
#[cfg(kani)]
#[kani::proof]
fn verify_altitude_control() {
    let current_altitude: f64 = kani::any();
    let target_altitude: f64 = kani::any();
    
    kani::assume(current_altitude >= 0.0 && current_altitude <= 50000.0);
    kani::assume(target_altitude >= 0.0 && target_altitude <= 50000.0);
    
    let control_signal = compute_control_signal(current_altitude, target_altitude);
    
    // éªŒè¯æ§åˆ¶ä¿¡å·åœ¨å®‰å…¨èŒƒå›´å†…
    assert!(control_signal.abs() <= MAX_CONTROL_SIGNAL);
}

fn compute_control_signal(current: f64, target: f64) -> f64 {
    const KP: f64 = 0.1;
    let error = target - current;
    KP * error
}

const MAX_CONTROL_SIGNAL: f64 = 10.0;
```

### 4.3.8.2 åŒ»ç–—è®¾å¤‡

**IEC 62304 æ ‡å‡†**:

```rust
use prusti_contracts::*;

struct InsulinPump {
    dose_rate: f64, // å•ä½: units/hour
    max_rate: f64,
    min_rate: f64,
}

#[invariant(self.dose_rate >= self.min_rate && self.dose_rate <= self.max_rate)]
impl InsulinPump {
    #[ensures(result.dose_rate == 0.0)]
    #[ensures(result.max_rate == 10.0)]
    #[ensures(result.min_rate == 0.0)]
    fn new() -> Self {
        Self {
            dose_rate: 0.0,
            max_rate: 10.0,
            min_rate: 0.0,
        }
    }
    
    #[requires(new_rate >= self.min_rate && new_rate <= self.max_rate)]
    #[ensures(self.dose_rate == new_rate)]
    fn set_dose_rate(&mut self, new_rate: f64) {
        self.dose_rate = new_rate;
    }
    
    #[pure]
    fn get_dose_rate(&self) -> f64 {
        self.dose_rate
    }
}
```

### 4.3.8.3 é‡‘èç³»ç»Ÿ

**äº¤æ˜“ç³»ç»ŸéªŒè¯**:

```rust
#[cfg(kani)]
#[kani::proof]
fn verify_trade_settlement() {
    let account_balance: i64 = kani::any();
    let trade_amount: i64 = kani::any();
    
    kani::assume(account_balance >= 0);
    kani::assume(trade_amount >= 0);
    
    match settle_trade(account_balance, trade_amount) {
        Some(new_balance) => {
            // éªŒè¯ä½™é¢æ­£ç¡®æ›´æ–°
            assert!(new_balance == account_balance - trade_amount);
            assert!(new_balance >= 0);
        }
        None => {
            // éªŒè¯ä½™é¢ä¸è¶³æ—¶æ‹’ç»äº¤æ˜“
            assert!(account_balance < trade_amount);
        }
    }
}

fn settle_trade(balance: i64, amount: i64) -> Option<i64> {
    balance.checked_sub(amount)
}
```

### 4.3.8.4 å·¥ä¸šæ§åˆ¶

**PLC æ§åˆ¶é€»è¾‘**:

```rust
struct PLCController {
    temperature: f32,
    pressure: f32,
    valve_open: bool,
}

impl PLCController {
    fn control_loop(&mut self) {
        // å®‰å…¨è§„åˆ™: å¦‚æœæ¸©åº¦æˆ–å‹åŠ›è¶…é™ï¼Œå…³é—­é˜€é—¨
        if self.temperature > 100.0 || self.pressure > 10.0 {
            self.valve_open = false;
        }
    }
}

#[cfg(kani)]
#[kani::proof]
fn verify_safety_shutdown() {
    let mut controller = PLCController {
        temperature: kani::any(),
        pressure: kani::any(),
        valve_open: true,
    };
    
    kani::assume(controller.temperature >= 0.0 && controller.temperature <= 200.0);
    kani::assume(controller.pressure >= 0.0 && controller.pressure <= 20.0);
    
    controller.control_loop();
    
    // éªŒè¯å®‰å…¨å±æ€§
    if controller.temperature > 100.0 || controller.pressure > 10.0 {
        assert!(!controller.valve_open);
    }
}
```

---

## 4.3.9 éªŒè¯æœ€ä½³å®è·µ

### 4.3.9.1 éªŒè¯ç­–ç•¥

**1. åˆ†å±‚éªŒè¯**:

```text
Layer 1: å•å…ƒå‡½æ•°éªŒè¯ (Kani)
Layer 2: æ¨¡å—ä¸å˜é‡éªŒè¯ (Prusti)
Layer 3: ç³»ç»Ÿçº§å±æ€§éªŒè¯ (TLA+)
```

**2. å¢é‡éªŒè¯**:

```rust
// å…ˆéªŒè¯æ ¸å¿ƒä¸å˜é‡
#[cfg(kani)]
#[kani::proof]
fn verify_core_invariant() {
    // æœ€é‡è¦çš„å±æ€§
}

// å†éªŒè¯è¾¹ç•Œæƒ…å†µ
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(5)]
fn verify_edge_cases() {
    // è¾¹ç•Œæ¡ä»¶
}
```

### 4.3.9.2 æ€§èƒ½ä¼˜åŒ–

**é™åˆ¶æœç´¢ç©ºé—´**:

```rust
#[cfg(kani)]
#[kani::proof]
#[kani::unwind(10)] // é™åˆ¶å¾ªç¯å±•å¼€
fn verify_bounded() {
    let n: u32 = kani::any();
    kani::assume(n < 100); // é™åˆ¶è¾“å…¥èŒƒå›´
    
    let result = expensive_function(n);
    assert!(result >= 0);
}
```

**ä½¿ç”¨æŠ½è±¡**:

```rust
// æŠ½è±¡å¤æ‚æ•°æ®ç»“æ„
#[cfg(kani)]
struct AbstractVec {
    len: usize,
    capacity: usize,
}

#[cfg(not(kani))]
type AbstractVec = Vec<i32>;
```

### 4.3.9.3 å¯ç»´æŠ¤æ€§

**æ–‡æ¡£åŒ–éªŒè¯æ„å›¾**:

```rust
/// éªŒè¯ç›®æ ‡: è¯æ˜æ•°ç»„è®¿é—®æ°¸ä¸è¶Šç•Œ
/// å‰ç½®æ¡ä»¶: index < arr.len()
/// åç½®æ¡ä»¶: è¿”å› arr[index]
#[cfg(kani)]
#[kani::proof]
fn verify_safe_access() {
    // ...
}
```

**æ¨¡å—åŒ–éªŒè¯**:

```rust
mod verified_core {
    // æ ¸å¿ƒé€»è¾‘,å·²éªŒè¯
}

mod unverified_wrapper {
    // å¤–å±‚å°è£…,å¯èƒ½æœªéªŒè¯
    use super::verified_core;
}
```

### 4.3.9.4 æŒç»­é›†æˆ

**GitHub Actions é›†æˆ**:

```yaml
name: Formal Verification

on: [push, pull_request]

jobs:
  kani:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Kani
        run: cargo install --locked kani-verifier
      - name: Run Kani
        run: cargo kani --harness verify_all

  prusti:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Prusti
        run: cargo install prusti-rustc
      - name: Run Prusti
        run: cargo-prusti
```

---

## 4.3.10 å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Kani Rust Verifier](https://model-checking.github.io/kani/)
- [Prusti](https://www.pm.inf.ethz.ch/research/prusti.html)
- [Creusot](https://github.com/xldenis/creusot)
- [MIRAI](https://github.com/facebookexperimental/MIRAI)

**å­¦æœ¯è®ºæ–‡**:

- "RustBelt: Securing the Foundations of the Rust Programming Language"
- "Prusti: Deductive Verification for Rust"
- "Leveraging Rust Types for Modular Specification and Verification"

**ç›¸å…³æ–‡æ¡£**:

- [4.1 è¿›é˜¶ä¸»é¢˜é›†](4.1_è¿›é˜¶ä¸»é¢˜é›†.md)
- [4.2 è·¨è¡Œä¸šåº”ç”¨åˆ†æ](4.2_è·¨è¡Œä¸šåº”ç”¨åˆ†æ.md)
- [1.1 ä¸»ç´¢å¼•å¯¼èˆª](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

---

**æŠ¥å‘Šå®Œæˆæ—¶é—´**: 2025-10-21  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å½¢å¼åŒ–éªŒè¯ç ”ç©¶ç»„

---

**ğŸ¯ å½¢å¼åŒ–éªŒè¯ï¼Œä¿éšœRustä»£ç ç»å¯¹æ­£ç¡®ï¼**
