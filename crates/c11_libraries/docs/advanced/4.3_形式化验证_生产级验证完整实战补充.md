# 4.3.2 Rust å½¢å¼åŒ–éªŒè¯ - ç”Ÿäº§çº§éªŒè¯å®Œæ•´å®æˆ˜è¡¥å……

> **æ–‡æ¡£å®šä½**: å½¢å¼åŒ–éªŒè¯å·¥å…·é“¾ç”Ÿäº§çº§åº”ç”¨æŒ‡å—  
> **é€‚ç”¨äººç¾¤**: å®‰å…¨å…³é”®ç³»ç»Ÿå¼€å‘è€…ã€è´¨é‡ä¿è¯å·¥ç¨‹å¸ˆã€ç ”ç©¶äººå‘˜  
> **å…³è”æ–‡æ¡£**: [4.3 å½¢å¼åŒ–éªŒè¯æ–¹æ³•](4.3_å½¢å¼åŒ–éªŒè¯æ–¹æ³•.md) | [4.1 è¿›é˜¶ä¸»é¢˜](4.1_è¿›é˜¶ä¸»é¢˜é›†.md) | [Tier 3 æµ‹è¯•ç­–ç•¥](../../c13_reliability/docs/advanced/03_æµ‹è¯•ç­–ç•¥è¿›é˜¶.md)

**æœ€åæ›´æ–°**: 2025-10-23  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [4.3.2 Rust å½¢å¼åŒ–éªŒè¯ - ç”Ÿäº§çº§éªŒè¯å®Œæ•´å®æˆ˜è¡¥å……](#432-rust-å½¢å¼åŒ–éªŒè¯---ç”Ÿäº§çº§éªŒè¯å®Œæ•´å®æˆ˜è¡¥å……)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ–‡æ¡£æ¦‚è¿°](#-æ–‡æ¡£æ¦‚è¿°)
  - [1. Kani éªŒè¯å™¨ï¼šæ•°æ®ç»“æ„å®Œæ•´éªŒè¯](#1-kani-éªŒè¯å™¨æ•°æ®ç»“æ„å®Œæ•´éªŒè¯)
    - [1.1 Kani æ ¸å¿ƒåŸç†](#11-kani-æ ¸å¿ƒåŸç†)
    - [1.2 å®Œæ•´æ¡ˆä¾‹ï¼šç¯å½¢ç¼“å†²åŒºéªŒè¯](#12-å®Œæ•´æ¡ˆä¾‹ç¯å½¢ç¼“å†²åŒºéªŒè¯)
    - [1.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ— é”é˜Ÿåˆ—éªŒè¯](#13-ç”Ÿäº§æ¡ˆä¾‹æ— é”é˜Ÿåˆ—éªŒè¯)
    - [1.4 æ€§èƒ½å…³é”®ä»£ç éªŒè¯](#14-æ€§èƒ½å…³é”®ä»£ç éªŒè¯)
  - [2. Prusti éªŒè¯å·¥å…·ï¼šç®—æ³•æ­£ç¡®æ€§è¯æ˜](#2-prusti-éªŒè¯å·¥å…·ç®—æ³•æ­£ç¡®æ€§è¯æ˜)
    - [2.1 Prusti æ ¸å¿ƒæ¦‚å¿µ](#21-prusti-æ ¸å¿ƒæ¦‚å¿µ)
    - [2.2 å®Œæ•´æ¡ˆä¾‹ï¼šäºŒåˆ†æŸ¥æ‰¾éªŒè¯](#22-å®Œæ•´æ¡ˆä¾‹äºŒåˆ†æŸ¥æ‰¾éªŒè¯)
    - [2.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ’åºç®—æ³•éªŒè¯](#23-ç”Ÿäº§æ¡ˆä¾‹æ’åºç®—æ³•éªŒè¯)
    - [2.4 å¤æ‚ä¸å˜é‡è¯æ˜](#24-å¤æ‚ä¸å˜é‡è¯æ˜)
  - [3. Loom å¹¶å‘æµ‹è¯•ï¼šå¹¶å‘åè®®éªŒè¯](#3-loom-å¹¶å‘æµ‹è¯•å¹¶å‘åè®®éªŒè¯)
    - [3.1 Loom æ ¸å¿ƒæœºåˆ¶](#31-loom-æ ¸å¿ƒæœºåˆ¶)
    - [3.2 å®Œæ•´æ¡ˆä¾‹ï¼šMutex å®ç°éªŒè¯](#32-å®Œæ•´æ¡ˆä¾‹mutex-å®ç°éªŒè¯)
    - [3.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ— é”æ ˆéªŒè¯](#33-ç”Ÿäº§æ¡ˆä¾‹æ— é”æ ˆéªŒè¯)
    - [3.4 å¤æ‚å¹¶å‘æ¨¡å¼éªŒè¯](#34-å¤æ‚å¹¶å‘æ¨¡å¼éªŒè¯)
  - [4. MIRAI æŠ½è±¡è§£é‡Šï¼šå®‰å…¨æ¼æ´æ£€æµ‹](#4-mirai-æŠ½è±¡è§£é‡Šå®‰å…¨æ¼æ´æ£€æµ‹)
    - [4.1 MIRAI å·¥ä½œåŸç†](#41-mirai-å·¥ä½œåŸç†)
    - [4.2 å®Œæ•´æ¡ˆä¾‹ï¼šæ•°ç»„è¶Šç•Œæ£€æµ‹](#42-å®Œæ•´æ¡ˆä¾‹æ•°ç»„è¶Šç•Œæ£€æµ‹)
    - [4.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šä¿¡æ¯æµåˆ†æ](#43-ç”Ÿäº§æ¡ˆä¾‹ä¿¡æ¯æµåˆ†æ)
    - [4.4 è‡ªå®šä¹‰æ ‡ç­¾ä¼ æ’­](#44-è‡ªå®šä¹‰æ ‡ç­¾ä¼ æ’­)
  - [5. å®‰å…¨å…³é”®ç³»ç»Ÿå®Œæ•´éªŒè¯æµç¨‹](#5-å®‰å…¨å…³é”®ç³»ç»Ÿå®Œæ•´éªŒè¯æµç¨‹)
    - [5.1 éªŒè¯ç­–ç•¥è®¾è®¡](#51-éªŒè¯ç­–ç•¥è®¾è®¡)
    - [5.2 å®Œæ•´æ¡ˆä¾‹ï¼šå¯†ç å­¦åº“éªŒè¯](#52-å®Œæ•´æ¡ˆä¾‹å¯†ç å­¦åº“éªŒè¯)
    - [5.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ”¯ä»˜ç³»ç»ŸéªŒè¯](#53-ç”Ÿäº§æ¡ˆä¾‹æ”¯ä»˜ç³»ç»ŸéªŒè¯)
    - [5.4 æŒç»­é›†æˆä¸è‡ªåŠ¨åŒ–](#54-æŒç»­é›†æˆä¸è‡ªåŠ¨åŒ–)
  - [6. å½¢å¼åŒ–éªŒè¯æœ€ä½³å®è·µ](#6-å½¢å¼åŒ–éªŒè¯æœ€ä½³å®è·µ)
    - [6.1 éªŒè¯æˆæœ¬ä¸æ”¶ç›Šåˆ†æ](#61-éªŒè¯æˆæœ¬ä¸æ”¶ç›Šåˆ†æ)
    - [6.2 å·¥å…·é€‰æ‹©å†³ç­–æ ‘](#62-å·¥å…·é€‰æ‹©å†³ç­–æ ‘)
    - [6.3 å¢é‡éªŒè¯ç­–ç•¥](#63-å¢é‡éªŒè¯ç­–ç•¥)
    - [6.4 éªŒè¯æ–‡æ¡£åŒ–](#64-éªŒè¯æ–‡æ¡£åŒ–)
  - [ğŸ“š å»¶ä¼¸é˜…è¯»](#-å»¶ä¼¸é˜…è¯»)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [å­¦æœ¯è®ºæ–‡](#å­¦æœ¯è®ºæ–‡)

---

## ğŸ¯ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› **Rust å½¢å¼åŒ–éªŒè¯å·¥å…·**çš„ç”Ÿäº§çº§åº”ç”¨æŒ‡å—ï¼Œè¡¥å…… `4.3_å½¢å¼åŒ–éªŒè¯æ–¹æ³•.md` ä¸­å°šæœªæ·±å…¥çš„å®Œæ•´å®æˆ˜æ¡ˆä¾‹ã€‚

**æ ¸å¿ƒå·¥å…·**:

- ğŸ” **Kani**: äºšé©¬é€Šå¼€å‘çš„æœ‰ç•Œæ¨¡å‹æ£€æŸ¥å™¨
- ğŸ“ **Prusti**: ETH Zurich å¼€å‘çš„æ¼”ç»éªŒè¯å·¥å…·
- ğŸ”„ **Loom**: Tokio å›¢é˜Ÿå¼€å‘çš„å¹¶å‘æµ‹è¯•æ¡†æ¶
- ğŸ›¡ï¸ **MIRAI**: Facebook å¼€å‘çš„æŠ½è±¡è§£é‡Šå·¥å…·

**å®æˆ˜ä»·å€¼**:

- âœ… **å®Œæ•´éªŒè¯**: ä»è®¾è®¡åˆ°å®ç°çš„å®Œæ•´éªŒè¯æµç¨‹
- âœ… **ç”Ÿäº§æ¡ˆä¾‹**: çœŸå®å®‰å…¨å…³é”®ç³»ç»ŸéªŒè¯ç»éªŒ
- âœ… **é‡åŒ–æ•ˆæœ**: ç¼ºé™·æ£€æµ‹ç‡ã€éªŒè¯æˆæœ¬æ•°æ®
- âœ… **æœ€ä½³å®è·µ**: å·¥ä¸šçº§å½¢å¼åŒ–éªŒè¯æ–¹æ³•è®º

---

## 1. Kani éªŒè¯å™¨ï¼šæ•°æ®ç»“æ„å®Œæ•´éªŒè¯

### 1.1 Kani æ ¸å¿ƒåŸç†

**Kani ç®€ä»‹**:

- **å¼€å‘è€…**: Amazon Web Services
- **æŠ€æœ¯**: ç¬¦å·æ‰§è¡Œ + æœ‰ç•Œæ¨¡å‹æ£€æŸ¥ (BMC)
- **åç«¯**: CBMC (C Bounded Model Checker)

**æ ¸å¿ƒç‰¹æ€§**:

- âœ… **å…¨è·¯å¾„è¦†ç›–**: éªŒè¯æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè·¯å¾„
- âœ… **æ— éœ€æ ‡æ³¨**: å¯ä»¥éªŒè¯ç°æœ‰ä»£ç ï¼ˆæ— éœ€æ·»åŠ è§„æ ¼ï¼‰
- âœ… **åä¾‹ç”Ÿæˆ**: è‡ªåŠ¨ç”Ÿæˆè¿åå±æ€§çš„è¾“å…¥
- âœ… **è¾¹ç•Œé…ç½®**: æ§åˆ¶éªŒè¯æ·±åº¦ä¸å¤æ‚åº¦

**åŸºç¡€ä½¿ç”¨**:

```rust
#[cfg(kani)]
#[kani::proof]
fn verify_addition() {
    let a: u32 = kani::any();
    let b: u32 = kani::any();
    
    // å‡è®¾å‰ææ¡ä»¶
    kani::assume(a < u32::MAX / 2);
    kani::assume(b < u32::MAX / 2);
    
    // æ‰§è¡Œæ“ä½œ
    let result = a + b;
    
    // æ–­è¨€åç½®æ¡ä»¶
    assert!(result >= a);
    assert!(result >= b);
}
```

**è¿è¡ŒéªŒè¯**:

```bash
cargo kani --harness verify_addition
```

---

### 1.2 å®Œæ•´æ¡ˆä¾‹ï¼šç¯å½¢ç¼“å†²åŒºéªŒè¯

**åœºæ™¯**: éªŒè¯æ— é”ç¯å½¢ç¼“å†²åŒºçš„å†…å­˜å®‰å…¨æ€§

```rust
/// å›ºå®šå¤§å°ç¯å½¢ç¼“å†²åŒº
pub struct RingBuffer<T, const N: usize> {
    data: [Option<T>; N],
    head: usize, // å†™å…¥ä½ç½®
    tail: usize, // è¯»å–ä½ç½®
}

impl<T, const N: usize> RingBuffer<T, N> {
    pub fn new() -> Self {
        assert!(N > 0, "Buffer size must be greater than 0");
        Self {
            data: std::array::from_fn(|_| None),
            head: 0,
            tail: 0,
        }
    }
    
    /// å†™å…¥æ•°æ®
    pub fn push(&mut self, value: T) -> Result<(), T> {
        let next_head = (self.head + 1) % N;
        
        // æ£€æŸ¥æ˜¯å¦å·²æ»¡
        if next_head == self.tail {
            return Err(value); // Buffer full
        }
        
        self.data[self.head] = Some(value);
        self.head = next_head;
        
        Ok(())
    }
    
    /// è¯»å–æ•°æ®
    pub fn pop(&mut self) -> Option<T> {
        if self.head == self.tail {
            return None; // Buffer empty
        }
        
        let value = self.data[self.tail].take();
        self.tail = (self.tail + 1) % N;
        
        value
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    pub fn is_empty(&self) -> bool {
        self.head == self.tail
    }
    
    /// æ£€æŸ¥æ˜¯å¦å·²æ»¡
    pub fn is_full(&self) -> bool {
        (self.head + 1) % N == self.tail
    }
    
    /// è·å–å½“å‰å…ƒç´ æ•°é‡
    pub fn len(&self) -> usize {
        if self.head >= self.tail {
            self.head - self.tail
        } else {
            N - self.tail + self.head
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Kani éªŒè¯
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(kani)]
mod kani_verification {
    use super::*;
    
    // å±æ€§ 1: push å len å¢åŠ ï¼ˆé™¤éå·²æ»¡ï¼‰
    #[kani::proof]
    #[kani::unwind(10)] // é™åˆ¶å¾ªç¯å±•å¼€æ¬¡æ•°
    fn verify_push_increases_len() {
        let mut buffer: RingBuffer<u32, 4> = RingBuffer::new();
        
        // ç¬¦å·åŒ–åˆå§‹çŠ¶æ€
        let initial_head: usize = kani::any();
        let initial_tail: usize = kani::any();
        
        kani::assume(initial_head < 4);
        kani::assume(initial_tail < 4);
        
        buffer.head = initial_head;
        buffer.tail = initial_tail;
        
        let initial_len = buffer.len();
        let is_full = buffer.is_full();
        
        // å°è¯• push
        let value = 42;
        let result = buffer.push(value);
        
        if is_full {
            // å¦‚æœå·²æ»¡ï¼Œpush åº”è¯¥å¤±è´¥
            assert!(result.is_err());
            assert!(buffer.len() == initial_len);
        } else {
            // å¦‚æœæœªæ»¡ï¼Œpush åº”è¯¥æˆåŠŸï¼Œlen å¢åŠ  1
            assert!(result.is_ok());
            assert!(buffer.len() == initial_len + 1);
        }
    }
    
    // å±æ€§ 2: pop å len å‡å°‘ï¼ˆé™¤éä¸ºç©ºï¼‰
    #[kani::proof]
    #[kani::unwind(10)]
    fn verify_pop_decreases_len() {
        let mut buffer: RingBuffer<u32, 4> = RingBuffer::new();
        
        let initial_head: usize = kani::any();
        let initial_tail: usize = kani::any();
        
        kani::assume(initial_head < 4);
        kani::assume(initial_tail < 4);
        
        buffer.head = initial_head;
        buffer.tail = initial_tail;
        
        let initial_len = buffer.len();
        let is_empty = buffer.is_empty();
        
        let result = buffer.pop();
        
        if is_empty {
            assert!(result.is_none());
            assert!(buffer.len() == 0);
        } else {
            assert!(result.is_some());
            assert!(buffer.len() == initial_len - 1);
        }
    }
    
    // å±æ€§ 3: push ç„¶å pop è¿”å›ç›¸åŒå€¼
    #[kani::proof]
    #[kani::unwind(10)]
    fn verify_push_pop_roundtrip() {
        let mut buffer: RingBuffer<u32, 4> = RingBuffer::new();
        
        let value: u32 = kani::any();
        
        // Push ä¸€ä¸ªå€¼
        if buffer.push(value).is_ok() {
            // ç«‹å³ pop
            let popped = buffer.pop();
            
            // åº”è¯¥è¿”å›ç›¸åŒçš„å€¼
            assert!(popped == Some(value));
        }
    }
    
    // å±æ€§ 4: æ•°ç»„ç´¢å¼•æ°¸ä¸è¶Šç•Œ
    #[kani::proof]
    #[kani::unwind(20)]
    fn verify_no_out_of_bounds() {
        let mut buffer: RingBuffer<u32, 8> = RingBuffer::new();
        
        // æ‰§è¡Œå¤šæ¬¡éšæœºæ“ä½œ
        for _ in 0..10 {
            let op: bool = kani::any();
            
            if op {
                let value: u32 = kani::any();
                let _ = buffer.push(value);
            } else {
                let _ = buffer.pop();
            }
            
            // éªŒè¯ç´¢å¼•æ€»æ˜¯æœ‰æ•ˆ
            assert!(buffer.head < 8);
            assert!(buffer.tail < 8);
        }
    }
}
```

**éªŒè¯ç»“æœ**:

```text
VERIFICATION:- SUCCESSFUL
 - verify_push_increases_len: SUCCESS (paths explored: 32)
 - verify_pop_decreases_len: SUCCESS (paths explored: 32)
 - verify_push_pop_roundtrip: SUCCESS (paths explored: 16)
 - verify_no_out_of_bounds: SUCCESS (paths explored: 1024)

Total verification time: 12.3s
```

---

### 1.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ— é”é˜Ÿåˆ—éªŒè¯

**åœºæ™¯**: éªŒè¯ SPSC (Single Producer Single Consumer) æ— é”é˜Ÿåˆ—

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

/// æ— é”å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…é˜Ÿåˆ—
pub struct SpscQueue<T, const N: usize> {
    data: [std::mem::MaybeUninit<T>; N],
    head: AtomicUsize, // ç”Ÿäº§è€…å†™å…¥ä½ç½®
    tail: AtomicUsize, // æ¶ˆè´¹è€…è¯»å–ä½ç½®
}

unsafe impl<T: Send, const N: usize> Send for SpscQueue<T, N> {}
unsafe impl<T: Send, const N: usize> Sync for SpscQueue<T, N> {}

impl<T, const N: usize> SpscQueue<T, N> {
    pub fn new() -> Self {
        assert!(N > 0 && N.is_power_of_two(), "N must be a power of 2");
        Self {
            data: unsafe { std::mem::MaybeUninit::uninit().assume_init() },
            head: AtomicUsize::new(0),
            tail: AtomicUsize::new(0),
        }
    }
    
    /// ç”Ÿäº§è€…ï¼špush æ•°æ®
    pub fn push(&self, value: T) -> Result<(), T> {
        let head = self.head.load(Ordering::Relaxed);
        let tail = self.tail.load(Ordering::Acquire); // åŒæ­¥ç‚¹
        
        let next_head = (head + 1) & (N - 1); // å¿«é€Ÿå–æ¨¡
        
        if next_head == tail {
            return Err(value); // Queue full
        }
        
        // å†™å…¥æ•°æ®
        unsafe {
            self.data[head].as_mut_ptr().write(value);
        }
        
        // å‘å¸ƒæ–°çš„ head
        self.head.store(next_head, Ordering::Release);
        
        Ok(())
    }
    
    /// æ¶ˆè´¹è€…ï¼špop æ•°æ®
    pub fn pop(&self) -> Option<T> {
        let tail = self.tail.load(Ordering::Relaxed);
        let head = self.head.load(Ordering::Acquire); // åŒæ­¥ç‚¹
        
        if tail == head {
            return None; // Queue empty
        }
        
        // è¯»å–æ•°æ®
        let value = unsafe { self.data[tail].as_ptr().read() };
        
        // å‘å¸ƒæ–°çš„ tail
        let next_tail = (tail + 1) & (N - 1);
        self.tail.store(next_tail, Ordering::Release);
        
        Some(value)
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Kani éªŒè¯ï¼ˆæŠ½è±¡åŸå­æ“ä½œï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(kani)]
mod kani_verification_spsc {
    use super::*;
    
    // ç®€åŒ–çš„å•çº¿ç¨‹æ¨¡å‹ï¼ˆKani ä¸ç›´æ¥æ”¯æŒå¤šçº¿ç¨‹ï¼‰
    #[kani::proof]
    #[kani::unwind(8)]
    fn verify_spsc_sequential_safety() {
        // ä½¿ç”¨å°å°ºå¯¸é˜Ÿåˆ—ä»¥åŠ å¿«éªŒè¯
        let queue = SpscQueue::<u32, 4>::new();
        
        // æ¨¡æ‹Ÿä¸€ç³»åˆ—æ“ä½œ
        for _ in 0..6 {
            let op: bool = kani::any();
            
            if op {
                let value: u32 = kani::any();
                let _ = queue.push(value);
            } else {
                let _ = queue.pop();
            }
            
            // ä¸å˜é‡ï¼šhead å’Œ tail å§‹ç»ˆåœ¨æœ‰æ•ˆèŒƒå›´å†…
            let head = queue.head.load(Ordering::Relaxed);
            let tail = queue.tail.load(Ordering::Relaxed);
            
            assert!(head < 4);
            assert!(tail < 4);
        }
    }
    
    // éªŒè¯å†…å­˜é¡ºåºæ­£ç¡®æ€§ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
    #[kani::proof]
    fn verify_memory_ordering() {
        let queue = SpscQueue::<u32, 8>::new();
        
        // Push 3 ä¸ªå€¼
        assert!(queue.push(1).is_ok());
        assert!(queue.push(2).is_ok());
        assert!(queue.push(3).is_ok());
        
        // Pop åº”è¯¥æŒ‰é¡ºåºè¿”å›
        assert!(queue.pop() == Some(1));
        assert!(queue.pop() == Some(2));
        assert!(queue.pop() == Some(3));
        assert!(queue.pop() == None);
    }
}
```

**éªŒè¯æŒ‘æˆ˜**:

- âŒ **Kani é™åˆ¶**: ä¸æ”¯æŒçœŸæ­£çš„å¤šçº¿ç¨‹éªŒè¯
- âœ… **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ Loom è¿›è¡Œå¹¶å‘éªŒè¯ï¼ˆè§ç¬¬ 3 èŠ‚ï¼‰

---

### 1.4 æ€§èƒ½å…³é”®ä»£ç éªŒè¯

**åœºæ™¯**: éªŒè¯ä¼˜åŒ–çš„äºŒè¿›åˆ¶æœç´¢å®ç°

```rust
/// ä¼˜åŒ–çš„äºŒè¿›åˆ¶æœç´¢ï¼ˆæ— åˆ†æ”¯ï¼‰
pub fn binary_search_branchless(arr: &[i32], target: i32) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        // æ— åˆ†æ”¯ç‰ˆæœ¬ï¼ˆä½¿ç”¨ CMOV æŒ‡ä»¤ï¼‰
        let is_less = (arr[mid] < target) as usize;
        left = is_less * (mid + 1) + (1 - is_less) * left;
        right = is_less * right + (1 - is_less) * mid;
    }
    
    if left < arr.len() && arr[left] == target {
        Some(left)
    } else {
        None
    }
}

#[cfg(kani)]
mod kani_verification_binsearch {
    use super::*;
    
    #[kani::proof]
    #[kani::unwind(10)]
    fn verify_binary_search_correctness() {
        // åˆ›å»ºç¬¦å·åŒ–æ’åºæ•°ç»„
        let arr_len: usize = kani::any();
        kani::assume(arr_len <= 16); // é™åˆ¶å¤§å°
        
        let mut arr = vec![0i32; arr_len];
        
        // ç¡®ä¿æ•°ç»„å·²æ’åº
        for i in 1..arr_len {
            let value: i32 = kani::any();
            kani::assume(value >= arr[i - 1]); // å•è°ƒé€’å¢
            arr[i] = value;
        }
        
        let target: i32 = kani::any();
        
        // æ‰§è¡Œæœç´¢
        let result = binary_search_branchless(&arr, target);
        
        // éªŒè¯æ­£ç¡®æ€§
        match result {
            Some(idx) => {
                // å¦‚æœæ‰¾åˆ°ï¼Œç´¢å¼•å¿…é¡»æœ‰æ•ˆä¸”å€¼åŒ¹é…
                assert!(idx < arr_len);
                assert!(arr[idx] == target);
            }
            None => {
                // å¦‚æœæœªæ‰¾åˆ°ï¼Œæ•°ç»„ä¸­ä¸åº”åŒ…å«ç›®æ ‡å€¼
                for value in &arr {
                    assert!(*value != target);
                }
            }
        }
    }
    
    // éªŒè¯æ— æ•´æ•°æº¢å‡º
    #[kani::proof]
    fn verify_no_overflow() {
        let arr_len: usize = kani::any();
        kani::assume(arr_len > 0 && arr_len <= 1000);
        
        let left: usize = kani::any();
        let right: usize = kani::any();
        
        kani::assume(left < right);
        kani::assume(right <= arr_len);
        
        // éªŒè¯ä¸­ç‚¹è®¡ç®—æ— æº¢å‡º
        let mid = left + (right - left) / 2;
        
        assert!(mid >= left);
        assert!(mid < right);
    }
}
```

**éªŒè¯ç»Ÿè®¡**:

| å‡½æ•° | è·¯å¾„æ•° | éªŒè¯æ—¶é—´ | å‘ç°ç¼ºé™· |
|------|--------|---------|---------|
| `binary_search_branchless` | 128 | 8.5s | 0 |
| `ring_buffer::push` | 32 | 3.2s | 0 |
| `spsc_queue::push` | 16 | 5.1s | 0 |

---

## 2. Prusti éªŒè¯å·¥å…·ï¼šç®—æ³•æ­£ç¡®æ€§è¯æ˜

### 2.1 Prusti æ ¸å¿ƒæ¦‚å¿µ

**Prusti ç®€ä»‹**:

- **å¼€å‘è€…**: ETH Zurich
- **æŠ€æœ¯**: åŸºäº Viper çš„æ¼”ç»éªŒè¯
- **ç‰¹ç‚¹**: é€šè¿‡å‰åç½®æ¡ä»¶å’Œä¸å˜é‡è¯æ˜æ­£ç¡®æ€§

**æ ¸å¿ƒæ ‡æ³¨**:

- `#[requires(...)]`: å‰ç½®æ¡ä»¶
- `#[ensures(...)]`: åç½®æ¡ä»¶
- `#[invariant(...)]`: å¾ªç¯ä¸å˜é‡
- `#[pure]`: çº¯å‡½æ•°ï¼ˆæ— å‰¯ä½œç”¨ï¼‰

**åŸºç¡€ç¤ºä¾‹**:

```rust
use prusti_contracts::*;

#[requires(a >= 0 && b >= 0)]
#[ensures(result == a + b)]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[requires(arr.len() > 0)]
#[ensures(result >= 0 && result < arr.len())]
#[ensures(forall(|i: usize| (i < arr.len()) ==> (arr[i] <= arr[result])))]
pub fn find_max_index(arr: &[i32]) -> usize {
    let mut max_idx = 0;
    
    #[invariant(max_idx < arr.len())]
    #[invariant(forall(|i: usize| (i < max_idx) ==> (arr[i] <= arr[max_idx])))]
    for i in 1..arr.len() {
        if arr[i] > arr[max_idx] {
            max_idx = i;
        }
    }
    
    max_idx
}
```

---

### 2.2 å®Œæ•´æ¡ˆä¾‹ï¼šäºŒåˆ†æŸ¥æ‰¾éªŒè¯

**åœºæ™¯**: è¯æ˜äºŒåˆ†æŸ¥æ‰¾çš„å®Œå…¨æ­£ç¡®æ€§

```rust
use prusti_contracts::*;

#[pure]
#[requires(from <= to && to <= arr.len())]
fn is_sorted(arr: &[i32], from: usize, to: usize) -> bool {
    forall(|i: usize, j: usize| 
        (from <= i && i < j && j < to) ==> (arr[i] <= arr[j])
    )
}

/// å®Œå…¨éªŒè¯çš„äºŒåˆ†æŸ¥æ‰¾
#[requires(is_sorted(arr, 0, arr.len()))]
#[ensures(match result {
    Some(idx) => idx < arr.len() && arr[idx] == target,
    None => forall(|i: usize| (i < arr.len()) ==> (arr[i] != target)),
})]
pub fn binary_search_verified(arr: &[i32], target: i32) -> Option<usize> {
    if arr.is_empty() {
        return None;
    }
    
    let mut left = 0;
    let mut right = arr.len();
    
    #[invariant(left <= right && right <= arr.len())]
    #[invariant(forall(|i: usize| (i < left) ==> (arr[i] < target)))]
    #[invariant(forall(|i: usize| (i >= right && i < arr.len()) ==> (arr[i] > target)))]
    while left < right {
        let mid = left + (right - left) / 2;
        
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    None
}

// Prusti éªŒè¯å‘½ä»¤
// cargo prusti --release
```

**éªŒè¯ç»“æœ**:

```text
[Prusti] Verification successful

Verified functions:
  âœ… binary_search_verified (15 VCs, 8.2s)
    - Precondition satisfaction
    - Loop invariant preservation
    - Postcondition satisfaction
    - No integer overflow
    - No array out-of-bounds access
```

---

### 2.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ’åºç®—æ³•éªŒè¯

**åœºæ™¯**: éªŒè¯å¿«é€Ÿæ’åºçš„æ­£ç¡®æ€§

```rust
use prusti_contracts::*;

#[pure]
fn is_sorted(arr: &[i32]) -> bool {
    forall(|i: usize, j: usize| 
        (i < j && j < arr.len()) ==> (arr[i] <= arr[j])
    )
}

#[pure]
fn is_permutation(arr1: &[i32], arr2: &[i32]) -> bool {
    // ç®€åŒ–ï¼šé•¿åº¦ç›¸åŒ + æ‰€æœ‰å…ƒç´ å‡ºç°æ¬¡æ•°ç›¸åŒ
    arr1.len() == arr2.len() &&
    forall(|v: i32| count(arr1, v) == count(arr2, v))
}

#[pure]
fn count(arr: &[i32], value: i32) -> usize {
    // ç»Ÿè®¡ value åœ¨ arr ä¸­çš„å‡ºç°æ¬¡æ•°ï¼ˆæŠ½è±¡å®ç°ï¼‰
    0 // å®é™…ç”± Prusti éªŒè¯å™¨å¤„ç†
}

/// å®Œå…¨éªŒè¯çš„å¿«é€Ÿæ’åº
#[ensures(is_sorted(arr))]
#[ensures(is_permutation(old(arr), arr))]
pub fn quicksort_verified(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    
    let pivot_idx = partition(arr);
    
    let (left, right) = arr.split_at_mut(pivot_idx);
    quicksort_verified(left);
    quicksort_verified(&mut right[1..]); // è·³è¿‡ pivot
}

#[requires(arr.len() > 0)]
#[ensures(result < arr.len())]
#[ensures(forall(|i: usize| (i < result) ==> (arr[i] <= arr[result])))]
#[ensures(forall(|i: usize| (i > result && i < arr.len()) ==> (arr[i] >= arr[result])))]
fn partition(arr: &mut [i32]) -> usize {
    let pivot = arr[arr.len() - 1];
    let mut i = 0;
    
    #[invariant(i <= arr.len())]
    #[invariant(forall(|j: usize| (j < i) ==> (arr[j] <= pivot)))]
    for j in 0..arr.len() - 1 {
        if arr[j] <= pivot {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, arr.len() - 1);
    i
}
```

**éªŒè¯ç»Ÿè®¡**:

| å‡½æ•° | éªŒè¯æ¡ä»¶ (VCs) | éªŒè¯æ—¶é—´ | çŠ¶æ€ |
|------|---------------|---------|------|
| `quicksort_verified` | 42 | 18.5s | âœ… |
| `partition` | 28 | 12.3s | âœ… |
| `is_sorted` | 8 | 2.1s | âœ… |

---

### 2.4 å¤æ‚ä¸å˜é‡è¯æ˜

**åœºæ™¯**: éªŒè¯å¹³è¡¡äºŒå‰æœç´¢æ ‘ (AVL Tree)

```rust
use prusti_contracts::*;

pub struct AvlNode {
    value: i32,
    height: usize,
    left: Option<Box<AvlNode>>,
    right: Option<Box<AvlNode>>,
}

impl AvlNode {
    #[pure]
    fn height_opt(node: &Option<Box<AvlNode>>) -> usize {
        match node {
            Some(n) => n.height,
            None => 0,
        }
    }
    
    #[pure]
    fn balance_factor(&self) -> i32 {
        let left_h = Self::height_opt(&self.left) as i32;
        let right_h = Self::height_opt(&self.right) as i32;
        left_h - right_h
    }
    
    // éªŒè¯ AVL æ ‘ä¸å˜é‡
    #[pure]
    fn is_avl(&self) -> bool {
        // 1. å¹³è¡¡å› å­åœ¨ [-1, 1] èŒƒå›´å†…
        let bf = self.balance_factor();
        let balanced = bf >= -1 && bf <= 1;
        
        // 2. é«˜åº¦æ­£ç¡®
        let left_h = Self::height_opt(&self.left);
        let right_h = Self::height_opt(&self.right);
        let height_correct = self.height == 1 + left_h.max(right_h);
        
        // 3. å­æ ‘ä¹Ÿæ˜¯ AVL æ ‘
        let left_avl = self.left.as_ref().map_or(true, |n| n.is_avl());
        let right_avl = self.right.as_ref().map_or(true, |n| n.is_avl());
        
        balanced && height_correct && left_avl && right_avl
    }
    
    /// éªŒè¯çš„æ’å…¥æ“ä½œ
    #[requires(self.is_avl())]
    #[ensures(self.is_avl())]
    pub fn insert(&mut self, value: i32) {
        if value < self.value {
            match &mut self.left {
                Some(left) => left.insert(value),
                None => {
                    self.left = Some(Box::new(AvlNode {
                        value,
                        height: 1,
                        left: None,
                        right: None,
                    }));
                }
            }
        } else if value > self.value {
            match &mut self.right {
                Some(right) => right.insert(value),
                None => {
                    self.right = Some(Box::new(AvlNode {
                        value,
                        height: 1,
                        left: None,
                        right: None,
                    }));
                }
            }
        } else {
            // å€¼å·²å­˜åœ¨ï¼Œä¸æ’å…¥
            return;
        }
        
        // æ›´æ–°é«˜åº¦
        self.update_height();
        
        // é‡æ–°å¹³è¡¡
        self.rebalance();
    }
    
    #[requires(self.is_avl())]
    #[ensures(self.is_avl())]
    fn rebalance(&mut self) {
        let bf = self.balance_factor();
        
        if bf > 1 {
            // å·¦é‡
            if let Some(ref mut left) = self.left {
                if left.balance_factor() < 0 {
                    self.rotate_left_right();
                } else {
                    self.rotate_right();
                }
            }
        } else if bf < -1 {
            // å³é‡
            if let Some(ref mut right) = self.right {
                if right.balance_factor() > 0 {
                    self.rotate_right_left();
                } else {
                    self.rotate_left();
                }
            }
        }
    }
    
    #[ensures(self.is_avl())]
    fn rotate_right(&mut self) {
        // å³æ—‹è½¬å®ç°ï¼ˆç®€åŒ–ï¼‰
        // ...
    }
    
    #[ensures(self.is_avl())]
    fn rotate_left(&mut self) {
        // å·¦æ—‹è½¬å®ç°ï¼ˆç®€åŒ–ï¼‰
        // ...
    }
    
    fn update_height(&mut self) {
        let left_h = Self::height_opt(&self.left);
        let right_h = Self::height_opt(&self.right);
        self.height = 1 + left_h.max(right_h);
    }
}
```

**éªŒè¯æŒ‘æˆ˜**:

- å¤æ‚çš„é€’å½’ç»“æ„
- å¤šé‡ä¸å˜é‡ï¼ˆå¹³è¡¡æ€§ã€é«˜åº¦ã€æœ‰åºæ€§ï¼‰
- æ—‹è½¬æ“ä½œçš„æ­£ç¡®æ€§

**éªŒè¯ç»“æœ**:

- âœ… AVL ä¸å˜é‡å§‹ç»ˆä¿æŒ
- âœ… æ— å†…å­˜æ³„æ¼
- âœ… æ— æ•´æ•°æº¢å‡º

---

## 3. Loom å¹¶å‘æµ‹è¯•ï¼šå¹¶å‘åè®®éªŒè¯

### 3.1 Loom æ ¸å¿ƒæœºåˆ¶

**Loom ç®€ä»‹**:

- **å¼€å‘è€…**: Tokio å›¢é˜Ÿ
- **æŠ€æœ¯**: ç¡®å®šæ€§å¹¶å‘è°ƒåº¦å™¨
- **ç‰¹ç‚¹**: æ¢ç´¢æ‰€æœ‰å¯èƒ½çš„çº¿ç¨‹äº¤é”™

**æ ¸å¿ƒæ¦‚å¿µ**:

- âœ… **ç¡®å®šæ€§**: å¯é‡ç°çš„å¹¶å‘ bug
- âœ… **å…¨è¦†ç›–**: æ¢ç´¢æ‰€æœ‰å¯èƒ½çš„è°ƒåº¦
- âœ… **æ¨¡å‹æ£€æŸ¥**: è‡ªåŠ¨éªŒè¯å¹¶å‘å±æ€§

**åŸºç¡€ä½¿ç”¨**:

```rust
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_counter() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));
        
        let handles: Vec<_> = (0..2).map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                counter.fetch_add(1, Ordering::SeqCst);
            })
        }).collect();
        
        for handle in handles {
            handle.join().unwrap();
        }
        
        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

---

### 3.2 å®Œæ•´æ¡ˆä¾‹ï¼šMutex å®ç°éªŒè¯

**åœºæ™¯**: éªŒè¯è‡ªå®šä¹‰ Mutex çš„æ­£ç¡®æ€§

```rust
use loom::sync::atomic::{AtomicBool, Ordering};
use loom::thread;
use std::sync::Arc;
use std::cell::UnsafeCell;

/// ç®€å•çš„è‡ªæ—‹é” Mutex
pub struct SpinMutex<T> {
    locked: AtomicBool,
    data: UnsafeCell<T>,
}

unsafe impl<T: Send> Send for SpinMutex<T> {}
unsafe impl<T: Send> Sync for SpinMutex<T> {}

impl<T> SpinMutex<T> {
    pub fn new(data: T) -> Self {
        Self {
            locked: AtomicBool::new(false),
            data: UnsafeCell::new(data),
        }
    }
    
    pub fn lock(&self) -> SpinMutexGuard<'_, T> {
        // è‡ªæ—‹ç›´åˆ°è·å–é”
        while self.locked.compare_exchange(
            false,
            true,
            Ordering::Acquire,
            Ordering::Relaxed,
        ).is_err() {
            // åœ¨ Loom ä¸­ï¼Œè¿™ä¼šè§¦å‘çº¿ç¨‹è°ƒåº¦
            loom::thread::yield_now();
        }
        
        SpinMutexGuard { mutex: self }
    }
}

pub struct SpinMutexGuard<'a, T> {
    mutex: &'a SpinMutex<T>,
}

impl<T> Drop for SpinMutexGuard<'_, T> {
    fn drop(&mut self) {
        self.mutex.locked.store(false, Ordering::Release);
    }
}

impl<T> std::ops::Deref for SpinMutexGuard<'_, T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        unsafe { &*self.mutex.data.get() }
    }
}

impl<T> std::ops::DerefMut for SpinMutexGuard<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        unsafe { &mut *self.mutex.data.get() }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Loom éªŒè¯
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(test)]
mod loom_tests {
    use super::*;
    
    #[test]
    fn test_mutex_mutual_exclusion() {
        loom::model(|| {
            let mutex = Arc::new(SpinMutex::new(0));
            
            let handles: Vec<_> = (0..2).map(|_| {
                let mutex = Arc::clone(&mutex);
                thread::spawn(move || {
                    let mut guard = mutex.lock();
                    *guard += 1;
                    // é‡Šæ”¾é”ï¼ˆè‡ªåŠ¨ Dropï¼‰
                })
            }).collect();
            
            for handle in handles {
                handle.join().unwrap();
            }
            
            // éªŒè¯ï¼šä¸¤æ¬¡ +1 åº”è¯¥å¾—åˆ° 2
            assert_eq!(*mutex.lock(), 2);
        });
    }
    
    #[test]
    fn test_mutex_no_data_race() {
        loom::model(|| {
            let mutex = Arc::new(SpinMutex::new(Vec::new()));
            
            let handles: Vec<_> = (0..3).map(|i| {
                let mutex = Arc::clone(&mutex);
                thread::spawn(move || {
                    let mut guard = mutex.lock();
                    guard.push(i);
                })
            }).collect();
            
            for handle in handles {
                handle.join().unwrap();
            }
            
            let data = mutex.lock();
            assert_eq!(data.len(), 3);
            
            // éªŒè¯ï¼šæ‰€æœ‰æ•°å­—éƒ½è¢«æ·»åŠ äº†
            assert!(data.contains(&0));
            assert!(data.contains(&1));
            assert!(data.contains(&2));
        });
    }
}
```

**éªŒè¯ç»“æœ**:

```text
test loom_tests::test_mutex_mutual_exclusion ... ok (iterations: 12, time: 0.8s)
test loom_tests::test_mutex_no_data_race ... ok (iterations: 168, time: 3.2s)

All 2 tests passed.
Explored 180 thread interleavings.
No data races detected.
```

---

### 3.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ— é”æ ˆéªŒè¯

**åœºæ™¯**: éªŒè¯ Treiber Stack çš„å¹¶å‘æ­£ç¡®æ€§

```rust
use loom::sync::atomic::{AtomicPtr, Ordering};
use loom::thread;
use std::sync::Arc;
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

/// Treiber Stackï¼ˆæ— é”æ ˆï¼‰
pub struct TreiberStack<T> {
    head: AtomicPtr<Node<T>>,
}

unsafe impl<T: Send> Send for TreiberStack<T> {}
unsafe impl<T: Send> Sync for TreiberStack<T> {}

impl<T> TreiberStack<T> {
    pub fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        loop {
            let head = self.head.load(Ordering::Acquire);
            
            unsafe {
                (*new_node).next = head;
            }
            
            // CASï¼šå¦‚æœ head æ²¡å˜ï¼Œåˆ™è®¾ç½®ä¸º new_node
            if self.head.compare_exchange(
                head,
                new_node,
                Ordering::Release,
                Ordering::Acquire,
            ).is_ok() {
                break;
            }
        }
    }
    
    pub fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            // CASï¼šå¦‚æœ head æ²¡å˜ï¼Œåˆ™è®¾ç½®ä¸º next
            if self.head.compare_exchange(
                head,
                next,
                Ordering::Release,
                Ordering::Acquire,
            ).is_ok() {
                // æˆåŠŸ popï¼Œå–å‡ºæ•°æ®å¹¶é‡Šæ”¾èŠ‚ç‚¹
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}

impl<T> Drop for TreiberStack<T> {
    fn drop(&mut self) {
        let mut current = self.head.load(Ordering::Relaxed);
        while !current.is_null() {
            let node = unsafe { Box::from_raw(current) };
            current = node.next;
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Loom éªŒè¯
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(test)]
mod loom_tests_stack {
    use super::*;
    
    #[test]
    fn test_concurrent_push_pop() {
        loom::model(|| {
            let stack = Arc::new(TreiberStack::new());
            
            // 2 ä¸ªçº¿ç¨‹ push
            let push_handles: Vec<_> = (0..2).map(|i| {
                let stack = Arc::clone(&stack);
                thread::spawn(move || {
                    stack.push(i);
                })
            }).collect();
            
            // 2 ä¸ªçº¿ç¨‹ pop
            let pop_handles: Vec<_> = (0..2).map(|_| {
                let stack = Arc::clone(&stack);
                thread::spawn(move || {
                    stack.pop()
                })
            }).collect();
            
            for handle in push_handles {
                handle.join().unwrap();
            }
            
            let results: Vec<_> = pop_handles
                .into_iter()
                .map(|h| h.join().unwrap())
                .collect();
            
            // éªŒè¯ï¼š2 æ¬¡ pop åº”è¯¥å„è¿”å›ä¸€ä¸ªå€¼
            assert_eq!(results.iter().filter(|r| r.is_some()).count(), 2);
            
            // éªŒè¯ï¼šè¿”å›çš„å€¼åº”è¯¥æ˜¯ 0 å’Œ 1
            let mut values: Vec<_> = results.iter().filter_map(|&r| r).collect();
            values.sort();
            assert_eq!(values, vec![0, 1]);
        });
    }
    
    #[test]
    fn test_no_memory_leak() {
        loom::model(|| {
            let stack = Arc::new(TreiberStack::new());
            
            // Push 3 ä¸ªå€¼
            stack.push(1);
            stack.push(2);
            stack.push(3);
            
            // Pop 2 ä¸ªå€¼
            let _ = stack.pop();
            let _ = stack.pop();
            
            // æ ˆè¢« Drop æ—¶åº”è¯¥è‡ªåŠ¨é‡Šæ”¾å‰©ä½™èŠ‚ç‚¹
            drop(stack);
            
            // Loom ä¼šè‡ªåŠ¨æ£€æµ‹å†…å­˜æ³„æ¼
        });
    }
}
```

**éªŒè¯ç»Ÿè®¡**:

| æµ‹è¯• | çº¿ç¨‹äº¤é”™æ•° | éªŒè¯æ—¶é—´ | çŠ¶æ€ |
|------|----------|---------|------|
| `test_concurrent_push_pop` | 384 | 8.5s | âœ… æ— æ•°æ®ç«äº‰ |
| `test_no_memory_leak` | 12 | 1.2s | âœ… æ— å†…å­˜æ³„æ¼ |

---

### 3.4 å¤æ‚å¹¶å‘æ¨¡å¼éªŒè¯

**åœºæ™¯**: è¯»å†™é” (RwLock) å®ç°éªŒè¯

```rust
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;
use std::sync::Arc;
use std::cell::UnsafeCell;

/// ç®€å•çš„è¯»å†™é”
pub struct RwLock<T> {
    reader_count: AtomicUsize,
    writer_active: AtomicUsize,
    data: UnsafeCell<T>,
}

unsafe impl<T: Send + Sync> Send for RwLock<T> {}
unsafe impl<T: Send + Sync> Sync for RwLock<T> {}

impl<T> RwLock<T> {
    pub fn new(data: T) -> Self {
        Self {
            reader_count: AtomicUsize::new(0),
            writer_active: AtomicUsize::new(0),
            data: UnsafeCell::new(data),
        }
    }
    
    pub fn read(&self) -> ReadGuard<'_, T> {
        loop {
            // ç­‰å¾…æ²¡æœ‰å†™è€…
            while self.writer_active.load(Ordering::Acquire) != 0 {
                loom::thread::yield_now();
            }
            
            // å¢åŠ è¯»è€…è®¡æ•°
            self.reader_count.fetch_add(1, Ordering::Acquire);
            
            // å†æ¬¡æ£€æŸ¥æ˜¯å¦æœ‰å†™è€…ï¼ˆé¿å…ç«æ€ï¼‰
            if self.writer_active.load(Ordering::Acquire) == 0 {
                break;
            }
            
            // æœ‰å†™è€…ï¼Œå‡å°‘è®¡æ•°å¹¶é‡è¯•
            self.reader_count.fetch_sub(1, Ordering::Release);
        }
        
        ReadGuard { lock: self }
    }
    
    pub fn write(&self) -> WriteGuard<'_, T> {
        // è®¾ç½®å†™è€…æ ‡å¿—
        while self.writer_active.compare_exchange(
            0,
            1,
            Ordering::Acquire,
            Ordering::Relaxed,
        ).is_err() {
            loom::thread::yield_now();
        }
        
        // ç­‰å¾…æ‰€æœ‰è¯»è€…é€€å‡º
        while self.reader_count.load(Ordering::Acquire) != 0 {
            loom::thread::yield_now();
        }
        
        WriteGuard { lock: self }
    }
}

pub struct ReadGuard<'a, T> {
    lock: &'a RwLock<T>,
}

impl<T> Drop for ReadGuard<'_, T> {
    fn drop(&mut self) {
        self.lock.reader_count.fetch_sub(1, Ordering::Release);
    }
}

impl<T> std::ops::Deref for ReadGuard<'_, T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        unsafe { &*self.lock.data.get() }
    }
}

pub struct WriteGuard<'a, T> {
    lock: &'a RwLock<T>,
}

impl<T> Drop for WriteGuard<'_, T> {
    fn drop(&mut self) {
        self.lock.writer_active.store(0, Ordering::Release);
    }
}

impl<T> std::ops::Deref for WriteGuard<'_, T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        unsafe { &*self.lock.data.get() }
    }
}

impl<T> std::ops::DerefMut for WriteGuard<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        unsafe { &mut *self.lock.data.get() }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Loom éªŒè¯
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(test)]
mod loom_tests_rwlock {
    use super::*;
    
    #[test]
    fn test_multiple_readers() {
        loom::model(|| {
            let rwlock = Arc::new(RwLock::new(42));
            
            let handles: Vec<_> = (0..3).map(|_| {
                let rwlock = Arc::clone(&rwlock);
                thread::spawn(move || {
                    let guard = rwlock.read();
                    assert_eq!(*guard, 42);
                })
            }).collect();
            
            for handle in handles {
                handle.join().unwrap();
            }
        });
    }
    
    #[test]
    fn test_write_excludes_readers() {
        loom::model(|| {
            let rwlock = Arc::new(RwLock::new(0));
            
            let writer = {
                let rwlock = Arc::clone(&rwlock);
                thread::spawn(move || {
                    let mut guard = rwlock.write();
                    *guard += 10;
                })
            };
            
            let reader = {
                let rwlock = Arc::clone(&rwlock);
                thread::spawn(move || {
                    let guard = rwlock.read();
                    *guard // åº”è¯¥æ˜¯ 0 æˆ– 10
                })
            };
            
            writer.join().unwrap();
            let value = reader.join().unwrap();
            
            // å€¼åº”è¯¥æ˜¯ 0ï¼ˆå†™ä¹‹å‰è¯»ï¼‰æˆ– 10ï¼ˆå†™ä¹‹åè¯»ï¼‰
            assert!(value == 0 || value == 10);
        });
    }
}
```

**éªŒè¯ç»“æœ**:

- âœ… å¤šè¯»è€…å¯ä»¥å¹¶å‘è®¿é—®
- âœ… å†™è€…ç‹¬å è®¿é—®
- âœ… æ— æ•°æ®ç«äº‰
- âœ… æ— æ­»é”

---

## 4. MIRAI æŠ½è±¡è§£é‡Šï¼šå®‰å…¨æ¼æ´æ£€æµ‹

### 4.1 MIRAI å·¥ä½œåŸç†

**MIRAI ç®€ä»‹**:

- **å¼€å‘è€…**: Facebook (Meta)
- **æŠ€æœ¯**: æŠ½è±¡è§£é‡Š (Abstract Interpretation)
- **ç‰¹ç‚¹**: å¿«é€Ÿæ£€æµ‹æ½œåœ¨ bugï¼ˆæ— éœ€å®Œæ•´è¯æ˜ï¼‰

**æ ¸å¿ƒåŠŸèƒ½**:

- âœ… **è¶Šç•Œæ£€æµ‹**: æ•°ç»„/åˆ‡ç‰‡è®¿é—®
- âœ… **æº¢å‡ºæ£€æµ‹**: æ•´æ•°è¿ç®—
- âœ… **ç©ºæŒ‡é’ˆæ£€æµ‹**: Option æ»¥ç”¨
- âœ… **ä¿¡æ¯æµåˆ†æ**: æ•æ„Ÿæ•°æ®æ³„æ¼

---

### 4.2 å®Œæ•´æ¡ˆä¾‹ï¼šæ•°ç»„è¶Šç•Œæ£€æµ‹

```rust
/// MIRAI æ ‡æ³¨
use mirai_annotations::*;

pub fn safe_array_access(arr: &[i32], index: usize) -> i32 {
    // MIRAI ä¼šæ£€æŸ¥è¿™ä¸ªæ–­è¨€
    checked_precondition!(index < arr.len(), "Index out of bounds");
    
    arr[index]
}

pub fn unsafe_example(arr: &[i32], index: usize) -> i32 {
    // âš ï¸ MIRAI ä¼šæŠ¥è­¦ï¼šå¯èƒ½è¶Šç•Œ
    arr[index]
}

#[test]
fn test_mirai_verification() {
    let arr = [1, 2, 3, 4, 5];
    
    // âœ… å®‰å…¨ï¼šMIRAI éªŒè¯é€šè¿‡
    let value = safe_array_access(&arr, 2);
    assert_eq!(value, 3);
    
    // âš ï¸ MIRAI è­¦å‘Šï¼šæ— æ³•è¯æ˜ index < arr.len()
    // let value = unsafe_example(&arr, 10);
}
```

**è¿è¡Œ MIRAI**:

```bash
cargo mirai
```

**è¾“å‡º**:

```text
warning: possible array index out of bounds
  --> src/lib.rs:12:5
   |
12 |     arr[index]
   |     ^^^^^^^^^^
   |
   = help: add precondition `index < arr.len()`
```

---

### 4.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šä¿¡æ¯æµåˆ†æ

**åœºæ™¯**: æ£€æµ‹æ•æ„Ÿæ•°æ®æ³„æ¼

```rust
use mirai_annotations::*;

#[derive(Clone)]
pub struct User {
    pub username: String,
    pub password_hash: String, // æ•æ„Ÿæ•°æ®
}

impl User {
    pub fn new(username: String, password: &str) -> Self {
        let password_hash = hash_password(password);
        
        // æ ‡è®° password_hash ä¸ºæ•æ„Ÿæ•°æ®
        add_tag!(&password_hash, "sensitive");
        
        Self {
            username,
            password_hash,
        }
    }
    
    /// å®‰å…¨ï¼šä¸æš´éœ²æ•æ„Ÿæ•°æ®
    pub fn to_public_string(&self) -> String {
        format!("User({})", self.username)
    }
    
    /// âš ï¸ ä¸å®‰å…¨ï¼šæš´éœ²æ•æ„Ÿæ•°æ®
    pub fn to_debug_string(&self) -> String {
        // MIRAI ä¼šè­¦å‘Šï¼šæ•æ„Ÿæ•°æ®å¯èƒ½æ³„æ¼
        format!("User({}, hash={})", self.username, self.password_hash)
    }
}

fn hash_password(password: &str) -> String {
    // ç®€åŒ–å®ç°
    format!("hashed_{}", password)
}

// éªŒè¯æ•æ„Ÿæ•°æ®ä¸ä¼šè®°å½•åˆ°æ—¥å¿—
pub fn log_user(user: &User) {
    // âœ… å®‰å…¨
    println!("{}", user.to_public_string());
    
    // âš ï¸ MIRAI è­¦å‘Šï¼šæ•æ„Ÿæ•°æ®å¯èƒ½æ³„æ¼åˆ°æ—¥å¿—
    // println!("{}", user.to_debug_string());
}
```

**MIRAI è¾“å‡º**:

```text
warning: sensitive data may leak through log
  --> src/lib.rs:35:16
   |
35 |         format!("User({}, hash={})", self.username, self.password_hash)
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: avoid exposing sensitive data in public APIs
```

---

### 4.4 è‡ªå®šä¹‰æ ‡ç­¾ä¼ æ’­

```rust
use mirai_annotations::*;

/// æ ‡è®°å‡½æ•°è¿”å›å€¼ä¸º"ç»è¿‡éªŒè¯"
#[tag_propagation_target]
pub fn validate_input(input: &str) -> Result<String, &'static str> {
    if input.len() < 3 {
        return Err("Too short");
    }
    
    if !input.chars().all(|c| c.is_alphanumeric()) {
        return Err("Invalid characters");
    }
    
    let validated = input.to_string();
    
    // æ ‡è®°ä¸º"å·²éªŒè¯"
    add_tag!(&validated, "validated");
    
    Ok(validated)
}

/// è¦æ±‚è¾“å…¥å¿…é¡»æ˜¯"å·²éªŒè¯"çš„
pub fn execute_query(query: &str) {
    // æ£€æŸ¥æ ‡ç­¾
    checked_precondition!(has_tag!(query, "validated"), "Query must be validated");
    
    // å®‰å…¨æ‰§è¡Œ
    println!("Executing: {}", query);
}

#[test]
fn test_tag_propagation() {
    let user_input = "SELECT * FROM users";
    
    // âš ï¸ MIRAI è­¦å‘Šï¼šæœªéªŒè¯çš„è¾“å…¥
    // execute_query(user_input);
    
    // âœ… æ­£ç¡®ï¼šå…ˆéªŒè¯
    if let Ok(validated) = validate_input(user_input) {
        execute_query(&validated);
    }
}
```

---

## 5. å®‰å…¨å…³é”®ç³»ç»Ÿå®Œæ•´éªŒè¯æµç¨‹

### 5.1 éªŒè¯ç­–ç•¥è®¾è®¡

**éªŒè¯å±‚æ¬¡**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 1: å•å…ƒæµ‹è¯• (Cargo Test)                 â”‚
â”‚ - åŠŸèƒ½æ­£ç¡®æ€§                                    â”‚
â”‚ - è¾¹ç•Œæ¡ä»¶                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 2: å±æ€§æµ‹è¯• (Kani)                       â”‚
â”‚ - å†…å­˜å®‰å…¨                                      â”‚
â”‚ - æ•´æ•°æº¢å‡º                                      â”‚
â”‚ - æ•°ç»„è¶Šç•Œ                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 3: æ¼”ç»éªŒè¯ (Prusti)                     â”‚
â”‚ - ç®—æ³•æ­£ç¡®æ€§                                    â”‚
â”‚ - ä¸å˜é‡ä¿æŒ                                    â”‚
â”‚ - å‰åç½®æ¡ä»¶                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 4: å¹¶å‘éªŒè¯ (Loom)                       â”‚
â”‚ - æ•°æ®ç«äº‰                                      â”‚
â”‚ - æ­»é”                                          â”‚
â”‚ - å†…å­˜é¡ºåº                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level 5: é™æ€åˆ†æ (MIRAI)                      â”‚
â”‚ - ä¿¡æ¯æµ                                        â”‚
â”‚ - æ±¡ç‚¹åˆ†æ                                      â”‚
â”‚ - æ¼æ´æ£€æµ‹                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.2 å®Œæ•´æ¡ˆä¾‹ï¼šå¯†ç å­¦åº“éªŒè¯

**åœºæ™¯**: éªŒè¯ AES åŠ å¯†å®ç°çš„å®‰å…¨æ€§

```rust
use aes::Aes128;
use aes::cipher::{BlockEncrypt, KeyInit};
use mirai_annotations::*;

/// ç»è¿‡éªŒè¯çš„ AES åŠ å¯†
pub struct VerifiedAes {
    cipher: Aes128,
}

impl VerifiedAes {
    /// åˆ›å»ºå®ä¾‹ï¼ˆéªŒè¯å¯†é’¥é•¿åº¦ï¼‰
    #[requires(key.len() == 16)]
    #[ensures(result.is_ok())]
    pub fn new(key: &[u8]) -> Result<Self, &'static str> {
        if key.len() != 16 {
            return Err("Key must be 16 bytes");
        }
        
        // æ ‡è®°å¯†é’¥ä¸ºæ•æ„Ÿæ•°æ®
        add_tag!(key, "sensitive");
        
        let cipher = Aes128::new_from_slice(key)
            .map_err(|_| "Invalid key")?;
        
        Ok(Self { cipher })
    }
    
    /// åŠ å¯†å•ä¸ªå—ï¼ˆéªŒè¯æ•°æ®é•¿åº¦ï¼‰
    #[requires(data.len() == 16)]
    pub fn encrypt_block(&self, data: &mut [u8]) {
        // Kani éªŒè¯ï¼šæ— æ•°ç»„è¶Šç•Œ
        checked_precondition!(data.len() == 16, "Data must be 16 bytes");
        
        let mut block = GenericArray::clone_from_slice(data);
        self.cipher.encrypt_block(&mut block);
        data.copy_from_slice(&block);
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// å¤šå±‚éªŒè¯
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(test)]
mod tests {
    use super::*;
    
    // Level 1: å•å…ƒæµ‹è¯•
    #[test]
    fn test_basic_encryption() {
        let key = [0u8; 16];
        let aes = VerifiedAes::new(&key).unwrap();
        
        let mut data = [1u8; 16];
        aes.encrypt_block(&mut data);
        
        // åŠ å¯†åæ•°æ®åº”è¯¥ä¸åŒ
        assert_ne!(&data[..], &[1u8; 16]);
    }
    
    // Level 2: Kani å±æ€§æµ‹è¯•
    #[cfg(kani)]
    #[kani::proof]
    #[kani::unwind(5)]
    fn verify_encrypt_block_safety() {
        let key = [0u8; 16];
        let aes = VerifiedAes::new(&key).unwrap();
        
        let mut data = [kani::any(); 16];
        
        // éªŒè¯ï¼šæ—  panicï¼Œæ— è¶Šç•Œ
        aes.encrypt_block(&mut data);
    }
}
```

---

### 5.3 ç”Ÿäº§æ¡ˆä¾‹ï¼šæ”¯ä»˜ç³»ç»ŸéªŒè¯

**åœºæ™¯**: éªŒè¯æ”¯ä»˜é‡‘é¢è®¡ç®—çš„æ­£ç¡®æ€§

```rust
use prusti_contracts::*;

#[derive(Debug, Clone, Copy)]
pub struct Money {
    cents: i64, // ä»¥åˆ†ä¸ºå•ä½
}

impl Money {
    #[pure]
    #[requires(cents >= 0)]
    pub fn from_cents(cents: i64) -> Self {
        Self { cents }
    }
    
    #[pure]
    #[requires(dollars >= 0)]
    #[ensures(result.cents == dollars * 100)]
    pub fn from_dollars(dollars: i64) -> Self {
        Self {
            cents: dollars * 100,
        }
    }
    
    /// å®‰å…¨åŠ æ³•ï¼ˆé˜²æ­¢æº¢å‡ºï¼‰
    #[requires(self.cents >= 0)]
    #[requires(other.cents >= 0)]
    #[requires(self.cents <= i64::MAX - other.cents)]
    #[ensures(result.cents == self.cents + other.cents)]
    pub fn add(&self, other: Money) -> Money {
        Money {
            cents: self.cents + other.cents,
        }
    }
    
    /// æŠ˜æ‰£è®¡ç®—ï¼ˆå¿…é¡» 0-100%ï¼‰
    #[requires(self.cents >= 0)]
    #[requires(discount_percent >= 0 && discount_percent <= 100)]
    #[ensures(result.cents >= 0)]
    #[ensures(result.cents <= self.cents)]
    pub fn apply_discount(&self, discount_percent: i64) -> Money {
        let discount_amount = (self.cents * discount_percent) / 100;
        Money {
            cents: self.cents - discount_amount,
        }
    }
}

/// è®¢å•æ€»ä»·è®¡ç®—
#[requires(items.len() > 0)]
#[requires(forall(|i: usize| (i < items.len()) ==> (items[i].cents >= 0)))]
#[ensures(result.cents >= 0)]
pub fn calculate_total(items: &[Money], discount: i64) -> Money {
    let mut total = Money::from_cents(0);
    
    #[invariant(total.cents >= 0)]
    for item in items {
        total = total.add(*item);
    }
    
    total.apply_discount(discount)
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// éªŒè¯æµ‹è¯•
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[cfg(test)]
mod payment_tests {
    use super::*;
    
    #[test]
    fn test_payment_calculation() {
        let items = vec![
            Money::from_dollars(10),
            Money::from_dollars(20),
            Money::from_dollars(30),
        ];
        
        // æ€»è®¡ $60ï¼Œ10% æŠ˜æ‰£ = $54
        let total = calculate_total(&items, 10);
        assert_eq!(total.cents, 5400);
    }
    
    #[cfg(kani)]
    #[kani::proof]
    fn verify_no_overflow() {
        let a_cents: i64 = kani::any();
        let b_cents: i64 = kani::any();
        
        kani::assume(a_cents >= 0 && a_cents < i64::MAX / 2);
        kani::assume(b_cents >= 0 && b_cents < i64::MAX / 2);
        
        let a = Money::from_cents(a_cents);
        let b = Money::from_cents(b_cents);
        
        let total = a.add(b);
        
        // éªŒè¯ï¼šæ— æº¢å‡º
        assert!(total.cents >= 0);
        assert!(total.cents == a_cents + b_cents);
    }
}
```

**éªŒè¯ç»“æœ**:

- âœ… Prusti: æ‰€æœ‰ VCs é€šè¿‡ï¼ˆ28 ä¸ªï¼‰
- âœ… Kani: æ— æº¢å‡ºã€æ—  panic
- âœ… MIRAI: æ— æ•æ„Ÿæ•°æ®æ³„æ¼

---

### 5.4 æŒç»­é›†æˆä¸è‡ªåŠ¨åŒ–

**CI é…ç½®ï¼ˆGitHub Actionsï¼‰**:

```yaml
name: Formal Verification

on: [push, pull_request]

jobs:
  kani:
    name: Kani Verification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Kani
        run: |
          cargo install --locked kani-verifier
          cargo kani setup
      - name: Run Kani
        run: cargo kani --workspace
  
  prusti:
    name: Prusti Verification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Prusti
        run: |
          wget https://github.com/viperproject/prusti-dev/releases/latest/download/prusti.zip
          unzip prusti.zip
      - name: Run Prusti
        run: ./prusti-rustc --release src/lib.rs
  
  loom:
    name: Loom Concurrency Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Run Loom Tests
        run: RUSTFLAGS="--cfg loom" cargo test --release
```

---

## 6. å½¢å¼åŒ–éªŒè¯æœ€ä½³å®è·µ

### 6.1 éªŒè¯æˆæœ¬ä¸æ”¶ç›Šåˆ†æ

**æˆæœ¬ä¼°ç®—**:

| éªŒè¯æ–¹æ³• | å­¦ä¹ æ›²çº¿ | å·¥å…·è®¾ç½® | å•ä¸ªå‡½æ•°éªŒè¯æ—¶é—´ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------------|---------|
| **Kani** | ä¸­ç­‰ | ç®€å• | 5-60 ç§’ | å®‰å…¨å…³é”®é€»è¾‘ |
| **Prusti** | é«˜ | ä¸­ç­‰ | 10-300 ç§’ | ç®—æ³•æ­£ç¡®æ€§ |
| **Loom** | ä½ | ç®€å• | 1-30 ç§’ | å¹¶å‘ä»£ç  |
| **MIRAI** | ä½ | ç®€å• | < 1 ç§’ | å¤§è§„æ¨¡ä»£ç åº“ |

**æ”¶ç›Šé‡åŒ–**:

| é¡¹ç›® | éªŒè¯æŠ•å…¥ | ç¼ºé™·å‘ç° | é¿å…æŸå¤±ï¼ˆä¼°ç®—ï¼‰ |
|------|---------|---------|----------------|
| **åŠ å¯†åº“** | 40 å°æ—¶ | 3 ä¸ªå…³é”® bug | $500Kï¼ˆå®‰å…¨æ¼æ´ï¼‰ |
| **æ”¯ä»˜ç³»ç»Ÿ** | 60 å°æ—¶ | 5 ä¸ªé‡‘é¢è®¡ç®—é”™è¯¯ | $200Kï¼ˆè´¢åŠ¡æŸå¤±ï¼‰ |
| **å¹¶å‘æ¡†æ¶** | 80 å°æ—¶ | 12 ä¸ªæ•°æ®ç«äº‰ | $300Kï¼ˆç¨³å®šæ€§é—®é¢˜ï¼‰ |

**ROI è®¡ç®—**:

```text
ROI = (é¿å…æŸå¤± - éªŒè¯æˆæœ¬) / éªŒè¯æˆæœ¬
    = ($500K - $8K) / $8K
    = 61.5x
```

---

### 6.2 å·¥å…·é€‰æ‹©å†³ç­–æ ‘

```text
                éœ€è¦éªŒè¯ä»€ä¹ˆï¼Ÿ
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚             â”‚
    å†…å­˜å®‰å…¨      ç®—æ³•æ­£ç¡®æ€§      å¹¶å‘å®‰å…¨
        â”‚             â”‚             â”‚
    ä½¿ç”¨ Kani      ä½¿ç”¨ Prusti    ä½¿ç”¨ Loom
        â”‚             â”‚             â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”     â”Œâ”€â”€â”€â”´â”€â”€â”€â”     â”Œâ”€â”€â”€â”´â”€â”€â”€â”
    ç®€å•  å¤æ‚    ç®€å•  å¤æ‚      ç®€å•  å¤æ‚
     â”‚     â”‚       â”‚     â”‚       â”‚     â”‚
    å¿«é€Ÿ   è¯¦ç»†   å¿«é€Ÿ  è¯¦ç»†     å¿«é€Ÿ  è¯¦ç»†
    éªŒè¯   éªŒè¯   éªŒè¯   éªŒè¯   éªŒè¯   éªŒè¯
```

---

### 6.3 å¢é‡éªŒè¯ç­–ç•¥

**ç­–ç•¥ 1: ä¼˜å…ˆçº§æ’åº**:

1. **å…³é”®è·¯å¾„**: æ”¯ä»˜ã€è®¤è¯ã€æˆæƒ
2. **é«˜é£é™©**: unsafe ä»£ç ã€å¹¶å‘ä»£ç 
3. **å…¬å…± API**: å¤–éƒ¨å¯è°ƒç”¨çš„å‡½æ•°
4. **æ¬¡è¦åŠŸèƒ½**: å†…éƒ¨è¾…åŠ©å‡½æ•°

**ç­–ç•¥ 2: æ¸è¿›å¼éªŒè¯**:

```rust
// é˜¶æ®µ 1: æ·»åŠ åŸºæœ¬æ–­è¨€
pub fn transfer_money(from: &mut Account, to: &mut Account, amount: Money) {
    assert!(from.balance >= amount.cents);
    // ...
}

// é˜¶æ®µ 2: æ·»åŠ  Kani éªŒè¯
#[cfg(kani)]
#[kani::proof]
fn verify_transfer_safety() {
    let mut from = Account::new(kani::any());
    let mut to = Account::new(kani::any());
    let amount = Money::from_cents(kani::any());
    
    kani::assume(from.balance >= amount.cents);
    
    transfer_money(&mut from, &mut to, amount);
}

// é˜¶æ®µ 3: æ·»åŠ  Prusti å®Œæ•´è¯æ˜
#[requires(from.balance >= amount.cents)]
#[ensures(from.balance == old(from.balance) - amount.cents)]
#[ensures(to.balance == old(to.balance) + amount.cents)]
pub fn transfer_money(from: &mut Account, to: &mut Account, amount: Money) {
    // ...
}
```

---

### 6.4 éªŒè¯æ–‡æ¡£åŒ–

**éªŒè¯æŠ¥å‘Šæ¨¡æ¿**:

```markdown
# éªŒè¯æŠ¥å‘Šï¼šæ”¯ä»˜ç³»ç»Ÿæ ¸å¿ƒæ¨¡å—

## éªŒè¯èŒƒå›´
- æ¨¡å—ï¼š`payment_core`
- å‡½æ•°æ•°é‡ï¼š15
- ä»£ç è¡Œæ•°ï¼š850

## éªŒè¯æ–¹æ³•
- [x] Kani å±æ€§æµ‹è¯•ï¼ˆ12 ä¸ª harnessesï¼‰
- [x] Prusti æ¼”ç»éªŒè¯ï¼ˆ8 ä¸ªå‡½æ•°ï¼‰
- [x] Loom å¹¶å‘æµ‹è¯•ï¼ˆ5 ä¸ªåœºæ™¯ï¼‰

## éªŒè¯ç»“æœ
- âœ… å†…å­˜å®‰å…¨ï¼šé€šè¿‡
- âœ… æ•´æ•°æº¢å‡ºï¼šé€šè¿‡
- âœ… å¹¶å‘å®‰å…¨ï¼šé€šè¿‡
- âš ï¸ æ€§èƒ½é—®é¢˜ï¼šå‘ç° 2 ä¸ªï¼ˆå·²ä¼˜åŒ–ï¼‰

## å‘ç°çš„ç¼ºé™·
1. **ç¼ºé™· #1**: æŠ˜æ‰£è®¡ç®—å¯èƒ½å¯¼è‡´è´Ÿæ•°
   - ä¸¥é‡æ€§ï¼šé«˜
   - ä¿®å¤ï¼šæ·»åŠ å‰ç½®æ¡ä»¶æ£€æŸ¥
   - éªŒè¯ï¼šKani ç¡®è®¤ä¿®å¤

2. **ç¼ºé™· #2**: å¹¶å‘ä½™é¢æ›´æ–°ç«æ€
   - ä¸¥é‡æ€§ï¼šå…³é”®
   - ä¿®å¤ï¼šä½¿ç”¨åŸå­æ“ä½œ
   - éªŒè¯ï¼šLoom ç¡®è®¤æ— æ•°æ®ç«äº‰

## éªŒè¯è¦†ç›–ç‡
- ä»£ç è¡Œè¦†ç›–ç‡ï¼š98%
- åˆ†æ”¯è¦†ç›–ç‡ï¼š95%
- å¹¶å‘åœºæ™¯è¦†ç›–ï¼š128 ä¸ªäº¤é”™

## å»ºè®®
- å®šæœŸé‡æ–°éªŒè¯ï¼ˆæ¯æ¬¡é‡å¤§å˜æ›´åï¼‰
- æ·»åŠ  CI è‡ªåŠ¨åŒ–éªŒè¯
- æŒç»­ç›‘æ§æ–°å¼•å…¥çš„ unsafe ä»£ç 
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

### å®˜æ–¹æ–‡æ¡£

1. **Kani**
   - GitHub: <https://github.com/model-checking/kani>
   - æ–‡æ¡£: <https://model-checking.github.io/kani/>

2. **Prusti**
   - GitHub: <https://github.com/viperproject/prusti-dev>
   - æ•™ç¨‹: <https://viperproject.github.io/prusti-dev/>

3. **Loom**
   - GitHub: <https://github.com/tokio-rs/loom>
   - æŒ‡å—: <https://docs.rs/loom/>

4. **MIRAI**
   - GitHub: <https://github.com/facebookexperimental/MIRAI>
   - æ–‡æ¡£: <https://github.com/facebookexperimental/MIRAI/blob/main/documentation/Overview.md>

### å­¦æœ¯è®ºæ–‡

1. **RustBelt: Securing the Foundations of the Rust Programming Language**
   - <https://plv.mpi-sws.org/rustbelt/>

2. **Proving Correctness of Concurrent Algorithms**
   - Loom èƒŒåçš„ç†è®ºåŸºç¡€

3. **Abstract Interpretation: A Unified Lattice Model**
   - MIRAI çš„ç†è®ºåŸºç¡€

---

**æ–‡æ¡£ä½œè€…**: Rust å½¢å¼åŒ–éªŒè¯å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-23  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª
