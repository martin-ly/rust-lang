# 3.5.2 Rust æ¶æ„è®¾è®¡æ¨¡å¼ - å®Œæ•´å®æˆ˜æ¡ˆä¾‹

> **æ–‡æ¡£å®šä½**: ç«¯åˆ°ç«¯æ¶æ„å®æˆ˜æ¡ˆä¾‹ï¼Œå¯å¤åˆ¶çš„è®¾è®¡æ¨¡å¼  
> **é€‚ç”¨äººç¾¤**: æ¶æ„å¸ˆã€æŠ€æœ¯è´Ÿè´£äººã€é«˜çº§å¼€å‘è€…  
> **å…³è”æ–‡æ¡£**: [3.5 æ¶æ„æ¨¡å¼é›†](3.5_æ¶æ„è®¾è®¡æ¨¡å¼é›†.md) | [3.4 æ€§èƒ½æŠ¥å‘Š](3.4_æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š.md) | [1.1 ä¸»ç´¢å¼•](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æœ€åæ›´æ–°**: 2025-10-23  
**Rust ç‰ˆæœ¬**: 1.90+  
**æ¡ˆä¾‹æ•°é‡**: 5 ä¸ªå®Œæ•´æ¡ˆä¾‹  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [3.5.2 Rust æ¶æ„è®¾è®¡æ¨¡å¼ - å®Œæ•´å®æˆ˜æ¡ˆä¾‹](#352-rust-æ¶æ„è®¾è®¡æ¨¡å¼---å®Œæ•´å®æˆ˜æ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®Œæ•´çš„ CQRS + Event Sourcing ç³»ç»Ÿ](#1-å®Œæ•´çš„-cqrs--event-sourcing-ç³»ç»Ÿ)
    - [1.1 æ¶æ„è®¾è®¡](#11-æ¶æ„è®¾è®¡)
    - [1.2 é¢†åŸŸæ¨¡å‹](#12-é¢†åŸŸæ¨¡å‹)
    - [1.3 å®Œæ•´å®ç°](#13-å®Œæ•´å®ç°)
      - [3.1 Event Store (äº‹ä»¶å­˜å‚¨)](#31-event-store-äº‹ä»¶å­˜å‚¨)
      - [3.2 å‘½ä»¤æœåŠ¡ï¼ˆWrite Sideï¼‰](#32-å‘½ä»¤æœåŠ¡write-side)
      - [3.3 æŸ¥è¯¢æœåŠ¡ï¼ˆRead Sideï¼‰](#33-æŸ¥è¯¢æœåŠ¡read-side)
    - [1.4 æ€§èƒ½ä¼˜åŒ–](#14-æ€§èƒ½ä¼˜åŒ–)
      - [å¿«ç…§ï¼ˆSnapshotï¼‰](#å¿«ç…§snapshot)
  - [2. åˆ†å¸ƒå¼é™æµç³»ç»Ÿ](#2-åˆ†å¸ƒå¼é™æµç³»ç»Ÿ)
    - [2.1 æ»‘åŠ¨çª—å£é™æµå™¨](#21-æ»‘åŠ¨çª—å£é™æµå™¨)
    - [2.2 ä»¤ç‰Œæ¡¶é™æµå™¨](#22-ä»¤ç‰Œæ¡¶é™æµå™¨)
  - [3. æœåŠ¡é™çº§ä¸ç†”æ–­å™¨å®æˆ˜](#3-æœåŠ¡é™çº§ä¸ç†”æ–­å™¨å®æˆ˜)
    - [3.1 å®Œæ•´çš„ç†”æ–­å™¨å®ç°](#31-å®Œæ•´çš„ç†”æ–­å™¨å®ç°)
    - [3.2 æœåŠ¡é™çº§ç­–ç•¥](#32-æœåŠ¡é™çº§ç­–ç•¥)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## 1. å®Œæ•´çš„ CQRS + Event Sourcing ç³»ç»Ÿ

### 1.1 æ¶æ„è®¾è®¡

**ç³»ç»Ÿæ¦‚è§ˆ**: ç”µå•†è®¢å•ç®¡ç†ç³»ç»Ÿ

```text
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    Client    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚     API Gateway      â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   Command   â”‚               â”‚     Query      â”‚
     â”‚   Service   â”‚               â”‚    Service     â”‚
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   Event     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   Read Model   â”‚
     â”‚   Store     â”‚   Event Bus   â”‚   (PostgreSQL) â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
     â”‚  Event Log  â”‚
     â”‚ (Append-Only)â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒåŸåˆ™**:

1. âœ… **å‘½ä»¤ä¸æŸ¥è¯¢åˆ†ç¦»**: å†™å…¥å’Œè¯»å–ä½¿ç”¨ä¸åŒçš„æ¨¡å‹
2. âœ… **äº‹ä»¶æº¯æº**: æ‰€æœ‰çŠ¶æ€å˜æ›´è®°å½•ä¸ºäº‹ä»¶
3. âœ… **æœ€ç»ˆä¸€è‡´æ€§**: è¯»æ¨¡å‹å¼‚æ­¥æ›´æ–°
4. âœ… **å®¡è®¡å®Œæ•´**: æ‰€æœ‰å†å²å¯è¿½æº¯

---

### 1.2 é¢†åŸŸæ¨¡å‹

```rust
// ============================================
// 1. äº‹ä»¶å®šä¹‰ï¼ˆEvent Sourcing çš„æ ¸å¿ƒï¼‰
// ============================================

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum OrderEvent {
    OrderCreated {
        order_id: Uuid,
        user_id: Uuid,
        items: Vec<OrderItem>,
        total: f64,
        created_at: DateTime<Utc>,
    },
    OrderPaid {
        order_id: Uuid,
        payment_id: String,
        amount: f64,
        paid_at: DateTime<Utc>,
    },
    OrderShipped {
        order_id: Uuid,
        tracking_number: String,
        shipped_at: DateTime<Utc>,
    },
    OrderCancelled {
        order_id: Uuid,
        reason: String,
        cancelled_at: DateTime<Utc>,
    },
    OrderDelivered {
        order_id: Uuid,
        delivered_at: DateTime<Utc>,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderItem {
    pub product_id: Uuid,
    pub quantity: i32,
    pub price: f64,
}

// ============================================
// 2. èšåˆæ ¹ï¼ˆAggregate Rootï¼‰
// ============================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderStatus {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}

#[derive(Debug, Clone)]
pub struct Order {
    pub id: Uuid,
    pub user_id: Uuid,
    pub items: Vec<OrderItem>,
    pub total: f64,
    pub status: OrderStatus,
    pub created_at: DateTime<Utc>,
    pub paid_at: Option<DateTime<Utc>>,
    pub shipped_at: Option<DateTime<Utc>>,
    pub delivered_at: Option<DateTime<Utc>>,
    
    // ç‰ˆæœ¬å·ï¼ˆä¹è§‚é”ï¼‰
    pub version: u64,
    
    // æœªæäº¤çš„äº‹ä»¶
    uncommitted_events: Vec<OrderEvent>,
}

impl Order {
    // ä»äº‹ä»¶æµé‡å»ºèšåˆæ ¹
    pub fn from_events(events: Vec<OrderEvent>) -> Result<Self, Error> {
        if events.is_empty() {
            return Err(Error::EmptyEventStream);
        }
        
        let mut order = match &events[0] {
            OrderEvent::OrderCreated {
                order_id,
                user_id,
                items,
                total,
                created_at,
            } => Self {
                id: *order_id,
                user_id: *user_id,
                items: items.clone(),
                total: *total,
                status: OrderStatus::Pending,
                created_at: *created_at,
                paid_at: None,
                shipped_at: None,
                delivered_at: None,
                version: 0,
                uncommitted_events: Vec::new(),
            },
            _ => return Err(Error::InvalidFirstEvent),
        };
        
        // åº”ç”¨åç»­äº‹ä»¶
        for event in events.into_iter().skip(1) {
            order.apply_event(event)?;
        }
        
        Ok(order)
    }
    
    // åº”ç”¨äº‹ä»¶ï¼ˆä¿®æ”¹çŠ¶æ€ï¼‰
    fn apply_event(&mut self, event: OrderEvent) -> Result<(), Error> {
        match event {
            OrderEvent::OrderCreated { .. } => {
                // å·²åœ¨æ„é€ å‡½æ•°ä¸­å¤„ç†
            }
            OrderEvent::OrderPaid { paid_at, .. } => {
                if self.status != OrderStatus::Pending {
                    return Err(Error::InvalidTransition);
                }
                self.status = OrderStatus::Paid;
                self.paid_at = Some(paid_at);
            }
            OrderEvent::OrderShipped { shipped_at, tracking_number, .. } => {
                if self.status != OrderStatus::Paid {
                    return Err(Error::InvalidTransition);
                }
                self.status = OrderStatus::Shipped;
                self.shipped_at = Some(shipped_at);
            }
            OrderEvent::OrderDelivered { delivered_at, .. } => {
                if self.status != OrderStatus::Shipped {
                    return Err(Error::InvalidTransition);
                }
                self.status = OrderStatus::Delivered;
                self.delivered_at = Some(delivered_at);
            }
            OrderEvent::OrderCancelled { cancelled_at, .. } => {
                if matches!(self.status, OrderStatus::Delivered | OrderStatus::Cancelled) {
                    return Err(Error::InvalidTransition);
                }
                self.status = OrderStatus::Cancelled;
            }
        }
        
        self.version += 1;
        Ok(())
    }
    
    // è®°å½•æœªæäº¤çš„äº‹ä»¶
    fn record_event(&mut self, event: OrderEvent) {
        self.uncommitted_events.push(event.clone());
        let _ = self.apply_event(event);
    }
    
    // è·å–æœªæäº¤çš„äº‹ä»¶
    pub fn uncommitted_events(&self) -> &[OrderEvent] {
        &self.uncommitted_events
    }
    
    // æ¸…ç©ºæœªæäº¤çš„äº‹ä»¶
    pub fn clear_uncommitted_events(&mut self) {
        self.uncommitted_events.clear();
    }
}

// ============================================
// 3. å‘½ä»¤ï¼ˆCommandsï¼‰
// ============================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCommand {
    CreateOrder {
        order_id: Uuid,
        user_id: Uuid,
        items: Vec<OrderItem>,
    },
    PayOrder {
        order_id: Uuid,
        payment_id: String,
        amount: f64,
    },
    ShipOrder {
        order_id: Uuid,
        tracking_number: String,
    },
    CancelOrder {
        order_id: Uuid,
        reason: String,
    },
}

// ============================================
// 4. å‘½ä»¤å¤„ç†å™¨ï¼ˆCommand Handlerï¼‰
// ============================================

impl Order {
    // å¤„ç†åˆ›å»ºè®¢å•å‘½ä»¤
    pub fn create(
        order_id: Uuid,
        user_id: Uuid,
        items: Vec<OrderItem>,
    ) -> Result<Self, Error> {
        // ä¸šåŠ¡è§„åˆ™éªŒè¯
        if items.is_empty() {
            return Err(Error::EmptyOrder);
        }
        
        let total = items.iter().map(|item| item.price * item.quantity as f64).sum();
        
        if total <= 0.0 {
            return Err(Error::InvalidTotal);
        }
        
        // åˆ›å»ºäº‹ä»¶
        let event = OrderEvent::OrderCreated {
            order_id,
            user_id,
            items: items.clone(),
            total,
            created_at: Utc::now(),
        };
        
        // åº”ç”¨äº‹ä»¶
        let mut order = Self::from_events(vec![event])?;
        
        Ok(order)
    }
    
    // å¤„ç†æ”¯ä»˜å‘½ä»¤
    pub fn pay(&mut self, payment_id: String, amount: f64) -> Result<(), Error> {
        // ä¸šåŠ¡è§„åˆ™éªŒè¯
        if self.status != OrderStatus::Pending {
            return Err(Error::OrderNotPending);
        }
        
        if (amount - self.total).abs() > 0.01 {
            return Err(Error::InvalidPaymentAmount);
        }
        
        // åˆ›å»ºäº‹ä»¶
        let event = OrderEvent::OrderPaid {
            order_id: self.id,
            payment_id,
            amount,
            paid_at: Utc::now(),
        };
        
        // è®°å½•äº‹ä»¶
        self.record_event(event);
        
        Ok(())
    }
    
    // å¤„ç†å‘è´§å‘½ä»¤
    pub fn ship(&mut self, tracking_number: String) -> Result<(), Error> {
        if self.status != OrderStatus::Paid {
            return Err(Error::OrderNotPaid);
        }
        
        let event = OrderEvent::OrderShipped {
            order_id: self.id,
            tracking_number,
            shipped_at: Utc::now(),
        };
        
        self.record_event(event);
        
        Ok(())
    }
    
    // å¤„ç†å–æ¶ˆå‘½ä»¤
    pub fn cancel(&mut self, reason: String) -> Result<(), Error> {
        if matches!(self.status, OrderStatus::Delivered | OrderStatus::Cancelled) {
            return Err(Error::CannotCancel);
        }
        
        let event = OrderEvent::OrderCancelled {
            order_id: self.id,
            reason,
            cancelled_at: Utc::now(),
        };
        
        self.record_event(event);
        
        Ok(())
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Empty event stream")]
    EmptyEventStream,
    #[error("Invalid first event")]
    InvalidFirstEvent,
    #[error("Invalid state transition")]
    InvalidTransition,
    #[error("Empty order")]
    EmptyOrder,
    #[error("Invalid total")]
    InvalidTotal,
    #[error("Order not pending")]
    OrderNotPending,
    #[error("Invalid payment amount")]
    InvalidPaymentAmount,
    #[error("Order not paid")]
    OrderNotPaid,
    #[error("Cannot cancel order")]
    CannotCancel,
}
```

---

### 1.3 å®Œæ•´å®ç°

#### 3.1 Event Store (äº‹ä»¶å­˜å‚¨)

```rust
use sqlx::{PgPool, postgres::PgRow, Row};
use serde_json;

pub struct EventStore {
    pool: PgPool,
}

impl EventStore {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    // ä¿å­˜äº‹ä»¶ï¼ˆç¡®ä¿åŸå­æ€§ï¼‰
    pub async fn save_events(
        &self,
        aggregate_id: Uuid,
        events: &[OrderEvent],
        expected_version: u64,
    ) -> Result<(), Error> {
        let mut tx = self.pool.begin().await?;
        
        for (i, event) in events.iter().enumerate() {
            let version = expected_version + i as u64 + 1;
            let event_type = event.event_type();
            let event_data = serde_json::to_value(event)?;
            
            sqlx::query(
                r#"
                INSERT INTO events (
                    aggregate_id, 
                    aggregate_type, 
                    version, 
                    event_type, 
                    event_data, 
                    created_at
                )
                VALUES ($1, $2, $3, $4, $5, NOW())
                "#
            )
            .bind(aggregate_id)
            .bind("Order")
            .bind(version as i64)
            .bind(event_type)
            .bind(event_data)
            .execute(&mut *tx)
            .await?;
        }
        
        tx.commit().await?;
        
        // å‘å¸ƒäº‹ä»¶åˆ°äº‹ä»¶æ€»çº¿
        for event in events {
            self.publish_event(event).await?;
        }
        
        Ok(())
    }
    
    // åŠ è½½äº‹ä»¶æµ
    pub async fn load_events(&self, aggregate_id: Uuid) -> Result<Vec<OrderEvent>, Error> {
        let rows = sqlx::query(
            r#"
            SELECT event_data 
            FROM events 
            WHERE aggregate_id = $1 
            ORDER BY version ASC
            "#
        )
        .bind(aggregate_id)
        .fetch_all(&self.pool)
        .await?;
        
        let mut events = Vec::new();
        for row in rows {
            let event_data: serde_json::Value = row.get("event_data");
            let event: OrderEvent = serde_json::from_value(event_data)?;
            events.push(event);
        }
        
        Ok(events)
    }
    
    // å‘å¸ƒäº‹ä»¶åˆ° Kafka/Redis Streams
    async fn publish_event(&self, event: &OrderEvent) -> Result<(), Error> {
        // å®ç°äº‹ä»¶å‘å¸ƒé€»è¾‘
        // ä½¿ç”¨ Kafka æˆ– Redis Streams
        Ok(())
    }
}

// æ•°æ®åº“ Schema
/*
CREATE TABLE events (
    id BIGSERIAL PRIMARY KEY,
    aggregate_id UUID NOT NULL,
    aggregate_type VARCHAR(50) NOT NULL,
    version BIGINT NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    event_data JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    UNIQUE(aggregate_id, version)
);

CREATE INDEX idx_events_aggregate ON events(aggregate_id, version);
CREATE INDEX idx_events_created_at ON events(created_at);
*/
```

#### 3.2 å‘½ä»¤æœåŠ¡ï¼ˆWrite Sideï¼‰

```rust
use axum::{
    Router,
    routing::{post, get},
    extract::{State, Path, Json},
    http::StatusCode,
};
use std::sync::Arc;

pub struct CommandService {
    event_store: Arc<EventStore>,
}

impl CommandService {
    pub fn new(event_store: Arc<EventStore>) -> Self {
        Self { event_store }
    }
    
    pub fn routes(self: Arc<Self>) -> Router {
        Router::new()
            .route("/orders", post(create_order))
            .route("/orders/:id/pay", post(pay_order))
            .route("/orders/:id/ship", post(ship_order))
            .route("/orders/:id/cancel", post(cancel_order))
            .with_state(self)
    }
}

// API Handlers

async fn create_order(
    State(service): State<Arc<CommandService>>,
    Json(cmd): Json<CreateOrderRequest>,
) -> Result<Json<CreateOrderResponse>, AppError> {
    // 1. åˆ›å»ºèšåˆæ ¹
    let order = Order::create(
        Uuid::new_v4(),
        cmd.user_id,
        cmd.items,
    )?;
    
    // 2. ä¿å­˜äº‹ä»¶
    service.event_store.save_events(
        order.id,
        order.uncommitted_events(),
        0,  // æ–°è®¢å•ç‰ˆæœ¬ä¸º 0
    ).await?;
    
    Ok(Json(CreateOrderResponse {
        order_id: order.id,
    }))
}

async fn pay_order(
    State(service): State<Arc<CommandService>>,
    Path(order_id): Path<Uuid>,
    Json(cmd): Json<PayOrderRequest>,
) -> Result<StatusCode, AppError> {
    // 1. ä»äº‹ä»¶æµé‡å»ºèšåˆæ ¹
    let events = service.event_store.load_events(order_id).await?;
    let mut order = Order::from_events(events)?;
    let version = order.version;
    
    // 2. æ‰§è¡Œå‘½ä»¤
    order.pay(cmd.payment_id, cmd.amount)?;
    
    // 3. ä¿å­˜äº‹ä»¶
    service.event_store.save_events(
        order_id,
        order.uncommitted_events(),
        version,
    ).await?;
    
    Ok(StatusCode::OK)
}

// ... å…¶ä»–å‘½ä»¤å¤„ç†å™¨ç±»ä¼¼

#[derive(Debug, Serialize, Deserialize)]
struct CreateOrderRequest {
    user_id: Uuid,
    items: Vec<OrderItem>,
}

#[derive(Debug, Serialize, Deserialize)]
struct CreateOrderResponse {
    order_id: Uuid,
}

#[derive(Debug, Serialize, Deserialize)]
struct PayOrderRequest {
    payment_id: String,
    amount: f64,
}
```

#### 3.3 æŸ¥è¯¢æœåŠ¡ï¼ˆRead Sideï¼‰

```rust
// è¯»æ¨¡å‹ï¼ˆæŠ•å½±ï¼‰
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct OrderReadModel {
    pub id: Uuid,
    pub user_id: Uuid,
    pub total: f64,
    pub status: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

pub struct QueryService {
    pool: PgPool,
}

impl QueryService {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    pub fn routes(self: Arc<Self>) -> Router {
        Router::new()
            .route("/orders/:id", get(get_order))
            .route("/users/:user_id/orders", get(list_user_orders))
            .with_state(self)
    }
}

async fn get_order(
    State(service): State<Arc<QueryService>>,
    Path(order_id): Path<Uuid>,
) -> Result<Json<OrderReadModel>, AppError> {
    let order = sqlx::query_as!(
        OrderReadModel,
        "SELECT * FROM orders_read_model WHERE id = $1",
        order_id
    )
    .fetch_one(&service.pool)
    .await?;
    
    Ok(Json(order))
}

async fn list_user_orders(
    State(service): State<Arc<QueryService>>,
    Path(user_id): Path<Uuid>,
) -> Result<Json<Vec<OrderReadModel>>, AppError> {
    let orders = sqlx::query_as!(
        OrderReadModel,
        "SELECT * FROM orders_read_model WHERE user_id = $1 ORDER BY created_at DESC",
        user_id
    )
    .fetch_all(&service.pool)
    .await?;
    
    Ok(Json(orders))
}

// äº‹ä»¶å¤„ç†å™¨ï¼ˆæ›´æ–°è¯»æ¨¡å‹ï¼‰
pub struct ReadModelProjection {
    pool: PgPool,
}

impl ReadModelProjection {
    pub async fn handle_event(&self, event: &OrderEvent) -> Result<(), Error> {
        match event {
            OrderEvent::OrderCreated {
                order_id,
                user_id,
                items,
                total,
                created_at,
            } => {
                sqlx::query(
                    r#"
                    INSERT INTO orders_read_model 
                    (id, user_id, total, status, created_at, updated_at)
                    VALUES ($1, $2, $3, 'pending', $4, $4)
                    "#
                )
                .bind(order_id)
                .bind(user_id)
                .bind(total)
                .bind(created_at)
                .execute(&self.pool)
                .await?;
            }
            OrderEvent::OrderPaid { order_id, paid_at, .. } => {
                sqlx::query(
                    r#"
                    UPDATE orders_read_model 
                    SET status = 'paid', updated_at = $2
                    WHERE id = $1
                    "#
                )
                .bind(order_id)
                .bind(paid_at)
                .execute(&self.pool)
                .await?;
            }
            // ... å¤„ç†å…¶ä»–äº‹ä»¶
            _ => {}
        }
        
        Ok(())
    }
}
```

---

### 1.4 æ€§èƒ½ä¼˜åŒ–

#### å¿«ç…§ï¼ˆSnapshotï¼‰

**é—®é¢˜**: äº‹ä»¶æµè¿‡é•¿ï¼Œé‡å»ºèšåˆæ ¹è€—æ—¶

**è§£å†³æ–¹æ¡ˆ**: å®šæœŸåˆ›å»ºå¿«ç…§

```rust
pub struct SnapshotStore {
    pool: PgPool,
}

impl SnapshotStore {
    // ä¿å­˜å¿«ç…§ï¼ˆæ¯ 100 ä¸ªäº‹ä»¶ï¼‰
    pub async fn save_snapshot(
        &self,
        aggregate_id: Uuid,
        version: u64,
        snapshot_data: &Order,
    ) -> Result<(), Error> {
        let data = serde_json::to_value(snapshot_data)?;
        
        sqlx::query(
            r#"
            INSERT INTO snapshots (aggregate_id, version, snapshot_data, created_at)
            VALUES ($1, $2, $3, NOW())
            ON CONFLICT (aggregate_id) 
            DO UPDATE SET version = $2, snapshot_data = $3, created_at = NOW()
            "#
        )
        .bind(aggregate_id)
        .bind(version as i64)
        .bind(data)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    // åŠ è½½å¿«ç…§
    pub async fn load_snapshot(&self, aggregate_id: Uuid) -> Result<Option<(Order, u64)>, Error> {
        let row = sqlx::query(
            "SELECT snapshot_data, version FROM snapshots WHERE aggregate_id = $1"
        )
        .bind(aggregate_id)
        .fetch_optional(&self.pool)
        .await?;
        
        match row {
            Some(row) => {
                let data: serde_json::Value = row.get("snapshot_data");
                let version: i64 = row.get("version");
                let order: Order = serde_json::from_value(data)?;
                Ok(Some((order, version as u64)))
            }
            None => Ok(None),
        }
    }
}

// ä¼˜åŒ–çš„äº‹ä»¶åŠ è½½
impl EventStore {
    pub async fn load_aggregate(&self, aggregate_id: Uuid) -> Result<Order, Error> {
        // 1. å°è¯•åŠ è½½å¿«ç…§
        let (mut order, version) = match self.snapshot_store.load_snapshot(aggregate_id).await? {
            Some((order, version)) => (order, version),
            None => {
                // æ²¡æœ‰å¿«ç…§ï¼Œä»ç¬¬ä¸€ä¸ªäº‹ä»¶å¼€å§‹
                let events = self.load_events(aggregate_id).await?;
                return Order::from_events(events);
            }
        };
        
        // 2. åŠ è½½å¿«ç…§åçš„äº‹ä»¶
        let events = self.load_events_after_version(aggregate_id, version).await?;
        
        // 3. åº”ç”¨åç»­äº‹ä»¶
        for event in events {
            order.apply_event(event)?;
        }
        
        Ok(order)
    }
}

// æ•ˆæœï¼š
// - æ— å¿«ç…§ï¼šåŠ è½½ 1000 ä¸ªäº‹ä»¶éœ€è¦ 50ms
// - æœ‰å¿«ç…§ï¼šåŠ è½½æœ€è¿‘ 100 ä¸ªäº‹ä»¶éœ€è¦ 5ms (æå‡ 10x)
```

---

## 2. åˆ†å¸ƒå¼é™æµç³»ç»Ÿ

### 2.1 æ»‘åŠ¨çª—å£é™æµå™¨

**å®ç°åŸºäº Redis çš„æ»‘åŠ¨çª—å£é™æµ**:

```rust
use redis::{AsyncCommands, Client};
use std::time::{SystemTime, UNIX_EPOCH};

pub struct SlidingWindowRateLimiter {
    redis: Client,
    max_requests: u32,
    window_secs: u64,
}

impl SlidingWindowRateLimiter {
    pub fn new(redis_url: &str, max_requests: u32, window_secs: u64) -> Result<Self, redis::RedisError> {
        let redis = Client::open(redis_url)?;
        Ok(Self {
            redis,
            max_requests,
            window_secs,
        })
    }
    
    pub async fn allow(&self, key: &str) -> Result<bool, redis::RedisError> {
        let mut conn = self.redis.get_multiplexed_async_connection().await?;
        
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
        
        let window_start = now - (self.window_secs * 1000);
        
        let redis_key = format!("rate_limit:{}", key);
        
        // Lua è„šæœ¬å®ç°åŸå­æ“ä½œ
        let lua_script = r#"
            local key = KEYS[1]
            local now = tonumber(ARGV[1])
            local window_start = tonumber(ARGV[2])
            local max_requests = tonumber(ARGV[3])
            
            -- åˆ é™¤çª—å£å¤–çš„è®°å½•
            redis.call('ZREMRANGEBYSCORE', key, 0, window_start)
            
            -- è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
            local current = redis.call('ZCARD', key)
            
            if current < max_requests then
                -- å…è®¸è¯·æ±‚ï¼Œæ·»åŠ è®°å½•
                redis.call('ZADD', key, now, now)
                redis.call('EXPIRE', key, 60)  -- è®¾ç½® key è¿‡æœŸæ—¶é—´
                return 1
            else
                -- æ‹’ç»è¯·æ±‚
                return 0
            end
        "#;
        
        let result: i32 = redis::Script::new(lua_script)
            .key(&redis_key)
            .arg(now)
            .arg(window_start)
            .arg(self.max_requests)
            .invoke_async(&mut conn)
            .await?;
        
        Ok(result == 1)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[axum::async_trait]
impl<S> FromRequestParts<S> for RateLimited
where
    S: Send + Sync,
{
    type Rejection = StatusCode;
    
    async fn from_request_parts(
        parts: &mut Parts,
        state: &S,
    ) -> Result<Self, Self::Rejection> {
        let limiter = parts.extensions.get::<Arc<SlidingWindowRateLimiter>>()
            .ok_or(StatusCode::INTERNAL_SERVER_ERROR)?;
        
        let client_ip = get_client_ip(parts);
        
        if limiter.allow(&client_ip).await.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
            Ok(Self)
        } else {
            Err(StatusCode::TOO_MANY_REQUESTS)
        }
    }
}

async fn protected_handler(_: RateLimited) -> &'static str {
    "Success"
}
```

### 2.2 ä»¤ç‰Œæ¡¶é™æµå™¨

```rust
use std::sync::Arc;
use tokio::sync::Mutex;
use std::time::{Duration, Instant};

pub struct TokenBucketRateLimiter {
    capacity: f64,
    tokens: Arc<Mutex<f64>>,
    refill_rate: f64,  // tokens per second
    last_refill: Arc<Mutex<Instant>>,
}

impl TokenBucketRateLimiter {
    pub fn new(capacity: f64, refill_rate: f64) -> Self {
        Self {
            capacity,
            tokens: Arc::new(Mutex::new(capacity)),
            refill_rate,
            last_refill: Arc::new(Mutex::new(Instant::now())),
        }
    }
    
    pub async fn allow(&self, tokens_needed: f64) -> bool {
        let mut tokens = self.tokens.lock().await;
        let mut last_refill = self.last_refill.lock().await;
        
        // è¡¥å……ä»¤ç‰Œ
        let now = Instant::now();
        let elapsed = now.duration_since(*last_refill).as_secs_f64();
        let tokens_to_add = elapsed * self.refill_rate;
        
        *tokens = (*tokens + tokens_to_add).min(self.capacity);
        *last_refill = now;
        
        // æ¶ˆè´¹ä»¤ç‰Œ
        if *tokens >= tokens_needed {
            *tokens -= tokens_needed;
            true
        } else {
            false
        }
    }
}
```

---

## 3. æœåŠ¡é™çº§ä¸ç†”æ–­å™¨å®æˆ˜

### 3.1 å®Œæ•´çš„ç†”æ–­å™¨å®ç°

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{Duration, Instant};

#[derive(Debug, Clone, PartialEq)]
pub enum CircuitState {
    Closed,       // æ­£å¸¸çŠ¶æ€
    Open,         // ç†”æ–­çŠ¶æ€
    HalfOpen,     // åŠå¼€çŠ¶æ€ï¼ˆæµ‹è¯•æ¢å¤ï¼‰
}

pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitState>>,
    failure_threshold: u32,
    success_threshold: u32,
    timeout: Duration,
    
    failure_count: Arc<RwLock<u32>>,
    success_count: Arc<RwLock<u32>>,
    last_failure_time: Arc<RwLock<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(
        failure_threshold: u32,
        success_threshold: u32,
        timeout: Duration,
    ) -> Self {
        Self {
            state: Arc::new(RwLock::new(CircuitState::Closed)),
            failure_threshold,
            success_threshold,
            timeout,
            failure_count: Arc::new(RwLock::new(0)),
            success_count: Arc::new(RwLock::new(0)),
            last_failure_time: Arc::new(RwLock::new(None)),
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = Result<T, E>>,
    {
        // æ£€æŸ¥å½“å‰çŠ¶æ€
        let state = self.state.read().await.clone();
        
        match state {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥è½¬æ¢åˆ° HalfOpen
                if let Some(last_failure) = *self.last_failure_time.read().await {
                    if last_failure.elapsed() > self.timeout {
                        *self.state.write().await = CircuitState::HalfOpen;
                        *self.success_count.write().await = 0;
                    } else {
                        return Err(CircuitBreakerError::Open);
                    }
                }
            }
            CircuitState::HalfOpen => {
                // åŠå¼€çŠ¶æ€ï¼Œå°è¯•è°ƒç”¨
            }
            CircuitState::Closed => {
                // æ­£å¸¸çŠ¶æ€
            }
        }
        
        // æ‰§è¡Œè°ƒç”¨
        match f().await {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(CircuitBreakerError::InnerError(e))
            }
        }
    }
    
    async fn on_success(&self) {
        let state = self.state.read().await.clone();
        
        match state {
            CircuitState::HalfOpen => {
                let mut success_count = self.success_count.write().await;
                *success_count += 1;
                
                if *success_count >= self.success_threshold {
                    *self.state.write().await = CircuitState::Closed;
                    *self.failure_count.write().await = 0;
                    tracing::info!("Circuit breaker closed");
                }
            }
            CircuitState::Closed => {
                *self.failure_count.write().await = 0;
            }
            _ => {}
        }
    }
    
    async fn on_failure(&self) {
        let mut failure_count = self.failure_count.write().await;
        *failure_count += 1;
        
        if *failure_count >= self.failure_threshold {
            *self.state.write().await = CircuitState::Open;
            *self.last_failure_time.write().await = Some(Instant::now());
            tracing::warn!("Circuit breaker opened");
        }
    }
}

#[derive(Debug)]
pub enum CircuitBreakerError<E> {
    Open,
    InnerError(E),
}

// ä½¿ç”¨ç¤ºä¾‹
async fn call_external_service_with_circuit_breaker(
    circuit_breaker: &CircuitBreaker,
    client: &reqwest::Client,
    url: &str,
) -> Result<String, CircuitBreakerError<reqwest::Error>> {
    circuit_breaker.call(|| async {
        let response = client.get(url).send().await?;
        let body = response.text().await?;
        Ok(body)
    }).await
}
```

### 3.2 æœåŠ¡é™çº§ç­–ç•¥

```rust
pub struct FallbackService {
    primary: Arc<dyn Service>,
    fallback: Arc<dyn Service>,
    circuit_breaker: Arc<CircuitBreaker>,
}

#[async_trait]
trait Service: Send + Sync {
    async fn call(&self, request: Request) -> Result<Response, Error>;
}

impl FallbackService {
    pub async fn call(&self, request: Request) -> Result<Response, Error> {
        match self.circuit_breaker.call(|| self.primary.call(request.clone())).await {
            Ok(response) => Ok(response),
            Err(CircuitBreakerError::Open) => {
                tracing::warn!("Circuit breaker open, using fallback");
                self.fallback.call(request).await
            }
            Err(CircuitBreakerError::InnerError(e)) => {
                tracing::error!("Primary service error: {}, using fallback", e);
                self.fallback.call(request).await
            }
        }
    }
}
```

---

## å‚è€ƒèµ„æº

- [Event Sourcing Pattern](https://martinfowler.com/eaaDev/EventSourcing.html)
- [CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)

---

**æœ€åæ›´æ–°**: 2025-10-23  
**ä¸‹æ¬¡æ›´æ–°**: æŒ‰éœ€æ›´æ–°
