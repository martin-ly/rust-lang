# 3.5 Rust æ¶æ„è®¾è®¡æ¨¡å¼é›† (2025-10-21)

> **æ–‡æ¡£å®šä½**: Rust ç³»ç»Ÿæ¶æ„è®¾è®¡æƒå¨æŒ‡å—ï¼Œæ¨¡å¼åº“ä¸æœ€ä½³å®è·µ  
> **é€‚ç”¨äººç¾¤**: æ¶æ„å¸ˆã€æŠ€æœ¯è´Ÿè´£äººã€é«˜çº§å¼€å‘è€…  
> **å…³è”æ–‡æ¡£**: [3.3 æˆç†Ÿåº¦çŸ©é˜µ](3.3_åº“æˆç†Ÿåº¦è¯„ä¼°çŸ©é˜µ.md) | [3.4 æ€§èƒ½æŠ¥å‘Š](3.4_æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š.md) | [1.1 ä¸»ç´¢å¼•](../1.1_ä¸»ç´¢å¼•å¯¼èˆª.md)

**æœ€åæ›´æ–°**: 2025-10-21  
**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [3.5 Rust æ¶æ„è®¾è®¡æ¨¡å¼é›† (2025-10-21)](#35-rust-æ¶æ„è®¾è®¡æ¨¡å¼é›†-2025-10-21)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [3.5.1 å¾®æœåŠ¡æ¶æ„æ¨¡å¼](#351-å¾®æœåŠ¡æ¶æ„æ¨¡å¼)
    - [3.5.1.1 æœåŠ¡æ‹†åˆ†ç­–ç•¥](#3511-æœåŠ¡æ‹†åˆ†ç­–ç•¥)
    - [3.5.1.2 API Gateway æ¨¡å¼](#3512-api-gateway-æ¨¡å¼)
    - [3.5.1.3 æœåŠ¡å‘ç°ä¸æ³¨å†Œ](#3513-æœåŠ¡å‘ç°ä¸æ³¨å†Œ)
    - [3.5.1.4 æœåŠ¡é—´é€šä¿¡](#3514-æœåŠ¡é—´é€šä¿¡)
  - [3.5.2 æ•°æ®æ¶æ„æ¨¡å¼](#352-æ•°æ®æ¶æ„æ¨¡å¼)
    - [3.5.2.1 CQRS (å‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»)](#3521-cqrs-å‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»)
    - [3.5.2.2 Event Sourcing (äº‹ä»¶æº¯æº)](#3522-event-sourcing-äº‹ä»¶æº¯æº)
    - [3.5.2.3 Saga åˆ†å¸ƒå¼äº‹åŠ¡](#3523-saga-åˆ†å¸ƒå¼äº‹åŠ¡)
    - [3.5.2.4 è¯»å†™åˆ†ç¦»](#3524-è¯»å†™åˆ†ç¦»)
  - [3.5.3 å¹¶å‘æ¶æ„æ¨¡å¼](#353-å¹¶å‘æ¶æ„æ¨¡å¼)
    - [3.5.3.1 Actor æ¨¡å‹](#3531-actor-æ¨¡å‹)
    - [3.5.3.2 Pipeline æ¨¡å¼](#3532-pipeline-æ¨¡å¼)
    - [3.5.3.3 Work Stealing æ¨¡å¼](#3533-work-stealing-æ¨¡å¼)
    - [3.5.3.4 Lock-Free æ•°æ®ç»“æ„](#3534-lock-free-æ•°æ®ç»“æ„)
  - [3.5.4 å¯é æ€§æ¨¡å¼](#354-å¯é æ€§æ¨¡å¼)
    - [3.5.4.1 ç†”æ–­å™¨æ¨¡å¼](#3541-ç†”æ–­å™¨æ¨¡å¼)
    - [3.5.4.2 é‡è¯•ä¸è¶…æ—¶](#3542-é‡è¯•ä¸è¶…æ—¶)
    - [3.5.4.3 é™æµæ¨¡å¼](#3543-é™æµæ¨¡å¼)
    - [3.5.4.4 é™çº§ä¸å®¹é”™](#3544-é™çº§ä¸å®¹é”™)
  - [3.5.5 å¯è§‚æµ‹æ€§æ¨¡å¼](#355-å¯è§‚æµ‹æ€§æ¨¡å¼)
    - [3.5.5.1 åˆ†å¸ƒå¼è¿½è¸ª](#3551-åˆ†å¸ƒå¼è¿½è¸ª)
    - [3.5.5.2 æŒ‡æ ‡æ”¶é›†](#3552-æŒ‡æ ‡æ”¶é›†)
    - [3.5.5.3 ç»“æ„åŒ–æ—¥å¿—](#3553-ç»“æ„åŒ–æ—¥å¿—)
    - [3.5.5.4 å¥åº·æ£€æŸ¥](#3554-å¥åº·æ£€æŸ¥)
  - [3.5.6 ç¼“å­˜æ¶æ„æ¨¡å¼](#356-ç¼“å­˜æ¶æ„æ¨¡å¼)
    - [3.5.6.1 Cache-Aside æ¨¡å¼](#3561-cache-aside-æ¨¡å¼)
    - [3.5.6.2 Read-Through / Write-Through](#3562-read-through--write-through)
    - [3.5.6.3 å¤šçº§ç¼“å­˜](#3563-å¤šçº§ç¼“å­˜)
    - [3.5.6.4 ç¼“å­˜ä¸€è‡´æ€§](#3564-ç¼“å­˜ä¸€è‡´æ€§)
  - [3.5.7 æ¶ˆæ¯é©±åŠ¨æ¶æ„](#357-æ¶ˆæ¯é©±åŠ¨æ¶æ„)
    - [3.5.7.1 å‘å¸ƒ-è®¢é˜…æ¨¡å¼](#3571-å‘å¸ƒ-è®¢é˜…æ¨¡å¼)
    - [3.5.7.2 äº‹ä»¶é©±åŠ¨æ¶æ„](#3572-äº‹ä»¶é©±åŠ¨æ¶æ„)
  - [3.5.10 åæ¨¡å¼ä¸é™·é˜±](#3510-åæ¨¡å¼ä¸é™·é˜±)
  - [3.5.11 å‚è€ƒèµ„æº](#3511-å‚è€ƒèµ„æº)

---

## 3.5.1 å¾®æœåŠ¡æ¶æ„æ¨¡å¼

### 3.5.1.1 æœåŠ¡æ‹†åˆ†ç­–ç•¥

**æŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†** (æ¨è):

```text
ç”µå•†ç³»ç»Ÿç¤ºä¾‹:
â”œâ”€â”€ ç”¨æˆ·æœåŠ¡ (User Service)
â”‚   â”œâ”€â”€ ç”¨æˆ·æ³¨å†Œ/ç™»å½•
â”‚   â”œâ”€â”€ ç”¨æˆ·ä¿¡æ¯ç®¡ç†
â”‚   â””â”€â”€ ç”¨æˆ·åå¥½è®¾ç½®
â”‚
â”œâ”€â”€ å•†å“æœåŠ¡ (Product Service)
â”‚   â”œâ”€â”€ å•†å“ç›®å½•ç®¡ç†
â”‚   â”œâ”€â”€ å•†å“æœç´¢
â”‚   â””â”€â”€ åº“å­˜ç®¡ç†
â”‚
â”œâ”€â”€ è®¢å•æœåŠ¡ (Order Service)
â”‚   â”œâ”€â”€ è®¢å•åˆ›å»º
â”‚   â”œâ”€â”€ è®¢å•çŠ¶æ€ç®¡ç†
â”‚   â””â”€â”€ è®¢å•æŸ¥è¯¢
â”‚
â””â”€â”€ æ”¯ä»˜æœåŠ¡ (Payment Service)
    â”œâ”€â”€ æ”¯ä»˜å¤„ç†
    â”œâ”€â”€ é€€æ¬¾ç®¡ç†
    â””â”€â”€ è´¦å•ç”Ÿæˆ
```

**æ‹†åˆ†åŸåˆ™**:

1. âœ… **å•ä¸€èŒè´£**: æ¯ä¸ªæœåŠ¡ä¸“æ³¨äºä¸€ä¸ªä¸šåŠ¡é¢†åŸŸ
2. âœ… **é«˜å†…èš**: ç›¸å…³åŠŸèƒ½åœ¨åŒä¸€æœåŠ¡å†…
3. âœ… **ä½è€¦åˆ**: æœåŠ¡é—´é€šè¿‡ API é€šä¿¡
4. âœ… **ç‹¬ç«‹éƒ¨ç½²**: æœåŠ¡å¯ç‹¬ç«‹å‘å¸ƒå’Œæ‰©å±•
5. âœ… **æ•°æ®è‡ªæ²»**: æ¯ä¸ªæœåŠ¡æ‹¥æœ‰è‡ªå·±çš„æ•°æ®åº“

**Rust å®ç°ç¤ºä¾‹**:

```rust
// ç”¨æˆ·æœåŠ¡ (ç‹¬ç«‹ crate)
// crates/user-service/src/lib.rs

use axum::{Router, routing::{get, post}};
use sqlx::PgPool;

pub struct UserService {
    db: PgPool,
}

impl UserService {
    pub fn new(db: PgPool) -> Self {
        Self { db }
    }
    
    pub fn routes(&self) -> Router {
        Router::new()
            .route("/users", post(create_user))
            .route("/users/:id", get(get_user))
            .with_state(self.db.clone())
    }
}

async fn create_user(/* ... */) -> Result<Json<User>, Error> {
    // ç”¨æˆ·åˆ›å»ºé€»è¾‘
}

async fn get_user(/* ... */) -> Result<Json<User>, Error> {
    // ç”¨æˆ·æŸ¥è¯¢é€»è¾‘
}
```

### 3.5.1.2 API Gateway æ¨¡å¼

**æ¶æ„è®¾è®¡**:

```text
                    [Client]
                       |
                   [API Gateway]
                    /   |   \
                   /    |    \
          [User      [Order   [Product
          Service]   Service] Service]
             |          |         |
          [User DB] [Order DB] [Product DB]
```

**API Gateway èŒè´£**:

1. âœ… **è·¯ç”±è½¬å‘**: å°†è¯·æ±‚è·¯ç”±åˆ°å¯¹åº”çš„åç«¯æœåŠ¡
2. âœ… **è®¤è¯æˆæƒ**: ç»Ÿä¸€çš„èº«ä»½éªŒè¯å’Œæƒé™æ§åˆ¶
3. âœ… **é™æµç†”æ–­**: ä¿æŠ¤åç«¯æœåŠ¡ä¸è¢«è¿‡è½½
4. âœ… **è¯·æ±‚èšåˆ**: å°†å¤šä¸ªåç«¯è°ƒç”¨èšåˆæˆä¸€ä¸ªå“åº”
5. âœ… **åè®®è½¬æ¢**: HTTP/REST â†’ gRPC
6. âœ… **ç›‘æ§æ—¥å¿—**: ç»Ÿä¸€çš„å¯è§‚æµ‹æ€§

**Rust å®ç° (Axum + Tower)**:

```rust
use axum::{Router, middleware, Extension};
use tower::{ServiceBuilder, ServiceExt};
use tower_http::{
    trace::TraceLayer,
    limit::RequestBodyLimitLayer,
};

#[tokio::main]
async fn main() {
    let app = Router::new()
        // ç”¨æˆ·æœåŠ¡è·¯ç”±
        .nest("/api/users", user_routes())
        // è®¢å•æœåŠ¡è·¯ç”±
        .nest("/api/orders", order_routes())
        // å•†å“æœåŠ¡è·¯ç”±
        .nest("/api/products", product_routes())
        // ä¸­é—´ä»¶
        .layer(
            ServiceBuilder::new()
                // è¿½è¸ª
                .layer(TraceLayer::new_for_http())
                // é™æµ
                .layer(RequestBodyLimitLayer::new(1024 * 1024)) // 1MB
                // è®¤è¯
                .layer(middleware::from_fn(auth_middleware))
                // é™æµå™¨
                .layer(middleware::from_fn(rate_limit_middleware))
        );
    
    let addr = "0.0.0.0:3000".parse().unwrap();
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

// è®¤è¯ä¸­é—´ä»¶
async fn auth_middleware(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let token = req.headers()
        .get("Authorization")
        .and_then(|v| v.to_str().ok());
    
    if let Some(token) = token {
        if verify_token(token).await? {
            return Ok(next.run(req).await);
        }
    }
    
    Err(StatusCode::UNAUTHORIZED)
}

// é™æµä¸­é—´ä»¶
async fn rate_limit_middleware(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let client_ip = get_client_ip(&req);
    
    if check_rate_limit(client_ip).await {
        Ok(next.run(req).await)
    } else {
        Err(StatusCode::TOO_MANY_REQUESTS)
    }
}
```

### 3.5.1.3 æœåŠ¡å‘ç°ä¸æ³¨å†Œ

**æœåŠ¡æ³¨å†Œæµç¨‹**:

```text
1. æœåŠ¡å¯åŠ¨ â†’ 2. æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒ â†’ 3. å®šæœŸå‘é€å¿ƒè·³
                    â†“
            4. å®¢æˆ·ç«¯æŸ¥è¯¢ â†’ 5. è·å–æœåŠ¡åˆ—è¡¨ â†’ 6. è´Ÿè½½å‡è¡¡è°ƒç”¨
```

**Consul é›†æˆç¤ºä¾‹**:

```rust
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Serialize, Deserialize)]
struct ServiceRegistration {
    id: String,
    name: String,
    address: String,
    port: u16,
    check: HealthCheck,
}

#[derive(Serialize, Deserialize)]
struct HealthCheck {
    http: String,
    interval: String,
    timeout: String,
}

pub struct ConsulClient {
    client: Client,
    consul_addr: String,
}

impl ConsulClient {
    pub fn new(consul_addr: String) -> Self {
        Self {
            client: Client::new(),
            consul_addr,
        }
    }
    
    // æ³¨å†ŒæœåŠ¡
    pub async fn register_service(
        &self,
        service_name: &str,
        service_addr: &str,
        service_port: u16,
    ) -> Result<(), Error> {
        let registration = ServiceRegistration {
            id: format!("{}-{}", service_name, uuid::Uuid::new_v4()),
            name: service_name.to_string(),
            address: service_addr.to_string(),
            port: service_port,
            check: HealthCheck {
                http: format!("http://{}:{}/health", service_addr, service_port),
                interval: "10s".to_string(),
                timeout: "5s".to_string(),
            },
        };
        
        self.client
            .put(&format!("{}/v1/agent/service/register", self.consul_addr))
            .json(&registration)
            .send()
            .await?;
        
        Ok(())
    }
    
    // å‘ç°æœåŠ¡
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<Service>, Error> {
        let response = self.client
            .get(&format!("{}/v1/health/service/{}", self.consul_addr, service_name))
            .query(&[("passing", "true")])
            .send()
            .await?;
        
        let services: Vec<Service> = response.json().await?;
        Ok(services)
    }
    
    // æ³¨é”€æœåŠ¡
    pub async fn deregister_service(&self, service_id: &str) -> Result<(), Error> {
        self.client
            .put(&format!("{}/v1/agent/service/deregister/{}", self.consul_addr, service_id))
            .send()
            .await?;
        
        Ok(())
    }
}
```

### 3.5.1.4 æœåŠ¡é—´é€šä¿¡

**é€šä¿¡æ–¹å¼å¯¹æ¯”**:

| æ–¹å¼ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ | Rust åº“ |
|------|------|---------|---------|
| **RESTful API** | ç®€å•ã€é€šç”¨ | å¤–éƒ¨ APIã€è½»é‡è°ƒç”¨ | `axum`, `reqwest` |
| **gRPC** | é«˜æ€§èƒ½ã€ç±»å‹å®‰å…¨ | å†…éƒ¨æœåŠ¡ã€é«˜é¢‘è°ƒç”¨ | `tonic` |
| **æ¶ˆæ¯é˜Ÿåˆ—** | å¼‚æ­¥ã€è§£è€¦ | äº‹ä»¶é€šçŸ¥ã€æ‰¹å¤„ç† | `rdkafka`, `lapin` |
| **GraphQL** | çµæ´»æŸ¥è¯¢ | å¤æ‚æ•°æ®èšåˆ | `async-graphql` |

**gRPC æœåŠ¡é—´é€šä¿¡ç¤ºä¾‹**:

```protobuf
// proto/user.proto
syntax = "proto3";

package user;

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
}

message GetUserRequest {
    int64 user_id = 1;
}

message CreateUserRequest {
    string name = 1;
    string email = 2;
}

message User {
    int64 id = 1;
    string name = 2;
    string email = 3;
    string created_at = 4;
}
```

```rust
// æœåŠ¡ç«¯å®ç°
use tonic::{transport::Server, Request, Response, Status};
use user_proto::user_service_server::{UserService, UserServiceServer};
use user_proto::{GetUserRequest, CreateUserRequest, User};

pub struct UserServiceImpl {
    db: PgPool,
}

#[tonic::async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(
        &self,
        request: Request<GetUserRequest>,
    ) -> Result<Response<User>, Status> {
        let user_id = request.into_inner().user_id;
        
        let user = sqlx::query_as!(
            User,
            "SELECT id, name, email, created_at FROM users WHERE id = $1",
            user_id
        )
        .fetch_one(&self.db)
        .await
        .map_err(|e| Status::not_found(format!("User not found: {}", e)))?;
        
        Ok(Response::new(user))
    }
    
    async fn create_user(
        &self,
        request: Request<CreateUserRequest>,
    ) -> Result<Response<User>, Status> {
        let req = request.into_inner();
        
        let user = sqlx::query_as!(
            User,
            "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *",
            req.name,
            req.email
        )
        .fetch_one(&self.db)
        .await
        .map_err(|e| Status::internal(format!("Failed to create user: {}", e)))?;
        
        Ok(Response::new(user))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "[::1]:50051".parse()?;
    let service = UserServiceImpl { db: create_pool().await? };
    
    Server::builder()
        .add_service(UserServiceServer::new(service))
        .serve(addr)
        .await?;
    
    Ok(())
}
```

```rust
// å®¢æˆ·ç«¯è°ƒç”¨
use user_proto::user_service_client::UserServiceClient;
use user_proto::{GetUserRequest, CreateUserRequest};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = UserServiceClient::connect("http://[::1]:50051").await?;
    
    // è·å–ç”¨æˆ·
    let request = tonic::Request::new(GetUserRequest {
        user_id: 1,
    });
    
    let response = client.get_user(request).await?;
    println!("User: {:?}", response.into_inner());
    
    // åˆ›å»ºç”¨æˆ·
    let request = tonic::Request::new(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    });
    
    let response = client.create_user(request).await?;
    println!("Created user: {:?}", response.into_inner());
    
    Ok(())
}
```

---

## 3.5.2 æ•°æ®æ¶æ„æ¨¡å¼

### 3.5.2.1 CQRS (å‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»)

**æ¶æ„è®¾è®¡**:

```text
        [Client]
           |
    +------+------+
    |             |
[Command      [Query
  API]          API]
    |             |
[Command      [Query
  Model]        Model]
    |             |
[Write DB] â†’ [Read DB]
           (Sync)
```

**æ ¸å¿ƒæ¦‚å¿µ**:

- **Command (å‘½ä»¤)**: ä¿®æ”¹æ•°æ®çš„æ“ä½œ (Create, Update, Delete)
- **Query (æŸ¥è¯¢)**: åªè¯»æ“ä½œ (Read)
- **åˆ†ç¦»ä¼˜åŠ¿**: è¯»å†™åˆ†ç¦»ã€ç‹¬ç«‹æ‰©å±•ã€ä¸åŒæ•°æ®æ¨¡å‹ä¼˜åŒ–

**Rust å®ç°ç¤ºä¾‹**:

```rust
use axum::{Router, routing::{get, post}};
use sqlx::{PgPool, postgres::PgPoolOptions};
use serde::{Deserialize, Serialize};

// ========== Command Side ==========

#[derive(Deserialize)]
struct CreateOrderCommand {
    user_id: i64,
    product_id: i64,
    quantity: i32,
}

#[derive(Deserialize)]
struct UpdateOrderStatusCommand {
    order_id: i64,
    status: String,
}

// å‘½ä»¤å¤„ç†å™¨
struct CommandHandler {
    write_db: PgPool,  // å†™æ•°æ®åº“
    event_bus: EventBus,  // äº‹ä»¶æ€»çº¿
}

impl CommandHandler {
    async fn handle_create_order(
        &self,
        cmd: CreateOrderCommand,
    ) -> Result<i64, Error> {
        // 1. éªŒè¯å‘½ä»¤
        self.validate_order(&cmd).await?;
        
        // 2. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        let order_id = sqlx::query_scalar!(
            "INSERT INTO orders (user_id, product_id, quantity, status) 
             VALUES ($1, $2, $3, 'pending') RETURNING id",
            cmd.user_id,
            cmd.product_id,
            cmd.quantity
        )
        .fetch_one(&self.write_db)
        .await?;
        
        // 3. å‘å¸ƒäº‹ä»¶
        self.event_bus.publish(OrderCreatedEvent {
            order_id,
            user_id: cmd.user_id,
            product_id: cmd.product_id,
            quantity: cmd.quantity,
        }).await?;
        
        Ok(order_id)
    }
    
    async fn handle_update_order_status(
        &self,
        cmd: UpdateOrderStatusCommand,
    ) -> Result<(), Error> {
        sqlx::query!(
            "UPDATE orders SET status = $1 WHERE id = $2",
            cmd.status,
            cmd.order_id
        )
        .execute(&self.write_db)
        .await?;
        
        self.event_bus.publish(OrderStatusUpdatedEvent {
            order_id: cmd.order_id,
            status: cmd.status.clone(),
        }).await?;
        
        Ok(())
    }
}

// ========== Query Side ==========

#[derive(Serialize)]
struct OrderView {
    id: i64,
    user_name: String,
    product_name: String,
    quantity: i32,
    status: String,
    total_price: f64,
    created_at: String,
}

// æŸ¥è¯¢å¤„ç†å™¨
struct QueryHandler {
    read_db: PgPool,  // è¯»æ•°æ®åº“ (å¯èƒ½æ˜¯åªè¯»å‰¯æœ¬)
}

impl QueryHandler {
    async fn get_order_by_id(&self, order_id: i64) -> Result<OrderView, Error> {
        let order = sqlx::query_as!(
            OrderView,
            r#"
            SELECT 
                o.id,
                u.name as user_name,
                p.name as product_name,
                o.quantity,
                o.status,
                o.quantity * p.price as total_price,
                o.created_at::text
            FROM orders o
            JOIN users u ON o.user_id = u.id
            JOIN products p ON o.product_id = p.id
            WHERE o.id = $1
            "#,
            order_id
        )
        .fetch_one(&self.read_db)
        .await?;
        
        Ok(order)
    }
    
    async fn get_user_orders(&self, user_id: i64) -> Result<Vec<OrderView>, Error> {
        let orders = sqlx::query_as!(
            OrderView,
            r#"
            SELECT 
                o.id,
                u.name as user_name,
                p.name as product_name,
                o.quantity,
                o.status,
                o.quantity * p.price as total_price,
                o.created_at::text
            FROM orders o
            JOIN users u ON o.user_id = u.id
            JOIN products p ON o.product_id = p.id
            WHERE o.user_id = $1
            ORDER BY o.created_at DESC
            "#,
            user_id
        )
        .fetch_all(&self.read_db)
        .await?;
        
        Ok(orders)
    }
}

// ========== äº‹ä»¶åŒæ­¥ ==========

struct EventSyncWorker {
    event_bus: EventBus,
    read_db: PgPool,
}

impl EventSyncWorker {
    async fn start(&self) {
        loop {
            if let Some(event) = self.event_bus.consume().await {
                match event {
                    Event::OrderCreated(e) => self.sync_order_created(e).await,
                    Event::OrderStatusUpdated(e) => self.sync_order_status(e).await,
                    _ => {}
                }
            }
        }
    }
    
    async fn sync_order_created(&self, event: OrderCreatedEvent) {
        // æ›´æ–°è¯»æ•°æ®åº“çš„èšåˆè§†å›¾
        sqlx::query!(
            "INSERT INTO order_views (...) VALUES (...)"
        )
        .execute(&self.read_db)
        .await
        .ok();
    }
}
```

### 3.5.2.2 Event Sourcing (äº‹ä»¶æº¯æº)

**æ ¸å¿ƒæ€æƒ³**:

ä¸å­˜å‚¨å½“å‰çŠ¶æ€ï¼Œè€Œæ˜¯å­˜å‚¨æ‰€æœ‰çŠ¶æ€å˜æ›´äº‹ä»¶ï¼Œé€šè¿‡é‡æ”¾äº‹ä»¶é‡å»ºå½“å‰çŠ¶æ€ã€‚

**æ¶æ„è®¾è®¡**:

```text
[Command] â†’ [Aggregate] â†’ [Events] â†’ [Event Store]
                              â†“
                         [Projections]
                              â†“
                         [Read Models]
```

**Rust å®ç°ç¤ºä¾‹**:

```rust
use serde::{Deserialize, Serialize};
use sqlx::PgPool;

// ========== Events ==========

#[derive(Serialize, Deserialize, Clone)]
#[serde(tag = "type")]
enum OrderEvent {
    OrderCreated {
        order_id: String,
        user_id: i64,
        items: Vec<OrderItem>,
        total: f64,
        timestamp: i64,
    },
    ItemAdded {
        order_id: String,
        item: OrderItem,
        timestamp: i64,
    },
    OrderShipped {
        order_id: String,
        tracking_number: String,
        timestamp: i64,
    },
    OrderDelivered {
        order_id: String,
        timestamp: i64,
    },
    OrderCancelled {
        order_id: String,
        reason: String,
        timestamp: i64,
    },
}

// ========== Event Store ==========

pub struct EventStore {
    db: PgPool,
}

impl EventStore {
    // ä¿å­˜äº‹ä»¶
    pub async fn save_event(
        &self,
        aggregate_id: &str,
        event: &OrderEvent,
        version: i32,
    ) -> Result<(), Error> {
        let event_data = serde_json::to_value(event)?;
        
        sqlx::query!(
            r#"
            INSERT INTO event_store (aggregate_id, aggregate_type, version, event_type, event_data, created_at)
            VALUES ($1, 'Order', $2, $3, $4, NOW())
            "#,
            aggregate_id,
            version,
            event_type_name(event),
            event_data
        )
        .execute(&self.db)
        .await?;
        
        Ok(())
    }
    
    // åŠ è½½èšåˆçš„æ‰€æœ‰äº‹ä»¶
    pub async fn load_events(&self, aggregate_id: &str) -> Result<Vec<OrderEvent>, Error> {
        let rows = sqlx::query!(
            r#"
            SELECT event_data
            FROM event_store
            WHERE aggregate_id = $1
            ORDER BY version ASC
            "#,
            aggregate_id
        )
        .fetch_all(&self.db)
        .await?;
        
        let events = rows
            .into_iter()
            .map(|row| serde_json::from_value(row.event_data).unwrap())
            .collect();
        
        Ok(events)
    }
}

// ========== Aggregate ==========

#[derive(Default)]
pub struct OrderAggregate {
    id: String,
    user_id: i64,
    items: Vec<OrderItem>,
    status: OrderStatus,
    total: f64,
    version: i32,
    uncommitted_events: Vec<OrderEvent>,
}

impl OrderAggregate {
    // ä»äº‹ä»¶é‡å»ºèšåˆ
    pub fn rebuild_from_events(events: Vec<OrderEvent>) -> Self {
        let mut aggregate = Self::default();
        for event in events {
            aggregate.apply_event(&event);
            aggregate.version += 1;
        }
        aggregate
    }
    
    // åº”ç”¨äº‹ä»¶åˆ°èšåˆçŠ¶æ€
    fn apply_event(&mut self, event: &OrderEvent) {
        match event {
            OrderEvent::OrderCreated { order_id, user_id, items, total, .. } => {
                self.id = order_id.clone();
                self.user_id = *user_id;
                self.items = items.clone();
                self.total = *total;
                self.status = OrderStatus::Created;
            },
            OrderEvent::ItemAdded { item, .. } => {
                self.items.push(item.clone());
                self.total += item.price * item.quantity as f64;
            },
            OrderEvent::OrderShipped { .. } => {
                self.status = OrderStatus::Shipped;
            },
            OrderEvent::OrderDelivered { .. } => {
                self.status = OrderStatus::Delivered;
            },
            OrderEvent::OrderCancelled { .. } => {
                self.status = OrderStatus::Cancelled;
            },
        }
    }
    
    // ä¸šåŠ¡å‘½ä»¤
    pub fn ship_order(&mut self, tracking_number: String) -> Result<(), Error> {
        if self.status != OrderStatus::Created {
            return Err(Error::InvalidState("Order must be in Created state"));
        }
        
        let event = OrderEvent::OrderShipped {
            order_id: self.id.clone(),
            tracking_number,
            timestamp: current_timestamp(),
        };
        
        self.apply_event(&event);
        self.uncommitted_events.push(event);
        
        Ok(())
    }
    
    // è·å–æœªæäº¤çš„äº‹ä»¶
    pub fn uncommitted_events(&self) -> &[OrderEvent] {
        &self.uncommitted_events
    }
    
    // æ ‡è®°äº‹ä»¶å·²æäº¤
    pub fn mark_events_committed(&mut self) {
        self.uncommitted_events.clear();
    }
}

// ========== Command Handler with Event Sourcing ==========

pub struct OrderCommandHandler {
    event_store: EventStore,
}

impl OrderCommandHandler {
    pub async fn handle_ship_order(
        &self,
        order_id: &str,
        tracking_number: String,
    ) -> Result<(), Error> {
        // 1. ä»äº‹ä»¶å­˜å‚¨åŠ è½½èšåˆ
        let events = self.event_store.load_events(order_id).await?;
        let mut aggregate = OrderAggregate::rebuild_from_events(events);
        
        // 2. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        aggregate.ship_order(tracking_number)?;
        
        // 3. ä¿å­˜æ–°äº‹ä»¶
        for event in aggregate.uncommitted_events() {
            self.event_store
                .save_event(order_id, event, aggregate.version + 1)
                .await?;
        }
        
        aggregate.mark_events_committed();
        
        Ok(())
    }
}
```

**Event Sourcing ä¼˜åŠ¿**:

1. âœ… **å®Œæ•´å®¡è®¡æ—¥å¿—**: æ‰€æœ‰çŠ¶æ€å˜æ›´éƒ½æœ‰è®°å½•
2. âœ… **æ—¶é—´æ—…è¡Œ**: å¯ä»¥å›æº¯åˆ°ä»»æ„æ—¶é—´ç‚¹çš„çŠ¶æ€
3. âœ… **äº‹ä»¶é‡æ”¾**: ä¿®å¤ bug åå¯ä»¥é‡æ”¾äº‹ä»¶
4. âœ… **å¤šä¸ªè¯»æ¨¡å‹**: ä»åŒä¸€äº‹ä»¶æµæ„å»ºä¸åŒè§†å›¾

### 3.5.2.3 Saga åˆ†å¸ƒå¼äº‹åŠ¡

**ç¼–æ’å¼ Saga (Orchestration)**:

```text
[Saga Orchestrator]
         |
         +--â†’ [Order Service] â†’ Success
         +--â†’ [Payment Service] â†’ Success
         +--â†’ [Inventory Service] â†’ Failed
         +--â†’ [Compensation: Cancel Payment]
         +--â†’ [Compensation: Cancel Order]
```

**Rust å®ç°ç¤ºä¾‹**:

```rust
use async_trait::async_trait;
use thiserror::Error;

#[derive(Error, Debug)]
enum SagaError {
    #[error("Step failed: {0}")]
    StepFailed(String),
    #[error("Compensation failed: {0}")]
    CompensationFailed(String),
}

// ========== Saga Step Trait ==========

#[async_trait]
trait SagaStep: Send + Sync {
    async fn execute(&self) -> Result<(), SagaError>;
    async fn compensate(&self) -> Result<(), SagaError>;
}

// ========== Saga Orchestrator ==========

pub struct SagaOrchestrator {
    steps: Vec<Box<dyn SagaStep>>,
}

impl SagaOrchestrator {
    pub fn new() -> Self {
        Self { steps: Vec::new() }
    }
    
    pub fn add_step(&mut self, step: Box<dyn SagaStep>) {
        self.steps.push(step);
    }
    
    pub async fn execute(&self) -> Result<(), SagaError> {
        let mut completed_steps = Vec::new();
        
        // é¡ºåºæ‰§è¡Œæ‰€æœ‰æ­¥éª¤
        for step in &self.steps {
            match step.execute().await {
                Ok(_) => {
                    completed_steps.push(step);
                },
                Err(e) => {
                    // æ‰§è¡Œå¤±è´¥ï¼Œè¡¥å¿å·²å®Œæˆçš„æ­¥éª¤
                    self.compensate_steps(&completed_steps).await?;
                    return Err(e);
                }
            }
        }
        
        Ok(())
    }
    
    async fn compensate_steps(&self, steps: &[&Box<dyn SagaStep>]) -> Result<(), SagaError> {
        // é€†åºè¡¥å¿
        for step in steps.iter().rev() {
            step.compensate().await?;
        }
        Ok(())
    }
}

// ========== Concrete Steps ==========

struct CreateOrderStep {
    order_service: OrderServiceClient,
    order_id: String,
}

#[async_trait]
impl SagaStep for CreateOrderStep {
    async fn execute(&self) -> Result<(), SagaError> {
        self.order_service
            .create_order(&self.order_id)
            .await
            .map_err(|e| SagaError::StepFailed(format!("Create order failed: {}", e)))
    }
    
    async fn compensate(&self) -> Result<(), SagaError> {
        self.order_service
            .cancel_order(&self.order_id)
            .await
            .map_err(|e| SagaError::CompensationFailed(format!("Cancel order failed: {}", e)))
    }
}

struct ProcessPaymentStep {
    payment_service: PaymentServiceClient,
    payment_id: String,
}

#[async_trait]
impl SagaStep for ProcessPaymentStep {
    async fn execute(&self) -> Result<(), SagaError> {
        self.payment_service
            .process_payment(&self.payment_id)
            .await
            .map_err(|e| SagaError::StepFailed(format!("Payment failed: {}", e)))
    }
    
    async fn compensate(&self) -> Result<(), SagaError> {
        self.payment_service
            .refund_payment(&self.payment_id)
            .await
            .map_err(|e| SagaError::CompensationFailed(format!("Refund failed: {}", e)))
    }
}

struct ReserveInventoryStep {
    inventory_service: InventoryServiceClient,
    product_id: String,
    quantity: i32,
}

#[async_trait]
impl SagaStep for ReserveInventoryStep {
    async fn execute(&self) -> Result<(), SagaError> {
        self.inventory_service
            .reserve_inventory(&self.product_id, self.quantity)
            .await
            .map_err(|e| SagaError::StepFailed(format!("Reserve inventory failed: {}", e)))
    }
    
    async fn compensate(&self) -> Result<(), SagaError> {
        self.inventory_service
            .release_inventory(&self.product_id, self.quantity)
            .await
            .map_err(|e| SagaError::CompensationFailed(format!("Release inventory failed: {}", e)))
    }
}

// ========== Usage ==========

async fn create_order_saga(
    order_id: String,
    payment_id: String,
    product_id: String,
    quantity: i32,
) -> Result<(), SagaError> {
    let mut saga = SagaOrchestrator::new();
    
    // æ·»åŠ æ­¥éª¤
    saga.add_step(Box::new(CreateOrderStep {
        order_service: create_order_service_client(),
        order_id: order_id.clone(),
    }));
    
    saga.add_step(Box::new(ProcessPaymentStep {
        payment_service: create_payment_service_client(),
        payment_id,
    }));
    
    saga.add_step(Box::new(ReserveInventoryStep {
        inventory_service: create_inventory_service_client(),
        product_id,
        quantity,
    }));
    
    // æ‰§è¡Œ Saga
    saga.execute().await
}
```

### 3.5.2.4 è¯»å†™åˆ†ç¦»

**æ¶æ„è®¾è®¡**:

```text
[Client]
   |
   +--â†’ Write â†’ [Master DB]
   |                |
   |                â†“ (Replication)
   +--â†’ Read  â†’ [Read Replica 1]
                [Read Replica 2]
                [Read Replica 3]
```

**Rust å®ç° (SQLx)**:

```rust
use sqlx::{PgPool, postgres::PgPoolOptions};
use std::sync::Arc;

pub struct DatabasePool {
    master: PgPool,      // å†™åº“
    replicas: Vec<PgPool>,  // è¯»åº“
    current_replica: Arc<AtomicUsize>,
}

impl DatabasePool {
    pub async fn new(
        master_url: &str,
        replica_urls: Vec<String>,
    ) -> Result<Self, sqlx::Error> {
        let master = PgPoolOptions::new()
            .max_connections(100)
            .connect(master_url)
            .await?;
        
        let mut replicas = Vec::new();
        for url in replica_urls {
            let pool = PgPoolOptions::new()
                .max_connections(50)
                .connect(&url)
                .await?;
            replicas.push(pool);
        }
        
        Ok(Self {
            master,
            replicas,
            current_replica: Arc::new(AtomicUsize::new(0)),
        })
    }
    
    // è·å–å†™è¿æ¥
    pub fn master(&self) -> &PgPool {
        &self.master
    }
    
    // è·å–è¯»è¿æ¥ (è´Ÿè½½å‡è¡¡)
    pub fn replica(&self) -> &PgPool {
        if self.replicas.is_empty() {
            return &self.master;
        }
        
        let index = self.current_replica.fetch_add(1, Ordering::Relaxed);
        let index = index % self.replicas.len();
        &self.replicas[index]
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn user_service_example() -> Result<(), Error> {
    let db = DatabasePool::new(
        "postgresql://master:5432/db",
        vec![
            "postgresql://replica1:5432/db".to_string(),
            "postgresql://replica2:5432/db".to_string(),
        ],
    ).await?;
    
    // å†™æ“ä½œ - ä½¿ç”¨ master
    sqlx::query!(
        "INSERT INTO users (name, email) VALUES ($1, $2)",
        "Alice",
        "alice@example.com"
    )
    .execute(db.master())
    .await?;
    
    // è¯»æ“ä½œ - ä½¿ç”¨ replica (è‡ªåŠ¨è´Ÿè½½å‡è¡¡)
    let users = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE active = true"
    )
    .fetch_all(db.replica())
    .await?;
    
    Ok(())
}
```

---

## 3.5.3 å¹¶å‘æ¶æ„æ¨¡å¼

### 3.5.3.1 Actor æ¨¡å‹

**æ ¸å¿ƒæ¦‚å¿µ**:

- Actor: ç‹¬ç«‹çš„è®¡ç®—å•å…ƒï¼Œæ‹¥æœ‰è‡ªå·±çš„çŠ¶æ€
- æ¶ˆæ¯ä¼ é€’: Actor ä¹‹é—´é€šè¿‡å¼‚æ­¥æ¶ˆæ¯é€šä¿¡
- æ— å…±äº«çŠ¶æ€: é¿å…é”å’Œæ•°æ®ç«äº‰

**Rust å®ç° (Actix)**:

```rust
use actix::prelude::*;

// ========== Messages ==========

#[derive(Message)]
#[rtype(result = "Result<i64, ()>")]
struct CreateOrder {
    user_id: i64,
    product_id: i64,
    quantity: i32,
}

#[derive(Message)]
#[rtype(result = "Result<OrderStatus, ()>")]
struct GetOrderStatus {
    order_id: i64,
}

// ========== Actor ==========

struct OrderActor {
    db: PgPool,
}

impl Actor for OrderActor {
    type Context = Context<Self>;
}

impl Handler<CreateOrder> for OrderActor {
    type Result = ResponseFuture<Result<i64, ()>>;
    
    fn handle(&mut self, msg: CreateOrder, _ctx: &mut Self::Context) -> Self::Result {
        let db = self.db.clone();
        
        Box::pin(async move {
            let order_id = sqlx::query_scalar!(
                "INSERT INTO orders (user_id, product_id, quantity) VALUES ($1, $2, $3) RETURNING id",
                msg.user_id,
                msg.product_id,
                msg.quantity
            )
            .fetch_one(&db)
            .await
            .map_err(|_| ())?;
            
            Ok(order_id)
        })
    }
}

impl Handler<GetOrderStatus> for OrderActor {
    type Result = ResponseFuture<Result<OrderStatus, ()>>;
    
    fn handle(&mut self, msg: GetOrderStatus, _ctx: &mut Self::Context) -> Self::Result {
        let db = self.db.clone();
        
        Box::pin(async move {
            let status = sqlx::query_scalar!(
                "SELECT status FROM orders WHERE id = $1",
                msg.order_id
            )
            .fetch_one(&db)
            .await
            .map_err(|_| ())?;
            
            Ok(status)
        })
    }
}

// ========== Usage ==========

#[actix_web::main]
async fn main() {
    let db = create_database_pool().await;
    
    // å¯åŠ¨ Actor
    let order_actor = OrderActor { db }.start();
    
    // å‘é€æ¶ˆæ¯
    let order_id = order_actor
        .send(CreateOrder {
            user_id: 1,
            product_id: 100,
            quantity: 2,
        })
        .await
        .unwrap()
        .unwrap();
    
    println!("Created order: {}", order_id);
    
    let status = order_actor
        .send(GetOrderStatus { order_id })
        .await
        .unwrap()
        .unwrap();
    
    println!("Order status: {:?}", status);
}
```

### 3.5.3.2 Pipeline æ¨¡å¼

**æ¶æ„è®¾è®¡**:

```text
[Input] â†’ [Stage 1] â†’ [Stage 2] â†’ [Stage 3] â†’ [Output]
           â†“           â†“           â†“
        [Buffer]    [Buffer]    [Buffer]
```

**Rust å®ç° (Tokio)**:

```rust
use tokio::sync::mpsc;
use tokio::task;

// ========== Pipeline Stages ==========

async fn stage1_validate(
    mut input: mpsc::Receiver<String>,
    output: mpsc::Sender<String>,
) {
    while let Some(data) = input.recv().await {
        // éªŒè¯æ•°æ®
        if data.len() > 0 {
            output.send(data).await.ok();
        }
    }
}

async fn stage2_transform(
    mut input: mpsc::Receiver<String>,
    output: mpsc::Sender<String>,
) {
    while let Some(data) = input.recv().await {
        // è½¬æ¢æ•°æ®
        let transformed = data.to_uppercase();
        output.send(transformed).await.ok();
    }
}

async fn stage3_process(
    mut input: mpsc::Receiver<String>,
    output: mpsc::Sender<String>,
) {
    while let Some(data) = input.recv().await {
        // å¤„ç†æ•°æ®
        let processed = format!("Processed: {}", data);
        output.send(processed).await.ok();
    }
}

// ========== Pipeline Setup ==========

async fn run_pipeline() {
    let (tx1, rx1) = mpsc::channel(100);
    let (tx2, rx2) = mpsc::channel(100);
    let (tx3, rx3) = mpsc::channel(100);
    
    // å¯åŠ¨ pipeline stages
    task::spawn(stage1_validate(rx1, tx2));
    task::spawn(stage2_transform(rx2, tx3));
    task::spawn(stage3_process(rx3, /* final output */));
    
    // è¾“å…¥æ•°æ®
    for i in 0..1000 {
        tx1.send(format!("data-{}", i)).await.ok();
    }
}
```

### 3.5.3.3 Work Stealing æ¨¡å¼

**Tokio å†…ç½®å®ç°**:

Tokio è¿è¡Œæ—¶é»˜è®¤ä½¿ç”¨ work-stealing è°ƒåº¦å™¨ï¼Œæ— éœ€æ‰‹åŠ¨å®ç°ã€‚

**åŸç†**:

```text
Thread 1: [Task1, Task2, Task3]
Thread 2: [Task4, Task5]
Thread 3: []  â† ç©ºé—²ï¼Œä» Thread 1 å·å– Task3
```

**é…ç½®ç¤ºä¾‹**:

```rust
use tokio::runtime::Runtime;

fn main() {
    // åˆ›å»ºå¤šçº¿ç¨‹è¿è¡Œæ—¶ (work-stealing)
    let runtime = Runtime::new().unwrap();
    
    runtime.block_on(async {
        // ç”Ÿæˆå¤§é‡ä»»åŠ¡
        for i in 0..10_000 {
            tokio::spawn(async move {
                // æ¨¡æ‹Ÿå·¥ä½œ
                tokio::time::sleep(Duration::from_millis(10)).await;
                println!("Task {} completed", i);
            });
        }
    });
}
```

### 3.5.3.4 Lock-Free æ•°æ®ç»“æ„

**Crossbeam æ— é”é˜Ÿåˆ—**:

```rust
use crossbeam::queue::SegQueue;
use std::sync::Arc;
use std::thread;

fn lock_free_queue_example() {
    let queue = Arc::new(SegQueue::new());
    
    // ç”Ÿäº§è€…çº¿ç¨‹
    let queue_clone = queue.clone();
    thread::spawn(move || {
        for i in 0..1000 {
            queue_clone.push(i);
        }
    });
    
    // æ¶ˆè´¹è€…çº¿ç¨‹
    let queue_clone = queue.clone();
    thread::spawn(move || {
        loop {
            if let Some(item) = queue_clone.pop() {
                println!("Consumed: {}", item);
            }
        }
    });
}
```

---

## 3.5.4 å¯é æ€§æ¨¡å¼

### 3.5.4.1 ç†”æ–­å™¨æ¨¡å¼

**çŠ¶æ€æœº**:

```text
[Closed] --é”™è¯¯è¾¾åˆ°é˜ˆå€¼--> [Open] --è¶…æ—¶--> [Half-Open] --æˆåŠŸ--> [Closed]
   â†‘                          |                   |
   |                          +--å¤±è´¥--------------+
   +--æˆåŠŸ-----------------------+
```

**Rust å®ç°**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use tokio::time::{Duration, Instant};

#[derive(Clone)]
enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: Arc<AtomicU64>,
    success_count: Arc<AtomicU64>,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
    failure_threshold: u64,
    success_threshold: u64,
    timeout: Duration,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u64, timeout: Duration) -> Self {
        Self {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(AtomicU64::new(0)),
            success_count: Arc::new(AtomicU64::new(0)),
            last_failure_time: Arc::new(Mutex::new(None)),
            failure_threshold,
            success_threshold: 3,
            timeout,
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: FnOnce() -> Future<Output = Result<T, E>>,
    {
        // æ£€æŸ¥çŠ¶æ€
        let state = self.state.lock().await.clone();
        
        match state {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
                if let Some(last_time) = *self.last_failure_time.lock().await {
                    if Instant::now().duration_since(last_time) > self.timeout {
                        // è½¬æ¢åˆ° Half-Open
                        *self.state.lock().await = CircuitState::HalfOpen;
                    } else {
                        return Err(/* CircuitOpenError */);
                    }
                }
            }
            _ => {}
        }
        
        // æ‰§è¡Œè°ƒç”¨
        match f().await {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(e)
            }
        }
    }
    
    async fn on_success(&self) {
        let state = self.state.lock().await.clone();
        
        match state {
            CircuitState::HalfOpen => {
                let count = self.success_count.fetch_add(1, Ordering::Relaxed) + 1;
                if count >= self.success_threshold {
                    *self.state.lock().await = CircuitState::Closed;
                    self.reset_counters();
                }
            }
            CircuitState::Closed => {
                self.failure_count.store(0, Ordering::Relaxed);
            }
            _ => {}
        }
    }
    
    async fn on_failure(&self) {
        let count = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;
        
        if count >= self.failure_threshold {
            *self.state.lock().await = CircuitState::Open;
            *self.last_failure_time.lock().await = Some(Instant::now());
        }
    }
    
    fn reset_counters(&self) {
        self.failure_count.store(0, Ordering::Relaxed);
        self.success_count.store(0, Ordering::Relaxed);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn call_external_service_with_breaker() -> Result<String, Error> {
    let breaker = CircuitBreaker::new(5, Duration::from_secs(30));
    
    breaker.call(|| async {
        // è°ƒç”¨å¤–éƒ¨æœåŠ¡
        reqwest::get("https://api.example.com/data")
            .await?
            .text()
            .await
    }).await
}
```

### 3.5.4.2 é‡è¯•ä¸è¶…æ—¶

**æŒ‡æ•°é€€é¿é‡è¯•**:

```rust
use tokio::time::{sleep, Duration};

pub async fn retry_with_backoff<F, T, E>(
    mut f: F,
    max_retries: u32,
    initial_delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Future<Output = Result<T, E>>,
{
    let mut attempt = 0;
    let mut delay = initial_delay;
    
    loop {
        match f().await {
            Ok(result) => return Ok(result),
            Err(e) => {
                attempt += 1;
                if attempt >= max_retries {
                    return Err(e);
                }
                
                // æŒ‡æ•°é€€é¿
                sleep(delay).await;
                delay *= 2;
                
                // æ·»åŠ  jitter
                delay += Duration::from_millis(rand::random::<u64>() % 1000);
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn fetch_data_with_retry() -> Result<String, Error> {
    retry_with_backoff(
        || async {
            reqwest::get("https://api.example.com/data")
                .await?
                .text()
                .await
        },
        3,  // æœ€å¤šé‡è¯• 3 æ¬¡
        Duration::from_secs(1),  // åˆå§‹å»¶è¿Ÿ 1 ç§’
    ).await
}
```

**è¶…æ—¶æ§åˆ¶**:

```rust
use tokio::time::{timeout, Duration};

async fn call_with_timeout() -> Result<String, Error> {
    match timeout(
        Duration::from_secs(10),
        reqwest::get("https://api.example.com/data").await?.text()
    ).await {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(e)) => Err(e),
        Err(_) => Err(Error::Timeout),
    }
}
```

### 3.5.4.3 é™æµæ¨¡å¼

**ä»¤ç‰Œæ¡¶ç®—æ³•**:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;
use tokio::time::{interval, Duration};

pub struct RateLimiter {
    semaphore: Arc<Semaphore>,
    rate: u32,
}

impl RateLimiter {
    pub fn new(rate_per_second: u32) -> Self {
        let semaphore = Arc::new(Semaphore::new(rate_per_second as usize));
        
        // å®šæœŸè¡¥å……ä»¤ç‰Œ
        let sem_clone = semaphore.clone();
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(1));
            loop {
                interval.tick().await;
                sem_clone.add_permits(rate_per_second as usize);
            }
        });
        
        Self { semaphore, rate: rate_per_second }
    }
    
    pub async fn acquire(&self) -> Result<(), Error> {
        self.semaphore
            .acquire()
            .await
            .map(|_| ())
            .map_err(|_| Error::RateLimitExceeded)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn rate_limited_request(limiter: &RateLimiter) -> Result<(), Error> {
    limiter.acquire().await?;
    
    // æ‰§è¡Œè¯·æ±‚
    reqwest::get("https://api.example.com/data").await?;
    
    Ok(())
}
```

### 3.5.4.4 é™çº§ä¸å®¹é”™

**æœåŠ¡é™çº§ç¤ºä¾‹**:

```rust
pub async fn get_user_recommendations(
    user_id: i64,
    recommendation_service: &RecommendationService,
    db: &PgPool,
) -> Result<Vec<Product>, Error> {
    // å°è¯•è°ƒç”¨æ¨èæœåŠ¡
    match recommendation_service
        .get_recommendations(user_id)
        .await
    {
        Ok(products) => Ok(products),
        Err(e) => {
            // é™çº§: ä½¿ç”¨é»˜è®¤ç­–ç•¥
            tracing::warn!("Recommendation service failed, using fallback: {}", e);
            
            // è¿”å›çƒ­é—¨å•†å“
            let products = sqlx::query_as!(
                Product,
                "SELECT * FROM products ORDER BY sales_count DESC LIMIT 10"
            )
            .fetch_all(db)
            .await?;
            
            Ok(products)
        }
    }
}
```

---

## 3.5.5 å¯è§‚æµ‹æ€§æ¨¡å¼

### 3.5.5.1 åˆ†å¸ƒå¼è¿½è¸ª

**OpenTelemetry é›†æˆ**:

```rust
use opentelemetry::{global, trace::Tracer, KeyValue};
use opentelemetry_sdk::trace::{config, TracerProvider};
use tracing_subscriber::layer::SubscriberExt;

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ– OpenTelemetry
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_simple()
        .unwrap();
    
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    tracing_subscriber::registry()
        .with(telemetry)
        .with(tracing_subscriber::fmt::layer())
        .init();
    
    // ä½¿ç”¨è¿½è¸ª
    process_order(123).await;
}

#[tracing::instrument]
async fn process_order(order_id: i64) {
    tracing::info!("Processing order: {}", order_id);
    
    validate_order(order_id).await;
    charge_payment(order_id).await;
    ship_order(order_id).await;
}

#[tracing::instrument]
async fn validate_order(order_id: i64) {
    // éªŒè¯é€»è¾‘
    tracing::debug!("Order validated");
}
```

### 3.5.5.2 æŒ‡æ ‡æ”¶é›†

**Prometheus é›†æˆ**:

```rust
use prometheus::{Counter, Histogram, Registry, Encoder, TextEncoder};
use axum::{Router, routing::get};

// å®šä¹‰æŒ‡æ ‡
lazy_static! {
    static ref HTTP_REQUESTS_TOTAL: Counter = Counter::new(
        "http_requests_total",
        "Total HTTP requests"
    ).unwrap();
    
    static ref HTTP_REQUEST_DURATION: Histogram = Histogram::with_opts(
        HistogramOpts::new(
            "http_request_duration_seconds",
            "HTTP request duration"
        )
    ).unwrap();
}

#[tokio::main]
async fn main() {
    let registry = Registry::new();
    registry.register(Box::new(HTTP_REQUESTS_TOTAL.clone())).unwrap();
    registry.register(Box::new(HTTP_REQUEST_DURATION.clone())).unwrap();
    
    let app = Router::new()
        .route("/metrics", get(metrics_handler))
        .route("/api/users", get(users_handler).layer(middleware::from_fn(metrics_middleware)));
    
    // ...
}

async fn metrics_middleware(req: Request, next: Next) -> Response {
    HTTP_REQUESTS_TOTAL.inc();
    
    let timer = HTTP_REQUEST_DURATION.start_timer();
    let response = next.run(req).await;
    timer.observe_duration();
    
    response
}

async fn metrics_handler() -> String {
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = vec![];
    encoder.encode(&metric_families, &mut buffer).unwrap();
    String::from_utf8(buffer).unwrap()
}
```

### 3.5.5.3 ç»“æ„åŒ–æ—¥å¿—

**Tracing ç»“æ„åŒ–æ—¥å¿—**:

```rust
use tracing::{info, warn, error, debug};
use tracing_subscriber::{fmt, EnvFilter};

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .json()  // JSON æ ¼å¼è¾“å‡º
        .init();
    
    process_request().await;
}

async fn process_request() {
    info!(
        user_id = 123,
        request_id = "req-456",
        "Processing user request"
    );
    
    if let Err(e) = perform_action().await {
        error!(
            error = %e,
            user_id = 123,
            "Action failed"
        );
    }
}
```

### 3.5.5.4 å¥åº·æ£€æŸ¥

**å¥åº·æ£€æŸ¥ç«¯ç‚¹**:

```rust
use axum::{Router, routing::get, Json};
use serde::Serialize;

#[derive(Serialize)]
struct HealthStatus {
    status: String,
    database: String,
    redis: String,
}

async fn health_check(db: PgPool, redis: RedisPool) -> Json<HealthStatus> {
    let db_status = check_database(&db).await;
    let redis_status = check_redis(&redis).await;
    
    let overall_status = if db_status == "healthy" && redis_status == "healthy" {
        "healthy"
    } else {
        "unhealthy"
    };
    
    Json(HealthStatus {
        status: overall_status.to_string(),
        database: db_status,
        redis: redis_status,
    })
}

async fn check_database(db: &PgPool) -> String {
    match sqlx::query("SELECT 1").fetch_one(db).await {
        Ok(_) => "healthy".to_string(),
        Err(_) => "unhealthy".to_string(),
    }
}
```

---

## 3.5.6 ç¼“å­˜æ¶æ„æ¨¡å¼

### 3.5.6.1 Cache-Aside æ¨¡å¼

**æµç¨‹**:

```text
1. æŸ¥è¯¢ç¼“å­˜
2. ç¼“å­˜å‘½ä¸­ â†’ è¿”å›
3. ç¼“å­˜æœªå‘½ä¸­ â†’ æŸ¥è¯¢æ•°æ®åº“
4. å†™å…¥ç¼“å­˜
5. è¿”å›æ•°æ®
```

**Rust å®ç°**:

```rust
use redis::AsyncCommands;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: i64,
    name: String,
    email: String,
}

async fn get_user_cache_aside(
    user_id: i64,
    redis: &mut redis::aio::Connection,
    db: &PgPool,
) -> Result<User, Error> {
    let cache_key = format!("user:{}", user_id);
    
    // 1. æŸ¥è¯¢ç¼“å­˜
    if let Some(cached) = redis.get::<_, Option<String>>(&cache_key).await? {
        let user: User = serde_json::from_str(&cached)?;
        return Ok(user);
    }
    
    // 2. æŸ¥è¯¢æ•°æ®åº“
    let user = sqlx::query_as!(
        User,
        "SELECT id, name, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_one(db)
    .await?;
    
    // 3. å†™å…¥ç¼“å­˜
    let user_json = serde_json::to_string(&user)?;
    redis.set_ex(&cache_key, user_json, 3600).await?;  // TTL: 1å°æ—¶
    
    Ok(user)
}
```

### 3.5.6.2 Read-Through / Write-Through

**Read-Through**:

```rust
pub struct CacheableRepository {
    cache: Arc<dyn Cache>,
    db: PgPool,
}

impl CacheableRepository {
    async fn get_user(&self, user_id: i64) -> Result<User, Error> {
        // Cache automatically loads from DB if miss
        self.cache
            .get_or_load(
                format!("user:{}", user_id),
                || self.load_user_from_db(user_id)
            )
            .await
    }
    
    async fn load_user_from_db(&self, user_id: i64) -> Result<User, Error> {
        sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", user_id)
            .fetch_one(&self.db)
            .await
    }
}
```

**Write-Through**:

```rust
async fn update_user_write_through(
    user: &User,
    redis: &mut redis::aio::Connection,
    db: &PgPool,
) -> Result<(), Error> {
    // 1. å†™å…¥æ•°æ®åº“
    sqlx::query!(
        "UPDATE users SET name = $1, email = $2 WHERE id = $3",
        user.name,
        user.email,
        user.id
    )
    .execute(db)
    .await?;
    
    // 2. æ›´æ–°ç¼“å­˜
    let cache_key = format!("user:{}", user.id);
    let user_json = serde_json::to_string(user)?;
    redis.set_ex(&cache_key, user_json, 3600).await?;
    
    Ok(())
}
```

### 3.5.6.3 å¤šçº§ç¼“å­˜

**æ¶æ„**:

```text
[Request] â†’ [L1: Local Cache (moka)] â†’ [L2: Redis] â†’ [Database]
              â†“ 100Î¼s                    â†“ 1ms         â†“ 10ms
```

**Rust å®ç°**:

```rust
use moka::future::Cache as LocalCache;
use redis::aio::Connection as RedisConn;

pub struct MultiLevelCache {
    l1: LocalCache<String, String>,  // æœ¬åœ°ç¼“å­˜
    redis: Arc<Mutex<RedisConn>>,    // åˆ†å¸ƒå¼ç¼“å­˜
    db: PgPool,                      // æ•°æ®åº“
}

impl MultiLevelCache {
    async fn get_user(&self, user_id: i64) -> Result<User, Error> {
        let key = format!("user:{}", user_id);
        
        // L1: æœ¬åœ°ç¼“å­˜
        if let Some(value) = self.l1.get(&key).await {
            return Ok(serde_json::from_str(&value)?);
        }
        
        // L2: Redis
        let mut redis = self.redis.lock().await;
        if let Some(value) = redis.get::<_, Option<String>>(&key).await? {
            // å›å¡« L1
            self.l1.insert(key.clone(), value.clone()).await;
            return Ok(serde_json::from_str(&value)?);
        }
        
        // L3: æ•°æ®åº“
        let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", user_id)
            .fetch_one(&self.db)
            .await?;
        
        // å›å¡« L1 å’Œ L2
        let value = serde_json::to_string(&user)?;
        self.l1.insert(key.clone(), value.clone()).await;
        redis.set_ex(&key, value, 3600).await?;
        
        Ok(user)
    }
}
```

### 3.5.6.4 ç¼“å­˜ä¸€è‡´æ€§

**ç¼“å­˜å¤±æ•ˆç­–ç•¥**:

```rust
async fn update_user_with_cache_invalidation(
    user: &User,
    redis: &mut redis::aio::Connection,
    db: &PgPool,
) -> Result<(), Error> {
    // 1. åˆ é™¤ç¼“å­˜ (å…ˆåˆ é™¤)
    let cache_key = format!("user:{}", user.id);
    redis.del(&cache_key).await?;
    
    // 2. æ›´æ–°æ•°æ®åº“
    sqlx::query!(
        "UPDATE users SET name = $1, email = $2 WHERE id = $3",
        user.name,
        user.email,
        user.id
    )
    .execute(db)
    .await?;
    
    // 3. å»¶è¿ŸåŒåˆ  (é˜²æ­¢è„æ•°æ®)
    tokio::time::sleep(Duration::from_millis(100)).await;
    redis.del(&cache_key).await?;
    
    Ok(())
}
```

---

## 3.5.7 æ¶ˆæ¯é©±åŠ¨æ¶æ„

### 3.5.7.1 å‘å¸ƒ-è®¢é˜…æ¨¡å¼

**Kafka å®ç°**:

```rust
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::consumer::{Consumer, StreamConsumer};
use rdkafka::config::ClientConfig;

// å‘å¸ƒè€…
pub struct EventPublisher {
    producer: FutureProducer,
}

impl EventPublisher {
    pub async fn publish_event(&self, topic: &str, event: &Event) -> Result<(), Error> {
        let payload = serde_json::to_string(event)?;
        
        let record = FutureRecord::to(topic)
            .key(&event.aggregate_id)
            .payload(&payload);
        
        self.producer.send(record, Duration::from_secs(0)).await?;
        
        Ok(())
    }
}

// è®¢é˜…è€…
pub struct EventSubscriber {
    consumer: StreamConsumer,
}

impl EventSubscriber {
    pub async fn subscribe(&self, topics: &[&str]) -> Result<(), Error> {
        self.consumer.subscribe(topics)?;
        
        loop {
            match self.consumer.recv().await {
                Ok(message) => {
                    if let Some(payload) = message.payload() {
                        let event: Event = serde_json::from_slice(payload)?;
                        self.handle_event(event).await?;
                    }
                    
                    self.consumer.commit_message(&message, CommitMode::Async)?;
                }
                Err(e) => {
                    tracing::error!("Consumer error: {}", e);
                }
            }
        }
    }
    
    async fn handle_event(&self, event: Event) -> Result<(), Error> {
        match event.event_type {
            EventType::OrderCreated => { /* handle */ },
            EventType::OrderShipped => { /* handle */ },
            _ => {}
        }
        
        Ok(())
    }
}
```

### 3.5.7.2 äº‹ä»¶é©±åŠ¨æ¶æ„

**(Content continues with more patterns...)**-

---

## 3.5.10 åæ¨¡å¼ä¸é™·é˜±

**å¸¸è§åæ¨¡å¼**:

1. âŒ **åˆ†å¸ƒå¼å•ä½“**: å¾®æœåŠ¡ä½†å…±äº«æ•°æ®åº“
2. âŒ **è¿‡åº¦æ‹†åˆ†**: æœåŠ¡ç²’åº¦è¿‡ç»†ï¼Œé€šä¿¡å¼€é”€å¤§
3. âŒ **åŒæ­¥é“¾è·¯è¿‡é•¿**: A â†’ B â†’ C â†’ D (å»¶è¿Ÿç´¯ç§¯)
4. âŒ **ç¼ºä¹ç›‘æ§**: åˆ†å¸ƒå¼ç³»ç»Ÿå¿…é¡»æœ‰å…¨é¢ç›‘æ§
5. âŒ **å¿½ç•¥ç½‘ç»œåˆ†åŒº**: æœªè€ƒè™‘ç½‘ç»œæ•…éšœåœºæ™¯

**æœ€ä½³å®è·µ**:

1. âœ… **æœåŠ¡è‡ªæ²»**: æ¯ä¸ªæœåŠ¡æ‹¥æœ‰è‡ªå·±çš„æ•°æ®åº“
2. âœ… **å¼‚æ­¥é€šä¿¡**: ä¼˜å…ˆä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—
3. âœ… **å¹‚ç­‰è®¾è®¡**: æ‰€æœ‰æ“ä½œåº”æ”¯æŒé‡è¯•
4. âœ… **å¯è§‚æµ‹æ€§**: æ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ª
5. âœ… **å¼¹æ€§è®¾è®¡**: ç†”æ–­ã€é‡è¯•ã€é™çº§

---

## 3.5.11 å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£**:

- [Microservices Patterns](https://microservices.io/patterns/)
- [Rust Async Book](https://rust-lang.github.io/async-book/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)

**ç›¸å…³æ–‡æ¡£**:

- [3.3 åº“æˆç†Ÿåº¦è¯„ä¼°çŸ©é˜µ](3.3_åº“æˆç†Ÿåº¦è¯„ä¼°çŸ©é˜µ.md)
- [3.4 æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š](3.4_æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š.md)
- [2.4 Web æ¡†æ¶æŒ‡å—](../guides/2.4_Webæ¡†æ¶æŒ‡å—.md)
- [2.5 å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—](../guides/2.5_å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—.md)

---

**æŠ¥å‘Šå®Œæˆæ—¶é—´**: 2025-10-21  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ä¸‹æ¬¡æ›´æ–°**: 2026-01-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust æ¶æ„å›¢é˜Ÿ

---

**ğŸ¯ æœ¬æ–‡æ¡£ä¸º Rust ç³»ç»Ÿæ¶æ„è®¾è®¡æä¾›å…¨é¢æŒ‡å¯¼ï¼**
