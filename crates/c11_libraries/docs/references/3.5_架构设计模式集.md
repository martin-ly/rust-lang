# 3.5 Rust 架构设计模式集 (2025-10-21)

> **文档定位**: Rust 系统架构设计权威指南，模式库与最佳实践  
> **适用人群**: 架构师、技术负责人、高级开发者  
> **关联文档**: [3.3 成熟度矩阵](3.3_库成熟度评估矩阵.md) | [3.4 性能报告](3.4_性能基准测试报告.md) | [1.1 主索引](../1.1_主索引导航.md)

## 📊 目录

- [3.5 Rust 架构设计模式集 (2025-10-21)](#35-rust-架构设计模式集-2025-10-21)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [3.5.1 微服务架构模式](#351-微服务架构模式)
    - [3.5.1.1 服务拆分策略](#3511-服务拆分策略)
    - [3.5.1.2 API Gateway 模式](#3512-api-gateway-模式)
    - [3.5.1.3 服务发现与注册](#3513-服务发现与注册)
    - [3.5.1.4 服务间通信](#3514-服务间通信)
  - [3.5.2 数据架构模式](#352-数据架构模式)
    - [3.5.2.1 CQRS (命令查询职责分离)](#3521-cqrs-命令查询职责分离)
    - [3.5.2.2 Event Sourcing (事件溯源)](#3522-event-sourcing-事件溯源)
    - [3.5.2.3 Saga 分布式事务](#3523-saga-分布式事务)
    - [3.5.2.4 读写分离](#3524-读写分离)
  - [3.5.3 并发架构模式](#353-并发架构模式)
    - [3.5.3.1 Actor 模型](#3531-actor-模型)
    - [3.5.3.2 Pipeline 模式](#3532-pipeline-模式)
    - [3.5.3.3 Work Stealing 模式](#3533-work-stealing-模式)
    - [3.5.3.4 Lock-Free 数据结构](#3534-lock-free-数据结构)
  - [3.5.4 可靠性模式](#354-可靠性模式)
    - [3.5.4.1 熔断器模式](#3541-熔断器模式)
    - [3.5.4.2 重试与超时](#3542-重试与超时)
    - [3.5.4.3 限流模式](#3543-限流模式)
    - [3.5.4.4 降级与容错](#3544-降级与容错)
  - [3.5.5 可观测性模式](#355-可观测性模式)
    - [3.5.5.1 分布式追踪](#3551-分布式追踪)
    - [3.5.5.2 指标收集](#3552-指标收集)
    - [3.5.5.3 结构化日志](#3553-结构化日志)
    - [3.5.5.4 健康检查](#3554-健康检查)
  - [3.5.6 缓存架构模式](#356-缓存架构模式)
    - [3.5.6.1 Cache-Aside 模式](#3561-cache-aside-模式)
    - [3.5.6.2 Read-Through / Write-Through](#3562-read-through--write-through)
    - [3.5.6.3 多级缓存](#3563-多级缓存)
    - [3.5.6.4 缓存一致性](#3564-缓存一致性)
  - [3.5.7 消息驱动架构](#357-消息驱动架构)
    - [3.5.7.1 发布-订阅模式](#3571-发布-订阅模式)
    - [3.5.7.2 事件驱动架构](#3572-事件驱动架构)
  - [3.5.10 反模式与陷阱](#3510-反模式与陷阱)
  - [3.5.11 参考资源](#3511-参考资源)

**最后更新**: 2025-10-21  
**Rust 版本**: 1.90  
**文档状态**: ✅ 生产就绪

---

## 📋 目录

- [3.5 Rust 架构设计模式集 (2025-10-21)](#35-rust-架构设计模式集-2025-10-21)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [3.5.1 微服务架构模式](#351-微服务架构模式)
    - [3.5.1.1 服务拆分策略](#3511-服务拆分策略)
    - [3.5.1.2 API Gateway 模式](#3512-api-gateway-模式)
    - [3.5.1.3 服务发现与注册](#3513-服务发现与注册)
    - [3.5.1.4 服务间通信](#3514-服务间通信)
  - [3.5.2 数据架构模式](#352-数据架构模式)
    - [3.5.2.1 CQRS (命令查询职责分离)](#3521-cqrs-命令查询职责分离)
    - [3.5.2.2 Event Sourcing (事件溯源)](#3522-event-sourcing-事件溯源)
    - [3.5.2.3 Saga 分布式事务](#3523-saga-分布式事务)
    - [3.5.2.4 读写分离](#3524-读写分离)
  - [3.5.3 并发架构模式](#353-并发架构模式)
    - [3.5.3.1 Actor 模型](#3531-actor-模型)
    - [3.5.3.2 Pipeline 模式](#3532-pipeline-模式)
    - [3.5.3.3 Work Stealing 模式](#3533-work-stealing-模式)
    - [3.5.3.4 Lock-Free 数据结构](#3534-lock-free-数据结构)
  - [3.5.4 可靠性模式](#354-可靠性模式)
    - [3.5.4.1 熔断器模式](#3541-熔断器模式)
    - [3.5.4.2 重试与超时](#3542-重试与超时)
    - [3.5.4.3 限流模式](#3543-限流模式)
    - [3.5.4.4 降级与容错](#3544-降级与容错)
  - [3.5.5 可观测性模式](#355-可观测性模式)
    - [3.5.5.1 分布式追踪](#3551-分布式追踪)
    - [3.5.5.2 指标收集](#3552-指标收集)
    - [3.5.5.3 结构化日志](#3553-结构化日志)
    - [3.5.5.4 健康检查](#3554-健康检查)
  - [3.5.6 缓存架构模式](#356-缓存架构模式)
    - [3.5.6.1 Cache-Aside 模式](#3561-cache-aside-模式)
    - [3.5.6.2 Read-Through / Write-Through](#3562-read-through--write-through)
    - [3.5.6.3 多级缓存](#3563-多级缓存)
    - [3.5.6.4 缓存一致性](#3564-缓存一致性)
  - [3.5.7 消息驱动架构](#357-消息驱动架构)
    - [3.5.7.1 发布-订阅模式](#3571-发布-订阅模式)
    - [3.5.7.2 事件驱动架构](#3572-事件驱动架构)
  - [3.5.10 反模式与陷阱](#3510-反模式与陷阱)
  - [3.5.11 参考资源](#3511-参考资源)

---

## 3.5.1 微服务架构模式

### 3.5.1.1 服务拆分策略

**按业务能力拆分** (推荐):

```text
电商系统示例:
├── 用户服务 (User Service)
│   ├── 用户注册/登录
│   ├── 用户信息管理
│   └── 用户偏好设置
│
├── 商品服务 (Product Service)
│   ├── 商品目录管理
│   ├── 商品搜索
│   └── 库存管理
│
├── 订单服务 (Order Service)
│   ├── 订单创建
│   ├── 订单状态管理
│   └── 订单查询
│
└── 支付服务 (Payment Service)
    ├── 支付处理
    ├── 退款管理
    └── 账单生成
```

**拆分原则**:

1. ✅ **单一职责**: 每个服务专注于一个业务领域
2. ✅ **高内聚**: 相关功能在同一服务内
3. ✅ **低耦合**: 服务间通过 API 通信
4. ✅ **独立部署**: 服务可独立发布和扩展
5. ✅ **数据自治**: 每个服务拥有自己的数据库

**Rust 实现示例**:

```rust
// 用户服务 (独立 crate)
// crates/user-service/src/lib.rs

use axum::{Router, routing::{get, post}};
use sqlx::PgPool;

pub struct UserService {
    db: PgPool,
}

impl UserService {
    pub fn new(db: PgPool) -> Self {
        Self { db }
    }
    
    pub fn routes(&self) -> Router {
        Router::new()
            .route("/users", post(create_user))
            .route("/users/:id", get(get_user))
            .with_state(self.db.clone())
    }
}

async fn create_user(/* ... */) -> Result<Json<User>, Error> {
    // 用户创建逻辑
}

async fn get_user(/* ... */) -> Result<Json<User>, Error> {
    // 用户查询逻辑
}
```

### 3.5.1.2 API Gateway 模式

**架构设计**:

```text
                    [Client]
                       |
                   [API Gateway]
                    /   |   \
                   /    |    \
          [User      [Order   [Product
          Service]   Service] Service]
             |          |         |
          [User DB] [Order DB] [Product DB]
```

**API Gateway 职责**:

1. ✅ **路由转发**: 将请求路由到对应的后端服务
2. ✅ **认证授权**: 统一的身份验证和权限控制
3. ✅ **限流熔断**: 保护后端服务不被过载
4. ✅ **请求聚合**: 将多个后端调用聚合成一个响应
5. ✅ **协议转换**: HTTP/REST → gRPC
6. ✅ **监控日志**: 统一的可观测性

**Rust 实现 (Axum + Tower)**:

```rust
use axum::{Router, middleware, Extension};
use tower::{ServiceBuilder, ServiceExt};
use tower_http::{
    trace::TraceLayer,
    limit::RequestBodyLimitLayer,
};

#[tokio::main]
async fn main() {
    let app = Router::new()
        // 用户服务路由
        .nest("/api/users", user_routes())
        // 订单服务路由
        .nest("/api/orders", order_routes())
        // 商品服务路由
        .nest("/api/products", product_routes())
        // 中间件
        .layer(
            ServiceBuilder::new()
                // 追踪
                .layer(TraceLayer::new_for_http())
                // 限流
                .layer(RequestBodyLimitLayer::new(1024 * 1024)) // 1MB
                // 认证
                .layer(middleware::from_fn(auth_middleware))
                // 限流器
                .layer(middleware::from_fn(rate_limit_middleware))
        );
    
    let addr = "0.0.0.0:3000".parse().unwrap();
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

// 认证中间件
async fn auth_middleware(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let token = req.headers()
        .get("Authorization")
        .and_then(|v| v.to_str().ok());
    
    if let Some(token) = token {
        if verify_token(token).await? {
            return Ok(next.run(req).await);
        }
    }
    
    Err(StatusCode::UNAUTHORIZED)
}

// 限流中间件
async fn rate_limit_middleware(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let client_ip = get_client_ip(&req);
    
    if check_rate_limit(client_ip).await {
        Ok(next.run(req).await)
    } else {
        Err(StatusCode::TOO_MANY_REQUESTS)
    }
}
```

### 3.5.1.3 服务发现与注册

**服务注册流程**:

```text
1. 服务启动 → 2. 注册到注册中心 → 3. 定期发送心跳
                    ↓
            4. 客户端查询 → 5. 获取服务列表 → 6. 负载均衡调用
```

**Consul 集成示例**:

```rust
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Serialize, Deserialize)]
struct ServiceRegistration {
    id: String,
    name: String,
    address: String,
    port: u16,
    check: HealthCheck,
}

#[derive(Serialize, Deserialize)]
struct HealthCheck {
    http: String,
    interval: String,
    timeout: String,
}

pub struct ConsulClient {
    client: Client,
    consul_addr: String,
}

impl ConsulClient {
    pub fn new(consul_addr: String) -> Self {
        Self {
            client: Client::new(),
            consul_addr,
        }
    }
    
    // 注册服务
    pub async fn register_service(
        &self,
        service_name: &str,
        service_addr: &str,
        service_port: u16,
    ) -> Result<(), Error> {
        let registration = ServiceRegistration {
            id: format!("{}-{}", service_name, uuid::Uuid::new_v4()),
            name: service_name.to_string(),
            address: service_addr.to_string(),
            port: service_port,
            check: HealthCheck {
                http: format!("http://{}:{}/health", service_addr, service_port),
                interval: "10s".to_string(),
                timeout: "5s".to_string(),
            },
        };
        
        self.client
            .put(&format!("{}/v1/agent/service/register", self.consul_addr))
            .json(&registration)
            .send()
            .await?;
        
        Ok(())
    }
    
    // 发现服务
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<Service>, Error> {
        let response = self.client
            .get(&format!("{}/v1/health/service/{}", self.consul_addr, service_name))
            .query(&[("passing", "true")])
            .send()
            .await?;
        
        let services: Vec<Service> = response.json().await?;
        Ok(services)
    }
    
    // 注销服务
    pub async fn deregister_service(&self, service_id: &str) -> Result<(), Error> {
        self.client
            .put(&format!("{}/v1/agent/service/deregister/{}", self.consul_addr, service_id))
            .send()
            .await?;
        
        Ok(())
    }
}
```

### 3.5.1.4 服务间通信

**通信方式对比**:

| 方式 | 特点 | 适用场景 | Rust 库 |
|------|------|---------|---------|
| **RESTful API** | 简单、通用 | 外部 API、轻量调用 | `axum`, `reqwest` |
| **gRPC** | 高性能、类型安全 | 内部服务、高频调用 | `tonic` |
| **消息队列** | 异步、解耦 | 事件通知、批处理 | `rdkafka`, `lapin` |
| **GraphQL** | 灵活查询 | 复杂数据聚合 | `async-graphql` |

**gRPC 服务间通信示例**:

```protobuf
// proto/user.proto
syntax = "proto3";

package user;

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
}

message GetUserRequest {
    int64 user_id = 1;
}

message CreateUserRequest {
    string name = 1;
    string email = 2;
}

message User {
    int64 id = 1;
    string name = 2;
    string email = 3;
    string created_at = 4;
}
```

```rust
// 服务端实现
use tonic::{transport::Server, Request, Response, Status};
use user_proto::user_service_server::{UserService, UserServiceServer};
use user_proto::{GetUserRequest, CreateUserRequest, User};

pub struct UserServiceImpl {
    db: PgPool,
}

#[tonic::async_trait]
impl UserService for UserServiceImpl {
    async fn get_user(
        &self,
        request: Request<GetUserRequest>,
    ) -> Result<Response<User>, Status> {
        let user_id = request.into_inner().user_id;
        
        let user = sqlx::query_as!(
            User,
            "SELECT id, name, email, created_at FROM users WHERE id = $1",
            user_id
        )
        .fetch_one(&self.db)
        .await
        .map_err(|e| Status::not_found(format!("User not found: {}", e)))?;
        
        Ok(Response::new(user))
    }
    
    async fn create_user(
        &self,
        request: Request<CreateUserRequest>,
    ) -> Result<Response<User>, Status> {
        let req = request.into_inner();
        
        let user = sqlx::query_as!(
            User,
            "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *",
            req.name,
            req.email
        )
        .fetch_one(&self.db)
        .await
        .map_err(|e| Status::internal(format!("Failed to create user: {}", e)))?;
        
        Ok(Response::new(user))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "[::1]:50051".parse()?;
    let service = UserServiceImpl { db: create_pool().await? };
    
    Server::builder()
        .add_service(UserServiceServer::new(service))
        .serve(addr)
        .await?;
    
    Ok(())
}
```

```rust
// 客户端调用
use user_proto::user_service_client::UserServiceClient;
use user_proto::{GetUserRequest, CreateUserRequest};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = UserServiceClient::connect("http://[::1]:50051").await?;
    
    // 获取用户
    let request = tonic::Request::new(GetUserRequest {
        user_id: 1,
    });
    
    let response = client.get_user(request).await?;
    println!("User: {:?}", response.into_inner());
    
    // 创建用户
    let request = tonic::Request::new(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    });
    
    let response = client.create_user(request).await?;
    println!("Created user: {:?}", response.into_inner());
    
    Ok(())
}
```

---

## 3.5.2 数据架构模式

### 3.5.2.1 CQRS (命令查询职责分离)

**架构设计**:

```text
        [Client]
           |
    +------+------+
    |             |
[Command      [Query
  API]          API]
    |             |
[Command      [Query
  Model]        Model]
    |             |
[Write DB] → [Read DB]
           (Sync)
```

**核心概念**:

- **Command (命令)**: 修改数据的操作 (Create, Update, Delete)
- **Query (查询)**: 只读操作 (Read)
- **分离优势**: 读写分离、独立扩展、不同数据模型优化

**Rust 实现示例**:

```rust
use axum::{Router, routing::{get, post}};
use sqlx::{PgPool, postgres::PgPoolOptions};
use serde::{Deserialize, Serialize};

// ========== Command Side ==========

#[derive(Deserialize)]
struct CreateOrderCommand {
    user_id: i64,
    product_id: i64,
    quantity: i32,
}

#[derive(Deserialize)]
struct UpdateOrderStatusCommand {
    order_id: i64,
    status: String,
}

// 命令处理器
struct CommandHandler {
    write_db: PgPool,  // 写数据库
    event_bus: EventBus,  // 事件总线
}

impl CommandHandler {
    async fn handle_create_order(
        &self,
        cmd: CreateOrderCommand,
    ) -> Result<i64, Error> {
        // 1. 验证命令
        self.validate_order(&cmd).await?;
        
        // 2. 执行业务逻辑
        let order_id = sqlx::query_scalar!(
            "INSERT INTO orders (user_id, product_id, quantity, status) 
             VALUES ($1, $2, $3, 'pending') RETURNING id",
            cmd.user_id,
            cmd.product_id,
            cmd.quantity
        )
        .fetch_one(&self.write_db)
        .await?;
        
        // 3. 发布事件
        self.event_bus.publish(OrderCreatedEvent {
            order_id,
            user_id: cmd.user_id,
            product_id: cmd.product_id,
            quantity: cmd.quantity,
        }).await?;
        
        Ok(order_id)
    }
    
    async fn handle_update_order_status(
        &self,
        cmd: UpdateOrderStatusCommand,
    ) -> Result<(), Error> {
        sqlx::query!(
            "UPDATE orders SET status = $1 WHERE id = $2",
            cmd.status,
            cmd.order_id
        )
        .execute(&self.write_db)
        .await?;
        
        self.event_bus.publish(OrderStatusUpdatedEvent {
            order_id: cmd.order_id,
            status: cmd.status.clone(),
        }).await?;
        
        Ok(())
    }
}

// ========== Query Side ==========

#[derive(Serialize)]
struct OrderView {
    id: i64,
    user_name: String,
    product_name: String,
    quantity: i32,
    status: String,
    total_price: f64,
    created_at: String,
}

// 查询处理器
struct QueryHandler {
    read_db: PgPool,  // 读数据库 (可能是只读副本)
}

impl QueryHandler {
    async fn get_order_by_id(&self, order_id: i64) -> Result<OrderView, Error> {
        let order = sqlx::query_as!(
            OrderView,
            r#"
            SELECT 
                o.id,
                u.name as user_name,
                p.name as product_name,
                o.quantity,
                o.status,
                o.quantity * p.price as total_price,
                o.created_at::text
            FROM orders o
            JOIN users u ON o.user_id = u.id
            JOIN products p ON o.product_id = p.id
            WHERE o.id = $1
            "#,
            order_id
        )
        .fetch_one(&self.read_db)
        .await?;
        
        Ok(order)
    }
    
    async fn get_user_orders(&self, user_id: i64) -> Result<Vec<OrderView>, Error> {
        let orders = sqlx::query_as!(
            OrderView,
            r#"
            SELECT 
                o.id,
                u.name as user_name,
                p.name as product_name,
                o.quantity,
                o.status,
                o.quantity * p.price as total_price,
                o.created_at::text
            FROM orders o
            JOIN users u ON o.user_id = u.id
            JOIN products p ON o.product_id = p.id
            WHERE o.user_id = $1
            ORDER BY o.created_at DESC
            "#,
            user_id
        )
        .fetch_all(&self.read_db)
        .await?;
        
        Ok(orders)
    }
}

// ========== 事件同步 ==========

struct EventSyncWorker {
    event_bus: EventBus,
    read_db: PgPool,
}

impl EventSyncWorker {
    async fn start(&self) {
        loop {
            if let Some(event) = self.event_bus.consume().await {
                match event {
                    Event::OrderCreated(e) => self.sync_order_created(e).await,
                    Event::OrderStatusUpdated(e) => self.sync_order_status(e).await,
                    _ => {}
                }
            }
        }
    }
    
    async fn sync_order_created(&self, event: OrderCreatedEvent) {
        // 更新读数据库的聚合视图
        sqlx::query!(
            "INSERT INTO order_views (...) VALUES (...)"
        )
        .execute(&self.read_db)
        .await
        .ok();
    }
}
```

### 3.5.2.2 Event Sourcing (事件溯源)

**核心思想**:

不存储当前状态，而是存储所有状态变更事件，通过重放事件重建当前状态。

**架构设计**:

```text
[Command] → [Aggregate] → [Events] → [Event Store]
                              ↓
                         [Projections]
                              ↓
                         [Read Models]
```

**Rust 实现示例**:

```rust
use serde::{Deserialize, Serialize};
use sqlx::PgPool;

// ========== Events ==========

#[derive(Serialize, Deserialize, Clone)]
#[serde(tag = "type")]
enum OrderEvent {
    OrderCreated {
        order_id: String,
        user_id: i64,
        items: Vec<OrderItem>,
        total: f64,
        timestamp: i64,
    },
    ItemAdded {
        order_id: String,
        item: OrderItem,
        timestamp: i64,
    },
    OrderShipped {
        order_id: String,
        tracking_number: String,
        timestamp: i64,
    },
    OrderDelivered {
        order_id: String,
        timestamp: i64,
    },
    OrderCancelled {
        order_id: String,
        reason: String,
        timestamp: i64,
    },
}

// ========== Event Store ==========

pub struct EventStore {
    db: PgPool,
}

impl EventStore {
    // 保存事件
    pub async fn save_event(
        &self,
        aggregate_id: &str,
        event: &OrderEvent,
        version: i32,
    ) -> Result<(), Error> {
        let event_data = serde_json::to_value(event)?;
        
        sqlx::query!(
            r#"
            INSERT INTO event_store (aggregate_id, aggregate_type, version, event_type, event_data, created_at)
            VALUES ($1, 'Order', $2, $3, $4, NOW())
            "#,
            aggregate_id,
            version,
            event_type_name(event),
            event_data
        )
        .execute(&self.db)
        .await?;
        
        Ok(())
    }
    
    // 加载聚合的所有事件
    pub async fn load_events(&self, aggregate_id: &str) -> Result<Vec<OrderEvent>, Error> {
        let rows = sqlx::query!(
            r#"
            SELECT event_data
            FROM event_store
            WHERE aggregate_id = $1
            ORDER BY version ASC
            "#,
            aggregate_id
        )
        .fetch_all(&self.db)
        .await?;
        
        let events = rows
            .into_iter()
            .map(|row| serde_json::from_value(row.event_data).unwrap())
            .collect();
        
        Ok(events)
    }
}

// ========== Aggregate ==========

#[derive(Default)]
pub struct OrderAggregate {
    id: String,
    user_id: i64,
    items: Vec<OrderItem>,
    status: OrderStatus,
    total: f64,
    version: i32,
    uncommitted_events: Vec<OrderEvent>,
}

impl OrderAggregate {
    // 从事件重建聚合
    pub fn rebuild_from_events(events: Vec<OrderEvent>) -> Self {
        let mut aggregate = Self::default();
        for event in events {
            aggregate.apply_event(&event);
            aggregate.version += 1;
        }
        aggregate
    }
    
    // 应用事件到聚合状态
    fn apply_event(&mut self, event: &OrderEvent) {
        match event {
            OrderEvent::OrderCreated { order_id, user_id, items, total, .. } => {
                self.id = order_id.clone();
                self.user_id = *user_id;
                self.items = items.clone();
                self.total = *total;
                self.status = OrderStatus::Created;
            },
            OrderEvent::ItemAdded { item, .. } => {
                self.items.push(item.clone());
                self.total += item.price * item.quantity as f64;
            },
            OrderEvent::OrderShipped { .. } => {
                self.status = OrderStatus::Shipped;
            },
            OrderEvent::OrderDelivered { .. } => {
                self.status = OrderStatus::Delivered;
            },
            OrderEvent::OrderCancelled { .. } => {
                self.status = OrderStatus::Cancelled;
            },
        }
    }
    
    // 业务命令
    pub fn ship_order(&mut self, tracking_number: String) -> Result<(), Error> {
        if self.status != OrderStatus::Created {
            return Err(Error::InvalidState("Order must be in Created state"));
        }
        
        let event = OrderEvent::OrderShipped {
            order_id: self.id.clone(),
            tracking_number,
            timestamp: current_timestamp(),
        };
        
        self.apply_event(&event);
        self.uncommitted_events.push(event);
        
        Ok(())
    }
    
    // 获取未提交的事件
    pub fn uncommitted_events(&self) -> &[OrderEvent] {
        &self.uncommitted_events
    }
    
    // 标记事件已提交
    pub fn mark_events_committed(&mut self) {
        self.uncommitted_events.clear();
    }
}

// ========== Command Handler with Event Sourcing ==========

pub struct OrderCommandHandler {
    event_store: EventStore,
}

impl OrderCommandHandler {
    pub async fn handle_ship_order(
        &self,
        order_id: &str,
        tracking_number: String,
    ) -> Result<(), Error> {
        // 1. 从事件存储加载聚合
        let events = self.event_store.load_events(order_id).await?;
        let mut aggregate = OrderAggregate::rebuild_from_events(events);
        
        // 2. 执行业务逻辑
        aggregate.ship_order(tracking_number)?;
        
        // 3. 保存新事件
        for event in aggregate.uncommitted_events() {
            self.event_store
                .save_event(order_id, event, aggregate.version + 1)
                .await?;
        }
        
        aggregate.mark_events_committed();
        
        Ok(())
    }
}
```

**Event Sourcing 优势**:

1. ✅ **完整审计日志**: 所有状态变更都有记录
2. ✅ **时间旅行**: 可以回溯到任意时间点的状态
3. ✅ **事件重放**: 修复 bug 后可以重放事件
4. ✅ **多个读模型**: 从同一事件流构建不同视图

### 3.5.2.3 Saga 分布式事务

**编排式 Saga (Orchestration)**:

```text
[Saga Orchestrator]
         |
         +--→ [Order Service] → Success
         +--→ [Payment Service] → Success
         +--→ [Inventory Service] → Failed
         +--→ [Compensation: Cancel Payment]
         +--→ [Compensation: Cancel Order]
```

**Rust 实现示例**:

```rust
use async_trait::async_trait;
use thiserror::Error;

#[derive(Error, Debug)]
enum SagaError {
    #[error("Step failed: {0}")]
    StepFailed(String),
    #[error("Compensation failed: {0}")]
    CompensationFailed(String),
}

// ========== Saga Step Trait ==========

#[async_trait]
trait SagaStep: Send + Sync {
    async fn execute(&self) -> Result<(), SagaError>;
    async fn compensate(&self) -> Result<(), SagaError>;
}

// ========== Saga Orchestrator ==========

pub struct SagaOrchestrator {
    steps: Vec<Box<dyn SagaStep>>,
}

impl SagaOrchestrator {
    pub fn new() -> Self {
        Self { steps: Vec::new() }
    }
    
    pub fn add_step(&mut self, step: Box<dyn SagaStep>) {
        self.steps.push(step);
    }
    
    pub async fn execute(&self) -> Result<(), SagaError> {
        let mut completed_steps = Vec::new();
        
        // 顺序执行所有步骤
        for step in &self.steps {
            match step.execute().await {
                Ok(_) => {
                    completed_steps.push(step);
                },
                Err(e) => {
                    // 执行失败，补偿已完成的步骤
                    self.compensate_steps(&completed_steps).await?;
                    return Err(e);
                }
            }
        }
        
        Ok(())
    }
    
    async fn compensate_steps(&self, steps: &[&Box<dyn SagaStep>]) -> Result<(), SagaError> {
        // 逆序补偿
        for step in steps.iter().rev() {
            step.compensate().await?;
        }
        Ok(())
    }
}

// ========== Concrete Steps ==========

struct CreateOrderStep {
    order_service: OrderServiceClient,
    order_id: String,
}

#[async_trait]
impl SagaStep for CreateOrderStep {
    async fn execute(&self) -> Result<(), SagaError> {
        self.order_service
            .create_order(&self.order_id)
            .await
            .map_err(|e| SagaError::StepFailed(format!("Create order failed: {}", e)))
    }
    
    async fn compensate(&self) -> Result<(), SagaError> {
        self.order_service
            .cancel_order(&self.order_id)
            .await
            .map_err(|e| SagaError::CompensationFailed(format!("Cancel order failed: {}", e)))
    }
}

struct ProcessPaymentStep {
    payment_service: PaymentServiceClient,
    payment_id: String,
}

#[async_trait]
impl SagaStep for ProcessPaymentStep {
    async fn execute(&self) -> Result<(), SagaError> {
        self.payment_service
            .process_payment(&self.payment_id)
            .await
            .map_err(|e| SagaError::StepFailed(format!("Payment failed: {}", e)))
    }
    
    async fn compensate(&self) -> Result<(), SagaError> {
        self.payment_service
            .refund_payment(&self.payment_id)
            .await
            .map_err(|e| SagaError::CompensationFailed(format!("Refund failed: {}", e)))
    }
}

struct ReserveInventoryStep {
    inventory_service: InventoryServiceClient,
    product_id: String,
    quantity: i32,
}

#[async_trait]
impl SagaStep for ReserveInventoryStep {
    async fn execute(&self) -> Result<(), SagaError> {
        self.inventory_service
            .reserve_inventory(&self.product_id, self.quantity)
            .await
            .map_err(|e| SagaError::StepFailed(format!("Reserve inventory failed: {}", e)))
    }
    
    async fn compensate(&self) -> Result<(), SagaError> {
        self.inventory_service
            .release_inventory(&self.product_id, self.quantity)
            .await
            .map_err(|e| SagaError::CompensationFailed(format!("Release inventory failed: {}", e)))
    }
}

// ========== Usage ==========

async fn create_order_saga(
    order_id: String,
    payment_id: String,
    product_id: String,
    quantity: i32,
) -> Result<(), SagaError> {
    let mut saga = SagaOrchestrator::new();
    
    // 添加步骤
    saga.add_step(Box::new(CreateOrderStep {
        order_service: create_order_service_client(),
        order_id: order_id.clone(),
    }));
    
    saga.add_step(Box::new(ProcessPaymentStep {
        payment_service: create_payment_service_client(),
        payment_id,
    }));
    
    saga.add_step(Box::new(ReserveInventoryStep {
        inventory_service: create_inventory_service_client(),
        product_id,
        quantity,
    }));
    
    // 执行 Saga
    saga.execute().await
}
```

### 3.5.2.4 读写分离

**架构设计**:

```text
[Client]
   |
   +--→ Write → [Master DB]
   |                |
   |                ↓ (Replication)
   +--→ Read  → [Read Replica 1]
                [Read Replica 2]
                [Read Replica 3]
```

**Rust 实现 (SQLx)**:

```rust
use sqlx::{PgPool, postgres::PgPoolOptions};
use std::sync::Arc;

pub struct DatabasePool {
    master: PgPool,      // 写库
    replicas: Vec<PgPool>,  // 读库
    current_replica: Arc<AtomicUsize>,
}

impl DatabasePool {
    pub async fn new(
        master_url: &str,
        replica_urls: Vec<String>,
    ) -> Result<Self, sqlx::Error> {
        let master = PgPoolOptions::new()
            .max_connections(100)
            .connect(master_url)
            .await?;
        
        let mut replicas = Vec::new();
        for url in replica_urls {
            let pool = PgPoolOptions::new()
                .max_connections(50)
                .connect(&url)
                .await?;
            replicas.push(pool);
        }
        
        Ok(Self {
            master,
            replicas,
            current_replica: Arc::new(AtomicUsize::new(0)),
        })
    }
    
    // 获取写连接
    pub fn master(&self) -> &PgPool {
        &self.master
    }
    
    // 获取读连接 (负载均衡)
    pub fn replica(&self) -> &PgPool {
        if self.replicas.is_empty() {
            return &self.master;
        }
        
        let index = self.current_replica.fetch_add(1, Ordering::Relaxed);
        let index = index % self.replicas.len();
        &self.replicas[index]
    }
}

// 使用示例
async fn user_service_example() -> Result<(), Error> {
    let db = DatabasePool::new(
        "postgresql://master:5432/db",
        vec![
            "postgresql://replica1:5432/db".to_string(),
            "postgresql://replica2:5432/db".to_string(),
        ],
    ).await?;
    
    // 写操作 - 使用 master
    sqlx::query!(
        "INSERT INTO users (name, email) VALUES ($1, $2)",
        "Alice",
        "alice@example.com"
    )
    .execute(db.master())
    .await?;
    
    // 读操作 - 使用 replica (自动负载均衡)
    let users = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE active = true"
    )
    .fetch_all(db.replica())
    .await?;
    
    Ok(())
}
```

---

## 3.5.3 并发架构模式

### 3.5.3.1 Actor 模型

**核心概念**:

- Actor: 独立的计算单元，拥有自己的状态
- 消息传递: Actor 之间通过异步消息通信
- 无共享状态: 避免锁和数据竞争

**Rust 实现 (Actix)**:

```rust
use actix::prelude::*;

// ========== Messages ==========

#[derive(Message)]
#[rtype(result = "Result<i64, ()>")]
struct CreateOrder {
    user_id: i64,
    product_id: i64,
    quantity: i32,
}

#[derive(Message)]
#[rtype(result = "Result<OrderStatus, ()>")]
struct GetOrderStatus {
    order_id: i64,
}

// ========== Actor ==========

struct OrderActor {
    db: PgPool,
}

impl Actor for OrderActor {
    type Context = Context<Self>;
}

impl Handler<CreateOrder> for OrderActor {
    type Result = ResponseFuture<Result<i64, ()>>;
    
    fn handle(&mut self, msg: CreateOrder, _ctx: &mut Self::Context) -> Self::Result {
        let db = self.db.clone();
        
        Box::pin(async move {
            let order_id = sqlx::query_scalar!(
                "INSERT INTO orders (user_id, product_id, quantity) VALUES ($1, $2, $3) RETURNING id",
                msg.user_id,
                msg.product_id,
                msg.quantity
            )
            .fetch_one(&db)
            .await
            .map_err(|_| ())?;
            
            Ok(order_id)
        })
    }
}

impl Handler<GetOrderStatus> for OrderActor {
    type Result = ResponseFuture<Result<OrderStatus, ()>>;
    
    fn handle(&mut self, msg: GetOrderStatus, _ctx: &mut Self::Context) -> Self::Result {
        let db = self.db.clone();
        
        Box::pin(async move {
            let status = sqlx::query_scalar!(
                "SELECT status FROM orders WHERE id = $1",
                msg.order_id
            )
            .fetch_one(&db)
            .await
            .map_err(|_| ())?;
            
            Ok(status)
        })
    }
}

// ========== Usage ==========

#[actix_web::main]
async fn main() {
    let db = create_database_pool().await;
    
    // 启动 Actor
    let order_actor = OrderActor { db }.start();
    
    // 发送消息
    let order_id = order_actor
        .send(CreateOrder {
            user_id: 1,
            product_id: 100,
            quantity: 2,
        })
        .await
        .unwrap()
        .unwrap();
    
    println!("Created order: {}", order_id);
    
    let status = order_actor
        .send(GetOrderStatus { order_id })
        .await
        .unwrap()
        .unwrap();
    
    println!("Order status: {:?}", status);
}
```

### 3.5.3.2 Pipeline 模式

**架构设计**:

```text
[Input] → [Stage 1] → [Stage 2] → [Stage 3] → [Output]
           ↓           ↓           ↓
        [Buffer]    [Buffer]    [Buffer]
```

**Rust 实现 (Tokio)**:

```rust
use tokio::sync::mpsc;
use tokio::task;

// ========== Pipeline Stages ==========

async fn stage1_validate(
    mut input: mpsc::Receiver<String>,
    output: mpsc::Sender<String>,
) {
    while let Some(data) = input.recv().await {
        // 验证数据
        if data.len() > 0 {
            output.send(data).await.ok();
        }
    }
}

async fn stage2_transform(
    mut input: mpsc::Receiver<String>,
    output: mpsc::Sender<String>,
) {
    while let Some(data) = input.recv().await {
        // 转换数据
        let transformed = data.to_uppercase();
        output.send(transformed).await.ok();
    }
}

async fn stage3_process(
    mut input: mpsc::Receiver<String>,
    output: mpsc::Sender<String>,
) {
    while let Some(data) = input.recv().await {
        // 处理数据
        let processed = format!("Processed: {}", data);
        output.send(processed).await.ok();
    }
}

// ========== Pipeline Setup ==========

async fn run_pipeline() {
    let (tx1, rx1) = mpsc::channel(100);
    let (tx2, rx2) = mpsc::channel(100);
    let (tx3, rx3) = mpsc::channel(100);
    
    // 启动 pipeline stages
    task::spawn(stage1_validate(rx1, tx2));
    task::spawn(stage2_transform(rx2, tx3));
    task::spawn(stage3_process(rx3, /* final output */));
    
    // 输入数据
    for i in 0..1000 {
        tx1.send(format!("data-{}", i)).await.ok();
    }
}
```

### 3.5.3.3 Work Stealing 模式

**Tokio 内置实现**:

Tokio 运行时默认使用 work-stealing 调度器，无需手动实现。

**原理**:

```text
Thread 1: [Task1, Task2, Task3]
Thread 2: [Task4, Task5]
Thread 3: []  ← 空闲，从 Thread 1 偷取 Task3
```

**配置示例**:

```rust
use tokio::runtime::Runtime;

fn main() {
    // 创建多线程运行时 (work-stealing)
    let runtime = Runtime::new().unwrap();
    
    runtime.block_on(async {
        // 生成大量任务
        for i in 0..10_000 {
            tokio::spawn(async move {
                // 模拟工作
                tokio::time::sleep(Duration::from_millis(10)).await;
                println!("Task {} completed", i);
            });
        }
    });
}
```

### 3.5.3.4 Lock-Free 数据结构

**Crossbeam 无锁队列**:

```rust
use crossbeam::queue::SegQueue;
use std::sync::Arc;
use std::thread;

fn lock_free_queue_example() {
    let queue = Arc::new(SegQueue::new());
    
    // 生产者线程
    let queue_clone = queue.clone();
    thread::spawn(move || {
        for i in 0..1000 {
            queue_clone.push(i);
        }
    });
    
    // 消费者线程
    let queue_clone = queue.clone();
    thread::spawn(move || {
        loop {
            if let Some(item) = queue_clone.pop() {
                println!("Consumed: {}", item);
            }
        }
    });
}
```

---

## 3.5.4 可靠性模式

### 3.5.4.1 熔断器模式

**状态机**:

```text
[Closed] --错误达到阈值--> [Open] --超时--> [Half-Open] --成功--> [Closed]
   ↑                          |                   |
   |                          +--失败--------------+
   +--成功-----------------------+
```

**Rust 实现**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use tokio::time::{Duration, Instant};

#[derive(Clone)]
enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: Arc<AtomicU64>,
    success_count: Arc<AtomicU64>,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
    failure_threshold: u64,
    success_threshold: u64,
    timeout: Duration,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u64, timeout: Duration) -> Self {
        Self {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(AtomicU64::new(0)),
            success_count: Arc::new(AtomicU64::new(0)),
            last_failure_time: Arc::new(Mutex::new(None)),
            failure_threshold,
            success_threshold: 3,
            timeout,
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: FnOnce() -> Future<Output = Result<T, E>>,
    {
        // 检查状态
        let state = self.state.lock().await.clone();
        
        match state {
            CircuitState::Open => {
                // 检查是否超时
                if let Some(last_time) = *self.last_failure_time.lock().await {
                    if Instant::now().duration_since(last_time) > self.timeout {
                        // 转换到 Half-Open
                        *self.state.lock().await = CircuitState::HalfOpen;
                    } else {
                        return Err(/* CircuitOpenError */);
                    }
                }
            }
            _ => {}
        }
        
        // 执行调用
        match f().await {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(e)
            }
        }
    }
    
    async fn on_success(&self) {
        let state = self.state.lock().await.clone();
        
        match state {
            CircuitState::HalfOpen => {
                let count = self.success_count.fetch_add(1, Ordering::Relaxed) + 1;
                if count >= self.success_threshold {
                    *self.state.lock().await = CircuitState::Closed;
                    self.reset_counters();
                }
            }
            CircuitState::Closed => {
                self.failure_count.store(0, Ordering::Relaxed);
            }
            _ => {}
        }
    }
    
    async fn on_failure(&self) {
        let count = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;
        
        if count >= self.failure_threshold {
            *self.state.lock().await = CircuitState::Open;
            *self.last_failure_time.lock().await = Some(Instant::now());
        }
    }
    
    fn reset_counters(&self) {
        self.failure_count.store(0, Ordering::Relaxed);
        self.success_count.store(0, Ordering::Relaxed);
    }
}

// 使用示例
async fn call_external_service_with_breaker() -> Result<String, Error> {
    let breaker = CircuitBreaker::new(5, Duration::from_secs(30));
    
    breaker.call(|| async {
        // 调用外部服务
        reqwest::get("https://api.example.com/data")
            .await?
            .text()
            .await
    }).await
}
```

### 3.5.4.2 重试与超时

**指数退避重试**:

```rust
use tokio::time::{sleep, Duration};

pub async fn retry_with_backoff<F, T, E>(
    mut f: F,
    max_retries: u32,
    initial_delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Future<Output = Result<T, E>>,
{
    let mut attempt = 0;
    let mut delay = initial_delay;
    
    loop {
        match f().await {
            Ok(result) => return Ok(result),
            Err(e) => {
                attempt += 1;
                if attempt >= max_retries {
                    return Err(e);
                }
                
                // 指数退避
                sleep(delay).await;
                delay *= 2;
                
                // 添加 jitter
                delay += Duration::from_millis(rand::random::<u64>() % 1000);
            }
        }
    }
}

// 使用示例
async fn fetch_data_with_retry() -> Result<String, Error> {
    retry_with_backoff(
        || async {
            reqwest::get("https://api.example.com/data")
                .await?
                .text()
                .await
        },
        3,  // 最多重试 3 次
        Duration::from_secs(1),  // 初始延迟 1 秒
    ).await
}
```

**超时控制**:

```rust
use tokio::time::{timeout, Duration};

async fn call_with_timeout() -> Result<String, Error> {
    match timeout(
        Duration::from_secs(10),
        reqwest::get("https://api.example.com/data").await?.text()
    ).await {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(e)) => Err(e),
        Err(_) => Err(Error::Timeout),
    }
}
```

### 3.5.4.3 限流模式

**令牌桶算法**:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;
use tokio::time::{interval, Duration};

pub struct RateLimiter {
    semaphore: Arc<Semaphore>,
    rate: u32,
}

impl RateLimiter {
    pub fn new(rate_per_second: u32) -> Self {
        let semaphore = Arc::new(Semaphore::new(rate_per_second as usize));
        
        // 定期补充令牌
        let sem_clone = semaphore.clone();
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(1));
            loop {
                interval.tick().await;
                sem_clone.add_permits(rate_per_second as usize);
            }
        });
        
        Self { semaphore, rate: rate_per_second }
    }
    
    pub async fn acquire(&self) -> Result<(), Error> {
        self.semaphore
            .acquire()
            .await
            .map(|_| ())
            .map_err(|_| Error::RateLimitExceeded)
    }
}

// 使用示例
async fn rate_limited_request(limiter: &RateLimiter) -> Result<(), Error> {
    limiter.acquire().await?;
    
    // 执行请求
    reqwest::get("https://api.example.com/data").await?;
    
    Ok(())
}
```

### 3.5.4.4 降级与容错

**服务降级示例**:

```rust
pub async fn get_user_recommendations(
    user_id: i64,
    recommendation_service: &RecommendationService,
    db: &PgPool,
) -> Result<Vec<Product>, Error> {
    // 尝试调用推荐服务
    match recommendation_service
        .get_recommendations(user_id)
        .await
    {
        Ok(products) => Ok(products),
        Err(e) => {
            // 降级: 使用默认策略
            tracing::warn!("Recommendation service failed, using fallback: {}", e);
            
            // 返回热门商品
            let products = sqlx::query_as!(
                Product,
                "SELECT * FROM products ORDER BY sales_count DESC LIMIT 10"
            )
            .fetch_all(db)
            .await?;
            
            Ok(products)
        }
    }
}
```

---

## 3.5.5 可观测性模式

### 3.5.5.1 分布式追踪

**OpenTelemetry 集成**:

```rust
use opentelemetry::{global, trace::Tracer, KeyValue};
use opentelemetry_sdk::trace::{config, TracerProvider};
use tracing_subscriber::layer::SubscriberExt;

#[tokio::main]
async fn main() {
    // 初始化 OpenTelemetry
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_simple()
        .unwrap();
    
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    tracing_subscriber::registry()
        .with(telemetry)
        .with(tracing_subscriber::fmt::layer())
        .init();
    
    // 使用追踪
    process_order(123).await;
}

#[tracing::instrument]
async fn process_order(order_id: i64) {
    tracing::info!("Processing order: {}", order_id);
    
    validate_order(order_id).await;
    charge_payment(order_id).await;
    ship_order(order_id).await;
}

#[tracing::instrument]
async fn validate_order(order_id: i64) {
    // 验证逻辑
    tracing::debug!("Order validated");
}
```

### 3.5.5.2 指标收集

**Prometheus 集成**:

```rust
use prometheus::{Counter, Histogram, Registry, Encoder, TextEncoder};
use axum::{Router, routing::get};

// 定义指标
lazy_static! {
    static ref HTTP_REQUESTS_TOTAL: Counter = Counter::new(
        "http_requests_total",
        "Total HTTP requests"
    ).unwrap();
    
    static ref HTTP_REQUEST_DURATION: Histogram = Histogram::with_opts(
        HistogramOpts::new(
            "http_request_duration_seconds",
            "HTTP request duration"
        )
    ).unwrap();
}

#[tokio::main]
async fn main() {
    let registry = Registry::new();
    registry.register(Box::new(HTTP_REQUESTS_TOTAL.clone())).unwrap();
    registry.register(Box::new(HTTP_REQUEST_DURATION.clone())).unwrap();
    
    let app = Router::new()
        .route("/metrics", get(metrics_handler))
        .route("/api/users", get(users_handler).layer(middleware::from_fn(metrics_middleware)));
    
    // ...
}

async fn metrics_middleware(req: Request, next: Next) -> Response {
    HTTP_REQUESTS_TOTAL.inc();
    
    let timer = HTTP_REQUEST_DURATION.start_timer();
    let response = next.run(req).await;
    timer.observe_duration();
    
    response
}

async fn metrics_handler() -> String {
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = vec![];
    encoder.encode(&metric_families, &mut buffer).unwrap();
    String::from_utf8(buffer).unwrap()
}
```

### 3.5.5.3 结构化日志

**Tracing 结构化日志**:

```rust
use tracing::{info, warn, error, debug};
use tracing_subscriber::{fmt, EnvFilter};

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .json()  // JSON 格式输出
        .init();
    
    process_request().await;
}

async fn process_request() {
    info!(
        user_id = 123,
        request_id = "req-456",
        "Processing user request"
    );
    
    if let Err(e) = perform_action().await {
        error!(
            error = %e,
            user_id = 123,
            "Action failed"
        );
    }
}
```

### 3.5.5.4 健康检查

**健康检查端点**:

```rust
use axum::{Router, routing::get, Json};
use serde::Serialize;

#[derive(Serialize)]
struct HealthStatus {
    status: String,
    database: String,
    redis: String,
}

async fn health_check(db: PgPool, redis: RedisPool) -> Json<HealthStatus> {
    let db_status = check_database(&db).await;
    let redis_status = check_redis(&redis).await;
    
    let overall_status = if db_status == "healthy" && redis_status == "healthy" {
        "healthy"
    } else {
        "unhealthy"
    };
    
    Json(HealthStatus {
        status: overall_status.to_string(),
        database: db_status,
        redis: redis_status,
    })
}

async fn check_database(db: &PgPool) -> String {
    match sqlx::query("SELECT 1").fetch_one(db).await {
        Ok(_) => "healthy".to_string(),
        Err(_) => "unhealthy".to_string(),
    }
}
```

---

## 3.5.6 缓存架构模式

### 3.5.6.1 Cache-Aside 模式

**流程**:

```text
1. 查询缓存
2. 缓存命中 → 返回
3. 缓存未命中 → 查询数据库
4. 写入缓存
5. 返回数据
```

**Rust 实现**:

```rust
use redis::AsyncCommands;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: i64,
    name: String,
    email: String,
}

async fn get_user_cache_aside(
    user_id: i64,
    redis: &mut redis::aio::Connection,
    db: &PgPool,
) -> Result<User, Error> {
    let cache_key = format!("user:{}", user_id);
    
    // 1. 查询缓存
    if let Some(cached) = redis.get::<_, Option<String>>(&cache_key).await? {
        let user: User = serde_json::from_str(&cached)?;
        return Ok(user);
    }
    
    // 2. 查询数据库
    let user = sqlx::query_as!(
        User,
        "SELECT id, name, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_one(db)
    .await?;
    
    // 3. 写入缓存
    let user_json = serde_json::to_string(&user)?;
    redis.set_ex(&cache_key, user_json, 3600).await?;  // TTL: 1小时
    
    Ok(user)
}
```

### 3.5.6.2 Read-Through / Write-Through

**Read-Through**:

```rust
pub struct CacheableRepository {
    cache: Arc<dyn Cache>,
    db: PgPool,
}

impl CacheableRepository {
    async fn get_user(&self, user_id: i64) -> Result<User, Error> {
        // Cache automatically loads from DB if miss
        self.cache
            .get_or_load(
                format!("user:{}", user_id),
                || self.load_user_from_db(user_id)
            )
            .await
    }
    
    async fn load_user_from_db(&self, user_id: i64) -> Result<User, Error> {
        sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", user_id)
            .fetch_one(&self.db)
            .await
    }
}
```

**Write-Through**:

```rust
async fn update_user_write_through(
    user: &User,
    redis: &mut redis::aio::Connection,
    db: &PgPool,
) -> Result<(), Error> {
    // 1. 写入数据库
    sqlx::query!(
        "UPDATE users SET name = $1, email = $2 WHERE id = $3",
        user.name,
        user.email,
        user.id
    )
    .execute(db)
    .await?;
    
    // 2. 更新缓存
    let cache_key = format!("user:{}", user.id);
    let user_json = serde_json::to_string(user)?;
    redis.set_ex(&cache_key, user_json, 3600).await?;
    
    Ok(())
}
```

### 3.5.6.3 多级缓存

**架构**:

```text
[Request] → [L1: Local Cache (moka)] → [L2: Redis] → [Database]
              ↓ 100μs                    ↓ 1ms         ↓ 10ms
```

**Rust 实现**:

```rust
use moka::future::Cache as LocalCache;
use redis::aio::Connection as RedisConn;

pub struct MultiLevelCache {
    l1: LocalCache<String, String>,  // 本地缓存
    redis: Arc<Mutex<RedisConn>>,    // 分布式缓存
    db: PgPool,                      // 数据库
}

impl MultiLevelCache {
    async fn get_user(&self, user_id: i64) -> Result<User, Error> {
        let key = format!("user:{}", user_id);
        
        // L1: 本地缓存
        if let Some(value) = self.l1.get(&key).await {
            return Ok(serde_json::from_str(&value)?);
        }
        
        // L2: Redis
        let mut redis = self.redis.lock().await;
        if let Some(value) = redis.get::<_, Option<String>>(&key).await? {
            // 回填 L1
            self.l1.insert(key.clone(), value.clone()).await;
            return Ok(serde_json::from_str(&value)?);
        }
        
        // L3: 数据库
        let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", user_id)
            .fetch_one(&self.db)
            .await?;
        
        // 回填 L1 和 L2
        let value = serde_json::to_string(&user)?;
        self.l1.insert(key.clone(), value.clone()).await;
        redis.set_ex(&key, value, 3600).await?;
        
        Ok(user)
    }
}
```

### 3.5.6.4 缓存一致性

**缓存失效策略**:

```rust
async fn update_user_with_cache_invalidation(
    user: &User,
    redis: &mut redis::aio::Connection,
    db: &PgPool,
) -> Result<(), Error> {
    // 1. 删除缓存 (先删除)
    let cache_key = format!("user:{}", user.id);
    redis.del(&cache_key).await?;
    
    // 2. 更新数据库
    sqlx::query!(
        "UPDATE users SET name = $1, email = $2 WHERE id = $3",
        user.name,
        user.email,
        user.id
    )
    .execute(db)
    .await?;
    
    // 3. 延迟双删 (防止脏数据)
    tokio::time::sleep(Duration::from_millis(100)).await;
    redis.del(&cache_key).await?;
    
    Ok(())
}
```

---

## 3.5.7 消息驱动架构

### 3.5.7.1 发布-订阅模式

**Kafka 实现**:

```rust
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::consumer::{Consumer, StreamConsumer};
use rdkafka::config::ClientConfig;

// 发布者
pub struct EventPublisher {
    producer: FutureProducer,
}

impl EventPublisher {
    pub async fn publish_event(&self, topic: &str, event: &Event) -> Result<(), Error> {
        let payload = serde_json::to_string(event)?;
        
        let record = FutureRecord::to(topic)
            .key(&event.aggregate_id)
            .payload(&payload);
        
        self.producer.send(record, Duration::from_secs(0)).await?;
        
        Ok(())
    }
}

// 订阅者
pub struct EventSubscriber {
    consumer: StreamConsumer,
}

impl EventSubscriber {
    pub async fn subscribe(&self, topics: &[&str]) -> Result<(), Error> {
        self.consumer.subscribe(topics)?;
        
        loop {
            match self.consumer.recv().await {
                Ok(message) => {
                    if let Some(payload) = message.payload() {
                        let event: Event = serde_json::from_slice(payload)?;
                        self.handle_event(event).await?;
                    }
                    
                    self.consumer.commit_message(&message, CommitMode::Async)?;
                }
                Err(e) => {
                    tracing::error!("Consumer error: {}", e);
                }
            }
        }
    }
    
    async fn handle_event(&self, event: Event) -> Result<(), Error> {
        match event.event_type {
            EventType::OrderCreated => { /* handle */ },
            EventType::OrderShipped => { /* handle */ },
            _ => {}
        }
        
        Ok(())
    }
}
```

### 3.5.7.2 事件驱动架构

**(Content continues with more patterns...)**-

---

## 3.5.10 反模式与陷阱

**常见反模式**:

1. ❌ **分布式单体**: 微服务但共享数据库
2. ❌ **过度拆分**: 服务粒度过细，通信开销大
3. ❌ **同步链路过长**: A → B → C → D (延迟累积)
4. ❌ **缺乏监控**: 分布式系统必须有全面监控
5. ❌ **忽略网络分区**: 未考虑网络故障场景

**最佳实践**:

1. ✅ **服务自治**: 每个服务拥有自己的数据库
2. ✅ **异步通信**: 优先使用消息队列
3. ✅ **幂等设计**: 所有操作应支持重试
4. ✅ **可观测性**: 日志、指标、追踪
5. ✅ **弹性设计**: 熔断、重试、降级

---

## 3.5.11 参考资源

**官方文档**:

- [Microservices Patterns](https://microservices.io/patterns/)
- [Rust Async Book](https://rust-lang.github.io/async-book/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)

**相关文档**:

- [3.3 库成熟度评估矩阵](3.3_库成熟度评估矩阵.md)
- [3.4 性能基准测试报告](3.4_性能基准测试报告.md)
- [2.4 Web 框架指南](../guides/2.4_Web框架指南.md)
- [2.5 异步运行时指南](../guides/2.5_异步运行时指南.md)

---

**报告完成时间**: 2025-10-21  
**文档版本**: v1.0  
**下次更新**: 2026-01-21  
**维护团队**: Rust 架构团队

---

**🎯 本文档为 Rust 系统架构设计提供全面指导！**
