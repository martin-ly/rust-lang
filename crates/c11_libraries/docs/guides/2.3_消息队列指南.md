# 2.3 Rust æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å— (2025)

> **æ–‡æ¡£å®šä½**: Rust æ¶ˆæ¯é˜Ÿåˆ—å®Œæ•´å®æˆ˜æŒ‡å—  
> **é€‚ç”¨äººç¾¤**: åç«¯å¼€å‘è€…ï¼Œåˆ†å¸ƒå¼ç³»ç»Ÿå·¥ç¨‹å¸ˆ  
> **å…³è”æ–‡æ¡£**: [3.2 å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾](../references/3.2_å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾.md) | [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](./2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md)

**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  
**æœ€åæ›´æ–°**: 2025-10-21

---

## ğŸ“‹ ç›®å½•

- [2.3 Rust æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å— (2025)](#23-rust-æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—-2025)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2.3.1 æ¦‚è¿°](#231-æ¦‚è¿°)
    - [2.3.1.1 ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—ï¼Ÿ](#2311-ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—)
    - [2.3.1.2 æ¶ˆæ¯é˜Ÿåˆ—æŠ€æœ¯æ ˆå¯¹æ¯”](#2312-æ¶ˆæ¯é˜Ÿåˆ—æŠ€æœ¯æ ˆå¯¹æ¯”)
  - [2.3.2 Kafka æ·±åº¦å®æˆ˜](#232-kafka-æ·±åº¦å®æˆ˜)
    - [2.3.2.1 é¡¹ç›®åˆå§‹åŒ–](#2321-é¡¹ç›®åˆå§‹åŒ–)
    - [2.3.2.2 ç”Ÿäº§è€…](#2322-ç”Ÿäº§è€…)
    - [2.3.2.3 æ¶ˆè´¹è€…](#2323-æ¶ˆè´¹è€…)
    - [2.3.2.4 é«˜çº§ç‰¹æ€§](#2324-é«˜çº§ç‰¹æ€§)
  - [2.3.3 RabbitMQ å®æˆ˜](#233-rabbitmq-å®æˆ˜)
    - [2.3.3.1 é¡¹ç›®åˆå§‹åŒ–](#2331-é¡¹ç›®åˆå§‹åŒ–)
    - [2.3.3.2 åŸºç¡€æ“ä½œ](#2332-åŸºç¡€æ“ä½œ)
    - [2.3.3.3 æ¶ˆæ¯æ¨¡å¼](#2333-æ¶ˆæ¯æ¨¡å¼)
    - [2.3.3.4 é«˜çº§ç‰¹æ€§](#2334-é«˜çº§ç‰¹æ€§)
  - [2.3.4 NATS å®æˆ˜](#234-nats-å®æˆ˜)
    - [2.3.4.1 é¡¹ç›®åˆå§‹åŒ–](#2341-é¡¹ç›®åˆå§‹åŒ–)
    - [2.3.4.2 åŸºç¡€æ“ä½œ](#2342-åŸºç¡€æ“ä½œ)
    - [2.3.4.3 JetStream](#2343-jetstream)
  - [2.3.5 æ¶ˆæ¯æ¨¡å¼](#235-æ¶ˆæ¯æ¨¡å¼)
    - [2.3.5.1 ç‚¹å¯¹ç‚¹æ¨¡å¼](#2351-ç‚¹å¯¹ç‚¹æ¨¡å¼)
    - [2.3.5.2 å‘å¸ƒè®¢é˜…æ¨¡å¼](#2352-å‘å¸ƒè®¢é˜…æ¨¡å¼)
    - [2.3.5.3 è¯·æ±‚å“åº”æ¨¡å¼](#2353-è¯·æ±‚å“åº”æ¨¡å¼)
  - [2.3.6 å¯é æ€§ä¿è¯](#236-å¯é æ€§ä¿è¯)
    - [2.3.6.1 æ¶ˆæ¯ç¡®è®¤](#2361-æ¶ˆæ¯ç¡®è®¤)
    - [2.3.6.2 äº‹åŠ¡æ”¯æŒ](#2362-äº‹åŠ¡æ”¯æŒ)
    - [2.3.6.3 æ­»ä¿¡é˜Ÿåˆ—](#2363-æ­»ä¿¡é˜Ÿåˆ—)
  - [2.3.7 æ€§èƒ½ä¼˜åŒ–](#237-æ€§èƒ½ä¼˜åŒ–)
    - [2.3.7.1 æ‰¹é‡å‘é€](#2371-æ‰¹é‡å‘é€)
    - [2.3.7.2 å¹¶å‘æ¶ˆè´¹](#2372-å¹¶å‘æ¶ˆè´¹)
    - [2.3.7.3 èƒŒå‹å¤„ç†](#2373-èƒŒå‹å¤„ç†)
  - [2.3.8 ç”Ÿäº§å®è·µ](#238-ç”Ÿäº§å®è·µ)
    - [2.3.8.1 ç›‘æ§å‘Šè­¦](#2381-ç›‘æ§å‘Šè­¦)
    - [2.3.8.2 å®¹é”™å¤„ç†](#2382-å®¹é”™å¤„ç†)
    - [2.3.8.3 å®¹é‡è§„åˆ’](#2383-å®¹é‡è§„åˆ’)
  - [2.3.9 æœ€ä½³å®è·µ](#239-æœ€ä½³å®è·µ)
    - [2.3.9.1 æ¶ˆæ¯è®¾è®¡](#2391-æ¶ˆæ¯è®¾è®¡)
    - [2.3.9.2 é”™è¯¯å¤„ç†](#2392-é”™è¯¯å¤„ç†)
    - [2.3.9.3 å®‰å…¨å®è·µ](#2393-å®‰å…¨å®è·µ)

---

## 2.3.1 æ¦‚è¿°

### 2.3.1.1 ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—ï¼Ÿ

**æ ¸å¿ƒä»·å€¼**:

1. âœ… **è§£è€¦** - æœåŠ¡é—´æ¾è€¦åˆï¼Œé™ä½ä¾èµ–
2. âœ… **å¼‚æ­¥** - éé˜»å¡å¤„ç†ï¼Œæé«˜å“åº”é€Ÿåº¦
3. âœ… **å‰Šå³°å¡«è°·** - åº”å¯¹æµé‡çªå‘
4. âœ… **å¯é æ€§** - æ¶ˆæ¯æŒä¹…åŒ–ï¼Œä¿è¯ä¸ä¸¢å¤±
5. âœ… **æ‰©å±•æ€§** - æ°´å¹³æ‰©å±•ï¼Œæé«˜ååé‡

**é€‚ç”¨åœºæ™¯**:

```mermaid
graph LR
    A[æ¶ˆæ¯é˜Ÿåˆ—åº”ç”¨åœºæ™¯] --> B[å¼‚æ­¥å¤„ç†]
    A --> C[æœåŠ¡è§£è€¦]
    A --> D[æµé‡å‰Šå³°]
    A --> E[æ—¥å¿—æ”¶é›†]
    A --> F[äº‹ä»¶é©±åŠ¨]
    
    B --> B1[é‚®ä»¶å‘é€]
    B --> B2[å›¾ç‰‡å¤„ç†]
    C --> C1[è®¢å•ç³»ç»Ÿ]
    C --> C2[åº“å­˜ç³»ç»Ÿ]
    D --> D1[ç§’æ€æ´»åŠ¨]
    D --> D2[å¤§ä¿ƒæ´»åŠ¨]
```

### 2.3.1.2 æ¶ˆæ¯é˜Ÿåˆ—æŠ€æœ¯æ ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ç±»å‹ | ç‰¹ç‚¹ | ååé‡ | å»¶è¿Ÿ | é€‚ç”¨åœºæ™¯ | æˆç†Ÿåº¦ |
|------|------|------|--------|------|----------|--------|
| **Kafka** | æ—¥å¿—å‹ | é«˜ååï¼ŒæŒä¹…åŒ– | â­â­â­â­â­ | 10ms | å¤§æ•°æ®ï¼Œæ—¥å¿— | â­â­â­â­â­ |
| **RabbitMQ** | AMQP | åŠŸèƒ½ä¸°å¯Œï¼Œçµæ´» | â­â­â­â­ | 1ms | é€šç”¨åœºæ™¯ | â­â­â­â­â­ |
| **NATS** | è½»é‡çº§ | ä½å»¶è¿Ÿï¼Œç®€å• | â­â­â­â­ | <1ms | å¾®æœåŠ¡ | â­â­â­â­ |
| **Pulsar** | äº‘åŸç”Ÿ | å¤šç§Ÿæˆ·ï¼Œåœ°åŸŸå¤åˆ¶ | â­â­â­â­â­ | 5ms | äº‘å¹³å° | â­â­â­â­ |

---

## 2.3.2 Kafka æ·±åº¦å®æˆ˜

### 2.3.2.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# Kafka å®¢æˆ·ç«¯
rdkafka = { version = "0.37", features = [
    "tokio",           # Tokio å¼‚æ­¥æ”¯æŒ
    "cmake-build",     # CMake æ„å»º
    "ssl",             # SSL/TLS æ”¯æŒ
    "sasl",            # SASL è®¤è¯
] }

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.48", features = ["full"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "2.0"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = "0.3"
```

**é…ç½®ç»“æ„**:

```rust
use rdkafka::ClientConfig;

pub struct KafkaConfig {
    pub brokers: String,
    pub group_id: String,
    pub security_protocol: Option<String>,
    pub sasl_mechanism: Option<String>,
    pub sasl_username: Option<String>,
    pub sasl_password: Option<String>,
}

impl Default for KafkaConfig {
    fn default() -> Self {
        Self {
            brokers: "localhost:9092".to_string(),
            group_id: "my-consumer-group".to_string(),
            security_protocol: None,
            sasl_mechanism: None,
            sasl_username: None,
            sasl_password: None,
        }
    }
}

impl KafkaConfig {
    pub fn to_client_config(&self) -> ClientConfig {
        let mut config = ClientConfig::new();
        config.set("bootstrap.servers", &self.brokers);
        config.set("group.id", &self.group_id);
        
        if let Some(protocol) = &self.security_protocol {
            config.set("security.protocol", protocol);
        }
        
        if let Some(mechanism) = &self.sasl_mechanism {
            config.set("sasl.mechanism", mechanism);
        }
        
        if let Some(username) = &self.sasl_username {
            config.set("sasl.username", username);
        }
        
        if let Some(password) = &self.sasl_password {
            config.set("sasl.password", password);
        }
        
        config
    }
}
```

### 2.3.2.2 ç”Ÿäº§è€…

**åŸºç¡€ç”Ÿäº§è€…**:

```rust
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::util::Timeout;
use std::time::Duration;

pub struct KafkaProducer {
    producer: FutureProducer,
}

impl KafkaProducer {
    pub fn new(config: &KafkaConfig) -> Result<Self, anyhow::Error> {
        let producer: FutureProducer = config
            .to_client_config()
            .set("message.timeout.ms", "5000")
            .set("compression.type", "snappy")
            .create()?;
        
        Ok(Self { producer })
    }
    
    // å‘é€æ¶ˆæ¯
    pub async fn send_message(
        &self,
        topic: &str,
        key: Option<&str>,
        payload: &str,
    ) -> Result<(i32, i64), anyhow::Error> {
        let record = FutureRecord::to(topic)
            .key(key.unwrap_or(""))
            .payload(payload);
        
        let delivery_status = self.producer
            .send(record, Timeout::After(Duration::from_secs(5)))
            .await;
        
        match delivery_status {
            Ok((partition, offset)) => {
                tracing::info!(
                    topic = topic,
                    partition = partition,
                    offset = offset,
                    "Message sent"
                );
                Ok((partition, offset))
            }
            Err((e, _)) => {
                tracing::error!(error = ?e, "Failed to send message");
                Err(e.into())
            }
        }
    }
    
    // å‘é€ç»“æ„åŒ–æ¶ˆæ¯
    pub async fn send_json<T: serde::Serialize>(
        &self,
        topic: &str,
        key: Option<&str>,
        data: &T,
    ) -> Result<(i32, i64), anyhow::Error> {
        let payload = serde_json::to_string(data)?;
        self.send_message(topic, key, &payload).await
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct OrderEvent {
    pub order_id: String,
    pub user_id: u64,
    pub amount: f64,
    pub timestamp: i64,
}

pub async fn producer_example() -> Result<(), anyhow::Error> {
    let config = KafkaConfig::default();
    let producer = KafkaProducer::new(&config)?;
    
    let event = OrderEvent {
        order_id: "ORD-12345".to_string(),
        user_id: 1001,
        amount: 99.99,
        timestamp: chrono::Utc::now().timestamp(),
    };
    
    let (partition, offset) = producer
        .send_json("orders", Some("ORD-12345"), &event)
        .await?;
    
    println!("Sent to partition {} at offset {}", partition, offset);
    
    Ok(())
}
```

### 2.3.2.3 æ¶ˆè´¹è€…

**åŸºç¡€æ¶ˆè´¹è€…**:

```rust
use rdkafka::consumer::{Consumer, StreamConsumer};
use rdkafka::Message;
use futures::StreamExt;

pub struct KafkaConsumer {
    consumer: StreamConsumer,
}

impl KafkaConsumer {
    pub fn new(config: &KafkaConfig, topics: &[&str]) -> Result<Self, anyhow::Error> {
        let consumer: StreamConsumer = config
            .to_client_config()
            .set("enable.auto.commit", "true")
            .set("auto.commit.interval.ms", "5000")
            .set("session.timeout.ms", "6000")
            .set("auto.offset.reset", "earliest")
            .create()?;
        
        consumer.subscribe(topics)?;
        
        Ok(Self { consumer })
    }
    
    // æ¶ˆè´¹æ¶ˆæ¯
    pub async fn consume<F>(&self, mut handler: F) -> Result<(), anyhow::Error>
    where
        F: FnMut(&str, Option<&str>, &[u8]) -> Result<(), anyhow::Error>,
    {
        let mut stream = self.consumer.stream();
        
        while let Some(message) = stream.next().await {
            match message {
                Ok(m) => {
                    let topic = m.topic();
                    let key = m.key().map(|k| std::str::from_utf8(k).unwrap_or(""));
                    let payload = m.payload().unwrap_or(&[]);
                    
                    if let Err(e) = handler(topic, key, payload) {
                        tracing::error!(
                            error = ?e,
                            topic = topic,
                            "Failed to process message"
                        );
                    }
                }
                Err(e) => {
                    tracing::error!(error = ?e, "Kafka error");
                }
            }
        }
        
        Ok(())
    }
    
    // æ¶ˆè´¹ JSON æ¶ˆæ¯
    pub async fn consume_json<T, F>(&self, mut handler: F) -> Result<(), anyhow::Error>
    where
        T: for<'de> Deserialize<'de>,
        F: FnMut(T) -> Result<(), anyhow::Error>,
    {
        self.consume(|_topic, _key, payload| {
            let data: T = serde_json::from_slice(payload)?;
            handler(data)
        }).await
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
pub async fn consumer_example() -> Result<(), anyhow::Error> {
    let config = KafkaConfig::default();
    let consumer = KafkaConsumer::new(&config, &["orders"])?;
    
    consumer.consume_json::<OrderEvent, _>(|event| {
        println!("Received order: {:?}", event);
        
        // å¤„ç†è®¢å•
        process_order(&event)?;
        
        Ok(())
    }).await?;
    
    Ok(())
}

fn process_order(event: &OrderEvent) -> Result<(), anyhow::Error> {
    // ä¸šåŠ¡é€»è¾‘
    println!("Processing order {}", event.order_id);
    Ok(())
}
```

### 2.3.2.4 é«˜çº§ç‰¹æ€§

**æ‰‹åŠ¨æäº¤åç§»é‡**:

```rust
use rdkafka::consumer::{CommitMode, Consumer};

pub async fn manual_commit_example(
    config: &KafkaConfig,
) -> Result<(), anyhow::Error> {
    let consumer: StreamConsumer = config
        .to_client_config()
        .set("enable.auto.commit", "false")  // ç¦ç”¨è‡ªåŠ¨æäº¤
        .create()?;
    
    consumer.subscribe(&["orders"])?;
    
    let mut stream = consumer.stream();
    
    while let Some(message) = stream.next().await {
        match message {
            Ok(m) => {
                // å¤„ç†æ¶ˆæ¯
                let payload = m.payload().unwrap_or(&[]);
                process_message(payload)?;
                
                // æ‰‹åŠ¨æäº¤åç§»é‡
                consumer.commit_message(&m, CommitMode::Async)?;
            }
            Err(e) => {
                tracing::error!(error = ?e, "Kafka error");
            }
        }
    }
    
    Ok(())
}

fn process_message(payload: &[u8]) -> Result<(), anyhow::Error> {
    // å¤„ç†é€»è¾‘
    Ok(())
}
```

**äº‹åŠ¡ç”Ÿäº§è€…**:

```rust
use rdkafka::producer::FutureProducer;

pub async fn transactional_producer_example() -> Result<(), anyhow::Error> {
    let producer: FutureProducer = ClientConfig::new()
        .set("bootstrap.servers", "localhost:9092")
        .set("transactional.id", "my-transactional-id")
        .create()?;
    
    // åˆå§‹åŒ–äº‹åŠ¡
    producer.init_transactions(Timeout::After(Duration::from_secs(5)))?;
    
    // å¼€å§‹äº‹åŠ¡
    producer.begin_transaction()?;
    
    // å‘é€æ¶ˆæ¯
    for i in 0..10 {
        let record = FutureRecord::to("orders")
            .key(&format!("key-{}", i))
            .payload(&format!("value-{}", i));
        
        producer.send(record, Timeout::Never).await?;
    }
    
    // æäº¤äº‹åŠ¡
    producer.commit_transaction(Timeout::After(Duration::from_secs(5)))?;
    
    Ok(())
}
```

**åˆ†åŒºç®¡ç†**:

```rust
use rdkafka::producer::FutureRecord;

pub async fn partition_example(
    producer: &FutureProducer,
) -> Result<(), anyhow::Error> {
    // å‘é€åˆ°æŒ‡å®šåˆ†åŒº
    let record = FutureRecord::to("orders")
        .partition(0)  // æŒ‡å®šåˆ†åŒº 0
        .key("key")
        .payload("value");
    
    producer.send(record, Timeout::Never).await?;
    
    Ok(())
}
```

---

## 2.3.3 RabbitMQ å®æˆ˜

### 2.3.3.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# RabbitMQ å®¢æˆ·ç«¯
lapin = "2.5"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.48", features = ["full"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "2.0"

# æ—¥å¿—
tracing = "0.1"
```

**è¿æ¥é…ç½®**:

```rust
use lapin::{Connection, ConnectionProperties, Channel};

pub struct RabbitMQConfig {
    pub url: String,
}

impl Default for RabbitMQConfig {
    fn default() -> Self {
        Self {
            url: "amqp://guest:guest@localhost:5672/%2f".to_string(),
        }
    }
}

pub async fn create_connection(
    config: &RabbitMQConfig,
) -> Result<Connection, anyhow::Error> {
    let conn = Connection::connect(
        &config.url,
        ConnectionProperties::default(),
    ).await?;
    
    Ok(conn)
}

pub async fn create_channel(
    conn: &Connection,
) -> Result<Channel, anyhow::Error> {
    let channel = conn.create_channel().await?;
    Ok(channel)
}
```

### 2.3.3.2 åŸºç¡€æ“ä½œ

**å£°æ˜é˜Ÿåˆ—å’Œäº¤æ¢å™¨**:

```rust
use lapin::{
    options::*,
    types::FieldTable,
    ExchangeKind,
};

pub async fn declare_queue(
    channel: &Channel,
    queue_name: &str,
) -> Result<(), anyhow::Error> {
    channel.queue_declare(
        queue_name,
        QueueDeclareOptions {
            durable: true,      // æŒä¹…åŒ–
            exclusive: false,   // éç‹¬å 
            auto_delete: false, // ä¸è‡ªåŠ¨åˆ é™¤
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    Ok(())
}

pub async fn declare_exchange(
    channel: &Channel,
    exchange_name: &str,
    exchange_kind: ExchangeKind,
) -> Result<(), anyhow::Error> {
    channel.exchange_declare(
        exchange_name,
        exchange_kind,
        ExchangeDeclareOptions {
            durable: true,
            auto_delete: false,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    Ok(())
}

pub async fn bind_queue(
    channel: &Channel,
    queue_name: &str,
    exchange_name: &str,
    routing_key: &str,
) -> Result<(), anyhow::Error> {
    channel.queue_bind(
        queue_name,
        exchange_name,
        routing_key,
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    Ok(())
}
```

**å‘å¸ƒæ¶ˆæ¯**:

```rust
use lapin::BasicProperties;

pub async fn publish_message(
    channel: &Channel,
    exchange: &str,
    routing_key: &str,
    payload: &[u8],
) -> Result<(), anyhow::Error> {
    channel.basic_publish(
        exchange,
        routing_key,
        BasicPublishOptions::default(),
        payload,
        BasicProperties::default()
            .with_delivery_mode(2)  // æŒä¹…åŒ–æ¶ˆæ¯
            .with_content_type("application/json".into()),
    ).await?;
    
    Ok(())
}

pub async fn publish_json<T: serde::Serialize>(
    channel: &Channel,
    exchange: &str,
    routing_key: &str,
    data: &T,
) -> Result<(), anyhow::Error> {
    let payload = serde_json::to_vec(data)?;
    publish_message(channel, exchange, routing_key, &payload).await
}
```

**æ¶ˆè´¹æ¶ˆæ¯**:

```rust
use lapin::Consumer;
use futures::StreamExt;

pub async fn consume_messages(
    channel: &Channel,
    queue_name: &str,
) -> Result<(), anyhow::Error> {
    let mut consumer = channel.basic_consume(
        queue_name,
        "my-consumer",
        BasicConsumeOptions::default(),
        FieldTable::default(),
    ).await?;
    
    while let Some(delivery) = consumer.next().await {
        match delivery {
            Ok(delivery) => {
                let payload = &delivery.data;
                
                // å¤„ç†æ¶ˆæ¯
                match process_message(payload) {
                    Ok(_) => {
                        // ç¡®è®¤æ¶ˆæ¯
                        delivery.ack(BasicAckOptions::default()).await?;
                    }
                    Err(e) => {
                        tracing::error!(error = ?e, "Failed to process message");
                        // æ‹’ç»æ¶ˆæ¯å¹¶é‡æ–°å…¥é˜Ÿ
                        delivery.nack(BasicNackOptions {
                            requeue: true,
                            ..Default::default()
                        }).await?;
                    }
                }
            }
            Err(e) => {
                tracing::error!(error = ?e, "Consumer error");
            }
        }
    }
    
    Ok(())
}

fn process_message(payload: &[u8]) -> Result<(), anyhow::Error> {
    // å¤„ç†é€»è¾‘
    Ok(())
}
```

### 2.3.3.3 æ¶ˆæ¯æ¨¡å¼

**å·¥ä½œé˜Ÿåˆ— (Work Queue)**:

```rust
pub async fn work_queue_pattern(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let queue = "task_queue";
    
    // å£°æ˜é˜Ÿåˆ—
    channel.queue_declare(
        queue,
        QueueDeclareOptions {
            durable: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // QoS è®¾ç½® (æ¯æ¬¡åªæ¶ˆè´¹ 1 æ¡æ¶ˆæ¯)
    channel.basic_qos(
        1,
        BasicQosOptions::default(),
    ).await?;
    
    Ok(())
}
```

**å‘å¸ƒè®¢é˜… (Pub/Sub)**:

```rust
pub async fn pubsub_pattern(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let exchange = "logs";
    
    // å£°æ˜ fanout äº¤æ¢å™¨
    channel.exchange_declare(
        exchange,
        ExchangeKind::Fanout,
        ExchangeDeclareOptions {
            durable: false,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // å£°æ˜ä¸´æ—¶é˜Ÿåˆ—
    let queue = channel.queue_declare(
        "",
        QueueDeclareOptions {
            exclusive: true,
            auto_delete: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢å™¨
    channel.queue_bind(
        queue.name().as_str(),
        exchange,
        "",
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    Ok(())
}
```

**è·¯ç”±æ¨¡å¼ (Routing)**:

```rust
pub async fn routing_pattern(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let exchange = "direct_logs";
    
    // å£°æ˜ direct äº¤æ¢å™¨
    channel.exchange_declare(
        exchange,
        ExchangeKind::Direct,
        ExchangeDeclareOptions {
            durable: false,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // æ ¹æ®è·¯ç”±é”®ç»‘å®š
    let queue = "error_logs";
    channel.queue_bind(
        queue,
        exchange,
        "error",  // åªæ¥æ”¶ error çº§åˆ«çš„æ¶ˆæ¯
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    Ok(())
}
```

**ä¸»é¢˜æ¨¡å¼ (Topic)**:

```rust
pub async fn topic_pattern(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let exchange = "topic_logs";
    
    // å£°æ˜ topic äº¤æ¢å™¨
    channel.exchange_declare(
        exchange,
        ExchangeKind::Topic,
        ExchangeDeclareOptions {
            durable: false,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // ä½¿ç”¨é€šé…ç¬¦ç»‘å®š
    // * åŒ¹é…ä¸€ä¸ªå•è¯
    // # åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå•è¯
    channel.queue_bind(
        "critical_queue",
        exchange,
        "*.critical.*",  // åŒ¹é… user.critical.login ç­‰
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    Ok(())
}
```

### 2.3.3.4 é«˜çº§ç‰¹æ€§

**æ­»ä¿¡é˜Ÿåˆ— (DLX)**:

```rust
pub async fn setup_dlx(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let main_queue = "main_queue";
    let dlx_exchange = "dlx_exchange";
    let dlx_queue = "dlx_queue";
    
    // 1. å£°æ˜æ­»ä¿¡äº¤æ¢å™¨
    channel.exchange_declare(
        dlx_exchange,
        ExchangeKind::Direct,
        ExchangeDeclareOptions {
            durable: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // 2. å£°æ˜æ­»ä¿¡é˜Ÿåˆ—
    channel.queue_declare(
        dlx_queue,
        QueueDeclareOptions {
            durable: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // 3. ç»‘å®šæ­»ä¿¡é˜Ÿåˆ—
    channel.queue_bind(
        dlx_queue,
        dlx_exchange,
        "",
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    // 4. å£°æ˜ä¸»é˜Ÿåˆ—å¹¶è®¾ç½® DLX
    let mut args = FieldTable::default();
    args.insert("x-dead-letter-exchange".into(), dlx_exchange.into());
    
    channel.queue_declare(
        main_queue,
        QueueDeclareOptions {
            durable: true,
            ..Default::default()
        },
        args,
    ).await?;
    
    Ok(())
}
```

**æ¶ˆæ¯ TTL**:

```rust
pub async fn message_ttl_example(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    // å‘é€å¸¦ TTL çš„æ¶ˆæ¯
    channel.basic_publish(
        "",
        "my_queue",
        BasicPublishOptions::default(),
        b"message",
        BasicProperties::default()
            .with_expiration("60000".into()),  // 60 ç§’è¿‡æœŸ
    ).await?;
    
    Ok(())
}
```

---

## 2.3.4 NATS å®æˆ˜

### 2.3.4.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# NATS å®¢æˆ·ç«¯
async-nats = "0.37"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.48", features = ["full"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
```

**è¿æ¥é…ç½®**:

```rust
use async_nats::Client;

pub async fn create_nats_client() -> Result<Client, anyhow::Error> {
    let client = async_nats::connect("nats://localhost:4222").await?;
    Ok(client)
}
```

### 2.3.4.2 åŸºç¡€æ“ä½œ

**å‘å¸ƒè®¢é˜…**:

```rust
pub async fn publish_example(
    client: &Client,
) -> Result<(), anyhow::Error> {
    // å‘å¸ƒæ¶ˆæ¯
    client.publish("subject", "Hello, NATS!".into()).await?;
    
    Ok(())
}

pub async fn subscribe_example(
    client: &Client,
) -> Result<(), anyhow::Error> {
    let mut subscriber = client.subscribe("subject").await?;
    
    while let Some(message) = subscriber.next().await {
        let payload = String::from_utf8_lossy(&message.payload);
        println!("Received: {}", payload);
    }
    
    Ok(())
}
```

**è¯·æ±‚å“åº”**:

```rust
use std::time::Duration;

pub async fn request_reply_example(
    client: &Client,
) -> Result<(), anyhow::Error> {
    // è¯·æ±‚ç«¯
    let response = client
        .request("help", "need help".into())
        .await?;
    
    println!("Response: {:?}", response.payload);
    
    Ok(())
}

pub async fn reply_handler(
    client: &Client,
) -> Result<(), anyhow::Error> {
    // å“åº”ç«¯
    let mut subscriber = client.subscribe("help").await?;
    
    while let Some(message) = subscriber.next().await {
        if let Some(reply) = message.reply {
            client.publish(reply, "I can help!".into()).await?;
        }
    }
    
    Ok(())
}
```

**é˜Ÿåˆ—ç»„**:

```rust
pub async fn queue_group_example(
    client: &Client,
) -> Result<(), anyhow::Error> {
    // å¤šä¸ªæ¶ˆè´¹è€…å…±äº«å·¥ä½œè´Ÿè½½
    let mut subscriber = client
        .queue_subscribe("tasks", "workers".to_string())
        .await?;
    
    while let Some(message) = subscriber.next().await {
        println!("Worker processing: {:?}", message.payload);
    }
    
    Ok(())
}
```

### 2.3.4.3 JetStream

**å¯ç”¨ JetStream**:

```rust
use async_nats::jetstream;

pub async fn jetstream_example(
    client: &Client,
) -> Result<(), anyhow::Error> {
    let jetstream = jetstream::new(client.clone());
    
    // åˆ›å»º Stream
    let _stream = jetstream
        .create_stream(jetstream::stream::Config {
            name: "ORDERS".to_string(),
            subjects: vec!["orders.*".to_string()],
            max_messages: 10_000,
            ..Default::default()
        })
        .await?;
    
    // å‘å¸ƒæ¶ˆæ¯
    let ack = jetstream
        .publish("orders.new", "order data".into())
        .await?;
    
    println!("Published to sequence: {}", ack.await?.sequence);
    
    Ok(())
}
```

**æŒä¹…åŒ–æ¶ˆè´¹è€…**:

```rust
pub async fn durable_consumer_example(
    client: &Client,
) -> Result<(), anyhow::Error> {
    let jetstream = jetstream::new(client.clone());
    
    // åˆ›å»ºæŒä¹…åŒ–æ¶ˆè´¹è€…
    let consumer = jetstream
        .create_consumer_on_stream(
            jetstream::consumer::Config {
                durable_name: Some("order_processor".to_string()),
                ack_policy: jetstream::consumer::AckPolicy::Explicit,
                ..Default::default()
            },
            "ORDERS",
        )
        .await?;
    
    let mut messages = consumer.messages().await?;
    
    while let Some(message) = messages.next().await {
        let message = message?;
        
        // å¤„ç†æ¶ˆæ¯
        println!("Processing: {:?}", message.payload);
        
        // ç¡®è®¤æ¶ˆæ¯
        message.ack().await?;
    }
    
    Ok(())
}
```

---

## 2.3.5 æ¶ˆæ¯æ¨¡å¼

### 2.3.5.1 ç‚¹å¯¹ç‚¹æ¨¡å¼

**ç‰¹ç‚¹**:

- æ¯æ¡æ¶ˆæ¯åªè¢«ä¸€ä¸ªæ¶ˆè´¹è€…å¤„ç†
- æ¶ˆè´¹è€…ç«äº‰è·å–æ¶ˆæ¯
- é€‚åˆä»»åŠ¡åˆ†å‘åœºæ™¯

**å®ç°** (Kafka):

```rust
pub async fn point_to_point_kafka() -> Result<(), anyhow::Error> {
    let config = KafkaConfig {
        group_id: "task-workers".to_string(),
        ..Default::default()
    };
    
    let consumer = KafkaConsumer::new(&config, &["tasks"])?;
    
    consumer.consume(|_topic, _key, payload| {
        // åªæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…ä¼šå¤„ç†è¿™æ¡æ¶ˆæ¯
        process_task(payload)?;
        Ok(())
    }).await?;
    
    Ok(())
}

fn process_task(payload: &[u8]) -> Result<(), anyhow::Error> {
    // å¤„ç†ä»»åŠ¡
    Ok(())
}
```

### 2.3.5.2 å‘å¸ƒè®¢é˜…æ¨¡å¼

**ç‰¹ç‚¹**:

- æ¯æ¡æ¶ˆæ¯è¢«æ‰€æœ‰è®¢é˜…è€…æ¥æ”¶
- è®¢é˜…è€…ç‹¬ç«‹å¤„ç†
- é€‚åˆäº‹ä»¶é€šçŸ¥åœºæ™¯

**å®ç°** (RabbitMQ):

```rust
pub async fn publish_subscribe_rabbitmq(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let exchange = "events";
    
    // å‘å¸ƒè€…
    channel.exchange_declare(
        exchange,
        ExchangeKind::Fanout,
        ExchangeDeclareOptions::default(),
        FieldTable::default(),
    ).await?;
    
    // è®¢é˜…è€… 1: é‚®ä»¶æœåŠ¡
    let queue1 = channel.queue_declare(
        "",
        QueueDeclareOptions {
            exclusive: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    channel.queue_bind(
        queue1.name().as_str(),
        exchange,
        "",
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    // è®¢é˜…è€… 2: çŸ­ä¿¡æœåŠ¡
    let queue2 = channel.queue_declare(
        "",
        QueueDeclareOptions {
            exclusive: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    channel.queue_bind(
        queue2.name().as_str(),
        exchange,
        "",
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    Ok(())
}
```

### 2.3.5.3 è¯·æ±‚å“åº”æ¨¡å¼

**ç‰¹ç‚¹**:

- åŒæ­¥è°ƒç”¨è¯­ä¹‰
- éœ€è¦å“åº”é˜Ÿåˆ—
- é€‚åˆ RPC åœºæ™¯

**å®ç°** (NATS):

```rust
pub async fn request_response_nats(
    client: &Client,
) -> Result<(), anyhow::Error> {
    // æœåŠ¡ç«¯
    tokio::spawn({
        let client = client.clone();
        async move {
            let mut subscriber = client.subscribe("rpc.add").await.unwrap();
            
            while let Some(message) = subscriber.next().await {
                if let Some(reply) = message.reply {
                    // å¤„ç†è¯·æ±‚
                    let result = "result";
                    client.publish(reply, result.into()).await.unwrap();
                }
            }
        }
    });
    
    // å®¢æˆ·ç«¯
    let response = client
        .request("rpc.add", "1 + 1".into())
        .await?;
    
    println!("Result: {:?}", response.payload);
    
    Ok(())
}
```

---

## 2.3.6 å¯é æ€§ä¿è¯

### 2.3.6.1 æ¶ˆæ¯ç¡®è®¤

**ç”Ÿäº§è€…ç¡®è®¤** (Kafka):

```rust
pub async fn producer_acks_example() -> Result<(), anyhow::Error> {
    let producer: FutureProducer = ClientConfig::new()
        .set("bootstrap.servers", "localhost:9092")
        .set("acks", "all")  // ç­‰å¾…æ‰€æœ‰å‰¯æœ¬ç¡®è®¤
        .create()?;
    
    let record = FutureRecord::to("orders")
        .key("key")
        .payload("value");
    
    // ç­‰å¾…ç¡®è®¤
    let (partition, offset) = producer
        .send(record, Timeout::After(Duration::from_secs(5)))
        .await
        .map_err(|(e, _)| e)?;
    
    println!("Confirmed: partition={}, offset={}", partition, offset);
    
    Ok(())
}
```

**æ¶ˆè´¹è€…ç¡®è®¤** (RabbitMQ):

```rust
pub async fn consumer_acks_example(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let mut consumer = channel.basic_consume(
        "orders",
        "",
        BasicConsumeOptions {
            no_ack: false,  // éœ€è¦æ‰‹åŠ¨ç¡®è®¤
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    while let Some(delivery) = consumer.next().await {
        match delivery {
            Ok(delivery) => {
                // å¤„ç†æˆåŠŸ,ç¡®è®¤æ¶ˆæ¯
                if process_message(&delivery.data).is_ok() {
                    delivery.ack(BasicAckOptions::default()).await?;
                } else {
                    // å¤„ç†å¤±è´¥,æ‹’ç»å¹¶é‡æ–°å…¥é˜Ÿ
                    delivery.nack(BasicNackOptions {
                        requeue: true,
                        ..Default::default()
                    }).await?;
                }
            }
            Err(e) => {
                tracing::error!(error = ?e, "Consumer error");
            }
        }
    }
    
    Ok(())
}
```

### 2.3.6.2 äº‹åŠ¡æ”¯æŒ

**Kafka äº‹åŠ¡**:

```rust
pub async fn kafka_transaction() -> Result<(), anyhow::Error> {
    let producer: FutureProducer = ClientConfig::new()
        .set("bootstrap.servers", "localhost:9092")
        .set("transactional.id", "txn-1")
        .create()?;
    
    producer.init_transactions(Timeout::After(Duration::from_secs(5)))?;
    producer.begin_transaction()?;
    
    // å‘é€å¤šæ¡æ¶ˆæ¯
    for i in 0..10 {
        let record = FutureRecord::to("orders")
            .payload(&format!("message-{}", i));
        producer.send(record, Timeout::Never).await?;
    }
    
    // æäº¤äº‹åŠ¡
    producer.commit_transaction(Timeout::After(Duration::from_secs(5)))?;
    
    Ok(())
}
```

### 2.3.6.3 æ­»ä¿¡é˜Ÿåˆ—

**RabbitMQ DLQ**:

```rust
pub async fn setup_dlq(
    channel: &Channel,
) -> Result<(), anyhow::Error> {
    let main_queue = "orders";
    let dlq = "orders_dlq";
    let dlx = "dlx";
    
    // 1. åˆ›å»ºæ­»ä¿¡äº¤æ¢å™¨
    channel.exchange_declare(
        dlx,
        ExchangeKind::Direct,
        ExchangeDeclareOptions {
            durable: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    // 2. åˆ›å»ºæ­»ä¿¡é˜Ÿåˆ—
    channel.queue_declare(
        dlq,
        QueueDeclareOptions {
            durable: true,
            ..Default::default()
        },
        FieldTable::default(),
    ).await?;
    
    channel.queue_bind(
        dlq,
        dlx,
        "",
        QueueBindOptions::default(),
        FieldTable::default(),
    ).await?;
    
    // 3. åˆ›å»ºä¸»é˜Ÿåˆ—å¹¶é…ç½® DLX
    let mut args = FieldTable::default();
    args.insert("x-dead-letter-exchange".into(), dlx.into());
    
    channel.queue_declare(
        main_queue,
        QueueDeclareOptions {
            durable: true,
            ..Default::default()
        },
        args,
    ).await?;
    
    Ok(())
}
```

---

## 2.3.7 æ€§èƒ½ä¼˜åŒ–

### 2.3.7.1 æ‰¹é‡å‘é€

**Kafka æ‰¹é‡ç”Ÿäº§**:

```rust
pub async fn batch_send_kafka(
    producer: &FutureProducer,
    messages: Vec<String>,
) -> Result<(), anyhow::Error> {
    let mut futures = Vec::new();
    
    for msg in messages {
        let record = FutureRecord::to("orders").payload(&msg);
        let future = producer.send(record, Timeout::Never);
        futures.push(future);
    }
    
    // ç­‰å¾…æ‰€æœ‰æ¶ˆæ¯å‘é€å®Œæˆ
    for future in futures {
        future.await?;
    }
    
    Ok(())
}
```

### 2.3.7.2 å¹¶å‘æ¶ˆè´¹

**å¤šçº¿ç¨‹æ¶ˆè´¹**:

```rust
use tokio::task::JoinSet;

pub async fn concurrent_consume(
    config: &KafkaConfig,
    num_workers: usize,
) -> Result<(), anyhow::Error> {
    let mut set = JoinSet::new();
    
    for i in 0..num_workers {
        let config = config.clone();
        set.spawn(async move {
            let consumer = KafkaConsumer::new(&config, &["orders"]).unwrap();
            
            consumer.consume(|_topic, _key, payload| {
                println!("Worker {} processing message", i);
                process_message(payload)?;
                Ok(())
            }).await.unwrap();
        });
    }
    
    while let Some(res) = set.join_next().await {
        res?;
    }
    
    Ok(())
}
```

### 2.3.7.3 èƒŒå‹å¤„ç†

**æµé‡æ§åˆ¶**:

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

pub async fn backpressure_example(
    consumer: &KafkaConsumer,
) -> Result<(), anyhow::Error> {
    let semaphore = Arc::new(Semaphore::new(10)); // æœ€å¤šå¹¶å‘å¤„ç† 10 æ¡æ¶ˆæ¯
    
    consumer.consume(|_topic, _key, payload| {
        let semaphore = semaphore.clone();
        
        tokio::spawn(async move {
            let _permit = semaphore.acquire().await.unwrap();
            
            // å¤„ç†æ¶ˆæ¯
            process_message(payload).unwrap();
        });
        
        Ok(())
    }).await?;
    
    Ok(())
}
```

---

## 2.3.8 ç”Ÿäº§å®è·µ

### 2.3.8.1 ç›‘æ§å‘Šè­¦

**Kafka ç›‘æ§**:

```rust
use rdkafka::statistics::Statistics;

pub async fn kafka_monitoring(
    consumer: &StreamConsumer,
) -> Result<(), anyhow::Error> {
    // è·å–ç»Ÿè®¡ä¿¡æ¯
    consumer.context();
    
    // è®°å½•æŒ‡æ ‡
    tracing::info!(
        consumer_group = "my-group",
        "Consumer lag and metrics"
    );
    
    Ok(())
}
```

### 2.3.8.2 å®¹é”™å¤„ç†

**é‡è¯•æœºåˆ¶**:

```rust
pub async fn retry_mechanism(
    producer: &FutureProducer,
    message: &str,
    max_retries: u32,
) -> Result<(), anyhow::Error> {
    let mut retries = 0;
    
    loop {
        let record = FutureRecord::to("orders").payload(message);
        
        match producer.send(record, Timeout::After(Duration::from_secs(5))).await {
            Ok(_) => break,
            Err((e, _)) => {
                retries += 1;
                if retries >= max_retries {
                    return Err(e.into());
                }
                
                tracing::warn!(retries = retries, "Retrying send");
                tokio::time::sleep(Duration::from_secs(2_u64.pow(retries))).await;
            }
        }
    }
    
    Ok(())
}
```

### 2.3.8.3 å®¹é‡è§„åˆ’

**ååé‡ä¼°ç®—**:

```rust
pub fn estimate_throughput(
    msg_size_kb: f64,
    msg_per_sec: f64,
) -> f64 {
    // ä¼°ç®—å¸¦å®½éœ€æ±‚ (MB/s)
    msg_size_kb * msg_per_sec / 1024.0
}

pub fn estimate_storage(
    msg_size_kb: f64,
    msg_per_sec: f64,
    retention_days: u32,
) -> f64 {
    // ä¼°ç®—å­˜å‚¨éœ€æ±‚ (GB)
    let daily_volume = msg_size_kb * msg_per_sec * 86400.0 / (1024.0 * 1024.0);
    daily_volume * retention_days as f64
}
```

---

## 2.3.9 æœ€ä½³å®è·µ

### 2.3.9.1 æ¶ˆæ¯è®¾è®¡

**æ¶ˆæ¯ç»“æ„**:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Message<T> {
    pub id: String,
    pub timestamp: i64,
    pub version: String,
    pub event_type: String,
    pub data: T,
}

impl<T> Message<T> {
    pub fn new(event_type: String, data: T) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            version: "1.0".to_string(),
            event_type,
            data,
        }
    }
}
```

### 2.3.9.2 é”™è¯¯å¤„ç†

**è‡ªå®šä¹‰é”™è¯¯ç±»å‹**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MessagingError {
    #[error("Failed to send message: {0}")]
    SendError(String),
    
    #[error("Failed to consume message: {0}")]
    ConsumeError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),
    
    #[error("Kafka error: {0}")]
    KafkaError(#[from] rdkafka::error::KafkaError),
}
```

### 2.3.9.3 å®‰å…¨å®è·µ

1. âœ… **ä½¿ç”¨ TLS åŠ å¯†**
2. âœ… **å¯ç”¨ SASL è®¤è¯**
3. âœ… **é™åˆ¶ç½‘ç»œè®¿é—®**
4. âœ… **æ¶ˆæ¯åŠ å¯†**
5. âœ… **å®¡è®¡æ—¥å¿—**
6. âœ… **è®¿é—®æ§åˆ¶**

```rust
// TLS é…ç½®ç¤ºä¾‹
pub fn create_secure_config() -> ClientConfig {
    let mut config = ClientConfig::new();
    config.set("bootstrap.servers", "localhost:9092");
    config.set("security.protocol", "SASL_SSL");
    config.set("sasl.mechanism", "PLAIN");
    config.set("sasl.username", "user");
    config.set("sasl.password", "password");
    config
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å­¦ä¹ ç¤¾åŒº

---

**âœ… Rust æ¶ˆæ¯é˜Ÿåˆ—æŒ‡å—å®Œæˆï¼** ğŸ‰
