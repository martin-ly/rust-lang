# 2.1 Rust 数据库集成指南 (2025)

> **文档定位**: Rust 数据库集成完整实战指南  
> **适用人群**: 后端开发者，数据库工程师  
> **关联文档**: [3.2 开源库生态全景图](../references/3.2_开源库生态全景图.md) | [1.3 常见问题](../1.3_常见问题.md)

## 📊 目录

- [2.1 Rust 数据库集成指南 (2025)](#21-rust-数据库集成指南-2025)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [2.1.1 概述](#211-概述)
    - [2.1.1.1 为什么选择 Rust 做数据库开发？](#2111-为什么选择-rust-做数据库开发)
    - [2.1.1.2 数据库技术栈对比](#2112-数据库技术栈对比)
  - [2.1.2 技术选型](#212-技术选型)
    - [2.1.2.1 决策树](#2121-决策树)
    - [2.1.2.2 选型建议](#2122-选型建议)
  - [2.1.3 SQLx 深度实战](#213-sqlx-深度实战)
    - [2.1.3.1 项目初始化](#2131-项目初始化)
    - [2.1.3.2 基础连接](#2132-基础连接)
    - [2.1.3.3 CRUD 操作](#2133-crud-操作)
    - [2.1.3.4 编译时检查查询](#2134-编译时检查查询)
    - [2.1.3.5 复杂查询](#2135-复杂查询)
  - [2.1.4 SeaORM 实战](#214-seaorm-实战)
    - [2.1.4.1 项目初始化](#2141-项目初始化)
    - [2.1.4.2 实体定义](#2142-实体定义)
    - [2.1.4.3 CRUD 操作](#2143-crud-操作)
    - [2.1.4.4 关联查询](#2144-关联查询)
  - [2.1.5 Diesel 实战](#215-diesel-实战)
    - [2.1.5.1 项目初始化](#2151-项目初始化)
    - [2.1.5.2 模式定义](#2152-模式定义)
    - [2.1.5.3 CRUD 操作](#2153-crud-操作)
  - [2.1.6 NoSQL 数据库](#216-nosql-数据库)
    - [2.1.6.1 MongoDB](#2161-mongodb)
    - [2.1.6.2 Redis](#2162-redis)
  - [2.1.7 数据库迁移](#217-数据库迁移)
    - [2.1.7.1 SQLx 迁移](#2171-sqlx-迁移)
    - [2.1.7.2 SeaORM 迁移](#2172-seaorm-迁移)
  - [2.1.8 连接池管理](#218-连接池管理)
    - [2.1.8.1 配置最佳实践](#2181-配置最佳实践)
    - [2.1.8.2 连接池监控](#2182-连接池监控)
  - [2.1.9 事务处理](#219-事务处理)
    - [2.1.9.1 SQLx 事务](#2191-sqlx-事务)
  - [2.1.10 性能优化](#2110-性能优化)
    - [2.1.10.1 批量操作](#21101-批量操作)
    - [2.1.10.2 索引优化](#21102-索引优化)
    - [2.1.10.3 查询优化](#21103-查询优化)
  - [2.1.11 生产部署](#2111-生产部署)
    - [2.1.11.1 健康检查](#21111-健康检查)
    - [2.1.11.2 优雅关闭](#21112-优雅关闭)
  - [2.1.12 最佳实践](#2112-最佳实践)
    - [2.1.12.1 错误处理](#21121-错误处理)
    - [2.1.12.2 日志记录](#21122-日志记录)
    - [2.1.12.3 安全实践](#21123-安全实践)

**Rust 版本**: 1.90  
**文档状态**: ✅ 生产就绪  
**最后更新**: 2025-10-21

---

## 📋 目录

- [2.1 Rust 数据库集成指南 (2025)](#21-rust-数据库集成指南-2025)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [2.1.1 概述](#211-概述)
    - [2.1.1.1 为什么选择 Rust 做数据库开发？](#2111-为什么选择-rust-做数据库开发)
    - [2.1.1.2 数据库技术栈对比](#2112-数据库技术栈对比)
  - [2.1.2 技术选型](#212-技术选型)
    - [2.1.2.1 决策树](#2121-决策树)
    - [2.1.2.2 选型建议](#2122-选型建议)
  - [2.1.3 SQLx 深度实战](#213-sqlx-深度实战)
    - [2.1.3.1 项目初始化](#2131-项目初始化)
    - [2.1.3.2 基础连接](#2132-基础连接)
    - [2.1.3.3 CRUD 操作](#2133-crud-操作)
    - [2.1.3.4 编译时检查查询](#2134-编译时检查查询)
    - [2.1.3.5 复杂查询](#2135-复杂查询)
  - [2.1.4 SeaORM 实战](#214-seaorm-实战)
    - [2.1.4.1 项目初始化](#2141-项目初始化)
    - [2.1.4.2 实体定义](#2142-实体定义)
    - [2.1.4.3 CRUD 操作](#2143-crud-操作)
    - [2.1.4.4 关联查询](#2144-关联查询)
  - [2.1.5 Diesel 实战](#215-diesel-实战)
    - [2.1.5.1 项目初始化](#2151-项目初始化)
    - [2.1.5.2 模式定义](#2152-模式定义)
    - [2.1.5.3 CRUD 操作](#2153-crud-操作)
  - [2.1.6 NoSQL 数据库](#216-nosql-数据库)
    - [2.1.6.1 MongoDB](#2161-mongodb)
    - [2.1.6.2 Redis](#2162-redis)
  - [2.1.7 数据库迁移](#217-数据库迁移)
    - [2.1.7.1 SQLx 迁移](#2171-sqlx-迁移)
    - [2.1.7.2 SeaORM 迁移](#2172-seaorm-迁移)
  - [2.1.8 连接池管理](#218-连接池管理)
    - [2.1.8.1 配置最佳实践](#2181-配置最佳实践)
    - [2.1.8.2 连接池监控](#2182-连接池监控)
  - [2.1.9 事务处理](#219-事务处理)
    - [2.1.9.1 SQLx 事务](#2191-sqlx-事务)
  - [2.1.10 性能优化](#2110-性能优化)
    - [2.1.10.1 批量操作](#21101-批量操作)
    - [2.1.10.2 索引优化](#21102-索引优化)
    - [2.1.10.3 查询优化](#21103-查询优化)
  - [2.1.11 生产部署](#2111-生产部署)
    - [2.1.11.1 健康检查](#21111-健康检查)
    - [2.1.11.2 优雅关闭](#21112-优雅关闭)
  - [2.1.12 最佳实践](#2112-最佳实践)
    - [2.1.12.1 错误处理](#21121-错误处理)
    - [2.1.12.2 日志记录](#21122-日志记录)
    - [2.1.12.3 安全实践](#21123-安全实践)

---

## 2.1.1 概述

### 2.1.1.1 为什么选择 Rust 做数据库开发？

**核心优势**:

1. ✅ **类型安全** - 编译时检查，避免 SQL 注入
2. ✅ **零成本抽象** - 性能媲美原生代码
3. ✅ **内存安全** - 无数据竞争，无内存泄漏
4. ✅ **异步高效** - 原生异步支持，高并发性能
5. ✅ **生态成熟** - 完善的数据库生态

### 2.1.1.2 数据库技术栈对比

| 方案 | 类型 | 特点 | 性能 | 学习曲线 | 适用场景 | 成熟度 |
|------|------|------|------|----------|----------|--------|
| **sqlx** | 查询构建器 | 编译时检查 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 灵活查询 | ⭐⭐⭐⭐⭐ |
| **sea-orm** | 异步 ORM | 动态查询 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 快速开发 | ⭐⭐⭐⭐ |
| **diesel** | 同步 ORM | 类型安全 | ⭐⭐⭐⭐⭐ | ⭐⭐ | 复杂查询 | ⭐⭐⭐⭐⭐ |

---

## 2.1.2 技术选型

### 2.1.2.1 决策树

```mermaid
graph TD
    A[选择数据库方案] --> B{需要 ORM？}
    B -->|是| C{异步还是同步？}
    B -->|否| D[sqlx]
    C -->|异步| E[sea-orm]
    C -->|同步| F[diesel]
    D --> G{需要编译时检查？}
    G -->|是| H[sqlx::query!]
    G -->|否| I[sqlx::query]
    
    style D fill:#90EE90
    style E fill:#87CEEB
    style F fill:#FFB6C1
```

### 2.1.2.2 选型建议

**推荐方案**:

1. **微服务 API** → sqlx (灵活 + 性能)
2. **快速原型** → sea-orm (易用 + 功能完整)
3. **复杂业务** → diesel (类型安全 + 强大)
4. **高并发** → sqlx (异步 + 零成本)

---

## 2.1.3 SQLx 深度实战

### 2.1.3.1 项目初始化

**依赖配置**:

```toml
[dependencies]
# SQLx - 异步 SQL 工具包
sqlx = { version = "0.8.6", features = [
    "runtime-tokio-rustls",  # Tokio 运行时 + Rustls TLS
    "postgres",              # PostgreSQL 支持
    "mysql",                 # MySQL 支持 (可选)
    "sqlite",                # SQLite 支持 (可选)
    "chrono",                # 日期时间类型
    "uuid",                  # UUID 类型
    "json",                  # JSON 类型
    "macros",                # 宏支持 (编译时检查)
] }

# 异步运行时
tokio = { version = "1.48", features = ["full"] }

# 错误处理
anyhow = "1.0.100"
thiserror = "2.0.17"

# 日志
tracing = "0.1.41"
tracing-subscriber = "0.3"

# 环境变量
dotenvy = "0.15"
```

**环境配置** (`.env`):

```bash
# PostgreSQL
DATABASE_URL=postgres://username:password@localhost:5432/mydb

# MySQL
# DATABASE_URL=mysql://username:password@localhost:3306/mydb

# SQLite
# DATABASE_URL=sqlite:./database.db
```

### 2.1.3.2 基础连接

**连接池初始化**:

```rust
use sqlx::{postgres::PgPoolOptions, PgPool};
use std::time::Duration;

pub async fn create_pool() -> Result<PgPool, sqlx::Error> {
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    
    PgPoolOptions::new()
        .max_connections(5)                    // 最大连接数
        .min_connections(1)                    // 最小连接数
        .max_lifetime(Duration::from_secs(30 * 60))  // 连接最大存活时间
        .acquire_timeout(Duration::from_secs(3))      // 获取连接超时
        .connect(&database_url)
        .await
}
```

### 2.1.3.3 CRUD 操作

**定义模型**:

```rust
use sqlx::FromRow;
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, FromRow)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug)]
pub struct CreateUser {
    pub username: String,
    pub email: String,
}
```

**CREATE - 插入数据**:

```rust
use sqlx::PgPool;

pub async fn create_user(
    pool: &PgPool,
    user: CreateUser,
) -> Result<User, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        r#"
        INSERT INTO users (id, username, email, created_at, updated_at)
        VALUES ($1, $2, $3, NOW(), NOW())
        RETURNING *
        "#,
    )
    .bind(Uuid::new_v4())
    .bind(&user.username)
    .bind(&user.email)
    .fetch_one(pool)
    .await?;
    
    Ok(user)
}
```

**READ - 查询数据**:

```rust
// 查询单个用户
pub async fn get_user_by_id(
    pool: &PgPool,
    id: Uuid,
) -> Result<Option<User>, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        "SELECT * FROM users WHERE id = $1"
    )
    .bind(id)
    .fetch_optional(pool)
    .await?;
    
    Ok(user)
}

// 查询所有用户
pub async fn list_users(
    pool: &PgPool,
    limit: i64,
    offset: i64,
) -> Result<Vec<User>, sqlx::Error> {
    let users = sqlx::query_as::<_, User>(
        "SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2"
    )
    .bind(limit)
    .bind(offset)
    .fetch_all(pool)
    .await?;
    
    Ok(users)
}

// 分页查询
pub struct Pagination {
    pub total: i64,
    pub page: i64,
    pub page_size: i64,
    pub users: Vec<User>,
}

pub async fn list_users_paginated(
    pool: &PgPool,
    page: i64,
    page_size: i64,
) -> Result<Pagination, sqlx::Error> {
    let offset = (page - 1) * page_size;
    
    // 查询总数
    let total: (i64,) = sqlx::query_as(
        "SELECT COUNT(*) FROM users"
    )
    .fetch_one(pool)
    .await?;
    
    // 查询数据
    let users = list_users(pool, page_size, offset).await?;
    
    Ok(Pagination {
        total: total.0,
        page,
        page_size,
        users,
    })
}
```

**UPDATE - 更新数据**:

```rust
pub async fn update_user_email(
    pool: &PgPool,
    id: Uuid,
    new_email: String,
) -> Result<User, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        r#"
        UPDATE users
        SET email = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING *
        "#,
    )
    .bind(&new_email)
    .bind(id)
    .fetch_one(pool)
    .await?;
    
    Ok(user)
}
```

**DELETE - 删除数据**:

```rust
pub async fn delete_user(
    pool: &PgPool,
    id: Uuid,
) -> Result<bool, sqlx::Error> {
    let result = sqlx::query("DELETE FROM users WHERE id = $1")
        .bind(id)
        .execute(pool)
        .await?;
    
    Ok(result.rows_affected() > 0)
}
```

### 2.1.3.4 编译时检查查询

**使用 `query!` 宏**:

```rust
// 编译时检查 SQL 语法和类型
pub async fn get_user_checked(
    pool: &PgPool,
    id: Uuid,
) -> Result<Option<User>, sqlx::Error> {
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        id
    )
    .fetch_optional(pool)
    .await?;
    
    Ok(user)
}
```

**优势**:

1. ✅ 编译时验证 SQL 语法
2. ✅ 编译时检查列类型
3. ✅ 自动生成类型映射
4. ✅ IDE 智能提示

**限制**:

- ⚠️ 需要在编译时连接数据库
- ⚠️ 需要 `.sqlx` 离线模式文件

### 2.1.3.5 复杂查询

**JOIN 查询**:

```rust
#[derive(Debug, FromRow)]
pub struct UserWithPosts {
    pub user_id: Uuid,
    pub username: String,
    pub post_id: Option<Uuid>,
    pub post_title: Option<String>,
}

pub async fn get_users_with_posts(
    pool: &PgPool,
) -> Result<Vec<UserWithPosts>, sqlx::Error> {
    let results = sqlx::query_as::<_, UserWithPosts>(
        r#"
        SELECT 
            u.id as user_id,
            u.username,
            p.id as post_id,
            p.title as post_title
        FROM users u
        LEFT JOIN posts p ON u.id = p.user_id
        ORDER BY u.created_at DESC
        "#,
    )
    .fetch_all(pool)
    .await?;
    
    Ok(results)
}
```

**动态查询构建**:

```rust
pub struct UserFilter {
    pub username: Option<String>,
    pub email: Option<String>,
}

pub async fn search_users(
    pool: &PgPool,
    filter: UserFilter,
) -> Result<Vec<User>, sqlx::Error> {
    let mut query = String::from("SELECT * FROM users WHERE 1=1");
    let mut bindings: Vec<String> = vec![];
    
    if let Some(username) = &filter.username {
        query.push_str(&format!(" AND username LIKE ${}", bindings.len() + 1));
        bindings.push(format!("%{}%", username));
    }
    
    if let Some(email) = &filter.email {
        query.push_str(&format!(" AND email = ${}", bindings.len() + 1));
        bindings.push(email.clone());
    }
    
    let mut q = sqlx::query_as::<_, User>(&query);
    for binding in bindings {
        q = q.bind(binding);
    }
    
    let users = q.fetch_all(pool).await?;
    Ok(users)
}
```

---

## 2.1.4 SeaORM 实战

### 2.1.4.1 项目初始化

**依赖配置**:

```toml
[dependencies]
# SeaORM - 异步 ORM
sea-orm = { version = "2.0.0-rc.9", features = [
    "sqlx-postgres",           # PostgreSQL 支持
    "runtime-tokio-rustls",    # Tokio 运行时
    "macros",                  # 宏支持
] }

# SeaORM CLI (开发工具)
[dev-dependencies]
sea-orm-cli = "2.0.0-rc.9"
```

**生成实体**:

```bash
# 安装 CLI
cargo install sea-orm-cli

# 从数据库生成实体
sea-orm-cli generate entity \
  -u postgres://username:password@localhost:5432/mydb \
  -o src/entities
```

### 2.1.4.2 实体定义

**手动定义实体**:

```rust
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::post::Entity")]
    Posts,
}

impl Related<super::post::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Posts.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

### 2.1.4.3 CRUD 操作

**CREATE**:

```rust
use sea_orm::*;
use crate::entities::{user, prelude::*};

pub async fn create_user(
    db: &DatabaseConnection,
    username: String,
    email: String,
) -> Result<user::Model, DbErr> {
    let user = user::ActiveModel {
        id: Set(Uuid::new_v4()),
        username: Set(username),
        email: Set(email),
        created_at: Set(Utc::now()),
        updated_at: Set(Utc::now()),
    };
    
    let user = user.insert(db).await?;
    Ok(user)
}
```

**READ**:

```rust
// 查询单个
pub async fn get_user_by_id(
    db: &DatabaseConnection,
    id: Uuid,
) -> Result<Option<user::Model>, DbErr> {
    User::find_by_id(id).one(db).await
}

// 查询所有
pub async fn list_users(
    db: &DatabaseConnection,
) -> Result<Vec<user::Model>, DbErr> {
    User::find().all(db).await
}

// 条件查询
pub async fn find_by_email(
    db: &DatabaseConnection,
    email: String,
) -> Result<Option<user::Model>, DbErr> {
    User::find()
        .filter(user::Column::Email.eq(email))
        .one(db)
        .await
}
```

**UPDATE**:

```rust
pub async fn update_user_email(
    db: &DatabaseConnection,
    id: Uuid,
    new_email: String,
) -> Result<user::Model, DbErr> {
    let user = User::find_by_id(id)
        .one(db)
        .await?
        .ok_or(DbErr::RecordNotFound("User not found".to_string()))?;
    
    let mut user: user::ActiveModel = user.into();
    user.email = Set(new_email);
    user.updated_at = Set(Utc::now());
    
    user.update(db).await
}
```

**DELETE**:

```rust
pub async fn delete_user(
    db: &DatabaseConnection,
    id: Uuid,
) -> Result<DeleteResult, DbErr> {
    User::delete_by_id(id).exec(db).await
}
```

### 2.1.4.4 关联查询

**一对多查询**:

```rust
pub async fn get_user_with_posts(
    db: &DatabaseConnection,
    user_id: Uuid,
) -> Result<(user::Model, Vec<post::Model>), DbErr> {
    let user = User::find_by_id(user_id)
        .one(db)
        .await?
        .ok_or(DbErr::RecordNotFound("User not found".to_string()))?;
    
    let posts = user.find_related(Post).all(db).await?;
    
    Ok((user, posts))
}
```

---

## 2.1.5 Diesel 实战

### 2.1.5.1 项目初始化

**依赖配置**:

```toml
[dependencies]
diesel = { version = "2.2.4", features = [
    "postgres",
    "chrono",
    "uuid",
    "r2d2",  # 连接池
] }
diesel_migrations = "2.2"
```

**生成模式**:

```bash
# 安装 CLI
cargo install diesel_cli --no-default-features --features postgres

# 初始化
diesel setup

# 创建迁移
diesel migration generate create_users

# 运行迁移
diesel migration run
```

### 2.1.5.2 模式定义

**Schema** (`src/schema.rs`):

```rust
// @generated automatically by Diesel CLI.

diesel::table! {
    users (id) {
        id -> Uuid,
        username -> Varchar,
        email -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}
```

**Model**:

```rust
use diesel::prelude::*;
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, Queryable, Selectable)]
#[diesel(table_name = crate::schema::users)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Insertable)]
#[diesel(table_name = crate::schema::users)]
pub struct NewUser {
    pub id: Uuid,
    pub username: String,
    pub email: String,
}
```

### 2.1.5.3 CRUD 操作

**CREATE**:

```rust
use diesel::prelude::*;
use crate::schema::users;

pub fn create_user(
    conn: &mut PgConnection,
    username: String,
    email: String,
) -> Result<User, diesel::result::Error> {
    let new_user = NewUser {
        id: Uuid::new_v4(),
        username,
        email,
    };
    
    diesel::insert_into(users::table)
        .values(&new_user)
        .returning(User::as_returning())
        .get_result(conn)
}
```

**READ**:

```rust
use crate::schema::users::dsl::*;

// 查询单个
pub fn get_user_by_id(
    conn: &mut PgConnection,
    user_id: Uuid,
) -> Result<User, diesel::result::Error> {
    users.find(user_id).first(conn)
}

// 查询所有
pub fn list_users(
    conn: &mut PgConnection,
) -> Result<Vec<User>, diesel::result::Error> {
    users.load::<User>(conn)
}

// 条件查询
pub fn find_by_email(
    conn: &mut PgConnection,
    user_email: &str,
) -> Result<Option<User>, diesel::result::Error> {
    users
        .filter(email.eq(user_email))
        .first(conn)
        .optional()
}
```

**UPDATE**:

```rust
pub fn update_user_email(
    conn: &mut PgConnection,
    user_id: Uuid,
    new_email: String,
) -> Result<User, diesel::result::Error> {
    diesel::update(users.find(user_id))
        .set((
            email.eq(new_email),
            updated_at.eq(diesel::dsl::now),
        ))
        .returning(User::as_returning())
        .get_result(conn)
}
```

**DELETE**:

```rust
pub fn delete_user(
    conn: &mut PgConnection,
    user_id: Uuid,
) -> Result<usize, diesel::result::Error> {
    diesel::delete(users.find(user_id)).execute(conn)
}
```

---

## 2.1.6 NoSQL 数据库

### 2.1.6.1 MongoDB

**依赖配置**:

```toml
[dependencies]
mongodb = "3.2"
serde = { version = "1.0", features = ["derive"] }
```

**连接和操作**:

```rust
use mongodb::{Client, Collection};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    id: Option<mongodb::bson::oid::ObjectId>,
    username: String,
    email: String,
}

pub async fn mongo_example() -> mongodb::error::Result<()> {
    // 连接
    let client = Client::with_uri_str("mongodb://localhost:27017").await?;
    let db = client.database("mydb");
    let collection: Collection<User> = db.collection("users");
    
    // 插入
    let user = User {
        id: None,
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
    };
    collection.insert_one(user).await?;
    
    // 查询
    let filter = doc! { "username": "alice" };
    let user = collection.find_one(filter).await?;
    
    Ok(())
}
```

### 2.1.6.2 Redis

**依赖配置**:

```toml
[dependencies]
redis = { version = "1.0.0-rc.2", features = ["tokio-comp", "connection-manager"] }
```

**连接和操作**:

```rust
use redis::AsyncCommands;

pub async fn redis_example() -> redis::RedisResult<()> {
    // 连接
    let client = redis::Client::open("redis://localhost:6379")?;
    let mut con = client.get_connection_manager().await?;
    
    // 设置
    con.set("key", "value").await?;
    
    // 获取
    let value: String = con.get("key").await?;
    
    // 设置过期时间
    con.set_ex("session", "data", 3600).await?;
    
    Ok(())
}
```

---

## 2.1.7 数据库迁移

### 2.1.7.1 SQLx 迁移

**创建迁移文件**:

```bash
# 创建迁移目录
mkdir -p migrations

# 创建迁移文件
# migrations/20250101_create_users.sql
```

**迁移文件内容**:

```sql
-- 20250101_create_users.sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
```

**运行迁移**:

```rust
use sqlx::migrate::Migrator;

pub async fn run_migrations(pool: &PgPool) -> Result<(), sqlx::Error> {
    let migrator = Migrator::new(std::path::Path::new("./migrations")).await?;
    migrator.run(pool).await?;
    Ok(())
}
```

### 2.1.7.2 SeaORM 迁移

**创建迁移**:

```bash
sea-orm-cli migrate generate create_users
```

**迁移代码**:

```rust
use sea_orm_migration::prelude::*;

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(Users::Table)
                    .col(ColumnDef::new(Users::Id).uuid().primary_key())
                    .col(ColumnDef::new(Users::Username).string().not_null().unique_key())
                    .col(ColumnDef::new(Users::Email).string().not_null().unique_key())
                    .col(ColumnDef::new(Users::CreatedAt).timestamp_with_time_zone().not_null())
                    .col(ColumnDef::new(Users::UpdatedAt).timestamp_with_time_zone().not_null())
                    .to_owned(),
            )
            .await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(Users::Table).to_owned())
            .await
    }
}

#[derive(Iden)]
enum Users {
    Table,
    Id,
    Username,
    Email,
    CreatedAt,
    UpdatedAt,
}
```

---

## 2.1.8 连接池管理

### 2.1.8.1 配置最佳实践

```rust
use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

pub async fn create_optimized_pool() -> Result<PgPool, sqlx::Error> {
    PgPoolOptions::new()
        // 连接数配置
        .max_connections(20)              // 最大连接数 = CPU核心数 * 2
        .min_connections(2)               // 最小连接数
        
        // 超时配置
        .acquire_timeout(Duration::from_secs(30))  // 获取连接超时
        .connect_timeout(Duration::from_secs(10))  // 连接超时
        
        // 生命周期配置
        .max_lifetime(Duration::from_secs(30 * 60))  // 30分钟
        .idle_timeout(Duration::from_secs(10 * 60))  // 10分钟闲置
        
        // 健康检查
        .test_before_acquire(true)         // 获取前测试
        
        .connect(&std::env::var("DATABASE_URL")?)
        .await
}
```

### 2.1.8.2 连接池监控

```rust
pub fn monitor_pool(pool: &PgPool) {
    tracing::info!(
        "Pool status: connections={}, idle={}",
        pool.size(),
        pool.num_idle()
    );
}
```

---

## 2.1.9 事务处理

### 2.1.9.1 SQLx 事务

**基础事务**:

```rust
pub async fn transfer_money(
    pool: &PgPool,
    from_id: Uuid,
    to_id: Uuid,
    amount: Decimal,
) -> Result<(), sqlx::Error> {
    let mut tx = pool.begin().await?;
    
    // 扣款
    sqlx::query!(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
        amount,
        from_id
    )
    .execute(&mut *tx)
    .await?;
    
    // 加款
    sqlx::query!(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        amount,
        to_id
    )
    .execute(&mut *tx)
    .await?;
    
    // 提交事务
    tx.commit().await?;
    
    Ok(())
}
```

**错误回滚**:

```rust
pub async fn transaction_with_rollback(
    pool: &PgPool,
) -> Result<(), anyhow::Error> {
    let mut tx = pool.begin().await?;
    
    match sqlx::query!("INSERT INTO users (...) VALUES (...)")
        .execute(&mut *tx)
        .await
    {
        Ok(_) => {
            tx.commit().await?;
            Ok(())
        }
        Err(e) => {
            tx.rollback().await?;
            Err(e.into())
        }
    }
}
```

---

## 2.1.10 性能优化

### 2.1.10.1 批量操作

**批量插入**:

```rust
pub async fn batch_insert_users(
    pool: &PgPool,
    users: Vec<CreateUser>,
) -> Result<Vec<User>, sqlx::Error> {
    let mut tx = pool.begin().await?;
    let mut created_users = Vec::new();
    
    for user in users {
        let created = sqlx::query_as::<_, User>(
            "INSERT INTO users (...) VALUES (...) RETURNING *"
        )
        .bind(&user.username)
        .bind(&user.email)
        .fetch_one(&mut *tx)
        .await?;
        
        created_users.push(created);
    }
    
    tx.commit().await?;
    Ok(created_users)
}
```

### 2.1.10.2 索引优化

```sql
-- 常用查询的索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- 复合索引
CREATE INDEX idx_users_status_created ON users(status, created_at DESC);
```

### 2.1.10.3 查询优化

**使用 EXPLAIN ANALYZE**:

```rust
pub async fn analyze_query(pool: &PgPool) -> Result<(), sqlx::Error> {
    let plan = sqlx::query(
        "EXPLAIN ANALYZE SELECT * FROM users WHERE email = $1"
    )
    .bind("test@example.com")
    .fetch_all(pool)
    .await?;
    
    for row in plan {
        let line: String = row.try_get(0)?;
        println!("{}", line);
    }
    
    Ok(())
}
```

---

## 2.1.11 生产部署

### 2.1.11.1 健康检查

```rust
pub async fn health_check(pool: &PgPool) -> Result<bool, sqlx::Error> {
    sqlx::query("SELECT 1")
        .execute(pool)
        .await
        .map(|_| true)
}
```

### 2.1.11.2 优雅关闭

```rust
pub async fn graceful_shutdown(pool: PgPool) {
    tracing::info!("Closing database connections...");
    pool.close().await;
    tracing::info!("Database connections closed");
}
```

---

## 2.1.12 最佳实践

### 2.1.12.1 错误处理

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DatabaseError {
    #[error("User not found: {0}")]
    UserNotFound(Uuid),
    
    #[error("Duplicate email: {0}")]
    DuplicateEmail(String),
    
    #[error("Database error: {0}")]
    SqlxError(#[from] sqlx::Error),
}
```

### 2.1.12.2 日志记录

```rust
use tracing::{info, warn, error, instrument};

#[instrument(skip(pool))]
pub async fn create_user_with_logging(
    pool: &PgPool,
    user: CreateUser,
) -> Result<User, DatabaseError> {
    info!("Creating user: {}", user.username);
    
    match create_user(pool, user).await {
        Ok(user) => {
            info!("User created successfully: {}", user.id);
            Ok(user)
        }
        Err(e) => {
            error!("Failed to create user: {}", e);
            Err(e.into())
        }
    }
}
```

### 2.1.12.3 安全实践

1. ✅ **永远使用参数化查询**
2. ✅ **不在日志中记录敏感信息**
3. ✅ **使用连接池限制**
4. ✅ **实施数据库访问控制**
5. ✅ **定期备份数据**

---

**文档版本**: v1.0  
**最后更新**: 2025-10-21  
**维护团队**: Rust 学习社区

---

**✅ Rust 数据库集成指南完成！** 🎉
