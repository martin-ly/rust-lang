# 2.1 Rust æ•°æ®åº“é›†æˆæŒ‡å— (2025)

> **æ–‡æ¡£å®šä½**: Rust æ•°æ®åº“é›†æˆå®Œæ•´å®æˆ˜æŒ‡å—  
> **é€‚ç”¨äººç¾¤**: åç«¯å¼€å‘è€…ï¼Œæ•°æ®åº“å·¥ç¨‹å¸ˆ  
> **å…³è”æ–‡æ¡£**: [3.2 å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾](../references/3.2_å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾.md) | [1.3 å¸¸è§é—®é¢˜](../1.3_å¸¸è§é—®é¢˜.md)

**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  
**æœ€åæ›´æ–°**: 2025-10-21

---

## ğŸ“‹ ç›®å½•

- [2.1 Rust æ•°æ®åº“é›†æˆæŒ‡å— (2025)](#21-rust-æ•°æ®åº“é›†æˆæŒ‡å—-2025)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2.1.1 æ¦‚è¿°](#211-æ¦‚è¿°)
    - [2.1.1.1 ä¸ºä»€ä¹ˆé€‰æ‹© Rust åšæ•°æ®åº“å¼€å‘ï¼Ÿ](#2111-ä¸ºä»€ä¹ˆé€‰æ‹©-rust-åšæ•°æ®åº“å¼€å‘)
    - [2.1.1.2 æ•°æ®åº“æŠ€æœ¯æ ˆå¯¹æ¯”](#2112-æ•°æ®åº“æŠ€æœ¯æ ˆå¯¹æ¯”)
  - [2.1.2 æŠ€æœ¯é€‰å‹](#212-æŠ€æœ¯é€‰å‹)
    - [2.1.2.1 å†³ç­–æ ‘](#2121-å†³ç­–æ ‘)
    - [2.1.2.2 é€‰å‹å»ºè®®](#2122-é€‰å‹å»ºè®®)
  - [2.1.3 SQLx æ·±åº¦å®æˆ˜](#213-sqlx-æ·±åº¦å®æˆ˜)
    - [2.1.3.1 é¡¹ç›®åˆå§‹åŒ–](#2131-é¡¹ç›®åˆå§‹åŒ–)
    - [2.1.3.2 åŸºç¡€è¿æ¥](#2132-åŸºç¡€è¿æ¥)
    - [2.1.3.3 CRUD æ“ä½œ](#2133-crud-æ“ä½œ)
    - [2.1.3.4 ç¼–è¯‘æ—¶æ£€æŸ¥æŸ¥è¯¢](#2134-ç¼–è¯‘æ—¶æ£€æŸ¥æŸ¥è¯¢)
    - [2.1.3.5 å¤æ‚æŸ¥è¯¢](#2135-å¤æ‚æŸ¥è¯¢)
  - [2.1.4 SeaORM å®æˆ˜](#214-seaorm-å®æˆ˜)
    - [2.1.4.1 é¡¹ç›®åˆå§‹åŒ–](#2141-é¡¹ç›®åˆå§‹åŒ–)
    - [2.1.4.2 å®ä½“å®šä¹‰](#2142-å®ä½“å®šä¹‰)
    - [2.1.4.3 CRUD æ“ä½œ](#2143-crud-æ“ä½œ)
    - [2.1.4.4 å…³è”æŸ¥è¯¢](#2144-å…³è”æŸ¥è¯¢)
  - [2.1.5 Diesel å®æˆ˜](#215-diesel-å®æˆ˜)
    - [2.1.5.1 é¡¹ç›®åˆå§‹åŒ–](#2151-é¡¹ç›®åˆå§‹åŒ–)
    - [2.1.5.2 æ¨¡å¼å®šä¹‰](#2152-æ¨¡å¼å®šä¹‰)
    - [2.1.5.3 CRUD æ“ä½œ](#2153-crud-æ“ä½œ)
  - [2.1.6 NoSQL æ•°æ®åº“](#216-nosql-æ•°æ®åº“)
    - [2.1.6.1 MongoDB](#2161-mongodb)
    - [2.1.6.2 Redis](#2162-redis)
  - [2.1.7 æ•°æ®åº“è¿ç§»](#217-æ•°æ®åº“è¿ç§»)
    - [2.1.7.1 SQLx è¿ç§»](#2171-sqlx-è¿ç§»)
    - [2.1.7.2 SeaORM è¿ç§»](#2172-seaorm-è¿ç§»)
  - [2.1.8 è¿æ¥æ± ç®¡ç†](#218-è¿æ¥æ± ç®¡ç†)
    - [2.1.8.1 é…ç½®æœ€ä½³å®è·µ](#2181-é…ç½®æœ€ä½³å®è·µ)
    - [2.1.8.2 è¿æ¥æ± ç›‘æ§](#2182-è¿æ¥æ± ç›‘æ§)
  - [2.1.9 äº‹åŠ¡å¤„ç†](#219-äº‹åŠ¡å¤„ç†)
    - [2.1.9.1 SQLx äº‹åŠ¡](#2191-sqlx-äº‹åŠ¡)
  - [2.1.10 æ€§èƒ½ä¼˜åŒ–](#2110-æ€§èƒ½ä¼˜åŒ–)
    - [2.1.10.1 æ‰¹é‡æ“ä½œ](#21101-æ‰¹é‡æ“ä½œ)
    - [2.1.10.2 ç´¢å¼•ä¼˜åŒ–](#21102-ç´¢å¼•ä¼˜åŒ–)
    - [2.1.10.3 æŸ¥è¯¢ä¼˜åŒ–](#21103-æŸ¥è¯¢ä¼˜åŒ–)
  - [2.1.11 ç”Ÿäº§éƒ¨ç½²](#2111-ç”Ÿäº§éƒ¨ç½²)
    - [2.1.11.1 å¥åº·æ£€æŸ¥](#21111-å¥åº·æ£€æŸ¥)
    - [2.1.11.2 ä¼˜é›…å…³é—­](#21112-ä¼˜é›…å…³é—­)
  - [2.1.12 æœ€ä½³å®è·µ](#2112-æœ€ä½³å®è·µ)
    - [2.1.12.1 é”™è¯¯å¤„ç†](#21121-é”™è¯¯å¤„ç†)
    - [2.1.12.2 æ—¥å¿—è®°å½•](#21122-æ—¥å¿—è®°å½•)
    - [2.1.12.3 å®‰å…¨å®è·µ](#21123-å®‰å…¨å®è·µ)

---

## 2.1.1 æ¦‚è¿°

### 2.1.1.1 ä¸ºä»€ä¹ˆé€‰æ‹© Rust åšæ•°æ®åº“å¼€å‘ï¼Ÿ

**æ ¸å¿ƒä¼˜åŠ¿**:

1. âœ… **ç±»å‹å®‰å…¨** - ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œé¿å… SQL æ³¨å…¥
2. âœ… **é›¶æˆæœ¬æŠ½è±¡** - æ€§èƒ½åª²ç¾åŸç”Ÿä»£ç 
3. âœ… **å†…å­˜å®‰å…¨** - æ— æ•°æ®ç«äº‰ï¼Œæ— å†…å­˜æ³„æ¼
4. âœ… **å¼‚æ­¥é«˜æ•ˆ** - åŸç”Ÿå¼‚æ­¥æ”¯æŒï¼Œé«˜å¹¶å‘æ€§èƒ½
5. âœ… **ç”Ÿæ€æˆç†Ÿ** - å®Œå–„çš„æ•°æ®åº“ç”Ÿæ€

### 2.1.1.2 æ•°æ®åº“æŠ€æœ¯æ ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ç±»å‹ | ç‰¹ç‚¹ | æ€§èƒ½ | å­¦ä¹ æ›²çº¿ | é€‚ç”¨åœºæ™¯ | æˆç†Ÿåº¦ |
|------|------|------|------|----------|----------|--------|
| **sqlx** | æŸ¥è¯¢æ„å»ºå™¨ | ç¼–è¯‘æ—¶æ£€æŸ¥ | â­â­â­â­â­ | â­â­â­ | çµæ´»æŸ¥è¯¢ | â­â­â­â­â­ |
| **sea-orm** | å¼‚æ­¥ ORM | åŠ¨æ€æŸ¥è¯¢ | â­â­â­â­ | â­â­â­â­ | å¿«é€Ÿå¼€å‘ | â­â­â­â­ |
| **diesel** | åŒæ­¥ ORM | ç±»å‹å®‰å…¨ | â­â­â­â­â­ | â­â­ | å¤æ‚æŸ¥è¯¢ | â­â­â­â­â­ |

---

## 2.1.2 æŠ€æœ¯é€‰å‹

### 2.1.2.1 å†³ç­–æ ‘

```mermaid
graph TD
    A[é€‰æ‹©æ•°æ®åº“æ–¹æ¡ˆ] --> B{éœ€è¦ ORMï¼Ÿ}
    B -->|æ˜¯| C{å¼‚æ­¥è¿˜æ˜¯åŒæ­¥ï¼Ÿ}
    B -->|å¦| D[sqlx]
    C -->|å¼‚æ­¥| E[sea-orm]
    C -->|åŒæ­¥| F[diesel]
    D --> G{éœ€è¦ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Ÿ}
    G -->|æ˜¯| H[sqlx::query!]
    G -->|å¦| I[sqlx::query]
    
    style D fill:#90EE90
    style E fill:#87CEEB
    style F fill:#FFB6C1
```

### 2.1.2.2 é€‰å‹å»ºè®®

**æ¨èæ–¹æ¡ˆ**:

1. **å¾®æœåŠ¡ API** â†’ sqlx (çµæ´» + æ€§èƒ½)
2. **å¿«é€ŸåŸå‹** â†’ sea-orm (æ˜“ç”¨ + åŠŸèƒ½å®Œæ•´)
3. **å¤æ‚ä¸šåŠ¡** â†’ diesel (ç±»å‹å®‰å…¨ + å¼ºå¤§)
4. **é«˜å¹¶å‘** â†’ sqlx (å¼‚æ­¥ + é›¶æˆæœ¬)

---

## 2.1.3 SQLx æ·±åº¦å®æˆ˜

### 2.1.3.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# SQLx - å¼‚æ­¥ SQL å·¥å…·åŒ…
sqlx = { version = "0.8.6", features = [
    "runtime-tokio-rustls",  # Tokio è¿è¡Œæ—¶ + Rustls TLS
    "postgres",              # PostgreSQL æ”¯æŒ
    "mysql",                 # MySQL æ”¯æŒ (å¯é€‰)
    "sqlite",                # SQLite æ”¯æŒ (å¯é€‰)
    "chrono",                # æ—¥æœŸæ—¶é—´ç±»å‹
    "uuid",                  # UUID ç±»å‹
    "json",                  # JSON ç±»å‹
    "macros",                # å®æ”¯æŒ (ç¼–è¯‘æ—¶æ£€æŸ¥)
] }

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.48", features = ["full"] }

# é”™è¯¯å¤„ç†
anyhow = "1.0.100"
thiserror = "2.0.17"

# æ—¥å¿—
tracing = "0.1.41"
tracing-subscriber = "0.3"

# ç¯å¢ƒå˜é‡
dotenvy = "0.15"
```

**ç¯å¢ƒé…ç½®** (`.env`):

```bash
# PostgreSQL
DATABASE_URL=postgres://username:password@localhost:5432/mydb

# MySQL
# DATABASE_URL=mysql://username:password@localhost:3306/mydb

# SQLite
# DATABASE_URL=sqlite:./database.db
```

### 2.1.3.2 åŸºç¡€è¿æ¥

**è¿æ¥æ± åˆå§‹åŒ–**:

```rust
use sqlx::{postgres::PgPoolOptions, PgPool};
use std::time::Duration;

pub async fn create_pool() -> Result<PgPool, sqlx::Error> {
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    
    PgPoolOptions::new()
        .max_connections(5)                    // æœ€å¤§è¿æ¥æ•°
        .min_connections(1)                    // æœ€å°è¿æ¥æ•°
        .max_lifetime(Duration::from_secs(30 * 60))  // è¿æ¥æœ€å¤§å­˜æ´»æ—¶é—´
        .acquire_timeout(Duration::from_secs(3))      // è·å–è¿æ¥è¶…æ—¶
        .connect(&database_url)
        .await
}
```

### 2.1.3.3 CRUD æ“ä½œ

**å®šä¹‰æ¨¡å‹**:

```rust
use sqlx::FromRow;
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, FromRow)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug)]
pub struct CreateUser {
    pub username: String,
    pub email: String,
}
```

**CREATE - æ’å…¥æ•°æ®**:

```rust
use sqlx::PgPool;

pub async fn create_user(
    pool: &PgPool,
    user: CreateUser,
) -> Result<User, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        r#"
        INSERT INTO users (id, username, email, created_at, updated_at)
        VALUES ($1, $2, $3, NOW(), NOW())
        RETURNING *
        "#,
    )
    .bind(Uuid::new_v4())
    .bind(&user.username)
    .bind(&user.email)
    .fetch_one(pool)
    .await?;
    
    Ok(user)
}
```

**READ - æŸ¥è¯¢æ•°æ®**:

```rust
// æŸ¥è¯¢å•ä¸ªç”¨æˆ·
pub async fn get_user_by_id(
    pool: &PgPool,
    id: Uuid,
) -> Result<Option<User>, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        "SELECT * FROM users WHERE id = $1"
    )
    .bind(id)
    .fetch_optional(pool)
    .await?;
    
    Ok(user)
}

// æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
pub async fn list_users(
    pool: &PgPool,
    limit: i64,
    offset: i64,
) -> Result<Vec<User>, sqlx::Error> {
    let users = sqlx::query_as::<_, User>(
        "SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2"
    )
    .bind(limit)
    .bind(offset)
    .fetch_all(pool)
    .await?;
    
    Ok(users)
}

// åˆ†é¡µæŸ¥è¯¢
pub struct Pagination {
    pub total: i64,
    pub page: i64,
    pub page_size: i64,
    pub users: Vec<User>,
}

pub async fn list_users_paginated(
    pool: &PgPool,
    page: i64,
    page_size: i64,
) -> Result<Pagination, sqlx::Error> {
    let offset = (page - 1) * page_size;
    
    // æŸ¥è¯¢æ€»æ•°
    let total: (i64,) = sqlx::query_as(
        "SELECT COUNT(*) FROM users"
    )
    .fetch_one(pool)
    .await?;
    
    // æŸ¥è¯¢æ•°æ®
    let users = list_users(pool, page_size, offset).await?;
    
    Ok(Pagination {
        total: total.0,
        page,
        page_size,
        users,
    })
}
```

**UPDATE - æ›´æ–°æ•°æ®**:

```rust
pub async fn update_user_email(
    pool: &PgPool,
    id: Uuid,
    new_email: String,
) -> Result<User, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        r#"
        UPDATE users
        SET email = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING *
        "#,
    )
    .bind(&new_email)
    .bind(id)
    .fetch_one(pool)
    .await?;
    
    Ok(user)
}
```

**DELETE - åˆ é™¤æ•°æ®**:

```rust
pub async fn delete_user(
    pool: &PgPool,
    id: Uuid,
) -> Result<bool, sqlx::Error> {
    let result = sqlx::query("DELETE FROM users WHERE id = $1")
        .bind(id)
        .execute(pool)
        .await?;
    
    Ok(result.rows_affected() > 0)
}
```

### 2.1.3.4 ç¼–è¯‘æ—¶æ£€æŸ¥æŸ¥è¯¢

**ä½¿ç”¨ `query!` å®**:

```rust
// ç¼–è¯‘æ—¶æ£€æŸ¥ SQL è¯­æ³•å’Œç±»å‹
pub async fn get_user_checked(
    pool: &PgPool,
    id: Uuid,
) -> Result<Option<User>, sqlx::Error> {
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        id
    )
    .fetch_optional(pool)
    .await?;
    
    Ok(user)
}
```

**ä¼˜åŠ¿**:

1. âœ… ç¼–è¯‘æ—¶éªŒè¯ SQL è¯­æ³•
2. âœ… ç¼–è¯‘æ—¶æ£€æŸ¥åˆ—ç±»å‹
3. âœ… è‡ªåŠ¨ç”Ÿæˆç±»å‹æ˜ å°„
4. âœ… IDE æ™ºèƒ½æç¤º

**é™åˆ¶**:

- âš ï¸ éœ€è¦åœ¨ç¼–è¯‘æ—¶è¿æ¥æ•°æ®åº“
- âš ï¸ éœ€è¦ `.sqlx` ç¦»çº¿æ¨¡å¼æ–‡ä»¶

### 2.1.3.5 å¤æ‚æŸ¥è¯¢

**JOIN æŸ¥è¯¢**:

```rust
#[derive(Debug, FromRow)]
pub struct UserWithPosts {
    pub user_id: Uuid,
    pub username: String,
    pub post_id: Option<Uuid>,
    pub post_title: Option<String>,
}

pub async fn get_users_with_posts(
    pool: &PgPool,
) -> Result<Vec<UserWithPosts>, sqlx::Error> {
    let results = sqlx::query_as::<_, UserWithPosts>(
        r#"
        SELECT 
            u.id as user_id,
            u.username,
            p.id as post_id,
            p.title as post_title
        FROM users u
        LEFT JOIN posts p ON u.id = p.user_id
        ORDER BY u.created_at DESC
        "#,
    )
    .fetch_all(pool)
    .await?;
    
    Ok(results)
}
```

**åŠ¨æ€æŸ¥è¯¢æ„å»º**:

```rust
pub struct UserFilter {
    pub username: Option<String>,
    pub email: Option<String>,
}

pub async fn search_users(
    pool: &PgPool,
    filter: UserFilter,
) -> Result<Vec<User>, sqlx::Error> {
    let mut query = String::from("SELECT * FROM users WHERE 1=1");
    let mut bindings: Vec<String> = vec![];
    
    if let Some(username) = &filter.username {
        query.push_str(&format!(" AND username LIKE ${}", bindings.len() + 1));
        bindings.push(format!("%{}%", username));
    }
    
    if let Some(email) = &filter.email {
        query.push_str(&format!(" AND email = ${}", bindings.len() + 1));
        bindings.push(email.clone());
    }
    
    let mut q = sqlx::query_as::<_, User>(&query);
    for binding in bindings {
        q = q.bind(binding);
    }
    
    let users = q.fetch_all(pool).await?;
    Ok(users)
}
```

---

## 2.1.4 SeaORM å®æˆ˜

### 2.1.4.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# SeaORM - å¼‚æ­¥ ORM
sea-orm = { version = "2.0.0-rc.9", features = [
    "sqlx-postgres",           # PostgreSQL æ”¯æŒ
    "runtime-tokio-rustls",    # Tokio è¿è¡Œæ—¶
    "macros",                  # å®æ”¯æŒ
] }

# SeaORM CLI (å¼€å‘å·¥å…·)
[dev-dependencies]
sea-orm-cli = "2.0.0-rc.9"
```

**ç”Ÿæˆå®ä½“**:

```bash
# å®‰è£… CLI
cargo install sea-orm-cli

# ä»æ•°æ®åº“ç”Ÿæˆå®ä½“
sea-orm-cli generate entity \
  -u postgres://username:password@localhost:5432/mydb \
  -o src/entities
```

### 2.1.4.2 å®ä½“å®šä¹‰

**æ‰‹åŠ¨å®šä¹‰å®ä½“**:

```rust
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::post::Entity")]
    Posts,
}

impl Related<super::post::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Posts.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

### 2.1.4.3 CRUD æ“ä½œ

**CREATE**:

```rust
use sea_orm::*;
use crate::entities::{user, prelude::*};

pub async fn create_user(
    db: &DatabaseConnection,
    username: String,
    email: String,
) -> Result<user::Model, DbErr> {
    let user = user::ActiveModel {
        id: Set(Uuid::new_v4()),
        username: Set(username),
        email: Set(email),
        created_at: Set(Utc::now()),
        updated_at: Set(Utc::now()),
    };
    
    let user = user.insert(db).await?;
    Ok(user)
}
```

**READ**:

```rust
// æŸ¥è¯¢å•ä¸ª
pub async fn get_user_by_id(
    db: &DatabaseConnection,
    id: Uuid,
) -> Result<Option<user::Model>, DbErr> {
    User::find_by_id(id).one(db).await
}

// æŸ¥è¯¢æ‰€æœ‰
pub async fn list_users(
    db: &DatabaseConnection,
) -> Result<Vec<user::Model>, DbErr> {
    User::find().all(db).await
}

// æ¡ä»¶æŸ¥è¯¢
pub async fn find_by_email(
    db: &DatabaseConnection,
    email: String,
) -> Result<Option<user::Model>, DbErr> {
    User::find()
        .filter(user::Column::Email.eq(email))
        .one(db)
        .await
}
```

**UPDATE**:

```rust
pub async fn update_user_email(
    db: &DatabaseConnection,
    id: Uuid,
    new_email: String,
) -> Result<user::Model, DbErr> {
    let user = User::find_by_id(id)
        .one(db)
        .await?
        .ok_or(DbErr::RecordNotFound("User not found".to_string()))?;
    
    let mut user: user::ActiveModel = user.into();
    user.email = Set(new_email);
    user.updated_at = Set(Utc::now());
    
    user.update(db).await
}
```

**DELETE**:

```rust
pub async fn delete_user(
    db: &DatabaseConnection,
    id: Uuid,
) -> Result<DeleteResult, DbErr> {
    User::delete_by_id(id).exec(db).await
}
```

### 2.1.4.4 å…³è”æŸ¥è¯¢

**ä¸€å¯¹å¤šæŸ¥è¯¢**:

```rust
pub async fn get_user_with_posts(
    db: &DatabaseConnection,
    user_id: Uuid,
) -> Result<(user::Model, Vec<post::Model>), DbErr> {
    let user = User::find_by_id(user_id)
        .one(db)
        .await?
        .ok_or(DbErr::RecordNotFound("User not found".to_string()))?;
    
    let posts = user.find_related(Post).all(db).await?;
    
    Ok((user, posts))
}
```

---

## 2.1.5 Diesel å®æˆ˜

### 2.1.5.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
diesel = { version = "2.2.4", features = [
    "postgres",
    "chrono",
    "uuid",
    "r2d2",  # è¿æ¥æ± 
] }
diesel_migrations = "2.2"
```

**ç”Ÿæˆæ¨¡å¼**:

```bash
# å®‰è£… CLI
cargo install diesel_cli --no-default-features --features postgres

# åˆå§‹åŒ–
diesel setup

# åˆ›å»ºè¿ç§»
diesel migration generate create_users

# è¿è¡Œè¿ç§»
diesel migration run
```

### 2.1.5.2 æ¨¡å¼å®šä¹‰

**Schema** (`src/schema.rs`):

```rust
// @generated automatically by Diesel CLI.

diesel::table! {
    users (id) {
        id -> Uuid,
        username -> Varchar,
        email -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}
```

**Model**:

```rust
use diesel::prelude::*;
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, Queryable, Selectable)]
#[diesel(table_name = crate::schema::users)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Insertable)]
#[diesel(table_name = crate::schema::users)]
pub struct NewUser {
    pub id: Uuid,
    pub username: String,
    pub email: String,
}
```

### 2.1.5.3 CRUD æ“ä½œ

**CREATE**:

```rust
use diesel::prelude::*;
use crate::schema::users;

pub fn create_user(
    conn: &mut PgConnection,
    username: String,
    email: String,
) -> Result<User, diesel::result::Error> {
    let new_user = NewUser {
        id: Uuid::new_v4(),
        username,
        email,
    };
    
    diesel::insert_into(users::table)
        .values(&new_user)
        .returning(User::as_returning())
        .get_result(conn)
}
```

**READ**:

```rust
use crate::schema::users::dsl::*;

// æŸ¥è¯¢å•ä¸ª
pub fn get_user_by_id(
    conn: &mut PgConnection,
    user_id: Uuid,
) -> Result<User, diesel::result::Error> {
    users.find(user_id).first(conn)
}

// æŸ¥è¯¢æ‰€æœ‰
pub fn list_users(
    conn: &mut PgConnection,
) -> Result<Vec<User>, diesel::result::Error> {
    users.load::<User>(conn)
}

// æ¡ä»¶æŸ¥è¯¢
pub fn find_by_email(
    conn: &mut PgConnection,
    user_email: &str,
) -> Result<Option<User>, diesel::result::Error> {
    users
        .filter(email.eq(user_email))
        .first(conn)
        .optional()
}
```

**UPDATE**:

```rust
pub fn update_user_email(
    conn: &mut PgConnection,
    user_id: Uuid,
    new_email: String,
) -> Result<User, diesel::result::Error> {
    diesel::update(users.find(user_id))
        .set((
            email.eq(new_email),
            updated_at.eq(diesel::dsl::now),
        ))
        .returning(User::as_returning())
        .get_result(conn)
}
```

**DELETE**:

```rust
pub fn delete_user(
    conn: &mut PgConnection,
    user_id: Uuid,
) -> Result<usize, diesel::result::Error> {
    diesel::delete(users.find(user_id)).execute(conn)
}
```

---

## 2.1.6 NoSQL æ•°æ®åº“

### 2.1.6.1 MongoDB

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
mongodb = "3.2"
serde = { version = "1.0", features = ["derive"] }
```

**è¿æ¥å’Œæ“ä½œ**:

```rust
use mongodb::{Client, Collection};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    id: Option<mongodb::bson::oid::ObjectId>,
    username: String,
    email: String,
}

pub async fn mongo_example() -> mongodb::error::Result<()> {
    // è¿æ¥
    let client = Client::with_uri_str("mongodb://localhost:27017").await?;
    let db = client.database("mydb");
    let collection: Collection<User> = db.collection("users");
    
    // æ’å…¥
    let user = User {
        id: None,
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
    };
    collection.insert_one(user).await?;
    
    // æŸ¥è¯¢
    let filter = doc! { "username": "alice" };
    let user = collection.find_one(filter).await?;
    
    Ok(())
}
```

### 2.1.6.2 Redis

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
redis = { version = "1.0.0-rc.2", features = ["tokio-comp", "connection-manager"] }
```

**è¿æ¥å’Œæ“ä½œ**:

```rust
use redis::AsyncCommands;

pub async fn redis_example() -> redis::RedisResult<()> {
    // è¿æ¥
    let client = redis::Client::open("redis://localhost:6379")?;
    let mut con = client.get_connection_manager().await?;
    
    // è®¾ç½®
    con.set("key", "value").await?;
    
    // è·å–
    let value: String = con.get("key").await?;
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    con.set_ex("session", "data", 3600).await?;
    
    Ok(())
}
```

---

## 2.1.7 æ•°æ®åº“è¿ç§»

### 2.1.7.1 SQLx è¿ç§»

**åˆ›å»ºè¿ç§»æ–‡ä»¶**:

```bash
# åˆ›å»ºè¿ç§»ç›®å½•
mkdir -p migrations

# åˆ›å»ºè¿ç§»æ–‡ä»¶
# migrations/20250101_create_users.sql
```

**è¿ç§»æ–‡ä»¶å†…å®¹**:

```sql
-- 20250101_create_users.sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
```

**è¿è¡Œè¿ç§»**:

```rust
use sqlx::migrate::Migrator;

pub async fn run_migrations(pool: &PgPool) -> Result<(), sqlx::Error> {
    let migrator = Migrator::new(std::path::Path::new("./migrations")).await?;
    migrator.run(pool).await?;
    Ok(())
}
```

### 2.1.7.2 SeaORM è¿ç§»

**åˆ›å»ºè¿ç§»**:

```bash
sea-orm-cli migrate generate create_users
```

**è¿ç§»ä»£ç **:

```rust
use sea_orm_migration::prelude::*;

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(Users::Table)
                    .col(ColumnDef::new(Users::Id).uuid().primary_key())
                    .col(ColumnDef::new(Users::Username).string().not_null().unique_key())
                    .col(ColumnDef::new(Users::Email).string().not_null().unique_key())
                    .col(ColumnDef::new(Users::CreatedAt).timestamp_with_time_zone().not_null())
                    .col(ColumnDef::new(Users::UpdatedAt).timestamp_with_time_zone().not_null())
                    .to_owned(),
            )
            .await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(Users::Table).to_owned())
            .await
    }
}

#[derive(Iden)]
enum Users {
    Table,
    Id,
    Username,
    Email,
    CreatedAt,
    UpdatedAt,
}
```

---

## 2.1.8 è¿æ¥æ± ç®¡ç†

### 2.1.8.1 é…ç½®æœ€ä½³å®è·µ

```rust
use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

pub async fn create_optimized_pool() -> Result<PgPool, sqlx::Error> {
    PgPoolOptions::new()
        // è¿æ¥æ•°é…ç½®
        .max_connections(20)              // æœ€å¤§è¿æ¥æ•° = CPUæ ¸å¿ƒæ•° * 2
        .min_connections(2)               // æœ€å°è¿æ¥æ•°
        
        // è¶…æ—¶é…ç½®
        .acquire_timeout(Duration::from_secs(30))  // è·å–è¿æ¥è¶…æ—¶
        .connect_timeout(Duration::from_secs(10))  // è¿æ¥è¶…æ—¶
        
        // ç”Ÿå‘½å‘¨æœŸé…ç½®
        .max_lifetime(Duration::from_secs(30 * 60))  // 30åˆ†é’Ÿ
        .idle_timeout(Duration::from_secs(10 * 60))  // 10åˆ†é’Ÿé—²ç½®
        
        // å¥åº·æ£€æŸ¥
        .test_before_acquire(true)         // è·å–å‰æµ‹è¯•
        
        .connect(&std::env::var("DATABASE_URL")?)
        .await
}
```

### 2.1.8.2 è¿æ¥æ± ç›‘æ§

```rust
pub fn monitor_pool(pool: &PgPool) {
    tracing::info!(
        "Pool status: connections={}, idle={}",
        pool.size(),
        pool.num_idle()
    );
}
```

---

## 2.1.9 äº‹åŠ¡å¤„ç†

### 2.1.9.1 SQLx äº‹åŠ¡

**åŸºç¡€äº‹åŠ¡**:

```rust
pub async fn transfer_money(
    pool: &PgPool,
    from_id: Uuid,
    to_id: Uuid,
    amount: Decimal,
) -> Result<(), sqlx::Error> {
    let mut tx = pool.begin().await?;
    
    // æ‰£æ¬¾
    sqlx::query!(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
        amount,
        from_id
    )
    .execute(&mut *tx)
    .await?;
    
    // åŠ æ¬¾
    sqlx::query!(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        amount,
        to_id
    )
    .execute(&mut *tx)
    .await?;
    
    // æäº¤äº‹åŠ¡
    tx.commit().await?;
    
    Ok(())
}
```

**é”™è¯¯å›æ»š**:

```rust
pub async fn transaction_with_rollback(
    pool: &PgPool,
) -> Result<(), anyhow::Error> {
    let mut tx = pool.begin().await?;
    
    match sqlx::query!("INSERT INTO users (...) VALUES (...)")
        .execute(&mut *tx)
        .await
    {
        Ok(_) => {
            tx.commit().await?;
            Ok(())
        }
        Err(e) => {
            tx.rollback().await?;
            Err(e.into())
        }
    }
}
```

---

## 2.1.10 æ€§èƒ½ä¼˜åŒ–

### 2.1.10.1 æ‰¹é‡æ“ä½œ

**æ‰¹é‡æ’å…¥**:

```rust
pub async fn batch_insert_users(
    pool: &PgPool,
    users: Vec<CreateUser>,
) -> Result<Vec<User>, sqlx::Error> {
    let mut tx = pool.begin().await?;
    let mut created_users = Vec::new();
    
    for user in users {
        let created = sqlx::query_as::<_, User>(
            "INSERT INTO users (...) VALUES (...) RETURNING *"
        )
        .bind(&user.username)
        .bind(&user.email)
        .fetch_one(&mut *tx)
        .await?;
        
        created_users.push(created);
    }
    
    tx.commit().await?;
    Ok(created_users)
}
```

### 2.1.10.2 ç´¢å¼•ä¼˜åŒ–

```sql
-- å¸¸ç”¨æŸ¥è¯¢çš„ç´¢å¼•
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_users_status_created ON users(status, created_at DESC);
```

### 2.1.10.3 æŸ¥è¯¢ä¼˜åŒ–

**ä½¿ç”¨ EXPLAIN ANALYZE**:

```rust
pub async fn analyze_query(pool: &PgPool) -> Result<(), sqlx::Error> {
    let plan = sqlx::query(
        "EXPLAIN ANALYZE SELECT * FROM users WHERE email = $1"
    )
    .bind("test@example.com")
    .fetch_all(pool)
    .await?;
    
    for row in plan {
        let line: String = row.try_get(0)?;
        println!("{}", line);
    }
    
    Ok(())
}
```

---

## 2.1.11 ç”Ÿäº§éƒ¨ç½²

### 2.1.11.1 å¥åº·æ£€æŸ¥

```rust
pub async fn health_check(pool: &PgPool) -> Result<bool, sqlx::Error> {
    sqlx::query("SELECT 1")
        .execute(pool)
        .await
        .map(|_| true)
}
```

### 2.1.11.2 ä¼˜é›…å…³é—­

```rust
pub async fn graceful_shutdown(pool: PgPool) {
    tracing::info!("Closing database connections...");
    pool.close().await;
    tracing::info!("Database connections closed");
}
```

---

## 2.1.12 æœ€ä½³å®è·µ

### 2.1.12.1 é”™è¯¯å¤„ç†

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DatabaseError {
    #[error("User not found: {0}")]
    UserNotFound(Uuid),
    
    #[error("Duplicate email: {0}")]
    DuplicateEmail(String),
    
    #[error("Database error: {0}")]
    SqlxError(#[from] sqlx::Error),
}
```

### 2.1.12.2 æ—¥å¿—è®°å½•

```rust
use tracing::{info, warn, error, instrument};

#[instrument(skip(pool))]
pub async fn create_user_with_logging(
    pool: &PgPool,
    user: CreateUser,
) -> Result<User, DatabaseError> {
    info!("Creating user: {}", user.username);
    
    match create_user(pool, user).await {
        Ok(user) => {
            info!("User created successfully: {}", user.id);
            Ok(user)
        }
        Err(e) => {
            error!("Failed to create user: {}", e);
            Err(e.into())
        }
    }
}
```

### 2.1.12.3 å®‰å…¨å®è·µ

1. âœ… **æ°¸è¿œä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢**
2. âœ… **ä¸åœ¨æ—¥å¿—ä¸­è®°å½•æ•æ„Ÿä¿¡æ¯**
3. âœ… **ä½¿ç”¨è¿æ¥æ± é™åˆ¶**
4. âœ… **å®æ–½æ•°æ®åº“è®¿é—®æ§åˆ¶**
5. âœ… **å®šæœŸå¤‡ä»½æ•°æ®**

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å­¦ä¹ ç¤¾åŒº

---

**âœ… Rust æ•°æ®åº“é›†æˆæŒ‡å—å®Œæˆï¼** ğŸ‰
