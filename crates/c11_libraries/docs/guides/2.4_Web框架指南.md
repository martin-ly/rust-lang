# 2.4 Rust Web æ¡†æ¶æŒ‡å— (2025)

> **æ–‡æ¡£å®šä½**: Rust Web æ¡†æ¶å®Œæ•´å®æˆ˜æŒ‡å—  
> **é€‚ç”¨äººç¾¤**: Web å¼€å‘è€…ï¼Œåç«¯å·¥ç¨‹å¸ˆ  
> **å…³è”æ–‡æ¡£**: [3.2 å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾](../references/3.2_å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾.md) | [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](./2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md)

**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  
**æœ€åæ›´æ–°**: 2025-10-21

---

## ğŸ“‹ ç›®å½•

- [2.4 Rust Web æ¡†æ¶æŒ‡å— (2025)](#24-rust-web-æ¡†æ¶æŒ‡å—-2025)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2.4.1 æ¦‚è¿°](#241-æ¦‚è¿°)
    - [2.4.1.1 ä¸ºä»€ä¹ˆé€‰æ‹© Rust åš Web å¼€å‘ï¼Ÿ](#2411-ä¸ºä»€ä¹ˆé€‰æ‹©-rust-åš-web-å¼€å‘)
    - [2.4.1.2 Web æ¡†æ¶æŠ€æœ¯æ ˆå¯¹æ¯”](#2412-web-æ¡†æ¶æŠ€æœ¯æ ˆå¯¹æ¯”)
  - [2.4.2 Axum æ·±åº¦å®æˆ˜](#242-axum-æ·±åº¦å®æˆ˜)
    - [2.4.2.1 é¡¹ç›®åˆå§‹åŒ–](#2421-é¡¹ç›®åˆå§‹åŒ–)
    - [2.4.2.2 è·¯ç”±ç³»ç»Ÿ](#2422-è·¯ç”±ç³»ç»Ÿ)
    - [2.4.2.3 æå–å™¨ (Extractors)](#2423-æå–å™¨-extractors)
    - [2.4.2.4 ä¸­é—´ä»¶](#2424-ä¸­é—´ä»¶)
    - [2.4.2.5 é”™è¯¯å¤„ç†](#2425-é”™è¯¯å¤„ç†)
    - [2.4.2.6 çŠ¶æ€ç®¡ç†](#2426-çŠ¶æ€ç®¡ç†)
  - [2.4.3 Actix-web å®æˆ˜](#243-actix-web-å®æˆ˜)
    - [2.4.3.1 é¡¹ç›®åˆå§‹åŒ–](#2431-é¡¹ç›®åˆå§‹åŒ–)
    - [2.4.3.2 è·¯ç”±å’Œå¤„ç†å™¨](#2432-è·¯ç”±å’Œå¤„ç†å™¨)
    - [2.4.3.3 ä¸­é—´ä»¶](#2433-ä¸­é—´ä»¶)
    - [2.4.3.4 åº”ç”¨çŠ¶æ€](#2434-åº”ç”¨çŠ¶æ€)
  - [2.4.4 RESTful API è®¾è®¡](#244-restful-api-è®¾è®¡)
    - [2.4.4.1 èµ„æºè®¾è®¡](#2441-èµ„æºè®¾è®¡)
    - [2.4.4.2 HTTP æ–¹æ³•](#2442-http-æ–¹æ³•)
    - [2.4.4.3 çŠ¶æ€ç ](#2443-çŠ¶æ€ç )
    - [2.4.4.4 ç‰ˆæœ¬æ§åˆ¶](#2444-ç‰ˆæœ¬æ§åˆ¶)
  - [2.4.5 è®¤è¯æˆæƒ](#245-è®¤è¯æˆæƒ)
    - [2.4.5.1 JWT è®¤è¯](#2451-jwt-è®¤è¯)
    - [2.4.5.2 OAuth2](#2452-oauth2)
    - [2.4.5.3 RBAC æƒé™](#2453-rbac-æƒé™)
  - [2.4.6 WebSocket](#246-websocket)
    - [2.4.6.1 åŸºç¡€å®ç°](#2461-åŸºç¡€å®ç°)
    - [2.4.6.2 æ¶ˆæ¯å¹¿æ’­](#2462-æ¶ˆæ¯å¹¿æ’­)
    - [2.4.6.3 å¿ƒè·³æœºåˆ¶](#2463-å¿ƒè·³æœºåˆ¶)
  - [2.4.7 æ€§èƒ½ä¼˜åŒ–](#247-æ€§èƒ½ä¼˜åŒ–)
    - [2.4.7.1 è¿æ¥å¤ç”¨](#2471-è¿æ¥å¤ç”¨)
    - [2.4.7.2 å“åº”å‹ç¼©](#2472-å“åº”å‹ç¼©)
    - [2.4.7.3 é™æ€èµ„æº](#2473-é™æ€èµ„æº)
  - [2.4.8 ç”Ÿäº§éƒ¨ç½²](#248-ç”Ÿäº§éƒ¨ç½²)
    - [2.4.8.1 é…ç½®ç®¡ç†](#2481-é…ç½®ç®¡ç†)
    - [2.4.8.2 æ—¥å¿—è®°å½•](#2482-æ—¥å¿—è®°å½•)
    - [2.4.8.3 å¥åº·æ£€æŸ¥](#2483-å¥åº·æ£€æŸ¥)
  - [2.4.9 æœ€ä½³å®è·µ](#249-æœ€ä½³å®è·µ)
    - [2.4.9.1 é¡¹ç›®ç»“æ„](#2491-é¡¹ç›®ç»“æ„)
    - [2.4.9.2 é”™è¯¯å¤„ç†](#2492-é”™è¯¯å¤„ç†)
    - [2.4.9.3 å®‰å…¨å®è·µ](#2493-å®‰å…¨å®è·µ)

---

## 2.4.1 æ¦‚è¿°

### 2.4.1.1 ä¸ºä»€ä¹ˆé€‰æ‹© Rust åš Web å¼€å‘ï¼Ÿ

**æ ¸å¿ƒä¼˜åŠ¿**:

1. âœ… **æè‡´æ€§èƒ½** - é›¶æˆæœ¬æŠ½è±¡ï¼Œæ¥è¿‘ C++ æ€§èƒ½
2. âœ… **å†…å­˜å®‰å…¨** - ç¼–è¯‘æ—¶ä¿è¯ï¼Œæ— è¿è¡Œæ—¶é”™è¯¯
3. âœ… **å¹¶å‘å‹å¥½** - åŸç”Ÿå¼‚æ­¥æ”¯æŒï¼Œé«˜å¹¶å‘å¤„ç†
4. âœ… **ç±»å‹å®‰å…¨** - ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œå‡å°‘ bug
5. âœ… **ç”Ÿæ€æˆç†Ÿ** - å®Œå–„çš„ Web ç”Ÿæ€ç³»ç»Ÿ

**æ€§èƒ½å¯¹æ¯”**:

```mermaid
graph LR
    A[Web æ¡†æ¶æ€§èƒ½] --> B[Rust Axum]
    A --> C[Go Gin]
    A --> D[Node.js Express]
    A --> E[Python FastAPI]
    
    B --> B1[è¯·æ±‚/ç§’: 200K+]
    C --> C1[è¯·æ±‚/ç§’: 100K+]
    D --> D1[è¯·æ±‚/ç§’: 30K+]
    E --> E1[è¯·æ±‚/ç§’: 20K+]
    
    style B fill:#90EE90
    style C fill:#87CEEB
    style D fill:#FFD700
    style E fill:#FFA07A
```

### 2.4.1.2 Web æ¡†æ¶æŠ€æœ¯æ ˆå¯¹æ¯”

| æ¡†æ¶ | ç±»å‹ | ç‰¹ç‚¹ | æ€§èƒ½ | å­¦ä¹ æ›²çº¿ | ç”Ÿæ€ | æˆç†Ÿåº¦ |
|------|------|------|------|----------|------|--------|
| **Axum** | æ¨¡å—åŒ– | Tower ç”Ÿæ€ï¼Œç±»å‹å®‰å…¨ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |
| **Actix-web** | Actor æ¨¡å‹ | é«˜æ€§èƒ½ï¼ŒåŠŸèƒ½å®Œæ•´ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **Rocket** | å®é©±åŠ¨ | æ˜“ç”¨ï¼Œè¡¨è¾¾åŠ›å¼º | â­â­â­â­ | â­â­ | â­â­â­â­ | â­â­â­â­ |
| **Poem** | ç°ä»£åŒ– | OpenAPIï¼Œä¼˜é›… | â­â­â­â­ | â­â­ | â­â­â­ | â­â­â­ |

---

## 2.4.2 Axum æ·±åº¦å®æˆ˜

### 2.4.2.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[package]
name = "axum-web-app"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web æ¡†æ¶
axum = { version = "0.8", features = ["ws", "multipart"] }
tower = "0.5"
tower-http = { version = "0.6", features = ["fs", "trace", "cors", "compression-gzip"] }

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.48", features = ["full"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# æ•°æ®åº“
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres"] }

# è®¤è¯
jsonwebtoken = "9.3"
argon2 = "0.5"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "2.0"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# é…ç½®
dotenvy = "0.15"

# éªŒè¯
validator = { version = "0.18", features = ["derive"] }

# æ—¶é—´
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
```

**åŸºç¡€åº”ç”¨**:

```rust
use axum::{
    Router,
    routing::{get, post},
};
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();

    // åˆ›å»ºè·¯ç”±
    let app = Router::new()
        .route("/", get(root))
        .route("/health", get(health_check));

    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    tracing::info!("Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn root() -> &'static str {
    "Hello, Axum!"
}

async fn health_check() -> &'static str {
    "OK"
}
```

### 2.4.2.2 è·¯ç”±ç³»ç»Ÿ

**åŸºç¡€è·¯ç”±**:

```rust
use axum::{
    Router,
    routing::{get, post, put, delete},
    response::Json,
};
use serde::{Deserialize, Serialize};

pub fn create_router() -> Router {
    Router::new()
        // åŸºç¡€è·¯ç”±
        .route("/", get(root))
        .route("/users", get(list_users).post(create_user))
        .route("/users/:id", get(get_user).put(update_user).delete(delete_user))
        
        // åµŒå¥—è·¯ç”±
        .nest("/api/v1", api_v1_routes())
        
        // é€šé…ç¬¦è·¯ç”±
        .route("/files/*path", get(serve_file))
}

fn api_v1_routes() -> Router {
    Router::new()
        .route("/users", get(list_users))
        .route("/posts", get(list_posts))
}
```

**è·¯å¾„å‚æ•°**:

```rust
use axum::extract::Path;

// å•ä¸ªå‚æ•°
async fn get_user(Path(id): Path<u64>) -> String {
    format!("User ID: {}", id)
}

// å¤šä¸ªå‚æ•°
async fn get_user_post(
    Path((user_id, post_id)): Path<(u64, u64)>,
) -> String {
    format!("User {} Post {}", user_id, post_id)
}

// ç»“æ„ä½“å‚æ•°
#[derive(Deserialize)]
struct Params {
    user_id: u64,
    post_id: u64,
}

async fn get_user_post_struct(
    Path(params): Path<Params>,
) -> String {
    format!("User {} Post {}", params.user_id, params.post_id)
}
```

**æŸ¥è¯¢å‚æ•°**:

```rust
use axum::extract::Query;

#[derive(Deserialize)]
struct Pagination {
    page: Option<u64>,
    per_page: Option<u64>,
}

async fn list_users(Query(pagination): Query<Pagination>) -> String {
    let page = pagination.page.unwrap_or(1);
    let per_page = pagination.per_page.unwrap_or(10);
    
    format!("Page {} with {} items", page, per_page)
}
```

### 2.4.2.3 æå–å™¨ (Extractors)

**JSON è¯·æ±‚ä½“**:

```rust
use axum::Json;

#[derive(Deserialize, Serialize)]
struct CreateUserRequest {
    username: String,
    email: String,
    password: String,
}

#[derive(Serialize)]
struct User {
    id: u64,
    username: String,
    email: String,
}

async fn create_user(
    Json(payload): Json<CreateUserRequest>,
) -> Json<User> {
    let user = User {
        id: 1,
        username: payload.username,
        email: payload.email,
    };
    
    Json(user)
}
```

**è¡¨å•æ•°æ®**:

```rust
use axum::Form;

#[derive(Deserialize)]
struct LoginForm {
    username: String,
    password: String,
}

async fn login(Form(form): Form<LoginForm>) -> String {
    format!("Login: {}", form.username)
}
```

**è¯·æ±‚å¤´**:

```rust
use axum::http::HeaderMap;

async fn headers_demo(headers: HeaderMap) -> String {
    let user_agent = headers
        .get("user-agent")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("unknown");
    
    format!("User-Agent: {}", user_agent)
}
```

**è‡ªå®šä¹‰æå–å™¨**:

```rust
use axum::{
    async_trait,
    extract::{FromRequestParts, rejection::JsonRejection},
    http::{request::Parts, StatusCode},
};

// éªŒè¯çš„ JSON æå–å™¨
struct ValidatedJson<T>(T);

#[async_trait]
impl<S, T> FromRequestParts<S> for ValidatedJson<T>
where
    T: for<'de> Deserialize<'de> + validator::Validate,
    S: Send + Sync,
{
    type Rejection = (StatusCode, String);

    async fn from_request_parts(
        parts: &mut Parts,
        state: &S,
    ) -> Result<Self, Self::Rejection> {
        let Json(value): Json<T> = Json::from_request_parts(parts, state)
            .await
            .map_err(|e| (StatusCode::BAD_REQUEST, e.to_string()))?;
        
        value.validate()
            .map_err(|e| (StatusCode::BAD_REQUEST, e.to_string()))?;
        
        Ok(ValidatedJson(value))
    }
}
```

### 2.4.2.4 ä¸­é—´ä»¶

**æ—¥å¿—ä¸­é—´ä»¶**:

```rust
use tower_http::trace::TraceLayer;

let app = Router::new()
    .route("/", get(root))
    .layer(TraceLayer::new_for_http());
```

**CORS ä¸­é—´ä»¶**:

```rust
use tower_http::cors::{CorsLayer, Any};

let cors = CorsLayer::new()
    .allow_origin(Any)
    .allow_methods(Any)
    .allow_headers(Any);

let app = Router::new()
    .route("/", get(root))
    .layer(cors);
```

**å‹ç¼©ä¸­é—´ä»¶**:

```rust
use tower_http::compression::CompressionLayer;

let app = Router::new()
    .route("/", get(root))
    .layer(CompressionLayer::new());
```

**è‡ªå®šä¹‰ä¸­é—´ä»¶**:

```rust
use axum::middleware::{self, Next};
use axum::http::Request;
use axum::response::Response;

async fn auth_middleware<B>(
    req: Request<B>,
    next: Next<B>,
) -> Response {
    // æ£€æŸ¥è®¤è¯
    if let Some(auth_header) = req.headers().get("authorization") {
        // éªŒè¯ token
        tracing::info!("Authenticated request");
    }
    
    next.run(req).await
}

let app = Router::new()
    .route("/", get(root))
    .layer(middleware::from_fn(auth_middleware));
```

### 2.4.2.5 é”™è¯¯å¤„ç†

**è‡ªå®šä¹‰é”™è¯¯ç±»å‹**:

```rust
use axum::{
    response::{IntoResponse, Response},
    http::StatusCode,
};

#[derive(thiserror::Error, Debug)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Not found: {0}")]
    NotFound(String),
    
    #[error("Unauthorized")]
    Unauthorized,
    
    #[error("Bad request: {0}")]
    BadRequest(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::Database(e) => {
                tracing::error!("Database error: {}", e);
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error")
            }
            AppError::NotFound(msg) => {
                (StatusCode::NOT_FOUND, msg.as_str())
            }
            AppError::Unauthorized => {
                (StatusCode::UNAUTHORIZED, "Unauthorized")
            }
            AppError::BadRequest(msg) => {
                (StatusCode::BAD_REQUEST, msg.as_str())
            }
        };
        
        (status, Json(serde_json::json!({
            "error": message
        }))).into_response()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn get_user(Path(id): Path<u64>) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(id as i64)
        .fetch_optional(&pool)
        .await?
        .ok_or_else(|| AppError::NotFound("User not found".to_string()))?;
    
    Ok(Json(user))
}
```

### 2.4.2.6 çŠ¶æ€ç®¡ç†

**åº”ç”¨çŠ¶æ€**:

```rust
use axum::extract::State;
use sqlx::PgPool;
use std::sync::Arc;

#[derive(Clone)]
struct AppState {
    db: PgPool,
    config: Arc<Config>,
}

async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as::<_, User>(
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING *"
    )
    .bind(&payload.username)
    .bind(&payload.email)
    .fetch_one(&state.db)
    .await?;
    
    Ok(Json(user))
}

#[tokio::main]
async fn main() {
    let pool = create_pool().await.unwrap();
    
    let state = AppState {
        db: pool,
        config: Arc::new(load_config()),
    };
    
    let app = Router::new()
        .route("/users", post(create_user))
        .with_state(state);
    
    // å¯åŠ¨æœåŠ¡å™¨
}
```

---

## 2.4.3 Actix-web å®æˆ˜

### 2.4.3.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
actix-web = "4.9"
actix-rt = "2.10"
actix-cors = "0.7"

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# æ•°æ®åº“
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres"] }
```

**åŸºç¡€åº”ç”¨**:

```rust
use actix_web::{web, App, HttpServer, HttpResponse};

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/", web::get().to(index))
            .route("/health", web::get().to(health))
    })
    .bind(("0.0.0.0", 8080))?
    .run()
    .await
}

async fn index() -> HttpResponse {
    HttpResponse::Ok().body("Hello, Actix!")
}

async fn health() -> HttpResponse {
    HttpResponse::Ok().json(serde_json::json!({
        "status": "ok"
    }))
}
```

### 2.4.3.2 è·¯ç”±å’Œå¤„ç†å™¨

**èµ„æºè·¯ç”±**:

```rust
use actix_web::{web, HttpResponse, Result};

pub fn config(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api/v1")
            .service(
                web::resource("/users")
                    .route(web::get().to(list_users))
                    .route(web::post().to(create_user))
            )
            .service(
                web::resource("/users/{id}")
                    .route(web::get().to(get_user))
                    .route(web::put().to(update_user))
                    .route(web::delete().to(delete_user))
            )
    );
}

async fn list_users() -> Result<HttpResponse> {
    Ok(HttpResponse::Ok().json(vec![
        User { id: 1, username: "alice".to_string() },
    ]))
}

async fn create_user(user: web::Json<CreateUserRequest>) -> Result<HttpResponse> {
    Ok(HttpResponse::Created().json(User {
        id: 1,
        username: user.username.clone(),
    }))
}
```

**è·¯å¾„å‚æ•°**:

```rust
use actix_web::web::Path;

async fn get_user(path: Path<u64>) -> Result<HttpResponse> {
    let user_id = path.into_inner();
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": user_id
    })))
}

// å¤šä¸ªå‚æ•°
async fn get_user_post(path: Path<(u64, u64)>) -> Result<HttpResponse> {
    let (user_id, post_id) = path.into_inner();
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "user_id": user_id,
        "post_id": post_id
    })))
}
```

### 2.4.3.3 ä¸­é—´ä»¶

**æ—¥å¿—ä¸­é—´ä»¶**:

```rust
use actix_web::middleware::Logger;

HttpServer::new(|| {
    App::new()
        .wrap(Logger::default())
        .route("/", web::get().to(index))
})
```

**CORS ä¸­é—´ä»¶**:

```rust
use actix_cors::Cors;

HttpServer::new(|| {
    let cors = Cors::default()
        .allow_any_origin()
        .allow_any_method()
        .allow_any_header();
    
    App::new()
        .wrap(cors)
        .route("/", web::get().to(index))
})
```

### 2.4.3.4 åº”ç”¨çŠ¶æ€

**å…±äº«çŠ¶æ€**:

```rust
use actix_web::web::Data;
use sqlx::PgPool;

struct AppState {
    db: PgPool,
}

async fn create_user(
    data: Data<AppState>,
    user: web::Json<CreateUserRequest>,
) -> Result<HttpResponse> {
    let user = sqlx::query_as::<_, User>(
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING *"
    )
    .bind(&user.username)
    .bind(&user.email)
    .fetch_one(&data.db)
    .await?;
    
    Ok(HttpResponse::Created().json(user))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let pool = create_pool().await.unwrap();
    
    let app_state = Data::new(AppState { db: pool });
    
    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .route("/users", web::post().to(create_user))
    })
    .bind(("0.0.0.0", 8080))?
    .run()
    .await
}
```

---

## 2.4.4 RESTful API è®¾è®¡

### 2.4.4.1 èµ„æºè®¾è®¡

**URI è®¾è®¡åŸåˆ™**:

```rust
// âœ… å¥½çš„è®¾è®¡
GET    /api/v1/users           // è·å–ç”¨æˆ·åˆ—è¡¨
GET    /api/v1/users/{id}      // è·å–å•ä¸ªç”¨æˆ·
POST   /api/v1/users           // åˆ›å»ºç”¨æˆ·
PUT    /api/v1/users/{id}      // æ›´æ–°ç”¨æˆ·
DELETE /api/v1/users/{id}      // åˆ é™¤ç”¨æˆ·

// åµŒå¥—èµ„æº
GET    /api/v1/users/{id}/posts          // è·å–ç”¨æˆ·çš„æ–‡ç« 
POST   /api/v1/users/{id}/posts          // åˆ›å»ºç”¨æˆ·çš„æ–‡ç« 
GET    /api/v1/users/{id}/posts/{post_id} // è·å–ç‰¹å®šæ–‡ç« 

// âŒ ä¸å¥½çš„è®¾è®¡
GET    /api/v1/getUsers           // åŠ¨è¯å½¢å¼
POST   /api/v1/user-creation      // éèµ„æºåè¯
GET    /api/v1/users/list         // å†—ä½™çš„åŠ¨ä½œ
```

### 2.4.4.2 HTTP æ–¹æ³•

**æ ‡å‡†æ–¹æ³•è¯­ä¹‰**:

```rust
use axum::{Router, routing::*};

pub fn user_routes() -> Router {
    Router::new()
        // GET - å®‰å…¨ä¸”å¹‚ç­‰
        .route("/users", get(list_users))
        .route("/users/:id", get(get_user))
        
        // POST - éå¹‚ç­‰ï¼Œåˆ›å»ºèµ„æº
        .route("/users", post(create_user))
        
        // PUT - å¹‚ç­‰ï¼Œå®Œå…¨æ›¿æ¢èµ„æº
        .route("/users/:id", put(replace_user))
        
        // PATCH - å¹‚ç­‰ï¼Œéƒ¨åˆ†æ›´æ–°èµ„æº
        .route("/users/:id", patch(update_user))
        
        // DELETE - å¹‚ç­‰ï¼Œåˆ é™¤èµ„æº
        .route("/users/:id", delete(delete_user))
}
```

### 2.4.4.3 çŠ¶æ€ç 

**å¸¸ç”¨çŠ¶æ€ç **:

```rust
use axum::http::StatusCode;

// 2xx æˆåŠŸ
async fn create_user() -> (StatusCode, Json<User>) {
    (StatusCode::CREATED, Json(user))  // 201
}

// 3xx é‡å®šå‘
async fn redirect() -> (StatusCode, [(&'static str, &'static str); 1]) {
    (StatusCode::MOVED_PERMANENTLY, [("location", "/new-path")])  // 301
}

// 4xx å®¢æˆ·ç«¯é”™è¯¯
async fn not_found() -> StatusCode {
    StatusCode::NOT_FOUND  // 404
}

async fn bad_request() -> (StatusCode, &'static str) {
    (StatusCode::BAD_REQUEST, "Invalid request")  // 400
}

async fn unauthorized() -> StatusCode {
    StatusCode::UNAUTHORIZED  // 401
}

// 5xx æœåŠ¡å™¨é”™è¯¯
async fn internal_error() -> StatusCode {
    StatusCode::INTERNAL_SERVER_ERROR  // 500
}
```

### 2.4.4.4 ç‰ˆæœ¬æ§åˆ¶

**URI ç‰ˆæœ¬æ§åˆ¶**:

```rust
let app = Router::new()
    .nest("/api/v1", v1_routes())
    .nest("/api/v2", v2_routes());

fn v1_routes() -> Router {
    Router::new()
        .route("/users", get(v1::list_users))
}

fn v2_routes() -> Router {
    Router::new()
        .route("/users", get(v2::list_users))
}
```

**è¯·æ±‚å¤´ç‰ˆæœ¬æ§åˆ¶**:

```rust
use axum::http::HeaderMap;

async fn list_users(headers: HeaderMap) -> Json<Vec<User>> {
    let version = headers
        .get("api-version")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("v1");
    
    match version {
        "v2" => Json(v2::get_users().await),
        _ => Json(v1::get_users().await),
    }
}
```

---

## 2.4.5 è®¤è¯æˆæƒ

### 2.4.5.1 JWT è®¤è¯

**JWT å®ç°**:

```rust
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,  // ç”¨æˆ· ID
    exp: usize,   // è¿‡æœŸæ—¶é—´
    iat: usize,   // ç­¾å‘æ—¶é—´
}

// ç”Ÿæˆ JWT
fn generate_jwt(user_id: &str, secret: &str) -> Result<String, AppError> {
    let expiration = chrono::Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .unwrap()
        .timestamp() as usize;
    
    let claims = Claims {
        sub: user_id.to_string(),
        exp: expiration,
        iat: chrono::Utc::now().timestamp() as usize,
    };
    
    let token = encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )?;
    
    Ok(token)
}

// éªŒè¯ JWT
fn verify_jwt(token: &str, secret: &str) -> Result<Claims, AppError> {
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_bytes()),
        &Validation::default(),
    )?;
    
    Ok(token_data.claims)
}
```

**è®¤è¯ä¸­é—´ä»¶**:

```rust
use axum::{
    middleware::Next,
    http::{Request, StatusCode},
    response::Response,
};

async fn auth_middleware<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    let token = auth_header
        .strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // éªŒè¯ token
    verify_jwt(token, "secret")
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    Ok(next.run(req).await)
}

// åº”ç”¨ä¸­é—´ä»¶
let protected_routes = Router::new()
    .route("/profile", get(get_profile))
    .layer(middleware::from_fn(auth_middleware));
```

### 2.4.5.2 OAuth2

**OAuth2 å®¢æˆ·ç«¯**:

```rust
use oauth2::{
    AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl,
    basic::BasicClient,
    AuthorizationCode, CsrfToken, PkceCodeChallenge,
};

pub fn create_oauth_client() -> BasicClient {
    BasicClient::new(
        ClientId::new("client_id".to_string()),
        Some(ClientSecret::new("client_secret".to_string())),
        AuthUrl::new("https://provider.com/oauth/authorize".to_string()).unwrap(),
        Some(TokenUrl::new("https://provider.com/oauth/token".to_string()).unwrap()),
    )
    .set_redirect_uri(
        RedirectUrl::new("http://localhost:3000/callback".to_string()).unwrap()
    )
}

// ç”Ÿæˆæˆæƒ URL
async fn login() -> String {
    let client = create_oauth_client();
    
    let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
    
    let (auth_url, csrf_token) = client
        .authorize_url(CsrfToken::new_random)
        .set_pkce_challenge(pkce_challenge)
        .url();
    
    // ä¿å­˜ csrf_token å’Œ pkce_verifier åˆ° session
    
    auth_url.to_string()
}

// å¤„ç†å›è°ƒ
async fn callback(
    Query(params): Query<CallbackParams>,
) -> Result<String, AppError> {
    let client = create_oauth_client();
    
    // ä» session è·å– pkce_verifier
    
    let token_result = client
        .exchange_code(AuthorizationCode::new(params.code))
        .set_pkce_verifier(pkce_verifier)
        .request_async(oauth2::reqwest::async_http_client)
        .await?;
    
    Ok(token_result.access_token().secret().to_string())
}
```

### 2.4.5.3 RBAC æƒé™

**æƒé™æ£€æŸ¥**:

```rust
use std::collections::HashSet;

#[derive(Debug, Clone)]
enum Permission {
    ReadUser,
    WriteUser,
    DeleteUser,
    ReadPost,
    WritePost,
}

#[derive(Debug, Clone)]
struct User {
    id: u64,
    username: String,
    permissions: HashSet<Permission>,
}

impl User {
    fn has_permission(&self, permission: &Permission) -> bool {
        self.permissions.contains(permission)
    }
}

// æƒé™ä¸­é—´ä»¶
async fn require_permission<B>(
    permission: Permission,
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    // ä» token è·å–ç”¨æˆ·ä¿¡æ¯
    let user = get_current_user(&req)?;
    
    if !user.has_permission(&permission) {
        return Err(StatusCode::FORBIDDEN);
    }
    
    Ok(next.run(req).await)
}
```

---

## 2.4.6 WebSocket

### 2.4.6.1 åŸºç¡€å®ç°

**Axum WebSocket**:

```rust
use axum::{
    extract::ws::{Message, WebSocket, WebSocketUpgrade},
    response::Response,
};
use futures::{sink::SinkExt, stream::StreamExt};

async fn ws_handler(ws: WebSocketUpgrade) -> Response {
    ws.on_upgrade(handle_socket)
}

async fn handle_socket(mut socket: WebSocket) {
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(Message::Text(text)) => {
                // å¤„ç†æ–‡æœ¬æ¶ˆæ¯
                println!("Received: {}", text);
                
                // å‘é€å“åº”
                if socket
                    .send(Message::Text(format!("Echo: {}", text)))
                    .await
                    .is_err()
                {
                    break;
                }
            }
            Ok(Message::Binary(data)) => {
                // å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯
                println!("Received {} bytes", data.len());
            }
            Ok(Message::Close(_)) => {
                println!("Client disconnected");
                break;
            }
            Err(e) => {
                eprintln!("WebSocket error: {}", e);
                break;
            }
            _ => {}
        }
    }
}

// è·¯ç”±é…ç½®
let app = Router::new()
    .route("/ws", get(ws_handler));
```

### 2.4.6.2 æ¶ˆæ¯å¹¿æ’­

**å¹¿æ’­å®ç°**:

```rust
use tokio::sync::broadcast;
use std::sync::Arc;

type Tx = broadcast::Sender<String>;

struct AppState {
    tx: Tx,
}

async fn ws_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    ws.on_upgrade(|socket| handle_socket(socket, state))
}

async fn handle_socket(socket: WebSocket, state: Arc<AppState>) {
    let (mut sender, mut receiver) = socket.split();
    let mut rx = state.tx.subscribe();
    
    // æ¥æ”¶æ¶ˆæ¯å¹¶å¹¿æ’­
    let mut send_task = tokio::spawn(async move {
        while let Ok(msg) = rx.recv().await {
            if sender.send(Message::Text(msg)).await.is_err() {
                break;
            }
        }
    });
    
    // æ¥æ”¶å®¢æˆ·ç«¯æ¶ˆæ¯
    let tx = state.tx.clone();
    let mut recv_task = tokio::spawn(async move {
        while let Some(Ok(Message::Text(text))) = receiver.next().await {
            // å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
            let _ = tx.send(text);
        }
    });
    
    // ç­‰å¾…ä»»åŠ¡å®Œæˆ
    tokio::select! {
        _ = (&mut send_task) => recv_task.abort(),
        _ = (&mut recv_task) => send_task.abort(),
    };
}

#[tokio::main]
async fn main() {
    let (tx, _) = broadcast::channel(100);
    
    let state = Arc::new(AppState { tx });
    
    let app = Router::new()
        .route("/ws", get(ws_handler))
        .with_state(state);
    
    // å¯åŠ¨æœåŠ¡å™¨
}
```

### 2.4.6.3 å¿ƒè·³æœºåˆ¶

**å¿ƒè·³å®ç°**:

```rust
use std::time::Duration;

async fn handle_socket_with_heartbeat(mut socket: WebSocket) {
    let mut interval = tokio::time::interval(Duration::from_secs(30));
    
    loop {
        tokio::select! {
            msg = socket.recv() => {
                match msg {
                    Some(Ok(Message::Text(text))) => {
                        println!("Received: {}", text);
                    }
                    Some(Ok(Message::Pong(_))) => {
                        println!("Received pong");
                    }
                    Some(Ok(Message::Close(_))) => {
                        break;
                    }
                    _ => {}
                }
            }
            _ = interval.tick() => {
                // å‘é€å¿ƒè·³
                if socket.send(Message::Ping(vec![])).await.is_err() {
                    break;
                }
            }
        }
    }
}
```

---

## 2.4.7 æ€§èƒ½ä¼˜åŒ–

### 2.4.7.1 è¿æ¥å¤ç”¨

**HTTP/2 æ”¯æŒ**:

```rust
use axum::Router;

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(root));
    
    // ä½¿ç”¨ HTTP/2
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
}
```

### 2.4.7.2 å“åº”å‹ç¼©

**Gzip å‹ç¼©**:

```rust
use tower_http::compression::CompressionLayer;

let app = Router::new()
    .route("/", get(large_response))
    .layer(CompressionLayer::new());

async fn large_response() -> String {
    "A".repeat(100_000)
}
```

### 2.4.7.3 é™æ€èµ„æº

**é™æ€æ–‡ä»¶æœåŠ¡**:

```rust
use tower_http::services::ServeDir;

let app = Router::new()
    .nest_service("/static", ServeDir::new("static"));
```

---

## 2.4.8 ç”Ÿäº§éƒ¨ç½²

### 2.4.8.1 é…ç½®ç®¡ç†

**ç¯å¢ƒé…ç½®**:

```rust
use serde::Deserialize;

#[derive(Deserialize, Clone)]
pub struct Config {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
}

#[derive(Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Deserialize, Clone)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
}

pub fn load_config() -> Result<Config, config::ConfigError> {
    let config = config::Config::builder()
        .add_source(config::File::with_name("config/default"))
        .add_source(config::File::with_name("config/production").required(false))
        .add_source(config::Environment::with_prefix("APP"))
        .build()?;
    
    config.try_deserialize()
}
```

### 2.4.8.2 æ—¥å¿—è®°å½•

**ç»“æ„åŒ–æ—¥å¿—**:

```rust
use tracing::{info, error, instrument};

#[instrument]
async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, AppError> {
    info!(username = %payload.username, "Creating user");
    
    let user = sqlx::query_as::<_, User>(
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING *"
    )
    .bind(&payload.username)
    .bind(&payload.email)
    .fetch_one(&state.db)
    .await
    .map_err(|e| {
        error!(error = %e, "Failed to create user");
        AppError::Database(e)
    })?;
    
    info!(user_id = user.id, "User created successfully");
    
    Ok(Json(user))
}
```

### 2.4.8.3 å¥åº·æ£€æŸ¥

**å¥åº·æ£€æŸ¥ç«¯ç‚¹**:

```rust
use axum::http::StatusCode;

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    database: String,
    version: String,
}

async fn health_check(State(state): State<AppState>) -> (StatusCode, Json<HealthResponse>) {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    let db_status = match sqlx::query("SELECT 1")
        .execute(&state.db)
        .await
    {
        Ok(_) => "healthy",
        Err(_) => "unhealthy",
    };
    
    let status = if db_status == "healthy" {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    
    (status, Json(HealthResponse {
        status: "ok".to_string(),
        database: db_status.to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    }))
}
```

---

## 2.4.9 æœ€ä½³å®è·µ

### 2.4.9.1 é¡¹ç›®ç»“æ„

**æ¨èç»“æ„**:

```text
my-web-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs               # åº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ config.rs             # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ errors.rs             # é”™è¯¯å®šä¹‰
â”‚   â”œâ”€â”€ models/               # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ user.rs
â”‚   â”œâ”€â”€ routes/               # è·¯ç”±å¤„ç†
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ users.rs
â”‚   â”‚   â””â”€â”€ posts.rs
â”‚   â”œâ”€â”€ services/             # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ user_service.rs
â”‚   â”œâ”€â”€ middleware/           # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ auth.rs
â”‚   â””â”€â”€ utils/                # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ jwt.rs
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ default.yaml
â”‚   â””â”€â”€ production.yaml
â”œâ”€â”€ migrations/               # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ tests/                    # é›†æˆæµ‹è¯•
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .env
```

### 2.4.9.2 é”™è¯¯å¤„ç†

**ç»Ÿä¸€é”™è¯¯å“åº”**:

```rust
#[derive(Serialize)]
struct ErrorResponse {
    error: String,
    message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    details: Option<serde_json::Value>,
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg),
            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, "Unauthorized".to_string()),
            AppError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, "Database error".to_string()),
        };
        
        let body = Json(ErrorResponse {
            error: status.to_string(),
            message: error_message,
            details: None,
        });
        
        (status, body).into_response()
    }
}
```

### 2.4.9.3 å®‰å…¨å®è·µ

**å®‰å…¨æ£€æŸ¥æ¸…å•**:

1. âœ… **ä½¿ç”¨ HTTPS** - TLS åŠ å¯†ä¼ è¾“
2. âœ… **è¾“å…¥éªŒè¯** - éªŒè¯æ‰€æœ‰ç”¨æˆ·è¾“å…¥
3. âœ… **SQL æ³¨å…¥é˜²æŠ¤** - ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
4. âœ… **XSS é˜²æŠ¤** - è½¬ä¹‰ç”¨æˆ·è¾“å…¥
5. âœ… **CSRF é˜²æŠ¤** - ä½¿ç”¨ CSRF token
6. âœ… **é€Ÿç‡é™åˆ¶** - é˜²æ­¢ DDoS æ”»å‡»
7. âœ… **è®¤è¯æˆæƒ** - JWT æˆ– OAuth2
8. âœ… **æ•æ„Ÿæ•°æ®åŠ å¯†** - Argon2 å¯†ç å“ˆå¸Œ

```rust
use argon2::{
    password_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};

// å¯†ç å“ˆå¸Œ
pub fn hash_password(password: &str) -> Result<String, AppError> {
    let salt = SaltString::generate(&mut rand::thread_rng());
    let argon2 = Argon2::default();
    
    let password_hash = argon2
        .hash_password(password.as_bytes(), &salt)?
        .to_string();
    
    Ok(password_hash)
}

// å¯†ç éªŒè¯
pub fn verify_password(password: &str, hash: &str) -> Result<bool, AppError> {
    let parsed_hash = PasswordHash::new(hash)?;
    let argon2 = Argon2::default();
    
    Ok(argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å­¦ä¹ ç¤¾åŒº

---

**âœ… Rust Web æ¡†æ¶æŒ‡å—å®Œæˆï¼** ğŸ‰
