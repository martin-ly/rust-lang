# 2.5 Rust å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å— (2025)

> **æ–‡æ¡£å®šä½**: Rust å¼‚æ­¥è¿è¡Œæ—¶å®Œæ•´å®æˆ˜æŒ‡å—  
> **é€‚ç”¨äººç¾¤**: Rust å¼€å‘è€…ï¼Œå¹¶å‘ç¼–ç¨‹å·¥ç¨‹å¸ˆ  
> **å…³è”æ–‡æ¡£**: [3.1 Rust 1.90 ç‰¹æ€§å…¨è§£æ](../references/3.1_Rust_1.90_ç‰¹æ€§å…¨è§£æ.md) | [1.2 æœ¯è¯­è¡¨](../1.2_æœ¯è¯­è¡¨.md)

**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  
**æœ€åæ›´æ–°**: 2025-10-21

---

## ğŸ“‹ ç›®å½•

- [2.5 Rust å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å— (2025)](#25-rust-å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—-2025)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2.5.1 æ¦‚è¿°](#251-æ¦‚è¿°)
    - [2.5.1.1 ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥è¿è¡Œæ—¶ï¼Ÿ](#2511-ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥è¿è¡Œæ—¶)
    - [2.5.1.2 è¿è¡Œæ—¶æŠ€æœ¯æ ˆå¯¹æ¯”](#2512-è¿è¡Œæ—¶æŠ€æœ¯æ ˆå¯¹æ¯”)
  - [2.5.2 Tokio æ·±åº¦å®æˆ˜](#252-tokio-æ·±åº¦å®æˆ˜)
    - [2.5.2.1 é¡¹ç›®åˆå§‹åŒ–](#2521-é¡¹ç›®åˆå§‹åŒ–)
    - [2.5.2.2 ä»»åŠ¡è°ƒåº¦](#2522-ä»»åŠ¡è°ƒåº¦)
    - [2.5.2.3 Future å’Œ Poll](#2523-future-å’Œ-poll)
    - [2.5.2.4 å¼‚æ­¥é€šé“](#2524-å¼‚æ­¥é€šé“)
    - [2.5.2.5 åŒæ­¥åŸè¯­](#2525-åŒæ­¥åŸè¯­)
    - [2.5.2.6 å®šæ—¶å™¨](#2526-å®šæ—¶å™¨)
  - [2.5.3 async-std å®æˆ˜](#253-async-std-å®æˆ˜)
    - [2.5.3.1 åŸºç¡€ä½¿ç”¨](#2531-åŸºç¡€ä½¿ç”¨)
    - [2.5.3.2 ä»»åŠ¡å’Œæµ](#2532-ä»»åŠ¡å’Œæµ)
  - [2.5.4 å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼](#254-å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼)
    - [2.5.4.1 å¹¶å‘æ‰§è¡Œ](#2541-å¹¶å‘æ‰§è¡Œ)
    - [2.5.4.2 æµå¤„ç†](#2542-æµå¤„ç†)
    - [2.5.4.3 è¶…æ—¶å¤„ç†](#2543-è¶…æ—¶å¤„ç†)
  - [2.5.5 å¼‚æ­¥ I/O](#255-å¼‚æ­¥-io)
    - [2.5.5.1 æ–‡ä»¶ I/O](#2551-æ–‡ä»¶-io)
    - [2.5.5.2 ç½‘ç»œ I/O](#2552-ç½‘ç»œ-io)
    - [2.5.5.3 ç¼“å†² I/O](#2553-ç¼“å†²-io)
  - [2.5.6 é”™è¯¯å¤„ç†](#256-é”™è¯¯å¤„ç†)
    - [2.5.6.1 Result ä¼ æ’­](#2561-result-ä¼ æ’­)
    - [2.5.6.2 panic å¤„ç†](#2562-panic-å¤„ç†)
    - [2.5.6.3 å–æ¶ˆå®‰å…¨](#2563-å–æ¶ˆå®‰å…¨)
  - [2.5.7 æ€§èƒ½ä¼˜åŒ–](#257-æ€§èƒ½ä¼˜åŒ–)
    - [2.5.7.1 ä»»åŠ¡è°ƒåº¦å™¨](#2571-ä»»åŠ¡è°ƒåº¦å™¨)
    - [2.5.7.2 é›¶æ‹·è´](#2572-é›¶æ‹·è´)
    - [2.5.7.3 æ‰¹å¤„ç†](#2573-æ‰¹å¤„ç†)
  - [2.5.8 è°ƒè¯•å’Œæµ‹è¯•](#258-è°ƒè¯•å’Œæµ‹è¯•)
    - [2.5.8.1 å¼‚æ­¥æµ‹è¯•](#2581-å¼‚æ­¥æµ‹è¯•)
    - [2.5.8.2 Tracing](#2582-tracing)
    - [2.5.8.3 æ€§èƒ½åˆ†æ](#2583-æ€§èƒ½åˆ†æ)
  - [2.5.9 æœ€ä½³å®è·µ](#259-æœ€ä½³å®è·µ)
    - [2.5.9.1 ä»»åŠ¡è®¾è®¡](#2591-ä»»åŠ¡è®¾è®¡)
    - [2.5.9.2 èµ„æºç®¡ç†](#2592-èµ„æºç®¡ç†)
    - [2.5.9.3 é¿å…é˜»å¡](#2593-é¿å…é˜»å¡)

---

## 2.5.1 æ¦‚è¿°

### 2.5.1.1 ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥è¿è¡Œæ—¶ï¼Ÿ

**æ ¸å¿ƒä»·å€¼**:

1. âœ… **é«˜å¹¶å‘** - å•çº¿ç¨‹å¤„ç†ä¸Šä¸‡å¹¶å‘è¿æ¥
2. âœ… **ä½å¼€é”€** - é›¶æˆæœ¬æŠ½è±¡ï¼Œæ¥è¿‘æ‰‹å†™çŠ¶æ€æœº
3. âœ… **æ˜“ç”¨æ€§** - async/await è¯­æ³•ç®€å•ç›´è§‚
4. âœ… **çµæ´»æ€§** - è‡ªå®šä¹‰è¿è¡Œæ—¶å’Œè°ƒåº¦ç­–ç•¥
5. âœ… **ç”Ÿæ€å®Œæ•´** - ä¸°å¯Œçš„å¼‚æ­¥åº“ç”Ÿæ€

**åŒæ­¥ vs å¼‚æ­¥å¯¹æ¯”**:

```mermaid
graph LR
    A[è¯·æ±‚å¤„ç†æ¨¡å‹] --> B[åŒæ­¥æ¨¡å‹]
    A --> C[å¼‚æ­¥æ¨¡å‹]
    
    B --> B1[æ¯ä¸ªè¯·æ±‚ä¸€ä¸ªçº¿ç¨‹]
    B --> B2[çº¿ç¨‹åˆ‡æ¢å¼€é”€å¤§]
    B --> B3[å†…å­˜å ç”¨é«˜]
    
    C --> C1[å•çº¿ç¨‹å¤šä»»åŠ¡]
    C --> C2[äº‹ä»¶é©±åŠ¨]
    C --> C3[å†…å­˜å ç”¨ä½]
    
    style C fill:#90EE90
    style B fill:#FFB6C1
```

### 2.5.1.2 è¿è¡Œæ—¶æŠ€æœ¯æ ˆå¯¹æ¯”

| è¿è¡Œæ—¶ | è°ƒåº¦å™¨ | ç‰¹ç‚¹ | æ€§èƒ½ | ç”Ÿæ€ | æˆç†Ÿåº¦ |
|--------|--------|------|------|------|--------|
| **Tokio** | å·¥ä½œçªƒå– | åŠŸèƒ½å®Œæ•´ï¼Œé«˜æ€§èƒ½ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **async-std** | å·¥ä½œçªƒå– | ç±»ä¼¼ stdï¼Œæ˜“ç”¨ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| **smol** | å•çº¿ç¨‹ | è½»é‡çº§ï¼Œç®€å• | â­â­â­â­ | â­â­â­ | â­â­â­ |

---

## 2.5.2 Tokio æ·±åº¦å®æˆ˜

### 2.5.2.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# Tokio è¿è¡Œæ—¶
tokio = { version = "1.48", features = [
    "full",           # æ‰€æœ‰ç‰¹æ€§
    "macros",         # #[tokio::main] å’Œ #[tokio::test]
    "rt-multi-thread", # å¤šçº¿ç¨‹è¿è¡Œæ—¶
    "io-util",        # I/O å·¥å…·
    "net",            # ç½‘ç»œ
    "time",           # å®šæ—¶å™¨
    "sync",           # åŒæ­¥åŸè¯­
    "signal",         # ä¿¡å·å¤„ç†
] }

# Future å·¥å…·
futures = "0.3"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "2.0"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = "0.3"
```

**åŸºç¡€åº”ç”¨**:

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("Hello, Tokio!");
    
    sleep(Duration::from_secs(1)).await;
    
    println!("1 second passed");
}
```

**è¿è¡Œæ—¶é…ç½®**:

```rust
use tokio::runtime::Runtime;

fn main() {
    // å•çº¿ç¨‹è¿è¡Œæ—¶
    let rt = Runtime::new().unwrap();
    
    rt.block_on(async {
        println!("Running on single thread");
    });
    
    // å¤šçº¿ç¨‹è¿è¡Œæ—¶
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(4)                    // å·¥ä½œçº¿ç¨‹æ•°
        .thread_name("my-tokio-worker")       // çº¿ç¨‹åç§°
        .thread_stack_size(3 * 1024 * 1024)  // æ ˆå¤§å° 3MB
        .enable_all()                         // å¯ç”¨æ‰€æœ‰ç‰¹æ€§
        .build()
        .unwrap();
    
    rt.block_on(async {
        println!("Running on multi-thread runtime");
    });
}
```

### 2.5.2.2 ä»»åŠ¡è°ƒåº¦

**spawn ä»»åŠ¡**:

```rust
use tokio::task;

#[tokio::main]
async fn main() {
    // ç”Ÿæˆå¼‚æ­¥ä»»åŠ¡
    let handle = task::spawn(async {
        println!("Task running");
        42
    });
    
    // ç­‰å¾…ä»»åŠ¡å®Œæˆ
    let result = handle.await.unwrap();
    println!("Task result: {}", result);
}
```

**spawn_blocking é˜»å¡ä»»åŠ¡**:

```rust
#[tokio::main]
async fn main() {
    // åœ¨é˜»å¡çº¿ç¨‹æ± ä¸­æ‰§è¡Œ
    let handle = task::spawn_blocking(|| {
        // CPU å¯†é›†å‹æˆ–é˜»å¡æ“ä½œ
        std::thread::sleep(Duration::from_secs(1));
        println!("Blocking task complete");
        42
    });
    
    let result = handle.await.unwrap();
    println!("Result: {}", result);
}
```

**JoinSet ç®¡ç†å¤šä»»åŠ¡**:

```rust
use tokio::task::JoinSet;

#[tokio::main]
async fn main() {
    let mut set = JoinSet::new();
    
    // æ·»åŠ ä»»åŠ¡
    for i in 0..10 {
        set.spawn(async move {
            sleep(Duration::from_millis(100 * i)).await;
            i
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    while let Some(res) = set.join_next().await {
        match res {
            Ok(n) => println!("Task {} completed", n),
            Err(e) => eprintln!("Task failed: {}", e),
        }
    }
}
```

### 2.5.2.3 Future å’Œ Poll

**è‡ªå®šä¹‰ Future**:

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct MyFuture {
    count: u32,
}

impl Future for MyFuture {
    type Output = u32;
    
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        self.count += 1;
        
        if self.count < 3 {
            // è¿˜æœªå°±ç»ªï¼Œé€šçŸ¥ waker å†æ¬¡ poll
            cx.waker().wake_by_ref();
            Poll::Pending
        } else {
            // å°±ç»ªï¼Œè¿”å›ç»“æœ
            Poll::Ready(self.count)
        }
    }
}

#[tokio::main]
async fn main() {
    let future = MyFuture { count: 0 };
    let result = future.await;
    println!("Result: {}", result);  // è¾“å‡º: Result: 3
}
```

**Pin å’Œ Unpin**:

```rust
use std::pin::Pin;

async fn process_data(data: String) -> usize {
    data.len()
}

#[tokio::main]
async fn main() {
    let data = String::from("Hello");
    
    // Pin future
    let future = process_data(data);
    let pinned = Box::pin(future);
    
    let result = pinned.await;
    println!("Length: {}", result);
}
```

### 2.5.2.4 å¼‚æ­¥é€šé“

**mpsc (å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…)**:

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);  // ç¼“å†²åŒºå¤§å° 32
    
    // ç”Ÿäº§è€…
    tokio::spawn(async move {
        for i in 0..10 {
            if tx.send(i).await.is_err() {
                break;
            }
        }
    });
    
    // æ¶ˆè´¹è€…
    while let Some(value) = rx.recv().await {
        println!("Received: {}", value);
    }
}
```

**oneshot (å•æ¬¡é€šä¿¡)**:

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx, rx) = oneshot::channel();
    
    tokio::spawn(async move {
        // å‘é€ä¸€æ¬¡
        if tx.send(42).is_err() {
            println!("Receiver dropped");
        }
    });
    
    match rx.await {
        Ok(value) => println!("Received: {}", value),
        Err(_) => println!("Sender dropped"),
    }
}
```

**broadcast (å¹¿æ’­)**:

```rust
use tokio::sync::broadcast;

#[tokio::main]
async fn main() {
    let (tx, mut rx1) = broadcast::channel(16);
    let mut rx2 = tx.subscribe();
    
    // å‘é€è€…
    tokio::spawn(async move {
        for i in 0..5 {
            tx.send(i).unwrap();
        }
    });
    
    // æ¥æ”¶è€… 1
    tokio::spawn(async move {
        while let Ok(value) = rx1.recv().await {
            println!("Receiver 1: {}", value);
        }
    });
    
    // æ¥æ”¶è€… 2
    tokio::spawn(async move {
        while let Ok(value) = rx2.recv().await {
            println!("Receiver 2: {}", value);
        }
    });
    
    sleep(Duration::from_secs(1)).await;
}
```

**watch (çŠ¶æ€åŒæ­¥)**:

```rust
use tokio::sync::watch;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = watch::channel(0);
    
    // æ›´æ–°è€…
    tokio::spawn(async move {
        for i in 1..=5 {
            tx.send(i).unwrap();
            sleep(Duration::from_millis(100)).await;
        }
    });
    
    // è§‚å¯Ÿè€…
    while rx.changed().await.is_ok() {
        println!("Value changed to: {}", *rx.borrow());
    }
}
```

### 2.5.2.5 åŒæ­¥åŸè¯­

**Mutex (äº’æ–¥é”)**:

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = tokio::spawn(async move {
            let mut num = counter.lock().await;
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("Counter: {}", *counter.lock().await);
}
```

**RwLock (è¯»å†™é”)**:

```rust
use tokio::sync::RwLock;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    
    // è¯»è€…
    let data_clone = Arc::clone(&data);
    tokio::spawn(async move {
        let read_guard = data_clone.read().await;
        println!("Read: {:?}", *read_guard);
    });
    
    // å†™è€…
    let data_clone = Arc::clone(&data);
    tokio::spawn(async move {
        let mut write_guard = data_clone.write().await;
        write_guard.push(4);
    });
    
    sleep(Duration::from_millis(100)).await;
}
```

**Semaphore (ä¿¡å·é‡)**:

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));  // æœ€å¤š 3 ä¸ªå¹¶å‘
    let mut handles = vec![];
    
    for i in 0..10 {
        let permit = semaphore.clone();
        let handle = tokio::spawn(async move {
            let _permit = permit.acquire().await.unwrap();
            println!("Task {} acquired permit", i);
            sleep(Duration::from_secs(1)).await;
            println!("Task {} released permit", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

**Barrier (å±éšœ)**:

```rust
use tokio::sync::Barrier;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let barrier = Arc::new(Barrier::new(5));
    let mut handles = vec![];
    
    for i in 0..5 {
        let barrier = Arc::clone(&barrier);
        let handle = tokio::spawn(async move {
            println!("Task {} waiting at barrier", i);
            barrier.wait().await;
            println!("Task {} passed barrier", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 2.5.2.6 å®šæ—¶å™¨

**sleep å»¶è¿Ÿ**:

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("Start");
    sleep(Duration::from_secs(1)).await;
    println!("1 second passed");
}
```

**interval å®šæ—¶å™¨**:

```rust
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() {
    let mut interval = interval(Duration::from_secs(1));
    
    for i in 0..5 {
        interval.tick().await;
        println!("Tick {}", i);
    }
}
```

**timeout è¶…æ—¶**:

```rust
use tokio::time::{timeout, Duration, sleep};

#[tokio::main]
async fn main() {
    let result = timeout(Duration::from_secs(1), async {
        sleep(Duration::from_secs(2)).await;
        "completed"
    }).await;
    
    match result {
        Ok(value) => println!("Completed: {}", value),
        Err(_) => println!("Timeout!"),
    }
}
```

---

## 2.5.3 async-std å®æˆ˜

### 2.5.3.1 åŸºç¡€ä½¿ç”¨

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
async-std = { version = "1.13", features = ["attributes"] }
```

**åŸºç¡€åº”ç”¨**:

```rust
use async_std::task;
use async_std::prelude::*;

#[async_std::main]
async fn main() {
    println!("Hello, async-std!");
    
    task::sleep(std::time::Duration::from_secs(1)).await;
    
    println!("1 second passed");
}
```

### 2.5.3.2 ä»»åŠ¡å’Œæµ

**spawn ä»»åŠ¡**:

```rust
use async_std::task;

#[async_std::main]
async fn main() {
    let handle = task::spawn(async {
        println!("Task running");
        42
    });
    
    let result = handle.await;
    println!("Result: {}", result);
}
```

**æµå¤„ç†**:

```rust
use async_std::stream::{self, StreamExt};

#[async_std::main]
async fn main() {
    let mut stream = stream::from_iter(1..=5);
    
    while let Some(value) = stream.next().await {
        println!("Value: {}", value);
    }
}
```

---

## 2.5.4 å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼

### 2.5.4.1 å¹¶å‘æ‰§è¡Œ

**join! å®**:

```rust
use tokio::join;

#[tokio::main]
async fn main() {
    let future1 = async { 1 + 1 };
    let future2 = async { 2 + 2 };
    let future3 = async { 3 + 3 };
    
    // å¹¶å‘æ‰§è¡Œï¼Œç­‰å¾…æ‰€æœ‰å®Œæˆ
    let (result1, result2, result3) = join!(future1, future2, future3);
    
    println!("Results: {}, {}, {}", result1, result2, result3);
}
```

**select! å®**:

```rust
use tokio::select;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let future1 = sleep(Duration::from_secs(1));
    let future2 = sleep(Duration::from_secs(2));
    
    select! {
        _ = future1 => println!("Future 1 completed first"),
        _ = future2 => println!("Future 2 completed first"),
    }
}
```

**FuturesUnordered**:

```rust
use futures::stream::{FuturesUnordered, StreamExt};

#[tokio::main]
async fn main() {
    let mut futures = FuturesUnordered::new();
    
    for i in 0..5 {
        futures.push(async move {
            sleep(Duration::from_millis(100 * i)).await;
            i
        });
    }
    
    while let Some(result) = futures.next().await {
        println!("Completed: {}", result);
    }
}
```

### 2.5.4.2 æµå¤„ç†

**Stream trait**:

```rust
use futures::stream::{self, StreamExt};

#[tokio::main]
async fn main() {
    let stream = stream::iter(1..=10)
        .filter(|x| futures::future::ready(x % 2 == 0))
        .map(|x| x * 2);
    
    let results: Vec<_> = stream.collect().await;
    println!("Results: {:?}", results);
}
```

**å¼‚æ­¥è¿­ä»£**:

```rust
use futures::stream::{self, StreamExt};

#[tokio::main]
async fn main() {
    let mut stream = stream::iter(1..=5);
    
    while let Some(value) = stream.next().await {
        println!("Processing: {}", value);
        sleep(Duration::from_millis(100)).await;
    }
}
```

### 2.5.4.3 è¶…æ—¶å¤„ç†

**tokio::time::timeout**:

```rust
use tokio::time::{timeout, Duration};

async fn fetch_data() -> Result<String, String> {
    sleep(Duration::from_secs(2)).await;
    Ok("data".to_string())
}

#[tokio::main]
async fn main() {
    match timeout(Duration::from_secs(1), fetch_data()).await {
        Ok(Ok(data)) => println!("Got data: {}", data),
        Ok(Err(e)) => println!("Fetch error: {}", e),
        Err(_) => println!("Timeout!"),
    }
}
```

---

## 2.5.5 å¼‚æ­¥ I/O

### 2.5.5.1 æ–‡ä»¶ I/O

**è¯»å–æ–‡ä»¶**:

```rust
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // è¯»å–æ–‡ä»¶
    let mut file = File::open("example.txt").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    println!("File contents: {}", contents);
    
    // å†™å…¥æ–‡ä»¶
    let mut file = File::create("output.txt").await?;
    file.write_all(b"Hello, async file!").await?;
    
    Ok(())
}
```

**æ–‡ä»¶å…ƒæ•°æ®**:

```rust
use tokio::fs;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let metadata = fs::metadata("example.txt").await?;
    println!("File size: {} bytes", metadata.len());
    println!("Is file: {}", metadata.is_file());
    
    Ok(())
}
```

### 2.5.5.2 ç½‘ç»œ I/O

**TCP å®¢æˆ·ç«¯**:

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    
    // å‘é€æ•°æ®
    stream.write_all(b"Hello, server!").await?;
    
    // æ¥æ”¶æ•°æ®
    let mut buffer = [0; 1024];
    let n = stream.read(&mut buffer).await?;
    println!("Received: {}", String::from_utf8_lossy(&buffer[..n]));
    
    Ok(())
}
```

**TCP æœåŠ¡å™¨**:

```rust
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("Server listening on port 8080");
    
    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!("New connection from: {}", addr);
        
        tokio::spawn(async move {
            let mut buffer = [0; 1024];
            
            loop {
                match socket.read(&mut buffer).await {
                    Ok(0) => break,  // è¿æ¥å…³é—­
                    Ok(n) => {
                        // å›æ˜¾æ•°æ®
                        if socket.write_all(&buffer[..n]).await.is_err() {
                            break;
                        }
                    }
                    Err(_) => break,
                }
            }
        });
    }
}
```

### 2.5.5.3 ç¼“å†² I/O

**BufReader å’Œ BufWriter**:

```rust
use tokio::fs::File;
use tokio::io::{BufReader, BufWriter, AsyncBufReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ç¼“å†²è¯»å–
    let file = File::open("example.txt").await?;
    let reader = BufReader::new(file);
    
    let mut lines = reader.lines();
    while let Some(line) = lines.next_line().await? {
        println!("Line: {}", line);
    }
    
    // ç¼“å†²å†™å…¥
    let file = File::create("output.txt").await?;
    let mut writer = BufWriter::new(file);
    writer.write_all(b"Line 1\n").await?;
    writer.write_all(b"Line 2\n").await?;
    writer.flush().await?;
    
    Ok(())
}
```

---

## 2.5.6 é”™è¯¯å¤„ç†

### 2.5.6.1 Result ä¼ æ’­

**? æ“ä½œç¬¦**:

```rust
async fn fetch_user(id: u64) -> Result<User, AppError> {
    let db = get_database().await?;
    let user = db.query_user(id).await?;
    Ok(user)
}
```

**è‡ªå®šä¹‰é”™è¯¯**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum AppError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("User not found: {0}")]
    UserNotFound(u64),
}
```

### 2.5.6.2 panic å¤„ç†

**catch_unwind**:

```rust
use std::panic::catch_unwind;

#[tokio::main]
async fn main() {
    let handle = tokio::spawn(async {
        panic!("Task panic!");
    });
    
    match handle.await {
        Ok(_) => println!("Task completed"),
        Err(e) => {
            if e.is_panic() {
                println!("Task panicked");
            }
        }
    }
}
```

### 2.5.6.3 å–æ¶ˆå®‰å…¨

**CancellationToken**:

```rust
use tokio_util::sync::CancellationToken;

#[tokio::main]
async fn main() {
    let token = CancellationToken::new();
    let token_clone = token.clone();
    
    let handle = tokio::spawn(async move {
        loop {
            tokio::select! {
                _ = token_clone.cancelled() => {
                    println!("Task cancelled");
                    break;
                }
                _ = sleep(Duration::from_secs(1)) => {
                    println!("Working...");
                }
            }
        }
    });
    
    sleep(Duration::from_secs(3)).await;
    token.cancel();
    
    handle.await.unwrap();
}
```

---

## 2.5.7 æ€§èƒ½ä¼˜åŒ–

### 2.5.7.1 ä»»åŠ¡è°ƒåº¦å™¨

**å·¥ä½œçªƒå–è°ƒåº¦å™¨**:

```rust
// Tokio é»˜è®¤ä½¿ç”¨å·¥ä½œçªƒå–è°ƒåº¦å™¨
let rt = tokio::runtime::Builder::new_multi_thread()
    .worker_threads(num_cpus::get())  // CPU æ ¸å¿ƒæ•°
    .enable_all()
    .build()
    .unwrap();
```

### 2.5.7.2 é›¶æ‹·è´

**bytes crate**:

```rust
use bytes::{Bytes, BytesMut, BufMut};

fn process_data() {
    let mut buf = BytesMut::with_capacity(1024);
    buf.put(&b"Hello"[..]);
    
    // é›¶æ‹·è´è½¬æ¢
    let bytes: Bytes = buf.freeze();
    
    // é›¶æ‹·è´åˆ‡ç‰‡
    let slice = bytes.slice(0..5);
}
```

### 2.5.7.3 æ‰¹å¤„ç†

**æ‰¹é‡æ“ä½œ**:

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(100);
    
    // æ‰¹é‡å‘é€
    tokio::spawn(async move {
        for i in 0..100 {
            tx.send(i).await.unwrap();
        }
    });
    
    // æ‰¹é‡å¤„ç†
    let mut batch = Vec::new();
    while let Some(value) = rx.recv().await {
        batch.push(value);
        
        if batch.len() >= 10 {
            process_batch(&batch).await;
            batch.clear();
        }
    }
}

async fn process_batch(batch: &[i32]) {
    println!("Processing batch of {} items", batch.len());
}
```

---

## 2.5.8 è°ƒè¯•å’Œæµ‹è¯•

### 2.5.8.1 å¼‚æ­¥æµ‹è¯•

**tokio::test**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_async_function() {
        let result = fetch_data().await.unwrap();
        assert_eq!(result, "data");
    }
    
    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
    async fn test_concurrent() {
        let (result1, result2) = tokio::join!(
            async { 1 + 1 },
            async { 2 + 2 },
        );
        assert_eq!(result1, 2);
        assert_eq!(result2, 4);
    }
}
```

### 2.5.8.2 Tracing

**Tokio Console**:

```toml
[dependencies]
console-subscriber = "0.4"
```

```rust
#[tokio::main]
async fn main() {
    console_subscriber::init();
    
    // åº”ç”¨ä»£ç 
}
```

### 2.5.8.3 æ€§èƒ½åˆ†æ

**æ—¶é—´ç»Ÿè®¡**:

```rust
use std::time::Instant;

#[tokio::main]
async fn main() {
    let start = Instant::now();
    
    expensive_operation().await;
    
    let duration = start.elapsed();
    println!("Operation took: {:?}", duration);
}
```

---

## 2.5.9 æœ€ä½³å®è·µ

### 2.5.9.1 ä»»åŠ¡è®¾è®¡

**ä»»åŠ¡ç²’åº¦**:

```rust
// âœ… å¥½çš„è®¾è®¡ - åˆç†çš„ä»»åŠ¡ç²’åº¦
async fn process_user(user_id: u64) -> Result<()> {
    let user = fetch_user(user_id).await?;
    let posts = fetch_user_posts(user_id).await?;
    update_user_stats(&user, &posts).await?;
    Ok(())
}

// âŒ ä¸å¥½çš„è®¾è®¡ - ä»»åŠ¡è¿‡å°
async fn tiny_task() {
    1 + 1
}
```

### 2.5.9.2 èµ„æºç®¡ç†

**è¿æ¥æ± **:

```rust
use sqlx::postgres::PgPoolOptions;

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect("postgres://localhost/mydb")
        .await?;
    
    // ä½¿ç”¨è¿æ¥æ± 
    let row: (i64,) = sqlx::query_as("SELECT 1")
        .fetch_one(&pool)
        .await?;
    
    Ok(())
}
```

### 2.5.9.3 é¿å…é˜»å¡

**é˜»å¡æ“ä½œå¤„ç†**:

```rust
use tokio::task;

#[tokio::main]
async fn main() {
    // âŒ ä¸è¦åœ¨å¼‚æ­¥ä»»åŠ¡ä¸­ç›´æ¥é˜»å¡
    // std::thread::sleep(Duration::from_secs(1));
    
    // âœ… ä½¿ç”¨å¼‚æ­¥ sleep
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // âœ… æˆ–å°†é˜»å¡æ“ä½œç§»åˆ°ä¸“ç”¨çº¿ç¨‹
    task::spawn_blocking(|| {
        std::thread::sleep(Duration::from_secs(1));
    }).await.unwrap();
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å­¦ä¹ ç¤¾åŒº

---

**âœ… Rust å¼‚æ­¥è¿è¡Œæ—¶æŒ‡å—å®Œæˆï¼** ğŸ‰
