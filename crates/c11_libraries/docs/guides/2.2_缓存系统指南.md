# 2.2 Rust 缓存系统指南 (2025)

> **文档定位**: Rust 缓存系统完整实战指南  
> **适用人群**: 后端开发者，性能优化工程师  
> **关联文档**: [3.2 开源库生态全景图](../references/3.2_开源库生态全景图.md) | [2.1 数据库集成指南](./2.1_数据库集成指南.md)

## 📊 目录

- [2.2 Rust 缓存系统指南 (2025)](#22-rust-缓存系统指南-2025)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [2.2.1 概述](#221-概述)
    - [2.2.1.1 为什么需要缓存？](#2211-为什么需要缓存)
    - [2.2.1.2 缓存技术栈对比](#2212-缓存技术栈对比)
  - [2.2.2 Redis 深度实战](#222-redis-深度实战)
    - [2.2.2.1 项目初始化](#2221-项目初始化)
    - [2.2.2.2 基础操作](#2222-基础操作)
    - [2.2.2.3 数据结构](#2223-数据结构)
    - [2.2.2.4 高级特性](#2224-高级特性)
    - [2.2.2.5 发布订阅](#2225-发布订阅)
    - [2.2.2.6 分布式锁](#2226-分布式锁)
  - [2.2.3 本地缓存](#223-本地缓存)
    - [2.2.3.1 Moka 缓存](#2231-moka-缓存)
    - [2.2.3.2 Cached 缓存](#2232-cached-缓存)
  - [2.2.4 缓存策略](#224-缓存策略)
    - [2.2.4.1 缓存模式](#2241-缓存模式)
    - [2.2.4.2 过期策略](#2242-过期策略)
    - [2.2.4.3 淘汰策略](#2243-淘汰策略)
  - [2.2.5 缓存问题](#225-缓存问题)
    - [2.2.5.1 缓存穿透](#2251-缓存穿透)
    - [2.2.5.2 缓存击穿](#2252-缓存击穿)
    - [2.2.5.3 缓存雪崩](#2253-缓存雪崩)
  - [2.2.6 性能优化](#226-性能优化)
    - [2.2.6.1 连接池优化](#2261-连接池优化)
    - [2.2.6.2 批量操作](#2262-批量操作)
    - [2.2.6.3 Pipeline 优化](#2263-pipeline-优化)
  - [2.2.7 生产实践](#227-生产实践)
    - [2.2.7.1 监控告警](#2271-监控告警)
    - [2.2.7.2 高可用方案](#2272-高可用方案)
    - [2.2.7.3 容量规划](#2273-容量规划)
  - [2.2.8 最佳实践](#228-最佳实践)
    - [2.2.8.1 命名规范](#2281-命名规范)
    - [2.2.8.2 序列化方案](#2282-序列化方案)
    - [2.2.8.3 安全实践](#2283-安全实践)

**Rust 版本**: 1.90  
**文档状态**: ✅ 生产就绪  
**最后更新**: 2025-10-21

---

## 📋 目录

- [2.2 Rust 缓存系统指南 (2025)](#22-rust-缓存系统指南-2025)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [2.2.1 概述](#221-概述)
    - [2.2.1.1 为什么需要缓存？](#2211-为什么需要缓存)
    - [2.2.1.2 缓存技术栈对比](#2212-缓存技术栈对比)
  - [2.2.2 Redis 深度实战](#222-redis-深度实战)
    - [2.2.2.1 项目初始化](#2221-项目初始化)
    - [2.2.2.2 基础操作](#2222-基础操作)
    - [2.2.2.3 数据结构](#2223-数据结构)
    - [2.2.2.4 高级特性](#2224-高级特性)
    - [2.2.2.5 发布订阅](#2225-发布订阅)
    - [2.2.2.6 分布式锁](#2226-分布式锁)
  - [2.2.3 本地缓存](#223-本地缓存)
    - [2.2.3.1 Moka 缓存](#2231-moka-缓存)
    - [2.2.3.2 Cached 缓存](#2232-cached-缓存)
  - [2.2.4 缓存策略](#224-缓存策略)
    - [2.2.4.1 缓存模式](#2241-缓存模式)
    - [2.2.4.2 过期策略](#2242-过期策略)
    - [2.2.4.3 淘汰策略](#2243-淘汰策略)
  - [2.2.5 缓存问题](#225-缓存问题)
    - [2.2.5.1 缓存穿透](#2251-缓存穿透)
    - [2.2.5.2 缓存击穿](#2252-缓存击穿)
    - [2.2.5.3 缓存雪崩](#2253-缓存雪崩)
  - [2.2.6 性能优化](#226-性能优化)
    - [2.2.6.1 连接池优化](#2261-连接池优化)
    - [2.2.6.2 批量操作](#2262-批量操作)
    - [2.2.6.3 Pipeline 优化](#2263-pipeline-优化)
  - [2.2.7 生产实践](#227-生产实践)
    - [2.2.7.1 监控告警](#2271-监控告警)
    - [2.2.7.2 高可用方案](#2272-高可用方案)
    - [2.2.7.3 容量规划](#2273-容量规划)
  - [2.2.8 最佳实践](#228-最佳实践)
    - [2.2.8.1 命名规范](#2281-命名规范)
    - [2.2.8.2 序列化方案](#2282-序列化方案)
    - [2.2.8.3 安全实践](#2283-安全实践)

---

## 2.2.1 概述

### 2.2.1.1 为什么需要缓存？

**核心价值**:

1. ✅ **性能提升** - 内存访问比数据库快 100-1000 倍
2. ✅ **降低负载** - 减少数据库查询压力
3. ✅ **提高可用性** - 数据库故障时仍可提供服务
4. ✅ **节省成本** - 减少数据库资源消耗
5. ✅ **改善体验** - 毫秒级响应时间

**性能对比**:

| 存储类型 | 平均延迟 | 吞吐量 | 适用场景 |
|---------|---------|--------|---------|
| **内存缓存 (Moka)** | 1-10 μs | 100M+ ops/s | 热点数据，高频读 |
| **Redis** | 0.1-1 ms | 100K+ ops/s | 分布式缓存，会话 |
| **PostgreSQL** | 10-100 ms | 1K-10K ops/s | 持久化存储 |

### 2.2.1.2 缓存技术栈对比

| 方案 | 类型 | 特点 | 性能 | 复杂度 | 适用场景 | 成熟度 |
|------|------|------|------|--------|----------|--------|
| **Redis** | 远程缓存 | 分布式，持久化 | ⭐⭐⭐⭐ | ⭐⭐⭐ | 分布式系统 | ⭐⭐⭐⭐⭐ |
| **Moka** | 本地缓存 | 高性能，零延迟 | ⭐⭐⭐⭐⭐ | ⭐⭐ | 单机应用 | ⭐⭐⭐⭐ |
| **Cached** | 本地缓存 | 宏驱动，易用 | ⭐⭐⭐⭐ | ⭐ | 快速集成 | ⭐⭐⭐ |

---

## 2.2.2 Redis 深度实战

### 2.2.2.1 项目初始化

**依赖配置**:

```toml
[dependencies]
# Redis 客户端
redis = { version = "1.0.0-rc.2", features = [
    "tokio-comp",           # Tokio 异步支持
    "connection-manager",   # 连接管理器
    "cluster",              # 集群支持
    "streams",              # Stream 支持
    "script",               # Lua 脚本支持
] }

# 异步运行时
tokio = { version = "1.48", features = ["full"] }

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 错误处理
anyhow = "1.0"
thiserror = "2.0"

# 日志
tracing = "0.1"
```

**连接配置**:

```rust
use redis::{Client, aio::ConnectionManager};
use anyhow::Result;

pub struct RedisConfig {
    pub url: String,
    pub max_connections: u32,
    pub connect_timeout_ms: u64,
    pub command_timeout_ms: u64,
}

impl Default for RedisConfig {
    fn default() -> Self {
        Self {
            url: "redis://localhost:6379".to_string(),
            max_connections: 10,
            connect_timeout_ms: 5000,
            command_timeout_ms: 3000,
        }
    }
}

pub async fn create_redis_client(config: RedisConfig) -> Result<Client> {
    let client = Client::open(config.url)?;
    Ok(client)
}

pub async fn create_connection_manager(client: &Client) -> Result<ConnectionManager> {
    let manager = ConnectionManager::new(client.clone()).await?;
    Ok(manager)
}
```

### 2.2.2.2 基础操作

**String 操作**:

```rust
use redis::AsyncCommands;

// SET/GET
pub async fn basic_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 设置键值
    conn.set("key", "value").await?;
    
    // 获取值
    let value: String = conn.get("key").await?;
    println!("Value: {}", value);
    
    // 设置带过期时间
    conn.set_ex("session:123", "user_data", 3600).await?;
    
    // 设置 NX (仅当不存在时)
    let set: bool = conn.set_nx("lock", "1").await?;
    
    // 设置多个键值
    conn.mset(&[("key1", "value1"), ("key2", "value2")]).await?;
    
    // 获取多个值
    let values: Vec<String> = conn.mget(&["key1", "key2"]).await?;
    
    // 递增/递减
    let count: i64 = conn.incr("counter", 1).await?;
    let count: i64 = conn.decr("counter", 1).await?;
    
    // 获取并设置
    let old_value: Option<String> = conn.getset("key", "new_value").await?;
    
    Ok(())
}
```

**键操作**:

```rust
pub async fn key_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 检查键是否存在
    let exists: bool = conn.exists("key").await?;
    
    // 删除键
    let deleted: i32 = conn.del("key").await?;
    
    // 设置过期时间 (秒)
    conn.expire("key", 3600).await?;
    
    // 设置过期时间 (毫秒)
    conn.pexpire("key", 3600000).await?;
    
    // 查询剩余 TTL
    let ttl: i64 = conn.ttl("key").await?;
    
    // 移除过期时间
    conn.persist("key").await?;
    
    // 重命名键
    conn.rename("old_key", "new_key").await?;
    
    Ok(())
}
```

### 2.2.2.3 数据结构

**Hash 哈希表**:

```rust
pub async fn hash_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 设置单个字段
    conn.hset("user:1000", "name", "Alice").await?;
    
    // 设置多个字段
    conn.hset_multiple("user:1000", &[
        ("email", "alice@example.com"),
        ("age", "25"),
    ]).await?;
    
    // 获取单个字段
    let name: String = conn.hget("user:1000", "name").await?;
    
    // 获取所有字段
    let user: std::collections::HashMap<String, String> = 
        conn.hgetall("user:1000").await?;
    
    // 获取多个字段
    let values: Vec<String> = conn.hmget("user:1000", &["name", "email"]).await?;
    
    // 递增字段值
    let age: i64 = conn.hincr("user:1000", "age", 1).await?;
    
    // 检查字段是否存在
    let exists: bool = conn.hexists("user:1000", "name").await?;
    
    // 删除字段
    conn.hdel("user:1000", "age").await?;
    
    // 获取所有字段名
    let keys: Vec<String> = conn.hkeys("user:1000").await?;
    
    // 获取字段数量
    let count: i64 = conn.hlen("user:1000").await?;
    
    Ok(())
}
```

**List 列表**:

```rust
pub async fn list_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 左侧推入
    conn.lpush("queue", "task1").await?;
    
    // 右侧推入
    conn.rpush("queue", "task2").await?;
    
    // 左侧弹出
    let task: Option<String> = conn.lpop("queue", None).await?;
    
    // 右侧弹出
    let task: Option<String> = conn.rpop("queue", None).await?;
    
    // 获取列表长度
    let len: i64 = conn.llen("queue").await?;
    
    // 获取范围元素
    let items: Vec<String> = conn.lrange("queue", 0, -1).await?;
    
    // 通过索引获取元素
    let item: String = conn.lindex("queue", 0).await?;
    
    // 通过索引设置元素
    conn.lset("queue", 0, "new_task").await?;
    
    // 修剪列表
    conn.ltrim("queue", 0, 99).await?;
    
    // 阻塞式弹出 (超时 5 秒)
    let result: Option<(String, String)> = conn.blpop("queue", 5.0).await?;
    
    Ok(())
}
```

**Set 集合**:

```rust
pub async fn set_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 添加成员
    conn.sadd("tags", "rust").await?;
    conn.sadd("tags", &["programming", "systems"]).await?;
    
    // 删除成员
    conn.srem("tags", "rust").await?;
    
    // 检查成员是否存在
    let exists: bool = conn.sismember("tags", "rust").await?;
    
    // 获取所有成员
    let members: Vec<String> = conn.smembers("tags").await?;
    
    // 获取成员数量
    let count: i64 = conn.scard("tags").await?;
    
    // 随机获取成员
    let member: Option<String> = conn.srandmember("tags").await?;
    
    // 弹出随机成员
    let member: Option<String> = conn.spop("tags").await?;
    
    // 集合运算
    let union: Vec<String> = conn.sunion(&["set1", "set2"]).await?;
    let inter: Vec<String> = conn.sinter(&["set1", "set2"]).await?;
    let diff: Vec<String> = conn.sdiff(&["set1", "set2"]).await?;
    
    Ok(())
}
```

**Sorted Set 有序集合**:

```rust
pub async fn zset_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 添加成员
    conn.zadd("leaderboard", "player1", 100).await?;
    conn.zadd_multiple("leaderboard", &[
        (200, "player2"),
        (150, "player3"),
    ]).await?;
    
    // 递增分数
    let score: f64 = conn.zincr("leaderboard", "player1", 10).await?;
    
    // 获取分数
    let score: Option<f64> = conn.zscore("leaderboard", "player1").await?;
    
    // 获取排名 (从小到大)
    let rank: Option<i64> = conn.zrank("leaderboard", "player1").await?;
    
    // 获取排名 (从大到小)
    let rank: Option<i64> = conn.zrevrank("leaderboard", "player1").await?;
    
    // 获取范围成员 (按分数)
    let members: Vec<String> = conn.zrange("leaderboard", 0, -1).await?;
    
    // 获取范围成员带分数
    let members: Vec<(String, f64)> = conn.zrange_withscores("leaderboard", 0, -1).await?;
    
    // 获取范围成员 (按分数区间)
    let members: Vec<String> = conn.zrangebyscore("leaderboard", 100, 200).await?;
    
    // 获取成员数量
    let count: i64 = conn.zcard("leaderboard").await?;
    
    // 删除成员
    conn.zrem("leaderboard", "player1").await?;
    
    Ok(())
}
```

### 2.2.2.4 高级特性

**Pipeline 批量操作**:

```rust
pub async fn pipeline_example(
    conn: &mut ConnectionManager,
) -> Result<()> {
    let mut pipe = redis::pipe();
    
    pipe.set("key1", "value1")
        .ignore()
        .set("key2", "value2")
        .ignore()
        .get("key1")
        .get("key2");
    
    let (val1, val2): (String, String) = pipe.query_async(conn).await?;
    
    println!("Values: {}, {}", val1, val2);
    
    Ok(())
}
```

**事务**:

```rust
pub async fn transaction_example(
    conn: &mut ConnectionManager,
) -> Result<()> {
    let mut pipe = redis::pipe();
    
    pipe.atomic()
        .set("balance:1", 100)
        .set("balance:2", 200)
        .incr("balance:1", -50)
        .incr("balance:2", 50);
    
    let _: () = pipe.query_async(conn).await?;
    
    Ok(())
}
```

**Lua 脚本**:

```rust
pub async fn lua_script_example(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // 原子性操作：限流脚本
    let script = r#"
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local current = redis.call('GET', key)
        
        if current and tonumber(current) >= limit then
            return 0
        else
            redis.call('INCR', key)
            redis.call('EXPIRE', key, 60)
            return 1
        end
    "#;
    
    let allowed: i32 = redis::Script::new(script)
        .key("rate_limit:user:123")
        .arg(100)
        .invoke_async(conn)
        .await?;
    
    if allowed == 1 {
        println!("Request allowed");
    } else {
        println!("Rate limit exceeded");
    }
    
    Ok(())
}
```

### 2.2.2.5 发布订阅

**发布者**:

```rust
pub async fn publish_message(
    conn: &mut ConnectionManager,
    channel: &str,
    message: &str,
) -> Result<()> {
    let subscribers: i32 = conn.publish(channel, message).await?;
    println!("Message sent to {} subscribers", subscribers);
    Ok(())
}
```

**订阅者**:

```rust
use redis::aio::PubSub;

pub async fn subscribe_channel(
    client: &Client,
    channel: &str,
) -> Result<()> {
    let mut pubsub = client.get_async_pubsub().await?;
    pubsub.subscribe(channel).await?;
    
    let mut stream = pubsub.on_message();
    
    while let Some(msg) = stream.next().await {
        let payload: String = msg.get_payload()?;
        println!("Received: {}", payload);
    }
    
    Ok(())
}
```

### 2.2.2.6 分布式锁

**简单实现**:

```rust
use std::time::Duration;

pub struct RedisLock {
    conn: ConnectionManager,
    key: String,
    value: String,
    ttl: usize,
}

impl RedisLock {
    pub fn new(conn: ConnectionManager, key: String, ttl: usize) -> Self {
        Self {
            conn,
            key,
            value: uuid::Uuid::new_v4().to_string(),
            ttl,
        }
    }
    
    // 获取锁
    pub async fn acquire(&mut self) -> Result<bool> {
        let acquired: bool = self.conn
            .set_nx(&self.key, &self.value)
            .await?;
        
        if acquired {
            self.conn.expire(&self.key, self.ttl).await?;
        }
        
        Ok(acquired)
    }
    
    // 释放锁 (使用 Lua 脚本保证原子性)
    pub async fn release(&mut self) -> Result<bool> {
        let script = r#"
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
        "#;
        
        let released: i32 = redis::Script::new(script)
            .key(&self.key)
            .arg(&self.value)
            .invoke_async(&mut self.conn)
            .await?;
        
        Ok(released == 1)
    }
    
    // 续期
    pub async fn renew(&mut self) -> Result<bool> {
        let script = r#"
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("EXPIRE", KEYS[1], ARGV[2])
            else
                return 0
            end
        "#;
        
        let renewed: i32 = redis::Script::new(script)
            .key(&self.key)
            .arg(&self.value)
            .arg(self.ttl)
            .invoke_async(&mut self.conn)
            .await?;
        
        Ok(renewed == 1)
    }
}

// 使用示例
pub async fn use_distributed_lock(
    conn: ConnectionManager,
) -> Result<()> {
    let mut lock = RedisLock::new(
        conn,
        "lock:resource".to_string(),
        30, // 30 秒
    );
    
    if lock.acquire().await? {
        // 执行临界区代码
        println!("Lock acquired, processing...");
        
        // 模拟工作
        tokio::time::sleep(Duration::from_secs(5)).await;
        
        // 释放锁
        lock.release().await?;
        println!("Lock released");
    } else {
        println!("Failed to acquire lock");
    }
    
    Ok(())
}
```

---

## 2.2.3 本地缓存

### 2.2.3.1 Moka 缓存

**依赖配置**:

```toml
[dependencies]
moka = { version = "0.12", features = ["future"] }
```

**基础使用**:

```rust
use moka::future::Cache;
use std::time::Duration;

pub async fn moka_basic_example() {
    // 创建缓存
    let cache: Cache<String, String> = Cache::builder()
        .max_capacity(10_000)                    // 最大容量
        .time_to_live(Duration::from_secs(60))   // 存活时间
        .time_to_idle(Duration::from_secs(30))   // 空闲时间
        .build();
    
    // 插入
    cache.insert("key".to_string(), "value".to_string()).await;
    
    // 获取
    if let Some(value) = cache.get(&"key".to_string()).await {
        println!("Value: {}", value);
    }
    
    // 获取或插入
    let value = cache.get_or_insert_with("key".to_string(), async {
        // 从数据库加载
        "computed_value".to_string()
    }).await;
    
    // 使缓存失效
    cache.invalidate(&"key".to_string()).await;
    
    // 清空所有缓存
    cache.invalidate_all();
}
```

**高级用法**:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

pub struct UserCache {
    cache: Cache<u64, User>,
}

impl UserCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .max_capacity(10_000)
                .time_to_live(Duration::from_secs(300))
                .build(),
        }
    }
    
    pub async fn get_user(&self, id: u64) -> Option<User> {
        self.cache.get(&id).await
    }
    
    pub async fn get_or_fetch_user<F, Fut>(
        &self,
        id: u64,
        fetch_fn: F,
    ) -> User
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = User>,
    {
        self.cache.get_or_insert_with(id, fetch_fn()).await
    }
    
    pub async fn set_user(&self, user: User) {
        self.cache.insert(user.id, user).await;
    }
    
    pub async fn invalidate_user(&self, id: u64) {
        self.cache.invalidate(&id).await;
    }
}
```

### 2.2.3.2 Cached 缓存

**依赖配置**:

```toml
[dependencies]
cached = "0.53"
```

**函数缓存宏**:

```rust
use cached::proc_macro::cached;

// 基础缓存
#[cached]
fn expensive_function(n: u64) -> u64 {
    // 模拟耗时计算
    std::thread::sleep(std::time::Duration::from_secs(1));
    n * n
}

// 带容量限制
#[cached(size = 100)]
fn fibonacci(n: u64) -> u64 {
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// 带 TTL
#[cached(time = 60)]
fn get_config(key: &str) -> String {
    format!("config_value_for_{}", key)
}

// 自定义缓存键
#[cached(
    key = "String",
    convert = r#"{ format!("{}-{}", user_id, resource) }"#
)]
fn check_permission(user_id: u64, resource: &str) -> bool {
    // 检查权限
    true
}
```

---

## 2.2.4 缓存策略

### 2.2.4.1 缓存模式

**Cache-Aside (旁路缓存)**:

```rust
pub async fn cache_aside_read(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<User> {
    let cache_key = format!("user:{}", user_id);
    
    // 1. 先查缓存
    if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
        return Ok(serde_json::from_str(&cached)?);
    }
    
    // 2. 缓存未命中,查数据库
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id as i64)
        .fetch_one(db_pool)
        .await?;
    
    // 3. 写入缓存
    let user_json = serde_json::to_string(&user)?;
    cache.set_ex(&cache_key, &user_json, 3600).await?;
    
    Ok(user)
}

pub async fn cache_aside_write(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user: User,
) -> Result<()> {
    // 1. 先更新数据库
    sqlx::query("UPDATE users SET name = $1 WHERE id = $2")
        .bind(&user.name)
        .bind(user.id as i64)
        .execute(db_pool)
        .await?;
    
    // 2. 删除缓存
    let cache_key = format!("user:{}", user.id);
    cache.del(&cache_key).await?;
    
    Ok(())
}
```

**Read-Through (穿透读)**:

```rust
pub struct ReadThroughCache {
    cache: Cache<u64, User>,
    db_pool: PgPool,
}

impl ReadThroughCache {
    pub async fn get_user(&self, user_id: u64) -> Result<User> {
        self.cache.get_or_try_insert_with(user_id, async {
            // 自动从数据库加载
            sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
                .bind(user_id as i64)
                .fetch_one(&self.db_pool)
                .await
        }).await
    }
}
```

**Write-Through (穿透写)**:

```rust
pub async fn write_through(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user: User,
) -> Result<()> {
    // 同时更新缓存和数据库
    let cache_key = format!("user:{}", user.id);
    let user_json = serde_json::to_string(&user)?;
    
    // 先写数据库
    sqlx::query("UPDATE users SET name = $1 WHERE id = $2")
        .bind(&user.name)
        .bind(user.id as i64)
        .execute(db_pool)
        .await?;
    
    // 再更新缓存
    cache.set_ex(&cache_key, &user_json, 3600).await?;
    
    Ok(())
}
```

### 2.2.4.2 过期策略

**固定过期时间**:

```rust
// 设置 1 小时过期
cache.set_ex("key", "value", 3600).await?;
```

**滑动过期时间**:

```rust
pub async fn sliding_expiration(
    cache: &mut ConnectionManager,
    key: &str,
) -> Result<Option<String>> {
    if let Some(value): Option<String> = cache.get(key).await? {
        // 重置过期时间
        cache.expire(key, 3600).await?;
        Ok(Some(value))
    } else {
        Ok(None)
    }
}
```

### 2.2.4.3 淘汰策略

**LRU (Least Recently Used)**:

```rust
// Moka 默认使用 LRU
let cache = Cache::builder()
    .max_capacity(1000)
    .build();
```

**LFU (Least Frequently Used)**:

```rust
// Redis 配置
// maxmemory-policy allkeys-lfu
```

---

## 2.2.5 缓存问题

### 2.2.5.1 缓存穿透

**问题**: 查询不存在的数据,导致每次都击穿到数据库

**解决方案 1: 布隆过滤器**:

```rust
// 简化示例,实际需要使用 bloom crate
pub async fn with_bloom_filter(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<Option<User>> {
    // 1. 先检查布隆过滤器
    let exists: bool = check_bloom_filter(user_id).await?;
    if !exists {
        return Ok(None);
    }
    
    // 2. 查缓存
    let cache_key = format!("user:{}", user_id);
    if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
        return Ok(Some(serde_json::from_str(&cached)?));
    }
    
    // 3. 查数据库
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id as i64)
        .fetch_optional(db_pool)
        .await?;
    
    Ok(user)
}
```

**解决方案 2: 缓存空值**:

```rust
pub async fn cache_null_value(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<Option<User>> {
    let cache_key = format!("user:{}", user_id);
    
    // 查缓存
    match cache.get::<_, Option<String>>(&cache_key).await {
        Ok(Some(cached)) if cached == "null" => {
            // 缓存的空值
            return Ok(None);
        }
        Ok(Some(cached)) => {
            return Ok(Some(serde_json::from_str(&cached)?));
        }
        _ => {}
    }
    
    // 查数据库
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id as i64)
        .fetch_optional(db_pool)
        .await?;
    
    // 缓存结果 (包括空值)
    if let Some(ref u) = user {
        cache.set_ex(&cache_key, &serde_json::to_string(u)?, 3600).await?;
    } else {
        // 空值短时间缓存
        cache.set_ex(&cache_key, "null", 60).await?;
    }
    
    Ok(user)
}
```

### 2.2.5.2 缓存击穿

**问题**: 热点 key 过期瞬间,大量请求击穿到数据库

**解决方案: 互斥锁**:

```rust
pub async fn with_mutex(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<User> {
    let cache_key = format!("user:{}", user_id);
    
    // 查缓存
    if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
        return Ok(serde_json::from_str(&cached)?);
    }
    
    // 获取锁
    let lock_key = format!("lock:user:{}", user_id);
    let mut lock = RedisLock::new(cache.clone(), lock_key, 10);
    
    if lock.acquire().await? {
        // 双重检查
        if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
            lock.release().await?;
            return Ok(serde_json::from_str(&cached)?);
        }
        
        // 查数据库
        let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(user_id as i64)
            .fetch_one(db_pool)
            .await?;
        
        // 写缓存
        cache.set_ex(&cache_key, &serde_json::to_string(&user)?, 3600).await?;
        
        lock.release().await?;
        Ok(user)
    } else {
        // 等待其他线程加载
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // 重试
        if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
            Ok(serde_json::from_str(&cached)?)
        } else {
            // 如果还是没有,直接查数据库
            Ok(sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
                .bind(user_id as i64)
                .fetch_one(db_pool)
                .await?)
        }
    }
}
```

### 2.2.5.3 缓存雪崩

**问题**: 大量 key 同时过期,导致大量请求打到数据库

**解决方案: 随机过期时间**:

```rust
use rand::Rng;

pub async fn set_with_random_ttl(
    cache: &mut ConnectionManager,
    key: &str,
    value: &str,
    base_ttl: usize,
) -> Result<()> {
    let mut rng = rand::thread_rng();
    // 基础 TTL + 随机偏移 (0-10%)
    let random_offset = rng.gen_range(0..base_ttl / 10);
    let final_ttl = base_ttl + random_offset;
    
    cache.set_ex(key, value, final_ttl).await?;
    Ok(())
}
```

---

## 2.2.6 性能优化

### 2.2.6.1 连接池优化

```rust
use redis::aio::ConnectionManager;
use deadpool_redis::{Config, Runtime};

pub async fn create_connection_pool() -> Result<deadpool_redis::Pool> {
    let cfg = Config::from_url("redis://localhost:6379");
    let pool = cfg.create_pool(Some(Runtime::Tokio1))?;
    Ok(pool)
}
```

### 2.2.6.2 批量操作

```rust
pub async fn batch_get(
    conn: &mut ConnectionManager,
    keys: &[String],
) -> Result<Vec<String>> {
    let values = conn.mget(keys).await?;
    Ok(values)
}

pub async fn batch_set(
    conn: &mut ConnectionManager,
    items: &[(&str, &str)],
) -> Result<()> {
    conn.mset(items).await?;
    Ok(())
}
```

### 2.2.6.3 Pipeline 优化

```rust
pub async fn pipeline_batch_operations(
    conn: &mut ConnectionManager,
    users: Vec<User>,
) -> Result<()> {
    let mut pipe = redis::pipe();
    
    for user in users {
        let key = format!("user:{}", user.id);
        let value = serde_json::to_string(&user)?;
        pipe.set_ex(&key, &value, 3600).ignore();
    }
    
    pipe.query_async(conn).await?;
    Ok(())
}
```

---

## 2.2.7 生产实践

### 2.2.7.1 监控告警

```rust
use tracing::{info, warn};

pub async fn monitor_cache_stats(
    conn: &mut ConnectionManager,
) -> Result<()> {
    let info: String = redis::cmd("INFO")
        .arg("stats")
        .query_async(conn)
        .await?;
    
    // 解析并记录关键指标
    info!(cache_info = %info, "Cache statistics");
    
    Ok(())
}
```

### 2.2.7.2 高可用方案

**Redis Sentinel**:

```rust
use redis::sentinel::SentinelClient;

pub async fn create_sentinel_client() -> Result<Client> {
    let sentinels = vec![
        "redis://sentinel1:26379",
        "redis://sentinel2:26379",
        "redis://sentinel3:26379",
    ];
    
    let client = SentinelClient::build(
        sentinels,
        "mymaster".to_string(),
        None,
        redis::sentinel::SentinelNodeConnectionInfo::default(),
    )?;
    
    Ok(client.into())
}
```

### 2.2.7.3 容量规划

```rust
pub async fn estimate_memory_usage(
    cache: &mut ConnectionManager,
    sample_key: &str,
) -> Result<()> {
    // 获取单个 key 的内存使用
    let memory: usize = redis::cmd("MEMORY")
        .arg("USAGE")
        .arg(sample_key)
        .query_async(cache)
        .await?;
    
    // 获取总 key 数量
    let key_count: usize = redis::cmd("DBSIZE")
        .query_async(cache)
        .await?;
    
    // 估算总内存
    let estimated_total = memory * key_count;
    
    info!(
        sample_memory = memory,
        key_count = key_count,
        estimated_total = estimated_total,
        "Memory estimation"
    );
    
    Ok(())
}
```

---

## 2.2.8 最佳实践

### 2.2.8.1 命名规范

```rust
// 使用冒号分隔的命名空间
// 格式: <业务>:<对象>:<id>:<字段>

pub struct CacheKey;

impl CacheKey {
    pub fn user(id: u64) -> String {
        format!("user:{}", id)
    }
    
    pub fn user_field(id: u64, field: &str) -> String {
        format!("user:{}:{}", id, field)
    }
    
    pub fn session(token: &str) -> String {
        format!("session:{}", token)
    }
    
    pub fn rate_limit(user_id: u64, resource: &str) -> String {
        format!("rate_limit:{}:{}", user_id, resource)
    }
}
```

### 2.2.8.2 序列化方案

```rust
use serde::{Serialize, Deserialize};

// JSON (可读性好)
pub fn serialize_json<T: Serialize>(data: &T) -> Result<String> {
    Ok(serde_json::to_string(data)?)
}

pub fn deserialize_json<T: for<'de> Deserialize<'de>>(data: &str) -> Result<T> {
    Ok(serde_json::from_str(data)?)
}

// MessagePack (更紧凑)
pub fn serialize_msgpack<T: Serialize>(data: &T) -> Result<Vec<u8>> {
    Ok(rmp_serde::to_vec(data)?)
}

pub fn deserialize_msgpack<T: for<'de> Deserialize<'de>>(data: &[u8]) -> Result<T> {
    Ok(rmp_serde::from_slice(data)?)
}
```

### 2.2.8.3 安全实践

1. ✅ **使用密码认证**
2. ✅ **启用 TLS 加密**
3. ✅ **限制网络访问**
4. ✅ **禁用危险命令** (FLUSHALL, KEYS)
5. ✅ **设置最大内存限制**
6. ✅ **定期备份数据**

```rust
// 安全连接示例
pub async fn create_secure_client() -> Result<Client> {
    let client = Client::open(redis::ConnectionInfo {
        addr: redis::ConnectionAddr::Tcp("localhost".to_string(), 6379),
        redis: redis::RedisConnectionInfo {
            db: 0,
            username: Some("default".to_string()),
            password: Some("your_password".to_string()),
        },
    })?;
    
    Ok(client)
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025-10-21  
**维护团队**: Rust 学习社区

---

**✅ Rust 缓存系统指南完成！** 🎉
