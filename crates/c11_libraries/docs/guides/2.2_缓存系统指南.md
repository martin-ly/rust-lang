# 2.2 Rust ç¼“å­˜ç³»ç»ŸæŒ‡å— (2025)

> **æ–‡æ¡£å®šä½**: Rust ç¼“å­˜ç³»ç»Ÿå®Œæ•´å®æˆ˜æŒ‡å—  
> **é€‚ç”¨äººç¾¤**: åç«¯å¼€å‘è€…ï¼Œæ€§èƒ½ä¼˜åŒ–å·¥ç¨‹å¸ˆ  
> **å…³è”æ–‡æ¡£**: [3.2 å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾](../references/3.2_å¼€æºåº“ç”Ÿæ€å…¨æ™¯å›¾.md) | [2.1 æ•°æ®åº“é›†æˆæŒ‡å—](./2.1_æ•°æ®åº“é›†æˆæŒ‡å—.md)

**Rust ç‰ˆæœ¬**: 1.90  
**æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  
**æœ€åæ›´æ–°**: 2025-10-21

---

## ğŸ“‹ ç›®å½•

- [2.2 Rust ç¼“å­˜ç³»ç»ŸæŒ‡å— (2025)](#22-rust-ç¼“å­˜ç³»ç»ŸæŒ‡å—-2025)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2.2.1 æ¦‚è¿°](#221-æ¦‚è¿°)
    - [2.2.1.1 ä¸ºä»€ä¹ˆéœ€è¦ç¼“å­˜ï¼Ÿ](#2211-ä¸ºä»€ä¹ˆéœ€è¦ç¼“å­˜)
    - [2.2.1.2 ç¼“å­˜æŠ€æœ¯æ ˆå¯¹æ¯”](#2212-ç¼“å­˜æŠ€æœ¯æ ˆå¯¹æ¯”)
  - [2.2.2 Redis æ·±åº¦å®æˆ˜](#222-redis-æ·±åº¦å®æˆ˜)
    - [2.2.2.1 é¡¹ç›®åˆå§‹åŒ–](#2221-é¡¹ç›®åˆå§‹åŒ–)
    - [2.2.2.2 åŸºç¡€æ“ä½œ](#2222-åŸºç¡€æ“ä½œ)
    - [2.2.2.3 æ•°æ®ç»“æ„](#2223-æ•°æ®ç»“æ„)
    - [2.2.2.4 é«˜çº§ç‰¹æ€§](#2224-é«˜çº§ç‰¹æ€§)
    - [2.2.2.5 å‘å¸ƒè®¢é˜…](#2225-å‘å¸ƒè®¢é˜…)
    - [2.2.2.6 åˆ†å¸ƒå¼é”](#2226-åˆ†å¸ƒå¼é”)
  - [2.2.3 æœ¬åœ°ç¼“å­˜](#223-æœ¬åœ°ç¼“å­˜)
    - [2.2.3.1 Moka ç¼“å­˜](#2231-moka-ç¼“å­˜)
    - [2.2.3.2 Cached ç¼“å­˜](#2232-cached-ç¼“å­˜)
  - [2.2.4 ç¼“å­˜ç­–ç•¥](#224-ç¼“å­˜ç­–ç•¥)
    - [2.2.4.1 ç¼“å­˜æ¨¡å¼](#2241-ç¼“å­˜æ¨¡å¼)
    - [2.2.4.2 è¿‡æœŸç­–ç•¥](#2242-è¿‡æœŸç­–ç•¥)
    - [2.2.4.3 æ·˜æ±°ç­–ç•¥](#2243-æ·˜æ±°ç­–ç•¥)
  - [2.2.5 ç¼“å­˜é—®é¢˜](#225-ç¼“å­˜é—®é¢˜)
    - [2.2.5.1 ç¼“å­˜ç©¿é€](#2251-ç¼“å­˜ç©¿é€)
    - [2.2.5.2 ç¼“å­˜å‡»ç©¿](#2252-ç¼“å­˜å‡»ç©¿)
    - [2.2.5.3 ç¼“å­˜é›ªå´©](#2253-ç¼“å­˜é›ªå´©)
  - [2.2.6 æ€§èƒ½ä¼˜åŒ–](#226-æ€§èƒ½ä¼˜åŒ–)
    - [2.2.6.1 è¿æ¥æ± ä¼˜åŒ–](#2261-è¿æ¥æ± ä¼˜åŒ–)
    - [2.2.6.2 æ‰¹é‡æ“ä½œ](#2262-æ‰¹é‡æ“ä½œ)
    - [2.2.6.3 Pipeline ä¼˜åŒ–](#2263-pipeline-ä¼˜åŒ–)
  - [2.2.7 ç”Ÿäº§å®è·µ](#227-ç”Ÿäº§å®è·µ)
    - [2.2.7.1 ç›‘æ§å‘Šè­¦](#2271-ç›‘æ§å‘Šè­¦)
    - [2.2.7.2 é«˜å¯ç”¨æ–¹æ¡ˆ](#2272-é«˜å¯ç”¨æ–¹æ¡ˆ)
    - [2.2.7.3 å®¹é‡è§„åˆ’](#2273-å®¹é‡è§„åˆ’)
  - [2.2.8 æœ€ä½³å®è·µ](#228-æœ€ä½³å®è·µ)
    - [2.2.8.1 å‘½åè§„èŒƒ](#2281-å‘½åè§„èŒƒ)
    - [2.2.8.2 åºåˆ—åŒ–æ–¹æ¡ˆ](#2282-åºåˆ—åŒ–æ–¹æ¡ˆ)
    - [2.2.8.3 å®‰å…¨å®è·µ](#2283-å®‰å…¨å®è·µ)

---

## 2.2.1 æ¦‚è¿°

### 2.2.1.1 ä¸ºä»€ä¹ˆéœ€è¦ç¼“å­˜ï¼Ÿ

**æ ¸å¿ƒä»·å€¼**:

1. âœ… **æ€§èƒ½æå‡** - å†…å­˜è®¿é—®æ¯”æ•°æ®åº“å¿« 100-1000 å€
2. âœ… **é™ä½è´Ÿè½½** - å‡å°‘æ•°æ®åº“æŸ¥è¯¢å‹åŠ›
3. âœ… **æé«˜å¯ç”¨æ€§** - æ•°æ®åº“æ•…éšœæ—¶ä»å¯æä¾›æœåŠ¡
4. âœ… **èŠ‚çœæˆæœ¬** - å‡å°‘æ•°æ®åº“èµ„æºæ¶ˆè€—
5. âœ… **æ”¹å–„ä½“éªŒ** - æ¯«ç§’çº§å“åº”æ—¶é—´

**æ€§èƒ½å¯¹æ¯”**:

| å­˜å‚¨ç±»å‹ | å¹³å‡å»¶è¿Ÿ | ååé‡ | é€‚ç”¨åœºæ™¯ |
|---------|---------|--------|---------|
| **å†…å­˜ç¼“å­˜ (Moka)** | 1-10 Î¼s | 100M+ ops/s | çƒ­ç‚¹æ•°æ®ï¼Œé«˜é¢‘è¯» |
| **Redis** | 0.1-1 ms | 100K+ ops/s | åˆ†å¸ƒå¼ç¼“å­˜ï¼Œä¼šè¯ |
| **PostgreSQL** | 10-100 ms | 1K-10K ops/s | æŒä¹…åŒ–å­˜å‚¨ |

### 2.2.1.2 ç¼“å­˜æŠ€æœ¯æ ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ç±»å‹ | ç‰¹ç‚¹ | æ€§èƒ½ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | æˆç†Ÿåº¦ |
|------|------|------|------|--------|----------|--------|
| **Redis** | è¿œç¨‹ç¼“å­˜ | åˆ†å¸ƒå¼ï¼ŒæŒä¹…åŒ– | â­â­â­â­ | â­â­â­ | åˆ†å¸ƒå¼ç³»ç»Ÿ | â­â­â­â­â­ |
| **Moka** | æœ¬åœ°ç¼“å­˜ | é«˜æ€§èƒ½ï¼Œé›¶å»¶è¿Ÿ | â­â­â­â­â­ | â­â­ | å•æœºåº”ç”¨ | â­â­â­â­ |
| **Cached** | æœ¬åœ°ç¼“å­˜ | å®é©±åŠ¨ï¼Œæ˜“ç”¨ | â­â­â­â­ | â­ | å¿«é€Ÿé›†æˆ | â­â­â­ |

---

## 2.2.2 Redis æ·±åº¦å®æˆ˜

### 2.2.2.1 é¡¹ç›®åˆå§‹åŒ–

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
# Redis å®¢æˆ·ç«¯
redis = { version = "1.0.0-rc.2", features = [
    "tokio-comp",           # Tokio å¼‚æ­¥æ”¯æŒ
    "connection-manager",   # è¿æ¥ç®¡ç†å™¨
    "cluster",              # é›†ç¾¤æ”¯æŒ
    "streams",              # Stream æ”¯æŒ
    "script",               # Lua è„šæœ¬æ”¯æŒ
] }

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.48", features = ["full"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "2.0"

# æ—¥å¿—
tracing = "0.1"
```

**è¿æ¥é…ç½®**:

```rust
use redis::{Client, aio::ConnectionManager};
use anyhow::Result;

pub struct RedisConfig {
    pub url: String,
    pub max_connections: u32,
    pub connect_timeout_ms: u64,
    pub command_timeout_ms: u64,
}

impl Default for RedisConfig {
    fn default() -> Self {
        Self {
            url: "redis://localhost:6379".to_string(),
            max_connections: 10,
            connect_timeout_ms: 5000,
            command_timeout_ms: 3000,
        }
    }
}

pub async fn create_redis_client(config: RedisConfig) -> Result<Client> {
    let client = Client::open(config.url)?;
    Ok(client)
}

pub async fn create_connection_manager(client: &Client) -> Result<ConnectionManager> {
    let manager = ConnectionManager::new(client.clone()).await?;
    Ok(manager)
}
```

### 2.2.2.2 åŸºç¡€æ“ä½œ

**String æ“ä½œ**:

```rust
use redis::AsyncCommands;

// SET/GET
pub async fn basic_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // è®¾ç½®é”®å€¼
    conn.set("key", "value").await?;
    
    // è·å–å€¼
    let value: String = conn.get("key").await?;
    println!("Value: {}", value);
    
    // è®¾ç½®å¸¦è¿‡æœŸæ—¶é—´
    conn.set_ex("session:123", "user_data", 3600).await?;
    
    // è®¾ç½® NX (ä»…å½“ä¸å­˜åœ¨æ—¶)
    let set: bool = conn.set_nx("lock", "1").await?;
    
    // è®¾ç½®å¤šä¸ªé”®å€¼
    conn.mset(&[("key1", "value1"), ("key2", "value2")]).await?;
    
    // è·å–å¤šä¸ªå€¼
    let values: Vec<String> = conn.mget(&["key1", "key2"]).await?;
    
    // é€’å¢/é€’å‡
    let count: i64 = conn.incr("counter", 1).await?;
    let count: i64 = conn.decr("counter", 1).await?;
    
    // è·å–å¹¶è®¾ç½®
    let old_value: Option<String> = conn.getset("key", "new_value").await?;
    
    Ok(())
}
```

**é”®æ“ä½œ**:

```rust
pub async fn key_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
    let exists: bool = conn.exists("key").await?;
    
    // åˆ é™¤é”®
    let deleted: i32 = conn.del("key").await?;
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´ (ç§’)
    conn.expire("key", 3600).await?;
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´ (æ¯«ç§’)
    conn.pexpire("key", 3600000).await?;
    
    // æŸ¥è¯¢å‰©ä½™ TTL
    let ttl: i64 = conn.ttl("key").await?;
    
    // ç§»é™¤è¿‡æœŸæ—¶é—´
    conn.persist("key").await?;
    
    // é‡å‘½åé”®
    conn.rename("old_key", "new_key").await?;
    
    Ok(())
}
```

### 2.2.2.3 æ•°æ®ç»“æ„

**Hash å“ˆå¸Œè¡¨**:

```rust
pub async fn hash_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // è®¾ç½®å•ä¸ªå­—æ®µ
    conn.hset("user:1000", "name", "Alice").await?;
    
    // è®¾ç½®å¤šä¸ªå­—æ®µ
    conn.hset_multiple("user:1000", &[
        ("email", "alice@example.com"),
        ("age", "25"),
    ]).await?;
    
    // è·å–å•ä¸ªå­—æ®µ
    let name: String = conn.hget("user:1000", "name").await?;
    
    // è·å–æ‰€æœ‰å­—æ®µ
    let user: std::collections::HashMap<String, String> = 
        conn.hgetall("user:1000").await?;
    
    // è·å–å¤šä¸ªå­—æ®µ
    let values: Vec<String> = conn.hmget("user:1000", &["name", "email"]).await?;
    
    // é€’å¢å­—æ®µå€¼
    let age: i64 = conn.hincr("user:1000", "age", 1).await?;
    
    // æ£€æŸ¥å­—æ®µæ˜¯å¦å­˜åœ¨
    let exists: bool = conn.hexists("user:1000", "name").await?;
    
    // åˆ é™¤å­—æ®µ
    conn.hdel("user:1000", "age").await?;
    
    // è·å–æ‰€æœ‰å­—æ®µå
    let keys: Vec<String> = conn.hkeys("user:1000").await?;
    
    // è·å–å­—æ®µæ•°é‡
    let count: i64 = conn.hlen("user:1000").await?;
    
    Ok(())
}
```

**List åˆ—è¡¨**:

```rust
pub async fn list_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // å·¦ä¾§æ¨å…¥
    conn.lpush("queue", "task1").await?;
    
    // å³ä¾§æ¨å…¥
    conn.rpush("queue", "task2").await?;
    
    // å·¦ä¾§å¼¹å‡º
    let task: Option<String> = conn.lpop("queue", None).await?;
    
    // å³ä¾§å¼¹å‡º
    let task: Option<String> = conn.rpop("queue", None).await?;
    
    // è·å–åˆ—è¡¨é•¿åº¦
    let len: i64 = conn.llen("queue").await?;
    
    // è·å–èŒƒå›´å…ƒç´ 
    let items: Vec<String> = conn.lrange("queue", 0, -1).await?;
    
    // é€šè¿‡ç´¢å¼•è·å–å…ƒç´ 
    let item: String = conn.lindex("queue", 0).await?;
    
    // é€šè¿‡ç´¢å¼•è®¾ç½®å…ƒç´ 
    conn.lset("queue", 0, "new_task").await?;
    
    // ä¿®å‰ªåˆ—è¡¨
    conn.ltrim("queue", 0, 99).await?;
    
    // é˜»å¡å¼å¼¹å‡º (è¶…æ—¶ 5 ç§’)
    let result: Option<(String, String)> = conn.blpop("queue", 5.0).await?;
    
    Ok(())
}
```

**Set é›†åˆ**:

```rust
pub async fn set_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // æ·»åŠ æˆå‘˜
    conn.sadd("tags", "rust").await?;
    conn.sadd("tags", &["programming", "systems"]).await?;
    
    // åˆ é™¤æˆå‘˜
    conn.srem("tags", "rust").await?;
    
    // æ£€æŸ¥æˆå‘˜æ˜¯å¦å­˜åœ¨
    let exists: bool = conn.sismember("tags", "rust").await?;
    
    // è·å–æ‰€æœ‰æˆå‘˜
    let members: Vec<String> = conn.smembers("tags").await?;
    
    // è·å–æˆå‘˜æ•°é‡
    let count: i64 = conn.scard("tags").await?;
    
    // éšæœºè·å–æˆå‘˜
    let member: Option<String> = conn.srandmember("tags").await?;
    
    // å¼¹å‡ºéšæœºæˆå‘˜
    let member: Option<String> = conn.spop("tags").await?;
    
    // é›†åˆè¿ç®—
    let union: Vec<String> = conn.sunion(&["set1", "set2"]).await?;
    let inter: Vec<String> = conn.sinter(&["set1", "set2"]).await?;
    let diff: Vec<String> = conn.sdiff(&["set1", "set2"]).await?;
    
    Ok(())
}
```

**Sorted Set æœ‰åºé›†åˆ**:

```rust
pub async fn zset_operations(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // æ·»åŠ æˆå‘˜
    conn.zadd("leaderboard", "player1", 100).await?;
    conn.zadd_multiple("leaderboard", &[
        (200, "player2"),
        (150, "player3"),
    ]).await?;
    
    // é€’å¢åˆ†æ•°
    let score: f64 = conn.zincr("leaderboard", "player1", 10).await?;
    
    // è·å–åˆ†æ•°
    let score: Option<f64> = conn.zscore("leaderboard", "player1").await?;
    
    // è·å–æ’å (ä»å°åˆ°å¤§)
    let rank: Option<i64> = conn.zrank("leaderboard", "player1").await?;
    
    // è·å–æ’å (ä»å¤§åˆ°å°)
    let rank: Option<i64> = conn.zrevrank("leaderboard", "player1").await?;
    
    // è·å–èŒƒå›´æˆå‘˜ (æŒ‰åˆ†æ•°)
    let members: Vec<String> = conn.zrange("leaderboard", 0, -1).await?;
    
    // è·å–èŒƒå›´æˆå‘˜å¸¦åˆ†æ•°
    let members: Vec<(String, f64)> = conn.zrange_withscores("leaderboard", 0, -1).await?;
    
    // è·å–èŒƒå›´æˆå‘˜ (æŒ‰åˆ†æ•°åŒºé—´)
    let members: Vec<String> = conn.zrangebyscore("leaderboard", 100, 200).await?;
    
    // è·å–æˆå‘˜æ•°é‡
    let count: i64 = conn.zcard("leaderboard").await?;
    
    // åˆ é™¤æˆå‘˜
    conn.zrem("leaderboard", "player1").await?;
    
    Ok(())
}
```

### 2.2.2.4 é«˜çº§ç‰¹æ€§

**Pipeline æ‰¹é‡æ“ä½œ**:

```rust
pub async fn pipeline_example(
    conn: &mut ConnectionManager,
) -> Result<()> {
    let mut pipe = redis::pipe();
    
    pipe.set("key1", "value1")
        .ignore()
        .set("key2", "value2")
        .ignore()
        .get("key1")
        .get("key2");
    
    let (val1, val2): (String, String) = pipe.query_async(conn).await?;
    
    println!("Values: {}, {}", val1, val2);
    
    Ok(())
}
```

**äº‹åŠ¡**:

```rust
pub async fn transaction_example(
    conn: &mut ConnectionManager,
) -> Result<()> {
    let mut pipe = redis::pipe();
    
    pipe.atomic()
        .set("balance:1", 100)
        .set("balance:2", 200)
        .incr("balance:1", -50)
        .incr("balance:2", 50);
    
    let _: () = pipe.query_async(conn).await?;
    
    Ok(())
}
```

**Lua è„šæœ¬**:

```rust
pub async fn lua_script_example(
    conn: &mut ConnectionManager,
) -> Result<()> {
    // åŸå­æ€§æ“ä½œï¼šé™æµè„šæœ¬
    let script = r#"
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local current = redis.call('GET', key)
        
        if current and tonumber(current) >= limit then
            return 0
        else
            redis.call('INCR', key)
            redis.call('EXPIRE', key, 60)
            return 1
        end
    "#;
    
    let allowed: i32 = redis::Script::new(script)
        .key("rate_limit:user:123")
        .arg(100)
        .invoke_async(conn)
        .await?;
    
    if allowed == 1 {
        println!("Request allowed");
    } else {
        println!("Rate limit exceeded");
    }
    
    Ok(())
}
```

### 2.2.2.5 å‘å¸ƒè®¢é˜…

**å‘å¸ƒè€…**:

```rust
pub async fn publish_message(
    conn: &mut ConnectionManager,
    channel: &str,
    message: &str,
) -> Result<()> {
    let subscribers: i32 = conn.publish(channel, message).await?;
    println!("Message sent to {} subscribers", subscribers);
    Ok(())
}
```

**è®¢é˜…è€…**:

```rust
use redis::aio::PubSub;

pub async fn subscribe_channel(
    client: &Client,
    channel: &str,
) -> Result<()> {
    let mut pubsub = client.get_async_pubsub().await?;
    pubsub.subscribe(channel).await?;
    
    let mut stream = pubsub.on_message();
    
    while let Some(msg) = stream.next().await {
        let payload: String = msg.get_payload()?;
        println!("Received: {}", payload);
    }
    
    Ok(())
}
```

### 2.2.2.6 åˆ†å¸ƒå¼é”

**ç®€å•å®ç°**:

```rust
use std::time::Duration;

pub struct RedisLock {
    conn: ConnectionManager,
    key: String,
    value: String,
    ttl: usize,
}

impl RedisLock {
    pub fn new(conn: ConnectionManager, key: String, ttl: usize) -> Self {
        Self {
            conn,
            key,
            value: uuid::Uuid::new_v4().to_string(),
            ttl,
        }
    }
    
    // è·å–é”
    pub async fn acquire(&mut self) -> Result<bool> {
        let acquired: bool = self.conn
            .set_nx(&self.key, &self.value)
            .await?;
        
        if acquired {
            self.conn.expire(&self.key, self.ttl).await?;
        }
        
        Ok(acquired)
    }
    
    // é‡Šæ”¾é” (ä½¿ç”¨ Lua è„šæœ¬ä¿è¯åŸå­æ€§)
    pub async fn release(&mut self) -> Result<bool> {
        let script = r#"
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
        "#;
        
        let released: i32 = redis::Script::new(script)
            .key(&self.key)
            .arg(&self.value)
            .invoke_async(&mut self.conn)
            .await?;
        
        Ok(released == 1)
    }
    
    // ç»­æœŸ
    pub async fn renew(&mut self) -> Result<bool> {
        let script = r#"
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("EXPIRE", KEYS[1], ARGV[2])
            else
                return 0
            end
        "#;
        
        let renewed: i32 = redis::Script::new(script)
            .key(&self.key)
            .arg(&self.value)
            .arg(self.ttl)
            .invoke_async(&mut self.conn)
            .await?;
        
        Ok(renewed == 1)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn use_distributed_lock(
    conn: ConnectionManager,
) -> Result<()> {
    let mut lock = RedisLock::new(
        conn,
        "lock:resource".to_string(),
        30, // 30 ç§’
    );
    
    if lock.acquire().await? {
        // æ‰§è¡Œä¸´ç•ŒåŒºä»£ç 
        println!("Lock acquired, processing...");
        
        // æ¨¡æ‹Ÿå·¥ä½œ
        tokio::time::sleep(Duration::from_secs(5)).await;
        
        // é‡Šæ”¾é”
        lock.release().await?;
        println!("Lock released");
    } else {
        println!("Failed to acquire lock");
    }
    
    Ok(())
}
```

---

## 2.2.3 æœ¬åœ°ç¼“å­˜

### 2.2.3.1 Moka ç¼“å­˜

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
moka = { version = "0.12", features = ["future"] }
```

**åŸºç¡€ä½¿ç”¨**:

```rust
use moka::future::Cache;
use std::time::Duration;

pub async fn moka_basic_example() {
    // åˆ›å»ºç¼“å­˜
    let cache: Cache<String, String> = Cache::builder()
        .max_capacity(10_000)                    // æœ€å¤§å®¹é‡
        .time_to_live(Duration::from_secs(60))   // å­˜æ´»æ—¶é—´
        .time_to_idle(Duration::from_secs(30))   // ç©ºé—²æ—¶é—´
        .build();
    
    // æ’å…¥
    cache.insert("key".to_string(), "value".to_string()).await;
    
    // è·å–
    if let Some(value) = cache.get(&"key".to_string()).await {
        println!("Value: {}", value);
    }
    
    // è·å–æˆ–æ’å…¥
    let value = cache.get_or_insert_with("key".to_string(), async {
        // ä»æ•°æ®åº“åŠ è½½
        "computed_value".to_string()
    }).await;
    
    // ä½¿ç¼“å­˜å¤±æ•ˆ
    cache.invalidate(&"key".to_string()).await;
    
    // æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
    cache.invalidate_all();
}
```

**é«˜çº§ç”¨æ³•**:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}

pub struct UserCache {
    cache: Cache<u64, User>,
}

impl UserCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .max_capacity(10_000)
                .time_to_live(Duration::from_secs(300))
                .build(),
        }
    }
    
    pub async fn get_user(&self, id: u64) -> Option<User> {
        self.cache.get(&id).await
    }
    
    pub async fn get_or_fetch_user<F, Fut>(
        &self,
        id: u64,
        fetch_fn: F,
    ) -> User
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = User>,
    {
        self.cache.get_or_insert_with(id, fetch_fn()).await
    }
    
    pub async fn set_user(&self, user: User) {
        self.cache.insert(user.id, user).await;
    }
    
    pub async fn invalidate_user(&self, id: u64) {
        self.cache.invalidate(&id).await;
    }
}
```

### 2.2.3.2 Cached ç¼“å­˜

**ä¾èµ–é…ç½®**:

```toml
[dependencies]
cached = "0.53"
```

**å‡½æ•°ç¼“å­˜å®**:

```rust
use cached::proc_macro::cached;

// åŸºç¡€ç¼“å­˜
#[cached]
fn expensive_function(n: u64) -> u64 {
    // æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—
    std::thread::sleep(std::time::Duration::from_secs(1));
    n * n
}

// å¸¦å®¹é‡é™åˆ¶
#[cached(size = 100)]
fn fibonacci(n: u64) -> u64 {
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// å¸¦ TTL
#[cached(time = 60)]
fn get_config(key: &str) -> String {
    format!("config_value_for_{}", key)
}

// è‡ªå®šä¹‰ç¼“å­˜é”®
#[cached(
    key = "String",
    convert = r#"{ format!("{}-{}", user_id, resource) }"#
)]
fn check_permission(user_id: u64, resource: &str) -> bool {
    // æ£€æŸ¥æƒé™
    true
}
```

---

## 2.2.4 ç¼“å­˜ç­–ç•¥

### 2.2.4.1 ç¼“å­˜æ¨¡å¼

**Cache-Aside (æ—è·¯ç¼“å­˜)**:

```rust
pub async fn cache_aside_read(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<User> {
    let cache_key = format!("user:{}", user_id);
    
    // 1. å…ˆæŸ¥ç¼“å­˜
    if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
        return Ok(serde_json::from_str(&cached)?);
    }
    
    // 2. ç¼“å­˜æœªå‘½ä¸­,æŸ¥æ•°æ®åº“
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id as i64)
        .fetch_one(db_pool)
        .await?;
    
    // 3. å†™å…¥ç¼“å­˜
    let user_json = serde_json::to_string(&user)?;
    cache.set_ex(&cache_key, &user_json, 3600).await?;
    
    Ok(user)
}

pub async fn cache_aside_write(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user: User,
) -> Result<()> {
    // 1. å…ˆæ›´æ–°æ•°æ®åº“
    sqlx::query("UPDATE users SET name = $1 WHERE id = $2")
        .bind(&user.name)
        .bind(user.id as i64)
        .execute(db_pool)
        .await?;
    
    // 2. åˆ é™¤ç¼“å­˜
    let cache_key = format!("user:{}", user.id);
    cache.del(&cache_key).await?;
    
    Ok(())
}
```

**Read-Through (ç©¿é€è¯»)**:

```rust
pub struct ReadThroughCache {
    cache: Cache<u64, User>,
    db_pool: PgPool,
}

impl ReadThroughCache {
    pub async fn get_user(&self, user_id: u64) -> Result<User> {
        self.cache.get_or_try_insert_with(user_id, async {
            // è‡ªåŠ¨ä»æ•°æ®åº“åŠ è½½
            sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
                .bind(user_id as i64)
                .fetch_one(&self.db_pool)
                .await
        }).await
    }
}
```

**Write-Through (ç©¿é€å†™)**:

```rust
pub async fn write_through(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user: User,
) -> Result<()> {
    // åŒæ—¶æ›´æ–°ç¼“å­˜å’Œæ•°æ®åº“
    let cache_key = format!("user:{}", user.id);
    let user_json = serde_json::to_string(&user)?;
    
    // å…ˆå†™æ•°æ®åº“
    sqlx::query("UPDATE users SET name = $1 WHERE id = $2")
        .bind(&user.name)
        .bind(user.id as i64)
        .execute(db_pool)
        .await?;
    
    // å†æ›´æ–°ç¼“å­˜
    cache.set_ex(&cache_key, &user_json, 3600).await?;
    
    Ok(())
}
```

### 2.2.4.2 è¿‡æœŸç­–ç•¥

**å›ºå®šè¿‡æœŸæ—¶é—´**:

```rust
// è®¾ç½® 1 å°æ—¶è¿‡æœŸ
cache.set_ex("key", "value", 3600).await?;
```

**æ»‘åŠ¨è¿‡æœŸæ—¶é—´**:

```rust
pub async fn sliding_expiration(
    cache: &mut ConnectionManager,
    key: &str,
) -> Result<Option<String>> {
    if let Some(value): Option<String> = cache.get(key).await? {
        // é‡ç½®è¿‡æœŸæ—¶é—´
        cache.expire(key, 3600).await?;
        Ok(Some(value))
    } else {
        Ok(None)
    }
}
```

### 2.2.4.3 æ·˜æ±°ç­–ç•¥

**LRU (Least Recently Used)**:

```rust
// Moka é»˜è®¤ä½¿ç”¨ LRU
let cache = Cache::builder()
    .max_capacity(1000)
    .build();
```

**LFU (Least Frequently Used)**:

```rust
// Redis é…ç½®
// maxmemory-policy allkeys-lfu
```

---

## 2.2.5 ç¼“å­˜é—®é¢˜

### 2.2.5.1 ç¼“å­˜ç©¿é€

**é—®é¢˜**: æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®,å¯¼è‡´æ¯æ¬¡éƒ½å‡»ç©¿åˆ°æ•°æ®åº“

**è§£å†³æ–¹æ¡ˆ 1: å¸ƒéš†è¿‡æ»¤å™¨**:

```rust
// ç®€åŒ–ç¤ºä¾‹,å®é™…éœ€è¦ä½¿ç”¨ bloom crate
pub async fn with_bloom_filter(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<Option<User>> {
    // 1. å…ˆæ£€æŸ¥å¸ƒéš†è¿‡æ»¤å™¨
    let exists: bool = check_bloom_filter(user_id).await?;
    if !exists {
        return Ok(None);
    }
    
    // 2. æŸ¥ç¼“å­˜
    let cache_key = format!("user:{}", user_id);
    if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
        return Ok(Some(serde_json::from_str(&cached)?));
    }
    
    // 3. æŸ¥æ•°æ®åº“
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id as i64)
        .fetch_optional(db_pool)
        .await?;
    
    Ok(user)
}
```

**è§£å†³æ–¹æ¡ˆ 2: ç¼“å­˜ç©ºå€¼**:

```rust
pub async fn cache_null_value(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<Option<User>> {
    let cache_key = format!("user:{}", user_id);
    
    // æŸ¥ç¼“å­˜
    match cache.get::<_, Option<String>>(&cache_key).await {
        Ok(Some(cached)) if cached == "null" => {
            // ç¼“å­˜çš„ç©ºå€¼
            return Ok(None);
        }
        Ok(Some(cached)) => {
            return Ok(Some(serde_json::from_str(&cached)?));
        }
        _ => {}
    }
    
    // æŸ¥æ•°æ®åº“
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(user_id as i64)
        .fetch_optional(db_pool)
        .await?;
    
    // ç¼“å­˜ç»“æœ (åŒ…æ‹¬ç©ºå€¼)
    if let Some(ref u) = user {
        cache.set_ex(&cache_key, &serde_json::to_string(u)?, 3600).await?;
    } else {
        // ç©ºå€¼çŸ­æ—¶é—´ç¼“å­˜
        cache.set_ex(&cache_key, "null", 60).await?;
    }
    
    Ok(user)
}
```

### 2.2.5.2 ç¼“å­˜å‡»ç©¿

**é—®é¢˜**: çƒ­ç‚¹ key è¿‡æœŸç¬é—´,å¤§é‡è¯·æ±‚å‡»ç©¿åˆ°æ•°æ®åº“

**è§£å†³æ–¹æ¡ˆ: äº’æ–¥é”**:

```rust
pub async fn with_mutex(
    cache: &mut ConnectionManager,
    db_pool: &PgPool,
    user_id: u64,
) -> Result<User> {
    let cache_key = format!("user:{}", user_id);
    
    // æŸ¥ç¼“å­˜
    if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
        return Ok(serde_json::from_str(&cached)?);
    }
    
    // è·å–é”
    let lock_key = format!("lock:user:{}", user_id);
    let mut lock = RedisLock::new(cache.clone(), lock_key, 10);
    
    if lock.acquire().await? {
        // åŒé‡æ£€æŸ¥
        if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
            lock.release().await?;
            return Ok(serde_json::from_str(&cached)?);
        }
        
        // æŸ¥æ•°æ®åº“
        let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(user_id as i64)
            .fetch_one(db_pool)
            .await?;
        
        // å†™ç¼“å­˜
        cache.set_ex(&cache_key, &serde_json::to_string(&user)?, 3600).await?;
        
        lock.release().await?;
        Ok(user)
    } else {
        // ç­‰å¾…å…¶ä»–çº¿ç¨‹åŠ è½½
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // é‡è¯•
        if let Some(cached): Option<String> = cache.get(&cache_key).await.ok() {
            Ok(serde_json::from_str(&cached)?)
        } else {
            // å¦‚æœè¿˜æ˜¯æ²¡æœ‰,ç›´æ¥æŸ¥æ•°æ®åº“
            Ok(sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
                .bind(user_id as i64)
                .fetch_one(db_pool)
                .await?)
        }
    }
}
```

### 2.2.5.3 ç¼“å­˜é›ªå´©

**é—®é¢˜**: å¤§é‡ key åŒæ—¶è¿‡æœŸ,å¯¼è‡´å¤§é‡è¯·æ±‚æ‰“åˆ°æ•°æ®åº“

**è§£å†³æ–¹æ¡ˆ: éšæœºè¿‡æœŸæ—¶é—´**:

```rust
use rand::Rng;

pub async fn set_with_random_ttl(
    cache: &mut ConnectionManager,
    key: &str,
    value: &str,
    base_ttl: usize,
) -> Result<()> {
    let mut rng = rand::thread_rng();
    // åŸºç¡€ TTL + éšæœºåç§» (0-10%)
    let random_offset = rng.gen_range(0..base_ttl / 10);
    let final_ttl = base_ttl + random_offset;
    
    cache.set_ex(key, value, final_ttl).await?;
    Ok(())
}
```

---

## 2.2.6 æ€§èƒ½ä¼˜åŒ–

### 2.2.6.1 è¿æ¥æ± ä¼˜åŒ–

```rust
use redis::aio::ConnectionManager;
use deadpool_redis::{Config, Runtime};

pub async fn create_connection_pool() -> Result<deadpool_redis::Pool> {
    let cfg = Config::from_url("redis://localhost:6379");
    let pool = cfg.create_pool(Some(Runtime::Tokio1))?;
    Ok(pool)
}
```

### 2.2.6.2 æ‰¹é‡æ“ä½œ

```rust
pub async fn batch_get(
    conn: &mut ConnectionManager,
    keys: &[String],
) -> Result<Vec<String>> {
    let values = conn.mget(keys).await?;
    Ok(values)
}

pub async fn batch_set(
    conn: &mut ConnectionManager,
    items: &[(&str, &str)],
) -> Result<()> {
    conn.mset(items).await?;
    Ok(())
}
```

### 2.2.6.3 Pipeline ä¼˜åŒ–

```rust
pub async fn pipeline_batch_operations(
    conn: &mut ConnectionManager,
    users: Vec<User>,
) -> Result<()> {
    let mut pipe = redis::pipe();
    
    for user in users {
        let key = format!("user:{}", user.id);
        let value = serde_json::to_string(&user)?;
        pipe.set_ex(&key, &value, 3600).ignore();
    }
    
    pipe.query_async(conn).await?;
    Ok(())
}
```

---

## 2.2.7 ç”Ÿäº§å®è·µ

### 2.2.7.1 ç›‘æ§å‘Šè­¦

```rust
use tracing::{info, warn};

pub async fn monitor_cache_stats(
    conn: &mut ConnectionManager,
) -> Result<()> {
    let info: String = redis::cmd("INFO")
        .arg("stats")
        .query_async(conn)
        .await?;
    
    // è§£æå¹¶è®°å½•å…³é”®æŒ‡æ ‡
    info!(cache_info = %info, "Cache statistics");
    
    Ok(())
}
```

### 2.2.7.2 é«˜å¯ç”¨æ–¹æ¡ˆ

**Redis Sentinel**:

```rust
use redis::sentinel::SentinelClient;

pub async fn create_sentinel_client() -> Result<Client> {
    let sentinels = vec![
        "redis://sentinel1:26379",
        "redis://sentinel2:26379",
        "redis://sentinel3:26379",
    ];
    
    let client = SentinelClient::build(
        sentinels,
        "mymaster".to_string(),
        None,
        redis::sentinel::SentinelNodeConnectionInfo::default(),
    )?;
    
    Ok(client.into())
}
```

### 2.2.7.3 å®¹é‡è§„åˆ’

```rust
pub async fn estimate_memory_usage(
    cache: &mut ConnectionManager,
    sample_key: &str,
) -> Result<()> {
    // è·å–å•ä¸ª key çš„å†…å­˜ä½¿ç”¨
    let memory: usize = redis::cmd("MEMORY")
        .arg("USAGE")
        .arg(sample_key)
        .query_async(cache)
        .await?;
    
    // è·å–æ€» key æ•°é‡
    let key_count: usize = redis::cmd("DBSIZE")
        .query_async(cache)
        .await?;
    
    // ä¼°ç®—æ€»å†…å­˜
    let estimated_total = memory * key_count;
    
    info!(
        sample_memory = memory,
        key_count = key_count,
        estimated_total = estimated_total,
        "Memory estimation"
    );
    
    Ok(())
}
```

---

## 2.2.8 æœ€ä½³å®è·µ

### 2.2.8.1 å‘½åè§„èŒƒ

```rust
// ä½¿ç”¨å†’å·åˆ†éš”çš„å‘½åç©ºé—´
// æ ¼å¼: <ä¸šåŠ¡>:<å¯¹è±¡>:<id>:<å­—æ®µ>

pub struct CacheKey;

impl CacheKey {
    pub fn user(id: u64) -> String {
        format!("user:{}", id)
    }
    
    pub fn user_field(id: u64, field: &str) -> String {
        format!("user:{}:{}", id, field)
    }
    
    pub fn session(token: &str) -> String {
        format!("session:{}", token)
    }
    
    pub fn rate_limit(user_id: u64, resource: &str) -> String {
        format!("rate_limit:{}:{}", user_id, resource)
    }
}
```

### 2.2.8.2 åºåˆ—åŒ–æ–¹æ¡ˆ

```rust
use serde::{Serialize, Deserialize};

// JSON (å¯è¯»æ€§å¥½)
pub fn serialize_json<T: Serialize>(data: &T) -> Result<String> {
    Ok(serde_json::to_string(data)?)
}

pub fn deserialize_json<T: for<'de> Deserialize<'de>>(data: &str) -> Result<T> {
    Ok(serde_json::from_str(data)?)
}

// MessagePack (æ›´ç´§å‡‘)
pub fn serialize_msgpack<T: Serialize>(data: &T) -> Result<Vec<u8>> {
    Ok(rmp_serde::to_vec(data)?)
}

pub fn deserialize_msgpack<T: for<'de> Deserialize<'de>>(data: &[u8]) -> Result<T> {
    Ok(rmp_serde::from_slice(data)?)
}
```

### 2.2.8.3 å®‰å…¨å®è·µ

1. âœ… **ä½¿ç”¨å¯†ç è®¤è¯**
2. âœ… **å¯ç”¨ TLS åŠ å¯†**
3. âœ… **é™åˆ¶ç½‘ç»œè®¿é—®**
4. âœ… **ç¦ç”¨å±é™©å‘½ä»¤** (FLUSHALL, KEYS)
5. âœ… **è®¾ç½®æœ€å¤§å†…å­˜é™åˆ¶**
6. âœ… **å®šæœŸå¤‡ä»½æ•°æ®**

```rust
// å®‰å…¨è¿æ¥ç¤ºä¾‹
pub async fn create_secure_client() -> Result<Client> {
    let client = Client::open(redis::ConnectionInfo {
        addr: redis::ConnectionAddr::Tcp("localhost".to_string(), 6379),
        redis: redis::RedisConnectionInfo {
            db: 0,
            username: Some("default".to_string()),
            password: Some("your_password".to_string()),
        },
    })?;
    
    Ok(client)
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-21  
**ç»´æŠ¤å›¢é˜Ÿ**: Rust å­¦ä¹ ç¤¾åŒº

---

**âœ… Rust ç¼“å­˜ç³»ç»ŸæŒ‡å—å®Œæˆï¼** ğŸ‰
