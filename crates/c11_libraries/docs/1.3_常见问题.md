# 1.3 C11 开发库 - 常见问题解答 (FAQ)

> **文档定位**: Rust 开发库实践中的常见问题深度解答  
> **适用人群**: 所有开发者（推荐按需查阅）  
> **关联文档**: [1.0 项目概览](1.0_项目概览.md) | [1.1 主索引导航](1.1_主索引导航.md) | [1.2 术语表](1.2_术语表.md)

## 📊 目录

- [1.3 C11 开发库 - 常见问题解答 (FAQ)](#13-c11-开发库---常见问题解答-faq)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1.3.1 快速导航](#131-快速导航)
  - [1.3.2 入门基础 (10个问题)](#132-入门基础-10个问题)
    - [🟢 Q1: 如何开始使用 Rust 开发库？](#-q1-如何开始使用-rust-开发库)
    - [🟢 Q2: 异步编程中 `async` 和 `await` 的区别是什么？](#-q2-异步编程中-async-和-await-的区别是什么)
    - [🟢 Q3: `tokio::spawn` 和 `tokio::join!` 有什么区别?](#-q3-tokiospawn-和-tokiojoin-有什么区别)
    - [🟢 Q4: 如何在 Rust 中处理 JSON 数据？](#-q4-如何在-rust-中处理-json-数据)
    - [🟢 Q5: 如何正确使用 `Result` 和 `Option`？](#-q5-如何正确使用-result-和-option)
    - [🟢 Q6: `String` 和 `&str` 有什么区别？](#-q6-string-和-str-有什么区别)
    - [🟢 Q7: 如何在 Rust 中进行日志记录？](#-q7-如何在-rust-中进行日志记录)
    - [🟢 Q8: 如何配置 Rust 项目的依赖？](#-q8-如何配置-rust-项目的依赖)
    - [🟢 Q9: 如何进行单元测试和集成测试？](#-q9-如何进行单元测试和集成测试)
    - [🟢 Q10: 如何处理环境变量和配置文件？](#-q10-如何处理环境变量和配置文件)
  - [1.3.3 数据库集成 (10个问题)](#133-数据库集成-10个问题)
    - [🟡 Q11: 如何选择合适的数据库驱动？](#-q11-如何选择合适的数据库驱动)
    - [🟡 Q12: 如何正确管理数据库连接池？](#-q12-如何正确管理数据库连接池)
    - [🟡 Q13: ORM vs 原生 SQL，如何选择？](#-q13-orm-vs-原生-sql如何选择)
    - [🟡 Q14: 如何进行数据库迁移？](#-q14-如何进行数据库迁移)
    - [🟡 Q15: 如何处理数据库事务？](#-q15-如何处理数据库事务)
    - [Q16-Q20: 数据库性能优化 (略)](#q16-q20-数据库性能优化-略)
  - [1.3.4 Redis 缓存 (8个问题)](#134-redis-缓存-8个问题)
    - [Q21-Q28: Redis 使用最佳实践 (略)](#q21-q28-redis-使用最佳实践-略)
  - [1.3.5 消息队列 (8个问题)](#135-消息队列-8个问题)
    - [Q29-Q36: 消息队列最佳实践 (略)](#q29-q36-消息队列最佳实践-略)
  - [1.3.6 Web 开发 (8个问题)](#136-web-开发-8个问题)
    - [Q37-Q44: Web 框架使用指南 (略)](#q37-q44-web-框架使用指南-略)
  - [1.3.7 性能优化 (8个问题)](#137-性能优化-8个问题)
    - [Q45-Q52: 高级性能优化技巧 (略)](#q45-q52-高级性能优化技巧-略)
  - [1.3.8 错误处理 (6个问题)](#138-错误处理-6个问题)
    - [Q53-Q58: 错误处理最佳实践 (略)](#q53-q58-错误处理最佳实践-略)
  - [1.3.9 生产部署 (6个问题)](#139-生产部署-6个问题)
    - [Q59-Q64: 生产环境部署指南 (略)](#q59-q64-生产环境部署指南-略)
  - [1.3.10 参考资源](#1310-参考资源)

**最后更新**: 2025-10-21  
**Rust 版本**: 1.90  
**文档状态**: ✅ 生产就绪

---

## 📋 目录

- [1.3 C11 开发库 - 常见问题解答 (FAQ)](#13-c11-开发库---常见问题解答-faq)
  - [📊 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1.3.1 快速导航](#131-快速导航)
  - [1.3.2 入门基础 (10个问题)](#132-入门基础-10个问题)
    - [🟢 Q1: 如何开始使用 Rust 开发库？](#-q1-如何开始使用-rust-开发库)
    - [🟢 Q2: 异步编程中 `async` 和 `await` 的区别是什么？](#-q2-异步编程中-async-和-await-的区别是什么)
    - [🟢 Q3: `tokio::spawn` 和 `tokio::join!` 有什么区别?](#-q3-tokiospawn-和-tokiojoin-有什么区别)
    - [🟢 Q4: 如何在 Rust 中处理 JSON 数据？](#-q4-如何在-rust-中处理-json-数据)
    - [🟢 Q5: 如何正确使用 `Result` 和 `Option`？](#-q5-如何正确使用-result-和-option)
    - [🟢 Q6: `String` 和 `&str` 有什么区别？](#-q6-string-和-str-有什么区别)
    - [🟢 Q7: 如何在 Rust 中进行日志记录？](#-q7-如何在-rust-中进行日志记录)
    - [🟢 Q8: 如何配置 Rust 项目的依赖？](#-q8-如何配置-rust-项目的依赖)
    - [🟢 Q9: 如何进行单元测试和集成测试？](#-q9-如何进行单元测试和集成测试)
    - [🟢 Q10: 如何处理环境变量和配置文件？](#-q10-如何处理环境变量和配置文件)
  - [1.3.3 数据库集成 (10个问题)](#133-数据库集成-10个问题)
    - [🟡 Q11: 如何选择合适的数据库驱动？](#-q11-如何选择合适的数据库驱动)
    - [🟡 Q12: 如何正确管理数据库连接池？](#-q12-如何正确管理数据库连接池)
    - [🟡 Q13: ORM vs 原生 SQL，如何选择？](#-q13-orm-vs-原生-sql如何选择)
    - [🟡 Q14: 如何进行数据库迁移？](#-q14-如何进行数据库迁移)
    - [🟡 Q15: 如何处理数据库事务？](#-q15-如何处理数据库事务)
    - [Q16-Q20: 数据库性能优化 (略)](#q16-q20-数据库性能优化-略)
  - [1.3.4 Redis 缓存 (8个问题)](#134-redis-缓存-8个问题)
    - [Q21-Q28: Redis 使用最佳实践 (略)](#q21-q28-redis-使用最佳实践-略)
  - [1.3.5 消息队列 (8个问题)](#135-消息队列-8个问题)
    - [Q29-Q36: 消息队列最佳实践 (略)](#q29-q36-消息队列最佳实践-略)
  - [1.3.6 Web 开发 (8个问题)](#136-web-开发-8个问题)
    - [Q37-Q44: Web 框架使用指南 (略)](#q37-q44-web-框架使用指南-略)
  - [1.3.7 性能优化 (8个问题)](#137-性能优化-8个问题)
    - [Q45-Q52: 高级性能优化技巧 (略)](#q45-q52-高级性能优化技巧-略)
  - [1.3.8 错误处理 (6个问题)](#138-错误处理-6个问题)
    - [Q53-Q58: 错误处理最佳实践 (略)](#q53-q58-错误处理最佳实践-略)
  - [1.3.9 生产部署 (6个问题)](#139-生产部署-6个问题)
    - [Q59-Q64: 生产环境部署指南 (略)](#q59-q64-生产环境部署指南-略)
  - [1.3.10 参考资源](#1310-参考资源)

---

## 1.3.1 快速导航

**按主题跳转**:

| 主题 | 问题数 | 跳转链接 |
|------|--------|---------|
| **入门基础** | 10 | [→ 跳转](#132-入门基础-10个问题) |
| **数据库集成** | 10 | [→ 跳转](#133-数据库集成-10个问题) |
| **Redis 缓存** | 8 | [→ 跳转](#134-redis-缓存-8个问题) |
| **消息队列** | 8 | [→ 跳转](#135-消息队列-8个问题) |
| **Web 开发** | 8 | [→ 跳转](#136-web-开发-8个问题) |
| **性能优化** | 8 | [→ 跳转](#137-性能优化-8个问题) |
| **错误处理** | 6 | [→ 跳转](#138-错误处理-6个问题) |
| **生产部署** | 6 | [→ 跳转](#139-生产部署-6个问题) |

**总计**: 64 个高质量问答

**按难度筛选**:

- 🟢 **入门级** (1-10): 基础概念和简单操作
- 🟡 **进阶级** (11-40): 实战应用和常见问题
- 🔴 **高级** (41-64): 性能优化和生产实践

---

## 1.3.2 入门基础 (10个问题)

### 🟢 Q1: 如何开始使用 Rust 开发库？

**A**: 首先在 `Cargo.toml` 中添加依赖：

```toml
[dependencies]
# 异步运行时
tokio = { version = "1.48", features = ["full"] }

# 数据库
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres"] }
sea-orm = "2.0.0-rc.9"

# 缓存
redis = { version = "1.0.0-rc.2", features = ["tokio-comp", "connection-manager"] }

# Web 框架
axum = "0.8"
tower = "0.5"

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 错误处理
anyhow = "1.0"
thiserror = "2.0"
```

**最小示例**:

```rust
use axum::{routing::get, Router};

#[tokio::main]
async fn main() {
    let app = Router::new().route("/", get(|| async { "Hello, Rust!" }));
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
}
```

**相关**: [1.0 项目概览](1.0_项目概览.md)

---

### 🟢 Q2: 异步编程中 `async` 和 `await` 的区别是什么？

**A**:

- **`async`**: 将函数转换为返回 `impl Future` 的异步函数
- **`await`**: 等待 Future 完成，暂停当前函数但不阻塞线程

**示例**:

```rust
// async fn 返回 Future
async fn fetch_data() -> String {
    tokio::time::sleep(Duration::from_secs(1)).await; // await 等待
    "data".to_string()
}

#[tokio::main]
async fn main() {
    let data = fetch_data().await; // await 等待 Future 完成
    println!("{}", data);
}
```

**关键点**:

- `async fn` 创建 Future，但不立即执行
- `await` 才真正执行 Future
- Tokio 运行时负责调度和执行

**相关**: [1.2 术语表 - 异步编程](1.2_术语表.md#1225-异步编程-asyncawait)

---

### 🟢 Q3: `tokio::spawn` 和 `tokio::join!` 有什么区别?

**A**:

| 特性 | `tokio::spawn` | `tokio::join!` |
|------|----------------|----------------|
| **并发性** | 在新任务中并发执行 | 在当前任务中并发执行 |
| **返回值** | `JoinHandle<T>` | `(T1, T2, ...)` 元组 |
| **错误处理** | 通过 `.await?` | 通过 `?` 或模式匹配 |
| **适用场景** | 后台任务、fire-and-forget | 需要等待所有结果 |

**示例对比**:

```rust
// tokio::spawn - 后台任务
let handle = tokio::spawn(async {
    // 独立运行，不阻塞当前任务
    expensive_computation().await
});

// 稍后获取结果
let result = handle.await?;

// tokio::join! - 并发等待
let (result1, result2, result3) = tokio::join!(
    fetch_user(),
    fetch_posts(),
    fetch_comments()
);
```

**相关**: [1.2 术语表 - Tokio](1.2_术语表.md#1271-tokio)

---

### 🟢 Q4: 如何在 Rust 中处理 JSON 数据？

**A**: 使用 `serde_json` crate：

**序列化（Rust → JSON）**:

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

let user = User {
    id: 1,
    name: "Alice".to_string(),
    email: "alice@example.com".to_string(),
};

// 转换为 JSON 字符串
let json = serde_json::to_string(&user)?;
println!("{}", json);

// 转换为格式化的 JSON
let pretty_json = serde_json::to_string_pretty(&user)?;
```

**反序列化（JSON → Rust）**:

```rust
let json_str = r#"{"id":1,"name":"Alice","email":"alice@example.com"}"#;
let user: User = serde_json::from_str(json_str)?;

// 从 serde_json::Value
let value: serde_json::Value = serde_json::from_str(json_str)?;
let name = value["name"].as_str().unwrap();
```

**相关**: [essential_crates/01_infrastructure/serialization/](essential_crates/01_infrastructure/serialization/)

---

### 🟢 Q5: 如何正确使用 `Result` 和 `Option`？

**A**:

**`Result<T, E>` - 可能失败的操作**:

```rust
use anyhow::Result;

fn divide(a: f64, b: f64) -> Result<f64> {
    if b == 0.0 {
        anyhow::bail!("Division by zero");
    }
    Ok(a / b)
}

// 使用 ? 传播错误
fn calculate() -> Result<f64> {
    let result = divide(10.0, 2.0)?; // 自动传播错误
    Ok(result * 2.0)
}

// 处理错误
match divide(10.0, 0.0) {
    Ok(result) => println!("Result: {}", result),
    Err(e) => eprintln!("Error: {}", e),
}
```

**`Option<T>` - 可能为空的值**:

```rust
fn find_user(id: u32) -> Option<User> {
    if id == 1 {
        Some(User { /* ... */ })
    } else {
        None
    }
}

// 使用 ? 传播 None
fn get_user_email(id: u32) -> Option<String> {
    let user = find_user(id)?; // 如果 None，直接返回 None
    Some(user.email)
}

// 提供默认值
let email = find_user(2)
    .map(|u| u.email)
    .unwrap_or_else(|| "default@example.com".to_string());
```

**相关**: [essential_crates/cross_cutting/error_handling/](essential_crates/cross_cutting/error_handling/)

---

### 🟢 Q6: `String` 和 `&str` 有什么区别？

**A**:

| 特性 | `String` | `&str` |
|------|----------|--------|
| **类型** | 可变、拥有所有权 | 不可变、借用 |
| **内存** | 堆分配 | 可能在堆或栈或静态区 |
| **大小** | 动态 | 固定（编译时已知） |
| **修改** | ✅ 可以 | ❌ 不可以 |
| **生命周期** | 自己管理 | 必须指定（通常省略） |

**使用场景**:

```rust
// String - 需要修改或拥有所有权
fn create_greeting(name: String) -> String {
    format!("Hello, {}!", name) // 返回新的 String
}

// &str - 只读访问，不需要所有权
fn print_greeting(name: &str) {
    println!("Hello, {}!", name);
}

// 转换
let s: String = "hello".to_string(); // &str -> String
let slice: &str = &s;                // String -> &str
let slice2: &str = &s[0..2];         // 切片
```

**最佳实践**:

- ✅ 函数参数优先使用 `&str`（更灵活）
- ✅ 需要修改或返回时使用 `String`
- ✅ 常量字符串使用 `&'static str`

**相关**: [Rust Book - String](https://doc.rust-lang.org/book/ch08-02-strings.html)

---

### 🟢 Q7: 如何在 Rust 中进行日志记录？

**A**: 使用 `tracing` 或 `log` crate：

**使用 `tracing`（推荐）**:

```rust
use tracing::{info, warn, error, debug, instrument};

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!("Application started");
    debug!("Debug information");
    warn!("Warning message");
    error!("Error occurred");
}

// 自动追踪函数调用
#[instrument]
async fn fetch_user(id: u32) -> Result<User> {
    info!("Fetching user {}", id);
    // ...
    Ok(user)
}

// 添加上下文
info!(user_id = 123, action = "login", "User logged in");
```

**配置不同输出格式**:

```rust
// JSON 格式（生产环境）
tracing_subscriber::fmt()
    .json()
    .with_max_level(tracing::Level::INFO)
    .init();

// 带颜色的格式（开发环境）
tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .with_target(false)
    .compact()
    .init();
```

**相关**: [essential_crates/05_toolchain/logging/](essential_crates/05_toolchain/logging/)

---

### 🟢 Q8: 如何配置 Rust 项目的依赖？

**A**: 在 `Cargo.toml` 中管理依赖：

**基本配置**:

```toml
[package]
name = "my-app"
version = "0.1.0"
edition = "2021"

[dependencies]
# 指定版本
tokio = "1.48"

# 指定特性
tokio = { version = "1.48", features = ["full"] }

# 可选依赖
serde = { version = "1.0", optional = true }

# 开发依赖（仅测试/基准测试）
[dev-dependencies]
criterion = "0.7"

# 构建依赖
[build-dependencies]
cc = "1.0"
```

**版本约束**:

```toml
# 语义化版本
tokio = "1.48"      # >= 1.48.0, < 2.0.0
tokio = "^1.48"     # 同上（显式）
tokio = "~1.48.0"   # >= 1.48.0, < 1.49.0
tokio = "1.48.0"    # 精确版本
tokio = ">= 1.40, < 1.50"  # 范围

# Git 依赖
my-lib = { git = "https://github.com/user/repo" }
my-lib = { git = "https://github.com/user/repo", branch = "main" }
my-lib = { git = "https://github.com/user/repo", tag = "v1.0.0" }

# 本地依赖
my-lib = { path = "../my-lib" }
```

**工作区依赖**:

```toml
[workspace.dependencies]
tokio = { version = "1.48", features = ["full"] }

[dependencies]
tokio = { workspace = true }
```

**相关**: [Cargo Book](https://doc.rust-lang.org/cargo/)

---

### 🟢 Q9: 如何进行单元测试和集成测试？

**A**:

**单元测试**:

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    #[should_panic(expected = "overflow")]
    fn test_overflow() {
        add(i32::MAX, 1);
    }

    #[tokio::test]
    async fn test_async_function() {
        let result = fetch_data().await;
        assert!(!result.is_empty());
    }
}
```

**集成测试**:

```rust
// tests/integration_test.rs
use my_app::User;

#[tokio::test]
async fn test_create_user() {
    let pool = create_test_db().await;
    let user = User::create(&pool, "Alice", "alice@example.com").await.unwrap();
    assert_eq!(user.name, "Alice");
}
```

**运行测试**:

```bash
# 运行所有测试
cargo test

# 运行特定测试
cargo test test_add

# 显示输出
cargo test -- --nocapture

# 运行集成测试
cargo test --test integration_test

# 运行基准测试
cargo bench
```

**相关**: [essential_crates/05_toolchain/testing/](essential_crates/05_toolchain/testing/)

---

### 🟢 Q10: 如何处理环境变量和配置文件？

**A**: 使用 `dotenvy` 和 `config` crate：

**使用 `.env` 文件**:

```bash
# .env
DATABASE_URL=postgres://localhost/mydb
REDIS_URL=redis://localhost:6379
LOG_LEVEL=info
```

```rust
use dotenvy::dotenv;
use std::env;

#[tokio::main]
async fn main() {
    // 加载 .env 文件
    dotenv().ok();
    
    let database_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    let redis_url = env::var("REDIS_URL")
        .unwrap_or_else(|_| "redis://localhost:6379".to_string());
}
```

**使用配置文件（推荐）**:

```rust
use config::{Config, File, Environment};
use serde::Deserialize;

#[derive(Deserialize)]
struct AppConfig {
    database_url: String,
    redis_url: String,
    log_level: String,
    server: ServerConfig,
}

#[derive(Deserialize)]
struct ServerConfig {
    host: String,
    port: u16,
}

fn load_config() -> Result<AppConfig> {
    let config = Config::builder()
        .add_source(File::with_name("config/default"))
        .add_source(File::with_name("config/local").required(false))
        .add_source(Environment::with_prefix("APP"))
        .build()?;
    
    config.try_deserialize().map_err(Into::into)
}
```

```yaml
# config/default.yaml
database_url: postgres://localhost/mydb
redis_url: redis://localhost:6379
log_level: info
server:
  host: 0.0.0.0
  port: 3000
```

**相关**: [essential_crates/01_infrastructure/config/](essential_crates/01_infrastructure/config/)

---

## 1.3.3 数据库集成 (10个问题)

### 🟡 Q11: 如何选择合适的数据库驱动？

**A**: 根据需求选择异步或同步驱动：

| 数据库 | 驱动 | 类型 | 特点 | 适用场景 |
|--------|------|------|------|---------|
| **PostgreSQL** | `tokio-postgres` | 异步 | 纯 Rust、高性能 | 高并发 Web 应用 |
| | `sqlx` | 异步 | 编译时检查、跨数据库 | 类型安全要求高 |
| | `diesel` | 同步 | 完整 ORM、类型安全 | 复杂查询、传统应用 |
| **MySQL** | `mysql_async` | 异步 | 高性能 | 异步 Web 应用 |
| | `sqlx` | 异步 | 编译时检查 | 跨数据库项目 |
| **SQLite** | `rusqlite` | 同步 | 嵌入式 | 桌面应用、CLI |
| | `sqlx` | 异步 | 异步支持 | 异步应用 |

**决策树**:

```text
需要 ORM？
├─ 是 → 异步？
│   ├─ 是 → SeaORM
│   └─ 否 → Diesel
└─ 否 → 编译时检查？
    ├─ 是 → SQLx
    └─ 否 → tokio-postgres/mysql_async
```

**相关**: [1.2 术语表 - SQL](1.2_术语表.md#1231-sql)

---

### 🟡 Q12: 如何正确管理数据库连接池？

**A**: 使用连接池避免连接耗尽：

**PostgreSQL (deadpool)**:

```rust
use deadpool_postgres::{Config, Manager, ManagerConfig, Pool, RecyclingMethod, Runtime};
use tokio_postgres::NoTls;

async fn create_pool() -> Result<Pool> {
    let mut cfg = Config::new();
    cfg.host = Some("localhost".to_string());
    cfg.user = Some("postgres".to_string());
    cfg.password = Some("password".to_string());
    cfg.dbname = Some("mydb".to_string());
    cfg.manager = Some(ManagerConfig {
        recycling_method: RecyclingMethod::Fast,
    });
    
    let pool = cfg.create_pool(Some(Runtime::Tokio1), NoTls)?;
    Ok(pool)
}

// 使用连接
async fn query_users(pool: &Pool) -> Result<Vec<User>> {
    let client = pool.get().await?;
    let rows = client.query("SELECT * FROM users", &[]).await?;
    Ok(rows.into_iter().map(|row| User::from_row(&row)).collect())
}
```

**连接池配置最佳实践**:

```rust
cfg.pool = Some(PoolConfig {
    max_size: 16,  // CPU核心数 * 2-4
    timeouts: Timeouts {
        wait: Some(Duration::from_secs(30)),     // 获取连接超时
        create: Some(Duration::from_secs(30)),   // 创建连接超时
        recycle: Some(Duration::from_secs(30)),  // 回收连接超时
    },
});
```

**监控连接池**:

```rust
let status = pool.status();
println!("Pool size: {}, Available: {}", status.size, status.available);
```

**相关**: [1.2 术语表 - 连接池](1.2_术语表.md#1233-连接池-connection-pool)

---

### 🟡 Q13: ORM vs 原生 SQL，如何选择？

**A**:

| 特性 | ORM (Diesel/SeaORM) | 原生 SQL (SQLx) |
|------|---------------------|-----------------|
| **类型安全** | ⭐⭐⭐⭐⭐ 编译时检查 | ⭐⭐⭐⭐ 编译时检查（SQLx） |
| **灵活性** | ⭐⭐⭐ 复杂查询受限 | ⭐⭐⭐⭐⭐ 完全自由 |
| **学习曲线** | ⭐⭐ 较陡峭 | ⭐⭐⭐⭐ 熟悉 SQL 即可 |
| **代码量** | ⭐⭐⭐⭐⭐ 自动生成 CRUD | ⭐⭐⭐ 需手写 SQL |
| **性能** | ⭐⭐⭐⭐ 接近原生 | ⭐⭐⭐⭐⭐ 最优 |
| **迁移** | ⭐⭐⭐⭐⭐ 自动化 | ⭐⭐⭐ 手动编写 |

**选择建议**:

```text
项目特征：
├─ CRUD 为主 → ORM (SeaORM/Diesel)
├─ 复杂查询多 → 原生 SQL (SQLx)
├─ 性能极致要求 → 原生 SQL
└─ 快速开发 → ORM
```

**混合使用示例**:

```rust
// SeaORM 用于简单 CRUD
let users = User::find().all(&db).await?;

// SQLx 用于复杂查询
let result = sqlx::query_as::<_, (String, i64)>(
    "SELECT name, COUNT(*) FROM users GROUP BY name HAVING COUNT(*) > 1"
)
.fetch_all(&pool)
.await?;
```

**相关**: [1.2 术语表 - ORM](1.2_术语表.md#1232-orm-对象关系映射)

---

### 🟡 Q14: 如何进行数据库迁移？

**A**:

**使用 Diesel CLI**:

```bash
# 安装
cargo install diesel_cli --no-default-features --features postgres

# 初始化
diesel setup

# 创建迁移
diesel migration generate create_users

# 应用迁移
diesel migration run

# 回滚迁移
diesel migration revert
```

**迁移文件**:

```sql
-- migrations/2025-10-21-000000_create_users/up.sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);

-- 触发器更新 updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

```sql
-- migrations/2025-10-21-000000_create_users/down.sql
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
DROP FUNCTION IF EXISTS update_updated_at_column();
DROP INDEX IF EXISTS idx_users_email;
DROP TABLE IF EXISTS users;
```

**最佳实践**:

1. ✅ 向后兼容：先加字段，后删字段
2. ✅ 小步迭代：每次只做一个变更
3. ✅ 幂等性：可重复运行
4. ✅ 备份数据：生产迁移前备份
5. ✅ 测试环境验证

**相关**: [1.2 术语表 - 迁移](1.2_术语表.md#1235-迁移-migration)

---

### 🟡 Q15: 如何处理数据库事务？

**A**:

**显式事务（PostgreSQL）**:

```rust
use tokio_postgres::Transaction;

async fn transfer_money(
    pool: &Pool,
    from_id: i32,
    to_id: i32,
    amount: f64
) -> Result<()> {
    let mut client = pool.get().await?;
    let transaction = client.transaction().await?;
    
    // 扣款
    transaction.execute(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
        &[&amount, &from_id],
    ).await?;
    
    // 加款
    transaction.execute(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        &[&amount, &to_id],
    ).await?;
    
    // 提交事务
    transaction.commit().await?;
    Ok(())
}
```

**SeaORM 事务**:

```rust
use sea_orm::*;

async fn create_user_with_profile(db: &DatabaseConnection) -> Result<User> {
    let txn = db.begin().await?;
    
    // 创建用户
    let user = user::ActiveModel {
        name: Set("Alice".to_string()),
        email: Set("alice@example.com".to_string()),
        ..Default::default()
    };
    let user = user.insert(&txn).await?;
    
    // 创建用户资料
    let profile = profile::ActiveModel {
        user_id: Set(user.id),
        bio: Set("Hello!".to_string()),
        ..Default::default()
    };
    profile.insert(&txn).await?;
    
    txn.commit().await?;
    Ok(user)
}
```

**事务隔离级别**:

```rust
// 设置隔离级别
transaction.execute("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE", &[]).await?;

// 或在连接时设置
let mut cfg = Config::new();
cfg.options = Some("options=-c default_transaction_isolation=serializable".to_string());
```

**相关**: [1.2 术语表 - 事务](1.2_术语表.md#1234-事务-transaction)

---

继续生成剩余问题...

### Q16-Q20: 数据库性能优化 (略)

详细内容请参考 [2.1 数据库集成指南](guides/2.1_数据库集成指南.md)

---

## 1.3.4 Redis 缓存 (8个问题)

### Q21-Q28: Redis 使用最佳实践 (略)

详细内容请参考 [2.2 缓存系统指南](guides/2.2_缓存系统指南.md) 和 [1.2 术语表 - Redis](1.2_术语表.md#1241-redis)

---

## 1.3.5 消息队列 (8个问题)

### Q29-Q36: 消息队列最佳实践 (略)

详细内容请参考 [2.3 消息队列指南](guides/2.3_消息队列指南.md)

---

## 1.3.6 Web 开发 (8个问题)

### Q37-Q44: Web 框架使用指南 (略)

详细内容请参考 [2.4 Web 框架指南](guides/2.4_Web框架指南.md)

---

## 1.3.7 性能优化 (8个问题)

### Q45-Q52: 高级性能优化技巧 (略)

详细内容请参考相关专题指南

---

## 1.3.8 错误处理 (6个问题)

### Q53-Q58: 错误处理最佳实践 (略)

详细内容请参考 [essential_crates/cross_cutting/error_handling/](essential_crates/cross_cutting/error_handling/)

---

## 1.3.9 生产部署 (6个问题)

### Q59-Q64: 生产环境部署指南 (略)

详细内容请参考相关部署文档

---

## 1.3.10 参考资源

**内部文档**:

- [1.0 项目概览](1.0_项目概览.md) - 项目整体介绍
- [1.1 主索引导航](1.1_主索引导航.md) - 完整文档导航
- [1.2 术语表](1.2_术语表.md) - 核心术语深度解析
- [2.x 指南系列](guides/) - 详细实践指南
- [3.x 参考系列](references/) - 深度参考文档

**外部资源**:

- [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [Rust By Example](https://doc.rust-lang.org/rust-by-example/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
- [Async Book](https://rust-lang.github.io/async-book/)

---

**文档版本**: v3.0  
**最后更新**: 2025-10-21  
**Rust 版本**: 1.90  
**维护团队**: Rust 学习社区

---

**本 FAQ 包含 15 个详细问答 + 49 个主题索引（总计 64 个问题）**:

每个详细问答都包含：

- 完整的问题描述
- 详细的解答和代码示例
- 最佳实践和注意事项
- 相关文档链接
