# 知识图谱

本页展示所有权、借用与作用域的概念关系。

---

## 📊 核心概念关系图

```text
                    [所有权系统]
                         |
         +---------------+---------------+
         |               |               |
    [所有权]         [借用]         [生命周期]
         |               |               |
    +----+----+     +----+----+     +----+----+
    |    |    |     |    |    |     |    |    |
  移动  复制 Drop  不可变  可变  引用  标注  省略  静态
                  借用    借用  规则
```

---

## 🎯 概念层次

### 1. 所有权 (Ownership)

**核心规则**:

- 每个值都有一个所有者
- 值在任一时刻只能有一个所有者
- 当所有者离开作用域时，值被释放

**相关概念**:

- **移动 (Move)**: 所有权转移
- **Copy**: 自动复制而非移动
- **Clone**: 显式深拷贝
- **Drop**: 值离开作用域时的清理

---

### 2. 借用 (Borrowing)

**核心规则**:

- 可以有多个不可变引用
- 或者只有一个可变引用
- 引用必须总是有效的

**相关概念**:

- **不可变借用** (`&T`): 只读访问
- **可变借用** (`&mut T`): 读写访问
- **借用检查器**: 编译时验证借用规则
- **NLL** (Non-Lexical Lifetimes): 更智能的生命周期分析

---

### 3. 生命周期 (Lifetimes)

**核心概念**:

- 引用有效的作用域
- 防止悬垂引用
- 在编译时验证

**相关概念**:

- **生命周期标注** (`'a`): 显式标注生命周期关系
- **生命周期省略**: 编译器自动推断
- **静态生命周期** (`'static`): 整个程序期间有效
- **子类型**: 生命周期的协变和逆变

---

## 🔗 概念关联

### 所有权 ←→ 借用

```rust
// 所有权: 完全拥有
let s = String::from("hello");

// 借用: 临时访问
let r = &s;

// 关系: 借用不转移所有权
println!("{}", s);  // s 仍然有效
println!("{}", r);  // r 是 s 的借用
```

### 借用 ←→ 生命周期

```rust
// 借用必须有有效的生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// 返回值的生命周期不能超过输入
```

### 所有权 ←→ 作用域

```rust
{
    let s = String::from("hello");  // s 开始有效
    // 使用 s
}  // s 离开作用域，所有权结束，内存被释放
```

---

## 📚 学习路径图

```text
第一步: 理解所有权
    ↓
第二步: 掌握移动和复制
    ↓
第三步: 学习借用规则
    ↓
第四步: 理解生命周期
    ↓
第五步: 实战应用
```

---

## 🎓 从其他语言的角度

### 对比 C++

| 概念 | C++ | Rust |
|------|-----|------|
| **所有权** | 手动管理 | 自动管理 |
| **引用** | 可能悬垂 | 编译时检查 |
| **内存泄漏** | 常见问题 | 极少发生 |
| **多线程** | 数据竞争 | 编译时防止 |

### 对比 Java/Python

| 概念 | Java/Python | Rust |
|------|-------------|------|
| **内存管理** | 垃圾回收 | 所有权系统 |
| **性能** | GC 暂停 | 无运行时开销 |
| **并发** | 运行时检查 | 编译时检查 |
| **可预测性** | GC 不确定 | 确定性清理 |

---

## 💡 核心原则

### 1. 所有权保证内存安全

```text
所有权 → 唯一所有者 → 确定性清理 → 无内存泄漏
```

### 2. 借用防止数据竞争

```text
借用规则 → 编译时检查 → 无数据竞争 → 线程安全
```

### 3. 生命周期保证引用有效

```text
生命周期 → 引用必须有效 → 无悬垂指针 → 内存安全
```

---

## 🔍 深入主题

### 主题 1: 智能指针与所有权

- **`Box<T>`**: 堆分配
- **`Rc<T>`**: 引用计数
- **`Arc<T>`**: 原子引用计数
- **`RefCell<T>`**: 内部可变性

```rust
use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    let b = Rc::clone(&a);
    
    println!("引用计数: {}", Rc::strong_count(&a));
}
```

### 主题 2: 并发中的所有权

- **Send**: 可在线程间转移
- **Sync**: 可在线程间共享引用

```rust
use std::thread;
use std::sync::Arc;

fn main() {
    let data = Arc::new(vec![1, 2, 3]);
    
    let data_clone = Arc::clone(&data);
    thread::spawn(move || {
        println!("{:?}", data_clone);
    });
}
```

### 主题 3: 高级生命周期

- **高阶 trait 边界** (HRTB)
- **生命周期子类型**
- **型变** (Variance)

```rust
// HRTB 示例
fn apply<F>(f: F)
where
    F: for<'a> Fn(&'a str) -> &'a str,
{
    let s = String::from("hello");
    println!("{}", f(&s));
}
```

---

## 📖 相关章节

- **[基础概念](./foundations.md)** - 理论详解
- **[实践指南](./guides.md)** - 实用技巧
- **[代码示例](./examples.md)** - 交互式示例 ⭐
- **[返回模块首页](./README.md)**

---

## 🔗 扩展学习

### 深入阅读

- [完整知识图谱](../../crates/c01_ownership_borrow_scope/docs/theory/KNOWLEDGE_GRAPH_AND_CONCEPT_RELATIONS.md)
- [Rust Nomicon - 高级主题](https://doc.rust-lang.org/nomicon/)
- [RFC 2094 - NLL](https://rust-lang.github.io/rfcs/2094-nll.html)

### 相关模块

- **[C05: 多线程](../c05/README.md)** - Send 和 Sync
- **[C04: 泛型](../c04/README.md)** - 生命周期泛型
- **[C13: 可靠性](../c13/README.md)** - 智能指针

---

**理解这些概念的关系将帮助你更好地掌握 Rust！** 🚀
