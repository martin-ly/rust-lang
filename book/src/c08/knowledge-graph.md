# çŸ¥è¯†å›¾è°±

æœ¬é¡µå±•ç¤ºç®—æ³•ä¸æ•°æ®ç»“æ„çš„æ¦‚å¿µå…³ç³»ã€‚

---

## ğŸ“Š æ ¸å¿ƒæ¦‚å¿µå…³ç³»å›¾

```text
                   [ç®—æ³•ä¸æ•°æ®ç»“æ„]
                         |
         +---------------+---------------+
         |               |               |
    [æ•°æ®ç»“æ„]       [ç®—æ³•è®¾è®¡]       [å¤æ‚åº¦åˆ†æ]
         |               |               |
    +----+----+     +----+----+     +----+----+
    |    |    |     |    |    |     |    |    |
  çº¿æ€§  æ ‘å½¢  å›¾    åˆ†æ²»  åŠ¨æ€  è´ªå¿ƒ  æ—¶é—´  ç©ºé—´  æ¸è¿›
  ç»“æ„  ç»“æ„  ç»“æ„        è§„åˆ’              åˆ†æ
```

---

## ğŸ¯ æ¦‚å¿µå±‚æ¬¡

### 1. æ•°æ®ç»“æ„ (Data Structures)

**æ ¸å¿ƒç±»åˆ«**:

- **çº¿æ€§ç»“æ„**: æ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€åŒç«¯é˜Ÿåˆ—
- **æ ‘å½¢ç»“æ„**: äºŒå‰æ ‘ã€BSTã€AVLæ ‘ã€çº¢é»‘æ ‘ã€Bæ ‘ã€å †
- **å›¾ç»“æ„**: æœ‰å‘å›¾ã€æ— å‘å›¾ã€åŠ æƒå›¾ã€DAG
- **æ•£åˆ—ç»“æ„**: å“ˆå¸Œè¡¨ã€å¸ƒéš†è¿‡æ»¤å™¨

**Rust ç‰¹æ€§**:

- **Vec**: åŠ¨æ€æ•°ç»„
- **VecDeque**: åŒç«¯é˜Ÿåˆ—
- **BinaryHeap**: äºŒå‰å †
- **HashMap/BTreeMap**: å…³è”å®¹å™¨

---

### 2. ç®—æ³•è®¾è®¡èŒƒå¼ (Algorithm Paradigms)

**æ ¸å¿ƒèŒƒå¼**:

- **åˆ†æ²»æ³•** (Divide and Conquer): å¿«é€Ÿæ’åºã€å½’å¹¶æ’åº
- **åŠ¨æ€è§„åˆ’** (Dynamic Programming): èƒŒåŒ…é—®é¢˜ã€æœ€é•¿å­åºåˆ—
- **è´ªå¿ƒç®—æ³•** (Greedy): æœ€å°ç”Ÿæˆæ ‘ã€å“ˆå¤«æ›¼ç¼–ç 
- **å›æº¯ç®—æ³•** (Backtracking): Nçš‡åã€è¿·å®«é—®é¢˜
- **åˆ†æ”¯é™ç•Œ** (Branch and Bound): æ—…è¡Œå•†é—®é¢˜

**Rust å®ç°ç‰¹ç‚¹**:

- é›¶æˆæœ¬æŠ½è±¡
- è¿­ä»£å™¨ç»„åˆ
- æ‰€æœ‰æƒä¼˜åŒ–
- å¹¶å‘å®‰å…¨

---

### 3. å¤æ‚åº¦åˆ†æ (Complexity Analysis)

**æ—¶é—´å¤æ‚åº¦**:

- O(1) - å¸¸æ•°æ—¶é—´
- O(log n) - å¯¹æ•°æ—¶é—´
- O(n) - çº¿æ€§æ—¶é—´
- O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´
- O(nÂ²) - å¹³æ–¹æ—¶é—´

**ç©ºé—´å¤æ‚åº¦**:

- åŸåœ°ç®—æ³• O(1)
- é€’å½’æ·±åº¦
- ç¼“å­˜ç©ºé—´

---

## ğŸ”— æ¦‚å¿µå…³è”

### æ•°æ®ç»“æ„ â†â†’ ç®—æ³•è®¾è®¡

```rust
// æ•°æ®ç»“æ„é€‰æ‹©å½±å“ç®—æ³•æ•ˆç‡
use std::collections::BinaryHeap;

// ä¼˜å…ˆé˜Ÿåˆ— + è´ªå¿ƒç®—æ³• = Dijkstraæœ€çŸ­è·¯å¾„
fn dijkstra(graph: &[(Vec<(usize, i32)>)], start: usize) -> Vec<i32> {
    let mut distances = vec![i32::MAX; graph.len()];
    let mut heap = BinaryHeap::new();
    
    distances[start] = 0;
    heap.push((0, start));
    
    while let Some((dist, node)) = heap.pop() {
        // è´ªå¿ƒé€‰æ‹©å½“å‰æœ€çŸ­è·¯å¾„
        if -dist > distances[node] { continue; }
        
        for &(neighbor, weight) in &graph[node] {
            let new_dist = distances[node] + weight;
            if new_dist < distances[neighbor] {
                distances[neighbor] = new_dist;
                heap.push((-new_dist, neighbor));
            }
        }
    }
    
    distances
}
```

### ç®—æ³•èŒƒå¼ â†â†’ å¤æ‚åº¦

```rust
// åŠ¨æ€è§„åˆ’: ç©ºé—´æ¢æ—¶é—´
fn fibonacci_dp(n: usize) -> u64 {
    let mut dp = vec![0; n + 1];
    dp[1] = 1;
    
    for i in 2..=n {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    dp[n]  // O(n) æ—¶é—´, O(n) ç©ºé—´
}

// ä¼˜åŒ–: é™ä½ç©ºé—´å¤æ‚åº¦
fn fibonacci_optimized(n: usize) -> u64 {
    let (mut prev, mut curr) = (0, 1);
    
    for _ in 2..=n {
        let next = prev + curr;
        prev = curr;
        curr = next;
    }
    
    curr  // O(n) æ—¶é—´, O(1) ç©ºé—´
}
```

### å¹¶å‘ â†â†’ ç®—æ³•

```rust
use rayon::prelude::*;

// å¹¶è¡Œå¿«é€Ÿæ’åº
fn parallel_quicksort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 1 { return; }
    
    let mid = partition(arr);
    let (left, right) = arr.split_at_mut(mid);
    
    rayon::join(
        || parallel_quicksort(left),
        || parallel_quicksort(right),
    );
}
```

---

## ğŸ“š å­¦ä¹ è·¯å¾„å›¾

```text
ç¬¬ä¸€æ­¥: æŒæ¡åŸºæœ¬æ•°æ®ç»“æ„
    â†“
ç¬¬äºŒæ­¥: å­¦ä¹ æ’åºå’Œæœç´¢ç®—æ³•
    â†“
ç¬¬ä¸‰æ­¥: ç†è§£ç®—æ³•è®¾è®¡èŒƒå¼
    â†“
ç¬¬å››æ­¥: æŒæ¡å›¾ç®—æ³•
    â†“
ç¬¬äº”æ­¥: å¹¶å‘ä¸å¼‚æ­¥ç®—æ³•
```

---

## ğŸ“ ç®—æ³•åˆ†ç±»ä½“ç³»

### æ’åºç®—æ³•

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ |
|------|-----------|-----------|--------|
| å¿«é€Ÿæ’åº | O(n log n) | O(log n) | ä¸ç¨³å®š |
| å½’å¹¶æ’åº | O(n log n) | O(n) | ç¨³å®š |
| å †æ’åº | O(n log n) | O(1) | ä¸ç¨³å®š |
| æ’å…¥æ’åº | O(nÂ²) | O(1) | ç¨³å®š |

### æœç´¢ç®—æ³•

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|---------|
| äºŒåˆ†æœç´¢ | O(log n) | æœ‰åºæ•°ç»„ |
| å“ˆå¸ŒæŸ¥æ‰¾ | O(1) | é”®å€¼å¯¹ |
| DFS | O(V+E) | å›¾éå† |
| BFS | O(V+E) | æœ€çŸ­è·¯å¾„ |

### å›¾ç®—æ³•

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç”¨é€” |
|------|-----------|------|
| Dijkstra | O((V+E) log V) | å•æºæœ€çŸ­è·¯å¾„ |
| Floyd-Warshall | O(VÂ³) | å…¨æºæœ€çŸ­è·¯å¾„ |
| Kruskal | O(E log E) | æœ€å°ç”Ÿæˆæ ‘ |
| Prim | O((V+E) log V) | æœ€å°ç”Ÿæˆæ ‘ |

---

## ğŸ’¡ æ ¸å¿ƒåŸåˆ™

### 1. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„

```text
æ•°æ®ç»“æ„ â†’ ç®—æ³•æ•ˆç‡ â†’ ç³»ç»Ÿæ€§èƒ½
```

### 2. æƒè¡¡æ—¶é—´ä¸ç©ºé—´

```text
æ—¶é—´æ¢ç©ºé—´ â† åŠ¨æ€è§„åˆ’ â†’ ç©ºé—´æ¢æ—¶é—´
```

### 3. åˆ©ç”¨ Rust ç‰¹æ€§

```text
æ‰€æœ‰æƒ â†’ é›¶æˆæœ¬æŠ½è±¡ â†’ é«˜æ•ˆå®ç°
```

---

## ğŸ” Rust 1.90 å¢å¼ºç‰¹æ€§

### 1. é«˜çº§ç±»å‹æ¨æ–­

```rust
// å¤æ‚ç±»å‹è‡ªåŠ¨æ¨æ–­
let graph: Vec<Vec<_>> = (0..n)
    .map(|_| Vec::new())
    .collect();
```

### 2. å¹¶å‘ç®—æ³•

```rust
use tokio::task;

// å¼‚æ­¥å¹¶è¡Œè®¡ç®—
async fn parallel_map<F, T, R>(data: Vec<T>, f: F) -> Vec<R>
where
    F: Fn(T) -> R + Send + Sync + 'static,
    T: Send + 'static,
    R: Send + 'static,
{
    let handles: Vec<_> = data
        .into_iter()
        .map(|item| task::spawn_blocking(move || f(item)))
        .collect();
    
    let mut results = Vec::new();
    for handle in handles {
        results.push(handle.await.unwrap());
    }
    results
}
```

### 3. æ³›å‹ä¼˜åŒ–

```rust
// ä½¿ç”¨ const æ³›å‹ä¼˜åŒ–æ•°ç»„ç®—æ³•
fn array_sum<T, const N: usize>(arr: [T; N]) -> T
where
    T: std::ops::Add<Output = T> + Default + Copy,
{
    arr.into_iter().fold(T::default(), |acc, x| acc + x)
}
```

---

## ğŸ“– ç›¸å…³ç« èŠ‚

- **[åŸºç¡€æ¦‚å¿µ](./foundations.md)** - ç†è®ºè¯¦è§£
- **[å®è·µæŒ‡å—](./guides.md)** - å®ç°æŠ€å·§
- **[ä»£ç ç¤ºä¾‹](./examples.md)** - ç®—æ³•å®ç° â­
- **[è¿”å›æ¨¡å—é¦–é¡µ](./README.md)**

---

## ğŸ”— æ‰©å±•å­¦ä¹ 

### æ·±å…¥é˜…è¯»

- [å®Œæ•´çŸ¥è¯†å›¾è°±](../../crates/c08_algorithms/docs/KNOWLEDGE_GRAPH.md)
- [ç®—æ³•ç†è®º](../../crates/c08_algorithms/docs/theory/README.md)
- [å½¢å¼åŒ–åˆ†æ](../../crates/c08_algorithms/docs/theory_enhanced/README.md)

### ç›¸å…³æ¨¡å—

- **[C05: å¤šçº¿ç¨‹](../c05/README.md)** - å¹¶è¡Œç®—æ³•
- **[C06: å¼‚æ­¥ç¼–ç¨‹](../c06/README.md)** - å¼‚æ­¥ç®—æ³•
- **[C09: è®¾è®¡æ¨¡å¼](../c09/README.md)** - ç®—æ³•æ¨¡å¼

---

## ğŸ¯ å®è·µé¡¹ç›®å»ºè®®

### å…¥é—¨çº§

- å®ç°åŸºæœ¬æ’åºç®—æ³•
- äºŒå‰æ ‘éå†
- ç®€å•å›¾ç®—æ³•

### è¿›é˜¶çº§

- LRU ç¼“å­˜
- å¹¶å‘æ•°æ®ç»“æ„
- é«˜æ€§èƒ½å“ˆå¸Œè¡¨

### é«˜çº§

- åˆ†å¸ƒå¼ç®—æ³•
- æ— é”æ•°æ®ç»“æ„
- å®æ—¶ç³»ç»Ÿç®—æ³•

---

**ç†è§£ç®—æ³•ä¸æ•°æ®ç»“æ„çš„å…³ç³»æ˜¯é«˜æ•ˆç¼–ç¨‹çš„åŸºç¡€ï¼** ğŸš€
