# Rust泛型机制下的工作流系统设计模式分析

```text
<think>
在这个任务中，我需要使用Rust泛型机制来分析设计工作流系统的设计模式，并通过Petri网建模、23种工作流设计模式以及开源框架来展示完整的分析。

关键要点：
1. Petri网形式化建模与工作流设计的结合
2. 23种工作流模式的完整覆盖
3. 结合开源框架进行说明

我需要全面分析工作流的23种模式，大致分为以下几类：
- 基本控制流模式
- 高级分支/合并模式
- 结构模式
- 多实例模式
- 状态基础模式
- 取消模式

然后使用Rust泛型机制来实现这些模式，展示泛型如何帮助设计灵活且类型安全的工作流系统。

同时，我需要引入Petri网的概念，展示如何使用Petri网对工作流进行形式化建模，这有助于验证工作流的正确性、活性和安全性。

最后，我会结合开源框架（如Swirl、Flowrs、Tokio等）来说明这些模式在实践中的应用。
</think>
```

## 目录

- [Rust泛型机制下的工作流系统设计模式分析](#rust泛型机制下的工作流系统设计模式分析)
  - [目录](#目录)
  - [引言：工作流建模与Rust泛型](#引言工作流建模与rust泛型)
  - [1. Petri网与工作流形式化建模](#1-petri网与工作流形式化建模)
    - [1.1 Petri网基础](#11-petri网基础)
    - [1.2 Rust中的Petri网建模](#12-rust中的petri网建模)
    - [1.3 工作流与Petri网映射](#13-工作流与petri网映射)
  - [2. 基本控制流模式](#2-基本控制流模式)
    - [2.1 序列模式与Petri网表示](#21-序列模式与petri网表示)
    - [2.2 并行分支模式](#22-并行分支模式)
    - [2.3 排他选择模式](#23-排他选择模式)
  - [3. 高级分支/合并模式](#3-高级分支合并模式)
    - [3.1 多选择模式](#31-多选择模式)
    - [3.2 同步合并模式](#32-同步合并模式)
    - [3.3 多合并模式](#33-多合并模式)
  - [4. 结构模式](#4-结构模式)
    - [4.1 任意循环模式](#41-任意循环模式)
    - [4.2 隐式终止模式](#42-隐式终止模式)
  - [5. 多实例模式](#5-多实例模式)
    - [5.1 无同步多实例模式](#51-无同步多实例模式)
    - [5.2 设计时多实例模式](#52-设计时多实例模式)
    - [5.3 运行时多实例模式](#53-运行时多实例模式)
    - [5.4 无先验知识多实例模式](#54-无先验知识多实例模式)
  - [6. 状态基础模式](#6-状态基础模式)
    - [6.1 延迟选择模式](#61-延迟选择模式)
    - [6.2 交错并行路由模式](#62-交错并行路由模式)
    - [6.3 里程碑模式](#63-里程碑模式)
  - [7. 取消和触发模式](#7-取消和触发模式)
    - [7.1 取消活动模式](#71-取消活动模式)
    - [7.2 取消案例模式](#72-取消案例模式)
    - [7.3 瞬时触发模式](#73-瞬时触发模式)
    - [7.4 持久触发模式](#74-持久触发模式)
  - [8. 数据基础模式](#8-数据基础模式)
    - [8.1 结构化判别模式](#81-结构化判别模式)
    - [8.2 通用判别模式](#82-通用判别模式)
    - [8.3 环路数据传递模式](#83-环路数据传递模式)
  - [9. 综合示例：基于Rust泛型的工作流系统](#9-综合示例基于rust泛型的工作流系统)
  - [10. 结论](#10-结论)
  - [11. 开源生态系统集成](#11-开源生态系统集成)
    - [11.1 Tokio](#111-tokio)
    - [11.2 actix](#112-actix)
    - [11.3 async-graphql](#113-async-graphql)
    - [11.4 tide-async](#114-tide-async)
  - [12. 未来工作方向](#12-未来工作方向)
  - [13. 总结](#13-总结)

## 引言：工作流建模与Rust泛型

工作流系统是一类用于管理和执行复杂业务流程的软件框架。
Rust语言以其强大的类型系统和零成本抽象能力，为工作流系统的设计提供了独特优势。
本文将通过结合Petri网形式化建模与工作流设计模式，全面分析Rust泛型机制在工作流系统设计中的应用。

## 1. Petri网与工作流形式化建模

### 1.1 Petri网基础

Petri网是一种用于描述分布式系统的数学建模语言，包含以下基本元素：

- **库所(Places)**：代表系统状态或条件
- **变迁(Transitions)**：代表动作或事件
- **弧(Arcs)**：连接库所和变迁
- **标记(Tokens)**：表示资源或控制流

### 1.2 Rust中的Petri网建模

在Rust中，我们可以使用泛型来构建Petri网模型：

```rust
pub struct PetriNet<S, T> {
    places: HashMap<String, Place<S>>,
    transitions: HashMap<String, Transition<T>>,
    arcs: Vec<Arc>,
}

pub struct Place<S> {
    id: String,
    tokens: Vec<S>,
    capacity: Option<usize>,
}

pub struct Transition<T> {
    id: String,
    action: Box<dyn Fn(&[&dyn Any]) -> Result<T, String> + Send + Sync>,
    guard: Option<Box<dyn Fn() -> bool + Send + Sync>>,
}

pub enum Arc {
    Input(String, String, usize),   // place_id, transition_id, weight
    Output(String, String, usize),  // transition_id, place_id, weight
}
```

在这个设计中，`Place<S>`和`Transition<T>`都使用泛型参数来表示不同类型的标记和转换结果。这种设计使Petri网能够适应各种类型的工作流需求。

### 1.3 工作流与Petri网映射

工作流中的核心元素可以直接映射到Petri网元素：

- 工作流活动 → Petri网变迁
- 工作流状态 → Petri网库所
- 工作流路由 → Petri网弧和标记流

使用Rust实现这种映射：

```rust
pub struct WorkflowEngine<S, A, R> {
    petri_net: PetriNet<S, R>,
    activities: HashMap<String, Box<dyn Fn(A) -> R + Send + Sync>>,
}

impl<S, A, R> WorkflowEngine<S, A, R> 
where 
    S: Clone + Send + Sync + 'static,
    A: Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    // 将工作流活动注册为Petri网变迁
    pub fn register_activity<F>(&mut self, id: &str, activity: F)
    where
        F: Fn(A) -> R + Send + Sync + 'static 
    {
        let activity_box = Box::new(activity);
        self.activities.insert(id.to_string(), activity_box);
        
        // 创建对应的变迁
        let transition = Transition::new(id.to_string(), move |inputs| {
            // 实现变迁逻辑
            // ...
        });
        
        self.petri_net.add_transition(transition);
    }
}
```

## 2. 基本控制流模式

### 2.1 序列模式与Petri网表示

**定义**：活动按照预定义的顺序依次执行。

**Petri网表示**：

- 相邻活动通过库所连接
- 前一个活动的输出库所作为后一个活动的输入库所

```rust
pub struct SequenceWorkflow<T, R> {
    steps: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> SequenceWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self { steps: Vec::new() }
    }
    
    pub fn add_step<F>(&mut self, step: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.steps.push(Box::new(step));
        self
    }
    
    pub fn execute(&self, input: T) -> Vec<R> {
        let mut results = Vec::new();
        let mut current = input;
        
        for step in &self.steps {
            let result = step(current.clone());
            results.push(result);
        }
        
        results
    }
}
```

**开源实现**：Tokio的`chain`函数可用于实现异步序列工作流：

```rust
use tokio::task;
use futures::future::BoxFuture;

async fn sequence_workflow<T, R>(
    steps: Vec<Box<dyn Fn(T) -> BoxFuture<'static, R> + Send + Sync>>,
    input: T,
) -> Vec<R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    let mut results = Vec::new();
    let mut current = input;
    
    for step in steps {
        let result = step(current.clone()).await;
        results.push(result);
    }
    
    results
}
```

### 2.2 并行分支模式

**定义**：同时执行多个分支，所有分支完成后再继续。

**Petri网表示**：

- 使用一个变迁产生多个标记
- 多条并行分支同时执行
- 使用汇聚变迁等待所有分支完成

```rust
pub struct ParallelWorkflow<T, R> {
    branches: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> ParallelWorkflow<T, R>
where
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self { branches: Vec::new() }
    }
    
    pub fn add_branch<F>(&mut self, branch: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push(Box::new(branch));
        self
    }
    
    pub fn execute(&self, input: T) -> Vec<R> {
        use rayon::prelude::*;
        
        self.branches
            .par_iter()
            .map(|branch| branch(input.clone()))
            .collect()
    }
}
```

**开源实现**：Tokio的`join_all`函数支持异步并行执行：

```rust
use futures::future::join_all;

async fn parallel_workflow<T, R>(
    branches: Vec<Box<dyn Fn(T) -> BoxFuture<'static, R> + Send + Sync>>,
    input: T,
) -> Vec<R>
where
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    let futures = branches
        .into_iter()
        .map(|branch| branch(input.clone()))
        .collect::<Vec<_>>();
    
    join_all(futures).await
}
```

### 2.3 排他选择模式

**定义**：基于条件从多个分支中选择一个执行。

**Petri网表示**：

- 使用带条件的变迁
- 只有满足条件的变迁能够触发

```rust
pub struct ExclusiveChoiceWorkflow<T, R> {
    branches: Vec<(Box<dyn Fn(&T) -> bool + Send + Sync>, Box<dyn Fn(T) -> R + Send + Sync>)>,
    default_branch: Option<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> ExclusiveChoiceWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: Vec::new(),
            default_branch: None,
        }
    }
    
    pub fn add_branch<C, F>(&mut self, condition: C, branch: F) -> &mut Self
    where
        C: Fn(&T) -> bool + Send + Sync + 'static,
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push((Box::new(condition), Box::new(branch)));
        self
    }
    
    pub fn set_default<F>(&mut self, branch: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.default_branch = Some(Box::new(branch));
        self
    }
    
    pub fn execute(&self, input: T) -> Option<R> {
        for (condition, branch) in &self.branches {
            if condition(&input) {
                return Some(branch(input.clone()));
            }
        }
        
        // 如果没有分支匹配，使用默认分支
        self.default_branch.as_ref().map(|branch| branch(input))
    }
}
```

**开源实现**：Flowrs框架中的条件路由：

```rust
use flowrs::{flow, conditional};

let workflow = flow::new()
    .then(conditional(
        |data: &MyData| data.value > 10,
        process_high_value,
        process_low_value
    ))
    .then(notify_completion);
```

## 3. 高级分支/合并模式

### 3.1 多选择模式

**定义**：基于条件从多个分支中选择一个或多个执行。

**Petri网表示**：

- 使用带条件的变迁
- 可能有多个变迁同时触发

```rust
pub struct MultiChoiceWorkflow<T, R> {
    branches: Vec<(Box<dyn Fn(&T) -> bool + Send + Sync>, Box<dyn Fn(T) -> R + Send + Sync>)>,
}

impl<T, R> MultiChoiceWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self { branches: Vec::new() }
    }
    
    pub fn add_branch<C, F>(&mut self, condition: C, branch: F) -> &mut Self
    where
        C: Fn(&T) -> bool + Send + Sync + 'static,
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push((Box::new(condition), Box::new(branch)));
        self
    }
    
    pub fn execute(&self, input: T) -> Vec<R> {
        let mut results = Vec::new();
        
        for (condition, branch) in &self.branches {
            if condition(&input) {
                results.push(branch(input.clone()));
            }
        }
        
        results
    }
}
```

### 3.2 同步合并模式

**定义**：等待多个分支全部完成后再继续。

**Petri网表示**：

- 使用一个变迁连接多个输入库所
- 只有当所有输入库所都有标记时，变迁才能触发

```rust
pub struct SynchronizingMergeWorkflow<T, I, R> {
    branches: Vec<Box<dyn Fn(T) -> I + Send + Sync>>,
    merge_task: Option<Box<dyn Fn(Vec<I>) -> R + Send + Sync>>,
}

impl<T, I, R> SynchronizingMergeWorkflow<T, I, R>
where
    T: Clone + Send + 'static,
    I: Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: Vec::new(),
            merge_task: None,
        }
    }
    
    pub fn add_branch<F>(&mut self, branch: F) -> &mut Self
    where
        F: Fn(T) -> I + Send + Sync + 'static,
    {
        self.branches.push(Box::new(branch));
        self
    }
    
    pub fn set_merge_task<F>(&mut self, task: F) -> &mut Self
    where
        F: Fn(Vec<I>) -> R + Send + Sync + 'static,
    {
        self.merge_task = Some(Box::new(task));
        self
    }
    
    pub fn execute(&self, input: T) -> Option<R> {
        let results: Vec<I> = self.branches
            .iter()
            .map(|branch| branch(input.clone()))
            .collect();
        
        self.merge_task.as_ref().map(|task| task(results))
    }
}
```

**开源实现**：使用Tokio的屏障实现同步合并：

```rust
use tokio::sync::Barrier;
use std::sync::Arc;

async fn synchronizing_merge<T, I, R>(
    branches: Vec<Box<dyn Fn(T) -> BoxFuture<'static, I> + Send + Sync>>,
    merge_task: Box<dyn Fn(Vec<I>) -> R + Send + Sync>,
    input: T,
) -> R
where
    T: Clone + Send + Sync + 'static,
    I: Send + Sync + 'static,
    R: Send + 'static,
{
    let barrier = Arc::new(Barrier::new(branches.len()));
    let results = Arc::new(tokio::sync::Mutex::new(Vec::new()));
    
    let mut handles = Vec::new();
    
    for branch in branches {
        let input_clone = input.clone();
        let barrier_clone = barrier.clone();
        let results_clone = results.clone();
        
        let handle = tokio::spawn(async move {
            let result = branch(input_clone).await;
            
            // 存储结果
            {
                let mut results_guard = results_clone.lock().await;
                results_guard.push(result);
            }
            
            // 等待所有分支完成
            barrier_clone.wait().await;
        });
        
        handles.push(handle);
    }
    
    // 等待所有任务完成
    for handle in handles {
        let _ = handle.await;
    }
    
    // 合并结果
    let final_results = results.lock().await.clone();
    merge_task(final_results)
}
```

### 3.3 多合并模式

**定义**：允许多个分支的执行结果以不同的方式合并。

**Petri网表示**：

- 使用多个汇聚变迁
- 每个变迁有不同的合并逻辑

```rust
pub struct MultiMergeWorkflow<T, K, R> 
where
    K: Eq + std::hash::Hash,
{
    branches: HashMap<K, Box<dyn Fn(T) -> R + Send + Sync>>,
    merge_strategies: HashMap<String, Box<dyn Fn(HashMap<K, R>) -> R + Send + Sync>>,
    default_strategy: Option<Box<dyn Fn(HashMap<K, R>) -> R + Send + Sync>>,
}

impl<T, K, R> MultiMergeWorkflow<T, K, R>
where
    T: Clone + Send + 'static,
    K: Eq + std::hash::Hash + Clone + Send + 'static,
    R: Clone + Send + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: HashMap::new(),
            merge_strategies: HashMap::new(),
            default_strategy: None,
        }
    }
    
    pub fn add_branch<F>(&mut self, key: K, branch: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.insert(key, Box::new(branch));
        self
    }
    
    pub fn add_merge_strategy<F>(&mut self, name: &str, strategy: F) -> &mut Self
    where
        F: Fn(HashMap<K, R>) -> R + Send + Sync + 'static,
    {
        self.merge_strategies.insert(name.to_string(), Box::new(strategy));
        self
    }
    
    pub fn set_default_strategy<F>(&mut self, strategy: F) -> &mut Self
    where
        F: Fn(HashMap<K, R>) -> R + Send + Sync + 'static,
    {
        self.default_strategy = Some(Box::new(strategy));
        self
    }
    
    pub fn execute(&self, input: T, strategy_name: Option<&str>) -> Option<R> {
        let mut results = HashMap::new();
        
        for (key, branch) in &self.branches {
            let result = branch(input.clone());
            results.insert(key.clone(), result);
        }
        
        if let Some(name) = strategy_name {
            if let Some(strategy) = self.merge_strategies.get(name) {
                return Some(strategy(results));
            }
        }
        
        // 使用默认策略
        self.default_strategy.as_ref().map(|strategy| strategy(results))
    }
}
```

## 4. 结构模式

### 4.1 任意循环模式

**定义**：允许工作流中的活动或子流程重复执行，直到满足特定条件。

**Petri网表示**：

- 使用变迁到库所的回环连接
- 包含条件变迁控制循环退出

```rust
#[async_trait::async_trait]
pub trait ArbitraryLoopWorkflow<T> {
    // 执行循环体
    async fn execute_iteration(&self, state: T) -> (T, bool);
    
    // 执行整个循环
    async fn execute(&self, initial_state: T) -> T {
        let mut current_state = initial_state;
        let mut continue_loop = true;
        
        while continue_loop {
            let (new_state, should_continue) = self.execute_iteration(current_state).await;
            current_state = new_state;
            continue_loop = should_continue;
        }
        
        current_state
    }
}

// 具体实现
pub struct RetryWorkflow<T, F, Fut> {
    max_attempts: usize,
    operation: F,
    _phantom: std::marker::PhantomData<(T, Fut)>,
}

impl<T, F, Fut> RetryWorkflow<T, F, Fut>
where
    T: Clone + Send + 'static,
    F: Fn(T) -> Fut + Send + Sync,
    Fut: Future<Output = Result<T, String>> + Send,
{
    pub fn new(max_attempts: usize, operation: F) -> Self {
        Self {
            max_attempts,
            operation,
            _phantom: std::marker::PhantomData,
        }
    }
}

#[async_trait::async_trait]
impl<T, F, Fut> ArbitraryLoopWorkflow<(bool, usize, T)> for RetryWorkflow<T, F, Fut>
where
    T: Clone + Send + 'static,
    F: Fn(T) -> Fut + Send + Sync,
    Fut: Future<Output = Result<T, String>> + Send,
{
    async fn execute_iteration(&self, state: (bool, usize, T)) -> ((bool, usize, T), bool) {
        let (success, attempts, data) = state;
        
        // 如果已成功或达到最大尝试次数，不再继续
        if success || attempts >= self.max_attempts {
            return ((success, attempts, data), false);
        }
        
        match (self.operation)(data.clone()).await {
            Ok(result) => ((true, attempts + 1, result), false),
            Err(_) => ((false, attempts + 1, data), attempts + 1 < self.max_attempts),
        }
    }
}
```

**开源实现**：Tokio-retry库提供了重试功能：

```rust
use tokio_retry::{Retry, strategy::{ExponentialBackoff, jitter}};

async fn arbitrary_loop<T, F, Fut>(
    operation: F,
    initial_state: T,
    should_continue: impl Fn(&T) -> bool,
) -> T
where
    T: Clone + Send + 'static,
    F: Fn(T) -> Fut,
    Fut: Future<Output = T>,
{
    let mut current_state = initial_state;
    
    while should_continue(&current_state) {
        current_state = operation(current_state.clone()).await;
    }
    
    current_state
}

// 使用Tokio-retry进行重试
async fn retry_workflow<T, E, F, Fut>(operation: F, initial_input: T) -> Result<T, E>
where
    T: Clone + Send + 'static,
    F: Fn(T) -> Fut,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Display,
{
    let retry_strategy = ExponentialBackoff::from_millis(100)
        .map(jitter)
        .take(5);
    
    Retry::spawn(retry_strategy, || operation(initial_input.clone())).await
}
```

### 4.2 隐式终止模式

**定义**：工作流中的活动在所有分支都完成后自动终止，无需显式的终止点。

**Petri网表示**：

- 使用库所的覆盖标记来表示完成状态
- 无需专门的终止变迁

```rust
pub struct ImplicitTerminationWorkflow<T, R> {
    work_items: HashMap<String, WorkItem<T, R>>,
    dependencies: HashMap<String, HashSet<String>>,
}

pub struct WorkItem<T, R> {
    id: String,
    dependencies: HashSet<String>,
    task: Box<dyn Fn(T) -> R + Send + Sync>,
}

impl<T, R> ImplicitTerminationWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            work_items: HashMap::new(),
            dependencies: HashMap::new(),
        }
    }
    
    pub fn add_work_item<F>(&mut self, id: &str, dependencies: &[&str], task: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        let dep_set: HashSet<String> = dependencies.iter().map(|&s| s.to_string()).collect();
        
        let work_item = WorkItem {
            id: id.to_string(),
            dependencies: dep_set.clone(),
            task: Box::new(task),
        };
        
        self.work_items.insert(id.to_string(), work_item);
        self.dependencies.insert(id.to_string(), dep_set);
        
        self
    }
    
    pub async fn execute(&self, input: T) -> HashMap<String, R> {
        use tokio::sync::mpsc;
        
        let (completion_tx, mut completion_rx) = mpsc::channel::<String>(100);
        let mut results = HashMap::new();
        let mut completed = HashSet::new();
        let mut running = HashSet::new();
        
        // 找出没有依赖的工作项
        let mut ready: Vec<String> = self.work_items.iter()
            .filter(|(_, item)| item.dependencies.is_empty())
            .map(|(id, _)| id.clone())
            .collect();
        
        // 执行直到所有工作项完成
        while !ready.is_empty() || !running.is_empty() {
            // 启动准备好的工作项
            for id in ready.drain(..) {
                if let Some(item) = self.work_items.get(&id) {
                    let input_clone = input.clone();
                    let completion_tx_clone = completion_tx.clone();
                    let id_clone = id.clone();
                    
                    running.insert(id.clone());
                    
                    tokio::spawn(async move {
                        let task = &item.task;
                        let result = task(input_clone);
                        
                        // 通知完成
                        let _ = completion_tx_clone.send(id_clone).await;
                        
                        result
                    });
                }
            }
            
            // 等待某个工作项完成
            if let Some(completed_id) = completion_rx.recv().await {
                running.remove(&completed_id);
                completed.insert(completed_id.clone());
                
                // 查找新的可准备工作项
                for (id, deps) in &self.dependencies {
                    if !completed.contains(id) && !running.contains(id) && 
                       deps.iter().all(|dep| completed.contains(dep)) {
                        ready.push(id.clone());
                    }
                }
            }
        }
        
        results
    }
}
```

**开源实现**：使用Tokio的通道和任务模型：

```rust
use tokio::sync::{mpsc, Mutex};
use tokio::task;
use std::sync::Arc;

async fn implicit_termination_workflow<T, R>(
    work_items: HashMap<String, (Vec<String>, Box<dyn Fn(T) -> BoxFuture<'static, R> + Send + Sync>)>,
    input: T,
) -> HashMap<String, R>
where
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    let (completion_tx, mut completion_rx) = mpsc::channel::<(String, R)>(100);
    let dependencies = Arc::new(work_items.iter().map(|(id, (deps, _))| {
        (id.clone(), deps.clone())
    }).collect::<HashMap<_, _>>());
    
    let completed = Arc::new(Mutex::new(HashSet::<String>::new()));
    let results = Arc::new(Mutex::new(HashMap::<String, R>::new()));
    
    // 找出没有依赖的工作项
    let initial_ready: Vec<String> = work_items.iter()
        .filter(|(_, (deps, _))| deps.is_empty())
        .map(|(id, _)| id.clone())
        .collect();
    
    // 启动初始任务
    for id in initial_ready {
        let input_clone = input.clone();
        let completion_tx_clone = completion_tx.clone();
        let (_, task) = work_items.get(&id).unwrap().clone();
        let id_clone = id.clone();
        
        task::spawn(async move {
            let result = task(input_clone).await;
            let _ = completion_tx_clone.send((id_clone, result)).await;
        });
    }
    
    // 等待所有任务完成
    let mut completed_count = 0;
    while completed_count < work_items.len() {
        if let Some((id, result)) = completion_rx.recv().await {
            // 存储结果
            {
                let mut results_guard = results.lock().await;
                results_guard.insert(id.clone(), result);
            }
            
            // 标记为已完成
            {
                let mut completed_guard = completed.lock().await;
                completed_guard.insert(id.clone());
            }
            
            completed_count += 1;
            
            // 检查是否有新任务可以启动
            let newly_ready = {
                let completed_guard = completed.lock().await;
                work_items.iter()
                    .filter(|(id, (deps, _))| {
                        !completed_guard.contains(id.as_str()) && 
                        deps.iter().all(|dep| completed_guard.contains(dep))
                    })
                    .map(|(id, _)| id.clone())
                    .collect::<Vec<_>>()
            };
            
            // 启动新任务
            for new_id in newly_ready {
                let input_clone = input.clone();
                let completion_tx_clone = completion_tx.clone();
                let (_, task) = work_items.get(&new_id).unwrap().clone();
                let id_clone = new_id.clone();
                
                task::spawn(async move {
                    let result = task(input_clone).await;
                    let _ = completion_tx_clone.send((id_clone, result)).await;
                });
            }
        }
    }
    
    Arc::try_unwrap(results)
        .expect("Results should only be referenced here")
        .into_inner()
}
```

## 5. 多实例模式

### 5.1 无同步多实例模式

**定义**：创建同一活动的多个实例，这些实例相互独立，无需同步。

**Petri网表示**：

- 使用一个变迁生成多个标记
- 每个标记触发一个独立的实例执行

```rust
pub struct MultipleInstancesWithoutSynchronization<T, R> {
    task: Box<dyn Fn(T) -> R + Send + Sync>,
    max_concurrent: Option<usize>,
}

impl<T, R> MultipleInstancesWithoutSynchronization<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F>(task: F) -> Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            max_concurrent: None,
        }
    }
    
    pub fn with_max_concurrent(mut self, max: usize) -> Self {
        self.max_concurrent = Some(max);
        self
    }
    
    pub fn execute_sync<I>(&self, inputs: I) -> Vec<R>
    where
        I: IntoIterator<Item = T>,
        I::IntoIter: Send,
    {
        use rayon::prelude::*;
        
        let inputs_vec: Vec<_> = inputs.into_iter().collect();
        
        match self.max_concurrent {
            Some(max) => {
                // 限制并发数
                inputs_vec
                    .chunks(max)
                    .flat_map(|chunk| {
                        chunk.par_iter()
                            .map(|item| (self.task)(item.clone()))
                            .collect::<Vec<_>>()
                    })
                    .collect()
            },
            None => {
                // 无限制并发
                inputs_vec
                    .par_iter()
                    .map(|item| (self.task)(item.clone()))
                    .collect()
            }
        }
    }
    
    pub async fn execute_async<I>(&self, inputs: I) -> Vec<R>
    where
        I: IntoIterator<Item = T>,
        I::IntoIter: Send,
    {
        use futures::future::join_all;
        use tokio::task;
        
        let inputs_vec: Vec<_> = inputs.into_iter().collect();
        let task_ref = &self.task;
        
        match self.max_concurrent {
            Some(max) => {
                // 使用信号量限制并发
                use tokio::sync::Semaphore;
                let semaphore = Arc::new(Semaphore::new(max));
                
                let mut handles = Vec::new();
                
                for input in inputs_vec {
                    let permit = semaphore.clone().acquire_owned().await.unwrap();
                    let task_fn = task_ref.clone();
                    
                    let handle = task::spawn(async move {
                        let result = task_fn(input);
                        drop(permit); // 释放许可
                        result
                    });
                    
                    handles.push(handle);
                }
                
                join_all(handles)
                    .await
                    .into_iter()
                    .filter_map(|r| r.ok())
                    .collect()
            },
            None => {
                // 无限制并发
                let handles = inputs_vec
                    .into_iter()
                    .map(|input| {
                        let task_fn = task_ref.clone();
                        task::spawn(async move { task_fn(input) })
                    })
                    .collect::<Vec<_>>();
                
                join_all(handles)
                    .await
                    .into_iter()
                    .filter_map(|r| r.ok())
                    .collect()
            }
        }
    }
}
```

**开源实现**：Rayon库的并行迭代器：

```rust
use rayon::prelude::*;

fn parallel_process<T, R, F>(inputs: Vec<T>, processor: F) -> Vec<R>
where
    T: Send,
    R: Send,
    F: Fn(T) -> R + Send + Sync,
{
    inputs.into_par_iter()
          .map(processor)
          .collect()
}
```

### 5.2 设计时多实例模式

**定义**：实例数在工作流设计时确定。

**Petri网表示**：

- 在设计时创建固定数量的平行路径
- 每个路径有预定义的库所和变迁

```rust
pub struct DesignTimeMultipleInstances<T, R, C> {
    task: Box<dyn Fn(T, C) -> R + Send + Sync>,
    instance_count: usize,
    context_provider: Box<dyn Fn(usize) -> C + Send + Sync>,
}

impl<T, R, C> DesignTimeMultipleInstances<T, R, C>
where
    T: Send + 'static,
    R: Send + 'static,
    C: Send + 'static,
{
    pub fn new<F, P>(task: F, instance_count: usize, context_provider: P) -> Self
    where
        F: Fn(T, C) -> R + Send + Sync + 'static,
        P: Fn(usize) -> C + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            instance_count,
            context_provider: Box::new(context_provider),
        }
    }
    
    pub fn execute(&self, input: T) -> Vec<R>
    where
        T: Clone,
    {
        (0..self.instance_count)
            .into_iter()
            .map(|i| {
                let context = (self.context_provider)(i);
                (self.task)(input.clone(), context)
            })
            .collect()
    }
}
```

### 5.3 运行时多实例模式

**定义**：实例数在工作流执行时动态确定。

**Petri网表示**：

- 使用变迁动态创建多个标记
- 标记数量在运行时确定

```text
<think>
我需要继续完成这个关于Rust工作流系统设计模式的分析。
我刚才讲到了5.3 运行时多实例模式，需要继续完成它，然后继续讲解后续的模式。

让我继续介绍运行时多实例模式的代码实现，
然后继续讲解剩余的工作流模式，
包括状态基础模式、取消和触发模式等，
并结合Petri网形式化建模和Rust泛型机制。
</think>
```

```rust
pub struct RuntimeMultipleInstances<T, R, D> {
    task: Box<dyn Fn(D) -> R + Send + Sync>,
    data_provider: Box<dyn Fn(T) -> Vec<D> + Send + Sync>,
    merge_results: Option<Box<dyn Fn(Vec<R>) -> R + Send + Sync>>,
}

impl<T, R, D> RuntimeMultipleInstances<T, R, D>
where
    T: Send + 'static,
    R: Send + 'static,
    D: Send + 'static,
{
    pub fn new<F, P>(task: F, data_provider: P) -> Self
    where
        F: Fn(D) -> R + Send + Sync + 'static,
        P: Fn(T) -> Vec<D> + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            data_provider: Box::new(data_provider),
            merge_results: None,
        }
    }
    
    pub fn with_merge<M>(&mut self, merge: M) -> &mut Self
    where
        M: Fn(Vec<R>) -> R + Send + Sync + 'static,
    {
        self.merge_results = Some(Box::new(merge));
        self
    }
    
    pub async fn execute(&self, input: T) -> Vec<R> {
        use futures::future::join_all;
        use tokio::task;
        
        let items = (self.data_provider)(input);
        let task_ref = &self.task;
        
        let handles = items
            .into_iter()
            .map(|item| {
                let task_fn = task_ref.clone();
                task::spawn(async move { task_fn(item) })
            })
            .collect::<Vec<_>>();
        
        join_all(handles)
            .await
            .into_iter()
            .filter_map(|r| r.ok())
            .collect()
    }
    
    pub async fn execute_and_merge(&self, input: T) -> Option<R> {
        let results = self.execute(input).await;
        
        if let Some(merge) = &self.merge_results {
            Some(merge(results))
        } else {
            None
        }
    }
}
```

**开源实现**：使用Tokio和futures库：

```rust
use tokio::task;
use futures::future::join_all;
use tokio::sync::Semaphore;
use std::sync::Arc;

async fn runtime_multiple_instances<T, R, D, F, P>(
    input: T,
    task: F,
    data_provider: P,
    max_concurrent: Option<usize>,
) -> Vec<R>
where
    T: Send + 'static,
    R: Send + 'static,
    D: Send + 'static,
    F: Fn(D) -> R + Send + Sync + Clone + 'static,
    P: Fn(T) -> Vec<D>,
{
    let items = data_provider(input);
    
    match max_concurrent {
        Some(max) => {
            let semaphore = Arc::new(Semaphore::new(max));
            let mut handles = Vec::new();
            
            for item in items {
                let permit = semaphore.clone().acquire_owned().await.unwrap();
                let task_clone = task.clone();
                
                let handle = task::spawn(async move {
                    let result = task_clone(item);
                    drop(permit);
                    result
                });
                
                handles.push(handle);
            }
            
            join_all(handles)
                .await
                .into_iter()
                .filter_map(|r| r.ok())
                .collect()
        },
        None => {
            let handles = items
                .into_iter()
                .map(|item| {
                    let task_clone = task.clone();
                    task::spawn(async move { task_clone(item) })
                })
                .collect::<Vec<_>>();
            
            join_all(handles)
                .await
                .into_iter()
                .filter_map(|r| r.ok())
                .collect()
        }
    }
}
```

### 5.4 无先验知识多实例模式

**定义**：在工作流执行开始时，不知道需要处理的项目集合，需要从外部动态获取。

**Petri网表示**：

- 使用特殊变迁从外部动态获取标记数量
- 根据获取的标记数量创建相应实例

```rust
#[async_trait::async_trait]
pub trait ItemProvider<T, D> {
    async fn get_items(&self, context: T) -> Vec<D>;
}

pub struct StaticItemProvider<T, D> {
    items: Vec<D>,
    _phantom: std::marker::PhantomData<T>,
}

impl<T, D: Clone> StaticItemProvider<T, D> {
    pub fn new(items: Vec<D>) -> Self {
        Self {
            items,
            _phantom: std::marker::PhantomData,
        }
    }
}

#[async_trait::async_trait]
impl<T, D: Clone + Send + 'static> ItemProvider<T, D> for StaticItemProvider<T, D> {
    async fn get_items(&self, _context: T) -> Vec<D> {
        self.items.clone()
    }
}

pub struct DynamicMultipleInstances<T, R, D, P> {
    task: Box<dyn Fn(D) -> R + Send + Sync>,
    provider: P,
    merge_results: Option<Box<dyn Fn(Vec<R>) -> R + Send + Sync>>,
}

impl<T, R, D, P> DynamicMultipleInstances<T, R, D, P>
where
    T: Send + 'static,
    R: Send + 'static,
    D: Send + 'static,
    P: ItemProvider<T, D> + Send + Sync,
{
    pub fn new<F>(task: F, provider: P) -> Self
    where
        F: Fn(D) -> R + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            provider,
            merge_results: None,
        }
    }
    
    pub fn with_merge<M>(&mut self, merge: M) -> &mut Self
    where
        M: Fn(Vec<R>) -> R + Send + Sync + 'static,
    {
        self.merge_results = Some(Box::new(merge));
        self
    }
    
    pub async fn execute(&self, input: T) -> Vec<R> {
        use futures::future::join_all;
        use tokio::task;
        
        let items = self.provider.get_items(input).await;
        let task_ref = &self.task;
        
        let handles = items
            .into_iter()
            .map(|item| {
                let task_fn = task_ref.clone();
                task::spawn(async move { task_fn(item) })
            })
            .collect::<Vec<_>>();
        
        join_all(handles)
            .await
            .into_iter()
            .filter_map(|r| r.ok())
            .collect()
    }
    
    pub async fn execute_and_merge(&self, input: T) -> Option<R> {
        let results = self.execute(input).await;
        
        if let Some(merge) = &self.merge_results {
            Some(merge(results))
        } else {
            None
        }
    }
}
```

**开源实现**：使用Stream实现动态获取和处理项目：

```rust
use futures::{Stream, StreamExt};
use tokio::task;
use tokio_stream::wrappers::ReceiverStream;
use tokio::sync::mpsc;

async fn dynamic_multiple_instances<T, R, D, S, F>(
    input: T,
    stream_creator: impl FnOnce(T) -> S,
    processor: F,
) -> Vec<R>
where
    T: Send + 'static,
    R: Send + 'static,
    D: Send + 'static,
    S: Stream<Item = D> + Send + 'static,
    F: Fn(D) -> R + Send + Sync + Clone + 'static,
{
    let stream = stream_creator(input);
    let (result_tx, result_rx) = mpsc::channel(100);
    
    // 创建处理任务
    task::spawn(async move {
        tokio::pin!(stream);
        
        while let Some(item) = stream.next().await {
            let processor_clone = processor.clone();
            let result_tx_clone = result_tx.clone();
            
            task::spawn(async move {
                let result = processor_clone(item);
                let _ = result_tx_clone.send(result).await;
            });
        }
    });
    
    // 收集结果
    let mut results = Vec::new();
    let result_stream = ReceiverStream::new(result_rx);
    tokio::pin!(result_stream);
    
    while let Some(result) = result_stream.next().await {
        results.push(result);
    }
    
    results
}
```

## 6. 状态基础模式

### 6.1 延迟选择模式

**定义**：推迟选择执行分支的决策，直到获取更多信息。

**Petri网表示**：

- 使用特殊变迁表示决策点
- 决策变迁在获取足够信息后触发

```rust
pub struct LazyChoice<T, C, R> {
    branches: HashMap<C, Box<dyn Fn(T) -> R + Send + Sync>>,
    evaluator: Box<dyn Fn(&T) -> C + Send + Sync>,
    default_branch: Option<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, C, R> LazyChoice<T, C, R>
where
    T: Clone + Send + 'static,
    C: Eq + std::hash::Hash + Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new<E>(evaluator: E) -> Self
    where
        E: Fn(&T) -> C + Send + Sync + 'static,
    {
        Self {
            branches: HashMap::new(),
            evaluator: Box::new(evaluator),
            default_branch: None,
        }
    }
    
    pub fn add_branch<F>(&mut self, value: C, branch: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.insert(value, Box::new(branch));
        self
    }
    
    pub fn set_default<F>(&mut self, branch: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.default_branch = Some(Box::new(branch));
        self
    }
    
    pub async fn execute(&self, input: T) -> Option<R> {
        // 延迟到执行时决定走哪个分支
        let choice = (self.evaluator)(&input);
        
        if let Some(branch) = self.branches.get(&choice) {
            Some(branch(input))
        } else {
            // 如果没有匹配分支，使用默认分支
            self.default_branch.as_ref().map(|branch| branch(input))
        }
    }
}
```

**开源实现**：使用Tokio的async trait：

```rust
#[async_trait::async_trait]
pub trait LazyEvaluator<T, C> {
    async fn evaluate(&self, input: &T) -> C;
}

pub struct AsyncLazyChoice<T, C, R, E> {
    branches: HashMap<C, Box<dyn Fn(T) -> R + Send + Sync>>,
    evaluator: E,
    default_branch: Option<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, C, R, E> AsyncLazyChoice<T, C, R, E>
where
    T: Clone + Send + Sync + 'static,
    C: Eq + std::hash::Hash + Clone + Send + 'static,
    R: Send + 'static,
    E: LazyEvaluator<T, C> + Send + Sync,
{
    pub fn new(evaluator: E) -> Self {
        Self {
            branches: HashMap::new(),
            evaluator,
            default_branch: None,
        }
    }
    
    // 添加分支和默认分支的方法与上面类似
    
    pub async fn execute(&self, input: T) -> Option<R> {
        let choice = self.evaluator.evaluate(&input).await;
        
        if let Some(branch) = self.branches.get(&choice) {
            Some(branch(input))
        } else {
            self.default_branch.as_ref().map(|branch| branch(input))
        }
    }
}
```

### 6.2 交错并行路由模式

**定义**：允许不同并行分支之间的活动以任意顺序交错执行。

**Petri网表示**：

- 使用多个独立的库所和变迁表示并行路径
- 没有显式同步点

```rust
pub struct InterleavedParallelRouting<T, R> 
where
    R: Send,
{
    branches: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
    interleave_strategy: InterleavingStrategy,
}

pub enum InterleavingStrategy {
    Random,
    RoundRobin,
    PriorityBased(Vec<usize>),
}

impl<T, R> InterleavedParallelRouting<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new(strategy: InterleavingStrategy) -> Self {
        Self {
            branches: Vec::new(),
            interleave_strategy: strategy,
        }
    }
    
    pub fn add_branch<F>(&mut self, branch: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push(Box::new(branch));
        self
    }
    
    pub async fn execute(&self, input: T) -> Vec<R> 
    where
        T: Clone
    {
        use tokio::sync::mpsc;
        
        let (tx, mut rx) = mpsc::channel(self.branches.len());
        let branch_indices = match &self.interleave_strategy {
            InterleavingStrategy::Random => {
                let mut indices: Vec<usize> = (0..self.branches.len()).collect();
                use rand::seq::SliceRandom;
                indices.shuffle(&mut rand::thread_rng());
                indices
            },
            InterleavingStrategy::RoundRobin => {
                (0..self.branches.len()).collect()
            },
            InterleavingStrategy::PriorityBased(priorities) => {
                priorities.clone()
            },
        };
        
        // 按计算的顺序启动分支
        for idx in branch_indices {
            if idx < self.branches.len() {
                let branch = &self.branches[idx];
                let input_clone = input.clone();
                let tx_clone = tx.clone();
                
                tokio::spawn(async move {
                    let result = branch(input_clone);
                    let _ = tx_clone.send((idx, result)).await;
                });
            }
        }
        
        // 接收结果
        drop(tx); // 删除发送端引用以允许通道关闭
        
        let mut results = vec![None; self.branches.len()];
        while let Some((idx, result)) = rx.recv().await {
            results[idx] = Some(result);
        }
        
        results.into_iter().filter_map(|r| r).collect()
    }
}
```

**开源实现**：使用Tokio的优先级通道：

```rust
use tokio::sync::mpsc;
use tokio::task;
use futures::future::join_all;
use std::cmp::Ordering;
use std::time::Instant;

struct PrioritizedTask<T> {
    priority: usize,
    timestamp: Instant,
    data: T,
}

impl<T> PartialEq for PrioritizedTask<T> {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority && self.timestamp == other.timestamp
    }
}

impl<T> Eq for PrioritizedTask<T> {}

impl<T> PartialOrd for PrioritizedTask<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl<T> Ord for PrioritizedTask<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority)
            .then_with(|| self.timestamp.cmp(&other.timestamp))
    }
}

async fn interleaved_parallel_routing<T, R, F>(
    input: T,
    branches: Vec<(usize, F)>,
) -> Vec<R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> R + Send + Sync + Clone + 'static,
{
    use tokio::sync::mpsc;
    
    let (tx, mut rx) = mpsc::channel(branches.len());
    
    // 按优先级启动分支
    for (priority, branch) in branches {
        let input_clone = input.clone();
        let tx_clone = tx.clone();
        
        task::spawn(async move {
            let result = branch(input_clone);
            let _ = tx_clone.send(PrioritizedTask {
                priority,
                timestamp: Instant::now(),
                data: result,
            }).await;
        });
    }
    
    // 接收结果
    drop(tx);
    
    let mut results = Vec::new();
    while let Some(task) = rx.recv().await {
        results.push(task.data);
    }
    
    results
}
```

### 6.3 里程碑模式

**定义**：使用里程碑标记工作流中的重要点，允许不同分支在达到里程碑时同步。

**Petri网表示**：

- 使用特殊库所表示里程碑
- 多个变迁可以向里程碑库所添加标记

```rust
pub struct Milestone<T, R> {
    name: String,
    milestones: Arc<Mutex<HashSet<String>>>,
    preconditions: HashMap<String, Box<dyn Fn(&T) -> bool + Send + Sync>>,
    postconditions: HashMap<String, Box<dyn Fn(&T) -> bool + Send + Sync>>,
    task: Box<dyn Fn(T) -> R + Send + Sync>,
}

impl<T, R> Milestone<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new<S, F>(name: S, task: F) -> Self
    where
        S: Into<String>,
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        Self {
            name: name.into(),
            milestones: Arc::new(Mutex::new(HashSet::new())),
            preconditions: HashMap::new(),
            postconditions: HashMap::new(),
            task: Box::new(task),
        }
    }
    
    pub fn add_precondition<S, F>(&mut self, milestone: S, condition: F) -> &mut Self
    where
        S: Into<String>,
        F: Fn(&T) -> bool + Send + Sync + 'static,
    {
        self.preconditions.insert(milestone.into(), Box::new(condition));
        self
    }
    
    pub fn add_postcondition<S, F>(&mut self, milestone: S, condition: F) -> &mut Self
    where
        S: Into<String>,
        F: Fn(&T) -> bool + Send + Sync + 'static,
    {
        self.postconditions.insert(milestone.into(), Box::new(condition));
        self
    }
    
    pub async fn execute(&self, input: T) -> Option<R> {
        // 检查前置条件
        for (milestone, condition) in &self.preconditions {
            // 如果里程碑不在已完成列表中，且条件为真，则无法执行
            if !self.milestones.lock().unwrap().contains(milestone) && condition(&input) {
                return None;
            }
        }
        
        // 执行任务
        let result = (self.task)(input.clone());
        
        // 检查后置条件并更新里程碑
        for (milestone, condition) in &self.postconditions {
            if condition(&input) {
                self.milestones.lock().unwrap().insert(milestone.clone());
            }
        }
        
        Some(result)
    }
}

pub struct MilestoneWorkflow<T, R> {
    tasks: Vec<Arc<Milestone<T, R>>>,
    milestones: Arc<Mutex<HashSet<String>>>,
}

impl<T, R> MilestoneWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            tasks: Vec::new(),
            milestones: Arc::new(Mutex::new(HashSet::new())),
        }
    }
    
    pub fn add_task(&mut self, task: Milestone<T, R>) -> &mut Self {
        let milestone_task = Arc::new(task);
        milestone_task.milestones = self.milestones.clone();
        self.tasks.push(milestone_task);
        self
    }
    
    pub async fn execute(&self, input: T) -> Vec<R> {
        let mut results = Vec::new();
        
        for task in &self.tasks {
            if let Some(result) = task.execute(input.clone()).await {
                results.push(result);
            }
        }
        
        results
    }
}
```

**开源实现**：使用Tokio的通知机制：

```rust
use tokio::sync::{Notify, Mutex};
use std::sync::Arc;
use std::collections::HashMap;

struct MilestoneTracker {
    milestones: Mutex<HashMap<String, bool>>,
    notifications: HashMap<String, Arc<Notify>>,
}

impl MilestoneTracker {
    fn new() -> Self {
        Self {
            milestones: Mutex::new(HashMap::new()),
            notifications: HashMap::new(),
        }
    }
    
    fn register_milestone(&mut self, name: &str) {
        let name = name.to_string();
        self.milestones.blocking_lock().insert(name.clone(), false);
        self.notifications.insert(name, Arc::new(Notify::new()));
    }
    
    async fn wait_for_milestone(&self, name: &str) {
        let name = name.to_string();
        
        // 检查里程碑是否已完成
        {
            let milestones = self.milestones.lock().await;
            if let Some(true) = milestones.get(&name) {
                return;
            }
        }
        
        // 等待里程碑达成
        if let Some(notify) = self.notifications.get(&name) {
            notify.notified().await;
        }
    }
    
    async fn achieve_milestone(&self, name: &str) {
        let name = name.to_string();
        
        // 标记里程碑为已完成
        {
            let mut milestones = self.milestones.lock().await;
            milestones.insert(name.clone(), true);
        }
        
        // 通知等待者
        if let Some(notify) = self.notifications.get(&name) {
            notify.notify_waiters();
        }
    }
}

async fn milestone_workflow<T, R, F>(
    input: T,
    tasks: Vec<(Vec<String>, Vec<String>, F)>,
) -> Vec<R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> R + Send + Sync + Clone + 'static,
{
    let tracker = Arc::new(MilestoneTracker::new());
    let mut handles = Vec::new();
    
    // 为每个任务创建处理线程
    for (required_milestones, achieved_milestones, task) in tasks {
        let input_clone = input.clone();
        let tracker_clone = tracker.clone();
        
        let handle = tokio::spawn(async move {
            // 等待所有必要的里程碑
            for milestone in required_milestones {
                tracker_clone.wait_for_milestone(&milestone).await;
            }
            
            // 执行任务
            let result = task(input_clone);
            
            // 达成里程碑
            for milestone in achieved_milestones {
                tracker_clone.achieve_milestone(&milestone).await;
            }
            
            result
        });
        
        handles.push(handle);
    }
    
    // 等待所有任务完成
    futures::future::join_all(handles)
        .await
        .into_iter()
        .filter_map(|r| r.ok())
        .collect()
}
```

## 7. 取消和触发模式

### 7.1 取消活动模式

**定义**：允许一个活动在工作流的另一部分指示时被取消。

**Petri网表示**：

- 使用特殊类型的抑制弧连接到变迁
- 当抑制库所有标记时，变迁无法触发

```rust
pub struct CancellableTask<T, R> {
    task: Box<dyn Fn(T) -> R + Send + Sync>,
    cancel_flag: Arc<AtomicBool>,
    on_cancel: Option<Box<dyn Fn() + Send + Sync>>,
}

impl<T, R> CancellableTask<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F>(task: F) -> Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            cancel_flag: Arc::new(AtomicBool::new(false)),
            on_cancel: None,
        }
    }
    
    pub fn with_cancel_handler<H>(&mut self, handler: H) -> &mut Self
    where
        H: Fn() + Send + Sync + 'static,
    {
        self.on_cancel = Some(Box::new(handler));
        self
    }
    
    pub fn cancel(&self) {
        self.cancel_flag.store(true, std::sync::atomic::Ordering::SeqCst);
        
        if let Some(handler) = &self.on_cancel {
            handler();
        }
    }
    
    pub fn is_cancelled(&self) -> bool {
        self.cancel_flag.load(std::sync::atomic::Ordering::SeqCst)
    }
    
    pub fn reset(&self) {
        self.cancel_flag.store(false, std::sync::atomic::Ordering::SeqCst);
    }
    
    pub async fn execute(&self, input: T) -> Option<R> {
        if self.is_cancelled() {
            return None;
        }
        
        Some((self.task)(input))
    }
    
    pub async fn execute_async<F, Fut>(&self, input: T, async_task: F) -> Option<R>
    where
        F: FnOnce(T) -> Fut,
        Fut: Future<Output = R>,
    {
        if self.is_cancelled() {
            return None;
        }
        
        let cancel_flag = self.cancel_flag.clone();
        
        // 创建一个任务和取消检查
        let task_handle = tokio::spawn(async_task(input));
        
        // 检查取消标志
        let cancel_check = tokio::spawn(async move {
            while !cancel_flag.load(std::sync::atomic::Ordering::SeqCst) {
                tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
            }
        });
        
        // 等待任务完成或被取消
        tokio::select! {
            result = task_handle => {
                if let Ok(r) = result {
                    Some(r)
                } else {
                    None
                }
            }
            _ = cancel_check => {
                // 任务被取消
                None
            }
        }
    }
}
```

**开源实现**：使用Tokio的取消机制：

```rust
use tokio::task::JoinHandle;
use tokio::sync::oneshot;
use std::future::Future;
use std::pin::Pin;

pub struct CancellableActivity<T, R> {
    cancel_tx: Option<oneshot::Sender<()>>,
    handle: Option<JoinHandle<Option<R>>>,
    _phantom: std::marker::PhantomData<T>,
}

impl<T, R> CancellableActivity<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            cancel_tx: None,
            handle: None,
            _phantom: std::marker::PhantomData,
        }
    }
    
    pub fn start<F, Fut>(&mut self, task: F, input: T) -> &mut Self
    where
        F: FnOnce(T, oneshot::Receiver<()>) -> Fut + Send + 'static,
        Fut: Future<Output = Option<R>> + Send + 'static,
    {
        if self.handle.is_some() {
            // 如果已有任务在运行，先取消
            self.cancel();
        }
        
        let (cancel_tx, cancel_rx) = oneshot::channel();
        self.cancel_tx = Some(cancel_tx);
        
        let handle = tokio::spawn(task(input, cancel_rx));
        self.handle = Some(handle);
        
        self
    }
    
    pub fn cancel(&mut self) {
        if let Some(tx) = self.cancel_tx.take() {
            let _ = tx.send(());
        }
    }
    
    pub async fn result(&mut self) -> Option<R> {
        if let Some(handle) = self.handle.take() {
            match handle.await {
                Ok(result) => result,
                Err(_) => None,
            }
        } else {
            None
        }
    }
}

// 使用示例
async fn cancellable_task<T, R>(
    input: T,
    task: impl Fn(T) -> R + Send + 'static,
    cancel_after: tokio::time::Duration,
) -> Option<R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    let mut activity = CancellableActivity::new();
    
    activity.start(|input, mut cancel_rx| async move {
        tokio::select! {
            _ = cancel_rx.changed() => {
                println!("Task was cancelled");
                None
            }
            _ = async {
                let result = task(input);
                result
            } => {
                Some(result)
            }
        }
    }, input);
    
    // 设置一个定时器以取消任务
    tokio::spawn({
        let mut activity_clone = activity.clone();
        async move {
            tokio::time::sleep(cancel_after).await;
            activity_clone.cancel();
        }
    });
    
    activity.result().await
}
```

### 7.2 取消案例模式

**定义**：允许整个工作流实例被取消，同时进行相应的清理操作。

**Petri网表示**：

- 使用一个特殊的取消库所，当有标记时触发取消流程
- 取消库所连接到所有需要被取消的活动的抑制弧

```rust
pub struct CancellableWorkflow<T, R> {
    tasks: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
    compensation_tasks: Vec<Box<dyn Fn() + Send + Sync>>,
    cancel_flag: Arc<AtomicBool>,
}

impl<T, R> CancellableWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            tasks: Vec::new(),
            compensation_tasks: Vec::new(),
            cancel_flag: Arc::new(AtomicBool::new(false)),
        }
    }
    
    pub fn add_task<F>(&mut self, task: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.tasks.push(Box::new(task));
        self
    }
    
    pub fn add_compensation<F>(&mut self, task: F) -> &mut Self
    where
        F: Fn() + Send + Sync + 'static,
    {
        self.compensation_tasks.push(Box::new(task));
        self
    }
    
    pub fn cancel(&self) {
        self.cancel_flag.store(true, std::sync::atomic::Ordering::SeqCst);
    }
    
    pub async fn execute(&self, input: T) -> Vec<R> {
        let mut results = Vec::new();
        
        for (i, task) in self.tasks.iter().enumerate() {
            // 检查取消标志
            if self.cancel_flag.load(std::sync::atomic::Ordering::SeqCst) {
                // 执行补偿操作，从最后添加的开始逆序执行
                for comp_task in self.compensation_tasks.iter().rev() {
                    comp_task();
                }
                
                break;
            }
            
            // 执行任务
            let result = task(input.clone());
            results.push(result);
        }
        
        results
    }
}
```

**开源实现**：使用Tokio的取消和补偿机制：

```rust
use tokio::sync::broadcast;
use tokio::task::JoinSet;
use std::sync::Arc;

pub struct WorkflowCancellation {
    cancel_tx: broadcast::Sender<()>,
}

impl WorkflowCancellation {
    pub fn new() -> Self {
        let (cancel_tx, _) = broadcast::channel(1);
        Self { cancel_tx }
    }
    
    pub fn cancel(&self) {
        let _ = self.cancel_tx.send(());
    }
    
    pub fn subscribe(&self) -> broadcast::Receiver<()> {
        self.cancel_tx.subscribe()
    }
}

async fn cancellable_workflow<T, R, F, C>(
    tasks: Vec<F>,
    compensations: Vec<C>,
    input: T,
) -> Result<Vec<R>, String>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> R + Send + Sync + Clone + 'static,
    C: Fn() + Send + Sync + Clone + 'static,
{
    let cancellation = Arc::new(WorkflowCancellation::new());
    let mut results = Vec::new();
    let mut completed_indices = Vec::new();
    
    for (i, task) in tasks.iter().enumerate() {
        // 检查取消
        let mut cancel_rx = cancellation.subscribe();
        tokio::select! {
            _ = cancel_rx.recv() => {
                // 被取消，执行补偿
                for idx in completed_indices.iter().rev() {
                    if let Some(comp) = compensations.get(*idx) {
                        comp();
                    }
                }
                return Err("Workflow cancelled".to_string());
            }
            _ = async {} => {
                // 执行任务
                let task_clone = task.clone();
                let input_clone = input.clone();
                let result = task_clone(input_clone);
                results.push(result);
                completed_indices.push(i);
            }
        }
    }
    
    Ok(results)
}
```

```text
<think>
我需要继续介绍工作流模式及其Rust实现，包括瞬时触发模式和持久触发模式等剩余内容。
</think>
```

### 7.3 瞬时触发模式

**定义**：某个事件或条件的瞬时发生触发工作流中的活动。

**Petri网表示**：

- 使用特殊类型的弧，只有当事件发生时才传递标记
- 事件库所产生标记，立即触发连接的变迁

```rust
use std::sync::mpsc::{channel, Sender, Receiver};
use std::collections::HashMap;
use std::thread;
use std::time::Duration;

pub struct TransientTrigger<E, T, R> {
    event_handlers: HashMap<E, Vec<Box<dyn Fn(T) -> R + Send + Sync>>>,
    event_receiver: Option<Receiver<(E, T)>>,
    event_sender: Option<Sender<(E, T)>>,
}

impl<E, T, R> TransientTrigger<E, T, R>
where
    E: Eq + std::hash::Hash + Clone + Send + 'static,
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        let (tx, rx) = channel();
        
        Self {
            event_handlers: HashMap::new(),
            event_receiver: Some(rx),
            event_sender: Some(tx),
        }
    }
    
    pub fn register_handler<F>(&mut self, event: E, handler: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.event_handlers
            .entry(event)
            .or_insert_with(Vec::new)
            .push(Box::new(handler));
        
        self
    }
    
    pub fn get_sender(&self) -> Option<Sender<(E, T)>> {
        self.event_sender.clone()
    }
    
    pub fn trigger(&self, event: E, data: T) -> Result<(), String> {
        if let Some(sender) = &self.event_sender {
            sender.send((event, data)).map_err(|e| e.to_string())
        } else {
            Err("No event sender available".to_string())
        }
    }
    
    pub fn start_processing(&mut self) -> Result<thread::JoinHandle<()>, String> {
        let receiver = self.event_receiver.take()
            .ok_or_else(|| "Event receiver already taken".to_string())?;
        
        let handlers = self.event_handlers.clone();
        
        let handle = thread::spawn(move || {
            while let Ok((event, data)) = receiver.recv() {
                if let Some(event_handlers) = handlers.get(&event) {
                    for handler in event_handlers {
                        let _ = handler(data.clone());
                    }
                }
            }
        });
        
        Ok(handle)
    }
}
```

**开源实现**：使用Tokio的通道和事件驱动模式：

```rust
use tokio::sync::mpsc;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::task;

async fn transient_trigger_workflow<E, T, R, F>(
    handlers: HashMap<E, F>,
) -> mpsc::Sender<(E, T)>
where
    E: Eq + std::hash::Hash + Clone + Send + 'static,
    T: Clone + Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> R + Send + Sync + Clone + 'static,
{
    let (tx, mut rx) = mpsc::channel::<(E, T)>(100);
    
    // 启动事件处理循环
    task::spawn(async move {
        while let Some((event, data)) = rx.recv().await {
            if let Some(handler) = handlers.get(&event) {
                let handler_clone = handler.clone();
                let data_clone = data.clone();
                
                // 处理事件
                task::spawn(async move {
                    handler_clone(data_clone);
                });
            }
        }
    });
    
    tx
}

// 使用EventStore框架
use event_store::{Client, EventData, ExpectedVersion, ReadStreamOptions};

async fn event_store_trigger_workflow<T, R, F>(
    event_store: Client,
    stream_name: &str,
    handler: F,
) -> Result<(), Box<dyn std::error::Error>>
where
    T: serde::de::DeserializeOwned + Clone + Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> R + Send + Sync + Clone + 'static,
{
    let handler = Arc::new(handler);
    
    // 订阅事件流
    let mut subscription = event_store.subscribe_to_stream(stream_name).await?;
    
    while let Some(event) = subscription.next().await {
        let event = event?;
        
        // 反序列化事件数据
        if let Ok(data) = event.event.as_json::<T>() {
            let handler_clone = handler.clone();
            
            // 处理事件
            tokio::spawn(async move {
                handler_clone(data);
            });
        }
    }
    
    Ok(())
}
```

### 7.4 持久触发模式

**定义**：某个条件持续满足时，触发工作流中的活动执行。

**Petri网表示**：

- 使用持久库所表示持续条件
- 只要库所中有标记，连接的变迁就能够触发

```rust
pub struct PersistentTrigger<C, T, R> {
    conditions: HashMap<C, Box<dyn Fn(&T) -> bool + Send + Sync>>,
    actions: HashMap<C, Box<dyn Fn(T) -> R + Send + Sync>>,
    polling_interval: Duration,
}

impl<C, T, R> PersistentTrigger<C, T, R>
where
    C: Eq + std::hash::Hash + Clone + Send + 'static,
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new(polling_interval: Duration) -> Self {
        Self {
            conditions: HashMap::new(),
            actions: HashMap::new(),
            polling_interval,
        }
    }
    
    pub fn register_condition_action<F, A>(&mut self, condition_id: C, condition: F, action: A) -> &mut Self
    where
        F: Fn(&T) -> bool + Send + Sync + 'static,
        A: Fn(T) -> R + Send + Sync + 'static,
    {
        self.conditions.insert(condition_id.clone(), Box::new(condition));
        self.actions.insert(condition_id, Box::new(action));
        self
    }
    
    pub async fn start_monitoring(&self, context: T) {
        let conditions = self.conditions.clone();
        let actions = self.actions.clone();
        let interval = self.polling_interval;
        let context = context.clone();
        
        tokio::spawn(async move {
            let mut interval_timer = tokio::time::interval(interval);
            
            loop {
                interval_timer.tick().await;
                
                for (condition_id, condition) in &conditions {
                    if condition(&context) {
                        if let Some(action) = actions.get(condition_id) {
                            let context_clone = context.clone();
                            
                            tokio::spawn(async move {
                                action(context_clone);
                            });
                        }
                    }
                }
            }
        });
    }
}
```

**开源实现**：使用Tokio的定时器和响应式编程：

```rust
use tokio::time::{self, Duration};
use futures::Stream;
use futures::stream::{self, StreamExt};
use std::pin::Pin;

type ConditionStream<T> = Pin<Box<dyn Stream<Item = T> + Send>>;

async fn persistent_trigger_workflow<T, R, F, C>(
    condition_stream: ConditionStream<T>,
    condition: C,
    action: F,
) -> impl Stream<Item = R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> R + Send + Sync + Clone + 'static,
    C: Fn(&T) -> bool + Send + Sync + Clone + 'static,
{
    condition_stream
        .filter(move |item| {
            let condition = condition.clone();
            async move { condition(item) }
        })
        .map(move |item| {
            let action = action.clone();
            action(item)
        })
}

// 使用reactor-rs库
use reactor_rs::{Reactor, Event};

fn reactor_persistent_trigger<T, R, F>(
    reactor: &mut Reactor<T>,
    condition: impl Fn(&T) -> bool + 'static,
    action: F,
) 
where
    T: Clone + 'static,
    F: Fn(T) -> R + 'static,
{
    reactor.add_handler(move |event: &Event<T>| {
        if condition(&event.data) {
            action(event.data.clone());
        }
    });
}
```

## 8. 数据基础模式

### 8.1 结构化判别模式

**定义**：基于数据结构的内容和形式来做出判别。

**Petri网表示**：

- 使用带有复杂条件的变迁
- 条件基于数据的结构属性

```rust
pub struct StructuredDiscriminator<T, R> {
    discriminators: Vec<Box<dyn Fn(&T) -> bool + Send + Sync>>,
    actions: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> StructuredDiscriminator<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            discriminators: Vec::new(),
            actions: Vec::new(),
        }
    }
    
    pub fn add_discriminator<F, A>(&mut self, discriminator: F, action: A) -> &mut Self
    where
        F: Fn(&T) -> bool + Send + Sync + 'static,
        A: Fn(T) -> R + Send + Sync + 'static,
    {
        self.discriminators.push(Box::new(discriminator));
        self.actions.push(Box::new(action));
        self
    }
    
    pub fn process(&self, input: T) -> Option<R> {
        for (i, discriminator) in self.discriminators.iter().enumerate() {
            if discriminator(&input) {
                if let Some(action) = self.actions.get(i) {
                    return Some(action(input.clone()));
                }
            }
        }
        
        None
    }
}

// Rust类型系统的结构化判别
pub struct TypeBasedDiscriminator<R> {
    type_handlers: HashMap<TypeId, Box<dyn Fn(Box<dyn Any>) -> R + Send + Sync>>,
}

impl<R> TypeBasedDiscriminator<R>
where
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            type_handlers: HashMap::new(),
        }
    }
    
    pub fn register<T, F>(&mut self, handler: F) -> &mut Self
    where
        T: 'static + Send,
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        let type_id = TypeId::of::<T>();
        
        let boxed_handler = Box::new(move |any_box: Box<dyn Any>| {
            if let Ok(value) = any_box.downcast::<T>() {
                handler(*value)
            } else {
                panic!("Type mismatch in discriminator");
            }
        });
        
        self.type_handlers.insert(type_id, boxed_handler);
        self
    }
    
    pub fn process<T: 'static + Send>(&self, input: T) -> Option<R> {
        let type_id = TypeId::of::<T>();
        
        if let Some(handler) = self.type_handlers.get(&type_id) {
            Some(handler(Box::new(input)))
        } else {
            None
        }
    }
}
```

**开源实现**：使用Rust的模式匹配和trait系统：

```rust
// 使用trait实现结构化判别
trait MessageHandler<R> {
    fn can_handle(&self, message: &dyn Any) -> bool;
    fn handle(&self, message: Box<dyn Any>) -> R;
}

struct HandlerRegistry<R> {
    handlers: Vec<Box<dyn MessageHandler<R> + Send + Sync>>,
}

impl<R> HandlerRegistry<R> {
    fn new() -> Self {
        Self { handlers: Vec::new() }
    }
    
    fn register<H>(&mut self, handler: H) -> &mut Self
    where
        H: MessageHandler<R> + Send + Sync + 'static,
    {
        self.handlers.push(Box::new(handler));
        self
    }
    
    fn dispatch(&self, message: Box<dyn Any>) -> Option<R> {
        for handler in &self.handlers {
            if handler.can_handle(message.as_ref()) {
                return Some(handler.handle(message));
            }
        }
        None
    }
}

// 使用Rust的模式匹配
enum Message {
    TextMessage(String),
    ImageMessage { url: String, size: usize },
    AudioMessage(Vec<u8>),
}

fn process_message(msg: Message) -> String {
    match msg {
        Message::TextMessage(text) => format!("处理文本: {}", text),
        Message::ImageMessage { url, size } => {
            format!("处理图片: {} ({}字节)", url, size)
        },
        Message::AudioMessage(data) => {
            format!("处理音频: {}字节", data.len())
        }
    }
}
```

### 8.2 通用判别模式

**定义**：基于数据内容的广泛属性进行判别。

**Petri网表示**：

- 使用更通用的条件变迁
- 条件可基于数据的各种属性和关系

```rust
pub struct GenericDiscriminator<T, R> {
    rules: Vec<(String, Box<dyn Fn(&T) -> bool + Send + Sync>, Box<dyn Fn(T) -> R + Send + Sync>)>,
    default_action: Option<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> GenericDiscriminator<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            default_action: None,
        }
    }
    
    pub fn add_rule<F, A>(&mut self, name: &str, condition: F, action: A) -> &mut Self
    where
        F: Fn(&T) -> bool + Send + Sync + 'static,
        A: Fn(T) -> R + Send + Sync + 'static,
    {
        self.rules.push((name.to_string(), Box::new(condition), Box::new(action)));
        self
    }
    
    pub fn set_default<A>(&mut self, action: A) -> &mut Self
    where
        A: Fn(T) -> R + Send + Sync + 'static,
    {
        self.default_action = Some(Box::new(action));
        self
    }
    
    pub fn process(&self, input: T) -> Option<R> {
        for (_, condition, action) in &self.rules {
            if condition(&input) {
                return Some(action(input.clone()));
            }
        }
        
        // 使用默认动作
        self.default_action.as_ref().map(|action| action(input))
    }
    
    pub fn process_with_explanation(&self, input: T) -> Option<(String, R)> {
        for (name, condition, action) in &self.rules {
            if condition(&input) {
                return Some((name.clone(), action(input.clone())));
            }
        }
        
        // 使用默认动作
        self.default_action.as_ref().map(|action| 
            ("default".to_string(), action(input))
        )
    }
}
```

**开源实现**：使用规则引擎和函数式编程：

```rust
// 使用规则引擎库
use rules_engine::{Rule, RuleEngine, Context};

fn generic_discrimination_with_rules<T, R>(
    input: T,
    rules: Vec<Rule>,
    actions: HashMap<String, Box<dyn Fn(T) -> R + Send + Sync>>,
) -> Option<R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    let mut context = Context::new();
    context.insert("input", input.clone());
    
    let engine = RuleEngine::new(rules);
    let results = engine.execute(&context);
    
    for result in results {
        if result.is_success() {
            if let Some(action) = actions.get(&result.rule_name) {
                return Some(action(input.clone()));
            }
        }
    }
    
    None
}

// 函数式实现
fn compose_discriminators<T, R>(
    discriminators: Vec<Box<dyn Fn(&T) -> bool + Send + Sync>>,
    actions: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
) -> impl Fn(T) -> Option<R> + Send + Sync
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    move |input: T| {
        for (i, discriminator) in discriminators.iter().enumerate() {
            if discriminator(&input) {
                if let Some(action) = actions.get(i) {
                    return Some(action(input.clone()));
                }
            }
        }
        None
    }
}
```

### 8.3 环路数据传递模式

**定义**：允许数据在循环执行的工作流中传递并累积。

**Petri网表示**：

- 使用特殊类型的库所保存循环中传递的数据
- 循环变迁更新数据并将其传回

```rust
pub struct DataLoop<T, A> {
    initial_state: T,
    iteration: Box<dyn Fn(T, A) -> (T, bool) + Send + Sync>,
    max_iterations: Option<usize>,
}

impl<T, A> DataLoop<T, A>
where
    T: Clone + Send + 'static,
    A: Send + 'static,
{
    pub fn new<F>(initial_state: T, iteration: F) -> Self
    where
        F: Fn(T, A) -> (T, bool) + Send + Sync + 'static,
    {
        Self {
            initial_state,
            iteration: Box::new(iteration),
            max_iterations: None,
        }
    }
    
    pub fn with_max_iterations(mut self, max: usize) -> Self {
        self.max_iterations = Some(max);
        self
    }
    
    pub fn execute(&self, action_data: A) -> T
    where
        A: Clone,
    {
        let mut current_state = self.initial_state.clone();
        let mut iterations = 0;
        let mut should_continue = true;
        
        while should_continue {
            let (new_state, continue_loop) = (self.iteration)(current_state, action_data.clone());
            current_state = new_state;
            should_continue = continue_loop;
            
            iterations += 1;
            if let Some(max) = self.max_iterations {
                if iterations >= max {
                    break;
                }
            }
        }
        
        current_state
    }
    
    pub async fn execute_async<F, Fut>(&self, action_data: A, async_iteration: F) -> T
    where
        A: Clone,
        F: Fn(T, A) -> Fut + Send + Sync,
        Fut: Future<Output = (T, bool)>,
    {
        let mut current_state = self.initial_state.clone();
        let mut iterations = 0;
        let mut should_continue = true;
        
        while should_continue {
            let (new_state, continue_loop) = async_iteration(current_state, action_data.clone()).await;
            current_state = new_state;
            should_continue = continue_loop;
            
            iterations += 1;
            if let Some(max) = self.max_iterations {
                if iterations >= max {
                    break;
                }
            }
        }
        
        current_state
    }
}
```

**开源实现**：使用迭代器模式：

```rust
use futures::stream::{self, Stream, StreamExt};
use std::pin::Pin;

type AsyncIterator<T> = Pin<Box<dyn Stream<Item = T>>>;

// 使用迭代器实现数据循环
fn data_loop_iterator<T, F>(
    initial: T,
    iteration_function: F,
    max_iterations: Option<usize>,
) -> impl Iterator<Item = T>
where
    T: Clone,
    F: Fn(T) -> Option<T>,
{
    std::iter::successors(Some(initial), move |state| {
        iteration_function(state.clone())
    })
    .take(max_iterations.unwrap_or(std::usize::MAX))
}

// 使用异步迭代器
async fn data_loop_async<T, F, Fut>(
    initial: T,
    iteration_function: F,
    max_iterations: Option<usize>,
) -> AsyncIterator<T>
where
    T: Clone + Send + 'static,
    F: Fn(T) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = Option<T>> + Send + 'static,
{
    let stream = stream::once(async move { initial })
        .chain(stream::unfold(
            (initial, 0usize), 
            move |(state, iteration)| {
                let iteration_fn = iteration_function.clone();
                async move {
                    if let Some(max) = max_iterations {
                        if iteration >= max {
                            return None;
                        }
                    }
                    
                    if let Some(next_state) = iteration_fn(state).await {
                        Some((next_state.clone(), (next_state, iteration + 1)))
                    } else {
                        None
                    }
                }
            }
        ));
    
    Box::pin(stream)
}
```

## 9. 综合示例：基于Rust泛型的工作流系统

最后，我们展示一个综合多种工作流模式的完整示例。
这个示例使用Rust的泛型和特征系统构建一个灵活的工作流引擎：

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use std::future::Future;
use std::pin::Pin;
use std::any::Any;
use tokio::sync::mpsc;
use tokio::task;
use async_trait::async_trait;

// 核心工作流特征
#[async_trait]
pub trait Workflow<C: WorkflowContext> {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError>;
}

// 工作流上下文特征
pub trait WorkflowContext: Send + Sync {
    fn get<T: 'static>(&self, key: &str) -> Option<&T>;
    fn set<T: 'static + Send + Sync>(&mut self, key: &str, value: T);
}

// 基本上下文实现
pub struct SimpleContext {
    data: HashMap<String, Box<dyn Any + Send + Sync>>,
}

impl SimpleContext {
    pub fn new() -> Self {
        Self { data: HashMap::new() }
    }
}

impl WorkflowContext for SimpleContext {
    fn get<T: 'static>(&self, key: &str) -> Option<&T> {
        self.data.get(key)
            .and_then(|boxed| boxed.downcast_ref::<T>())
    }
    
    fn set<T: 'static + Send + Sync>(&mut self, key: &str, value: T) {
        self.data.insert(key.to_string(), Box::new(value));
    }
}

// 错误类型
#[derive(Debug)]
pub enum WorkflowError {
    TaskFailed(String),
    InvalidState(String),
    Cancelled,
    Timeout,
}

// 任务特征
#[async_trait]
pub trait Task<C: WorkflowContext>: Send + Sync {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError>;
}

// 序列工作流
pub struct SequenceWorkflow<C: WorkflowContext> {
    tasks: Vec<Box<dyn Task<C>>>,
}

impl<C: WorkflowContext> SequenceWorkflow<C> {
    pub fn new() -> Self {
        Self { tasks: Vec::new() }
    }
    
    pub fn add_task<T: Task<C> + 'static>(&mut self, task: T) -> &mut Self {
        self.tasks.push(Box::new(task));
        self
    }
}

#[async_trait]
impl<C: WorkflowContext> Workflow<C> for SequenceWorkflow<C> {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError> {
        for task in &self.tasks {
            task.execute(context).await?;
        }
        Ok(())
    }
}

// 并行工作流
pub struct ParallelWorkflow<C: WorkflowContext + Clone + 'static> {
    tasks: Vec<Box<dyn Task<C>>>,
}

impl<C: WorkflowContext + Clone + 'static> ParallelWorkflow<C> {
    pub fn new() -> Self {
        Self { tasks: Vec::new() }
    }
    
    pub fn add_task<T: Task<C> + 'static>(&mut self, task: T) -> &mut Self {
        self.tasks.push(Box::new(task));
        self
    }
}

#[async_trait]
impl<C: WorkflowContext + Clone + 'static> Workflow<C> for ParallelWorkflow<C> {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError> {
        let mut handles = Vec::new();
        
        for task in &self.tasks {
            let task_clone = task.clone();
            let mut ctx_clone = context.clone();
            
            let handle = task::spawn(async move {
                task_clone.execute(&mut ctx_clone).await
            });
            
            handles.push(handle);
        }
        
        for handle in handles {
            handle.await??;
        }
        
        Ok(())
    }
}

// 条件工作流
pub struct ConditionalWorkflow<C: WorkflowContext> {
    condition: Box<dyn Fn(&C) -> bool + Send + Sync>,
    if_branch: Box<dyn Workflow<C>>,
    else_branch: Option<Box<dyn Workflow<C>>>,
}

impl<C: WorkflowContext> ConditionalWorkflow<C> {
    pub fn new<F>(condition: F, if_workflow: impl Workflow<C> + 'static) -> Self
    where
        F: Fn(&C) -> bool + Send + Sync + 'static,
    {
        Self {
            condition: Box::new(condition),
            if_branch: Box::new(if_workflow),
            else_branch: None,
        }
    }
    
    pub fn with_else_branch(mut self, else_workflow: impl Workflow<C> + 'static) -> Self {
        self.else_branch = Some(Box::new(else_workflow));
        self
    }
}

#[async_trait]
impl<C: WorkflowContext> Workflow<C> for ConditionalWorkflow<C> {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError> {
        if (self.condition)(context) {
            self.if_branch.execute(context).await
        } else if let Some(else_branch) = &self.else_branch {
            else_branch.execute(context).await
        } else {
            Ok(())
        }
    }
}

// 循环工作流
pub struct WhileWorkflow<C: WorkflowContext> {
    condition: Box<dyn Fn(&C) -> bool + Send + Sync>,
    body: Box<dyn Workflow<C>>,
    max_iterations: Option<usize>,
}

impl<C: WorkflowContext> WhileWorkflow<C> {
    pub fn new<F>(condition: F, body: impl Workflow<C> + 'static) -> Self
    where
        F: Fn(&C) -> bool + Send + Sync + 'static,
    {
        Self {
            condition: Box::new(condition),
            body: Box::new(body),
            max_iterations: None,
        }
    }
    
    pub fn with_max_iterations(mut self, max: usize) -> Self {
        self.max_iterations = Some(max);
        self
    }
}

#[async_trait]
impl<C: WorkflowContext> Workflow<C> for WhileWorkflow<C> {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError> {
        let mut iterations = 0;
        
        while (self.condition)(context) {
            self.body.execute(context).await?;
            
            iterations += 1;
            if let Some(max) = self.max_iterations {
                if iterations >= max {
                    break;
                }
            }
        }
        
        Ok(())
    }
}

// 可取消工作流
pub struct CancellableWorkflow<C: WorkflowContext> {
    inner: Box<dyn Workflow<C>>,
    cancel_flag: Arc<Mutex<bool>>,
    compensations: Vec<Box<dyn Task<C>>>,
}

impl<C: WorkflowContext> CancellableWorkflow<C> {
    pub fn new(workflow: impl Workflow<C> + 'static) -> Self {
        Self {
            inner: Box::new(workflow),
            cancel_flag: Arc::new(Mutex::new(false)),
            compensations: Vec::new(),
        }
    }
    
    pub fn add_compensation<T: Task<C> + 'static>(&mut self, task: T) -> &mut Self {
        self.compensations.push(Box::new(task));
        self
    }
    
    pub fn cancel(&self) {
        let mut flag = self.cancel_flag.lock().unwrap();
        *flag = true;
    }
}

#[async_trait]
impl<C: WorkflowContext> Workflow<C> for CancellableWorkflow<C> {
    async fn execute(&self, context: &mut C) -> Result<(), WorkflowError> {
        // 检查是否已取消
        let cancelled = {
            let flag = self.cancel_flag.lock().unwrap();
            *flag
        };
        
        if cancelled {
            return Err(WorkflowError::Cancelled);
        }
        
        // 尝试执行工作流
        let result = self.inner.execute(context).await;
        
        // 如果执行失败或被取消，执行补偿操作
        if result.is_err() {
            for comp in self.compensations.iter().rev() {
                let _ = comp.execute(context).await;
            }
        }
        
        result
    }
}

// 工作流引擎
pub struct WorkflowEngine<C: WorkflowContext> {
    workflows: HashMap<String, Box<dyn Workflow<C>>>,
}

impl<C: WorkflowContext> WorkflowEngine<C> {
    pub fn new() -> Self {
        Self { workflows: HashMap::new() }
    }
    
    pub fn register_workflow<W: Workflow<C> + 'static>(
        &mut self,
        name: &str,
        workflow: W,
    ) -> &mut Self {
        self.workflows.insert(name.to_string(), Box::new(workflow));
        self
    }
    
    pub async fn execute_workflow(
        &self,
        name: &str,
        context: &mut C,
    ) -> Result<(), WorkflowError> {
        if let Some(workflow) = self.workflows.get(name) {
            workflow.execute(context).await
        } else {
            Err(WorkflowError::InvalidState(format!("Workflow not found: {}", name)))
        }
    }
}

// 示例使用
#[derive(Clone)]
struct OrderProcessTask;

#[async_trait]
impl Task<SimpleContext> for OrderProcessTask {
    async fn execute(&self, context: &mut SimpleContext) -> Result<(), WorkflowError> {
        let order_id = context.get::<String>("order_id").ok_or_else(|| {
            WorkflowError::InvalidState("Missing order_id".to_string())
        })?;
        
        println!("Processing order: {}", order_id);
        
        // 模拟处理
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        
        context.set("order_status", "processed".to_string());
        Ok(())
    }
}

#[derive(Clone)]
struct PaymentTask;

#[async_trait]
impl Task<SimpleContext> for PaymentTask {
    async fn execute(&self, context: &mut SimpleContext) -> Result<(), WorkflowError> {
        let order_id = context.get::<String>("order_id").ok_or_else(|| {
            WorkflowError::InvalidState("Missing order_id".to_string())
        })?;
        
        let amount = context.get::<f64>("amount").ok_or_else(|| {
            WorkflowError::InvalidState("Missing amount".to_string())
        })?;
        
        println!("Processing payment of ${} for order: {}", amount, order_id);
        
        // 模拟支付处理
        tokio::time::sleep(tokio::time::Duration::from_millis(150)).await;
        
        // 有时失败
        if *amount > 1000.0 {
            return Err(WorkflowError::TaskFailed("Payment too large".to_string()));
        }
        
        context.set("payment_status", "completed".to_string());
        Ok(())
    }
}

// 使用上述工作流引擎构建一个订单处理系统
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut engine = WorkflowEngine::<SimpleContext>::new();
    
    // 创建订单处理工作流
    let mut order_workflow = SequenceWorkflow::new();
    order_workflow
        .add_task(OrderProcessTask)
        .add_task(PaymentTask);
    
    // 注册工作流
    engine.register_workflow("order_processing", order_workflow);
    
    // 执行工作流
    let mut context = SimpleContext::new();
    context.set("order_id", "ORD-12345".to_string());
    context.set("amount", 99.99);
    
    match engine.execute_workflow("order_processing", &mut context).await {
        Ok(_) => {
            println!("Order workflow completed successfully");
            println!("Order status: {}", context.get::<String>("order_status").unwrap());
            println!("Payment status: {}", context.get::<String>("payment_status").unwrap());
        },
        Err(e) => {
            println!("Order workflow failed: {:?}", e);
        }
    }
    
    Ok(())
}
```

## 10. 结论

在本文中，我们深入探讨了如何利用Rust的泛型机制来实现丰富多样的工作流设计模式。Petri网形式化建模与工作流模式的结合，为我们提供了一种严谨而灵活的方法来设计和实现复杂的工作流系统。

Rust的类型系统和零成本抽象特性，使得我们能够构建既安全又高效的工作流引擎，主要优势包括：

1. **类型安全**：Rust的强类型系统确保在编译时捕获许多错误，减少运行时错误。
2. **并发控制**：通过所有权和借用规则，Rust提供了安全的并发模型，适用于复杂工作流。
3. **性能优化**：零成本抽象使得高层次的工作流模式可以编译成高效的机器代码。
4. **资源管理**：Rust的RAII模式确保资源在工作流中被正确管理和释放。
5. **可扩展性**：特征系统支持开放式设计
6. **可扩展性**：特征系统支持开放式设计，允许用户轻松扩展现有工作流系统。
7. **异步支持**：Rust的async/await语法和Tokio等异步运行时，为工作流提供了天然的异步处理能力。

```text
<think>
继续完成最后的结论部分，并可能添加一些关于未来工作和开源实现的详细信息。
</think>
```

通过本文的系统性分析，我们不仅展示了工作流的23种设计模式在Rust中的实现，还强调了这些模式如何在现代分布式系统中解决实际问题。
这些模式的组合使用，可以构建出从简单的线性流程到复杂的事件驱动系统的各种工作流应用。

## 11. 开源生态系统集成

现有的Rust生态系统提供了多个可用于构建工作流系统的优秀框架：

### 11.1 Tokio

Tokio是Rust中最流行的异步运行时，为工作流系统提供了坚实的基础：

```rust
use tokio::sync::{mpsc, oneshot};
use tokio::time::{self, Duration};

struct WorkflowManager {
    task_tx: mpsc::Sender<TaskMessage>,
}

enum TaskMessage {
    Execute { task_id: String, params: TaskParams, response_tx: oneshot::Sender<TaskResult> },
    Cancel { task_id: String },
}

impl WorkflowManager {
    pub fn new() -> Self {
        let (task_tx, mut task_rx) = mpsc::channel(100);
        
        // 启动任务处理器
        tokio::spawn(async move {
            while let Some(msg) = task_rx.recv().await {
                match msg {
                    TaskMessage::Execute { task_id, params, response_tx } => {
                        // 处理任务...
                        let result = execute_task(task_id, params).await;
                        let _ = response_tx.send(result);
                    },
                    TaskMessage::Cancel { task_id } => {
                        // 取消任务...
                    }
                }
            }
        });
        
        Self { task_tx }
    }
    
    pub async fn execute_task(&self, task_id: String, params: TaskParams) -> TaskResult {
        let (response_tx, response_rx) = oneshot::channel();
        
        self.task_tx.send(TaskMessage::Execute {
            task_id,
            params,
            response_tx,
        }).await.expect("任务管理器已关闭");
        
        response_rx.await.expect("任务执行器已关闭")
    }
}
```

### 11.2 actix

actix是一个基于Actor模型的框架，非常适合实现复杂的工作流系统：

```rust
use actix::prelude::*;

// 工作流Actor
struct WorkflowActor {
    state: WorkflowState,
    tasks: Vec<Box<dyn Task>>,
    current_task: usize,
}

// 消息定义
#[derive(Message)]
#[rtype(result = "()")]
struct ExecuteWorkflow;

#[derive(Message)]
#[rtype(result = "TaskResult")]
struct ExecuteTask {
    id: usize,
    params: TaskParams,
}

impl Actor for WorkflowActor {
    type Context = Context<Self>;
}

impl Handler<ExecuteWorkflow> for WorkflowActor {
    type Result = ();
    
    fn handle(&mut self, _msg: ExecuteWorkflow, ctx: &mut Self::Context) -> Self::Result {
        if self.current_task < self.tasks.len() {
            let task = &self.tasks[self.current_task];
            ctx.address().do_send(ExecuteTask {
                id: self.current_task,
                params: self.state.get_params_for_task(self.current_task),
            });
        }
    }
}

impl Handler<ExecuteTask> for WorkflowActor {
    type Result = TaskResult;
    
    fn handle(&mut self, msg: ExecuteTask, ctx: &mut Self::Context) -> Self::Result {
        let result = self.tasks[msg.id].execute(msg.params);
        
        self.state.update_with_result(msg.id, &result);
        self.current_task += 1;
        
        if self.current_task < self.tasks.len() {
            ctx.address().do_send(ExecuteWorkflow);
        }
        
        result
    }
}
```

### 11.3 async-graphql

对于需要提供GraphQL API的工作流系统，async-graphql是一个强大的选择：

```rust
use async_graphql::{Context, Object, Schema, EmptySubscription, SimpleObject, ID};

#[derive(SimpleObject)]
struct Workflow {
    id: ID,
    name: String,
    status: WorkflowStatus,
    tasks: Vec<Task>,
}

#[derive(SimpleObject)]
struct Task {
    id: ID,
    name: String,
    status: TaskStatus,
}

struct Query;

#[Object]
impl Query {
    async fn workflow(&self, ctx: &Context<'_>, id: ID) -> Workflow {
        // 获取工作流信息
    }
    
    async fn workflows(&self, ctx: &Context<'_>) -> Vec<Workflow> {
        // 获取所有工作流
    }
}

struct Mutation;

#[Object]
impl Mutation {
    async fn start_workflow(&self, ctx: &Context<'_>, name: String, params: String) -> Workflow {
        // 启动工作流
    }
    
    async fn cancel_workflow(&self, ctx: &Context<'_>, id: ID) -> bool {
        // 取消工作流
    }
}

type WorkflowSchema = Schema<Query, Mutation, EmptySubscription>;
```

### 11.4 tide-async

对于RESTful API，tide-async提供了简洁的接口：

```rust
use tide::{Request, Response, Server};
use async_std::task;

#[derive(serde::Deserialize)]
struct WorkflowRequest {
    name: String,
    params: serde_json::Value,
}

async fn start_workflow(mut req: Request<WorkflowState>) -> tide::Result {
    let workflow_req: WorkflowRequest = req.body_json().await?;
    let state = req.state();
    
    let workflow_id = state.workflow_engine.start_workflow(
        &workflow_req.name,
        workflow_req.params,
    ).await?;
    
    let response = Response::builder(200)
        .body(json!({ "id": workflow_id }))
        .build();
    
    Ok(response)
}

async fn get_workflow_status(req: Request<WorkflowState>) -> tide::Result {
    let workflow_id = req.param("id")?;
    let state = req.state();
    
    let status = state.workflow_engine.get_workflow_status(workflow_id).await?;
    
    let response = Response::builder(200)
        .body(json!(status))
        .build();
    
    Ok(response)
}

#[async_std::main]
async fn main() -> tide::Result<()> {
    let workflow_engine = WorkflowEngine::new();
    let state = WorkflowState { workflow_engine };
    
    let mut app = tide::with_state(state);
    app.at("/workflows").post(start_workflow);
    app.at("/workflows/:id").get(get_workflow_status);
    
    app.listen("127.0.0.1:8080").await?;
    Ok(())
}
```

## 12. 未来工作方向

Rust生态系统中的工作流引擎还有许多发展机会：

1. **形式化验证**：利用Rust的类型系统开发更先进的工作流验证工具，在编译时检测死锁和活锁。

2. **DSL开发**：创建专门用于工作流定义的领域特定语言，可以编译成Rust代码。

3. **分布式工作流**：扩展现有模式以更好地支持跨多个节点的分布式工作流执行。

4. **智能调度**：集成机器学习算法优化工作流调度和资源分配。

5. **区块链集成**：将工作流与区块链技术结合，实现可审计和不可变的工作流执行。

## 13. 总结

Rust的泛型机制为工作流系统设计提供了强大而灵活的基础。
通过结合Petri网的形式化建模能力和工作流设计模式，开发者可以构建既安全又高效的工作流系统。

本文展示的23种工作流模式及其Rust实现，为设计复杂业务流程提供了可靠的模板。
这些模式不仅涵盖了基本的控制流，
还包括高级分支/合并、多实例处理、状态基础和数据基础等场景，几乎覆盖了现代工作流系统需要解决的所有核心问题。

随着Rust在企业和关键系统中的采用不断增加，
基于Rust的工作流引擎将在未来发挥越来越重要的作用，特别是在需要高可靠性、高性能和形式化正确性保证的领域。
