# Rustè¯­è¨€è¯­æ³•è¯­ä¹‰ç‰¹æ€§å…¨é¢è§£æ

```text
<think>
æˆ‘éœ€è¦é’ˆå¯¹å‰9ç« çš„å†…å®¹æä¾›æ›´åŠ è¯¦ç»†çš„åˆ†æå’Œè§£é‡Šï¼ŒåŒ…æ‹¬å®Œæ•´çš„ç›®å½•ç»“æ„å’Œè¯¦ç»†çš„å†…å®¹è¾“å‡ºã€‚
æˆ‘ä¸éœ€è¦ç®€æ´ï¼Œè€Œæ˜¯è¦å°½å¯èƒ½è¯¦ç»†åœ°åˆ†æå’Œé˜è¿°Rustçš„è¯­æ³•ã€è¯­ä¹‰å’Œç‰¹æ€§ã€‚
è®©æˆ‘ç»§ç»­å‰9ç« çš„å†…å®¹ï¼Œæä¾›æ·±å…¥åˆ†æã€‚
</think>
```

## ç›®å½•

- [Rustè¯­è¨€è¯­æ³•è¯­ä¹‰ç‰¹æ€§å…¨é¢è§£æ](#rustè¯­è¨€è¯­æ³•è¯­ä¹‰ç‰¹æ€§å…¨é¢è§£æ)
  - [ç›®å½•](#ç›®å½•)
  - [1. åŸºç¡€è¯­æ³•ä¸è¡¨è¾¾å¼](#1-åŸºç¡€è¯­æ³•ä¸è¡¨è¾¾å¼)
    - [1.1 å˜é‡ç»‘å®šä¸å£°æ˜](#11-å˜é‡ç»‘å®šä¸å£°æ˜)
    - [1.2 åŸºæœ¬æ•°æ®ç±»å‹](#12-åŸºæœ¬æ•°æ®ç±»å‹)
    - [1.3 å¤åˆæ•°æ®ç±»å‹](#13-å¤åˆæ•°æ®ç±»å‹)
    - [1.4 å‡½æ•°ä¸é—­åŒ…](#14-å‡½æ•°ä¸é—­åŒ…)
    - [1.5 æ§åˆ¶æµç»“æ„](#15-æ§åˆ¶æµç»“æ„)
  - [2. ç±»å‹ç³»ç»Ÿä¸æŠ½è±¡](#2-ç±»å‹ç³»ç»Ÿä¸æŠ½è±¡)
    - [2.1 è‡ªå®šä¹‰æ•°æ®ç±»å‹](#21-è‡ªå®šä¹‰æ•°æ®ç±»å‹)
    - [2.2 æ³›å‹ä¸å¤šæ€](#22-æ³›å‹ä¸å¤šæ€)
    - [2.3 ç‰¹å¾ç³»ç»Ÿ](#23-ç‰¹å¾ç³»ç»Ÿ)
    - [2.4 ç±»å‹è½¬æ¢](#24-ç±»å‹è½¬æ¢)
    - [2.5 é«˜çº§ç±»å‹ç³»ç»Ÿç‰¹æ€§](#25-é«˜çº§ç±»å‹ç³»ç»Ÿç‰¹æ€§)
  - [3. æ‰€æœ‰æƒç³»ç»Ÿä¸å†…å­˜ç®¡ç†](#3-æ‰€æœ‰æƒç³»ç»Ÿä¸å†…å­˜ç®¡ç†)
    - [3.1 æ‰€æœ‰æƒåŸºæœ¬åŸåˆ™](#31-æ‰€æœ‰æƒåŸºæœ¬åŸåˆ™)
    - [3.2 å€Ÿç”¨ç³»ç»Ÿ](#32-å€Ÿç”¨ç³»ç»Ÿ)
    - [3.3 ç”Ÿå‘½å‘¨æœŸ](#33-ç”Ÿå‘½å‘¨æœŸ)
    - [3.4 å†…å­˜ç®¡ç†æ¨¡å¼](#34-å†…å­˜ç®¡ç†æ¨¡å¼)
  - [4. é”™è¯¯å¤„ç†](#4-é”™è¯¯å¤„ç†)
    - [4.1 é”™è¯¯å¤„ç†ç­–ç•¥](#41-é”™è¯¯å¤„ç†ç­–ç•¥)
    - [4.2 é«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼](#42-é«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼)
  - [5. æ¨¡å—ä¸åŒ…ç®¡ç†](#5-æ¨¡å—ä¸åŒ…ç®¡ç†)
    - [5.1 æ¨¡å—ç³»ç»Ÿ](#51-æ¨¡å—ç³»ç»Ÿ)
    - [5.2 åŒ…ä¸Crateç³»ç»Ÿ](#52-åŒ…ä¸crateç³»ç»Ÿ)
  - [6. å¹¶å‘](#6-å¹¶å‘)
    - [6.1 çº¿ç¨‹ä¸å¹¶å‘åŸºç¡€](#61-çº¿ç¨‹ä¸å¹¶å‘åŸºç¡€)
    - [6.2 Rayonå¹¶è¡Œè¿­ä»£å™¨](#62-rayonå¹¶è¡Œè¿­ä»£å™¨)
    - [6.3 å¼‚æ­¥ç¼–ç¨‹](#63-å¼‚æ­¥ç¼–ç¨‹)
    - [6.4 å¹¶å‘è®¾è®¡æ¨¡å¼](#64-å¹¶å‘è®¾è®¡æ¨¡å¼)
  - [7. å…ƒç¼–ç¨‹](#7-å…ƒç¼–ç¨‹)
    - [7.1 å®ç³»ç»Ÿ](#71-å®ç³»ç»Ÿ)
    - [7.2 ç¼–è¯‘æ—¶åå°„](#72-ç¼–è¯‘æ—¶åå°„)
    - [7.3 æ„å»ºæ—¶é…ç½®](#73-æ„å»ºæ—¶é…ç½®)
  - [8. é«˜çº§ç‰¹æ€§](#8-é«˜çº§ç‰¹æ€§)
    - [8.1 unsafe Rust](#81-unsafe-rust)
    - [8.2 é«˜çº§ç‰¹å¾](#82-é«˜çº§ç‰¹å¾)
    - [8.3 é«˜çº§ç±»å‹ç³»ç»Ÿç‰¹æ€§](#83-é«˜çº§ç±»å‹ç³»ç»Ÿç‰¹æ€§)
    - [8.4 FFIä¸å¤–éƒ¨ä»£ç é›†æˆ](#84-ffiä¸å¤–éƒ¨ä»£ç é›†æˆ)
      - [8.4.1 Cè¯­è¨€äº’æ“ä½œ](#841-cè¯­è¨€äº’æ“ä½œ)
      - [8.4.2 å†…å­˜ç®¡ç†ä¸ç±»å‹è½¬æ¢](#842-å†…å­˜ç®¡ç†ä¸ç±»å‹è½¬æ¢)
  - [9. è¯­è¨€å“²å­¦ä¸è®¾è®¡åŸåˆ™](#9-è¯­è¨€å“²å­¦ä¸è®¾è®¡åŸåˆ™)
    - [9.1 Rustçš„è®¾è®¡å“²å­¦](#91-rustçš„è®¾è®¡å“²å­¦)
    - [9.2 ç±»å‹å®‰å…¨ä¸è¡¨è¾¾èƒ½åŠ›](#92-ç±»å‹å®‰å…¨ä¸è¡¨è¾¾èƒ½åŠ›)
    - [9.3 ç”Ÿæ€ç³»ç»Ÿä¸ç¤¾åŒº](#93-ç”Ÿæ€ç³»ç»Ÿä¸ç¤¾åŒº)
    - [9.4 æ€»ç»“](#94-æ€»ç»“)

## 1. åŸºç¡€è¯­æ³•ä¸è¡¨è¾¾å¼

### 1.1 å˜é‡ç»‘å®šä¸å£°æ˜

#### 1.1.1 letç»‘å®šä¸å¯å˜æ€§ï¼ˆmutï¼‰

Rustçš„å˜é‡ç»‘å®šæ˜¯å…¶ç‹¬ç‰¹è®¾è®¡ä¹‹ä¸€ï¼Œä¸å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€æœ‰æœ¬è´¨åŒºåˆ«ã€‚
åœ¨Rustä¸­ï¼Œ"å˜é‡ç»‘å®š"ä¸ä»…ä»…æ˜¯ä¸ºå€¼åˆ†é…å†…å­˜ä½ç½®ï¼Œæ›´æ˜¯å»ºç«‹å€¼ä¸åç§°ä¹‹é—´çš„æ‰€æœ‰æƒå…³ç³»ã€‚

```rust
let x = 5; // ä¸å¯å˜ç»‘å®š
```

è¿™æ¡è¯­å¥ä¸ä»…å°†æ•°å€¼5ç»‘å®šåˆ°å˜é‡xï¼Œè¿˜å»ºç«‹äº†ä¸€ä¸ªä¸å¯å˜çš„æ‰€æœ‰æƒå…³ç³»ã€‚
é»˜è®¤æƒ…å†µä¸‹ï¼ŒRustä¸­çš„æ‰€æœ‰å˜é‡ç»‘å®šéƒ½æ˜¯ä¸å¯å˜çš„ï¼Œ
è¿™åæ˜ äº†Rustçš„"é»˜è®¤å®‰å…¨"è®¾è®¡å“²å­¦â€”â€”é™¤éæ˜ç¡®æŒ‡å‡ºï¼Œå¦åˆ™å˜é‡ä¸åº”è¯¥è¢«ä¿®æ”¹ã€‚

è‹¥è¦åˆ›å»ºå¯å˜ç»‘å®šï¼Œéœ€æ˜¾å¼ä½¿ç”¨`mut`å…³é”®å­—ï¼š

```rust
let mut y = 5; // å¯å˜ç»‘å®š
y = 6;         // åˆæ³•ï¼šå¯ä»¥ä¿®æ”¹å¯å˜å˜é‡
```

è¿™ç§è®¾è®¡æœ‰å¤šé‡æ„ä¹‰ï¼š

1. **å®‰å…¨æ€§**ï¼šé»˜è®¤ä¸å¯å˜å‡å°‘äº†çŠ¶æ€è¢«æ„å¤–ä¿®æ”¹çš„å¯èƒ½æ€§
2. **å¹¶å‘å®‰å…¨**ï¼šä¸å¯å˜æ•°æ®å¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´å…±äº«
3. **ä»£ç ç†è§£**ï¼šæ˜ç¡®æ ‡è®°å“ªäº›å˜é‡å¯ä»¥å˜åŒ–ï¼Œä½¿ä»£ç æ„å›¾æ›´æ¸…æ™°
4. **ç¼–è¯‘å™¨ä¼˜åŒ–**ï¼šçŸ¥é“å“ªäº›å˜é‡ä¸ä¼šå˜åŒ–ï¼Œç¼–è¯‘å™¨å¯ä»¥è¿›è¡Œæ›´å¤šä¼˜åŒ–

å˜é‡ç»‘å®šä¹Ÿå¼•å…¥äº†ä½œç”¨åŸŸæ¦‚å¿µâ€”â€”å˜é‡ä»å£°æ˜ç‚¹å¼€å§‹æœ‰æ•ˆï¼Œç›´åˆ°åŒ…å«å®ƒçš„å—ç»“æŸï¼š

```rust
{
    let temp = 10;
    // tempåœ¨è¿™é‡Œå¯ç”¨
} 
// tempåœ¨è¿™é‡Œä¸å¯ç”¨ï¼Œå·²ç»"ç¦»å¼€ä½œç”¨åŸŸ"å¹¶è¢«"ä¸¢å¼ƒ"
```

å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œ
Rustè‡ªåŠ¨è°ƒç”¨`drop`å‡½æ•°é‡Šæ”¾èµ„æºï¼Œè¿™æ˜¯Rustå®ç°RAIIï¼ˆèµ„æºè·å–å³åˆå§‹åŒ–ï¼‰çš„æ ¸å¿ƒæœºåˆ¶ã€‚

#### 1.1.2 å¸¸é‡ï¼ˆconstï¼‰ä¸é™æ€å˜é‡ï¼ˆstaticï¼‰

Rustæä¾›ä¸¤ç§åœ¨æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸä¸­å­˜åœ¨çš„å€¼ï¼šå¸¸é‡å’Œé™æ€å˜é‡ã€‚

**å¸¸é‡ï¼ˆconstï¼‰**ï¼š

```rust
const MAX_POINTS: u32 = 100_000;
```

å¸¸é‡æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. å¿…é¡»æ³¨æ˜ç±»å‹ï¼ˆå¦‚`u32`ï¼‰
2. å€¼å¿…é¡»æ˜¯ç¼–è¯‘æ—¶å¯è®¡ç®—çš„å¸¸é‡è¡¨è¾¾å¼
3. åœ¨ç¼–è¯‘æ—¶å†…è”åˆ°ä½¿ç”¨å¤„ï¼Œæ²¡æœ‰å›ºå®šå†…å­˜åœ°å€
4. å‘½åæƒ¯ä¾‹ä¸ºå…¨å¤§å†™ä¸‹åˆ’çº¿åˆ†éš”ï¼ˆ`MAX_POINTS`ï¼‰
5. åœ¨ç¼–è¯‘æœŸè¢«æ±‚å€¼ï¼Œä¸èƒ½æ˜¯è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šçš„å€¼ï¼Œå¦‚å‡½æ•°ç»“æœ

**é™æ€å˜é‡ï¼ˆstaticï¼‰**ï¼š

```rust
static LANGUAGE: &str = "Rust";
static mut COUNTER: u32 = 0; // å¯å˜é™æ€å˜é‡ï¼Œä½¿ç”¨éœ€è¦unsafe
```

é™æ€å˜é‡ç‰¹ç‚¹ï¼š

1. æœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œæ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´å­˜åœ¨
2. æ‰€æœ‰å¼•ç”¨é™æ€å˜é‡çš„åœ°æ–¹éƒ½è®¿é—®åŒä¸€å†…å­˜ä½ç½®
3. å¯ä»¥æ˜¯å¯å˜çš„ï¼ˆ`static mut`ï¼‰ï¼Œä½†ä½¿ç”¨æ—¶éœ€è¦`unsafe`å—ï¼Œå› ä¸ºè¿™å¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰
4. å‘½åæƒ¯ä¾‹åŒæ ·æ˜¯å…¨å¤§å†™ä¸‹åˆ’çº¿åˆ†éš”

é™æ€å˜é‡ä¸å¸¸é‡çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼š
é™æ€å˜é‡æœ‰å›ºå®šå†…å­˜åœ°å€ï¼Œå¯ç”¨äºéœ€è¦å¼•ç”¨å­˜æ´»æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸçš„åœºæ™¯ï¼›
è€Œå¸¸é‡åœ¨ç¼–è¯‘æ—¶è¢«å†…è”ï¼Œæ²¡æœ‰å›ºå®šå†…å­˜ä½ç½®ã€‚

å¯å˜é™æ€å˜é‡æ˜¯Rustä¸­å°‘æ•°å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºçš„ç‰¹æ€§ä¹‹ä¸€ï¼š

```rust
static mut COUNTER: u32 = 0;

fn main() {
    unsafe {
        COUNTER += 1; // éœ€è¦unsafeå—
        println!("COUNTER: {}", COUNTER);
    }
}
```

ä½¿ç”¨å¯å˜é™æ€å˜é‡å¿…é¡»å°å¿ƒï¼Œå› ä¸ºï¼š

1. å¤šçº¿ç¨‹è®¿é—®ä¼šå¯¼è‡´æ•°æ®ç«äº‰
2. æ²¡æœ‰é”ä¿æŠ¤çš„å¹¶å‘ä¿®æ”¹å¯èƒ½å¯¼è‡´å†…å­˜ä¸ä¸€è‡´
3. ç¼–è¯‘å™¨å¯èƒ½é‡æ’æŒ‡ä»¤ï¼Œå½±å“è®¿é—®é¡ºåº

å› æ­¤ï¼ŒRustå¼ºåˆ¶è¦æ±‚ä½¿ç”¨`unsafe`å—æ¥è®¿é—®å¯å˜é™æ€å˜é‡ï¼Œæé†’å¼€å‘è€…éœ€è¦è‡ªè¡Œç¡®ä¿å®‰å…¨ã€‚

#### 1.1.3 å˜é‡é®è”½ï¼ˆshadowingï¼‰

Rustå…è®¸åœ¨åŒä¸€ä½œç”¨åŸŸä¸­å¤šæ¬¡ä½¿ç”¨ç›¸åŒçš„å˜é‡åï¼Œæ–°å˜é‡ä¼š"é®è”½"ï¼ˆshadowï¼‰ä¹‹å‰çš„åŒåå˜é‡ï¼š

```rust
fn main() {
    let x = 5;
    let x = x + 1; // åˆ›å»ºæ–°å˜é‡xï¼Œå€¼ä¸º6ï¼Œé®è”½åŸæ¥çš„x
    {
        let x = x * 2; // åœ¨å†…éƒ¨ä½œç”¨åŸŸå†æ¬¡é®è”½ï¼Œå€¼ä¸º12
        println!("Inner scope x: {}", x); // è¾“å‡º12
    }
    println!("Outer scope x: {}", x); // è¾“å‡º6ï¼Œå†…éƒ¨ä½œç”¨åŸŸçš„é®è”½å·²ç»“æŸ
}
```

å˜é‡é®è”½ä¸`mut`å˜é‡æœ‰æ ¹æœ¬åŒºåˆ«ï¼š

1. é®è”½åˆ›å»ºå…¨æ–°å˜é‡ï¼Œåªæ˜¯åç§°ç›¸åŒ
2. æ–°å˜é‡å¯ä»¥æœ‰ä¸åŒçš„ç±»å‹
3. é®è”½ä¸ä¿®æ”¹åŸå˜é‡ï¼Œè€Œæ˜¯åˆ›å»ºæ–°çš„ç»‘å®š

è¿™ä¸€ç‰¹æ€§ç‰¹åˆ«é€‚åˆå˜é‡ç±»å‹æˆ–å¯å˜æ€§éœ€è¦è½¬æ¢çš„åœºæ™¯ï¼š

```rust
let spaces = "   "; // å­—ç¬¦ä¸²ç±»å‹
let spaces = spaces.len(); // æ•°å€¼ç±»å‹ï¼Œé€šè¿‡é®è”½æ”¹å˜ç±»å‹

// è€Œä¸‹é¢çš„ä»£ç æ˜¯ä¸åˆæ³•çš„ï¼š
let mut spaces = "   ";
spaces = spaces.len(); // é”™è¯¯ï¼šä¸èƒ½æ”¹å˜å˜é‡ç±»å‹
```

å˜é‡é®è”½çš„ç”¨ä¾‹ï¼š

1. æ•°æ®è½¬æ¢è¿‡ç¨‹ä¸­ä¿æŒç›¸åŒåç§°
2. ä¸´æ—¶ä¿®æ”¹ä¸å¯å˜å˜é‡è¿›è¡Œè®¡ç®—
3. åœ¨æœ‰é™ä½œç”¨åŸŸå†…é‡ç”¨å˜é‡å

#### 1.1.4 è§£æ„æ¨¡å¼ï¼ˆdestructuringï¼‰

Rustæ”¯æŒå¤æ‚çš„è§£æ„æ¨¡å¼ï¼Œå…è®¸å°†å¤åˆæ•°æ®ç±»å‹åˆ†è§£ä¸ºå„ä¸ªç»„æˆéƒ¨åˆ†ï¼š

```rust
// å…ƒç»„è§£æ„
let tuple = (1, "hello", 3.14);
let (x, y, z) = tuple; // x=1, y="hello", z=3.14

// ç»“æ„ä½“è§£æ„
struct Point { x: i32, y: i32 }
let point = Point { x: 0, y: 1 };
let Point { x, y } = point; // x=0, y=1
// æˆ–è€…è‡ªå®šä¹‰å˜é‡å
let Point { x: a, y: b } = point; // a=0, b=1

// æšä¸¾è§£æ„
enum Message {
    Move { x: i32, y: i32 },
    Write(String),
}
let msg = Message::Move { x: 3, y: 4 };
if let Message::Move { x, y } = msg {
    println!("Moved to ({}, {})", x, y);
}
```

è§£æ„å¯ä»¥ä¸æ¨¡å¼åŒ¹é…ç»“åˆï¼Œæ˜¯Rustå¼ºå¤§è¡¨è¾¾èƒ½åŠ›çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼š

```rust
// å¤æ‚æ¨¡å¼åŒ¹é…è§£æ„
match complex_value {
    (0, x, _) => println!("First is 0, second is {}, third ignored", x),
    (_, 0, _) => println!("Second is 0"),
    (_, _, z) if z > 100 => println!("Third is large: {}", z),
    _ => println!("No special pattern matched"),
}
```

è§£æ„åœ¨å‡½æ•°å‚æ•°ä¸­ä¹Ÿéå¸¸æœ‰ç”¨ï¼š

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}
```

### 1.2 åŸºæœ¬æ•°æ®ç±»å‹

#### 1.2.1 æ•´æ•°ç±»å‹ï¼ˆi8/u8 è‡³ i128/u128, isize/usizeï¼‰

Rustæä¾›ä¸°å¯Œçš„æ•´æ•°ç±»å‹ï¼Œç²¾ç¡®æ§åˆ¶å†…å­˜ä½¿ç”¨å’Œæ•°å€¼èŒƒå›´ï¼š

| ç±»å‹    | èŒƒå›´                                    | å¤§å°    | ç”¨é€”                     |
|-------|---------------------------------------|-------|------------------------|
| i8    | -128 åˆ° 127                            | 1å­—èŠ‚   | å°èŒƒå›´æœ‰ç¬¦å·æ•´æ•°              |
| u8    | 0 åˆ° 255                              | 1å­—èŠ‚   | å°èŒƒå›´æ— ç¬¦å·æ•´æ•°ï¼Œå¸¸ç”¨äºå­—èŠ‚æ“ä½œ     |
| i16   | -32,768 åˆ° 32,767                     | 2å­—èŠ‚   | ä¸­ç­‰èŒƒå›´æœ‰ç¬¦å·æ•´æ•°             |
| u16   | 0 åˆ° 65,535                           | 2å­—èŠ‚   | ä¸­ç­‰èŒƒå›´æ— ç¬¦å·æ•´æ•°             |
| i32   | -2,147,483,648 åˆ° 2,147,483,647       | 4å­—èŠ‚   | é»˜è®¤æ•´æ•°ç±»å‹ï¼Œå¹³è¡¡èŒƒå›´å’Œæ€§èƒ½       |
| u32   | 0 åˆ° 4,294,967,295                    | 4å­—èŠ‚   | ä¸­å¤§èŒƒå›´æ— ç¬¦å·æ•´æ•°             |
| i64   | -9,223,372,036,854,775,808 åˆ° 9,223,372,036,854,775,807 | 8å­—èŠ‚ | å¤§èŒƒå›´æœ‰ç¬¦å·æ•´æ•° |
| u64   | 0 åˆ° 18,446,744,073,709,551,615       | 8å­—èŠ‚   | å¤§èŒƒå›´æ— ç¬¦å·æ•´æ•°              |
| i128  | -170,141,183,460,469,231,731,687,303,715,884,105,728 åˆ° 170,141,183,460,469,231,731,687,303,715,884,105,727 | 16å­—èŠ‚ | è¶…å¤§èŒƒå›´æœ‰ç¬¦å·æ•´æ•° |
| u128  | 0 åˆ° 340,282,366,920,938,463,463,374,607,431,768,211,455 | 16å­—èŠ‚ | è¶…å¤§èŒƒå›´æ— ç¬¦å·æ•´æ•° |
| isize | å–å†³äºå¹³å°ï¼ˆ32ä½ç³»ç»Ÿä¸ºi32ï¼Œ64ä½ç³»ç»Ÿä¸ºi64ï¼‰         | 4æˆ–8å­—èŠ‚ | æŒ‡é’ˆå¤§å°çš„æœ‰ç¬¦å·æ•´æ•°ï¼Œé€‚åˆç´¢å¼•é›†åˆ    |
| usize | å–å†³äºå¹³å°ï¼ˆ32ä½ç³»ç»Ÿä¸ºu32ï¼Œ64ä½ç³»ç»Ÿä¸ºu64ï¼‰         | 4æˆ–8å­—èŠ‚ | æŒ‡é’ˆå¤§å°çš„æ— ç¬¦å·æ•´æ•°ï¼Œç”¨äºè¡¨ç¤ºå¤§å°å’Œç´¢å¼• |

æ•´æ•°å­—é¢é‡å¯ä»¥æœ‰ä¸åŒè¡¨ç¤ºå½¢å¼ï¼š

```rust
let decimal = 98_222;      // åè¿›åˆ¶
let hex = 0xff;            // åå…­è¿›åˆ¶
let octal = 0o77;          // å…«è¿›åˆ¶
let binary = 0b1111_0000;  // äºŒè¿›åˆ¶
let byte = b'A';           // å­—èŠ‚ï¼ˆä»…é™u8ï¼‰
```

ä¸‹åˆ’çº¿å¯ç”¨äºæé«˜å¯è¯»æ€§ï¼š`1_000_000`ç­‰åŒäº`1000000`ã€‚

æ•´æ•°æº¢å‡ºå¤„ç†æ˜¯Rustå®‰å…¨è®¾è®¡çš„ä½“ç°ï¼š

- è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæ•´æ•°æº¢å‡ºä¼šå¯¼è‡´ç¨‹åºpanicï¼Œä¾¿äºåŠæ—©å‘ç°é—®é¢˜
- å‘å¸ƒæ¨¡å¼ä¸‹ï¼Œæº¢å‡ºä¼šå¯¼è‡´"ç¯ç»•"ï¼ˆwrap aroundï¼‰ï¼Œå¦‚`u8`ç±»å‹çš„`255 + 1 = 0`

ä¸ºäº†æ˜¾å¼å¤„ç†æº¢å‡ºï¼Œæ ‡å‡†åº“æä¾›æ–¹æ³•ï¼š

```rust
let (result, overflowed) = 255u8.overflowing_add(1); // result=0, overflowed=true
let wrapped = 255u8.wrapping_add(1);                 // wrapped=0
let saturated = 255u8.saturating_add(1);             // saturated=255
let (result, is_ok) = 255u8.checked_add(1);          // result=None, is_ok=false
```

ç±»å‹é€‰æ‹©è€ƒè™‘å› ç´ ï¼š

1. **èŒƒå›´éœ€æ±‚**ï¼šç¡®ä¿ç±»å‹å¯è¡¨ç¤ºæ‰€æœ‰å¯èƒ½å€¼
2. **æ€§èƒ½**ï¼šè¾ƒå°ç±»å‹å¯èƒ½åœ¨æŸäº›å¹³å°ä¸Šæ›´é«˜æ•ˆ
3. **å†…å­˜ä½¿ç”¨**ï¼šåœ¨å¤§å‹æ•°ç»„ä¸­ä½¿ç”¨è¾ƒå°ç±»å‹å¯æ˜¾è‘—å‡å°‘å†…å­˜å ç”¨
4. **æŒ‡é’ˆå¤§å°ä¸€è‡´æ€§**ï¼š`usize`ç¡®ä¿ä¸å¹³å°æŒ‡é’ˆå¤§å°ä¸€è‡´ï¼Œé€‚åˆç´¢å¼•æ“ä½œ

#### 1.2.2 æµ®ç‚¹ç±»å‹ï¼ˆf32, f64ï¼‰

Rustæä¾›ä¸¤ç§ç¬¦åˆIEEE-754æ ‡å‡†çš„æµ®ç‚¹æ•°ç±»å‹ï¼š

| ç±»å‹  | ç²¾åº¦    | å¤§å°  | ç”¨é€”                |
|-----|-------|-----|-------------------|
| f32 | å•ç²¾åº¦æµ®ç‚¹ | 4å­—èŠ‚ | éœ€è¦è¾ƒå°ç©ºé—´æˆ–è¾ƒä½ç²¾åº¦çš„æµ®ç‚¹è®¡ç®— |
| f64 | åŒç²¾åº¦æµ®ç‚¹ | 8å­—èŠ‚ | é»˜è®¤æµ®ç‚¹ç±»å‹ï¼Œæä¾›æ›´é«˜ç²¾åº¦    |

æµ®ç‚¹æ•°ç¤ºä¾‹ï¼š

```rust
let x = 2.0;        // f64ï¼ˆé»˜è®¤ï¼‰
let y: f32 = 3.0;   // f32ï¼ˆæ˜¾å¼ç±»å‹æ ‡æ³¨ï¼‰
let large = 1.0e10; // ç§‘å­¦è®°æ•°æ³•ï¼š1.0 Ã— 10^10

// æµ®ç‚¹æ•°è¿ç®—
let sum = 5.5 + 3.7;
let difference = 95.6 - 4.3;
let product = 4.0 * 30.0;
let quotient = 56.7 / 32.2;
let remainder = 43.5 % 5.0;
```

æµ®ç‚¹æ•°çš„ç‰¹æ®Šå€¼å’Œæ³¨æ„äº‹é¡¹ï¼š

1. **NaNï¼ˆéæ•°ï¼‰**ï¼šè¡¨ç¤ºæ— æ•ˆæ“ä½œç»“æœï¼Œå¦‚`0.0/0.0`
2. **æ— ç©·**ï¼š`1.0/0.0`äº§ç”Ÿæ­£æ— ç©·ï¼Œ`-1.0/0.0`äº§ç”Ÿè´Ÿæ— ç©·
3. **ç²¾åº¦é™åˆ¶**ï¼šæµ®ç‚¹æ•°æ— æ³•ç²¾ç¡®è¡¨ç¤ºæ‰€æœ‰å°æ•°ï¼Œå¯èƒ½æœ‰èˆå…¥è¯¯å·®
4. **æ¯”è¾ƒé—®é¢˜**ï¼šç”±äºç²¾åº¦é™åˆ¶ï¼Œæµ®ç‚¹æ•°ç›¸ç­‰æ¯”è¾ƒéœ€å°å¿ƒï¼ˆé€šå¸¸ç”¨æ¥è¿‘åº¦æ¯”è¾ƒï¼‰

```rust
let nan = 0.0 / 0.0;
assert!(nan.is_nan());

// æµ®ç‚¹æ•°æ¯”è¾ƒæœ€ä½³å®è·µ
let a = 0.1 + 0.2;
let b = 0.3;
assert!((a - b).abs() < 1e-10); // ä½¿ç”¨è¯¯å·®èŒƒå›´æ¯”è¾ƒ
```

æµ®ç‚¹æ•°é€‰æ‹©ï¼š

- ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæ¨èä½¿ç”¨`f64`ï¼Œç°ä»£CPUå¤„ç†f64å’Œf32é€Ÿåº¦ç›¸è¿‘
- åœ¨å¤§é‡æ•°æ®æˆ–æ€§èƒ½å—é™åœºæ™¯ï¼Œ`f32`å¯èƒ½æ›´åˆé€‚
- ç‰¹å®šé¢†åŸŸå¦‚å›¾å½¢å­¦ï¼Œå¯èƒ½åå‘ä½¿ç”¨`f32`

#### 1.2.3 å¸ƒå°”ç±»å‹ï¼ˆboolï¼‰

Rustçš„å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼š`true`å’Œ`false`ï¼Œå¤§å°ä¸º1å­—èŠ‚ã€‚

```rust
let t = true;
let f: bool = false;

// å¸ƒå°”è¡¨è¾¾å¼
let comparison = 10 > 5;   // true
let logical_and = true && false; // false
let logical_or = true || false;  // true
let logical_not = !true;         // false
```

å¸ƒå°”ç±»å‹æ˜¯æ¡ä»¶è¡¨è¾¾å¼çš„åŸºç¡€ï¼š

```rust
if some_condition {
    // å½“some_conditionä¸ºtrueæ—¶æ‰§è¡Œ
} else {
    // å½“some_conditionä¸ºfalseæ—¶æ‰§è¡Œ
}

// çŸ­è·¯æ±‚å€¼
let result = false && compute_expensive_value(); // compute_expensive_valueä¸ä¼šè¢«è°ƒç”¨
```

Rustä¸æ”¯æŒå°†æ•°å­—éšå¼è½¬æ¢ä¸ºå¸ƒå°”å€¼ï¼Œéœ€æ˜¾å¼æ¯”è¾ƒï¼š

```rust
let num = 5;
if num != 0 {  // æ­£ç¡®ï¼šæ˜¾å¼æ¯”è¾ƒ
    println!("num is not zero");
}

// ä¸‹é¢ä»£ç æ— æ³•ç¼–è¯‘
// if num {  // é”™è¯¯ï¼šRustéœ€è¦å¸ƒå°”è¡¨è¾¾å¼
//     println!("num is not zero");
// }
```

#### 1.2.4 å­—ç¬¦ç±»å‹ï¼ˆcharï¼‰

Rustçš„`char`ç±»å‹è¡¨ç¤ºå•ä¸ªUnicodeæ ‡é‡å€¼ï¼Œä½¿ç”¨å•å¼•å·è¡¨ç¤ºï¼Œå ç”¨4å­—èŠ‚ï¼ˆ32ä½ï¼‰ã€‚

```rust
let c = 'z';
let z: char = 'â„¤'; // Unicodeå­—ç¬¦
let heart_eyed_cat = 'ğŸ˜»'; // emojiä¹Ÿæ˜¯æœ‰æ•ˆçš„char
```

`char`ç±»å‹è¦ç‚¹ï¼š

1. æ”¯æŒå®Œæ•´UnicodeèŒƒå›´ï¼ˆU+0000åˆ°U+D7FFå’ŒU+E000åˆ°U+10FFFFï¼‰
2. æ¯ä¸ªå­—ç¬¦å ç”¨4å­—èŠ‚ï¼Œæ— è®ºæ˜¯ASCIIè¿˜æ˜¯å¤æ‚Unicodeå­—ç¬¦
3. å¯è¡¨ç¤ºå„ç§è¯­è¨€å­—ç¬¦ã€ç¬¦å·å’Œemoji
4. åŒºåˆ«äºå­—ç¬¦ä¸²ï¼Œå­—ç¬¦æ˜¯å•ä¸ªUnicodeæ ‡é‡å€¼

å­—ç¬¦æ“ä½œç¤ºä¾‹ï¼š

```rust
// æ£€æŸ¥å­—ç¬¦å±æ€§
let c = 'A';
assert!(c.is_alphabetic());
assert!(c.is_uppercase());
assert_eq!(c.to_lowercase().to_string(), "a");

// Unicodeè½¬æ¢
let unicode_codepoint = 'â¤' as u32; // å°†å­—ç¬¦è½¬æ¢ä¸ºUnicodeç ç‚¹
let back_to_char = std::char::from_u32(unicode_codepoint).unwrap(); // ä»ç ç‚¹åˆ›å»ºå­—ç¬¦
```

éœ€æ³¨æ„ï¼ŒæŸäº›çœ‹ä¼¼å•ä¸ªå­—ç¬¦çš„ç¬¦å·å¯èƒ½ç”±å¤šä¸ªUnicodeæ ‡é‡å€¼ç»„æˆï¼Œå¦‚ä¸€äº›ç‰¹æ®Šemojiæˆ–å¸¦å˜éŸ³ç¬¦å·çš„å­—ç¬¦ï¼Œè¿™äº›éœ€è¦ç”¨å­—ç¬¦ä¸²è€Œéå•ä¸ª`char`è¡¨ç¤ºã€‚

#### 1.2.5 å•å…ƒç±»å‹ï¼ˆunit type: ()ï¼‰

å•å…ƒç±»å‹ï¼Œå†™ä½œ`()`ï¼Œæ˜¯Rustä¸­çš„ä¸€ä¸ªç‹¬ç‰¹ç±»å‹ï¼Œè¡¨ç¤ºæ²¡æœ‰å€¼ã€‚å®ƒç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„`void`ï¼Œä½†ä½œä¸ºä¸€ä¸ªå®é™…çš„ç±»å‹å­˜åœ¨ã€‚

å•å…ƒç±»å‹ä¸»è¦ç‰¹ç‚¹ï¼š

1. å¤§å°ä¸ºé›¶ï¼ˆZSTï¼Œé›¶å¤§å°ç±»å‹ï¼‰
2. åªæœ‰ä¸€ä¸ªå€¼ï¼Œå³`()`
3. é€šå¸¸è¡¨ç¤ºæ— è¿”å›å€¼çš„å‡½æ•°
4. åœ¨ä¸å…³å¿ƒå€¼çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨

```rust
// å•å…ƒç±»å‹ä½œä¸ºå‡½æ•°è¿”å›å€¼
fn just_do_something() -> () {
    println!("Did something");
    // éšå¼è¿”å›()
}

// ç­‰ä»·å†™æ³•
fn just_do_something2() {
    println!("Did something");
}

// æ˜¾å¼è¿”å›å•å…ƒå€¼
fn just_do_something3() -> () {
    println!("Did something");
    return ();
}

// åœ¨è¡¨è¾¾å¼ä¸­ä½¿ç”¨
let val = if condition {
    do_something();
    () // è¿”å›å•å…ƒå€¼
} else {
    do_something_else();
    () // ä¹Ÿè¿”å›å•å…ƒå€¼
};
// valçš„ç±»å‹æ˜¯()
```

å•å…ƒç±»å‹çš„é‡è¦ç”¨é€”ï¼š

1. **è¡¨è¾¾å¼æ±‚å€¼ä½†ä¸éœ€è¦ç»“æœ**ï¼šå¦‚`let _ = expensive_function();`
2. **æ³›å‹å‚æ•°ä¸­è¡¨ç¤ºæ— å…³è”æ•°æ®**ï¼š`struct NoData<T>(PhantomData<T>);`
3. **æ˜ å°„åˆ°ä¸å…³å¿ƒç»“æœçš„åœºæ™¯**ï¼š`Result<(), Error>`è¡¨ç¤ºæˆåŠŸæ—¶æ— éœ€è¿”å›å€¼
4. **å®ç°ç‰¹å®štraitä½†ä¸å­˜å‚¨æ•°æ®**ï¼š`impl Handler for () { ... }`

### 1.3 å¤åˆæ•°æ®ç±»å‹

#### 1.3.1 å…ƒç»„ï¼ˆtupleï¼‰

å…ƒç»„æ˜¯å›ºå®šé•¿åº¦çš„å¤šç±»å‹å€¼é›†åˆï¼Œä¸€æ—¦å£°æ˜ï¼Œé•¿åº¦ä¸èƒ½æ”¹å˜ã€‚å…ƒç»„æ˜¯Rustä¸­æœ€ç®€å•çš„å¤åˆæ•°æ®ç±»å‹ã€‚

```rust
// å£°æ˜å…ƒç»„
let tup: (i32, f64, u8) = (500, 6.4, 1);

// é€šè¿‡è§£æ„è·å–å…ƒç´ 
let (x, y, z) = tup;
println!("yçš„å€¼æ˜¯: {}", y); // è¾“å‡º "yçš„å€¼æ˜¯: 6.4"

// é€šè¿‡ç´¢å¼•è®¿é—®
let five_hundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;
```

å…ƒç»„çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **å¼‚æ„ç±»å‹**ï¼šå¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„å…ƒç´ 
2. **å›ºå®šé•¿åº¦**ï¼šç¼–è¯‘æ—¶ç¡®å®šï¼Œä¸èƒ½åŠ¨æ€æ”¹å˜
3. **é¡ºåºå›ºå®š**ï¼šå…ƒç´ çš„é¡ºåºæœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºä¸åŒå­—æ®µ
4. **é€šè¿‡ç´¢å¼•æˆ–è§£æ„è®¿é—®**ï¼š`.0`ã€`.1`ç­‰ç´¢å¼•æˆ–è§£æ„æ¨¡å¼
5. **å•å…ƒå…ƒç»„**ï¼šå•ä¸ªå…ƒç´ çš„å…ƒç»„éœ€è¦é€—å·ï¼Œå¦‚`(42,)`

å…ƒç»„çš„å¸¸è§ç”¨é€”ï¼š

1. **è¿”å›å¤šä¸ªå€¼**ï¼šå‡½æ•°å¯ä»¥è¿”å›å…ƒç»„åŒ…å«å¤šä¸ªç»“æœ
2. **ä¸´æ—¶æ•°æ®åˆ†ç»„**ï¼šä¸éœ€å®šä¹‰ç»“æ„ä½“çš„ç®€å•åˆ†ç»„
3. **è§£æ„å¤šä¸ªå€¼**ï¼šé€šè¿‡å•ä¸€èµ‹å€¼è·å¾—å¤šä¸ªå˜é‡
4. **ç±»å‹ç»„åˆ**ï¼šåˆ›å»ºå¤åˆç±»å‹

```rust
// å‡½æ•°è¿”å›å¤šä¸ªå€¼
fn get_stats(data: &[i32]) -> (i32, i32, i32) {
    let sum: i32 = data.iter().sum();
    let min = *data.iter().min().unwrap_or(&0);
    let max = *data.iter().max().unwrap_or(&0);
    (min, max, sum)
}

// ä½¿ç”¨
let data = [1, 5, 10, 2, 8];
let (min, max, sum) = get_stats(&data);
```

ç©ºå…ƒç»„`()`æ˜¯å•å…ƒç±»å‹ï¼Œä¸Šä¸€èŠ‚å·²è¯¦ç»†è®¨è®ºã€‚

#### 1.3.2 æ•°ç»„ï¼ˆarrayï¼‰ä¸åˆ‡ç‰‡ï¼ˆsliceï¼‰

**æ•°ç»„**æ˜¯å›ºå®šé•¿åº¦çš„åŒç±»å‹å…ƒç´ é›†åˆï¼Œåˆ†é…åœ¨æ ˆä¸Šï¼š

```rust
// æ•°ç»„å£°æ˜
let a = [1, 2, 3, 4, 5]; // å…ƒç´ ç±»å‹å’Œé•¿åº¦é€šè¿‡æ¨æ–­ç¡®å®š

// æ˜¾å¼æŒ‡å®šç±»å‹å’Œé•¿åº¦
let a: [i32; 5] = [1, 2, 3, 4, 5];

// åˆå§‹åŒ–ç›¸åŒå€¼çš„æ•°ç»„
let a = [3; 5]; // ç­‰åŒäº [3, 3, 3, 3, 3]

// è®¿é—®å…ƒç´ 
let first = a[0];
let second = a[1];

// éæ³•è®¿é—®ä¼šå¯¼è‡´è¿è¡Œæ—¶panic
// let element = a[10]; // è¿è¡Œæ—¶panic: ç´¢å¼•è¶…å‡ºèŒƒå›´
```

æ•°ç»„çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **å›ºå®šé•¿åº¦**ï¼šç¼–è¯‘æ—¶ç¡®å®šï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
2. **åŒè´¨å…ƒç´ **ï¼šæ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒç±»å‹
3. **é›¶å¼€é”€è¾¹ç•Œæ£€æŸ¥**ï¼šè®¿é—®è¶Šç•Œå¯¼è‡´panicè€Œéæœªå®šä¹‰è¡Œä¸º
4. **ç±»å‹ç­¾å**ï¼š`[T; N]`ï¼Œå…¶ä¸­Tæ˜¯å…ƒç´ ç±»å‹ï¼ŒNæ˜¯é•¿åº¦

**åˆ‡ç‰‡**æ˜¯æ•°ç»„ï¼ˆæˆ–å…¶ä»–è¿ç»­å­˜å‚¨ï¼‰çš„è§†å›¾ï¼Œç”±æŒ‡é’ˆå’Œé•¿åº¦ç»„æˆï¼š

```rust
// åˆ›å»ºåˆ‡ç‰‡
let a = [1, 2, 3, 4, 5];
let slice = &a[1..4]; // åŒ…å«ç´¢å¼•1,2,3çš„åˆ‡ç‰‡

// å®Œæ•´åˆ‡ç‰‡
let whole = &a[..]; // æ•´ä¸ªæ•°ç»„çš„åˆ‡ç‰‡

// éƒ¨åˆ†åˆ‡ç‰‡
let beginning = &a[..3]; // ç´¢å¼•0,1,2
let end = &a[2..];       // ç´¢å¼•2,3,4

// å‡½æ•°æ¥å—åˆ‡ç‰‡å‚æ•°
fn sum(numbers: &[i32]) -> i32 {
    let mut result = 0;
    for &num in numbers {
        result += num;
    }
    result
}
```

åˆ‡ç‰‡çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **è¿è¡Œæ—¶é•¿åº¦**ï¼šé•¿åº¦åœ¨è¿è¡Œæ—¶ç¡®å®šï¼Œå‚¨å­˜åœ¨"èƒ–æŒ‡é’ˆ"ä¸­
2. **å€Ÿç”¨è¯­ä¹‰**ï¼šåˆ‡ç‰‡ä¸æ‹¥æœ‰æ•°æ®ï¼Œåªæ˜¯å€Ÿç”¨
3. **ç±»å‹ç­¾å**ï¼š`&[T]`æˆ–`&mut [T]`
4. **é›¶å¼€é”€æŠ½è±¡**ï¼šä¸å¼•å…¥è¿è¡Œæ—¶å¼€é”€
5. **çµæ´»æ¥å£**ï¼šæ¥å—ä¸åŒé•¿åº¦çš„æ•°ç»„æˆ–åˆ‡ç‰‡ä½œä¸ºå‚æ•°

åˆ‡ç‰‡ä¸æ•°ç»„çš„å…³ç³»æ˜¯Rustç±»å‹ç³»ç»Ÿçš„é‡è¦éƒ¨åˆ†ï¼Œä½“ç°äº†æ‰€æœ‰æƒå€Ÿç”¨ç³»ç»Ÿå’Œé›¶æˆæœ¬æŠ½è±¡çš„è®¾è®¡ç†å¿µã€‚

#### 1.3.3 å­—ç¬¦ä¸²ï¼ˆString ä¸ &strï¼‰

Rustæœ‰ä¸¤ç§ä¸»è¦å­—ç¬¦ä¸²ç±»å‹ï¼š`String`ï¼ˆå¯å¢é•¿ã€å †åˆ†é…ï¼‰å’Œ`&str`ï¼ˆå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œä¸å¯å˜å¼•ç”¨ï¼‰ã€‚

**å­—ç¬¦ä¸²åˆ‡ç‰‡ (&str)**:

```rust
// å­—ç¬¦ä¸²å­—é¢é‡æ˜¯&strç±»å‹
let s = "hello"; // sçš„ç±»å‹æ˜¯&'static str

// åˆ›å»ºå­—ç¬¦ä¸²åˆ‡ç‰‡
let hello = &s[0..5]; // æˆ– &s[..5]
let world = &s[6..11]; // æˆ– &s[6..]
```

**å­—ç¬¦ä¸²(String)**:

```rust
// ä»å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»ºString
let s = String::from("hello");
let s = "hello".to_string();

// ä¿®æ”¹String
let mut s = String::from("hello");
s.push_str(", world"); // æ·»åŠ å­—ç¬¦ä¸²
s.push('!');           // æ·»åŠ å•ä¸ªå­—ç¬¦

// Stringä¸&sträº’ç›¸è½¬æ¢
let s1: String = String::from("hello");
let s2: &str = &s1; // Stringè½¬ä¸º&stré€šè¿‡å¼•ç”¨
let s3: String = s2.to_string(); // &strè½¬ä¸ºStringéœ€è¦åˆ†é…
```

å­—ç¬¦ä¸²çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **UTF-8ç¼–ç **ï¼šRustå­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„UTF-8
2. **éç©ºç»ˆæ­¢**ï¼šä¸åƒCå­—ç¬¦ä¸²ï¼Œä¸ä¾èµ–nullå­—èŠ‚ç»ˆæ­¢
3. **éç´¢å¼•è®¿é—®**ï¼š`s[0]`ä¸åˆæ³•ï¼Œå› ä¸ºUTF-8å­—ç¬¦å¯èƒ½å¤šå­—èŠ‚
4. **åˆ‡ç‰‡è¾¹ç•Œé™åˆ¶**ï¼šåˆ‡ç‰‡å¿…é¡»åœ¨å­—ç¬¦è¾¹ç•Œä¸Š
5. **æ‰€æœ‰æƒåŒºåˆ«**ï¼š`String`æ‹¥æœ‰å†…å®¹ï¼Œ`&str`å€Ÿç”¨å†…å®¹

å­—ç¬¦ä¸²æ“ä½œç¤ºä¾‹ï¼š

```rust
// æ‹¼æ¥
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1è¢«ç§»åŠ¨ï¼Œä¸èƒ½å†ä½¿ç”¨

// ä½¿ç”¨format!å®ï¼ˆä¸ç§»åŠ¨æ‰€æœ‰æƒï¼‰
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = format!("{}{}", s1, s2); // s1å’Œs2ä»å¯ä½¿ç”¨

// å®‰å…¨çš„å­—ç¬¦éå†
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c);
}

// å­—èŠ‚éå†
for b in "hello".bytes() {
    println!("{}", b);
}
```

å­—ç¬¦ä¸²å†…å­˜è¡¨ç¤ºï¼š

- `String`ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šæŒ‡é’ˆï¼ˆå †ä¸Šæ•°æ®ï¼‰ã€é•¿åº¦ï¼ˆå·²ä½¿ç”¨å­—èŠ‚ï¼‰å’Œå®¹é‡ï¼ˆæ€»åˆ†é…å­—èŠ‚ï¼‰
- `&str`ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šæŒ‡é’ˆï¼ˆæ•°æ®ä½ç½®ï¼‰å’Œé•¿åº¦ï¼ˆå­—èŠ‚æ•°ï¼‰

#### 1.3.4 å‘é‡ï¼ˆ`Vec<T>`ï¼‰

å‘é‡`Vec<T>`æ˜¯åŠ¨æ€å¤§å°çš„åŒç±»å‹å…ƒç´ é›†åˆï¼Œå­˜å‚¨åœ¨å †ä¸Šï¼š

```rust
// åˆ›å»ºç©ºå‘é‡
let v: Vec<i32> = Vec::new();

// ä½¿ç”¨å®åˆ›å»ºå¸¦åˆå§‹å€¼çš„å‘é‡
let v = vec![1, 2, 3];

// æ·»åŠ å…ƒç´ 
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);

// è®¿é—®å…ƒç´ 
let third: &i32 = &v[2]; // ç´¢å¼•è®¿é—®ï¼ˆè¶Šç•Œä¼španicï¼‰
match v.get(2) {         // å®‰å…¨è®¿é—®ï¼ˆè¶Šç•Œè¿”å›Noneï¼‰
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}

// éå†ä¿®æ”¹
for i in &mut v {
    *i += 50; // è§£å¼•ç”¨æ‰èƒ½ä¿®æ”¹å€¼
}

// éå†ä¸å¯å˜å¼•ç”¨
for i in &v {
    println!("{}", i);
}

// ä½¿ç”¨æšä¸¾å­˜å‚¨å¤šç§ç±»å‹
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

å‘é‡çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **åŠ¨æ€å¤§å°**ï¼šå¯ä»¥åœ¨è¿è¡Œæ—¶å¢é•¿æˆ–ç¼©å°
2. **åŒè´¨å…ƒç´ **ï¼šæ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒç±»å‹
3. **å †åˆ†é…**ï¼šæ•°æ®å­˜å‚¨åœ¨å †ä¸Š
4. **è‡ªåŠ¨é‡Šæ”¾**ï¼šå½“å‘é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå…¶æ‰€æœ‰å†…å®¹éƒ½è¢«é‡Šæ”¾
5. **å†…å­˜å¢é•¿ç­–ç•¥**ï¼šå®¹é‡ä¸è¶³æ—¶æŒ‰å€æ•°æ‰©å±•ï¼ˆé€šå¸¸æ˜¯2å€ï¼‰

å‘é‡çš„å¸¸è§æ“ä½œï¼š

```rust
// é¢„åˆ†é…ç©ºé—´
let mut v = Vec::with_capacity(10); // é¢„åˆ†é…10ä¸ªå…ƒç´ çš„ç©ºé—´

// ä»è¿­ä»£å™¨åˆ›å»º
let v: Vec<i32> = (0..5).collect(); // [0, 1, 2, 3, 4]

// åˆ é™¤å’Œæ’å…¥
let mut v = vec![1, 2, 3];
v.pop();          // ç§»é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´ 
v.insert(1, 7);   // åœ¨ç´¢å¼•1å¤„æ’å…¥7
let removed = v.remove(0); // ç§»é™¤å¹¶è¿”å›ç´¢å¼•0å¤„çš„å…ƒç´ 

// åˆ‡ç‰‡æ“ä½œ
let slice = &v[1..3]; // å¾—åˆ°å‘é‡çš„åˆ‡ç‰‡
```

å‘é‡æ˜¯Rustä¸­æœ€å¸¸ç”¨çš„é›†åˆç±»å‹ä¹‹ä¸€ï¼Œç»“åˆæ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™ï¼Œæä¾›äº†å†…å­˜å®‰å…¨çš„åŠ¨æ€æ•°ç»„åŠŸèƒ½ã€‚

### 1.4 å‡½æ•°ä¸é—­åŒ…

#### 1.4.1 å‡½æ•°å£°æ˜ä¸è°ƒç”¨

Rustå‡½æ•°ä½¿ç”¨`fn`å…³é”®å­—å£°æ˜ï¼Œå…·æœ‰æ˜ç¡®çš„å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹ï¼š

```rust
// åŸºæœ¬å‡½æ•°å£°æ˜
fn add(x: i32, y: i32) -> i32 {
    x + y // æ— åˆ†å·çš„è¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼
}

// æœ‰å¤šä¸ªè¯­å¥çš„å‡½æ•°
fn complex_function(x: i32) -> i32 {
    let y = x * 2;
    let z = y + 3;
    z // è¿”å›å€¼
}

// æ˜¾å¼return
fn early_return(x: i32) -> i32 {
    if x < 0 {
        return 0; // æå‰è¿”å›
    }
    x * x
}

// è°ƒç”¨å‡½æ•°
let result = add(5, 6);
```

Rustå‡½æ•°çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **æ˜¾å¼ç±»å‹**ï¼šå‚æ•°å’Œè¿”å›å€¼éœ€è¦æ˜¾å¼ç±»å‹æ ‡æ³¨
2. **è¡¨è¾¾å¼è¿”å›**ï¼šæœ€åçš„è¡¨è¾¾å¼ï¼ˆæ— åˆ†å·ï¼‰ä½œä¸ºè¿”å›å€¼
3. **å‘½åè§„èŒƒ**ï¼šä½¿ç”¨è›‡å½¢å‘½åæ³•ï¼ˆsnake_caseï¼‰
4. **æå‰è¿”å›**ï¼šå¯ä½¿ç”¨`return`è¯­å¥æå‰è¿”å›
5. **æ³›å‹å‡½æ•°**ï¼šæ”¯æŒç±»å‹å‚æ•°åŒ–ï¼ˆåç»­ç« èŠ‚è¯¦è¿°ï¼‰

å‡½æ•°æ˜¯Rustä¸­çš„ä¸€ç­‰å…¬æ°‘ï¼Œå¯ä»¥ä½œä¸ºå€¼ä¼ é€’ï¼š

```rust
fn apply_twice(f: fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn square(x: i32) -> i32 {
    x * x
}

let result = apply_twice(square, 2); // ç»“æœï¼š16
```

å‡½æ•°ä¸æ–¹æ³•çš„åŒºåˆ«åœ¨äºæ–¹æ³•æ˜¯ä¸ç‰¹å®šç±»å‹å…³è”çš„å‡½æ•°ï¼š

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•ï¼ˆæ¥æ”¶selfå‚æ•°ï¼‰
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // å…³è”å‡½æ•°ï¼ˆä¸æ¥æ”¶selfï¼‰
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

// è°ƒç”¨æ–¹æ³•
let rect = Rectangle::new(10, 20);
let area = rect.area();

// è°ƒç”¨å…³è”å‡½æ•°
let rect2 = Rectangle::new(30, 40);
```

#### 1.4.2 åŒ¿åå‡½æ•°ä¸é—­åŒ…

é—­åŒ…æ˜¯å¯ä»¥æ•è·ç¯å¢ƒçš„åŒ¿åå‡½æ•°ï¼Œç”¨äºåˆ›å»ºä¸´æ—¶åŠŸèƒ½å—ï¼š

```rust
// åŸºæœ¬é—­åŒ…è¯­æ³•
let add_one = |x| x + 1;
let add_two = |x: i32| -> i32 { x + 2 }; // æ˜¾å¼ç±»å‹æ ‡æ³¨

// è°ƒç”¨é—­åŒ…
let three = add_one(2);
let four = add_two(2);

// æ•è·ç¯å¢ƒå˜é‡
let y = 10;
let add_y = |x| x + y; // é—­åŒ…æ•è·å¤–éƒ¨å˜é‡y
println!("{}", add_y(5)); // è¾“å‡º15
```

é—­åŒ…çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **ç±»å‹æ¨æ–­**ï¼šå‚æ•°å’Œè¿”å›ç±»å‹é€šå¸¸å¯ä»¥çœç•¥
2. **ç¯å¢ƒæ•è·**ï¼šå¯ä»¥ä½¿ç”¨å®šä¹‰ä½œç”¨åŸŸä¸­çš„å˜é‡
3. **çµæ´»è¯­æ³•**ï¼šç®€å•é—­åŒ…å¯ä»¥å†™æˆå•è¡Œè¡¨è¾¾å¼
4. **å¤šç§æ•è·æ¨¡å¼**ï¼šå¯ä»¥é€šè¿‡å¼•ç”¨æˆ–å€¼æ•è·å˜é‡

é—­åŒ…æ•è·æ¨¡å¼ï¼š

```rust
// 1. ä¸å¯å˜å€Ÿç”¨æ•è·ï¼ˆé»˜è®¤ï¼‰
let v = vec![1, 2, 3];
let closure = || println!("Vector: {:?}", v);
closure();
// vä»å¯ä½¿ç”¨

// 2. å¯å˜å€Ÿç”¨æ•è·
let mut v = vec![1, 2, 3];
let mut add_element = || v.push(4);
add_element();
// vä»å¯ä½¿ç”¨ï¼Œç°åœ¨åŒ…å«[1,2,3,4]

// 3. æ‰€æœ‰æƒæ•è·ï¼ˆä½¿ç”¨moveå…³é”®å­—ï¼‰
let v = vec![1, 2, 3];
let take_ownership = move || {
    println!("Taken vector: {:?}", v);
    // è¿™é‡Œå®Œå…¨æ‹¥æœ‰v
};
take_ownership();
// vä¸å†å¯ç”¨ï¼Œæ‰€æœ‰æƒå·²è½¬ç§»åˆ°é—­åŒ…ä¸­
```

é—­åŒ…å®ç°åŸç†ï¼š
Rusté—­åŒ…åœ¨ç¼–è¯‘æ—¶è¢«ç¿»è¯‘æˆå®ç°ç‰¹å®štraitçš„åŒ¿åç»“æ„ä½“ï¼š

1. **FnOnce**ï¼šæ¶ˆè€—æ•è·çš„å˜é‡ï¼Œåªèƒ½è°ƒç”¨ä¸€æ¬¡
2. **FnMut**ï¼šå¯ä»¥ä¿®æ”¹æ•è·çš„å˜é‡ï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨
3. **Fn**ï¼šä¸ä¿®æ”¹æ•è·çš„å˜é‡ï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨

```rust
// æ ¹æ®ä½¿ç”¨æ–¹å¼ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨å®ç°é€‚å½“çš„trait
fn execute_once<F>(f: F) where F: FnOnce() {
    f();
}

fn execute_mut<F>(mut f: F) where F: FnMut() {
    f();
    f();
}

fn execute<F>(f: F) where F: Fn() {
    f();
    f();
}

// ä½¿ç”¨ç¤ºä¾‹
let x = vec![1, 2, 3];

execute(|| println!("å€Ÿç”¨x: {:?}", x)); // å®ç°Fn
execute_mut(|| println!("å€Ÿç”¨x: {:?}", x)); // å®ç°FnMutå’ŒFn
execute_once(|| println!("å€Ÿç”¨x: {:?}", x)); // å®ç°FnOnce, FnMutå’ŒFn

execute_once(move || println!("æ‹¥æœ‰x: {:?}", x)); // åªå®ç°FnOnce
```

é—­åŒ…çš„é«˜çº§ç”¨é€”ï¼š

```rust
// 1. å»¶è¿Ÿè®¡ç®—
let expensive_calculation = |x| {
    println!("è®¡ç®—ä¸­...");
    thread::sleep(Duration::from_secs(2));
    x * x
};
let result = expensive_calculation(5);

// 2. è‡ªå®šä¹‰è¿­ä»£å™¨é€‚é…å™¨
let v = vec![1, 2, 3, 4, 5];
let even_squares: Vec<_> = v.iter()
    .filter(|&x| x % 2 == 0)
    .map(|&x| x * x)
    .collect();

// 3. å‡½æ•°å·¥å‚
fn make_adder(y: i32) -> impl Fn(i32) -> i32 {
    move |x| x + y
}
let add_five = make_adder(5);
println!("{}", add_five(10)); // è¾“å‡º15
```

#### 1.4.3 é«˜é˜¶å‡½æ•°

é«˜é˜¶å‡½æ•°æ˜¯æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°ï¼Œåœ¨Rustä¸­æœ‰å¹¿æ³›åº”ç”¨ï¼š

```rust
// æ¥å—å‡½æ•°æŒ‡é’ˆå‚æ•°
fn apply_to_all(nums: &mut [i32], f: fn(i32) -> i32) {
    for num in nums.iter_mut() {
        *num = f(*num);
    }
}

// é—­åŒ…ä½œä¸ºå‚æ•°ï¼ˆä½¿ç”¨æ³›å‹å’Œtraité™å®šï¼‰
fn transform<F>(nums: &mut [i32], transformer: F)
    where F: Fn(i32) -> i32
{
    for num in nums.iter_mut() {
        *num = transformer(*num);
    }
}

// è¿”å›å‡½æ•°ï¼ˆå‡†ç¡®åœ°è¯´ï¼Œè¿”å›å®ç°Fn traitçš„ç±»å‹ï¼‰
fn make_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
    move |x| x * factor
}

// ä½¿ç”¨ç¤ºä¾‹
fn double(x: i32) -> i32 { x * 2 }

fn main() {
    let mut numbers = [1, 2, 3, 4];
    
    // ä½¿ç”¨å‡½æ•°æŒ‡é’ˆ
    apply_to_all(&mut numbers, double);
    println!("{:?}", numbers); // [2, 4, 6, 8]
    
    // ä½¿ç”¨é—­åŒ…
    let add_ten = |x| x + 10;
    transform(&mut numbers, add_ten);
    println!("{:?}", numbers); // [12, 14, 16, 18]
    
    // ä½¿ç”¨è¿”å›çš„å‡½æ•°
    let triple = make_multiplier(3);
    let result = triple(5); // 15
}
```

é«˜é˜¶å‡½æ•°çš„å…¸å‹åº”ç”¨åœºæ™¯ï¼š

1. **è¿­ä»£å™¨æ“ä½œ**ï¼šmapã€filterã€foldç­‰
2. **å›è°ƒå‡½æ•°**ï¼šäº‹ä»¶å¤„ç†ã€è‡ªå®šä¹‰ç­–ç•¥
3. **å‡½æ•°ç»„åˆ**ï¼šåˆ›å»ºå¤æ‚å‡½æ•°é“¾
4. **APIçµæ´»æ€§**ï¼šå…è®¸ç”¨æˆ·æä¾›è‡ªå®šä¹‰è¡Œä¸º

```rust
// è¿­ä»£å™¨ç»„åˆç¤ºä¾‹
let squares: Vec<_> = (1..10)
    .map(|x| x * x)
    .filter(|&x| x % 2 == 0)
    .collect();

// å‡½æ•°ç»„åˆç¤ºä¾‹
fn compose<F, G, T>(f: F, g: G) -> impl Fn(T) -> T
where
    F: Fn(T) -> T,
    G: Fn(T) -> T,
    T: Copy,
{
    move |x| f(g(x))
}

let add_one = |x| x + 1;
let double = |x| x * 2;
let add_one_then_double = compose(double, add_one);
let double_then_add_one = compose(add_one, double);

println!("{}", add_one_then_double(5)); // (5+1)*2 = 12
println!("{}", double_then_add_one(5)); // 5*2+1 = 11
```

Rustçš„é«˜é˜¶å‡½æ•°èƒ½åŠ›åŒå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç›¸å½“ï¼Œä½†ä¿ç•™äº†ä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥å’Œé›¶æˆæœ¬æŠ½è±¡ã€‚

#### 1.4.4 å‘æ•£å‡½æ•°ï¼ˆnever type: !ï¼‰

å‘æ•£å‡½æ•°æ˜¯æ°¸ä¸è¿”å›çš„å‡½æ•°ï¼Œå…¶è¿”å›ç±»å‹æ˜¯ç‰¹æ®Šçš„neverç±»å‹ï¼ˆ`!`ï¼‰ï¼š

```rust
// å‘æ•£å‡½æ•°ç¤ºä¾‹
fn never_returns() -> ! {
    // æ— é™å¾ªç¯
    loop {
        println!("æ°¸è¿œæ‰§è¡Œ...");
    }
}

// ç»ˆæ­¢ç¨‹åºçš„å‘æ•£å‡½æ•°
fn terminate(error_code: i32) -> ! {
    println!("ç¨‹åºç»ˆæ­¢ï¼Œé”™è¯¯ç : {}", error_code);
    std::process::exit(error_code);
}

// panic!å®ä¹Ÿæ˜¯å‘æ•£å‡½æ•°
fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
    }
    a / b
}
```

neverç±»å‹çš„ç‰¹æ€§ï¼š

1. **åº•ç±»å‹**ï¼šå¯ä»¥è¢«å¼ºåˆ¶è½¬æ¢ä¸ºä»»ä½•å…¶ä»–ç±»å‹
2. **ç±»å‹ç³»ç»Ÿå®Œå¤‡æ€§**ï¼šè¡¨ç¤ºè®¡ç®—ä¸ä¼šäº§ç”Ÿå€¼
3. **ç¼–è¯‘å™¨ä¼˜åŒ–**ï¼šä½¿ç¼–è¯‘å™¨èƒ½æ¨æ–­å‡ºæŸäº›åˆ†æ”¯ä¸å¯è¾¾

neverç±»å‹çš„å®é™…åº”ç”¨ï¼š

```rust
// åœ¨matchè¡¨è¾¾å¼ä¸­ä½¿ç”¨continue/break
let result = loop {
    match get_input() {
        Ok(value) => break value, // è¿”å›value
        Err(_) => continue, // continueçš„ç±»å‹æ˜¯!
    }
};

// ç±»å‹è½¬æ¢ä¸­çš„é”™è¯¯å¤„ç†
let value: Option<i32> = None;
let unwrapped = value.unwrap_or_else(|| -> ! {
    eprintln!("å‘ç”Ÿé”™è¯¯ï¼šå€¼ä¸ºNone");
    std::process::exit(1);
});

// Resultè½¬Optionæ—¶çš„é”™è¯¯å¤„ç†
let file = match File::open("file.txt") {
    Ok(f) => Some(f),
    Err(e) => {
        eprintln!("æ— æ³•æ‰“å¼€æ–‡ä»¶: {}", e);
        return None; // returnçš„ç±»å‹æ˜¯!
    }
};
```

å‘æ•£å‡½æ•°åœ¨é”™è¯¯å¤„ç†å’Œæ§åˆ¶æµè¡¨è¾¾æ–¹é¢éå¸¸æœ‰ç”¨ï¼Œä½¿å¾—Rustçš„ç±»å‹ç³»ç»Ÿæ›´åŠ å®Œå¤‡ã€‚

### 1.5 æ§åˆ¶æµç»“æ„

#### 1.5.1 æ¡ä»¶è¡¨è¾¾å¼ï¼ˆif/elseï¼‰

Rustçš„æ¡ä»¶è¡¨è¾¾å¼æ˜¯è¡¨è¾¾å¼è€Œéè¯­å¥ï¼Œå¯ä»¥è¿”å›å€¼ï¼š

```rust
// åŸºæœ¬if/else
let number = 7;
if number < 5 {
    println!("æ¡ä»¶ä¸ºçœŸ");
} else {
    println!("æ¡ä»¶ä¸ºå‡");
}

// ifä½œä¸ºè¡¨è¾¾å¼
let condition = true;
let number = if condition { 5 } else { 6 };
println!("numberçš„å€¼æ˜¯: {}", number);

// å¤šé‡æ¡ä»¶
let number = 6;
if number % 4 == 0 {
    println!("numberèƒ½è¢«4æ•´é™¤");
} else if number % 3 == 0 {
    println!("numberèƒ½è¢«3æ•´é™¤");
} else if number % 2 == 0 {
    println!("numberèƒ½è¢«2æ•´é™¤");
} else {
    println!("numberä¸èƒ½è¢«4ã€3æˆ–2æ•´é™¤");
}
```

ifè¡¨è¾¾å¼çš„ä¸»è¦ç‰¹æ€§ï¼š

1. **è¡¨è¾¾å¼ç‰¹æ€§**ï¼šå¯ä»¥è¿”å›å€¼ï¼Œç”¨äºå˜é‡åˆå§‹åŒ–
2. **æ— æ‹¬å·æ¡ä»¶**ï¼šæ¡ä»¶è¡¨è¾¾å¼ä¸éœ€è¦æ‹¬å·
3. **å¿…é¡»æ˜¯å¸ƒå°”æ¡ä»¶**ï¼šæ¡ä»¶å¿…é¡»æ˜¯å¸ƒå°”ç±»å‹ï¼ˆä¸åƒC/JSå¯ä»¥ç”¨æ•°å­—ï¼‰
4. **å„åˆ†æ”¯è¿”å›ç±»å‹ä¸€è‡´**ï¼šç”¨äºèµ‹å€¼æ—¶æ‰€æœ‰åˆ†æ”¯å¿…é¡»è¿”å›ç›¸åŒç±»å‹

ifè¡¨è¾¾å¼çš„é«˜çº§ç”¨æ³•ï¼š

```rust
// è¿åŒletä¸€èµ·ä½¿ç”¨
let age = 30;
let status = if age < 18 {
    "æœªæˆå¹´"
} else if age < 65 {
    "æˆå¹´"
} else {
    "è€å¹´"
};

// åœ¨å‡½æ•°è¿”å›ä¸­ä½¿ç”¨
fn check_number(x: i32) -> &'static str {
    if x < 0 {
        "è´Ÿæ•°"
    } else if x > 0 {
        "æ­£æ•°"
    } else {
        "é›¶"
    }
}

// ä¸æ¨¡å¼åŒ¹é…ç»“åˆ
if let Some(value) = optional_value {
    println!("æœ‰å€¼: {}", value);
}
```

æ¡ä»¶è¡¨è¾¾å¼æ—¢å¯ä»¥ç”¨äºæµç¨‹æ§åˆ¶ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºè¡¨è¾¾å¼ç”Ÿæˆå€¼ï¼Œæä¾›äº†ç®€æ´è€Œå¼ºå¤§çš„æ¡ä»¶å¤„ç†èƒ½åŠ›ã€‚

#### 1.5.2 å¾ªç¯ç»“æ„ï¼ˆloop, while, forï¼‰

Rustæä¾›ä¸‰ç§å¾ªç¯ç»“æ„ï¼Œå„æœ‰ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯ï¼š

**loopå¾ªç¯**ï¼šæ— æ¡ä»¶å¾ªç¯ï¼Œé€‚åˆéœ€è¦æ‰‹åŠ¨æ§åˆ¶ç»ˆæ­¢çš„åœºæ™¯ã€‚

```rust
// åŸºæœ¬loopå¾ªç¯
loop {
    println!("å†æ¥ä¸€æ¬¡!");
    if should_stop() {
        break; // é€€å‡ºå¾ªç¯
    }
}

// å¸¦è¿”å›å€¼çš„loop
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2; // è¿”å›å€¼
    }
};
println!("ç»“æœæ˜¯ {}", result); // è¾“å‡º20

// åµŒå¥—å¾ªç¯å’Œæ ‡ç­¾
'outer: loop {
    println!("å¤–å±‚å¾ªç¯");
    'inner: loop {
        println!("å†…å±‚å¾ªç¯");
        break 'outer; // é€€å‡ºå¤–å±‚å¾ªç¯
    }
    println!("è¿™è¡Œæ°¸è¿œä¸ä¼šæ‰§è¡Œ");
}
```

**whileå¾ªç¯**ï¼šæ¡ä»¶æ§åˆ¶å¾ªç¯ï¼Œé€‚åˆäº‹å…ˆçŸ¥é“ç»ˆæ­¢æ¡ä»¶çš„åœºæ™¯ã€‚

```rust
// åŸºæœ¬whileå¾ªç¯
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number -= 1;
}
println!("å‘å°„!");

// whileä¸æ¨¡å¼åŒ¹é…ç»“åˆ
let mut optional = Some(0);
while let Some(i) = optional {
    if i > 9 {
        println!("å¤§äº9ï¼Œé€€å‡º");
        optional = None;
    } else {
        println!("i = {}", i);
        optional = Some(i + 1);
    }
}
```

**forå¾ªç¯**ï¼šè¿­ä»£é›†åˆå…ƒç´ ï¼Œæ˜¯Rustä¸­æœ€å¸¸ç”¨çš„å¾ªç¯å½¢å¼ã€‚

```rust
// åŸºæœ¬forå¾ªç¯ï¼ˆè¿­ä»£é›†åˆï¼‰
let a = [10, 20, 30, 40, 50];
for element in a.iter() {
    println!("å€¼: {}", element);
}

// forè¿­ä»£èŒƒå›´
for number in 1..4 {  // 1, 2, 3
    println!("{}!", number);
}
for number in 1..=4 { // 1, 2, 3, 4
    println!("{}!", number);
}

// è¿­ä»£ä¸ç´¢å¼•
let items = ["è‹¹æœ", "é¦™è•‰", "æ©™å­"];
for (i, &item) in items.iter().enumerate() {
    println!("ä½ç½®{}æ˜¯: {}", i, item);
}

// åå‘è¿­ä»£
for number in (1..4).rev() { // 3, 2, 1
    println!("{}!", number);
}
```

å¾ªç¯æ§åˆ¶ï¼š

```rust
// continueè·³è¿‡å½“å‰è¿­ä»£
for x in 0..10 {
    if x % 2 == 0 {
        continue; // è·³è¿‡å¶æ•°
    }
    println!("{}", x);
}

// breakæå‰ç»ˆæ­¢
let mut sum = 0;
for x in 1..100 {
    sum += x;
    if sum > 500 {
        println!("å’Œè¶…è¿‡500ï¼Œåœ¨x={}æ—¶ç»ˆæ­¢", x);
        break;
    }
}
```

Rustçš„å¾ªç¯ç»“æ„æä¾›äº†çµæ´»ä¸”å®‰å…¨çš„è¿­ä»£æ–¹å¼ï¼Œå°¤å…¶æ˜¯forå¾ªç¯ä¸è¿­ä»£å™¨çš„æ•´åˆï¼Œæ”¯æŒé«˜æ•ˆã€å®‰å…¨åœ°å¤„ç†é›†åˆæ•°æ®ã€‚

#### 1.5.3 æå‰è¿”å›ï¼ˆreturnï¼‰ä¸å¾ªç¯æ§åˆ¶ï¼ˆbreak, continueï¼‰

Rustæä¾›å¤šç§æ–¹å¼æ§åˆ¶å‡½æ•°å’Œå¾ªç¯çš„æ‰§è¡Œæµç¨‹ï¼š

**æå‰è¿”å›ï¼ˆreturnï¼‰**ï¼š

```rust
fn process_number(x: i32) -> i32 {
    if x < 0 {
        println!("ä¸å¤„ç†è´Ÿæ•°");
        return 0; // æå‰è¿”å›
    }
    
    if x == 0 {
        println!("0çš„å¹³æ–¹ä»ä¸º0");
        return 0; // æå‰è¿”å›
    }
    
    // é»˜è®¤å¤„ç†
    println!("è®¡ç®—{}çš„å¹³æ–¹", x);
    x * x
}

// ä½¿ç”¨returnå…³é”®å­—æ˜¾å¼è¿”å›ï¼ˆå¯é€‰ï¼‰
fn compute(x: i32) -> i32 {
    return x + 1; // æ˜¾å¼è¿”å›
    // æˆ–
    x + 1 // éšå¼è¿”å›ï¼ˆæ— åˆ†å·è¡¨è¾¾å¼ï¼‰
}
```

**breakä¸continue**ï¼š

```rust
// breakç»ˆæ­¢å¾ªç¯
let mut counter = 0;
loop {
    counter += 1;
    if counter == 10 {
        break; // ç»ˆæ­¢å¾ªç¯
    }
}

// breakè¿”å›å€¼
let result = loop {
    counter += 1;
    if counter >= 20 {
        break counter; // è¿”å›counterçš„å€¼
    }
};

// continueè·³è¿‡å‰©ä½™è¿­ä»£
for i in 0..10 {
    if i % 2 == 0 {
        continue; // è·³è¿‡å¶æ•°
    }
    println!("{}", i);
}

// æ ‡ç­¾å’ŒåµŒå¥—å¾ªç¯
'outer: for x in 0..5 {
    for y in 0..5 {
        if x == 2 && y == 2 {
            break 'outer; // ç»ˆæ­¢å¤–å±‚å¾ªç¯
        }
        println!("({}, {})", x, y);
    }
}
```

æ§åˆ¶æµè¯­å¥çš„æ ¸å¿ƒç‰¹æ€§ï¼š

1. **è¡¨è¾¾å¼è¿”å›**ï¼šloopå¾ªç¯å¯ä»¥è¿”å›å€¼
2. **æ ‡ç­¾å¾ªç¯**ï¼šå…è®¸æŒ‡å®šè¦ä¸­æ–­æˆ–ç»§ç»­çš„ç‰¹å®šå¾ªç¯
3. **æå‰è¿”å›**ï¼šå‡½æ•°å¯ä»¥åœ¨ä»»ä½•ç‚¹è¿”å›
4. **æ— å€¼è¿”å›**ï¼šå‡½æ•°å¯ä»¥ä¸è¿”å›å€¼ï¼ˆè¿”å›å•å…ƒç±»å‹`()`ï¼‰

è¿™äº›æ§åˆ¶æµç‰¹æ€§å…è®¸å¼€å‘è€…ç²¾ç¡®åœ°æ§åˆ¶ç¨‹åºçš„æ‰§è¡Œè·¯å¾„ï¼Œæé«˜ä»£ç æ¸…æ™°åº¦å’Œæ•ˆç‡ã€‚

#### 1.5.4 æ¨¡å¼åŒ¹é…ï¼ˆmatchï¼‰

æ¨¡å¼åŒ¹é…æ˜¯Rustæœ€å¼ºå¤§çš„ç‰¹æ€§ä¹‹ä¸€ï¼Œæä¾›äº†å…¨é¢è€Œå®‰å…¨çš„å€¼åˆ†ææ–¹å¼ï¼š

```rust
// åŸºæœ¬matchè¡¨è¾¾å¼
let number = 13;
match number {
    // åŒ¹é…å•ä¸ªå€¼
    1 => println!("ä¸€"),
    // åŒ¹é…å¤šä¸ªå€¼
    2 | 3 | 5 | 7 | 11 | 13 => println!("ç´ æ•°"),
    // åŒ¹é…èŒƒå›´
    8..=12 => println!("8åˆ°12ä¹‹é—´"),
    // é»˜è®¤æƒ…å†µ
    _ => println!("å…¶ä»–æ•°å­—"),
}

// matchä½œä¸ºè¡¨è¾¾å¼è¿”å›å€¼
let description = match number {
    1 => "ä¸€",
    2 | 3 | 5 | 7 | 11 | 13 => "ç´ æ•°",
    8..=12 => "8åˆ°12ä¹‹é—´",
    _ => "å…¶ä»–æ•°å­—",
};
```

**æ¨¡å¼ç»‘å®š**ï¼šä»åŒ¹é…å€¼ä¸­æå–éƒ¨åˆ†ï¼š

```rust
// è§£æ„å…ƒç»„
let point = (0, 7);
match point {
    (0, 0) => println!("åŸç‚¹"),
    (0, y) => println!("ä½äºyè½´ï¼Œy={}", y),
    (x, 0) => println!("ä½äºxè½´ï¼Œx={}", x),
    (x, y) => println!("ä½äº(x={}, y={})", x, y),
}

// è§£æ„ç»“æ„ä½“
struct Point { x: i32, y: i32 }
let p = Point { x: 0, y: 7 };
match p {
    Point { x: 0, y: 0 } => println!("åŸç‚¹"),
    Point { x: 0, y } => println!("ä½äºyè½´ï¼Œy={}", y),
    Point { x, y: 0 } => println!("ä½äºxè½´ï¼Œx={}", x),
    Point { x, y } => println!("ä½äº(x={}, y={})", x, y),
}

// è§£æ„æšä¸¾
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let msg = Message::Move { x: 3, y: 4 };
match msg {
    Message::Quit => println!("é€€å‡º"),
    Message::Move { x, y } => println!("ç§»åŠ¨åˆ°x={}, y={}", x, y),
    Message::Write(text) => println!("æ–‡æœ¬æ¶ˆæ¯: {}", text),
    Message::ChangeColor(r, g, b) => println!("é¢œè‰²å˜æ›´ä¸º: {}, {}, {}", r, g, b),
}
```

**åŒ¹é…å®ˆå«**ï¼šä¸ºæ¨¡å¼æ·»åŠ é¢å¤–çš„æ¡ä»¶æµ‹è¯•ï¼š

```rust
let num = 4;
match num {
    x if x < 0 => println!("è´Ÿæ•°"),
    x if x % 2 == 0 => println!("å¶æ•°"),
    x => println!("{} æ˜¯å¥‡æ•°", x),
}

// å¤æ‚æ¡ä»¶
let pair = (2, -2);
match pair {
    (x, y) if x == y => println!("ç›¸ç­‰"),
    (x, y) if x + y == 0 => println!("å’Œä¸ºé›¶"),
    (x, y) if x % 2 == 0 && y % 2 == 0 => println!("éƒ½æ˜¯å¶æ•°"),
    _ => println!("æ— ç‰¹æ®Šè§„å¾‹"),
}
```

**@ç»‘å®š**ï¼šåŒæ—¶æµ‹è¯•å€¼å¹¶åˆ›å»ºå˜é‡ï¼š

```rust
let msg = Message::ChangeColor(255, 160, 0);
match msg {
    Message::ChangeColor(r @ 0..=255, g @ 0..=255, b @ 0..=255) => {
        println!("æœ‰æ•ˆRGBé¢œè‰²: {}, {}, {}", r, g, b);
    }
    Message::ChangeColor(r, g, b) => {
        println!("æ— æ•ˆRGBé¢œè‰²: {}, {}, {}", r, g, b);
    }
    _ => (),
}
```

æ¨¡å¼åŒ¹é…æ˜¯Rustå¤„ç†å¤æ‚æ•°æ®ç»“æ„çš„å¼ºå¤§å·¥å…·ï¼Œæä¾›äº†ç±»å‹å®‰å…¨å’Œç©·å°½æ€§æ£€æŸ¥ã€‚ç¼–è¯‘å™¨ç¡®ä¿matchè¡¨è¾¾å¼æ¶µç›–æ‰€æœ‰å¯èƒ½æƒ…å†µï¼Œé¿å…é—æ¼è¾¹ç•Œæƒ…å†µã€‚

#### 1.5.5 if let ä¸ while let è¯­æ³•

`if let`å’Œ`while let`æ˜¯matchè¡¨è¾¾å¼çš„ç®€åŒ–å½¢å¼ï¼Œé€‚ç”¨äºåªå…³å¿ƒä¸€ä¸ªæ¨¡å¼çš„æƒ…å†µï¼š

**if let**ï¼š

```rust
// ä¼ ç»Ÿmatch
let some_value = Some(3);
match some_value {
    Some(3) => println!("æ˜¯ä¸‰!"),
    _ => (),
}

// ç®€åŒ–ä¸ºif let
if let Some(3) = some_value {
    println!("æ˜¯ä¸‰!");
}

// å¸¦elseçš„if let
if let Some(x) = some_value {
    println!("æœ‰å€¼: {}", x);
} else {
    println!("æ²¡æœ‰å€¼");
}

// å¤æ‚æ¨¡å¼
if let (0, y) = (0, 5) {
    println!("xæ˜¯0ï¼Œyæ˜¯{}", y);
}
```

**while let**ï¼š

```rust
// ä¼ ç»Ÿæ–¹å¼
let mut stack = Vec::new();
stack.push(1);
stack.push(2);
stack.push(3);

loop {
    match stack.pop() {
        Some(top) => println!("å¼¹å‡º: {}", top),
        None => break,
    }
}

// ä½¿ç”¨while letç®€åŒ–
let mut stack = Vec::new();
stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!("å¼¹å‡º: {}", top);
}
```

`if let`å’Œ`while let`çš„ä¼˜ç‚¹ï¼š

1. **ç®€æ´æ€§**ï¼šå½“åªå…³å¿ƒä¸€ä¸ªæ¨¡å¼æ—¶ï¼Œé¿å…äº†å†—é•¿çš„match
2. **è¡¨è¾¾æ¸…æ™°**ï¼šæ˜ç¡®è¡¨æ˜ä»£ç åªå¤„ç†ç‰¹å®šæƒ…å†µ
3. **ä¸å…¶ä»–æ§åˆ¶æµç»“åˆ**ï¼šå¯ä»¥ä¸if elseå’Œå¾ªç¯è‡ªç„¶ç»“åˆ

è¿™äº›ç®€åŒ–å½¢å¼åœ¨å¤„ç†`Option`å’Œ`Result`ç±»å‹æ—¶ç‰¹åˆ«æœ‰ç”¨ï¼Œä½¿ä»£ç æ›´åŠ æ¸…æ™°ç®€æ´ã€‚

#### 1.5.6 é—®å·æ“ä½œç¬¦ï¼ˆ?ï¼‰çš„é”™è¯¯ä¼ æ’­

é—®å·æ“ä½œç¬¦`?`æ˜¯Rustä¸­ä¼˜é›…å¤„ç†é”™è¯¯çš„å…³é”®ç‰¹æ€§ï¼Œç®€åŒ–äº†é”™è¯¯ä¼ æ’­ï¼š

```rust
// ä¼ ç»Ÿæ–¹å¼å¤„ç†é”™è¯¯
fn read_file_verbose(path: &str) -> Result<String, io::Error> {
    let file = match File::open(path) {
        Ok(file) => file,
        Err(error) => return Err(error),
    };
    
    let mut content = String::new();
    match file.read_to_string(&mut content) {
        Ok(_) => Ok(content),
        Err(error) => Err(error),
    }
}

// ä½¿ç”¨?æ“ä½œç¬¦ç®€åŒ–
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;
    Ok(content)
}

// é“¾å¼è°ƒç”¨
fn read_file_chain(path: &str) -> Result<String, io::Error> {
    let mut content = String::new();
    File::open(path)?.read_to_string(&mut content)?;
    Ok(content)
}
```

é—®å·æ“ä½œç¬¦çš„å·¥ä½œåŸç†ï¼š

1. å¦‚æœç»“æœæ˜¯`Ok(value)`ï¼Œåˆ™æå–valueç»§ç»­æ‰§è¡Œ
2. å¦‚æœç»“æœæ˜¯`Err(error)`ï¼Œåˆ™æå‰è¿”å›é”™è¯¯
3. é”™è¯¯ç±»å‹ä¼šè‡ªåŠ¨è½¬æ¢ï¼Œå¦‚æœå®ç°äº†`From` trait

é—®å·æ“ä½œç¬¦ä¹Ÿå¯ç”¨äº`Option`ç±»å‹ï¼š

```rust
fn first_char(text: &str) -> Option<char> {
    let first_char = text.chars().next()?;
    Some(first_char.to_uppercase().next()?)
}
```

å·¥ä½œåœ¨`Option`ä¸Šæ—¶ï¼š

1. å¦‚æœæ˜¯`Some(value)`ï¼Œæå–valueç»§ç»­æ‰§è¡Œ
2. å¦‚æœæ˜¯`None`ï¼Œç«‹å³è¿”å›`None`

é—®å·æ“ä½œç¬¦çš„é«˜çº§åº”ç”¨ï¼š

```rust
// ç»„åˆResultå’ŒOption
fn process_file(path: &str) -> Result<Option<String>, io::Error> {
    let content = std::fs::read_to_string(path)?;
    
    if content.trim().is_empty() {
        return Ok(None); // æ–‡ä»¶ä¸ºç©º
    }
    
    Ok(Some(format!("å¤„ç†å: {}", content)))
}

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹è½¬æ¢
#[derive(Debug)]
enum AppError {
    IoError(io::Error),
    ParseError(ParseIntError),
    Other(String),
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::IoError(error)
    }
}

impl From<ParseIntError> for AppError {
    fn from(error: ParseIntError) -> Self {
        AppError::ParseError(error)
    }
}

fn read_and_parse(path: &str) -> Result<i32, AppError> {
    let content = std::fs::read_to_string(path)?; // io::Errorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    let number = content.trim().parse::<i32>()?;  // ParseIntErrorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    Ok(number * 2)
}
```

é—®å·æ“ä½œç¬¦æå¤§ç®€åŒ–äº†é”™è¯¯å¤„ç†ä»£ç ï¼Œæ˜¯Rustä¸­æœ€å®ç”¨çš„è¯­æ³•ç³–ä¹‹ä¸€ï¼Œä½¿é”™è¯¯ä¼ æ’­æ—¢ç®€æ´åˆä¸å¤±å®‰å…¨æ€§ã€‚

## 2. ç±»å‹ç³»ç»Ÿä¸æŠ½è±¡

### 2.1 è‡ªå®šä¹‰æ•°æ®ç±»å‹

#### 2.1.1 ç»“æ„ä½“ï¼ˆstructï¼‰

ç»“æ„ä½“æ˜¯Rustä¸­è‡ªå®šä¹‰æ•°æ®ç±»å‹çš„ä¸»è¦å½¢å¼ï¼Œç”¨äºç»„ç»‡ç›¸å…³æ•°æ®ï¼š

```rust
// ç»å…¸ç»“æ„ä½“ï¼ˆå…·åå­—æ®µï¼‰
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

// åˆ›å»ºå®ä¾‹
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

// å¯å˜å®ä¾‹
let mut user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anothername456"),
    active: true,
    sign_in_count: 3,
};
user2.email = String::from("newemail@example.com");

// å­—æ®µåˆå§‹åŒ–ç®€å†™
fn build_user(email: String, username: String) -> User {
    User {
        email,      // ç­‰åŒäº email: email
        username,   // ç­‰åŒäº username: username
        active: true,
        sign_in_count: 1,
    }
}

// ç»“æ„ä½“æ›´æ–°è¯­æ³•
let user3 = User {
    email: String::from("third@example.com"),
    ..user1  // å…¶ä½™å­—æ®µä»user1è·å–
};
```

Rustæ”¯æŒä¸‰ç§ç»“æ„ä½“å½¢å¼ï¼š

**1. å…·åå­—æ®µç»“æ„ä½“**ï¼šå¦‚ä¸Šä¾‹æ‰€ç¤ºï¼Œæœ€å¸¸ç”¨å½¢å¼ã€‚

**2. å…ƒç»„ç»“æ„ä½“**ï¼šæœ‰åç§°ä½†å­—æ®µæ— åï¼š

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// è®¿é—®å­—æ®µ
let red = black.0;
```

**3. ç±»å•å…ƒç»“æ„ä½“**ï¼šæ— å­—æ®µï¼Œé€šå¸¸ç”¨äºå®ç°traitsï¼š

```rust
struct AlwaysEqual;
let subject = AlwaysEqual;

// å®ç°ç‰¹æ€§
impl SomeTrait for AlwaysEqual {
    // æ–¹æ³•å®ç°...
}
```

ç»“æ„ä½“æ–¹æ³•å®ç°ï¼š

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•ï¼ˆæ¥æ”¶selfï¼‰
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // å¯ä»¥ä¿®æ”¹è‡ªèº«çš„æ–¹æ³•
    fn set_width(&mut self, width: u32) {
        self.width = width;
    }
    
    // å…³è”å‡½æ•°ï¼ˆä¸æ¥æ”¶selfï¼Œç±»ä¼¼"é™æ€æ–¹æ³•"ï¼‰
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

// ä½¿ç”¨
let mut rect = Rectangle { width: 30, height: 50 };
let area = rect.area();  // è°ƒç”¨æ–¹æ³•
rect.set_width(60);      // è°ƒç”¨å¯å˜æ–¹æ³•
let square = Rectangle::square(20);  // è°ƒç”¨å…³è”å‡½æ•°
```

ç»“æ„ä½“å¯ä»¥æœ‰å¤šä¸ª`impl`å—ï¼š

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

ç»“æ„ä½“çš„é«˜çº§ç‰¹æ€§ï¼š

**æ³›å‹ç»“æ„ä½“**ï¼š

```rust
struct Point<T> {
    x: T,
    y: T,
}

// ä¸åŒå‚æ•°ç±»å‹
struct Pair<T, U> {
    first: T,
    second: U,
}
```

**æ´¾ç”Ÿç‰¹å¾**ï¼š

```rust
#[derive(Debug, Clone, PartialEq)]
struct Person {
    name: String,
    age: u32,
}

// ä½¿ç”¨æ´¾ç”Ÿçš„Debugç‰¹å¾
let p = Person { name: String::from("Alice"), age: 30 };
println!("{:?}", p);  // è¾“å‡º: Person { name: "Alice", age: 30 }
```

**ç”Ÿå‘½å‘¨æœŸç»“æ„ä½“**ï¼š

```rust
struct Excerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let e = Excerpt { part: first_sentence };
}
```

ç»“æ„ä½“æä¾›äº†ç»„ç»‡ç›¸å…³æ•°æ®çš„å¼ºå¤§æœºåˆ¶ï¼Œç»“åˆæ–¹æ³•å®ç°ï¼Œæ˜¯Rustä¸­å®ç°é¢å‘å¯¹è±¡ç¼–ç¨‹èŒƒå¼çš„åŸºç¡€ã€‚

#### 2.1.2 æšä¸¾ï¼ˆenumï¼‰

æšä¸¾å…è®¸å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹å¯ä»¥æ˜¯å‡ ä¸ªä¸åŒå˜ä½“ä¹‹ä¸€ï¼š

```rust
// åŸºæœ¬æšä¸¾
enum IpAddrKind {
    V4,
    V6,
}

// ä½¿ç”¨
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;

// å¸¦æ•°æ®çš„æšä¸¾
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));

// ä¸åŒç±»å‹çš„å˜ä½“
enum Message {
    Quit,                       // æ— æ•°æ®
    Move { x: i32, y: i32 },    // åŒ¿åç»“æ„ä½“
    Write(String),              // å•å€¼å…ƒç»„
    ChangeColor(i32, i32, i32), // å…ƒç»„
}
```

æšä¸¾ä¹Ÿå¯ä»¥æœ‰æ–¹æ³•å®ç°ï¼š

```rust
impl Message {
    fn call(&self) {
        match self {
            Message::Quit => println!("é€€å‡º"),
            Message::Move { x, y } => println!("ç§»åŠ¨åˆ° x:{}, y:{}", x, y),
            Message::Write(text) => println!("æ–‡æœ¬æ¶ˆæ¯: {}", text),
            Message::ChangeColor(r, g, b) => println!("é¢œè‰²å˜æ›´ä¸º: {}, {}, {}", r, g, b),
        }
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

**Optionæšä¸¾**ï¼š
Rustæ ‡å‡†åº“ä¸­æœ€å¸¸ç”¨çš„æšä¸¾æ˜¯`Option<T>`ï¼Œè¡¨ç¤ºå¯èƒ½å­˜åœ¨æˆ–ä¸å­˜åœ¨çš„å€¼ï¼š

```rust
enum Option<T> {
    Some(T),
    None,
}

// ä½¿ç”¨Option
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;

// å¤„ç†Option
match some_number {
    Some(n) => println!("å€¼æ˜¯ {}", n),
    None => println!("æ²¡æœ‰å€¼"),
}

// å®‰å…¨è§£åŒ…
let value = some_number.unwrap_or(0);
```

**Resultæšä¸¾**ï¼š
å¦ä¸€ä¸ªå¸¸ç”¨æšä¸¾æ˜¯`Result<T, E>`ï¼Œè¡¨ç¤ºå¯èƒ½æˆåŠŸæˆ–å¤±è´¥çš„æ“ä½œï¼š

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// ä½¿ç”¨Result
let file_result = File::open("hello.txt");
match file_result {
    Ok(file) => println!("æ–‡ä»¶æ‰“å¼€æˆåŠŸ"),
    Err(error) => println!("æ‰“å¼€æ–‡ä»¶å¤±è´¥: {}", error),
}
```

æšä¸¾çš„é«˜çº§åº”ç”¨ï¼š

**é€’å½’æšä¸¾**ï¼š

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

// åˆ›å»ºåˆ—è¡¨ 1 -> 2 -> 3 -> Nil
let list = List::Cons(1, Box::new(List::Cons(2,
    Box::new(List::Cons(3, Box::new(List::Nil))))));
```

**ç±»å‹åˆ«åä¸æšä¸¾**ï¼š

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// ç±»å‹åˆ«ååˆ›å»ºç‰¹å®šé¢†åŸŸç±»å‹
type IoResult<T> = Result<T, std::io::Error>;

fn read_file() -> IoResult<String> {
    // ...
}
```

æšä¸¾æ˜¯Rustè¡¨è¾¾ä¸€ç»„ç›¸å…³å¯èƒ½æ€§çš„å¼ºå¤§å·¥å…·ï¼Œé…åˆæ¨¡å¼åŒ¹é…ï¼Œæä¾›äº†ç±»å‹å®‰å…¨çš„é€‰æ‹©å¤„ç†æœºåˆ¶ã€‚

#### 2.1.3 è”åˆä½“ï¼ˆunionï¼‰

è”åˆä½“æ˜¯ä¸€ç§å†…å­˜èŠ‚çº¦å‹æ•°æ®ç»“æ„ï¼Œå…è®¸å¤šä¸ªä¸åŒç±»å‹å…±äº«ç›¸åŒå†…å­˜ä½ç½®ï¼š

```rust
// å®šä¹‰è”åˆä½“ï¼ˆéœ€è¦unsafeä»£ç ï¼‰
#[repr(C)]
union IntOrFloat {
    i: u32,
    f: f32,
}

// ä½¿ç”¨è”åˆä½“
fn main() {
    let mut value = IntOrFloat { i: 123456 };
    
    unsafe {
        println!("æ•´æ•°å€¼: {}", value.i);
        value.f = 3.14;
        println!("æµ®ç‚¹å€¼: {}", value.f);
        
        // å±é™©: value.iç°åœ¨åŒ…å«fçš„ä½æ¨¡å¼
        println!("é‡è§£é‡Šä¸ºæ•´æ•°: {}", value.i);
    }
}
```

è”åˆä½“å…³é”®ç‰¹æ€§ï¼š

1. **è®¿é—®éœ€è¦unsafe**ï¼šå› ä¸ºæ— æ³•åœ¨ç¼–è¯‘æ—¶ä¿è¯ç±»å‹å®‰å…¨
2. **å…±äº«å†…å­˜**ï¼šæ‰€æœ‰å­—æ®µå…±äº«ç›¸åŒå†…å­˜ç©ºé—´
3. **æ— æ ‡è®°**ï¼šè”åˆä½“æœ¬èº«ä¸è·Ÿè¸ªå½“å‰æ´»åŠ¨çš„å­—æ®µ
4. **ä¸»è¦ç”¨äºFFI**ï¼šä¸Cä»£ç äº¤äº’æ—¶ç‰¹åˆ«æœ‰ç”¨
5. **å­—æ®µä¸èƒ½å®ç°Drop**ï¼šå› ä¸ºç¼–è¯‘å™¨ä¸çŸ¥é“å“ªä¸ªå­—æ®µæ˜¯æ´»åŠ¨çš„

ä½¿ç”¨åœºæ™¯ï¼š

1. **ä¸Cä»£ç äº¤äº’**ï¼šå®ç°ä¸Cè”åˆä½“å…¼å®¹çš„æ•°æ®ç»“æ„
2. **åº•å±‚å†…å­˜è¡¨ç¤ºæ§åˆ¶**ï¼šå¦‚ç½‘ç»œåè®®æˆ–ç¡¬ä»¶æ¥å£
3. **é«˜æ•ˆå†…å­˜å¤ç”¨**ï¼šå½“åªéœ€ä¸€æ¬¡ä½¿ç”¨å¤šä¸ªå¯èƒ½ç±»å‹
4. **ä½æ¨¡å¼è§£é‡Š**ï¼šæŸ¥çœ‹ç›¸åŒæ•°æ®çš„ä¸åŒè¡¨ç¤º

è”åˆä½“æ˜¯Rustè¾ƒä½çº§çš„ç‰¹æ€§ï¼Œé€šå¸¸åœ¨ç³»ç»Ÿç¼–ç¨‹å’Œä¸Cäº¤äº’æ—¶ä½¿ç”¨ï¼Œä¸€èˆ¬åº”ç”¨ä¸­è¾ƒå°‘å‡ºç°ã€‚

#### 2.1.4 ç±»å‹åˆ«åï¼ˆtypeï¼‰

ç±»å‹åˆ«åä½¿ç”¨`type`å…³é”®å­—åˆ›å»ºç°æœ‰ç±»å‹çš„æ–°åç§°ï¼Œæé«˜ä»£ç å¯è¯»æ€§ï¼š

```rust
// åŸºæœ¬ç±»å‹åˆ«å
type Kilometers = i32;

let distance: Kilometers = 5;
let normal_int: i32 = 5;
// Kilometerså’Œi32å®Œå…¨ç›¸åŒï¼Œå¯äº’æ¢ä½¿ç”¨
let sum = distance + normal_int; 

// å¤æ‚ç±»å‹åˆ«å
type Thunk = Box<dyn Fn() + Send + 'static>;

fn take_thunk(f: Thunk) {
    // ...
}

fn return_thunk() -> Thunk {
    Box::new(|| println!("è¿™æ˜¯ä¸€ä¸ªé—­åŒ…"))
}

// æ³›å‹ç±»å‹åˆ«å
type Result<T> = std::result::Result<T, std::io::Error>;

fn read_file(path: &str) -> Result<String> {
    std::fs::read_to_string(path)
}

// å¤æ‚æ³›å‹åˆ«å
type GenericMap<K, V> = HashMap<K, V, RandomState>;
```

ç±»å‹åˆ«åçš„ä¸»è¦ç”¨é€”ï¼š

1. **å‡å°‘é‡å¤**ï¼šç¼©çŸ­å†—é•¿ç±»å‹å
2. **æé«˜å¯è¯»æ€§**ï¼šä¸ºå¤æ‚ç±»å‹æä¾›æœ‰æ„ä¹‰åç§°
3. **åŸŸç‰¹å®šè¯­ä¹‰**ï¼šæ·»åŠ ä¸Šä¸‹æ–‡æˆ–é¢†åŸŸå«ä¹‰
4. **æŠ½è±¡å®ç°ç»†èŠ‚**ï¼šéšè—å†…éƒ¨ç±»å‹å®ç°
5. **ç®€åŒ–è¿ç§»**ï¼šé€šè¿‡åˆ«åå®ç°ç±»å‹æ›¿æ¢

ç±»å‹åˆ«åä¸åŸç±»å‹çš„å…³ç³»ï¼š

```rust
// ç±»å‹åˆ«åå’ŒåŸç±»å‹å®Œå…¨ç›¸åŒ
type Age = u32;

let age: Age = 30;
let years: u32 = age; // å¯ç›´æ¥èµ‹å€¼ï¼Œæ— éœ€è½¬æ¢

fn process_number(n: u32) {
    // ...
}
process_number(age); // åˆæ³•
```

ç±»å‹åˆ«åä¸æ–°ç±»å‹æ¨¡å¼çš„åŒºåˆ«ï¼šç±»å‹åˆ«ååªæ˜¯ç°æœ‰ç±»å‹çš„å¦ä¸€ä¸ªåç§°ï¼Œè€Œæ–°ç±»å‹åˆ›å»ºäº†å…¨æ–°çš„ã€ä¸åŒçš„ç±»å‹ã€‚

#### 2.1.5 æ–°ç±»å‹æ¨¡å¼ï¼ˆnewtype patternï¼‰

æ–°ç±»å‹æ¨¡å¼ä½¿ç”¨å•å­—æ®µå…ƒç»„ç»“æ„ä½“åˆ›å»ºå…¨æ–°ç±»å‹ï¼Œæä¾›ç±»å‹å®‰å…¨å’ŒæŠ½è±¡ï¼š

```rust
// åŸºæœ¬æ–°ç±»å‹
struct Meters(f64);
struct Kilometers(f64);

// å³ä½¿éƒ½åŒ…å«f64ï¼Œè¿™ä¸¤ä¸ªç±»å‹ä¸èƒ½äº’æ¢
let distance = Kilometers(5.0);
// let m: Meters = distance; // ç¼–è¯‘é”™è¯¯

// æ·»åŠ è½¬æ¢æ–¹æ³•
impl Kilometers {
    fn to_meters(&self) -> Meters {
        Meters(self.0 * 1000.0)
    }
}

// ä¸ºæ–°ç±»å‹æ·»åŠ æ“ä½œ
impl Meters {
    fn add(&self, other: &Meters) -> Meters {
        Meters(self.0 + other.0)
    }
}

// é€šè¿‡æ–°ç±»å‹å®ç°å¤–éƒ¨ç‰¹å¾
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

æ–°ç±»å‹æ¨¡å¼ç”¨é€”ï¼š

1. **ç±»å‹å®‰å…¨**ï¼šé˜²æ­¢æ··æ·†ä¸åŒå•ä½æˆ–æ¦‚å¿µ
2. **é™åˆ¶åŠŸèƒ½**ï¼šéšè—å†…éƒ¨ç±»å‹çš„æŸäº›æ–¹æ³•
3. **æ·»åŠ ä¸Šä¸‹æ–‡**ï¼šä½¿ç±»å‹åä½“ç°é¢†åŸŸå«ä¹‰
4. **ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨ç‰¹å¾**ï¼šè§£å†³å­¤å„¿è§„åˆ™é™åˆ¶
5. **é›¶å¼€é”€æŠ½è±¡**ï¼šç¼–è¯‘æ—¶å¼ºåˆ¶ç±»å‹å®‰å…¨ï¼Œæ— è¿è¡Œæ—¶å¼€é”€

æ–°ç±»å‹ä¸ç±»å‹åˆ«åçš„å…³é”®åŒºåˆ«ï¼š

```rust
type Miles = f64; // ç±»å‹åˆ«å
struct Kilometers(f64); // æ–°ç±»å‹

let m1: Miles = 10.0;
let m2: f64 = m1; // æœ‰æ•ˆï¼ŒMileså°±æ˜¯f64

let k1 = Kilometers(10.0);
// let k2: f64 = k1; // é”™è¯¯ï¼ŒKilometersä¸æ˜¯f64
let k2: f64 = k1.0; // æ­£ç¡®ï¼Œé€šè¿‡.0è®¿é—®å†…éƒ¨å€¼
```

æ–°ç±»å‹æ¨¡å¼æ˜¯Rustä¸­å®ç°ç±»å‹å®‰å…¨ã€è¯­ä¹‰æ¸…æ™°ä»£ç çš„å¼ºå¤§å·¥å…·ï¼Œåœ¨åº“è®¾è®¡ä¸­æœ‰å¹¿æ³›åº”ç”¨ã€‚

### 2.2 æ³›å‹ä¸å¤šæ€

#### 2.2.1 æ³›å‹å‚æ•°

æ³›å‹å…è®¸åœ¨ä¸æŸå¤±ç±»å‹å®‰å…¨çš„å‰æä¸‹å®ç°ä»£ç å¤ç”¨ï¼š

```rust
// æ³›å‹å‡½æ•°
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// è°ƒç”¨æ³›å‹å‡½æ•°
let number_list = vec![34, 50, 25, 100, 65];
let result = largest(&number_list);
let char_list = vec!['y', 'm', 'a', 'q'];
let result = largest(&char_list);

// å¤šå‚æ•°æ³›å‹
fn pair<T, U>(t: T, u: U) -> (T, U) {
    (t, u)
}
```

æ³›å‹å‚æ•°å‘½åçº¦å®šï¼š

- ç±»å‹å‚æ•°é€šå¸¸ä½¿ç”¨å•ä¸ªå¤§å†™å­—æ¯ï¼š`T`ã€`U`ã€`V`ç­‰
- é›†åˆå…ƒç´ ç±»å‹å¸¸ç”¨`T`
- é”®å€¼å¯¹å¸¸ç”¨`K`å’Œ`V`
- è¿­ä»£å™¨å…ƒç´ é€šå¸¸ç”¨`Item`ï¼ˆå…³è”ç±»å‹ï¼‰

æ³›å‹å‚æ•°ä½ç½®ï¼š

```rust
// å‡½æ•°æ³›å‹å‚æ•°
fn process<T>(value: T) {}

// ç»“æ„ä½“æ³›å‹å‚æ•°
struct Point<T> {
    x: T,
    y: T,
}

// æšä¸¾æ³›å‹å‚æ•°
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

// æ–¹æ³•æ³›å‹å‚æ•°
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
    
    // æ–¹æ³•å¯ä»¥æœ‰é¢å¤–çš„æ³›å‹å‚æ•°
    fn transform<U>(&self, other: U) -> U {
        other
    }
}
```

#### 2.2.2 æ³›å‹å‡½æ•°ä¸æ–¹æ³•

æ³›å‹å‡½æ•°æä¾›é€‚ç”¨äºå¤šç§ç±»å‹çš„é€šç”¨å®ç°ï¼š

```rust
// åŸºæœ¬æ³›å‹å‡½æ•°
fn first<T>(list: &[T]) -> Option<&T> {
    if list.is_empty() {
        None
    } else {
        Some(&list[0])
    }
}

// æ³›å‹æ–¹æ³•
struct Data<T> {
    values: Vec<T>,
}

impl<T> Data<T> {
    fn new() -> Self {
        Data { values: Vec::new() }
    }
    
    fn add(&mut self, value: T) {
        self.values.push(value);
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        self.values.get(index)
    }
}

// å…·ä½“ç±»å‹æ–¹æ³•
impl Data<String> {
    fn join(&self, separator: &str) -> String {
        self.values.join(separator)
    }
}
```

æ³›å‹æ–¹æ³•çš„ç‰¹æ®Šæƒ…å†µï¼š

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

// æ‰€æœ‰Point<T, U>å®ä¾‹ä¸Šçš„æ–¹æ³•
impl<T, U> Point<T, U> {
    fn x(&self) -> &T {
        &self.x
    }
}

// åªåœ¨Point<f32, f32>ä¸Šå®ç°çš„æ–¹æ³•
impl Point<f32, f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// æ–¹æ³•å¯ä½¿ç”¨ä¸åŒçš„æ³›å‹å‚æ•°
impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
```

æ³›å‹å‡½æ•°çš„æ€§èƒ½ï¼š

- Rustä½¿ç”¨**å•æ€åŒ–**å¤„ç†æ³›å‹ï¼šä¸ºæ¯ç§å…·ä½“ç±»å‹ç”Ÿæˆä¸“ç”¨ä»£ç 
- è¿™ç¡®ä¿äº†æ³›å‹ä»£ç ä¸æ‰‹å†™ä¸“ç”¨ä»£ç å…·æœ‰ç›¸åŒæ€§èƒ½
- ç¼–è¯‘æ—¶é—´å’Œä»£ç å¤§å°å¯èƒ½å¢åŠ ï¼Œä½†è¿è¡Œæ—¶æ— æ€§èƒ½æŸå¤±

#### 2.2.3 æ³›å‹ç»“æ„ä½“ä¸æšä¸¾

æ³›å‹ç»“æ„ä½“å’Œæšä¸¾ä½¿æ•°æ®ç»“æ„é€‚ç”¨äºå¤šç§ç±»å‹ï¼š

```rust
// å•å‚æ•°æ³›å‹ç»“æ„ä½“
struct Container<T> {
    value: T,
}

// å¤šå‚æ•°æ³›å‹ç»“æ„ä½“ï¼Œå‚æ•°å¯æœ‰ä¸åŒç±»å‹
struct KeyValue<K, V> {
    key: K,
    value: V,
}

// å¤šå‚æ•°ä½†æŸäº›ä½ç½®ç±»å‹ç›¸åŒ
struct Point<T> {
    x: T,
    y: T,
}

// æ³›å‹åŒ…å«å¼•ç”¨éœ€ç”Ÿå‘½å‘¨æœŸ
struct Ref<'a, T> {
    value: &'a T,
}

// æ³›å‹æšä¸¾
enum Status<T> {
    Success(T),
    Failure(T),
    Pending,
}

// ä¸åŒå˜ä½“å¯ç”¨ä¸åŒç±»å‹
enum Either<L, R> {
    Left(L),
    Right(R),
}
```

å°†æ³›å‹ä¸å…¶ä»–ç‰¹æ€§ç»„åˆï¼š

```rust
// å¸¦é»˜è®¤ç±»å‹çš„æ³›å‹ç»“æ„ä½“
struct Container<T = i32> {
    value: T,
}
let int_container = Container { value: 42 }; // é»˜è®¤i32
let str_container: Container<String> = Container { value: "hello".to_string() };

// æ³›å‹ä¸ç‰¹å¾çº¦æŸ
struct SortableContainer<T: Ord> {
    values: Vec<T>,
}

impl<T: Ord> SortableContainer<T> {
    fn sort(&mut self) {
        self.values.sort();
    }
}

// æ³›å‹ã€ç‰¹å¾çº¦æŸä¸ç”Ÿå‘½å‘¨æœŸ
struct NamedRef<'a, T: Display> {
    name: String,
    reference: &'a T,
}
```

#### 2.2.4 æ³›å‹çº¦æŸ

æ³›å‹çº¦æŸé™åˆ¶ç±»å‹å‚æ•°å¿…é¡»æ»¡è¶³ç‰¹å®šç‰¹å¾ï¼š

```rust
// åŸºæœ¬ç‰¹å¾çº¦æŸ
fn print<T: Display>(value: T) {
    println!("{}", value);
}

// å¤šé‡ç‰¹å¾çº¦æŸ
fn print_and_compare<T: Display + PartialOrd>(value1: T, value2: T) {
    println!("{} and {}", value1, value2);
    if value1 > value2 {
        println!("First is greater");
    } else if value1 < value2 {
        println!("Second is greater");
    } else {
        println!("They are equal");
    }
}

// whereå­å¥ï¼ˆé€‚åˆå¤æ‚çº¦æŸï¼‰
fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
    // å‡½æ•°ä½“
}

// çº¦æŸæ³›å‹å…³è”ç±»å‹
fn process<I>(items: I)
    where I: Iterator,
          I::Item: Debug
{
    for item in items {
        println!("{:?}", item);
    }
}
```

çº¦æŸå¯å®ç°æ¡ä»¶æ–¹æ³•ï¼š

```rust
struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// åªä¸ºå®ç°Displayå’ŒPartialOrdçš„ç±»å‹å®ç°cmp_displayæ–¹æ³•
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("æœ€å¤§å€¼æ˜¯x = {}", self.x);
        } else {
            println!("æœ€å¤§å€¼æ˜¯y = {}", self.y);
        }
    }
}
```

ç‰¹å¾çº¦æŸå…è®¸å®ç°**ç‰¹å¾çº¦æŸçš„æ¡ä»¶å®ç°**ï¼š

```rust
// ä¸ºæ‰€æœ‰å®ç°Displayçš„Tç±»å‹å®ç°ToString
impl<T: Display> ToString for T {
    // ...
}
```

#### 2.2.5 é›¶å¤§å°ç±»å‹ï¼ˆZSTï¼‰

é›¶å¤§å°ç±»å‹ï¼ˆZero-Sized Typeï¼‰æ˜¯ç¼–è¯‘æ—¶å­˜åœ¨ä½†è¿è¡Œæ—¶ä¸å ç”¨å†…å­˜çš„ç±»å‹ï¼š

```rust
// å•å…ƒç»“æ„ä½“æ˜¯é›¶å¤§å°ç±»å‹
struct Empty;

// éªŒè¯å¤§å°
use std::mem::size_of;
assert_eq!(size_of::<Empty>(), 0);

// ç”¨äºæ ‡è®°çš„é›¶å¤§å°ç±»å‹
struct Input;
struct Output;

fn process(_: Input) -> Output {
    Output
}

// æ³›å‹ä¸Šä¸‹æ–‡ä¸­çš„é›¶å¤§å°ç±»å‹
use std::marker::PhantomData;
struct Identifier<T> {
    id: u64,
    _marker: PhantomData<T>, // ä¸å ç”¨è¿è¡Œæ—¶å†…å­˜
}

fn main() {
    let id1 = Identifier::<String> { id: 1, _marker: PhantomData };
    let id2 = Identifier::<i32> { id: 2, _marker: PhantomData };
    
    // id1å’Œid2æ˜¯ä¸åŒç±»å‹
    // ä½†_markerå­—æ®µä¸å å†…å­˜
}
```

é›¶å¤§å°ç±»å‹çš„ç”¨é€”ï¼š

1. **ç±»å‹çŠ¶æ€**ï¼šåœ¨ç±»å‹çº§åˆ«è¡¨è¾¾çŠ¶æ€ï¼Œæ— è¿è¡Œæ—¶å¼€é”€
2. **æ ‡è®°ç‰¹å¾**ï¼šå¦‚`Send`ã€`Sync`ç­‰ï¼Œä»…ç”¨äºç±»å‹æ£€æŸ¥
3. **ç±»å‹æ ‡è®°**ï¼š`PhantomData`æä¾›æ³›å‹å‚æ•°è€Œæ— éœ€å­˜å‚¨å€¼
4. **ç±»å‹çº§åˆ«ç¼–ç¨‹**ï¼šå®ç°ç¼–è¯‘æ—¶çº¦æŸå’ŒéªŒè¯
5. **å†…å­˜ä¼˜åŒ–**ï¼šç©ºç»“æ„ä½“å­—æ®µä¸å¢åŠ å¤§å°

é›¶å¤§å°ç±»å‹æ˜¯Rustç±»å‹ç³»ç»Ÿçš„é‡è¦ç‰¹æ€§ï¼Œå®ç°äº†æ— è¿è¡Œæ—¶å¼€é”€çš„ç¼–è¯‘æ—¶å®‰å…¨æ£€æŸ¥ã€‚

### 2.3 ç‰¹å¾ç³»ç»Ÿ

#### 2.3.1 ç‰¹å¾ï¼ˆtraitï¼‰å®šä¹‰ä¸å®ç°

ç‰¹å¾å®šä¹‰ç±»å‹è¡Œä¸ºçš„æ¥å£ï¼š

```rust
// å®šä¹‰ç‰¹å¾
trait Summary {
    // å¿…é¡»å®ç°çš„æ–¹æ³•ï¼ˆç­¾åï¼‰
    fn summarize(&self) -> String;
    
    // å¸¦é»˜è®¤å®ç°çš„æ–¹æ³•
    fn preview(&self) -> String {
        format!("é˜…è¯»æ›´å¤š: {}", self.summarize())
    }
}

// å®ç°ç‰¹å¾
struct NewsArticle {
    headline: String,
    location: String,
    author: String,
    content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
    
    // å¯ä»¥è¦†ç›–é»˜è®¤å®ç°
    fn preview(&self) -> String {
        format!("çªå‘æ–°é—»: {}", self.headline)
    }
}

struct Tweet {
    username: String,
    content: String,
    reply: bool,
    retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
    // ä½¿ç”¨previewé»˜è®¤å®ç°
}
```

ç‰¹å¾çš„ä¸»è¦ç»„æˆï¼š

1. **æ–¹æ³•ç­¾å**ï¼šå¿…é¡»å®ç°çš„å‡½æ•°
2. **é»˜è®¤å®ç°**ï¼šå¯é€‰çš„é¢„å®šä¹‰è¡Œä¸º
3. **å…³è”ç±»å‹**ï¼šä¸å®ç°ç±»å‹ç›¸å…³çš„ç±»å‹
4. **å…³è”å¸¸é‡**ï¼šä¸å®ç°ç±»å‹ç›¸å…³çš„å¸¸é‡
5. **ç±»å‹å‡½æ•°**ï¼šå¯¹å…³è”ç±»å‹çš„æ“ä½œ

```rust
// å¸¦å…³è”ç±»å‹çš„ç‰¹å¾
trait Container {
    type Item;
    
    fn get(&self, index: usize) -> Option<&Self::Item>;
    fn push(&mut self, item: Self::Item);
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

// å®ç°å¸¦å…³è”ç±»å‹çš„ç‰¹å¾
impl Container for Vec<i32> {
    type Item = i32;
    
    fn get(&self, index: usize) -> Option<&Self::Item> {
        self.get(index)
    }
    
    fn push(&mut self, item: Self::Item) {
        self.push(item);
    }
    
    fn len(&self) -> usize {
        self.len()
    }
}
```

#### 2.3.2 ç‰¹å¾ä½œä¸ºå‚æ•°

ç‰¹å¾å¯ç”¨ä½œå‡½æ•°å‚æ•°ï¼Œåˆ›å»ºå¤šæ€æ€§ï¼š

```rust
// ç‰¹å¾çº¦æŸè¯­æ³•
fn notify(item: &impl Summary) {
    println!("çªå‘æ–°é—»! {}", item.summarize());
}

// æ³›å‹ä¸ç‰¹å¾çº¦æŸç­‰ä»·å½¢å¼
fn notify<T: Summary>(item: &T) {
    println!("çªå‘æ–°é—»! {}", item.summarize());
}

// å¤šç‰¹å¾çº¦æŸ
fn notify(item: &(impl Summary + Display)) {
    println!("çªå‘æ–°é—»! {}", item.summarize());
    println!("{}", item);
}

// ç­‰ä»·æ³›å‹å½¢å¼
fn notify<T: Summary + Display>(item: &T) {
    println!("çªå‘æ–°é—»! {}", item.summarize());
    println!("{}", item);
}

// ä½¿ç”¨whereå­å¥çš„å¤æ‚çº¦æŸ
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
    // å‡½æ•°ä½“
}
```

ç‰¹å¾ä½œä¸ºè¿”å›ç±»å‹ï¼š

```rust
// è¿”å›å®ç°ç‰¹å¾çš„ç±»å‹
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("å½“ç„¶ï¼Œä½ äº†è§£çš„..."),
        reply: false,
        retweet: false,
    }
}

// æ³¨æ„ï¼šç›®å‰æ— æ³•ç›´æ¥è¿”å›ä¸åŒå®ç°ç›¸åŒç‰¹å¾çš„ç±»å‹
// è¿™æ ·çš„ä»£ç ä¸èƒ½ç¼–è¯‘ï¼š
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle { /*...*/ }
    } else {
        Tweet { /*...*/ } // é”™è¯¯ï¼šä¸å…¼å®¹çš„ç±»å‹
    }
}
// è§£å†³æ–¹æ³•ï¼šä½¿ç”¨ç‰¹å¾å¯¹è±¡æˆ–Box<dyn Summary>
```

#### 2.3.3 ç‰¹å¾å¯¹è±¡ä¸åŠ¨æ€åˆ†å‘

ç‰¹å¾å¯¹è±¡å…è®¸è¿è¡Œæ—¶é€‰æ‹©å…·ä½“å®ç°ï¼ˆåŠ¨æ€åˆ†å‘ï¼‰ï¼š

```rust
// å®šä¹‰ç‰¹å¾
trait Draw {
    fn draw(&self);
}

// å®ç°ç‰¹å¾
struct Button {
    label: String,
}

impl Draw for Button {
    fn draw(&self) {
        println!("ç»˜åˆ¶æŒ‰é’®: {}", self.label);
    }
}

struct Checkbox {
    label: String,
    state: bool,
}

impl Draw for Checkbox {
    fn draw(&self) {
        println!("ç»˜åˆ¶å¤é€‰æ¡†: {} {}", self.label, if self.state { "âœ“" } else { "â–¡" });
    }
}

// ä½¿ç”¨ç‰¹å¾å¯¹è±¡
struct Screen {
    components: Vec<Box<dyn Draw>>, // ç‰¹å¾å¯¹è±¡
}

impl Screen {
    fn run(&self) {
        for component in &self.components {
            component.draw();
        }
    }
}

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(Button { label: String::from("ç¡®å®š") }),
            Box::new(Checkbox { label: String::from("æ¥å—æ¡æ¬¾"), state: true }),
        ],
    };
    
    screen.run();
}
```

ç‰¹å¾å¯¹è±¡å†…å­˜å¸ƒå±€ï¼š

- ç‰¹å¾å¯¹è±¡æ˜¯**èƒ–æŒ‡é’ˆ**ï¼ŒåŒ…å«ä¸¤éƒ¨åˆ†ï¼š
  1. æŒ‡å‘å®ä¾‹æ•°æ®çš„æŒ‡é’ˆ
  2. æŒ‡å‘vtableï¼ˆè™šè¡¨ï¼‰çš„æŒ‡é’ˆ

- vtableåŒ…å«ï¼š
  1. ç±»å‹çš„Dropå®ç°
  2. ç±»å‹çš„å¤§å°å’Œå¯¹é½ä¿¡æ¯
  3. ç‰¹å¾æ–¹æ³•çš„å‡½æ•°æŒ‡é’ˆ

ç‰¹å¾å¯¹è±¡é™åˆ¶ï¼šåªæœ‰æ»¡è¶³å¯¹è±¡å®‰å…¨ï¼ˆobject safeï¼‰çš„ç‰¹å¾æ‰èƒ½å˜æˆç‰¹å¾å¯¹è±¡ã€‚ä¸€ä¸ªç‰¹å¾æ˜¯å¯¹è±¡å®‰å…¨çš„ï¼Œéœ€è¦ï¼š

1. è¿”å›å€¼ä¸æ˜¯`Self`
2. æ²¡æœ‰æ³›å‹ç±»å‹å‚æ•°
3. æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯å¯¹è±¡å®‰å…¨çš„

```rust
// ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„ç‰¹å¾
trait Clone {
    fn clone(&self) -> Self; // è¿”å›Self
}

// è¿™æ ·çš„ä»£ç æ— æ³•ç¼–è¯‘
let obj: Box<dyn Clone> = Box::new(String::from("hello")); // é”™è¯¯

// å¯¹è±¡å®‰å…¨çš„ç‰¹å¾
trait Draw {
    fn draw(&self); // æ²¡æœ‰è¿”å›Selfï¼Œæ²¡æœ‰æ³›å‹å‚æ•°
}

let obj: Box<dyn Draw> = Box::new(Button { label: "OK".to_string() }); // æœ‰æ•ˆ
```

#### 2.3.4 ç‰¹å¾ç»§æ‰¿ï¼ˆsupertraitsï¼‰

ç‰¹å¾å¯ä»¥ä¾èµ–äºå…¶ä»–ç‰¹å¾ï¼Œå½¢æˆç»§æ‰¿å…³ç³»ï¼š

```rust
// åŸºç¡€ç‰¹å¾
trait Printable {
    fn format(&self) -> String;
}

// ç»§æ‰¿ç‰¹å¾
trait PrettyPrintable: Printable {
    fn pretty_format(&self) -> String {
        format!("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ {} â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜", self.format())
    }
}

// å®ç°
struct Point {
    x: i32,
    y: i32,
}

impl Printable for Point {
    fn format(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}

impl PrettyPrintable for Point {
    // ç»§æ‰¿formatæ–¹æ³•ï¼Œå¯ä»¥é€‰æ‹©è¦†ç›–pretty_format
}

// ä½¿ç”¨
let point = Point { x: 10, y: 20 };
println!("{}", point.format());         // è¾“å‡º: (10, 20)
println!("{}", point.pretty_format());  // è¾“å‡ºæ ·å¼åŒ–æ–‡æœ¬
```

ç‰¹å¾ç»§æ‰¿ç”¨é€”ï¼š

1. **ä¸“ä¸šåŒ–ç‰¹å¾**ï¼šåŸºäºå·²æœ‰ç‰¹å¾æ·»åŠ æ›´å…·ä½“åŠŸèƒ½
2. **ä»£ç å¤ç”¨**ï¼šåœ¨å¤šä¸ªç‰¹å¾é—´å…±äº«æ–¹æ³•
3. **æ¦‚å¿µç»„ç»‡**ï¼šè¡¨è¾¾ç‰¹å¾ä¹‹é—´çš„å…³ç³»å’Œå±‚æ¬¡ç»“æ„
4. **å®‰å…¨çº¦æŸ**ï¼šè¦æ±‚åº•å±‚è¡Œä¸ºä»¥å®ç°æ›´é«˜çº§åŠŸèƒ½

å¤šé‡ç»§æ‰¿ï¼š

```rust
trait A {
    fn method_a(&self);
}

trait B {
    fn method_b(&self);
}

// Cç»§æ‰¿Aå’ŒB
trait C: A + B {
    fn method_c(&self) {
        self.method_a();
        self.method_b();
        println!("Method C");
    }
}

// å®ç°éœ€è¦æ»¡è¶³æ‰€æœ‰åŸºç¡€ç‰¹å¾
struct MyType;

impl A for MyType {
    fn method_a(&self) {
        println!("Method A");
    }
}

impl B for MyType {
    fn method_b(&self) {
        println!("Method B");
    }
}

impl C for MyType {
    // å¯é€‰æ‹©è¦†ç›–method_c
}
```

#### 2.3.5 å…³è”ç±»å‹ä¸å…³è”å¸¸é‡

å…³è”ç±»å‹æä¾›äº†ç‰¹å¾å†…éƒ¨ä½¿ç”¨çš„ç±»å‹å ä½ç¬¦ï¼š

```rust
// å¸¦å…³è”ç±»å‹çš„ç‰¹å¾
trait Iterator {
    type Item; // å…³è”ç±»å‹
    
    fn next(&mut self) -> Option<Self::Item>;
}

// å®ç°
struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32; // æŒ‡å®šå…³è”ç±»å‹
    
    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
```

å…³è”ç±»å‹ä¸æ³›å‹å‚æ•°å¯¹æ¯”ï¼š

```rust
// ä½¿ç”¨æ³›å‹å‚æ•°
trait GenericIterator<T> {
    fn next(&mut self) -> Option<T>;
}

// ä½¿ç”¨å…³è”ç±»å‹
trait AssocIterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// æ³›å‹å‚æ•°ç‰ˆæœ¬å…è®¸å¤šç§å®ç°
impl GenericIterator<u32> for Counter { /* ... */ }
impl GenericIterator<String> for Counter { /* ... */ }

// å…³è”ç±»å‹ç‰ˆæœ¬åªå…è®¸ä¸€ç§å®ç°
impl AssocIterator for Counter {
    type Item = u32;
    /* ... */
}
```

å…³è”å¸¸é‡ä¸ºç‰¹å¾æä¾›å¸¸é‡å€¼ï¼š

```rust
trait Geometry {
    // å…³è”å¸¸é‡
    const PI: f64 = 3.14159265359;
    const E: f64;  // å¿…é¡»ç”±å®ç°è€…æä¾›
    
    fn area(&self) -> f64;
}

struct Circle {
    radius: f64,
}

impl Geometry for Circle {
    const E: f64 = 2.71828;
    
    fn area(&self) -> f64 {
        Self::PI * self.radius * self.radius
    }
}

fn main() {
    let c = Circle { radius: 2.0 };
    println!("PI = {}", Circle::PI); // é€šè¿‡ç±»å‹è®¿é—®
    println!("E = {}", Circle::E);
    println!("Area = {}", c.area());
}
```

å…³è”ç±»å‹å’Œå¸¸é‡çš„ä¸»è¦ç”¨é€”ï¼š

1. **æä¾›ç±»å‹æŠ½è±¡**ï¼šå®šä¹‰ä¾èµ–ç±»å‹ä½†ä¸æŒ‡å®šå…·ä½“ç±»å‹
2. **æ”¹å–„ç±»å‹æ¨å¯¼**ï¼šç®€åŒ–å¤æ‚æ³›å‹ä»£ç 
3. **å®šä¹‰ç±»å‹å…³ç³»**ï¼šå¼ºåˆ¶å…³è”ç±»å‹åœ¨ç‰¹å¾å®ç°é—´çš„ä¸€è‡´æ€§
4. **æä¾›å¸¸é‡æŠ½è±¡**ï¼šå…è®¸åœ¨ç‰¹å¾çº§åˆ«å®šä¹‰æˆ–è¦æ±‚å¸¸é‡å€¼

#### 2.3.6 é»˜è®¤å®ç°ä¸ç‰¹å¾æ–¹æ³•è¦†ç›–

ç‰¹å¾å¯ä»¥æä¾›æ–¹æ³•çš„é»˜è®¤å®ç°ï¼š

```rust
// å¸¦é»˜è®¤å®ç°çš„ç‰¹å¾
trait Animal {
    // å¿…é¡»å®ç°çš„æ–¹æ³•
    fn name(&self) -> String;
    
    // å¸¦é»˜è®¤å®ç°çš„æ–¹æ³•
    fn talk(&self) {
        println!("{} å‘å‡ºäº†å£°éŸ³", self.name());
    }
    
    // å¤šä¸ªé»˜è®¤æ–¹æ³•å¯ä»¥ç›¸äº’è°ƒç”¨
    fn introduce(&self) {
        println!("å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯{}", self.name());
        self.talk();
    }
}

// ä½¿ç”¨é»˜è®¤å®ç°
struct Human(String);

impl Animal for Human {
    fn name(&self) -> String {
        self.0.clone()
    }
    
    // è¦†ç›–é»˜è®¤å®ç°
    fn talk(&self) {
        println!("ä½ å¥½ï¼Œæˆ‘æ˜¯{}", self.name());
    }
    
    // introduceä½¿ç”¨é»˜è®¤å®ç°ï¼Œä¼šè°ƒç”¨è¦†ç›–åçš„talk
}

// æœ€å°å®ç°
struct Cat(String);

impl Animal for Cat {
    fn name(&self) -> String {
        self.0.clone()
    }
    // å…¶ä»–æ–¹æ³•ä½¿ç”¨é»˜è®¤å®ç°
}
```

é»˜è®¤å®ç°çš„ä¼˜åŠ¿ï¼š

1. **ä¾¿åˆ©æ€§**ï¼šå‡å°‘é‡å¤ä»£ç 
2. **æ‰©å±•æ€§**ï¼šå¯ä»¥å‘ç‰¹å¾æ·»åŠ æ–¹æ³•è€Œä¸ç ´åç°æœ‰å®ç°
3. **æ¸è¿›å¼æ¥å£**ï¼šåˆ›å»ºå…·æœ‰å°æ ¸å¿ƒå’Œæ‰©å±•åŠŸèƒ½çš„API
4. **é€»è¾‘ç»„ç»‡**ï¼šå®ç°é€šç”¨è¡Œä¸ºä¸ä¸“ç”¨è¡Œä¸ºåˆ†ç¦»

ç‰¹å¾æ–¹æ³•è¦†ç›–ç­–ç•¥ï¼š

```rust
// å…¨éƒ¨ä½¿ç”¨é»˜è®¤å®ç°
struct Dog(String);

impl Animal for Dog {
    fn name(&self) -> String {
        self.0.clone()
    }
    // talkå’Œintroduceä½¿ç”¨é»˜è®¤
}

// éƒ¨åˆ†è¦†ç›–ï¼Œå¤ç”¨éƒ¨åˆ†é»˜è®¤å®ç°
struct Parrot(String);

impl Animal for Parrot {
    fn name(&self) -> String {
        self.0.clone()
    }
    
    fn talk(&self) {
        println!("{} è¯´: 'Squawk!'", self.name());
    }
    // introduceä½¿ç”¨é»˜è®¤å®ç°
}

// å®Œå…¨è¦†ç›–
struct Robot(String);

impl Animal for Robot {
    fn name(&self) -> String {
        self.0.clone()
    }
    
    fn talk(&self) {
        println!("å—¡å—¡ï¼šæˆ‘æ˜¯æœºå™¨äºº {}", self.name());
    }
    
    fn introduce(&self) {
        println!("åˆå§‹åŒ–é—®å€™æ¨¡å—...");
        println!("æœºå™¨äººæ ‡è¯†: {}", self.name());
        self.talk();
    }
}
```

#### 2.3.7 å­¤å„¿è§„åˆ™ï¼ˆorphan ruleï¼‰

å­¤å„¿è§„åˆ™è§„å®šï¼šåªèƒ½ä¸ºå®šä¹‰åœ¨å½“å‰crateä¸­çš„ç±»å‹å®ç°å½“å‰crateä¸­çš„ç‰¹å¾ã€‚

```rust
// è¿™äº›æƒ…å†µéƒ½æ˜¯åˆæ³•çš„ï¼š

// 1. ä¸ºè‡ªå·±çš„ç±»å‹å®ç°è‡ªå·±çš„ç‰¹å¾
struct MyType;
trait MyTrait {
    fn my_method(&self);
}
impl MyTrait for MyType {
    fn my_method(&self) { /* ... */ }
}

// 2. ä¸ºè‡ªå·±çš„ç±»å‹å®ç°æ ‡å‡†åº“ç‰¹å¾
impl ToString for MyType {
    fn to_string(&self) -> String {
        "MyType".to_string()
    }
}

// 3. ä¸ºæ ‡å‡†åº“ç±»å‹å®ç°è‡ªå·±çš„ç‰¹å¾
impl MyTrait for String {
    fn my_method(&self) { /* ... */ }
}

// è¿™ç§æƒ…å†µæ˜¯éæ³•çš„ï¼š
// ä¸ºæ ‡å‡†åº“ç±»å‹å®ç°æ ‡å‡†åº“ç‰¹å¾
// impl Display for Vec<i32> { /* ... */ } // ç¼–è¯‘é”™è¯¯
```

è§£å†³å­¤å„¿è§„åˆ™é™åˆ¶çš„æ¨¡å¼ï¼š

**1. æ–°ç±»å‹æ¨¡å¼**ï¼š

```rust
// ä¸ºæ ‡å‡†åº“ç±»å‹å®ç°æ ‡å‡†åº“ç‰¹å¾
struct MyVec(Vec<i32>);

impl Display for MyVec {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "MyVec: {:?}", self.0)
    }
}
```

**2. æœ¬åœ°ç‰¹å¾**ï¼š

```rust
// åˆ›å»ºæœ¬åœ°ç‰¹å¾ä½œä¸ºæ ‡å‡†åº“ç‰¹å¾çš„è¶…é›†
trait MyDisplay: Display {
    fn display_twice(&self) {
        println!("{}", self);
        println!("{}", self);
    }
}

// ä¸ºä»»ä½•å®ç°Displayçš„ç±»å‹å®ç°MyDisplay
impl<T: Display> MyDisplay for T {}
```

å­¤å„¿è§„åˆ™çš„åŸå› ï¼š

1. **é¿å…å†²çª**ï¼šé˜²æ­¢ä¸åŒcrateä¸ºåŒä¸€ç±»å‹å®ç°åŒä¸€ç‰¹å¾
2. **ç¡®ä¿ä¸€è‡´æ€§**ï¼šä¿è¯ç‰¹å¾å®ç°çš„ä¸€è‡´æ€§å’Œè¿è´¯æ€§
3. **æ˜ç¡®è´£ä»»**ï¼šæ˜ç¡®ç±»å‹æˆ–ç‰¹å¾æ‰€æœ‰è€…è´Ÿè´£å®ç°
4. **ç¨³å®šæ€§**ï¼šé˜²æ­¢ä¾èµ–æ›´æ”¹ç ´åç°æœ‰ä»£ç 

### 2.4 ç±»å‹è½¬æ¢

#### 2.4.1 å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼ˆcoercionï¼‰

å¼ºåˆ¶ç±»å‹è½¬æ¢æ˜¯ç¼–è¯‘å™¨åœ¨æŸäº›ä¸Šä¸‹æ–‡è‡ªåŠ¨åº”ç”¨çš„éšå¼è½¬æ¢ï¼š

```rust
// å¼•ç”¨å¼ºåˆ¶è½¬æ¢
let mut x: i32 = 10;
let r1: &i32 = &x;     // &i32
let r2: &i32 = &mut x; // &mut i32 -> &i32

// æ•°ç»„åˆ°åˆ‡ç‰‡è½¬æ¢
let arr: [i32; 3] = [1, 2, 3];
let slice: &[i32] = &arr; // [i32; 3] -> [i32]

// å‡½æ•°æŒ‡é’ˆè½¬æ¢
fn foo() {}
let f: fn() = foo; // å‡½æ•°é¡¹è½¬ä¸ºå‡½æ•°æŒ‡é’ˆ

// ç”Ÿå‘½å‘¨æœŸå¼ºåˆ¶è½¬æ¢
fn longer_lifetime<'a, 'b: 'a>(x: &'a str, y: &'b str) -> &'a str {
    if x.len() > y.len() { x } else { y } // &'b str -> &'a str
}
```

å¼ºåˆ¶è½¬æ¢å‘ç”Ÿçš„ä¸Šä¸‹æ–‡ï¼š

1. **èµ‹å€¼**ï¼š`let x: T = expr;`
2. **å‡½æ•°è°ƒç”¨**ï¼š`foo(expr)`ï¼Œå…¶ä¸­`expr`ç±»å‹ä¸å‚æ•°ç±»å‹ä¸å®Œå…¨åŒ¹é…
3. **æ–¹æ³•è°ƒç”¨**ï¼š`expr.method()`
4. **åŒ¹é…**ï¼š`match expr { ... }`

å¼ºåˆ¶è½¬æ¢è§„åˆ™çš„è®¾è®¡ç¡®ä¿ç±»å‹å®‰å…¨ä¸å—å½±å“ï¼Œåªå…è®¸ç»å¯¹å®‰å…¨çš„è½¬æ¢ã€‚

#### 2.4.2 asè¿ç®—ç¬¦

`as`è¿ç®—ç¬¦æä¾›æ˜¾å¼ç±»å‹è½¬æ¢ï¼š

```rust
// æ•°å€¼ç±»å‹è½¬æ¢
let a = 15i32;
let b = a as i64;   // i32 -> i64
let c = a as u32;   // i32 -> u32
let d = a as f64;   // i32 -> f64

// æº¢å‡ºè¡Œä¸º
let x = 1000i32;
let y = x as u8;    // 1000 ä¸é€‚åˆ u8ï¼Œç»“æœæ˜¯ 232 (1000 % 256)
let z = -1i32 as u32; // -1 è½¬ä¸º u32 å˜æˆ 4294967295

// æŒ‡é’ˆè½¬æ¢
let ptr = &a as *const i32;  // &T -> *const T
let val = unsafe { *ptr };   // ä½¿ç”¨åŸå§‹æŒ‡é’ˆéœ€è¦unsafe

// enumè½¬æ¢ä¸ºæ•´æ•°
enum Color { Red, Green, Blue }
let red_value = Color::Red as u32;  // è½¬æ¢ä¸ºåˆ¤åˆ«å¼å€¼ (0)
```

`as`è½¬æ¢çš„è§„åˆ™å’Œé™åˆ¶ï¼š

1. **æ•°å€¼ç±»å‹è½¬æ¢**ï¼šä»»ä½•æ•°å€¼ç±»å‹å¯è½¬æ¢ä¸ºä»»ä½•å…¶ä»–æ•°å€¼ç±»å‹
2. **æº¢å‡ºæˆªæ–­**ï¼šè¶…å‡ºç›®æ ‡ç±»å‹èŒƒå›´çš„å€¼ä¼šè¢«æˆªæ–­/ç¯ç»•
3. **æŒ‡é’ˆè½¬æ¢**ï¼šæŒ‡é’ˆç±»å‹é—´å¯ä»¥è½¬æ¢
4. **å†…å­˜å®‰å…¨**ï¼š`as`ä¸ä¿è¯å†…å­˜å®‰å…¨ï¼ŒæŸäº›è½¬æ¢å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸º
5. **æšä¸¾è½¬æ¢**ï¼šæ— æ•°æ®çš„æšä¸¾å˜ä½“å¯è½¬æ¢ä¸ºæ•´æ•°
6. **å—é™èŒƒå›´**ï¼šå¹¶éä»»æ„ç±»å‹éƒ½å¯ä»¥ç”¨`as`è½¬æ¢ï¼ˆå¦‚ç»“æ„ä½“é—´è½¬æ¢ï¼‰

å®‰å…¨ä½¿ç”¨`as`çš„æœ€ä½³å®è·µï¼š

```rust
// æ‰©å±•è½¬æ¢ï¼ˆå®‰å…¨ï¼‰
let small: i32 = 42;
let big: i64 = small as i64;

// å¯èƒ½ä¸¢å¤±ä¿¡æ¯çš„è½¬æ¢ï¼ˆå°å¿ƒï¼‰
let big: i64 = 1_000_000;
let small: i32 = big as i32; // å¦‚æœbig > i32::MAXï¼Œä¼šå‘ç”Ÿæˆªæ–­

// æŒ‡é’ˆè½¬æ¢ï¼ˆéœ€è¦unsafeä½¿ç”¨ï¼‰
let value: i32 = 42;
let ptr = &value as *const i32;
let raw_value = unsafe { *ptr };

// ä½¿ç”¨ä¸“ç”¨æ–¹æ³•è€Œéasè¿›è¡Œå¯èƒ½å¤±è´¥çš„è½¬æ¢
let s = "42";
let n: i32 = s.parse().expect("éæ•°å­—");
```

#### 2.4.3 From/Intoç‰¹å¾

`From`å’Œ`Into`ç‰¹å¾æä¾›äº†ç±»å‹é—´è½¬æ¢çš„æ ‡å‡†æ–¹æ³•ï¼š

```rust
// Fromç‰¹å¾
trait From<T> {
    fn from(value: T) -> Self;
}

// Intoç‰¹å¾
trait Into<T> {
    fn into(self) -> T;
}

// æ ‡å‡†å®ç°ï¼šå¦‚æœå®ç°äº†Fromï¼Œè‡ªåŠ¨è·å¾—Into
// å½“T: From<U>æ—¶ï¼ŒUè‡ªåŠ¨å®ç°Into<T>

// è‡ªå®šä¹‰ç±»å‹è½¬æ¢
struct Number {
    value: i32,
}

// å®ç°From
impl From<i32> for Number {
    fn from(value: i32) -> Self {
        Number { value }
    }
}

// ä½¿ç”¨From/Into
let num1 = Number::from(42);  // ä½¿ç”¨From
let num2: Number = 42.into(); // ä½¿ç”¨Into
```

From/Intoçš„ä¼˜åŠ¿ï¼š

1. **æ ‡å‡†åŒ–**ï¼šæä¾›ä¸€è‡´çš„è½¬æ¢æ¥å£
2. **ç±»å‹å®‰å…¨**ï¼šè½¬æ¢åœ¨ç¼–è¯‘æ—¶éªŒè¯
3. **åŒå‘ç‰¹æ€§**ï¼šå®ç°Fromè‡ªåŠ¨è·å¾—Into
4. **é“¾å¼è½¬æ¢**ï¼šå¤šä¸ªè½¬æ¢å¯ä»¥ç»„åˆ
5. **å¯å¤±è´¥è½¬æ¢çš„æ›¿ä»£å“**ï¼šå¯¹åº”TryFrom/TryInto

å¸¸è§çš„Fromå®ç°ï¼š

```rust
// String from &str
let string = String::from("hello");

// Vec from array
let vec = Vec::from([1, 2, 3]);

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
struct AppError {
    kind: String,
    message: String,
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError {
            kind: "IO".to_string(),
            message: error.to_string(),
        }
    }
}

```rust
// é”™è¯¯ä¼ æ’­ä¸­ä½¿ç”¨From
fn read_file() -> Result<String, AppError> {
    let content = std::fs::read_to_string("file.txt")?; // io::Errorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    Ok(content)
}
```

æ ‡å‡†åº“ä¸­çš„å¸¸è§è½¬æ¢å®ç°ï¼š

```rust
// å­—ç¬¦ä¸²è½¬æ¢
let s1: String = "hello".into();
let s2 = String::from("world");

// æ•°å€¼è½¬æ¢
let n1: f64 = 42i32.into();
let n2 = f64::from(42i32);

// é›†åˆè½¬æ¢
let v: Vec<i32> = [1, 2, 3].into();
let v2 = Vec::from([1, 2, 3]);

// æ™ºèƒ½æŒ‡é’ˆè½¬æ¢
let b: Box<i32> = Box::from(42);
let r: Rc<String> = Rc::from("shared data".to_string());
```

From/Intoç”¨äºæ³›å‹çº¦æŸï¼š

```rust
// å…è®¸ä»»ä½•å¯è½¬æ¢ä¸ºStringçš„ç±»å‹
fn print_info<T: Into<String>>(info: T) {
    let info_string = info.into();
    println!("ä¿¡æ¯: {}", info_string);
}

// ä½¿ç”¨
print_info("å­—ç¬¦ä¸²å­—é¢é‡");
print_info(String::from("å·²æœ‰å­—ç¬¦ä¸²"));
print_info('c'); // å­—ç¬¦ä¹Ÿå¯ä»¥è½¬æ¢ä¸ºString
```

#### 2.4.4 TryFrom/TryIntoç‰¹å¾

`TryFrom`å’Œ`TryInto`æ˜¯`From`å’Œ`Into`çš„å¯å¤±è´¥ç‰ˆæœ¬ï¼š

```rust
// TryFromç‰¹å¾
trait TryFrom<T> {
    type Error;
    fn try_from(value: T) -> Result<Self, Self::Error>;
}

// TryIntoç‰¹å¾
trait TryInto<T> {
    type Error;
    fn try_into(self) -> Result<T, Self::Error>;
}

// å®ç°TryFrom
use std::convert::TryFrom;
use std::num::TryFromIntError;

struct PositiveNumber(i32);

impl TryFrom<i32> for PositiveNumber {
    type Error = &'static str;
    
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value >= 0 {
            Ok(PositiveNumber(value))
        } else {
            Err("ä¸èƒ½åˆ›å»ºè´Ÿæ•°çš„PositiveNumber")
        }
    }
}

// ä½¿ç”¨
fn main() -> Result<(), &'static str> {
    // ä½¿ç”¨TryFrom
    let pos = PositiveNumber::try_from(42)?;
    
    // ä½¿ç”¨TryInto
    let num: i32 = 42;
    let pos: PositiveNumber = num.try_into()?;
    
    // æ ‡å‡†åº“çš„ä¾‹å­
    let large: i64 = 1000;
    let small: i32 = large.try_into().expect("è½¬æ¢å¤±è´¥ï¼Œå€¼å¤ªå¤§");
    
    Ok(())
}
```

TryFrom/TryIntoçš„ä¸»è¦ç”¨é€”ï¼š

1. **éªŒè¯è½¬æ¢**ï¼šç¡®ä¿ç”Ÿæˆçš„å€¼æ»¡è¶³ç‰¹å®šæ¡ä»¶
2. **æ•è·å¤±è´¥**ï¼šå¤„ç†å¯èƒ½å¤±è´¥çš„è½¬æ¢ï¼Œè€Œä¸æ˜¯æº¢å‡ºæˆ–æˆªæ–­
3. **ç±»å‹åè®®**ï¼šå»ºç«‹ç±»å‹é—´çš„å®‰å…¨è½¬æ¢åè®®
4. **æ›´å¼ºçš„ç±»å‹ä¿è¯**ï¼šåœ¨è½¬æ¢æ—¶å¢åŠ ä¸šåŠ¡è§„åˆ™çº¦æŸ

æ ‡å‡†åº“ä¸­çš„ä¾‹å­ï¼š

```rust
// å­—ç¬¦ä¸²è§£æ
let s = "42";
let n: i32 = s.parse().unwrap(); // å†…éƒ¨ä½¿ç”¨FromStrï¼Œç±»ä¼¼TryFrom

// æ•´æ•°ç±»å‹é—´çš„å®‰å…¨è½¬æ¢
let large = 1000i64;
let result = i8::try_from(large); // è¿”å›Errï¼Œå› ä¸º1000è¶…å‡ºi8èŒƒå›´
assert!(result.is_err());

// åˆ‡ç‰‡è½¬æ•°ç»„
let slice: &[i32] = &[1, 2, 3, 4];
let array: [i32; 4] = slice.try_into().unwrap(); // æˆåŠŸï¼Œé•¿åº¦åŒ¹é…
let result = <[i32; 3]>::try_from(slice); // é”™è¯¯ï¼Œé•¿åº¦ä¸åŒ¹é…
assert!(result.is_err());
```

#### 2.4.5 Derefå¼ºåˆ¶è½¬æ¢

`Deref`ç‰¹å¾å…è®¸è‡ªå®šä¹‰è§£å¼•ç”¨è¡Œä¸ºï¼Œå®ç°æ™ºèƒ½æŒ‡é’ˆå’Œè‡ªåŠ¨è½¬æ¢ï¼š

```rust
// Derefç‰¹å¾å®šä¹‰
trait Deref {
    type Target;
    fn deref(&self) -> &Self::Target;
}

// å®ç°è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// ä½¿ç”¨
fn main() {
    let x = 5;
    let y = MyBox::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y); // è§£å¼•ç”¨MyBox
    
    // Derefå¼ºåˆ¶è½¬æ¢
    let name = MyBox::new(String::from("Rust"));
    // &MyBox<String> -> &String -> &str
    hello(&name); // è‡ªåŠ¨è§£å¼•ç”¨
}

fn hello(name: &str) {
    println!("ä½ å¥½ï¼Œ{}ï¼", name);
}
```

Derefå¼ºåˆ¶è½¬æ¢é“¾ï¼š

```rust
fn main() {
    // å¼ºåˆ¶è½¬æ¢é“¾ä¾‹å­
    let s = Box::new(String::from("Hello"));
    
    // &Box<String> -> &String -> &str
    let slice: &str = &s;
    
    // ä»¥ä¸‹è½¬æ¢ä¼šè‡ªåŠ¨å‘ç”Ÿ
    // &s ç±»å‹æ˜¯ &Box<String>
    // é€šè¿‡ Deref å˜æˆ &String
    // å†é€šè¿‡ Stringçš„Deref å˜æˆ &str
}
```

Derefå¼ºåˆ¶è½¬æ¢è§„åˆ™ï¼š

1. ä»`&T`åˆ°`&U`ï¼Œå½“`T: Deref<Target=U>`
2. ä»`&mut T`åˆ°`&mut U`ï¼Œå½“`T: DerefMut<Target=U>`
3. ä»`&mut T`åˆ°`&U`ï¼Œå½“`T: Deref<Target=U>`ï¼ˆå¯ä»¥ä»å¯å˜å€Ÿç”¨è½¬ä¸ºä¸å¯å˜å€Ÿç”¨ï¼‰

æ ‡å‡†åº“ä¸­çš„Derefå®ç°ï¼š

```rust
// Box<T> -> T
let boxed = Box::new(5);
let value = *boxed; // ç­‰åŒäº *(boxed.deref())

// String -> str
let s = String::from("hello");
let len = s.len(); // é€šè¿‡Derefè°ƒç”¨strçš„æ–¹æ³•
```

Derefå¼ºåˆ¶è½¬æ¢çš„ä¸»è¦ç”¨ä¾‹ï¼š

1. **æ™ºèƒ½æŒ‡é’ˆ**ï¼šå®ç°ç±»ä¼¼å¼•ç”¨çš„è¡Œä¸º
2. **è‡ªåŠ¨å€Ÿç”¨**ï¼šç®€åŒ–APIè®¾è®¡å’Œä½¿ç”¨
3. **ç±»å‹é€‚é…**ï¼šåˆ›å»ºåŒ…è£…ç±»å‹æ—¶ä¿æŒåŸæœ‰æ¥å£
4. **æ— ç¼ä½¿ç”¨**ï¼šå…è®¸ç”¨æˆ·æ— éœ€æ˜¾å¼è½¬æ¢å³å¯ä½¿ç”¨å†…éƒ¨ç±»å‹

### 2.5 é«˜çº§ç±»å‹ç³»ç»Ÿç‰¹æ€§

#### 2.5.1 é«˜çº§ç‰¹å¾çº¦æŸ

é«˜çº§ç‰¹å¾çº¦æŸæä¾›æ›´ç»†ç²’åº¦çš„ç±»å‹é™åˆ¶ï¼š

```rust
// å…³è”ç±»å‹çº¦æŸ
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

fn process<I>(iter: I)
    where I: Iterator,
          I::Item: Debug    // çº¦æŸå…³è”ç±»å‹
{
    for item in iter {
        println!("{:?}", item);
    }
}

// å¤šé‡ç‰¹å¾çº¦æŸ
fn complex_function<T>(item: T)
    where T: Clone + Debug + PartialEq + Send
{
    // å¯ä»¥ä½¿ç”¨æ‰€æœ‰è¿™äº›ç‰¹å¾çš„åŠŸèƒ½
}

// é«˜çº§whereå­å¥
fn process_pairs<T, U>(t: T, u: U)
    where T: Display,
          T::Item: AsRef<str>,  // çº¦æŸå…³è”ç±»å‹
          for<'a> U: Fn(&'a i32) -> bool,  // é«˜é˜¶ç”Ÿå‘½å‘¨æœŸçº¦æŸ
          U: Copy
{
    // å‡½æ•°ä½“
}
```

çº¦æŸèŒƒå›´ç‰¹å¾ç­¾åï¼ˆé«˜çº§ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼‰ï¼š

```rust
// é«˜é˜¶ç”Ÿå‘½å‘¨æœŸçº¦æŸ
fn call_twice<F>(f: F)
    where F: for<'a> Fn(&'a str) -> bool
{
    let result1 = f("hello");
    let result2 = f("world");
    println!("{} {}", result1, result2);
}

// ä½¿ç”¨
let check_empty = |s: &str| s.is_empty();
call_twice(check_empty);
```

å—çº¦æŸçš„å…³è”ç±»å‹ï¼š

```rust
trait Container {
    type Item;
    fn get(&self) -> Option<&Self::Item>;
}

// çº¦æŸå…³è”ç±»å‹å¿…é¡»å®ç°Display
fn print<C>(container: C)
    where C: Container,
          C::Item: Display
{
    if let Some(item) = container.get() {
        println!("{}", item);
    }
}
```

è¿ç®—ç¬¦ç‰¹å¾çº¦æŸï¼š

```rust
use std::ops::Add;

fn sum<T: Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// æ›´å¤æ‚çš„æ“ä½œç¬¦çº¦æŸ
fn complex_math<T>(a: T, b: T) -> T
    where T: Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T>
{
    (a + b) * (a - b) / b
}
```

#### 2.5.2 ç±»å‹å˜å‹ï¼ˆvarianceï¼‰

å˜å‹æè¿°äº†ç±»å‹å…³ç³»åœ¨æ³›å‹ä¸Šä¸‹æ–‡ä¸­çš„ä¼ é€’æ€§ï¼š

```rust
// åå˜ï¼ˆCovariantï¼‰ï¼šå¦‚æœAæ˜¯Bçš„å­ç±»å‹ï¼Œåˆ™F<A>æ˜¯F<B>çš„å­ç±»å‹
// åœ¨Rustä¸­ï¼Œå¼•ç”¨&Tå…³äºTæ˜¯åå˜çš„

// ç¤ºä¾‹ï¼šç”Ÿå‘½å‘¨æœŸåå˜
fn example<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
    where 'b: 'a // 'bæ¯”'aæ´»å¾—é•¿
{
    if x.len() > y.len() {
        x
    } else {
        y // å°†&'b strè½¬æ¢ä¸º&'a stræ˜¯å®‰å…¨çš„ï¼Œå› ä¸º'bæ¯”'aé•¿
    }
}

// é€†å˜ï¼ˆContravariantï¼‰ï¼šå¦‚æœAæ˜¯Bçš„å­ç±»å‹ï¼Œåˆ™F<B>æ˜¯F<A>çš„å­ç±»å‹
// åœ¨Rustä¸­ï¼Œå‡½æ•°å‚æ•°æ˜¯é€†å˜çš„

// ç¤ºä¾‹ï¼šå‡½æ•°å‚æ•°é€†å˜
fn process<F>(f: F)
    where F: Fn(&'static str) // æ¥å—å¼•ç”¨é™æ€ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°
{
    let local = String::from("hello");
    // å¯ä»¥ä¼ é€’æ¥å—æ›´çŸ­ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°
    process_impl(f);
}

fn process_impl<F>(f: F)
    where F: Fn(&str) // æ¥å—ä»»ä½•ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
{
    f("hello");
}

// ä¸å˜ï¼ˆInvariantï¼‰ï¼šæ²¡æœ‰å­ç±»å‹å…³ç³»
// åœ¨Rustä¸­ï¼Œ&mut Tæ˜¯å…³äºTä¸å˜çš„

// ç¤ºä¾‹ï¼šå¯å˜å¼•ç”¨çš„ä¸å˜æ€§
fn invalid<'a, 'b>(x: &'a mut i32, y: &'b mut i32)
    where 'b: 'a // 'bæ¯”'aé•¿
{
    // ä¸‹é¢çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼Œä¸èƒ½å°†&'b mut i32è½¬æ¢ä¸º&'a mut i32
    // let z: &'a mut i32 = y;
}
```

å˜å‹åœ¨å®é™…æ³›å‹ç±»å‹ä¸­ï¼š

```rust
// Box<T>æ˜¯å…³äºTåå˜çš„
let long_lived = String::from("long lived");
let long_box: Box<String> = Box::new(long_lived);
// ç”Ÿå‘½å‘¨æœŸï¼š'long -> String -> &'static str
let static_box: Box<&'static str> = Box::new("static str");

// å‡½æ•°ä¸­çš„å˜å‹
type ShortStringFn = dyn Fn(&'static str) -> bool;
type LongStringFn = dyn Fn(&str) -> bool;

// å‡½æ•°å‚æ•°æ˜¯é€†å˜çš„ï¼Œæ‰€ä»¥æ¥å—'staticçš„å‡½æ•°å¯ä»¥ä½¿ç”¨æ›´çŸ­ç”Ÿå‘½å‘¨æœŸ
fn accepts_static_fn(f: &ShortStringFn) {
    f("hello");
}

fn use_any_fn(f: &LongStringFn) {
    // é”™è¯¯ï¼šLongStringFnä¸èƒ½è½¬æ¢ä¸ºShortStringFn
    // accepts_static_fn(f);
}
```

åœ¨è‡ªå®šä¹‰ç±»å‹ä¸­æ§åˆ¶å˜å‹ï¼š

```rust
use std::marker::PhantomData;

// åå˜ä¾‹å­
struct Covariant<T>(PhantomData<T>);

// é€†å˜ä¾‹å­ï¼ˆä½¿ç”¨å‡½æ•°æŒ‡é’ˆï¼‰
struct Contravariant<T>(PhantomData<fn(T)>);

// ä¸å˜ä¾‹å­
struct Invariant<T>(PhantomData<fn(T) -> T>);

// åº”ç”¨ï¼šåˆ›å»ºç±»å‹å®‰å…¨çš„IDç±»å‹
struct Id<T> {
    id: u64,
    _marker: PhantomData<T>,
}

impl<T> Id<T> {
    fn new(id: u64) -> Self {
        Id { id, _marker: PhantomData }
    }
}

// UserIdå’ŒProductIdæ˜¯ä¸åŒç±»å‹ï¼Œæ— æ³•äº’æ¢
type UserId = Id<User>;
type ProductId = Id<Product>;
```

#### 2.5.3 å­˜åœ¨ç±»å‹ï¼ˆimpl Traitï¼‰

`impl Trait`è¯­æ³•æä¾›äº†ä¸€ç§ä¸æŒ‡å®šå…·ä½“ç±»å‹çš„æ–¹å¼æ¥è¡¨è¾¾ç±»å‹ï¼š

```rust
// è¿”å›ä½ç½®çš„impl Traitï¼ˆå­˜åœ¨ç±»å‹ï¼‰
fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}

// è¿”å›è¿­ä»£å™¨ï¼Œä¸æŒ‡æ˜å…·ä½“ç±»å‹
fn fibonacci(n: usize) -> impl Iterator<Item = u64> {
    let mut a = 0;
    let mut b = 1;
    std::iter::from_fn(move || {
        if n == 0 {
            return None;
        }
        
        let c = a + b;
        a = b;
        b = c;
        
        Some(a)
    })
}

// åœ¨å‚æ•°ä½ç½®çš„impl Traitï¼ˆä»»ä½•å®ç°ç‰¹å®šç‰¹å¾çš„ç±»å‹ï¼‰
fn process(item: impl Display + Clone) {
    let copy = item.clone();
    println!("Item: {}", item);
    println!("Copy: {}", copy);
}
```

`impl Trait`çš„ä¸»è¦ç‰¹ç‚¹ï¼š

**åœ¨è¿”å›ä½ç½®**ï¼š

- éšè—å…·ä½“ç±»å‹ï¼Œåªå…¬å¼€å¿…è¦æ¥å£
- å…è®¸è¿”å›æ— æ³•å‘½åçš„ç±»å‹ï¼ˆå¦‚é—­åŒ…ã€å¤æ‚è¿­ä»£å™¨ï¼‰
- ç®€åŒ–ç­¾åï¼Œå°¤å…¶æ˜¯å¯¹å¤æ‚ç»„åˆç±»å‹
- é™åˆ¶ï¼šå‡½æ•°å†…éƒ¨å¿…é¡»è¿”å›å•ä¸€å…·ä½“ç±»å‹

```rust
// è¿”å›å¤æ‚è¿­ä»£å™¨ç±»å‹çš„ç®€åŒ–
fn complex_transformation(data: Vec<i32>) -> impl Iterator<Item = String> {
    data.into_iter()
        .filter(|x| x % 2 == 0)
        .map(|x| x * 2)
        .map(|x| format!("item: {}", x))
}

// æ— æ³•å‘½åçš„é—­åŒ…ç±»å‹
fn make_incrementor(step: i32) -> impl Fn(i32) -> i32 {
    move |x| x + step
}
```

**åœ¨å‚æ•°ä½ç½®**ï¼š

- ä½œä¸ºæ³›å‹å‚æ•°çš„ç®€åŒ–è¯­æ³•
- ä¸æ”¯æŒè¿”å›ç›¸åŒç‰¹å¾çš„ä¸åŒå…·ä½“ç±»å‹

```rust
// impl Traitä½œä¸ºå‚æ•°æ˜¯æ³›å‹çš„è¯­æ³•ç³–
fn process(item: impl Display) {
    println!("{}", item);
}

// ç­‰ä»·äºï¼š
fn process<T: Display>(item: T) {
    println!("{}", item);
}
```

`impl Trait`çš„é™åˆ¶ï¼š

```rust
// ä¸èƒ½è¿”å›ä¸åŒçš„å…·ä½“ç±»å‹
fn returns_string_or_vector(condition: bool) -> impl Display {
    if condition {
        "hello".to_string() // è¿”å›String
    } else {
        // vec![1, 2, 3] // é”™è¯¯ï¼šä¸èƒ½è¿”å›ä¸åŒç±»å‹
        "world".to_string() // å¿…é¡»æ˜¯ç›¸åŒç±»å‹
    }
}

// è§£å†³æ–¹æ³•ï¼šä½¿ç”¨ç‰¹å¾å¯¹è±¡
fn returns_different_types(condition: bool) -> Box<dyn Display> {
    if condition {
        Box::new("hello".to_string())
    } else {
        Box::new(vec![1, 2, 3]) // ç°åœ¨å¯ä»¥äº†
    }
}
```

#### 2.5.4 é«˜çº§ç±»å‹åˆ«å

ç±»å‹åˆ«åå¯ä»¥ç®€åŒ–å¤æ‚ç±»å‹ï¼Œæé«˜ä»£ç å¯è¯»æ€§ï¼š

```rust
// åŸºæœ¬ç±»å‹åˆ«å
type Result<T> = std::result::Result<T, std::io::Error>;

// å¤æ‚æ³›å‹ç±»å‹åˆ«å
type HashMap<K, V> = std::collections::HashMap<K, V, std::collections::hash_map::RandomState>;

// å‡½æ•°æŒ‡é’ˆç±»å‹åˆ«å
type OperationFn = fn(i32, i32) -> i32;

fn apply_operation(a: i32, b: i32, op: OperationFn) -> i32 {
    op(a, b)
}

// é—­åŒ…ç±»å‹åˆ«åï¼ˆé€šè¿‡æ³›å‹ï¼‰
type Callback<T> = Box<dyn Fn(T) -> bool>;

fn register_callback<T>(cb: Callback<T>) {
    // ...
}

// å¤æ‚ç‰¹å¾çº¦æŸåˆ«åï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼‰
// éœ€è¦useç‰¹å¾åˆ«åç‰¹æ€§
trait Shorthand = Clone + Debug + PartialEq;

fn complex_function<T: Shorthand>(item: T) {
    // ...
}
```

åµŒå¥—å’Œé€’å½’ç±»å‹åˆ«åï¼š

```rust
// åµŒå¥—ç±»å‹åˆ«å
type IntVec = Vec<i32>;
type IntVecVec = Vec<IntVec>;

// éƒ¨åˆ†é€’å½’ç±»å‹åˆ«å
type NodeRef<T> = Option<Box<Node<T>>>;

struct Node<T> {
    value: T,
    left: NodeRef<T>,
    right: NodeRef<T>,
}
```

å…³è”ç±»å‹åˆ«åï¼š

```rust
trait Container {
    type Item;
    
    // å…³è”ç±»å‹åˆ«å
    type ItemRef<'a> where Self: 'a = &'a Self::Item;
    
    fn get<'a>(&'a self, index: usize) -> Option<Self::ItemRef<'a>>;
}
```

ç±»å‹åˆ«åçš„é«˜çº§åº”ç”¨ï¼š

```rust
// APIç®€åŒ–
type ConnectionPool = Arc<Mutex<Vec<Connection>>>;

// è¿”å›ç±»å‹ç®€åŒ–
type BoxFuture<T> = Pin<Box<dyn Future<Output = T>>>;

async fn complex_operation() -> BoxFuture<Result<(), Error>> {
    // ...
}

// æé«˜ç±»å‹å®‰å…¨
type UserId = u64;
type ProductId = u64;

fn get_user(id: UserId) -> User { /* ... */ }
fn get_product(id: ProductId) -> Product { /* ... */ }

// è™½ç„¶UserIdå’ŒProductIdéƒ½æ˜¯u64ï¼Œ
// ä½†æ˜ç¡®çš„ç±»å‹åä½¿ä»£ç æ›´æ˜“è¯»å’Œç»´æŠ¤
```

#### 2.5.5 é«˜çº§æ³›å‹çº¦æŸï¼ˆwhereå­å¥ï¼‰

`where`å­å¥å…è®¸ç¼–å†™æ›´å¤æ‚ã€æ›´æ¸…æ™°çš„æ³›å‹çº¦æŸï¼š

```rust
// åŸºæœ¬whereå­å¥
fn print<T>(value: T)
    where T: Display
{
    println!("{}", value);
}

// å¤æ‚çº¦æŸ
fn process<T, U>(t: T, u: U)
    where T: Display + Clone,
          U: Clone + Debug
{
    // å‡½æ•°ä½“
}

// å¤šè¡Œçº¦æŸæé«˜å¯è¯»æ€§
fn complex_function<T, U, V>(t: T, u: U, v: V) -> i32
    where T: Display + Clone + Debug,
          U: Clone + Debug + PartialEq + Default,
          V: Copy + Ord
{
    // å‡½æ•°ä½“
}
```

Whereå­å¥çš„é«˜çº§ç”¨æ³•ï¼š

çº¦æŸå…³è”ç±»å‹

```rust
fn process_items<I>(iter: I)
    where I: Iterator,
          I::Item: Display
{
    for item in iter {
        println!("{}", item);
    }
}
```

æ¶‰åŠå¤šä¸ªç±»å‹å‚æ•°çš„çº¦æŸ

```rust
fn compare<T, U>(t: T, u: U) -> bool
    where T: PartialEq<U>
{
    t == u
}
```

é«˜é˜¶ç‰¹å¾çº¦æŸï¼ˆHRTBï¼‰

```rust
fn call_on_ref<F>(f: F)
    where F: for<'a> Fn(&'a i32)
{
    let local = 42;
    f(&local);
}
```

ç±»å‹ç›¸ç­‰çº¦æŸ

```rust
// è¦æ±‚ä¸¤ä¸ªå…³è”ç±»å‹ç›¸åŒ
fn process<T, U>(t: T, u: U)
    where T: Iterator,
          U: Iterator<Item = T::Item>
{
    // å¤„ç†å…·æœ‰ç›¸åŒé¡¹ç±»å‹çš„ä¸¤ä¸ªè¿­ä»£å™¨
}
```

å­ç‰¹å¾çº¦æŸ

```rust
trait Base {
    fn base_method(&self);
}

trait Derived: Base {
    fn derived_method(&self);
}

fn call_both<T>(item: T)
    where T: Derived
{
    // å¯ä»¥è°ƒç”¨Baseå’ŒDerivedçš„æ–¹æ³•
    item.base_method();
    item.derived_method();
}
```

çº¦æŸå…·ä½“ç±»å‹

```rust
// çº¦æŸVec<T>è€Œä¸ä»…ä»…æ˜¯T
fn sort_vec<T>(mut vec: Vec<T>) -> Vec<T>
    where Vec<T>: Debug,
          T: Ord
{
    vec.sort();
    println!("Sorted: {:?}", vec);
    vec
}
```

Whereå­å¥ä¸æ™®é€šçº¦æŸçš„æ¯”è¾ƒï¼š

```rust
// æ™®é€šçº¦æŸï¼ˆä½¿ç”¨å†’å·ï¼‰
fn process<T: Clone + Debug, U: Default + Display>(t: T, u: U) {
    // ...
}

// ç­‰ä»·çš„whereå­å¥
fn process<T, U>(t: T, u: U)
    where T: Clone + Debug,
          U: Default + Display
{
    // ...
}
```

Whereå­å¥çš„ä¼˜åŠ¿ï¼š

1. **å¯è¯»æ€§**ï¼šå¯¹äºå¤šä¸ªå’Œå¤æ‚çš„çº¦æŸæ›´æ¸…æ™°
2. **è¡¨è¾¾èƒ½åŠ›**ï¼šå¯ä»¥è¡¨è¾¾æ›´å¤æ‚çš„çº¦æŸå…³ç³»
3. **å…³è”ç±»å‹çº¦æŸ**ï¼šå…è®¸çº¦æŸå…³è”ç±»å‹
4. **é«˜é˜¶ç‰¹å¾ç»‘å®š**ï¼šæ”¯æŒfor<'a>è¯­æ³•

#### 2.5.6 æ³›å‹å…³è”ç±»å‹ï¼ˆGATï¼‰

æ³›å‹å…³è”ç±»å‹ï¼ˆGeneric Associated Typesï¼ŒGATï¼‰å…è®¸åœ¨å…³è”ç±»å‹ä¸­ä½¿ç”¨æ³›å‹å‚æ•°ï¼š

```rust
// åŸºæœ¬çš„æ³›å‹å…³è”ç±»å‹
trait Container {
    type Item<'a> where Self: 'a;
    
    fn get<'a>(&'a self, index: usize) -> Option<Self::Item<'a>>;
}

// å®ç°ç¤ºä¾‹
struct VecContainer<T>(Vec<T>);

impl<T> Container for VecContainer<T> {
    type Item<'a> where Self: 'a = &'a T;
    
    fn get<'a>(&'a self, index: usize) -> Option<Self::Item<'a>> {
        self.0.get(index)
    }
}

// å¸¦ç”Ÿå‘½å‘¨æœŸçš„å®ç°
struct OwnedContainer<T>(Vec<T>);

impl<T: Clone> Container for OwnedContainer<T> {
    type Item<'a> where Self: 'a = T; // è¿”å›æ‹¥æœ‰çš„ç±»å‹
    
    fn get<'a>(&'a self, index: usize) -> Option<Self::Item<'a>> {
        self.0.get(index).cloned()
    }
}
```

å¸¦å¤šä¸ªæ³›å‹å‚æ•°çš„GATï¼š

```rust
trait AdvancedContainer {
    type Item<'a, T> where Self: 'a;
    
    fn get<'a, T>(&'a self, key: T) -> Option<Self::Item<'a, T>>;
}

// å®ç°
struct Map<K, V>(HashMap<K, V>);

impl<K: Eq + Hash, V> AdvancedContainer for Map<K, V> {
    type Item<'a, T> where Self: 'a = &'a V;
    
    fn get<'a, T>(&'a self, key: T) -> Option<Self::Item<'a, T>>
    where
        T: Borrow<K>,
    {
        self.0.get(key.borrow())
    }
}
```

GATä¸ç‰¹å¾å¯¹è±¡ï¼š

```rust
trait Stream {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// ä½¿ç”¨GATå®ç°å€Ÿç”¨è¿­ä»£å™¨
impl<'s, T> Stream for std::slice::Iter<'s, T> {
    type Item<'a> where Self: 'a = &'s T;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        std::slice::Iter::next(self)
    }
}

// ä½¿ç”¨GATçš„å‡½æ•°
fn process_stream<S: Stream>(stream: &mut S) {
    while let Some(item) = stream.next() {
        // å¤„ç†item
    }
}
```

GATä¸é«˜çº§ç±»å‹å…³ç³»ï¼š

```rust
// æ˜ å°„å™¨ç‰¹å¾
trait Mapper {
    type Input;
    type Output<T>; // æ³›å‹å…³è”ç±»å‹
    
    fn map<T>(&self, input: Self::Input) -> Self::Output<T>
    where
        Self::Input: Into<T>;
}

// IDæ˜ å°„å™¨å®ç°
struct IdMapper;

impl Mapper for IdMapper {
    type Input = String;
    type Output<T> = T;
    
    fn map<T>(&self, input: Self::Input) -> Self::Output<T>
    where
        Self::Input: Into<T>,
    {
        input.into()
    }
}
```

GATçš„ä¸»è¦ç”¨é€”ï¼š

1. **å€Ÿç”¨è¿­ä»£å™¨**ï¼šåˆ›å»ºè¿”å›å¼•ç”¨çš„è¿­ä»£å™¨
2. **æ³›å‹å®¹å™¨**ï¼šå®šä¹‰è¿”å›å®¹å™¨å†…éƒ¨å¼•ç”¨çš„æ¥å£
3. **çŠ¶æ€æœº**ï¼šå®šä¹‰ä¸çŠ¶æ€ç›¸å…³çš„å…³è”ç±»å‹
4. **é«˜çº§ç±»å‹è½¬æ¢**ï¼šå®šä¹‰ä¾èµ–äºå®ç°æˆ–æ³›å‹çš„è½¬æ¢
5. **çµæ´»APIè®¾è®¡**ï¼šå¢å¼ºç‰¹å¾çš„è¡¨è¾¾èƒ½åŠ›

#### 2.5.7 ç‰¹å¾åˆ«åï¼ˆtrait aliasesï¼‰

ç‰¹å¾åˆ«åæä¾›äº†å®šä¹‰å¤šä¸ªç‰¹å¾ç»„åˆçš„ç®€ä¾¿æ–¹å¼ï¼š

```rust
// åŸºæœ¬ç‰¹å¾åˆ«å
trait Printable = Display + Debug;

// ä½¿ç”¨ç‰¹å¾åˆ«å
fn print<T: Printable>(value: T) {
    println!("Display: {}", value);
    println!("Debug: {:?}", value);
}

// å¤æ‚ç‰¹å¾åˆ«å
trait WebComponent = Display + Clone + Default + 'static;

// ä½¿ç”¨å¤æ‚åˆ«å
fn render<T: WebComponent>(component: T) {
    // æ¸²æŸ“ç»„ä»¶
}

// å¸¦æ³›å‹å’Œçº¦æŸçš„ç‰¹å¾åˆ«å
trait Mappable<T, U> = FnOnce(T) -> U + Clone;

// ä½¿ç”¨
fn apply_twice<T, U, F>(f: F, input: T) -> U
where
    F: Mappable<T, U>,
    T: Clone,
{
    let first_result = f.clone()(input.clone());
    // åšä¸€äº›å¤„ç†...
    f(input)
}
```

ç‰¹å¾åˆ«åä¸ç‰¹å¾å¯¹è±¡ï¼š

```rust
// å®šä¹‰ç‰¹å¾åˆ«å
trait SerializeDeserialize = Serialize + Deserialize + Send + Sync;

// ä½¿ç”¨ç‰¹å¾åˆ«ååˆ›å»ºç‰¹å¾å¯¹è±¡
fn process(data: Box<dyn SerializeDeserialize>) {
    // å¤„ç†æ•°æ®
}

// ç­‰ä»·äº
fn process(data: Box<dyn Serialize + Deserialize + Send + Sync>) {
    // å¤„ç†æ•°æ®
}
```

å¸¦å…³è”ç±»å‹çš„ç‰¹å¾åˆ«åï¼š

```rust
// åºåˆ—åŒ–ç‰¹å¾åˆ«åï¼Œå¸¦å…³è”ç±»å‹çº¦æŸ
trait BinarySerializable = Serialize + Deserialize<Error = bincode::Error>;

// ä½¿ç”¨
fn save_to_binary<T: BinarySerializable>(value: &T) -> Result<Vec<u8>, bincode::Error> {
    bincode::serialize(value)
}
```

ç‰¹å¾åˆ«åä¸æ³›å‹ç»‘å®šï¼š

```rust
// å®šä¹‰æ³›å‹ç‰¹å¾åˆ«å
trait Processable<T> = AsRef<T> + Clone + Debug;

// ä½¿ç”¨
fn transform<T, U>(input: U) -> T
where
    U: Processable<T>,
    T: Default,
{
    // ...
}
```

ç‰¹å¾åˆ«åçš„ä¼˜åŠ¿ï¼š

1. **ä»£ç ç®€åŒ–**ï¼šå‡å°‘é‡å¤ç‰¹å¾çº¦æŸ
2. **è¯­ä¹‰ç»„ç»‡**ï¼šæ ¹æ®åŠŸèƒ½å°†ç‰¹å¾åˆ†ç»„
3. **APIè®¾è®¡**ï¼šåˆ›å»ºæ›´å…·è¡¨è¾¾åŠ›çš„æ¥å£
4. **çº¦æŸé‡ç”¨**ï¼šé¿å…åœ¨å¤šå¤„é‡å¤ç›¸åŒçº¦æŸé›†
5. **å¯è¯»æ€§**ï¼šä½¿å¤æ‚ç±»å‹çº¦æŸæ›´æ˜“ç†è§£

ç‰¹å¾åˆ«åçš„é™åˆ¶ï¼š

1. **ä¸èƒ½æ·»åŠ æ–°æ–¹æ³•**ï¼šåªæ˜¯ç°æœ‰ç‰¹å¾çš„ç»„åˆ
2. **ä¸èƒ½æ”¹å˜ç‰¹å¾è¯­ä¹‰**ï¼šæ²¡æœ‰åˆ›å»ºæ–°ç‰¹å¾
3. **ä¸èƒ½æ·»åŠ æ–°å…³è”ç±»å‹**ï¼šåªèƒ½ä½¿ç”¨ç»„æˆç‰¹å¾ä¸­å·²æœ‰çš„

## 3. æ‰€æœ‰æƒç³»ç»Ÿä¸å†…å­˜ç®¡ç†

### 3.1 æ‰€æœ‰æƒåŸºæœ¬åŸåˆ™

#### 3.1.1 æ‰€æœ‰æƒè§„åˆ™

æ‰€æœ‰æƒæ˜¯Rustå†…å­˜å®‰å…¨æ¨¡å‹çš„æ ¸å¿ƒï¼ŒåŸºäºä¸‰ä¸ªåŸºæœ¬è§„åˆ™ï¼š

```rust
// Rustæ‰€æœ‰æƒè§„åˆ™ï¼š
// 1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
// 2. ä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
// 3. å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼Œå€¼å°†è¢«ä¸¢å¼ƒ
```

è¿™äº›è§„åˆ™åœ¨å®è·µä¸­çš„ä½“ç°ï¼š

```rust
// è§„åˆ™1ï¼šæ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
let s = String::from("hello"); // sæ˜¯è¯¥å­—ç¬¦ä¸²çš„æ‰€æœ‰è€…

// è§„åˆ™2ï¼šä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
let s1 = s;          // æ‰€æœ‰æƒä»sè½¬ç§»åˆ°s1
// println!("{}", s); // é”™è¯¯ï¼šsçš„å€¼å·²è¢«ç§»åŠ¨

// è§„åˆ™3ï¼šå½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼Œå€¼å°†è¢«ä¸¢å¼ƒ
{
    let s = String::from("hello"); // sæ˜¯æœ‰æ•ˆçš„
    // ä½¿ç”¨s
} // ä½œç”¨åŸŸç»“æŸï¼Œsæ— æ•ˆï¼Œå†…å­˜è¢«é‡Šæ”¾
```

æ‰€æœ‰æƒåœ¨ä¸åŒåœºæ™¯ä¸­çš„åº”ç”¨ï¼š

**å‡½æ•°å‚æ•°ä¸è¿”å›å€¼**ï¼š

```rust
fn take_ownership(some_string: String) {
    println!("{}", some_string);
} // some_stringç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {
    let s = String::from("hello"); // sè¿›å…¥ä½œç”¨åŸŸ
    s // è¿”å›så¹¶ç§»åŠ¨ç»™è°ƒç”¨è€…
}

// ä½¿ç”¨ç¤ºä¾‹
let s1 = String::from("hello");
take_ownership(s1); // s1çš„æ‰€æœ‰æƒç§»åŠ¨ç»™å‡½æ•°
// println!("{}", s1); // é”™è¯¯ï¼šs1ä¸å†æœ‰æ•ˆ

let s2 = gives_ownership(); // s2è·å¾—è¿”å›å€¼çš„æ‰€æœ‰æƒ
```

**å¼•ç”¨ä¸å€Ÿç”¨**ï¼šåœ¨ä¸è½¬ç§»æ‰€æœ‰æƒçš„æƒ…å†µä¸‹è®¿é—®æ•°æ®ï¼š

```rust
fn calculate_length(s: &String) -> usize { // sæ˜¯Stringçš„å¼•ç”¨
    s.len()
} // sç¦»å¼€ä½œç”¨åŸŸï¼Œä½†ä¸å½±å“åŸå§‹String

let s1 = String::from("hello");
let len = calculate_length(&s1); // ä¼ é€’å¼•ç”¨ï¼Œä¸è½¬ç§»æ‰€æœ‰æƒ
println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len); // s1ä»ç„¶æœ‰æ•ˆ
```

#### 3.1.2 ç§»åŠ¨è¯­ä¹‰ï¼ˆmove semanticsï¼‰

Rustä½¿ç”¨ç§»åŠ¨è¯­ä¹‰è€Œééšå¼æ‹·è´ï¼Œç¡®ä¿å†…å­˜å®‰å…¨ï¼š

```rust
// ç§»åŠ¨è¯­ä¹‰ç¤ºä¾‹
let s1 = String::from("hello");
let s2 = s1; // æ‰€æœ‰æƒä»s1ç§»åŠ¨åˆ°s2
// s1ä¸å†æœ‰æ•ˆ

// ç§»åŠ¨å‘ç”Ÿçš„åœºæ™¯ï¼š
// 1. èµ‹å€¼
let v1 = vec![1, 2, 3];
let v2 = v1; // v1ç§»åŠ¨åˆ°v2

// 2. å‡½æ•°å‚æ•°
fn process(v: Vec<i32>) {
    // ä½¿ç”¨v
} // vè¢«ä¸¢å¼ƒ

let v = vec![1, 2, 3];
process(v); // vçš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å‡½æ•°
// vä¸å†æœ‰æ•ˆ

// 3. å‡½æ•°è¿”å›å€¼
fn create() -> Vec<i32> {
    let v = vec![1, 2, 3];
    v // è¿”å›vï¼Œæ‰€æœ‰æƒç§»åŠ¨ç»™è°ƒç”¨è€…
}

let v = create(); // vè·å¾—æ‰€æœ‰æƒ
```

ç§»åŠ¨çš„å†…å­˜å®ç°ï¼š

```rust
// Stringçš„å†…å­˜è¡¨ç¤º
// å †æ ˆè¡¨ç¤ºï¼š
//   s1 -> æŒ‡é’ˆ -> å †å†…å­˜("hello")
//        å®¹é‡
//        é•¿åº¦

let s1 = String::from("hello");
let s2 = s1;

// ç§»åŠ¨åï¼š
//   s1 -> [æ— æ•ˆ]
//   s2 -> æŒ‡é’ˆ -> å †å†…å­˜("hello")
//        å®¹é‡
//        é•¿åº¦
// åªå¤åˆ¶äº†æ ˆä¸Šçš„æŒ‡é’ˆã€å®¹é‡å’Œé•¿åº¦ï¼Œæ²¡æœ‰å¤åˆ¶å †æ•°æ®
```

ç§»åŠ¨è¯­ä¹‰ç¡®ä¿ï¼š

1. **æ— é‡å¤é‡Šæ”¾**ï¼šåŒä¸€å†…å­˜ä¸ä¼šè¢«é‡Šæ”¾ä¸¤æ¬¡
2. **æ— æ•°æ®ç«äº‰**ï¼šåŒä¸€å¯å˜æ•°æ®ä¸ä¼šåŒæ—¶è¢«å¤šå¤„è®¿é—®
3. **æ— æ‚¬å‚æŒ‡é’ˆ**ï¼šæŒ‡é’ˆæ€»æ˜¯æŒ‡å‘æœ‰æ•ˆå†…å­˜
4. **æ— å†…å­˜æ³„æ¼**ï¼šæ‰€æœ‰èµ„æºéƒ½æœ‰æ˜ç¡®çš„æ‰€æœ‰è€…å’Œé‡Šæ”¾ç‚¹

#### 3.1.3 å¤åˆ¶è¯­ä¹‰ï¼ˆcopy semanticsï¼‰

æŸäº›ç®€å•ç±»å‹å®ç°äº†`Copy`ç‰¹å¾ï¼Œåœ¨èµ‹å€¼æ—¶è¿›è¡Œå¤åˆ¶è€Œéç§»åŠ¨ï¼š

```rust
// å¤åˆ¶è¯­ä¹‰ï¼ˆé€‚ç”¨äºå®ç°Copyç‰¹å¾çš„ç±»å‹ï¼‰
let x = 5;
let y = x; // xè¢«å¤åˆ¶åˆ°yï¼Œè€Œéç§»åŠ¨
println!("x = {}, y = {}", x, y); // xå’Œyéƒ½å¯ç”¨

// å®ç°äº†Copyçš„ç±»å‹åŒ…æ‹¬ï¼š
// - æ‰€æœ‰æ•´æ•°ç±»å‹ï¼ˆi32, u64ç­‰ï¼‰
// - å¸ƒå°”ç±»å‹ï¼ˆboolï¼‰
// - æµ®ç‚¹ç±»å‹ï¼ˆf32, f64ï¼‰
// - å­—ç¬¦ç±»å‹ï¼ˆcharï¼‰
// - å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶æ‰€æœ‰å­—æ®µéƒ½å®ç°äº†Copy
//   ä¾‹å¦‚ï¼š(i32, i32)å®ç°äº†Copyï¼Œä½†(i32, String)æ²¡æœ‰
// - æ•°ç»„ï¼Œå½“ä¸”ä»…å½“å…¶å…ƒç´ ç±»å‹å®ç°äº†Copy
//   ä¾‹å¦‚ï¼š[i32; 5]å®ç°äº†Copyï¼Œä½†[String; 5]æ²¡æœ‰
```

è‡ªå®šä¹‰ç±»å‹å®ç°`Copy`ï¼š

```rust
// ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°Copy
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

let p1 = Point { x: 10, y: 20 };
let p2 = p1; // p1è¢«å¤åˆ¶åˆ°p2ï¼Œè€Œéç§»åŠ¨
println!("p1: ({}, {}), p2: ({}, {})", p1.x, p1.y, p2.x, p2.y);

// ä¸èƒ½ä¸ºæ‹¥æœ‰èµ„æºçš„ç±»å‹å®ç°Copy
struct Person {
    name: String, // åŒ…å«å †åˆ†é…çš„èµ„æº
    age: i32,
}
// #[derive(Copy, Clone)] // é”™è¯¯ï¼šStringæ²¡æœ‰å®ç°Copy
```

æ˜¾å¼å¤åˆ¶ï¼ˆéCopyç±»å‹ï¼‰ï¼š

```rust
// Cloneç‰¹å¾ç”¨äºæ˜¾å¼å¤åˆ¶
let s1 = String::from("hello");
let s2 = s1.clone(); // æ·±æ‹·è´s1åˆ°s2
println!("s1 = {}, s2 = {}", s1, s2); // s1å’Œs2éƒ½å¯ç”¨

// Vecçš„å…‹éš†
let v1 = vec![1, 2, 3];
let v2 = v1.clone();
println!("v1: {:?}, v2: {:?}", v1, v2);

// è‡ªå®šä¹‰ç±»å‹å®ç°Clone
#[derive(Clone)]
struct Person {
    name: String,
    age: i32,
}

let p1 = Person { name: String::from("Alice"), age: 30 };
let p2 = p1.clone();
println!("{} is {} years old", p1.name, p1.age);
println!("{} is {} years old", p2.name, p2.age);
```

Copyä¸Cloneçš„å…³ç³»ï¼š

```rust
// Copyæ˜¯Cloneçš„å­ç‰¹å¾
trait Copy: Clone {}

// æ„å‘³ç€ï¼š
// 1. æ‰€æœ‰å®ç°Copyçš„ç±»å‹å¿…é¡»å®ç°Clone
// 2. Copyç±»å‹çš„clone()ä¸åšç‰¹æ®Šäº‹æƒ…ï¼Œåªæ˜¯ç®€å•å†…å­˜å¤åˆ¶
// 3. Cloneæ›´é€šç”¨ï¼ˆå…è®¸æ·±æ‹·è´ï¼‰ï¼ŒCopyæ›´ä¸¥æ ¼ï¼ˆä»…å…è®¸ä½å¤åˆ¶ï¼‰
```

#### 3.1.4 æ‰€æœ‰æƒè½¬ç§»çš„æ—¶æœºä¸å½±å“

æ‰€æœ‰æƒè½¬ç§»åœ¨å¤šç§ä¸Šä¸‹æ–‡ä¸­å‘ç”Ÿï¼Œäº†è§£è¿™äº›æ—¶æœºå¯¹äºç¼–å†™æ­£ç¡®ä»£ç è‡³å…³é‡è¦ï¼š

```rust
// 1. å˜é‡èµ‹å€¼
let s1 = String::from("hello");
let s2 = s1; // æ‰€æœ‰æƒä»s1è½¬ç§»åˆ°s2

// 2. å‡½æ•°å‚æ•°ä¼ é€’
fn process(s: String) {
    println!("å¤„ç†: {}", s);
}
let s = String::from("world");
process(s); // æ‰€æœ‰æƒè½¬ç§»ç»™å‡½æ•°å‚æ•°

// 3. å‡½æ•°è¿”å›å€¼
fn create_string() -> String {
    let s = String::from("æ–°å­—ç¬¦ä¸²");
    s // æ‰€æœ‰æƒè½¬ç§»ç»™è°ƒç”¨è€…
}
let s = create_string(); // sè·å¾—è¿”å›å€¼çš„æ‰€æœ‰æƒ

// 4. ä½¿ç”¨è§£æ„
let tuple = (String::from("hello"), 5);
let (s, n) = tuple; // tuple.0çš„æ‰€æœ‰æƒè½¬ç§»ç»™s

// 5. åœ¨matchè¡¨è¾¾å¼ä¸­
let optional = Some(String::from("å€¼"));
match optional {
    Some(s) => println!("æ‰¾åˆ°å€¼: {}", s), // æ‰€æœ‰æƒè½¬ç§»ç»™s
    None => println!("æ— å€¼"),
}
// optionalä¸å†æŒæœ‰å…¶å†…éƒ¨Stringçš„æ‰€æœ‰æƒ
```

æ‰€æœ‰æƒè½¬ç§»çš„å½±å“ï¼š

**1. å˜é‡ä½œç”¨åŸŸå’Œèµ„æºé‡Šæ”¾**ï¼š

```rust
{
    let s = String::from("ä½œç”¨åŸŸæ¼”ç¤º");
    // såœ¨æ­¤ä½œç”¨åŸŸæœ‰æ•ˆ
} // sç¦»å¼€ä½œç”¨åŸŸï¼ŒStringè¢«é‡Šæ”¾
  // Rustè‡ªåŠ¨è°ƒç”¨String::dropå‡½æ•°

// åµŒå¥—ä½œç”¨åŸŸ
{
    let outer = String::from("å¤–éƒ¨");
    {
        let inner = String::from("å†…éƒ¨");
        // innerå’Œouteréƒ½æœ‰æ•ˆ
    } // innerç¦»å¼€ä½œç”¨åŸŸï¼Œå…¶å†…å­˜è¢«é‡Šæ”¾
    // outerä»ç„¶æœ‰æ•ˆ
} // outerç¦»å¼€ä½œç”¨åŸŸï¼Œå…¶å†…å­˜è¢«é‡Šæ”¾
```

**2. é›†åˆä¸­çš„æ‰€æœ‰æƒ**ï¼š

```rust
// å‘é›†åˆä¸­æ’å…¥å…ƒç´ ä¼šè½¬ç§»æ‰€æœ‰æƒ
let mut vec = Vec::new();
let s = String::from("hello");
vec.push(s); // sçš„æ‰€æœ‰æƒè½¬ç§»ç»™vec
// println!("{}", s); // é”™è¯¯ï¼šsä¸å†æœ‰æ•ˆ

// ä»vecä¸­è·å–å…ƒç´ 
let mut v = vec![String::from("hello"), String::from("world")];
let s = v.pop().unwrap(); // sè·å¾—å¼¹å‡ºå€¼çš„æ‰€æœ‰æƒ
println!("å¼¹å‡º: {}", s);

// é›†åˆè¢«ä¸¢å¼ƒæ—¶ï¼Œå…¶æ‰€æœ‰å…ƒç´ ä¹Ÿè¢«ä¸¢å¼ƒ
{
    let v = vec![String::from("goodbye"), String::from("world")];
    // væ‹¥æœ‰æ‰€æœ‰Stringçš„æ‰€æœ‰æƒ
} // vç¦»å¼€ä½œç”¨åŸŸï¼Œæ‰€æœ‰Stringéƒ½è¢«é‡Šæ”¾
```

**3. éƒ¨åˆ†æ‰€æœ‰æƒè½¬ç§»**ï¼š

```rust
// ç»“æ„ä½“çš„éƒ¨åˆ†ç§»åŠ¨
struct Person {
    name: String,
    age: i32,
}

let p = Person {
    name: String::from("Alice"),
    age: 30,
};

let name = p.name; // nameå­—æ®µçš„æ‰€æœ‰æƒä»pè½¬ç§»å‡ºæ¥
// println!("å®Œæ•´person: {:?}", p); // é”™è¯¯ï¼šp.nameå·²ç§»åŠ¨
println!("å¹´é¾„: {}", p.age); // å¯ä»¥è®¿é—®æœªç§»åŠ¨çš„å­—æ®µ

// æšä¸¾çš„éƒ¨åˆ†ç§»åŠ¨
enum Message {
    Text(String),
    Code(i32),
}

let msg = Message::Text(String::from("hello"));

if let Message::Text(text) = msg {
    println!("æ¶ˆæ¯å†…å®¹: {}", text); // textè·å¾—Stringæ‰€æœ‰æƒ
}
// æ­¤å¤„msgå·²è¢«éƒ¨åˆ†æˆ–å®Œå…¨ç§»åŠ¨ï¼Œå–å†³äºåŒ¹é…çš„å˜ä½“
```

### 3.2 å€Ÿç”¨ç³»ç»Ÿ

#### 3.2.1 ä¸å¯å˜å€Ÿç”¨ï¼ˆ&Tï¼‰

å€Ÿç”¨å…è®¸åœ¨ä¸è½¬ç§»æ‰€æœ‰æƒçš„æƒ…å†µä¸‹ä½¿ç”¨å€¼ï¼š

```rust
// åŸºæœ¬ä¸å¯å˜å€Ÿç”¨
let s = String::from("hello");
let len = calculate_length(&s); // å€Ÿç”¨sï¼Œä¸è·å–æ‰€æœ‰æƒ
println!("'{}' çš„é•¿åº¦æ˜¯: {}", s, len); // sä»æœ‰æ•ˆ

fn calculate_length(s: &String) -> usize { // sæ˜¯å¯¹Stringçš„å¼•ç”¨
    s.len()
} // sç¦»å¼€ä½œç”¨åŸŸï¼Œä½†ä¸å½±å“åŸå§‹String

// å¼•ç”¨çš„æ•°æ®ä¸èƒ½è¢«ä¿®æ”¹
fn invalid_modify(s: &String) {
    // s.push_str(" world"); // é”™è¯¯ï¼šä¸èƒ½ä¿®æ”¹å€Ÿç”¨çš„å€¼
}
```

ä¸å¯å˜å€Ÿç”¨çš„ç‰¹ç‚¹ï¼š

1. **å…±äº«æ€§**ï¼šå¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
2. **åªè¯»è®¿é—®**ï¼šä¸èƒ½é€šè¿‡å¼•ç”¨ä¿®æ”¹æ•°æ®
3. **éæ‰€æœ‰æƒ**ï¼šå¼•ç”¨ç¦»å¼€ä½œç”¨åŸŸä¸ä¼šé‡Šæ”¾è¢«å¼•ç”¨çš„å€¼
4. **å€Ÿç”¨æ—¶é—´é™åˆ¶**ï¼šå¼•ç”¨ä¸èƒ½è¶…è¿‡è¢«å¼•ç”¨å€¼çš„ç”Ÿå‘½å‘¨æœŸ

```rust
// å¤šä¸ªä¸å¯å˜å¼•ç”¨
let s = String::from("hello");
let r1 = &s; // ç¬¬ä¸€ä¸ªå¼•ç”¨
let r2 = &s; // ç¬¬äºŒä¸ªå¼•ç”¨
println!("{} and {}", r1, r2); // ä¸¤ä¸ªå¼•ç”¨éƒ½å¯ç”¨

// é¿å…æ‚¬å‚å¼•ç”¨
fn dangling() -> &String { // é”™è¯¯ï¼šè¿”å›å¯¹å±€éƒ¨å˜é‡çš„å¼•ç”¨
    let s = String::from("hello");
    &s // sç¦»å¼€ä½œç”¨åŸŸï¼Œå¼•ç”¨æ— æ•ˆ
} // sç¦»å¼€ä½œç”¨åŸŸè¢«é‡Šæ”¾ï¼Œè¿”å›çš„å¼•ç”¨å°†æŒ‡å‘æ— æ•ˆå†…å­˜
```

å¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°ï¼š

```rust
// ä½¿ç”¨ä¸å¯å˜å¼•ç”¨è¯»å–æ•°æ®
fn print_details(person: &Person) {
    println!("å§“å: {}, å¹´é¾„: {}", person.name, person.age);
}

let alice = Person { name: String::from("Alice"), age: 30 };
print_details(&alice); // å€Ÿç”¨alice
print_details(&alice); // å¯ä»¥å¤šæ¬¡å€Ÿç”¨
```

#### 3.2.2 å¯å˜å€Ÿç”¨ï¼ˆ&mut Tï¼‰

å¯å˜å€Ÿç”¨å…è®¸ä¿®æ”¹å€Ÿç”¨çš„æ•°æ®ï¼š

```rust
// åŸºæœ¬å¯å˜å€Ÿç”¨
let mut s = String::from("hello");
change(&mut s); // å¯å˜å€Ÿç”¨
println!("ä¿®æ”¹å: {}", s); // è¾“å‡º "hello world"

fn change(s: &mut String) {
    s.push_str(" world"); // å¯ä»¥ä¿®æ”¹å€Ÿç”¨çš„å€¼
}

// å¯å˜å¼•ç”¨é™åˆ¶ï¼šåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨
let mut s = String::from("hello");
let r1 = &mut s;
// let r2 = &mut s; // é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰ä¸¤ä¸ªå¯å˜å¼•ç”¨
// println!("{}, {}", r1, r2);

// åœ¨ä¸åŒä½œç”¨åŸŸä¸­å¯ä»¥æœ‰å¤šä¸ªå¯å˜å¼•ç”¨
let mut s = String::from("hello");
{
    let r1 = &mut s;
    r1.push_str(" world");
} // r1ç¦»å¼€ä½œç”¨åŸŸï¼Œå…¶å€Ÿç”¨ç»“æŸ

// ç°åœ¨å¯ä»¥åˆ›å»ºæ–°çš„å¯å˜å¼•ç”¨
let r2 = &mut s;
r2.push_str("!");
```

ä¸å¯å˜å¼•ç”¨ä¸å¯å˜å¼•ç”¨çš„äº’æ–¥æ€§ï¼š

```rust
// ä¸èƒ½åŒæ—¶æ‹¥æœ‰å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨
let mut s = String::from("hello");

let r1 = &s; // ä¸å¯å˜å€Ÿç”¨
let r2 = &s; // å¦ä¸€ä¸ªä¸å¯å˜å€Ÿç”¨
// let r3 = &mut s; // é”™è¯¯ï¼šå·²æœ‰ä¸å¯å˜å€Ÿç”¨ï¼Œä¸èƒ½å†æœ‰å¯å˜å€Ÿç”¨
// println!("{}, {}, and {}", r1, r2, r3);

// å€Ÿç”¨çš„ä½œç”¨åŸŸ
let mut s = String::from("hello");

let r1 = &s; // ä¸å¯å˜å€Ÿç”¨
let r2 = &s; // å¦ä¸€ä¸ªä¸å¯å˜å€Ÿç”¨
println!("{} and {}", r1, r2); // r1å’Œr2çš„ä½œç”¨åŸŸåˆ°æ­¤ç»“æŸ

let r3 = &mut s; // ç°åœ¨å¯ä»¥è¿›è¡Œå¯å˜å€Ÿç”¨
println!("{}", r3);
```

å¯å˜å€Ÿç”¨çš„ç”¨ä¾‹ï¼š

```rust
// ä¿®æ”¹å¤æ‚æ•°æ®ç»“æ„
fn add_year(person: &mut Person) {
    person.age += 1;
}

let mut bob = Person { name: String::from("Bob"), age: 25 };
add_year(&mut bob); // é€šè¿‡å¯å˜å¼•ç”¨å¢åŠ å¹´é¾„
println!("{} ç°åœ¨ {} å²", bob.name, bob.age); // è¾“å‡º 26

// å¤šä¸ªå­—æ®µå•ç‹¬å€Ÿç”¨
let mut person = Person { name: String::from("Charlie"), age: 40 };
let name = &mut person.name;
let age = &mut person.age;
name.push_str(" Smith");
*age += 1;
println!("{} ç°åœ¨ {} å²", name, age);
```

#### 3.2.3 å€Ÿç”¨è§„åˆ™ä¸å€Ÿç”¨æ£€æŸ¥å™¨

å€Ÿç”¨æ£€æŸ¥å™¨åœ¨ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡Œå€Ÿç”¨è§„åˆ™ï¼Œç¡®ä¿å†…å­˜å®‰å…¨ï¼š

```rust
// å€Ÿç”¨è§„åˆ™ï¼š
// 1. åŒä¸€æ—¶é—´ï¼Œåªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–å¤šä¸ªä¸å¯å˜å¼•ç”¨
// 2. å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ï¼ˆä¸èƒ½æœ‰æ‚¬å‚å¼•ç”¨ï¼‰
```

å€Ÿç”¨æ£€æŸ¥å™¨çš„å·¥ä½œåŸç†ï¼š

**1. å¼•ç”¨çš„ä½œç”¨åŸŸä¸æœ‰æ•ˆæ€§**ï¼š

```rust
// ä½œç”¨åŸŸåˆ†æ
let mut s = String::from("hello");

// ä¸å¯å˜å€Ÿç”¨
let r1 = &s; // r1ä½œç”¨åŸŸå¼€å§‹
let r2 = &s; // r2ä½œç”¨åŸŸå¼€å§‹
println!("{} {}", r1, r2); // r1å’Œr2æœ€åä¸€æ¬¡ä½¿ç”¨ï¼Œä½œç”¨åŸŸç»“æŸ

// å¯å˜å€Ÿç”¨ï¼Œç°åœ¨å¯ä»¥äº†ï¼Œå› ä¸ºr1å’Œr2çš„ä½œç”¨åŸŸå·²ç»“æŸ
let r3 = &mut s; // r3ä½œç”¨åŸŸå¼€å§‹
println!("{}", r3); // r3æœ€åä¸€æ¬¡ä½¿ç”¨ï¼Œä½œç”¨åŸŸç»“æŸ

// éè¯æ³•ç”Ÿå‘½å‘¨æœŸ(NLL)
let mut v = vec![1, 2, 3];
let r = &v[0]; // ä¸å¯å˜å€Ÿç”¨
println!("é¦–å…ƒç´ : {}", r); // rçš„æœ€åä½¿ç”¨

v.push(4); // å¯ä»¥ä¿®æ”¹vï¼Œå› ä¸ºrä¸å†ä½¿ç”¨
// println!("é¦–å…ƒç´ ä»ç„¶æ˜¯: {}", r); // é”™è¯¯ï¼šrä¸èƒ½åœ¨æ­¤ä½¿ç”¨
```

**2. å€Ÿç”¨æ£€æŸ¥å™¨é”™è¯¯åœºæ™¯**ï¼š

```rust
// æ‚¬å‚å¼•ç”¨æ£€æµ‹
fn invalid_return() -> &i32 {
    let x = 5;
    &x // é”™è¯¯ï¼šè¿”å›å¯¹å±€éƒ¨å˜é‡çš„å¼•ç”¨
}

// å€Ÿç”¨å†²çªæ£€æµ‹
fn conflicting_borrow(v: &mut Vec<i32>) {
    let first = &v[0]; // ä¸å¯å˜å€Ÿç”¨æŸå…ƒç´ 
    v.push(6); // é”™è¯¯ï¼šå¯å˜å€Ÿç”¨æ•´ä¸ªé›†åˆï¼Œå¯èƒ½ä½¿firstæ— æ•ˆ
    // println!("é¦–å…ƒç´ : {}", first);
}

// ç§»åŠ¨æ£€æµ‹
fn move_borrowed(v: &Vec<i32>) {
    // let v2 = *v; // é”™è¯¯ï¼šå°è¯•ç§»åŠ¨å€Ÿç”¨çš„å€¼
}
```

**3. æ­£ç¡®æ¨¡å¼**ï¼š

```rust
// åˆ†ç¦»å€Ÿç”¨
fn split_borrow(v: &mut Vec<i32>) {
    // å…ˆè®¡ç®—ç´¢å¼•ï¼Œé¿å…åŒæ—¶å€Ÿç”¨
    let last_idx = v.len() - 1;
    // åˆ†å¼€å€Ÿç”¨ä¸åŒå…ƒç´ 
    let first = &mut v[0];
    let last = &mut v[last_idx];
    *first += 1;
    *last += 1;
}

// å€Ÿç”¨å°è£…
fn process_data(data: &mut [i32]) {
    // å¤šé˜¶æ®µå¤„ç†ï¼Œæ¯æ¬¡åªæœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨
    let sum: i32 = data.iter().sum();
    for item in data.iter_mut() {
        *item -= sum / data.len() as i32;
    }
}
```

#### 3.2.4 å¤šé‡å€Ÿç”¨ä¸å€Ÿç”¨å†²çª

ç†è§£ä¸åŒå€Ÿç”¨åœºæ™¯åŠå…¶å†²çªçš„å¤„ç†ï¼š

```rust
// ç¦æ­¢çš„æ¨¡å¼ï¼šåŒæ—¶å­˜åœ¨çš„å¯å˜å’Œä¸å¯å˜å€Ÿç”¨
let mut data = vec![1, 2, 3];
let slice = &data; // ä¸å¯å˜å€Ÿç”¨
// data.push(4); // é”™è¯¯ï¼šåŒæ—¶æœ‰ä¸å¯å˜å’Œå¯å˜å€Ÿç”¨
println!("åˆ‡ç‰‡: {:?}", slice);

// å…è®¸çš„æ¨¡å¼ï¼šé¡ºåºå€Ÿç”¨
let mut data = vec![1, 2, 3];
{
    let slice = &data; // ä¸å¯å˜å€Ÿç”¨
    println!("åˆ‡ç‰‡: {:?}", slice);
} // ä¸å¯å˜å€Ÿç”¨ç»“æŸ

data.push(4); // ç°åœ¨å¯ä»¥å¯å˜å€Ÿç”¨
println!("ä¿®æ”¹å: {:?}", data);
```

å®¹å™¨çš„å€Ÿç”¨ä¸å®¹å™¨å…ƒç´ å€Ÿç”¨ï¼š

```rust
// é›†åˆæ•´ä½“ä¸å…ƒç´ çš„å€Ÿç”¨
let mut v = vec![1, 2, 3];

// å®‰å…¨: å€Ÿç”¨ä¸åŒå…ƒç´ 
let a = &mut v[0];
let b = &mut v[2];
*a += 10;
*b += 10;
println!("v[0] = {}, v[2] = {}", a, b);

// ä¸å®‰å…¨: åŒæ—¶å€Ÿç”¨å®¹å™¨å’Œå…ƒç´ 
let mut v = vec![1, 2, 3];
let first = &v[0]; // å€Ÿç”¨å…ƒç´ 
// v.push(4); // é”™è¯¯: å¯èƒ½ä½¿firstæ— æ•ˆï¼ˆvå¯èƒ½é‡æ–°åˆ†é…å†…å­˜ï¼‰
// println!("First: {}", first);
```

å­—æ®µçš„ç‹¬ç«‹å€Ÿç”¨ï¼š

```rust
struct Person {
    name: String,
    age: u32,
}

let mut person = Person {
    name: String::from("Alice"),
    age: 30,
};

// å¯ä»¥åŒæ—¶å¯å˜å€Ÿç”¨ä¸åŒå­—æ®µ
let name = &mut person.name;
let age = &mut person.age;
name.push_str(" Smith");
*age += 1;

println!("{} is {} years old", name, age);
```

å€Ÿç”¨çš„åµŒå¥—ä¸åˆ†è§£ï¼š

```rust
// åµŒå¥—ç»“æ„çš„å€Ÿç”¨
struct Team {
    name: String,
    members: Vec<Person>,
}

let mut team = Team {
    name: String::from("Rustå¼€å‘è€…"),
    members: vec![
        Person { name: String::from("Alice"), age: 30 },
        Person { name: String::from("Bob"), age: 25 },
    ],
};

// å¯ä»¥åˆ†åˆ«å€Ÿç”¨ä¸åŒéƒ¨åˆ†
let team_name = &team.name;
let first_member = &mut team.members[0];
println!("å›¢é˜Ÿ: {}", team_name);
first_member.age += 1;
```

#### 3.2.5 è‡ªå¼•ç”¨ç»“æ„çš„æŒ‘æˆ˜

è‡ªå¼•ç”¨ç»“æ„ï¼ˆå«æœ‰æŒ‡å‘è‡ªèº«å…¶ä»–éƒ¨åˆ†çš„å¼•ç”¨ï¼‰å¸¦æ¥ç‰¹æ®ŠæŒ‘æˆ˜ï¼š

```rust
// åŸºæœ¬è‡ªå¼•ç”¨ç»“æ„ï¼ˆé€šå¸¸æ— æ³•ç›´æ¥å®ç°ï¼‰
struct SelfRef {
    value: String,
    pointer: *const String, // ä½¿ç”¨åŸå§‹æŒ‡é’ˆ
}

// åˆ›å»ºè‡ªå¼•ç”¨ç»“æ„
fn create_self_ref() -> SelfRef {
    let mut s = SelfRef {
        value: String::from("hello"),
        pointer: std::ptr::null(),
    };
    s.pointer = &s.value; // å­˜å‚¨æŒ‡å‘è‡ªèº«å­—æ®µçš„æŒ‡é’ˆ
    s
}

// ä½¿ç”¨è‡ªå¼•ç”¨ç»“æ„
fn use_self_ref() {
    let s = create_self_ref();
    
    // å¿…é¡»ä½¿ç”¨unsafeï¼Œå› ä¸ºæ¶‰åŠåŸå§‹æŒ‡é’ˆè§£å¼•ç”¨
    unsafe {
        println!("å€¼: {}, æŒ‡é’ˆ: {}", s.value, *s.pointer);
    }
}
```

è‡ªå¼•ç”¨ç»“æ„çš„é—®é¢˜ï¼š

```rust
// è‡ªå¼•ç”¨ç»“æ„çš„ç§»åŠ¨é—®é¢˜
fn problematic() {
    let mut s = create_self_ref();
    
    // ç§»åŠ¨sä¼šå¯¼è‡´æŒ‡é’ˆæŒ‡å‘æ—§ä½ç½®
    let s2 = s; // s.pointerä»æŒ‡å‘s.valueçš„æ—§ä½ç½®
    
    // æ­¤æ—¶è§£å¼•ç”¨s2.pointeræ˜¯æœªå®šä¹‰è¡Œä¸º
    // unsafe {
    //     println!("ç§»åŠ¨å: {}", *s2.pointer); // å±é™©ï¼
    // }
}
```

å®‰å…¨è§£å†³æ–¹æ¡ˆï¼š

1. **é¿å…è‡ªå¼•ç”¨ç»“æ„**ï¼šé‡æ–°è®¾è®¡æ•°æ®ç»“æ„ï¼Œé¿å…è‡ªå¼•ç”¨
2. **ä½¿ç”¨ç´¢å¼•è€Œéå¼•ç”¨**ï¼šå¼•ç”¨è¡¨ç¤ºä¸ºç´¢å¼•æˆ–ID
3. **ä½¿ç”¨`Rc`/`RefCell`ç»„åˆ**ï¼šé—´æ¥ç®¡ç†å¼•ç”¨
4. **ä½¿ç”¨`Pin`ç‰¹æ€§**ï¼šé˜²æ­¢å·²å›ºå®šçš„æ•°æ®ç§»åŠ¨
5. **ä½¿ç”¨ç®±åº“**ï¼šå¦‚`ouroboros`æˆ–`rental`

```rust
// è§£å†³æ–¹æ¡ˆ1ï¼šä½¿ç”¨ç´¢å¼•
struct IndexBased {
    values: Vec<String>,
    pointer_idx: usize, // å­˜å‚¨ç´¢å¼•è€Œéå¼•ç”¨
}

impl IndexBased {
    fn new(value: String) -> Self {
        let mut result = IndexBased {
            values: vec![value],
            pointer_idx: 0,
        };
        result
    }
    
    fn get_pointed(&self) -> &String {
        &self.values[self.pointer_idx]
    }
}

// è§£å†³æ–¹æ¡ˆ2ï¼šä½¿ç”¨Rc/RefCell
use std::rc::Rc;
use std::cell::RefCell;

struct SafeSelfRef {
    value: Rc<RefCell<String>>,
    pointer: Rc<RefCell<String>>, // æŒ‡å‘åŒä¸€æ•°æ®
}

impl SafeSelfRef {
    fn new(value: String) -> Self {
        let shared = Rc::new(RefCell::new(value));
        SafeSelfRef {
            value: Rc::clone(&shared),
            pointer: Rc::clone(&shared),
        }
    }
}
```

### 3.3 ç”Ÿå‘½å‘¨æœŸ

#### 3.3.1 ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼ˆ'aï¼‰

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ç”¨äºæŒ‡å®šå¼•ç”¨ä¹‹é—´çš„æœ‰æ•ˆæœŸå…³ç³»ï¼š

```rust
// åŸºæœ¬ç”Ÿå‘½å‘¨æœŸè¯­æ³•
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// ä½¿ç”¨
fn use_longest() {
    let string1 = String::from("long string is long");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("æœ€é•¿çš„å­—ç¬¦ä¸²æ˜¯: {}", result);
}
```

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„å«ä¹‰ï¼š

- ç”Ÿå‘½å‘¨æœŸä¸æ”¹å˜å¼•ç”¨çš„å®é™…ç”Ÿå‘½å‘¨æœŸ
- æ ‡æ³¨æè¿°å¼•ç”¨é—´çš„å…³ç³»ï¼Œå¸®åŠ©ç¼–è¯‘å™¨éªŒè¯
- `'a`è¯»ä½œ"ç”Ÿå‘½å‘¨æœŸa"ï¼Œè¡¨ç¤ºä¸€æ®µä½œç”¨åŸŸ
- è¾“å‡ºå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡è¾“å…¥å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ

```rust
// å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
fn complex<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    println!("y: {}", y); // ä½¿ç”¨y
    x // è¿”å›xï¼Œä¸'aå…³è”
}

// ç”Ÿå‘½å‘¨æœŸçº¦æŸ
fn constrained<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
    where 'b: 'a // 'bè‡³å°‘ä¸'aä¸€æ ·é•¿
{
    if x.len() > 0 {
        x
    } else {
        y // åˆæ³•ï¼Œå› ä¸º'b: 'aæ„å‘³ç€yè‡³å°‘æ´»å¾—å’Œxä¸€æ ·é•¿
    }
}
```

ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œçº¦æŸçš„å«ä¹‰ï¼š

- `'b: 'a`è¡¨ç¤ºç”Ÿå‘½å‘¨æœŸ`'b`è‡³å°‘ä¸`'a`ä¸€æ ·é•¿
- è¿™ç§çº¦æŸä½¿å¾—`'b`å¼•ç”¨å¯ä»¥åœ¨éœ€è¦`'a`å¼•ç”¨çš„åœ°æ–¹ä½¿ç”¨
- ç”Ÿå‘½å‘¨æœŸçº¦æŸå¸¸ç”¨äºè¡¨è¾¾å¤æ‚çš„å¼•ç”¨å…³ç³»

#### 3.3.2 å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸç”¨äºç¡®ä¿è¿”å›å¼•ç”¨çš„æœ‰æ•ˆæ€§ï¼š

```rust
// æœ‰æ•ˆçš„ç”Ÿå‘½å‘¨æœŸå…³ç³»
fn first_word<'a>(s: &'a str) -> &'a str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    s
}

// æ— æ•ˆçš„ç”Ÿå‘½å‘¨æœŸå°è¯•
fn invalid_reference<'a>(x: &str) -> &'a str {
    let local = String::from("local value");
    // &local[..] // é”™è¯¯ï¼šè¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨
    x // æ­£ç¡®ï¼šè¿”å›å‚æ•°çš„å¼•ç”¨
}

// ç”Ÿå‘½å‘¨æœŸèåˆ
fn duplicate<'a>(s: &'a str, count: usize) -> String {
    let mut result = String::new();
    for _ in 0..count {
        result.push_str(s);
    }
    result
}
```

é«˜çº§ç”Ÿå‘½å‘¨æœŸåœºæ™¯ï¼š

```rust
// å¤„ç†å¤šä¸ªå‚æ•°
fn first_match<'a, 'b>(text: &'a str, pattern: &'b str) -> Option<&'a str>
where 'b: 'a
{
    for line in text.lines() {
        if line.contains(pattern) {
            return Some(line);
        }
    }
    None
}

// è¿”å›è¾ƒçŸ­ç”Ÿå‘½å‘¨æœŸ
fn either<'a, 'b>(x: &'a str, y: &'b str, use_first: bool) -> &'a str
where 'b: 'a
{
    if use_first {
        x
    } else {
        y // åˆæ³•å› ä¸º'b: 'a
    }
}
```

#### 3.3.3 ç»“æ„ä½“ä¸æšä¸¾ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

ç»“æ„ä½“å’Œæšä¸¾å¯ä»¥åŒ…å«å¼•ç”¨ï¼Œæ­¤æ—¶éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼š

```rust
// å¸¦ç”Ÿå‘½å‘¨æœŸçš„ç»“æ„ä½“
struct Excerpt<'a> {
    part: &'a str,
}

// ä½¿ç”¨ç¤ºä¾‹
fn use_excerpt() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let excerpt = Excerpt { part: first_sentence };
    println!("æ‘˜å½•: {}", excerpt.part);
}

// å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
struct MultiRef<'a, 'b> {
    x: &'a i32,
    y: &'b i32,
}

// æšä¸¾ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
enum Either<'a, 'b> {
    Left(&'a str),
    Right(&'b str),
}
```

ç»“æ„ä½“æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸï¼š

```rust
// ç»“æ„ä½“æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
impl<'a> Excerpt<'a> {
    // æ–¹æ³•è·å–ç¬¬ä¸€ä¸ªå•è¯
    fn first_word(&self) -> &str {
        let bytes = self.part.as_bytes();
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &self.part[0..i];
            }
        }
        self.part
    }
    
    // ä¸åŒç”Ÿå‘½å‘¨æœŸå‚æ•°çš„æ–¹æ³•
    fn compare<'b>(&self, other: &'b str) -> bool
    where 'a: 'b
    {
        self.part.contains(other)
    }
}
```

#### 3.3.4 ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

Rustå…è®¸åœ¨æŸäº›å¸¸è§åœºæ™¯ä¸‹çœç•¥ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼š

```rust
// ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼š
// 1. æ¯ä¸ªå¼•ç”¨å‚æ•°è·å¾—ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
// 2. å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå®ƒè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
// 3. å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯&selfæˆ–&mut selfï¼Œ
//    åˆ™selfçš„ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
```

ä¾‹å­ï¼š

```rust
// å®Œæ•´æ ‡æ³¨
fn first_word<'a>(s: &'a str) -> &'a str {
    // ...
}

// çœç•¥ç­‰ä»·å½¢å¼ï¼ˆè§„åˆ™1å’Œ2ï¼‰
fn first_word(s: &str) -> &str {
    // ...
}

// æ–¹æ³•ä¸­çš„çœç•¥ï¼ˆè§„åˆ™3ï¼‰
impl<'a> Excerpt<'a> {
    // å®Œæ•´å†™æ³•
    fn level_and_part<'b>(&'b self) -> (&'b str, &'a str) {
        ("åŸºç¡€", self.part)
    }
    
    // çœç•¥ç­‰ä»·å½¢å¼ï¼ˆè§„åˆ™1å’Œ3ï¼‰
    fn level_and_part(&self) -> (&str, &str) {
        ("åŸºç¡€", self.part)
    }
}
```

çœç•¥ä¸é€‚ç”¨çš„åœºæ™¯ï¼š

```rust
// çœç•¥è§„åˆ™æ— æ³•æ¨å¯¼
fn longest(x: &str, y: &str) -> &str { // é”™è¯¯ï¼šéœ€è¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// æ­£ç¡®å†™æ³•
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // ...
}
```

#### 3.3.5 'static ç”Ÿå‘½å‘¨æœŸ

`'static`ç”Ÿå‘½å‘¨æœŸè¡¨ç¤ºå¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆï¼š

```rust
// å­—ç¬¦ä¸²å­—é¢é‡æ‹¥æœ‰'staticç”Ÿå‘½å‘¨æœŸ
let s: &'static str = "æˆ‘æœ‰é™æ€ç”Ÿå‘½å‘¨æœŸ";

// ç¼–è¯‘æ—¶è®¡ç®—çš„å¸¸é‡ä¹Ÿæ˜¯'static
const MAX_VALUE: &'static str = "æœ€å¤§å€¼";

// è¿”å›'staticå¼•ç”¨
fn get_static_str() -> &'static str {
    "è¿™æ˜¯ä¸€ä¸ªé™æ€å­—ç¬¦ä¸²"
}

// æ³›å‹çº¦æŸä¸­çš„'static
fn process<T: 'static>(value: T) {
    // Tè¦ä¹ˆæ‹¥æœ‰æ‰€æœ‰æƒï¼Œè¦ä¹ˆåªåŒ…å«'staticå¼•ç”¨
}
```

`'static`çš„ä¸¤ç§ç”¨æ³•ï¼š

1. **å¼•ç”¨ç”Ÿå‘½å‘¨æœŸ**ï¼š`&'static T`è¡¨ç¤ºå¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆ
2. **ç±»å‹çº¦æŸ**ï¼š`T: 'static`è¡¨ç¤ºç±»å‹Tä¸åŒ…å«éé™æ€å¼•ç”¨ï¼Œ
   è¿™ç§æƒ…å†µTå¯ä»¥æ˜¯æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹

```rust
// 'staticä½œä¸ºå¼•ç”¨ç”Ÿå‘½å‘¨æœŸ
fn print_static_str(s: &'static str) {
    println!("é™æ€å­—ç¬¦ä¸²: {}", s);
}

// æœ‰æ•ˆè°ƒç”¨
print_static_str("å­—é¢é‡ - æœ‰æ•ˆ");
// æ— æ•ˆè°ƒç”¨
let owned = String::from("å †ä¸Šå­—ç¬¦ä¸²");
// print_static_str(&owned); // é”™è¯¯ï¼šé'static

// 'staticä½œä¸ºç±»å‹çº¦æŸ
fn process_static_type<T: 'static>(value: T) {
    // å¤„ç†value
}

// æœ‰æ•ˆè°ƒç”¨
process_static_type("å­—é¢é‡"); // &'static stræ»¡è¶³çº¦æŸ
process_static_type(String::from("owned")); // Stringæ»¡è¶³çº¦æŸ
// æ— æ•ˆè°ƒç”¨
let local = String::from("å±€éƒ¨å˜é‡");
let reference = &local;
// process_static_type(reference); // é”™è¯¯ï¼š&Stringä¸æ»¡è¶³'staticçº¦æŸ
```

#### 3.3.6 ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œä¸çº¦æŸ

ç”Ÿå‘½å‘¨æœŸçº¦æŸè¡¨ç¤ºå¼•ç”¨é—´çš„å…³ç³»ï¼š

```rust
// åŸºæœ¬ç”Ÿå‘½å‘¨æœŸçº¦æŸ
fn for_each_ref<'a, 'b, T>(first: &'a T, second: &'b T, f: impl Fn(&T))
    where 'a: 'b,  // 'aè‡³å°‘å’Œ'bä¸€æ ·é•¿
          T: Debug
{
    f(first);
    f(second);
    println!("first: {:?}, second: {:?}", first, second);
}

// å¤æ‚çº¦æŸ
struct RefWrapper<'a, T: 'a> {
    // T: 'aè¡¨ç¤ºTçš„æ‰€æœ‰å¼•ç”¨å¿…é¡»è‡³å°‘å’Œ'aä¸€æ ·é•¿
    data: &'a T,
}

// ç‰¹å¾å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸ
trait Displayable {
    fn display(&self);
}

fn display_it<'a>(items: &[&'a dyn Displayable]) {
    for item in items {
        item.display();
    }
}
```

é«˜é˜¶ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼š

```rust
// for<'a>è¡¨ç¤ºå¯¹äºä»»ä½•ç”Ÿå‘½å‘¨æœŸ'a
fn process_fn(f: impl for<'a> Fn(&'a i32) -> &'a i32) {
    let local = 42;
    let result = f(&local);
    println!("ç»“æœ: {}", result);
}

// ä½¿ç”¨ç¤ºä¾‹
fn identity(x: &i32) -> &i32 { x }
process_fn(identity);
```

#### 3.3.7 éè¯æ³•ç”Ÿå‘½å‘¨æœŸï¼ˆNLLï¼‰

éè¯æ³•ç”Ÿå‘½å‘¨æœŸï¼ˆNon-Lexical Lifetimesï¼ŒNLLï¼‰æ˜¯Rustå€Ÿç”¨æ£€æŸ¥å™¨çš„ä¼˜åŒ–ï¼š

```rust
// ä¼ ç»Ÿè¯æ³•ç”Ÿå‘½å‘¨æœŸ
fn old_approach() {
    let mut x = 5;
    let r = &mut x; // rçš„ä½œç”¨åŸŸå¼€å§‹
    *r += 1;        // ä½¿ç”¨r
    // rçš„ä½œç”¨åŸŸåœ¨è¿™ä¸ªä½œç”¨åŸŸç»“æŸå‰ç»“æŸ
    // ä¹‹å‰ç‰ˆæœ¬ä¸­ï¼Œråœ¨æ­¤ä½œç”¨åŸŸç»“æŸå‰ä¸€ç›´æœ‰æ•ˆï¼Œå³ä½¿ä¸å†ä½¿ç”¨
    
    // åœ¨æ—§çš„å€Ÿç”¨æ£€æŸ¥å™¨ä¸­ï¼Œæ­¤å¤„æ“ä½œæ— æ•ˆ
    // x += 1; // é”™è¯¯ï¼šxå·²è¢«å¯å˜å€Ÿç”¨
    // println!("x: {}", x);
}

// éè¯æ³•ç”Ÿå‘½å‘¨æœŸ
fn nll_approach() {
    let mut x = 5;
    let r = &mut x;
    *r += 1;
    // rçš„æœ€åä½¿ç”¨ï¼Œå…¶ä½œç”¨åŸŸç»“æŸ
    
    // åœ¨NLLä¸­ï¼Œæ­¤å¤„æ“ä½œæœ‰æ•ˆ
    x += 1; // æœ‰æ•ˆï¼šrä¸å†ä½¿ç”¨
    println!("x: {}", x);
}
```

NLLä¸æ§åˆ¶æµï¼š

```rust
// æ¡ä»¶åˆ†æ”¯ä¸­çš„å€Ÿç”¨
fn conditional_borrow() {
    let mut v = vec![1, 2, 3];
    
    if v.len() > 10 {
        let first = &v[0]; // æ¡ä»¶åˆ†æ”¯ä¸­çš„å€Ÿç”¨
        println!("first: {}", first);
        // åœ¨æ­¤åˆ†æ”¯ä¸­ï¼Œfirstçš„ç”Ÿå‘½å‘¨æœŸç»“æŸ
    }
    
    // å³ä½¿æ¡ä»¶ä¸ºçœŸï¼Œæ­¤å¤„ä¹Ÿæœ‰æ•ˆï¼Œå› ä¸ºfirstçš„ä½œç”¨åŸŸå·²ç»“æŸ
    v.push(4);
    println!("vector: {:?}", v);
}

// å¾ªç¯ä¸­çš„å€Ÿç”¨
fn loop_borrow() {
    let mut values = vec![1, 2, 3];
    
    for value in &values {
        println!("value: {}", value);
        // æ¯æ¬¡è¿­ä»£ç»“æŸï¼Œå½“å‰valueçš„å€Ÿç”¨ç»“æŸ
    }
    
    // å¾ªç¯åå¯ä»¥ä¿®æ”¹values
    values.push(4);
    println!("values: {:?}", values);
}
```

### 3.4 å†…å­˜ç®¡ç†æ¨¡å¼

#### 3.4.1 RAIIæ¨¡å¼

RAIIï¼ˆèµ„æºè·å–å³åˆå§‹åŒ–ï¼‰ç¡®ä¿èµ„æºåœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾ï¼š

```rust
// åŸºæœ¬RAIIæ¨¡å¼
fn basic_raii() {
    // èµ„æºè·å–
    let file = File::open("example.txt").expect("æ— æ³•æ‰“å¼€æ–‡ä»¶");
    // ä½¿ç”¨file...
    // fileç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å…³é—­
}

// è‡ªå®šä¹‰RAIIç±»å‹
struct Resource {
    name: String,
}

impl Resource {
    fn new(name: &str) -> Resource {
        println!("åˆ›å»ºèµ„æº: {}", name);
        Resource { name: name.to_string() }
    }
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("é”€æ¯èµ„æº: {}", self.name);
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰RAIIç±»å‹
fn use_resource() {
    let r1 = Resource::new("first");
    {
        let r2 = Resource::new("second");
        println!("å†…éƒ¨ä½œç”¨åŸŸ");
        // r2åœ¨æ­¤å¤„é”€æ¯
    }
    println!("å¤–éƒ¨ä½œç”¨åŸŸ");
    // r1åœ¨æ­¤å¤„é”€æ¯
}
```

RAIIä¸æ§åˆ¶æµï¼š

```rust
// æå‰è¿”å›æ—¶çš„RAII
fn early_return(flag: bool) {
    let r = Resource::new("dynamic");
    if flag {
        println!("æå‰è¿”å›");
        return; // rä»ä¼šè¢«é”€æ¯
    }
    println!("ç»§ç»­æ‰§è¡Œ");
    // råœ¨å‡½æ•°ç»“æŸæ—¶é”€æ¯
}

// å¼‚å¸¸æƒ…å†µä¸‹çš„RAII
fn exception_safety() {
    let r = Resource::new("protected");
    // å³ä½¿å‘ç”Ÿpanicï¼Œrä»ç„¶ä¼šè¢«æ­£ç¡®æ¸…ç†
    if rand::random() {
        panic!("æ„å¤–é”™è¯¯");
    }
    println!("æ­£å¸¸æ‰§è¡Œ");
}
```

#### 3.4.2 Dropç‰¹å¾ä¸èµ„æºé‡Šæ”¾

`Drop`ç‰¹å¾å…è®¸è‡ªå®šä¹‰èµ„æºé‡Šæ”¾çš„è¡Œä¸ºï¼š

```rust
// Dropç‰¹å¾
trait Drop {
    fn drop(&mut self);
}

// è‡ªå®šä¹‰Dropå®ç°
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("é”€æ¯ CustomSmartPointer: {}", self.data);
    }
}

// ä½¿ç”¨
fn use_drop() {
    let c1 = CustomSmartPointer { data: String::from("first") };
    let c2 = CustomSmartPointer { data: String::from("second") };
    println!("æ™ºèƒ½æŒ‡é’ˆå·²åˆ›å»º");
    // c2å…ˆé”€æ¯ï¼Œç„¶åc1é”€æ¯
}

// æ˜¾å¼åˆ é™¤
fn explicit_drop() {
    let c = CustomSmartPointer { data: String::from("early") };
    println!("æå‰åˆ é™¤...");
    drop(c); // æ˜¾å¼è°ƒç”¨std::mem::dropå‡½æ•°
    println!("åœ¨mainç»“æŸå‰CustomSmartPointerå·²è¢«åˆ é™¤");
}
```

Dropä¸æ‰€æœ‰æƒï¼š

```rust
// Dropä¸æ‰€æœ‰æƒè½¬ç§»
fn move_drops() {
    let c = CustomSmartPointer { data: String::from("will be moved") };
    let d = c; // cçš„æ‰€æœ‰æƒç§»åŠ¨åˆ°d
    println!("cè¢«ç§»åŠ¨åˆ°dï¼Œä»…dä¼šè¢«åˆ é™¤");
    // åªæœ‰dçš„dropè¢«è°ƒç”¨
}

// å®¹å™¨æ¸…ç†é¡ºåº
fn container_drop() {
    let v = vec![
        CustomSmartPointer { data: String::from("item 1") },
        CustomSmartPointer { data: String::from("item 2") },
        CustomSmartPointer { data: String::from("item 3") },
    ];
    println!("å‘é‡å·²åˆ›å»º");
    // å‘é‡é”€æ¯é¡ºåºï¼šitem 3, item 2, item 1ï¼ˆé€†åºæ¸…ç†ï¼‰
}

// Dropå®ç°ä¸­çš„å¤æ‚æ¸…ç†
struct DatabaseConnection {
    url: String,
    connection_id: u32,
}

impl DatabaseConnection {
    fn new(url: &str) -> Self {
        println!("è¿æ¥åˆ°æ•°æ®åº“: {}", url);
        DatabaseConnection {
            url: url.to_string(),
            connection_id: rand::random(),
        }
    }
    
    fn execute(&self, query: &str) {
        println!("æ‰§è¡ŒæŸ¥è¯¢[{}]: {}", self.connection_id, query);
    }
}

impl Drop for DatabaseConnection {
    fn drop(&mut self) {
        // æ¨¡æ‹Ÿå¤æ‚çš„èµ„æºæ¸…ç†è¿‡ç¨‹
        println!("å…³é—­æ•°æ®åº“è¿æ¥: {} (ID: {})", self.url, self.connection_id);
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œå¯èƒ½æ¶‰åŠç½‘ç»œè¿æ¥å…³é—­ã€ç¼“å†²åŒºåˆ·æ–°ç­‰
    }
}
```

Dropçš„é™åˆ¶ï¼š

```rust
// Dropä¸èƒ½è¿”å›é”™è¯¯
impl Drop for CannotFail {
    fn drop(&mut self) {
        // ä¸èƒ½ä½¿ç”¨Resultæˆ–panic
        // å¦‚éœ€å¤„ç†é”™è¯¯ï¼Œåº”è®°å½•æ—¥å¿—æˆ–ä½¿ç”¨å…¶ä»–æ‰‹æ®µ
        if let Err(e) = self.cleanup() {
            eprintln!("æ¸…ç†æ—¶å‡ºé”™: {}", e);
        }
    }
}

// ä¸èƒ½æ‰‹åŠ¨è°ƒç”¨ææ„å‡½æ•°
struct Resource {
    name: String,
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("é”€æ¯èµ„æº: {}", self.name);
    }
}

fn invalid_manual_drop() {
    let r = Resource { name: String::from("test") };
    // r.drop(); // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½ç›´æ¥è°ƒç”¨dropæ–¹æ³•
    
    // æ­£ç¡®æ–¹å¼ï¼šä½¿ç”¨std::mem::drop
    drop(r);
}
```

#### 3.4.3 æ™ºèƒ½æŒ‡é’ˆæ¨¡å¼

æ™ºèƒ½æŒ‡é’ˆæ˜¯å®ç°äº†`Deref`å’Œ`Drop`ç‰¹å¾çš„æ•°æ®ç»“æ„ï¼Œæä¾›è¶…å‡ºæ™®é€šå¼•ç”¨çš„åŠŸèƒ½ï¼š

```rust
// Box<T>ï¼šå †åˆ†é…çš„å€¼
fn box_example() {
    // åœ¨å †ä¸Šåˆ†é…æ•´æ•°
    let b = Box::new(5);
    println!("ç›’å­ä¸­çš„å€¼: {}", b);
    
    // ç”¨äºé€’å½’æ•°æ®ç»“æ„
    enum List {
        Cons(i32, Box<List>),
        Nil,
    }
    
    let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    
    // å¤§å‹æ•°æ®ç§»åŠ¨
    let large_data = [0; 1000000]; // åœ¨æ ˆä¸Šåˆ†é…1MBæ•°ç»„
    let boxed = Box::new(large_data); // ç§»å…¥å †ï¼Œåªå¤åˆ¶æŒ‡é’ˆ
}

// Rc<T>ï¼šå¼•ç”¨è®¡æ•°æŒ‡é’ˆ
use std::rc::Rc;

fn rc_example() {
    // åˆ›å»ºå…±äº«æ•°æ®
    let data = Rc::new(String::from("å…±äº«æ•°æ®"));
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data)); // è¾“å‡º 1
    
    // åˆ›å»ºå¤šä¸ªæ‰€æœ‰è€…
    let data2 = Rc::clone(&data);
    let data3 = Rc::clone(&data);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data)); // è¾“å‡º 3
    
    // å…±äº«è®¿é—®
    println!("å…±äº«æ•°æ®: {}, {}, {}", data, data2, data3);
    
    // data3å…ˆç¦»å¼€ä½œç”¨åŸŸ
    drop(data3);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data)); // è¾“å‡º 2
}

// RefCell<T>ï¼šå†…éƒ¨å¯å˜æ€§
use std::cell::RefCell;

fn refcell_example() {
    // åˆ›å»ºRefCell
    let data = RefCell::new(42);
    
    // ä¸å¯å˜å€Ÿç”¨
    {
        let borrowed = data.borrow();
        println!("å€Ÿç”¨çš„å€¼: {}", borrowed);
    }
    
    // å¯å˜å€Ÿç”¨
    {
        let mut mut_borrowed = data.borrow_mut();
        *mut_borrowed += 1;
    }
    
    println!("ä¿®æ”¹åçš„å€¼: {}", data.borrow());
    
    // è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥
    let ref1 = data.borrow();
    let ref2 = data.borrow();
    // let mut_ref = data.borrow_mut(); // è¿è¡Œæ—¶é”™è¯¯ï¼šå·²æœ‰ä¸å¯å˜å€Ÿç”¨
    
    println!("ref1: {}, ref2: {}", ref1, ref2);
}

// ç»„åˆæ™ºèƒ½æŒ‡é’ˆ
fn combined_pointers() {
    // Rc<RefCell<T>>ï¼šå¤šæ‰€æœ‰è€…å†…éƒ¨å¯å˜æ€§
    let shared_mutable = Rc::new(RefCell::new(vec![1, 2, 3]));
    
    // åˆ›å»ºå…‹éš†
    let shared1 = Rc::clone(&shared_mutable);
    let shared2 = Rc::clone(&shared_mutable);
    
    // é€šè¿‡ä»»ä½•å¼•ç”¨ä¿®æ”¹æ•°æ®
    shared1.borrow_mut().push(4);
    shared2.borrow_mut().push(5);
    
    println!("å…±äº«å‘é‡: {:?}", shared_mutable.borrow());
}
```

è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆï¼š

```rust
// è‡ªå®šä¹‰Boxå®ç°
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

// å®ç°Derefç‰¹å¾
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

// å®ç°Dropç‰¹å¾
impl<T> Drop for MyBox<T> {
    fn drop(&mut self) {
        println!("ä¸¢å¼ƒMyBoxå®ä¾‹");
    }
}

// ä½¿ç”¨
fn use_mybox() {
    let x = 5;
    let y = MyBox::new(x);
    
    // è§£å¼•ç”¨
    assert_eq!(5, *y); // *y ç­‰ä»·äº *(y.deref())
}
```

å¼±å¼•ç”¨ï¼š

```rust
// Weak<T>ï¼šå¼±å¼•ç”¨
use std::rc::Weak;

fn weak_example() {
    // åˆ›å»ºå¼ºå¼•ç”¨
    let strong = Rc::new(String::from("å¼ºå¼•ç”¨æ•°æ®"));
    
    // åˆ›å»ºå¼±å¼•ç”¨
    let weak = Rc::downgrade(&strong);
    println!("å¼ºå¼•ç”¨è®¡æ•°: {}, å¼±å¼•ç”¨è®¡æ•°: {}", 
             Rc::strong_count(&strong), Rc::weak_count(&strong));
    
    // ä½¿ç”¨å¼±å¼•ç”¨
    if let Some(borrowed) = weak.upgrade() {
        println!("å¼±å¼•ç”¨ä»ç„¶æœ‰æ•ˆ: {}", borrowed);
    }
    
    // åˆ é™¤å¼ºå¼•ç”¨
    drop(strong);
    
    // å°è¯•ä½¿ç”¨å¼±å¼•ç”¨
    match weak.upgrade() {
        Some(borrowed) => println!("ä»ç„¶æœ‰æ•ˆ: {}", borrowed),
        None => println!("å¼±å¼•ç”¨å·²å¤±æ•ˆ"),
    }
}

// ä½¿ç”¨Weakæ‰“ç ´å¾ªç¯å¼•ç”¨
fn cyclic_references() {
    // å®šä¹‰èŠ‚ç‚¹ç»“æ„
    struct Node {
        value: i32,
        parent: RefCell<Weak<Node>>,
        children: RefCell<Vec<Rc<Node>>>,
    }
    
    // åˆ›å»ºæ ‘å½¢ç»“æ„
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });
    
    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
    
    // è®¾ç½®å­èŠ‚ç‚¹çš„çˆ¶å¼•ç”¨ä¸ºå¼±å¼•ç”¨
    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
    
    // è®¿é—®çˆ¶èŠ‚ç‚¹
    if let Some(parent) = leaf.parent.borrow().upgrade() {
        println!("å¶å­çš„çˆ¶èŠ‚ç‚¹å€¼: {}", parent.value);
    }
}
```

#### 3.4.4 å†…å­˜å¸ƒå±€å’Œå¯¹é½

ç†è§£Rustä¸­æ•°æ®çš„å†…å­˜å¸ƒå±€å’Œå¯¹é½ï¼š

```rust
// åŸºæœ¬ç±»å‹çš„å†…å­˜å¸ƒå±€
fn basic_layout() {
    println!("i8å¤§å°: {} å­—èŠ‚", std::mem::size_of::<i8>());     // 1
    println!("i32å¤§å°: {} å­—èŠ‚", std::mem::size_of::<i32>());   // 4
    println!("f64å¤§å°: {} å­—èŠ‚", std::mem::size_of::<f64>());   // 8
    println!("boolå¤§å°: {} å­—èŠ‚", std::mem::size_of::<bool>()); // 1
    println!("charå¤§å°: {} å­—èŠ‚", std::mem::size_of::<char>()); // 4
    
    // å¼•ç”¨å¤§å°å–å†³äºç›®æ ‡å¹³å°ï¼ˆ32ä½æˆ–64ä½ï¼‰
    println!("&i32å¤§å°: {} å­—èŠ‚", std::mem::size_of::<&i32>());
}

// ç»“æ„ä½“çš„å†…å­˜å¸ƒå±€
fn struct_layout() {
    // é»˜è®¤å¯¹é½
    struct DefaultStruct {
        a: u8,
        b: u32,
        c: u16,
    }
    
    println!("DefaultStructå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<DefaultStruct>()); // 8æˆ–12å­—èŠ‚ï¼ˆå«å¡«å……ï¼‰
             
    // ç´§å‡‘å¸ƒå±€
    #[repr(packed)]
    struct PackedStruct {
        a: u8,
        b: u32,
        c: u16,
    }
    
    println!("PackedStructå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<PackedStruct>()); // 7å­—èŠ‚ï¼ˆæ— å¡«å……ï¼‰
             
    // Cå…¼å®¹å¸ƒå±€
    #[repr(C)]
    struct CStruct {
        a: u8,
        b: u32,
        c: u16,
    }
    
    println!("CStructå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<CStruct>()); // 12å­—èŠ‚ï¼ˆCå…¼å®¹å¯¹é½ï¼‰
}

// æšä¸¾çš„å†…å­˜å¸ƒå±€
fn enum_layout() {
    // åŸºæœ¬æšä¸¾
    enum BasicEnum {
        A,
        B,
        C,
    }
    
    println!("BasicEnumå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<BasicEnum>()); // é€šå¸¸ä¸º1å­—èŠ‚
             
    // å¸¦æ•°æ®çš„æšä¸¾
    enum DataEnum {
        A(u8),
        B(u32),
        C(String),
    }
    
    println!("DataEnumå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<DataEnum>()); // å¤§å°è¶³ä»¥å®¹çº³æœ€å¤§å˜ä½“+æ ‡è®°
             
    // ç©ºæšä¸¾
    enum Void {} // ä¸èƒ½åˆ›å»ºå®ä¾‹
    
    println!("Voidå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<Void>()); // 0å­—èŠ‚
             
    // Cé£æ ¼æšä¸¾
    #[repr(C)]
    enum CEnum {
        A = 1,
        B = 2,
        C = 4,
    }
    
    println!("CEnumå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<CEnum>()); // é€šå¸¸ä¸º4å­—èŠ‚ï¼ˆCå…¼å®¹ï¼‰
}

// å¯¹é½è¦æ±‚
fn alignment_requirements() {
    println!("i8å¯¹é½: {} å­—èŠ‚", std::mem::align_of::<i8>());     // 1
    println!("i32å¯¹é½: {} å­—èŠ‚", std::mem::align_of::<i32>());   // 4
    println!("f64å¯¹é½: {} å­—èŠ‚", std::mem::align_of::<f64>());   // 8
    
    struct Aligned {
        a: u8,
        b: u32,
    }
    
    println!("Alignedå¯¹é½: {} å­—èŠ‚", 
             std::mem::align_of::<Aligned>()); // é€šå¸¸ä¸º4
             
    #[repr(align(16))]
    struct AlignedTo16 {
        value: u8,
    }
    
    println!("AlignedTo16å¯¹é½: {} å­—èŠ‚", 
             std::mem::align_of::<AlignedTo16>()); // 16
}
```

å†…å­˜å¸ƒå±€ä¼˜åŒ–ï¼š

```rust
// å­—æ®µé‡æ’åºä¼˜åŒ–
fn field_reordering() {
    // ä½æ•ˆå¸ƒå±€ï¼ˆå«å¡«å……ï¼‰
    struct Inefficient {
        a: u8,
        b: u64,
        c: u16,
        d: u32,
    }
    
    // ä¼˜åŒ–å¸ƒå±€ï¼ˆå‡å°‘å¡«å……ï¼‰
    struct Efficient {
        b: u64,
        d: u32,
        c: u16,
        a: u8,
    }
    
    println!("Inefficientå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<Inefficient>()); // 24å­—èŠ‚
    println!("Efficientå¤§å°: {} å­—èŠ‚", 
             std::mem::size_of::<Efficient>());   // 16å­—èŠ‚
}

// é›¶å¤§å°ç±»å‹
fn zero_sized_types() {
    // å•å…ƒç±»å‹
    println!("()å¤§å°: {} å­—èŠ‚", std::mem::size_of::<()>()); // 0
    
    // ç©ºç»“æ„
    struct Empty;
    println!("Emptyå¤§å°: {} å­—èŠ‚", std::mem::size_of::<Empty>()); // 0
    
    // é›¶å¤§å°ç±»å‹åœ¨ä¼˜åŒ–ä¸­è¢«æ¶ˆé™¤
    let many_empties = vec![Empty; 1000];
    println!("1000ä¸ªEmptyçš„å‘é‡å¤§å°: {} å­—èŠ‚", 
             std::mem::size_of_val(&many_empties)); // åªæœ‰å‘é‡å…ƒæ•°æ®çš„å¤§å°
}
```

#### 3.4.5 å†…å­˜æ³„æ¼ä¸é˜²èŒƒ

å°½ç®¡Rustçš„æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢äº†å¤§å¤šæ•°å†…å­˜æ³„æ¼ï¼Œä½†ä»æœ‰å‘ç”Ÿæ³„æ¼çš„å¯èƒ½ï¼š

```rust
// å¾ªç¯å¼•ç”¨å¯¼è‡´çš„å†…å­˜æ³„æ¼
fn reference_cycle() {
    use std::cell::RefCell;
    use std::rc::Rc;
    
    struct Node {
        next: Option<Rc<RefCell<Node>>>,
    }
    
    // åˆ›å»ºå¾ªç¯
    let first = Rc::new(RefCell::new(Node { next: None }));
    let second = Rc::new(RefCell::new(Node { next: None }));
    
    // ç›¸äº’å¼•ç”¨
    first.borrow_mut().next = Some(Rc::clone(&second));
    second.borrow_mut().next = Some(Rc::clone(&first));
    
    // æ­¤æ—¶å³ä½¿firstå’Œsecondç¦»å¼€ä½œç”¨åŸŸï¼ŒèŠ‚ç‚¹ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾
    // å› ä¸ºå®ƒä»¬ä»äº’ç›¸æŒæœ‰å¯¹æ–¹çš„å¼ºå¼•ç”¨
}

// ä¿®å¤ï¼šä½¿ç”¨Weakå¼•ç”¨
fn prevent_cycle() {
    use std::cell::RefCell;
    use std::rc::{Rc, Weak};
    
    struct Node {
        next: Option<Rc<RefCell<Node>>>,
        prev: Option<Weak<RefCell<Node>>>, // ä½¿ç”¨å¼±å¼•ç”¨
    }
    
    // åˆ›å»ºèŠ‚ç‚¹
    let first = Rc::new(RefCell::new(Node { 
        next: None, 
        prev: None,
    }));
    let second = Rc::new(RefCell::new(Node { 
        next: None, 
        prev: None,
    }));
    
    // è®¾ç½®å…³ç³»ï¼šå¼ºå¼•ç”¨å’Œå¼±å¼•ç”¨
    first.borrow_mut().next = Some(Rc::clone(&second));
    second.borrow_mut().prev = Some(Rc::downgrade(&first));
    
    // ç°åœ¨ï¼Œå½“firstç¦»å¼€ä½œç”¨åŸŸï¼Œå®ƒä¼šè¢«æ­£ç¡®é‡Šæ”¾
    // secondä¸­çš„å¼±å¼•ç”¨ä¸ä¼šé˜»æ­¢é‡Šæ”¾
}

// å¿˜è®°è°ƒç”¨.drop()å¯¼è‡´çš„èµ„æºæ³„æ¼
fn resource_leak() {
    use std::fs::File;
    
    // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
    if let Ok(file) = File::create("temp.txt") {
        // å‡è®¾å¿˜è®°dropæ–‡ä»¶
        // åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ–‡ä»¶ä¼šåœ¨ä½œç”¨åŸŸç»“æŸæ—¶å…³é—­
        // ä½†å¦‚æœå‘ç”Ÿpanicæˆ–æå‰è¿”å›ï¼Œå¯èƒ½å¯¼è‡´é—®é¢˜
    }
    
    // ä¿®å¤ï¼šä½¿ç”¨RAIIæ¨¡å¼
    if let Ok(_file) = File::create("safe_temp.txt") {
        // _fileä¼šåœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨å…³é—­
    }
}

// æœ‰æ„çš„"å†…å­˜æ³„æ¼"ï¼šä½¿ç”¨std::mem::forget
fn intentional_leak() {
    let data = vec![1, 2, 3, 4];
    
    // é˜²æ­¢è¿è¡Œææ„å‡½æ•°
    std::mem::forget(data);
    // dataçš„å†…å­˜ä¸ä¼šè¢«é‡Šæ”¾ï¼Œç›´åˆ°ç¨‹åºç»“æŸ
    
    // åˆæ³•ç”¨ä¾‹ï¼š
    // 1. å°†å†…å­˜ç®¡ç†è½¬äº¤ç»™å¦ä¸€ä¸ªç³»ç»Ÿ
    // 2. é¿å…åŒé‡é‡Šæ”¾
    // 3. é¿å…ä¸å®‰å…¨ä»£ç ä¸­çš„ææ„å‡½æ•°å‰¯ä½œç”¨
}

// æ£€æµ‹å†…å­˜æ³„æ¼
fn detect_leaks() {
    // ä½¿ç”¨å·¥å…·æ£€æµ‹æ³„æ¼ï¼š
    // 1. åœ¨å¼€å‘æ—¶ä½¿ç”¨Valgrindæˆ–ç±»ä¼¼å·¥å…·
    // 2. åœ¨ä»£ç ä¸­æ·»åŠ å¼•ç”¨è®¡æ•°æ—¥å¿—
    
    // ç¤ºä¾‹ï¼šè·Ÿè¸ªRcè®¡æ•°
    let data = Rc::new(String::from("leak detection"));
    let data2 = Rc::clone(&data);
    
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data)); // åº”ä¸º2
    drop(data2);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&data)); // åº”ä¸º1
}
```

## 4. é”™è¯¯å¤„ç†

### 4.1 é”™è¯¯å¤„ç†ç­–ç•¥

#### 4.1.1 å¯æ¢å¤é”™è¯¯ä¸Result

Rustä½¿ç”¨`Result`æšä¸¾å¤„ç†å¯æ¢å¤é”™è¯¯ï¼š

```rust
// Resultæšä¸¾å®šä¹‰
enum Result<T, E> {
    Ok(T),    // æˆåŠŸæ—¶åŒ…å«å€¼T
    Err(E),   // é”™è¯¯æ—¶åŒ…å«é”™è¯¯E
}

// åŸºæœ¬ä½¿ç”¨
fn basic_result() {
    use std::fs::File;
    
    // å°è¯•æ‰“å¼€æ–‡ä»¶
    let file_result = File::open("hello.txt");
    
    // å¤„ç†ç»“æœ
    match file_result {
        Ok(file) => println!("æ–‡ä»¶æ‰“å¼€æˆåŠŸ: {:?}", file),
        Err(error) => println!("æ‰“å¼€æ–‡ä»¶å¤±è´¥: {:?}", error),
    }
}

// å¤„ç†ä¸åŒç±»å‹çš„é”™è¯¯
fn handle_different_errors() {
    use std::fs::File;
    use std::io::ErrorKind;
    
    let file_result = File::open("hello.txt");
    
    let file = match file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("åˆ›å»ºæ–‡ä»¶å¤±è´¥: {:?}", e),
            },
            other_error => panic!("æ‰“å¼€æ–‡ä»¶å¤±è´¥: {:?}", other_error),
        },
    };
    
    println!("æ–‡ä»¶: {:?}", file);
}

// ä½¿ç”¨é—­åŒ…ç®€åŒ–é”™è¯¯å¤„ç†
fn using_closures() {
    use std::fs::File;
    use std::io::ErrorKind;
    
    let file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("åˆ›å»ºæ–‡ä»¶å¤±è´¥: {:?}", error);
            })
        } else {
            panic!("æ‰“å¼€æ–‡ä»¶å¤±è´¥: {:?}", error);
        }
    });
    
    println!("æ–‡ä»¶: {:?}", file);
}
```

ç®€å†™æ–¹æ³•ï¼š

```rust
// unwrapå’Œexpect
fn shortcuts() {
    use std::fs::File;
    
    // unwrap: æˆåŠŸè¿”å›å€¼ï¼Œé”™è¯¯åˆ™panic
    let file1 = File::open("existing.txt").unwrap();
    
    // expect: ä¸unwrapç±»ä¼¼ï¼Œä½†æä¾›è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯
    let file2 = File::open("existing.txt")
        .expect("æ— æ³•æ‰“å¼€existing.txtæ–‡ä»¶");
        
    // unwrap_or: æä¾›é»˜è®¤å€¼
    let content = std::fs::read_to_string("config.txt")
        .unwrap_or(String::from("é»˜è®¤é…ç½®"));
        
    // unwrap_or_else: æä¾›è®¡ç®—é»˜è®¤å€¼çš„é—­åŒ…
    let content = std::fs::read_to_string("config.txt")
        .unwrap_or_else(|_| String::from("é»˜è®¤é…ç½®"));
}

// ä¼ æ’­é”™è¯¯
fn propagating_errors() -> Result<String, std::io::Error> {
    use std::fs::File;
    use std::io::Read;
    
    // è¯¦ç»†ç‰ˆæœ¬
    let mut file = match File::open("hello.txt") {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    
    let mut s = String::new();
    
    match file.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}

// ä½¿ç”¨?è¿ç®—ç¬¦ç®€åŒ–é”™è¯¯ä¼ æ’­
fn read_file() -> Result<String, std::io::Error> {
    use std::fs::File;
    use std::io::Read;
    
    // ?è¿ç®—ç¬¦ï¼šæˆåŠŸæ—¶è§£åŒ…å€¼ï¼Œé”™è¯¯åˆ™è¿”å›
    let mut file = File::open("hello.txt")?;
    let mut s = String::new();
    file.read_to_string(&mut s)?;
    Ok(s)
}

// é“¾å¼è°ƒç”¨?è¿ç®—ç¬¦
fn read_file_chained() -> Result<String, std::io::Error> {
    use std::fs::File;
    use std::io::Read;
    
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}

// ä½¿ç”¨æ ‡å‡†åº“å‡½æ•°è¿›ä¸€æ­¥ç®€åŒ–
fn read_file_simple() -> Result<String, std::io::Error> {
    std::fs::read_to_string("hello.txt")
}
```

Resultä¸å‰¯ä½œç”¨ï¼š

```rust
// å¤„ç†å¸¦å‰¯ä½œç”¨çš„æ“ä½œ
fn operations_with_side_effects() -> Result<(), std::io::Error> {
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open("log.txt")?;
        
    // ç¬¬ä¸€ä¸ªæ“ä½œ
    std::io::Write::write_all(&mut file, b"æ—¥å¿—æ¡ç›®1\n")?;
    
    // ç¬¬äºŒä¸ªæ“ä½œ
    std::io::Write::write_all(&mut file, b"æ—¥å¿—æ¡ç›®2\n")?;
    
    // æˆåŠŸå®Œæˆ
    Ok(())
}

// æ•è·?è¿ç®—ç¬¦çš„é”™è¯¯
fn process_operations() {
    match operations_with_side_effects() {
        Ok(()) => println!("æ‰€æœ‰æ“ä½œæˆåŠŸ"),
        Err(e) => {
            println!("æ“ä½œå¤±è´¥: {}", e);
            // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œæ¸…ç†æˆ–æ¢å¤æ“ä½œ
        }
    }
}
```

#### 4.1.2 ä¸å¯æ¢å¤é”™è¯¯ä¸panic

ä¸å¯æ¢å¤é”™è¯¯ä½¿ç”¨`panic!`å®å¤„ç†ï¼š

```rust
// åŸºæœ¬panicç”¨æ³•
fn basic_panic() {
    panic!("å´©æºƒå¹¶ç‡ƒçƒ§");
    // ç¨‹åºç»ˆæ­¢ï¼Œæ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
}

// ä½¿ç”¨ç¯å¢ƒå˜é‡æ§åˆ¶panicè¡Œä¸º
fn panic_behavior() {
    // RUST_BACKTRACE=1 cargo run
    // è®¾ç½®ç¯å¢ƒå˜é‡å¯ä»¥æ˜¾ç¤ºå †æ ˆè·Ÿè¸ª
    
    // ä¹Ÿå¯ä»¥åœ¨Cargo.tomlä¸­è®¾ç½®panicè¡Œä¸ºï¼š
    // [profile.release]
    // panic = "abort"  // å‘ç”Ÿpanicæ—¶ç›´æ¥ç»ˆæ­¢ï¼Œä¸è¿›è¡Œå±•å¼€
}

// panicå †æ ˆè·Ÿè¸ª
fn trace_demo() {
    function_a();
}

fn function_a() {
    function_b();
}

fn function_b() {
    function_c();
}

fn function_c() {
    panic!("åœ¨function_cä¸­è§¦å‘çš„panic");
    // å †æ ˆè·Ÿè¸ªå°†æ˜¾ç¤ºè°ƒç”¨è·¯å¾„ï¼štrace_demo -> function_a -> function_b -> function_c
}

// ä½•æ—¶ä½¿ç”¨panic
fn when_to_panic() {
    // 1. é”™è¯¯æ˜¯ä¸å¯æ¢å¤çš„
    // 2. ç»§ç»­æ‰§è¡Œæ˜¯ä¸å®‰å…¨çš„
    // 3. é”™è¯¯è¡¨ç¤ºç¨‹åºçŠ¶æ€å·²æŸå
    
    // ç¤ºä¾‹ï¼šç±»å‹è½¬æ¢
    let age = "ä¸‰åäºŒ";
    // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—ï¼Œå¦‚æœå¤±è´¥åˆ™panic
    let age_num: u32 = age.parse().expect("å¹´é¾„å¿…é¡»æ˜¯æ•°å­—");
    
    // ç¤ºä¾‹ï¼šæ•°ç»„è¾¹ç•Œæ£€æŸ¥
    let array = [1, 2, 3];
    // è®¿é—®è¶Šç•Œç´¢å¼•ä¼španic
    let item = array[99]; // å¼•å‘panic
}
```

è‡ªå®šä¹‰panicæ¡ä»¶ï¼š

```rust
// æ–­è¨€
fn assertions() {
    let value = -5;
    
    // æ–­è¨€ï¼šæ¡ä»¶ä¸ºfalseæ—¶panic
    assert!(value >= 0, "å€¼å¿…é¡»æ˜¯éè´Ÿæ•°");
    
    // ç›¸ç­‰æ€§æ–­è¨€
    let actual = 2 + 2;
    assert_eq!(actual, 4, "2+2åº”è¯¥ç­‰äº4");
    
    // ä¸ç­‰æ–­è¨€
    assert_ne!(actual, 5, "2+2ä¸åº”è¯¥ç­‰äº5");
}

// è‡ªå®šä¹‰panicæ¡ä»¶
fn validate_input(age: i32) {
    if age < 0 {
        panic!("å¹´é¾„ä¸èƒ½ä¸ºè´Ÿæ•°: {}", age);
    }
    
    if age > 150 {
        panic!("å¹´é¾„ä¸å¤ªå¯èƒ½è¶…è¿‡150: {}", age);
    }
    
    println!("éªŒè¯é€šè¿‡: å¹´é¾„ä¸º{}", age);
}

// è°ƒè¯•æ–­è¨€
fn debug_assertions() {
    // debug_assert! ä»…åœ¨è°ƒè¯•æ„å»ºä¸­æ£€æŸ¥ï¼Œå‘å¸ƒæ„å»ºä¸­å¿½ç•¥
    let x = 5;
    debug_assert!(x < 10, "xå¤ªå¤§");
    debug_assert_eq!(x, 5, "xåº”è¯¥ç­‰äº5");
    debug_assert_ne!(x, 0, "xä¸åº”ä¸º0");
}
```

#### 4.1.3 Optionä¸ç©ºå€¼å¤„ç†

`Option`æšä¸¾ç”¨äºè¡¨ç¤ºå¯èƒ½çš„ç¼ºå¤±å€¼ï¼š

```rust
// Optionæšä¸¾å®šä¹‰
enum Option<T> {
    Some(T), // å­˜åœ¨å€¼
    None,    // ç¼ºå°‘å€¼
}

// åŸºæœ¬ä½¿ç”¨
fn basic_option() {
    let some_number = Some(5);
    let some_string = Some("ä¸€ä¸ªå­—ç¬¦ä¸²");
    let absent_number: Option<i32> = None;
    
    // ä½¿ç”¨matchæå–å€¼
    match some_number {
        Some(n) => println!("æ•°å­—æ˜¯: {}", n),
        None => println!("æ²¡æœ‰æ•°å­—"),
    }
}

// Optionä¸ç©ºå€¼çš„åŒºåˆ«
fn option_vs_null() {
    // åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼š
    // int x = null; // å¯ä»¥ï¼Œä½†å±é™©
    
    // åœ¨Rustä¸­ï¼š
    // let x: i32 = None; // ç¼–è¯‘é”™è¯¯ï¼šNoneä¸æ˜¯i32ç±»å‹
    let y: Option<i32> = None; // æ­£ç¡®ï¼šæ˜¾å¼å£°æ˜Option
    
    // åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼š
    // int result = x + 5; // å¦‚æœxä¸ºnullï¼Œåˆ™è¿è¡Œæ—¶é”™è¯¯
    
    // åœ¨Rustä¸­ï¼š
    // let result = y + 5; // ç¼–è¯‘é”™è¯¯ï¼šOption<i32>ä¸èƒ½ç›´æ¥ä¸i32è¿ç®—
    
    // å¿…é¡»å…ˆè§£åŒ…Option
    let result = match y {
        Some(n) => n + 5,
        None => 0, // æä¾›é»˜è®¤å€¼
    };
    println!("ç»“æœ: {}", result);
}

// å¤„ç†Option
fn handle_option() {
    let name: Option<String> = Some(String::from("Alice"));
    
    // æ–¹æ³•1ï¼šmatchè¡¨è¾¾å¼
    match name {
        Some(n) => println!("åå­—: {}", n),
        None => println!("åŒ¿å"),
    }
    
    // æ–¹æ³•2ï¼šif letç®€å†™
    if let Some(n) = name {
        println!("åå­—: {}", n);
    } else {
        println!("åŒ¿å");
    }
    
    // æ–¹æ³•3ï¼šmapæ–¹æ³•
    let greeting = name.map(|n| format!("ä½ å¥½, {}", n));
    println!("é—®å€™: {:?}", greeting);
    
    // æ–¹æ³•4ï¼šand_thenæ–¹æ³•ï¼ˆflatMapï¼‰
    let verbose_name = name.and_then(|n| {
        if n.is_empty() {
            None
        } else {
            Some(format!("ç”¨æˆ· {}", n))
        }
    });
    println!("è¯¦ç»†åç§°: {:?}", verbose_name);
}

// Optionæ–¹æ³•
fn option_methods() {
    // is_some & is_none
    let x = Some(5);
    if x.is_some() {
        println!("xåŒ…å«å€¼");
    }
    if x.is_none() {
        println!("xä¸åŒ…å«å€¼");
    }
    
    // unwrapï¼šè·å–å€¼æˆ–panic
    let value = x.unwrap(); // å¦‚æœæ˜¯Noneåˆ™panic
    println!("å€¼: {}", value);
    
    // unwrap_orï¼šæä¾›é»˜è®¤å€¼
    let y: Option<i32> = None;
    let default_value = y.unwrap_or(0);
    println!("é»˜è®¤å€¼: {}", default_value);
    
    // unwrap_or_elseï¼šä½¿ç”¨é—­åŒ…æä¾›é»˜è®¤å€¼
    let default_calculated = y.unwrap_or_else(|| {
        println!("è®¡ç®—é»˜è®¤å€¼");
        42
    });
    println!("è®¡ç®—çš„é»˜è®¤å€¼: {}", default_calculated);
    
    // expectï¼šç±»ä¼¼unwrapï¼Œä½†æœ‰å®šåˆ¶æ¶ˆæ¯
    let value = x.expect("xåº”è¯¥æœ‰å€¼");
    println!("å€¼: {}", value);
}

// Optionç»„åˆå™¨
fn option_combinators() {
    let value = Some(5);
    
    // mapï¼šè½¬æ¢Someå€¼
    let mapped = value.map(|x| x * 2);
    println!("æ˜ å°„å: {:?}", mapped); // Some(10)
    
    // filterï¼šåŸºäºæ¡ä»¶è¿‡æ»¤
    let filtered = value.filter(|x| *x > 10);
    println!("è¿‡æ»¤å: {:?}", filtered); // None
    
    // and_thenï¼šé“¾å¼æ“ä½œï¼Œç±»ä¼¼flatMap
    let chained = value
        .and_then(|x| if x < 10 { Some(x * 2) } else { None });
    println!("é“¾å¼å¤„ç†å: {:?}", chained); // Some(10)
    
    // orï¼šæä¾›å¤‡é€‰Option
    let a: Option<i32> = None;
    let b = Some(10);
    let result = a.or(b);
    println!("aæˆ–b: {:?}", result); // Some(10)
    
    // or_elseï¼šæä¾›è®¡ç®—å¤‡é€‰Optionçš„é—­åŒ…
    let c = a.or_else(|| {
        println!("è®¡ç®—å¤‡é€‰é€‰é¡¹");
        Some(42)
    });
    println!("å¤‡é€‰é€‰é¡¹: {:?}", c); // Some(42)
}

// ç»„åˆå¤šä¸ªOption
fn combining_options() {
    let width = Some(10);
    let height = Some(5);
    let depth = None;
    
    // è®¡ç®—ä½“ç§¯ï¼ˆæ‰€æœ‰å€¼éƒ½éœ€è¦å­˜åœ¨ï¼‰
    let volume = match (width, height, depth) {
        (Some(w), Some(h), Some(d)) => Some(w * h * d),
        _ => None,
    };
    println!("ä½“ç§¯: {:?}", volume); // None
    
    // ä½¿ç”¨zipå’Œmap
    let width = Some(10);
    let height = Some(5);
    let area = width.zip(height).map(|(w, h)| w * h);
    println!("é¢ç§¯: {:?}", area); // Some(50)
    
    // ä½¿ç”¨and_thené“¾å¼å¤„ç†
    let config_max = Some(3);
    let input = "5";
    
    let result = config_max
        .and_then(|max| input.parse::<i32>().ok())
        .and_then(|input_num| {
            if input_num <= max {
                Some(input_num)
            } else {
                None
            }
        });
    
    println!("å¤„ç†ç»“æœ: {:?}", result); // Noneï¼Œå› ä¸º5>3
}
```

#### 4.1.4 è‡ªå®šä¹‰é”™è¯¯ç±»å‹

åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯ç±»å‹æ»¡è¶³ç‰¹å®šéœ€æ±‚ï¼š

```rust
// åŸºæœ¬è‡ªå®šä¹‰é”™è¯¯
#[derive(Debug)]
enum AppError {
    FileError,
    ParseError,
    NetworkError,
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AppError::FileError => write!(f, "æ–‡ä»¶æ“ä½œé”™è¯¯"),
            AppError::ParseError => write!(f, "è§£æé”™è¯¯"),
            AppError::NetworkError => write!(f, "ç½‘ç»œé”™è¯¯"),
        }
    }
}

// å¸¦æ•°æ®çš„é”™è¯¯
#[derive(Debug)]
enum DetailedError {
    FileError { path: String, message: String },
    ParseError { line: usize, column: usize, message: String },
    NetworkError { url: String, code: u32 },
}

impl std::fmt::Display for DetailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            DetailedError::FileError { path, message } => 
                write!(f, "æ–‡ä»¶é”™è¯¯[{}]: {}", path, message),
            DetailedError::ParseError { line, column, message } => 
                write!(f, "è§£æé”™è¯¯[{}:{}]: {}", line, column, message),
            DetailedError::NetworkError { url, code } => 
                write!(f, "ç½‘ç»œé”™è¯¯[{}]: çŠ¶æ€ç  {}", url, code),
        }
    }
}
```

å®ç°Errorç‰¹å¾ï¼š

```rust
// å®ç°æ ‡å‡†Errorç‰¹å¾
use std::error::Error;

impl Error for AppError {}

impl Error for DetailedError {}

// ä»å…¶ä»–é”™è¯¯ç±»å‹è½¬æ¢
impl From<std::io::Error> for AppError {
    fn from(_: std::io::Error) -> Self {
        AppError::FileError
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(_: std::num::ParseIntError) -> Self {
        AppError::ParseError
    }
}

// ä½¿ç”¨è½¬æ¢è¿›è¡Œé”™è¯¯ä¼ æ’­
fn read_config() -> Result<i32, AppError> {
    // std::io::Errorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    let content = std::fs::read_to_string("config.txt")?;
    
    // std::num::ParseIntErrorè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    let value = content.trim().parse::<i32>()?;
    
    Ok(value)
}

// æ„å»ºå¤æ‚é”™è¯¯ç±»å‹
struct Context {
    line: usize,
    column: usize,
}

#[derive(Debug)]
enum ComplexError {
    Io(std::io::Error),
    Parse {
        source: std::num::ParseIntError,
        context: Context,
    },
    Validation(String),
}

impl std::fmt::Display for ComplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ComplexError::Io(err) => write!(f, "IOé”™è¯¯: {}", err),
            ComplexError::Parse { source, context } => {
                write!(f, "è§£æé”™è¯¯[{}:{}]: {}", context.line, context.column, source)
            }
            ComplexError::Validation(msg) => write!(f, "éªŒè¯é”™è¯¯: {}", msg),
        }
    }
}

impl Error for ComplexError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            ComplexError::Io(err) => Some(err),
            ComplexError::Parse { source, .. } => Some(source),
            ComplexError::Validation(_) => None,
        }
    }
}
```

ä½¿ç”¨`thiserror`ç®€åŒ–é”™è¯¯å®šä¹‰ï¼š

```rust
// ä½¿ç”¨thiserrorå®
use thiserror::Error;

#[derive(Error, Debug)]
enum ServiceError {
    #[error("æ–‡ä»¶é”™è¯¯: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("è§£æé”™è¯¯: {source} at line {line}")]
    Parse {
        line: usize,
        #[source] source: std::num::ParseIntError,
    },
    
    #[error("é…ç½®æ— æ•ˆ: {0}")]
    InvalidConfig(String),
    
    #[error("è®¤è¯å¤±è´¥")]
    Unauthorized,
}
```

è‡ªå®šä¹‰Resultç±»å‹ï¼š

```rust
// è‡ªå®šä¹‰Resultåˆ«å
type AppResult<T> = Result<T, AppError>;

// ä½¿ç”¨è‡ªå®šä¹‰Result
fn process_data() -> AppResult<String> {
    let data = std::fs::read_to_string("data.txt")?;
    if data.trim().is_empty() {
        return Err(AppError::ParseError);
    }
    Ok(format!("å¤„ç†åçš„æ•°æ®: {}", data))
}

// å¤šå±‚æ¬¡é”™è¯¯
mod database {
    #[derive(Debug)]
    pub enum DbError {
        ConnectionFailed,
        QueryFailed,
        TransactionFailed,
    }
    
    impl std::fmt::Display for DbError {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            match self {
                DbError::ConnectionFailed => write!(f, "æ•°æ®åº“è¿æ¥å¤±è´¥"),
                DbError::QueryFailed => write!(f, "æŸ¥è¯¢æ‰§è¡Œå¤±è´¥"),
                DbError::TransactionFailed => write!(f, "äº‹åŠ¡æ‰§è¡Œå¤±è´¥"),
            }
        }
    }
    
    impl std::error::Error for DbError {}
    
    pub type DbResult<T> = Result<T, DbError>;
}

// é”™è¯¯è½¬æ¢
impl From<database::DbError> for AppError {
    fn from(err: database::DbError) -> Self {
        match err {
            database::DbError::ConnectionFailed => AppError::NetworkError,
            _ => AppError::FileError, // ç®€åŒ–ç¤ºä¾‹
        }
    }
}

// æ•´åˆä½¿ç”¨
fn integrated_example() -> AppResult<()> {
    // æ•°æ®åº“æ“ä½œå¯èƒ½è¿”å›DbErrorï¼Œè‡ªåŠ¨è½¬æ¢ä¸ºAppError
    let _db_result: database::DbResult<()> = Err(database::DbError::ConnectionFailed);
    let _app_result: AppResult<()> = _db_result?;
    
    Ok(())
}
```

### 4.2 é«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼

#### 4.2.1 é”™è¯¯ä¸Šä¸‹æ–‡å’Œæ•…éšœä¼ æ’­

ä¸ºé”™è¯¯æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯ä»¥è·å¾—æ›´æœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯ï¼š

```rust
// ä½¿ç”¨anyhowæ·»åŠ ä¸Šä¸‹æ–‡
use anyhow::{Context, Result};

fn read_config_file() -> Result<String> {
    let path = "config.txt";
    std::fs::read_to_string(path)
        .with_context(|| format!("æ— æ³•è¯»å–é…ç½®æ–‡ä»¶: {}", path))
}

fn parse_config(content: &str) -> Result<i32> {
    content.trim().parse::<i32>()
        .with_context(|| format!("é…ç½®æ ¼å¼æ— æ•ˆ: '{}'", content))
}

fn load_config() -> Result<i32> {
    let content = read_config_file()?;
    parse_config(&content)
}

// è‡ªå®šä¹‰ä¸Šä¸‹æ–‡
fn custom_context() -> Result<(), DetailedError> {
    let path = "data.txt";
    let content = match std::fs::read_to_string(path) {
        Ok(content) => content,
        Err(err) => {
            return Err(DetailedError::FileError {
                path: path.to_string(),
                message: format!("{}", err),
            });
        }
    };
    
    // ç»§ç»­å¤„ç†...
    Ok(())
}

// é“¾å¼é”™è¯¯
fn chain_errors() -> Result<()> {
    let config = read_config_file()
        .context("åŠ è½½é…ç½®æ–‡ä»¶æ—¶å‡ºé”™")?;
    
    let value = parse_config(&config)
        .context("è§£æé…ç½®å¤±è´¥")?;
    
    if value < 0 {
        anyhow::bail!("é…ç½®å€¼å¿…é¡»ä¸ºæ­£æ•°ï¼Œä½†å¾—åˆ°äº† {}", value);
    }
    
    Ok(())
}
```

è‡ªå®šä¹‰é”™è¯¯å±‚æ¬¡ç»“æ„ï¼š

```rust
// åŸºæœ¬å’Œä¸“ç”¨é”™è¯¯
trait AppErrorTrait: Error + Send + Sync + 'static {}

#[derive(Debug, Error)]
enum UserError {
    #[error("æ— æ•ˆçš„ç”¨æˆ·å: {0}")]
    InvalidUsername(String),
    
    #[error("å¯†ç å¤ªçŸ­")]
    PasswordTooShort,
    
    #[error("ç”¨æˆ·å·²å­˜åœ¨")]
    UserExists,
}

#[derive(Debug, Error)]
enum DataError {
    #[error("æ— æ³•è¿æ¥åˆ°æ•°æ®åº“: {0}")]
    ConnectionFailed(String),
    
    #[error("æŸ¥è¯¢å¤±è´¥: {0}")]
    QueryFailed(String),
}

// é¡¶å±‚é”™è¯¯ç±»å‹
#[derive(Debug, Error)]
enum ApplicationError {
    #[error("ç”¨æˆ·é”™è¯¯: {0}")]
    User(#[from] UserError),
    
    #[error("æ•°æ®é”™è¯¯: {0}")]
    Data(#[from] DataError),
    
    #[error("IOé”™è¯¯: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("å…¶ä»–é”™è¯¯: {0}")]
    Other(String),
}

// å„æ¨¡å—ä½¿ç”¨è‡ªå·±çš„é”™è¯¯ç±»å‹
fn validate_user(username: &str) -> Result<(), UserError> {
    if username.is_empty() {
        return Err(UserError::InvalidUsername(username.to_string()));
    }
    Ok(())
}

// é¡¶å±‚ä½¿ç”¨ç»Ÿä¸€é”™è¯¯ç±»å‹
fn register_user(username: &str) -> Result<(), ApplicationError> {
    validate_user(username)?; // UserErrorè‡ªåŠ¨è½¬æ¢ä¸ºApplicationError
    // å…¶ä»–æ“ä½œ...
    Ok(())
}
```

#### 4.2.2 é”™è¯¯è¾¹ç•Œä¸æ¢å¤ç­–ç•¥

å»ºç«‹é”™è¯¯è¾¹ç•Œå’Œæ¢å¤ç­–ç•¥ï¼š

```rust
// è¾¹ç•Œå¤„ç†æ¨¡å¼
fn error_boundary() {
    // 1. æ”¶é›†é”™è¯¯å¹¶ç»§ç»­
    let mut errors = Vec::new();
    
    for file in &["file1.txt", "file2.txt", "file3.txt"] {
        match std::fs::read_to_string(file) {
            Ok(content) => println!("è¯»å–æ–‡ä»¶ {}: {} å­—èŠ‚", file, content.len()),
            Err(err) => errors.push(format!("æ— æ³•è¯»å– {}: {}", file, err)),
        }
    }
    
    if !errors.is_empty() {
        println!("å‘ç”Ÿäº†ä»¥ä¸‹é”™è¯¯:");
        for error in errors {
            println!("- {}", error);
        }
    }
    
    // 2. éƒ¨åˆ†æ¢å¤
    let result = std::fs::read_to_string("important.txt");
    match result {
        Ok(content) => println!("è¯»å–æˆåŠŸ: {}", content),
        Err(err) => {
            println!("ä½¿ç”¨é»˜è®¤å€¼: {}", err);
            // åˆ›å»ºç©ºæ–‡ä»¶ä½œä¸ºæ¢å¤ç­–ç•¥
            if let Err(create_err) = std::fs::write("important.txt", "é»˜è®¤å†…å®¹") {
                println!("æ— æ³•åˆ›å»ºé»˜è®¤æ–‡ä»¶: {}", create_err);
            }
        }
    }
}

// é‡è¯•ç­–ç•¥
fn retry_strategy<F, T, E>(mut operation: F, max_attempts: usize) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    let mut last_error: Option<E> = None;
    
    while attempts < max_attempts {
        match operation() {
            Ok(value) => return Ok(value),
            Err(err) => {
                attempts += 1;
                if attempts == max_attempts {
                    return Err(err);
                }
                last_error = Some(err);
                std::thread::sleep(std::time::Duration::from_millis(100 * attempts as u64));
            }
        }
    }
    
    Err(last_error.unwrap())
}

// ä½¿ç”¨é‡è¯•ç­–ç•¥
fn use_retry() {
    let result = retry_strategy(|| {
        // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
        if rand::random::<f32>() < 0.8 {
            Err("æ“ä½œå¤±è´¥")
        } else {
            Ok("æ“ä½œæˆåŠŸ")
        }
    }, 3);
    
    match result {
        Ok(value) => println!("æœ€ç»ˆç»“æœ: {}", value),
        Err(err) => println!("é‡è¯•åä»ç„¶å¤±è´¥: {}", err),
    }
}

// é™çº§ç­–ç•¥
fn graceful_degradation() -> String {
    // å°è¯•ä¸»è¦åŠŸèƒ½
    let primary_result = std::fs::read_to_string("data.json");
    
    match primary_result {
        Ok(data) => {
            // å°è¯•è§£æJSON
            match serde_json::from_str::<serde_json::Value>(&data) {
                Ok(json) => format!("å®Œæ•´åŠŸèƒ½: {}", json),
                Err(_) => {
                    // é™çº§ï¼šä½¿ç”¨åŸå§‹æ–‡æœ¬
                    println!("è­¦å‘Š: æ— æ³•è§£æJSONï¼Œé™çº§ä¸ºåŸå§‹æ–‡æœ¬");
                    format!("é™çº§åŠŸèƒ½: {}", data)
                }
            }
        }
        Err(_) => {
            // é™çº§ï¼šä½¿ç”¨å¤‡ä»½æ•°æ®
            println!("è­¦å‘Š: æ— æ³•è¯»å–ä¸»æ•°æ®ï¼Œé™çº§ä¸ºå¤‡ä»½");
            String::from("é™çº§åŠŸèƒ½: å¤‡ä»½æ•°æ®")
        }
    }
}
```

#### 4.2.3 é”™è¯¯æ—¥å¿—ä¸ç›‘æ§

è®°å½•å’Œç›‘æ§é”™è¯¯ä»¥è·Ÿè¸ªåº”ç”¨ç¨‹åºå¥åº·çŠ¶å†µï¼š

```rust
// åŸºæœ¬æ—¥å¿—è®°å½•
fn log_errors() {
    use log::{error, info, warn};
    
    let result = std::fs::read_to_string("file.txt");
    match result {
        Ok(content) => {
            info!("æˆåŠŸè¯»å–æ–‡ä»¶ï¼Œå¤§å°: {} å­—èŠ‚", content.len());
            // å¤„ç†å†…å®¹...
        }
        Err(err) => {
            // è®°å½•é”™è¯¯è¯¦æƒ…
            error!("è¯»å–æ–‡ä»¶å¤±è´¥: {}", err);
            // å¯ä»¥åŒæ—¶è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡
            if err.kind() == std::io::ErrorKind::NotFound {
                warn!("æ–‡ä»¶å¯èƒ½å·²è¢«ç§»åŠ¨æˆ–åˆ é™¤ï¼Œå°è¯•é‡æ–°åˆ›å»º");
                // æ¢å¤æ“ä½œ...
            }
        }
    }
}

// ç»“æ„åŒ–é”™è¯¯æ—¥å¿—
fn structured_logging(err: &dyn Error) {
    // è®°å½•é”™è¯¯é“¾
    let mut current_err = Some(err);
    let mut depth = 0;
    
    while let Some(err) = current_err {
        eprintln!("é”™è¯¯å±‚çº§ {}: {}", depth, err);
        depth += 1;
        current_err = err.source();
    }
    
    // å¯ä»¥å°†é”™è¯¯ä¿¡æ¯å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    // monitor::send_error(&format!("å‘ç”Ÿé”™è¯¯: {}", err));
}

// æ—¥å¿—ä¸Šä¸‹æ–‡
fn log_with_context<T, E: std::fmt::Display>(
    result: Result<T, E>,
    context: &str,
) -> Result<T, E> {
    if let Err(ref err) = result {
        eprintln!("{}: {}", context, err);
        // å¯ä»¥æ·»åŠ æ›´å¤šä¸Šä¸‹æ–‡ï¼Œå¦‚æ—¶é—´æˆ³ã€è¯·æ±‚IDç­‰
    }
    result
}

// ä½¿ç”¨æ—¥å¿—ä¸Šä¸‹æ–‡
fn use_logging() -> Result<(), std::io::Error> {
    log_with_context(
        std::fs::read_to_string("config.txt"),
        "è¯»å–é…ç½®æ–‡ä»¶æ—¶å‡ºé”™"
    )?;
    
    Ok(())
}
```

## 5. æ¨¡å—ä¸åŒ…ç®¡ç†

### 5.1 æ¨¡å—ç³»ç»Ÿ

#### 5.1.1 æ¨¡å—åŸºç¡€

Rustä½¿ç”¨æ¨¡å—ç³»ç»Ÿç»„ç»‡ä»£ç å’Œç®¡ç†å¯è§æ€§ï¼š

```rust
// åŸºæœ¬æ¨¡å—å®šä¹‰
mod math {
    // æ¨¡å—å†…éƒ¨å‡½æ•°
    fn private_function() {
        println!("è¿™æ˜¯ç§æœ‰å‡½æ•°");
    }
    
    // å…¬å¼€å‡½æ•°
    pub fn add(a: i32, b: i32) -> i32 {
        private_function(); // å¯ä»¥è®¿é—®åŒæ¨¡å—ç§æœ‰å‡½æ•°
        a + b
    }
    
    pub fn subtract(a: i32, b: i32) -> i32 {
        a - b
    }
    
    // åµŒå¥—æ¨¡å—
    pub mod advanced {
        pub fn multiply(a: i32, b: i32) -> i32 {
            a * b
        }
        
        fn divide(a: i32, b: i32) -> Option<i32> {
            if b == 0 {
                None
            } else {
                Some(a / b)
            }
        }
        
        // å…¬å¼€å†…éƒ¨å‡½æ•°
        pub fn safe_divide(a: i32, b: i32) -> Option<i32> {
            divide(a, b)
        }
    }
}

// ä½¿ç”¨æ¨¡å—å†…å®¹
fn use_modules() {
    // ç›´æ¥ä½¿ç”¨å®Œæ•´è·¯å¾„
    let sum = math::add(2, 3);
    println!("2 + 3 = {}", sum);
    
    // è®¿é—®åµŒå¥—æ¨¡å—
    let product = math::advanced::multiply(4, 5);
    println!("4 * 5 = {}", product);
    
    // ç§æœ‰é¡¹ä¸å¯è®¿é—®
    // let quotient = math::advanced::divide(10, 2); // é”™è¯¯ï¼šç§æœ‰å‡½æ•°
    
    // é€šè¿‡å…¬å¼€æ¥å£è®¿é—®
    if let Some(result) = math::advanced::safe_divide(10, 2) {
        println!("10 / 2 = {}", result);
    }
}
```

ä½¿ç”¨`use`å…³é”®å­—å¯¼å…¥æ¨¡å—å†…å®¹ï¼š

```rust
// åŸºæœ¬å¯¼å…¥
use math::add;
use math::advanced::multiply;

fn basic_imports() {
    // ç›´æ¥ä½¿ç”¨å¯¼å…¥çš„å‡½æ•°
    let sum = add(5, 7);
    let product = multiply(3, 4);
    println!("5 + 7 = {}, 3 * 4 = {}", sum, product);
}

// å¤šç§å¯¼å…¥è¯­æ³•
mod imports_demo {
    // å•ä¸ªé¡¹å¯¼å…¥
    use crate::math::add;
    
    // å¤šé¡¹å¯¼å…¥
    use crate::math::{subtract, advanced::multiply};
    
    // é‡å‘½åå¯¼å…¥
    use crate::math::add as addition;
    
    // å…¨è·¯å¾„å¯¼å…¥
    use crate::math::advanced::safe_divide;
    
    // å¯¼å…¥æ‰€æœ‰å…¬å¼€é¡¹
    use crate::math::advanced::*;
    
    pub fn demo() {
        let a = add(1, 2);
        let b = subtract(5, 3);
        let c = multiply(2, 4);
        let d = addition(3, 5);
        let e = safe_divide(10, 2);
        println!("ç»“æœ: {}, {}, {}, {}, {:?}", a, b, c, d, e);
    }
}

// åµŒå¥—è·¯å¾„å¯¼å…¥
use std::{fs, io::{self, Read}};

fn nested_imports() {
    let mut file = fs::File::open("text.txt").unwrap();
    let mut content = String::new();
    file.read_to_string(&mut content).unwrap();
    println!("æ–‡ä»¶å†…å®¹: {}", content);
}
```

#### 5.1.2 å¯è§æ€§è§„åˆ™

Rustä½¿ç”¨`pub`å…³é”®å­—æ§åˆ¶é¡¹çš„å¯è§æ€§ï¼š

```rust
// åŸºæœ¬å¯è§æ€§è§„åˆ™
mod visibility {
    // ç§æœ‰é»˜è®¤ï¼šåªåœ¨å½“å‰æ¨¡å—å¯è§
    fn private_function() {
        println!("è¿™æ˜¯ç§æœ‰å‡½æ•°");
    }
    
    // å…¬å¼€ï¼šå¯¹å¤–éƒ¨å¯è§
    pub fn public_function() {
        println!("è¿™æ˜¯å…¬å¼€å‡½æ•°");
        private_function(); // å¯ä»¥è®¿é—®åŒæ¨¡å—çš„ç§æœ‰é¡¹
    }
    
    // å…¬å¼€ç»“æ„ä½“
    pub struct User {
        pub name: String,   // å…¬å¼€å­—æ®µ
        nickname: String,   // ç§æœ‰å­—æ®µ
        pub age: u32,       // å…¬å¼€å­—æ®µ
    }
    
    impl User {
        // å…¬å¼€æ„é€ å‡½æ•°
        pub fn new(name: String, nickname: String, age: u32) -> User {
            User { name, nickname, age }
        }
        
        // è®¿é—®ç§æœ‰å­—æ®µçš„å…¬å¼€æ–¹æ³•
        pub fn nickname(&self) -> &str {
            &self.nickname
        }
        
        // ç§æœ‰æ–¹æ³•
        fn validate(&self) -> bool {
            !self.name.is_empty() && self.age > 0
        }
        
        // ä½¿ç”¨ç§æœ‰æ–¹æ³•çš„å…¬å¼€æ–¹æ³•
        pub fn is_valid(&self) -> bool {
            self.validate()
        }
    }
    
    // å…¬å¼€æšä¸¾
    pub enum Status {
        Active,    // æšä¸¾å˜ä½“è‡ªåŠ¨å…¬å¼€
        Inactive,
        Suspended,
    }
}

// ä½¿ç”¨å¸¦å¯è§æ€§çš„æ¨¡å—
fn use_visibility() {
    // è®¿é—®å…¬å¼€å‡½æ•°
    visibility::public_function();
    
    // åˆ›å»ºå…¬å¼€ç»“æ„ä½“
    let user = visibility::User::new(
        String::from("å¼ ä¸‰"),
        String::from("å°å¼ "),
        30
    );
    
    // è®¿é—®å…¬å¼€å­—æ®µ
    println!("ç”¨æˆ·: {}, {} å²", user.name, user.age);
    
    // æ— æ³•è®¿é—®ç§æœ‰å­—æ®µ
    // println!("æ˜µç§°: {}", user.nickname); // é”™è¯¯ï¼šç§æœ‰å­—æ®µ
    
    // é€šè¿‡å…¬å¼€æ–¹æ³•è®¿é—®ç§æœ‰å­—æ®µ
    println!("æ˜µç§°: {}", user.nickname());
    
    // ä½¿ç”¨å…¬å¼€æšä¸¾
    let status = visibility::Status::Active;
    match status {
        visibility::Status::Active => println!("ç”¨æˆ·æ´»è·ƒ"),
        visibility::Status::Inactive => println!("ç”¨æˆ·ä¸æ´»è·ƒ"),
        visibility::Status::Suspended => println!("ç”¨æˆ·å·²æš‚åœ"),
    }
}
```

é™åˆ¶å¯è§æ€§ï¼š

```rust
// superå…³é”®å­—ï¼šè®¿é—®çˆ¶æ¨¡å—
mod parent {
    pub fn parent_function() {
        println!("çˆ¶æ¨¡å—å‡½æ•°");
    }
    
    mod child {
        pub fn child_function() {
            println!("å­æ¨¡å—å‡½æ•°");
            super::parent_function(); // è®¿é—®çˆ¶æ¨¡å—å‡½æ•°
        }
        
        pub fn call_grand_parent() {
            super::super::root_function(); // è®¿é—®çˆ¶æ¨¡å—çš„çˆ¶æ¨¡å—
        }
    }
    
    pub fn call_child() {
        child::child_function();
    }
}

fn root_function() {
    println!("æ ¹æ¨¡å—å‡½æ•°");
}

// å—é™å…¬å¼€å¯è§æ€§
mod restricted {
    pub(crate) fn crate_visible() {
        // åªå¯¹å½“å‰crateå¯è§ï¼Œå¯¹å¤–éƒ¨crateä¸å¯è§
        println!("å¯¹crateå¯è§");
    }
    
    pub(super) fn parent_visible() {
        // åªå¯¹çˆ¶æ¨¡å—å¯è§
        println!("å¯¹çˆ¶æ¨¡å—å¯è§");
    }
    
    pub(self) fn self_visible() {
        // ç­‰åŒäºç§æœ‰ï¼Œåªå¯¹å½“å‰æ¨¡å—å¯è§
        println!("å¯¹è‡ªèº«å¯è§");
    }
    
    pub(in crate::restricted) fn path_visible() {
        // åªå¯¹æŒ‡å®šè·¯å¾„å¯è§
        println!("å¯¹æŒ‡å®šè·¯å¾„å¯è§");
    }
    
    mod inner {
        pub(super) fn super_visible() {
            // åªå¯¹çˆ¶æ¨¡å—(restricted)å¯è§
            println!("å¯¹çˆ¶æ¨¡å—å¯è§ï¼Œä»inner");
        }
    }
    
    pub fn call_inner() {
        inner::super_visible(); // å¯ä»¥è®¿é—®
    }
}

// å®é™…ä½¿ç”¨
fn use_restricted() {
    restricted::crate_visible(); // å¯ä»¥è®¿é—®ï¼Œå› ä¸ºåœ¨åŒä¸€ä¸ªcrate
    // restricted::parent_visible(); // é”™è¯¯ï¼šåªå¯¹çˆ¶æ¨¡å—å¯è§
    // restricted::path_visible(); // é”™è¯¯ï¼šåªå¯¹æŒ‡å®šè·¯å¾„å¯è§
}
```

#### 5.1.3 æ¨¡å—ç»„ç»‡ä¸æ–‡ä»¶ç³»ç»Ÿ

Rustæ¨¡å—ç³»ç»Ÿä¸æ–‡ä»¶ç³»ç»Ÿæœ‰å¯†åˆ‡å…³ç³»ï¼š

```rust
// å•æ–‡ä»¶å¤šæ¨¡å—
// src/main.rs æˆ– src/lib.rs
mod config {
    pub struct Config {
        pub database_url: String,
        pub port: u16,
    }
    
    impl Config {
        pub fn new() -> Self {
            Config {
                database_url: String::from("localhost:5432"),
                port: 8080,
            }
        }
    }
}

mod server {
    use super::config::Config;
    
    pub struct Server {
        config: Config,
    }
    
    impl Server {
        pub fn new(config: Config) -> Self {
            Server { config }
        }
        
        pub fn start(&self) {
            println!("æœåŠ¡å™¨å¯åŠ¨äºç«¯å£ {}", self.config.port);
            println!("è¿æ¥åˆ°æ•°æ®åº“ {}", self.config.database_url);
        }
    }
}

fn single_file_modules() {
    let config = config::Config::new();
    let server = server::Server::new(config);
    server.start();
}
```

å¤šæ–‡ä»¶ç»„ç»‡ï¼š

```rust
// src/lib.rs æˆ– src/main.rs
mod config; // å£°æ˜æ¨¡å—ï¼ŒæŸ¥æ‰¾ src/config.rs æˆ– src/config/mod.rs
mod server; // å£°æ˜æ¨¡å—ï¼ŒæŸ¥æ‰¾ src/server.rs æˆ– src/server/mod.rs

fn use_modules() {
    let config = config::Config::new();
    let server = server::Server::new(config);
    server.start();
}

// src/config.rs
pub struct Config {
    pub database_url: String,
    pub port: u16,
}

impl Config {
    pub fn new() -> Self {
        Config {
            database_url: String::from("localhost:5432"),
            port: 8080,
        }
    }
}

// src/server.rs
use crate::config::Config;

pub struct Server {
    config: Config,
}

impl Server {
    pub fn new(config: Config) -> Self {
        Server { config }
    }
    
    pub fn start(&self) {
        println!("æœåŠ¡å™¨å¯åŠ¨äºç«¯å£ {}", self.config.port);
        println!("è¿æ¥åˆ°æ•°æ®åº“ {}", self.config.database_url);
    }
}
```

åµŒå¥—æ¨¡å—çš„æ–‡ä»¶ç³»ç»Ÿè¡¨ç¤ºï¼š

```rust
// src/lib.rs æˆ– src/main.rs
mod models; // æŸ¥æ‰¾ src/models.rs æˆ– src/models/mod.rs

// src/models/mod.rs
pub mod user; // æŸ¥æ‰¾ src/models/user.rs
pub mod product; // æŸ¥æ‰¾ src/models/product.rs

// src/models/user.rs
pub struct User {
    pub id: u64,
    pub name: String,
}

impl User {
    pub fn new(id: u64, name: String) -> Self {
        User { id, name }
    }
}

// src/models/product.rs
pub struct Product {
    pub id: u64,
    pub name: String,
    pub price: f64,
}

impl Product {
    pub fn new(id: u64, name: String, price: f64) -> Self {
        Product { id, name, price }
    }
}

// åœ¨main.rsæˆ–lib.rsä¸­ä½¿ç”¨
fn use_nested_modules() {
    let user = models::user::User::new(1, String::from("å¼ ä¸‰"));
    let product = models::product::Product::new(
        101,
        String::from("ç¬”è®°æœ¬"),
        999.99
    );
    
    println!("ç”¨æˆ·: {} (ID: {})", user.name, user.id);
    println!("äº§å“: {} (ID: {}, ä»·æ ¼: Â¥{})",
             product.name, product.id, product.price);
}
```

#### 5.1.4 è·¯å¾„å¼•ç”¨å’Œç›¸å¯¹è·¯å¾„

Rustä¸­çš„è·¯å¾„å¯ä»¥æ˜¯ç»å¯¹çš„æˆ–ç›¸å¯¹çš„ï¼š

```rust
// ä¸åŒè·¯å¾„æ–¹å¼
fn paths() {
    // ä»crateæ ¹å¼€å§‹çš„ç»å¯¹è·¯å¾„
    use crate::models::user::User;
    
    // ä»å½“å‰æ¨¡å—å¼€å§‹çš„ç›¸å¯¹è·¯å¾„
    use self::local::Helper;
    
    // ä»çˆ¶æ¨¡å—å¼€å§‹çš„ç›¸å¯¹è·¯å¾„
    use super::parent::ParentType;
}

// æ ‡å‡†åº“å¯¼å…¥
use std::collections::HashMap;
use std::io::{self, Read, Write};
use std::cmp::Ordering;

// å¤–éƒ¨crateå¯¼å…¥
use serde::{Serialize, Deserialize};
use rand::prelude::*;

// å¯¼å…¥å†²çªè§£å†³
fn resolve_conflicts() {
    // ç›¸åŒåç§°çš„ä¸åŒç±»å‹å¯¼å…¥å†²çª
    use std::fmt::Result;
    use std::io::Result as IoResult; // ä½¿ç”¨asé‡å‘½å
    
    // å®Œæ•´è·¯å¾„è®¿é—®é¿å…å†²çª
    let fmt_result: Result = Ok(());
    let io_result: std::io::Result<()> = Ok(());
    
    // åµŒå¥—è·¯å¾„å¯¼å…¥
    use std::{
        collections::HashMap,
        fmt::{self, Display}, // selfå¯¼å…¥fmtæœ¬èº«
    };
    
    // é€šé…ç¬¦å¯¼å…¥
    use std::collections::*; // å¯¼å…¥æ‰€æœ‰å…¬å¼€é¡¹ï¼ˆæ…ç”¨ï¼‰
}
```

ä¸åŒçš„å¯¼å…¥åœºæ™¯ï¼š

```rust
// æ¨¡å—å¤–éƒ¨å¯¼å…¥
use std::collections::HashMap;
use crate::models::user::User;

// æ¨¡å—å†…éƒ¨å¯¼å…¥
mod services {
    // æ¨¡å—å†…éƒ¨å¯¼å…¥ï¼Œåªåœ¨æœ¬æ¨¡å—å¯è§
    use crate::models::user::User;
    use std::collections::HashMap;
    
    pub fn process_users(users: &[User]) {
        let mut user_map = HashMap::new();
        for user in users {
            user_map.insert(user.id, &user.name);
        }
        println!("å¤„ç†äº† {} ä¸ªç”¨æˆ·", user_map.len());
    }
}

// å­æ¨¡å—ä¸ä¼šç»§æ‰¿çˆ¶æ¨¡å—çš„å¯¼å…¥
mod parent {
    use std::collections::HashMap;
    
    pub fn use_hash_map() {
        let mut map = HashMap::new();
        map.insert("key", "value");
    }
    
    pub mod child {
        // è¿™é‡Œæ— æ³•è®¿é—®HashMapï¼Œéœ€è¦è‡ªå·±å¯¼å…¥
        // let map = HashMap::new(); // é”™è¯¯
        
        pub fn needs_hash_map() {
            // éœ€è¦è‡ªå·±å¯¼å…¥æˆ–ä½¿ç”¨å®Œæ•´è·¯å¾„
            let mut map = std::collections::HashMap::new();
            map.insert("child_key", "child_value");
        }
    }
}
```

### 5.2 åŒ…ä¸Crateç³»ç»Ÿ

#### 5.2.1 åŒ…ä¸CrateåŸºç¡€

Rustçš„åŒ…å’Œcrateç³»ç»Ÿæ˜¯ä»£ç ç»„ç»‡çš„åŸºç¡€ï¼š

```rust
// åŒ…(package)ï¼šç”±Cargo.tomlå®šä¹‰çš„é¡¹ç›®
// crateï¼šç¼–è¯‘å•å…ƒï¼Œå¯ä»¥æ˜¯åº“æˆ–äºŒè¿›åˆ¶

// Cargo.tomlç¤ºä¾‹
/*
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
rand = "0.8"

[dev-dependencies]
criterion = "0.3"

[[bin]]
name = "cli"
path = "src/bin/cli.rs"

[lib]
name = "my_lib"
path = "src/lib.rs"
*/

// åº“crateçš„å…¥å£: src/lib.rs
pub mod models;
pub mod services;

pub fn public_api_function() {
    println!("è¿™æ˜¯åº“çš„å…¬å…±API");
}

fn private_function() {
    println!("è¿™æ˜¯åº“çš„ç§æœ‰å‡½æ•°");
}

// äºŒè¿›åˆ¶crateçš„å…¥å£: src/main.rs
fn main() {
    println!("è¿™æ˜¯äºŒè¿›åˆ¶crateçš„å…¥å£ç‚¹");
    
    // ä½¿ç”¨åº“crateçš„å…¬å…±API
    my_lib::public_api_function();
    
    // ä½¿ç”¨æ¨¡å—
    let user = my_lib::models::user::User::new(1, String::from("æå››"));
    println!("ç”¨æˆ·: {}", user.name);
}
```

å¤šäºŒè¿›åˆ¶æ–‡ä»¶ï¼š

```rust
// src/bin/cli.rs (äºŒè¿›åˆ¶crate)
fn main() {
    println!("è¿™æ˜¯å‘½ä»¤è¡Œç•Œé¢");
    my_lib::public_api_function();
}

// src/bin/server.rs (å¦ä¸€ä¸ªäºŒè¿›åˆ¶crate)
fn main() {
    println!("è¿™æ˜¯æœåŠ¡å™¨åº”ç”¨");
    my_lib::public_api_function();
}
```

å·¥ä½œç©ºé—´ï¼š

```rust
// Cargo.toml (å·¥ä½œç©ºé—´æ ¹ç›®å½•)
/*
[workspace]
members = [
    "app",
    "lib_a",
    "lib_b",
]
*/

// lib_a/Cargo.toml
/*
[package]
name = "lib_a"
version = "0.1.0"
edition = "2021"
*/

// lib_a/src/lib.rs
pub fn lib_a_function() {
    println!("åº“Açš„å‡½æ•°");
}

// lib_b/Cargo.toml
/*
[package]
name = "lib_b"
version = "0.1.0"
edition = "2021"

[dependencies]
lib_a = { path = "../lib_a" }
*/

// lib_b/src/lib.rs
pub fn lib_b_function() {
    println!("åº“Bçš„å‡½æ•°");
    lib_a::lib_a_function();
}

// app/Cargo.toml
/*
[package]
name = "app"
version = "0.1.0"
edition = "2021"

[dependencies]
lib_a = { path = "../lib_a" }
lib_b = { path = "../lib_b" }
*/

// app/src/main.rs
fn main() {
    println!("åº”ç”¨ä¸»ç¨‹åº");
    lib_a::lib_a_function();
    lib_b::lib_b_function();
}
```

#### 5.2.2 CargoåŒ…ç®¡ç†å™¨

Cargoæ˜¯Rustçš„åŒ…ç®¡ç†å™¨å’Œæ„å»ºå·¥å…·ï¼š

```rust
// Cargo.tomlé…ç½®é€‰é¡¹
/*
[package]
name = "my_package"       # åŒ…å
version = "0.1.0"         # ç‰ˆæœ¬å·
authors = ["ä½œè€… <email@example.com>"] # ä½œè€…
edition = "2021"          # Rustç‰ˆæœ¬
description = "åŒ…æè¿°"     # åŒ…æè¿°
license = "MIT"           # è®¸å¯è¯
repository = "https://github.com/user/repo" # ä»£ç ä»“åº“
documentation = "https://docs.rs/my_package" # æ–‡æ¡£URL
readme = "README.md"      # READMEæ–‡ä»¶
keywords = ["keyword1", "keyword2"] # å…³é”®è¯
categories = ["category1", "category2"] # åˆ†ç±»

[dependencies]
# åŸºæœ¬ä¾èµ–æŒ‡å®š
serde = "1.0"             # ä½¿ç”¨å…¼å®¹1.0çš„æœ€æ–°ç‰ˆæœ¬
rand = "0.8.5"            # æŒ‡å®šç²¾ç¡®ç‰ˆæœ¬
tokio = { version = "1.0", features = ["full"] } # å¸¦ç‰¹æ€§çš„ä¾èµ–
local_lib = { path = "../local_lib" } # æœ¬åœ°è·¯å¾„ä¾èµ–
git_lib = { git = "https://github.com/user/repo" } # Gitä»“åº“ä¾èµ–
git_lib_branch = { git = "https://github.com/user/repo", branch = "dev" } # æŒ‡å®šåˆ†æ”¯

[dev-dependencies]        # ä»…ç”¨äºæµ‹è¯•çš„ä¾èµ–
criterion = "0.3"

[build-dependencies]      # ä»…ç”¨äºæ„å»ºè„šæœ¬çš„ä¾èµ–
cc = "1.0"

[target.'cfg(target_os = "linux")'.dependencies] # ç‰¹å®šç›®æ ‡çš„ä¾èµ–
x11 = "2.0"

[features]                # ç‰¹æ€§æ ‡å¿—
default = ["feature1"]    # é»˜è®¤å¯ç”¨çš„ç‰¹æ€§
feature1 = []             # ç®€å•ç‰¹æ€§
feature2 = ["dep1/feat1", "dep2"] # ä¾èµ–å…¶ä»–åŒ…çš„ç‰¹æ€§
*/

// ç®€å•çš„build.rsæ„å»ºè„šæœ¬
fn main() {
    // æ‰§è¡Œæ„å»ºæ—¶ä»»åŠ¡
    println!("cargo:rustc-link-lib=sqlite3"); // é“¾æ¥å¤–éƒ¨åº“
    println!("cargo:rustc-link-search=native=/usr/lib"); // è®¾ç½®åº“æœç´¢è·¯å¾„
    println!("cargo:rerun-if-changed=src/bindings.h"); // æ–‡ä»¶å˜æ›´æ—¶é‡æ–°è¿è¡Œ
    
    // æ¡ä»¶ç¼–è¯‘
    if cfg!(target_os = "windows") {
        println!("cargo:rustc-link-lib=user32");
    }
}
```

Cargoå‘½ä»¤ï¼š

```bash
# åˆ›å»ºæ–°é¡¹ç›®
cargo new my_project
cargo new --lib my_library

# æ„å»ºé¡¹ç›®
cargo build            # è°ƒè¯•æ„å»º
cargo build --release  # å‘å¸ƒæ„å»º

# è¿è¡Œé¡¹ç›®
cargo run             # æ„å»ºå¹¶è¿è¡Œ
cargo run --bin cli   # è¿è¡Œç‰¹å®šäºŒè¿›åˆ¶

# æµ‹è¯•
cargo test            # è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test test_name  # è¿è¡Œç‰¹å®šæµ‹è¯•

# æ–‡æ¡£
cargo doc             # ç”Ÿæˆæ–‡æ¡£
cargo doc --open      # ç”Ÿæˆå¹¶æ‰“å¼€æ–‡æ¡£

# ä¾èµ–ç®¡ç†
cargo add serde       # æ·»åŠ ä¾èµ–
cargo update          # æ›´æ–°ä¾èµ–
cargo tree            # æ˜¾ç¤ºä¾èµ–æ ‘

# å‘å¸ƒ
cargo publish         # å‘å¸ƒåˆ°crates.io

# å·¥ä½œç©ºé—´
cargo build -p lib_a  # æ„å»ºç‰¹å®šåŒ…
```

#### 5.2.3 å‘å¸ƒä¸ä½¿ç”¨crate

å‘å¸ƒcrateåˆ°crates.ioå¹¶ä½¿ç”¨å®ƒï¼š

```rust
// å‡†å¤‡å‘å¸ƒcrate
/*
1. ç¡®ä¿Cargo.tomlåŒ…å«å¿…è¦ä¿¡æ¯ï¼š
   - name, version, authors
   - description, license
   - repository, documentation
   - keywords, categories

2. æ·»åŠ README.md

3. æ’°å†™æ–‡æ¡£æ³¨é‡Š
*/

// æ–‡æ¡£æ³¨é‡Šç¤ºä¾‹
/// è®¡ç®—ä¸¤ä¸ªæ•°å­—çš„å’Œ
///
/// # Examples
///
/// ```
/// let sum = my_crate::add(2, 3);
/// assert_eq!(sum, 5);
/// ```
///
/// # Panics
///
/// ä¸ä¼španic
///
/// # Errors
///
/// ä¸è¿”å›é”™è¯¯
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

//! # My Crate
//!
//! `my_crate` æ˜¯ä¸€ä¸ªç¤ºä¾‹åº“ï¼Œæä¾›åŸºç¡€ç®—æœ¯åŠŸèƒ½ã€‚
//!
//! ## åŠŸèƒ½
//!
//! - åŸºæœ¬ç®—æœ¯æ“ä½œ
//! - æ•°å€¼è½¬æ¢
//! - è®¡ç®—å·¥å…·

// æ¨¡å—æ–‡æ¡£
/// æ•°å­¦ç›¸å…³åŠŸèƒ½æ¨¡å—
pub mod math {
    /// è®¡ç®—ä¸¤ä¸ªæ•°å­—çš„å’Œ
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    /// è®¡ç®—ä¸¤ä¸ªæ•°å­—çš„å·®
    pub fn subtract(a: i32, b: i32) -> i32 {
        a - b
    }
}

// æµ‹è¯•æ¨¡å—
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(math::add(2, 3), 5);
    }
    
    #[test]
    fn test_subtract() {
        assert_eq!(math::subtract(5, 2), 3);
    }
}
```

å‘å¸ƒæµç¨‹ï¼š

```bash
# ç™»å½• crates.io
cargo login <ä½ çš„APIä»¤ç‰Œ>

# æ£€æŸ¥åŒ…
cargo package

# å‘å¸ƒåŒ…
cargo publish

# æ›´æ–°ç‰ˆæœ¬åå†æ¬¡å‘å¸ƒ
# 1. ä¿®æ”¹ Cargo.toml ä¸­çš„ç‰ˆæœ¬å·
# 2. cargo publish
```

ä½¿ç”¨å·²å‘å¸ƒçš„crateï¼š

```rust
// åœ¨Cargo.tomlæ·»åŠ ä¾èµ–
/*
[dependencies]
my_crate = "0.1.0"
*/

// åœ¨ä»£ç ä¸­ä½¿ç”¨
use my_crate::math::{add, subtract};

fn main() {
    let sum = add(10, 5);
    let diff = subtract(10, 5);
    
    println!("10 + 5 = {}", sum);
    println!("10 - 5 = {}", diff);
}
```

è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶ï¼š

```rust
// Cargo.toml ä¸­çš„ç‰ˆæœ¬è§„åˆ™
/*
[dependencies]
# ç²¾ç¡®ç‰ˆæœ¬
exact_version = "=1.2.3"

# å…¼å®¹ç‰ˆæœ¬ï¼ˆæ¥å—1.2.3åˆ°1.3.0ä¹‹å‰çš„ä»»ä½•ç‰ˆæœ¬ï¼‰
compatible = "~1.2.3"

# ä¸»ç‰ˆæœ¬å…¼å®¹ï¼ˆæ¥å—1.2.3åˆ°2.0.0ä¹‹å‰çš„ä»»ä½•ç‰ˆæœ¬ï¼‰
major_compatible = "^1.2.3"

# èŒƒå›´ç‰ˆæœ¬
range = ">= 1.2, < 1.5"

# é€šé…ç¬¦ç‰ˆæœ¬
wildcard = "1.2.*"

# æœ€æ–°ç‰ˆæœ¬
latest = "*"
*/
```

## 6. å¹¶å‘

### 6.1 çº¿ç¨‹ä¸å¹¶å‘åŸºç¡€

#### 6.1.1 çº¿ç¨‹åˆ›å»ºä¸ç®¡ç†

Rustæä¾›äº†å¯¹æ“ä½œç³»ç»ŸåŸç”Ÿçº¿ç¨‹çš„å®‰å…¨æŠ½è±¡ï¼š

```rust
// åŸºæœ¬çº¿ç¨‹åˆ›å»º
use std::thread;
use std::time::Duration;

fn basic_threading() {
    // åˆ›å»ºæ–°çº¿ç¨‹
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("çº¿ç¨‹ä¸­: è®¡æ•° {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // ä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œ
    for i in 1..5 {
        println!("ä¸»çº¿ç¨‹: è®¡æ•° {}", i);
        thread::sleep(Duration::from_millis(150));
    }
    
    // ç­‰å¾…çº¿ç¨‹å®Œæˆ
    handle.join().unwrap();
    println!("å­çº¿ç¨‹å·²å®Œæˆ");
}

// çº¿ç¨‹å‚æ•°å’Œæ‰€æœ‰æƒ
fn thread_with_data() {
    let v = vec![1, 2, 3];
    
    // ç§»åŠ¨é—­åŒ… - è½¬ç§»æ‰€æœ‰æƒåˆ°çº¿ç¨‹
    let handle = thread::spawn(move || {
        println!("çº¿ç¨‹ä¸­çš„å‘é‡: {:?}", v);
        // vçš„æ‰€æœ‰æƒå·²è½¬ç§»åˆ°çº¿ç¨‹
    });
    
    // ä¸èƒ½å†ä½¿ç”¨v
    // println!("ä¸»çº¿ç¨‹ä¸­çš„å‘é‡: {:?}", v); // é”™è¯¯: vå·²ç§»åŠ¨
    
    handle.join().unwrap();
}

// çº¿ç¨‹è¿”å›å€¼
fn thread_with_return() {
    let handle = thread::spawn(|| {
        // æ‰§è¡ŒæŸäº›è®¡ç®—
        let result = (0..100).sum::<i32>();
        // è¿”å›è®¡ç®—ç»“æœ
        result
    });
    
    // è·å–çº¿ç¨‹çš„è¿”å›å€¼
    let result = handle.join().unwrap();
    println!("çº¿ç¨‹è®¡ç®—ç»“æœ: {}", result);
}
```

è‡ªå®šä¹‰çº¿ç¨‹è®¾ç½®ï¼š

```rust
// è‡ªå®šä¹‰çº¿ç¨‹åç§°å’Œæ ˆå¤§å°
fn custom_thread_settings() {
    // åˆ›å»ºè‡ªå®šä¹‰çº¿ç¨‹æ„å»ºå™¨
    let builder = thread::Builder::new()
        .name("è‡ªå®šä¹‰çº¿ç¨‹".to_string())
        .stack_size(32 * 1024); // 32KBæ ˆ
    
    // ä½¿ç”¨æ„å»ºå™¨å¯åŠ¨çº¿ç¨‹
    let handle = builder.spawn(|| {
        // è·å–å½“å‰çº¿ç¨‹
        let thread = thread::current();
        println!("åœ¨ {:?} çº¿ç¨‹ä¸­è¿è¡Œ", thread.name().unwrap_or("æœªå‘½å"));
        
        // è®¿é—®å½“å‰çº¿ç¨‹çš„ID
        println!("çº¿ç¨‹ID: {:?}", thread.id());
    }).unwrap();
    
    handle.join().unwrap();
}

// çº¿ç¨‹æœ¬åœ°å­˜å‚¨
thread_local! {
    static COUNTER: std::cell::RefCell<u32> = std::cell::RefCell::new(0);
}

fn thread_local_storage() {
    // ä¿®æ”¹ä¸»çº¿ç¨‹çš„å€¼
    COUNTER.with(|c| {
        *c.borrow_mut() += 1;
        println!("ä¸»çº¿ç¨‹è®¡æ•°: {}", *c.borrow());
    });
    
    // å¯åŠ¨å¤šä¸ªçº¿ç¨‹
    let handles: Vec<_> = (0..5).map(|id| {
        thread::spawn(move || {
            // æ¯ä¸ªçº¿ç¨‹æœ‰è‡ªå·±çš„COUNTERå‰¯æœ¬
            COUNTER.with(|c| {
                *c.borrow_mut() = id + 10;
                println!("çº¿ç¨‹ {}: è®¡æ•°è®¾ç½®ä¸º {}", id, *c.borrow());
            });
            
            thread::sleep(Duration::from_millis(50));
            
            // å†æ¬¡è®¿é—®ï¼Œåªå½±å“æ­¤çº¿ç¨‹çš„å‰¯æœ¬
            COUNTER.with(|c| {
                println!("çº¿ç¨‹ {}: è®¡æ•°ä»ç„¶æ˜¯ {}", id, *c.borrow());
            });
        })
    }).collect();
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹
    for handle in handles {
        handle.join().unwrap();
    }
    
    // ä¸»çº¿ç¨‹çš„å€¼ä¸å—å½±å“
    COUNTER.with(|c| {
        println!("ä¸»çº¿ç¨‹è®¡æ•°ä»ç„¶æ˜¯: {}", *c.borrow());
    });
}
```

#### 6.1.2 çº¿ç¨‹é—´é€šä¿¡

é€šè¿‡é€šé“(channel)åœ¨çº¿ç¨‹é—´ä¼ é€’æ¶ˆæ¯ï¼š

```rust
// åŸºæœ¬æ¶ˆæ¯ä¼ é€’
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn basic_channel() {
    // åˆ›å»ºé€šé“
    let (tx, rx) = mpsc::channel();
    
    // åœ¨å•ç‹¬çº¿ç¨‹ä¸­å‘é€æ¶ˆæ¯
    thread::spawn(move || {
        let messages = vec![
            "ä½ å¥½".to_string(),
            "ä»".to_string(),
            "çº¿ç¨‹".to_string(),
            "å‘é€".to_string(),
        ];
        
        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
        println!("æ¶ˆæ¯å·²å…¨éƒ¨å‘é€");
        // txåœ¨è¿™é‡Œè¢«åˆ é™¤ï¼Œå…³é—­é€šé“
    });
    
    // åœ¨ä¸»çº¿ç¨‹ä¸­æ¥æ”¶æ¶ˆæ¯
    for received in rx {
        println!("æ”¶åˆ°: {}", received);
    }
    println!("é€šé“å·²å…³é—­");
}

// å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…
fn multiple_producers() {
    // åˆ›å»ºé€šé“
    let (tx, rx) = mpsc::channel();
    
    // å…‹éš†å‘é€ç«¯ï¼Œåˆ›å»ºå¤šä¸ªç”Ÿäº§è€…
    let tx1 = tx.clone();
    
    // ç¬¬ä¸€ä¸ªå‘é€çº¿ç¨‹
    thread::spawn(move || {
        let messages = vec![1, 2, 3];
        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // ç¬¬äºŒä¸ªå‘é€çº¿ç¨‹
    thread::spawn(move || {
        let messages = vec![4, 5, 6];
        for msg in messages {
            tx1.send(msg).unwrap();
            thread::sleep(Duration::from_millis(150));
        }
    });
    
    // æ¥æ”¶æ¶ˆæ¯
    // ä¸¤ä¸ªå‘é€ç«¯éƒ½ç¦»å¼€ä½œç”¨åŸŸåé€šé“å…³é—­
    for received in rx {
        println!("æ”¶åˆ°: {}", received);
    }
}

// å‘é€å¤æ‚æ•°æ®
fn sending_complex_data() {
    // å®šä¹‰æ¶ˆæ¯ç±»å‹
    enum Message {
        Text(String),
        Number(i32),
        Exit,
    }
    
    let (tx, rx) = mpsc::channel();
    
    // å‘é€ä¸åŒç±»å‹çš„æ¶ˆæ¯
    thread::spawn(move || {
        tx.send(Message::Text("Hello".to_string())).unwrap();
        thread::sleep(Duration::from_millis(100));
        
        tx.send(Message::Number(42)).unwrap();
        thread::sleep(Duration::from_millis(100));
        
        tx.send(Message::Exit).unwrap();
    });
    
    // æ¥æ”¶å’Œå¤„ç†æ¶ˆæ¯
    for msg in rx {
        match msg {
            Message::Text(text) => println!("æ–‡æœ¬æ¶ˆæ¯: {}", text),
            Message::Number(num) => println!("æ•°å­—æ¶ˆæ¯: {}", num),
            Message::Exit => {
                println!("æ”¶åˆ°é€€å‡ºä¿¡å·");
                break;
            }
        }
    }
}
```

åŒæ­¥é€šé“ï¼š

```rust
// åŒæ­¥é€šé“ç¤ºä¾‹
fn synchronized_channel() {
    // åˆ›å»ºåŒæ­¥é€šé“
    let (tx, rx) = mpsc::sync_channel(2); // ç¼“å†²åŒºå¤§å°ä¸º2
    
    // å‘é€çº¿ç¨‹
    let sender = thread::spawn(move || {
        println!("å‘é€æ¶ˆæ¯1");
        tx.send(1).unwrap();
        println!("æ¶ˆæ¯1å·²å‘é€");
        
        println!("å‘é€æ¶ˆæ¯2");
        tx.send(2).unwrap();
        println!("æ¶ˆæ¯2å·²å‘é€");
        
        println!("å‘é€æ¶ˆæ¯3");
        // ç¼“å†²åŒºå·²æ»¡ï¼Œå‘é€å°†é˜»å¡ç›´åˆ°æ¥æ”¶è€…æ¥æ”¶æ¶ˆæ¯
        tx.send(3).unwrap();
        println!("æ¶ˆæ¯3å·²å‘é€");
        
        println!("å‘é€æ¶ˆæ¯4");
        tx.send(4).unwrap();
        println!("æ¶ˆæ¯4å·²å‘é€");
    });
    
    // æ¥æ”¶çº¿ç¨‹
    let receiver = thread::spawn(move || {
        thread::sleep(Duration::from_secs(1));
        println!("æ¥æ”¶æ¶ˆæ¯: {}", rx.recv().unwrap());
        
        thread::sleep(Duration::from_secs(1));
        println!("æ¥æ”¶æ¶ˆæ¯: {}", rx.recv().unwrap());
        
        thread::sleep(Duration::from_secs(1));
        println!("æ¥æ”¶æ¶ˆæ¯: {}", rx.recv().unwrap());
        
        thread::sleep(Duration::from_secs(1));
        println!("æ¥æ”¶æ¶ˆæ¯: {}", rx.recv().unwrap());
    });
    
    sender.join().unwrap();
    receiver.join().unwrap();
}

// éé˜»å¡æ¥æ”¶
fn non_blocking_receive() {
    let (tx, rx) = mpsc::channel();
    
    // å‘é€ä¸€ä¸ªæ¶ˆæ¯
    tx.send(1).unwrap();
    
    // éé˜»å¡æ¥æ”¶ - try_recv
    match rx.try_recv() {
        Ok(msg) => println!("ç«‹å³æ”¶åˆ°: {}", msg),
        Err(e) => println!("æ— æ¶ˆæ¯: {:?}", e),
    }
    
    // å†æ¬¡å°è¯• - ç°åœ¨é€šé“ä¸ºç©º
    match rx.try_recv() {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(e) => println!("æ— æ¶ˆæ¯: {:?}", e), // è¿”å›mpsc::TryRecvError::Empty
    }
    
    // ä¸¢å¼ƒtxï¼Œå…³é—­é€šé“
    drop(tx);
    
    // å°è¯•ä»å…³é—­çš„é€šé“æ¥æ”¶
    match rx.try_recv() {
        Ok(msg) => println!("æ”¶åˆ°: {}", msg),
        Err(e) => println!("é”™è¯¯: {:?}", e), // è¿”å›mpsc::TryRecvError::Disconnected
    }
}
```

#### 6.1.3 çº¿ç¨‹åŒæ­¥åŸè¯­

Rustæä¾›å¤šç§åŒæ­¥åŸè¯­ç”¨äºçº¿ç¨‹é—´åè°ƒï¼š

```rust
// äº’æ–¥é”(Mutex)
use std::sync::{Mutex, Arc};
use std::thread;

fn basic_mutex() {
    // åˆ›å»ºäº’æ–¥é”
    let counter = Mutex::new(0);
    
    // è®¿é—®äº’æ–¥é”ä¿æŠ¤çš„æ•°æ®
    {
        // åŠ é”è®¿é—®æ•°æ®
        let mut num = counter.lock().unwrap();
        *num += 1;
    } // é”è‡ªåŠ¨é‡Šæ”¾
    
    println!("è®¡æ•°: {:?}", counter);
}

// åœ¨å¤šçº¿ç¨‹é—´å…±äº«äº’æ–¥é”
fn shared_mutex() {
    // Arc = åŸå­å¼•ç”¨è®¡æ•°ï¼Œç”¨äºå¤šçº¿ç¨‹é—´å®‰å…¨å…±äº«
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        // å…‹éš†Arcï¼Œå¢åŠ å¼•ç”¨è®¡æ•°
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            // åœ¨çº¿ç¨‹ä¸­ä½¿ç”¨äº’æ–¥é”
            let mut num = counter.lock().unwrap();
            *num += 1;
            // é”åœ¨è¿™é‡Œè‡ªåŠ¨é‡Šæ”¾
        });
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹
    for handle in handles {
        handle.join().unwrap();
    }
    
    // æŸ¥çœ‹æœ€ç»ˆç»“æœ
    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().unwrap());
}

// è¯»å†™é”(RwLock)
use std::sync::RwLock;

fn read_write_lock() {
    // åˆ›å»ºè¯»å†™é”
    let rw_lock = Arc::new(RwLock::new(5));
    
    // åˆ›å»ºè¯»å–çº¿ç¨‹
    let readers: Vec<_> = (0..3).map(|id| {
        let lock = Arc::clone(&rw_lock);
        thread::spawn(move || {
            // è·å–è¯»é”
            let value = lock.read().unwrap();
            println!("è¯»å–çº¿ç¨‹ {}: å€¼ä¸º {}", id, *value);
            // æ¨¡æ‹Ÿè¯»å–æ“ä½œ
            thread::sleep(Duration::from_millis(100));
            // è¯»é”åœ¨è¿™é‡Œé‡Šæ”¾
        })
    }).collect();
    
    // ç­‰å¾…ä¸€äº›è¯»å–å¼€å§‹
    thread::sleep(Duration::from_millis(50));
    
    // åˆ›å»ºå†™å…¥çº¿ç¨‹
    let writers: Vec<_> = (0..2).map(|id| {
        let lock = Arc::clone(&rw_lock);
        thread::spawn(move || {
            // è·å–å†™é”
            let mut value = lock.write().unwrap();
            *value += 1;
            println!("å†™å…¥çº¿ç¨‹ {}: å¢åŠ å€¼åˆ° {}", id, *value);
            // æ¨¡æ‹Ÿå†™å…¥æ“ä½œ
            thread::sleep(Duration::from_millis(200));
            // å†™é”åœ¨è¿™é‡Œé‡Šæ”¾
        })
    }).collect();
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹
    for handle in readers {
        handle.join().unwrap();
    }
    for handle in writers {
        handle.join().unwrap();
    }
    
    // æ£€æŸ¥æœ€ç»ˆå€¼
    println!("æœ€ç»ˆå€¼: {}", *rw_lock.read().unwrap());
}

// æ¡ä»¶å˜é‡(Condvar)
use std::sync::{Condvar, Arc, Mutex};

fn condition_variable() {
    // åˆ›å»ºæ¡ä»¶å˜é‡å’Œäº’æ–¥é”
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = Arc::clone(&pair);
    
    // ç­‰å¾…çº¿ç¨‹
    let waiter = thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        let mut ready = lock.lock().unwrap();
        
        println!("ç­‰å¾…çº¿ç¨‹: ç­‰å¾…ä¿¡å·...");
        
        // å¦‚æœæ ‡å¿—ä¸ºfalseï¼Œç­‰å¾…ä¿¡å·
        while !*ready {
            // å½“waitè¿”å›æ—¶ï¼Œä¼šé‡æ–°è·å–é”
            ready = cvar.wait(ready).unwrap();
        }
        
        println!("ç­‰å¾…çº¿ç¨‹: æ”¶åˆ°ä¿¡å·!");
    });
    
    // è®©ç­‰å¾…çº¿ç¨‹å¯åŠ¨
    thread::sleep(Duration::from_millis(500));
    
    // å‘é€çº¿ç¨‹
    let (lock, cvar) = &*pair;
    let mut ready = lock.lock().unwrap();
    *ready = true;
    println!("ä¸»çº¿ç¨‹: å‘é€ä¿¡å·");
    cvar.notify_one();
    // é”åœ¨è¿™é‡Œé‡Šæ”¾
    
    waiter.join().unwrap();
}

// å±éšœ(Barrier)
use std::sync::Barrier;

fn barrier_example() {
    // åˆ›å»º3çº¿ç¨‹å±éšœ
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];
    
    for i in 0..3 {
        let b = Arc::clone(&barrier);
        handles.push(thread::spawn(move || {
            // æ¨¡æ‹Ÿå·¥ä½œ
            println!("çº¿ç¨‹ {} å¼€å§‹å·¥ä½œ", i);
            thread::sleep(Duration::from_millis(i * 100 + 100));
            println!("çº¿ç¨‹ {} åˆ°è¾¾å±éšœ", i);
            
            // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾å±éšœ
            let wait_result = b.wait();
            // wait_result.is_leader()è¿”å›trueä»…å¯¹ä¸€ä¸ªçº¿ç¨‹
            
            // æ‰€æœ‰çº¿ç¨‹éƒ½é€šè¿‡å±éšœåç»§ç»­
            println!("çº¿ç¨‹ {} é€šè¿‡å±éšœ", i);
        }));
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

åŸå­ç±»å‹ï¼š

```rust
// åŸå­ç±»å‹
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

fn atomic_operations() {
    // åˆ›å»ºåŸå­å¸ƒå°”ç±»å‹
    let running = Arc::new(AtomicBool::new(true));
    let r = Arc::clone(&running);
    
    // ä½¿ç”¨åŸå­å¸ƒå°”å€¼æ§åˆ¶çº¿ç¨‹
    let handle = thread::spawn(move || {
        let mut count = 0;
        // æ£€æŸ¥åŸå­å˜é‡æ˜¯å¦ä¸ºtrue
        while r.load(Ordering::Relaxed) {
            count += 1;
            thread::sleep(Duration::from_millis(10));
        }
        println!("çº¿ç¨‹å®Œæˆï¼Œè®¡æ•°: {}", count);
    });
    
    // ä¸»çº¿ç¨‹å·¥ä½œ
    thread::sleep(Duration::from_millis(500));
    
    // åŸå­åœ°è®¾ç½®ä¸ºfalseï¼Œé€šçŸ¥çº¿ç¨‹é€€å‡º
    running.store(false, Ordering::Relaxed);
    handle.join().unwrap();
    
    // åŸå­æ•´æ•°
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let c = Arc::clone(&counter);
        handles.push(thread::spawn(move || {
            // åŸå­åœ°å¢åŠ è®¡æ•°
            c.fetch_add(1, Ordering::SeqCst);
        }));
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€ç»ˆè®¡æ•°: {}", counter.load(Ordering::SeqCst));
}

// å†…å­˜é¡ºåº
fn memory_ordering() {
    let counter = Arc::new(AtomicUsize::new(0));
    let c = Arc::clone(&counter);
    
    // ä¸åŒçš„å†…å­˜é¡ºåº
    thread::spawn(move || {
        // Relaxed - æœ€å°‘ä¿è¯ï¼Œåªä¿è¯åŸå­æ€§
        c.fetch_add(1, Ordering::Relaxed);
        
        // Release - å†™å…¥æ“ä½œçš„å†…å­˜é¡ºåº
        c.store(2, Ordering::Release);
        
        // Acquire - è¯»å–æ“ä½œçš„å†…å­˜é¡ºåº
        let _ = c.load(Ordering::Acquire);
        
        // AcqRel - Acquire+Releaseè¯­ä¹‰
        c.fetch_add(1, Ordering::AcqRel);
        
        // SeqCst - æœ€å¼ºä¿è¯ï¼Œå…¨åºä¸€è‡´æ€§
        c.fetch_add(1, Ordering::SeqCst);
    });
}
```

ä½¿ç”¨`parking_lot`ä¼˜åŒ–çš„åŒæ­¥åŸè¯­ï¼š

```rust
// parking_lotæä¾›æ›´é«˜æ€§èƒ½çš„åŒæ­¥åŸè¯­
use parking_lot::{Mutex, RwLock, Condvar};

fn parking_lot_example() {
    // Mutexç¤ºä¾‹
    let mutex = Mutex::new(0);
    
    // æ— éœ€unwrapï¼Œä¸ä¼španic
    {
        let mut guard = mutex.lock();
        *guard += 1;
    } // é”è‡ªåŠ¨é‡Šæ”¾
    
    // try_lockä¸ä¼šé˜»å¡
    if let Some(mut guard) = mutex.try_lock() {
        *guard += 1;
    }
    
    // RwLockç¤ºä¾‹
    let rw_lock = RwLock::new(vec![1, 2, 3]);
    
    // è¯»é”
    {
        let data = rw_lock.read();
        println!("æ•°æ®: {:?}", *data);
    }
    
    // å†™é”
    {
        let mut data = rw_lock.write();
        data.push(4);
    }
    
    // æ¡ä»¶å˜é‡
    let mutex = Mutex::new(false);
    let condvar = Condvar::new();
    
    thread::spawn(move || {
        thread::sleep(Duration::from_millis(500));
        
        let mut guard = mutex.lock();
        *guard = true;
        
        // é€šçŸ¥ç­‰å¾…çº¿ç¨‹
        condvar.notify_one();
    });
    
    // ç­‰å¾…æ¡ä»¶
    let mut guard = mutex.lock();
    while !*guard {
        // ç­‰å¾…é€šçŸ¥
        condvar.wait(&mut guard);
    }
    println!("æ¡ä»¶å·²æ»¡è¶³");
}
```

### 6.2 Rayonå¹¶è¡Œè¿­ä»£å™¨

Rayonåº“æä¾›äº†ç®€å•æ˜“ç”¨çš„æ•°æ®å¹¶è¡Œå¤„ç†åŠŸèƒ½ï¼š

```rust
// åŸºæœ¬Rayonå¹¶è¡Œè¿­ä»£
use rayon::prelude::*;

fn basic_parallel_iter() {
    // ä¸²è¡Œè¿­ä»£
    let sum_sequential: i32 = (1..1_000_000).sum();
    
    // å¹¶è¡Œè¿­ä»£
    let sum_parallel: i32 = (1..1_000_000).into_par_iter().sum();
    
    // ç»“æœåº”ç›¸åŒ
    assert_eq!(sum_sequential, sum_parallel);
    println!("æ€»å’Œ: {}", sum_parallel);
    
    // å¹¶è¡Œæ˜ å°„æ“ä½œ
    let v: Vec<i32> = (0..100).collect();
    let squares: Vec<i32> = v.par_iter()
                             .map(|&i| i * i)
                             .collect();
    
    println!("éƒ¨åˆ†å¹³æ–¹ç»“æœ: {:?}", &squares[0..10]);
}

// æ›´å¤šå¹¶è¡Œæ“ä½œ
fn parallel_operations() {
    let v: Vec<i32> = (0..1000).collect();
    
    // å¹¶è¡ŒæŸ¥æ‰¾
    let first_negative = v.par_iter()
                         .find_first(|&&x| x < 0);
    println!("ç¬¬ä¸€ä¸ªè´Ÿæ•°: {:?}", first_negative); // Noneï¼Œå› ä¸ºæ²¡æœ‰è´Ÿæ•°
    
    // å¹¶è¡Œä»»æ„åŒ¹é…
    let has_even = v.par_iter()
                    .any(|&x| x % 2 == 0);
    println!("åŒ…å«å¶æ•°: {}", has_even); // true
    
    // å¹¶è¡Œæ‰€æœ‰åŒ¹é…
    let all_positive = v.par_iter()
                       .all(|&x| x >= 0);
    println!("å…¨éƒ¨ä¸ºæ­£: {}", all_positive); // true
    
    // å¹¶è¡Œè¿‡æ»¤
    let evens: Vec<i32> = v.par_iter()
                          .filter(|&&x| x % 2 == 0)
                          .cloned()
                          .collect();
    println!("éƒ¨åˆ†å¶æ•°: {:?}", &evens[0..10]);
    
    // å¹¶è¡Œç¼©å‡
    let sum = v.par_iter()
               .reduce(|| &0, |a, b| &(a + b));
    println!("å¹¶è¡Œæ±‚å’Œ: {}", sum);
}

// è‡ªå®šä¹‰å¹¶è¡Œä»»åŠ¡
fn custom_parallel_work() {
    let results: Vec<_> = (0..1000).collect();
    
    // è‡ªå®šä¹‰å¤æ‚è®¡ç®—
    let processed: Vec<i32> = results.par_iter()
        .map(|&i| {
            // æ¨¡æ‹Ÿå¯†é›†è®¡ç®—
            let mut result = i;
            for _ in 0..i % 10 {
                result = (result * result) % 997; // ä¸€äº›è®¡ç®—
            }
            result
        })
        .collect();
    
    println!("å¤„ç†ç»“æœ(éƒ¨åˆ†): {:?}", &processed[0..10]);
    
    // ä½¿ç”¨for_eachå¹¶è¡Œæ‰§è¡Œ
    let mut modified = vec![0; 1000];
    (0..1000).into_par_iter().for_each(|i| {
        modified[i] = i * i;
    });
    
    println!("ä¿®æ”¹ç»“æœ(éƒ¨åˆ†): {:?}", &modified[0..10]);
}

// è‡ªå®šä¹‰å¹¶è¡Œåˆ†è§£å’Œåˆå¹¶
fn custom_join() {
    // å¹¶è¡Œåˆå¹¶æ’åºç¤ºä¾‹
    fn merge_sort<T: Ord + Send + Copy>(v: &mut [T]) {
        if v.len() <= 1 {
            return;
        }
        
        let mid = v.len() / 2;
        
        // å¹¶è¡Œé€’å½’æ’åºä¸¤åŠ
        rayon::join(
            || merge_sort(&mut v[..mid]),
            || merge_sort(&mut v[mid..])
        );
        
        // åˆå¹¶å·²æ’åºçš„ä¸¤åŠ
        let mut tmp = v.to_vec();
        let (left, right) = v.split_at(mid);
        merge(&left, &right, &mut tmp[..]);
        v.copy_from_slice(&tmp);
    }
    
    // åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„æ•°ç»„
    fn merge<T: Ord + Copy>(left: &[T], right: &[T], output: &mut [T]) {
        let mut left_iter = left.iter();
        let mut right_iter = right.iter();
        let mut left_item = left_iter.next();
        let mut right_item = right_iter.next();
        
        for out in output {
            let take_left = match (left_item, right_item) {
                (Some(l), None) => true,
                (None, Some(_)) => false,
                (Some(l), Some(r)) => l <= r,
                (None, None) => unreachable!(),
            };
            
            if take_left {
                *out = *left_item.unwrap();
                left_item = left_iter.next();
            } else {
                *out = *right_item.unwrap();
                right_item = right_iter.next();
            }
        }
    }
    
    // ä½¿ç”¨å¹¶è¡Œåˆå¹¶æ’åº
    let mut v = vec![7, 1, 9, 3, 5, 2, 8, 4, 6];
    merge_sort(&mut v);
    println!("æ’åºå: {:?}", v);
}
```

### 6.3 å¼‚æ­¥ç¼–ç¨‹

#### 6.3.1 Futureä¸å¼‚æ­¥å‡½æ•°

Rustçš„å¼‚æ­¥ç¼–ç¨‹åŸºäº`Future`ç‰¹å¾å’Œ`async/await`è¯­æ³•ï¼š

```rust
// åŸºæœ¬Futureå’Œå¼‚æ­¥å‡½æ•°
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use async_std::task;
use std::time::Duration;

// æ‰‹åŠ¨å®ç°Future
struct Delay {
    when: std::time::Instant,
}

impl Future for Delay {
    type Output = ();
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if std::time::Instant::now() >= self.when {
            Poll::Ready(())
        } else {
            // è®¾ç½®å”¤é†’å™¨ï¼Œè®©æ‰§è¡Œå™¨åœ¨é€‚å½“æ—¶æœºå†æ¬¡è½®è¯¢
            let waker = cx.waker().clone();
            let when = self.when;
            
            std::thread::spawn(move || {
                let now = std::time::Instant::now();
                if now < when {
                    std::thread::sleep(when - now);
                }
                waker.wake();
            });
            
            Poll::Pending
        }
    }
}

// ä½¿ç”¨async/await
async fn delay(duration: Duration) {
    task::sleep(duration).await;
    println!("å»¶è¿Ÿ {:?} å", duration);
}

// ç»„åˆå¤šä¸ªå¼‚æ­¥æ“ä½œ
async fn async_main() {
    println!("å¼€å§‹");
    
    // å¹¶å‘æ‰§è¡Œä¸¤ä¸ªå¼‚æ­¥æ“ä½œ
    let future1 = delay(Duration::from_millis(100));
    let future2 = delay(Duration::from_millis(200));
    
    // ç­‰å¾…æ‰€æœ‰futureå®Œæˆ
    futures::join!(future1, future2);
    
    println!("æ‰€æœ‰å»¶è¿Ÿå®Œæˆ");
}

// è¿è¡Œå¼‚æ­¥å‡½æ•°
fn run_async() {
    task::block_on(async_main());
}
```

å¼‚æ­¥æµæ§åˆ¶ï¼š

```rust
// å¼‚æ­¥æµæ§åˆ¶ç»“æ„
use futures::{stream, StreamExt};

// é¡ºåºå¼‚æ­¥
async fn sequential() {
    println!("å¼€å§‹é¡ºåºæ‰§è¡Œ");
    
    delay(Duration::from_millis(100)).await;
    println!("ç¬¬ä¸€ä¸ªæ“ä½œå®Œæˆ");
    
    delay(Duration::from_millis(200)).await;
    println!("ç¬¬äºŒä¸ªæ“ä½œå®Œæˆ");
    
    println!("é¡ºåºæ‰§è¡Œå®Œæˆ");
}

// å¹¶å‘å¼‚æ­¥
async fn concurrent() {
    println!("å¼€å§‹å¹¶å‘æ‰§è¡Œ");
    
    // ä½¿ç”¨join!å¹¶å‘æ‰§è¡Œå¤šä¸ªfuture
    let (_, _) = futures::join!(
        delay(Duration::from_millis(100)),
        delay(Duration::from_millis(200))
    );
    
    println!("å¹¶å‘æ‰§è¡Œå®Œæˆ");
}

// å¤„ç†å¼‚æ­¥æµ
async fn process_stream() {
    // åˆ›å»ºä¸€ä¸ªæ•°å­—æµ
    let mut stream = stream::iter(1..=5);
    
    // ä½¿ç”¨while letå¤„ç†æµ
    while let Some(value) = stream.next().await {
        println!("æµå€¼: {}", value);
        task::sleep(Duration::from_millis(50)).await;
    }
    
    // ä½¿ç”¨mapå’Œcollectå¤„ç†æµ
    let values: Vec<i32> = stream::iter(1..=5)
        .map(|x| async move { x * x })
        .then(|fut| fut)  // ä¸²è¡Œæ‰§è¡Œæ¯ä¸ªfuture
        .collect()
        .await;
    
    println!("æµå¤„ç†ç»“æœ: {:?}", values);
}

// è¿è¡Œå¼‚æ­¥æµç¨‹
fn run_async_workflow() {
    task::block_on(async {
        sequential().await;
        concurrent().await;
        process_stream().await;
    });
}
```

#### 6.3.2 å¼‚æ­¥è¿è¡Œæ—¶

Rustçš„å¼‚æ­¥ç¼–ç¨‹éœ€è¦è¿è¡Œæ—¶åº“æ¥æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ï¼š

```rust
// Tokioè¿è¡Œæ—¶
use tokio::time::{sleep, Duration};
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};

// åŸºæœ¬Tokioå¼‚æ­¥
#[tokio::main]
async fn main() -> io::Result<()> {
    println!("å¼€å§‹Tokioç¨‹åº");
    
    // å¹¶å‘IOæ“ä½œ
    let handle = tokio::spawn(async {
        // å¼‚æ­¥ç­‰å¾…
        sleep(Duration::from_millis(100)).await;
        
        // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
        let sum: u32 = (1..1000).sum();
        sum
    });
    
    // å¼‚æ­¥æ–‡ä»¶IO
    let mut file = File::create("example.txt").await?;
    file.write_all(b"Hello, async world!").await?;
    
    let mut file = File::open("example.txt").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    
    println!("æ–‡ä»¶å†…å®¹: {}", contents);
    
    // ç­‰å¾…ç”Ÿæˆçš„ä»»åŠ¡
    let result = handle.await?;
    println!("ä»»åŠ¡ç»“æœ: {}", result);
    
    Ok(())
}

// å¤šä»»åŠ¡å¹¶å‘
async fn concurrent_tasks() {
    // åˆ›å»ºå¤šä¸ªä»»åŠ¡
    let mut handles = Vec::new();
    
    for i in 0..10 {
        let handle = tokio::spawn(async move {
            // æ¨¡æ‹Ÿä¸åŒçš„å·¥ä½œè´Ÿè½½
            sleep(Duration::from_millis(50 * i)).await;
            println!("ä»»åŠ¡ {} å®Œæˆ", i);
            i
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    let mut results = Vec::new();
    for handle in handles {
        results.push(handle.await.unwrap());
    }
    
    println!("æ‰€æœ‰ä»»åŠ¡ç»“æœ: {:?}", results);
}

// èµ„æºå…±äº«
use std::sync::Arc;
use tokio::sync::Mutex;

async fn shared_state() {
    // åœ¨ä»»åŠ¡é—´å…±äº«çŠ¶æ€
    let counter = Arc::new(Mutex::new(0));
    let mut handles = Vec::new();
    
    for i in 0..5 {
        let counter = Arc::clone(&counter);
        let handle = tokio::spawn(async move {
            // è·å–é”
            let mut lock = counter.lock().await;
            *lock += 1;
            println!("ä»»åŠ¡ {} å¢åŠ è®¡æ•°åˆ° {}", i, *lock);
            
            // å»¶è¿Ÿä¸€ä¸‹ï¼Œæ¨¡æ‹Ÿå·¥ä½œ
            drop(lock); // é‡Šæ”¾é”
            sleep(Duration::from_millis(50)).await;
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().await);
}
```

å¼‚æ­¥é€šé“å’Œä¿¡å·ï¼š

```rust
// å¼‚æ­¥é€šé“
use tokio::sync::{mpsc, oneshot};

async fn mpsc_channels() {
    // åˆ›å»ºå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…é€šé“
    let (tx, mut rx) = mpsc::channel(16); // ç¼“å†²åŒºå¤§å°ä¸º16
    
    // ç”Ÿäº§è€…ä»»åŠ¡
    for i in 0..5 {
        let mut tx = tx.clone();
        tokio::spawn(async move {
            // å‘é€å¤šä¸ªæ¶ˆæ¯
            for j in 0..3 {
                let msg = format!("ä»»åŠ¡ {} æ¶ˆæ¯ {}", i, j);
                if tx.send(msg).await.is_err() {
                    println!("æ¥æ”¶è€…å·²å…³é—­");
                    return;
                }
                sleep(Duration::from_millis(100)).await;
            }
        });
    }
    
    // ä¸¢å¼ƒåŸå§‹å‘é€è€…
    drop(tx);
    
    // æ¶ˆè´¹è€…æ¥æ”¶æ‰€æœ‰æ¶ˆæ¯
    while let Some(msg) = rx.recv().await {
        println!("æ”¶åˆ°: {}", msg);
    }
    
    println!("æ‰€æœ‰å‘é€è€…å…³é—­ï¼Œé€šé“å·²å…³é—­");
}

// ä¸€æ¬¡æ€§é€šé“
async fn oneshot_channels() {
    // åˆ›å»ºå“åº”é€šé“
    let (tx, rx) = oneshot::channel();
    
<think>æˆ‘éœ€è¦ç»§ç»­ä¹‹å‰çš„å†…å®¹ï¼Œå®Œæˆå…³äºRustè¯­è¨€çš„ä»‹ç»ã€‚ä»å‰é¢çš„å†…å®¹çœ‹ï¼Œæˆ‘æ­£åœ¨è®²è§£Rustçš„å¹¶å‘ç¼–ç¨‹éƒ¨åˆ†ï¼Œç‰¹åˆ«æ˜¯å…³äºå¼‚æ­¥é€šé“å’Œä¿¡å·çš„å†…å®¹ã€‚æˆ‘å°†æ¥ç€ä»‹ç»å¼‚æ­¥ç¼–ç¨‹ç›¸å…³çš„å†…å®¹ï¼Œç„¶åç»§ç»­å®Œæˆç¬¬6ç« çš„å‰©ä½™å†…å®¹åŠç¬¬7ç« çš„å…ƒç¼–ç¨‹éƒ¨åˆ†ã€‚</think># Rustè¯­è¨€è¯­æ³•è¯­ä¹‰ç‰¹æ€§å…¨é¢è§£æï¼šå‰9ç« è¯¦è§£ï¼ˆç»­ï¼‰

## 6. å¹¶å‘ï¼ˆç»­ï¼‰

#### 6.3.2 å¼‚æ­¥è¿è¡Œæ—¶ï¼ˆç»­ï¼‰

```rust
// ä¸€æ¬¡æ€§é€šé“
async fn oneshot_channels() {
    // åˆ›å»ºå“åº”é€šé“
    let (tx, rx) = oneshot::channel();
    
    // å¯åŠ¨ä»»åŠ¡æ‰§è¡Œå·¥ä½œ
    tokio::spawn(async move {
        // æ¨¡æ‹Ÿä¸€äº›å¼‚æ­¥å·¥ä½œ
        sleep(Duration::from_millis(200)).await;
        
        // å‘é€ç»“æœ
        if tx.send(42).is_err() {
            println!("æ¥æ”¶è€…å·²ä¸¢å¼ƒ");
        }
    });
    
    // ç­‰å¾…ç»“æœ
    match rx.await {
        Ok(value) => println!("æ”¶åˆ°ç»“æœ: {}", value),
        Err(_) => println!("å‘é€è€…ä¸¢å¼ƒäº†é€šé“"),
    }
}

// å¹¿æ’­é€šé“
use tokio::sync::broadcast;

async fn broadcast_channels() {
    // åˆ›å»ºå¹¿æ’­é€šé“
    let (tx, _) = broadcast::channel(16);
    
    // åˆ›å»ºå¤šä¸ªæ¥æ”¶è€…
    let mut rx1 = tx.subscribe();
    let mut rx2 = tx.subscribe();
    
    // å‘é€æ¶ˆæ¯
    tx.send("è¿™æ˜¯ä¸€æ¡å¹¿æ’­æ¶ˆæ¯").unwrap();
    
    // æ¥æ”¶è€…1å¤„ç†æ¶ˆæ¯
    let handle1 = tokio::spawn(async move {
        match rx1.recv().await {
            Ok(msg) => println!("æ¥æ”¶è€…1æ”¶åˆ°: {}", msg),
            Err(e) => println!("æ¥æ”¶è€…1é”™è¯¯: {:?}", e),
        }
    });
    
    // æ¥æ”¶è€…2å¤„ç†æ¶ˆæ¯
    let handle2 = tokio::spawn(async move {
        match rx2.recv().await {
            Ok(msg) => println!("æ¥æ”¶è€…2æ”¶åˆ°: {}", msg),
            Err(e) => println!("æ¥æ”¶è€…2é”™è¯¯: {:?}", e),
        }
    });
    
    // ç­‰å¾…ä¸¤ä¸ªæ¥æ”¶è€…
    handle1.await.unwrap();
    handle2.await.unwrap();
}

// ä½¿ç”¨semaphoreæ§åˆ¶å¹¶å‘
use tokio::sync::Semaphore;

async fn semaphore_example() {
    // åˆ›å»ºä¿¡å·é‡ï¼Œé™åˆ¶åŒæ—¶è¿è¡Œçš„ä»»åŠ¡æ•°é‡
    let semaphore = Arc::new(Semaphore::new(3)); // æœ€å¤š3ä¸ªå¹¶å‘ä»»åŠ¡
    let mut handles = Vec::new();
    
    for i in 0..10 {
        let sem = Arc::clone(&semaphore);
        let handle = tokio::spawn(async move {
            // è·å–è®¸å¯
            let permit = sem.acquire().await.unwrap();
            println!("ä»»åŠ¡ {} è·å–è®¸å¯ï¼Œå¼€å§‹æ‰§è¡Œ", i);
            
            // æ¨¡æ‹Ÿå·¥ä½œ
            sleep(Duration::from_millis(200)).await;
            
            println!("ä»»åŠ¡ {} å®Œæˆï¼Œé‡Šæ”¾è®¸å¯", i);
            // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾è®¸å¯
            drop(permit);
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡
    for handle in handles {
        handle.await.unwrap();
    }
}
```

#### 6.3.3 Async/Awaitæ¨¡å¼

é«˜æ•ˆä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹çš„å¸¸è§æ¨¡å¼ï¼š

```rust
// å¼‚æ­¥é”™è¯¯å¤„ç†
use std::io;
use futures::future::{self, TryFutureExt};

async fn async_error_handling() -> Result<(), Box<dyn std::error::Error>> {
    // æ–¹æ³•1: ç›´æ¥ä½¿ç”¨?è¿ç®—ç¬¦
    let file = File::open("config.txt").await?;
    
    // æ–¹æ³•2: ä½¿ç”¨match
    let data = match File::open("data.txt").await {
        Ok(mut file) => {
            let mut content = String::new();
            file.read_to_string(&mut content).await?;
            content
        }
        Err(e) => {
            eprintln!("æ— æ³•æ‰“å¼€æ•°æ®æ–‡ä»¶: {}", e);
            "é»˜è®¤æ•°æ®".to_string()
        }
    };
    
    // æ–¹æ³•3: ä½¿ç”¨ç»„åˆå™¨
    let result = File::open("optional.txt")
        .await
        .map_err(|e| format!("æ–‡ä»¶é”™è¯¯: {}", e))
        .and_then(|mut file| async move {
            let mut content = String::new();
            file.read_to_string(&mut content).await?;
            Ok(content)
        });
    
    // å¤„ç†å¯é€‰æ–‡ä»¶
    match result {
        Ok(content) => println!("å¯é€‰æ–‡ä»¶å†…å®¹: {}", content),
        Err(e) => println!("æ— æ³•è¯»å–å¯é€‰æ–‡ä»¶: {}", e),
    }
    
    // è½¬æ¢é”™è¯¯ç±»å‹
    let result: Result<String, io::Error> = File::open("another.txt")
        .await
        .and_then(|mut file| {
            let mut content = String::new();
            file.read_to_string(&mut content)?;
            Ok(content)
        });
    
    let content = result.unwrap_or_else(|_| "é»˜è®¤å†…å®¹".to_string());
    println!("å†…å®¹: {}", content);
    
    Ok(())
}

// ä½¿ç”¨selectè¿›è¡Œå¹¶å‘
use futures::future::select;
use futures::pin_mut;

async fn select_example() {
    // åˆ›å»ºä¸¤ä¸ªfuture
    let fast = async {
        sleep(Duration::from_millis(100)).await;
        println!("å¿«é€Ÿä»»åŠ¡å®Œæˆ");
        1
    };
    
    let slow = async {
        sleep(Duration::from_millis(200)).await;
        println!("æ…¢é€Ÿä»»åŠ¡å®Œæˆ");
        2
    };
    
    // Pin futures
    pin_mut!(fast);
    pin_mut!(slow);
    
    // ç­‰å¾…ç¬¬ä¸€ä¸ªå®Œæˆçš„future
    let result = select(fast, slow).await;
    
    match result {
        future::Either::Left((value, _remaining_future)) => {
            println!("å¿«é€Ÿå®Œæˆï¼Œå€¼: {}", value);
        }
        future::Either::Right((value, _remaining_future)) => {
            println!("æ…¢é€Ÿå®Œæˆï¼Œå€¼: {}", value);
        }
    }
}

// è¶…æ—¶æ§åˆ¶
use tokio::time::timeout;

async fn timeout_control() {
    // åˆ›å»ºå¯èƒ½è¶…æ—¶çš„ä»»åŠ¡
    let long_task = async {
        println!("é•¿ä»»åŠ¡å¼€å§‹");
        sleep(Duration::from_secs(2)).await;
        println!("é•¿ä»»åŠ¡å®Œæˆ");
        "é•¿ä»»åŠ¡ç»“æœ"
    };
    
    // æ·»åŠ è¶…æ—¶
    match timeout(Duration::from_secs(1), long_task).await {
        Ok(result) => println!("ä»»åŠ¡åœ¨è¶…æ—¶å‰å®Œæˆ: {}", result),
        Err(_) => println!("ä»»åŠ¡è¶…æ—¶"),
    }
    
    // ä½¿ç”¨selectå®ç°è¶…æ—¶
    let task = async {
        sleep(Duration::from_secs(2)).await;
        "ä»»åŠ¡ç»“æœ"
    };
    
    let timer = sleep(Duration::from_secs(1));
    
    pin_mut!(task);
    pin_mut!(timer);
    
    match select(task, timer).await {
        future::Either::Left((result, _)) => {
            println!("ä»»åŠ¡åœ¨è®¡æ—¶å™¨å‰å®Œæˆ: {}", result);
        }
        future::Either::Right((_, _)) => {
            println!("è®¡æ—¶å™¨åˆ°æœŸï¼Œä»»åŠ¡æœªå®Œæˆ");
        }
    }
}

// å¼‚æ­¥èµ„æºæ± 
use std::collections::VecDeque;
use tokio::sync::{Mutex as TokioMutex, Semaphore};

struct AsyncPool<T> {
    resources: TokioMutex<VecDeque<T>>,
    semaphore: Semaphore,
}

impl<T> AsyncPool<T> {
    // åˆ›å»ºæ–°æ± 
    fn new(resources: Vec<T>, max_concurrent: usize) -> Self {
        AsyncPool {
            resources: TokioMutex::new(resources.into()),
            semaphore: Semaphore::new(max_concurrent),
        }
    }
    
    // è·å–èµ„æº
    async fn acquire(&self) -> PoolGuard<'_, T> {
        // è·å–ä¿¡å·é‡è®¸å¯
        let permit = self.semaphore.acquire().await.unwrap();
        
        // è·å–èµ„æº
        let mut resources = self.resources.lock().await;
        let resource = resources.pop_front().expect("èµ„æºæ± ä¸ºç©º");
        
        // è¿”å›å¸¦èµ„æºçš„å®ˆå«
        PoolGuard {
            pool: self,
            resource: Some(resource),
            _permit: permit,
        }
    }
    
    // å†…éƒ¨æ–¹æ³•ï¼šé‡Šæ”¾èµ„æºå›æ± 
    async fn release(&self, resource: T) {
        let mut resources = self.resources.lock().await;
        resources.push_back(resource);
    }
}

// èµ„æºå®ˆå«
struct PoolGuard<'a, T> {
    pool: &'a AsyncPool<T>,
    resource: Option<T>,
    _permit: tokio::sync::OwnedSemaphorePermit,
}

impl<'a, T> PoolGuard<'a, T> {
    // è®¿é—®èµ„æº
    fn resource(&self) -> &T {
        self.resource.as_ref().unwrap()
    }
    
    // è®¿é—®èµ„æºçš„å¯å˜å¼•ç”¨
    fn resource_mut(&mut self) -> &mut T {
        self.resource.as_mut().unwrap()
    }
}

impl<'a, T> Drop for PoolGuard<'a, T> {
    fn drop(&mut self) {
        // å–å‡ºèµ„æº
        if let Some(resource) = self.resource.take() {
            // åˆ›å»ºè¿è¡Œæ—¶å¤„ç†å¼‚æ­¥é‡Šæ”¾
            let pool = self.pool;
            tokio::spawn(async move {
                pool.release(resource).await;
            });
        }
    }
}

async fn use_async_pool() {
    // åˆ›å»ºè¿æ¥æ± 
    let pool = Arc::new(AsyncPool::new(
        vec!["è¿æ¥1".to_string(), "è¿æ¥2".to_string(), "è¿æ¥3".to_string()],
        2, // æœ€å¤šåŒæ—¶ä½¿ç”¨2ä¸ªè¿æ¥
    ));
    
    // åŒæ—¶å¯åŠ¨å¤šä¸ªä»»åŠ¡
    let mut handles = Vec::new();
    
    for i in 0..5 {
        let pool = Arc::clone(&pool);
        let handle = tokio::spawn(async move {
            // è·å–è¿æ¥
            let mut conn = pool.acquire().await;
            println!("ä»»åŠ¡ {} è·å–è¿æ¥: {}", i, conn.resource());
            
            // ä½¿ç”¨è¿æ¥
            sleep(Duration::from_millis(100 * (i + 1))).await;
            
            // ä¿®æ”¹è¿æ¥çŠ¶æ€
            *conn.resource_mut() = format!("{}(ç”±ä»»åŠ¡{}ä½¿ç”¨)", conn.resource(), i);
            
            println!("ä»»åŠ¡ {} é‡Šæ”¾è¿æ¥: {}", i, conn.resource());
            // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾å›æ± 
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 6.4 å¹¶å‘è®¾è®¡æ¨¡å¼

#### 6.4.1 Actoræ¨¡å‹

Actoræ¨¡å‹æ˜¯ä¸€ç§å¹¶å‘ç¼–ç¨‹èŒƒå¼ï¼Œæ¯ä¸ªActoræ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è®¡ç®—å•å…ƒï¼š

```rust
// åŸºæœ¬Actoræ¨¡å‹
use tokio::sync::mpsc;
use std::sync::Arc;

// å®šä¹‰æ¶ˆæ¯ç±»å‹
enum Message {
    Increment,
    Decrement,
    GetValue(oneshot::Sender<i32>),
    Stop,
}

// Actorç»“æ„
struct CounterActor {
    value: i32,
}

impl CounterActor {
    fn new() -> Self {
        CounterActor { value: 0 }
    }
    
    // è¿è¡ŒActorçš„æ–¹æ³•
    async fn run(mut self, mut rx: mpsc::Receiver<Message>) {
        while let Some(msg) = rx.recv().await {
            match msg {
                Message::Increment => {
                    self.value += 1;
                    println!("å¢åŠ å€¼åˆ° {}", self.value);
                }
                Message::Decrement => {
                    self.value -= 1;
                    println!("å‡å°‘å€¼åˆ° {}", self.value);
                }
                Message::GetValue(resp) => {
                    let _ = resp.send(self.value);
                }
                Message::Stop => {
                    println!("åœæ­¢Actorï¼Œæœ€ç»ˆå€¼: {}", self.value);
                    break;
                }
            }
        }
    }
}

// Actorå¥æŸ„
struct CounterHandle {
    sender: mpsc::Sender<Message>,
}

impl CounterHandle {
    fn new() -> (Self, mpsc::Receiver<Message>) {
        let (sender, receiver) = mpsc::channel(16);
        (CounterHandle { sender }, receiver)
    }
    
    // å‘é€æ¶ˆæ¯çš„æ–¹æ³•
    async fn increment(&self) -> Result<(), mpsc::error::SendError<Message>> {
        self.sender.send(Message::Increment).await
    }
    
    async fn decrement(&self) -> Result<(), mpsc::error::SendError<Message>> {
        self.sender.send(Message::Decrement).await
    }
    
    async fn get_value(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let (resp_tx, resp_rx) = oneshot::channel();
        self.sender.send(Message::GetValue(resp_tx)).await?;
        Ok(resp_rx.await?)
    }
    
    async fn stop(&self) -> Result<(), mpsc::error::SendError<Message>> {
        self.sender.send(Message::Stop).await
    }
}

// ä½¿ç”¨Actor
async fn use_actor() {
    // åˆ›å»ºActorå®ä¾‹
    let (handle, receiver) = CounterHandle::new();
    let actor = CounterActor::new();
    
    // åœ¨å•ç‹¬ä»»åŠ¡ä¸­è¿è¡ŒActor
    let actor_task = tokio::spawn(async move {
        actor.run(receiver).await;
    });
    
    // ä½¿ç”¨å¥æŸ„å‘é€æ¶ˆæ¯
    handle.increment().await.unwrap();
    handle.increment().await.unwrap();
    handle.decrement().await.unwrap();
    
    // è·å–å½“å‰å€¼
    let value = handle.get_value().await.unwrap();
    println!("å½“å‰å€¼: {}", value);
    
    // åœæ­¢Actor
    handle.stop().await.unwrap();
    
    // ç­‰å¾…Actorä»»åŠ¡å®Œæˆ
    actor_task.await.unwrap();
}
```

#### 6.4.2 å·¥ä½œæ± ä¸ä»»åŠ¡åˆ†å‘

å·¥ä½œæ± æ¨¡å¼å…è®¸é«˜æ•ˆç®¡ç†å’Œåˆ†å‘ä»»åŠ¡ï¼š

```rust
// åŸºæœ¬å·¥ä½œæ± 
use tokio::sync::{mpsc, oneshot};
use std::sync::Arc;

// ä»»åŠ¡å®šä¹‰
struct Task {
    id: usize,
    work: Box<dyn FnOnce() -> String + Send + 'static>,
    response: oneshot::Sender<String>,
}

// å·¥ä½œæ± å®ç°
struct WorkerPool {
    sender: mpsc::Sender<Task>,
}

impl WorkerPool {
    // åˆ›å»ºæ–°å·¥ä½œæ± 
    fn new(size: usize) -> Self {
        let (sender, receiver) = mpsc::channel(100);
        let receiver = Arc::new(tokio::sync::Mutex::new(receiver));
        
        // åˆ›å»ºå·¥ä½œè€…çº¿ç¨‹
        for id in 0..size {
            let receiver = Arc::clone(&receiver);
            tokio::spawn(async move {
                Self::run_worker(id, receiver).await;
            });
        }
        
        WorkerPool { sender }
    }
    
    // æäº¤ä»»åŠ¡
    async fn submit<F>(&self, work: F) -> Result<String, Box<dyn std::error::Error>>
    where
        F: FnOnce() -> String + Send + 'static,
    {
        let (response_sender, response_receiver) = oneshot::channel();
        
        // åˆ›å»ºä»»åŠ¡
        let task = Task {
            id: rand::random(),
            work: Box::new(work),
            response: response_sender,
        };
        
        // å‘é€ä»»åŠ¡åˆ°å·¥ä½œé˜Ÿåˆ—
        self.sender.send(task).await?;
        
        // ç­‰å¾…ç»“æœ
        Ok(response_receiver.await?)
    }
    
    // å·¥ä½œè€…ä¸»å¾ªç¯
    async fn run_worker(id: usize, receiver: Arc<tokio::sync::Mutex<mpsc::Receiver<Task>>>) {
        println!("å·¥ä½œè€… {} å¯åŠ¨", id);
        
        loop {
            // è·å–ä»»åŠ¡
            let task = {
                let mut rx = receiver.lock().await;
                match rx.recv().await {
                    Some(task) => task,
                    None => {
                        println!("å·¥ä½œè€… {} å…³é—­ï¼Œæ²¡æœ‰æ›´å¤šä»»åŠ¡", id);
                        break;
                    }
                }
            };
            
            println!("å·¥ä½œè€… {} å¤„ç†ä»»åŠ¡ {}", id, task.id);
            
            // æ‰§è¡Œä»»åŠ¡
            let result = (task.work)();
            
            // å‘é€ç»“æœ
            if task.response.send(result).is_err() {
                println!("å·¥ä½œè€… {}: å®¢æˆ·ç«¯å·²æ”¾å¼ƒä»»åŠ¡ {}", id, task.id);
            }
        }
    }
}

// ä½¿ç”¨å·¥ä½œæ± 
async fn use_worker_pool() {
    // åˆ›å»ºå·¥ä½œæ± 
    let pool = WorkerPool::new(4);
    
    // æäº¤ä»»åŠ¡
    let mut handles = Vec::new();
    
    for i in 0..10 {
        let pool = &pool;
        let handle = tokio::spawn(async move {
            let task_id = i;
            
            let result = pool.submit(move || {
                // æ¨¡æ‹Ÿå·¥ä½œ
                std::thread::sleep(Duration::from_millis(100));
                format!("ä»»åŠ¡ {} çš„ç»“æœ", task_id)
            }).await.unwrap();
            
            println!("æ”¶åˆ°ä»»åŠ¡ {} çš„ç»“æœ: {}", task_id, result);
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for handle in handles {
        handle.await.unwrap();
    }
}
```

#### 6.4.3 å¹¶å‘ç»„åˆæ¨¡å¼

ç»„åˆå„ç§å¹¶å‘åŸè¯­ä»¥åˆ›å»ºé«˜çº§å¹¶å‘æ¨¡å¼ï¼š

```rust
// è¯»å†™é”ç¼“å­˜
use std::collections::HashMap;
use std::hash::Hash;
use std::sync::Arc;
use tokio::sync::RwLock;

// ç®€å•ç¼“å­˜å®ç°
struct Cache<K, V> {
    storage: RwLock<HashMap<K, V>>,
}

impl<K, V> Cache<K, V>
where
    K: Eq + Hash + Clone + Send + Sync + 'static,
    V: Clone + Send + Sync + 'static,
{
    fn new() -> Self {
        Cache {
            storage: RwLock::new(HashMap::new()),
        }
    }
    
    // è·å–æˆ–è®¡ç®—å€¼
    async fn get_or_compute<F>(&self, key: K, compute_fn: F) -> V
    where
        F: FnOnce(&K) -> V,
    {
        // é¦–å…ˆå°è¯•è¯»å–é”
        {
            let cache = self.storage.read().await;
            if let Some(value) = cache.get(&key) {
                return value.clone();
            }
        }
        
        // å€¼ä¸å­˜åœ¨ï¼Œè·å–å†™é”
        let mut cache = self.storage.write().await;
        
        // å†æ¬¡æ£€æŸ¥ï¼ˆé˜²æ­¢åœ¨è·å–å†™é”æœŸé—´å…¶ä»–çº¿ç¨‹å·²æ·»åŠ å€¼ï¼‰
        if let Some(value) = cache.get(&key) {
            return value.clone();
        }
        
        // è®¡ç®—æ–°å€¼
        let value = compute_fn(&key);
        cache.insert(key, value.clone());
        value
    }
    
    // æ¸…é™¤ç¼“å­˜
    async fn clear(&self) {
        let mut cache = self.storage.write().await;
        cache.clear();
    }
}

// ä½¿ç”¨ç¼“å­˜
async fn use_cache() {
    // åˆ›å»ºç¼“å­˜
    let cache = Arc::new(Cache::<String, i32>::new());
    
    // åŒæ—¶æŸ¥è¯¢å¤šä¸ªå€¼
    let mut handles = Vec::new();
    
    for i in 0..5 {
        let cache = Arc::clone(&cache);
        let key = format!("key{}", i % 3); // ä¸€äº›é”®ä¼šé‡å¤
        
        let handle = tokio::spawn(async move {
            // è·å–æˆ–è®¡ç®—å€¼
            let value = cache.get_or_compute(key.clone(), |k| {
                println!("è®¡ç®—é”® '{}' çš„å€¼", k);
                // æ¨¡æ‹Ÿæ˜‚è´µè®¡ç®—
                std::thread::sleep(Duration::from_millis(100));
                k.len() as i32 * 10
            }).await;
            
            println!("é”® '{}' çš„å€¼: {}", key, value);
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰æŸ¥è¯¢
    for handle in handles {
        handle.await.unwrap();
    }
}

// å¤šé˜¶æ®µå¤„ç†ç®¡é“
use futures::stream::{self, StreamExt};

async fn pipeline_processing() {
    // åˆ›å»ºæ•°æ®æº
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // åˆ›å»ºå¤„ç†ç®¡é“
    let results = stream::iter(data)
        // ç¬¬ä¸€é˜¶æ®µ: è¿‡æ»¤
        .filter(|&x| future::ready(x % 2 == 0))
        // ç¬¬äºŒé˜¶æ®µ: è½¬æ¢
        .map(|x| async move {
            // å¼‚æ­¥è½¬æ¢
            sleep(Duration::from_millis(50)).await;
            x * x
        })
        // æ‰§è¡Œå¼‚æ­¥è½¬æ¢
        .buffer_unordered(4) // æœ€å¤š4ä¸ªå¹¶å‘è½¬æ¢
        // ç¬¬ä¸‰é˜¶æ®µ: å¦ä¸€ä¸ªè¿‡æ»¤
        .filter(|&x| future::ready(x > 20))
        // æ”¶é›†ç»“æœ
        .collect::<Vec<_>>()
        .await;
    
    println!("ç®¡é“ç»“æœ: {:?}", results);
}

// äº‹ä»¶æ€»çº¿æ¨¡å¼
use tokio::sync::broadcast;

// äº‹ä»¶å®šä¹‰
#[derive(Clone, Debug)]
enum SystemEvent {
    UserLoggedIn { user_id: u64, username: String },
    DataChanged { entity: String, id: u64 },
    SystemShutdown { reason: String },
}

// äº‹ä»¶æ€»çº¿
struct EventBus {
    sender: broadcast::Sender<SystemEvent>,
}

impl EventBus {
    fn new(capacity: usize) -> Self {
        let (sender, _) = broadcast::channel(capacity);
        EventBus { sender }
    }
    
    // å‘å¸ƒäº‹ä»¶
    fn publish(&self, event: SystemEvent) -> Result<(), broadcast::error::SendError<SystemEvent>> {
        self.sender.send(event)
    }
    
    // è®¢é˜…äº‹ä»¶
    fn subscribe(&self) -> broadcast::Receiver<SystemEvent> {
        self.sender.subscribe()
    }
}

// ä½¿ç”¨äº‹ä»¶æ€»çº¿
async fn use_event_bus() {
    // åˆ›å»ºäº‹ä»¶æ€»çº¿
    let bus = Arc::new(EventBus::new(16));
    
    // åˆ›å»ºç›‘å¬å™¨
    let mut handles = Vec::new();
    
    // ç”¨æˆ·æ´»åŠ¨ç›‘å¬å™¨
    {
        let bus = Arc::clone(&bus);
        let mut rx = bus.subscribe();
        let handle = tokio::spawn(async move {
            while let Ok(event) = rx.recv().await {
                match &event {
                    SystemEvent::UserLoggedIn { user_id, username } => {
                        println!("ç”¨æˆ·ç›‘å¬å™¨: ç”¨æˆ· {} ({}) å·²ç™»å½•", username, user_id);
                    }
                    _ => {} // å¿½ç•¥å…¶ä»–äº‹ä»¶
                }
            }
        });
        handles.push(handle);
    }
    
    // ç³»ç»Ÿç›‘æ§ç›‘å¬å™¨
    {
        let bus = Arc::clone(&bus);
        let mut rx = bus.subscribe();
        let handle = tokio::spawn(async move {
            while let Ok(event) = rx.recv().await {
                match &event {
                    SystemEvent::SystemShutdown { reason } => {
                        println!("ç³»ç»Ÿç›‘å¬å™¨: ç³»ç»Ÿå…³é—­, åŸå› : {}", reason);
                    }
                    SystemEvent::DataChanged { entity, id } => {
                        println!("ç³»ç»Ÿç›‘å¬å™¨: {} {} å·²æ›´æ”¹", entity, id);
                    }
                    _ => {} // å¿½ç•¥å…¶ä»–äº‹ä»¶
                }
            }
        });
        handles.push(handle);
    }
    
    // å…¨éƒ¨äº‹ä»¶ç›‘å¬å™¨
    {
        let bus = Arc::clone(&bus);
        let mut rx = bus.subscribe();
        let handle = tokio::spawn(async move {
            while let Ok(event) = rx.recv().await {
                println!("æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨: {:?}", event);
            }
        });
        handles.push(handle);
    }
    
    // å‘å¸ƒä¸€äº›äº‹ä»¶
    sleep(Duration::from_millis(100)).await;
    bus.publish(SystemEvent::UserLoggedIn {
        user_id: 1001,
        username: "alice".to_string(),
    }).unwrap();
    
    sleep(Duration::from_millis(100)).await;
    bus.publish(SystemEvent::DataChanged {
        entity: "Profile".to_string(),
        id: 1001,
    }).unwrap();
    
    sleep(Duration::from_millis(100)).await;
    bus.publish(SystemEvent::SystemShutdown {
        reason: "ç»´æŠ¤".to_string(),
    }).unwrap();
    
    // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©ç›‘å¬å™¨å¤„ç†äº‹ä»¶
    sleep(Duration::from_secs(1)).await;
    
    // åœæ­¢æ‰€æœ‰ç›‘å¬å™¨
    for handle in handles {
        handle.abort();
    }
}
```

## 7. å…ƒç¼–ç¨‹

### 7.1 å®ç³»ç»Ÿ

#### 7.1.1 å£°æ˜å®

å£°æ˜å®ä½¿ç”¨`macro_rules!`å®šä¹‰ï¼Œå…è®¸æ¨¡å¼åŒ¹é…å’Œä»£ç ç”Ÿæˆï¼š

```rust
// åŸºæœ¬å®å®šä¹‰
macro_rules! say_hello {
    // ä¸æ¥å—ä»»ä½•å‚æ•°çš„å®
    () => {
        println!("ä½ å¥½ï¼Œä¸–ç•Œ!");
    };
}

// å¸¦å‚æ•°çš„å®
macro_rules! say_to {
    // æ¥å—ä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºå‚æ•°
    ($name:expr) => {
        println!("ä½ å¥½ï¼Œ{}!", $name);
    };
}

// å¤šç§æ¨¡å¼çš„å®
macro_rules! print_result {
    // æ¥å—ä¸€ä¸ªè¡¨è¾¾å¼
    ($expr:expr) => {
        println!("è¡¨è¾¾å¼: {} = {}", stringify!($expr), $expr);
    };
    
    // æ¥å—ä¸€ä¸ªè¡¨è¾¾å¼å’Œä¸€ä¸ªæ ¼å¼å­—ç¬¦ä¸²
    ($expr:expr, $fmt:expr) => {
        println!("{}: {}", $fmt, $expr);
    };
    
    // æ¥å—å¤šä¸ªè¡¨è¾¾å¼
    ($expr:expr, $fmt:expr, $($arg:expr),*) => {
        println!("{}: {}", $fmt, format!($expr, $($arg),*));
    };
}

// é€’å½’å®
macro_rules! vector {
    // åŸºæœ¬æƒ…å†µ: ç©ºå‘é‡
    () => {
        Vec::new()
    };
    
    // ä¸€ä¸ªå…ƒç´ 
    ($x:expr) => {
        {
            let mut v = Vec::new();
            v.push($x);
            v
        }
    };
    
    // å¤šä¸ªå…ƒç´ : $x åé¢è·Ÿç€æ›´å¤šå…ƒç´ 
    ($x:expr, $($rest:expr),*) => {
        {
            let mut v = vector![$($rest),*];
            v.insert(0, $x);
            v
        }
    };
}

// ä½¿ç”¨å®
fn use_macros() {
    // ç®€å•å®
    say_hello!();
    
    say_to!("Rust");
    
    // å¸¦ä¸åŒå‚æ•°çš„å®
    print_result!(5 + 3);
    print_result!(5 + 3, "ç»“æœ");
    print_result!("{} + {}", "ç»“æœ", 5, 3);
    
    // é€’å½’å®
    let v1 = vector![];
    let v2 = vector![1];
    let v3 = vector![1, 2, 3, 4];
    
    println!("å‘é‡: {:?}, {:?}, {:?}", v1, v2, v3);
}
```

é«˜çº§å®æŠ€æœ¯ï¼š

```rust
// å®å«ç”Ÿæ€§
macro_rules! create_function {
    ($name:ident) => {
        fn $name() {
            println!("å‡½æ•° {} è¢«è°ƒç”¨", stringify!($name));
        }
    };
}

// ä½¿ç”¨
create_function!(my_func);

// ä½¿ç”¨$crateä¿è¯å«ç”Ÿæ€§
macro_rules! log_info {
    ($($arg:tt)*) => {
        $crate::log::info!($($arg)*);
    };
}

// æ•è·å¤šä¸ªæ ‡è®°
macro_rules! hash_map {
    // ç©ºæ˜ å°„
    () => {
        std::collections::HashMap::new()
    };
    
    // é”®å€¼å¯¹åºåˆ—
    ( $($key:expr => $value:expr),* $(,)? ) => {
        {
            let mut map = std::collections::HashMap::new();
            $(
                map.insert($key, $value);
            )*
            map
        }
    };
}

// ä½¿ç”¨æ•è·
fn use_advanced_macros() {
    my_func(); // è¾“å‡º: å‡½æ•° my_func è¢«è°ƒç”¨
    
    let map = hash_map! {
        "one" => 1,
        "two" => 2,
        "three" => 3,
    };
    
    println!("æ˜ å°„: {:?}", map);
}

// æ¡ä»¶ç¼–è¯‘å®
macro_rules! cfg_if {
    // ç»ˆæ­¢æƒ…å†µ
    () => {};
    
    // å¸¦è™šæ„çš„å—
    ($(#[cfg($meta:meta)] { $($tokens:tt)* })*) => {
        $(
            #[cfg($meta)]
            { $($tokens)* }
        )*
    };
}

// ä½¿ç”¨
fn conditional_compilation() {
    cfg_if! {
        #[cfg(target_os = "windows")] {
            println!("Windowså¹³å°ç‰¹å®šä»£ç ");
        }
        #[cfg(target_os = "linux")] {
            println!("Linuxå¹³å°ç‰¹å®šä»£ç ");
        }
        #[cfg(target_os = "macos")] {
            println!("macOSå¹³å°ç‰¹å®šä»£ç ");
        }
    }
}

// åŸŸç‰¹å®šè¯­è¨€(DSL)å®
macro_rules! html {
    // æ–‡æœ¬èŠ‚ç‚¹
    ($text:expr) => {
        format!("{}", $text)
    };
    
    // å¸¦å±æ€§çš„å…ƒç´ 
    ($tag:ident [ $($attr:ident = $value:expr),* ] { $($children:tt)* }) => {
        format!(
            "<{}{}>{}</{}>",
            stringify!($tag),
            html_attrs!($($attr = $value),*),
            html!($($children)*),
            stringify!($tag)
        )
    };
    
    // ä¸å¸¦å±æ€§çš„å…ƒç´ 
    ($tag:ident { $($children:tt)* }) => {
        html!($tag [] { $($children)* })
    };
    
    // ç»„åˆå¤šä¸ªèŠ‚ç‚¹
    ($($node:tt)*) => {
        format!("{}", concat_nodes!($(html!($node)),*))
    };
}

// è¾…åŠ©å®: ç”ŸæˆHTMLå±æ€§
macro_rules! html_attrs {
    // æ— å±æ€§
    () => {
        ""
    };
    
    // å±æ€§åˆ—è¡¨
    ($($attr:ident = $value:expr),*) => {
        format!(
            " {}",
            concat_attrs!($(stringify!($attr) = $value),*)
        )
    };
}

// è¾…åŠ©å®: æ‹¼æ¥å±æ€§
macro_rules! concat_attrs {
    // ç©º
    () => {
        ""
    };
    
    // ä¸€ä¸ªå±æ€§
    ($attr:expr = $value:expr) => {
        format!("{}=\"{}\"", $attr, $value)
    };
    
    // å¤šä¸ªå±æ€§
    ($attr:expr = $value:expr, $($rest:tt)*) => {
        format!(
            "{}=\"{}\" {}",
            $attr,
            $value,
            concat_attrs!($($rest)*)
        )
    };
}

// è¾…åŠ©å®: æ‹¼æ¥èŠ‚ç‚¹
macro_rules! concat_nodes {
    // ç©º
    () => {
        ""
    };
    
    // ä¸€ä¸ªèŠ‚ç‚¹
    ($node:expr) => {
        $node
    };
    
    // å¤šä¸ªèŠ‚ç‚¹
    ($node:expr, $($rest:expr),*) => {
        format!("{}{}", $node, concat_nodes!($($rest),*))
    };
}

// ä½¿ç”¨HTML DSL
fn use_html_dsl() {
    let document = html! {
        html {
            head {
                title { "æˆ‘çš„ç½‘é¡µ" }
            }
            body [id = "main", class = "content"] {
                h1 { "æ¬¢è¿ä½¿ç”¨Rust HTML DSL" }
                p { "è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨å®åˆ›å»ºçš„HTMLæ–‡æ¡£ã€‚" }
                ul {
                    li { "é¡¹ç›® 1" }
                    li { "é¡¹ç›® 2" }
                    li { "é¡¹ç›® 3" }
                }
            }
        }
    };
    
    println!("{}", document);
}
```

#### 7.1.2 è¿‡ç¨‹å®

è¿‡ç¨‹å®æ˜¯åœ¨ç¼–è¯‘æ—¶è¿è¡Œçš„å‡½æ•°ï¼Œå®ƒä»¬æ“ä½œRustä»£ç çš„æŠ½è±¡è¯­æ³•æ ‘ï¼š

```rust
// è¿‡ç¨‹å®ç¤ºä¾‹
// éœ€è¦åœ¨å•ç‹¬çš„crateä¸­å®šä¹‰
// lib.rs

// å¯ç”¨è¿‡ç¨‹å®åŠŸèƒ½
#![feature(proc_macro)]

extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

// æ´¾ç”Ÿå®: ç”ŸæˆDebugå®ç°
#[proc_macro_derive(SimpleDebug)]
pub fn simple_debug_derive(input: TokenStream) -> TokenStream {
    // è§£æè¾“å…¥æ ‡è®°
    let input = parse_macro_input!(input as DeriveInput);
    
    // æå–ç»“æ„ä½“å
    let name = &input.ident;
    
    // ç”Ÿæˆè¾“å‡ºä»£ç 
    let expanded = quote! {
        // ä¸ºç»“æ„ä½“å®ç°Debug
        impl std::fmt::Debug for #name {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "{} {{ ... }}", stringify!(#name))
            }
        }
    };
    
    // è½¬æ¢å›TokenStream
    expanded.into()
}

// å±æ€§å®: æ·»åŠ æ—¥å¿—
#[proc_macro_attribute]
pub fn log_function(attr: TokenStream, item: TokenStream) -> TokenStream {
    // è§£æå±æ€§å‚æ•°
    let attr_str = attr.to_string();
    let level = if attr_str.is_empty() { "info" } else { &attr_str };
    
    // è§£æå‡½æ•°å®šä¹‰
    let input = parse_macro_input!(item as syn::ItemFn);
    let name = &input.sig.ident;
    let body = &input.block;
    
    // ç”Ÿæˆå¸¦æ—¥å¿—çš„æ–°å‡½æ•°
    let output = quote! {
        fn #name() {
            println!("[{}] è°ƒç”¨å‡½æ•° {}", #level, stringify!(#name));
            #body
        }
    };
    
    // è¿”å›ç”Ÿæˆçš„ä»£ç 
    output.into()
}

// å‡½æ•°å¼å®: SQLæŸ¥è¯¢æ„å»ºå™¨
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    // è§£æSQLæŸ¥è¯¢
    let sql_str = input.to_string();
    
    // ç”ŸæˆæŸ¥è¯¢ä»£ç 
    let output = quote! {
        {
            let query = String::from(#sql_str);
            println!("æ‰§è¡ŒSQL: {}", query);
            query
        }
    };
    
    // è¿”å›ç”Ÿæˆçš„ä»£ç 
    output.into()
}
```

ä½¿ç”¨è¿‡ç¨‹å®ï¼š

```rust
// ä½¿ç”¨æ´¾ç”Ÿå®
use my_macros::SimpleDebug;

#[derive(SimpleDebug)]
struct Person {
    name: String,
    age: u32,
}

// ä½¿ç”¨å±æ€§å®
use my_macros::log_function;

#[log_function]
fn foo() {
    println!("æ‰§è¡Œfoo");
}

#[log_function("debug")]
fn bar() {
    println!("æ‰§è¡Œbar");
}

// ä½¿ç”¨å‡½æ•°å¼å®
use my_macros::sql;

fn database_query() {
    let query = sql!(SELECT * FROM users WHERE age > 18);
    // æ‰§è¡ŒæŸ¥è¯¢...
}

// ä½¿ç”¨è¿‡ç¨‹å®çš„ä¸»å‡½æ•°
fn use_proc_macros() {
    let person = Person {
        name: String::from("å¼ ä¸‰"),
        age: 30,
    };
    
    println!("{:?}", person); // è¾“å‡º: Person { ... }
    
    foo(); // è¾“å‡º: [info] è°ƒç”¨å‡½æ•° foo \n æ‰§è¡Œfoo
    bar(); // è¾“å‡º: [debug] è°ƒç”¨å‡½æ•° bar \n æ‰§è¡Œbar
    
    database_query(); // è¾“å‡º: æ‰§è¡ŒSQL: SELECT * FROM users WHERE age > 18
}
```

#### 7.1.3 å¸¸è§å®æ¨¡å¼ä¸æŠ€å·§

å®è®¾è®¡ä¸­çš„å¸¸è§æ¨¡å¼å’Œæœ€ä½³å®è·µï¼š

```rust
// è¿½è¸ªå®è°ƒç”¨
macro_rules! trace {
    ($msg:expr) => {
        println!("[TRACE] {}", $msg);
    };
    
    ($fmt:expr, $($arg:tt)*) => {
        println!("[TRACE] {}", format!($fmt, $($arg)*));
    };
}

// å¸¦å¯é€‰å‚æ•°çš„å®
macro_rules! config {
    // é»˜è®¤é…ç½®
    () => {
        Config { debug: false, timeout: 30 }
    };
    
    // åªæŒ‡å®šdebug
    (debug = $debug:expr) => {
        Config { debug: $debug, timeout: 30 }
    };
    
    // åªæŒ‡å®štimeout
    (timeout = $timeout:expr) => {
        Config { debug: false, timeout: $timeout }
    };
    
    // ä¸¤è€…éƒ½æŒ‡å®š
    (debug = $debug:expr, timeout = $timeout:expr) => {
        Config { debug: $debug, timeout: $timeout }
    };
    
    // åè½¬é¡ºåºä¹Ÿå¯ä»¥
    (timeout = $timeout:expr, debug = $debug:expr) => {
        config!(debug = $debug, timeout = $timeout)
    };
}

// å†…éƒ¨è§„åˆ™æ¨¡å¼
macro_rules! vec_strs {
    // å…¬å…±å…¥å£
    ($($s:expr),*) => {
        // è°ƒç”¨å†…éƒ¨å®ç°
        vec_strs_internal!($($s),*)
    };
}

// å†…éƒ¨å®ç°ç»†èŠ‚
macro_rules! vec_strs_internal {
    ($($s:expr),*) => {
        {
            let mut v = Vec::new();
            $(
                v.push($s.to_string());
            )*
            v
        }
    };
}

// é¿å…å˜é‡æ•è·
macro_rules! avoid_capture {
    ($e:expr) => {
        {
            // ä½¿ç”¨åµŒå¥—ä½œç”¨åŸŸå’Œå”¯ä¸€å˜é‡å
            let result = {
                let _avoid_capture_unique = 42;
                $e
            };
            result
        }
    };
}

// å®é‡ç”¨
macro_rules! count_exprs {
    () => (0);
    ($head:expr) => (1);
    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ($seq:ident[$idx:expr] = $($recur:tt)*) => {
        // è®¡ç®—é€’å½’è¡¨è¾¾å¼
        {
            // ä½¿ç”¨å¦ä¸€ä¸ªå®è®¡ç®—è¡¨è¾¾å¼çš„é¡¹æ•°
            let exprs = count_exprs!($($recur)*);
            println!("è¡¨è¾¾å¼æ•°é‡: {}", exprs);
            // å®é™…å®ç°...
        }
    };
}

// ä½¿ç”¨å®æ¨¡å¼
fn use_macro_patterns() {
    // è¿½è¸ªå®
    trace!("ç®€å•æ¶ˆæ¯");
    trace!("å€¼: {}", 42);
    
    // å¯é€‰å‚æ•°
    let c1 = config!();
    let c2 = config!(debug = true);
    let c3 = config!(timeout = 60);
    let c4 = config!(debug = true, timeout = 60);
    
    // å†…éƒ¨è§„åˆ™
    let strings = vec_strs!["a", "b", "c"];
    
    // é¿å…æ•è·
    let result = 10;
    let computed = avoid_capture!({ let result = 20; result + 5 });
    println!("è®¡ç®—ç»“æœ: {}, åŸå§‹ç»“æœ: {}", computed, result);
    
    // å®é‡ç”¨
    recurrence!(fib[n] = fib[n-1] + fib[n-2]);
}
```

### 7.2 ç¼–è¯‘æ—¶åå°„

#### 7.2.1 ç¼–è¯‘æ—¶ç±»å‹ä¿¡æ¯

Rustæä¾›äº†åœ¨ç¼–è¯‘æ—¶è®¿é—®å’Œæ“ä½œç±»å‹ä¿¡æ¯çš„æœºåˆ¶ï¼š

```rust
// åŸºæœ¬ç±»å‹å¤§å°å’Œå¯¹é½
fn type_info() {
    use std::mem;
    
    // è·å–ç±»å‹å¤§å°
    println!("i32å¤§å°: {} å­—èŠ‚", mem::size_of::<i32>());
    println!("Stringå¤§å°: {} å­—èŠ‚", mem::size_of::<String>());
    println!("Vec<i32>å¤§å°: {} å­—èŠ‚", mem::size_of::<Vec<i32>>());
    
    // è·å–ç±»å‹å¯¹é½
    println!("i32å¯¹é½: {} å­—èŠ‚", mem::align_of::<i32>());
    println!("Stringå¯¹é½: {} å­—èŠ‚", mem::align_of::<String>());
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦drop
    println!("i32éœ€è¦Drop: {}", mem::needs_drop::<i32>());
    println!("Stringéœ€è¦Drop: {}", mem::needs_drop::<String>());
    
    // ç©ºç±»å‹å¤§å°
    println!("()å¤§å°: {} å­—èŠ‚", mem::size_of::<()>());
    println!("[u8; 0]å¤§å°: {} å­—èŠ‚", mem::size_of::<[u8; 0]>());
    
    // åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯ZST(é›¶å¤§å°ç±»å‹)
    println!("()æ˜¯ZST: {}", mem::size_of::<()>() == 0);
}

// æ³›å‹ä¸­çš„ç±»å‹ä¿¡æ¯
fn generic_type_info<T>() {
    println!("Tçš„å¤§å°: {} å­—èŠ‚", std::mem::size_of::<T>());
    println!("Tçš„å¯¹é½: {} å­—èŠ‚", std::mem::align_of::<T>());
    println!("Téœ€è¦Drop: {}", std::mem::needs_drop::<T>());
    
    // ç±»å‹åç§°ï¼ˆä»…ä¾›è°ƒè¯•ä½¿ç”¨ï¼‰
    println!("Tæ˜¯ä»€ä¹ˆ: {}", std::any::type_name::<T>());
}

// ä»»æ„ç±»å‹åå°„
use std::any::{Any, TypeId};

fn reflect_type<T: 'static + Any>(value: &T) {
    // è·å–ç±»å‹ID
    let type_id = TypeId::of::<T>();
    
    // ç±»å‹ç›¸ç­‰æ£€æŸ¥
    println!("æ˜¯i32: {}", type_id == TypeId::of::<i32>());
    println!("æ˜¯String: {}", type_id == TypeId::of::<String>());
    
    // ç±»å‹å‘ä¸‹è½¬æ¢
    if let Some(i) = value.downcast_ref::<i32>() {
        println!("å€¼æ˜¯i32: {}", i);
    } else if let Some(s) = value.downcast_ref::<String>() {
        println!("å€¼æ˜¯String: {}", s);
    } else {
        println!("å€¼æ˜¯å…¶ä»–ç±»å‹");
    }
}

// ä½¿ç”¨ç±»å‹åå°„
fn use_reflection() {
    // åŸºæœ¬ç±»å‹ä¿¡æ¯
    type_info();
    
    // æ³›å‹ç±»å‹ä¿¡æ¯
    generic_type_info::<i32>();
    generic_type_info::<String>();
    generic_type_info::<[u8; 16]>();
    
    // è¿è¡Œæ—¶ç±»å‹åå°„
    let num = 42;
    let text = "Hello".to_string();
    
    reflect_type(&num);
    reflect_type(&text);
    
    // Anyç‰¹å¾å¯¹è±¡
    let values: Vec<Box<dyn Any>> = vec![
        Box::new(42),
        Box::new("hello".to_string()),
        Box::new(3.14),
    ];
    
    for value in values {
        if let Ok(i) = value.downcast::<i32>() {
            println!("æ•´æ•°: {}", *i);
        } else if let Ok(s) = value.downcast::<String>() {
            println!("å­—ç¬¦ä¸²: {}", *s);
        } else if let Ok(f) = value.downcast::<f64>() {
            println!("æµ®ç‚¹æ•°: {}", *f);
        } else {
            println!("æœªçŸ¥ç±»å‹");
        }
    }
}
```

#### 7.2.2 ç¼–è¯‘æ—¶ä»£ç ç”Ÿæˆ

ä½¿ç”¨å®å’Œæ³›å‹ç”Ÿæˆä»£ç ï¼š

```rust
// æšä¸¾è½¬æ•´æ•°
macro_rules! enum_to_int {
    (enum $name:ident { $($variant:ident = $value:expr),* $(,)? }) => {
        #[derive(Debug, PartialEq, Eq)]
        enum $name {
            $($variant = $value),*
        }
        
        impl $name {
            fn to_int(&self) -> i32 {
                *self as i32
            }
            
            fn from_int(value: i32) -> Option<Self> {
                match value {
                    $($value => Some(Self::$variant),)*
                    _ => None,
                }
            }
        }
    };
}

// è‡ªåŠ¨æ´¾ç”ŸToString
macro_rules! derive_to_string {
    (for $($t:ty),* $(,)?) => {
        $(
            impl ToString for $t {
                fn to_string(&self) -> String {
                    format!("{:?}", self)
                }
            }
        )*
    };
}

// è¡¨ç±»å‹ç”Ÿæˆå™¨
macro_rules! create_struct {
    (struct $name:ident { $($field:ident: $type:ty),* $(,)? }) => {
        #[derive(Debug, Default)]
        struct $name {
            $($field: $type),*
        }
        
        impl $name {
            fn new($($field: $type),*) -> Self {
                Self {
                    $($field),*
                }
            }
            
            $(
                fn $field(&self) -> &$type {
                    &self.$field
                }
            )*
        }
    };
}

// ä½¿ç”¨ä»£ç ç”Ÿæˆ
fn use_code_generation() {
    // ç”Ÿæˆæšä¸¾ä¸è½¬æ¢æ–¹æ³•
    enum_to_int! {
        enum Direction {
            North = 0,
            East = 90,
            South = 180,
            West = 270,
        }
    }
    
    let dir = Direction::East;
    println!("æ–¹å‘: {:?}, è§’åº¦: {}", dir, dir.to_int());
    println!("ä»æ•´æ•°: {:?}", Direction::from_int(180));
    
    // æ´¾ç”ŸToString
    derive_to_string!(for i32, f64, bool);
    let num: i32 = 42;
    println!("toString: {}", num.to_string());
    
    // ç”Ÿæˆç»“æ„ä½“
    create_struct! {
        struct User {
            id: u64,
            name: String,
            email: String,
        }
    }
    
    let user = User::new(1, "å¼ ä¸‰".to_string(), "zhangsan@example.com".to_string());
    println!("ç”¨æˆ·: {:?}", user);
    println!("åç§°: {}", user.name());
}
```

#### 7.2.3 ç±»å‹çº§ç¼–ç¨‹

åˆ©ç”¨Rustçš„ç±»å‹ç³»ç»Ÿè¿›è¡Œç¼–è¯‘æ—¶è®¡ç®—ï¼š

```rust
// ç±»å‹çº§æ•°å­—
struct Zero;
struct Succ<T>(std::marker::PhantomData<T>);

// ç±»å‹çº§åŠ æ³•
trait Add<B> {
    type Output;
}

impl Add<Zero> for Zero {
    type Output = Zero;
}

impl<T> Add<Zero> for Succ<T> {
    type Output = Succ<T>;
}

impl<T> Add<Succ<T>> for Zero {
    type Output = Succ<T>;
}

impl<A, B> Add<Succ<B>> for Succ<A>
where
    A: Add<B>,
{
    type Output = Succ<Succ<A::Output>>;
}

// å°†ç±»å‹çº§æ•°å­—è½¬æ¢ä¸ºè¿è¡Œæ—¶
trait ToValue {
    fn to_value() -> usize;
}

impl ToValue for Zero {
    fn to_value() -> usize {
        0
    }
}

impl<T: ToValue> ToValue for Succ<T> {
    fn to_value() -> usize {
        1 + T::to_value()
    }
}

// ç±»å‹çº§åˆ—è¡¨
struct Nil;
struct Cons<H, T>(std::marker::PhantomData<(H, T)>);

// åˆ—è¡¨é•¿åº¦
trait Length {
    type Output;
}

impl Length for Nil {
    type Output = Zero;
}

impl<H, T: Length> Length for Cons<H, T> {
    type Output = Succ<T::Output>;
}

// ç±»å‹çŠ¶æ€æ¨¡å¼
struct Open;
struct Closed;

struct File<S> {
    name: String,
    _state: std::marker::PhantomData<S>,
}

impl File<Closed> {
    fn new(name: &str) -> Self {
        File {
            name: name.to_string(),
            _state: std::marker::PhantomData,
        }
    }
    
    fn open(self) -> File<Open> {
        println!("æ‰“å¼€æ–‡ä»¶: {}", self.name);
        File {
            name: self.name,
            _state: std::marker::PhantomData,
        }
    }
}

impl File<Open> {
    fn read(&self) -> String {
        format!("è¯»å–æ–‡ä»¶ {} çš„å†…å®¹", self.name)
    }
    
    fn close(self) -> File<Closed> {
        println!("å…³é—­æ–‡ä»¶: {}", self.name);
        File {
            name: self.name,
            _state: std::marker::PhantomData,
        }
    }
}

// ä½¿ç”¨ç±»å‹çº§ç¼–ç¨‹
fn use_type_level_programming() {
    // ç±»å‹çº§æ•°å€¼è®¡ç®—
    type One = Succ<Zero>;
    type Two = Succ<One>;
    type Three = Succ<Two>;
    
    type Sum = <Two as Add<One>>::Output;
    
    println!("2 + 1 = {}", Sum::to_value());
    
    // ç±»å‹çŠ¶æ€
    let file = File::<Closed>::new("example.txt");
    // file.read(); // ç¼–è¯‘é”™è¯¯ï¼šClosedçŠ¶æ€æ²¡æœ‰readæ–¹æ³•
    
    let file = file.open();
    let content = file.read();
    println!("å†…å®¹: {}", content);
    
    let file = file.close();
    // file.read(); // ç¼–è¯‘é”™è¯¯ï¼šå†æ¬¡å˜ä¸ºClosedçŠ¶æ€
}
```

### 7.3 æ„å»ºæ—¶é…ç½®

#### 7.3.1 æ¡ä»¶ç¼–è¯‘

ä½¿ç”¨æ¡ä»¶ç¼–è¯‘å±æ€§å®šåˆ¶ä»£ç è¡Œä¸ºï¼š

```rust
// åŸºæœ¬æ¡ä»¶ç¼–è¯‘
fn conditional_compilation() {
    // æ ¹æ®æ“ä½œç³»ç»Ÿç¼–è¯‘ä¸åŒä»£ç 
    #[cfg(target_os = "windows")]
    fn platform_specific() {
        println!("Windowsç‰¹å®šä»£ç ");
    }
    
    #[cfg(target_os = "linux")]
    fn platform_specific() {
        println!("Linuxç‰¹å®šä»£ç ");
    }
    
    #[cfg(target_os = "macos")]
    fn platform_specific() {
        println!("macOSç‰¹å®šä»£ç ");
    }
    
    // è°ƒç”¨ç‰¹å®šå¹³å°å‡½æ•°
    platform_specific();
    
    // å†…è”æ¡ä»¶ä»£ç å—
    #[cfg(debug_assertions)]
    {
        println!("è°ƒè¯•æ¨¡å¼ä»£ç ");
        println!("è¿™é‡Œæœ‰æ›´å¤šè°ƒè¯•è¾“å‡º");
    }
    
    // ç‰¹å®šåŠŸèƒ½ç¼–è¯‘
    #[cfg(feature = "advanced")]
    fn advanced_feature() {
        println!("é«˜çº§ç‰¹æ€§å·²å¯ç”¨");
    }
    
    #[cfg(not(feature = "advanced"))]
    fn advanced_feature() {
        println!("é«˜çº§ç‰¹æ€§æœªå¯ç”¨");
    }
    
    advanced_feature();
}

// å¤æ‚æ¡ä»¶ç¼–è¯‘
fn complex_conditions() {
    // å¤šæ¡ä»¶ - ä¸æ“ä½œ
    #[cfg(all(target_arch = "x86_64", target_os = "linux"))]
    println!("ä»£ç ä»…åœ¨Linux x86_64æ¶æ„ä¸Šç¼–è¯‘");
    
    // å¤šæ¡ä»¶ - æˆ–æ“ä½œ
    #[cfg(any(target_os = "windows", target_os = "macos"))]
    println!("ä»£ç åœ¨Windowsæˆ–macOSä¸Šç¼–è¯‘");
    
    // éæ¡ä»¶
    #[cfg(not(target_feature = "avx2"))]
    println!("ä¸ä½¿ç”¨AVX2æŒ‡ä»¤é›†æ—¶ç¼–è¯‘");
    
    // å¤æ‚åµŒå¥—æ¡ä»¶
    #[cfg(all(feature = "parallel", any(target_arch = "x86_64", target_arch = "aarch64")))]
    println!("å¹¶è¡Œç‰¹æ€§åœ¨x86_64æˆ–aarch64æ¶æ„ä¸Šå¯ç”¨æ—¶ç¼–è¯‘");
}

// æ¡ä»¶å¯¼å…¥æ¨¡å—
mod desktop {
    pub fn run() {
        println!("æ¡Œé¢ç‰ˆåº”ç”¨");
    }
}

mod mobile {
    pub fn run() {
        println!("ç§»åŠ¨ç‰ˆåº”ç”¨");
    }
}

#[cfg(any(target_os = "windows", target_os = "macos", target_os = "linux"))]
use self::desktop as platform;

#[cfg(any(target_os = "android", target_os = "ios"))]
use self::mobile as platform;

// ä½¿ç”¨æ¡ä»¶æ¨¡å—
fn use_conditional_module() {
    platform::run();
}
```

åœ¨Cargo.tomlä¸­é…ç½®ç‰¹æ€§ï¼š

```toml
[package]
name = "my_package"
version = "0.1.0"
edition = "2021"

[features]
default = ["std"] # é»˜è®¤å¯ç”¨çš„ç‰¹æ€§
std = [] # æ ‡å‡†åº“æ”¯æŒ
parallel = [] # å¹¶è¡Œè®¡ç®—æ”¯æŒ
advanced = ["parallel"] # é«˜çº§ç‰¹æ€§ä¾èµ–å¹¶è¡Œç‰¹æ€§
logging = [] # æ—¥å¿—è®°å½•ç‰¹æ€§

[dependencies]
serde = { version = "1.0", optional = true } # å¯é€‰ä¾èµ–
rand = { version = "0.8", optional = true } # å¯é€‰ä¾èµ–

[target.'cfg(target_os = "linux")'.dependencies]
libc = "0.2" # ä»…Linuxå¹³å°ä¾èµ–
```

#### 7.3.2 è‡ªå®šä¹‰æ„å»ºè„šæœ¬

é€šè¿‡`build.rs`é…ç½®æ„å»ºè¿‡ç¨‹ï¼š

```rust
// build.rs
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // è¯»å–ç¯å¢ƒå˜é‡
    let profile = env::var("PROFILE").unwrap();
    println!("æ„å»ºé…ç½®: {}", profile);
    
    // è·å–è¾“å‡ºç›®å½•
    let out_dir = env::var("OUT_DIR").unwrap();
    
    // ç”Ÿæˆé…ç½®æ–‡ä»¶
    let config = format!(
        "pub const VERSION: &str = \"{}\";\n\
         pub const BUILD_TYPE: &str = \"{}\";\n\
         pub const BUILD_TIME: &str = \"{}\";\n",
        env!("CARGO_PKG_VERSION"),
        profile,
        chrono::Local::now().to_rfc3339(),
    );
    
    // å†™å…¥ç”Ÿæˆçš„Rustæ–‡ä»¶
    let dest_path = Path::new(&out_dir).join("generated_config.rs");
    fs::write(&dest_path, config).unwrap();
    
    // æ·»åŠ é“¾æ¥æ ‡å¿—
    println!("cargo:rustc-link-search=native=/usr/local/lib");
    println!("cargo:rustc-link-lib=mylib");
    
    // æ¡ä»¶ç¼–è¯‘æ ‡å¿—
    if cfg!(target_os = "windows") {
        println!("cargo:rustc-cfg=windows_platform");
    }
    
    // é‡æ–°è¿è¡Œçš„æ¡ä»¶
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=config_template.txt");
    
    // ç¼–è¯‘å¤–éƒ¨Cä»£ç 
    cc::Build::new()
        .file("native/helper.c")
        .compile("helper");
}
```

åœ¨ä»£ç ä¸­ä½¿ç”¨ç”Ÿæˆçš„æ–‡ä»¶ï¼š

```rust
// åŒ…å«ç”Ÿæˆçš„é…ç½®
include!(concat!(env!("OUT_DIR"), "/generated_config.rs"));

// ä½¿ç”¨ç”Ÿæˆçš„å¸¸é‡
fn use_generated_config() {
    println!("åº”ç”¨ç‰ˆæœ¬: {}", VERSION);
    println!("æ„å»ºç±»å‹: {}", BUILD_TYPE);
    println!("æ„å»ºæ—¶é—´: {}", BUILD_TIME);
    
    // æ ¹æ®è‡ªå®šä¹‰é…ç½®æ ‡å¿—ç¼–è¯‘ä»£ç 
    #[cfg(windows_platform)]
    println!("Windowså¹³å°ç‰¹å®šä»£ç å·²ç¼–è¯‘");
}

// ä½¿ç”¨å¤–éƒ¨Cåº“
extern "C" {
    fn helper_function(x: i32) -> i32;
}

fn use_native_code() {
    unsafe {
        let result = helper_function(42);
        println!("æœ¬åœ°ä»£ç ç»“æœ: {}", result);
    }
}
```

## 8. é«˜çº§ç‰¹æ€§

### 8.1 Unsafe Rust

#### 8.1.1 UnsafeåŸºç¡€

Unsafe Rustå…è®¸è¿›è¡Œåº•å±‚æ“ä½œï¼Œä½†éœ€è¦ç¨‹åºå‘˜ç¡®ä¿å®‰å…¨ï¼š

```rust
// åŸºæœ¬unsafeå—
fn basic_unsafe() {
    // åˆ›å»ºå¯å˜åŸå§‹æŒ‡é’ˆ
    let mut num = 5;
    let r1 = &mut num as *mut i32;
    
    // åœ¨unsafeå—ä¸­è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
    unsafe {
        *r1 += 1;
        println!("r1: {}", *r1);
    }
    
    // åˆ›å»ºä¸å¯å˜åŸå§‹æŒ‡é’ˆ
    let num = 5;
    let r2 = &num as *const i32;
    
    unsafe {
        println!("r2: {}", *r2);
    }
    
    // æŒ‡é’ˆç®—æœ¯
    unsafe {
        let ptr = r2.offset(0);
        println!("åç§»å: {}", *ptr);
    }
}

// unsafeå‡½æ•°
unsafe fn dangerous() {
    // åŒ…å«ä¸å®‰å…¨ä»£ç 
    println!("æ‰§è¡Œä¸å®‰å…¨æ“ä½œ");
}

// è°ƒç”¨unsafeå‡½æ•°
fn call_unsafe() {
    // å¿…é¡»åœ¨unsafeå—ä¸­è°ƒç”¨
    unsafe {
        dangerous();
    }
}

// å¤–éƒ¨å‡½æ•°æ¥å£
extern "C" {
    fn abs(input: i32) -> i32;
}

// ä½¿ç”¨å¤–éƒ¨å‡½æ•°
fn use_extern_function() {
    unsafe {
        println!("-3çš„ç»å¯¹å€¼: {}", abs(-3));
    }
}

// å¯¼å‡ºç»™Cè°ƒç”¨çš„å‡½æ•°
#[no_mangle]
pub extern "C" fn rust_function(x: i32) -> i32 {
    println!("ä»Cè°ƒç”¨Rustå‡½æ•°");
    x * 2
}
```

ä¿®æ”¹é™æ€å˜é‡ï¼š

```rust
// å¯å˜é™æ€å˜é‡
static mut COUNTER: u32 = 0;

fn use_static() {
    // è¯»å–é™æ€å˜é‡
    println!("è®¡æ•°å™¨åˆå§‹å€¼: {}", unsafe { COUNTER });
    
    // ä¿®æ”¹é™æ€å˜é‡
    unsafe {
        COUNTER += 1;
        println!("è®¡æ•°å™¨æ–°å€¼: {}", COUNTER);
    }
}

// å®ç°ä¸å®‰å…¨ç‰¹å¾
unsafe trait Dangerous {
    fn risky(&self);
}

unsafe impl Dangerous for i32 {
    fn risky(&self) {
        println!("å¯¹ {} è¿›è¡Œå±é™©æ“ä½œ", self);
    }
}

// è°ƒç”¨ä¸å®‰å…¨ç‰¹å¾æ–¹æ³•
fn use_unsafe_trait() {
    let num = 42;
    num.risky();
}
```

#### 8.1.2 å†…å­˜ç®¡ç†ä¸åŸå§‹æŒ‡é’ˆ

ä½¿ç”¨ä¸å®‰å…¨ä»£ç ç®¡ç†å†…å­˜ï¼š

```rust
// æ‰‹åŠ¨å†…å­˜åˆ†é…
fn manual_memory() {
    use std::alloc::{alloc, dealloc, Layout};
    
    // åˆ†é…å†…å­˜
    let layout = Layout::array::<i32>(5).unwrap();
    let ptr = unsafe { alloc(layout) as *mut i32 };
    
    if ptr.is_null() {
        panic!("å†…å­˜åˆ†é…å¤±è´¥");
    }
    
    // åˆå§‹åŒ–å†…å­˜
    unsafe {
        for i in 0..5 {
            *ptr.add(i) = i as i32;
        }
        
        // è¯»å–å¹¶æ‰“å°å€¼
        for i in 0..5 {
            println!("{}", *ptr.add(i));
        }
        
        // é‡Šæ”¾å†…å­˜
        dealloc(ptr as *mut u8, layout);
    }
}

// å†…å­˜è½¬æ¢
fn transmutation() {
    use std::mem::transmute;
    
    // i32åˆ°[u8; 4]
    let num: i32 = 0x01020304;
    let bytes: [u8; 4] = unsafe { transmute(num) };
    println!("å­—èŠ‚: {:?}", bytes);
    
    // å‡½æ•°æŒ‡é’ˆåˆ°usize
    fn foo() { println!("è°ƒç”¨foo"); }
    let fn_ptr: fn() = foo;
    let addr: usize = unsafe { transmute(fn_ptr) };
    println!("å‡½æ•°åœ°å€: 0x{:x}", addr);
    
    // æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ³•
    let num: i32 = 0x01020304;
    let bytes = num.to_ne_bytes();
    println!("å­—èŠ‚(å®‰å…¨): {:?}", bytes);
}

// åŸºäºè£¸æŒ‡é’ˆçš„æ•°æ®ç»“æ„
struct RawVec<T> {
    ptr: *mut T,
    cap: usize,
    len: usize,
}

impl<T> RawVec<T> {
    fn new() -> Self {
        RawVec {
            ptr: std::ptr::null_mut(),
            cap: 0,
            len: 0,
        }
    }
    
    fn push(&mut self, value: T) {
        use std::alloc::{alloc, realloc, Layout};
        use std::mem;
        
        if self.len == self.cap {
            // éœ€è¦åˆ†é…æˆ–æ‰©å®¹
            let new_cap = if self.cap == 0 { 1 } else { self.cap * 2 };
            let layout = Layout::array::<T>(new_cap).unwrap();
            
            unsafe {
                if self.cap == 0 {
                    // é¦–æ¬¡åˆ†é…
                    self.ptr = alloc(layout) as *mut T;
                    if self.ptr.is_null() {
                        panic!("å†…å­˜åˆ†é…å¤±è´¥");
                    }
                } else {
                    // æ‰©å®¹
                    let old_layout = Layout::array::<T>(self.cap).unwrap();
                    let old_ptr = self.ptr as *mut u8;
                    let new_ptr = realloc(old_ptr, old_layout, layout.size());
                    if new_ptr.is_null() {
                        panic!("å†…å­˜é‡æ–°åˆ†é…å¤±è´¥");
                    }
                    self.ptr = new_ptr as *mut T;
                }
            }
            
            self.cap = new_cap;
        }
        
        // æ·»åŠ æ–°å…ƒç´ 
        unsafe {
            std::ptr::write(self.ptr.add(self.len), value);
        }
        self.len += 1;
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        if index >= self.len {
            None
        } else {
            unsafe {
                Some(&*self.ptr.add(index))
            }
        }
    }
}

impl<T> Drop for RawVec<T> {
    fn drop(&mut self) {
        use std::alloc::{dealloc, Layout};
        
        if self.cap > 0 {
            // é¦–å…ˆåˆ é™¤æ‰€æœ‰å…ƒç´ 
            unsafe {
                for i in 0..self.len {
                    std::ptr::drop_in_place(self.ptr.add(i));
                }
            }
            
            // é‡Šæ”¾å†…å­˜
            unsafe {
                let layout = Layout::array::<T>(self.cap).unwrap();
                dealloc(self.ptr as *mut u8, layout);
            }
        }
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰å‘é‡
fn use_raw_vec() {
    let mut v = RawVec::<String>::new();
    v.push("Hello".to_string());
    v.push("World".to_string());
    
    if let Some(s) = v.get(0) {
        println!("ç¬¬ä¸€ä¸ª: {}", s);
    }
    if let Some(s) = v.get(1) {
        println!("ç¬¬äºŒä¸ª: {}", s);
    }
}
```

#### 8.1.3 å®‰å…¨æŠ½è±¡æ„å»º

ä½¿ç”¨Unsafeä»£ç æ„å»ºå®‰å…¨çš„æŠ½è±¡ï¼š

```rust
// å®ç°Splitç›¸äº’å€Ÿç”¨
struct Split<'a, T: 'a> {
    slice: &'a mut [T],
    position: usize,
}

impl<'a, T> Split<'a, T> {
    fn new(slice: &'a mut [T], position: usize) -> Self {
        assert!(position <= slice.len());
        Split { slice, position }
    }
    
    // å®‰å…¨åœ°è·å–ä¸¤ä¸ªå¯å˜å¼•ç”¨
    fn get_parts(&mut self) -> (&mut [T], &mut [T]) {
        // ä½¿ç”¨unsafeåˆ‡åˆ†ï¼Œä½†ä¿è¯å®‰å…¨
        let slice = std::mem::replace(&mut self.slice, &mut []);
        let (left, right) = slice.split_at_mut(self.position);
        (left, right)
    }
}

// ä½¿ç”¨Split
fn use_split() {
    let mut data = [1, 2, 3, 4, 5];
    let mut split = Split::new(&mut data, 2);
    
    {
        let (left, right) = split.get_parts();
        println!("å·¦ä¾§: {:?}", left);
        println!("å³ä¾§: {:?}", right);
        
        // ä¿®æ”¹ä¸¤éƒ¨åˆ†
        left[0] = 10;
        right[0] = 30;
    }
    
    println!("ä¿®æ”¹å: {:?}", data);
}

// å†…éƒ¨å¯å˜æ€§è®¾è®¡
use std::cell::UnsafeCell;

pub struct OnceCell<T> {
    inner: UnsafeCell<Option<T>>,
}

// å¿…é¡»æ‰‹åŠ¨å®ç°çº¿ç¨‹å®‰å…¨
unsafe impl<T: Sync> Sync for OnceCell<T> {}

impl<T> OnceCell<T> {
    pub fn new() -> Self {
        OnceCell {
            inner: UnsafeCell::new(None),
        }
    }
    
    pub fn get(&self) -> Option<&T> {
        // å®‰å…¨è¯»å–å†…éƒ¨å€¼
        unsafe { &*self.inner.get() }.as_ref()
    }
    
    pub fn set(&self, value: T) -> Result<(), T> {
        // è®¾ç½®å€¼ï¼ˆå¦‚æœå°šæœªè®¾ç½®ï¼‰
        let slot = unsafe { &mut *self.inner.get() };
        if slot.is_some() {
            return Err(value);
        }
        *slot = Some(value);
        Ok(())
    }
}

// ä½¿ç”¨OnceCell
fn use_once_cell() {
    let cell = OnceCell::new();
    
    assert!(cell.get().is_none());
    
    assert!(cell.set(42).is_ok());
    assert_eq!(cell.get(), Some(&42));
    
    assert!(cell.set(27).is_err());
    assert_eq!(cell.get(), Some(&42));
}
```

### 8.2 é«˜çº§ç‰¹å¾

#### 8.2.1 å…³è”ç±»å‹ä¸ç±»å‹æ—

å…³è”ç±»å‹æä¾›äº†åœ¨ç‰¹å¾å®šä¹‰ä¸­ä½¿ç”¨å ä½ç¬¦ç±»å‹çš„èƒ½åŠ›ï¼š

```rust
// å®šä¹‰å¸¦å…³è”ç±»å‹çš„ç‰¹å¾
trait Iterator {
    type Item; // å…³è”ç±»å‹
    
    fn next(&mut self) -> Option<Self::Item>;
}

// å®ç°ç‰¹å¾
struct Counter {
    count: usize,
    max: usize,
}

impl Iterator for Counter {
    type Item = usize; // æŒ‡å®šå…³è”ç±»å‹
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            let result = Some(self.count);
            self.count += 1;
            result
        } else {
            None
        }
    }
}

// ä½¿ç”¨å…³è”ç±»å‹
fn use_iterator() {
    let mut counter = Counter { count: 0, max: 5 };
    
    while let Some(value) = counter.next() {
        println!("è®¡æ•°: {}", value);
    }
}

// å…³è”ç±»å‹ä¸çº¦æŸ
trait Container {
    type Item: Display;
    
    fn contains(&self, item: &Self::Item) -> bool;
    fn first(&self) -> Option<&Self::Item>;
    fn print_all(&self);
}

// ä½¿ç”¨å…³è”ç±»å‹çš„ä¼˜åŠ¿
trait Graph {
    type Node;
    type Edge;
    
    fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool;
    fn edges(&self, from: &Self::Node) -> Vec<&Self::Edge>;
}

// å…·ä½“å›¾å®ç°
struct MyGraph {
    // å›¾ç»“æ„
}

struct MyNode {
    id: usize,
}

struct MyEdge {
    from: usize,
    to: usize,
    weight: f64,
}

impl Graph for MyGraph {
    type Node = MyNode;
    type Edge = MyEdge;
    
    fn has_edge(&self, from: &Self::Node, to: &Self::Node) -> bool {
        // å®ç°...
        true
    }
    
    fn edges(&self, from: &Self::Node) -> Vec<&Self::Edge> {
        // å®ç°...
        vec![]
    }
}

// å…³è”ç±»å‹çš„å…¶ä»–ç”¨ä¾‹
trait Builder {
    type Output;
    
    fn build(self) -> Self::Output;
}

struct StringBuilder {
    parts: Vec<String>,
}

impl Builder for StringBuilder {
    type Output = String;
    
    fn build(self) -> String {
        self.parts.join("")
    }
}
```

ç±»å‹æ—å’Œç›¸å…³æ¨¡å¼ï¼š

```rust
// ç±»å‹æ—
trait ShapeFamily {
    type Point;
    type Line;
    type Surface;
}

struct EuclideanGeometry;

impl ShapeFamily for EuclideanGeometry {
    type Point = EuclideanPoint;
    type Line = EuclideanLine;
    type Surface = EuclideanSurface;
}

struct EuclideanPoint { x: f64, y: f64, z: f64 }
struct EuclideanLine { start: EuclideanPoint, end: EuclideanPoint }
struct EuclideanSurface { /* ... */ }

// å…³è”å¸¸é‡
trait Constants {
    const MAX_VALUE: u32;
    const NAME: &'static str;
}

struct AppConfig;

impl Constants for AppConfig {
    const MAX_VALUE: u32 = 1000;
    const NAME: &'static str = "MyApp";
}

// ä½¿ç”¨å…³è”å¸¸é‡
fn use_constants() {
    println!("æœ€å¤§å€¼: {}", AppConfig::MAX_VALUE);
    println!("åç§°: {}", AppConfig::NAME);
}
```

#### 8.2.2 é«˜çº§ç‰¹å¾è¾¹ç•Œ

å¤æ‚çš„ç‰¹å¾è¾¹ç•Œå…è®¸æ›´ç²¾ç¡®åœ°è¡¨è¾¾ç±»å‹çº¦æŸï¼š

```rust
// å¤šé‡ç‰¹å¾è¾¹ç•Œ
fn display_and_clone<T: Display + Clone>(t: T) {
    let cloned = t.clone();
    println!("æ˜¾ç¤º: {}", cloned);
}

// whereå­å¥
fn complex_bounds<T, U>(t: T, u: U) -> i32
where
    T: Display + Clone + Debug,
    U: Clone + Debug + PartialOrd,
{
    println!("t: {}, u: {:?}", t, u);
    0
}

// å…³è”ç±»å‹çº¦æŸ
trait Sequence {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
}

// çº¦æŸå…³è”ç±»å‹
fn process_sequence<S>(sequence: &mut S)
where
    S: Sequence,
    S::Item: Display,
{
    while let Some(item) = sequence.next() {
        println!("åºåˆ—é¡¹: {}", item);
    }
}

// æ›´å¤æ‚çš„å…³è”ç±»å‹çº¦æŸ
trait Parser {
    type Output;
    
    fn parse(&self, input: &str) -> Result<Self::Output, String>;
}

fn parse_and_display<P>(parser: &P, input: &str)
where
    P: Parser,
    P::Output: Display + Debug,
{
    match parser.parse(input) {
        Ok(output) => {
            println!("è§£ææˆåŠŸ: {}", output);
            println!("è°ƒè¯•è¾“å‡º: {:?}", output);
        }
        Err(e) => println!("è§£æé”™è¯¯: {}", e),
    }
}

// é€šè¿‡ç‰¹å¾è¾¹ç•Œæ‰©å±•å¤–éƒ¨ç±»å‹
struct Point {
    x: f64,
    y: f64,
}

trait Distance {
    fn distance_from_origin(&self) -> f64;
}

impl Distance for Point {
    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// ä½¿ç”¨æ³›å‹ç‰¹å¾è¾¹ç•Œ
fn furthest_from_origin<T: Distance>(items: &[T]) -> Option<&T> {
    items.iter()
        .max_by(|a, b| a.distance_from_origin().partial_cmp(&b.distance_from_origin()).unwrap())
}

// æ¡ä»¶å®ç°
trait Summary {
    fn summarize(&self) -> String;
}

// ä¸ºæ‰€æœ‰Displayç±»å‹å®ç°Summary
impl<T: Display> Summary for T {
    fn summarize(&self) -> String {
        format!("({})", self)
    }
}
```

#### 8.2.3 GATä¸å¤æ‚æ³›å‹

å¹¿ä¹‰å…³è”ç±»å‹ï¼ˆGeneric Associated Types, GATï¼‰å’Œå¤æ‚æ³›å‹æ¨¡å¼ï¼š

```rust
// åŸºæœ¬æ³›å‹å…³è”ç±»å‹
trait Container<'a> {
    type Item;
    type Iter: Iterator<Item = &'a Self::Item>;
    
    fn iter(&'a self) -> Self::Iter;
}

// å®ç°å®¹å™¨
struct VecContainer<T> {
    items: Vec<T>,
}

impl<'a, T> Container<'a> for VecContainer<T> {
    type Item = T;
    type Iter = std::slice::Iter<'a, T>;
    
    fn iter(&'a self) -> Self::Iter {
        self.items.iter()
    }
}

// ä½¿ç”¨å®¹å™¨
fn use_container() {
    let container = VecContainer { items: vec![1, 2, 3, 4] };
    
    for item in container.iter() {
        println!("é¡¹: {}", item);
    }
}

// é«˜çº§ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ
trait AdvancedCollection<T> {
    type ItemRef<'a>: Sized where Self: 'a;
    
    fn get_item<'a>(&'a self, index: usize) -> Option<Self::ItemRef<'a>>;
}

struct MyCollection<T> {
    items: Vec<T>,
}

impl<T> AdvancedCollection<T> for MyCollection<T> {
    type ItemRef<'a> = &'a T where Self: 'a;
    
    fn get_item<'a>(&'a self, index: usize) -> Option<Self::ItemRef<'a>> {
        self.items.get(index)
    }
}

// å¤šæ€è¿­ä»£å™¨
trait StreamingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

// å®ç°æµå¼è¿­ä»£å™¨
struct StrSplitter<'s> {
    remainder: Option<&'s str>,
    delimiter: char,
}

impl<'s> StreamingIterator for StrSplitter<'s> {
    type Item<'a> = &'a str where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        let remainder = self.remainder?;
        
        if let Some(i) = remainder.find(self.delimiter) {
            let (prefix, suffix) = remainder.split_at(i);
            self.remainder = Some(&suffix[1..]);
            Some(prefix)
        } else {
            self.remainder = None;
            Some(remainder)
        }
    }
}

fn streaming_example() {
    let mut splitter = StrSplitter {
        remainder: Some("a,b,c"),
        delimiter: ',',
    };
    
    while let Some(item) = splitter.next() {
        println!("é¡¹: {}", item);
    }
}
```

#### 8.2.4 ç‰¹å¾å¯¹è±¡ä¸åŠ¨æ€åˆ†å‘

ä½¿ç”¨ç‰¹å¾å¯¹è±¡å®ç°è¿è¡Œæ—¶å¤šæ€æ€§ï¼š

```rust
// å®šä¹‰ç‰¹å¾
trait Animal {
    fn make_sound(&self) -> String;
    fn description(&self) -> String {
        format!("ä¸€ç§åŠ¨ç‰©ï¼Œå«å£°ï¼š{}", self.make_sound())
    }
}

// å®ç°å…·ä½“ç±»å‹
struct Dog {
    name: String,
}

impl Animal for Dog {
    fn make_sound(&self) -> String {
        format!("æ±ªæ±ª! æˆ‘æ˜¯ {}", self.name)
    }
    
    fn description(&self) -> String {
        format!("ä¸€åªåå«{}çš„ç‹—", self.name)
    }
}

struct Cat {
    name: String,
}

impl Animal for Cat {
    fn make_sound(&self) -> String {
        format!("å–µå–µ! æˆ‘æ˜¯ {}", self.name)
    }
}

// ä½¿ç”¨åŠ¨æ€åˆ†å‘
fn animal_sounds(animals: Vec<Box<dyn Animal>>) {
    for animal in animals {
        println!("å£°éŸ³: {}", animal.make_sound());
        println!("æè¿°: {}", animal.description());
    }
}

// ä½¿ç”¨ç‰¹å¾å¯¹è±¡
fn use_trait_objects() {
    let animals: Vec<Box<dyn Animal>> = vec![
        Box::new(Dog { name: String::from("å°é»„") }),
        Box::new(Cat { name: String::from("å°èŠ±") }),
    ];
    
    animal_sounds(animals);
}

// åŠ¨æ€åˆ†å‘çš„é™åˆ¶
fn static_vs_dynamic() {
    // é™æ€åˆ†å‘ï¼ˆå•æ€åŒ–ï¼‰
    fn static_dispatch<T: Animal>(animal: T) {
        println!("é™æ€: {}", animal.make_sound());
    }
    
    // åŠ¨æ€åˆ†å‘
    fn dynamic_dispatch(animal: &dyn Animal) {
        println!("åŠ¨æ€: {}", animal.make_sound());
    }
    
    let dog = Dog { name: String::from("é™æ€ç‹—") };
    let cat = Cat { name: String::from("åŠ¨æ€çŒ«") };
    
    static_dispatch(dog);
    dynamic_dispatch(&cat);
}

// ç‰¹å¾å¯¹è±¡çš„é™åˆ¶
trait Example: Sized {
    fn method(&self) -> String;
}

// ä»¥ä¸‹æ— æ³•ä½œä¸ºç‰¹å¾å¯¹è±¡ä½¿ç”¨ï¼ˆéœ€è¦Sizedï¼‰
// fn use_example(e: &dyn Example) { // é”™è¯¯!
//     println!("{}", e.method());
// }

// å¯¹è±¡å®‰å…¨çš„ç‰¹å¾
trait ObjectSafe {
    fn safe_method(&self) -> String;
}

// éå¯¹è±¡å®‰å…¨çš„ç‰¹å¾
trait NotObjectSafe {
    fn unsafe_method(&self) -> Self; // è¿”å›Self
    fn generic_method<T>(&self, value: T); // æ³›å‹æ–¹æ³•
}
```

#### 8.2.5 é›¶æˆæœ¬æŠ½è±¡

Rustæ”¯æŒé›¶æˆæœ¬æŠ½è±¡ï¼Œé«˜çº§æŠ½è±¡åœ¨è¿è¡Œæ—¶æ²¡æœ‰é¢å¤–å¼€é”€ï¼š

```rust
// è¿­ä»£å™¨ç¤ºä¾‹
fn zero_cost_iterators() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // é«˜çº§æŠ½è±¡
    let sum: i32 = numbers.iter()
                         .map(|&x| x * 2)
                         .filter(|&x| x > 5)
                         .sum();
    
    println!("æ€»å’Œ: {}", sum);
    
    // ç­‰ä»·çš„å‘½ä»¤å¼ä»£ç 
    let mut sum2 = 0;
    for &num in &numbers {
        let doubled = num * 2;
        if doubled > 5 {
            sum2 += doubled;
        }
    }
    
    assert_eq!(sum, sum2);
}

// æ³›å‹å®ç°
struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    fn new(value: T) -> Self {
        Wrapper { value }
    }
    
    fn get(&self) -> &T {
        &self.value
    }
}

// å•æ€åŒ–ç¤ºä¾‹
fn monomorphization() {
    let w_i32 = Wrapper::new(42);
    let w_str = Wrapper::new("hello");
    
    println!("i32: {}", w_i32.get());
    println!("str: {}", w_str.get());
    
    // ç¼–è¯‘å™¨ä¸ºæ¯ç§ç±»å‹ç”Ÿæˆç‰¹åŒ–ä»£ç 
}

// å†…è”ä¸å¸¸é‡æŠ˜å 
#[inline]
fn square(x: u32) -> u32 {
    x * x
}

const MAX_SIZE: usize = 1024;

fn optimizations() {
    let x = 5;
    let result = square(x); // å¯èƒ½è¢«å†…è”
    
    let array = [0; MAX_SIZE]; // å¸¸é‡æŠ˜å 
    
    println!("å¹³æ–¹: {}, æ•°ç»„å¤§å°: {}", result, array.len());
}
```

### 8.3 é«˜çº§ç±»å‹ç³»ç»Ÿç‰¹æ€§

#### 8.3.1 å¼‚è´¨é›†åˆä¸ `Any` ç±»å‹

å¤„ç†ä¸åŒç±»å‹çš„å€¼çš„é›†åˆï¼š

```rust
// ä½¿ç”¨Anyç±»å‹
use std::any::Any;

fn log_type<T: Any + std::fmt::Debug>(value: &T) {
    println!("å€¼: {:?}", value);
    println!("ç±»å‹ID: {:?}", std::any::TypeId::of::<T>());
}

// å‘ä¸‹è½¬æ¢Anyå¯¹è±¡
fn downcast_examples() {
    use std::any::Any;
    
    // åˆ›å»ºå„ç§ç±»å‹çš„å€¼
    let values: Vec<Box<dyn Any>> = vec![
        Box::new(42),
        Box::new("hello"),
        Box::new(3.14),
        Box::new(vec![1, 2, 3]),
    ];
    
    for value in values {
        if let Some(i) = value.downcast_ref::<i32>() {
            println!("æ•´æ•°: {}", i);
        } else if let Some(s) = value.downcast_ref::<&str>() {
            println!("å­—ç¬¦ä¸²: {}", s);
        } else if let Some(f) = value.downcast_ref::<f64>() {
            println!("æµ®ç‚¹æ•°: {}", f);
        } else {
            println!("å…¶ä»–ç±»å‹");
        }
    }
}

// ä»»æ„ç±»å‹é›†åˆ
struct AnyCollection {
    items: Vec<Box<dyn Any>>,
}

impl AnyCollection {
    fn new() -> Self {
        AnyCollection { items: Vec::new() }
    }
    
    fn add<T: Any + 'static>(&mut self, item: T) {
        self.items.push(Box::new(item));
    }
    
    fn get<T: Any + 'static>(&self, index: usize) -> Option<&T> {
        if index >= self.items.len() {
            return None;
        }
        
        self.items[index].downcast_ref::<T>()
    }
}

// ä½¿ç”¨å¼‚è´¨é›†åˆ
fn use_any_collection() {
    let mut collection = AnyCollection::new();
    
    collection.add(42);
    collection.add("hello");
    collection.add(3.14);
    
    if let Some(i) = collection.get::<i32>(0) {
        println!("ç¬¬ä¸€é¡¹ (i32): {}", i);
    }
    
    if let Some(s) = collection.get::<&str>(1) {
        println!("ç¬¬äºŒé¡¹ (str): {}", s);
    }
    
    if let Some(f) = collection.get::<f64>(2) {
        println!("ç¬¬ä¸‰é¡¹ (f64): {}", f);
    }
    
    // ç±»å‹ä¸åŒ¹é…
    if let Some(b) = collection.get::<bool>(0) {
        println!("æ‰¾åˆ°å¸ƒå°”å€¼: {}", b);
    } else {
        println!("å¸ƒå°”ç±»å‹è½¬æ¢å¤±è´¥");
    }
}
```

#### 8.3.2 å¹½çµç±»å‹ä¸ç±»å‹çŠ¶æ€

ä½¿ç”¨å¹½çµç±»å‹ï¼ˆPhantomDataï¼‰å’Œç±»å‹çŠ¶æ€æ¨¡å¼å®ç°ç¼–è¯‘æ—¶çº¦æŸï¼š

```rust
// åŸºæœ¬å¹½çµç±»å‹
use std::marker::PhantomData;

struct Identifier<T> {
    id: u64,
    _marker: PhantomData<T>, // å¹½çµç±»å‹å‚æ•°
}

struct User;
struct Product;

impl<T> Identifier<T> {
    fn new(id: u64) -> Self {
        Identifier {
            id,
            _marker: PhantomData,
        }
    }
    
    fn get_id(&self) -> u64 {
        self.id
    }
}

// ä½¿ç”¨å¹½çµç±»å‹
fn use_phantom_data() {
    let user_id = Identifier::<User>::new(1);
    let product_id = Identifier::<Product>::new(2);
    
    println!("ç”¨æˆ·ID: {}", user_id.get_id());
    println!("äº§å“ID: {}", product_id.get_id());
    
    // ä¸åŒç±»å‹çš„IDä¸å¯äº’æ¢
    // let wrong: Identifier<User> = product_id; // ç¼–è¯‘é”™è¯¯
}

// ç±»å‹çŠ¶æ€æ¨¡å¼
struct Empty;
struct Active;
struct Closed;

struct Connection<State> {
    address: String,
    _state: PhantomData<State>,
}

impl Connection<Empty> {
    fn new(address: &str) -> Self {
        Connection {
            address: address.to_string(),
            _state: PhantomData,
        }
    }
    
    fn connect(self) -> Connection<Active> {
        println!("è¿æ¥åˆ° {}", self.address);
        Connection {
            address: self.address,
            _state: PhantomData,
        }
    }
}

impl Connection<Active> {
    fn send_data(&self, data: &str) {
        println!("å‘é€æ•°æ®åˆ° {}: {}", self.address, data);
    }
    
    fn close(self) -> Connection<Closed> {
        println!("å…³é—­è¿æ¥åˆ° {}", self.address);
        Connection {
            address: self.address,
            _state: PhantomData,
        }
    }
}

impl Connection<Closed> {
    fn reconnect(self) -> Connection<Active> {
        println!("é‡æ–°è¿æ¥åˆ° {}", self.address);
        Connection {
            address: self.address,
            _state: PhantomData,
        }
    }
}

// ä½¿ç”¨ç±»å‹çŠ¶æ€
fn use_type_state() {
    let conn = Connection::<Empty>::new("example.com");
    let conn = conn.connect(); // ç°åœ¨æ˜¯ActiveçŠ¶æ€
    
    conn.send_data("hello");
    
    let conn = conn.close(); // ç°åœ¨æ˜¯ClosedçŠ¶æ€
    // conn.send_data("world"); // ç¼–è¯‘é”™è¯¯ï¼šClosedçŠ¶æ€æ²¡æœ‰send_dataæ–¹æ³•
    
    let conn = conn.reconnect(); // å›åˆ°ActiveçŠ¶æ€
    conn.send_data("å†æ¬¡å‘é€");
}
```

#### 8.3.3 ç±»å‹ç³»ç»Ÿçš„é«˜çº§æ¨¡å¼

åˆ©ç”¨ç±»å‹ç³»ç»Ÿè¡¨è¾¾å¤æ‚çº¦æŸå’Œè®¾è®¡æ¨¡å¼ï¼š

```rust
// ä¾èµ–æ³¨å…¥æ¨¡å¼
trait Logger {
    fn log(&self, message: &str);
}

trait Database {
    fn query(&self, query: &str) -> Vec<String>;
}

struct ConsoleLogger;
impl Logger for ConsoleLogger {
    fn log(&self, message: &str) {
        println!("[LOG] {}", message);
    }
}

struct FakeDatabase;
impl Database for FakeDatabase {
    fn query(&self, query: &str) -> Vec<String> {
        println!("æ‰§è¡ŒæŸ¥è¯¢: {}", query);
        vec!["ç»“æœ1".to_string(), "ç»“æœ2".to_string()]
    }
}

// é€šè¿‡æ³›å‹å®ç°ä¾èµ–æ³¨å…¥
struct UserService<L, D> {
    logger: L,
    database: D,
}

impl<L: Logger, D: Database> UserService<L, D> {
    fn new(logger: L, database: D) -> Self {
        UserService { logger, database }
    }
    
    fn find_user(&self, id: u64) -> Vec<String> {
        self.logger.log(&format!("å¯»æ‰¾ç”¨æˆ·ID: {}", id));
        self.database.query(&format!("SELECT * FROM users WHERE id = {}", id))
    }
}

// ä½¿ç”¨ä¾èµ–æ³¨å…¥
fn use_dependency_injection() {
    let logger = ConsoleLogger;
    let database = FakeDatabase;
    
    let service = UserService::new(logger, database);
    let results = service.find_user(42);
    
    println!("æ‰¾åˆ° {} æ¡ç»“æœ", results.len());
}

// ç¼–è¯‘æ—¶éªŒè¯çš„æ„å»ºå™¨æ¨¡å¼
struct Required;
struct Optional;
struct Complete;

struct Builder<Name, Age> {
    name: Option<String>,
    age: Option<u32>,
    _name: PhantomData<Name>,
    _age: PhantomData<Age>,
}

impl Builder<Required, Required> {
    fn build(self) -> Person {
        Person {
            name: self.name.unwrap(),
            age: self.age.unwrap(),
        }
    }
}

impl<Age> Builder<Required, Age> {
    fn age(self, age: u32) -> Builder<Required, Complete> {
        Builder {
            name: self.name,
            age: Some(age),
            _name: PhantomData,
            _age: PhantomData,
        }
    }
}

impl<Name> Builder<Name, Required> {
    fn name(self, name: String) -> Builder<Complete, Required> {
        Builder {
            name: Some(name),
            age: self.age,
            _name: PhantomData,
            _age: PhantomData,
        }
    }
}

impl Builder<Optional, Optional> {
    fn new() -> Self {
        Builder {
            name: None,
            age: None,
            _name: PhantomData,
            _age: PhantomData,
        }
    }
}

struct Person {
    name: String,
    age: u32,
}

// ä½¿ç”¨ç±»å‹å®‰å…¨çš„æ„å»ºå™¨
fn use_type_safe_builder() {
    let person = Builder::<Optional, Optional>::new()
        .name("å¼ ä¸‰".to_string())
        .age(30)
        .build();
    
    println!("äººç‰©: {}, {} å²", person.name, person.age);
    
    // é”™è¯¯ï¼šç¼ºå°‘å¿…éœ€å­—æ®µ
    // let invalid = Builder::<Optional, Optional>::new().build();
}
```

### 8.4 FFIä¸å¤–éƒ¨ä»£ç é›†æˆ

#### 8.4.1 Cè¯­è¨€äº’æ“ä½œ

ä¸Cè¯­è¨€ä»£ç çš„äº’æ“ä½œï¼š

```rust
// ä»Cè°ƒç”¨Rustå‡½æ•°
#[no_mangle]
pub extern "C" fn add_numbers(a: i32, b: i32) -> i32 {
    a + b
}

// è°ƒç”¨Cå‡½æ•°
extern "C" {
    fn c_subtract(a: i32, b: i32) -> i32;
    fn c_multiply(a: i32, b: i32) -> i32;
}

// ä½¿ç”¨Cå‡½æ•°
fn use_c_functions() {
    // å®‰å…¨åœ°åŒ…è£…ä¸å®‰å…¨è°ƒç”¨
    fn subtract(a: i32, b: i32) -> i32 {
        unsafe { c_subtract(a, b) }
    }
    
    fn multiply(a: i32, b: i32) -> i32 {
        unsafe { c_multiply(a, b) }
    }
    
    println!("5 - 3 = {}", subtract(5, 3));
    println!("4 * 6 = {}", multiply(4, 6));
}

// Cç»“æ„ä½“ç»‘å®š
#[repr(C)]
struct Point {
    x: f64,
    y: f64,
}

extern "C" {
    fn calculate_distance(a: *const Point, b: *const Point) -> f64;
}

// ä½¿ç”¨Cç»“æ„ä½“
fn use_c_structs() {
    let p1 = Point { x: 0.0, y: 0.0 };
    let p2 = Point { x: 3.0, y: 4.0 };
    
    let distance = unsafe {
        calculate_distance(&p1, &p2)
    };
    
    println!("ä¸¤ç‚¹è·ç¦»: {}", distance);
}

// å›è°ƒå‡½æ•°
extern "C" {
    fn register_callback(callback: extern "C" fn(i32) -> i32);
}

extern "C" fn rust_callback(value: i32) -> i32 {
    println!("Rustå›è°ƒè¢«è°ƒç”¨ï¼Œå€¼: {}", value);
    value * 2
}

// ä½¿ç”¨å›è°ƒ
fn use_callbacks() {
    unsafe {
        register_callback(rust_callback);
    }
}
```

#### 8.4.2 å†…å­˜ç®¡ç†ä¸ç±»å‹è½¬æ¢

å¤„ç†FFIä¸­çš„å†…å­˜ç®¡ç†å’Œç±»å‹è½¬æ¢ï¼š

```rust
// å­—ç¬¦ä¸²è½¬æ¢
use std::ffi::{CString, CStr};
use std::os::raw::c_char;

extern "C" {
    fn print_string(s: *const c_char);
    fn get_string() -> *const c_char;
}

// Rustå­—ç¬¦ä¸²ä¼ é€’ç»™C
fn pass_string_to_c(s: &str) {
    // åˆ›å»ºä»¥nullç»“å°¾çš„Cå­—ç¬¦ä¸²
    let c_string = CString::new(s).expect("åŒ…å«å†…éƒ¨nullå­—èŠ‚çš„å­—ç¬¦ä¸²");
    
    unsafe {
        print_string(c_string.as_ptr());
    }
}

// ä»Cæ¥æ”¶å­—ç¬¦ä¸²
fn get_string_from_c() -> String {
    unsafe {
        let ptr = get_string();
        
        // æ£€æŸ¥ç©ºæŒ‡é’ˆ
        if ptr.is_null() {
            return String::new();
        }
        
        // è½¬æ¢ä¸ºRustå­—ç¬¦ä¸²
        let c_str = CStr::from_ptr(ptr);
        c_str.to_string_lossy().into_owned()
    }
}

// åŸå§‹å†…å­˜ç®¡ç†
extern "C" {
    fn malloc(size: usize) -> *mut std::ffi::c_void;
    fn free(ptr: *mut std::ffi::c_void);
}

// ä½¿ç”¨Cçš„å†…å­˜åˆ†é…å™¨
fn use_c_memory() {
    unsafe {
        // åˆ†é…å†…å­˜
        let size = std::mem::size_of::<i32>() * 10;
        let ptr = malloc(size) as *mut i32;
        
        if ptr.is_null() {
            panic!("å†…å­˜åˆ†é…å¤±è´¥");
        }
        
        // ä½¿ç”¨å†…å­˜
        for i in 0..10 {
            *ptr.add(i) = i as i32;
        }
        
        // è¯»å–å†…å­˜
        for i in 0..10 {
            println!("å€¼[{}]: {}", i, *ptr.add(i));
        }
        
        // é‡Šæ”¾å†…å­˜
        free(ptr as *mut std::ffi::c_void);
    }
}

// ä½¿ç”¨Rustçš„RAIIæ¨¡å¼åŒ…è£…Cèµ„æº
struct CResource {
    ptr: *mut std::ffi::c_void,
}

impl CResource {
    fn new(size: usize) -> Option<Self> {
        let ptr = unsafe { malloc(size) };
        
        if ptr.is_null() {
            None
        } else {
            Some(CResource { ptr })
        }
    }
    
    fn as_ptr(&self) -> *mut std::ffi::c_void {
        self.ptr
    }
}

impl Drop for CResource {
    fn drop(&mut self) {
        unsafe {
            free(self.ptr);
        }
    }
}

// ä½¿ç”¨å®‰å…¨åŒ…è£…
fn use_c_resource() {
    if let Some(resource) = CResource::new(1024) {
        println!("èµ„æºå·²åˆ†é…: {:?}", resource.as_ptr());
        // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾èµ„æº
    }
}
```

## 9. è¯­è¨€å“²å­¦ä¸è®¾è®¡åŸåˆ™

### 9.1 Rustçš„è®¾è®¡å“²å­¦

#### 9.1.1 å®‰å…¨ã€å¹¶å‘ã€æ§åˆ¶

Rustè¯­è¨€çš„ä¸‰å¤§æ ¸å¿ƒè®¾è®¡æ”¯æŸ±ï¼š

```rust
// å†…å­˜å®‰å…¨ç¤ºä¾‹
fn memory_safety() {
    // æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢å†…å­˜é”™è¯¯
    let s1 = String::from("hello");
    let s2 = s1;
    // println!("{}", s1); // ç¼–è¯‘é”™è¯¯ï¼šs1å·²ç§»åŠ¨
    
    // ç”Ÿå‘½å‘¨æœŸé˜²æ­¢æ‚¬å‚å¼•ç”¨
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() { x } else { y }
    }
    
    // è¾¹ç•Œæ£€æŸ¥é˜²æ­¢ç¼“å†²åŒºæº¢å‡º
    let v = vec![1, 2, 3];
    // let item = v[10]; // è¿è¡Œæ—¶é”™è¯¯ï¼Œä½†ä¸ä¼šå¯¼è‡´å†…å­˜ä¸å®‰å…¨
    
    // æ™ºèƒ½æŒ‡é’ˆè€Œéæ‰‹åŠ¨å†…å­˜ç®¡ç†
    let boxed = Box::new(5);
    println!("è£…ç®±å€¼: {}", boxed);
}

// å¹¶å‘å®‰å…¨ç¤ºä¾‹
fn concurrency_safety() {
    use std::sync::{Arc, Mutex};
    use std::thread;
    
    // å…±äº«æ•°æ®ï¼šArc + Mutex
    let counter = Arc::new(Mutex::new(0));
    
    let mut handles = vec![];
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("ç»“æœ: {}", *counter.lock().unwrap());
    
    // æ²¡æœ‰æ•°æ®ç«äº‰ï¼Œæ²¡æœ‰æ­»é”é£é™©ï¼ˆé™¤éç¨‹åºå‘˜æ•…æ„åˆ›å»ºï¼‰
}

// åº•å±‚æ§åˆ¶ç¤ºä¾‹
fn control_example() {
    // å†…å­˜å¸ƒå±€æ§åˆ¶
    #[repr(C)]
    struct AlignedStruct {
        a: u8,
        b: u32,
        c: u16,
    }
    
    println!("ç»“æ„ä½“å¤§å°: {}", std::mem::size_of::<AlignedStruct>());
    
    // æ— è¿è¡Œæ—¶å¼€é”€çš„é›¶æˆæœ¬æŠ½è±¡
    fn generic_sum<T: std::iter::Sum + Copy>(slice: &[T]) -> T {
        slice.iter().copied().sum()
    }
    
    let nums = [1, 2, 3, 4, 5];
    println!("æ€»å’Œ: {}", generic_sum(&nums));
    
    // ä¸å¼ºåˆ¶åƒåœ¾å›æ”¶
    let mut v = Vec::new();
    for i in 0..1000 {
        v.push(i);
    }
    drop(v); // æ˜¾å¼é‡Šæ”¾èµ„æº
    
    // å†…è”æ±‡ç¼–è®¿é—®
    let result: u64;
    unsafe {
        std::arch::asm!(
            "mov {0}, 42",
            out(reg) result,
        );
    }
    println!("æ±‡ç¼–ç»“æœ: {}", result);
}
```

#### 9.1.2 è¡¨è¾¾æ€§ä¸å·¥ç¨‹æ€§

Rustçš„è¯­è¨€è¡¨è¾¾èƒ½åŠ›ä¸å·¥ç¨‹å®è·µï¼š

```rust
// å‡½æ•°å¼ç¼–ç¨‹ç‰¹æ€§
fn functional_features() {
    // é«˜é˜¶å‡½æ•°
    let numbers = vec![1, 2, 3, 4, 5];
    let sum: i32 = numbers.iter()
                         .filter(|&&n| n % 2 == 0)
                         .map(|&n| n * n)
                         .sum();
    println!("å¶æ•°å¹³æ–¹å’Œ: {}", sum);
    
    // é—­åŒ…è¯­æ³•
    let add = |a, b| a + b;
    println!("2 + 3 = {}", add(2, 3));
    
    // æ¨¡å¼åŒ¹é…
    let opt = Some(42);
    match opt {
        Some(x) if x > 10 => println!("å¤§äº10: {}", x),
        Some(x) => println!("å°äºç­‰äº10: {}", x),
        None => println!("æ²¡æœ‰å€¼"),
    }
    
    // Optionå’ŒResultå•å­
    let result = numbers.first()
                       .map(|&x| x * 2)
                       .filter(|&x| x > 5);
    println!("Optionç»“æœ: {:?}", result);
}

// å·¥ç¨‹å®è·µ
fn engineering_practices() {
    // å¼ºå¤§çš„æ¨¡å—ç³»ç»Ÿ
    mod math {
        pub fn add(a: i32, b: i32) -> i32 { a + b }
        pub fn multiply(a: i32, b: i32) -> i32 { a * b }
    }
    
    println!("5 + 3 = {}", math::add(5, 3));
    
    // æ–‡æ¡£æ³¨é‡Šç”Ÿæˆæ–‡æ¡£
    /// è®¡ç®—æ•´æ•°çš„å¹³æ–¹
    /// 
    /// # Examples
    /// ```
    /// let result = square(4);
    /// assert_eq!(result, 16);
    /// ```
    fn square(x: i32) -> i32 {
        x * x
    }
    
    // é›†æˆçš„æµ‹è¯•æ¡†æ¶
    #[cfg(test)]
    mod tests {
        use super::*;
        
        #[test]
        fn test_square() {
            assert_eq!(square(4), 16);
        }
    }
    
    // å¼ºå¤§çš„é”™è¯¯å¤„ç†
    fn process_data() -> Result<i32, String> {
        let step1 = std::fs::read_to_string("data.txt")
            .map_err(|e| format!("è¯»å–æ–‡ä»¶å¤±è´¥: {}", e))?;
        
        let num = step1.trim().parse::<i32>()
            .map_err(|e| format!("è§£ææ•´æ•°å¤±è´¥: {}", e))?;
        
        Ok(num * 2)
    }
    
    // æˆç†Ÿçš„åŒ…ç®¡ç†ç³»ç»Ÿï¼ˆCargoï¼‰
}
```

#### 9.1.3 æƒè¡¡ä¸å–èˆ

Rustçš„æƒè¡¡è®¾è®¡ä¸å–èˆå†³ç­–ï¼š

```rust
// å®‰å…¨æ€§ä¸çµæ´»æ€§çš„æƒè¡¡
fn safety_vs_flexibility() {
    // å®‰å…¨ä½†å—é™çš„å€Ÿç”¨æ£€æŸ¥å™¨
    let mut s = String::from("hello");
    let r1 = &s;
    // s.push_str(" world"); // é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰ä¸å¯å˜å¼•ç”¨å’Œå¯å˜å¼•ç”¨
    println!("{}", r1);
    
    // æä¾›ä¸å®‰å…¨é€ƒç”Ÿèˆ±
    unsafe {
        // å¯ä»¥åšå±é™©æ“ä½œï¼Œä½†ç¨‹åºå‘˜å¿…é¡»ä¿è¯å®‰å…¨
        let addr = 0x12345usize;
        // let value = *(addr as *const i32); // å±é™©ï¼šå¯èƒ½å¯¼è‡´å´©æºƒ
    }
    
    // æä¾›å®‰å…¨æŠ½è±¡
    struct SafeResource {
        ptr: *mut i32,
    }
    
    impl SafeResource {
        fn new() -> Self {
            SafeResource {
                ptr: Box::into_raw(Box::new(0)),
            }
        }
        
        fn get(&self) -> i32 {
            unsafe { *self.ptr }
        }
        
        fn set(&mut self, value: i32) {
            unsafe { *self.ptr = value; }
        }
    }
    
    impl Drop for SafeResource {
        fn drop(&mut self) {
            unsafe {
                Box::from_raw(self.ptr);
            }
        }
    }
    
    // å®‰å…¨ä½¿ç”¨
    let mut res = SafeResource::new();
    res.set(42);
    println!("èµ„æºå€¼: {}", res.get());
}

// æ§åˆ¶ä¸ä¾¿åˆ©æ€§çš„æƒè¡¡
fn control_vs_convenience() {
    // æ˜¾å¼è€Œééšå¼
    let a = 5;
    let b = 5.0;
    // let c = a + b; // é”™è¯¯ï¼šéœ€è¦æ˜¾å¼ç±»å‹è½¬æ¢
    let c = a as f64 + b;
    println!("æ€»å’Œ: {}", c);
    
    // å¼€é”€æ˜ç¡®ï¼Œä¸ä¼šæœ‰éšè—æˆæœ¬
    let small_vec = vec![1, 2, 3]; // åœ¨å †ä¸Šåˆ†é…
    let array = [1, 2, 3];         // åœ¨æ ˆä¸Šåˆ†é…
    
    println!("å‘é‡å¤§å°: {}", std::mem::size_of_val(&small_vec));
    println!("æ•°ç»„å¤§å°: {}", std::mem::size_of_val(&array));
    
    // ä¸è¿‡åº¦æŠ½è±¡
    struct Wrapper<T> {
        value: T,
    }
    
    impl<T: std::fmt::Display> Wrapper<T> {
        fn new(value: T) -> Self {
            Wrapper { value }
        }
        
        fn display(&self) {
            println!("å€¼: {}", self.value);
        }
    }
    
    let w = Wrapper::new(42);
    w.display();
}

// é™æ€ä¸åŠ¨æ€æƒè¡¡
fn static_vs_dynamic() {
    // å°½å¯èƒ½åœ¨ç¼–è¯‘æ—¶è§£å†³
    let value = 5;
    let option = if value > 10 { Some(value) } else { None };
    
    // éœ€è¦æ—¶æ‰ä½¿ç”¨åŠ¨æ€æ–¹æ³•
    trait Animal { fn speak(&self); }
    
    struct Dog;
    impl Animal for Dog {
        fn speak(&self) { println!("æ±ªæ±ª!"); }
    }
    
    struct Cat;
    impl Animal for Cat {
        fn speak(&self) { println!("å–µå–µ!"); }
    }
    
    // åŠ¨æ€åˆ†å‘
    let animals: Vec<Box<dyn Animal>> = vec![
        Box::new(Dog),
        Box::new(Cat),
    ];
    
    for animal in animals {
        animal.speak();
    }
}
```

### 9.2 ç±»å‹å®‰å…¨ä¸è¡¨è¾¾èƒ½åŠ›

#### 9.2.1 ç±»å‹é©±åŠ¨å¼€å‘

Rustå¼ºå¤§çš„ç±»å‹ç³»ç»Ÿç”¨äºé©±åŠ¨è®¾è®¡ï¼š

```rust
// ä½¿ç”¨ç±»å‹è¡¨è¾¾çº¦æŸ
fn type_constraints() {
    // ä½¿ç”¨ç±»å‹è¡¨è¾¾éç©º
    type NonEmptyString = String;
    
    fn validate_non_empty(s: String) -> Result<NonEmptyString, &'static str> {
        if s.is_empty() {
            Err("å­—ç¬¦ä¸²ä¸èƒ½ä¸ºç©º")
        } else {
            Ok(s)
        }
    }
    
    // ä½¿ç”¨ç±»å‹è¡¨è¾¾éªŒè¯
    struct ValidEmail(String);
    
    impl ValidEmail {
        fn new(email: &str) -> Result<Self, &'static str> {
            // ç®€åŒ–çš„éªŒè¯
            if email.contains('@') {
                Ok(ValidEmail(email.to_string()))
            } else {
                Err("æ— æ•ˆçš„ç”µå­é‚®ä»¶æ ¼å¼")
            }
        }
        
        fn as_str(&self) -> &str {
            &self.0
        }
    }
    
    match ValidEmail::new("user@example.com") {
        Ok(email) => println!("æœ‰æ•ˆé‚®ä»¶: {}", email.as_str()),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}

// ç±»å‹çŠ¶æ€ç¼–ç¨‹
fn typestate_programming() {
    struct DraftPost {
        content: String,
    }
    
    struct PendingReviewPost {
        content: String,
    }
    
    struct PublishedPost {
        content: String,
    }
    
    impl DraftPost {
        fn new() -> Self {
            DraftPost {
                content: String::new(),
            }
        }
        
        fn add_text(&mut self, text: &str) {
            self.content.push_str(text);
        }
        
        fn request_review(self) -> PendingReviewPost {
            PendingReviewPost {
                content: self.content,
            }
        }
    }
    
    impl PendingReviewPost {
        fn approve(self) -> PublishedPost {
            PublishedPost {
                content: self.content,
            }
        }
        
        fn reject(self) -> DraftPost {
            DraftPost {
                content: self.content,
            }
        }
    }
    
    impl PublishedPost {
        fn content(&self) -> &str {
            &self.content
        }
    }
    
    // ä½¿ç”¨ç±»å‹çŠ¶æ€
    let mut post = DraftPost::new();
    post.add_text("è¿™æ˜¯ä¸€ç¯‡åšå®¢æ–‡ç« è‰ç¨¿ã€‚");
    
    let post = post.request_review();
    // post.add_text("æ›´å¤šå†…å®¹"); // é”™è¯¯ï¼šPendingReviewPostæ²¡æœ‰add_textæ–¹æ³•
    
    let post = post.approve();
    println!("å·²å‘å¸ƒå†…å®¹: {}", post.content());
    // let post = post.reject(); // é”™è¯¯ï¼šPublishedPostæ²¡æœ‰rejectæ–¹æ³•
}

// å€ŸåŠ©ç±»å‹æé«˜APIè¡¨è¾¾èƒ½åŠ›
fn expressive_apis() {
    // ä½¿ç”¨æ–°ç±»å‹æ¨¡å¼åŒºåˆ†ç›¸åŒçš„åŸºç¡€ç±»å‹
    struct Meters(f64);
    struct Feet(f64);
    
    impl Meters {
        fn to_feet(&self) -> Feet {
            Feet(self.0 * 3.28084)
        }
    }
    
    impl Feet {
        fn to_meters(&self) -> Meters {
            Meters(self.0 / 3.28084)
        }
    }
    
    // ä¸å†æ··æ·†å•ä½
    let height = Meters(1.85);
    let height_ft = height.to_feet();
    println!("èº«é«˜: {} ç±³ ({} è‹±å°º)", height.0, height_ft.0);
    
    // ä½¿ç”¨æšä¸¾è¡¨è¾¾å¤æ‚åŸŸæ¦‚å¿µ
    enum PaymentMethod {
        CreditCard {
            number: String,
            expiry: String,
            cvv: String,
        },
        BankTransfer {
            account: String,
            sort_code: String,
        },
        Cash,
    }
    
    fn process_payment(amount: f64, method: PaymentMethod) {
        match method {
            PaymentMethod::CreditCard { number, .. } => {
                println!("å¤„ç†ä¿¡ç”¨å¡ä»˜æ¬¾ {} å…ƒï¼Œå¡å·: {}", amount, number);
            }
            PaymentMethod::BankTransfer { account, .. } => {
                println!("å¤„ç†é“¶è¡Œè½¬è´¦ {} å…ƒï¼Œè´¦å·: {}", amount, account);
            }
            PaymentMethod::Cash => {
                println!("å¤„ç†ç°é‡‘æ”¯ä»˜ {} å…ƒ", amount);
            }
        }
    }
    
    process_payment(99.99, PaymentMethod::CreditCard {
        number: "1234-5678-9012-3456".to_string(),
        expiry: "12/24".to_string(),
        cvv: "123".to_string(),
    });
}
```

#### 9.2.2 è¡¨è¾¾å¼è¯­è¨€

Rustä½œä¸ºè¡¨è¾¾å¼è¯­è¨€çš„ç‰¹æ€§ï¼š

```rust
// ä¸€åˆ‡çš†è¡¨è¾¾å¼
fn expressions_everywhere() {
    // å—è¡¨è¾¾å¼
    let x = {
        let a = 1;
        let b = 2;
        a + b  // æ³¨æ„æ²¡æœ‰åˆ†å·ï¼Œä½œä¸ºå—çš„è¿”å›å€¼
    };
    println!("å—è¡¨è¾¾å¼å€¼: {}", x);
    
    // ifè¡¨è¾¾å¼
    let condition = true;
    let value = if condition { 5 } else { 10 };
    println!("ifè¡¨è¾¾å¼å€¼: {}", value);
    
    // matchè¡¨è¾¾å¼
    let opt = Some(42);
    let value = match opt {
        Some(n) => n,
        None => 0,
    };
    println!("matchè¡¨è¾¾å¼å€¼: {}", value);
    
    // å¾ªç¯è¡¨è¾¾å¼
    let result = loop {
        break 10;  // ä»å¾ªç¯è¿”å›å€¼
    };
    println!("å¾ªç¯è¡¨è¾¾å¼å€¼: {}", result);
    
    // é—­åŒ…è¡¨è¾¾å¼
    let add = |a, b| a + b;
    println!("é—­åŒ…è¡¨è¾¾å¼è®¡ç®—: {}", add(3, 4));
}

// è¡¨è¾¾å¼è¯­è¨€çš„é«˜çº§ç”¨æ³•
fn advanced_expressions() {
    // è¡¨è¾¾å¼é“¾å¼è°ƒç”¨
    let numbers = vec![1, 2, 3, 4, 5];
    let sum_of_squares = numbers.iter()
                               .filter(|&&n| n % 2 == 0)
                               .map(|&n| n * n)
                               .sum::<i32>();
    println!("å¶æ•°å¹³æ–¹å’Œ: {}", sum_of_squares);
    
    // æ¡ä»¶åˆå§‹åŒ–
    struct Config {
        debug: bool,
        threads: usize,
    }
    
    let args: Vec<String> = std::env::args().collect();
    let debug_mode = args.iter().any(|arg| arg == "--debug");
    
    let config = Config {
        debug: debug_mode,
        threads: if debug_mode { 1 } else { 4 },
    };
    
    println!("è°ƒè¯•æ¨¡å¼: {}, çº¿ç¨‹æ•°: {}", config.debug, config.threads);
    
    // é”™è¯¯å¤„ç†ä½œä¸ºè¡¨è¾¾å¼
    let result = std::fs::read_to_string("file.txt")
        .map_err(|e| format!("æ— æ³•è¯»å–æ–‡ä»¶: {}", e))
        .and_then(|content| {
            if content.is_empty() {
                Err("æ–‡ä»¶ä¸ºç©º".to_string())
            } else {
                Ok(content.len())
            }
        });
    
    match result {
        Ok(len) => println!("æ–‡ä»¶é•¿åº¦: {} å­—èŠ‚", len),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}

// ç®¡é“å’Œè½¬æ¢
fn pipelines_and_transformations() {
    // æ•°æ®è½¬æ¢ç®¡é“
    let text = "10,20,30,40,50";
    
    let sum: i32 = text.split(',')
                      .map(|s| s.trim())
                      .filter(|s| !s.is_empty())
                      .map(|s| s.parse::<i32>().unwrap_or(0))
                      .sum();
    
    println!("æ€»å’Œ: {}", sum);
    
    // Optionç®¡é“
    let config_value = Some("127.0.0.1:8080");
    let port = config_value
        .map(|addr| addr.split(':').nth(1))
        .flatten()
        .and_then(|p| p.parse::<u16>().ok());
    
    println!("ç«¯å£: {:?}", port);
    
    // ç›¸åŒåŠŸèƒ½ä½¿ç”¨?.and_then()é“¾
    fn extract_port(addr: Option<&str>) -> Option<u16> {
        let parts = addr?.split(':');
        let port_str = parts.skip(1).next()?;
        port_str.parse::<u16>().ok()
    }
    
    println!("æå–çš„ç«¯å£: {:?}", extract_port(config_value));
}
```

#### 9.2.3 ç±»å‹æ¨å¯¼ä¸æ¨¡å¼åŒ¹é…

Rustç±»å‹æ¨å¯¼ä¸æ¨¡å¼åŒ¹é…çš„ç»“åˆï¼š

```rust
// ç±»å‹æ¨å¯¼ç¤ºä¾‹
fn type_inference() {
    // å±€éƒ¨å˜é‡ç±»å‹æ¨å¯¼
    let x = 5; // æ¨å¯¼ä¸º i32
    let y = 3.14; // æ¨å¯¼ä¸º f64
    let s = "hello"; // æ¨å¯¼ä¸º &str
    
    // è¿­ä»£å™¨ç±»å‹æ¨å¯¼
    let v = vec![1, 2, 3];
    let iter = v.iter(); // æ¨å¯¼å‡ºæ­£ç¡®çš„è¿­ä»£å™¨ç±»å‹
    
    // é—­åŒ…ç±»å‹æ¨å¯¼
    let square = |x| x * x; // å‚æ•°ç±»å‹ä»ä¸Šä¸‹æ–‡æ¨å¯¼
    println!("5çš„å¹³æ–¹: {}", square(5));
    
    // å¤æ‚æ³›å‹æ¨å¯¼
    let data = vec![1, 2, 3, 4, 5];
    let sum = data.iter().sum(); // æ¨å¯¼å‡ºæ­£ç¡®çš„è¿”å›ç±»å‹
    println!("æ€»å’Œ: {}", sum);
    
    // ç±»å‹æ¨å¯¼é™åˆ¶
    // let ambiguous = || { }; // é”™è¯¯ï¼šæ— æ³•æ¨å¯¼è¿”å›ç±»å‹
    let specified: fn() -> i32 = || 42; // æ˜ç¡®æŒ‡å®šç±»å‹
    println!("æŒ‡å®šç±»å‹å‡½æ•°: {}", specified());
}

// æ¨¡å¼åŒ¹é…ç»¼åˆç¤ºä¾‹
fn pattern_matching() {
    // åŸºæœ¬match
    let value = 3;
    match value {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        _ => println!("å…¶ä»–"),
    }
    
    // ç»“æ„ä½“æ¨¡å¼
    struct Point { x: i32, y: i32 }
    let point = Point { x: 10, y: 20 };
    
    match point {
        Point { x: 0, y: 0 } => println!("åŸç‚¹"),
        Point { x: 0, y } => println!("ä½äºyè½´ï¼Œy={}", y),
        Point { x, y: 0 } => println!("ä½äºxè½´ï¼Œx={}", x),
        Point { x, y } => println!("ç‚¹({}, {})", x, y),
    }
    
    // æšä¸¾å’Œè§£æ„
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }
    
    let msg = Message::ChangeColor(0, 160, 255);
    
    match msg {
        Message::Quit => println!("é€€å‡º"),
        Message::Move { x, y } => println!("ç§»åŠ¨åˆ°({}, {})", x, y),
        Message::Write(text) => println!("æ–‡æœ¬æ¶ˆæ¯: {}", text),
        Message::ChangeColor(r, g, b) => println!("é¢œè‰²å˜æ›´ä¸º: RGB({}, {}, {})", r, g, b),
    }
    
    // if-letå’Œwhile-letæ¨¡å¼
    let opt = Some(5);
    if let Some(value) = opt {
        println!("æœ‰å€¼: {}", value);
    }
    
    let mut stack = vec![1, 2, 3, 4, 5];
    while let Some(top) = stack.pop() {
        println!("æ ˆé¡¶: {}", top);
    }
    
    // å¤æ‚æ¨¡å¼åŒ¹é…
    let pair = (2, -2);
    match pair {
        (x, y) if x == y => println!("ç›¸ç­‰"),
        (x, y) if x + y == 0 => println!("äº’ä¸ºç›¸åæ•°"),
        (x, _) if x % 2 == 0 => println!("xæ˜¯å¶æ•°"),
        _ => println!("æ— ç‰¹æ®Šå…³ç³»"),
    }
    
    // åŒ¹é…å®ˆå«
    let num = 5;
    match num {
        n if n < 0 => println!("è´Ÿæ•°"),
        n if n > 0 => println!("æ­£æ•°"),
        _ => println!("é›¶"),
    }
    
    // è§£æ„å’Œç»‘å®š
    let point = Point { x: 10, y: 20 };
    let Point { x: a, y: b } = point;
    println!("è§£æ„: a={}, b={}", a, b);
}
```

### 9.3 ç”Ÿæ€ç³»ç»Ÿä¸ç¤¾åŒº

#### 9.3.1 åŒ…ç®¡ç†ä¸ç”Ÿæ€ç³»ç»Ÿå¥å£®æ€§

Rustçš„åŒ…ç®¡ç†å’Œç”Ÿæ€ç³»ç»Ÿè®¾è®¡ï¼š

```rust
// Cargo.toml é…ç½®ç¤ºä¾‹
/*
[package]
name = "my_app"
version = "0.1.0"
authors = ["Your Name <your.email@example.com>"]
edition = "2021"
description = "ç¤ºä¾‹Ruståº”ç”¨ç¨‹åº"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/yourname/my_app"
keywords = ["example", "demo"]
categories = ["command-line-utilities"]

[dependencies]
# åŸºæœ¬ä¾èµ–
serde = { version = "1.0", features = ["derive"] }

# æ¡ä»¶ä¾èµ–
rand = { version = "0.8", optional = true }

# å¼€å‘ä¾èµ–
[dev-dependencies]
criterion = "0.3"
mockall = "0.11"

# ç‰¹æ€§é…ç½®
[features]
default = ["cli"]
cli = ["rand"]
web = ["actix-web"]

# å¹³å°ç‰¹å®šä¾èµ–
[target.'cfg(windows)'.dependencies]
winapi = "0.3"

# æ„å»ºè„šæœ¬ä¾èµ–
[build-dependencies]
cc = "1.0"
*/

// ç¤ºä¾‹build.rs
fn build_script_example() {
    /*
    // build.rs
    fn main() {
        // å¦‚æœCåº“çš„å¤´æ–‡ä»¶å‘ç”Ÿå˜åŒ–ï¼Œé‡æ–°è¿è¡Œæ„å»ºè„šæœ¬
        println!("cargo:rerun-if-changed=native/header.h");
        
        // ç¼–è¯‘æœ¬åœ°Cä»£ç 
        cc::Build::new()
            .file("native/lib.c")
            .compile("mylib");
        
        // è®¾ç½®é“¾æ¥å™¨æ ‡å¿—
        println!("cargo:rustc-link-search=native=lib/");
        println!("cargo:rustc-link-lib=static=mylib");
        
        // æ ¹æ®ç¼–è¯‘ç›®æ ‡å¹³å°è°ƒæ•´è¡Œä¸º
        if cfg!(target_os = "windows") {
            println!("cargo:rustc-link-lib=dylib=user32");
        }
    }
    */
}

// å·¥ä½œç©ºé—´ç¤ºä¾‹
fn workspace_example() {
    /*
    // Cargo.toml (å·¥ä½œç©ºé—´)
    [workspace]
    members = [
        "app",
        "lib1",
        "lib2",
    ]
    
    // lib1/Cargo.toml
    [package]
    name = "lib1"
    version = "0.1.0"
    edition = "2021"
    
    // lib2/Cargo.toml
    [package]
    name = "lib2"
    version = "0.1.0"
    edition = "2021"
    
    [dependencies]
    lib1 = { path = "../lib1" }
    
    // app/Cargo.toml
    [package]
    name = "app"
    version = "0.1.0"
    edition = "2021"
    
    [dependencies]
    lib1 = { path = "../lib1" }
    lib2 = { path = "../lib2" }
    */
}
```

#### 9.3.2 çº¿ç¨‹å®‰å…¨ä¸­çš„å†…å­˜æ¨¡å‹å’Œä¸å˜æ¡ä»¶

Rustçš„å†…å­˜æ¨¡å‹å’Œçº¿ç¨‹å®‰å…¨ä¿è¯ï¼š

```rust
// çº¿ç¨‹å®‰å…¨å†…å­˜æ¨¡å‹
fn memory_model() {
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;
    use std::thread;
    
    // åŸå­æ“ä½œ - ä¸éœ€è¦äº’æ–¥
    let counter = Arc::new(AtomicUsize::new(0));
    
    let mut handles = Vec::new();
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            // ä¸åŒå†…å­˜é¡ºåºå½±å“æ€§èƒ½å’Œè¯­ä¹‰
            counter.fetch_add(1, Ordering::SeqCst);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€ç»ˆè®¡æ•°: {}", counter.load(Ordering::SeqCst));
    
    // å†…å­˜é¡ºåºé€‰é¡¹
    // - Relaxed: æœ€å¼±ä¿è¯ï¼Œåªæœ‰åŸå­æ€§
    // - Release: å†™å…¥æ“ä½œï¼Œå»ºç«‹happens-beforeå…³ç³»
    // - Acquire: è¯»å–æ“ä½œï¼Œè§‚å¯ŸReleaseå†™å…¥
    // - AcqRel: ç»„åˆAcquireå’ŒReleaseè¯­ä¹‰
    // - SeqCst: æœ€å¼ºä¿è¯ï¼Œå…¨åºä¸€è‡´æ€§
}

// ä¸å˜æ¡ä»¶ç»´æŠ¤ç¤ºä¾‹
fn invariants() {
    // é€šè¿‡ç±»å‹ç³»ç»Ÿç»´æŠ¤ä¸å˜æ¡ä»¶
    struct NonZeroUsize(usize);
    
    impl NonZeroUsize {
        fn new(value: usize) -> Option<Self> {
            if value == 0 {
                None
            } else {
                Some(NonZeroUsize(value))
            }
        }
        
        fn get(&self) -> usize {
            self.0 // ä¿è¯éé›¶
        }
    }
    
    // ä½¿ç”¨NonZeroUsize
    match NonZeroUsize::new(42) {
        Some(n) => println!("æœ‰æ•ˆå€¼: {}", n.get()),
        None => println!("æ— æ•ˆå€¼"),
    }
    
    // é€šè¿‡å†…éƒ¨å¯å˜æ€§æ–¹æ³•
    use std::cell::RefCell;
    
    struct BoundedStack {
        data: RefCell<Vec<i32>>,
        capacity: usize,
    }
    
    impl BoundedStack {
        fn new(capacity: usize) -> Self {
            BoundedStack {
                data: RefCell::new(Vec::with_capacity(capacity)),
                capacity,
            }
        }
        
        fn push(&self, value: i32) -> Result<(), &'static str> {
            let mut data = self.data.borrow_mut();
            if data.len() >= self.capacity {
                return Err("æ ˆå·²æ»¡");
            }
            data.push(value);
            Ok(())
        }
        
        fn pop(&self) -> Option<i32> {
            let mut data = self.data.borrow_mut();
            data.pop()
        }
    }
    
    // æµ‹è¯•BoundedStack
    let stack = BoundedStack::new(2);
    assert!(stack.push(1).is_ok());
    assert!(stack.push(2).is_ok());
    assert!(stack.push(3).is_err()); // å·²æ»¡
    
    assert_eq!(stack.pop(), Some(2));
    assert_eq!(stack.pop(), Some(1));
    assert_eq!(stack.pop(), None);
}

// Sendå’ŒSyncå®‰å…¨ç‰¹å¾
fn send_sync_traits() {
    // Send: å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨ä¼ é€’æ‰€æœ‰æƒ
    // Sync: å¯ä»¥åœ¨çº¿ç¨‹é—´å®‰å…¨å…±äº«å¼•ç”¨
    
    struct MySendType(i32);
    // è‡ªåŠ¨å®ç°Send
    
    struct MyNonSendType {
        data: *mut i32, // åŸå§‹æŒ‡é’ˆä¸æ˜¯Send
    }
    // ä¸æ˜¯Send
    
    struct MySyncType(i32);
    // è‡ªåŠ¨å®ç°Sync
    
    struct ThreadSafeWrapper<T> {
        data: std::sync::Mutex<T>,
    }
    
    // å³ä½¿Tä¸æ˜¯Syncï¼ŒThreadSafeWrapper<T>ä¹Ÿæ˜¯Sync
    // å› ä¸ºMutex<T>æ˜¯Syncçš„ï¼Œä¸ç®¡Tæ˜¯ä»€ä¹ˆ
    
    // æ‰‹åŠ¨å®ç°Send/Sync (éå¸¸å°‘è§ä¸”å±é™©)
    struct ManualSend(*mut i32);
    unsafe impl Send for ManualSend {}
    
    // Sendå’ŒSyncåœ¨å®è·µä¸­
    use std::rc::Rc; // ä¸æ˜¯Sendæˆ–Sync
    use std::sync::Arc; // æ˜¯Sendå’ŒSync
    
    // ä¸èƒ½è·¨çº¿ç¨‹å‘é€Rc
    let rc = Rc::new(42);
    // thread::spawn(move || {
    //     println!("rc: {}", rc); // ç¼–è¯‘é”™è¯¯ï¼šRcä¸æ˜¯Send
    // });
    
    // å¯ä»¥è·¨çº¿ç¨‹å‘é€Arc
    let arc = Arc::new(42);
    std::thread::spawn(move || {
        println!("arc: {}", arc); // æ­£ç¡®ï¼šArcæ˜¯Send
    });
}
```

#### 9.3.3 Rustçš„æœªæ¥å‘å±•ä¸æ¼”è¿›æ–¹å‘

Rustè¯­è¨€çš„æœªæ¥å±•æœ›å’Œæ¼”è¿›è®¡åˆ’ï¼š

```rust
// å¼‚æ­¥/ç­‰å¾…æ‰©å±•
async fn async_future() {
    // åŸºæœ¬å¼‚æ­¥å‡½æ•°
    async fn fetch_data(url: &str) -> Result<String, &'static str> {
        // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        Ok(format!("æ¥è‡ª{}çš„æ•°æ®", url))
    }
    
    // å¼‚æ­¥å—
    let future = async {
        let data1 = fetch_data("example.com/api1").await?;
        let data2 = fetch_data("example.com/api2").await?;
        Ok::<_, &'static str>(format!("ç»“æœ: {} å’Œ {}", data1, data2))
    };
    
    // æœªæ¥å¯èƒ½çš„å¼‚æ­¥è¯­æ³•ç³–
    // try_join!(
    //     fetch_data("example.com/api1"),
    //     fetch_data("example.com/api2")
    // )
    
    println!("å¼‚æ­¥ä»£ç å·²å‡†å¤‡å¥½æ‰§è¡Œ");
}

// ç±»å‹ç³»ç»Ÿå¢å¼º
fn type_system_enhancements() {
    // æ³›å‹å…³è”ç±»å‹(GAT) - ç°å·²ç¨³å®š
    trait AdvancedIterator {
        type Item<'a> where Self: 'a;
        
        fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
    }
    
    // å¸¸é‡æ³›å‹å‚æ•° - ç°å·²ç¨³å®š
    fn array_sum<const N: usize>(arr: &[i32; N]) -> i32 {
        arr.iter().sum()
    }
    
    let array = [1, 2, 3, 4, 5];
    println!("æ•°ç»„æ€»å’Œ: {}", array_sum(&array));
    
    // å¯èƒ½çš„æœªæ¥ç‰¹æ€§ï¼šç‰¹åŒ–
    /*
    trait Converter<T> {
        fn convert(&self, value: T) -> String;
    }
    
    impl<T> Converter<T> for Logger {
        fn convert(&self, _: T) -> String {
            "é»˜è®¤è½¬æ¢".to_string()
        }
    }
    
    // ç‰¹åŒ–ä¸ºi32ç±»å‹
    impl Converter<i32> for Logger {
        fn convert(&self, value: i32) -> String {
            format!("æ•´æ•°: {}", value)
        }
    }
    */
}

// å®ç³»ç»Ÿå¢å¼º
fn macro_enhancements() {
    // å£°æ˜å®2.0ï¼ˆé¢„æœŸæœªæ¥ç‰¹æ€§ï¼‰
    /*
    macro json_object {
        { $($key:ident : $value:expr),* $(,)? } => {
            {
                let mut map = std::collections::HashMap::new();
                $(
                    map.insert(stringify!($key).to_string(), $value);
                )*
                map
            }
        }
    }
    
    let config = json_object!{
        server: "127.0.0.1",
        port: 8080,
        debug: true,
    };
    */
    
    // è¿‡ç¨‹å®æ”¹è¿›
    // æ”¹è¿›çš„é”™è¯¯æŠ¥å‘Šå’Œè°ƒè¯•ä½“éªŒ
    // æ›´å¥½çš„å«ç”Ÿæ€§å’Œè§£æèƒ½åŠ›
}

// ç¼–è¯‘å™¨å’Œå·¥å…·é“¾å¢å¼º
fn compiler_improvements() {
    // ç¼–è¯‘é€Ÿåº¦ä¼˜åŒ–
    // ä¾‹å¦‚: å¢é‡ç¼–è¯‘ã€å¹¶è¡Œç¼–è¯‘ç­‰
    
    // é™æ€åˆ†æèƒ½åŠ›å¢å¼º
    // ä¾‹å¦‚: æ›´å¥½çš„å€Ÿç”¨æ£€æŸ¥å™¨ã€æ›´å°‘çš„è¯¯æŠ¥ç­‰
    
    // äº¤å‰ç¼–è¯‘ç®€åŒ–
    // ä¾‹å¦‚: é¢„æ„å»ºå·¥å…·é“¾å’Œä¾èµ–å¤„ç†
    
    // IDEé›†æˆå¢å¼º
    // ä¾‹å¦‚: rust-analyzerå’Œè¯­è¨€æœåŠ¡å™¨åè®®çš„æ”¹è¿›
    
    println!("æœŸå¾…æœªæ¥Rustå·¥å…·é“¾çš„æ›´å¤šå¢å¼º");
}

// ç”Ÿæ€ç³»ç»Ÿå’Œç¤¾åŒºæ‰©å±•
fn ecosystem_growth() {
    // æ ‡å‡†åº“æ‰©å±•
    // ä¾‹å¦‚: æ›´å¤šçš„é›†åˆç±»å‹ã€å®ç”¨å·¥å…·ç­‰
    
    // å¼‚æ­¥ç”Ÿæ€ç³»ç»Ÿæˆç†Ÿ
    // ä¾‹å¦‚: ç»Ÿä¸€å¼‚æ­¥è¿è¡Œæ—¶æ ‡å‡†
    
    // é¢†åŸŸç‰¹å®šæ¡†æ¶
    // ä¾‹å¦‚: åµŒå…¥å¼ã€WebAssemblyã€æ¸¸æˆå¼€å‘ç­‰
    
    // ä¼ä¸šé‡‡ç”¨å¢é•¿
    // ä¾‹å¦‚: æ›´å¤šå¤§å‹ç»„ç»‡å°†Rustç”¨äºç”Ÿäº§ç¯å¢ƒ
    
    println!("Rustç¤¾åŒºä¸æ–­æ‰©å¤§å’Œæˆç†Ÿ");
}
```

### 9.4 æ€»ç»“

Rustè¯­è¨€æ˜¯ä¸€é—¨ç°ä»£ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œè®¾è®¡ç›®æ ‡æ˜¯å…¼é¡¾å®‰å…¨æ€§ã€æ€§èƒ½å’Œå¹¶å‘æ€§ã€‚
é€šè¿‡æœ¬æ–‡å¯¹å‰9ç« çš„è¯¦ç»†è§£æï¼Œæˆ‘ä»¬å·²ç»å…¨é¢äº†è§£äº†Rustçš„è¯­æ³•å’Œè¯­ä¹‰ç‰¹æ€§ï¼Œ
åŒ…æ‹¬ï¼š

1. **åŸºæœ¬è¯­æ³•ä¸è¡¨è¾¾å¼**ï¼šå˜é‡ã€æ•°æ®ç±»å‹ã€å‡½æ•°ã€æ§åˆ¶æµå’ŒåŸºæœ¬æ“ä½œç¬¦ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

2. **ç±»å‹ç³»ç»Ÿä¸æŠ½è±¡**ï¼šRustå¼ºå¤§çš„ç±»å‹ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç»“æ„ä½“ã€æšä¸¾ã€ç‰¹å¾ç­‰æŠ½è±¡æœºåˆ¶ã€‚

3. **æ‰€æœ‰æƒä¸å€Ÿç”¨ç³»ç»Ÿ**ï¼šRustæœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œé€šè¿‡æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™åœ¨ç¼–è¯‘æ—¶ä¿è¯å†…å­˜å®‰å…¨ã€‚

4. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨Resultå’ŒOptionç±»å‹è¿›è¡Œå¯æ¢å¤å’Œä¸å¯æ¢å¤é”™è¯¯å¤„ç†ã€‚

5. **æ¨¡å—ä¸åŒ…ç®¡ç†**ï¼šä»£ç ç»„ç»‡å’Œä¾èµ–ç®¡ç†èƒ½åŠ›ã€‚

6. **å¹¶å‘ç¼–ç¨‹**ï¼šå®‰å…¨é«˜æ•ˆçš„çº¿ç¨‹ã€å¼‚æ­¥ç¼–ç¨‹å’Œå¹¶å‘æ¨¡å¼ã€‚

7. **å…ƒç¼–ç¨‹**ï¼šå®ç³»ç»Ÿå’Œç¼–è¯‘æ—¶ä»£ç ç”Ÿæˆèƒ½åŠ›ã€‚

8. **é«˜çº§ç‰¹æ€§**ï¼šUnsafe Rustã€é«˜çº§ç‰¹å¾ã€ç±»å‹ç³»ç»Ÿç‰¹æ€§å’Œå¤–éƒ¨ä»£ç é›†æˆã€‚

9. **è¯­è¨€å“²å­¦ä¸è®¾è®¡åŸåˆ™**ï¼šRustçš„è®¾è®¡å“²å­¦ã€ç±»å‹å®‰å…¨å’Œè¡¨è¾¾èƒ½åŠ›ï¼Œä»¥åŠç”Ÿæ€ç³»ç»Ÿå‘å±•ã€‚

Rustçš„ç‹¬ç‰¹ä¹‹å¤„åœ¨äºå®ƒé€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶ä¿è¯å†…å­˜å®‰å…¨å’Œçº¿ç¨‹å®‰å…¨ï¼ŒåŒæ—¶ä¸ç‰ºç‰²æ€§èƒ½ã€‚
è¿™ç§"é›¶æˆæœ¬æŠ½è±¡"çš„ç†å¿µä½¿å¾—Rustèƒ½å¤Ÿåœ¨é«˜çº§è¯­è¨€çš„å®‰å…¨æ€§å’Œä½çº§è¯­è¨€çš„æ€§èƒ½ä¹‹é—´å–å¾—å¹³è¡¡ã€‚

éšç€Rustç”Ÿæ€ç³»ç»Ÿçš„ä¸æ–­æˆç†Ÿå’Œç¤¾åŒºçš„å£®å¤§ï¼Œ
æˆ‘ä»¬æœ‰ç†ç”±ç›¸ä¿¡Rustå°†åœ¨ç³»ç»Ÿç¼–ç¨‹ã€WebAssemblyã€åµŒå…¥å¼å¼€å‘å’Œé«˜æ€§èƒ½æœåŠ¡å™¨ç­‰é¢†åŸŸå‘æŒ¥è¶Šæ¥è¶Šé‡è¦çš„ä½œç”¨ã€‚
é€šè¿‡æŒæ¡æœ¬æ–‡ä»‹ç»çš„æ ¸å¿ƒæ¦‚å¿µå’Œç‰¹æ€§ï¼Œè¯»è€…å·²ç»å…·å¤‡äº†æ·±å…¥æ¢ç´¢Rustä¸–ç•Œçš„åŸºç¡€çŸ¥è¯†å’Œå·¥å…·ã€‚
