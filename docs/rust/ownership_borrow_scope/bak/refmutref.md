# Rust 中的引用（&T 和 &mut T）以及“接引用”

下面介绍下 Rust 中关于引用（&T 和 &mut T）以及所谓“接引用”（即先解引用再取引用，如 `&*r`）的定义、等价形式和它们之间的等价关系。

---

## 1. 引用与借用的基本概念

在 Rust 中，**引用**本质上就是对某个值的借用。  

- **不可变引用**：类型为 `&T`，借用后只能对共享数据进行只读访问。  
- **可变引用**：类型为 `&mut T`，在借用期间允许通过该引用修改数据，但同时要求在同一作用域内不能存在其他引用。

当你写出表达式 `&x` 时，实际上就是对 `x` 的一次借用操作。引用和借用在 Rust 的语义中是同一概念，都是在不取得所有权的前提下对数据进行访问。

---

## 2. 解引用与接引用的等价形式

在 Rust 中，**解引用**操作符 `*` 用于从引用中取出其指向值；而**取引用**操作符 `&` 则是获取某个值的地址。当对一个引用先做解引用再取引用时，实际上起到了“取消”解引用的作用，即：
r \equiv &*r
同样，对于可变引用也成立：
r \equiv &mut*r

### 原理说明

给定一个引用 `r`（例如 `r: &T`），则执行下面这步：

- `*r` 会解引用，结果得到类型 `T` 的值（注意：这里只是“访问”，并不发生所有权转移）。
- 对 `*r` 再取地址，即 `&*r`，则会生成一个新的引用，其类型还是 `&T`，且指向的地址与原引用 `r` 所指相同。

因此，**对一个引用先解引用再取引用，结果与原引用是等价的**。这就是 Rust 中“接引用”的等价形式。在编译器的自动解引用（auto-deref）和重新借用（reborrowing）机制下，这种等价关系经常在代码中隐式发挥作用。

---

## 3. 代码示例

下面给出两个简单的例子说明不可变引用和可变引用的等价形式。

### 不可变引用示例

```rust:src/main.rs
fn main() {
    let x = 42;
    let r: &i32 = &x;
    // &*r 与 r 等价
    let r2: &i32 = &*r;
    assert_eq!(r, r2);
}
```

在上面的例子中，`r` 是一个 `&i32` 类型的引用，`&*r` 先解引用后取引用，仍然是一个指向 `x` 的 `&i32` 类型引用，与 `r` 完全等价。

### 可变引用示例

```rust:src/main.rs
fn main() {
    let mut x = 42;
    let r: &mut i32 = &mut x;
    // &mut *r 与 r 等价
    let r2: &mut i32 = &mut *r;
    *r2 += 1;
    assert_eq!(x, 43);
}
```

这里，`r` 是一个可变引用，通过 `&mut *r` 得到的 `r2` 与 `r` 等价，同样指向变量 `x`。

---

## 4. 自动解引用与重新借用

Rust 编译器在方法调用等场景中会自动进行解引用（auto-deref）和重新借用（reborrowing）：  

- **自动解引用**：当方法调用时，编译器会自动沿着实现了 `Deref` trait 的类型进行多次解引用，使得调用链更简洁。  
- **重新借用**：当传递引用给函数时，若函数参数类型的生命周期比原引用短，编译器会自动创建一个局部的借用引用，这个过程可以看作是 `&*r` 或 `&mut *r` 的隐式应用。

例如：

```rust:src/main.rs
fn print_str(s: &str) {
    println!("{}", s);
}

fn main() {
    let s = String::from("hello");
    // s.as_str() 返回的是 &str，而这里编译器也允许将 &String 自动转换为 &str，其中也涉及了自动解引用
    print_str(&s);
}
```

---

## 5. 等价关系总结

- 对于任意不可变引用 `r: &T`，都有：  
  **`r ≡ &*r`**

- 对于任意可变引用 `r: &mut T`，也有：  
  **`r ≡ &mut *r`**

这些等价关系体现了**取地址**和**解引用**操作互为逆操作的性质。同时，根据 Rust 的借用检查规则，只要多个引用满足借用规则（例如不可变引用可以共存，可变引用则要求独占），它们在内存上的指向是一致的，均可安全地访问同一数据。

---

## 小结

- **引用**（&T 和 &mut T）表示对值**借用**。
- 对引用执行 `*` （解引用），再对结果取地址 `&`（接引用），得到的结果与原来的引用完全等价。  
- 这种等价形式不仅使得手写代码时可以灵活转换，也为 Rust 自动解引用和重新借用机制提供了理论基础，从而大大简化了代码的书写和阅读。

通过理解这些等价关系，我们可以更清晰地看到 Rust 在处理引用和借用时背后的设计哲学，从而写出更安全、简洁的代码。
