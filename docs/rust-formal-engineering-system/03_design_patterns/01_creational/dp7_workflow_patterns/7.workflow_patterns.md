# Rust实现的23种工作流设计模式全解析

```text
这是一个关于23种工作流模式的请求，要求用Rust实现各种用例，并结合Rust的异步、泛型和多线程等特性。我需要首先明确这23种工作流模式是什么，因为在工作流领域，不同的分类方法可能会得出不同的模式列表。

一般而言，工作流模式可能指的是工作流控制模式(Workflow Control Patterns)或
业务流程建模(Business Process Modeling)中的模式。
它们通常包括：

基本控制流模式：
1. 序列(Sequence)
2. 并行拆分(Parallel Split)
3. 同步(Synchronization)
4. 独占选择(Exclusive Choice)
5. 简单合并(Simple Merge)

高级分支合并模式：
6. 多选(Multi-Choice)
7. 结构化同步合并(Structured Synchronizing Merge)
8. 多合并(Multi-Merge)
9. 结构化判别(Structured Discriminator)

结构模式：
10. 任意循环(Arbitrary Cycles)
11. 隐式终止(Implicit Termination)

多实例模式：
12. 多实例不同步(Multiple Instances without Synchronization)
13. 设计时多实例(Multiple Instances with a Priori Design-Time Knowledge)
14. 运行时多实例(Multiple Instances with a Priori Run-Time Knowledge)
15. 多实例无先验知识(Multiple Instances without a Priori Runtime Knowledge)

状态基础模式：
16. 延迟选择(Deferred Choice)
17. 交错并行路由(Interleaved Parallel Routing)
18. 里程碑(Milestone)

取消模式：
19. 取消活动(Cancel Activity)
20. 取消案例(Cancel Case)

触发模式：
21. 瞬时触发(Transient Trigger)
22. 持久触发(Persistent Trigger)

其他模式：
23. 可取消活动(Cancelling Discriminator)或通信模式(Communication Pattern)

现在，我将构建一个全面的回答，包括这些模式的详细解释和Rust实现。
我将考虑如何利用Rust的异步、泛型和多线程特性来优化这些实现，
并研究是否有优秀的开源库可以辅助实现这些用例。

Rust的特性优势：
- 异步(async/await)：适合I/O密集型工作流，处理并发任务
- 泛型：可以创建类型安全且可重用的工作流组件
- 多线程：适合CPU密集型工作流处理，提高吞吐量
- 所有权系统：确保资源安全使用和释放
- 错误处理：使工作流程中的错误处理更加明确和安全

让我开始规划答案的结构并提供详细内容。
```

## 目录

- [Rust实现的23种工作流设计模式全解析](#rust实现的23种工作流设计模式全解析)
  - [目录](#目录)
  - [1. 基本控制流模式](#1-基本控制流模式)
    - [1.1 序列模式](#11-序列模式)
    - [1.2 并行拆分模式](#12-并行拆分模式)
    - [1.3 同步模式](#13-同步模式)
    - [1.4 独占选择模式](#14-独占选择模式)
    - [1.5 简单合并模式](#15-简单合并模式)
  - [2. 高级分支合并模式](#2-高级分支合并模式)
    - [2.1 多选模式](#21-多选模式)
    - [2.2 同步合并模式](#22-同步合并模式)
    - [2.3 多合并模式](#23-多合并模式)
    - [2.4 结构化判别模式](#24-结构化判别模式)
    - [2.5 通用判别模式](#25-通用判别模式)
  - [3. 结构模式](#3-结构模式)
    - [3.1 任意循环模式](#31-任意循环模式)
    - [3.2 隐式终止模式](#32-隐式终止模式)
  - [4. 多实例模式](#4-多实例模式)
    - [4.1 无同步多实例模式](#41-无同步多实例模式)
    - [4.2 设计时多实例模式](#42-设计时多实例模式)
    - [4.3 运行时多实例模式](#43-运行时多实例模式)
    - [4.4 无先验知识多实例模式](#44-无先验知识多实例模式)
  - [5. 状态基础模式](#5-状态基础模式)
    - [5.1 延迟选择模式](#51-延迟选择模式)
    - [5.2 交错并行路由模式](#52-交错并行路由模式)
    - [5.3 里程碑模式](#53-里程碑模式)
  - [6. 取消和触发模式](#6-取消和触发模式)
    - [6.1 取消活动模式](#61-取消活动模式)
    - [6.2 取消案例模式](#62-取消案例模式)
    - [6.3 瞬时触发模式](#63-瞬时触发模式)
    - [6.4 持久触发模式](#64-持久触发模式)
  - [7. 模式组合应用](#7-模式组合应用)
    - [7.1 订单处理工作流](#71-订单处理工作流)
    - [7.2 审批工作流](#72-审批工作流)
  - [8. Rust开源工作流库](#8-rust开源工作流库)
    - [8.1 流行库概述](#81-流行库概述)
    - [8.2 Swirl 工作流引擎](#82-swirl-工作流引擎)
      - [8.2.1 基本概念](#821-基本概念)
      - [8.2.2 安装和基本使用](#822-安装和基本使用)
      - [8.2.3 高级功能](#823-高级功能)
    - [8.3 实现自定义工作流库](#83-实现自定义工作流库)
      - [8.3.1 核心组件设计](#831-核心组件设计)
      - [8.3.2 使用示例](#832-使用示例)
  - [9. 总结](#9-总结)
    - [9.1 工作流模式选择指南](#91-工作流模式选择指南)
    - [9.2 Rust工作流实践中的最佳实践](#92-rust工作流实践中的最佳实践)
    - [9.3 未来发展方向](#93-未来发展方向)

## 1. 基本控制流模式

### 1.1 序列模式

**定义**：任务按照预定义的顺序依次执行，前一个任务完成后才开始下一个任务。

**优点**：

- 简单直观，易于实现和理解
- 控制流清晰
- 任务间依赖关系明确

**缺点**：

- 缺乏并行性，总体执行时间是所有任务时间的总和
- 前面的任务失败会阻塞后续任务执行

**使用泛型实现**：

```rust
// 使用泛型定义序列工作流
pub struct SequentialWorkflow<T> {
    tasks: Vec<Box<dyn Fn(T) -> Result<T, String>>>,
}

impl<T: 'static> SequentialWorkflow<T> {
    pub fn new() -> Self {
        Self { tasks: Vec::new() }
    }
    
    pub fn add_task<F>(&mut self, task: F) 
    where 
        F: Fn(T) -> Result<T, String> + 'static
    {
        self.tasks.push(Box::new(task));
    }
    
    pub fn execute(&self, initial: T) -> Result<T, String> {
        let mut current = initial;
        
        for task in &self.tasks {
            match task(current) {
                Ok(result) => current = result,
                Err(e) => return Err(e),
            }
        }
        
        Ok(current)
    }
}

// 使用示例
fn main() {
    let mut workflow = SequentialWorkflow::new();
    
    // 添加处理任务
    workflow.add_task(|data: i32| {
        println!("任务1: 接收数据 {}", data);
        Ok(data + 10)
    });
    
    workflow.add_task(|data: i32| {
        println!("任务2: 处理数据 {}", data);
        if data > 20 {
            Ok(data * 2)
        } else {
            Err("数据值太小".to_string())
        }
    });
    
    workflow.add_task(|data: i32| {
        println!("任务3: 完成处理 {}", data);
        Ok(data - 5)
    });
    
    // 执行工作流
    match workflow.execute(15) {
        Ok(result) => println!("工作流成功完成，结果：{}", result),
        Err(e) => println!("工作流执行失败：{}", e),
    }
}
```

### 1.2 并行拆分模式

**定义**：将执行流分成可以并行执行的多个分支。

**优点**：

- 提高执行效率，减少总体执行时间
- 充分利用多核处理能力
- 适合相互独立的任务

**缺点**：

- 实现复杂度较高
- 需要处理并发安全问题
- 可能需要处理部分失败情况

**使用多线程和异步实现**：

```rust
use std::sync::{Arc, Mutex};
use tokio::task;
use futures::future::join_all;

// 使用多线程实现并行拆分模式
pub struct ParallelSplitWorkflow<T, R> 
where 
    T: Clone + Send + 'static,
    R: Send + 'static
{
    tasks: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> ParallelSplitWorkflow<T, R> 
where
    T: Clone + Send + 'static,
    R: Send + 'static
{
    pub fn new() -> Self {
        Self { tasks: Vec::new() }
    }
    
    pub fn add_task<F>(&mut self, task: F) 
    where 
        F: Fn(T) -> R + Send + Sync + 'static
    {
        self.tasks.push(Box::new(task));
    }
    
    // 同步版本 - 使用标准线程
    pub fn execute_sync(&self, input: T) -> Vec<R> {
        let tasks = Arc::new(self.tasks.clone());
        let results = Arc::new(Mutex::new(Vec::with_capacity(self.tasks.len())));
        let mut handles = vec![];
        
        for i in 0..self.tasks.len() {
            let tasks_clone = Arc::clone(&tasks);
            let results_clone = Arc::clone(&results);
            let input_clone = input.clone();
            
            let handle = std::thread::spawn(move || {
                let task = &tasks_clone[i];
                let result = task(input_clone);
                let mut results = results_clone.lock().unwrap();
                results.push(result);
            });
            
            handles.push(handle);
        }
        
        for handle in handles {
            handle.join().unwrap();
        }
        
        Arc::try_unwrap(results).unwrap().into_inner().unwrap()
    }
    
    // 异步版本 - 使用tokio
    pub async fn execute_async(&self, input: T) -> Vec<R> 
    where 
        R: Send + 'static
    {
        let mut tasks = Vec::with_capacity(self.tasks.len());
        
        for task in &self.tasks {
            let input_clone = input.clone();
            let task_clone = task.clone();
            
            let future = task::spawn_blocking(move || {
                task_clone(input_clone)
            });
            
            tasks.push(future);
        }
        
        let results = join_all(tasks).await;
        results.into_iter().map(|r| r.unwrap()).collect()
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let mut workflow = ParallelSplitWorkflow::new();
    
    // 添加要并行执行的任务
    workflow.add_task(|num: i32| {
        println!("计算平方：{}", num);
        std::thread::sleep(std::time::Duration::from_millis(500));
        num * num
    });
    
    workflow.add_task(|num: i32| {
        println!("计算立方：{}", num);
        std::thread::sleep(std::time::Duration::from_millis(300));
        num * num * num
    });
    
    workflow.add_task(|num: i32| {
        println!("计算加倍：{}", num);
        std::thread::sleep(std::time::Duration::from_millis(100));
        num * 2
    });
    
    // 同步执行
    let sync_results = workflow.execute_sync(5);
    println!("同步执行结果：{:?}", sync_results);
    
    // 异步执行
    let async_results = workflow.execute_async(5).await;
    println!("异步执行结果：{:?}", async_results);
}
```

### 1.3 同步模式

**定义**：将多个并行执行的分支合并为一个分支，等待所有输入分支完成才继续执行。

**优点**：

- 确保所有前置任务完成后再继续
- 适合有依赖关系的任务流程
- 便于处理阶段性结果

**缺点**：

- 整体速度受限于最慢的分支
- 可能引入阻塞等待
- 需要合理处理任务失败情况

**使用异步实现**：

```rust
use std::sync::Arc;
use tokio::sync::{Barrier, Mutex};
use futures::future::join_all;
use std::time::Duration;

// 使用异步实现同步模式
pub struct SynchronizationWorkflow<T, R> 
where 
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    parallel_tasks: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
    after_sync_task: Option<Box<dyn Fn(Vec<R>) -> R + Send + Sync>>,
}

impl<T, R> SynchronizationWorkflow<T, R> 
where
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self { 
            parallel_tasks: Vec::new(),
            after_sync_task: None,
        }
    }
    
    pub fn add_parallel_task<F>(&mut self, task: F) 
    where 
        F: Fn(T) -> R + Send + Sync + 'static
    {
        self.parallel_tasks.push(Box::new(task));
    }
    
    pub fn set_after_sync_task<F>(&mut self, task: F)
    where
        F: Fn(Vec<R>) -> R + Send + Sync + 'static
    {
        self.after_sync_task = Some(Box::new(task));
    }
    
    pub async fn execute(&self, input: T) -> R
    where
        R: Default,
    {
        // 没有设置同步后任务，返回默认值
        if self.after_sync_task.is_none() {
            return R::default();
        }
        
        let mut tasks = Vec::new();
        let barrier = Arc::new(Barrier::new(self.parallel_tasks.len()));
        let results = Arc::new(Mutex::new(Vec::with_capacity(self.parallel_tasks.len())));
        
        // 创建并执行所有并行任务
        for task in &self.parallel_tasks {
            let task_fn = task.clone();
            let input_clone = input.clone();
            let barrier_clone = barrier.clone();
            let results_clone = results.clone();
            
            let future = tokio::spawn(async move {
                // 执行任务
                let result = task_fn(input_clone);
                
                // 存储结果
                {
                    let mut results = results_clone.lock().await;
                    results.push(result);
                }
                
                // 等待所有任务完成
                barrier_clone.wait().await;
            });
            
            tasks.push(future);
        }
        
        // 等待所有任务完成
        join_all(tasks).await;
        
        // 获取所有结果并执行同步后任务
        let collected_results = results.lock().await.clone();
        let after_sync = self.after_sync_task.as_ref().unwrap();
        after_sync(collected_results)
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let mut workflow = SynchronizationWorkflow::new();
    
    // 添加并行任务
    workflow.add_parallel_task(|num: i32| {
        println!("计算平方：{}", num);
        tokio::time::sleep(Duration::from_millis(200)).await;
        num * num
    });
    
    workflow.add_parallel_task(|num: i32| {
        println!("计算立方：{}", num);
        tokio::time::sleep(Duration::from_millis(300)).await;
        num * num * num
    });
    
    workflow.add_parallel_task(|num: i32| {
        println!("计算加倍：{}", num);
        tokio::time::sleep(Duration::from_millis(100)).await;
        num * 2
    });
    
    // 设置同步后任务
    workflow.set_after_sync_task(|results: Vec<i32>| {
        println!("所有并行任务已完成，结果：{:?}", results);
        results.iter().sum() // 计算总和
    });
    
    // 执行工作流
    let result = workflow.execute(5).await;
    println!("最终结果：{}", result);
}
```

### 1.4 独占选择模式

**定义**：根据条件从多个分支中选择一个执行，类似编程语言中的if-else或switch语句。

**优点**：

- 根据条件动态选择执行路径
- 避免不必要的任务执行
- 灵活处理多种情况

**缺点**：

- 需要明确的选择条件
- 如果条件复杂可能导致难以维护
- 可能存在条件评估开销

**使用泛型实现**：

```rust
// 使用泛型实现独占选择模式
pub struct ExclusiveChoiceWorkflow<T, R> {
    branches: Vec<(Box<dyn Fn(&T) -> bool>, Box<dyn Fn(T) -> R>)>,
    default_branch: Option<Box<dyn Fn(T) -> R>>,
}

impl<T, R> ExclusiveChoiceWorkflow<T, R> 
where
    T: Clone + 'static,
    R: 'static,
{
    pub fn new() -> Self {
        Self { 
            branches: Vec::new(),
            default_branch: None,
        }
    }
    
    pub fn add_branch<C, F>(&mut self, condition: C, task: F)
    where
        C: Fn(&T) -> bool + 'static,
        F: Fn(T) -> R + 'static,
    {
        self.branches.push((Box::new(condition), Box::new(task)));
    }
    
    pub fn set_default_branch<F>(&mut self, task: F)
    where
        F: Fn(T) -> R + 'static,
    {
        self.default_branch = Some(Box::new(task));
    }
    
    pub fn execute(&self, input: T) -> Option<R> {
        // 迭代所有分支，查找第一个满足条件的
        for (condition, task) in &self.branches {
            if condition(&input) {
                return Some(task(input.clone()));
            }
        }
        
        // 如果没有匹配的分支，使用默认分支
        self.default_branch.as_ref().map(|default| default(input))
    }
}

// 使用示例
fn main() {
    // 创建工作流
    let mut workflow = ExclusiveChoiceWorkflow::new();
    
    // 添加条件分支
    workflow.add_branch(
        |num: &i32| *num > 100, // 条件
        |num: i32| {            // 任务
            println!("处理大数：{}", num);
            format!("大数结果：{}", num / 2)
        }
    );
    
    workflow.add_branch(
        |num: &i32| *num > 50 && *num <= 100,
        |num: i32| {
            println!("处理中等数：{}", num);
            format!("中等数结果：{}", num * 2)
        }
    );
    
    workflow.add_branch(
        |num: &i32| *num > 0 && *num <= 50,
        |num: i32| {
            println!("处理小数：{}", num);
            format!("小数结果：{}", num * 10)
        }
    );
    
    // 设置默认分支
    workflow.set_default_branch(|num: i32| {
        println!("处理其他情况：{}", num);
        format!("默认结果：{}", num)
    });
    
    // 执行工作流
    let result1 = workflow.execute(120);
    let result2 = workflow.execute(75);
    let result3 = workflow.execute(30);
    let result4 = workflow.execute(-10);
    
    println!("结果1：{:?}", result1);
    println!("结果2：{:?}", result2);
    println!("结果3：{:?}", result3);
    println!("结果4：{:?}", result4);
}
```

### 1.5 简单合并模式

**定义**：将多个分支合并为一个分支，不需要同步（任一分支完成即可继续）。

**优点**：

- 无需等待所有分支完成
- 简化分支流程控制
- 减少不必要的等待

**缺点**：

- 可能丢失某些分支结果
- 难以处理多个分支都完成的情况
- 需要小心处理重复执行合并后流程的情况

**使用异步实现**：

```rust
use tokio::sync::mpsc;
use tokio::time::Duration;
use futures::StreamExt;

// 使用异步实现简单合并模式
pub struct SimpleMergeWorkflow<T, R> {
    branches: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
    after_merge: Option<Box<dyn Fn(R) -> R + Send + Sync>>,
}

impl<T, R> SimpleMergeWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: Vec::new(),
            after_merge: None,
        }
    }
    
    pub fn add_branch<F>(&mut self, branch: F)
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push(Box::new(branch));
    }
    
    pub fn set_after_merge<F>(&mut self, task: F)
    where
        F: Fn(R) -> R + Send + Sync + 'static,
    {
        self.after_merge = Some(Box::new(task));
    }
    
    pub async fn execute(&self, input: T) -> Option<R>
    where
        R: Send,
    {
        if self.branches.is_empty() {
            return None;
        }
        
        // 创建通道用于接收第一个完成的分支结果
        let (tx, mut rx) = mpsc::channel(1);
        
        // 执行所有分支
        for branch in &self.branches {
            let branch = branch.clone();
            let input_clone = input.clone();
            let tx = tx.clone();
            
            tokio::spawn(async move {
                let result = branch(input_clone);
                // 尝试发送结果，如果通道已关闭则忽略错误
                let _ = tx.send(result).await;
            });
        }
        
        // 丢弃最后一个多余的发送端
        drop(tx);
        
        // 接收第一个完成的分支结果
        if let Some(result) = rx.recv().await {
            // 立即关闭通道，后续结果会被丢弃
            rx.close();
            
            // 如果设置了合并后任务，则执行
            if let Some(after_merge) = &self.after_merge {
                return Some(after_merge(result));
            }
            
            return Some(result);
        }
        
        None
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let mut workflow = SimpleMergeWorkflow::new();
    
    // 添加分支
    workflow.add_branch(|input: String| {
        println!("分支1处理中: {}", input);
        std::thread::sleep(Duration::from_millis(300));
        format!("分支1结果: {}", input.to_uppercase())
    });
    
    workflow.add_branch(|input: String| {
        println!("分支2处理中: {}", input);
        std::thread::sleep(Duration::from_millis(200)); // 这个完成得更快
        format!("分支2结果: {}-分支2", input)
    });
    
    workflow.add_branch(|input: String| {
        println!("分支3处理中: {}", input);
        std::thread::sleep(Duration::from_millis(500));
        format!("分支3结果: {}-很慢", input)
    });
    
    // 设置合并后任务
    workflow.set_after_merge(|result: String| {
        println!("合并后处理: {}", result);
        format!("最终结果: {}", result)
    });
    
    // 执行工作流
    let result = workflow.execute("测试输入".to_string()).await;
    println!("工作流结果: {:?}", result);
}
```

## 2. 高级分支合并模式

### 2.1 多选模式

**定义**：根据条件从多个分支中选择零个、一个或多个分支执行，与独占选择不同，这里允许多个分支同时被选中。

**优点**：

- 比独占选择更灵活
- 可以处理多种条件同时满足的情况
- 支持并发执行多个分支

**缺点**：

- 实现复杂度较高
- 需要处理多个分支结果
- 可能需要更复杂的合并策略

**使用泛型和异步实现**：

```rust
use std::sync::Arc;
use tokio::task;
use futures::future::join_all;

// 使用泛型和异步实现多选模式
pub struct MultiChoiceWorkflow<T, R> {
    branches: Vec<(Box<dyn Fn(&T) -> bool + Send + Sync>, Box<dyn Fn(T) -> R + Send + Sync>)>,
    merge_strategy: Option<Box<dyn Fn(Vec<R>) -> R + Send + Sync>>,
}

impl<T, R> MultiChoiceWorkflow<T, R>
where
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: Vec::new(),
            merge_strategy: None,
        }
    }
    
    pub fn add_branch<C, F>(&mut self, condition: C, task: F)
    where
        C: Fn(&T) -> bool + Send + Sync + 'static,
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push((Box::new(condition), Box::new(task)));
    }
    
    pub fn set_merge_strategy<F>(&mut self, strategy: F)
    where
        F: Fn(Vec<R>) -> R + Send + Sync + 'static,
    {
        self.merge_strategy = Some(Box::new(strategy));
    }
    
    pub async fn execute(&self, input: T) -> Option<R>
    where
        R: Default,
    {
        // 选择满足条件的分支
        let mut selected_branches = Vec::new();
        
        for (condition, task) in &self.branches {
            if condition(&input) {
                selected_branches.push(task.clone());
            }
        }
        
        if selected_branches.is_empty() {
            return None;
        }
        
        // 并行执行所有选中的分支
        let mut tasks = Vec::new();
        
        for branch in selected_branches {
            let input_clone = input.clone();
            let task = task::spawn(async move {
                branch(input_clone)
            });
            tasks.push(task);
        }
        
        // 收集所有结果
        let results = join_all(tasks).await;
        let results: Vec<R> = results.into_iter()
            .filter_map(|r| r.ok())
            .collect();
        
        // 应用合并策略
        if let Some(merge_strategy) = &self.merge_strategy {
            Some(merge_strategy(results))
        } else if !results.is_empty() {
            // 默认返回第一个结果
            results.into_iter().next()
        } else {
            None
        }
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let mut workflow = MultiChoiceWorkflow::new();
    
    // 添加分支
    workflow.add_branch(
        |num: &i32| *num % 2 == 0, // 条件: 偶数
        |num: i32| {
            println!("偶数处理: {}", num);
            format!("偶数结果: {}", num * 2)
        }
    );
    
    workflow.add_branch(
        |num: &i32| *num % 3 == 0, // 条件: 3的倍数
        |num: i32| {
            println!("3的倍数处理: {}", num);
            format!("3的倍数结果: {}", num / 3)
        }
    );
    
    workflow.add_branch(
        |num: &i32| *num > 10, // 条件: 大于10
        |num: i32| {
            println!("大数处理: {}", num);
            format!("大数结果: {}", num - 10)
        }
    );
    
    // 设置合并策略
    workflow.set_merge_strategy(|results: Vec<String>| {
        println!("合并 {} 个结果", results.len());
        results.join(" | ")
    });
    
    // 执行工作流 - 满足多个条件
    let result = workflow.execute(12).await; // 12是偶数，3的倍数，也大于10
    println!("最终结果: {:?}", result);
}
```

### 2.2 同步合并模式

**定义**：与多选模式配合使用，等待所有被选中的分支完成后再合并为一个分支。

**优点**：

- 确保所有选中分支都完成
- 提供全面的结果处理
- 适合需要综合多个结果的场景

**缺点**：

- 执行时间取决于最慢的分支
- 需要处理部分分支失败的情况
- 实现复杂度高

**使用异步和多线程实现**：

```rust
use std::sync::Arc;
use tokio::sync::{Barrier, Mutex};
use tokio::task;
use futures::future::join_all;

// 使用异步实现同步合并模式
pub struct SynchronizingMergeWorkflow<T, R> {
    branches: Vec<(Box<dyn Fn(&T) -> bool + Send + Sync>, Box<dyn Fn(T) -> R + Send + Sync>)>,
    merge_task: Option<Box<dyn Fn(Vec<R>) -> R + Send + Sync>>,
}

impl<T, R> SynchronizingMergeWorkflow<T, R>
where
    T: Clone + Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: Vec::new(),
            merge_task: None,
        }
    }
    
    pub fn add_branch<C, F>(&mut self, condition: C, task: F)
    where
        C: Fn(&T) -> bool + Send + Sync + 'static,
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.branches.push((Box::new(condition), Box::new(task)));
    }
    
    pub fn set_merge_task<F>(&mut self, task: F)
    where
        F: Fn(Vec<R>) -> R + Send + Sync + 'static,
    {
        self.merge_task = Some(Box::new(task));
    }
    
    pub async fn execute(&self, input: T) -> Option<R>
    where
        R: Default + Clone,
    {
        // 筛选满足条件的分支
        let mut selected_branches = Vec::new();
        
        for (condition, task) in &self.branches {
            if condition(&input) {
                selected_branches.push(task.clone());
            }
        }
        
        if selected_branches.is_empty() {
            return None;
        }
        
        // 创建屏障和结果存储
        let barrier = Arc::new(Barrier::new(selected_branches.len()));
        let results = Arc::new(Mutex::new(Vec::with_capacity(selected_branches.len())));
        let mut tasks = Vec::with_capacity(selected_branches.len());
        
        // 并行执行所有选中的分支
        for (index, branch) in selected_branches.into_iter().enumerate() {
            let input_clone = input.clone();
            let barrier_clone = barrier.clone();
            let results_clone = results.clone();
            
            let task = task::spawn(async move {
                let result = branch(input_clone);
                
                // 存储结果
                {
                    let mut results = results_clone.lock().await;
                    // 确保结果按索引顺序存储
                    if results.len() <= index {
                        results.resize_with(index + 1, || R::default());
                    }
                    results[index] = result;
                }
                
                // 等待所有分支完成
                barrier_clone.wait().await;
            });
            
            tasks.push(task);
        }
        
        // 等待所有任务完成
        let _ = join_all(tasks).await;
        
        // 处理结果
        let collected_results = results.lock().await.clone();
        if let Some(merge_task) = &self.merge_task {
            Some(merge_task(collected_results))
        } else if !collected_results.is_empty() {
            Some(collected_results[0].clone())
        } else {
            None
        }
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let mut workflow = SynchronizingMergeWorkflow::new();
    
    // 添加条件分支
    workflow.add_branch(
        |data: &String| data.contains("A"),
        |data: String| {
            println!("处理包含A: {}", data);
            tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
            format!("A处理结果: {}", data)
        }
    );
    
    workflow.add_branch(
        |data: &String| data.contains("B"),
        |data: String| {
            println!("处理包含B: {}", data);
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
            format!("B处理结果: {}", data)
        }
    );
    
    workflow.add_branch(
        |data: &String| data.len() > 5,
        |data: String| {
            println!("处理长字符串: {}", data);
            tok
<think>
继续完成代码示例，然后继续编写其他模式的解释和实现。
</think>

```rust
            println!("处理长字符串: {}", data);
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
            format!("长度处理结果: {}", data)
        }
    );
    
    // 设置合并任务
    workflow.set_merge_task(|results: Vec<String>| {
        println!("合并 {} 个结果", results.len());
        format!("组合结果: {}", results.join(" + "))
    });
    
    // 执行工作流 - 输入同时满足多个条件
    let result = workflow.execute("ABCDEF".to_string()).await;
    println!("最终结果: {:?}", result);
    
    // 执行工作流 - 输入只满足部分条件
    let result = workflow.execute("CDE".to_string()).await;
    println!("最终结果: {:?}", result);
}
```

### 2.3 多合并模式

**定义**：允许多个分支的执行结果以不同的方式合并（可能采用不同的合并策略）。

**优点**：

- 高度灵活的结果处理方式
- 支持复杂的业务逻辑
- 可以根据结果的不同特性采用不同合并策略

**缺点**：

- 实现复杂
- 需要明确定义各种合并策略
- 测试复杂度高

**使用泛型和多线程实现**：

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::HashMap;
use std::hash::Hash;

// 多合并模式
pub struct MultiMergeWorkflow<T, K, R> 
where
    K: Eq + Hash,
{
    branches: Vec<Box<dyn Fn(T) -> (K, R) + Send + Sync>>,
    merge_strategies: HashMap<K, Box<dyn Fn(Vec<R>) -> R + Send + Sync>>,
    default_strategy: Box<dyn Fn(Vec<R>) -> R + Send + Sync>,
}

impl<T, K, R> MultiMergeWorkflow<T, K, R>
where
    T: Clone + Send + Sync + 'static,
    K: Eq + Hash + Clone + Send + Sync + 'static,
    R: Clone + Send + Sync + 'static,
{
    pub fn new<F>(default_strategy: F) -> Self
    where
        F: Fn(Vec<R>) -> R + Send + Sync + 'static,
    {
        Self {
            branches: Vec::new(),
            merge_strategies: HashMap::new(),
            default_strategy: Box::new(default_strategy),
        }
    }
    
    pub fn add_branch<F>(&mut self, branch: F)
    where
        F: Fn(T) -> (K, R) + Send + Sync + 'static,
    {
        self.branches.push(Box::new(branch));
    }
    
    pub fn add_merge_strategy<F>(&mut self, key: K, strategy: F)
    where
        F: Fn(Vec<R>) -> R + Send + Sync + 'static,
    {
        self.merge_strategies.insert(key, Box::new(strategy));
    }
    
    pub fn execute(&self, input: T) -> HashMap<K, R>
    where
        R: Default,
    {
        if self.branches.is_empty() {
            return HashMap::new();
        }
        
        // 存储分组结果
        let grouped_results: Arc<Mutex<HashMap<K, Vec<R>>>> = Arc::new(Mutex::new(HashMap::new()));
        let mut handles = Vec::new();
        
        // 并行执行所有分支
        for branch in &self.branches {
            let branch = branch.clone();
            let input_clone = input.clone();
            let results_clone = Arc::clone(&grouped_results);
            
            let handle = thread::spawn(move || {
                let (key, result) = branch(input_clone);
                
                // 将结果添加到对应的组
                let mut results = results_clone.lock().unwrap();
                results.entry(key).or_insert_with(Vec::new).push(result);
            });
            
            handles.push(handle);
        }
        
        // 等待所有线程完成
        for handle in handles {
            handle.join().unwrap();
        }
        
        // 应用合并策略
        let grouped_results = Arc::try_unwrap(grouped_results)
            .unwrap()
            .into_inner()
            .unwrap();
        
        let mut final_results = HashMap::new();
        
        for (key, results) in grouped_results {
            let merge_fn = self.merge_strategies.get(&key)
                .unwrap_or(&self.default_strategy);
            
            final_results.insert(key, merge_fn(results));
        }
        
        final_results
    }
}

// 使用示例
fn main() {
    // 创建工作流，默认合并策略是取第一个结果
    let mut workflow = MultiMergeWorkflow::new(|results: Vec<String>| {
        if results.is_empty() {
            "空结果".to_string()
        } else {
            results[0].clone()
        }
    });
    
    // 添加分支
    workflow.add_branch(|data: String| {
        println!("分支1处理: {}", data);
        if data.contains("error") {
            ("error".to_string(), format!("错误: {}", data))
        } else {
            ("success".to_string(), format!("成功1: {}", data))
        }
    });
    
    workflow.add_branch(|data: String| {
        println!("分支2处理: {}", data);
        if data.len() < 5 {
            ("short".to_string(), format!("短数据: {}", data))
        } else {
            ("success".to_string(), format!("成功2: {}", data))
        }
    });
    
    workflow.add_branch(|data: String| {
        println!("分支3处理: {}", data);
        if data.to_uppercase() == data {
            ("uppercase".to_string(), format!("大写: {}", data))
        } else {
            ("success".to_string(), format!("成功3: {}", data))
        }
    });
    
    // 添加合并策略
    workflow.add_merge_strategy("success".to_string(), |results| {
        format!("合并成功结果: {}", results.join(" | "))
    });
    
    workflow.add_merge_strategy("error".to_string(), |results| {
        format!("错误已处理: {}", results[0])
    });
    
    // 执行工作流
    let result1 = workflow.execute("test data".to_string());
    println!("结果1: {:?}", result1);
    
    let result2 = workflow.execute("ERROR".to_string());
    println!("结果2: {:?}", result2);
    
    let result3 = workflow.execute("error case".to_string());
    println!("结果3: {:?}", result3);
}
```

### 2.4 结构化判别模式

**定义**：根据工作流实例的数据（而非控制流数据）来决定执行路径，通常基于结构化的业务文档或数据对象。

**优点**：

- 路由决策基于业务数据
- 适合处理复杂结构化数据
- 支持更细粒度的控制流

**缺点**：

- 路由逻辑可能变得复杂
- 需要访问和理解结构化数据
- 可能需要维护多个判别标准

**使用泛型实现**：

```rust
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

// 结构化判别模式
pub struct StructuredDiscriminatorWorkflow<T, R>
where
    T: 'static,
    R: 'static,
{
    // 判别器: 输入数据 -> 路径标识
    discriminator: Box<dyn Fn(&T) -> String>,
    
    // 路径映射: 路径标识 -> 处理函数
    paths: HashMap<String, Box<dyn Fn(T) -> R>>,
    
    // 默认路径
    default_path: Option<Box<dyn Fn(T) -> R>>,
}

impl<T, R> StructuredDiscriminatorWorkflow<T, R>
where
    T: 'static,
    R: 'static,
{
    pub fn new<F>(discriminator: F) -> Self
    where
        F: Fn(&T) -> String + 'static,
    {
        Self {
            discriminator: Box::new(discriminator),
            paths: HashMap::new(),
            default_path: None,
        }
    }
    
    pub fn add_path<F>(&mut self, path_id: &str, handler: F)
    where
        F: Fn(T) -> R + 'static,
    {
        self.paths.insert(path_id.to_string(), Box::new(handler));
    }
    
    pub fn set_default_path<F>(&mut self, handler: F)
    where
        F: Fn(T) -> R + 'static,
    {
        self.default_path = Some(Box::new(handler));
    }
    
    pub fn execute(&self, input: T) -> Option<R> {
        // 使用判别器获取路径标识
        let path_id = (self.discriminator)(&input);
        
        // 查找对应的处理函数
        if let Some(handler) = self.paths.get(&path_id) {
            Some(handler(input))
        } else if let Some(default_handler) = &self.default_path {
            Some(default_handler(input))
        } else {
            None
        }
    }
}

// 示例用结构化数据
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Order {
    id: String,
    customer_type: String,
    total_amount: f64,
    items: Vec<OrderItem>,
    shipping_address: Address,
    status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct OrderItem {
    product_id: String,
    quantity: i32,
    price: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Address {
    country: String,
    city: String,
    postal_code: String,
}

// 使用示例
fn main() {
    // 创建工作流，判别器基于订单的多个属性
    let mut workflow = StructuredDiscriminatorWorkflow::new(|order: &Order| -> String {
        // 国际高价值订单
        if order.shipping_address.country != "中国" && order.total_amount > 1000.0 {
            return "international_high_value".to_string();
        }
        
        // VIP客户订单
        if order.customer_type == "VIP" {
            return "vip_order".to_string();
        }
        
        // 大型订单（10个以上物品）
        if order.items.len() > 10 {
            return "bulk_order".to_string();
        }
        
        // 标准订单
        "standard_order".to_string()
    });
    
    // 添加处理路径
    workflow.add_path("international_high_value", |order: Order| {
        println!("处理国际高价值订单: {}", order.id);
        format!("国际高价值订单 {} 已处理，安排特殊配送", order.id)
    });
    
    workflow.add_path("vip_order", |order: Order| {
        println!("处理VIP订单: {}", order.id);
        format!("VIP订单 {} 已优先处理，安排礼品包装", order.id)
    });
    
    workflow.add_path("bulk_order", |order: Order| {
        println!("处理大型订单: {}", order.id);
        format!("大型订单 {} 已处理，安排分批发货", order.id)
    });
    
    workflow.add_path("standard_order", |order: Order| {
        println!("处理标准订单: {}", order.id);
        format!("标准订单 {} 已处理", order.id)
    });
    
    // 设置默认路径
    workflow.set_default_path(|order: Order| {
        println!("处理未分类订单: {}", order.id);
        format!("订单 {} 已通过默认流程处理", order.id)
    });
    
    // 创建测试订单
    let vip_order = Order {
        id: "ORD-001".to_string(),
        customer_type: "VIP".to_string(),
        total_amount: 500.0,
        items: vec![
            OrderItem { product_id: "P1".to_string(), quantity: 2, price: 250.0 }
        ],
        shipping_address: Address {
            country: "中国".to_string(),
            city: "北京".to_string(),
            postal_code: "100000".to_string(),
        },
        status: "新建".to_string(),
    };
    
    let international_order = Order {
        id: "ORD-002".to_string(),
        customer_type: "标准".to_string(),
        total_amount: 1500.0,
        items: vec![
            OrderItem { product_id: "P2".to_string(), quantity: 1, price: 1500.0 }
        ],
        shipping_address: Address {
            country: "美国".to_string(),
            city: "纽约".to_string(),
            postal_code: "10001".to_string(),
        },
        status: "新建".to_string(),
    };
    
    // 执行工作流
    let result1 = workflow.execute(vip_order);
    let result2 = workflow.execute(international_order);
    
    println!("结果1: {:?}", result1);
    println!("结果2: {:?}", result2);
}
```

### 2.5 通用判别模式

**定义**：同步多个分支的执行结果，根据预定义的判别函数来路由控制流向不同的输出分支。

**优点**：

- 提供高度的动态性和灵活性
- 基于运行时状态做决策
- 适合复杂业务逻辑

**缺点**：

- 实现复杂
- 可能导致控制流不透明
- 测试和调试困难

**使用异步和泛型实现**：

```rust
use std::collections::HashMap;
use std::future::Future;
use std::pin::Pin;
use futures::future::join_all;
use async_trait::async_trait;

// 任务特征
#[async_trait]
pub trait Task<T, R> {
    async fn execute(&self, input: T) -> R;
}

// 实现Task特征的闭包包装
pub struct TaskFn<T, R, F>
where
    F: Fn(T) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync,
{
    func: F,
}

impl<T, R, F> TaskFn<T, R, F>
where
    F: Fn(T) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync,
{
    pub fn new(func: F) -> Self {
        Self { func }
    }
}

#[async_trait]
impl<T, R, F> Task<T, R> for TaskFn<T, R, F>
where
    T: Send + 'static,
    R: Send + 'static,
    F: Fn(T) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync + 'static,
{
    async fn execute(&self, input: T) -> R {
        (self.func)(input).await
    }
}

// 通用判别模式
pub struct GeneralizedAndDiscriminatorWorkflow<T, I, R> {
    // 初始任务
    initial_tasks: Vec<Box<dyn Task<T, I> + Send + Sync>>,
    
    // 判别器: 接收初始任务的所有结果，返回选择的路径ID
    discriminator: Box<dyn Fn(Vec<I>) -> String + Send + Sync>,
    
    // 路径映射: 路径ID -> 最终处理任务
    paths: HashMap<String, Box<dyn Task<Vec<I>, R> + Send + Sync>>,
    
    // 默认路径
    default_path: Option<Box<dyn Task<Vec<I>, R> + Send + Sync>>,
}

impl<T, I, R> GeneralizedAndDiscriminatorWorkflow<T, I, R>
where
    T: Clone + Send + 'static,
    I: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F>(discriminator: F) -> Self
    where
        F: Fn(Vec<I>) -> String + Send + Sync + 'static,
    {
        Self {
            initial_tasks: Vec::new(),
            discriminator: Box::new(discriminator),
            paths: HashMap::new(),
            default_path: None,
        }
    }
    
    pub fn add_initial_task<F>(&mut self, task: F)
    where
        F: Fn(T) -> Pin<Box<dyn Future<Output = I> + Send>> + Send + Sync + 'static,
    {
        self.initial_tasks.push(Box::new(TaskFn::new(task)));
    }
    
    pub fn add_path<P, F>(&mut self, path_id: P, handler: F)
    where
        P: AsRef<str>,
        F: Fn(Vec<I>) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync + 'static,
    {
        self.paths.insert(
            path_id.as_ref().to_string(),
            Box::new(TaskFn::new(handler)),
        );
    }
    
    pub fn set_default_path<F>(&mut self, handler: F)
    where
        F: Fn(Vec<I>) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync + 'static,
    {
        self.default_path = Some(Box::new(TaskFn::new(handler)));
    }
    
    pub async fn execute(&self, input: T) -> Option<R> {
        if self.initial_tasks.is_empty() {
            return None;
        }
        
        // 并行执行所有初始任务
        let mut futures = Vec::new();
        for task in &self.initial_tasks {
            let input_clone = input.clone();
            let future = task.execute(input_clone);
            futures.push(future);
        }
        
        // 等待所有初始任务完成
        let initial_results = join_all(futures).await;
        
        // 使用判别器确定路径
        let path_id = (self.discriminator)(initial_results.clone());
        
        // 执行选中的路径
        if let Some(path_handler) = self.paths.get(&path_id) {
            Some(path_handler.execute(initial_results).await)
        } else if let Some(default_handler) = &self.default_path {
            Some(default_handler.execute(initial_results).await)
        } else {
            None
        }
    }
}

// 使用示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建工作流
    let mut workflow = GeneralizedAndDiscriminatorWorkflow::new(|results: Vec<String>| {
        // 判别器: 分析所有初始结果，确定后续路径
        let mut error_count = 0;
        let mut warning_count = 0;
        
        for result in &results {
            if result.contains("ERROR") {
                error_count += 1;
            } else if result.contains("WARNING") {
                warning_count += 1;
            }
        }
        
        if error_count > 0 {
            "error_path".to_string()
        } else if warning_count > 0 {
            "warning_path".to_string()
        } else {
            "success_path".to_string()
        }
    });
    
    // 添加初始任务
    workflow.add_initial_task(|data: String| {
        let data_clone = data.clone();
        Box::pin(async move {
            println!("验证数据格式: {}", data_clone);
            if data_clone.len() < 3 {
                "ERROR: 数据太短".to_string()
            } else {
                "格式验证通过".to_string()
            }
        })
    });
    
    workflow.add_initial_task(|data: String| {
        let data_clone = data.clone();
        Box::pin(async move {
            println!("检查数据内容: {}", data_clone);
            if data_clone.contains("invalid") {
                "ERROR: 包含无效内容".to_string()
            } else if data_clone.contains("suspect") {
                "WARNING: 可疑内容".to_string()
            } else {
                "内容检查通过".to_string()
            }
        })
    });
    
    workflow.add_initial_task(|data: String| {
        let data_clone = data.clone();
        Box::pin(async move {
            println!("性能评估: {}", data_clone);
            if data_clone.len() > 100 {
                "WARNING: 数据量大，处理可能较慢".to_string()
            } else {
                "性能评估通过".to_string()
            }
        })
    });
    
    // 添加路径处理器
    workflow.add_path("error_path", |results: Vec<String>| {
        Box::pin(async move {
            println!("处理错误: {:?}", results);
            let errors: Vec<_> = results.iter()
                .filter(|r| r.contains("ERROR"))
                .collect();
            format!("错误处理完成，发现{}个错误", errors.len())
        })
    });
    
    workflow.add_path("warning_path", |results: Vec<String>| {
        Box::pin(async move {
            println!("处理警告: {:?}", results);
            let warnings: Vec<_> = results.iter()
                .filter(|r| r.contains("WARNING"))
                .collect();
            format!("警告处理完成，发现{}个警告", warnings.len())
        })
    });
    
    workflow.add_path("success_path", |results: Vec<String>| {
        Box::pin(async move {
            println!("处理成功: {:?}", results);
            "全部验证通过，处理成功".to_string()
        })
    });
    
    // 设置默认路径
    workflow.set_default_path(|results: Vec<String>| {
        Box::pin(async move {
            println!("未知路径处理: {:?}", results);
            "通过默认处理完成".to_string()
        })
    });
    
    // 执行工作流
    let result1 = workflow.execute("valid test data".to_string()).await;
    println!("结果1: {:?}\n", result1);
    
    let result2 = workflow.execute("ab".to_string()).await;
    println!("结果2: {:?}\n", result2);
    
    let result3 = workflow.execute("suspect data for testing".to_string()).await;
    println!("结果3: {:?}\n", result3);
    
    Ok(())
}
```

## 3. 结构模式

### 3.1 任意循环模式

**定义**：允许工作流中的活动或子流程重复执行任意次，直到达到某个条件为止。

**优点**：

- 支持动态迭代次数
- 适合需要重复尝试的场景
- 灵活处理不确定次数的操作

**缺点**：

- 可能陷入无限循环
- 需要明确的退出条件
- 可能导致性能问题

**使用异步实现**：

```rust
use async_trait::async_trait;
use std::future::Future;
use std::pin::Pin;
use std::time::Duration;
use tokio::time::sleep;

// 任意循环模式
#[async_trait]
pub trait ArbitraryLoopWorkflow<T> {
    // 执行循环体
    async fn execute_loop_body(&self, data: &mut T) -> bool;
    
    // 执行工作流
    async fn execute(&self, mut data: T) -> T {
        // 循环执行，直到循环体返回false
        while self.execute_loop_body(&mut data).await {
            // 可以在这里添加循环控制逻辑，如最大迭代次数等
        }
        data
    }
}

// 简单实现
pub struct SimpleArbitraryLoop<T, F>
where
    F: Fn(&mut T) -> Pin<Box<dyn Future<Output = bool> + Send>> + Send + Sync,
{
    loop_body: F,
    max_iterations: Option<usize>,
}

impl<T, F> SimpleArbitraryLoop<T, F>
where
    F: Fn(&mut T) -> Pin<Box<dyn Future<Output = bool> + Send>> + Send + Sync,
{
    pub fn new(loop_body: F) -> Self {
        Self {
            loop_body,
            max_iterations: None,
        }
    }
    
    pub fn with_max_iterations(mut self, max: usize) -> Self {
        self.max_iterations = Some(max);
        self
    }
}

#[async_trait]
impl<T, F> ArbitraryLoopWorkflow<T> for SimpleArbitraryLoop<T, F>
where
    T: Send + 'static,
    F: Fn(&mut T) -> Pin<Box<dyn Future<Output = bool> + Send>> + Send + Sync + 'static,
{
    async fn execute_loop_body(&self, data: &mut T) -> bool {
        (self.loop_body)(data).await
    }
    
    async fn execute(&self, mut data: T) -> T {
        let mut iterations = 0;
        
        // 循环执行，直到循环体返回false或达到最大迭代次数
        while self.execute_loop_body(&mut data).await {
            iterations += 1;
            
            // 检查是否达到最大迭代次数
            if let Some(max) = self.max_iterations {
                if iterations >= max {
                    println!("达到最大迭代次数: {}", max);
                    break;
                }
            }
        }
        
        data
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 示例1: 处理数据直到满足条件
    let processor = SimpleArbitraryLoop::new(|data: &mut Vec<i32>| {
        Box::pin(async move {
            // 如果集合中没有负数，则继续循环
            if data.iter().all(|&x| x >= 0) {
                // 模拟处理: 所有元素加1，并移除最后一个
                if !data.is_empty() {
                    for item in data.iter_mut() {
                        *item += 1;
                    }
                    data.pop();
                    println!("处理后: {:?}", data);
                    sleep(Duration::from_millis(500)).await;
                    return true; // 继续循环
                }
            }
            false // 结束循环
        })
    }).with_max_iterations(10);
    
    let input_data = vec![1, 2, 3, 4, 5];
    println!("初始数据: {:?}", input_data);
    let result = processor.execute(input_data).await;
    println!("最终结果: {:?}", result);
    
    // 示例2: 重试失败的操作
    let retry_logic = SimpleArbitraryLoop::new(|state: &mut (bool, u32, String)| {
        Box::pin(async move {
            let (success, attempts, message) = state;
            
            if *success || *attempts >= 5 {
                return false; // 已成功或已达到最大尝试次数
            }
            
            *attempts += 1;
            println!("尝试 #{}: {}", *attempts, message);
            
            // 模拟操作，成功率随着尝试次数增加
            sleep(Duration::from_millis(300)).await;
            let random_value = rand::random::<f32>();
            let success_threshold = 0.2 * (*attempts as f32);
            
            if random_value < success_threshold {
                println!("操作成功!");
                *success = true;
                *message = format!("成功，用了{}次尝试", *attempts);
                false // 成功，结束循环
            } else {
                println!("操作失败，将重试...");
                *message = format!("尝试#{}失败", *attempts);
                true // 失败，继续循环
            }
        })
    });
    
    let retry_state = (false, 0, "初始操作".to_string());
    let final_state = retry_logic.execute(retry_state).await;
    
    println!("\n最终状态:");
    println!("成功: {}", final_state.0);
    println!("尝试次数: {}", final_state.1);
    println!("消息: {}", final_state.2);
}
```

### 3.2 隐式终止模式

**定义**：工作流中的活动在所有分支都完成后自动终止，无需显式的终止点。

**优点**：

- 简化工作流定义
- 减少冗余的同步点
- 自然处理并行分支

**缺点**：

- 可能导致工作流结束不明确
- 调试困难
- 需要隐含地跟踪所有活动状态

**使用异步和多线程实现**：

```rust
use std::collections::HashSet;
use std::sync::{Arc, Mutex};
use tokio::sync::broadcast;
use tokio::task;
use futures::future::join_all;

// 工作单元
pub struct WorkItem<T, R> {
    id: String,
    dependencies: HashSet<String>,
    task: Box<dyn Fn(T) -> R + Send + Sync>,
}

impl<T, R> WorkItem<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new<I: Into<String>, F>(id: I, task: F) -> Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        Self {
            id: id.into(),
            dependencies: HashSet::new(),
            task: Box::new(task),
        }
    }
    
    pub fn with_dependencies<I: Into<String>>(mut self, deps: Vec<I>) -> Self {
        for dep in deps {
            self.dependencies.insert(dep.into());
        }
        self
    }
}

// 隐式终止工作流
pub struct ImplicitTerminationWorkflow<T, R> {
    work_items: HashMap<String, WorkItem<T, R>>,
    results: Arc<Mutex<HashMap<String, R>>>,
}

impl<T, R> ImplicitTerminationWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            work_items: HashMap::new(),
            results: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub fn add_work_item(&mut self, work_item: WorkItem<T, R>) {
        self.work_items.insert(work_item.id.clone(), work_item);
    }
    
    pub async fn execute(&self, input: T) -> HashMap<String, R>
    where
        R: Clone,
    {
        if self.work_items.is_empty() {
            return HashMap::new();
        }
        
        // 创建工作项完成通知通道
        let (completion_tx, _) = broadcast::channel(self.work_items.len());
        
        // 跟踪已完成的工作项
        let completed_items = Arc::new(Mutex::new(HashSet::new()));
        
        // 创建所有工作项的任务
        let mut tasks = Vec::new();
        
        for (id, work_item) in &self.work_items {
            let id = id.clone();
            let input = input.clone();
            let work_item = work_item.clone();
            let results = Arc::clone(&self.results);
            let completed = Arc::clone(&completed_items);
            let completion_tx = completion_tx.clone();
            let mut completion_rx = completion_tx.subscribe();
            
            // 创建任务
            let task = task::spawn(async move {
                // 等待所有依赖项完成
                let mut remaining_deps = work_item.dependencies.clone();
                
                while !remaining_deps.is_empty() {
                    if let Ok(completed_id) = completion_rx.recv().await {
                        remaining_deps.remove(&completed_id);
                    }
                }
                
                // 执行工作
                println!("执行工作项: {}", id);
                let result = (work_item.task)(input);
                
                // 保存结果
                {
                    let mut results = results.lock().unwrap();
                    results.insert(id.clone(), result);
                }
                
                // 标记完成并通知其他任务
                {
                    let mut completed = completed.lock().unwrap();
                    completed.insert(id.clone());
                }
                
                // 通知依赖此工作项的其他任务
                let _ = completion_tx.send(id.clone());
                
                id
            });
            
            tasks.push(task);
        }
        
        // 等待所有工作项完成
        join_all(tasks).await;
        
        // 返回所有结果
        Arc::try_unwrap(self.results)
            .unwrap()
            .into_inner()
            .unwrap()
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    use std::collections::HashMap;
    
    let mut workflow = ImplicitTerminationWorkflow::new();
    
    // 添加工作项
    workflow.add_work_item(
        WorkItem::new("start", |data: String| {
            println!("开始处理: {}", data);
            format!("开始: {}", data)
        })
    );
    
    workflow.add_work_item(
        WorkItem::new("validate", |data: String| {
            println!("验证数据: {}", data);
            format!("验证通过: {}", data)
        })
        .with_dependencies(vec!["start"])
    );
    
    workflow.add_work_item(
        WorkItem::new("process_a", |data: String| {
            println!("处理A: {}", data);
            tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
            format!("A处理结果: {}", data)
        })
        .with_dependencies(vec!["validate"])
    );
    
    workflow.add_work_item(
        WorkItem::new("process_b", |data: String| {
            println!("处理B: {}", data);
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
            format!("B处理结果: {}", data)
        })
        .with_dependencies(vec!["validate"])
    );
    
    workflow.add_work_item(
        WorkItem::new("finalize", |data: String| {
            println!("完成处理: {}", data);
            format!("完成: {}", data)
        })
        .with_dependencies(vec!["process_a", "process_b"])
    );
    
    // 执行工作流
    let results = workflow.execute("测试数据".to_string()).await;
    
    println!("\n所有结果:");
    for (id, result) in &results {
        println!("{}: {}", id, result);
    }
}
```

## 4. 多实例模式

```text
I need to continue with the multi-instance patterns (4.1 无同步多实例模式). 
I was cut off in the middle of explaining this pattern.
 I'll continue with the definition and implementation for 
 this and the remaining patterns.
```

### 4.1 无同步多实例模式

**定义**：创建同一活动的多个实例，这些实例相互独立，无需同步，可以并行执行。

**优点**：

- 高效并行处理大量相似任务
- 简单的并发模型
- 适合无依赖的批处理

**缺点**：

- 不能处理有依赖关系的任务
- 难以处理部分失败情况
- 资源使用可能不受控制

**使用多线程和异步实现**：

```rust
use std::sync::{Arc, Mutex};
use rayon::prelude::*;
use futures::future::join_all;

// 无同步多实例模式
pub struct MultipleInstancesWithoutSynchronization<T, R> {
    task: Box<dyn Fn(T) -> R + Send + Sync>,
    max_concurrent: Option<usize>,
}

impl<T, R> MultipleInstancesWithoutSynchronization<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F>(task: F) -> Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            max_concurrent: None,
        }
    }
    
    // 设置最大并发实例数
    pub fn with_max_concurrent(mut self, max: usize) -> Self {
        self.max_concurrent = Some(max);
        self
    }
    
    // 同步执行 - 使用rayon并行迭代器
    pub fn execute_sync(&self, inputs: Vec<T>) -> Vec<R>
    where
        T: Clone + Send + Sync,
        R: Send,
    {
        if let Some(max) = self.max_concurrent {
            // 限制并发数
            let results = Arc::new(Mutex::new(Vec::with_capacity(inputs.len())));
            let chunks = inputs.chunks(max);
            
            for chunk in chunks {
                let task_results: Vec<R> = chunk.par_iter()
                    .map(|input| (self.task)(input.clone()))
                    .collect();
                
                let mut results_guard = results.lock().unwrap();
                results_guard.extend(task_results);
            }
            
            Arc::try_unwrap(results).unwrap().into_inner().unwrap()
        } else {
            // 不限制并发数
            inputs.par_iter()
                .map(|input| (self.task)(input.clone()))
                .collect()
        }
    }
    
    // 异步执行
    pub async fn execute_async(&self, inputs: Vec<T>) -> Vec<R>
    where
        T: Clone,
        R: Send,
        T: Send,
    {
        if inputs.is_empty() {
            return Vec::new();
        }
        
        if let Some(max) = self.max_concurrent {
            // 限制并发数
            let mut all_results = Vec::with_capacity(inputs.len());
            
            for chunk in inputs.chunks(max) {
                let mut futures = Vec::with_capacity(chunk.len());
                
                for input in chunk {
                    let task = self.task.clone();
                    let input_clone = input.clone();
                    
                    let future = tokio::spawn(async move {
                        task(input_clone)
                    });
                    
                    futures.push(future);
                }
                
                let chunk_results = join_all(futures).await
                    .into_iter()
                    .filter_map(|r| r.ok())
                    .collect::<Vec<R>>();
                
                all_results.extend(chunk_results);
            }
            
            all_results
        } else {
            // 不限制并发数
            let mut futures = Vec::with_capacity(inputs.len());
            
            for input in inputs {
                let task = self.task.clone();
                
                let future = tokio::spawn(async move {
                    task(input)
                });
                
                futures.push(future);
            }
            
            join_all(futures).await
                .into_iter()
                .filter_map(|r| r.ok())
                .collect()
        }
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建处理实例
    let processor = MultipleInstancesWithoutSynchronization::new(|num: i32| {
        println!("处理数据: {}", num);
        std::thread::sleep(std::time::Duration::from_millis(100));
        num * num
    }).with_max_concurrent(4); // 最多同时处理4个实例
    
    // 准备输入数据
    let input_data: Vec<i32> = (1..=10).collect();
    
    // 同步执行
    println!("同步执行:");
    let sync_results = processor.execute_sync(input_data.clone());
    println!("同步结果: {:?}", sync_results);
    
    // 异步执行
    println!("\n异步执行:");
    let async_results = processor.execute_async(input_data).await;
    println!("异步结果: {:?}", async_results);
}
```

### 4.2 设计时多实例模式

**定义**：在工作流设计时确定需要创建的实例数量，即实例数是预先确定的。

**优点**：

- 实例数可以在设计时优化
- 便于资源规划
- 执行模式可预测

**缺点**：

- 缺乏运行时灵活性
- 不适应动态工作负载
- 可能导致资源浪费

**使用泛型和多线程实现**：

```rust
use std::sync::{Arc, Mutex};
use rayon::prelude::*;

// 设计时多实例模式
pub struct DesignTimeMultipleInstances<T, R, C> {
    task: Box<dyn Fn(T, C) -> R + Send + Sync>,
    instance_count: usize,
    context_provider: Box<dyn Fn(usize) -> C + Send + Sync>,
}

impl<T, R, C> DesignTimeMultipleInstances<T, R, C>
where
    T: Send + 'static,
    R: Send + 'static,
    C: Send + 'static,
{
    pub fn new<F, P>(task: F, instance_count: usize, context_provider: P) -> Self
    where
        F: Fn(T, C) -> R + Send + Sync + 'static,
        P: Fn(usize) -> C + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            instance_count,
            context_provider: Box::new(context_provider),
        }
    }
    
    pub fn execute(&self, input: T) -> Vec<R>
    where
        T: Clone + Send + Sync,
        C: Send + Sync,
        R: Send,
    {
        if self.instance_count == 0 {
            return Vec::new();
        }
        
        // 为每个实例创建上下文
        let contexts: Vec<C> = (0..self.instance_count)
            .map(|i| (self.context_provider)(i))
            .collect();
        
        // 并行执行所有实例
        (0..self.instance_count)
            .into_par_iter()
            .map(|i| {
                let context = &contexts[i];
                (self.task)(input.clone(), context.clone())
            })
            .collect()
    }
}

// 使用示例
fn main() {
    // 创建工作流，设计时确定3个实例
    let workflow = DesignTimeMultipleInstances::new(
        // 任务函数
        |data: String, context: (usize, String)| {
            let (instance_id, instance_name) = context;
            println!("实例 {} ({}): 处理数据 '{}'", instance_id, instance_name, data);
            
            // 模拟处理
            std::thread::sleep(std::time::Duration::from_millis(100 * (instance_id as u64 + 1)));
            
            format!("实例 {} ({}) 的结果: {}", instance_id, instance_name, data.to_uppercase())
        },
        // 实例数量
        3,
        // 上下文提供函数
        |i| (i, format!("实例类型-{}", ['A', 'B', 'C'][i % 3]))
    );
    
    // 执行工作流
    let results = workflow.execute("测试数据".to_string());
    
    println!("\n所有结果:");
    for result in results {
        println!("{}", result);
    }
}
```

### 4.3 运行时多实例模式

**定义**：实例的数量在工作流执行时动态确定，可以根据输入数据或运行时条件决定。

**优点**：

- 灵活适应不同的工作负载
- 根据实际需求创建实例
- 高效利用资源

**缺点**：

- 难以预测资源需求
- 可能导致系统过载
- 实现复杂度高

**使用异步和多线程实现**：

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;
use futures::future::join_all;

// 运行时多实例模式
pub struct RuntimeMultipleInstances<T, R, D> {
    task: Box<dyn Fn(D) -> R + Send + Sync>,
    get_instance_data: Box<dyn Fn(T) -> Vec<D> + Send + Sync>,
    max_concurrent: Option<usize>,
}

impl<T, R, D> RuntimeMultipleInstances<T, R, D>
where
    T: Send + 'static,
    R: Send + 'static,
    D: Send + 'static,
{
    pub fn new<F, G>(task: F, get_instance_data: G) -> Self
    where
        F: Fn(D) -> R + Send + Sync + 'static,
        G: Fn(T) -> Vec<D> + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            get_instance_data: Box::new(get_instance_data),
            max_concurrent: None,
        }
    }
    
    pub fn with_max_concurrent(mut self, max: usize) -> Self {
        self.max_concurrent = Some(max);
        self
    }
    
    pub async fn execute(&self, input: T) -> Vec<R>
    where
        D: Clone + Send,
        R: Send,
    {
        // 动态确定要处理的数据项
        let instances_data = (self.get_instance_data)(input);
        
        if instances_data.is_empty() {
            return Vec::new();
        }
        
        // 如果设置了并发限制，使用信号量控制
        if let Some(max) = self.max_concurrent {
            let semaphore = Arc::new(Semaphore::new(max));
            let mut tasks = Vec::with_capacity(instances_data.len());
            
            for data in instances_data {
                let task_fn = self.task.clone();
                let semaphore_clone = semaphore.clone();
                
                tasks.push(tokio::spawn(async move {
                    // 获取信号量许可
                    let _permit = semaphore_clone.acquire().await.unwrap();
                    task_fn(data)
                }));
            }
            
            join_all(tasks).await
                .into_iter()
                .filter_map(|r| r.ok())
                .collect()
        } else {
            // 不限制并发数
            let mut tasks = Vec::with_capacity(instances_data.len());
            
            for data in instances_data {
                let task_fn = self.task.clone();
                
                tasks.push(tokio::spawn(async move {
                    task_fn(data)
                }));
            }
            
            join_all(tasks).await
                .into_iter()
                .filter_map(|r| r.ok())
                .collect()
        }
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建工作流
    let workflow = RuntimeMultipleInstances::new(
        // 任务函数
        |item: (String, i32)| {
            let (name, value) = item;
            println!("处理项目: {} (值: {})", name, value);
            
            // 模拟处理时间与值成正比
            tokio::time::sleep(tokio::time::Duration::from_millis((value * 50) as u64)).await;
            
            format!("{}处理完成，结果: {}", name, value * value)
        },
        // 实例数据提供函数
        |input: Vec<(String, i32)>| {
            // 筛选出值大于0的项目
            input.into_iter()
                .filter(|(_, value)| *value > 0)
                .collect()
        }
    ).with_max_concurrent(3); // 最多3个并发实例
    
    // 准备输入数据
    let input_data = vec![
        ("项目A".to_string(), 5),
        ("项目B".to_string(), -2), // 会被过滤掉
        ("项目C".to_string(), 3),
        ("项目D".to_string(), 0),  // 会被过滤掉
        ("项目E".to_string(), 7),
        ("项目F".to_string(), 2),
        ("项目G".to_string(), 4),
    ];
    
    // 执行工作流
    let results = workflow.execute(input_data).await;
    
    println!("\n所有结果:");
    for result in results {
        println!("{}", result);
    }
}
```

### 4.4 无先验知识多实例模式

**定义**：处理一组在设计时和执行开始时都未知的项目集合，通常通过外部服务或系统动态获取。

**优点**：

- 高度灵活，适应未知数据源
- 能处理动态变化的需求
- 适合与外部系统交互

**缺点**：

- 实现复杂
- 难以预测性能和资源需求
- 需要处理外部依赖和异常

**使用异步和泛型实现**：

```rust
use async_trait::async_trait;
use futures::stream::{self, StreamExt};
use std::sync::Arc;
use tokio::sync::{mpsc, Semaphore};

// 数据源特征
#[async_trait]
pub trait DataSource<T> {
    async fn fetch_batch(&self, batch_size: usize) -> Vec<T>;
    async fn has_more(&self) -> bool;
}

// 无先验知识多实例模式
pub struct MultipleInstancesWithoutAPrioriKnowledge<T, R> {
    task: Box<dyn Fn(T) -> R + Send + Sync>,
    max_concurrent: usize,
    batch_size: usize,
}

impl<T, R> MultipleInstancesWithoutAPrioriKnowledge<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F>(task: F, max_concurrent: usize, batch_size: usize) -> Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        Self {
            task: Box::new(task),
            max_concurrent,
            batch_size,
        }
    }
    
    pub async fn execute<D>(&self, data_source: Arc<D>) -> Vec<R>
    where
        T: Send,
        R: Send,
        D: DataSource<T> + Send + Sync + 'static,
    {
        let (result_tx, mut result_rx) = mpsc::channel(self.max_concurrent);
        let semaphore = Arc::new(Semaphore::new(self.max_concurrent));
        
        // 启动后台处理任务
        let processor_handle = tokio::spawn(async move {
            let mut results = Vec::new();
            
            while let Some(result) = result_rx.recv().await {
                results.push(result);
            }
            
            results
        });
        
        // 循环获取批次数据并处理
        while data_source.has_more().await {
            let batch = data_source.fetch_batch(self.batch_size).await;
            
            if batch.is_empty() {
                continue;
            }
            
            // 处理一批数据
            let futures = batch.into_iter().map(|item| {
                let task = self.task.clone();
                let semaphore_clone = semaphore.clone();
                let result_tx_clone = result_tx.clone();
                
                async move {
                    // 获取信号量许可
                    let _permit = semaphore_clone.acquire().await.unwrap();
                    
                    // 执行任务
                    let result = task(item);
                    
                    // 发送结果
                    let _ = result_tx_clone.send(result).await;
                }
            });
            
            // 并发执行所有任务
            futures::future::join_all(futures).await;
        }
        
        // 关闭发送端，让接收端结束
        drop(result_tx);
        
        // 等待所有结果收集完毕
        processor_handle.await.unwrap()
    }
}

// 示例实现：模拟数据源
struct MockDataSource {
    data: Vec<String>,
    position: usize,
}

impl MockDataSource {
    fn new(items: Vec<String>) -> Self {
        Self {
            data: items,
            position: 0,
        }
    }
}

#[async_trait]
impl DataSource<String> for MockDataSource {
    async fn fetch_batch(&self, batch_size: usize) -> Vec<String> {
        let end = std::cmp::min(self.position + batch_size, self.data.len());
        let batch = self.data[self.position..end].to_vec();
        
        // 更新位置
        let mut_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mut_self.position = end;
        
        tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
        println!("获取数据批次，大小: {}", batch.len());
        
        batch
    }
    
    async fn has_more(&self) -> bool {
        self.position < self.data.len()
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建工作流
    let workflow = MultipleInstancesWithoutAPrioriKnowledge::new(
        // 任务函数
        |item: String| {
            println!("处理项目: {}", item);
            std::thread::sleep(std::time::Duration::from_millis(200));
            format!("处理结果: {}", item.to_uppercase())
        },
        3,   // 最大并发数
        2    // 批次大小
    );
    
    // 创建模拟数据源
    let data_source = Arc::new(MockDataSource::new(vec![
        "项目1".to_string(),
        "项目2".to_string(),
        "项目3".to_string(),
        "项目4".to_string(),
        "项目5".to_string(),
        "项目6".to_string(),
        "项目7".to_string(),
    ]));
    
    // 执行工作流
    let results = workflow.execute(data_source).await;
    
    println!("\n所有结果:");
    for result in results {
        println!("{}", result);
    }
}
```

## 5. 状态基础模式

### 5.1 延迟选择模式

**定义**：推迟选择执行路径的决策，直到工作流执行过程中的某个特定点。

**优点**：

- 基于最新信息做出决策
- 提高决策质量
- 适应动态变化的环境

**缺点**：

- 增加工作流复杂性
- 可能引入额外延迟
- 难以预测执行路径

**使用异步和泛型实现**：

```rust
use std::collections::HashMap;
use std::future::Future;
use std::pin::Pin;

// 延迟选择模式
pub struct DeferredChoiceWorkflow<T, I, R> {
    // 前置任务
    pre_task: Box<dyn Fn(T) -> I + Send + Sync>,
    
    // 决策函数：基于前置任务的结果选择路径
    decision_maker: Box<dyn Fn(&I) -> String + Send + Sync>,
    
    // 路径映射：路径ID -> 处理函数
    paths: HashMap<String, Box<dyn Fn(I) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync>>,
    
    // 默认路径
    default_path: Option<Box<dyn Fn(I) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync>>,
}

impl<T, I, R> DeferredChoiceWorkflow<T, I, R>
where
    T: Send + 'static,
    I: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F, D>(pre_task: F, decision_maker: D) -> Self
    where
        F: Fn(T) -> I + Send + Sync + 'static,
        D: Fn(&I) -> String + Send + Sync + 'static,
    {
        Self {
            pre_task: Box::new(pre_task),
            decision_maker: Box::new(decision_maker),
            paths: HashMap::new(),
            default_path: None,
        }
    }
    
    pub fn add_path<P, F>(&mut self, path_id: P, handler: F)
    where
        P: Into<String>,
        F: Fn(I) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync + 'static,
    {
        self.paths.insert(path_id.into(), Box::new(handler));
    }
    
    pub fn set_default_path<F>(&mut self, handler: F)
    where
        F: Fn(I) -> Pin<Box<dyn Future<Output = R> + Send>> + Send + Sync + 'static,
    {
        self.default_path = Some(Box::new(handler));
    }
    
    pub async fn execute(&self, input: T) -> Option<R> {
        // 执行前置任务
        let intermediate = (self.pre_task)(input);
        
        // 基于中间结果做出决策
        let path_id = (self.decision_maker)(&intermediate);
        
        // 选择并执行路径
        if let Some(handler) = self.paths.get(&path_id) {
            Some(handler(intermediate).await)
        } else if let Some(default_handler) = &self.default_path {
            Some(default_handler(intermediate).await)
        } else {
            None
        }
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建工作流
    let mut workflow = DeferredChoiceWorkflow::new(
        // 前置任务：处理并返回中间结果
        |request: HashMap<String, String>| {
            println!("处理初始请求...");
            
            // 模拟获取额外信息
            let mut enriched_request = request.clone();
            
            if let Some(user_id) = request.get("user_id") {
                // 模拟用户信息查询
                enriched_request.insert("user_type".to_string(), 
                    if user_id.parse::<i32>().unwrap_or(0) > 1000 {
                        "premium".to_string()
                    } else {
                        "standard".to_string()
                    }
                );
            }
            
            if let Some(amount) = request.get("amount") {
                let amount = amount.parse::<f64>().unwrap_or(0.0);
                
                // 根据金额确定风险级别
                let risk_level = if amount > 10000.0 {
                    "high"
                } else if amount > 1000.0 {
                    "medium"
                } else {
                    "low"
                };
                
                enriched_request.insert("risk_level".to_string(), risk_level.to_string());
            }
            
            println!("请求已处理和丰富：{:?}", enriched_request);
            enriched_request
        },
        
        // 决策函数：基于丰富后的数据选择路径
        |data: &HashMap<String, String>| {
            // 首先检查风险级别
            if let Some(risk) = data.get("risk_level") {
                if risk == "high" {
                    return "high_risk".to_string();
                }
            }
            
            // 然后检查用户类型
            if let Some(user_type) = data.get("user_type") {
                if user_type == "premium" {
                    return "premium_flow".to_string();
                }
            }
            
            // 默认路径
            "standard_flow".to_string()
        }
    );
    
    // 添加路径处理器
    workflow.add_path("high_risk", |data: HashMap<String, String>| {
        Box::pin(async move {
            println!("执行高风险处理流程...");
            tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
            format!("高风险请求已处理，要求进一步审查: {:?}", data)
        })
    });
    
    workflow.add_path("premium_flow", |data: HashMap<String, String>| {
        Box::pin(async move {
            println!("执行高级用户流程...");
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
            format!("高级用户请求已优先处理: {:?}", data)
        })
    });
    
    workflow.add_path("standard_flow", |data: HashMap<String, String>| {
        Box::pin(async move {
            println!("执行标准流程...");
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
            format!("标准请求已处理: {:?}", data)
        })
    });
    
    // 创建测试请求
    let request1 = {
        let mut request = HashMap::new();
        request.insert("user_id".to_string(), "1500".to_string());
        request.insert("amount".to_string(), "500".to_string());
        request
    };
    
    let request2 = {
        let mut request = HashMap::new();
        request.insert("user_id".to_string(), "500".to_string());
        request.insert("amount".to_string(), "15000".to_string());
        request
    };
    
    // 执行工作流
    println!("处理请求1:");
    let result1 = workflow.execute(request1).await;
    println!("结果: {:?}\n", result1);
    
    println!("处理请求2:");
    let result2 = workflow.execute(request2).await;
    println!("结果: {:?}", result2);
}
```

### 5.2 交错并行路由模式

**定义**：允许不同并行分支之间的活动以任意顺序交错执行，适合活动间没有严格顺序约束的场景。

**优点**：

- 最大化并行执行
- 充分利用系统资源
- 适应不确定的执行顺序

**缺点**：

- 导致复杂的执行顺序
- 难以调试和跟踪
- 可能引发并发问题

**使用多线程和异步实现**：

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use tokio::task;
use futures::future::join_all;
use rand::seq::SliceRandom;
use rand::thread_rng;

// 交错并行路由模式
pub struct InterleavedParallelRoutingWorkflow<T, R> {
    branches: Vec<Box<dyn Fn(T) -> Vec<Box<dyn Fn() -> R + Send>> + Send + Sync>>,
}

impl<T, R> InterleavedParallelRoutingWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            branches: Vec::new(),
        }
    }
    
    pub fn add_branch<F, G>(&mut self, branch_generator: F)
    where
        F: Fn(T) -> Vec<Box<dyn Fn() -> R + Send>> + Send + Sync + 'static,
    {
        self.branches.push(Box::new(branch_generator));
    }
    
    pub async fn execute(&self, input: T) -> Vec<R> {
        if self.branches.is_empty() {
            return Vec::new();
        }
        
        // 收集所有分支中的任务
        let mut all_tasks = Vec::new();
        
        for branch in &self.branches {
            let branch_tasks = branch(input.clone());
            all_tasks.extend(branch_tasks);
        }
        
        // 随机打乱任务顺序，模拟交错执行
        let mut rng = thread_rng();
        all_tasks.shuffle(&mut rng);
        
        // 使用通道收集结果
        let (tx, mut rx) = mpsc::channel(all_tasks.len());
        let results = Arc::new(Mutex::new(Vec::with_capacity(all_tasks.len())));
        
        // 启动结果收集器
        let results_clone = Arc::clone(&results);
        let collector = tokio::spawn(async move {
            while let Some(result) = rx.recv().await {
                let mut results = results_clone.lock().unwrap();
                results.push(result);
            }
        });
        
        // 交错执行所有任务
        let mut handles = Vec::new();
        
        for task in all_tasks {
            let tx = tx.clone();
            
            let handle = task::spawn_blocking(move || {
                // 执行任务
                let result = task();
                
                // 发送结果
                let _ = tokio::task::block_in_place(|| {
                    tokio::runtime::Handle::current().block_on(async {
                        tx.send(result).await
                    })
                });
            });
            
            handles.push(handle);
        }
        
        // 等待所有任务完成
        join_all(handles).await;
        drop(tx); // 关闭发送端，让接收端完成
        
        // 等待收集器完成
        collector.await.unwrap();
        
        // 返回所有结果
        Arc::try_unwrap(results)
            .unwrap()
            .into_inner()
            .unwrap()
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建工作流
    let mut workflow = InterleavedParallelRoutingWorkflow::new();
    
    // 添加第一个分支（处理用户数据）
    workflow.add_branch(|context: HashMap<String, String>| {
        let mut tasks = Vec::new();
        
        if let Some(user_id) = context.get("user_id") {
            let user_id = user_id.clone();
            
            // 任务1: 获取用户基本信息
            tasks.push(Box::new(move || {
                println!("获取用户基本信息: {}", user_id);
                std::thread::sleep(std::time::Duration::from_millis(300));
                format!("用户{}基本信息已获取", user_id)
            }) as Box<dyn Fn() -> String + Send>);
            
            let user_id2 = user_id.clone();
            // 任务2: 获取用户偏好
            tasks.push(Box::new(move || {
                println!("获取用户偏好: {}", user_id2);
                std::thread::sleep(std::time::Duration::from_millis(200));
                format!("用户{}偏好已获取", user_id2)
            }) as Box<dyn Fn() -> String + Send>);
        }
        
        tasks
    });
    
    // 添加第二个分支（处理订单数据）
    workflow.add_branch(|context: HashMap<String, String>| {
        let mut tasks = Vec::new();
        
        if let Some(order_id) = context.get("order_id") {
            let order_id = order_id.clone();
            
            // 任务1: 验证订单
            tasks.push(Box::new(move || {
                println!("验证订单: {}", order_id);
                std::thread::sleep(std::time::Duration::from_millis(150));
                format!("订单{}已验证", order_id)
            }) as Box<dyn Fn() -> String + Send>);
            
            let order_id2 = order_id.clone();
            // 任务2: 检查库存
            tasks.push(Box::new(move || {
                println!("检查库存: {}", order_id2);
                std::thread::sleep(std::time::Duration::from_millis(250));
                format!("订单{}库存已检查", order_id2)
            }) as Box<dyn Fn() -> String + Send>);
            
            let order_id3 = order_id.clone();
            // 任务3: 计算价格
            tasks.push(Box::new(move || {
                println!("计算价格: {}", order_id3);
                std::thread::sleep(std::time::Duration::from_millis(100));
                format!("订单{}价格已计算", order_id3)
            }) as Box<dyn Fn() -> String + Send>);
        }
        
        tasks
    });
    
    // 添加第三个分支（处理支付数据）
    workflow.add_branch(|context: HashMap<String, String>| {
        let mut tasks = Vec::new();
        
        if let Some(payment_id) = context.get("payment_id") {
            let payment_id = payment_id.clone();
            
            // 任务: 验证支付
            tasks.push(Box::new(move || {
                println!("验证支付: {}", payment_id);
                std::thread::sleep(std::time::Duration::from_millis(350));
                format!("支付{}已验证", payment_id)
            }) as Box<dyn Fn() -> String + Send>);
        }
        
        tasks
    });
    
    // 准备测试数据
    let mut context = HashMap::new();
    context.insert("user_id".to_string(), "U12345".to_string());
    context.insert("order_id".to_string(), "O98765".to_string());
    context.insert("payment_id".to_string(), "P54321".to_string());
    
    // 执行工作流
    println!("开始执行交错并行路由工作流...");
    let results = workflow.execute(context).await;
    
    println!("\n所有结果:");
    for (i, result) in results.iter().enumerate() {
        println!("{}. {}", i+1, result);
    }
}
```

### 5.3 里程碑模式

**定义**：使用里程碑标记工作流中的重要点，允许不同分支在达到里程碑时同步或触发新的活动。

**优点**：

- 为工作流提供检查点
- 允许不同分支间的松散同步
- 支持基于事件的触发

**缺点**:

- 增加工作流复杂性
- 可能导致隐式依赖
- 难以追踪里程碑状态

**使用异步和多线程实现**：

```text
Let me continue with the implementation of the Milestone pattern in Rust. 
The pattern allows workflows to have important checkpoints (milestones) that 
can be used to synchronize different branches or trigger new activities.
```

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use tokio::sync::{broadcast, Barrier};
use tokio::task;
use futures::future::join_all;

// 里程碑模式
pub struct MilestoneWorkflow {
    // 里程碑集合，用于跟踪已达成的里程碑
    milestones: Arc<Mutex<HashSet<String>>>,
    
    // 事件广播通道，用于通知里程碑达成
    milestone_sender: broadcast::Sender<String>,
}

impl MilestoneWorkflow {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(100);
        
        Self {
            milestones: Arc::new(Mutex::new(HashSet::new())),
            milestone_sender: sender,
        }
    }
    
    // 检查里程碑是否已达成
    pub fn is_milestone_reached(&self, milestone: &str) -> bool {
        let milestones = self.milestones.lock().unwrap();
        milestones.contains(milestone)
    }
    
    // 等待里程碑达成
    pub async fn wait_for_milestone(&self, milestone: &str) -> Result<(), tokio::sync::broadcast::error::RecvError> {
        // 如果里程碑已达成，直接返回
        if self.is_milestone_reached(milestone) {
            return Ok(());
        }
        
        // 订阅里程碑事件
        let mut receiver = self.milestone_sender.subscribe();
        
        // 等待里程碑事件
        loop {
            let event = receiver.recv().await?;
            if event == milestone {
                return Ok(());
            }
        }
    }
    
    // 达成里程碑
    pub fn reach_milestone(&self, milestone: &str) {
        let mut milestones = self.milestones.lock().unwrap();
        milestones.insert(milestone.to_string());
        
        // 广播里程碑达成事件
        let _ = self.milestone_sender.send(milestone.to_string());
    }
    
    // 添加基于里程碑的任务
    pub async fn execute_after_milestone<F, Fut, R>(&self, milestone: &str, task: F) -> Result<R, tokio::sync::broadcast::error::RecvError>
    where
        F: FnOnce() -> Fut + Send + 'static,
        Fut: futures::Future<Output = R> + Send + 'static,
        R: Send + 'static,
    {
        // 等待里程碑达成
        self.wait_for_milestone(milestone).await?;
        
        // 执行任务
        let task_result = task().await;
        Ok(task_result)
    }
    
    // 添加会达成里程碑的任务
    pub async fn execute_and_reach_milestone<F, Fut, R>(&self, task: F, milestone: &str) -> R
    where
        F: FnOnce() -> Fut + Send + 'static,
        Fut: futures::Future<Output = R> + Send + 'static,
        R: Send + 'static,
    {
        // 执行任务
        let result = task().await;
        
        // 达成里程碑
        self.reach_milestone(milestone);
        
        result
    }
    
    // 执行一系列任务，最后达成里程碑
    pub async fn execute_tasks_and_reach_milestone<F, Fut, R>(&self, tasks: Vec<F>, milestone: &str) -> Vec<R>
    where
        F: FnOnce() -> Fut + Send + 'static,
        Fut: futures::Future<Output = R> + Send + 'static,
        R: Send + 'static,
    {
        // 并行执行所有任务
        let mut futures = Vec::with_capacity(tasks.len());
        
        for task in tasks {
            futures.push(tokio::spawn(async move {
                task().await
            }));
        }
        
        // 等待所有任务完成
        let results = join_all(futures).await
            .into_iter()
            .filter_map(|r| r.ok())
            .collect::<Vec<_>>();
        
        // 达成里程碑
        self.reach_milestone(milestone);
        
        results
    }
}

// 使用示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建里程碑工作流
    let workflow = Arc::new(MilestoneWorkflow::new());
    
    // 开始处理订单
    println!("开始订单处理工作流...");
    
    // 并行执行初始任务
    let initial_tasks = vec![
        {
            let workflow = workflow.clone();
            move || async move {
                println!("验证客户信息...");
                tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
                println!("客户信息验证完成");
                workflow.reach_milestone("customer_verified");
                "客户信息已验证"
            }
        },
        {
            move || async move {
                println!("处理商品信息...");
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
                println!("商品信息处理完成");
                "商品信息已处理"
            }
        }
    ];
    
    // 执行初始任务
    let results = join_all(initial_tasks.into_iter().map(|t| tokio::spawn(t()))).await
        .into_iter()
        .filter_map(|r| r.ok())
        .collect::<Vec<_>>();
    
    println!("初始任务结果: {:?}", results);
    
    // 在库存检查里程碑后执行的任务
    let inventory_task = {
        let workflow = workflow.clone();
        tokio::spawn(async move {
            // 等待库存检查里程碑
            match workflow.wait_for_milestone("inventory_checked").await {
                Ok(()) => {
                    println!("库存已确认，准备发货...");
                    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
                    workflow.reach_milestone("shipping_prepared");
                    "发货准备就绪"
                },
                Err(e) => {
                    println!("等待库存检查时出错: {:?}", e);
                    "发货准备失败"
                }
            }
        })
    };
    
    // 在客户验证里程碑后执行的任务
    let payment_task = {
        let workflow = workflow.clone();
        tokio::spawn(async move {
            match workflow.wait_for_milestone("customer_verified").await {
                Ok(()) => {
                    println!("客户已验证，处理支付...");
                    tokio::time::sleep(tokio::time::Duration::from_millis(400)).await;
                    println!("支付处理完成");
                    workflow.reach_milestone("payment_processed");
                    "支付已处理"
                },
                Err(e) => {
                    println!("等待客户验证时出错: {:?}", e);
                    "支付处理失败"
                }
            }
        })
    };
    
    // 执行库存检查并达成里程碑
    let inventory_check = {
        let workflow = workflow.clone();
        tokio::spawn(async move {
            println!("检查库存...");
            tokio::time::sleep(tokio::time::Duration::from_millis(350)).await;
            println!("库存检查完成");
            workflow.reach_milestone("inventory_checked");
            "库存已检查"
        })
    };
    
    // 在支付处理和发货准备两个里程碑后执行的任务
    let finalize_task = {
        let workflow = workflow.clone();
        tokio::spawn(async move {
            // 等待支付处理里程碑
            if let Err(e) = workflow.wait_for_milestone("payment_processed").await {
                println!("等待支付处理时出错: {:?}", e);
                return "订单完成失败 - 支付问题";
            }
            
            // 等待发货准备里程碑
            if let Err(e) = workflow.wait_for_milestone("shipping_prepared").await {
                println!("等待发货准备时出错: {:?}", e);
                return "订单完成失败 - 发货问题";
            }
            
            println!("支付和发货都已就绪，完成订单...");
            tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
            println!("订单已完成");
            workflow.reach_milestone("order_completed");
            "订单已完成"
        })
    };
    
    // 等待所有任务完成
    let task_results = join_all(vec![inventory_task, payment_task, inventory_check, finalize_task]).await
        .into_iter()
        .filter_map(|r| r.ok())
        .collect::<Vec<_>>();
    
    // 处理最终结果
    println!("\n工作流执行结果:");
    for (i, result) in task_results.iter().enumerate() {
        println!("任务 {}: {}", i+1, result);
    }
    
    // 检查最终里程碑状态
    let milestones = workflow.milestones.lock().unwrap();
    println!("\n已达成的里程碑:");
    for milestone in milestones.iter() {
        println!("- {}", milestone);
    }
    
    Ok(())
}
```

## 6. 取消和触发模式

### 6.1 取消活动模式

**定义**：允许一个活动在工作流的另一部分指示时被取消，通常用于长时间运行的活动。

**优点**：

- 支持及时中止不必要的活动
- 节省资源
- 快速响应条件变化

**缺点**：

- 实现复杂，需要处理取消逻辑
- 可能导致部分完成状态
- 需要妥善清理资源

**使用异步和多线程实现**：

```rust
use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};
use tokio::task::JoinHandle;

// 取消活动模式
pub struct CancellableActivity<T, R> {
    // 取消标志
    cancel_flag: Arc<AtomicBool>,
    
    // 活动函数
    activity: Box<dyn Fn(T, Arc<AtomicBool>) -> JoinHandle<Option<R>> + Send + Sync>,
    
    // 取消处理函数
    on_cancel: Option<Box<dyn Fn() + Send + Sync>>,
}

impl<T, R> CancellableActivity<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    pub fn new<F>(activity: F) -> Self
    where
        F: Fn(T, Arc<AtomicBool>) -> JoinHandle<Option<R>> + Send + Sync + 'static,
    {
        Self {
            cancel_flag: Arc::new(AtomicBool::new(false)),
            activity: Box::new(activity),
            on_cancel: None,
        }
    }
    
    // 设置取消处理函数
    pub fn on_cancel<F>(mut self, handler: F) -> Self
    where
        F: Fn() + Send + Sync + 'static,
    {
        self.on_cancel = Some(Box::new(handler));
        self
    }
    
    // 启动活动
    pub fn start(&self, input: T) -> JoinHandle<Option<R>> {
        // 重置取消标志
        self.cancel_flag.store(false, Ordering::SeqCst);
        
        // 启动活动
        (self.activity)(input, self.cancel_flag.clone())
    }
    
    // 取消活动
    pub fn cancel(&self) {
        // 设置取消标志
        self.cancel_flag.store(true, Ordering::SeqCst);
        
        // 执行取消处理函数（如果有）
        if let Some(handler) = &self.on_cancel {
            handler();
        }
    }
    
    // 检查是否已取消
    pub fn is_cancelled(&self) -> bool {
        self.cancel_flag.load(Ordering::SeqCst)
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建可取消活动
    let activity = CancellableActivity::new(|data: Vec<u32>, cancel_flag: Arc<AtomicBool>| {
        tokio::spawn(async move {
            let mut result = Vec::new();
            
            println!("开始处理 {} 个项目...", data.len());
            
            for (i, item) in data.iter().enumerate() {
                // 定期检查取消标志
                if cancel_flag.load(Ordering::SeqCst) {
                    println!("活动被取消，已处理 {}/{} 个项目", i, data.len());
                    return None; // 返回None表示活动被取消
                }
                
                println!("处理项目 {}: {}", i+1, item);
                sleep(Duration::from_millis(500)).await; // 模拟耗时操作
                
                result.push(item * item);
            }
            
            println!("所有 {} 个项目处理完成", data.len());
            Some(result) // 返回Some表示活动完成
        })
    }).on_cancel(|| {
        println!("触发取消处理函数...");
        // 可以在这里进行资源清理等操作
    });
    
    // 准备测试数据
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // 启动活动
    let handle = activity.start(data.clone());
    
    // 模拟在处理过程中触发取消
    sleep(Duration::from_millis(1500)).await;
    println!("触发取消...");
    activity.cancel();
    
    // 等待活动结束
    let result = handle.await.unwrap();
    
    match result {
        Some(output) => println!("活动正常完成，结果: {:?}", output),
        None => println!("活动被取消，没有完整结果"),
    }
    
    // 第二次运行，不取消
    println!("\n再次运行，不取消...");
    let handle = activity.start(data.clone());
    
    // 等待活动完成
    let result = handle.await.unwrap();
    
    match result {
        Some(output) => println!("活动正常完成，结果: {:?}", output),
        None => println!("活动被取消，没有完整结果"),
    }
}
```

### 6.2 取消案例模式

**定义**：允许整个工作流案例在某些条件下被取消，并进行适当的清理和补偿操作。

**优点**：

- 支持整个工作流的取消
- 可以进行全面的资源清理
- 提供一致的取消机制

**缺点**：

- 需要处理复杂的分布式取消逻辑
- 可能需要执行补偿事务
- 取消状态传播复杂

**使用异步和状态管理实现**：

```rust
use std::collections::HashMap;
use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
use std::sync::Mutex;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tokio::time::{sleep, Duration};
use futures::future::join_all;

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum ActivityState {
    NotStarted,
    Running,
    Completed,
    Cancelled,
    Failed,
}

// 活动定义
pub struct WorkflowActivity<T, R> {
    id: String,
    state: Arc<Mutex<ActivityState>>,
    cancel_flag: Arc<AtomicBool>,
    compensation: Option<Box<dyn Fn() -> JoinHandle<()> + Send + Sync>>,
    activity: Box<dyn Fn(T, Arc<AtomicBool>) -> JoinHandle<Option<R>> + Send + Sync>,
}

impl<T, R> WorkflowActivity<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new<I, F>(id: I, activity: F) -> Self
    where
        I: Into<String>,
        F: Fn(T, Arc<AtomicBool>) -> JoinHandle<Option<R>> + Send + Sync + 'static,
    {
        Self {
            id: id.into(),
            state: Arc::new(Mutex::new(ActivityState::NotStarted)),
            cancel_flag: Arc::new(AtomicBool::new(false)),
            compensation: None,
            activity: Box::new(activity),
        }
    }
    
    // 设置补偿操作
    pub fn with_compensation<F>(mut self, compensation: F) -> Self
    where
        F: Fn() -> JoinHandle<()> + Send + Sync + 'static,
    {
        self.compensation = Some(Box::new(compensation));
        self
    }
    
    // 执行活动
    pub async fn execute(&self, input: T) -> Option<R> {
        // 更新状态为运行中
        {
            let mut state = self.state.lock().unwrap();
            *state = ActivityState::Running;
        }
        
        // 重置取消标志
        self.cancel_flag.store(false, Ordering::SeqCst);
        
        // 执行活动
        let handle = (self.activity)(input, self.cancel_flag.clone());
        let result = handle.await.unwrap();
        
        // 更新状态
        {
            let mut state = self.state.lock().unwrap();
            if self.cancel_flag.load(Ordering::SeqCst) {
                *state = ActivityState::Cancelled;
            } else if result.is_some() {
                *state = ActivityState::Completed;
            } else {
                *state = ActivityState::Failed;
            }
        }
        
        result
    }
    
    // 取消活动
    pub fn cancel(&self) {
        self.cancel_flag.store(true, Ordering::SeqCst);
    }
    
    // 执行补偿操作
    pub async fn compensate(&self) -> bool {
        if let Some(compensation) = &self.compensation {
            let state = *self.state.lock().unwrap();
            
            // 只有已完成或失败的活动需要补偿
            if state == ActivityState::Completed || state == ActivityState::Failed {
                println!("为活动 {} 执行补偿操作", self.id);
                let _ = compensation().await;
                return true;
            }
        }
        
        false
    }
    
    // 获取当前状态
    pub fn get_state(&self) -> ActivityState {
        *self.state.lock().unwrap()
    }
    
    // 获取ID
    pub fn get_id(&self) -> &str {
        &self.id
    }
}

// 取消案例模式
pub struct CancelCaseWorkflow<T, R> {
    activities: Vec<Arc<WorkflowActivity<T, R>>>,
    global_cancel_flag: Arc<AtomicBool>,
    workflow_state: Arc<Mutex<ActivityState>>,
}

impl<T, R> CancelCaseWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self {
            activities: Vec::new(),
            global_cancel_flag: Arc::new(AtomicBool::new(false)),
            workflow_state: Arc::new(Mutex::new(ActivityState::NotStarted)),
        }
    }
    
    // 添加活动
    pub fn add_activity(&mut self, activity: Arc<WorkflowActivity<T, R>>) {
        self.activities.push(activity);
    }
    
    // 取消整个工作流
    pub fn cancel(&self) {
        println!("取消整个工作流案例");
        self.global_cancel_flag.store(true, Ordering::SeqCst);
        
        // 取消所有活动
        for activity in &self.activities {
            activity.cancel();
        }
        
        // 更新工作流状态
        let mut state = self.workflow_state.lock().unwrap();
        *state = ActivityState::Cancelled;
    }
    
    // 执行工作流
    pub async fn execute(&self, input: T) -> HashMap<String, Option<R>> {
        if self.activities.is_empty() {
            return HashMap::new();
        }
        
        // 更新工作流状态为运行中
        {
            let mut state = self.workflow_state.lock().unwrap();
            *state = ActivityState::Running;
        }
        
        // 重置取消标志
        self.global_cancel_flag.store(false, Ordering::SeqCst);
        
        // 存储结果
        let mut results = HashMap::new();
        
        // 顺序执行活动
        for activity in &self.activities {
            // 检查全局取消标志
            if self.global_cancel_flag.load(Ordering::SeqCst) {
                break;
            }
            
            // 执行活动
            let id = activity.get_id().to_string();
            println!("执行活动: {}", id);
            let result = activity.execute(input.clone()).await;
            results.insert(id, result);
            
            // 检查活动是否被取消
            if activity.get_state() == ActivityState::Cancelled {
                // 活动被取消，整个工作流也应该取消
                self.cancel();
                break;
            }
        }
        
        // 如果工作流被取消，执行所有已完成活动的补偿操作
        if self.global_cancel_flag.load(Ordering::SeqCst) {
            println!("工作流被取消，执行补偿操作");
            let compensation_futures = self.activities.iter()
                .map(|activity| activity.compensate())
                .collect::<Vec<_>>();
            
            // 等待所有补偿操作完成
            join_all(compensation_futures).await;
        } else {
            // 更新工作流状态为完成
            let mut state = self.workflow_state.lock().unwrap();
            *state = ActivityState::Completed;
        }
        
        results
    }
    
    // 获取当前状态
    pub fn get_state(&self) -> ActivityState {
        *self.workflow_state.lock().unwrap()
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建工作流
    let mut workflow = CancelCaseWorkflow::new();
    
    // 创建活动1
    let activity1 = Arc::new(WorkflowActivity::new(
        "验证",
        |data: String, cancel_flag: Arc<AtomicBool>| {
            tokio::spawn(async move {
                println!("验证数据: {}", data);
                sleep(Duration::from_millis(300)).await;
                
                if cancel_flag.load(Ordering::SeqCst) {
                    println!("验证活动被取消");
                    return None;
                }
                
                println!("验证完成");
                Some(format!("验证结果: {}", data))
            })
        }
    ).with_compensation(|| {
        tokio::spawn(async {
            println!("执行验证的补偿操作");
            sleep(Duration::from_millis(100)).await;
            println!("验证补偿完成");
        })
    }));
    
    // 创建活动2
    let activity2 = Arc::new(WorkflowActivity::new(
        "处理",
        |data: String, cancel_flag: Arc<AtomicBool>| {
            tokio::spawn(async move {
                println!("处理数据: {}", data);
                sleep(Duration::from_millis(500)).await;
                
                if cancel_flag.load(Ordering::SeqCst) {
                    println!("处理活动被取消");
                    return None;
                }
                
                println!("处理完成");
                Some(format!("处理结果: {}", data))
            })
        }
    ).with_compensation(|| {
        tokio::spawn(async {
            println!("执行处理的补偿操作");
            sleep(Duration::from_millis(200)).await;
            println!("处理补偿完成");
        })
    }));
    
    // 创建活动3
    let activity3 = Arc::new(WorkflowActivity::new(
        "通知",
        |data: String, cancel_flag: Arc<AtomicBool>| {
            tokio::spawn(async move {
                println!("发送通知: {}", data);
                sleep(Duration::from_millis(400)).await;
                
                if cancel_flag.load(Ordering::SeqCst) {
                    println!("通知活动被取消");
                    return None;
                }
                
                println!("通知发送完成");
                Some(format!("通知结果: {}", data))
            })
        }
    ).with_compensation(|| {
        tokio::spawn(async {
            println!("执行通知的补偿操作");
            sleep(Duration::from_millis(150)).await;
            println!("通知补偿完成");
        })
    }));
    
    // 添加活动到工作流
    workflow.add_activity(activity1);
    workflow.add_activity(activity2);
    workflow.add_activity(activity3);
    
    // 准备测试数据
    let data = "测试数据".to_string();
    
    // 启动一个任务在工作流执行过程中取消它
    let workflow_ref = Arc::new(workflow);
    let workflow_cancel = workflow_ref.clone();
    
    tokio::spawn(async move {
        sleep(Duration::from_millis(800)).await;
        println!("\n触发工作流取消...");
        workflow_cancel.cancel();
    });
    
    // 执行工作流
    println!("开始执行工作流...");
    let results = workflow_ref.execute(data).await;
    
    // 显示最终状态和结果
    println!("\n工作流最终状态: {:?}", workflow_ref.get_state());
    println!("活动结果:");
    for (id, result) in &results {
        match result {
            Some(value) => println!("  {}: {}", id, value),
            None => println!("  {}: 未完成", id),
        }
    }
}
```

### 6.3 瞬时触发模式

**定义**：允许某个事件或条件的瞬时发生触发工作流中的活动，不需要持续满足该条件。

**优点**：

- 支持基于事件的工作流触发
- 即时响应外部事件
- 允许工作流元素解耦

**缺点**：

- 事件可能在不合适的时间触发
- 事件可能丢失
- 需要适当的事件处理机制

**使用异步实现**：

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::broadcast;
use tokio::task;
use tokio::time::{sleep, Duration};

// 事件定义
#[derive(Debug, Clone)]
pub struct Event {
    name: String,
    data: HashMap<String, String>,
}

impl Event {
    pub fn new<S: Into<String>>(name: S) -> Self {
        Self {
            name: name.into(),
            data: HashMap::new(),
        }
    }
    
    pub fn with_data<K, V>(mut self, key: K, value: V) -> Self
    where
        K: Into<String>,
        V: Into<String>,
    {
        self.data.insert(key.into(), value.into());
        self
    }
    
    pub fn get_name(&self) -> &str {
        &self.name
    }
    
    pub fn get_data(&self, key: &str) -> Option<&String> {
        self.data.get(key)
    }
}

// 瞬时触发模式
pub struct InstantTriggerWorkflow {
    // 事件发布者
    event_sender: broadcast::Sender<Event>,
    
    // 已注册的触发器
    triggers: Arc<Mutex<Vec<(String, Box<dyn Fn(Event) -> task::JoinHandle<()> + Send + Sync>)>>>,
}

impl InstantTriggerWorkflow {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(100);
        
        Self {
            event_sender: sender,
            triggers: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    // 发布事件
    pub fn publish_event(&self, event: Event) {
        println!("发布事件: {}", event.get_name());
        let _ = self.event_sender.send(event);
    }
    
    // 注册触发器
    pub fn register_trigger<F, Fut>(&self, event_name: &str, handler: F)
    where
        F: Fn(Event) -> Fut + Send + Sync + 'static,
        Fut: std::future::Future<Output = ()> + Send + 'static,
    {
        let event_name = event_name.to_string();
        let mut triggers = self.triggers.lock().unwrap();
        
        // 创建处理函数
        let trigger_fn = Box::new(move |event: Event| {
            task::spawn(handler(event))
        });
        
        triggers.push((event_name, trigger_fn));
    }
    
    // 启动工作流
    pub async fn start(&self) -> task::JoinHandle<()> {
        let mut receiver = self.event_sender.subscribe();
        let triggers = self.triggers.clone();
        
        task::spawn(async move {
            while let Ok(event) = receiver.recv().await {
                let triggers = triggers.lock().unwrap();
                
                // 查找匹配的触发器
                for (name, handler) in triggers.iter() {
                    if name == event.get_name() {
                        println!("触发处理器: {}", name);
                        handler(event.clone());
                    }
                }
            }
        })
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 创建工作流
    let workflow = Arc::new(InstantTriggerWorkflow::new());
    
    // 注册触发器
    workflow.register_trigger("新订单", |event: Event| async move {
        println!("处理新订单事件: {:?}", event);
        
        // 提取订单ID
        let order_id = event.get_data("order_id")
            .map(|s| s.as_str())
            .unwrap_or("未知");
            
        println!("开始处理订单: {}", order_id);
        sleep(Duration::from_millis(300)).await;
        println!("订单{}处理完成", order_id);
    });
    
    workflow.register_trigger("支付完成", |event: Event| async move {
        println!("处理支付完成事件: {:?}", event);
        
        // 提取支付信息
        let payment_id = event.get_data("payment_id")
            .map(|s| s.as_str())
            .unwrap_or("未知");
            
        let amount = event.get_data("amount")
            .map(|s| s.as_str())
            .unwrap_or("0");
            
        println!("处理支付 {}: {}", payment_id, amount);
        sleep(Duration::from_millis(200)).await;
        println!("支付{}处理完成", payment_id);
    });
    
    workflow.register_trigger("错误", |event: Event| async move {
        println!("处理错误事件: {:?}", event);
        
        // 提取错误信息
        let error_code = event.get_data("code")
            .map(|s| s.as_str())
            .unwrap_or("未知");
            
        let message = event.get_data("message")
            .map(|s| s.as_str())
            .unwrap_or("未知错误");
            
        println!("处理错误 {}: {}", error_code, message);
        sleep(Duration::from_millis(150)).await;
        println!("错误{}已记录", error_code);
    });
    
    // 启动工作流
    let _handle = workflow.start().await;
    
    // 发布一些事件
    sleep(Duration::from_millis(100)).await;
    workflow.publish_event(
        Event::new("新订单")
            .with_data("order_id", "ORD-12345")
            .with_data("customer", "张三")
    );
    
    sleep(Duration::from_millis(200)).await;
    workflow.publish_event(
        Event::new("支付完成")
            .with_data("payment_id", "PAY-6789")
            .with_data("order_id", "ORD-12345")
            .with_data("amount", "199.99")
    );
    
    sleep(Duration::from_millis(300)).await;
    workflow.publish_event(
        Event::new("错误")
            .with_data("code", "E-404")
            .with_data("message", "找不到产品")
    );
    
    // 等待所有事件处理完成
    sleep(Duration::from_millis(1000)).await;
    println!("工作流演示完成");
}
```

### 6.4 持久触发模式

**定义**：只有在某个条件持续满足的情况下，才会触发或允许工作流中的活动执行。

**优点**：

- 确保只在条件持续满足时执行活动
- 支持更严格的业务规则
- 防止波动条件导致不当执行

**缺点**：

- 可能导致活动长时间等待
- 需要持续监控条件
- 实现复杂度高

**使用异步和状态监控实现**：

```rust
use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
use tokio::sync::mpsc;
use tokio::task;
use tokio::time::{sleep, Duration, interval};
use futures::future::join_all;

// 持久条件定义
pub trait PersistentCondition: Send + Sync {
    fn is_satisfied(&self) -> bool;
    fn get_name(&self) -> &str;
}

// 简单条件实现
pub struct SimpleCondition {
    name: String,
    check_fn: Box<dyn Fn() -> bool + Send + Sync>,
}

impl SimpleCondition {
    pub fn new<S, F>(name: S, check_fn: F) -> Self
    where
        S: Into<String>,
        F: Fn() -> bool + Send + Sync + 'static,
    {
        Self {
            name: name.into(),
            check_fn: Box::new(check_fn),
        }
    }
}

impl PersistentCondition for SimpleCondition {
    fn is_satisfied(&self) -> bool {
        (self.check_fn)()
    }
    
    fn get_name(&self) -> &str {
        &self.name
    }
}

// 持久触发活动
pub struct PersistentlyTriggeredActivity<T, R> {
    id: String,
    activity: Box<dyn Fn(T) -> task::JoinHandle<R> + Send + Sync>,
    condition: Arc<dyn PersistentCondition>,
    check_interval: Duration,
    min_satisfaction_duration: Duration,
}

/*
看起来在持久触发模式的代码中被截断了。
我需要继续实现这个类，并且添加其余的内容。
接下来会完成PersistentlyTriggeredActivity的实现，然后添加使用示例。
*/

impl<T, R> PersistentlyTriggeredActivity<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new<I, F>(id: I, activity: F, condition: Arc<dyn PersistentCondition>) -> Self
    where
        I: Into<String>,
        F: Fn(T) -> task::JoinHandle<R> + Send + Sync + 'static,
    {
        Self {
            id: id.into(),
            activity: Box::new(activity),
            condition,
            check_interval: Duration::from_millis(100),
            min_satisfaction_duration: Duration::from_millis(1000),
        }
    }
    
    // 设置检查间隔
    pub fn with_check_interval(mut self, interval: Duration) -> Self {
        self.check_interval = interval;
        self
    }
    
    // 设置最小满足持续时间
    pub fn with_min_satisfaction_duration(mut self, duration: Duration) -> Self {
        self.min_satisfaction_duration = duration;
        self
    }
    
    // 执行活动（仅当条件持续满足时）
    pub async fn execute(&self, input: T) -> Option<R> {
        println!("等待条件 '{}' 持续满足 {:?}...", 
                 self.condition.get_name(), 
                 self.min_satisfaction_duration);
        
        // 检查条件是否持续满足
        let mut satisfied_since = None;
        let mut interval_timer = interval(self.check_interval);
        
        loop {
            interval_timer.tick().await;
            
            if self.condition.is_satisfied() {
                // 条件满足
                if satisfied_since.is_none() {
                    // 开始计时
                    satisfied_since = Some(std::time::Instant::now());
                    println!("条件 '{}' 开始满足", self.condition.get_name());
                }
                
                // 检查是否已经持续满足足够长时间
                if let Some(start_time) = satisfied_since {
                    if start_time.elapsed() >= self.min_satisfaction_duration {
                        println!("条件 '{}' 已持续满足 {:?}, 开始执行活动", 
                                 self.condition.get_name(), 
                                 start_time.elapsed());
                        break;
                    }
                }
            } else {
                // 条件不满足，重置计时
                if satisfied_since.is_some() {
                    println!("条件 '{}' 不再满足，重置计时", self.condition.get_name());
                    satisfied_since = None;
                }
            }
        }
        
        // 执行活动
        println!("开始执行活动 '{}'", self.id);
        let handle = (self.activity)(input);
        match handle.await {
            Ok(result) => {
                println!("活动 '{}' 执行完成", self.id);
                Some(result)
            }
            Err(e) => {
                println!("活动 '{}' 执行失败: {:?}", self.id, e);
                None
            }
        }
    }
}

// 持久触发工作流
pub struct PersistentTriggerWorkflow {
    activities: Vec<Box<dyn Fn() -> task::JoinHandle<()> + Send + Sync>>,
}

impl PersistentTriggerWorkflow {
    pub fn new() -> Self {
        Self {
            activities: Vec::new(),
        }
    }
    
    // 添加持久触发活动
    pub fn add_activity<T, R, F>(&mut self, 
                                 activity: Arc<PersistentlyTriggeredActivity<T, R>>, 
                                 input_provider: F)
    where
        T: Clone + Send + 'static,
        R: Send + 'static,
        F: Fn() -> T + Send + Sync + 'static,
    {
        let activity_fn = Box::new(move || {
            let activity = activity.clone();
            let input = input_provider();
            
            task::spawn(async move {
                let _ = activity.execute(input).await;
            })
        });
        
        self.activities.push(activity_fn);
    }
    
    // 启动工作流
    pub async fn execute(&self) -> Vec<task::JoinHandle<()>> {
        self.activities
            .iter()
            .map(|activity| activity())
            .collect()
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    // 共享资源状态
    let system_ready = Arc::new(AtomicBool::new(false));
    let database_available = Arc::new(AtomicBool::new(false));
    
    // 创建条件
    let system_ready_condition = Arc::new(SimpleCondition::new(
        "系统就绪",
        {
            let flag = system_ready.clone();
            move || flag.load(Ordering::SeqCst)
        }
    ));
    
    let database_condition = Arc::new(SimpleCondition::new(
        "数据库可用",
        {
            let flag = database_available.clone();
            move || flag.load(Ordering::SeqCst)
        }
    ));
    
    // 创建活动
    let data_processing_activity = Arc::new(
        PersistentlyTriggeredActivity::new(
            "数据处理",
            |data: String| {
                tokio::spawn(async move {
                    println!("处理数据: {}", data);
                    sleep(Duration::from_millis(500)).await;
                    println!("数据处理完成: {}", data);
                    format!("处理结果: {}", data.to_uppercase())
                })
            },
            system_ready_condition.clone()
        )
        .with_min_satisfaction_duration(Duration::from_millis(2000))
    );
    
    let backup_activity = Arc::new(
        PersistentlyTriggeredActivity::new(
            "数据备份",
            |_: ()| {
                tokio::spawn(async {
                    println!("执行数据备份...");
                    sleep(Duration::from_millis(800)).await;
                    println!("数据备份完成");
                    "备份成功"
                })
            },
            database_condition.clone()
        )
        .with_min_satisfaction_duration(Duration::from_millis(3000))
    );
    
    // 创建工作流
    let mut workflow = PersistentTriggerWorkflow::new();
    
    // 添加活动
    workflow.add_activity(
        data_processing_activity.clone(),
        || "示例数据".to_string()
    );
    
    workflow.add_activity(
        backup_activity.clone(),
        || ()
    );
    
    // 启动工作流
    let activity_handles = workflow.execute().await;
    
    // 模拟条件变化
    tokio::spawn(async move {
        // 系统准备就绪
        sleep(Duration::from_millis(500)).await;
        println!("系统开始就绪");
        system_ready.store(true, Ordering::SeqCst);
        
        // 系统临时不可用
        sleep(Duration::from_millis(1000)).await;
        println!("系统临时不可用");
        system_ready.store(false, Ordering::SeqCst);
        
        // 系统恢复并保持就绪
        sleep(Duration::from_millis(500)).await;
        println!("系统恢复并保持就绪");
        system_ready.store(true, Ordering::SeqCst);
        
        // 数据库变为可用
        sleep(Duration::from_millis(2000)).await;
        println!("数据库变为可用");
        database_available.store(true, Ordering::SeqCst);
    });
    
    // 等待所有活动完成
    join_all(activity_handles).await;
    
    println!("工作流演示完成");
}
```

## 7. 模式组合应用

### 7.1 订单处理工作流

下面是一个综合案例，结合多种工作流模式实现订单处理系统：

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex, atomic::{AtomicBool, Ordering}};
use tokio::sync::{mpsc, broadcast, Barrier};
use tokio::task;
use tokio::time::{sleep, Duration};
use futures::future::join_all;
use async_trait::async_trait;
use serde::{Serialize, Deserialize};

// 订单结构
#[derive(Clone, Debug, Serialize, Deserialize)]
struct Order {
    id: String,
    customer_id: String,
    items: Vec<OrderItem>,
    total_amount: f64,
    payment_method: String,
    shipping_address: Address,
    status: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct OrderItem {
    product_id: String,
    quantity: i32,
    price: f64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct Address {
    street: String,
    city: String,
    country: String,
    postal_code: String,
}

// 事件定义
#[derive(Clone, Debug)]
struct OrderEvent {
    order_id: String,
    event_type: String,
    data: HashMap<String, String>,
}

// 工作流状态
#[derive(Debug, PartialEq, Eq, Clone)]
enum WorkflowStatus {
    NotStarted,
    Running,
    Completed,
    Failed,
    Cancelled,
}

// 活动结果
#[derive(Clone, Debug)]
enum ActivityResult {
    Success(String),
    Failure(String),
    Skipped,
    Cancelled,
}

// 活动接口
#[async_trait]
trait OrderActivity: Send + Sync {
    fn get_id(&self) -> &str;
    fn get_dependencies(&self) -> &[String];
    async fn execute(&self, order: Arc<Mutex<Order>>, cancel_flag: Arc<AtomicBool>) -> ActivityResult;
    async fn compensate(&self, order: Arc<Mutex<Order>>) -> ActivityResult;
}

// 订单处理工作流
struct OrderProcessingWorkflow {
    activities: HashMap<String, Arc<dyn OrderActivity>>,
    dependencies: HashMap<String, HashSet<String>>,
    status: Arc<Mutex<WorkflowStatus>>,
    event_sender: broadcast::Sender<OrderEvent>,
    cancel_flag: Arc<AtomicBool>,
}

impl OrderProcessingWorkflow {
    fn new() -> Self {
        let (sender, _) = broadcast::channel(100);
        
        Self {
            activities: HashMap::new(),
            dependencies: HashMap::new(),
            status: Arc::new(Mutex::new(WorkflowStatus::NotStarted)),
            event_sender: sender,
            cancel_flag: Arc::new(AtomicBool::new(false)),
        }
    }
    
    // 添加活动
    fn add_activity(&mut self, activity: Arc<dyn OrderActivity>) {
        let id = activity.get_id().to_string();
        let deps = activity.get_dependencies().to_vec();
        
        // 添加依赖关系
        let mut activity_deps = HashSet::new();
        for dep in deps {
            activity_deps.insert(dep);
        }
        
        self.dependencies.insert(id.clone(), activity_deps);
        self.activities.insert(id, activity);
    }
    
    // 发布事件
    fn publish_event(&self, event: OrderEvent) {
        let _ = self.event_sender.send(event);
    }
    
    // 订阅事件
    fn subscribe_events(&self) -> broadcast::Receiver<OrderEvent> {
        self.event_sender.subscribe()
    }
    
    // 取消工作流
    fn cancel(&self) {
        let mut status = self.status.lock().unwrap();
        if *status == WorkflowStatus::Running {
            *status = WorkflowStatus::Cancelled;
            self.cancel_flag.store(true, Ordering::SeqCst);
            println!("工作流已请求取消");
        }
    }
    
    // 获取工作流状态
    fn get_status(&self) -> WorkflowStatus {
        self.status.lock().unwrap().clone()
    }
    
    // 执行工作流
    async fn execute(&self, order: Order) -> Result<Order, String> {
        // 更新状态
        {
            let mut status = self.status.lock().unwrap();
            if *status != WorkflowStatus::NotStarted {
                return Err("工作流已开始执行".to_string());
            }
            *status = WorkflowStatus::Running;
        }
        
        // 重置取消标志
        self.cancel_flag.store(false, Ordering::SeqCst);
        
        // 创建可变订单
        let order = Arc::new(Mutex::new(order));
        
        // 查找没有依赖的活动作为起始点
        let mut ready_activities = Vec::new();
        for (id, deps) in &self.dependencies {
            if deps.is_empty() {
                if let Some(activity) = self.activities.get(id) {
                    ready_activities.push(activity.clone());
                }
            }
        }
        
        // 创建完成的活动集合
        let completed_activities = Arc::new(Mutex::new(HashSet::new()));
        
        // 创建执行结果
        let results = Arc::new(Mutex::new(HashMap::new()));
        
        // 递归执行所有活动
        async fn execute_activities(
            workflow: &OrderProcessingWorkflow,
            activities: Vec<Arc<dyn OrderActivity>>,
            order: Arc<Mutex<Order>>,
            completed: Arc<Mutex<HashSet<String>>>,
            results: Arc<Mutex<HashMap<String, ActivityResult>>>,
            cancel_flag: Arc<AtomicBool>,
        ) -> Result<(), String> {
            // 检查工作流是否已取消
            if cancel_flag.load(Ordering::SeqCst) {
                return Err("工作流已取消".to_string());
            }
            
            if activities.is_empty() {
                return Ok(());
            }
            
            // 并行执行当前批次的活动
            let mut handles = Vec::new();
            
            for activity in &activities {
                let activity_id = activity.get_id().to_string();
                let activity = activity.clone();
                let order = order.clone();
                let completed = completed.clone();
                let results = results.clone();
                let cancel_flag = cancel_flag.clone();
                
                let handle = tokio::spawn(async move {
                    let result = activity.execute(order.clone(), cancel_flag).await;
                    
                    // 更新结果
                    {
                        let mut results = results.lock().unwrap();
                        results.insert(activity_id.clone(), result.clone());
                    }
                    
                    // 更新完成活动集合
                    if matches!(result, ActivityResult::Success(_)) {
                        let mut completed = completed.lock().unwrap();
                        completed.insert(activity_id.clone());
                    }
                    
                    (activity_id, result)
                });
                
                handles.push(handle);
            }
            
            // 等待所有活动完成
            let results_vec = join_all(handles).await
                .into_iter()
                .filter_map(|r| r.ok())
                .collect::<Vec<_>>();
            
            // 发布活动完成事件
            for (id, result) in &results_vec {
                let event_type = match result {
                    ActivityResult::Success(_) => "活动成功",
                    ActivityResult::Failure(_) => "活动失败",
                    ActivityResult::Skipped => "活动跳过",
                    ActivityResult::Cancelled => "活动取消",
                };
                
                workflow.publish_event(OrderEvent {
                    order_id: {
                        let order = order.lock().unwrap();
                        order.id.clone()
                    },
                    event_type: event_type.to_string(),
                    data: {
                        let mut data = HashMap::new();
                        data.insert("activity_id".to_string(), id.clone());
                        data
                    },
                });
            }
            
            // 检查是否有失败的活动
            if results_vec.iter().any(|(_, result)| matches!(result, ActivityResult::Failure(_))) {
                // 执行补偿操作
                return Err("某些活动失败，需要补偿".to_string());
            }
            
            // 检查工作流是否已取消
            if cancel_flag.load(Ordering::SeqCst) {
                return Err("工作流已取消".to_string());
            }
            
            // 查找下一批可执行的活动
            let completed = completed.lock().unwrap();
            let mut next_activities = Vec::new();
            
            for (id, deps) in &workflow.dependencies {
                // 跳过已完成的活动
                if completed.contains(id) {
                    continue;
                }
                
                // 检查依赖是否全部满足
                let all_deps_completed = deps.iter()
                    .all(|dep| completed.contains(dep));
                
                if all_deps_completed {
                    if let Some(activity) = workflow.activities.get(id) {
                        next_activities.push(activity.clone());
                    }
                }
            }
            
            // 递归执行下一批活动
            if !next_activities.is_empty() {
                execute_activities(
                    workflow,
                    next_activities,
                    order,
                    Arc::clone(&completed),
                    Arc::clone(&results),
                    cancel_flag,
                ).await?;
            }
            
            Ok(())
        }
        
        // 开始执行活动
        let result = execute_activities(
            self,
            ready_activities,
            order.clone(),
            completed_activities.clone(),
            results.clone(),
            self.cancel_flag.clone(),
        ).await;
        
        // 更新工作流状态
        {
            let mut status = self.status.lock().unwrap();
            match result {
                Ok(_) => *status = WorkflowStatus::Completed,
                Err(_) => *status = if self.cancel_flag.load(Ordering::SeqCst) {
                    WorkflowStatus::Cancelled
                } else {
                    WorkflowStatus::Failed
                },
            }
        }
        
        // 如果发生错误，执行补偿操作
        if let Err(err) = result {
            println!("工作流执行失败: {}", err);
            
            // 查找已完成的活动，并按相反顺序执行补偿
            let completed = completed_activities.lock().unwrap();
            let mut compensation_activities = Vec::new();
            
            for id in completed.iter() {
                if let Some(activity) = self.activities.get(id) {
                    compensation_activities.push(activity.clone());
                }
            }
            
            // 按相反顺序执行补偿
            compensation_activities.reverse();
            
            for activity in compensation_activities {
                println!("执行补偿操作: {}", activity.get_id());
                let _ = activity.compensate(order.clone()).await;
            }
            
            return Err(err);
        }
        
        // 返回最终订单
        let final_order = {
            let order = order.lock().unwrap();
            order.clone()
        };
        
        Ok(final_order)
    }
}

// 具体活动实现示例
struct ValidateOrderActivity;

#[async_trait]
impl OrderActivity for ValidateOrderActivity {
    fn get_id(&self) -> &str {
        "validate_order"
    }
    
    fn get_dependencies(&self) -> &[String] {
        &[]
    }
    
    async fn execute(&self, order: Arc<Mutex<Order>>, cancel_flag: Arc<AtomicBool>) -> ActivityResult {
        println!("验证订单...");
        sleep(Duration::from_millis(300)).await;
        
        if cancel_flag.load(Ordering::SeqCst) {
            return ActivityResult::Cancelled;
        }
        
        let order_id = {
            let order = order.lock().unwrap();
            order.id.clone()
        };
        
        // 模拟验证逻辑
        ActivityResult::Success(format!("订单{}验证成功", order_id))
    }
    
    async fn compensate(&self, _: Arc<Mutex<Order>>) -> ActivityResult {
        // 验证不需要补偿
        ActivityResult::Success("无需补偿".to_string())
    }
}

struct ReserveInventoryActivity;

#[async_trait]
impl OrderActivity for ReserveInventoryActivity {
    fn get_id(&self) -> &str {
        "reserve_inventory"
    }
    
    fn get_dependencies(&self) -> &[String] {
        &["validate_order".to_string()]
    }
    
    async fn execute(&self, order: Arc<Mutex<Order>>, cancel_flag: Arc<AtomicBool>) -> ActivityResult {
        println!("预留库存...");
        sleep(Duration::from_millis(500)).await;
        
        if cancel_flag.load(Ordering::SeqCst) {
            return ActivityResult::Cancelled;
        }
        
        // 获取订单ID和项目
        let (order_id, items) = {
            let order = order.lock().unwrap();
            (order.id.clone(), order.items.clone())
        };
        
        // 模拟库存预留
        println!("为订单{}预留了{}个商品", order_id, items.len());
        
        ActivityResult::Success(format!("订单{}库存预留成功", order_id))
    }
    
    async fn compensate(&self, order: Arc<Mutex<Order>>) -> ActivityResult {
        println!("释放库存...");
        sleep(Duration::from_millis(300)).await;
        
        let order_id = {
            let order = order.lock().unwrap();
            order.id.clone()
        };
        
        ActivityResult::Success(format!("订单{}库存已释放", order_id))
    }
}

struct ProcessPaymentActivity;

#[async_trait]
impl OrderActivity for ProcessPaymentActivity {
    fn get_id(&self) -> &str {
        "process_payment"
    }
    
    fn get_dependencies(&self) -> &[String] {
        &["validate_order".to_string()]
    }
    
    async fn execute(&self, order: Arc<Mutex<Order>>, cancel_flag: Arc<AtomicBool>) -> ActivityResult {
        println!("处理支付...");
        sleep(Duration::from_millis(700)).await;
        
        if cancel_flag.load(Ordering::SeqCst) {
            return ActivityResult::Cancelled;
        }
        
        // 获取订单数据
        let (order_id, amount, method) = {
            let order = order.lock().unwrap();
            (order.id.clone(), order.total_amount, order.payment_method.clone())
        };
        
        // 模拟支付处理
        println!("使用{}方式处理订单{}的支付，金额: {}", method, order_id, amount);
        
        // 更新订单状态
        {
            let mut order = order.lock().unwrap();
            order.status = "已付款".to_string();
        }
        
        ActivityResult::Success(format!("订单{}支付处理成功", order_id))
    }
    
    async fn compensate(&self, order: Arc<Mutex<Order>>) -> ActivityResult {
        println!("退款...");
        sleep(Duration::from_millis(500)).await;
        
        let (order_id, amount) = {
            let order = order.lock().unwrap();
            (order.id.clone(), order.total_amount)
        };
        
        println!("为订单{}退款: {}", order_id, amount);
        
        // 更新订单状态
        {
            let mut order = order.lock().unwrap();
            order.status = "已退款".to_string();
        }
        
        ActivityResult::Success(format!("订单{}已退款", order_id))
    }
}

struct PrepareShippingActivity;

#[async_trait]
impl OrderActivity for PrepareShippingActivity {
    fn get_id(&self) -> &str {
        "prepare_shipping"
    }
    
    fn get_dependencies(&self) -> &[String] {
        &["reserve_inventory".to_string(), "process_payment".to_string()]
    }
    
    async fn execute(&self, order: Arc<Mutex<Order>>, cancel_flag: Arc<AtomicBool>) -> ActivityResult {
        println!("准备发货...");
        sleep(Duration::from_millis(600)).await;
        
        if cancel_flag.load(Ordering::SeqCst) {
            return ActivityResult::Cancelled;
        }
        
        // 获取订单信息
        let (order_id, address) = {
            let order = order.lock().unwrap();
            (order.id.clone(), order.shipping_address.clone())
        };
        
        // 模拟准备发货
        println!("为订单{}准备发货到: {}, {}, {}", 
                 order_id, 
                 address.street,
                 address.city,
                 address.country);
        
        // 更新订单状态
        {
            let mut order = order.lock().unwrap();
            order.status = "准备发货".to_string();
        }
        
        ActivityResult::Success(format!("订单{}发货准备完成", order_id))
    }
    
    async fn compensate(&self, order: Arc<Mutex<Order>>) -> ActivityResult {
        println!("取消发货准备...");
        sleep(Duration::from_millis(300)).await;
        
        let order_id = {
            let order = order.lock().unwrap();
            order.id.clone()
        };
        
        // 更新订单状态
        {
            let mut order = order.lock().unwrap();
            order.status = "发货已取消".to_string();
        }
        
        ActivityResult::Success(format!("订单{}发货准备已取消", order_id))
    }
}

struct SendNotificationActivity;

#[async_trait]
impl OrderActivity for SendNotificationActivity {
    fn get_id(&self) -> &str {
        "send_notification"
    }
    
    fn get_dependencies(&self) -> &[String] {
        &["prepare_shipping".to_string()]
    }
    
    async fn execute(&self, order: Arc<Mutex<Order>>, cancel_flag: Arc<AtomicBool>) -> ActivityResult {
        println!("发送通知...");
        sleep(Duration::from_millis(200)).await;
        
        if cancel_flag.load(Ordering::SeqCst) {
            return ActivityResult::Cancelled;
        }
        
        // 获取订单信息
        let (order_id, customer_id) = {
            let order = order.lock().unwrap();
            (order.id.clone(), order.customer_id.clone())
        };
        
        // 模拟发送通知
        println!("向客户{}发送订单{}的通知", customer_id, order_id);
        
        // 更新订单状态
        {
            let mut order = order.lock().unwrap();
            order.status = "已通知".to_string();
        }
        
        ActivityResult::Success(format!("订单{}通知已发送", order_id))
    }
    
    async fn compensate(&self, _: Arc<Mutex<Order>>) -> ActivityResult {
        // 通知不需要补偿
        ActivityResult::Success("无需补偿".to_string())
    }
}

// 使用示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建工作流
    let mut workflow = OrderProcessingWorkflow::new();
    
    // 添加活动
    workflow.add_activity(Arc::new(ValidateOrderActivity));
    workflow.add_activity(Arc::new(ReserveInventoryActivity));
    workflow.add_activity(Arc::new(ProcessPaymentActivity));
    workflow.add_activity(Arc::new(PrepareShippingActivity));
    workflow.add_activity(Arc::new(SendNotificationActivity));
    
    // 订阅事件
    let mut event_receiver = workflow.subscribe_events();
    
    // 启动事件监听器
    tokio::spawn(async move {
        while let Ok(event) = event_receiver.recv().await {
            println!("收到事件: {} - {}", event.order_id, event.event_type);
        }
    });
    
    // 创建测试订单
    let order = Order {
        id: "ORD-12345".to_string(),
        customer_id: "CUST-6789".to_string(),
        items: vec![
            OrderItem {
                product_id: "PROD-001".to_string(),
                quantity: 2,
                price: 99.99,
            },
            OrderItem {
                product_id: "PROD-002".to_string(),
                quantity: 1,
                price: 49.99,
            },
        ],
        total_amount: 249.97,
        payment_method: "信用卡".to_string(),
        shipping_address: Address {
            street: "示例街123号".to_string(),
            city: "北京".to_string(),
            country: "中国".to_string(),
            postal_code: "100000".to_string(),
        },
        status: "新建".to_string(),
    };
    
    // 异步执行工作流，展示自动完成情况
    let workflow_ref = Arc::new(workflow);
    let workflow_clone = workflow_ref.clone();
    
    // 启动取消任务（在特定时间点取消工作流）
    /*
    tokio::spawn(async move {
        sleep(Duration::from_millis(1800)).await;
        println!("\n请求取消工作流...");
        workflow_clone.cancel();
    });
    */
    
    // 执行工作流
    println!("开始执行订单处理工作流...");
    match workflow_ref.execute(order).await {
        Ok(final_order) => {
            println!("\n工作流成功完成!");
            println!("最终订单状态: {}", final_order.status);
        },
        Err(err) => {
            println!("\n工作流执行失败: {}", err);
            println!("最终工作流状态: {:?}", workflow_ref.get_status());
        }
    }
    
    Ok(())
}
```

### 7.2 审批工作流

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex, atomic::{AtomicBool, Ordering}};
use tokio::sync::{mpsc, broadcast};
use tokio::task;
use tokio::time::{sleep, Duration, timeout};
use futures::future::join_all;
use async_trait::async_trait;
use serde::{Serialize, Deserialize};
use uuid::Uuid;

// 审批请求结构
#[derive(Clone, Debug, Serialize, Deserialize)]
struct ApprovalRequest {
    id: String,
    title: String,
    description: String,
    requester: String,
    department: String,
    amount: Option<f64>,
    status: String,
    created_at: String,
    approvals: HashMap<String, ApprovalStatus>,
    data: HashMap<String, String>,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
enum ApprovalStatus {
    Pending,
    Approved,
    Rejected,
    Skipped,
}

// 审批工作流状态
#[derive(Debug, Clone, PartialEq, Eq)]
enum ApprovalWorkflowStatus {
    Draft,
    InProgress,
    Approved,
    Rejected,
    Cancelled,
    TimedOut,
}

// 审批事件
#[derive(Clone, Debug)]
struct ApprovalEvent {
    request_id: String,
    event_type: String,
    approver: Option<String>,
    data: HashMap<String, String>,
    timestamp: String,
}

// 审批者接口
#[async_trait]
trait Approver: Send + Sync {
    fn get_id(&self) -> &str;
    fn get_name(&self) -> &str;
    fn can_approve(&self, request: &ApprovalRequest) -> bool;
    async fn request_approval(&self, request: Arc<Mutex<ApprovalRequest>>) -> ApprovalStatus;
}

// 审批规则
trait ApprovalRule: Send + Sync {
    fn get_id(&self) -> &str;
    fn is_satisfied(&self, request: &ApprovalRequest) -> bool;
    fn get_required_approvers(&self, request: &ApprovalRequest) -> Vec<String>;
}

// 审批策略
#[derive(Debug, Clone, PartialEq, Eq)]
enum ApprovalStrategy {
    // 任意一个批准即可
    AnyOne,
    // 所有人都必须批准
    AllMustApprove,
    // 至少N个批准
    AtLeastN(usize),
    // 顺序审批
    Sequential,
    // 主管优先审批
    SupervisorFirst,
}

// 审批阶段
struct ApprovalStage {
    id: String,
    name: String,
    approvers: Vec<Arc<dyn Approver>>,
    strategy: ApprovalStrategy,
    rules: Vec<Arc<dyn ApprovalRule>>,
    timeout: Option<Duration>,
    dependencies: Vec<String>,
}

impl ApprovalStage {
    fn new<I: Into<String>, N: Into<String>>(id: I, name: N, strategy: ApprovalStrategy) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            approvers: Vec::new(),
            strategy,
            rules: Vec::new(),
            timeout: None,
            dependencies: Vec::new(),
        }
    }
    
    fn add_approver(mut self, approver: Arc<dyn Approver>) -> Self {
        self.approvers.push(approver);
        self
    }
    
    fn add_rule(mut self, rule: Arc<dyn ApprovalRule>) -> Self {
        self.rules.push(rule);
        self
    }
    
    fn with_timeout(mut self, timeout: Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    fn with_dependencies<I: Into<String>>(mut self, deps: Vec<I>) -> Self {
        for dep in deps {
            self.dependencies.push(dep.into());
        }
        self
    }
    
    // 获取适用的审批者
    fn get_applicable_approvers(&self, request: &ApprovalRequest) -> Vec<Arc<dyn Approver>> {
        let mut result = Vec::new();
        
        for approver in &self.approvers {
            if approver.can_approve(request) {
                result.push(approver.clone());
            }
        }
        
        result
    }
    
    // 检查是否适用于请求
    fn is_applicable(&self, request: &ApprovalRequest) -> bool {
        if self.rules.is_empty() {
            return true;
        }
        
        for rule in &self.rules {
            if rule.is_satisfied(request) {
                return true;
            }
        }
        
        false
    }
}

// 审批工作流
struct ApprovalWorkflow {
    id: String,
    name: String,
    stages: HashMap<String, ApprovalStage>,
    dependencies: HashMap<String, HashSet<String>>,
    status: Arc<Mutex<ApprovalWorkflowStatus>>,
    event_sender: broadcast::Sender<ApprovalEvent>,
    cancel_flag: Arc<AtomicBool>,
}

impl ApprovalWorkflow {
    fn new<I: Into<String>, N: Into<String>>(id: I, name: N) -> Self {
        let (sender, _) = broadcast::channel(100);
        
        Self {
            id: id.into(),
            name: name.into(),
            stages: HashMap::new(),
            dependencies: HashMap::new(),
            status: Arc::new(Mutex::new(ApprovalWorkflowStatus::Draft)),
            event_sender: sender,
            cancel_flag: Arc::new(AtomicBool::new(false)),
        }
    }
    
/*    
<think>
我需要继续提供Rust实现的工作流模式的代码。
我将从之前中断的地方继续，完成审批工作流的实现，然后进入其他部分。
</think>
*/

    fn add_stage(&mut self, stage: ApprovalStage) {
        let id = stage.id.clone();
        let deps = stage.dependencies.clone();
        
        // 更新依赖关系
        let mut stage_deps = HashSet::new();
        for dep in deps {
            stage_deps.insert(dep);
        }
        
        self.dependencies.insert(id.clone(), stage_deps);
        self.stages.insert(id, stage);
    }
    
    fn subscribe_events(&self) -> broadcast::Receiver<ApprovalEvent> {
        self.event_sender.subscribe()
    }
    
    fn publish_event(&self, event: ApprovalEvent) {
        let _ = self.event_sender.send(event);
    }
    
    fn cancel(&self) {
        self.cancel_flag.store(true, Ordering::SeqCst);
    }
    
    async fn execute(&self, mut request: ApprovalRequest) -> Result<ApprovalRequest, String> {
        // 更新工作流状态
        {
            let mut status = self.status.lock().unwrap();
            *status = ApprovalWorkflowStatus::InProgress;
        }
        
        // 发布工作流开始事件
        self.publish_event(ApprovalEvent {
            request_id: request.id.clone(),
            event_type: "workflow_started".to_string(),
            approver: None,
            data: HashMap::new(),
            timestamp: chrono::Utc::now().to_rfc3339(),
        });
        
        // 找出无依赖的阶段
        let mut ready_stages: Vec<String> = Vec::new();
        for (stage_id, deps) in &self.dependencies {
            if deps.is_empty() {
                ready_stages.push(stage_id.clone());
            }
        }
        
        // 已完成的阶段
        let mut completed_stages = HashSet::new();
        
        // 跟踪总体结果
        let request_arc = Arc::new(Mutex::new(request));
        let mut overall_result = ApprovalWorkflowStatus::InProgress;
        
        // 执行所有阶段，直到所有阶段都已处理或工作流被取消
        while !ready_stages.is_empty() {
            // 检查取消标志
            if self.cancel_flag.load(Ordering::SeqCst) {
                let mut status = self.status.lock().unwrap();
                *status = ApprovalWorkflowStatus::Cancelled;
                
                self.publish_event(ApprovalEvent {
                    request_id: request_arc.lock().unwrap().id.clone(),
                    event_type: "workflow_cancelled".to_string(),
                    approver: None,
                    data: HashMap::new(),
                    timestamp: chrono::Utc::now().to_rfc3339(),
                });
                
                return Err("工作流已取消".to_string());
            }
            
            // 并行执行就绪的阶段
            let mut tasks = Vec::new();
            
            for stage_id in &ready_stages {
                if let Some(stage) = self.stages.get(stage_id) {
                    let request_clone = request_arc.clone();
                    let stage_clone = stage.clone();
                    let cancel_flag = self.cancel_flag.clone();
                    let event_sender = self.event_sender.clone();
                    
                    // 异步执行阶段
                    let task = tokio::spawn(async move {
                        let stage_result = Self::execute_stage(
                            stage_clone, 
                            request_clone, 
                            cancel_flag,
                            event_sender
                        ).await;
                        
                        (stage_id.clone(), stage_result)
                    });
                    
                    tasks.push(task);
                }
            }
            
            // 等待所有就绪阶段完成
            let results = join_all(tasks).await;
            
            // 处理结果并确定下一批就绪的阶段
            for result in results {
                if let Ok((stage_id, stage_result)) = result {
                    // 标记阶段为已完成
                    completed_stages.insert(stage_id.clone());
                    
                    // 检查阶段结果
                    match stage_result {
                        ApprovalWorkflowStatus::Rejected => {
                            // 如有拒绝，整个工作流被拒绝
                            let mut status = self.status.lock().unwrap();
                            *status = ApprovalWorkflowStatus::Rejected;
                            
                            request_arc.lock().unwrap().status = "已拒绝".to_string();
                            
                            self.publish_event(ApprovalEvent {
                                request_id: request_arc.lock().unwrap().id.clone(),
                                event_type: "workflow_rejected".to_string(),
                                approver: None,
                                data: HashMap::new(),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                            });
                            
                            return Ok(request_arc.lock().unwrap().clone());
                        },
                        ApprovalWorkflowStatus::TimedOut => {
                            // 超时，工作流失败
                            let mut status = self.status.lock().unwrap();
                            *status = ApprovalWorkflowStatus::TimedOut;
                            
                            request_arc.lock().unwrap().status = "已超时".to_string();
                            
                            self.publish_event(ApprovalEvent {
                                request_id: request_arc.lock().unwrap().id.clone(),
                                event_type: "workflow_timed_out".to_string(),
                                approver: None,
                                data: HashMap::new(),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                            });
                            
                            return Err("审批工作流超时".to_string());
                        },
                        ApprovalWorkflowStatus::Cancelled => {
                            // 取消，工作流终止
                            let mut status = self.status.lock().unwrap();
                            *status = ApprovalWorkflowStatus::Cancelled;
                            
                            request_arc.lock().unwrap().status = "已取消".to_string();
                            
                            return Err("审批工作流已取消".to_string());
                        },
                        _ => {
                            // 阶段成功完成，继续工作流
                        }
                    }
                }
            }
            
            // 确定下一批就绪的阶段
            ready_stages.clear();
            
            for (stage_id, deps) in &self.dependencies {
                if !completed_stages.contains(stage_id) {
                    let mut all_deps_completed = true;
                    
                    for dep in deps {
                        if !completed_stages.contains(dep) {
                            all_deps_completed = false;
                            break;
                        }
                    }
                    
                    if all_deps_completed {
                        ready_stages.push(stage_id.clone());
                    }
                }
            }
        }
        
        // 所有阶段都已完成，工作流成功
        let mut status = self.status.lock().unwrap();
        *status = ApprovalWorkflowStatus::Approved;
        
        request_arc.lock().unwrap().status = "已批准".to_string();
        
        self.publish_event(ApprovalEvent {
            request_id: request_arc.lock().unwrap().id.clone(),
            event_type: "workflow_approved".to_string(),
            approver: None,
            data: HashMap::new(),
            timestamp: chrono::Utc::now().to_rfc3339(),
        });
        
        Ok(request_arc.lock().unwrap().clone())
    }
    
    // 执行单个审批阶段
    async fn execute_stage(
        stage: ApprovalStage,
        request: Arc<Mutex<ApprovalRequest>>,
        cancel_flag: Arc<AtomicBool>,
        event_sender: broadcast::Sender<ApprovalEvent>
    ) -> ApprovalWorkflowStatus {
        // 检查阶段是否适用于此请求
        let is_applicable = {
            let request_guard = request.lock().unwrap();
            stage.is_applicable(&request_guard)
        };
        
        if !is_applicable {
            println!("阶段 {} 不适用于此请求，跳过", stage.id);
            
            // 发布阶段跳过事件
            let _ = event_sender.send(ApprovalEvent {
                request_id: request.lock().unwrap().id.clone(),
                event_type: format!("stage_skipped:{}", stage.id),
                approver: None,
                data: HashMap::new(),
                timestamp: chrono::Utc::now().to_rfc3339(),
            });
            
            return ApprovalWorkflowStatus::Approved;
        }
        
        // 获取适用的审批者
        let approvers = {
            let request_guard = request.lock().unwrap();
            stage.get_applicable_approvers(&request_guard)
        };
        
        if approvers.is_empty() {
            println!("阶段 {} 没有适用的审批者，自动批准", stage.id);
            
            // 发布自动批准事件
            let _ = event_sender.send(ApprovalEvent {
                request_id: request.lock().unwrap().id.clone(),
                event_type: format!("stage_auto_approved:{}", stage.id),
                approver: None,
                data: HashMap::new(),
                timestamp: chrono::Utc::now().to_rfc3339(),
            });
            
            return ApprovalWorkflowStatus::Approved;
        }
        
        // 发布阶段开始事件
        let _ = event_sender.send(ApprovalEvent {
            request_id: request.lock().unwrap().id.clone(),
            event_type: format!("stage_started:{}", stage.id),
            approver: None,
            data: HashMap::new(),
            timestamp: chrono::Utc::now().to_rfc3339(),
        });
        
        // 根据审批策略执行
        match stage.strategy {
            ApprovalStrategy::AnyOne => {
                // 任意一个批准即可
                for approver in approvers {
                    // 检查取消标志
                    if cancel_flag.load(Ordering::SeqCst) {
                        return ApprovalWorkflowStatus::Cancelled;
                    }
                    
                    let request_clone = request.clone();
                    let approver_id = approver.get_id().to_string();
                    
                    // 发布请求审批事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: "approval_requested".to_string(),
                        approver: Some(approver_id.clone()),
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    // 用超时包装审批请求
                    let approval_result = if let Some(timeout_duration) = stage.timeout {
                        match timeout(timeout_duration, approver.request_approval(request_clone)).await {
                            Ok(result) => result,
                            Err(_) => {
                                println!("审批者 {} 超时", approver_id);
                                ApprovalStatus::Skipped
                            }
                        }
                    } else {
                        approver.request_approval(request_clone).await
                    };
                    
                    // 更新请求中的审批状态
                    {
                        let mut request_guard = request.lock().unwrap();
                        request_guard.approvals.insert(approver_id.clone(), approval_result.clone());
                    }
                    
                    // 发布审批结果事件
                    let event_type = match approval_result {
                        ApprovalStatus::Approved => "approval_approved".to_string(),
                        ApprovalStatus::Rejected => "approval_rejected".to_string(),
                        ApprovalStatus::Skipped => "approval_skipped".to_string(),
                        _ => "approval_pending".to_string(),
                    };
                    
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type,
                        approver: Some(approver_id),
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    // 如果有人批准，则返回批准结果
                    if approval_result == ApprovalStatus::Approved {
                        // 发布阶段完成事件
                        let _ = event_sender.send(ApprovalEvent {
                            request_id: request.lock().unwrap().id.clone(),
                            event_type: format!("stage_completed:{}", stage.id),
                            approver: None,
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        return ApprovalWorkflowStatus::Approved;
                    }
                    
                    // 如果有人拒绝，则返回拒绝结果
                    if approval_result == ApprovalStatus::Rejected {
                        // 发布阶段拒绝事件
                        let _ = event_sender.send(ApprovalEvent {
                            request_id: request.lock().unwrap().id.clone(),
                            event_type: format!("stage_rejected:{}", stage.id),
                            approver: None,
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        return ApprovalWorkflowStatus::Rejected;
                    }
                }
                
                // 如果所有人都跳过，则按照策略返回
                match stage.skip_strategy {
                    SkipStrategy::ApproveOnSkip => ApprovalWorkflowStatus::Approved,
                    SkipStrategy::RejectOnSkip => ApprovalWorkflowStatus::Rejected,
                    SkipStrategy::TimeoutOnSkip => ApprovalWorkflowStatus::TimedOut,
                }
            },
            ApprovalStrategy::AllMustApprove => {
                // 所有人都必须批准
                let mut tasks = Vec::new();
                
                for approver in approvers {
                    let request_clone = request.clone();
                    let approver_clone = approver.clone();
                    let event_sender_clone = event_sender.clone();
                    let cancel_flag_clone = cancel_flag.clone();
                    let timeout_option = stage.timeout;
                    
                    // 异步执行审批请求
                    let task = tokio::spawn(async move {
                        // 检查取消标志
                        if cancel_flag_clone.load(Ordering::SeqCst) {
                            return (approver_clone.get_id().to_string(), ApprovalStatus::Skipped);
                        }
                        
                        let approver_id = approver_clone.get_id().to_string();
                        
                        // 发布请求审批事件
                        let _ = event_sender_clone.send(ApprovalEvent {
                            request_id: request_clone.lock().unwrap().id.clone(),
                            event_type: "approval_requested".to_string(),
                            approver: Some(approver_id.clone()),
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        // 用超时包装审批请求
                        let approval_result = if let Some(timeout_duration) = timeout_option {
                            match timeout(timeout_duration, approver_clone.request_approval(request_clone.clone())).await {
                                Ok(result) => result,
                                Err(_) => {
                                    println!("审批者 {} 超时", approver_id);
                                    ApprovalStatus::Skipped
                                }
                            }
                        } else {
                            approver_clone.request_approval(request_clone.clone()).await
                        };
                        
                        // 发布审批结果事件
                        let event_type = match approval_result {
                            ApprovalStatus::Approved => "approval_approved".to_string(),
                            ApprovalStatus::Rejected => "approval_rejected".to_string(),
                            ApprovalStatus::Skipped => "approval_skipped".to_string(),
                            _ => "approval_pending".to_string(),
                        };
                        
                        let _ = event_sender_clone.send(ApprovalEvent {
                            request_id: request_clone.lock().unwrap().id.clone(),
                            event_type,
                            approver: Some(approver_id.clone()),
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        (approver_id, approval_result)
                    });
                    
                    tasks.push(task);
                }
                
                // 等待所有审批结果
                let results = join_all(tasks).await;
                
                // 处理审批结果
                let mut all_approved = true;
                let mut any_rejected = false;
                let mut all_skipped = true;
                
                // 更新请求中的审批状态
                {
                    let mut request_guard = request.lock().unwrap();
                    
                    for result in results {
                        if let Ok((approver_id, approval_result)) = result {
                            request_guard.approvals.insert(approver_id, approval_result.clone());
                            
                            match approval_result {
                                ApprovalStatus::Approved => all_skipped = false,
                                ApprovalStatus::Rejected => {
                                    all_approved = false;
                                    any_rejected = true;
                                    all_skipped = false;
                                },
                                ApprovalStatus::Pending => {
                                    all_approved = false;
                                    all_skipped = false;
                                },
                                ApprovalStatus::Skipped => {}
                            }
                        }
                    }
                }
                
                // 决定阶段结果
                if any_rejected {
                    // 发布阶段拒绝事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: format!("stage_rejected:{}", stage.id),
                        approver: None,
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    return ApprovalWorkflowStatus::Rejected;
                } else if all_approved {
                    // 发布阶段完成事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: format!("stage_completed:{}", stage.id),
                        approver: None,
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    return ApprovalWorkflowStatus::Approved;
                } else if all_skipped {
                    // 所有人都跳过，按照策略返回
                    match stage.skip_strategy {
                        SkipStrategy::ApproveOnSkip => ApprovalWorkflowStatus::Approved,
                        SkipStrategy::RejectOnSkip => ApprovalWorkflowStatus::Rejected,
                        SkipStrategy::TimeoutOnSkip => ApprovalWorkflowStatus::TimedOut,
                    }
                } else {
                    // 部分人没有做出决定，视为工作流超时
                    ApprovalWorkflowStatus::TimedOut
                }
            },
            ApprovalStrategy::AtLeastN(n) => {
                // 至少N个批准
                let mut tasks = Vec::new();
                
                for approver in approvers {
                    let request_clone = request.clone();
                    let approver_clone = approver.clone();
                    let event_sender_clone = event_sender.clone();
                    let cancel_flag_clone = cancel_flag.clone();
                    let timeout_option = stage.timeout;
                    
                    // 异步执行审批请求
                    let task = tokio::spawn(async move {
                        // 检查取消标志
                        if cancel_flag_clone.load(Ordering::SeqCst) {
                            return (approver_clone.get_id().to_string(), ApprovalStatus::Skipped);
                        }
                        
                        let approver_id = approver_clone.get_id().to_string();
                        
                        // 发布请求审批事件
                        let _ = event_sender_clone.send(ApprovalEvent {
                            request_id: request_clone.lock().unwrap().id.clone(),
                            event_type: "approval_requested".to_string(),
                            approver: Some(approver_id.clone()),
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        // 用超时包装审批请求
                        let approval_result = if let Some(timeout_duration) = timeout_option {
                            match timeout(timeout_duration, approver_clone.request_approval(request_clone.clone())).await {
                                Ok(result) => result,
                                Err(_) => {
                                    println!("审批者 {} 超时", approver_id);
                                    ApprovalStatus::Skipped
                                }
                            }
                        } else {
                            approver_clone.request_approval(request_clone.clone()).await
                        };
                        
                        // 发布审批结果事件
                        let event_type = match approval_result {
                            ApprovalStatus::Approved => "approval_approved".to_string(),
                            ApprovalStatus::Rejected => "approval_rejected".to_string(),
                            ApprovalStatus::Skipped => "approval_skipped".to_string(),
                            _ => "approval_pending".to_string(),
                        };
                        
                        let _ = event_sender_clone.send(ApprovalEvent {
                            request_id: request_clone.lock().unwrap().id.clone(),
                            event_type,
                            approver: Some(approver_id.clone()),
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        (approver_id, approval_result)
                    });
                    
                    tasks.push(task);
                }
                
                // 等待所有审批结果
                let results = join_all(tasks).await;
                
                // 处理审批结果
                let mut approved_count = 0;
                let mut rejected_count = 0;
                let mut skipped_count = 0;
                
                // 更新请求中的审批状态
                {
                    let mut request_guard = request.lock().unwrap();
                    
                    for result in results {
                        if let Ok((approver_id, approval_result)) = result {
                            request_guard.approvals.insert(approver_id, approval_result.clone());
                            
                            match approval_result {
                                ApprovalStatus::Approved => approved_count += 1,
                                ApprovalStatus::Rejected => rejected_count += 1,
                                ApprovalStatus::Skipped => skipped_count += 1,
                                _ => {}
                            }
                        }
                    }
                }
                
                // 决定阶段结果
                if approved_count >= n {
                    // 发布阶段完成事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: format!("stage_completed:{}", stage.id),
                        approver: None,
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    return ApprovalWorkflowStatus::Approved;
                } else if rejected_count > approvers.len() - n {
                    // 已经不可能达到足够的批准
                    // 发布阶段拒绝事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: format!("stage_rejected:{}", stage.id),
                        approver: None,
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    return ApprovalWorkflowStatus::Rejected;
                } else if skipped_count == approvers.len() {
                    // 所有人都跳过，按照策略返回
                    match stage.skip_strategy {
                        SkipStrategy::ApproveOnSkip => ApprovalWorkflowStatus::Approved,
                        SkipStrategy::RejectOnSkip => ApprovalWorkflowStatus::Rejected,
                        SkipStrategy::TimeoutOnSkip => ApprovalWorkflowStatus::TimedOut,
                    }
                } else {
                    // 部分人没有做出决定，视为工作流超时
                    ApprovalWorkflowStatus::TimedOut
                }
            },
            ApprovalStrategy::Sequential => {
                // 顺序审批
                for approver in approvers {
                    // 检查取消标志
                    if cancel_flag.load(Ordering::SeqCst) {
                        return ApprovalWorkflowStatus::Cancelled;
                    }
                    
                    let request_clone = request.clone();
                    let approver_id = approver.get_id().to_string();
                    
                    // 发布请求审批事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: "approval_requested".to_string(),
                        approver: Some(approver_id.clone()),
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    // 用超时包装审批请求
                    let approval_result = if let Some(timeout_duration) = stage.timeout {
                        match timeout(timeout_duration, approver.request_approval(request_clone)).await {
                            Ok(result) => result,
                            Err(_) => {
                                println!("审批者 {} 超时", approver_id);
                                ApprovalStatus::Skipped
                            }
                        }
                    } else {
                        approver.request_approval(request_clone).await
                    };
                    
                    // 更新请求中的审批状态
                    {
                        let mut request_guard = request.lock().unwrap();
                        request_guard.approvals.insert(approver_id.clone(), approval_result.clone());
                    }
                    
                    // 发布审批结果事件
                    let event_type = match approval_result {
                        ApprovalStatus::Approved => "approval_approved".to_string(),
                        ApprovalStatus::Rejected => "approval_rejected".to_string(),
                        ApprovalStatus::Skipped => "approval_skipped".to_string(),
                        _ => "approval_pending".to_string(),
                    };
                    
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type,
                        approver: Some(approver_id),
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    // 如果拒绝，立即结束
                    if approval_result == ApprovalStatus::Rejected {
                        // 发布阶段拒绝事件
                        let _ = event_sender.send(ApprovalEvent {
                            request_id: request.lock().unwrap().id.clone(),
                            event_type: format!("stage_rejected:{}", stage.id),
                            approver: None,
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        return ApprovalWorkflowStatus::Rejected;
                    }
                    
                    // 如果跳过，根据策略处理
                    if approval_result == ApprovalStatus::Skipped {
                        match stage.skip_strategy {
                            SkipStrategy::ApproveOnSkip => {
                                // 继续下一个审批者
                                continue;
                            },
                            SkipStrategy::RejectOnSkip => {
                                // 发布阶段拒绝事件
                                let _ = event_sender.send(ApprovalEvent {
                                    request_id: request.lock().unwrap().id.clone(),
                                    event_type: format!("stage_rejected:{}", stage.id),
                                    approver: None,
                                    data: HashMap::new(),
                                    timestamp: chrono::Utc::now().to_rfc3339(),
                                });
                                
                                return ApprovalWorkflowStatus::Rejected;
                            },
                            SkipStrategy::TimeoutOnSkip => {
                                return ApprovalWorkflowStatus::TimedOut;
                            }
                        }
                    }
                }
                
                // 所有人都批准或跳过（且按策略可继续），则阶段成功
                // 发布阶段完成事件
                let _ = event_sender.send(ApprovalEvent {
                    request_id: request.lock().unwrap().id.clone(),
                    event_type: format!("stage_completed:{}", stage.id),
                    approver: None,
                    data: HashMap::new(),
                    timestamp: chrono::Utc::now().to_rfc3339(),
                });
                
                ApprovalWorkflowStatus::Approved
            },
            ApprovalStrategy::Percentage(percentage) => {
                // 百分比批准
                let required_approvals = (approvers.len() as f64 * percentage / 100.0).ceil() as usize;
                
                // 使用类似AtLeastN的逻辑
                let mut tasks = Vec::new();
                
                for approver in approvers {
                    let request_clone = request.clone();
                    let approver_clone = approver.clone();
                    let event_sender_clone = event_sender.clone();
                    let cancel_flag_clone = cancel_flag.clone();
                    let timeout_option = stage.timeout;
                    
                    // 异步执行审批请求
                    let task = tokio::spawn(async move {
                        // 检查取消标志
                        if cancel_flag_clone.load(Ordering::SeqCst) {
                            return (approver_clone.get_id().to_string(), ApprovalStatus::Skipped);
                        }
                        
                        let approver_id = approver_clone.get_id().to_string();
                        
                        // 发布请求审批事件
                        let _ = event_sender_clone.send(ApprovalEvent {
                            request_id: request_clone.lock().unwrap().id.clone(),
                            event_type: "approval_requested".to_string(),
                            approver: Some(approver_id.clone()),
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        // 用超时包装审批请求
                        let approval_result = if let Some(timeout_duration) = timeout_option {
                            match timeout(timeout_duration, approver_clone.request_approval(request_clone.clone())).await {
                                Ok(result) => result,
                                Err(_) => {
                                    println!("审批者 {} 超时", approver_id);
                                    ApprovalStatus::Skipped
                                }
                            }
                        } else {
                            approver_clone.request_approval(request_clone.clone()).await
                        };
                        
                        // 发布审批结果事件
                        let event_type = match approval_result {
                            ApprovalStatus::Approved => "approval_approved".to_string(),
                            ApprovalStatus::Rejected => "approval_rejected".to_string(),
                            ApprovalStatus::Skipped => "approval_skipped".to_string(),
                            _ => "approval_pending".to_string(),
                        };
                        
                        let _ = event_sender_clone.send(ApprovalEvent {
                            request_id: request_clone.lock().unwrap().id.clone(),
                            event_type,
                            approver: Some(approver_id.clone()),
                            data: HashMap::new(),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                        });
                        
                        (approver_id, approval_result)
                    });
                    
                    tasks.push(task);
                }
                
                // 等待所有审批结果
                let results = join_all(tasks).await;
                
                // 处理审批结果
                let mut approved_count = 0;
                let mut rejected_count = 0;
                let mut skipped_count = 0;
                
                // 更新请求中的审批状态
                {
                    let mut request_guard = request.lock().unwrap();
                    
                    for result in results {
                        if let Ok((approver_id, approval_result)) = result {
                            request_guard.approvals.insert(approver_id, approval_result.clone());
                            
                            match approval_result {
                                ApprovalStatus::Approved => approved_count += 1,
                                ApprovalStatus::Rejected => rejected_count += 1,
                                ApprovalStatus::Skipped => skipped_count += 1,
                                _ => {}
                            }
                        }
                    }
                }
                
                // 决定阶段结果
                if approved_count >= required_approvals {
                    // 发布阶段完成事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: format!("stage_completed:{}", stage.id),
                        approver: None,
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    return ApprovalWorkflowStatus::Approved;
                } else if rejected_count > approvers.len() - required_approvals {
                    // 已经不可能达到足够的批准
                    // 发布阶段拒绝事件
                    let _ = event_sender.send(ApprovalEvent {
                        request_id: request.lock().unwrap().id.clone(),
                        event_type: format!("stage_rejected:{}", stage.id),
                        approver: None,
                        data: HashMap::new(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                    });
                    
                    return ApprovalWorkflowStatus::Rejected;
                } else if skipped_count == approvers.len() {
                    // 所有人都跳过，按照策略返回
                    match stage.skip_strategy {
                        SkipStrategy::ApproveOnSkip => ApprovalWorkflowStatus::Approved,
                        SkipStrategy::RejectOnSkip => ApprovalWorkflowStatus::Rejected,
                        SkipStrategy::TimeoutOnSkip => ApprovalWorkflowStatus::TimedOut,
                    }
                } else {
                    // 部分人没有做出决定，视为工作流超时
                    ApprovalWorkflowStatus::TimedOut
                }
            }
        }
    }
}
```

## 8. Rust开源工作流库

### 8.1 流行库概述

Rust生态系统中有几个为工作流设计的库，以下是一些值得关注的库：

1. **Swirl**：一个轻量级的工作流引擎，支持异步执行和错误处理。
   - GitHub: <https://github.com/swirlai/swirl-workflow>
   - 特点：
     - 基于任务图的工作流定义
     - 支持条件分支和并行执行
     - 集成了错误处理机制

2. **Gearman-Rust**：Gearman工作队列系统的Rust实现。
   - GitHub: <https://github.com/sunng87/gearman-rust>
   - 特点：
     - 分布式工作队列
     - 支持后台任务和优先级
     - 提供异步接口

3. **Tokio-Process**：基于Tokio的进程执行库，可用于构建工作流。
   - GitHub: <https://github.com/tokio-rs/tokio-process>
   - 特点：
     - 异步进程执行
     - 管道和重定向支持

    ```text
    <think>
    需要继续完成 "8.1 流行库概述" 部分并继续介绍 
    "8.2 Swirl 工作流引擎" 和 "8.3 实现自定义工作流库" 部分。
    我将继续用中文撰写这些内容，保持与前面部分一致的风格和深度。
    </think>
    ```

4. **Copper**：一个状态机和工作流引擎，专为复杂业务流程设计。
   - GitHub: <https://github.com/copper-rs/copper>
   - 特点：
     - 基于状态机模型
     - 支持持久化工作流状态
     - 提供工作流可视化工具

5. **Riker**：一个基于Actor模型的框架，可用于构建复杂的工作流系统。
   - GitHub: <https://github.com/riker-rs/riker>
   - 特点：
     - 基于Actor的消息传递
     - 内置流处理能力
     - 支持分布式系统

6. **Lapin**：RabbitMQ的Rust客户端，可用于构建基于消息的工作流。
   - GitHub: <https://github.com/CleverCloud/lapin>
   - 特点：
     - 完整支持AMQP协议
     - 提供异步API
     - 支持工作队列和发布/订阅模式

### 8.2 Swirl 工作流引擎

Swirl是一个轻量级的工作流引擎，提供了直观的API来定义和执行工作流。
下面探讨如何使用Swirl构建工作流：

#### 8.2.1 基本概念

Swirl的核心概念包括：

- **工作流(Workflow)**：一系列相互关联的任务
- **步骤(Step)**：工作流中的单个任务单元
- **上下文(Context)**：在步骤之间传递的数据
- **执行器(Executor)**：负责执行工作流的运行时

#### 8.2.2 安装和基本使用

```rust
// Cargo.toml
[dependencies]
swirl = "0.4"
tokio = { version = "1", features = ["full"] }
```

一个简单的工作流示例：

```rust
use swirl::{Workflow, Step, Context, Error};
use std::sync::Arc;

// 定义步骤
struct ValidateData;
struct ProcessData;
struct NotifyCompletion;

impl Step for ValidateData {
    type Context = String;
    type Output = String;
    type Error = Error;
    
    async fn execute(&self, ctx: Self::Context) -> Result<Self::Output, Self::Error> {
        println!("验证数据: {}", ctx);
        
        if ctx.is_empty() {
            return Err(Error::new("数据不能为空"));
        }
        
        Ok(ctx)
    }
}

impl Step for ProcessData {
    type Context = String;
    type Output = String;
    type Error = Error;
    
    async fn execute(&self, ctx: Self::Context) -> Result<Self::Output, Self::Error> {
        println!("处理数据: {}", ctx);
        let processed = format!("已处理: {}", ctx.to_uppercase());
        Ok(processed)
    }
}

impl Step for NotifyCompletion {
    type Context = String;
    type Output = String;
    type Error = Error;
    
    async fn execute(&self, ctx: Self::Context) -> Result<Self::Output, Self::Error> {
        println!("发送通知: {}", ctx);
        Ok(format!("处理完成: {}", ctx))
    }
}

#[tokio::main]
async fn main() {
    // 创建工作流
    let workflow = Workflow::new()
        .add_step(ValidateData)
        .add_step(ProcessData)
        .add_step(NotifyCompletion);
    
    // 执行工作流
    let result = workflow.execute("测试数据".to_string()).await;
    
    match result {
        Ok(output) => println!("工作流结果: {}", output),
        Err(e) => println!("工作流错误: {:?}", e),
    }
}
```

#### 8.2.3 高级功能

**条件分支**：

```rust
let workflow = Workflow::new()
    .add_step(ValidateData)
    .branch(
        |ctx| ctx.contains("重要"),
        Workflow::new().add_step(HighPriorityProcess),
        Workflow::new().add_step(NormalProcess)
    )
    .add_step(NotifyCompletion);
```

**并行执行**：

```rust
let workflow = Workflow::new()
    .add_step(ValidateData)
    .parallel(vec![
        Workflow::new().add_step(ProcessDataPart1),
        Workflow::new().add_step(ProcessDataPart2),
        Workflow::new().add_step(ProcessDataPart3),
    ])
    .add_step(MergeResults)
    .add_step(NotifyCompletion);
```

### 8.3 实现自定义工作流库

如果现有库无法满足特定需求，可以考虑实现自定义工作流库。
以下是一个简化但功能完整的工作流库实现思路：

#### 8.3.1 核心组件设计

```rust
use std::collections::HashMap;
use std::any::{Any, TypeId};
use std::sync::{Arc, Mutex};
use std::future::Future;
use std::pin::Pin;
use async_trait::async_trait;

// 工作流上下文
pub struct WorkflowContext {
    data: Mutex<HashMap<TypeId, Box<dyn Any + Send + Sync>>>,
}

impl WorkflowContext {
    pub fn new() -> Self {
        Self {
            data: Mutex::new(HashMap::new()),
        }
    }
    
    // 存储数据
    pub fn set<T: 'static + Send + Sync>(&self, value: T) {
        let mut data = self.data.lock().unwrap();
        data.insert(TypeId::of::<T>(), Box::new(value));
    }
    
    // 获取数据
    pub fn get<T: 'static + Send + Sync + Clone>(&self) -> Option<T> {
        let data = self.data.lock().unwrap();
        data.get(&TypeId::of::<T>())
            .and_then(|boxed| boxed.downcast_ref::<T>())
            .cloned()
    }
}

// 任务特征
#[async_trait]
pub trait Task: Send + Sync {
    fn name(&self) -> &str;
    async fn execute(&self, context: Arc<WorkflowContext>) -> Result<(), String>;
}

// 工作流引擎
pub struct WorkflowEngine {
    tasks: Vec<Arc<dyn Task>>,
}

impl WorkflowEngine {
    pub fn new() -> Self {
        Self {
            tasks: Vec::new(),
        }
    }
    
    pub fn add_task<T: Task + 'static>(&mut self, task: T) -> &mut Self {
        self.tasks.push(Arc::new(task));
        self
    }
    
    pub async fn execute(&self) -> Result<Arc<WorkflowContext>, String> {
        let context = Arc::new(WorkflowContext::new());
        
        for task in &self.tasks {
            println!("执行任务: {}", task.name());
            if let Err(e) = task.execute(context.clone()).await {
                return Err(format!("任务 '{}' 失败: {}", task.name(), e));
            }
        }
        
        Ok(context)
    }
}

// 条件任务包装器
pub struct ConditionalTask<F> {
    name: String,
    condition: F,
    task: Arc<dyn Task>,
    else_task: Option<Arc<dyn Task>>,
}

impl<F> ConditionalTask<F> 
where 
    F: Fn(&WorkflowContext) -> bool + Send + Sync + 'static
{
    pub fn new<S: Into<String>>(name: S, condition: F, task: Arc<dyn Task>) -> Self {
        Self {
            name: name.into(),
            condition,
            task,
            else_task: None,
        }
    }
    
    pub fn with_else(mut self, else_task: Arc<dyn Task>) -> Self {
        self.else_task = Some(else_task);
        self
    }
}

#[async_trait]
impl<F> Task for ConditionalTask<F> 
where 
    F: Fn(&WorkflowContext) -> bool + Send + Sync + 'static
{
    fn name(&self) -> &str {
        &self.name
    }
    
    async fn execute(&self, context: Arc<WorkflowContext>) -> Result<(), String> {
        if (self.condition)(&context) {
            self.task.execute(context).await
        } else if let Some(else_task) = &self.else_task {
            else_task.execute(context).await
        } else {
            Ok(())
        }
    }
}

// 并行任务
pub struct ParallelTasks {
    name: String,
    tasks: Vec<Arc<dyn Task>>,
}

impl ParallelTasks {
    pub fn new<S: Into<String>>(name: S, tasks: Vec<Arc<dyn Task>>) -> Self {
        Self {
            name: name.into(),
            tasks,
        }
    }
}

#[async_trait]
impl Task for ParallelTasks {
    fn name(&self) -> &str {
        &self.name
    }
    
    async fn execute(&self, context: Arc<WorkflowContext>) -> Result<(), String> {
        let mut handles = Vec::new();
        
        for task in &self.tasks {
            let task_clone = task.clone();
            let context_clone = context.clone();
            
            let handle = tokio::spawn(async move {
                let task_name = task_clone.name().to_string();
                match task_clone.execute(context_clone).await {
                    Ok(()) => Ok(()),
                    Err(e) => Err(format!("并行任务 '{}' 失败: {}", task_name, e)),
                }
            });
            
            handles.push(handle);
        }
        
        // 等待所有任务完成
        for handle in futures::future::join_all(handles).await {
            if let Ok(Err(e)) = handle {
                return Err(e);
            }
        }
        
        Ok(())
    }
}
```

#### 8.3.2 使用示例

```rust
use std::sync::Arc;

// 示例任务实现
struct DataLoadTask;
struct DataProcessTask;
struct NotificationTask;

#[async_trait]
impl Task for DataLoadTask {
    fn name(&self) -> &str {
        "数据加载"
    }
    
    async fn execute(&self, context: Arc<WorkflowContext>) -> Result<(), String> {
        println!("正在加载数据...");
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        
        // 存储加载的数据到上下文
        let data = vec![1, 2, 3, 4, 5];
        context.set(data);
        
        Ok(())
    }
}

#[async_trait]
impl Task for DataProcessTask {
    fn name(&self) -> &str {
        "数据处理"
    }
    
    async fn execute(&self, context: Arc<WorkflowContext>) -> Result<(), String> {
        // 从上下文获取数据
        let data = context.get::<Vec<i32>>()
            .ok_or_else(|| "找不到数据".to_string())?;
        
        println!("处理数据: {:?}", data);
        
        // 处理数据并存回上下文
        let processed: Vec<i32> = data.iter().map(|x| x * x).collect();
        context.set(processed);
        
        Ok(())
    }
}

#[async_trait]
impl Task for NotificationTask {
    fn name(&self) -> &str {
        "发送通知"
    }
    
    async fn execute(&self, context: Arc<WorkflowContext>) -> Result<(), String> {
        // 获取处理后的数据
        let processed = context.get::<Vec<i32>>()
            .ok_or_else(|| "找不到处理后的数据".to_string())?;
        
        println!("发送处理结果通知: {:?}", processed);
        
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建工作流引擎
    let mut engine = WorkflowEngine::new();
    
    // 添加任务
    engine
        .add_task(DataLoadTask)
        .add_task(
            ConditionalTask::new(
                "条件处理", 
                |ctx| ctx.get::<Vec<i32>>().map_or(false, |v| !v.is_empty()),
                Arc::new(DataProcessTask)
            )
        )
        .add_task(
            ParallelTasks::new(
                "并行任务",
                vec![
                    Arc::new(NotificationTask),
                    Arc::new(LogResultTask)
                ]
            )
        );
    
    // 执行工作流
    let result = engine.execute().await;
    
    match result {
        Ok(_) => println!("工作流成功完成!"),
        Err(e) => println!("工作流执行错误: {}", e),
    }
    
    Ok(())
}
```

## 9. 总结

### 9.1 工作流模式选择指南

选择合适的工作流模式应考虑以下因素：

1. **业务需求复杂度**：
   - 简单顺序流程：使用序列模式
   - 有分支条件：使用排他选择或并行分支模式
   - 需要并行处理：使用并行分支或多实例模式

2. **执行环境特点**：
   - 资源受限环境：避免多实例无同步模式
   - 高可用要求：考虑使用里程碑和取消模式
   - 分布式系统：使用瞬时触发或持久触发模式

3. **数据流类型**：
   - 结构化数据：结构化判别模式
   - 动态数据：通用判别模式或延迟选择模式
   - 大量同类数据：无同步多实例模式

4. **错误处理要求**：
   - 高容错性：考虑取消案例和里程碑模式
   - 需要补偿：使用取消案例模式
   - 需要重试：使用任意循环模式

### 9.2 Rust工作流实践中的最佳实践

1. **充分利用Rust类型系统**：
   - 使用泛型使工作流组件可复用
   - 利用特征约束确保类型安全
   - 通过枚举表达状态转换

2. **异步设计考虑**：
   - 合理使用`async/await`避免阻塞
   - 考虑任务取消和超时机制
   - 注意资源管理和内存使用

3. **错误处理策略**：
   - 使用`Result`类型进行明确的错误处理
   - 为工作流各个阶段定义专用错误类型
   - 实现适当的错误传播机制

4. **并发控制**：
   - 合理使用`Arc`和`Mutex`等同步原语
   - 注意避免死锁和竞态条件
   - 考虑使用信道进行任务间通信

5. **测试策略**：
   - 为各个工作流组件编写单元测试
   - 创建集成测试验证完整工作流
   - 模拟各种错误条件和边缘情况

### 9.3 未来发展方向

1. **与AI集成**：
   - 工作流决策点引入机器学习模型
   - 使用AI预测工作流瓶颈
   - 智能工作流优化和资源分配

2. **分布式工作流增强**：
   - 跨节点工作流协调和同步
   - 容错和自动恢复机制
   - 基于事件的工作流触发

3. **可视化和监控**：
   - 工作流执行可视化工具
   - 实时监控和性能分析
   - 工作流历史和审计能力

4. **领域特定工作流**：
   - 为特定行业开发专用工作流模式
   - 针对物联网和边缘计算的轻量级工作流
   - 支持实时数据处理的流式工作流

通过合理选择和组合这些工作流模式，
开发者可以构建出既高效又可靠的复杂系统，充分发挥Rust语言的性能和安全特性。
