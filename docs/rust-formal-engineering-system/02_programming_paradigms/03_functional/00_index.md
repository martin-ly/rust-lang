# 函数式编程范式（Functional Programming Paradigm）索引

> **创建日期**: 2025-11-15
> **最后更新**: 2025-11-15
> **Rust 版本**: 1.91.1+ (Edition 2024) ✅
> **状态**: 🔄 进行中

---

## 📊 目录

- [函数式编程范式（Functional Programming Paradigm）索引](#函数式编程范式functional-programming-paradigm索引)
  - [📊 目录](#-目录)
  - [目的](#目的)
  - [术语](#术语)
  - [核心概念](#核心概念)
  - [💻 实际代码示例](#-实际代码示例)
  - [实践与示例（仓库内）](#实践与示例仓库内)
  - [设计建议](#设计建议)
  - [常见陷阱](#常见陷阱)
  - [📚 内容文档](#-内容文档)
  - [参考资料](#参考资料)
  - [导航](#导航)

---

## 目的

- 明确函数式编程范式在 Rust 中的定位与适用场景。
- 统一函数式编程相关术语，建立与其他编程范式的映射关系。
- 汇总仓库中与函数式编程相关的示例与深度文章。

---

## 术语

- **函数式编程（Functional Programming）**: 以函数为第一等公民，强调不可变性和纯函数。
- **纯函数（Pure Function）**: 无副作用，相同输入总是产生相同输出。
- **不可变性（Immutability）**: 数据一旦创建就不能修改。
- **高阶函数（Higher-Order Function）**: 接受函数作为参数或返回函数的函数。
- **闭包（Closure）**: 可以捕获环境变量的匿名函数。

---

## 核心概念

- **不可变优先**: Rust 默认变量不可变，鼓励不可变数据结构。
- **迭代器模式**: `Iterator` trait 提供函数式风格的集合操作。
- **模式匹配**: `match` 表达式提供强大的模式匹配能力。
- **类型系统**: 强类型系统支持函数式编程的类型安全。
- **所有权系统**: 所有权系统确保内存安全，无需垃圾回收。

---

## 💻 实际代码示例

将函数式编程形式化理论知识应用到实际代码中：

- **[C04 泛型模块](../../../../crates/c04_generic/)** - 泛型和函数式编程示例
- **[C08 算法模块](../../../../crates/c08_algorithms/)** - 函数式算法实现

**学习路径**: 形式化理论 → 实际代码 → 验证理解

---

## 实践与示例（仓库内）

- 迭代器和闭包：参见 `crates/c04_generic/src/` 与示例 `crates/c04_generic/examples/`。
- 函数式算法：参见 `crates/c08_algorithms/src/`。

---

## 设计建议

- 优先使用不可变数据结构。
- 利用迭代器进行集合操作。
- 使用闭包实现高阶函数。
- 通过模式匹配处理不同情况。

---

## 常见陷阱

- 过度使用 `clone()` 导致性能问题。
- 忽略迭代器的惰性求值特性。
- 在闭包中意外捕获可变引用。

---

## 📚 内容文档

- **[函数式编程基础](./01_functional_programming_foundations.md)** - 函数式编程核心概念和实践 ✅

## 参考资料

- Rust 标准库迭代器：`std::iter`
- Rust 闭包文档：`std::ops::Fn`
- 函数式编程最佳实践

---

## 导航

- 返回总索引：[`../00_index.md`](../00_index.md)
- 返回项目根：[`../../README.md`](../../README.md)
- 同步范式：[`../01_synchronous/00_index.md`](../01_synchronous/00_index.md)
- 异步范式：[`../02_async/00_index.md`](../02_async/00_index.md)
