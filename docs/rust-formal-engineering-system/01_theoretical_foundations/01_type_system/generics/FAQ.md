# C04: 常见问题解答 (FAQ)

**Q1: Rust 的泛型是零成本的，这是什么意思？它有什么缺点吗？**

A1: "零成本"是指使用泛型不会带来任何**运行时**性能开销。这是通过**单态化**实现的：编译器为每个使用的具体类型生成一份专门的、非泛型的代码。因此，泛型代码的运行速度与手写具体类型版本的代码完全相同。其主要缺点是可能增加**编译时间**和最终**二进制文件的大小**，因为同一段泛型代码可能会被复制多份。不过，在实践中，编译器的优化通常能将此影响控制在合理作用域内。

**Q2: 什么是静态分派 (Static Dispatch) 和动态分派 (Dynamic Dispatch)？**

A2:

* **静态分派**: 编译器在**编译时**就知道具体要调用哪个函数实现。Rust 的泛型使用的就是静态分派。因为没有运行时查找，所以速度非常快。
* **动态分派**: 编译器在编译时不知道要调用哪个函数，需要到**运行时**才能确定。Rust 的 Trait 对象 (`&dyn Trait`) 使用的就是动态分派。它通过 vtable（虚方法表）在运行时查找正确的函数地址，这会带来一点微小的性能开销。

**Q3: 什么时候应该使用泛型 (静态多态)，什么时候应该使用 Trait 对象 (动态多态)？**

A3:

* **使用泛型**: 当你在编写函数或数据结构体体体时，希望最大化性能，并且可以在编译时确定所有涉及的类型时。这是 Rust 中最常用、最首选的方式。
* **使用 Trait 对象**: 当你需要一个集合（如 `Vec`）来存放多种不同类型的对象，只要它们都实现了同一个 Trait 时。例如，一个图形界面库可能有一个 `Vec<Box<dyn Widget>>` 来存放按钮、文本框等不同类型的 UI 组件。这种需要异构集合的场景是动态分派的主要优势所在。

**Q4: Trait 的关联类型 (Associated Types) 和泛型类型参数 (Generic Type Parameters) 有什么区别？**

A4: 主要区别在于一个类型能实现 Trait 的次数。

* **泛型类型参数**: 一个类型可以为不同的泛型参数多次实现同一个 Trait。例如 `impl From<i32> for MyType` 和 `impl From<f64> for MyType`。
* **关联类型**: 一个类型只能实现一次带有某个关联类型的 Trait，因为该关联类型在该实现中必须是唯一确定的。例如，一个迭代器（如 `vec![1, 2].iter()`）的 `Item` 类型只能是 `i32`，不可能是其他类型。因此，`Iterator` Trait 使用关联类型 `Item` 而不是泛型参数。

**Q5: 什么是高阶类型 (HKT)？为什么它在 Rust 社区中备受关注？**

A5: 高阶类型是泛化"容器"本身的能力。想象一下，你想写一个函数，它能对任何容器（如 `Vec<T>`, `Option<T>`, `Result<T, E>`）执行 `map` 操作，而无需关心这个容器具体是什么。HKT 就能让你表达这种 `F<_>` 形式的泛型，其中 `F` 是一个类型构造器。它之所以备受关注，是因为它能解锁更高层次的抽象，特别是在函数式编程领域，可以方便地实现像 `Functor`, `Monad` 等强大的设计模式，从而编写出更通用、更具组合性的库。虽然 Rust 目前没有原生支持，但它代表了类型系统演进的一个重要方向。
