# 术语表 (Glossary)

## 📊 目录

- [术语表 (Glossary)](#术语表-glossary)
  - [📊 目录](#-目录)
  - [术语](#术语)
    - [A](#a)
    - [C](#c)
    - [D](#d)
    - [F](#f)
    - [I](#i)
    - [M](#m)
    - [P](#p)
    - [S](#s)
    - [T](#t)
    - [U](#u)
    - [V](#v)

本页定义了“第 2 章：Rust 类型系统”中出现的关键术语。

## 术语

---

### A

- **代数数据类型 (Algebraic Data Type, ADT)**
  - 一种复合类型，通过“和”（`enum`）与“积”（`struct`, `tuple`）的方式组合其他类型来定义新类型。

### C

- **类型强制 (Coercion)**
  - 一种由编译器自动执行的、隐式的、保证绝对安全的类型转换。最常见的例子是 `Deref` 强制。

- **协变 (Covariance)**
  - 型变的一种。如果 `T` 是 `U` 的子类型，`F<T>` 也是 `F<U>` 的子类型，则 `F` 对 `T` 是协变的。例如 `&'long T` 是 `&'short T` 的子类型。

- **逆变 (Contravariance)**
  - 型变的一种。如果 `T` 是 `U` 的子类型，`F<U>` 反而是 `F<T>` 的子类型，则 `F` 对 `T` 是逆变的。主要例子是函数参数类型。

### D

- **动态分派 (Dynamic Dispatch)**
  - 在运行时确定调用哪个具体方法的过程。在 Rust 中，`dyn Trait`（Trait 对象）使用动态分派，通过虚函数表 (vtable) 实现，会带来少量运行时开销。

- **Deref 强制 (Deref Coercion)**
  - 最重要的类型强制规则。如果类型 `A` 实现了 `Deref<Target=B>`，则 `&A` 类型的值可以被自动转换为 `&B`。

- **下转型 (Downcasting)**
  - 在运行时将一个 Trait 对象 (`&dyn Trait`) 安全地转换回其原始具体类型的过程，需要 `Any` Trait 的支持。

### F

- **`From`/`Into`**
  - 用于实现类型间安全、显式、惯用转换的两个 Trait。实现 `From` 会自动获得 `Into` 的实现。

### I

- **不变 (Invariance)**
  - 型变的一种。即使 `T` 是 `U` 的子类型，`F<T>` 和 `F<U>` 之间也没有子类型关系。例如 `&mut T` 为了保证内存安全必须是不变的。

- **`impl Trait`**
  - 一种语法，用于函数参数或返回值位置，表示“某个实现了该 Trait 的具体但匿名的类型”。它使用静态分派。

### M

- **单态化 (Monomorphization)**
  - 编译器在编译时处理泛型代码的过程。编译器会为泛型代码所用到的每一种具体类型，生成一份专门的代码，从而消除泛型的运行时开销。

### P

- **`PhantomData`**
  - 一个零大小的标记类型，用于在逻辑上关联一个结构体体体体与某个泛型参数，即使该参数未在字段中被使用。它主要用于影响编译器的型变推导。

### S

- **静态分派 (Static Dispatch)**
  - 在编译时就确定调用哪个具体方法的过程。在 Rust 中，泛型和 `impl Trait` 使用静态分派（通过单态化），没有任何运行时开销。

### T

- **Trait (特征)**
  - Rust 中用于定义共享行为的机制，类似于接口。它是实现特设多态的核心。

- **Trait 对象 (Trait Object)**
  - 一种指向实现了某个 Trait 的类型实例的指针，通常是 `&dyn Trait` 或 `Box<dyn Trait>`。它允许在运行时处理不同具体类型的共同行为，使用动态分派。

### U

- **上转型 (Upcasting)**
  - 将一个具体类型的实例隐式转换为其 Trait 对象的过程。例如，将 `&Dog` 转换为 `&dyn Animal`。

### V

- **型变 (Variance)**
  - 描述了当类型参数之间存在子类型关系时（如生命周期），包含这些参数的泛型类型之间会形成什么样的子类型关系（协变、逆变或不变）。
