# 2.3 借用检查器算法


## 📊 目录

- [1. 概述](#1-概述)
- [2. 核心分析流程](#2-核心分析流程)
- [3. 分析实例](#3-分析实例)
- [4. MIR 与控制流图 (CFG)](#4-mir-与控制流图-cfg)
- [5. 借用分析与 NLL](#5-借用分析与-nll)
  - [5.1. 活跃性分析](#51-活跃性分析)
  - [5.2. 确定借用生命周期](#52-确定借用生命周期)
  - [5.3. 冲突检测](#53-冲突检测)
- [6. Polonius: 下一代借用检查器](#6-polonius-下一代借用检查器)


## 1. 概述

借用检查器（Borrow Checker）是 Rust 编译器的核心组件，它是一套复杂的静态分析算法，用于在编译时强制执行所有权和借用规则。其主要目标是保证程序的内存安全和并发安全，防止悬垂借用、数据竞争和使用已移动的值，而这一切都无需运行时的垃圾回收。

本章将通过一个具体的例子，逐步拆解借用检查器的工作流程，重点阐述其在 **中间表示（MIR）** 上的分析过程，以及 **非词法生命周期（NLL）** 的核心思想。

## 2. 核心分析流程

借用检查器的分析过程可以概括为以下几个主要步骤：

1. **构建 MIR**: 将源代码转换为一种明确的、基于控制流图（Control-Flow Graph, CFG）的中间表示。
2. **活跃性分析**: 在 CFG 的每个点上，计算哪些变量的未来使用是可能的（即变量是"活跃的"）。
3. **借用分析**: 识别代码中所有的借用操作，并确定每个借用的 **生命周期**（即借用保持有效的 CFG 区域）。
4. **冲突检测**: 检查是否存在冲突的借用。例如，在同一个点上，一个变量不能同时存在活跃的独占借用和任何其他借用。

## 3. 分析实例

我们将使用以下函数作为贯穿本章的分析实例：

```rust
fn example(condition: bool) {
    let mut x = 5;      // --+ 'scope
    let y = &x;         // --+ 'a
                        //   |
    if condition {      //   |
        println!("{}", y);  // --+
    }                   //   |
                        //   |
    x += 1;             // --+
    //                      |
} // <----------------------+ 'scope, 'a
```

在 NLL 之前的旧版借用检查器中，这段代码会编译失败，因为 `y` 的借用生命周期 `'a` 被错误地扩展到了 `'scope` 的末尾，导致 `x += 1` 处的独占访问与 `y` 的共享借用冲突。而 NLL 能够正确地通过编译。

## 4. MIR 与控制流图 (CFG)

借用检查器不在源代码上直接工作，而是在 MIR 上进行分析。MIR 将代码分解为一系列 **基本块（Basic Blocks）**，每个块包含一系列无分支的语句，并以一个 **终结符（Terminator）**（如 `if`、`goto`、`return`）结束，这些块共同构成了函数的 CFG。

对于我们的 `example` 函数，其简化的 CFG 如下：

```mermaid
graph TD
    BB0 -->|always| BB1;
    BB1 -->|if true| BB2;
    BB1 -->|if false| BB3;
    BB2 -->|always| BB3;
    BB3 -->|return| BB4;

    subgraph " "
        BB0["<b>BB0</b><br/>x = 5<br/>y = &x"];
        BB2["<b>BB2</b><br/>println!(\"{}\", y)"];
        BB3["<b>BB3</b><br/>x += 1"];
        BB1["<b>BB1</b><br/>switch_int(condition)"];
        BB4["<b>BB4</b><br/>return"];
    end
```

- **BB0**: 初始化 `x` 和 `y`。
- **BB1**: `if` 条件判断，根据 `condition` 的值跳转。
- **BB2**: `if` 为 `true` 时执行的分支。
- **BB3**: `if` 为 `false` 时或从 `BB2` 执行完毕后继续执行。
- **BB4**: 函数返回。

## 5. 借用分析与 NLL

### 5.1. 活跃性分析

借用检查器首先进行活跃性分析，以确定在 CFG 的每个点的入口处，哪些变量是活跃的（即其值在未来可能被读取）。对于我们的例子，关键点是：

- `y` 在 `BB2` 的入口处是活跃的，因为 `println!` 需要读取它。
- `y` 在 `BB3` 的入口处 **不是** 活跃的，因为在从 `BB1` 或 `BB2` 到达 `BB3` 的任何路径上，`y` 都不会再被使用。

### 5.2. 确定借用生命周期

借用检查器为每个借用（如 `y = &x`）计算一个生命周期区域。这个区域是 CFG 中所有满足以下条件的点的集合：

1. 该点是借用创建点。
2. 从该点出发，可以到达一个借用是 **活跃** 的点。

在我们的例子中，对 `y` 的借用，其生命周期区域包含：

- `BB0` 的后半部分（借用创建后）。
- 整个 `BB1`（因为从 `BB1` 可以到达 `BB2`，而 `y` 在 `BB2` 是活跃的）。
- 整个 `BB2`。

重要的是，这个区域 **不包含** `BB3`，因为 `y` 在 `BB3` 的入口处不是活跃的。这就是 **非词法生命周期 (NLL)** 的精髓：**一个借用的生命周期仅持续到其最后一次使用**。

### 5.3. 冲突检测

最后，借用检查器在 CFG 的每个点上检查冲突：

- 在 `BB0`, `BB1`, `BB2` 中，存在一个活跃的共享借用 `y` (`&x`)。在这些点上任何对 `x` 的独占访问（`&mut x` 或直接修改）都会被禁止。
- 在 `BB3` 中，对 `y` 的借用生命周期已经结束。因此，`B(x)` 的状态回到了 `Unborrowed`。此时，`x += 1`（需要一个对 `x` 的独占借用）是完全合法的。

由于在任何点上都没有发现冲突，所以借用检查通过。

## 6. Polonius: 下一代借用检查器

Polonius 是 Rust 下一代借用检查器算法的代号，它基于 Datalog 逻辑编程。其核心思想是将借用检查的规则形式化为一系列逻辑事实和推导规则。

**简化后的核心逻辑**:

1. **输入事实**:
    - `loan_issued_at(L, P)`: 在点 `P` 产生了借用 `L`。
    - `var_used_at(V, P)`: 变量 `V` 在点 `P` 被使用。
    - `cfg_edge(P1, P2)`: 控制流可以从点 `P1` 到达 `P2`。

2. **推导规则**:
    - `loan_live_at(L, P)`: 如果 `L` 在 `P` 点被使用，或从 `P` 点可以到达一个 `L` 被使用的点，则借用 `L` 在 `P` 点是活跃的。
    - `subset(L1, L2)`: 如果借用 `L1` 的生命周期需要包含 `L2` 的生命周期（例如，`fn foo<'a, 'b: 'a>(...)`）。

3. **错误检测**:
    - `error(L1, L2, P)`: 如果在点 `P` 上，借用 `L1` 和 `L2` 都是活跃的，并且 `L1` 和 `L2` 互相冲突（例如，一个是 `&mut x`，另一个是 `&x`），则产生一个错误。

Polonius 的方法更加精确，能够处理一些 NLL 仍然会错误拒绝的复杂代码模式，并有望在未来提供更清晰的错误诊断信息。
