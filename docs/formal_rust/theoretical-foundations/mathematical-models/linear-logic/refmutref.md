# Rust 中的借用（&T 和 &mut T）以及“接借用”


## 📊 目录

- [Rust 中的借用（\&T 和 \&mut T）以及“接借用”](#rust-中的借用t-和-mut-t以及接借用)
  - [📊 目录](#-目录)
  - [1. 借用与借用的基本概念](#1-借用与借用的基本概念)
  - [2. 解借用与接借用的等价形式](#2-解借用与接借用的等价形式)
    - [原理说明](#原理说明)
  - [3. 代码示例](#3-代码示例)
    - [不可变借用示例](#不可变借用示例)
    - [可变借用示例](#可变借用示例)
  - [4. 自动解借用与重新借用](#4-自动解借用与重新借用)
  - [5. 等价关系总结](#5-等价关系总结)
  - [小结](#小结)


下面介绍下 Rust 中关于借用（&T 和 &mut T）以及所谓“接借用”（即先解借用再取借用，如 `&*r`）的定义、等价形式和它们之间的等价关系。

---

## 1. 借用与借用的基本概念

在 Rust 中，**借用**本质上就是对某个值的借用。  

- **不可变借用**：类型为 `&T`，借用后只能对共享数据进行只读访问。  
- **可变借用**：类型为 `&mut T`，在借用期间允许通过该借用修改数据，但同时要求在同一作用域内不能存在其他借用。

当你写出表达式 `&x` 时，实际上就是对 `x` 的一次借用操作。借用和借用在 Rust 的语义中是同一概念，都是在不取得所有权的前提下对数据进行访问。

---

## 2. 解借用与接借用的等价形式

在 Rust 中，**解借用**操作符 `*` 用于从借用中取出其指向值；而**取借用**操作符 `&` 则是获取某个值的地址。当对一个借用先做解借用再取借用时，实际上起到了“取消”解借用的作用，即：
r \equiv &*r
同样，对于可变借用也成立：
r \equiv &mut*r

### 原理说明

给定一个借用 `r`（例如 `r: &T`），则执行下面这步：

- `*r` 会解借用，结果得到类型 `T` 的值（注意：这里只是“访问”，并不发生所有权转移）。
- 对 `*r` 再取地址，即 `&*r`，则会生成一个新的借用，其类型还是 `&T`，且指向的地址与原借用 `r` 所指相同。

因此，**对一个借用先解借用再取借用，结果与原借用是等价的**。这就是 Rust 中“接借用”的等价形式。在编译器的自动解借用（auto-deref）和重新借用（reborrowing）机制下，这种等价关系经常在代码中隐式发挥作用。

---

## 3. 代码示例

下面给出两个简单的例子说明不可变借用和可变借用的等价形式。

### 不可变借用示例

```rust:src/main.rs
fn main() {
    let x = 42;
    let r: &i32 = &x;
    // &*r 与 r 等价
    let r2: &i32 = &*r;
    assert_eq!(r, r2);
}
```

在上面的例子中，`r` 是一个 `&i32` 类型的借用，`&*r` 先解借用后取借用，仍然是一个指向 `x` 的 `&i32` 类型借用，与 `r` 完全等价。

### 可变借用示例

```rust:src/main.rs
fn main() {
    let mut x = 42;
    let r: &mut i32 = &mut x;
    // &mut *r 与 r 等价
    let r2: &mut i32 = &mut *r;
    *r2 += 1;
    assert_eq!(x, 43);
}
```

这里，`r` 是一个可变借用，通过 `&mut *r` 得到的 `r2` 与 `r` 等价，同样指向变量 `x`。

---

## 4. 自动解借用与重新借用

Rust 编译器在方法调用等场景中会自动进行解借用（auto-deref）和重新借用（reborrowing）：  

- **自动解借用**：当方法调用时，编译器会自动沿着实现了 `Deref` trait 的类型进行多次解借用，使得调用链更简洁。  
- **重新借用**：当传递借用给函数时，若函数参数类型的生命周期比原借用短，编译器会自动创建一个局部的借用借用，这个过程可以看作是 `&*r` 或 `&mut *r` 的隐式应用。

例如：

```rust:src/main.rs
fn print_str(s: &str) {
    println!("{}", s);
}

fn main() {
    let s = String::from("hello");
    // s.as_str() 返回的是 &str，而这里编译器也允许将 &String 自动转换为 &str，其中也涉及了自动解借用
    print_str(&s);
}
```

---

## 5. 等价关系总结

- 对于任意不可变借用 `r: &T`，都有：  
  **`r ≡ &*r`**

- 对于任意可变借用 `r: &mut T`，也有：  
  **`r ≡ &mut *r`**

这些等价关系体现了**取地址**和**解借用**操作互为逆操作的性质。同时，根据 Rust 的借用检查规则，只要多个借用满足借用规则（例如不可变借用可以共存，可变借用则要求独占），它们在内存上的指向是一致的，均可安全地访问同一数据。

---

## 小结

- **借用**（&T 和 &mut T）表示对值**借用**。
- 对借用执行 `*` （解借用），再对结果取地址 `&`（接借用），得到的结果与原来的借用完全等价。  
- 这种等价形式不仅使得手写代码时可以灵活转换，也为 Rust 自动解借用和重新借用机制提供了理论基础，从而大大简化了代码的书写和阅读。

通过理解这些等价关系，我们可以更清晰地看到 Rust 在处理借用和借用时背后的设计哲学，从而写出更安全、简洁的代码。
