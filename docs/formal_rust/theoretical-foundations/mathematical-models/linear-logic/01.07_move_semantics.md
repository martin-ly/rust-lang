# 移动语义（Move Semantics）


## 📊 目录

- [移动语义（Move Semantics）](#移动语义move-semantics)
  - [📊 目录](#-目录)
  - [元数据](#元数据)
  - [理论简述](#理论简述)
  - [形式化定义](#形式化定义)
  - [代码示例](#代码示例)
  - [边界情况](#边界情况)
  - [理论映射](#理论映射)
  - [常见错误](#常见错误)
  - [总结](#总结)


## 元数据

- **概念ID**: 01.07
- **概念名称**: 移动语义 (Move Semantics)
- **理论层次**: 第二层：语言特质形式化层
- **相关概念**: 01.01 (所有权定义), 01.03 (所有权转移), 01.04 (借用)
- **难度级别**: 基础

## 理论简述

移动语义是Rust所有权系统的核心机制之一，指的是变量赋值或作为参数传递时，所有权会从原变量转移到新变量，原变量失效。移动语义保证了值的唯一所有权，防止悬垂借用和数据竞争。

- 非Copy类型赋值时发生所有权转移
- 原变量在移动后不可再用
- Copy类型（如i32）赋值时不会发生移动

## 形式化定义

```math
Own(y, v) \land \neg Own(x, v) \iff \text{Move}(x \to y)
```

- $Own(x, v)$：x拥有值v
- $Move(x \to y)$：所有权从x转移到y
- 移动后x不再拥有v，y拥有v

## 代码示例

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1的所有权移动到s2
    // println!("{}", s1); // 错误：s1已失效
    println!("{}", s2);
}
```

**解释**：

- `let s2 = s1;` 发生所有权转移，s1失效，s2拥有值
- 使用s1会导致编译错误

## 边界情况

```rust
fn main() {
    let x = 42; // i32实现了Copy
    let y = x; // x和y都可用
    println!("x = {}, y = {}", x, y);

    let s1 = String::from("hi");
    let s2 = s1;
    // println!("{}", s1); // 错误：s1已失效
    println!("{}", s2);
}
```

**解释**：

- Copy类型赋值不会发生所有权转移，非Copy类型会

## 理论映射

- 形式化定义：$Move(x \to y)$
- Copy类型：赋值为复制，非Copy类型：赋值为移动
- 移动后原变量失效，防止悬垂借用

## 常见错误

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1); // 错误：s1已失效
}
```

**错误原因**：

- 移动后原变量不可再用，防止多重所有权

## 总结

移动语义是Rust内存安全的基础，配合所有权和借用机制，防止悬垂借用和数据竞争。
