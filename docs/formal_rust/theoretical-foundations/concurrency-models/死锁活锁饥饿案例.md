# 死锁、活锁、饥饿案例


## 📊 目录

- [概述](#概述)
- [死锁案例](#死锁案例)
  - [1. 经典死锁：哲学家就餐问题](#1-经典死锁哲学家就餐问题)
  - [2. 死锁检测算法](#2-死锁检测算法)
  - [3. 死锁预防策略](#3-死锁预防策略)
- [活锁案例](#活锁案例)
  - [1. 活锁示例：礼貌哲学家](#1-活锁示例礼貌哲学家)
  - [2. 活锁检测](#2-活锁检测)
  - [3. 活锁预防](#3-活锁预防)
- [饥饿案例](#饥饿案例)
  - [1. 饥饿示例：优先级调度](#1-饥饿示例优先级调度)
  - [2. 饥饿检测](#2-饥饿检测)
  - [3. 饥饿预防](#3-饥饿预防)
- [自动化检测工具](#自动化检测工具)
  - [1. 综合检测器](#1-综合检测器)
  - [2. 形式化验证](#2-形式化验证)
- [工程实践](#工程实践)
  - [1. 最佳实践](#1-最佳实践)
  - [2. 测试策略](#2-测试策略)
- [总结](#总结)
- [交叉引用](#交叉引用)


## 概述

本文档提供Rust并发编程中死锁、活锁、饥饿的详细案例分析和自动化检测方法，包括形式化定义、检测算法、预防策略和工程实践。

## 死锁案例

### 1. 经典死锁：哲学家就餐问题

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// 哲学家就餐问题的死锁实现
struct Philosopher {
    id: usize,
    left_fork: Arc<Mutex<()>>,
    right_fork: Arc<Mutex<()>>,
}

impl Philosopher {
    fn new(id: usize, left_fork: Arc<Mutex<()>>, right_fork: Arc<Mutex<()>>) -> Self {
        Self {
            id,
            left_fork,
            right_fork,
        }
    }
    
    fn eat(&self) {
        // 死锁场景：所有哲学家同时拿起左叉子
        println!("哲学家 {} 尝试拿起左叉子", self.id);
        let _left = self.left_fork.lock().unwrap();
        println!("哲学家 {} 拿起左叉子", self.id);
        
        thread::sleep(Duration::from_millis(100)); // 模拟思考时间
        
        println!("哲学家 {} 尝试拿起右叉子", self.id);
        let _right = self.right_fork.lock().unwrap();
        println!("哲学家 {} 拿起右叉子，开始就餐", self.id);
        
        thread::sleep(Duration::from_millis(100)); // 模拟就餐时间
        
        println!("哲学家 {} 就餐完毕", self.id);
    }
}

// 死锁演示
fn demonstrate_deadlock() {
    let forks: Vec<Arc<Mutex<()>>> = (0..5).map(|_| Arc::new(Mutex::new(()))).collect();
    let philosophers: Vec<Philosopher> = (0..5)
        .map(|i| {
            let left_fork = forks[i].clone();
            let right_fork = forks[(i + 1) % 5].clone();
            Philosopher::new(i, left_fork, right_fork)
        })
        .collect();
    
    let handles: Vec<_> = philosophers
        .into_iter()
        .map(|philosopher| {
            thread::spawn(move || {
                philosopher.eat();
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 2. 死锁检测算法

```rust
// 资源分配图死锁检测
pub struct ResourceAllocationGraph {
    processes: Vec<Process>,
    resources: Vec<Resource>,
    allocations: Vec<Allocation>,
    requests: Vec<Request>,
}

#[derive(Debug, Clone)]
pub struct Process {
    id: usize,
    allocated_resources: Vec<usize>,
    requested_resources: Vec<usize>,
}

#[derive(Debug, Clone)]
pub struct Resource {
    id: usize,
    total_units: usize,
    available_units: usize,
}

#[derive(Debug)]
pub struct Allocation {
    process_id: usize,
    resource_id: usize,
    units: usize,
}

#[derive(Debug)]
pub struct Request {
    process_id: usize,
    resource_id: usize,
    units: usize,
}

impl ResourceAllocationGraph {
    pub fn new() -> Self {
        Self {
            processes: Vec::new(),
            resources: Vec::new(),
            allocations: Vec::new(),
            requests: Vec::new(),
        }
    }
    
    // 死锁检测：银行家算法
    pub fn detect_deadlock(&self) -> Option<Vec<usize>> {
        let mut work: Vec<usize> = self.resources.iter().map(|r| r.available_units).collect();
        let mut finish: Vec<bool> = vec![false; self.processes.len()];
        let mut safe_sequence: Vec<usize> = Vec::new();
        
        // 找到可以完成的进程
        loop {
            let mut found = false;
            for (i, process) in self.processes.iter().enumerate() {
                if !finish[i] && self.can_allocate(i, &work) {
                    // 释放进程占用的资源
                    for &resource_id in &process.allocated_resources {
                        work[resource_id] += self.get_allocation(i, resource_id);
                    }
                    finish[i] = true;
                    safe_sequence.push(i);
                    found = true;
                }
            }
            
            if !found {
                break;
            }
        }
        
        // 检查是否所有进程都完成
        if finish.iter().all(|&f| f) {
            None // 无死锁
        } else {
            // 返回死锁进程
            Some(
                finish
                    .iter()
                    .enumerate()
                    .filter_map(|(i, &f)| if !f { Some(i) } else { None })
                    .collect()
            )
        }
    }
    
    fn can_allocate(&self, process_id: usize, work: &[usize]) -> bool {
        let process = &self.processes[process_id];
        for &resource_id in &process.requested_resources {
            let requested = self.get_request(process_id, resource_id);
            if work[resource_id] < requested {
                return false;
            }
        }
        true
    }
    
    fn get_allocation(&self, process_id: usize, resource_id: usize) -> usize {
        self.allocations
            .iter()
            .find(|a| a.process_id == process_id && a.resource_id == resource_id)
            .map(|a| a.units)
            .unwrap_or(0)
    }
    
    fn get_request(&self, process_id: usize, resource_id: usize) -> usize {
        self.requests
            .iter()
            .find(|r| r.process_id == process_id && r.resource_id == resource_id)
            .map(|r| r.units)
            .unwrap_or(0)
    }
}
```

### 3. 死锁预防策略

```rust
// 死锁预防：资源有序分配
pub struct OrderedResourceAllocation {
    resource_order: Vec<usize>,
}

impl OrderedResourceAllocation {
    pub fn new() -> Self {
        Self {
            resource_order: Vec::new(),
        }
    }
    
    pub fn set_resource_order(&mut self, order: Vec<usize>) {
        self.resource_order = order;
    }
    
    // 检查资源请求是否违反有序分配原则
    pub fn is_safe_request(&self, current_allocations: &[usize], requested_resource: usize) -> bool {
        // 找到当前进程已分配的最高优先级资源
        let max_allocated = current_allocations
            .iter()
            .enumerate()
            .filter(|(_, &allocated)| allocated > 0)
            .map(|(resource_id, _)| {
                self.resource_order
                    .iter()
                    .position(|&id| id == resource_id)
                    .unwrap_or(usize::MAX)
            })
            .max()
            .unwrap_or(0);
        
        // 检查请求的资源优先级是否低于已分配资源
        let requested_priority = self.resource_order
            .iter()
            .position(|&id| id == requested_resource)
            .unwrap_or(usize::MAX);
        
        requested_priority >= max_allocated
    }
}

// 死锁预防：超时机制
pub struct TimeoutDeadlockPrevention {
    timeout_duration: Duration,
}

impl TimeoutDeadlockPrevention {
    pub fn new(timeout: Duration) -> Self {
        Self {
            timeout_duration: timeout,
        }
    }
    
    pub async fn acquire_with_timeout<T>(
        &self,
        mutex: &Arc<Mutex<T>>,
    ) -> Result<MutexGuard<T>, TimeoutError> {
        let start = std::time::Instant::now();
        
        loop {
            match mutex.try_lock() {
                Ok(guard) => return Ok(guard),
                Err(_) => {
                    if start.elapsed() > self.timeout_duration {
                        return Err(TimeoutError);
                    }
                    tokio::time::sleep(Duration::from_millis(1)).await;
                }
            }
        }
    }
}

#[derive(Debug)]
pub struct TimeoutError;
```

## 活锁案例

### 1. 活锁示例：礼貌哲学家

```rust
// 活锁：礼貌哲学家问题
struct PolitePhilosopher {
    id: usize,
    left_fork: Arc<Mutex<()>>,
    right_fork: Arc<Mutex<()>>,
}

impl PolitePhilosopher {
    fn new(id: usize, left_fork: Arc<Mutex<()>>, right_fork: Arc<Mutex<()>>) -> Self {
        Self {
            id,
            left_fork,
            right_fork,
        }
    }
    
    fn eat(&self) {
        loop {
            // 尝试拿起左叉子
            match self.left_fork.try_lock() {
                Ok(_left) => {
                    println!("哲学家 {} 拿起左叉子", self.id);
                    
                    // 尝试拿起右叉子
                    match self.right_fork.try_lock() {
                        Ok(_right) => {
                            println!("哲学家 {} 拿起右叉子，开始就餐", self.id);
                            thread::sleep(Duration::from_millis(100));
                            println!("哲学家 {} 就餐完毕", self.id);
                            return;
                        }
                        Err(_) => {
                            // 右叉子不可用，礼貌地放下左叉子
                            println!("哲学家 {} 放下左叉子（礼貌）", self.id);
                            drop(_left);
                            thread::sleep(Duration::from_millis(10));
                        }
                    }
                }
                Err(_) => {
                    // 左叉子不可用，等待
                    thread::sleep(Duration::from_millis(10));
                }
            }
        }
    }
}
```

### 2. 活锁检测

```rust
// 活锁检测：状态变化监控
pub struct LivelockDetector {
    process_states: Arc<Mutex<HashMap<usize, ProcessState>>>,
    state_history: Arc<Mutex<VecDeque<StateSnapshot>>>,
    max_history_size: usize,
}

#[derive(Debug, Clone)]
pub struct ProcessState {
    process_id: usize,
    current_state: String,
    timestamp: std::time::Instant,
    state_count: usize,
}

#[derive(Debug)]
pub struct StateSnapshot {
    timestamp: std::time::Instant,
    states: HashMap<usize, ProcessState>,
}

impl LivelockDetector {
    pub fn new(max_history_size: usize) -> Self {
        Self {
            process_states: Arc::new(Mutex::new(HashMap::new())),
            state_history: Arc::new(Mutex::new(VecDeque::new())),
            max_history_size,
        }
    }
    
    pub fn record_state_change(&self, process_id: usize, new_state: String) {
        let mut states = self.process_states.lock().unwrap();
        let now = std::time::Instant::now();
        
        let state_count = states
            .get(&process_id)
            .map(|s| s.state_count + 1)
            .unwrap_or(1);
        
        states.insert(process_id, ProcessState {
            process_id,
            current_state: new_state,
            timestamp: now,
            state_count,
        });
        
        // 记录状态快照
        let snapshot = StateSnapshot {
            timestamp: now,
            states: states.clone(),
        };
        
        let mut history = self.state_history.lock().unwrap();
        history.push_back(snapshot);
        
        if history.len() > self.max_history_size {
            history.pop_front();
        }
    }
    
    pub fn detect_livelock(&self) -> Option<LivelockReport> {
        let history = self.state_history.lock().unwrap();
        let states = self.process_states.lock().unwrap();
        
        // 检查是否有进程在短时间内频繁切换状态
        let mut suspicious_processes = Vec::new();
        
        for (process_id, state) in states.iter() {
            if state.state_count > 100 { // 阈值可配置
                let recent_snapshots: Vec<_> = history
                    .iter()
                    .filter(|s| s.timestamp > state.timestamp - Duration::from_secs(10))
                    .collect();
                
                if recent_snapshots.len() > 50 {
                    suspicious_processes.push(*process_id);
                }
            }
        }
        
        if !suspicious_processes.is_empty() {
            Some(LivelockReport {
                suspicious_processes,
                detection_time: std::time::Instant::now(),
            })
        } else {
            None
        }
    }
}

#[derive(Debug)]
pub struct LivelockReport {
    suspicious_processes: Vec<usize>,
    detection_time: std::time::Instant,
}
```

### 3. 活锁预防

```rust
// 活锁预防：随机退避
pub struct RandomBackoff {
    base_delay: Duration,
    max_delay: Duration,
    multiplier: f64,
}

impl RandomBackoff {
    pub fn new(base_delay: Duration, max_delay: Duration, multiplier: f64) -> Self {
        Self {
            base_delay,
            max_delay,
            multiplier,
        }
    }
    
    pub fn get_delay(&self, attempt: usize) -> Duration {
        let delay_ms = (self.base_delay.as_millis() as f64 * self.multiplier.powi(attempt as i32)) as u64;
        let jitter = rand::random::<u64>() % 100; // 添加随机抖动
        let final_delay = (delay_ms + jitter).min(self.max_delay.as_millis() as u64);
        Duration::from_millis(final_delay)
    }
}

// 活锁预防：优先级机制
pub struct PriorityBasedPrevention {
    priorities: Arc<Mutex<HashMap<usize, u32>>>,
}

impl PriorityBasedPrevention {
    pub fn new() -> Self {
        Self {
            priorities: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub fn set_priority(&self, process_id: usize, priority: u32) {
        self.priorities.lock().unwrap().insert(process_id, priority);
    }
    
    pub fn should_yield(&self, current_process: usize, competing_process: usize) -> bool {
        let priorities = self.priorities.lock().unwrap();
        let current_priority = priorities.get(&current_process).unwrap_or(&0);
        let competing_priority = priorities.get(&competing_process).unwrap_or(&0);
        
        competing_priority > current_priority
    }
}
```

## 饥饿案例

### 1. 饥饿示例：优先级调度

```rust
// 饥饿：低优先级任务永远无法执行
pub struct PriorityScheduler {
    high_priority_queue: Arc<Mutex<VecDeque<Task>>>,
    low_priority_queue: Arc<Mutex<VecDeque<Task>>>,
    current_task: Arc<Mutex<Option<Task>>>,
}

#[derive(Debug, Clone)]
pub struct Task {
    id: usize,
    priority: Priority,
    execution_time: Duration,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum Priority {
    Low,
    Medium,
    High,
}

impl PriorityScheduler {
    pub fn new() -> Self {
        Self {
            high_priority_queue: Arc::new(Mutex::new(VecDeque::new())),
            low_priority_queue: Arc::new(Mutex::new(VecDeque::new())),
            current_task: Arc::new(Mutex::new(None)),
        }
    }
    
    pub fn add_task(&self, task: Task) {
        match task.priority {
            Priority::High => {
                self.high_priority_queue.lock().unwrap().push_back(task);
            }
            Priority::Low | Priority::Medium => {
                self.low_priority_queue.lock().unwrap().push_back(task);
            }
        }
    }
    
    pub fn schedule(&self) -> Option<Task> {
        // 饥饿场景：总是优先执行高优先级任务
        if let Some(task) = self.high_priority_queue.lock().unwrap().pop_front() {
            return Some(task);
        }
        
        // 低优先级任务永远无法执行
        self.low_priority_queue.lock().unwrap().pop_front()
    }
}
```

### 2. 饥饿检测

```rust
// 饥饿检测：等待时间监控
pub struct StarvationDetector {
    task_wait_times: Arc<Mutex<HashMap<usize, WaitTimeInfo>>>,
    starvation_threshold: Duration,
}

#[derive(Debug)]
pub struct WaitTimeInfo {
    task_id: usize,
    priority: Priority,
    creation_time: std::time::Instant,
    last_check_time: std::time::Instant,
    total_wait_time: Duration,
}

impl StarvationDetector {
    pub fn new(starvation_threshold: Duration) -> Self {
        Self {
            task_wait_times: Arc::new(Mutex::new(HashMap::new())),
            starvation_threshold,
        }
    }
    
    pub fn register_task(&self, task_id: usize, priority: Priority) {
        let now = std::time::Instant::now();
        let wait_info = WaitTimeInfo {
            task_id,
            priority,
            creation_time: now,
            last_check_time: now,
            total_wait_time: Duration::ZERO,
        };
        
        self.task_wait_times.lock().unwrap().insert(task_id, wait_info);
    }
    
    pub fn update_wait_time(&self, task_id: usize) {
        let mut wait_times = self.task_wait_times.lock().unwrap();
        if let Some(wait_info) = wait_times.get_mut(&task_id) {
            let now = std::time::Instant::now();
            wait_info.total_wait_time = now - wait_info.creation_time;
            wait_info.last_check_time = now;
        }
    }
    
    pub fn detect_starvation(&self) -> Vec<StarvationReport> {
        let wait_times = self.task_wait_times.lock().unwrap();
        let mut starvation_reports = Vec::new();
        
        for (task_id, wait_info) in wait_times.iter() {
            if wait_info.total_wait_time > self.starvation_threshold {
                starvation_reports.push(StarvationReport {
                    task_id: *task_id,
                    priority: wait_info.priority.clone(),
                    wait_time: wait_info.total_wait_time,
                    detection_time: std::time::Instant::now(),
                });
            }
        }
        
        starvation_reports
    }
}

#[derive(Debug)]
pub struct StarvationReport {
    task_id: usize,
    priority: Priority,
    wait_time: Duration,
    detection_time: std::time::Instant,
}
```

### 3. 饥饿预防

```rust
// 饥饿预防：老化机制
pub struct AgingScheduler {
    task_ages: Arc<Mutex<HashMap<usize, AgingInfo>>>,
    aging_factor: f64,
}

#[derive(Debug)]
pub struct AgingInfo {
    task_id: usize,
    original_priority: Priority,
    current_priority: Priority,
    age: Duration,
    last_update: std::time::Instant,
}

impl AgingScheduler {
    pub fn new(aging_factor: f64) -> Self {
        Self {
            task_ages: Arc::new(Mutex::new(HashMap::new())),
            aging_factor,
        }
    }
    
    pub fn register_task(&self, task_id: usize, priority: Priority) {
        let aging_info = AgingInfo {
            task_id,
            original_priority: priority.clone(),
            current_priority: priority,
            age: Duration::ZERO,
            last_update: std::time::Instant::now(),
        };
        
        self.task_ages.lock().unwrap().insert(task_id, aging_info);
    }
    
    pub fn update_aging(&self, task_id: usize) {
        let mut ages = self.task_ages.lock().unwrap();
        if let Some(aging_info) = ages.get_mut(&task_id) {
            let now = std::time::Instant::now();
            aging_info.age = now - aging_info.last_update;
            aging_info.last_update = now;
            
            // 根据等待时间提升优先级
            self.promote_priority(aging_info);
        }
    }
    
    fn promote_priority(&self, aging_info: &mut AgingInfo) {
        let age_seconds = aging_info.age.as_secs() as f64;
        let promotion_threshold = age_seconds * self.aging_factor;
        
        match aging_info.current_priority {
            Priority::Low if promotion_threshold > 10.0 => {
                aging_info.current_priority = Priority::Medium;
            }
            Priority::Medium if promotion_threshold > 20.0 => {
                aging_info.current_priority = Priority::High;
            }
            _ => {}
        }
    }
    
    pub fn get_effective_priority(&self, task_id: usize) -> Option<Priority> {
        self.task_ages
            .lock()
            .unwrap()
            .get(&task_id)
            .map(|info| info.current_priority.clone())
    }
}
```

## 自动化检测工具

### 1. 综合检测器

```rust
// 综合并发问题检测器
pub struct ConcurrencyProblemDetector {
    deadlock_detector: ResourceAllocationGraph,
    livelock_detector: LivelockDetector,
    starvation_detector: StarvationDetector,
    detection_interval: Duration,
}

impl ConcurrencyProblemDetector {
    pub fn new() -> Self {
        Self {
            deadlock_detector: ResourceAllocationGraph::new(),
            livelock_detector: LivelockDetector::new(1000),
            starvation_detector: StarvationDetector::new(Duration::from_secs(30)),
            detection_interval: Duration::from_secs(1),
        }
    }
    
    pub async fn start_monitoring(&self) {
        loop {
            // 检测死锁
            if let Some(deadlocked_processes) = self.deadlock_detector.detect_deadlock() {
                println!("检测到死锁，涉及进程: {:?}", deadlocked_processes);
                self.handle_deadlock(deadlocked_processes).await;
            }
            
            // 检测活锁
            if let Some(livelock_report) = self.livelock_detector.detect_livelock() {
                println!("检测到活锁: {:?}", livelock_report);
                self.handle_livelock(livelock_report).await;
            }
            
            // 检测饥饿
            let starvation_reports = self.starvation_detector.detect_starvation();
            if !starvation_reports.is_empty() {
                println!("检测到饥饿: {:?}", starvation_reports);
                self.handle_starvation(starvation_reports).await;
            }
            
            tokio::time::sleep(self.detection_interval).await;
        }
    }
    
    async fn handle_deadlock(&self, deadlocked_processes: Vec<usize>) {
        // 死锁处理策略
        for process_id in deadlocked_processes {
            // 可以选择终止进程、回滚操作或资源抢占
            println!("处理死锁进程: {}", process_id);
        }
    }
    
    async fn handle_livelock(&self, livelock_report: LivelockReport) {
        // 活锁处理策略
        for process_id in livelock_report.suspicious_processes {
            // 可以强制进程等待或调整优先级
            println!("处理活锁进程: {}", process_id);
        }
    }
    
    async fn handle_starvation(&self, starvation_reports: Vec<StarvationReport>) {
        // 饥饿处理策略
        for report in starvation_reports {
            // 可以提升任务优先级或调整调度策略
            println!("处理饥饿任务: {}", report.task_id);
        }
    }
}
```

### 2. 形式化验证

```rust
// 使用模型检查进行形式化验证
pub struct FormalVerification {
    // 状态空间
    state_space: Vec<SystemState>,
    // 转换关系
    transitions: Vec<StateTransition>,
    // 安全属性
    safety_properties: Vec<SafetyProperty>,
    // 活性属性
    liveness_properties: Vec<LivenessProperty>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SystemState {
    process_states: HashMap<usize, ProcessState>,
    resource_states: HashMap<usize, ResourceState>,
    timestamp: u64,
}

#[derive(Debug)]
pub struct StateTransition {
    from_state: SystemState,
    to_state: SystemState,
    action: String,
    process_id: usize,
}

#[derive(Debug)]
pub struct SafetyProperty {
    name: String,
    condition: Box<dyn Fn(&SystemState) -> bool>,
}

#[derive(Debug)]
pub struct LivenessProperty {
    name: String,
    condition: Box<dyn Fn(&[SystemState]) -> bool>,
}

impl FormalVerification {
    pub fn new() -> Self {
        Self {
            state_space: Vec::new(),
            transitions: Vec::new(),
            safety_properties: Vec::new(),
            liveness_properties: Vec::new(),
        }
    }
    
    pub fn add_safety_property(&mut self, name: String, condition: Box<dyn Fn(&SystemState) -> bool>) {
        self.safety_properties.push(SafetyProperty { name, condition });
    }
    
    pub fn add_liveness_property(&mut self, name: String, condition: Box<dyn Fn(&[SystemState]) -> bool>) {
        self.liveness_properties.push(LivenessProperty { name, condition });
    }
    
    pub fn verify_properties(&self) -> VerificationReport {
        let mut report = VerificationReport::new();
        
        // 验证安全属性
        for property in &self.safety_properties {
            let mut violated = false;
            for state in &self.state_space {
                if !(property.condition)(state) {
                    violated = true;
                    report.safety_violations.push(SafetyViolation {
                        property_name: property.name.clone(),
                        violating_state: state.clone(),
                    });
                }
            }
            
            if !violated {
                report.satisfied_safety_properties.push(property.name.clone());
            }
        }
        
        // 验证活性属性
        for property in &self.liveness_properties {
            if (property.condition)(&self.state_space) {
                report.satisfied_liveness_properties.push(property.name.clone());
            } else {
                report.liveness_violations.push(LivenessViolation {
                    property_name: property.name.clone(),
                });
            }
        }
        
        report
    }
}

#[derive(Debug)]
pub struct VerificationReport {
    satisfied_safety_properties: Vec<String>,
    safety_violations: Vec<SafetyViolation>,
    satisfied_liveness_properties: Vec<String>,
    liveness_violations: Vec<LivenessViolation>,
}

impl VerificationReport {
    fn new() -> Self {
        Self {
            satisfied_safety_properties: Vec::new(),
            safety_violations: Vec::new(),
            satisfied_liveness_properties: Vec::new(),
            liveness_violations: Vec::new(),
        }
    }
}

#[derive(Debug)]
pub struct SafetyViolation {
    property_name: String,
    violating_state: SystemState,
}

#[derive(Debug)]
pub struct LivenessViolation {
    property_name: String,
}
```

## 工程实践

### 1. 最佳实践

```rust
// 并发编程最佳实践
pub struct ConcurrencyBestPractices {
    // 锁层次结构
    lock_hierarchy: LockHierarchy,
    // 资源管理
    resource_management: ResourceManagement,
    // 错误处理
    error_handling: ErrorHandling,
}

pub struct LockHierarchy {
    hierarchy_levels: Vec<u32>,
    lock_order: Vec<usize>,
}

impl LockHierarchy {
    pub fn new() -> Self {
        Self {
            hierarchy_levels: Vec::new(),
            lock_order: Vec::new(),
        }
    }
    
    pub fn add_lock(&mut self, lock_id: usize, level: u32) {
        self.hierarchy_levels.push(level);
        self.lock_order.push(lock_id);
    }
    
    pub fn validate_lock_order(&self, acquired_locks: &[usize]) -> bool {
        let mut current_level = 0;
        
        for &lock_id in acquired_locks {
            if let Some(&level) = self.hierarchy_levels.get(lock_id) {
                if level < current_level {
                    return false; // 违反锁层次结构
                }
                current_level = level;
            }
        }
        
        true
    }
}

pub struct ResourceManagement {
    resource_pool: Arc<Mutex<HashMap<String, Vec<Resource>>>>,
    allocation_strategy: AllocationStrategy,
}

pub enum AllocationStrategy {
    FirstFit,
    BestFit,
    WorstFit,
}

impl ResourceManagement {
    pub fn new(strategy: AllocationStrategy) -> Self {
        Self {
            resource_pool: Arc::new(Mutex::new(HashMap::new())),
            allocation_strategy: strategy,
        }
    }
    
    pub async fn allocate_resource(&self, resource_type: &str, size: usize) -> Option<Resource> {
        let mut pool = self.resource_pool.lock().unwrap();
        
        if let Some(resources) = pool.get_mut(resource_type) {
            match self.allocation_strategy {
                AllocationStrategy::FirstFit => {
                    resources.iter().position(|r| r.size >= size).map(|i| resources.remove(i))
                }
                AllocationStrategy::BestFit => {
                    resources
                        .iter()
                        .enumerate()
                        .filter(|(_, r)| r.size >= size)
                        .min_by_key(|(_, r)| r.size)
                        .map(|(i, _)| resources.remove(i))
                }
                AllocationStrategy::WorstFit => {
                    resources
                        .iter()
                        .enumerate()
                        .filter(|(_, r)| r.size >= size)
                        .max_by_key(|(_, r)| r.size)
                        .map(|(i, _)| resources.remove(i))
                }
            }
        } else {
            None
        }
    }
}
```

### 2. 测试策略

```rust
// 并发测试策略
pub struct ConcurrencyTesting {
    // 压力测试
    stress_testing: StressTesting,
    // 模型检查
    model_checking: ModelChecking,
    // 模糊测试
    fuzz_testing: FuzzTesting,
}

pub struct StressTesting {
    max_concurrent_tasks: usize,
    test_duration: Duration,
    failure_threshold: f64,
}

impl StressTesting {
    pub fn new(max_concurrent_tasks: usize, test_duration: Duration, failure_threshold: f64) -> Self {
        Self {
            max_concurrent_tasks,
            test_duration,
            failure_threshold,
        }
    }
    
    pub async fn run_stress_test<F, Fut>(&self, test_function: F) -> StressTestResult
    where
        F: Fn() -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Result<(), Box<dyn std::error::Error>>> + Send,
    {
        let start = std::time::Instant::now();
        let mut tasks = Vec::new();
        let mut failures = 0;
        let mut total_tasks = 0;
        
        while start.elapsed() < self.test_duration {
            // 启动并发任务
            for _ in 0..self.max_concurrent_tasks {
                let task = tokio::spawn(test_function());
                tasks.push(task);
                total_tasks += 1;
            }
            
            // 等待任务完成
            for task in tasks.drain(..) {
                match task.await {
                    Ok(Ok(_)) => {}
                    Ok(Err(_)) | Err(_) => failures += 1,
                }
            }
        }
        
        let failure_rate = failures as f64 / total_tasks as f64;
        StressTestResult {
            total_tasks,
            failures,
            failure_rate,
            test_duration: start.elapsed(),
        }
    }
}

#[derive(Debug)]
pub struct StressTestResult {
    total_tasks: usize,
    failures: usize,
    failure_rate: f64,
    test_duration: Duration,
}

pub struct ModelChecking {
    state_exploration: StateExploration,
    property_verification: PropertyVerification,
}

impl ModelChecking {
    pub fn new() -> Self {
        Self {
            state_exploration: StateExploration::new(),
            property_verification: PropertyVerification::new(),
        }
    }
    
    pub fn explore_state_space(&self, initial_state: SystemState) -> Vec<SystemState> {
        let mut visited = HashSet::new();
        let mut to_visit = VecDeque::new();
        let mut all_states = Vec::new();
        
        to_visit.push_back(initial_state);
        
        while let Some(state) = to_visit.pop_front() {
            if visited.insert(state.clone()) {
                all_states.push(state.clone());
                
                // 生成后继状态
                let successors = self.generate_successors(&state);
                for successor in successors {
                    to_visit.push_back(successor);
                }
            }
        }
        
        all_states
    }
    
    fn generate_successors(&self, state: &SystemState) -> Vec<SystemState> {
        // 实现状态转换逻辑
        Vec::new()
    }
}
```

## 总结

本文档提供了Rust并发编程中死锁、活锁、饥饿问题的全面分析和解决方案。通过形式化定义、检测算法、预防策略和自动化工具，开发者可以更好地理解和避免这些并发问题，构建更可靠、高效的并发系统。

## 交叉引用

- [并发与同步原语](../05_concurrency/)
- [异步编程模型](./async-models/)
- [形式化验证](../formal_verification/)
- [工程实践](../engineering_practices/)
