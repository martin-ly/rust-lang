# 教程：借用检查器工作原理

> **创建日期**: 2026-02-24
> **目标受众**: 初学者-进阶
> **预计阅读时间**: 20分钟
> **级别**: L1/L2

---

## 引言

借用检查器(Borrow Checker)是Rust编译器的核心组件。它确保你的代码内存安全，无需垃圾回收器。本教程将解释借用检查器的工作原理。

---

## 第一部分：为什么需要借用检查器？

### 内存安全问题

```rust
// C语言中的错误
int* ptr = malloc(sizeof(int));
free(ptr);
*ptr = 42;  // 使用已释放内存！悬垂指针！
```

传统解决方案：

- **GC**: 运行时开销
- **手动管理**: 容易出错
- **智能指针**: 仍可能出错

**Rust的解决方案**: 编译时检查，零运行时开销。

---

## 第二部分：借用检查器的核心规则

### 规则1: 要么多个不可变借用，要么一个可变借用

```rust
let mut x = 5;

// 可以有多个不可变借用
let r1 = &x;
let r2 = &x;
println!("{} {}", r1, r2);

// 但不能同时有可变借用
// let r3 = &mut x;  // 错误！
```

**为什么?** 防止数据竞争。读者看到的数据可能被写者修改。

### 规则2: 引用必须始终有效

```rust
let r;
{
    let x = 5;
    r = &x;  // 错误！x在此处被释放
}  // x结束
// r仍然有效，但指向无效内存
```

---

## 第三部分：工作原理

### 借用检查算法

```
1. 为每个引用分配生命周期
2. 检查引用是否活得比数据长
3. 检查借用规则冲突
4. 如果有冲突，编译错误
```

### 生命周期标注

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// 编译器检查:
// - 返回的引用与x、y生命周期关联
// - 调用者必须确保返回的引用活得足够长
```

---

## 第四部分：常见错误与解决

### 错误1: 借用冲突

```rust
let mut x = 5;
let r1 = &x;
let r2 = &mut x;  // 错误！r1还在用
println!("{}", r1);

// 解决: 缩小r1的作用域
{
    let r1 = &x;
    println!("{}", r1);
}
let r2 = &mut x;  // OK
```

### 错误2: 悬垂引用

```rust
fn dangling() -> &String {
    let s = String::from("hello");
    &s  // 错误！s在函数结束时被释放
}

// 解决: 返回所有权
fn not_dangling() -> String {
    let s = String::from("hello");
    s  // 转移所有权
}
```

---

## 第五部分：高级特性

### NLL (非词法生命周期)

```rust
let mut x = 5;
let y = &x;
println!("{}", y);  // y最后一次使用
// 这里y已经结束，即使还在作用域内
let z = &mut x;  // OK！NLL允许
```

### 内部可变性

```rust
use std::cell::RefCell;

let x = RefCell::new(5);
let y = x.borrow();    // 不可变借用
let z = x.borrow_mut(); // 运行时错误！已有借用
```

借用检查器在编译时检查，RefCell在运行时检查。

---

## 第六部分：形式化视角

### 定理 T-BR1

**借用检查器保证数据竞争自由。**

```
BorrowCheck(P) = OK → DataRaceFree(P)
```

**证明思路**:

- 借用规则确保写操作独占
- 不可变借用允许多个读者
- 不可能同时存在写者和读者

---

## 总结

```
借用检查器
    │
    ├──→ 核心规则
    │       ├── 要么多&，要么一个&mut
    │       └── 引用必须有效
    │
    ├──→ 实现方式
    │       ├── 生命周期分析
    │       └── 借用图检查
    │
    └──→ 保证
            ├── 无数据竞争
            ├── 无悬垂指针
            └── 零运行时开销
```

---

**下一步**: [理解生命周期](./TUTORIAL_LIFETIMES.md)

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-24
**状态**: ✅ 已完成 - 教程：借用检查器工作原理 (2/5教程)
