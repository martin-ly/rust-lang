# 认知论证框架

> **创建日期**: 2026-02-23
> **目标**: 建立给人看的形式化论证体系
> **核心**: 认知负荷管理 + 渐进式理解

---

## 一、论证层次模型

### 三层论证体系

```text
┌─────────────────────────────────────────────────────────┐
│  Layer 3: 机器可检查证明 (L3)                             │
│  - Coq/Lean形式化                                         │
│  - 绝对正确性保证                                         │
│  - 受众: 机器 + 形式化验证专家                             │
├─────────────────────────────────────────────────────────┤
│  Layer 2: 完整数学证明 (L2)                               │
│  - 详细数学推导                                           │
│  - 包含所有步骤和引理                                     │
│  - 受众: 理论研究者 + 核心贡献者                           │
├─────────────────────────────────────────────────────────┤
│  Layer 1: 证明思路与理解 (L1) ⭐ 本项目重点                │
│  - 核心思想 + 关键步骤                                     │
│  - 直观解释 + 类比                                         │
│  - 受众: 所有Rust学习者 + 工程师                           │
└─────────────────────────────────────────────────────────┘
```

### 本项目定位

**主要产出**: Layer 1 + 部分Layer 2
**目标读者**:

- Rust学习者（理解为什么Rust安全）
- 系统工程师（理解形式化保证）
- 技术决策者（评估Rust可靠性）

---

## 二、认知设计原则

### 原则1: 渐进式披露

**问题**: 形式化内容信息密度高，容易造成认知过载

**解决方案**:

```text
概念呈现方式:
├── 一句话定义 (快速理解)
├── 形式化表示 (精确性)
├── 代码示例 (具体化)
├── 图示说明 (可视化)
└── 反例对比 (边界理解)
```

**示例**: 所有权概念

```text
一句话: 每个值有且只有一个所有者

形式化: ∀v, ∃!x, owns(x, v)

代码:
    let x = String::from("hello");
    let y = x;  // 所有权转移
    // x 不再有效

图示: [x: owns("hello")] --move--> [y: owns("hello")]
                         [x: moved]

反例: C++中双指针指向同一内存，易重复释放
```

### 原则2: 多模态表征

**同一概念用多种形式呈现**:

| 模态 | 用途 | 示例 |
| :--- | :--- | :--- |
| **文本** | 精确描述 | 概念定义 |
| **公式** | 形式化精确 | ∀x, P(x) |
| **代码** | 可运行示例 | Rust代码 |
| **图表** | 关系可视化 | 所有权转移图 |
| **表格** | 对比分析 | Send/Sync矩阵 |
| **反例** | 边界理解 | 编译错误示例 |

### 原则3: 脚手架理论

**学习支持结构**:

```text
初学者路径:
    直观理解 → 简单示例 → 核心概念 → 形式化定义

进阶路径:
    形式化定义 → 定理陈述 → 证明思路 → 完整证明

专家路径:
    完整证明 → 机器形式化 → 工具实现
```

---

## 三、文档类型与认知功能

### 文档分类矩阵

| 文档类型 | 认知功能 | 目标读者 | 示例 |
| :--- | :--- | :--- | :--- |
| **概念百科** | 定义查找 | 所有学习者 | Formal Concepts Encyclopedia |
| **定理汇编** | 理解保证 | 进阶学习者 | Theorems and Proof Strategies |
| **思维导图** | 全景理解 | 初学者 | 概念族谱 |
| **决策树** | 实践指导 | 工程师 | 架构选型决策树 |
| **反例集** | 边界理解 | 所有学习者 | 编译错误示例 |
| **教程** | 渐进学习 | 初学者 | 学习路径 |
| **速查卡** | 快速参考 | 实践者 | Cheat Sheet |

### 认知负荷管理

**内在认知负荷**（内容本身复杂度）:

- 无法减少，但可分解
- 策略：分块呈现，逐步深入

**外在认知负荷**（呈现方式）:

- 可减少，通过优化设计
- 策略：清晰结构，一致格式

**关联认知负荷**（建立联系）:

- 应增加，促进理解
- 策略：类比、可视化、交叉引用

---

## 四、形式化 vs 可理解性平衡

### 平衡策略

```text
形式化程度
    │
    │         ★ 机器证明 (L3)
    │        ／
    │       ／
    │      ★ 完整证明 (L2)
    │     ／
    │    ／
    │   ★ 证明思路 (L1)  ← 本项目重点
    │  ／
    │ ／
    │★ 直观理解
    └─────────────────→ 可理解性
```

### 具体实践

**形式化符号的使用原则**:

1. **引入时解释**: 首次使用符号必须解释

   ```text
   ∀x: "对于所有x"（全称量词）
   ```

2. **渐进引入**: 先自然语言，后形式化

   ```text
   自然: 每个值只有一个所有者
   形式: ∀v, ∃!x, owns(x, v)
   ```

3. **并行呈现**: 形式化与自然语言对照

   ```text
   Γ ⊢ e : τ  （在上下文Γ中，表达式e具有类型τ）
   ```

4. **避免过度形式化**: 不牺牲可读性

   ```text
   差:  ∀Γ:Context, ∀e:Expr, ∀τ:Type, ...
   好:  对于任意上下文Γ，表达式e，类型τ，...
   ```

---

## 五、论证质量评估

### 评估维度

| 维度 | 指标 | 评估问题 |
| :--- | :--- | :--- |
| **准确性** | 形式正确性 | 定义是否精确？定理是否正确？ |
| **完整性** | 覆盖全面性 | 是否覆盖所有核心概念？ |
| **清晰性** | 表达清晰度 | 是否容易理解？ |
| **一致性** | 内部一致性 | 术语使用是否一致？ |
| **可访问性** | 学习门槛 | 目标读者能否理解？ |
| **实用性** | 实践价值 | 对编程是否有指导意义？ |

### 评估检查清单

**概念定义**:

- [ ] 一句话定义清晰
- [ ] 形式化定义精确
- [ ] 示例具体可运行
- [ ] 边界情况说明
- [ ] 与其他概念关系明确

**定理陈述**:

- [ ] 前提条件明确
- [ ] 结论清晰
- [ ] 直观解释提供
- [ ] 应用场景说明

**证明/论证**:

- [ ] 核心思想突出
- [ ] 关键步骤完整
- [ ] 难点有解释
- [ ] 反例/边界考虑

---

## 六、与其他形式化工作的区别

### 本项目 vs 传统形式化验证

| 方面 | 传统形式化验证 | 本项目 |
| :--- | :--- | :--- |
| **主要产出** | 机器证明 (Coq) | 给人看的文档 |
| **验证目标** | 绝对正确性 | 认知理解 |
| **受众** | 验证专家 | 广大开发者 |
| **重点** | 技术细节 | 概念清晰度 |
| **价值** | 数学保证 | 教育 + 工程指导 |

### 与Rust官方文档的区别

| 方面 | 官方文档 | 本项目 |
| :--- | :--- | :--- |
| **形式化程度** | 非形式化 | 半形式化 |
| **目标** | 学习使用 | 理解原理 |
| **深度** | 实践导向 | 理论 + 实践 |
| **范围** | 语言特性 | 形式化方法全景 |

---

## 七、持续改进机制

### 反馈收集

**读者反馈渠道**:

- 文档内反馈链接
- 社区讨论
- 学习路径完成率
- 概念理解测试

**迭代方向**:

1. 根据反馈优化表达
2. 补充缺失概念
3. 调整难度梯度
4. 增加可视化内容

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-23
**用途**: 指导给人看的形式化论证内容创建
