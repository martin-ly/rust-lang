# 概念对比表汇编

> **创建日期**: 2026-02-24
> **目标**: 通过对比理解概念差异
> **级别**: L1 (给人看的)

---

## 一、所有权相关对比

### Move vs Copy

| 特性 | Move | Copy |
| :--- | :--- | :--- |
| **所有权** | 转移 | 复制 |
| **原变量** | 无效 | 仍有效 |
| **性能** | O(1)指针复制 | 视大小而定 |
| **实现条件** | 默认 | 只含标量值 |
| **示例类型** | `String`, `Vec<T>` | `i32`, `bool`, `(i32, i32)` |
| **使用场景** | 转移资源所有权 | 简单值复制 |

### &T vs &mut T

| 特性 | &T (不可变借用) | &mut T (可变借用) |
| :--- | :--- | :--- |
| **读** | ✅ | ✅ |
| **写** | ❌ | ✅ |
| **数量** | 多个 | 只能一个 |
| **与其他借用共存** | 可以 | 不能 |
| **排他性** | 共享 | 独占 |
| **类比** | 多人阅读 | 一个人修改 |

### Box vs Rc vs Arc

| 特性 | Box<T> | Rc<T> | Arc<T> |
| :--- | :--- | :--- | :--- |
| **所有权** | 唯一 | 共享 | 共享 |
| **线程安全** | ✅ | ❌ | ✅ |
| **引用计数** | 无 | 非原子 | 原子 |
| **开销** | 最低 | 低 | 中等 |
| **克隆行为** | 转移所有权 | 引用+1 | 引用+1 |
| **使用场景** | 堆分配唯一值 | 单线程共享 | 多线程共享 |

### Cell vs RefCell vs Mutex vs RwLock

| 特性 | Cell<T> | RefCell<T> | Mutex<T> | RwLock<T> |
| :--- | :--- | :--- | :--- | :--- |
| **线程安全** | ❌ | ❌ | ✅ | ✅ |
| **检查时机** | 编译时 | 运行时 | 运行时 | 运行时 |
| **借用检查** | 无（ Copy类型） | 有 | 有 | 有 |
| **并发读** | N/A | N/A | ❌ | ✅ |
| **适用类型** | Copy类型 | 任意 | 任意 | 任意 |
| **性能** | 最高 | 高 | 中等 | 中等 |
| **典型错误** | 无 | BorrowMutError | Deadlock | Deadlock |

---

## 二、类型系统对比

### impl Trait vs dyn Trait

| 特性 | impl Trait | dyn Trait |
| :--- | :--- | :--- |
| **分发方式** | 静态 | 动态 |
| **运行时开销** | 无 | 虚表查找 |
| **代码生成** | 单态化 | 统一接口 |
| **编译时大小** | 大（代码膨胀） | 小 |
| **运行时大小** | 小 | 大（胖指针） |
| **使用场景** | 性能敏感 | 需要运行时多态 |
| **返回类型** | ✅ 支持 | ⚠️ 需要Box |

### Sized vs ?Sized

| 特性 | Sized | ?Sized (DST) |
| :--- | :--- | :--- |
| **编译时大小** | 已知 | 未知 |
| **使用位置** | 栈/寄存器 | 必须间接（&/Box） |
| **示例** | i32, String | str, [i32], dyn Trait |
| **泛型默认** | ✅ | 需显式标注 |
| **使用场景** | 通用 | 特化场景 |

### 型变对比

| 类型构造器 | 型变 | 说明 | 示例 |
| :--- | :--- | :--- | :--- |
| `Box<T>` | 协变(+) | 保持方向 | `Box<&'static str> <: Box<&'a str>` |
| `Vec<T>` | 协变(+) | 保持方向 | `Vec<&'static str> <: Vec<&'a str>` |
| `Option<T>` | 协变(+) | 保持方向 | `Option<&'static str> <: Option<&'a str>` |
| `fn(T)` | 逆变(-) | 反转方向 | `fn(&'a str) <: fn(&'static str)` |
| `fn() -> T` | 协变(+) | 保持方向 | `fn() -> &'static str <: fn() -> &'a str` |
| `&mut T` | 不变(=) | 必须相同 | `&mut &'static str` 与 `&mut &'a str` 无关 |
| `Cell<T>` | 不变(=) | 必须相同 | `Cell<&'static str>` 独立 |

---

## 三、并发对比

### Send vs Sync

| 特性 | Send | Sync |
| :--- | :--- | :--- |
| **含义** | 可跨线程转移 | 可跨线程共享 |
| **等价定义** | T: Send | &T: Send |
| **示例类型** | i32, String, Arc<T> | i32, String, Arc<T> |
| **非示例** | Rc<T>, *const T | Cell<T>, RefCell<T>, Rc<T> |
| **保证** | 线程间转移安全 | 线程间共享安全 |
| **同时满足** | 可以 | 可以 |

### thread::spawn vs tokio::spawn

| 特性 | thread::spawn | tokio::spawn |
| :--- | :--- | :--- |
| **创建** | OS线程 | 异步任务 |
| **成本** | ~MB栈空间 | ~KB上下文 |
| **数量限制** | ~几百 | ~数百万 |
| **切换成本** | 高（内核） | 低（用户态） |
| **适用场景** | CPU密集型 | IO密集型 |
| **阻塞操作** | 可以 | 必须避免 |

### Mutex vs RwLock

| 特性 | Mutex | RwLock |
| :--- | :--- | :--- |
| **读并发** | ❌ 独占 | ✅ 共享 |
| **写并发** | ❌ 独占 | ❌ 独占 |
| **实现** | 简单 | 复杂 |
| **性能** | 高 | 读高/写中等 |
| **写者饥饿** | 无 | 可能 |
| **使用场景** | 通用 | 读多写少 |
| **推荐** | 默认选择 | 明确读多写少 |

---

## 四、异步对比

### async fn vs 普通fn

| 特性 | fn | async fn |
| :--- | :--- | :--- |
| **返回值** | 立即返回 | 返回Future |
| **执行** | 立即执行 | 惰性求值 |
| **状态** | 无 | 状态机 |
| **挂起** | 不能 | .await处可以 |
| **运行时** | 不需要 | 需要 |
| **传染性** | 无 | 调用者需await |

### Future vs Task

| 特性 | Future | Task |
| :--- | :--- | :--- |
| **定义** | 异步计算描述 | 运行时调度单位 |
| **创建** | async块/async fn | tokio::spawn |
| **执行** | 惰性 | 立即加入调度 |
| **取消** | 通过Drop | 通过AbortHandle |
| **并发** | 单描述 | 可真正并行 |

### Pin<&mut T> vs &mut T

| 特性 | &mut T | Pin<&mut T> |
| :--- | :--- | :--- |
| **可移动** | ✅ | ❌ |
| **使用场景** | 通用 | 自引用结构 |
| **开销** | 无 | 无（零成本） |
| **安全保证** | 借用规则 | + 位置稳定 |
| **典型使用** | 通用借用 | async/await |

---

## 五、分布式模式对比

### Saga vs 2PC

| 特性 | Saga | 2PC |
| :--- | :--- | :--- |
| **一致性** | 最终一致 | 强一致 |
| **复杂度** | 中 | 高 |
| **性能** | 高 | 低（阻塞） |
| **故障恢复** | 补偿操作 | 协调者恢复 |
| **协调方式** | 编排/编制 | 集中协调 |
| **适用场景** | 长事务 | 短事务 |
| **隔离性** | 弱 | 强 |

### 编排式 vs 编制式 Saga

| 特性 | 编排式(Orchestration) | 编制式(Choreography) |
| :--- | :--- | :--- |
| **协调** | 集中协调器 | 事件驱动，各自决策 |
| **复杂度** | 协调器复杂 | 服务间耦合 |
| **可见性** | 高（集中） | 低（分散） |
| **灵活性** | 低 | 高 |
| **调试** | 容易 | 困难 |
| **适用场景** | 流程固定 | 流程灵活 |

### CQRS vs CRUD

| 特性 | CRUD | CQRS |
| :--- | :--- | :--- |
| **模型** | 统一 | 读写分离 |
| **复杂度** | 低 | 高 |
| **查询灵活性** | 受限于写模型 | 专门优化 |
| **一致性** | 立即 | 最终一致 |
| **适用场景** | 简单应用 | 读多写少 |
| **事件溯源** | 不需要 | 通常配合 |

---

## 六、工作流对比

### 编排 vs 编制

| 特性 | 编排(Orchestration) | 编制(Choreography) |
| :--- | :--- | :--- |
| **控制** | 集中 | 分散 |
| **可见性** | 高 | 低 |
| **耦合** | 低（服务只对接协调器） | 高（服务间直接通信） |
| **复杂度** | 协调器复杂 | 流程分散难理解 |
| **灵活性** | 低 | 高 |
| **典型实现** | Temporal/Camunda | 事件驱动架构 |

### 向后补偿 vs 向前补偿

| 特性 | 向后补偿 | 向前补偿 |
| :--- | :--- | :--- |
| **方向** | 撤销已执行操作 | 继续执行补偿操作 |
| **语义** | 回滚 | 修正 |
| **复杂度** | 高（需要补偿逻辑） | 中 |
| **适用场景** | 标准Saga | 可交换更新 |
| **示例** | 退款、释放库存 | 发送纠正通知 |

---

## 七、证明层级对比

### L1 vs L2 vs L3

| 特性 | L1 (证明思路) | L2 (完整证明) | L3 (机器证明) |
| :--- | :--- | :--- | :--- |
| **详细程度** | 核心思想 | 完整步骤 | 完全形式化 |
| **受众** | 所有人 | 研究者 | 机器+专家 |
| **验证** | 人工审查 | 人工审查 | 机器验证 |
| **工作量** | 低 | 中 | 高 |
| **形式化程度** | 低 | 中 | 高 |
| **可读性** | 高 | 中 | 低 |
| **本项目优先级** | ⭐⭐⭐ 高 | ⭐⭐⭐ 高 | ⭐⭐ 中 |

---

## 八、快速决策表

### 选择何种智能指针？

```
需要唯一所有权？
├── 是 → Box<T>
└── 否（需要共享）
    ├── 单线程？
    │   ├── 是 → Rc<T>
    │   └── 否（多线程） → Arc<T>
    └── 需要内部可变性？
        ├── 是 → Rc<RefCell<T>> / Arc<Mutex<T>>
        └── 否 → Rc<T> / Arc<T>
```

### 选择何种锁？

```
读多写少？
├── 是 → RwLock<T>
└── 否
    ├── 需要升级锁（读→写）？
    │   ├── 是 → RwLock<T>（注意死锁）
    │   └── 否 → Mutex<T>（默认推荐）
```

### 选择何种并发模型？

```
CPU密集型？
├── 是 → thread::spawn
└── 否（IO密集型）
    └── tokio::spawn
```

### 选择何种事务模式？

```
事务短？
├── 是 → 2PC
└── 否（长事务）
    └── Saga模式
        ├── 流程固定？
        │   ├── 是 → 编排式
        │   └── 否 → 编制式
        └── 可交换更新？
            ├── 是 → 向前补偿
            └── 否 → 向后补偿
```

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-24
**状态**: ✅ 已完成 - 概念对比表汇编
