# å†…å­˜åˆ†æ

> **åˆ›å»ºæ—¥æœŸ**: 2025-01-27
> **æœ€åæ›´æ–°**: 2025-11-15
> **Rust ç‰ˆæœ¬**: 1.91.1+ (Edition 2024) âœ…
> **çŠ¶æ€**: ğŸ”„ è¿›è¡Œä¸­

---

## ğŸ“Š ç›®å½•

- [å†…å­˜åˆ†æ](#å†…å­˜åˆ†æ)
  - [ğŸ“Š ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ ç ”ç©¶ç›®æ ‡](#-ç ”ç©¶ç›®æ ‡)
    - [æ ¸å¿ƒé—®é¢˜](#æ ¸å¿ƒé—®é¢˜)
    - [é¢„æœŸæˆæœ](#é¢„æœŸæˆæœ)
  - [ğŸ“š ç†è®ºåŸºç¡€](#-ç†è®ºåŸºç¡€)
    - [å†…å­˜æ¨¡å‹](#å†…å­˜æ¨¡å‹)
    - [å†…å­˜åˆ†ææŒ‡æ ‡](#å†…å­˜åˆ†ææŒ‡æ ‡)
    - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
    - [ç†è®ºèƒŒæ™¯](#ç†è®ºèƒŒæ™¯)
  - [ğŸ”¬ å®éªŒè®¾è®¡](#-å®éªŒè®¾è®¡)
    - [1. å†…å­˜åˆ†æå·¥å…·](#1-å†…å­˜åˆ†æå·¥å…·)
    - [2. æµ‹è¯•åœºæ™¯](#2-æµ‹è¯•åœºæ™¯)
    - [3. æ•°æ®æ”¶é›†](#3-æ•°æ®æ”¶é›†)
  - [ğŸ“Š å®éªŒç»“æœ](#-å®éªŒç»“æœ)
    - [å¾…æµ‹è¯•çš„åœºæ™¯](#å¾…æµ‹è¯•çš„åœºæ™¯)
    - [ç»“æœåˆ†æ](#ç»“æœåˆ†æ)
  - [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
    - [ç¤ºä¾‹ 1: å†…å­˜ä½¿ç”¨ç»Ÿè®¡](#ç¤ºä¾‹-1-å†…å­˜ä½¿ç”¨ç»Ÿè®¡)
    - [ç¤ºä¾‹ 2: å†…å­˜æ³„æ¼æ£€æµ‹](#ç¤ºä¾‹-2-å†…å­˜æ³„æ¼æ£€æµ‹)
    - [ç¤ºä¾‹ 3: å†…å­˜ä¼˜åŒ–](#ç¤ºä¾‹-3-å†…å­˜ä¼˜åŒ–)
  - [ğŸ“– å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)
    - [å·¥å…·æ–‡æ¡£](#å·¥å…·æ–‡æ¡£)
    - [ç›¸å…³ä»£ç ](#ç›¸å…³ä»£ç )
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ”„ ç ”ç©¶è¿›å±•](#-ç ”ç©¶è¿›å±•)
    - [å·²å®Œæˆ âœ…](#å·²å®Œæˆ-)
    - [è¿›è¡Œä¸­ ğŸ”„](#è¿›è¡Œä¸­-)
    - [è®¡åˆ’ä¸­ ğŸ“‹](#è®¡åˆ’ä¸­-)
  - [ğŸ†• Rust 1.91.1 æ›´æ–°å†…å®¹](#-rust-1911-æ›´æ–°å†…å®¹)
    - [å†…å­˜åˆ†é…ä¼˜åŒ–](#å†…å­˜åˆ†é…ä¼˜åŒ–)
    - [å†…å­˜ä½¿ç”¨æ¨¡å¼ä¼˜åŒ–](#å†…å­˜ä½¿ç”¨æ¨¡å¼ä¼˜åŒ–)

---

## ğŸ¯ ç ”ç©¶ç›®æ ‡

æœ¬ç ”ç©¶çš„ç›®çš„æ˜¯åˆ†æ Rust ç¨‹åºçš„å†…å­˜ä½¿ç”¨æ¨¡å¼ï¼Œè¯†åˆ«å†…å­˜ä¼˜åŒ–æœºä¼šã€‚

### æ ¸å¿ƒé—®é¢˜

1. **å†…å­˜ä½¿ç”¨æ¨¡å¼**: ä¸åŒæ•°æ®ç»“æ„çš„å†…å­˜ä½¿ç”¨æ¨¡å¼å¦‚ä½•ï¼Ÿ
2. **å†…å­˜åˆ†é…**: å¦‚ä½•ä¼˜åŒ–å†…å­˜åˆ†é…ï¼Ÿ
3. **å†…å­˜æ³„æ¼**: å¦‚ä½•æ£€æµ‹å’Œä¿®å¤å†…å­˜æ³„æ¼ï¼Ÿ

### é¢„æœŸæˆæœ

- å†…å­˜ä½¿ç”¨åˆ†ææŠ¥å‘Š
- å†…å­˜ä¼˜åŒ–å»ºè®®
- å†…å­˜æ³„æ¼æ£€æµ‹æ–¹æ³•

---

## ğŸ“š ç†è®ºåŸºç¡€

### å†…å­˜æ¨¡å‹

**æ ˆå†…å­˜ (Stack Memory)**: å‡½æ•°è°ƒç”¨æ ˆï¼Œè‡ªåŠ¨ç®¡ç†ã€‚æ ˆå†…å­˜ç”¨äºå­˜å‚¨å±€éƒ¨å˜é‡å’Œå‡½æ•°è°ƒç”¨ä¿¡æ¯ï¼Œå…·æœ‰åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰çš„ç‰¹æ€§ã€‚

**å †å†…å­˜ (Heap Memory)**: åŠ¨æ€åˆ†é…ï¼Œæ‰‹åŠ¨æˆ–è‡ªåŠ¨ç®¡ç†ã€‚å †å†…å­˜ç”¨äºå­˜å‚¨åŠ¨æ€åˆ†é…çš„æ•°æ®ï¼Œéœ€è¦æ˜¾å¼åˆ†é…å’Œé‡Šæ”¾ã€‚

**é™æ€å†…å­˜ (Static Memory)**: å…¨å±€å˜é‡å’Œå¸¸é‡ã€‚é™æ€å†…å­˜åœ¨ç¨‹åºå¯åŠ¨æ—¶åˆ†é…ï¼Œåœ¨ç¨‹åºç»“æŸæ—¶é‡Šæ”¾ã€‚

### å†…å­˜åˆ†ææŒ‡æ ‡

**å†…å­˜ä½¿ç”¨é‡ (Memory Usage)**: ç¨‹åºä½¿ç”¨çš„å†…å­˜æ€»é‡ï¼ŒåŒ…æ‹¬æ ˆå†…å­˜ã€å †å†…å­˜å’Œé™æ€å†…å­˜ã€‚å†…å­˜ä½¿ç”¨é‡åæ˜ äº†ç¨‹åºçš„å†…å­˜éœ€æ±‚ã€‚

**å†…å­˜æ³„æ¼ (Memory Leak)**: æœªé‡Šæ”¾çš„å†…å­˜ï¼Œå¯¼è‡´å†…å­˜ä½¿ç”¨é‡æŒç»­å¢é•¿ã€‚å†…å­˜æ³„æ¼ä¼šå¯¼è‡´ç¨‹åºæœ€ç»ˆè€—å°½å¯ç”¨å†…å­˜ã€‚

**å†…å­˜ç¢ç‰‡ (Memory Fragmentation)**: å†…å­˜ç¢ç‰‡åŒ–ç¨‹åº¦ï¼ŒæŒ‡å†…å­˜ä¸­å­˜åœ¨å¤§é‡å°çš„ã€ä¸è¿ç»­çš„ç©ºé—²å—ã€‚å†…å­˜ç¢ç‰‡ä¼šé™ä½å†…å­˜åˆ†é…æ•ˆç‡ã€‚

**åˆ†é…æ¨¡å¼ (Allocation Pattern)**: å†…å­˜åˆ†é…çš„æ¨¡å¼ï¼ŒåŒ…æ‹¬åˆ†é…é¢‘ç‡ã€åˆ†é…å¤§å°ã€åˆ†é…ä½ç½®ç­‰ã€‚åˆ†é…æ¨¡å¼å½±å“å†…å­˜ä½¿ç”¨æ•ˆç‡ã€‚

### ç›¸å…³æ¦‚å¿µ

**å†…å­˜åˆ†é…å™¨ (Memory Allocator)**: è´Ÿè´£ç®¡ç†å †å†…å­˜åˆ†é…å’Œé‡Šæ”¾çš„ç»„ä»¶ã€‚Rust ä½¿ç”¨ç³»ç»Ÿåˆ†é…å™¨æˆ–è‡ªå®šä¹‰åˆ†é…å™¨ã€‚

**å†…å­˜å¯¹é½ (Memory Alignment)**: æ•°æ®åœ¨å†…å­˜ä¸­çš„å¯¹é½æ–¹å¼ï¼Œå½±å“å†…å­˜è®¿é—®æ•ˆç‡å’Œå†…å­˜ä½¿ç”¨ã€‚

**å†…å­˜æ±  (Memory Pool)**: é¢„åˆ†é…çš„å†…å­˜å—ï¼Œç”¨äºå¿«é€Ÿåˆ†é…å’Œé‡Šæ”¾ã€‚å†…å­˜æ± å¯ä»¥å‡å°‘å†…å­˜åˆ†é…å¼€é”€ã€‚

**åƒåœ¾å›æ”¶ (Garbage Collection)**: è‡ªåŠ¨ç®¡ç†å†…å­˜çš„æœºåˆ¶ï¼Œè‡ªåŠ¨è¯†åˆ«å’Œå›æ”¶ä¸å†ä½¿ç”¨çš„å†…å­˜ã€‚Rust ä¸ä½¿ç”¨åƒåœ¾å›æ”¶ï¼Œè€Œæ˜¯ä½¿ç”¨æ‰€æœ‰æƒç³»ç»Ÿã€‚

**å¼•ç”¨è®¡æ•° (Reference Counting)**: é€šè¿‡å¼•ç”¨è®¡æ•°æ¥ç®¡ç†å†…å­˜çš„æœºåˆ¶ã€‚Rust çš„ `Rc` å’Œ `Arc` ä½¿ç”¨å¼•ç”¨è®¡æ•°ã€‚

**å†…å­˜å®‰å…¨ (Memory Safety)**: ä¿è¯ç¨‹åºä¸ä¼šè®¿é—®æ— æ•ˆå†…å­˜æˆ–å¯¼è‡´å†…å­˜é”™è¯¯çš„ç‰¹æ€§ã€‚Rust é€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ã€‚

**å†…å­˜åˆ†æå·¥å…· (Memory Profiling Tools)**: ç”¨äºåˆ†æç¨‹åºå†…å­˜ä½¿ç”¨çš„å·¥å…·ï¼Œå¦‚ Valgrindã€Miriã€heaptrack ç­‰ã€‚

**å†…å­˜è¿½è¸ª (Memory Tracing)**: è¿½è¸ªç¨‹åºçš„å†…å­˜åˆ†é…å’Œé‡Šæ”¾æ“ä½œï¼Œç”¨äºè¯†åˆ«å†…å­˜æ³„æ¼å’Œå†…å­˜ä½¿ç”¨æ¨¡å¼ã€‚

### ç†è®ºèƒŒæ™¯

**å†…å­˜ç®¡ç†ç†è®º (Memory Management Theory)**: ç ”ç©¶å¦‚ä½•æœ‰æ•ˆç®¡ç†ç¨‹åºå†…å­˜çš„ç†è®ºã€‚å†…å­˜ç®¡ç†ç†è®ºåŒ…æ‹¬åˆ†é…ç­–ç•¥ã€å›æ”¶ç­–ç•¥ã€ç¢ç‰‡æ•´ç†ç­‰ã€‚

**å†…å­˜æ¨¡å‹ç†è®º (Memory Model Theory)**: ç ”ç©¶ç¨‹åºå†…å­˜æ¨¡å‹çš„å½¢å¼åŒ–ç†è®ºã€‚å†…å­˜æ¨¡å‹ç†è®ºå®šä¹‰äº†å†…å­˜æ“ä½œçš„è¯­ä¹‰å’Œçº¦æŸã€‚

**å†…å­˜å®‰å…¨ç†è®º (Memory Safety Theory)**: ç ”ç©¶å¦‚ä½•ä¿è¯ç¨‹åºå†…å­˜å®‰å…¨çš„ç†è®ºã€‚Rust çš„æ‰€æœ‰æƒç³»ç»ŸåŸºäºå†…å­˜å®‰å…¨ç†è®ºã€‚

**æ€§èƒ½åˆ†æç†è®º (Performance Analysis Theory)**: ç ”ç©¶å¦‚ä½•åˆ†æç¨‹åºæ€§èƒ½çš„ç†è®ºã€‚å†…å­˜åˆ†ææ˜¯æ€§èƒ½åˆ†æçš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚

---

## ğŸ”¬ å®éªŒè®¾è®¡

### 1. å†…å­˜åˆ†æå·¥å…·

ä½¿ç”¨ä»¥ä¸‹å·¥å…·è¿›è¡Œå†…å­˜åˆ†æï¼š

- **Valgrind**: å†…å­˜é”™è¯¯æ£€æµ‹å·¥å…·
- **heaptrack**: å †å†…å­˜åˆ†æå·¥å…·
- **memory-stats**: Rust å†…å­˜ç»Ÿè®¡åº“
- **dhat**: å †åˆ†æå·¥å…·

### 2. æµ‹è¯•åœºæ™¯

- **æ•°æ®ç»“æ„å†…å­˜**: æµ‹è¯•ä¸åŒæ•°æ®ç»“æ„çš„å†…å­˜ä½¿ç”¨
- **åˆ†é…ç­–ç•¥**: æµ‹è¯•ä¸åŒå†…å­˜åˆ†é…ç­–ç•¥
- **å†…å­˜æ³„æ¼**: æµ‹è¯•å†…å­˜æ³„æ¼æ£€æµ‹
- **å†…å­˜ä¼˜åŒ–**: æµ‹è¯•å†…å­˜ä¼˜åŒ–æ•ˆæœ

### 3. æ•°æ®æ”¶é›†

- **å†…å­˜ä½¿ç”¨é‡**: æ”¶é›†å†…å­˜ä½¿ç”¨é‡æ•°æ®
- **åˆ†é…æ¨¡å¼**: æ”¶é›†å†…å­˜åˆ†é…æ¨¡å¼
- **æ€§èƒ½å½±å“**: æ”¶é›†å†…å­˜å¯¹æ€§èƒ½çš„å½±å“

---

## ğŸ“Š å®éªŒç»“æœ

### å¾…æµ‹è¯•çš„åœºæ™¯

1. **æ•°æ®ç»“æ„å†…å­˜**: ä¸åŒæ•°æ®ç»“æ„çš„å†…å­˜ä½¿ç”¨æ¯”è¾ƒ
2. **åˆ†é…å™¨æ€§èƒ½**: ä¸åŒåˆ†é…å™¨çš„æ€§èƒ½æ¯”è¾ƒ
3. **å†…å­˜ä¼˜åŒ–**: å†…å­˜ä¼˜åŒ–çš„æ•ˆæœè¯„ä¼°
4. **å†…å­˜æ³„æ¼**: å†…å­˜æ³„æ¼çš„æ£€æµ‹å’Œä¿®å¤

### ç»“æœåˆ†æ

- **å†…å­˜ä½¿ç”¨å¯¹æ¯”**: å¯¹æ¯”ä¸åŒå®ç°çš„å†…å­˜ä½¿ç”¨
- **ä¼˜åŒ–æœºä¼š**: è¯†åˆ«å†…å­˜ä¼˜åŒ–æœºä¼š
- **ä¼˜åŒ–å»ºè®®**: æä¾›å†…å­˜ä¼˜åŒ–å»ºè®®

---

## ğŸ’» ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹ 1: å†…å­˜ä½¿ç”¨ç»Ÿè®¡

```rust
use std::alloc::{GlobalAlloc, Layout, System};

struct MemoryStats {
    allocations: usize,
    total_bytes: usize,
}

static mut STATS: MemoryStats = MemoryStats {
    allocations: 0,
    total_bytes: 0,
};

struct TrackingAllocator;

unsafe impl GlobalAlloc for TrackingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ptr = System.alloc(layout);
        if !ptr.is_null() {
            unsafe {
                STATS.allocations += 1;
                STATS.total_bytes += layout.size();
            }
        }
        ptr
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        unsafe {
            STATS.total_bytes -= layout.size();
        }
    }
}

#[global_allocator]
static GLOBAL: TrackingAllocator = TrackingAllocator;

fn main() {
    let vec: Vec<i32> = (0..1000).collect();

    unsafe {
        println!("åˆ†é…æ¬¡æ•°: {}", STATS.allocations);
        println!("æ€»å­—èŠ‚æ•°: {}", STATS.total_bytes);
    }
}
```

### ç¤ºä¾‹ 2: å†…å­˜æ³„æ¼æ£€æµ‹

```rust
use std::cell::RefCell;

thread_local! {
    static ALLOCATIONS: RefCell<Vec<*const u8>> = RefCell::new(Vec::new());
}

fn track_allocation(ptr: *const u8) {
    ALLOCATIONS.with(|allocations| {
        allocations.borrow_mut().push(ptr);
    });
}

fn check_leaks() {
    ALLOCATIONS.with(|allocations| {
        let count = allocations.borrow().len();
        if count > 0 {
            println!("æ£€æµ‹åˆ° {} ä¸ªæ½œåœ¨å†…å­˜æ³„æ¼", count);
        }
    });
}

fn main() {
    let ptr = Box::into_raw(Box::new(42));
    track_allocation(ptr);

    // å¿˜è®°é‡Šæ”¾
    // unsafe { Box::from_raw(ptr); }

    check_leaks();
}
```

### ç¤ºä¾‹ 3: å†…å­˜ä¼˜åŒ–

```rust
// ä¼˜åŒ–å‰ï¼šä½¿ç”¨ Vec
fn process_data_naive(data: &[i32]) -> Vec<i32> {
    data.iter().map(|x| x * 2).collect()
}

// ä¼˜åŒ–åï¼šä½¿ç”¨è¿­ä»£å™¨ï¼Œå»¶è¿Ÿåˆ†é…
fn process_data_optimized(data: &[i32]) -> impl Iterator<Item = i32> + '_ {
    data.iter().map(|x| x * 2)
}

fn main() {
    let data: Vec<i32> = (0..1000).collect();

    // ä¼˜åŒ–å‰ï¼šç«‹å³åˆ†é…å†…å­˜
    let result1 = process_data_naive(&data);

    // ä¼˜åŒ–åï¼šå»¶è¿Ÿåˆ†é…ï¼ŒæŒ‰éœ€è®¡ç®—
    let result2: Vec<i32> = process_data_optimized(&data).collect();
}
```

---

## ğŸ“– å‚è€ƒæ–‡çŒ®

### å·¥å…·æ–‡æ¡£

- [Valgrind æ–‡æ¡£](https://valgrind.org/docs/manual/manual.html)
- [heaptrack æ–‡æ¡£](https://github.com/KDE/heaptrack)
- [dhat æ–‡æ¡£](https://github.com/nnethercote/dhat-rs)

### ç›¸å…³ä»£ç 

- [å†…å­˜åˆ†æå·¥å…·](../../../crates/c05_threads/benches/)
- [å†…å­˜ä¼˜åŒ–å®ç°](../../../crates/c01_ownership_borrow_scope/src/)

### æœ€ä½³å®è·µ

- [Rust å†…å­˜ä¼˜åŒ–æŒ‡å—](https://nnethercote.github.io/perf-book/heap-allocations.html)
- [å†…å­˜æ³„æ¼æ£€æµ‹](https://doc.rust-lang.org/book/ch15-06-reference-cycles.html)

---

## ğŸ”„ ç ”ç©¶è¿›å±•

### å·²å®Œæˆ âœ…

- [x] ç ”ç©¶ç›®æ ‡å®šä¹‰
- [x] ç†è®ºåŸºç¡€æ•´ç†ï¼ˆåŒ…æ‹¬ç†è®ºèƒŒæ™¯å’Œç›¸å…³æ¦‚å¿µï¼‰
- [x] å®éªŒè®¾è®¡æ¡†æ¶
- [x] åŸºæœ¬ä»£ç ç¤ºä¾‹

### è¿›è¡Œä¸­ ğŸ”„

- [ ] å…·ä½“å®éªŒè®¾è®¡
- [ ] æ•°æ®æ”¶é›†
- [ ] ç»“æœåˆ†æ

### è®¡åˆ’ä¸­ ğŸ“‹

- [ ] å†…å­˜ä¼˜åŒ–å»ºè®®
- [ ] å®é™…åº”ç”¨æ¡ˆä¾‹
- [ ] å·¥å…·æ”¹è¿›

---

**ç»´æŠ¤è€…**: Rust Performance Research Group
**æœ€åæ›´æ–°**: 2025-11-15
**çŠ¶æ€**: ğŸ”„ **è¿›è¡Œä¸­**

---

## ğŸ†• Rust 1.91.1 æ›´æ–°å†…å®¹

### å†…å­˜åˆ†é…ä¼˜åŒ–

**æ€§èƒ½æå‡**: å°å¯¹è±¡åˆ†é…æ€§èƒ½æå‡ 25-30%

**ç ”ç©¶å½±å“**:

- å°å¯¹è±¡åˆ†é…æ€§èƒ½æ˜¾è‘—æå‡
- å†…å­˜ç¢ç‰‡å‡å°‘
- éœ€è¦é‡æ–°è¯„ä¼°å†…å­˜åˆ†é…åŸºå‡†

**ç›¸å…³å®éªŒ**:

- å°å¯¹è±¡åˆ†é…æ€§èƒ½æµ‹è¯•
- å†…å­˜ç¢ç‰‡åˆ†æ
- å†…å­˜åˆ†é…å™¨æ€§èƒ½åŸºå‡†æµ‹è¯•

### å†…å­˜ä½¿ç”¨æ¨¡å¼ä¼˜åŒ–

**æ”¹è¿›**: HashMap æ“ä½œæ€§èƒ½æå‡ï¼Œå†…å­˜ç¢ç‰‡å‡å°‘

**ç ”ç©¶å½±å“**:

- HashMap æ“ä½œæ€§èƒ½æå‡
- å†…å­˜ä½¿ç”¨æ¨¡å¼ä¼˜åŒ–
- éœ€è¦é‡æ–°è¯„ä¼°å†…å­˜ä½¿ç”¨æ¨¡å¼

**ç›¸å…³å®éªŒ**:

- HashMap å†…å­˜ä½¿ç”¨åˆ†æ
- å†…å­˜ä½¿ç”¨æ¨¡å¼ä¼˜åŒ–æµ‹è¯•
- å†…å­˜åˆ†é…å™¨æ€§èƒ½å¯¹æ¯”
