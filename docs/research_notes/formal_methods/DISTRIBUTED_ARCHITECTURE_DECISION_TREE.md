# åˆ†å¸ƒå¼æ¶æ„é€‰å‹å†³ç­–æ ‘

> **åˆ›å»ºæ—¥æœŸ**: 2026-02-21
> **æœ€åæ›´æ–°**: 2026-02-21
> **çŠ¶æ€**: ğŸ†• æ–°å»º
> **å¯¹åº”ä»»åŠ¡**: P1-T11 / DT-3

---

## å†³ç­–æ ‘å…¨æ™¯

```text
æ„å»ºåˆ†å¸ƒå¼ç³»ç»Ÿ?
â”œâ”€â”€ éœ€è¦äº‹åŠ¡ä¸€è‡´æ€§?
â”‚   â”œâ”€â”€ å¼ºä¸€è‡´æ€§è¦æ±‚ (ACID)?
â”‚   â”‚   â”œâ”€â”€ æ˜¯ â†’ 2PC/3PC (éœ€å¤–éƒ¨åè°ƒå™¨å¦‚Atomikos)
â”‚   â”‚   â”‚   â”œâ”€â”€ çŸ­äº‹åŠ¡ (<1s) â†’ 2PC
â”‚   â”‚   â”‚   â””â”€â”€ é•¿äº‹åŠ¡æˆ–è·¨åœ°åŸŸ â†’ 3PC (é¿å…åè°ƒå™¨å•ç‚¹)
â”‚   â”‚   â””â”€â”€ å¦ â†’ æœ€ç»ˆä¸€è‡´æ€§
â”‚   â”‚       â”œâ”€â”€ é•¿äº‹åŠ¡ (>30s)?
â”‚   â”‚       â”‚   â”œâ”€â”€ æ˜¯ â†’ Sagaæ¨¡å¼
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ éœ€è¦ä¸­å¤®åè°ƒ? â†’ ç¼–æ’å¼Saga (Orchestration)
â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ æ¨è: Temporal/Cadence
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ æµç¨‹å¤æ‚ â†’ çŠ¶æ€æœºå·¥ä½œæµ
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ äº‹ä»¶é©±åŠ¨è‡ªæ²»? â†’ ç¼–åˆ¶å¼Saga (Choreography)
â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ å·²æœ‰æ¶ˆæ¯é˜Ÿåˆ— â†’ Kafka/RabbitMQ + äº‹ä»¶å¤„ç†å™¨
â”‚   â”‚       â”‚   â”‚       â””â”€â”€ æ¨è: äº‹ä»¶æº¯æº + Saga
â”‚   â”‚       â”‚   â””â”€â”€ è¡¥å¿ç­–ç•¥é€‰æ‹©
â”‚   â”‚       â”‚       â”œâ”€â”€ å‘åè¡¥å¿ â†’ æ ‡å‡†Saga (æ¨è)
â”‚   â”‚       â”‚       â””â”€â”€ å‘å‰è¡¥å¿ â†’ å¯äº¤æ¢æ›´æ–° (å¹‚ç­‰è®¾è®¡)
â”‚   â”‚       â””â”€â”€ çŸ­äº‹åŠ¡?
â”‚   â”‚           â””â”€â”€ Outboxæ¨¡å¼ + æ¶ˆæ¯ä»£ç†
â”‚   â”‚               â”œâ”€â”€ é«˜åå â†’ Kafka
â”‚   â”‚               â””â”€â”€ å¯é ä¼ é€’ â†’ RabbitMQ/ActiveMQ
â”‚   â””â”€â”€ è¯»å†™è´Ÿè½½åˆ†ç¦»?
â”‚       â”œâ”€â”€ æ˜¯ â†’ CQRSæ¨¡å¼
â”‚       â”‚   â”œâ”€â”€ è¯»æ¨¡å‹å»¶è¿Ÿå®¹å¿?
â”‚       â”‚   â”‚   â”œâ”€â”€ å³æ—¶ (<100ms) â†’ åŒæ­¥CQRS + 2PC
â”‚       â”‚   â”‚   â””â”€â”€ å¯å»¶è¿Ÿ (>1s) â†’ å¼‚æ­¥CQRS + äº‹ä»¶æº¯æº
â”‚       â”‚   â”œâ”€â”€ å†™æ“ä½œå¤æ‚? â†’ Event Sourcing (äº‹ä»¶æº¯æº)
â”‚   â”‚       â”‚   â”œâ”€â”€ å®¡è®¡è¦æ±‚ä¸¥æ ¼ â†’ å¿…é€‰Event Sourcing
â”‚   â”‚       â”‚   â””â”€â”€ çŠ¶æ€é‡å»ºæ€§èƒ½æ•æ„Ÿ â†’ å¿«ç…§ä¼˜åŒ–
â”‚   â”‚       â””â”€â”€ è¯»æ¨¡å‹å¤šæ ·æ€§?
â”‚   â”‚           â”œâ”€â”€ å¤šæŸ¥è¯¢æ¨¡å¼ â†’ å¤šç‰©åŒ–è§†å›¾
â”‚   â”‚           â””â”€â”€ æœç´¢éœ€æ±‚ â†’ CQRS + Elasticsearch
â”‚       â””â”€â”€ å¦ â†’ ç»Ÿä¸€æ¨¡å‹ (ä¼ ç»ŸCRUD)
â”‚           â””â”€â”€ è€ƒè™‘: ç®€å•æ€§ä¼˜å…ˆï¼Œé¿å…è¿‡åº¦è®¾è®¡
â”œâ”€â”€ å®¹é”™è¦æ±‚é«˜ (99.99%)?
â”‚   â”œâ”€â”€ æ˜¯ â†’ ç†”æ–­å™¨ + èˆ±å£ + é‡è¯•ç­–ç•¥ç»„åˆ
â”‚   â”‚   â”œâ”€â”€ å¿«é€Ÿå¤±è´¥ â†’ Circuit Breaker
â”‚   â”‚   â”‚   â”œâ”€â”€ å¤±è´¥ç‡é˜ˆå€¼ â†’ 50% (é»˜è®¤) æˆ–è‡ªå®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ æ¢å¤æ¢æµ‹ â†’ Half-OpençŠ¶æ€
â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: resilience4j / è‡ªå®šä¹‰çŠ¶æ€æœº
â”‚   â”‚   â”œâ”€â”€ èµ„æºéš”ç¦» â†’ Bulkheadæ¨¡å¼
â”‚   â”‚   â”‚   â”œâ”€â”€ çº¿ç¨‹æ± éš”ç¦» â†’ Hystrixé£æ ¼
â”‚   â”‚   â”‚   â””â”€â”€ ä¿¡å·é‡éš”ç¦» â†’ è½»é‡çº§
â”‚   â”‚   â””â”€â”€ é‡è¯•ç­–ç•¥
â”‚   â”‚       â”œâ”€â”€ ç«‹å³é‡è¯• (ç½‘ç»œæŠ–åŠ¨) â†’ æœ€å¤š1æ¬¡
â”‚   â”‚       â”œâ”€â”€ å›ºå®šé—´éš” â†’ å›ºå®šå»¶è¿Ÿ (å¦‚5s)
â”‚   â”‚       â”œâ”€â”€ çº¿æ€§é€€é¿ â†’ åˆå§‹1s, æ¯æ¬¡+1s
â”‚   â”‚       â””â”€â”€ æŒ‡æ•°é€€é¿ â†’ åˆå§‹1s, æ¯æ¬¡Ã—2, ä¸Šé™60s
â”‚   â””â”€â”€ å¦ â†’ ç®€å•è¶…æ—¶æ§åˆ¶
â”‚       â””â”€â”€ å›ºå®šè¶…æ—¶ â†’ åŸºäºP99å»¶è¿Ÿ
â”œâ”€â”€ æœåŠ¡é—´é€šä¿¡æ¨¡å¼?
â”‚   â”œâ”€â”€ åŒæ­¥è¯·æ±‚/å“åº”?
â”‚   â”‚   â”œâ”€â”€ ä½å»¶è¿Ÿ (<10ms) â†’ gRPC/HTTP2
â”‚   â”‚   â”‚   â””â”€â”€ éœ€è¦æµå¼? â†’ gRPC Streaming
â”‚   â”‚   â””â”€â”€ æ ‡å‡†REST â†’ HTTP/1.1 + JSON
â”‚   â”‚       â””â”€â”€ ç¼“å­˜å‹å¥½ â†’ é…åˆCache-Control
â”‚   â””â”€â”€ å¼‚æ­¥æ¶ˆæ¯?
â”‚       â”œâ”€â”€ ç‚¹å¯¹ç‚¹é˜Ÿåˆ— â†’ ä»»åŠ¡åˆ†å‘
â”‚       â”‚   â””â”€â”€  competing consumers â†’ å·¥ä½œé˜Ÿåˆ—
â”‚       â”œâ”€â”€ å‘å¸ƒè®¢é˜… â†’ äº‹ä»¶å¹¿æ’­
â”‚       â”‚   â””â”€â”€ å¤šè®¢é˜…è€… â†’ Kafkaåˆ†åŒº
â”‚       â””â”€â”€ è¯·æ±‚/å›å¤å¼‚æ­¥ â†’ å›è°ƒé˜Ÿåˆ— + Correlation ID
â”œâ”€â”€ æ•°æ®å­˜å‚¨ç­–ç•¥?
â”‚   â”œâ”€â”€ å•ä¸€æ•°æ®åº“?
â”‚   â”‚   â”œâ”€â”€ å…³ç³»å‹ â†’ PostgreSQL (æ¨è)
â”‚   â”‚   â””â”€â”€ NoSQL â†’ MongoDB/DynamoDB
â”‚   â””â”€â”€ å¤šå­˜å‚¨ (Polyglot Persistence)?
â”‚       â”œâ”€â”€ äº‹åŠ¡æ•°æ® â†’ PostgreSQL
â”‚       â”œâ”€â”€ ç¼“å­˜ â†’ Redis
â”‚       â”œâ”€â”€ æœç´¢ â†’ Elasticsearch
â”‚       â””â”€â”€ æ—¶åºæ•°æ® â†’ InfluxDB/TimescaleDB
â””â”€â”€ æœåŠ¡å‘ç°?
    â”œâ”€â”€ é›†ä¸­å¼æ³¨å†Œä¸­å¿ƒ
    â”‚   â”œâ”€â”€ Consul â†’ å¥åº·æ£€æŸ¥ + KVå­˜å‚¨
    â”‚   â”œâ”€â”€ Eureka â†’ Netflixç”Ÿæ€
    â”‚   â””â”€â”€ etcd â†’ KubernetesåŸç”Ÿ
    â””â”€â”€ å»ä¸­å¿ƒåŒ–
        â””â”€â”€  gossipåè®® â†’ Serf/Hashicorp
```

---

## å¿«é€Ÿå†³ç­–è¡¨

### æŒ‰åœºæ™¯æ¨è

| åœºæ™¯ | æ¨èæ¶æ„ | å…³é”®æ¨¡å¼ | æŠ€æœ¯æ ˆ |
| :--- | :--- | :--- | :--- |
| ç”µå•†è®¢å• | Saga + CQRS | ç¼–æ’å¼Saga, å¼‚æ­¥CQRS | Temporal, Kafka, PostgreSQL |
| é‡‘èæ”¯ä»˜ | å¼ºä¸€è‡´æ€§ä¼˜å…ˆ | 2PC + è¡¥å¿ | Atomikos, PostgreSQL |
| ç¤¾äº¤ç½‘ç»œ | æœ€ç»ˆä¸€è‡´æ€§ | CQRS + Event Sourcing | Kafka, Cassandra, ES |
| IoTæ•°æ® ingest | é«˜ååå¼‚æ­¥ | ç¼–åˆ¶å¼Saga | Kafka, TimescaleDB |
| å¾®æœåŠ¡APIç½‘å…³ | å®¹é”™ä¼˜å…ˆ | ç†”æ–­å™¨ + èˆ±å£ | resilience4j, Redis |

---

## Rust å®ç°æ˜ å°„

### Saga å®ç°

```rust
// ç¼–æ’å¼ Saga ç¤ºä¾‹
#[derive(Clone)]
struct OrderSaga {
    steps: Vec<Box<dyn SagaStep>>,
    compensations: Vec<Box<dyn CompensationAction>>,
}

#[async_trait]
trait SagaStep {
    async fn execute(&self, ctx: &SagaContext) -> Result<(), SagaError>;
}

#[async_trait]
trait CompensationAction {
    async fn compensate(&self, ctx: &SagaContext) -> Result<(), CompensateError>;
}
```

### Circuit Breaker å®ç°

```rust
use std::sync::atomic::{AtomicU32, Ordering};
use std::time::{Duration, Instant};

enum CircuitState {
    Closed,           // æ­£å¸¸
    Open(Instant),    // ç†”æ–­ï¼Œè®°å½•æ¢å¤æ—¶é—´
    HalfOpen,         // æ¢æµ‹
}

struct CircuitBreaker {
    state: std::sync::Mutex<CircuitState>,
    failure_count: AtomicU32,
    failure_threshold: u32,
    timeout: Duration,
}
```

### CQRS å®ç°

```rust
// Command Side
struct OrderCommandHandler {
    event_store: Box<dyn EventStore>,
}

impl OrderCommandHandler {
    async fn handle_create_order(&self, cmd: CreateOrder) -> Result<Vec<Event>, Error> {
        let order = Order::create(cmd)?;
        let events = order.uncommitted_events();
        self.event_store.append(events.clone()).await?;
        Ok(events)
    }
}

// Query Side
struct OrderQueryHandler {
    read_model: Box<dyn ReadModel>,
}

impl OrderQueryHandler {
    async fn get_order(&self, id: OrderId) -> Option<OrderView> {
        self.read_model.get(id).await
    }
}
```

---

## å†³ç­–è·¯å¾„ç¤ºä¾‹

### ç¤ºä¾‹ 1: ç”µå•†è®¢å•ç³»ç»Ÿ

```text
éœ€è¦äº‹åŠ¡ä¸€è‡´æ€§? æ˜¯ (è®¢å•åˆ›å»ºæ¶‰åŠåº“å­˜ã€æ”¯ä»˜ã€ç‰©æµ)
  â””â”€> å¼ºä¸€è‡´æ€§? å¦ (å…è®¸çŸ­æš‚ä¸ä¸€è‡´)
      â””â”€> é•¿äº‹åŠ¡? æ˜¯ (æ”¯ä»˜å¯èƒ½è€—æ—¶æ•°åˆ†é’Ÿ)
          â””â”€> éœ€è¦ä¸­å¤®åè°ƒ? æ˜¯ (æµç¨‹å¤æ‚)
              â””â”€> æ¨è: ç¼–æ’å¼ Saga + Temporal
```

**æ¶æ„**:

- Sagaåè°ƒå™¨: Temporal
- å‘½ä»¤ç«¯: Actix-web + PostgreSQL
- æŸ¥è¯¢ç«¯: Read model in Redis
- äº‹ä»¶æ€»çº¿: Kafka

### ç¤ºä¾‹ 2: å®æ—¶æ•°æ®åˆ†æ

```text
éœ€è¦äº‹åŠ¡ä¸€è‡´æ€§? å¦ (çº¯åˆ†æåœºæ™¯)
  â””â”€> å®¹é”™è¦æ±‚é«˜? æ˜¯ (99.9%å¯ç”¨æ€§)
      â””â”€> æ¨è: ç†”æ–­å™¨ + èˆ±å£ + å¼‚æ­¥å¤„ç†
```

**æ¶æ„**:

- æ•°æ®æ‘„å–: Kafka
- å¤„ç†: è‡ªç ”Rust stream processor
- ç†”æ–­: è‡ªå®šä¹‰å®ç°
- å­˜å‚¨: TimescaleDB

---

## ç›¸å…³æ¨¡å¼

| æ¨¡å¼ | è§£å†³çš„é—®é¢˜ | ç»„åˆå»ºè®® |
| :--- | :--- | :--- |
| Saga | é•¿äº‹åŠ¡ä¸€è‡´æ€§ | + Outbox (é˜²ä¸¢æ¶ˆæ¯) + Idempotent Consumer |
| CQRS | è¯»å†™è´Ÿè½½åˆ†ç¦» | + Event Sourcing (å®¡è®¡) + ç‰©åŒ–è§†å›¾ç¼“å­˜ |
| Circuit Breaker | çº§è”æ•…éšœé˜²æŠ¤ | + é‡è¯• + é™çº§ (Fallback) |
| Bulkhead | èµ„æºéš”ç¦» | + çº¿ç¨‹æ± éš”ç¦» + é˜Ÿåˆ—é™æµ |

---

## ç›¸å…³æ–‡æ¡£

- [åˆ†å¸ƒå¼æ¨¡å¼å½¢å¼åŒ–](../../coq_skeleton/DISTRIBUTED_PATTERNS.v)
- [Sagaè¯¦è§£](../../software_design_theory/04_compositional_engineering/)
- [å·¥ä½œæµæ¦‚å¿µæ—](./WORKFLOW_CONCEPT_MINDMAP.md)
- [éªŒè¯å·¥å…·å¯¹æ¯”](./VERIFICATION_TOOLS_MATRIX.md)

---

**ç»´æŠ¤è€…**: Rust Formal Methods Research Team
**å¯¹åº”ä»»åŠ¡**: P1-T11, DT-3 - åˆ†å¸ƒå¼æ¶æ„é€‰å‹å†³ç­–æ ‘
