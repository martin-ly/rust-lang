# 并发安全矩阵

> **创建日期**: 2026-02-24
> **最后更新**: 2026-02-28
> **状态**: ✅ 已扩展
> **版本**: Rust 1.93.1+ (Edition 2024)

---

## 概述

并发安全矩阵全面梳理 Rust 并发编程中的安全保证、同步原语、并发模式和常见陷阱，为并发程序的形式化验证提供参考框架。

---

## 一、Send/Sync 类型矩阵

### 基础规则

| 类型 | `Send` | `Sync` | 说明 |
| :--- | :--- | :--- | :--- |
| `i32`, `f64` 等原始类型 | ✅ | ✅ | 值类型天然线程安全 |
| `String`, `Vec<T>` | ✅(T:Send) | ✅(T:Send) | 拥有数据的集合 |
| `&T` | ✅(T:Sync) | ✅(T:Sync) | 共享引用 |
| `&mut T` | ✅(T:Send) | ❌ | 独占引用非Sync |
| `Box<T>` | ✅(T:Send) | ✅(T:Send) | 堆分配 |
| `Rc<T>` | ❌ | ❌ | 非原子计数 |
| `Arc<T>` | ✅(T:Send) | ✅(T:Sync) | 原子计数共享 |
| `RefCell<T>` | ✅(T) | ❌ | 运行时借用检查非Sync |
| `Mutex<T>` | ✅(T:Send) | ✅(T) | 提供Sync给T |
| `RwLock<T>` | ✅(T:Send) | ✅(T) | 读写锁 |
| `Cell<T>` | ✅(T) | ❌ | 内部可变非Sync |
| `UnsafeCell<T>` | ✅(T) | ❌ | 原始内部可变 |
| `*const T`, `*mut T` | ❌ | ❌ | 裸指针 |
| `PhantomData<T>` | ✅(T:Send) | ✅(T:Sync) | 标记类型 |

### 复合类型推导

| 复合类型 | `Send`条件 | `Sync`条件 |
| :--- | :--- | :--- |
| `struct S<T>(T)` | `T: Send` | `T: Sync` |
| `struct S<T, U>(T, U)` | `T: Send, U: Send` | `T: Sync, U: Sync` |
| `enum E<T, U> { A(T), B(U) }` | `T: Send, U: Send` | `T: Sync, U: Sync` |
| `Option<T>` | `T: Send` | `T: Sync` |
| `Result<T, E>` | `T: Send, E: Send` | `T: Sync, E: Sync` |

---

## 二、同步原语矩阵

### 互斥与锁

| 原语 | 公平性 | 阻塞类型 | 适用场景 | 开销 |
| :--- | :--- | :--- | :--- | :--- |
| `std::sync::Mutex` | 不保证 | 阻塞 | 通用互斥 | 中 |
| `std::sync::RwLock` | 不保证 | 阻塞 | 多读少写 | 中 |
| `parking_lot::Mutex` | 可选 | 阻塞 | 高性能 | 低 |
| `parking_lot::RwLock` | 可选 | 阻塞 | 高性能多读 | 低 |
| `tokio::sync::Mutex` | FIFO | 异步 | async环境 | 中 |
| `tokio::sync::RwLock` | FIFO | 异步 | async多读 | 中 |

### 原子操作

| 操作 | 内存序 | 使用场景 | 性能 |
| :--- | :--- | :--- | :--- |
| `Relaxed` | 无 | 计数器 | 最高 |
| `Acquire`/`Release` | 获取/释放 | 锁实现 | 高 |
| `AcqRel` | 获取+释放 | CAS操作 | 高 |
| `SeqCst` | 顺序一致 | 严格同步 | 较低 |

### 线程通信

| 机制 | 语义 | 容量 | 适用场景 |
| :--- | :--- | :--- | :--- |
| `mpsc::channel` | 多生产者单消费者 | 无限 | 任务分发 |
| `mpsc::sync_channel` | MPSC | 有限 | 背压控制 |
| `oneshot::channel` | 单值 | 1 | 请求-响应 |
| `broadcast::channel` | 广播 | 有限 | 事件通知 |
| `watch::channel` | 状态同步 | 1 | 配置更新 |

---

## 三、并发模式矩阵

### 数据共享模式

| 模式 | 所有权 | 同步 | 性能 | 复杂度 |
| :--- | :--- | :--- | :--- | :--- |
| **消息传递** | 转移 | 无 | 高 | 低 |
| **共享状态** | `Arc<Mutex<T>>` | 锁 | 中 | 中 |
| **读写分离** | `Arc<RwLock<T>>` | 读写锁 | 中高 | 中 |
| **线程局部** | 每线程独立 | 无 | 高 | 低 |
| **不可变共享** | `Arc<T>` | 无 | 最高 | 低 |

### 任务并行模式

| 模式 | 适用 | 工具 | 负载均衡 |
| :--- | :--- | :--- | :--- |
| **数据并行** | 大数据集 | `rayon` | 自动 |
| **任务窃取** | 不规则任务 | `tokio::task` | 工作窃取 |
| **分阶段并行** | 流水线 | 通道+线程 | 手动 |
| **Fork-Join** | 分治算法 | `rayon::join` | 自动 |

---

## 四、并发安全保证矩阵

| 保证 | 机制 | 验证方式 | 运行时开销 |
| :--- | :--- | :--- | :--- |
| **数据竞争自由** | 借用检查+Send/Sync | 编译期 | 无 |
| **内存安全** | 所有权系统 | 编译期 | 无 |
| **死锁避免** | 锁顺序/超时 | 代码审查 | 可选 |
| **活锁避免** | 退避策略 | 设计模式 | 低 |
| **公平性** | FIFO/优先级 | 原语选择 | 中 |

### 数据竞争条件分析

| 场景 | 条件1 | 条件2 | 条件3 | 是否竞争 |
| :--- | :--- | :--- | :--- | :--- |
| 双写 | 同一内存 | 两个写 | 无同步 | ❌ 禁止 |
| 读写 | 同一内存 | 读+写 | 无同步 | ❌ 禁止 |
| 安全读 | 同一内存 | 多个读 | - | ✅ 允许 |
| Mutex保护 | 同一内存 | 读写 | Mutex | ✅ 安全 |
| RwLock保护 | 同一内存 | 多读/单写 | RwLock | ✅ 安全 |

---

## 五、常见并发陷阱

### 死锁模式

| 模式 | 示例 | 解决方案 |
| :--- | :--- | :--- |
| **循环等待** | A锁B锁→B锁A锁 | 统一锁顺序 |
| **嵌套锁** | 持有锁A请求锁B | 锁层级/try_lock |
| **自死锁** | 同线程重复lock | 递归锁/reentrant |
| **跨对象死锁** | 对象A和B互相依赖 | 全局锁顺序 |

### 不安全并发

| 危险操作 | 后果 | 安全替代 |
| :--- | :--- | :--- |
| 裸指针共享 | 数据竞争 | `Arc<UnsafeCell<T>>` |
| `static mut` | 未定义行为 | `LazyLock<Mutex<T>>` |
| 遗忘`Send`边界 | 编译通过但危险 | 显式`unsafe impl` |
| 跨越await持有锁 | 阻塞executor | `MutexGuard`跨越问题 |

---

## 六、形式化规约

### Send/Sync 公理

```rust
// Axiom SEND1: Send类型可跨线程转移所有权
unsafe impl<T: Send> Send for Wrapper<T> {}

// Axiom SYNC1: Sync类型可跨线程共享引用
unsafe impl<T: Sync> Sync for Wrapper<T> {}
```

### 并发安全定理

**定理 CS-T1 (数据竞争自由)**:
若程序中所有共享状态访问都通过`Sync`类型，且所有权转移只通过`Send`类型，则程序无数据竞争。

**定理 CS-T2 (Mutex安全)**:
`Mutex<T>`提供互斥访问，保证同一时刻最多一个线程可访问`T`。

---

## 七、与Rust 1.93对应

| 1.93特性 | 并发影响 |
| :--- | :--- |
| `std::sync::LazyLock`稳定 | 懒初始化线程安全 |
| `Cell::update` | 单线程内部可变性增强 |
| `offset_of!` | 并发数据结构布局优化 |
| 标准库性能优化 | 锁开销降低 |

---

## 八、并发检查清单

```markdown
□ 所有跨线程类型实现 Send
□ 所有共享状态类型实现 Sync
□ 锁的持有时间最小化
□ 避免在锁内做I/O
□ 锁顺序一致避免死锁
□ 使用通道优先于共享状态
□ 考虑使用 parking_lot 替代 std
□ async代码中使用异步锁
```

---

## 类型安全矩阵

| 类型 | 跨线程移动 | 跨线程共享 | 要求 |
| :--- | :--- | :--- | :--- |
| `i32` | ✅ Send | ✅ Sync | 无时态依赖 |
| `String` | ✅ Send | ✅ Sync | 堆内存管理 |
| `Rc<T>` | ❌ | ❌ | 非原子计数 |
| `Arc<T>` | ✅ Send | ✅ Sync | 原子计数 |
| `RefCell<T>` | ✅ Send | ❌ | 运行时借用 |
| `Mutex<T>` | ✅ Send | ✅ Sync | 锁保护 |
| `Cell<T>` | ✅ Send | ❌ | 内部可变性 |
| `*const T` | ✅ Send | ✅ Sync | 原始指针 |

---

## 同步原语对比

| 原语 | 互斥 | 读写分离 | 条件变量 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| Mutex | ✅ | ❌ | ✅ | 通用互斥 |
| RwLock | ✅ | ✅ | ❌ | 多读少写 |
| Semaphore | ✅ | ❌ | ❌ | 资源限制 |
| Barrier | ❌ | ❌ | ❌ | 同步点 |
| Condvar | ❌ | ❌ | ✅ | 条件等待 |

---

## 通道类型对比

| 通道 | 多生产者 | 多消费者 | 缓冲 | 异步 |
| :--- | :--- | :--- | :--- | :--- |
| std::mpsc | ✅ | ❌ | ✅ | ❌ |
| crossbeam | ✅ | ✅ | ✅ | ❌ |
| tokio::sync | ✅ | ✅ | ✅ | ✅ |
| async-channel | ✅ | ✅ | ✅ | ✅ |

---

## 并发模式安全

| 模式 | 安全保证 | 风险 | 缓解 |
| :--- | :--- | :--- | :--- |
| 消息传递 | 无共享 | 死锁 | 超时 |
| 共享状态 | Mutex保护 | 死锁 | 锁顺序 |
| 原子操作 | 无锁 | ABA | CAS循环 |
| 无锁结构 | 内存序 | 复杂 | 专家审查 |

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-28
**状态**: ✅ 已扩展 - 并发安全矩阵完整版
