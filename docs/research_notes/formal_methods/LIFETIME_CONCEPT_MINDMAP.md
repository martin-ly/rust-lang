# 生命周期概念族谱

> **创建日期**: 2026-02-24
> **状态**: ✅ 新建 (15/15思维导图完成)
> **任务ID**: P1-W5-T3

---

## 生命周期概念全景

```text
                        生命周期概念族
                               │
        ┌──────────────────────┼──────────────────────┐
        │                      │                      │
   【生命周期参数】        【生命周期关系】        【特殊生命周期】
        │                      │                      │
    ├─'a (泛型)           ├─'a: 'b              ├─'static
    ├─'b                  │  (包含关系)           │  ├─程序整个运行期
    ├─'c                  │                      │  ├─字符串字面量
    │                     ├─子类型               │  ├─全局常量
    ├─'input              │  'static <: 'a       │  └─拥有所有权类型
    ├─'output             │                      │
    └─'_ (推断)           └─生命周期约束         ├─'_
       (自动推断)            ├─T: 'a               │  └─编译器推断
                              └─where 'a: 'b       │
                                                   └─匿名生命周期
                                                      └─函数体

                                      │
   【生命周期省略】           【生命周期在类型中】
        │                          │
    ├─规则1                      ├─&'a T
    │  每个引用参数               ├─&'a mut T
    │  有自己的生命周期           ├─struct Foo<'a>
    │                              ├─trait Bar<'a>
    ├─规则2                        └─impl<'a> Foo<'a>
    │  单一输入→输出
    │                              【NLL非词法生命周期】
    └─规则3                           │
       &self存在                      ├─基于使用位置
       →self的生命周期               ├─而非词法作用域
       赋给输出                       └─更准确推断
```

---

## 一、生命周期参数

### 1.1 泛型生命周期

```text
泛型生命周期
├── 'a, 'b, 'c ...
│   └── 惯例命名
│
├── 多生命周期
│   └── fn foo<'a, 'b>(x: &'a str, y: &'b str)
│
└── 显式标注位置
    ├── 函数参数
    ├── 返回值
    ├── 结构体字段
    └── trait实现
```

### 1.2 生命周期推断

```text
生命周期推断
├── '_
│   └── 让编译器推断
│
├── 函数签名
│   └── 编译器根据省略规则推断
│
└── impl块
    └── 编译器自动推断
```

---

## 二、生命周期关系

### 2.1 包含关系

```text
包含关系 ('a: 'b)
├── 定义
│   └── 'a 至少和 'b 一样长
│
├── 读法
│   └── "'a outlives 'b"
│
├── 方向
│   └── 长生命周期包含短生命周期
│
└─- 约束
    where 'a: 'b
```

### 2.2 子类型关系

```text
子类型关系
├── 'static <: 'a
│   └── 'static是任何'a的子类型
│
├── 协变性
│   └── &'static str <: &'a str
│
└── 使用场景
    └── 传递长生命周期给短生命周期参数
```

### 2.3 类型约束

```text
类型约束
├── T: 'a
│   └── T中所有引用至少存活'a
│
├── 结构体约束
│   struct Foo<'a, T: 'a> { ... }
│
└── 函数约束
    fn foo<'a, T: 'a>(x: &'a T)
```

---

## 三、特殊生命周期

### 3.1 'static

```text
'static
├── 定义
│   └── 整个程序运行期间有效
│
├── 来源
│   ├── 字符串字面量
│   │   └── let s: &'static str = "hello"
│   ├── 全局常量
│   │   └── const X: i32 = 5;
│   └── 拥有所有权的类型
│       └── String, Vec<T> (隐式)
│
└── 使用场景
    ├── 全局配置
    ├── 缓存数据
    └── 线程spawn
```

### 3.2 匿名生命周期

```text
匿名生命周期
├── 函数参数
│   └── fn foo(&str) → fn foo<'_>(&str)
│
└──  impl Trait
    └── impl<'_> Foo for Bar
```

---

## 四、生命周期省略

### 4.1 三条规则

```text
规则1: 每个引用参数有自己的生命周期
fn foo(x: &str, y: &str) → fn foo<'a, 'b>(x: &'a str, y: &'b str)

规则2: 只有一个输入生命周期 → 赋给所有输出
fn foo(x: &str) -> &str → fn foo<'a>(x: &'a str) -> &'a str

规则3: &self存在 → self的生命周期赋给输出
fn method(&self, x: &str) -> &str
  → fn method<'a, 'b>(&'a self, x: &'b str) -> &'a str
```

### 4.2 何时需要显式标注

```text
需要显式标注
├── 多个输入，一个输出
│   └── fn longest<'a>(x: &'a str, y: &'a str) -> &'a str
│
├── 输出与特定输入关联
│   └── fn get<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
│
└── 结构体包含引用
    struct Foo<'a> { x: &'a str }
```

---

## 五、生命周期在类型中

### 5.1 引用类型

```text
引用类型
├── &'a T
│   └── 不可变引用
│
├── &'a mut T
│   └── 可变引用
│
└── 嵌套
    &&'a T, &mut &'a T, etc.
```

### 5.2 结构体

```text
结构体生命周期
├── 声明
│   struct Foo<'a> { x: &'a str }
│
├── 多生命周期
│   struct Bar<'a, 'b> { x: &'a str, y: &'b str }
│
└── 约束
    struct Baz<'a, T: 'a> { x: &'a T }
```

### 5.3 Trait

```text
Trait生命周期
├── 声明
│   trait Foo<'a> { ... }
│
├── 实现
│   impl<'a> Foo<'a> for Bar { ... }
│
└── 使用
    fn use_foo<T: Foo<'static>>(x: T)
```

---

## 六、NLL (非词法生命周期)

### 6.1 概念

```text
NLL
├── 基于值的使用位置
│   └── 而非词法作用域
│
├── 好处
│   ├── 更准确的借用检查
│   └── 允许更多合法代码
│
└─- 示例
    let mut x = 5;
    let y = &x;
    println!("{}", y);  // y最后一次使用
    // 这里y已经结束，即使还在作用域内
    let z = &mut x;  // OK
```

---

## 七、常见模式

### 7.1 模式1: 相同生命周期

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str
```

### 7.2 模式2: 独立生命周期

```rust
fn parse<'a, 'b>(input: &'a str, config: &'b Config) -> &'a str
```

### 7.3 模式3: 返回self引用

```rust
impl<'a> Parser<'a> {
    fn input(&self) -> &'a str { self.input }
}
```

---

## 八、与所有权的关系

```text
生命周期基于所有权
        │
        ├──→ 引用不能比数据活得长
        │       └── 防止悬垂指针
        │
        ├──→ 借用规则
        │       └── 生命周期检查借用有效性
        │
        └──→ Drop顺序
                └── 先Drop引用，后Drop数据
```

---

## 九、学习路径

```text
学习生命周期
        │
        ├──→ 基础
        │       ├── 理解省略规则
        │       ├── 'static生命周期
        │       └── 显式标注
        │
        ├──→ 进阶
        │       ├── 生命周期约束
        │       ├── 多生命周期
        │       └── 结构体生命周期
        │
        └──→ 专家
                ├── 高级模式
                ├── 与类型系统结合
                └── 形式化理解
```

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-24
**状态**: ✅ 已完成 - 生命周期概念族谱 (15/15思维导图全部完成！)
