# 操作语义

> **创建日期**: 2026-02-28
> **最后更新**: 2026-02-28
> **状态**: ✅ 已完成
> **领域**: 程序语义学

---

## 概述

操作语义通过定义程序执行的步骤来精确描述程序行为。本文档建立Rust核心语言的操作语义框架，包括小步语义、大步语义和环境语义。

---

## 一、小步操作语义 (Small-Step Semantics)

### 1.1 基本概念

**配置**: `⟨e, σ⟩` 其中

- e: 表达式
- σ: 存储(内存状态)

**转换**: `⟨e, σ⟩ → ⟨e', σ'⟩`

- 表达式e在状态σ下一步归约为e'，新状态σ'

### 1.2 λ演算的小步语义

**β归约**:

```
⟨(λx.e) v, σ⟩ → ⟨e[v/x], σ⟩
```

**上下文规则**:

```
⟨e, σ⟩ → ⟨e', σ'⟩
─────────────────────
⟨E[e], σ⟩ → ⟨E[e'], σ'⟩

其中E是求值上下文
```

### 1.3 存储操作

**分配**:

```
⟨alloc(v), σ⟩ → ⟨l, σ[l ↦ v]⟩    (l ∉ dom(σ))
```

**读取**:

```
⟨!l, σ⟩ → ⟨v, σ⟩    (if σ(l) = v)
```

**写入**:

```
⟨l := v, σ⟩ → ⟨(), σ[l ↦ v]⟩
```

### 1.4 Rust特定规则

**移动**:

```
⟨let x = v; e, σ⟩ → ⟨e[v/x], σ⟩    (v是线性值)
```

**复制**:

```
⟨let x = v; e, σ⟩ → ⟨e[v/x], σ⟩    (v实现Copy)
```

**借用**:

```
⟨&x, σ⟩ → ⟨&l, σ⟩    (if x在σ中对应位置l)
```

---

## 二、大步操作语义 (Big-Step Semantics)

### 2.1 基本概念

**判断**: `⟨e, σ⟩ ⇓ ⟨v, σ'⟩`

- 表达式e在状态σ下求值为v，最终状态σ'

### 2.2 表达式规则

**值**:

```
⟨v, σ⟩ ⇓ ⟨v, σ⟩
```

**变量**:

```
⟨x, σ⟩ ⇓ ⟨σ(x), σ⟩
```

**函数应用**:

```
⟨e₁, σ⟩ ⇓ ⟨λx.e, σ₁⟩    ⟨e₂, σ₁⟩ ⇓ ⟨v₂, σ₂⟩    ⟨e[v₂/x], σ₂⟩ ⇓ ⟨v, σ'⟩
───────────────────────────────────────────────────────────────────────
                    ⟨e₁ e₂, σ⟩ ⇓ ⟨v, σ'⟩
```

**Let绑定**:

```
⟨e₁, σ⟩ ⇓ ⟨v₁, σ₁⟩    ⟨e₂[v₁/x], σ₁⟩ ⇓ ⟨v₂, σ'⟩
────────────────────────────────────────────────
        ⟨let x = e₁ in e₂, σ⟩ ⇓ ⟨v₂, σ'⟩
```

### 2.3 递归

**不动点**:

```
⟨fix(λf.λx.e), σ⟩ ⇓ ⟨λx.e[fix(λf.λx.e)/f], σ⟩
```

---

## 三、环境语义 (Environmental Semantics)

### 3.1 环境定义

**环境 ρ**: 变量到位置的映射
**存储 σ**: 位置到值的映射

**配置**: `⟨e, ρ, σ⟩`

### 3.2 规则

**变量查找**:

```
⟨x, ρ, σ⟩ → ⟨v, ρ, σ⟩    (if σ(ρ(x)) = v)
```

**闭包创建**:

```
⟨λx.e, ρ, σ⟩ → ⟨⟨λx.e, ρ⟩, ρ, σ⟩
```

**闭包应用**:

```
⟨e₁, ρ, σ⟩ → ⟨⟨λx.e, ρ'⟩, ρ₁, σ₁⟩
⟨e₂, ρ₁, σ₁⟩ → ⟨v, ρ₂, σ₂⟩
l ∉ dom(σ₂)
⟨e, ρ'[x ↦ l], σ₂[l ↦ v]⟩ → ⟨v', ρ', σ'⟩
────────────────────────────────────────────────────────────────
              ⟨e₁ e₂, ρ, σ⟩ → ⟨v', ρ₂, σ'⟩
```

### 3.3 与Rust的对应

**栈帧**:

```
ρ 对应 栈帧中的变量绑定
σ 对应 堆内存
```

**所有权跟踪**:

```
环境记录所有权状态
存储记录实际值
```

---

## 四、类型化操作语义

### 4.1 类型保持

**定理 (保持性)**:

```
如果 ∅ ⊢ e : T 且 ⟨e, ∅⟩ → ⟨e', σ'⟩，
那么 ∃T'. ∅ ⊢ e' : T'
```

**定理 (进展性)**:

```
如果 ∅ ⊢ e : T，那么
- e是值，或
- ∃e', σ'. ⟨e, ∅⟩ → ⟨e', σ'⟩
```

### 4.2 Rust类型规则

**移动规则**:

```
Γ ⊢ e : T    T: !Copy
─────────────────────
Γ ⊢ move e : T

(e消耗所有权)
```

**复制规则**:

```
Γ ⊢ e : T    T: Copy
────────────────────
Γ ⊢ e : T

(e保留所有权)
```

**借用规则**:

```
Γ ⊢ x : &mut T
────────────────
Γ ⊢ *x : T

(解引用)
```

---

## 五、并发操作语义

### 5.1 线程模型

**配置**: `⟨t₁ | t₂ | ... | tₙ, σ⟩`

**线程池**:

```
⟨E[spawn e], σ⟩ → ⟨E[l] | ⟨e, ∅⟩, σ[l ↦ ()]⟩
```

### 5.2 共享内存

**原子读**:

```
⟨l.load(Ordering), σ⟩ → ⟨σ(l), σ⟩
```

**原子写**:

```
⟨l.store(v, Ordering), σ⟩ → ⟨(), σ[l ↦ v]⟩
```

### 5.3 消息传递

**发送**:

```
⟨tx.send(v), σ⟩ → ⟨Ok(()), σ'⟩
```

**接收**:

```
⟨rx.recv(), σ⟩ → ⟨Ok(v), σ'⟩
```

---

## 六、语义等价

### 6.1 上下文等价

**定义**:

```
e₁ ≅ e₂  当且仅当  对所有上下文C，C[e₁]和C[e₂]行为相同
```

### 6.2 模拟关系

**模拟**: R是模拟如果

```
⟨e₁, σ₁⟩ R ⟨e₂, σ₂⟩ 且 ⟨e₁, σ₁⟩ → ⟨e₁', σ₁'⟩
⇒ ∃e₂', σ₂'. ⟨e₂, σ₂⟩ →* ⟨e₂', σ₂'⟩ 且 ⟨e₁', σ₁'⟩ R ⟨e₂', σ₂'⟩
```

**双模拟**: 互模拟关系

### 6.3 在Rust优化中的应用

**编译器优化**:

```
如果 e₁ ≅ e₂，则可以用e₂替换e₁
```

**示例**:

```rust
// 优化前
let x = 1 + 2;
print!("{}", x);

// 优化后 (语义等价)
print!("{}", 3);
```

---

## 七、与形式化验证的联系

### 7.1 霍尔三元组

**定义**:

```
{P} C {Q}
含义: 如果P成立，执行C后Q成立
```

**与操作语义的联系**:

```
{P} C {Q} ⟺ ∀σ. σ ⊨ P → (∀v, σ'. ⟨C, σ⟩ ⇓ ⟨v, σ'⟩ → σ' ⊨ Q)
```

### 7.2 最弱前置条件

**定义**:

```
wp(C, Q) = λσ. ∀v, σ'. ⟨C, σ⟩ ⇓ ⟨v, σ'⟩ → Q(v, σ')
```

**性质**:

```
{wp(C, Q)} C {Q}
```

---

## 八、实际应用

### 8.1 MIR语义

Rust的中间表示(MIR)操作语义：

```
基本块: bb₀, bb₁, ...
语句: x = rvalue
终结符: goto, switch, return, etc.
```

### 8.2 优化验证

使用操作语义验证编译器优化的正确性。

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-28
**状态**: ✅ 操作语义文档完成
