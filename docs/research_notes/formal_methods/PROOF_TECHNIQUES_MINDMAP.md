# è¯æ˜æŠ€æœ¯æ¦‚å¿µæ—è°±æ€ç»´å¯¼å›¾

## æ€»è§ˆå›¾è°±

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ğŸŒ³ è¯æ˜æŠ€æœ¯æ¦‚å¿µæ—è°±                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚  å½’çº³æ³•     â”‚    â”‚   æ„é€ æ³•    â”‚    â”‚   åè¯æ³•    â”‚    â”‚  åˆ†ç¦»é€»è¾‘ â”‚  â”‚
â”‚    â”‚  Induction â”‚    â”‚Construction â”‚    â”‚ Contradict â”‚    â”‚ Separationâ”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚                  â”‚                  â”‚                 â”‚       â”‚
â”‚           â–¼                  â–¼                  â–¼                 â–¼       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚â€¢ç»“æ„å½’çº³    â”‚    â”‚â€¢å­˜åœ¨æ„é€     â”‚    â”‚â€¢å½’è°¬æ³•      â”‚    â”‚â€¢Iris      â”‚  â”‚
â”‚    â”‚â€¢æ•°å­¦å½’çº³    â”‚    â”‚â€¢ç®—æ³•æ„é€     â”‚    â”‚â€¢å¯¹è§’çº¿      â”‚    â”‚â€¢Hoareé€»è¾‘ â”‚  â”‚
â”‚    â”‚â€¢è‰¯åŸºå½’çº³    â”‚    â”‚â€¢Witnesses   â”‚    â”‚â€¢åå½’        â”‚    â”‚â€¢èµ„æºä»£æ•°  â”‚  â”‚
â”‚    â”‚â€¢å…±å½’çº³      â”‚    â”‚             â”‚    â”‚             â”‚    â”‚           â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚                  â”‚                  â”‚                 â”‚       â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚       â”‚
â”‚                              â”‚                                    â”‚       â”‚
â”‚                              â–¼                                    â”‚       â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚       â”‚
â”‚                      â”‚  ç±»å‹ç†è®ºè¯æ˜  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                      â”‚  Type Theory  â”‚                                    â”‚
â”‚                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                    â”‚
â”‚                      â”‚ â€¢ è¿›å±•æ€§       â”‚                                    â”‚
â”‚                      â”‚ â€¢ ä¿æŒæ€§       â”‚                                    â”‚
â”‚                      â”‚ â€¢ ç±»å‹å®‰å…¨     â”‚                                    â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. å½’çº³æ³•æ¦‚å¿µæ— (Induction Family)

### 1.1 ç»“æ„æ ‘

```
                            å½’çº³æ³• Induction
                                 â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                    â”‚                    â”‚
            â–¼                    â–¼                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  æ•°å­¦å½’çº³æ³•   â”‚    â”‚  ç»“æ„å½’çº³æ³•   â”‚    â”‚   è‰¯åŸºå½’çº³    â”‚
    â”‚ Mathematical â”‚    â”‚  Structural   â”‚    â”‚  Well-Founded â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                    â”‚                    â”‚
       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
       â–¼         â–¼          â–¼         â–¼          â–¼         â–¼
   ç®€å•å½’çº³   å®Œå…¨å½’çº³    åˆ—è¡¨å½’çº³   æ ‘å½’çº³    å­—å…¸åº    æµ‹åº¦å‡½æ•°
     PMI        PCI       on List  on Tree   Ordering  Measure
```

### 1.2 æ•°å­¦å½’çº³æ³• (Mathematical Induction)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
åŸºç¡€æƒ…å½¢: P(0) æˆç«‹
å½’çº³æ­¥éª¤: âˆ€n âˆˆ â„•. P(n) â‡’ P(n+1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         âˆ€n âˆˆ â„•. P(n)
```

**LaTeXè¡¨ç¤ºï¼š**

```
  P(0)    âˆ€n âˆˆ â„•. P(n) â‡’ P(n+1)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ IND
            âˆ€n âˆˆ â„•. P(n)
```

**é€‚ç”¨åœºæ™¯ï¼š**
- è‡ªç„¶æ•°æ€§è´¨è¯æ˜
- é€’å½’å‡½æ•°ç»ˆæ­¢æ€§
- ç®—æ³•å¤æ‚åº¦åˆ†æ

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// è¯æ˜ factorial(n) = n!
#[requires(n >= 0)]
#[ensures(result == factorial(n))]
fn factorial(n: u64) -> u64 {
    if n == 0 {
        1  // åŸºç¡€æƒ…å½¢
    } else {
        n * factorial(n - 1)  // å½’çº³æ­¥éª¤
    }
}

// ä½¿ç”¨Prustiè¿›è¡Œå½’çº³è¯æ˜
proof! {
    fn factorial_correct(n: u64) {
        // åŸºç¡€: factorial(0) = 1 = 0!
        assert!(factorial(0) == 1);
        
        // å½’çº³: å‡è®¾ factorial(k) = k!
        // è¯æ˜ factorial(k+1) = (k+1) * factorial(k) = (k+1)!
    }
}
```

### 1.3 ç»“æ„å½’çº³æ³• (Structural Induction)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
å¯¹äºå½’çº³ç±»å‹ Tï¼Œè‹¥ï¼š
1. æ‰€æœ‰æ„é€ å­ cáµ¢ çš„åŸºç¡€æƒ…å½¢æ»¡è¶³ P
2. å¯¹æ‰€æœ‰é€’å½’ä½ç½®ï¼Œå½’çº³å‡è®¾æˆç«‹æ—¶ P æˆç«‹
åˆ™ âˆ€x:T. P(x)
```

**LaTeXè¡¨ç¤ºï¼š**

```
  âˆ€c âˆˆ constructors(T). âˆ€xâƒ—. (âˆ§áµ¢ P(xáµ¢)) â‡’ P(c(xâƒ—))
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ S-IND
              âˆ€x : T. P(x)
```

**é€‚ç”¨åœºæ™¯ï¼š**
- æ•°æ®ç»“æ„æ€§è´¨è¯æ˜ï¼ˆåˆ—è¡¨ã€æ ‘ã€è¡¨è¾¾å¼ï¼‰
- ç¼–è¯‘å™¨æ­£ç¡®æ€§
- è¯­æ³•åˆ†æå™¨éªŒè¯

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// äºŒå‰æœç´¢æ ‘é«˜åº¦æ€§è´¨
enum BST<T: Ord> {
    Empty,
    Node(Box<BST<T>>, T, Box<BST<T>>),
}

// è¯æ˜: height(t) â‰¤ size(t)
#[requires(is_bst(tree))]
#[ensures(height(tree) <= size(tree))]
fn verify_height_bound<T: Ord>(tree: &BST<T>) -> bool {
    match tree {
        BST::Empty => true,  // åŸºç¡€: height(Empty)=0 â‰¤ size(Empty)=0
        BST::Node(left, _, right) => {
            // å½’çº³å‡è®¾: height(left) â‰¤ size(left), height(right) â‰¤ size(right)
            // éœ€è¯: 1 + max(height(left), height(right)) â‰¤ 1 + size(left) + size(right)
            verify_height_bound(left) && verify_height_bound(right)
        }
    }
}
```

### 1.4 è‰¯åŸºå½’çº³æ³• (Well-Founded Induction)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
è®¾ (A, â‰º) æ˜¯è‰¯åŸºå…³ç³»ï¼ˆæ— æ— é™é™é“¾ï¼‰
è‹¥ âˆ€x âˆˆ A. (âˆ€y â‰º x. P(y)) â‡’ P(x)
åˆ™ âˆ€x âˆˆ A. P(x)
```

**LaTeXè¡¨ç¤ºï¼š**

```
  âˆ€x âˆˆ A. (âˆ€y â‰º x. P(y)) â‡’ P(x)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WF-IND
          âˆ€x âˆˆ A. P(x)
```

**é€‚ç”¨åœºæ™¯ï¼š**
- äº’é€’å½’å‡½æ•°ç»ˆæ­¢æ€§
- æ’åºè¯æ˜
- å¤æ‚é€’å½’æ¨¡å¼

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// é˜¿å…‹æ›¼å‡½æ•° - ä½¿ç”¨å­—å…¸åºè‰¯åŸºå½’çº³è¯æ˜ç»ˆæ­¢
#[requires(m >= 0 && n >= 0)]
#[decreases((m, n))]  // å­—å…¸åºè‰¯åŸºå…³ç³»
fn ackermann(m: u64, n: u64) -> u64 {
    match (m, n) {
        (0, _) => n + 1,
        (_, 0) => ackermann(m - 1, 1),
        _ => ackermann(m - 1, ackermann(m, n - 1)),
    }
}

// è¯æ˜ ackermann å¯¹æ‰€æœ‰ (m,n) ç»ˆæ­¢
// è‰¯åŸºå…³ç³»: (m',n') â‰º (m,n) å½“ m'<m âˆ¨ (m'=m âˆ§ n'<n)
```

### 1.5 å…±å½’çº³æ³• (Coinduction)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
è¦è¯æ˜ x ~ yï¼ˆäº’æ¨¡æ‹Ÿï¼‰ï¼Œéœ€æ‰¾åˆ°å…³ç³» R ä½¿å¾—ï¼š
1. (x, y) âˆˆ R
2. R æ˜¯äº’æ¨¡æ‹Ÿå…³ç³»ï¼š
   - x â†’ x' â‡’ âˆƒy'. y â†’ y' âˆ§ (x', y') âˆˆ R
   - y â†’ y' â‡’ âˆƒx'. x â†’ x' âˆ§ (x', y') âˆˆ R
```

**LaTeXè¡¨ç¤ºï¼š**

```
  x ~ y â‡” âˆƒR. (x,y) âˆˆ R âˆ§ R is a bisimulation
```

**é€‚ç”¨åœºæ™¯ï¼š**
- æ— é™æ•°æ®ç»“æ„ï¼ˆæµã€å»¶è¿Ÿåˆ—è¡¨ï¼‰
- è¿›ç¨‹ç­‰ä»·æ€§
- å¾ªç¯ç¨‹åºéªŒè¯

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
use std::rc::Rc;

// æ— é™æµï¼ˆæƒ°æ€§æ±‚å€¼ï¼‰
type Stream<T> = Rc<dyn Fn() -> (T, Stream<T>)>;

// è¯æ˜ä¸¤ä¸ªæµç›¸ç­‰ï¼ˆé€šè¿‡äº’æ¨¡æ‹Ÿï¼‰
#[ensures(stream_eq(s1, s2))]
fn ones_stream_eq(s1: Stream<u64>, s2: Stream<u64>) -> bool {
    // äº’æ¨¡æ‹Ÿå…³ç³»: R = {(ones, ones)} æ»¡è¶³å…±å½’çº³æ¡ä»¶
    // âˆ€n. head(s1) = head(s2) = 1 âˆ§ (tail(s1), tail(s2)) âˆˆ R
    true
}

// ä½¿ç”¨ guarded recursion ä¿è¯ç”Ÿäº§åŠ›
#[guarded_recursion]
fn map_stream<T, U, F>(f: F, s: Stream<T>) -> Stream<U>
where F: Fn(T) -> U + Clone + 'static, T: Clone + 'static, U: Clone + 'static
{
    Rc::new(move || {
        let (head, tail) = s();
        (f(head), map_stream(f.clone(), tail))
    })
}
```

---

## 2. æ„é€ æ³•æ¦‚å¿µæ— (Construction Family)

### 2.1 ç»“æ„æ ‘

```
                          æ„é€ æ³• Construction
                                 â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                     â”‚                     â”‚
           â–¼                     â–¼                     â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  å­˜åœ¨æ„é€      â”‚     â”‚  ç®—æ³•æ„é€      â”‚     â”‚   Witness    â”‚
   â”‚  Existential  â”‚     â”‚  Algorithmic  â”‚     â”‚  Extraction  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                     â”‚                     â”‚
      â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
      â–¼         â–¼           â–¼         â–¼          â–¼         â–¼
  æ˜¾å¼æ„é€    éšå¼æ„é€     ç¨‹åºæå–   ä¼˜åŒ–æ„é€     ç±»å‹è§è¯   è®¡ç®—è§è¯
Explicit   Implicit   Program   Optimized  Type      Computation
```

### 2.2 å­˜åœ¨æ„é€  (Existential Construction)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
è¯æ˜ âˆƒx. P(x) çš„æ–¹æ³•ï¼š
1. æ˜¾å¼æ„é€ ï¼šæ‰¾åˆ°å…·ä½“çš„ t ä½¿å¾— P(t) æˆç«‹
2. éšå¼æ„é€ ï¼šè¯æ˜æ„é€ è¿‡ç¨‹çš„æ­£ç¡®æ€§

æ˜¾å¼:    P(t)        éšå¼:  æ„é€ ç®—æ³• A
      â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
      âˆƒx. P(x)                 â–¼
                           P(A())
                           â”€â”€â”€â”€â”€
                          âˆƒx. P(x)
```

**LaTeXè¡¨ç¤ºï¼š**

```
  P(t)                    âŠ¢ A : âˆ€xâƒ—. âˆƒy. P(xâƒ—, y)
  â”€â”€â”€â”€â”€â”€â”€ âˆƒ-I    æˆ–     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  âˆƒx. P(x)              âŠ¢ Î»xâƒ—. Ï€â‚(A(xâƒ—)) : âˆ€xâƒ—. P(xâƒ—, f(xâƒ—))
```

**é€‚ç”¨åœºæ™¯ï¼š**
- å­˜åœ¨æ€§å®šç†çš„ç®—æ³•åŒ–
- ç¨‹åºç»¼åˆ
- ç¼–è¯‘å™¨ä¼˜åŒ–

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// è¯æ˜: âˆ€n. âˆƒm. m > n âˆ§ is_prime(m)
// æ˜¾å¼æ„é€ : m = next_prime(n)
#[ensures(result > n && is_prime(result))]
fn find_prime_gt(n: u64) -> u64 {
    // æ˜¾å¼æ„é€ è§è¯
    let mut candidate = n + 1;
    while !is_prime(candidate) {
        candidate += 1;
    }
    candidate
}

// éšå¼æ„é€ ï¼ˆé€šè¿‡ä¾èµ–ç±»å‹ï¼‰
trait Existential<P> {
    type Witness;
    fn construct() -> Self::Witness;
}

// å­˜åœ¨ç±»å‹ âˆƒx. Prime(x)
struct ExistsPrime(u64);
impl Existential<IsPrime> for ExistsPrime {
    type Witness = u64;
    fn construct() -> u64 { 2 }  // 2 æ˜¯ç´ æ•°çš„è§è¯
}
```

### 2.3 ç®—æ³•æ„é€  (Algorithmic Construction)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
ä»è¯æ˜ä¸­æå–ç¨‹åºï¼ˆCurry-Howard åŒæ„ï¼‰ï¼š

è¯æ˜ Î  : âˆ€x:A. âˆƒy:B. P(x,y)
        â†“ æå–
ç¨‹åº f : A â†’ B  æ»¡è¶³  âˆ€x:A. P(x, f(x))
```

**LaTeXè¡¨ç¤ºï¼š**

```
  Extract(Î ) = Î»x : A. Ï€â‚(Î (x)) : A â†’ B
```

**é€‚ç”¨åœºæ™¯ï¼š**
- è¯æ˜æºå¸¦ä»£ç  (Proof-Carrying Code)
- è®¤è¯ç¼–è¯‘å™¨
- å½¢å¼åŒ–ç¨‹åºç»¼åˆ

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä½¿ç”¨ Prusti è¿›è¡Œç¨‹åºæå–
// è¯æ˜æ’åºç®—æ³•çš„æ­£ç¡®æ€§åŒæ—¶æå–ç®—æ³•

#[ensures(is_sorted(&result))]
#[ensures(is_permutation(&result, &input))]
fn sort<T: Ord + Clone>(input: Vec<T>) -> Vec<T> {
    // æ„é€ æ€§è¯æ˜: ç®—æ³•æœ¬èº«å°±æ˜¯è¯æ˜
    let mut result = input.clone();
    result.sort();
    result
}

// è®¤è¯æ•°æ®ç»“æ„çš„æ„é€ 
#[invariant(self.is_valid())]
pub struct CertifiedVec<T> {
    data: Vec<T>,
}

impl<T: Ord> CertifiedVec<T> {
    // æ„é€ æ€§è¯æ˜: æ’å…¥ä¿æŒæœ‰åº
    #[requires(self.is_sorted())]
    #[ensures(result.is_sorted())]
    #[ensures(result.len() == old(self.len()) + 1)]
    pub fn insert(&mut self, value: T) -> &Self {
        // ç®—æ³•æ„é€ è§è¯
        let pos = self.data.binary_search(&value).unwrap_or_else(|e| e);
        self.data.insert(pos, value);
        self
    }
}
```

### 2.4 Witnessesï¼ˆè§è¯æå–ï¼‰

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
ç±»å‹è§è¯: è¿è¡Œæ—¶æºå¸¦ç±»å‹ä¿¡æ¯çš„å€¼
è®¡ç®—è§è¯: è¯æ˜è®¡ç®—è¿‡ç¨‹æ­£ç¡®æ€§çš„è¯æ®

Witness Type:    W = (v, proof(v))
                 å…¶ä¸­ proof(v) : P(v)
```

**LaTeXè¡¨ç¤ºï¼š**

```
  Î£x:A P(x) = {(a, p) | a : A, p : P(a)}
```

**é€‚ç”¨åœºæ™¯ï¼š**
- ä¾èµ–ç±»å‹ç¼–ç¨‹
- ç±»å‹é©±åŠ¨å¼€å‘
- è¿è¡Œæ—¶éªŒè¯

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä½¿ç”¨å¹½çµç±»å‹å®ç°è§è¯
use std::marker::PhantomData;

// è§è¯ç±»å‹: âˆƒn. n > 0
pub struct Positive(PhantomData<fn() -> ()>);
pub struct PositiveWitness {
    value: u64,
    _proof: PhantomData<Positive>,
}

impl PositiveWitness {
    pub fn new(n: u64) -> Option<Self> {
        if n > 0 {
            Some(Self {
                value: n,
                _proof: PhantomData,
            })
        } else {
            None
        }
    }
}

// ä½¿ç”¨è§è¯ç¡®ä¿é™¤æ³•å®‰å…¨
#[requires(divisor.value > 0)]
#[ensures(result * divisor.value <= dividend)]
fn safe_div(dividend: u64, divisor: &PositiveWitness) -> u64 {
    dividend / divisor.value
}

// è®¡ç®—è§è¯ç¤ºä¾‹
pub struct SortedWitness<T> {
    data: Vec<T>,
    proof: Vec<(usize, usize)>,  // æ¯”è¾ƒäº¤æ¢åºåˆ—çš„è¯æ˜
}
```

---

## 3. åè¯æ³•æ¦‚å¿µæ— (Contradiction Family)

### 3.1 ç»“æ„æ ‘

```
                        åè¯æ³• Contradiction
                                â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                     â”‚                     â”‚
          â–¼                     â–¼                     â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   å½’è°¬æ³•      â”‚     â”‚   å¯¹è§’çº¿æ³•    â”‚     â”‚   åå½’æ³•      â”‚
  â”‚   Reductio    â”‚     â”‚   Diagonal    â”‚     â”‚   Co-Rec    â”‚
  â”‚   ad absurdum â”‚     â”‚   Argument    â”‚     â”‚   Refutation â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                     â”‚                     â”‚
     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
     â–¼         â–¼           â–¼         â–¼          â–¼         â–¼
  ç»å…¸é€»è¾‘   ç›´è§‰é€»è¾‘    Cantor    Turing    çŸ›ç›¾æ¨å¯¼  ä¸å¯æ»¡è¶³
 Classical  Intuition  å®šç†      åœæœº      å½’çº¦      UNSAT
```

### 3.2 å½’è°¬æ³• (Reductio ad Absurdum)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
è¦è¯æ˜ Pï¼Œå‡è®¾ Â¬Pï¼š

  [Â¬P]Â¹
    â‹®
    âŠ¥         æˆ–ç»å…¸å½¢å¼:
  â”€â”€â”€â”€â”€ Â¬EÂ¹    [Â¬P]Â¹
    P            â‹®
               Q âˆ§ Â¬Q
              â”€â”€â”€â”€â”€â”€â”€â”€â”€ RAAÂ¹
                 P
```

**LaTeXè¡¨ç¤ºï¼š**

```
        Î“, Â¬P âŠ¢ âŠ¥                   Î“, Â¬P âŠ¢ Q âˆ§ Â¬Q
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ RAA   æˆ–  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ RAA
           Î“ âŠ¢ P                          Î“ âŠ¢ P
```

**é€‚ç”¨åœºæ™¯ï¼š**
- å”¯ä¸€æ€§è¯æ˜
- å­˜åœ¨æ€§è¯æ˜ï¼ˆéæ„é€ æ€§ï¼‰
- å¦å®šå¼•å…¥

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// è¯æ˜ Vec::get çš„å®‰å…¨æ€§ï¼ˆåè¯æ³•ï¼‰
// å‡è®¾è¶Šç•Œè®¿é—®ä¼šå¯¼è‡´ä¸å®‰å…¨

#[requires(index < self.len())]
#[ensures(result == &self.data[index])]
fn get_unchecked_proof<T>(&self, index: usize) -> &T {
    // åè¯: å‡è®¾ index >= len()
    // åˆ™ self.data.get(index) = None
    // ä½†æˆ‘ä»¬éœ€è¦ Some(&T)ï¼ŒçŸ›ç›¾ï¼
    &self.data[index]
}

// ä½¿ç”¨ Prusti çš„ä¸å¯æ»¡è¶³æ€§è¯æ˜
#[pure]
#[ensures(result == (a != b))]
fn distinct_implies_not_equal<T: PartialEq>(a: &T, b: &T) -> bool {
    // åè¯: å‡è®¾ a â‰  b âˆ§ a = b
    // ç”± a = b å’Œ a â‰  b å¾—çŸ›ç›¾
    a != b
}
```

### 3.3 å¯¹è§’çº¿æ³• (Diagonal Argument)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
Cantor å¯¹è§’çº¿è®ºè¯:

å‡è®¾å­˜åœ¨æšä¸¾ f: â„• â†’ 2^â„•
æ„é€  D = {n | n âˆ‰ f(n)}
åˆ™ âˆ€n. D â‰  f(n) å› ä¸º n âˆˆ D âŸº n âˆ‰ f(n)
çŸ›ç›¾ï¼æ•… 2^â„• ä¸å¯æ•°
```

**LaTeXè¡¨ç¤ºï¼š**

```
  è®¾ f: â„• â†’ P(â„•) æ˜¯æšä¸¾
  D = {n âˆˆ â„• | n âˆ‰ f(n)}
  âˆ€n. D â‰  f(n) å› ä¸º n âˆˆ D â‡” n âˆ‰ f(n)
  âˆ´ âˆ„ æ»¡å°„ f: â„• â†’ P(â„•)
```

**é€‚ç”¨åœºæ™¯ï¼š**
- ä¸å¯åˆ¤å®šæ€§è¯æ˜
- ç±»å‹ç³»ç»Ÿè¡¨è¾¾èƒ½åŠ›é™åˆ¶
- å®‰å…¨æ€§è¾¹ç•Œè¯æ˜

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// è¯æ˜: ä¸å­˜åœ¨é€šç”¨çš„ Rust ç±»å‹æ£€æŸ¥å™¨åœæœºåˆ¤å®šå™¨

// å¯¹è§’çº¿æ„é€ : å‡è®¾å­˜åœ¨ halt_checker
fn halt_checker<P: Fn()>(program: P) -> bool {
    // å‡è®¾å¯ä»¥åˆ¤å®šç¨‹åºæ˜¯å¦åœæœº
    unimplemented!()
}

// æ„é€ å¯¹è§’çº¿ç¨‹åº
fn diagonal() {
    if halt_checker(diagonal) {
        loop {}  // å¦‚æœåˆ¤å®šåœæœºï¼Œåˆ™æ­»å¾ªç¯
    } else {
        return;  // å¦‚æœåˆ¤å®šä¸åœæœºï¼Œåˆ™ç«‹å³è¿”å›
    }
}

// çŸ›ç›¾: halt_checker(diagonal) æ— è®ºè¿”å›ä»€ä¹ˆéƒ½ä¼šå¯¼è‡´çŸ›ç›¾
// ç»“è®º: ä¸å­˜åœ¨é€šç”¨çš„åœæœºåˆ¤å®šå™¨

// ç±»å‹ç³»ç»Ÿåº”ç”¨: è¯æ˜ç±»å‹ç³»ç»Ÿä¸èƒ½è¡¨è¾¾æ‰€æœ‰å®‰å…¨ç¨‹åº
trait TypeCheckable {
    fn type_check() -> bool;
}

// å¯¹è§’çº¿ç¨‹åº:
struct Diagonal;
impl TypeCheckable for Diagonal {
    fn type_check() -> bool {
        !Self::type_check()  // çŸ›ç›¾æ„é€ 
    }
}
```

### 3.4 çŸ›ç›¾æ¨å¯¼ (Contradiction Derivation)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
ä»çŸ›ç›¾æ¨å‡ºä»»ä½•å‘½é¢˜ï¼ˆçˆ†ç‚¸åŸç†ï¼‰:

  âŠ¥          P âˆ§ Â¬P
  â”€â”€ âŠ¥E      â”€â”€â”€â”€â”€
  Q            âŠ¥
              â”€â”€â”€ âŠ¥E
               Q

éçŸ›ç›¾å¾‹: Â¬(P âˆ§ Â¬P)
æ’ä¸­å¾‹:   P âˆ¨ Â¬P (ç»å…¸é€»è¾‘)
```

**LaTeXè¡¨ç¤ºï¼š**

```
      âŠ¥              P âˆ§ Â¬P
  â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Q                âŠ¥
                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ âŠ¥E
                        Q
```

**é€‚ç”¨åœºæ™¯ï¼š**
- é”™è¯¯å¤„ç†
- å®‰å…¨æ£€æŸ¥
- ä¸å˜é‡è¿åæ£€æµ‹

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä½¿ç”¨ä¸å¯è¾¾æ ‡è®°è¿›è¡ŒçŸ›ç›¾æ¨å¯¼
#[deny(unreachable_patterns)]
fn safe_unwrap<T>(opt: Option<T>) -> T {
    match opt {
        Some(v) => v,
        None => {
            // çŸ›ç›¾: å‰ç½®æ¡ä»¶ä¿è¯ opt ä¸ä¸º None
            // ä½¿ç”¨ unreachable_unchecked ä½œä¸º âŠ¥ æ¶ˆé™¤
            unsafe { std::hint::unreachable_unchecked() }
        }
    }
}

// ä¸å˜é‡è¿åçš„æ£€æµ‹
#[requires(*ref_count > 0)]
fn drop_reference(ref_count: &mut usize) {
    *ref_count -= 1;
    if *ref_count == usize::MAX {
        // æ•´æ•°ä¸‹æº¢æ£€æµ‹ - çŸ›ç›¾
        panic!("Reference count underflow - contradiction detected");
    }
}

// ä½¿ç”¨ç±»å‹ç³»ç»Ÿæ’é™¤çŸ›ç›¾çŠ¶æ€
pub struct NonEmptyVec<T>(Vec<T>);

impl<T> NonEmptyVec<T> {
    pub fn new(item: T) -> Self {
        Self(vec![item])
    }
    
    pub fn first(&self) -> &T {
        // ç”±ä¸å˜é‡ä¿è¯ï¼Œæ— çŸ›ç›¾
        &self.0[0]
    }
}
```

---

## 4. åˆ†ç¦»é€»è¾‘æ¦‚å¿µæ— (Separation Logic Family)

### 4.1 ç»“æ„æ ‘

```
                          åˆ†ç¦»é€»è¾‘ Separation Logic
                                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                         â”‚                         â”‚
         â–¼                         â–¼                         â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   Irisæ¡†æ¶    â”‚         â”‚   Hoareé€»è¾‘   â”‚         â”‚   èµ„æºä»£æ•°    â”‚
 â”‚   (å¹¶å‘)      â”‚         â”‚   (é¡ºåº)      â”‚         â”‚   RA          â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚â€¢é«˜é˜¶è°“è¯      â”‚         â”‚â€¢å‰ç½®æ¡ä»¶      â”‚         â”‚â€¢æˆæƒ         â”‚
â”‚â€¢ä¸å˜é‡        â”‚         â”‚â€¢åç½®æ¡ä»¶      â”‚         â”‚â€¢æ‰€æœ‰æƒ        â”‚
â”‚â€¢åŸå­æ€§        â”‚         â”‚â€¢å¾ªç¯ä¸å˜é‡    â”‚         â”‚â€¢åˆ†å¼æƒé™      â”‚
â”‚â€¢é«˜é˜¶å¹½çµçŠ¶æ€  â”‚         â”‚â€¢éœå°”ä¸‰å…ƒç»„    â”‚         â”‚â€¢æ›´æ–°æ¨¡æ€      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚                         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   RustBelt     â”‚
                         â”‚   Rustç”Ÿå‘½å‘¨æœŸ â”‚
                         â”‚   æ‰€æœ‰æƒç³»ç»Ÿ   â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Iris æ¡†æ¶ (Iris Framework)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
Iris æ–­è¨€è¯­æ³•:
P, Q ::=  â–· P        (later modality)
       |  â–¡ P        (persistent)
       |  â—‡ P        (æ›´æ–°æ¨¡æ€)
       |  P âˆ— Q      (åˆ†ç¦»åˆå–)
       |  P -* Q     (åˆ†ç¦»è•´å«/Wand)
       |  Î¼ x. P     (é€’å½’æ–­è¨€)
       |  âˆ€ x. P     (å…¨ç§°é‡è¯)
       |  âˆƒ x. P     (å­˜åœ¨é‡è¯)
       |  l â†¦ v      (ç‚¹æ–­è¨€)
       |  inv^N(P)   (ä¸å˜é‡)
```

**LaTeXè¡¨ç¤ºï¼š**

```
  P âŠ¢ Q                      
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â–· P âŠ¢ â–· Q             

       
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â–· P âŠ¢ â–· â–· P           

ä¸å˜é‡è§„åˆ™:

  {â–· P} âŸ¨eâŸ© {v. Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {inv(P)} âŸ¨eâŸ© {v. Q}
```

**é€‚ç”¨åœºæ™¯ï¼š**
- å¹¶å‘ç¨‹åºéªŒè¯
- é«˜é˜¶è¯­è¨€ç‰¹æ€§
- æ¨¡å—åŒ–éªŒè¯

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä½¿ç”¨ Iris æ€æƒ³éªŒè¯ Arc
use std::sync::Arc;

// ä¸å˜é‡: Arc<T> çš„å¼•ç”¨è®¡æ•° â‰¥ 1 æ—¶æ•°æ®æœ‰æ•ˆ
//         å½“å¼•ç”¨è®¡æ•° = 0 æ—¶æ•°æ®è¢«é‡Šæ”¾

#[invariant(self.ref_count > 0 ==> valid(self.data))]
pub struct VerifiedArc<T> {
    ref_count: AtomicUsize,
    data: UnsafeCell<T>,
}

impl<T> VerifiedArc<T> {
    // åŸå­æ€§æ“ä½œ: clone å¢åŠ å¼•ç”¨è®¡æ•°
    #[atomic]
    #[ensures(self.ref_count == old(self.ref_count) + 1)]
    pub fn clone(&self) -> Self {
        // Iris éªŒè¯:
        // å‰ç½®: inv(âˆƒn. ref_count â†¦ n âˆ— n > 0 âˆ— is_arc(self))
        // åç½®: inv(âˆƒn. ref_count â†¦ n + 1 âˆ— is_arc(self))
        let count = self.ref_count.fetch_add(1, Ordering::Relaxed);
        assert!(count < usize::MAX, "overflow");
        Self { /* ... */ }
    }
    
    // åŸå­æ€§ drop
    #[atomic]
    #[ensures(result ==> self.ref_count == 0)]
    pub fn drop(&mut self) -> bool {
        // Iris éªŒè¯:
        // å‰ç½®: inv(âˆƒn. ref_count â†¦ n âˆ— n > 0 âˆ— is_arc(self))
        // å¦‚æœè¿”å› true: ref_count â†¦ 0
        // å¦‚æœè¿”å› false: ref_count â†¦ n - 1
        let count = self.ref_count.fetch_sub(1, Ordering::Release);
        count == 1
    }
}
```

### 4.3 Hoareé€»è¾‘ (Hoare Logic)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
éœå°”ä¸‰å…ƒç»„: {P} C {Q}

å«ä¹‰: è‹¥å‰ç½®æ¡ä»¶ P æˆç«‹ï¼Œæ‰§è¡Œ C åï¼Œ
      è‹¥ C ç»ˆæ­¢ï¼Œåˆ™åç½®æ¡ä»¶ Q æˆç«‹

è§„åˆ™:

{P} skip {P}                           (Skip)

{Q[e/x]} x := e {Q}                    (Assign)

{P} Câ‚ {R}    {R} Câ‚‚ {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              (Seq)
      {P} Câ‚; Câ‚‚ {Q}

     {P âˆ§ b} Câ‚ {Q}     {P âˆ§ Â¬b} Câ‚‚ {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (If)
       {P} if b then Câ‚ else Câ‚‚ {Q}

    {P âˆ§ b} C {P}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   (While)
{P} while b do C {P âˆ§ Â¬b}

    P' â‡’ P    {P} C {Q}    Q â‡’ Q'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   (Consequence)
           {P'} C {Q'}
```

**LaTeXè¡¨ç¤ºï¼š**

```
        
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SKIP
         {P} skip {P}         

  
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ASSIGN
      {Q[e/x]} x := e {Q}    

  {P} Câ‚ {R}    {R} Câ‚‚ {Q}
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SEQ
        {P} Câ‚; Câ‚‚ {Q}       

  {P âˆ§ b} Câ‚ {Q}    {P âˆ§ Â¬b} Câ‚‚ {Q}
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ IF
     {P} if b then Câ‚ else Câ‚‚ {Q}    

      {P âˆ§ b} C {P}
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WHILE
  {P} while b do C {P âˆ§ Â¬b} 

  P' â‡’ P    {P} C {Q}    Q â‡’ Q'
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONSEQUENCE
             {P'} C {Q'}             
```

**é€‚ç”¨åœºæ™¯ï¼š**
- é¡ºåºç¨‹åºéªŒè¯
- å¾ªç¯ä¸å˜é‡æ¨ç†
- å‰ç½®/åç½®æ¡ä»¶è§„çº¦

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä½¿ç”¨ Prusti çš„ Hoare é€»è¾‘éªŒè¯

// {n >= 0}
#[requires(n >= 0)]
// {result == fib(n)}
#[ensures(result == fib(n))]
// {i >= 0 && a == fib(i) && b == fib(i+1)}
#[invariant(i >= 0)]
#[invariant(a == fib(i))]
#[invariant(b == fib(i+1))]
fn fibonacci(n: u64) -> u64 {
    if n == 0 {
        return 0;  // {return == 0 == fib(0)}
    }
    
    let mut a = 0;  // a = fib(0)
    let mut b = 1;  // b = fib(1)
    let mut i = 0;
    
    // å¾ªç¯ä¸å˜é‡: i >= 0 âˆ§ a = fib(i) âˆ§ b = fib(i+1)
    while i < n {
        // {i < n âˆ§ i >= 0 âˆ§ a = fib(i) âˆ§ b = fib(i+1)}
        let temp = a + b;
        a = b;      // a = fib(i+1)
        b = temp;   // b = fib(i+2)
        i += 1;     // i = i+1
        // {i' = i+1 âˆ§ a = fib(i') âˆ§ b = fib(i'+1)}
    }
    
    a  // {i = n âˆ§ a = fib(n)}
}

// éœå°”ä¸‰å…ƒç»„åº”ç”¨: Vec::push
#[requires(self.len() < self.capacity())]
#[ensures(self.len() == old(self.len()) + 1)]
#[ensures(self.last() == Some(&value))]
fn push_verified<T>(&mut self, value: T) {
    // {len < capacity}
    self.data.push(value);
    // {len = len + 1 âˆ§ last = value}
}
```

### 4.4 èµ„æºä»£æ•° (Resource Algebra)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
èµ„æºä»£æ•° (Resource Algebra) âŸ¨A, â‹…, Îµ, VâŸ©:

1. (A, â‹…) æ˜¯äº¤æ¢å¹ºåŠç¾¤ï¼Œå•ä½å…ƒ Îµ
2. æœ‰æ•ˆæ€§è°“è¯ V : A â†’ Prop æ»¡è¶³:
   - V(Îµ) æˆç«‹
   - V(a â‹… b) â‡’ V(a) âˆ§ V(b)
   
å…³é”®æ¦‚å¿µ:
- ç‹¬å èµ„æº (Excl A): ä¸€æ¬¡æ€§æ‰€æœ‰æƒ
- åˆ†å¼æƒé™ (Frac A): 0 < q â‰¤ 1 çš„éƒ¨åˆ†æ‰€æœ‰æƒ
- æˆæƒ (Auth A): æƒå¨ä¸ç‰‡æ®µçš„ç»„åˆ
- èšåˆ (Agree A): ä¸€è‡´æ€§è§è¯
```

**LaTeXè¡¨ç¤ºï¼š**

```
èµ„æºä»£æ•°: (A, â‹…, Îµ, V)
å…¶ä¸­: âˆ€a, b âˆˆ A. a â‹… b = b â‹… a
      V(a â‹… b) â‡’ V(a) âˆ§ V(b)

åˆ†å¼æƒé™: Frac(Qâº) æ»¡è¶³ qâ‚ + qâ‚‚ = 1 â‡’ ç‹¬å è®¿é—®
```

**é€‚ç”¨åœºæ™¯ï¼š**
- æ‰€æœ‰æƒç³»ç»Ÿå»ºæ¨¡
- æƒé™åˆ†æ
- å†…å­˜ç®¡ç†éªŒè¯

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä½¿ç”¨èµ„æºä»£æ•°å»ºæ¨¡ Rust æ‰€æœ‰æƒ

// ç‹¬å æ‰€æœ‰æƒç±»å‹
pub struct Excl<T>(T);

impl<T> Excl<T> {
    // Îµ: åˆ›å»ºæ–°èµ„æº
    pub fn new(value: T) -> Self {
        Self(value)
    }
    
    // è½¬ç§»æ‰€æœ‰æƒ: a â†’ b
    pub fn into_inner(self) -> T {
        self.0
    }
}

// åˆ†å¼æƒé™: è¯»å†™é”çš„æ•°å­¦æ¨¡å‹
pub struct Frac<T> {
    data: T,
    q: f64,  // 0 < q â‰¤ 1
}

impl<T: Clone> Frac<T> {
    // åˆ†å‰²æƒé™: q = q1 + q2
    pub fn split(self, q1: f64) -> (Frac<T>, Frac<T>) {
        assert!(0.0 < q1 && q1 < self.q);
        let q2 = self.q - q1;
        let data = self.data.clone();
        (
            Frac { data: data.clone(), q: q1 },
            Frac { data, q: q2 },
        )
    }
    
    // åˆå¹¶æƒé™: éœ€è¦ q1 + q2 â‰¤ 1
    pub fn combine(a: Frac<T>, b: Frac<T>) -> Frac<T> {
        assert_eq!(a.data, b.data);
        Frac {
            data: a.data,
            q: a.q + b.q,
        }
    }
}

// æˆæƒæ¨¡å¼: Arc/Rc çš„æ•°å­¦æ¨¡å‹
pub struct Auth<T> {
    authoritative: T,
    fragments: Vec<Frac<T>>,
}

// ä¸å˜é‡: Î£ fragments.q â‰¤ 1
//         authoritative ä»…åœ¨ Î£ fragments.q = 0 æ—¶å¯å˜
```

---

## 5. ç±»å‹ç†è®ºè¯æ˜ (Type Theory Proofs)

### 5.1 ç»“æ„æ ‘

```
                      ç±»å‹ç†è®ºè¯æ˜ Type Theory
                                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚    è¿›å±•æ€§     â”‚       â”‚    ä¿æŒæ€§     â”‚       â”‚   ç±»å‹å®‰å…¨   â”‚
 â”‚   Progress    â”‚       â”‚ Preservation  â”‚       â”‚ Type Safety â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚â€¢é—­åˆè¡¨è¾¾å¼    â”‚       â”‚â€¢è§„çº¦ä¿æŒç±»å‹ â”‚       â”‚â€¢æ— å¡æ­»      â”‚
â”‚â€¢å€¼æˆ–å¯è§„çº¦    â”‚       â”‚â€¢ç±»å‹ä¸Šä¸‹æ–‡   â”‚       â”‚â€¢æ— æœªå®šä¹‰è¡Œä¸ºâ”‚
â”‚â€¢ç±»å‹æŒ‡å¯¼æ±‚å€¼  â”‚       â”‚â€¢ä»£æ¢å¼•ç†     â”‚       â”‚â€¢è§„èŒƒå½¢å¼    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   Rustç±»å‹ç³»ç»Ÿ   â”‚
                         â”‚  â€¢ æ‰€æœ‰æƒ/å€Ÿç”¨   â”‚
                         â”‚  â€¢ ç”Ÿå‘½å‘¨æœŸ      â”‚
                         â”‚  â€¢ Send/Sync    â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 è¿›å±•æ€§ (Progress)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
è¿›å±•æ€§å®šç†:
è‹¥ âŠ¢ e : Tï¼Œåˆ™ e æ˜¯å€¼ï¼Œæˆ–å­˜åœ¨ e' ä½¿å¾— e âŸ¶ e'

âˆ€e, T. âŠ¢ e : T â‡’ value(e) âˆ¨ (âˆƒe'. e âŸ¶ e')

å°é—­è¡¨è¾¾å¼çš„è¿›å±•æ€§ä¿è¯ç¨‹åºä¸ä¼š"å¡ä½"
```

**LaTeXè¡¨ç¤ºï¼š**

```
            âŠ¢ e : Ï„
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  value(e) âˆ¨ âˆƒe'. e âŸ¶ e'
```

**é€‚ç”¨åœºæ™¯ï¼š**
- ç¡®ä¿æ±‚å€¼ä¸ä¼šå¡æ­»
- æ¨¡å¼åŒ¹é…ç©·å°½æ€§
- é”™è¯¯å¤„ç†å®Œå¤‡æ€§

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// Rust ç¼–è¯‘å™¨è¿›å±•æ€§æ£€æŸ¥ç¤ºä¾‹

// ç©·å°½æ€§æ£€æŸ¥ï¼ˆè¿›å±•æ€§ï¼‰
enum Option<T> {
    Some(T),
    None,
}

// å¿…é¡»å¤„ç†æ‰€æœ‰å˜ä½“ï¼Œå¦åˆ™ä¼šå¡æ­»
fn option_unwrap<T>(opt: Option<T>) -> T {
    match opt {
        Option::Some(v) => v,
        Option::None => panic!("called `Option::unwrap()` on a `None` value"),
    }
}

// ç±»å‹ç³»ç»Ÿä¿è¯è¿›å±•æ€§
#[deny(unreachable_patterns)]
fn exhaustive_match(x: Result<i32, &str>) -> i32 {
    match x {
        Ok(n) => n * 2,
        Err(_) => 0,
        // ç¼–è¯‘å™¨éªŒè¯: æ‰€æœ‰å˜ä½“å·²å¤„ç†
    }
}

// unsafe å—éœ€è¦éªŒè¯è¿›å±•æ€§
unsafe fn raw_pointer_progress(ptr: *const i32) -> i32 {
    // éœ€è¦éªŒè¯ ptr éç©º
    if ptr.is_null() {
        panic!("null pointer");
    }
    *ptr  // è¿›å±•æ€§: ä¸ä¼šå¡æ­»
}
```

### 5.3 ä¿æŒæ€§ (Preservation)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
ä¿æŒæ€§å®šç†ï¼ˆSubject Reductionï¼‰:
è‹¥ âŠ¢ e : T ä¸” e âŸ¶ e'ï¼Œåˆ™ âŠ¢ e' : T

âˆ€e, e', T. âŠ¢ e : T âˆ§ e âŸ¶ e' â‡’ âŠ¢ e' : T

ç±»å‹åœ¨è§„çº¦è¿‡ç¨‹ä¸­ä¿æŒä¸å˜
```

**LaTeXè¡¨ç¤ºï¼š**

```
   âŠ¢ e : Ï„    e âŸ¶ e'
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         âŠ¢ e' : Ï„
```

**é€‚ç”¨åœºæ™¯ï¼š**
- ç±»å‹å®‰å…¨ä¿è¯
- ä¼˜åŒ–æ­£ç¡®æ€§
- ç±»å‹æ¨å¯¼å¯é æ€§

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// ä¿æŒæ€§éªŒè¯: ç±»å‹åœ¨è½¬æ¢ä¸­ä¿æŒ

// å­ç±»å‹ä¿æŒ
fn upcast<T: Into<U>, U>(x: T) -> U {
    x.into()  // T â†’ U ä¿æŒç±»å‹ä¸€è‡´æ€§
}

// ç”Ÿå‘½å‘¨æœŸä¿æŒ
fn borrow_preservation<'a, 'b: 'a>(x: &'b str) -> &'a str {
    x  // 'b <: 'a, è¿”å›ç±»å‹ä¿æŒæœ‰æ•ˆæ€§
}

// Prusti ä¿æŒæ€§éªŒè¯
#[requires(x >= 0)]
#[ensures(result >= 0)]
fn preservation_example(x: i32) -> i32 {
    // è§„çº¦: x â†’ x + 1
    let y = x + 1;
    // ä¿æŒæ€§: y >= 0 (å› ä¸º x >= 0)
    y
}

// æ³›å‹ä¿æŒæ€§
#[requires(f.precondition(x))]
#[ensures(f.postcondition(result))]
fn map_preservation<T, U, F>(x: T, f: F) -> U
where F: Fn(T) -> U {
    f(x)
}
```

### 5.4 ç±»å‹å®‰å…¨ (Type Safety)

**å½¢å¼åŒ–å®šä¹‰ï¼š**

```
ç±»å‹å®‰å…¨ = è¿›å±•æ€§ + ä¿æŒæ€§

è¯­ä¹‰å®‰å…¨: 
- æ— ç±»å‹é”™è¯¯è¿è¡Œæ—¶å¼‚å¸¸
- å†…å­˜å®‰å…¨ï¼ˆæ— æ‚¬å‚æŒ‡é’ˆã€ç¼“å†²åŒºæº¢å‡ºï¼‰
- çº¿ç¨‹å®‰å…¨ï¼ˆæ— æ•°æ®ç«äº‰ï¼‰

å½¢å¼åŒ–:
âŠ¢ e : T âˆ§ e â†’* v â‡’ value(v) âˆ§ âŠ¢ v : T
```

**LaTeXè¡¨ç¤ºï¼š**

```
   âŠ¢ e : Ï„    e â†’* v
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  value(v) âˆ§ âŠ¢ v : Ï„
```

**é€‚ç”¨åœºæ™¯ï¼š**
- å®‰å…¨å…³é”®ç³»ç»Ÿ
- å½¢å¼åŒ–è¯­è¨€è§„èŒƒ
- ç¼–è¯‘å™¨æ­£ç¡®æ€§

**Rustå½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ï¼š**

```rust
// Rust ç±»å‹å®‰å…¨ç»¼åˆç¤ºä¾‹

// 1. æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨
fn ownership_safety() {
    let s = String::from("hello");
    let r1 = &s;  // ä¸å¯å˜å€Ÿç”¨
    let r2 = &s;  // å¤šä¸ªä¸å¯å˜å€Ÿç”¨ OK
    // let r3 = &mut s;  // é”™è¯¯! ä¸èƒ½åŒæ—¶å­˜åœ¨å¯å˜å’Œä¸å¯å˜å€Ÿç”¨
    println!("{} {}", r1, r2);
}  // s åœ¨è¿™é‡Œè¢«æ­£ç¡®é‡Šæ”¾

// 2. ç”Ÿå‘½å‘¨æœŸä¿è¯å¼•ç”¨æœ‰æ•ˆæ€§
fn lifetime_safety<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}  // è¿”å›å€¼ä¸å‚æ•°ç”Ÿå‘½å‘¨æœŸå…³è”

// 3. Send/Sync ä¿è¯çº¿ç¨‹å®‰å…¨
trait SendSafe: Send + Sync {}

fn thread_safety<T: SendSafe>(data: T) {
    std::thread::spawn(move || {
        // å®‰å…¨åœ°è·¨çº¿ç¨‹ä¼ é€’æ•°æ®
        drop(data);
    });
}

// 4. ç±»å‹å®‰å…¨çš„é”™è¯¯å¤„ç†
fn type_safe_error_handling() -> Result<i32, String> {
    let x = "42".parse::<i32>()?;  // ç±»å‹è½¬æ¢é”™è¯¯è¢«å¼ºåˆ¶å¤„ç†
    Ok(x * 2)
}

// 5. Prusti ç»¼åˆéªŒè¯
#[requires(idx < vec.len())]
#[ensures(result == vec[idx])]
fn safe_indexing<T: Copy>(vec: &Vec<T>, idx: usize) -> T {
    // ç±»å‹å®‰å…¨ + ç´¢å¼•è¾¹ç•Œæ£€æŸ¥
    vec[idx]
}
```

---

## 6. æ¦‚å¿µæ—å…³ç³»å›¾

### 6.1 æ•´ä½“å…³ç³»å›¾è°±

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         æ¦‚å¿µæ—äº¤å‰å…³ç³»å…¨æ™¯å›¾                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                           â”‚
â”‚   â”‚  æ•°å­¦åŸºç¡€    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Mathematics â”‚                                                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                                    â”‚   â”‚
â”‚          â”‚                                                           â”‚   â”‚
â”‚          â–¼                                                           â”‚   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚  å½’çº³æ³•     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  ç±»å‹ç†è®º   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  æ„é€ æ³•     â”‚   â”‚   â”‚
â”‚   â”‚  Induction â”‚ åº”ç”¨     â”‚  Type Theoryâ”‚ åŸºç¡€     â”‚Construction â”‚   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚          â”‚                       â”‚                       â”‚          â”‚   â”‚
â”‚          â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚          â”‚   â”‚
â”‚          â”‚        â”‚                                      â”‚          â”‚   â”‚
â”‚          â–¼        â–¼                                      â–¼          â”‚   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚ è‰¯åŸºå½’çº³    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Irisæ¡†æ¶   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”‚  Witness    â”‚   â”‚   â”‚
â”‚   â”‚ Well-Found â”‚ å»ºæ¨¡     â”‚  (å¹¶å‘)     â”‚ èµ„æº     â”‚ Extraction â”‚   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚                                  â”‚                                   â”‚   â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚   â”‚
â”‚          â”‚                       â”‚                       â”‚          â”‚   â”‚
â”‚          â–¼                       â–¼                       â–¼          â”‚   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚ å…±å½’çº³æ³•    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ RustBelt   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ åˆ†ç¦»é€»è¾‘   â”‚   â”‚   â”‚
â”‚   â”‚ Coinduction â”‚ æ— é™    â”‚ (æ‰€æœ‰æƒ)    â”‚ å®‰å…¨     â”‚ Separation â”‚   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚                                  â”‚                       â”‚          â”‚   â”‚
â”‚                                  â–¼                       â–¼          â”‚   â”‚
â”‚                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚                           â”‚ èµ„æºä»£æ•°   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Hoareé€»è¾‘  â”‚   â”‚   â”‚
â”‚                           â”‚     RA     â”‚ æ¨ç†     â”‚   Hoare    â”‚â”€â”€â”€â”˜   â”‚
â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                  â”‚                                      â”‚
â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚   â”‚  åè¯æ³•     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  å¯¹è§’çº¿æ³•   â”‚                                   â”‚
â”‚   â”‚ Contradict â”‚ ä¸å¯åˆ¤å®š â”‚  Diagonal   â”‚                                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 æ¦‚å¿µæ—äº¤å‰åº”ç”¨çŸ©é˜µ

| æŠ€æœ¯ | å½’çº³æ³• | æ„é€ æ³• | åè¯æ³• | åˆ†ç¦»é€»è¾‘ | ç±»å‹ç†è®º |
|------|--------|--------|--------|----------|----------|
| **é€’å½’å‡½æ•°** | â—â—â— æ ¸å¿ƒ | â—â— æå– | â— ç»ˆæ­¢ | â— èµ„æº | â—â— ç±»å‹ |
| **å¹¶å‘ç¨‹åº** | â—â— ä¸å˜é‡ | â— æ„é€  | â— äº’æ–¥ | â—â—â— æ ¸å¿ƒ | â—â— Send/Sync |
| **ç±»å‹ç³»ç»Ÿ** | â—â— å½’çº³å®šä¹‰ | â—â—â— æ„é€ è§„åˆ™ | â— ä¸€è‡´æ€§ | â— æ‰€æœ‰æƒ | â—â—â— æ ¸å¿ƒ |
| **å†…å­˜å®‰å…¨** | â— ç»“æ„ | â— åˆ†é… | â— æ£€æŸ¥ | â—â—â— èµ„æº | â—â— ç”Ÿå‘½å‘¨æœŸ |
| **ç»ˆæ­¢æ€§** | â—â—â— WFå½’çº³ | â— åº¦é‡ | â— åè®¾ | â—‹ | â— ç±»å‹ |

### 6.3 è¯æ˜æŠ€æœ¯ç»„åˆæ¨¡å¼

```
å¸¸è§è¯æ˜ç»„åˆæ¨¡å¼:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. å½’çº³ + æ„é€  (Inductive Construction)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¨¡å¼: ä½¿ç”¨å½’çº³æ³•è¯æ˜å­˜åœ¨æ€§ï¼ŒåŒæ—¶æ„é€ æ€§æå–ç®—æ³•                   â”‚
â”‚ åº”ç”¨: æ’åºç®—æ³•æ­£ç¡®æ€§è¯æ˜ï¼Œç¨‹åºç»¼åˆ                               â”‚
â”‚ Rust: fn sort<T: Ord>() -> Vec<T> çš„è¯æ˜æå–                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. åˆ†ç¦»é€»è¾‘ + ç±»å‹ç†è®º (SL + Types)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¨¡å¼: ç”¨åˆ†ç¦»é€»è¾‘è¯æ˜å†…å­˜å®‰å…¨ï¼Œç”¨ç±»å‹ç†è®ºä¿è¯é«˜å±‚æ€§è´¨              â”‚
â”‚ åº”ç”¨: RustBelt, æ‰€æœ‰æƒç³»ç»Ÿå½¢å¼åŒ–                                 â”‚
â”‚ Rust: Box<T>, Rc<T>, Arc<T> çš„å®‰å…¨æ€§è¯æ˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. å…±å½’çº³ + åè¯ (Coinduction + Contradiction)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¨¡å¼: ç”¨å…±å½’çº³å®šä¹‰æ— ç©·è¡Œä¸ºï¼Œç”¨åè¯è¯æ˜ç­‰ä»·æ€§                     â”‚
â”‚ åº”ç”¨: è¿›ç¨‹ç­‰ä»·æ€§ï¼Œæ— ç©·æ•°æ®ç»“æ„                                   â”‚
â”‚ Rust: Stream<T>, Iterator çš„æ­£ç¡®æ€§                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. è‰¯åŸºå½’çº³ + åˆ†ç¦»é€»è¾‘ (WF + SL)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¨¡å¼: è‰¯åŸºå½’çº³è¯æ˜ç»ˆæ­¢æ€§ï¼Œåˆ†ç¦»é€»è¾‘è¯æ˜èµ„æºå®‰å…¨                   â”‚
â”‚ åº”ç”¨: å¤æ‚é€’å½’å‡½æ•°ï¼Œèµ„æºå—é™ç³»ç»Ÿ                                 â”‚
â”‚ Rust: é€’å½’ä¸‹é™è§£æå™¨ï¼Œå†…å­˜æ± åˆ†é…å™¨                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. Rustå½¢å¼åŒ–éªŒè¯å·¥å…·é“¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Rust å½¢å¼åŒ–éªŒè¯å·¥å…·æ ˆ                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚   Prusti      â”‚    â”‚    Kani       â”‚    â”‚    Creusot    â”‚               â”‚
â”‚  â”‚   (Viper)     â”‚    â”‚   (CBMC)      â”‚    â”‚   (Why3)      â”‚               â”‚
â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚               â”‚
â”‚  â”‚ â€¢ å¥‘çº¦ç¼–ç¨‹   â”‚    â”‚ â€¢ ç©·å°½éªŒè¯   â”‚    â”‚ â€¢ åˆ†ç¦»é€»è¾‘   â”‚               â”‚
â”‚  â”‚ â€¢ è‡ªåŠ¨æ¨ç†   â”‚    â”‚ â€¢ ä¸å®‰å…¨ä»£ç  â”‚    â”‚ â€¢ æ¨¡å—åŒ–è¯æ˜ â”‚               â”‚
â”‚  â”‚ â€¢ å¹½çµä»£ç    â”‚    â”‚ â€¢ æœ‰é™çŠ¶æ€   â”‚    â”‚ â€¢ é«˜é˜¶å‡½æ•°   â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚          â”‚                    â”‚                    â”‚                        â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                               â–¼                                             â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚                    â”‚    MIR (Rust IR)    â”‚                                  â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
â”‚                               â”‚                                             â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚          â–¼                    â–¼                    â–¼                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚    Aeneas     â”‚    â”‚    hax        â”‚    â”‚  rustc-plugin â”‚               â”‚
â”‚   â”‚  (Leanæå–)   â”‚    â”‚  (F*/Coq)     â”‚    â”‚   (è‡ªå®šä¹‰)    â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚   â”‚                    åº•å±‚è¯æ˜åŠ©æ‰‹                           â”‚              â”‚
â”‚   â”‚  Coq â—„â”€â”€â”€â”€â”€â”€â–º Isabelle/HOL â—„â”€â”€â”€â”€â”€â”€â–º Lean 4 â—„â”€â”€â”€â”€â”€â”€â–º F*   â”‚              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8. ç›¸å…³æ–‡æ¡£é“¾æ¥

### 8.1 å­¦æœ¯è®ºæ–‡ä¸èµ„æº

| ç±»åˆ« | èµ„æº | é“¾æ¥ |
|------|------|------|
| **Irisæ¡†æ¶** | Iris é¡¹ç›®ä¸»é¡µ | https://iris-project.org/ |
| | Higher-Order Ghost State | POPL 2016 |
| | RustBelt è®ºæ–‡ | POPL 2018 |
| **åˆ†ç¦»é€»è¾‘** | Separation Logic Tutorial | https://plv.mpi-sws.org/seplog/ |
| | Verified Software Toolchain | http://vst.cs.princeton.edu/ |
| **ç±»å‹ç†è®º** | PFPL (Bob Harper) | https://www.cs.cmu.edu/~rwh/pfpl/ |
| | TAPL (Pierce) | https://www.cis.upenn.edu/~bcpierce/tapl/ |
| **å½’çº³æ³•** | Coq å½’çº³æ³•æ•™ç¨‹ | https://softwarefoundations.cis.upenn.edu/ |
| | Induction Principles | https://lean-lang.org/theorem_proving_in_lean/induction.html |

### 8.2 Rustå½¢å¼åŒ–éªŒè¯èµ„æº

| å·¥å…· | æ–‡æ¡£ | GitHub |
|------|------|--------|
| **Prusti** | https://www.pm.inf.ethz.ch/research/prusti.html | https://github.com/viperproject/prusti |
| **Kani** | https://model-checking.github.io/kani/ | https://github.com/model-checking/kani |
| **Creusot** | https://creusot-rs.github.io/ | https://github.com/creusot-rs/creusot |
| **Aeneas** | https://aeneas-verif.org/ | https://github.com/AeneasVerif/aeneas |
| **hax** | https://hacspec.org/ | https://github.com/hacspec/hax |

### 8.3 ç›¸å…³æœ¬åœ°æ–‡æ¡£

```
docs/research_notes/formal_methods/
â”œâ”€â”€ PROOF_TECHNIQUES_MINDMAP.md      # æœ¬æ–‡æ¡£
â”œâ”€â”€ SEPARATION_LOGIC_OVERVIEW.md      # åˆ†ç¦»é€»è¾‘æ¦‚è¿°
â”œâ”€â”€ TYPE_SYSTEM_FORMALIZATION.md      # ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–
â”œâ”€â”€ RUST_VERIFICATION_TOOLS.md        # RustéªŒè¯å·¥å…·
â”œâ”€â”€ IRIS_FRAMEWORK_NOTES.md           # Irisæ¡†æ¶ç¬”è®°
â””â”€â”€ RUSTBELT_ANALYSIS.md              # RustBeltåˆ†æ
```

---

## 9. å¿«é€Ÿå‚è€ƒå¡ç‰‡

### 9.1 è¯æ˜æŠ€æœ¯é€‰æ‹©æŒ‡å—

```
                    éœ€è¦è¯æ˜ä»€ä¹ˆæ€§è´¨?
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚               â”‚               â”‚
           â–¼               â–¼               â–¼
      ç»ˆæ­¢/æ­£ç¡®æ€§      å­˜åœ¨æ€§/æ„é€ æ€§      ä¸å¯èƒ½æ€§
           â”‚               â”‚               â”‚
           â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ å½’çº³æ³•   â”‚    â”‚ æ„é€ æ³•   â”‚    â”‚ åè¯æ³•   â”‚
    â”‚ Inductionâ”‚    â”‚Construct â”‚    â”‚Contradictâ”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚â€¢æ•°å­¦å½’çº³ â”‚    â”‚â€¢æ˜¾å¼æ„é€  â”‚    â”‚â€¢å½’è°¬æ³•   â”‚
    â”‚â€¢ç»“æ„å½’çº³ â”‚    â”‚â€¢Witness  â”‚    â”‚â€¢å¯¹è§’çº¿æ³• â”‚
    â”‚â€¢è‰¯åŸºå½’çº³ â”‚    â”‚â€¢ç¨‹åºæå– â”‚    â”‚â€¢åå½’æ³•   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         å¹¶å‘/èµ„æºç›¸å…³?           ç±»å‹ç›¸å…³?
              â”‚                       â”‚
              â–¼                       â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚åˆ†ç¦»é€»è¾‘  â”‚            â”‚ç±»å‹ç†è®º  â”‚
       â”‚Separationâ”‚            â”‚  Types  â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚â€¢Iris     â”‚            â”‚â€¢è¿›å±•æ€§   â”‚
       â”‚â€¢Hoare    â”‚            â”‚â€¢ä¿æŒæ€§   â”‚
       â”‚â€¢èµ„æºä»£æ•° â”‚            â”‚â€¢ç±»å‹å®‰å…¨ â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.2 å¸¸ç”¨è¯æ˜æ¨¡å¼é€ŸæŸ¥

| ç›®æ ‡ | æ–¹æ³• | Rustç¤ºä¾‹ |
|------|------|----------|
| é€’å½’ç»ˆæ­¢ | è‰¯åŸºå½’çº³ + åº¦é‡å‡½æ•° | `#[decreases((m, n))]` |
| å¾ªç¯æ­£ç¡® | éœå°”é€»è¾‘ + ä¸å˜é‡ | `#[invariant(i >= 0)]` |
| å¹¶å‘å®‰å…¨ | Iris + ä¸å˜é‡ | `#[atomic]` |
| å†…å­˜å®‰å…¨ | åˆ†ç¦»é€»è¾‘ + æ‰€æœ‰æƒ | `Box<T>, &mut T` |
| ç±»å‹å®‰å…¨ | è¿›å±• + ä¿æŒ | ç©·å°½æ€§æ£€æŸ¥ |
| å­˜åœ¨è¯æ˜ | æ„é€ æ€§æå– | `#[ensures(exists(result))]` |

---

## 10. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†è¯æ˜æŠ€æœ¯æ¦‚å¿µæ—è°±çš„å®Œæ•´æ€ç»´å¯¼å›¾ï¼Œæ¶µç›–äº”å¤§æ ¸å¿ƒæ¦‚å¿µæ—ï¼š

1. **å½’çº³æ³•**ï¼šä»åŸºç¡€åˆ°å¤æ‚ï¼Œé€šè¿‡ç»“æ„ã€è‰¯åŸºã€å…±å½’çº³å¤„ç†ä¸åŒé€’å½’æ¨¡å¼
2. **æ„é€ æ³•**ï¼šå°†å­˜åœ¨æ€§è¯æ˜è½¬åŒ–ä¸ºç®—æ³•ï¼Œå®ç°è¯æ˜æºå¸¦ä»£ç 
3. **åè¯æ³•**ï¼šé€šè¿‡çŸ›ç›¾æ¨å¯¼å’Œä¸å¯èƒ½æ€§è¯æ˜ç¡®ç«‹è¾¹ç•Œ
4. **åˆ†ç¦»é€»è¾‘**ï¼šç‰¹åˆ«æ˜¯Irisæ¡†æ¶ï¼Œä¸ºå¹¶å‘å’Œèµ„æºç®¡ç†æä¾›æ¨¡å—åŒ–æ¨ç†
5. **ç±»å‹ç†è®º**ï¼šè¿›å±•æ€§ã€ä¿æŒæ€§å…±åŒä¿éšœç±»å‹å®‰å…¨

è¿™äº›æŠ€æœ¯åœ¨Rustå½¢å¼åŒ–éªŒè¯ä¸­æœ‰å¹¿æ³›åº”ç”¨ï¼Œé€šè¿‡Prustiã€Kaniã€Creusotç­‰å·¥å…·å°†ç†è®ºè½¬åŒ–ä¸ºå®è·µï¼Œç¡®ä¿Rustç¨‹åºçš„æ­£ç¡®æ€§å’Œå®‰å…¨æ€§ã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬: 1.0*  
*æœ€åæ›´æ–°: 2026-02-21*  
*ç»´æŠ¤è€…: Research Notes Team*
