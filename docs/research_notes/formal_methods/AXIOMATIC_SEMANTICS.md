# 公理语义

> **创建日期**: 2026-02-28
> **最后更新**: 2026-02-28
> **Rust 版本**: 1.93.1+ (Edition 2024)
> **状态**: ✅ 已完成
> **领域**: 程序验证

---

## 概述

公理语义通过逻辑公理和推理规则来描述程序行为，是形式化验证的基础。本文档建立Rust语言的公理语义框架，包括霍尔逻辑、最弱前置条件和最强后置条件。

---

## 一、霍尔逻辑 (Hoare Logic)

### 1.1 基本概念

**霍尔三元组**: `{P} C {Q}`

- P: 前置条件 (precondition)
- C: 命令/程序
- Q: 后置条件 (postcondition)

**含义**: 如果P在C执行前成立，且C终止，则Q在C执行后成立。

### 1.2 推理规则

**空语句**:

```
────────── (Skip)
{P} skip {P}
```

**赋值**:

```
────────────────── (Assign)
{P[e/x]} x := e {P}
```

**顺序**:

```
{P} C₁ {Q}    {Q} C₂ {R}
────────────────────────── (Seq)
      {P} C₁; C₂ {R}
```

**条件**:

```
{P ∧ b} C₁ {Q}    {P ∧ ¬b} C₂ {Q}
────────────────────────────────── (If)
     {P} if b then C₁ else C₂ {Q}
```

**循环**:

```
{I ∧ b} C {I}
────────────────────────── (While)
{I} while b do C {I ∧ ¬b}

其中I是循环不变式
```

### 1.3 衍生规则

**强化前置条件**:

```
P' → P    {P} C {Q}
─────────────────── (Strengthen Pre)
     {P'} C {Q}
```

**弱化后置条件**:

```
{P} C {Q}    Q → Q'
─────────────────── (Weaken Post)
     {P} C {Q'}
```

**合取**:

```
{P₁} C {Q₁}    {P₂} C {Q₂}
─────────────────────────── (Conjunction)
   {P₁ ∧ P₂} C {Q₁ ∧ Q₂}
```

**析取**:

```
{P₁} C {Q}    {P₂} C {Q}
───────────────────────── (Disjunction)
     {P₁ ∨ P₂} C {Q}
```

---

## 二、最弱前置条件 (Weakest Precondition)

### 2.1 定义

**wp(C, Q)**: 使命令C执行后Q成立的最弱(最一般)条件

**性质**:

```
{wp(C, Q)} C {Q}  是有效的
且对于任何P使得 {P} C {Q}，有 P → wp(C, Q)
```

### 2.2 计算规则

**空语句**:

```
wp(skip, Q) = Q
```

**赋值**:

```
wp(x := e, Q) = Q[e/x]
```

**顺序**:

```
wp(C₁; C₂, Q) = wp(C₁, wp(C₂, Q))
```

**条件**:

```
wp(if b then C₁ else C₂, Q) = (b → wp(C₁, Q)) ∧ (¬b → wp(C₂, Q))
```

**循环**:

```
wp(while b do C, Q) = μZ. (¬b → Q) ∧ (b → wp(C, Z))

(最小不动点)
```

### 2.3 在Rust中的应用

**所有权转移**:

```rust
let y = x;
```

```
wp(let y = x, Q) = owns(x, v) * Q[v/y, ⊥/x]

(前提: x拥有v，后置: y拥有v，x失效)
```

**借用**:

```rust
let r = &x;
```

```
wp(let r = &x, Q) = ∃v. x ↦ v * Q[&x/r]
```

---

## 三、最强后置条件 (Strongest Postcondition)

### 3.1 定义

**sp(P, C)**: 从条件P出发，执行C后成立的最强(最具体)条件

**性质**:

```
{P} C {sp(P, C)}  是有效的
且对于任何Q使得 {P} C {Q}，有 sp(P, C) → Q
```

### 3.2 计算规则

**空语句**:

```
sp(P, skip) = P
```

**赋值**:

```
sp(P, x := e) = ∃v. P[v/x] ∧ x = e[v/x]
```

**顺序**:

```
sp(P, C₁; C₂) = sp(sp(P, C₁), C₂)
```

### 3.3 与最弱前置条件的关系

**对偶性**:

```
P → wp(C, Q)  ⟺  sp(P, C) → Q
```

**伽罗瓦连接**:

```
sp(P, C) ⊨ Q    ⟺    P ⊨ wp(C, Q)
```

---

## 四、Rust特定规则

### 4.1 所有权规则

**移动**:

```
{owns(x, v)}
let y = x;
{owns(y, v) * x ↦ ⊥}
```

**复制**:

```
{x ↦ v}
let y = x;
{x ↦ v * y ↦ v}
```

**Drop**:

```
{owns(x, v)}
drop(x)
{emp}    (emp表示空资源)
```

### 4.2 借用规则

**不可变借用**:

```
{x ↦ v}
let r = &x;
{x ↦ v * r ↦ &x * readonly(r)}
```

**可变借用**:

```
{x ↦ _}
let r = &mut x;
{x ↦ ⊥ * r ↦ &mut x * mutable(r) * exclusive(r)}
```

**借用结束**:

```
{r ↦ &mut x * mutable(r) * x ↦ ⊥ * r ↦ v}
// r超出作用域
{x ↦ v}
```

### 4.3 生命周期规则

**子类型**:

```
{'a: 'b} ⊢ &‘a T <: &‘b T
```

**生命周期包含**:

```
{lifetime(‘a) * lifetime(‘b) * ‘a: ‘b}
⊢ ‘a包含‘b
```

---

## 五、并发程序验证

### 5.1 Owicki-Gries方法

**并行规则**:

```
{P₁} C₁ {Q₁}    {P₂} C₂ {Q₂}
P₁, Q₁ 不与 C₂ 的变量冲突
P₂, Q₂ 不与 C₁ 的变量冲突
────────────────────────────────
{P₁ ∧ P₂} C₁ || C₂ {Q₁ ∧ Q₂}
```

### 5.2 分离逻辑并发规则

**并行组合**:

```
{P₁} C₁ {Q₁}    {P₂} C₂ {Q₂}
────────────────────────────────
{P₁ * P₂} C₁ || C₂ {Q₁ * Q₂}
```

**原子块**:

```
⟨P⟩ C ⟨Q⟩
─────────────────────
{P} atomic {C} {Q}
```

### 5.3 Rust并发规则

**线程创建**:

```
{P * T: Send}
let handle = spawn(move || { C });
{P * handle: JoinHandle<T>}
```

**线程加入**:

```
{handle: JoinHandle<T>}
handle.join();
{Result<T>}
```

---

## 六、验证条件生成

### 6.1 基本算法

```
vc({P} C {Q}) =
  生成验证条件使得 wp(C, Q) 被 P 蕴含
```

### 6.2 示例

**程序**:

```rust
let mut x = 0;
while x < 10 {
    x = x + 1;
}
assert!(x == 10);
```

**验证条件**:

```
1. x = 0 → I
2. I ∧ x < 10 → wp(x = x + 1, I)
3. I ∧ ¬(x < 10) → x == 10
```

**解**:

```
I = x ≤ 10 ∧ x ≥ 0
```

---

## 七、与类型系统的联系

### 7.1 类型作为规范

**Curry-Howard对应**:

```
类型 ≃ 命题
程序 ≃ 证明
```

**类型判断作为霍尔三元组**:

```
Γ ⊢ e : T   ⟺   {Γ} e {ret: T}
```

### 7.2 细化类型

**定义**:

```
{v: T | P(v)}    (类型T的值为v使得P(v)成立)
```

**示例**:

```rust
{x: i32 | x > 0}  // 正整数类型
```

---

## 八、工具与应用

### 8.1 验证工具

| 工具 | 方法 | 适用范围 |
| :--- | :--- | :--- |
| Why3 | WP计算 | 通用程序 |
| Dafny | 霍尔逻辑 | 命令式程序 |
| Viper | 分离逻辑 | 面向对象 |
| Iris | 高阶分离逻辑 | 并发程序 |

### 8.2 在Rust验证中的应用

**Creusot**:

```rust
#[requires(x > 0)]
#[ensures(result > x)]
fn increment(x: u32) -> u32 {
    x + 1
}
```

**Prusti**:

```rust
#[pure]
#[requires(x > 0)]
#[ensures(ret > 0)]
fn abs(x: i32) -> i32 {
    if x < 0 { -x } else { x }
}
```

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-28
**状态**: ✅ 公理语义文档完成
