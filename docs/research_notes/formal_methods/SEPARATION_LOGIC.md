# 分离逻辑

> **创建日期**: 2026-02-28
> **最后更新**: 2026-02-28
> **状态**: ✅ 已完成
> **领域**: 程序验证/内存推理

---

## 概述

分离逻辑(Separation Logic)是霍尔逻辑的扩展，专门用于推理使用共享可变状态的程序。
它为Rust的所有权和借用系统提供了形式化基础。

---

## 一、分离逻辑基础

### 1.1 分离合取 (*)

**语法**: `P * Q` (P和Q分别描述不相交的内存区域)

**含义**:

- 内存可分割为两部分
- 一部分满足P，另一部分满足Q

**规则**:

```
H₁ ⊨ P    H₂ ⊨ Q    H₁ ⊥ H₂
────────────────────────────
      H₁ ⊎ H₂ ⊨ P * Q
```

### 1.2 分离蕴含 (-*)

**语法**: `P -* Q` (如果添加满足P的内存，则Q成立)

**含义**:

- 将P描述的内存添加到当前堆中
- 结果满足Q

**规则**:

```
H ⊨ P -* Q    H' ⊨ P    H ⊥ H'
────────────────────────────────
         H ⊎ H' ⊨ Q
```

### 1.3 空堆断言 (emp)

**含义**: 堆为空

**规则**:

```
∅ ⊨ emp
```

### 1.4 Points-to断言

**语法**: `l ↦ v` (位置l存储值v)

**含义**:

- 堆只包含一个单元
- 地址l，值v

**规则**:

```
{l → v} ⊨ l ↦ v
```

---

## 二、分离逻辑推理规则

### 2.1 框架规则 (Frame Rule)

```
{P} C {Q}
──────────────────
{P * R} C {Q * R}

(要求: C不修改R中的资源)
```

**意义**: 局部推理，不受无关资源影响

**在Rust中的应用**:

```rust
// 只使用x，y不受影响
{ x ↦ _ }
*x = 42;
{ x ↦ 42 }

// 由框架规则
{ x ↦ _ * y ↦ 0 }
*x = 42;
{ x ↦ 42 * y ↦ 0 }
```

### 2.2 规则合取

```
{P₁} C {Q₁}    {P₂} C {Q₂}
───────────────────────────
   {P₁ * P₂} C {Q₁ * Q₂}
```

### 2.3 分配规则

**存在量词分配**:

```
{∃x.P} C {Q}    x ∉ FV(C, Q)
────────────────────────────
    {P} C {Q}
```

**分离合取分配**:

```
{P} C {Q₁}    {P} C {Q₂}
─────────────────────────
   {P} C {Q₁ ∧ Q₂}
```

---

## 三、在Rust形式化中的应用

### 3.1 所有权建模

**独占所有权**:

```
own(x, v) ≃ x ↦ v
```

**所有权转移**:

```
{own(x, v) * own(y, _)}
  y = x;
{own(x, ⊥) * own(y, v)}
```

**移动语义**:

```rust
let y = x;  // x的所有权转移到y

// 逻辑上:
{ x ↦ v }
let y = x;
{ x ↦ ⊥ * y ↦ v }  // x失效，y获得所有权
```

### 3.2 借用建模

**不可变借用**:

```
borrow_immut(x) ≃ ∃v. x ↦ v ∧ readonly(v)
```

**可变借用**:

```
borrow_mut(x) ≃ x ↦ _ * exclusive(x)
```

**借用规则**:

```
{ x ↦ v }
let r = &x;
{ x ↦ v * r ↦ &x * readonly(r) }

// 可变借用排斥其他借用
borrow_mut(x) * borrow_mut(x) ⊢ ⊥
borrow_mut(x) * borrow_immut(x) ⊢ ⊥
```

### 3.3 资源共享

**引用计数**:

```
rc(x, n) ≃ x ↦ (v, n) * (if n > 0 then shared(v) else emp)
```

**原子引用计数**:

```
arc(x, n) ≃ x ↦ₐ (v, n) * (if n > 0 then threadsafe_shared(v) else emp)
```

---

## 四、Iris分离逻辑框架

### 4.1 资源代数

**资源代数定义**:

```
(RA, •, ε, V)
- R: 资源集合
- •: 组合操作 (结合、交换)
- ε: 单位元
- V: 有效性谓词
```

**例子 - Points-to**:

```
l ↦ v • l ↦ v'  无效 (冲突)
l₁ ↦ v₁ • l₂ ↦ v₂  有效 (当 l₁ ≠ l₂)
```

### 4.2 模态断言

**持久性 (□)**:

```
□P: 资源是持久的，可任意复制

□P ⊢ P
□P ⊢ □□P
```

**Later (▷)**:

```
▷P: 在"下一步"成立

用于处理递归和不动点
```

**更新 (|={E}=>)**:

```
|= {E}=> P: 可以更新幽灵状态使P成立
```

### 4.3 在RustBelt中的应用

**协议状态机**:

```
Protocol(T) = μrec. (own(T) ∨ shared(T) ∨ ...)
```

**生命周期逻辑**:

```
lifetime(κ) = ▷(κ_alive) * ...
```

---

## 五、高级推理模式

### 5.1 幽灵状态

**幽灵变量**: 只在规范中存在，不影响程序执行

```
{P * γ ↦ v}  // γ是幽灵变量
C
{Q * γ ↦ v'}
```

**在Rust中的应用**:

- 追踪所有权状态
- 验证协议遵守

### 5.2 视图移位 (View Shift)

```
P ={E}=∗ Q

含义: 可以更新幽灵状态，将P转换为Q
```

**应用**: 资源重新解释

### 5.3 原子性推理

**原子命令**:

```
⟨P⟩ e ⟨Q⟩  // 表达式e原子地从P状态转换到Q状态
```

**在并发中的应用**:

```rust
{ x ↦ n }
x.fetch_add(1, Relaxed)
{ x ↦ n+1 }
```

---

## 六、证明模式

### 6.1 所有权证明模式

**唯一性证明**:

```
要证: owns(x, v) * owns(x, v') ⊢ v = v'

证明:
1. owns(x, v) ⊢ x ↦ v
2. owns(x, v') ⊢ x ↦ v'
3. x ↦ v * x ↦ v' ⊢ ⊥  (如果v ≠ v')
4. 因此v = v'
```

### 6.2 借用证明模式

**无数据竞争证明**:

```
要证: 同时有&mut x和&x是不可能的

证明:
1. &mut x ⊢ exclusive(x)
2. &x ⊢ shared(x)
3. exclusive(x) * shared(x) ⊢ ⊥
4. 因此不能同时拥有
```

---

## 七、与其他逻辑的对比

| 逻辑 | 资源处理 | 适用场景 | 工具支持 |
| :--- | :--- | :--- | :--- |
| 霍尔逻辑 | 全局状态 | 简单程序 | 多种 |
| 分离逻辑 | 局部资源 | 指针程序 | VeriFast, Infer |
| 高阶分离逻辑 | 高阶资源 | 高阶函数 | Iris, VST |
| 并发分离逻辑 | 并发资源 | 并发程序 | Iris, FCSL |

---

## 八、形式化验证工具

### 8.1 Iris (Coq)

```coq
(* Iris中的断言 *)
Definition own (l: loc) (v: val) : iProp :=
  l ↦ v.

(* 规范 *)
Lemma assign_spec (l: loc) (v: val):
  {{{ l ↦ _ }}}
    #l <- v
  {{{ RET #(); l ↦ v }}}.
```

### 8.2 VeriFast

```c
/*@
predicate owns(int* x, int v) = x |-> v;
@*/

void assign(int* x, int v)
/*@ requires owns(x, _); @*/
/*@ ensures owns(x, v); @*/
{
    *x = v;
}
```

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-28
**状态**: ✅ 分离逻辑文档完成
