# 教程：所有权与内存安全

> **创建日期**: 2026-02-24
> **最后更新**: 2026-02-28
> **目标受众**: 初学者-进阶
> **预计阅读时间**: 35分钟
> **级别**: L1/L2

---

## 引言

所有权是Rust最独特的特性，它使Rust能够在没有垃圾回收器的情况下保证内存安全。本教程将深入讲解所有权系统的工作原理、规则以及如何利用它编写安全的代码。

---

## 第一部分：为什么需要所有权

### 内存管理的困境

传统语言面临的三难问题：

```
         内存安全
            /\
           /  \
          /    \
         /      \
        /        \
   性能 <--------> 易用性
```

| 语言 | 策略 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| C/C++ | 手动管理 | 最高性能 | 容易出错(悬垂指针、双重释放等) |
| Java/Python | 垃圾回收 | 安全易用 | 运行时开销、停顿 |
| Rust | 所有权系统 | 零成本抽象 | 学习曲线陡峭 |

### Rust的解决方案

所有权系统在编译时检查内存安全，无需运行时开销：

```rust
fn main() {
    let s = String::from("hello");  // s拥有字符串
    takes_ownership(s);              // s的所有权转移到函数
    // println!("{}", s);            // 错误! s不再有效

    let x = 5;                       // x是基本类型
    makes_copy(x);                   // 复制值
    println!("{}", x);               // OK! x仍然有效
}

fn takes_ownership(s: String) {
    println!("{}", s);
} // s在这里drop，内存释放

fn makes_copy(i: i32) {
    println!("{}", i);
}
```

---

## 第二部分：所有权规则

### 三大规则

1. **每个值都有一个所有者**
2. **同一时间只能有一个所有者**
3. **当所有者离开作用域，值被丢弃**

### 作用域与生命周期

```rust
{
    let s = String::from("hello"); // s进入作用域

    // 使用s
    println!("{}", s);

} // s离开作用域，内存自动释放

// println!("{}", s); // 错误! s已失效
```

### 内存表示

```
栈                    堆
┌──────────┐         ┌──────────────┐
│ name: s  │───────>│ "hello"      │
│ ptr      │         │ 容量: 5      │
│ len: 5   │         │ 长度: 5      │
│ cap: 5   │         └──────────────┘
└──────────┘

s离开作用域时:
1. 调用drop(s)
2. 释放堆内存
3. 清理栈空间
```

---

## 第三部分：移动语义

### 什么是移动

```rust
let s1 = String::from("hello");
let s2 = s1;  // s1的所有权移动到s2

// println!("{}", s1); // 错误! s1已失效
println!("{}", s2);    // OK
```

**为什么移动而不是复制?**

- 性能: 避免深拷贝
- 安全: 避免双重释放

### 浅复制的问题(Copy vs Move)

```rust
// C++中的问题(如果只有浅拷贝)
let s1 = String::from("hello");
let s2 = s1;                    // 浅拷贝: 两个指针指向同一内存
// s1和s2都离开作用域
// 双重释放! 未定义行为!

// Rust的解决方案: 移动
let s1 = String::from("hello");
let s2 = s1;                    // 移动: s1失效，只有s2释放
// 安全!
```

---

## 第四部分：Copy trait

### 哪些类型实现Copy

```rust
// 实现Copy的类型(栈上简单复制)
let x: i32 = 5;
let y = x;        // 复制值
println!("{}", x); // OK! x仍然有效

// 同样适用于:
// - 所有整数类型(u32, i64等)
// - 布尔类型
// - 浮点数
// - 字符类型
// - 只包含Copy类型的元组
```

### 自定义类型的Copy

```rust
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

let p1 = Point { x: 1, y: 2 };
let p2 = p1;           // 复制
println!("{}", p1.x);  // OK!

// 注意: 包含非Copy类型的结构体不能实现Copy
#[derive(Clone)]
struct Container {
    data: String,  // String不是Copy
}
// 不能derive(Copy)!
```

---

## 第五部分：借用

### 为什么需要借用

```rust
// 不使用借用: 需要返回值来继续使用
fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)  // 必须返回所有权
}

let s1 = String::from("hello");
let (s2, len) = calculate_length(s1);  // 繁琐!
```

```rust
// 使用借用: 简洁安全
fn calculate_length(s: &String) -> usize {
    s.len()  // 借用，不获取所有权
}

let s1 = String::from("hello");
let len = calculate_length(&s1);  // 借用s1
println!("{} 长度是 {}", s1, len);  // s1仍然可用!
```

### 借用规则

```rust
// 规则1: 可同时有多个不可变借用
let r1 = &s;
let r2 = &s;
println!("{} {}", r1, r2);  // OK

// 规则2: 只能有一个可变借用
let r1 = &mut s;
// let r2 = &mut s;  // 错误! 不能同时有两个可变借用

// 规则3: 不能同时有可变和不可变借用
let r1 = &s;
// let r2 = &mut s;  // 错误!
println!("{}", r1);  // r1最后使用在这里
```

### 借用与作用域

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
    r1.push_str(" world");
} // r1在这里结束

// 现在可以创建新的借用
let r2 = &mut s;  // OK!
r2.push_str("!");
```

---

## 第六部分：悬垂引用

### 编译器如何防止

```rust
fn dangle() -> &String {  // 错误! 返回悬垂引用
    let s = String::from("hello");
    &s  // s在函数结束时释放
}     // 返回的引用指向无效内存!

// 编译错误:
// error[E0106]: 缺少生命周期说明符
```

### 正确的做法

```rust
// 方案1: 返回所有权
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // 转移所有权
}

// 方案2: 返回切片(如果输入是引用)
fn first_word(s: &str) -> &str {
    &s[0..1]  // 返回与输入相同生命周期的引用
}
```

---

## 第七部分：字符串切片

### String vs &str

```rust
// String: 拥有所有权的可变字符串(堆分配)
let s = String::from("hello world");

// &str: 字符串切片(借用)
let hello = &s[0..5];    // "hello"
let world = &s[6..11];   // "world"

// 内存布局
// s: String --指向--> 堆内存: "hello world"
// hello: &str --指向--> s的[0..5]
// world: &str --指向--> s的[6..11]
```

### 字符串字面量

```rust
let s: &'static str = "hello";  // 'static生命周期
// 字符串字面量存储在二进制文件中
// 'static表示整个程序运行期间有效
```

---

## 第八部分：实践模式

### 模式1: 所有权转移

```rust
fn process(data: Vec<u8>) -> Vec<u8> {
    // 处理数据，返回所有权
    data.into_iter().map(|b| b * 2).collect()
}

let data = vec![1, 2, 3];
let processed = process(data);  // 转移所有权
// data不再可用
```

### 模式2: 借用检查

```rust
fn analyze(data: &[u8]) -> Analysis {
    // 只读分析，不修改
    Analysis {
        sum: data.iter().sum(),
        len: data.len(),
    }
}

let data = vec![1, 2, 3];
let a1 = analyze(&data);  // 借用
let a2 = analyze(&data);  // 可以同时多次借用
```

### 模式3: 可变借用

```rust
fn normalize(data: &mut Vec<f64>) {
    let max = data.iter().copied().fold(0.0, f64::max);
    for v in data.iter_mut() {
        *v /= max;
    }
}

let mut data = vec![1.0, 2.0, 3.0];
normalize(&mut data);  // 可变借用修改数据
```

---

## 第九部分：常见错误

| 错误 | 代码 | 修复 |
| :--- | :--- | :--- |
| 使用已移动值 | `let y = x; use x` | 克隆或重新设计 |
| 悬垂引用 | 返回局部引用 | 返回所有权或使用String |
| 多重可变借用 | `&mut x` 和 `&mut x` | 限制作用域或使用内部可变性 |
| 借用冲突 | `&x` 和 `&mut x` | 分离使用范围 |

---

## 第十部分：形式化视角

### 所有权定理

**定理 (所有权唯一性)**: 在任意程序点，每个值最多只有一个有效的所有者。

**定理 (内存安全)**: 良类型的Rust程序不会出现以下错误:

- 使用已释放内存
- 双重释放
- 空指针解引用
- 数据竞争

### 与形式化文档的关联

| 概念 | 形式化定义 | 文档位置 |
| :--- | :--- | :--- |
| 所有权转移 | `move: T -> T` | ownership_model.md |
| 借用 | `&'a T`, `&'a mut T` | borrow_checker_proof.md |
| 生命周期 | `'a: 'b` | lifetime_formalization.md |
| Drop | `drop: T -> ()` | ownership_model.md |

---

## 总结

```
所有权系统
    │
    ├── 所有权规则
    │   ├── 每个值有唯一所有者
    │   ├── 同一时间只有一个所有者
    │   └── 离开作用域自动释放
    │
    ├── 移动语义
    │   ├── 转移所有权
    │   └── 禁止双重释放
    │
    ├── Copy trait
    │   ├── 简单类型复制
    │   └── 栈上值语义
    │
    └── 借用
        ├── 不可变借用 &T
        ├── 可变借用 &mut T
        └── 编译时检查安全
```

## 引言

Rust的所有权系统是其最独特的特性。
但为什么这个系统能保证内存安全？
本文将通过**直观的例子**和**形式化论证**，让你理解所有权背后的安全保证。

---

## 第一部分：问题是什么？

### C/C++中的内存错误

在C/C++中，以下错误很常见：

```c
// 使用已释放内存
char* ptr = malloc(100);
free(ptr);
printf("%s", ptr);  // 悬垂指针！

// 双重释放
char* ptr2 = malloc(100);
free(ptr2);
free(ptr2);  // 双重释放！

// 内存泄漏
void leak() {
    char* ptr = malloc(100);
    // 忘记free
}
```

这些错误导致：

- 安全漏洞（70%的安全问题与内存有关）
- 程序崩溃
- 难以调试

### 传统解决方案的局限

| 方案 | 优点 | 缺点 |
| :--- | :--- | :--- |
| 垃圾回收(GC) | 自动管理 | 运行时开销、暂停 |
| 智能指针 | 部分自动化 | 循环引用、仍然可能出错 |
| 静态分析 | 编译时检查 | 误报、不能捕获所有错误 |

**Rust的方案**: 编译时通过所有权系统完全防止这些错误。

---

## 第二部分：所有权的核心规则

### 规则很简单

1. **每个值有且只有一个所有者**
2. **所有者离开作用域，值被丢弃**
3. **所有权可以转移(Move)或借用(Borrow)**

### 直观理解：图书馆比喻

想象一个图书馆系统：

```
书（值）
    │
    ├── 一个人借走（所有权）
    │   └── 书在这个人的书架上
    │   └── 这个人离开图书馆时，必须还书（Drop）
    │
    ├── 转借给别人（Move）
    │   └── 原持有者的书架上不再有此书
    │
    └── 允许别人看但不借走（Borrow）
        └── 书仍在原处，别人临时使用
```

**关键**: 任何时候，书的位置和状态都是明确的。

---

## 第三部分：为什么这能保证安全？

### 安全保证1：没有悬垂指针

**问题**: 在C中，指针指向已释放内存。

**Rust的解决**: 所有权转移后，原变量无效。

```rust
let s1 = String::from("hello");
let s2 = s1;  // 所有权转移到s2

// println!("{}", s1);  // 编译错误！s1已无效
println!("{}", s2);     // OK，s2是现在的所有者
```

**形式化保证**:

```
Move(s1, s2, v) 后:
- Ω(s2) = Owned, Γ(s2) = v
- Ω(s1) = Moved, Γ(s1) = None
- 使用Moved状态的变量 = 编译错误
```

### 安全保证2：没有双重释放

**问题**: 在C中，同一内存被释放两次。

**Rust的解决**: 每个值只有一个所有者，所以只会在所有者离开作用域时释放一次。

```rust
{
    let s = String::from("hello");
    // 使用s
}  // s在这里自动释放，且只释放一次

// 不可能再次释放s，因为s已经不存在了
```

**形式化保证**:

```
∀v, ∃!x, owns(x, v) → Drop(x) 只发生一次
```

### 安全保证3：没有数据竞争

**问题**: 多线程同时读写同一数据。

**Rust的解决**: 借用规则保证读写互斥。

```rust
let mut data = vec![1, 2, 3];

// 可以同时有多个读者
let r1 = &data;
let r2 = &data;
println!("{} {}", r1[0], r2[0]);

// 但不能同时有写者
// let w = &mut data;  // 错误！r1, r2还在用

// 写者独占
let w = &mut data;
w.push(4);  // OK，没有其他引用
```

**形式化保证**:

```
借用规则:
- 任意时刻: 多个& XOR 一个&mut
- 保证: 写操作独占，读操作共享
- 结果: 无数据竞争
```

---

## 第四部分：形式化视角

### 定理 T-OW2: 所有权唯一性

**陈述**: 对于任何值v，在任意时刻，最多存在一个变量x拥有v。

**证明思路**:

```
1. 初始状态: 变量声明时获得所有权 ✓
2. 转移操作: Move操作转移所有权，原所有者失效 ✓
3. 借用操作: 不转移所有权，所有者仍唯一 ✓
4. 归纳: 所有操作保持唯一性不变式 ✓
```

### 定理 T-BR1: 数据竞争自由

**陈述**: 借用检查通过的程序无数据竞争。

**证明思路**:

```
借用规则保证:
- 有&mut时: 独占访问，无其他访问
- 只有&时: 只读访问，安全共享
- 不可能同时存在写者和读者
```

---

## 第五部分：实际示例

### 示例1: 函数参数传递

```rust
fn process(s: String) {
    // s获得所有权
    println!("{}", s);
} // s在这里释放

fn main() {
    let s = String::from("hello");
    process(s);  // 所有权转移给process
    // s不再有效
}
```

**安全保证**: `main`中的`s`不能再使用，防止悬垂引用。

### 示例2: 返回值

```rust
fn create() -> String {
    String::from("hello")  // 转移所有权给调用者
}

fn main() {
    let s = create();  // 获得所有权
    println!("{}", s);  // OK
}  // s在这里释放
```

**安全保证**: 所有权链条清晰，内存管理正确。

### 示例3: 借用临时使用

```rust
fn print_length(s: &String) {
    println!("{}", s.len());
} // 借用结束，但不释放

fn main() {
    let s = String::from("hello");
    print_length(&s);  // 借用
    print_length(&s);  // 再次借用，OK
    println!("{}", s);  // 所有权仍在s
}  // s在这里释放
```

**安全保证**: 借用不转移所有权，原变量始终有效。

---

## 第六部分：常见疑问

### Q: 所有权检查有运行时开销吗？

**A**: 没有！所有权检查完全在编译时完成。运行时没有额外开销。

```rust
// 编译后，所有权检查完全消失
// 生成的代码与C一样高效
```

### Q: 所有权系统限制太多？

**A**: 实际上非常灵活：

- `Rc`/`Arc`: 共享所有权
- `RefCell`/`Mutex`: 内部可变性
- 借用: 临时使用不转移

99%的场景都有优雅的解决方案。

### Q: 学习所有权很难？

**A**: 初期确实需要适应，但：

- 编译器错误信息非常友好
- 一旦掌握，极少出现内存错误
- 值得长期投资

---

## 总结

### 所有权为什么安全？

```
┌─────────────────────────────────────────┐
│  所有权三规则                            │
│  1. 每个值只有一个所有者                 │
│  2. 所有者离开，值被丢弃                 │
│  3. 可转移或借用                         │
└──────────────────┬──────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────┐
│  编译时保证                              │
│  • 没有悬垂指针                          │
│  • 没有双重释放                          │
│  • 没有数据竞争                          │
└──────────────────┬──────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────┐
│  结果: 内存安全 + 零运行时开销           │
└─────────────────────────────────────────┘
```

### 下一步学习

- [借用检查器工作原理](./TUTORIAL_BORROW_CHECKER.md)
- [理解生命周期](./TUTORIAL_LIFETIMES.md)
- [反例汇编](./COUNTER_EXAMPLES_COMPENDIUM.md)

---

**练习**: 尝试解释为什么这段代码安全？

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // println!("{}", s1);  // 取消注释会发生什么？为什么？
    println!("{}", s2);
}
```

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-28
**状态**: ✅ 已扩展 - 所有权与内存安全教程完整版
