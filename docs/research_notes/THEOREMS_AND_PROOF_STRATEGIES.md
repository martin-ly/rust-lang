# 定理与证明策略汇编

> **创建日期**: 2026-02-23
> **级别**: L1 (证明思路) + L2 (完整证明草图)
> **目标**: 给人看的形式化论证，注重认知理解

---

## 核心定理索引

| 定理ID | 定理名称 | 难度 | 证明策略 | 状态 |
| :--- | :--- | :---: | :--- | :---: |
| T-OW2 | 所有权唯一性 | ⭐⭐⭐ | 状态机归纳 | ✅ |
| T-BR1 | 数据竞争自由 | ⭐⭐⭐⭐ | 分离逻辑 | 🔄 |
| T-TY3 | 类型安全 | ⭐⭐⭐ | 进展+保持 | ✅ |
| T-LF2 | 引用有效性 | ⭐⭐ | 区域包含 | ✅ |
| SEND-T1 | Send安全 | ⭐⭐ | 构造证明 | ✅ |
| SYNC-T1 | Sync安全 | ⭐⭐ | 等价推导 | ✅ |

---

## 一、所有权唯一性定理 (T-OW2)

### 1.1 定理陈述

**定理 (T-OW2)**: 对于任何值$v$，在任意时刻，最多存在一个变量$x$使得$\Omega(x) = \text{Owned}$且$\Gamma(x) = v$。

**自然语言**: 每个值在任意时刻只有一个所有者。

### 1.2 证明策略

**核心思想**: 证明所有权转移操作保持唯一性不变式。

**证明结构**:

```
1. 定义所有权唯一性不变式
2. 证明初始状态满足不变式
3. 对状态转移进行归纳
   - 证明每种转移保持不变式
4. 得出所有可达状态满足不变式
```

### 1.3 详细证明思路

**步骤 1: 定义不变式**

```
ownership_unique(S) ≡
  ∀v: Value, ∀x₁, x₂: Var,
    Ω(x₁) = Owned ∧ Γ(x₁) = v ∧
    Ω(x₂) = Owned ∧ Γ(x₂) = v
    → x₁ = x₂
```

**步骤 2: 归纳基础**

初始状态：程序开始时，每个值只有一个所有者。

- 由语言语义保证
- 或通过变量声明规则保证

**步骤 3: 归纳步骤**

对可能的操作进行分类分析：

**情况 A: Move操作**

```
pre: owns(x, v)
post: owns(y, v) ∧ ¬valid(x)

分析:
- x失去所有权，变为Moved状态
- y获得所有权
- 其他变量不变
- 因此v仍然只有一个所有者(y)
```

**情况 B: Copy操作**

```
pre: owns(x, v)
post: owns(x, v) ∧ owns(y, v')

注意: Copy创建的是新值v'，不是共享v
因此不涉及唯一性违反
```

**情况 C: Drop操作**

```
pre: owns(x, v)
post: v被释放，x变为Dropped

分析: v不再存在，唯一性自然保持
```

**关键引理**: 每个操作都是原子性的，不会出现中间状态。

### 1.4 推论

**推论 1 (无使用后移动)**: 值被移动后，原变量不能继续使用。

**推论 2 (无双重释放)**: 值不会被释放两次。

---

## 二、数据竞争自由定理 (T-BR1)

### 2.1 定理陈述

**定理 (T-BR1)**: 通过Rust借用检查的程序是数据竞争自由的。

**形式化**:

```
BorrowCheck(P) = OK → DataRaceFree(P)
```

### 2.2 证明策略

**核心思想**: 借用规则确保对同一内存位置的冲突访问不能并发发生。

**证明结构**:

```
1. 定义数据竞争
2. 分析借用规则如何保证互斥
3. 证明借用检查通过 ⇒ 无数据竞争
```

### 2.3 详细证明思路

**步骤 1: 数据竞争定义**

```
数据竞争存在当且仅当:
∃a₁, a₂: MemoryAccess,
  a₁.thread ≠ a₂.thread ∧      // 不同线程
  a₁.location = a₂.location ∧  // 同一位置
  (a₁.is_write ∨ a₂.is_write)  // 至少一个写
```

**步骤 2: 借用规则分析**

**规则**: 在任意时刻，对于内存位置l：

- 要么：有一个可变借用`&mut l`
- 要么：有多个不可变借用`&l`
- 不会同时有可变和不可变借用

**步骤 3: 证明借用规则阻止数据竞争**

**情况 A: 可变借用**

```
如果线程T持有 &mut l:
- 没有其他线程可以持有 &l 或 &mut l
- 因此其他线程不能访问l
- 不存在并发访问，无数据竞争
```

**情况 B: 不可变借用**

```
如果多个线程持有 &l:
- 所有线程都是读操作
- 没有写操作
- 读-读不冲突，无数据竞争
```

**关键观察**: 借用检查器在编译时强制执行上述规则。

### 2.4 直观理解

**类比**: 借用系统像图书馆的管理规则：

- `&mut T`: 一个人借走书，其他人不能借
- `&T`: 多人可以借阅副本（同时阅读）
- 规则防止：一人正在修改时，其他人也在读或改

---

## 三、类型安全定理 (T-TY3)

### 3.1 定理陈述

**定理 (T-TY3)**: 良类型的程序不会陷入类型错误。

**形式化**:

```
Γ ⊢ e : τ → ¬∃e', e →* e' ∧ type_error(e')
```

**分解为两个子定理**:

- T-TY1 (进展性): 良类型表达式可以继续求值或已是值
- T-TY2 (保持性): 求值保持类型

### 3.2 证明策略：进展 + 保持

**经典类型安全证明框架** (Wright & Felleisen, 1994)

```
类型安全 = 进展性 + 保持性
```

### 3.3 进展性 (T-TY1)

**定理**: 如果$e$是良类型的，那么$e$要么是值，要么可以求值为某个$e'$。

**证明思路**:

```
对类型推导进行结构归纳:

情况 1: e是值 (整数、布尔、函数)
  → 直接满足

情况 2: e是变量
  → 假设上下文已定义

情况 3: e = e₁ + e₂
  → 递归应用归纳假设
  → e₁和e₂都可以求值
  → 因此e可以求值

情况 4: e = (λx.e₁) e₂
  → e₂可以求值（归纳假设）
  → 或e₂是值，可以β归约
```

### 3.4 保持性 (T-TY2)

**定理**: 如果$e$是良类型的且$e → e'$，那么$e'$也是良类型的。

**证明思路**:

```
对求值规则进行案例分析:

情况 1: β归约 (λx.e₁) v₂ → [v₂/x]e₁
  → 使用替换引理
  → 替换保持类型

情况 2: 算术求值 n₁ + n₂ → n₃
  → 结果仍是整数

情况 3: 条件求值 if true e₂ e₃ → e₂
  → 分支类型与条件类型一致
```

**关键引理 (替换引理)**:

```
如果 Γ, x:τ₁ ⊢ e : τ₂ 且 Γ ⊢ v : τ₁
那么 Γ ⊢ [v/x]e : τ₂
```

### 3.5 直观理解

**类型系统作为过滤器**:

```
所有程序
    │
    ├── 良类型程序 ──→ 类型安全（不会崩溃）
    │
    └── 非良类型程序 ──→ 编译错误
```

**Rust的扩展**:

- 所有权系统扩展了类型安全
- 不仅保证"不会stuck"，还保证"内存安全"

---

## 四、生命周期有效性定理 (T-LF2)

### 4.1 定理陈述

**定理**: 引用的生命周期不超过被引用数据的生命周期。

**形式化**:

```
Γ ⊢ r: &'a T  →  lifetime(r) ⊆ lifetime(T)
```

### 4.2 证明策略

**核心**: 区域包含关系的传递性。

**证明思路**:

```
1. 每个值有隐式或显式的生命周期
2. 引用创建时，编译器检查被引用值的生命周期
3. 生命周期关系通过类型系统传播
4. 如果引用可能比数据活得长，编译拒绝
```

**关键规则 (Outlives)**:

```
T: 'a  表示 T中所有引用都存活至少'a
```

---

## 五、证明技术总结

### 5.1 常用证明技术

| 技术 | 适用场景 | 示例 |
| :--- | :--- | :--- |
| **结构归纳** | 归纳定义的数据 | 表达式、类型、状态 |
| **规则归纳** | 归纳定义的关系 | 类型判断、求值关系 |
| **反证法** | 否定性质 | 无数据竞争 |
| **案例分析** | 有限情况 | 操作语义规则 |
| **构造法** | 存在性命题 | 存在类型安全求值 |

### 5.2 证明检查清单

- [ ] 定义清晰（概念、谓词、关系）
- [ ] 归纳基础成立
- [ ] 归纳步骤覆盖所有情况
- [ ] 辅助引理已证明
- [ ] 边界情况已考虑
- [ ] 反例已排除

---

## 六、与机器证明的关系

### L1 → L2 → L3 映射

| 层级 | 内容 | 形式 |
| :--- | :--- | :--- |
| **L1** | 证明思路 (本文档) | 自然语言 + 数学符号 |
| **L2** | 完整证明 (草图) | 详细步骤，可能省略基础情况 |
| **L3** | 机器证明 (Coq) | 形式化，可验证，完全详细 |

**关系**:

- L1 给人看，理解核心思想
- L2 给专家看，验证证明结构
- L3 给机器看，确保绝对正确

**本项目重点**: L1和L2，确保概念清晰、论证完整。

---

**维护者**: Rust Formal Methods Research Team
**最后更新**: 2026-02-23
**用途**: 给人看的形式化论证
