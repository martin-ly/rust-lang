# 04. 函数与闭包 (Functions and Closures)

函数和闭包是 Rust 中组织代码和转移控制流的核心单元。它们不仅封装了逻辑，还与所有权系统深度集成，以实现安全的抽象。

## 4.1. 函数 (Functions)

函数是具名的、可复用的代码块。在控制流的视角下，函数调用是一种控制权的转移。

**核心概念**:

1. **控制流转移**:
    * **调用 (Call)**: 当一个函数被调用时，程序的执行控制权从调用点转移到函数的入口。
    * **返回 (Return)**: 函数通过 `return` 关键字或在函数体最后一个表达式隐式返回值，将控制权和计算结果（如果有）交还给调用点。

2. **所有权转移**:
    函数参数的传递和返回值的传递严格遵循所有权规则：
    * **传值 (Move)**: `fn process(s: String)` - `s` 的所有权被移入函数。
    * **不可变借用**: `fn view(s: &String)` - `s` 被不可变地借用。
    * **可变借用**: `fn mutate(s: &mut String)` - `s` 被可变地借用。

3. **递归 (Recursion)**:
    函数可以调用自身，形成递归。这是实现某些算法（如树的遍历）的自然方式。Rust 编译器不进行尾调用优化（TCO），因此深度递归可能导致栈溢出。

4. **发散函数 (Diverging Functions)**:
    * **定义**: 发散函数是永不返回的函数，其返回类型为 `!` (never type)。
    * **作用**: 它向编译器明确表示该路径的控制流将不会返回到调用点。常见的发散函数包括 `panic!`, `std::process::exit`，以及无限循环 `loop {}`。
    * **类型系统**: `!` 类型可以被强制转换 (coerce) 为任何其他类型。这使得它可以在 `match` 分支等要求所有分支返回同一类型的地方使用。

**代码示例**:

```rust
// 发散函数作为 match 分支
fn check_input(input: i32) -> String {
    match input {
        0..=100 => format!("Valid input: {}", input),
        _ => panic!("Input out of range!"), // panic! 返回 `!`
    }
    // 编译器知道 panic! 分支不会返回，因此类型检查通过
}
```

## 4.2. 闭包 (Closures)

闭包是匿名的、可以捕获其所在环境的函数式结构。它们在需要传递函数作为参数的场景（如迭代器适配器）中非常强大。

### 4.2.1. 定义与环境捕获

闭包的语法为 `|arg1, arg2, ...| { body }`。其核心特性是能够捕获 (capture) 定义它时所在作用域中的变量。

捕获方式有三种，由闭包如何使用被捕获的变量决定，并对应三种 `Fn` Trait：

1. **`FnOnce`**:
    * **行为**: **消耗**被捕获的变量（通过移动所有权）。
    * **调用**: 只能被调用一次。
    * **例子**: `|s: String| drop(s)`。

2. **`FnMut`**:
    * **行为**: **可变地借用**被捕获的变量。
    * **调用**: 可以被多次调用，并在调用期间修改环境。
    * **例子**: `|vec: &mut Vec<i32>| vec.push(1)`。

3. **`Fn`**:
    * **行为**: **不可变地借用**被捕获的变量。
    * **调用**: 可以被多次调用，不能修改环境。
    * **例子**: `|x: &i32| println!("{}", x)`。

**Trait 关系**: `Fn` 是 `FnMut` 的子 trait，`FnMut` 是 `FnOnce` 的子 trait。即任何 `Fn` 闭包都可以被当作 `FnMut` 或 `FnOnce` 使用。编译器会为每个闭包自动推断出最合适的 trait。

### 4.2.2. `move` 关键字

在闭包定义前使用 `move` 关键字 (`move || ...`) 会强制闭包获得其捕获的所有变量的**所有权**。这在多线程编程中至关重要，可以确保闭包的生命周期不会超过其引用的变量。

```rust
use std::thread;

let data = vec![1, 2, 3];

// `move` 关键字将 `data` 的所有权转移给新线程
let handle = thread::spawn(move || {
    // 如果没有 `move`，`data` 的借用可能在主线程结束后失效，导致悬垂引用
    println!("Here's the data: {:?}", data);
});

// `data` 在此已不可用
// println!("{:?}", data); // 编译错误

handle.join().unwrap();
```

### 4.2.3. 作为控制流机制

闭包是 Rust 中实现高阶函数 (Higher-Order Functions) 和延迟执行 (Lazy Execution) 的关键。

* **高阶函数**: 接受函数（闭包）作为参数或返回函数的函数。最典型的例子是 `Iterator` trait 的各种适配器，如 `map`, `filter`, `fold`。
* **延迟执行**: 闭包封装了一段代码，但直到它被显式调用时才会执行。

**代码示例**:

```rust
let numbers = vec![1, 2, 3, 4, 5];

// `filter` 和 `map` 接受闭包作为参数来定义控制流
let sum_of_even_squares: i32 = numbers
    .iter() // 产生一个迭代器
    .filter(|&&n| n % 2 == 0) // 闭包定义过滤条件
    .map(|&n| n * n) // 闭包定义转换逻辑
    .sum(); // 消耗迭代器并求和

println!("Sum: {}", sum_of_even_squares); // (2*2 + 4*4) = 20
```

在这个链式调用中，控制流由一系列闭包驱动，每个闭包定义了数据流中的一步操作。

---

**章节导航:**

* **上一章 ->** `03_iterative_constructs.md`
* **下一章 ->** `05_error_handling_as_control_flow.md`: 将 `Option` 和 `Result` 视为一种控制流机制。
* **返回目录 ->** `_index.md`

## 批判性分析（未来展望）

* Rust 函数与闭包未来可在自动化泛型推断、异步集成和工程可视化等方面持续优化。

* 随着异步、分布式和嵌入式场景的普及，函数与闭包与所有权、生命周期等机制的深度集成将成为提升系统健壮性和开发效率的关键。
* 社区和生态对函数与闭包相关标准化、最佳实践和自动化工具的支持仍有较大提升空间。

## 典型案例（未来展望）

* 开发自动化泛型推断和闭包可视化工具，提升大型项目的可维护性。

* 在分布式系统中，结合异步闭包与任务调度、容错机制实现高可用架构。
* 推动函数与闭包相关的跨平台标准和社区协作，促进 Rust 在多领域的广泛应用。
