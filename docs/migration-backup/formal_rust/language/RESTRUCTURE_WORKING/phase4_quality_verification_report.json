{
  "consistency_check": {
    "concept_inconsistencies": [
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "移动语义是指在赋值或传参时，值的所有权从一个变量转移到另一个变量，而原变量不再有效的机制。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "借用是指在不转移所有权的情况下，临时获取对值的引用的机制，既可以是不可变借用，也可以是可变借用。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "生命周期是引用的有效作用域，用于防止引用指向已被释放的内存。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型安全是指程序在运行时不会因类型错误而导致未定义行为的特性。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "特征是Rust中定义共享行为的抽象接口，类似于其他语言中的接口或抽象类。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型推断是编译器根据上下文自动确定表达式类型的能力，无需程序员显式标注。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "模式匹配是一种解构和检查数据结构的机制，允许根据值的结构执行不同的代码路径。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "错误处理是处理程序执行过程中可能出现的异常情况的机制，在Rust中主要通过 `Result` 和 `Option` 类型实现。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "泛型是一种参数多态性机制，允许编写适用于多种类型的代码。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "特征约束是对泛型类型参数的限制，要求类型必须实现特定的特征。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "并发安全是指程序在多线程环境中执行时免于数据竞争和其他并发相关错误的特性。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "消息传递是一种并发通信模式，线程或任务通过发送和接收消息而非共享内存来通信。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "concept_dictionary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "异步编程是一种并发编程模型，允许任务在等待I/O操作完成时暂停执行，而不阻塞线程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "cross_reference_implementation_report.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.1: 所有权](01_formal_ownership_system.md#所有权定义)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "线性类型系统中的每个值必须恰好使用一次。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "仿射类型系统允许值被使用零次或一次，但不能超过一次。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "分离逻辑提供形式化方法来推理程序状态的分离部分。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型环境 $\\Gamma$ 是变量到类型的映射。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "所有权类型表示值的所有权状态。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "所有权从一个变量转移到另一个变量。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\02_borrowing_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$B = (B_{\\text{imm}}, B_{\\text{mut}})$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\02_borrowing_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.4: 借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\02_borrowing_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Borrows}(r, x) = \\text{true} \\iff r \\text{ 借用 } x$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\02_borrowing_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.4: 借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\02_borrowing_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.5: 可变借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\02_borrowing_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{BorrowChecker} = \\text{struct}\\{\\text{env}: \\text{BorrowEnv}, \\text{rules}: \\text{Vec}[\\text{BorrowRule}]\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\06_theorems.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.1: 所有权](01_formal_ownership_system.md#所有权定义)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\06_theorems.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.4: 借用](01_formal_ownership_system.md#借用定义)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\06_theorems.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- [定义 1.6: 生命周期](01_formal_ownership_system.md#生命周期定义)"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_theory_foundations\\00_index.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "使用操作语义和指称语义"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_theory_foundations\\01_linear_affine_types.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "在线性类型系统中，如果 $\\Gamma \\vdash e : \\tau$ 表示在上下文 $\\Gamma$ 中表达式 $e$ 的类型为 $\\tau$，则线性类型系统要求："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_theory_foundations\\01_linear_affine_types.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "仿射类型系统可表示为带有弱化规则（weakening rule）的线性逻辑："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_theory_foundations\\03_separation_logic.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果 $P$ 和 $Q$ 是描述堆状态的断言，则分离合取 $P * Q$ 表示堆可以分为两个不相交的部分，一部分满足 $P$，另一部分满足 $Q$。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "01_theory_foundations\\06_type_theory_foundations.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- **类型 (Type)**：表示一组值的集合或分类，记为 $T, S, U$ 等。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型和函数形成范畴。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "参数多态允许函数和数据结构对多种类型进行操作。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型环境 $\\Gamma$ 是变量到类型的映射。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型约束表示类型间的关系。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型安全确保程序不会在运行时出现类型错误。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "多态性允许代码对多种类型进行操作。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_fundamental_concepts.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "结构体是 **积类型** 的实现。一个类型 `struct T { a: A, b: B }` 的所有可能值的集合，是类型 `A` 的值集和类型 `B` 的值集的 **笛卡尔积 (Cartesian Product)**。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_fundamental_concepts.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "枚举是 **和类型 (或余积类型, Coproduct Type)** 的实现。一个类型 `enum E { V1(A), V2(B) }` 的所有可能值的集合，是类型 `A` 的值集和类型 `B` 的值集的 **不交并 (Disjoint Union)**。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_type_inference.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\tau ::= \\alpha \\mid \\text{Int} \\mid \\text{Bool} \\mid \\text{String} \\mid \\tau_1 \\to \\tau_2 \\mid \\forall \\alpha. \\tau$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_type_inference.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\Gamma = \\{x_1 : \\tau_1, x_2 : \\tau_2, \\ldots, x_n : \\tau_n\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_type_inference.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\sigma = [\\alpha_1 \\mapsto \\tau_1, \\alpha_2 \\mapsto \\tau_2, \\ldots, \\alpha_n \\mapsto \\tau_n]$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_type_inference.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{TypeScheme} = \\forall \\alpha_1. \\forall \\alpha_2. \\ldots \\forall \\alpha_n. \\tau$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_type_inference.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{generalize}(\\Gamma, \\tau) = \\forall \\alpha_1. \\forall \\alpha_2. \\ldots \\forall \\alpha_n. \\tau$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\02_type_inference.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$C = \\{\\tau_1 = \\tau_2, \\tau_3 = \\tau_4, \\ldots\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\03_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\Gamma_T = \\{\\text{Trait}_1[\\alpha_1], \\text{Trait}_2[\\alpha_2], \\ldots, \\text{Trait}_n[\\alpha_n]\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\03_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\03_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\03_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\03_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\03_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{VTable}[\\text{Trait}] = \\text{struct}\\{\\text{method}_1: \\text{fn}(\\text{*const ()}) \\to \\tau_1, \\ldots, \\text{method}_n: \\text{fn}(\\text{*const ()}) \\to \\tau_n\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\06_variance.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果 `T` 是 `U` 的子类型，且 `F<T>` 也是 `F<U>` 的子类型，则 `F` 对参数 `T` 是协变的。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\06_variance.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果 `T` 是 `U` 的子类型，但 `F<U>` 是 `F<T>` 的子类型，则 `F` 对参数 `T` 是逆变的。子类型关系被反转了。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\06_variance.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "即使 `T` 是 `U` 的子类型，`F<T>` 和 `F<U>` 之间也没有子类型关系。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\08_type_conversion.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "上转型是将一个具体类型的实例转换为其父类型的实例。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\08_type_conversion.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "下转型是将一个父类型的实例转换为其子类型的实例。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\08_type_conversion.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果类型 \\( A \\) 是类型 \\( B \\) 的子类型，则 \\( F(A) \\) 是 \\( F(B) \\) 的子类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\08_type_conversion.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果类型 \\( A \\) 是类型 \\( B \\) 的子类型，则 \\( F(B) \\) 是 \\( F(A) \\) 的子类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\08_type_conversion.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型 \\( A \\) 和类型 \\( B \\) 之间没有协变或逆变关系。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\08_type_conversion.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型 \\( A \\) 和类型 \\( B \\) 之间存在协变和逆变关系。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 类型 \\( T \\) 是一组值的集合，定义了这些值的结构和操作。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 不可变借用：允许多个不可变引用同时存在。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 原始类型 \\( P \\) 是基本数据类型的集合。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 组合类型 \\( C \\) 是由多个类型构成的复合类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 解构操作将类型 \\( T \\) 的实例分解为其组成部分。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 控制流 \\( C \\) 是程序执行路径的集合。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 一致性 \\( I \\) 是在类型转换和解构过程中保持数据完整性的属性。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 协变：如果 \\( A \\) 是 \\( B \\) 的子类型，则 \\( F(A) \\) 是 \\( F(B) \\) 的子类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 双变：类型 \\( A \\) 和类型 \\( B \\) 之间存在协变和逆变关系。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 同步流 \\( S \\) 是线性执行的过程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "02_type_system\\10_advanced_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 同构关系 \\( H \\) 是在不同类型之间建立的结构相似性。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\00_progress_report.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "15个核心定义"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_conditional_expressions.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个 `if` 表达式 \\(E_{if}\\) 接受一个条件 \\(c\\) (必须为 `bool` 类型) 和两个代码块，一个用于 `true` 情况 (\\(b_t\\))，一个用于 `false` 情况 (\\(b_f\\))。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_conditional_expressions.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`if let pattern = expression { block_true } else { block_false }`"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_conditional_expressions.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个 `match` 表达式 \\(E_{m}\\) 接受一个值 \\(v\\) 和一个模式-表达式对的列表 \\([(p_i, e_i), ...]\\)。它会返回第一个匹配成功的模式 \\(p_k\\) 对应的表达式 \\(e_k\\) 的求值结果。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_conditional_expressions.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`match` 表达式必须是**穷尽的**，即它的模式必须覆盖所有可能输入的值。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_analysis.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$G = (V, E, entry, exit)$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_analysis.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Path} = \\text{sequence}[V]$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_analysis.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Reachable}(u, v) \\iff \\exists \\text{path}. \\text{path}[0] = u \\land \\text{path}[-1] = v$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_analysis.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{State} = \\text{struct}\\{\\text{memory}: \\text{Memory}, \\text{stack}: \\text{Stack}, \\text{pc}: \\text{ProgramCounter}\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_analysis.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{AnalysisFramework} = \\text{struct}\\{\\text{domain}: \\text{Domain}, \\text{transfer}: \\text{TransferFunction}, \\text{meet}: \\text{MeetFunction}\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`if` 表达式是一个条件判断结构，形式为 `if condition { block_true } else { block_false }`。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`match` 表达式将一个值与多个模式进行比较，并执行第一个匹配成功的分支。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`if let pattern = expression { block_true } else { block_false }`"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`while let pattern = expression { block }`"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`loop` 创建无限循环，形式为 `loop { block }`，必须通过 `break` 显式退出。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`while` 循环在每次迭代前检查条件，形式为 `while condition { block }`。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`for` 循环用于迭代一个实现了 `IntoIterator` trait 的集合。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- `break`：立即终止最内层循环"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "函数是具名的代码块，接收输入参数并可选择性返回值。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "递归是函数直接或间接调用自身的机制。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "发散函数是永不返回的函数，标记为返回类型 `!`。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "闭包是可以捕获环境的匿名函数，语法为 `|params| expression`。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "异步函数创建返回 `Future` 的函数，允许非阻塞执行。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- `async` 关键字创建异步上下文"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "Rust编译器将异步函数转换为状态机，每个 `.await` 点对应一个状态。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\02_control_flow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "? 运算符是处理 `Result` 和 `Option` 的简洁方式，自动传播错误或空值。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\03_control_flow_optimization.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{OptimizationFramework} = \\text{struct}\\{\\text{analysis}: \\text{Analysis}, \\text{transformation}: \\text{Transformation}, \\text{verification}: \\text{Verification}\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\04_functions_and_closures.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "发散函数是永不返回的函数，其返回类型为 `!` (never type)。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow\\05_error_handling_as_control_flow.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "在一个返回 `Result` 或 `Option` 的函数中，对一个同样类型的表达式使用 `?` 运算符："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_control_flow_and_functions\\00_index.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "参数化计算的抽象机制"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\01_basic_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "设 $\\mathcal{U}$ 是所有可能值的全集，类型 $T$ 是 $\\mathcal{U}$ 的一个子集，即 $T \\subseteq \\mathcal{U}$。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\01_basic_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个类型系统是安全的，如果对于任何通过类型检查的程序 $P$，执行 $P$ 不会导致类型错误（如访问不存在的字段、调用不存在的方法等）。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\02_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "特征 $\\text{Tr}$ 可以表示为一个元组 $(\\text{Methods}, \\text{AssocItems})$，其中："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\02_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型 $T$ 对特征 $\\text{Tr}$ 的实现 $\\text{Impl}(T, \\text{Tr})$ 是一个映射，将 $\\text{Tr}$ 中的每个方法签名和关联项映射到具体实现。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\02_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "泛型函数 $f<T: \\text{Tr}_1 + \\text{Tr}_2 + \\ldots + \\text{Tr}_n>$ 表示类型参数 $T$ 必须实现所有列出的特征。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\02_trait_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "特征对象 $\\text{dyn Tr}$ 可以表示为一个存在类型（existential type）："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\03_type_constraints.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型约束 $C$ 是一个谓词 $C(T)$，对于任意类型 $T$，$C(T)$ 为真当且仅当 $T$ 满足约束 $C$。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\04_variance.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "对于类型构造器 $F$，给定类型 $A$ 和 $B$，如果 $A <: B$（$A$ 是 $B$ 的子类型），则 $F$ 的型变性质决定了 $F<A>$ 和 $F<B>$ 之间的关系。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\04_variance.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "子类型关系 $<:$ 是类型之间的一个偏序关系，满足以下性质："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\05_subtyping.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果类型 $S$ 是类型 $T$ 的子类型，记作 $S <: T$，则 $S$ 类型的值可以在期望 $T$ 类型的上下文中使用。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\05_subtyping.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果类型 $S$ 实现了特征 $\\text{Tr}$，则 $S$ 是 $\\text{dyn Tr}$ 的子类型，即 $S <: \\text{dyn Tr}$。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\05_subtyping.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "如果生命周期 `'a` 比 `'b` 长（即 `'a` 包含 `'b`），则 `'a` 是 `'b` 的子类型，记作 `'a <: 'b`。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\06_type_system_formal_proofs.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "语言的形式化语义可以通过以下几种方式定义："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\06_type_system_formal_proofs.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- **进展定理**：如果 $\\emptyset \\vdash e : T$（即在空环境中表达式 $e$ 具有类型 $T$），则 $e$ 要么是一个值，要么可以进行求值步骤。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\06_type_system_formal_proofs.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 特征 $\\text{Tr}$ 定义为一组方法签名 $\\{m_1 : T_1, m_2 : T_2, \\ldots\\}$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "03_type_system_core\\06_type_system_formal_proofs.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 在定理证明助手中定义语言的语法、类型规则和操作语义"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\forall T \\in \\text{Type}, \\text{Generic}(P, T) \\Rightarrow P<T> \\in \\text{Type}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\forall T \\in \\text{TypeParam}, \\forall \\tau \\in \\text{Type}, \\text{Subst}(T, \\tau) \\text{ is valid}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$T : \\text{Trait} \\Rightarrow T \\text{ implements } \\text{Trait}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$T \\models C \\Leftrightarrow T \\text{ implements all requirements of } C$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\sigma : \\text{TypeParam} \\rightarrow \\text{Type}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Container}<T> \\text{ where }:$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{fn } f<T>(x: T) \\rightarrow R \\text{ where}:$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$T : \\text{Trait} \\text{ where}:$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$T : \\text{Trait}_1 + \\text{Trait}_2 + ... + \\text{Trait}_n \\text{ where}:$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{'a} \\in \\text{LifetimeParam}, \\text{'a} \\subseteq \\text{Scope}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{'a} : \\text{'b} \\Rightarrow \\text{'a} \\subseteq \\text{'b}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Monomorphize}(f<T>) = \\{f_{\\tau} | \\tau \\in \\text{Types used with } f\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "参数化多态性允许类型和函数接受类型参数，实现代码的通用性。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型环境包含类型变量和约束信息。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型约束限制类型参数必须满足的条件。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\frac{\\Gamma \\vdash \\alpha : \\text{Trait}}{\\Gamma \\vdash \\alpha : \\text{Constraint}}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "单态化是将泛型代码转换为具体类型代码的过程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "关联类型允许Trait定义与实现者相关的类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "生命周期参数化的泛型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "编译时常量参数化的泛型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_introduction_to_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "* **泛型类型 (Generic Type)**: 在定义结构体或枚举时使用的占位符类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\01_introduction_to_generics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "单态化是编译器在编译期间，将泛型代码替换为使用具体类型的特定代码的过程。编译器会查看所有泛型函数被调用的地方，根据传入的具体类型，为每种类型生成一个非泛型的、定制化的函数实现。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\02_generic_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{GenericType} = \\forall \\alpha_1, \\alpha_2, \\ldots, \\alpha_n. \\tau$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\05_advanced_topics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型构造器是一个\"函数\"，它在**类型级别**上运作。它接受一个或多个类型作为参数，并\"返回\"一个新的、具体的类型。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "04_generics\\05_advanced_topics.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "HKT 是**泛化类型构造器本身**的能力。换句话说，它允许我们编写一个不关心具体容器类型（如 `Vec` 或 `Option`），只关心容器\"形状\"的代码。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "05_concurrency\\01_formal_concurrency_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```math"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\01_formal_async_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "`std::future::Future` Trait。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\02_async_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "调度策略D是一个映射D: 2^T × H → T，其中T是任务集合，H是任务执行历史。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "Rust 用于编写异步代码的语法关键字。`async` 用于定义一个异步函数或代码块，它返回一个 `Future`。`await` 用于暂停一个 `async` 函数的执行，直到其等待的 `Future` 完成。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个 Trait，代表一个可以随时间推移而产生的值。这是 Rust 异步计算的核心抽象。`Future` 通过 `poll` 方法被驱动，直到产生一个最终值。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个库，提供了执行异步代码所需的服务。它包含一个或多个执行器、一个 I/O 事件反应器（如 epoll, kqueue）、定时器以及任务调度逻辑。`tokio` 和 `async-std` 是最流行的运行时。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "运行时的核心组件，负责接收异步任务（`Future`），并通过重复调用 `poll` 方法来驱动它们直至完成。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个智能指针，用于\"固定\"一个对象在内存中的位置，防止其被移动。这对于安全地处理自引用结构至关重要，而自引用结构是 `async`/`await` 状态机的常见实现方式。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个自动 Trait，用于标记那些即使被 `Pin` 包裹也可以安全移动的类型。绝大多数 Rust 类型都是 `Unpin` 的。如果一个类型不是 `Unpin`，它通常是自引用的。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个 Trait，代表一个异步的值序列。它是 `Iterator` 的异步等价物。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个 Trait，代表一个可以异步接收值的地方。它是 `Stream` 的对偶概念，用于异步写入数据。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个描述编程语言中 `async` 和 `sync` 函数之间交互限制的术语。它指出了 `async` 代码倾向于\"病毒式\"传播，以及 `async`/`sync` 边界处需要谨慎处理的架构问题。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个由执行器提供给 `Future` 的句柄。当一个 `Future` 在 `poll` 时返回 `Poll::Pending`，它必须存储这个 `Waker`。当 `Future` 准备好再次被轮询时（例如，一个 I/O 事件已发生），它会调用 `waker.wake()` 来通知执行器。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "06_async_await\\Glossary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一个流行的第三方 crate，它通过宏提供了在 Trait 中使用 `async fn` 的能力。它通过将 `Future` 包装在 `Box<dyn Future>` 中来实现对象安全。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\01_formal_macro_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{MacroSystem} = (\\text{MacroTypes}, \\text{MacroExpansion}, \\text{MacroHygiene}, \\text{MacroTypeSafety})$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\01_formal_macro_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{MacroPattern} = \\text{TokenTree} \\times \\text{Repetition} \\times \\text{Metavariable}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\01_formal_macro_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{MacroTemplate} = \\text{TokenTree} \\times \\text{Substitution} \\times \\text{Repetition}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\01_formal_macro_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{ProceduralMacro} = \\text{enum}\\{"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\01_formal_macro_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\01_formal_macro_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\02_declarative_macros.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{DeclarativeMacro} = \\text{macro\\_rules!} \\quad \\text{MacroName} \\quad \\text{MacroRules}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\02_declarative_macros.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{TokenTree} = \\text{enum}\\{"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "07_macro_system\\02_declarative_macros.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Repetition} = \\text{enum}\\{*, +, ?\\}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "08_algorithms\\progress_report.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "使用严格的数学符号和定义"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "09_error_handling\\01_formal_error_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "错误处理类型是代数数据类型的实例。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "09_error_handling\\01_formal_error_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "错误传播是错误值在函数调用链中的传递过程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "09_error_handling\\01_formal_error_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "错误恢复是从错误状态恢复到正常状态的过程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "09_error_handling\\01_formal_error_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "异常安全确保在错误发生时程序状态保持一致。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "09_error_handling\\02_error_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Result}\\langle T, E \\rangle = \\text{Ok}(T) + \\text{Err}(E)$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "10_modules\\01_formal_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "类型、trait、函数均以模块为作用域。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "12_middlewares\\01_formal_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "管道 $P$ 是一系列中间件的组合："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "12_middlewares\\01_formal_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "管道是一系列中间件的线性组合。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "12_middlewares\\01_formal_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "上下文是请求处理过程中可访问的共享状态。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "12_middlewares\\01_formal_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "异步中间件返回一个Future。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "12_traits\\02_trait_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{Trait} = \\text{Interface} \\times \\text{Constraints} \\times \\text{Methods}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "12_traits\\02_trait_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "$$\\text{AssociatedType} = \\text{TypeName} \\times \\text{TypeBounds} \\times \\text{DefaultType}$$"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "14_workflow\\02_workflow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "描述业务流程的结构和逻辑"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "14_workflow\\02_workflow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "两者都描述了计算的整体结构和逻辑"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "14_workflow\\02_workflow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "- 令F₁和F₂是两个异步函数，W₁和W₂是对应的工作流"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "14_workflow\\02_workflow_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "数据不存储在单一的中央服务器上，而是分布在网络中的多个节点（计算机）上。没有单一的控制中心或失败点。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一旦数据被记录到区块链上，就极难甚至不可能被修改或删除。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "在公有链中，虽然参与者的真实身份可能是匿名的（通过地址表示），但账本上的所有交易记录通常是公开可见、可供任何人查询和验证的。私有链或联盟链可以根据需要设定不同的透明度级别。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "在分布式网络中，节点之间就账本状态（哪些交易是有效的、下一个区块应该由谁来创建）达成一致的规则和过程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "数据不存储在单一的中央服务器上，而是分布在网络中的多个节点（计算机）上。没有单一的控制中心或失败点。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "一旦数据被记录到区块链上，就极难甚至不可能被修改或删除。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "在公有链中，虽然参与者的真实身份可能是匿名的（通过地址表示），但账本上的所有交易记录通常是公开可见、可供任何人查询和验证的。私有链或联盟链可以根据需要设定不同的透明度级别。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "15_blockchain\\01_formal_blockchain_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "在分布式网络中，节点之间就账本状态（哪些交易是有效的、下一个区块应该由谁来创建）达成一致的规则和过程。"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "16_webassembly\\02_webassembly_theory.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "使用组件接口类型(WIT)定义接口"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "19_advanced_features\\01_advanced_type_system.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```rust"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "19_advanced_language_features\\04_compiler_dwarf_stabilization.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```mathematical"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "19_advanced_language_features\\05_stabilized_apis_comprehensive.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```mathematical"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "19_advanced_language_features\\06_compatibility_and_lints.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```mathematical"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "19_advanced_language_features\\07_rustdoc_cargo_improvements.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "```mathematical"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "28_advanced_type_features\\00_index.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "trait中的类型成员"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "28_advanced_type_features\\01_higher_kinded_types.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "种类系统通常使用以下符号表示："
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "RESTRUCTURE_WORKING\\phase4_major_improvements_summary.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "编号的定义体系"
        ]
      },
      {
        "concept": "**",
        "conflicting_files": [
          "concept_dictionary.md",
          "ARCHIVE\\versions\\content_restructuring_plan_v1.md"
        ],
        "definitions": [
          "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。",
          "使用标准数学符号"
        ]
      },
      {
        "concept": "行为",
        "conflicting_files": [
          "concept_dictionary.md",
          "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md"
        ],
        "definitions": [
          "避免因类型不匹配导致的运行时错误",
          "96%减少"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "cross_reference_implementation_report.md"
        ],
        "definitions": [
          "所有权是指...",
          "所有权是指对一个值的唯一控制权，包括读取、修改和销毁该值的能力。"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "所有权是指...",
          "所有权是指对一个值的唯一控制权，包括读取、修改和销毁该值的能力。"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "02_type_system\\00_index.md"
        ],
        "definitions": [
          "所有权是指...",
          "[类型](01_formal_type_system.md#类型定义) - 值的集合及其操作"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "所有权是指...",
          "类型是一组值及其上的操作集合。"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "03_control_flow\\00_index.md"
        ],
        "definitions": [
          "所有权是指...",
          "[控制流](01_formal_control_flow.md#控制流定义) - 程序执行路径的形式化表示"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "所有权是指...",
          "操作语义描述程序如何逐步执行。"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "所有权是指...",
          "控制流图是程序执行路径的抽象表示。"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "所有权是指...",
          "控制流是程序执行路径的形式化表示，描述了程序如何在不同的语句和表达式之间转移执行控制。"
        ]
      },
      {
        "concept": ".1**",
        "conflicting_files": [
          "cross_reference_guide.md",
          "06_theory_practice\\01_theory_application_framework.md"
        ],
        "definitions": [
          "所有权是指...",
          "理论应用映射 Application: Theory → Practice"
        ]
      },
      {
        "concept": "- **定义 1.1**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "01_theory_foundations\\00_index.md"
        ],
        "definitions": [
          "[所有权](01_formal_ownership_system.md#所有权定义) - 对值的唯一控制权",
          "[线性类型](01_linear_affine_types.md#线性类型定义) - 恰好使用一次的类型"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "借用是指在不转移所有权的情况下，临时获取对值的访问权限。借用分为不可变借用（只读访问）和可变借用（读写访问）。"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "01_theory_foundations\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[分离合取](03_separation_logic.md#分离合取定义) - 内存分离的逻辑表示"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "02_type_system\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[代数数据类型](01_formal_type_system.md#代数数据类型定义) - 复合数据类型的形式化定义"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "代数数据类型是通过类型代数运算（如积、和、幂等）构造的复合数据类型。"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "03_control_flow\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[条件控制](01_formal_control_flow.md#条件控制) - 基于条件表达式的执行路径选择"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "循环控制是重复执行代码块的控制流结构。"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "03_control_flow_and_functions\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[函数签名](02_function_formal_semantics.md#函数签名定义) - 函数类型的声明规范"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "03_type_system_core\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[特质](02_trait_system.md#特质定义) - 类型行为的抽象接口"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "04_generics\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[关联类型](04_associated_types.md#关联类型定义) - 特质内部的类型成员"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "05_concurrency\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[原子性](05_atomic_operations.md#原子性定义) - 不可分割的操作性质"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "05_formal_verification\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[并发安全](05_concurrent_logic.md#并发安全定义) - 并发错误的避免"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "05_formal_verification\\01_verification_foundations.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "数据竞争 DataRace(T, t1, t2) 当且仅当："
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "06_theory_practice\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[抽象层次](10_zero_cost_abstractions.md#抽象层次定义) - 合适抽象级别的选择标准"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "07_macro_system\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[宏展开](01_formal_macro_system.md#宏展开定义) - 宏到代码的转换过程"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "08_algorithms\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[并行算法](07_parallel_algorithms.md#并行算法定义) - 多处理器环境的算法"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "09_error_handling\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[错误恢复](06_error_recovery.md#错误恢复定义) - 从错误状态的恢复机制"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "11_frameworks\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[扩展机制](08_extension_mechanisms.md#扩展机制定义) - 框架功能的扩展方式"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "12_middlewares\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[异步中间件](03_async_middleware.md#异步中间件定义) - 支持异步操作的中间件"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "12_traits\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[特质约束](02_trait_theory.md#特质约束定义) - 泛型参数的行为限制"
        ]
      },
      {
        "concept": ".4**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "28_advanced_type_features\\00_index.md"
        ],
        "definitions": [
          "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限",
          "[Trait对象](05_trait_objects_and_dynamic_dispatch.md#trait对象定义) - 动态分发机制"
        ]
      },
      {
        "concept": ".6**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md"
        ],
        "definitions": [
          "[生命周期](01_formal_ownership_system.md#生命周期定义) - 引用有效期范围",
          "生命周期 $\\alpha$ 表示引用的有效期，即引用在程序中可以安全使用的时间范围。"
        ]
      },
      {
        "concept": ".6**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "02_type_system\\00_index.md"
        ],
        "definitions": [
          "[生命周期](01_formal_ownership_system.md#生命周期定义) - 引用有效期范围",
          "[特质约束](03_trait_system.md#特质约束定义) - 类型行为的约束条件"
        ]
      },
      {
        "concept": ".6**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "03_control_flow\\00_index.md"
        ],
        "definitions": [
          "[生命周期](01_formal_ownership_system.md#生命周期定义) - 引用有效期范围",
          "[函数控制](01_formal_control_flow.md#函数控制) - 函数调用和返回的控制流机制"
        ]
      },
      {
        "concept": ".6**",
        "conflicting_files": [
          "01_ownership_borrowing\\00_index.md",
          "05_formal_verification\\01_verification_foundations.md"
        ],
        "definitions": [
          "[生命周期](01_formal_ownership_system.md#生命周期定义) - 引用有效期范围",
          "抽象函数 α: ConcreteState → AbstractState"
        ]
      },
      {
        "concept": ".5",
        "conflicting_files": [
          "01_ownership_borrowing\\02_borrowing_system.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "可变借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)",
          "类型替换"
        ]
      },
      {
        "concept": ".6",
        "conflicting_files": [
          "01_ownership_borrowing\\02_borrowing_system.md",
          "01_ownership_borrowing\\06_theorems.md"
        ],
        "definitions": [
          "生命周期](03_lifetime_system.md#生命周期定义) (本模块)",
          "生命周期](01_formal_ownership_system.md#生命周期定义)"
        ]
      },
      {
        "concept": ".4",
        "conflicting_files": [
          "01_ownership_borrowing\\06_theorems.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "借用](01_formal_ownership_system.md#借用定义)",
          "约束满足 {#约束满足}"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "02_type_system\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[子类型](08_type_conversion.md#子类型定义) - 类型间的包含关系"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "02_type_system\\01_formal_type_system.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "如果类型 $\\tau$ 的值可以用于任何需要类型 $\\sigma$ 的上下文，则 $\\tau$ 是 $\\sigma$ 的子类型。"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[模式匹配](02_pattern_matching_system.md#模式匹配定义) - 结构化数据解构与条件控制的统一机制"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "指称语义将程序映射到数学对象。"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "状态转换系统描述程序执行的状态变化。"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "条件控制是基于布尔条件选择执行路径的控制流结构。"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow_and_functions\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[循环不变式](01_conditional_and_looping_constructs.md#循环不变式定义) - 循环执行中保持的性质"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_type_system_core\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[类型环境](01_basic_type_system.md#类型环境定义) - 变量到类型的映射"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "04_generics\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[类型参数](02_type_parameters.md#类型参数定义) - 类型级别的参数化机制"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "05_concurrency\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[数据竞争](01_formal_concurrency_system.md#数据竞争定义) - 并发访问的竞争条件"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "05_formal_verification\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[类型安全](01_type_system_safety.md#类型安全定义) - 类型错误的免疫性"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "05_formal_verification\\01_verification_foundations.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "正确性谓词 Correct(P, S) 当且仅当："
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "06_theory_practice\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[安全性实现](07_concurrency_safety.md#安全性实现定义) - 理论安全保证的实际实现"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "07_macro_system\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[模式匹配](02_macro_theory.md#模式匹配定义) - 语法模式的匹配机制"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "08_algorithms\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[算法正确性](01_formal_algorithm_system.md#正确性定义) - 算法满足规约的性质"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "09_error_handling\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[Result Monad](02_error_theory.md#Result单子定义) - Result类型的单子性质"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "10_modules\\02_module_resolution_theory.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "模块路径解析函数："
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "11_frameworks\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[组件接口](02_component_theory.md#组件接口定义) - 组件间的交互接口"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "12_middlewares\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[中间件组合](02_composition_theory.md#组合定义) - 多个中间件的链式组合"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "12_middlewares\\02_middleware_composition_theory.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "中间件组合 `∘` 满足结合律："
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "12_traits\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[特质实现](01_formal_theory.md#特质实现定义) - 类型对特质的具体实现"
        ]
      },
      {
        "concept": ".2**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "28_advanced_type_features\\00_index.md"
        ],
        "definitions": [
          "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型",
          "[关联类型](02_associated_types.md#关联类型定义) - Trait中的类型成员"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "02_type_system\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[类型推断](02_type_inference.md#类型推断定义) - 自动推导类型的过程"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[错误传播](06_exception_handling.md#错误传播定义) - 错误在控制流中的传递机制"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "公理语义通过前置条件和后置条件描述程序行为。"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "类型环境记录变量和表达式的类型信息。"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "模式匹配是基于数据结构模式选择执行路径的控制流结构。"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_control_flow_and_functions\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[模式匹配](01_conditional_and_looping_constructs.md#模式匹配定义) - 数据结构的解构与绑定"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "03_type_system_core\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[类型判断](01_basic_type_system.md#类型判断定义) - 表达式的类型推导"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "04_generics\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[特质约束](03_trait_bounds.md#特质约束定义) - 对类型参数的行为约束"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "05_concurrency\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[死锁](02_concurrency_theory.md#死锁定义) - 资源竞争的死锁状态"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "05_formal_verification\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[内存安全](02_ownership_correctness.md#内存安全定义) - 内存错误的防护"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "05_formal_verification\\01_verification_foundations.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "线性类型 Linear(T) 满足："
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "06_theory_practice\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[性能模型](09_performance_impact.md#性能模型定义) - 理论性能保证的实际表现"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "07_macro_system\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[卫生宏](03_hygiene_theory.md#卫生宏定义) - 标识符作用域的自动管理"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "08_algorithms\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[数据结构不变式](02_algorithm_theory.md#不变式定义) - 数据结构的恒定性质"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "09_error_handling\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[错误传播](05_error_propagation.md#错误传播定义) - 错误在调用链中的传播"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "11_frameworks\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[组合规则](03_composition_rules.md#组合规则定义) - 组件组合的形式化规则"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "12_middlewares\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[处理上下文](01_formal_theory.md#上下文定义) - 中间件间共享的状态信息"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "12_traits\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[关联类型](05_associated_types.md#关联类型定义) - 特质内部的类型投影"
        ]
      },
      {
        "concept": ".3**",
        "conflicting_files": [
          "01_theory_foundations\\00_index.md",
          "28_advanced_type_features\\00_index.md"
        ],
        "definitions": [
          "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象",
          "[Phantom Types](04_phantom_and_zero_sized_types.md#幽灵类型定义) - 编译时标记类型"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "03_control_flow\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[循环控制](01_formal_control_flow.md#循环控制) - 重复执行代码块的机制"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "03_control_flow\\01_formal_control_flow.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "函数控制是通过函数调用和返回实现控制流转移的机制。"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "03_control_flow_and_functions\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[闭包捕获](02_function_formal_semantics.md#闭包捕获定义) - 环境变量的获取方式"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "03_type_system_core\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[特质边界](03_type_constraints.md#特质边界定义) - 泛型约束机制"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "04_generics\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[单态化](05_generic_impls.md#单态化定义) - 泛型的编译时实例化"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "05_concurrency\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[内存序](06_memory_ordering.md#内存序定义) - 内存操作的顺序约束"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "05_formal_verification\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[验证条件](03_program_logic.md#验证条件定义) - 证明义务的生成"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "05_formal_verification\\01_verification_foundations.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "模型检查 ModelCheck(M, φ) 验证模型M是否满足性质φ"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "06_theory_practice\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[实践反馈](12_practical_applications.md#实践反馈定义) - 实践对理论的改进推动"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "07_macro_system\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[过程宏](05_procedural_macros.md#过程宏定义) - TokenStream的程序化处理"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "08_algorithms\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[近似算法](08_optimization_algorithms.md#近似算法定义) - 近似最优解的算法"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "09_error_handling\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[错误边界](01_formal_error_system.md#错误边界定义) - 错误影响范围的边界"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "11_frameworks\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[配置模型](01_formal_theory.md#配置模型定义) - 框架配置的抽象模型"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "12_middlewares\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[错误传播](06_error_handling.md#错误传播定义) - 中间件链中的错误处理机制"
        ]
      },
      {
        "concept": ".5**",
        "conflicting_files": [
          "02_type_system\\00_index.md",
          "12_traits\\00_index.md"
        ],
        "definitions": [
          "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质",
          "[特质对象](06_trait_objects.md#特质对象定义) - 动态分发的运行时抽象"
        ]
      },
      {
        "concept": "行为**",
        "conflicting_files": [
          "02_type_system\\05_type_casting_and_coercion.md",
          "02_type_system\\FAQ.md"
        ],
        "definitions": [
          "某些指针转换可能导致未定义行为。",
          "将无效整数转为指针，或某些指针间的转换可能导致未定义行为。"
        ]
      },
      {
        "concept": "类型设计准则",
        "conflicting_files": [
          "02_type_system\\09_package_system.md",
          "02_type_system\\09_package_system.md"
        ],
        "definitions": [
          "包管理与概念组织",
          "包管理与概念组织](#rust-自定义类型设计准则包管理与概念组织)"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\01_formal_control_flow_system.md"
        ],
        "definitions": [
          "$$",
          "$$E_{match}(value, [(p_1, e_1), (p_2, e_2), ..., (p_n, e_n)]) = eval(e_i)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\01_formal_control_flow_system.md"
        ],
        "definitions": [
          "$$",
          "$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\01_formal_control_flow_system.md"
        ],
        "definitions": [
          "$$",
          "$$L_{loop}(body) = \\text{repeat}(body)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\02_pattern_matching_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Pattern} = \\text{Literal} \\mid \\text{Variable} \\mid \\text{Wildcard} \\mid \\text{Constructor} \\mid \\text{Ref} \\mid \\text{Slice}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\03_conditional_flow.md"
        ],
        "definitions": [
          "$$",
          "$$\\sigma \\sim \\rho \\iff \\text{Match}(\\sigma, \\rho) = \\text{true}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\03_conditional_flow.md"
        ],
        "definitions": [
          "$$",
          "$$M = (S, S_0, T, L)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\04_loop_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Iterator}[\\tau] = \\text{struct}\\{\\text{next}: \\text{fn}() \\to \\text{Option}[\\tau]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\04_loop_control.md"
        ],
        "definitions": [
          "$$",
          "1. **Map**: $\\text{map}(I, f) = \\{f(x) \\mid x \\in I\\}$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\04_loop_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{unroll}(L, n) = \\text{repeat}(L, n)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\04_loop_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{fuse}(L_1, L_2) = \\text{loop}(\\text{body}(L_1) \\circ \\text{body}(L_2))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\04_loop_control.md"
        ],
        "definitions": [
          "$$",
          "$$S = \\{(pc, \\sigma) \\mid pc \\in \\text{ProgramCounter}, \\sigma \\in \\text{State}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{fn}(\\tau_1, ..., \\tau_n) \\to \\tau = \\text{struct}\\{\\text{params}: [\\tau_1, ..., \\tau_n], \\text{return}: \\tau\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{signature}(f) = (\\text{params}(f), \\text{return}(f), \\text{effects}(f))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{rec}(f, x, e) = \\text{fix}(\\lambda f. \\lambda x. e)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{closure}(x, e, \\rho) = \\text{struct}\\{\\text{code}: \\lambda x. e, \\text{env}: \\rho\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{capture}(e, \\rho) = \\{x \\mapsto v \\mid x \\in \\text{free}(e) \\land (x, v) \\in \\rho\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$f \\circ g = \\lambda x. f(g(x))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\05_function_control.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{effects}(f) = \\{\\text{read}(x), \\text{write}(x), \\text{call}(g) \\mid x \\in \\text{vars}, g \\in \\text{functions}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Result}[\\tau, \\epsilon] = \\text{enum}\\{\\text{Ok}(\\tau), \\text{Err}(\\epsilon)\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Error} = \\text{trait}\\{\\text{source}: \\text{fn}() \\to \\text{Option}[\\text{Error}], \\text{description}: \\text{fn}() \\to \\text{String}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{From}[\\epsilon_1, \\epsilon_2] = \\text{trait}\\{\\text{from}: \\text{fn}(\\epsilon_1) \\to \\epsilon_2\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{propagate}(e) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow v, \\text{Err}(e) \\Rightarrow \\text{return Err}(e))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$e? = \\text{match}(e, \\text{Ok}(v) \\Rightarrow v, \\text{Err}(e) \\Rightarrow \\text{return Err}(e))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{early\\_return}(e_1, e_2, ..., e_n) = e_1?; e_2?; ...; e_n?; \\text{Ok}(\\text{result})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{map\\_err}(e, f) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow \\text{Ok}(v), \\text{Err}(e) \\Rightarrow \\text{Err}(f(e)))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{and\\_then}(e, f) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow f(v), \\text{Err}(e) \\Rightarrow \\text{Err}(e))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{panic}(msg) = \\text{unwind}(\\text{panic\\_info}(msg))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{!} = \\text{never}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{unwind}(info) = \\text{stack\\_unwind}(\\text{panic\\_info}, \\text{cleanup})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{catch\\_unwind}(f) = \\text{try\\_catch}(f, \\text{panic\\_handler})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{recover}(e, \\text{strategy}) = \\text{match}(\\text{strategy}, \\text{retry} \\Rightarrow \\text{retry}(e), \\text{fallback} \\Rightarrow \\text{fallback}(e), \\text{ignore} \\Rightarrow \\text{ignore}(e))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{optimize\\_error}(\\epsilon) = \\text{flatten}(\\text{normalize}(\\epsilon))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{zero\\_cost\\_error}(e) = \\text{compile\\_time\\_check}(e) \\land \\text{runtime\\_zero\\_overhead}(e)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{error\\_pattern} = \\text{Err}(\\text{pattern})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\06_exception_handling.md"
        ],
        "definitions": [
          "$$",
          "1. **map**: $\\text{map}(e, f) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow \\text{Ok}(f(v)), \\text{Err}(e) \\Rightarrow \\text{Err}(e))$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{trait}(name, \\text{items}) = \\text{interface}\\{\\text{methods}: \\text{items}, \\text{name}: \\text{string}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{method}(name, \\text{params}, \\text{return}) = \\text{fn}(\\text{params}) \\to \\text{return}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{trait\\_object}(trait) = \\text{struct}\\{\\text{vtable}: \\text{VTable}[trait], \\text{data}: \\text{*mut}()\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{VTable}[trait] = \\text{struct}\\{\\text{methods}: [\\text{fn}(\\text{*mut}(), ...) \\to \\text{return}], \\text{drop}: \\text{fn}(\\text{*mut}())\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{solve}(\\text{constraints}) = \\text{find}(\\text{impls} \\mid \\text{constraints} \\subseteq \\text{impls})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{associated\\_type}(name, \\text{bounds}) = \\text{type} \\text{ name}: \\text{bounds}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{impl\\_associated\\_type}(name, \\text{type}) = \\text{type} \\text{ name} = \\text{type}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{associated\\_type\\_bound}(trait, name, \\text{bounds}) = \\text{trait}::\\text{name}: \\text{bounds}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{default\\_impl}(method, \\text{body}) = \\text{method} \\text{ with default body}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{override}(default\\_impl, \\text{custom\\_impl}) = \\text{custom\\_impl}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\02_trait_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{monomorphize}(\\text{generic\\_code}, \\text{type\\_args}) = \\text{specialized\\_code}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AssociatedType}(name, \\text{bounds}) = \\text{type} \\text{ name}: \\text{bounds}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AssociatedTypeEnv} = \\text{Map}[\\text{String}, \\text{AssociatedType}]$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{solve\\_associated\\_type}(\\text{constraints}) = \\text{find}(\\text{impls} \\mid \\text{constraints} \\subseteq \\text{impls})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ProjectionType}(\\text{trait}, \\text{name}) = \\text{trait}::\\text{name}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{infer\\_associated\\_type}(\\text{context}, \\text{constraints}) = \\text{unify}(\\text{constraints})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{unify}(\\text{constraints}) = \\text{most\\_general\\_unifier}(\\text{constraints})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{monomorphize\\_associated\\_type}(\\text{generic\\_code}, \\text{type\\_args}) = \\text{specialized\\_code}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Constraint}(\\tau, \\text{trait}) = \\tau : \\text{trait}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ConstraintSet}(\\text{constraints}) = \\{\\text{constraints}_1, ..., \\text{constraints}_n\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Solver}(\\text{constraints}) = \\text{find}(\\text{impls} \\mid \\text{constraints} \\subseteq \\text{impls})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{unify\\_constraints}(\\text{constraints}) = \\text{most\\_general\\_unifier}(\\text{constraints})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{propagate}(\\text{constraints}) = \\text{transitive\\_closure}(\\text{constraints})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$G = (V, E) \\text{ where } V = \\text{types}, E = \\text{constraints}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{eliminate}(\\text{constraints}) = \\text{remove\\_redundant}(\\text{constraints})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{sort\\_constraints}(\\text{constraints}) = \\text{topological\\_sort}(\\text{constraint\\_graph})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AssociatedTypeConstraint}(\\text{trait}, \\text{name}, \\text{bounds}) = \\text{trait}::\\text{name}: \\text{bounds}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{LifetimeConstraint}(\\tau, \\text{lifetime}) = \\tau : \\text{lifetime}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\04_constraint_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{CompoundConstraint}(\\text{constraints}) = \\text{constraints}_1 \\land \\text{constraints}_2 \\land ... \\land \\text{constraints}_n$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{GenericFn}(\\text{params}, \\text{body}) = \\forall \\text{params}. \\text{fn}(\\text{param\\_types}) \\to \\text{return\\_type}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{instantiate}(\\text{generic\\_fn}, \\text{type\\_args}) = \\text{specialize}(\\text{generic\\_fn}, \\text{type\\_args})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{GenericStruct}(\\text{params}, \\text{fields}) = \\forall \\text{params}. \\text{struct}\\{\\text{fields}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{GenericEnum}(\\text{params}, \\text{variants}) = \\forall \\text{params}. \\text{enum}\\{\\text{variants}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{GenericTrait}(\\text{params}, \\text{items}) = \\forall \\text{params}. \\text{trait}\\{\\text{items}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{GenericConstraint}(\\text{type\\_param}, \\text{bounds}) = \\text{type\\_param}: \\text{bounds}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "04_generics\\05_generic_programming.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{monomorphize}(\\text{generic\\_code}, \\text{type\\_args}) = \\text{specialized\\_code}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Thread}(id, \\text{state}) = \\text{struct}\\{\\text{id}: \\text{ThreadId}, \\text{state}: \\text{ThreadState}, \\text{stack}: \\text{Stack}, \\text{registers}: \\text{Registers}, \\text{context}: \\text{ThreadContext}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ThreadId} = \\text{unique\\_identifier}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{CreateThread}(f) = \\text{new\\_thread}(\\text{execute}(f))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Scheduler}(\\text{policy}) = \\text{struct}\\{\\text{policy}: \\text{SchedulingPolicy}, \\text{ready\\_queue}: \\text{Queue}[\\text{Thread}], \\text{running}: \\text{Option}[\\text{Thread}]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{SchedulingPolicy} = \\text{enum}\\{\\text{RoundRobin}, \\text{Priority}, \\text{Fair}, \\text{WorkStealing}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{SyncPrimitive} = \\text{enum}\\{\\text{Mutex}, \\text{RwLock}, \\text{Semaphore}, \\text{Barrier}, \\text{CondVar}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Mutex}(\\text{data}) = \\text{struct}\\{\\text{locked}: \\text{bool}, \\text{owner}: \\text{Option}[\\text{ThreadId}], \\text{waiting}: \\text{Queue}[\\text{ThreadId}]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{CondVar} = \\text{struct}\\{\\text{waiting}: \\text{Queue}[\\text{ThreadId}], \\text{mutex}: \\text{Mutex}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Channel}(\\text{capacity}) = \\text{struct}\\{\\text{buffer}: \\text{Queue}[\\text{Value}], \\text{capacity}: \\text{usize}, \\text{senders}: \\text{int}, \\text{receivers}: \\text{int}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ChannelType} = \\text{enum}\\{\\text{Sender}[\\tau], \\text{Receiver}[\\tau], \\text{SyncSender}[\\tau], \\text{SyncReceiver}[\\tau]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ThreadPool}(\\text{workers}) = \\text{struct}\\{\\text{workers}: \\text{Vec}[\\text{Worker}], \\text{sender}: \\text{Sender}[\\text{Job}], \\text{receiver}: \\text{Receiver}[\\text{Job}]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Worker} = \\text{struct}\\{\\text{id}: \\text{usize}, \\text{thread}: \\text{Option}[\\text{JoinHandle}[\\text{()}]], \\text{receiver}: \\text{Receiver}[\\text{Job}]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{WorkStealing} = \\text{steal\\_from\\_other\\_queues}(\\text{local\\_queue})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{SafeConcurrentAccess}(t_1, t_2, \\tau) = \\neg \\text{DataRace}(t_1, t_2, \\tau)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Send}(\\tau) = \\text{can\\_transfer\\_ownership\\_between\\_threads}(\\tau)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Sync}(\\tau) = \\text{can\\_share\\_reference\\_between\\_threads}(\\tau)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ThreadCreationOptimization} = \\text{Minimize}(\\text{creation\\_overhead}) \\land \\text{Maximize}(\\text{reuse})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{ContextSwitchOptimization} = \\text{Minimize}(\\text{switch\\_overhead}) \\land \\text{Optimize}(\\text{scheduling})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\02_thread_model.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{MemoryLocalityOptimization} = \\text{Maximize}(\\text{cache\\_hit\\_rate}) \\land \\text{Minimize}(\\text{false\\_sharing})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncModel} = (\\text{Futures}, \\text{AsyncRuntime}, \\text{EventLoop})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncExecution} = \\text{cooperative\\_multitasking}(\\text{Futures})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncStateMachine} = (S, \\Sigma, \\delta, s_0, F)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Future}(\\tau) = \\text{trait}\\{\\text{poll}: \\text{fn}(\\&mut \\text{self}, \\&mut \\text{Context}) \\to \\text{Poll}[\\tau]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Poll}(\\tau) = \\text{enum}\\{\\text{Pending}, \\text{Ready}(\\tau)\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncFn}(\\tau_1, \\tau_2) = \\text{fn}(\\tau_1) \\to \\text{Future}[\\tau_2]$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncRuntime} = \\text{struct}\\{\\text{executor}: \\text{Executor}, \\text{reactor}: \\text{Reactor}, \\text{task\\_queue}: \\text{TaskQueue}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Executor} = \\text{struct}\\{\\text{thread\\_pool}: \\text{ThreadPool}, \\text{task\\_scheduler}: \\text{TaskScheduler}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{EventLoop} = \\text{loop}\\{\\text{poll\\_events}(); \\text{process\\_events}(); \\text{schedule\\_tasks}();\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncIO} = \\text{struct}\\{\\text{file\\_descriptor}: \\text{FileDescriptor}, \\text{operation}: \\text{IOOperation}, \\text{callback}: \\text{IOCallback}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{IOOperation} = \\text{enum}\\{\\text{Read}, \\text{Write}, \\text{Connect}, \\text{Accept}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncStream}(\\tau) = \\text{trait}\\{\\text{next}: \\text{fn}(\\&mut \\text{self}) \\to \\text{Future}[\\text{Option}[\\tau]]\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{StreamOperation} = \\text{enum}\\{\\text{Map}, \\text{Filter}, \\text{Fold}, \\text{Collect}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncTask} = \\text{struct}\\{\\text{future}: \\text{Future}, \\text{state}: \\text{TaskState}, \\text{priority}: \\text{Priority}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{TaskState} = \\text{enum}\\{\\text{Ready}, \\text{Running}, \\text{Blocked}, \\text{Completed}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncPerformanceOptimization} = \\text{Maximize}(\\text{throughput}) \\land \\text{Minimize}(\\text{latency}) \\land \\text{Optimize}(\\text{resource\\_usage})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncMemoryOptimization} = \\text{Minimize}(\\text{allocation\\_overhead}) \\land \\text{Optimize}(\\text{memory\\_layout})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_async_system.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{AsyncSchedulingOptimization} = \\text{Minimize}(\\text{context\\_switches}) \\land \\text{Maximize}(\\text{cpu\\_utilization})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "05_concurrency\\03_synchronization_primitives.md"
        ],
        "definitions": [
          "$$",
          "1. **两个或以上**的线程并发地访问同一内存位置。"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "08_algorithms\\01_formal_sorting_algorithms.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{TimeComplexity}(A) = O(f(n))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "08_algorithms\\01_formal_sorting_algorithms.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{SpaceComplexity}(A) = O(g(n))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "08_algorithms\\02_formal_data_structures.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Complexity}(op) = O(f(n))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "08_algorithms\\02_formal_data_structures.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Node}(T) = (\\text{Data}: T, \\text{Next}: \\text{Option<Box<Node<T>>>})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "08_algorithms\\02_formal_data_structures.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{TreeNode}(T) = (\\text{Value}: T, \\text{Left}: \\text{Option<Box<TreeNode<T>>>}, \\text{Right}: \\text{Option<Box<TreeNode<T>>>}})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "13_microservices\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{M} = (\\mathcal{S}, \\mathcal{C}, \\mathcal{D}, \\mathcal{O})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "13_microservices\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Registry}(S) = \\forall s : S. \\exists r : \\text{Record}. \\text{register}(s) = r$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "13_microservices\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{LoadBalancer}(S, L) = \\forall r : \\text{Request}. \\exists s : S. \\text{route}(r) = s$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "13_microservices\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{CircuitBreaker}(S) = \\text{State} \\in \\{\\text{Closed}, \\text{Open}, \\text{HalfOpen}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "14_workflow\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{W} = (S, T, I, O, \\Delta)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "14_workflow\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$(W_1 \\circ W_2)(i) = W_2(W_1(i))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "14_workflow\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$W_{async}(I) \\rightarrow \\text{Future}<O>$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "14_workflow\\02_workflow_theory.md"
        ],
        "definitions": [
          "$$",
          "```rust"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "15_blockchain\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{B} = (B, H, T, S, C)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "15_blockchain\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Contract}(S, I, O) = \\forall i : I. \\exists s' : S. \\text{execute}(s, i) = (s', o)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "15_blockchain\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Block} = (\\text{Header}, \\text{Transactions})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "15_blockchain\\04_blockchain_applications.md"
        ],
        "definitions": [
          "$$",
          "`∀i ∈ [1, n], Bᵢ.h_prev = H(B_{i-1})`"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "16_webassembly\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{W} = (M, F, T, I, E)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "16_webassembly\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Memory} = \\{(\\text{addr}, \\text{value}) | \\text{addr} \\in \\mathbb{N}, \\text{value} \\in \\text{Bytes}\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "16_webassembly\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\vdash \\text{module} : \\text{valid}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "17_iot\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{I} = (D, S, N, P, C)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "17_iot\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{RTOS}(T, R) = \\forall t \\in T. \\exists r \\in R. \\text{respond}(t) \\leq r$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "18_model\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{M} = (E, R, C, T, S)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "18_model\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Verify}(\\mathcal{M}, \\phi) = \\forall \\mathcal{I} \\in \\text{Semantics}(\\mathcal{M}). \\mathcal{I} \\models \\phi$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "19_advanced_language_features\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{T}_{adv} = (T, C, L, P)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "19_advanced_language_features\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Macro}(I) \\rightarrow O$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "19_advanced_language_features\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{U} = (S, I, C)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "19_advanced_language_features\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$T<\\text{const } N: \\tau>$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "20_theoretical_perspectives\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{T}_{Rust} = (T, \\Gamma, \\vdash, R)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "20_theoretical_perspectives\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{C}_{Rust} = (Obj, Mor, \\circ, id)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "20_theoretical_perspectives\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{V}_{Rust} = (P, S, \\models, \\vdash)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "21_application_domains\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{D} = (E, R, C, M)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "21_application_domains\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Pattern}(D, P, S) = \\forall p \\in P. \\exists s \\in S. \\text{solve}(p, D) = s$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "21_application_domains\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$DSL_D = (L, \\Sigma_D, \\mathcal{R}_D, \\mathcal{S}_D)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "21_application_domains\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$f_D(P) = \\sum_{i=1}^{n} w_i \\cdot c_i(P)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "22_performance_optimization\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{P} = (M, T, R, C)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "22_performance_optimization\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Strategy}(P, O) = \\forall p \\in P. \\exists o \\in O. \\text{optimize}(p) = o$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "22_performance_optimization\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$f(P, I) = \\sum_{i=1}^{n} w_i \\cdot m_i(P, I)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "22_performance_optimization\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$M(P) = (T(P), S(P), E(P), L(P), C(P))$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "23_security_verification\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{S} = (P, A, T, C)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "23_security_verification\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Verify}(\\text{System}, \\text{Property}) = \\text{System} \\models \\text{Property}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "24_cross_language_comparison\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{L} = (T, M, C, P, S)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "24_cross_language_comparison\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Compare}(L_1, L_2, D) = \\{(f_1, f_2, \\sim) | f_1 \\in L_1, f_2 \\in L_2, \\sim \\in D\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "24_cross_language_comparison\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$FM_{i,j} = M_{f_j}(L_i)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "25_teaching_learning\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{L} = (C, P, S, M)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "25_teaching_learning\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Teach}(C, A, M) = \\{\\text{Session}(c_i, a_j, m_k) | c_i \\in C, a_j \\in A, m_k \\in M\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "26_toolchain_ecosystem\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{T} = (C, P, I, W)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "26_toolchain_ecosystem\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\text{Dynamics}(\\mathcal{T}) = \\{(c_i, c_j, r_{ij}) | c_i, c_j \\in \\mathcal{T}.C, r_{ij} \\in R\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "26_toolchain_ecosystem\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$Boundary(Ecosystem) = Core \\cup \\{e | Compatible(e, Core)\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "27_ecosystem_architecture\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\mathcal{G} = (V, E, W)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "27_ecosystem_architecture\\00_index.md"
        ],
        "definitions": [
          "$$",
          "$$\\frac{d\\mathbf{S}}{dt} = \\mathbf{F}(\\mathbf{S}, \\mathbf{P}, t)$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "27_ecosystem_architecture\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$R(G) = 1 - \\frac{\\sum_{v \\in V} I(v) \\cdot V(v)}{\\sum_{v \\in V} V(v)}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "27_ecosystem_architecture\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$C(a, b) = \\frac{|I_{compatible}(a, b)|}{|I_{total}(a, b)|}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "27_ecosystem_architecture\\01_formal_theory.md"
        ],
        "definitions": [
          "$$",
          "$$P(S_0, S_n) = \\{S_0, S_1, \\ldots, S_n\\}$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "27_ecosystem_architecture\\03_evolution_model.md"
        ],
        "definitions": [
          "$$",
          "$$C(P) = \\sum_{i=0}^{n-1} c(S_i, S_{i+1})$$"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "28_advanced_type_features\\07_generic_associated_types.md"
        ],
        "definitions": [
          "$$",
          "```text"
        ]
      },
      {
        "concept": "为",
        "conflicting_files": [
          "03_control_flow\\01_formal_control_flow_system.md",
          "28_advanced_type_features\\07_generic_associated_types.md"
        ],
        "definitions": [
          "$$",
          "```rust"
        ]
      },
      {
        "concept": "- **定义 3.1**",
        "conflicting_files": [
          "03_control_flow_and_functions\\00_index.md",
          "03_type_system_core\\00_index.md"
        ],
        "definitions": [
          "[条件表达式](01_conditional_and_looping_constructs.md#条件表达式定义) - 基于布尔值的分支选择",
          "[类型](01_basic_type_system.md#类型定义) - 值的分类和操作集合"
        ]
      },
      {
        "concept": ".1",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "泛型 {#泛型定义}",
          "泛型容器"
        ]
      },
      {
        "concept": ".1",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "泛型 {#泛型定义}",
          "单一特质约束"
        ]
      },
      {
        "concept": ".1",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "泛型 {#泛型定义}",
          "生命周期参数"
        ]
      },
      {
        "concept": ".1",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "泛型 {#泛型定义}",
          "单态化"
        ]
      },
      {
        "concept": ".2",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "类型参数 {#类型参数定义}",
          "泛型函数"
        ]
      },
      {
        "concept": ".2",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "类型参数 {#类型参数定义}",
          "多重特质约束"
        ]
      },
      {
        "concept": ".2",
        "conflicting_files": [
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generics.md"
        ],
        "definitions": [
          "类型参数 {#类型参数定义}",
          "生命周期约束"
        ]
      },
      {
        "concept": "规则**",
        "conflicting_files": [
          "04_generics\\01_formal_generic_system.md",
          "04_generics\\01_formal_generic_system.md"
        ],
        "definitions": [
          "$$\\frac{\\Gamma, \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\vdash e : \\tau}{\\Gamma \\vdash \\text{fn} \\langle \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\rangle (x_1: \\tau_1, x_2: \\tau_2, \\ldots, x_n: \\tau_n) \\rightarrow \\tau : \\text{FunctionType}}$$",
          "$$\\frac{\\Gamma, \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\vdash \\text{fields} : \\text{FieldTypes}}{\\Gamma \\vdash \\text{struct} \\langle \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\rangle \\{ \\text{fields} \\} : \\text{StructType}}$$"
        ]
      },
      {
        "concept": "规则**",
        "conflicting_files": [
          "04_generics\\01_formal_generic_system.md",
          "07_macro_system\\02_declarative_macros.md"
        ],
        "definitions": [
          "$$\\frac{\\Gamma, \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\vdash e : \\tau}{\\Gamma \\vdash \\text{fn} \\langle \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\rangle (x_1: \\tau_1, x_2: \\tau_2, \\ldots, x_n: \\tau_n) \\rightarrow \\tau : \\text{FunctionType}}$$",
          "$$\\frac{\\Gamma \\vdash \\text{macro\\_rules!} \\quad \\Gamma \\vdash \\text{name}: \\text{Identifier} \\quad \\Gamma \\vdash \\text{rules}: \\text{MacroRules}}{\\Gamma \\vdash \\text{DeclarativeMacro}(\\text{name}, \\text{rules}) : \\text{Macro}}$$"
        ]
      },
      {
        "concept": "规则**",
        "conflicting_files": [
          "04_generics\\01_formal_generic_system.md",
          "28_advanced_type_features\\02_associated_types.md"
        ],
        "definitions": [
          "$$\\frac{\\Gamma, \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\vdash e : \\tau}{\\Gamma \\vdash \\text{fn} \\langle \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\rangle (x_1: \\tau_1, x_2: \\tau_2, \\ldots, x_n: \\tau_n) \\rightarrow \\tau : \\text{FunctionType}}$$",
          "特征中的关联类型声明定义了一个类型占位符"
        ]
      },
      {
        "concept": "理论**",
        "conflicting_files": [
          "04_generics\\02_trait_system.md",
          "04_generics\\03_associated_types.md"
        ],
        "definitions": [
          "建立了Trait定义和方法的形式化模型",
          "建立了关联类型定义和环境的形式化模型"
        ]
      },
      {
        "concept": ".1.1 (进程)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "进程是程序执行的实例，包含代码、数据、堆栈和系统资源的集合，",
          "进程是程序执行的实例，包含代码、数据、堆栈和系统资源，由操作系统分配和管理，具有独立的地址空间和执行上下文。"
        ]
      },
      {
        "concept": ".2.1 (进程状态)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "一个进程可以处于以下几种状态之一：创建(Created)、运行(Running)、等待(Waiting)、终止(Terminated)。",
          "Created、Running、Waiting、Terminated。"
        ]
      },
      {
        "concept": ".3.1 (命令构建器)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "`Command`是一个构建器模式实现，用于配置将要创建的新进程的各种参数。",
          "`Command`类型配置新进程参数。"
        ]
      },
      {
        "concept": ".4.1 (进程属性)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "进程属性是影响进程行为和资源使用的可配置特性，包括环境变量、工作目录、I/O重定向等。",
          "环境变量、工作目录、I/O重定向等。"
        ]
      },
      {
        "concept": ".1.1 (管道)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "管道是一种单向通信通道，由读取端和写入端组成，数据以字节流形式从写入端流向读取端。",
          "单向通信通道，数据以字节流形式从写入端流向读取端。"
        ]
      },
      {
        "concept": ".2.1 (Unix域套接字)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "Unix域套接字是一种特殊类型的套接字，用于同一系统上进程间的通信，通过文件系统路径标识。",
          "同一系统进程间通信，文件系统路径标识。"
        ]
      },
      {
        "concept": ".3.1 (共享内存段)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "共享内存段是一块可由多个进程映射到各自地址空间的内存区域，提供直接内存访问而无需数据复制。",
          "多进程映射同一物理内存区域。"
        ]
      },
      {
        "concept": ".4.1 (信号)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "信号是发送给进程的异步通知，用于指示发生了特定事件或请求特定操作。",
          "进程间异步通知。"
        ]
      },
      {
        "concept": ".5.1 (消息队列)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "消息队列是一种允许进程发送和接收消息的IPC机制，支持消息优先级和类型。",
          "结构化消息传递机制。"
        ]
      },
      {
        "concept": ".1.1 (互斥锁)**",
        "conflicting_files": [
          "05_concurrency\\01_formal_concurrency_system.md",
          "07_process_management\\01_process_theory.md"
        ],
        "definitions": [
          "互斥锁是一种同步原语，确保在任一时刻最多只有一个线程可以访问受保护的资源。",
          "确保同一时刻最多一个线程访问资源。"
        ]
      },
      {
        "concept": "**定义 1.1**",
        "conflicting_files": [
          "05_formal_verification\\01_verification_foundations.md",
          "10_modules\\02_module_resolution_theory.md"
        ],
        "definitions": [
          "形式化验证是一个三元组 V = (S, P, M)，其中：",
          "模块空间 ModuleSpace 是一个有向无环图 (DAG)："
        ]
      },
      {
        "concept": "**定义 1.1**",
        "conflicting_files": [
          "05_formal_verification\\01_verification_foundations.md",
          "12_middlewares\\02_middleware_composition_theory.md"
        ],
        "definitions": [
          "形式化验证是一个三元组 V = (S, P, M)，其中：",
          "中间件函数是一个高阶函数："
        ]
      },
      {
        "concept": "- **定义 12.1**",
        "conflicting_files": [
          "12_middlewares\\00_index.md",
          "12_traits\\00_index.md"
        ],
        "definitions": [
          "[中间件函数](01_formal_theory.md#中间件函数定义) - 高阶处理函数的抽象",
          "[特质声明](01_formal_theory.md#特质声明定义) - 类型行为的抽象接口"
        ]
      },
      {
        "concept": "let definition = serde_json",
        "conflicting_files": [
          "14_workflow\\03_workflow_implementation.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          ":json!({",
          ":to_value(workflow)"
        ]
      },
      {
        "concept": "pub event_handlers",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "Vec<EventHandlerDefinition>,",
          "Vec<EventHandler>,"
        ]
      },
      {
        "concept": "let definition",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "WorkflowDefinition = if file_path.extension().and_then(|e| e.to_str()) == Some(\"yaml\") ||",
          "WorkflowDefinition = match source_format.as_str() {"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "失败",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "{}\", error[\"message\"]).into());",
          "{}\", e)))?;"
        ]
      },
      {
        "concept": "field_definitions",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "Vec<HumanTaskFieldDefinition>,",
          "Option<Vec<HumanTaskFieldDefinition>>,"
        ]
      },
      {
        "concept": "pub definition",
        "conflicting_files": [
          "14_workflow\\05_workflow_models.md",
          "14_workflow\\05_workflow_models.md"
        ],
        "definitions": [
          "Option<WorkflowDefinition>,",
          "WorkflowDefinition,"
        ]
      },
      {
        "concept": "│   │   ├── 结构",
        "conflicting_files": [
          "15_blockchain\\03_blockchain_implementation.md",
          "15_blockchain\\03_blockchain_implementation.md"
        ],
        "definitions": [
          "(sender, recipient, value, nonce, data, sig)",
          "(Header, Body={tx...})"
        ]
      },
      {
        "concept": "#[wit_bindgen",
        "conflicting_files": [
          "16_webassembly\\02_webassembly_theory.md",
          "16_webassembly\\02_webassembly_theory.md"
        ],
        "definitions": [
          ":interface]",
          ":contract]"
        ]
      },
      {
        "concept": "行为风险",
        "conflicting_files": [
          "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
          "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md"
        ],
        "definitions": [
          "**传统问题**:",
          "编译器优化依赖"
        ]
      },
      {
        "concept": "$S <",
        "conflicting_files": [
          "28_advanced_type_features\\06_variance_and_subtyping.md",
          "28_advanced_type_features\\06_variance_and_subtyping.md"
        ],
        "definitions": [
          "T \\Rightarrow F<S> <: F<T>$",
          "T \\land S \\neq T \\Rightarrow F<S> \\not<: F<T> \\land F<T> \\not<: F<S>$"
        ]
      }
    ],
    "symbol_inconsistencies": [
      {
        "symbol": "forall",
        "variants": [
          "\\forall",
          "∀"
        ],
        "files": [
          "concept_dictionary.md",
          "fixed_temporary.md",
          "01_ownership_borrowing\\01_ownership_theory.md",
          "01_ownership_borrowing\\02_borrowing_system.md",
          "01_ownership_borrowing\\03_lifetime_system.md",
          "01_ownership_borrowing\\04_mutability_theory.md",
          "01_ownership_borrowing\\05_variable_analysis.md",
          "01_ownership_borrowing\\06_ownership_formal_proofs.md",
          "01_ownership_borrowing\\09_formal_theory_and_proof.md",
          "01_theory_foundations\\03_separation_logic.md",
          "01_theory_foundations\\06_type_theory_foundations.md",
          "02_type_system\\00_index.md",
          "02_type_system\\01_formal_type_system.md",
          "02_type_system\\01_type_system_foundations.md",
          "02_type_system\\02_lifetime_system.md",
          "02_type_system\\02_type_inference.md",
          "02_type_system\\03_trait_system.md",
          "02_type_system\\03_type_inference.md",
          "03_control_flow\\01_control_flow_theory.md",
          "03_control_flow\\01_formal_control_flow.md",
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\02_control_flow_theory.md",
          "03_control_flow\\02_pattern_matching_system.md",
          "03_control_flow\\03_conditional_flow.md",
          "03_control_flow\\03_control_flow_optimization.md",
          "03_type_system_core\\00_index.md",
          "03_type_system_core\\01_basic_type_system.md",
          "03_type_system_core\\03_type_constraints.md",
          "03_type_system_core\\04_variance.md",
          "04_generics\\00_index.md",
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generic_system.md",
          "04_generics\\01_formal_theory.md",
          "04_generics\\02_generic_theory.md",
          "04_generics\\05_generic_programming.md",
          "05_concurrency\\01_formal_concurrency_system.md",
          "05_concurrency\\02_thread_model.md",
          "05_concurrency\\04_concurrency_applications.md",
          "05_concurrency\\05_concurrency_models.md",
          "05_formal_verification\\01_verification_foundations.md",
          "05_formal_verification\\02_type_safety_proofs.md",
          "06_async_await\\01_async_programming_theory.md",
          "06_async_await\\02_async_theory.md",
          "07_macro_system\\01_formal_macro_system.md",
          "07_macro_system\\02_declarative_macros.md",
          "07_macro_system\\03_procedural_macros.md",
          "07_process_management\\00_index.md",
          "07_process_management\\02_task_management.md",
          "07_process_management\\03_io_system.md",
          "08_algorithms\\01_formal_algorithms_system.md",
          "08_algorithms\\01_formal_sorting_algorithms.md",
          "08_algorithms\\01_formal_theory.md",
          "08_algorithms\\02_formal_data_structures.md",
          "09_design_patterns\\01_formal_theory.md",
          "09_design_patterns\\02_behavioral_patterns.md",
          "09_error_handling\\02_error_theory.md",
          "10_modules\\03_visibility_and_privacy.md",
          "11_frameworks\\01_formal_theory.md",
          "11_memory_management\\01_formal_memory_management_system.md",
          "11_memory_management\\01_formal_theory.md",
          "12_middlewares\\01_formal_theory.md",
          "12_traits\\02_trait_theory.md",
          "13_microservices\\00_index.md",
          "13_microservices\\01_formal_theory.md",
          "14_workflow\\01_formal_theory.md",
          "14_workflow\\02_workflow_theory.md",
          "15_blockchain\\00_index.md",
          "15_blockchain\\01_formal_theory.md",
          "15_blockchain\\02_blockchain_theory.md",
          "15_blockchain\\03_blockchain_implementation.md",
          "15_blockchain\\04_blockchain_applications.md",
          "16_webassembly\\01_formal_theory.md",
          "17_iot\\00_index.md",
          "17_iot\\01_formal_theory.md",
          "17_iot\\01_iot_theory.md",
          "18_model\\00_index.md",
          "18_model\\01_formal_theory.md",
          "19_advanced_features\\00_index.md",
          "19_advanced_features\\01_advanced_type_system.md",
          "19_advanced_language_features\\01_formal_theory.md",
          "20_theoretical_perspectives\\01_formal_theory.md",
          "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
          "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
          "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
          "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
          "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
          "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
          "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
          "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
          "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
          "21_application_domains\\00_index.md",
          "21_application_domains\\01_formal_theory.md",
          "22_performance_optimization\\00_index.md",
          "22_performance_optimization\\01_formal_theory.md",
          "23_security_verification\\01_formal_theory.md",
          "24_cross_language_comparison\\01_formal_theory.md",
          "25_teaching_learning\\01_formal_theory.md",
          "27_ecosystem_architecture\\03_evolution_model.md",
          "28_advanced_type_features\\00_index.md",
          "28_advanced_type_features\\04_phantom_and_zero_sized_types.md",
          "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md",
          "28_advanced_type_features\\06_variance_and_subtyping.md",
          "28_advanced_type_features\\07_generic_associated_types.md",
          "28_advanced_type_features\\08_advanced_type_patterns.md",
          "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md"
        ]
      },
      {
        "symbol": "exists",
        "variants": [
          "\\exists",
          "∃"
        ],
        "files": [
          "concept_dictionary.md",
          "cross_reference_implementation_report.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md",
          "01_ownership_borrowing\\01_ownership_theory.md",
          "01_ownership_borrowing\\05_variable_analysis.md",
          "01_ownership_borrowing\\06_ownership_formal_proofs.md",
          "01_theory_foundations\\03_separation_logic.md",
          "01_theory_foundations\\06_type_theory_foundations.md",
          "02_type_system\\00_index.md",
          "02_type_system\\01_type_system_foundations.md",
          "03_control_flow\\01_control_flow_theory.md",
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\02_control_flow_analysis.md",
          "03_control_flow\\02_pattern_matching_system.md",
          "03_control_flow\\03_conditional_flow.md",
          "03_type_system_core\\00_index.md",
          "03_type_system_core\\01_basic_type_system.md",
          "03_type_system_core\\02_trait_system.md",
          "03_type_system_core\\04_variance.md",
          "05_concurrency\\01_formal_concurrency_system.md",
          "05_formal_verification\\01_verification_foundations.md",
          "06_async_await\\02_async_theory.md",
          "07_macro_system\\03_procedural_macros.md",
          "09_design_patterns\\01_formal_theory.md",
          "09_design_patterns\\02_behavioral_patterns.md",
          "10_modules\\03_visibility_and_privacy.md",
          "11_frameworks\\01_formal_theory.md",
          "11_memory_management\\01_formal_theory.md",
          "13_microservices\\00_index.md",
          "13_microservices\\01_formal_theory.md",
          "14_workflow\\01_formal_theory.md",
          "15_blockchain\\00_index.md",
          "15_blockchain\\01_formal_theory.md",
          "15_blockchain\\04_blockchain_applications.md",
          "17_iot\\00_index.md",
          "17_iot\\01_formal_theory.md",
          "18_model\\01_formal_theory.md",
          "19_advanced_language_features\\01_formal_theory.md",
          "19_advanced_language_features\\06_compatibility_and_lints.md",
          "20_theoretical_perspectives\\01_formal_theory.md",
          "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
          "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
          "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
          "21_application_domains\\00_index.md",
          "21_application_domains\\01_formal_theory.md",
          "22_performance_optimization\\00_index.md",
          "24_cross_language_comparison\\01_formal_theory.md",
          "27_ecosystem_architecture\\03_evolution_model.md",
          "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md"
        ]
      },
      {
        "symbol": "in",
        "variants": [
          "\\in",
          "∈"
        ],
        "files": [
          "concept_dictionary.md",
          "content_consistency_checklist.md",
          "fixed_temporary.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md",
          "01_ownership_borrowing\\01_ownership_rules.md",
          "01_ownership_borrowing\\02_borrowing_system.md",
          "01_ownership_borrowing\\03_lifetime_system.md",
          "01_theory_foundations\\01_linear_affine_types.md",
          "01_theory_foundations\\04_algebraic_data_types.md",
          "01_theory_foundations\\06_type_theory_foundations.md",
          "02_type_system\\01_formal_type_system.md",
          "02_type_system\\01_type_system_foundations.md",
          "02_type_system\\02_type_inference.md",
          "02_type_system\\03_trait_system.md",
          "02_type_system\\03_type_inference.md",
          "03_control_flow\\01_control_flow_theory.md",
          "03_control_flow\\01_formal_control_flow.md",
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\02_control_flow_analysis.md",
          "03_control_flow\\02_pattern_matching_system.md",
          "03_control_flow\\03_conditional_flow.md",
          "03_control_flow\\04_loop_control.md",
          "03_control_flow\\05_function_control.md",
          "03_type_system_core\\01_basic_type_system.md",
          "03_type_system_core\\02_trait_system.md",
          "03_type_system_core\\03_type_constraints.md",
          "03_type_system_core\\06_type_system_formal_proofs.md",
          "04_generics\\00_index.md",
          "04_generics\\01_formal_generics.md",
          "04_generics\\02_trait_system.md",
          "04_generics\\03_associated_types.md",
          "04_generics\\04_constraint_system.md",
          "04_generics\\05_generic_programming.md",
          "05_concurrency\\01_formal_concurrency_system.md",
          "05_concurrency\\02_thread_model.md",
          "05_concurrency\\03_async_system.md",
          "05_concurrency\\04_concurrency_applications.md",
          "05_concurrency\\05_concurrency_models.md",
          "05_formal_verification\\01_verification_foundations.md",
          "05_formal_verification\\02_type_safety_proofs.md",
          "06_async_await\\01_async_programming_theory.md",
          "06_async_await\\01_formal_theory.md",
          "06_async_await\\02_async_theory.md",
          "07_macro_system\\01_formal_macro_system.md",
          "07_macro_system\\02_declarative_macros.md",
          "07_macro_system\\03_procedural_macros.md",
          "07_process_management\\00_index.md",
          "07_process_management\\02_task_management.md",
          "07_process_management\\03_io_system.md",
          "08_algorithms\\01_formal_algorithms_system.md",
          "08_algorithms\\01_formal_sorting_algorithms.md",
          "08_algorithms\\01_formal_theory.md",
          "08_algorithms\\02_formal_data_structures.md",
          "08_algorithms\\03_algorithm_implementation.md",
          "08_algorithms\\04_algorithm_applications.md",
          "08_algorithms\\05_algorithm_models.md",
          "09_design_patterns\\01_formal_theory.md",
          "09_design_patterns\\02_behavioral_patterns.md",
          "10_modules\\01_formal_theory.md",
          "10_modules\\03_visibility_and_privacy.md",
          "11_frameworks\\01_formal_theory.md",
          "11_memory_management\\01_formal_memory_management_system.md",
          "12_traits\\02_trait_theory.md",
          "13_microservices\\00_index.md",
          "13_microservices\\01_formal_theory.md",
          "14_workflow\\01_formal_theory.md",
          "14_workflow\\02_workflow_theory.md",
          "15_blockchain\\01_formal_theory.md",
          "15_blockchain\\02_blockchain_theory.md",
          "15_blockchain\\03_blockchain_implementation.md",
          "15_blockchain\\04_blockchain_applications.md",
          "16_webassembly\\00_index.md",
          "16_webassembly\\01_formal_theory.md",
          "16_webassembly\\02_webassembly_theory.md",
          "17_iot\\00_index.md",
          "17_iot\\01_formal_theory.md",
          "17_iot\\01_iot_theory.md",
          "18_model\\00_index.md",
          "18_model\\01_formal_theory.md",
          "19_advanced_language_features\\01_formal_theory.md",
          "19_advanced_language_features\\05_stabilized_apis_comprehensive.md",
          "19_advanced_language_features\\06_compatibility_and_lints.md",
          "20_theoretical_perspectives\\01_formal_theory.md",
          "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
          "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
          "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
          "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
          "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
          "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
          "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
          "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
          "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
          "21_application_domains\\00_index.md",
          "21_application_domains\\01_formal_theory.md",
          "22_performance_optimization\\00_index.md",
          "22_performance_optimization\\01_formal_theory.md",
          "23_security_verification\\01_formal_theory.md",
          "24_cross_language_comparison\\00_index.md",
          "24_cross_language_comparison\\01_formal_theory.md",
          "25_teaching_learning\\00_index.md",
          "25_teaching_learning\\01_formal_theory.md",
          "26_toolchain_ecosystem\\00_index.md",
          "26_toolchain_ecosystem\\01_formal_theory.md",
          "27_ecosystem_architecture\\01_formal_theory.md",
          "27_ecosystem_architecture\\03_evolution_model.md",
          "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md",
          "28_advanced_type_features\\07_generic_associated_types.md",
          "28_advanced_type_features\\08_advanced_type_patterns.md"
        ]
      },
      {
        "symbol": "subset",
        "variants": [
          "\\subset",
          "⊆",
          "\\subseteq",
          "⊂"
        ],
        "files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\00_index.md",
          "01_ownership_borrowing\\01_formal_ownership_system.md",
          "01_ownership_borrowing\\01_ownership_theory.md",
          "01_ownership_borrowing\\04_lifetime_system.md",
          "01_ownership_borrowing\\06_theorems.md",
          "01_ownership_borrowing\\07_case_and_comparison.md",
          "01_ownership_borrowing\\09_formal_theory_and_proof.md",
          "01_theory_foundations\\00_index.md",
          "01_theory_foundations\\02_region_effect_systems.md",
          "02_type_system\\01_type_system_foundations.md",
          "02_type_system\\02_lifetime_system.md",
          "02_type_system\\03_trait_system.md",
          "02_type_system\\03_type_inference.md",
          "03_control_flow\\01_control_flow_theory.md",
          "03_control_flow\\01_formal_control_flow.md",
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\02_control_flow_analysis.md",
          "03_control_flow\\03_conditional_flow.md",
          "03_control_flow\\06_exception_handling.md",
          "03_type_system_core\\01_basic_type_system.md",
          "04_generics\\01_formal_generics.md",
          "04_generics\\01_formal_generic_system.md",
          "04_generics\\02_generic_theory.md",
          "04_generics\\02_trait_system.md",
          "04_generics\\03_associated_types.md",
          "04_generics\\04_constraint_system.md",
          "05_concurrency\\01_formal_concurrency_system.md",
          "05_concurrency\\05_concurrency_models.md",
          "07_macro_system\\03_procedural_macros.md",
          "08_algorithms\\01_formal_algorithms_system.md",
          "08_algorithms\\03_algorithm_implementation.md",
          "08_algorithms\\05_algorithm_models.md",
          "09_design_patterns\\01_formal_theory.md",
          "10_modules\\00_index.md",
          "10_modules\\02_module_resolution_theory.md",
          "10_modules\\03_visibility_and_privacy.md",
          "11_memory_management\\01_formal_theory.md",
          "14_workflow\\01_workflow_theory.md",
          "16_webassembly\\01_formal_theory.md",
          "19_advanced_language_features\\04_compiler_dwarf_stabilization.md",
          "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
          "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
          "23_security_verification\\01_formal_theory.md",
          "26_toolchain_ecosystem\\01_formal_theory.md",
          "27_ecosystem_architecture\\01_formal_theory.md",
          "27_ecosystem_architecture\\03_evolution_model.md",
          "28_advanced_type_features\\07_generic_associated_types.md",
          "ARCHIVE\\versions\\content_analysis_report_v1.md",
          "ARCHIVE\\versions\\content_restructuring_plan_v1.md"
        ]
      },
      {
        "symbol": "union",
        "variants": [
          "\\cup",
          "∪",
          "\\uplus"
        ],
        "files": [
          "concept_dictionary.md",
          "01_theory_foundations\\02_region_effect_systems.md",
          "01_theory_foundations\\03_separation_logic.md",
          "01_theory_foundations\\04_algebraic_data_types.md",
          "02_type_system\\01_type_system_foundations.md",
          "02_type_system\\03_trait_system.md",
          "02_type_system\\03_type_inference.md",
          "03_control_flow\\02_pattern_matching_system.md",
          "03_type_system_core\\01_basic_type_system.md",
          "05_concurrency\\02_thread_model.md",
          "06_async_await\\01_formal_theory.md",
          "07_process_management\\01_formal_theory.md",
          "07_process_management\\03_io_system.md",
          "08_algorithms\\05_algorithm_models.md",
          "09_design_patterns\\01_formal_theory.md",
          "11_memory_management\\01_formal_memory_management_system.md",
          "14_workflow\\01_workflow_theory.md",
          "14_workflow\\02_workflow_theory.md",
          "15_blockchain\\02_blockchain_theory.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
          "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
          "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
          "22_performance_optimization\\01_formal_theory.md",
          "26_toolchain_ecosystem\\01_formal_theory.md"
        ]
      },
      {
        "symbol": "intersection",
        "variants": [
          "∩",
          "\\cap"
        ],
        "files": [
          "concept_dictionary.md",
          "01_ownership_borrowing\\01_ownership_theory.md",
          "02_type_system\\02_lifetime_system.md",
          "05_concurrency\\05_concurrency_models.md",
          "07_macro_system\\01_formal_macro_system.md",
          "07_macro_system\\02_declarative_macros.md",
          "07_macro_system\\03_procedural_macros.md",
          "09_design_patterns\\01_formal_theory.md",
          "11_frameworks\\01_formal_theory.md",
          "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
          "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
          "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md"
        ]
      },
      {
        "symbol": "implies",
        "variants": [
          "\\implies",
          "=>",
          "⇒"
        ],
        "files": [
          "01_ownership_borrowing\\01_ownership_theory.md",
          "01_ownership_borrowing\\02_borrowing_system.md",
          "01_ownership_borrowing\\02_examples_and_applications.md",
          "01_ownership_borrowing\\02_ownership_theory.md",
          "01_ownership_borrowing\\03_borrowing_system.md",
          "01_ownership_borrowing\\03_lifetime_system.md",
          "01_ownership_borrowing\\04_memory_management.md",
          "01_ownership_borrowing\\04_mutability_theory.md",
          "01_ownership_borrowing\\05_variable_analysis.md",
          "01_ownership_borrowing\\06_move_semantics.md",
          "01_ownership_borrowing\\07_case_and_comparison.md",
          "01_ownership_borrowing\\07_examples.md",
          "01_ownership_borrowing\\09_formal_theory_and_proof.md",
          "01_theory_foundations\\03_separation_logic.md",
          "01_theory_foundations\\04_algebraic_data_types.md",
          "02_type_system\\01_type_system_foundations.md",
          "02_type_system\\02_lifetime_system.md",
          "02_type_system\\02_type_inference.md",
          "02_type_system\\03_category_theory.md",
          "02_type_system\\03_trait_system.md",
          "02_type_system\\05_examples.md",
          "03_control_flow\\01_control_flow_theory.md",
          "03_control_flow\\01_formal_control_flow.md",
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_control_flow\\02_conditional_expressions.md",
          "03_control_flow\\02_control_flow_analysis.md",
          "03_control_flow\\02_control_flow_theory.md",
          "03_control_flow\\02_pattern_matching_system.md",
          "03_control_flow\\03_conditional_flow.md",
          "03_control_flow\\03_control_flow_optimization.md",
          "03_control_flow\\03_iterative_constructs.md",
          "03_control_flow\\04_examples.md",
          "03_control_flow\\04_functions_and_closures.md",
          "03_control_flow\\05_error_handling_as_control_flow.md",
          "03_control_flow\\05_function_control.md",
          "03_control_flow\\06_exception_handling.md",
          "03_control_flow\\FAQ.md",
          "03_type_system_core\\01_basic_type_system.md",
          "03_type_system_core\\02_trait_system.md",
          "03_type_system_core\\03_type_constraints.md",
          "03_type_system_core\\04_variance.md",
          "04_generics\\01_formal_generic_system.md",
          "04_generics\\02_generic_theory.md",
          "04_generics\\02_type_parameters.md",
          "04_generics\\03_associated_types.md",
          "04_generics\\03_generic_implementation.md",
          "04_generics\\04_constraint_system.md",
          "04_generics\\05_generic_programming.md",
          "05_concurrency\\01_formal_concurrency_system.md",
          "05_concurrency\\02_thread_model.md",
          "05_concurrency\\03_async_system.md",
          "05_concurrency\\03_concurrency_implementation.md",
          "05_concurrency\\04_concurrency_applications.md",
          "05_concurrency\\05_concurrency_models.md",
          "05_formal_verification\\02_type_safety_proofs.md",
          "06_async_await\\01_async_programming_theory.md",
          "06_async_await\\01_formal_async_system.md",
          "06_async_await\\02_async_theory.md",
          "06_theory_practice\\01_theory_application_framework.md",
          "06_theory_practice\\02_practical_verification_cases.md",
          "07_macro_system\\01_formal_macro_system.md",
          "07_macro_system\\02_declarative_macros.md",
          "07_macro_system\\03_procedural_macros.md",
          "07_process_management\\01_formal_theory.md",
          "07_process_management\\02_task_management.md",
          "07_process_management\\03_io_system.md",
          "08_algorithms\\01_formal_algorithms_system.md",
          "08_algorithms\\01_formal_algorithm_system.md",
          "08_algorithms\\01_formal_theory.md",
          "08_algorithms\\02_algorithm_theory.md",
          "08_algorithms\\02_formal_data_structures.md",
          "08_algorithms\\03_algorithm_implementation.md",
          "08_algorithms\\04_algorithm_applications.md",
          "08_algorithms\\05_algorithm_models.md",
          "09_design_patterns\\02_behavioral_patterns.md",
          "09_error_handling\\01_formal_error_system.md",
          "09_error_handling\\02_error_theory.md",
          "09_error_handling\\03_error_implementation.md",
          "10_modules\\02_module_resolution_theory.md",
          "10_modules\\03_visibility_and_privacy.md",
          "12_middlewares\\01_formal_theory.md",
          "12_middlewares\\02_middleware_composition_theory.md",
          "12_traits\\02_trait_theory.md",
          "13_microservices\\02_service_communication_patterns.md",
          "14_workflow\\01_formal_workflow_system.md",
          "14_workflow\\01_workflow_theory.md",
          "14_workflow\\02_workflow_theory.md",
          "14_workflow\\03_workflow_implementation.md",
          "14_workflow\\04_workflow_applications.md",
          "14_workflow\\05_workflow_models.md",
          "15_blockchain\\01_formal_theory.md",
          "15_blockchain\\02_blockchain_theory.md",
          "15_blockchain\\04_blockchain_applications.md",
          "16_webassembly\\01_formal_theory.md",
          "16_webassembly\\01_webassembly_theory.md",
          "16_webassembly\\02_webassembly_theory.md",
          "17_iot\\01_formal_iot_system.md",
          "17_iot\\01_formal_theory.md",
          "17_iot\\01_iot_theory.md",
          "18_model\\01_formal_theory.md",
          "18_model\\01_model_theory.md",
          "19_advanced_features\\01_advanced_type_system.md",
          "19_advanced_language_features\\01_formal_theory.md",
          "19_advanced_language_features\\01_let_chains_analysis.md",
          "19_advanced_language_features\\02_cargo_cache_management.md",
          "19_advanced_language_features\\03_naked_functions_analysis.md",
          "19_advanced_language_features\\04_compiler_dwarf_stabilization.md",
          "19_advanced_language_features\\05_stabilized_apis_comprehensive.md",
          "19_advanced_language_features\\06_compatibility_and_lints.md",
          "19_advanced_language_features\\07_rustdoc_cargo_improvements.md",
          "19_advanced_language_features\\08_let_chains_extended_features.md",
          "19_advanced_language_features\\09_cargo_workspace_optimizations.md",
          "20_theoretical_perspectives\\01_formal_theory.md",
          "20_theoretical_perspectives\\01_theory.md",
          "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
          "20_version_features_analysis\\02_lazy_cell_lazy_lock_analysis.md",
          "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
          "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
          "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
          "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
          "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
          "20_version_features_analysis\\08_rust_178_async_improvements_comprehensive.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
          "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
          "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
          "20_version_features_analysis\\13_rust_180_lazy_cell_comprehensive.md",
          "20_version_features_analysis\\16_rust_186_cargo_improvements_comprehensive.md",
          "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
          "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
          "20_version_features_analysis\\19_rust_188_macro_improvements_comprehensive.md",
          "20_version_features_analysis\\20_rust_189_async_ecosystem_comprehensive.md",
          "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
          "20_version_features_analysis\\23_rust_192_future_roadmap_comprehensive.md",
          "21_application_domains\\01_formal_theory.md",
          "22_performance_optimization\\01_formal_theory.md",
          "23_security_verification\\01_formal_theory.md",
          "28_advanced_type_features\\01_higher_kinded_types.md",
          "28_advanced_type_features\\04_phantom_and_zero_sized_types.md",
          "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md",
          "ARCHIVE\\versions\\content_analysis_report_v1.md",
          "ARCHIVE\\versions\\content_restructuring_plan_v1.md"
        ]
      },
      {
        "symbol": "equiv",
        "variants": [
          "\\equiv",
          "⇔"
        ],
        "files": [
          "01_theory_foundations\\03_separation_logic.md",
          "02_type_system\\01_formal_type_system.md",
          "03_control_flow\\01_control_flow_theory.md",
          "03_control_flow\\01_formal_control_flow_system.md",
          "03_type_system_core\\00_index.md",
          "05_concurrency\\01_formal_theory.md",
          "05_formal_verification\\02_type_safety_proofs.md",
          "06_async_await\\01_formal_theory.md",
          "07_process_management\\01_formal_theory.md",
          "08_algorithms\\01_formal_theory.md",
          "09_design_patterns\\01_formal_theory.md",
          "09_design_patterns\\02_behavioral_patterns.md",
          "10_modules\\03_visibility_and_privacy.md",
          "12_middlewares\\01_formal_theory.md",
          "14_workflow\\02_workflow_theory.md",
          "16_webassembly\\01_formal_theory.md"
        ]
      },
      {
        "symbol": "bottom",
        "variants": [
          "⊥",
          "\\bot"
        ],
        "files": [
          "01_theory_foundations\\06_type_theory_foundations.md",
          "03_control_flow\\00_index.md",
          "03_control_flow\\02_control_flow_theory.md",
          "06_async_await\\00_index.md",
          "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md"
        ]
      }
    ]
  },
  "completeness_check": {
    "module_completeness": {
      "01_ownership_borrowing": {
        "expected_files": 2,
        "actual_files": 32,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_ownership_system.md",
          "01_ownership_rules.md",
          "01_ownership_theory.md",
          "02_borrowing_mechanism.md",
          "02_borrowing_system.md",
          "02_examples_and_applications.md",
          "02_ownership_theory.md",
          "03_borrowing_system.md",
          "03_borrow_checker.md",
          "03_lifetime_system.md",
          "04_lifetime_system.md",
          "04_lifetime_theory.md",
          "04_memory_management.md",
          "04_mutability_theory.md",
          "05_memory_safety.md",
          "05_move_semantics.md",
          "05_ownership_implementation.md",
          "05_variable_analysis.md",
          "06_move_semantics.md",
          "06_ownership_formal_proofs.md",
          "06_theorems.md",
          "07_case_and_comparison.md",
          "07_examples.md",
          "08_design_philosophy_and_symmetry.md",
          "09_formal_theory_and_proof.md",
          "10_engineering_case_studies.md",
          "11_future_trends_and_outlook.md",
          "FAQ.md",
          "Glossary.md",
          "README.md",
          "_index.md"
        ]
      },
      "02_type_system": {
        "expected_files": 2,
        "actual_files": 27,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_type_system.md",
          "01_introduction_and_philosophy.md",
          "01_type_system_foundations.md",
          "02_fundamental_concepts.md",
          "02_lifetime_system.md",
          "02_type_inference.md",
          "02_type_variance.md",
          "03_category_theory.md",
          "03_trait_system.md",
          "03_type_inference.md",
          "03_type_safety_and_inference.md",
          "04_generics_and_traits.md",
          "04_type_safety.md",
          "05_affine_types.md",
          "05_examples.md",
          "05_type_casting_and_coercion.md",
          "06_homotopy_types.md",
          "06_variance.md",
          "07_type_design.md",
          "08_type_conversion.md",
          "09_package_system.md",
          "10_advanced_theory.md",
          "FAQ.md",
          "Glossary.md",
          "README.md",
          "_index.md"
        ]
      },
      "03_control_flow": {
        "expected_files": 2,
        "actual_files": 24,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "00_progress_report.md",
          "01_control_flow_theory.md",
          "01_formal_control_flow.md",
          "01_formal_control_flow_system.md",
          "01_foundations_of_control_flow.md",
          "02_conditional_expressions.md",
          "02_control_flow_analysis.md",
          "02_control_flow_theory.md",
          "02_pattern_matching_system.md",
          "03_conditional_flow.md",
          "03_control_flow_optimization.md",
          "03_iterative_constructs.md",
          "04_examples.md",
          "04_functions_and_closures.md",
          "04_loop_control.md",
          "05_error_handling_as_control_flow.md",
          "05_function_control.md",
          "06_advanced_control_flow.md",
          "06_exception_handling.md",
          "FAQ.md",
          "Glossary.md",
          "README.md",
          "_index.md"
        ]
      },
      "04_generics": {
        "expected_files": 2,
        "actual_files": 24,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_generics.md",
          "01_formal_generic_system.md",
          "01_formal_theory.md",
          "01_introduction_to_generics.md",
          "02_generic_theory.md",
          "02_generic_type_parameters.md",
          "02_trait_system.md",
          "02_type_parameters.md",
          "03_associated_types.md",
          "03_generic_implementation.md",
          "03_trait_bounds.md",
          "04_associated_types.md",
          "04_constraint_system.md",
          "05_advanced_topics.md",
          "05_generic_impls.md",
          "05_generic_programming.md",
          "06_phantom_data.md",
          "07_generic_patterns.md",
          "08_examples.md",
          "FAQ.md",
          "Glossary.md",
          "README.md",
          "_index.md"
        ]
      },
      "05_concurrency": {
        "expected_files": 2,
        "actual_files": 18,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_concurrency_system.md",
          "01_formal_theory.md",
          "01_threads_and_ownership.md",
          "02_concurrency_theory.md",
          "02_message_passing.md",
          "02_thread_model.md",
          "03_async_system.md",
          "03_concurrency_implementation.md",
          "03_synchronization_primitives.md",
          "04_concurrency_applications.md",
          "04_parallelism_and_beyond.md",
          "05_advanced_topics_and_summary.md",
          "05_concurrency_models.md",
          "FAQ.md",
          "Glossary.md",
          "README.md",
          "_index.md"
        ]
      },
      "06_async_await": {
        "expected_files": 2,
        "actual_files": 15,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_async_programming_theory.md",
          "01_formal_async_system.md",
          "01_formal_theory.md",
          "01_introduction_and_philosophy.md",
          "02_async_theory.md",
          "02_runtime_and_execution_model.md",
          "03_pinning_and_unsafe_foundations.md",
          "04_streams_and_sinks.md",
          "05_async_in_traits_and_ecosystem.md",
          "06_critical_analysis_and_advanced_topics.md",
          "FAQ.md",
          "Glossary.md",
          "README.md",
          "_index.md"
        ]
      },
      "07_macro_system": {
        "expected_files": 2,
        "actual_files": 4,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_macro_system.md",
          "02_declarative_macros.md",
          "03_procedural_macros.md"
        ]
      },
      "08_algorithms": {
        "expected_files": 2,
        "actual_files": 12,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_algorithm_theory.md",
          "01_formal_algorithms_system.md",
          "01_formal_algorithm_system.md",
          "01_formal_sorting_algorithms.md",
          "01_formal_theory.md",
          "02_algorithm_theory.md",
          "02_formal_data_structures.md",
          "03_algorithm_implementation.md",
          "04_algorithm_applications.md",
          "05_algorithm_models.md",
          "progress_report.md"
        ]
      },
      "09_design_patterns": {
        "expected_files": 2,
        "actual_files": 3,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_theory.md",
          "02_behavioral_patterns.md"
        ]
      },
      "10_modules": {
        "expected_files": 2,
        "actual_files": 4,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_theory.md",
          "02_module_resolution_theory.md",
          "03_visibility_and_privacy.md"
        ]
      },
      "11_memory_management": {
        "expected_files": 2,
        "actual_files": 4,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_memory_management_system.md",
          "01_formal_theory.md",
          "02_memory_safety_proofs.md"
        ]
      },
      "12_traits": {
        "expected_files": 2,
        "actual_files": 4,
        "completion_rate": 1.0,
        "files": [
          "00_index.md",
          "01_formal_theory.md",
          "02_trait_theory.md",
          "03_trait_coherence_theory.md"
        ]
      }
    },
    "missing_files": [],
    "overall_completion": 1.0
  },
  "cross_reference_check": {
    "total_links": 5797,
    "broken_links": [
      {
        "source": "00_index.md",
        "target": "./EXECUTION_STATUS_V57.md",
        "resolved_path": "EXECUTION_STATUS_V57.md"
      },
      {
        "source": "00_index.md",
        "target": "./EXECUTION_STATUS_V56.md",
        "resolved_path": "EXECUTION_STATUS_V56.md"
      },
      {
        "source": "00_index.md",
        "target": "./EXECUTION_STATUS_V48.md",
        "resolved_path": "EXECUTION_STATUS_V48.md"
      },
      {
        "source": "00_index.md",
        "target": "./PROGRESS_REPORT_V48.md",
        "resolved_path": "PROGRESS_REPORT_V48.md"
      },
      {
        "source": "00_index.md",
        "target": "./BATCH_EXECUTION_PLAN_V52.md",
        "resolved_path": "BATCH_EXECUTION_PLAN_V52.md"
      },
      {
        "source": "00_index.md",
        "target": "./BATCH_EXECUTION_PLAN_V51.md",
        "resolved_path": "BATCH_EXECUTION_PLAN_V51.md"
      },
      {
        "source": "00_index.md",
        "target": "./BATCH_EXECUTION_PLAN_V43.md",
        "resolved_path": "BATCH_EXECUTION_PLAN_V43.md"
      },
      {
        "source": "00_index.md",
        "target": "./content_restructuring_plan_v1.md",
        "resolved_path": "content_restructuring_plan_v1.md"
      },
      {
        "source": "00_index.md",
        "target": "./content_analysis_report_v1.md",
        "resolved_path": "content_analysis_report_v1.md"
      },
      {
        "source": "concept_dictionary.md",
        "target": "01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "concept_dictionary.md",
        "target": "01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "concept_dictionary.md",
        "target": "01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "concept_dictionary.md",
        "target": "01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "concept_dictionary.md",
        "target": "03_control_flow/01_formal_theory.md",
        "resolved_path": "03_control_flow\\01_formal_theory.md"
      },
      {
        "source": "concept_dictionary.md",
        "target": "03_control_flow/01_formal_theory.md",
        "resolved_path": "03_control_flow\\01_formal_theory.md"
      },
      {
        "source": "cross_reference_guide.md",
        "target": "../main_comprehensive_index.md",
        "resolved_path": "..\\main_comprehensive_index.md"
      },
      {
        "source": "cross_reference_implementation_report.md",
        "target": "../02_type_system/00_index.md",
        "resolved_path": "..\\02_type_system\\00_index.md"
      },
      {
        "source": "cross_reference_implementation_report.md",
        "target": "../04_generics/00_index.md",
        "resolved_path": "..\\04_generics\\00_index.md"
      },
      {
        "source": "cross_reference_implementation_report.md",
        "target": "../05_concurrency/00_index.md",
        "resolved_path": "..\\05_concurrency\\00_index.md"
      },
      {
        "source": "cross_reference_implementation_report.md",
        "target": "../06_async_await/00_index.md",
        "resolved_path": "..\\06_async_await\\00_index.md"
      },
      {
        "source": "cross_reference_implementation_report.md",
        "target": "../11_memory_management/00_index.md",
        "resolved_path": "..\\11_memory_management\\00_index.md"
      },
      {
        "source": "cross_reference_implementation_report.md",
        "target": "../19_advanced_language_features/00_index.md",
        "resolved_path": "..\\19_advanced_language_features\\00_index.md"
      },
      {
        "source": "markdown_format_checker.md",
        "target": "../type_system/formal_theory.md",
        "resolved_path": "..\\type_system\\formal_theory.md"
      },
      {
        "source": "markdown_format_checker.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "01_ownership_borrowing\\README.md",
        "target": "./01_variable_and_ownership.md",
        "resolved_path": "01_ownership_borrowing\\01_variable_and_ownership.md"
      },
      {
        "source": "01_ownership_borrowing\\README.md",
        "target": "./02_lifetime_and_scope.md",
        "resolved_path": "01_ownership_borrowing\\02_lifetime_and_scope.md"
      },
      {
        "source": "01_ownership_borrowing\\README.md",
        "target": "./03_mutability_and_interior.md",
        "resolved_path": "01_ownership_borrowing\\03_mutability_and_interior.md"
      },
      {
        "source": "01_ownership_borrowing\\README.md",
        "target": "./04_move_and_partial_move.md",
        "resolved_path": "01_ownership_borrowing\\04_move_and_partial_move.md"
      },
      {
        "source": "01_ownership_borrowing\\README.md",
        "target": "./05_memory_management_and_balance.md",
        "resolved_path": "01_ownership_borrowing\\05_memory_management_and_balance.md"
      },
      {
        "source": "01_ownership_borrowing\\_index.md",
        "target": "./01_variable_and_ownership.md",
        "resolved_path": "01_ownership_borrowing\\01_variable_and_ownership.md"
      },
      {
        "source": "01_ownership_borrowing\\_index.md",
        "target": "./02_lifetime_and_scope.md",
        "resolved_path": "01_ownership_borrowing\\02_lifetime_and_scope.md"
      },
      {
        "source": "01_ownership_borrowing\\_index.md",
        "target": "./03_mutability_and_interior.md",
        "resolved_path": "01_ownership_borrowing\\03_mutability_and_interior.md"
      },
      {
        "source": "01_ownership_borrowing\\_index.md",
        "target": "./04_move_and_partial_move.md",
        "resolved_path": "01_ownership_borrowing\\04_move_and_partial_move.md"
      },
      {
        "source": "01_ownership_borrowing\\_index.md",
        "target": "./05_memory_management_and_balance.md",
        "resolved_path": "01_ownership_borrowing\\05_memory_management_and_balance.md"
      },
      {
        "source": "02_type_system\\00_index.md",
        "target": "02_type_theory.md",
        "resolved_path": "02_type_system\\02_type_theory.md"
      },
      {
        "source": "02_type_system\\00_index.md",
        "target": "06_theorems.md",
        "resolved_path": "02_type_system\\06_theorems.md"
      },
      {
        "source": "02_type_system\\00_index.md",
        "target": "07_references.md",
        "resolved_path": "02_type_system\\07_references.md"
      },
      {
        "source": "03_control_flow\\00_index.md",
        "target": "06_theorems.md",
        "resolved_path": "03_control_flow\\06_theorems.md"
      },
      {
        "source": "03_control_flow\\00_index.md",
        "target": "07_references.md",
        "resolved_path": "03_control_flow\\07_references.md"
      },
      {
        "source": "03_control_flow\\00_index.md",
        "target": "../19_advanced_language_features/05_closures.md",
        "resolved_path": "03_control_flow\\..\\19_advanced_language_features\\05_closures.md"
      },
      {
        "source": "03_control_flow\\00_index.md",
        "target": "../09_error_handling/01_formal_error_model.md",
        "resolved_path": "03_control_flow\\..\\09_error_handling\\01_formal_error_model.md"
      },
      {
        "source": "03_control_flow\\01_formal_control_flow.md",
        "target": "../20_theoretical_perspectives/01_programming_paradigms.md",
        "resolved_path": "03_control_flow\\..\\20_theoretical_perspectives\\01_programming_paradigms.md"
      },
      {
        "source": "03_control_flow\\01_formal_control_flow.md",
        "target": "../23_security_verification/02_formal_proofs.md",
        "resolved_path": "03_control_flow\\..\\23_security_verification\\02_formal_proofs.md"
      },
      {
        "source": "03_control_flow\\03_conditional_flow.md",
        "target": "../../02_type_system/07_references.md",
        "resolved_path": "03_control_flow\\..\\..\\02_type_system\\07_references.md"
      },
      {
        "source": "03_control_flow\\03_conditional_flow.md",
        "target": "../../23_security_verification/07_references.md",
        "resolved_path": "03_control_flow\\..\\..\\23_security_verification\\07_references.md"
      },
      {
        "source": "03_control_flow\\03_conditional_flow.md",
        "target": "../../22_performance_optimization/07_references.md",
        "resolved_path": "03_control_flow\\..\\..\\22_performance_optimization\\07_references.md"
      },
      {
        "source": "03_control_flow\\03_conditional_flow.md",
        "target": "../../20_theoretical_perspectives/07_references.md",
        "resolved_path": "03_control_flow\\..\\..\\20_theoretical_perspectives\\07_references.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/01_formal_trait_system.md",
        "resolved_path": "04_generics\\..\\12_traits\\01_formal_trait_system.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/02_trait_implementation.md",
        "resolved_path": "04_generics\\..\\12_traits\\02_trait_implementation.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../08_algorithms/01_collections.md",
        "resolved_path": "04_generics\\..\\08_algorithms\\01_collections.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/02_trait_bounds.md",
        "resolved_path": "04_generics\\..\\12_traits\\02_trait_bounds.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/02_trait_implementation.md",
        "resolved_path": "04_generics\\..\\12_traits\\02_trait_implementation.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/04_trait_composition.md",
        "resolved_path": "04_generics\\..\\12_traits\\04_trait_composition.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/03_trait_inheritance.md",
        "resolved_path": "04_generics\\..\\12_traits\\03_trait_inheritance.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../22_performance_optimization/02_compiler_optimizations.md",
        "resolved_path": "04_generics\\..\\22_performance_optimization\\02_compiler_optimizations.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../22_performance_optimization/01_formal_optimization_theory.md",
        "resolved_path": "04_generics\\..\\22_performance_optimization\\01_formal_optimization_theory.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../22_performance_optimization/02_compiler_optimizations.md",
        "resolved_path": "04_generics\\..\\22_performance_optimization\\02_compiler_optimizations.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../22_performance_optimization/03_runtime_optimizations.md",
        "resolved_path": "04_generics\\..\\22_performance_optimization\\03_runtime_optimizations.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../23_security_verification/01_formal_security_model.md",
        "resolved_path": "04_generics\\..\\23_security_verification\\01_formal_security_model.md"
      },
      {
        "source": "04_generics\\01_formal_generics.md",
        "target": "../12_traits/01_formal_trait_system.md",
        "resolved_path": "04_generics\\..\\12_traits\\01_formal_trait_system.md"
      },
      {
        "source": "05_concurrency\\00_index.md",
        "target": "03_thread_safety.md",
        "resolved_path": "05_concurrency\\03_thread_safety.md"
      },
      {
        "source": "05_concurrency\\00_index.md",
        "target": "04_synchronization_primitives.md",
        "resolved_path": "05_concurrency\\04_synchronization_primitives.md"
      },
      {
        "source": "05_concurrency\\00_index.md",
        "target": "05_atomic_operations.md",
        "resolved_path": "05_concurrency\\05_atomic_operations.md"
      },
      {
        "source": "05_concurrency\\00_index.md",
        "target": "06_memory_ordering.md",
        "resolved_path": "05_concurrency\\06_memory_ordering.md"
      },
      {
        "source": "05_concurrency\\00_index.md",
        "target": "07_message_passing.md",
        "resolved_path": "05_concurrency\\07_message_passing.md"
      },
      {
        "source": "05_concurrency\\00_index.md",
        "target": "08_shared_memory.md",
        "resolved_path": "05_concurrency\\08_shared_memory.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "01_type_system_safety.md",
        "resolved_path": "05_formal_verification\\01_type_system_safety.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "02_ownership_correctness.md",
        "resolved_path": "05_formal_verification\\02_ownership_correctness.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "03_program_logic.md",
        "resolved_path": "05_formal_verification\\03_program_logic.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "04_separation_logic.md",
        "resolved_path": "05_formal_verification\\04_separation_logic.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "05_concurrent_logic.md",
        "resolved_path": "05_formal_verification\\05_concurrent_logic.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "06_mechanized_proofs.md",
        "resolved_path": "05_formal_verification\\06_mechanized_proofs.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "07_coq_formalization.md",
        "resolved_path": "05_formal_verification\\07_coq_formalization.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "08_isabelle_verification.md",
        "resolved_path": "05_formal_verification\\08_isabelle_verification.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "09_verification_tools.md",
        "resolved_path": "05_formal_verification\\09_verification_tools.md"
      },
      {
        "source": "05_formal_verification\\00_index.md",
        "target": "10_case_studies.md",
        "resolved_path": "05_formal_verification\\10_case_studies.md"
      },
      {
        "source": "05_formal_verification\\02_type_safety_proofs.md",
        "target": "../11_memory_management/README.md",
        "resolved_path": "05_formal_verification\\..\\11_memory_management\\README.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "01_resource_management.md",
        "resolved_path": "06_theory_practice\\01_resource_management.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "02_raii_patterns.md",
        "resolved_path": "06_theory_practice\\02_raii_patterns.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "03_linear_types_practice.md",
        "resolved_path": "06_theory_practice\\03_linear_types_practice.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "04_design_patterns.md",
        "resolved_path": "06_theory_practice\\04_design_patterns.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "05_rust_idioms.md",
        "resolved_path": "06_theory_practice\\05_rust_idioms.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "06_ownership_patterns.md",
        "resolved_path": "06_theory_practice\\06_ownership_patterns.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "07_concurrency_safety.md",
        "resolved_path": "06_theory_practice\\07_concurrency_safety.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "08_parallel_patterns.md",
        "resolved_path": "06_theory_practice\\08_parallel_patterns.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "09_performance_impact.md",
        "resolved_path": "06_theory_practice\\09_performance_impact.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "10_zero_cost_abstractions.md",
        "resolved_path": "06_theory_practice\\10_zero_cost_abstractions.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "11_real_world_analogies.md",
        "resolved_path": "06_theory_practice\\11_real_world_analogies.md"
      },
      {
        "source": "06_theory_practice\\00_index.md",
        "target": "12_practical_applications.md",
        "resolved_path": "06_theory_practice\\12_practical_applications.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "02_macro_theory.md",
        "resolved_path": "07_macro_system\\02_macro_theory.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "03_hygiene_theory.md",
        "resolved_path": "07_macro_system\\03_hygiene_theory.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "04_declarative_macros.md",
        "resolved_path": "07_macro_system\\04_declarative_macros.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "05_procedural_macros.md",
        "resolved_path": "07_macro_system\\05_procedural_macros.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "06_attribute_macros.md",
        "resolved_path": "07_macro_system\\06_attribute_macros.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "07_dsl_construction.md",
        "resolved_path": "07_macro_system\\07_dsl_construction.md"
      },
      {
        "source": "07_macro_system\\00_index.md",
        "target": "08_code_generation.md",
        "resolved_path": "07_macro_system\\08_code_generation.md"
      },
      {
        "source": "07_macro_system\\03_procedural_macros.md",
        "target": "../05_formal_verification/README.md",
        "resolved_path": "07_macro_system\\..\\05_formal_verification\\README.md"
      },
      {
        "source": "07_process_management\\00_index.md",
        "target": "../13_safety_guarantees/00_index.md",
        "resolved_path": "07_process_management\\..\\13_safety_guarantees\\00_index.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "03_complexity_theory.md",
        "resolved_path": "08_algorithms\\03_complexity_theory.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "04_sorting_algorithms.md",
        "resolved_path": "08_algorithms\\04_sorting_algorithms.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "05_search_algorithms.md",
        "resolved_path": "08_algorithms\\05_search_algorithms.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "06_graph_algorithms.md",
        "resolved_path": "08_algorithms\\06_graph_algorithms.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "07_parallel_algorithms.md",
        "resolved_path": "08_algorithms\\07_parallel_algorithms.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "08_optimization_algorithms.md",
        "resolved_path": "08_algorithms\\08_optimization_algorithms.md"
      },
      {
        "source": "08_algorithms\\00_index.md",
        "target": "09_cryptographic_algorithms.md",
        "resolved_path": "08_algorithms\\09_cryptographic_algorithms.md"
      },
      {
        "source": "09_error_handling\\00_index.md",
        "target": "03_type_safety.md",
        "resolved_path": "09_error_handling\\03_type_safety.md"
      },
      {
        "source": "09_error_handling\\00_index.md",
        "target": "04_result_option.md",
        "resolved_path": "09_error_handling\\04_result_option.md"
      },
      {
        "source": "09_error_handling\\00_index.md",
        "target": "05_error_propagation.md",
        "resolved_path": "09_error_handling\\05_error_propagation.md"
      },
      {
        "source": "09_error_handling\\00_index.md",
        "target": "06_error_recovery.md",
        "resolved_path": "09_error_handling\\06_error_recovery.md"
      },
      {
        "source": "09_error_handling\\00_index.md",
        "target": "07_custom_errors.md",
        "resolved_path": "09_error_handling\\07_custom_errors.md"
      },
      {
        "source": "09_error_handling\\00_index.md",
        "target": "08_error_composition.md",
        "resolved_path": "09_error_handling\\08_error_composition.md"
      },
      {
        "source": "10_modules\\01_formal_theory.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "10_modules\\..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "10_modules\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "10_modules\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "10_modules\\03_visibility_and_privacy.md",
        "target": "../05_formal_verification/README.md",
        "resolved_path": "10_modules\\..\\05_formal_verification\\README.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "02_component_theory.md",
        "resolved_path": "11_frameworks\\02_component_theory.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "03_composition_rules.md",
        "resolved_path": "11_frameworks\\03_composition_rules.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "04_web_frameworks.md",
        "resolved_path": "11_frameworks\\04_web_frameworks.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "05_testing_frameworks.md",
        "resolved_path": "11_frameworks\\05_testing_frameworks.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "06_data_frameworks.md",
        "resolved_path": "11_frameworks\\06_data_frameworks.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "07_framework_patterns.md",
        "resolved_path": "11_frameworks\\07_framework_patterns.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "08_extension_mechanisms.md",
        "resolved_path": "11_frameworks\\08_extension_mechanisms.md"
      },
      {
        "source": "11_frameworks\\00_index.md",
        "target": "../10_networks/00_index.md",
        "resolved_path": "11_frameworks\\..\\10_networks\\00_index.md"
      },
      {
        "source": "11_frameworks\\01_formal_theory.md",
        "target": "../09_error_handling/01_formal_theory.md",
        "resolved_path": "11_frameworks\\..\\09_error_handling\\01_formal_theory.md"
      },
      {
        "source": "11_memory_management\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "11_memory_management\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "11_memory_management\\01_formal_theory.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "11_memory_management\\..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "02_composition_theory.md",
        "resolved_path": "12_middlewares\\02_composition_theory.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "03_async_middleware.md",
        "resolved_path": "12_middlewares\\03_async_middleware.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "04_pipeline_pattern.md",
        "resolved_path": "12_middlewares\\04_pipeline_pattern.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "05_onion_pattern.md",
        "resolved_path": "12_middlewares\\05_onion_pattern.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "06_error_handling.md",
        "resolved_path": "12_middlewares\\06_error_handling.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "07_web_frameworks.md",
        "resolved_path": "12_middlewares\\07_web_frameworks.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "08_microservice_middleware.md",
        "resolved_path": "12_middlewares\\08_microservice_middleware.md"
      },
      {
        "source": "12_middlewares\\00_index.md",
        "target": "../10_networks/00_index.md",
        "resolved_path": "12_middlewares\\..\\10_networks\\00_index.md"
      },
      {
        "source": "12_traits\\00_index.md",
        "target": "03_coherence_theory.md",
        "resolved_path": "12_traits\\03_coherence_theory.md"
      },
      {
        "source": "12_traits\\00_index.md",
        "target": "04_trait_resolution.md",
        "resolved_path": "12_traits\\04_trait_resolution.md"
      },
      {
        "source": "12_traits\\00_index.md",
        "target": "05_associated_types.md",
        "resolved_path": "12_traits\\05_associated_types.md"
      },
      {
        "source": "12_traits\\00_index.md",
        "target": "06_trait_objects.md",
        "resolved_path": "12_traits\\06_trait_objects.md"
      },
      {
        "source": "12_traits\\00_index.md",
        "target": "07_higher_ranked_traits.md",
        "resolved_path": "12_traits\\07_higher_ranked_traits.md"
      },
      {
        "source": "12_traits\\00_index.md",
        "target": "08_specialization.md",
        "resolved_path": "12_traits\\08_specialization.md"
      },
      {
        "source": "12_traits\\01_formal_theory.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "12_traits\\..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "14_workflow\\01_formal_theory.md",
        "target": "../03_control_flow/01_formal_theory.md",
        "resolved_path": "14_workflow\\..\\03_control_flow\\01_formal_theory.md"
      },
      {
        "source": "15_blockchain\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "15_blockchain\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "16_webassembly\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "16_webassembly\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "17_iot\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "17_iot\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "18_model\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "18_model\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "19_advanced_language_features\\01_formal_theory.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "19_advanced_language_features\\..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "19_advanced_language_features\\01_formal_theory.md",
        "target": "../06_macros/01_formal_theory.md",
        "resolved_path": "19_advanced_language_features\\..\\06_macros\\01_formal_theory.md"
      },
      {
        "source": "20_theoretical_perspectives\\01_formal_theory.md",
        "target": "../01_ownership_borrowing/01_formal_theory.md",
        "resolved_path": "20_theoretical_perspectives\\..\\01_ownership_borrowing\\01_formal_theory.md"
      },
      {
        "source": "20_theoretical_perspectives\\01_formal_theory.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "20_theoretical_perspectives\\..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "21_application_domains\\01_formal_theory.md",
        "target": "../02_type_system/01_formal_theory.md",
        "resolved_path": "21_application_domains\\..\\02_type_system\\01_formal_theory.md"
      },
      {
        "source": "21_application_domains\\01_formal_theory.md",
        "target": "../07_unsafe_rust/01_formal_theory.md",
        "resolved_path": "21_application_domains\\..\\07_unsafe_rust\\01_formal_theory.md"
      },
      {
        "source": "22_performance_optimization\\01_formal_theory.md",
        "target": "../03_memory_management/01_formal_theory.md",
        "resolved_path": "22_performance_optimization\\..\\03_memory_management\\01_formal_theory.md"
      },
      {
        "source": "22_performance_optimization\\01_formal_theory.md",
        "target": "../07_unsafe_rust/01_formal_theory.md",
        "resolved_path": "22_performance_optimization\\..\\07_unsafe_rust\\01_formal_theory.md"
      }
    ],
    "valid_links": 5644
  },
  "concept_definitions": {
    "**": [
      {
        "file": "concept_dictionary.md",
        "definition": "所有权是Rust内存管理的基本概念，指的是一个值在程序中只能有一个所有者，当所有者离开作用域时，该值将被销毁。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "移动语义是指在赋值或传参时，值的所有权从一个变量转移到另一个变量，而原变量不再有效的机制。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "借用是指在不转移所有权的情况下，临时获取对值的引用的机制，既可以是不可变借用，也可以是可变借用。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "生命周期是引用的有效作用域，用于防止引用指向已被释放的内存。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "类型安全是指程序在运行时不会因类型错误而导致未定义行为的特性。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "特征是Rust中定义共享行为的抽象接口，类似于其他语言中的接口或抽象类。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "类型推断是编译器根据上下文自动确定表达式类型的能力，无需程序员显式标注。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "模式匹配是一种解构和检查数据结构的机制，允许根据值的结构执行不同的代码路径。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "错误处理是处理程序执行过程中可能出现的异常情况的机制，在Rust中主要通过 `Result` 和 `Option` 类型实现。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "泛型是一种参数多态性机制，允许编写适用于多种类型的代码。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "特征约束是对泛型类型参数的限制，要求类型必须实现特定的特征。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "并发安全是指程序在多线程环境中执行时免于数据竞争和其他并发相关错误的特性。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "消息传递是一种并发通信模式，线程或任务通过发送和接收消息而非共享内存来通信。"
      },
      {
        "file": "concept_dictionary.md",
        "definition": "异步编程是一种并发编程模型，允许任务在等待I/O操作完成时暂停执行，而不阻塞线程。"
      },
      {
        "file": "cross_reference_implementation_report.md",
        "definition": "- [定义 1.1: 所有权](01_formal_ownership_system.md#所有权定义)"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "线性类型系统中的每个值必须恰好使用一次。"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "仿射类型系统允许值被使用零次或一次，但不能超过一次。"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "分离逻辑提供形式化方法来推理程序状态的分离部分。"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "类型环境 $\\Gamma$ 是变量到类型的映射。"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "所有权类型表示值的所有权状态。"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "所有权从一个变量转移到另一个变量。"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "$$B = (B_{\\text{imm}}, B_{\\text{mut}})$$"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "- [定义 1.4: 借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "$$\\text{Borrows}(r, x) = \\text{true} \\iff r \\text{ 借用 } x$$"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "- [定义 1.4: 借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "- [定义 1.5: 可变借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "$$\\text{BorrowChecker} = \\text{struct}\\{\\text{env}: \\text{BorrowEnv}, \\text{rules}: \\text{Vec}[\\text{BorrowRule}]\\}$$"
      },
      {
        "file": "01_ownership_borrowing\\06_theorems.md",
        "definition": "- [定义 1.1: 所有权](01_formal_ownership_system.md#所有权定义)"
      },
      {
        "file": "01_ownership_borrowing\\06_theorems.md",
        "definition": "- [定义 1.4: 借用](01_formal_ownership_system.md#借用定义)"
      },
      {
        "file": "01_ownership_borrowing\\06_theorems.md",
        "definition": "- [定义 1.6: 生命周期](01_formal_ownership_system.md#生命周期定义)"
      },
      {
        "file": "01_theory_foundations\\00_index.md",
        "definition": "使用操作语义和指称语义"
      },
      {
        "file": "01_theory_foundations\\01_linear_affine_types.md",
        "definition": "在线性类型系统中，如果 $\\Gamma \\vdash e : \\tau$ 表示在上下文 $\\Gamma$ 中表达式 $e$ 的类型为 $\\tau$，则线性类型系统要求："
      },
      {
        "file": "01_theory_foundations\\01_linear_affine_types.md",
        "definition": "仿射类型系统可表示为带有弱化规则（weakening rule）的线性逻辑："
      },
      {
        "file": "01_theory_foundations\\03_separation_logic.md",
        "definition": "如果 $P$ 和 $Q$ 是描述堆状态的断言，则分离合取 $P * Q$ 表示堆可以分为两个不相交的部分，一部分满足 $P$，另一部分满足 $Q$。"
      },
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "definition": "- **类型 (Type)**：表示一组值的集合或分类，记为 $T, S, U$ 等。"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "类型和函数形成范畴。"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "参数多态允许函数和数据结构对多种类型进行操作。"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "类型环境 $\\Gamma$ 是变量到类型的映射。"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "类型约束表示类型间的关系。"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "类型安全确保程序不会在运行时出现类型错误。"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "多态性允许代码对多种类型进行操作。"
      },
      {
        "file": "02_type_system\\02_fundamental_concepts.md",
        "definition": "结构体是 **积类型** 的实现。一个类型 `struct T { a: A, b: B }` 的所有可能值的集合，是类型 `A` 的值集和类型 `B` 的值集的 **笛卡尔积 (Cartesian Product)**。"
      },
      {
        "file": "02_type_system\\02_fundamental_concepts.md",
        "definition": "枚举是 **和类型 (或余积类型, Coproduct Type)** 的实现。一个类型 `enum E { V1(A), V2(B) }` 的所有可能值的集合，是类型 `A` 的值集和类型 `B` 的值集的 **不交并 (Disjoint Union)**。"
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "definition": "$$\\tau ::= \\alpha \\mid \\text{Int} \\mid \\text{Bool} \\mid \\text{String} \\mid \\tau_1 \\to \\tau_2 \\mid \\forall \\alpha. \\tau$$"
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "definition": "$$\\Gamma = \\{x_1 : \\tau_1, x_2 : \\tau_2, \\ldots, x_n : \\tau_n\\}$$"
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "definition": "$$\\sigma = [\\alpha_1 \\mapsto \\tau_1, \\alpha_2 \\mapsto \\tau_2, \\ldots, \\alpha_n \\mapsto \\tau_n]$$"
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "definition": "$$\\text{TypeScheme} = \\forall \\alpha_1. \\forall \\alpha_2. \\ldots \\forall \\alpha_n. \\tau$$"
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "definition": "$$\\text{generalize}(\\Gamma, \\tau) = \\forall \\alpha_1. \\forall \\alpha_2. \\ldots \\forall \\alpha_n. \\tau$$"
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "definition": "$$C = \\{\\tau_1 = \\tau_2, \\tau_3 = \\tau_4, \\ldots\\}$$"
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "$$\\Gamma_T = \\{\\text{Trait}_1[\\alpha_1], \\text{Trait}_2[\\alpha_2], \\ldots, \\text{Trait}_n[\\alpha_n]\\}$$"
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "```rust"
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "```rust"
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "```rust"
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "```rust"
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "$$\\text{VTable}[\\text{Trait}] = \\text{struct}\\{\\text{method}_1: \\text{fn}(\\text{*const ()}) \\to \\tau_1, \\ldots, \\text{method}_n: \\text{fn}(\\text{*const ()}) \\to \\tau_n\\}$$"
      },
      {
        "file": "02_type_system\\06_variance.md",
        "definition": "如果 `T` 是 `U` 的子类型，且 `F<T>` 也是 `F<U>` 的子类型，则 `F` 对参数 `T` 是协变的。"
      },
      {
        "file": "02_type_system\\06_variance.md",
        "definition": "如果 `T` 是 `U` 的子类型，但 `F<U>` 是 `F<T>` 的子类型，则 `F` 对参数 `T` 是逆变的。子类型关系被反转了。"
      },
      {
        "file": "02_type_system\\06_variance.md",
        "definition": "即使 `T` 是 `U` 的子类型，`F<T>` 和 `F<U>` 之间也没有子类型关系。"
      },
      {
        "file": "02_type_system\\08_type_conversion.md",
        "definition": "上转型是将一个具体类型的实例转换为其父类型的实例。"
      },
      {
        "file": "02_type_system\\08_type_conversion.md",
        "definition": "下转型是将一个父类型的实例转换为其子类型的实例。"
      },
      {
        "file": "02_type_system\\08_type_conversion.md",
        "definition": "如果类型 \\( A \\) 是类型 \\( B \\) 的子类型，则 \\( F(A) \\) 是 \\( F(B) \\) 的子类型。"
      },
      {
        "file": "02_type_system\\08_type_conversion.md",
        "definition": "如果类型 \\( A \\) 是类型 \\( B \\) 的子类型，则 \\( F(B) \\) 是 \\( F(A) \\) 的子类型。"
      },
      {
        "file": "02_type_system\\08_type_conversion.md",
        "definition": "类型 \\( A \\) 和类型 \\( B \\) 之间没有协变或逆变关系。"
      },
      {
        "file": "02_type_system\\08_type_conversion.md",
        "definition": "类型 \\( A \\) 和类型 \\( B \\) 之间存在协变和逆变关系。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 类型 \\( T \\) 是一组值的集合，定义了这些值的结构和操作。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 不可变借用：允许多个不可变引用同时存在。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 原始类型 \\( P \\) 是基本数据类型的集合。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 组合类型 \\( C \\) 是由多个类型构成的复合类型。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 解构操作将类型 \\( T \\) 的实例分解为其组成部分。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 控制流 \\( C \\) 是程序执行路径的集合。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 一致性 \\( I \\) 是在类型转换和解构过程中保持数据完整性的属性。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 协变：如果 \\( A \\) 是 \\( B \\) 的子类型，则 \\( F(A) \\) 是 \\( F(B) \\) 的子类型。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 双变：类型 \\( A \\) 和类型 \\( B \\) 之间存在协变和逆变关系。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 同步流 \\( S \\) 是线性执行的过程。"
      },
      {
        "file": "02_type_system\\10_advanced_theory.md",
        "definition": "- 同构关系 \\( H \\) 是在不同类型之间建立的结构相似性。"
      },
      {
        "file": "03_control_flow\\00_progress_report.md",
        "definition": "15个核心定义"
      },
      {
        "file": "03_control_flow\\02_conditional_expressions.md",
        "definition": "一个 `if` 表达式 \\(E_{if}\\) 接受一个条件 \\(c\\) (必须为 `bool` 类型) 和两个代码块，一个用于 `true` 情况 (\\(b_t\\))，一个用于 `false` 情况 (\\(b_f\\))。"
      },
      {
        "file": "03_control_flow\\02_conditional_expressions.md",
        "definition": "`if let pattern = expression { block_true } else { block_false }`"
      },
      {
        "file": "03_control_flow\\02_conditional_expressions.md",
        "definition": "一个 `match` 表达式 \\(E_{m}\\) 接受一个值 \\(v\\) 和一个模式-表达式对的列表 \\([(p_i, e_i), ...]\\)。它会返回第一个匹配成功的模式 \\(p_k\\) 对应的表达式 \\(e_k\\) 的求值结果。"
      },
      {
        "file": "03_control_flow\\02_conditional_expressions.md",
        "definition": "`match` 表达式必须是**穷尽的**，即它的模式必须覆盖所有可能输入的值。"
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "definition": "$$G = (V, E, entry, exit)$$"
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "definition": "$$\\text{Path} = \\text{sequence}[V]$$"
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "definition": "$$\\text{Reachable}(u, v) \\iff \\exists \\text{path}. \\text{path}[0] = u \\land \\text{path}[-1] = v$$"
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "definition": "$$\\text{State} = \\text{struct}\\{\\text{memory}: \\text{Memory}, \\text{stack}: \\text{Stack}, \\text{pc}: \\text{ProgramCounter}\\}$$"
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "definition": "$$\\text{AnalysisFramework} = \\text{struct}\\{\\text{domain}: \\text{Domain}, \\text{transfer}: \\text{TransferFunction}, \\text{meet}: \\text{MeetFunction}\\}$$"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`if` 表达式是一个条件判断结构，形式为 `if condition { block_true } else { block_false }`。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`match` 表达式将一个值与多个模式进行比较，并执行第一个匹配成功的分支。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`if let pattern = expression { block_true } else { block_false }`"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`while let pattern = expression { block }`"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`loop` 创建无限循环，形式为 `loop { block }`，必须通过 `break` 显式退出。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`while` 循环在每次迭代前检查条件，形式为 `while condition { block }`。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "`for` 循环用于迭代一个实现了 `IntoIterator` trait 的集合。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "- `break`：立即终止最内层循环"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "函数是具名的代码块，接收输入参数并可选择性返回值。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "递归是函数直接或间接调用自身的机制。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "发散函数是永不返回的函数，标记为返回类型 `!`。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "闭包是可以捕获环境的匿名函数，语法为 `|params| expression`。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "异步函数创建返回 `Future` 的函数，允许非阻塞执行。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "- `async` 关键字创建异步上下文"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "Rust编译器将异步函数转换为状态机，每个 `.await` 点对应一个状态。"
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "definition": "? 运算符是处理 `Result` 和 `Option` 的简洁方式，自动传播错误或空值。"
      },
      {
        "file": "03_control_flow\\03_control_flow_optimization.md",
        "definition": "$$\\text{OptimizationFramework} = \\text{struct}\\{\\text{analysis}: \\text{Analysis}, \\text{transformation}: \\text{Transformation}, \\text{verification}: \\text{Verification}\\}$$"
      },
      {
        "file": "03_control_flow\\04_functions_and_closures.md",
        "definition": "发散函数是永不返回的函数，其返回类型为 `!` (never type)。"
      },
      {
        "file": "03_control_flow\\05_error_handling_as_control_flow.md",
        "definition": "在一个返回 `Result` 或 `Option` 的函数中，对一个同样类型的表达式使用 `?` 运算符："
      },
      {
        "file": "03_control_flow_and_functions\\00_index.md",
        "definition": "参数化计算的抽象机制"
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "definition": "设 $\\mathcal{U}$ 是所有可能值的全集，类型 $T$ 是 $\\mathcal{U}$ 的一个子集，即 $T \\subseteq \\mathcal{U}$。"
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "definition": "一个类型系统是安全的，如果对于任何通过类型检查的程序 $P$，执行 $P$ 不会导致类型错误（如访问不存在的字段、调用不存在的方法等）。"
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "definition": "特征 $\\text{Tr}$ 可以表示为一个元组 $(\\text{Methods}, \\text{AssocItems})$，其中："
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "definition": "类型 $T$ 对特征 $\\text{Tr}$ 的实现 $\\text{Impl}(T, \\text{Tr})$ 是一个映射，将 $\\text{Tr}$ 中的每个方法签名和关联项映射到具体实现。"
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "definition": "泛型函数 $f<T: \\text{Tr}_1 + \\text{Tr}_2 + \\ldots + \\text{Tr}_n>$ 表示类型参数 $T$ 必须实现所有列出的特征。"
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "definition": "特征对象 $\\text{dyn Tr}$ 可以表示为一个存在类型（existential type）："
      },
      {
        "file": "03_type_system_core\\03_type_constraints.md",
        "definition": "类型约束 $C$ 是一个谓词 $C(T)$，对于任意类型 $T$，$C(T)$ 为真当且仅当 $T$ 满足约束 $C$。"
      },
      {
        "file": "03_type_system_core\\04_variance.md",
        "definition": "对于类型构造器 $F$，给定类型 $A$ 和 $B$，如果 $A <: B$（$A$ 是 $B$ 的子类型），则 $F$ 的型变性质决定了 $F<A>$ 和 $F<B>$ 之间的关系。"
      },
      {
        "file": "03_type_system_core\\04_variance.md",
        "definition": "子类型关系 $<:$ 是类型之间的一个偏序关系，满足以下性质："
      },
      {
        "file": "03_type_system_core\\05_subtyping.md",
        "definition": "如果类型 $S$ 是类型 $T$ 的子类型，记作 $S <: T$，则 $S$ 类型的值可以在期望 $T$ 类型的上下文中使用。"
      },
      {
        "file": "03_type_system_core\\05_subtyping.md",
        "definition": "如果类型 $S$ 实现了特征 $\\text{Tr}$，则 $S$ 是 $\\text{dyn Tr}$ 的子类型，即 $S <: \\text{dyn Tr}$。"
      },
      {
        "file": "03_type_system_core\\05_subtyping.md",
        "definition": "如果生命周期 `'a` 比 `'b` 长（即 `'a` 包含 `'b`），则 `'a` 是 `'b` 的子类型，记作 `'a <: 'b`。"
      },
      {
        "file": "03_type_system_core\\06_type_system_formal_proofs.md",
        "definition": "语言的形式化语义可以通过以下几种方式定义："
      },
      {
        "file": "03_type_system_core\\06_type_system_formal_proofs.md",
        "definition": "- **进展定理**：如果 $\\emptyset \\vdash e : T$（即在空环境中表达式 $e$ 具有类型 $T$），则 $e$ 要么是一个值，要么可以进行求值步骤。"
      },
      {
        "file": "03_type_system_core\\06_type_system_formal_proofs.md",
        "definition": "- 特征 $\\text{Tr}$ 定义为一组方法签名 $\\{m_1 : T_1, m_2 : T_2, \\ldots\\}$"
      },
      {
        "file": "03_type_system_core\\06_type_system_formal_proofs.md",
        "definition": "- 在定理证明助手中定义语言的语法、类型规则和操作语义"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\forall T \\in \\text{Type}, \\text{Generic}(P, T) \\Rightarrow P<T> \\in \\text{Type}$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\forall T \\in \\text{TypeParam}, \\forall \\tau \\in \\text{Type}, \\text{Subst}(T, \\tau) \\text{ is valid}$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$T : \\text{Trait} \\Rightarrow T \\text{ implements } \\text{Trait}$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$T \\models C \\Leftrightarrow T \\text{ implements all requirements of } C$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\sigma : \\text{TypeParam} \\rightarrow \\text{Type}$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\text{Container}<T> \\text{ where }:$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\text{fn } f<T>(x: T) \\rightarrow R \\text{ where}:$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$T : \\text{Trait} \\text{ where}:$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$T : \\text{Trait}_1 + \\text{Trait}_2 + ... + \\text{Trait}_n \\text{ where}:$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\text{'a} \\in \\text{LifetimeParam}, \\text{'a} \\subseteq \\text{Scope}$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\text{'a} : \\text{'b} \\Rightarrow \\text{'a} \\subseteq \\text{'b}$$"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "$$\\text{Monomorphize}(f<T>) = \\{f_{\\tau} | \\tau \\in \\text{Types used with } f\\}$$"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "参数化多态性允许类型和函数接受类型参数，实现代码的通用性。"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "类型环境包含类型变量和约束信息。"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "类型约束限制类型参数必须满足的条件。"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "$$\\frac{\\Gamma \\vdash \\alpha : \\text{Trait}}{\\Gamma \\vdash \\alpha : \\text{Constraint}}$$"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "单态化是将泛型代码转换为具体类型代码的过程。"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "关联类型允许Trait定义与实现者相关的类型。"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "生命周期参数化的泛型。"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "编译时常量参数化的泛型。"
      },
      {
        "file": "04_generics\\01_introduction_to_generics.md",
        "definition": "* **泛型类型 (Generic Type)**: 在定义结构体或枚举时使用的占位符类型。"
      },
      {
        "file": "04_generics\\01_introduction_to_generics.md",
        "definition": "单态化是编译器在编译期间，将泛型代码替换为使用具体类型的特定代码的过程。编译器会查看所有泛型函数被调用的地方，根据传入的具体类型，为每种类型生成一个非泛型的、定制化的函数实现。"
      },
      {
        "file": "04_generics\\02_generic_theory.md",
        "definition": "$$\\text{GenericType} = \\forall \\alpha_1, \\alpha_2, \\ldots, \\alpha_n. \\tau$$"
      },
      {
        "file": "04_generics\\05_advanced_topics.md",
        "definition": "类型构造器是一个\"函数\"，它在**类型级别**上运作。它接受一个或多个类型作为参数，并\"返回\"一个新的、具体的类型。"
      },
      {
        "file": "04_generics\\05_advanced_topics.md",
        "definition": "HKT 是**泛化类型构造器本身**的能力。换句话说，它允许我们编写一个不关心具体容器类型（如 `Vec` 或 `Option`），只关心容器\"形状\"的代码。"
      },
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "```math"
      },
      {
        "file": "06_async_await\\01_formal_async_system.md",
        "definition": "`std::future::Future` Trait。"
      },
      {
        "file": "06_async_await\\02_async_theory.md",
        "definition": "调度策略D是一个映射D: 2^T × H → T，其中T是任务集合，H是任务执行历史。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "Rust 用于编写异步代码的语法关键字。`async` 用于定义一个异步函数或代码块，它返回一个 `Future`。`await` 用于暂停一个 `async` 函数的执行，直到其等待的 `Future` 完成。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个 Trait，代表一个可以随时间推移而产生的值。这是 Rust 异步计算的核心抽象。`Future` 通过 `poll` 方法被驱动，直到产生一个最终值。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个库，提供了执行异步代码所需的服务。它包含一个或多个执行器、一个 I/O 事件反应器（如 epoll, kqueue）、定时器以及任务调度逻辑。`tokio` 和 `async-std` 是最流行的运行时。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "运行时的核心组件，负责接收异步任务（`Future`），并通过重复调用 `poll` 方法来驱动它们直至完成。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个智能指针，用于\"固定\"一个对象在内存中的位置，防止其被移动。这对于安全地处理自引用结构至关重要，而自引用结构是 `async`/`await` 状态机的常见实现方式。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个自动 Trait，用于标记那些即使被 `Pin` 包裹也可以安全移动的类型。绝大多数 Rust 类型都是 `Unpin` 的。如果一个类型不是 `Unpin`，它通常是自引用的。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个 Trait，代表一个异步的值序列。它是 `Iterator` 的异步等价物。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个 Trait，代表一个可以异步接收值的地方。它是 `Stream` 的对偶概念，用于异步写入数据。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个描述编程语言中 `async` 和 `sync` 函数之间交互限制的术语。它指出了 `async` 代码倾向于\"病毒式\"传播，以及 `async`/`sync` 边界处需要谨慎处理的架构问题。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个由执行器提供给 `Future` 的句柄。当一个 `Future` 在 `poll` 时返回 `Poll::Pending`，它必须存储这个 `Waker`。当 `Future` 准备好再次被轮询时（例如，一个 I/O 事件已发生），它会调用 `waker.wake()` 来通知执行器。"
      },
      {
        "file": "06_async_await\\Glossary.md",
        "definition": "一个流行的第三方 crate，它通过宏提供了在 Trait 中使用 `async fn` 的能力。它通过将 `Future` 包装在 `Box<dyn Future>` 中来实现对象安全。"
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "$$\\text{MacroSystem} = (\\text{MacroTypes}, \\text{MacroExpansion}, \\text{MacroHygiene}, \\text{MacroTypeSafety})$$"
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "$$\\text{MacroPattern} = \\text{TokenTree} \\times \\text{Repetition} \\times \\text{Metavariable}$$"
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "$$\\text{MacroTemplate} = \\text{TokenTree} \\times \\text{Substitution} \\times \\text{Repetition}$$"
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "$$\\text{ProceduralMacro} = \\text{enum}\\{"
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "```rust"
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "```rust"
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\text{DeclarativeMacro} = \\text{macro\\_rules!} \\quad \\text{MacroName} \\quad \\text{MacroRules}$$"
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\text{TokenTree} = \\text{enum}\\{"
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\text{Repetition} = \\text{enum}\\{*, +, ?\\}$$"
      },
      {
        "file": "08_algorithms\\progress_report.md",
        "definition": "使用严格的数学符号和定义"
      },
      {
        "file": "09_error_handling\\01_formal_error_system.md",
        "definition": "错误处理类型是代数数据类型的实例。"
      },
      {
        "file": "09_error_handling\\01_formal_error_system.md",
        "definition": "错误传播是错误值在函数调用链中的传递过程。"
      },
      {
        "file": "09_error_handling\\01_formal_error_system.md",
        "definition": "错误恢复是从错误状态恢复到正常状态的过程。"
      },
      {
        "file": "09_error_handling\\01_formal_error_system.md",
        "definition": "异常安全确保在错误发生时程序状态保持一致。"
      },
      {
        "file": "09_error_handling\\02_error_theory.md",
        "definition": "$$\\text{Result}\\langle T, E \\rangle = \\text{Ok}(T) + \\text{Err}(E)$$"
      },
      {
        "file": "10_modules\\01_formal_theory.md",
        "definition": "类型、trait、函数均以模块为作用域。"
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "管道 $P$ 是一系列中间件的组合："
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "管道是一系列中间件的线性组合。"
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "上下文是请求处理过程中可访问的共享状态。"
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "异步中间件返回一个Future。"
      },
      {
        "file": "12_traits\\02_trait_theory.md",
        "definition": "$$\\text{Trait} = \\text{Interface} \\times \\text{Constraints} \\times \\text{Methods}$$"
      },
      {
        "file": "12_traits\\02_trait_theory.md",
        "definition": "$$\\text{AssociatedType} = \\text{TypeName} \\times \\text{TypeBounds} \\times \\text{DefaultType}$$"
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "描述业务流程的结构和逻辑"
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "两者都描述了计算的整体结构和逻辑"
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "- 令F₁和F₂是两个异步函数，W₁和W₂是对应的工作流"
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "```rust"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "数据不存储在单一的中央服务器上，而是分布在网络中的多个节点（计算机）上。没有单一的控制中心或失败点。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "一旦数据被记录到区块链上，就极难甚至不可能被修改或删除。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "在公有链中，虽然参与者的真实身份可能是匿名的（通过地址表示），但账本上的所有交易记录通常是公开可见、可供任何人查询和验证的。私有链或联盟链可以根据需要设定不同的透明度级别。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "在分布式网络中，节点之间就账本状态（哪些交易是有效的、下一个区块应该由谁来创建）达成一致的规则和过程。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "数据不存储在单一的中央服务器上，而是分布在网络中的多个节点（计算机）上。没有单一的控制中心或失败点。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "一旦数据被记录到区块链上，就极难甚至不可能被修改或删除。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "在公有链中，虽然参与者的真实身份可能是匿名的（通过地址表示），但账本上的所有交易记录通常是公开可见、可供任何人查询和验证的。私有链或联盟链可以根据需要设定不同的透明度级别。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "在分布式网络中，节点之间就账本状态（哪些交易是有效的、下一个区块应该由谁来创建）达成一致的规则和过程。"
      },
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": "使用组件接口类型(WIT)定义接口"
      },
      {
        "file": "19_advanced_features\\01_advanced_type_system.md",
        "definition": "```rust"
      },
      {
        "file": "19_advanced_language_features\\04_compiler_dwarf_stabilization.md",
        "definition": "```mathematical"
      },
      {
        "file": "19_advanced_language_features\\05_stabilized_apis_comprehensive.md",
        "definition": "```mathematical"
      },
      {
        "file": "19_advanced_language_features\\06_compatibility_and_lints.md",
        "definition": "```mathematical"
      },
      {
        "file": "19_advanced_language_features\\07_rustdoc_cargo_improvements.md",
        "definition": "```mathematical"
      },
      {
        "file": "28_advanced_type_features\\00_index.md",
        "definition": "trait中的类型成员"
      },
      {
        "file": "28_advanced_type_features\\01_higher_kinded_types.md",
        "definition": "种类系统通常使用以下符号表示："
      },
      {
        "file": "RESTRUCTURE_WORKING\\phase4_major_improvements_summary.md",
        "definition": "编号的定义体系"
      },
      {
        "file": "ARCHIVE\\versions\\content_restructuring_plan_v1.md",
        "definition": "使用标准数学符号"
      }
    ],
    "行为": [
      {
        "file": "concept_dictionary.md",
        "definition": "避免因类型不匹配导致的运行时错误"
      },
      {
        "file": "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
        "definition": "96%减少"
      }
    ],
    "引用**": [
      {
        "file": "cross_reference_guide.md",
        "definition": "`定义 X.Y: 概念名称`"
      }
    ],
    "后，应添加相关概念部分": [
      {
        "file": "cross_reference_guide.md",
        "definition": "```markdown"
      }
    ],
    ".1**": [
      {
        "file": "cross_reference_guide.md",
        "definition": "所有权是指..."
      },
      {
        "file": "cross_reference_implementation_report.md",
        "definition": "所有权是指对一个值的唯一控制权，包括读取、修改和销毁该值的能力。"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "所有权是指对一个值的唯一控制权，包括读取、修改和销毁该值的能力。"
      },
      {
        "file": "02_type_system\\00_index.md",
        "definition": "[类型](01_formal_type_system.md#类型定义) - 值的集合及其操作"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "类型是一组值及其上的操作集合。"
      },
      {
        "file": "03_control_flow\\00_index.md",
        "definition": "[控制流](01_formal_control_flow.md#控制流定义) - 程序执行路径的形式化表示"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "操作语义描述程序如何逐步执行。"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "控制流图是程序执行路径的抽象表示。"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "控制流是程序执行路径的形式化表示，描述了程序如何在不同的语句和表达式之间转移执行控制。"
      },
      {
        "file": "06_theory_practice\\01_theory_application_framework.md",
        "definition": "理论应用映射 Application: Theory → Practice"
      }
    ],
    "与定理部分，例如": [
      {
        "file": "cross_reference_implementation_report.md",
        "definition": "```markdown"
      }
    ],
    "添加了相关定理和相关概念部分，例如": [
      {
        "file": "cross_reference_implementation_report.md",
        "definition": "```markdown"
      }
    ],
    "、相关定理和应用部分，例如": [
      {
        "file": "cross_reference_implementation_report.md",
        "definition": "```markdown"
      }
    ],
    "类型状态模式（Typestate Pattern）利用类型系统在编译时跟踪对象的状态。形式上，这可以表示为一个状态转换系统": [
      {
        "file": "fixed_temporary.md",
        "definition": "$$\\mathcal{T} = (S, \\Sigma, \\delta)$$"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "$$\\mathcal{T} = (S, \\Sigma, \\delta)$$"
      }
    ],
    "新类型模式（Newtype Pattern）通过创建单字段元组结构体，在类型系统中区分具有相同内部表示但语义不同的值": [
      {
        "file": "fixed_temporary.md",
        "definition": "$$\\text{Newtype}(T) \\neq T \\text{ 尽管 } |\\text{Newtype}(T)| = |T|$$"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "$$\\text{Newtype}(T) \\neq T \\text{ 尽管 } |\\text{Newtype}(T)| = |T|$$"
      }
    ],
    "标记特性模式（Marker Trait Pattern）使用无方法的特征来表示类型属性": [
      {
        "file": "fixed_temporary.md",
        "definition": "$$\\text{Marker} = \\{ T \\mid T \\text{ 满足特定属性 } P \\}$$"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "$$\\text{Marker} = \\{ T \\mid T \\text{ 满足特定属性 } P \\}$$"
      }
    ],
    "CRTP（奇异递归模板模式，Curiously Recurring Template Pattern）在 Rust 中通过特征与关联类型实现": [
      {
        "file": "fixed_temporary.md",
        "definition": "```rust"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "```rust"
      }
    ],
    "幻影类型模式（Phantom Type Pattern）使用不在值构造函数中出现的类型参数来表达额外的类型信息": [
      {
        "file": "fixed_temporary.md",
        "definition": "```rust"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "```rust"
      }
    ],
    "视图类型模式（View Type Pattern）创建了原始类型的不同\"视图\"，提供不同的操作集合": [
      {
        "file": "fixed_temporary.md",
        "definition": "```rust"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "```rust"
      }
    ],
    "Rust 通过 enum 实现代数数据类型（ADT）": [
      {
        "file": "fixed_temporary.md",
        "definition": "```rust"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "```rust"
      }
    ],
    "类型级编程使用类型系统作为编程语言，在编译时执行计算": [
      {
        "file": "fixed_temporary.md",
        "definition": "```rust"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "```rust"
      }
    ],
    "借用器模式（Borrower Pattern）提供了一种安全地临时借用对象内部数据的机制": [
      {
        "file": "fixed_temporary.md",
        "definition": "```rust"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "```rust"
      }
    ],
    "零成本抽象是 Rust 的核心设计原则之一，表示抽象不应增加运行时开销": [
      {
        "file": "fixed_temporary.md",
        "definition": "$$\\text{cost}(\\text{abstract}(f)) = \\text{cost}(f)$$"
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "definition": "$$\\text{cost}(\\text{abstract}(f)) = \\text{cost}(f)$$"
      }
    ],
    "**标准格式**": [
      {
        "file": "markdown_format_checker.md",
        "definition": "- 使用HTML锚点: `<a id=\"anchor-name\"></a>`"
      }
    ],
    "-使用一致性**": [
      {
        "file": "quality_check_guide.md",
        "definition": "确保概念的使用与其定义一致"
      }
    ],
    "- **定义 1.1**": [
      {
        "file": "01_ownership_borrowing\\00_index.md",
        "definition": "[所有权](01_formal_ownership_system.md#所有权定义) - 对值的唯一控制权"
      },
      {
        "file": "01_theory_foundations\\00_index.md",
        "definition": "[线性类型](01_linear_affine_types.md#线性类型定义) - 恰好使用一次的类型"
      }
    ],
    ".4**": [
      {
        "file": "01_ownership_borrowing\\00_index.md",
        "definition": "[借用](01_formal_ownership_system.md#借用定义) - 临时访问权限"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "借用是指在不转移所有权的情况下，临时获取对值的访问权限。借用分为不可变借用（只读访问）和可变借用（读写访问）。"
      },
      {
        "file": "01_theory_foundations\\00_index.md",
        "definition": "[分离合取](03_separation_logic.md#分离合取定义) - 内存分离的逻辑表示"
      },
      {
        "file": "02_type_system\\00_index.md",
        "definition": "[代数数据类型](01_formal_type_system.md#代数数据类型定义) - 复合数据类型的形式化定义"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "代数数据类型是通过类型代数运算（如积、和、幂等）构造的复合数据类型。"
      },
      {
        "file": "03_control_flow\\00_index.md",
        "definition": "[条件控制](01_formal_control_flow.md#条件控制) - 基于条件表达式的执行路径选择"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "循环控制是重复执行代码块的控制流结构。"
      },
      {
        "file": "03_control_flow_and_functions\\00_index.md",
        "definition": "[函数签名](02_function_formal_semantics.md#函数签名定义) - 函数类型的声明规范"
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[特质](02_trait_system.md#特质定义) - 类型行为的抽象接口"
      },
      {
        "file": "04_generics\\00_index.md",
        "definition": "[关联类型](04_associated_types.md#关联类型定义) - 特质内部的类型成员"
      },
      {
        "file": "05_concurrency\\00_index.md",
        "definition": "[原子性](05_atomic_operations.md#原子性定义) - 不可分割的操作性质"
      },
      {
        "file": "05_formal_verification\\00_index.md",
        "definition": "[并发安全](05_concurrent_logic.md#并发安全定义) - 并发错误的避免"
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "definition": "数据竞争 DataRace(T, t1, t2) 当且仅当："
      },
      {
        "file": "06_theory_practice\\00_index.md",
        "definition": "[抽象层次](10_zero_cost_abstractions.md#抽象层次定义) - 合适抽象级别的选择标准"
      },
      {
        "file": "07_macro_system\\00_index.md",
        "definition": "[宏展开](01_formal_macro_system.md#宏展开定义) - 宏到代码的转换过程"
      },
      {
        "file": "08_algorithms\\00_index.md",
        "definition": "[并行算法](07_parallel_algorithms.md#并行算法定义) - 多处理器环境的算法"
      },
      {
        "file": "09_error_handling\\00_index.md",
        "definition": "[错误恢复](06_error_recovery.md#错误恢复定义) - 从错误状态的恢复机制"
      },
      {
        "file": "11_frameworks\\00_index.md",
        "definition": "[扩展机制](08_extension_mechanisms.md#扩展机制定义) - 框架功能的扩展方式"
      },
      {
        "file": "12_middlewares\\00_index.md",
        "definition": "[异步中间件](03_async_middleware.md#异步中间件定义) - 支持异步操作的中间件"
      },
      {
        "file": "12_traits\\00_index.md",
        "definition": "[特质约束](02_trait_theory.md#特质约束定义) - 泛型参数的行为限制"
      },
      {
        "file": "28_advanced_type_features\\00_index.md",
        "definition": "[Trait对象](05_trait_objects_and_dynamic_dispatch.md#trait对象定义) - 动态分发机制"
      }
    ],
    ".6**": [
      {
        "file": "01_ownership_borrowing\\00_index.md",
        "definition": "[生命周期](01_formal_ownership_system.md#生命周期定义) - 引用有效期范围"
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "definition": "生命周期 $\\alpha$ 表示引用的有效期，即引用在程序中可以安全使用的时间范围。"
      },
      {
        "file": "02_type_system\\00_index.md",
        "definition": "[特质约束](03_trait_system.md#特质约束定义) - 类型行为的约束条件"
      },
      {
        "file": "03_control_flow\\00_index.md",
        "definition": "[函数控制](01_formal_control_flow.md#函数控制) - 函数调用和返回的控制流机制"
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "definition": "抽象函数 α: ConcreteState → AbstractState"
      }
    ],
    ".1 (所有权状态)**": [
      {
        "file": "01_ownership_borrowing\\01_ownership_rules.md",
        "definition": "设程序状态为一个映射 $\\sigma: \\text{Var} \\to \\text{State} \\times \\text{Value}$，其中 $\\text{Var}$ 是变量集合，$\\text{State}$ 是所有权状态集合，$\\text{Value}$ 是值的集合。"
      }
    ],
    ".2 (Drop)**": [
      {
        "file": "01_ownership_borrowing\\01_ownership_rules.md",
        "definition": "当一个变量 `x` 离开其作用域 `S` 时，如果其状态为 `Initialized(v)`，则会自动触发 `drop(v)` 操作，释放 `v` 占有的资源，并将 `x` 的状态迁移至 `Uninit`。"
      }
    ],
    ".3 (移动操作)**": [
      {
        "file": "01_ownership_borrowing\\01_ownership_rules.md",
        "definition": "`let y = x;` 的操作可以形式化为状态迁移："
      }
    ],
    ".4 (`Copy` 操作)**": [
      {
        "file": "01_ownership_borrowing\\01_ownership_rules.md",
        "definition": "如果类型 `T` 实现了 `Copy` trait，`let y = x;` 的操作变为："
      }
    ],
    ".5 (`Clone` 操作)**": [
      {
        "file": "01_ownership_borrowing\\01_ownership_rules.md",
        "definition": "`let y = x.clone();` 的操作形式化为："
      }
    ],
    "了资源的清理行为": [
      {
        "file": "01_ownership_borrowing\\01_ownership_theory.md",
        "definition": "$$\\text{Drop}(\\tau) \\iff \\forall x : \\tau, \\text{drop}(x) \\text{ is called when } x \\text{ goes out of scope}$$"
      }
    ],
    ".1 (生命周期与状态转换)**": [
      {
        "file": "01_ownership_borrowing\\02_borrowing_mechanism.md",
        "definition": "- 一个引用的创建，对应于应用 **规则 3.1** 或 **3.2** 的状态入口转换。"
      }
    ],
    "是": [
      {
        "file": "01_ownership_borrowing\\02_borrowing_mechanism.md",
        "definition": "在没有同步机制的情况下，两个或多个线程并发地访问同一内存位置，并且至少其中一个访问是写入操作。"
      }
    ],
    ".5": [
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "可变借用](../main_comprehensive_index.md#21-所有权与借用系统) (主索引)"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "类型替换"
      }
    ],
    ".6": [
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "生命周期](03_lifetime_system.md#生命周期定义) (本模块)"
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "definition": "生命周期](03_lifetime_system.md#生命周期定义) (本模块)"
      },
      {
        "file": "01_ownership_borrowing\\06_theorems.md",
        "definition": "生命周期](01_formal_ownership_system.md#生命周期定义)"
      }
    ],
    ".1 (区域与 Outlives 约束)**": [
      {
        "file": "01_ownership_borrowing\\04_lifetime_system.md",
        "definition": "- **区域 (Region)**: 一个生命周期 `'a` 代表了程序中的一个代码区域。"
      }
    ],
    "│   │   │   └── 态射": [
      {
        "file": "01_ownership_borrowing\\04_lifetime_theory.md",
        "definition": "将输入映射到输出"
      }
    ],
    "和实现之间存在对称结构": [
      {
        "file": "01_ownership_borrowing\\05_ownership_implementation.md",
        "definition": "```rust"
      }
    ],
    ".4": [
      {
        "file": "01_ownership_borrowing\\06_theorems.md",
        "definition": "借用](01_formal_ownership_system.md#借用定义)"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "约束满足 {#约束满足}"
      }
    ],
    ".2**": [
      {
        "file": "01_theory_foundations\\00_index.md",
        "definition": "[仿射类型](01_linear_affine_types.md#仿射类型定义) - 至多使用一次的类型"
      },
      {
        "file": "02_type_system\\00_index.md",
        "definition": "[子类型](08_type_conversion.md#子类型定义) - 类型间的包含关系"
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "definition": "如果类型 $\\tau$ 的值可以用于任何需要类型 $\\sigma$ 的上下文，则 $\\tau$ 是 $\\sigma$ 的子类型。"
      },
      {
        "file": "03_control_flow\\00_index.md",
        "definition": "[模式匹配](02_pattern_matching_system.md#模式匹配定义) - 结构化数据解构与条件控制的统一机制"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "指称语义将程序映射到数学对象。"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "状态转换系统描述程序执行的状态变化。"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "条件控制是基于布尔条件选择执行路径的控制流结构。"
      },
      {
        "file": "03_control_flow_and_functions\\00_index.md",
        "definition": "[循环不变式](01_conditional_and_looping_constructs.md#循环不变式定义) - 循环执行中保持的性质"
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[类型环境](01_basic_type_system.md#类型环境定义) - 变量到类型的映射"
      },
      {
        "file": "04_generics\\00_index.md",
        "definition": "[类型参数](02_type_parameters.md#类型参数定义) - 类型级别的参数化机制"
      },
      {
        "file": "05_concurrency\\00_index.md",
        "definition": "[数据竞争](01_formal_concurrency_system.md#数据竞争定义) - 并发访问的竞争条件"
      },
      {
        "file": "05_formal_verification\\00_index.md",
        "definition": "[类型安全](01_type_system_safety.md#类型安全定义) - 类型错误的免疫性"
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "definition": "正确性谓词 Correct(P, S) 当且仅当："
      },
      {
        "file": "06_theory_practice\\00_index.md",
        "definition": "[安全性实现](07_concurrency_safety.md#安全性实现定义) - 理论安全保证的实际实现"
      },
      {
        "file": "07_macro_system\\00_index.md",
        "definition": "[模式匹配](02_macro_theory.md#模式匹配定义) - 语法模式的匹配机制"
      },
      {
        "file": "08_algorithms\\00_index.md",
        "definition": "[算法正确性](01_formal_algorithm_system.md#正确性定义) - 算法满足规约的性质"
      },
      {
        "file": "09_error_handling\\00_index.md",
        "definition": "[Result Monad](02_error_theory.md#Result单子定义) - Result类型的单子性质"
      },
      {
        "file": "10_modules\\02_module_resolution_theory.md",
        "definition": "模块路径解析函数："
      },
      {
        "file": "11_frameworks\\00_index.md",
        "definition": "[组件接口](02_component_theory.md#组件接口定义) - 组件间的交互接口"
      },
      {
        "file": "12_middlewares\\00_index.md",
        "definition": "[中间件组合](02_composition_theory.md#组合定义) - 多个中间件的链式组合"
      },
      {
        "file": "12_middlewares\\02_middleware_composition_theory.md",
        "definition": "中间件组合 `∘` 满足结合律："
      },
      {
        "file": "12_traits\\00_index.md",
        "definition": "[特质实现](01_formal_theory.md#特质实现定义) - 类型对特质的具体实现"
      },
      {
        "file": "28_advanced_type_features\\00_index.md",
        "definition": "[关联类型](02_associated_types.md#关联类型定义) - Trait中的类型成员"
      }
    ],
    ".3**": [
      {
        "file": "01_theory_foundations\\00_index.md",
        "definition": "[区域](02_region_effect_systems.md#区域定义) - 内存位置的抽象"
      },
      {
        "file": "02_type_system\\00_index.md",
        "definition": "[类型推断](02_type_inference.md#类型推断定义) - 自动推导类型的过程"
      },
      {
        "file": "03_control_flow\\00_index.md",
        "definition": "[错误传播](06_exception_handling.md#错误传播定义) - 错误在控制流中的传递机制"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "公理语义通过前置条件和后置条件描述程序行为。"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "类型环境记录变量和表达式的类型信息。"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "模式匹配是基于数据结构模式选择执行路径的控制流结构。"
      },
      {
        "file": "03_control_flow_and_functions\\00_index.md",
        "definition": "[模式匹配](01_conditional_and_looping_constructs.md#模式匹配定义) - 数据结构的解构与绑定"
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[类型判断](01_basic_type_system.md#类型判断定义) - 表达式的类型推导"
      },
      {
        "file": "04_generics\\00_index.md",
        "definition": "[特质约束](03_trait_bounds.md#特质约束定义) - 对类型参数的行为约束"
      },
      {
        "file": "05_concurrency\\00_index.md",
        "definition": "[死锁](02_concurrency_theory.md#死锁定义) - 资源竞争的死锁状态"
      },
      {
        "file": "05_formal_verification\\00_index.md",
        "definition": "[内存安全](02_ownership_correctness.md#内存安全定义) - 内存错误的防护"
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "definition": "线性类型 Linear(T) 满足："
      },
      {
        "file": "06_theory_practice\\00_index.md",
        "definition": "[性能模型](09_performance_impact.md#性能模型定义) - 理论性能保证的实际表现"
      },
      {
        "file": "07_macro_system\\00_index.md",
        "definition": "[卫生宏](03_hygiene_theory.md#卫生宏定义) - 标识符作用域的自动管理"
      },
      {
        "file": "08_algorithms\\00_index.md",
        "definition": "[数据结构不变式](02_algorithm_theory.md#不变式定义) - 数据结构的恒定性质"
      },
      {
        "file": "09_error_handling\\00_index.md",
        "definition": "[错误传播](05_error_propagation.md#错误传播定义) - 错误在调用链中的传播"
      },
      {
        "file": "11_frameworks\\00_index.md",
        "definition": "[组合规则](03_composition_rules.md#组合规则定义) - 组件组合的形式化规则"
      },
      {
        "file": "12_middlewares\\00_index.md",
        "definition": "[处理上下文](01_formal_theory.md#上下文定义) - 中间件间共享的状态信息"
      },
      {
        "file": "12_traits\\00_index.md",
        "definition": "[关联类型](05_associated_types.md#关联类型定义) - 特质内部的类型投影"
      },
      {
        "file": "28_advanced_type_features\\00_index.md",
        "definition": "[Phantom Types](04_phantom_and_zero_sized_types.md#幽灵类型定义) - 编译时标记类型"
      }
    ],
    "线性类型理论源自线性逻辑，对值的使用施加了严格的约束": [
      {
        "file": "01_theory_foundations\\01_linear_affine_types.md",
        "definition": "每个值必须恰好使用一次，不能被复制或丢弃。"
      }
    ],
    "从集合论的角度看，如果类型 `T` 的值集合为 `S(T)`，那么由类型 `A` 和 `B` 构成的积类型 `P` 的值集合 `S(P)` 是 `S(A)` 和 `S(B)` 的 **笛卡尔积 (Cartesian Product)**": [
      {
        "file": "01_theory_foundations\\04_algebraic_data_types.md",
        "definition": "\\["
      }
    ],
    "从集合论的角度看，由类型 `A` 和 `B` 构成的和类型 `S` 的值集合 `S(S)` 是 `S(A)` 和 `S(B)` 的 **不交并 (Disjoint Union)**": [
      {
        "file": "01_theory_foundations\\04_algebraic_data_types.md",
        "definition": "\\["
      }
    ],
    "了如何从已知的判断推导出新判断。它们通常表示为": [
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "definition": "\\[\\frac{\\text{前提判断 } 1 \\quad \\text{前提判断 } 2 \\quad \\ldots}{\\text{结论判断}}\\]"
      }
    ],
    "- **设计模式**": [
      {
        "file": "02_type_system\\00_index.md",
        "definition": "类型设计的最佳实践和设计准则"
      }
    ],
    ".5**": [
      {
        "file": "02_type_system\\00_index.md",
        "definition": "[型变](08_type_conversion.md#型变定义) - 类型转换的协变与逆变性质"
      },
      {
        "file": "03_control_flow\\00_index.md",
        "definition": "[循环控制](01_formal_control_flow.md#循环控制) - 重复执行代码块的机制"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "函数控制是通过函数调用和返回实现控制流转移的机制。"
      },
      {
        "file": "03_control_flow_and_functions\\00_index.md",
        "definition": "[闭包捕获](02_function_formal_semantics.md#闭包捕获定义) - 环境变量的获取方式"
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[特质边界](03_type_constraints.md#特质边界定义) - 泛型约束机制"
      },
      {
        "file": "04_generics\\00_index.md",
        "definition": "[单态化](05_generic_impls.md#单态化定义) - 泛型的编译时实例化"
      },
      {
        "file": "05_concurrency\\00_index.md",
        "definition": "[内存序](06_memory_ordering.md#内存序定义) - 内存操作的顺序约束"
      },
      {
        "file": "05_formal_verification\\00_index.md",
        "definition": "[验证条件](03_program_logic.md#验证条件定义) - 证明义务的生成"
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "definition": "模型检查 ModelCheck(M, φ) 验证模型M是否满足性质φ"
      },
      {
        "file": "06_theory_practice\\00_index.md",
        "definition": "[实践反馈](12_practical_applications.md#实践反馈定义) - 实践对理论的改进推动"
      },
      {
        "file": "07_macro_system\\00_index.md",
        "definition": "[过程宏](05_procedural_macros.md#过程宏定义) - TokenStream的程序化处理"
      },
      {
        "file": "08_algorithms\\00_index.md",
        "definition": "[近似算法](08_optimization_algorithms.md#近似算法定义) - 近似最优解的算法"
      },
      {
        "file": "09_error_handling\\00_index.md",
        "definition": "[错误边界](01_formal_error_system.md#错误边界定义) - 错误影响范围的边界"
      },
      {
        "file": "11_frameworks\\00_index.md",
        "definition": "[配置模型](01_formal_theory.md#配置模型定义) - 框架配置的抽象模型"
      },
      {
        "file": "12_middlewares\\00_index.md",
        "definition": "[错误传播](06_error_handling.md#错误传播定义) - 中间件链中的错误处理机制"
      },
      {
        "file": "12_traits\\00_index.md",
        "definition": "[特质对象](06_trait_objects.md#特质对象定义) - 动态分发的运行时抽象"
      }
    ],
    "类型是值的集合及其操作的抽象": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{Type} = (V, O)$$"
      }
    ],
    "类型安全确保程序不会出现类型错误": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{TypeSafe}(P) \\iff \\forall \\text{execution}, \\text{no type errors}$$"
      }
    ],
    "操作**": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "对类型执行不支持的操作"
      }
    ],
    "所有权类型表示对值的独占所有权": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{Owned}(T) = \\text{exclusive ownership of } T$$"
      }
    ],
    "子类型关系表示类型之间的包含关系": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$A \\leq B \\iff \\text{all values of } A \\text{ can be used where } B \\text{ is expected}$$"
      }
    ],
    "协变": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "如果 $A \\leq B$，则 $F(A) \\leq F(B)$"
      }
    ],
    "逆变": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "如果 $A \\leq B$，则 $F(B) \\leq F(A)$"
      }
    ],
    "不变性": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "类型之间没有子类型关系"
      }
    ],
    "双变性": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "同时具有协变和逆变特性"
      }
    ],
    "了类型之间的运算": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{Type Algebra} = (\\text{Type}, +, \\times, \\rightarrow)$$"
      }
    ],
    "泛型允许类型参数化": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{Generic}(T) = \\forall \\alpha. F(\\alpha)$$"
      }
    ],
    "特征是类型行为的抽象": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{Trait}(T) = \\text{interface for type } T$$"
      }
    ],
    "关联类型是特征内部的类型参数": [
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "definition": "$$\\text{AssociatedType}(Trait, Type) = \\text{type defined within trait}$$"
      }
    ],
    "**Trait定义**": [
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "$$\\text{Trait}[\\alpha] = \\text{interface}\\{\\text{method}_1: \\tau_1, \\text{method}_2: \\tau_2, \\ldots, \\text{method}_n: \\tau_n\\}$$"
      }
    ],
    "**Trait对象类型**": [
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "$$\\text{TraitObject}[\\text{Trait}] = \\text{struct}\\{\\text{vtable}: \\text{*const VTable}[\\text{Trait}], \\text{data}: \\text{*const ()}\\}$$"
      }
    ],
    "**Trait继承语法**": [
      {
        "file": "02_type_system\\03_trait_system.md",
        "definition": "```rust"
      }
    ],
    "行为**": [
      {
        "file": "02_type_system\\05_type_casting_and_coercion.md",
        "definition": "某些指针转换可能导致未定义行为。"
      },
      {
        "file": "02_type_system\\FAQ.md",
        "definition": "将无效整数转为指针，或某些指针间的转换可能导致未定义行为。"
      }
    ],
    "类型设计准则": [
      {
        "file": "02_type_system\\09_package_system.md",
        "definition": "包管理与概念组织"
      },
      {
        "file": "02_type_system\\09_package_system.md",
        "definition": "包管理与概念组织](#rust-自定义类型设计准则包管理与概念组织)"
      }
    ],
    "了“第 2 章": [
      {
        "file": "02_type_system\\Glossary.md",
        "definition": "Rust 类型系统”中出现的关键术语。"
      }
    ],
    ". **严格的数学框架**": [
      {
        "file": "03_control_flow\\00_progress_report.md",
        "definition": "使用LaTeX符号的精确数学表示"
      }
    ],
    "`if` 表达式基于布尔条件选择性地执行代码块": [
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "definition": "$$\\text{IfExpression} ::= \\text{if } \\text{Expression} \\text{ then } \\text{Expression} \\text{ else } \\text{Expression}$$"
      }
    ],
    "`match` 表达式将值与模式进行比较": [
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "definition": "$$\\text{MatchExpression} ::= \\text{match } \\text{Expression} \\{ \\text{Pattern} \\Rightarrow \\text{Expression}, \\ldots \\}$$"
      }
    ],
    "模式是用于匹配值的结构": [
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "definition": "$$\\text{Pattern} ::= \\text{Literal} \\mid \\text{Variable} \\mid \\text{Wildcard} \\mid \\text{StructPattern} \\mid \\text{EnumPattern}$$"
      }
    ],
    "闭包是匿名函数": [
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "definition": "$$\\text{Closure} ::= |\\text{Parameters}| \\text{Expression}$$"
      }
    ],
    "使用泛型参数表示状态": [
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "definition": "```rust"
      }
    ],
    "$$\\frac{\\Gamma, x": [
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "definition": "\\tau \\vdash e: \\sigma}{\\Gamma \\vdash \\lambda x.e: \\tau \\rightarrow \\sigma}$$"
      }
    ],
    "为": [
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "definition": "$$"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "definition": "$$E_{match}(value, [(p_1, e_1), (p_2, e_2), ..., (p_n, e_n)]) = eval(e_i)$$"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "definition": "$$"
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "definition": "$$L_{loop}(body) = \\text{repeat}(body)$$"
      },
      {
        "file": "03_control_flow\\02_pattern_matching_system.md",
        "definition": "$$\\text{Pattern} = \\text{Literal} \\mid \\text{Variable} \\mid \\text{Wildcard} \\mid \\text{Constructor} \\mid \\text{Ref} \\mid \\text{Slice}$$"
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "definition": "$$\\sigma \\sim \\rho \\iff \\text{Match}(\\sigma, \\rho) = \\text{true}$$"
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "definition": "$$M = (S, S_0, T, L)$$"
      },
      {
        "file": "03_control_flow\\04_loop_control.md",
        "definition": "$$\\text{Iterator}[\\tau] = \\text{struct}\\{\\text{next}: \\text{fn}() \\to \\text{Option}[\\tau]\\}$$"
      },
      {
        "file": "03_control_flow\\04_loop_control.md",
        "definition": "1. **Map**: $\\text{map}(I, f) = \\{f(x) \\mid x \\in I\\}$"
      },
      {
        "file": "03_control_flow\\04_loop_control.md",
        "definition": "$$\\text{unroll}(L, n) = \\text{repeat}(L, n)$$"
      },
      {
        "file": "03_control_flow\\04_loop_control.md",
        "definition": "$$\\text{fuse}(L_1, L_2) = \\text{loop}(\\text{body}(L_1) \\circ \\text{body}(L_2))$$"
      },
      {
        "file": "03_control_flow\\04_loop_control.md",
        "definition": "$$S = \\{(pc, \\sigma) \\mid pc \\in \\text{ProgramCounter}, \\sigma \\in \\text{State}\\}$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$\\text{fn}(\\tau_1, ..., \\tau_n) \\to \\tau = \\text{struct}\\{\\text{params}: [\\tau_1, ..., \\tau_n], \\text{return}: \\tau\\}$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$\\text{signature}(f) = (\\text{params}(f), \\text{return}(f), \\text{effects}(f))$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$\\text{rec}(f, x, e) = \\text{fix}(\\lambda f. \\lambda x. e)$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$\\text{closure}(x, e, \\rho) = \\text{struct}\\{\\text{code}: \\lambda x. e, \\text{env}: \\rho\\}$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$\\text{capture}(e, \\rho) = \\{x \\mapsto v \\mid x \\in \\text{free}(e) \\land (x, v) \\in \\rho\\}$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$f \\circ g = \\lambda x. f(g(x))$$"
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "$$\\text{effects}(f) = \\{\\text{read}(x), \\text{write}(x), \\text{call}(g) \\mid x \\in \\text{vars}, g \\in \\text{functions}\\}$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{Result}[\\tau, \\epsilon] = \\text{enum}\\{\\text{Ok}(\\tau), \\text{Err}(\\epsilon)\\}$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{Error} = \\text{trait}\\{\\text{source}: \\text{fn}() \\to \\text{Option}[\\text{Error}], \\text{description}: \\text{fn}() \\to \\text{String}\\}$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{From}[\\epsilon_1, \\epsilon_2] = \\text{trait}\\{\\text{from}: \\text{fn}(\\epsilon_1) \\to \\epsilon_2\\}$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{propagate}(e) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow v, \\text{Err}(e) \\Rightarrow \\text{return Err}(e))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$e? = \\text{match}(e, \\text{Ok}(v) \\Rightarrow v, \\text{Err}(e) \\Rightarrow \\text{return Err}(e))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{early\\_return}(e_1, e_2, ..., e_n) = e_1?; e_2?; ...; e_n?; \\text{Ok}(\\text{result})$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{map\\_err}(e, f) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow \\text{Ok}(v), \\text{Err}(e) \\Rightarrow \\text{Err}(f(e)))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{and\\_then}(e, f) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow f(v), \\text{Err}(e) \\Rightarrow \\text{Err}(e))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{panic}(msg) = \\text{unwind}(\\text{panic\\_info}(msg))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{!} = \\text{never}$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{unwind}(info) = \\text{stack\\_unwind}(\\text{panic\\_info}, \\text{cleanup})$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{catch\\_unwind}(f) = \\text{try\\_catch}(f, \\text{panic\\_handler})$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{recover}(e, \\text{strategy}) = \\text{match}(\\text{strategy}, \\text{retry} \\Rightarrow \\text{retry}(e), \\text{fallback} \\Rightarrow \\text{fallback}(e), \\text{ignore} \\Rightarrow \\text{ignore}(e))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{optimize\\_error}(\\epsilon) = \\text{flatten}(\\text{normalize}(\\epsilon))$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{zero\\_cost\\_error}(e) = \\text{compile\\_time\\_check}(e) \\land \\text{runtime\\_zero\\_overhead}(e)$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "$$\\text{error\\_pattern} = \\text{Err}(\\text{pattern})$$"
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "definition": "1. **map**: $\\text{map}(e, f) = \\text{match}(e, \\text{Ok}(v) \\Rightarrow \\text{Ok}(f(v)), \\text{Err}(e) \\Rightarrow \\text{Err}(e))$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{trait}(name, \\text{items}) = \\text{interface}\\{\\text{methods}: \\text{items}, \\text{name}: \\text{string}\\}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{method}(name, \\text{params}, \\text{return}) = \\text{fn}(\\text{params}) \\to \\text{return}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{trait\\_object}(trait) = \\text{struct}\\{\\text{vtable}: \\text{VTable}[trait], \\text{data}: \\text{*mut}()\\}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{VTable}[trait] = \\text{struct}\\{\\text{methods}: [\\text{fn}(\\text{*mut}(), ...) \\to \\text{return}], \\text{drop}: \\text{fn}(\\text{*mut}())\\}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{solve}(\\text{constraints}) = \\text{find}(\\text{impls} \\mid \\text{constraints} \\subseteq \\text{impls})$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{associated\\_type}(name, \\text{bounds}) = \\text{type} \\text{ name}: \\text{bounds}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{impl\\_associated\\_type}(name, \\text{type}) = \\text{type} \\text{ name} = \\text{type}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{associated\\_type\\_bound}(trait, name, \\text{bounds}) = \\text{trait}::\\text{name}: \\text{bounds}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{default\\_impl}(method, \\text{body}) = \\text{method} \\text{ with default body}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{override}(default\\_impl, \\text{custom\\_impl}) = \\text{custom\\_impl}$$"
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "$$\\text{monomorphize}(\\text{generic\\_code}, \\text{type\\_args}) = \\text{specialized\\_code}$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{AssociatedType}(name, \\text{bounds}) = \\text{type} \\text{ name}: \\text{bounds}$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{AssociatedTypeEnv} = \\text{Map}[\\text{String}, \\text{AssociatedType}]$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{solve\\_associated\\_type}(\\text{constraints}) = \\text{find}(\\text{impls} \\mid \\text{constraints} \\subseteq \\text{impls})$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{ProjectionType}(\\text{trait}, \\text{name}) = \\text{trait}::\\text{name}$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{infer\\_associated\\_type}(\\text{context}, \\text{constraints}) = \\text{unify}(\\text{constraints})$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{unify}(\\text{constraints}) = \\text{most\\_general\\_unifier}(\\text{constraints})$$"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "$$\\text{monomorphize\\_associated\\_type}(\\text{generic\\_code}, \\text{type\\_args}) = \\text{specialized\\_code}$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{Constraint}(\\tau, \\text{trait}) = \\tau : \\text{trait}$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{ConstraintSet}(\\text{constraints}) = \\{\\text{constraints}_1, ..., \\text{constraints}_n\\}$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{Solver}(\\text{constraints}) = \\text{find}(\\text{impls} \\mid \\text{constraints} \\subseteq \\text{impls})$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{unify\\_constraints}(\\text{constraints}) = \\text{most\\_general\\_unifier}(\\text{constraints})$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{propagate}(\\text{constraints}) = \\text{transitive\\_closure}(\\text{constraints})$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$G = (V, E) \\text{ where } V = \\text{types}, E = \\text{constraints}$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{eliminate}(\\text{constraints}) = \\text{remove\\_redundant}(\\text{constraints})$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{sort\\_constraints}(\\text{constraints}) = \\text{topological\\_sort}(\\text{constraint\\_graph})$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{AssociatedTypeConstraint}(\\text{trait}, \\text{name}, \\text{bounds}) = \\text{trait}::\\text{name}: \\text{bounds}$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{LifetimeConstraint}(\\tau, \\text{lifetime}) = \\tau : \\text{lifetime}$$"
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "definition": "$$\\text{CompoundConstraint}(\\text{constraints}) = \\text{constraints}_1 \\land \\text{constraints}_2 \\land ... \\land \\text{constraints}_n$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{GenericFn}(\\text{params}, \\text{body}) = \\forall \\text{params}. \\text{fn}(\\text{param\\_types}) \\to \\text{return\\_type}$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{instantiate}(\\text{generic\\_fn}, \\text{type\\_args}) = \\text{specialize}(\\text{generic\\_fn}, \\text{type\\_args})$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{GenericStruct}(\\text{params}, \\text{fields}) = \\forall \\text{params}. \\text{struct}\\{\\text{fields}\\}$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{GenericEnum}(\\text{params}, \\text{variants}) = \\forall \\text{params}. \\text{enum}\\{\\text{variants}\\}$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{GenericTrait}(\\text{params}, \\text{items}) = \\forall \\text{params}. \\text{trait}\\{\\text{items}\\}$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{GenericConstraint}(\\text{type\\_param}, \\text{bounds}) = \\text{type\\_param}: \\text{bounds}$$"
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "definition": "$$\\text{monomorphize}(\\text{generic\\_code}, \\text{type\\_args}) = \\text{specialized\\_code}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Thread}(id, \\text{state}) = \\text{struct}\\{\\text{id}: \\text{ThreadId}, \\text{state}: \\text{ThreadState}, \\text{stack}: \\text{Stack}, \\text{registers}: \\text{Registers}, \\text{context}: \\text{ThreadContext}\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{ThreadId} = \\text{unique\\_identifier}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{CreateThread}(f) = \\text{new\\_thread}(\\text{execute}(f))$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Scheduler}(\\text{policy}) = \\text{struct}\\{\\text{policy}: \\text{SchedulingPolicy}, \\text{ready\\_queue}: \\text{Queue}[\\text{Thread}], \\text{running}: \\text{Option}[\\text{Thread}]\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{SchedulingPolicy} = \\text{enum}\\{\\text{RoundRobin}, \\text{Priority}, \\text{Fair}, \\text{WorkStealing}\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{SyncPrimitive} = \\text{enum}\\{\\text{Mutex}, \\text{RwLock}, \\text{Semaphore}, \\text{Barrier}, \\text{CondVar}\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Mutex}(\\text{data}) = \\text{struct}\\{\\text{locked}: \\text{bool}, \\text{owner}: \\text{Option}[\\text{ThreadId}], \\text{waiting}: \\text{Queue}[\\text{ThreadId}]\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{CondVar} = \\text{struct}\\{\\text{waiting}: \\text{Queue}[\\text{ThreadId}], \\text{mutex}: \\text{Mutex}\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Channel}(\\text{capacity}) = \\text{struct}\\{\\text{buffer}: \\text{Queue}[\\text{Value}], \\text{capacity}: \\text{usize}, \\text{senders}: \\text{int}, \\text{receivers}: \\text{int}\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{ChannelType} = \\text{enum}\\{\\text{Sender}[\\tau], \\text{Receiver}[\\tau], \\text{SyncSender}[\\tau], \\text{SyncReceiver}[\\tau]\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{ThreadPool}(\\text{workers}) = \\text{struct}\\{\\text{workers}: \\text{Vec}[\\text{Worker}], \\text{sender}: \\text{Sender}[\\text{Job}], \\text{receiver}: \\text{Receiver}[\\text{Job}]\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Worker} = \\text{struct}\\{\\text{id}: \\text{usize}, \\text{thread}: \\text{Option}[\\text{JoinHandle}[\\text{()}]], \\text{receiver}: \\text{Receiver}[\\text{Job}]\\}$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{WorkStealing} = \\text{steal\\_from\\_other\\_queues}(\\text{local\\_queue})$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{SafeConcurrentAccess}(t_1, t_2, \\tau) = \\neg \\text{DataRace}(t_1, t_2, \\tau)$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Send}(\\tau) = \\text{can\\_transfer\\_ownership\\_between\\_threads}(\\tau)$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{Sync}(\\tau) = \\text{can\\_share\\_reference\\_between\\_threads}(\\tau)$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{ThreadCreationOptimization} = \\text{Minimize}(\\text{creation\\_overhead}) \\land \\text{Maximize}(\\text{reuse})$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{ContextSwitchOptimization} = \\text{Minimize}(\\text{switch\\_overhead}) \\land \\text{Optimize}(\\text{scheduling})$$"
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "definition": "$$\\text{MemoryLocalityOptimization} = \\text{Maximize}(\\text{cache\\_hit\\_rate}) \\land \\text{Minimize}(\\text{false\\_sharing})$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncModel} = (\\text{Futures}, \\text{AsyncRuntime}, \\text{EventLoop})$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncExecution} = \\text{cooperative\\_multitasking}(\\text{Futures})$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncStateMachine} = (S, \\Sigma, \\delta, s_0, F)$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{Future}(\\tau) = \\text{trait}\\{\\text{poll}: \\text{fn}(\\&mut \\text{self}, \\&mut \\text{Context}) \\to \\text{Poll}[\\tau]\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{Poll}(\\tau) = \\text{enum}\\{\\text{Pending}, \\text{Ready}(\\tau)\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncFn}(\\tau_1, \\tau_2) = \\text{fn}(\\tau_1) \\to \\text{Future}[\\tau_2]$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncRuntime} = \\text{struct}\\{\\text{executor}: \\text{Executor}, \\text{reactor}: \\text{Reactor}, \\text{task\\_queue}: \\text{TaskQueue}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{Executor} = \\text{struct}\\{\\text{thread\\_pool}: \\text{ThreadPool}, \\text{task\\_scheduler}: \\text{TaskScheduler}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{EventLoop} = \\text{loop}\\{\\text{poll\\_events}(); \\text{process\\_events}(); \\text{schedule\\_tasks}();\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncIO} = \\text{struct}\\{\\text{file\\_descriptor}: \\text{FileDescriptor}, \\text{operation}: \\text{IOOperation}, \\text{callback}: \\text{IOCallback}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{IOOperation} = \\text{enum}\\{\\text{Read}, \\text{Write}, \\text{Connect}, \\text{Accept}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncStream}(\\tau) = \\text{trait}\\{\\text{next}: \\text{fn}(\\&mut \\text{self}) \\to \\text{Future}[\\text{Option}[\\tau]]\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{StreamOperation} = \\text{enum}\\{\\text{Map}, \\text{Filter}, \\text{Fold}, \\text{Collect}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncTask} = \\text{struct}\\{\\text{future}: \\text{Future}, \\text{state}: \\text{TaskState}, \\text{priority}: \\text{Priority}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{TaskState} = \\text{enum}\\{\\text{Ready}, \\text{Running}, \\text{Blocked}, \\text{Completed}\\}$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncPerformanceOptimization} = \\text{Maximize}(\\text{throughput}) \\land \\text{Minimize}(\\text{latency}) \\land \\text{Optimize}(\\text{resource\\_usage})$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncMemoryOptimization} = \\text{Minimize}(\\text{allocation\\_overhead}) \\land \\text{Optimize}(\\text{memory\\_layout})$$"
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "definition": "$$\\text{AsyncSchedulingOptimization} = \\text{Minimize}(\\text{context\\_switches}) \\land \\text{Maximize}(\\text{cpu\\_utilization})$$"
      },
      {
        "file": "05_concurrency\\03_synchronization_primitives.md",
        "definition": "1. **两个或以上**的线程并发地访问同一内存位置。"
      },
      {
        "file": "08_algorithms\\01_formal_sorting_algorithms.md",
        "definition": "$$\\text{TimeComplexity}(A) = O(f(n))$$"
      },
      {
        "file": "08_algorithms\\01_formal_sorting_algorithms.md",
        "definition": "$$\\text{SpaceComplexity}(A) = O(g(n))$$"
      },
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "definition": "$$\\text{Complexity}(op) = O(f(n))$$"
      },
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "definition": "$$\\text{Node}(T) = (\\text{Data}: T, \\text{Next}: \\text{Option<Box<Node<T>>>})$$"
      },
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "definition": "$$\\text{TreeNode}(T) = (\\text{Value}: T, \\text{Left}: \\text{Option<Box<TreeNode<T>>>}, \\text{Right}: \\text{Option<Box<TreeNode<T>>>}})$$"
      },
      {
        "file": "13_microservices\\00_index.md",
        "definition": "$$\\mathcal{M} = (\\mathcal{S}, \\mathcal{C}, \\mathcal{D}, \\mathcal{O})$$"
      },
      {
        "file": "13_microservices\\00_index.md",
        "definition": "$$\\text{Registry}(S) = \\forall s : S. \\exists r : \\text{Record}. \\text{register}(s) = r$$"
      },
      {
        "file": "13_microservices\\00_index.md",
        "definition": "$$\\text{LoadBalancer}(S, L) = \\forall r : \\text{Request}. \\exists s : S. \\text{route}(r) = s$$"
      },
      {
        "file": "13_microservices\\00_index.md",
        "definition": "$$\\text{CircuitBreaker}(S) = \\text{State} \\in \\{\\text{Closed}, \\text{Open}, \\text{HalfOpen}\\}$$"
      },
      {
        "file": "14_workflow\\00_index.md",
        "definition": "$$\\mathcal{W} = (S, T, I, O, \\Delta)$$"
      },
      {
        "file": "14_workflow\\00_index.md",
        "definition": "$$(W_1 \\circ W_2)(i) = W_2(W_1(i))$$"
      },
      {
        "file": "14_workflow\\00_index.md",
        "definition": "$$W_{async}(I) \\rightarrow \\text{Future}<O>$$"
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "```rust"
      },
      {
        "file": "15_blockchain\\00_index.md",
        "definition": "$$\\mathcal{B} = (B, H, T, S, C)$$"
      },
      {
        "file": "15_blockchain\\00_index.md",
        "definition": "$$\\text{Contract}(S, I, O) = \\forall i : I. \\exists s' : S. \\text{execute}(s, i) = (s', o)$$"
      },
      {
        "file": "15_blockchain\\00_index.md",
        "definition": "$$\\text{Block} = (\\text{Header}, \\text{Transactions})$$"
      },
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "definition": "`∀i ∈ [1, n], Bᵢ.h_prev = H(B_{i-1})`"
      },
      {
        "file": "16_webassembly\\00_index.md",
        "definition": "$$\\mathcal{W} = (M, F, T, I, E)$$"
      },
      {
        "file": "16_webassembly\\00_index.md",
        "definition": "$$\\text{Memory} = \\{(\\text{addr}, \\text{value}) | \\text{addr} \\in \\mathbb{N}, \\text{value} \\in \\text{Bytes}\\}$$"
      },
      {
        "file": "16_webassembly\\00_index.md",
        "definition": "$$\\vdash \\text{module} : \\text{valid}$$"
      },
      {
        "file": "17_iot\\00_index.md",
        "definition": "$$\\mathcal{I} = (D, S, N, P, C)$$"
      },
      {
        "file": "17_iot\\00_index.md",
        "definition": "$$\\text{RTOS}(T, R) = \\forall t \\in T. \\exists r \\in R. \\text{respond}(t) \\leq r$$"
      },
      {
        "file": "18_model\\00_index.md",
        "definition": "$$\\mathcal{M} = (E, R, C, T, S)$$"
      },
      {
        "file": "18_model\\00_index.md",
        "definition": "$$\\text{Verify}(\\mathcal{M}, \\phi) = \\forall \\mathcal{I} \\in \\text{Semantics}(\\mathcal{M}). \\mathcal{I} \\models \\phi$$"
      },
      {
        "file": "19_advanced_language_features\\00_index.md",
        "definition": "$$\\mathcal{T}_{adv} = (T, C, L, P)$$"
      },
      {
        "file": "19_advanced_language_features\\00_index.md",
        "definition": "$$\\text{Macro}(I) \\rightarrow O$$"
      },
      {
        "file": "19_advanced_language_features\\00_index.md",
        "definition": "$$\\mathcal{U} = (S, I, C)$$"
      },
      {
        "file": "19_advanced_language_features\\00_index.md",
        "definition": "$$T<\\text{const } N: \\tau>$$"
      },
      {
        "file": "20_theoretical_perspectives\\00_index.md",
        "definition": "$$\\mathcal{T}_{Rust} = (T, \\Gamma, \\vdash, R)$$"
      },
      {
        "file": "20_theoretical_perspectives\\00_index.md",
        "definition": "$$\\mathcal{C}_{Rust} = (Obj, Mor, \\circ, id)$$"
      },
      {
        "file": "20_theoretical_perspectives\\00_index.md",
        "definition": "$$\\mathcal{V}_{Rust} = (P, S, \\models, \\vdash)$$"
      },
      {
        "file": "21_application_domains\\00_index.md",
        "definition": "$$\\mathcal{D} = (E, R, C, M)$$"
      },
      {
        "file": "21_application_domains\\00_index.md",
        "definition": "$$\\text{Pattern}(D, P, S) = \\forall p \\in P. \\exists s \\in S. \\text{solve}(p, D) = s$$"
      },
      {
        "file": "21_application_domains\\01_formal_theory.md",
        "definition": "$$DSL_D = (L, \\Sigma_D, \\mathcal{R}_D, \\mathcal{S}_D)$$"
      },
      {
        "file": "21_application_domains\\01_formal_theory.md",
        "definition": "$$f_D(P) = \\sum_{i=1}^{n} w_i \\cdot c_i(P)$$"
      },
      {
        "file": "22_performance_optimization\\00_index.md",
        "definition": "$$\\mathcal{P} = (M, T, R, C)$$"
      },
      {
        "file": "22_performance_optimization\\00_index.md",
        "definition": "$$\\text{Strategy}(P, O) = \\forall p \\in P. \\exists o \\in O. \\text{optimize}(p) = o$$"
      },
      {
        "file": "22_performance_optimization\\01_formal_theory.md",
        "definition": "$$f(P, I) = \\sum_{i=1}^{n} w_i \\cdot m_i(P, I)$$"
      },
      {
        "file": "22_performance_optimization\\01_formal_theory.md",
        "definition": "$$M(P) = (T(P), S(P), E(P), L(P), C(P))$$"
      },
      {
        "file": "23_security_verification\\00_index.md",
        "definition": "$$\\mathcal{S} = (P, A, T, C)$$"
      },
      {
        "file": "23_security_verification\\00_index.md",
        "definition": "$$\\text{Verify}(\\text{System}, \\text{Property}) = \\text{System} \\models \\text{Property}$$"
      },
      {
        "file": "24_cross_language_comparison\\00_index.md",
        "definition": "$$\\mathcal{L} = (T, M, C, P, S)$$"
      },
      {
        "file": "24_cross_language_comparison\\00_index.md",
        "definition": "$$\\text{Compare}(L_1, L_2, D) = \\{(f_1, f_2, \\sim) | f_1 \\in L_1, f_2 \\in L_2, \\sim \\in D\\}$$"
      },
      {
        "file": "24_cross_language_comparison\\01_formal_theory.md",
        "definition": "$$FM_{i,j} = M_{f_j}(L_i)$$"
      },
      {
        "file": "25_teaching_learning\\00_index.md",
        "definition": "$$\\mathcal{L} = (C, P, S, M)$$"
      },
      {
        "file": "25_teaching_learning\\00_index.md",
        "definition": "$$\\text{Teach}(C, A, M) = \\{\\text{Session}(c_i, a_j, m_k) | c_i \\in C, a_j \\in A, m_k \\in M\\}$$"
      },
      {
        "file": "26_toolchain_ecosystem\\00_index.md",
        "definition": "$$\\mathcal{T} = (C, P, I, W)$$"
      },
      {
        "file": "26_toolchain_ecosystem\\00_index.md",
        "definition": "$$\\text{Dynamics}(\\mathcal{T}) = \\{(c_i, c_j, r_{ij}) | c_i, c_j \\in \\mathcal{T}.C, r_{ij} \\in R\\}$$"
      },
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "definition": "$$Boundary(Ecosystem) = Core \\cup \\{e | Compatible(e, Core)\\}$$"
      },
      {
        "file": "27_ecosystem_architecture\\00_index.md",
        "definition": "$$\\mathcal{G} = (V, E, W)$$"
      },
      {
        "file": "27_ecosystem_architecture\\00_index.md",
        "definition": "$$\\frac{d\\mathbf{S}}{dt} = \\mathbf{F}(\\mathbf{S}, \\mathbf{P}, t)$$"
      },
      {
        "file": "27_ecosystem_architecture\\01_formal_theory.md",
        "definition": "$$R(G) = 1 - \\frac{\\sum_{v \\in V} I(v) \\cdot V(v)}{\\sum_{v \\in V} V(v)}$$"
      },
      {
        "file": "27_ecosystem_architecture\\01_formal_theory.md",
        "definition": "$$C(a, b) = \\frac{|I_{compatible}(a, b)|}{|I_{total}(a, b)|}$$"
      },
      {
        "file": "27_ecosystem_architecture\\01_formal_theory.md",
        "definition": "$$P(S_0, S_n) = \\{S_0, S_1, \\ldots, S_n\\}$$"
      },
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "definition": "$$C(P) = \\sum_{i=0}^{n-1} c(S_i, S_{i+1})$$"
      },
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "definition": "```text"
      },
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "definition": "```rust"
      }
    ],
    "`match` 表达式必须是": [
      {
        "file": "03_control_flow\\02_conditional_expressions.md",
        "definition": "穷尽的**，即它的模式必须覆盖所有可能输入的值。"
      }
    ],
    ".2，$\\text{map}(I, f)": [
      {
        "file": "03_control_flow\\04_loop_control.md",
        "definition": "\\text{Iterator}[\\tau_2]$"
      }
    ],
    "了函数调用的参数传递和返回值处理方式": [
      {
        "file": "03_control_flow\\05_function_control.md",
        "definition": "1. **参数传递**: 按值传递或按引用传递"
      }
    ],
    "- **定义 3.1**": [
      {
        "file": "03_control_flow_and_functions\\00_index.md",
        "definition": "[条件表达式](01_conditional_and_looping_constructs.md#条件表达式定义) - 基于布尔值的分支选择"
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[类型](01_basic_type_system.md#类型定义) - 值的分类和操作集合"
      }
    ],
    "- **定义 3.6**": [
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[型变](04_variance.md#型变定义) - 子类型关系的传播性质"
      }
    ],
    ".7**": [
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[子类型](05_subtyping.md#子类型定义) - 类型间的替换关系"
      }
    ],
    ".8**": [
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[类型等价](01_basic_type_system.md#类型等价定义) - 类型的同构关系"
      }
    ],
    ".9**": [
      {
        "file": "03_type_system_core\\00_index.md",
        "definition": "[高阶类型](06_type_system_formal_proofs.md#高阶类型定义) - 类型的类型"
      }
    ],
    "的，则编译器会推导出约束 $T": [
      {
        "file": "03_type_system_core\\03_type_constraints.md",
        "definition": "\\text{Tr}$。"
      }
    ],
    "对于单参数类型构造器 $F<\\_>$，其型变性质可以形式化定义如下": [
      {
        "file": "03_type_system_core\\04_variance.md",
        "definition": "1. **协变**：$\\forall A, B. A <: B \\Rightarrow F<A> <: F<B>$"
      }
    ],
    "- **定义 4.1**": [
      {
        "file": "04_generics\\00_index.md",
        "definition": "[泛型](01_formal_generics.md#泛型定义) - 参数化类型的形式化定义"
      }
    ],
    "1.5: 类型替换": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "类型替换将类型参数替换为具体类型。\n\n**形式化定义**:\n$$\\sigma : \\text{TypeParam} \\rightarrow \\text{Type}$$\n$$\\sigma[T_1/T_2] \\text{ 表示将 } T_1 \\text{ 替换为 } T_2$$"
      }
    ],
    "2.1: 泛型容器": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "泛型容器是一种可以存储任意类型值的类型。\n\n**形式化定义**:\n$$\\text{Container}<T> \\text{ where }:$$\n\n- $T$ 是元素类型\n- $\\text{Container}<T>$ 提供 $T$ 的存储\n- $\\text{Container}<T>$ 维护所有权语义\n\n**示例 2.1: 向量类型**:\n\n```rust\nstruct Vec<T> {\n    data: Box<[T]>,\n    len: usize,\n    capacity: usize,\n}\n\nimpl<T> Vec<T> {\n    fn new() -> Self {\n        Vec {\n            data: Box::new([]),\n            len: 0,\n            capacity: 0,\n        }\n    }\n    \n    fn push(&mut self, item: T) {\n        // 实现确保类型安全\n    }\n}\n```\n\n**相关概念**:\n\n- [所有权系统](../01_ownership_borrowing/01_formal_ownership_system.md) (模块 01)\n- [集合类型](../08_algorithms/01_collections.md) (模块 08)"
      }
    ],
    "3.1: 单一特质约束": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "单一特质约束限制类型参数实现一个特质。\n\n**形式化定义**:\n$$T : \\text{Trait} \\text{ where}:$$\n\n- $T$ 必须实现 $\\text{Trait}$\n- $T$ 上必须有所有 $\\text{Trait}$ 方法\n\n**示例 3.1: Display约束**:\n\n```rust\nfn print<T: Display>(item: T) {\n    println!(\"{}\", item);\n}\n\n// T 必须实现 Display 特质\n// 这确保 println! 可以格式化 T\n```\n\n**相关概念**:\n\n- [特质约束](../12_traits/02_trait_bounds.md) (模块 12)\n- [特质实现](../12_traits/02_trait_implementation.md) (模块 12)"
      }
    ],
    "3.2: 多重特质约束": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "多重特质约束限制类型参数实现多个特质。\n\n**形式化定义**:\n$$T : \\text{Trait}_1 + \\text{Trait}_2 + ... + \\text{Trait}_n \\text{ where}:$$\n\n- $T$ 必须实现所有 $\\text{Trait}_i$\n- 所有特质的方法都可用\n\n**示例 3.2: Clone和Display**:\n\n```rust\nfn print_and_clone<T: Clone + Display>(item: T) -> T {\n    println!(\"{}\", item);\n    item.clone()\n}\n\n// T 必须同时实现 Clone 和 Display\n```\n\n**相关概念**:\n\n- [特质组合](../12_traits/04_trait_composition.md) (模块 12)\n- [特质继承](../12_traits/03_trait_inheritance.md) (模块 12)"
      }
    ],
    "5.1: 单态化": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "单态化是将泛型代码转换为具体类型代码的过程。\n\n**形式化定义**:\n$$\\text{Monomorphize}(f<T>) = \\{f_{\\tau} | \\tau \\in \\text{Types used with } f\\}$$\n\n**示例 5.1: 单态化示例**:\n\n```rust\n// 泛型定义\nfn identity<T>(x: T) -> T { x }\n\n// 使用\nlet a = identity(42);\nlet b = identity(\"hello\");\n\n// 单态化后\nfn identity_i32(x: i32) -> i32 { x }\nfn identity_str(x: &str) -> &str { x }\n```\n\n**相关概念**:\n\n- [编译优化](../22_performance_optimization/02_compiler_optimizations.md) (模块 22)\n- [零成本抽象](../22_performance_optimization/01_formal_optimization_theory.md) (模块 22)"
      }
    ],
    ".1": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "泛型 {#泛型定义}"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "泛型容器"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "单一特质约束"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "生命周期参数"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "单态化"
      }
    ],
    ".2": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "类型参数 {#类型参数定义}"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "泛型函数"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "多重特质约束"
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "生命周期约束"
      }
    ],
    ".3": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "特质约束 {#特质约束定义}"
      }
    ],
    "fn identity<T>(x": [
      {
        "file": "04_generics\\01_formal_generics.md",
        "definition": "T) -> T { x }"
      }
    ],
    "规则**": [
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "$$\\frac{\\Gamma, \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\vdash e : \\tau}{\\Gamma \\vdash \\text{fn} \\langle \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\rangle (x_1: \\tau_1, x_2: \\tau_2, \\ldots, x_n: \\tau_n) \\rightarrow \\tau : \\text{FunctionType}}$$"
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "definition": "$$\\frac{\\Gamma, \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\vdash \\text{fields} : \\text{FieldTypes}}{\\Gamma \\vdash \\text{struct} \\langle \\alpha_1, \\alpha_2, \\ldots, \\alpha_n \\rangle \\{ \\text{fields} \\} : \\text{StructType}}$$"
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\frac{\\Gamma \\vdash \\text{macro\\_rules!} \\quad \\Gamma \\vdash \\text{name}: \\text{Identifier} \\quad \\Gamma \\vdash \\text{rules}: \\text{MacroRules}}{\\Gamma \\vdash \\text{DeclarativeMacro}(\\text{name}, \\text{rules}) : \\text{Macro}}$$"
      },
      {
        "file": "28_advanced_type_features\\02_associated_types.md",
        "definition": "特征中的关联类型声明定义了一个类型占位符"
      }
    ],
    "- $\\text{impl}(trait, type)$": [
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "Trait实现"
      }
    ],
    "理论**": [
      {
        "file": "04_generics\\02_trait_system.md",
        "definition": "建立了Trait定义和方法的形式化模型"
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "建立了关联类型定义和环境的形式化模型"
      }
    ],
    "- $\\text{ImplAssociatedType}(name, \\tau)$": [
      {
        "file": "04_generics\\03_associated_types.md",
        "definition": "关联类型实现"
      }
    ],
    "`Iterator` Trait": [
      {
        "file": "04_generics\\04_associated_types.md",
        "definition": "```rust"
      }
    ],
    "类型构造器是一个\"函数\"，它在": [
      {
        "file": "04_generics\\05_advanced_topics.md",
        "definition": "类型级别**上运作。它接受一个或多个类型作为参数，并\"返回\"一个新的、具体的类型。"
      }
    ],
    "HKT 是": [
      {
        "file": "04_generics\\05_advanced_topics.md",
        "definition": "泛化类型构造器本身**的能力。换句话说，它允许我们编写一个不关心具体容器类型（如 `Vec` 或 `Option`），只关心容器\"形状\"的代码。"
      }
    ],
    "- **定义 05.1**": [
      {
        "file": "05_concurrency\\00_index.md",
        "definition": "[线程安全](03_thread_safety.md#线程安全定义) - 多线程环境下的安全性"
      }
    ],
    ".1.1 (进程)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "进程是程序执行的实例，包含代码、数据、堆栈和系统资源的集合，"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "进程是程序执行的实例，包含代码、数据、堆栈和系统资源，由操作系统分配和管理，具有独立的地址空间和执行上下文。"
      }
    ],
    ".2.1 (进程状态)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "一个进程可以处于以下几种状态之一：创建(Created)、运行(Running)、等待(Waiting)、终止(Terminated)。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "Created、Running、Waiting、Terminated。"
      }
    ],
    ".3.1 (命令构建器)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "`Command`是一个构建器模式实现，用于配置将要创建的新进程的各种参数。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "`Command`类型配置新进程参数。"
      }
    ],
    ".4.1 (进程属性)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "进程属性是影响进程行为和资源使用的可配置特性，包括环境变量、工作目录、I/O重定向等。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "环境变量、工作目录、I/O重定向等。"
      }
    ],
    ".1.1 (管道)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "管道是一种单向通信通道，由读取端和写入端组成，数据以字节流形式从写入端流向读取端。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "单向通信通道，数据以字节流形式从写入端流向读取端。"
      }
    ],
    ".2.1 (Unix域套接字)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "Unix域套接字是一种特殊类型的套接字，用于同一系统上进程间的通信，通过文件系统路径标识。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "同一系统进程间通信，文件系统路径标识。"
      }
    ],
    ".3.1 (共享内存段)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "共享内存段是一块可由多个进程映射到各自地址空间的内存区域，提供直接内存访问而无需数据复制。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "多进程映射同一物理内存区域。"
      }
    ],
    ".4.1 (信号)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "信号是发送给进程的异步通知，用于指示发生了特定事件或请求特定操作。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "进程间异步通知。"
      }
    ],
    "信号\"安全\"处理器的约束": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "```rust"
      }
    ],
    ".5.1 (消息队列)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "消息队列是一种允许进程发送和接收消息的IPC机制，支持消息优先级和类型。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "结构化消息传递机制。"
      }
    ],
    ".1.1 (互斥锁)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "互斥锁是一种同步原语，确保在任一时刻最多只有一个线程可以访问受保护的资源。"
      },
      {
        "file": "07_process_management\\01_process_theory.md",
        "definition": "确保同一时刻最多一个线程访问资源。"
      }
    ],
    ".2.1 (条件变量)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "条件变量是一种同步原语，允许线程在特定条件满足前等待，并在条件满足时接收通知。"
      }
    ],
    ".3.1 (信号量)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "信号量是一个计数器，用于控制对共享资源的访问数量，通过原子的P(减少)和V(增加)操作。"
      }
    ],
    ".4.1 (原子操作)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "原子操作是不可中断的操作单元，要么完全执行，要么完全不执行，没有中间状态。"
      }
    ],
    ".5.1 (内存排序)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "内存排序定义了不同线程对内存操作结果的观察规则，包括操作重排和可见性保证。"
      }
    ],
    ".6.1 (锁无关性)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "锁无关算法保证在任意线程子集失败或挂起的情况下，仍有线程可以完成操作。"
      }
    ],
    ".1.1 (并发系统模型)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "并发系统的形式化模型是对系统状态和转换的数学表示，用于分析系统属性。"
      }
    ],
    ".2.1 (安全性)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "安全性属性断言\"坏事不会发生\"，形式化表示为`∀s ∈ ReachableStates(M): P(s)`。"
      }
    ],
    ".2.2 (活性)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "活性属性断言\"好事最终会发生\"，形式化表示为`∀s ∈ ReachableStates(M), ∃s' ∈ ReachableStates(s): P(s')`。"
      }
    ],
    "- **互斥性**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "`∀t₁,t₂ ∈ Threads, t₁ ≠ t₂: ¬(InCriticalSection(t₁) ∧ InCriticalSection(t₂))`"
      }
    ],
    ".3.1 (通信顺序进程)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "CSP (Communicating Sequential Processes) 是一种形式化表示并发系统通信的代数模型。"
      }
    ],
    ".3.2 (π演算)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "π演算是一种更强大的进程代数，允许动态创建通信通道和进程。"
      }
    ],
    ".4.1 (死锁)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "死锁是系统状态，其中一组进程中的每个进程都在等待组中其他进程持有的资源，导致所有进程无法继续执行。"
      }
    ],
    ".5.1 (模型检查)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "模型检查是一种自动验证有限状态系统是否满足时态逻辑规范的技术。"
      }
    ],
    ".5.2 (定理证明)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "定理证明使用逻辑推理系统，从公理出发，应用推理规则，证明系统满足特定属性。"
      }
    ],
    ".1.1 (类型安全)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "类型安全是语言属性，确保操作只应用于支持这些操作的类型的值，防止类型错误。"
      }
    ],
    ".1.2 (内存安全)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "内存安全是程序属性，确保所有内存访问都是有效的，没有悬垂指针、缓冲区溢出或数据竞争。"
      }
    ],
    ".2.1 (所有权规则)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "Rust的所有权规则包括："
      }
    ],
    ".3.1 (生命周期)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "生命周期是编译器用来确保引用有效性的区域。"
      }
    ],
    ".4.1 (数据竞争)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "数据竞争是一种特定类型的竞争条件，当两个或更多线程同时访问同一内存位置，"
      }
    ],
    ".1.1 (进程池)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "进程池是一组预先创建的进程，用于执行任务，避免频繁创建和销毁进程的开销。"
      }
    ],
    ".1.2 (工作窃取)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "工作窃取是调度策略，允许空闲工作单元从繁忙单元的队列中\"窃取\"任务。"
      }
    ],
    ".2.1 (软件事务型内存)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "软件事务型内存(STM)是并发控制机制，允许代码块作为原子事务执行，提供自动冲突检测和回滚。"
      }
    ],
    ".3.1 (无等待)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "无等待算法保证任何线程的操作在有限步骤内完成，不管其他线程的执行情况如何。"
      }
    ],
    ".3.2 (无锁)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "无锁算法保证至少有一个线程在有限步骤内完成其操作。"
      }
    ],
    ".4.1 (扩展性)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "扩展性是系统随着资源（如处理器核心）增加而保持性能提升的能力。"
      }
    ],
    ".1.1 (平台抽象层)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "平台抽象层是代码层，提供统一API但在不同操作系统上有不同实现。"
      }
    ],
    ".2.1 (平台特定功能)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "平台特定功能是仅在特定操作系统上可用的系统功能。"
      }
    ],
    ".3.1 (可移植性)**": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "可移植性是代码在不同平台上无需修改或仅需最小修改即可正确运行的特性。"
      }
    ],
    "│   │   ├── 安全性": [
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "definition": "坏事不发生"
      }
    ],
    "(进程 Process)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "进程是操作系统进行资源分配和调度的基本单位，它拥有独立的内存地址空间、文件描述符、程序计数器和系统资源。进程间的隔离性是现代操作系统安全和稳定性的基石。"
      }
    ],
    "(Process Configuration `PConfig`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "一个包含可执行文件路径、参数列表、环境变量、工作目录、标准流配置等的记录。"
      }
    ],
    "(Process Handle `Child`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "一个代表操作系统子进程的句柄，可能包含 I/O 句柄（管道）。"
      }
    ],
    "(Exit Status `ExitStatus`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "包含进程退出码或终止原因的值。"
      }
    ],
    "(Pipe)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "一个单向的、基于字节流的、由操作系统内核管理的通信通道。`Pipe ≈ Queue<byte>`。"
      }
    ],
    "(Socket)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "网络通信的一个端点，由 IP 地址和端口号（或文件系统路径对 Unix 域套接字）标识。"
      }
    ],
    "(Shared Region `SR`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "`SR = Map(name: String, size: usize) -> Result<MemoryRegion>`。`MemoryRegion` 是一块可由多个进程访问的原始内存。"
      }
    ],
    "(Message Queue `MQ`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "`MQ(name) -> Handle`。`Send(Handle, Msg) -> Result<()>`, `Receive(Handle) -> Result<Msg>`。"
      }
    ],
    "(Signal)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "`Signal(pid, sig_type)`. 一个发送给特定进程的异步事件。"
      }
    ],
    "(Semaphore `Sem`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "`Sem(name: String, initial_value: u32) -> Result<Handle>`。"
      }
    ],
    "(System Mutex `SysMutex`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "`SysMutex(name: String) -> Result<Handle>`。"
      }
    ],
    "(File Lock `FLock`)**": [
      {
        "file": "05_concurrency\\02_concurrency_theory.md",
        "definition": "`FLock(file: FileHandle, type: LockType, mode: LockMode) -> Result<()>`。`FUnlock(file: FileHandle) -> Result<()>`。"
      }
    ],
    ".1.1** (内存位置)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "内存位置是一个有类型的存储单元，可以持有符合其类型的值。"
      }
    ],
    ".1.2** (内存一致性)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "一个内存操作序列是一致的，当且仅当所有线程观察到的所有存储器操作顺序符合一个全局顺序，且该顺序与程序顺序相容。"
      }
    ],
    "行为，包括": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "1. 数据竞争（Data Race）"
      }
    ],
    ".2.1** (所有权)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "每个值在任一时刻有且仅有一个所有者。"
      }
    ],
    ".2.2** (借用)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "引用类型表示对值的借用，分为可变借用（&mut T）和不可变借用（&T）。"
      }
    ],
    ".3.1** (`Send`)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "类型T是`Send`当且仅当将T的所有权从一个线程转移到另一个线程是安全的。"
      }
    ],
    ".3.2** (`Sync`)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "类型T是`Sync`当且仅当T的引用可以安全地在多个线程之间共享。"
      }
    ],
    ".1.1** (进程)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程是一个独立的执行环境，具有自己的内存空间、系统资源和执行状态。"
      }
    ],
    ".1.2** (进程创建)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程创建是指从当前执行环境派生出新的执行环境的操作。"
      }
    ],
    ".1.3** (进程状态)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程可以处于以下状态之一："
      }
    ],
    ".2.1** (进程通信通道)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程通信通道是一种允许不同进程之间交换数据的机制。"
      }
    ],
    ".3.1** (命令)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "命令是一个封装了程序路径、参数、环境变量等执行配置的实体。"
      }
    ],
    ".3.2** (执行结果)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "执行结果包含退出状态、标准输出和标准错误输出。"
      }
    ],
    ".4.1** (进程边界)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程边界是操作系统强制执行的内存和资源隔离机制。"
      }
    ],
    ".4.2** (权限提升)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "权限提升是指进程获取超出其初始权限的操作能力。"
      }
    ],
    ".1.1** (线程)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "线程是进程内的执行单元，共享进程的内存空间但有独立的执行栈和程序计数器。"
      }
    ],
    ".1.2** (线程创建)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "线程创建是指在现有进程内启动新的执行流。在Rust中："
      }
    ],
    ".2.1** (线程局部变量)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "线程局部变量是每个线程拥有独立实例的变量。"
      }
    ],
    ".3.1** (线程安全类型)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "类型T是线程安全的，当且仅当T实现了`Sync` trait且其任何方法的调用在并发环境中不会导致未定义行为。"
      }
    ],
    ".4.1** (线程池)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "线程池是一组预创建的线程，用于执行提交的任务，避免频繁的线程创建和销毁。"
      }
    ],
    ".4.2** (调度策略)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "调度策略决定了任务如何分配给线程池中的线程。"
      }
    ],
    ".1.1** (互斥锁)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "互斥锁是一种同步原语，确保在任意时刻最多有一个线程可以访问受保护的资源。"
      }
    ],
    ".2.1** (读写锁)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "读写锁是一种允许多个读取者或一个写入者（但不能同时存在）访问共享资源的同步原语。"
      }
    ],
    ".3.1** (条件变量)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "条件变量是一种同步原语，允许线程等待特定条件成为真，并在条件满足时被其他线程通知。"
      }
    ],
    ".4.1** (屏障)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "屏障是一种同步原语，确保一组线程在继续执行前都到达某个执行点。"
      }
    ],
    ".5.1** (信号量)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "信号量是一种维护计数器的同步原语，用于控制对共享资源的访问。"
      }
    ],
    ".1.1** (通道)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "通道是一种单向通信机制，允许一端（发送者）发送消息，另一端（接收者）接收消息。"
      }
    ],
    ".2.1** (同步通道)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "同步通道(`sync_channel`)要求发送操作阻塞直到消息被接收，或缓冲区有空间。"
      }
    ],
    ".2.2** (异步通道)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "异步通道(`channel`)允许发送操作在缓冲区未满时立即返回。"
      }
    ],
    ".3.1** (选择器)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "选择器是一种机制，允许线程同时等待多个通道操作，并处理首先就绪的那个。"
      }
    ],
    ".4.1** (通道组合)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "通道组合是指使用多个通道构建更复杂的通信结构。"
      }
    ],
    ".1.1** (原子操作)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "原子操作是一种不可分割的操作，在多线程环境中要么完全发生，要么完全不发生，没有中间状态。"
      }
    ],
    "了多线程程序中操作的可见性顺序": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "**定义 6.2.1** (内存排序)：内存排序是一组规则，用于确定在多线程程序中，对共享内存的读写操作如何对其他线程可见。"
      }
    ],
    ".3.1** (无锁算法)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "无锁算法是一种不使用互斥锁的并发算法，通常依赖于原子Compare-And-Swap(CAS)或Load-Linked/Store-Conditional(LL/SC)操作。"
      }
    ],
    ".3.2** (无等待属性)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "无等待(wait-free)算法保证所有线程在有限步骤内完成操作，无论其他线程的执行情况如何。"
      }
    ],
    ".4.1** (happens-before关系)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "happens-before是一个偏序关系，定义了内存操作的可见性顺序。如果操作A happens-before操作B，则A的效果对B可见。"
      }
    ],
    ".1.1** (类型安全并发)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "类型安全并发是指通过类型系统静态防止并发错误，如数据竞争。"
      }
    ],
    ".2.1** (死锁)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "死锁是指多个线程因循环等待资源而永久阻塞的状态。"
      }
    ],
    ".2.2** (死锁条件)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "死锁发生需要同时满足四个条件：互斥访问、持有并等待、不可抢占、循环等待。"
      }
    ],
    ".3.1** (通信协议)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "通信协议是定义进程间消息交换顺序、格式和语义的规则集。"
      }
    ],
    ".4.1** (数据竞争)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "数据竞争是指多个线程同时访问同一内存位置，且至少有一个是写入操作，且这些访问没有使用同步机制。"
      }
    ],
    ".1.1** (生产者-消费者模式)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "生产者-消费者是一种并发设计模式，其中一组线程（生产者）生成数据并放入共享缓冲区，另一组线程（消费者）从缓冲区取出数据处理。"
      }
    ],
    ".2.1** (读者-写者问题)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "读者-写者问题描述了多个读取者和写入者并发访问共享资源的协调问题，其中允许多个读取者同时访问，但写入者需要独占访问。"
      }
    ],
    ".3.1** (同步原语组合)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "同步原语组合是指将多种基本同步机制（如锁、条件变量、通道等）结合使用，构建更复杂的并发控制结构。"
      }
    ],
    ".4.1** (并发粒度)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "并发粒度指的是并发控制机制的范围大小，细粒度意味着较小的同步范围，粗粒度意味着较大的同步范围。"
      }
    ],
    ".1.1** (异步进程)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "异步进程管理是指使用异步编程模型启动、监视和与子进程交互的技术。"
      }
    ],
    ".2.1** (进程Future)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程Future是一个代表子进程执行的异步计算，完成时产生进程的退出状态。"
      }
    ],
    ".3.1** (异步通信通道)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "异步通信通道是一种允许跨进程异步消息传递的机制，操作返回Future而非阻塞。"
      }
    ],
    ".4.1** (跨进程协调)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "跨进程协调是指同步多个独立进程的执行和通信，确保它们按照预期顺序或关系运行。"
      }
    ],
    ".1.1** (信号)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "信号是操作系统发送给进程的异步通知，用于指示特定事件的发生。"
      }
    ],
    ".2.1** (进程模型)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "进程模型定义了操作系统如何创建、管理和终止进程，包括继承关系、资源分配和权限控制。"
      }
    ],
    ".3.1** (多进程架构)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "多进程架构是一种软件设计方法，将系统分解为多个通过明确机制通信的独立进程。"
      }
    ],
    ".4.1** (资源限制)": [
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "definition": "资源限制是操作系统施加的限制，约束进程可以使用的资源量（内存、CPU时间、文件描述符等）。"
      }
    ],
    "(Command)**": [
      {
        "file": "05_concurrency\\04_concurrency_applications.md",
        "definition": "`Command` 结构体代表一个将要被创建和执行的外部命令的配置蓝图。它本身不代表一个运行中的进程。"
      }
    ],
    "- **原子操作 (Atomic Operation)**": [
      {
        "file": "05_concurrency\\04_concurrency_applications.md",
        "definition": "一个操作在执行过程中不会被其他线程中断，它要么完全执行成功，要么完全不执行，不会出现中间状态。形式上，对于原子操作 A 作用于内存位置 M，不存在时间点 τ1 < τ < τ2，使得 M 在 τ 的状态既不是 A 执行前的状态，也不是 A 执行后的状态。"
      }
    ],
    "在 `std": [
      {
        "file": "05_concurrency\\05_advanced_topics_and_summary.md",
        "definition": ":sync::atomic` 模块中，例如 `AtomicBool`, `AtomicI32`, `AtomicPtr` 等。"
      }
    ],
    ".1.1 (进程)** 进程P是一个三元组P = (S, s₀, T)，其中": [
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "definition": "- S是可能状态的集合"
      }
    ],
    "强调了进程的核心特性": [
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "definition": "独立的状态空间和受控的状态转换。进程隔离是操作系统安全的基础，也是Rust并发安全的起点。"
      }
    ],
    ".3.1 (进程状态)** 进程可处于以下状态集合中的一个状态": [
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "definition": "{创建中, 就绪, 运行中, 阻塞, 终止}。"
      }
    ],
    ".1.1 (通信通道)** 通信通道C是一个四元组C = (S, R, M, B)，其中": [
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "definition": "- S是发送者集合"
      }
    ],
    ".1.2 (同步属性)** 同步机制必须满足以下属性": [
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "definition": "1. **互斥性**：任何时刻最多一个进程/线程可以访问临界区"
      }
    ],
    "了多线程程序中操作的可见性和顺序关系": [
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "definition": "**定义 5.2.1 (happens-before关系)** happens-before是偏序关系，若操作A happens-before操作B，则A的效果对B可见。"
      }
    ],
    "了\"第 5 章": [
      {
        "file": "05_concurrency\\Glossary.md",
        "definition": "并发\"中出现的关键术语。"
      }
    ],
    "- **定义 5.1**": [
      {
        "file": "05_formal_verification\\00_index.md",
        "definition": "[程序正确性](03_program_logic.md#程序正确性定义) - 程序满足规范的性质"
      }
    ],
    "**定义 1.1**": [
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "definition": "形式化验证是一个三元组 V = (S, P, M)，其中："
      },
      {
        "file": "10_modules\\02_module_resolution_theory.md",
        "definition": "模块空间 ModuleSpace 是一个有向无环图 (DAG)："
      },
      {
        "file": "12_middlewares\\02_middleware_composition_theory.md",
        "definition": "中间件函数是一个高阶函数："
      }
    ],
    "Future 特质是 Rust 异步编程的核心抽象": [
      {
        "file": "06_async_await\\01_async_programming_theory.md",
        "definition": "```rust"
      }
    ],
    "异步函数被编译为状态机": [
      {
        "file": "06_async_await\\01_async_programming_theory.md",
        "definition": "$$\\text{StateMachine} = (S, \\Sigma, \\delta, s_0, F)$$"
      }
    ],
    "非常简洁，其核心只有一个方法": [
      {
        "file": "06_async_await\\01_introduction_and_philosophy.md",
        "definition": "`poll`。"
      }
    ],
    "async fn fetch_data(url": [
      {
        "file": "06_async_await\\02_async_theory.md",
        "definition": "&str) -> Result<String, Error> {"
      }
    ],
    "可取消任务": [
      {
        "file": "06_async_await\\02_async_theory.md",
        "definition": "```rust"
      }
    ],
    "，是异步生态系统的基石之一。它的定义与 `Iterator` 非常相似": [
      {
        "file": "06_async_await\\04_streams_and_sinks.md",
        "definition": "```rust"
      }
    ],
    "- **定义 6.1**": [
      {
        "file": "06_theory_practice\\00_index.md",
        "definition": "[理论实践映射](01_resource_management.md#理论实践映射定义) - 理论到实践的转换关系"
      }
    ],
    "- **定义 07.1**": [
      {
        "file": "07_macro_system\\00_index.md",
        "definition": "[宏规则](01_formal_macro_system.md#宏规则定义) - 宏的形式化语法规则"
      }
    ],
    "- **规则引擎**": [
      {
        "file": "07_macro_system\\00_index.md",
        "definition": "业务规则的DSL表达"
      }
    ],
    "**卫生性条件**": [
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "definition": "$$\\text{Hygiene} = \\forall v \\in \\text{MacroVariables} \\cdot \\text{scope}(v) \\cap \\text{external\\_scope}(v) = \\emptyset$$"
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\text{Hygiene} = \\forall v \\in \\text{MacroVariables} \\cdot \\text{scope}(v) \\cap \\text{external\\_scope}(v) = \\emptyset$$"
      }
    ],
    "**模式语法**": [
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\text{MacroPattern} = \\text{TokenTree} \\times \\text{Repetition} \\times \\text{Metavariable}$$"
      }
    ],
    "**模板语法**": [
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "definition": "$$\\text{MacroTemplate} = \\text{TokenTree} \\times \\text{Substitution} \\times \\text{Repetition}$$"
      }
    ],
    "FunctionMacro": [
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "definition": "TokenStream → TokenStream"
      }
    ],
    "DeriveMacro": [
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "definition": "Struct | Enum → impl Block"
      }
    ],
    "AttributeMacro": [
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "definition": "(TokenStream, Item) → Item"
      }
    ],
    "- **定义 08.1**": [
      {
        "file": "08_algorithms\\00_index.md",
        "definition": "[算法复杂度](03_complexity_theory.md#复杂度定义) - 算法资源消耗的度量"
      }
    ],
    ".1.1 (算法特征抽象)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "用 trait 抽象算法核心行为，支持多实现与替换。"
      }
    ],
    ".1.2 (泛型算法)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "利用泛型参数实现类型无关的算法复用。"
      }
    ],
    ".2.1 (策略模式)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "通过 trait 和动态分发实现算法的运行时选择与切换。"
      }
    ],
    ".1.1 (命令式控制流)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "通过语句顺序和显式状态变化实现。"
      }
    ],
    ".1.2 (函数式控制流)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "通过函数组合和不可变性表达计算。"
      }
    ],
    ".2.1 (错误处理控制流)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "用 Result/Option 类型和 ? 运算符实现安全的错误传播。"
      }
    ],
    ".3.1 (数据流管道)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "通过迭代器和 map/filter/fold 等组合实现数据流式处理。"
      }
    ],
    ".3.2 (惰性求值)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "只有在需要时才计算结果，提升性能。"
      }
    ],
    ".1.1 (比较排序)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "如快速排序、归并排序。"
      }
    ],
    ".1.2 (非比较排序)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "如计数排序、基数排序。"
      }
    ],
    ".1.1 (Future 模型)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "异步计算的核心抽象。"
      }
    ],
    ".3.1 (执行器/调度器)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "管理任务生命周期和调度。"
      }
    ],
    ".1.1 (迭代器模式)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "统一遍历集合元素。"
      }
    ],
    ".1.2 (适配器模式)**": [
      {
        "file": "08_algorithms\\01_algorithm_theory.md",
        "definition": "组合和转换算法行为。"
      }
    ],
    "**定义 1.1** (算法)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "算法A是一个五元组 $A = (I, O, S, \\delta, s_0)$，其中："
      }
    ],
    ".2** (算法正确性)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "算法A对于问题P是正确的，当且仅当："
      }
    ],
    ".3** (时间复杂度)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "算法A的时间复杂度 $T_A(n)$ 是输入大小为n时执行的基本操作次数。"
      }
    ],
    ".4** (空间复杂度)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "算法A的空间复杂度 $S_A(n)$ 是输入大小为n时使用的额外存储空间。"
      }
    ],
    ".1** (顺序计算模型)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "顺序计算模型M是一个三元组："
      }
    ],
    "**定义 3.1** (排序问题)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "给定序列 $A = [a_1, a_2, \\ldots, a_n]$，排序问题是找到一个排列 $\\pi$ 使得："
      }
    ],
    ".2** (快速排序)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "快速排序是一种分治排序算法，基于选择pivot元素进行分区。"
      }
    ],
    ".3** (归并排序)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "归并排序是一种分治排序算法，将数组分为两半，递归排序后合并。"
      }
    ],
    "**定义 4.1** (搜索问题)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "给定集合 $S$ 和目标元素 $x$，搜索问题是找到 $x$ 在 $S$ 中的位置或确定 $x \\notin S$。"
      }
    ],
    ".2** (二分搜索)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "二分搜索是一种在有序数组中查找目标值的算法。"
      }
    ],
    ".3** (线性搜索)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "线性搜索是逐个检查数组元素直到找到目标值。"
      }
    ],
    "**定义 5.1** (图)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "图G是一个二元组 $G = (V, E)$，其中："
      }
    ],
    ".2** (邻接表表示)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "图的邻接表表示是一个映射 $adj: V \\rightarrow 2^V$，其中 $adj(v)$ 表示与顶点v相邻的顶点集合。"
      }
    ],
    ".3** (广度优先搜索)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "BFS是一种图遍历算法，从起始顶点开始，逐层访问相邻顶点。"
      }
    ],
    ".4** (深度优先搜索)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "DFS是一种图遍历算法，沿着图的边尽可能深入。"
      }
    ],
    ".5** (最短路径)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "给定带权图G和起始顶点s，最短路径问题是找到从s到所有其他顶点的最短路径。"
      }
    ],
    ".1** (最大公约数)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "两个整数a和b的最大公约数gcd(a,b)是能同时整除a和b的最大正整数。"
      }
    ],
    ".2** (素数)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "大于1的整数p是素数，当且仅当p的正因子只有1和p本身。"
      }
    ],
    ".1** (字符串匹配)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "给定文本T和模式P，字符串匹配问题是找到P在T中的所有出现位置。"
      }
    ],
    ".2** (KMP算法)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "KMP算法是一种高效的字符串匹配算法，利用模式的前缀函数避免不必要的比较。"
      }
    ],
    ".1** (PRAM模型)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "PRAM（并行随机访问机器）是一个并行计算模型，包含多个处理器共享内存。"
      }
    ],
    ".2** (并行复杂度)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "并行算法的时间复杂度是在PRAM模型上执行所需的时间步数。"
      }
    ],
    ".3** (并行归约)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "并行归约是将数组元素通过二元操作组合成单个值的过程。"
      }
    ],
    ".1** (算法操作语义)": [
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "definition": "算法的操作语义描述了算法执行时的状态转换。"
      }
    ],
    ".1** (算法)": [
      {
        "file": "08_algorithms\\01_formal_algorithm_system.md",
        "definition": "算法是一个精确定义的计算过程，它接受一个或多个值作为输入，并产生一个或多个值作为输出。"
      }
    ],
    ".2** (算法复杂度)": [
      {
        "file": "08_algorithms\\01_formal_algorithm_system.md",
        "definition": "算法的时间复杂度 $T(n)$ 和空间复杂度 $S(n)$ 分别描述了算法执行时间和内存使用与输入规模 $n$ 的关系。"
      }
    ],
    ".3** (算法正确性)": [
      {
        "file": "08_algorithms\\01_formal_algorithm_system.md",
        "definition": "一个算法对于其规范的形式化描述，如果它始终产生符合规范的输出，则称该算法是正确的。"
      }
    ],
    "fn sort<T": [
      {
        "file": "08_algorithms\\01_formal_algorithm_system.md",
        "definition": "Ord>(&self, slice: &mut [T]);"
      }
    ],
    "pub trait DivideAndConquer": [
      {
        "file": "08_algorithms\\01_formal_algorithm_system.md",
        "definition": "Sized {"
      }
    ],
    ".2.5 (红黑树)** 红黑树是一种自平衡二叉搜索树，每个节点都有一个额外的颜色属性（红色或黑色），并满足以下性质": [
      {
        "file": "08_algorithms\\02_algorithm_theory.md",
        "definition": "1. 每个节点是红色或黑色"
      }
    ],
    ".4.2 (散列函数)** 散列函数h": [
      {
        "file": "08_algorithms\\02_algorithm_theory.md",
        "definition": "K→[0,m-1]将键空间K映射到m个整数（桶索引），理想的散列函数应具有均匀分布性。"
      }
    ],
    "了数据之间的关系以及对这些数据的操作": [
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "definition": "$$\\text{DataStructure} = (\\text{Data}, \\text{Relations}, \\text{Operations})$$"
      }
    ],
    "为左子树高度减去右子树高度": [
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "definition": "$$\\text{BalanceFactor}(node) = \\text{Height}(\\text{Left}(node)) - \\text{Height}(\\text{Right}(node))$$"
      }
    ],
    "(合并操作 Merge)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "输入两个已排序序列 \\( A, B \\)，输出一个包含 \\( A \\) 和 \\( B \\) 所有元素的已排序序列 \\( C \\)。可以通过比较 \\( A, B \\) 的首元素，将较小的元素移入 \\( C \\) 并重复此过程来完成。"
      }
    ],
    "(分区操作 Partition)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "对序列 \\( A[p..r] \\)，选择基准 \\( x = A[k] \\)。重新排列 \\( A[p..r] \\)，使得存在一个索引 \\( q \\)，满足 \\( p \\le q \\le r \\)，并且对于所有 \\( i \\) 使得 \\( p \\le i < q \\)，有 \\( A[i] \\le x \\)，对于所有 \\( j \\) 使得 \\( q \\le j \\le r \\)，有 \\( A[j] \\ge x \\)。返回索引 \\( q \\)。常用Lomuto或Hoare分区方案。"
      }
    ],
    "(堆 Heap)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "一个数组 \\( A \\) 可以被视为一个近似完整的二叉树，如果它满足堆性质（父节点 \\( \\ge \\) 子节点（最大堆）或父节点 \\( \\le \\) 子节点（最小堆）），则称为堆。"
      }
    ],
    "(建堆 Build-Heap)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "将一个无序数组 \\( A \\) 转换成满足堆性质的数组。通常通过从最后一个非叶子节点开始向上调用 `heapify` 完成。"
      }
    ],
    "(维护堆性质 Heapify)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "给定一个节点 \\( i \\) 和它的左右子树（假设它们已满足堆性质），调整 \\( A[i] \\) 的位置，使得以 \\( i \\) 为根的子树满足堆性质。"
      }
    ],
    "(哈希函数 Hash Function)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "一个函数 \\( h: U \\to \\{0, 1, \\dots, m-1\\} \\)，将全域键空间 \\( U \\) 映射到大小为 \\( m \\) 的哈希表槽位。"
      }
    ],
    "(碰撞 Collision)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "当 \\( k_1 \\ne k_2 \\) 但 \\( h(k_1) = h(k_2) \\) 时，发生碰撞。需要解决碰撞（如链地址法、开放地址法）。"
      }
    ],
    "(松弛 Relaxation)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "对于边 \\( (u, v) \\) 权重为 \\( w(u, v) \\)，如果当前估计的到 \\( v \\) 的距离 `dist[v]` 大于通过 \\( u \\) 到达 \\( v \\) 的距离 `dist[u] + w(u, v)`，则更新 `dist[v]`。"
      }
    ],
    ".5.1 (最小生成树 Minimum Spanning Tree, MST)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "对于一个连通的、无向的、带权图 \\( G = (V, E, w) \\)，MST 是一个子图 \\( T = (V, E') \\)，其中 \\( E' \\subseteq E \\)，\\( T \\) 是一棵树且连接所有顶点，并且 \\( T \\) 的边的总权重 \\( \\sum_{e \\in E'} w(e) \\) 最小。"
      }
    ],
    ".1.1 (字符串匹配)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "给定一个文本串 \\( T \\) 和一个模式串 \\( P \\)，查找 \\( P \\) 在 \\( T \\) 中所有出现的位置。"
      }
    ],
    "(next数组)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "`next[j]` 是模式串 \\( P[0..j-1] \\) 的最长真前缀，同时也是其后缀的长度。"
      }
    ],
    "(大O符号 Big O Notation)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "描述算法运行时间或空间消耗随输入规模 \\( n \\) 增长的**上界**。\\( f(n) = O(g(n)) \\) 意为存在正常数 \\( c \\) 和 \\( n_0 \\)，使得对所有 \\( n \\ge n_0 \\)，有 \\( 0 \\le f(n) \\le c g(n) \\)。"
      }
    ],
    "(P类问题)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "能在多项式时间内由确定性图灵机解决的判定问题集合。"
      }
    ],
    "(NP类问题)**": [
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "definition": "能在多项式时间内由非确定性图灵机解决的判定问题集合。等价地，一个解能在多项式时间内被确定性图灵机验证的判定问题集合。"
      }
    ],
    "与形式化": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "**定义 2.1.1 (控制流)**：控制流描述了程序中语句、指令或函数调用的执行顺序。它决定了程序执行的路径。\n\n**形式化模型 (控制流图 - CFG)**：一个有向图 G = (N, E, entry, exit)，其中：\n\n- N 是一组基本块（顺序执行的指令序列）。\n- E 是一组边，表示基本块之间可能的控制转移。\n- entry ∈ N 是入口节点。\n- exit ∈ N 是出口节点。\n\n**定理 2.1.1 (结构化程序定理)**：任何只包含顺序、选择（if/match）和循环（loop/while/for）控制结构的程序，都可以表示为一个单入口、单出口的控制流图。"
      }
    ],
    ".1.1 (控制流)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "控制流描述了程序中语句、指令或函数调用的执行顺序。它决定了程序执行的路径。"
      }
    ],
    ".2.1 (数据流)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "数据流描述了数据在程序中产生、传递、转换和消耗的过程。它关注数据依赖关系和值的流动路径。"
      }
    ],
    ".3.1 (执行流)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "执行流（或线程流）指单个顺序执行指令的路径。在单线程程序中，只有一个执行流；在多线程程序中，可以有多个并发执行流。"
      }
    ],
    ".4.1 (工作流)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "工作流是一系列结构化的活动或任务的序列，旨在完成特定的业务目标。可以看作是控制流和数据流在更高抽象层次上的组合。"
      }
    ],
    ".1.1 (同步执行)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "同步执行模型中，操作（特别是I/O操作）会阻塞当前执行流，直到操作完成。程序按严格的顺序执行。"
      }
    ],
    ".2.1 (并发)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "并发是指系统具有同时处理多个任务的能力，这些任务的执行在时间上可以重叠。并发关注的是结构（处理多个任务），不一定需要并行（物理上同时执行）。"
      }
    ],
    ".3.1 (并行)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "并行是指系统物理上同时执行多个计算任务的能力，通常需要多核处理器。并行关注的是执行（同时计算）。"
      }
    ],
    ".4.1 (异步执行)**": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": "异步执行模型允许任务在等待I/O等阻塞操作时不阻塞执行线程，而是让出控制权，稍后在操作完成后恢复执行。关注的是非阻塞I/O和并发任务管理。"
      }
    ],
    "了原子操作和内存序 (`std": [
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "definition": ":sync::atomic::Ordering`)。"
      }
    ],
    ".1.1 (所有权转移)** 所有权转移是将数据从一个变量转移到另一个变量的操作，转移后原变量不再可用。形式上表示为": [
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "definition": "若变量 $a$ 拥有值 $v$，赋值操作 $b = a$ 后，$b$ 拥有 $v$，而 $a$ 不再有效。"
      }
    ],
    ".1.1 (Future)** Future是表示异步计算的抽象，定义为一个实现了Future特质的类型，包含Poll方法检查计算是否完成": [
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "definition": "```rust"
      }
    ],
    ".2.1 (异步状态机)** 异步状态机是编译器从async代码生成的结构，表示异步计算的不同阶段，形式上可表示为有限状态机 $(S, s_0, \\delta, F)$，其中": [
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "definition": "- $S$ 是状态集合"
      }
    ],
    ".4.1 (Stream)** Stream是异步版本的迭代器，表示可以产生多个值的异步序列": [
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "definition": "```rust"
      }
    ],
    ".1** (设计模式)": [
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "definition": "设计模式是软件设计中常见问题的一种可重用解决方案，形式化表示为四元组 $\\mathcal{P} = (\\Sigma, \\mathcal{T}, \\mathcal{R}, \\mathcal{S})$，其中 $\\Sigma$ 是签名（类型和特征）、$\\mathcal{T}$ 是类型约束、$\\mathcal{R}$ 是实现规则、$\\mathcal{S}$ 是安全保证。"
      }
    ],
    ".2** (模式变换)": [
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "definition": "给定两个模式 $\\mathcal{P}_1$ 和 $\\mathcal{P}_2$，模式变换 $\\phi: \\mathcal{P}_1 \\rightarrow \\mathcal{P}_2$ 是一个类型保持的转换。"
      }
    ],
    ".3** (模式组合)": [
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "definition": "两个模式 $\\mathcal{P}_1$ 和 $\\mathcal{P}_2$ 的组合 $\\mathcal{P}_1 \\circ \\mathcal{P}_2$ 是一个新的模式，保持了两个原始模式的属性。"
      }
    ],
    "- **定义 09.1**": [
      {
        "file": "09_error_handling\\00_index.md",
        "definition": "[错误类型](01_formal_error_system.md#错误类型定义) - 错误的类型化表示"
      }
    ],
    "Rust 模块系统可形式化为": [
      {
        "file": "10_modules\\01_formal_theory.md",
        "definition": "$$"
      }
    ],
    "lint": [
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "definition": "可见性最佳实践检查"
      }
    ],
    "- **策略模式**": [
      {
        "file": "11_frameworks\\00_index.md",
        "definition": "算法族的可替换设计"
      }
    ],
    "- **定义 11.1**": [
      {
        "file": "11_frameworks\\00_index.md",
        "definition": "[框架规范](01_formal_theory.md#框架规范定义) - 框架的形式化规范结构"
      }
    ],
    "**定义 11.1.1** (内存空间)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存空间是一个可寻址的存储区域，形式化定义为："
      }
    ],
    ".1.2** (内存区域)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存区域是内存空间的一个连续子集："
      }
    ],
    ".1.3** (所有权内存模型)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "Rust的所有权系统定义了内存的访问规则："
      }
    ],
    ".1.4** (内存安全)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存安全是指程序不会出现以下错误："
      }
    ],
    ".2.1** (内存分配器)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存分配器负责管理内存的分配和释放："
      }
    ],
    ".2.2** (分配器契约)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "分配器必须满足以下契约："
      }
    ],
    ".2.3** (栈分配)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "栈分配是自动的内存管理，基于作用域："
      }
    ],
    ".2.4** (堆分配)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "堆分配是显式的内存管理，需要手动释放："
      }
    ],
    ".2.5** (智能指针)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "智能指针是管理内存生命周期的抽象："
      }
    ],
    ".2.6** (Box)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "Box是独占所有权的智能指针："
      }
    ],
    ".3.1** (引用计数)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "引用计数跟踪指向同一内存区域的引用数量："
      }
    ],
    ".3.2** (Rc)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "Rc是单线程引用计数智能指针："
      }
    ],
    ".3.3** (Arc)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "Arc是线程安全的引用计数智能指针："
      }
    ],
    ".3.4** (垃圾回收接口)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "Rust提供与垃圾回收系统交互的接口："
      }
    ],
    "**定义 11.4.1** (内存布局)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存布局定义了类型在内存中的表示："
      }
    ],
    ".4.2** (对齐要求)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "对齐要求确保数据在正确的地址边界上："
      }
    ],
    ".4.3** (结构体布局)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "结构体的内存布局由其字段决定："
      }
    ],
    ".4.4** (零大小类型)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "零大小类型不占用内存空间："
      }
    ],
    "**定义 11.5.1** (内存模型)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存模型定义了并发访问内存的规则："
      }
    ],
    ".5.2** (数据竞争)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "数据竞争是并发访问同一内存位置的冲突："
      }
    ],
    ".5.3** (原子操作)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "原子操作是不可分割的内存操作："
      }
    ],
    ".5.4** (内存序)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存序定义了操作的可见性和顺序："
      }
    ],
    ".6.1** (内存安全证明)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存安全可以通过以下方式证明："
      }
    ],
    ".6.2** (内存泄漏)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存泄漏是指分配的内存没有被释放："
      }
    ],
    ".6.3** (验证工具)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存安全可以通过以下工具验证："
      }
    ],
    ".7.1** (分配器性能)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "分配器的性能指标包括："
      }
    ],
    ".7.2** (内存池)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存池是预分配的内存区域，用于快速分配："
      }
    ],
    ".7.3** (缓存友好)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "缓存友好的内存布局减少缓存未命中："
      }
    ],
    ".8.1** (内存管理模式)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "常见的内存管理模式包括："
      }
    ],
    ".8.2** (内存安全实践)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存安全的最佳实践包括："
      }
    ],
    ".8.3** (性能优化)": [
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "definition": "内存管理性能优化策略包括："
      }
    ],
    "Rust 内存管理系统可形式化为": [
      {
        "file": "11_memory_management\\01_formal_theory.md",
        "definition": "$$"
      }
    ],
    "- **定义 12.1**": [
      {
        "file": "12_middlewares\\00_index.md",
        "definition": "[中间件函数](01_formal_theory.md#中间件函数定义) - 高阶处理函数的抽象"
      },
      {
        "file": "12_traits\\00_index.md",
        "definition": "[特质声明](01_formal_theory.md#特质声明定义) - 类型行为的抽象接口"
      }
    ],
    "中间件 $M$ 是一个高阶函数，它接受一个处理函数 $f$ 并返回一个新的处理函数 $g$": [
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "$$M : (A \\rightarrow B) \\rightarrow (A \\rightarrow B)$$"
      }
    ],
    "中间件组合操作 $\\circ$，对于中间件 $M_1$ 和 $M_2$，有": [
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "$$(M_1 \\circ M_2)(f) = M_1(M_2(f))$$"
      }
    ],
    "在Rust中，中间件可以通过特质（Trait）形式化定义": [
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "```rust"
      }
    ],
    "了请求如何通过一系列中间件进行处理": [
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "definition": "1. **链定义**：处理链是一系列中间件的有序序列。"
      }
    ],
    "Rust Trait 系统可形式化为": [
      {
        "file": "12_traits\\01_formal_theory.md",
        "definition": "$$"
      }
    ],
    "- **方法签名**": [
      {
        "file": "12_traits\\01_formal_theory.md",
        "definition": "Trait 定义方法签名，不包含实现。"
      }
    ],
    "关联类型提供类型级抽象": [
      {
        "file": "12_traits\\02_trait_theory.md",
        "definition": "```rust"
      }
    ],
    "了服务交互和组合的数学操作，包括": [
      {
        "file": "13_microservices\\00_index.md",
        "definition": "- 服务签名定义"
      }
    ],
    "了服务间通信的契约，形式化定义为": [
      {
        "file": "13_microservices\\00_index.md",
        "definition": "$$\\text{Service}(I, O, E) = \\forall i : I. \\exists o : O. \\text{handle}(i) : \\text{Result}[O, E]$$"
      }
    ],
    "了状态转换的过程，形式化表示为": [
      {
        "file": "14_workflow\\00_index.md",
        "definition": "$$\\Delta: S \\times I \\rightarrow S \\times O$$"
      }
    ],
    "工作流系统可以用形式化语言来定义。假设": [
      {
        "file": "14_workflow\\01_formal_workflow_system.md",
        "definition": "- $W$ 表示工作流"
      }
    ],
    "未找到": [
      {
        "file": "14_workflow\\01_formal_workflow_system.md",
        "definition": "{}\", workflow_type"
      }
    ],
    "组件": [
      {
        "file": "14_workflow\\01_formal_workflow_system.md",
        "definition": "使用组件自己的优化提示"
      }
    ],
    "异步计算状态": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "- `S` 表示所有可能状态的集合"
      }
    ],
    "映射函数": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "- `φ: S → W` 将异步状态映射到工作流状态"
      }
    ],
    "工作流活动特征": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "```rust"
      }
    ],
    "映射关系": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "**定义**："
      }
    ],
    "实现**": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "基于Rust异步机制的定制工作流引擎："
      }
    ],
    "pub trait WorkflowRegistry": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "Send + Sync {"
      }
    ],
    "\\(W\\)，多次执行产生相同结果 \\(O\\)": [
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "definition": "\\[ \\forall I, W, \\, execute_1(W, I) = execute_2(W, I) = ... = O \\]"
      }
    ],
    "state_machines": [
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "definition": "RwLock<HashMap<WorkflowId, StateMachineDefinition>>,"
      }
    ],
    "petri_nets": [
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "definition": "RwLock<HashMap<WorkflowId, PetriNetDefinition>>,"
      }
    ],
    "pub fn validate(&self, workflow": [
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "definition": "&WorkflowDefinition) -> Result<(), ConversionError> {"
      }
    ],
    "fn parse(&self, input": [
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "definition": "&str) -> Result<WorkflowDefinition, ParseError>;"
      }
    ],
    "fn build_workflow(&self, ast": [
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "definition": "Ast) -> Result<WorkflowDefinition, ParseError> {"
      }
    ],
    "let definition = serde_json": [
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "definition": ":json!({"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":to_value(workflow)"
      }
    ],
    "通常依赖于JSON或YAML等通用格式，或者直接使用Rust代码。这些方法各有局限性": [
      {
        "file": "14_workflow\\04_workflow_applications.md",
        "definition": "- JSON/YAML缺乏表达力和编译时类型检查"
      }
    ],
    "使用接口定义语言(IDL)创建语言无关的活动定义": [
      {
        "file": "14_workflow\\04_workflow_applications.md",
        "definition": "```proto"
      }
    ],
    "pub input_type": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<TypeDefinition>,"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<TypeDefinition>,"
      }
    ],
    "pub output_type": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<TypeDefinition>,"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<TypeDefinition>,"
      }
    ],
    "pub event_handlers": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<EventHandlerDefinition>,"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<EventHandler>,"
      }
    ],
    "pub human_intervention_points": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<HumanInterventionPoint>,"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<HumanInterventionPoint>,"
      }
    ],
    "pub transitions": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<Transition>,"
      }
    ],
    "let definition": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "WorkflowDefinition = if file_path.extension().and_then(|e| e.to_str()) == Some(\"yaml\") ||"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "WorkflowDefinition = if file_path.extension().and_then(|e| e.to_str()) == Some(\"yaml\") ||"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "WorkflowDefinition = if file_path.extension().and_then(|e| e.to_str()) == Some(\"yaml\") ||"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "WorkflowDefinition = match source_format.as_str() {"
      }
    ],
    "验证失败": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "\");"
      }
    ],
    "let client = reqwest": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":Client::new();"
      }
    ],
    "失败": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", error[\"message\"]).into());"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      }
    ],
    "#[tonic": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":async_trait]"
      }
    ],
    "pub fields": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<FieldDefinition>,"
      }
    ],
    "field_definitions": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Vec<HumanTaskFieldDefinition>,"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<Vec<HumanTaskFieldDefinition>>,"
      }
    ],
    "pub workflow": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<Box<WorkflowDefinition>>,"
      }
    ],
    "async fn get_workflow_definition(&self, workflow_id": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "&str) -> Result<WorkflowDefinition, WorkflowError>;"
      }
    ],
    "async fn get_all_workflow_definitions(&self, page": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "usize, page_size: usize) -> Result<WorkflowDefinitionList, WorkflowError>;"
      }
    ],
    "async fn save_workflow_definition(&self, workflow": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "&WorkflowDefinition) -> Result<(), WorkflowError>;"
      }
    ],
    "async fn delete_workflow_definition(&self, workflow_id": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "&str) -> Result<(), WorkflowError>;"
      }
    ],
    "表失败": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      }
    ],
    "let row = sqlx": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":query(&format!("
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":query(&format!("
      }
    ],
    "总数失败": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "{}\", e)))?;"
      }
    ],
    "let rows = sqlx": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":query(&format!("
      }
    ],
    "sqlx": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":query(&format!("
      }
    ],
    "let result = sqlx": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":query(&format!("
      }
    ],
    "let workflow = match row.get": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":<Option<serde_json::Value>, _>(\"workflow\") {"
      }
    ],
    "workflow_definitions": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "parking_lot::RwLock<HashMap<String, HashMap<String, WorkflowDefinition>>>,"
      }
    ],
    "pub definition": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "Option<WorkflowDefinition>,"
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": "WorkflowDefinition,"
      }
    ],
    "let get_workflow = warp": [
      {
        "file": "14_workflow\\05_workflow_models.md",
        "definition": ":path!(\"workflows\" / String)"
      }
    ],
    "**区块链 (Blockchain)**": [
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "从技术上讲，区块链是一个不断增长的记录列表（称为\"区块\"），这些区块使用密码学链接在一起。每个区块通常包含前一个区块的加密哈希、时间戳和交易数据。这种链接方式使得数据难以被篡改。从更广泛的意义上说，区块链是一种分布式数据库或账本，由一个点对点网络共同维护和验证。"
      },
      {
        "file": "15_blockchain\\01_formal_blockchain_system.md",
        "definition": "从技术上讲，区块链是一个不断增长的记录列表（称为“区块”），这些区块使用密码学链接在一起。每个区块通常包含前一个区块的加密哈希、时间戳和交易数据。这种链接方式使得数据难以被篡改。从更广泛的意义上说，区块链是一种分布式数据库或账本，由一个点对点网络共同维护和验证。"
      }
    ],
    ".1** (区块链)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "区块链是一个序列 BC = (B₀, B₁, ..., Bₙ)，其中每个 Bᵢ 是一个区块，"
      }
    ],
    ".2** (区块)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "区块 B 是一个元组 B = (h_{prev}, T, nonce, h)，其中:"
      }
    ],
    ".3** (加密哈希函数)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "加密哈希函数 H: {0,1}* → {0,1}^n 应满足以下属性:"
      }
    ],
    ".4** (区块链的有向无环图模型)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "区块链可表示为有向无环图 G = (V, E)，其中:"
      }
    ],
    ".1** (单向函数)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "函数 f: X → Y 是单向的，如果:"
      }
    ],
    ".2** (抗碰撞函数)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "函数 f: X → Y 是抗碰撞的，如果找到任意两个不同输入 x₁ ≠ x₂ 使得 f(x₁) = f(x₂) 是计算上不可行的。"
      }
    ],
    ".3** (数字签名方案)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "数字签名方案 Σ 是一个三元组 (Gen, Sign, Verify):"
      }
    ],
    ".4** (默克尔树)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "默克尔树是一种二叉哈希树，叶节点包含数据块的哈希值，非叶节点包含其两个子节点的哈希值的哈希。"
      }
    ],
    ".1** (拜占庭将军问题)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "拜占庭将军问题描述了n个分布式节点中有f个节点可能是恶意的情况下，如何达成共识:"
      }
    ],
    ".2** (工作量证明)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "工作量证明是一个二元关系 (x, y)，其中 x 为问题，y 为解，满足:"
      }
    ],
    "难度目标": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "哈希值必须以特定数量的0开头"
      }
    ],
    ".3** (权益证明)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "权益证明是一种共识机制，其中节点被选为区块生产者的概率与其在系统中持有的权益成正比。"
      }
    ],
    ".4** (共识算法安全性)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "共识算法安全满足以下属性:"
      }
    ],
    ".1** (双花攻击)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "双花攻击是攻击者尝试在区块链上使用相同的资金进行两次消费的行为。"
      }
    ],
    ".2** (51%攻击)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "51%攻击是指攻击者控制超过网络一半的哈希能力，从而能够主导区块生产，潜在地实施双花或审查交易。"
      }
    ],
    ".3** (去中心化度量)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "网络的去中心化程度可以用纳什(Nakamoto)系数来度量，定义为控制系统超过50%资源(哈希能力/权益)所需的最小实体数量。"
      }
    ],
    ".1** (智能合约)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "智能合约 C 是一个状态转换系统，可表示为元组 C = (S, T, s₀)，其中:"
      }
    ],
    ".2** (智能合约执行)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "智能合约执行是一个状态序列 (s₀, s₁, ..., sₙ)，其中 sᵢ₊₁ = T(sᵢ, iᵢ)，iᵢ 是第 i 步的输入。"
      }
    ],
    ".3** (安全性属性)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "安全性属性指定系统不应该进入\"坏\"状态，可表示为逻辑断言 ∀s ∈ Reach(C, s₀): φ(s)，其中 Reach(C, s₀) 是从 s₀ 可达的状态集，φ 是状态谓词。"
      }
    ],
    ".4** (活性属性)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "活性属性指定\"好\"事件最终会发生，可表示为时态逻辑公式 □(p → ◇q)，表示如果 p 成立，则最终 q 也会成立。"
      }
    ],
    ".5** (霍尔三元组)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "霍尔三元组 {P} C {Q} 表示如果执行前谓词 P 成立，则执行 C 后谓词 Q 成立。"
      }
    ],
    ".6** (符号执行)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "符号执行是一种程序分析技术，它通过使用符号值而不是具体值来执行程序，从而探索多个执行路径。"
      }
    ],
    ".1** (全局状态)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "区块链的全局状态 S 是所有账户状态的映射，S: A → Σ，其中 A 是账户地址集合，Σ 是可能的账户状态集合。"
      }
    ],
    ".2** (状态转换函数)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "状态转换函数 Apply: S × T → S 接受当前状态和交易，并产生新状态。"
      }
    ],
    ".3** (区块链分叉)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "分叉是区块链的两个或多个不同版本，它们共享一个公共前缀。"
      }
    ],
    ".4** (最长链规则)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "最长链规则指定节点应该选择工作量最大的链作为规范链。"
      }
    ],
    ".5** (最终一致性)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "交易 Tx 在区块高度 h 达到 k-确认时被认为是最终的，如果该交易被包含在区块 Bₕ 中，且有至少 k 个后续区块。"
      }
    ],
    ".1** (线性时态逻辑LTL)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "线性时态逻辑是一种形式化语言，可以表达随时间变化的属性，包括以下操作符:"
      }
    ],
    ".2** (模型检验)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "模型检验是一种自动验证系统是否满足形式化规约的技术，通过穷尽搜索可能的系统状态。"
      }
    ],
    ".3** (可验证计算)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "可验证计算是一种允许计算执行者向验证者证明计算结果正确性的技术，无需验证者重复整个计算。"
      }
    ],
    ".4** (零知识证明)": [
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "definition": "零知识证明是一种协议，允许证明者向验证者证明陈述的真实性，而不泄露任何额外信息。"
      }
    ],
    ".1 (全局状态 S)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "区块链系统的全局状态 \\(S\\) 是一个由系统中所有相关数据（如账户余额、合约代码和存储）构成的值。在任意时刻 \\(t\\)，系统处于某个特定的状态 \\(s_t \\in S\\)。"
      }
    ],
    ".2 (交易 Tx)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "一个交易 \\(tx \\in Tx\\) 是对系统状态提出更改请求的原子事件。它通常包含发起者、接收者、操作类型、数据以及发起者的数字签名。"
      }
    ],
    ".3 (交易有效性谓词 isValidTx)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "\\(isValidTx(tx, s) \\rightarrow \\{True, False\\}\\) 是一个布尔函数，用于判断交易 \\(tx\\) 在当前状态 \\(s\\) 下是否有效（例如，签名是否正确、发起者是否有足够余额）。"
      }
    ],
    ".4 (节点 N)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "系统由一组节点 \\(N = \\{n_1, n_2, ...\\}\\) 构成，每个节点 \\(n_i\\) 维护一个对全局状态 \\(S\\) 的本地副本 \\(s_i\\)。节点通过网络进行通信。"
      }
    ],
    ".1 (交易结构 Tx)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "一个交易 \\(tx\\) 可以形式化地定义为一个元组："
      }
    ],
    ".2 (交易有效性条件 isValidTx)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "\\(isValidTx(tx, s)\\) 为 \\(True\\) 当且仅当满足以下条件："
      }
    ],
    ".3 (区块结构 B)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "一个区块 \\(B\\) 是一个包含交易集合和元数据的结构，通常形式化为："
      }
    ],
    ".4 (区块有效性谓词 isValidBlock)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "\\(isValidBlock(B, B_{prev}, s_{prev}) \\rightarrow \\{True, False\\}\\) 是一个布尔函数，判断区块 \\(B\\) 是否有效，需要满足："
      }
    ],
    ".5 (区块链 L)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "区块链 \\(L\\) 是一个由区块构成的有序序列："
      }
    ],
    ".6 (链有效性规则 isValidChain)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "一个区块链 \\(L = \\langle B_0, ..., B_k \\rangle\\) 是有效的，当且仅当："
      }
    ],
    ".1 (状态转换函数 apply)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "\\(apply(s, tx) \\rightarrow s'\\) 是一个函数，它接受当前状态 \\(s\\) 和一个有效交易 \\(tx\\)，并计算出应用该交易后的新状态 \\(s'\\)。前提是 \\(isValidTx(tx, s)\\)。"
      }
    ],
    ".2 (区块状态转换函数 applyBlock)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "\\(applyBlock(s, B) \\rightarrow s'\\) 是一个函数，它接受状态 \\(s\\) 和一个有效区块 \\(B\\)，并计算出应用该区块中所有交易后的最终状态 \\(s'\\)。"
      }
    ],
    ".3 (区块链状态)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "对于一个有效的区块链 \\(L = \\langle B_0, ..., B_k \\rangle\\)，其在区块 \\(k\\) 之后的状态 \\(S_k\\) 定义为："
      }
    ],
    ".4 (一致性)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "系统达到一致性是指对于所有诚实节点 \\(n_i, n_j\\)，它们的本地状态相同，即 \\(s_i = s_j\\)。"
      }
    ],
    "**定义 5.1 (分布式共识问题)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "在一个可能存在故障（崩溃、拜占庭）节点的分布式系统中，所有非故障节点需要就一个提议的值（在区块链中是下一个有效区块）达成一致决定。需要满足以下属性："
      }
    ],
    ".2 (PoW 谜题)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "给定前一区块哈希 \\(prev\\_hash\\)、交易集 \\(Txs\\) 和难度目标 \\(D\\)，找到一个随机数 \\(nonce\\) 使得："
      }
    ],
    ".3 (PoW 区块有效性增强)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "`isValidBlock` 谓词中增加条件 \\(Hash(B.Header) < B.Header.difficulty\\)。"
      }
    ],
    ".4 (PoS 提议者/验证者选择)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "区块提议者或验证者根据其持有的权益（代币数量、币龄等）被（伪）随机地选择出来。"
      }
    ],
    ".5 (PoS 区块有效性增强)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "`isValidBlock` 谓词中增加条件，要求区块 \\(B\\) 必须由当前轮次/槽位（slot）的合法提议者签名，并且可能需要一组验证者的签名确认（attestation）。"
      }
    ],
    ".6 (BFT 共识)**": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "BFT 算法旨在容忍一部分节点（通常少于 1/3）可能任意行为（拜占庭故障）的情况下达成共识。例如 PBFT。"
      }
    ],
    "│   │   ├── 结构": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "(sender, recipient, value, nonce, data, sig)"
      },
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "(Header, Body={tx...})"
      }
    ],
    "│       ├── 结构": [
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "definition": "<B_0, ..., B_k>"
      }
    ],
    "`apply_block_body(T, Σ)` 为顺序应用事务 `tx₁` 到 `tx_k` 后的最终状态": [
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "definition": "- `Σ₁ = apply_tx(tx₁, Σ)`"
      }
    ],
    "的结构": [
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "definition": "创世块是基础，后续块通过引用前一个块的哈希并满足有效性谓词来扩展链。"
      }
    ],
    "状态转换请求 (tx": [
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "definition": "Σ → Σ')"
      }
    ],
    "- I": [
      {
        "file": "16_webassembly\\01_webassembly_theory.md",
        "definition": "导入接口"
      }
    ],
    "为状态转换规则": [
      {
        "file": "16_webassembly\\01_webassembly_theory.md",
        "definition": "(s, f, l, g, m) →ᵢ (s', f', l', g', m')"
      }
    ],
    "和实现组件**": [
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": "wit文件 (my-component.wit):"
      }
    ],
    "示例**": [
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": "```wit"
      }
    ],
    "process-data": [
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": "func(input: data-chunk, options: processing-options) -> process-result;"
      }
    ],
    "package example": [
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": "media-system@1.0.0;"
      }
    ],
    "#[wit_bindgen": [
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": ":interface]"
      },
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "definition": ":contract]"
      }
    ],
    "的接口进行交互，这些接口构成了模型之间的映射": [
      {
        "file": "17_iot\\01_formal_iot_system.md",
        "definition": "1. **寄存器访问层(PAC)**：将物理寄存器映射为Rust类型和操作"
      }
    ],
    "资源规范，模型(struct)实现资源管理": [
      {
        "file": "17_iot\\01_formal_iot_system.md",
        "definition": "```rust"
      }
    ],
    "#[embassy": [
      {
        "file": "17_iot\\01_iot_theory.md",
        "definition": ":task]"
      }
    ],
    "模糊": [
      {
        "file": "17_iot\\02_iot_theory.md",
        "definition": "** 现实项目中，层与层之间的界限往往是模糊的。例如，某些协议处理可能需要直接与 HAL 甚至 PAC 交互以获得最佳性能或硬件支持，这打破了清晰的分层模型。"
      }
    ],
    "了模型的解释框架，形式化表示为": [
      {
        "file": "18_model\\00_index.md",
        "definition": "$$\\text{Semantics}(\\mathcal{M}) = \\{\\mathcal{I} | \\mathcal{I} \\models \\mathcal{M}\\}$$"
      }
    ],
    "- **定义 19.1.1**": [
      {
        "file": "19_advanced_features\\00_index.md",
        "definition": "[GAT定义](01_advanced_type_system.md#191-gat与高阶类型系统) - Generic Associated Types"
      }
    ],
    ".2.3**": [
      {
        "file": "19_advanced_features\\00_index.md",
        "definition": "[Const Generics](01_advanced_type_system.md#192-const-generics与类型表达力) - 常量泛型参数"
      }
    ],
    ".3.1**": [
      {
        "file": "19_advanced_features\\00_index.md",
        "definition": "[Async Traits](01_advanced_type_system.md#193-async-trait与异步类型系统) - 异步特质定义"
      }
    ],
    "(异步trait语义)**": [
      {
        "file": "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "∃ 时间点t, ∃ 线程i,j (i≠j)": [
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "definition": "access(i,memory,t) ∧ access(j,memory,t) ∧"
      }
    ],
    "线程到达时间序列": [
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "definition": "T = {t₁, t₂, ..., tₙ}"
      }
    ],
    "访问完成时间序列": [
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "definition": "C = {c₁, c₂, ..., cₙ}"
      }
    ],
    "(Expect属性代数)**": [
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "行为风险": [
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "definition": "**传统问题**:"
      },
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "definition": "编译器优化依赖"
      }
    ],
    "**定义1 (地址计算函数)**": [
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "设trait hierarchy": [
      {
        "file": "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
        "definition": "T₁ <: T₂ <: ... <: Tₙ"
      }
    ],
    "(Trait子类型关系)**": [
      {
        "file": "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "**定义1 (标签化生命周期空间)**": [
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "**定义1 (C字符串安全转换)**": [
      {
        "file": "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "**定义1 (编译时表达式空间)**": [
      {
        "file": "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
        "definition": "```mathematical"
      }
    ],
    "find_references_ms": [
      {
        "file": "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
        "definition": "85,     // 查找引用"
      }
    ],
    "了Rust应用程序的整体结构和组件交互模式，包括": [
      {
        "file": "21_application_domains\\00_index.md",
        "definition": "- 分层架构"
      }
    ],
    "以下关键概念": [
      {
        "file": "23_security_verification\\01_formal_theory.md",
        "definition": "```rust"
      }
    ],
    "我们定义以下维度来比较不同的编程语言": [
      {
        "file": "24_cross_language_comparison\\01_formal_theory.md",
        "definition": "1. **类型系统**:"
      }
    ],
    ". **演化适应原则**": [
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "definition": "工具链随需求和技术演化"
      }
    ],
    "为输入类型、输出类型和副作用的三元组": [
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "definition": "$$Interface(C) = (Input, Output, SideEffects)$$"
      }
    ],
    "为它们的输出和输入兼容": [
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "definition": "$$Cooperate(T_1, T_2) \\iff Output(T_1) \\subseteq Input(T_2)$$"
      }
    ],
    "组件间交互的规范": [
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "definition": "$$Protocol = (Messages, Sequence, ErrorHandling)$$"
      }
    ],
    "为它在不同平台上的行为一致性": [
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "definition": "$$CrossPlatform(T) = \\min_{p_i, p_j \\in Platforms} Similarity(Behavior(T, p_i), Behavior(T, p_j))$$"
      }
    ],
    ".6）分析": [
      {
        "file": "27_ecosystem_architecture\\02_case_studies.md",
        "definition": "1. **技术扩散**: 创新特性从一个框架扩散到其他框架"
      }
    ],
    "了在外部事件 $e \\in E$ 影响下，系统如何从一个状态转移到另一个状态": [
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "definition": "$$S_{t+1} = T(S_t, e_t)$$"
      }
    ],
    "的转移规则保持生态系统约束，即": [
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "definition": "$$\\forall S \\in \\Omega, \\forall e \\in E, T(S, e) \\in \\Omega$$"
      }
    ],
    "为单位时间内新增采纳者的比例": [
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "definition": "$$v_L(t) = \\frac{dA_L(t)}{dt}$$"
      }
    ],
    "- **定义 28.1**": [
      {
        "file": "28_advanced_type_features\\00_index.md",
        "definition": "[Higher-Kinded Types](01_higher_kinded_types.md#高阶类型定义) - 类型构造器抽象"
      }
    ],
    "了一个映射": [
      {
        "file": "28_advanced_type_features\\02_associated_types.md",
        "definition": "$$\\text{Assoc}_{\\text{Tr}}(T) \\mapsto U$$"
      }
    ],
    "中声明": [
      {
        "file": "28_advanced_type_features\\02_associated_types.md",
        "definition": "```rust"
      }
    ],
    "了一个类型级函数，它接受类型参数并返回一个类型": [
      {
        "file": "28_advanced_type_features\\02_associated_types.md",
        "definition": "$$\\text{Iter}_{\\text{Collection}}(T, 'a) \\mapsto U_{T, 'a}$$"
      }
    ],
    "通用集合接口变得更加简洁": [
      {
        "file": "28_advanced_type_features\\02_associated_types.md",
        "definition": "```rust"
      }
    ],
    "类型族，这是类型级函数的一种形式": [
      {
        "file": "28_advanced_type_features\\03_type_level_programming.md",
        "definition": "```rust"
      }
    ],
    "状态机，在编译时保证状态转换的正确性": [
      {
        "file": "28_advanced_type_features\\03_type_level_programming.md",
        "definition": "```rust"
      }
    ],
    "零大小类型是在编译时存在但在运行时不占用内存的类型。形式上，类型 $T$ 是零大小类型，当且仅当": [
      {
        "file": "28_advanced_type_features\\04_phantom_and_zero_sized_types.md",
        "definition": "$$\\text{sizeof}(T) = 0$$"
      }
    ],
    "包括以下条件": [
      {
        "file": "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md",
        "definition": "- 所有方法都是分发的(dispatchable)："
      }
    ],
    "对于参数化类型构造器 $F<T>$，其变型描述了当参数 $T$ 的子类型关系变化时，$F<T>$ 的子类型关系如何变化。有三种基本变型": [
      {
        "file": "28_advanced_type_features\\06_variance_and_subtyping.md",
        "definition": "1. **协变(Covariant)**: 保持子类型关系同向"
      }
    ],
    "$S <": [
      {
        "file": "28_advanced_type_features\\06_variance_and_subtyping.md",
        "definition": "T \\Rightarrow F<S> <: F<T>$"
      },
      {
        "file": "28_advanced_type_features\\06_variance_and_subtyping.md",
        "definition": "T \\Rightarrow F<T> <: F<S>$"
      },
      {
        "file": "28_advanced_type_features\\06_variance_and_subtyping.md",
        "definition": "T \\land S \\neq T \\Rightarrow F<S> \\not<: F<T> \\land F<T> \\not<: F<S>$"
      }
    ],
    "自动推导变型": [
      {
        "file": "28_advanced_type_features\\06_variance_and_subtyping.md",
        "definition": "```rust"
      }
    ],
    "的 GAT $A<P>$": [
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "definition": "- $A$ 必须在所有 $Tr$ 的实现中提供具体类型"
      }
    ],
    "了一个生命周期参数索引的类型族": [
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "definition": "$$A : \\text{Lifetime} \\rightarrow \\text{Type}$$"
      }
    ],
    "在 Rust 中定义 GAT": [
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "definition": "```rust"
      }
    ],
    "更灵活的迭代器抽象成为可能": [
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "definition": "```rust"
      }
    ],
    "一致性": [
      {
        "file": "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md",
        "definition": "100%"
      }
    ],
    ". **符号一致性检查器**": [
      {
        "file": "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md",
        "definition": "检查符号使用一致性"
      }
    ],
    "**白银级标准**": [
      {
        "file": "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md",
        "definition": "- 理论一致性100%"
      }
    ],
    "{{模块编号}}.1**": [
      {
        "file": "RESTRUCTURE_WORKING\\standard_index_template.md",
        "definition": "[{{定义名称}}]({{文件名}}#{{锚点}}) - {{定义简述}}"
      }
    ],
    "{{模块编号}}.2**": [
      {
        "file": "RESTRUCTURE_WORKING\\standard_index_template.md",
        "definition": "[{{定义名称}}]({{文件名}}#{{锚点}}) - {{定义简述}}"
      }
    ],
    "{{模块编号}}.3**": [
      {
        "file": "RESTRUCTURE_WORKING\\standard_index_template.md",
        "definition": "[{{定义名称}}]({{文件名}}#{{锚点}}) - {{定义简述}}"
      }
    ],
    "{{模块编号}}.4**": [
      {
        "file": "RESTRUCTURE_WORKING\\standard_index_template.md",
        "definition": "[{{定义名称}}]({{文件名}}#{{锚点}}) - {{定义简述}}"
      }
    ],
    "{{模块编号}}.5**": [
      {
        "file": "RESTRUCTURE_WORKING\\standard_index_template.md",
        "definition": "[{{定义名称}}]({{文件名}}#{{锚点}}) - {{定义简述}}"
      }
    ],
    "整合**": [
      {
        "file": "ARCHIVE\\versions\\content_restructuring_plan_v1.md",
        "definition": "- 收集所有形式化定义"
      }
    ],
    "应包含": [
      {
        "file": "ARCHIVE\\versions\\content_restructuring_plan_v1.md",
        "definition": "1. **非形式化描述**：用自然语言解释概念"
      }
    ],
    "一致性**": [
      {
        "file": "ARCHIVE\\versions\\content_restructuring_plan_v1.md",
        "definition": "确保同一概念在不同文件中的定义一致"
      }
    ]
  },
  "mathematical_symbols": {
    "forall": [
      {
        "file": "concept_dictionary.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "fixed_temporary.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_ownership_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\03_lifetime_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\04_mutability_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\05_variable_analysis.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\06_ownership_formal_proofs.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_ownership_borrowing\\09_formal_theory_and_proof.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_theory_foundations\\03_separation_logic.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "variants": [
          "\\forall",
          "∀"
        ]
      },
      {
        "file": "02_type_system\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "variants": [
          "\\forall",
          "∀"
        ]
      },
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "02_type_system\\02_lifetime_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "02_type_system\\03_type_inference.md",
        "variants": [
          "\\forall",
          "∀"
        ]
      },
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_control_flow\\02_pattern_matching_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_control_flow\\03_control_flow_optimization.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_type_system_core\\03_type_constraints.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "03_type_system_core\\04_variance.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "04_generics\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "04_generics\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "04_generics\\02_generic_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "05_concurrency\\04_concurrency_applications.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "05_formal_verification\\02_type_safety_proofs.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "06_async_await\\01_async_programming_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "06_async_await\\02_async_theory.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "07_process_management\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "07_process_management\\02_task_management.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "07_process_management\\03_io_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_sorting_algorithms.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\forall",
          "∀"
        ]
      },
      {
        "file": "09_design_patterns\\02_behavioral_patterns.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "09_error_handling\\02_error_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "11_frameworks\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "11_memory_management\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "12_traits\\02_trait_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "13_microservices\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "13_microservices\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "14_workflow\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "15_blockchain\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "15_blockchain\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "variants": [
          "\\forall",
          "∀"
        ]
      },
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "16_webassembly\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "17_iot\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "17_iot\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "17_iot\\01_iot_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "18_model\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "18_model\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "19_advanced_features\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "19_advanced_features\\01_advanced_type_system.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "19_advanced_language_features\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "20_theoretical_perspectives\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
        "variants": [
          "∀"
        ]
      },
      {
        "file": "21_application_domains\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "21_application_domains\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "22_performance_optimization\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "22_performance_optimization\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "23_security_verification\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "24_cross_language_comparison\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "25_teaching_learning\\01_formal_theory.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "28_advanced_type_features\\00_index.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "28_advanced_type_features\\04_phantom_and_zero_sized_types.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "28_advanced_type_features\\06_variance_and_subtyping.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "variants": [
          "\\forall"
        ]
      },
      {
        "file": "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md",
        "variants": [
          "∀"
        ]
      }
    ],
    "exists": [
      {
        "file": "concept_dictionary.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "cross_reference_implementation_report.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_ownership_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "01_ownership_borrowing\\05_variable_analysis.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "01_ownership_borrowing\\06_ownership_formal_proofs.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "01_theory_foundations\\03_separation_logic.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "02_type_system\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_control_flow\\02_pattern_matching_system.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "03_type_system_core\\04_variance.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "06_async_await\\02_async_theory.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\exists",
          "∃"
        ]
      },
      {
        "file": "09_design_patterns\\02_behavioral_patterns.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "11_frameworks\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "11_memory_management\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "13_microservices\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "13_microservices\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "14_workflow\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "15_blockchain\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "15_blockchain\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "17_iot\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "17_iot\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "18_model\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "19_advanced_language_features\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "19_advanced_language_features\\06_compatibility_and_lints.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "20_theoretical_perspectives\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
        "variants": [
          "∃"
        ]
      },
      {
        "file": "21_application_domains\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "21_application_domains\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "22_performance_optimization\\00_index.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "24_cross_language_comparison\\01_formal_theory.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "variants": [
          "\\exists"
        ]
      },
      {
        "file": "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md",
        "variants": [
          "\\exists"
        ]
      }
    ],
    "in": [
      {
        "file": "concept_dictionary.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "content_consistency_checklist.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "fixed_temporary.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_ownership_rules.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_ownership_borrowing\\03_lifetime_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_theory_foundations\\01_linear_affine_types.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_theory_foundations\\04_algebraic_data_types.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "02_type_system\\03_type_inference.md",
        "variants": [
          "∈",
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\02_pattern_matching_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\04_loop_control.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_type_system_core\\03_type_constraints.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "03_type_system_core\\06_type_system_formal_proofs.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "04_generics\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "05_concurrency\\04_concurrency_applications.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "05_formal_verification\\01_verification_foundations.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "05_formal_verification\\02_type_safety_proofs.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "06_async_await\\01_async_programming_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "06_async_await\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "06_async_await\\02_async_theory.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "07_process_management\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "07_process_management\\02_task_management.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "07_process_management\\03_io_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_sorting_algorithms.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "09_design_patterns\\02_behavioral_patterns.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "10_modules\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "11_frameworks\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "12_traits\\02_trait_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "13_microservices\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "13_microservices\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "14_workflow\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "15_blockchain\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "15_blockchain\\03_blockchain_implementation.md",
        "variants": [
          "\\in",
          "∈"
        ]
      },
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "16_webassembly\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "16_webassembly\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "17_iot\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "17_iot\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "17_iot\\01_iot_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "18_model\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "18_model\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "19_advanced_language_features\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "19_advanced_language_features\\05_stabilized_apis_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "19_advanced_language_features\\06_compatibility_and_lints.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_theoretical_perspectives\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
        "variants": [
          "∈"
        ]
      },
      {
        "file": "21_application_domains\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "21_application_domains\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "22_performance_optimization\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "22_performance_optimization\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "23_security_verification\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "24_cross_language_comparison\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "24_cross_language_comparison\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "25_teaching_learning\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "25_teaching_learning\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "26_toolchain_ecosystem\\00_index.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "27_ecosystem_architecture\\01_formal_theory.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "28_advanced_type_features\\05_trait_objects_and_dynamic_dispatch.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "variants": [
          "\\in"
        ]
      },
      {
        "file": "28_advanced_type_features\\08_advanced_type_patterns.md",
        "variants": [
          "\\in"
        ]
      }
    ],
    "subset": [
      {
        "file": "concept_dictionary.md",
        "variants": [
          "\\subset",
          "\\subseteq"
        ]
      },
      {
        "file": "01_ownership_borrowing\\00_index.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_formal_ownership_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_ownership_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "01_ownership_borrowing\\04_lifetime_system.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "01_ownership_borrowing\\06_theorems.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "01_ownership_borrowing\\07_case_and_comparison.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "01_ownership_borrowing\\09_formal_theory_and_proof.md",
        "variants": [
          "\\subset",
          "\\subseteq"
        ]
      },
      {
        "file": "01_theory_foundations\\00_index.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "01_theory_foundations\\02_region_effect_systems.md",
        "variants": [
          "⊆",
          "\\subseteq"
        ]
      },
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "02_type_system\\02_lifetime_system.md",
        "variants": [
          "⊆",
          "\\subseteq"
        ]
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "02_type_system\\03_type_inference.md",
        "variants": [
          "⊆",
          "\\subseteq"
        ]
      },
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "04_generics\\01_formal_generics.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "04_generics\\02_generic_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "04_generics\\02_trait_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "variants": [
          "⊆",
          "⊂"
        ]
      },
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "variants": [
          "\\subset"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "10_modules\\00_index.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "10_modules\\02_module_resolution_theory.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "11_memory_management\\01_formal_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "14_workflow\\01_workflow_theory.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "16_webassembly\\01_formal_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "19_advanced_language_features\\04_compiler_dwarf_stabilization.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "⊂"
        ]
      },
      {
        "file": "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
        "variants": [
          "⊆"
        ]
      },
      {
        "file": "23_security_verification\\01_formal_theory.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "variants": [
          "\\subset",
          "\\subseteq"
        ]
      },
      {
        "file": "27_ecosystem_architecture\\01_formal_theory.md",
        "variants": [
          "\\subset",
          "\\subseteq"
        ]
      },
      {
        "file": "27_ecosystem_architecture\\03_evolution_model.md",
        "variants": [
          "\\subset"
        ]
      },
      {
        "file": "28_advanced_type_features\\07_generic_associated_types.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "ARCHIVE\\versions\\content_analysis_report_v1.md",
        "variants": [
          "\\subseteq"
        ]
      },
      {
        "file": "ARCHIVE\\versions\\content_restructuring_plan_v1.md",
        "variants": [
          "\\subseteq"
        ]
      }
    ],
    "union": [
      {
        "file": "concept_dictionary.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "01_theory_foundations\\02_region_effect_systems.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "01_theory_foundations\\03_separation_logic.md",
        "variants": [
          "\\uplus"
        ]
      },
      {
        "file": "01_theory_foundations\\04_algebraic_data_types.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "02_type_system\\03_type_inference.md",
        "variants": [
          "\\cup",
          "∪"
        ]
      },
      {
        "file": "03_control_flow\\02_pattern_matching_system.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "06_async_await\\01_formal_theory.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "07_process_management\\01_formal_theory.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "07_process_management\\03_io_system.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "11_memory_management\\01_formal_memory_management_system.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "14_workflow\\01_workflow_theory.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
        "variants": [
          "∪"
        ]
      },
      {
        "file": "22_performance_optimization\\01_formal_theory.md",
        "variants": [
          "\\cup"
        ]
      },
      {
        "file": "26_toolchain_ecosystem\\01_formal_theory.md",
        "variants": [
          "\\cup"
        ]
      }
    ],
    "intersection": [
      {
        "file": "concept_dictionary.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "01_ownership_borrowing\\01_ownership_theory.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "02_type_system\\02_lifetime_system.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "variants": [
          "∩"
        ]
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "variants": [
          "∩"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "11_frameworks\\01_formal_theory.md",
        "variants": [
          "\\cap"
        ]
      },
      {
        "file": "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
        "variants": [
          "∩"
        ]
      },
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "variants": [
          "∩"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "∩"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "∩"
        ]
      },
      {
        "file": "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
        "variants": [
          "∩"
        ]
      }
    ],
    "implies": [
      {
        "file": "01_ownership_borrowing\\01_ownership_theory.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\02_borrowing_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "01_ownership_borrowing\\02_examples_and_applications.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "01_ownership_borrowing\\02_ownership_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "01_ownership_borrowing\\03_borrowing_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "01_ownership_borrowing\\03_lifetime_system.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\04_memory_management.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\04_mutability_theory.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\05_variable_analysis.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\06_move_semantics.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\07_case_and_comparison.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_ownership_borrowing\\07_examples.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "01_ownership_borrowing\\09_formal_theory_and_proof.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_theory_foundations\\03_separation_logic.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "01_theory_foundations\\04_algebraic_data_types.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "02_type_system\\01_type_system_foundations.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "02_type_system\\02_lifetime_system.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "02_type_system\\02_type_inference.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "02_type_system\\03_category_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "02_type_system\\03_trait_system.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "02_type_system\\05_examples.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\02_conditional_expressions.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_analysis.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\02_pattern_matching_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\03_conditional_flow.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\03_control_flow_optimization.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\03_iterative_constructs.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\04_examples.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\04_functions_and_closures.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\05_error_handling_as_control_flow.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\05_function_control.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\06_exception_handling.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_control_flow\\FAQ.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_type_system_core\\01_basic_type_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_type_system_core\\02_trait_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_type_system_core\\03_type_constraints.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "03_type_system_core\\04_variance.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\01_formal_generic_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\02_generic_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\02_type_parameters.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\03_associated_types.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\03_generic_implementation.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\04_constraint_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "04_generics\\05_generic_programming.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "05_concurrency\\01_formal_concurrency_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "05_concurrency\\02_thread_model.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "05_concurrency\\03_async_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "05_concurrency\\03_concurrency_implementation.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "05_concurrency\\04_concurrency_applications.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "05_concurrency\\05_concurrency_models.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "05_formal_verification\\02_type_safety_proofs.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "06_async_await\\01_async_programming_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "06_async_await\\01_formal_async_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "06_async_await\\02_async_theory.md",
        "variants": [
          "⇒",
          "=>"
        ]
      },
      {
        "file": "06_theory_practice\\01_theory_application_framework.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "06_theory_practice\\02_practical_verification_cases.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "07_macro_system\\01_formal_macro_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "07_macro_system\\02_declarative_macros.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "07_macro_system\\03_procedural_macros.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "07_process_management\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "07_process_management\\02_task_management.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "07_process_management\\03_io_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_algorithms_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_algorithm_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_theory.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "08_algorithms\\02_algorithm_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\02_formal_data_structures.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\03_algorithm_implementation.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\04_algorithm_applications.md",
        "variants": [
          "⇒",
          "=>"
        ]
      },
      {
        "file": "08_algorithms\\05_algorithm_models.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "09_design_patterns\\02_behavioral_patterns.md",
        "variants": [
          "⇒",
          "=>"
        ]
      },
      {
        "file": "09_error_handling\\01_formal_error_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "09_error_handling\\02_error_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "09_error_handling\\03_error_implementation.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "10_modules\\02_module_resolution_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "12_middlewares\\02_middleware_composition_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "12_traits\\02_trait_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "13_microservices\\02_service_communication_patterns.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "14_workflow\\01_formal_workflow_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "14_workflow\\01_workflow_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "14_workflow\\03_workflow_implementation.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "14_workflow\\04_workflow_applications.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "14_workflow\\05_workflow_models.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "15_blockchain\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "15_blockchain\\02_blockchain_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "15_blockchain\\04_blockchain_applications.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "16_webassembly\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "16_webassembly\\01_webassembly_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "16_webassembly\\02_webassembly_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "17_iot\\01_formal_iot_system.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "17_iot\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "17_iot\\01_iot_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "18_model\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "18_model\\01_model_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_features\\01_advanced_type_system.md",
        "variants": [
          "\\implies",
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\01_let_chains_analysis.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\02_cargo_cache_management.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\03_naked_functions_analysis.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\04_compiler_dwarf_stabilization.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\05_stabilized_apis_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\06_compatibility_and_lints.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\07_rustdoc_cargo_improvements.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\08_let_chains_extended_features.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "19_advanced_language_features\\09_cargo_workspace_optimizations.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_theoretical_perspectives\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_theoretical_perspectives\\01_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\01_async_fn_in_traits_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\02_lazy_cell_lazy_lock_analysis.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\03_rust_175_async_fn_traits_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\04_rust_180_lazy_cell_lock_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\05_rust_181_expect_attribute_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\06_rust_182_raw_pointer_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\07_rust_184_trait_upcasting_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\08_rust_178_async_improvements_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\10_rust_177_c_string_literals_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\11_rust_179_inline_const_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\13_rust_180_lazy_cell_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\16_rust_186_cargo_improvements_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\17_rust_187_stdlib_optimizations_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\18_rust_173_safe_transmute_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\19_rust_188_macro_improvements_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\20_rust_189_async_ecosystem_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\22_rust_191_ecosystem_integration_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "20_version_features_analysis\\23_rust_192_future_roadmap_comprehensive.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "21_application_domains\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "22_performance_optimization\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "23_security_verification\\01_formal_theory.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "28_advanced_type_features\\01_higher_kinded_types.md",
        "variants": [
          "=>"
        ]
      },
      {
        "file": "28_advanced_type_features\\04_phantom_and_zero_sized_types.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "RESTRUCTURE_WORKING\\phase4_quality_verification_plan.md",
        "variants": [
          "⇒"
        ]
      },
      {
        "file": "ARCHIVE\\versions\\content_analysis_report_v1.md",
        "variants": [
          "\\implies"
        ]
      },
      {
        "file": "ARCHIVE\\versions\\content_restructuring_plan_v1.md",
        "variants": [
          "\\implies"
        ]
      }
    ],
    "equiv": [
      {
        "file": "01_theory_foundations\\03_separation_logic.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "02_type_system\\01_formal_type_system.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "03_control_flow\\01_control_flow_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "03_control_flow\\01_formal_control_flow_system.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "03_type_system_core\\00_index.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "05_concurrency\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "05_formal_verification\\02_type_safety_proofs.md",
        "variants": [
          "⇔"
        ]
      },
      {
        "file": "06_async_await\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "07_process_management\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "08_algorithms\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "09_design_patterns\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "09_design_patterns\\02_behavioral_patterns.md",
        "variants": [
          "⇔"
        ]
      },
      {
        "file": "10_modules\\03_visibility_and_privacy.md",
        "variants": [
          "⇔"
        ]
      },
      {
        "file": "12_middlewares\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "14_workflow\\02_workflow_theory.md",
        "variants": [
          "\\equiv"
        ]
      },
      {
        "file": "16_webassembly\\01_formal_theory.md",
        "variants": [
          "\\equiv"
        ]
      }
    ],
    "bottom": [
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "variants": [
          "\\bot"
        ]
      },
      {
        "file": "03_control_flow\\00_index.md",
        "variants": [
          "\\bot"
        ]
      },
      {
        "file": "03_control_flow\\02_control_flow_theory.md",
        "variants": [
          "\\bot"
        ]
      },
      {
        "file": "06_async_await\\00_index.md",
        "variants": [
          "\\bot"
        ]
      },
      {
        "file": "20_version_features_analysis\\09_rust_183_raw_lifetime_labels_comprehensive.md",
        "variants": [
          "⊥"
        ]
      }
    ],
    "top": [
      {
        "file": "01_theory_foundations\\06_type_theory_foundations.md",
        "variants": [
          "\\top"
        ]
      },
      {
        "file": "03_control_flow\\00_index.md",
        "variants": [
          "\\top"
        ]
      },
      {
        "file": "06_async_await\\00_index.md",
        "variants": [
          "\\top"
        ]
      }
    ]
  },
  "errors": [
    "无法读取文件 main_comprehensive_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 01_ownership_borrowing\\05_memory_safety.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 03_control_flow_and_functions\\02_function_formal_semantics.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\00_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\02_memory_safety_proofs.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 12_traits\\03_trait_coherence_theory.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 19_advanced_language_features\\00_rust_1_88_0_comprehensive_analysis.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 20_version_features_analysis\\14_rust_185_nested_impl_traits_comprehensive.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_PLAN\\02_restructure_execution_plan.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\batch_index_improvement_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\final_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\module_01_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase2_quality_standardization_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase3_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase9_link_optimization_completion.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\restructure_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\restructure_log.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 main_comprehensive_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 01_ownership_borrowing\\05_memory_safety.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 03_control_flow_and_functions\\02_function_formal_semantics.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\00_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\02_memory_safety_proofs.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 12_traits\\03_trait_coherence_theory.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 19_advanced_language_features\\00_rust_1_88_0_comprehensive_analysis.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 20_version_features_analysis\\14_rust_185_nested_impl_traits_comprehensive.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_PLAN\\02_restructure_execution_plan.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\batch_index_improvement_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\final_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\module_01_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase2_quality_standardization_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase3_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase9_link_optimization_completion.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\restructure_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\restructure_log.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 main_comprehensive_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 01_ownership_borrowing\\05_memory_safety.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 03_control_flow_and_functions\\02_function_formal_semantics.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\00_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\02_memory_safety_proofs.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 12_traits\\03_trait_coherence_theory.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 19_advanced_language_features\\00_rust_1_88_0_comprehensive_analysis.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 20_version_features_analysis\\14_rust_185_nested_impl_traits_comprehensive.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_PLAN\\02_restructure_execution_plan.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\batch_index_improvement_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\final_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\module_01_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase2_quality_standardization_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase3_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\phase9_link_optimization_completion.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\restructure_completion_report.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 RESTRUCTURE_WORKING\\restructure_log.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte",
    "无法读取文件 11_memory_management\\00_index.md: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte"
  ],
  "warnings": [],
  "structure_verification": {
    "issues": [
      "00_index.md: 缺少必需章节 ##\\s*概述",
      "00_index.md: 缺少必需章节 ##\\s*核心概念",
      "00_index.md: 缺少必需章节 ##\\s*相关模块",
      "00_index.md: 缺少必需章节 ##\\s*参考文献",
      "00_index.md: 缺少必需章节 ##\\s*维护信息",
      "01_ownership_borrowing\\00_index.md: 缺少必需章节 ##\\s*概述",
      "01_ownership_borrowing\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "01_ownership_borrowing\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "01_theory_foundations\\00_index.md: 缺少必需章节 ##\\s*概述",
      "01_theory_foundations\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "01_theory_foundations\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "02_type_system\\00_index.md: 缺少必需章节 ##\\s*概述",
      "02_type_system\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "03_control_flow\\00_index.md: 缺少必需章节 ##\\s*概述",
      "03_control_flow\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "03_control_flow_and_functions\\00_index.md: 缺少必需章节 ##\\s*概述",
      "03_control_flow_and_functions\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "03_control_flow_and_functions\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "03_type_system_core\\00_index.md: 缺少必需章节 ##\\s*概述",
      "03_type_system_core\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "03_type_system_core\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "04_generics\\00_index.md: 缺少必需章节 ##\\s*概述",
      "04_generics\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "04_generics\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "05_concurrency\\00_index.md: 缺少必需章节 ##\\s*概述",
      "05_concurrency\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "05_concurrency\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "05_formal_verification\\00_index.md: 缺少必需章节 ##\\s*概述",
      "05_formal_verification\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "05_formal_verification\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "06_async_await\\00_index.md: 缺少必需章节 ##\\s*概述",
      "06_async_await\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "06_async_await\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "06_async_await\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "06_theory_practice\\00_index.md: 缺少必需章节 ##\\s*概述",
      "06_theory_practice\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "06_theory_practice\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "07_macro_system\\00_index.md: 缺少必需章节 ##\\s*概述",
      "07_macro_system\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "07_macro_system\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "07_process_management\\00_index.md: 缺少必需章节 ##\\s*概述",
      "07_process_management\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "07_process_management\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "08_algorithms\\00_index.md: 缺少必需章节 ##\\s*概述",
      "08_algorithms\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "08_algorithms\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "09_design_patterns\\00_index.md: 缺少必需章节 ##\\s*概述",
      "09_design_patterns\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "09_design_patterns\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "09_error_handling\\00_index.md: 缺少必需章节 ##\\s*概述",
      "09_error_handling\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "09_error_handling\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "10_modules\\00_index.md: 缺少必需章节 ##\\s*概述",
      "10_modules\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "10_modules\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "11_frameworks\\00_index.md: 缺少必需章节 ##\\s*概述",
      "11_frameworks\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "11_frameworks\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "12_middlewares\\00_index.md: 缺少必需章节 ##\\s*概述",
      "12_middlewares\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "12_middlewares\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "12_traits\\00_index.md: 缺少必需章节 ##\\s*概述",
      "12_traits\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "12_traits\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "13_microservices\\00_index.md: 缺少必需章节 ##\\s*概述",
      "13_microservices\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "13_microservices\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "13_microservices\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "13_microservices\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "14_workflow\\00_index.md: 缺少必需章节 ##\\s*概述",
      "14_workflow\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "14_workflow\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "14_workflow\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "14_workflow\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "15_blockchain\\00_index.md: 缺少必需章节 ##\\s*概述",
      "15_blockchain\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "15_blockchain\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "15_blockchain\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "15_blockchain\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "16_webassembly\\00_index.md: 缺少必需章节 ##\\s*概述",
      "16_webassembly\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "16_webassembly\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "16_webassembly\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "16_webassembly\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "17_iot\\00_index.md: 缺少必需章节 ##\\s*概述",
      "17_iot\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "17_iot\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "17_iot\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "17_iot\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "18_model\\00_index.md: 缺少必需章节 ##\\s*概述",
      "18_model\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "18_model\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "18_model\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "18_model\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "19_advanced_features\\00_index.md: 缺少必需章节 ##\\s*概述",
      "19_advanced_features\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "19_advanced_features\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "19_advanced_language_features\\00_index.md: 缺少必需章节 ##\\s*概述",
      "19_advanced_language_features\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "19_advanced_language_features\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "19_advanced_language_features\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "19_advanced_language_features\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "20_theoretical_perspectives\\00_index.md: 缺少必需章节 ##\\s*概述",
      "20_theoretical_perspectives\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "20_theoretical_perspectives\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "20_theoretical_perspectives\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "20_theoretical_perspectives\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "21_application_domains\\00_index.md: 缺少必需章节 ##\\s*概述",
      "21_application_domains\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "21_application_domains\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "21_application_domains\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "21_application_domains\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "22_performance_optimization\\00_index.md: 缺少必需章节 ##\\s*概述",
      "22_performance_optimization\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "22_performance_optimization\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "22_performance_optimization\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "22_performance_optimization\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "23_security_verification\\00_index.md: 缺少必需章节 ##\\s*概述",
      "23_security_verification\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "23_security_verification\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "23_security_verification\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "23_security_verification\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "24_cross_language_comparison\\00_index.md: 缺少必需章节 ##\\s*概述",
      "24_cross_language_comparison\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "24_cross_language_comparison\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "24_cross_language_comparison\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "24_cross_language_comparison\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "25_teaching_learning\\00_index.md: 缺少必需章节 ##\\s*概述",
      "25_teaching_learning\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "25_teaching_learning\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "25_teaching_learning\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "25_teaching_learning\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "26_toolchain_ecosystem\\00_index.md: 缺少必需章节 ##\\s*概述",
      "26_toolchain_ecosystem\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "26_toolchain_ecosystem\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "26_toolchain_ecosystem\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "26_toolchain_ecosystem\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "27_ecosystem_architecture\\00_index.md: 缺少必需章节 ##\\s*概述",
      "27_ecosystem_architecture\\00_index.md: 缺少必需章节 ##\\s*核心概念",
      "27_ecosystem_architecture\\00_index.md: 缺少必需章节 ##\\s*相关模块",
      "27_ecosystem_architecture\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "27_ecosystem_architecture\\00_index.md: 缺少必需章节 ##\\s*维护信息",
      "28_advanced_type_features\\00_index.md: 缺少必需章节 ##\\s*概述",
      "28_advanced_type_features\\00_index.md: 缺少必需章节 ##\\s*参考文献",
      "28_advanced_type_features\\00_index.md: 缺少必需章节 ##\\s*维护信息"
    ],
    "total_index_files": 39
  }
}