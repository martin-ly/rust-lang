# Rust语言形式理论：概念词典

## 目录

- [Rust语言形式理论：概念词典](#rust语言形式理论概念词典)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 核心语言概念](#2-核心语言概念)
    - [2.1 所有权与借用](#21-所有权与借用)
      - [所有权 (Ownership)](#所有权-ownership)
      - [移动语义 (Move Semantics)](#移动语义-move-semantics)
      - [借用 (Borrowing)](#借用-borrowing)
      - [生命周期 (Lifetime)](#生命周期-lifetime)
    - [2.2 类型系统](#22-类型系统)
      - [类型安全 (Type Safety)](#类型安全-type-safety)
      - [特征 (Trait)](#特征-trait)
      - [类型推断 (Type Inference)](#类型推断-type-inference)
    - [2.3 控制流](#23-控制流)
      - [模式匹配 (Pattern Matching)](#模式匹配-pattern-matching)
      - [错误处理 (Error Handling)](#错误处理-error-handling)
    - [2.4 泛型与特征](#24-泛型与特征)
      - [泛型 (Generics)](#泛型-generics)
      - [特征约束 (Trait Bounds)](#特征约束-trait-bounds)
    - [2.5 并发与异步](#25-并发与异步)
      - [并发安全 (Concurrency Safety)](#并发安全-concurrency-safety)
      - [消息传递 (Message Passing)](#消息传递-message-passing)
      - [异步编程 (Asynchronous Programming)](#异步编程-asynchronous-programming)
  - [8. 数学表示与符号](#8-数学表示与符号)
    - [8.1 集合论符号](#81-集合论符号)
    - [8.2 类型理论符号](#82-类型理论符号)
    - [8.3 所有权系统符号](#83-所有权系统符号)

## 1. 概述

本文档是Rust语言形式理论项目的概念词典，旨在确保整个文档集中概念定义和术语使用的一致性。每个概念包括正式定义、相关属性和模块引用信息。

## 2. 核心语言概念

### 2.1 所有权与借用

#### 所有权 (Ownership)

**定义**：所有权是Rust资源管理的核心概念，指的是对资源的唯一控制权。从引用一致性视角看，所有权是**资源构造性存在的证明**，而非内存管理机制。所有者拥有对资源的完全支配权，包括读取、修改和销毁的能力。

**数学表示**：$\text{Own}(v, s)$ 表示变量 $v$ 在作用域 $s$ 中拥有资源的唯一控制权。

**关键属性**（引用一致性视角）：

- 唯一性：在任一时刻，一个资源只能有一个所有者（排他控制权）
- 作用域绑定：所有权与变量的作用域绑定（逻辑关系）
- 资源管理：当所有者离开作用域时，资源被自动释放（编译期证明的资源生命周期）
- **核心洞察**：所有权不依赖物理内存，而是资源的逻辑控制权证明

**模块引用**：[01_ownership_borrowing](01_ownership_borrowing/01_formal_theory.md)

#### 移动语义 (Move Semantics)

**定义**：移动语义是指在赋值或传参时，资源的控制权从一个变量转移到另一个变量，而原变量不再有效的机制。从引用一致性视角看，移动是**资源控制权的转移**，而非内存拷贝。

**数学表示**：$\text{Move}(v_1, v_2)$ 表示将变量 $v_1$ 的资源控制权转移给变量 $v_2$。

**关键属性**（引用一致性视角）：

- 控制权转移：资源的控制权从源变量转移到目标变量（逻辑转移）
- 源失效：转移后，源变量不再可用（编译期证明的排他性）
- 安全保证：通过编译期证明防止多重释放和悬垂引用（逻辑证明，非运行时检查）
- **核心洞察**：移动是资源控制权的逻辑转移，与物理内存无关

**模块引用**：[01_ownership_borrowing](01_ownership_borrowing/01_formal_theory.md)

#### 借用 (Borrowing)

**定义**：借用是指在不转移资源控制权的情况下，临时获取对资源访问能力的机制。从引用一致性视角看，借用是**能力转移与受限授权**，而非内存地址传递。`&T` 是只读访问许可证，`&mut T` 是独占写入能力的证明。

**数学表示**：

- $\text{Borrow}(v, r)$ 表示从变量 $v$ 创建不可变引用 $r$（只读访问许可证）
- $\text{BorrowMut}(v, r)$ 表示从变量 $v$ 创建可变引用 $r$（独占写入能力证明）

**关键属性**（引用一致性视角）：

- 能力规则：同一时刻，要么有多个只读访问许可证，要么只有一个独占写入能力证明（编译期排他性契约）
- 生命周期：引用的生命周期是编译期证明的有效范围，而非内存地址的有效期（逻辑关系）
- 安全保证：通过编译期证明防止数据竞争和悬垂引用（逻辑证明，非运行时检查）
- **核心洞察**：借用是访问能力的逻辑转移，与物理内存无关

**模块引用**：[01_ownership_borrowing](01_ownership_borrowing/01_formal_theory.md)

#### 生命周期 (Lifetime)

**定义**：生命周期是编译期构造的证明变量，用于证明引用在其使用期间始终指向有效的资源。从引用一致性视角看，生命周期是**有效性的编译期证明**，而非内存地址的有效时间段。`'a` 是证明变量，证明引用在作用域 `'a` 内永远不会被无效使用。

**数学表示**：$\text{Lifetime}(r) = \alpha$ 表示引用 $r$ 的生命周期参数 $\alpha$，这是编译期证明变量，而非时间戳。

**关键属性**（引用一致性视角）：

- 编译期证明：生命周期是类型系统的一部分，在编译期证明引用的有效性（逻辑证明）
- 逻辑关系：生命周期表达的是引用之间的逻辑依赖关系，而非内存地址的物理关系（逻辑约束）
- 约束求解：编译器通过约束求解来验证生命周期的一致性（图算法，非内存检查）
- 标注语法：使用 `'a` 形式在函数签名中显式标注生命周期参数（证明变量）
- **核心洞察**：生命周期是证明的有效范围，与物理内存无关

**模块引用**：[01_ownership_borrowing](01_ownership_borrowing/01_formal_theory.md)

### 2.2 类型系统

#### 类型安全 (Type Safety)

**定义**：类型安全是指程序在运行时不会因类型错误而导致未定义行为的特性。

**数学表示**：如果对所有表达式 $e$ 和类型 $T$，当 $\vdash e : T$ 时，$e$ 的求值不会导致类型错误，则称语言是类型安全的。

**关键属性**：

- 静态检查：编译时捕获类型错误
- 类型边界：明确定义类型间的转换规则
- 无未定义行为：避免因类型不匹配导致的运行时错误

**模块引用**：[02_type_system](02_type_system/01_formal_type_system.md)

#### 特征 (Trait)

**定义**：特征是Rust中定义共享行为的抽象接口，类似于其他语言中的接口或抽象类。

**数学表示**：$\text{Trait}(T) = \{m_1, m_2, \ldots, m_n\}$ 表示特征 $T$ 定义了一组方法 $\{m_1, m_2, \ldots, m_n\}$。

**关键属性**：

- 行为抽象：定义可由不同类型实现的共享行为
- 边界约束：可用作泛型约束
- 动态分发：通过特征对象实现运行时多态
- 静态分发：通过泛型实现编译时多态

**模块引用**：[02_type_system](02_type_system/01_formal_type_system.md), [04_generics](04_generics/01_formal_theory.md)

#### 类型推断 (Type Inference)

**定义**：类型推断是编译器根据上下文自动确定表达式类型的能力，无需程序员显式标注。

**数学表示**：$\Gamma \vdash e : T$ 表示在上下文 $\Gamma$ 中，表达式 $e$ 被推断为类型 $T$。

**关键属性**：

- 局部推断：主要基于局部信息进行推断
- 流向分析：考虑数据流向进行推断
- 完整性：如果无法推断类型，则要求显式标注

**模块引用**：[02_type_system](02_type_system/02_type_inference.md)

### 2.3 控制流

#### 模式匹配 (Pattern Matching)

**定义**：模式匹配是一种解构和检查数据结构的机制，允许根据值的结构执行不同的代码路径。

**数学表示**：$\text{Match}(v, \{(p_1, e_1), (p_2, e_2), \ldots, (p_n, e_n)\})$ 表示将值 $v$ 与模式 $p_1, p_2, \ldots, p_n$ 进行匹配，并执行对应的表达式 $e_i$。

**关键属性**：

- 解构能力：可以解构复合数据类型
- 穷尽性：要求匹配所有可能的情况
- 变量绑定：可在匹配过程中绑定变量

**模块引用**：[03_control_flow](03_control_flow/01_formal_theory.md)

#### 错误处理 (Error Handling)

**定义**：错误处理是处理程序执行过程中可能出现的异常情况的机制，在Rust中主要通过 `Result` 和 `Option` 类型实现。

**数学表示**：

- $\text{Result}<T, E>$ 可以是 $\text{Ok}(t)$ 或 $\text{Err}(e)$，其中 $t: T, e: E$
- $\text{Option}<T>$ 可以是 $\text{Some}(t)$ 或 $\text{None}$，其中 $t: T$

**关键属性**：

- 显式性：错误必须被显式处理
- 可组合性：可通过 `?` 运算符和组合子函数组合多个可能失败的操作
- 类型安全：错误处理受类型系统保护

**模块引用**：[03_control_flow](03_control_flow/01_formal_theory.md)

### 2.4 泛型与特征

#### 泛型 (Generics)

**定义**：泛型是一种参数多态性机制，允许编写适用于多种类型的代码。

**数学表示**：如果 $F<T>$ 是参数化类型，则对任何类型 $A, B$，$F<A>$ 和 $F<B>$ 是不同的类型。

**关键属性**：

- 类型参数化：允许函数和数据结构接受类型参数
- 静态分发：泛型在编译时单态化，无运行时开销
- 约束系统：通过特征约束限制泛型类型

**模块引用**：[04_generics](04_generics/01_formal_theory.md)

#### 特征约束 (Trait Bounds)

**定义**：特征约束是对泛型类型参数的限制，要求类型必须实现特定的特征。

**数学表示**：如果 $T: \text{Trait}$ 是特征约束，则任何满足该约束的类型 $A$ 必须实现 $\text{Trait}$。

**关键属性**：

- 行为保证：确保类型支持特定操作
- 静态验证：在编译时检查约束是否满足
- 条件实现：可以为满足特定约束的类型实现特征

**模块引用**：[04_generics](04_generics/01_formal_theory.md)

### 2.5 并发与异步

#### 并发安全 (Concurrency Safety)

**定义**：并发安全是指程序在多线程环境中执行时免于数据竞争和其他并发相关错误的特性。

**数学表示**：对于所有线程 $t_1, t_2$ 和共享数据 $d$，如果 $t_1$ 和 $t_2$ 同时访问 $d$，且至少有一个是写操作，则必须存在同步机制防止数据竞争。

**关键属性**：

- 所有权和借用：通过类型系统防止数据竞争
- 线程边界：所有权转移规则在线程边界上的应用
- 同步原语：提供安全的线程间通信机制

**模块引用**：[05_concurrency](05_concurrency/01_formal_theory.md)

#### 消息传递 (Message Passing)

**定义**：消息传递是一种并发通信模式，线程或任务通过发送和接收消息而非共享内存来通信。

**数学表示**：$\text{Channel}<T> = (\text{Sender}<T>, \text{Receiver}<T>)$，其中 $\text{Sender}$ 可以发送类型为 $T$ 的消息，$\text{Receiver}$ 可以接收这些消息。

**关键属性**：

- 所有权转移：消息的所有权从发送者转移到接收者
- 通道语义：支持多种通道语义（同步、异步、有界、无界）
- 并发模式：符合"不要通过共享内存来通信，而是通过通信来共享内存"的理念

**模块引用**：[05_concurrency](05_concurrency/01_formal_theory.md)

#### 异步编程 (Asynchronous Programming)

**定义**：异步编程是一种并发编程模型，允许任务在等待I/O操作完成时暂停执行，而不阻塞线程。

**数学表示**：如果 $F$ 是异步函数，则 $F: T \rightarrow \text{Future}<U>$，即接受类型 $T$ 的输入并返回表示未来结果的 $\text{Future}<U>$。

**关键属性**：

- 非阻塞：异步操作不会阻塞执行线程
- 状态机：异步函数编译为状态机
- 任务调度：通过执行器调度和执行异步任务
- 轮询模型：基于 `Poll` 的轮询模型

**模块引用**：[06_async_await](06_async_await/01_formal_async_system.md)

## 8. 数学表示与符号

本节定义了在整个文档集中使用的标准数学符号和表示法。

### 8.1 集合论符号

- $\in$ - 属于
- $\subset$ - 真子集
- $\subseteq$ - 子集
- $\cup$ - 并集
- $\cap$ - 交集
- $\emptyset$ - 空集
- $\mathbb{N}$ - 自然数集
- $\mathbb{Z}$ - 整数集
- $\mathbb{R}$ - 实数集

### 8.2 类型理论符号

- $\Gamma \vdash e : T$ - 在上下文 $\Gamma$ 中，表达式 $e$ 具有类型 $T$
- $T_1 <: T_2$ - 类型 $T_1$ 是 $T_2$ 的子类型
- $\forall \alpha. T$ - 对所有类型 $\alpha$，类型 $T$ 成立
- $\exists \alpha. T$ - 存在类型 $\alpha$，使得类型 $T$ 成立
- $T_1 \times T_2$ - $T_1$ 和 $T_2$ 的笛卡尔积（元组类型）
- $T_1 \rightarrow T_2$ - 从 $T_1$ 到 $T_2$ 的函数类型

### 8.3 所有权系统符号

- $\text{Own}(v, s)$ - 变量 $v$ 在作用域 $s$ 中拥有值的所有权
- $\text{Borrow}(v, r)$ - 从变量 $v$ 创建不可变引用 $r$
- $\text{BorrowMut}(v, r)$ - 从变量 $v$ 创建可变引用 $r$
- $\text{Move}(v_1, v_2)$ - 将变量 $v_1$ 的值的所有权转移给变量 $v_2$
- $\text{Copy}(v_1, v_2)$ - 将变量 $v_1$ 的值复制给变量 $v_2$
- $\text{Lifetime}(r)$ - 引用 $r$ 的生命周期

---

**文档生成**: 2025年7月27日
**版本**: V1.0
**状态**: 进行中 - 将随质量检查工作进展而更新
