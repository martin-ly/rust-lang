# 2.3 借用检查器算法

## 📊 目录

- [2.3 借用检查器算法](#23-借用检查器算法)
  - [📊 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 核心分析流程](#2-核心分析流程)
  - [3. 分析实例](#3-分析实例)
  - [4. MIR 与控制流图 (CFG)](#4-mir-与控制流图-cfg)
  - [5. 借用分析与 NLL](#5-借用分析与-nll)
    - [5.1. 活跃性分析](#51-活跃性分析)
    - [5.2. 确定借用生命周期](#52-确定借用生命周期)
    - [5.3. 冲突检测](#53-冲突检测)
  - [6. Polonius: 下一代借用检查器](#6-polonius-下一代借用检查器)

## 1. 概述

借用检查器（Borrow Checker）是 Rust 编译器的核心组件，它是一套**编译期逻辑证明系统**，用于在编译时通过逻辑证明强制执行所有权和借用规则。从引用一致性视角看，借用检查器的主要目标是保证程序的**资源安全和并发安全**，通过编译期逻辑证防止悬垂引用、数据竞争和使用已移动的值，而这一切都无需运行时的垃圾回收。

本章将通过一个具体的例子，逐步拆解借用检查器的工作流程，重点阐述其在 **中间表示（MIR）** 上的**逻辑证明过程**，以及 **非词法生命周期（NLL）** 的核心思想。从引用一致性视角看，借用检查器通过**约束求解**来验证引用的有效性，而非检查内存状态。

## 2. 核心分析流程

从引用一致性视角看，借用检查器的分析过程是**编译期逻辑证明**，可以概括为以下几个主要步骤：

1. **构建 MIR**: 将源代码转换为一种明确的、基于控制流图（Control-Flow Graph, CFG）的中间表示。
2. **活跃性分析**: 在 CFG 的每个点上，计算哪些变量的未来使用是可能的（即变量是"活跃的"）。这是**逻辑分析**，而非内存状态追踪。
3. **借用分析**: 识别代码中所有的借用操作，并确定每个借用的 **生命周期**（即借用保持有效的 CFG 区域）。从引用一致性视角看，这是**证明变量的计算**，而非内存地址的有效期。
4. **冲突检测**: 通过**逻辑证明**验证是否存在冲突的借用。例如，在同一个点上，一个变量不能同时存在活跃的独占引用和任何其他引用。这是**编译期排他性契约的验证**，而非运行时内存检查。

## 3. 分析实例

我们将使用以下函数作为贯穿本章的分析实例：

```rust
fn example(condition: bool) {
    let mut x = 5;      // --+ 'scope
    let y = &x;         // --+ 'a
                        //   |
    if condition {      //   |
        println!("{}", y);  // --+
    }                   //   |
                        //   |
    x += 1;             // --+
    //                      |
} // <----------------------+ 'scope, 'a
```

在 NLL 之前的旧版借用检查器中，这段代码会编译失败，因为 `y` 的借用生命周期 `'a` 被错误地扩展到了 `'scope` 的末尾，导致 `x += 1` 处的独占访问与 `y` 的共享借用冲突。而 NLL 能够正确地通过编译。从引用一致性视角看，NLL 通过**逻辑证明**更精确地计算引用的有效范围，而非简单地追踪内存状态。

## 4. MIR 与控制流图 (CFG)

借用检查器不在源代码上直接工作，而是在 MIR 上进行分析。MIR 将代码分解为一系列 **基本块（Basic Blocks）**，每个块包含一系列无分支的语句，并以一个 **终结符（Terminator）**（如 `if`、`goto`、`return`）结束，这些块共同构成了函数的 CFG。

对于我们的 `example` 函数，其简化的 CFG 如下：

```mermaid
graph TD
    BB0 -->|always| BB1;
    BB1 -->|if true| BB2;
    BB1 -->|if false| BB3;
    BB2 -->|always| BB3;
    BB3 -->|return| BB4;

    subgraph " "
        BB0["<b>BB0</b><br/>x = 5<br/>y = &x"];
        BB2["<b>BB2</b><br/>println!(\"{}\", y)"];
        BB3["<b>BB3</b><br/>x += 1"];
        BB1["<b>BB1</b><br/>switch_int(condition)"];
        BB4["<b>BB4</b><br/>return"];
    end
```

- **BB0**: 初始化 `x` 和 `y`。
- **BB1**: `if` 条件判断，根据 `condition` 的值跳转。
- **BB2**: `if` 为 `true` 时执行的分支。
- **BB3**: `if` 为 `false` 时或从 `BB2` 执行完毕后继续执行。
- **BB4**: 函数返回。

## 5. 借用分析与 NLL

### 5.1. 活跃性分析

借用检查器首先进行活跃性分析，以确定在 CFG 的每个点的入口处，哪些变量是活跃的（即其值在未来可能被读取）。对于我们的例子，关键点是：

- `y` 在 `BB2` 的入口处是活跃的，因为 `println!` 需要读取它。
- `y` 在 `BB3` 的入口处 **不是** 活跃的，因为在从 `BB1` 或 `BB2` 到达 `BB3` 的任何路径上，`y` 都不会再被使用。

### 5.2. 确定借用生命周期

借用检查器为每个借用（如 `y = &x`）计算一个生命周期区域。这个区域是 CFG 中所有满足以下条件的点的集合：

1. 该点是借用创建点。
2. 从该点出发，可以到达一个引用是 **活跃** 的点。

在我们的例子中，对 `y` 的借用，其生命周期区域包含：

- `BB0` 的后半部分（借用创建后）。
- 整个 `BB1`（因为从 `BB1` 可以到达 `BB2`，而 `y` 在 `BB2` 是活跃的）。
- 整个 `BB2`。

重要的是，这个区域 **不包含** `BB3`，因为 `y` 在 `BB3` 的入口处不是活跃的。这就是 **非词法生命周期 (NLL)** 的精髓：**一个借用的生命周期仅持续到其最后一次使用**。

### 5.3. 冲突检测

从引用一致性视角看，冲突检测是**编译期逻辑证明**，而非运行时内存检查。借用检查器在 CFG 的每个点上通过**逻辑证明**验证是否存在冲突的借用：

- 在 `BB0`, `BB1`, `BB2` 中，存在一个活跃的共享借用 `y` (`&x`)。在这些点上任何对 `x` 的独占访问（`&mut x` 或直接修改）都会被禁止。这是**编译期排他性契约的验证**，而非内存保护。
- 在 `BB3` 中，对 `y` 的借用生命周期已经结束。因此，`B(x)` 的状态回到了 `Unborrowed`。此时，`x += 1`（需要一个对 `x` 的独占借用）是完全合法的。这是**逻辑证明**，而非内存状态检查。

由于在任何点上都没有发现冲突，所以借用检查通过。这是**编译期逻辑证明**的结果，而非运行时内存检查。

## 6. Polonius: 下一代借用检查器

Polonius 是 Rust 下一代借用检查器算法的代号，它基于 Datalog 逻辑编程。从引用一致性视角看，Polonius 是**纯粹的编译期逻辑证明系统**，其核心思想是将借用检查的规则形式化为一系列逻辑事实和推导规则。

**引用一致性视角**：Polonius 通过**逻辑编程**来证明引用的有效性，而非检查内存状态。这是**类型层面的逻辑证明**，而非内存层面的物理检查。

**简化后的核心逻辑**:

1. **输入事实**（逻辑事实，非内存状态）:
    - `loan_issued_at(L, P)`: 在点 `P` 产生了借用 `L`（逻辑事实）。
    - `var_used_at(V, P)`: 变量 `V` 在点 `P` 被使用（逻辑事实）。
    - `cfg_edge(P1, P2)`: 控制流可以从点 `P1` 到达 `P2`（逻辑关系）。

2. **推导规则**（逻辑证明规则）:
    - `loan_live_at(L, P)`: 如果 `L` 在 `P` 点被使用，或从 `P` 点可以到达一个 `L` 被使用的点，则借用 `L` 在 `P` 点是活跃的。这是**逻辑证明**，而非内存状态追踪。
    - `subset(L1, L2)`: 如果借用 `L1` 的生命周期需要包含 `L2` 的生命周期（例如，`fn foo<'a, 'b: 'a>(...)`）。这是**逻辑关系**，而非内存地址的包含关系。

3. **错误检测**（逻辑证明的失败）:
    - `error(L1, L2, P)`: 如果在点 `P` 上，借用 `L1` 和 `L2` 都是活跃的，并且 `L1` 和 `L2` 互相冲突（例如，一个是 `&mut x`，另一个是 `&x`），则产生一个错误。这是**逻辑证明的失败**，而非运行时内存冲突。

Polonius 的方法更加精确，能够处理一些 NLL 仍然会错误拒绝的复杂代码模式，并有望在未来提供更清晰的错误诊断信息。从引用一致性视角看，Polonius 通过**更精确的逻辑证明**来验证引用的有效性，而非更精确的内存检查。
