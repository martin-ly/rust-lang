# 汇编语言分析

## 目录

- [汇编语言分析](#汇编语言分析)
  - [目录](#目录)
  - [1. 汇编基础：变量、类型与控制](#1-汇编基础变量类型与控制)
    - [1.1 变量与数据存储](#11-变量与数据存储)
    - [1.2 类型系统与表示](#12-类型系统与表示)
    - [1.3 控制结构与流程](#13-控制结构与流程)
    - [1.4 作用域与可见性](#14-作用域与可见性)
  - [2. 执行模型与流分析](#2-执行模型与流分析)
    - [2.1 控制流分析](#21-控制流分析)
    - [2.2 数据流分析](#22-数据流分析)
    - [2.3 执行流分析](#23-执行流分析)
    - [2.4 同步与异步机制](#24-同步与异步机制)
  - [3. 形式化方法](#3-形式化方法)
    - [3.1 形式化语义](#31-形式化语义)
    - [3.2 形式化验证](#32-形式化验证)
    - [3.3 程序分析技术](#33-程序分析技术)
  - [4. 抽象层次与模型](#4-抽象层次与模型)
    - [4.1 硬件执行模型](#41-硬件执行模型)
    - [4.2 调度与系统交互](#42-调度与系统交互)
    - [4.3 元模型与元理论](#43-元模型与元理论)
    - [4.4 层次间关系](#44-层次间关系)
  - [思维导图-汇编分析](#思维导图-汇编分析)
  - [5. WebAssembly与汇编对比](#5-webassembly与汇编对比)
    - [5.1 WebAssembly基础特性](#51-webassembly基础特性)
    - [5.2 类型系统与安全性](#52-类型系统与安全性)
    - [5.3 执行模型对比](#53-执行模型对比)
  - [6. 编译器视角](#6-编译器视角)
    - [6.1 从高级语言到汇编](#61-从高级语言到汇编)
    - [6.2 中间表示(IR)](#62-中间表示ir)
    - [6.3 优化技术](#63-优化技术)
  - [7. 跨平台与移植性](#7-跨平台与移植性)
    - [7.1 不同架构比较](#71-不同架构比较)
    - [7.2 跨平台汇编抽象](#72-跨平台汇编抽象)
  - [8. 高级分析技术](#8-高级分析技术)
    - [8.1 符号执行深入](#81-符号执行深入)
    - [8.2 模型检查方法](#82-模型检查方法)
    - [8.3 定理证明技术](#83-定理证明技术)
  - [思维导图-汇编分析(续)](#思维导图-汇编分析续)

## 1. 汇编基础：变量、类型与控制

### 1.1 变量与数据存储

汇编语言中的"变量"概念与高级语言有本质区别，实际上是存储位置：

- **寄存器变量**：CPU内部的高速存储单元

  ```assembly
  mov eax, 5       ; 将值5存入EAX寄存器
  add eax, ebx     ; EAX = EAX + EBX
  ```

- **内存变量**：通过地址访问的存储单元

  ```assembly
  section .data
  counter dd 0     ; 定义双字变量counter，初值为0

  section .text
  inc dword [counter] ; 增加内存中counter的值
  ```

- **栈变量**：基于栈指针的临时存储

  ```assembly
  push eax         ; 保存EAX到栈
  sub esp, 4       ; 分配4字节栈空间
  mov [esp], 10    ; 在栈上存储值
  ```

### 1.2 类型系统与表示

汇编语言的类型系统极其简单，主要依赖程序员维护：

- **原始类型**：字节(byte)、字(word)、双字(dword)、四字(qword)等

  ```assembly
  mov al, 0xFF     ; 8位操作 (byte)
  mov bx, 1234h    ; 16位操作 (word)
  mov ecx, 0       ; 32位操作 (dword)
  ```

- **类型表示**：汇编中通过指令和操作数大小隐式表示类型

  ```assembly
  movzx eax, byte [data] ; 零扩展加载字节
  cvtsi2sd xmm0, eax     ; 整数转双精度浮点
  ```

- **类型检查**：几乎不存在，错误类型使用可能导致未定义行为

### 1.3 控制结构与流程

汇编通过跳转指令实现控制流：

- **无条件跳转**：直接改变执行流向

  ```assembly
  jmp label        ; 无条件跳转到标签处
  ```

- **条件跳转**：基于标志位状态决定是否跳转

  ```assembly
  cmp eax, 10      ; 比较EAX与10
  jl loop_start    ; 如果小于则跳转
  ```

- **循环构造**：使用条件跳转和计数器

  ```assembly
  mov ecx, 10      ; 循环计数器初始化
  loop_start:
    ; 循环体
    dec ecx        ; 递减计数器
    jnz loop_start ; 不为零则继续循环
  ```

### 1.4 作用域与可见性

- **静态作用域**：汇编缺乏高级语言的词法作用域，通常通过标签和链接属性管理

  ```assembly
  global _start    ; 全局可见标签
  _start:
    ; 代码
  local_label:     ; 文件内可见标签
    ; 更多代码
  ```

- **动态作用域**：不直接支持，需通过栈帧手动实现

## 2. 执行模型与流分析

### 2.1 控制流分析

- **控制流图(CFG)**：表示程序所有可能执行路径的有向图
  - **节点**：基本块(没有分支的指令序列)
  - **边**：可能的控制转移(条件/无条件跳转)

- **形式化表示**：CFG = (V, E)，其中V是基本块集合，E是转移边集合

- **示例**：

  ```assembly
  B1: mov ecx, 10
      cmp eax, 0
      jne B3      ; 边B1→B3(条件)
                  ; 边B1→B2(顺序执行)
  B2: mov ebx, 1
      jmp B4      ; 边B2→B4(无条件)
  B3: mov ebx, -1 ; 边B3→B4(顺序执行)
  B4: add eax, ebx
      loop B1     ; 边B4→B1(循环)
                  ; 边B4→B5(循环结束)
  B5: ret
  ```

### 2.2 数据流分析

- **定义**：分析数据(变量/寄存器值)在程序中如何传播和变化

- **常见数据流分析类型**：
  - **到达定义分析**：哪些变量赋值可能到达程序某点
  - **活跃变量分析**：哪些变量的值在某点后可能被使用
  - **可用表达式分析**：哪些表达式已计算且值未改变

- **应用**：优化、寄存器分配、死代码消除等

- **示例(活跃变量分析)**：

  ```assembly
  ; 点1：eax未知，ebx未知
  mov eax, 1      ; 定义eax
  ; 点2：eax=1，ebx未知，eax活跃(后面使用)
  mov ebx, 2      ; 定义ebx
  ; 点3：eax=1，ebx=2，两者活跃(后面使用)
  add eax, ebx    ; 使用eax,ebx，重定义eax
  ; 点4：eax=3，ebx=2，eax活跃，ebx非活跃
  ```

### 2.3 执行流分析

- **概念**：分析指令实际执行顺序及时间特性

- **关键方面**：
  - **指令级并行**：流水线、超标量、乱序执行
  - **微架构影响**：缓存、分支预测、指令获取
  - **中断与异常**：执行流被外部事件打断

- **现代CPU执行模型**：

  ```math
  获取→解码→执行→访存→写回
     ↑                 |
     |_____(乱序)______|
  ```

### 2.4 同步与异步机制

- **同步原语**：

  ```assembly
  ; 原子操作示例(x86)
  lock xchg [lock_var], eax  ; 原子交换获取锁
  ```

- **内存屏障**：确保内存操作顺序

  ```assembly
  ; 内存屏障(x86)
  mfence  ; 完整内存屏障，确保前后内存操作不重排
  ```

- **中断处理**：异步执行流的典型例子

  ```assembly
  ; 中断处理程序入口
  push eax        ; 保存上下文
  ; 处理中断
  pop eax         ; 恢复上下文
  iret            ; 中断返回
  ```

## 3. 形式化方法

### 3.1 形式化语义

- **操作语义**：描述指令如何改变状态
  - **小步语义**：单条指令执行效果

    ```math
    \langle \text{MOV }r, imm, \sigma \rangle \rightarrow \sigma[r \mapsto imm]
    ```

  - **大步语义**：整体计算结果

    ```math
    \langle \text{code block}, \sigma \rangle \Downarrow \sigma'
    ```

- **示例(ADD指令形式化语义)**：

  ```math
  ⟦ADD dst, src⟧(σ) = σ[
    dst ↦ σ(dst) + σ(src),
    ZF ↦ (σ(dst) + σ(src) == 0),
    SF ↦ (σ(dst) + σ(src) < 0),
    ... ]
  ```

### 3.2 形式化验证

- **基本概念**：
  - **规约**：系统预期行为的数学描述
  - **模型**：系统的形式化表示
  - **验证**：证明模型满足规约

- **验证技术**：
  - **模型检查**：自动探索有限状态系统
  - **定理证明**：使用逻辑推导证明性质
  - **抽象解释**：在抽象域上分析程序

- **霍尔逻辑示例**：

  ```math
  {EAX = x}
  mov ebx, eax
  add ebx, 5
  {EBX = x + 5}
  ```

### 3.3 程序分析技术

- **符号执行**：使用符号值而非具体值执行程序

  ```math
  初始：x = α, y = β
  mov eax, x    ; eax = α
  add eax, y    ; eax = α + β
  条件：若 α + β > 10 则分支1，否则分支2
  ```

- **抽象解释**：在抽象域上近似执行

  ```math
  区间分析：
  mov eax, [0..5]  ; eax ∈ [0,5]
  add eax, [1..3]  ; eax ∈ [1,8]
  ```

- **不变量推导**：自动发现循环不变式

  ```assembly
  ; 循环计算n!
  mov eax, 1     ; 结果=1
  mov ecx, n     ; 计数器=n
  loop_start:
    test ecx, ecx
    jz loop_end
    mul ecx      ; eax *= ecx
    dec ecx
    jmp loop_start
  loop_end:

  ; 不变量：迭代后，eax = (n-ecx+1)! 且 ecx ≥ 0
  ```

## 4. 抽象层次与模型

### 4.1 硬件执行模型

- **处理器微架构**：
  - **流水线执行**：指令分阶段并行处理
  - **分支预测**：预测跳转减少流水线停顿
  - **超标量/乱序**：多条指令并行执行

- **内存层次**：
  - **缓存模型**：多级缓存及其一致性协议
  - **内存模型**：指令重排规则(如TSO,弱序)

### 4.2 调度与系统交互

- **进程调度**：操作系统如何分配CPU时间

- **上下文切换**：

  ```assembly
  ; 上下文保存
  push eax, ebx, ...  ; 保存寄存器
  mov [saved_esp], esp ; 保存栈指针
  ; 上下文恢复
  mov esp, [new_esp]   ; 恢复栈指针
  pop ..., ebx, eax    ; 恢复寄存器
  ```

- **系统调用**：用户态到内核态转换

  ```assembly
  mov eax, SYS_WRITE   ; 系统调用号
  int 0x80             ; x86中断触发系统调用
  ```

### 4.3 元模型与元理论

- **元模型**：描述模型的模型
  - ISA(指令集架构)是处理器实现的元模型
  - 形式语义是编程语言的元模型

- **元理论**：研究理论本身的理论
  - 类型论研究类型系统的基础
  - 证明论研究形式证明系统

### 4.4 层次间关系

- **抽象层次**：

  ```math
  硬件电路 → 微架构 → ISA → 汇编语言 → 操作系统 → 应用程序
  ```

- **层次间映射**：
  - 编译器：高级语言→汇编→机器码
  - 硬件实现：ISA→微架构→电路

- **形式化关系**：
  - 精化关系(Refinement)：高层抽象实现低层细节
  - 仿真关系(Simulation)：低层模型模拟高层行为

## 思维导图-汇编分析

```text
汇编语言分析
├── 基础概念
│   ├── 变量
│   │   ├── 寄存器变量：CPU内部存储
│   │   ├── 内存变量：通过地址访问
│   │   └── 栈变量：基于栈指针临时存储
│   ├── 类型
│   │   ├── 原始类型：字节/字/双字/四字
│   │   ├── 隐式表示：通过指令和操作数大小
│   │   └── 几乎无类型检查：靠程序员保证
│   ├── 控制
│   │   ├── 无条件跳转：直接改变执行流
│   │   ├── 条件跳转：基于标志位决定
│   │   └── 手动构造：循环/分支/函数调用
│   └── 作用域
│       ├── 静态作用域：通过标签和链接属性
│       └── 无动态作用域：需手动实现
├── 流分析
│   ├── 控制流
│   │   ├── 控制流图(CFG)：基本块和转移边
│   │   ├── 形式化表示：CFG = (V,E)
│   │   └── 应用：优化/验证/理解程序结构
│   ├── 数据流
│   │   ├── 到达定义分析：变量赋值传播
│   │   ├── 活跃变量分析：变量使用情况
│   │   └── 可用表达式分析：已计算表达式跟踪
│   ├── 执行流
│   │   ├── 指令级并行：流水线/乱序执行
│   │   ├── 微架构影响：缓存/分支预测
│   │   └── 中断与异常：执行流打断
│   └── 同步异步
│       ├── 原子操作：不可分割的指令序列
│       ├── 内存屏障：确保内存操作顺序
│       └── 中断机制：支持异步事件处理
├── 形式化方法
│   ├── 形式化语义
│   │   ├── 操作语义：状态转换规则
│   │   ├── 公理语义：前置/后置条件
│   │   └── 指令精确定义：如何修改状态
│   ├── 形式化验证
│   │   ├── 模型检查：探索状态空间
│   │   ├── 定理证明：逻辑推导证明
│   │   └── 循环不变量：发现和验证
│   └── 程序分析
│       ├── 符号执行：使用符号值执行
│       ├── 抽象解释：抽象域上近似
│       └── 静态分析：编译时分析程序
└── 抽象层次
    ├── 硬件模型
    │   ├── 处理器微架构：流水线/超标量
    │   ├── 内存层次：缓存/主存
    │   └── 内存模型：SC/TSO/弱序
    ├── 系统交互
    │   ├── 进程调度：CPU时间分配
    │   ├── 上下文切换：保存恢复状态
    │   └── 系统调用：用户态到内核态
    ├── 元模型与理论
    │   ├── ISA：指令集架构
    │   ├── 语义学：程序意义
    │   └── 形式系统：逻辑基础
    └── 层次关系
        ├── 实现关系：高层→低层实现
        ├── 抽象关系：低层→高层抽象
        └── 验证链：确保层间一致性
```

## 5. WebAssembly与汇编对比

### 5.1 WebAssembly基础特性

WebAssembly (Wasm) 是一种面向网络的低级字节码格式，对比传统汇编：

- **栈式虚拟机**：Wasm主要基于栈操作，而非寄存器

  ```wasm
  (func $add (param $a i32) (param $b i32) (result i32)
    local.get $a    ;; 将$a压入栈
    local.get $b    ;; 将$b压入栈
    i32.add         ;; 弹出两个i32，将其和压入栈
  )
  ```

- **模块化设计**：明确的导入/导出机制

  ```wasm
  (module
    (import "env" "memory" (memory 1))
    (export "add" (func $add))
    (func $add ...)
  )
  ```

- **二进制格式**：优化的.wasm二进制格式，比文本格式更紧凑高效

### 5.2 类型系统与安全性

- **静态类型系统**：Wasm拥有简单但严格的类型系统

  ```wasm
  (func $conditional (param $x i32) (param $cond i32) (result i32)
    local.get $cond   ;; 条件值
    if (result i32)   ;; 结果类型必须声明为i32
      local.get $x
      i32.const 2
      i32.mul
    else
      local.get $x    ;; 保持原值
    end
  )
  ```

- **内存安全**：Wasm通过类型检查和边界检查保证内存安全

  ```wasm
  (func $read_at (param $addr i32) (result i32)
    local.get $addr
    i32.load      ;; 如果地址越界，将触发陷阱(trap)
  )
  ```

- **验证阶段**：在执行前进行验证，拒绝非法模块

### 5.3 执行模型对比

传统汇编与WebAssembly执行模型对比：

| 特性 | 传统汇编 | WebAssembly |
|------|----------|-------------|
| 执行环境 | 直接硬件执行 | 虚拟机解释/JIT编译 |
| 内存模型 | 平坦地址空间 | 线性内存(类似数组) |
| 控制流 | 随意跳转 | 结构化控制流 |
| 异常处理 | 依赖OS机制 | 陷阱(trap)机制 |
| 并发模型 | 取决于处理器 | 基于共享内存的线程 |

## 6. 编译器视角

### 6.1 从高级语言到汇编

编译过程的核心阶段：

1. **词法分析**：将源代码分解为词素(tokens)
2. **语法分析**：构建抽象语法树(AST)
3. **语义分析**：类型检查和语义验证
4. **中间表示**：转换为优化友好的IR
5. **优化**：各种IR级别优化
6. **代码生成**：生成目标架构汇编
7. **汇编与链接**：转换为机器码并链接

高级语言构造在汇编中的表示：

- **变量作用域**：

  ```c
  // C代码
  int func() {
    int x = 5;
    if (x > 0) {
      int y = 10;
      return x + y;
    }
    return x;
  }
  ```

  ```assembly
  ; x86汇编(简化)
  func:
    push ebp
    mov ebp, esp
    sub esp, 8       ; 为局部变量分配空间
    mov dword [ebp-4], 5  ; x = 5
    cmp dword [ebp-4], 0
    jle else_branch
    mov dword [ebp-8], 10 ; y = 10
    mov eax, [ebp-4]
    add eax, [ebp-8]
    jmp end
  else_branch:
    mov eax, [ebp-4]
  end:
    mov esp, ebp
    pop ebp
    ret
  ```

### 6.2 中间表示(IR)

现代编译器通常使用中间表示(IR)作为高级语言到汇编的桥梁：

- **三地址码**：最基本的IR形式

  ```math
  t1 = a + b
  t2 = t1 * c
  x = t2
  ```

- **静态单赋值(SSA)**：每个变量只被赋值一次

  ```math
  a1 = ...
  b1 = ...
  t1 = a1 + b1
  x1 = t1
  if (condition)
    x2 = x1 + 1
  else
    x3 = x1 - 1
  x4 = φ(x2, x3)  // φ(phi)函数表示分支合并
  ```

- **LLVM IR示例**：

  ```llvm
  define i32 @add(i32 %a, i32 %b) {
  entry:
    %result = add i32 %a, %b
    ret i32 %result
  }
  ```

### 6.3 优化技术

汇编级优化技术：

- **常量折叠与传播**：

  ```assembly
  ; 优化前
  mov eax, 5
  add eax, 3
  mov ebx, eax

  ; 优化后
  mov ebx, 8
  ```

- **强度削减**：用更快的等价操作替换

  ```assembly
  ; 优化前 - 乘法
  imul eax, 8

  ; 优化后 - 位移
  shl eax, 3
  ```

- **寄存器分配**：最小化内存访问

  ```assembly
  ; 优化前 - 频繁访存
  mov [var1], eax
  mov ebx, [var2]
  add ebx, 5
  mov [var3], ebx
  mov ecx, [var1]

  ; 优化后 - 寄存器复用
  mov ebx, eax    ; 保留var1值在寄存器
  add ebx, 5      ; var2+5直接在寄存器计算
  mov [var3], ebx
  mov ecx, eax    ; 直接从寄存器读取var1
  ```

## 7. 跨平台与移植性

### 7.1 不同架构比较

主要指令集架构对比：

| 特性 | x86-64 | ARM (AArch64) | RISC-V |
|------|--------|---------------|--------|
| 设计理念 | CISC | RISC | RISC |
| 指令长度 | 变长 | 固定(32位) | 固定(基础32位) |
| 寄存器 | 16个通用 | 31个通用 | 32个通用 |
| 寻址模式 | 复杂多样 | 相对简单 | 最简化 |
| 条件执行 | 通过标志位 | 部分指令带条件 | 通过分支 |

相同算法在不同架构上的汇编表示：

- **计算阶乘(x86)**：

  ```assembly
  ; x86汇编计算n!
  mov eax, 1      ; 结果=1
  mov ecx, [n]    ; 计数=n
  factorial_loop:
    test ecx, ecx
    jz end
    imul eax, ecx ; eax *= ecx
    dec ecx
    jmp factorial_loop
  end:
  ```

- **计算阶乘(ARM)**：

  ```assembly
  ; ARM汇编计算n!
  mov x0, #1      @ 结果=1
  ldr x1, [n]     @ 计数=n
  factorial_loop:
    cbz x1, end
    mul x0, x0, x1 @ x0 *= x1
    sub x1, x1, #1
    b factorial_loop
  end:
  ```

### 7.2 跨平台汇编抽象

实现跨平台的汇编代码策略：

- **条件编译**：为不同架构维护不同版本

  ```assembly
  #ifdef x86_64
    mov rax, rdi   ; x86-64参数约定
  #elif defined(ARM64)
    mov x0, x0     ; ARM64参数已在x0
  #endif
  ```

- **汇编宏**：抽象常见模式

  ```assembly
  ; 定义宏
  %macro PUSH_ALL 0
  %ifdef x86_64
    push rax
    push rbx
    ; ...
  %elifdef ARM64
    stp x0, x1, [sp, #-16]!
    stp x2, x3, [sp, #-16]!
    ; ...
  %endif
  %endmacro

  ; 使用宏
  PUSH_ALL
  ```

- **抽象汇编语言**：如LLVM IR，作为通用中间表示

## 8. 高级分析技术

### 8.1 符号执行深入

符号执行将程序输入替换为符号值，跟踪路径条件：

- **符号状态**：程序变量映射到符号表达式

  ```math
  (eax ↦ α, ebx ↦ β, ecx ↦ 5)
  ```

- **路径约束**：分支条件积累的约束

  ```math
  cmp eax, 10     ; 比较α与10
  jl label        ; 如果α<10跳转
  ; 此处路径约束为α≥10
  ```

- **路径分裂**：条件分支创建多条路径

  ```math
  初始状态：x↦α
  if (x > 0)   ; 路径约束：α>0
    y = x+1    ; 状态：x↦α, y↦α+1
  else         ; 路径约束：α≤0
    y = x-1    ; 状态：x↦α, y↦α-1
  ```

- **约束求解**：使用SMT求解器确定路径可达性

### 8.2 模型检查方法

模型检查是自动验证有限状态系统的形式化技术：

- **状态空间表示**：构建系统所有可能状态的图

  ```math
  S = {s₀, s₁, ...} 状态集合
  R ⊆ S×S 转移关系
  A ⊆ S 初始状态
  φ 待验证属性
  ```

- **时序逻辑表示**：用LTL/CTL等表达性质

  ```math
  AG(req → AF ack)  // 全局性：每个请求最终都会得到响应
  EF deadlock       // 存在性：系统可能进入死锁状态
  ```

- **反例生成**：当性质不满足时提供反例路径

  ```math
  s₀ → s₃ → s₇ → s₁₂  // 导致错误的执行序列
  ```

### 8.3 定理证明技术

定理证明使用严格的数学推理验证程序：

- **霍尔逻辑规则**：形式化验证基础

  ```math
  {P} C {Q}  // 如果执行前P为真，执行C后Q为真

  赋值规则：
  {P[E/x]} x := E {P}

  顺序规则：
  {P} C₁ {R}, {R} C₂ {Q}
  ----------------------
      {P} C₁; C₂ {Q}
  ```

- **循环不变量**：证明循环正确性的关键

  ```math
  {I ∧ B} C {I}  // 循环体保持不变量
  {I} while B do C {I ∧ ¬B}  // 循环终止时，不变量成立且条件不满足
  ```

- **自动定理证明工具**：如Coq、Isabelle/HOL、Z3

  ```math
  (* Coq证明示例：加法交换律 *)
  Theorem add_comm : forall n m : nat, n + m = m + n.
  Proof.
    intros n m.
    induction n as [| n' IHn'].
    - simpl. rewrite -> plus_n_O. reflexivity.
    - simpl. rewrite -> IHn'. rewrite -> plus_n_Sm. reflexivity.
  Qed.
  ```

## 思维导图-汇编分析(续)

```text
汇编语言分析(续)
├── WebAssembly比较
│   ├── 基础特性
│   │   ├── 栈式虚拟机：操作基于栈
│   │   ├── 模块化：明确导入导出
│   │   └── 二进制格式：紧凑高效
│   ├── 类型安全
│   │   ├── 静态类型：严格类型检查
│   │   ├── 内存安全：边界检查
│   │   └── 验证阶段：执行前验证
│   └── 执行模型
│       ├── 虚拟机解释：非直接硬件
│       ├── 线性内存：类数组访问
│       └── 结构化控制流：非随意跳转
├── 编译器视角
│   ├── 编译过程
│   │   ├── 前端：词法语法语义分析
│   │   ├── 中间：IR生成和优化
│   │   └── 后端：目标代码生成
│   ├── 中间表示
│   │   ├── 三地址码：基本IR形式
│   │   ├── SSA格式：单赋值形式
│   │   └── LLVM IR：通用中间表示
│   └── 优化技术
│       ├── 常量折叠：编译时计算
│       ├── 强度削减：替换为快速操作
│       └── 寄存器分配：最小化内存访问
├── 跨平台考量
│   ├── 架构比较
│   │   ├── x86-64：CISC，变长指令
│   │   ├── ARM：RISC，固定长度
│   │   └── RISC-V：开放简洁设计
│   └── 抽象策略
│       ├── 条件编译：多版本维护
│       ├── 汇编宏：模式抽象
│       └── 通用IR：跨平台中间表示
└── 高级分析
    ├── 符号执行
    │   ├── 符号状态：变量映射到表达式
    │   ├── 路径约束：积累分支条件
    │   └── 约束求解：验证路径可行性
    ├── 模型检查
    │   ├── 状态空间：系统所有可能状态
    │   ├── 时序逻辑：LTL/CTL表达性质
    │   └── 反例生成：不满足时提供路径
    └── 定理证明
        ├── 霍尔逻辑：形式化验证基础
        ├── 循环不变量：证明循环正确性
        └── 自动工具：Coq/Isabelle/Z3
```
