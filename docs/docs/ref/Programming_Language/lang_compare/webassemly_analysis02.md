# WebAssembly 与源语言的对比分析：HoTT、范畴论与控制论视角

## 目录

- [WebAssembly 与源语言的对比分析：HoTT、范畴论与控制论视角](#webassembly-与源语言的对比分析hott范畴论与控制论视角)
  - [目录](#目录)
  - [1. 引言](#1-引言)
    - [1.1 WebAssembly 简介](#11-webassembly-简介)
    - [1.2 分析视角：HoTT、范畴论、控制论](#12-分析视角hott范畴论控制论)
    - [1.3 分析目标与方法](#13-分析目标与方法)
  - [2. 形式化框架](#2-形式化框架)
    - [2.1 同伦类型论 (HoTT) 视角](#21-同伦类型论-hott-视角)
      - [2.1.1 类型即空间](#211-类型即空间)
      - [2.1.2 Wasm 类型系统的 HoTT 解读](#212-wasm-类型系统的-hott-解读)
      - [2.1.3 高阶类型与 Wasm 的局限](#213-高阶类型与-wasm-的局限)
    - [2.2 范畴论视角](#22-范畴论视角)
      - [2.2.1 类型系统即范畴](#221-类型系统即范畴)
      - [2.2.2 编译即函子](#222-编译即函子)
      - [2.2.3 Wasm 范畴的结构](#223-wasm-范畴的结构)
      - [2.2.4 结构保持与丢失](#224-结构保持与丢失)
    - [2.3 控制论视角](#23-控制论视角)
      - [2.3.1 程序即控制系统](#231-程序即控制系统)
      - [2.3.2 类型作为约束与接口](#232-类型作为约束与接口)
      - [2.3.3 控制流作为调节机制](#233-控制流作为调节机制)
      - [2.3.4 Wasm 的控制与交互](#234-wasm-的控制与交互)
  - [3. 核心要素对比分析](#3-核心要素对比分析)
    - [3.1 类型、变量与控制](#31-类型变量与控制)
      - [3.1.1 Wasm：底层、显式栈、结构化控制](#311-wasm底层显式栈结构化控制)
      - [3.1.2 源语言：抽象、词法作用域、多样化控制](#312-源语言抽象词法作用域多样化控制)
      - [3.1.3 形式化对比](#313-形式化对比)
      - [3.1.4 代码示例：Wasm 控制流原语 (WAT 格式)](#314-代码示例wasm-控制流原语-wat-格式)
    - [3.2 类型范畴：构造与关系](#32-类型范畴构造与关系)
      - [3.2.1 Wasm：基础类型与有限结构](#321-wasm基础类型与有限结构)
      - [3.2.2 源语言：丰富的类型构造](#322-源语言丰富的类型构造)
      - [3.2.3 映射分析：ADT 与面向对象的降级](#323-映射分析adt-与面向对象的降级)
      - [3.2.4 代码示例：Rust `enum` 到 Wasm 的映射 (概念性 WAT)](#324-代码示例rust-enum-到-wasm-的映射-概念性-wat)
    - [3.3 语言映射、控制流与一致性](#33-语言映射控制流与一致性)
      - [3.3.1 映射机制：编译器转换](#331-映射机制编译器转换)
      - [3.3.2 控制流转换](#332-控制流转换)
      - [3.3.3 容错与一致性](#333-容错与一致性)
      - [3.3.4 代码示例：`call_indirect` 与虚函数调用 (概念性 WAT)](#334-代码示例call_indirect-与虚函数调用-概念性-wat)
    - [3.4 类型变异性与代数运算](#34-类型变异性与代数运算)
      - [3.4.1 Wasm：基本不变性与有限子类型](#341-wasm基本不变性与有限子类型)
      - [3.4.2 源语言：协变、逆变、双变](#342-源语言协变逆变双变)
      - [3.4.3 编译挑战：变异性的擦除与编码](#343-编译挑战变异性的擦除与编码)
    - [3.5 控制流：同步与异步](#35-控制流同步与异步)
      - [3.5.1 Wasm 核心：同步执行模型](#351-wasm-核心同步执行模型)
      - [3.5.2 异步实现：宿主交互与状态机](#352-异步实现宿主交互与状态机)
      - [3.5.3 形式化模型：非同构转换（Monad视角）](#353-形式化模型非同构转换monad视角)
      - [3.5.4 控制论解释：延迟反馈](#354-控制论解释延迟反馈)
      - [3.5.5 代码示例：异步转换概念 (伪代码)](#355-代码示例异步转换概念-伪代码)
  - [4. 综合论证与结论](#4-综合论证与结论)
    - [4.1 Wasm 作为编译目标的角色](#41-wasm-作为编译目标的角色)
    - [4.2 抽象层级的差异与权衡](#42-抽象层级的差异与权衡)
    - [4.3 各形式化视角的洞见总结](#43-各形式化视角的洞见总结)
    - [4.4 未来展望](#44-未来展望)
  - [5. 思维导图 (Text)](#5-思维导图-text)

---

## 1. 引言

### 1.1 WebAssembly 简介

WebAssembly (Wasm) 是一种为现代 Web 浏览器设计的二进制指令格式，旨在成为 C/C++/Rust 等语言的高性能编译目标。它提供了一个低级、可移植、安全且高效的虚拟机环境。其设计哲学强调与 JavaScript 的互操作性，并在浏览器之外的场景（如服务器端、边缘计算）中也展现出巨大潜力。Wasm 的核心特征包括：基于栈的虚拟机、强类型系统（但类型种类有限）、结构化的控制流指令以及定义清晰的模块化和沙箱安全模型。

### 1.2 分析视角：HoTT、范畴论、控制论

本分析将采用三个不同的形式化视角来审视 Wasm 及其与源语言的关系：

- **同伦类型论 (Homotopy Type Theory, HoTT):** HoTT 将类型视为数学中的“空间”，命题视为类型，证明视为类型的项（元素），等价关系视为路径（同伦）。它提供了一个统一的基础来看待逻辑、集合论和拓扑学。我们将用其概念来探讨类型系统的深层结构和等价性。
- **范畴论 (Category Theory):** 范畴论使用对象和态射（箭头）来抽象数学结构。类型系统可以被建模为范畴，其中类型是对象，函数是态射。编译过程可以被视为不同范畴之间的函子。这有助于分析结构在转换过程中的保持和丢失。
- **控制论 (Cybernetics):** 控制论研究系统中的控制、通信和反馈。程序可以被视为目标导向的控制系统，类型定义了信息通道和约束，控制流是实现目标的调节机制。我们将用此视角分析 Wasm 的执行模型、与环境的交互以及容错性。

### 1.3 分析目标与方法

本分析旨在：

- 对比 Wasm 类型系统与典型源语言（如 Rust, TypeScript, Haskell 等）类型系统的设计差异。
- 分析源语言构造（类型、控制流）到 Wasm 的转换关系，关注信息的保持与丢失。
- 从 HoTT、范畴论、控制论的角度，对这些差异和转换进行形式化、批判性的审视。
- 通过逻辑推理、形式化概念和代码示例进行论证，避免辩证法。
- 最终输出一份包含目录和思维导图的 Markdown 文档。

## 2. 形式化框架

### 2.1 同伦类型论 (HoTT) 视角

#### 2.1.1 类型即空间

在 HoTT 中，类型被赋予了拓扑空间的含义。

- **命题即类型 (Propositions as Types):** 一个命题 `P` 可以被视为一个类型。如果该类型有元素（项），则命题 `P` 为真，该元素即为 `P` 的一个证明。
- **集合即 0-类型 (Sets as 0-types):** 类型中的任意两个元素 `x, y : T`，它们之间的所有等价路径 `p : x = y` 都是平凡的（即只有一个等价证明，如果它们相等）。这对应于传统集合论中的元素。
- **高阶类型 (Higher Types):** 类型可以具有更丰富的等价结构。例如，范畴可以看作 1-类型，其对象之间的等价路径（态射）本身可以有等价路径（自然变换），依此类推。

#### 2.1.2 Wasm 类型系统的 HoTT 解读

Wasm 的核心类型系统 (`i32`, `i64`, `f32`, `f64`, `v128`, `externref`, `funcref`) 非常基础。从 HoTT 的角度看：

- **Wasm 类型主要是 0-类型:** 这些基础类型可以被视为集合（0-类型）。`i32` 类型包含所有 32 位整数，任意两个相同的整数 `n: i32` 和 `m: i32` 之间的等价 `n = m` 是唯一的、平凡的。类型检查过程验证项（指令序列产生的值）是否属于预期的 0-类型。
- **等价性简单:** Wasm 中的等价性主要是值的位模式比较，没有 HoTT 中路径或同伦的概念。
- **函数类型 `funcref`:** 可以看作是函数集合的类型，仍然是 0-类型。两个函数引用的等价性是引用本身的等价性。

#### 2.1.3 高阶类型与 Wasm 的局限

许多现代编程语言拥有更丰富的类型系统，可能触及 HoTT 中更高阶的概念：

- **依赖类型 (Dependent Types):** 类型可以依赖于值（例如 Agda, Idris）。这使得类型可以表达更复杂的命题和结构，可能对应 HoTT 中的高阶类型。
- **精炼类型 (Refinement Types):** 类型带有谓词约束（例如 Liquid Haskell）。这可以看作是为 0-类型增加了命题层面的信息。
- **范畴同构/等价:** 在某些语言中，类型的同构或等价关系可能更受关注，这隐约触及了 HoTT 的 1-类型思想。

**结论:** Wasm 的类型系统在 HoTT 视角下非常基础，主要处理 0-类型（集合）。它缺乏表达 HoTT 中高阶结构的能力。源语言到 Wasm 的编译过程，本质上是将可能更丰富的类型结构（可能是高阶的）“拍扁”到 0-类型的世界，丢失了高维度的等价信息。

### 2.2 范畴论视角

#### 2.2.1 类型系统即范畴

一个类型系统可以自然地建模为一个范畴 `C`：

- **对象 (Objects):** `C` 的对象是类型系统中的类型。
- **态射 (Morphisms):** 从类型 `A` 到类型 `B` 的态射 `f: A -> B` 是类型为 `A -> B` 的函数或程序项。
- **组合 (Composition):** 态射的组合对应于函数的组合。
- **恒等态射 (Identity Morphism):** 每个类型 `A` 都有一个恒等函数 `id_A: A -> A`。

不同的类型系统对应于具有不同结构的范畴：

- **积类型 (Product Types, e.g., `struct`, `tuple`):** 对应范畴中的积 (Product)。
- **和类型 (Sum Types, e.g., `enum`, `union`):** 对应范畴中的余积 (Coproduct)。
- **函数类型 (Function Types):** 在笛卡尔闭范畴 (Cartesian Closed Category, CCC) 中对应指数对象 (Exponential Object)。
- **泛型/多态 (Generics/Polymorphism):** 可能涉及函子 (Functors) 或自然变换 (Natural Transformations)。

#### 2.2.2 编译即函子

从源语言 `S` 到目标语言 `T`（例如 Wasm）的编译过程 `Comp` 可以被建模为一个函子 `F: Cat(S) -> Cat(T)`，其中 `Cat(S)` 和 `Cat(T)` 分别是源语言和目标语言类型系统对应的范畴。

- `F` 将 `Cat(S)` 中的对象（源类型）映射到 `Cat(T)` 中的对象（目标类型）。
- `F` 将 `Cat(S)` 中的态射（源函数）映射到 `Cat(T)` 中的态射（目标函数/代码）。
- 函子需要保持结构：`F(g ∘ f) = F(g) ∘ F(f)` 且 `F(id_A) = id_{F(A)}`。

#### 2.2.3 Wasm 范畴的结构

Wasm 的核心类型系统形成的范畴 `Cat(Wasm)` 结构相对简单：

- **对象:** 主要是基础类型 `i32, i64, f32, f64, v128, externref, funcref`。GC 提案增加了 `struct` 和 `array`，对应有限的积。
- **态射:** Wasm 函数。函数类型 `(A*) -> (B*)` 可以看作是从积类型 `A*` 到积类型 `B*` 的态射（考虑到多值返回）。
- **结构:** 具备基础类型。结构化控制流指令（`block`, `loop`, `if`）定义了态射的构造方式。`call` 和 `call_indirect` 实现了态射的应用。它不是笛卡尔闭的（核心 Wasm 中函数不能直接作为一级值传递，需要 `funcref`）。

#### 2.2.4 结构保持与丢失

编译器作为函子 `F: Cat(Source) -> Cat(Wasm)`，其关键在于它能在多大程度上保持源范畴的结构：

- **积类型:** 通常能较好地映射（例如 `struct` -> Wasm `struct` 或内存布局）。
- **和类型:** 需要编码（例如，使用标签整数 + `br_table` 或 `if` 链），范畴的余积结构在 `Cat(Wasm)` 中没有直接对应物，结构被模拟而非直接映射。
- **函数类型/高阶函数:** 源语言中的 CCC 结构（如果存在）通常会丢失。高阶函数需要通过 `funcref` 和 `call_indirect` 来模拟闭包和函数传递，失去了类型系统层面的直接支持。
- **泛型:** 通常在编译时被单态化 (Monomorphization) 或通过类似 C++ 虚函数表的方式（类型擦除 + `call_indirect`）实现，源范畴中的参数化结构丢失。

**结论:** 范畴论视角清晰地揭示了编译过程是一种结构映射。`Cat(Wasm)` 是一个相对“贫瘠”的范畴，编译过程 `F` 不可避免地是一个“遗忘函子” (Forgetful Functor)，它丢弃了源语言范畴中丰富的结构（如余积、指数对象、参数化等），将它们编码为 `Cat(Wasm)` 中可用的更简单的结构。

### 2.3 控制论视角

#### 2.3.1 程序即控制系统

控制论将系统视为具有目标、状态、输入、输出和反馈机制的实体。一个运行的程序可以被看作一个控制系统：

- **目标:** 计算预期结果，完成特定任务。
- **状态:** 内存、寄存器、堆栈、程序计数器等。
- **输入:** 函数参数、用户输入、环境数据。
- **输出:** 返回值、副作用（I/O、状态改变）。
- **控制律/调节器:** 程序的逻辑（条件、循环、函数调用）根据当前状态和输入决定下一步动作，以趋向目标。
- **反馈:** 计算的中间结果或状态变化会影响后续的控制决策（例如，循环条件判断）。

#### 2.3.2 类型作为约束与接口

在控制论框架下，类型系统扮演着关键角色：

- **定义状态空间:** 类型限制了变量和数据结构可能的状态。
- **定义接口/通道:** 函数签名（类型）定义了组件间的通信协议（输入/输出类型），确保信息流的兼容性。
- **施加约束:** 类型检查在编译时或运行时强制执行这些约束，防止系统进入无效或不期望的状态（例如，类型错误导致的崩溃），提高了系统的可预测性和稳定性。

#### 2.3.3 控制流作为调节机制

程序的控制流结构是控制论中的调节机制：

- **`if/else`:** 基于状态（条件）选择不同的控制路径。
- **`loop`:** 基于状态（循环条件）重复执行某段控制逻辑，实现迭代逼近目标。
- **`call/return`:** 将控制权委托给子系统（函数），并在完成后收回控制权和结果。
- **异常处理:** 检测到异常状态（错误）时，转移控制到预定义的恢复逻辑，是一种故障调节机制。
- **异步:** 处理具有延迟的外部输入或操作，需要更复杂的调度和状态管理机制来协调控制。

#### 2.3.4 Wasm 的控制与交互

- **低级控制原语:** Wasm 提供结构化的控制流指令 (`block`, `loop`, `if`, `br`, `br_if`, `br_table`)，这些是构成复杂调节机制的基础模块。
- **显式状态管理:** Wasm 的栈式模型使得状态（操作数栈）的管理非常直接和底层。
- **宿主交互:** Wasm 模块通常需要与宿主环境（如 JavaScript）交互以获取输入、执行 I/O 或访问高级 API。这种交互是控制系统与外部环境的通信通道，类型（如 `externref`）和导入/导出机制定义了接口。
- **沙箱:** Wasm 的内存沙箱模型是一种强制性的边界控制，限制了 Wasm 控制系统对外部环境（宿主内存）的直接影响，增强了安全性（防止干扰其他系统）。

**结论:** 控制论视角将 Wasm 及其执行模型视为一个目标导向的、受类型约束的控制系统。其低级的控制原语和显式的状态管理提供了构建调节器的基础。与宿主环境的交互和沙箱模型体现了系统边界控制和信息交换。相比之下，高级语言提供了更抽象、更强大的控制结构（如模式匹配、monadic 控制流、async/await），这些高级调节机制在编译到 Wasm 时需要被分解为基础原语。

## 3. 核心要素对比分析

### 3.1 类型、变量与控制

#### 3.1.1 Wasm：底层、显式栈、结构化控制

- **类型:** 少数几种数值类型 (`i32`, `i64`, `f32`, `f64`, `v128`) 和引用类型 (`externref`, `funcref`)。类型检查简单且可判定。GC 提案引入了 `struct` 和 `array`。类型信息主要用于验证和指令选择。
- **变量:** 主要是函数参数 (parameters) 和局部变量 (locals)。局部变量在使用前必须声明类型。值主要在操作数栈上传递和操作，栈是隐式的但其类型状态在编译/验证时被严格跟踪。
- **控制:** 提供结构化的控制流指令 (`block`, `loop`, `if`) 和基于标签的跳转 (`br`, `br_if`, `br_table`)。不允许任意 `goto`，强制执行单一入口、单一出口（或受控多出口）的控制流图，便于优化和验证。`call` 和 `call_indirect` 用于函数调用。

#### 3.1.2 源语言：抽象、词法作用域、多样化控制

- **类型:** 通常包含丰富的类型系统，包括用户定义的代数数据类型 (ADT)、类、接口、泛型、依赖类型（某些语言）等。类型不仅用于验证，还用于代码组织、抽象和表达领域逻辑。
- **变量:** 通常具有词法作用域，变量名绑定到值。内存管理（栈、堆、垃圾回收、所有权）通常比 Wasm 的显式栈操作更抽象。
- **控制:** 提供高级控制结构，如 `match`/`switch` 表达式、`for`/`while` 循环、异常处理 (`try/catch/finally`)、协程、`async/await` 等。这些结构提供了更强的表达能力和抽象层次。

#### 3.1.3 形式化对比

- **HoTT:** Wasm 的类型和变量局限于 0-类型世界。源语言的复杂类型（如依赖类型）可能需要 HoTT 的高阶视角才能完全理解其内涵，这种内涵在编译到 Wasm 时丢失。Wasm 的结构化控制可以看作是构造特定计算“路径”的方式，但缺乏 HoTT 意义上的路径等价。
- **范畴论:** Wasm 的变量（局部变量）和栈操作对应于在 `Cat(Wasm)` 态射内部管理中间值的方式。源语言的变量和作用域规则是在更丰富的 `Cat(Source)` 中定义的。Wasm 的结构化控制流对应于 `Cat(Wasm)` 中构造态射的特定模式（如 `if` 对应于基于条件的态射选择）。高级控制结构（如 `match` 对 ADT 进行模式匹配）在 `Cat(Source)` 中有对应结构（如利用余积的注入和投影），但在 `Cat(Wasm)` 中需要被编码。
- **控制论:** Wasm 的类型、变量和控制流共同定义了一个底层的、状态显式的控制系统。源语言则提供了更高层次的抽象，允许定义更复杂的控制策略和状态表示，编译器负责将这些高级策略分解为 Wasm 的基础控制机制。类型系统在两种情况下都作为核心的约束和接口定义机制。

#### 3.1.4 代码示例：Wasm 控制流原语 (WAT 格式)

```wat
(module
  (func $example (param $a i32) (param $b i32) (result i32)
    (local $temp i32) ;; 局部变量声明

    block $my_block ;; 命名 block
      loop $my_loop ;; 命名 loop
        local.get $a
        i32.const 0
        i32.eq ;; a == 0 ?
        if ;; if (a == 0)
          ;; then 分支
          i32.const 100
          local.set $temp ;; temp = 100
          br $my_block ;; 跳出 block $my_block
        else
          ;; else 分支
          local.get $a
          i32.const 1
          i32.sub
          local.set $a ;; a = a - 1
          br $my_loop ;; 继续循环 loop $my_loop
        end
      end ;; loop 结束
    end ;; block 结束

    ;; block 跳出后会到达这里
    local.get $temp
    local.get $b
    i32.add ;; 返回 temp + b
    return
  )
)
```

这个例子展示了 Wasm 的 `local`, `block`, `loop`, `if`, `br` 指令如何协同工作，实现基本的控制逻辑。

### 3.2 类型范畴：构造与关系

#### 3.2.1 Wasm：基础类型与有限结构

- **核心类型:** `i32, i64, f32, f64, v128` (数值), `funcref, externref` (引用)。
- **GC 提案:** 增加了 `struct` (积类型/记录) 和 `array` (数组/序列)。这些是 Wasm 层面的结构化数据表示。`(struct (field i32) (field f32))` 定义了一个包含一个 `i32` 和一个 `f32` 的结构体类型。
- **关系:** 类型之间的关系非常有限。除了 GC 提案中可能的子类型关系外，核心 Wasm 类型基本是独立的。没有内置的 ADT、类或泛型概念。

#### 3.2.2 源语言：丰富的类型构造

- **原始类型:** 类似 Wasm，但种类和大小可能更多样。
- **代数数据类型 (ADT):**
  - **积类型 (Product Types):** `struct`, `record`, `tuple`。将多个类型组合在一起。范畴论中的积。
  - **和类型 (Sum Types):** `enum`, `union`, `variant`。表示一个值可能是多种类型之一。范畴论中的余积。
- **组合类型:** 数组、列表、指针、引用等。
- **抽象类型:** 类 (Class)、接口 (Interface)、Trait。定义行为和结构，支持封装、继承、多态。
- **泛型/参数化多态:** 允许编写适用于多种类型的代码 (`List<T>`)。范畴论中可能涉及函子。

#### 3.2.3 映射分析：ADT 与面向对象的降级

源语言的丰富类型构造在编译到 Wasm 时，必须被“降级” (lowered) 或编码：

- **ADT - 积类型:**
  - `struct { a: i32, b: f64 }` (Rust/C) 通常映射到 Wasm 内存中的连续布局，或者如果使用了 Wasm GC，则映射到 Wasm `struct` 类型 `(struct (field i32) (field f64))`。访问字段变成内存偏移加载或 `struct.get` 指令。结构保持相对直接。
- **ADT - 和类型:**
  - `enum Result<T, E> { Ok(T), Err(E) }` (Rust) 通常需要编码。一种常见策略是用一个整数标签（discriminant）来指示当前是哪个变体，后面跟着该变体的数据。
    - `Ok(value)` 可能编码为 `{ tag: 0, data: value }`
    - `Err(error)` 可能编码为 `{ tag: 1, data: error }`
  - 对 `enum` 的模式匹配 (`match`) 被转换为 Wasm 中的 `if` 链或 `br_table` 跳转，基于标签值进行分发。范畴论的余积结构被分解了。
- **类/对象:**
  - 对象状态（成员变量）通常映射到 Wasm 内存中的结构体布局或 Wasm `struct`。
  - 方法调用，特别是虚方法（多态），通常通过虚函数表 (VTable) 实现。VTable 是一个包含函数指针（在 Wasm 中是 `funcref` 或函数索引）的表，通常存储在对象实例的开头或通过指针访问。方法调用变成：加载对象 -> 加载 VTable 指针 -> 加载 VTable 中对应方法的函数引用/索引 -> `call_indirect`。面向对象的抽象（封装、继承、多态）被手动编码为 Wasm 的底层结构和间接调用。

#### 3.2.4 代码示例：Rust `enum` 到 Wasm 的映射 (概念性 WAT)

假设有 Rust 枚举：

```rust
enum Message {
    Quit,
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

编译到 Wasm (概念性，忽略 String 和内存管理细节，假设 String/Color 映射为 i32)：

```wat
;;; 概念性 Wasm 映射 Rust enum Message
;;; 假设内存布局: [tag: i32] [payload...]
;;; tag=0: Quit
;;; tag=1: Write(i32) ; 假设 String 句柄是 i32
;;; tag=2: ChangeColor(i32, i32, i32)

(func $process_message (param $ptr i32) ;; $ptr 是指向消息数据的指针
  (local $tag i32)
  (local $payload1 i32)
  (local $payload2 i32)
  (local $payload3 i32)

  ;; 读取 tag
  local.get $ptr
  i32.load offset=0 ;; 加载第一个 i32 作为 tag
  local.set $tag

  ;; 使用 br_table 进行分发 (类似 switch)
  block $end_switch
    block $case2
      block $case1
        block $case0
          local.get $tag ;; switch(tag)
          br_table $case0 $case1 $case2 (br $end_switch) ;; default case (optional)
        end ;; case0 结束 (Quit)
        ;; Quit 分支代码 (可能为空)
        br $end_switch ;; 跳转到 switch 结束
      end ;; case1 结束 (Write)
      ;; Write 分支代码
      local.get $ptr
      i32.load offset=4 ;; 加载 Write 的 payload (假设 String 句柄在 offset 4)
      local.set $payload1
      ;; ... 处理 payload1 ...
      br $end_switch
    end ;; case2 结束 (ChangeColor)
    ;; ChangeColor 分支代码
    local.get $ptr
    i32.load offset=4
    local.set $payload1
    local.get $ptr
    i32.load offset=8
    local.set $payload2
    local.get $ptr
    i32.load offset=12
    local.set $payload3
    ;; ... 处理 R, G, B (payload1, 2, 3) ...
    br $end_switch
  end ;; $end_switch

  ;; ... 后续代码 ...
)
```

这个例子展示了和类型如何通过标签和条件跳转 (`br_table`) 在 Wasm 中模拟。

### 3.3 语言映射、控制流与一致性

#### 3.3.1 映射机制：编译器转换

编译器（如 `rustc`, `emscripten` (C/C++), `AssemblyScript`) 负责将源语言的高级构造翻译成 Wasm 的二进制格式。这个过程包括：

- **类型映射:** 如 3.2 所述，将源类型映射或编码为 Wasm 类型和内存布局。
- **控制流转换:** 将源语言控制流（循环、条件、函数调用、异常等）映射到 Wasm 的结构化控制流指令。
- **内存管理:** 实现源语言的内存模型（如 C++ 的 `new`/`delete`，Rust 的所有权/借用检查后的底层操作，或集成 GC）通常需要编译器和运行时库 (runtime) 的支持。Wasm 本身只提供线性内存和基础的分配/增长指令（或 Wasm GC）。
- **ABI 定义:** 定义函数调用约定 (Application Binary Interface)，即参数如何传递、返回值如何返回，这对于 Wasm 模块间或与宿主环境的互操作至关重要。

#### 3.3.2 控制流转换

- **结构化控制流 (`if`, `loop`, `while`, `for`):** 通常可以比较直接地映射到 Wasm 的 `block`, `loop`, `if`, `br`, `br_if`。
- **`switch`/`match`:** 通常映射到 `br_table`（如果 case 是密集的整数）或 `if` 链。
- **函数调用:** 直接调用映射到 `call`，间接/虚调用映射到 `call_indirect`（通常涉及查找函数引用或表索引）。
- **异常处理:** 核心 Wasm 没有内置异常处理。方案包括：
    1. **返回值约定:** C 风格的错误码返回。
    2. **JavaScript 异常集成:** Emscripten 等工具链可以将 C++ 异常转换为 JavaScript 异常，反之亦然，但这需要 JS 胶水代码和性能开销。
    3. **Wasm EH (Exception Handling) 提案:** 引入新的指令 (`try`, `catch`, `throw`, `rethrow`) 在 Wasm 内部实现低开销的异常处理。这更接近源语言的异常模型。
- **异步 (`async/await`, Promises, Futures):** Wasm 核心是同步的。异步操作通常需要：
    1. **编译器转换:** 将 `async` 函数转换为状态机。每次 `await` 暂停时，保存当前状态（包括局部变量），并将控制权返回给调度器（通常是宿主环境的事件循环）。当等待的操作完成时，调度器恢复 Wasm 函数的执行，并传入结果。
    2. **宿主集成:** 依赖宿主环境（如 JS `Promise`）来处理实际的异步 I/O 或计时器。Wasm 通过导入函数与宿主异步 API 交互。

#### 3.3.3 容错与一致性

- **Wasm 层面 (模块内):**
  - **类型安全:** Wasm 的强类型系统和验证过程阻止了许多类型的内存错误（如缓冲区溢出、类型混淆）。
  - **控制流完整性:** 结构化控制流和验证确保了控制流不会跳转到非法位置。
  - **内存沙箱:** 每个 Wasm 实例拥有独立的线性内存，无法直接访问宿主或其他实例的内存，提供了强大的隔离性，这是重要的容错机制。
  - **陷阱 (Traps):** 某些运行时错误（如除以零、内存越界访问、间接调用类型不匹配）会导致 Wasm 实例“陷落”，这是一个确定的失败状态，通常由宿主处理。陷阱保证了错误不会被忽略，有助于一致性。
- **源语言层面:**
  - **语言保证:** 某些语言（如 Rust 的所有权和借用系统）在编译时提供了更强的内存安全和数据竞争安全保证。这些保证在编译到 Wasm 后仍然（大部分）有效，因为编译器确保生成的 Wasm 代码遵守这些规则。
  - **运行时系统:** 垃圾回收、复杂的异常处理机制等提供了语言层面的容错能力，这些需要在 Wasm 之上由编译器和运行时库实现。
- **对比:** Wasm 提供了基础的、强制性的安全和隔离保证（沙箱、类型安全、陷阱）。源语言则可能提供更高层次的、通过编译器和运行时实现的保证。编译过程的目标是在 Wasm 的基础上重建或模拟源语言的容错和一致性模型。控制论上，Wasm 沙箱是强边界控制，陷阱是确定的故障信号，而源语言机制是更复杂的内部状态管理和恢复策略。

#### 3.3.4 代码示例：`call_indirect` 与虚函数调用 (概念性 WAT)

假设 C++ 类：

```cpp
class Shape {
public:
    virtual float area() = 0;
};
class Circle : public Shape {
    float r;
public:
    Circle(float radius) : r(radius) {}
    float area() override { return 3.14159 * r * r; }
};
// ... VTable for Circle contains pointer to Circle::area ...
```

Wasm 调用 `shape_ptr->area()` 的概念性代码：

```wat
(module
  (table $vtable funcref) ;; 假设 VTable 存储在 table 中，或通过 funcref
  (type $shape_area_type (func (param i32) (result f32))) ;; 定义 area 函数类型: (this_ptr) -> f32

  ;; Circle::area 实现 (假设 this 指针是实例数据指针)
  (func $Circle_area (param $this i32) (result f32)
    ;; load radius 'r' from offset (e.g., 4) in the object pointed by $this
    local.get $this
    i32.const 4
    i32.add
    f32.load
    ;; calculate area
    f32.const 3.14159
    f32.mul
    local.get $this ;; load 'r' again for r*r
    i32.const 4
    i32.add
    f32.load
    f32.mul
    return
  )

  ;; 假设有一个函数获取 Circle 的 VTable 索引 (指向 $Circle_area)
  (func $get_circle_vtable_index (result i32) i32.const 0) ;; 假设 Circle::area 在 table 索引 0

  ;; 调用 shape_ptr->area()
  (func $call_virtual_area (param $shape_ptr i32) (result f32)
    (local $vtable_ptr i32)
    (local $func_index i32)

    ;; 1. 加载 VTable 指针 (假设存储在对象实例 offset 0)
    local.get $shape_ptr
    i32.load offset=0
    local.set $vtable_ptr ;; (这里简化了，实际可能是 table 索引或更复杂)

    ;; 2. 从 VTable 加载 area 函数的索引 (假设 area 在 VTable offset 0)
    local.get $vtable_ptr
    i32.load offset=0 ;; (再次简化，实际是 VTable 中的函数指针/索引)
    local.set $func_index

    ;; 3. 执行间接调用
    local.get $shape_ptr ;; 传递 this 指针作为参数
    local.get $func_index ;; 要调用的函数索引
    call_indirect $vtable (type $shape_area_type) ;; 使用正确的函数类型签名
    ;; 返回值已经在栈顶
    return
  )

  ;; (需要初始化 table $vtable, e.g., (elem (i32.const 0) $Circle_area))
)
```

这个例子展示了 `call_indirect` 如何用于实现动态分发，这是面向对象多态在 Wasm 中的典型实现方式。

### 3.4 类型变异性与代数运算

#### 3.4.1 Wasm：基本不变性与有限子类型

- **核心 Wasm:** 类型系统主要是**不变 (invariant)** 的。`i32` 就是 `i32`，不能隐式或安全地当作 `i64` 或其他类型使用（除了明确的转换指令）。函数类型 `(A) -> B` 和 `(C) -> D` 只有在 `A=C` 且 `B=D` 时才被认为是相同的（用于 `call_indirect` 的类型检查）。
- **Wasm GC 提案:** 引入了结构化类型 (`struct`, `array`) 和相应的子类型关系。例如，如果 `struct B` 扩展了 `struct A`（拥有 `A` 的所有字段加上更多字段），则 `ref B` 可以是 `ref A` 的子类型（**协变 covariant** on the reference type）。这使得 GC 对象可以具有一定的多态性。但这种子类型关系比许多面向对象语言更受限。
- **代数运算:** Wasm 类型系统本身不直接支持丰富的代数运算（如类型构造器的组合、交集类型、联合类型）。类型主要是原子性的或有限的结构组合（GC struct/array）。

#### 3.4.2 源语言：协变、逆变、双变

许多静态类型语言支持更复杂的类型变异性规则，尤其是在泛型和函数类型中：

- **不变 (Invariance):** `T` 和 `U` 不同时，`C<T>` 和 `C<U>` 没有子类型关系。例如，在 Java 中 `List<String>` 不是 `List<Object>`。
- **协变 (Covariance):** 如果 `T` 是 `U` 的子类型，则 `C<T>` 也是 `C<U>` 的子类型。例如，在 C# 中 `IEnumerable<String>` 是 `IEnumerable<Object>` 的子类型。数组在某些语言（如 Java）中是协变的（`String[]` 是 `Object[]`），但这可能导致运行时类型错误。通常用于只读或生产者场景。
- **逆变 (Contravariance):** 如果 `T` 是 `U` 的子类型，则 `C<U>` 反而是 `C<T>` 的子类型。这通常出现在函数参数类型中。如果一个函数接受 `Object` (`f: Object -> void`)，那么它也能安全地接受 `String`。因此，`Action<Object>` (接受 Object 的委托) 是 `Action<String>` (接受 String 的委托) 的子类型。通常用于只写或消费者场景。
- **双变 (Bivariance):** 同时具有协变和逆变的特性，或者在某些上下文中表现不同。较少见。

**类型代数:** 一些语言（如 TypeScript）具有更丰富的类型代数运算，如：

- **联合类型 (Union Types):** `string | number`
- **交集类型 (Intersection Types):** `A & B`
- **映射类型 (Mapped Types):** 基于现有类型构造新类型。

#### 3.4.3 编译挑战：变异性的擦除与编码

将具有复杂变异性规则的源语言编译到 Wasm（尤其是核心 Wasm）时，这些变异性信息通常会被处理掉：

- **类型擦除 (Type Erasure):** 类似于 Java 泛型的处理方式，泛型类型参数在编译后被擦除，替换为上界（如 `Object`）或具体类型。Wasm 代码操作的是擦除后的类型。运行时可能需要进行类型转换或检查。
- **单态化 (Monomorphization):** 类似于 C++ 模板或 Rust 泛型的处理方式，编译器为每个用到的具体类型参数生成一份专门的代码。例如 `List<i32>` 和 `List<f32>` 会生成两套不同的 Wasm 函数。这样避免了运行时的变异性问题，但可能导致代码膨胀。
- **编码:** 变异性信息可能被编码到运行时数据结构或 VTable 中，通过额外的检查或间接调用来模拟。

**结论:** Wasm 的核心类型系统在变异性方面非常保守（基本不变）。源语言丰富的变异性（协变、逆变）和类型代数运算在编译到 Wasm 时，其语义需要通过类型擦除、单态化或复杂的运行时编码来模拟，类型系统本身的表达能力在 Wasm 层面被大大削弱。Wasm GC 提案引入的有限子类型部分缓解了这个问题，但仍远不及许多源语言的灵活性。范畴论上，源语言类型系统中的子类型关系（可以看作特殊的态射或范畴间的包含关系）在到 `Cat(Wasm)` 的函子映射中通常不被直接保持。

### 3.5 控制流：同步与异步

#### 3.5.1 Wasm 核心：同步执行模型

Wasm 指令在一个线程内是按顺序、同步执行的。

- `call` 指令会立即转移控制权到被调用函数，并等待其返回，然后继续执行下一条指令。整个过程是阻塞的。
- Wasm 实例内部没有内置的并发或异步执行原语。

#### 3.5.2 异步实现：宿主交互与状态机

WebAssembly 要执行异步操作（如网络请求、文件 I/O、计时器），必须依赖宿主环境（如浏览器 JS 或 Node.js）并采用特定策略：

1. **宿主驱动:** Wasm 代码调用一个导入的宿主函数（例如，启动一个 JS `fetch` 请求）。这个宿主函数会启动异步操作并立即返回（通常返回一个 Promise ID 或不返回）。Wasm 代码的执行会暂停（通常是整个函数返回到宿主）。
2. **回调/Promise:** 当宿主的异步操作完成时，宿主环境会调用一个从 Wasm 导出的函数（回调），并将结果传递给它。或者，宿主通过某种机制（如共享内存、消息传递）通知 Wasm，Wasm 在其事件循环（如果由运行时实现）中检查并处理结果。
3. **编译器转换 (Async/Await):** 对于源语言中的 `async/await`，编译器通常执行以下转换：
    - 将 `async` 函数分割成多个部分，每个 `await` 点是一个分割点。
    - 创建一个状态机来管理函数的执行状态和局部变量。
    - 当遇到 `await` 时，调用宿主异步函数，保存当前状态，并将控制权返回给宿主/调度器。
    - 当异步操作完成，宿主/调度器调用 Wasm 状态机的“恢复”入口点，传入结果，恢复状态，并从上次暂停的地方继续执行。

#### 3.5.3 形式化模型：非同构转换（Monad视角）

同步和异步执行模型在结构上是不同的，它们的转换不是简单的同构关系。

- **同步函数:** 可以看作是从类型 `A` 到类型 `B` 的纯粹映射 `A -> B`。
- **异步函数:** 更准确的模型是返回一个“承诺”或“未来”结果，例如 `A -> Promise<B>` (JavaScript) 或 `A -> Future<B>` (Rust)。

从范畴论角度看，异步操作可以用 Monad 来建模：

- 例如，`Promise` 或 `Future` 类型构造器可以看作是一个 Monad `M`。一个异步函数 `A -> MB` (接受 `A` 返回一个 `M<B>`)。
- `async` 对应于进入 `M` Monad 的计算。
- `await` 对应于 Monad 的 `bind` 操作 ( >>= )，它允许将一个普通函数 `B -> C` 应用到 `M<B>` 上，或者将一个异步函数 `B -> M<C>` 链接到 `M<B>` 之后，得到 `M<C>`。

将源语言的 `async/await` (Monadic 结构) 编译为 Wasm 的同步状态机，是一个复杂的转换过程。它将 Monadic 的组合逻辑（由 `bind` 体现）展开为显式的状态管理和控制流跳转。这个转换过程本身可以形式化描述，但结果（Wasm 状态机）与源异步代码在结构上不再是直接的同构。

#### 3.5.4 控制论解释：延迟反馈

在控制论中，同步执行可以看作是具有即时反馈的控制回路。输入 -> 处理 -> 输出/状态更新 -> 下一步决策，都在一个紧密的时间循环内。

异步执行则引入了**延迟反馈**。控制系统发出一个动作（例如，请求数据），但其结果（反馈）不会立即到达。系统需要：

1. **发出请求并挂起:** 启动外部操作，保存当前控制状态。
2. **处理其他任务:** 在等待期间，系统可能切换到处理其他控制流或任务（如果有多任务调度）。
3. **接收并处理反馈:** 当延迟的反馈（异步结果）到达时，系统需要恢复之前的控制状态，并将反馈整合到决策过程中。

Wasm 的状态机转换正是实现了这种管理延迟反馈的机制：状态变量记录了挂起点的上下文，调度器负责在反馈到达时重新激活正确的控制路径。

#### 3.5.5 代码示例：异步转换概念 (伪代码)

源语言 (TypeScript-like):

```typescript
async function fetchData(url: string): Promise<string> {
  console.log("Fetching...");
  const response = await fetch(url); // 异步点 1
  console.log("Parsing...");
  const text = await response.text(); // 异步点 2
  console.log("Done.");
  return text;
}
```

编译后的 Wasm 状态机 (概念性伪代码/WAT 风格):

```wat
;; 状态机状态变量 (通常在内存中)
(global $fetchData_state i32 (mut) (i32.const 0)) ;; 0: initial, 1: awaiting fetch, 2: awaiting text
(global $fetchData_url i32 (mut)) ;; 保存 url 指针
(global $fetchData_response i32 (mut)) ;; 保存 response 句柄

;; 导入宿主 fetch 函数 (启动异步操作)
(import "host" "start_fetch" (func $start_fetch (param i32) (result i32))) ;; url_ptr -> promise_id
;; 导入宿主 text 函数 (启动异步操作)
(import "host" "start_response_text" (func $start_response_text (param i32) (result i32))) ;; response_handle -> promise_id

;; Wasm 函数入口/状态机驱动
(func $fetchData_resume (param $arg i32) (result i32) ;; $arg 是上次异步操作的结果/句柄, 返回 0=继续, 1=完成, -1=错误
  (local $promise_id i32)

  block $exit_func
    block $state2
      block $state1
        block $state0
          global.get $fetchData_state
          br_table $state0 $state1 $state2 (br $exit_func) ;; 跳转到当前状态的处理
        end ;; $state0: Initial state
        ;; console.log("Fetching..."); (调用导入的 log 函数)
        global.get $fetchData_url
        call $start_fetch
        local.set $promise_id ;; 记录需要等待的 Promise
        i32.const 1
        global.set $fetchData_state ;; 更新状态为 1 (awaiting fetch)
        ;; 保存局部变量 (如果需要)
        ;; 返回 $promise_id 或特殊值，告诉调度器需要等待
        return ... ;; 返回控制权给调度器

      end ;; $state1: Resumed after fetch returned
      ;; $arg 包含 response 句柄
      global.set $fetchData_response $arg ;; 保存 response 句柄
      ;; console.log("Parsing...");
      global.get $fetchData_response
      call $start_response_text
      local.set $promise_id
      i32.const 2
      global.set $fetchData_state ;; 更新状态为 2 (awaiting text)
      ;; 保存状态...
      return ... ;; 返回控制权

    end ;; $state2: Resumed after response.text returned
    ;; $arg 包含 text 结果 (假设是 i32 句柄)
    ;; console.log("Done.");
    ;; 保存最终结果 $arg 到某个地方
    i32.const 0
    global.set $fetchData_state ;; 重置状态 (可选)
    ;; 返回 1 表示完成
    i32.const 1
    return
  end ;; $exit_func
  ;; 错误处理或默认返回
  i32.const -1 ;; 表示错误
  return
)

;; 初始调用
(func $call_fetchData (param $url_ptr i32)
  global.set $fetchData_url $url_ptr ;; 设置初始参数
  i32.const 0 ;; 初始调用时 arg 通常无意义
  call $fetchData_resume
  ;; ... 处理 $fetchData_resume 的返回值 (启动等待等) ...
)
```

这个伪代码展示了 `async` 函数如何被分解为状态 (`$fetchData_state`) 和基于状态的跳转。
每次 `await`（对应于调用 `$start_fetch` 或 `$start_response_text`）后，
函数保存状态并返回，等待宿主在未来某个时刻带着结果调用 `$fetchData_resume` 来继续执行。

## 4. 综合论证与结论

### 4.1 Wasm 作为编译目标的角色

WebAssembly 被设计为一个高效、可移植且安全的**底层编译目标**。它并非旨在直接提供源语言级别的高级抽象。其类型系统、控制流和执行模型都是为了满足这个目标而精心选择的：

- **简单性:** 有助于快速验证、编译和优化。
- **底层性:** 允许编译器精确控制代码生成和内存布局，以实现接近原生的性能。
- **安全性:** 沙箱模型和类型/控制流验证提供了关键的安全保障。
- **可移植性:** 二进制格式和虚拟机设计使其能在不同平台和环境中运行。

### 4.2 抽象层级的差异与权衡

Wasm 与典型源语言之间存在显著的抽象层级差异：

- **源语言:** 提供丰富的类型系统（ADT, 类, 泛型, 变异性）、高级控制流（异常, 异步）、自动内存管理等，旨在提高开发效率、代码可读性和表达能力。
- **Wasm:** 提供基础类型、结构化控制流和线性内存。高级抽象必须由编译器**编码**或**模拟**在这些基础之上。

这种差异导致了编译过程中的权衡：

- **结构丢失:** 如 HoTT 和范畴论视角所示，源语言中丰富的类型结构（高阶类型、余积、指数对象、参数化多态、变异性）在编译到 Wasm 时通常会丢失或被大幅简化/编码。
- **性能 vs. 抽象:** Wasm 的底层性允许高性能执行，但代价是失去了源语言的抽象表达能力。编译器的工作是在这两者之间找到平衡，通过优化将高级抽象高效地映射到底层指令。
- **运行时开销:** 模拟某些高级特性（如复杂的 GC、异常处理、反射、动态类型）可能需要在 Wasm 之上引入显著的运行时系统开销。

### 4.3 各形式化视角的洞见总结

- **HoTT:** 强调了 Wasm 类型系统的“维度”很低（主要是 0-类型/集合），缺乏表达源语言中可能存在的更深层次的等价结构（路径、同伦）的能力。编译过程是向低维空间的“投影”。
- **范畴论:** 将编译形式化为范畴间的函子，清晰地展示了结构（积、余积、指数对象）在映射过程中的保持与丢失。`Cat(Wasm)` 是一个相对简单的范畴，迫使编译器成为一个“遗忘”丰富源结构的函子。
- **控制论:** 将程序执行视为控制系统，类型是约束，控制流是调节机制。Wasm 提供了基础的控制原语和强制的边界控制（沙箱）。源语言的高级控制结构（如异步）是更复杂的调节策略，需要被分解为 Wasm 的基础机制，并常常涉及与外部环境（宿主）的交互和延迟反馈管理。

### 4.4 未来展望

Wasm 的标准仍在不断发展中，许多提案旨在弥合与源语言的差距，例如：

- **GC:** 提供对托管语言更高效的支持，引入结构化类型和有限子类型。
- **异常处理:** 提供原生、低开销的异常机制。
- **线程:** 引入多线程支持。
- **接口类型 (Interface Types):** 旨在改进模块间和与宿主环境交互的高级类型支持。
- **尾调用 (Tail Call Optimization):** 支持某些函数式编程模式。

这些提案如果被采纳，将丰富 `Cat(Wasm)` 的结构，使得编译器函子能够保持更多的源语言特性，减少运行时模拟的开销，并可能在 HoTT 和控制论视角下提供更强大的表达和控制能力。然而，Wasm 的核心设计哲学——作为一种底层、安全、高效的编译目标——可能仍会使其与功能最丰富的源语言类型系统之间保持一定的距离。

最终，WebAssembly 的成功在于它在性能、安全性、可移植性和与现有生态（特别是 Web）的兼容性之间取得了有效的平衡，即使这意味着在 Wasm 层面牺牲了源语言的部分类型和控制抽象。理解这种权衡以及其背后的形式化结构，对于设计编译器、运行时以及利用 Wasm 的开发者都至关重要。

---

## 5. 思维导图 (Text)

```text
WebAssembly 与源语言对比分析
│
├── 1. 引言
│   ├── 1.1 Wasm 简介 (底层、安全、高效编译目标)
│   ├── 1.2 分析视角 (HoTT, 范畴论, 控制论)
│   └── 1.3 分析目标与方法 (形式化、批判性、无辩证法)
│
├── 2. 形式化框架
│   ├── 2.1 HoTT 视角
│   │   ├── 类型即空间 (0-类型/集合 vs 高阶类型)
│   │   ├── Wasm 类型系统解读 (主要是 0-类型, 等价性简单)
│   │   └── 局限性 (无法表达高阶结构, 编译是降维)
│   ├── 2.2 范畴论视角
│   │   ├── 类型系统即范畴 (对象=类型, 态射=函数)
│   │   ├── 编译即函子 (F: Cat(Source) -> Cat(Wasm))
│   │   ├── Wasm 范畴结构 (基础类型, 有限积(GC), 结构化控制构造态射)
│   │   └── 结构保持与丢失 (积ok, 余积/指数/泛型需编码/丢失, 遗忘函子)
│   └── 2.3 控制论视角
│       ├── 程序即控制系统 (目标, 状态, 输入/输出, 反馈, 控制律)
│       ├── 类型作为约束与接口 (定义状态空间/通道, 保证稳定)
│       ├── 控制流作为调节机制 (if/loop/call/异常/异步)
│       └── Wasm 的控制与交互 (低级原语, 显式状态, 宿主交互, 沙箱=边界控制)
│
├── 3. 核心要素对比分析
│   ├── 3.1 类型、变量与控制
│   │   ├── Wasm (基础类型, 显式栈/局部变量, 结构化控制)
│   │   ├── 源语言 (丰富类型, 词法作用域, 多样化控制)
│   │   └── 形式化对比 (HoTT: 0-类型; Cat: 简单态射构造; Cyber: 底层控制系统)
│   ├── 3.2 类型范畴：构造与关系
│   │   ├── Wasm (基础类型, GC struct/array)
│   │   ├── 源语言 (ADT(积/和), 类, 接口, 泛型)
│   │   └── 映射分析 (积->内存/struct; 和->标签+跳转; 类->struct+VTable+call_indirect)
│   ├── 3.3 语言映射、控制流与一致性
│   │   ├── 映射机制 (编译器转换: 类型/控制流/内存/ABI)
│   │   ├── 控制流转换 (结构化->直接; switch->br_table; 异常->返回码/JS/EH提案; 异步->状态机+宿主)
│   │   └── 容错与一致性 (Wasm: 类型安全/沙箱/陷阱; 源: 语言保证+运行时)
│   ├── 3.4 类型变异性与代数运算
│   │   ├── Wasm (核心不变, GC有限协变子类型, 无代数)
│   │   ├── 源语言 (协变, 逆变, 双变, 联合/交集类型)
│   │   └── 编译挑战 (类型擦除, 单态化, 运行时编码)
│   └── 3.5 控制流：同步与异步
│       ├── Wasm 核心 (同步, 阻塞 call)
│       ├── 异步实现 (宿主交互, 回调/Promise, 编译器状态机转换)
│       ├── 形式化模型 (非同构转换, Monad M<T>, bind -> 状态切换)
│       └── 控制论解释 (同步=即时反馈, 异步=延迟反馈管理)
│
└── 4. 综合论证与结论
    ├── 4.1 Wasm 角色 (底层编译目标)
    ├── 4.2 抽象层级差异与权衡 (结构丢失, 性能 vs 抽象, 运行时开销)
    ├── 4.3 各形式化视角洞见总结 (HoTT:维度; Cat:遗忘函子; Cyber:控制层级)
    └── 4.4 未来展望 (Wasm 提案: GC, EH, 线程, 接口类型...)
```
