# rust pointer

## 目录

- [rust pointer](#rust-pointer)
  - [目录](#目录)
  - [1. 引用（References）](#1-引用references)
  - [2. 原始指针（Raw Pointers）](#2-原始指针raw-pointers)
  - [3. 智能指针（Smart Pointers）](#3-智能指针smart-pointers)
  - [4. 其他指针类型](#4-其他指针类型)
  - [总结](#总结)

下面介绍一下 Rust 中不同种类的指针以及它们各自的特点和适用场景。
Rust 的指针大体可以分为**安全指针**和**不安全指针**，
其中安全指针主要包括引用和各种智能指针，而不安全指针主要是原始指针。

## 1. 引用（References）

- **不可变引用：`&T`**  
  - **特点**：只读借用数据，保证在引用期间数据不会被修改。  
  - **安全性**：由借用检查器（borrow checker）在编译期保证，不允许数据竞争。  
  - **使用场景**：读取数据、作为参数传递时使用，确保数据不会意外修改。

- **可变引用：`&mut T`**  
  - **特点**：允许对数据进行修改，但同一作用域内同一时间只能有一个可变引用。  
  - **安全性**：同样由编译器借用检查器保证，防止同一数据的多重修改。  
  - **使用场景**：需要更改数据时使用；
  在使用可变引用时要注意不能同时存在其他引用（无论是可变还是不可变）。

## 2. 原始指针（Raw Pointers）

- **不可变原始指针：`*const T`**  
- **可变原始指针：`*mut T`**  
  - **特点**：
    - 类似于 C 语言中的指针，可以执行指针算术，可以是空指针，允许绕过 Rust 的借用检查。  
    - 没有编译器自动提供的内存安全保证。
  - **安全性**：需要在 `unsafe` 块中进行解引用和其它操作，使用时程序员必须手动保证内存安全。  
  - **使用场景**：主要用于与 C 语言交互（FFI），或者需要底层内存操作、性能调优等场合。

```rust:src/main.rs
fn main() {
    let x = 42;
    let raw_ptr: *const i32 = &x as *const i32;

    unsafe {
        // 访问原始指针操作必须放在 unsafe 块中
        println!("通过原始指针访问数据: {}", *raw_ptr);
    }
}
```

## 3. 智能指针（Smart Pointers）

智能指针不仅仅是指针，还封装了所有权和生命周期管理，常见的有：

- **Box`<T>`**
  - **特点**：提供对堆上数据的唯一所有权，当 Box 离开作用域时自动释放堆内存。  
  - **使用场景**：用于递归数据结构、需要在堆上分配大数据时。

- **Rc`<T>`（Reference Counted）**
  - **特点**：引用计数智能指针，在单线程环境下允许数据的多重所有权。  
  - **使用场景**：在无需可变共享的单线程场景下，实现多个所有者共同拥有数据。

- **Arc`<T>`（Atomic Reference Counted）**
  - **特点**：与 Rc 相似，但使用原子操作计数，适用于多线程环境。  
  - **使用场景**：多线程并发共享数据时使用。

这些智能指针内部实现了 Drop 等 trait，确保资源在生命周期结束时正确释放，同时简化了内存管理。

## 4. 其他指针类型

- **NonNull`<T>`**
  - **特点**：一种包装了非空原始指针的类型，常用于底层库中作为高级抽象的构建块。  
  - **优势**：确保指针不会是 null，适合作为 unsafe API 中的内部类型。

- **函数指针**
  - **特点**：像 `fn(i32) -> i32` 这样的类型，指向一段可执行代码，可以作为参数传递或存储回调。  
  - **使用场景**：实现类似回调函数或函数表（vtable）的功能时使用。

- **内部可变性相关指针**  
  - **Cell`<T>` 和 RefCell`<T>`**：提供在不可变引用中获得“可变”行为的能力，
  用于实现内部可变性。  
  - **注意**：这些类型本身并不是裸指针，但它们依赖于借用检查的“运行时”版本，
  可能在使用不当时引发运行时 panic。

在 Rust 中，`*mut T` 是一种**原始可变指针（raw mutable pointer）**的类型声明。这意味着：

- 它指向类型 `T` 的内存地址，并且允许通过指针修改该内存内容。
- 与引用（如 `&mut T`）不同，原始指针不受编译器借用规则的约束，
  也不具备生命周期信息，因此它们的使用都需要在 `unsafe` 块中进行，以确保内存安全。
- 原始指针可以为空（null pointer），并且没有自动解引用行为，所有解引用操作均为不安全行为。

下面是一个简单的示例代码，展示了如何声明和使用 `*mut T`：

```rust:src/main.rs
fn main() {
    let mut value = 42;
    // 获取 value 的可变原始指针
    let ptr: *mut i32 = &mut value as *mut i32;

    unsafe {
        // 解引用原始指针并修改内存中的值
        *ptr = 100;
    }

    println!("value: {}", value); // 输出 value: 100
}
```

在这个示例中：

- `ptr` 被声明为 `*mut i32`，表示它是指向 `i32` 类型的一个内存地址的可变原始指针。
- 由于原始指针不保证内存安全，所以在解引用（例如 `*ptr = 100`）时
必须使用 `unsafe` 块来明确表示你已经检查了相关不安全性问题。

总的来说，`*mut T` 提供了一种底层的指针操作能力，类似于 C/C++ 中的指针，
但在 Rust 中需要额外的 `unsafe` 保障来处理内存安全问题。

## 总结

Rust 的指针类型具有以下特点：

1. **安全引用（&T 和 &mut T）**：由编译器静态检查，保证内存和线程安全。
2. **原始指针（*const T 和 *mut T）**：提供 C 语言风格的指针操作，
所有相关操作需要在 unsafe 块中进行，安全性由程序员保证。
3. **智能指针（Box、Rc、Arc 等）**：封装了所有权和生命周期管理，
简化资源管理，兼顾安全性与高效性。
4. **其他辅助指针类型（NonNull、函数指针等）**：
为高级抽象和特定应用场景提供了更细粒度的内存控制手段。

通过合理选择和使用各种指针类型，
Rust 程序既能保持内存安全和并发安全，又能在必要时实现底层高性能操作。
