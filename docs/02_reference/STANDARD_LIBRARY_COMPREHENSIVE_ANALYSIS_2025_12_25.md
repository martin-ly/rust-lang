# Rust æ ‡å‡†åº“å…¨é¢åˆ†æä¸è®ºè¯æ–‡æ¡£

**åˆ›å»ºæ—¥æœŸ**: 2025-12-25
**æœ€åæ›´æ–°**: 2025-12-25
**Rust ç‰ˆæœ¬**: 1.93.0+ | Edition 2024
**çŠ¶æ€**: âœ… **Rust 1.93.0 æ›´æ–°å®Œæˆ**ï¼ˆå†å²å¿«ç…§æ–‡æ¡£ï¼‰

---

## ğŸ“‹ ç›®å½•

- [Rust æ ‡å‡†åº“å…¨é¢åˆ†æä¸è®ºè¯æ–‡æ¡£](#rust-æ ‡å‡†åº“å…¨é¢åˆ†æä¸è®ºè¯æ–‡æ¡£)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ–‡æ¡£ç›®æ ‡](#-æ–‡æ¡£ç›®æ ‡)
  - [ğŸ“š 1. æ ‡å‡†åº“æ¦‚è¿°](#-1-æ ‡å‡†åº“æ¦‚è¿°)
    - [1.1 æ ‡å‡†åº“çš„å®šä¹‰å’Œå®šä½](#11-æ ‡å‡†åº“çš„å®šä¹‰å’Œå®šä½)
      - [å®šä¹‰](#å®šä¹‰)
      - [å®šä½](#å®šä½)
    - [1.2 æ ‡å‡†åº“çš„è®¾è®¡å“²å­¦](#12-æ ‡å‡†åº“çš„è®¾è®¡å“²å­¦)
      - [1.2.1 é›¶æˆæœ¬æŠ½è±¡ (Zero-Cost Abstractions)](#121-é›¶æˆæœ¬æŠ½è±¡-zero-cost-abstractions)
      - [1.2.2 å†…å­˜å®‰å…¨ (Memory Safety)](#122-å†…å­˜å®‰å…¨-memory-safety)
      - [1.2.3 æ˜¾å¼é”™è¯¯å¤„ç† (Explicit Error Handling)](#123-æ˜¾å¼é”™è¯¯å¤„ç†-explicit-error-handling)
    - [1.3 Rust 1.92.0 æ ‡å‡†åº“æ–°ç‰¹æ€§](#13-rust-1920-æ ‡å‡†åº“æ–°ç‰¹æ€§)
      - [1.3.1 Box::new\_zeroed å’Œ Box::new\_zeroed\_slice](#131-boxnew_zeroed-å’Œ-boxnew_zeroed_slice)
      - [1.3.2 Rc::new\_zeroed å’Œ Arc::new\_zeroed](#132-rcnew_zeroed-å’Œ-arcnew_zeroed)
      - [1.3.3 è¿­ä»£å™¨æ–¹æ³•ç‰¹åŒ–](#133-è¿­ä»£å™¨æ–¹æ³•ç‰¹åŒ–)
    - [1.4 Rust 1.93.0 æ ‡å‡†åº“æ–°ç‰¹æ€§ ğŸ†•](#14-rust-1930-æ ‡å‡†åº“æ–°ç‰¹æ€§-)
      - [1.4.1 MaybeUninit API å¢å¼º](#141-maybeuninit-api-å¢å¼º)
      - [1.4.2 String å’Œ Vec åŸå§‹éƒ¨åˆ†è®¿é—®](#142-string-å’Œ-vec-åŸå§‹éƒ¨åˆ†è®¿é—®)
      - [1.4.3 VecDeque æ¡ä»¶å¼¹å‡º](#143-vecdeque-æ¡ä»¶å¼¹å‡º)
      - [1.4.4 æ•´æ•°æ“ä½œå¢å¼º](#144-æ•´æ•°æ“ä½œå¢å¼º)
      - [1.4.5 åˆ‡ç‰‡åˆ°æ•°ç»„è½¬æ¢](#145-åˆ‡ç‰‡åˆ°æ•°ç»„è½¬æ¢)
      - [1.4.6 Duration æ‰©å±•](#146-duration-æ‰©å±•)
      - [1.4.7 char å¸¸é‡](#147-char-å¸¸é‡)
      - [1.4.8 fmt::from\_fn](#148-fmtfrom_fn)
    - [1.5 Rust 1.93.0 æ ‡å‡†åº“è¡Œä¸ºå˜æ›´ âš ï¸](#15-rust-1930-æ ‡å‡†åº“è¡Œä¸ºå˜æ›´-ï¸)
      - [1.5.1 Copy ç‰¹åŒ–ç§»é™¤](#151-copy-ç‰¹åŒ–ç§»é™¤)
      - [1.5.2 BTree::append è¡Œä¸ºå˜æ›´](#152-btreeappend-è¡Œä¸ºå˜æ›´)
      - [1.5.3 vec::IntoIter RefUnwindSafe æ”¾å®½](#153-vecintoiter-refunwindsafe-æ”¾å®½)
  - [ğŸ“Š 2. æ ¸å¿ƒæ ‡å‡†åº“æ¨¡å—åˆ†æ](#-2-æ ¸å¿ƒæ ‡å‡†åº“æ¨¡å—åˆ†æ)
    - [2.1 é›†åˆç±»å‹ (std::collections)](#21-é›†åˆç±»å‹-stdcollections)
      - [2.1.1 HashMap\<K, V\>](#211-hashmapk-v)
      - [2.1.2 Vec](#212-vec)
      - [2.1.3 VecDeque](#213-vecdeque)
    - [2.2 å¹¶å‘ç±»å‹ (std::sync)](#22-å¹¶å‘ç±»å‹-stdsync)
      - [2.2.1 Arc](#221-arc)
      - [2.2.2 Mutex](#222-mutex)
      - [2.2.3 RwLock](#223-rwlock)
    - [2.3 I/O ç±»å‹ (std::io)](#23-io-ç±»å‹-stdio)
      - [2.3.1 Read å’Œ Write Traits](#231-read-å’Œ-write-traits)
      - [2.3.2 BufRead Trait](#232-bufread-trait)
    - [2.4 çº¿ç¨‹ç±»å‹ (std::thread)](#24-çº¿ç¨‹ç±»å‹-stdthread)
      - [2.4.1 Thread](#241-thread)
      - [2.4.2 JoinHandle](#242-joinhandle)
    - [2.5 è¿›ç¨‹ç±»å‹ (std::process)](#25-è¿›ç¨‹ç±»å‹-stdprocess)
      - [2.5.1 Command](#251-command)
    - [2.6 æ—¶é—´ç±»å‹ (std::time)](#26-æ—¶é—´ç±»å‹-stdtime)
      - [2.6.1 Instant](#261-instant)
      - [2.6.2 Duration](#262-duration)
    - [2.7 é”™è¯¯å¤„ç† (std::error, std::result)](#27-é”™è¯¯å¤„ç†-stderror-stdresult)
      - [2.7.1 Result\<T, E\>](#271-resultt-e)
      - [2.7.2 Option](#272-option)
  - [ğŸ” 3. æ ‡å‡†åº“è®¾è®¡è®ºè¯](#-3-æ ‡å‡†åº“è®¾è®¡è®ºè¯)
    - [3.1 é›¶æˆæœ¬æŠ½è±¡](#31-é›¶æˆæœ¬æŠ½è±¡)
    - [3.2 æ‰€æœ‰æƒç³»ç»Ÿ](#32-æ‰€æœ‰æƒç³»ç»Ÿ)
    - [3.3 å†…å­˜å®‰å…¨](#33-å†…å­˜å®‰å…¨)
    - [3.4 æ€§èƒ½ä¼˜åŒ–](#34-æ€§èƒ½ä¼˜åŒ–)
  - [ğŸ“ 4. æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ](#-4-æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ)
    - [4.1 ä½•æ—¶ä½¿ç”¨æ ‡å‡†åº“](#41-ä½•æ—¶ä½¿ç”¨æ ‡å‡†åº“)
    - [4.2 ä½•æ—¶ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“](#42-ä½•æ—¶ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“)
    - [4.3 æ ‡å‡†åº“ä¸ç¬¬ä¸‰æ–¹åº“çš„æƒè¡¡](#43-æ ‡å‡†åº“ä¸ç¬¬ä¸‰æ–¹åº“çš„æƒè¡¡)
  - [ğŸ“ 5. é¡¹ç›®ä¸­çš„æ ‡å‡†åº“ä½¿ç”¨](#-5-é¡¹ç›®ä¸­çš„æ ‡å‡†åº“ä½¿ç”¨)
    - [5.1 å„æ¨¡å—çš„æ ‡å‡†åº“ä½¿ç”¨æƒ…å†µ](#51-å„æ¨¡å—çš„æ ‡å‡†åº“ä½¿ç”¨æƒ…å†µ)
      - [C01 æ‰€æœ‰æƒä¸å€Ÿç”¨](#c01-æ‰€æœ‰æƒä¸å€Ÿç”¨)
      - [C04 æ³›å‹ç¼–ç¨‹](#c04-æ³›å‹ç¼–ç¨‹)
      - [C05 çº¿ç¨‹ä¸å¹¶å‘](#c05-çº¿ç¨‹ä¸å¹¶å‘)
      - [C07 è¿›ç¨‹ç®¡ç†](#c07-è¿›ç¨‹ç®¡ç†)
      - [C08 ç®—æ³•](#c08-ç®—æ³•)
    - [5.2 æ ‡å‡†åº“ä½¿ç”¨ç¤ºä¾‹](#52-æ ‡å‡†åº“ä½¿ç”¨ç¤ºä¾‹)
      - [ç¤ºä¾‹ 1: ä½¿ç”¨ HashMap](#ç¤ºä¾‹-1-ä½¿ç”¨-hashmap)
      - [ç¤ºä¾‹ 2: ä½¿ç”¨ Arc å’Œ Mutex](#ç¤ºä¾‹-2-ä½¿ç”¨-arc-å’Œ-mutex)
      - [ç¤ºä¾‹ 3: ä½¿ç”¨ Command](#ç¤ºä¾‹-3-ä½¿ç”¨-command)
    - [5.3 æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ](#53-æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ)
      - [å®è·µ 1: ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“](#å®è·µ-1-ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“)
      - [å®è·µ 2: å……åˆ†åˆ©ç”¨æ ‡å‡†åº“ç‰¹æ€§](#å®è·µ-2-å……åˆ†åˆ©ç”¨æ ‡å‡†åº“ç‰¹æ€§)
      - [å®è·µ 3: ç†è§£æ ‡å‡†åº“çš„å®ç°](#å®è·µ-3-ç†è§£æ ‡å‡†åº“çš„å®ç°)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## ğŸ¯ æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£æ—¨åœ¨ï¼š

1. **å…¨é¢åˆ†æ** Rust æ ‡å‡†åº“çš„æ ¸å¿ƒæ¨¡å—å’ŒåŠŸèƒ½
2. **æ·±å…¥è®ºè¯** æ ‡å‡†åº“çš„è®¾è®¡ç†å¿µå’Œå®ç°åŸç†
3. **æä¾›æŒ‡å—** æ ‡å‡†åº“çš„ä½¿ç”¨æœ€ä½³å®è·µ
4. **å¯¹é½éªŒè¯** ç¡®ä¿é¡¹ç›®ä¸ Rust 1.93.0 æ ‡å‡†åº“å¯¹é½
5. **å®è·µå‚è€ƒ** æä¾›é¡¹ç›®ä¸­æ ‡å‡†åº“ä½¿ç”¨çš„ç¤ºä¾‹å’Œè®ºè¯

---

## ğŸ“š 1. æ ‡å‡†åº“æ¦‚è¿°

### 1.1 æ ‡å‡†åº“çš„å®šä¹‰å’Œå®šä½

**æ ‡å‡†åº“ (Standard Library)** æ˜¯ Rust è¯­è¨€çš„æ ¸å¿ƒåº“ï¼Œæä¾›äº† Rust ç¨‹åºçš„åŸºç¡€åŠŸèƒ½ã€‚

#### å®šä¹‰

æ ‡å‡†åº“ `std` æ˜¯ Rust è¯­è¨€çš„æ ¸å¿ƒåº“ï¼ŒåŒ…å«ï¼š

- **åŸºç¡€ç±»å‹**: `String`, `Vec`, `Option`, `Result` ç­‰
- **é›†åˆç±»å‹**: `HashMap`, `VecDeque`, `HashSet` ç­‰
- **å¹¶å‘ç±»å‹**: `Arc`, `Mutex`, `RwLock` ç­‰
- **I/O ç±»å‹**: `File`, `Read`, `Write` ç­‰
- **çº¿ç¨‹ç±»å‹**: `Thread`, `JoinHandle` ç­‰
- **è¿›ç¨‹ç±»å‹**: `Command`, `Child` ç­‰
- **æ—¶é—´ç±»å‹**: `Instant`, `Duration` ç­‰
- **é”™è¯¯å¤„ç†**: `Error` trait, `Result` ç­‰

#### å®šä½

æ ‡å‡†åº“åœ¨ Rust ç”Ÿæ€ä¸­çš„å®šä½ï¼š

1. **æœ€å°ä¾èµ–**: æ ‡å‡†åº“æ˜¯ Rust ç¨‹åºçš„æœ€å°ä¾èµ–
2. **ç¨³å®šä¿è¯**: æ ‡å‡†åº“ API ç¨³å®šï¼Œå‘åå…¼å®¹
3. **æ€§èƒ½ä¿è¯**: æ ‡å‡†åº“ç»è¿‡é«˜åº¦ä¼˜åŒ–
4. **å®‰å…¨ä¿è¯**: æ ‡å‡†åº“éµå¾ª Rust å®‰å…¨ä¿è¯

### 1.2 æ ‡å‡†åº“çš„è®¾è®¡å“²å­¦

Rust æ ‡å‡†åº“çš„è®¾è®¡å“²å­¦å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š

#### 1.2.1 é›¶æˆæœ¬æŠ½è±¡ (Zero-Cost Abstractions)

æ ‡å‡†åº“æä¾›çš„æŠ½è±¡ä¸åº”è¯¥å¸¦æ¥è¿è¡Œæ—¶å¼€é”€ã€‚

**è®ºè¯**:

```rust
// Vec<T> åœ¨è¿è¡Œæ—¶ä¸æ‰‹åŠ¨ç®¡ç†çš„å†…å­˜ç­‰ä»·
let vec: Vec<i32> = vec![1, 2, 3];
// ç¼–è¯‘åçš„ä»£ç ä¸æ‰‹åŠ¨å†…å­˜ç®¡ç†ç­‰ä»·

// Option<T> åœ¨ç¼–è¯‘æ—¶ä¼˜åŒ–
let opt: Option<i32> = Some(42);
// None å’Œ Some åœ¨ç¼–è¯‘åçš„ä»£ç ä¸­ä¸å ç”¨é¢å¤–ç©ºé—´ï¼ˆä½¿ç”¨ niche optimizationï¼‰
```

#### 1.2.2 å†…å­˜å®‰å…¨ (Memory Safety)

æ ‡å‡†åº“çš„æ‰€æœ‰ API éƒ½éµå¾ª Rust çš„å†…å­˜å®‰å…¨ä¿è¯ã€‚

**è®ºè¯**:

```rust
// Vec<T> è‡ªåŠ¨ç®¡ç†å†…å­˜ï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾
let mut vec = Vec::new();
vec.push(1);
// vec ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾å†…å­˜

// å€Ÿç”¨æ£€æŸ¥å™¨ç¡®ä¿ä¸ä¼šå‡ºç°æ•°æ®ç«äº‰
let vec = vec![1, 2, 3];
let slice = &vec[..];  // ä¸å¯å˜å€Ÿç”¨
// vec.push(4);  // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½åœ¨å€Ÿç”¨æ—¶ä¿®æ”¹
```

#### 1.2.3 æ˜¾å¼é”™è¯¯å¤„ç† (Explicit Error Handling)

æ ‡å‡†åº“ä½¿ç”¨ `Result<T, E>` å’Œ `Option<T>` è¿›è¡Œæ˜¾å¼é”™è¯¯å¤„ç†ã€‚

**è®ºè¯**:

```rust
// æ‰€æœ‰å¯èƒ½å¤±è´¥çš„æ“ä½œéƒ½è¿”å› Result
let file = std::fs::File::open("file.txt")?;
// å¿…é¡»å¤„ç†å¯èƒ½çš„é”™è¯¯ï¼Œæ— æ³•å¿½ç•¥

// Option ç”¨äºå¯èƒ½ä¸ºç©ºçš„å€¼
let value = Some(42);
match value {
    Some(v) => println!("{}", v),
    None => println!("No value"),
}
```

### 1.3 Rust 1.92.0 æ ‡å‡†åº“æ–°ç‰¹æ€§

Rust 1.92.0 æ ‡å‡†åº“å¼•å…¥äº†ä»¥ä¸‹æ–°ç‰¹æ€§ï¼š

#### 1.3.1 Box::new_zeroed å’Œ Box::new_zeroed_slice

å…è®¸åˆ›å»ºé›¶åˆå§‹åŒ–çš„ `Box`ã€‚

**è®ºè¯**:

```rust
// Rust 1.92.0 æ–°ç‰¹æ€§
use std::alloc::Layout;

// åˆ›å»ºé›¶åˆå§‹åŒ–çš„ Box
let boxed: Box<[u8; 1024]> = Box::new_zeroed();
let boxed = unsafe { boxed.assume_init() };

// é¿å…ä¸å¿…è¦çš„åˆå§‹åŒ–ï¼Œæé«˜æ€§èƒ½
```

**è®¾è®¡åŠ¨æœº**:

- **æ€§èƒ½**: é¿å…ä¸å¿…è¦çš„åˆå§‹åŒ–
- **å®‰å…¨**: ä½¿ç”¨ `MaybeUninit` ç¡®ä¿å®‰å…¨
- **çµæ´»æ€§**: å…è®¸æ‰‹åŠ¨åˆå§‹åŒ–

#### 1.3.2 Rc::new_zeroed å’Œ Arc::new_zeroed

å…è®¸åˆ›å»ºé›¶åˆå§‹åŒ–çš„ `Rc` å’Œ `Arc`ã€‚

**è®ºè¯**:

```rust
// Rust 1.92.0 æ–°ç‰¹æ€§
use std::rc::Rc;
use std::sync::Arc;

// åˆ›å»ºé›¶åˆå§‹åŒ–çš„ Rc
let rc: Rc<[u8; 1024]> = Rc::new_zeroed();
let rc = unsafe { rc.assume_init() };

// åˆ›å»ºé›¶åˆå§‹åŒ–çš„ Arc
let arc: Arc<[u8; 1024]> = Arc::new_zeroed();
let arc = unsafe { arc.assume_init() };
```

**è®¾è®¡åŠ¨æœº**:

- **ä¸€è‡´æ€§**: ä¸ `Box::new_zeroed` ä¿æŒä¸€è‡´
- **æ€§èƒ½**: é¿å…ä¸å¿…è¦çš„åˆå§‹åŒ–
- **å®‰å…¨**: ä½¿ç”¨ `MaybeUninit` ç¡®ä¿å®‰å…¨

#### 1.3.3 è¿­ä»£å™¨æ–¹æ³•ç‰¹åŒ–

`Iterator::eq` å’Œ `Iterator::eq_by` ä¸º `TrustedLen` è¿­ä»£å™¨ç‰¹åŒ–ã€‚

**è®ºè¯**:

```rust
// Rust 1.92.0 æ€§èƒ½ä¼˜åŒ–
let vec1 = vec![1, 2, 3, 4, 5];
let vec2 = vec![1, 2, 3, 4, 5];

// å¯¹äº TrustedLen è¿­ä»£å™¨ï¼Œä½¿ç”¨æ›´ä¼˜åŒ–çš„å®ç°
let equal = vec1.iter().eq(vec2.iter());
// ç¼–è¯‘æ—¶ä¼˜åŒ–ï¼Œè¿è¡Œæ—¶æ€§èƒ½æ›´å¥½
```

**è®¾è®¡åŠ¨æœº**:

- **æ€§èƒ½**: åˆ©ç”¨è¿­ä»£å™¨é•¿åº¦ä¿¡æ¯ä¼˜åŒ–
- **å…¼å®¹æ€§**: ä¸å½±å“ç°æœ‰ä»£ç 
- **æ¸è¿›å¼**: é€æ­¥ä¼˜åŒ–å¸¸ç”¨æ“ä½œ

---

### 1.4 Rust 1.93.0 æ ‡å‡†åº“æ–°ç‰¹æ€§ ğŸ†•

Rust 1.93.0 æ ‡å‡†åº“å¼•å…¥äº†ä»¥ä¸‹æ–°ç‰¹æ€§ï¼š

#### 1.4.1 MaybeUninit API å¢å¼º

**æ–°å¢æ–¹æ³•**ï¼š

```rust
// Rust 1.93.0 æ–°ç‰¹æ€§
use std::mem::MaybeUninit;

let mut uninit = MaybeUninit::<String>::uninit();

// âœ… 1.93 æ–°å¢ï¼šå®‰å…¨åœ°è·å–å¼•ç”¨
let reference: &String = unsafe { uninit.assume_init_ref() };
let mutable: &mut String = unsafe { uninit.assume_init_mut() };

// âœ… 1.93 æ–°å¢ï¼šå®‰å…¨åœ°è°ƒç”¨ drop
unsafe { uninit.assume_init_drop() };

// âœ… 1.93 æ–°å¢ï¼šä»åˆ‡ç‰‡å†™å…¥
let src = [1, 2, 3];
let mut dst = [MaybeUninit::<i32>::uninit(); 3];
MaybeUninit::write_copy_of_slice(&mut dst, &src);
MaybeUninit::write_clone_of_slice(&mut dst, &src);
```

**è®¾è®¡åŠ¨æœº**ï¼š

- **å®‰å…¨æ€§**: æä¾›æ›´å®‰å…¨çš„æœªåˆå§‹åŒ–å†…å­˜æ“ä½œ
- **ä¾¿åˆ©æ€§**: ç®€åŒ– MaybeUninit çš„ä½¿ç”¨
- **æ€§èƒ½**: é›¶æˆæœ¬æŠ½è±¡

#### 1.4.2 String å’Œ Vec åŸå§‹éƒ¨åˆ†è®¿é—®

```rust
// âœ… 1.93 æ–°å¢ï¼šè·å– String çš„åŸå§‹éƒ¨åˆ†
let s = String::from("hello");
let (ptr, len, capacity) = s.into_raw_parts();
let s = unsafe { String::from_raw_parts(ptr, len, capacity) };

// âœ… 1.93 æ–°å¢ï¼šè·å– Vec çš„åŸå§‹éƒ¨åˆ†
let v = vec![1, 2, 3];
let (ptr, len, capacity) = v.into_raw_parts();
let v = unsafe { Vec::from_raw_parts(ptr, len, capacity) };
```

#### 1.4.3 VecDeque æ¡ä»¶å¼¹å‡º

```rust
use std::collections::VecDeque;

let mut deque = VecDeque::from([1, 2, 3, 4, 5]);

// âœ… 1.93 æ–°å¢ï¼šæ¡ä»¶å¼¹å‡º
if let Some(value) = deque.pop_front_if(|&x| x > 2) {
    println!("Popped: {}", value);  // è¾“å‡º: Popped: 3
}

if let Some(value) = deque.pop_back_if(|&x| x < 5) {
    println!("Popped: {}", value);  // è¾“å‡º: Popped: 4
}
```

#### 1.4.4 æ•´æ•°æ“ä½œå¢å¼º

```rust
// âœ… 1.93 æ–°å¢ï¼šæœªæ£€æŸ¥çš„æ•´æ•°æ“ä½œ
let x: i32 = 10;

// æœªæ£€æŸ¥çš„å–åï¼ˆä¸ä¼šæ£€æŸ¥æº¢å‡ºï¼‰
let neg = unsafe { x.unchecked_neg() };

// æœªæ£€æŸ¥çš„å·¦ç§»/å³ç§»
let shifted_left = unsafe { x.unchecked_shl(2) };
let shifted_right = unsafe { x.unchecked_shr(2) };

// æ— ç¬¦å·æ•´æ•°ä¹Ÿæœ‰ç±»ä¼¼æ–¹æ³•
let y: u32 = 10;
let shifted = unsafe { y.unchecked_shl(2) };
```

#### 1.4.5 åˆ‡ç‰‡åˆ°æ•°ç»„è½¬æ¢

```rust
// âœ… 1.93 æ–°å¢ï¼šåˆ‡ç‰‡åˆ°æ•°ç»„çš„å®‰å…¨è½¬æ¢
let slice = &[1, 2, 3, 4];
let array: &[i32; 4] = slice.as_array().unwrap();

let mut slice = &mut [1, 2, 3, 4];
let array: &mut [i32; 4] = slice.as_mut_array().unwrap();
```

#### 1.4.6 Duration æ‰©å±•

```rust
use std::time::Duration;

// âœ… 1.93 æ–°å¢ï¼šä» u128 çº³ç§’åˆ›å»º Duration
let nanos: u128 = 1_000_000_000;
let duration = Duration::from_nanos_u128(nanos);
assert_eq!(duration.as_secs(), 1);
```

#### 1.4.7 char å¸¸é‡

```rust
// âœ… 1.93 æ–°å¢ï¼šchar çš„æœ€å¤§ UTF-8/UTF-16 é•¿åº¦å¸¸é‡
assert_eq!(char::MAX_LEN_UTF8, 4);
assert_eq!(char::MAX_LEN_UTF16, 2);
```

#### 1.4.8 fmt::from_fn

```rust
use std::fmt;

// âœ… 1.93 æ–°å¢ï¼šä»å‡½æ•°åˆ›å»ºæ ¼å¼åŒ–å™¨
let formatter = fmt::from_fn(|f: &mut fmt::Formatter<'_>| {
    write!(f, "Custom: {}", 42)
});

println!("{}", formatter);  // è¾“å‡º: Custom: 42
```

---

### 1.5 Rust 1.93.0 æ ‡å‡†åº“è¡Œä¸ºå˜æ›´ âš ï¸

Rust 1.93.0 å¯¹æ ‡å‡†åº“å†…éƒ¨å®ç°è¿›è¡Œäº†è‹¥å¹²ä¿®æ­£ï¼Œå¯èƒ½å½±å“ç°æœ‰ä»£ç æˆ–æ€§èƒ½ï¼š

#### 1.5.1 Copy ç‰¹åŒ–ç§»é™¤

**å˜æ›´**ï¼šæ ‡å‡†åº“åœæ­¢åœ¨ `Copy` trait ä¸Šä½¿ç”¨å†…éƒ¨ç‰¹åŒ–ï¼ˆspecializationï¼‰ï¼Œå› å…¶åœ¨å­˜åœ¨ç”Ÿå‘½å‘¨æœŸä¾èµ–çš„ `Copy` å®ç°æ—¶å­˜åœ¨ soundness é—®é¢˜ã€‚

**å½±å“**ï¼šéƒ¨åˆ†æ ‡å‡†åº“ API å¯èƒ½æ”¹ä¸ºè°ƒç”¨ `Clone::clone` è€Œéä½å¤åˆ¶ï¼Œå¯¼è‡´**æ½œåœ¨æ€§èƒ½å›å½’**ã€‚

**åœºæ™¯**ï¼šå¯¹ `Copy` ç±»å‹è¿›è¡Œå¤§é‡å¤åˆ¶çš„çƒ­ç‚¹è·¯å¾„ï¼ˆå¦‚ `Iterator::collect`ã€åˆ‡ç‰‡æ“ä½œï¼‰å¯èƒ½ç•¥å¾®å˜æ…¢ã€‚

**å‚è€ƒ**ï¼š[PR #135634](https://github.com/rust-lang/rust/pull/135634)

#### 1.5.2 BTree::append è¡Œä¸ºå˜æ›´

**å˜æ›´**ï¼š`BTreeMap::append` å’Œ `BTreeSet` ç›¸å…³ append æ“ä½œä¸å†æ›´æ–°ç›®æ ‡ä¸­å·²å­˜åœ¨çš„ keyã€‚

**åŸè¡Œä¸º**ï¼šappend æ—¶è‹¥æºä¸ç›®æ ‡æœ‰ç›¸åŒ keyï¼Œä¼šè¦†ç›–ç›®æ ‡ä¸­çš„å€¼ã€‚

**æ–°è¡Œä¸º**ï¼šappend æ—¶è‹¥æºä¸ç›®æ ‡æœ‰ç›¸åŒ keyï¼Œ**ä¸æ›´æ–°**ç›®æ ‡ä¸­çš„å€¼ï¼Œä¿ç•™ç›®æ ‡åŸæœ‰æ¡ç›®ã€‚

**å½±å“**ï¼šä¾èµ–ã€Œappend è¦†ç›–ã€è¯­ä¹‰çš„ä»£ç éœ€æ”¹ä¸ºæ˜¾å¼ `insert` æˆ– `entry` APIã€‚

```rust
// 1.93 è¡Œä¸ºï¼šç›¸åŒ key ä¸è¦†ç›–
let mut target = BTreeMap::new();
target.insert(1, "a");

let mut source = BTreeMap::new();
source.insert(1, "b");

target.append(&mut source);
// target[1] ä»ä¸º "a"ï¼Œä¸å†å˜ä¸º "b"
```

**å‚è€ƒ**ï¼š[PR #145628](https://github.com/rust-lang/rust/pull/145628)

#### 1.5.3 vec::IntoIter RefUnwindSafe æ”¾å®½

**å˜æ›´**ï¼š`vec::IntoIter<T>` ä¸å†è¦æ±‚ `T: RefUnwindSafe` å³å¯å®ç° `UnwindSafe`ã€‚

**å½±å“**ï¼šåŒ…å« `!RefUnwindSafe` ç±»å‹çš„ `Vec` çš„ `into_iter()` ç°åœ¨å¯ä»¥åœ¨ `catch_unwind` ç­‰éœ€è¦ `UnwindSafe` çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ã€‚

**å‚è€ƒ**ï¼š[PR #145665](https://github.com/rust-lang/rust/pull/145665)

---

## ğŸ“Š 2. æ ¸å¿ƒæ ‡å‡†åº“æ¨¡å—åˆ†æ

### 2.1 é›†åˆç±»å‹ (std::collections)

#### 2.1.1 HashMap<K, V>

**å®šä¹‰**: åŸºäºå“ˆå¸Œè¡¨çš„é”®å€¼å¯¹æ˜ å°„ã€‚

**è®¾è®¡è®ºè¯**:

1. **å“ˆå¸Œè¡¨é€‰æ‹©**: ä½¿ç”¨å¼€æ”¾åœ°å€æ³•ï¼Œæ€§èƒ½ä¼˜äºé“¾è¡¨æ³•
2. **è´Ÿè½½å› å­**: é»˜è®¤ 0.75ï¼Œå¹³è¡¡ç©ºé—´å’Œæ€§èƒ½
3. **å“ˆå¸Œç®—æ³•**: ä½¿ç”¨ SipHashï¼Œé˜²æ­¢å“ˆå¸Œæ”»å‡»

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::collections::HashMap;

let mut map = HashMap::new();
map.insert("key1", "value1");
map.insert("key2", "value2");

// è·å–å€¼
if let Some(value) = map.get("key1") {
    println!("{}", value);
}

// éå†
for (key, value) in &map {
    println!("{}: {}", key, value);
}
```

**æ€§èƒ½åˆ†æ**:

- **å¹³å‡æ—¶é—´å¤æ‚åº¦**: O(1) æ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤
- **æœ€åæ—¶é—´å¤æ‚åº¦**: O(n) æ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤ï¼ˆå“ˆå¸Œå†²çªï¼‰
- **ç©ºé—´å¤æ‚åº¦**: O(n)

#### 2.1.2 Vec<T>

**å®šä¹‰**: åŠ¨æ€æ•°ç»„ï¼Œè‡ªåŠ¨æ‰©å®¹ã€‚

**è®¾è®¡è®ºè¯**:

1. **è¿ç»­å†…å­˜**: å…ƒç´ åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨ï¼Œç¼“å­˜å‹å¥½
2. **æ‰©å®¹ç­–ç•¥**: å®¹é‡ç¿»å€ï¼Œæ‘Šé”€ O(1) æ’å…¥
3. **é›¶æˆæœ¬æŠ½è±¡**: ç¼–è¯‘åä¸æ‰‹åŠ¨å†…å­˜ç®¡ç†ç­‰ä»·

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
let mut vec = Vec::new();
vec.push(1);
vec.push(2);
vec.push(3);

// è®¿é—®å…ƒç´ 
let first = vec[0];
let last = vec.last().unwrap();

// è¿­ä»£
for item in &vec {
    println!("{}", item);
}
```

**æ€§èƒ½åˆ†æ**:

- **å¹³å‡æ—¶é—´å¤æ‚åº¦**: O(1) æ’å…¥ï¼ˆæ‘Šé”€ï¼‰ã€O(1) è®¿é—®
- **æœ€åæ—¶é—´å¤æ‚åº¦**: O(n) æ’å…¥ï¼ˆæ‰©å®¹æ—¶ï¼‰
- **ç©ºé—´å¤æ‚åº¦**: O(n)

#### 2.1.3 VecDeque<T>

**å®šä¹‰**: åŒç«¯é˜Ÿåˆ—ï¼Œæ”¯æŒä¸¤ç«¯æ“ä½œã€‚

**è®¾è®¡è®ºè¯**:

1. **ç¯å½¢ç¼“å†²åŒº**: ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºå®ç°ï¼Œä¸¤ç«¯æ“ä½œéƒ½æ˜¯ O(1)
2. **å†…å­˜æ•ˆç‡**: æ¯” `Vec` æ›´èŠ‚çœå†…å­˜ï¼ˆä¸éœ€è¦ç§»åŠ¨å…ƒç´ ï¼‰
3. **ç¼“å­˜å‹å¥½**: å…ƒç´ åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::collections::VecDeque;

let mut deque = VecDeque::new();
deque.push_back(1);
deque.push_front(2);
deque.push_back(3);

// ä»ä¸¤ç«¯å¼¹å‡º
let front = deque.pop_front();
let back = deque.pop_back();
```

**æ€§èƒ½åˆ†æ**:

- **æ—¶é—´å¤æ‚åº¦**: O(1) ä¸¤ç«¯æ’å…¥ã€åˆ é™¤ã€è®¿é—®
- **ç©ºé—´å¤æ‚åº¦**: O(n)

### 2.2 å¹¶å‘ç±»å‹ (std::sync)

#### 2.2.1 Arc<T>

**å®šä¹‰**: åŸå­å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œçº¿ç¨‹å®‰å…¨ã€‚

**è®¾è®¡è®ºè¯**:

1. **åŸå­æ“ä½œ**: ä½¿ç”¨åŸå­æ“ä½œå®ç°å¼•ç”¨è®¡æ•°ï¼Œçº¿ç¨‹å®‰å…¨
2. **å…±äº«æ‰€æœ‰æƒ**: å¤šä¸ªçº¿ç¨‹å¯ä»¥å…±äº«æ•°æ®æ‰€æœ‰æƒ
3. **ä¸å¯å˜**: `Arc<T>` æœ¬èº«ä¸å¯å˜ï¼Œéœ€è¦ `Mutex` ç­‰å®ç°å¯å˜

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::sync::Arc;
use std::thread;

let data = Arc::new(vec![1, 2, 3]);

let handles: Vec<_> = (0..3).map(|i| {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        println!("Thread {}: {:?}", i, data);
    })
}).collect();

for handle in handles {
    handle.join().unwrap();
}
```

**æ€§èƒ½åˆ†æ**:

- **å¼•ç”¨è®¡æ•°**: ä½¿ç”¨åŸå­æ“ä½œï¼Œæœ‰æ€§èƒ½å¼€é”€
- **å…‹éš†å¼€é”€**: `Arc::clone` åªæ˜¯å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå¼€é”€å°
- **å†…å­˜å¼€é”€**: æ¯ä¸ª `Arc` å¢åŠ  16 å­—èŠ‚ï¼ˆ64ä½ç³»ç»Ÿï¼‰

#### 2.2.2 Mutex<T>

**å®šä¹‰**: äº’æ–¥é”ï¼Œä¿æŠ¤å…±äº«æ•°æ®ã€‚

**è®¾è®¡è®ºè¯**:

1. **äº’æ–¥è®¿é—®**: åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®æ•°æ®
2. **RAII**: ä½¿ç”¨ `MutexGuard` å®ç° RAIIï¼Œè‡ªåŠ¨é‡Šæ”¾é”
3. **ä¸­æ¯’æœºåˆ¶**: çº¿ç¨‹ panic æ—¶æ ‡è®°é”ä¸ºä¸­æ¯’ï¼Œé˜²æ­¢æ•°æ®ä¸ä¸€è‡´

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(0));

let handles: Vec<_> = (0..10).map(|_| {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let mut num = data.lock().unwrap();
        *num += 1;
    })
}).collect();

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *data.lock().unwrap());
```

**æ€§èƒ½åˆ†æ**:

- **é”ç«äº‰**: å¤šçº¿ç¨‹ç«äº‰é”æ—¶æœ‰æ€§èƒ½å¼€é”€
- **é˜»å¡**: è·å–é”å¤±è´¥æ—¶çº¿ç¨‹é˜»å¡
- **å†…å­˜å¼€é”€**: æ¯ä¸ª `Mutex` å¢åŠ  24 å­—èŠ‚ï¼ˆ64ä½ç³»ç»Ÿï¼‰

#### 2.2.3 RwLock<T>

**å®šä¹‰**: è¯»å†™é”ï¼Œæ”¯æŒå¤šä¸ªè¯»è€…æˆ–ä¸€ä¸ªå†™è€…ã€‚

**è®¾è®¡è®ºè¯**:

1. **è¯»å†™åˆ†ç¦»**: å¤šä¸ªè¯»è€…å¯ä»¥å¹¶å‘è®¿é—®ï¼Œæé«˜æ€§èƒ½
2. **å†™è€…ä¼˜å…ˆ**: å†™è€…ä¼˜å…ˆäºè¯»è€…ï¼Œé˜²æ­¢å†™è€…é¥¥é¥¿
3. **RAII**: ä½¿ç”¨ `RwLockReadGuard` å’Œ `RwLockWriteGuard` å®ç° RAII

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::sync::{Arc, RwLock};
use std::thread;

let data = Arc::new(RwLock::new(0));

// å¤šä¸ªè¯»è€…
let readers: Vec<_> = (0..5).map(|_| {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let num = data.read().unwrap();
        println!("Reader: {}", *num);
    })
}).collect();

// ä¸€ä¸ªå†™è€…
let writer = {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let mut num = data.write().unwrap();
        *num += 1;
    })
};

for handle in readers {
    handle.join().unwrap();
}
writer.join().unwrap();
```

**æ€§èƒ½åˆ†æ**:

- **è¯»è€…å¹¶å‘**: å¤šä¸ªè¯»è€…å¯ä»¥å¹¶å‘è®¿é—®ï¼Œæ€§èƒ½ä¼˜äº `Mutex`
- **å†™è€…é˜»å¡**: å†™è€…éœ€è¦ç­‰å¾…æ‰€æœ‰è¯»è€…é‡Šæ”¾é”
- **å†…å­˜å¼€é”€**: æ¯ä¸ª `RwLock` å¢åŠ  40 å­—èŠ‚ï¼ˆ64ä½ç³»ç»Ÿï¼‰

### 2.3 I/O ç±»å‹ (std::io)

#### 2.3.1 Read å’Œ Write Traits

**å®šä¹‰**: I/O æ“ä½œçš„æŠ½è±¡æ¥å£ã€‚

**è®¾è®¡è®ºè¯**:

1. **ç»Ÿä¸€æ¥å£**: æ‰€æœ‰ I/O æ“ä½œä½¿ç”¨ç»Ÿä¸€çš„ trait
2. **é›¶æˆæœ¬æŠ½è±¡**: trait å¯¹è±¡åœ¨è¿è¡Œæ—¶æ²¡æœ‰é¢å¤–å¼€é”€
3. **ç»„åˆæ€§**: å¯ä»¥ä½¿ç”¨è£…é¥°å™¨æ¨¡å¼ç»„åˆ I/O æ“ä½œ

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::io::{Read, Write};
use std::fs::File;

// è¯»å–æ–‡ä»¶
let mut file = File::open("file.txt")?;
let mut contents = String::new();
file.read_to_string(&mut contents)?;

// å†™å…¥æ–‡ä»¶
let mut file = File::create("output.txt")?;
file.write_all(b"Hello, world!")?;
```

#### 2.3.2 BufRead Trait

**å®šä¹‰**: å¸¦ç¼“å†²çš„è¯»å–æ¥å£ã€‚

**è®¾è®¡è®ºè¯**:

1. **æ€§èƒ½**: ä½¿ç”¨ç¼“å†²åŒºå‡å°‘ç³»ç»Ÿè°ƒç”¨
2. **ä¾¿åˆ©æ€§**: æä¾›æŒ‰è¡Œè¯»å–ç­‰ä¾¿åˆ©æ–¹æ³•
3. **ç»„åˆæ€§**: å¯ä»¥ä¸ `Read` trait ç»„åˆ

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::io::{BufRead, BufReader};
use std::fs::File;

let file = File::open("file.txt")?;
let reader = BufReader::new(file);

for line in reader.lines() {
    let line = line?;
    println!("{}", line);
}
```

### 2.4 çº¿ç¨‹ç±»å‹ (std::thread)

#### 2.4.1 Thread

**å®šä¹‰**: çº¿ç¨‹æŠ½è±¡ã€‚

**è®¾è®¡è®ºè¯**:

1. **å¹³å°æŠ½è±¡**: è·¨å¹³å°çš„çº¿ç¨‹æŠ½è±¡
2. **æ‰€æœ‰æƒ**: çº¿ç¨‹æ‹¥æœ‰å…¶æ•°æ®çš„æ‰€æœ‰æƒ
3. **ç”Ÿå‘½å‘¨æœŸ**: çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸä¸ `JoinHandle` ç»‘å®š

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::thread;

let handle = thread::spawn(|| {
    println!("Hello from thread!");
});

handle.join().unwrap();
```

#### 2.4.2 JoinHandle<T>

**å®šä¹‰**: çº¿ç¨‹å¥æŸ„ï¼Œç”¨äºç­‰å¾…çº¿ç¨‹å®Œæˆã€‚

**è®¾è®¡è®ºè¯**:

1. **è¿”å›å€¼**: å¯ä»¥è·å–çº¿ç¨‹è¿”å›å€¼
2. **é˜»å¡**: `join()` æ–¹æ³•é˜»å¡ç›´åˆ°çº¿ç¨‹å®Œæˆ
3. **é”™è¯¯å¤„ç†**: `join()` è¿”å› `Result`ï¼Œå¤„ç† panic

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::thread;

let handle = thread::spawn(|| {
    42
});

let result = handle.join().unwrap();
println!("Thread returned: {}", result);
```

### 2.5 è¿›ç¨‹ç±»å‹ (std::process)

#### 2.5.1 Command

**å®šä¹‰**: è¿›ç¨‹å‘½ä»¤æ„å»ºå™¨ã€‚

**è®¾è®¡è®ºè¯**:

1. **æ„å»ºå™¨æ¨¡å¼**: ä½¿ç”¨æ„å»ºå™¨æ¨¡å¼ï¼ŒAPI æ¸…æ™°
2. **è·¨å¹³å°**: è·¨å¹³å°çš„è¿›ç¨‹ç®¡ç†
3. **å®‰å…¨æ€§**: é˜²æ­¢å‘½ä»¤æ³¨å…¥ç­‰å®‰å…¨é—®é¢˜

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::process::Command;

let output = Command::new("echo")
    .arg("Hello, world!")
    .output()?;

println!("{}", String::from_utf8(output.stdout)?);
```

### 2.6 æ—¶é—´ç±»å‹ (std::time)

#### 2.6.1 Instant

**å®šä¹‰**: å•è°ƒæ—¶é—´ç‚¹ï¼Œç”¨äºæµ‹é‡æ—¶é—´é—´éš”ã€‚

**è®¾è®¡è®ºè¯**:

1. **å•è°ƒæ€§**: ä¸å—ç³»ç»Ÿæ—¶é—´è°ƒæ•´å½±å“
2. **ç²¾åº¦**: é«˜ç²¾åº¦æ—¶é—´æµ‹é‡
3. **æ€§èƒ½**: é›¶æˆæœ¬æŠ½è±¡ï¼Œç¼–è¯‘åç›´æ¥è°ƒç”¨ç³»ç»Ÿ API

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::time::Instant;

let start = Instant::now();
// æ‰§è¡Œä¸€äº›æ“ä½œ
let duration = start.elapsed();
println!("è€—æ—¶: {:?}", duration);
```

#### 2.6.2 Duration

**å®šä¹‰**: æ—¶é—´é—´éš”ã€‚

**è®¾è®¡è®ºè¯**:

1. **ç±»å‹å®‰å…¨**: ä½¿ç”¨ç±»å‹ç³»ç»Ÿé˜²æ­¢å•ä½é”™è¯¯
2. **ç²¾åº¦**: çº³ç§’çº§ç²¾åº¦
3. **ä¾¿åˆ©æ€§**: æä¾›å¤šç§å•ä½è½¬æ¢æ–¹æ³•

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::time::Duration;

let duration = Duration::from_secs(5);
let millis = duration.as_millis();
println!("{} æ¯«ç§’", millis);
```

### 2.7 é”™è¯¯å¤„ç† (std::error, std::result)

#### 2.7.1 Result<T, E>

**å®šä¹‰**: è¡¨ç¤ºæˆåŠŸæˆ–å¤±è´¥çš„ç»“æœã€‚

**è®¾è®¡è®ºè¯**:

1. **æ˜¾å¼é”™è¯¯å¤„ç†**: å¼ºåˆ¶å¤„ç†é”™è¯¯ï¼Œé˜²æ­¢å¿½ç•¥
2. **ç±»å‹å®‰å…¨**: ä½¿ç”¨ç±»å‹ç³»ç»ŸåŒºåˆ†æˆåŠŸå’Œå¤±è´¥
3. **ç»„åˆæ€§**: å¯ä»¥ä½¿ç”¨ `?` æ“ä½œç¬¦ç»„åˆé”™è¯¯å¤„ç†

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
use std::fs::File;
use std::io::Read;

fn read_file(path: &str) -> std::io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

#### 2.7.2 Option<T>

**å®šä¹‰**: è¡¨ç¤ºå¯èƒ½ä¸ºç©ºçš„å€¼ã€‚

**è®¾è®¡è®ºè¯**:

1. **ç©ºå€¼å®‰å…¨**: ä½¿ç”¨ç±»å‹ç³»ç»Ÿé˜²æ­¢ç©ºæŒ‡é’ˆ
2. **é›¶æˆæœ¬**: `Option<T>` ä¸ `T` åœ¨å†…å­˜ä¸­å¤§å°ç›¸åŒï¼ˆä½¿ç”¨ niche optimizationï¼‰
3. **ç»„åˆæ€§**: å¯ä»¥ä½¿ç”¨ `?` æ“ä½œç¬¦å’Œç»„åˆå­

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
let value: Option<i32> = Some(42);

match value {
    Some(v) => println!("Value: {}", v),
    None => println!("No value"),
}

// ä½¿ç”¨ map å’Œ and_then ç»„åˆ
let result = value
    .map(|v| v * 2)
    .and_then(|v| if v > 0 { Some(v) } else { None });
```

---

## ğŸ” 3. æ ‡å‡†åº“è®¾è®¡è®ºè¯

### 3.1 é›¶æˆæœ¬æŠ½è±¡

**å®šä¹‰**: æŠ½è±¡ä¸åº”è¯¥å¸¦æ¥è¿è¡Œæ—¶å¼€é”€ã€‚

**è®ºè¯**:

1. **ç¼–è¯‘æ—¶ä¼˜åŒ–**: Rust ç¼–è¯‘å™¨å¯ä»¥è¿›è¡Œé›¶æˆæœ¬æŠ½è±¡ä¼˜åŒ–
2. **å†…è”**: å°å‡½æ•°å¯ä»¥å†…è”ï¼Œæ¶ˆé™¤å‡½æ•°è°ƒç”¨å¼€é”€
3. **å•æ€åŒ–**: æ³›å‹ä»£ç å•æ€åŒ–ï¼Œç”Ÿæˆç‰¹åŒ–ä»£ç 

**ç¤ºä¾‹**:

```rust
// Vec<T> åœ¨ç¼–è¯‘åä¸æ‰‹åŠ¨å†…å­˜ç®¡ç†ç­‰ä»·
let vec = vec![1, 2, 3];
// ç¼–è¯‘åçš„ä»£ç ä¸æ‰‹åŠ¨åˆ†é…å†…å­˜ã€ç®¡ç†ç”Ÿå‘½å‘¨æœŸç­‰ä»·

// Option<T> ä½¿ç”¨ niche optimization
let opt: Option<&i32> = Some(&42);
// None ä½¿ç”¨ç©ºæŒ‡é’ˆè¡¨ç¤ºï¼Œä¸å ç”¨é¢å¤–ç©ºé—´
```

### 3.2 æ‰€æœ‰æƒç³»ç»Ÿ

**å®šä¹‰**: Rust çš„æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨ã€‚

**è®ºè¯**:

1. **ç¼–è¯‘æ—¶æ£€æŸ¥**: æ‰€æœ‰æƒæ£€æŸ¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œï¼Œæ— è¿è¡Œæ—¶å¼€é”€
2. **å†…å­˜å®‰å…¨**: é˜²æ­¢å†…å­˜æ³„æ¼ã€åŒé‡é‡Šæ”¾ã€æ‚¬ç©ºæŒ‡é’ˆ
3. **å¹¶å‘å®‰å…¨**: æ‰€æœ‰æƒç³»ç»Ÿè‡ªç„¶é˜²æ­¢æ•°æ®ç«äº‰

**ç¤ºä¾‹**:

```rust
// æ‰€æœ‰æƒè½¬ç§»
let vec = vec![1, 2, 3];
let vec2 = vec;  // vec çš„æ‰€æœ‰æƒè½¬ç§»åˆ° vec2
// println!("{:?}", vec);  // ç¼–è¯‘é”™è¯¯ï¼švec å·²è¢«ç§»åŠ¨

// å€Ÿç”¨
let vec = vec![1, 2, 3];
let slice = &vec[..];  // ä¸å¯å˜å€Ÿç”¨
// vec.push(4);  // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½åœ¨å€Ÿç”¨æ—¶ä¿®æ”¹
```

### 3.3 å†…å­˜å®‰å…¨

**å®šä¹‰**: Rust ä¿è¯å†…å­˜å®‰å…¨ï¼Œæ— éœ€åƒåœ¾å›æ”¶ã€‚

**è®ºè¯**:

1. **ç¼–è¯‘æ—¶æ£€æŸ¥**: å€Ÿç”¨æ£€æŸ¥å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å†…å­˜å®‰å…¨
2. **RAII**: ä½¿ç”¨ RAII è‡ªåŠ¨ç®¡ç†èµ„æº
3. **ç±»å‹ç³»ç»Ÿ**: ä½¿ç”¨ç±»å‹ç³»ç»Ÿé˜²æ­¢æœªå®šä¹‰è¡Œä¸º

**ç¤ºä¾‹**:

```rust
// è‡ªåŠ¨å†…å­˜ç®¡ç†
{
    let vec = vec![1, 2, 3];
    // vec ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾å†…å­˜
}

// é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
fn get_slice() -> &[i32] {
    let vec = vec![1, 2, 3];
    &vec[..]  // ç¼–è¯‘é”™è¯¯ï¼šè¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨
}
```

### 3.4 æ€§èƒ½ä¼˜åŒ–

**å®šä¹‰**: æ ‡å‡†åº“ç»è¿‡é«˜åº¦ä¼˜åŒ–ã€‚

**è®ºè¯**:

1. **ç®—æ³•ä¼˜åŒ–**: ä½¿ç”¨æœ€ä¼˜ç®—æ³•ï¼ˆå¦‚ Timsortï¼‰
2. **å†…å­˜ä¼˜åŒ–**: ä½¿ç”¨å†…å­˜æ± ã€é¢„åˆ†é…ç­‰æŠ€æœ¯
3. **ç¼–è¯‘å™¨ä¼˜åŒ–**: åˆ©ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–ï¼ˆå¦‚å†…è”ã€å•æ€åŒ–ï¼‰

**ç¤ºä¾‹**:

```rust
// Vec ä½¿ç”¨æŒ‡æ•°æ‰©å®¹ï¼Œæ‘Šé”€ O(1) æ’å…¥
let mut vec = Vec::new();
for i in 0..1000 {
    vec.push(i);  // æ‘Šé”€ O(1)
}

// HashMap ä½¿ç”¨ SipHashï¼Œé˜²æ­¢å“ˆå¸Œæ”»å‡»
use std::collections::HashMap;
let mut map = HashMap::new();
map.insert("key", "value");  // O(1) å¹³å‡
```

---

## ğŸ“ 4. æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ

### 4.1 ä½•æ—¶ä½¿ç”¨æ ‡å‡†åº“

**ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“çš„åœºæ™¯**:

1. âœ… **é€šç”¨åœºæ™¯**: æ ‡å‡†åº“ç»è¿‡å……åˆ†æµ‹è¯•å’Œä¼˜åŒ–
2. âœ… **ç¨³å®šæ€§ä¼˜å…ˆ**: æ ‡å‡†åº“ API ç¨³å®šï¼Œå‘åå…¼å®¹
3. âœ… **æœ€å°ä¾èµ–**: æ ‡å‡†åº“æ— éœ€é¢å¤–ä¾èµ–
4. âœ… **æ€§èƒ½è¦æ±‚**: æ ‡å‡†åº“æ€§èƒ½ç»è¿‡ä¼˜åŒ–

**ç¤ºä¾‹**:

```rust
// âœ… ä½¿ç”¨æ ‡å‡†åº“ Vec
let vec = vec![1, 2, 3];

// âœ… ä½¿ç”¨æ ‡å‡†åº“ HashMap
use std::collections::HashMap;
let mut map = HashMap::new();

// âœ… ä½¿ç”¨æ ‡å‡†åº“ Mutex
use std::sync::Mutex;
let data = Mutex::new(0);
```

### 4.2 ä½•æ—¶ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“

**ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“çš„åœºæ™¯**:

1. âš ï¸ **ç‰¹æ®Šéœ€æ±‚**: æ ‡å‡†åº“æ— æ³•æ»¡è¶³çš„ç‰¹æ®Šéœ€æ±‚
2. âš ï¸ **æ€§èƒ½ä¼˜åŒ–**: ç¬¬ä¸‰æ–¹åº“åœ¨ç‰¹å®šåœºæ™¯ä¸‹æ€§èƒ½æ›´å¥½
3. âš ï¸ **åŠŸèƒ½æ‰©å±•**: éœ€è¦æ ‡å‡†åº“æ²¡æœ‰çš„åŠŸèƒ½
4. âš ï¸ **ç”Ÿæ€é›†æˆ**: éœ€è¦ä¸ç‰¹å®šç”Ÿæ€é›†æˆ

**ç¤ºä¾‹**:

```rust
// âš ï¸ ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ crossbeam çš„å¹¶å‘åŸè¯­ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
use crossbeam::channel;

// âš ï¸ ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ tokio çš„å¼‚æ­¥è¿è¡Œæ—¶ï¼ˆåŠŸèƒ½æ›´å¼ºå¤§ï¼‰
use tokio::runtime::Runtime;

// âš ï¸ ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ serde çš„åºåˆ—åŒ–ï¼ˆåŠŸèƒ½æ›´å…¨é¢ï¼‰
use serde::{Serialize, Deserialize};
```

### 4.3 æ ‡å‡†åº“ä¸ç¬¬ä¸‰æ–¹åº“çš„æƒè¡¡

**æƒè¡¡å› ç´ **:

1. **ç¨³å®šæ€§**: æ ‡å‡†åº“ > ç¬¬ä¸‰æ–¹åº“
2. **æ€§èƒ½**: å–å†³äºå…·ä½“åœºæ™¯
3. **åŠŸèƒ½**: ç¬¬ä¸‰æ–¹åº“é€šå¸¸åŠŸèƒ½æ›´å…¨é¢
4. **ç»´æŠ¤**: æ ‡å‡†åº“ç»´æŠ¤æ›´ç¨³å®š
5. **ä¾èµ–**: æ ‡å‡†åº“æ— ä¾èµ–ï¼Œç¬¬ä¸‰æ–¹åº“æœ‰ä¾èµ–

**å†³ç­–æ ‘**:

```text
æ˜¯å¦éœ€è¦æ ‡å‡†åº“æ”¯æŒï¼Ÿ
â”œâ”€ æ˜¯ â†’ ä½¿ç”¨æ ‡å‡†åº“ âœ…
â””â”€ å¦ â†’ æ˜¯å¦éœ€è¦ç‰¹æ®ŠåŠŸèƒ½ï¼Ÿ
    â”œâ”€ æ˜¯ â†’ è¯„ä¼°ç¬¬ä¸‰æ–¹åº“
    â””â”€ å¦ â†’ ä½¿ç”¨æ ‡å‡†åº“ âœ…
```

---

## ğŸ“ 5. é¡¹ç›®ä¸­çš„æ ‡å‡†åº“ä½¿ç”¨

### 5.1 å„æ¨¡å—çš„æ ‡å‡†åº“ä½¿ç”¨æƒ…å†µ

#### C01 æ‰€æœ‰æƒä¸å€Ÿç”¨

**æ ‡å‡†åº“ä½¿ç”¨**:

- `std::collections::HashMap` - ç¤ºä¾‹ä¸­çš„é›†åˆ
- `std::sync::{Arc, Mutex, RwLock}` - å¹¶å‘ç¤ºä¾‹
- `std::thread` - çº¿ç¨‹ç¤ºä¾‹

**ç»Ÿè®¡**: 1678+ å¤„æ ‡å‡†åº“ä½¿ç”¨

#### C04 æ³›å‹ç¼–ç¨‹

**æ ‡å‡†åº“ä½¿ç”¨**:

- `std::collections::{HashMap, VecDeque, HashSet}` - é›†åˆç±»å‹
- `std::sync::{Arc, Mutex, RwLock}` - å¹¶å‘ç±»å‹
- `std::thread::JoinHandle` - çº¿ç¨‹ç±»å‹
- `std::fmt::Display` - æ ¼å¼åŒ– trait

**ç»Ÿè®¡**: å¤§é‡æ ‡å‡†åº“ç±»å‹åˆ«åå’Œä½¿ç”¨

#### C05 çº¿ç¨‹ä¸å¹¶å‘

**æ ‡å‡†åº“ä½¿ç”¨**:

- `std::thread` - çº¿ç¨‹ç®¡ç†
- `std::sync::{Arc, Mutex, RwLock, Condvar, Barrier}` - åŒæ­¥åŸè¯­
- `std::sync::mpsc` - é€šé“
- `std::sync::atomic` - åŸå­æ“ä½œ

**ç»Ÿè®¡**: æ ¸å¿ƒæ ‡å‡†åº“å¹¶å‘ç±»å‹ä½¿ç”¨

#### C07 è¿›ç¨‹ç®¡ç†

**æ ‡å‡†åº“ä½¿ç”¨**:

- `std::process::{Command, Child, Stdio}` - è¿›ç¨‹ç®¡ç†
- `std::io::{Read, Write, BufRead}` - I/O æ“ä½œ
- `std::sync::{Arc, Mutex}` - å¹¶å‘æ§åˆ¶

**ç»Ÿè®¡**: æ ‡å‡†åº“è¿›ç¨‹å’Œ I/O ç±»å‹ä½¿ç”¨

#### C08 ç®—æ³•

**æ ‡å‡†åº“ä½¿ç”¨**:

- `std::collections::{HashMap, BTreeMap, HashSet}` - æ•°æ®ç»“æ„
- `std::cmp::Ordering` - æ¯”è¾ƒ
- `std::iter::Iterator` - è¿­ä»£å™¨

**ç»Ÿè®¡**: æ ‡å‡†åº“ç®—æ³•å’Œæ•°æ®ç»“æ„ä½¿ç”¨

### 5.2 æ ‡å‡†åº“ä½¿ç”¨ç¤ºä¾‹

#### ç¤ºä¾‹ 1: ä½¿ç”¨ HashMap

```rust
use std::collections::HashMap;

let mut map = HashMap::new();
map.insert("key1", "value1");
map.insert("key2", "value2");

// è·å–å€¼
if let Some(value) = map.get("key1") {
    println!("{}", value);
}
```

#### ç¤ºä¾‹ 2: ä½¿ç”¨ Arc å’Œ Mutex

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let data = Arc::new(Mutex::new(0));

let handles: Vec<_> = (0..10).map(|_| {
    let data = Arc::clone(&data);
    thread::spawn(move || {
        let mut num = data.lock().unwrap();
        *num += 1;
    })
}).collect();

for handle in handles {
    handle.join().unwrap();
}
```

#### ç¤ºä¾‹ 3: ä½¿ç”¨ Command

```rust
use std::process::Command;

let output = Command::new("echo")
    .arg("Hello, world!")
    .output()?;

println!("{}", String::from_utf8(output.stdout)?);
```

### 5.3 æ ‡å‡†åº“ä½¿ç”¨æœ€ä½³å®è·µ

#### å®è·µ 1: ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“

```rust
// âœ… ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“
use std::collections::HashMap;

// âš ï¸ ä»…åœ¨éœ€è¦ç‰¹æ®ŠåŠŸèƒ½æ—¶ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“
// use hashbrown::HashMap;  // ä»…å½“éœ€è¦æ€§èƒ½ä¼˜åŒ–æ—¶
```

#### å®è·µ 2: å……åˆ†åˆ©ç”¨æ ‡å‡†åº“ç‰¹æ€§

```rust
// âœ… ä½¿ç”¨æ ‡å‡†åº“çš„ä¾¿åˆ©æ–¹æ³•
let vec = vec![1, 2, 3];
let sum: i32 = vec.iter().sum();

// âœ… ä½¿ç”¨æ ‡å‡†åº“çš„é”™è¯¯å¤„ç†
let file = std::fs::File::open("file.txt")?;
```

#### å®è·µ 3: ç†è§£æ ‡å‡†åº“çš„å®ç°

```rust
// âœ… ç†è§£ Vec çš„æ‰©å®¹ç­–ç•¥
let mut vec = Vec::with_capacity(100);  // é¢„åˆ†é…å®¹é‡

// âœ… ç†è§£ HashMap çš„å“ˆå¸Œç®—æ³•
use std::collections::HashMap;
let mut map = HashMap::with_capacity(100);  // é¢„åˆ†é…å®¹é‡
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [Rust æ ‡å‡†åº“æ–‡æ¡£](https://doc.rust-lang.org/std/)
- [Rust 1.93.0 å‘å¸ƒè¯´æ˜](https://blog.rust-lang.org/2026/01/22/Rust-1.93.0) ğŸ†•
- [Rust 1.92.0 å‘å¸ƒè¯´æ˜](https://blog.rust-lang.org/2024/12/19/Rust-1.92.0.html)
- [é¡¹ç›®æ ‡å‡†åº“ç®—æ³•å‚è€ƒ](./crates/c08_algorithms/docs/tier_03_references/05_æ ‡å‡†åº“ç®—æ³•å‚è€ƒ.md)
- [Rust 1.92.0 ç‰¹æ€§å¯¹é½æ–‡æ¡£](../archive/version_reports/RUST_192_FEATURES_ALIGNMENT.md)

---

**åˆ›å»ºæ—¥æœŸ**: 2025-12-25
**æœ€åæ›´æ–°**: 2026-01-26
**çŠ¶æ€**: âœ… **Rust 1.93.0 æ›´æ–°å®Œæˆ**ï¼ˆå†å²å¿«ç…§æ–‡æ¡£ï¼‰
