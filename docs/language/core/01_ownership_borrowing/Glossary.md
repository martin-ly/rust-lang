# Rust 所有权与生命周期分册术语表（Glossary）


## 📊 目录

- [A/B/C](#abc)
- [D/E/F/G](#defg)
- [H/I/J/K/L](#hijkl)
- [M/N/O/P/Q](#mnopq)
- [R/S/T/U/V/W/X/Y/Z](#rstuvwxyz)
- [时间戳](#时间戳)


## A/B/C

- **Arc（原子引用计数，Atomic Reference Counting）**
  - 多线程下的共享所有权智能指针，线程安全，常与Mutex/RwLock组合。
  - 典型场景：多线程共享只读或可变数据。

- **Borrow（借用）/Borrowing**
  - Rust中通过&/&mut获取对值的临时访问权，无所有权转移。
  - 注意事项：借用不能超出被借用值的生命周期。

- **Box（堆分配智能指针）**
  - 用于在堆上分配数据，所有权唯一。
  - 典型场景：递归数据结构、动态大小类型。

## D/E/F/G

- **Drop（析构）**
  - Rust自动调用的资源释放机制，实现Drop trait可自定义析构逻辑。
  - 注意事项：避免在Drop中panic。

- **FFI（Foreign Function Interface，外部函数接口）**
  - Rust与C/C++等语言互操作的机制。
  - 注意事项：FFI边界需手动保证内存/线程安全。

- **Fn/FnMut/FnOnce（函数trait）**
  - Rust三种函数/闭包trait，分别对应不可变借用、可变借用、一次性消费。
  - 典型场景：高阶函数、回调、并发任务。

## H/I/J/K/L

- **Lifetime（生命周期）**
  - Rust用于描述引用有效期的机制，防止悬垂指针。
  - 典型场景：函数参数/返回值、结构体中引用字段。

- **Lock（锁）/Mutex/RwLock**
  - 并发下保护可变数据的同步原语，Mutex独占写，RwLock支持多读。
  - 注意事项：避免死锁，合理控制锁粒度。

## M/N/O/P/Q

- **Move（移动语义）**
  - 所有权从一个变量转移到另一个变量，原变量失效。
  - 典型场景：函数参数传递、容器插入。

- **Mut/Mutable（可变/可变性）**
  - Rust通过mut关键字声明变量/引用可变。
  - 注意事项：可变借用必须唯一。

- **Mutex（互斥锁）**
  - 线程安全的内部可变性容器，保证同一时刻只有一个线程访问数据。
  - 典型场景：多线程共享可变状态。

## R/S/T/U/V/W/X/Y/Z

- **Rc（引用计数，Reference Counting）**
  - 单线程下的共享所有权智能指针，非线程安全。
  - 典型场景：树/图等多所有者结构。

- **RefCell（运行时借用检查）**
  - 单线程下的内部可变性容器，运行时检查借用规则。
  - 注意事项：违反借用规则会panic。

- **Send/Sync（并发trait）**
  - Send：类型可在线程间安全转移所有权；Sync：类型可安全被多线程引用。
  - 典型场景：多线程并发编程。

- **Trait（特质）**
  - Rust的接口/类型类机制，支持多态与约束。
  - 典型场景：泛型编程、依赖注入、设计模式。

- **Unsafe（不安全代码）**
  - 绕过Rust安全检查的代码块，需手动保证内存/线程安全。
  - 注意事项：仅在必要时使用，严格审查。

- **Ownership（所有权）**
  - Rust核心机制，控制值的唯一归属与生命周期。
  - 典型场景：资源管理、内存安全、并发。

## 时间戳

- 最后更新：2024-06-09
