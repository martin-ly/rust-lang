# 第 4 章：并行计算与生态系统


## 📊 目录

- [1. 并发 (Concurrency) vs. 并行 (Parallelism)](#1-并发-concurrency-vs-并行-parallelism)
  - [1.1. 形式化区分](#11-形式化区分)
  - [1.2. Rust 的模型映射](#12-rust-的模型映射)
- [2. 数据并行：Rayon 库](#2-数据并行rayon-库)
  - [2.1. 核心理念：轻松将串行改为并行](#21-核心理念轻松将串行改为并行)
  - [2.2. 并行迭代器 (`ParallelIterator`)](#22-并行迭代器-paralleliterator)
  - [2.3. 工作窃取 (Work-Stealing) 调度](#23-工作窃取-work-stealing-调度)
- [3. 其他关键并发/并行库](#3-其他关键并发并行库)
  - [3.1. `crossbeam`: 更强大的通道与工具](#31-crossbeam-更强大的通道与工具)
  - [3.2. `tokio` 和 `async-std`: 异步运行时](#32-tokio-和-async-std-异步运行时)
- [4. 哲学批判性分析](#4-哲学批判性分析)
  - [4.1. 抽象层次的提升](#41-抽象层次的提升)
  - [4.2. "无畏"的边界](#42-无畏的边界)
- [5. 总结](#5-总结)


- [第 4 章：并行计算与生态系统](#第-4-章并行计算与生态系统)
  - [1. 并发 (Concurrency) vs. 并行 (Parallelism)](#1-并发-concurrency-vs-并行-parallelism)
    - [1.1. 形式化区分](#11-形式化区分)
    - [1.2. Rust 的模型映射](#12-rust-的模型映射)
  - [2. 数据并行：Rayon 库](#2-数据并行rayon-库)
    - [2.1. 核心理念：轻松将串行改为并行](#21-核心理念轻松将串行改为并行)
    - [2.2. 并行迭代器 (`ParallelIterator`)](#22-并行迭代器-paralleliterator)
    - [2.3. 工作窃取 (Work-Stealing) 调度](#23-工作窃取-work-stealing-调度)
  - [3. 其他关键并发/并行库](#3-其他关键并发并行库)
    - [3.1. `crossbeam`: 更强大的通道与工具](#31-crossbeam-更强大的通道与工具)
    - [3.2. `tokio` 和 `async-std`: 异步运行时](#32-tokio-和-async-std-异步运行时)
  - [4. 哲学批判性分析](#4-哲学批判性分析)
    - [4.1. 抽象层次的提升](#41-抽象层次的提升)
    - [4.2. "无畏"的边界](#42-无畏的边界)
  - [5. 总结](#5-总结)

---

## 1. 并发 (Concurrency) vs. 并行 (Parallelism)

在深入探讨生态系统之前，必须对两个核心概念进行精确的形式化区分。

### 1.1. 形式化区分

- **并发 (Concurrency)**: 是关于**构造 (structuring)**。它是一种处理**多个独立任务**的能力。这些任务的执行可以在时间上重叠（例如，在单核处理器上通过时间分片交替执行），也可以不重叠。并发是一种程序设计模型，其核心在于**任务的分解与交互**。
  - *关注点*: 管理多个逻辑上的执行流，处理非确定性，确保任务间的安全交互。
  - *模型*: CSP (消息传递), 共享状态与锁。

- **并行 (Parallelism)**: 是关于**执行 (execution)**。它是指**同时执行多个计算任务**的能力。并行需要硬件支持（例如，多核处理器）。并行是一种提升计算速度的手段，其核心在于**任务的分解与同时处理**。
  - *关注点*: 将单个计算密集型任务分解成子任务，并分配到不同的计算单元上以缩短总执行时间。
  - *模型*: 数据并行，任务并行。

一个程序可以是并发的但不是并行的（如在单核 CPU 上的 web 服务器），也可以是并行的但不是并发的（如对一个大数组进行分块并行计算），还可以两者都是。

### 1.2. Rust 的模型映射

- **`std::thread`**: 提供了并发执行的基本单元。
- **`mpsc` 和 `Mutex`**: 提供了**并发**构造的工具，用于管理这些并发执行单元之间的关系。
- **Rayon 库**: 提供了**并行**计算的强大抽象，专注于将计算密集型任务并行化。

## 2. 数据并行：Rayon 库

Rayon 是 Rust 生态中最著名、使用最广泛的并行计算库。它使得将计算密集型的顺序代码（特别是迭代器）转化为并行代码变得异常简单和安全。

### 2.1. 核心理念：轻松将串行改为并行

Rayon 的设计哲学是，对于许多数据处理任务，并行化不应该要求对代码进行大规模的重构。理想情况下，它应该只是一个"开关"。

### 2.2. 并行迭代器 (`ParallelIterator`)

Rayon 的核心抽象是 `ParallelIterator` Trait。它几乎镜像了标准库的 `Iterator` Trait，但其方法（如 `map`, `filter`, `fold`）会并行地执行。

将一个顺序的迭代器操作改为并行的，通常只需要一步：将 `.iter()` 修改为 `.par_iter()`。

**代码示例**:

```rust
// 首先，需要将 rayon 添加到 Cargo.toml
// [dependencies]
// rayon = "1.5"

use rayon::prelude::*;

fn main() {
    let mut numbers = (1..=1_000_000).collect::<Vec<i32>>();

    // 顺序计算
    // numbers.iter_mut().for_each(|n| *n *= 2);

    // 并行计算，只需改变这一点
    numbers.par_iter_mut().for_each(|n| *n *= 2);

    println!("并行计算完成。");
}
```

Rayon 会自动处理线程池的创建、任务的分割和结果的合并。最重要的是，这一切都是安全的。因为 `ParallelIterator` 的约束要求被处理的数据必须是 `Send` 和 `Sync` 的，Rust 的类型系统从根本上防止了在并行处理中出现数据竞争。

### 2.3. 工作窃取 (Work-Stealing) 调度

Rayon 的高性能得益于其底层的**工作窃取调度器**。

1. **任务分割**: 它首先将整个工作（如一百万个元素的数组）分割成若干个大块，分配给线程池中的每个线程。
2. **本地队列**: 每个线程都有一个自己的双端队列 (deque) 来存放分配给它的任务。
3. **工作窃取**: 当一个线程完成了自己队列中的所有任务后，它不会闲置，而是会随机地查看其他线程的队列，并从队列的**另一端**"窃取"一个任务来执行。

这种调度策略已被证明在理论和实践中都非常高效，能够很好地实现负载均衡，确保所有核心都保持繁忙。

## 3. 其他关键并发/并行库

### 3.1. `crossbeam`: 更强大的通道与工具

`crossbeam` 是一个提供了多种高效并发数据结构和算法的库。

- **无界/有界通道**: 它提供了比标准库 `mpsc` 功能更强大的通道，支持多生产者、多消费者 (MPMC)，并且在许多基准测试中性能更高。
- **原子操作工具**: 提供了如 `AtomicCell` 等方便的原子类型。
- **内存管理**: 提供了线程安全的内存回收机制，如 `epoch`。

### 3.2. `tokio` 和 `async-std`: 异步运行时

虽然我们将在后续章节深入探讨异步编程，但在这里有必要提及 `tokio` 和 `async-std`。它们是完整的异步运行时，提供了事件循环、异步 I/O、定时器和任务调度器。

它们解决的是**I/O 密集型**并发问题，而不是 **CPU 密集型**并行问题。一个异步运行时可以用很少的操作系统线程（甚至一个）来高效地管理成千上万个并发的 I/O 操作（如网络连接、文件读写）。

## 4. 哲学批判性分析

### 4.1. 抽象层次的提升

从 `std::thread` 到 `Mutex`，再到 `Rayon`，我们看到了一个清晰的抽象层次提升。

- `std::thread` 是最底层的抽象，直接映射到操作系统线程。开发者需要手动管理所有事情。
- `Mutex` 和通道是中层抽象，它们封装了特定的同步逻辑，降低了心智负担。
- `Rayon` 是高层抽象，它将并行化的"意图"与"实现"完全分离。开发者只需声明"我希望这段代码并行运行"，而 Rayon 则负责处理所有复杂的调度和同步细节。

这种分层抽象是 Rust 生态系统成熟的标志。

### 4.2. "无畏"的边界

Rayon 和其他库极大地扩展了"无畏并发"的边界。对于数据并行这类高度结构化的问题，它们几乎完全消除了并发编程的复杂性。

然而，"无畏"并非"无思"。开发者仍然需要理解其代码的并行潜力。一个本质上是顺序的算法，无论如何使用 Rayon 也无法获得加速。此外，对于小任务量的计算，并行化引入的调度开销甚至可能超过其带来的收益。性能分析和基准测试仍然是不可或缺的。

## 5. 总结

Rust 的并发故事远不止于标准库。通过像 Rayon 这样的第三方库，Rust 将高性能的**并行计算**变得像顺序编程一样简单和安全。工作窃取等先进的调度算法确保了高资源利用率。同时，`crossbeam` 和异步运行时等库为更广泛的并发问题提供了强大的、生产级的解决方案。

理解并发与并行的区别，并根据问题是 **CPU 密集型**还是 **I/O 密集型**来选择合适的工具（例如 Rayon vs. Tokio），是成为一名高效 Rust 程序员的关键一步。

---
**章节导航:**

- **上一章 ->** `03_synchronization_primitives.md`
- **下一章 ->** `05_advanced_topics_and_summary.md`: 高级主题与本分册总结。
- **返回目录 ->** `_index.md`
