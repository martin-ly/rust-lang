# Rust形式化理论统一符号系统 (RFUSS)

## 1. 符号系统目标

本符号系统旨在为Rust语言形式化理论提供统一、一致的数学表示方法，确保：

1. **一致性**：同一概念在所有模块中使用相同符号
2. **可读性**：符号选择直观且易于理解
3. **完备性**：覆盖Rust语言所有核心概念
4. **可扩展性**：支持新概念的符号扩展
5. **与现有文献兼容**：尽可能采用学术界通用符号

## 2. 基础集合符号

| 符号 | 含义 | 示例 |
|------|------|------|
| 𝕋 | 类型集合 | `t ∈ 𝕋` 表示t是一个类型 |
| 𝕍 | 值集合 | `v ∈ 𝕍` 表示v是一个值 |
| 𝕏 | 变量集合 | `x ∈ 𝕏` 表示x是一个变量 |
| ℒ | 生命周期集合 | `α ∈ ℒ` 表示α是一个生命周期 |
| 𝔼 | 表达式集合 | `e ∈ 𝔼` 表示e是一个表达式 |
| 𝕊 | 语句集合 | `s ∈ 𝕊` 表示s是一个语句 |
| Γ | 类型上下文 | `Γ = {x₁:T₁, x₂:T₂, ...}` |
| Σ | 内存状态 | `Σ = {addr₁↦val₁, addr₂↦val₂, ...}` |

## 3. 类型系统符号

### 3.1 基本类型判断

| 符号 | 含义 | 示例 |
|------|------|------|
| t : T | 值t具有类型T | `42 : i32` |
| Γ ⊢ e : T | 在上下文Γ中e具有类型T | `x:i32 ⊢ x+1 : i32` |
| T <: U | T是U的子类型 | `&'static str <: &'a str` |
| T : Trait | T实现了Trait | `Vec<T> : Clone where T : Clone` |

### 3.2 类型构造

| 符号 | 含义 | 示例 |
|------|------|------|
| T + U | 类型交集(trait bounds) | `T : Clone + Copy` |
| T & U | 类型交集(另一种表示) | `T : Clone & Copy` |
| ∀α. T | 泛型类型(所有α) | `∀α. Vec<α>` |
| ∃α. T | 存在类型(某些α) | `∃α. α : Display` |
| T → U | 函数类型 | `fn(i32) → bool` |
| T × U | 元组类型 | `(i32, bool)` |
| `Option<T>` | 可选类型 | `Option<i32>` |
| Result<T,E> | 结果类型 | `Result<String, Error>` |

### 3.3 类型关系

| 符号 | 含义 | 示例 |
|------|------|------|
| T ≡ U | 类型等价 | `Vec<T> ≡ Vec<T>` |
| T ≢ U | 类型不等价 | `i32 ≢ u32` |
| T ∩ U | 类型交集 | `(T : Clone) ∩ (T : Copy)` |
| T ∪ U | 类型并集 | `Result<T,E₁> ∪ Result<T,E₂>` |
| T[α/β] | 类型替换(α替换为β) | `Vec<&'a T>[′a/′static]` |

## 4. 所有权系统符号

### 4.1 所有权关系

| 符号 | 含义 | 示例 |
|------|------|------|
| Own(x, v) | 变量x拥有值v | `Own(x, Vec<i32>{1,2,3})` |
| &^α T | 生命周期为α的不可变引用 | `&^'a i32` |
| &^α mut T | 生命周期为α的可变引用 | `&^'a mut Vec<T>` |
| Move(x → y) | 所有权从x移动到y | `Move(v1 → v2)` |
| Copy(x → y) | x的值复制到y | `Copy(i → j)` |
| Drop(x) | 销毁x拥有的值 | `Drop(v)` |

### 4.2 借用检查

| 符号 | 含义 | 示例 |
|------|------|------|
| Borrow(r, x, α) | r借用x，生命周期为α | `Borrow(r, v, 'a)` |
| MutBorrow(r, x, α) | r可变借用x，生命周期为α | `MutBorrow(r, v, 'a)` |
| α ⊑ β | 生命周期α包含在β中 | `'a ⊑ 'static` |
| Live(x, α) | x在生命周期α内有效 | `Live(r, 'a)` |
| Conflict(b₁, b₂) | 借用b₁和b₂冲突 | `Conflict(r1, r2)` |

### 4.3 内存安全

| 符号 | 含义 | 示例 |
|------|------|------|
| Valid(ptr, Σ) | 指针ptr在内存状态Σ中有效 | `Valid(p, heap)` |
| Dangling(ptr, Σ) | 指针ptr在内存状态Σ中悬垂 | `¬Dangling(p, heap)` |
| Aliased(ptr₁, ptr₂, Σ) | 两指针在内存状态Σ中别名 | `¬Aliased(p1, p2, heap)` |
| SafeAccess(e, Σ) | 表达式e在内存状态Σ中安全访问 | `SafeAccess(x.f, heap)` |

## 5. 并发与异步符号

### 5.1 并发安全性

| 符号 | 含义 | 示例 |
|------|------|------|
| Sync(T) | 类型T是同步安全的 | `Sync(Arc<T>)` |
| Send(T) | 类型T是发送安全的 | `Send(Vec<T>) ⟺ Send(T)` |
| Thread(t) | 线程t | `Thread(t₁)` |
| Atomic(op) | 原子操作 | `Atomic(fetch_add)` |
| Race(e₁, e₂) | 表达式e₁和e₂存在数据竞争 | `¬Race(x.f, y.f)` |

### 5.2 异步计算

| 符号 | 含义 | 示例 |
|------|------|------|
| `Future<T>` | T类型的未来值 | `Future<Result<u8, Error>>` |
| `Async(e) → T` | 异步表达式e产生T类型结果 | `Async(fetch(url)) → String` |
| `Poll<T>` | T类型的轮询结果 | `Poll<Vec<u8>>` |
| Ready(v) | 就绪值v | `Ready(Ok(data))` |
| Pending | 挂起状态 | `Poll::Pending` |
| Await(f) | 等待future f | `Await(async_read())` |

## 6. 语义与证明符号

### 6.1 操作语义

| 符号 | 含义 | 示例 |
|------|------|------|
| e ⇓ v | 表达式e求值为v | `x + 1 ⇓ 6` |
| e ⇓ ⊥ | 表达式e求值出错 | `vec[10] ⇓ ⊥` |
| s₁ → s₂ | 语句s₁转换为s₂ | `x = 1; → x = 2;` |
| Σ₁ → Σ₂ | 内存状态Σ₁转换为Σ₂ | `{x↦1} → {x↦2}` |
| e : T ⇓ v | 类型为T的表达式e求值为v | `1 + 2 : i32 ⇓ 3` |

### 6.2 逻辑推导

| 符号 | 含义 | 示例 |
|------|------|------|
| P ⟹ Q | P蕴含Q | `Send(T) ⟹ Send(Vec<T>)` |
| P ⟺ Q | P当且仅当Q | `Valid(p, Σ) ⟺ ∃v. Σ(p) = v` |
| P ∧ Q | P且Q | `Sync(T) ∧ Send(T)` |
| P ∨ Q | P或Q | `Copy(T) ∨ Clone(T)` |
| ¬P | 非P | `¬Dangling(ptr, Σ)` |
| ∀x. P(x) | 对所有x，P(x)成立 | `∀T. Send(Box<T>) ⟺ Send(T)` |
| ∃x. P(x) | 存在x使P(x)成立 | `∃T. T : !Send` |
| ⊥ | 矛盾 | `T <: U ∧ U <: T ∧ T ≠ U ⟹ ⊥` |

### 6.3 类型系统性质

| 符号 | 含义 | 示例 |
|------|------|------|
| Progress(e) | 表达式e要么求值为值，要么出错 | `Progress(x + 1)` |
| Preservation(e, T) | 如果e:T且e⇓v，则v:T | `Preservation(1+2, i32)` |
| Sound(Sys) | 类型系统Sys是健全的 | `Sound(Rust) ⟺ ∀e,T. e:T ⟹ ¬(e⇓⊥)` |
| Safe(P) | 程序P是内存安全的 | `Safe(P) ⟺ ∀e∈P. ¬UB(e)` |
| UB(e) | 表达式e导致未定义行为 | `UB(unsafe { *null_ptr })` |

## 7. 使用规范

1. **一致性原则**：同一概念在所有文档中使用相同符号
2. **清晰性原则**：复杂表达式应使用括号明确优先级
3. **简洁性原则**：选择最简洁的表示方式
4. **扩展性原则**：新概念的符号应与现有系统保持一致
5. **可读性原则**：在首次使用非常规符号时提供解释

## 8. 符号扩展指南

当需要为新概念引入符号时，请遵循以下步骤：

1. 检查是否已有适用的符号
2. 参考相关学术文献中的常用符号
3. 确保新符号与现有符号系统风格一致
4. 避免与现有符号冲突或造成歧义
5. 在符号系统参考文档中注册新符号
6. 提供清晰的使用示例

## 9. 代码映射指南

为确保形式化理论与实际代码之间的明确对应关系，使用以下映射表示法：

```text
⟦ 形式化表达式 ⟧ = Rust代码
```

例如：

```text
⟦ ∀α. Vec<α> ⟧ = vec![...]
⟦ &^'a mut T ⟧ = &mut t
⟦ Option<T> ⟧ = Some(t) | None
```

## 10. 版本控制

- 当前版本：1.0
- 最后更新：2025-07-01
- 变更历史：初始版本
