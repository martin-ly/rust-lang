# 移动语义（Move Semantics）

## 元数据

- **概念ID**: 01.07
- **概念名称**: 移动语义 (Move Semantics)
- **理论层次**: 第二层：语言特征形式化层
- **相关概念**: 01.01 (所有权定义), 01.03 (所有权移动), 01.04 (借用)
- **难度级别**: 基础

## 理论简述

移动语义是Rust所有权系统的核心机制之一，指的是变量赋值或作为参数传递时，所有权会从原变量移动到新变量，原变量失效。移动语义保证了值的唯一所有权，防止悬垂引用和数据竞争。

- 非Copy类型赋值时发生所有权移动
- 原变量在移动后不可再用
- Copy类型（如i32）赋值时不会发生移动

## 形式化定义

```math
Own(y, v) \land \neg Own(x, v) \iff \text{Move}(x \to y)
```

- $Own(x, v)$：x拥有值v
- $Move(x \to y)$：所有权从x移动到y
- 移动后x不再拥有v，y拥有v

## 代码示例

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1的所有权移动到s2
    // println!("{}", s1); // 错误：s1已失效
    println!("{}", s2);
}
```

**解释**：

- `let s2 = s1;` 发生所有权移动，s1失效，s2拥有值
- 使用s1会导致编译错误

## 边界情况

```rust
fn main() {
    let x = 42; // i32实现了Copy
    let y = x; // x和y都可用
    println!("x = {}, y = {}", x, y);

    let s1 = String::from("hi");
    let s2 = s1;
    // println!("{}", s1); // 错误：s1已失效
    println!("{}", s2);
}
```

**解释**：

- Copy类型赋值不会发生所有权移动，非Copy类型会

## 理论映射

- 形式化定义：$Move(x \to y)$
- Copy类型：赋值为复制，非Copy类型：赋值为移动
- 移动后原变量失效，防止悬垂引用

## 常见错误

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1); // 错误：s1已失效
}
```

**错误原因**：

- 移动后原变量不可再用，防止多重所有权

## 总结

移动语义是Rust内存安全的基础，配合所有权和借用机制，防止悬垂引用和数据竞争。

"

---

<!-- 以下为按标准模板自动补全的占位章节，待后续填充 -->
"
## 概述
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 技术背景
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 核心概念
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 技术实现
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 形式化分析
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 应用案例
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 性能分析
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 最佳实践
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 常见问题
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n
## 未来值值展望
(待补充，参考 STANDARD_DOCUMENT_TEMPLATE_2025.md)\n


