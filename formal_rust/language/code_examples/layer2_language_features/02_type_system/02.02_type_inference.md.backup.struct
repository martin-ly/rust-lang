# 类型推断（Type Inference）

## 元数据

- **概念ID**: 02.02
- **概念名称**: 类型推断 (Type Inference)
- **理论层次**: 第二层：语言特征形式化层
- **相关概念**: 02.01 (类型定义), 02.03 (子类型), 02.14 (类型参数)
- **难度级别**: 基础

## 理论简述

类型推断是编译器根据上下文自动确定变量、表达式或函数参数类型的机制。Rust采用局部类型推断，要求大部分类型信息可由上下文推导，提升代码简洁性和安全。

- let语句、函数返回值、泛型参数等可自动推断类型
- 复杂场景下需显式类型注解
- 类型推断保证类型安全，防止类型不一致

## 形式化定义

```math
\Gamma \vdash e : ? \implies \exists T. \Gamma \vdash e : T
```

- $\Gamma$：类型环境
- $e$：表达式
- $T$：推断出的类型

## 代码示例

```rust
fn main() {
    // 基本类型推断
    let x = 42; // x: i32
    let y = 3.14; // y: f64
    let s = "hello"; // s: &str

    // 复合类型推断
    let v = vec![1, 2, 3]; // v: Vec<i32>
    let t = (x, y, s); // t: (i32, f64, &str)

    // 函数返回值类型推断
    let sum = add(1, 2); // sum: i32
    println!("sum = {}", sum);
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

**解释**：

- `let x = 42;` 编译器推断x为i32
- `let v = vec![1, 2, 3];` 推断v为`Vec<i32>`
- 函数add的返回值类型由签名和返回表达式推断

## 边界情况

```rust
fn main() {
    // 需要类型注解的场景
    let v: Vec<f64> = Vec::new(); // 空向量无法自动推断元素类型
    let n: u64 = "42".parse().unwrap(); // parse需要类型注解
}
```

**解释**：

- 空集合、parse等场景需显式类型注解，避免类型不确定

## 理论映射

- 形式化定义：$\Gamma \vdash e : ? \implies \exists T. \Gamma \vdash e : T$
- 类型推断提升代码简洁性，保证类型安全
- 泛型、闭包等场景依赖类型推断

## 常见错误

```rust
fn main() {
    // let v = Vec::new();
    // v.push(1);
    // v.push(2.0); // 错误：类型不一致，无法推断唯一类型
}
```

**错误原因**：

- 类型推断要求类型一致，混用不同类型会导致编译错误

## 总结

类型推断是Rust类型系统的重要特征，提升了代码简洁性和安全，但在类型不明确时需显式注解。


