# 常见问题解答 (FAQ) - C05 并发

---

## 问答

### Q1: `Send` 和 `Sync` 到底有什么区别？我总是搞混

**A1:** 这是最常见的一个困惑点。可以这样简单记忆：

- **`Send`**: "Can be **sen**t". 如果一个类型 `T` 是 `Send` 的，意味着 `T` 类型的值可以被**安全地发送（所有权移动）**到另一个线程。
- **`Sync`**: "Can be **syn**chronized/shared". 如果一个类型 `T` 是 `Sync` 的，意味着 `&T` 类型的值（一个共享引用）可以被**安全地在多个线程间共享**。

**一个例子**:

- `String` 是 `Send` 但不是 `Sync` 的（因为 `&String` 不能直接在多线程间共享并修改）。但是，`&String` 可以被共享。
- `Mutex<T>` 是 `Sync` (如果 `T` 是 `Send` 的)。你不能直接"发送"一个 `Mutex` 本身给多个线程（所有权会被移动），但你可以将它包在 `Arc` 里，然后将 `&Arc<Mutex<T>>` 共享给多个线程，因为 `Mutex` 保证了内部访问是同步的。
- `Rc<T>` 既不是 `Send` 也不是 `Sync`，它完全不能用于多线程。

---

### Q2: 既然 `Mutex` 这么好用，为什么 Rust 还推崇消息传递？

**A2:** 这是为了引导开发者走向更易于推理的并发模型。

- **认知负荷**: 共享状态（`Mutex`）要求开发者时刻思考锁的顺序、粒度和潜在的死锁问题。代码库越大，这种心智负担越重。
- **解耦**: 消息传递模型鼓励将线程/任务设计成独立的、解耦的单元，它们之间只通过定义好的消息进行通信。这使得系统更模块化，更易于维护和理解。
- **避免死锁**: 简单的消息传递模式（如单向数据流）天然地不容易产生死锁。

当然，这并非绝对。对于需要极高性能或数据量巨大的场景，共享状态可能更优。Rust 的美妙之处在于它同时为你提供了两种安全的选择。

---

### Q3: `Arc<Mutex<T>>` 看起来很笨重，它到底是怎么工作的？

**A3:** `Arc<Mutex<T>>` 是两种能力的组合：

1. **`Arc` (原子引用计数)**: 负责**共享所有权**。它让多个线程能"拥有"指向同一个 `Mutex` 的指针。当你 `clone()` 一个 `Arc` 时，它只是原子性地增加一个引用计数，成本非常低。
2. **`Mutex` (互斥锁)**: 负责**同步访问**。它保护内部的数据 `T`，确保任何时候只有一个线程能通过 `.lock()` 方法拿到可变访问权限。

所以，`Arc` 解决了"如何在线程间传递指针"的问题，而 `Mutex` 解决了"如何安全地修改指针指向的内容"的问题。两者结合，构成了 Rust 中最基础、最通用的线程安全内部可变性模式。

---

### Q4: 我应该什么时候用 `Rayon`，什么时候用 `async/await` (Tokio/async-std)？

**A4:** 这是一个关于 **CPU 密集型** vs. **I/O 密集型**任务的核心问题。

- **使用 `Rayon` (数据并行)**: 当你的任务是 **CPU 密集型**的。例如：
  - 对一个巨大的集合（数组、图片、矩阵）进行计算。
  - 运行复杂的模拟或算法。
  - Rayon 会使用线程池榨干你所有的 CPU 核心来加速这些计算。

- **使用 `async/await` (异步并发)**: 当你的任务是 **I/O 密集型**的。例如：
  - 同时处理成千上万个网络连接（Web 服务器）。
  - 同时读写大量文件。
  - 与数据库进行大量并发查询。
  - 在这些场景下，CPU 大部分时间都在**等待** I/O 操作完成。异步运行时可以用极少的系统线程来高效管理这些等待，而不会阻塞线程。

简单说：**计算用 Rayon，等待用 async**。

---

### Q5: 直接使用原子类型 (Atomics) 会比 `Mutex` 更快吗？

**A5:** **可能会，但你几乎永远不应该这样做。**

- **性能**: 对于非常简单的操作（如递增一个计数器），直接使用 `AtomicI32::fetch_add` 确实会比 `Mutex<i32>` 更快，因为它避免了锁的开销。
- **危险性**: 这是在与魔鬼交易。直接使用原子类型意味着你必须手动处理**内存排序**，这是并发编程中最复杂、最微妙、最容易出错的部分。一个错误的 `Ordering` 可能导致在某些硬件上正常工作，但在另一些硬件上出现难以复现的数据竞争。

**准则**: 除非你是在编写像 `Mutex` 本身这样的底层同步原语，或者是性能分析表明一个 `Mutex` 确实是无法接受的瓶颈，否则请始终使用 `Mutex`、`RwLock` 或通道等更高层次的抽象。安全和正确性远比微小的性能提升更重要。


