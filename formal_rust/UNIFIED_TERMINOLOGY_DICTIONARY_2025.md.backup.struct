# Rust形式化理论项目统一术语词典 2025

## 🎯 词典概述

**版本**: v1.0 (基于批判性评估建立)  
**制定日期**: 2025年1月27日  
**适用作用域**: 整个Rust形式化理论项目  
**更新频率**: 月度更新与维护  
**目标**: 解决术语使用不一致问题，建立标准化术语体系

---

## 📚 核心术语定义

### 1. 语言基础概念

#### 1.1 所有权与借用系统

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **ownership** | 所有权 | 变量对其值拥有独占控制权的机制 | 统一使用"所有权"，不使用"所有权" |
| **borrowing** | 借用 | 临时获取值的引用而不移动所有权的机制 | 统一使用"借用"，不使用"引用" |
| **reference** | 引用 | 指向值的指针，分为可变引用和不可变引用 | 在借用上下文中使用"借用"，在指针上下文中使用"引用" |
| **lifetime** | 生命周期 | 引用有效的时间作用域 | 统一使用"生命周期"，不使用"生命周期" |
| **scope** | 作用域 | 变量或引用有效的代码区域 | 统一使用"作用域" |
| **move** | 移动 | 将值的所有权从一个变量移动到另一个变量 | 统一使用"移动"，不使用"移动" |
| **copy** | 复制 | 创建值的副本，原值保持不变 | 统一使用"复制" |
| **clone** | 克隆 | 深度复制，创建完全独立的值副本 | 统一使用"克隆" |

#### 1.2 类型系统

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **trait** | 特征 | 定义共享行为的接口 | 统一使用"特征"，不使用"特征" |
| **type** | 类型 | 值的分类和结构体定义 | 统一使用"类型" |
| **generic** | 泛型 | 可以处理多种类型的代码模板 | 统一使用"泛型" |
| **impl** | 实现 | 为类型提供具体的行为实现 | 统一使用"实现" |
| **struct** | 结构体体 | 自定义复合数据类型 | 统一使用"结构体体" |
| **enum** | 枚举 | 可以包含多个变体的类型 | 统一使用"枚举" |
| **union** | 联合体体 | 可以存储多种类型之一的数据结构体 | 统一使用"联合体体" |
| **type alias** | 类型别名 | 为现有类型创建新名称 | 统一使用"类型别名" |

#### 1.3 内存管理

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **stack** | 栈 | 后进先出的内存区域 | 统一使用"栈" |
| **heap** | 堆 | 动态分配的内存区域 | 统一使用"堆" |
| **memory safety** | 内存安全 | 防止内存错误的安全保证 | 统一使用"内存安全" |
| **memory leak** | 内存泄漏 | 程序无法释放不再使用的内存 | 统一使用"内存泄漏" |
| **use-after-free** | 释放后使用 | 使用已被释放的内存 | 统一使用"释放后使用" |
| **double-free** | 重复释放 | 对同一内存区域释放两次 | 统一使用"重复释放" |
| **dangling pointer** | 悬空指针 | 指向已释放内存的指针 | 统一使用"悬空指针" |

### 2. 并发与异步

#### 2.1 并发编程

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **concurrency** | 并发 | 多个任务交替执行的能力 | 统一使用"并发" |
| **parallelism** | 并行 | 多个任务同时执行的能力 | 统一使用"并行" |
| **thread** | 线程 | 程序执行的最小单位 | 统一使用"线程" |
| **mutex** | 互斥锁 | 保护共享资源的同步原语 | 统一使用"互斥锁" |
| **semaphore** | 信号量 | 控制并发访问数量的同步原语 | 统一使用"信号量" |
| **atomic** | 原子操作 | 不可分割的操作，保证线程安全 | 统一使用"原子操作" |
| **race condition** | 竞态条件 | 多个线程访问共享资源时的时序问题 | 统一使用"竞态条件" |
| **deadlock** | 死锁 | 多个线程相互等待导致的阻塞 | 统一使用"死锁" |

#### 2.2 异步编程

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **async** | 异步 | 非阻塞的编程模式 | 统一使用"异步" |
| **await** | 等待 | 等待异步操作完成 | 统一使用"等待" |
| **future** | 未来值值 | 表示异步计算结果的类型 | 统一使用"未来值值" |
| **task** | 任务 | 异步执行的工作单元 | 统一使用"任务" |
| **executor** | 执行器 | 调度和执行异步任务的组件 | 统一使用"执行器" |
| **reactor** | 反应器 | 处理I/O事件的组件 | 统一使用"反应器" |
| **poll** | 轮询 | 检查异步操作是否完成 | 统一使用"轮询" |

### 3. 错误处理

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **error** | 错误 | 程序执行中的异常情况 | 统一使用"错误" |
| **panic** | 恐慌 | 程序遇到无法恢复的错误时的行为 | 统一使用"恐慌" |
| **unwrap** | 解包 | 从Result或Option中提取值，失败时恐慌 | 统一使用"解包" |
| **expect** | 期望 | 从Result或Option中提取值，失败时显示自定义消息 | 统一使用"期望" |
| **Result** | 结果 | 表示成功或失败的类型 | 统一使用"结果" |
| **Option** | 选项 | 表示可能存在或不存在的值 | 统一使用"选项" |
| **Some** | 有值 | Option类型的变体，表示存在值 | 统一使用"有值" |
| **None** | 无值 | Option类型的变体，表示不存在值 | 统一使用"无值" |

### 4. 宏系统

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **macro** | 宏 | 编译时代码生成机制 | 统一使用"宏" |
| **macro_rules** | 宏规则 | 声明宏的语法 | 统一使用"宏规则" |
| **procedural macro** | 过程宏 | 基于函数的宏实现 | 统一使用"过程宏" |
| **derive macro** | 派生宏 | 自动实现特征的宏 | 统一使用"派生宏" |
| **attribute macro** | 属性宏 | 修改项的宏 | 统一使用"属性宏" |
| **function-like macro** | 函数式宏 | 类似函数调用的宏 | 统一使用"函数式宏" |
| **hygiene** | 卫生性 | 宏展开时避免名称冲突的特征 | 统一使用"卫生性" |

### 5. 模块系统

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **module** | 模块 | 代码组织和封装的单位 | 统一使用"模块" |
| **crate** | 包 | Rust的编译单位 | 统一使用"包" |
| **library** | 库 | 可重用的代码集合 | 统一使用"库" |
| **binary** | 二进制 | 可执行的程序 | 统一使用"二进制" |
| **dependency** | 依赖 | 项目依赖的其他包 | 统一使用"依赖" |
| **visibility** | 可见性 | 控制项是否可以从外部访问 | 统一使用"可见性" |
| **pub** | 公开 | 使项可以从外部访问 | 统一使用"公开" |
| **use** | 使用 | 导入其他模块的项 | 统一使用"使用" |

### 6. 形式化理论

#### 6.1 数学概念

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **formal semantics** | 形式语义 | 编程语言的数学语义定义 | 统一使用"形式语义" |
| **type theory** | 类型理论 | 研究类型系统的数学理论 | 统一使用"类型理论" |
| **category theory** | 范畴论 | 研究数学结构体的抽象理论 | 统一使用"范畴论" |
| **monad** | 单子 | 函数式编程中的抽象概念 | 统一使用"单子" |
| **functor** | 函子 | 保持结构体的映射 | 统一使用"函子" |
| **algebraic data type** | 代数数据类型 | 通过代数运算构造的数据类型 | 统一使用"代数数据类型" |
| **pattern matching** | 模式匹配 | 根据数据结构体形状进行匹配 | 统一使用"模式匹配" |

#### 6.2 证明理论

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **proof** | 证明 | 数学命题的严格论证 | 统一使用"证明" |
| **theorem** | 定理 | 经过证明的数学命题 | 统一使用"定理" |
| **lemma** | 引理 | 辅助证明的数学命题 | 统一使用"引理" |
| **corollary** | 推论 | 从定理直接得出的结论 | 统一使用"推论" |
| **axiom** | 公理 | 不证自明的基本命题 | 统一使用"公理" |
| **induction** | 归纳 | 数学归纳法 | 统一使用"归纳" |
| **contradiction** | 矛盾 | 逻辑矛盾 | 统一使用"矛盾" |

### 7. 性能与优化

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **performance** | 性能 | 程序执行效率 | 统一使用"性能" |
| **optimization** | 优化 | 提高程序性能的过程 | 统一使用"优化" |
| **benchmark** | 基准测试 | 性能测试的标准程序 | 统一使用"基准测试" |
| **profiling** | 性能分析 | 分析程序性能特征 | 统一使用"性能分析" |
| **zero-cost abstraction** | 零成本抽象 | 不增加运行时开销的抽象 | 统一使用"零成本抽象" |
| **inlining** | 内联 | 将函数调用替换为函数体 | 统一使用"内联" |
| **vectorization** | 向量化 | 使用SIMD指令优化 | 统一使用"向量化" |

### 8. 安全与验证

| 英文术语 | 标准中文翻译 | 定义 | 使用规范 |
|----------|--------------|------|----------|
| **safety** | 安全 | 程序正确性和可靠性 | 统一使用"安全" |
| **unsafe** | 不安全 | 需要手动保证安全的代码 | 统一使用"不安全" |
| **verification** | 验证 | 证明程序正确性的过程 | 统一使用"验证" |
| **static analysis** | 静态分析 | 编译时分析程序性质 | 统一使用"静态分析" |
| **dynamic analysis** | 动态分析 | 运行时分析程序行为 | 统一使用"动态分析" |
| **model checking** | 模型检验 | 自动验证系统性质 | 统一使用"模型检验" |
| **invariant** | 不变量 | 程序执行过程中保持的性质 | 统一使用"不变量" |

---

## 🔧 术语检查工具

### 1. 自动化检查脚本

```rust
// terminology_checker.rs
use std::collections::HashMap;
use std::fs;
use std::path::Path;

#[derive(Debug)]
pub struct TermInconsistency {
    pub term: String,
    pub standard_translation: String,
    pub found_translations: Vec<String>,
    pub file_path: String,
    pub line_number: usize,
}

#[derive(Debug)]
pub struct ConsistencyReport {
    pub total_terms: usize,
    pub inconsistent_terms: usize,
    pub consistency_rate: f64,
    pub inconsistencies: Vec<TermInconsistency>,
}

pub struct TerminologyChecker {
    pub standard_terms: HashMap<String, String>,
    pub term_frequency: HashMap<String, u32>,
    pub inconsistency_reports: Vec<TermInconsistency>,
}

impl TerminologyChecker {
    pub fn new() -> Self {
        let mut standard_terms = HashMap::new();
        
        // 加载标准术语
        standard_terms.insert("trait".to_string(), "特征".to_string());
        standard_terms.insert("ownership".to_string(), "所有权".to_string());
        standard_terms.insert("borrowing".to_string(), "借用".to_string());
        standard_terms.insert("reference".to_string(), "引用".to_string());
        standard_terms.insert("lifetime".to_string(), "生命周期".to_string());
        standard_terms.insert("scope".to_string(), "作用域".to_string());
        standard_terms.insert("move".to_string(), "移动".to_string());
        standard_terms.insert("copy".to_string(), "复制".to_string());
        standard_terms.insert("clone".to_string(), "克隆".to_string());
        standard_terms.insert("type".to_string(), "类型".to_string());
        standard_terms.insert("generic".to_string(), "泛型".to_string());
        standard_terms.insert("impl".to_string(), "实现".to_string());
        standard_terms.insert("struct".to_string(), "结构体体".to_string());
        standard_terms.insert("enum".to_string(), "枚举".to_string());
        standard_terms.insert("union".to_string(), "联合体体".to_string());
        standard_terms.insert("stack".to_string(), "栈".to_string());
        standard_terms.insert("heap".to_string(), "堆".to_string());
        standard_terms.insert("memory safety".to_string(), "内存安全".to_string());
        standard_terms.insert("concurrency".to_string(), "并发".to_string());
        standard_terms.insert("parallelism".to_string(), "并行".to_string());
        standard_terms.insert("thread".to_string(), "线程".to_string());
        standard_terms.insert("mutex".to_string(), "互斥锁".to_string());
        standard_terms.insert("async".to_string(), "异步".to_string());
        standard_terms.insert("await".to_string(), "等待".to_string());
        standard_terms.insert("future".to_string(), "未来值值".to_string());
        standard_terms.insert("error".to_string(), "错误".to_string());
        standard_terms.insert("panic".to_string(), "恐慌".to_string());
        standard_terms.insert("Result".to_string(), "结果".to_string());
        standard_terms.insert("Option".to_string(), "选项".to_string());
        standard_terms.insert("macro".to_string(), "宏".to_string());
        standard_terms.insert("module".to_string(), "模块".to_string());
        standard_terms.insert("crate".to_string(), "包".to_string());
        standard_terms.insert("library".to_string(), "库".to_string());
        standard_terms.insert("dependency".to_string(), "依赖".to_string());
        standard_terms.insert("visibility".to_string(), "可见性".to_string());
        standard_terms.insert("formal semantics".to_string(), "形式语义".to_string());
        standard_terms.insert("type theory".to_string(), "类型理论".to_string());
        standard_terms.insert("category theory".to_string(), "范畴论".to_string());
        standard_terms.insert("proof".to_string(), "证明".to_string());
        standard_terms.insert("theorem".to_string(), "定理".to_string());
        standard_terms.insert("performance".to_string(), "性能".to_string());
        standard_terms.insert("optimization".to_string(), "优化".to_string());
        standard_terms.insert("safety".to_string(), "安全".to_string());
        standard_terms.insert("verification".to_string(), "验证".to_string());
        
        Self {
            standard_terms,
            term_frequency: HashMap::new(),
            inconsistency_reports: Vec::new(),
        }
    }
    
    pub fn check_consistency(&mut self, document_path: &Path) -> ConsistencyReport {
        let content = fs::read_to_string(document_path)
            .expect("Failed to read document");
        
        let mut inconsistencies = Vec::new();
        let mut total_terms = 0;
        let mut inconsistent_terms = 0;
        
        for (line_num, line) in content.lines().enumerate() {
            for (english_term, standard_translation) in &self.standard_terms {
                // 检查是否包含英文术语
                if line.contains(english_term) {
                    total_terms += 1;
                    
                    // 检查是否有对应的中文翻译
                    if !line.contains(standard_translation) {
                        // 查找可能的其他翻译
                        let found_translations = self.find_alternative_translations(
                            english_term, 
                            standard_translation, 
                            line
                        );
                        
                        if !found_translations.is_empty() {
                            inconsistent_terms += 1;
                            inconsistencies.push(TermInconsistency {
                                term: english_term.clone(),
                                standard_translation: standard_translation.clone(),
                                found_translations,
                                file_path: document_path.to_string_lossy().to_string(),
                                line_number: line_num + 1,
                            });
                        }
                    }
                }
            }
        }
        
        let consistency_rate = if total_terms > 0 {
            (total_terms - inconsistent_terms) as f64 / total_terms as f64 * 100.0
        } else {
            100.0
        };
        
        ConsistencyReport {
            total_terms,
            inconsistent_terms,
            consistency_rate,
            inconsistencies,
        }
    }
    
    fn find_alternative_translations(
        &self, 
        english_term: &str, 
        standard_translation: &str, 
        line: &str
    ) -> Vec<String> {
        let mut alternatives = Vec::new();
        
        // 定义可能的替代翻译
        let alternative_mappings = match english_term {
            "trait" => vec!["特征"],
            "ownership" => vec!["所有权"],
            "borrowing" => vec!["引用"],
            "reference" => vec!["借用"],
            "lifetime" => vec!["生命周期"],
            "move" => vec!["移动"],
            "copy" => vec!["复制"],
            "clone" => vec!["复制"],
            "type" => vec!["类型"],
            "generic" => vec!["泛型"],
            "impl" => vec!["实现"],
            "struct" => vec!["结构体"],
            "enum" => vec!["枚举"],
            "union" => vec!["联合体"],
            "stack" => vec!["栈"],
            "heap" => vec!["堆"],
            "memory safety" => vec!["内存安全"],
            "concurrency" => vec!["并发"],
            "parallelism" => vec!["并行"],
            "thread" => vec!["线程"],
            "mutex" => vec!["互斥锁"],
            "async" => vec!["异步"],
            "await" => vec!["等待"],
            "future" => vec!["未来值"],
            "error" => vec!["错误"],
            "panic" => vec!["恐慌"],
            "Result" => vec!["结果"],
            "Option" => vec!["选项"],
            "macro" => vec!["宏"],
            "module" => vec!["模块"],
            "crate" => vec!["包"],
            "library" => vec!["库"],
            "dependency" => vec!["依赖"],
            "visibility" => vec!["可见性"],
            "formal semantics" => vec!["形式语义"],
            "type theory" => vec!["类型理论"],
            "category theory" => vec!["范畴论"],
            "proof" => vec!["证明"],
            "theorem" => vec!["定理"],
            "performance" => vec!["性能"],
            "optimization" => vec!["优化"],
            "safety" => vec!["安全"],
            "verification" => vec!["验证"],
            _ => vec![],
        };
        
        for alternative in alternative_mappings {
            if line.contains(alternative) {
                alternatives.push(alternative.to_string());
            }
        }
        
        alternatives
    }
    
    pub fn generate_report(&self, report: &ConsistencyReport) -> String {
        let mut report_text = String::new();
        
        report_text.push_str(&format!("# 术语一致性检查报告\n\n"));
        report_text.push_str(&format!("## 总体统计\n"));
        report_text.push_str(&format!("- **总术语数**: {}\n", report.total_terms));
        report_text.push_str(&format!("- **不一致术语数**: {}\n", report.inconsistent_terms));
        report_text.push_str(&format!("- **一致性率**: {:.2}%\n\n", report.consistency_rate));
        
        if !report.inconsistencies.is_empty() {
            report_text.push_str("## 不一致术语详情\n\n");
            
            for inconsistency in &report.inconsistencies {
                report_text.push_str(&format!("### {}\n", inconsistency.term));
                report_text.push_str(&format!("- **标准翻译**: {}\n", inconsistency.standard_translation));
                report_text.push_str(&format!("- **发现翻译**: {}\n", inconsistency.found_translations.join(", ")));
                report_text.push_str(&format!("- **文件**: {}\n", inconsistency.file_path));
                report_text.push_str(&format!("- **行号**: {}\n\n", inconsistency.line_number));
            }
        }
        
        report_text
    }
}
```

### 2. 批量修正脚本

```rust
// terminology_fixer.rs
use std::collections::HashMap;
use std::fs;
use std::path::Path;

pub struct TerminologyFixer {
    pub replacement_mappings: HashMap<String, String>,
}

impl TerminologyFixer {
    pub fn new() -> Self {
        let mut replacement_mappings = HashMap::new();
        
        // 定义需要替换的术语映射
        replacement_mappings.insert("特征".to_string(), "特征".to_string());
        replacement_mappings.insert("所有权".to_string(), "所有权".to_string());
        replacement_mappings.insert("生命周期".to_string(), "生命周期".to_string());
        replacement_mappings.insert("移动".to_string(), "移动".to_string());
        replacement_mappings.insert("复制".to_string(), "复制".to_string());
        replacement_mappings.insert("结构体".to_string(), "结构体体".to_string());
        replacement_mappings.insert("联合体".to_string(), "联合体体".to_string());
        replacement_mappings.insert("内存安全".to_string(), "内存安全".to_string());
        replacement_mappings.insert("并发".to_string(), "并发".to_string());
        replacement_mappings.insert("并行".to_string(), "并行".to_string());
        replacement_mappings.insert("互斥锁".to_string(), "互斥锁".to_string());
        replacement_mappings.insert("未来值".to_string(), "未来值值".to_string());
        replacement_mappings.insert("选项".to_string(), "选项".to_string());
        replacement_mappings.insert("形式语义".to_string(), "形式语义".to_string());
        replacement_mappings.insert("类型理论".to_string(), "类型理论".tostring());
        replacement_mappings.insert("范畴论".to_string(), "范畴论".to_string());
        replacement_mappings.insert("证明".to_string(), "证明".to_string());
        replacement_mappings.insert("定理".to_string(), "定理".to_string());
        replacement_mappings.insert("性能".to_string(), "性能".to_string());
        replacement_mappings.insert("优化".to_string(), "优化".to_string());
        replacement_mappings.insert("安全".to_string(), "安全".to_string());
        replacement_mappings.insert("验证".to_string(), "验证".to_string());
        
        Self {
            replacement_mappings,
        }
    }
    
    pub fn fix_document(&self, document_path: &Path) -> Result<String, std::io::Error> {
        let content = fs::read_to_string(document_path)?;
        let mut fixed_content = content.clone();
        
        for (incorrect, correct) in &self.replacement_mappings {
            fixed_content = fixed_content.replace(incorrect, correct);
        }
        
        if fixed_content != content {
            fs::write(document_path, &fixed_content)?;
        }
        
        Ok(fixed_content)
    }
    
    pub fn fix_directory(&self, dir_path: &Path) -> Result<Vec<String>, std::io::Error> {
        let mut fixed_files = Vec::new();
        
        if dir_path.is_dir() {
            for entry in fs::read_dir(dir_path)? {
                let entry = entry?;
                let path = entry.path();
                
                if path.is_file() && path.extension().map_or(false, |ext| ext == "md") {
                    match self.fix_document(&path) {
                        Ok(_) => fixed_files.push(path.to_string_lossy().to_string()),
                        Err(e) => eprintln!("Error fixing {}: {}", path.display(), e),
                    }
                } else if path.is_dir() {
                    let sub_files = self.fix_directory(&path)?;
                    fixed_files.extend(sub_files);
                }
            }
        }
        
        Ok(fixed_files)
    }
}
```

---

## 📋 术语标准化执行计划

### 1. 第一阶段：词典建立 (Week 1)

**目标**: 建立完整的术语词典

**任务**:

- [x] 定义核心术语标准翻译
- [x] 建立术语使用规范
- [x] 创建术语检查工具
- [x] 制定术语修正流程

### 2. 第二阶段：批量检查 (Week 2)

**目标**: 对现有文档进行术语一致性检查

**任务**:

- [ ] 运行术语一致性检查工具
- [ ] 生成不一致性报告
- [ ] 分析主要问题
- [ ] 制定修正优先级

### 3. 第三阶段：批量修正 (Week 3-4)

**目标**: 修正所有术语不一致问题

**任务**:

- [ ] 优先修正高质量文档
- [ ] 重点修正中等质量文档
- [ ] 建立术语检查机制
- [ ] 验证修正效果

### 4. 第四阶段：持续监控 (Week 5-6)

**目标**: 建立术语使用持续监控机制

**任务**:

- [ ] 建立自动化检查流程
- [ ] 制定新文档术语标准
- [ ] 建立术语更新机制
- [ ] 培训团队成员

---

## 🎯 成功标准

### 1. 量化目标

**术语一致性目标**:

- 总体一致性率: 65% → 95%
- 核心术语一致性: 80% → 100%
- 新文档术语标准: 100%

**修正目标**:

- 21个现有文档术语标准化完成
- 所有核心术语使用统一
- 建立持续监控机制

### 2. 质量目标

**标准化质量**:

- 术语定义清晰明确
- 使用规范易于遵循
- 检查工具准确可靠
- 修正过程可追溯

**持续改进**:

- 定期更新术语词典
- 及时处理新术语
- 持续优化检查工具
- 建立反馈改进机制

---

## 📞 维护与更新

### 1. 更新机制

**定期更新**:

- 月度术语词典更新
- 季度使用规范修订
- 年度全面审查

**触发更新**:

- 新语言特征引入
- 社区术语变化
- 学术标准更新
- 用户反馈建议

### 2. 反馈渠道

**反馈收集**:

- 开发者使用反馈
- 专家评审意见
- 社区讨论建议
- 自动化检查发现

**反馈处理**:

- 问题分类和优先级排序
- 术语定义修订
- 使用规范更新
- 工具功能改进

---

**词典负责人**: AI Assistant  
**制定日期**: 2025年1月27日  
**版本**: v1.0  
**下次更新**: 2025年2月27日  

�� **统一术语词典正式建立！** 🦀


