# 2.3.3 è§£é‡Šå™¨æ¨¡å¼ï¼ˆInterpreter Patternï¼‰

## ğŸ“… æ–‡æ¡£ä¿¡æ¯

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-08-11  
**æœ€åæ›´æ–°**: 2025-08-11  
**çŠ¶æ€**: å·²å®Œæˆ  
**è´¨é‡ç­‰çº§**: é’»çŸ³çº§ â­â­â­â­â­

---



---

## 1. ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–å»ºæ¨¡

### 1.1 æ¨¡å¼åŠ¨æœºä¸å®šä¹‰

è§£é‡Šå™¨æ¨¡å¼ï¼ˆInterpreter Patternï¼‰å®šä¹‰äº†ä¸€ç§è¯­è¨€çš„æ–‡æ³•ï¼Œå¹¶å»ºç«‹è§£é‡Šå™¨æ¥è§£é‡Šè¯¥è¯­è¨€ä¸­çš„å¥å­ã€‚

> **æ‰¹åˆ¤æ€§è§†è§’**ï¼šè§£é‡Šå™¨æ¨¡å¼é€‚åˆè¯­æ³•è§„åˆ™é¢‘ç¹å˜åŒ–çš„åœºæ™¯ï¼Œä½†åœ¨é«˜æ€§èƒ½éœ€æ±‚ä¸‹å¯èƒ½ä¸å¦‚ç¼–è¯‘å‹æ–¹æ¡ˆã€‚

### 1.2 æ•°å­¦ä¸èŒƒç•´å­¦æŠ½è±¡

- **å¯¹è±¡**ï¼š$V$ ä¸ºç»ˆç»“ç¬¦é›†åˆï¼Œ$N$ ä¸ºéç»ˆç»“ç¬¦é›†åˆï¼Œ$T$ ä¸ºè¯­æ³•æ ‘ã€‚
- **æ€å°„**ï¼š$\text{interpret}: T \times C \to R$ï¼Œ$C$ ä¸ºä¸Šä¸‹æ–‡ï¼Œ$R$ ä¸ºè§£é‡Šç»“æœã€‚
- **æŠ½è±¡è¯­æ³•æ ‘**ï¼š$(N, \Sigma, P)$ï¼Œ$P$ ä¸ºäº§ç”Ÿå¼é›†åˆã€‚

#### Mermaid å›¾ï¼šè§£é‡Šå™¨æ¨¡å¼ç»“æ„

```mermaid
graph TD
  Client["Client"]
  Context["Context"]
  Interpreter["Interpreter"]
  AST["AST"]
  Client --> Interpreter
  Interpreter --> AST
  Interpreter --> Context
```

---

## 2. Rust å®ç°ä¸ç±»å‹ç³»ç»Ÿåˆ†æ

### 2.1 ç»Ÿä¸€æ¥å£ä¸è¡¨è¾¾å¼å°è£…

- æ‰€æœ‰è¡¨è¾¾å¼å®ç° `Expression` traitï¼Œæ”¯æŒæ³›å‹ä¸Šä¸‹æ–‡ä¸ç»“æœã€‚
- æ”¯æŒç»ˆç»“ç¬¦ã€éç»ˆç»“ç¬¦è¡¨è¾¾å¼ä¸é€’å½’ç»„åˆã€‚

#### ä»£ç ç¤ºä¾‹ï¼šæ ¸å¿ƒæ¥å£ä¸å®ç°

```rust
// è¡¨è¾¾å¼ç‰¹å¾
trait Expression {
    type Context;
    type Result;

    fn interpret(&self, context: &Self::Context) -> Self::Result;
}

// ç»ˆç»“ç¬¦è¡¨è¾¾å¼
struct TerminalExpression<T, R> {
    value: T,
    interpreter: Box<dyn Fn(&T, &R) -> R>,
}

impl<T, R> Expression for TerminalExpression<T, R> {
    type Context = R;
    type Result = R;

    fn interpret(&self, context: &Self::Context) -> Self::Result {
        (self.interpreter)(&self.value, context)
    }
}

// éç»ˆç»“ç¬¦è¡¨è¾¾å¼
struct NonTerminalExpression<T, R> {
    children: Vec<Box<dyn Expression<Context = T, Result = R>>>,
    combinator: Box<dyn Fn(&[R]) -> R>,
}

impl<T, R> Expression for NonTerminalExpression<T, R> {
    type Context = T;
    type Result = R;

    fn interpret(&self, context: &Self::Context) -> Self::Result {
        let results: Vec<R> = self.children.iter()
            .map(|child| child.interpret(context))
            .collect();
        (self.combinator)(&results)
    }
}
```

### 2.2 ç±»å‹å®‰å…¨ä¸æ‰€æœ‰æƒ

- Rust trait å¯¹è±¡ä¸æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿è§£é‡Šå™¨å°è£…çš„ç±»å‹å®‰å…¨ã€‚
- é€šè¿‡æ³›å‹å’Œ trait çº¦æŸä¿è¯ä¸Šä¸‹æ–‡ä¸ç»“æœç±»å‹ä¸€è‡´ã€‚

#### å…¬å¼ï¼šç±»å‹å®‰å…¨ä¿è¯

$$
\forall e, c,\ \text{type}(\text{interpret}(e, c)) = \text{type}(e.\text{Result})
$$

---

## 3. å½¢å¼åŒ–è¯æ˜ä¸å¤æ‚åº¦åˆ†æ

### 3.1 è§£é‡Šä¸ç»„åˆæ­£ç¡®æ€§è¯æ˜

**å‘½é¢˜ 3.1**ï¼šè§£é‡Šå™¨çš„æ­£ç¡®æ€§ä¸ç»„åˆæ€§

- è§£é‡Šå‡½æ•°é€’å½’å®šä¹‰ï¼Œç»“æœå”¯ä¸€ä¸”ç¬¦åˆè¯­ä¹‰
- å¤åˆè¡¨è¾¾å¼çš„è§£é‡Šç”±å­è¡¨è¾¾å¼ç»„åˆè€Œæˆ

**è¯æ˜ç•¥**ï¼ˆè§æ­£æ–‡ 4.1ã€4.2 èŠ‚ï¼‰

### 3.2 æ€§èƒ½ä¸ç©ºé—´å¤æ‚åº¦

| æ“ä½œ         | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|--------------|------------|------------|
| è§£é‡Š         | $O(n)$     | $O(h)$/æ ‘é«˜ |
| è¯­æ³•æ ‘ä¼˜åŒ–   |:---:|:---:|:---:| $O(n)$     |:---:|:---:|:---:| $O(n)$/èŠ‚ç‚¹ |:---:|:---:|:---:|



---

## 4. å¤šæ¨¡æ€åº”ç”¨ä¸å·¥ç¨‹å®è·µ

### 4.1 ç¼–ç¨‹è¯­è¨€ä¸è§„åˆ™å¼•æ“å»ºæ¨¡

- è„šæœ¬è¯­è¨€è§£é‡Šå™¨ã€æŸ¥è¯¢è¯­è¨€è§£æã€é…ç½®è¯­è¨€å¤„ç†
- è§„åˆ™å¼•æ“ã€æ¡ä»¶è¡¨è¾¾å¼ã€å·¥ä½œæµå®šä¹‰

### 4.2 æ•°å­¦è¡¨è¾¾å¼ä¸ç¬¦å·è®¡ç®—

- æ•°å­¦è¡¨è¾¾å¼æ±‚å€¼ã€å…¬å¼è®¡ç®—å¼•æ“ã€ç¬¦å·è®¡ç®—ç³»ç»Ÿ

#### Mermaid å›¾ï¼šAST ä¼˜åŒ–ä¸è§£é‡Š

```mermaid
graph TD
  AST["AST"]
  Optimizer["Optimizer"]
  Interpreter["Interpreter"]
  AST --> Optimizer
  Optimizer --> Interpreter
```

---

## 5. æ‰¹åˆ¤æ€§åˆ†æä¸äº¤å‰å¯¹æ¯”

- **ä¸è®¿é—®è€…æ¨¡å¼å¯¹æ¯”**ï¼šè®¿é—®è€…å…³æ³¨æ“ä½œåˆ†ç¦»ï¼Œè§£é‡Šå™¨å…³æ³¨è¯­æ³•è§£é‡Šã€‚
- **ä¸ç»„åˆæ¨¡å¼å¯¹æ¯”**ï¼šç»„åˆæ¨¡å¼å…³æ³¨ç»“æ„ç»„ç»‡ï¼Œè§£é‡Šå™¨æ¨¡å¼å…³æ³¨è¯­ä¹‰è§£é‡Šã€‚
- **å·¥ç¨‹æƒè¡¡**ï¼šè§£é‡Šå™¨é€‚åˆè§„åˆ™é¢‘ç¹å˜åŒ–åœºæ™¯ï¼Œä½†åœ¨é«˜æ€§èƒ½éœ€æ±‚ä¸‹éœ€æƒè¡¡é€’å½’ä¸æ•ˆç‡ã€‚

---

## 6. è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®

- [x] ç»“æ„åŒ–åˆ†èŠ‚ä¸ç¼–å·
- [x] å¤šæ¨¡æ€è¡¨è¾¾ï¼ˆMermaidã€è¡¨æ ¼ã€å…¬å¼ã€ä»£ç ã€è¯æ˜ï¼‰
- [x] æ‰¹åˆ¤æ€§åˆ†æä¸äº¤å‰å¼•ç”¨
- [x] å¤æ‚åº¦ä¸å·¥ç¨‹å®è·µè¡¥å……
- [x] æ–‡æœ«è¿›åº¦ä¸å»ºè®®åŒºå—

**åç»­å»ºè®®**ï¼š

1. å¯è¡¥å……æ›´å¤šå®é™…å·¥ç¨‹æ¡ˆä¾‹ï¼ˆå¦‚ DSL è§£é‡Šå™¨ã€è§„åˆ™å¼•æ“ç­‰ï¼‰
2. å¢å¼ºä¸ Rust ç”Ÿå‘½å‘¨æœŸã€trait å¯¹è±¡çš„æ·±åº¦ç»“åˆåˆ†æ
3. å¢åŠ ä¸å…¶ä»–è¡Œä¸ºå‹æ¨¡å¼çš„ç³»ç»Ÿæ€§å¯¹æ¯”è¡¨

---

**å‚è€ƒæ–‡çŒ®**ï¼š

1. Gamma, E., et al. "Design Patterns: Elements of Reusable Object-Oriented Software"
2. Pierce, B. C. "Types and Programming Languages"
3. Mac Lane, S. "Categories for the Working Mathematician"
