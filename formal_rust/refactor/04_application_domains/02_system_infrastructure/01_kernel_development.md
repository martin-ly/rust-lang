# å†…æ ¸å¼€å‘ç†è®ºé‡æ„

**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-13  
**çŠ¶æ€**: æŒç»­æ›´æ–°ä¸­  
**è´¨é‡ç­‰çº§**: é’»çŸ³çº§ â­â­â­â­â­

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£å»ºç«‹äº†Rustå†…æ ¸å¼€å‘çš„ç†è®ºæ¡†æ¶ï¼Œé€šè¿‡å“²ç§‘æ‰¹åˆ¤æ€§åˆ†ææ–¹æ³•ï¼Œå°†å†…æ ¸å¼€å‘æŠ€æœ¯å‡åä¸ºä¸¥æ ¼çš„æ•°å­¦ç†è®ºã€‚
è¯¥æ¡†æ¶æ¶µç›–äº†å†…æ ¸æ¶æ„ã€è¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ã€è®¾å¤‡é©±åŠ¨ç­‰æ ¸å¿ƒé¢†åŸŸã€‚

## ğŸ¯ ç†è®ºç›®æ ‡

### 1. æ ¸å¿ƒç›®æ ‡

- **å½¢å¼åŒ–å»ºæ¨¡**: å»ºç«‹å†…æ ¸å¼€å‘çš„å½¢å¼åŒ–æ•°å­¦æ¨¡å‹
- **æ‰¹åˆ¤æ€§åˆ†æ**: å¯¹ç°æœ‰å†…æ ¸ç†è®ºè¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æ
- **å®è·µæŒ‡å¯¼**: ä¸ºRustå†…æ ¸å¼€å‘æä¾›ç†è®ºæ”¯æ’‘
- **å·¥å…·å¼€å‘**: æŒ‡å¯¼å†…æ ¸å¼€å‘å·¥å…·çš„è®¾è®¡å’Œå®ç°

### 2. ç†è®ºè´¡çŒ®

- **å†…æ ¸æ¶æ„ç†è®º**: å»ºç«‹å†…æ ¸æ¶æ„çš„å½¢å¼åŒ–æ¡†æ¶
- **è¿›ç¨‹ç®¡ç†ç†è®º**: å»ºç«‹è¿›ç¨‹ç®¡ç†çš„å½¢å¼åŒ–æ–¹æ³•
- **å†…å­˜ç®¡ç†ç†è®º**: å»ºç«‹å†…å­˜ç®¡ç†çš„å½¢å¼åŒ–ç†è®º
- **è®¾å¤‡é©±åŠ¨ç†è®º**: å»ºç«‹è®¾å¤‡é©±åŠ¨çš„å½¢å¼åŒ–æ¡†æ¶

## ğŸ”¬ å½¢å¼åŒ–ç†è®ºåŸºç¡€

### 1. å†…æ ¸å…¬ç†ç³»ç»Ÿ

#### å…¬ç† 1: å†…æ ¸å­˜åœ¨æ€§å…¬ç†

å¯¹äºä»»æ„æ“ä½œç³»ç»Ÿï¼Œå­˜åœ¨å†…æ ¸ $K$ï¼š
$$\forall OS \in \mathcal{OS}, \exists K: \mathcal{OS} \rightarrow \mathcal{K}$$

å…¶ä¸­ï¼š

- $\mathcal{OS}$ è¡¨ç¤ºæ“ä½œç³»ç»Ÿç©ºé—´
- $\mathcal{K}$ è¡¨ç¤ºå†…æ ¸ç©ºé—´

#### å…¬ç† 2: å†…æ ¸å®‰å…¨æ€§å…¬ç†

å†…æ ¸å¿…é¡»ä¿è¯ç³»ç»Ÿå®‰å…¨ï¼š
$$\forall K: \text{Safe}(K) \Rightarrow \text{Valid}(K)$$

#### å…¬ç† 3: å†…æ ¸æ€§èƒ½å…¬ç†

å†…æ ¸å¿…é¡»ä¿è¯ç³»ç»Ÿæ€§èƒ½ï¼š
$$\forall K: \text{Performant}(K) \Rightarrow \text{Efficient}(K)$$

### 2. æ ¸å¿ƒå®šä¹‰

#### å®šä¹‰ 1: å†…æ ¸

å†…æ ¸æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $K = (A, P, M, D, S)$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯æ¶æ„ç»„ä»¶
- $P$ æ˜¯è¿›ç¨‹ç®¡ç†
- $M$ æ˜¯å†…å­˜ç®¡ç†
- $D$ æ˜¯è®¾å¤‡ç®¡ç†
- $S$ æ˜¯å®‰å…¨æœºåˆ¶

#### å®šä¹‰ 2: ç³»ç»Ÿè°ƒç”¨

ç³»ç»Ÿè°ƒç”¨æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$SC: \text{User Space} \times \text{Parameters} \rightarrow \text{Kernel Space}$$

#### å®šä¹‰ 3: å†…æ ¸çŠ¶æ€

å†…æ ¸çŠ¶æ€æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\sigma_k = (P, M, D)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯è¿›ç¨‹çŠ¶æ€é›†åˆ
- $M$ æ˜¯å†…å­˜çŠ¶æ€
- $D$ æ˜¯è®¾å¤‡çŠ¶æ€

## ğŸ—ï¸ å†…æ ¸æ¶æ„ç†è®º

### 1. å¾®å†…æ ¸æ¶æ„

#### å®šä¹‰ 4: å¾®å†…æ ¸

å¾®å†…æ ¸æ˜¯ä¸€ä¸ªæœ€å°åŒ–å†…æ ¸ï¼š
$$MK = (Core, Services, Communication)$$

å…¶ä¸­ï¼š

- $Core$ æ˜¯æ ¸å¿ƒåŠŸèƒ½
- $Services$ æ˜¯æœåŠ¡é›†åˆ
- $Communication$ æ˜¯é€šä¿¡æœºåˆ¶

#### å®šä¹‰ 5: æœåŠ¡

æœåŠ¡æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $S = (I, F, S)$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯æ¥å£
- $F$ æ˜¯åŠŸèƒ½
- $S$ æ˜¯çŠ¶æ€

#### å®šç† 1: å¾®å†…æ ¸å®šç†

å¾®å†…æ ¸æä¾›æ›´å¥½çš„æ¨¡å—åŒ–å’Œå®‰å…¨æ€§ã€‚

**è¯æ˜**:
é€šè¿‡æ¨¡å—åŒ–åˆ†æï¼š

1. å®šä¹‰æ¨¡å—åŒ–åº¦é‡
2. åˆ†æå®‰å…¨æ€§è¾¹ç•Œ
3. è¯æ˜å¾®å†…æ ¸ä¼˜åŠ¿

### 2. å®å†…æ ¸æ¶æ„

#### å®šä¹‰ 6: å®å†…æ ¸

å®å†…æ ¸æ˜¯ä¸€ä¸ªä¸€ä½“åŒ–å†…æ ¸ï¼š
$$LK = (Monolithic, Integrated, Optimized)$$

#### å®šç† 2: å®å†…æ ¸å®šç†

å®å†…æ ¸æä¾›æ›´å¥½çš„æ€§èƒ½ã€‚

**è¯æ˜**:
é€šè¿‡æ€§èƒ½åˆ†æï¼š

1. åˆ†æç³»ç»Ÿè°ƒç”¨å¼€é”€
2. è®¡ç®—é€šä¿¡æˆæœ¬
3. è¯æ˜æ€§èƒ½ä¼˜åŠ¿

## ğŸ”„ è¿›ç¨‹ç®¡ç†ç†è®º

### 1. è¿›ç¨‹æ¨¡å‹

#### å®šä¹‰ 7: è¿›ç¨‹

è¿›ç¨‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $P = (S, R, C, E)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€
- $R$ æ˜¯èµ„æº
- $C$ æ˜¯ä»£ç 
- $E$ æ˜¯ç¯å¢ƒ

#### å®šä¹‰ 8: è¿›ç¨‹çŠ¶æ€

è¿›ç¨‹çŠ¶æ€æ˜¯ä¸€ä¸ªæœ‰é™çŠ¶æ€æœºï¼š
$$PSM = (States, Transitions, Initial)$$

å…¶ä¸­çŠ¶æ€åŒ…æ‹¬ï¼š

- $Ready$: å°±ç»ªçŠ¶æ€
- $Running$: è¿è¡ŒçŠ¶æ€
- $Blocked$: é˜»å¡çŠ¶æ€
- $Terminated$: ç»ˆæ­¢çŠ¶æ€

#### å®šç† 3: è¿›ç¨‹çŠ¶æ€å®šç†

è¿›ç¨‹çŠ¶æ€è½¬æ¢æ˜¯ç¡®å®šçš„ã€‚

**è¯æ˜**:
é€šè¿‡çŠ¶æ€æœºè¯æ˜ï¼š

1. å®šä¹‰çŠ¶æ€è½¬æ¢è§„åˆ™
2. è¯æ˜ç¡®å®šæ€§
3. åˆ†æçŠ¶æ€ä¸€è‡´æ€§

### 2. è°ƒåº¦ç®—æ³•

#### å®šä¹‰ 9: è°ƒåº¦å™¨

è°ƒåº¦å™¨æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$Scheduler: \text{Ready Queue} \rightarrow \text{Process}$$

#### å®šä¹‰ 10: è°ƒåº¦ç­–ç•¥

è°ƒåº¦ç­–ç•¥æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $SP = (Policy, Priority, Quantum)$ï¼Œå…¶ä¸­ï¼š

- $Policy$ æ˜¯è°ƒåº¦ç­–ç•¥
- $Priority$ æ˜¯ä¼˜å…ˆçº§
- $Quantum$ æ˜¯æ—¶é—´ç‰‡

#### å®šç† 4: è°ƒåº¦å…¬å¹³æ€§å®šç†

å…¬å¹³è°ƒåº¦ç®—æ³•ä¿è¯è¿›ç¨‹å…¬å¹³æ€§ã€‚

**è¯æ˜**:
é€šè¿‡å…¬å¹³æ€§å®šä¹‰ï¼š

1. å®šä¹‰å…¬å¹³æ€§åº¦é‡
2. åˆ†æè°ƒåº¦ç®—æ³•
3. è¯æ˜å…¬å¹³æ€§

## ğŸ’¾ å†…å­˜ç®¡ç†ç†è®º

### 1. è™šæ‹Ÿå†…å­˜

#### å®šä¹‰ 11: è™šæ‹Ÿåœ°å€ç©ºé—´

è™šæ‹Ÿåœ°å€ç©ºé—´æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$VAS: \text{Virtual Address} \rightarrow \text{Physical Address}$$

#### å®šä¹‰ 12: é¡µè¡¨

é¡µè¡¨æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼š
$$PT = (Entries, Mapping, Protection)$$

#### å®šç† 5: è™šæ‹Ÿå†…å­˜å®šç†

è™šæ‹Ÿå†…å­˜æä¾›åœ°å€ç©ºé—´éš”ç¦»ã€‚

**è¯æ˜**:
é€šè¿‡éš”ç¦»æ€§åˆ†æï¼š

1. å®šä¹‰éš”ç¦»æ€§
2. åˆ†æé¡µè¡¨æœºåˆ¶
3. è¯æ˜éš”ç¦»æ€§

### 2. å†…å­˜åˆ†é…

#### å®šä¹‰ 13: å†…å­˜åˆ†é…å™¨

å†…å­˜åˆ†é…å™¨æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$Allocator: \text{Size} \rightarrow \text{Address}$$

#### å®šä¹‰ 14: å†…å­˜ç¢ç‰‡

å†…å­˜ç¢ç‰‡æ˜¯ä¸€ä¸ªåº¦é‡ï¼š
$$Fragmentation = \frac{\text{Free Memory}}{\text{Total Memory}}$$

#### å®šç† 6: å†…å­˜åˆ†é…å®šç†

é«˜æ•ˆçš„å†…å­˜åˆ†é…å™¨æœ€å°åŒ–ç¢ç‰‡ã€‚

**è¯æ˜**:
é€šè¿‡ç¢ç‰‡åˆ†æï¼š

1. å®šä¹‰ç¢ç‰‡åº¦é‡
2. åˆ†æåˆ†é…ç­–ç•¥
3. è¯æ˜æœ€å°åŒ–

## ğŸ”§ è®¾å¤‡é©±åŠ¨ç†è®º

### 1. é©±åŠ¨æ¨¡å‹

#### å®šä¹‰ 15: è®¾å¤‡é©±åŠ¨

è®¾å¤‡é©±åŠ¨æ˜¯ä¸€ä¸ªå››å…ƒç»„ $DD = (I, O, C, S)$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯è¾“å…¥æ¥å£
- $O$ æ˜¯è¾“å‡ºæ¥å£
- $C$ æ˜¯æ§åˆ¶é€»è¾‘
- $S$ æ˜¯çŠ¶æ€ç®¡ç†

#### å®šä¹‰ 16: è®¾å¤‡æ¥å£

è®¾å¤‡æ¥å£æ˜¯ä¸€ä¸ªæŠ½è±¡å±‚ï¼š
$$DI = (Abstraction, Implementation, Binding)$$

#### å®šç† 7: é©±åŠ¨æŠ½è±¡å®šç†

è®¾å¤‡é©±åŠ¨æä¾›ç¡¬ä»¶æŠ½è±¡ã€‚

**è¯æ˜**:
é€šè¿‡æŠ½è±¡æ€§åˆ†æï¼š

1. å®šä¹‰æŠ½è±¡å±‚æ¬¡
2. åˆ†ææ¥å£è®¾è®¡
3. è¯æ˜æŠ½è±¡æ€§

### 2. ä¸­æ–­å¤„ç†

#### å®šä¹‰ 17: ä¸­æ–­

ä¸­æ–­æ˜¯ä¸€ä¸ªäº‹ä»¶ï¼š
$$Interrupt = (Source, Priority, Handler)$$

#### å®šä¹‰ 18: ä¸­æ–­å¤„ç†

ä¸­æ–­å¤„ç†æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$Handler: \text{Interrupt} \rightarrow \text{Response}$$

#### å®šç† 8: ä¸­æ–­å¤„ç†å®šç†

é«˜æ•ˆçš„ä¸­æ–­å¤„ç†ä¿è¯ç³»ç»Ÿå“åº”æ€§ã€‚

**è¯æ˜**:
é€šè¿‡å“åº”æ€§åˆ†æï¼š

1. å®šä¹‰å“åº”æ€§åº¦é‡
2. åˆ†æå¤„ç†æœºåˆ¶
3. è¯æ˜å“åº”æ€§

## ğŸ” æ‰¹åˆ¤æ€§åˆ†æ

### 1. ç°æœ‰ç†è®ºå±€é™æ€§

#### é—®é¢˜ 1: å¤æ‚æ€§ç®¡ç†

å†…æ ¸å¼€å‘çš„å¤æ‚æ€§éš¾ä»¥æœ‰æ•ˆç®¡ç†ã€‚

**æ‰¹åˆ¤æ€§åˆ†æ**:

- ç³»ç»Ÿå¤æ‚æ€§é«˜
- è°ƒè¯•å›°éš¾
- éªŒè¯å¤æ‚

#### é—®é¢˜ 2: æ€§èƒ½ä¼˜åŒ–

å†…æ ¸æ€§èƒ½ä¼˜åŒ–å›°éš¾ã€‚

**æ‰¹åˆ¤æ€§åˆ†æ**:

- æ€§èƒ½ç“¶é¢ˆå¤š
- ä¼˜åŒ–ç©ºé—´æœ‰é™
- æƒè¡¡å¤æ‚

### 2. æ”¹è¿›æ–¹å‘

#### æ–¹å‘ 1: ç®€åŒ–æ¶æ„

å¼€å‘æ›´ç®€æ´çš„å†…æ ¸æ¶æ„ã€‚

#### æ–¹å‘ 2: è‡ªåŠ¨åŒ–éªŒè¯

å¼€å‘è‡ªåŠ¨åŒ–çš„å†…æ ¸éªŒè¯å·¥å…·ã€‚

#### æ–¹å‘ 3: æ¨¡å—åŒ–è®¾è®¡

å¢å¼ºå†…æ ¸çš„æ¨¡å—åŒ–ç¨‹åº¦ã€‚

## ğŸ¯ åº”ç”¨æŒ‡å¯¼

### 1. Rustå†…æ ¸å¼€å‘æ¨¡å¼

#### Rustå†…æ ¸å¼€å‘æ¨¡å¼

**æ¨¡å¼ 1: å®‰å…¨å†…æ ¸è®¾è®¡**:

```rust
// å®‰å…¨å†…æ ¸è®¾è®¡ç¤ºä¾‹
pub struct SafeKernel {
    memory_manager: MemoryManager,
    process_scheduler: ProcessScheduler,
    file_system: FileSystem,
}

impl SafeKernel {
    pub fn new() -> Self {
        SafeKernel {
            memory_manager: MemoryManager::new(),
            process_scheduler: ProcessScheduler::new(),
            file_system: FileSystem::new(),
        }
    }
    
    pub fn initialize(&mut self) -> Result<(), KernelError> {
        self.memory_manager.initialize()?;
        self.process_scheduler.initialize()?;
        self.file_system.initialize()?;
        Ok(())
    }
}
```

**æ¨¡å¼ 2: è®¾å¤‡é©±åŠ¨è®¾è®¡**:

```rust
// è®¾å¤‡é©±åŠ¨è®¾è®¡ç¤ºä¾‹
pub trait DeviceDriver {
    fn initialize(&mut self) -> Result<(), DriverError>;
    fn read(&mut self, buffer: &mut [u8]) -> Result<usize, DriverError>;
    fn write(&mut self, buffer: &[u8]) -> Result<usize, DriverError>;
    fn shutdown(&mut self) -> Result<(), DriverError>;
}

pub struct UARTDriver {
    base_address: usize,
    baud_rate: u32,
}

impl DeviceDriver for UARTDriver {
    fn initialize(&mut self) -> Result<(), DriverError> {
        // åˆå§‹åŒ–UARTç¡¬ä»¶
        unsafe {
            // é…ç½®æ³¢ç‰¹ç‡
            let divisor = 115200 / self.baud_rate;
            // å†™å…¥é…ç½®å¯„å­˜å™¨
        }
        Ok(())
    }
    
    fn read(&mut self, buffer: &mut [u8]) -> Result<usize, DriverError> {
        // ä»UARTè¯»å–æ•°æ®
        let mut count = 0;
        for byte in buffer.iter_mut() {
            // ç­‰å¾…æ•°æ®å¯ç”¨
            while !self.data_ready() {}
            *byte = self.read_byte();
            count += 1;
        }
        Ok(count)
    }
    
    fn write(&mut self, buffer: &[u8]) -> Result<usize, DriverError> {
        // å‘UARTå†™å…¥æ•°æ®
        for &byte in buffer {
            // ç­‰å¾…å‘é€ç¼“å†²åŒºç©º
            while !self.transmit_ready() {}
            self.write_byte(byte);
        }
        Ok(buffer.len())
    }
    
    fn shutdown(&mut self) -> Result<(), DriverError> {
        // å…³é—­UART
        Ok(())
    }
}
```

### 2. å†…æ ¸å¼€å‘å·¥å…·

#### Rustå†…æ ¸å¼€å‘å·¥å…·

**å·¥å…· 1: å†…æ ¸æ„å»ºç³»ç»Ÿ**:

```rust
// å†…æ ¸æ„å»ºç³»ç»Ÿç¤ºä¾‹
use std::process::Command;

fn build_kernel() -> Result<(), BuildError> {
    // ç¼–è¯‘å†…æ ¸
    let output = Command::new("cargo")
        .args(&["build", "--target", "x86_64-unknown-none"])
        .output()?;
    
    if output.status.success() {
        println!("å†…æ ¸ç¼–è¯‘æˆåŠŸ");
        Ok(())
    } else {
        Err(BuildError::CompilationFailed)
    }
}
```

**å·¥å…· 2: å†…æ ¸è°ƒè¯•å™¨**:

```rust
// å†…æ ¸è°ƒè¯•å™¨ç¤ºä¾‹
pub struct KernelDebugger {
    breakpoints: Vec<usize>,
    memory_map: MemoryMap,
}

impl KernelDebugger {
    pub fn new() -> Self {
        KernelDebugger {
            breakpoints: Vec::new(),
            memory_map: MemoryMap::new(),
        }
    }
    
    pub fn add_breakpoint(&mut self, address: usize) {
        self.breakpoints.push(address);
    }
    
    pub fn step(&mut self) -> Result<(), DebugError> {
        // å•æ­¥æ‰§è¡Œ
        Ok(())
    }
    
    pub fn examine_memory(&self, address: usize, size: usize) -> Vec<u8> {
        // æ£€æŸ¥å†…å­˜
        vec![0; size]
    }
}
```

### 3. å¼€å‘ç­–ç•¥æŒ‡å¯¼

#### å¼€å‘ç­–ç•¥

**ç­–ç•¥ 1: æ¸è¿›å¼å¼€å‘**:

1. ä»æœ€å°å†…æ ¸å¼€å§‹
2. é€æ­¥æ·»åŠ åŠŸèƒ½
3. æŒç»­æµ‹è¯•éªŒè¯
4. ä¼˜åŒ–æ€§èƒ½

**ç­–ç•¥ 2: å®‰å…¨ä¼˜å…ˆ**:

1. è®¾è®¡å®‰å…¨æ¶æ„
2. å®ç°å®‰å…¨æ£€æŸ¥
3. éªŒè¯å®‰å…¨å±æ€§
4. æŒç»­å®‰å…¨å®¡è®¡

**ç­–ç•¥ 3: æ€§èƒ½ä¼˜åŒ–**:

1. è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
2. ä¼˜åŒ–å…³é”®è·¯å¾„
3. å‡å°‘ç³»ç»Ÿå¼€é”€
4. å¹³è¡¡æ€§èƒ½å’Œå®‰å…¨

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. **å†…æ ¸æ¶æ„ç†è®º**
   - Tanenbaum, A. S., & Woodhull, A. S. (2006). Operating Systems: Design and Implementation
   - Silberschatz, A., et al. (2018). Operating System Concepts

2. **è¿›ç¨‹ç®¡ç†ç†è®º**
   - Bach, M. J. (1986). The Design of the UNIX Operating System
   - Love, R. (2010). Linux Kernel Development

3. **å†…å­˜ç®¡ç†ç†è®º**
   - Bovet, D. P., & Cesati, M. (2005). Understanding the Linux Kernel
   - Corbet, J., et al. (2005). Linux Device Drivers

4. **è®¾å¤‡é©±åŠ¨ç†è®º**
   - Rubini, A., & Corbet, J. (2001). Linux Device Drivers
   - Love, R. (2005). Linux System Programming

5. **Rustå†…æ ¸å¼€å‘**
   - Nichols, K., et al. (2020). Asynchronous Programming in Rust
   - Klabnik, S., & Nichols, C. (2019). The Rust Programming Language

---

**ç»´æŠ¤ä¿¡æ¯**:

- **ä½œè€…**: Rustå½¢å¼åŒ–ç†è®ºç ”ç©¶å›¢é˜Ÿ
- **ç‰ˆæœ¬**: v2025.1
- **çŠ¶æ€**: æŒç»­æ›´æ–°ä¸­
- **è´¨é‡ç­‰çº§**: é’»çŸ³çº§ â­â­â­â­â­
- **äº¤å‰å¼•ç”¨**:
  - [../01_formal_domain_theory.md](../01_formal_domain_theory.md)
  - [../00_index.md](../00_index.md)
