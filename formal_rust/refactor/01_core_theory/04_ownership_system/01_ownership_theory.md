# 01. Rust æ‰€æœ‰æƒç³»ç»Ÿç†è®ºï¼ˆ01_ownership_theoryï¼‰

## ğŸ“… æ–‡æ¡£ä¿¡æ¯

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-08-11  
**æœ€åæ›´æ–°**: 2025-08-11  
**çŠ¶æ€**: å·²å®Œæˆ  
**è´¨é‡ç­‰çº§**: é’»çŸ³çº§ â­â­â­â­â­

---



## 1. 0 ä¸¥æ ¼ç¼–å·ç›®å½•

- [01. Rust æ‰€æœ‰æƒç³»ç»Ÿç†è®ºï¼ˆ01\_ownership\_theoryï¼‰](#01-rust-æ‰€æœ‰æƒç³»ç»Ÿç†è®º01_ownership_theory)
  - [1.0 ä¸¥æ ¼ç¼–å·ç›®å½•](#10-ä¸¥æ ¼ç¼–å·ç›®å½•)
  - [1.1 æ‰€æœ‰æƒå…¬ç†ç³»ç»Ÿ](#11-æ‰€æœ‰æƒå…¬ç†ç³»ç»Ÿ)
    - [1.1.1 åŸºæœ¬å…¬ç†](#111-åŸºæœ¬å…¬ç†)
    - [1.1.2 æ‰€æœ‰æƒå…³ç³»](#112-æ‰€æœ‰æƒå…³ç³»)
    - [1.1.3 æ‰¹åˆ¤æ€§åˆ†æ](#113-æ‰¹åˆ¤æ€§åˆ†æ)
  - [1.2 å€Ÿç”¨ç³»ç»Ÿç†è®º](#12-å€Ÿç”¨ç³»ç»Ÿç†è®º)
    - [1.2.1 å€Ÿç”¨å…¬ç†](#121-å€Ÿç”¨å…¬ç†)
    - [1.2.2 å€Ÿç”¨è§„åˆ™](#122-å€Ÿç”¨è§„åˆ™)
    - [1.2.3 å€Ÿç”¨ç±»å‹](#123-å€Ÿç”¨ç±»å‹)
    - [1.2.4 æ‰¹åˆ¤æ€§åˆ†æ](#124-æ‰¹åˆ¤æ€§åˆ†æ)
  - [1.3 ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ](#13-ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ)
    - [1.3.1 ç”Ÿå‘½å‘¨æœŸå‚æ•°](#131-ç”Ÿå‘½å‘¨æœŸå‚æ•°)
  - [1.4 äº¤å‰å¼•ç”¨ä¸æœ¬åœ°å¯¼èˆª](#14-äº¤å‰å¼•ç”¨ä¸æœ¬åœ°å¯¼èˆª)
  - [1.5 è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®](#15-è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)

---

## 1. 1 æ‰€æœ‰æƒå…¬ç†ç³»ç»Ÿ

### 1.1.1 åŸºæœ¬å…¬ç†

**å…¬ç† 1.1ï¼ˆå”¯ä¸€æ‰€æœ‰æƒå…¬ç†ï¼‰**
$$\forall v \in \text{Value}: \exists! o \in \text{Owner}: \text{Owns}(o, v)$$

**å…¬ç† 1.2ï¼ˆæ‰€æœ‰æƒè½¬ç§»å…¬ç†ï¼‰**
$$\text{Transfer}(v, o_1, o_2) \Rightarrow \neg \text{Owns}(o_1, v) \land \text{Owns}(o_2, v)$$

**å…¬ç† 1.3ï¼ˆæ‰€æœ‰æƒé”€æ¯å…¬ç†ï¼‰**
$$\text{Drop}(o) \Rightarrow \forall v: \text{Owns}(o, v) \rightarrow \text{Deallocate}(v)$$

- **ç†è®ºåŸºç¡€**ï¼šæ‰€æœ‰æƒç³»ç»Ÿä¿è¯æ¯ä¸ªå€¼æœ‰å”¯ä¸€æ‰€æœ‰è€…ï¼Œè½¬ç§»å’Œé”€æ¯å‡æœ‰ä¸¥æ ¼è§„åˆ™ã€‚
- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šå˜é‡ moveã€dropã€clone è¡Œä¸ºã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// æ‰€æœ‰æƒç¤ºä¾‹
fn ownership_example() {
    let s1 = String::from("hello");
    let s2 = s1;  // æ‰€æœ‰æƒè½¬ç§»ï¼šs1 ç§»åŠ¨åˆ° s2
    // println!("{}", s1);  // ç¼–è¯‘é”™è¯¯ï¼šs1 å·²è¢«ç§»åŠ¨
    
    let s3 = s2.clone();  // å¤åˆ¶ï¼šs2 ä»ç„¶æœ‰æ•ˆ
    println!("{}", s2);   // æ­£ç¡®
    println!("{}", s3);   // æ­£ç¡®
    // è‡ªåŠ¨é”€æ¯ï¼šs2 å’Œ s3 åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨ drop
}
```

- **Mermaid å¯è§†åŒ–**ï¼š

```mermaid
graph TD
    A[æ‰€æœ‰æƒ] -- move --> B[æ–°æ‰€æœ‰è€…]
    A -- borrow --> C[å€Ÿç”¨è€…]
    B -- drop --> D[é‡Šæ”¾]
```

### 1.1.2 æ‰€æœ‰æƒå…³ç³»

**å®šä¹‰ 1.1ï¼ˆæ‰€æœ‰æƒå…³ç³»ï¼‰**
$$\text{OwnershipRelation} = \{(o, v) \mid \text{Owns}(o, v)\}$$

**å®šç† 1.1ï¼ˆæ‰€æœ‰æƒå‡½æ•°æ€§ï¼‰**
æ‰€æœ‰æƒå…³ç³»æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$\text{Ownership}: \text{Value} \rightarrow \text{Owner}$$

- **æ‰¹åˆ¤æ€§åˆ†æ**ï¼šæ‰€æœ‰æƒå”¯ä¸€æ€§æå‡å®‰å…¨æ€§ï¼Œä½†å¯¹å¹¶å‘å’Œå¤æ‚æ•°æ®ç»“æ„æœ‰ä¸€å®šçº¦æŸã€‚

### 1.1.3 æ‰¹åˆ¤æ€§åˆ†æ

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| æ‰€æœ‰æƒç³»ç»Ÿ   | ä¿è¯å†…å­˜å®‰å…¨ï¼Œé˜²æ­¢æ‚¬å‚æŒ‡é’ˆ | å¯¹å¤æ‚åœºæ™¯è¡¨è¾¾æœ‰é™         |

---

## 1. 2 å€Ÿç”¨ç³»ç»Ÿç†è®º

### 1.2.1 å€Ÿç”¨å…¬ç†

**å…¬ç† 1.4ï¼ˆä¸å¯å˜å€Ÿç”¨å…¬ç†ï¼‰**
$$\forall r \in \text{ImmutableReference}: \text{Valid}(r) \Rightarrow \text{ReadOnly}(r)$$

**å…¬ç† 1.5ï¼ˆå¯å˜å€Ÿç”¨å…¬ç†ï¼‰**
$$\forall r \in \text{MutableReference}: \text{Valid}(r) \Rightarrow \text{Exclusive}(r)$$

**å…¬ç† 1.6ï¼ˆå€Ÿç”¨å†²çªå…¬ç†ï¼‰**
$$\neg (\text{Valid}(r_1) \land \text{Valid}(r_2) \land \text{Conflicting}(r_1, r_2))$$

- **ç†è®ºåŸºç¡€**ï¼šå€Ÿç”¨ç³»ç»ŸåŒºåˆ†å¯å˜ä¸ä¸å¯å˜å€Ÿç”¨ï¼Œé˜²æ­¢æ•°æ®ç«äº‰ã€‚
- **å·¥ç¨‹æ¡ˆä¾‹**ï¼š&Tã€&mut Tã€RefCellã€Mutexã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å€Ÿç”¨ç¤ºä¾‹
fn borrowing_example() {
    let mut data = vec![1, 2, 3, 4, 5];
    // ä¸å¯å˜å€Ÿç”¨
    let ref1 = &data;
    let ref2 = &data;  // å¤šä¸ªä¸å¯å˜å€Ÿç”¨
    // å¯å˜å€Ÿç”¨ï¼ˆç¼–è¯‘é”™è¯¯ï¼‰
    // let ref3 = &mut data;  // ç¼–è¯‘é”™è¯¯ï¼šå·²æœ‰ä¸å¯å˜å€Ÿç”¨
    println!("{:?} {:?}", ref1, ref2);
    // ä¸å¯å˜å€Ÿç”¨ç»“æŸï¼Œå¯ä»¥å¯å˜å€Ÿç”¨
    let ref3 = &mut data;
    ref3.push(6);
}
```

### 1.2.2 å€Ÿç”¨è§„åˆ™

**è§„åˆ™ 1.1ï¼ˆå€Ÿç”¨æ£€æŸ¥è§„åˆ™ï¼‰**
$$\frac{\text{Owns}(o, v) \quad \text{Borrow}(o, v, r)}{\text{Valid}(r) \land \text{Reference}(r, v)}$$

**è§„åˆ™ 1.2ï¼ˆå€Ÿç”¨å†²çªè§„åˆ™ï¼‰**
$$\frac{\text{Valid}(r_1) \land \text{Valid}(r_2) \land \text{Overlap}(r_1, r_2)}{\text{Conflicting}(r_1, r_2)}$$

- **Mermaid å¯è§†åŒ–**ï¼š

```mermaid
graph LR
    A[æ‰€æœ‰æƒ] -- borrow --> B[ä¸å¯å˜å€Ÿç”¨]
    A -- borrow_mut --> C[å¯å˜å€Ÿç”¨]
    B -- overlap --> D[å†²çªæ£€æµ‹]
    C -- overlap --> D
```

### 1.2.3 å€Ÿç”¨ç±»å‹

**å®šä¹‰ 1.2ï¼ˆå€Ÿç”¨ç±»å‹ï¼‰**
$$\text{BorrowType} = \text{ImmutableReference} \cup \text{MutableReference}$$

**å®šä¹‰ 1.3ï¼ˆå€Ÿç”¨ä¿¡æ¯ï¼‰**
$$\text{BorrowInfo} = \text{Type} \times \text{Lifetime} \times \text{Permission}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šå€Ÿç”¨ä¿¡æ¯åœ¨ç¼–è¯‘æœŸé™æ€åˆ†æã€‚

### 1.2.4 æ‰¹åˆ¤æ€§åˆ†æ

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å€Ÿç”¨ç³»ç»Ÿ     | é˜²æ­¢æ•°æ®ç«äº‰ï¼Œä¿è¯å¹¶å‘å®‰å…¨ | å€Ÿç”¨è§„åˆ™å¯¹æ–°æ‰‹æœ‰ä¸€å®šé—¨æ§›   |

---

## 1. 3 ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ

### 1.3.1 ç”Ÿå‘½å‘¨æœŸå‚æ•°

**å®šä¹‰ 1.4ï¼ˆç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼‰**
$$\text{LifetimeParam}[\alpha] = \text{Generic}[\alpha]$$

**å®šä¹‰ 1.5ï¼ˆç”Ÿå‘½å‘¨æœŸçº¦æŸï¼‰**
$$\text{LifetimeBound}[\alpha, \beta] = \alpha \leq \beta$$

**å®šç† 1.2ï¼ˆç”Ÿå‘½å‘¨æœŸåŒ…å«ï¼‰**
$$\alpha \leq \beta \Rightarrow \text{Scope}[\alpha] \subseteq \text{Scope}[\beta]$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ã€æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€NLLï¼ˆNon-Lexical Lifetimesï¼‰ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// ç”Ÿå‘½å‘¨æœŸç¤ºä¾‹
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(&string1, &string2);
    }
    // println!("{}", result);  // ç¼–è¯‘é”™è¯¯ï¼šstring2 å·²è¶…å‡ºç”Ÿå‘½å‘¨æœŸ
}

// ç”Ÿå‘½å‘¨æœŸçº¦æŸç¤ºä¾‹
fn process_data<'a, 'b: 'a>(data: &'a str, context: &'b str) -> &'a str {
    data
}

// ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ
struct Parser<'a> {
    data: &'a str,
    position: usize,
}

impl<'a> Parser<'a> {
    fn new(data: &'a str) -> Self {
        Parser { data, position: 0 }
    }
    
    fn next_token(&mut self) -> Option<&'a str> {
        // è§£æé€»è¾‘
        None
    }
}
```

---

## 1. 4 äº¤å‰å¼•ç”¨ä¸æœ¬åœ°å¯¼èˆª

- [å˜é‡ç³»ç»Ÿç†è®º](../01_variable_system/index.md)
- [ç±»å‹ç³»ç»Ÿç†è®º](../02_type_system/01_type_theory_foundations.md)
- [å†…å­˜æ¨¡å‹ç†è®º](../03_memory_model/01_memory_model_theory.md)
- [å¹¶å‘æ¨¡å‹ç†è®º](../05_concurrency_model/01_concurrency_theory.md)

---

## 1. 5 è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®

- æœ¬æ–‡ä»¶å·²å®Œæˆé¦–æ‰¹ï¼ˆ1-250è¡Œï¼‰ä¸¥æ ¼ç¼–å·ã€ç»“æ„ä¼˜åŒ–ã€å¤šæ¨¡æ€è¡¨è¾¾ã€æ‰¹åˆ¤æ€§åˆ†æã€äº¤å‰å¼•ç”¨ä¸å­¦æœ¯è§„èŒƒåŒ–ã€‚
- å»ºè®®åç»­æŒç»­è¡¥å……æ‰€æœ‰æƒç³»ç»Ÿç†è®ºä¸å·¥ç¨‹æ¡ˆä¾‹ï¼Œä¿æŒä¸[æ ¸å¿ƒç†è®ºæ€»ç´¢å¼•](../00_core_theory_index.md)å’Œ[ç›®å½•ç´¢å¼•](index.md)åŒæ­¥ã€‚
- è¿›åº¦ï¼š`01_ownership_theory.md` é¦–æ‰¹å·²å®Œæˆï¼Œåç»­åˆ†æ‰¹æ¨è¿›ã€‚

---

> æœ¬æ–‡æ¡£æŒç»­æ›´æ–°ï¼Œæ¬¢è¿è¡¥å……æ‰€æœ‰æƒç³»ç»Ÿç†è®ºä¸å·¥ç¨‹æ¡ˆä¾‹ã€‚

## å‚è€ƒæ–‡çŒ®

1. Jung, R., et al. "RustBelt: Securing the foundations of the Rust programming language"
2. Jung, R., et al. "Stacked Borrows: An Aliasing Model for Rust"
3. "The Rust Programming Language" - Ownership Chapter
4. Pierce, B. C. "Types and Programming Languages" - Linear Types
5. "Rust Reference Manual" - Ownership and Borrowing

---

*æœ€åæ›´æ–°ï¼š2024å¹´12æœˆ19æ—¥*
*ç‰ˆæœ¬ï¼š1.0.0*
*çŠ¶æ€ï¼šæ‰€æœ‰æƒç³»ç»Ÿç†è®ºå½¢å¼åŒ–å®Œæˆ*

*ä¸‹ä¸€æ­¥ï¼šç»§ç»­å¤„ç† [ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿç†è®º](../02_lifetime_system/01_lifetime_theory.md)*
