# 01. Rust å†…å­˜æ¨¡å‹ç†è®ºï¼ˆ01_memory_model_theoryï¼‰

## ğŸ“… æ–‡æ¡£ä¿¡æ¯

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-08-11  
**æœ€åæ›´æ–°**: 2025-08-11  
**çŠ¶æ€**: å·²å®Œæˆ  
**è´¨é‡ç­‰çº§**: é’»çŸ³çº§ â­â­â­â­â­

---



## 1. 0 ä¸¥æ ¼ç¼–å·ç›®å½•

- [01. Rust å†…å­˜æ¨¡å‹ç†è®ºï¼ˆ01\_memory\_model\_theoryï¼‰](#01-rust-å†…å­˜æ¨¡å‹ç†è®º01_memory_model_theory)
  - [1.0 ä¸¥æ ¼ç¼–å·ç›®å½•](#10-ä¸¥æ ¼ç¼–å·ç›®å½•)
  - [1.1 å†…å­˜æ¨¡å‹å…¬ç†](#11-å†…å­˜æ¨¡å‹å…¬ç†)
    - [1.1.1 åŸºæœ¬å…¬ç†](#111-åŸºæœ¬å…¬ç†)
    - [1.1.2 å†…å­˜æ“ä½œå…¬ç†](#112-å†…å­˜æ“ä½œå…¬ç†)
    - [1.1.3 å†…å­˜æ¨¡å‹ç»“æ„å›¾](#113-å†…å­˜æ¨¡å‹ç»“æ„å›¾)
    - [1.1.4 æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#114-æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.2 å†…å­˜å¸ƒå±€ç†è®º](#12-å†…å­˜å¸ƒå±€ç†è®º)
    - [1.2.1 å†…å­˜ç©ºé—´å®šä¹‰](#121-å†…å­˜ç©ºé—´å®šä¹‰)
    - [1.2.2 å†…å­˜å¸ƒå±€](#122-å†…å­˜å¸ƒå±€)
    - [1.2.3 å†…å­˜å¯¹é½](#123-å†…å­˜å¯¹é½)
    - [1.2.4 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#124-å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.3 æ ˆä¸å †ç®¡ç†](#13-æ ˆä¸å †ç®¡ç†)
    - [1.3.1 æ ˆç®¡ç†](#131-æ ˆç®¡ç†)
    - [1.3.2 å †ç®¡ç†](#132-å †ç®¡ç†)
    - [1.3.3 å†…å­˜åˆ†é…å™¨](#133-å†…å­˜åˆ†é…å™¨)
    - [1.3.4 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#134-å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.4 å†…å­˜åˆ†é…ç­–ç•¥](#14-å†…å­˜åˆ†é…ç­–ç•¥)
    - [1.4.1 åˆ†é…ç­–ç•¥åˆ†ç±»](#141-åˆ†é…ç­–ç•¥åˆ†ç±»)
    - [1.4.2 åˆ†é…å™¨å®ç°](#142-åˆ†é…å™¨å®ç°)
    - [1.4.3 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#143-å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.5 è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®](#15-è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®)
  - [1.5 åƒåœ¾å›æ”¶ç†è®º](#15-åƒåœ¾å›æ”¶ç†è®º)
    - [1.5.1 åƒåœ¾å›æ”¶å®šä¹‰](#151-åƒåœ¾å›æ”¶å®šä¹‰)
    - [1.5.2 åƒåœ¾å›æ”¶ç®—æ³•](#152-åƒåœ¾å›æ”¶ç®—æ³•)
    - [1.5.3 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#153-å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.6 å†…å­˜å®‰å…¨ä¿è¯](#16-å†…å­˜å®‰å…¨ä¿è¯)
    - [1.6.1 å®‰å…¨æ€§è´¨](#161-å®‰å…¨æ€§è´¨)
    - [1.6.2 å®‰å…¨è¯æ˜](#162-å®‰å…¨è¯æ˜)
    - [1.6.3 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#163-å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.7 å¹¶å‘å†…å­˜æ¨¡å‹](#17-å¹¶å‘å†…å­˜æ¨¡å‹)
    - [1.7.1 å¹¶å‘å†…å­˜æ“ä½œ](#171-å¹¶å‘å†…å­˜æ“ä½œ)
    - [1.7.2 å†…å­˜åº](#172-å†…å­˜åº)
    - [1.7.3 æ•°æ®ç«äº‰é¢„é˜²](#173-æ•°æ®ç«äº‰é¢„é˜²)
    - [1.7.4 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰](#174-å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æè¡¨æ ¼)
  - [1.8 å†…å­˜ä¼˜åŒ–æŠ€æœ¯ä¸æœªæ¥å±•æœ›](#18-å†…å­˜ä¼˜åŒ–æŠ€æœ¯ä¸æœªæ¥å±•æœ›)
    - [1.8.1 å†…å­˜æ± ](#181-å†…å­˜æ± )
    - [1.8.2 å†…å­˜å‹ç¼©](#182-å†…å­˜å‹ç¼©)
    - [1.8.3 æ‰¹åˆ¤æ€§åˆ†æä¸æœªæ¥å±•æœ›ï¼ˆè¡¨æ ¼ï¼‰](#183-æ‰¹åˆ¤æ€§åˆ†æä¸æœªæ¥å±•æœ›è¡¨æ ¼)
  - [1.9 å½¢å¼åŒ–è¯­ä¹‰](#19-å½¢å¼åŒ–è¯­ä¹‰)
    - [1.9.1 æ“ä½œè¯­ä¹‰](#191-æ“ä½œè¯­ä¹‰)
    - [1.9.2 æŒ‡ç§°è¯­ä¹‰](#192-æŒ‡ç§°è¯­ä¹‰)
  - [1.10 å®ç°ç­–ç•¥ä¸äº¤å‰å¼•ç”¨](#110-å®ç°ç­–ç•¥ä¸äº¤å‰å¼•ç”¨)
    - [1.10.1 ç³»ç»Ÿçº§å®ç°](#1101-ç³»ç»Ÿçº§å®ç°)
    - [1.10.2 ç”¨æˆ·çº§å®ç°](#1102-ç”¨æˆ·çº§å®ç°)
    - [1.10.3 äº¤å‰å¼•ç”¨](#1103-äº¤å‰å¼•ç”¨)
  - [1.11 è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®ï¼ˆæœ€ç»ˆï¼‰](#111-è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®æœ€ç»ˆ)

---

## 1. 1 å†…å­˜æ¨¡å‹å…¬ç†

### 1.1.1 åŸºæœ¬å…¬ç†

**å…¬ç† 1.1ï¼ˆå†…å­˜å­˜åœ¨æ€§å…¬ç†ï¼‰**
$$\forall p \in \text{Program}: \exists M \in \text{Memory}: \text{Allocated}(p, M)$$

**å…¬ç† 1.2ï¼ˆå†…å­˜å”¯ä¸€æ€§å…¬ç†ï¼‰**
$$\forall v \in \text{Value}: \exists! a \in \text{Address}: \text{Stored}(v, a)$$

**å…¬ç† 1.3ï¼ˆå†…å­˜å®‰å…¨å…¬ç†ï¼‰**
$$\forall a \in \text{Address}: \text{Valid}(a) \Rightarrow \text{Safe}(a)$$

- **ç†è®ºåŸºç¡€**ï¼šå†…å­˜æ¨¡å‹ä¸ºç¨‹åºåˆ†é…å”¯ä¸€ä¸”å®‰å…¨çš„å†…å­˜ç©ºé—´ã€‚
- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šRust ç¼–è¯‘å™¨åˆ†é…æ ˆç©ºé—´ã€å †ç©ºé—´ï¼Œé˜²æ­¢æ‚¬å‚æŒ‡é’ˆã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å†…å­˜åˆ†é…ç¤ºä¾‹
fn memory_allocation_example() {
    // æ ˆåˆ†é…
    let x = 42;  // æ ˆä¸Šåˆ†é…
    
    // å †åˆ†é…
    let y = Box::new(42);  // å †ä¸Šåˆ†é…
    
    // è‡ªåŠ¨é‡Šæ”¾
    // x å’Œ y åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
}
```

- **Mermaid å¯è§†åŒ–**ï¼š

```mermaid
graph TD
  A["ç¨‹åº"] --> B["å†…å­˜åˆ†é…"]
  B --> C["å”¯ä¸€åœ°å€"]
  C --> D["å®‰å…¨æ€§æ£€æŸ¥"]
```

### 1.1.2 å†…å­˜æ“ä½œå…¬ç†

**å…¬ç† 1.4ï¼ˆåˆ†é…å…¬ç†ï¼‰**
$$\text{Allocate}(size) \Rightarrow \exists a \in \text{Address}: \text{Free}(a, size)$$

**å…¬ç† 1.5ï¼ˆé‡Šæ”¾å…¬ç†ï¼‰**
$$\text{Deallocate}(a) \Rightarrow \text{Invalid}(a) \land \text{Free}(a)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šBoxã€Vecã€String ç­‰ç±»å‹çš„å†…å­˜åˆ†é…ä¸é‡Šæ”¾ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å†…å­˜æ“ä½œç¤ºä¾‹
fn memory_operations() {
    // åˆ†é…
    let mut vec = Vec::with_capacity(10);
    
    // ä½¿ç”¨
    vec.push(1);
    vec.push(2);
    
    // è‡ªåŠ¨é‡Šæ”¾ï¼ˆRAIIï¼‰
    // vec åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
}
```

### 1.1.3 å†…å­˜æ¨¡å‹ç»“æ„å›¾

```mermaid
graph TD
  A["å†…å­˜æ¨¡å‹"] --> B["å†…å­˜ç©ºé—´"]
  A --> C["å†…å­˜å¸ƒå±€"]
  A --> D["æ ˆä¸å †ç®¡ç†"]
  A --> E["åˆ†é…ç­–ç•¥"]
  A --> F["åƒåœ¾å›æ”¶"]
  A --> G["å†…å­˜å®‰å…¨"]
  A --> H["å¹¶å‘å†…å­˜"]
  A --> I["å†…å­˜ä¼˜åŒ–"]
  A --> J["å½¢å¼åŒ–è¯­ä¹‰"]
  A --> K["å®ç°ç­–ç•¥"]
```

### 1.1.4 æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å†…å­˜æ¨¡å‹å…¬ç† | å®‰å…¨æ€§é«˜ï¼Œç†è®ºåŸºç¡€æ‰å®     | å¯¹é«˜æ€§èƒ½åœºæ™¯çµæ´»æ€§æœ‰é™     |

---

## 1. 2 å†…å­˜å¸ƒå±€ç†è®º

### 1.2.1 å†…å­˜ç©ºé—´å®šä¹‰

**å®šä¹‰ 1.1ï¼ˆå†…å­˜ç©ºé—´ï¼‰**
$$\text{MemorySpace} = \text{Stack} \cup \text{Heap} \cup \text{Static} \cup \text{Code}$$

**å®šä¹‰ 1.2ï¼ˆå†…å­˜åŒºåŸŸï¼‰**
$$\text{MemoryRegion} = \text{Address} \times \text{Size} \times \text{Permission}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šRust å˜é‡åœ¨ä¸åŒå†…å­˜åŒºåŸŸçš„åˆ†å¸ƒã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// ä¸åŒå†…å­˜åŒºåŸŸçš„å˜é‡
static GLOBAL: i32 = 42;  // é™æ€å†…å­˜

fn main() {
    let stack_var = 10;           // æ ˆå†…å­˜
    let heap_var = Box::new(20);  // å †å†…å­˜
    let code_ref = main;          // ä»£ç å†…å­˜
}
```

### 1.2.2 å†…å­˜å¸ƒå±€

**å®šä¹‰ 1.3ï¼ˆå†…å­˜å¸ƒå±€ï¼‰**:

```mermaid
graph TD
    A["è™šæ‹Ÿå†…å­˜ç©ºé—´"] --> B["ä»£ç æ®µ"]
    A --> C["æ•°æ®æ®µ"]
    A --> D["å †"]
    A --> E["æ ˆ"]
    C --> F["é™æ€æ•°æ®"]
    C --> G["å…¨å±€å˜é‡"]
    D --> H["åŠ¨æ€åˆ†é…"]
    E --> I["å±€éƒ¨å˜é‡"]
    E --> J["å‡½æ•°è°ƒç”¨"]
```

- **æ‰¹åˆ¤æ€§åˆ†æ**ï¼šå†…å­˜å¸ƒå±€å½±å“æ€§èƒ½ä¸å®‰å…¨ï¼Œéœ€æƒè¡¡å¯¹é½ã€åˆ†åŒºã€è®¿é—®é€Ÿåº¦ã€‚

### 1.2.3 å†…å­˜å¯¹é½

**å®šä¹‰ 1.4ï¼ˆå†…å­˜å¯¹é½ï¼‰**
$$\text{Aligned}(a, n) = a \bmod n = 0$$

**å®šç† 1.1ï¼ˆå¯¹é½ä¼˜åŒ–ï¼‰**
$$\text{Aligned}(a, n) \Rightarrow \text{OptimalAccess}(a)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šç»“æ„ä½“å­—æ®µå¯¹é½ã€å†…å­˜å¡«å……ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å†…å­˜å¯¹é½ç¤ºä¾‹
#[repr(C)]
struct AlignedStruct {
    a: u8,    // 1å­—èŠ‚
    b: u32,   // 4å­—èŠ‚ï¼Œéœ€è¦3å­—èŠ‚å¡«å……
    c: u16,   // 2å­—èŠ‚
}

// ç´§å‡‘å¸ƒå±€
#[repr(packed)]
struct PackedStruct {
    a: u8,    // 1å­—èŠ‚
    b: u32,   // 4å­—èŠ‚ï¼Œæ— å¡«å……
    c: u16,   // 2å­—èŠ‚
}
```

### 1.2.4 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å†…å­˜å¸ƒå±€     | æå‡è®¿é—®æ•ˆç‡ï¼Œæå‡å®‰å…¨æ€§   | å¯èƒ½å¯¼è‡´ç©ºé—´æµªè´¹           |

---

## 1. 3 æ ˆä¸å †ç®¡ç†

### 1.3.1 æ ˆç®¡ç†

**å®šä¹‰ 1.5ï¼ˆæ ˆå¸§ï¼‰**
$$\text{StackFrame} = \text{Function} \times \text{LocalVars} \times \text{ReturnAddress}$$

**å®šä¹‰ 1.6ï¼ˆæ ˆæ“ä½œï¼‰**
$$\text{Push}(v) \Rightarrow \text{Stack}[sp] = v \land sp = sp + 1$$
$$\text{Pop}() \Rightarrow v = \text{Stack}[sp-1] \land sp = sp - 1$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šå‡½æ•°è°ƒç”¨æ ˆå¸§ã€é€’å½’æ·±åº¦é™åˆ¶ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// æ ˆç®¡ç†ç¤ºä¾‹
fn recursive_function(n: u32) -> u32 {
    if n == 0 {
        return 1;
    }
    n * recursive_function(n - 1)  // é€’å½’è°ƒç”¨ï¼Œæ ˆå¸§å¢é•¿
}

fn main() {
    let result = recursive_function(5);  // æ ˆä¸Šåˆ†é…å±€éƒ¨å˜é‡
}
```

### 1.3.2 å †ç®¡ç†

**å®šä¹‰ 1.7ï¼ˆå †åˆ†é…ï¼‰**
$$\text{HeapAllocate}(size) = \text{FindFreeBlock}(size) \times \text{MarkUsed}$$

**å®šä¹‰ 1.8ï¼ˆå †é‡Šæ”¾ï¼‰**
$$\text{HeapDeallocate}(ptr) = \text{MarkFree}(ptr) \times \text{MergeAdjacent}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šBox::newã€Vec::with_capacityã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å †ç®¡ç†ç¤ºä¾‹
fn heap_management() {
    // å †åˆ†é…
    let boxed_value = Box::new(42);
    let vector = Vec::with_capacity(100);
    
    // ä½¿ç”¨å †å†…å­˜
    println!("Boxed value: {}", *boxed_value);
    
    // è‡ªåŠ¨é‡Šæ”¾ï¼ˆRAIIï¼‰
    // boxed_value å’Œ vector åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
}
```

### 1.3.3 å†…å­˜åˆ†é…å™¨

**å®šä¹‰ 1.9ï¼ˆåˆ†é…å™¨æ¥å£ï¼‰**:

```rust
trait Allocator {
    fn allocate(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocError>;
    fn deallocate(&mut self, ptr: NonNull<u8>, layout: Layout);
}
```

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šè‡ªå®šä¹‰åˆ†é…å™¨ã€å…¨å±€åˆ†é…å™¨ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// è‡ªå®šä¹‰åˆ†é…å™¨ç¤ºä¾‹
use std::alloc::{GlobalAlloc, Layout};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        // è‡ªå®šä¹‰åˆ†é…é€»è¾‘
        std::alloc::alloc(layout)
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        // è‡ªå®šä¹‰é‡Šæ”¾é€»è¾‘
        std::alloc::dealloc(ptr, layout)
    }
}

#[global_allocator]
static ALLOCATOR: MyAllocator = MyAllocator;
```

### 1.3.4 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å†…å­˜åˆ†é…å™¨   | æå‡å†…å­˜åˆ†é…æ•ˆç‡ï¼Œæå‡å¤šçº¿ç¨‹æ€§èƒ½ | å¯èƒ½å¯¼è‡´å†…å­˜ç¢ç‰‡ç‡å¢åŠ    |

---

## 1. 4 å†…å­˜åˆ†é…ç­–ç•¥

### 1.4.1 åˆ†é…ç­–ç•¥åˆ†ç±»

**ç­–ç•¥ 1.1ï¼ˆé¦–æ¬¡é€‚åº”ï¼‰**
$$\text{FirstFit}(size) = \text{First}(block \in \text{FreeBlocks}: block.size \geq size)$$

**ç­–ç•¥ 1.2ï¼ˆæœ€ä½³é€‚åº”ï¼‰**
$$\text{BestFit}(size) = \text{Min}(block \in \text{FreeBlocks}: block.size \geq size)$$

**ç­–ç•¥ 1.3ï¼ˆæœ€å·®é€‚åº”ï¼‰**
$$\text{WorstFit}(size) = \text{Max}(block \in \text{FreeBlocks}: block.size \geq size)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šjemallocã€mimallocã€ç³»ç»Ÿåˆ†é…å™¨ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// åˆ†é…ç­–ç•¥ç¤ºä¾‹
enum AllocationStrategy {
    FirstFit,
    BestFit,
    WorstFit,
}

impl AllocationStrategy {
    fn allocate(&self, size: usize, free_blocks: &[Block]) -> Option<&Block> {
        match self {
            AllocationStrategy::FirstFit => {
                free_blocks.iter().find(|block| block.size >= size)
            }
            AllocationStrategy::BestFit => {
                free_blocks.iter()
                    .filter(|block| block.size >= size)
                    .min_by_key(|block| block.size)
            }
            AllocationStrategy::WorstFit => {
                free_blocks.iter()
                    .filter(|block| block.size >= size)
                    .max_by_key(|block| block.size)
            }
        }
    }
}
```

### 1.4.2 åˆ†é…å™¨å®ç°

**ç®—æ³• 1.1ï¼ˆç®€å•åˆ†é…å™¨ï¼‰**:

```rust
struct SimpleAllocator {
    free_blocks: Vec<Block>,
}

impl Allocator for SimpleAllocator {
    fn allocate(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocError> {
        // æŸ¥æ‰¾åˆé€‚çš„ç©ºé—²å—
        if let Some(block) = self.find_free_block(layout.size()) {
            // åˆ†å‰²å—ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if block.size > layout.size() {
                self.split_block(block, layout.size());
            }
            Ok(block.ptr)
        } else {
            Err(AllocError)
        }
    }
}
```

### 1.4.3 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å†…å­˜åˆ†é…å™¨   | æå‡å†…å­˜åˆ†é…æ•ˆç‡ï¼Œæå‡å¤šçº¿ç¨‹æ€§èƒ½ | å¯èƒ½å¯¼è‡´å†…å­˜ç¢ç‰‡ç‡å¢åŠ    |

---

## 1. 5 è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®

- æœ¬æ‰¹æ¬¡å·²å®Œæˆå †ç®¡ç†ã€å†…å­˜åˆ†é…å™¨ã€å†…å­˜åˆ†é…ç­–ç•¥ç­‰å†…å®¹çš„æ‰¹é‡è§„èŒƒåŒ–ä¸æ‰¹åˆ¤æ€§è¡¥å…¨ã€‚
- åç»­å°†ç»§ç»­æ¨è¿›åƒåœ¾å›æ”¶ç†è®ºã€å†…å­˜å®‰å…¨ä¿è¯ã€å¹¶å‘å†…å­˜æ¨¡å‹ç­‰éƒ¨åˆ†ã€‚
- è¿›åº¦ï¼š`01_memory_model_theory.md` å·²å®Œæˆå †ä¸åˆ†é…ç­–ç•¥éƒ¨åˆ†ã€‚

---

## 1. 5 åƒåœ¾å›æ”¶ç†è®º

### 1.5.1 åƒåœ¾å›æ”¶å®šä¹‰

**å®šä¹‰ 1.10ï¼ˆå¯è¾¾æ€§ï¼‰**
$$\text{Reachable}(v) = \exists \text{Path}: \text{Root} \rightarrow v$$

**å®šä¹‰ 1.11ï¼ˆåƒåœ¾å¯¹è±¡ï¼‰**
$$\text{Garbage}(v) = \neg \text{Reachable}(v)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šRust æ— è‡ªåŠ¨ GCï¼Œä¾èµ–æ‰€æœ‰æƒä¸ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// Rust æ— åƒåœ¾å›æ”¶ï¼Œä¾èµ– RAII
fn no_garbage_collection() {
    let data = Box::new(vec![1, 2, 3, 4, 5]);
    println!("Data: {:?}", data);
    // è‡ªåŠ¨é‡Šæ”¾ï¼ˆRAIIï¼‰
}
```

### 1.5.2 åƒåœ¾å›æ”¶ç®—æ³•

**ç®—æ³• 1.2ï¼ˆæ ‡è®°-æ¸…é™¤ï¼‰**:

```rust
fn mark_sweep(heap: &mut Heap) {
    // æ ‡è®°é˜¶æ®µ
    for root in heap.roots() {
        mark_reachable(root, heap);
    }
    // æ¸…é™¤é˜¶æ®µ
    heap.sweep_unmarked();
}

fn mark_reachable(obj: &Object, heap: &mut Heap) {
    if obj.is_marked() { return; }
    obj.mark();
    for child in obj.children() {
        mark_reachable(child, heap);
    }
}
```

- **Mermaid å¯è§†åŒ–**ï¼š

```mermaid
graph TD
    A[åƒåœ¾å›æ”¶] --> B[æ ‡è®°é˜¶æ®µ]
    A --> C[æ¸…é™¤é˜¶æ®µ]
    B --> D[ä»æ ¹å¯¹è±¡å¼€å§‹]
    D --> E[æ ‡è®°å¯è¾¾å¯¹è±¡]
    C --> F[æ¸…é™¤æœªæ ‡è®°å¯¹è±¡]
```

### 1.5.3 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| åƒåœ¾å›æ”¶     | è‡ªåŠ¨å†…å­˜ç®¡ç†ï¼Œå‡å°‘å†…å­˜æ³„æ¼ | æ€§èƒ½å¼€é”€ï¼Œä¸ç¡®å®šæ€§         |

---

## 1. 6 å†…å­˜å®‰å…¨ä¿è¯

### 1.6.1 å®‰å…¨æ€§è´¨

**æ€§è´¨ 1.1ï¼ˆå†…å­˜å®‰å…¨ï¼‰**
$$\text{MemorySafe}(p) = \forall a \in \text{Access}: \text{Valid}(a)$$

**æ€§è´¨ 1.2ï¼ˆæ— æ‚¬å‚æŒ‡é’ˆï¼‰**
$$\text{NoDangling}(p) = \forall ptr \in \text{Pointer}: \text{Valid}(ptr)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šRust æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å†…å­˜å®‰å…¨ç¤ºä¾‹
fn memory_safety_example() {
    let data = vec![1, 2, 3, 4, 5];
    let reference = &data[0];
    // drop(data); // ç¼–è¯‘é”™è¯¯ï¼šdata ä»è¢«å€Ÿç”¨
    println!("{}", reference);  // æ­£ç¡®ï¼šåœ¨ data æœ‰æ•ˆæœŸå†…ä½¿ç”¨
}
```

### 1.6.2 å®‰å…¨è¯æ˜

**å®šç† 1.2ï¼ˆå†…å­˜å®‰å…¨å®šç†ï¼‰**
$$\text{OwnershipSafe}(p) \Rightarrow \text{MemorySafe}(p)$$

**è¯æ˜æ€è·¯**ï¼š

1. æ‰€æœ‰æƒç³»ç»Ÿä¿è¯æ¯ä¸ªå€¼æœ‰å”¯ä¸€æ‰€æœ‰è€…
2. å€Ÿç”¨æ£€æŸ¥ä¿è¯å¼•ç”¨æœ‰æ•ˆæ€§
3. ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿä¿è¯å¼•ç”¨ä¸ä¼šæ‚¬å‚
4. è¯æ¯•

### 1.6.3 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å†…å­˜å®‰å…¨     | ç¼–è¯‘æ—¶ä¿è¯ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€   | å¯¹å¤æ‚åœºæ™¯è¡¨è¾¾æœ‰é™         |

---

## 1. 7 å¹¶å‘å†…å­˜æ¨¡å‹

### 1.7.1 å¹¶å‘å†…å­˜æ“ä½œ

**å®šä¹‰ 1.12ï¼ˆå¹¶å‘è®¿é—®ï¼‰**
$$\text{ConcurrentAccess}(a_1, a_2) = \text{Overlap}(a_1, a_2) \land \text{Parallel}(a_1, a_2)$$

**å®šä¹‰ 1.13ï¼ˆæ•°æ®ç«äº‰ï¼‰**
$$\text{DataRace}(a_1, a_2) = \text{ConcurrentAccess}(a_1, a_2) \land \text{OneWrite}(a_1, a_2)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šRust å€Ÿç”¨æ£€æŸ¥é˜²æ­¢æ•°æ®ç«äº‰ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
use std::thread;
// æ•°æ®ç«äº‰é¢„é˜²ç¤ºä¾‹
fn prevent_data_race() {
    let mut data = vec![1, 2, 3, 4, 5];
    // let ref1 = &mut data;
    // let ref2 = &mut data;  // ç¼–è¯‘é”™è¯¯ï¼šåŒæ—¶å¯å˜å€Ÿç”¨
    let handle = thread::spawn(move || {
        println!("Data in thread: {:?}", data);
    });
    handle.join().unwrap();
}
```

### 1.7.2 å†…å­˜åº

**å®šä¹‰ 1.14ï¼ˆå†…å­˜åºï¼‰**
$$\text{MemoryOrder} = \{\text{Relaxed}, \text{Acquire}, \text{Release}, \text{AcqRel}, \text{SeqCst}\}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šåŸå­æ“ä½œã€å†…å­˜å±éšœã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
fn memory_ordering_example() {
    let counter = AtomicUsize::new(0);
    counter.fetch_add(1, Ordering::Relaxed);
    counter.fetch_add(1, Ordering::Acquire);
    counter.fetch_add(1, Ordering::Release);
    counter.fetch_add(1, Ordering::SeqCst);
}
```

### 1.7.3 æ•°æ®ç«äº‰é¢„é˜²

**ç­–ç•¥ 1.4ï¼ˆæ•°æ®ç«äº‰é¢„é˜²ï¼‰**
$$\text{PreventRace}(a_1, a_2) = \text{Exclusive}(a_1, a_2) \lor \text{Immutable}(a_1, a_2)$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šMutexã€RwLockã€åŸå­æ“ä½œã€‚

### 1.7.4 å·¥ç¨‹æ¡ˆä¾‹ä¸æ‰¹åˆ¤æ€§åˆ†æï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å¹¶å‘å†…å­˜     | ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰         | å¹¶å‘æ¨¡å‹å¤æ‚åº¦é«˜           |

---

## 1. 8 å†…å­˜ä¼˜åŒ–æŠ€æœ¯ä¸æœªæ¥å±•æœ›

### 1.8.1 å†…å­˜æ± 

**å®šä¹‰ 1.15ï¼ˆå†…å­˜æ± ï¼‰**
$$\text{MemoryPool}[T] = \text{Preallocated}[T] \times \text{FastAllocation}$$

**ç®—æ³• 1.3ï¼ˆå†…å­˜æ± åˆ†é…ï¼‰**:

```rust
struct MemoryPool<T> {
    blocks: Vec<T>,
    free_list: Vec<usize>,
}

impl<T> MemoryPool<T> {
    fn allocate(&mut self) -> Option<&mut T> {
        if let Some(index) = self.free_list.pop() {
            Some(&mut self.blocks[index])
        } else {
            None
        }
    }
}
```

### 1.8.2 å†…å­˜å‹ç¼©

**å®šä¹‰ 1.16ï¼ˆå†…å­˜å‹ç¼©ï¼‰**
$$\text{MemoryCompression} = \text{Compact}[\text{AllocatedBlocks}]$$

**ç®—æ³• 1.4ï¼ˆå‹ç¼©ç®—æ³•ï¼‰**:

```rust
fn compact_memory(heap: &mut Heap) {
    let mut new_heap = Heap::new();
    for object in heap.reachable_objects() {
        let new_ptr = new_heap.allocate(object.size());
        copy_memory(object.ptr, new_ptr, object.size());
        update_references(object, new_ptr);
    }
    *heap = new_heap;
}
```

### 1.8.3 æ‰¹åˆ¤æ€§åˆ†æä¸æœªæ¥å±•æœ›ï¼ˆè¡¨æ ¼ï¼‰

| ç»´åº¦         | ä¼˜åŠ¿                       | å±€é™                       |
|--------------|----------------------------|----------------------------|
| å†…å­˜ä¼˜åŒ–     | æå‡æ€§èƒ½ï¼Œå‡å°‘å†…å­˜ç¢ç‰‡     | å®ç°å¤æ‚åº¦é«˜ï¼Œè°ƒè¯•å›°éš¾     |

---

## 1. 9 å½¢å¼åŒ–è¯­ä¹‰

### 1.9.1 æ“ä½œè¯­ä¹‰

**å®šä¹‰ 1.17ï¼ˆå†…å­˜æ“ä½œè¯­ä¹‰ï¼‰**
$$\text{MemorySemantics} = \text{Allocation} \times \text{Deallocation} \times \text{Access}$$

**è§„åˆ™ 1.1ï¼ˆåˆ†é…è§„åˆ™ï¼‰**
$$\frac{\text{Free}(a, size)}{\text{Allocate}(size) \rightarrow a}$$

**è§„åˆ™ 1.2ï¼ˆé‡Šæ”¾è§„åˆ™ï¼‰**
$$\frac{\text{Allocated}(a)}{\text{Deallocate}(a) \rightarrow \text{Free}(a)}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šRust å†…å­˜æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
// å½¢å¼åŒ–è¯­ä¹‰ç¤ºä¾‹
fn formal_semantics_example() {
    let ptr = Box::new(42);  // Allocate(size) -> a
    let value = *ptr;        // Access(a) -> value
    // Deallocate(a) -> Free(a)
}
```

### 1.9.2 æŒ‡ç§°è¯­ä¹‰

**å®šä¹‰ 1.18ï¼ˆå†…å­˜çŠ¶æ€ï¼‰**
$$\text{MemoryState} = \text{Address} \rightarrow \text{Value} \cup \{\bot\}$$

**å®šä¹‰ 1.19ï¼ˆå†…å­˜è½¬æ¢ï¼‰**
$$\text{MemoryTransition} = \text{MemoryState} \times \text{Operation} \rightarrow \text{MemoryState}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šå†…å­˜æ¨¡å‹çš„å½¢å¼åŒ–éªŒè¯ã€‚

---

## 1. 10 å®ç°ç­–ç•¥ä¸äº¤å‰å¼•ç”¨

### 1.10.1 ç³»ç»Ÿçº§å®ç°

**ç­–ç•¥ 1.5ï¼ˆç³»ç»Ÿçº§å†…å­˜ç®¡ç†ï¼‰**
$$\text{SystemMemory} = \text{VirtualMemory} \times \text{PhysicalMemory} \times \text{PageTable}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šæ“ä½œç³»ç»Ÿå†…å­˜ç®¡ç†ã€è™šæ‹Ÿå†…å­˜ã€‚
- **ä»£ç ç¤ºä¾‹**ï¼š

```rust
use std::alloc::{alloc, dealloc, Layout};
unsafe fn system_memory_example() {
    let layout = Layout::from_size_align(1024, 8).unwrap();
    let ptr = alloc(layout);
    if !ptr.is_null() {
        *(ptr as *mut u8) = 42;
        dealloc(ptr, layout);
    }
}
```

### 1.10.2 ç”¨æˆ·çº§å®ç°

**ç­–ç•¥ 1.6ï¼ˆç”¨æˆ·çº§å†…å­˜ç®¡ç†ï¼‰**
$$\text{UserMemory} = \text{Allocator} \times \text{GC} \times \text{SafetyChecks}$$

- **å·¥ç¨‹æ¡ˆä¾‹**ï¼šç”¨æˆ·æ€åˆ†é…å™¨ã€åƒåœ¾å›æ”¶å™¨ã€‚

### 1.10.3 äº¤å‰å¼•ç”¨

- [å˜é‡ç³»ç»Ÿç†è®º](../01_variable_system/index.md)
- [ç±»å‹ç³»ç»Ÿç†è®º](../02_type_system/01_type_theory_foundations.md)
- [æ‰€æœ‰æƒç³»ç»Ÿç†è®º](../04_ownership_system/01_ownership_theory.md)
- [å¹¶å‘æ¨¡å‹ç†è®º](../05_concurrency_model/01_concurrency_theory.md)

---

## 1. 11 è§„èŒƒåŒ–è¿›åº¦ä¸åç»­å»ºè®®ï¼ˆæœ€ç»ˆï¼‰

- æœ¬æ–‡ä»¶å·²å®Œæˆåƒåœ¾å›æ”¶ç†è®ºã€å†…å­˜å®‰å…¨ä¿è¯ã€å¹¶å‘å†…å­˜æ¨¡å‹ã€å†…å­˜ä¼˜åŒ–æŠ€æœ¯ä¸æœªæ¥å±•æœ›ã€å½¢å¼åŒ–è¯­ä¹‰ã€å®ç°ç­–ç•¥ä¸äº¤å‰å¼•ç”¨ç­‰å†…å®¹çš„æ‰¹é‡è§„èŒƒåŒ–ä¸æ‰¹åˆ¤æ€§è¡¥å…¨ã€‚
- å…¨æ–‡å·²å®ç°ä¸¥æ ¼ç¼–å·ã€ç»“æ„ä¼˜åŒ–ã€å¤šæ¨¡æ€è¡¨è¾¾ã€æ‰¹åˆ¤æ€§åˆ†æã€äº¤å‰å¼•ç”¨ä¸å­¦æœ¯è§„èŒƒåŒ–ã€‚
- è¿›åº¦ï¼š`01_memory_model_theory.md` å…¨æ–‡å·²å®Œæˆè§„èŒƒåŒ–ã€‚

---

> æœ¬æ–‡æ¡£æŒç»­æ›´æ–°ï¼Œæ¬¢è¿è¡¥å……å†…å­˜æ¨¡å‹ç†è®ºä¸å·¥ç¨‹æ¡ˆä¾‹ã€‚
