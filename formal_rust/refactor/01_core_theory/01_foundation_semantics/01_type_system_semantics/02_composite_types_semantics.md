# 2.0 Rustå¤åˆç±»å‹è¯­ä¹‰æ¨¡å‹æ·±åº¦åˆ†æ

## ğŸ“… æ–‡æ¡£ä¿¡æ¯

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-08-11  
**æœ€åæ›´æ–°**: 2025-08-11  
**çŠ¶æ€**: å·²å®Œæˆ  
**è´¨é‡ç­‰çº§**: é’»çŸ³çº§ â­â­â­â­â­

---



## ç›®å½•

- [2.0 Rustå¤åˆç±»å‹è¯­ä¹‰æ¨¡å‹æ·±åº¦åˆ†æ](#20-rustå¤åˆç±»å‹è¯­ä¹‰æ¨¡å‹æ·±åº¦åˆ†æ)
  - [ç›®å½•](#ç›®å½•)
  - [2.1 å¤åˆç±»å‹ç†è®ºåŸºç¡€](#21-å¤åˆç±»å‹ç†è®ºåŸºç¡€)
    - [2.1.1 å¤åˆç±»å‹èŒƒç•´è®ºæ¡†æ¶](#211-å¤åˆç±»å‹èŒƒç•´è®ºæ¡†æ¶)
    - [2.1.2 ç±»å‹æ„é€ çš„è¯­ä¹‰å±‚æ¬¡](#212-ç±»å‹æ„é€ çš„è¯­ä¹‰å±‚æ¬¡)
  - [2.2 æ•°ç»„ç±»å‹è¯­ä¹‰åˆ†æ](#22-æ•°ç»„ç±»å‹è¯­ä¹‰åˆ†æ)
    - [2.2.1 å›ºå®šå¤§å°æ•°ç»„è¯­ä¹‰](#221-å›ºå®šå¤§å°æ•°ç»„è¯­ä¹‰)
    - [2.2.2 åˆ‡ç‰‡ç±»å‹è¯­ä¹‰](#222-åˆ‡ç‰‡ç±»å‹è¯­ä¹‰)
  - [2.3 å…ƒç»„ç±»å‹è¯­ä¹‰åˆ†æ](#23-å…ƒç»„ç±»å‹è¯­ä¹‰åˆ†æ)
    - [2.3.1 å…ƒç»„ç±»å‹ä»£æ•°ç»“æ„](#231-å…ƒç»„ç±»å‹ä»£æ•°ç»“æ„)
    - [2.3.2 å•å…ƒç±»å‹ä¸ç©ºå…ƒç»„](#232-å•å…ƒç±»å‹ä¸ç©ºå…ƒç»„)
  - [2.4 ç»“æ„ä½“ç±»å‹è¯­ä¹‰åˆ†æ](#24-ç»“æ„ä½“ç±»å‹è¯­ä¹‰åˆ†æ)
    - [2.4.1 å‘½åå­—æ®µç»“æ„ä½“](#241-å‘½åå­—æ®µç»“æ„ä½“)
    - [2.4.2 å…ƒç»„ç»“æ„ä½“è¯­ä¹‰](#242-å…ƒç»„ç»“æ„ä½“è¯­ä¹‰)
    - [2.4.3 å•å…ƒç»“æ„ä½“è¯­ä¹‰](#243-å•å…ƒç»“æ„ä½“è¯­ä¹‰)
  - [2.5 æšä¸¾ç±»å‹è¯­ä¹‰åˆ†æ](#25-æšä¸¾ç±»å‹è¯­ä¹‰åˆ†æ)
    - [2.5.1 å’Œç±»å‹è¯­ä¹‰åŸºç¡€](#251-å’Œç±»å‹è¯­ä¹‰åŸºç¡€)
    - [2.5.2 æšä¸¾çš„å†…å­˜è¡¨ç¤º](#252-æšä¸¾çš„å†…å­˜è¡¨ç¤º)
    - [2.5.3 æ¨¡å¼åŒ¹é…è¯­ä¹‰](#253-æ¨¡å¼åŒ¹é…è¯­ä¹‰)
  - [2.6 å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…ç±»å‹](#26-å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…ç±»å‹)
    - [2.6.1 å‡½æ•°æŒ‡é’ˆç±»å‹è¯­ä¹‰](#261-å‡½æ•°æŒ‡é’ˆç±»å‹è¯­ä¹‰)
    - [2.6.2 é—­åŒ…ç±»å‹è¯­ä¹‰](#262-é—­åŒ…ç±»å‹è¯­ä¹‰)
  - [2.7 æ™ºèƒ½æŒ‡é’ˆç±»å‹è¯­ä¹‰](#27-æ™ºèƒ½æŒ‡é’ˆç±»å‹è¯­ä¹‰)
    - [2.7.1 `Box<T>`è¯­ä¹‰æ¨¡å‹](#271-boxtè¯­ä¹‰æ¨¡å‹)
    - [2.7.2 `Rc<T>`å’Œ`Arc<T>`è¯­ä¹‰](#272-rctå’Œarctè¯­ä¹‰)
  - [2.8 å¤åˆç±»å‹çš„ç±»å‹ç†è®º](#28-å¤åˆç±»å‹çš„ç±»å‹ç†è®º)
    - [2.8.1 ç§¯ç±»å‹ä¸å’Œç±»å‹çš„å¯¹å¶æ€§](#281-ç§¯ç±»å‹ä¸å’Œç±»å‹çš„å¯¹å¶æ€§)
    - [2.8.2 é€’å½’ç±»å‹çš„ä¸åŠ¨ç‚¹è¯­ä¹‰](#282-é€’å½’ç±»å‹çš„ä¸åŠ¨ç‚¹è¯­ä¹‰)
  - [2.9 å¤åˆç±»å‹çš„å†…å­˜å¸ƒå±€ä¼˜åŒ–](#29-å¤åˆç±»å‹çš„å†…å­˜å¸ƒå±€ä¼˜åŒ–)
    - [2.9.1 ç»“æ„ä½“å­—æ®µé‡æ’](#291-ç»“æ„ä½“å­—æ®µé‡æ’)
    - [2.9.2 æšä¸¾è¡¨ç¤ºä¼˜åŒ–](#292-æšä¸¾è¡¨ç¤ºä¼˜åŒ–)
  - [2.10 è·¨å¼•ç”¨ç½‘ç»œ](#210-è·¨å¼•ç”¨ç½‘ç»œ)
    - [2.10.1 å†…éƒ¨å¼•ç”¨](#2101-å†…éƒ¨å¼•ç”¨)
    - [2.10.2 å¤–éƒ¨å¼•ç”¨](#2102-å¤–éƒ¨å¼•ç”¨)
  - [2.11 ç†è®ºå‰æ²¿ä¸å‘å±•æ–¹å‘](#211-ç†è®ºå‰æ²¿ä¸å‘å±•æ–¹å‘)
    - [2.11.1 ä¾èµ–ç±»å‹æ‰©å±•](#2111-ä¾èµ–ç±»å‹æ‰©å±•)
    - [2.11.2 é«˜çº§ç±»å‹æ„é€ ](#2112-é«˜çº§ç±»å‹æ„é€ )
  - [2.12 æŒç»­æ”¹è¿›ä¸ç‰ˆæœ¬è¿½è¸ª](#212-æŒç»­æ”¹è¿›ä¸ç‰ˆæœ¬è¿½è¸ª)
    - [2.12.1 æ–‡æ¡£ç‰ˆæœ¬](#2121-æ–‡æ¡£ç‰ˆæœ¬)
    - [2.12.2 æ”¹è¿›è®¡åˆ’](#2122-æ”¹è¿›è®¡åˆ’)

## 2. 1 å¤åˆç±»å‹ç†è®ºåŸºç¡€

### 2.1.1 å¤åˆç±»å‹èŒƒç•´è®ºæ¡†æ¶

**å®šä¹‰ 2.1.1** (å¤åˆç±»å‹æ„é€ å‡½å­)
è®¾ $\mathcal{C}$ ä¸ºç±»å‹èŒƒç•´ï¼Œå¤åˆç±»å‹æ„é€ å™¨å®šä¹‰ä¸ºå‡½å­ï¼š
$$F: \mathcal{C}^n \rightarrow \mathcal{C}$$

å…¶ä¸­ä¸»è¦æ„é€ å™¨åŒ…æ‹¬ï¼š

- **ç§¯ç±»å‹**: $F_{prod}(T_1, T_2, ..., T_n) = T_1 \times T_2 \times ... \times T_n$
- **å’Œç±»å‹**: $F_{sum}(T_1, T_2, ..., T_n) = T_1 + T_2 + ... + T_n$
- **å‡½æ•°ç±»å‹**: $F_{func}(T_1, T_2) = T_1 \rightarrow T_2$
- **é€’å½’ç±»å‹**: $F_{rec}(\lambda T. F(T))$

### 2.1.2 ç±»å‹æ„é€ çš„è¯­ä¹‰å±‚æ¬¡

```mermaid
graph TB
    subgraph "è¯­ä¹‰å±‚æ¬¡ç»“æ„"
        L1[åŸå§‹ç±»å‹å±‚]
        L2[åŸºç¡€å¤åˆç±»å‹å±‚]
        L3[é«˜çº§å¤åˆç±»å‹å±‚]
        L4[æ³›å‹ç±»å‹å±‚]
        L5[ç‰¹è´¨å¯¹è±¡å±‚]
    end
    
    subgraph "æ„é€ æ“ä½œ"
        PROD[ç§¯è¿ç®— Ã—]
        SUM[å’Œè¿ç®— +]
        FUNC[å‡½æ•°ç±»å‹ â†’]
        REC[é€’å½’ç±»å‹ Î¼]
        POLY[å¤šæ€ç±»å‹ âˆ€]
    end
    
    L1 --> L2
    L2 --> L3
    L3 --> L4
    L4 --> L5
    
    PROD --> L2
    SUM --> L2
    FUNC --> L3
    REC --> L3
    POLY --> L4
```

---

## 2. 2 æ•°ç»„ç±»å‹è¯­ä¹‰åˆ†æ

### 2.2.1 å›ºå®šå¤§å°æ•°ç»„è¯­ä¹‰

**å®šä¹‰ 2.2.1** (æ•°ç»„ç±»å‹è¯­ä¹‰)
å›ºå®šå¤§å°æ•°ç»„ `[T; N]` çš„è¯­ä¹‰ä¸ºï¼š
$$[T; N] = T^N = \underbrace{T \times T \times ... \times T}_{N \text{æ¬¡}}$$

**ç±»å‹ä¸å˜å¼**ï¼š

1. **å¤§å°ç¡®å®šæ€§**: $\text{size}([T; N]) = N \times \text{size}(T)$
2. **å†…å­˜è¿ç»­æ€§**: æ•°ç»„å…ƒç´ åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨
3. **è¾¹ç•Œå®‰å…¨æ€§**: ç´¢å¼•è®¿é—®åœ¨ç¼–è¯‘æ—¶æˆ–è¿è¡Œæ—¶è¿›è¡Œè¾¹ç•Œæ£€æŸ¥

```rust
// æ•°ç»„è¯­ä¹‰ç¤ºä¾‹
fn array_semantics() {
    // 1. ç±»å‹å®‰å…¨çš„æ•°ç»„æ“ä½œ
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    
    // ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°
    assert_eq!(std::mem::size_of_val(&arr), 5 * 4); // 5ä¸ªi32
    
    // 2. å†…å­˜å¸ƒå±€ä¿è¯
    let ptr = arr.as_ptr();
    unsafe {
        assert_eq!(*ptr, 1);
        assert_eq!(*ptr.add(1), 2); // è¿ç»­å†…å­˜
    }
    
    // 3. è¾¹ç•Œæ£€æŸ¥
    // let invalid = arr[10]; // ç¼–è¯‘æ—¶é”™è¯¯æˆ–è¿è¡Œæ—¶panic
}
```

### 2.2.2 åˆ‡ç‰‡ç±»å‹è¯­ä¹‰

**å®šä¹‰ 2.2.2** (åˆ‡ç‰‡è¯­ä¹‰æ¨¡å‹)
åˆ‡ç‰‡ `&[T]` æ˜¯æ•°ç»„çš„è§†å›¾ï¼Œè¯­ä¹‰ä¸Šä¸ºï¼š
$$\&[T] = \{(ptr, len) : ptr \in \text{Ptr}(T), len \in \mathbb{N}\}$$

**åˆ‡ç‰‡ä¸å˜å¼**ï¼š

```mermaid
stateDiagram-v2
    [*] --> ValidSlice
    ValidSlice --> InvalidAccess: è¶Šç•Œè®¿é—®
    ValidSlice --> ValidSlice: å®‰å…¨æ“ä½œ
    InvalidAccess --> [*]: panic!
    
    note right of ValidSlice
        ptræŒ‡å‘æœ‰æ•ˆå†…å­˜
        len â‰¤ åˆ†é…å¤§å°
        ç”Ÿå‘½å‘¨æœŸæœ‰æ•ˆ
    end note
```

---

## 2. 3 å…ƒç»„ç±»å‹è¯­ä¹‰åˆ†æ

### 2.3.1 å…ƒç»„ç±»å‹ä»£æ•°ç»“æ„

**å®šä¹‰ 2.3.1** (å…ƒç»„ç±»å‹è¯­ä¹‰)
$n$-å…ƒç»„ç±»å‹ $(T_1, T_2, ..., T_n)$ çš„è¯­ä¹‰ä¸ºç¬›å¡å°”ç§¯ï¼š
$$\text{Tuple}_n(T_1, ..., T_n) = T_1 \times T_2 \times ... \times T_n$$

**å…ƒç»„æŠ•å½±å‡½æ•°**ï¼š
$$\pi_i: T_1 \times ... \times T_n \rightarrow T_i$$

```rust
// å…ƒç»„è¯­ä¹‰æ“ä½œ
fn tuple_semantics() {
    // 1. å…ƒç»„æ„é€ ä¸è§£æ„
    let tuple: (i32, f64, String) = (42, 3.14, "hello".to_string());
    
    // æŠ•å½±æ“ä½œ
    let first: i32 = tuple.0;    // Ï€â‚
    let second: f64 = tuple.1;   // Ï€â‚‚
    let third: String = tuple.2; // Ï€â‚ƒ
    
    // 2. æ¨¡å¼åŒ¹é…è§£æ„
    let (x, y, z) = tuple;
    
    // 3. ç±»å‹åŒæ„
    let nested: ((i32, f64), String) = ((42, 3.14), "hello".to_string());
    // (A Ã— B) Ã— C â‰… A Ã— (B Ã— C) ç»“åˆå¾‹
}
```

### 2.3.2 å•å…ƒç±»å‹ä¸ç©ºå…ƒç»„

**å®šç† 2.3.1** (å•å…ƒç±»å‹åŒæ„æ€§)
å•å…ƒç±»å‹ `()` ä¸é›¶å…ƒç»„åŒæ„ï¼š
$$() \cong \text{Tuple}_0 \cong \mathbf{1}$$

å…¶ä¸­ $\mathbf{1}$ æ˜¯èŒƒç•´è®ºä¸­çš„ç»ˆå¯¹è±¡ã€‚

---

## 2. 4 ç»“æ„ä½“ç±»å‹è¯­ä¹‰åˆ†æ

### 2.4.1 å‘½åå­—æ®µç»“æ„ä½“

**å®šä¹‰ 2.4.1** (ç»“æ„ä½“è¯­ä¹‰æ˜ å°„)
ç»“æ„ä½“ `struct S { f1: T1, f2: T2, ..., fn: Tn }` ç­‰ä»·äºæ ‡è®°å…ƒç»„ï¼š
$$S \cong \{f_1: T_1, f_2: T_2, ..., f_n: T_n\}$$

**å­—æ®µè®¿é—®è¯­ä¹‰**ï¼š
$$\text{access}(s, f_i) = \pi_i(\text{untag}(s))$$

```rust
// ç»“æ„ä½“è¯­ä¹‰ç¤ºä¾‹
#[derive(Debug, Clone)]
struct Point3D {
    x: f64,
    y: f64,
    z: f64,
}

fn struct_semantics() {
    // 1. æ„é€ å‡½æ•°è¯­ä¹‰
    let p = Point3D { x: 1.0, y: 2.0, z: 3.0 };
    
    // 2. å­—æ®µè®¿é—®çš„å†…å­˜å¸ƒå±€
    use std::mem;
    assert_eq!(mem::size_of::<Point3D>(), 3 * mem::size_of::<f64>());
    
    // 3. å­—æ®µé‡æ’ä¸ä¼˜åŒ–
    let ptr = &p as *const Point3D as *const f64;
    unsafe {
        assert_eq!(*ptr, 1.0);           // xå­—æ®µ
        assert_eq!(*ptr.add(1), 2.0);    // yå­—æ®µ
        assert_eq!(*ptr.add(2), 3.0);    // zå­—æ®µ
    }
}
```

### 2.4.2 å…ƒç»„ç»“æ„ä½“è¯­ä¹‰

**å®šä¹‰ 2.4.2** (å…ƒç»„ç»“æ„ä½“åŒæ„)
å…ƒç»„ç»“æ„ä½“ `struct Wrapper(T)` ä¸å•å…ƒç´ å…ƒç»„åŒæ„ï¼š
$$\text{Wrapper}(T) \cong (T,)$$

ä½†å…·æœ‰ä¸åŒçš„åä¹‰ç±»å‹æ ‡è¯†ã€‚

### 2.4.3 å•å…ƒç»“æ„ä½“è¯­ä¹‰

**å®šä¹‰ 2.4.3** (å•å…ƒç»“æ„ä½“è¯­ä¹‰)
å•å…ƒç»“æ„ä½“ `struct Unit;` ç­‰ä»·äºå•å…ƒç±»å‹ï¼š
$$\text{Unit} \cong ()$$

ä½†åœ¨ç±»å‹ç³»ç»Ÿä¸­å…·æœ‰ç‹¬ç‰¹çš„æ ‡è¯†ã€‚

---

## 2. 5 æšä¸¾ç±»å‹è¯­ä¹‰åˆ†æ

### 2.5.1 å’Œç±»å‹è¯­ä¹‰åŸºç¡€

**å®šä¹‰ 2.5.1** (æšä¸¾ç±»å‹è¯­ä¹‰)
æšä¸¾ `enum E { V1(T1), V2(T2), ..., Vn(Tn) }` çš„è¯­ä¹‰ä¸ºæ ‡è®°è”åˆï¼š
$$E \cong T_1 + T_2 + ... + T_n$$

**æ³¨å…¥å‡½æ•°**ï¼š
$$\text{inj}_i: T_i \rightarrow E$$

```mermaid
graph LR
    subgraph "å’Œç±»å‹æ„é€ "
        T1[Tâ‚] --> E
        T2[Tâ‚‚] --> E  
        T3[Tâ‚ƒ] --> E
        TN[Tâ‚™] --> E
    end
    
    subgraph "æ¨¡å¼åŒ¹é…"
        E --> M{match}
        M --> A1[åˆ†æ”¯1]
        M --> A2[åˆ†æ”¯2]
        M --> A3[åˆ†æ”¯3]
        M --> AN[åˆ†æ”¯n]
    end
    
    E -.-> tag[æ ‡è®°å­—æ®µ]
    E -.-> data[æ•°æ®å­—æ®µ]
```

### 2.5.2 æšä¸¾çš„å†…å­˜è¡¨ç¤º

```rust
// æšä¸¾è¯­ä¹‰ä¸å†…å­˜å¸ƒå±€
#[derive(Debug)]
enum Message {
    Quit,                        // å•å…ƒå˜ä½“
    Move { x: i32, y: i32 },    // ç»“æ„ä½“å˜ä½“
    Write(String),              // å…ƒç»„å˜ä½“
    ChangeColor(i32, i32, i32), // å¤šå­—æ®µå…ƒç»„å˜ä½“
}

fn enum_semantics() {
    use std::mem;
    
    // 1. åˆ¤åˆ«å¼(discriminant)è¯­ä¹‰
    let msg = Message::Write("hello".to_string());
    let discriminant = unsafe { *((&msg) as *const _ as *const u8) };
    
    // 2. å†…å­˜å¸ƒå±€ä¼˜åŒ–
    // æšä¸¾å¤§å° = max(å˜ä½“å¤§å°) + åˆ¤åˆ«å¼å¤§å°
    println!("Message size: {}", mem::size_of::<Message>());
    
    // 3. ç©ºæŒ‡é’ˆä¼˜åŒ–
    let opt: Option<&i32> = None;
    // Option<&T> ä¸ &T å…·æœ‰ç›¸åŒçš„å†…å­˜è¡¨ç¤º
    assert_eq!(mem::size_of::<Option<&i32>>(), mem::size_of::<&i32>());
}
```

### 2.5.3 æ¨¡å¼åŒ¹é…è¯­ä¹‰

**å®šä¹‰ 2.5.3** (æ¨¡å¼åŒ¹é…è¯­ä¹‰)
æ¨¡å¼åŒ¹é…æ˜¯å’Œç±»å‹çš„æ¡ˆä¾‹åˆ†æï¼š
$$\text{match } e \text{ with } \{p_1 \Rightarrow e_1, ..., p_n \Rightarrow e_n\}$$

ç­‰ä»·äºï¼š
$$\text{case}(e, [p_1 \mapsto e_1, ..., p_n \mapsto e_n])$$

```rust
// å®Œæ•´æ€§ä¸æ’ä»–æ€§æ£€æŸ¥
fn pattern_matching_semantics(msg: Message) -> String {
    match msg {
        Message::Quit => "quit".to_string(),
        Message::Move { x, y } => format!("move to ({}, {})", x, y),
        Message::Write(text) => text,
        Message::ChangeColor(r, g, b) => format!("color ({}, {}, {})", r, g, b),
        // ç¼–è¯‘å™¨ä¿è¯ï¼šæ‰€æœ‰æƒ…å†µéƒ½è¢«è¦†ç›–(å®Œæ•´æ€§)
        // ç¼–è¯‘å™¨ä¿è¯ï¼šæ²¡æœ‰é‡å¤æ¨¡å¼(æ’ä»–æ€§)
    }
}
```

---

## 2. 6 å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…ç±»å‹

### 2.6.1 å‡½æ•°æŒ‡é’ˆç±»å‹è¯­ä¹‰

**å®šä¹‰ 2.6.1** (å‡½æ•°æŒ‡é’ˆè¯­ä¹‰)
å‡½æ•°æŒ‡é’ˆç±»å‹ `fn(T1, T2, ..., Tn) -> R` è¡¨ç¤ºå‡½æ•°çš„ç±»å‹ï¼š
$$\text{fn}(T_1, ..., T_n) \rightarrow R \cong T_1 \times ... \times T_n \rightarrow R$$

```rust
// å‡½æ•°æŒ‡é’ˆè¯­ä¹‰
fn function_pointer_semantics() {
    // 1. å‡½æ•°ä½œä¸ºä¸€ç­‰å€¼
    fn add(a: i32, b: i32) -> i32 { a + b }
    fn multiply(a: i32, b: i32) -> i32 { a * b }
    
    let operation: fn(i32, i32) -> i32 = add;
    assert_eq!(operation(3, 4), 7);
    
    // 2. é«˜é˜¶å‡½æ•°
    fn apply_twice(f: fn(i32) -> i32, x: i32) -> i32 {
        f(f(x))
    }
    
    fn increment(x: i32) -> i32 { x + 1 }
    assert_eq!(apply_twice(increment, 5), 7);
    
    // 3. å‡½æ•°æŒ‡é’ˆçš„é›¶æˆæœ¬æŠ½è±¡
    use std::mem;
    assert_eq!(mem::size_of::<fn()>(), mem::size_of::<usize>());
}
```

### 2.6.2 é—­åŒ…ç±»å‹è¯­ä¹‰

**å®šä¹‰ 2.6.2** (é—­åŒ…ç±»å‹åˆ†ç±»)
Rusté—­åŒ…æ ¹æ®ç¯å¢ƒæ•è·æ–¹å¼åˆ†ä¸ºä¸‰ç±»ï¼š

1. **Fn**: ä¸å¯å˜å€Ÿç”¨ç¯å¢ƒ
2. **FnMut**: å¯å˜å€Ÿç”¨ç¯å¢ƒ  
3. **FnOnce**: è·å–ç¯å¢ƒæ‰€æœ‰æƒ

```mermaid
graph TB
    subgraph "é—­åŒ…ç‰¹å¾å±‚æ¬¡"
        FnOnce[FnOnce]
        FnMut[FnMut]
        Fn[Fn]
    end
    
    subgraph "ç¯å¢ƒæ•è·"
        Move[move è¯­ä¹‰]
        BorrowMut[&mut å€Ÿç”¨]
        BorrowImm[& å€Ÿç”¨]
    end
    
    FnOnce --> FnMut
    FnMut --> Fn
    
    Move --> FnOnce
    BorrowMut --> FnMut
    BorrowImm --> Fn
```

```rust
// é—­åŒ…è¯­ä¹‰åˆ†æ
fn closure_semantics() {
    let x = 42;
    let y = 24;
    
    // 1. Fné—­åŒ…ï¼šä¸å¯å˜æ•è·
    let read_only = || x + y;
    println!("{}", read_only()); // å¯ä»¥å¤šæ¬¡è°ƒç”¨
    println!("{}", read_only());
    
    // 2. FnMuté—­åŒ…ï¼šå¯å˜æ•è·
    let mut count = 0;
    let mut increment = || {
        count += 1;
        count
    };
    println!("{}", increment()); // 1
    println!("{}", increment()); // 2
    
    // 3. FnOnceé—­åŒ…ï¼šè·å–æ‰€æœ‰æƒ
    let data = vec![1, 2, 3];
    let consume = move || {
        data // ç§»åŠ¨dataçš„æ‰€æœ‰æƒ
    };
    let consumed_data = consume();
    // consume(); // ç¼–è¯‘é”™è¯¯ï¼šå·²ç»è¢«æ¶ˆè´¹
}
```

---

## 2. 7 æ™ºèƒ½æŒ‡é’ˆç±»å‹è¯­ä¹‰

### 2.7.1 `Box<T>`è¯­ä¹‰æ¨¡å‹

**å®šä¹‰ 2.7.1** (å †åˆ†é…æŒ‡é’ˆè¯­ä¹‰)
`Box<T>` æä¾›å †ä¸ŠTçš„å”¯ä¸€æ‰€æœ‰æƒï¼š
$$\text{Box}\langle T \rangle \cong \text{Owned}(\text{Heap}(T))$$

```rust
// Boxè¯­ä¹‰åˆ†æ
fn box_semantics() {
    // 1. å †åˆ†é…ä¸æ‰€æœ‰æƒ
    let boxed_value = Box::new(42);
    
    // 2. è§£å¼•ç”¨è¯­ä¹‰
    assert_eq!(*boxed_value, 42);
    
    // 3. ç§»åŠ¨è¯­ä¹‰
    let moved_box = boxed_value;
    // println!("{}", boxed_value); // ç¼–è¯‘é”™è¯¯ï¼šå€¼å·²ç§»åŠ¨
    
    // 4. é€’å½’ç±»å‹æ„é€ 
    enum List {
        Nil,
        Cons(i32, Box<List>),
    }
    
    let list = List::Cons(1, Box::new(
        List::Cons(2, Box::new(List::Nil))
    ));
}
```

### 2.7.2 `Rc<T>`å’Œ`Arc<T>`è¯­ä¹‰

**å®šä¹‰ 2.7.2** (å¼•ç”¨è®¡æ•°æŒ‡é’ˆè¯­ä¹‰)

- `Rc<T>`: å•çº¿ç¨‹å¼•ç”¨è®¡æ•°
- `Arc<T>`: åŸå­å¼•ç”¨è®¡æ•°

$$\text{Rc}\langle T \rangle \cong \text{Shared}(\text{Heap}(T)) \times \text{RefCount}$$

```rust
// å¼•ç”¨è®¡æ•°è¯­ä¹‰
use std::rc::Rc;
use std::sync::Arc;

fn reference_counting_semantics() {
    // 1. Rcè¯­ä¹‰ï¼šå…±äº«æ‰€æœ‰æƒ
    let data = Rc::new(vec![1, 2, 3]);
    let data1 = Rc::clone(&data);
    let data2 = Rc::clone(&data);
    
    assert_eq!(Rc::strong_count(&data), 3);
    
    // 2. Arcè¯­ä¹‰ï¼šçº¿ç¨‹å®‰å…¨å…±äº«
    let shared_data = Arc::new(42);
    let handles: Vec<_> = (0..10).map(|_| {
        let data = Arc::clone(&shared_data);
        std::thread::spawn(move || {
            println!("Thread sees: {}", *data);
        })
    }).collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 2. 8 å¤åˆç±»å‹çš„ç±»å‹ç†è®º

### 2.8.1 ç§¯ç±»å‹ä¸å’Œç±»å‹çš„å¯¹å¶æ€§

**å®šç† 2.8.1** (ç§¯å’Œå¯¹å¶æ€§)
åœ¨ç±»å‹èŒƒç•´ä¸­ï¼Œç§¯ç±»å‹ä¸å’Œç±»å‹æ»¡è¶³åˆ†é…å¾‹ï¼š
$$A \times (B + C) \cong (A \times B) + (A \times C)$$

**åº”ç”¨ç¤ºä¾‹**ï¼š

```rust
// ç±»å‹åˆ†é…å¾‹çš„Rustè¡¨ç¤º
enum Either<B, C> {
    Left(B),
    Right(C),
}

struct ProductLeft<A, B>(A, B);
struct ProductRight<A, C>(A, C);

enum Distributed<A, B, C> {
    Left(ProductLeft<A, B>),
    Right(ProductRight<A, C>),
}

// (A, Either<B, C>) â‰… Distributed<A, B, C>
```

### 2.8.2 é€’å½’ç±»å‹çš„ä¸åŠ¨ç‚¹è¯­ä¹‰

**å®šä¹‰ 2.8.2** (é€’å½’ç±»å‹ä¸åŠ¨ç‚¹)
é€’å½’ç±»å‹ `T = F(T)` çš„è¯­ä¹‰ä¸ºå‡½å­ `F` çš„æœ€å°ä¸åŠ¨ç‚¹ï¼š
$$T = \mu F = \text{fix}(F)$$

```rust
// é€’å½’ç±»å‹ç¤ºä¾‹
enum Tree<T> {
    Leaf(T),
    Node(Box<Tree<T>>, Box<Tree<T>>),
}

// Tree<T> = T + (Tree<T> Ã— Tree<T>)
// å³ Tree = Î¼X. T + (X Ã— X)
```

---

## 2. 9 å¤åˆç±»å‹çš„å†…å­˜å¸ƒå±€ä¼˜åŒ–

### 2.9.1 ç»“æ„ä½“å­—æ®µé‡æ’

**å†…å­˜å¸ƒå±€ä¼˜åŒ–è§„åˆ™**ï¼š

1. **å¯¹é½è¦æ±‚**: å­—æ®µæŒ‰ç…§å¯¹é½è¦æ±‚æ’åˆ—
2. **å¡«å……æœ€å°åŒ–**: å‡å°‘å†…å­˜å¡«å……
3. **ç¼“å­˜å‹å¥½**: è€ƒè™‘CPUç¼“å­˜è¡Œå¤§å°

```rust
// å†…å­˜å¸ƒå±€æ¯”è¾ƒ
#[repr(C)]  // Cè¯­è¨€å…¼å®¹å¸ƒå±€
struct UnoptimizedStruct {
    a: u8,     // 1å­—èŠ‚
    b: u64,    // 8å­—èŠ‚ï¼Œéœ€è¦7å­—èŠ‚å¡«å……
    c: u8,     // 1å­—èŠ‚ï¼Œéœ€è¦7å­—èŠ‚å¡«å……
}  // æ€»è®¡ï¼š24å­—èŠ‚

#[repr(C)]
struct OptimizedStruct {
    b: u64,    // 8å­—èŠ‚
    a: u8,     // 1å­—èŠ‚
    c: u8,     // 1å­—èŠ‚ï¼Œå…±2å­—èŠ‚ï¼Œéœ€è¦6å­—èŠ‚å¡«å……
}  // æ€»è®¡ï¼š16å­—èŠ‚
```

### 2.9.2 æšä¸¾è¡¨ç¤ºä¼˜åŒ–

```rust
// æšä¸¾ä¼˜åŒ–ç¤ºä¾‹
enum OptimizedEnum {
    Variant1,                    // 0å­—èŠ‚æ•°æ®
    Variant2(NonZeroU32),       // éé›¶ä¼˜åŒ–
    Variant3(Box<i32>),         // ç©ºæŒ‡é’ˆä¼˜åŒ–
}

// ç”±äºä¼˜åŒ–ï¼Œå¯èƒ½ä¸éœ€è¦é¢å¤–çš„åˆ¤åˆ«å¼å­—æ®µ
```

---

## 2. 10 è·¨å¼•ç”¨ç½‘ç»œ

### 2.10.1 å†…éƒ¨å¼•ç”¨

- [åŸå§‹ç±»å‹è¯­ä¹‰](01_primitive_types_semantics.md) - æ„å»ºå¤åˆç±»å‹çš„åŸºç¡€
- [ç±»å‹æ¨æ–­è¯­ä¹‰](06_type_inference_semantics.md) - å¤åˆç±»å‹çš„æ¨æ–­è§„åˆ™
- [å†…å­˜æ¨¡å‹è¯­ä¹‰](../03_memory_model_semantics/01_memory_layout_semantics.md) - å†…å­˜å¸ƒå±€ç»†èŠ‚

### 2.10.2 å¤–éƒ¨å¼•ç”¨

- [æ‰€æœ‰æƒç³»ç»Ÿè¯­ä¹‰](../04_ownership_system_semantics/01_ownership_rules_semantics.md) - å¤åˆç±»å‹çš„æ‰€æœ‰æƒè§„åˆ™
- [æ³›å‹ç³»ç»Ÿè¯­ä¹‰](../../05_transformation_semantics/04_generic_system_semantics/01_generic_parameters_semantics.md) - æ³›å‹å¤åˆç±»å‹
- [traitç³»ç»Ÿè¯­ä¹‰](../../05_transformation_semantics/03_trait_system_semantics/01_trait_definition_semantics.md) - ç±»å‹èƒ½åŠ›æ‰©å±•

---

## 2. 11 ç†è®ºå‰æ²¿ä¸å‘å±•æ–¹å‘

### 2.11.1 ä¾èµ–ç±»å‹æ‰©å±•

1. **é•¿åº¦ç´¢å¼•ç±»å‹**: `Vec<T, n>` å…¶ä¸­ `n` æ˜¯ç¼–è¯‘æ—¶å·²çŸ¥é•¿åº¦
2. **æ•ˆæœç±»å‹**: åœ¨ç±»å‹ä¸­ç¼–ç å‰¯ä½œç”¨ä¿¡æ¯
3. **çº¿æ€§ç±»å‹**: èµ„æºä½¿ç”¨çš„ç²¾ç¡®æ§åˆ¶

### 2.11.2 é«˜çº§ç±»å‹æ„é€ 

1. **é«˜é˜¶ç§ç±»**: `type Constructor<F<_>>`
2. **å…³è”ç±»å‹æ—**: æ›´çµæ´»çš„ç±»å‹å…³è”
3. **ç±»å‹çº§è®¡ç®—**: ç¼–è¯‘æ—¶ç±»å‹è®¡ç®—

---

## 2. 12 æŒç»­æ”¹è¿›ä¸ç‰ˆæœ¬è¿½è¸ª

### 2.12.1 æ–‡æ¡£ç‰ˆæœ¬

- **ç‰ˆæœ¬**: v1.0.0
- **åˆ›å»ºæ—¥æœŸ**: 2024-12-30
- **æœ€åæ›´æ–°**: 2024-12-30
- **çŠ¶æ€**: æ ¸å¿ƒå†…å®¹å®Œæˆ

### 2.12.2 æ”¹è¿›è®¡åˆ’

- [ ] æ·»åŠ æ›´å¤šé«˜çº§å¤åˆç±»å‹ç¤ºä¾‹
- [ ] æ·±åŒ–å†…å­˜å¸ƒå±€ä¼˜åŒ–åˆ†æ
- [ ] å®Œå–„é€’å½’ç±»å‹çš„å½¢å¼åŒ–å¤„ç†
- [ ] å¢åŠ æ€§èƒ½æµ‹è¯•æ¡ˆä¾‹

---

> **é“¾æ¥ç½‘ç»œ**: [ç±»å‹ç³»ç»Ÿè¯­ä¹‰æ¨¡å‹ç´¢å¼•](00_type_system_semantics_index.md) | [åŸºç¡€è¯­ä¹‰å±‚æ€»è§ˆ](../00_foundation_semantics_index.md) | [æ ¸å¿ƒç†è®ºæ¡†æ¶](../../00_core_theory_index.md)
