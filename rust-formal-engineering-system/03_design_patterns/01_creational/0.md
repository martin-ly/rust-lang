# 设计模式

设计模式是软件开发中经过验证的解决方案模板，用于解决在特定环境条件下反复出现的特定问题。
它们是独立于编程语言的，可以应用于任何软件开发过程中。
设计模式主要分为三大类：

## 1. **创建型模式**（Creational Patterns）：这些模式提供了对象创建的机制，增加了现有代码的灵活性和重用性

常见的创建型模式包括：

- 原型模式（Prototype）：一个完全初始化的实例，作为创建其他对象的模型。
- 单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
- 建造者模式（Builder）：将一个复杂对象的构建与其表示分离，允许使用相同的构建过程来创建不同的表示。
- 工厂方法模式（Factory Method）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。
- 抽象工厂模式（Abstract Factory）：创建一个相关或依赖对象的家族，而不指定它们的具体类。

## 2. **结构型模式**（Structural Patterns）：这些模式处理对象组合，通常涉及类或对象之间的关系

常见的结构型模式包括：

- 适配器模式（Adapter）：允许具有不兼容接口的对象一起工作，通过将现有对象包装在适配器中。
- 桥接模式（Bridge）：将抽象与其实现解耦，以便两者可以独立变化。
- 装饰器模式（Decorator）：通过将对象包装在额外的层中，动态地向对象添加行为。
- 外观模式（Facade）：为复杂的子系统提供一个简化的接口。
- 享元模式（Flyweight）：通过尽可能多地与相似对象共享数据，最小化内存使用。
- 组合模式（Composite）：允许客户端统一地对待单个对象和对象的组合。

## 3. **行为型模式**（Behavioral Patterns）：这些模式关注对象之间的交互以及它们如何分配责任

常见的行为型模式包括：

- 命令模式（Command）：将请求封装为一个对象，从而允许用不同的请求参数化客户端。
- 解释器模式（Interpreter）：定义一种语言的语法，并提供解释器来处理它。
- 迭代器模式（Iterator）：顺序访问集合的元素，而不暴露其底层表示。
- 责任链模式（Chain of Responsibility）：允许将请求沿着潜在的处理者链传递，直到其中一个处理它。
- 中介者模式（Mediator）：定义一个对象，封装一组对象之间的交互。
- 观察者模式（Observer）：定义对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖项都会自动通知并更新。
- 状态模式（State）：当其内部状态改变时，改变实例的行为。  
- 策略模式（Strategy）：定义一系列算法，将每个算法封装起来，并使它们可以互换。

每种模式都有其自身的上下文、问题、解决方案和后果。
它们不是用来盲目应用的，而是需要根据正在开发的软件的具体需求进行调整。

## 4. 并发和并行设计模式(concurrent parallel pattern)主要关注如何有效地利用多核处理器和多线程来提高程序的执行效率

以下是一些常见的并发和并行设计模式：

### 1. **并行模式**

- **Pipeline（流水线模式）**：将任务分解成多个阶段，每个阶段可以并行处理，从而提高整体的执行效率。
- **Master-Worker（主从模式）**：一个或多个主线程分配任务给一组工作线程，工作线程并行执行任务。

### 2. **并发模式**

- **Thread Pool（线程池模式）**：预先创建一组线程，用于执行任务，以避免频繁创建和销毁线程的开销。
- **Future and Promise（未来和承诺模式）**：Future表示一个尚未完成的异步计算的结果，而Promise用于表示一个异步操作的最终结果。
- **Reactor（反应器模式）**：通过非阻塞I/O操作来处理多个I/O请求，通常与事件循环一起使用。
- **Proactor（提议者模式）**：与反应器模式类似，但用于异步I/O操作，它在操作完成时通知应用程序。

### 3. **同步模式**

- **Monitor Object（监视器对象模式）**：一个对象负责协调对共享资源的访问，通常使用锁来实现。
- **Lock/Mutex（锁/互斥锁模式）**：用于控制对共享资源的访问，防止多个线程同时访问。
- **Semaphore（信号量模式）**：一种计数器，用于控制对共享资源的访问数量。
- **Barrier（屏障模式）**：一种同步机制，用于确保所有线程在继续执行之前都到达某个点。

### 4. **数据共享模式**

- **ReadWrite Lock（读写锁模式）**：允许多个线程同时读取数据，但写入时需要独占访问。
- **Copy-on-Write（写时复制模式）**：在修改数据之前复制数据，以减少对共享数据的锁定时间。

### 5. **任务分解模式**

- **Task Decomposition（任务分解模式）**：将大任务分解成多个小任务，这些小任务可以在不同的线程或进程中并行执行。

### 6. **工作窃取模式**

- **Work Stealing（工作窃取模式）**：工作线程从其他线程的任务队列中窃取任务来执行，以平衡负载。

### 7. **Actor模型**

- **Actor（参与者模式）**：每个Actor是一个并发执行的实体，拥有自己的状态和行为，并通过消息传递与其他Actor通信。

这些模式可以帮助开发者设计出能够充分利用现代多核处理器的并发程序。然而，设计并发程序时还需要考虑线程安全、死锁、竞态条件等并发问题。
