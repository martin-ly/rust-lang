# 2.4 生命周期系统

## 1. 核心问题: 防止悬垂引用

生命周期（Lifetimes）并非一种需要"学习"的语言特征，而是 Rust 编译器用来理解和验证引用有效性的一种**形式化工具**。其唯一目标是杜绝 **悬垂引用（Dangling References）**——即指向已被释放内存的引用。

考虑以下 C++ 风格的不安全代码：

```rust,ignore
// 这是一个无法在 Rust 中编译的、不安全逻辑的例子
fn get_dangling_reference() -> &i32 {
    let x = 5;
    &x // 返回对 x 的引用
} // x 在此处被销毁，其内存被释放

fn main() {
    let r = get_dangling_reference();
    println!("{}", *r); // `r` 是悬垂引用，解引用是未定义行为！
}
```

生命周期系统就是 Rust 编译器用来静态地（在编译时）证明此类代码不安全并拒绝其编译的形式化方法。

## 2. 生命周期的形式化: 区域与约束

在形式化模型中，生命周期可以被理解为 **区域（Regions）**，即代码中的一段作用域。借用检查器为程序中的每个作用域和引用都分配一个区域变量（如 `'a`, `'b`）。然后，它通过分析代码生成一组 **"outlives" 约束**。

**定义 2.1 (区域与 Outlives 约束)**:

- **区域 (Region)**: 一个生命周期 `'a` 代表了程序中的一个代码区域。
- **Outlives 约束 (`'a: 'b`)**: 表示区域 `'a` 必须包含（或"活得比"）区域 `'b` 长。从集合论的角度看，这意味着 `'b` 所代表的程序点集合是 `'a` 的子集 (`'b ⊆ 'a`)。

借用检查的核心规则可以形式化为一个约束：
**对于任何引用 `let r = &x;`，其引用的生命周期 `'ref` 必须被其引用的值的生命周期 `'val` 所包含，即 `'val: 'ref`。**

对于上面的不安全例子，分析如下：

1. `let x = 5;`: 变量 `x` 的生命周期是函数 `get_dangling_reference` 的作用域，我们称之为 `'x_scope`。
2. `&x`: 创建了一个引用，其生命周期是函数返回值的生命周期，我们称之为 `'return`。
3. **生成约束**: 根据核心规则，必须满足 `'x_scope: 'return`。
4. **求解约束**: 编译器发现，`'x_scope` 在函数结束时就终结了，而 `'return` 必须在函数调用点（`main` 函数中）之后仍然有效。因此，`'x_scope` 显然 **不能** 活得比 `'return` 长。
5. **结论**: 约束无法被满足，编译失败。

## 3. 函数签名中的生命周期

当函数签名中涉及引用时，我们需要显式地告诉编译器不同引用生命周期之间的关系，以便它可以在调用点生成并验证约束。

```rust
// 通过使用同一个生命周期参数 'a，我们告诉编译器：
// 1. x 和 y 的生命周期必须相互关联。
// 2. 返回的引用的生命周期不能超过 x 和 y 中较短的那个。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**形式化分析**:

1. **函数签名中的约束**: `fn longest<'a>(...) -> &'a str` 建立了内部约束：两个输入引用和输出引用的生命周期都是 `'a`。
2. **调用点的分析**:

    ```rust
    let string1 = String::from("long"); // 生命周期 's1
    let result;
    {
        let string2 = String::from("xyz"); // 生命周期 's2
        result = longest(&string1, &string2); // 调用 longest
    } // 's2 结束
    // println!("{}", result); // 编译错误！
    ```

3. **生成约束**:
    - `longest` 的调用将 `&string1` 的生命周期（受 `'s1` 约束）和 `&string2` 的生命周期（受 `'s2` 约束）统一为 `'a`。
    - 这意味着 `'a` 必须同时满足 `'s1: 'a` 和 `'s2: 'a`。因此，`'a` 最多只能和 `'s1` 与 `'s2` 中较短的那个一样长，即 `'s2`。
    - 返回的 `result` 的生命周期也是 `'a`。所以 `result` 的生命周期不能超过 `'s2`。
4. **求解约束**: 当 `println!` 尝试使用 `result` 时，`string2` 已经被销毁，`'s2` 已经结束。但 `result` 仍然要求 `'s2` 是活跃的，约束无解，编译失败。

## 4. 生命周期省略规则 (Elision Rules)

为了方便，编译器遵循一套 **省略规则** 来自动推断最常见的生命周期关系，让你不必在每个函数上都写显式标注。

1. **输入规则**: 每个作为输入的引用都被赋予一个独立的生命周期参数。
    - `fn foo(&T)` 变成 `fn foo<'a>(&'a T)`。
    - `fn foo(&T, &U)` 变成 `fn foo<'a, 'b>(&'a T, &'b U)`。
2. **输出规则**: 如果只有一个输入生命周期，那么该生命周期被赋给所有输出引用。
    - `fn foo(&T) -> &U` 变成 `fn foo<'a>(&'a T) -> &'a U`。
3. **方法规则**: 如果有多个输入生命周期，但其中一个是 `&self` 或 `&mut self`，那么 `self` 的生命周期被赋给所有输出引用。
    - `impl T { fn method(&self, &U) -> &V { ... } }` 变成 `impl T { fn method<'a, 'b>(&'a self, &'b U) -> &'a V { ... } }`。

如果这些规则应用后，输出引用的生命周期仍然不确定，编译器就会报错，要求显式标注。

## 5. 特殊生命周期: `'static`

`'static` 是一个预定义的、特殊的生命周期，它表示一个引用可以在程序的整个运行期间都保持有效。

- **来源**:
    1. **字符串字面量**: `let s: &'static str = "Hello";`，因为字符串字面量被直接编译进程序的二进制数据段。
    2. **静态变量**: `static X: i32 = 5; let r: &'static i32 = &X;`。
    3. **泄露的内存**: 通过 `Box::leak()` 创建的引用，其所有权被放弃，因此可以在程序剩余的生命周期内有效。
- **`T: 'static` 约束**:
  - 这是一个泛型约束，表示类型 `T` 本身不包含任何比 `'static` 短的借用。
  - 例如 `String` 类型满足 `String: 'static`，因为它拥有其所有数据。但 `&'a String` 不满足（除非 `'a` 是 `'static`）。
  - 这个约束在多线程编程中很常见（`thread::spawn` 要求闭包是 `'static`），以确保线程不会意外地引用主线程栈上可能被销毁的数据。

---

## 附：索引锚点与导航

### 生命周期定义 {#生命周期定义}

用于跨文档引用，统一指向本篇对生命周期的核心定义与约束。

### 推断算法 {#推断算法}

用于跨文档引用，统一指向生命周期推断相关的算法与规则。

### 省略规则 {#省略规则}

用于跨文档引用，统一指向生命周期省略（Elision）规则。

### 函数生命周期规则 {#函数生命周期规则}

用于跨文档引用，统一指向函数签名中的生命周期规则与约束。

### 生命周期组合 {#生命周期组合}

用于跨文档引用，统一指向生命周期与借用/作用域的组合与传播。
